
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -b -q -L rom.lst -o rom.bin basic.asm
; Mon Aug 19 11:08:49 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="65816"				CPU = "65816"
="em65816"				HARDWARE = "em65816"

;******  Processing file: modules/float/fpmacros.inc


;******  Return to file: _include.asm


;******  Processing file: modules/common/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zLTemp1:	.dword ?						; long word (used in multiply)
>001a					zGenPtr:	.word ? 						; general pointer.
>0200					IFT_XCursor:.byte ?							; current logical position on screen
>0201					IFT_YCursor:.byte ?
>0202					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0266					IFT_LineBuffer: .fill 100 					; line input buffer.
>0300					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>0304					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>0305					XS_Type 	.byte ? 						; bit 7 sign (float only)
=774					XS2_Mantissa = XS_Mantissa+6
=778					XS2_Exponent = XS_Exponent+6
=779					XS2_Type = XS_Type+6
>0400					Num_Buffer	.fill 	32 						; buffer for numeric conversions
>0420					NumBufX 	.byte 	?						; buffer index position
>0421					NumSuppress	.byte 	?						; leading zero suppression flag
>0422					NumConvCount .byte 	? 						; count for conversions.
>0423					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>0425					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>0427					Tim_SR:		.byte ? 						; Processor Status
>0428					Tim_A:		.byte ? 						; Processor Registers
>0429					Tim_X:		.byte ?
>042a					Tim_Y:		.byte ?
>042b					Tim_Z:		.byte ?
>042c					Tim_SP:		.byte ?							; Stack Pointer
>042d					ExpTemp:	.byte ?							; Working temp for exponents.
>042e					ExpCount:	.byte ? 						; Count of decimal exponents.

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/em65816.asm

.c000					StartROM:
.c000	18		clc				clc
.c001	fb		xce				xce
.c002	c2 30		rep #$30			rep 	#$30
.c004	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.c007	1b		tcs				tcs
.c008	e2 30		sep #$30			sep 	#$30
.c00a	c2 30		rep #$30			rep 	#$30
.c00c	a9 00 00	lda #$0000			lda 	#$0000
.c00f	aa		tax				tax
.c010	a8		tay				tay
.c011	e2 30		sep #$30			sep 	#$30
.c013	20 b7 c1	jsr $c1b7			jsr 	IF_Reset 					; reset external interface
.c016	20 1c c0	jsr $c01c			jsr 	IFT_ClearScreen
.c019	4c 06 c2	jmp $c206		jmp BASIC_Start

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.c01c					IFT_ClearScreen:
.c01c	48		pha				pha
.c01d	da		phx				phx
.c01e	5a		phy				phy
.c01f	20 b8 c1	jsr $c1b8			jsr 	IF_Home 					; home cursor
.c022	a2 20		ldx #$20			ldx 	#IF_Height 					; this many lines.
.c024					_IFT_CS0:
.c024	a0 40		ldy #$40			ldy 	#IF_Width 					; this many chars/line
.c026					_IFT_CS1:
.c026	a9 20		lda #$20			lda 	#' '						; clear line.
.c028	20 e4 c1	jsr $c1e4			jsr 	IF_Write
.c02b	88		dey				dey
.c02c	d0 f8		bne $c026			bne 	_IFT_CS1
.c02e	20 cb c1	jsr $c1cb			jsr 	IF_NewLine 					; next line down
.c031	ca		dex				dex
.c032	d0 f0		bne $c024			bne 	_IFT_CS0
.c034	7a		ply				ply
.c035	fa		plx				plx
.c036	68		pla				pla
.c037					IFT_HomeCursor:
.c037	48		pha				pha
.c038	20 b8 c1	jsr $c1b8			jsr 	IF_Home
.c03b	a9 00		lda #$00			lda 	#0
.c03d	8d 00 02	sta $0200			sta 	IFT_XCursor
.c040	8d 01 02	sta $0201			sta 	IFT_YCursor
.c043	68		pla				pla
.c044	60		rts				rts
.c045					IFT_UpLine:
.c045	48		pha				pha
.c046	ad 01 02	lda $0201			lda  	IFT_YCursor 				; get Y
.c049	3a		dec a				dec 	a 							; line above
.c04a	30 03		bmi $c04f			bmi 	_IFTULExit 					; too far, abort
.c04c	20 da c0	jsr $c0da			jsr 	IFT_SetYPos					; set to that line.
.c04f					_IFTULExit:
.c04f	68		pla				pla
.c050	60		rts				rts
.c051					IFT_PrintCharacter:
.c051	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.c053	f0 16		beq $c06b			beq 	IFT_NewLine
.c055	48		pha				pha
.c056	20 83 c0	jsr $c083			jsr 	IFT_UpperCase 				; make upper case
.c059	20 e4 c1	jsr $c1e4			jsr 	IF_Write 					; write out.
.c05c	ee 00 02	inc $0200			inc 	IFT_XCursor 				; bump x cursor
.c05f	ad 00 02	lda $0200			lda 	IFT_XCursor 				; reached RHS ?
.c062	c9 40		cmp #$40			cmp 	#IF_Width
.c064	d0 03		bne $c069			bne 	_IFT_PCNotEOL
.c066	20 6b c0	jsr $c06b			jsr 	IFT_NewLine 				; if so do new line.
.c069					_IFT_PCNotEOL:
.c069	68		pla				pla
.c06a	60		rts				rts
.c06b					IFT_NewLine:
.c06b	48		pha				pha
.c06c	20 cb c1	jsr $c1cb			jsr 	IF_NewLine 					; new line on actual screen.
.c06f	a9 00		lda #$00			lda 	#0 							; reset x position
.c071	8d 00 02	sta $0200			sta 	IFT_XCursor
.c074	ee 01 02	inc $0201			inc 	IFT_YCursor 				; move down.
.c077	ad 01 02	lda $0201			lda 	IFT_YCursor
.c07a	c9 20		cmp #$20			cmp 	#IF_Height 					; reached bottom.
.c07c	d0 03		bne $c081			bne 	_IFT_NL_NotEOS
.c07e	20 8e c0	jsr $c08e			jsr 	IFT_Scroll 					; scroll screen up.
.c081					_IFT_NL_NotEOS:
.c081	68		pla				pla
.c082	60		rts				rts
.c083					IFT_UpperCase:
.c083	c9 61		cmp #$61			cmp 	#"a"
.c085	90 06		bcc $c08d			bcc 	_IFT_UCExit
.c087	c9 7b		cmp #$7b			cmp 	#"z"+1
.c089	b0 02		bcs $c08d			bcs 	_IFT_UCExit
.c08b	49 20		eor #$20			eor 	#$20
.c08d					_IFT_UCExit:
.c08d	60		rts				rts
.c08e					IFT_Scroll:
.c08e	48		pha				pha 								; save AXY
.c08f	da		phx				phx
.c090	5a		phy				phy
.c091	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.c093					_IFT_SLoop:
.c093	20 b3 c0	jsr $c0b3			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.c096	e8		inx				inx
.c097	e0 1f		cpx #$1f			cpx 	#IF_Height-1				; do whole screen
.c099	d0 f8		bne $c093			bne 	_IFT_SLoop
.c09b	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.c09d	20 da c0	jsr $c0da			jsr 	IFT_SetYPos
.c0a0	a2 40		ldx #$40			ldx 	#IF_Width 					; blank line
.c0a2					_IFT_SBlank:
.c0a2	a9 20		lda #$20			lda 	#32
.c0a4	20 e4 c1	jsr $c1e4			jsr 	IF_Write
.c0a7	ca		dex				dex
.c0a8	d0 f8		bne $c0a2			bne 	_IFT_SBlank
.c0aa	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.c0ac	20 da c0	jsr $c0da			jsr 	IFT_SetYPos
.c0af	7a		ply				ply
.c0b0	fa		plx				plx
.c0b1	68		pla				pla
.c0b2	60		rts				rts
.c0b3					_IFT_ScrollLine:
.c0b3	da		phx				phx
.c0b4	da		phx				phx
.c0b5	8a		txa				txa 								; copy line into buffer.
.c0b6	1a		inc a				inc 	a 							; next line down.
.c0b7	20 da c0	jsr $c0da			jsr 	IFT_SetYPos
.c0ba	a2 00		ldx #$00			ldx 	#0
.c0bc					_IFTScrollCopy1:
.c0bc	20 db c1	jsr $c1db			jsr 	IF_Read
.c0bf	9d 02 02	sta $0202,x			sta 	IFT_Buffer,x
.c0c2	e8		inx				inx
.c0c3	e0 40		cpx #$40			cpx 	#IF_Width
.c0c5	d0 f5		bne $c0bc			bne 	_IFTScrollCopy1
.c0c7	68		pla				pla
.c0c8	20 da c0	jsr $c0da			jsr 	IFT_SetYPos
.c0cb	a2 00		ldx #$00			ldx 	#0
.c0cd					_IFTScrollCopy2:
.c0cd	bd 02 02	lda $0202,x			lda 	IFT_Buffer,x
.c0d0	20 e4 c1	jsr $c1e4			jsr 	IF_Write
.c0d3	e8		inx				inx
.c0d4	e0 40		cpx #$40			cpx 	#IF_Width
.c0d6	d0 f5		bne $c0cd			bne 	_IFTScrollCopy2
.c0d8	fa		plx				plx
.c0d9	60		rts				rts
.c0da					IFT_SetYPos:
.c0da	48		pha				pha
.c0db	da		phx				phx
.c0dc	aa		tax				tax
.c0dd	20 37 c0	jsr $c037			jsr 	IFT_HomeCursor
.c0e0	e0 00		cpx #$00			cpx 	#0
.c0e2	f0 09		beq $c0ed			beq 	_IFT_MOAExit
.c0e4					_IFT_MOALoop:
.c0e4	20 cb c1	jsr $c1cb			jsr 	IF_NewLine
.c0e7	ee 01 02	inc $0201			inc 	IFT_YCursor
.c0ea	ca		dex				dex
.c0eb	d0 f7		bne $c0e4			bne		_IFT_MOALoop
.c0ed					_IFT_MOAExit:
.c0ed	fa		plx				plx
.c0ee	68		pla				pla
.c0ef	60		rts				rts
.c0f0					IFT_GetKeyCursor:
.c0f0	20 f8 c0	jsr $c0f8			jsr 	_IFT_FlipCursor 			; reverse current
.c0f3					_IFT_GKCWait:
.c0f3	20 f5 c1	jsr $c1f5			jsr 	IF_GetKey 					; get key
.c0f6	f0 fb		beq $c0f3			beq 	_IFT_GKCWait
.c0f8					_IFT_FlipCursor:
.c0f8	48		pha				pha 								; save
.c0f9	20 db c1	jsr $c1db			jsr 	IF_Read 					; read
.c0fc	20 ed c1	jsr $c1ed			jsr 	IF_LeftOne
.c0ff	49 80		eor #$80			eor 	#$80 						; reverse
.c101	20 e4 c1	jsr $c1e4			jsr 	IF_Write 					; write
.c104	20 ed c1	jsr $c1ed			jsr 	IF_LeftOne
.c107	68		pla				pla
.c108	60		rts				rts
.c109					IFT_ReadLine:
.c109	48		pha				pha
.c10a					_IFT_RLLoop:
.c10a	20 f0 c0	jsr $c0f0			jsr 	IFT_GetKeyCursor 			; get keystroke
.c10d	c9 0d		cmp #$0d			cmp 	#13							; return
.c10f	f0 7d		beq $c18e			beq 	_IFT_RLExit
.c111	c9 20		cmp #$20			cmp 	#32 						; control character
.c113	90 05		bcc $c11a			bcc 	_IFT_Control
.c115	20 51 c0	jsr $c051			jsr 	IFT_PrintCharacter
.c118	80 f0		bra $c10a			bra 	_IFT_RLLoop
.c11a					_IFT_Control:
.c11a	c9 01		cmp #$01			cmp 	#"A"-64
.c11c	f0 26		beq $c144			beq 	_IFT_Left
.c11e	c9 04		cmp #$04			cmp 	#"D"-64
.c120	f0 2e		beq $c150			beq 	_IFT_Right
.c122	c9 17		cmp #$17			cmp 	#"W"-64
.c124	f0 36		beq $c15c			beq 	_IFT_Up
.c126	c9 13		cmp #$13			cmp 	#"S"-64
.c128	f0 3e		beq $c168			beq 	_IFT_Down
.c12a	c9 08		cmp #$08			cmp 	#"H"-64
.c12c	f0 09		beq $c137			beq 	_IFT_Backspace
.c12e	c9 1a		cmp #$1a			cmp 	#"Z"-64
.c130	d0 d8		bne $c10a			bne 	_IFT_RLLoop
.c132	20 1c c0	jsr $c01c			jsr 	IFT_ClearScreen				; clear CTL-Z
.c135	80 d3		bra $c10a			bra 	_IFT_RLLoop
.c137					_IFT_Backspace:
.c137	ad 00 02	lda $0200			lda 	IFT_XCursor 				; check not start of line.
.c13a	f0 ce		beq $c10a			beq 	_IFT_RLLoop
.c13c	20 ed c1	jsr $c1ed			jsr 	IF_LeftOne
.c13f	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.c141	20 e4 c1	jsr $c1e4			jsr 	IF_Write
.c144					_IFT_Left:
.c144	ce 00 02	dec $0200			dec 	IFT_XCursor 				; left CTL-W
.c147	10 29		bpl $c172			bpl 	_IFT_Reposition
.c149	a9 3f		lda #$3f			lda 	#IF_Width-1
.c14b					_IFT_SetX:
.c14b	8d 00 02	sta $0200			sta 	IFT_XCursor
.c14e	80 22		bra $c172			bra 	_IFT_Reposition
.c150					_IFT_Right:
.c150	ee 00 02	inc $0200			inc 	IFT_XCursor
.c153	ad 00 02	lda $0200			lda 	IFT_XCursor
.c156	49 40		eor #$40			eor 	#IF_Width
.c158	f0 f1		beq $c14b			beq 	_IFT_SetX
.c15a	80 16		bra $c172			bra 	_IFT_Reposition
.c15c					_IFT_Up:
.c15c	ce 01 02	dec $0201			dec 	IFT_YCursor
.c15f	10 11		bpl $c172			bpl 	_IFT_Reposition
.c161	a9 1f		lda #$1f			lda 	#IF_Height-1
.c163					_IFT_SetY:
.c163	8d 01 02	sta $0201			sta 	IFT_YCursor
.c166	80 0a		bra $c172			bra 	_IFT_Reposition
.c168					_IFT_Down:
.c168	ee 01 02	inc $0201			inc 	IFT_YCursor
.c16b	ad 01 02	lda $0201			lda 	IFT_YCursor
.c16e	49 20		eor #$20			eor 	#IF_Height
.c170	f0 f1		beq $c163			beq 	_IFT_SetY
.c172					_IFT_Reposition:
.c172	ad 00 02	lda $0200			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.c175	48		pha				pha
.c176	ad 01 02	lda $0201			lda 	IFT_YCursor
.c179	20 da c0	jsr $c0da			jsr 	IFT_SetYPos
.c17c	68		pla				pla
.c17d	aa		tax				tax
.c17e	e0 00		cpx #$00			cpx 	#0
.c180	f0 88		beq $c10a			beq 	_IFT_RLLoop
.c182					_IFT_MoveRight:
.c182	20 db c1	jsr $c1db			jsr 	IF_Read
.c185	ee 00 02	inc $0200			inc 	IFT_XCursor
.c188	ca		dex				dex
.c189	d0 f7		bne $c182			bne 	_IFT_MoveRight
.c18b	4c 0a c1	jmp $c10a			jmp 	_IFT_RLLoop
.c18e					_IFT_RLExit:
.c18e	ad 01 02	lda $0201			lda 	IFT_YCursor 				; go to start of line.
.c191	20 da c0	jsr $c0da			jsr 	IFT_SetYPos
.c194	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.c196					_IFT_RLRead:
.c196	20 db c1	jsr $c1db			jsr 	IF_Read
.c199	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.c19c	e8		inx				inx
.c19d	e0 40		cpx #$40			cpx 	#IF_Width
.c19f	d0 f5		bne $c196			bne 	_IFT_RLRead
.c1a1					_IFT_RL_Trim:
.c1a1	ca		dex				dex 	 							; previous char
.c1a2	30 07		bmi $c1ab			bmi 	_IFT_Found 					; gone too far
.c1a4	bd 66 02	lda $0266,x			lda 	IFT_LineBuffer,x			; go back if space
.c1a7	c9 20		cmp #$20			cmp 	#" "
.c1a9	f0 f6		beq $c1a1			beq 	_IFT_RL_Trim
.c1ab					_IFT_Found:
.c1ab	e8		inx				inx 								; forward to non-space
.c1ac	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.c1ae	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.c1b1	68		pla				pla
.c1b2	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.c1b4	a0 02		ldy #$02			ldy 	#IFT_LineBuffer >> 8
.c1b6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_em65816.asm

=64					IF_Width 	= 64 							; characters across
=32					IF_Height 	= 32 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line.
=8					IF_XPos 	= 8 							; current position, horizontal.
=$f0000					IF_Screen = $F0000							; 2k screen RAM here
=$f8010					IF_PKeyboard = $F8010						; Keyboard port.
=$f8000					IF_PBreak = $F8000 							; Break key.
.c1b7					IF_Reset:
.c1b7	60		rts				rts
.c1b8					IF_Home:
.c1b8	48		pha				pha
.c1b9	64 08		stz $08				stz 	IF_XPos 					; zero X position
.c1bb	a9 00		lda #$00			lda 	#IF_Screen & $FF 			; set r/w pos.
.c1bd	85 04		sta $04				sta 	IF_Pos
.c1bf	a9 00		lda #$00			lda 	#(IF_Screen >> 8) & $FF
.c1c1	85 05		sta $05				sta 	IF_Pos+1
.c1c3	a9 0f		lda #$0f			lda 	#IF_Screen >> 16
.c1c5	85 06		sta $06				sta 	IF_Pos+2
.c1c7	64 07		stz $07				stz 	IF_Pos+3
.c1c9	68		pla				pla
.c1ca	60		rts				rts
.c1cb					IF_NewLine:
.c1cb	48		pha				pha
.c1cc	64 08		stz $08				stz 	IF_XPos						; back to start of line
.c1ce	18		clc				clc 								; down one line
.c1cf	a5 04		lda $04				lda 	IF_Pos
.c1d1	69 40		adc #$40			adc 	#64
.c1d3	85 04		sta $04				sta 	IF_Pos
.c1d5	90 02		bcc $c1d9			bcc 	_IF_NoCarry 				; carry through.
.c1d7	e6 05		inc $05				inc 	IF_Pos+1
.c1d9					_IF_NoCarry:
.c1d9	68		pla				pla
.c1da	60		rts				rts
.c1db					IF_Read:
.c1db	5a		phy				phy 								; save current Y
.c1dc	a4 08		ldy $08				ldy 	IF_XPos 					; read character at current position
.c1de	b7 04		lda [$04],y			lda 	[IF_Pos],y
.c1e0	e6 08		inc $08				inc 	IF_XPos 					; step right.
.c1e2	7a		ply				ply									; restore Y
.c1e3	60		rts				rts
.c1e4					IF_Write:
.c1e4	5a		phy				phy 								; save current Y
.c1e5	a4 08		ldy $08				ldy 	IF_XPos 					; write character at current position
.c1e7	97 04		sta [$04],y			sta 	[IF_Pos],y
.c1e9	e6 08		inc $08				inc 	IF_XPos 					; step right.
.c1eb	7a		ply				ply									; restore Y
.c1ec	60		rts				rts
.c1ed					IF_LeftOne:
.c1ed	c6 08		dec $08				dec 	IF_XPos
.c1ef	60		rts				rts
.c1f0					IF_CheckBreak:
.c1f0	af 00 80 0f	lda $0f8000			lda 	IF_PBreak					; non-zero if Ctrl+C pressed.
.c1f4	60		rts				rts
.c1f5					IF_GetKey:
.c1f5	af 10 80 0f	lda $0f8010			lda 	IF_PKeyboard				; read keyboard
.c1f9	f0 08		beq $c203			beq		_IFGK_NoKey 				; skip if zero,no key pressed
.c1fb	48		pha				pha 								; key pressed, clear queue.
.c1fc	a9 00		lda #$00			lda 	#0
.c1fe	8f 10 80 0f	sta $0f8010			sta 	IF_PKeyboard
.c202	68		pla				pla
.c203					_IFGK_NoKey:
.c203	09 00		ora #$00			ora 	#0							; set Z flag appropriately.
.c205	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm

.c206					BASIC_Start:
.c206	ea		nop				nop
>c207	02						.byte 	2
.c208					ERR_Handler:
.c208	80 fe		bra $c208			bra 	ERR_Handler

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.c20a					FPSubtract:
.c20a	48		pha				pha
.c20b	bd 0b 03	lda $030b,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.c20e	49 80		eor #$80			eor 	#$80
.c210	9d 0b 03	sta $030b,x			sta 	XS2_Type,x
.c213	68		pla				pla 								; --- and fall through ---
.c214					FPAdd:
.c214	48		pha				pha
.c215	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.c218	d0 05		bne $c21f			bne 	_FPA_NegativeLHS
.c21a	20 3c c2	jsr $c23c			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.c21d	68		pla				pla
.c21e	60		rts				rts
.c21f					_FPA_NegativeLHS:
.c21f	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.c222	49 80		eor #$80			eor 	#$80
.c224	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c227	bd 0b 03	lda $030b,x			lda 	XS2_Type,x 					; flip the sign of B and add
.c22a	49 80		eor #$80			eor 	#$80
.c22c	9d 0b 03	sta $030b,x			sta 	XS2_Type,x
.c22f	20 3c c2	jsr $c23c			jsr 	FPAdd_Worker 				; do the add calculation.
.c232	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; flip sign of X1 back
.c235	49 80		eor #$80			eor 	#$80
.c237	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c23a	68		pla				pla
.c23b	60		rts				rts
.c23c					FPAdd_Worker:
.c23c	3c 0b 03	bit $030b,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.c23f	70 08		bvs $c249			bvs 	_FPAWExit 					; no change.
.c241	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.c244	50 07		bvc $c24d			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.c246	20 e1 c4	jsr $c4e1			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.c249					_FPAWExit:
.c249	20 69 c5	jsr $c569			jsr 	FPUNormalise 				; normalise the result.
.c24c	60		rts				rts
.c24d					_FPAWMakeSame:
.c24d	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.c250	38		sec				sec
.c251	fd 0a 03	sbc $030a,x			sbc	 	XS2_Exponent,x 				; using subtraction
.c254	f0 1b		beq $c271			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.c256	da		phx				phx 								; save X
.c257	90 06		bcc $c25f			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.c259	e8		inx				inx
.c25a	e8		inx				inx
.c25b	e8		inx				inx
.c25c	e8		inx				inx
.c25d	e8		inx				inx
.c25e	e8		inx				inx
.c25f					_FPAWShiftA:
.c25f	fe 04 03	inc $0304,x			inc 	XS_Exponent,x 				; so shift exponent up.
.c262	5e 03 03	lsr $0303,x			lsr 	3+XS_Mantissa,x
.c265	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.c268	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.c26b	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.c26e	fa		plx				plx 								; restore original X
.c26f	80 dc		bra $c24d			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.c271					_FPAW_DoArithmetic:
.c271	3c 0b 03	bit $030b,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.c274	30 39		bmi $c2af			bmi 	_FPAW_BNegative
.c276	18		clc				clc
.c277	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.c27a	7d 06 03	adc $0306,x			adc 	XS2_Mantissa+0,x
.c27d	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c280	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c283	7d 07 03	adc $0307,x			adc 	XS2_Mantissa+1,x
.c286	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c289	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c28c	7d 08 03	adc $0308,x			adc 	XS2_Mantissa+2,x
.c28f	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c292	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c295	7d 09 03	adc $0309,x			adc 	XS2_Mantissa+3,x
.c298	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c29b	90 ac		bcc $c249			bcc 	_FPAWExit 					; no carry.
.c29d	fe 04 03	inc $0304,x			inc 	XS_Exponent,x 				; so shift exponent up.
.c2a0	38		sec				sec
.c2a1	7e 03 03	ror $0303,x			ror 	3+XS_Mantissa,x
.c2a4	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.c2a7	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.c2aa	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.c2ad	80 9a		bra $c249			bra 	_FPAWExit
.c2af					_FPAW_BNegative:
.c2af	38		sec				sec
.c2b0	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.c2b3	fd 06 03	sbc $0306,x			sbc 	XS2_Mantissa+0,x
.c2b6	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c2b9	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c2bc	fd 07 03	sbc $0307,x			sbc 	XS2_Mantissa+1,x
.c2bf	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c2c2	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c2c5	fd 08 03	sbc $0308,x			sbc 	XS2_Mantissa+2,x
.c2c8	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c2cb	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c2ce	fd 09 03	sbc $0309,x			sbc 	XS2_Mantissa+3,x
.c2d1	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c2d4	b0 0b		bcs $c2e1			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.c2d6	20 0e c5	jsr $c50e			jsr 	FPUNegateInteger			; negate the mantissa
.c2d9	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; flip result sign
.c2dc	49 80		eor #$80			eor 	#$80
.c2de	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c2e1					_FPAWGoExit:
.c2e1	4c 49 c2	jmp $c249			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.c2e4					FPD_IsDivZero:
.c2e4	20 08 c2	jsr $c208			jsr 		ERR_Handler
>c2e7	44 69 76 69 73 69 6f 6e				.text 		"Division by zero",0
>c2ef	20 62 79 20 7a 65 72 6f 00
.c2f8					FPDivide:
.c2f8	48		pha				pha
.c2f9	5a		phy				phy
.c2fa	3c 0b 03	bit $030b,x			bit 	XS2_Type,x 					; check if division by zero
.c2fd	70 e5		bvs $c2e4			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.c2ff	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.c302	f0 03		beq $c307			beq 	_FPDCalculateExp
.c304					_FPD_Exit:
.c304	7a		ply				ply
.c305	68		pla				pla
.c306	60		rts				rts
.c307					_FPDCalculateExp:
.c307	bd 0a 03	lda $030a,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.c30a	49 ff		eor #$ff			eor 	#$FF
.c30c	1a		inc a				inc 	a
.c30d	9d 0a 03	sta $030a,x			sta 	XS2_Exponent,x
.c310	20 04 c4	jsr $c404			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.c313	18		clc				clc 	 							; add 1 to the resulting exponent
.c314	69 01		adc #$01			adc 	#1
.c316	b0 65		bcs $c37d			bcs 	_FPD_Overflow 				; which can overflow.
.c318	9d 04 03	sta $0304,x			sta 	XS_Exponent,x
.c31b	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.c31d	85 16		sta $16				sta 	zLTemp1+0
.c31f	85 17		sta $17				sta 	zLTemp1+1
.c321	85 18		sta $18				sta 	zLTemp1+2
.c323	85 19		sta $19				sta 	zLTemp1+3
.c325	a0 20		ldy #$20			ldy 	#32 						; times round.
.c327					_FPD_Loop:
.c327	38		sec				sec 								; calculate X1-X2 stacking result because we might
.c328	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x 				; not save it.
.c32b	fd 06 03	sbc $0306,x			sbc 	XS2_Mantissa,x
.c32e	48		pha				pha
.c32f	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c332	fd 07 03	sbc $0307,x			sbc 	XS2_Mantissa+1,x
.c335	48		pha				pha
.c336	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c339	fd 08 03	sbc $0308,x			sbc 	XS2_Mantissa+2,x
.c33c	48		pha				pha
.c33d	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c340	fd 09 03	sbc $0309,x			sbc 	XS2_Mantissa+3,x
.c343	90 17		bcc $c35c			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.c345	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x 			; save results out to A
.c348	68		pla				pla
.c349	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c34c	68		pla				pla
.c34d	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c350	68		pla				pla
.c351	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c354	a5 19		lda $19				lda 	zLTemp1+3 					; set high bit of result
.c356	09 80		ora #$80			ora 	#$80
.c358	85 19		sta $19				sta 	zLTemp1+3
.c35a	80 03		bra $c35f			bra 	_FPD_Rotates
.c35c					_FPD_NoSubtract:
.c35c	68		pla				pla 								; throw away unwanted results
.c35d	68		pla				pla
.c35e	68		pla				pla
.c35f					_FPD_Rotates:
.c35f	5e 09 03	lsr $0309,x			lsr 	3+XS2_Mantissa,x
.c362	7e 08 03	ror $0308,x			ror 	2+XS2_Mantissa,x
.c365	7e 07 03	ror $0307,x			ror 	1+XS2_Mantissa,x
.c368	7e 06 03	ror $0306,x			ror 	0+XS2_Mantissa,x
.c36b	06 16		asl $16				asl 	zLTemp1 					; rotate result round left
.c36d	26 17		rol $17				rol 	zLTemp1+1
.c36f	26 18		rol $18				rol 	zLTemp1+2
.c371	26 19		rol $19				rol 	zLTemp1+3
.c373	90 02		bcc $c377			bcc 	_FPD_NoCarry
.c375	e6 16		inc $16				inc 	zLTemp1 					; if rotated out, set LSB.
.c377					_FPD_NoCarry:
.c377	88		dey				dey 								; do 32 times
.c378	d0 ad		bne $c327			bne 	_FPD_Loop
.c37a	4c e1 c3	jmp $c3e1			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.c37d					_FPD_Overflow:
.c37d	4c de c5	jmp $c5de			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.c380					FPMultiply:
.c380	48		pha				pha
.c381	5a		phy				phy
.c382	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.c385	70 08		bvs $c38f			bvs 	_FPM_Exit
.c387	3c 0b 03	bit $030b,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.c38a	50 06		bvc $c392			bvc 	_FPM_CalcExponent
.c38c	20 e1 c4	jsr $c4e1			jsr 	FPUCopyX2ToX1
.c38f					_FPM_Exit:
.c38f	7a		ply				ply
.c390	68		pla				pla
.c391	60		rts				rts
.c392					_FPM_CalcExponent:
.c392	18		clc				clc
.c393	20 04 c4	jsr $c404			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.c396	9d 04 03	sta $0304,x			sta 	XS_Exponent,x 				; save the result.
.c399	a9 00		lda #$00			lda 	#0
.c39b	85 16		sta $16				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.c39d	85 17		sta $17				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.c39f	85 18		sta $18				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.c3a1	85 19		sta $19				sta 	zLTemp1+3
.c3a3	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.c3a5					_FPM_Loop:
.c3a5	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x				; check LSB of long product
.c3a8	29 01		and #$01			and 	#1
.c3aa	18		clc				clc 								; clear carry for the long rotate.
.c3ab	f0 1d		beq $c3ca			beq 	_FPM_NoAddition
.c3ad	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.c3ae	a5 16		lda $16				lda 	zLTemp1+0
.c3b0	7d 06 03	adc $0306,x			adc 	XS2_Mantissa+0,x
.c3b3	85 16		sta $16				sta 	zLTemp1+0
.c3b5	a5 17		lda $17				lda 	zLTemp1+1
.c3b7	7d 07 03	adc $0307,x			adc 	XS2_Mantissa+1,x
.c3ba	85 17		sta $17				sta 	zLTemp1+1
.c3bc	a5 18		lda $18				lda 	zLTemp1+2
.c3be	7d 08 03	adc $0308,x			adc 	XS2_Mantissa+2,x
.c3c1	85 18		sta $18				sta 	zLTemp1+2
.c3c3	a5 19		lda $19				lda 	zLTemp1+3
.c3c5	7d 09 03	adc $0309,x			adc 	XS2_Mantissa+3,x
.c3c8	85 19		sta $19				sta 	zLTemp1+3
.c3ca					_FPM_NoAddition:
.c3ca	66 19		ror $19				ror 	3+zLTemp1
.c3cc	66 18		ror $18				ror 	2+zLTemp1
.c3ce	66 17		ror $17				ror 	1+zLTemp1
.c3d0	66 16		ror $16				ror 	0+zLTemp1
.c3d2	7e 03 03	ror $0303,x			ror 	3+XS_Mantissa,x
.c3d5	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.c3d8	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.c3db	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.c3de	88		dey				dey
.c3df	d0 c4		bne $c3a5			bne 	_FPM_Loop 					; do this 32 times.
.c3e1					FPM_CopySignNormalize:
.c3e1	a5 16		lda $16				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.c3e3	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.c3e6	a5 17		lda $17				lda 	zLTemp1+1
.c3e8	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c3eb	a5 18		lda $18				lda 	zLTemp1+2
.c3ed	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c3f0	a5 19		lda $19				lda 	zLTemp1+3
.c3f2	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c3f5	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; sign is xor of signs
.c3f8	5d 0b 03	eor $030b,x			eor 	XS2_Type,x
.c3fb	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c3fe	20 69 c5	jsr $c569			jsr 	FPUNormalise 				; normalise and exit.
.c401	7a		ply				ply
.c402	68		pla				pla
.c403	60		rts				rts
.c404					FPCalculateExponent:
.c404	18		clc				clc
.c405	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.c408	7d 0a 03	adc $030a,x			adc 	XS2_Exponent,x
.c40b	b0 08		bcs $c415			bcs 	_FPCECarry 					; carry out ?
.c40d	10 03		bpl $c412			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.c40f	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.c411	60		rts				rts
.c412					_FPCEExpZero:
.c412	a9 00		lda #$00			lda 	#0
.c414	60		rts				rts
.c415					_FPCECarry:
.c415	30 03		bmi $c41a			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.c417	09 80		ora #$80			ora 	#$80 						; put in right range
.c419	60		rts				rts
.c41a					_FPCEOverflow:
.c41a	4c de c5	jmp $c5de			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.c41d					FPFractionalPart:
.c41d	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.c420	38		sec				sec 								; this flag tells us to keep the fractional part
.c421	30 0f		bmi $c432			bmi 	FPGetPart
.c423	60		rts				rts
.c424					FPIntegerPart:
.c424	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.c427	18		clc				clc 								; this flag says keep the integer part.
.c428	30 08		bmi $c432			bmi 	FPGetPart 					; -ve exponents are 0..127
.c42a	48		pha				pha
.c42b	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.c42d	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c430	68		pla				pla
.c431	60		rts				rts
.c432					FPGetPart:
.c432	48		pha				pha
.c433	5a		phy				phy 								; save Y
.c434	08		php				php 								; save action
.c435	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.c438	70 62		bvs $c49c			bvs 	_FPGP_Exit 					; then do nothing.
.c43a	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.c43c	85 16		sta $16				sta 	zLTemp1+0 					; this mask is applied to chop out the
.c43e	85 17		sta $17				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.c440	85 18		sta $18				sta 	zLTemp1+2
.c442	85 19		sta $19				sta 	zLTemp1+3
.c444	bd 04 03	lda $0304,x			lda 	XS_Exponent,x				; the number of shifts.
.c447	38		sec				sec
.c448	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.c44a	f0 12		beq $c45e			beq 	_FPGP_NoShift 				; ... if any
.c44c	c9 20		cmp #$20			cmp 	#32
.c44e	90 02		bcc $c452			bcc 	_FPGP_NotMax
.c450	a9 20		lda #$20			lda 	#32 						; max of 32.
.c452					_FPGP_NotMax:
.c452	a8		tay				tay 								; Y is the mask shift count.
.c453					_FPGP_ShiftMask:
.c453	46 19		lsr $19				lsr 	3+zLTemp1
.c455	66 18		ror $18				ror 	2+zLTemp1
.c457	66 17		ror $17				ror 	1+zLTemp1
.c459	66 16		ror $16				ror 	0+zLTemp1
.c45b	88		dey				dey
.c45c	d0 f5		bne $c453			bne 	_FPGP_ShiftMask
.c45e					_FPGP_NoShift:
.c45e	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.c460	8e 2d 04	stx $042d			stx 	ExpTemp						; save X
.c463					_FPGP_MaskLoop:
.c463	b9 16 00	lda $0016,y			lda 	zlTemp1,y 					; get mask byte
.c466	28		plp				plp 								; if CC we keep the top part, so we
.c467	08		php				php		 							; flip the mask.
.c468	b0 02		bcs $c46c			bcs		_FPGP_NoFlip
.c46a	49 ff		eor #$ff			eor 	#$FF
.c46c					_FPGP_NoFlip:
.c46c	3d 00 03	and $0300,x			and 	XS_Mantissa,x 				; and into the mantissa.
.c46f	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.c472	e8		inx				inx
.c473	c8		iny				iny
.c474	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.c476	d0 eb		bne $c463			bne 	_FPGP_MaskLoop
.c478	ae 2d 04	ldx $042d			ldx 	ExpTemp						; restore X
.c47b	28		plp				plp
.c47c	08		php				php 								; get action flag on the stack
.c47d	90 05		bcc $c484			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.c47f	a9 00		lda #$00			lda 	#0
.c481	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c484					_FPGP_NotFractional:
.c484	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x 						; check if \1 zero
.c487	1d 01 03	ora $0301,x			ora 	XS_Mantissa+1,x
.c48a	1d 02 03	ora $0302,x			ora 	XS_Mantissa+2,x
.c48d	1d 03 03	ora $0303,x			ora 	XS_Mantissa+3,x
.c490	f0 05		beq $c497			beq 	_FPGP_Zero 					; if zero, return zero
.c492	20 69 c5	jsr $c569			jsr 	FPUNormalise
.c495	80 05		bra $c49c			bra 	_FPGP_Exit 					; and exit
.c497					_FPGP_Zero:
.c497	a9 40		lda #$40			lda 	#$40 						; set zero flag
.c499	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c49c					_FPGP_Exit:
.c49c	68		pla				pla 								; throw saved action flag.
.c49d	7a		ply				ply
.c49e	68		pla				pla
.c49f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.c4a0					FPCompare:
.c4a0	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.c4a3	48		pha				pha
.c4a4	bd 0a 03	lda $030a,x			lda 	XS2_Exponent,x
.c4a7	48		pha				pha
.c4a8	20 0a c2	jsr $c20a			jsr 	FPSubtract 					; calculate X1-X2
.c4ab	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.c4ae	70 2c		bvs $c4dc			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.c4b0	68		pla				pla
.c4b1	8d 2d 04	sta $042d			sta 	ExpTemp						; save first exponent in temporary reg.
.c4b4	68		pla				pla
.c4b5	38		sec				sec
.c4b6	ed 2d 04	sbc $042d			sbc 	ExpTemp 					; calculate AX-BX
.c4b9	70 15		bvs $c4d0			bvs 	_FPCNotEqual				; overflow, can't be equal.
.c4bb	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.c4bc	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.c4be	b0 10		bcs $c4d0			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.c4c0	38		sec				sec
.c4c1	ad 2d 04	lda $042d			lda 	ExpTemp 					; get one of the exponents back.
.c4c4	e9 18		sbc #$18			sbc 	#24 						; allow for 2^24 error, relatively.
.c4c6	b0 02		bcs $c4ca			bcs 	_FPCNotRange 				; keep in range.
.c4c8	a9 01		lda #$01			lda 	#1
.c4ca					_FPCNotRange:
.c4ca	38		sec				sec
.c4cb	fd 04 03	sbc $0304,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.c4ce	b0 0e		bcs $c4de			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.c4d0					_FPCNotEqual:
.c4d0	bd 05 03	lda $0305,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.c4d3	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.c4d5	f0 02		beq $c4d9			beq 	_FPCNE2
.c4d7	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.c4d9	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.c4da	80 04		bra $c4e0			bra 	_FPCExit
.c4dc					_FPCPullZero:
.c4dc	68		pla				pla 								; throw saved exponents
.c4dd	68		pla				pla
.c4de					_FPCZero:
.c4de	a9 00		lda #$00			lda 	#0 							; and return zero
.c4e0					_FPCExit:
.c4e0	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.c4e1					FPUCopyX2ToX1:
.c4e1	48		pha				pha
.c4e2	da		phx				phx
.c4e3	5a		phy				phy
.c4e4	a0 08		ldy #$08			ldy 	#8
.c4e6	bd 06 03	lda $0306,x	_FPUC21:lda 	XS2_Mantissa,x
.c4e9	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.c4ec	e8		inx				inx
.c4ed	88		dey				dey
.c4ee	10 f6		bpl $c4e6			bpl 	_FPUC21
.c4f0	7a		ply				ply
.c4f1	fa		plx				plx
.c4f2	68		pla				pla
.c4f3	60		rts				rts
.c4f4					FPUSetInteger:
.c4f4	48		pha				pha
.c4f5	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.c4f8	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.c4fa	10 02		bpl $c4fe			bpl 	_FPUSIExtend
.c4fc	a9 ff		lda #$ff			lda 	#$FF
.c4fe					_FPUSIExtend:
.c4fe	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.c501	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c504	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c507	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.c509	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c50c	68		pla				pla
.c50d	60		rts				rts
.c50e					FPUNegateInteger:
.c50e	48		pha				pha
.c50f	38		sec				sec
.c510	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.c512	fd 00 03	sbc $0300,x			sbc 	XS_Mantissa+0,x
.c515	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c518	a9 00		lda #$00			lda 	#0
.c51a	fd 01 03	sbc $0301,x			sbc 	XS_Mantissa+1,x
.c51d	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c520	a9 00		lda #$00			lda 	#0
.c522	fd 02 03	sbc $0302,x			sbc 	XS_Mantissa+2,x
.c525	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c528	a9 00		lda #$00			lda 	#0
.c52a	fd 03 03	sbc $0303,x			sbc 	XS_Mantissa+3,x
.c52d	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c530	68		pla				pla
.c531	60		rts				rts
.c532					FPUToFloat:
.c532	48		pha				pha
.c533	bd 05 03	lda $0305,x			lda 	XS_Type,x					; exit if already float.
.c536	29 0f		and #$0f			and 	#$0F
.c538	f0 2d		beq $c567			beq 	_FPUFExit
.c53a	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.c53c	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c53f	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.c541	9d 04 03	sta $0304,x			sta 	XS_Exponent,x 				; x mantissa.
.c544	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.c547	10 08		bpl $c551			bpl		_FPUFPositive
.c549	20 0e c5	jsr $c50e			jsr 	FPUNegateInteger 			; negate the mantissa
.c54c	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.c54e	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c551					_FPUFPositive:
.c551	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.c554	1d 01 03	ora $0301,x			ora 	XS_Mantissa+1,x
.c557	1d 02 03	ora $0302,x			ora 	XS_Mantissa+2,x
.c55a	1d 03 03	ora $0303,x			ora 	XS_Mantissa+3,x
.c55d	d0 05		bne $c564			bne 	_FPUFNonZero
.c55f	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.c561	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c564					_FPUFNonZero:
.c564	20 69 c5	jsr $c569			jsr 	FPUNormalise 				; normalise the floating point.
.c567					_FPUFExit:
.c567	68		pla				pla
.c568	60		rts				rts
.c569					FPUNormalise:
.c569	48		pha				pha
.c56a	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.c56d	70 20		bvs $c58f			bvs 	_FPUNExit
.c56f	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.c572	f0 16		beq $c58a			beq 	_FPUNSetZero
.c574					_FPUNLoop:
.c574	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.c577	30 16		bmi $c58f			bmi 	_FPUNExit 					; if so, we are normalised.
.c579	1e 00 03	asl $0300,x			asl 	0+XS_Mantissa+0,x
.c57c	3e 01 03	rol $0301,x			rol 	1+XS_Mantissa+0,x
.c57f	3e 02 03	rol $0302,x			rol 	2+XS_Mantissa+0,x
.c582	3e 03 03	rol $0303,x			rol 	3+XS_Mantissa+0,x
.c585	de 04 03	dec $0304,x			dec 	XS_Exponent,x 				; decrement exponent
.c588	d0 ea		bne $c574			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.c58a					_FPUNSetZero:
.c58a	a9 40		lda #$40			lda 	#$40
.c58c	9d 05 03	sta $0305,x			sta 	XS_Type,x 					; the result is now zero.
.c58f					_FPUNExit:
.c58f	68		pla				pla
.c590	60		rts				rts
.c591					FPUToInteger:
.c591	48		pha				pha
.c592	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; if already integer, exit
.c595	29 01		and #$01			and 	#1
.c597	d0 3e		bne $c5d7			bne 	_FPUTOI_Exit
.c599	3c 05 03	bit $0305,x			bit 	XS_Type,x					; if zero, return zero.
.c59c	70 2b		bvs $c5c9			bvs 	_FPUTOI_Zero
.c59e	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.c5a1	10 26		bpl $c5c9			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.c5a3	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.c5a5	b0 37		bcs $c5de			bcs 	FP_Overflow
.c5a7					_FPUToIToInteger:
.c5a7	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.c5aa	c9 a0		cmp #$a0			cmp 	#128+32
.c5ac	f0 11		beq $c5bf			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.c5ae	fe 04 03	inc $0304,x			inc 	XS_Exponent,X 				; increment Exponent
.c5b1	5e 03 03	lsr $0303,x			lsr 	3+XS_Mantissa,x
.c5b4	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.c5b7	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.c5ba	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.c5bd	80 e8		bra $c5a7			bra 	_FPUToIToInteger 			; keep going.
.c5bf					_FPUToICheckSign:
.c5bf	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; check sign
.c5c2	10 13		bpl $c5d7			bpl 	_FPUToI_Exit 				; exit if unsigned.
.c5c4	20 0e c5	jsr $c50e			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.c5c7	80 0e		bra $c5d7			bra 	_FPUTOI_Exit
.c5c9					_FPUTOI_Zero:
.c5c9	a9 00		lda #$00			lda 	#0 							; return zero integer.
.c5cb	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c5ce	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c5d1	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c5d4	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c5d7					_FPUToI_Exit:
.c5d7	a9 01		lda #$01			lda 	#1 							; set type to integer
.c5d9	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c5dc	68		pla				pla
.c5dd	60		rts				rts
.c5de					FP_Overflow:
.c5de	20 08 c2	jsr $c208			jsr 	ERR_Handler
>c5e1	46 6c 6f 61 74 69 6e 67				.text 	"Floating Point overflow",0
>c5e9	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.c5f9					FPUTimes10:
.c5f9	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.c5fc	85 16		sta $16				sta 	ZLTemp1+0
.c5fe	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c601	85 17		sta $17				sta 	ZLTemp1+1
.c603	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c606	85 18		sta $18				sta 	ZLTemp1+2
.c608	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c60b	85 19		sta $19				sta 	ZLTemp1+3
.c60d	20 51 c6	jsr $c651			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.c610	20 51 c6	jsr $c651			jsr 	_FPUT_LSR_ZLTemp1
.c613	18		clc				clc
.c614	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.c617	65 16		adc $16				adc 	ZLTemp1+0
.c619	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c61c	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c61f	65 17		adc $17				adc 	ZLTemp1+1
.c621	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c624	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c627	65 18		adc $18				adc 	ZLTemp1+2
.c629	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c62c	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c62f	65 19		adc $19				adc 	ZLTemp1+3
.c631	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c634	90 0f		bcc $c645			bcc 	_FPUTimes10
.c636	7e 03 03	ror $0303,x			ror 	3+XS_Mantissa,x
.c639	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.c63c	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.c63f	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.c642	fe 04 03	inc $0304,x			inc 	XS_Exponent,x				; fix exponent
.c645					_FPUTimes10:
.c645	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.c648	18		clc				clc
.c649	69 03		adc #$03			adc 	#3
.c64b	9d 04 03	sta $0304,x			sta 	XS_Exponent,x
.c64e	b0 8e		bcs $c5de			bcs 	FP_Overflow 				; error
.c650	60		rts				rts
.c651					_FPUT_LSR_ZLTemp1:
.c651	46 19		lsr $19				lsr 	ZLTemp1+3
.c653	66 18		ror $18				ror 	ZLTemp1+2
.c655	66 17		ror $17				ror 	ZLTemp1+1
.c657	66 16		ror $16				ror 	ZLTemp1+0
.c659	60		rts				rts
.c65a					FPUScale10A:
.c65a	5a		phy				phy
.c65b	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.c65d	f0 3d		beq $c69c			beq 	_FPUScaleExit
.c65f	da		phx				phx 								; save X
.c660	e8		inx				inx
.c661	e8		inx				inx
.c662	e8		inx				inx
.c663	e8		inx				inx
.c664	e8		inx				inx
.c665	e8		inx				inx
.c666	a8		tay				tay 								; save power scalar in Y.
.c667	a9 00		lda #$00			lda 	#0
.c669	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.c66c	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c66f	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c672	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c675	a9 80		lda #$80			lda 	#$80
.c677	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c67a	a9 81		lda #$81			lda 	#$81
.c67c	9d 04 03	sta $0304,x			sta 	XS_Exponent,x
.c67f	5a		phy				phy 								; save 10^n on stack.
.c680	c0 00		cpy #$00			cpy 	#0
.c682	10 05		bpl $c689			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.c684	98		tya				tya
.c685	49 ff		eor #$ff			eor 	#$FF
.c687	1a		inc a				inc 	a
.c688	a8		tay				tay
.c689					_FPUSAbs:
.c689	20 f9 c5	jsr $c5f9			jsr 	FPUTimes10
.c68c	88		dey				dey
.c68d	d0 fa		bne $c689			bne 	_FPUSAbs 					; tos is now 10^|AC|
.c68f	68		pla				pla 								; restore count in A
.c690	fa		plx				plx 								; restore X pointing to number to scale.
.c691	0a		asl a				asl 	a
.c692	b0 05		bcs $c699			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.c694	20 80 c3	jsr $c380			jsr 	FPMultiply 					; if clear multiply.
.c697	80 03		bra $c69c			bra		_FPUScaleExit
.c699					_FPUSDivide:
.c699	20 f8 c2	jsr $c2f8			jsr 	FPDivide
.c69c					_FPUScaleExit:
.c69c	7a		ply				ply
.c69d	60		rts				rts
.c69e					FPUCopyToNext:
.c69e	a0 06		ldy #$06			ldy 		#6
.c6a0	da		phx				phx
.c6a1					_FPUCopy1:
.c6a1	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x
.c6a4	9d 06 03	sta $0306,x			sta 	XS2_Mantissa,x
.c6a7	e8		inx				inx
.c6a8	88		dey				dey
.c6a9	d0 f6		bne $c6a1			bne 	_FPUCopy1
.c6ab	fa		plx				plx
.c6ac	60		rts				rts
.c6ad					FPUCopyFromNext:
.c6ad	a0 06		ldy #$06			ldy 		#6
.c6af	da		phx				phx
.c6b0					_FPUCopy1:
.c6b0	bd 06 03	lda $0306,x			lda 	XS2_Mantissa,x
.c6b3	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.c6b6	e8		inx				inx
.c6b7	88		dey				dey
.c6b8	d0 f6		bne $c6b0			bne 	_FPUCopy1
.c6ba	fa		plx				plx
.c6bb	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.c6bc					FPToString:
.c6bc	48		pha				pha
.c6bd	5a		phy				phy
.c6be	3c 05 03	bit $0305,x			bit 		XS_Type,x 				; check zero flag
.c6c1	50 0a		bvc $c6cd			bvc 		_FPTSIsFloat 			; if zero,
.c6c3					_FPTSZero:
.c6c3	a9 30		lda #$30			lda 		#"0"
.c6c5	20 a0 c8	jsr $c8a0			jsr 		ITSOutputCharacter
.c6c8					_FPTSExit:
.c6c8	7a		ply				ply
.c6c9	68		pla				pla
.c6ca	60		rts				rts
.c6cb	80 fb		bra $c6c8			bra 		_FPTSExit
.c6cd					_FPTSIsFloat:
.c6cd	bd 05 03	lda $0305,x			lda 		XS_Type,x 				; is it signed ?
.c6d0	10 0a		bpl $c6dc			bpl 		_FPTSNotSigned
.c6d2	a9 00		lda #$00			lda 		#0 						; clear sign flag
.c6d4	9d 05 03	sta $0305,x			sta 		XS_Type,x
.c6d7	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.c6d9	20 a0 c8	jsr $c8a0			jsr 		ITSOutputCharacter
.c6dc					_FPTSNotSigned:
.c6dc	bd 04 03	lda $0304,x			lda 		XS_Exponent,x
.c6df	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.c6e1	b0 09		bcs $c6ec			bcs 		_FPTSExponent
.c6e3	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.c6e5	90 05		bcc $c6ec			bcc 		_FPTSExponent 			;
.c6e7					_FPTSStandard:
.c6e7	20 30 c7	jsr $c730			jsr 		FPTOutputBody 			; output the body.
.c6ea	80 dc		bra $c6c8			bra 		_FPTSExit
.c6ec					_FPTSExponent:
.c6ec	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.c6ee	8d 2e 04	sta $042e			sta 		ExpCount
.c6f1					_FPTSExponentLoop:
.c6f1	bd 04 03	lda $0304,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.c6f4	10 0e		bpl $c704			bpl 		_FPTSTimes
.c6f6	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.c6f8	90 14		bcc $c70e			bcc 		_FPTSScaledToExp
.c6fa	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.c6fc	20 5a c6	jsr $c65a			jsr 		FPUScale10A
.c6ff	ee 2e 04	inc $042e			inc 		ExpCount
.c702	80 ed		bra $c6f1			bra 		_FPTSExponentLoop
.c704					_FPTSTimes:
.c704	a9 01		lda #$01			lda 		#1
.c706	20 5a c6	jsr $c65a			jsr 		FPUScale10A
.c709	ce 2e 04	dec $042e			dec 		ExpCount
.c70c	80 e3		bra $c6f1			bra 		_FPTSExponentLoop
.c70e					_FPTSScaledToExp:
.c70e	20 30 c7	jsr $c730			jsr 		FPTOutputBody 			; output the body.
.c711	a9 65		lda #$65			lda 		#"e"					; output E
.c713	20 a0 c8	jsr $c8a0			jsr 		ITSOutputCharacter
.c716	ad 2e 04	lda $042e			lda 		ExpCount 				; get the exponent
.c719	9d 00 03	sta $0300,x			sta 		XS_Mantissa,x
.c71c	29 80		and #$80			and 		#$80 					; sign extend it
.c71e	f0 02		beq $c722			beq 		_FPTSSExt
.c720	a9 ff		lda #$ff			lda 		#$FF
.c722					_FPTSSExt:
.c722	9d 01 03	sta $0301,x			sta 		XS_Mantissa+1,x
.c725	9d 02 03	sta $0302,x			sta 		XS_Mantissa+2,x
.c728	9d 03 03	sta $0303,x			sta 		XS_Mantissa+3,x
.c72b	20 04 c8	jsr $c804			jsr 		INTToString 			; output the exponent.
.c72e	80 98		bra $c6c8			bra			_FPTSExit 				; and exit.
.c730					FPTOutputBody:
.c730	20 9e c6	jsr $c69e			jsr 		FPUCopyToNext 			; copy to next slot.
.c733	20 91 c5	jsr $c591			jsr 		FPUToInteger 			; convert to an integer
.c736	20 04 c8	jsr $c804			jsr 		INTToString 			; output the main integer part.
.c739	20 ad c6	jsr $c6ad			jsr 		FPUCopyFromNext 		; get the fractional part back.
.c73c	20 1d c4	jsr $c41d			jsr 		FPFractionalPart 		; get the decimal part.
.c73f	3c 05 03	bit $0305,x			bit 		XS_Type,x 				; any fractional part.
.c742	70 3e		bvs $c782			bvs 		_FPTOExit 				; if not, exit now.
.c744	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.c746	20 a0 c8	jsr $c8a0			jsr 		ITSOutputCharacter
.c749					_FPOutLoop:
.c749	3c 05 03	bit $0305,x			bit 		XS_Type,x 				; finally reached zero.
.c74c	70 1e		bvs $c76c			bvs 		_FPStripZeros 			; strip trailing zeros
.c74e	20 f9 c5	jsr $c5f9			jsr 		FPUTimes10 				; multiply by 10
.c751	20 9e c6	jsr $c69e			jsr 		FPUCopyToNext			; copy to next slot.
.c754	20 91 c5	jsr $c591			jsr 		FPUToInteger 			; convert to integer
.c757	bd 00 03	lda $0300,x			lda 		XS_Mantissa+0,x 		; print digit.
.c75a	09 30		ora #$30			ora 		#"0"
.c75c	20 a0 c8	jsr $c8a0			jsr 		ITSOutputCharacter
.c75f	20 ad c6	jsr $c6ad			jsr 		FPUCopyFromNext 		; get it back
.c762	20 1d c4	jsr $c41d			jsr 		FPFractionalPart 		; get fractional part
.c765	ad 20 04	lda $0420			lda 		NumBufX 				; done 11 characters yet ?
.c768	c9 0b		cmp #$0b			cmp 	 	#11
.c76a	90 dd		bcc $c749			bcc 		_FPOutLoop 				; if so, keep going till zero.
.c76c					_FPStripZeros:
.c76c	ac 20 04	ldy $0420			ldy 		NumBufX 				; strip trailing zeros.
.c76f					_FPStripLoop:
.c76f	88		dey				dey 								; back one, if at start then no strip
.c770	f0 10		beq $c782			beq 		_FPToExit
.c772	b9 00 04	lda $0400,y			lda 		Num_Buffer,y 			; keep going if "0"
.c775	c9 30		cmp #$30			cmp 		#"0"
.c777	f0 f6		beq $c76f			beq 		_FPStripLoop
.c779	c8		iny				iny
.c77a	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.c77c	99 00 04	sta $0400,y			sta 		Num_Buffer,y
.c77f	8c 20 04	sty $0420			sty 		NumBufX 				; update position.
.c782					_FPTOExit:
.c782	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.c783					FPFromString:
.c783	48		pha				pha 								; push A
.c784	b1 1a		lda ($1a),y			lda		(zGenPtr),y					; is it followed by a DP ?
.c786	c9 2e		cmp #$2e			cmp 	#"."
.c788	f0 03		beq $c78d			beq	 	_FPFIsDecimal
.c78a	4c f0 c7	jmp $c7f0			jmp 	_FPFNotDecimal
.c78d					_FPFIsDecimal:
.c78d	c8		iny				iny 								; consume the decimal.
.c78e	20 32 c5	jsr $c532			jsr 	FPUToFloat 					; convert the integer to float.
.c791	da		phx				phx 								; save X.
.c792	5a		phy				phy 								; save decimal start position
.c793	e8		inx				inx
.c794	e8		inx				inx
.c795	e8		inx				inx
.c796	e8		inx				inx
.c797	e8		inx				inx
.c798	e8		inx				inx
.c799	20 b8 c8	jsr $c8b8			jsr 	INTFromStringY 				; get the part after the DP.
.c79c	20 32 c5	jsr $c532			jsr 	FPUToFloat 					; convert that to a float.
.c79f	68		pla				pla 								; calculate - chars consumed.
.c7a0	8c 2d 04	sty $042d			sty 	ExpTemp
.c7a3	38		sec				sec
.c7a4	ed 2d 04	sbc $042d			sbc 	ExpTemp 					; this is the shift amount
.c7a7	20 5a c6	jsr $c65a			jsr 	FPUScale10A 				; scale it by 10^AC
.c7aa	fa		plx				plx 								; restore original X
.c7ab	20 14 c2	jsr $c214			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.c7ae	b1 1a		lda ($1a),y			lda 	(zGenPtr),y 				; exponent ?
.c7b0	c9 45		cmp #$45			cmp 	#"E"
.c7b2	f0 04		beq $c7b8			beq 	_FPFExponent
.c7b4	c9 65		cmp #$65			cmp 	#"e"
.c7b6	d0 38		bne $c7f0			bne 	_FPFNotDecimal 				; no, then exit normally.
.c7b8					_FPFExponent:
.c7b8	c8		iny				iny 								; skip over E symbol.
.c7b9	b1 1a		lda ($1a),y			lda 	(zGenPtr),y 				; look at next
.c7bb	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.c7bd	d0 01		bne $c7c0			bne 	_FPFGotSign
.c7bf	c8		iny				iny 								; if it was - skip over it.
.c7c0					_FPFGotSign:
.c7c0	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.c7c1	da		phx				phx
.c7c2	e8		inx				inx
.c7c3	e8		inx				inx
.c7c4	e8		inx				inx
.c7c5	e8		inx				inx
.c7c6	e8		inx				inx
.c7c7	e8		inx				inx
.c7c8	20 b8 c8	jsr $c8b8			jsr 	INTFromStringY 				; get the exponent
.c7cb	fa		plx				plx 								; restore X.
.c7cc	bd 07 03	lda $0307,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.c7cf	1d 09 03	ora $0309,x			ora 	XS2_Mantissa+3,x
.c7d2	1d 08 03	ora $0308,x			ora 	XS2_Mantissa+2,x
.c7d5	d0 1b		bne $c7f2			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.c7d7	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.c7da	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.c7dc	b0 14		bcs $c7f2			bcs 	_FPFXOverflow
.c7de	68		pla				pla 								; get direction
.c7df	d0 09		bne $c7ea			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.c7e1	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.c7e4	49 ff		eor #$ff			eor 	#$FF
.c7e6	1a		inc a				inc 	a
.c7e7	9d 06 03	sta $0306,x			sta 	XS2_Mantissa+0,x
.c7ea					_FPFXScale:
.c7ea	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.c7ed	20 5a c6	jsr $c65a			jsr 	FPUScale10A 				; scale by the exponent.
.c7f0					_FPFNotDecimal:
.c7f0	68		pla				pla
.c7f1	60		rts				rts
.c7f2					_FPFXOverflow:
.c7f2	20 08 c2	jsr $c208			jsr 	ERR_Handler
>c7f5	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>c7fd	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.c804					INTToString:
.c804	48		pha				pha
.c805	5a		phy				phy
.c806	bd 03 03	lda $0303,x			lda 		XS_Mantissa+3,x 		; check -ve
.c809	10 08		bpl $c813			bpl 		_ITSNotMinus
.c80b	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.c80d	20 a0 c8	jsr $c8a0			jsr 		ITSOutputCharacter
.c810	20 0e c5	jsr $c50e			jsr 		FPUNegateInteger
.c813					_ITSNotMinus:
.c813	a9 00		lda #$00			lda 		#0 						; X is offset in table.
.c815	8d 21 04	sta $0421			sta 		NumSuppress 			; clear the suppression flag.
.c818	a0 00		ldy #$00			ldy 		#0 						; Y is index into dword subtraction table.
.c81a					_ITSNextSubtractor:
.c81a	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.c81c	8d 22 04	sta $0422			sta 		NumConvCount
.c81f					_ITSSubtract:
.c81f	38		sec				sec
.c820	bd 00 03	lda $0300,x			lda 		XS_Mantissa,x 			; subtract number and push on stack
.c823	f9 7c c8	sbc $c87c,y			sbc 		_ITSSubtractors+0,y
.c826	48		pha				pha
.c827	bd 01 03	lda $0301,x			lda 		XS_Mantissa+1,x
.c82a	f9 7d c8	sbc $c87d,y			sbc 		_ITSSubtractors+1,y
.c82d	48		pha				pha
.c82e	bd 02 03	lda $0302,x			lda 		XS_Mantissa+2,x
.c831	f9 7e c8	sbc $c87e,y			sbc 		_ITSSubtractors+2,y
.c834	48		pha				pha
.c835	bd 03 03	lda $0303,x			lda 		XS_Mantissa+3,x
.c838	f9 7f c8	sbc $c87f,y			sbc 		_ITSSubtractors+3,y
.c83b	90 14		bcc $c851			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.c83d	9d 03 03	sta $0303,x			sta 		XS_Mantissa+3,x 		; save subtract off stack
.c840	68		pla				pla
.c841	9d 02 03	sta $0302,x			sta 		XS_Mantissa+2,x
.c844	68		pla				pla
.c845	9d 01 03	sta $0301,x			sta 		XS_Mantissa+1,x
.c848	68		pla				pla
.c849	9d 00 03	sta $0300,x			sta 		XS_Mantissa+0,x
.c84c	ee 22 04	inc $0422			inc 		NumConvCount 			; bump count.
.c84f	80 ce		bra $c81f			bra 		_ITSSubtract 			; go round again.
.c851					_ITSCantSubtract:
.c851	68		pla				pla 								; throw away interim answers
.c852	68		pla				pla
.c853	68		pla				pla
.c854	ad 22 04	lda $0422			lda 		NumConvCount 			; if not zero then no suppression check
.c857	c9 30		cmp #$30			cmp 		#"0"
.c859	d0 05		bne $c860			bne 		_ITSOutputDigit
.c85b	ad 21 04	lda $0421			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.c85e	10 09		bpl $c869			bpl 		_ITSGoNextSubtractor
.c860					_ITSOutputDigit:
.c860	ce 21 04	dec $0421			dec 		NumSuppress 			; suppression check will be non-zero.
.c863	ad 22 04	lda $0422			lda 		NumConvCount 			; count of subtractions
.c866	20 a0 c8	jsr $c8a0			jsr 		ITSOutputCharacter 		; output it.
.c869					_ITSGoNextSubtractor:
.c869	c8		iny				iny 								; next dword
.c86a	c8		iny				iny
.c86b	c8		iny				iny
.c86c	c8		iny				iny
.c86d	c0 24		cpy #$24			cpy 		#_ITSSubtractorsEnd-_ITSSubtractors
.c86f	d0 a9		bne $c81a			bne 		_ITSNextSubtractor 		; do all the subtractors.
.c871	bd 00 03	lda $0300,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.c874	09 30		ora #$30			ora 		#"0"
.c876	20 a0 c8	jsr $c8a0			jsr 		ITSOutputCharacter
.c879	7a		ply				ply 								; and exit
.c87a	68		pla				pla
.c87b	60		rts				rts
.c87c					_ITSSubtractors:
>c87c	00 ca 9a 3b					.dword 		1000000000
>c880	00 e1 f5 05					.dword 		100000000
>c884	80 96 98 00					.dword 		10000000
>c888	40 42 0f 00					.dword 		1000000
>c88c	a0 86 01 00					.dword 		100000
>c890	10 27 00 00					.dword 		10000
>c894	e8 03 00 00					.dword 		1000
>c898	64 00 00 00					.dword 		100
>c89c	0a 00 00 00					.dword 		10
.c8a0					_ITSSubtractorsEnd:
.c8a0					ITSOutputCharacter:
.c8a0	48		pha				pha
.c8a1	da		phx				phx
.c8a2	ae 20 04	ldx $0420			ldx 	NumBufX 					; save digit
.c8a5	9d 00 04	sta $0400,x			sta 	Num_Buffer,x
.c8a8	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.c8aa	9d 01 04	sta $0401,x			sta 	Num_Buffer+1,x
.c8ad	ee 20 04	inc $0420			inc 	NumBufX						; bump pointer.
.c8b0	fa		plx				plx
.c8b1	68		pla				pla
.c8b2	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.c8b3					IntFromString:
.c8b3	a0 00		ldy #$00			ldy 	#0
.c8b5	8c 2d 04	sty $042d			sty 	ExpTemp 					; this is the converted digit count.
.c8b8					IntFromStringY:
.c8b8	48		pha				pha
.c8b9	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.c8bb	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.c8be	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c8c1	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c8c4	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c8c7	a9 01		lda #$01			lda 	#1
.c8c9	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c8cc					_IFSLoop:
.c8cc	b1 1a		lda ($1a),y			lda 	(zGenPtr),y 				; get next
.c8ce	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.c8d0	90 60		bcc $c932			bcc 	_IFSExit
.c8d2	c9 3a		cmp #$3a			cmp 	#"9"+1
.c8d4	b0 5c		bcs $c932			bcs 	_IFSExit
.c8d6	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.c8d9	c9 0c		cmp #$0c			cmp 	#12
.c8db	b0 5f		bcs $c93c			bcs 	_IFSOverflow
.c8dd	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.c8e0	48		pha				pha
.c8e1	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c8e4	48		pha				pha
.c8e5	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c8e8	48		pha				pha
.c8e9	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.c8ec	48		pha				pha
.c8ed	20 51 c9	jsr $c951			jsr 	IFSX1ShiftLeft 				; double
.c8f0	20 51 c9	jsr $c951			jsr 	IFSX1ShiftLeft 				; x 4
.c8f3	18		clc				clc 								; add saved value x 5
.c8f4	68		pla				pla
.c8f5	7d 00 03	adc $0300,x			adc 	XS_Mantissa+0,x
.c8f8	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c8fb	68		pla				pla
.c8fc	7d 01 03	adc $0301,x			adc 	XS_Mantissa+1,x
.c8ff	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c902	68		pla				pla
.c903	7d 02 03	adc $0302,x			adc 	XS_Mantissa+2,x
.c906	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c909	68		pla				pla
.c90a	7d 03 03	adc $0303,x			adc 	XS_Mantissa+3,x
.c90d	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c910	20 51 c9	jsr $c951			jsr 	IFSX1ShiftLeft 				; x 10
.c913	ee 2d 04	inc $042d			inc 	ExpTemp 					; bump count of digits processed.
.c916	b1 1a		lda ($1a),y			lda 	(zGenPtr),y 				; add digit
.c918	29 0f		and #$0f			and 	#15
.c91a	c8		iny				iny
.c91b	7d 00 03	adc $0300,x			adc 	XS_Mantissa+0,x
.c91e	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c921	90 a9		bcc $c8cc			bcc 	_IFSLoop
.c923	fe 01 03	inc $0301,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.c926	d0 a4		bne $c8cc			bne 	_IFSLoop
.c928	fe 02 03	inc $0302,x			inc 	XS_Mantissa+2,x
.c92b	d0 9f		bne $c8cc			bne 	_IFSLoop
.c92d	fe 03 03	inc $0303,x			inc 	XS_Mantissa+3,x
.c930	80 9a		bra $c8cc			bra 	_IFSLoop
.c932					_IFSExit:
.c932	98		tya				tya 								; get offset
.c933					_IFSOkay:
.c933	38		sec				sec
.c934	ad 2d 04	lda $042d			lda 	ExpTemp
.c937	f0 01		beq $c93a			beq 	_IFSSkipFail
.c939	18		clc				clc
.c93a					_IFSSkipFail:
.c93a	68		pla				pla 								; and exit.
.c93b	60		rts				rts
.c93c					_IFSOverflow:
.c93c	20 08 c2	jsr $c208			jsr 	ERR_Handler
>c93f	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>c947	20 6f 76 65 72 66 6c 6f 77 00
.c951					IFSX1ShiftLeft:
.c951	1e 00 03	asl $0300,x			asl 	0+XS_Mantissa,x
.c954	3e 01 03	rol $0301,x			rol 	1+XS_Mantissa,x
.c957	3e 02 03	rol $0302,x			rol 	2+XS_Mantissa,x
.c95a	3e 03 03	rol $0303,x			rol 	3+XS_Mantissa,x
.c95d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.c95e					TIM_Error:
.c95e	20 45 c0	jsr $c045			jsr 	IFT_UpLine 					; go up one line.
.c961	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.c963	80 02		bra $c967			bra 	TIM_ShowPrompt
.c965					TIM_NewCommand:
.c965	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.c967					TIM_ShowPrompt:
.c967	20 51 c0	jsr $c051			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.c96a	20 09 c1	jsr $c109			jsr 	IFT_ReadLine	 			; get character, go to next line
.c96d	20 6b c0	jsr $c06b			jsr 	IFT_NewLine					; go to next line.
.c970	86 10		stx $10				stx 	zTemp1 						; save line read address
.c972	84 11		sty $11				sty 	zTemp1+1
.c974	a0 01		ldy #$01			ldy 	#1 							; get first character after the prompt.
.c976	b1 10		lda ($10),y			lda 	(zTemp1),y
.c978	c9 52		cmp #$52			cmp 	#"R"						; show registers
.c97a	f0 6b		beq $c9e7			beq 	TIM_ShowRegisters
.c97c	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.c97e	f0 12		beq $c992			beq 	TIM_ShowMemory
.c980	c9 47		cmp #$47			cmp 	#"G"						; execute
.c982	f0 49		beq $c9cd			beq 	TIM_Execute
.c984	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.c986	f0 07		beq $c98f			beq 	TIM_GoLoadMemory
.c988	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.c98a	d0 d2		bne $c95e			bne 	TIM_Error
.c98c	4c 0a cb	jmp $cb0a			jmp 	TIM_UpdateRegisters
.c98f					TIM_GoLoadMemory:
.c98f	4c 35 cb	jmp $cb35			jmp 	TIM_LoadMemory
.c992					TIM_ShowMemory:
.c992	20 86 ca	jsr $ca86			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.c995	b0 c7		bcs $c95e			bcs 	TIM_Error
.c997	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.c999	85 12		sta $12				sta 	zTemp2
.c99b	a5 15		lda $15				lda 	zTemp3+1
.c99d	85 13		sta $13				sta 	zTemp2+1
.c99f	20 86 ca	jsr $ca86			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.c9a2	90 08		bcc $c9ac			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.c9a4	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.c9a6	85 14		sta $14				sta 	zTemp3
.c9a8	a5 13		lda $13				lda 	zTemp2+1
.c9aa	85 15		sta $15				sta 	zTemp3+1
.c9ac					_TIMSM_Start:
.c9ac	20 5e ca	jsr $ca5e			jsr 	TIM_WriteLine 				; write one line of hex out
.c9af	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.c9b1	18		clc				clc
.c9b2	69 10		adc #$10			adc 	#16
.c9b4	85 12		sta $12				sta 	zTemp2
.c9b6	90 02		bcc $c9ba			bcc 	_TIMSM_NoCarry
.c9b8	e6 13		inc $13				inc 	zTemp2+1
.c9ba					_TIMSM_NoCarry:
.c9ba	20 f0 c1	jsr $c1f0			jsr 	IF_CheckBreak 				; check CTL+C
.c9bd	d0 0b		bne $c9ca			bne 	_TIMSM_Ends 				; if pressed break out.
.c9bf	38		sec				sec 								; check past the end address in zTemp3
.c9c0	a5 14		lda $14				lda 	zTemp3
.c9c2	e5 12		sbc $12				sbc 	zTemp2
.c9c4	a5 15		lda $15				lda 	zTemp3+1
.c9c6	e5 13		sbc $13				sbc 	zTemp2+1
.c9c8	10 e2		bpl $c9ac			bpl 	_TIMSM_Start
.c9ca					_TIMSM_Ends:
.c9ca	4c 65 c9	jmp $c965			jmp 	TIM_NewCommand
.c9cd					TIM_Execute:
.c9cd	20 86 ca	jsr $ca86			jsr 	TIM_GetHex 					; get the execute address
.c9d0	b0 8c		bcs $c95e			bcs 	TIM_Error 					; not legitimate
.c9d2	ae 2c 04	ldx $042c			ldx 	TIM_SP 						; set up SP
.c9d5	9a		txs				txs
.c9d6	ad 27 04	lda $0427			lda 	TIM_SR 						; Status for PLP
.c9d9	48		pha				pha
.c9da	ad 28 04	lda $0428			lda 	TIM_A 						; restore AXYZ
.c9dd	ae 29 04	ldx $0429			ldx 	TIM_X
.c9e0	ac 2a 04	ldy $042a			ldy 	TIM_Y
.c9e3	28		plp				plp 								; and PS Byte.
.c9e4	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.c9e7					TIM_Start:
.c9e7					TIM_ShowRegisters:
.c9e7	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.c9ea	8d 26 04	sta $0426			sta 	TIM_IRQ+1
.c9ed	ad ff ff	lda $ffff			lda 	$FFFF
.c9f0	8d 25 04	sta $0425			sta 	TIM_IRQ
.c9f3	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.c9f5					_TIMSR_Text:
.c9f5	bd 25 ca	lda $ca25,x			lda 	_TIMSR_Label,x
.c9f8	20 51 c0	jsr $c051			jsr 	IFT_PrintCharacter
.c9fb	e8		inx				inx
.c9fc	e0 20		cpx #$20			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.c9fe	d0 f5		bne $c9f5			bne 	_TIMSR_Text
.ca00	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.ca02					_TIMSR_Skip:
.ca02	e8		inx				inx
.ca03					_TIMSR_LoopSpace:
.ca03	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.ca05	b0 04		bcs $ca0b			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.ca07	8a		txa				txa
.ca08	4a		lsr a				lsr 	a
.ca09	b0 05		bcs $ca10			bcs 	_TIMSR_NoSpace
.ca0b					_TIMSR_Space:
.ca0b	a9 20		lda #$20			lda 	#" "
.ca0d	20 51 c0	jsr $c051			jsr 	IFT_PrintCharacter
.ca10					_TIMSR_NoSpace:
.ca10	bd 23 04	lda $0423,x			lda 	TIM_PC,x 					; output hex value.
.ca13	20 45 ca	jsr $ca45			jsr 	TIM_WriteHex
.ca16	e8		inx				inx
.ca17	e0 08		cpx #$08			cpx 	#TIM_Z-TIM_PC
.ca19	f0 e7		beq $ca02			beq 	_TIMSR_Skip
.ca1b	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.ca1d	d0 e4		bne $ca03			bne 	_TimSR_LoopSpace
.ca1f	20 6b c0	jsr $c06b			jsr 	IFT_NewLine 				; new line
.ca22	4c 65 c9	jmp $c965			jmp	 	TIM_NewCommand 				; new command.
.ca25					_TIMSR_Label:
>ca25	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>ca2d	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>ca3d	52
>ca3e	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.ca45					_TIMSR_LabelEnd:
.ca45					TIM_WriteHex:
.ca45	48		pha				pha 								; save A
.ca46	4a		lsr a				lsr 	a 							; shift MSB->LSB
.ca47	4a		lsr a				lsr 	a
.ca48	4a		lsr a				lsr 	a
.ca49	4a		lsr a				lsr 	a
.ca4a	20 4e ca	jsr $ca4e			jsr 	_TIMWH_Nibble 				; print MSB
.ca4d	68		pla				pla 								; restore and print LSB
.ca4e					_TIMWH_Nibble:
.ca4e	48		pha				pha
.ca4f	29 0f		and #$0f			and 	#15 						; mask out
.ca51	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.ca53	90 02		bcc $ca57			bcc 	_TIMWHNoLetter
.ca55	69 06		adc #$06			adc 	#6
.ca57					_TIMWHNoLetter:
.ca57	69 30		adc #$30			adc 	#48
.ca59	20 51 c0	jsr $c051			jsr 	IFT_PrintCharacter 			; print it out.
.ca5c	68		pla				pla
.ca5d	60		rts				rts
.ca5e					TIM_WriteLine:
.ca5e	a9 2e		lda #$2e			lda 	#"." 						; prompt
.ca60	20 51 c0	jsr $c051			jsr 	IFT_PrintCharacter
.ca63	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.ca65	20 51 c0	jsr $c051			jsr 	IFT_PrintCharacter
.ca68	a5 13		lda $13				lda 	zTemp2+1 					; write address
.ca6a	20 45 ca	jsr $ca45			jsr 	TIM_WriteHex
.ca6d	a5 12		lda $12				lda 	zTemp2
.ca6f	20 45 ca	jsr $ca45			jsr 	TIM_WriteHex
.ca72	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.ca74					_TIMWL_Loop:
.ca74	a9 20		lda #$20			lda 	#" "
.ca76	20 51 c0	jsr $c051			jsr 	IFT_PrintCharacter
.ca79	b1 12		lda ($12),y			lda 	(zTemp2),y
.ca7b	20 45 ca	jsr $ca45			jsr 	TIM_WriteHex
.ca7e	c8		iny				iny
.ca7f	c0 10		cpy #$10			cpy 	#16
.ca81	d0 f1		bne $ca74			bne 	_TIMWL_Loop
.ca83	4c 6b c0	jmp $c06b			jmp 	IFT_NewLine 				; new line and exit
.ca86					TIM_GetHex:
.ca86	c8		iny				iny
.ca87	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.ca89	c9 20		cmp #$20			cmp 	#32
.ca8b	f0 f9		beq $ca86			beq 	TIM_GetHex
.ca8d	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.ca8f	f0 f5		beq $ca86			beq 	TIM_GetHex
.ca91	20 ba ca	jsr $caba			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.ca94	b0 23		bcs $cab9			bcs 	_TIMGH_Exit					; if first bad then exit now.
.ca96	a9 00		lda #$00			lda 	#0 							; zero result
.ca98	85 14		sta $14				sta 	zTemp3
.ca9a	85 15		sta $15				sta 	zTemp3+1
.ca9c					_TIM_GHLoop:
.ca9c	20 ba ca	jsr $caba			jsr 	TIM_GetHexCharacter 		; get next character
.ca9f	b0 17		bcs $cab8			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.caa1	c8		iny				iny 								; skip over it.
.caa2	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.caa4	26 15		rol $15				rol 	zTemp3+1
.caa6	06 14		asl $14				asl 	zTemp3 						; now x 2
.caa8	26 15		rol $15				rol 	zTemp3+1
.caaa	06 14		asl $14				asl 	zTemp3						; now x 4
.caac	26 15		rol $15				rol 	zTemp3+1
.caae	06 14		asl $14				asl 	zTemp3 						; now x 8
.cab0	26 15		rol $15				rol 	zTemp3+1
.cab2	05 14		ora $14				ora 	zTemp3 						; OR result in
.cab4	85 14		sta $14				sta 	zTemp3
.cab6	80 e4		bra $ca9c			bra 	_TIM_GHLoop 				; loop round again.
.cab8					_TIMGH_Okay:
.cab8	18		clc				clc
.cab9					_TIMGH_Exit:
.cab9	60		rts				rts
.caba					TIM_GetHexCharacter:
.caba	b1 10		lda ($10),y			lda 	(zTemp1),y
.cabc	38		sec				sec
.cabd	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.cabf	90 0e		bcc $cacf			bcc 	_TIM_GHCFail
.cac1	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.cac3	90 0b		bcc $cad0			bcc 	_TIM_GHCExit
.cac5	c9 11		cmp #$11			cmp 	#65-48						; < A
.cac7	90 06		bcc $cacf			bcc		_TIM_GHCFail
.cac9	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.cacb	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.cacd	90 01		bcc $cad0			bcc		_TIM_GHCExit
.cacf					_TIM_GHCFail:
.cacf	38		sec				sec
.cad0					_TIM_GHCExit:
.cad0	60		rts				rts
.cad1					TIM_BreakVector:
.cad1	da		phx				phx									; save X/A on stack
.cad2	48		pha				pha
.cad3	ba		tsx				tsx 								; X points to S
.cad4	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.cad7	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.cad9	d0 03		bne $cade			bne 	_TIMBreak					; if set, it's BRK
.cadb	68		pla				pla 								; abandon routine.
.cadc	fa		plx				plx
.cadd	40		rti				rti
.cade					_TIMBreak:
.cade	68		pla				pla 								; save A X Y and maybe Z
.cadf	8d 28 04	sta $0428			sta 	TIM_A
.cae2	fa		plx				plx
.cae3	8e 29 04	stx $0429			stx 	TIM_X
.cae6	8c 2a 04	sty $042a			sty 	TIM_Y
.cae9	68		pla				pla 								; get Status Register
.caea	8d 27 04	sta $0427			sta 	TIM_SR
.caed	68		pla				pla
.caee	8d 24 04	sta $0424			sta 	TIM_PC+1 					; save calling address
.caf1	68		pla				pla
.caf2	8d 23 04	sta $0423			sta 	TIM_PC 						; high byte
.caf5	ad 24 04	lda $0424			lda 	TIM_PC+1 					; dec PC to point right.
.caf8	d0 03		bne $cafd			bne 	_TIMDecrement 				; brk bumps it.
.cafa	ce 23 04	dec $0423			dec 	TIM_PC
.cafd					_TIMDecrement:
.cafd	ce 24 04	dec $0424			dec 	TIM_PC+1
.cb00	ba		tsx				tsx 								; and copy SP
.cb01	8e 2c 04	stx $042c			stx 	TIM_SP
.cb04	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.cb06	9a		txs				txs
.cb07	4c e7 c9	jmp $c9e7			jmp 	TIM_Start 					; and start up TIM monitor.
.cb0a					TIM_UpdateRegisters:
.cb0a	20 86 ca	jsr $ca86			jsr 	TIM_GetHex 					; PC
.cb0d	b0 23		bcs $cb32			bcs 	_TIMURFail
.cb0f	a5 14		lda $14				lda 	zTemp3
.cb11	8d 24 04	sta $0424			sta 	Tim_PC+1
.cb14	a5 15		lda $15				lda 	zTemp3+1
.cb16	8d 23 04	sta $0423			sta 	Tim_PC
.cb19	20 86 ca	jsr $ca86			jsr 	TIM_GetHex 					; ignore IRQ
.cb1c	b0 14		bcs $cb32			bcs 	_TIMURFail
.cb1e	a2 00		ldx #$00			ldx 	#0
.cb20					_TIM_URLoop:
.cb20	20 86 ca	jsr $ca86			jsr 	TIM_GetHex 					; registers
.cb23	b0 0d		bcs $cb32			bcs 	_TIMURFail
.cb25	a5 14		lda $14				lda 	zTemp3
.cb27	9d 27 04	sta $0427,x			sta 	Tim_SR,x
.cb2a	e8		inx				inx
.cb2b	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.cb2d	d0 f1		bne $cb20			bne 	_TIM_URLoop
.cb2f	4c 65 c9	jmp $c965			jmp 	TIM_NewCommand
.cb32					_TIMURFail:
.cb32	4c 5e c9	jmp $c95e			jmp 	TIM_Error
.cb35					TIM_LoadMemory:
.cb35	20 86 ca	jsr $ca86			jsr 	TIM_GetHex 					; target address => zTemp2
.cb38	a5 14		lda $14				lda 	zTemp3
.cb3a	85 12		sta $12				sta 	zTemp2
.cb3c	a5 15		lda $15				lda 	zTemp3+1
.cb3e	85 13		sta $13				sta 	zTemp2+1
.cb40					_TIM_LMLoop:
.cb40	20 86 ca	jsr $ca86			jsr 	TIM_GetHex 					; next byte ?
.cb43	b0 0e		bcs $cb53			bcs 	_TIMLMDone 					; no more
.cb45	a2 00		ldx #$00			ldx 	#0							; write out.
.cb47	a5 14		lda $14				lda 	zTemp3
.cb49	81 12		sta ($12,x)			sta 	(zTemp2,x)
.cb4b	e6 12		inc $12				inc 	zTemp2 						; bump address
.cb4d	d0 f1		bne $cb40			bne 	_TIM_LMLoop
.cb4f	e6 13		inc $13				inc 	zTemp2+1
.cb51	80 ed		bra $cb40			bra 	_TIM_LMLoop
.cb53					_TIMLMDone:
.cb53	4c 65 c9	jmp $c965			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Return to file: basic.asm

>cb56	02						.byte 	2
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff					.word DefaultInterrupt
>fffc	00 c0						.word 	StartROM
>fffe	d1 ca					.word TIM_BreakVector

;******  End of listing
