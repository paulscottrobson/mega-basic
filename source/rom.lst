
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Sat Aug 31 21:15:30 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="65816"				cpu = "65816"
="em65816"				hardware = "em65816"
=1					exitonend = 1
=0					autorun = 0
=1					loadtest = 1
=1					hasfloat = 1
=1					hasinteger = 1
=253					maxstring = 253

;******  Processing file: modules/basic/pointer/em65816/src_em65816.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stackmarkers.inc

=5					SourcePosSize   =   5 							; Source position stack space needed.
=1					SMark_Gosub 	= 	1 							; 0 is GOSUB/RETURN.
=2					SMark_Repeat 	= 	2 							; 1 is REPEAT/UNTIL.
=3					SMark_While 	= 	3 							; 2 is WHILE/WEND.
=4					SMark_If 		= 	4 							; 3 is IF/ENDIF
=5					SMark_For 		= 	5 							; 4 is FOR/NEXT

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/hardware/common/macros32.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0020					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0022					zVarDataPtr: .word ? 						; position of variable data.
>0024					zVarType: 	.byte ? 						; type of data (token)
>0025					zNullString:.byte ? 						; represents a NULL string.
>0026					zBasicSP:	.word ? 						; stack pointer
>0080					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>0084					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>0085					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=134					XS2_Mantissa = XS_Mantissa+XS_Size
=138					XS2_Exponent = XS_Exponent+XS_Size
=139					XS2_Type = XS_Type+XS_Size
=140					XS3_Mantissa = XS_Mantissa+XS_Size*2
=144					XS3_Exponent = XS_Exponent+XS_Size*2
=145					XS3_Type = XS_Type+XS_Size*2
>0300					StringPtr:	.word ? 						; Top of free memory (for string allocation)
>0302					VarMemPtr: 	.word ?							; Bottom of free memory (for variables)
>0304					endOfProgram: .dword ? 						; End of Program Memory (long)
>0308					vecPrintCharacter .word ?
>030a					vecInputCharacter .word ?
>030c					UserVector .fill 4 							; USR(x) calls this.
>0310					LocalVector .fill 4 						; Indirect calls call this.
>0314					NumBufX 	.byte 	?						; buffer index position
>0315					Num_Buffer	.fill 	32 						; buffer for numeric conversions
=6					HashTableCount = 6 							; there are 6 hash tables, in token order.
=8					HashTableSize = 8 							; each hash table as 8 links.
.0335					HashTableBase:
>0335								.fill	HashTableCount * HashTableSize * 2
.0395					HashTableEnd:
=$315					Var_Buffer 	= Num_Buffer 					; buffer for variable name (same space)
>0395					Var_Type    .byte ? 						; type of variable (as a type token)
>0396					Var_Hash 	.byte ? 						; hash of identifier name.
>0397					Var_Length 	.byte ? 						; length of variable name
>0398					Var_HashAddress .byte ?						; low byte of hash table entry.
>0399					Var_DataSize .byte ?						; size of one element.
>039a					NumSuppress	.byte 	?						; leading zero suppression flag
>039b					NumConvCount .byte 	? 						; count for conversions.
>039c					ExpTemp:	.byte ?							; Working temp for exponents.
>039d					ExpCount:	.byte ? 						; Count of decimal exponents.
>039e					SignCount:	.byte ?							; Integer Divide Sign Counts.
>039f					TempStringWriteIndex: .byte ? 				; Write offset.
>03a0					ValSign: 	.byte ? 						; sign flag for val()
>03a1					SliceStart:	.byte ? 						; string slice parts
>03a2					SliceCount:	.byte ?
>03a3					RandomSeed:	.dword ? 						; Random seed.
>03a7					SignNext:	.byte ? 						; Used for keeping sign of STEP in FOR/NEXT
>03a8					BreakCount:	.byte ? 						; Counter, avoid checking break every command.
=3					ArrayMaxDim = 3 							; number of dimensions.
>03a9					ArrayDef:	.fill (ArrayMaxDim+1)*2 		; dimensions for auto-creation
>03b1					UsrArrayDef:.fill (ArrayMaxDim+1)*2 		; dimensions created in DIM
>03b9					UsrArrayIdx:.byte ? 						; index into UsrArrayDef
>03ba					LastPrinted:.byte ? 						; last printed char ?
>03bb					ListIndent: .byte ? 						; list indent level
>03bc					LastListIndent:.byte ? 						; previous one.
>03bd					DataLPtr: 	.dword ?						; the data long ptr (swapped with zCodePtr)
>03c1					DataIndex:	.byte ?							; index position.
>03c2					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>03c4					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>03c6					Tim_SR:		.byte ? 						; Processor Status
>03c7					Tim_A:		.byte ? 						; Processor Registers
>03c8					Tim_X:		.byte ?
>03c9					Tim_Y:		.byte ?
>03ca					Tim_Z:		.byte ?
>03cb					Tim_SP:		.word ?							; Stack Pointer (just in cases)
>0400					BasicStack:	.fill 	256 					; and occupy whole pages.
.0500					EndBasicStack:
>0500					IFT_XCursor:.byte ?							; current logical position on screen
>0501					IFT_YCursor:.byte ?
>0502					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0566					IFT_LineBuffer: .fill 100 					; line input buffer.

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/em65816.asm

=$7f00					HighMemory = $7F00
=$3000					VariableMemory = $3000
.1000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testcode.src

>1000	0b 0a 00 c6 01 bf 02 bb			.byte	$0b,$0a,$00,$c6,$01,$bf,$02,$bb
>1008	bf 03 00 0b 14 00 d6 01			.byte	$bf,$03,$00,$0b,$14,$00,$d6,$01
>1010	bf 02 bb bf 03 00 05 1e			.byte	$bf,$02,$bb,$bf,$03,$00,$05,$1e
>1018	00 c4 00 0e 28 00 c5 58			.byte	$00,$c4,$00,$0e,$28,$00,$c5,$58
>1020	bf 71 bf 41 7c fd 03 37			.byte	$bf,$71,$bf,$41,$7c,$fd,$03,$37
>1028	00 00					.byte	$00,$00

;******  Return to file: modules/hardware/em65816.asm

.c000					StartROM:
.c000	18		clc				clc
.c001	fb		xce				xce
.c002	c2 30		rep #$30			rep 	#$30
.c004	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.c007	1b		tcs				tcs
.c008	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.c00b	e2 30		sep #$30			sep 	#$30
.c00d	c2 30		rep #$30			rep 	#$30						; clear AXY in 16 bit.
.c00f	a9 00		lda #$00			lda 	#$0000
.c011	aa		tax				tax
.c012	a8		tay				tay
.c013	e2 30		sep #$30			sep 	#$30
.c015	5c d6 87 01	jmp $0187d6		jmp BASIC_Start
.c019					TIM_BreakHandler:
.c019	5c 69 83 01	jmp $018369			jmp 	TIM_BreakVector

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.018000					IFT_ClearScreen:
.018000	48		pha				pha
.018001	da		phx				phx
.018002	5a		phy				phy
.018003	20 9c 81	jsr $01819c			jsr 	IF_Home 					; home cursor
.018006	a2 20		ldx #$20			ldx 	#IF_Height 					; this many lines.
.018008					_IFT_CS0:
.018008	a0 40		ldy #$40			ldy 	#IF_Width 					; this many chars/line
.01800a					_IFT_CS1:
.01800a	a9 20		lda #$20			lda 	#' '						; clear line.
.01800c	20 c8 81	jsr $0181c8			jsr 	IF_Write
.01800f	88		dey				dey
.018010	d0 f8		bne $01800a			bne 	_IFT_CS1
.018012	20 af 81	jsr $0181af			jsr 	IF_NewLine 					; next line down
.018015	ca		dex				dex
.018016	d0 f0		bne $018008			bne 	_IFT_CS0
.018018	7a		ply				ply
.018019	fa		plx				plx
.01801a	68		pla				pla
.01801b					IFT_HomeCursor:
.01801b	48		pha				pha
.01801c	20 9c 81	jsr $01819c			jsr 	IF_Home
.01801f	a9 00		lda #$00			lda 	#0
.018021	8d 00 05	sta $0500			sta 	IFT_XCursor
.018024	8d 01 05	sta $0501			sta 	IFT_YCursor
.018027	68		pla				pla
.018028	60		rts				rts
.018029					IFT_UpLine:
.018029	48		pha				pha
.01802a	ad 01 05	lda $0501			lda  	IFT_YCursor 				; get Y
.01802d	3a		dec a				dec 	a 							; line above
.01802e	30 03		bmi $018033			bmi 	_IFTULExit 					; too far, abort
.018030	20 be 80	jsr $0180be			jsr 	IFT_SetYPos					; set to that line.
.018033					_IFTULExit:
.018033	68		pla				pla
.018034	60		rts				rts
.018035					IFT_PrintCharacter:
.018035	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.018037	f0 16		beq $01804f			beq 	IFT_NewLine
.018039	48		pha				pha
.01803a	20 67 80	jsr $018067			jsr 	IFT_UpperCase 				; make upper case
.01803d	20 c8 81	jsr $0181c8			jsr 	IF_Write 					; write out.
.018040	ee 00 05	inc $0500			inc 	IFT_XCursor 				; bump x cursor
.018043	ad 00 05	lda $0500			lda 	IFT_XCursor 				; reached RHS ?
.018046	c9 40		cmp #$40			cmp 	#IF_Width
.018048	d0 03		bne $01804d			bne 	_IFT_PCNotEOL
.01804a	20 4f 80	jsr $01804f			jsr 	IFT_NewLine 				; if so do new line.
.01804d					_IFT_PCNotEOL:
.01804d	68		pla				pla
.01804e	60		rts				rts
.01804f					IFT_NewLine:
.01804f	48		pha				pha
.018050	20 af 81	jsr $0181af			jsr 	IF_NewLine 					; new line on actual screen.
.018053	a9 00		lda #$00			lda 	#0 							; reset x position
.018055	8d 00 05	sta $0500			sta 	IFT_XCursor
.018058	ee 01 05	inc $0501			inc 	IFT_YCursor 				; move down.
.01805b	ad 01 05	lda $0501			lda 	IFT_YCursor
.01805e	c9 20		cmp #$20			cmp 	#IF_Height 					; reached bottom.
.018060	d0 03		bne $018065			bne 	_IFT_NL_NotEOS
.018062	20 72 80	jsr $018072			jsr 	IFT_Scroll 					; scroll screen up.
.018065					_IFT_NL_NotEOS:
.018065	68		pla				pla
.018066	60		rts				rts
.018067					IFT_UpperCase:
.018067	c9 61		cmp #$61			cmp 	#"a"
.018069	90 06		bcc $018071			bcc 	_IFT_UCExit
.01806b	c9 7b		cmp #$7b			cmp 	#"z"+1
.01806d	b0 02		bcs $018071			bcs 	_IFT_UCExit
.01806f	49 20		eor #$20			eor 	#$20
.018071					_IFT_UCExit:
.018071	60		rts				rts
.018072					IFT_Scroll:
.018072	48		pha				pha 								; save AXY
.018073	da		phx				phx
.018074	5a		phy				phy
.018075	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.018077					_IFT_SLoop:
.018077	20 97 80	jsr $018097			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.01807a	e8		inx				inx
.01807b	e0 1f		cpx #$1f			cpx 	#IF_Height-1				; do whole screen
.01807d	d0 f8		bne $018077			bne 	_IFT_SLoop
.01807f	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.018081	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.018084	a2 40		ldx #$40			ldx 	#IF_Width 					; blank line
.018086					_IFT_SBlank:
.018086	a9 20		lda #$20			lda 	#32
.018088	20 c8 81	jsr $0181c8			jsr 	IF_Write
.01808b	ca		dex				dex
.01808c	d0 f8		bne $018086			bne 	_IFT_SBlank
.01808e	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.018090	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.018093	7a		ply				ply
.018094	fa		plx				plx
.018095	68		pla				pla
.018096	60		rts				rts
.018097					_IFT_ScrollLine:
.018097	da		phx				phx
.018098	da		phx				phx
.018099	8a		txa				txa 								; copy line into buffer.
.01809a	1a		inc a				inc 	a 							; next line down.
.01809b	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.01809e	a2 00		ldx #$00			ldx 	#0
.0180a0					_IFTScrollCopy1:
.0180a0	20 bf 81	jsr $0181bf			jsr 	IF_Read
.0180a3	9d 02 05	sta $0502,x			sta 	IFT_Buffer,x
.0180a6	e8		inx				inx
.0180a7	e0 40		cpx #$40			cpx 	#IF_Width
.0180a9	d0 f5		bne $0180a0			bne 	_IFTScrollCopy1
.0180ab	68		pla				pla
.0180ac	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.0180af	a2 00		ldx #$00			ldx 	#0
.0180b1					_IFTScrollCopy2:
.0180b1	bd 02 05	lda $0502,x			lda 	IFT_Buffer,x
.0180b4	20 c8 81	jsr $0181c8			jsr 	IF_Write
.0180b7	e8		inx				inx
.0180b8	e0 40		cpx #$40			cpx 	#IF_Width
.0180ba	d0 f5		bne $0180b1			bne 	_IFTScrollCopy2
.0180bc	fa		plx				plx
.0180bd	60		rts				rts
.0180be					IFT_SetYPos:
.0180be	48		pha				pha
.0180bf	da		phx				phx
.0180c0	aa		tax				tax
.0180c1	20 1b 80	jsr $01801b			jsr 	IFT_HomeCursor
.0180c4	e0 00		cpx #$00			cpx 	#0
.0180c6	f0 09		beq $0180d1			beq 	_IFT_MOAExit
.0180c8					_IFT_MOALoop:
.0180c8	20 af 81	jsr $0181af			jsr 	IF_NewLine
.0180cb	ee 01 05	inc $0501			inc 	IFT_YCursor
.0180ce	ca		dex				dex
.0180cf	d0 f7		bne $0180c8			bne		_IFT_MOALoop
.0180d1					_IFT_MOAExit:
.0180d1	fa		plx				plx
.0180d2	68		pla				pla
.0180d3	60		rts				rts
.0180d4					IFT_GetKeyCursor:
.0180d4	20 dc 80	jsr $0180dc			jsr 	_IFT_FlipCursor 			; reverse current
.0180d7					_IFT_GKCWait:
.0180d7	20 d9 81	jsr $0181d9			jsr 	IF_GetKey 					; get key
.0180da	f0 fb		beq $0180d7			beq 	_IFT_GKCWait
.0180dc					_IFT_FlipCursor:
.0180dc	48		pha				pha 								; save
.0180dd	20 bf 81	jsr $0181bf			jsr 	IF_Read 					; read
.0180e0	20 d1 81	jsr $0181d1			jsr 	IF_LeftOne
.0180e3	49 80		eor #$80			eor 	#$80 						; reverse
.0180e5	20 c8 81	jsr $0181c8			jsr 	IF_Write 					; write
.0180e8	20 d1 81	jsr $0181d1			jsr 	IF_LeftOne
.0180eb	68		pla				pla
.0180ec	60		rts				rts
.0180ed					IFT_ReadLine:
.0180ed	48		pha				pha
.0180ee					_IFT_RLLoop:
.0180ee	20 d4 80	jsr $0180d4			jsr 	IFT_GetKeyCursor 			; get keystroke
.0180f1	c9 0d		cmp #$0d			cmp 	#13							; return
.0180f3	f0 7d		beq $018172			beq 	_IFT_RLExit
.0180f5	c9 20		cmp #$20			cmp 	#32 						; control character
.0180f7	90 05		bcc $0180fe			bcc 	_IFT_Control
.0180f9	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0180fc	80 f0		bra $0180ee			bra 	_IFT_RLLoop
.0180fe					_IFT_Control:
.0180fe	c9 01		cmp #$01			cmp 	#"A"-64
.018100	f0 26		beq $018128			beq 	_IFT_Left
.018102	c9 04		cmp #$04			cmp 	#"D"-64
.018104	f0 2e		beq $018134			beq 	_IFT_Right
.018106	c9 17		cmp #$17			cmp 	#"W"-64
.018108	f0 36		beq $018140			beq 	_IFT_Up
.01810a	c9 13		cmp #$13			cmp 	#"S"-64
.01810c	f0 3e		beq $01814c			beq 	_IFT_Down
.01810e	c9 08		cmp #$08			cmp 	#"H"-64
.018110	f0 09		beq $01811b			beq 	_IFT_Backspace
.018112	c9 1a		cmp #$1a			cmp 	#"Z"-64
.018114	d0 d8		bne $0180ee			bne 	_IFT_RLLoop
.018116	20 00 80	jsr $018000			jsr 	IFT_ClearScreen				; clear CTL-Z
.018119	80 d3		bra $0180ee			bra 	_IFT_RLLoop
.01811b					_IFT_Backspace:
.01811b	ad 00 05	lda $0500			lda 	IFT_XCursor 				; check not start of line.
.01811e	f0 ce		beq $0180ee			beq 	_IFT_RLLoop
.018120	20 d1 81	jsr $0181d1			jsr 	IF_LeftOne
.018123	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.018125	20 c8 81	jsr $0181c8			jsr 	IF_Write
.018128					_IFT_Left:
.018128	ce 00 05	dec $0500			dec 	IFT_XCursor 				; left CTL-W
.01812b	10 29		bpl $018156			bpl 	_IFT_Reposition
.01812d	a9 3f		lda #$3f			lda 	#IF_Width-1
.01812f					_IFT_SetX:
.01812f	8d 00 05	sta $0500			sta 	IFT_XCursor
.018132	80 22		bra $018156			bra 	_IFT_Reposition
.018134					_IFT_Right:
.018134	ee 00 05	inc $0500			inc 	IFT_XCursor
.018137	ad 00 05	lda $0500			lda 	IFT_XCursor
.01813a	49 40		eor #$40			eor 	#IF_Width
.01813c	f0 f1		beq $01812f			beq 	_IFT_SetX
.01813e	80 16		bra $018156			bra 	_IFT_Reposition
.018140					_IFT_Up:
.018140	ce 01 05	dec $0501			dec 	IFT_YCursor
.018143	10 11		bpl $018156			bpl 	_IFT_Reposition
.018145	a9 1f		lda #$1f			lda 	#IF_Height-1
.018147					_IFT_SetY:
.018147	8d 01 05	sta $0501			sta 	IFT_YCursor
.01814a	80 0a		bra $018156			bra 	_IFT_Reposition
.01814c					_IFT_Down:
.01814c	ee 01 05	inc $0501			inc 	IFT_YCursor
.01814f	ad 01 05	lda $0501			lda 	IFT_YCursor
.018152	49 20		eor #$20			eor 	#IF_Height
.018154	f0 f1		beq $018147			beq 	_IFT_SetY
.018156					_IFT_Reposition:
.018156	ad 00 05	lda $0500			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.018159	48		pha				pha
.01815a	ad 01 05	lda $0501			lda 	IFT_YCursor
.01815d	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.018160	68		pla				pla
.018161	aa		tax				tax
.018162	e0 00		cpx #$00			cpx 	#0
.018164	f0 88		beq $0180ee			beq 	_IFT_RLLoop
.018166					_IFT_MoveRight:
.018166	20 bf 81	jsr $0181bf			jsr 	IF_Read
.018169	ee 00 05	inc $0500			inc 	IFT_XCursor
.01816c	ca		dex				dex
.01816d	d0 f7		bne $018166			bne 	_IFT_MoveRight
.01816f	4c ee 80	jmp $0180ee			jmp 	_IFT_RLLoop
.018172					_IFT_RLExit:
.018172	ad 01 05	lda $0501			lda 	IFT_YCursor 				; go to start of line.
.018175	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.018178	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.01817a					_IFT_RLRead:
.01817a	20 bf 81	jsr $0181bf			jsr 	IF_Read
.01817d	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.018180	e8		inx				inx
.018181	e0 40		cpx #$40			cpx 	#IF_Width
.018183	d0 f5		bne $01817a			bne 	_IFT_RLRead
.018185					_IFT_RL_Trim:
.018185	ca		dex				dex 	 							; previous char
.018186	30 07		bmi $01818f			bmi 	_IFT_Found 					; gone too far
.018188	bd 66 05	lda $0566,x			lda 	IFT_LineBuffer,x			; go back if space
.01818b	c9 20		cmp #$20			cmp 	#" "
.01818d	f0 f6		beq $018185			beq 	_IFT_RL_Trim
.01818f					_IFT_Found:
.01818f	e8		inx				inx 								; forward to non-space
.018190	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.018192	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.018195	68		pla				pla
.018196	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.018198	a0 05		ldy #$05			ldy 	#IFT_LineBuffer >> 8
.01819a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_em65816.asm

=64					IF_Width 	= 64 							; characters across
=32					IF_Height 	= 32 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line.
=8					IF_XPos 	= 8 							; current position, horizontal.
=$f0000					IF_Screen = $F0000							; 2k screen RAM here
=$f8010					IF_PKeyboard = $F8010						; Keyboard port.
=$f8000					IF_PBreak = $F8000 							; Break key.
.01819b					IF_Reset:
.01819b	60		rts				rts
.01819c					IF_Home:
.01819c	48		pha				pha
.01819d	64 08		stz $08				stz 	IF_XPos 					; zero X position
.01819f	a9 00		lda #$00			lda 	#IF_Screen & $FF 			; set r/w pos.
.0181a1	85 04		sta $04				sta 	IF_Pos
.0181a3	a9 00		lda #$00			lda 	#(IF_Screen >> 8) & $FF
.0181a5	85 05		sta $05				sta 	IF_Pos+1
.0181a7	a9 0f		lda #$0f			lda 	#IF_Screen >> 16
.0181a9	85 06		sta $06				sta 	IF_Pos+2
.0181ab	64 07		stz $07				stz 	IF_Pos+3
.0181ad	68		pla				pla
.0181ae	60		rts				rts
.0181af					IF_NewLine:
.0181af	48		pha				pha
.0181b0	64 08		stz $08				stz 	IF_XPos						; back to start of line
.0181b2	18		clc				clc 								; down one line
.0181b3	a5 04		lda $04				lda 	IF_Pos
.0181b5	69 40		adc #$40			adc 	#64
.0181b7	85 04		sta $04				sta 	IF_Pos
.0181b9	90 02		bcc $0181bd			bcc 	_IF_NoCarry 				; carry through.
.0181bb	e6 05		inc $05				inc 	IF_Pos+1
.0181bd					_IF_NoCarry:
.0181bd	68		pla				pla
.0181be	60		rts				rts
.0181bf					IF_Read:
.0181bf	5a		phy				phy 								; save current Y
.0181c0	a4 08		ldy $08				ldy 	IF_XPos 					; read character at current position
.0181c2	b7 04		lda [$04],y			lda 	[IF_Pos],y
.0181c4	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181c6	7a		ply				ply									; restore Y
.0181c7	60		rts				rts
.0181c8					IF_Write:
.0181c8	5a		phy				phy 								; save current Y
.0181c9	a4 08		ldy $08				ldy 	IF_XPos 					; write character at current position
.0181cb	97 04		sta [$04],y			sta 	[IF_Pos],y
.0181cd	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181cf	7a		ply				ply									; restore Y
.0181d0	60		rts				rts
.0181d1					IF_LeftOne:
.0181d1	c6 08		dec $08				dec 	IF_XPos
.0181d3	60		rts				rts
.0181d4					IF_CheckBreak:
.0181d4	af 00 80 0f	lda $0f8000			lda 	IF_PBreak					; non-zero if Ctrl+C pressed.
.0181d8	60		rts				rts
.0181d9					IF_GetKey:
.0181d9	af 10 80 0f	lda $0f8010			lda 	IF_PKeyboard				; read keyboard
.0181dd	f0 08		beq $0181e7			beq		_IFGK_NoKey 				; skip if zero,no key pressed
.0181df	48		pha				pha 								; key pressed, clear queue.
.0181e0	a9 00		lda #$00			lda 	#0
.0181e2	8f 10 80 0f	sta $0f8010			sta 	IF_PKeyboard
.0181e6	68		pla				pla
.0181e7					_IFGK_NoKey:
.0181e7	09 00		ora #$00			ora 	#0							; set Z flag appropriately.
.0181e9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.0181ea					TIM_Error:
.0181ea	20 29 80	jsr $018029			jsr 	IFT_UpLine 					; go up one line.
.0181ed	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.0181ef	80 02		bra $0181f3			bra 	TIM_ShowPrompt
.0181f1					TIM_NewCommand:
.0181f1	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.0181f3					TIM_ShowPrompt:
.0181f3	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.0181f6	20 ed 80	jsr $0180ed			jsr 	IFT_ReadLine	 			; get character, go to next line
.0181f9	20 4f 80	jsr $01804f			jsr 	IFT_NewLine					; go to next line.
.0181fc	86 10		stx $10				stx 	zTemp1 						; save line read address
.0181fe	84 11		sty $11				sty 	zTemp1+1
.018200	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.018202	b1 10		lda ($10),y			lda 	(zTemp1),y
.018204	c9 3f		cmp #$3f			cmp 	#"?"
.018206	f0 04		beq $01820c			beq 	TIM_SkipFirst
.018208	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.01820a	d0 01		bne $01820d			bne 	TIM_NotDot
.01820c					TIM_SkipFirst:
.01820c	c8		iny				iny
.01820d					TIM_NotDot:
.01820d	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.01820f	c9 52		cmp #$52			cmp 	#"R"						; show registers
.018211	f0 6b		beq $01827e			beq 	TIM_ShowRegisters
.018213	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.018215	f0 12		beq $018229			beq 	TIM_ShowMemory
.018217	c9 47		cmp #$47			cmp 	#"G"						; execute
.018219	f0 49		beq $018264			beq 	TIM_Execute
.01821b	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.01821d	f0 07		beq $018226			beq 	TIM_GoLoadMemory
.01821f	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.018221	d0 c7		bne $0181ea			bne 	TIM_Error
.018223	4c a2 83	jmp $0183a2			jmp 	TIM_UpdateRegisters
.018226					TIM_GoLoadMemory:
.018226	4c d2 83	jmp $0183d2			jmp 	TIM_LoadMemory
.018229					TIM_ShowMemory:
.018229	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.01822c	b0 bc		bcs $0181ea			bcs 	TIM_Error
.01822e	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.018230	85 12		sta $12				sta 	zTemp2
.018232	a5 15		lda $15				lda 	zTemp3+1
.018234	85 13		sta $13				sta 	zTemp2+1
.018236	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.018239	90 08		bcc $018243			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.01823b	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.01823d	85 14		sta $14				sta 	zTemp3
.01823f	a5 13		lda $13				lda 	zTemp2+1
.018241	85 15		sta $15				sta 	zTemp3+1
.018243					_TIMSM_Start:
.018243	20 f6 82	jsr $0182f6			jsr 	TIM_WriteLine 				; write one line of hex out
.018246	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.018248	18		clc				clc
.018249	69 10		adc #$10			adc 	#16
.01824b	85 12		sta $12				sta 	zTemp2
.01824d	90 02		bcc $018251			bcc 	_TIMSM_NoCarry
.01824f	e6 13		inc $13				inc 	zTemp2+1
.018251					_TIMSM_NoCarry:
.018251	20 d4 81	jsr $0181d4			jsr 	IF_CheckBreak 				; check CTL+C
.018254	d0 0b		bne $018261			bne 	_TIMSM_Ends 				; if pressed break out.
.018256	38		sec				sec 								; check past the end address in zTemp3
.018257	a5 14		lda $14				lda 	zTemp3
.018259	e5 12		sbc $12				sbc 	zTemp2
.01825b	a5 15		lda $15				lda 	zTemp3+1
.01825d	e5 13		sbc $13				sbc 	zTemp2+1
.01825f	10 e2		bpl $018243			bpl 	_TIMSM_Start
.018261					_TIMSM_Ends:
.018261	4c f1 81	jmp $0181f1			jmp 	TIM_NewCommand
.018264					TIM_Execute:
.018264	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; get the execute address
.018267	b0 81		bcs $0181ea			bcs 	TIM_Error 					; not legitimate
.018269	ae cb 03	ldx $03cb			ldx 	TIM_SP 						; set up SP
.01826c	9a		txs				txs
.01826d	ad c6 03	lda $03c6			lda 	TIM_SR 						; Status for PLP
.018270	48		pha				pha
.018271	ad c7 03	lda $03c7			lda 	TIM_A 						; restore AXYZ
.018274	ae c8 03	ldx $03c8			ldx 	TIM_X
.018277	ac c9 03	ldy $03c9			ldy 	TIM_Y
.01827a	28		plp				plp 								; and PS Byte.
.01827b	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.01827e					TIM_Start:
.01827e					TIM_ShowRegisters:
.01827e	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.018281	8d c5 03	sta $03c5			sta 	TIM_IRQ+1
.018284	ad ff ff	lda $ffff			lda 	$FFFF
.018287	8d c4 03	sta $03c4			sta 	TIM_IRQ
.01828a	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.01828c					_TIMSR_Text:
.01828c	bf bd 82 01	lda $0182bd,x			lda 	_TIMSR_Label,x
.018290	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018293	e8		inx				inx
.018294	e0 20		cpx #$20			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.018296	d0 f4		bne $01828c			bne 	_TIMSR_Text
.018298	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.01829a					_TIMSR_Skip:
.01829a	e8		inx				inx
.01829b					_TIMSR_LoopSpace:
.01829b	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.01829d	b0 04		bcs $0182a3			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.01829f	8a		txa				txa
.0182a0	4a		lsr a				lsr 	a
.0182a1	b0 05		bcs $0182a8			bcs 	_TIMSR_NoSpace
.0182a3					_TIMSR_Space:
.0182a3	a9 20		lda #$20			lda 	#" "
.0182a5	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182a8					_TIMSR_NoSpace:
.0182a8	bd c2 03	lda $03c2,x			lda 	TIM_PC,x 					; output hex value.
.0182ab	20 dd 82	jsr $0182dd			jsr 	TIM_WriteHex
.0182ae	e8		inx				inx
.0182af	e0 08		cpx #$08			cpx 	#TIM_Z-TIM_PC
.0182b1	f0 e7		beq $01829a			beq 	_TIMSR_Skip
.0182b3	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.0182b5	d0 e4		bne $01829b			bne 	_TimSR_LoopSpace
.0182b7	20 4f 80	jsr $01804f			jsr 	IFT_NewLine 				; new line
.0182ba	4c f1 81	jmp $0181f1			jmp	 	TIM_NewCommand 				; new command.
.0182bd					_TIMSR_Label:
>0182bd	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>0182c5	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>0182d5	52
>0182d6	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.0182dd					_TIMSR_LabelEnd:
.0182dd					TIM_WriteHex:
.0182dd	48		pha				pha 								; save A
.0182de	4a		lsr a				lsr 	a 							; shift MSB->LSB
.0182df	4a		lsr a				lsr 	a
.0182e0	4a		lsr a				lsr 	a
.0182e1	4a		lsr a				lsr 	a
.0182e2	20 e6 82	jsr $0182e6			jsr 	_TIMWH_Nibble 				; print MSB
.0182e5	68		pla				pla 								; restore and print LSB
.0182e6					_TIMWH_Nibble:
.0182e6	48		pha				pha
.0182e7	29 0f		and #$0f			and 	#15 						; mask out
.0182e9	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.0182eb	90 02		bcc $0182ef			bcc 	_TIMWHNoLetter
.0182ed	69 06		adc #$06			adc 	#6
.0182ef					_TIMWHNoLetter:
.0182ef	69 30		adc #$30			adc 	#48
.0182f1	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter 			; print it out.
.0182f4	68		pla				pla
.0182f5	60		rts				rts
.0182f6					TIM_WriteLine:
.0182f6	a9 2e		lda #$2e			lda 	#"." 						; prompt
.0182f8	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182fb	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.0182fd	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018300	a5 13		lda $13				lda 	zTemp2+1 					; write address
.018302	20 dd 82	jsr $0182dd			jsr 	TIM_WriteHex
.018305	a5 12		lda $12				lda 	zTemp2
.018307	20 dd 82	jsr $0182dd			jsr 	TIM_WriteHex
.01830a	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.01830c					_TIMWL_Loop:
.01830c	a9 20		lda #$20			lda 	#" "
.01830e	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018311	b1 12		lda ($12),y			lda 	(zTemp2),y
.018313	20 dd 82	jsr $0182dd			jsr 	TIM_WriteHex
.018316	c8		iny				iny
.018317	c0 10		cpy #$10			cpy 	#16
.018319	d0 f1		bne $01830c			bne 	_TIMWL_Loop
.01831b	4c 4f 80	jmp $01804f			jmp 	IFT_NewLine 				; new line and exit
.01831e					TIM_GetHex:
.01831e	c8		iny				iny
.01831f	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.018321	c9 20		cmp #$20			cmp 	#32
.018323	f0 f9		beq $01831e			beq 	TIM_GetHex
.018325	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.018327	f0 f5		beq $01831e			beq 	TIM_GetHex
.018329	20 52 83	jsr $018352			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.01832c	b0 23		bcs $018351			bcs 	_TIMGH_Exit					; if first bad then exit now.
.01832e	a9 00		lda #$00			lda 	#0 							; zero result
.018330	85 14		sta $14				sta 	zTemp3
.018332	85 15		sta $15				sta 	zTemp3+1
.018334					_TIM_GHLoop:
.018334	20 52 83	jsr $018352			jsr 	TIM_GetHexCharacter 		; get next character
.018337	b0 17		bcs $018350			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.018339	c8		iny				iny 								; skip over it.
.01833a	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.01833c	26 15		rol $15				rol 	zTemp3+1
.01833e	06 14		asl $14				asl 	zTemp3 						; now x 2
.018340	26 15		rol $15				rol 	zTemp3+1
.018342	06 14		asl $14				asl 	zTemp3						; now x 4
.018344	26 15		rol $15				rol 	zTemp3+1
.018346	06 14		asl $14				asl 	zTemp3 						; now x 8
.018348	26 15		rol $15				rol 	zTemp3+1
.01834a	05 14		ora $14				ora 	zTemp3 						; OR result in
.01834c	85 14		sta $14				sta 	zTemp3
.01834e	80 e4		bra $018334			bra 	_TIM_GHLoop 				; loop round again.
.018350					_TIMGH_Okay:
.018350	18		clc				clc
.018351					_TIMGH_Exit:
.018351	60		rts				rts
.018352					TIM_GetHexCharacter:
.018352	b1 10		lda ($10),y			lda 	(zTemp1),y
.018354	38		sec				sec
.018355	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.018357	90 0e		bcc $018367			bcc 	_TIM_GHCFail
.018359	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.01835b	90 0b		bcc $018368			bcc 	_TIM_GHCExit
.01835d	c9 11		cmp #$11			cmp 	#65-48						; < A
.01835f	90 06		bcc $018367			bcc		_TIM_GHCFail
.018361	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.018363	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.018365	90 01		bcc $018368			bcc		_TIM_GHCExit
.018367					_TIM_GHCFail:
.018367	38		sec				sec
.018368					_TIM_GHCExit:
.018368	60		rts				rts
.018369					TIM_BreakVector:
.018369	da		phx				phx									; save X/A on stack
.01836a	48		pha				pha
.01836b	ba		tsx				tsx 								; X points to S
.01836c	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.01836f	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.018371	d0 03		bne $018376			bne 	_TIMBreak					; if set, it's BRK
.018373	68		pla				pla 								; abandon routine.
.018374	fa		plx				plx
.018375	40		rti				rti
.018376					_TIMBreak:
.018376	68		pla				pla 								; save A X Y and maybe Z
.018377	8d c7 03	sta $03c7			sta 	TIM_A
.01837a	fa		plx				plx
.01837b	8e c8 03	stx $03c8			stx 	TIM_X
.01837e	8c c9 03	sty $03c9			sty 	TIM_Y
.018381	68		pla				pla 								; get Status Register
.018382	8d c6 03	sta $03c6			sta 	TIM_SR
.018385	68		pla				pla
.018386	8d c3 03	sta $03c3			sta 	TIM_PC+1 					; save calling address
.018389	68		pla				pla
.01838a	8d c2 03	sta $03c2			sta 	TIM_PC 						; high byte
.01838d	ad c3 03	lda $03c3			lda 	TIM_PC+1 					; dec PC to point right.
.018390	d0 03		bne $018395			bne 	_TIMDecrement 				; brk bumps it.
.018392	ce c2 03	dec $03c2			dec 	TIM_PC
.018395					_TIMDecrement:
.018395	ce c3 03	dec $03c3			dec 	TIM_PC+1
.018398	ba		tsx				tsx 								; and copy SP
.018399	8e cb 03	stx $03cb			stx 	TIM_SP
.01839c	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.01839e	9a		txs				txs
.01839f	4c 7e 82	jmp $01827e			jmp 	TIM_Start 					; and start up TIM monitor.
.0183a2					TIM_UpdateRegisters:
.0183a2	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; PC
.0183a5	b0 28		bcs $0183cf			bcs 	_TIMURFail
.0183a7	a5 14		lda $14				lda 	zTemp3
.0183a9	8d c3 03	sta $03c3			sta 	Tim_PC+1
.0183ac	a5 15		lda $15				lda 	zTemp3+1
.0183ae	8d c2 03	sta $03c2			sta 	Tim_PC
.0183b1	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; ignore IRQ
.0183b4	b0 19		bcs $0183cf			bcs 	_TIMURFail
.0183b6	a2 00		ldx #$00			ldx 	#0
.0183b8					_TIM_URLoop:
.0183b8	e0 04		cpx #$04			cpx 	#Tim_Z-Tim_SR
.0183ba	d0 01		bne $0183bd			bne 	_TIM_1
.0183bc	e8		inx				inx
.0183bd					_TIM_1:
.0183bd	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; registers
.0183c0	b0 0d		bcs $0183cf			bcs 	_TIMURFail
.0183c2	a5 14		lda $14				lda 	zTemp3
.0183c4	9d c6 03	sta $03c6,x			sta 	Tim_SR,x
.0183c7	e8		inx				inx
.0183c8	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.0183ca	d0 ec		bne $0183b8			bne 	_TIM_URLoop
.0183cc	4c f1 81	jmp $0181f1			jmp 	TIM_NewCommand
.0183cf					_TIMURFail:
.0183cf	4c ea 81	jmp $0181ea			jmp 	TIM_Error
.0183d2					TIM_LoadMemory:
.0183d2	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; target address => zTemp2
.0183d5	a5 14		lda $14				lda 	zTemp3
.0183d7	85 12		sta $12				sta 	zTemp2
.0183d9	a5 15		lda $15				lda 	zTemp3+1
.0183db	85 13		sta $13				sta 	zTemp2+1
.0183dd					_TIM_LMLoop:
.0183dd	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; next byte ?
.0183e0	b0 0e		bcs $0183f0			bcs 	_TIMLMDone 					; no more
.0183e2	a2 00		ldx #$00			ldx 	#0							; write out.
.0183e4	a5 14		lda $14				lda 	zTemp3
.0183e6	81 12		sta ($12,x)			sta 	(zTemp2,x)
.0183e8	e6 12		inc $12				inc 	zTemp2 						; bump address
.0183ea	d0 f1		bne $0183dd			bne 	_TIM_LMLoop
.0183ec	e6 13		inc $13				inc 	zTemp2+1
.0183ee	80 ed		bra $0183dd			bra 	_TIM_LMLoop
.0183f0					_TIMLMDone:
.0183f0	4c f1 81	jmp $0181f1			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/skip.asm

.0183f3					StructureSearchSingle:
.0183f3	a2 00		ldx #$00			ldx 	#0
.0183f5					StructureSearchDouble:
.0183f5	85 10		sta $10				sta 	zTemp1 						; save the target on zTemp1,zTemp1+1
.0183f7	86 11		stx $11				stx 	zTemp1+1
.0183f9	a9 00		lda #$00			lda 	#0 							; set the structure depth to zero (zTemp2)
.0183fb	85 12		sta $12				sta 	zTemp2
.0183fd	80 18		bra $018417			bra 	_SSWLoop 					; jump in, start scanning from here.
.0183ff					_SSWNextLine:
.0183ff	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018401	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.018403	18		clc				clc
.018404	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018406	85 16		sta $16				sta 	zCodePtr
.018408	90 02		bcc $01840c			bcc 	_SNLNoCarry
.01840a	e6 17		inc $17				inc 	zCodePtr+1
.01840c					_SNLNoCarry:
.01840c	a0 00		ldy #$00			ldy 	#0
.01840e	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018410	c9 00		cmp #$00			cmp 	#0					 		; if zero, fail.
.018412	f0 54		beq $018468			beq 	_SSWFail
.018414	c8		iny				iny
.018415	c8		iny				iny
.018416					_SSWNextSimple:
.018416	c8		iny				iny
.018417					_SSWLoop:
.018417	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018419	c9 00		cmp #$00			cmp 	#0 							; end of line ?
.01841b	f0 e2		beq $0183ff			beq 	_SSWNextLine 				; if so, then next line
.01841d	10 f7		bpl $018416			bpl 	_SSWNextSimple 				; needs to be a token, just skip char/number.
.01841f	a6 12		ldx $12				ldx 	zTemp2 						; check structure count
.018421	d0 08		bne $01842b			bne 	_SSWCheckUpDown 			; if it's non zero, then a match doesn't work.
.018423	c5 10		cmp $10				cmp 	zTemp1 						; found the right keyword, either choice.
.018425	f0 2d		beq $018454			beq 	_SSWFound 					; so exit.
.018427	c5 11		cmp $11				cmp 	zTemp1+1
.018429	f0 29		beq $018454			beq 	_SSWFound
.01842b					_SSWCheckUpDown:
.01842b	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus 			; if < keyword +
.01842d	90 10		bcc $01843f			bcc 	_SSWNext
.01842f	c9 93		cmp #$93			cmp 	#firstKeywordMinus 			; if < keyword - then as keyword +
.018431	90 08		bcc $01843b			bcc 	_SSWPlus
.018433	c9 98		cmp #$98			cmp 	#firstUnaryFunction			; if < first unary down as keyword -
.018435	b0 08		bcs $01843f			bcs 	_SSWNext
.018437	c6 12		dec $12				dec 	zTemp2 						; reduce structure count.
.018439	c6 12		dec $12				dec 	zTemp2
.01843b					_SSWPlus:
.01843b	e6 12		inc $12				inc 	zTemp2
.01843d	30 16		bmi $018455			bmi 	_SSWUnder					; error if driven -ve
.01843f					_SSWNext:
.01843f	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018441	c8		iny				iny 								; skip
.018442	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018444	90 0c		bcc $018452			bcc 	_SEDone 					; so just skip over it.
.018446	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018448	90 07		bcc $018451			bcc 	_SEDouble
.01844a	98		tya				tya 								; this is Y + 1
.01844b	18		clc				clc
.01844c	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.01844e	a8		tay				tay 								; back in Y.
.01844f	88		dey				dey 								; fix up, one for the +1, one for the iny
.018450	88		dey				dey
.018451					_SEDouble:
.018451	c8		iny				iny
.018452					_SEDone:
.018452	80 c3		bra $018417			bra 	_SSWLoop
.018454					_SSWFound:
.018454	60		rts				rts
.018455					_SSWUnder:
.018455	20 4e 85	jsr $01854e			jsr ERR_Handler
>018458	53 74 72 75 63 74 75 72			.text "Structure order",0
>018460	65 20 6f 72 64 65 72 00
.018468					_SSWFail:
.018468	20 4e 85	jsr $01854e			jsr ERR_Handler
>01846b	43 61 6e 27 74 20 66 69			.text "Can't find structure",0
>018473	6e 64 20 73 74 72 75 63 74 75 72 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stack.asm

.018480					StackReset:
.018480	48		pha				pha
.018481	5a		phy				phy
.018482	a9 00		lda #$00			lda 	#(BasicStack & $FF) 		; reset pointer
.018484	85 26		sta $26				sta 	zBasicSP
.018486	a9 04		lda #$04			lda 	#(BasicStack >> 8)
.018488	85 27		sta $27				sta 	zBasicSP+1
.01848a	a0 00		ldy #$00			ldy 	#0 							; reset stack top to $00 which cannot
.01848c	98		tya				tya 								; be a legal token.
.01848d	91 26		sta ($26),y			sta 	(zBasicSP),y
.01848f	7a		ply				ply
.018490	68		pla				pla
.018491	60		rts				rts
.018492					StackPushFrame:
.018492	48		pha				pha
.018493	5a		phy				phy
.018494	1a		inc a				inc 	a 							; one extra byte in frame, for the marker.
.018495	48		pha				pha 								; save it.
.018496	29 0f		and #$0f			and 	#$0F 						; lower 4 bits
.018498	18		clc				clc 								; add to Basic Stack
.018499	65 26		adc $26				adc 	zBasicSP
.01849b	85 26		sta $26				sta 	zBasicSP
.01849d	90 02		bcc $0184a1			bcc 	_SPFNoBump
.01849f	e6 27		inc $27				inc 	zBasicSP+1
.0184a1					_SPFNoBump:
.0184a1	a0 00		ldy #$00			ldy 	#0
.0184a3	68		pla				pla
.0184a4	91 26		sta ($26),y			sta 	(zBasicSP),y
.0184a6	7a		ply				ply
.0184a7	68		pla				pla
.0184a8	60		rts				rts
.0184a9					StackPopFrame:
.0184a9	48		pha				pha
.0184aa	5a		phy				phy
.0184ab	a0 00		ldy #$00			ldy 	#0 							; compare with top of stack using EOR
.0184ad	51 26		eor ($26),y			eor 	(zBasicSP),y
.0184af	29 f0		and #$f0			and 	#$F0 						; top 4 bits zero, match
.0184b1	d0 12		bne $0184c5			bne 	SPFError 					; mixed structures
.0184b3	b1 26		lda ($26),y			lda 	(zBasicSP),y 				; get size from byte
.0184b5	29 0f		and #$0f			and 	#$0F
.0184b7	49 ff		eor #$ff			eor 	#$FF						; 2's complement
.0184b9	38		sec				sec
.0184ba	65 26		adc $26				adc 	zBasicSP
.0184bc	85 26		sta $26				sta 	zBasicSP
.0184be	b0 02		bcs $0184c2			bcs 	_SPFNoBump
.0184c0	c6 27		dec $27				dec 	zBasicSP+1
.0184c2					_SPFNoBump:
.0184c2	7a		ply				ply
.0184c3	68		pla				pla
.0184c4	60		rts				rts
.0184c5					SPFError:
.0184c5	20 4e 85	jsr $01854e			jsr ERR_Handler
>0184c8	4d 69 78 65 64 20 53 74			.text "Mixed Structures",0
>0184d0	72 75 63 74 75 72 65 73 00
.0184d9					StackSavePosition:
.0184d9	98		tya				tya
.0184da	5a		phy				phy
.0184db	a0 05		ldy #$05			ldy 	#5
.0184dd	91 26		sta ($26),y			sta 	(zBasicSP),y
.0184df	a0 01		ldy #$01			ldy 	#1
.0184e1	a5 16		lda $16				lda 	zCodePtr+0 					; 4 bytes, could reduce this for 65816/6502
.0184e3	91 26		sta ($26),y			sta 	(zBasicSP),y
.0184e5	c8		iny				iny
.0184e6	a5 17		lda $17				lda 	zCodePtr+1
.0184e8	91 26		sta ($26),y			sta 	(zBasicSP),y
.0184ea	c8		iny				iny
.0184eb	a5 18		lda $18				lda 	zCodePtr+2
.0184ed	91 26		sta ($26),y			sta 	(zBasicSP),y
.0184ef	c8		iny				iny
.0184f0	a5 19		lda $19				lda 	zCodePtr+3
.0184f2	91 26		sta ($26),y			sta 	(zBasicSP),y
.0184f4	7a		ply				ply
.0184f5	60		rts				rts
.0184f6					StackRestorePosition:
.0184f6	5a		phy				phy
.0184f7	a0 01		ldy #$01			ldy 	#1 							; copy 4 bytes that are the pointer
.0184f9	b1 26		lda ($26),y			lda 	(zBasicSP),y
.0184fb	85 16		sta $16				sta 	zCodePtr+0
.0184fd	c8		iny				iny
.0184fe	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018500	85 17		sta $17				sta 	zCodePtr+1
.018502	c8		iny				iny
.018503	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018505	85 18		sta $18				sta 	zCodePtr+2
.018507	c8		iny				iny
.018508	b1 26		lda ($26),y			lda 	(zBasicSP),y
.01850a	85 19		sta $19				sta 	zCodePtr+3
.01850c	c8		iny				iny
.01850d	b1 26		lda ($26),y			lda 	(zBasicSP),y 				; offset
.01850f	7a		ply				ply 								; restore Y
.018510	a8		tay				tay
.018511	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/vectors.asm

.018512					CharPrint:
.018512	4c 35 80	jmp $018035			jmp 	IFT_PrintCharacter
.018515					CharGet:
.018515	4c d9 81	jmp $0181d9			jmp 	IF_GetKey
.018518					CheckBreak:
.018518	4c d4 81	jmp $0181d4			jmp 	IF_CheckBreak
.01851b					CharGetPosition:
.01851b	ad 00 05	lda $0500			lda 	IFT_XCursor
.01851e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/errors.asm

.01851f					SyntaxError:
.01851f	20 4e 85	jsr $01854e			jsr 	ERR_Handler
>018522	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>01852a	72 72 6f 72 00
.01852f					TypeError:
.01852f	20 4e 85	jsr $01854e			jsr 	ERR_Handler
>018532	57 72 6f 6e 67 20 74 79				.text 	"Wrong type",0
>01853a	70 65 00
.01853d					BadParamError:
.01853d	20 4e 85	jsr $01854e			jsr 	ERR_Handler
>018540	42 61 64 20 50 61 72 61				.text 	"Bad Parameter",0
>018548	6d 65 74 65 72 00
.01854e					ERR_Handler:
.01854e	a0 00		ldy #$00			ldy 	#0
.018550	c8		iny				iny
.018551	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018553	85 80		sta $80				sta 	XS_Mantissa
.018555	c8		iny				iny
.018556	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018558	85 81		sta $81				sta 	XS_Mantissa+1
.01855a	fa		plx				plx 								; address in XY
.01855b	7a		ply				ply
.01855c	e8		inx				inx 								; bump, because of RTS/JSR address -1
.01855d	d0 01		bne $018560			bne 	_EHNoSkip
.01855f	c8		iny				iny
.018560					_EHNoSkip:
.018560	20 7f 85	jsr $01857f			jsr 	PrintROMMessage 			; print message from ROM.
.018563	a5 80		lda $80				lda 	XS_Mantissa					; line number = 0
.018565	05 81		ora $81				ora 	XS_Mantissa+1
.018567	f0 0c		beq $018575			beq 	_EHNoLine
.018569	a2 7a		ldx #$7a			ldx 	#_EHAt & $FF 				; print " at "
.01856b	a0 85		ldy #$85			ldy 	#(_EHAt >> 8) & $FF
.01856d	20 7f 85	jsr $01857f			jsr 	PrintROMMessage
.018570	a2 00		ldx #$00			ldx 	#0 							; Print line number
.018572	20 94 85	jsr $018594			jsr 	Print16BitInteger
.018575					_EHNoLine:
.018575	80 fe		bra $018575			bra 	_EHNoLine
.018577	4c 07 88	jmp $018807			jmp 	WarmStart
>01857a	20 61 74 20 00			_EHAt:	.text 	" at ",0
.01857f					PrintROMMessage:
.01857f	86 1a		stx $1a				stx 	zLTemp1 					; save addres
.018581	84 1b		sty $1b				sty 	zLTemp1+1
.018583	4b		phk				phk
.018584	68		pla				pla
.018585	85 1c		sta $1c				sta 	ZLTemp1+2
.018587	a0 00		ldy #$00			ldy 	#0
.018589					_PRMLoop:
.018589	b7 1a		lda [$1a],y			lda 	[zLTemp1],y
.01858b	f0 06		beq $018593			beq		_PRMExit
.01858d	c8		iny				iny
.01858e	20 12 85	jsr $018512			jsr 	CharPrint
.018591	80 f6		bra $018589			bra 	_PRMLoop
.018593					_PRMExit:
.018593	60		rts				rts
.018594					Print16BitInteger:
.018594	a9 00		lda #$00			lda 	#0 							; make 32 bit
.018596	85 82		sta $82				sta 	XS_Mantissa+2
.018598	85 83		sta $83				sta 	XS_Mantissa+3
.01859a					Print32BitInteger:
.01859a	a9 00		lda #$00			lda 	#0
.01859c	8d 14 03	sta $0314			sta 	NumBufX 					; reset the conversion pointer
.01859f	aa		tax				tax 								; convert bottom level.
.0185a0	20 50 9d	jsr $019d50			jsr 	INTToString 				; make string
.0185a3	a2 00		ldx #$00			ldx 	#0 							; print buffer
.0185a5	bd 15 03	lda $0315,x	_P1Loop:lda 	Num_Buffer,x
.0185a8	f0 06		beq $0185b0			beq 	_P1Exit
.0185aa	20 12 85	jsr $018512			jsr 	CharPrint
.0185ad	e8		inx				inx
.0185ae	80 f5		bra $0185a5			bra 	_P1Loop
.0185b0	8a		txa		_P1Exit:txa 								; return chars printed.
.0185b1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm


;******  Processing file: modules/basic/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b6					lastUnaryFunction = $b6
.0185b2					VectorTable:
>0185b2	a8 91					.word BinaryOp_And         & $FFFF ; $80 and
>0185b4	c4 91					.word BinaryOp_Or          & $FFFF ; $81 or
>0185b6	e0 91					.word BinaryOp_Xor         & $FFFF ; $82 xor
>0185b8	e0 91					.word BinaryOp_Eor         & $FFFF ; $83 eor
>0185ba	17 92					.word Binary_Equal         & $FFFF ; $84 =
>0185bc	31 92					.word Binary_NotEqual      & $FFFF ; $85 <>
>0185be	3a 92					.word Binary_Less          & $FFFF ; $86 <
>0185c0	43 92					.word Binary_LessEqual     & $FFFF ; $87 <=
>0185c2	55 92					.word Binary_Greater       & $FFFF ; $88 >
>0185c4	4c 92					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>0185c6	da 92					.word BinaryOp_Add         & $FFFF ; $8a +
>0185c8	f6 92					.word BinaryOp_Subtract    & $FFFF ; $8b -
>0185ca	07 93					.word BinaryOp_Multiply    & $FFFF ; $8c *
>0185cc	18 93					.word BinaryOp_Divide      & $FFFF ; $8d /
>0185ce	70 86					.word NotImplemented       & $FFFF ; $8e ^
>0185d0	38 8b					.word Command_IF           & $FFFF ; $8f if
>0185d2	a4 8f					.word Command_WHILE        & $FFFF ; $90 while
>0185d4	cc 8f					.word Command_REPEAT       & $FFFF ; $91 repeat
>0185d6	69 89					.word Command_FOR          & $FFFF ; $92 for
>0185d8	70 86					.word NotImplemented       & $FFFF ; $93 then
>0185da	95 8b					.word Command_ENDIF        & $FFFF ; $94 endif
>0185dc	c1 8f					.word Command_WEND         & $FFFF ; $95 wend
>0185de	d5 8f					.word Command_UNTIL        & $FFFF ; $96 until
>0185e0	e6 89					.word Command_NEXT         & $FFFF ; $97 next
>0185e2	70 86					.word NotImplemented       & $FFFF ; $98 not
>0185e4	70 86					.word NotImplemented       & $FFFF ; $99 fn(
>0185e6	1d 94					.word Unary_Abs            & $FFFF ; $9a abs(
>0185e8	6a 95					.word Unary_Asc            & $FFFF ; $9b asc(
>0185ea	7c a4					.word Unary_Int            & $FFFF ; $9c int(
>0185ec	37 94					.word Unary_Peek           & $FFFF ; $9d peek(
>0185ee	fd a3					.word Unary_Rnd            & $FFFF ; $9e rnd(
>0185f0	aa 94					.word Unary_Usr            & $FFFF ; $9f usr(
>0185f2	a9 95					.word Unary_Left           & $FFFF ; $a0 left$(
>0185f4	be 95					.word Unary_Right          & $FFFF ; $a1 right$(
>0185f6	90 95					.word Unary_Mid            & $FFFF ; $a2 mid$(
>0185f8	07 97					.word Unary_Spc            & $FFFF ; $a3 spc(
>0185fa	38 95					.word Unary_Str            & $FFFF ; $a4 str$(
>0185fc	cc 94					.word Unary_Val            & $FFFF ; $a5 val(
>0185fe	81 95					.word Unary_Len            & $FFFF ; $a6 len(
>018600	36 96					.word Unary_Hex            & $FFFF ; $a7 hex$(
>018602	70 86					.word NotImplemented       & $FFFF ; $a8 sin(
>018604	70 86					.word NotImplemented       & $FFFF ; $a9 cos(
>018606	70 86					.word NotImplemented       & $FFFF ; $aa tan(
>018608	70 86					.word NotImplemented       & $FFFF ; $ab atn(
>01860a	70 86					.word NotImplemented       & $FFFF ; $ac exp(
>01860c	70 86					.word NotImplemented       & $FFFF ; $ad log(
>01860e	70 86					.word NotImplemented       & $FFFF ; $ae sqr(
>018610	8c 96					.word Unary_Dec            & $FFFF ; $af dec(
>018612	3b 94					.word Unary_Deek           & $FFFF ; $b0 deek(
>018614	3f 94					.word Unary_Leek           & $FFFF ; $b1 leek(
>018616	77 94					.word Unary_Mod            & $FFFF ; $b2 mod(
>018618	d7 93					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>01861a	e9 96					.word Unary_Chr            & $FFFF ; $b4 chr$(
>01861c	6b 94					.word Unary_Pos            & $FFFF ; $b5 pos(
>01861e	2a 97					.word Unary_Tab            & $FFFF ; $b6 tab(
>018620	70 86					.word NotImplemented       & $FFFF ; $b7 $
>018622	70 86					.word NotImplemented       & $FFFF ; $b8 $(
>018624	70 86					.word NotImplemented       & $FFFF ; $b9 #
>018626	70 86					.word NotImplemented       & $FFFF ; $ba #(
>018628	70 86					.word NotImplemented       & $FFFF ; $bb %
>01862a	70 86					.word NotImplemented       & $FFFF ; $bc %(
>01862c	70 86					.word NotImplemented       & $FFFF ; $bd (
>01862e	70 86					.word NotImplemented       & $FFFF ; $be )
>018630	70 86					.word NotImplemented       & $FFFF ; $bf ,
>018632	68 89					.word Command_COLON        & $FFFF ; $c0 :
>018634	70 86					.word NotImplemented       & $FFFF ; $c1 ;
>018636	70 86					.word NotImplemented       & $FFFF ; $c2 def
>018638	85 8f					.word Command_CLR          & $FFFF ; $c3 clr
>01863a	9c 8f					.word Command_STOP         & $FFFF ; $c4 stop
>01863c	70 86					.word NotImplemented       & $FFFF ; $c5 data
>01863e	99 8a					.word Command_READ         & $FFFF ; $c6 read
>018640	14 88					.word Command_DIM          & $FFFF ; $c7 dim
>018642	70 86					.word NotImplemented       & $FFFF ; $c8 to
>018644	70 86					.word NotImplemented       & $FFFF ; $c9 step
>018646	b1 8e					.word Command_GOSUB        & $FFFF ; $ca gosub
>018648	c1 8e					.word Command_RETURN       & $FFFF ; $cb return
>01864a	a9 8e					.word Command_GOTO         & $FFFF ; $cc goto
>01864c	34 8b					.word Command_END          & $FFFF ; $cd end
>01864e	70 86					.word NotImplemented       & $FFFF ; $ce input
>018650	f9 8a					.word Command_LET          & $FFFF ; $cf let
>018652	9b 8b					.word Command_LIST         & $FFFF ; $d0 list
>018654	52 8e					.word Command_NEW          & $FFFF ; $d1 new
>018656	6e 8e					.word Command_OLD          & $FFFF ; $d2 old
>018658	ca 8e					.word Command_ON           & $FFFF ; $d3 on
>01865a	bf 8a					.word Command_RESTORE      & $FFFF ; $d4 restore
>01865c	21 8e					.word Command_POKE         & $FFFF ; $d5 poke
>01865e	8f 8d					.word Command_PRINT        & $FFFF ; $d6 print
>018660	da 88					.word Command_RUN          & $FFFF ; $d7 run
>018662	9c 88					.word Command_WAIT         & $FFFF ; $d8 wait
>018664	1a 8b					.word Command_SYS          & $FFFF ; $d9 sys
>018666	25 8e					.word Command_DOKE         & $FFFF ; $da doke
>018668	29 8e					.word Command_LOKE         & $FFFF ; $db loke
>01866a	09 8e					.word Command_ASSERT       & $FFFF ; $dc assert
>01866c	70 86					.word NotImplemented       & $FFFF ; $dd get
>01866e	8f 8b					.word Command_ELSE         & $FFFF ; $de else
.018670					NotImplemented:
.018670	20 4e 85	jsr $01854e			jsr ERR_Handler
>018673	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>01867b	65 6d 65 6e 74 65 64 00
.018683					BinaryPrecedence:
>018683	01					.byte 1    ; $80 and
>018684	01					.byte 1    ; $81 or
>018685	01					.byte 1    ; $82 xor
>018686	01					.byte 1    ; $83 eor
>018687	02					.byte 2    ; $84 =
>018688	02					.byte 2    ; $85 <>
>018689	02					.byte 2    ; $86 <
>01868a	02					.byte 2    ; $87 <=
>01868b	02					.byte 2    ; $88 >
>01868c	02					.byte 2    ; $89 >=
>01868d	03					.byte 3    ; $8a +
>01868e	03					.byte 3    ; $8b -
>01868f	04					.byte 4    ; $8c *
>018690	04					.byte 4    ; $8d /
>018691	05					.byte 5    ; $8e ^
.018692					KeywordText:
>018692	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>018695	4f d2					.byte $4f,$d2                          ; $81 or
>018697	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>01869a	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>01869d	bd					.byte $bd                              ; $84 =
>01869e	3c be					.byte $3c,$be                          ; $85 <>
>0186a0	bc					.byte $bc                              ; $86 <
>0186a1	3c bd					.byte $3c,$bd                          ; $87 <=
>0186a3	be					.byte $be                              ; $88 >
>0186a4	3e bd					.byte $3e,$bd                          ; $89 >=
>0186a6	ab					.byte $ab                              ; $8a +
>0186a7	ad					.byte $ad                              ; $8b -
>0186a8	aa					.byte $aa                              ; $8c *
>0186a9	af					.byte $af                              ; $8d /
>0186aa	de					.byte $de                              ; $8e ^
>0186ab	49 c6					.byte $49,$c6                          ; $8f if
>0186ad	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>0186b2	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>0186b8	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>0186bb	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>0186bf	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>0186c4	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>0186c8	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>0186cd	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>0186d1	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>0186d4	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>0186d7	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>0186db	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>0186df	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>0186e3	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>0186e8	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>0186ec	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>0186f0	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>0186f6	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>0186fd	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>018702	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>018706	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>01870b	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>01870f	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>018713	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>018718	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>01871c	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>018720	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>018724	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>018728	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>01872c	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>018730	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>018734	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>018738	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>01873d	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>018742	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>018746	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>01874a	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>01874f	50 4f 53 a8				.byte $50,$4f,$53,$a8                  ; $b5 pos(
>018753	54 41 42 a8				.byte $54,$41,$42,$a8                  ; $b6 tab(
>018757	a4					.byte $a4                              ; $b7 $
>018758	24 a8					.byte $24,$a8                          ; $b8 $(
>01875a	a3					.byte $a3                              ; $b9 #
>01875b	23 a8					.byte $23,$a8                          ; $ba #(
>01875d	a5					.byte $a5                              ; $bb %
>01875e	25 a8					.byte $25,$a8                          ; $bc %(
>018760	a8					.byte $a8                              ; $bd (
>018761	a9					.byte $a9                              ; $be )
>018762	ac					.byte $ac                              ; $bf ,
>018763	ba					.byte $ba                              ; $c0 :
>018764	bb					.byte $bb                              ; $c1 ;
>018765	44 45 c6				.byte $44,$45,$c6                      ; $c2 def
>018768	43 4c d2				.byte $43,$4c,$d2                      ; $c3 clr
>01876b	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $c4 stop
>01876f	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c5 data
>018773	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c6 read
>018777	44 49 cd				.byte $44,$49,$cd                      ; $c7 dim
>01877a	54 cf					.byte $54,$cf                          ; $c8 to
>01877c	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c9 step
>018780	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $ca gosub
>018785	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $cb return
>01878b	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $cc goto
>01878f	45 4e c4				.byte $45,$4e,$c4                      ; $cd end
>018792	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $ce input
>018797	4c 45 d4				.byte $4c,$45,$d4                      ; $cf let
>01879a	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $d0 list
>01879e	4e 45 d7				.byte $4e,$45,$d7                      ; $d1 new
>0187a1	4f 4c c4				.byte $4f,$4c,$c4                      ; $d2 old
>0187a4	4f ce					.byte $4f,$ce                          ; $d3 on
>0187a6	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d4 restore
>0187ad	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d5 poke
>0187b1	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d6 print
>0187b6	52 55 ce				.byte $52,$55,$ce                      ; $d7 run
>0187b9	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d8 wait
>0187bd	53 59 d3				.byte $53,$59,$d3                      ; $d9 sys
>0187c0	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $da doke
>0187c4	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $db loke
>0187c8	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $dc assert
>0187ce	47 45 d4				.byte $47,$45,$d4                      ; $dd get
>0187d1	45 4c 53 c5				.byte $45,$4c,$53,$c5                  ; $de else
>0187d5	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_pos = $b5
=$b6					token_tab = $b6
=$b7					token_dollar = $b7
=$b8					token_dollarlparen = $b8
=$b9					token_hash = $b9
=$ba					token_hashlparen = $ba
=$bb					token_percent = $bb
=$bc					token_percentlparen = $bc
=$bd					token_lparen = $bd
=$be					token_rparen = $be
=$bf					token_comma = $bf
=$c0					token_colon = $c0
=$c1					token_semicolon = $c1
=$c2					token_def = $c2
=$c3					token_clr = $c3
=$c4					token_stop = $c4
=$c5					token_data = $c5
=$c6					token_read = $c6
=$c7					token_dim = $c7
=$c8					token_to = $c8
=$c9					token_step = $c9
=$ca					token_gosub = $ca
=$cb					token_return = $cb
=$cc					token_goto = $cc
=$cd					token_end = $cd
=$ce					token_input = $ce
=$cf					token_let = $cf
=$d0					token_list = $d0
=$d1					token_new = $d1
=$d2					token_old = $d2
=$d3					token_on = $d3
=$d4					token_restore = $d4
=$d5					token_poke = $d5
=$d6					token_print = $d6
=$d7					token_run = $d7
=$d8					token_wait = $d8
=$d9					token_sys = $d9
=$da					token_doke = $da
=$db					token_loke = $db
=$dc					token_assert = $dc
=$dd					token_get = $dd
=$de					token_else = $de

;******  Return to file: modules/basic/core.asm

.0187d6					BASIC_Start:
.0187d6	20 9b 81	jsr $01819b			jsr 	IF_Reset 					; set up and clear screen.
.0187d9	20 00 80	jsr $018000			jsr 	IFT_ClearScreen
.0187dc	a9 5c		lda #$5c			lda 	#$5C 						; JMP Long opcode
.0187de	8d 10 03	sta $0310			sta 	LocalVector
.0187e1	8d 0c 03	sta $030c			sta 	UserVector
.0187e4	a9 ba		lda #$ba			lda 	#USRDefault & $FF 			; reset USR vector
.0187e6	8d 0d 03	sta $030d			sta 	UserVector+1
.0187e9	a9 94		lda #$94			lda 	#(USRDefault >> 8) & $FF
.0187eb	8d 0e 03	sta $030e			sta 	UserVector+2
.0187ee	a9 01		lda #$01			lda 	#(USRDefault >> 16) & $FF
.0187f0	8d 0f 03	sta $030f			sta 	UserVector+3
.0187f3	20 71 97	jsr $019771			jsr 	UpdateProgramEnd 			; update the program end.
.0187f6	20 85 8f	jsr $018f85			jsr 	ResetRunStatus 				; clear everything (CLR command)
.0187f9	c2 30		rep #$30			rep 	#$30
.0187fb	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.0187fe	1b		tcs				tcs
.0187ff	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.018802	e2 30		sep #$30			sep 	#$30
.018804	4c da 88	jmp $0188da			jmp 	COMMAND_Run
.018807					WarmStart:
.018807	c2 30		rep #$30			rep 	#$30
.018809	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.01880c	1b		tcs				tcs
.01880d	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.018810	e2 30		sep #$30			sep 	#$30
.018812	80 f3		bra $018807			bra 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/dim.asm

.018814					Command_DIM:
.018814	98		tya				tya
.018815	48		pha				pha 								; push on stack.
.018816	20 d9 98	jsr $0198d9			jsr 	VariableExtract 			; get the identifier
.018819	ad 95 03	lda $0395			lda 	Var_Type 					; check it is an array
.01881c	29 01		and #$01			and 	#1
.01881e	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.018820	d0 6c		bne $01888e			bne 	_CDIError
.018822	a9 00		lda #$00			lda 	#0 							; reset the DIM index. The dimensions are
.018824	8d b9 03	sta $03b9			sta 	UsrArrayIdx 				; built up here and copied in case we autodim
.018827					_CDIGetDimension:
.018827	ad b9 03	lda $03b9			lda 	UsrArrayIdx 				; done too many ?
.01882a	c9 06		cmp #$06			cmp 	#ArrayMaxDim*2
.01882c	f0 60		beq $01888e			beq 	_CDIError
.01882e	20 89 91	jsr $019189			jsr 	EvaluateInteger 			; evaluate an index size
.018831	a5 81		lda $81				lda 	XS_Mantissa+1 				; check in range 0-7FFF
.018833	29 80		and #$80			and 	#$80
.018835	05 82		ora $82				ora 	XS_Mantissa+2
.018837	05 83		ora $83				ora 	XS_Mantissa+3
.018839	d0 53		bne $01888e			bne 	_CDIError
.01883b	ae b9 03	ldx $03b9			ldx 	UsrArrayIdx 				; copy into the array table.
.01883e	18		clc				clc 								; add 1 - max index => size.
.01883f	a5 80		lda $80				lda 	XS_Mantissa+0
.018841	69 01		adc #$01			adc 	#1
.018843	9d b1 03	sta $03b1,x			sta 	UsrArrayDef+0,x
.018846	a5 81		lda $81				lda 	XS_Mantissa+1
.018848	69 00		adc #$00			adc 	#0
.01884a	9d b2 03	sta $03b2,x			sta 	UsrArrayDef+1,x
.01884d	30 3f		bmi $01888e			bmi 	_CDIError 					; could be dim a(32767)
.01884f	e8		inx				inx 								; bump index.
.018850	e8		inx				inx
.018851	8e b9 03	stx $03b9			stx 	UsrArrayIdx
.018854	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018856	c8		iny				iny
.018857	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another dimension
.018859	f0 cc		beq $018827			beq 	_CDIGetDimension
.01885b	88		dey				dey
.01885c	20 cd 97	jsr $0197cd			jsr 	CheckNextRParen 			; closing ) present ?
.01885f	ae b9 03	ldx $03b9			ldx 	UsrArrayIdx 				; copy USR array to default
.018862	a9 ff		lda #$ff			lda 	#$FF 						; put end marker in ArrayDef
.018864	9d aa 03	sta $03aa,x			sta 	ArrayDef+1,x
.018867					_CDICopy:
.018867	bd b1 03	lda $03b1,x			lda 	UsrArrayDef,x
.01886a	9d a9 03	sta $03a9,x			sta 	ArrayDef,x
.01886d	ca		dex				dex
.01886e	10 f7		bpl $018867			bpl 	_CDICopy
.018870	68		pla				pla									; position of array identifier
.018871	85 10		sta $10				sta 	zTemp1
.018873	98		tya				tya
.018874	48		pha				pha
.018875	a5 10		lda $10				lda 	zTemp1 						; point to identifier
.018877	a8		tay				tay
.018878	20 d9 98	jsr $0198d9			jsr 	VariableExtract 			; get the identifier
.01887b	20 72 9b	jsr $019b72			jsr 	VariableLocate 				; check if it exists already.
.01887e	b0 0e		bcs $01888e			bcs 	_CDIError
.018880	20 65 99	jsr $019965			jsr 	VariableCreate 				; create it using the current ArrayDef
.018883	68		pla				pla 								; restore code position
.018884	a8		tay				tay
.018885	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018887	c8		iny				iny
.018888	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another DIM
.01888a	f0 88		beq $018814			beq 	Command_DIM
.01888c	88		dey				dey
.01888d	60		rts				rts
.01888e					_CDIError:
.01888e	20 4e 85	jsr $01854e			jsr ERR_Handler
>018891	42 61 64 20 44 49 4d 00			.text "Bad DIM",0
.018899					_CDISyntax:
.018899	4c 1f 85	jmp $01851f			jmp 	SyntaxError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/wait.asm

.01889c					Command_WAIT:
.01889c	20 89 91	jsr $019189			jsr		EvaluateInteger 			; address
.01889f	a2 06		ldx #$06			ldx 	#XS_Size 					; and mask.
.0188a1	20 d5 97	jsr $0197d5			jsr 	CheckNextComma
.0188a4	20 8b 91	jsr $01918b			jsr 	EvaluateIntegerX
.0188a7	a9 00		lda #$00			lda 	#0							; set default xor.
.0188a9	85 8c		sta $8c				sta 	XS_Mantissa+XS_Size*2
.0188ab	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0188ad	c9 bf		cmp #$bf			cmp 	#token_Comma 				; no use the default
.0188af	d0 06		bne $0188b7			bne 	_CWAXorDefault
.0188b1	c8		iny				iny
.0188b2	a2 0c		ldx #$0c			ldx 	#XS_Size*2
.0188b4	20 8b 91	jsr $01918b			jsr 	EvaluateIntegerX
.0188b7					_CWAXorDefault:
.0188b7	a5 80		lda $80				lda 	XS_Mantissa 				; copy 24 bits of mantissa to ZLTemp1
.0188b9	85 1a		sta $1a				sta 	zLTemp1
.0188bb	a5 81		lda $81				lda 	XS_Mantissa+1
.0188bd	85 1b		sta $1b				sta 	zLTemp1+1
.0188bf	a5 82		lda $82				lda 	XS_Mantissa+2
.0188c1	85 1c		sta $1c				sta 	zLTemp1+2
.0188c3					_CWAWaitLoop:
.0188c3	20 18 85	jsr $018518			jsr 	CheckBreak 					; exit on break.
.0188c6	c9 00		cmp #$00			cmp 	#0
.0188c8	d0 0f		bne $0188d9			bne 	_CWAWaitExit
.0188ca	a9 01		lda #$01			lda 	#1							; read 1 byte to mantissa/0
.0188cc	a2 00		ldx #$00			ldx 	#0
.0188ce	5a		phy				phy 								; this is the same routine as PEEK.
.0188cf	20 4f 97	jsr $01974f			jsr 	MemRead
.0188d2	7a		ply				ply
.0188d3	25 86		and $86				and 	XS_Mantissa+XS_Size 		; process it
.0188d5	45 8c		eor $8c				eor 	XS_Mantissa+XS_Size*2
.0188d7	f0 ea		beq $0188c3			beq 	_CWAWaitLoop
.0188d9					_CWAWaitExit:
.0188d9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/run.asm

.0188da					Command_RUN:
.0188da	20 85 8f	jsr $018f85			jsr 	ResetRunStatus 				; clear, reset stacks etc.
.0188dd	a9 00		lda #$00			lda 	#BasicProgram & $FF
.0188df	85 16		sta $16				sta 	zCodePtr+0
.0188e1	a9 10		lda #$10			lda 	#BasicProgram >> 8
.0188e3	85 17		sta $17				sta 	zCodePtr+1
.0188e5	a9 00		lda #$00			lda 	#0
.0188e7	85 18		sta $18				sta 	zCodePtr+2
.0188e9	85 19		sta $19				sta 	zCodePtr+3
.0188eb	a0 03		ldy #$03			ldy 	#3
.0188ed					RUN_NewLine:
.0188ed	a0 00		ldy #$00			ldy 	#0
.0188ef	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0188f1	c8		iny				iny
.0188f2	c8		iny				iny
.0188f3	c8		iny				iny
.0188f4	c9 00		cmp #$00			cmp 	#0 							; if the offset is zero then END.
.0188f6	d0 16		bne $01890e			bne 	RUN_NextCommand
.0188f8	4c 34 8b	jmp $018b34			jmp 	Command_END 				; go do the command code.
.0188fb					RUN_Skip:
.0188fb	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.0188fd	c8		iny				iny 								; skip
.0188fe	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018900	90 0c		bcc $01890e			bcc 	_SEDone 					; so just skip over it.
.018902	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018904	90 07		bcc $01890d			bcc 	_SEDouble
.018906	98		tya				tya 								; this is Y + 1
.018907	18		clc				clc
.018908	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.01890a	a8		tay				tay 								; back in Y.
.01890b	88		dey				dey 								; fix up, one for the +1, one for the iny
.01890c	88		dey				dey
.01890d					_SEDouble:
.01890d	c8		iny				iny
.01890e					_SEDone:
.01890e					RUN_NextCommand:
.01890e	ad a8 03	lda $03a8			lda 	BreakCount 					; break counter
.018911	69 10		adc #$10			adc 	#16 						; one time in 16
.018913	8d a8 03	sta $03a8			sta 	BreakCount
.018916	90 0a		bcc $018922			bcc 	RUN_NoCheckBreak
.018918	20 18 85	jsr $018518			jsr 	CheckBreak 					; check for break
.01891b	c9 00		cmp #$00			cmp 	#0
.01891d	f0 03		beq $018922			beq 	RUN_NoCheckBreak
.01891f	4c 9c 8f	jmp $018f9c			jmp 	Command_STOP 				; stop on BREAK.
.018922					RUN_NoCheckBreak:
.018922	a9 00		lda #$00			lda 	#0 							; this resets temporary string allocation.
.018924	85 21		sta $21				sta 	zTempStr+1 					; (initialised when first called)
.018926	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018928	c9 c0		cmp #$c0			cmp 	#token_Colon 				; skip over colons
.01892a	f0 cf		beq $0188fb			beq 	RUN_Skip
.01892c	c9 00		cmp #$00			cmp 	#0 							; if non-zero execute whatever
.01892e	d0 0f		bne $01893f			bne 	RUN_Execute
.018930					RUN_NextLine:
.018930	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018932	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.018934	18		clc				clc
.018935	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018937	85 16		sta $16				sta 	zCodePtr
.018939	90 02		bcc $01893d			bcc 	_SNLNoCarry
.01893b	e6 17		inc $17				inc 	zCodePtr+1
.01893d					_SNLNoCarry:
.01893d	80 ae		bra $0188ed			bra 	RUN_NewLine 				; go do the new line code
.01893f					RUN_Execute:
.01893f	c9 f8		cmp #$f8			cmp 	#$F8 						; handle shifts, REM etc.
.018941	b0 1e		bcs $018961			bcs 	RUN_Extension
.018943	c8		iny				iny
.018944	0a		asl a				asl 	a 							; double the character read.
.018945	90 14		bcc $01895b			bcc 	RUN_Default 				; if carry clear was $00-$7F, so try LET.
.018947	aa		tax				tax 								; ready to look up.
.018948	bf b2 85 01	lda $0185b2,x			lda 	VectorTable,x 				; copy address into LocalVector
.01894c	8d 11 03	sta $0311			sta 	LocalVector+1
.01894f	bf b3 85 01	lda $0185b3,x			lda 	VectorTable+1,x
.018953	8d 12 03	sta $0312			sta 	LocalVector+2
.018956	20 d6 90	jsr $0190d6			jsr 	EVCallLocalVector 			; execute the appropriate code.
.018959	80 b3		bra $01890e			bra 	RUN_NextCommand 			; do the next command.
.01895b					RUN_Default:
.01895b	88		dey				dey
.01895c	20 f9 8a	jsr $018af9			jsr 	Command_LET 				; and try LET.
.01895f	80 ad		bra $01890e			bra 	RUN_NextCommand
.018961					RUN_Extension:
.018961	c9 ff		cmp #$ff			cmp 	#$FF 						; if $FF (REM)
.018963	f0 96		beq $0188fb			beq 	RUN_Skip 					; skip over it.
.018965	4c 1f 85	jmp $01851f			jmp 	SyntaxError
.018968					Command_COLON:
.018968	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/for.asm

.018969					Command_FOR:
.018969	20 f9 8a	jsr $018af9			jsr 	Command_LET 				; do the A = 99 bit
.01896c	a5 24		lda $24				lda 	zVarType 					; obviously has to be integer/real.
.01896e	c9 b7		cmp #$b7			cmp 	#token_Dollar
.018970	f0 71		beq $0189e3			beq 	_CFOError
.018972	48		pha				pha 								; save the variable type.
.018973	5a		phy				phy 								; save type/variable address.
.018974	a0 01		ldy #$01			ldy 	#1							; type at + 1
.018976	91 26		sta ($26),y			sta 	(zBasicSP),y
.018978	c8		iny				iny
.018979	a5 22		lda $22				lda 	zVarDataPtr 				; data low at +2
.01897b	91 26		sta ($26),y			sta 	(zBasicSP),y
.01897d	c8		iny				iny
.01897e	a5 23		lda $23				lda 	zVarDataPtr+1 				; data high at +3
.018980	91 26		sta ($26),y			sta 	(zBasicSP),y
.018982	7a		ply				ply
.018983	a9 53		lda #$53			lda 	#(SMark_For << 4) + 3
.018985	20 92 84	jsr $018492			jsr 	StackPushFrame 				; push on the stack with FOR marker.
.018988	a9 c8		lda #$c8			lda 	#token_TO
.01898a	20 b6 97	jsr $0197b6			jsr 	CheckNextToken
.01898d	a2 00		ldx #$00			ldx 	#0 							; put in Mantissa, bottom
.01898f	20 f3 8f	jsr $018ff3			jsr 	EvaluateExpression
.018992	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018994	a2 06		ldx #$06			ldx 	#XS_Size 					; X to second level
.018996	c9 c9		cmp #$c9			cmp 	#token_STEP
.018998	d0 06		bne $0189a0			bne 	_CFOStep1
.01899a	c8		iny				iny
.01899b	20 f5 8f	jsr $018ff5			jsr 	EvaluateExpressionX 		; get STEP value.
.01899e	80 0e		bra $0189ae			bra 	_CFOHaveStep
.0189a0					_CFOStep1:
.0189a0	a9 00		lda #$00			lda 	#0							; set step to integer 1.
.0189a2	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0189a4	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0189a6	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0189a8	a9 01		lda #$01			lda 	#1
.0189aa	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0189ac	95 85		sta $85,x			sta 	XS_Type,x
.0189ae					_CFOHaveStep:
.0189ae	68		pla				pla 								; restore variable type
.0189af	a2 00		ldx #$00			ldx 	#0
.0189b1	c9 bb		cmp #$bb			cmp 	#token_Percent 				; do conversion to type
.0189b3	f0 0a		beq $0189bf			beq 	_CFOInteger
.0189b5	20 7d a1	jsr $01a17d			jsr 	FPUToFloat
.0189b8	a2 06		ldx #$06			ldx 	#6
.0189ba	20 7d a1	jsr $01a17d			jsr 	FPUToFloat
.0189bd	80 08		bra $0189c7			bra 	_CFOEndConv
.0189bf					_CFOInteger:
.0189bf	20 c9 a1	jsr $01a1c9			jsr 	FPUToInteger
.0189c2	a2 06		ldx #$06			ldx 	#6
.0189c4	20 c9 a1	jsr $01a1c9			jsr 	FPUToInteger
.0189c7					_CFOEndConv:
.0189c7	20 d9 84	jsr $0184d9			jsr 	StackSavePosition 			; save the loop position at 1-5
.0189ca	a9 55		lda #$55			lda 	#(SMark_For << 4)+SourcePosSize
.0189cc	20 92 84	jsr $018492			jsr 	StackPushFrame 				; push the loop address frame.
.0189cf	5a		phy				phy
.0189d0	a0 00		ldy #$00			ldy 	#0
.0189d2					_CFOCopy:
.0189d2	b9 80 00	lda $0080,y			lda 	XS_Mantissa+0,y
.0189d5	c8		iny				iny
.0189d6	91 26		sta ($26),y			sta 	(zBasicSP),y
.0189d8	c0 0c		cpy #$0c			cpy 	#XS_Size*2
.0189da	d0 f6		bne $0189d2			bne 	_CFOCopy
.0189dc	7a		ply				ply
.0189dd	a9 5c		lda #$5c			lda 	#(SMark_For << 4)+(XS_Size*2)
.0189df	20 92 84	jsr $018492			jsr 	StackPushFrame
.0189e2	60		rts				rts
.0189e3					_CFOError:
.0189e3	4c 2f 85	jmp $01852f			jmp 	TypeError 					; wrong type.
.0189e6					Command_NEXT:
.0189e6	a9 00		lda #$00			lda 	#0 							; set variable data pointer+1 to zero
.0189e8	85 23		sta $23				sta 	zVarDataPtr+1 				; this means we don't check
.0189ea	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0189ec	c9 00		cmp #$00			cmp 	#0 							; EOL
.0189ee	f0 07		beq $0189f7			beq 	_CNextNoVariable
.0189f0	c9 40		cmp #$40			cmp 	#$40
.0189f2	b0 03		bcs $0189f7			bcs 	_CNextNoVariable
.0189f4	20 6e 98	jsr $01986e			jsr 	VariableFind
.0189f7					_CNextNoVariable:
.0189f7	a5 26		lda $26				lda 	zBasicSP 					; save on stack
.0189f9	48		pha				pha
.0189fa	a5 27		lda $27				lda 	zBasicSP+1
.0189fc	48		pha				pha
.0189fd	a9 50		lda #$50			lda 	#(SMark_For << 4) 			; pop loop address frame
.0189ff	20 a9 84	jsr $0184a9			jsr 	StackPopFrame
.018a02	a9 50		lda #$50			lda 	#(SMark_For << 4) 			; pop STEP/TARGET frame.
.018a04	20 a9 84	jsr $0184a9			jsr 	StackPopFrame
.018a07	a9 50		lda #$50			lda 	#(Smark_For << 4) 			; pop variable address frame.
.018a09	20 a9 84	jsr $0184a9			jsr 	StackPopFrame
.018a0c	a5 23		lda $23				lda 	zVarDataPtr+1 				; if zero, then no variable provided
.018a0e	f0 11		beq $018a21			beq 	_CNextGetTarget 			; e.g. just NEXT not NEXT x
.018a10	5a		phy				phy 								; check addresses match.
.018a11	a0 02		ldy #$02			ldy 	#2
.018a13	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a15	c5 22		cmp $22				cmp 	zVarDataPtr
.018a17	d0 69		bne $018a82			bne 	_CNextWrong
.018a19	c8		iny				iny
.018a1a	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a1c	c5 23		cmp $23				cmp 	zVarDataPtr+1
.018a1e	d0 62		bne $018a82			bne 	_CNextWrong
.018a20	7a		ply				ply
.018a21					_CNextGetTarget:
.018a21	5a		phy				phy
.018a22	a0 01		ldy #$01			ldy 	#1 							; restore variable type and data.
.018a24	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a26	85 24		sta $24				sta 	zVarType
.018a28	c8		iny				iny
.018a29	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a2b	85 22		sta $22				sta 	zVarDataPtr
.018a2d	c8		iny				iny
.018a2e	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a30	85 23		sta $23				sta 	zVarDataPtr+1
.018a32	a2 0c		ldx #$0c			ldx 	#12
.018a34	20 b6 9b	jsr $019bb6			jsr 	VariableGet 				; get that variable value into expr[2]
.018a37	a2 00		ldx #$00			ldx 	#0 							; copy stacked Target/Step into expr[0] and [1]
.018a39	a0 0b		ldy #$0b			ldy 	#11
.018a3b					_CNXCopy:
.018a3b	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a3d	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018a3f	e8		inx				inx
.018a40	c8		iny				iny
.018a41	e0 0c		cpx #$0c			cpx 	#XS_Size*2
.018a43	d0 f6		bne $018a3b			bne 	_CNXCopy
.018a45	7a		ply				ply
.018a46	a2 06		ldx #$06			ldx 	#6 							; point at expr[1] s
.018a48	20 fb 93	jsr $0193fb			jsr 	GetSignCurrent
.018a4b	8d a7 03	sta $03a7			sta 	SignNext 					; save in temporary.
.018a4e	a2 06		ldx #$06			ldx 	#6 							; add them, however
.018a50	20 da 92	jsr $0192da			jsr 	BinaryOp_Add
.018a53	20 07 9c	jsr $019c07			jsr 	VariableSet					; and write variable back.
.018a56	a2 00		ldx #$00			ldx 	#0
.018a58	20 5e 92	jsr $01925e			jsr 	CompareValues
.018a5b	09 00		ora #$00			ora 	#0
.018a5d	f0 05		beq $018a64			beq 	_CNXAgain 					; if true, then do it again.
.018a5f	cd a7 03	cmp $03a7			cmp 	SignNext 					; if sign different, then loop has finished.
.018a62	d0 0f		bne $018a73			bne 	_CNXLoopDone
.018a64					_CNXAgain:
.018a64	a9 53		lda #$53			lda 	#(SMark_For << 4) + 3		; re-stack variable address
.018a66	20 92 84	jsr $018492			jsr 	StackPushFrame
.018a69	20 f6 84	jsr $0184f6			jsr 	StackRestorePosition 		; get restore position back, e.g. loop round.
.018a6c	68		pla				pla
.018a6d	85 27		sta $27				sta 	zBasicSP+1
.018a6f	68		pla				pla
.018a70	85 26		sta $26				sta 	zBasicSP
.018a72					_CNXExit:
.018a72	60		rts				rts
.018a73					_CNXLoopDone:
.018a73	68		pla				pla
.018a74	68		pla				pla
.018a75	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018a77	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma ?
.018a79	d0 f7		bne $018a72			bne 	_CNXExit
.018a7b	c8		iny				iny
.018a7c	20 6e 98	jsr $01986e			jsr 	VariableFind 				; identify the variable
.018a7f	4c f7 89	jmp $0189f7			jmp 	_CNextNoVariable 			; go back with variable pre-found
.018a82					_CNextWrong:
.018a82	20 4e 85	jsr $01854e			jsr ERR_Handler
>018a85	57 72 6f 6e 67 20 4e 65			.text "Wrong Next Variable",0
>018a8d	78 74 20 56 61 72 69 61 62 6c 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/read.asm

.018a99					Command_READ:
.018a99	20 6e 98	jsr $01986e			jsr 	VariableFind 				; get variable/value into zVarDataPtr,zVarType
.018a9c	a5 22		lda $22				lda 	zVarDataPtr 				; save variable info on stack
.018a9e	48		pha				pha
.018a9f	a5 23		lda $23				lda 	zVarDataPtr+1
.018aa1	48		pha				pha
.018aa2	a5 24		lda $24				lda 	zVarType
.018aa4	48		pha				pha
.018aa5	20 e8 8a	jsr $018ae8			jsr 	READGetDataItem 			; get the next data item
.018aa8	68		pla				pla 								; restore target variable information.
.018aa9	85 24		sta $24				sta 	zVarType
.018aab	68		pla				pla
.018aac	85 23		sta $23				sta 	zVarDataPtr+1
.018aae	68		pla				pla
.018aaf	85 22		sta $22				sta 	zVarDataPtr
.018ab1	a2 00		ldx #$00			ldx 	#0
.018ab3	20 07 9c	jsr $019c07			jsr 	VariableSet 				; set the value out.
.018ab6	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018ab8	c8		iny				iny
.018ab9	c9 bf		cmp #$bf			cmp 	#token_Comma
.018abb	f0 dc		beq $018a99			beq 	Command_READ 				; found, do another READ
.018abd	88		dey				dey
.018abe	60		rts				rts
.018abf					Command_RESTORE:
.018abf	48		pha				pha
.018ac0	a9 00		lda #$00			lda 	#0 							; this being zero means 'initialise next read'
.018ac2	8d bd 03	sta $03bd			sta 	DataLPtr+0
.018ac5	8d be 03	sta $03be			sta 	DataLPtr+1
.018ac8	68		pla				pla
.018ac9	60		rts				rts
.018aca					READSwapPointers:
.018aca	98		tya				tya
.018acb	48		pha				pha 								; save it
.018acc	ad c1 03	lda $03c1			lda 	DataIndex 					; get data offset, and copy to offset
.018acf	a8		tay				tay
.018ad0	68		pla				pla 								; get code offset and save in DataIndex
.018ad1	8d c1 03	sta $03c1			sta 	DataIndex
.018ad4	da		phx				phx
.018ad5	a2 03		ldx #$03			ldx 	#3 							; swap the Data Pointers (4 bytes) round.
.018ad7					_RSWLoop:
.018ad7	bd bd 03	lda $03bd,x			lda 	DataLPtr+0,x
.018ada	48		pha				pha
.018adb	b5 16		lda $16,x			lda 	zCodePtr+0,x
.018add	9d bd 03	sta $03bd,x			sta 	DataLPtr+0,x
.018ae0	68		pla				pla
.018ae1	95 16		sta $16,x			sta 	zCodePtr+0,x
.018ae3	ca		dex				dex
.018ae4	10 f1		bpl $018ad7			bpl 	_RSWLoop
.018ae6	fa		plx				plx
.018ae7	60		rts				rts
.018ae8					READGetDataItem:
.018ae8	a9 0c		lda #$0c			lda 	#12
.018aea	85 80		sta $80				sta 	XS_Mantissa+0
.018aec	a9 00		lda #$00			lda 	#0
.018aee	85 81		sta $81				sta 	XS_Mantissa+1
.018af0	85 82		sta $82				sta 	XS_Mantissa+2
.018af2	85 83		sta $83				sta 	XS_Mantissa+3
.018af4	a9 01		lda #$01			lda 	#1
.018af6	85 85		sta $85				sta 	XS_Type
.018af8	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/let.asm

.018af9					Command_LET:
.018af9	20 6e 98	jsr $01986e			jsr 	VariableFind 				; get reference to one variable.
.018afc	a9 84		lda #$84			lda 	#token_Equal  				; get equals
.018afe	20 b6 97	jsr $0197b6			jsr 	CheckNextToken
.018b01	a5 22		lda $22				lda 	zVarDataPtr 				; save variable info on stack
.018b03	48		pha				pha
.018b04	a5 23		lda $23				lda 	zVarDataPtr+1
.018b06	48		pha				pha
.018b07	a5 24		lda $24				lda 	zVarType
.018b09	48		pha				pha
.018b0a	20 f3 8f	jsr $018ff3			jsr 	EvaluateExpression 			; evaluate the RHS, set X to zero.
.018b0d	68		pla				pla 								; restore target variable information.
.018b0e	85 24		sta $24				sta 	zVarType
.018b10	68		pla				pla
.018b11	85 23		sta $23				sta 	zVarDataPtr+1
.018b13	68		pla				pla
.018b14	85 22		sta $22				sta 	zVarDataPtr
.018b16	20 07 9c	jsr $019c07			jsr 	VariableSet 				; set the value out.
.018b19	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/sys.asm

.018b1a					Command_SYS:
.018b1a	20 89 91	jsr $019189			jsr 	EvaluateInteger 			; address
.018b1d	a5 80		lda $80				lda 	XS_Mantissa+0				; copy to localvector
.018b1f	8d 10 03	sta $0310			sta 	LocalVector+0 				; only three, can only do 24 bit calls
.018b22	a5 81		lda $81				lda 	XS_Mantissa+1 				; and that only on 65816
.018b24	8d 11 03	sta $0311			sta 	LocalVector+1
.018b27	a5 82		lda $82				lda 	XS_Mantissa+2
.018b29	8d 12 03	sta $0312			sta 	LocalVector+2
.018b2c	22 31 8b 01	jsl $018b31			jsl 	_CSYLocalCall
.018b30	60		rts				rts
.018b31					_CSYLocalCall:
.018b31	dc 10 03	jmp [$0310]			jmp 	[LocalVector]

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/end.asm

.018b34					Command_END:
>018b34	02						.byte 	2
.018b35	4c 07 88	jmp $018807			jmp 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/if.asm

.018b38					Command_IF:
.018b38	20 89 91	jsr $019189			jsr 	EvaluateInteger 			; check success.
.018b3b	a5 80		lda $80				lda 	XS_Mantissa+0				; check the result if zero
.018b3d	05 81		ora $81				ora 	XS_Mantissa+1
.018b3f	05 82		ora $82				ora 	XS_Mantissa+2
.018b41	05 83		ora $83				ora 	XS_Mantissa+3
.018b43	aa		tax				tax 								; put into X.
.018b44	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018b46	c9 93		cmp #$93			cmp 	#token_Then 				; then found.
.018b48	d0 2c		bne $018b76			bne 	_FIFExtended
.018b4a	c8		iny				iny
.018b4b	e0 00		cpx #$00			cpx 	#0 							; was it successful.
.018b4d	f0 0b		beq $018b5a			beq 	_FIFEndOfLine 				; if not, go to the end of the line.
.018b4f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018b51	29 c0		and #$c0			and 	#$C0 						; is it a number
.018b53	c9 40		cmp #$40			cmp 	#$40
.018b55	d0 1e		bne $018b75			bne 	_FIFContinue 				; if not, do what ever follows.
.018b57	4c a9 8e	jmp $018ea9			jmp		Command_GOTO 				; we have IF <expr> THEN <number> so we do GOTO code.
.018b5a					_FIFEndOfLine:
.018b5a	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018b5c	c9 00		cmp #$00			cmp 	#0 							; if zero, end of line, so exit
.018b5e	f0 15		beq $018b75			beq 	_FIFContinue
.018b60	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018b62	c8		iny				iny 								; skip
.018b63	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018b65	90 0c		bcc $018b73			bcc 	_SEDone 					; so just skip over it.
.018b67	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018b69	90 07		bcc $018b72			bcc 	_SEDouble
.018b6b	98		tya				tya 								; this is Y + 1
.018b6c	18		clc				clc
.018b6d	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018b6f	a8		tay				tay 								; back in Y.
.018b70	88		dey				dey 								; fix up, one for the +1, one for the iny
.018b71	88		dey				dey
.018b72					_SEDouble:
.018b72	c8		iny				iny
.018b73					_SEDone:
.018b73	80 e5		bra $018b5a			bra 	_FIFEndOfLine
.018b75					_FIFContinue:
.018b75	60		rts				rts
.018b76					_FIFExtended:
.018b76	da		phx				phx 								; save result
.018b77	a9 40		lda #$40			lda 	#(SMark_If << 4) 			; push marker on the stack, nothing else.
.018b79	20 92 84	jsr $018492			jsr 	StackPushFrame
.018b7c	68		pla				pla 								; restore result
.018b7d	f0 01		beq $018b80			beq 	_FIXSkip 					; if zero then it has failed.
.018b7f	60		rts				rts 								; test passed, so continue executing
.018b80					_FIXSkip:
.018b80	a9 94		lda #$94			lda 	#token_endif 				; scan forward till found either ELSE or ENDIF
.018b82	a2 de		ldx #$de			ldx 	#token_else 				; at the same level.
.018b84	20 f5 83	jsr $0183f5			jsr 	StructureSearchDouble
.018b87	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018b89	c8		iny				iny
.018b8a	c9 94		cmp #$94			cmp 	#token_endif 				; if endif, handle endif code.
.018b8c	f0 07		beq $018b95			beq 	Command_ENDIF
.018b8e	60		rts				rts
.018b8f					Command_ELSE:
.018b8f	a9 94		lda #$94			lda 	#token_endif 				; scan forward till found ENDIF
.018b91	20 f3 83	jsr $0183f3			jsr 	StructureSearchSingle 		; then do the ENDIF pop.
.018b94	c8		iny				iny
.018b95					Command_ENDIF:
.018b95	a9 40		lda #$40			lda 	#(SMark_If << 4)
.018b97	20 a9 84	jsr $0184a9			jsr 	StackPopFrame
.018b9a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/list.asm

.018b9b					Command_LIST:
.018b9b	20 28 8d	jsr $018d28			jsr 	ListGetRange				; get any parameters
.018b9e	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018ba0	85 16		sta $16				sta 	zCodePtr+0
.018ba2	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018ba4	85 17		sta $17				sta 	zCodePtr+1
.018ba6	a9 00		lda #$00			lda 	#0
.018ba8	85 18		sta $18				sta 	zCodePtr+2
.018baa	85 19		sta $19				sta 	zCodePtr+3
.018bac	a0 03		ldy #$03			ldy 	#3
.018bae	a9 00		lda #$00			lda 	#0 							; reset the indent & last indent
.018bb0	8d bc 03	sta $03bc			sta 	LastListIndent
.018bb3	8d bb 03	sta $03bb			sta 	ListIndent
.018bb6					_CILLoop:
.018bb6	a0 00		ldy #$00			ldy 	#0
.018bb8	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018bba	c9 00		cmp #$00			cmp 	#0 							; if zero, end of program
.018bbc	f0 23		beq $018be1			beq 	_CILExit
.018bbe	20 18 85	jsr $018518			jsr 	CheckBreak 					; check break
.018bc1	c9 00		cmp #$00			cmp 	#0
.018bc3	d0 1c		bne $018be1			bne 	_CILExit
.018bc5	20 6f 8d	jsr $018d6f			jsr 	ListCheckRange 				; check current line in range.
.018bc8	b0 08		bcs $018bd2			bcs		_CILNext
.018bca	a0 00		ldy #$00			ldy 	#0
.018bcc	c8		iny				iny
.018bcd	c8		iny				iny
.018bce	c8		iny				iny
.018bcf	20 e4 8b	jsr $018be4			jsr 	ListLine 					; list one line.
.018bd2					_CILNext:
.018bd2	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018bd4	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.018bd6	18		clc				clc
.018bd7	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018bd9	85 16		sta $16				sta 	zCodePtr
.018bdb	90 02		bcc $018bdf			bcc 	_SNLNoCarry
.018bdd	e6 17		inc $17				inc 	zCodePtr+1
.018bdf					_SNLNoCarry:
.018bdf	80 d5		bra $018bb6			bra 	_CILLoop
.018be1					_CILExit:
.018be1	4c 07 88	jmp $018807			jmp 	WarmStart
.018be4					ListLine:
.018be4	ad bb 03	lda $03bb			lda 	ListIndent 					; copy current list indent -> last
.018be7	8d bc 03	sta $03bc			sta 	LastListIndent
.018bea					_LICountIndent:
.018bea	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018bec	c9 00		cmp #$00			cmp 	#0
.018bee	f0 2f		beq $018c1f			beq 	_LIDoneIndent
.018bf0	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus
.018bf2	90 16		bcc $018c0a			bcc 	_LICINext
.018bf4	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.018bf6	b0 12		bcs $018c0a			bcs 	_LICINext
.018bf8	ee bb 03	inc $03bb			inc 	ListIndent
.018bfb	c9 93		cmp #$93			cmp 	#firstKeywordMinus
.018bfd	90 0b		bcc $018c0a			bcc 	_LICINext
.018bff	ce bb 03	dec $03bb			dec 	ListIndent
.018c02	ce bb 03	dec $03bb			dec 	ListIndent
.018c05	10 03		bpl $018c0a			bpl 	_LICINext
.018c07	ee bb 03	inc $03bb			inc 	ListIndent
.018c0a					_LICINext:
.018c0a	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018c0c	c8		iny				iny 								; skip
.018c0d	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018c0f	90 0c		bcc $018c1d			bcc 	_SEDone 					; so just skip over it.
.018c11	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018c13	90 07		bcc $018c1c			bcc 	_SEDouble
.018c15	98		tya				tya 								; this is Y + 1
.018c16	18		clc				clc
.018c17	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018c19	a8		tay				tay 								; back in Y.
.018c1a	88		dey				dey 								; fix up, one for the +1, one for the iny
.018c1b	88		dey				dey
.018c1c					_SEDouble:
.018c1c	c8		iny				iny
.018c1d					_SEDone:
.018c1d	80 cb		bra $018bea			bra 	_LICountIndent
.018c1f					_LIDoneIndent:
.018c1f	a0 00		ldy #$00			ldy 	#0
.018c21	c8		iny				iny
.018c22	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c24	85 80		sta $80				sta 	XS_Mantissa
.018c26	c8		iny				iny
.018c27	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c29	85 81		sta $81				sta 	XS_Mantissa+1
.018c2b	20 94 85	jsr $018594			jsr 	Print16BitInteger 			; print integer.
.018c2e	85 10		sta $10				sta 	zTemp1 						; save spaces printed.
.018c30	ad bb 03	lda $03bb			lda 	ListIndent 					; smaller of current/prev indent
.018c33	cd bc 03	cmp $03bc			cmp 	LastListIndent
.018c36	90 03		bcc $018c3b			bcc 	_LISmaller
.018c38	ad bc 03	lda $03bc			lda 	LastListIndent
.018c3b					_LISmaller:
.018c3b	0a		asl a				asl 	a 							; double indent
.018c3c	49 ff		eor #$ff			eor 	#$FF 						; 2's complement arithmetic
.018c3e	38		sec				sec
.018c3f	65 10		adc $10				adc 	zTemp1 						; "subtract" indent e.g. print more.
.018c41	aa		tax				tax 								; print spaces to column 6
.018c42					_LISpace:
.018c42	a9 20		lda #$20			lda 	#" "
.018c44	20 18 8d	jsr $018d18			jsr 	ListPrintLC
.018c47	e8		inx				inx
.018c48	e0 06		cpx #$06			cpx 	#6
.018c4a	d0 f6		bne $018c42			bne 	_LISpace
.018c4c					_LIDecode:
.018c4c	c8		iny				iny
.018c4d	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c4f	c9 00		cmp #$00			cmp 	#0 							; zero, exit.
.018c51	f0 0f		beq $018c62			beq 	_LIExit
.018c53	30 12		bmi $018c67			bmi 	_LIToken
.018c55	c9 40		cmp #$40			cmp 	#$40 						; 01-$3F, character.
.018c57	b0 50		bcs $018ca9			bcs 	_LIInteger
.018c59	49 20		eor #$20			eor 	#$20 						; make 7 bit
.018c5b	69 20		adc #$20			adc 	#$20
.018c5d	20 18 8d	jsr $018d18			jsr 	ListPrintLC 				; print in LC
.018c60	80 ea		bra $018c4c			bra 	_LIDecode
.018c62					_LIExit:
.018c62	a9 0d		lda #$0d			lda 	#13 						; print new line.
.018c64	4c 18 8d	jmp $018d18			jmp 	ListPrintLC
.018c67					_LIToken:
.018c67	c9 fc		cmp #$fc			cmp 	#$FC 						; $FC-$FF ?
.018c69	90 49		bcc $018cb4			bcc		_LICommandToken
.018c6b	48		pha				pha 								; save in case end
.018c6c	a2 22		ldx #$22			ldx 	#'"'						; print if $FE quoted string
.018c6e	c9 fe		cmp #$fe			cmp 	#$FE
.018c70	f0 17		beq $018c89			beq 	_LIPrint
.018c72	a2 2e		ldx #$2e			ldx 	#'.'						; print if $FD decimals
.018c74	c9 fd		cmp #$fd			cmp 	#$FD
.018c76	f0 11		beq $018c89			beq 	_LIPrint
.018c78	a9 52		lda #$52			lda 	#'R'						; must be REM
.018c7a	20 18 8d	jsr $018d18			jsr 	ListPrintLC
.018c7d	a9 45		lda #$45			lda 	#'E'
.018c7f	20 18 8d	jsr $018d18			jsr 	ListPrintLC
.018c82	a9 4d		lda #$4d			lda 	#'M'
.018c84	20 18 8d	jsr $018d18			jsr 	ListPrintLC
.018c87	a2 20		ldx #$20			ldx 	#' '
.018c89					_LIPrint:
.018c89	8a		txa				txa
.018c8a	20 18 8d	jsr $018d18			jsr 	ListPrintLC
.018c8d	c8		iny				iny
.018c8e	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c90	aa		tax				tax 								; put in X
.018c91	ca		dex				dex
.018c92					_LILoop:
.018c92	ca		dex				dex 								; exit when count reached zero.
.018c93	f0 08		beq $018c9d			beq 	_LIEnd
.018c95	c8		iny				iny
.018c96	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c98	20 18 8d	jsr $018d18			jsr 	ListPrintLC
.018c9b	80 f5		bra $018c92			bra 	_LILoop
.018c9d	68		pla		_LIEnd:	pla 								; get A back
.018c9e	c9 fe		cmp #$fe			cmp 	#$FE 						; if '"' need closing quotes
.018ca0	d0 aa		bne $018c4c			bne 	_LIDecode
.018ca2	a9 22		lda #$22			lda 	#'"'
.018ca4	20 18 8d	jsr $018d18			jsr 	ListPrintLC
.018ca7	80 a3		bra $018c4c			bra 	_LIDecode
.018ca9					_LIInteger:
.018ca9	a2 00		ldx #$00			ldx 	#0
.018cab	20 fb 90	jsr $0190fb			jsr 	EvaluateGetInteger 			; get an atom
.018cae	88		dey				dey
.018caf	20 9a 85	jsr $01859a			jsr 	Print32BitInteger 			; print integer.
.018cb2	80 98		bra $018c4c			bra 	_LIDecode
.018cb4					_LICommandToken:
.018cb4	5a		phy				phy 								; save Y
.018cb5	48		pha				pha 								; save token
.018cb6	a2 92		ldx #$92			ldx  	#KeywordText & $FF 			; address of keyword text table.
.018cb8	a9 86		lda #$86			lda 	(#KeywordText >> 8) & $FF
.018cba	86 1a		stx $1a				stx 	zLTemp1
.018cbc	85 1b		sta $1b				sta 	zLTemp1+1
.018cbe	a9 01		lda #$01			lda 	(#KeywordText >> 16) & $FF 	; this is for 65816 (it's a table in code
.018cc0	85 1c		sta $1c				sta 	zLTemp1+2 					; space) and won't affect a 6502 at all.
.018cc2	68		pla				pla 								; get token
.018cc3	29 7f		and #$7f			and 	#127 						; chuck bit 7.
.018cc5	f0 16		beq $018cdd			beq 	_LIFoundToken
.018cc7	aa		tax				tax
.018cc8					_LITokenLoop:
.018cc8	a0 00		ldy #$00			ldy 	#0 							; last character not a token.
.018cca					_LIFindEnd:
.018cca	b7 1a		lda [$1a],y			lda 	[zLTemp1],y
.018ccc	c8		iny				iny
.018ccd	0a		asl a				asl 	a
.018cce	90 fa		bcc $018cca			bcc 	_LIFindEnd
.018cd0	98		tya				tya 								; that is step to the next
.018cd1	18		clc				clc 								; we don't bother bumping the 3rd byte
.018cd2	65 1a		adc $1a				adc 	zLTemp1 					; here.
.018cd4	85 1a		sta $1a				sta 	zLTemp1
.018cd6	90 02		bcc $018cda			bcc 	_LINoBump
.018cd8	e6 1b		inc $1b				inc 	zLTemp1+1
.018cda					_LINoBump:
.018cda	ca		dex				dex 								; no go round again.
.018cdb	d0 eb		bne $018cc8			bne 	_LITokenLoop
.018cdd					_LIFoundToken:
.018cdd	a0 00		ldy #$00			ldy 	#0
.018cdf					_LIPrintToken:
.018cdf	b7 1a		lda [$1a],y			lda 	[zLTemp1],y
.018ce1	c0 00		cpy #$00			cpy 	#0 							; see if needs prefix space
.018ce3	d0 16		bne $018cfb			bne 	_LINoPrefixSpace
.018ce5	c9 41		cmp #$41			cmp 	#"A" 						; e.g. alphabetic token.
.018ce7	90 12		bcc $018cfb			bcc 	_LINoPrefixSpace
.018ce9	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018ceb	b0 0e		bcs $018cfb			bcs 	_LINoPrefixSpace
.018ced	ae ba 03	ldx $03ba			ldx 	LastPrinted 				; if last was space not required
.018cf0	e0 20		cpx #$20			cpx 	#" "
.018cf2	f0 07		beq $018cfb			beq 	_LINoPrefixSpace
.018cf4	48		pha				pha
.018cf5	a9 20		lda #$20			lda 	#" "
.018cf7	20 18 8d	jsr $018d18			jsr 	ListPrintLC
.018cfa	68		pla				pla
.018cfb					_LINoPrefixSpace:
.018cfb	c8		iny				iny
.018cfc	48		pha				pha 								; save it
.018cfd	29 7f		and #$7f			and 	#$7F
.018cff	20 18 8d	jsr $018d18			jsr 	ListPrintLC
.018d02	68		pla				pla
.018d03	10 da		bpl $018cdf			bpl 	_LIPrintToken 				; go back if not end
.018d05	7a		ply				ply 								; restore Y
.018d06	29 7f		and #$7f			and 	#$7F 						; if last char is a letter
.018d08	c9 41		cmp #$41			cmp 	#"A"
.018d0a	90 09		bcc $018d15			bcc 	_LINotLetter2
.018d0c	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018d0e	b0 05		bcs $018d15			bcs 	_LINotLetter2
.018d10	a9 20		lda #$20			lda 	#" " 						; add spacing
.018d12	20 18 8d	jsr $018d18			jsr 	ListPrintLC
.018d15					_LINotLetter2:
.018d15	4c 4c 8c	jmp $018c4c			jmp 	_LIDecode
.018d18					ListPrintLC:
.018d18	8d ba 03	sta $03ba			sta 	LastPrinted
.018d1b	c9 41		cmp #$41			cmp 	#"A"
.018d1d	90 06		bcc $018d25			bcc 	_LPLC0
.018d1f	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018d21	b0 02		bcs $018d25			bcs 	_LPLC0
.018d23	69 20		adc #$20			adc 	#$20
.018d25	4c 12 85	jmp $018512	_LPLC0:	jmp 	CharPrint
.018d28					ListGetRange:
.018d28	a2 0b		ldx #$0b			ldx 	#XS_Size*2-1 				; clear first 2 slots back to defaults.
.018d2a					_LGRClear:
.018d2a	a9 00		lda #$00			lda 	#0
.018d2c	95 80		sta $80,x			sta 	XS_Mantissa,x
.018d2e	ca		dex				dex
.018d2f	10 f9		bpl $018d2a			bpl 	_LGRClear
.018d31	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018d33	c9 00		cmp #$00			cmp 	#0 							; nothing
.018d35	f0 21		beq $018d58			beq 	_LGRBlank
.018d37	c9 c0		cmp #$c0			cmp 	#token_Colon 				; or colon
.018d39	f0 1d		beq $018d58			beq 	_LGRBlank
.018d3b	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma
.018d3d	f0 18		beq $018d57			beq 	_LGREnd 					; then it's LIST ,x
.018d3f	20 89 91	jsr $019189			jsr 	EvaluateInteger 			; get the first number into bottom
.018d42	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018d44	c9 bf		cmp #$bf			cmp 	#token_Comma
.018d46	f0 0f		beq $018d57			beq 	_LGREnd 					; then it is LIST a,b
.018d48	a5 80		lda $80				lda 	XS_Mantissa+0 				; copy first to second LIST n is n,n
.018d4a	85 86		sta $86				sta 	XS_Mantissa+XS_Size+0
.018d4c	a5 81		lda $81				lda 	XS_Mantissa+1
.018d4e	85 87		sta $87				sta 	XS_Mantissa+XS_Size+1
.018d50					_LGRBumpExit:
.018d50	e6 86		inc $86				inc 	XS_Mantissa+XS_Size 		; bump it so we can use cc.
.018d52	d0 02		bne $018d56			bne 	_LGRBump2
.018d54	e6 87		inc $87				inc 	XS_Mantissa+XS_Size+1
.018d56					_LGRBump2:
.018d56	60		rts				rts
.018d57					_LGREnd:
.018d57	c8		iny				iny
.018d58					_LGRBlank:
.018d58	a9 ff		lda #$ff			lda 	#$FF 						; default to the end.
.018d5a	85 86		sta $86				sta 	XS_Mantissa+XS_Size
.018d5c	85 87		sta $87				sta 	XS_Mantissa+XS_Size+1
.018d5e	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018d60	c9 00		cmp #$00			cmp 	#0
.018d62	f0 f2		beq $018d56			beq 	_LGRBump2
.018d64	0a		asl a				asl 	a 							; if not a number, then exit (to end)
.018d65	b0 ef		bcs $018d56			bcs 	_LGRBump2
.018d67	a2 06		ldx #$06			ldx 	#XS_Size 					; get to range
.018d69	20 8b 91	jsr $01918b			jsr 	EvaluateIntegerX
.018d6c	80 e2		bra $018d50			bra 	_LGRBumpExit
.018d6e	60		rts				rts
.018d6f					ListCheckRange:
.018d6f	c8		iny				iny
.018d70	a2 00		ldx #$00			ldx 	#0 							; test low
.018d72	20 7f 8d	jsr $018d7f			jsr 	_LCRCompare
.018d75	90 06		bcc $018d7d			bcc 	_LCRFail
.018d77	a2 06		ldx #$06			ldx 	#XS_Size 					; test high
.018d79	20 7f 8d	jsr $018d7f			jsr 	_LCRCompare
.018d7c	60		rts				rts
.018d7d					_LCRFail:
.018d7d	38		sec				sec
.018d7e	60		rts				rts
.018d7f					_LCRCompare:
.018d7f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018d81	38		sec				sec
.018d82	f5 80		sbc $80,x			sbc	 	XS_Mantissa+0,x
.018d84	08		php				php
.018d85	c8		iny				iny
.018d86	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018d88	28		plp				plp
.018d89	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.018d8b	08		php				php
.018d8c	88		dey				dey
.018d8d	28		plp				plp
.018d8e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/print.asm

.018d8f					Command_PRINT:
.018d8f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018d91	c9 00		cmp #$00			cmp 	#0 							; end
.018d93	f0 70		beq $018e05			beq 	_CPR_NewLine
.018d95	c9 c0		cmp #$c0			cmp 	#token_Colon
.018d97	f0 6c		beq $018e05			beq 	_CPR_NewLine
.018d99	c9 c1		cmp #$c1			cmp 	#token_SemiColon
.018d9b	f0 5b		beq $018df8			beq 	_CPR_Skip
.018d9d	c9 bf		cmp #$bf			cmp 	#token_Comma
.018d9f	f0 49		beq $018dea			beq 	_CPR_Tab
.018da1	20 f3 8f	jsr $018ff3			jsr 	EvaluateExpression 			; get expression.
.018da4	a5 85		lda $85				lda 	XS_Type 					; get type.
.018da6	29 02		and #$02			and 	#2
.018da8	d0 24		bne $018dce			bne 	_CPR_String 				; if type = 2 output as string.
.018daa					_CPR_Number:
.018daa	a9 00		lda #$00			lda 	#0 							; reset buffer index
.018dac	8d 14 03	sta $0314			sta 	NumBufX
.018daf	a5 85		lda $85				lda 	XS_Type 					; get type
.018db1	4a		lsr a				lsr 	a
.018db2	b0 05		bcs $018db9			bcs 	_CPRInt 					; if msb set do as integer
.018db4	20 c8 a2	jsr $01a2c8			jsr 	FPToString 					; call fp to str otherwise
.018db7	80 03		bra $018dbc			bra 	_CPRNPrint
.018db9	20 50 9d	jsr $019d50	_CPRInt:jsr 	IntToString
.018dbc					_CPRNPrint:
.018dbc	ad 15 03	lda $0315			lda 	Num_Buffer 					; is first character -
.018dbf	c9 2d		cmp #$2d			cmp 	#"-"
.018dc1	f0 05		beq $018dc8			beq 	_CPRNoSpace
.018dc3	a9 20		lda #$20			lda 	#" "						; print the leading space
.018dc5	20 12 85	jsr $018512			jsr 	CharPrint 					; so beloved of MS Basics.
.018dc8					_CPRNoSpace:
.018dc8	a2 14		ldx #$14			ldx 	#(Num_Buffer-1) & $FF
.018dca	a9 03		lda #$03			lda 	#(Num_Buffer-1) >> 8
.018dcc	80 04		bra $018dd2			bra 	_CPRPrint
.018dce					_CPR_String:
.018dce	a6 80		ldx $80				ldx 	XS_Mantissa
.018dd0	a5 81		lda $81				lda 	XS_Mantissa+1
.018dd2					_CPRPrint:
.018dd2	86 1e		stx $1e				stx 	zGenPtr
.018dd4	85 1f		sta $1f				sta 	zGenPtr+1
.018dd6	5a		phy				phy
.018dd7	a0 00		ldy #$00			ldy 	#0							; get length into X
.018dd9	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018ddb	aa		tax				tax
.018ddc	f0 09		beq $018de7			beq 	_CPREndPrint 				; nothing to print
.018dde					_CPRLoop:
.018dde	c8		iny				iny
.018ddf	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018de1	20 12 85	jsr $018512			jsr 	CharPrint
.018de4	ca		dex				dex
.018de5	d0 f7		bne $018dde			bne 	_CPRLoop
.018de7					_CPREndPrint:
.018de7	7a		ply				ply
.018de8	80 a5		bra $018d8f			bra 	Command_Print
.018dea					_CPR_Tab:
.018dea	20 1b 85	jsr $01851b			jsr 	CharGetPosition 			; print until position % 8 = 0
.018ded	29 07		and #$07			and 	#7
.018def	f0 07		beq $018df8			beq 	_CPR_Skip
.018df1	a9 20		lda #$20			lda 	#" "
.018df3	20 12 85	jsr $018512			jsr 	CharPrint
.018df6	80 f2		bra $018dea			bra 	_CPR_Tab
.018df8					_CPR_Skip:
.018df8	c8		iny				iny
.018df9	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018dfb	c9 c0		cmp #$c0			cmp 	#token_Colon 				; colon or $00, exit
.018dfd	f0 09		beq $018e08			beq 	_CPR_Exit
.018dff	c9 00		cmp #$00			cmp 	#0
.018e01	d0 8c		bne $018d8f			bne 	Command_PRINT 				; if not go round again.
.018e03	80 03		bra $018e08			bra 	_CPR_Exit
.018e05					_CPR_NewLine:
.018e05	20 4f 80	jsr $01804f			jsr 	IFT_NewLine
.018e08					_CPR_Exit:
.018e08	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/assert.asm

.018e09					Command_ASSERT:
.018e09	20 89 91	jsr $019189			jsr 	EvaluateInteger 			; calculate thing being asserted
.018e0c	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; check if true (non-zero)
.018e0e	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.018e10	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.018e12	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.018e14	f0 01		beq $018e17			beq 	_ASFail
.018e16	60		rts				rts
.018e17					_ASFail:
.018e17	20 4e 85	jsr $01854e			jsr ERR_Handler
>018e1a	41 73 73 65 72 74 00			.text "Assert",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/poke.asm

.018e21					Command_POKE:
.018e21	a9 01		lda #$01			lda 	#1
.018e23	80 06		bra $018e2b			bra 	CmdPoke_Main
.018e25					Command_DOKE:
.018e25	a9 02		lda #$02			lda 	#2
.018e27	80 02		bra $018e2b			bra 	CmdPoke_Main
.018e29					Command_LOKE:
.018e29	a9 04		lda #$04			lda 	#4
.018e2b					CmdPoke_Main:
.018e2b	48		pha				pha
.018e2c	20 89 91	jsr $019189			jsr 	EvaluateInteger 			; get two parameters.
.018e2f	e8		inx				inx
.018e30	e8		inx				inx
.018e31	e8		inx				inx
.018e32	e8		inx				inx
.018e33	e8		inx				inx
.018e34	e8		inx				inx
.018e35	20 d5 97	jsr $0197d5			jsr 	CheckNextComma
.018e38	20 8b 91	jsr $01918b			jsr 	EvaluateIntegerX
.018e3b	a5 80		lda $80				lda 	XS_Mantissa+0 			; copy the mantissa into ZLTemp1 (address)
.018e3d	85 1a		sta $1a				sta 	zLTemp1
.018e3f	a5 81		lda $81				lda 	XS_Mantissa+1
.018e41	85 1b		sta $1b				sta 	zLTemp1+1
.018e43	a5 82		lda $82				lda 	XS_Mantissa+2
.018e45	85 1c		sta $1c				sta 	zLTemp1+2
.018e47	a5 83		lda $83				lda 	XS_Mantissa+3
.018e49	85 1d		sta $1d				sta 	zLTemp1+3
.018e4b	68		pla				pla 								; get count
.018e4c	5a		phy				phy 								; save Y
.018e4d	20 60 97	jsr $019760			jsr 	MemWrite 					; write it out
.018e50	7a		ply				ply 								; restore Y and done.
.018e51	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/newold.asm

.018e52					Command_NEW:
.018e52	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018e54	85 16		sta $16				sta 	zCodePtr+0
.018e56	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018e58	85 17		sta $17				sta 	zCodePtr+1
.018e5a	a9 00		lda #$00			lda 	#0
.018e5c	85 18		sta $18				sta 	zCodePtr+2
.018e5e	85 19		sta $19				sta 	zCodePtr+3
.018e60	a0 03		ldy #$03			ldy 	#3
.018e62	a0 00		ldy #$00			ldy 	#0
.018e64	a9 00		lda #$00			lda 	#0 							; write a 0 there.
.018e66	97 16		sta [$16],y			sta 	[zCodePtr],y
.018e68	20 71 97	jsr $019771			jsr 	UpdateProgramEnd 			; update program end.
.018e6b	4c 07 88	jmp $018807			jmp 	WarmStart
.018e6e					Command_OLD:
.018e6e	ea		nop				nop
.018e6f	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018e71	85 16		sta $16				sta 	zCodePtr+0
.018e73	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018e75	85 17		sta $17				sta 	zCodePtr+1
.018e77	a9 00		lda #$00			lda 	#0
.018e79	85 18		sta $18				sta 	zCodePtr+2
.018e7b	85 19		sta $19				sta 	zCodePtr+3
.018e7d	a0 03		ldy #$03			ldy 	#3
.018e7f					_COL_Find:
.018e7f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e81	c8		iny				iny
.018e82	c9 00		cmp #$00			cmp 	#0 							; if zero, then the position Y/Z is new offset
.018e84	f0 18		beq $018e9e			beq 	_COL_Found
.018e86	98		tya				tya
.018e87	c9 00		cmp #$00			cmp 	#0
.018e89	d0 f4		bne $018e7f			bne 	_COL_Find 					; can't find old EOL, give up.
.018e8b	20 4e 85	jsr $01854e			jsr ERR_Handler
>018e8e	50 72 6f 67 72 61 6d 20			.text "Program Corrupt",0
>018e96	43 6f 72 72 75 70 74 00
.018e9e					_COL_Found:
.018e9e	98		tya				tya
.018e9f	48		pha				pha
.018ea0	a0 00		ldy #$00			ldy 	#0
.018ea2	68		pla				pla
.018ea3	97 16		sta [$16],y			sta 	[zCodePtr],y
.018ea5	20 71 97	jsr $019771			jsr 	UpdateProgramEnd 			; reset variable pointer
.018ea8	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/branch.asm

.018ea9					Command_GOTO:
.018ea9	20 18 8f	jsr $018f18			jsr 	GotoGetLineNumber
.018eac					CmdGOTO:
.018eac	a2 00		ldx #$00			ldx 	#0
.018eae	4c 35 8f	jmp $018f35			jmp 	GotoChangeToLineNumberX
.018eb1					Command_GOSUB:
.018eb1	20 18 8f	jsr $018f18			jsr 	GotoGetLineNumber
.018eb4					CmdGOSUB:
.018eb4	20 d9 84	jsr $0184d9			jsr 	StackSavePosition
.018eb7	a9 15		lda #$15			lda 	#(SMark_Gosub << 4)+SourcePosSize
.018eb9	20 92 84	jsr $018492			jsr 	StackPushFrame
.018ebc	a2 00		ldx #$00			ldx		#0
.018ebe	4c 35 8f	jmp $018f35			jmp 	GotoChangeToLineNumberX
.018ec1					Command_RETURN:
.018ec1	a9 10		lda #$10			lda 	#(SMark_Gosub << 4)
.018ec3	20 a9 84	jsr $0184a9			jsr 	StackPopFrame
.018ec6	20 f6 84	jsr $0184f6			jsr 	StackRestorePosition
.018ec9	60		rts				rts
.018eca					Command_ON:
.018eca	a2 00		ldx #$00			ldx 	#0 							; get the ON.
.018ecc	20 25 96	jsr $019625			jsr 	SLIByteParameter
.018ecf	a5 80		lda $80				lda 	XS_Mantissa+0 				; get the count
.018ed1	f0 42		beq $018f15			beq 	_CONFail 					; can't be zero.
.018ed3	aa		tax				tax 								; save in X.
.018ed4	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018ed6	c8		iny				iny
.018ed7	48		pha				pha
.018ed8	c9 cc		cmp #$cc			cmp 	#token_GOTO 				; must be GOTO or GOSUB
.018eda	f0 07		beq $018ee3			beq 	_CONOkayToken
.018edc	c9 ca		cmp #$ca			cmp 	#token_GOSUB
.018ede	f0 03		beq $018ee3			beq 	_CONOkayToken
.018ee0	4c 1f 85	jmp $01851f			jmp 	SyntaxError
.018ee3					_CONOkayToken:
.018ee3	da		phx				phx 								; count on top, GOTO/GOSUB token 2nd.
.018ee4					_CONFindNumber:
.018ee4	20 18 8f	jsr $018f18			jsr 	GotoGetLineNumber 			; get a line number.
.018ee7	fa		plx				plx 								; restore count
.018ee8	ca		dex				dex  								; decrement, exit if zero.
.018ee9	f0 06		beq $018ef1			beq 	_CONFound
.018eeb	da		phx				phx 								; push back
.018eec	20 d5 97	jsr $0197d5			jsr 	CheckNextComma				; check for comma
.018eef	80 f3		bra $018ee4			bra 	_CONFindNumber
.018ef1					_CONFound:
.018ef1	68		pla				pla 								; get token
.018ef2	c9 cc		cmp #$cc			cmp 	#token_GOTO 				; if GOTO
.018ef4	f0 b6		beq $018eac			beq		CmdGOTO 					; then just branch.
.018ef6					_CONEndOfCmd:
.018ef6	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018ef8	c9 00		cmp #$00			cmp 	#0 							; if zero, end of line, so exit
.018efa	f0 b8		beq $018eb4			beq 	CMDGosub
.018efc	c9 c0		cmp #$c0			cmp 	#token_Colon 				; if colon, end of command
.018efe	f0 b4		beq $018eb4			beq 	CMDGosub
.018f00	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018f02	c8		iny				iny 								; skip
.018f03	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018f05	90 0c		bcc $018f13			bcc 	_SEDone 					; so just skip over it.
.018f07	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018f09	90 07		bcc $018f12			bcc 	_SEDouble
.018f0b	98		tya				tya 								; this is Y + 1
.018f0c	18		clc				clc
.018f0d	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018f0f	a8		tay				tay 								; back in Y.
.018f10	88		dey				dey 								; fix up, one for the +1, one for the iny
.018f11	88		dey				dey
.018f12					_SEDouble:
.018f12	c8		iny				iny
.018f13					_SEDone:
.018f13	80 e1		bra $018ef6			bra 	_CONEndOfCmd
.018f15					_CONFail:
.018f15	4c 3d 85	jmp $01853d			jmp 	BadParamError
.018f18					GotoGetLineNumber:
.018f18	20 89 91	jsr $019189			jsr 	EvaluateInteger
.018f1b	a5 82		lda $82				lda 	XS_Mantissa+2 				; check range
.018f1d	05 83		ora $83				ora 	XS_Mantissa+3
.018f1f	d0 01		bne $018f22			bne 	_GLINError
.018f21	60		rts				rts
.018f22					_GLINError:
.018f22	20 4e 85	jsr $01854e			jsr ERR_Handler
>018f25	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>018f2d	20 4e 75 6d 62 65 72 00
.018f35					GotoChangeToLineNumberX:
.018f35	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check line number not zero
.018f37	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.018f39	f0 37		beq $018f72			beq 	_GCTLFail
.018f3b	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018f3d	85 16		sta $16				sta 	zCodePtr+0
.018f3f	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018f41	85 17		sta $17				sta 	zCodePtr+1
.018f43	a9 00		lda #$00			lda 	#0
.018f45	85 18		sta $18				sta 	zCodePtr+2
.018f47	85 19		sta $19				sta 	zCodePtr+3
.018f49	a0 03		ldy #$03			ldy 	#3
.018f4b					_GCTLLoop:
.018f4b	a0 00		ldy #$00			ldy 	#0
.018f4d	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018f4f	c9 00		cmp #$00			cmp 	#0
.018f51	f0 1f		beq $018f72			beq 	_GCTLFail
.018f53	c8		iny				iny
.018f54	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018f56	d5 80		cmp $80,x			cmp 	XS_Mantissa+0,x
.018f58	d0 07		bne $018f61			bne 	_GCTLNext
.018f5a	c8		iny				iny
.018f5b	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018f5d	d5 81		cmp $81,x			cmp 	XS_Mantissa+1,x
.018f5f	f0 0f		beq $018f70			beq 	_GCTLExit
.018f61					_GCTLNext:
.018f61	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018f63	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.018f65	18		clc				clc
.018f66	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018f68	85 16		sta $16				sta 	zCodePtr
.018f6a	90 02		bcc $018f6e			bcc 	_SNLNoCarry
.018f6c	e6 17		inc $17				inc 	zCodePtr+1
.018f6e					_SNLNoCarry:
.018f6e	80 db		bra $018f4b			bra 	_GCTLLoop 					; try next line.
.018f70					_GCTLExit:
.018f70	c8		iny				iny
.018f71	60		rts				rts
.018f72					_GCTLFail:
.018f72	20 4e 85	jsr $01854e			jsr ERR_Handler
>018f75	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>018f7d	20 4e 75 6d 62 65 72 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.018f85					Command_CLR:
.018f85					ResetRunStatus:
.018f85	20 aa 98	jsr $0198aa			jsr 	VariableClear
.018f88	20 80 84	jsr $018480			jsr 	StackReset
.018f8b	a9 00		lda #$00			lda 	#HighMemory & $FF
.018f8d	8d 00 03	sta $0300			sta 	StringPtr
.018f90	a9 7f		lda #$7f			lda 	#HighMemory >> 8
.018f92	8d 01 03	sta $0301			sta 	StringPtr+1
.018f95	20 74 9a	jsr $019a74			jsr 	ArrayResetDefault
.018f98	20 bf 8a	jsr $018abf			jsr 	Command_RESTORE
.018f9b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/stop.asm

.018f9c					Command_STOP:
.018f9c	20 4e 85	jsr $01854e			jsr ERR_Handler
>018f9f	53 74 6f 70 00				.text "Stop",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/while.asm

.018fa4					Command_WHILE:
.018fa4	20 d9 84	jsr $0184d9			jsr 	StackSavePosition			; save position into stack, but don't yet push.
.018fa7	20 89 91	jsr $019189			jsr 	EvaluateInteger 			; calculate the while loop value.
.018faa	a5 80		lda $80				lda 	XS_Mantissa+0				; check the result if zero
.018fac	05 81		ora $81				ora 	XS_Mantissa+1
.018fae	05 82		ora $82				ora 	XS_Mantissa+2
.018fb0	05 83		ora $83				ora 	XS_Mantissa+3
.018fb2	f0 06		beq $018fba			beq 	_CWHSkip 					; if it is zero, then skip to WEND.
.018fb4	a9 35		lda #$35			lda 	#(SMark_While << 4)+SourcePosSize
.018fb6	20 92 84	jsr $018492			jsr 	StackPushFrame 				; push on stack
.018fb9	60		rts				rts
.018fba					_CWHSkip:
.018fba	a9 95		lda #$95			lda 	#token_Wend 				; look for the WEND token.
.018fbc	20 f3 83	jsr $0183f3			jsr 	StructureSearchSingle
.018fbf	c8		iny				iny
.018fc0	60		rts				rts
.018fc1					Command_WEND:
.018fc1	a9 30		lda #$30			lda 	#(SMark_While << 4)			; remove the frame
.018fc3	20 a9 84	jsr $0184a9			jsr 	StackPopFrame
.018fc6	20 f6 84	jsr $0184f6			jsr 	StackRestorePosition
.018fc9	80 d9		bra $018fa4			bra 	Command_WHILE 				; and do the while again.
.018fcb	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/repeat.asm

.018fcc					Command_REPEAT:
.018fcc	20 d9 84	jsr $0184d9			jsr 	StackSavePosition			; save position into stack
.018fcf	a9 25		lda #$25			lda 	#(SMark_Repeat << 4)+SourcePosSize
.018fd1	20 92 84	jsr $018492			jsr 	StackPushFrame 				; push on stack
.018fd4	60		rts				rts
.018fd5					Command_UNTIL:
.018fd5	a9 20		lda #$20			lda 	#(SMark_Repeat << 4)		; remove the frame
.018fd7	20 a9 84	jsr $0184a9			jsr 	StackPopFrame
.018fda	20 89 91	jsr $019189			jsr 	EvaluateInteger				; work out UNTIL
.018fdd	a5 80		lda $80				lda 	XS_Mantissa+0 				; check if zero.
.018fdf	05 81		ora $81				ora 	XS_Mantissa+1
.018fe1	05 82		ora $82				ora 	XS_Mantissa+2
.018fe3	05 83		ora $83				ora 	XS_Mantissa+3
.018fe5	d0 08		bne $018fef			bne 	_CUTExit 					; if not, just exit
.018fe7	20 f6 84	jsr $0184f6			jsr 	StackRestorePosition 		; otherwise loop round again.
.018fea	a9 25		lda #$25			lda 	#(SMark_Repeat << 4)+SourcePosSize
.018fec	20 92 84	jsr $018492			jsr 	StackPushFrame 				; fix the stack back.
.018fef					_CUTExit:
.018fef	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.018ff0					EVESyntax:
.018ff0	4c 1f 85	jmp $01851f			jmp 	SyntaxError
.018ff3					EvaluateExpression:
.018ff3	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.018ff5					EvaluateExpressionX:
.018ff5	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.018ff7					EvaluateExpressionXA:
.018ff7	48		pha				pha 								; save precedence on stack.
.018ff8	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018ffa	f0 f4		beq $018ff0			beq 	EVESyntax 					; end of line, syntax error.
.018ffc	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.018ffe	b0 03		bcs $019003			bcs 	_EVNotVariable
.019000	4c cd 90	jmp $0190cd			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.019003					_EVNotVariable:
.019003	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.019005	90 e9		bcc $018ff0			bcc 	EVESyntax
.019007	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.019009	b0 58		bcs $019063			bcs 	_EVNotInteger
.01900b	20 fb 90	jsr $0190fb			jsr 	EvaluateGetInteger
.01900e					_EVCheckDecimal:
.01900e	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019010	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.019012	d0 05		bne $019019			bne 	_EVGotAtom 					; no, get atom.
.019014					_EVIsDecimal:
.019014	20 21 91	jsr $019121			jsr 	EVGetDecimal 				; extend to the decimal part.
.019017	80 00		bra $019019			bra 	_EVGotAtom 					; and continue to got atom.
.019019					_EVGotAtom:
.019019	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01901b	10 44		bpl $019061			bpl 	_EVExitDrop 				; must be a token.
.01901d	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.01901f	b0 40		bcs $019061			bcs 	_EVExitDrop
.019021	68		pla				pla 								; get current precedence
.019022	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.019024	da		phx				phx 								; save X
.019025	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019027	aa		tax				tax 								; put in X
.019028	bf 03 86 01	lda $018603,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.01902c	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.01902e	fa		plx				plx 								; restore X
.01902f	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.019031	90 2f		bcc $019062			bcc 	_EVExit 					; exit if too low.
.019033	f0 2d		beq $019062			beq 	_EVExit 					; exit if equals
.019035	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.019037	48		pha				pha
.019038	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01903a	48		pha				pha
.01903b	c8		iny				iny
.01903c	da		phx				phx 								; save current position
.01903d	e8		inx				inx
.01903e	e8		inx				inx
.01903f	e8		inx				inx
.019040	e8		inx				inx
.019041	e8		inx				inx
.019042	e8		inx				inx
.019043	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.019045	20 f7 8f	jsr $018ff7			jsr 	EvaluateExpressionXA 		; do the RHS.
.019048	fa		plx				plx 								; restore X
.019049	68		pla				pla 								; get the binary operator in A.
.01904a					_EVCallA:
.01904a	da		phx				phx 								; save X again
.01904b	0a		asl a				asl 	a 							; double, lose the MSB.
.01904c	aa		tax				tax									; put in X
.01904d	bf b2 85 01	lda $0185b2,x			lda 	VectorTable,x 				; copy address into zGenPtr
.019051	8d 11 03	sta $0311			sta 	LocalVector+1
.019054	bf b3 85 01	lda $0185b3,x			lda 	VectorTable+1,x
.019058	8d 12 03	sta $0312			sta 	LocalVector+2
.01905b	fa		plx				plx 								; restore X
.01905c	20 d6 90	jsr $0190d6			jsr 	EVCallLocalVector
.01905f	80 b8		bra $019019			bra 	_EVGotAtom 					; and loop back.
.019061					_EVExitDrop:
.019061	68		pla				pla
.019062					_EVExit:
.019062	60		rts				rts
.019063					_EVNotInteger:
.019063	c8		iny				iny
.019064	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.019066	d0 16		bne $01907e			bne 	_EVNotMinus
.019068	20 6a 91	jsr $01916a			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.01906b	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.01906d	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.01906f	f0 05		beq $019076			beq 	_EVMinusFloat
.019071	20 33 9d	jsr $019d33			jsr 	IntegerNegateAlways 		; negation
.019074	80 a3		bra $019019			bra 	_EVGotAtom 					; and go back.
.019076					_EVMinusFloat:
.019076	b5 85		lda $85,x			lda 	XS_Type,x 					; invert the sign bit.
.019078	49 80		eor #$80			eor 	#$80
.01907a	95 85		sta $85,x			sta 	XS_Type,x
.01907c	80 9b		bra $019019			bra 	_EVGotAtom
.01907e					_EVNotMinus:
.01907e	c9 bd		cmp #$bd			cmp 	#token_lparen 				; is it left parenthesis
.019080	d0 17		bne $019099			bne 	_EVNotParenthesis
.019082	20 f5 8f	jsr $018ff5			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.019085	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019087	c8		iny				iny
.019088	c9 be		cmp #$be			cmp 	#token_rparen 				; okay if right bracket.
.01908a	f0 8d		beq $019019			beq 	_EVGotAtom
.01908c	20 4e 85	jsr $01854e			jsr ERR_Handler
>01908f	4d 69 73 73 69 6e 67 20			.text "Missing )",0
>019097	29 00
.019099					_EVNotParenthesis:
.019099	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.01909b	d0 0c		bne $0190a9			bne 	_EVNotNot
.01909d	20 6a 91	jsr $01916a			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.0190a0	20 c9 a1	jsr $01a1c9			jsr 	FPUToInteger 				; make it an integer - if possible.
.0190a3	20 4f 91	jsr $01914f			jsr 	NotInteger 					; do the not calculation
.0190a6	4c 19 90	jmp $019019			jmp 	_EVGotAtom
.0190a9					_EVNotNot:
.0190a9	c9 fe		cmp #$fe			cmp 	#$FE
.0190ab	d0 12		bne $0190bf			bne 	_EVNotString
.0190ad	20 48 98	jsr $019848			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.0190b0	a5 20		lda $20				lda 	zTempStr 					; copy address of string into mantissa
.0190b2	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0190b4	a5 21		lda $21				lda 	zTempStr+1
.0190b6	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0190b8	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.0190ba	95 85		sta $85,x			sta 	XS_Type,x
.0190bc	4c 19 90	jmp $019019			jmp 	_EVGotAtom
.0190bf					_EVNotString:
.0190bf	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.0190c1	90 04		bcc $0190c7			bcc 	_EVBadElement
.0190c3	c9 b7		cmp #$b7			cmp 	#lastUnaryFunction+1
.0190c5	90 03		bcc $0190ca			bcc 	_EVUnaryFunction
.0190c7					_EVBadElement:
.0190c7	4c 1f 85	jmp $01851f			jmp 	SyntaxError
.0190ca					_EVUnaryFunction:
.0190ca	4c 4a 90	jmp $01904a			jmp 	_EVCallA
.0190cd					_EVVariableHandler:
.0190cd	20 6e 98	jsr $01986e			jsr 	VariableFind 				; locate a variable
.0190d0	20 b6 9b	jsr $019bb6			jsr 	VariableGet 				; copy into memory.
.0190d3	4c 19 90	jmp $019019			jmp 	_EVGotAtom 					; and go round.
.0190d6					EVCallLocalVector:
.0190d6	6c 11 03	jmp ($0311)			jmp 	(LocalVector+1)
.0190d9					EVShiftMantissaLeft6:
.0190d9	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.0190db	95 84		sta $84,x			sta 	XS_Exponent,x
.0190dd	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0190df	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0190e1	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0190e3	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0190e5	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0190e7	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0190e9	a9 00		lda #$00			lda 	#0
.0190eb	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0190ed	20 f0 90	jsr $0190f0			jsr 	_EVSMLShift 					; call it here to do it twice
.0190f0					_EVSMLShift:
.0190f0	56 84		lsr $84,x			lsr 	XS_Exponent,x
.0190f2	76 83		ror $83,x			ror 	XS_Mantissa+3,x
.0190f4	76 82		ror $82,x			ror 	XS_Mantissa+2,x
.0190f6	76 81		ror $81,x			ror 	XS_Mantissa+1,x
.0190f8	76 80		ror $80,x			ror 	XS_Mantissa+0,x
.0190fa	60		rts				rts
.0190fb					EvaluateGetInteger:
.0190fb	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0190fd	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.0190ff	95 80		sta $80,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.019101	a9 00		lda #$00			lda 	#0
.019103	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019105	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019107	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019109	1a		inc a				inc 	a 							; set to type 1 (integer)
.01910a	95 85		sta $85,x			sta 	XS_Type,x
.01910c					_EVCheckNextInteger:
.01910c	c8		iny				iny
.01910d	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01910f	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.019111	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.019113	b0 0b		bcs $019120			bcs 	_EVEndInteger
.019115	48		pha				pha 								; save it.
.019116	20 d9 90	jsr $0190d9			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.019119	68		pla				pla
.01911a	15 80		ora $80,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.01911c	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01911e	80 ec		bra $01910c			bra 	_EVCheckNextInteger
.019120					_EVEndInteger:
.019120	60		rts				rts
.019121					EVGetDecimal:
.019121	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.019123	8d 15 03	sta $0315			sta 	Num_Buffer
.019126	da		phx				phx
.019127	c8		iny				iny
.019128	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01912a	c8		iny				iny
.01912b	3a		dec a				dec 	a								; convert to a string length.
.01912c	3a		dec a				dec 	a
.01912d	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.01912f					_EVGDCopy:
.01912f	48		pha				pha 									; save count
.019130	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019132	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.019135	e8		inx				inx 									; forward ....
.019136	c8		iny				iny
.019137	68		pla				pla 									; get count
.019138	3a		dec a				dec 	a 								; until zero
.019139	d0 f4		bne $01912f			bne 	_EVGDCopy
.01913b	9d 15 03	sta $0315,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.01913e	fa		plx				plx 									; restore X
.01913f	a9 15		lda #$15			lda 	#Num_Buffer & $FF 				; set zGenPtr
.019141	85 1e		sta $1e				sta 	zGenPtr
.019143	a9 03		lda #$03			lda 	#Num_Buffer >> 8
.019145	85 1f		sta $1f				sta 	zGenPtr+1
.019147	5a		phy				phy 									; save Y
.019148	a0 00		ldy #$00			ldy 	#0 								; start position
.01914a	20 83 a3	jsr $01a383			jsr 	FPFromString 					; convert current
.01914d	7a		ply				ply 									; restore Y
.01914e	60		rts				rts
.01914f					NotInteger:
.01914f	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019151	49 ff		eor #$ff			eor 	#$FF
.019153	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019155	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019157	49 ff		eor #$ff			eor 	#$FF
.019159	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01915b	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01915d	49 ff		eor #$ff			eor 	#$FF
.01915f	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019161	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019163	49 ff		eor #$ff			eor 	#$FF
.019165	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019167	60		rts				rts
.019168					EvaluateGetAtom:
.019168	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.01916a					EvaluateGetAtomX:
.01916a	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.01916c	20 f7 8f	jsr $018ff7			jsr 	EvaluateExpressionXA
.01916f	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.019171	29 0f		and #$0f			and 	#15
.019173	c9 02		cmp #$02			cmp 	#2
.019175	b0 01		bcs $019178			bcs 	EvaluateType
.019177	60		rts				rts
.019178					EvaluateType:
.019178	4c 2f 85	jmp $01852f			jmp 	TypeError
.01917b					EvaluateNumber:
.01917b	a2 00		ldx #$00			ldx 	#0
.01917d					EvaluateNumberX:
.01917d	20 f5 8f	jsr $018ff5			jsr 	EvaluateExpressionX
.019180	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0/1
.019182	29 0f		and #$0f			and 	#15
.019184	c9 02		cmp #$02			cmp 	#2
.019186	b0 f0		bcs $019178			bcs 	EvaluateType
.019188	60		rts				rts
.019189					EvaluateInteger:
.019189	a2 00		ldx #$00			ldx 	#0
.01918b					EvaluateIntegerX:
.01918b	20 7d 91	jsr $01917d			jsr 	EvaluateNumberX
.01918e	20 c9 a1	jsr $01a1c9			jsr 	FPUToInteger
.019191	60		rts				rts
.019192					EvaluateString:
.019192	a2 00		ldx #$00			ldx 	#0
.019194					EvaluateStringX:
.019194	20 f5 8f	jsr $018ff5			jsr 	EvaluateExpressionX
.019197	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 2
.019199	29 0f		and #$0f			and 	#15
.01919b	c9 02		cmp #$02			cmp 	#2
.01919d	d0 d9		bne $019178			bne 	EvaluateType
.01919f	b5 80		lda $80,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.0191a1	85 1e		sta $1e				sta 	zGenPtr
.0191a3	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0191a5	85 1f		sta $1f				sta 	zGenPtr+1
.0191a7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.0191a8					BinaryOp_And:
.0191a8	20 fc 91	jsr $0191fc			jsr 	BinaryMakeBothInteger
.0191ab	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.0191ad	35 86		and $86,x			and 	XS2_Mantissa+0,x
.0191af	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0191b1	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.0191b3	35 87		and $87,x			and 	XS2_Mantissa+1,x
.0191b5	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0191b7	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.0191b9	35 88		and $88,x			and 	XS2_Mantissa+2,x
.0191bb	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0191bd	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.0191bf	35 89		and $89,x			and 	XS2_Mantissa+3,x
.0191c1	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0191c3	60		rts				rts
.0191c4					BinaryOp_Or:
.0191c4	20 fc 91	jsr $0191fc			jsr 	BinaryMakeBothInteger
.0191c7	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.0191c9	15 86		ora $86,x			ora 	XS2_Mantissa+0,x
.0191cb	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0191cd	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.0191cf	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.0191d1	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0191d3	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.0191d5	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.0191d7	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0191d9	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.0191db	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.0191dd	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0191df	60		rts				rts
.0191e0					BinaryOp_Eor:
.0191e0					BinaryOp_Xor:
.0191e0	20 fc 91	jsr $0191fc			jsr 	BinaryMakeBothInteger
.0191e3	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.0191e5	55 86		eor $86,x			eor 	XS2_Mantissa+0,x
.0191e7	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0191e9	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.0191eb	55 87		eor $87,x			eor 	XS2_Mantissa+1,x
.0191ed	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0191ef	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.0191f1	55 88		eor $88,x			eor 	XS2_Mantissa+2,x
.0191f3	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0191f5	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.0191f7	55 89		eor $89,x			eor 	XS2_Mantissa+3,x
.0191f9	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0191fb	60		rts				rts
.0191fc					BinaryMakeBothInteger:
.0191fc	da		phx				phx 								; save X
.0191fd	e8		inx				inx
.0191fe	e8		inx				inx
.0191ff	e8		inx				inx
.019200	e8		inx				inx
.019201	e8		inx				inx
.019202	e8		inx				inx
.019203	20 07 92	jsr $019207			jsr 	BinaryMakeInteger 			; convert to integer.
.019206	fa		plx				plx 								; restore X and fall through.
.019207					BinaryMakeInteger:
.019207	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.019209	29 0f		and #$0f			and 	#15 						; check type zero
.01920b	f0 04		beq $019211			beq 	_BMIConvert 				; if float convert to integer.
.01920d	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.01920e	90 04		bcc $019214			bcc 	_BMIError
.019210	60		rts				rts
.019211					_BMIConvert:
.019211	4c c9 a1	jmp $01a1c9			jmp 	FPUToInteger 				; convert to integer
.019214					_BMIError:
.019214	4c 2f 85	jmp $01852f			jmp 	TypeError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.019217					Binary_Equal:
.019217	20 5e 92	jsr $01925e			jsr 	CompareValues
.01921a	09 00		ora #$00			ora 	#0
.01921c	f0 04		beq $019222			beq 	CCTrue
.01921e	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.019220	80 02		bra $019224			bra 	CCWrite
.019222	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.019224	95 80		sta $80,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.019226	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019228	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01922a	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01922c	a9 01		lda #$01			lda 	#1
.01922e	95 85		sta $85,x			sta 	XS_Type,x 					; set type to integer whatever.
.019230	60		rts				rts
.019231					Binary_NotEqual:
.019231	20 5e 92	jsr $01925e			jsr 	CompareValues
.019234	09 00		ora #$00			ora 	#0
.019236	f0 e6		beq $01921e			beq 	CCFalse
.019238	80 e8		bra $019222			bra 	CCTrue
.01923a					Binary_Less:
.01923a	20 5e 92	jsr $01925e			jsr 	CompareValues
.01923d	09 00		ora #$00			ora 	#0
.01923f	30 e1		bmi $019222			bmi 	CCTrue
.019241	80 db		bra $01921e			bra 	CCFalse
.019243					Binary_LessEqual:
.019243	20 5e 92	jsr $01925e			jsr 	CompareValues
.019246	c9 01		cmp #$01			cmp 	#1
.019248	d0 d8		bne $019222			bne 	CCTrue
.01924a	80 d2		bra $01921e			bra 	CCFalse
.01924c					Binary_GreaterEqual:
.01924c	20 5e 92	jsr $01925e			jsr 	CompareValues
.01924f	09 00		ora #$00			ora 	#0
.019251	10 cf		bpl $019222			bpl 	CCTrue
.019253	80 c9		bra $01921e			bra 	CCFalse
.019255					Binary_Greater:
.019255	20 5e 92	jsr $01925e			jsr 	CompareValues
.019258	c9 01		cmp #$01			cmp 	#1
.01925a	f0 c6		beq $019222			beq 	CCTrue
.01925c	80 c0		bra $01921e			bra 	CCFalse
.01925e					CompareValues:
.01925e	b5 85		lda $85,x			lda 	XS_Type,x 					; and the types together
.019260	35 8b		and $8b,x			and 	XS2_Type,x
.019262	c9 02		cmp #$02			cmp 	#2
.019264	f0 11		beq $019277			beq 	_CVString
.019266	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.019268	35 8b		and $8b,x			and 	XS2_Type,x
.01926a	4a		lsr a				lsr 	a 							; shift bit 0 into C
.01926b	90 03		bcc $019270			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.01926d	4c b9 92	jmp $0192b9			jmp 	CompareInteger32 							; so execute code at \1
.019270					_BCFloat:
.019270	20 5d 93	jsr $01935d			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.019273	4c c2 a0	jmp $01a0c2			jmp 	FPCompare 							; and execute code at \2
.019276	60		rts				rts
.019277					_CVString:
.019277	da		phx				phx 								; save XY
.019278	5a		phy				phy
.019279	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.01927b	85 1a		sta $1a				sta		zLTemp1+0
.01927d	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01927f	85 1b		sta $1b				sta 	zLTemp1+1
.019281	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.019283	85 1c		sta $1c				sta 	zLTemp1+2
.019285	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.019287	85 1d		sta $1d				sta 	zLTemp1+3
.019289	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.01928b	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.01928d	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.01928f	90 02		bcc $019293			bcc 	_CVCommon
.019291	b1 1c		lda ($1c),y			lda 	(zLTemp1+2),y
.019293					_CVCommon:
.019293	aa		tax				tax 								; put shorter string length in zero.
.019294	f0 0c		beq $0192a2			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.019296					_CVCompare:
.019296	c8		iny				iny 								; next character
.019297	b1 1a		lda ($1a),y			lda 	(zLTemp1),y 				; compare characters
.019299	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.01929b	90 13		bcc $0192b0			bcc 	_CVReturnLess 				; <
.01929d	d0 15		bne $0192b4			bne 	_CVReturnGreater 			; >
.01929f	ca		dex				dex 								; until common length matched.
.0192a0	d0 f4		bne $019296			bne 	_CVCompare
.0192a2					_CVMatch:
.0192a2	a0 00		ldy #$00			ldy 	#0
.0192a4	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.0192a6	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.0192a8	90 06		bcc $0192b0			bcc 	_CVReturnLess 				; <
.0192aa	d0 08		bne $0192b4			bne 	_CVReturnGreater 			; >
.0192ac	a9 00		lda #$00			lda 	#0
.0192ae	80 06		bra $0192b6			bra 	_CVExit 					; same common, same length, same string
.0192b0					_CVReturnLess:
.0192b0	a9 ff		lda #$ff			lda 	#$FF
.0192b2	80 02		bra $0192b6			bra 	_CVExit
.0192b4					_CVReturnGreater:
.0192b4	a9 01		lda #$01			lda 	#$01
.0192b6					_CVExit:
.0192b6	7a		ply				ply
.0192b7	fa		plx				plx
.0192b8	60		rts				rts
.0192b9					CompareInteger32:
.0192b9	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.0192bb	49 80		eor #$80			eor 	#$80
.0192bd	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0192bf	b5 89		lda $89,x			lda 	XS2_Mantissa+3,x
.0192c1	49 80		eor #$80			eor 	#$80
.0192c3	95 89		sta $89,x			sta 	XS2_Mantissa+3,x
.0192c5	20 43 93	jsr $019343			jsr 	SubInteger32 				; subtraction
.0192c8	90 0d		bcc $0192d7			bcc 	_CI32Less 					; cc return -1
.0192ca	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check if zero
.0192cc	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.0192ce	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.0192d0	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.0192d2	f0 02		beq $0192d6			beq 	_CI32Exit
.0192d4	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.0192d6					_CI32Exit:
.0192d6	60		rts				rts
.0192d7					_CI32Less:
.0192d7	a9 ff		lda #$ff			lda 	#$FF
.0192d9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.0192da					BinaryOp_Add:
.0192da	b5 85		lda $85,x			lda 	XS_Type,x  					; and types together
.0192dc	35 8b		and $8b,x			and 	XS2_Type,x
.0192de	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.0192e0	d0 11		bne $0192f3			bne 	_BOAString
.0192e2	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.0192e4	35 8b		and $8b,x			and 	XS2_Type,x
.0192e6	4a		lsr a				lsr 	a 							; shift bit 0 into C
.0192e7	90 03		bcc $0192ec			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.0192e9	4c 29 93	jmp $019329			jmp 	AddInteger32 							; so execute code at \1
.0192ec					_BCFloat:
.0192ec	20 5d 93	jsr $01935d			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.0192ef	4c 9d 9e	jmp $019e9d			jmp 	FPAdd 							; and execute code at \2
.0192f2	60		rts				rts
.0192f3					_BOAString:
.0192f3	4c 77 93	jmp $019377			jmp 	ConcatenateString 			; concatenate two strings.
.0192f6					BinaryOp_Subtract:
.0192f6	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.0192f8	35 8b		and $8b,x			and 	XS2_Type,x
.0192fa	4a		lsr a				lsr 	a 							; shift bit 0 into C
.0192fb	90 03		bcc $019300			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.0192fd	4c 43 93	jmp $019343			jmp 	SubInteger32 							; so execute code at \1
.019300					_BCFloat:
.019300	20 5d 93	jsr $01935d			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.019303	4c 95 9e	jmp $019e95			jmp 	FPSubtract 							; and execute code at \2
.019306	60		rts				rts
.019307					BinaryOp_Multiply:
.019307	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.019309	35 8b		and $8b,x			and 	XS2_Type,x
.01930b	4a		lsr a				lsr 	a 							; shift bit 0 into C
.01930c	90 03		bcc $019311			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.01930e	4c 6e 9c	jmp $019c6e			jmp 	MulInteger32 							; so execute code at \1
.019311					_BCFloat:
.019311	20 5d 93	jsr $01935d			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.019314	4c c4 9f	jmp $019fc4			jmp 	FPMultiply 							; and execute code at \2
.019317	60		rts				rts
.019318					BinaryOp_Divide:
.019318	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.01931a	35 8b		and $8b,x			and 	XS2_Type,x
.01931c	4a		lsr a				lsr 	a 							; shift bit 0 into C
.01931d	90 03		bcc $019322			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.01931f	4c ac 9c	jmp $019cac			jmp 	DivInteger32 							; so execute code at \1
.019322					_BCFloat:
.019322	20 5d 93	jsr $01935d			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.019325	4c 51 9f	jmp $019f51			jmp 	FPDivide 							; and execute code at \2
.019328	60		rts				rts
.019329					AddInteger32:
.019329	18		clc				clc
.01932a	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01932c	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.01932e	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019330	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019332	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.019334	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019336	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019338	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.01933a	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01933c	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01933e	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.019340	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019342	60		rts				rts
.019343					SubInteger32:
.019343	38		sec				sec
.019344	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019346	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.019348	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01934a	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01934c	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.01934e	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019350	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019352	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.019354	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019356	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019358	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.01935a	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01935c	60		rts				rts
.01935d					BinaryMakeBothFloat:
.01935d	da		phx				phx 								; save X
.01935e	e8		inx				inx
.01935f	e8		inx				inx
.019360	e8		inx				inx
.019361	e8		inx				inx
.019362	e8		inx				inx
.019363	e8		inx				inx
.019364	20 68 93	jsr $019368			jsr 	BinaryMakeFloat 			; convert to float.
.019367	fa		plx				plx 								; restore X and fall through.
.019368					BinaryMakeFloat:
.019368	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.01936a	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.01936b	b0 04		bcs $019371			bcs 	_BMFConvert
.01936d	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.01936e	b0 04		bcs $019374			bcs 	_BMFError
.019370	60		rts				rts
.019371					_BMFConvert:
.019371	4c 7d a1	jmp $01a17d			jmp 	FPUToFloat 					; convert to float
.019374					_BMFError:
.019374	4c 2f 85	jmp $01852f			jmp 	TypeError
.019377					ConcatenateString:
.019377	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.019379	85 1a		sta $1a				sta		zLTemp1+0
.01937b	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01937d	85 1b		sta $1b				sta 	zLTemp1+1
.01937f	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.019381	85 1c		sta $1c				sta 	zLTemp1+2
.019383	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.019385	85 1d		sta $1d				sta 	zLTemp1+3
.019387	5a		phy				phy
.019388	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.01938a	b1 1a		lda ($1a),y			lda 	(zlTemp1),y
.01938c	71 1c		adc ($1c),y			adc 	(zlTemp1+2),y
.01938e	7a		ply				ply
.01938f	b0 33		bcs $0193c4			bcs 	_CSError					; check in range.
.019391	c9 fe		cmp #$fe			cmp 	#maxString+1
.019393	b0 2f		bcs $0193c4			bcs 	_CSError
.019395	20 0d 98	jsr $01980d			jsr 	AllocateTempString 			; store the result
.019398	20 af 93	jsr $0193af			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.01939b	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.01939d	85 1a		sta $1a				sta 	zLTemp1
.01939f	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.0193a1	85 1b		sta $1b				sta 	zLTemp1+1
.0193a3	20 af 93	jsr $0193af			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.0193a6	a5 20		lda $20				lda 	zTempStr 					; point current to new string
.0193a8	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0193aa	a5 21		lda $21				lda 	zTempStr+1
.0193ac	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0193ae	60		rts				rts
.0193af					_CSCopyString:
.0193af	da		phx				phx
.0193b0	5a		phy				phy
.0193b1	a0 00		ldy #$00			ldy 	#0 							; get length
.0193b3	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.0193b5	f0 0a		beq $0193c1			beq 	_CSCSExit 					; if zero, exit
.0193b7	aa		tax				tax 								; put in X
.0193b8					_CSCSLoop:
.0193b8	c8		iny				iny 								; get next char
.0193b9	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.0193bb	20 38 98	jsr $019838			jsr		WriteTempString 			; copy out
.0193be	ca		dex				dex 								; do whole string
.0193bf	d0 f7		bne $0193b8			bne 	_CSCSLoop
.0193c1					_CSCSExit:
.0193c1	7a		ply				ply
.0193c2	fa		plx				plx
.0193c3	60		rts				rts
.0193c4					_CSError:
.0193c4	20 4e 85	jsr $01854e			jsr ERR_Handler
>0193c7	53 74 72 69 6e 67 20 74			.text "String too long",0
>0193cf	6f 6f 20 6c 6f 6e 67 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.0193d7					Unary_Sgn:
.0193d7	20 7d 91	jsr $01917d			jsr 	EvaluateNumberX 			; get value
.0193da	20 cd 97	jsr $0197cd			jsr 	CheckNextRParen 			; check right bracket.
.0193dd	20 fb 93	jsr $0193fb			jsr 	GetSignCurrent 				; get sign.
.0193e0	09 00		ora #$00			ora 	#0
.0193e2	10 08		bpl $0193ec			bpl		UnarySetAInteger			; if 0,1 return that.
.0193e4	80 00		bra $0193e6			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.0193e6					UnarySetAMinus1:
.0193e6	a9 ff		lda #$ff			lda 	#$FF
.0193e8	95 80		sta $80,x			sta 	XS_Mantissa,x
.0193ea	80 04		bra $0193f0			bra 	UnarySetAFill
.0193ec					UnarySetAInteger:
.0193ec	95 80		sta $80,x			sta 	XS_Mantissa,x
.0193ee	a9 00		lda #$00			lda 	#0
.0193f0					UnarySetAFill:
.0193f0	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0193f2	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0193f4	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0193f6	a9 01		lda #$01			lda 	#1
.0193f8	95 85		sta $85,x			sta 	XS_Type,x
.0193fa	60		rts				rts
.0193fb					GetSignCurrent:
.0193fb	b5 85		lda $85,x			lda 	XS_Type,x 					; identify type.
.0193fd	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.0193fe	90 15		bcc $019415			bcc 	_GSCFloat
.019400	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019402	30 0e		bmi $019412			bmi 	_GSCMinus1
.019404	15 80		ora $80,x			ora 	XS_Mantissa+0,x
.019406	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019408	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01940a	d0 03		bne $01940f			bne 	_GSCPlus1
.01940c					_GSCZero:
.01940c	a9 00		lda #$00			lda 	#0
.01940e	60		rts				rts
.01940f					_GSCPlus1:
.01940f	a9 01		lda #$01			lda 	#$01
.019411	60		rts				rts
.019412					_GSCMinus1:
.019412	a9 ff		lda #$ff			lda 	#$FF
.019414	60		rts				rts
.019415					_GSCFloat:
.019415	34 85		bit $85,x			bit 	XS_Type,x
.019417	70 f3		bvs $01940c			bvs 	_GSCZero
.019419	30 f7		bmi $019412			bmi 	_GSCMinus1
.01941b	80 f2		bra $01940f			bra 	_GSCPlus1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.01941d					Unary_Abs:
.01941d	20 7d 91	jsr $01917d			jsr 	EvaluateNumberX 			; get value
.019420	20 cd 97	jsr $0197cd			jsr 	CheckNextRParen 			; check right bracket.
.019423	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.019425	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.019427	f0 07		beq $019430			beq 	_UAMinusFloat
.019429	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; check MSB
.01942b	10 09		bpl $019436			bpl 	_UAExit
.01942d	4c 33 9d	jmp $019d33			jmp 	IntegerNegateAlways 		; negation
.019430					_UAMinusFloat:
.019430	b5 85		lda $85,x			lda 	XS_Type,x 					; clear the sign bit.
.019432	29 7f		and #$7f			and		#$7F
.019434	95 85		sta $85,x			sta 	XS_Type,x
.019436					_UAExit:
.019436	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.019437					Unary_Peek:
.019437	a9 01		lda #$01			lda 	#1
.019439	80 06		bra $019441			bra 	UPMain
.01943b					Unary_Deek:
.01943b	a9 02		lda #$02			lda 	#2
.01943d	80 02		bra $019441			bra 	UPMain
.01943f					Unary_Leek:
.01943f	a9 04		lda #$04			lda 	#4
.019441					UPMain:
.019441	48		pha				pha 								; set bytes to copy.
.019442	20 8b 91	jsr $01918b			jsr 	EvaluateIntegerX 			; numeric parameter
.019445	20 cd 97	jsr $0197cd			jsr 	CheckNextRParen 			; right bracket.
.019448	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.01944a	85 1a		sta $1a				sta 	zLTemp1
.01944c	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01944e	85 1b		sta $1b				sta 	zLTemp1+1
.019450	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019452	85 1c		sta $1c				sta 	zLTemp1+2
.019454	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019456	85 1d		sta $1d				sta 	zLTemp1+3
.019458	a9 00		lda #$00			lda 	#0 							; clear target area
.01945a	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01945c	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01945e	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019460	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019462	68		pla				pla 								; restore bytes to copy
.019463	da		phx				phx 								; save XY
.019464	5a		phy				phy
.019465	20 4f 97	jsr $01974f			jsr 	MemRead 					; read the bytes in
.019468	7a		ply				ply 								; restore and exit
.019469	fa		plx				plx
.01946a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/pos.asm

.01946b					Unary_Pos:
.01946b	20 7d 91	jsr $01917d			jsr 	EvaluateNumberX 			; get value
.01946e	20 cd 97	jsr $0197cd			jsr 	CheckNextRParen 			; check right bracket.
.019471	20 1b 85	jsr $01851b			jsr 	CharGetPosition 			; get the position
.019474	4c ec 93	jmp $0193ec			jmp		UnarySetAInteger			; if 0,1 return that.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.019477					Unary_Mod:
.019477	20 9f 94	jsr $01949f			jsr 	_UMParameter 				; first parameter
.01947a	20 d5 97	jsr $0197d5			jsr 	CheckNextComma
.01947d	da		phx				phx 								; second parameter
.01947e	e8		inx				inx
.01947f	e8		inx				inx
.019480	e8		inx				inx
.019481	e8		inx				inx
.019482	e8		inx				inx
.019483	e8		inx				inx
.019484	20 9f 94	jsr $01949f			jsr 	_UMParameter
.019487	fa		plx				plx
.019488	20 cd 97	jsr $0197cd			jsr 	CheckNextRParen
.01948b	20 ac 9c	jsr $019cac			jsr 	DivInteger32 				; divide
.01948e	a5 1a		lda $1a				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.019490	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019492	a5 1b		lda $1b				lda 	zLTemp1+1
.019494	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019496	a5 1c		lda $1c				lda 	zLTemp1+2
.019498	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01949a	a5 1d		lda $1d				lda 	zLTemp1+3
.01949c	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01949e	60		rts				rts
.01949f					_UMParameter:
.01949f	20 8b 91	jsr $01918b			jsr 	EvaluateIntegerX 			; get value
.0194a2	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; absolute value
.0194a4	10 03		bpl $0194a9			bpl 	_UMNotSigned
.0194a6	20 33 9d	jsr $019d33			jsr 	IntegerNegateAlways
.0194a9					_UMNotSigned:
.0194a9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.0194aa					Unary_Usr:
.0194aa	20 7d 91	jsr $01917d			jsr 	EvaluateNumberX 			; numeric parameter
.0194ad	20 cd 97	jsr $0197cd			jsr 	CheckNextRParen 			; right bracket.
.0194b0	da		phx				phx 								; save XY
.0194b1	5a		phy				phy
.0194b2	ea		nop				nop
.0194b3	22 0c 03 00	jsl $00030c			jsl 	UserVector
.0194b7	7a		ply				ply 								; and exit
.0194b8	fa		plx				plx
.0194b9	60		rts				rts
.0194ba					USRDefault:
.0194ba	20 4e 85	jsr $01854e			jsr ERR_Handler
>0194bd	4e 6f 20 55 53 52 20 76			.text "No USR vector.",0
>0194c5	65 63 74 6f 72 2e 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.0194cc					Unary_Val:
.0194cc	20 94 91	jsr $019194			jsr 	EvaluateStringX 			; get string
.0194cf	20 cd 97	jsr $0197cd			jsr 	CheckNextRParen 			; check right bracket.
.0194d2	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.0194d4	85 1e		sta $1e				sta 	zGenPtr
.0194d6	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0194d8	85 1f		sta $1f				sta 	zGenPtr+1
.0194da	5a		phy				phy
.0194db	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.0194dd	b1 1e		lda ($1e),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.0194df	f0 54		beq $019535			beq 	_UVBadNumber
.0194e1	48		pha				pha 								; save length.
.0194e2	1a		inc a				inc 	a 							; one for the length, one for the terminator
.0194e3	1a		inc a				inc 	a
.0194e4	20 0d 98	jsr $01980d			jsr 	AllocateTempString
.0194e7	c8		iny				iny 								; move to the next.
.0194e8	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get character
.0194ea	49 2d		eor #$2d			eor 	#"-"						; zero if minus sign
.0194ec	8d a0 03	sta $03a0			sta 	ValSign
.0194ef	d0 04		bne $0194f5			bne 	_UVNotMinus
.0194f1	c8		iny				iny 								; skip over it.
.0194f2	68		pla				pla 								; decrement character count.
.0194f3	3a		dec a				dec 	a
.0194f4	48		pha				pha
.0194f5					_UVNotMinus:
.0194f5	68		pla				pla 								; this is the count.
.0194f6	48		pha		_UVCopy:pha									; copy into new temp string which is ASCIIZ
.0194f7	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.0194f9	c8		iny				iny
.0194fa	20 38 98	jsr $019838			jsr 	WriteTempString
.0194fd	68		pla				pla
.0194fe	3a		dec a				dec 	a
.0194ff	d0 f5		bne $0194f6			bne 	_UVCopy
.019501	20 38 98	jsr $019838			jsr 	WriteTempString 			; make it ASCIIZ
.019504	18		clc				clc
.019505	a5 20		lda $20				lda 	zTempStr 					; tempstring +1 => genptr
.019507	69 01		adc #$01			adc 	#1
.019509	85 1e		sta $1e				sta 	zGenPtr
.01950b	a5 21		lda $21				lda 	zTempStr+1
.01950d	69 00		adc #$00			adc 	#0
.01950f	85 1f		sta $1f				sta 	zGenPtr+1
.019511	18		clc				clc
.019512	20 05 9e	jsr $019e05			jsr 	IntFromString 				; first bit.
.019515	b0 1e		bcs $019535			bcs 	_UVBadNumber
.019517	20 83 a3	jsr $01a383			jsr 	FPFromString				; try for a float part.
.01951a	ad a0 03	lda $03a0			lda 	ValSign 					; was it negative
.01951d	d0 10		bne $01952f			bne 	_UVNotNegative
.01951f	b5 85		lda $85,x			lda 	XS_Type,x 					; check if integer
.019521	4a		lsr a				lsr 	a
.019522	b0 08		bcs $01952c			bcs 	_UVInteger
.019524	b5 85		lda $85,x			lda 	XS_Type,x 					; set sign bit
.019526	09 80		ora #$80			ora 	#$80
.019528	95 85		sta $85,x			sta 	XS_Type,x
.01952a	80 03		bra $01952f			bra 	_UVNotNegative
.01952c					_UVInteger:
.01952c	20 33 9d	jsr $019d33			jsr 	IntegerNegateAlways 		; sign it.
.01952f					_UVNotNegative:
.01952f	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; used everything
.019531	d0 02		bne $019535			bne 	_UVBadNumber
.019533	7a		ply				ply
.019534	60		rts				rts
.019535					_UVBadNumber:
.019535	4c 3d 85	jmp $01853d			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.019538					Unary_Str:
.019538	20 7d 91	jsr $01917d			jsr 	EvaluateNumberX 			; numeric parameter
.01953b	20 cd 97	jsr $0197cd			jsr 	CheckNextRParen 			; right bracket.
.01953e	a9 00		lda #$00			lda 	#0 							; reset buffer index
.019540	8d 14 03	sta $0314			sta 	NumBufX
.019543	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.019545	4a		lsr a				lsr 	a
.019546	b0 05		bcs $01954d			bcs 	_USInt 						; if msb set do as integer
.019548	20 c8 a2	jsr $01a2c8			jsr 	FPToString 					; call fp to str otherwise
.01954b	80 03		bra $019550			bra 	_USDuplicate
.01954d	20 50 9d	jsr $019d50	_USInt:	jsr 	IntToString
.019550					_USDuplicate:
.019550	ad 14 03	lda $0314			lda 	NumBufX 					; chars in buffer
.019553	1a		inc a				inc 	a 							; one more for length
.019554	20 0d 98	jsr $01980d			jsr 	AllocateTempString 			; allocate space for it.
.019557	5a		phy				phy 								; save Y
.019558	a0 00		ldy #$00			ldy 	#0 							; start copying
.01955a	b9 15 03	lda $0315,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.01955d	20 38 98	jsr $019838			jsr 	WriteTempString
.019560	c8		iny				iny
.019561	cc 14 03	cpy $0314			cpy 	NumBufX 					; done the lot
.019564	d0 f4		bne $01955a			bne 	_USCopy
.019566	7a		ply				ply 								; restore Y
.019567	4c 42 97	jmp $019742			jmp 	UnaryReturnTempStr 			; return new temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.01956a					Unary_Asc:
.01956a	20 94 91	jsr $019194			jsr 	EvaluateStringX 			; string parameter
.01956d	20 cd 97	jsr $0197cd			jsr 	CheckNextRParen 			; right bracket.
.019570	5a		phy				phy 								; get the string length
.019571	a0 00		ldy #$00			ldy 	#0
.019573	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.019575	f0 07		beq $01957e			beq 	_UAIllegal 					; must be at least one character
.019577	c8		iny				iny
.019578	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; read it.
.01957a	7a		ply				ply
.01957b	4c ec 93	jmp $0193ec			jmp 	UnarySetAInteger
.01957e					_UAIllegal:
.01957e	4c 3d 85	jmp $01853d			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.019581					Unary_Len:
.019581	20 94 91	jsr $019194			jsr 	EvaluateStringX 			; string parameter
.019584	20 cd 97	jsr $0197cd			jsr 	CheckNextRParen 			; right bracket.
.019587	5a		phy				phy 								; get the string length
.019588	a0 00		ldy #$00			ldy 	#0
.01958a	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.01958c	7a		ply				ply
.01958d	4c ec 93	jmp $0193ec			jmp 	UnarySetAInteger

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.019590					Unary_Mid:
.019590	20 94 91	jsr $019194			jsr 	EvaluateStringX 				; get string.
.019593	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.019595	48		pha				pha
.019596	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019598	48		pha				pha
.019599	20 d5 97	jsr $0197d5			jsr 	CheckNextComma 					; skip comma
.01959c	20 25 96	jsr $019625			jsr 	SLIByteParameter 				; get a byte parameter (start)
.01959f	48		pha				pha 									; and push it.
.0195a0	20 d5 97	jsr $0197d5			jsr 	CheckNextComma 					; skip comma
.0195a3	20 25 96	jsr $019625			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.0195a6	48		pha				pha 									; and push it.
.0195a7	80 41		bra $0195ea			bra 	SLIProcess
.0195a9					Unary_Left:
.0195a9	20 94 91	jsr $019194			jsr 	EvaluateStringX 				; get string.
.0195ac	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.0195ae	48		pha				pha
.0195af	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0195b1	48		pha				pha
.0195b2	a9 01		lda #$01			lda 	#1 								; push start position (1)
.0195b4	48		pha				pha
.0195b5	20 d5 97	jsr $0197d5			jsr 	CheckNextComma 					; skip comma
.0195b8	20 25 96	jsr $019625			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.0195bb	48		pha				pha 									; and push it.
.0195bc	80 2c		bra $0195ea			bra 	SLIProcess
.0195be					Unary_Right:
.0195be	20 94 91	jsr $019194			jsr 	EvaluateStringX 				; get string.
.0195c1	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.0195c3	48		pha				pha
.0195c4	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0195c6	48		pha				pha
.0195c7	da		phx				phx 									; get the string length and push on stack.
.0195c8	a2 00		ldx #$00			ldx 	#0
.0195ca	a1 1e		lda ($1e,x)			lda		(zGenPtr,x)
.0195cc	fa		plx				plx
.0195cd	48		pha				pha
.0195ce	20 d5 97	jsr $0197d5			jsr 	CheckNextComma 					; skip comma
.0195d1	20 25 96	jsr $019625			jsr 	SLIByteParameter 				; get a byte parameter.
.0195d4	8d 9e 03	sta $039e			sta 	SignCount 						; save in temporary.
.0195d7	68		pla				pla 									; restore string length.
.0195d8	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.0195d9	38		sec				sec
.0195da	ed 9e 03	sbc $039e			sbc 	SignCount 						; subtract characters needed, gives start position.
.0195dd	f0 02		beq $0195e1			beq 	_URStart 						; if <= 0 start from 1.
.0195df	10 02		bpl $0195e3			bpl 	_UROkay
.0195e1					_URStart:
.0195e1	a9 01		lda #$01			lda 	#1
.0195e3					_UROkay:
.0195e3	48		pha				pha 									; push start
.0195e4	ad 9e 03	lda $039e			lda 	SignCount 						; push count of characters
.0195e7	48		pha				pha
.0195e8	80 00		bra $0195ea			bra 	SLIProcess
.0195ea					SLIProcess:
.0195ea	20 cd 97	jsr $0197cd			jsr 	CheckNextRParen 				; closing right bracket.
.0195ed	68		pla				pla
.0195ee	8d a2 03	sta $03a2			sta 	SliceCount 						; count in signcount
.0195f1	1a		inc a				inc 	a 								; allocate +1 for it.
.0195f2	20 0d 98	jsr $01980d			jsr 	AllocateTempString
.0195f5	68		pla				pla 									; pop start number off stack.
.0195f6	f0 3b		beq $019633			beq 	SLIError 						; exit if start = 0
.0195f8	8d a1 03	sta $03a1			sta 	SliceStart
.0195fb	68		pla				pla  									; pop string address.
.0195fc	85 1f		sta $1f				sta 	zGenPtr+1
.0195fe	68		pla				pla
.0195ff	85 1e		sta $1e				sta 	zGenPtr
.019601	da		phx				phx
.019602	5a		phy				phy
.019603	a2 00		ldx #$00			ldx 	#0 								; point to string length.
.019605	ac a1 03	ldy $03a1			ldy 	SliceStart 						; start of the string (+1 for count)
.019608					_SLICopy:
.019608	ad a2 03	lda $03a2			lda 	SliceCount 						; done count characters
.01960b	f0 12		beq $01961f			beq 	_SLIExit
.01960d	ce a2 03	dec $03a2			dec 	SliceCount
.019610	98		tya				tya 									; index of character
.019611	c1 1e		cmp ($1e,x)			cmp 	(zGenPtr,x)						; compare against length
.019613	f0 02		beq $019617			beq 	_SLIOk 							; if equal, okay.
.019615	b0 08		bcs $01961f			bcs 	_SLIExit 						; if past end, then exit.
.019617	b1 1e		lda ($1e),y	_SLIOk:	lda 	(zGenPtr),y 					; copy one character
.019619	c8		iny				iny
.01961a	20 38 98	jsr $019838			jsr 	WriteTempString
.01961d	80 e9		bra $019608			bra 	_SLICopy 						; go round till copied characters
.01961f					_SLIExit:
.01961f	7a		ply				ply 									; restore YX
.019620	fa		plx				plx
.019621	4c 42 97	jmp $019742			jmp 	UnaryReturnTempStr 				; return new temporary string.
.019624	ea		nop				nop
.019625					SLIByteParameter:
.019625	20 8b 91	jsr $01918b			jsr 	EvaluateIntegerX 				; get integer
.019628	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.01962a	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01962c	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01962e	d0 03		bne $019633			bne 	SLIError
.019630	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019632	60		rts				rts
.019633					SLIError:
.019633	4c 3d 85	jmp $01853d			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.019636					Unary_Hex:
.019636	20 8b 91	jsr $01918b			jsr 	EvaluateIntegerX 			; numeric parameter
.019639	20 cd 97	jsr $0197cd			jsr 	CheckNextRParen 			; right bracket.
.01963c	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.01963e	20 0d 98	jsr $01980d			jsr 	AllocateTempString			; allocate string space
.019641	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.019643	20 67 96	jsr $019667			jsr 	_UHConvert
.019646	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019648	20 67 96	jsr $019667			jsr 	_UHConvert
.01964b	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01964d	20 67 96	jsr $019667			jsr 	_UHConvert
.019650	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019652	20 67 96	jsr $019667			jsr 	_UHConvert
.019655	5a		phy				phy 								; get length of new string
.019656	a0 00		ldy #$00			ldy 	#0
.019658	b1 20		lda ($20),y			lda 	(zTempStr),y
.01965a	7a		ply				ply
.01965b	c9 00		cmp #$00			cmp 	#0
.01965d	d0 05		bne $019664			bne 	_UHExit 					; if it was non zero okay
.01965f	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.019661	20 38 98	jsr $019838			jsr 	WriteTempString
.019664					_UHExit:
.019664	4c 42 97	jmp $019742			jmp 	UnaryReturnTempStr 			; return new temporary string.
.019667					_UHConvert:
.019667	48		pha				pha
.019668	4a		lsr a				lsr 	a 							; do MSB
.019669	4a		lsr a				lsr 	a
.01966a	4a		lsr a				lsr 	a
.01966b	4a		lsr a				lsr 	a
.01966c	20 70 96	jsr $019670			jsr 	_UHNibble
.01966f	68		pla				pla 								; do LSB
.019670					_UHNibble:
.019670	29 0f		and #$0f			and 	#15 						; get nibble
.019672	d0 0c		bne $019680			bne 	_UHNonZero
.019674	5a		phy				phy									; get the length
.019675	a0 00		ldy #$00			ldy 	#0
.019677	b1 20		lda ($20),y			lda 	(zTempStr),y
.019679	7a		ply				ply
.01967a	c9 00		cmp #$00			cmp 	#0 							; suppress leading zeros.
.01967c	f0 0d		beq $01968b			beq 	_UHExit2
.01967e	a9 00		lda #$00			lda 	#0
.019680					_UHNonZero:
.019680	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.019682	90 02		bcc $019686			bcc 	_UHDigit
.019684	69 06		adc #$06			adc 	#7-1
.019686					_UHDigit:
.019686	69 30		adc #$30			adc 	#48
.019688	20 38 98	jsr $019838			jsr 	WriteTempString				; output.
.01968b					_UHExit2:
.01968b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.01968c					Unary_Dec:
.01968c	20 94 91	jsr $019194			jsr 	EvaluateStringX 			; string parameter
.01968f	20 cd 97	jsr $0197cd			jsr 	CheckNextRParen 			; right bracket.
.019692	5a		phy				phy
.019693	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.019695	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.019697	f0 41		beq $0196da			beq 	_UDFail 					; must fail if zero.
.019699	8d 9e 03	sta $039e			sta 	SignCount 					; use SignCount as a counter
.01969c	a9 00		lda #$00			lda 	#0 							; set result to zero integer.
.01969e	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0196a0	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0196a2	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0196a4	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0196a6	a9 01		lda #$01			lda 	#1
.0196a8	95 85		sta $85,x			sta 	XS_Type,x
.0196aa					_UDConvertLoop:
.0196aa	5a		phy				phy 								; shift mantissa left 4
.0196ab	a0 04		ldy #$04			ldy 	#4
.0196ad					_UDShift:
.0196ad	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.0196af	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.0196b1	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.0196b3	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.0196b5	88		dey				dey
.0196b6	d0 f5		bne $0196ad			bne 	_UDShift
.0196b8	7a		ply				ply
.0196b9	c8		iny				iny 								; next character
.0196ba	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; fetch it.
.0196bc	20 dd 96	jsr $0196dd			jsr 	ConvertUpper 				; convert to U/C
.0196bf	c9 30		cmp #$30			cmp 	#"0"
.0196c1	90 17		bcc $0196da			bcc 	_UDFail
.0196c3	c9 3a		cmp #$3a			cmp 	#"9"+1
.0196c5	90 06		bcc $0196cd			bcc 	_UDOkay
.0196c7	e9 37		sbc #$37			sbc 	#7+"0" 						; alpha fudge
.0196c9	c9 10		cmp #$10			cmp 	#16
.0196cb	b0 0d		bcs $0196da			bcs 	_UDFail
.0196cd					_UDOkay:
.0196cd	29 0f		and #$0f			and 	#15 						; nibble only
.0196cf	15 80		ora $80,x			ora 	XS_Mantissa+0,x
.0196d1	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0196d3	ce 9e 03	dec $039e			dec 	SignCount 					; do it for each character
.0196d6	d0 d2		bne $0196aa			bne 	_UDConvertLoop
.0196d8	7a		ply				ply
.0196d9	60		rts				rts
.0196da					_UDFail:
.0196da	4c 3d 85	jmp $01853d			jmp 	BadParamError
.0196dd					ConvertUpper:
.0196dd	c9 61		cmp #$61			cmp 	#"a"
.0196df	90 07		bcc $0196e8			bcc 	_CUExit
.0196e1	c9 7b		cmp #$7b			cmp 	#"z"+1
.0196e3	b0 03		bcs $0196e8			bcs 	_CUExit
.0196e5	38		sec				sec
.0196e6	e9 20		sbc #$20			sbc 	#32
.0196e8	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.0196e9					Unary_Chr:
.0196e9	20 8b 91	jsr $01918b			jsr 	EvaluateIntegerX			; numeric parameter
.0196ec	20 cd 97	jsr $0197cd			jsr 	CheckNextRParen 			; right bracket.
.0196ef	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.0196f1	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.0196f3	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.0196f5	d0 0d		bne $019704			bne 	_UCChar
.0196f7	a9 01		lda #$01			lda 	#1 							; one character string
.0196f9	20 0d 98	jsr $01980d			jsr 	AllocateTempString
.0196fc	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.0196fe	20 38 98	jsr $019838			jsr 	WriteTempString
.019701	4c 42 97	jmp $019742			jmp 	UnaryReturnTempStr
.019704					_UCChar:
.019704	4c 3d 85	jmp $01853d			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.019707					Unary_Spc:
.019707	20 25 96	jsr $019625			jsr 	SLIByteParameter 			; check space.
.01970a	20 cd 97	jsr $0197cd			jsr 	CheckNextRParen
.01970d	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01970f					UnarySpcCreate:
.01970f	c9 fe		cmp #$fe			cmp 	#maxString+1
.019711	b0 14		bcs $019727			bcs 	_USSize
.019713	48		pha				pha 								; save length
.019714	1a		inc a				inc 	a 							; allocate one more.
.019715	20 0d 98	jsr $01980d			jsr 	AllocateTempString
.019718	68		pla				pla 								; get length
.019719	f0 27		beq $019742			beq 	UnaryReturnTempStr 			; return the current temp string
.01971b					_USLoop:
.01971b	48		pha				pha
.01971c	a9 20		lda #$20			lda 	#" "
.01971e	20 38 98	jsr $019838			jsr 	WriteTempString
.019721	68		pla				pla
.019722	3a		dec a				dec 	a
.019723	d0 f6		bne $01971b			bne 	_USLoop
.019725	80 1b		bra $019742			bra 	UnaryReturnTempStr
.019727					_USSize:
.019727	4c 3d 85	jmp $01853d			jmp 	BadParamError
.01972a					Unary_Tab:
.01972a	a2 00		ldx #$00			ldx 	#0 							; required TAB position.
.01972c	20 25 96	jsr $019625			jsr 	SLIByteParameter
.01972f	20 cd 97	jsr $0197cd			jsr 	CheckNextRParen
.019732	20 1b 85	jsr $01851b			jsr 	CharGetPosition 			; were are we ?
.019735	85 10		sta $10				sta 	zTemp1
.019737	38		sec				sec
.019738	a5 80		lda $80				lda 	XS_Mantissa+0 				; return chars required.
.01973a	e5 10		sbc $10				sbc 	zTemp1
.01973c	b0 d1		bcs $01970f			bcs 	UnarySpcCreate
.01973e	a9 00		lda #$00			lda 	#0
.019740	80 cd		bra $01970f			bra 	UnarySpcCreate
.019742					UnaryReturnTempStr:
.019742	a5 20		lda $20				lda 	zTempStr 					; copy temp string addr -> mantissa
.019744	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019746	a5 21		lda $21				lda 	zTempStr+1
.019748	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01974a	a9 02		lda #$02			lda 	#2 							; set type to string
.01974c	95 85		sta $85,x			sta 	XS_Type,x
.01974e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/65816.asm

.01974f					MemRead:
.01974f	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.019752	a0 00		ldy #$00			ldy 	#0 							; start from here
.019754	b7 1a		lda [$1a],y	_MLoop1:lda 	[zlTemp1],y 				; read the long address
.019756	95 80		sta $80,x			sta 	XS_Mantissa,x 				; copy into mantissa
.019758	c8		iny				iny 								; next to copy
.019759	e8		inx				inx
.01975a	cc 9e 03	cpy $039e			cpy 	SignCount 					; do required # of bytes.
.01975d	d0 f5		bne $019754			bne 	_MLoop1
.01975f	60		rts				rts
.019760					MemWrite:
.019760	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.019763	a0 00		ldy #$00			ldy 	#0 							; start from here
.019765	b5 80		lda $80,x	_MLoop1:lda 	XS_Mantissa,x 				; read mantisssa
.019767	97 1a		sta [$1a],y			sta 	[zlTemp1],y 				; write it out
.019769	c8		iny				iny 								; next to copy
.01976a	e8		inx				inx
.01976b	cc 9e 03	cpy $039e			cpy 	SignCount 					; do required # of bytes.
.01976e	d0 f5		bne $019765			bne 	_MLoop1
.019770	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/programend.asm

.019771					UpdateProgramEnd:
.019771	a9 00		lda #$00			lda 	#BasicProgram & $FF
.019773	85 16		sta $16				sta 	zCodePtr+0
.019775	a9 10		lda #$10			lda 	#BasicProgram >> 8
.019777	85 17		sta $17				sta 	zCodePtr+1
.019779	a9 00		lda #$00			lda 	#0
.01977b	85 18		sta $18				sta 	zCodePtr+2
.01977d	85 19		sta $19				sta 	zCodePtr+3
.01977f	a0 03		ldy #$03			ldy 	#3
.019781					_UPDLoop:
.019781	a0 00		ldy #$00			ldy 	#0
.019783	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019785	c9 00		cmp #$00			cmp 	#0 							; end if offset is zero.
.019787	f0 0f		beq $019798			beq 	_UPDFoundEnd
.019789	a0 00		ldy #$00			ldy 	#0 							; point to offset
.01978b	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.01978d	18		clc				clc
.01978e	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.019790	85 16		sta $16				sta 	zCodePtr
.019792	90 02		bcc $019796			bcc 	_SNLNoCarry
.019794	e6 17		inc $17				inc 	zCodePtr+1
.019796					_SNLNoCarry:
.019796	80 e9		bra $019781			bra 	_UPDLoop
.019798					_UPDFoundEnd:
.019798	18		clc				clc 								; end of program 2 on.
.019799	a5 16		lda $16				lda 	zCodePtr
.01979b	69 02		adc #$02			adc 	#2
.01979d	8d 04 03	sta $0304			sta 	endOfProgram
.0197a0	a5 17		lda $17				lda 	zCodePtr+1
.0197a2	69 00		adc #$00			adc 	#0
.0197a4	8d 05 03	sta $0305			sta 	endOfProgram+1
.0197a7	a5 18		lda $18				lda 	zCodePtr+2
.0197a9	69 00		adc #$00			adc		#0
.0197ab	8d 06 03	sta $0306			sta 	endOfProgram+2
.0197ae	a5 19		lda $19				lda 	zCodePtr+3
.0197b0	69 00		adc #$00			adc 	#0
.0197b2	8d 07 03	sta $0307			sta 	endOfProgram+3
.0197b5	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.0197b6					CheckNextToken:
.0197b6	d7 16		cmp [$16],y			cmp 	[zCodePtr],y
.0197b8	d0 02		bne $0197bc			bne 	CTFail 						; no, then fail
.0197ba	c8		iny				iny
.0197bb	60		rts				rts
.0197bc					CTFail:
.0197bc	20 4e 85	jsr $01854e			jsr ERR_Handler
>0197bf	4d 69 73 73 69 6e 67 20			.text "Missing token",0
>0197c7	74 6f 6b 65 6e 00
.0197cd					CheckNextRParen:
.0197cd	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0197cf	c9 be		cmp #$be			cmp 	#token_rparen
.0197d1	d0 e9		bne $0197bc			bne 	CTFail
.0197d3	c8		iny				iny
.0197d4	60		rts				rts
.0197d5					CheckNextComma:
.0197d5	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0197d7	c9 bf		cmp #$bf			cmp 	#token_comma
.0197d9	d0 e1		bne $0197bc			bne 	CTFail
.0197db	c8		iny				iny
.0197dc	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/concrete.asm

.0197dd					StringConcrete:
.0197dd	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; save source to zTemp1
.0197df	85 10		sta $10				sta 	zTemp1
.0197e1	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0197e3	85 11		sta $11				sta 	zTemp1+1
.0197e5	a0 00		ldy #$00			ldy 	#0 							; subtract the length+1 (clc) of the string.
.0197e7	18		clc				clc 								; from the string pointer
.0197e8	ad 00 03	lda $0300			lda 	StringPtr 					; and put in zTemp2 as well
.0197eb	f1 10		sbc ($10),y			sbc 	(zTemp1),y
.0197ed	8d 00 03	sta $0300			sta 	StringPtr
.0197f0	85 12		sta $12				sta 	zTemp2
.0197f2	ad 01 03	lda $0301			lda 	StringPtr+1
.0197f5	e9 00		sbc #$00			sbc 	#0
.0197f7	8d 01 03	sta $0301			sta 	StringPtr+1
.0197fa	85 13		sta $13				sta 	zTemp2+1
.0197fc	b1 10		lda ($10),y			lda 	(zTemp1),y 					; length add one for count
.0197fe	1a		inc a				inc 	a
.0197ff	aa		tax				tax
.019800	b1 10		lda ($10),y	_SCCopy:lda 	(zTemp1),y 					; copy whole thing including length
.019802	91 12		sta ($12),y			sta 	(zTemp2),y
.019804	c8		iny				iny
.019805	ca		dex				dex
.019806	d0 f8		bne $019800			bne 	_SCCopy
.019808	a5 13		lda $13				lda 	zTemp2+1 					; return concrete string in AX
.01980a	a6 12		ldx $12				ldx 	zTemp2
.01980c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.01980d					AllocateTempString:
.01980d	48		pha				pha 								; save required count.
.01980e	a5 21		lda $21				lda 	zTempStr+1 					; check if initialised yet ?
.019810	d0 0b		bne $01981d			bne 	_ATSInitialised
.019812	ad 00 03	lda $0300			lda 	StringPtr 					; set temporary string ptr 1 page below available
.019815	85 20		sta $20				sta 	zTempStr					; space, this is for strings to be concreted.
.019817	ad 01 03	lda $0301			lda 	StringPtr+1
.01981a	3a		dec a				dec 	a
.01981b	85 21		sta $21				sta 	zTempStr+1
.01981d					_ATSInitialised:
.01981d	68		pla				pla 								; get required count back.
.01981e	49 ff		eor #$ff			eor 	#$FF 						; negate 2's complement.
.019820	1a		inc a				inc 	a
.019821	18		clc				clc
.019822	65 20		adc $20				adc 	zTempStr 					; "add" to the temp string pointer
.019824	85 20		sta $20				sta 	zTempStr
.019826	a9 ff		lda #$ff			lda 	#$FF
.019828	65 21		adc $21				adc 	zTempStr+1
.01982a	85 21		sta $21				sta 	zTempStr+1
.01982c	a9 00		lda #$00			lda 	#0 							; clear temp string.
.01982e	5a		phy				phy
.01982f	a8		tay				tay
.019830	91 20		sta ($20),y			sta 	(zTempStr),y
.019832	7a		ply				ply
.019833	1a		inc a				inc 	a 							; reset the write index.
.019834	8d 9f 03	sta $039f			sta 	TempStringWriteIndex
.019837	60		rts				rts
.019838					WriteTempString:
.019838	5a		phy				phy 								; save Y
.019839	ac 9f 03	ldy $039f			ldy 	TempStringWriteIndex	 	; write position.
.01983c	91 20		sta ($20),y			sta 	(zTempStr),y 				; write character out.
.01983e	ee 9f 03	inc $039f			inc 	TempStringWriteIndex 		; increment the write position.
.019841	98		tya				tya 								; unchanged Y is now length
.019842	a0 00		ldy #$00			ldy 	#0
.019844	91 20		sta ($20),y			sta 	(zTempStr),y
.019846	7a		ply				ply 								; restore Y and exit
.019847	60		rts				rts
.019848					CreateTempStringCopy:
.019848	da		phx				phx 								; save X
.019849	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01984b	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.01984c	20 0d 98	jsr $01980d			jsr 	AllocateTempString 			; allocate memory for temporary string.
.01984f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019851	c8		iny				iny
.019852	3a		dec a				dec 	a 							; make the actual length in charactes
.019853	3a		dec a				dec 	a
.019854	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.019856	81 20		sta ($20,x)			sta 	(zTempStr,x)
.019858	85 1a		sta $1a				sta 	zLTemp1 					; that's used as a count.
.01985a	09 00		ora #$00			ora 	#0 							; if zero already, exit
.01985c	f0 0e		beq $01986c			beq 	_CTSCExit
.01985e					_CTSCLoop:
.01985e	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019860	c8		iny				iny
.019861	5a		phy				phy 								; save in Y
.019862	e8		inx				inx 								; bump index
.019863	da		phx				phx 								; index into Y
.019864	7a		ply				ply
.019865	91 20		sta ($20),y			sta 	(zTempStr),y 				; save at index
.019867	7a		ply				ply 								; restore Y
.019868	c6 1a		dec $1a				dec 	zLTemp1 					; do for each character
.01986a	d0 f2		bne $01985e			bne 	_CTSCLoop
.01986c					_CTSCExit:
.01986c	fa		plx				plx 								; restore X
.01986d	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/variables.asm

.01986e					VariableFind:
.01986e	20 d9 98	jsr $0198d9			jsr 	VariableExtract 		; find out all about it ....
.019871	20 72 9b	jsr $019b72			jsr 	VariableLocate 			; does it already exist ?
.019874	b0 03		bcs $019879			bcs 	_VFExists 				; if so, use that.
.019876	20 65 99	jsr $019965			jsr 	VariableCreate 			; otherwise create it.
.019879					_VFExists:
.019879	a5 24		lda $24				lda 	zVarType 				; is it still an array ?
.01987b	29 01		and #$01			and 	#1
.01987d	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.01987f	d0 28		bne $0198a9			bne 	_VFSingleElement
.019881					_VFNextIndex:
.019881	a5 22		lda $22				lda 	zVarDataPtr 			; push the data ptr and type on the stack.
.019883	48		pha				pha
.019884	a5 23		lda $23				lda 	zVarDataPtr+1
.019886	48		pha				pha
.019887	a5 24		lda $24				lda 	zVarType
.019889	48		pha				pha
.01988a	20 8b 91	jsr $01918b			jsr 	EvaluateIntegerX 		; calculate the index.
.01988d	68		pla				pla 							; restore and index.
.01988e	85 24		sta $24				sta 	zVarType
.019890	68		pla				pla
.019891	85 23		sta $23				sta 	zVarDataPtr+1
.019893	68		pla				pla
.019894	85 22		sta $22				sta 	zVarDataPtr
.019896	20 f0 99	jsr $0199f0			jsr 	ArrayIndexFollow 		; do the index.
.019899	a5 24		lda $24				lda 	zVarType 				; is it still an array ??
.01989b	29 01		and #$01			and 	#1
.01989d	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.01989f	d0 05		bne $0198a6			bne 	_VFArrayDone 			; if so then exit.
.0198a1	20 d5 97	jsr $0197d5			jsr 	CheckNextComma 			; comma should follow
.0198a4	80 db		bra $019881			bra 	_VFNextIndex
.0198a6					_VFArrayDone:
.0198a6	20 cd 97	jsr $0197cd			jsr 	CheckNextRParen 		; check closing right bracket.
.0198a9					_VFSingleElement:
.0198a9	60		rts				rts
.0198aa					VariableClear:
.0198aa	48		pha				pha 							; save registers
.0198ab	da		phx				phx
.0198ac	a2 00		ldx #$00			ldx 	#0 						; clear out the hash table.
.0198ae	8a		txa				txa
.0198af	9d 35 03	sta $0335,x	_VCLoop:sta 	HashTableBase,x
.0198b2	e8		inx				inx
.0198b3	e0 60		cpx #$60			cpx 	#HashTableEnd-HashTableBase
.0198b5	d0 f8		bne $0198af			bne 	_VCLoop
.0198b7	a9 00		lda #$00			lda 	#VariableMemory & $FF
.0198b9	8d 02 03	sta $0302			sta 	VarMemPtr
.0198bc	a9 30		lda #$30			lda 	#VariableMemory >> 8
.0198be	8d 03 03	sta $0303			sta 	VarMemPtr+1
.0198c1	fa		plx				plx 							; restore registers
.0198c2	68		pla				pla
.0198c3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/extract.asm

.0198c4					VariableNameError:
.0198c4	20 4e 85	jsr $01854e			jsr ERR_Handler
>0198c7	42 61 64 20 56 61 72 69			.text "Bad Variable Name",0
>0198cf	61 62 6c 65 20 4e 61 6d 65 00
.0198d9					VariableExtract:
.0198d9	da		phx				phx 							; save X.
.0198da	a9 ba		lda #$ba			lda 	#token_hashlParen  		; set the type to #( e.g. real array.
.0198dc	8d 95 03	sta $0395			sta 	Var_Type
.0198df	8d 96 03	sta $0396			sta 	Var_Hash 				; we initialise the hash with this. It doesn't matter
.0198e2	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0198e4	c9 00		cmp #$00			cmp 	#0 						; first one must be A-Z
.0198e6	f0 dc		beq $0198c4			beq 	VariableNameError
.0198e8	c9 1b		cmp #$1b			cmp 	#26+1
.0198ea	b0 d8		bcs $0198c4			bcs 	VariableNameError
.0198ec	a2 ff		ldx #$ff			ldx 	#255 					; now copy it into the variable buffer.
.0198ee					_VECopyBuffer:
.0198ee	e8		inx				inx
.0198ef	e0 1f		cpx #$1f			cpx 	#31 					; too long
.0198f1	f0 d1		beq $0198c4			beq 	VariableNameError
.0198f3	9d 15 03	sta $0315,x			sta 	Var_Buffer,x 			; save character
.0198f6	18		clc				clc  							; update the hash value for it.
.0198f7	6d 96 03	adc $0396			adc 	Var_Hash
.0198fa	8d 96 03	sta $0396			sta 	Var_Hash
.0198fd	c8		iny				iny
.0198fe	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019900	c9 00		cmp #$00			cmp 	#0 						; zero or token, end of variable
.019902	f0 0e		beq $019912			beq 	_VECopyEnd
.019904	30 0c		bmi $019912			bmi 	_VECopyEnd
.019906	c9 1b		cmp #$1b			cmp 	#26+1 					; A-Z continue copying
.019908	90 e4		bcc $0198ee			bcc 	_VECopyBuffer
.01990a	c9 30		cmp #$30			cmp 	#"0" 					; 0-9 copy as well.
.01990c	90 04		bcc $019912			bcc 	_VECopyEnd
.01990e	c9 3a		cmp #$3a			cmp 	#"9"+1
.019910	90 dc		bcc $0198ee			bcc 	_VECopyBuffer
.019912					_VECopyEnd:
.019912	c8		iny				iny
.019913	c9 b7		cmp #$b7			cmp 	#token_Dollar 			; first type token.
.019915	90 04		bcc $01991b			bcc 	_VEDefaultRequired
.019917	c9 bd		cmp #$bd			cmp 	#token_PercentLParen+1	; last type token.
.019919	90 0b		bcc $019926			bcc 	_VEHaveType
.01991b					_VEDefaultRequired:
.01991b	c9 bd		cmp #$bd			cmp 	#token_LParen 			; if it ends in ( then use the real array
.01991d	f0 04		beq $019923			beq 	_VESetType 				; default set above.
.01991f	ce 95 03	dec $0395			dec 	Var_Type 				; this changes that default to the variable default
.019922	88		dey				dey
.019923					_VESetType:
.019923	ad 95 03	lda $0395			lda 	Var_Type 				; get type ....
.019926					_VEHaveType:
.019926	8d 95 03	sta $0395			sta 	Var_Type 				; save as type.
.019929	bd 15 03	lda $0315,x			lda 	Var_Buffer,x 			; set bit 7 of name, marks the end.
.01992c	09 80		ora #$80			ora 	#$80
.01992e	9d 15 03	sta $0315,x			sta 	Var_Buffer,x
.019931	e8		inx				inx 							; offset 3 => length 4.
.019932	8e 97 03	stx $0397			stx 	Var_Length 				; save length of variable name.
.019935	ad 95 03	lda $0395			lda 	Var_Type 				; get offset of var type from first type token
.019938	38		sec				sec
.019939	e9 b7		sbc #$b7			sbc 	#token_Dollar
.01993b	0a		asl a				asl 	a 						; multiply by 16. This requires HashTableSize
.01993c	0a		asl a				asl 	a 						; in data.asm to be 8 (8 sets of links,2 bytes each)
.01993d	0a		asl a				asl 	a
.01993e	0a		asl a				asl 	a
.01993f	8d 98 03	sta $0398			sta 	Var_HashAddress
.019942	ad 96 03	lda $0396			lda 	Var_Hash 				; get the hash
.019945	29 07		and #$07			and 	#(HashTableSize-1) 		; force into range 0-tableSize-1
.019947	0a		asl a				asl 	a 						; double it (2 bytes per entry) & clears carry
.019948	6d 98 03	adc $0398			adc 	Var_HashAddress 		; add table offset.
.01994b	69 35		adc #$35			adc 	#HashTableBase & $FF 	; now the low byte of the actual table address
.01994d	8d 98 03	sta $0398			sta 	Var_HashAddress
.019950	a2 05		ldx #$05			ldx 	#5 						; hash is 5 bytes (real)
.019952	ad 95 03	lda $0395			lda 	Var_Type
.019955	c9 b9		cmp #$b9			cmp 	#token_Hash
.019957	f0 07		beq $019960			beq 	_VEHaveSize
.019959	ca		dex				dex
.01995a	c9 bb		cmp #$bb			cmp 	#token_Percent 			; percent is 4 bytes (integer)
.01995c	f0 02		beq $019960			beq 	_VEHaveSize
.01995e	a2 02		ldx #$02			ldx 	#2 						; everything else is two.
.019960					_VEHaveSize:
.019960	8e 99 03	stx $0399			stx 	Var_DataSize
.019963	fa		plx				plx
.019964	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varcreate.asm

.019965					VariableCreate:
.019965	da		phx				phx
.019966	5a		phy				phy
.019967	ad 02 03	lda $0302			lda 	VarMemPtr 					; get address of next free into zTemp1
.01996a	85 10		sta $10				sta 	zTemp1
.01996c	ad 03 03	lda $0303			lda 	VarMemPtr+1
.01996f	85 11		sta $11				sta 	zTemp1+1
.019971	ad 99 03	lda $0399			lda 	Var_DataSize 				; bytes for the data bit
.019974	18		clc				clc
.019975	6d 97 03	adc $0397			adc 	Var_Length 					; add the length of the name
.019978	69 03		adc #$03			adc 	#3 							; 3 for the link and the hash.
.01997a	6d 02 03	adc $0302			adc 	VarMemPtr 					; add to variable memory pointer
.01997d	8d 02 03	sta $0302			sta 	VarMemPtr
.019980	90 03		bcc $019985			bcc 	_VCNoCarry
.019982	ee 03 03	inc $0303			inc 	VarMemPtr+1
.019985					_VCNoCarry:
.019985	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.019988	85 12		sta $12				sta 	zTemp2
.01998a	a9 03		lda #$03			lda 	#HashTableBase >> 8
.01998c	85 13		sta $13				sta 	zTemp2+1
.01998e	a0 00		ldy #$00			ldy 	#0 							; put current hash link in position.
.019990	b1 12		lda ($12),y			lda 	(zTemp2),y
.019992	91 10		sta ($10),y			sta 	(zTemp1),y
.019994	c8		iny				iny
.019995	b1 12		lda ($12),y			lda 	(zTemp2),y
.019997	91 10		sta ($10),y			sta 	(zTemp1),y
.019999	c8		iny				iny
.01999a	ad 96 03	lda $0396			lda 	Var_Hash 					; write the hash out.
.01999d	91 10		sta ($10),y			sta 	(zTemp1),y
.01999f	c8		iny				iny
.0199a0	a2 00		ldx #$00			ldx 	#0 							; copy the name out.
.0199a2					_VCCopyName:
.0199a2	bd 15 03	lda $0315,x			lda 	Var_Buffer,x
.0199a5	91 10		sta ($10),y			sta 	(zTemp1),y
.0199a7	e8		inx				inx
.0199a8	c8		iny				iny
.0199a9	ec 97 03	cpx $0397			cpx 	Var_Length
.0199ac	d0 f4		bne $0199a2			bne 	_VCCopyName
.0199ae	5a		phy				phy 								; save the data offset.
.0199af	ae 99 03	ldx $0399			ldx 	Var_DataSize 				; and write the data out.
.0199b2	a9 00		lda #$00			lda 	#0 							; which is all zeroes.
.0199b4					_VCClearData:
.0199b4	91 10		sta ($10),y			sta 	(zTemp1),y
.0199b6	c8		iny				iny
.0199b7	ca		dex				dex
.0199b8	d0 fa		bne $0199b4			bne 	_VCClearData
.0199ba	68		pla				pla 								; offset to the data
.0199bb	18		clc				clc
.0199bc	65 10		adc $10				adc 	zTemp1 						; add to start and save as data pointer.
.0199be	85 22		sta $22				sta 	zVarDataPtr
.0199c0	a5 11		lda $11				lda 	zTemp1+1
.0199c2	69 00		adc #$00			adc 	#0
.0199c4	85 23		sta $23				sta 	zVarDataPtr+1
.0199c6	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.0199c9	85 24		sta $24				sta 	zVarType
.0199cb	a5 10		lda $10				lda 	zTemp1 						; fix hash link to point to new record
.0199cd	a0 00		ldy #$00			ldy 	#0
.0199cf	91 12		sta ($12),y			sta 	(zTemp2),y
.0199d1	c8		iny				iny
.0199d2	a5 11		lda $11				lda 	zTemp1+1
.0199d4	91 12		sta ($12),y			sta 	(zTemp2),y
.0199d6	ad 95 03	lda $0395			lda 	Var_Type 					; array ? if so create the empty one.
.0199d9	29 01		and #$01			and 	#1
.0199db	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.0199dd	d0 0e		bne $0199ed			bne 	_VCNotArray
.0199df	a2 00		ldx #$00			ldx 	#0 							; call recursive array creator
.0199e1	20 87 9a	jsr $019a87			jsr 	ArrayCreate
.0199e4	5a		phy				phy 								; save YA at zVarDataPtr
.0199e5	a0 00		ldy #$00			ldy 	#0
.0199e7	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0199e9	c8		iny				iny
.0199ea	68		pla				pla
.0199eb	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0199ed					_VCNotArray:
.0199ed	7a		ply				ply
.0199ee	fa		plx				plx
.0199ef	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arrayidx.asm

.0199f0					ArrayIndexFollow:
.0199f0	5a		phy				phy
.0199f1	a0 00		ldy #$00			ldy 	#0 							; make zVarDataPtr point to the array.
.0199f3	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; e.g. it points to itself.
.0199f5	48		pha				pha
.0199f6	c8		iny				iny
.0199f7	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.0199f9	85 23		sta $23				sta 	zVarDataPtr+1
.0199fb	68		pla				pla
.0199fc	85 22		sta $22				sta 	zVarDataPtr
.0199fe	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; MSB of 16 bit integer and bytes 2&3
.019a00	29 80		and #$80			and 	#$80 						; must be zero.
.019a02	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019a04	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019a06	d0 59		bne $019a61			bne 	_AIFError
.019a08	a0 00		ldy #$00			ldy 	#0 							; calculate size - current - 1
.019a0a	18		clc				clc
.019a0b	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019a0d	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.019a0f	c8		iny				iny
.019a10	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019a12	08		php				php 								; clear bit 7 retaining borrow.
.019a13	29 7f		and #$7f			and 	#$7F
.019a15	28		plp				plp
.019a16	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.019a18	90 47		bcc $019a61			bcc 	_AIFError 					; eror if size-current < 0
.019a1a	b5 80		lda $80,x			lda  	XS_Mantissa+0,x 			; copy and double the index
.019a1c	0a		asl a				asl 	a 							; (e.g. index * 2)
.019a1d	85 10		sta $10				sta 	zTemp1
.019a1f	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019a21	2a		rol a				rol 	a
.019a22	85 11		sta $11				sta 	zTemp1+1
.019a24	a0 01		ldy #$01			ldy 	#1 							; is this a data entry.
.019a26	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; if so, then type is unchanged, offset set
.019a28	30 1d		bmi $019a47			bmi 	_AIFCalculate
.019a2a	c6 24		dec $24				dec 	zVarType 					; converts from an array to a type.
.019a2c	a5 24		lda $24				lda 	zVarType 					; check that type
.019a2e	c9 b7		cmp #$b7			cmp 	#token_Dollar 				; if string, use x 2
.019a30	f0 15		beq $019a47			beq 	_AIFCalculate
.019a32	06 10		asl $10				asl 	zTemp1			 			; double the index
.019a34	26 11		rol $11				rol 	zTemp1+1					; (e.g. index * 4)
.019a36	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if integer, use x 4
.019a38	f0 0d		beq $019a47			beq 	_AIFCalculate
.019a3a	18		clc				clc 								; add the original mantissa in again
.019a3b	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; which makes it x5, for float.
.019a3d	65 10		adc $10				adc 	zTemp1
.019a3f	85 10		sta $10				sta 	zTemp1
.019a41	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019a43	65 11		adc $11				adc 	zTemp1+1
.019a45	85 11		sta $11				sta 	zTemp1+1
.019a47					_AIFCalculate:
.019a47	18		clc				clc 								; add index x 2,4 or 5 to base
.019a48	a5 22		lda $22				lda 	zVarDataPtr
.019a4a	65 10		adc $10				adc 	zTemp1
.019a4c	85 22		sta $22				sta 	zVarDataPtr
.019a4e	a5 23		lda $23				lda 	zVarDataPtr+1
.019a50	65 11		adc $11				adc 	zTemp1+1
.019a52	85 23		sta $23				sta 	zVarDataPtr+1
.019a54	18		clc				clc 								; add 2 more for the length prefix.
.019a55	a5 22		lda $22				lda 	zVarDataPtr
.019a57	69 02		adc #$02			adc 	#2
.019a59	85 22		sta $22				sta 	zVarDataPtr
.019a5b	90 02		bcc $019a5f			bcc 	_AIFNoBump
.019a5d	e6 23		inc $23				inc 	zVarDataPtr+1
.019a5f					_AIFNoBump:
.019a5f	7a		ply				ply
.019a60	60		rts				rts
.019a61					_AIFError:
.019a61	20 4e 85	jsr $01854e			jsr ERR_Handler
>019a64	42 61 64 20 61 72 72 61			.text "Bad array index",0
>019a6c	79 20 69 6e 64 65 78 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arraydef.asm

.019a74					ArrayResetDefault:
.019a74	a9 0b		lda #$0b			lda 	#11 						; 0..10 one array
.019a76	8d a9 03	sta $03a9			sta 	ArrayDef+0
.019a79	a9 00		lda #$00			lda 	#0
.019a7b	8d aa 03	sta $03aa			sta 	ArrayDef+1
.019a7e	a9 ff		lda #$ff			lda 	#$FF
.019a80	8d ab 03	sta $03ab			sta 	ArrayDef+2 					; $FFFF implies no second element.
.019a83	8d ac 03	sta $03ac			sta 	ArrayDef+3					; (test bit 7 of 2nd byte)
.019a86	60		rts				rts
.019a87					ArrayCreate:
.019a87	bd a9 03	lda $03a9,x			lda 	ArrayDef+0,x 				; put size x 2 in zTemp1
.019a8a	0a		asl a				asl 	a
.019a8b	85 10		sta $10				sta 	zTemp1
.019a8d	bd aa 03	lda $03aa,x			lda 	ArrayDef+1,x
.019a90	2a		rol a				rol 	a
.019a91	85 11		sta $11				sta 	zTemp1+1
.019a93	bd ac 03	lda $03ac,x			lda 	ArrayDef+3,x 				; if this is the last element it's array of ptrs.
.019a96	10 22		bpl $019aba			bpl 	_ACSized 					; if not multiply size x 2 (str) 4 (int) 5 (real)
.019a98	ad 95 03	lda $0395			lda 	Var_Type 					; check the type
.019a9b	c9 b8		cmp #$b8			cmp 	#token_DollarLParen 		; also if it is an array of strings $(
.019a9d	f0 1b		beq $019aba			beq 	_ACSized
.019a9f	06 10		asl $10				asl 	zTemp1 						; double again
.019aa1	26 11		rol $11				rol 	zTemp1+1
.019aa3	b0 6f		bcs $019b14			bcs 	ArrayIndexError 			; too large.
.019aa5	c9 bc		cmp #$bc			cmp 	#token_PercentLParen 		; if %( four bytes/entry is enough.
.019aa7	f0 11		beq $019aba			beq 	_ACSized
.019aa9	18		clc				clc 								; add original value x 5 for reals.
.019aaa	a5 10		lda $10				lda 	zTemp1
.019aac	7d a9 03	adc $03a9,x			adc 	ArrayDef+0,x
.019aaf	85 10		sta $10				sta 	zTemp1
.019ab1	a5 11		lda $11				lda 	zTemp1+1
.019ab3	7d aa 03	adc $03aa,x			adc 	ArrayDef+1,x
.019ab6	85 11		sta $11				sta 	zTemp1+1
.019ab8	b0 5a		bcs $019b14			bcs 	ArrayIndexError
.019aba					_ACSized:
.019aba	18		clc				clc
.019abb	a5 10		lda $10				lda 	zTemp1
.019abd	69 02		adc #$02			adc 	#2
.019abf	85 10		sta $10				sta 	zTemp1
.019ac1	90 04		bcc $019ac7			bcc 	_ACNoBump
.019ac3	e6 10		inc $10				inc 	zTemp1
.019ac5	f0 4d		beq $019b14			beq 	ArrayIndexError
.019ac7					_ACNoBump:
.019ac7	18		clc				clc
.019ac8	ad 02 03	lda $0302			lda 	VarMemPtr 					; add this allocated count to VarMemPtr
.019acb	85 12		sta $12				sta 	zTemp2						; save start in zTemp2/zTemp3
.019acd	85 14		sta $14				sta 	zTemp3
.019acf	65 10		adc $10				adc 	zTemp1
.019ad1	8d 02 03	sta $0302			sta 	VarMemPtr
.019ad4	ad 03 03	lda $0303			lda 	VarMemPtr+1
.019ad7	85 13		sta $13				sta 	zTemp2+1
.019ad9	85 15		sta $15				sta 	zTemp3+1
.019adb	65 11		adc $11				adc 	zTemp1+1
.019add	8d 03 03	sta $0303			sta 	VarMemPtr+1
.019ae0	85 11		sta $11				sta 	zTemp1+1
.019ae2	b0 30		bcs $019b14			bcs 	ArrayIndexError
.019ae4	a0 00		ldy #$00			ldy 	#0							; write $00 out.
.019ae6					_ACClear:
.019ae6	98		tya				tya
.019ae7	91 12		sta ($12),y			sta 	(zTemp2),y
.019ae9	e6 12		inc $12				inc 	zTemp2
.019aeb	d0 02		bne $019aef			bne 	_ACCBump
.019aed	e6 13		inc $13				inc 	zTemp2+1
.019aef					_ACCBump:
.019aef	a5 12		lda $12				lda 	zTemp2
.019af1	cd 02 03	cmp $0302			cmp 	VarMemPtr
.019af4	d0 f0		bne $019ae6			bne 	_ACClear
.019af6	a5 13		lda $13				lda 	zTemp2+1
.019af8	cd 03 03	cmp $0303			cmp 	VarMemPtr+1
.019afb	d0 e9		bne $019ae6			bne 	_ACClear
.019afd	a0 00		ldy #$00			ldy 	#0
.019aff	bd a9 03	lda $03a9,x			lda 	ArrayDef+0,x 				; copy the size into the start
.019b02	91 14		sta ($14),y			sta 	(zTemp3),y
.019b04	c8		iny				iny
.019b05	bd aa 03	lda $03aa,x			lda 	ArrayDef+1,x
.019b08	91 14		sta ($14),y			sta 	(zTemp3),y
.019b0a	bd ac 03	lda $03ac,x			lda 	ArrayDef+3,x 				; have we reached the end
.019b0d	10 18		bpl $019b27			bpl 	ACCFillRecursive
.019b0f	a4 15		ldy $15				ldy 	zTemp3+1 					; return address
.019b11	a5 14		lda $14				lda 	zTemp3
.019b13	60		rts				rts
.019b14					ArrayIndexError:
.019b14	20 4e 85	jsr $01854e			jsr ERR_Handler
>019b17	42 61 64 20 61 72 72 61			.text "Bad array index",0
>019b1f	79 20 69 6e 64 65 78 00
.019b27					ACCFillRecursive:
.019b27	a9 ff		lda #$ff			lda 	#$FF 						; we mark the end, this is free space.
.019b29	a0 00		ldy #$00			ldy 	#0 							; this is overwritten by size of next allocated
.019b2b	91 12		sta ($12),y			sta 	(zTemp2),y 					; array, but we might change that.
.019b2d	c8		iny				iny
.019b2e	b1 14		lda ($14),y			lda 	(zTemp3),y 					; set bit 15 of the max index indicating
.019b30	09 80		ora #$80			ora 	#$80 						; an array of pointers
.019b32	91 14		sta ($14),y			sta 	(zTemp3),y
.019b34	a5 14		lda $14				lda 	zTemp3 						; push the start on the stack
.019b36	48		pha				pha
.019b37	a5 15		lda $15				lda 	zTemp3+1
.019b39	48		pha				pha
.019b3a					_ACCFillLoop:
.019b3a	18		clc				clc
.019b3b	a5 14		lda $14				lda 	zTemp3 						; and work forwards.
.019b3d	69 02		adc #$02			adc 	#2
.019b3f	85 14		sta $14				sta 	zTemp3
.019b41	90 02		bcc $019b45			bcc 	_ACCSkip2
.019b43	e6 15		inc $15				inc 	zTemp3+1
.019b45					_ACCSkip2:
.019b45	a0 00		ldy #$00			ldy 	#0 							; reached the end ?
.019b47	b1 14		lda ($14),y			lda 	(zTemp3),y					; (looking for FF marker, everything else 00)
.019b49	c8		iny				iny
.019b4a	11 14		ora ($14),y			ora 	(zTemp3),y
.019b4c	d0 21		bne $019b6f			bne 	_ACCExit
.019b4e	a5 14		lda $14				lda 	zTemp3 						; push zTemp3
.019b50	48		pha				pha
.019b51	a5 15		lda $15				lda 	zTemp3+1
.019b53	48		pha				pha
.019b54	e8		inx				inx
.019b55	e8		inx				inx
.019b56	20 87 9a	jsr $019a87			jsr 	ArrayCreate 				; create array recursively.
.019b59	ca		dex				dex
.019b5a	ca		dex				dex
.019b5b	85 12		sta $12				sta 	zTemp2 						; save A
.019b5d	68		pla				pla
.019b5e	85 15		sta $15				sta 	zTemp3+1 					; restore zTemp3
.019b60	68		pla				pla
.019b61	85 14		sta $14				sta 	zTemp3
.019b63	98		tya				tya 								; write high bye from Y
.019b64	a0 01		ldy #$01			ldy 	#1
.019b66	91 14		sta ($14),y			sta 	(zTemp3),y
.019b68	88		dey				dey 								; write low byte out.
.019b69	a5 12		lda $12				lda 	zTemp2
.019b6b	91 14		sta ($14),y			sta 	(zTemp3),y
.019b6d	80 cb		bra $019b3a			bra 	_ACCFillLoop 				; and try again.
.019b6f					_ACCExit:
.019b6f	7a		ply				ply 								; restore the original address
.019b70	68		pla				pla
.019b71	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varfind.asm

.019b72					VariableLocate:
.019b72	da		phx				phx
.019b73	5a		phy				phy
.019b74	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.019b77	85 12		sta $12				sta 	zTemp2 						; points to first address.
.019b79	a9 03		lda #$03			lda 	#HashTableBase >> 8
.019b7b	85 13		sta $13				sta 	zTemp2+1
.019b7d	a0 00		ldy #$00	_VLNext:ldy 	#0 							; get next link into AX
.019b7f	b1 12		lda ($12),y			lda 	(zTemp2),y
.019b81	aa		tax				tax
.019b82	c8		iny				iny
.019b83	b1 12		lda ($12),y			lda 	(zTemp2),y
.019b85	85 13		sta $13				sta 	zTemp2+1 					; save in zTemp
.019b87	86 12		stx $12				stx 	zTemp2
.019b89	05 12		ora $12				ora 	zTemp2 						; got zero
.019b8b	18		clc				clc
.019b8c	f0 25		beq $019bb3			beq 	_VLExit 					; if so, then fail as end of chain.
.019b8e	c8		iny				iny 								; point to hash (offset + 2)
.019b8f	b1 12		lda ($12),y			lda 	(zTemp2),y
.019b91	cd 96 03	cmp $0396			cmp 	Var_Hash
.019b94	d0 e7		bne $019b7d			bne 	_VLNext 					; try next if different.
.019b96					_VLCompare:
.019b96	c8		iny				iny 								; next character
.019b97	b1 12		lda ($12),y			lda 	(zTemp2),y 					; compare variable field against buffer.
.019b99	d9 12 03	cmp $0312,y			cmp 	Var_Buffer-3,y 				; the -3 is because name starts at 3.
.019b9c	d0 df		bne $019b7d			bne 	_VLNext 					; fail if different, try next.
.019b9e	0a		asl a				asl 	a 							; until end character (bit 7 set) matched
.019b9f	90 f5		bcc $019b96			bcc 	_VLCompare
.019ba1	98		tya				tya
.019ba2	38		sec				sec 								; add 1 as Y points to last character
.019ba3	65 12		adc $12				adc 	zTemp2 						; add to the current address
.019ba5	85 22		sta $22				sta 	zVarDataPtr
.019ba7	a5 13		lda $13				lda 	zTemp2+1
.019ba9	69 00		adc #$00			adc 	#0
.019bab	85 23		sta $23				sta 	zVarDataPtr+1
.019bad	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.019bb0	85 24		sta $24				sta 	zVarType
.019bb2	38		sec				sec 								; return CS
.019bb3	7a		ply		_VLExit:ply
.019bb4	fa		plx				plx
.019bb5	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/vargetset.asm

.019bb6					VariableGet:
.019bb6	5a		phy				phy
.019bb7	a0 00		ldy #$00			ldy 	#0 							; copy first two bytes
.019bb9	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019bbb	95 80		sta $80,x			sta 	XS_Mantissa,x
.019bbd	c8		iny				iny
.019bbe	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019bc0	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019bc2	c8		iny				iny
.019bc3	a5 24		lda $24				lda 	zVarType 					; if it is a string, set up for that.
.019bc5	c9 b7		cmp #$b7			cmp 	#token_Dollar
.019bc7	f0 2c		beq $019bf5			beq 	_VGString
.019bc9	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; copy the next two bytes.
.019bcb	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019bcd	c8		iny				iny
.019bce	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019bd0	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019bd2	c8		iny				iny
.019bd3	a9 01		lda #$01			lda 	#1 							; set type to 1.
.019bd5	95 85		sta $85,x			sta 	XS_Type,x
.019bd7	a5 24		lda $24				lda 	zVarType
.019bd9	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if it is a %, then exit with default integer.
.019bdb	f0 28		beq $019c05			beq 	_VGExit
.019bdd	a9 40		lda #$40			lda 	#$40 						; set type byte to zero
.019bdf	95 85		sta $85,x			sta 	XS_Type,x 					; which is the code for zero/float.
.019be1	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; the last value to copy is the exponent.
.019be3	95 84		sta $84,x			sta 	XS_Exponent,x
.019be5	f0 1e		beq $019c05			beq 	_VGExit 					; if exponent is zero ... it's zero.
.019be7	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; the sign bit is the top mantissa bit.
.019be9	48		pha				pha
.019bea	29 80		and #$80			and 	#$80
.019bec	95 85		sta $85,x			sta 	XS_Type,x 					; this is the type byte.
.019bee	68		pla				pla
.019bef	09 80		ora #$80			ora 	#$80 						; set the MSB as you would expect.
.019bf1	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; so it's a normalised float.
.019bf3	80 10		bra $019c05			bra 	_VGExit
.019bf5					_VGString:
.019bf5	a9 02		lda #$02			lda 	#2 							; set type to 2, a string
.019bf7	95 85		sta $85,x			sta 	XS_Type,x
.019bf9	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; is the value there $0000
.019bfb	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019bfd	d0 06		bne $019c05			bne 	_VGExit 					; if not, exit.
.019bff	85 25		sta $25				sta 	zNullString 				; make zNullString a 00 string.
.019c01	a9 25		lda #$25			lda 	#zNullString
.019c03	95 80		sta $80,x			sta 	XS_Mantissa,x 				; make it point to it.
.019c05					_VGExit:
.019c05	7a		ply				ply
.019c06	60		rts				rts
.019c07					VariableSet:
.019c07	b5 85		lda $85,x			lda 	XS_Type,x 					; is the result a string
.019c09	29 02		and #$02			and 	#2 							; if so, it has to be
.019c0b	d0 4b		bne $019c58			bne 	_VSString
.019c0d	a5 24		lda $24				lda 	zVarType 					; if type is $ there's an error.
.019c0f	c9 b7		cmp #$b7			cmp 	#token_Dollar
.019c11	f0 42		beq $019c55			beq 	_VSBadType
.019c13	c9 bb		cmp #$bb			cmp 	#token_Percent 				; type convert to float/int
.019c15	f0 05		beq $019c1c			beq 	_VSMakeInt
.019c17	20 7d a1	jsr $01a17d			jsr 	FPUToFloat
.019c1a	80 03		bra $019c1f			bra 	_VSCopy
.019c1c					_VSMakeInt:
.019c1c	20 c9 a1	jsr $01a1c9			jsr 	FPUToInteger
.019c1f					_VSCopy:
.019c1f	5a		phy				phy
.019c20	a0 00		ldy #$00			ldy 	#0 							; copy mantissa to target.
.019c22	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019c24	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019c26	c8		iny				iny
.019c27	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019c29	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019c2b	c8		iny				iny
.019c2c	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019c2e	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019c30	c8		iny				iny
.019c31	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019c33	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019c35	a5 24		lda $24				lda 	zVarType 					; if target is integer, alrady done.
.019c37	c9 bb		cmp #$bb			cmp 	#token_Percent
.019c39	f0 18		beq $019c53			beq 	_VSExit
.019c3b	b5 85		lda $85,x			lda 	XS_Type,x 					; get the sign bit into carry flag.
.019c3d	0a		asl a				asl 	a
.019c3e	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; shift the sign into the mantissa high.
.019c40	08		php				php
.019c41	0a		asl a				asl 	a
.019c42	28		plp				plp
.019c43	6a		ror a				ror 	a
.019c44	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019c46	c8		iny				iny
.019c47	b5 84		lda $84,x			lda 	XS_Exponent,x 				; copy the exponent in
.019c49	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019c4b	34 85		bit $85,x			bit 	XS_Type,x 					; if the result is non zero
.019c4d	50 04		bvc $019c53			bvc 	_VSExit
.019c4f	a9 00		lda #$00			lda 	#00 						; zero exponent indicating 0.
.019c51	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019c53					_VSExit:
.019c53	7a		ply				ply
.019c54	60		rts				rts
.019c55					_VSBadType:
.019c55	4c 2f 85	jmp $01852f			jmp 	TypeError
.019c58					_VSString:
.019c58	a5 24		lda $24				lda 	zVarType 					; type must be $
.019c5a	c9 b7		cmp #$b7			cmp 	#token_Dollar
.019c5c	d0 f7		bne $019c55			bne 	_VSBadType
.019c5e	da		phx				phx
.019c5f	5a		phy				phy
.019c60	20 dd 97	jsr $0197dd			jsr 	StringConcrete 				; concrete the string in the mantissa -> AX
.019c63	a0 01		ldy #$01			ldy 	#1 							; save high byte
.019c65	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019c67	88		dey				dey 								; save low byte
.019c68	8a		txa				txa
.019c69	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019c6b	7a		ply				ply 								; and exit.
.019c6c	fa		plx				plx
.019c6d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.019c6e					MulInteger32:
.019c6e	b5 80		lda $80,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.019c70	95 8c		sta $8c,x			sta 	XS3_Mantissa,x
.019c72	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019c74	95 8d		sta $8d,x			sta 	XS3_Mantissa+1,x
.019c76	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019c78	95 8e		sta $8e,x			sta 	XS3_Mantissa+2,x
.019c7a	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019c7c	95 8f		sta $8f,x			sta 	XS3_Mantissa+3,x
.019c7e	a9 00		lda #$00			lda 	#0
.019c80	95 80		sta $80,x			sta 	XS_Mantissa+0,x 				; zero +0
.019c82	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019c84	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019c86	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019c88					_BFMMultiply:
.019c88	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.019c8a	29 01		and #$01			and 	#1
.019c8c	f0 03		beq $019c91			beq 	_BFMNoAdd
.019c8e	20 29 93	jsr $019329			jsr 	AddInteger32
.019c91					_BFMNoAdd:
.019c91	16 86		asl $86,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.019c93	36 87		rol $87,x			rol 	XS2_Mantissa+1,x
.019c95	36 88		rol $88,x			rol 	XS2_Mantissa+2,x
.019c97	36 89		rol $89,x			rol 	XS2_Mantissa+3,x
.019c99	56 8f		lsr $8f,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.019c9b	76 8e		ror $8e,x			ror 	XS3_Mantissa+2,x
.019c9d	76 8d		ror $8d,x			ror 	XS3_Mantissa+1,x
.019c9f	76 8c		ror $8c,x			ror 	XS3_Mantissa,x
.019ca1	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.019ca3	15 8d		ora $8d,x			ora 	XS3_Mantissa+1,x
.019ca5	15 8e		ora $8e,x			ora 	XS3_Mantissa+2,x
.019ca7	15 8f		ora $8f,x			ora 	XS3_Mantissa+3,x
.019ca9	d0 dd		bne $019c88			bne 	_BFMMultiply
.019cab	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.019cac					DivInteger32:
.019cac	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; check for /0
.019cae	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.019cb0	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.019cb2	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.019cb4	d0 14		bne $019cca			bne 	_BFDOkay
.019cb6	20 4e 85	jsr $01854e			jsr ERR_Handler
>019cb9	44 69 76 69 73 69 6f 6e			.text "Division by Zero",0
>019cc1	20 62 79 20 5a 65 72 6f 00
.019cca					_BFDOkay:
.019cca	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.019ccc	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.019cce	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.019cd0	85 1c		sta $1c				sta 	zLTemp1+2
.019cd2	85 1d		sta $1d				sta 	zLTemp1+3
.019cd4	8d 9e 03	sta $039e			sta 	SignCount 					; Count of signs.
.019cd7	20 2e 9d	jsr $019d2e			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.019cda	da		phx				phx
.019cdb	e8		inx				inx
.019cdc	e8		inx				inx
.019cdd	e8		inx				inx
.019cde	e8		inx				inx
.019cdf	e8		inx				inx
.019ce0	e8		inx				inx
.019ce1	20 2e 9d	jsr $019d2e			jsr 	CheckIntegerNegate
.019ce4	fa		plx				plx
.019ce5	5a		phy				phy 								; Y is the counter
.019ce6	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.019ce8					_BFDLoop:
.019ce8	16 80		asl $80,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.019cea	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.019cec	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.019cee	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.019cf0	26 1a		rol $1a				rol 	zLTemp1
.019cf2	26 1b		rol $1b				rol 	zLTemp1+1
.019cf4	26 1c		rol $1c				rol 	zLTemp1+2
.019cf6	26 1d		rol $1d				rol 	zLTemp1+3
.019cf8	38		sec				sec
.019cf9	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.019cfb	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.019cfd	48		pha				pha
.019cfe	a5 1b		lda $1b				lda 	zLTemp1+1
.019d00	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.019d02	48		pha				pha
.019d03	a5 1c		lda $1c				lda 	zLTemp1+2
.019d05	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.019d07	48		pha				pha
.019d08	a5 1d		lda $1d				lda 	zLTemp1+3
.019d0a	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.019d0c	90 13		bcc $019d21			bcc 	_BFDNoAdd
.019d0e	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.019d10	68		pla				pla
.019d11	85 1c		sta $1c				sta 	zLTemp1+2
.019d13	68		pla				pla
.019d14	85 1b		sta $1b				sta 	zLTemp1+1
.019d16	68		pla				pla
.019d17	85 1a		sta $1a				sta 	zLTemp1+0
.019d19	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.019d1b	09 01		ora #$01			ora 	#1
.019d1d	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019d1f	80 03		bra $019d24			bra 	_BFDNext
.019d21					_BFDNoAdd:
.019d21	68		pla				pla 								; Throw away the intermediate calculations
.019d22	68		pla				pla
.019d23	68		pla				pla
.019d24					_BFDNext:
.019d24	88		dey				dey
.019d25	d0 c1		bne $019ce8			bne 	_BFDLoop
.019d27	7a		ply				ply 								; restore Y and exit
.019d28	4e 9e 03	lsr $039e			lsr 	SignCount 					; if sign count odd,
.019d2b	b0 06		bcs $019d33			bcs		IntegerNegateAlways 			; negate the result
.019d2d	60		rts				rts
.019d2e					CheckIntegerNegate:
.019d2e	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019d30	30 01		bmi $019d33			bmi 	IntegerNegateAlways
.019d32	60		rts				rts
.019d33					IntegerNegateAlways:
.019d33	ee 9e 03	inc $039e			inc 	SignCount
.019d36	38		sec				sec
.019d37	a9 00		lda #$00			lda 	#0
.019d39	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.019d3b	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019d3d	a9 00		lda #$00			lda 	#0
.019d3f	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.019d41	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019d43	a9 00		lda #$00			lda 	#0
.019d45	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.019d47	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019d49	a9 00		lda #$00			lda 	#0
.019d4b	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.019d4d	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019d4f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.019d50					INTToString:
.019d50	48		pha				pha
.019d51	5a		phy				phy
.019d52	b5 83		lda $83,x			lda 		XS_Mantissa+3,x 		; check -ve
.019d54	10 08		bpl $019d5e			bpl 		_ITSNotMinus
.019d56	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.019d58	20 f2 9d	jsr $019df2			jsr 		ITSOutputCharacter
.019d5b	20 33 9d	jsr $019d33			jsr 		IntegerNegateAlways 	; negate the number.
.019d5e					_ITSNotMinus:
.019d5e	a9 00		lda #$00			lda 		#0
.019d60	8d 9a 03	sta $039a			sta 		NumSuppress 			; clear the suppression flag.
.019d63	8a		txa				txa 								; use Y for the mantissa index.
.019d64	a8		tay				tay
.019d65	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.019d67					_ITSNextSubtractor:
.019d67	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.019d69	8d 9b 03	sta $039b			sta 		NumConvCount
.019d6c					_ITSSubtract:
.019d6c	38		sec				sec
.019d6d	b9 80 00	lda $0080,y			lda 		XS_Mantissa,y 			; subtract number and push on stack
.019d70	ff ce 9d 01	sbc $019dce,x			sbc 		_ITSSubtractors+0,x
.019d74	48		pha				pha
.019d75	b9 81 00	lda $0081,y			lda 		XS_Mantissa+1,y
.019d78	ff cf 9d 01	sbc $019dcf,x			sbc 		_ITSSubtractors+1,x
.019d7c	48		pha				pha
.019d7d	b9 82 00	lda $0082,y			lda 		XS_Mantissa+2,y
.019d80	ff d0 9d 01	sbc $019dd0,x			sbc 		_ITSSubtractors+2,x
.019d84	48		pha				pha
.019d85	b9 83 00	lda $0083,y			lda 		XS_Mantissa+3,y
.019d88	ff d1 9d 01	sbc $019dd1,x			sbc 		_ITSSubtractors+3,x
.019d8c	90 14		bcc $019da2			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.019d8e	99 83 00	sta $0083,y			sta 		XS_Mantissa+3,y 		; save subtract off stack
.019d91	68		pla				pla
.019d92	99 82 00	sta $0082,y			sta 		XS_Mantissa+2,y
.019d95	68		pla				pla
.019d96	99 81 00	sta $0081,y			sta 		XS_Mantissa+1,y
.019d99	68		pla				pla
.019d9a	99 80 00	sta $0080,y			sta 		XS_Mantissa+0,y
.019d9d	ee 9b 03	inc $039b			inc 		NumConvCount 			; bump count.
.019da0	80 ca		bra $019d6c			bra 		_ITSSubtract 			; go round again.
.019da2					_ITSCantSubtract:
.019da2	68		pla				pla 								; throw away interim answers
.019da3	68		pla				pla
.019da4	68		pla				pla
.019da5	ad 9b 03	lda $039b			lda 		NumConvCount 			; if not zero then no suppression check
.019da8	c9 30		cmp #$30			cmp 		#"0"
.019daa	d0 05		bne $019db1			bne 		_ITSOutputDigit
.019dac	ad 9a 03	lda $039a			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.019daf	10 09		bpl $019dba			bpl	 		_ITSGoNextSubtractor
.019db1					_ITSOutputDigit:
.019db1	ce 9a 03	dec $039a			dec 		NumSuppress 			; suppression check will be non-zero.
.019db4	ad 9b 03	lda $039b			lda 		NumConvCount 			; count of subtractions
.019db7	20 f2 9d	jsr $019df2			jsr 		ITSOutputCharacter 		; output it.
.019dba					_ITSGoNextSubtractor:
.019dba	e8		inx				inx 								; next dword
.019dbb	e8		inx				inx
.019dbc	e8		inx				inx
.019dbd	e8		inx				inx
.019dbe	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.019dc0	d0 a5		bne $019d67			bne 		_ITSNextSubtractor 		; do all the subtractors.
.019dc2	98		tya				tya 								; X is back as the mantissa index
.019dc3	aa		tax				tax
.019dc4	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.019dc6	09 30		ora #$30			ora 		#"0"
.019dc8	20 f2 9d	jsr $019df2			jsr 		ITSOutputCharacter
.019dcb	7a		ply				ply 								; and exit
.019dcc	68		pla				pla
.019dcd	60		rts				rts
.019dce					_ITSSubtractors:
>019dce	00 ca 9a 3b					.dword 		1000000000
>019dd2	00 e1 f5 05					.dword 		100000000
>019dd6	80 96 98 00					.dword 		10000000
>019dda	40 42 0f 00					.dword 		1000000
>019dde	a0 86 01 00					.dword 		100000
>019de2	10 27 00 00					.dword 		10000
>019de6	e8 03 00 00					.dword 		1000
>019dea	64 00 00 00					.dword 		100
>019dee	0a 00 00 00					.dword 		10
.019df2					_ITSSubtractorsEnd:
.019df2					ITSOutputCharacter:
.019df2	48		pha				pha
.019df3	da		phx				phx
.019df4	ae 14 03	ldx $0314			ldx 	NumBufX 					; save digit
.019df7	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.019dfa	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.019dfc	9d 16 03	sta $0316,x			sta 	Num_Buffer+1,x
.019dff	ee 14 03	inc $0314			inc 	NumBufX						; bump pointer.
.019e02	fa		plx				plx
.019e03	68		pla				pla
.019e04	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.019e05					IntFromString:
.019e05	a0 00		ldy #$00			ldy 	#0
.019e07	8c 9c 03	sty $039c			sty 	ExpTemp 					; this is the converted digit count.
.019e0a					IntFromStringY:
.019e0a	48		pha				pha
.019e0b	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.019e0d	95 80		sta $80,x			sta 	XS_Mantissa,x
.019e0f	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019e11	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019e13	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019e15	a9 01		lda #$01			lda 	#1
.019e17	95 85		sta $85,x			sta 	XS_Type,x
.019e19					_IFSLoop:
.019e19	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.019e1b	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.019e1d	90 4e		bcc $019e6d			bcc 	_IFSExit
.019e1f	c9 3a		cmp #$3a			cmp 	#"9"+1
.019e21	b0 4a		bcs $019e6d			bcs 	_IFSExit
.019e23	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.019e25	c9 0c		cmp #$0c			cmp 	#12
.019e27	b0 4e		bcs $019e77			bcs 	_IFSOverflow
.019e29	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.019e2b	48		pha				pha
.019e2c	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019e2e	48		pha				pha
.019e2f	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019e31	48		pha				pha
.019e32	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019e34	48		pha				pha
.019e35	20 8c 9e	jsr $019e8c			jsr 	IFSX1ShiftLeft 				; double
.019e38	20 8c 9e	jsr $019e8c			jsr 	IFSX1ShiftLeft 				; x 4
.019e3b	18		clc				clc 								; add saved value x 5
.019e3c	68		pla				pla
.019e3d	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.019e3f	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019e41	68		pla				pla
.019e42	75 81		adc $81,x			adc 	XS_Mantissa+1,x
.019e44	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019e46	68		pla				pla
.019e47	75 82		adc $82,x			adc 	XS_Mantissa+2,x
.019e49	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019e4b	68		pla				pla
.019e4c	75 83		adc $83,x			adc 	XS_Mantissa+3,x
.019e4e	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019e50	20 8c 9e	jsr $019e8c			jsr 	IFSX1ShiftLeft 				; x 10
.019e53	ee 9c 03	inc $039c			inc 	ExpTemp 					; bump count of digits processed.
.019e56	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.019e58	29 0f		and #$0f			and 	#15
.019e5a	c8		iny				iny
.019e5b	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.019e5d	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019e5f	90 b8		bcc $019e19			bcc 	_IFSLoop
.019e61	f6 81		inc $81,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.019e63	d0 b4		bne $019e19			bne 	_IFSLoop
.019e65	f6 82		inc $82,x			inc 	XS_Mantissa+2,x
.019e67	d0 b0		bne $019e19			bne 	_IFSLoop
.019e69	f6 83		inc $83,x			inc 	XS_Mantissa+3,x
.019e6b	80 ac		bra $019e19			bra 	_IFSLoop
.019e6d					_IFSExit:
.019e6d	98		tya				tya 								; get offset
.019e6e					_IFSOkay:
.019e6e	38		sec				sec
.019e6f	ad 9c 03	lda $039c			lda 	ExpTemp
.019e72	f0 01		beq $019e75			beq 	_IFSSkipFail
.019e74	18		clc				clc
.019e75					_IFSSkipFail:
.019e75	68		pla				pla 								; and exit.
.019e76	60		rts				rts
.019e77					_IFSOverflow:
.019e77	20 4e 85	jsr $01854e			jsr 	ERR_Handler
>019e7a	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>019e82	20 6f 76 65 72 66 6c 6f 77 00
.019e8c					IFSX1ShiftLeft:
.019e8c	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.019e8e	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.019e90	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.019e92	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.019e94	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.019e95					FPSubtract:
.019e95	48		pha				pha
.019e96	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.019e98	49 80		eor #$80			eor 	#$80
.019e9a	95 8b		sta $8b,x			sta 	XS2_Type,x
.019e9c	68		pla				pla 								; --- and fall through ---
.019e9d					FPAdd:
.019e9d	48		pha				pha
.019e9e	b5 85		lda $85,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.019ea0	d0 05		bne $019ea7			bne 	_FPA_NegativeLHS
.019ea2	20 be 9e	jsr $019ebe			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.019ea5	68		pla				pla
.019ea6	60		rts				rts
.019ea7					_FPA_NegativeLHS:
.019ea7	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.019ea9	49 80		eor #$80			eor 	#$80
.019eab	95 85		sta $85,x			sta 	XS_Type,x
.019ead	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of B and add
.019eaf	49 80		eor #$80			eor 	#$80
.019eb1	95 8b		sta $8b,x			sta 	XS2_Type,x
.019eb3	20 be 9e	jsr $019ebe			jsr 	FPAdd_Worker 				; do the add calculation.
.019eb6	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 back
.019eb8	49 80		eor #$80			eor 	#$80
.019eba	95 85		sta $85,x			sta 	XS_Type,x
.019ebc	68		pla				pla
.019ebd	60		rts				rts
.019ebe					FPAdd_Worker:
.019ebe	34 8b		bit $8b,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.019ec0	70 07		bvs $019ec9			bvs 	_FPAWExit 					; no change.
.019ec2	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.019ec4	50 07		bvc $019ecd			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.019ec6	20 3b a1	jsr $01a13b			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.019ec9					_FPAWExit:
.019ec9	20 aa a1	jsr $01a1aa			jsr 	FPUNormalise 				; normalise the result.
.019ecc	60		rts				rts
.019ecd					_FPAWMakeSame:
.019ecd	b5 84		lda $84,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.019ecf	38		sec				sec
.019ed0	f5 8a		sbc $8a,x			sbc	 	XS2_Exponent,x 				; using subtraction
.019ed2	f0 16		beq $019eea			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.019ed4	da		phx				phx 								; save X
.019ed5	90 06		bcc $019edd			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.019ed7	e8		inx				inx
.019ed8	e8		inx				inx
.019ed9	e8		inx				inx
.019eda	e8		inx				inx
.019edb	e8		inx				inx
.019edc	e8		inx				inx
.019edd					_FPAWShiftA:
.019edd	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.019edf	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.019ee1	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.019ee3	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.019ee5	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.019ee7	fa		plx				plx 								; restore original X
.019ee8	80 e3		bra $019ecd			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.019eea					_FPAW_DoArithmetic:
.019eea	34 8b		bit $8b,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.019eec	30 28		bmi $019f16			bmi 	_FPAW_BNegative
.019eee	18		clc				clc
.019eef	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019ef1	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.019ef3	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019ef5	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019ef7	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.019ef9	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019efb	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019efd	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.019eff	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019f01	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019f03	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.019f05	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019f07	90 c0		bcc $019ec9			bcc 	_FPAWExit 					; no carry.
.019f09	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.019f0b	38		sec				sec
.019f0c	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.019f0e	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.019f10	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.019f12	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.019f14	80 b3		bra $019ec9			bra 	_FPAWExit
.019f16					_FPAW_BNegative:
.019f16	38		sec				sec
.019f17	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019f19	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.019f1b	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019f1d	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019f1f	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.019f21	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019f23	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019f25	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.019f27	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019f29	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019f2b	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.019f2d	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019f2f	b0 09		bcs $019f3a			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.019f31	20 61 a1	jsr $01a161			jsr 	FPUNegateInteger			; negate the mantissa
.019f34	b5 85		lda $85,x			lda 	XS_Type,x 					; flip result sign
.019f36	49 80		eor #$80			eor 	#$80
.019f38	95 85		sta $85,x			sta 	XS_Type,x
.019f3a					_FPAWGoExit:
.019f3a	4c c9 9e	jmp $019ec9			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.019f3d					FPD_IsDivZero:
.019f3d	20 4e 85	jsr $01854e			jsr ERR_Handler
>019f40	44 69 76 69 73 69 6f 6e			.text "Division by zero",0
>019f48	20 62 79 20 7a 65 72 6f 00
.019f51					FPDivide:
.019f51	48		pha				pha
.019f52	5a		phy				phy
.019f53	34 8b		bit $8b,x			bit 	XS2_Type,x 					; check if division by zero
.019f55	70 e6		bvs $019f3d			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.019f57	34 85		bit $85,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.019f59	f0 03		beq $019f5e			beq 	_FPDCalculateExp
.019f5b					_FPD_Exit:
.019f5b	7a		ply				ply
.019f5c	68		pla				pla
.019f5d	60		rts				rts
.019f5e					_FPDCalculateExp:
.019f5e	b5 8a		lda $8a,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.019f60	49 ff		eor #$ff			eor 	#$FF
.019f62	1a		inc a				inc 	a
.019f63	95 8a		sta $8a,x			sta 	XS2_Exponent,x
.019f65	20 35 a0	jsr $01a035			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.019f68	18		clc				clc 	 							; add 1 to the resulting exponent
.019f69	69 01		adc #$01			adc 	#1
.019f6b	b0 54		bcs $019fc1			bcs 	_FPD_Overflow 				; which can overflow.
.019f6d	95 84		sta $84,x			sta 	XS_Exponent,x
.019f6f	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.019f71	85 1a		sta $1a				sta 	zLTemp1+0
.019f73	85 1b		sta $1b				sta 	zLTemp1+1
.019f75	85 1c		sta $1c				sta 	zLTemp1+2
.019f77	85 1d		sta $1d				sta 	zLTemp1+3
.019f79	a0 20		ldy #$20			ldy 	#32 						; times round.
.019f7b					_FPD_Loop:
.019f7b	38		sec				sec 								; calculate X1-X2 stacking result because we might
.019f7c	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; not save it.
.019f7e	f5 86		sbc $86,x			sbc 	XS2_Mantissa,x
.019f80	48		pha				pha
.019f81	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019f83	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.019f85	48		pha				pha
.019f86	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019f88	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.019f8a	48		pha				pha
.019f8b	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019f8d	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.019f8f	90 13		bcc $019fa4			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.019f91	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; save results out to A
.019f93	68		pla				pla
.019f94	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019f96	68		pla				pla
.019f97	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019f99	68		pla				pla
.019f9a	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019f9c	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.019f9e	09 80		ora #$80			ora 	#$80
.019fa0	85 1d		sta $1d				sta 	zLTemp1+3
.019fa2	80 03		bra $019fa7			bra 	_FPD_Rotates
.019fa4					_FPD_NoSubtract:
.019fa4	68		pla				pla 								; throw away unwanted results
.019fa5	68		pla				pla
.019fa6	68		pla				pla
.019fa7					_FPD_Rotates:
.019fa7	56 89		lsr $89,x			lsr 	3+XS2_Mantissa,x
.019fa9	76 88		ror $88,x			ror 	2+XS2_Mantissa,x
.019fab	76 87		ror $87,x			ror 	1+XS2_Mantissa,x
.019fad	76 86		ror $86,x			ror 	0+XS2_Mantissa,x
.019faf	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.019fb1	26 1b		rol $1b				rol 	zLTemp1+1
.019fb3	26 1c		rol $1c				rol 	zLTemp1+2
.019fb5	26 1d		rol $1d				rol 	zLTemp1+3
.019fb7	90 02		bcc $019fbb			bcc 	_FPD_NoCarry
.019fb9	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.019fbb					_FPD_NoCarry:
.019fbb	88		dey				dey 								; do 32 times
.019fbc	d0 bd		bne $019f7b			bne 	_FPD_Loop
.019fbe	4c 19 a0	jmp $01a019			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.019fc1					_FPD_Overflow:
.019fc1	4c 07 a2	jmp $01a207			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.019fc4					FPMultiply:
.019fc4	48		pha				pha
.019fc5	5a		phy				phy
.019fc6	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.019fc8	70 07		bvs $019fd1			bvs 	_FPM_Exit
.019fca	34 8b		bit $8b,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.019fcc	50 06		bvc $019fd4			bvc 	_FPM_CalcExponent
.019fce	20 3b a1	jsr $01a13b			jsr 	FPUCopyX2ToX1
.019fd1					_FPM_Exit:
.019fd1	7a		ply				ply
.019fd2	68		pla				pla
.019fd3	60		rts				rts
.019fd4					_FPM_CalcExponent:
.019fd4	18		clc				clc
.019fd5	20 35 a0	jsr $01a035			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.019fd8	95 84		sta $84,x			sta 	XS_Exponent,x 				; save the result.
.019fda	a9 00		lda #$00			lda 	#0
.019fdc	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.019fde	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.019fe0	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.019fe2	85 1d		sta $1d				sta 	zLTemp1+3
.019fe4	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.019fe6					_FPM_Loop:
.019fe6	b5 80		lda $80,x			lda 	XS_Mantissa,x				; check LSB of long product
.019fe8	29 01		and #$01			and 	#1
.019fea	18		clc				clc 								; clear carry for the long rotate.
.019feb	f0 19		beq $01a006			beq 	_FPM_NoAddition
.019fed	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.019fee	a5 1a		lda $1a				lda 	zLTemp1+0
.019ff0	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.019ff2	85 1a		sta $1a				sta 	zLTemp1+0
.019ff4	a5 1b		lda $1b				lda 	zLTemp1+1
.019ff6	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.019ff8	85 1b		sta $1b				sta 	zLTemp1+1
.019ffa	a5 1c		lda $1c				lda 	zLTemp1+2
.019ffc	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.019ffe	85 1c		sta $1c				sta 	zLTemp1+2
.01a000	a5 1d		lda $1d				lda 	zLTemp1+3
.01a002	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.01a004	85 1d		sta $1d				sta 	zLTemp1+3
.01a006					_FPM_NoAddition:
.01a006	66 1d		ror $1d				ror 	3+zLTemp1
.01a008	66 1c		ror $1c				ror 	2+zLTemp1
.01a00a	66 1b		ror $1b				ror 	1+zLTemp1
.01a00c	66 1a		ror $1a				ror 	0+zLTemp1
.01a00e	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.01a010	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a012	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a014	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a016	88		dey				dey
.01a017	d0 cd		bne $019fe6			bne 	_FPM_Loop 					; do this 32 times.
.01a019					FPM_CopySignNormalize:
.01a019	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.01a01b	95 80		sta $80,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.01a01d	a5 1b		lda $1b				lda 	zLTemp1+1
.01a01f	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a021	a5 1c		lda $1c				lda 	zLTemp1+2
.01a023	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a025	a5 1d		lda $1d				lda 	zLTemp1+3
.01a027	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a029	b5 85		lda $85,x			lda 	XS_Type,x 					; sign is xor of signs
.01a02b	55 8b		eor $8b,x			eor 	XS2_Type,x
.01a02d	95 85		sta $85,x			sta 	XS_Type,x
.01a02f	20 aa a1	jsr $01a1aa			jsr 	FPUNormalise 				; normalise and exit.
.01a032	7a		ply				ply
.01a033	68		pla				pla
.01a034	60		rts				rts
.01a035					FPCalculateExponent:
.01a035	18		clc				clc
.01a036	b5 84		lda $84,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.01a038	75 8a		adc $8a,x			adc 	XS2_Exponent,x
.01a03a	b0 08		bcs $01a044			bcs 	_FPCECarry 					; carry out ?
.01a03c	10 03		bpl $01a041			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.01a03e	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.01a040	60		rts				rts
.01a041					_FPCEExpZero:
.01a041	a9 00		lda #$00			lda 	#0
.01a043	60		rts				rts
.01a044					_FPCECarry:
.01a044	30 03		bmi $01a049			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.01a046	09 80		ora #$80			ora 	#$80 						; put in right range
.01a048	60		rts				rts
.01a049					_FPCEOverflow:
.01a049	4c 07 a2	jmp $01a207			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.01a04c					FPFractionalPart:
.01a04c	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.01a04e	38		sec				sec 								; this flag tells us to keep the fractional part
.01a04f	30 0d		bmi $01a05e			bmi 	FPGetPart
.01a051	60		rts				rts
.01a052					FPIntegerPart:
.01a052	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.01a054	18		clc				clc 								; this flag says keep the integer part.
.01a055	30 07		bmi $01a05e			bmi 	FPGetPart 					; -ve exponents are 0..127
.01a057	48		pha				pha
.01a058	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.01a05a	95 85		sta $85,x			sta 	XS_Type,x
.01a05c	68		pla				pla
.01a05d	60		rts				rts
.01a05e					FPGetPart:
.01a05e	48		pha				pha
.01a05f	5a		phy				phy 								; save Y
.01a060	08		php				php 								; save action
.01a061	34 85		bit $85,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.01a063	70 59		bvs $01a0be			bvs 	_FPGP_Exit 					; then do nothing.
.01a065	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.01a067	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.01a069	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.01a06b	85 1c		sta $1c				sta 	zLTemp1+2
.01a06d	85 1d		sta $1d				sta 	zLTemp1+3
.01a06f	b5 84		lda $84,x			lda 	XS_Exponent,x				; the number of shifts.
.01a071	38		sec				sec
.01a072	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.01a074	f0 12		beq $01a088			beq 	_FPGP_NoShift 				; ... if any
.01a076	c9 20		cmp #$20			cmp 	#32
.01a078	90 02		bcc $01a07c			bcc 	_FPGP_NotMax
.01a07a	a9 20		lda #$20			lda 	#32 						; max of 32.
.01a07c					_FPGP_NotMax:
.01a07c	a8		tay				tay 								; Y is the mask shift count.
.01a07d					_FPGP_ShiftMask:
.01a07d	46 1d		lsr $1d				lsr 	3+zLTemp1
.01a07f	66 1c		ror $1c				ror 	2+zLTemp1
.01a081	66 1b		ror $1b				ror 	1+zLTemp1
.01a083	66 1a		ror $1a				ror 	0+zLTemp1
.01a085	88		dey				dey
.01a086	d0 f5		bne $01a07d			bne 	_FPGP_ShiftMask
.01a088					_FPGP_NoShift:
.01a088	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.01a08a	8e 9c 03	stx $039c			stx 	ExpTemp						; save X
.01a08d					_FPGP_MaskLoop:
.01a08d	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.01a090	28		plp				plp 								; if CC we keep the top part, so we
.01a091	08		php				php		 							; flip the mask.
.01a092	b0 02		bcs $01a096			bcs		_FPGP_NoFlip
.01a094	49 ff		eor #$ff			eor 	#$FF
.01a096					_FPGP_NoFlip:
.01a096	35 80		and $80,x			and 	XS_Mantissa,x 				; and into the mantissa.
.01a098	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a09a	e8		inx				inx
.01a09b	c8		iny				iny
.01a09c	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.01a09e	d0 ed		bne $01a08d			bne 	_FPGP_MaskLoop
.01a0a0	ae 9c 03	ldx $039c			ldx 	ExpTemp						; restore X
.01a0a3	28		plp				plp
.01a0a4	08		php				php 								; get action flag on the stack
.01a0a5	90 04		bcc $01a0ab			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.01a0a7	a9 00		lda #$00			lda 	#0
.01a0a9	95 85		sta $85,x			sta 	XS_Type,x
.01a0ab					_FPGP_NotFractional:
.01a0ab	b5 80		lda $80,x			lda 	XS_Mantissa,x 						; check if \1 zero
.01a0ad	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.01a0af	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01a0b1	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01a0b3	f0 05		beq $01a0ba			beq 	_FPGP_Zero 					; if zero, return zero
.01a0b5	20 aa a1	jsr $01a1aa			jsr 	FPUNormalise
.01a0b8	80 04		bra $01a0be			bra 	_FPGP_Exit 					; and exit
.01a0ba					_FPGP_Zero:
.01a0ba	a9 40		lda #$40			lda 	#$40 						; set zero flag
.01a0bc	95 85		sta $85,x			sta 	XS_Type,x
.01a0be					_FPGP_Exit:
.01a0be	68		pla				pla 								; throw saved action flag.
.01a0bf	7a		ply				ply
.01a0c0	68		pla				pla
.01a0c1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.01a0c2					FPCompare:
.01a0c2	20 03 a1	jsr $01a103			jsr 	FPFastCompare 				; fast compare try first
.01a0c5	b0 3b		bcs $01a102			bcs 	_FPCExit 					; that worked.
.01a0c7	b5 84		lda $84,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.01a0c9	48		pha				pha
.01a0ca	b5 8a		lda $8a,x			lda 	XS2_Exponent,x
.01a0cc	48		pha				pha
.01a0cd	20 95 9e	jsr $019e95			jsr 	FPSubtract 					; calculate X1-X2
.01a0d0	34 85		bit $85,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.01a0d2	70 2a		bvs $01a0fe			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.01a0d4	68		pla				pla
.01a0d5	8d 9c 03	sta $039c			sta 	ExpTemp						; save first exponent in temporary reg.
.01a0d8	68		pla				pla
.01a0d9	38		sec				sec
.01a0da	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; calculate AX-BX
.01a0dd	70 14		bvs $01a0f3			bvs 	_FPCNotEqual				; overflow, can't be equal.
.01a0df	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.01a0e0	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.01a0e2	b0 0f		bcs $01a0f3			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.01a0e4	38		sec				sec
.01a0e5	ad 9c 03	lda $039c			lda 	ExpTemp 					; get one of the exponents back.
.01a0e8	e9 12		sbc #$12			sbc 	#18 						; allow for 2^18 error, relatively.
.01a0ea	b0 02		bcs $01a0ee			bcs 	_FPCNotRange 				; keep in range.
.01a0ec	a9 01		lda #$01			lda 	#1
.01a0ee					_FPCNotRange:
.01a0ee	38		sec				sec
.01a0ef	f5 84		sbc $84,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.01a0f1	b0 0d		bcs $01a100			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.01a0f3					_FPCNotEqual:
.01a0f3	b5 85		lda $85,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.01a0f5	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.01a0f7	f0 02		beq $01a0fb			beq 	_FPCNE2
.01a0f9	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.01a0fb	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.01a0fc	80 04		bra $01a102			bra 	_FPCExit
.01a0fe					_FPCPullZero:
.01a0fe	68		pla				pla 								; throw saved exponents
.01a0ff	68		pla				pla
.01a100					_FPCZero:
.01a100	a9 00		lda #$00			lda 	#0 							; and return zero
.01a102					_FPCExit:
.01a102	60		rts				rts
.01a103					FPFastCompare:
.01a103	34 85		bit $85,x			bit 	XS_Type,x 					; n1 is zero.
.01a105	70 23		bvs $01a12a			bvs 	_FPFLeftZero
.01a107	34 8b		bit $8b,x			bit 	XS2_Type,x 					; n2 is zero
.01a109	b5 85		lda $85,x			lda 	XS_Type,x 					; if so, return sign bit of 1 (n-0)
.01a10b	70 25		bvs $01a132			bvs 	_FPFSignBit
.01a10d	55 8b		eor $8b,x			eor 	XS2_Type,x 					; eor 2 type bits. now know both non-zero
.01a10f	0a		asl a				asl 	a 							; put in CS if different.
.01a110	b5 85		lda $85,x			lda 	XS_Type,x 					; if signs different return sign of first
.01a112	b0 1e		bcs $01a132			bcs 	_FPFSignBit
.01a114	38		sec				sec 								; same sign and not-zero. compare exponents
.01a115	b5 84		lda $84,x			lda 	XS_Exponent,x 				; compare exponents. if the same, then fail.
.01a117	f5 8a		sbc $8a,x			sbc 	XS2_Exponent,x 				; e.g. we have to do it via subtraction.
.01a119	f0 09		beq $01a124			beq 	_FPNoFastCompare
.01a11b	6a		ror a				ror 	a 							; put carry into bit 7.
.01a11c	34 85		bit $85,x			bit 	XS_Type,X 					; if it is +x then flip it.
.01a11e	30 02		bmi $01a122			bmi		_FPFCNotMinus
.01a120	49 80		eor #$80			eor 	#$80
.01a122					_FPFCNotMinus:
.01a122	80 0e		bra $01a132			bra		_FPFSignBit
.01a124					_FPNoFastCompare:
.01a124	18		clc				clc
.01a125	60		rts				rts
.01a126					_FPFZero:
.01a126	a9 00		lda #$00			lda 	#0
.01a128					_FPFExitSet:
.01a128	38		sec				sec
.01a129	60		rts				rts
.01a12a					_FPFLeftZero:
.01a12a	34 8b		bit $8b,x			bit 	XS2_Type,x 					; if right is zero, return zero.
.01a12c	70 f8		bvs $01a126			bvs 	_FPFZero
.01a12e	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip sign bit
.01a130	49 80		eor #$80			eor 	#$80						; return that as a sign.
.01a132					_FPFSignBit:
.01a132	0a		asl a				asl 	a
.01a133	a9 01		lda #$01			lda 	#1
.01a135	90 f1		bcc $01a128			bcc		_FPFExitSet
.01a137	a9 ff		lda #$ff			lda 	#$FF
.01a139	38		sec				sec
.01a13a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.01a13b					FPUCopyX2ToX1:
.01a13b	48		pha				pha
.01a13c	da		phx				phx
.01a13d	5a		phy				phy
.01a13e	a0 08		ldy #$08			ldy 	#8
.01a140	b5 86		lda $86,x	_FPUC21:lda 	XS2_Mantissa,x
.01a142	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a144	e8		inx				inx
.01a145	88		dey				dey
.01a146	10 f8		bpl $01a140			bpl 	_FPUC21
.01a148	7a		ply				ply
.01a149	fa		plx				plx
.01a14a	68		pla				pla
.01a14b	60		rts				rts
.01a14c					FPUSetInteger:
.01a14c	48		pha				pha
.01a14d	95 80		sta $80,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.01a14f	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.01a151	10 02		bpl $01a155			bpl 	_FPUSIExtend
.01a153	a9 ff		lda #$ff			lda 	#$FF
.01a155					_FPUSIExtend:
.01a155	95 81		sta $81,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.01a157	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a159	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a15b	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.01a15d	95 85		sta $85,x			sta 	XS_Type,x
.01a15f	68		pla				pla
.01a160	60		rts				rts
.01a161					FPUNegateInteger:
.01a161	48		pha				pha
.01a162	38		sec				sec
.01a163	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.01a165	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.01a167	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a169	a9 00		lda #$00			lda 	#0
.01a16b	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.01a16d	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a16f	a9 00		lda #$00			lda 	#0
.01a171	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.01a173	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a175	a9 00		lda #$00			lda 	#0
.01a177	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.01a179	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a17b	68		pla				pla
.01a17c	60		rts				rts
.01a17d					FPUToFloat:
.01a17d	48		pha				pha
.01a17e	b5 85		lda $85,x			lda 	XS_Type,x					; exit if already float.
.01a180	29 0f		and #$0f			and 	#$0F
.01a182	f0 24		beq $01a1a8			beq 	_FPUFExit
.01a184	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.01a186	95 85		sta $85,x			sta 	XS_Type,x
.01a188	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.01a18a	95 84		sta $84,x			sta 	XS_Exponent,x 				; x mantissa.
.01a18c	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.01a18e	10 07		bpl $01a197			bpl		_FPUFPositive
.01a190	20 61 a1	jsr $01a161			jsr 	FPUNegateInteger 			; negate the mantissa
.01a193	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.01a195	95 85		sta $85,x			sta 	XS_Type,x
.01a197					_FPUFPositive:
.01a197	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.01a199	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.01a19b	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01a19d	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01a19f	d0 04		bne $01a1a5			bne 	_FPUFNonZero
.01a1a1	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.01a1a3	95 85		sta $85,x			sta 	XS_Type,x
.01a1a5					_FPUFNonZero:
.01a1a5	20 aa a1	jsr $01a1aa			jsr 	FPUNormalise 				; normalise the floating point.
.01a1a8					_FPUFExit:
.01a1a8	68		pla				pla
.01a1a9	60		rts				rts
.01a1aa					FPUNormalise:
.01a1aa	48		pha				pha
.01a1ab	34 85		bit $85,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.01a1ad	70 18		bvs $01a1c7			bvs 	_FPUNExit
.01a1af	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.01a1b1	f0 10		beq $01a1c3			beq 	_FPUNSetZero
.01a1b3					_FPUNLoop:
.01a1b3	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.01a1b5	30 10		bmi $01a1c7			bmi 	_FPUNExit 					; if so, we are normalised.
.01a1b7	16 80		asl $80,x			asl 	0+XS_Mantissa+0,x
.01a1b9	36 81		rol $81,x			rol 	1+XS_Mantissa+0,x
.01a1bb	36 82		rol $82,x			rol 	2+XS_Mantissa+0,x
.01a1bd	36 83		rol $83,x			rol 	3+XS_Mantissa+0,x
.01a1bf	d6 84		dec $84,x			dec 	XS_Exponent,x 				; decrement exponent
.01a1c1	d0 f0		bne $01a1b3			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.01a1c3					_FPUNSetZero:
.01a1c3	a9 40		lda #$40			lda 	#$40
.01a1c5	95 85		sta $85,x			sta 	XS_Type,x 					; the result is now zero.
.01a1c7					_FPUNExit:
.01a1c7	68		pla				pla
.01a1c8	60		rts				rts
.01a1c9					FPUToInteger:
.01a1c9	48		pha				pha
.01a1ca	b5 85		lda $85,x			lda 	XS_Type,x 					; if already integer, exit
.01a1cc	29 01		and #$01			and 	#1
.01a1ce	d0 31		bne $01a201			bne 	_FPUTOI_Exit
.01a1d0	34 85		bit $85,x			bit 	XS_Type,x					; if zero, return zero.
.01a1d2	70 23		bvs $01a1f7			bvs 	_FPUTOI_Zero
.01a1d4	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.01a1d6	10 1f		bpl $01a1f7			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.01a1d8	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.01a1da	b0 2b		bcs $01a207			bcs 	FP_Overflow
.01a1dc					_FPUToIToInteger:
.01a1dc	b5 84		lda $84,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.01a1de	c9 a0		cmp #$a0			cmp 	#128+32
.01a1e0	f0 0c		beq $01a1ee			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.01a1e2	f6 84		inc $84,x			inc 	XS_Exponent,X 				; increment Exponent
.01a1e4	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.01a1e6	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a1e8	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a1ea	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a1ec	80 ee		bra $01a1dc			bra 	_FPUToIToInteger 			; keep going.
.01a1ee					_FPUToICheckSign:
.01a1ee	b5 85		lda $85,x			lda 	XS_Type,x 					; check sign
.01a1f0	10 0f		bpl $01a201			bpl 	_FPUToI_Exit 				; exit if unsigned.
.01a1f2	20 61 a1	jsr $01a161			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.01a1f5	80 0a		bra $01a201			bra 	_FPUTOI_Exit
.01a1f7					_FPUTOI_Zero:
.01a1f7	a9 00		lda #$00			lda 	#0 							; return zero integer.
.01a1f9	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a1fb	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a1fd	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a1ff	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a201					_FPUToI_Exit:
.01a201	a9 01		lda #$01			lda 	#1 							; set type to integer
.01a203	95 85		sta $85,x			sta 	XS_Type,x
.01a205	68		pla				pla
.01a206	60		rts				rts
.01a207					FP_Overflow:
.01a207	20 4e 85	jsr $01854e			jsr ERR_Handler
>01a20a	46 6c 6f 61 74 69 6e 67			.text "Floating Point overflow",0
>01a212	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.01a222					FPUTimes10:
.01a222	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.01a224	85 1a		sta $1a				sta 	ZLTemp1+0
.01a226	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a228	85 1b		sta $1b				sta 	ZLTemp1+1
.01a22a	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a22c	85 1c		sta $1c				sta 	ZLTemp1+2
.01a22e	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a230	85 1d		sta $1d				sta 	ZLTemp1+3
.01a232	20 67 a2	jsr $01a267			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.01a235	20 67 a2	jsr $01a267			jsr 	_FPUT_LSR_ZLTemp1
.01a238	18		clc				clc
.01a239	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.01a23b	65 1a		adc $1a				adc 	ZLTemp1+0
.01a23d	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a23f	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a241	65 1b		adc $1b				adc 	ZLTemp1+1
.01a243	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a245	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a247	65 1c		adc $1c				adc 	ZLTemp1+2
.01a249	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a24b	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a24d	65 1d		adc $1d				adc 	ZLTemp1+3
.01a24f	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a251	90 0a		bcc $01a25d			bcc 	_FPUTimes10
.01a253	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.01a255	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a257	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a259	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a25b	f6 84		inc $84,x			inc 	XS_Exponent,x				; fix exponent
.01a25d					_FPUTimes10:
.01a25d	b5 84		lda $84,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.01a25f	18		clc				clc
.01a260	69 03		adc #$03			adc 	#3
.01a262	95 84		sta $84,x			sta 	XS_Exponent,x
.01a264	b0 a1		bcs $01a207			bcs 	FP_Overflow 				; error
.01a266	60		rts				rts
.01a267					_FPUT_LSR_ZLTemp1:
.01a267	46 1d		lsr $1d				lsr 	ZLTemp1+3
.01a269	66 1c		ror $1c				ror 	ZLTemp1+2
.01a26b	66 1b		ror $1b				ror 	ZLTemp1+1
.01a26d	66 1a		ror $1a				ror 	ZLTemp1+0
.01a26f	60		rts				rts
.01a270					FPUScale10A:
.01a270	5a		phy				phy
.01a271	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.01a273	f0 37		beq $01a2ac			beq 	_FPUScaleExit
.01a275	da		phx				phx 								; save X
.01a276	e8		inx				inx
.01a277	e8		inx				inx
.01a278	e8		inx				inx
.01a279	e8		inx				inx
.01a27a	e8		inx				inx
.01a27b	e8		inx				inx
.01a27c	a8		tay				tay 								; save power scalar in Y.
.01a27d	a9 00		lda #$00			lda 	#0
.01a27f	95 80		sta $80,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.01a281	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a283	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a285	95 85		sta $85,x			sta 	XS_Type,x
.01a287	a9 80		lda #$80			lda 	#$80
.01a289	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a28b	a9 81		lda #$81			lda 	#$81
.01a28d	95 84		sta $84,x			sta 	XS_Exponent,x
.01a28f	5a		phy				phy 								; save 10^n on stack.
.01a290	c0 00		cpy #$00			cpy 	#0
.01a292	10 05		bpl $01a299			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.01a294	98		tya				tya
.01a295	49 ff		eor #$ff			eor 	#$FF
.01a297	1a		inc a				inc 	a
.01a298	a8		tay				tay
.01a299					_FPUSAbs:
.01a299	20 22 a2	jsr $01a222			jsr 	FPUTimes10
.01a29c	88		dey				dey
.01a29d	d0 fa		bne $01a299			bne 	_FPUSAbs 					; tos is now 10^|AC|
.01a29f	68		pla				pla 								; restore count in A
.01a2a0	fa		plx				plx 								; restore X pointing to number to scale.
.01a2a1	0a		asl a				asl 	a
.01a2a2	b0 05		bcs $01a2a9			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.01a2a4	20 c4 9f	jsr $019fc4			jsr 	FPMultiply 					; if clear multiply.
.01a2a7	80 03		bra $01a2ac			bra		_FPUScaleExit
.01a2a9					_FPUSDivide:
.01a2a9	20 51 9f	jsr $019f51			jsr 	FPDivide
.01a2ac					_FPUScaleExit:
.01a2ac	7a		ply				ply
.01a2ad	60		rts				rts
.01a2ae					FPUCopyToNext:
.01a2ae	a0 06		ldy #$06			ldy 		#6
.01a2b0	da		phx				phx
.01a2b1					_FPUCopy1:
.01a2b1	b5 80		lda $80,x			lda 	XS_Mantissa,x
.01a2b3	95 86		sta $86,x			sta 	XS2_Mantissa,x
.01a2b5	e8		inx				inx
.01a2b6	88		dey				dey
.01a2b7	d0 f8		bne $01a2b1			bne 	_FPUCopy1
.01a2b9	fa		plx				plx
.01a2ba	60		rts				rts
.01a2bb					FPUCopyFromNext:
.01a2bb	a0 06		ldy #$06			ldy 		#6
.01a2bd	da		phx				phx
.01a2be					_FPUCopy1:
.01a2be	b5 86		lda $86,x			lda 	XS2_Mantissa,x
.01a2c0	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a2c2	e8		inx				inx
.01a2c3	88		dey				dey
.01a2c4	d0 f8		bne $01a2be			bne 	_FPUCopy1
.01a2c6	fa		plx				plx
.01a2c7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.01a2c8					FPToString:
.01a2c8	48		pha				pha
.01a2c9	5a		phy				phy
.01a2ca	34 85		bit $85,x			bit 		XS_Type,x 				; check zero flag
.01a2cc	50 0a		bvc $01a2d8			bvc 		_FPTSIsFloat 			; if zero,
.01a2ce					_FPTSZero:
.01a2ce	a9 30		lda #$30			lda 		#"0"
.01a2d0	20 f2 9d	jsr $019df2			jsr 		ITSOutputCharacter
.01a2d3					_FPTSExit:
.01a2d3	7a		ply				ply
.01a2d4	68		pla				pla
.01a2d5	60		rts				rts
.01a2d6	80 fb		bra $01a2d3			bra 		_FPTSExit
.01a2d8					_FPTSIsFloat:
.01a2d8	b5 85		lda $85,x			lda 		XS_Type,x 				; is it signed ?
.01a2da	10 09		bpl $01a2e5			bpl 		_FPTSNotSigned
.01a2dc	a9 00		lda #$00			lda 		#0 						; clear sign flag
.01a2de	95 85		sta $85,x			sta 		XS_Type,x
.01a2e0	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.01a2e2	20 f2 9d	jsr $019df2			jsr 		ITSOutputCharacter
.01a2e5					_FPTSNotSigned:
.01a2e5	b5 84		lda $84,x			lda 		XS_Exponent,x
.01a2e7	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.01a2e9	b0 09		bcs $01a2f4			bcs 		_FPTSExponent
.01a2eb	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.01a2ed	90 05		bcc $01a2f4			bcc 		_FPTSExponent 			;
.01a2ef					_FPTSStandard:
.01a2ef	20 33 a3	jsr $01a333			jsr 		FPTOutputBody 			; output the body.
.01a2f2	80 df		bra $01a2d3			bra 		_FPTSExit
.01a2f4					_FPTSExponent:
.01a2f4	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.01a2f6	8d 9d 03	sta $039d			sta 		ExpCount
.01a2f9					_FPTSExponentLoop:
.01a2f9	b5 84		lda $84,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.01a2fb	10 0e		bpl $01a30b			bpl 		_FPTSTimes
.01a2fd	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.01a2ff	90 14		bcc $01a315			bcc 		_FPTSScaledToExp
.01a301	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.01a303	20 70 a2	jsr $01a270			jsr 		FPUScale10A
.01a306	ee 9d 03	inc $039d			inc 		ExpCount
.01a309	80 ee		bra $01a2f9			bra 		_FPTSExponentLoop
.01a30b					_FPTSTimes:
.01a30b	a9 01		lda #$01			lda 		#1
.01a30d	20 70 a2	jsr $01a270			jsr 		FPUScale10A
.01a310	ce 9d 03	dec $039d			dec 		ExpCount
.01a313	80 e4		bra $01a2f9			bra 		_FPTSExponentLoop
.01a315					_FPTSScaledToExp:
.01a315	20 33 a3	jsr $01a333			jsr 		FPTOutputBody 			; output the body.
.01a318	a9 65		lda #$65			lda 		#"e"					; output E
.01a31a	20 f2 9d	jsr $019df2			jsr 		ITSOutputCharacter
.01a31d	ad 9d 03	lda $039d			lda 		ExpCount 				; get the exponent
.01a320	95 80		sta $80,x			sta 		XS_Mantissa,x
.01a322	29 80		and #$80			and 		#$80 					; sign extend it
.01a324	f0 02		beq $01a328			beq 		_FPTSSExt
.01a326	a9 ff		lda #$ff			lda 		#$FF
.01a328					_FPTSSExt:
.01a328	95 81		sta $81,x			sta 		XS_Mantissa+1,x
.01a32a	95 82		sta $82,x			sta 		XS_Mantissa+2,x
.01a32c	95 83		sta $83,x			sta 		XS_Mantissa+3,x
.01a32e	20 50 9d	jsr $019d50			jsr 		INTToString 			; output the exponent.
.01a331	80 a0		bra $01a2d3			bra			_FPTSExit 				; and exit.
.01a333					FPTOutputBody:
.01a333	20 ae a2	jsr $01a2ae			jsr 		FPUCopyToNext 			; copy to next slot.
.01a336	20 c9 a1	jsr $01a1c9			jsr 		FPUToInteger 			; convert to an integer
.01a339	20 50 9d	jsr $019d50			jsr 		INTToString 			; output the main integer part.
.01a33c	20 bb a2	jsr $01a2bb			jsr 		FPUCopyFromNext 		; get the fractional part back.
.01a33f	20 4c a0	jsr $01a04c			jsr 		FPFractionalPart 		; get the decimal part.
.01a342	34 85		bit $85,x			bit 		XS_Type,x 				; any fractional part.
.01a344	70 3c		bvs $01a382			bvs 		_FPTOExit 				; if not, exit now.
.01a346	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.01a348	20 f2 9d	jsr $019df2			jsr 		ITSOutputCharacter
.01a34b					_FPOutLoop:
.01a34b	34 85		bit $85,x			bit 		XS_Type,x 				; finally reached zero.
.01a34d	70 1d		bvs $01a36c			bvs 		_FPStripZeros 			; strip trailing zeros
.01a34f	20 22 a2	jsr $01a222			jsr 		FPUTimes10 				; multiply by 10
.01a352	20 ae a2	jsr $01a2ae			jsr 		FPUCopyToNext			; copy to next slot.
.01a355	20 c9 a1	jsr $01a1c9			jsr 		FPUToInteger 			; convert to integer
.01a358	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; print digit.
.01a35a	09 30		ora #$30			ora 		#"0"
.01a35c	20 f2 9d	jsr $019df2			jsr 		ITSOutputCharacter
.01a35f	20 bb a2	jsr $01a2bb			jsr 		FPUCopyFromNext 		; get it back
.01a362	20 4c a0	jsr $01a04c			jsr 		FPFractionalPart 		; get fractional part
.01a365	ad 14 03	lda $0314			lda 		NumBufX 				; done 11 characters yet ?
.01a368	c9 0b		cmp #$0b			cmp 	 	#11
.01a36a	90 df		bcc $01a34b			bcc 		_FPOutLoop 				; if so, keep going till zero.
.01a36c					_FPStripZeros:
.01a36c	ac 14 03	ldy $0314			ldy 		NumBufX 				; strip trailing zeros.
.01a36f					_FPStripLoop:
.01a36f	88		dey				dey 								; back one, if at start then no strip
.01a370	f0 10		beq $01a382			beq 		_FPToExit
.01a372	b9 15 03	lda $0315,y			lda 		Num_Buffer,y 			; keep going if "0"
.01a375	c9 30		cmp #$30			cmp 		#"0"
.01a377	f0 f6		beq $01a36f			beq 		_FPStripLoop
.01a379	c8		iny				iny
.01a37a	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.01a37c	99 15 03	sta $0315,y			sta 		Num_Buffer,y
.01a37f	8c 14 03	sty $0314			sty 		NumBufX 				; update position.
.01a382					_FPTOExit:
.01a382	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.01a383					FPFromString:
.01a383	48		pha				pha 								; push A
.01a384	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.01a386	c9 2e		cmp #$2e			cmp 	#"."
.01a388	f0 03		beq $01a38d			beq	 	_FPFIsDecimal
.01a38a	4c e9 a3	jmp $01a3e9			jmp 	_FPFNotDecimal
.01a38d					_FPFIsDecimal:
.01a38d	c8		iny				iny 								; consume the decimal.
.01a38e	20 7d a1	jsr $01a17d			jsr 	FPUToFloat 					; convert the integer to float.
.01a391	da		phx				phx 								; save X.
.01a392	5a		phy				phy 								; save decimal start position
.01a393	e8		inx				inx
.01a394	e8		inx				inx
.01a395	e8		inx				inx
.01a396	e8		inx				inx
.01a397	e8		inx				inx
.01a398	e8		inx				inx
.01a399	20 0a 9e	jsr $019e0a			jsr 	INTFromStringY 				; get the part after the DP.
.01a39c	20 7d a1	jsr $01a17d			jsr 	FPUToFloat 					; convert that to a float.
.01a39f	68		pla				pla 								; calculate - chars consumed.
.01a3a0	8c 9c 03	sty $039c			sty 	ExpTemp
.01a3a3	38		sec				sec
.01a3a4	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; this is the shift amount
.01a3a7	20 70 a2	jsr $01a270			jsr 	FPUScale10A 				; scale it by 10^AC
.01a3aa	fa		plx				plx 								; restore original X
.01a3ab	20 9d 9e	jsr $019e9d			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.01a3ae	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.01a3b0	c9 45		cmp #$45			cmp 	#"E"
.01a3b2	f0 04		beq $01a3b8			beq 	_FPFExponent
.01a3b4	c9 65		cmp #$65			cmp 	#"e"
.01a3b6	d0 31		bne $01a3e9			bne 	_FPFNotDecimal 				; no, then exit normally.
.01a3b8					_FPFExponent:
.01a3b8	c8		iny				iny 								; skip over E symbol.
.01a3b9	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.01a3bb	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.01a3bd	d0 01		bne $01a3c0			bne 	_FPFGotSign
.01a3bf	c8		iny				iny 								; if it was - skip over it.
.01a3c0					_FPFGotSign:
.01a3c0	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.01a3c1	da		phx				phx
.01a3c2	e8		inx				inx
.01a3c3	e8		inx				inx
.01a3c4	e8		inx				inx
.01a3c5	e8		inx				inx
.01a3c6	e8		inx				inx
.01a3c7	e8		inx				inx
.01a3c8	20 0a 9e	jsr $019e0a			jsr 	INTFromStringY 				; get the exponent
.01a3cb	fa		plx				plx 								; restore X.
.01a3cc	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.01a3ce	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.01a3d0	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.01a3d2	d0 17		bne $01a3eb			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.01a3d4	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.01a3d6	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.01a3d8	b0 11		bcs $01a3eb			bcs 	_FPFXOverflow
.01a3da	68		pla				pla 								; get direction
.01a3db	d0 07		bne $01a3e4			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.01a3dd	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.01a3df	49 ff		eor #$ff			eor 	#$FF
.01a3e1	1a		inc a				inc 	a
.01a3e2	95 86		sta $86,x			sta 	XS2_Mantissa+0,x
.01a3e4					_FPFXScale:
.01a3e4	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.01a3e6	20 70 a2	jsr $01a270			jsr 	FPUScale10A 				; scale by the exponent.
.01a3e9					_FPFNotDecimal:
.01a3e9	68		pla				pla
.01a3ea	60		rts				rts
.01a3eb					_FPFXOverflow:
.01a3eb	20 4e 85	jsr $01854e			jsr 	ERR_Handler
>01a3ee	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>01a3f6	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.01a3fd					Unary_Rnd:
.01a3fd	20 7d 91	jsr $01917d			jsr 	EvaluateNumberX 			; get value
.01a400	20 cd 97	jsr $0197cd			jsr 	CheckNextRParen 			; check right bracket.
.01a403	20 fb 93	jsr $0193fb			jsr 	GetSignCurrent 				; get sign -1,0,1.
.01a406	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.01a408	30 10		bmi $01a41a			bmi 	_URSetSeed
.01a40a	f0 28		beq $01a434			beq 	_URMakeRandom 				; if zero return same number.
.01a40c	da		phx				phx
.01a40d	a2 00		ldx #$00			ldx 	#0
.01a40f	20 6b a4	jsr $01a46b			jsr 	Random16
.01a412	a2 02		ldx #$02			ldx 	#2
.01a414	20 6b a4	jsr $01a46b			jsr 	Random16
.01a417	fa		plx				plx
.01a418	80 1a		bra $01a434			bra 	_URMakeRandom
.01a41a					_URSetSeed:
.01a41a	20 7d a1	jsr $01a17d			jsr 	FPUToFloat 					; make it a float to twiddle it.
.01a41d	b5 80		lda $80,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.01a41f	8d a3 03	sta $03a3			sta 	RandomSeed+0
.01a422	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.01a424	8d a4 03	sta $03a4			sta 	RandomSeed+1
.01a427	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.01a429	8d a5 03	sta $03a5			sta 	RandomSeed+2
.01a42c	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.01a42e	0a		asl a				asl 	a
.01a42f	49 db		eor #$db			eor 	#$DB
.01a431	8d a6 03	sta $03a6			sta 	RandomSeed+3
.01a434					_URMakeRandom:
.01a434	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; check if seed is zero.
.01a437	0d a4 03	ora $03a4			ora 	RandomSeed+1
.01a43a	0d a5 03	ora $03a5			ora 	RandomSeed+2
.01a43d	0d a6 03	ora $03a6			ora 	RandomSeed+3
.01a440	d0 0a		bne $01a44c			bne 	_URNotZero
.01a442	a9 47		lda #$47			lda 	#$47
.01a444	8d a4 03	sta $03a4			sta 	RandomSeed+1				; if it is, make it non zero.
.01a447	a9 3d		lda #$3d			lda 	#$3D
.01a449	8d a6 03	sta $03a6			sta 	RandomSeed+3
.01a44c					_URNotZero:
.01a44c	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; copy seed into mantissa.
.01a44f	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a451	ad a4 03	lda $03a4			lda 	RandomSeed+1
.01a454	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a456	ad a5 03	lda $03a5			lda 	RandomSeed+2
.01a459	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a45b	ad a6 03	lda $03a6			lda 	RandomSeed+3
.01a45e	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a460	a9 00		lda #$00			lda 	#$00 						; set type to float.
.01a462	95 85		sta $85,x			sta 	XS_Type,x
.01a464	a9 80		lda #$80			lda 	#$80
.01a466	95 84		sta $84,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.01a468	4c aa a1	jmp $01a1aa			jmp 	FPUNormalise
.01a46b					Random16:
.01a46b	5e a4 03	lsr $03a4,x			lsr 	RandomSeed+1,x				; shift seed right
.01a46e	7e a3 03	ror $03a3,x			ror 	RandomSeed,x
.01a471	90 08		bcc $01a47b			bcc 	_R16_NoXor
.01a473	bd a4 03	lda $03a4,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.01a476	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.01a478	9d a4 03	sta $03a4,x			sta 	RandomSeed+1,x
.01a47b					_R16_NoXor:
.01a47b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.01a47c					Unary_Int:
.01a47c	20 7d 91	jsr $01917d			jsr 	EvaluateNumberX 			; get value
.01a47f	20 cd 97	jsr $0197cd			jsr 	CheckNextRParen 			; check right bracket.
.01a482	4c c9 a1	jmp $01a1c9			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Return to file: basic.asm

>01a485	02						.byte 	2
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 c0						.word 	StartROM
>fffe	19 c0					.word TIM_BreakHandler

;******  End of listing
