
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Sun Sep  1 13:51:21 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="65816"				cpu = "65816"
="em65816"				hardware = "em65816"
=1					exitonend = 1
=0					autorun = 0
=1					loadtest = 1
=1					hasfloat = 1
=1					hasinteger = 1
=253					maxstring = 253

;******  Processing file: modules/basic/pointer/em65816/src_em65816.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stackmarkers.inc

=5					SourcePosSize   =   5 							; Source position stack space needed.
=1					SMark_Gosub 	= 	1 							; 0 is GOSUB/RETURN.
=2					SMark_Repeat 	= 	2 							; 1 is REPEAT/UNTIL.
=3					SMark_While 	= 	3 							; 2 is WHILE/WEND.
=4					SMark_If 		= 	4 							; 3 is IF/ENDIF
=5					SMark_For 		= 	5 							; 4 is FOR/NEXT

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/hardware/common/macros32.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0020					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0022					zVarDataPtr: .word ? 						; position of variable data.
>0024					zVarType: 	.byte ? 						; type of data (token)
>0025					zNullString:.byte ? 						; represents a NULL string.
>0026					zBasicSP:	.word ? 						; stack pointer
>0080					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>0084					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>0085					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=134					XS2_Mantissa = XS_Mantissa+XS_Size
=138					XS2_Exponent = XS_Exponent+XS_Size
=139					XS2_Type = XS_Type+XS_Size
=140					XS3_Mantissa = XS_Mantissa+XS_Size*2
=144					XS3_Exponent = XS_Exponent+XS_Size*2
=145					XS3_Type = XS_Type+XS_Size*2
>0300					StringPtr:	.word ? 						; Top of free memory (for string allocation)
>0302					VarMemPtr: 	.word ?							; Bottom of free memory (for variables)
>0304					endOfProgram: .dword ? 						; End of Program Memory (long)
>0308					vecPrintCharacter .word ?
>030a					vecInputCharacter .word ?
>030c					UserVector .fill 4 							; USR(x) calls this.
>0310					LocalVector .fill 4 						; Indirect calls call this.
>0314					NumBufX 	.byte 	?						; buffer index position
>0315					Num_Buffer	.fill 	32 						; buffer for numeric conversions
=6					HashTableCount = 6 							; there are 6 hash tables, in token order.
=8					HashTableSize = 8 							; each hash table as 8 links.
.0335					HashTableBase:
>0335								.fill	HashTableCount * HashTableSize * 2
.0395					HashTableEnd:
=$315					Var_Buffer 	= Num_Buffer 					; buffer for variable name (same space)
>0395					Var_Type    .byte ? 						; type of variable (as a type token)
>0396					Var_Hash 	.byte ? 						; hash of identifier name.
>0397					Var_Length 	.byte ? 						; length of variable name
>0398					Var_HashAddress .byte ?						; low byte of hash table entry.
>0399					Var_DataSize .byte ?						; size of one element.
>039a					NumSuppress	.byte 	?						; leading zero suppression flag
>039b					NumConvCount .byte 	? 						; count for conversions.
>039c					ExpTemp:	.byte ?							; Working temp for exponents.
>039d					ExpCount:	.byte ? 						; Count of decimal exponents.
>039e					SignCount:	.byte ?							; Integer Divide Sign Counts.
>039f					TempStringWriteIndex: .byte ? 				; Write offset.
>03a0					ValSign: 	.byte ? 						; sign flag for val()
>03a1					SliceStart:	.byte ? 						; string slice parts
>03a2					SliceCount:	.byte ?
>03a3					RandomSeed:	.dword ? 						; Random seed.
>03a7					SignNext:	.byte ? 						; Used for keeping sign of STEP in FOR/NEXT
>03a8					BreakCount:	.byte ? 						; Counter, avoid checking break every command.
=3					ArrayMaxDim = 3 							; number of dimensions.
>03a9					ArrayDef:	.fill (ArrayMaxDim+1)*2 		; dimensions for auto-creation
>03b1					UsrArrayDef:.fill (ArrayMaxDim+1)*2 		; dimensions created in DIM
>03b9					UsrArrayIdx:.byte ? 						; index into UsrArrayDef
>03ba					LastPrinted:.byte ? 						; last printed char ?
>03bb					ListIndent: .byte ? 						; list indent level
>03bc					LastListIndent:.byte ? 						; previous one.
>03bd					DataLPtr: 	.dword ?						; the data long ptr (swapped with zCodePtr)
>03c1					DataIndex:	.byte ?							; index position.
>03c2					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>03c4					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>03c6					Tim_SR:		.byte ? 						; Processor Status
>03c7					Tim_A:		.byte ? 						; Processor Registers
>03c8					Tim_X:		.byte ?
>03c9					Tim_Y:		.byte ?
>03ca					Tim_Z:		.byte ?
>03cb					Tim_SP:		.word ?							; Stack Pointer (just in cases)
>0400					BasicStack:	.fill 	256 					; and occupy whole pages.
.0500					EndBasicStack:
>0500					IFT_XCursor:.byte ?							; current logical position on screen
>0501					IFT_YCursor:.byte ?
>0502					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0566					IFT_LineBuffer: .fill 100 					; line input buffer.

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/em65816.asm

=$7f00					HighMemory = $7F00
=$3000					VariableMemory = $3000
.1000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testcode.src

>1000	05 0a 00 91 00 07 14 00			.byte	$05,$0a,$00,$91,$00,$07,$14,$00
>1008	dd 01 b7 00 13 1e 00 8f			.byte	$dd,$01,$b7,$00,$13,$1e,$00,$8f
>1010	01 b7 85 fe 02 93 d6 01			.byte	$01,$b7,$85,$fe,$02,$93,$d6,$01
>1018	b7 bf 9b 01 b7 be 00 06			.byte	$b7,$bf,$9b,$01,$b7,$be,$00,$06
>1020	28 00 96 40 00 05 32 00			.byte	$28,$00,$96,$40,$00,$05,$32,$00
>1028	c4 00 00				.byte	$c4,$00,$00

;******  Return to file: modules/hardware/em65816.asm

.c000					StartROM:
.c000	18		clc				clc
.c001	fb		xce				xce
.c002	c2 30		rep #$30			rep 	#$30
.c004	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.c007	1b		tcs				tcs
.c008	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.c00b	e2 30		sep #$30			sep 	#$30
.c00d	c2 30		rep #$30			rep 	#$30						; clear AXY in 16 bit.
.c00f	a9 00		lda #$00			lda 	#$0000
.c011	aa		tax				tax
.c012	a8		tay				tay
.c013	e2 30		sep #$30			sep 	#$30
.c015	5c 01 88 01	jmp $018801		jmp BASIC_Start
.c019					TIM_BreakHandler:
.c019	5c 69 83 01	jmp $018369			jmp 	TIM_BreakVector

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.018000					IFT_ClearScreen:
.018000	48		pha				pha
.018001	da		phx				phx
.018002	5a		phy				phy
.018003	20 9c 81	jsr $01819c			jsr 	IF_Home 					; home cursor
.018006	a2 20		ldx #$20			ldx 	#IF_Height 					; this many lines.
.018008					_IFT_CS0:
.018008	a0 40		ldy #$40			ldy 	#IF_Width 					; this many chars/line
.01800a					_IFT_CS1:
.01800a	a9 20		lda #$20			lda 	#' '						; clear line.
.01800c	20 c8 81	jsr $0181c8			jsr 	IF_Write
.01800f	88		dey				dey
.018010	d0 f8		bne $01800a			bne 	_IFT_CS1
.018012	20 af 81	jsr $0181af			jsr 	IF_NewLine 					; next line down
.018015	ca		dex				dex
.018016	d0 f0		bne $018008			bne 	_IFT_CS0
.018018	7a		ply				ply
.018019	fa		plx				plx
.01801a	68		pla				pla
.01801b					IFT_HomeCursor:
.01801b	48		pha				pha
.01801c	20 9c 81	jsr $01819c			jsr 	IF_Home
.01801f	a9 00		lda #$00			lda 	#0
.018021	8d 00 05	sta $0500			sta 	IFT_XCursor
.018024	8d 01 05	sta $0501			sta 	IFT_YCursor
.018027	68		pla				pla
.018028	60		rts				rts
.018029					IFT_UpLine:
.018029	48		pha				pha
.01802a	ad 01 05	lda $0501			lda  	IFT_YCursor 				; get Y
.01802d	3a		dec a				dec 	a 							; line above
.01802e	30 03		bmi $018033			bmi 	_IFTULExit 					; too far, abort
.018030	20 be 80	jsr $0180be			jsr 	IFT_SetYPos					; set to that line.
.018033					_IFTULExit:
.018033	68		pla				pla
.018034	60		rts				rts
.018035					IFT_PrintCharacter:
.018035	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.018037	f0 16		beq $01804f			beq 	IFT_NewLine
.018039	48		pha				pha
.01803a	20 67 80	jsr $018067			jsr 	IFT_UpperCase 				; make upper case
.01803d	20 c8 81	jsr $0181c8			jsr 	IF_Write 					; write out.
.018040	ee 00 05	inc $0500			inc 	IFT_XCursor 				; bump x cursor
.018043	ad 00 05	lda $0500			lda 	IFT_XCursor 				; reached RHS ?
.018046	c9 40		cmp #$40			cmp 	#IF_Width
.018048	d0 03		bne $01804d			bne 	_IFT_PCNotEOL
.01804a	20 4f 80	jsr $01804f			jsr 	IFT_NewLine 				; if so do new line.
.01804d					_IFT_PCNotEOL:
.01804d	68		pla				pla
.01804e	60		rts				rts
.01804f					IFT_NewLine:
.01804f	48		pha				pha
.018050	20 af 81	jsr $0181af			jsr 	IF_NewLine 					; new line on actual screen.
.018053	a9 00		lda #$00			lda 	#0 							; reset x position
.018055	8d 00 05	sta $0500			sta 	IFT_XCursor
.018058	ee 01 05	inc $0501			inc 	IFT_YCursor 				; move down.
.01805b	ad 01 05	lda $0501			lda 	IFT_YCursor
.01805e	c9 20		cmp #$20			cmp 	#IF_Height 					; reached bottom.
.018060	d0 03		bne $018065			bne 	_IFT_NL_NotEOS
.018062	20 72 80	jsr $018072			jsr 	IFT_Scroll 					; scroll screen up.
.018065					_IFT_NL_NotEOS:
.018065	68		pla				pla
.018066	60		rts				rts
.018067					IFT_UpperCase:
.018067	c9 61		cmp #$61			cmp 	#"a"
.018069	90 06		bcc $018071			bcc 	_IFT_UCExit
.01806b	c9 7b		cmp #$7b			cmp 	#"z"+1
.01806d	b0 02		bcs $018071			bcs 	_IFT_UCExit
.01806f	49 20		eor #$20			eor 	#$20
.018071					_IFT_UCExit:
.018071	60		rts				rts
.018072					IFT_Scroll:
.018072	48		pha				pha 								; save AXY
.018073	da		phx				phx
.018074	5a		phy				phy
.018075	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.018077					_IFT_SLoop:
.018077	20 97 80	jsr $018097			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.01807a	e8		inx				inx
.01807b	e0 1f		cpx #$1f			cpx 	#IF_Height-1				; do whole screen
.01807d	d0 f8		bne $018077			bne 	_IFT_SLoop
.01807f	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.018081	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.018084	a2 40		ldx #$40			ldx 	#IF_Width 					; blank line
.018086					_IFT_SBlank:
.018086	a9 20		lda #$20			lda 	#32
.018088	20 c8 81	jsr $0181c8			jsr 	IF_Write
.01808b	ca		dex				dex
.01808c	d0 f8		bne $018086			bne 	_IFT_SBlank
.01808e	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.018090	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.018093	7a		ply				ply
.018094	fa		plx				plx
.018095	68		pla				pla
.018096	60		rts				rts
.018097					_IFT_ScrollLine:
.018097	da		phx				phx
.018098	da		phx				phx
.018099	8a		txa				txa 								; copy line into buffer.
.01809a	1a		inc a				inc 	a 							; next line down.
.01809b	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.01809e	a2 00		ldx #$00			ldx 	#0
.0180a0					_IFTScrollCopy1:
.0180a0	20 bf 81	jsr $0181bf			jsr 	IF_Read
.0180a3	9d 02 05	sta $0502,x			sta 	IFT_Buffer,x
.0180a6	e8		inx				inx
.0180a7	e0 40		cpx #$40			cpx 	#IF_Width
.0180a9	d0 f5		bne $0180a0			bne 	_IFTScrollCopy1
.0180ab	68		pla				pla
.0180ac	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.0180af	a2 00		ldx #$00			ldx 	#0
.0180b1					_IFTScrollCopy2:
.0180b1	bd 02 05	lda $0502,x			lda 	IFT_Buffer,x
.0180b4	20 c8 81	jsr $0181c8			jsr 	IF_Write
.0180b7	e8		inx				inx
.0180b8	e0 40		cpx #$40			cpx 	#IF_Width
.0180ba	d0 f5		bne $0180b1			bne 	_IFTScrollCopy2
.0180bc	fa		plx				plx
.0180bd	60		rts				rts
.0180be					IFT_SetYPos:
.0180be	48		pha				pha
.0180bf	da		phx				phx
.0180c0	aa		tax				tax
.0180c1	20 1b 80	jsr $01801b			jsr 	IFT_HomeCursor
.0180c4	e0 00		cpx #$00			cpx 	#0
.0180c6	f0 09		beq $0180d1			beq 	_IFT_MOAExit
.0180c8					_IFT_MOALoop:
.0180c8	20 af 81	jsr $0181af			jsr 	IF_NewLine
.0180cb	ee 01 05	inc $0501			inc 	IFT_YCursor
.0180ce	ca		dex				dex
.0180cf	d0 f7		bne $0180c8			bne		_IFT_MOALoop
.0180d1					_IFT_MOAExit:
.0180d1	fa		plx				plx
.0180d2	68		pla				pla
.0180d3	60		rts				rts
.0180d4					IFT_GetKeyCursor:
.0180d4	20 dc 80	jsr $0180dc			jsr 	_IFT_FlipCursor 			; reverse current
.0180d7					_IFT_GKCWait:
.0180d7	20 d9 81	jsr $0181d9			jsr 	IF_GetKey 					; get key
.0180da	f0 fb		beq $0180d7			beq 	_IFT_GKCWait
.0180dc					_IFT_FlipCursor:
.0180dc	48		pha				pha 								; save
.0180dd	20 bf 81	jsr $0181bf			jsr 	IF_Read 					; read
.0180e0	20 d1 81	jsr $0181d1			jsr 	IF_LeftOne
.0180e3	49 80		eor #$80			eor 	#$80 						; reverse
.0180e5	20 c8 81	jsr $0181c8			jsr 	IF_Write 					; write
.0180e8	20 d1 81	jsr $0181d1			jsr 	IF_LeftOne
.0180eb	68		pla				pla
.0180ec	60		rts				rts
.0180ed					IFT_ReadLine:
.0180ed	48		pha				pha
.0180ee					_IFT_RLLoop:
.0180ee	20 d4 80	jsr $0180d4			jsr 	IFT_GetKeyCursor 			; get keystroke
.0180f1	c9 0d		cmp #$0d			cmp 	#13							; return
.0180f3	f0 7d		beq $018172			beq 	_IFT_RLExit
.0180f5	c9 20		cmp #$20			cmp 	#32 						; control character
.0180f7	90 05		bcc $0180fe			bcc 	_IFT_Control
.0180f9	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0180fc	80 f0		bra $0180ee			bra 	_IFT_RLLoop
.0180fe					_IFT_Control:
.0180fe	c9 01		cmp #$01			cmp 	#"A"-64
.018100	f0 26		beq $018128			beq 	_IFT_Left
.018102	c9 04		cmp #$04			cmp 	#"D"-64
.018104	f0 2e		beq $018134			beq 	_IFT_Right
.018106	c9 17		cmp #$17			cmp 	#"W"-64
.018108	f0 36		beq $018140			beq 	_IFT_Up
.01810a	c9 13		cmp #$13			cmp 	#"S"-64
.01810c	f0 3e		beq $01814c			beq 	_IFT_Down
.01810e	c9 08		cmp #$08			cmp 	#"H"-64
.018110	f0 09		beq $01811b			beq 	_IFT_Backspace
.018112	c9 1a		cmp #$1a			cmp 	#"Z"-64
.018114	d0 d8		bne $0180ee			bne 	_IFT_RLLoop
.018116	20 00 80	jsr $018000			jsr 	IFT_ClearScreen				; clear CTL-Z
.018119	80 d3		bra $0180ee			bra 	_IFT_RLLoop
.01811b					_IFT_Backspace:
.01811b	ad 00 05	lda $0500			lda 	IFT_XCursor 				; check not start of line.
.01811e	f0 ce		beq $0180ee			beq 	_IFT_RLLoop
.018120	20 d1 81	jsr $0181d1			jsr 	IF_LeftOne
.018123	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.018125	20 c8 81	jsr $0181c8			jsr 	IF_Write
.018128					_IFT_Left:
.018128	ce 00 05	dec $0500			dec 	IFT_XCursor 				; left CTL-W
.01812b	10 29		bpl $018156			bpl 	_IFT_Reposition
.01812d	a9 3f		lda #$3f			lda 	#IF_Width-1
.01812f					_IFT_SetX:
.01812f	8d 00 05	sta $0500			sta 	IFT_XCursor
.018132	80 22		bra $018156			bra 	_IFT_Reposition
.018134					_IFT_Right:
.018134	ee 00 05	inc $0500			inc 	IFT_XCursor
.018137	ad 00 05	lda $0500			lda 	IFT_XCursor
.01813a	49 40		eor #$40			eor 	#IF_Width
.01813c	f0 f1		beq $01812f			beq 	_IFT_SetX
.01813e	80 16		bra $018156			bra 	_IFT_Reposition
.018140					_IFT_Up:
.018140	ce 01 05	dec $0501			dec 	IFT_YCursor
.018143	10 11		bpl $018156			bpl 	_IFT_Reposition
.018145	a9 1f		lda #$1f			lda 	#IF_Height-1
.018147					_IFT_SetY:
.018147	8d 01 05	sta $0501			sta 	IFT_YCursor
.01814a	80 0a		bra $018156			bra 	_IFT_Reposition
.01814c					_IFT_Down:
.01814c	ee 01 05	inc $0501			inc 	IFT_YCursor
.01814f	ad 01 05	lda $0501			lda 	IFT_YCursor
.018152	49 20		eor #$20			eor 	#IF_Height
.018154	f0 f1		beq $018147			beq 	_IFT_SetY
.018156					_IFT_Reposition:
.018156	ad 00 05	lda $0500			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.018159	48		pha				pha
.01815a	ad 01 05	lda $0501			lda 	IFT_YCursor
.01815d	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.018160	68		pla				pla
.018161	aa		tax				tax
.018162	e0 00		cpx #$00			cpx 	#0
.018164	f0 88		beq $0180ee			beq 	_IFT_RLLoop
.018166					_IFT_MoveRight:
.018166	20 bf 81	jsr $0181bf			jsr 	IF_Read
.018169	ee 00 05	inc $0500			inc 	IFT_XCursor
.01816c	ca		dex				dex
.01816d	d0 f7		bne $018166			bne 	_IFT_MoveRight
.01816f	4c ee 80	jmp $0180ee			jmp 	_IFT_RLLoop
.018172					_IFT_RLExit:
.018172	ad 01 05	lda $0501			lda 	IFT_YCursor 				; go to start of line.
.018175	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.018178	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.01817a					_IFT_RLRead:
.01817a	20 bf 81	jsr $0181bf			jsr 	IF_Read
.01817d	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.018180	e8		inx				inx
.018181	e0 40		cpx #$40			cpx 	#IF_Width
.018183	d0 f5		bne $01817a			bne 	_IFT_RLRead
.018185					_IFT_RL_Trim:
.018185	ca		dex				dex 	 							; previous char
.018186	30 07		bmi $01818f			bmi 	_IFT_Found 					; gone too far
.018188	bd 66 05	lda $0566,x			lda 	IFT_LineBuffer,x			; go back if space
.01818b	c9 20		cmp #$20			cmp 	#" "
.01818d	f0 f6		beq $018185			beq 	_IFT_RL_Trim
.01818f					_IFT_Found:
.01818f	e8		inx				inx 								; forward to non-space
.018190	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.018192	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.018195	68		pla				pla
.018196	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.018198	a0 05		ldy #$05			ldy 	#IFT_LineBuffer >> 8
.01819a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_em65816.asm

=64					IF_Width 	= 64 							; characters across
=32					IF_Height 	= 32 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line.
=8					IF_XPos 	= 8 							; current position, horizontal.
=$f0000					IF_Screen = $F0000							; 2k screen RAM here
=$f8010					IF_PKeyboard = $F8010						; Keyboard port.
=$f8000					IF_PBreak = $F8000 							; Break key.
.01819b					IF_Reset:
.01819b	60		rts				rts
.01819c					IF_Home:
.01819c	48		pha				pha
.01819d	64 08		stz $08				stz 	IF_XPos 					; zero X position
.01819f	a9 00		lda #$00			lda 	#IF_Screen & $FF 			; set r/w pos.
.0181a1	85 04		sta $04				sta 	IF_Pos
.0181a3	a9 00		lda #$00			lda 	#(IF_Screen >> 8) & $FF
.0181a5	85 05		sta $05				sta 	IF_Pos+1
.0181a7	a9 0f		lda #$0f			lda 	#IF_Screen >> 16
.0181a9	85 06		sta $06				sta 	IF_Pos+2
.0181ab	64 07		stz $07				stz 	IF_Pos+3
.0181ad	68		pla				pla
.0181ae	60		rts				rts
.0181af					IF_NewLine:
.0181af	48		pha				pha
.0181b0	64 08		stz $08				stz 	IF_XPos						; back to start of line
.0181b2	18		clc				clc 								; down one line
.0181b3	a5 04		lda $04				lda 	IF_Pos
.0181b5	69 40		adc #$40			adc 	#64
.0181b7	85 04		sta $04				sta 	IF_Pos
.0181b9	90 02		bcc $0181bd			bcc 	_IF_NoCarry 				; carry through.
.0181bb	e6 05		inc $05				inc 	IF_Pos+1
.0181bd					_IF_NoCarry:
.0181bd	68		pla				pla
.0181be	60		rts				rts
.0181bf					IF_Read:
.0181bf	5a		phy				phy 								; save current Y
.0181c0	a4 08		ldy $08				ldy 	IF_XPos 					; read character at current position
.0181c2	b7 04		lda [$04],y			lda 	[IF_Pos],y
.0181c4	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181c6	7a		ply				ply									; restore Y
.0181c7	60		rts				rts
.0181c8					IF_Write:
.0181c8	5a		phy				phy 								; save current Y
.0181c9	a4 08		ldy $08				ldy 	IF_XPos 					; write character at current position
.0181cb	97 04		sta [$04],y			sta 	[IF_Pos],y
.0181cd	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181cf	7a		ply				ply									; restore Y
.0181d0	60		rts				rts
.0181d1					IF_LeftOne:
.0181d1	c6 08		dec $08				dec 	IF_XPos
.0181d3	60		rts				rts
.0181d4					IF_CheckBreak:
.0181d4	af 00 80 0f	lda $0f8000			lda 	IF_PBreak					; non-zero if Ctrl+C pressed.
.0181d8	60		rts				rts
.0181d9					IF_GetKey:
.0181d9	af 10 80 0f	lda $0f8010			lda 	IF_PKeyboard				; read keyboard
.0181dd	f0 08		beq $0181e7			beq		_IFGK_NoKey 				; skip if zero,no key pressed
.0181df	48		pha				pha 								; key pressed, clear queue.
.0181e0	a9 00		lda #$00			lda 	#0
.0181e2	8f 10 80 0f	sta $0f8010			sta 	IF_PKeyboard
.0181e6	68		pla				pla
.0181e7					_IFGK_NoKey:
.0181e7	09 00		ora #$00			ora 	#0							; set Z flag appropriately.
.0181e9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.0181ea					TIM_Error:
.0181ea	20 29 80	jsr $018029			jsr 	IFT_UpLine 					; go up one line.
.0181ed	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.0181ef	80 02		bra $0181f3			bra 	TIM_ShowPrompt
.0181f1					TIM_NewCommand:
.0181f1	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.0181f3					TIM_ShowPrompt:
.0181f3	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.0181f6	20 ed 80	jsr $0180ed			jsr 	IFT_ReadLine	 			; get character, go to next line
.0181f9	20 4f 80	jsr $01804f			jsr 	IFT_NewLine					; go to next line.
.0181fc	86 10		stx $10				stx 	zTemp1 						; save line read address
.0181fe	84 11		sty $11				sty 	zTemp1+1
.018200	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.018202	b1 10		lda ($10),y			lda 	(zTemp1),y
.018204	c9 3f		cmp #$3f			cmp 	#"?"
.018206	f0 04		beq $01820c			beq 	TIM_SkipFirst
.018208	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.01820a	d0 01		bne $01820d			bne 	TIM_NotDot
.01820c					TIM_SkipFirst:
.01820c	c8		iny				iny
.01820d					TIM_NotDot:
.01820d	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.01820f	c9 52		cmp #$52			cmp 	#"R"						; show registers
.018211	f0 6b		beq $01827e			beq 	TIM_ShowRegisters
.018213	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.018215	f0 12		beq $018229			beq 	TIM_ShowMemory
.018217	c9 47		cmp #$47			cmp 	#"G"						; execute
.018219	f0 49		beq $018264			beq 	TIM_Execute
.01821b	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.01821d	f0 07		beq $018226			beq 	TIM_GoLoadMemory
.01821f	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.018221	d0 c7		bne $0181ea			bne 	TIM_Error
.018223	4c a2 83	jmp $0183a2			jmp 	TIM_UpdateRegisters
.018226					TIM_GoLoadMemory:
.018226	4c d2 83	jmp $0183d2			jmp 	TIM_LoadMemory
.018229					TIM_ShowMemory:
.018229	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.01822c	b0 bc		bcs $0181ea			bcs 	TIM_Error
.01822e	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.018230	85 12		sta $12				sta 	zTemp2
.018232	a5 15		lda $15				lda 	zTemp3+1
.018234	85 13		sta $13				sta 	zTemp2+1
.018236	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.018239	90 08		bcc $018243			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.01823b	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.01823d	85 14		sta $14				sta 	zTemp3
.01823f	a5 13		lda $13				lda 	zTemp2+1
.018241	85 15		sta $15				sta 	zTemp3+1
.018243					_TIMSM_Start:
.018243	20 f6 82	jsr $0182f6			jsr 	TIM_WriteLine 				; write one line of hex out
.018246	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.018248	18		clc				clc
.018249	69 10		adc #$10			adc 	#16
.01824b	85 12		sta $12				sta 	zTemp2
.01824d	90 02		bcc $018251			bcc 	_TIMSM_NoCarry
.01824f	e6 13		inc $13				inc 	zTemp2+1
.018251					_TIMSM_NoCarry:
.018251	20 d4 81	jsr $0181d4			jsr 	IF_CheckBreak 				; check CTL+C
.018254	d0 0b		bne $018261			bne 	_TIMSM_Ends 				; if pressed break out.
.018256	38		sec				sec 								; check past the end address in zTemp3
.018257	a5 14		lda $14				lda 	zTemp3
.018259	e5 12		sbc $12				sbc 	zTemp2
.01825b	a5 15		lda $15				lda 	zTemp3+1
.01825d	e5 13		sbc $13				sbc 	zTemp2+1
.01825f	10 e2		bpl $018243			bpl 	_TIMSM_Start
.018261					_TIMSM_Ends:
.018261	4c f1 81	jmp $0181f1			jmp 	TIM_NewCommand
.018264					TIM_Execute:
.018264	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; get the execute address
.018267	b0 81		bcs $0181ea			bcs 	TIM_Error 					; not legitimate
.018269	ae cb 03	ldx $03cb			ldx 	TIM_SP 						; set up SP
.01826c	9a		txs				txs
.01826d	ad c6 03	lda $03c6			lda 	TIM_SR 						; Status for PLP
.018270	48		pha				pha
.018271	ad c7 03	lda $03c7			lda 	TIM_A 						; restore AXYZ
.018274	ae c8 03	ldx $03c8			ldx 	TIM_X
.018277	ac c9 03	ldy $03c9			ldy 	TIM_Y
.01827a	28		plp				plp 								; and PS Byte.
.01827b	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.01827e					TIM_Start:
.01827e					TIM_ShowRegisters:
.01827e	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.018281	8d c5 03	sta $03c5			sta 	TIM_IRQ+1
.018284	ad ff ff	lda $ffff			lda 	$FFFF
.018287	8d c4 03	sta $03c4			sta 	TIM_IRQ
.01828a	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.01828c					_TIMSR_Text:
.01828c	bf bd 82 01	lda $0182bd,x			lda 	_TIMSR_Label,x
.018290	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018293	e8		inx				inx
.018294	e0 20		cpx #$20			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.018296	d0 f4		bne $01828c			bne 	_TIMSR_Text
.018298	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.01829a					_TIMSR_Skip:
.01829a	e8		inx				inx
.01829b					_TIMSR_LoopSpace:
.01829b	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.01829d	b0 04		bcs $0182a3			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.01829f	8a		txa				txa
.0182a0	4a		lsr a				lsr 	a
.0182a1	b0 05		bcs $0182a8			bcs 	_TIMSR_NoSpace
.0182a3					_TIMSR_Space:
.0182a3	a9 20		lda #$20			lda 	#" "
.0182a5	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182a8					_TIMSR_NoSpace:
.0182a8	bd c2 03	lda $03c2,x			lda 	TIM_PC,x 					; output hex value.
.0182ab	20 dd 82	jsr $0182dd			jsr 	TIM_WriteHex
.0182ae	e8		inx				inx
.0182af	e0 08		cpx #$08			cpx 	#TIM_Z-TIM_PC
.0182b1	f0 e7		beq $01829a			beq 	_TIMSR_Skip
.0182b3	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.0182b5	d0 e4		bne $01829b			bne 	_TimSR_LoopSpace
.0182b7	20 4f 80	jsr $01804f			jsr 	IFT_NewLine 				; new line
.0182ba	4c f1 81	jmp $0181f1			jmp	 	TIM_NewCommand 				; new command.
.0182bd					_TIMSR_Label:
>0182bd	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>0182c5	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>0182d5	52
>0182d6	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.0182dd					_TIMSR_LabelEnd:
.0182dd					TIM_WriteHex:
.0182dd	48		pha				pha 								; save A
.0182de	4a		lsr a				lsr 	a 							; shift MSB->LSB
.0182df	4a		lsr a				lsr 	a
.0182e0	4a		lsr a				lsr 	a
.0182e1	4a		lsr a				lsr 	a
.0182e2	20 e6 82	jsr $0182e6			jsr 	_TIMWH_Nibble 				; print MSB
.0182e5	68		pla				pla 								; restore and print LSB
.0182e6					_TIMWH_Nibble:
.0182e6	48		pha				pha
.0182e7	29 0f		and #$0f			and 	#15 						; mask out
.0182e9	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.0182eb	90 02		bcc $0182ef			bcc 	_TIMWHNoLetter
.0182ed	69 06		adc #$06			adc 	#6
.0182ef					_TIMWHNoLetter:
.0182ef	69 30		adc #$30			adc 	#48
.0182f1	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter 			; print it out.
.0182f4	68		pla				pla
.0182f5	60		rts				rts
.0182f6					TIM_WriteLine:
.0182f6	a9 2e		lda #$2e			lda 	#"." 						; prompt
.0182f8	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182fb	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.0182fd	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018300	a5 13		lda $13				lda 	zTemp2+1 					; write address
.018302	20 dd 82	jsr $0182dd			jsr 	TIM_WriteHex
.018305	a5 12		lda $12				lda 	zTemp2
.018307	20 dd 82	jsr $0182dd			jsr 	TIM_WriteHex
.01830a	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.01830c					_TIMWL_Loop:
.01830c	a9 20		lda #$20			lda 	#" "
.01830e	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018311	b1 12		lda ($12),y			lda 	(zTemp2),y
.018313	20 dd 82	jsr $0182dd			jsr 	TIM_WriteHex
.018316	c8		iny				iny
.018317	c0 10		cpy #$10			cpy 	#16
.018319	d0 f1		bne $01830c			bne 	_TIMWL_Loop
.01831b	4c 4f 80	jmp $01804f			jmp 	IFT_NewLine 				; new line and exit
.01831e					TIM_GetHex:
.01831e	c8		iny				iny
.01831f	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.018321	c9 20		cmp #$20			cmp 	#32
.018323	f0 f9		beq $01831e			beq 	TIM_GetHex
.018325	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.018327	f0 f5		beq $01831e			beq 	TIM_GetHex
.018329	20 52 83	jsr $018352			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.01832c	b0 23		bcs $018351			bcs 	_TIMGH_Exit					; if first bad then exit now.
.01832e	a9 00		lda #$00			lda 	#0 							; zero result
.018330	85 14		sta $14				sta 	zTemp3
.018332	85 15		sta $15				sta 	zTemp3+1
.018334					_TIM_GHLoop:
.018334	20 52 83	jsr $018352			jsr 	TIM_GetHexCharacter 		; get next character
.018337	b0 17		bcs $018350			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.018339	c8		iny				iny 								; skip over it.
.01833a	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.01833c	26 15		rol $15				rol 	zTemp3+1
.01833e	06 14		asl $14				asl 	zTemp3 						; now x 2
.018340	26 15		rol $15				rol 	zTemp3+1
.018342	06 14		asl $14				asl 	zTemp3						; now x 4
.018344	26 15		rol $15				rol 	zTemp3+1
.018346	06 14		asl $14				asl 	zTemp3 						; now x 8
.018348	26 15		rol $15				rol 	zTemp3+1
.01834a	05 14		ora $14				ora 	zTemp3 						; OR result in
.01834c	85 14		sta $14				sta 	zTemp3
.01834e	80 e4		bra $018334			bra 	_TIM_GHLoop 				; loop round again.
.018350					_TIMGH_Okay:
.018350	18		clc				clc
.018351					_TIMGH_Exit:
.018351	60		rts				rts
.018352					TIM_GetHexCharacter:
.018352	b1 10		lda ($10),y			lda 	(zTemp1),y
.018354	38		sec				sec
.018355	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.018357	90 0e		bcc $018367			bcc 	_TIM_GHCFail
.018359	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.01835b	90 0b		bcc $018368			bcc 	_TIM_GHCExit
.01835d	c9 11		cmp #$11			cmp 	#65-48						; < A
.01835f	90 06		bcc $018367			bcc		_TIM_GHCFail
.018361	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.018363	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.018365	90 01		bcc $018368			bcc		_TIM_GHCExit
.018367					_TIM_GHCFail:
.018367	38		sec				sec
.018368					_TIM_GHCExit:
.018368	60		rts				rts
.018369					TIM_BreakVector:
.018369	da		phx				phx									; save X/A on stack
.01836a	48		pha				pha
.01836b	ba		tsx				tsx 								; X points to S
.01836c	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.01836f	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.018371	d0 03		bne $018376			bne 	_TIMBreak					; if set, it's BRK
.018373	68		pla				pla 								; abandon routine.
.018374	fa		plx				plx
.018375	40		rti				rti
.018376					_TIMBreak:
.018376	68		pla				pla 								; save A X Y and maybe Z
.018377	8d c7 03	sta $03c7			sta 	TIM_A
.01837a	fa		plx				plx
.01837b	8e c8 03	stx $03c8			stx 	TIM_X
.01837e	8c c9 03	sty $03c9			sty 	TIM_Y
.018381	68		pla				pla 								; get Status Register
.018382	8d c6 03	sta $03c6			sta 	TIM_SR
.018385	68		pla				pla
.018386	8d c3 03	sta $03c3			sta 	TIM_PC+1 					; save calling address
.018389	68		pla				pla
.01838a	8d c2 03	sta $03c2			sta 	TIM_PC 						; high byte
.01838d	ad c3 03	lda $03c3			lda 	TIM_PC+1 					; dec PC to point right.
.018390	d0 03		bne $018395			bne 	_TIMDecrement 				; brk bumps it.
.018392	ce c2 03	dec $03c2			dec 	TIM_PC
.018395					_TIMDecrement:
.018395	ce c3 03	dec $03c3			dec 	TIM_PC+1
.018398	ba		tsx				tsx 								; and copy SP
.018399	8e cb 03	stx $03cb			stx 	TIM_SP
.01839c	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.01839e	9a		txs				txs
.01839f	4c 7e 82	jmp $01827e			jmp 	TIM_Start 					; and start up TIM monitor.
.0183a2					TIM_UpdateRegisters:
.0183a2	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; PC
.0183a5	b0 28		bcs $0183cf			bcs 	_TIMURFail
.0183a7	a5 14		lda $14				lda 	zTemp3
.0183a9	8d c3 03	sta $03c3			sta 	Tim_PC+1
.0183ac	a5 15		lda $15				lda 	zTemp3+1
.0183ae	8d c2 03	sta $03c2			sta 	Tim_PC
.0183b1	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; ignore IRQ
.0183b4	b0 19		bcs $0183cf			bcs 	_TIMURFail
.0183b6	a2 00		ldx #$00			ldx 	#0
.0183b8					_TIM_URLoop:
.0183b8	e0 04		cpx #$04			cpx 	#Tim_Z-Tim_SR
.0183ba	d0 01		bne $0183bd			bne 	_TIM_1
.0183bc	e8		inx				inx
.0183bd					_TIM_1:
.0183bd	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; registers
.0183c0	b0 0d		bcs $0183cf			bcs 	_TIMURFail
.0183c2	a5 14		lda $14				lda 	zTemp3
.0183c4	9d c6 03	sta $03c6,x			sta 	Tim_SR,x
.0183c7	e8		inx				inx
.0183c8	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.0183ca	d0 ec		bne $0183b8			bne 	_TIM_URLoop
.0183cc	4c f1 81	jmp $0181f1			jmp 	TIM_NewCommand
.0183cf					_TIMURFail:
.0183cf	4c ea 81	jmp $0181ea			jmp 	TIM_Error
.0183d2					TIM_LoadMemory:
.0183d2	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; target address => zTemp2
.0183d5	a5 14		lda $14				lda 	zTemp3
.0183d7	85 12		sta $12				sta 	zTemp2
.0183d9	a5 15		lda $15				lda 	zTemp3+1
.0183db	85 13		sta $13				sta 	zTemp2+1
.0183dd					_TIM_LMLoop:
.0183dd	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; next byte ?
.0183e0	b0 0e		bcs $0183f0			bcs 	_TIMLMDone 					; no more
.0183e2	a2 00		ldx #$00			ldx 	#0							; write out.
.0183e4	a5 14		lda $14				lda 	zTemp3
.0183e6	81 12		sta ($12,x)			sta 	(zTemp2,x)
.0183e8	e6 12		inc $12				inc 	zTemp2 						; bump address
.0183ea	d0 f1		bne $0183dd			bne 	_TIM_LMLoop
.0183ec	e6 13		inc $13				inc 	zTemp2+1
.0183ee	80 ed		bra $0183dd			bra 	_TIM_LMLoop
.0183f0					_TIMLMDone:
.0183f0	4c f1 81	jmp $0181f1			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/skip.asm

.0183f3					StructureSearchSingle:
.0183f3	a2 00		ldx #$00			ldx 	#0
.0183f5					StructureSearchDouble:
.0183f5	85 10		sta $10				sta 	zTemp1 						; save the target on zTemp1,zTemp1+1
.0183f7	86 11		stx $11				stx 	zTemp1+1
.0183f9	a9 00		lda #$00			lda 	#0 							; set the structure depth to zero (zTemp2)
.0183fb	85 12		sta $12				sta 	zTemp2
.0183fd	80 18		bra $018417			bra 	_SSWLoop 					; jump in, start scanning from here.
.0183ff					_SSWNextLine:
.0183ff	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018401	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.018403	18		clc				clc
.018404	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018406	85 16		sta $16				sta 	zCodePtr
.018408	90 02		bcc $01840c			bcc 	_SNLNoCarry
.01840a	e6 17		inc $17				inc 	zCodePtr+1
.01840c					_SNLNoCarry:
.01840c	a0 00		ldy #$00			ldy 	#0
.01840e	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018410	c9 00		cmp #$00			cmp 	#0					 		; if zero, fail.
.018412	f0 54		beq $018468			beq 	_SSWFail
.018414	c8		iny				iny
.018415	c8		iny				iny
.018416					_SSWNextSimple:
.018416	c8		iny				iny
.018417					_SSWLoop:
.018417	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018419	c9 00		cmp #$00			cmp 	#0 							; end of line ?
.01841b	f0 e2		beq $0183ff			beq 	_SSWNextLine 				; if so, then next line
.01841d	10 f7		bpl $018416			bpl 	_SSWNextSimple 				; needs to be a token, just skip char/number.
.01841f	a6 12		ldx $12				ldx 	zTemp2 						; check structure count
.018421	d0 08		bne $01842b			bne 	_SSWCheckUpDown 			; if it's non zero, then a match doesn't work.
.018423	c5 10		cmp $10				cmp 	zTemp1 						; found the right keyword, either choice.
.018425	f0 2d		beq $018454			beq 	_SSWFound 					; so exit.
.018427	c5 11		cmp $11				cmp 	zTemp1+1
.018429	f0 29		beq $018454			beq 	_SSWFound
.01842b					_SSWCheckUpDown:
.01842b	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus 			; if < keyword +
.01842d	90 10		bcc $01843f			bcc 	_SSWNext
.01842f	c9 93		cmp #$93			cmp 	#firstKeywordMinus 			; if < keyword - then as keyword +
.018431	90 08		bcc $01843b			bcc 	_SSWPlus
.018433	c9 98		cmp #$98			cmp 	#firstUnaryFunction			; if < first unary down as keyword -
.018435	b0 08		bcs $01843f			bcs 	_SSWNext
.018437	c6 12		dec $12				dec 	zTemp2 						; reduce structure count.
.018439	c6 12		dec $12				dec 	zTemp2
.01843b					_SSWPlus:
.01843b	e6 12		inc $12				inc 	zTemp2
.01843d	30 16		bmi $018455			bmi 	_SSWUnder					; error if driven -ve
.01843f					_SSWNext:
.01843f	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018441	c8		iny				iny 								; skip
.018442	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018444	90 0c		bcc $018452			bcc 	_SEDone 					; so just skip over it.
.018446	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018448	90 07		bcc $018451			bcc 	_SEDouble
.01844a	98		tya				tya 								; this is Y + 1
.01844b	18		clc				clc
.01844c	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.01844e	a8		tay				tay 								; back in Y.
.01844f	88		dey				dey 								; fix up, one for the +1, one for the iny
.018450	88		dey				dey
.018451					_SEDouble:
.018451	c8		iny				iny
.018452					_SEDone:
.018452	80 c3		bra $018417			bra 	_SSWLoop
.018454					_SSWFound:
.018454	60		rts				rts
.018455					_SSWUnder:
.018455	20 79 85	jsr $018579			jsr ERR_Handler
>018458	53 74 72 75 63 74 75 72			.text "Structure order",0
>018460	65 20 6f 72 64 65 72 00
.018468					_SSWFail:
.018468	20 79 85	jsr $018579			jsr ERR_Handler
>01846b	43 61 6e 27 74 20 66 69			.text "Can't find structure",0
>018473	6e 64 20 73 74 72 75 63 74 75 72 65 00
.018480					SkipEndOfCommand:
.018480	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018482	c9 00		cmp #$00			cmp 	#0 							; if zero, end of line, so exit
.018484	f0 19		beq $01849f			beq 	_SOCExit
.018486	c9 c0		cmp #$c0			cmp 	#token_Colon 				; if colon, end of command
.018488	f0 15		beq $01849f			beq 	_SOCExit
.01848a	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.01848c	c8		iny				iny 								; skip
.01848d	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.01848f	90 0c		bcc $01849d			bcc 	_SEDone 					; so just skip over it.
.018491	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018493	90 07		bcc $01849c			bcc 	_SEDouble
.018495	98		tya				tya 								; this is Y + 1
.018496	18		clc				clc
.018497	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018499	a8		tay				tay 								; back in Y.
.01849a	88		dey				dey 								; fix up, one for the +1, one for the iny
.01849b	88		dey				dey
.01849c					_SEDouble:
.01849c	c8		iny				iny
.01849d					_SEDone:
.01849d	80 e1		bra $018480			bra 	SkipEndOfCommand
.01849f					_SOCExit:
.01849f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stack.asm

.0184a0					StackReset:
.0184a0	48		pha				pha
.0184a1	5a		phy				phy
.0184a2	a9 00		lda #$00			lda 	#(BasicStack & $FF) 		; reset pointer
.0184a4	85 26		sta $26				sta 	zBasicSP
.0184a6	a9 04		lda #$04			lda 	#(BasicStack >> 8)
.0184a8	85 27		sta $27				sta 	zBasicSP+1
.0184aa	a0 00		ldy #$00			ldy 	#0 							; reset stack top to $00 which cannot
.0184ac	98		tya				tya 								; be a legal token.
.0184ad	91 26		sta ($26),y			sta 	(zBasicSP),y
.0184af	7a		ply				ply
.0184b0	68		pla				pla
.0184b1	60		rts				rts
.0184b2					StackPushFrame:
.0184b2	48		pha				pha
.0184b3	5a		phy				phy
.0184b4	1a		inc a				inc 	a 							; one extra byte in frame, for the marker.
.0184b5	48		pha				pha 								; save it.
.0184b6	29 0f		and #$0f			and 	#$0F 						; lower 4 bits
.0184b8	18		clc				clc 								; add to Basic Stack
.0184b9	65 26		adc $26				adc 	zBasicSP
.0184bb	85 26		sta $26				sta 	zBasicSP
.0184bd	90 02		bcc $0184c1			bcc 	_SPFNoBump
.0184bf	e6 27		inc $27				inc 	zBasicSP+1
.0184c1					_SPFNoBump:
.0184c1	a0 00		ldy #$00			ldy 	#0
.0184c3	68		pla				pla
.0184c4	91 26		sta ($26),y			sta 	(zBasicSP),y
.0184c6	7a		ply				ply
.0184c7	68		pla				pla
.0184c8	60		rts				rts
.0184c9					StackPopFrame:
.0184c9	48		pha				pha
.0184ca	5a		phy				phy
.0184cb	a0 00		ldy #$00			ldy 	#0 							; compare with top of stack using EOR
.0184cd	51 26		eor ($26),y			eor 	(zBasicSP),y
.0184cf	29 f0		and #$f0			and 	#$F0 						; top 4 bits zero, match
.0184d1	d0 12		bne $0184e5			bne 	SPFError 					; mixed structures
.0184d3	b1 26		lda ($26),y			lda 	(zBasicSP),y 				; get size from byte
.0184d5	29 0f		and #$0f			and 	#$0F
.0184d7	49 ff		eor #$ff			eor 	#$FF						; 2's complement
.0184d9	38		sec				sec
.0184da	65 26		adc $26				adc 	zBasicSP
.0184dc	85 26		sta $26				sta 	zBasicSP
.0184de	b0 02		bcs $0184e2			bcs 	_SPFNoBump
.0184e0	c6 27		dec $27				dec 	zBasicSP+1
.0184e2					_SPFNoBump:
.0184e2	7a		ply				ply
.0184e3	68		pla				pla
.0184e4	60		rts				rts
.0184e5					SPFError:
.0184e5	20 79 85	jsr $018579			jsr ERR_Handler
>0184e8	4d 69 78 65 64 20 53 74			.text "Mixed Structures",0
>0184f0	72 75 63 74 75 72 65 73 00
.0184f9					StackSavePosition:
.0184f9	98		tya				tya
.0184fa	5a		phy				phy
.0184fb	a0 05		ldy #$05			ldy 	#5
.0184fd	91 26		sta ($26),y			sta 	(zBasicSP),y
.0184ff	a0 01		ldy #$01			ldy 	#1
.018501	a5 16		lda $16				lda 	zCodePtr+0 					; 4 bytes, could reduce this for 65816/6502
.018503	91 26		sta ($26),y			sta 	(zBasicSP),y
.018505	c8		iny				iny
.018506	a5 17		lda $17				lda 	zCodePtr+1
.018508	91 26		sta ($26),y			sta 	(zBasicSP),y
.01850a	c8		iny				iny
.01850b	a5 18		lda $18				lda 	zCodePtr+2
.01850d	91 26		sta ($26),y			sta 	(zBasicSP),y
.01850f	c8		iny				iny
.018510	a5 19		lda $19				lda 	zCodePtr+3
.018512	91 26		sta ($26),y			sta 	(zBasicSP),y
.018514	7a		ply				ply
.018515	60		rts				rts
.018516					StackRestorePosition:
.018516	5a		phy				phy
.018517	a0 01		ldy #$01			ldy 	#1 							; copy 4 bytes that are the pointer
.018519	b1 26		lda ($26),y			lda 	(zBasicSP),y
.01851b	85 16		sta $16				sta 	zCodePtr+0
.01851d	c8		iny				iny
.01851e	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018520	85 17		sta $17				sta 	zCodePtr+1
.018522	c8		iny				iny
.018523	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018525	85 18		sta $18				sta 	zCodePtr+2
.018527	c8		iny				iny
.018528	b1 26		lda ($26),y			lda 	(zBasicSP),y
.01852a	85 19		sta $19				sta 	zCodePtr+3
.01852c	c8		iny				iny
.01852d	b1 26		lda ($26),y			lda 	(zBasicSP),y 				; offset
.01852f	7a		ply				ply 								; restore Y
.018530	a8		tay				tay
.018531	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/vectors.asm

.018532					VIOCharPrint:
.018532	4c 35 80	jmp $018035			jmp 	IFT_PrintCharacter
.018535					VIOCharGet:
.018535	20 d9 81	jsr $0181d9			jsr 	IF_GetKey
.018538	c9 00		cmp #$00			cmp 	#0
.01853a	f0 02		beq $01853e			beq 	_VCG0
.01853c	38		sec				sec
.01853d	60		rts				rts
.01853e	18		clc		_VCG0:	clc
.01853f	60		rts				rts
.018540					VIOCheckBreak:
.018540	4c d4 81	jmp $0181d4			jmp 	IF_CheckBreak
.018543					VIOCharGetPosition:
.018543	ad 00 05	lda $0500			lda 	IFT_XCursor
.018546	60		rts				rts
.018547					VIOReadLine:
.018547	4c ed 80	jmp $0180ed			jmp 	IFT_ReadLine

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/errors.asm

.01854a					SyntaxError:
.01854a	20 79 85	jsr $018579			jsr 	ERR_Handler
>01854d	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>018555	72 72 6f 72 00
.01855a					TypeError:
.01855a	20 79 85	jsr $018579			jsr 	ERR_Handler
>01855d	57 72 6f 6e 67 20 74 79				.text 	"Wrong type",0
>018565	70 65 00
.018568					BadParamError:
.018568	20 79 85	jsr $018579			jsr 	ERR_Handler
>01856b	42 61 64 20 50 61 72 61				.text 	"Bad Parameter",0
>018573	6d 65 74 65 72 00
.018579					ERR_Handler:
.018579	a0 00		ldy #$00			ldy 	#0
.01857b	c8		iny				iny
.01857c	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01857e	85 80		sta $80				sta 	XS_Mantissa
.018580	c8		iny				iny
.018581	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018583	85 81		sta $81				sta 	XS_Mantissa+1
.018585	fa		plx				plx 								; address in XY
.018586	7a		ply				ply
.018587	e8		inx				inx 								; bump, because of RTS/JSR address -1
.018588	d0 01		bne $01858b			bne 	_EHNoSkip
.01858a	c8		iny				iny
.01858b					_EHNoSkip:
.01858b	20 aa 85	jsr $0185aa			jsr 	PrintROMMessage 			; print message from ROM.
.01858e	a5 80		lda $80				lda 	XS_Mantissa					; line number = 0
.018590	05 81		ora $81				ora 	XS_Mantissa+1
.018592	f0 0c		beq $0185a0			beq 	_EHNoLine
.018594	a2 a5		ldx #$a5			ldx 	#_EHAt & $FF 				; print " at "
.018596	a0 85		ldy #$85			ldy 	#(_EHAt >> 8) & $FF
.018598	20 aa 85	jsr $0185aa			jsr 	PrintROMMessage
.01859b	a2 00		ldx #$00			ldx 	#0 							; Print line number
.01859d	20 bf 85	jsr $0185bf			jsr 	Print16BitInteger
.0185a0					_EHNoLine:
.0185a0	80 fe		bra $0185a0			bra 	_EHNoLine
.0185a2	4c 32 88	jmp $018832			jmp 	WarmStart
>0185a5	20 61 74 20 00			_EHAt:	.text 	" at ",0
.0185aa					PrintROMMessage:
.0185aa	86 1a		stx $1a				stx 	zLTemp1 					; save addres
.0185ac	84 1b		sty $1b				sty 	zLTemp1+1
.0185ae	4b		phk				phk
.0185af	68		pla				pla
.0185b0	85 1c		sta $1c				sta 	ZLTemp1+2
.0185b2	a0 00		ldy #$00			ldy 	#0
.0185b4					_PRMLoop:
.0185b4	b7 1a		lda [$1a],y			lda 	[zLTemp1],y
.0185b6	f0 06		beq $0185be			beq		_PRMExit
.0185b8	c8		iny				iny
.0185b9	20 32 85	jsr $018532			jsr 	VIOCharPrint
.0185bc	80 f6		bra $0185b4			bra 	_PRMLoop
.0185be					_PRMExit:
.0185be	60		rts				rts
.0185bf					Print16BitInteger:
.0185bf	a9 00		lda #$00			lda 	#0 							; make 32 bit
.0185c1	85 82		sta $82				sta 	XS_Mantissa+2
.0185c3	85 83		sta $83				sta 	XS_Mantissa+3
.0185c5					Print32BitInteger:
.0185c5	a9 00		lda #$00			lda 	#0
.0185c7	8d 14 03	sta $0314			sta 	NumBufX 					; reset the conversion pointer
.0185ca	aa		tax				tax 								; convert bottom level.
.0185cb	20 38 9e	jsr $019e38			jsr 	INTToString 				; make string
.0185ce	a2 00		ldx #$00			ldx 	#0 							; print buffer
.0185d0	bd 15 03	lda $0315,x	_P1Loop:lda 	Num_Buffer,x
.0185d3	f0 06		beq $0185db			beq 	_P1Exit
.0185d5	20 32 85	jsr $018532			jsr 	VIOCharPrint
.0185d8	e8		inx				inx
.0185d9	80 f5		bra $0185d0			bra 	_P1Loop
.0185db	8a		txa		_P1Exit:txa 								; return chars printed.
.0185dc	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm


;******  Processing file: modules/basic/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b6					lastUnaryFunction = $b6
.0185dd					VectorTable:
>0185dd	83 92					.word BinaryOp_And         & $FFFF ; $80 and
>0185df	9f 92					.word BinaryOp_Or          & $FFFF ; $81 or
>0185e1	bb 92					.word BinaryOp_Xor         & $FFFF ; $82 xor
>0185e3	bb 92					.word BinaryOp_Eor         & $FFFF ; $83 eor
>0185e5	f2 92					.word Binary_Equal         & $FFFF ; $84 =
>0185e7	0c 93					.word Binary_NotEqual      & $FFFF ; $85 <>
>0185e9	15 93					.word Binary_Less          & $FFFF ; $86 <
>0185eb	1e 93					.word Binary_LessEqual     & $FFFF ; $87 <=
>0185ed	30 93					.word Binary_Greater       & $FFFF ; $88 >
>0185ef	27 93					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>0185f1	b5 93					.word BinaryOp_Add         & $FFFF ; $8a +
>0185f3	d1 93					.word BinaryOp_Subtract    & $FFFF ; $8b -
>0185f5	e2 93					.word BinaryOp_Multiply    & $FFFF ; $8c *
>0185f7	f3 93					.word BinaryOp_Divide      & $FFFF ; $8d /
>0185f9	9b 86					.word NotImplemented       & $FFFF ; $8e ^
>0185fb	11 8c					.word Command_IF           & $FFFF ; $8f if
>0185fd	7f 90					.word Command_WHILE        & $FFFF ; $90 while
>0185ff	a7 90					.word Command_REPEAT       & $FFFF ; $91 repeat
>018601	94 89					.word Command_FOR          & $FFFF ; $92 for
>018603	9b 86					.word NotImplemented       & $FFFF ; $93 then
>018605	6e 8c					.word Command_ENDIF        & $FFFF ; $94 endif
>018607	9c 90					.word Command_WEND         & $FFFF ; $95 wend
>018609	b0 90					.word Command_UNTIL        & $FFFF ; $96 until
>01860b	11 8a					.word Command_NEXT         & $FFFF ; $97 next
>01860d	9b 86					.word NotImplemented       & $FFFF ; $98 not
>01860f	9b 86					.word NotImplemented       & $FFFF ; $99 fn(
>018611	f8 94					.word Unary_Abs            & $FFFF ; $9a abs(
>018613	45 96					.word Unary_Asc            & $FFFF ; $9b asc(
>018615	64 a5					.word Unary_Int            & $FFFF ; $9c int(
>018617	12 95					.word Unary_Peek           & $FFFF ; $9d peek(
>018619	e5 a4					.word Unary_Rnd            & $FFFF ; $9e rnd(
>01861b	85 95					.word Unary_Usr            & $FFFF ; $9f usr(
>01861d	84 96					.word Unary_Left           & $FFFF ; $a0 left$(
>01861f	99 96					.word Unary_Right          & $FFFF ; $a1 right$(
>018621	6b 96					.word Unary_Mid            & $FFFF ; $a2 mid$(
>018623	e2 97					.word Unary_Spc            & $FFFF ; $a3 spc(
>018625	13 96					.word Unary_Str            & $FFFF ; $a4 str$(
>018627	a7 95					.word Unary_Val            & $FFFF ; $a5 val(
>018629	5c 96					.word Unary_Len            & $FFFF ; $a6 len(
>01862b	11 97					.word Unary_Hex            & $FFFF ; $a7 hex$(
>01862d	9b 86					.word NotImplemented       & $FFFF ; $a8 sin(
>01862f	9b 86					.word NotImplemented       & $FFFF ; $a9 cos(
>018631	9b 86					.word NotImplemented       & $FFFF ; $aa tan(
>018633	9b 86					.word NotImplemented       & $FFFF ; $ab atn(
>018635	9b 86					.word NotImplemented       & $FFFF ; $ac exp(
>018637	9b 86					.word NotImplemented       & $FFFF ; $ad log(
>018639	9b 86					.word NotImplemented       & $FFFF ; $ae sqr(
>01863b	67 97					.word Unary_Dec            & $FFFF ; $af dec(
>01863d	16 95					.word Unary_Deek           & $FFFF ; $b0 deek(
>01863f	1a 95					.word Unary_Leek           & $FFFF ; $b1 leek(
>018641	52 95					.word Unary_Mod            & $FFFF ; $b2 mod(
>018643	b2 94					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>018645	c4 97					.word Unary_Chr            & $FFFF ; $b4 chr$(
>018647	46 95					.word Unary_Pos            & $FFFF ; $b5 pos(
>018649	05 98					.word Unary_Tab            & $FFFF ; $b6 tab(
>01864b	9b 86					.word NotImplemented       & $FFFF ; $b7 $
>01864d	9b 86					.word NotImplemented       & $FFFF ; $b8 $(
>01864f	9b 86					.word NotImplemented       & $FFFF ; $b9 #
>018651	9b 86					.word NotImplemented       & $FFFF ; $ba #(
>018653	9b 86					.word NotImplemented       & $FFFF ; $bb %
>018655	9b 86					.word NotImplemented       & $FFFF ; $bc %(
>018657	9b 86					.word NotImplemented       & $FFFF ; $bd (
>018659	9b 86					.word NotImplemented       & $FFFF ; $be )
>01865b	9b 86					.word NotImplemented       & $FFFF ; $bf ,
>01865d	93 89					.word Command_COLON        & $FFFF ; $c0 :
>01865f	9b 86					.word NotImplemented       & $FFFF ; $c1 ;
>018661	9b 86					.word NotImplemented       & $FFFF ; $c2 def
>018663	60 90					.word Command_CLR          & $FFFF ; $c3 clr
>018665	77 90					.word Command_STOP         & $FFFF ; $c4 stop
>018667	ea 8a					.word Command_DATA         & $FFFF ; $c5 data
>018669	c4 8a					.word Command_READ         & $FFFF ; $c6 read
>01866b	3f 88					.word Command_DIM          & $FFFF ; $c7 dim
>01866d	9b 86					.word NotImplemented       & $FFFF ; $c8 to
>01866f	9b 86					.word NotImplemented       & $FFFF ; $c9 step
>018671	a6 8f					.word Command_GOSUB        & $FFFF ; $ca gosub
>018673	b6 8f					.word Command_RETURN       & $FFFF ; $cb return
>018675	9e 8f					.word Command_GOTO         & $FFFF ; $cc goto
>018677	0d 8c					.word Command_END          & $FFFF ; $cd end
>018679	9b 86					.word NotImplemented       & $FFFF ; $ce input
>01867b	88 8b					.word Command_LET          & $FFFF ; $cf let
>01867d	74 8c					.word Command_LIST         & $FFFF ; $d0 list
>01867f	47 8f					.word Command_NEW          & $FFFF ; $d1 new
>018681	63 8f					.word Command_OLD          & $FFFF ; $d2 old
>018683	bf 8f					.word Command_ON           & $FFFF ; $d3 on
>018685	ed 8a					.word Command_RESTORE      & $FFFF ; $d4 restore
>018687	16 8f					.word Command_POKE         & $FFFF ; $d5 poke
>018689	68 8e					.word Command_PRINTX       & $FFFF ; $d6 print
>01868b	05 89					.word Command_RUN          & $FFFF ; $d7 run
>01868d	c7 88					.word Command_WAIT         & $FFFF ; $d8 wait
>01868f	f3 8b					.word Command_SYS          & $FFFF ; $d9 sys
>018691	1a 8f					.word Command_DOKE         & $FFFF ; $da doke
>018693	1e 8f					.word Command_LOKE         & $FFFF ; $db loke
>018695	fe 8e					.word Command_ASSERT       & $FFFF ; $dc assert
>018697	a9 8b					.word Command_GET          & $FFFF ; $dd get
>018699	68 8c					.word Command_ELSE         & $FFFF ; $de else
.01869b					NotImplemented:
.01869b	20 79 85	jsr $018579			jsr ERR_Handler
>01869e	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>0186a6	65 6d 65 6e 74 65 64 00
.0186ae					BinaryPrecedence:
>0186ae	01					.byte 1    ; $80 and
>0186af	01					.byte 1    ; $81 or
>0186b0	01					.byte 1    ; $82 xor
>0186b1	01					.byte 1    ; $83 eor
>0186b2	02					.byte 2    ; $84 =
>0186b3	02					.byte 2    ; $85 <>
>0186b4	02					.byte 2    ; $86 <
>0186b5	02					.byte 2    ; $87 <=
>0186b6	02					.byte 2    ; $88 >
>0186b7	02					.byte 2    ; $89 >=
>0186b8	03					.byte 3    ; $8a +
>0186b9	03					.byte 3    ; $8b -
>0186ba	04					.byte 4    ; $8c *
>0186bb	04					.byte 4    ; $8d /
>0186bc	05					.byte 5    ; $8e ^
.0186bd					KeywordText:
>0186bd	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>0186c0	4f d2					.byte $4f,$d2                          ; $81 or
>0186c2	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>0186c5	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>0186c8	bd					.byte $bd                              ; $84 =
>0186c9	3c be					.byte $3c,$be                          ; $85 <>
>0186cb	bc					.byte $bc                              ; $86 <
>0186cc	3c bd					.byte $3c,$bd                          ; $87 <=
>0186ce	be					.byte $be                              ; $88 >
>0186cf	3e bd					.byte $3e,$bd                          ; $89 >=
>0186d1	ab					.byte $ab                              ; $8a +
>0186d2	ad					.byte $ad                              ; $8b -
>0186d3	aa					.byte $aa                              ; $8c *
>0186d4	af					.byte $af                              ; $8d /
>0186d5	de					.byte $de                              ; $8e ^
>0186d6	49 c6					.byte $49,$c6                          ; $8f if
>0186d8	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>0186dd	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>0186e3	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>0186e6	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>0186ea	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>0186ef	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>0186f3	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>0186f8	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>0186fc	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>0186ff	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>018702	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>018706	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>01870a	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>01870e	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>018713	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>018717	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>01871b	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>018721	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>018728	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>01872d	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>018731	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>018736	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>01873a	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>01873e	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>018743	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>018747	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>01874b	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>01874f	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>018753	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>018757	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>01875b	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>01875f	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>018763	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>018768	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>01876d	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>018771	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>018775	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>01877a	50 4f 53 a8				.byte $50,$4f,$53,$a8                  ; $b5 pos(
>01877e	54 41 42 a8				.byte $54,$41,$42,$a8                  ; $b6 tab(
>018782	a4					.byte $a4                              ; $b7 $
>018783	24 a8					.byte $24,$a8                          ; $b8 $(
>018785	a3					.byte $a3                              ; $b9 #
>018786	23 a8					.byte $23,$a8                          ; $ba #(
>018788	a5					.byte $a5                              ; $bb %
>018789	25 a8					.byte $25,$a8                          ; $bc %(
>01878b	a8					.byte $a8                              ; $bd (
>01878c	a9					.byte $a9                              ; $be )
>01878d	ac					.byte $ac                              ; $bf ,
>01878e	ba					.byte $ba                              ; $c0 :
>01878f	bb					.byte $bb                              ; $c1 ;
>018790	44 45 c6				.byte $44,$45,$c6                      ; $c2 def
>018793	43 4c d2				.byte $43,$4c,$d2                      ; $c3 clr
>018796	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $c4 stop
>01879a	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c5 data
>01879e	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c6 read
>0187a2	44 49 cd				.byte $44,$49,$cd                      ; $c7 dim
>0187a5	54 cf					.byte $54,$cf                          ; $c8 to
>0187a7	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c9 step
>0187ab	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $ca gosub
>0187b0	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $cb return
>0187b6	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $cc goto
>0187ba	45 4e c4				.byte $45,$4e,$c4                      ; $cd end
>0187bd	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $ce input
>0187c2	4c 45 d4				.byte $4c,$45,$d4                      ; $cf let
>0187c5	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $d0 list
>0187c9	4e 45 d7				.byte $4e,$45,$d7                      ; $d1 new
>0187cc	4f 4c c4				.byte $4f,$4c,$c4                      ; $d2 old
>0187cf	4f ce					.byte $4f,$ce                          ; $d3 on
>0187d1	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d4 restore
>0187d8	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d5 poke
>0187dc	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d6 print
>0187e1	52 55 ce				.byte $52,$55,$ce                      ; $d7 run
>0187e4	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d8 wait
>0187e8	53 59 d3				.byte $53,$59,$d3                      ; $d9 sys
>0187eb	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $da doke
>0187ef	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $db loke
>0187f3	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $dc assert
>0187f9	47 45 d4				.byte $47,$45,$d4                      ; $dd get
>0187fc	45 4c 53 c5				.byte $45,$4c,$53,$c5                  ; $de else
>018800	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_pos = $b5
=$b6					token_tab = $b6
=$b7					token_dollar = $b7
=$b8					token_dollarlparen = $b8
=$b9					token_hash = $b9
=$ba					token_hashlparen = $ba
=$bb					token_percent = $bb
=$bc					token_percentlparen = $bc
=$bd					token_lparen = $bd
=$be					token_rparen = $be
=$bf					token_comma = $bf
=$c0					token_colon = $c0
=$c1					token_semicolon = $c1
=$c2					token_def = $c2
=$c3					token_clr = $c3
=$c4					token_stop = $c4
=$c5					token_data = $c5
=$c6					token_read = $c6
=$c7					token_dim = $c7
=$c8					token_to = $c8
=$c9					token_step = $c9
=$ca					token_gosub = $ca
=$cb					token_return = $cb
=$cc					token_goto = $cc
=$cd					token_end = $cd
=$ce					token_input = $ce
=$cf					token_let = $cf
=$d0					token_list = $d0
=$d1					token_new = $d1
=$d2					token_old = $d2
=$d3					token_on = $d3
=$d4					token_restore = $d4
=$d5					token_poke = $d5
=$d6					token_print = $d6
=$d7					token_run = $d7
=$d8					token_wait = $d8
=$d9					token_sys = $d9
=$da					token_doke = $da
=$db					token_loke = $db
=$dc					token_assert = $dc
=$dd					token_get = $dd
=$de					token_else = $de

;******  Return to file: modules/basic/core.asm

.018801					BASIC_Start:
.018801	20 9b 81	jsr $01819b			jsr 	IF_Reset 					; set up and clear screen.
.018804	20 00 80	jsr $018000			jsr 	IFT_ClearScreen
.018807	a9 5c		lda #$5c			lda 	#$5C 						; JMP Long opcode
.018809	8d 10 03	sta $0310			sta 	LocalVector
.01880c	8d 0c 03	sta $030c			sta 	UserVector
.01880f	a9 95		lda #$95			lda 	#USRDefault & $FF 			; reset USR vector
.018811	8d 0d 03	sta $030d			sta 	UserVector+1
.018814	a9 95		lda #$95			lda 	#(USRDefault >> 8) & $FF
.018816	8d 0e 03	sta $030e			sta 	UserVector+2
.018819	a9 01		lda #$01			lda 	#(USRDefault >> 16) & $FF
.01881b	8d 0f 03	sta $030f			sta 	UserVector+3
.01881e	20 4c 98	jsr $01984c			jsr 	UpdateProgramEnd 			; update the program end.
.018821	20 60 90	jsr $019060			jsr 	ResetRunStatus 				; clear everything (CLR command)
.018824	c2 30		rep #$30			rep 	#$30
.018826	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.018829	1b		tcs				tcs
.01882a	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.01882d	e2 30		sep #$30			sep 	#$30
.01882f	4c 05 89	jmp $018905			jmp 	COMMAND_Run
.018832					WarmStart:
.018832	c2 30		rep #$30			rep 	#$30
.018834	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.018837	1b		tcs				tcs
.018838	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.01883b	e2 30		sep #$30			sep 	#$30
.01883d	80 f3		bra $018832			bra 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/dim.asm

.01883f					Command_DIM:
.01883f	98		tya				tya
.018840	48		pha				pha 								; push on stack.
.018841	20 c1 99	jsr $0199c1			jsr 	VariableExtract 			; get the identifier
.018844	ad 95 03	lda $0395			lda 	Var_Type 					; check it is an array
.018847	29 01		and #$01			and 	#1
.018849	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.01884b	d0 6c		bne $0188b9			bne 	_CDIError
.01884d	a9 00		lda #$00			lda 	#0 							; reset the DIM index. The dimensions are
.01884f	8d b9 03	sta $03b9			sta 	UsrArrayIdx 				; built up here and copied in case we autodim
.018852					_CDIGetDimension:
.018852	ad b9 03	lda $03b9			lda 	UsrArrayIdx 				; done too many ?
.018855	c9 06		cmp #$06			cmp 	#ArrayMaxDim*2
.018857	f0 60		beq $0188b9			beq 	_CDIError
.018859	20 64 92	jsr $019264			jsr 	EvaluateInteger 			; evaluate an index size
.01885c	a5 81		lda $81				lda 	XS_Mantissa+1 				; check in range 0-7FFF
.01885e	29 80		and #$80			and 	#$80
.018860	05 82		ora $82				ora 	XS_Mantissa+2
.018862	05 83		ora $83				ora 	XS_Mantissa+3
.018864	d0 53		bne $0188b9			bne 	_CDIError
.018866	ae b9 03	ldx $03b9			ldx 	UsrArrayIdx 				; copy into the array table.
.018869	18		clc				clc 								; add 1 - max index => size.
.01886a	a5 80		lda $80				lda 	XS_Mantissa+0
.01886c	69 01		adc #$01			adc 	#1
.01886e	9d b1 03	sta $03b1,x			sta 	UsrArrayDef+0,x
.018871	a5 81		lda $81				lda 	XS_Mantissa+1
.018873	69 00		adc #$00			adc 	#0
.018875	9d b2 03	sta $03b2,x			sta 	UsrArrayDef+1,x
.018878	30 3f		bmi $0188b9			bmi 	_CDIError 					; could be dim a(32767)
.01887a	e8		inx				inx 								; bump index.
.01887b	e8		inx				inx
.01887c	8e b9 03	stx $03b9			stx 	UsrArrayIdx
.01887f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018881	c8		iny				iny
.018882	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another dimension
.018884	f0 cc		beq $018852			beq 	_CDIGetDimension
.018886	88		dey				dey
.018887	20 a8 98	jsr $0198a8			jsr 	CheckNextRParen 			; closing ) present ?
.01888a	ae b9 03	ldx $03b9			ldx 	UsrArrayIdx 				; copy USR array to default
.01888d	a9 ff		lda #$ff			lda 	#$FF 						; put end marker in ArrayDef
.01888f	9d aa 03	sta $03aa,x			sta 	ArrayDef+1,x
.018892					_CDICopy:
.018892	bd b1 03	lda $03b1,x			lda 	UsrArrayDef,x
.018895	9d a9 03	sta $03a9,x			sta 	ArrayDef,x
.018898	ca		dex				dex
.018899	10 f7		bpl $018892			bpl 	_CDICopy
.01889b	68		pla				pla									; position of array identifier
.01889c	85 10		sta $10				sta 	zTemp1
.01889e	98		tya				tya
.01889f	48		pha				pha
.0188a0	a5 10		lda $10				lda 	zTemp1 						; point to identifier
.0188a2	a8		tay				tay
.0188a3	20 c1 99	jsr $0199c1			jsr 	VariableExtract 			; get the identifier
.0188a6	20 5a 9c	jsr $019c5a			jsr 	VariableLocate 				; check if it exists already.
.0188a9	b0 0e		bcs $0188b9			bcs 	_CDIError
.0188ab	20 4d 9a	jsr $019a4d			jsr 	VariableCreate 				; create it using the current ArrayDef
.0188ae	68		pla				pla 								; restore code position
.0188af	a8		tay				tay
.0188b0	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0188b2	c8		iny				iny
.0188b3	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another DIM
.0188b5	f0 88		beq $01883f			beq 	Command_DIM
.0188b7	88		dey				dey
.0188b8	60		rts				rts
.0188b9					_CDIError:
.0188b9	20 79 85	jsr $018579			jsr ERR_Handler
>0188bc	42 61 64 20 44 49 4d 00			.text "Bad DIM",0
.0188c4					_CDISyntax:
.0188c4	4c 4a 85	jmp $01854a			jmp 	SyntaxError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/wait.asm

.0188c7					Command_WAIT:
.0188c7	20 64 92	jsr $019264			jsr		EvaluateInteger 			; address
.0188ca	a2 06		ldx #$06			ldx 	#XS_Size 					; and mask.
.0188cc	20 b0 98	jsr $0198b0			jsr 	CheckNextComma
.0188cf	20 66 92	jsr $019266			jsr 	EvaluateIntegerX
.0188d2	a9 00		lda #$00			lda 	#0							; set default xor.
.0188d4	85 8c		sta $8c				sta 	XS_Mantissa+XS_Size*2
.0188d6	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0188d8	c9 bf		cmp #$bf			cmp 	#token_Comma 				; no use the default
.0188da	d0 06		bne $0188e2			bne 	_CWAXorDefault
.0188dc	c8		iny				iny
.0188dd	a2 0c		ldx #$0c			ldx 	#XS_Size*2
.0188df	20 66 92	jsr $019266			jsr 	EvaluateIntegerX
.0188e2					_CWAXorDefault:
.0188e2	a5 80		lda $80				lda 	XS_Mantissa 				; copy 24 bits of mantissa to ZLTemp1
.0188e4	85 1a		sta $1a				sta 	zLTemp1
.0188e6	a5 81		lda $81				lda 	XS_Mantissa+1
.0188e8	85 1b		sta $1b				sta 	zLTemp1+1
.0188ea	a5 82		lda $82				lda 	XS_Mantissa+2
.0188ec	85 1c		sta $1c				sta 	zLTemp1+2
.0188ee					_CWAWaitLoop:
.0188ee	20 40 85	jsr $018540			jsr 	VIOCheckBreak 				; exit on break.
.0188f1	c9 00		cmp #$00			cmp 	#0
.0188f3	d0 0f		bne $018904			bne 	_CWAWaitExit
.0188f5	a9 01		lda #$01			lda 	#1							; read 1 byte to mantissa/0
.0188f7	a2 00		ldx #$00			ldx 	#0
.0188f9	5a		phy				phy 								; this is the same routine as PEEK.
.0188fa	20 2a 98	jsr $01982a			jsr 	MemRead
.0188fd	7a		ply				ply
.0188fe	25 86		and $86				and 	XS_Mantissa+XS_Size 		; process it
.018900	45 8c		eor $8c				eor 	XS_Mantissa+XS_Size*2
.018902	f0 ea		beq $0188ee			beq 	_CWAWaitLoop
.018904					_CWAWaitExit:
.018904	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/run.asm

.018905					Command_RUN:
.018905	20 60 90	jsr $019060			jsr 	ResetRunStatus 				; clear, reset stacks etc.
.018908	a9 00		lda #$00			lda 	#BasicProgram & $FF
.01890a	85 16		sta $16				sta 	zCodePtr+0
.01890c	a9 10		lda #$10			lda 	#BasicProgram >> 8
.01890e	85 17		sta $17				sta 	zCodePtr+1
.018910	a9 00		lda #$00			lda 	#0
.018912	85 18		sta $18				sta 	zCodePtr+2
.018914	85 19		sta $19				sta 	zCodePtr+3
.018916	a0 03		ldy #$03			ldy 	#3
.018918					RUN_NewLine:
.018918	a0 00		ldy #$00			ldy 	#0
.01891a	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01891c	c8		iny				iny
.01891d	c8		iny				iny
.01891e	c8		iny				iny
.01891f	c9 00		cmp #$00			cmp 	#0 							; if the offset is zero then END.
.018921	d0 16		bne $018939			bne 	RUN_NextCommand
.018923	4c 0d 8c	jmp $018c0d			jmp 	Command_END 				; go do the command code.
.018926					RUN_Skip:
.018926	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018928	c8		iny				iny 								; skip
.018929	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.01892b	90 0c		bcc $018939			bcc 	_SEDone 					; so just skip over it.
.01892d	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.01892f	90 07		bcc $018938			bcc 	_SEDouble
.018931	98		tya				tya 								; this is Y + 1
.018932	18		clc				clc
.018933	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018935	a8		tay				tay 								; back in Y.
.018936	88		dey				dey 								; fix up, one for the +1, one for the iny
.018937	88		dey				dey
.018938					_SEDouble:
.018938	c8		iny				iny
.018939					_SEDone:
.018939					RUN_NextCommand:
.018939	ad a8 03	lda $03a8			lda 	BreakCount 					; break counter
.01893c	69 10		adc #$10			adc 	#16 						; one time in 16
.01893e	8d a8 03	sta $03a8			sta 	BreakCount
.018941	90 0a		bcc $01894d			bcc 	RUN_NoCheckBreak
.018943	20 40 85	jsr $018540			jsr 	VIOCheckBreak 				; check for break
.018946	c9 00		cmp #$00			cmp 	#0
.018948	f0 03		beq $01894d			beq 	RUN_NoCheckBreak
.01894a	4c 77 90	jmp $019077			jmp 	Command_STOP 				; stop on BREAK.
.01894d					RUN_NoCheckBreak:
.01894d	a9 00		lda #$00			lda 	#0 							; this resets temporary string allocation.
.01894f	85 21		sta $21				sta 	zTempStr+1 					; (initialised when first called)
.018951	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018953	c9 c0		cmp #$c0			cmp 	#token_Colon 				; skip over colons
.018955	f0 cf		beq $018926			beq 	RUN_Skip
.018957	c9 00		cmp #$00			cmp 	#0 							; if non-zero execute whatever
.018959	d0 0f		bne $01896a			bne 	RUN_Execute
.01895b					RUN_NextLine:
.01895b	a0 00		ldy #$00			ldy 	#0 							; point to offset
.01895d	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.01895f	18		clc				clc
.018960	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018962	85 16		sta $16				sta 	zCodePtr
.018964	90 02		bcc $018968			bcc 	_SNLNoCarry
.018966	e6 17		inc $17				inc 	zCodePtr+1
.018968					_SNLNoCarry:
.018968	80 ae		bra $018918			bra 	RUN_NewLine 				; go do the new line code
.01896a					RUN_Execute:
.01896a	c9 f8		cmp #$f8			cmp 	#$F8 						; handle shifts, REM etc.
.01896c	b0 1e		bcs $01898c			bcs 	RUN_Extension
.01896e	c8		iny				iny
.01896f	0a		asl a				asl 	a 							; double the character read.
.018970	90 14		bcc $018986			bcc 	RUN_Default 				; if carry clear was $00-$7F, so try LET.
.018972	aa		tax				tax 								; ready to look up.
.018973	bf dd 85 01	lda $0185dd,x			lda 	VectorTable,x 				; copy address into LocalVector
.018977	8d 11 03	sta $0311			sta 	LocalVector+1
.01897a	bf de 85 01	lda $0185de,x			lda 	VectorTable+1,x
.01897e	8d 12 03	sta $0312			sta 	LocalVector+2
.018981	20 b1 91	jsr $0191b1			jsr 	EVCallLocalVector 			; execute the appropriate code.
.018984	80 b3		bra $018939			bra 	RUN_NextCommand 			; do the next command.
.018986					RUN_Default:
.018986	88		dey				dey
.018987	20 88 8b	jsr $018b88			jsr 	Command_LET 				; and try LET.
.01898a	80 ad		bra $018939			bra 	RUN_NextCommand
.01898c					RUN_Extension:
.01898c	c9 ff		cmp #$ff			cmp 	#$FF 						; if $FF (REM)
.01898e	f0 96		beq $018926			beq 	RUN_Skip 					; skip over it.
.018990	4c 4a 85	jmp $01854a			jmp 	SyntaxError
.018993					Command_COLON:
.018993	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/for.asm

.018994					Command_FOR:
.018994	20 88 8b	jsr $018b88			jsr 	Command_LET 				; do the A = 99 bit
.018997	a5 24		lda $24				lda 	zVarType 					; obviously has to be integer/real.
.018999	c9 b7		cmp #$b7			cmp 	#token_Dollar
.01899b	f0 71		beq $018a0e			beq 	_CFOError
.01899d	48		pha				pha 								; save the variable type.
.01899e	5a		phy				phy 								; save type/variable address.
.01899f	a0 01		ldy #$01			ldy 	#1							; type at + 1
.0189a1	91 26		sta ($26),y			sta 	(zBasicSP),y
.0189a3	c8		iny				iny
.0189a4	a5 22		lda $22				lda 	zVarDataPtr 				; data low at +2
.0189a6	91 26		sta ($26),y			sta 	(zBasicSP),y
.0189a8	c8		iny				iny
.0189a9	a5 23		lda $23				lda 	zVarDataPtr+1 				; data high at +3
.0189ab	91 26		sta ($26),y			sta 	(zBasicSP),y
.0189ad	7a		ply				ply
.0189ae	a9 53		lda #$53			lda 	#(SMark_For << 4) + 3
.0189b0	20 b2 84	jsr $0184b2			jsr 	StackPushFrame 				; push on the stack with FOR marker.
.0189b3	a9 c8		lda #$c8			lda 	#token_TO
.0189b5	20 91 98	jsr $019891			jsr 	CheckNextToken
.0189b8	a2 00		ldx #$00			ldx 	#0 							; put in Mantissa, bottom
.0189ba	20 ce 90	jsr $0190ce			jsr 	EvaluateExpression
.0189bd	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0189bf	a2 06		ldx #$06			ldx 	#XS_Size 					; X to second level
.0189c1	c9 c9		cmp #$c9			cmp 	#token_STEP
.0189c3	d0 06		bne $0189cb			bne 	_CFOStep1
.0189c5	c8		iny				iny
.0189c6	20 d0 90	jsr $0190d0			jsr 	EvaluateExpressionX 		; get STEP value.
.0189c9	80 0e		bra $0189d9			bra 	_CFOHaveStep
.0189cb					_CFOStep1:
.0189cb	a9 00		lda #$00			lda 	#0							; set step to integer 1.
.0189cd	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0189cf	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0189d1	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0189d3	a9 01		lda #$01			lda 	#1
.0189d5	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0189d7	95 85		sta $85,x			sta 	XS_Type,x
.0189d9					_CFOHaveStep:
.0189d9	68		pla				pla 								; restore variable type
.0189da	a2 00		ldx #$00			ldx 	#0
.0189dc	c9 bb		cmp #$bb			cmp 	#token_Percent 				; do conversion to type
.0189de	f0 0a		beq $0189ea			beq 	_CFOInteger
.0189e0	20 65 a2	jsr $01a265			jsr 	FPUToFloat
.0189e3	a2 06		ldx #$06			ldx 	#6
.0189e5	20 65 a2	jsr $01a265			jsr 	FPUToFloat
.0189e8	80 08		bra $0189f2			bra 	_CFOEndConv
.0189ea					_CFOInteger:
.0189ea	20 b1 a2	jsr $01a2b1			jsr 	FPUToInteger
.0189ed	a2 06		ldx #$06			ldx 	#6
.0189ef	20 b1 a2	jsr $01a2b1			jsr 	FPUToInteger
.0189f2					_CFOEndConv:
.0189f2	20 f9 84	jsr $0184f9			jsr 	StackSavePosition 			; save the loop position at 1-5
.0189f5	a9 55		lda #$55			lda 	#(SMark_For << 4)+SourcePosSize
.0189f7	20 b2 84	jsr $0184b2			jsr 	StackPushFrame 				; push the loop address frame.
.0189fa	5a		phy				phy
.0189fb	a0 00		ldy #$00			ldy 	#0
.0189fd					_CFOCopy:
.0189fd	b9 80 00	lda $0080,y			lda 	XS_Mantissa+0,y
.018a00	c8		iny				iny
.018a01	91 26		sta ($26),y			sta 	(zBasicSP),y
.018a03	c0 0c		cpy #$0c			cpy 	#XS_Size*2
.018a05	d0 f6		bne $0189fd			bne 	_CFOCopy
.018a07	7a		ply				ply
.018a08	a9 5c		lda #$5c			lda 	#(SMark_For << 4)+(XS_Size*2)
.018a0a	20 b2 84	jsr $0184b2			jsr 	StackPushFrame
.018a0d	60		rts				rts
.018a0e					_CFOError:
.018a0e	4c 5a 85	jmp $01855a			jmp 	TypeError 					; wrong type.
.018a11					Command_NEXT:
.018a11	a9 00		lda #$00			lda 	#0 							; set variable data pointer+1 to zero
.018a13	85 23		sta $23				sta 	zVarDataPtr+1 				; this means we don't check
.018a15	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018a17	c9 00		cmp #$00			cmp 	#0 							; EOL
.018a19	f0 07		beq $018a22			beq 	_CNextNoVariable
.018a1b	c9 40		cmp #$40			cmp 	#$40
.018a1d	b0 03		bcs $018a22			bcs 	_CNextNoVariable
.018a1f	20 56 99	jsr $019956			jsr 	VariableFind
.018a22					_CNextNoVariable:
.018a22	a5 26		lda $26				lda 	zBasicSP 					; save on stack
.018a24	48		pha				pha
.018a25	a5 27		lda $27				lda 	zBasicSP+1
.018a27	48		pha				pha
.018a28	a9 50		lda #$50			lda 	#(SMark_For << 4) 			; pop loop address frame
.018a2a	20 c9 84	jsr $0184c9			jsr 	StackPopFrame
.018a2d	a9 50		lda #$50			lda 	#(SMark_For << 4) 			; pop STEP/TARGET frame.
.018a2f	20 c9 84	jsr $0184c9			jsr 	StackPopFrame
.018a32	a9 50		lda #$50			lda 	#(Smark_For << 4) 			; pop variable address frame.
.018a34	20 c9 84	jsr $0184c9			jsr 	StackPopFrame
.018a37	a5 23		lda $23				lda 	zVarDataPtr+1 				; if zero, then no variable provided
.018a39	f0 11		beq $018a4c			beq 	_CNextGetTarget 			; e.g. just NEXT not NEXT x
.018a3b	5a		phy				phy 								; check addresses match.
.018a3c	a0 02		ldy #$02			ldy 	#2
.018a3e	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a40	c5 22		cmp $22				cmp 	zVarDataPtr
.018a42	d0 69		bne $018aad			bne 	_CNextWrong
.018a44	c8		iny				iny
.018a45	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a47	c5 23		cmp $23				cmp 	zVarDataPtr+1
.018a49	d0 62		bne $018aad			bne 	_CNextWrong
.018a4b	7a		ply				ply
.018a4c					_CNextGetTarget:
.018a4c	5a		phy				phy
.018a4d	a0 01		ldy #$01			ldy 	#1 							; restore variable type and data.
.018a4f	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a51	85 24		sta $24				sta 	zVarType
.018a53	c8		iny				iny
.018a54	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a56	85 22		sta $22				sta 	zVarDataPtr
.018a58	c8		iny				iny
.018a59	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a5b	85 23		sta $23				sta 	zVarDataPtr+1
.018a5d	a2 0c		ldx #$0c			ldx 	#12
.018a5f	20 9e 9c	jsr $019c9e			jsr 	VariableGet 				; get that variable value into expr[2]
.018a62	a2 00		ldx #$00			ldx 	#0 							; copy stacked Target/Step into expr[0] and [1]
.018a64	a0 0b		ldy #$0b			ldy 	#11
.018a66					_CNXCopy:
.018a66	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a68	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018a6a	e8		inx				inx
.018a6b	c8		iny				iny
.018a6c	e0 0c		cpx #$0c			cpx 	#XS_Size*2
.018a6e	d0 f6		bne $018a66			bne 	_CNXCopy
.018a70	7a		ply				ply
.018a71	a2 06		ldx #$06			ldx 	#6 							; point at expr[1] s
.018a73	20 d6 94	jsr $0194d6			jsr 	GetSignCurrent
.018a76	8d a7 03	sta $03a7			sta 	SignNext 					; save in temporary.
.018a79	a2 06		ldx #$06			ldx 	#6 							; add them, however
.018a7b	20 b5 93	jsr $0193b5			jsr 	BinaryOp_Add
.018a7e	20 ef 9c	jsr $019cef			jsr 	VariableSet					; and write variable back.
.018a81	a2 00		ldx #$00			ldx 	#0
.018a83	20 39 93	jsr $019339			jsr 	CompareValues
.018a86	09 00		ora #$00			ora 	#0
.018a88	f0 05		beq $018a8f			beq 	_CNXAgain 					; if true, then do it again.
.018a8a	cd a7 03	cmp $03a7			cmp 	SignNext 					; if sign different, then loop has finished.
.018a8d	d0 0f		bne $018a9e			bne 	_CNXLoopDone
.018a8f					_CNXAgain:
.018a8f	a9 53		lda #$53			lda 	#(SMark_For << 4) + 3		; re-stack variable address
.018a91	20 b2 84	jsr $0184b2			jsr 	StackPushFrame
.018a94	20 16 85	jsr $018516			jsr 	StackRestorePosition 		; get restore position back, e.g. loop round.
.018a97	68		pla				pla
.018a98	85 27		sta $27				sta 	zBasicSP+1
.018a9a	68		pla				pla
.018a9b	85 26		sta $26				sta 	zBasicSP
.018a9d					_CNXExit:
.018a9d	60		rts				rts
.018a9e					_CNXLoopDone:
.018a9e	68		pla				pla
.018a9f	68		pla				pla
.018aa0	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018aa2	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma ?
.018aa4	d0 f7		bne $018a9d			bne 	_CNXExit
.018aa6	c8		iny				iny
.018aa7	20 56 99	jsr $019956			jsr 	VariableFind 				; identify the variable
.018aaa	4c 22 8a	jmp $018a22			jmp 	_CNextNoVariable 			; go back with variable pre-found
.018aad					_CNextWrong:
.018aad	20 79 85	jsr $018579			jsr ERR_Handler
>018ab0	57 72 6f 6e 67 20 4e 65			.text "Wrong Next Variable",0
>018ab8	78 74 20 56 61 72 69 61 62 6c 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/read.asm

.018ac4					Command_READ:
.018ac4	20 56 99	jsr $019956			jsr 	VariableFind 				; get variable/value into zVarDataPtr,zVarType
.018ac7	a5 22		lda $22				lda 	zVarDataPtr 				; save variable info on stack
.018ac9	48		pha				pha
.018aca	a5 23		lda $23				lda 	zVarDataPtr+1
.018acc	48		pha				pha
.018acd	a5 24		lda $24				lda 	zVarType
.018acf	48		pha				pha
.018ad0	20 16 8b	jsr $018b16			jsr 	READGetDataItem 			; get the next data item
.018ad3	68		pla				pla 								; restore target variable information.
.018ad4	85 24		sta $24				sta 	zVarType
.018ad6	68		pla				pla
.018ad7	85 23		sta $23				sta 	zVarDataPtr+1
.018ad9	68		pla				pla
.018ada	85 22		sta $22				sta 	zVarDataPtr
.018adc	a2 00		ldx #$00			ldx 	#0
.018ade	20 ef 9c	jsr $019cef			jsr 	VariableSet 				; set the value out.
.018ae1	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018ae3	c8		iny				iny
.018ae4	c9 bf		cmp #$bf			cmp 	#token_Comma
.018ae6	f0 dc		beq $018ac4			beq 	Command_READ 				; found, do another READ
.018ae8	88		dey				dey
.018ae9	60		rts				rts
.018aea					Command_DATA:
.018aea	4c 80 84	jmp $018480			jmp 	SkipEndOfCommand
.018aed					Command_RESTORE:
.018aed	48		pha				pha
.018aee	a9 00		lda #$00			lda 	#0 							; this being zero means 'initialise next read'
.018af0	8d bd 03	sta $03bd			sta 	DataLPtr+0
.018af3	8d be 03	sta $03be			sta 	DataLPtr+1
.018af6	68		pla				pla
.018af7	60		rts				rts
.018af8					READSwapPointers:
.018af8	98		tya				tya
.018af9	48		pha				pha 								; save it
.018afa	ad c1 03	lda $03c1			lda 	DataIndex 					; get data offset, and copy to offset
.018afd	a8		tay				tay
.018afe	68		pla				pla 								; get code offset and save in DataIndex
.018aff	8d c1 03	sta $03c1			sta 	DataIndex
.018b02	da		phx				phx
.018b03	a2 03		ldx #$03			ldx 	#3 							; swap the Data Pointers (4 bytes) round.
.018b05					_RSWLoop:
.018b05	bd bd 03	lda $03bd,x			lda 	DataLPtr+0,x
.018b08	48		pha				pha
.018b09	b5 16		lda $16,x			lda 	zCodePtr+0,x
.018b0b	9d bd 03	sta $03bd,x			sta 	DataLPtr+0,x
.018b0e	68		pla				pla
.018b0f	95 16		sta $16,x			sta 	zCodePtr+0,x
.018b11	ca		dex				dex
.018b12	10 f1		bpl $018b05			bpl 	_RSWLoop
.018b14	fa		plx				plx
.018b15	60		rts				rts
.018b16					READGetDataItem:
.018b16	20 f8 8a	jsr $018af8			jsr 	ReadSwapPointers 			; swap code and data pointer.
.018b19	a5 16		lda $16				lda		zCodePtr+0 					; initialise ?
.018b1b	05 17		ora $17				ora 	zCodePtr+1
.018b1d	d0 12		bne $018b31			bne 	_RGDIIsInitialised
.018b1f	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018b21	85 16		sta $16				sta 	zCodePtr+0
.018b23	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018b25	85 17		sta $17				sta 	zCodePtr+1
.018b27	a9 00		lda #$00			lda 	#0
.018b29	85 18		sta $18				sta 	zCodePtr+2
.018b2b	85 19		sta $19				sta 	zCodePtr+3
.018b2d	a0 03		ldy #$03			ldy 	#3
.018b2f	80 06		bra $018b37			bra 	_RGDIFindData 				; locate next data from start and read that.
.018b31					_RGDIIsInitialised:
.018b31	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018b33	c9 bf		cmp #$bf			cmp 	#token_Comma
.018b35	f0 49		beq $018b80			beq 	_RGDISkipEvaluateExit
.018b37					_RGDIFindData:
.018b37	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018b39	c9 00		cmp #$00			cmp 	#0 							; end of line
.018b3b	f0 19		beq $018b56			beq 	_RGDIFindNextLine
.018b3d	c9 c5		cmp #$c5			cmp 	#token_DATA 				; found data token
.018b3f	f0 3f		beq $018b80			beq 	_RGDISkipEvaluateExit 		; then skip it and evaluate
.018b41	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018b43	c8		iny				iny 								; skip
.018b44	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018b46	90 0c		bcc $018b54			bcc 	_SEDone 					; so just skip over it.
.018b48	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018b4a	90 07		bcc $018b53			bcc 	_SEDouble
.018b4c	98		tya				tya 								; this is Y + 1
.018b4d	18		clc				clc
.018b4e	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018b50	a8		tay				tay 								; back in Y.
.018b51	88		dey				dey 								; fix up, one for the +1, one for the iny
.018b52	88		dey				dey
.018b53					_SEDouble:
.018b53	c8		iny				iny
.018b54					_SEDone:
.018b54	80 e1		bra $018b37			bra 	_RGDIFindData
.018b56					_RGDIFindNextLine:
.018b56	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018b58	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.018b5a	18		clc				clc
.018b5b	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018b5d	85 16		sta $16				sta 	zCodePtr
.018b5f	90 02		bcc $018b63			bcc 	_SNLNoCarry
.018b61	e6 17		inc $17				inc 	zCodePtr+1
.018b63					_SNLNoCarry:
.018b63	a0 00		ldy #$00			ldy 	#0
.018b65	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018b67	48		pha				pha
.018b68	c8		iny				iny
.018b69	c8		iny				iny
.018b6a	c8		iny				iny
.018b6b	68		pla				pla
.018b6c	d0 c9		bne $018b37			bne 	_RGDIFindData 				; back to scanning.
.018b6e	20 f8 8a	jsr $018af8			jsr 	ReadSwapPointers 			; so we get error in line number of READ
.018b71	20 79 85	jsr $018579			jsr ERR_Handler
>018b74	4f 75 74 20 6f 66 20 44			.text "Out of Data",0
>018b7c	61 74 61 00
.018b80					_RGDISkipEvaluateExit:
.018b80	c8		iny				iny
.018b81	20 ce 90	jsr $0190ce			jsr 	EvaluateExpression 			; evaluate the expression
.018b84	20 f8 8a	jsr $018af8			jsr 	ReadSwapPointers 			; swap the pointers around.
.018b87	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/let.asm

.018b88					Command_LET:
.018b88	20 56 99	jsr $019956			jsr 	VariableFind 				; get reference to one variable.
.018b8b	a9 84		lda #$84			lda 	#token_Equal  				; get equals
.018b8d	20 91 98	jsr $019891			jsr 	CheckNextToken
.018b90	a5 22		lda $22				lda 	zVarDataPtr 				; save variable info on stack
.018b92	48		pha				pha
.018b93	a5 23		lda $23				lda 	zVarDataPtr+1
.018b95	48		pha				pha
.018b96	a5 24		lda $24				lda 	zVarType
.018b98	48		pha				pha
.018b99	20 ce 90	jsr $0190ce			jsr 	EvaluateExpression 			; evaluate the RHS, set X to zero.
.018b9c	68		pla				pla 								; restore target variable information.
.018b9d	85 24		sta $24				sta 	zVarType
.018b9f	68		pla				pla
.018ba0	85 23		sta $23				sta 	zVarDataPtr+1
.018ba2	68		pla				pla
.018ba3	85 22		sta $22				sta 	zVarDataPtr
.018ba5	20 ef 9c	jsr $019cef			jsr 	VariableSet 				; set the value out.
.018ba8	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/get.asm

.018ba9					Command_GET:
.018ba9					_CGLoop:
.018ba9	20 56 99	jsr $019956			jsr 	VariableFind 				; get a variable.
.018bac	20 35 85	jsr $018535			jsr 	VIOCharGet 					; get character
.018baf	b0 02		bcs $018bb3			bcs 	_CGNoKey
.018bb1	a9 00		lda #$00			lda 	#0 							; if no character return zero
.018bb3					_CGNoKey:
.018bb3	48		pha				pha
.018bb4	a5 24		lda $24				lda 	zVarType 					; look at the data type.
.018bb6	c9 b7		cmp #$b7			cmp 	#token_Dollar
.018bb8	f0 1e		beq $018bd8			beq 	_CGString
.018bba	68		pla				pla 								; put character in slot.
.018bbb	85 80		sta $80				sta 	XS_Mantissa
.018bbd	a9 00		lda #$00			lda 	#0
.018bbf	85 81		sta $81				sta 	XS_Mantissa+1
.018bc1	85 82		sta $82				sta 	XS_Mantissa+2
.018bc3	85 83		sta $83				sta 	XS_Mantissa+3
.018bc5	a9 01		lda #$01			lda 	#1 							; type integer
.018bc7	85 85		sta $85				sta 	XS_Type
.018bc9					_CGWriteSetNext:
.018bc9	a2 00		ldx #$00			ldx 	#0 							; write number/WriteTempString out
.018bcb	20 ef 9c	jsr $019cef			jsr 	VariableSet
.018bce	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018bd0	c9 bf		cmp #$bf			cmp 	#token_Comma 				; if not comma exit
.018bd2	d0 03		bne $018bd7			bne 	_CGExit
.018bd4	c8		iny				iny
.018bd5	80 d2		bra $018ba9			bra 	_CGLoop 					; and get another.
.018bd7					_CGExit:
.018bd7	60		rts				rts
.018bd8					_CGString:
.018bd8	a9 02		lda #$02			lda 	#2 							; allocate temp string, space for 2.
.018bda	20 f5 98	jsr $0198f5			jsr 	AllocateTempString 			; initially empty.
.018bdd	a5 20		lda $20				lda 	zTempStr 					; set up to be returned.
.018bdf	85 80		sta $80				sta 	XS_Mantissa
.018be1	a5 21		lda $21				lda 	zTempStr+1
.018be3	85 81		sta $81				sta 	XS_Mantissa+1
.018be5	a9 02		lda #$02			lda 	#2
.018be7	85 85		sta $85				sta 	XS_Type
.018be9	68		pla				pla 								; get A
.018bea	c9 00		cmp #$00			cmp 	#0
.018bec	f0 db		beq $018bc9			beq 	_CGWriteSetNext
.018bee	20 20 99	jsr $019920			jsr 	WriteTempString 			; write it into string
.018bf1	80 d6		bra $018bc9			bra 	_CGWriteSetNext

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/sys.asm

.018bf3					Command_SYS:
.018bf3	20 64 92	jsr $019264			jsr 	EvaluateInteger 			; address
.018bf6	a5 80		lda $80				lda 	XS_Mantissa+0				; copy to localvector
.018bf8	8d 10 03	sta $0310			sta 	LocalVector+0 				; only three, can only do 24 bit calls
.018bfb	a5 81		lda $81				lda 	XS_Mantissa+1 				; and that only on 65816
.018bfd	8d 11 03	sta $0311			sta 	LocalVector+1
.018c00	a5 82		lda $82				lda 	XS_Mantissa+2
.018c02	8d 12 03	sta $0312			sta 	LocalVector+2
.018c05	22 0a 8c 01	jsl $018c0a			jsl 	_CSYLocalCall
.018c09	60		rts				rts
.018c0a					_CSYLocalCall:
.018c0a	dc 10 03	jmp [$0310]			jmp 	[LocalVector]

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/end.asm

.018c0d					Command_END:
>018c0d	02						.byte 	2
.018c0e	4c 32 88	jmp $018832			jmp 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/if.asm

.018c11					Command_IF:
.018c11	20 64 92	jsr $019264			jsr 	EvaluateInteger 			; check success.
.018c14	a5 80		lda $80				lda 	XS_Mantissa+0				; check the result if zero
.018c16	05 81		ora $81				ora 	XS_Mantissa+1
.018c18	05 82		ora $82				ora 	XS_Mantissa+2
.018c1a	05 83		ora $83				ora 	XS_Mantissa+3
.018c1c	aa		tax				tax 								; put into X.
.018c1d	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c1f	c9 93		cmp #$93			cmp 	#token_Then 				; then found.
.018c21	d0 2c		bne $018c4f			bne 	_FIFExtended
.018c23	c8		iny				iny
.018c24	e0 00		cpx #$00			cpx 	#0 							; was it successful.
.018c26	f0 0b		beq $018c33			beq 	_FIFEndOfLine 				; if not, go to the end of the line.
.018c28	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c2a	29 c0		and #$c0			and 	#$C0 						; is it a number
.018c2c	c9 40		cmp #$40			cmp 	#$40
.018c2e	d0 1e		bne $018c4e			bne 	_FIFContinue 				; if not, do what ever follows.
.018c30	4c 9e 8f	jmp $018f9e			jmp		Command_GOTO 				; we have IF <expr> THEN <number> so we do GOTO code.
.018c33					_FIFEndOfLine:
.018c33	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c35	c9 00		cmp #$00			cmp 	#0 							; if zero, end of line, so exit
.018c37	f0 15		beq $018c4e			beq 	_FIFContinue
.018c39	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018c3b	c8		iny				iny 								; skip
.018c3c	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018c3e	90 0c		bcc $018c4c			bcc 	_SEDone 					; so just skip over it.
.018c40	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018c42	90 07		bcc $018c4b			bcc 	_SEDouble
.018c44	98		tya				tya 								; this is Y + 1
.018c45	18		clc				clc
.018c46	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018c48	a8		tay				tay 								; back in Y.
.018c49	88		dey				dey 								; fix up, one for the +1, one for the iny
.018c4a	88		dey				dey
.018c4b					_SEDouble:
.018c4b	c8		iny				iny
.018c4c					_SEDone:
.018c4c	80 e5		bra $018c33			bra 	_FIFEndOfLine
.018c4e					_FIFContinue:
.018c4e	60		rts				rts
.018c4f					_FIFExtended:
.018c4f	da		phx				phx 								; save result
.018c50	a9 40		lda #$40			lda 	#(SMark_If << 4) 			; push marker on the stack, nothing else.
.018c52	20 b2 84	jsr $0184b2			jsr 	StackPushFrame
.018c55	68		pla				pla 								; restore result
.018c56	f0 01		beq $018c59			beq 	_FIXSkip 					; if zero then it has failed.
.018c58	60		rts				rts 								; test passed, so continue executing
.018c59					_FIXSkip:
.018c59	a9 94		lda #$94			lda 	#token_endif 				; scan forward till found either ELSE or ENDIF
.018c5b	a2 de		ldx #$de			ldx 	#token_else 				; at the same level.
.018c5d	20 f5 83	jsr $0183f5			jsr 	StructureSearchDouble
.018c60	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c62	c8		iny				iny
.018c63	c9 94		cmp #$94			cmp 	#token_endif 				; if endif, handle endif code.
.018c65	f0 07		beq $018c6e			beq 	Command_ENDIF
.018c67	60		rts				rts
.018c68					Command_ELSE:
.018c68	a9 94		lda #$94			lda 	#token_endif 				; scan forward till found ENDIF
.018c6a	20 f3 83	jsr $0183f3			jsr 	StructureSearchSingle 		; then do the ENDIF pop.
.018c6d	c8		iny				iny
.018c6e					Command_ENDIF:
.018c6e	a9 40		lda #$40			lda 	#(SMark_If << 4)
.018c70	20 c9 84	jsr $0184c9			jsr 	StackPopFrame
.018c73	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/list.asm

.018c74					Command_LIST:
.018c74	20 01 8e	jsr $018e01			jsr 	ListGetRange				; get any parameters
.018c77	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018c79	85 16		sta $16				sta 	zCodePtr+0
.018c7b	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018c7d	85 17		sta $17				sta 	zCodePtr+1
.018c7f	a9 00		lda #$00			lda 	#0
.018c81	85 18		sta $18				sta 	zCodePtr+2
.018c83	85 19		sta $19				sta 	zCodePtr+3
.018c85	a0 03		ldy #$03			ldy 	#3
.018c87	a9 00		lda #$00			lda 	#0 							; reset the indent & last indent
.018c89	8d bc 03	sta $03bc			sta 	LastListIndent
.018c8c	8d bb 03	sta $03bb			sta 	ListIndent
.018c8f					_CILLoop:
.018c8f	a0 00		ldy #$00			ldy 	#0
.018c91	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c93	c9 00		cmp #$00			cmp 	#0 							; if zero, end of program
.018c95	f0 23		beq $018cba			beq 	_CILExit
.018c97	20 40 85	jsr $018540			jsr 	VIOCheckBreak 				; check break
.018c9a	c9 00		cmp #$00			cmp 	#0
.018c9c	d0 1c		bne $018cba			bne 	_CILExit
.018c9e	20 48 8e	jsr $018e48			jsr 	ListCheckRange 				; check current line in range.
.018ca1	b0 08		bcs $018cab			bcs		_CILNext
.018ca3	a0 00		ldy #$00			ldy 	#0
.018ca5	c8		iny				iny
.018ca6	c8		iny				iny
.018ca7	c8		iny				iny
.018ca8	20 bd 8c	jsr $018cbd			jsr 	ListLine 					; list one line.
.018cab					_CILNext:
.018cab	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018cad	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.018caf	18		clc				clc
.018cb0	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018cb2	85 16		sta $16				sta 	zCodePtr
.018cb4	90 02		bcc $018cb8			bcc 	_SNLNoCarry
.018cb6	e6 17		inc $17				inc 	zCodePtr+1
.018cb8					_SNLNoCarry:
.018cb8	80 d5		bra $018c8f			bra 	_CILLoop
.018cba					_CILExit:
.018cba	4c 32 88	jmp $018832			jmp 	WarmStart
.018cbd					ListLine:
.018cbd	ad bb 03	lda $03bb			lda 	ListIndent 					; copy current list indent -> last
.018cc0	8d bc 03	sta $03bc			sta 	LastListIndent
.018cc3					_LICountIndent:
.018cc3	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018cc5	c9 00		cmp #$00			cmp 	#0
.018cc7	f0 2f		beq $018cf8			beq 	_LIDoneIndent
.018cc9	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus
.018ccb	90 16		bcc $018ce3			bcc 	_LICINext
.018ccd	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.018ccf	b0 12		bcs $018ce3			bcs 	_LICINext
.018cd1	ee bb 03	inc $03bb			inc 	ListIndent
.018cd4	c9 93		cmp #$93			cmp 	#firstKeywordMinus
.018cd6	90 0b		bcc $018ce3			bcc 	_LICINext
.018cd8	ce bb 03	dec $03bb			dec 	ListIndent
.018cdb	ce bb 03	dec $03bb			dec 	ListIndent
.018cde	10 03		bpl $018ce3			bpl 	_LICINext
.018ce0	ee bb 03	inc $03bb			inc 	ListIndent
.018ce3					_LICINext:
.018ce3	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018ce5	c8		iny				iny 								; skip
.018ce6	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018ce8	90 0c		bcc $018cf6			bcc 	_SEDone 					; so just skip over it.
.018cea	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018cec	90 07		bcc $018cf5			bcc 	_SEDouble
.018cee	98		tya				tya 								; this is Y + 1
.018cef	18		clc				clc
.018cf0	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018cf2	a8		tay				tay 								; back in Y.
.018cf3	88		dey				dey 								; fix up, one for the +1, one for the iny
.018cf4	88		dey				dey
.018cf5					_SEDouble:
.018cf5	c8		iny				iny
.018cf6					_SEDone:
.018cf6	80 cb		bra $018cc3			bra 	_LICountIndent
.018cf8					_LIDoneIndent:
.018cf8	a0 00		ldy #$00			ldy 	#0
.018cfa	c8		iny				iny
.018cfb	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018cfd	85 80		sta $80				sta 	XS_Mantissa
.018cff	c8		iny				iny
.018d00	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018d02	85 81		sta $81				sta 	XS_Mantissa+1
.018d04	20 bf 85	jsr $0185bf			jsr 	Print16BitInteger 			; print integer.
.018d07	85 10		sta $10				sta 	zTemp1 						; save spaces printed.
.018d09	ad bb 03	lda $03bb			lda 	ListIndent 					; smaller of current/prev indent
.018d0c	cd bc 03	cmp $03bc			cmp 	LastListIndent
.018d0f	90 03		bcc $018d14			bcc 	_LISmaller
.018d11	ad bc 03	lda $03bc			lda 	LastListIndent
.018d14					_LISmaller:
.018d14	0a		asl a				asl 	a 							; double indent
.018d15	49 ff		eor #$ff			eor 	#$FF 						; 2's complement arithmetic
.018d17	38		sec				sec
.018d18	65 10		adc $10				adc 	zTemp1 						; "subtract" indent e.g. print more.
.018d1a	aa		tax				tax 								; print spaces to column 6
.018d1b					_LISpace:
.018d1b	a9 20		lda #$20			lda 	#" "
.018d1d	20 f1 8d	jsr $018df1			jsr 	ListPrintLC
.018d20	e8		inx				inx
.018d21	e0 06		cpx #$06			cpx 	#6
.018d23	d0 f6		bne $018d1b			bne 	_LISpace
.018d25					_LIDecode:
.018d25	c8		iny				iny
.018d26	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018d28	c9 00		cmp #$00			cmp 	#0 							; zero, exit.
.018d2a	f0 0f		beq $018d3b			beq 	_LIExit
.018d2c	30 12		bmi $018d40			bmi 	_LIToken
.018d2e	c9 40		cmp #$40			cmp 	#$40 						; 01-$3F, character.
.018d30	b0 50		bcs $018d82			bcs 	_LIInteger
.018d32	49 20		eor #$20			eor 	#$20 						; make 7 bit
.018d34	69 20		adc #$20			adc 	#$20
.018d36	20 f1 8d	jsr $018df1			jsr 	ListPrintLC 				; print in LC
.018d39	80 ea		bra $018d25			bra 	_LIDecode
.018d3b					_LIExit:
.018d3b	a9 0d		lda #$0d			lda 	#13 						; print new line.
.018d3d	4c f1 8d	jmp $018df1			jmp 	ListPrintLC
.018d40					_LIToken:
.018d40	c9 fc		cmp #$fc			cmp 	#$FC 						; $FC-$FF ?
.018d42	90 49		bcc $018d8d			bcc		_LICommandToken
.018d44	48		pha				pha 								; save in case end
.018d45	a2 22		ldx #$22			ldx 	#'"'						; print if $FE quoted string
.018d47	c9 fe		cmp #$fe			cmp 	#$FE
.018d49	f0 17		beq $018d62			beq 	_LIPrint
.018d4b	a2 2e		ldx #$2e			ldx 	#'.'						; print if $FD decimals
.018d4d	c9 fd		cmp #$fd			cmp 	#$FD
.018d4f	f0 11		beq $018d62			beq 	_LIPrint
.018d51	a9 52		lda #$52			lda 	#'R'						; must be REM
.018d53	20 f1 8d	jsr $018df1			jsr 	ListPrintLC
.018d56	a9 45		lda #$45			lda 	#'E'
.018d58	20 f1 8d	jsr $018df1			jsr 	ListPrintLC
.018d5b	a9 4d		lda #$4d			lda 	#'M'
.018d5d	20 f1 8d	jsr $018df1			jsr 	ListPrintLC
.018d60	a2 20		ldx #$20			ldx 	#' '
.018d62					_LIPrint:
.018d62	8a		txa				txa
.018d63	20 f1 8d	jsr $018df1			jsr 	ListPrintLC
.018d66	c8		iny				iny
.018d67	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018d69	aa		tax				tax 								; put in X
.018d6a	ca		dex				dex
.018d6b					_LILoop:
.018d6b	ca		dex				dex 								; exit when count reached zero.
.018d6c	f0 08		beq $018d76			beq 	_LIEnd
.018d6e	c8		iny				iny
.018d6f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018d71	20 f1 8d	jsr $018df1			jsr 	ListPrintLC
.018d74	80 f5		bra $018d6b			bra 	_LILoop
.018d76	68		pla		_LIEnd:	pla 								; get A back
.018d77	c9 fe		cmp #$fe			cmp 	#$FE 						; if '"' need closing quotes
.018d79	d0 aa		bne $018d25			bne 	_LIDecode
.018d7b	a9 22		lda #$22			lda 	#'"'
.018d7d	20 f1 8d	jsr $018df1			jsr 	ListPrintLC
.018d80	80 a3		bra $018d25			bra 	_LIDecode
.018d82					_LIInteger:
.018d82	a2 00		ldx #$00			ldx 	#0
.018d84	20 d6 91	jsr $0191d6			jsr 	EvaluateGetInteger 			; get an atom
.018d87	88		dey				dey
.018d88	20 c5 85	jsr $0185c5			jsr 	Print32BitInteger 			; print integer.
.018d8b	80 98		bra $018d25			bra 	_LIDecode
.018d8d					_LICommandToken:
.018d8d	5a		phy				phy 								; save Y
.018d8e	48		pha				pha 								; save token
.018d8f	a2 bd		ldx #$bd			ldx  	#KeywordText & $FF 			; address of keyword text table.
.018d91	a9 86		lda #$86			lda 	(#KeywordText >> 8) & $FF
.018d93	86 1a		stx $1a				stx 	zLTemp1
.018d95	85 1b		sta $1b				sta 	zLTemp1+1
.018d97	a9 01		lda #$01			lda 	(#KeywordText >> 16) & $FF 	; this is for 65816 (it's a table in code
.018d99	85 1c		sta $1c				sta 	zLTemp1+2 					; space) and won't affect a 6502 at all.
.018d9b	68		pla				pla 								; get token
.018d9c	29 7f		and #$7f			and 	#127 						; chuck bit 7.
.018d9e	f0 16		beq $018db6			beq 	_LIFoundToken
.018da0	aa		tax				tax
.018da1					_LITokenLoop:
.018da1	a0 00		ldy #$00			ldy 	#0 							; last character not a token.
.018da3					_LIFindEnd:
.018da3	b7 1a		lda [$1a],y			lda 	[zLTemp1],y
.018da5	c8		iny				iny
.018da6	0a		asl a				asl 	a
.018da7	90 fa		bcc $018da3			bcc 	_LIFindEnd
.018da9	98		tya				tya 								; that is step to the next
.018daa	18		clc				clc 								; we don't bother bumping the 3rd byte
.018dab	65 1a		adc $1a				adc 	zLTemp1 					; here.
.018dad	85 1a		sta $1a				sta 	zLTemp1
.018daf	90 02		bcc $018db3			bcc 	_LINoBump
.018db1	e6 1b		inc $1b				inc 	zLTemp1+1
.018db3					_LINoBump:
.018db3	ca		dex				dex 								; no go round again.
.018db4	d0 eb		bne $018da1			bne 	_LITokenLoop
.018db6					_LIFoundToken:
.018db6	a0 00		ldy #$00			ldy 	#0
.018db8					_LIPrintToken:
.018db8	b7 1a		lda [$1a],y			lda 	[zLTemp1],y
.018dba	c0 00		cpy #$00			cpy 	#0 							; see if needs prefix space
.018dbc	d0 16		bne $018dd4			bne 	_LINoPrefixSpace
.018dbe	c9 41		cmp #$41			cmp 	#"A" 						; e.g. alphabetic token.
.018dc0	90 12		bcc $018dd4			bcc 	_LINoPrefixSpace
.018dc2	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018dc4	b0 0e		bcs $018dd4			bcs 	_LINoPrefixSpace
.018dc6	ae ba 03	ldx $03ba			ldx 	LastPrinted 				; if last was space not required
.018dc9	e0 20		cpx #$20			cpx 	#" "
.018dcb	f0 07		beq $018dd4			beq 	_LINoPrefixSpace
.018dcd	48		pha				pha
.018dce	a9 20		lda #$20			lda 	#" "
.018dd0	20 f1 8d	jsr $018df1			jsr 	ListPrintLC
.018dd3	68		pla				pla
.018dd4					_LINoPrefixSpace:
.018dd4	c8		iny				iny
.018dd5	48		pha				pha 								; save it
.018dd6	29 7f		and #$7f			and 	#$7F
.018dd8	20 f1 8d	jsr $018df1			jsr 	ListPrintLC
.018ddb	68		pla				pla
.018ddc	10 da		bpl $018db8			bpl 	_LIPrintToken 				; go back if not end
.018dde	7a		ply				ply 								; restore Y
.018ddf	29 7f		and #$7f			and 	#$7F 						; if last char is a letter
.018de1	c9 41		cmp #$41			cmp 	#"A"
.018de3	90 09		bcc $018dee			bcc 	_LINotLetter2
.018de5	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018de7	b0 05		bcs $018dee			bcs 	_LINotLetter2
.018de9	a9 20		lda #$20			lda 	#" " 						; add spacing
.018deb	20 f1 8d	jsr $018df1			jsr 	ListPrintLC
.018dee					_LINotLetter2:
.018dee	4c 25 8d	jmp $018d25			jmp 	_LIDecode
.018df1					ListPrintLC:
.018df1	8d ba 03	sta $03ba			sta 	LastPrinted
.018df4	c9 41		cmp #$41			cmp 	#"A"
.018df6	90 06		bcc $018dfe			bcc 	_LPLC0
.018df8	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018dfa	b0 02		bcs $018dfe			bcs 	_LPLC0
.018dfc	69 20		adc #$20			adc 	#$20
.018dfe	4c 32 85	jmp $018532	_LPLC0:	jmp 	VIOCharPrint
.018e01					ListGetRange:
.018e01	a2 0b		ldx #$0b			ldx 	#XS_Size*2-1 				; clear first 2 slots back to defaults.
.018e03					_LGRClear:
.018e03	a9 00		lda #$00			lda 	#0
.018e05	95 80		sta $80,x			sta 	XS_Mantissa,x
.018e07	ca		dex				dex
.018e08	10 f9		bpl $018e03			bpl 	_LGRClear
.018e0a	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e0c	c9 00		cmp #$00			cmp 	#0 							; nothing
.018e0e	f0 21		beq $018e31			beq 	_LGRBlank
.018e10	c9 c0		cmp #$c0			cmp 	#token_Colon 				; or colon
.018e12	f0 1d		beq $018e31			beq 	_LGRBlank
.018e14	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma
.018e16	f0 18		beq $018e30			beq 	_LGREnd 					; then it's LIST ,x
.018e18	20 64 92	jsr $019264			jsr 	EvaluateInteger 			; get the first number into bottom
.018e1b	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e1d	c9 bf		cmp #$bf			cmp 	#token_Comma
.018e1f	f0 0f		beq $018e30			beq 	_LGREnd 					; then it is LIST a,b
.018e21	a5 80		lda $80				lda 	XS_Mantissa+0 				; copy first to second LIST n is n,n
.018e23	85 86		sta $86				sta 	XS_Mantissa+XS_Size+0
.018e25	a5 81		lda $81				lda 	XS_Mantissa+1
.018e27	85 87		sta $87				sta 	XS_Mantissa+XS_Size+1
.018e29					_LGRBumpExit:
.018e29	e6 86		inc $86				inc 	XS_Mantissa+XS_Size 		; bump it so we can use cc.
.018e2b	d0 02		bne $018e2f			bne 	_LGRBump2
.018e2d	e6 87		inc $87				inc 	XS_Mantissa+XS_Size+1
.018e2f					_LGRBump2:
.018e2f	60		rts				rts
.018e30					_LGREnd:
.018e30	c8		iny				iny
.018e31					_LGRBlank:
.018e31	a9 ff		lda #$ff			lda 	#$FF 						; default to the end.
.018e33	85 86		sta $86				sta 	XS_Mantissa+XS_Size
.018e35	85 87		sta $87				sta 	XS_Mantissa+XS_Size+1
.018e37	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e39	c9 00		cmp #$00			cmp 	#0
.018e3b	f0 f2		beq $018e2f			beq 	_LGRBump2
.018e3d	0a		asl a				asl 	a 							; if not a number, then exit (to end)
.018e3e	b0 ef		bcs $018e2f			bcs 	_LGRBump2
.018e40	a2 06		ldx #$06			ldx 	#XS_Size 					; get to range
.018e42	20 66 92	jsr $019266			jsr 	EvaluateIntegerX
.018e45	80 e2		bra $018e29			bra 	_LGRBumpExit
.018e47	60		rts				rts
.018e48					ListCheckRange:
.018e48	c8		iny				iny
.018e49	a2 00		ldx #$00			ldx 	#0 							; test low
.018e4b	20 58 8e	jsr $018e58			jsr 	_LCRCompare
.018e4e	90 06		bcc $018e56			bcc 	_LCRFail
.018e50	a2 06		ldx #$06			ldx 	#XS_Size 					; test high
.018e52	20 58 8e	jsr $018e58			jsr 	_LCRCompare
.018e55	60		rts				rts
.018e56					_LCRFail:
.018e56	38		sec				sec
.018e57	60		rts				rts
.018e58					_LCRCompare:
.018e58	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e5a	38		sec				sec
.018e5b	f5 80		sbc $80,x			sbc	 	XS_Mantissa+0,x
.018e5d	08		php				php
.018e5e	c8		iny				iny
.018e5f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e61	28		plp				plp
.018e62	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.018e64	08		php				php
.018e65	88		dey				dey
.018e66	28		plp				plp
.018e67	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/print.asm

.018e68					Command_PRINTX:
.018e68					_CPR_Loop:
.018e68	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e6a	c9 00		cmp #$00			cmp 	#0 							; end
.018e6c	f0 24		beq $018e92			beq 	_CPR_GoNewLine
.018e6e	c9 c0		cmp #$c0			cmp 	#token_Colon
.018e70	f0 20		beq $018e92			beq 	_CPR_GoNewLine
.018e72	c9 c1		cmp #$c1			cmp 	#token_SemiColon
.018e74	f0 74		beq $018eea			beq 	_CPR_Skip
.018e76	c9 bf		cmp #$bf			cmp 	#token_Comma
.018e78	f0 57		beq $018ed1			beq 	_CPR_Tab
.018e7a	20 ce 90	jsr $0190ce			jsr 	EvaluateExpression 			; get expression.
.018e7d	a5 85		lda $85				lda 	XS_Type 					; get type.
.018e7f	29 02		and #$02			and 	#2
.018e81	d0 27		bne $018eaa			bne 	_CPR_String 				; if type = 2 output as string.
.018e83					_CPR_Number:
.018e83	a9 00		lda #$00			lda 	#0 							; reset buffer index
.018e85	8d 14 03	sta $0314			sta 	NumBufX
.018e88	a5 85		lda $85				lda 	XS_Type 					; get type
.018e8a	4a		lsr a				lsr 	a
.018e8b	b0 08		bcs $018e95			bcs 	_CPRInt 					; if msb set do as integer
.018e8d	20 b0 a3	jsr $01a3b0			jsr 	FPToString 					; call fp to str otherwise
.018e90	80 06		bra $018e98			bra 	_CPRNPrint
.018e92					_CPR_GoNewLine:
.018e92	4c f8 8e	jmp $018ef8			jmp 	_CPR_NewLine
.018e95	20 38 9e	jsr $019e38	_CPRInt:jsr 	IntToString
.018e98					_CPRNPrint:
.018e98	ad 15 03	lda $0315			lda 	Num_Buffer 					; is first character -
.018e9b	c9 2d		cmp #$2d			cmp 	#"-"
.018e9d	f0 05		beq $018ea4			beq 	_CPRNoSpace
.018e9f	a9 20		lda #$20			lda 	#" "						; print the leading space
.018ea1	20 32 85	jsr $018532			jsr 	VIOCharPrint 				; so beloved of MS Basics.
.018ea4					_CPRNoSpace:
.018ea4	a2 14		ldx #$14			ldx 	#(Num_Buffer-1) & $FF
.018ea6	a9 03		lda #$03			lda 	#(Num_Buffer-1) >> 8
.018ea8	80 04		bra $018eae			bra 	_CPRPrint
.018eaa					_CPR_String:
.018eaa	a6 80		ldx $80				ldx 	XS_Mantissa
.018eac	a5 81		lda $81				lda 	XS_Mantissa+1
.018eae					_CPRPrint:
.018eae	86 1e		stx $1e				stx 	zGenPtr
.018eb0	85 1f		sta $1f				sta 	zGenPtr+1
.018eb2	5a		phy				phy
.018eb3	a0 00		ldy #$00			ldy 	#0							; get length into X
.018eb5	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018eb7	aa		tax				tax
.018eb8	f0 09		beq $018ec3			beq 	_CPREndPrint 				; nothing to print
.018eba					_CPRLoop:
.018eba	c8		iny				iny
.018ebb	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018ebd	20 32 85	jsr $018532			jsr 	VIOCharPrint
.018ec0	ca		dex				dex
.018ec1	d0 f7		bne $018eba			bne 	_CPRLoop
.018ec3					_CPREndPrint:
.018ec3	a5 85		lda $85				lda 	XS_Type 					; if numeric add trailing space
.018ec5	29 02		and #$02			and 	#2
.018ec7	d0 05		bne $018ece			bne 	_CPRNoTrail
.018ec9	a9 20		lda #$20			lda 	#" "
.018ecb	20 32 85	jsr $018532			jsr 	VIOCharPrint
.018ece					_CPRNoTrail:
.018ece	7a		ply				ply
.018ecf	80 97		bra $018e68			bra 	_CPR_Loop
.018ed1					_CPR_Tab:
.018ed1	20 43 85	jsr $018543			jsr 	VIOCharGetPosition 			; print until position % 8 = 0
.018ed4					_CPR_CalcSpaces:
.018ed4	38		sec				sec 								; calculate position mod 10.
.018ed5	e9 0a		sbc #$0a			sbc 	#10
.018ed7	b0 fb		bcs $018ed4			bcs 	_CPR_CalcSpaces
.018ed9	69 0a		adc #$0a			adc 	#10
.018edb	f0 0d		beq $018eea			beq 	_CPR_Skip 					; nothing to print
.018edd	aa		tax				tax 								; print out spaces to mod 10
.018ede					_CPRTabSpaces:
.018ede	a9 20		lda #$20			lda 	#" "
.018ee0	20 32 85	jsr $018532			jsr 	VIOCharPrint
.018ee3	e8		inx				inx
.018ee4	e0 0a		cpx #$0a			cpx 	#10
.018ee6	d0 f6		bne $018ede			bne 	_CPRTabSpaces
.018ee8	80 e7		bra $018ed1			bra 	_CPR_Tab
.018eea					_CPR_Skip:
.018eea	c8		iny				iny
.018eeb	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018eed	c9 c0		cmp #$c0			cmp 	#token_Colon 				; colon or $00, exit
.018eef	f0 0c		beq $018efd			beq 	_CPR_Exit
.018ef1	c9 00		cmp #$00			cmp 	#0
.018ef3	f0 08		beq $018efd			beq 	_CPR_Exit 					; if not go round again.
.018ef5	4c 68 8e	jmp $018e68			jmp 	_CPR_Loop
.018ef8					_CPR_NewLine:
.018ef8	a9 0d		lda #$0d			lda 	#13
.018efa	20 32 85	jsr $018532			jsr 	VIOCharPrint
.018efd					_CPR_Exit:
.018efd	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/assert.asm

.018efe					Command_ASSERT:
.018efe	20 64 92	jsr $019264			jsr 	EvaluateInteger 			; calculate thing being asserted
.018f01	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; check if true (non-zero)
.018f03	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.018f05	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.018f07	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.018f09	f0 01		beq $018f0c			beq 	_ASFail
.018f0b	60		rts				rts
.018f0c					_ASFail:
.018f0c	20 79 85	jsr $018579			jsr ERR_Handler
>018f0f	41 73 73 65 72 74 00			.text "Assert",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/poke.asm

.018f16					Command_POKE:
.018f16	a9 01		lda #$01			lda 	#1
.018f18	80 06		bra $018f20			bra 	CmdPoke_Main
.018f1a					Command_DOKE:
.018f1a	a9 02		lda #$02			lda 	#2
.018f1c	80 02		bra $018f20			bra 	CmdPoke_Main
.018f1e					Command_LOKE:
.018f1e	a9 04		lda #$04			lda 	#4
.018f20					CmdPoke_Main:
.018f20	48		pha				pha
.018f21	20 64 92	jsr $019264			jsr 	EvaluateInteger 			; get two parameters.
.018f24	e8		inx				inx
.018f25	e8		inx				inx
.018f26	e8		inx				inx
.018f27	e8		inx				inx
.018f28	e8		inx				inx
.018f29	e8		inx				inx
.018f2a	20 b0 98	jsr $0198b0			jsr 	CheckNextComma
.018f2d	20 66 92	jsr $019266			jsr 	EvaluateIntegerX
.018f30	a5 80		lda $80				lda 	XS_Mantissa+0 			; copy the mantissa into ZLTemp1 (address)
.018f32	85 1a		sta $1a				sta 	zLTemp1
.018f34	a5 81		lda $81				lda 	XS_Mantissa+1
.018f36	85 1b		sta $1b				sta 	zLTemp1+1
.018f38	a5 82		lda $82				lda 	XS_Mantissa+2
.018f3a	85 1c		sta $1c				sta 	zLTemp1+2
.018f3c	a5 83		lda $83				lda 	XS_Mantissa+3
.018f3e	85 1d		sta $1d				sta 	zLTemp1+3
.018f40	68		pla				pla 								; get count
.018f41	5a		phy				phy 								; save Y
.018f42	20 3b 98	jsr $01983b			jsr 	MemWrite 					; write it out
.018f45	7a		ply				ply 								; restore Y and done.
.018f46	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/newold.asm

.018f47					Command_NEW:
.018f47	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018f49	85 16		sta $16				sta 	zCodePtr+0
.018f4b	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018f4d	85 17		sta $17				sta 	zCodePtr+1
.018f4f	a9 00		lda #$00			lda 	#0
.018f51	85 18		sta $18				sta 	zCodePtr+2
.018f53	85 19		sta $19				sta 	zCodePtr+3
.018f55	a0 03		ldy #$03			ldy 	#3
.018f57	a0 00		ldy #$00			ldy 	#0
.018f59	a9 00		lda #$00			lda 	#0 							; write a 0 there.
.018f5b	97 16		sta [$16],y			sta 	[zCodePtr],y
.018f5d	20 4c 98	jsr $01984c			jsr 	UpdateProgramEnd 			; update program end.
.018f60	4c 32 88	jmp $018832			jmp 	WarmStart
.018f63					Command_OLD:
.018f63	ea		nop				nop
.018f64	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018f66	85 16		sta $16				sta 	zCodePtr+0
.018f68	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018f6a	85 17		sta $17				sta 	zCodePtr+1
.018f6c	a9 00		lda #$00			lda 	#0
.018f6e	85 18		sta $18				sta 	zCodePtr+2
.018f70	85 19		sta $19				sta 	zCodePtr+3
.018f72	a0 03		ldy #$03			ldy 	#3
.018f74					_COL_Find:
.018f74	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018f76	c8		iny				iny
.018f77	c9 00		cmp #$00			cmp 	#0 							; if zero, then the position Y/Z is new offset
.018f79	f0 18		beq $018f93			beq 	_COL_Found
.018f7b	98		tya				tya
.018f7c	c9 00		cmp #$00			cmp 	#0
.018f7e	d0 f4		bne $018f74			bne 	_COL_Find 					; can't find old EOL, give up.
.018f80	20 79 85	jsr $018579			jsr ERR_Handler
>018f83	50 72 6f 67 72 61 6d 20			.text "Program Corrupt",0
>018f8b	43 6f 72 72 75 70 74 00
.018f93					_COL_Found:
.018f93	98		tya				tya
.018f94	48		pha				pha
.018f95	a0 00		ldy #$00			ldy 	#0
.018f97	68		pla				pla
.018f98	97 16		sta [$16],y			sta 	[zCodePtr],y
.018f9a	20 4c 98	jsr $01984c			jsr 	UpdateProgramEnd 			; reset variable pointer
.018f9d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/branch.asm

.018f9e					Command_GOTO:
.018f9e	20 f3 8f	jsr $018ff3			jsr 	GotoGetLineNumber
.018fa1					CmdGOTO:
.018fa1	a2 00		ldx #$00			ldx 	#0
.018fa3	4c 10 90	jmp $019010			jmp 	GotoChangeToLineNumberX
.018fa6					Command_GOSUB:
.018fa6	20 f3 8f	jsr $018ff3			jsr 	GotoGetLineNumber
.018fa9					CmdGOSUB:
.018fa9	20 f9 84	jsr $0184f9			jsr 	StackSavePosition
.018fac	a9 15		lda #$15			lda 	#(SMark_Gosub << 4)+SourcePosSize
.018fae	20 b2 84	jsr $0184b2			jsr 	StackPushFrame
.018fb1	a2 00		ldx #$00			ldx		#0
.018fb3	4c 10 90	jmp $019010			jmp 	GotoChangeToLineNumberX
.018fb6					Command_RETURN:
.018fb6	a9 10		lda #$10			lda 	#(SMark_Gosub << 4)
.018fb8	20 c9 84	jsr $0184c9			jsr 	StackPopFrame
.018fbb	20 16 85	jsr $018516			jsr 	StackRestorePosition
.018fbe	60		rts				rts
.018fbf					Command_ON:
.018fbf	a2 00		ldx #$00			ldx 	#0 							; get the ON.
.018fc1	20 00 97	jsr $019700			jsr 	SLIByteParameter
.018fc4	a5 80		lda $80				lda 	XS_Mantissa+0 				; get the count
.018fc6	f0 28		beq $018ff0			beq 	_CONFail 					; can't be zero.
.018fc8	aa		tax				tax 								; save in X.
.018fc9	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018fcb	c8		iny				iny
.018fcc	48		pha				pha
.018fcd	c9 cc		cmp #$cc			cmp 	#token_GOTO 				; must be GOTO or GOSUB
.018fcf	f0 07		beq $018fd8			beq 	_CONOkayToken
.018fd1	c9 ca		cmp #$ca			cmp 	#token_GOSUB
.018fd3	f0 03		beq $018fd8			beq 	_CONOkayToken
.018fd5	4c 4a 85	jmp $01854a			jmp 	SyntaxError
.018fd8					_CONOkayToken:
.018fd8	da		phx				phx 								; count on top, GOTO/GOSUB token 2nd.
.018fd9					_CONFindNumber:
.018fd9	20 f3 8f	jsr $018ff3			jsr 	GotoGetLineNumber 			; get a line number.
.018fdc	fa		plx				plx 								; restore count
.018fdd	ca		dex				dex  								; decrement, exit if zero.
.018fde	f0 06		beq $018fe6			beq 	_CONFound
.018fe0	da		phx				phx 								; push back
.018fe1	20 b0 98	jsr $0198b0			jsr 	CheckNextComma				; check for comma
.018fe4	80 f3		bra $018fd9			bra 	_CONFindNumber
.018fe6					_CONFound:
.018fe6	68		pla				pla 								; get token
.018fe7	c9 cc		cmp #$cc			cmp 	#token_GOTO 				; if GOTO
.018fe9	f0 b6		beq $018fa1			beq		CmdGOTO 					; then just branch.
.018feb	20 80 84	jsr $018480			jsr 	SkipEndOfCommand 			; go to end of command
.018fee	80 b9		bra $018fa9			bra 	CmdGOSUB 					; and do a GOSUB.
.018ff0					_CONFail:
.018ff0	4c 68 85	jmp $018568			jmp 	BadParamError
.018ff3					GotoGetLineNumber:
.018ff3	20 64 92	jsr $019264			jsr 	EvaluateInteger
.018ff6	a5 82		lda $82				lda 	XS_Mantissa+2 				; check range
.018ff8	05 83		ora $83				ora 	XS_Mantissa+3
.018ffa	d0 01		bne $018ffd			bne 	_GLINError
.018ffc	60		rts				rts
.018ffd					_GLINError:
.018ffd	20 79 85	jsr $018579			jsr ERR_Handler
>019000	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>019008	20 4e 75 6d 62 65 72 00
.019010					GotoChangeToLineNumberX:
.019010	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check line number not zero
.019012	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019014	f0 37		beq $01904d			beq 	_GCTLFail
.019016	a9 00		lda #$00			lda 	#BasicProgram & $FF
.019018	85 16		sta $16				sta 	zCodePtr+0
.01901a	a9 10		lda #$10			lda 	#BasicProgram >> 8
.01901c	85 17		sta $17				sta 	zCodePtr+1
.01901e	a9 00		lda #$00			lda 	#0
.019020	85 18		sta $18				sta 	zCodePtr+2
.019022	85 19		sta $19				sta 	zCodePtr+3
.019024	a0 03		ldy #$03			ldy 	#3
.019026					_GCTLLoop:
.019026	a0 00		ldy #$00			ldy 	#0
.019028	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01902a	c9 00		cmp #$00			cmp 	#0
.01902c	f0 1f		beq $01904d			beq 	_GCTLFail
.01902e	c8		iny				iny
.01902f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019031	d5 80		cmp $80,x			cmp 	XS_Mantissa+0,x
.019033	d0 07		bne $01903c			bne 	_GCTLNext
.019035	c8		iny				iny
.019036	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019038	d5 81		cmp $81,x			cmp 	XS_Mantissa+1,x
.01903a	f0 0f		beq $01904b			beq 	_GCTLExit
.01903c					_GCTLNext:
.01903c	a0 00		ldy #$00			ldy 	#0 							; point to offset
.01903e	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.019040	18		clc				clc
.019041	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.019043	85 16		sta $16				sta 	zCodePtr
.019045	90 02		bcc $019049			bcc 	_SNLNoCarry
.019047	e6 17		inc $17				inc 	zCodePtr+1
.019049					_SNLNoCarry:
.019049	80 db		bra $019026			bra 	_GCTLLoop 					; try next line.
.01904b					_GCTLExit:
.01904b	c8		iny				iny
.01904c	60		rts				rts
.01904d					_GCTLFail:
.01904d	20 79 85	jsr $018579			jsr ERR_Handler
>019050	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>019058	20 4e 75 6d 62 65 72 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.019060					Command_CLR:
.019060					ResetRunStatus:
.019060	20 92 99	jsr $019992			jsr 	VariableClear
.019063	20 a0 84	jsr $0184a0			jsr 	StackReset
.019066	a9 00		lda #$00			lda 	#HighMemory & $FF
.019068	8d 00 03	sta $0300			sta 	StringPtr
.01906b	a9 7f		lda #$7f			lda 	#HighMemory >> 8
.01906d	8d 01 03	sta $0301			sta 	StringPtr+1
.019070	20 5c 9b	jsr $019b5c			jsr 	ArrayResetDefault
.019073	20 ed 8a	jsr $018aed			jsr 	Command_RESTORE
.019076	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/stop.asm

.019077					Command_STOP:
.019077	20 79 85	jsr $018579			jsr ERR_Handler
>01907a	53 74 6f 70 00				.text "Stop",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/while.asm

.01907f					Command_WHILE:
.01907f	20 f9 84	jsr $0184f9			jsr 	StackSavePosition			; save position into stack, but don't yet push.
.019082	20 64 92	jsr $019264			jsr 	EvaluateInteger 			; calculate the while loop value.
.019085	a5 80		lda $80				lda 	XS_Mantissa+0				; check the result if zero
.019087	05 81		ora $81				ora 	XS_Mantissa+1
.019089	05 82		ora $82				ora 	XS_Mantissa+2
.01908b	05 83		ora $83				ora 	XS_Mantissa+3
.01908d	f0 06		beq $019095			beq 	_CWHSkip 					; if it is zero, then skip to WEND.
.01908f	a9 35		lda #$35			lda 	#(SMark_While << 4)+SourcePosSize
.019091	20 b2 84	jsr $0184b2			jsr 	StackPushFrame 				; push on stack
.019094	60		rts				rts
.019095					_CWHSkip:
.019095	a9 95		lda #$95			lda 	#token_Wend 				; look for the WEND token.
.019097	20 f3 83	jsr $0183f3			jsr 	StructureSearchSingle
.01909a	c8		iny				iny
.01909b	60		rts				rts
.01909c					Command_WEND:
.01909c	a9 30		lda #$30			lda 	#(SMark_While << 4)			; remove the frame
.01909e	20 c9 84	jsr $0184c9			jsr 	StackPopFrame
.0190a1	20 16 85	jsr $018516			jsr 	StackRestorePosition
.0190a4	80 d9		bra $01907f			bra 	Command_WHILE 				; and do the while again.
.0190a6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/repeat.asm

.0190a7					Command_REPEAT:
.0190a7	20 f9 84	jsr $0184f9			jsr 	StackSavePosition			; save position into stack
.0190aa	a9 25		lda #$25			lda 	#(SMark_Repeat << 4)+SourcePosSize
.0190ac	20 b2 84	jsr $0184b2			jsr 	StackPushFrame 				; push on stack
.0190af	60		rts				rts
.0190b0					Command_UNTIL:
.0190b0	a9 20		lda #$20			lda 	#(SMark_Repeat << 4)		; remove the frame
.0190b2	20 c9 84	jsr $0184c9			jsr 	StackPopFrame
.0190b5	20 64 92	jsr $019264			jsr 	EvaluateInteger				; work out UNTIL
.0190b8	a5 80		lda $80				lda 	XS_Mantissa+0 				; check if zero.
.0190ba	05 81		ora $81				ora 	XS_Mantissa+1
.0190bc	05 82		ora $82				ora 	XS_Mantissa+2
.0190be	05 83		ora $83				ora 	XS_Mantissa+3
.0190c0	d0 08		bne $0190ca			bne 	_CUTExit 					; if not, just exit
.0190c2	20 16 85	jsr $018516			jsr 	StackRestorePosition 		; otherwise loop round again.
.0190c5	a9 25		lda #$25			lda 	#(SMark_Repeat << 4)+SourcePosSize
.0190c7	20 b2 84	jsr $0184b2			jsr 	StackPushFrame 				; fix the stack back.
.0190ca					_CUTExit:
.0190ca	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.0190cb					EVESyntax:
.0190cb	4c 4a 85	jmp $01854a			jmp 	SyntaxError
.0190ce					EvaluateExpression:
.0190ce	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.0190d0					EvaluateExpressionX:
.0190d0	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.0190d2					EvaluateExpressionXA:
.0190d2	48		pha				pha 								; save precedence on stack.
.0190d3	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0190d5	f0 f4		beq $0190cb			beq 	EVESyntax 					; end of line, syntax error.
.0190d7	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.0190d9	b0 03		bcs $0190de			bcs 	_EVNotVariable
.0190db	4c a8 91	jmp $0191a8			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.0190de					_EVNotVariable:
.0190de	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.0190e0	90 e9		bcc $0190cb			bcc 	EVESyntax
.0190e2	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.0190e4	b0 58		bcs $01913e			bcs 	_EVNotInteger
.0190e6	20 d6 91	jsr $0191d6			jsr 	EvaluateGetInteger
.0190e9					_EVCheckDecimal:
.0190e9	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0190eb	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.0190ed	d0 05		bne $0190f4			bne 	_EVGotAtom 					; no, get atom.
.0190ef					_EVIsDecimal:
.0190ef	20 fc 91	jsr $0191fc			jsr 	EVGetDecimal 				; extend to the decimal part.
.0190f2	80 00		bra $0190f4			bra 	_EVGotAtom 					; and continue to got atom.
.0190f4					_EVGotAtom:
.0190f4	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0190f6	10 44		bpl $01913c			bpl 	_EVExitDrop 				; must be a token.
.0190f8	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.0190fa	b0 40		bcs $01913c			bcs 	_EVExitDrop
.0190fc	68		pla				pla 								; get current precedence
.0190fd	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.0190ff	da		phx				phx 								; save X
.019100	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019102	aa		tax				tax 								; put in X
.019103	bf 2e 86 01	lda $01862e,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.019107	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.019109	fa		plx				plx 								; restore X
.01910a	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.01910c	90 2f		bcc $01913d			bcc 	_EVExit 					; exit if too low.
.01910e	f0 2d		beq $01913d			beq 	_EVExit 					; exit if equals
.019110	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.019112	48		pha				pha
.019113	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019115	48		pha				pha
.019116	c8		iny				iny
.019117	da		phx				phx 								; save current position
.019118	e8		inx				inx
.019119	e8		inx				inx
.01911a	e8		inx				inx
.01911b	e8		inx				inx
.01911c	e8		inx				inx
.01911d	e8		inx				inx
.01911e	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.019120	20 d2 90	jsr $0190d2			jsr 	EvaluateExpressionXA 		; do the RHS.
.019123	fa		plx				plx 								; restore X
.019124	68		pla				pla 								; get the binary operator in A.
.019125					_EVCallA:
.019125	da		phx				phx 								; save X again
.019126	0a		asl a				asl 	a 							; double, lose the MSB.
.019127	aa		tax				tax									; put in X
.019128	bf dd 85 01	lda $0185dd,x			lda 	VectorTable,x 				; copy address into zGenPtr
.01912c	8d 11 03	sta $0311			sta 	LocalVector+1
.01912f	bf de 85 01	lda $0185de,x			lda 	VectorTable+1,x
.019133	8d 12 03	sta $0312			sta 	LocalVector+2
.019136	fa		plx				plx 								; restore X
.019137	20 b1 91	jsr $0191b1			jsr 	EVCallLocalVector
.01913a	80 b8		bra $0190f4			bra 	_EVGotAtom 					; and loop back.
.01913c					_EVExitDrop:
.01913c	68		pla				pla
.01913d					_EVExit:
.01913d	60		rts				rts
.01913e					_EVNotInteger:
.01913e	c8		iny				iny
.01913f	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.019141	d0 16		bne $019159			bne 	_EVNotMinus
.019143	20 45 92	jsr $019245			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.019146	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.019148	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.01914a	f0 05		beq $019151			beq 	_EVMinusFloat
.01914c	20 1b 9e	jsr $019e1b			jsr 	IntegerNegateAlways 		; negation
.01914f	80 a3		bra $0190f4			bra 	_EVGotAtom 					; and go back.
.019151					_EVMinusFloat:
.019151	b5 85		lda $85,x			lda 	XS_Type,x 					; invert the sign bit.
.019153	49 80		eor #$80			eor 	#$80
.019155	95 85		sta $85,x			sta 	XS_Type,x
.019157	80 9b		bra $0190f4			bra 	_EVGotAtom
.019159					_EVNotMinus:
.019159	c9 bd		cmp #$bd			cmp 	#token_lparen 				; is it left parenthesis
.01915b	d0 17		bne $019174			bne 	_EVNotParenthesis
.01915d	20 d0 90	jsr $0190d0			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.019160	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019162	c8		iny				iny
.019163	c9 be		cmp #$be			cmp 	#token_rparen 				; okay if right bracket.
.019165	f0 8d		beq $0190f4			beq 	_EVGotAtom
.019167	20 79 85	jsr $018579			jsr ERR_Handler
>01916a	4d 69 73 73 69 6e 67 20			.text "Missing )",0
>019172	29 00
.019174					_EVNotParenthesis:
.019174	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.019176	d0 0c		bne $019184			bne 	_EVNotNot
.019178	20 45 92	jsr $019245			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.01917b	20 b1 a2	jsr $01a2b1			jsr 	FPUToInteger 				; make it an integer - if possible.
.01917e	20 2a 92	jsr $01922a			jsr 	NotInteger 					; do the not calculation
.019181	4c f4 90	jmp $0190f4			jmp 	_EVGotAtom
.019184					_EVNotNot:
.019184	c9 fe		cmp #$fe			cmp 	#$FE
.019186	d0 12		bne $01919a			bne 	_EVNotString
.019188	20 30 99	jsr $019930			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.01918b	a5 20		lda $20				lda 	zTempStr 					; copy address of string into mantissa
.01918d	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01918f	a5 21		lda $21				lda 	zTempStr+1
.019191	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019193	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.019195	95 85		sta $85,x			sta 	XS_Type,x
.019197	4c f4 90	jmp $0190f4			jmp 	_EVGotAtom
.01919a					_EVNotString:
.01919a	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.01919c	90 04		bcc $0191a2			bcc 	_EVBadElement
.01919e	c9 b7		cmp #$b7			cmp 	#lastUnaryFunction+1
.0191a0	90 03		bcc $0191a5			bcc 	_EVUnaryFunction
.0191a2					_EVBadElement:
.0191a2	4c 4a 85	jmp $01854a			jmp 	SyntaxError
.0191a5					_EVUnaryFunction:
.0191a5	4c 25 91	jmp $019125			jmp 	_EVCallA
.0191a8					_EVVariableHandler:
.0191a8	20 56 99	jsr $019956			jsr 	VariableFind 				; locate a variable
.0191ab	20 9e 9c	jsr $019c9e			jsr 	VariableGet 				; copy into memory.
.0191ae	4c f4 90	jmp $0190f4			jmp 	_EVGotAtom 					; and go round.
.0191b1					EVCallLocalVector:
.0191b1	6c 11 03	jmp ($0311)			jmp 	(LocalVector+1)
.0191b4					EVShiftMantissaLeft6:
.0191b4	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.0191b6	95 84		sta $84,x			sta 	XS_Exponent,x
.0191b8	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0191ba	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0191bc	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0191be	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0191c0	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0191c2	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0191c4	a9 00		lda #$00			lda 	#0
.0191c6	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0191c8	20 cb 91	jsr $0191cb			jsr 	_EVSMLShift 					; call it here to do it twice
.0191cb					_EVSMLShift:
.0191cb	56 84		lsr $84,x			lsr 	XS_Exponent,x
.0191cd	76 83		ror $83,x			ror 	XS_Mantissa+3,x
.0191cf	76 82		ror $82,x			ror 	XS_Mantissa+2,x
.0191d1	76 81		ror $81,x			ror 	XS_Mantissa+1,x
.0191d3	76 80		ror $80,x			ror 	XS_Mantissa+0,x
.0191d5	60		rts				rts
.0191d6					EvaluateGetInteger:
.0191d6	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0191d8	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.0191da	95 80		sta $80,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.0191dc	a9 00		lda #$00			lda 	#0
.0191de	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0191e0	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0191e2	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0191e4	1a		inc a				inc 	a 							; set to type 1 (integer)
.0191e5	95 85		sta $85,x			sta 	XS_Type,x
.0191e7					_EVCheckNextInteger:
.0191e7	c8		iny				iny
.0191e8	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0191ea	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.0191ec	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.0191ee	b0 0b		bcs $0191fb			bcs 	_EVEndInteger
.0191f0	48		pha				pha 								; save it.
.0191f1	20 b4 91	jsr $0191b4			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.0191f4	68		pla				pla
.0191f5	15 80		ora $80,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.0191f7	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0191f9	80 ec		bra $0191e7			bra 	_EVCheckNextInteger
.0191fb					_EVEndInteger:
.0191fb	60		rts				rts
.0191fc					EVGetDecimal:
.0191fc	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.0191fe	8d 15 03	sta $0315			sta 	Num_Buffer
.019201	da		phx				phx
.019202	c8		iny				iny
.019203	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019205	c8		iny				iny
.019206	3a		dec a				dec 	a								; convert to a string length.
.019207	3a		dec a				dec 	a
.019208	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.01920a					_EVGDCopy:
.01920a	48		pha				pha 									; save count
.01920b	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01920d	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.019210	e8		inx				inx 									; forward ....
.019211	c8		iny				iny
.019212	68		pla				pla 									; get count
.019213	3a		dec a				dec 	a 								; until zero
.019214	d0 f4		bne $01920a			bne 	_EVGDCopy
.019216	9d 15 03	sta $0315,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.019219	fa		plx				plx 									; restore X
.01921a	a9 15		lda #$15			lda 	#Num_Buffer & $FF 				; set zGenPtr
.01921c	85 1e		sta $1e				sta 	zGenPtr
.01921e	a9 03		lda #$03			lda 	#Num_Buffer >> 8
.019220	85 1f		sta $1f				sta 	zGenPtr+1
.019222	5a		phy				phy 									; save Y
.019223	a0 00		ldy #$00			ldy 	#0 								; start position
.019225	20 6b a4	jsr $01a46b			jsr 	FPFromString 					; convert current
.019228	7a		ply				ply 									; restore Y
.019229	60		rts				rts
.01922a					NotInteger:
.01922a	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01922c	49 ff		eor #$ff			eor 	#$FF
.01922e	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019230	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019232	49 ff		eor #$ff			eor 	#$FF
.019234	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019236	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019238	49 ff		eor #$ff			eor 	#$FF
.01923a	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01923c	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01923e	49 ff		eor #$ff			eor 	#$FF
.019240	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019242	60		rts				rts
.019243					EvaluateGetAtom:
.019243	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.019245					EvaluateGetAtomX:
.019245	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.019247	20 d2 90	jsr $0190d2			jsr 	EvaluateExpressionXA
.01924a	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.01924c	29 0f		and #$0f			and 	#15
.01924e	c9 02		cmp #$02			cmp 	#2
.019250	b0 01		bcs $019253			bcs 	EvaluateType
.019252	60		rts				rts
.019253					EvaluateType:
.019253	4c 5a 85	jmp $01855a			jmp 	TypeError
.019256					EvaluateNumber:
.019256	a2 00		ldx #$00			ldx 	#0
.019258					EvaluateNumberX:
.019258	20 d0 90	jsr $0190d0			jsr 	EvaluateExpressionX
.01925b	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0/1
.01925d	29 0f		and #$0f			and 	#15
.01925f	c9 02		cmp #$02			cmp 	#2
.019261	b0 f0		bcs $019253			bcs 	EvaluateType
.019263	60		rts				rts
.019264					EvaluateInteger:
.019264	a2 00		ldx #$00			ldx 	#0
.019266					EvaluateIntegerX:
.019266	20 58 92	jsr $019258			jsr 	EvaluateNumberX
.019269	20 b1 a2	jsr $01a2b1			jsr 	FPUToInteger
.01926c	60		rts				rts
.01926d					EvaluateString:
.01926d	a2 00		ldx #$00			ldx 	#0
.01926f					EvaluateStringX:
.01926f	20 d0 90	jsr $0190d0			jsr 	EvaluateExpressionX
.019272	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 2
.019274	29 0f		and #$0f			and 	#15
.019276	c9 02		cmp #$02			cmp 	#2
.019278	d0 d9		bne $019253			bne 	EvaluateType
.01927a	b5 80		lda $80,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.01927c	85 1e		sta $1e				sta 	zGenPtr
.01927e	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019280	85 1f		sta $1f				sta 	zGenPtr+1
.019282	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.019283					BinaryOp_And:
.019283	20 d7 92	jsr $0192d7			jsr 	BinaryMakeBothInteger
.019286	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.019288	35 86		and $86,x			and 	XS2_Mantissa+0,x
.01928a	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01928c	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.01928e	35 87		and $87,x			and 	XS2_Mantissa+1,x
.019290	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019292	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.019294	35 88		and $88,x			and 	XS2_Mantissa+2,x
.019296	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019298	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.01929a	35 89		and $89,x			and 	XS2_Mantissa+3,x
.01929c	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01929e	60		rts				rts
.01929f					BinaryOp_Or:
.01929f	20 d7 92	jsr $0192d7			jsr 	BinaryMakeBothInteger
.0192a2	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.0192a4	15 86		ora $86,x			ora 	XS2_Mantissa+0,x
.0192a6	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0192a8	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.0192aa	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.0192ac	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0192ae	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.0192b0	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.0192b2	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0192b4	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.0192b6	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.0192b8	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0192ba	60		rts				rts
.0192bb					BinaryOp_Eor:
.0192bb					BinaryOp_Xor:
.0192bb	20 d7 92	jsr $0192d7			jsr 	BinaryMakeBothInteger
.0192be	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.0192c0	55 86		eor $86,x			eor 	XS2_Mantissa+0,x
.0192c2	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0192c4	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.0192c6	55 87		eor $87,x			eor 	XS2_Mantissa+1,x
.0192c8	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0192ca	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.0192cc	55 88		eor $88,x			eor 	XS2_Mantissa+2,x
.0192ce	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0192d0	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.0192d2	55 89		eor $89,x			eor 	XS2_Mantissa+3,x
.0192d4	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0192d6	60		rts				rts
.0192d7					BinaryMakeBothInteger:
.0192d7	da		phx				phx 								; save X
.0192d8	e8		inx				inx
.0192d9	e8		inx				inx
.0192da	e8		inx				inx
.0192db	e8		inx				inx
.0192dc	e8		inx				inx
.0192dd	e8		inx				inx
.0192de	20 e2 92	jsr $0192e2			jsr 	BinaryMakeInteger 			; convert to integer.
.0192e1	fa		plx				plx 								; restore X and fall through.
.0192e2					BinaryMakeInteger:
.0192e2	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.0192e4	29 0f		and #$0f			and 	#15 						; check type zero
.0192e6	f0 04		beq $0192ec			beq 	_BMIConvert 				; if float convert to integer.
.0192e8	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.0192e9	90 04		bcc $0192ef			bcc 	_BMIError
.0192eb	60		rts				rts
.0192ec					_BMIConvert:
.0192ec	4c b1 a2	jmp $01a2b1			jmp 	FPUToInteger 				; convert to integer
.0192ef					_BMIError:
.0192ef	4c 5a 85	jmp $01855a			jmp 	TypeError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.0192f2					Binary_Equal:
.0192f2	20 39 93	jsr $019339			jsr 	CompareValues
.0192f5	09 00		ora #$00			ora 	#0
.0192f7	f0 04		beq $0192fd			beq 	CCTrue
.0192f9	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.0192fb	80 02		bra $0192ff			bra 	CCWrite
.0192fd	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.0192ff	95 80		sta $80,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.019301	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019303	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019305	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019307	a9 01		lda #$01			lda 	#1
.019309	95 85		sta $85,x			sta 	XS_Type,x 					; set type to integer whatever.
.01930b	60		rts				rts
.01930c					Binary_NotEqual:
.01930c	20 39 93	jsr $019339			jsr 	CompareValues
.01930f	09 00		ora #$00			ora 	#0
.019311	f0 e6		beq $0192f9			beq 	CCFalse
.019313	80 e8		bra $0192fd			bra 	CCTrue
.019315					Binary_Less:
.019315	20 39 93	jsr $019339			jsr 	CompareValues
.019318	09 00		ora #$00			ora 	#0
.01931a	30 e1		bmi $0192fd			bmi 	CCTrue
.01931c	80 db		bra $0192f9			bra 	CCFalse
.01931e					Binary_LessEqual:
.01931e	20 39 93	jsr $019339			jsr 	CompareValues
.019321	c9 01		cmp #$01			cmp 	#1
.019323	d0 d8		bne $0192fd			bne 	CCTrue
.019325	80 d2		bra $0192f9			bra 	CCFalse
.019327					Binary_GreaterEqual:
.019327	20 39 93	jsr $019339			jsr 	CompareValues
.01932a	09 00		ora #$00			ora 	#0
.01932c	10 cf		bpl $0192fd			bpl 	CCTrue
.01932e	80 c9		bra $0192f9			bra 	CCFalse
.019330					Binary_Greater:
.019330	20 39 93	jsr $019339			jsr 	CompareValues
.019333	c9 01		cmp #$01			cmp 	#1
.019335	f0 c6		beq $0192fd			beq 	CCTrue
.019337	80 c0		bra $0192f9			bra 	CCFalse
.019339					CompareValues:
.019339	b5 85		lda $85,x			lda 	XS_Type,x 					; and the types together
.01933b	35 8b		and $8b,x			and 	XS2_Type,x
.01933d	c9 02		cmp #$02			cmp 	#2
.01933f	f0 11		beq $019352			beq 	_CVString
.019341	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.019343	35 8b		and $8b,x			and 	XS2_Type,x
.019345	4a		lsr a				lsr 	a 							; shift bit 0 into C
.019346	90 03		bcc $01934b			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.019348	4c 94 93	jmp $019394			jmp 	CompareInteger32 							; so execute code at \1
.01934b					_BCFloat:
.01934b	20 38 94	jsr $019438			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.01934e	4c aa a1	jmp $01a1aa			jmp 	FPCompare 							; and execute code at \2
.019351	60		rts				rts
.019352					_CVString:
.019352	da		phx				phx 								; save XY
.019353	5a		phy				phy
.019354	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.019356	85 1a		sta $1a				sta		zLTemp1+0
.019358	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01935a	85 1b		sta $1b				sta 	zLTemp1+1
.01935c	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.01935e	85 1c		sta $1c				sta 	zLTemp1+2
.019360	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.019362	85 1d		sta $1d				sta 	zLTemp1+3
.019364	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.019366	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.019368	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.01936a	90 02		bcc $01936e			bcc 	_CVCommon
.01936c	b1 1c		lda ($1c),y			lda 	(zLTemp1+2),y
.01936e					_CVCommon:
.01936e	aa		tax				tax 								; put shorter string length in zero.
.01936f	f0 0c		beq $01937d			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.019371					_CVCompare:
.019371	c8		iny				iny 								; next character
.019372	b1 1a		lda ($1a),y			lda 	(zLTemp1),y 				; compare characters
.019374	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.019376	90 13		bcc $01938b			bcc 	_CVReturnLess 				; <
.019378	d0 15		bne $01938f			bne 	_CVReturnGreater 			; >
.01937a	ca		dex				dex 								; until common length matched.
.01937b	d0 f4		bne $019371			bne 	_CVCompare
.01937d					_CVMatch:
.01937d	a0 00		ldy #$00			ldy 	#0
.01937f	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.019381	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.019383	90 06		bcc $01938b			bcc 	_CVReturnLess 				; <
.019385	d0 08		bne $01938f			bne 	_CVReturnGreater 			; >
.019387	a9 00		lda #$00			lda 	#0
.019389	80 06		bra $019391			bra 	_CVExit 					; same common, same length, same string
.01938b					_CVReturnLess:
.01938b	a9 ff		lda #$ff			lda 	#$FF
.01938d	80 02		bra $019391			bra 	_CVExit
.01938f					_CVReturnGreater:
.01938f	a9 01		lda #$01			lda 	#$01
.019391					_CVExit:
.019391	7a		ply				ply
.019392	fa		plx				plx
.019393	60		rts				rts
.019394					CompareInteger32:
.019394	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.019396	49 80		eor #$80			eor 	#$80
.019398	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01939a	b5 89		lda $89,x			lda 	XS2_Mantissa+3,x
.01939c	49 80		eor #$80			eor 	#$80
.01939e	95 89		sta $89,x			sta 	XS2_Mantissa+3,x
.0193a0	20 1e 94	jsr $01941e			jsr 	SubInteger32 				; subtraction
.0193a3	90 0d		bcc $0193b2			bcc 	_CI32Less 					; cc return -1
.0193a5	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check if zero
.0193a7	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.0193a9	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.0193ab	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.0193ad	f0 02		beq $0193b1			beq 	_CI32Exit
.0193af	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.0193b1					_CI32Exit:
.0193b1	60		rts				rts
.0193b2					_CI32Less:
.0193b2	a9 ff		lda #$ff			lda 	#$FF
.0193b4	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.0193b5					BinaryOp_Add:
.0193b5	b5 85		lda $85,x			lda 	XS_Type,x  					; and types together
.0193b7	35 8b		and $8b,x			and 	XS2_Type,x
.0193b9	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.0193bb	d0 11		bne $0193ce			bne 	_BOAString
.0193bd	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.0193bf	35 8b		and $8b,x			and 	XS2_Type,x
.0193c1	4a		lsr a				lsr 	a 							; shift bit 0 into C
.0193c2	90 03		bcc $0193c7			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.0193c4	4c 04 94	jmp $019404			jmp 	AddInteger32 							; so execute code at \1
.0193c7					_BCFloat:
.0193c7	20 38 94	jsr $019438			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.0193ca	4c 85 9f	jmp $019f85			jmp 	FPAdd 							; and execute code at \2
.0193cd	60		rts				rts
.0193ce					_BOAString:
.0193ce	4c 52 94	jmp $019452			jmp 	ConcatenateString 			; concatenate two strings.
.0193d1					BinaryOp_Subtract:
.0193d1	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.0193d3	35 8b		and $8b,x			and 	XS2_Type,x
.0193d5	4a		lsr a				lsr 	a 							; shift bit 0 into C
.0193d6	90 03		bcc $0193db			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.0193d8	4c 1e 94	jmp $01941e			jmp 	SubInteger32 							; so execute code at \1
.0193db					_BCFloat:
.0193db	20 38 94	jsr $019438			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.0193de	4c 7d 9f	jmp $019f7d			jmp 	FPSubtract 							; and execute code at \2
.0193e1	60		rts				rts
.0193e2					BinaryOp_Multiply:
.0193e2	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.0193e4	35 8b		and $8b,x			and 	XS2_Type,x
.0193e6	4a		lsr a				lsr 	a 							; shift bit 0 into C
.0193e7	90 03		bcc $0193ec			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.0193e9	4c 56 9d	jmp $019d56			jmp 	MulInteger32 							; so execute code at \1
.0193ec					_BCFloat:
.0193ec	20 38 94	jsr $019438			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.0193ef	4c ac a0	jmp $01a0ac			jmp 	FPMultiply 							; and execute code at \2
.0193f2	60		rts				rts
.0193f3					BinaryOp_Divide:
.0193f3	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.0193f5	35 8b		and $8b,x			and 	XS2_Type,x
.0193f7	4a		lsr a				lsr 	a 							; shift bit 0 into C
.0193f8	90 03		bcc $0193fd			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.0193fa	4c 94 9d	jmp $019d94			jmp 	DivInteger32 							; so execute code at \1
.0193fd					_BCFloat:
.0193fd	20 38 94	jsr $019438			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.019400	4c 39 a0	jmp $01a039			jmp 	FPDivide 							; and execute code at \2
.019403	60		rts				rts
.019404					AddInteger32:
.019404	18		clc				clc
.019405	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019407	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.019409	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01940b	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01940d	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.01940f	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019411	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019413	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.019415	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019417	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019419	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.01941b	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01941d	60		rts				rts
.01941e					SubInteger32:
.01941e	38		sec				sec
.01941f	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019421	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.019423	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019425	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019427	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.019429	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01942b	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01942d	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.01942f	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019431	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019433	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.019435	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019437	60		rts				rts
.019438					BinaryMakeBothFloat:
.019438	da		phx				phx 								; save X
.019439	e8		inx				inx
.01943a	e8		inx				inx
.01943b	e8		inx				inx
.01943c	e8		inx				inx
.01943d	e8		inx				inx
.01943e	e8		inx				inx
.01943f	20 43 94	jsr $019443			jsr 	BinaryMakeFloat 			; convert to float.
.019442	fa		plx				plx 								; restore X and fall through.
.019443					BinaryMakeFloat:
.019443	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.019445	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.019446	b0 04		bcs $01944c			bcs 	_BMFConvert
.019448	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.019449	b0 04		bcs $01944f			bcs 	_BMFError
.01944b	60		rts				rts
.01944c					_BMFConvert:
.01944c	4c 65 a2	jmp $01a265			jmp 	FPUToFloat 					; convert to float
.01944f					_BMFError:
.01944f	4c 5a 85	jmp $01855a			jmp 	TypeError
.019452					ConcatenateString:
.019452	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.019454	85 1a		sta $1a				sta		zLTemp1+0
.019456	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019458	85 1b		sta $1b				sta 	zLTemp1+1
.01945a	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.01945c	85 1c		sta $1c				sta 	zLTemp1+2
.01945e	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.019460	85 1d		sta $1d				sta 	zLTemp1+3
.019462	5a		phy				phy
.019463	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.019465	b1 1a		lda ($1a),y			lda 	(zlTemp1),y
.019467	71 1c		adc ($1c),y			adc 	(zlTemp1+2),y
.019469	7a		ply				ply
.01946a	b0 33		bcs $01949f			bcs 	_CSError					; check in range.
.01946c	c9 fe		cmp #$fe			cmp 	#maxString+1
.01946e	b0 2f		bcs $01949f			bcs 	_CSError
.019470	20 f5 98	jsr $0198f5			jsr 	AllocateTempString 			; store the result
.019473	20 8a 94	jsr $01948a			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.019476	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.019478	85 1a		sta $1a				sta 	zLTemp1
.01947a	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.01947c	85 1b		sta $1b				sta 	zLTemp1+1
.01947e	20 8a 94	jsr $01948a			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.019481	a5 20		lda $20				lda 	zTempStr 					; point current to new string
.019483	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019485	a5 21		lda $21				lda 	zTempStr+1
.019487	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019489	60		rts				rts
.01948a					_CSCopyString:
.01948a	da		phx				phx
.01948b	5a		phy				phy
.01948c	a0 00		ldy #$00			ldy 	#0 							; get length
.01948e	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.019490	f0 0a		beq $01949c			beq 	_CSCSExit 					; if zero, exit
.019492	aa		tax				tax 								; put in X
.019493					_CSCSLoop:
.019493	c8		iny				iny 								; get next char
.019494	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.019496	20 20 99	jsr $019920			jsr		WriteTempString 			; copy out
.019499	ca		dex				dex 								; do whole string
.01949a	d0 f7		bne $019493			bne 	_CSCSLoop
.01949c					_CSCSExit:
.01949c	7a		ply				ply
.01949d	fa		plx				plx
.01949e	60		rts				rts
.01949f					_CSError:
.01949f	20 79 85	jsr $018579			jsr ERR_Handler
>0194a2	53 74 72 69 6e 67 20 74			.text "String too long",0
>0194aa	6f 6f 20 6c 6f 6e 67 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.0194b2					Unary_Sgn:
.0194b2	20 58 92	jsr $019258			jsr 	EvaluateNumberX 			; get value
.0194b5	20 a8 98	jsr $0198a8			jsr 	CheckNextRParen 			; check right bracket.
.0194b8	20 d6 94	jsr $0194d6			jsr 	GetSignCurrent 				; get sign.
.0194bb	09 00		ora #$00			ora 	#0
.0194bd	10 08		bpl $0194c7			bpl		UnarySetAInteger			; if 0,1 return that.
.0194bf	80 00		bra $0194c1			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.0194c1					UnarySetAMinus1:
.0194c1	a9 ff		lda #$ff			lda 	#$FF
.0194c3	95 80		sta $80,x			sta 	XS_Mantissa,x
.0194c5	80 04		bra $0194cb			bra 	UnarySetAFill
.0194c7					UnarySetAInteger:
.0194c7	95 80		sta $80,x			sta 	XS_Mantissa,x
.0194c9	a9 00		lda #$00			lda 	#0
.0194cb					UnarySetAFill:
.0194cb	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0194cd	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0194cf	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0194d1	a9 01		lda #$01			lda 	#1
.0194d3	95 85		sta $85,x			sta 	XS_Type,x
.0194d5	60		rts				rts
.0194d6					GetSignCurrent:
.0194d6	b5 85		lda $85,x			lda 	XS_Type,x 					; identify type.
.0194d8	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.0194d9	90 15		bcc $0194f0			bcc 	_GSCFloat
.0194db	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.0194dd	30 0e		bmi $0194ed			bmi 	_GSCMinus1
.0194df	15 80		ora $80,x			ora 	XS_Mantissa+0,x
.0194e1	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.0194e3	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.0194e5	d0 03		bne $0194ea			bne 	_GSCPlus1
.0194e7					_GSCZero:
.0194e7	a9 00		lda #$00			lda 	#0
.0194e9	60		rts				rts
.0194ea					_GSCPlus1:
.0194ea	a9 01		lda #$01			lda 	#$01
.0194ec	60		rts				rts
.0194ed					_GSCMinus1:
.0194ed	a9 ff		lda #$ff			lda 	#$FF
.0194ef	60		rts				rts
.0194f0					_GSCFloat:
.0194f0	34 85		bit $85,x			bit 	XS_Type,x
.0194f2	70 f3		bvs $0194e7			bvs 	_GSCZero
.0194f4	30 f7		bmi $0194ed			bmi 	_GSCMinus1
.0194f6	80 f2		bra $0194ea			bra 	_GSCPlus1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.0194f8					Unary_Abs:
.0194f8	20 58 92	jsr $019258			jsr 	EvaluateNumberX 			; get value
.0194fb	20 a8 98	jsr $0198a8			jsr 	CheckNextRParen 			; check right bracket.
.0194fe	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.019500	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.019502	f0 07		beq $01950b			beq 	_UAMinusFloat
.019504	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; check MSB
.019506	10 09		bpl $019511			bpl 	_UAExit
.019508	4c 1b 9e	jmp $019e1b			jmp 	IntegerNegateAlways 		; negation
.01950b					_UAMinusFloat:
.01950b	b5 85		lda $85,x			lda 	XS_Type,x 					; clear the sign bit.
.01950d	29 7f		and #$7f			and		#$7F
.01950f	95 85		sta $85,x			sta 	XS_Type,x
.019511					_UAExit:
.019511	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.019512					Unary_Peek:
.019512	a9 01		lda #$01			lda 	#1
.019514	80 06		bra $01951c			bra 	UPMain
.019516					Unary_Deek:
.019516	a9 02		lda #$02			lda 	#2
.019518	80 02		bra $01951c			bra 	UPMain
.01951a					Unary_Leek:
.01951a	a9 04		lda #$04			lda 	#4
.01951c					UPMain:
.01951c	48		pha				pha 								; set bytes to copy.
.01951d	20 66 92	jsr $019266			jsr 	EvaluateIntegerX 			; numeric parameter
.019520	20 a8 98	jsr $0198a8			jsr 	CheckNextRParen 			; right bracket.
.019523	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.019525	85 1a		sta $1a				sta 	zLTemp1
.019527	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019529	85 1b		sta $1b				sta 	zLTemp1+1
.01952b	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01952d	85 1c		sta $1c				sta 	zLTemp1+2
.01952f	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019531	85 1d		sta $1d				sta 	zLTemp1+3
.019533	a9 00		lda #$00			lda 	#0 							; clear target area
.019535	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019537	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019539	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01953b	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01953d	68		pla				pla 								; restore bytes to copy
.01953e	da		phx				phx 								; save XY
.01953f	5a		phy				phy
.019540	20 2a 98	jsr $01982a			jsr 	MemRead 					; read the bytes in
.019543	7a		ply				ply 								; restore and exit
.019544	fa		plx				plx
.019545	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/pos.asm

.019546					Unary_Pos:
.019546	20 58 92	jsr $019258			jsr 	EvaluateNumberX 			; get value
.019549	20 a8 98	jsr $0198a8			jsr 	CheckNextRParen 			; check right bracket.
.01954c	20 43 85	jsr $018543			jsr 	VIOCharGetPosition 			; get the position
.01954f	4c c7 94	jmp $0194c7			jmp		UnarySetAInteger			; if 0,1 return that.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.019552					Unary_Mod:
.019552	20 7a 95	jsr $01957a			jsr 	_UMParameter 				; first parameter
.019555	20 b0 98	jsr $0198b0			jsr 	CheckNextComma
.019558	da		phx				phx 								; second parameter
.019559	e8		inx				inx
.01955a	e8		inx				inx
.01955b	e8		inx				inx
.01955c	e8		inx				inx
.01955d	e8		inx				inx
.01955e	e8		inx				inx
.01955f	20 7a 95	jsr $01957a			jsr 	_UMParameter
.019562	fa		plx				plx
.019563	20 a8 98	jsr $0198a8			jsr 	CheckNextRParen
.019566	20 94 9d	jsr $019d94			jsr 	DivInteger32 				; divide
.019569	a5 1a		lda $1a				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.01956b	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01956d	a5 1b		lda $1b				lda 	zLTemp1+1
.01956f	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019571	a5 1c		lda $1c				lda 	zLTemp1+2
.019573	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019575	a5 1d		lda $1d				lda 	zLTemp1+3
.019577	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019579	60		rts				rts
.01957a					_UMParameter:
.01957a	20 66 92	jsr $019266			jsr 	EvaluateIntegerX 			; get value
.01957d	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; absolute value
.01957f	10 03		bpl $019584			bpl 	_UMNotSigned
.019581	20 1b 9e	jsr $019e1b			jsr 	IntegerNegateAlways
.019584					_UMNotSigned:
.019584	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.019585					Unary_Usr:
.019585	20 58 92	jsr $019258			jsr 	EvaluateNumberX 			; numeric parameter
.019588	20 a8 98	jsr $0198a8			jsr 	CheckNextRParen 			; right bracket.
.01958b	da		phx				phx 								; save XY
.01958c	5a		phy				phy
.01958d	ea		nop				nop
.01958e	22 0c 03 00	jsl $00030c			jsl 	UserVector
.019592	7a		ply				ply 								; and exit
.019593	fa		plx				plx
.019594	60		rts				rts
.019595					USRDefault:
.019595	20 79 85	jsr $018579			jsr ERR_Handler
>019598	4e 6f 20 55 53 52 20 76			.text "No USR vector.",0
>0195a0	65 63 74 6f 72 2e 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.0195a7					Unary_Val:
.0195a7	20 6f 92	jsr $01926f			jsr 	EvaluateStringX 			; get string
.0195aa	20 a8 98	jsr $0198a8			jsr 	CheckNextRParen 			; check right bracket.
.0195ad	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.0195af	85 1e		sta $1e				sta 	zGenPtr
.0195b1	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0195b3	85 1f		sta $1f				sta 	zGenPtr+1
.0195b5	5a		phy				phy
.0195b6	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.0195b8	b1 1e		lda ($1e),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.0195ba	f0 54		beq $019610			beq 	_UVBadNumber
.0195bc	48		pha				pha 								; save length.
.0195bd	1a		inc a				inc 	a 							; one for the length, one for the terminator
.0195be	1a		inc a				inc 	a
.0195bf	20 f5 98	jsr $0198f5			jsr 	AllocateTempString
.0195c2	c8		iny				iny 								; move to the next.
.0195c3	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get character
.0195c5	49 2d		eor #$2d			eor 	#"-"						; zero if minus sign
.0195c7	8d a0 03	sta $03a0			sta 	ValSign
.0195ca	d0 04		bne $0195d0			bne 	_UVNotMinus
.0195cc	c8		iny				iny 								; skip over it.
.0195cd	68		pla				pla 								; decrement character count.
.0195ce	3a		dec a				dec 	a
.0195cf	48		pha				pha
.0195d0					_UVNotMinus:
.0195d0	68		pla				pla 								; this is the count.
.0195d1	48		pha		_UVCopy:pha									; copy into new temp string which is ASCIIZ
.0195d2	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.0195d4	c8		iny				iny
.0195d5	20 20 99	jsr $019920			jsr 	WriteTempString
.0195d8	68		pla				pla
.0195d9	3a		dec a				dec 	a
.0195da	d0 f5		bne $0195d1			bne 	_UVCopy
.0195dc	20 20 99	jsr $019920			jsr 	WriteTempString 			; make it ASCIIZ
.0195df	18		clc				clc
.0195e0	a5 20		lda $20				lda 	zTempStr 					; tempstring +1 => genptr
.0195e2	69 01		adc #$01			adc 	#1
.0195e4	85 1e		sta $1e				sta 	zGenPtr
.0195e6	a5 21		lda $21				lda 	zTempStr+1
.0195e8	69 00		adc #$00			adc 	#0
.0195ea	85 1f		sta $1f				sta 	zGenPtr+1
.0195ec	18		clc				clc
.0195ed	20 ed 9e	jsr $019eed			jsr 	IntFromString 				; first bit.
.0195f0	b0 1e		bcs $019610			bcs 	_UVBadNumber
.0195f2	20 6b a4	jsr $01a46b			jsr 	FPFromString				; try for a float part.
.0195f5	ad a0 03	lda $03a0			lda 	ValSign 					; was it negative
.0195f8	d0 10		bne $01960a			bne 	_UVNotNegative
.0195fa	b5 85		lda $85,x			lda 	XS_Type,x 					; check if integer
.0195fc	4a		lsr a				lsr 	a
.0195fd	b0 08		bcs $019607			bcs 	_UVInteger
.0195ff	b5 85		lda $85,x			lda 	XS_Type,x 					; set sign bit
.019601	09 80		ora #$80			ora 	#$80
.019603	95 85		sta $85,x			sta 	XS_Type,x
.019605	80 03		bra $01960a			bra 	_UVNotNegative
.019607					_UVInteger:
.019607	20 1b 9e	jsr $019e1b			jsr 	IntegerNegateAlways 		; sign it.
.01960a					_UVNotNegative:
.01960a	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; used everything
.01960c	d0 02		bne $019610			bne 	_UVBadNumber
.01960e	7a		ply				ply
.01960f	60		rts				rts
.019610					_UVBadNumber:
.019610	4c 68 85	jmp $018568			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.019613					Unary_Str:
.019613	20 58 92	jsr $019258			jsr 	EvaluateNumberX 			; numeric parameter
.019616	20 a8 98	jsr $0198a8			jsr 	CheckNextRParen 			; right bracket.
.019619	a9 00		lda #$00			lda 	#0 							; reset buffer index
.01961b	8d 14 03	sta $0314			sta 	NumBufX
.01961e	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.019620	4a		lsr a				lsr 	a
.019621	b0 05		bcs $019628			bcs 	_USInt 						; if msb set do as integer
.019623	20 b0 a3	jsr $01a3b0			jsr 	FPToString 					; call fp to str otherwise
.019626	80 03		bra $01962b			bra 	_USDuplicate
.019628	20 38 9e	jsr $019e38	_USInt:	jsr 	IntToString
.01962b					_USDuplicate:
.01962b	ad 14 03	lda $0314			lda 	NumBufX 					; chars in buffer
.01962e	1a		inc a				inc 	a 							; one more for length
.01962f	20 f5 98	jsr $0198f5			jsr 	AllocateTempString 			; allocate space for it.
.019632	5a		phy				phy 								; save Y
.019633	a0 00		ldy #$00			ldy 	#0 							; start copying
.019635	b9 15 03	lda $0315,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.019638	20 20 99	jsr $019920			jsr 	WriteTempString
.01963b	c8		iny				iny
.01963c	cc 14 03	cpy $0314			cpy 	NumBufX 					; done the lot
.01963f	d0 f4		bne $019635			bne 	_USCopy
.019641	7a		ply				ply 								; restore Y
.019642	4c 1d 98	jmp $01981d			jmp 	UnaryReturnTempStr 			; return new temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.019645					Unary_Asc:
.019645	20 6f 92	jsr $01926f			jsr 	EvaluateStringX 			; string parameter
.019648	20 a8 98	jsr $0198a8			jsr 	CheckNextRParen 			; right bracket.
.01964b	5a		phy				phy 								; get the string length
.01964c	a0 00		ldy #$00			ldy 	#0
.01964e	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.019650	f0 07		beq $019659			beq 	_UAIllegal 					; must be at least one character
.019652	c8		iny				iny
.019653	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; read it.
.019655	7a		ply				ply
.019656	4c c7 94	jmp $0194c7			jmp 	UnarySetAInteger
.019659					_UAIllegal:
.019659	4c 68 85	jmp $018568			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.01965c					Unary_Len:
.01965c	20 6f 92	jsr $01926f			jsr 	EvaluateStringX 			; string parameter
.01965f	20 a8 98	jsr $0198a8			jsr 	CheckNextRParen 			; right bracket.
.019662	5a		phy				phy 								; get the string length
.019663	a0 00		ldy #$00			ldy 	#0
.019665	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.019667	7a		ply				ply
.019668	4c c7 94	jmp $0194c7			jmp 	UnarySetAInteger

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.01966b					Unary_Mid:
.01966b	20 6f 92	jsr $01926f			jsr 	EvaluateStringX 				; get string.
.01966e	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.019670	48		pha				pha
.019671	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019673	48		pha				pha
.019674	20 b0 98	jsr $0198b0			jsr 	CheckNextComma 					; skip comma
.019677	20 00 97	jsr $019700			jsr 	SLIByteParameter 				; get a byte parameter (start)
.01967a	48		pha				pha 									; and push it.
.01967b	20 b0 98	jsr $0198b0			jsr 	CheckNextComma 					; skip comma
.01967e	20 00 97	jsr $019700			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.019681	48		pha				pha 									; and push it.
.019682	80 41		bra $0196c5			bra 	SLIProcess
.019684					Unary_Left:
.019684	20 6f 92	jsr $01926f			jsr 	EvaluateStringX 				; get string.
.019687	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.019689	48		pha				pha
.01968a	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01968c	48		pha				pha
.01968d	a9 01		lda #$01			lda 	#1 								; push start position (1)
.01968f	48		pha				pha
.019690	20 b0 98	jsr $0198b0			jsr 	CheckNextComma 					; skip comma
.019693	20 00 97	jsr $019700			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.019696	48		pha				pha 									; and push it.
.019697	80 2c		bra $0196c5			bra 	SLIProcess
.019699					Unary_Right:
.019699	20 6f 92	jsr $01926f			jsr 	EvaluateStringX 				; get string.
.01969c	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.01969e	48		pha				pha
.01969f	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0196a1	48		pha				pha
.0196a2	da		phx				phx 									; get the string length and push on stack.
.0196a3	a2 00		ldx #$00			ldx 	#0
.0196a5	a1 1e		lda ($1e,x)			lda		(zGenPtr,x)
.0196a7	fa		plx				plx
.0196a8	48		pha				pha
.0196a9	20 b0 98	jsr $0198b0			jsr 	CheckNextComma 					; skip comma
.0196ac	20 00 97	jsr $019700			jsr 	SLIByteParameter 				; get a byte parameter.
.0196af	8d 9e 03	sta $039e			sta 	SignCount 						; save in temporary.
.0196b2	68		pla				pla 									; restore string length.
.0196b3	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.0196b4	38		sec				sec
.0196b5	ed 9e 03	sbc $039e			sbc 	SignCount 						; subtract characters needed, gives start position.
.0196b8	f0 02		beq $0196bc			beq 	_URStart 						; if <= 0 start from 1.
.0196ba	10 02		bpl $0196be			bpl 	_UROkay
.0196bc					_URStart:
.0196bc	a9 01		lda #$01			lda 	#1
.0196be					_UROkay:
.0196be	48		pha				pha 									; push start
.0196bf	ad 9e 03	lda $039e			lda 	SignCount 						; push count of characters
.0196c2	48		pha				pha
.0196c3	80 00		bra $0196c5			bra 	SLIProcess
.0196c5					SLIProcess:
.0196c5	20 a8 98	jsr $0198a8			jsr 	CheckNextRParen 				; closing right bracket.
.0196c8	68		pla				pla
.0196c9	8d a2 03	sta $03a2			sta 	SliceCount 						; count in signcount
.0196cc	1a		inc a				inc 	a 								; allocate +1 for it.
.0196cd	20 f5 98	jsr $0198f5			jsr 	AllocateTempString
.0196d0	68		pla				pla 									; pop start number off stack.
.0196d1	f0 3b		beq $01970e			beq 	SLIError 						; exit if start = 0
.0196d3	8d a1 03	sta $03a1			sta 	SliceStart
.0196d6	68		pla				pla  									; pop string address.
.0196d7	85 1f		sta $1f				sta 	zGenPtr+1
.0196d9	68		pla				pla
.0196da	85 1e		sta $1e				sta 	zGenPtr
.0196dc	da		phx				phx
.0196dd	5a		phy				phy
.0196de	a2 00		ldx #$00			ldx 	#0 								; point to string length.
.0196e0	ac a1 03	ldy $03a1			ldy 	SliceStart 						; start of the string (+1 for count)
.0196e3					_SLICopy:
.0196e3	ad a2 03	lda $03a2			lda 	SliceCount 						; done count characters
.0196e6	f0 12		beq $0196fa			beq 	_SLIExit
.0196e8	ce a2 03	dec $03a2			dec 	SliceCount
.0196eb	98		tya				tya 									; index of character
.0196ec	c1 1e		cmp ($1e,x)			cmp 	(zGenPtr,x)						; compare against length
.0196ee	f0 02		beq $0196f2			beq 	_SLIOk 							; if equal, okay.
.0196f0	b0 08		bcs $0196fa			bcs 	_SLIExit 						; if past end, then exit.
.0196f2	b1 1e		lda ($1e),y	_SLIOk:	lda 	(zGenPtr),y 					; copy one character
.0196f4	c8		iny				iny
.0196f5	20 20 99	jsr $019920			jsr 	WriteTempString
.0196f8	80 e9		bra $0196e3			bra 	_SLICopy 						; go round till copied characters
.0196fa					_SLIExit:
.0196fa	7a		ply				ply 									; restore YX
.0196fb	fa		plx				plx
.0196fc	4c 1d 98	jmp $01981d			jmp 	UnaryReturnTempStr 				; return new temporary string.
.0196ff	ea		nop				nop
.019700					SLIByteParameter:
.019700	20 66 92	jsr $019266			jsr 	EvaluateIntegerX 				; get integer
.019703	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.019705	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019707	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019709	d0 03		bne $01970e			bne 	SLIError
.01970b	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01970d	60		rts				rts
.01970e					SLIError:
.01970e	4c 68 85	jmp $018568			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.019711					Unary_Hex:
.019711	20 66 92	jsr $019266			jsr 	EvaluateIntegerX 			; numeric parameter
.019714	20 a8 98	jsr $0198a8			jsr 	CheckNextRParen 			; right bracket.
.019717	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.019719	20 f5 98	jsr $0198f5			jsr 	AllocateTempString			; allocate string space
.01971c	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.01971e	20 42 97	jsr $019742			jsr 	_UHConvert
.019721	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019723	20 42 97	jsr $019742			jsr 	_UHConvert
.019726	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019728	20 42 97	jsr $019742			jsr 	_UHConvert
.01972b	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01972d	20 42 97	jsr $019742			jsr 	_UHConvert
.019730	5a		phy				phy 								; get length of new string
.019731	a0 00		ldy #$00			ldy 	#0
.019733	b1 20		lda ($20),y			lda 	(zTempStr),y
.019735	7a		ply				ply
.019736	c9 00		cmp #$00			cmp 	#0
.019738	d0 05		bne $01973f			bne 	_UHExit 					; if it was non zero okay
.01973a	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.01973c	20 20 99	jsr $019920			jsr 	WriteTempString
.01973f					_UHExit:
.01973f	4c 1d 98	jmp $01981d			jmp 	UnaryReturnTempStr 			; return new temporary string.
.019742					_UHConvert:
.019742	48		pha				pha
.019743	4a		lsr a				lsr 	a 							; do MSB
.019744	4a		lsr a				lsr 	a
.019745	4a		lsr a				lsr 	a
.019746	4a		lsr a				lsr 	a
.019747	20 4b 97	jsr $01974b			jsr 	_UHNibble
.01974a	68		pla				pla 								; do LSB
.01974b					_UHNibble:
.01974b	29 0f		and #$0f			and 	#15 						; get nibble
.01974d	d0 0c		bne $01975b			bne 	_UHNonZero
.01974f	5a		phy				phy									; get the length
.019750	a0 00		ldy #$00			ldy 	#0
.019752	b1 20		lda ($20),y			lda 	(zTempStr),y
.019754	7a		ply				ply
.019755	c9 00		cmp #$00			cmp 	#0 							; suppress leading zeros.
.019757	f0 0d		beq $019766			beq 	_UHExit2
.019759	a9 00		lda #$00			lda 	#0
.01975b					_UHNonZero:
.01975b	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.01975d	90 02		bcc $019761			bcc 	_UHDigit
.01975f	69 06		adc #$06			adc 	#7-1
.019761					_UHDigit:
.019761	69 30		adc #$30			adc 	#48
.019763	20 20 99	jsr $019920			jsr 	WriteTempString				; output.
.019766					_UHExit2:
.019766	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.019767					Unary_Dec:
.019767	20 6f 92	jsr $01926f			jsr 	EvaluateStringX 			; string parameter
.01976a	20 a8 98	jsr $0198a8			jsr 	CheckNextRParen 			; right bracket.
.01976d	5a		phy				phy
.01976e	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.019770	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.019772	f0 41		beq $0197b5			beq 	_UDFail 					; must fail if zero.
.019774	8d 9e 03	sta $039e			sta 	SignCount 					; use SignCount as a counter
.019777	a9 00		lda #$00			lda 	#0 							; set result to zero integer.
.019779	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01977b	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01977d	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01977f	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019781	a9 01		lda #$01			lda 	#1
.019783	95 85		sta $85,x			sta 	XS_Type,x
.019785					_UDConvertLoop:
.019785	5a		phy				phy 								; shift mantissa left 4
.019786	a0 04		ldy #$04			ldy 	#4
.019788					_UDShift:
.019788	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.01978a	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.01978c	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.01978e	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.019790	88		dey				dey
.019791	d0 f5		bne $019788			bne 	_UDShift
.019793	7a		ply				ply
.019794	c8		iny				iny 								; next character
.019795	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; fetch it.
.019797	20 b8 97	jsr $0197b8			jsr 	ConvertUpper 				; convert to U/C
.01979a	c9 30		cmp #$30			cmp 	#"0"
.01979c	90 17		bcc $0197b5			bcc 	_UDFail
.01979e	c9 3a		cmp #$3a			cmp 	#"9"+1
.0197a0	90 06		bcc $0197a8			bcc 	_UDOkay
.0197a2	e9 37		sbc #$37			sbc 	#7+"0" 						; alpha fudge
.0197a4	c9 10		cmp #$10			cmp 	#16
.0197a6	b0 0d		bcs $0197b5			bcs 	_UDFail
.0197a8					_UDOkay:
.0197a8	29 0f		and #$0f			and 	#15 						; nibble only
.0197aa	15 80		ora $80,x			ora 	XS_Mantissa+0,x
.0197ac	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0197ae	ce 9e 03	dec $039e			dec 	SignCount 					; do it for each character
.0197b1	d0 d2		bne $019785			bne 	_UDConvertLoop
.0197b3	7a		ply				ply
.0197b4	60		rts				rts
.0197b5					_UDFail:
.0197b5	4c 68 85	jmp $018568			jmp 	BadParamError
.0197b8					ConvertUpper:
.0197b8	c9 61		cmp #$61			cmp 	#"a"
.0197ba	90 07		bcc $0197c3			bcc 	_CUExit
.0197bc	c9 7b		cmp #$7b			cmp 	#"z"+1
.0197be	b0 03		bcs $0197c3			bcs 	_CUExit
.0197c0	38		sec				sec
.0197c1	e9 20		sbc #$20			sbc 	#32
.0197c3	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.0197c4					Unary_Chr:
.0197c4	20 66 92	jsr $019266			jsr 	EvaluateIntegerX			; numeric parameter
.0197c7	20 a8 98	jsr $0198a8			jsr 	CheckNextRParen 			; right bracket.
.0197ca	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.0197cc	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.0197ce	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.0197d0	d0 0d		bne $0197df			bne 	_UCChar
.0197d2	a9 02		lda #$02			lda 	#1+1 						; one character string. 2 bytes.
.0197d4	20 f5 98	jsr $0198f5			jsr 	AllocateTempString
.0197d7	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.0197d9	20 20 99	jsr $019920			jsr 	WriteTempString
.0197dc	4c 1d 98	jmp $01981d			jmp 	UnaryReturnTempStr
.0197df					_UCChar:
.0197df	4c 68 85	jmp $018568			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.0197e2					Unary_Spc:
.0197e2	20 00 97	jsr $019700			jsr 	SLIByteParameter 			; check space.
.0197e5	20 a8 98	jsr $0198a8			jsr 	CheckNextRParen
.0197e8	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0197ea					UnarySpcCreate:
.0197ea	c9 fe		cmp #$fe			cmp 	#maxString+1
.0197ec	b0 14		bcs $019802			bcs 	_USSize
.0197ee	48		pha				pha 								; save length
.0197ef	1a		inc a				inc 	a 							; allocate one more.
.0197f0	20 f5 98	jsr $0198f5			jsr 	AllocateTempString
.0197f3	68		pla				pla 								; get length
.0197f4	f0 27		beq $01981d			beq 	UnaryReturnTempStr 			; return the current temp string
.0197f6					_USLoop:
.0197f6	48		pha				pha
.0197f7	a9 20		lda #$20			lda 	#" "
.0197f9	20 20 99	jsr $019920			jsr 	WriteTempString
.0197fc	68		pla				pla
.0197fd	3a		dec a				dec 	a
.0197fe	d0 f6		bne $0197f6			bne 	_USLoop
.019800	80 1b		bra $01981d			bra 	UnaryReturnTempStr
.019802					_USSize:
.019802	4c 68 85	jmp $018568			jmp 	BadParamError
.019805					Unary_Tab:
.019805	a2 00		ldx #$00			ldx 	#0 							; required TAB position.
.019807	20 00 97	jsr $019700			jsr 	SLIByteParameter
.01980a	20 a8 98	jsr $0198a8			jsr 	CheckNextRParen
.01980d	20 43 85	jsr $018543			jsr 	VIOCharGetPosition 			; were are we ?
.019810	85 10		sta $10				sta 	zTemp1
.019812	38		sec				sec
.019813	a5 80		lda $80				lda 	XS_Mantissa+0 				; return chars required.
.019815	e5 10		sbc $10				sbc 	zTemp1
.019817	b0 d1		bcs $0197ea			bcs 	UnarySpcCreate
.019819	a9 00		lda #$00			lda 	#0
.01981b	80 cd		bra $0197ea			bra 	UnarySpcCreate
.01981d					UnaryReturnTempStr:
.01981d	a5 20		lda $20				lda 	zTempStr 					; copy temp string addr -> mantissa
.01981f	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019821	a5 21		lda $21				lda 	zTempStr+1
.019823	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019825	a9 02		lda #$02			lda 	#2 							; set type to string
.019827	95 85		sta $85,x			sta 	XS_Type,x
.019829	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/65816.asm

.01982a					MemRead:
.01982a	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.01982d	a0 00		ldy #$00			ldy 	#0 							; start from here
.01982f	b7 1a		lda [$1a],y	_MLoop1:lda 	[zlTemp1],y 				; read the long address
.019831	95 80		sta $80,x			sta 	XS_Mantissa,x 				; copy into mantissa
.019833	c8		iny				iny 								; next to copy
.019834	e8		inx				inx
.019835	cc 9e 03	cpy $039e			cpy 	SignCount 					; do required # of bytes.
.019838	d0 f5		bne $01982f			bne 	_MLoop1
.01983a	60		rts				rts
.01983b					MemWrite:
.01983b	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.01983e	a0 00		ldy #$00			ldy 	#0 							; start from here
.019840	b5 80		lda $80,x	_MLoop1:lda 	XS_Mantissa,x 				; read mantisssa
.019842	97 1a		sta [$1a],y			sta 	[zlTemp1],y 				; write it out
.019844	c8		iny				iny 								; next to copy
.019845	e8		inx				inx
.019846	cc 9e 03	cpy $039e			cpy 	SignCount 					; do required # of bytes.
.019849	d0 f5		bne $019840			bne 	_MLoop1
.01984b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/programend.asm

.01984c					UpdateProgramEnd:
.01984c	a9 00		lda #$00			lda 	#BasicProgram & $FF
.01984e	85 16		sta $16				sta 	zCodePtr+0
.019850	a9 10		lda #$10			lda 	#BasicProgram >> 8
.019852	85 17		sta $17				sta 	zCodePtr+1
.019854	a9 00		lda #$00			lda 	#0
.019856	85 18		sta $18				sta 	zCodePtr+2
.019858	85 19		sta $19				sta 	zCodePtr+3
.01985a	a0 03		ldy #$03			ldy 	#3
.01985c					_UPDLoop:
.01985c	a0 00		ldy #$00			ldy 	#0
.01985e	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019860	c9 00		cmp #$00			cmp 	#0 							; end if offset is zero.
.019862	f0 0f		beq $019873			beq 	_UPDFoundEnd
.019864	a0 00		ldy #$00			ldy 	#0 							; point to offset
.019866	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.019868	18		clc				clc
.019869	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.01986b	85 16		sta $16				sta 	zCodePtr
.01986d	90 02		bcc $019871			bcc 	_SNLNoCarry
.01986f	e6 17		inc $17				inc 	zCodePtr+1
.019871					_SNLNoCarry:
.019871	80 e9		bra $01985c			bra 	_UPDLoop
.019873					_UPDFoundEnd:
.019873	18		clc				clc 								; end of program 2 on.
.019874	a5 16		lda $16				lda 	zCodePtr
.019876	69 02		adc #$02			adc 	#2
.019878	8d 04 03	sta $0304			sta 	endOfProgram
.01987b	a5 17		lda $17				lda 	zCodePtr+1
.01987d	69 00		adc #$00			adc 	#0
.01987f	8d 05 03	sta $0305			sta 	endOfProgram+1
.019882	a5 18		lda $18				lda 	zCodePtr+2
.019884	69 00		adc #$00			adc		#0
.019886	8d 06 03	sta $0306			sta 	endOfProgram+2
.019889	a5 19		lda $19				lda 	zCodePtr+3
.01988b	69 00		adc #$00			adc 	#0
.01988d	8d 07 03	sta $0307			sta 	endOfProgram+3
.019890	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.019891					CheckNextToken:
.019891	d7 16		cmp [$16],y			cmp 	[zCodePtr],y
.019893	d0 02		bne $019897			bne 	CTFail 						; no, then fail
.019895	c8		iny				iny
.019896	60		rts				rts
.019897					CTFail:
.019897	20 79 85	jsr $018579			jsr ERR_Handler
>01989a	4d 69 73 73 69 6e 67 20			.text "Missing token",0
>0198a2	74 6f 6b 65 6e 00
.0198a8					CheckNextRParen:
.0198a8	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0198aa	c9 be		cmp #$be			cmp 	#token_rparen
.0198ac	d0 e9		bne $019897			bne 	CTFail
.0198ae	c8		iny				iny
.0198af	60		rts				rts
.0198b0					CheckNextComma:
.0198b0	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0198b2	c9 bf		cmp #$bf			cmp 	#token_comma
.0198b4	d0 e1		bne $019897			bne 	CTFail
.0198b6	c8		iny				iny
.0198b7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/concrete.asm

.0198b8					StringConcrete:
.0198b8	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; save source to zTemp1
.0198ba	85 10		sta $10				sta 	zTemp1
.0198bc	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0198be	85 11		sta $11				sta 	zTemp1+1
.0198c0	a0 00		ldy #$00			ldy 	#0 							; empty string, return default empty
.0198c2	b1 10		lda ($10),y			lda 	(zTemp1),y
.0198c4	f0 26		beq $0198ec			beq		_SCEmpty
.0198c6	18		clc				clc 								; from the string pointer
.0198c7	ad 00 03	lda $0300			lda 	StringPtr 					; and put in zTemp2 as well
.0198ca	f1 10		sbc ($10),y			sbc 	(zTemp1),y
.0198cc	8d 00 03	sta $0300			sta 	StringPtr
.0198cf	85 12		sta $12				sta 	zTemp2
.0198d1	ad 01 03	lda $0301			lda 	StringPtr+1
.0198d4	e9 00		sbc #$00			sbc 	#0
.0198d6	8d 01 03	sta $0301			sta 	StringPtr+1
.0198d9	85 13		sta $13				sta 	zTemp2+1
.0198db	b1 10		lda ($10),y			lda 	(zTemp1),y 					; length add one for count
.0198dd	1a		inc a				inc 	a
.0198de	aa		tax				tax
.0198df	b1 10		lda ($10),y	_SCCopy:lda 	(zTemp1),y 					; copy whole thing including length
.0198e1	91 12		sta ($12),y			sta 	(zTemp2),y
.0198e3	c8		iny				iny
.0198e4	ca		dex				dex
.0198e5	d0 f8		bne $0198df			bne 	_SCCopy
.0198e7	a5 13		lda $13				lda 	zTemp2+1 					; return concrete string in AX
.0198e9	a6 12		ldx $12				ldx 	zTemp2
.0198eb	60		rts				rts
.0198ec					_SCEmpty:
.0198ec	a9 00		lda #$00			lda 	#0
.0198ee	85 25		sta $25				sta 	zNullString
.0198f0	a9 00		lda #$00			lda 	#zNullString >> 8
.0198f2	a2 25		ldx #$25			ldx 	#zNulLString & $FF
.0198f4	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.0198f5					AllocateTempString:
.0198f5	48		pha				pha 								; save required count.
.0198f6	a5 21		lda $21				lda 	zTempStr+1 					; check if initialised yet ?
.0198f8	d0 0b		bne $019905			bne 	_ATSInitialised
.0198fa	ad 00 03	lda $0300			lda 	StringPtr 					; set temporary string ptr 1 page below available
.0198fd	85 20		sta $20				sta 	zTempStr					; space, this is for strings to be concreted.
.0198ff	ad 01 03	lda $0301			lda 	StringPtr+1
.019902	3a		dec a				dec 	a
.019903	85 21		sta $21				sta 	zTempStr+1
.019905					_ATSInitialised:
.019905	68		pla				pla 								; get required count back.
.019906	49 ff		eor #$ff			eor 	#$FF 						; negate 2's complement.
.019908	1a		inc a				inc 	a
.019909	18		clc				clc
.01990a	65 20		adc $20				adc 	zTempStr 					; "add" to the temp string pointer
.01990c	85 20		sta $20				sta 	zTempStr
.01990e	a9 ff		lda #$ff			lda 	#$FF
.019910	65 21		adc $21				adc 	zTempStr+1
.019912	85 21		sta $21				sta 	zTempStr+1
.019914	a9 00		lda #$00			lda 	#0 							; clear temp string.
.019916	5a		phy				phy
.019917	a8		tay				tay
.019918	91 20		sta ($20),y			sta 	(zTempStr),y
.01991a	7a		ply				ply
.01991b	1a		inc a				inc 	a 							; reset the write index.
.01991c	8d 9f 03	sta $039f			sta 	TempStringWriteIndex
.01991f	60		rts				rts
.019920					WriteTempString:
.019920	5a		phy				phy 								; save Y
.019921	ac 9f 03	ldy $039f			ldy 	TempStringWriteIndex	 	; write position.
.019924	91 20		sta ($20),y			sta 	(zTempStr),y 				; write character out.
.019926	ee 9f 03	inc $039f			inc 	TempStringWriteIndex 		; increment the write position.
.019929	98		tya				tya 								; unchanged Y is now length
.01992a	a0 00		ldy #$00			ldy 	#0
.01992c	91 20		sta ($20),y			sta 	(zTempStr),y
.01992e	7a		ply				ply 								; restore Y and exit
.01992f	60		rts				rts
.019930					CreateTempStringCopy:
.019930	da		phx				phx 								; save X
.019931	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019933	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.019934	20 f5 98	jsr $0198f5			jsr 	AllocateTempString 			; allocate memory for temporary string.
.019937	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019939	c8		iny				iny
.01993a	3a		dec a				dec 	a 							; make the actual length in charactes
.01993b	3a		dec a				dec 	a
.01993c	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.01993e	81 20		sta ($20,x)			sta 	(zTempStr,x)
.019940	85 1a		sta $1a				sta 	zLTemp1 					; that's used as a count.
.019942	09 00		ora #$00			ora 	#0 							; if zero already, exit
.019944	f0 0e		beq $019954			beq 	_CTSCExit
.019946					_CTSCLoop:
.019946	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019948	c8		iny				iny
.019949	5a		phy				phy 								; save in Y
.01994a	e8		inx				inx 								; bump index
.01994b	da		phx				phx 								; index into Y
.01994c	7a		ply				ply
.01994d	91 20		sta ($20),y			sta 	(zTempStr),y 				; save at index
.01994f	7a		ply				ply 								; restore Y
.019950	c6 1a		dec $1a				dec 	zLTemp1 					; do for each character
.019952	d0 f2		bne $019946			bne 	_CTSCLoop
.019954					_CTSCExit:
.019954	fa		plx				plx 								; restore X
.019955	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/variables.asm

.019956					VariableFind:
.019956	20 c1 99	jsr $0199c1			jsr 	VariableExtract 		; find out all about it ....
.019959	20 5a 9c	jsr $019c5a			jsr 	VariableLocate 			; does it already exist ?
.01995c	b0 03		bcs $019961			bcs 	_VFExists 				; if so, use that.
.01995e	20 4d 9a	jsr $019a4d			jsr 	VariableCreate 			; otherwise create it.
.019961					_VFExists:
.019961	a5 24		lda $24				lda 	zVarType 				; is it still an array ?
.019963	29 01		and #$01			and 	#1
.019965	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.019967	d0 28		bne $019991			bne 	_VFSingleElement
.019969					_VFNextIndex:
.019969	a5 22		lda $22				lda 	zVarDataPtr 			; push the data ptr and type on the stack.
.01996b	48		pha				pha
.01996c	a5 23		lda $23				lda 	zVarDataPtr+1
.01996e	48		pha				pha
.01996f	a5 24		lda $24				lda 	zVarType
.019971	48		pha				pha
.019972	20 66 92	jsr $019266			jsr 	EvaluateIntegerX 		; calculate the index.
.019975	68		pla				pla 							; restore and index.
.019976	85 24		sta $24				sta 	zVarType
.019978	68		pla				pla
.019979	85 23		sta $23				sta 	zVarDataPtr+1
.01997b	68		pla				pla
.01997c	85 22		sta $22				sta 	zVarDataPtr
.01997e	20 d8 9a	jsr $019ad8			jsr 	ArrayIndexFollow 		; do the index.
.019981	a5 24		lda $24				lda 	zVarType 				; is it still an array ??
.019983	29 01		and #$01			and 	#1
.019985	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.019987	d0 05		bne $01998e			bne 	_VFArrayDone 			; if so then exit.
.019989	20 b0 98	jsr $0198b0			jsr 	CheckNextComma 			; comma should follow
.01998c	80 db		bra $019969			bra 	_VFNextIndex
.01998e					_VFArrayDone:
.01998e	20 a8 98	jsr $0198a8			jsr 	CheckNextRParen 		; check closing right bracket.
.019991					_VFSingleElement:
.019991	60		rts				rts
.019992					VariableClear:
.019992	48		pha				pha 							; save registers
.019993	da		phx				phx
.019994	a2 00		ldx #$00			ldx 	#0 						; clear out the hash table.
.019996	8a		txa				txa
.019997	9d 35 03	sta $0335,x	_VCLoop:sta 	HashTableBase,x
.01999a	e8		inx				inx
.01999b	e0 60		cpx #$60			cpx 	#HashTableEnd-HashTableBase
.01999d	d0 f8		bne $019997			bne 	_VCLoop
.01999f	a9 00		lda #$00			lda 	#VariableMemory & $FF
.0199a1	8d 02 03	sta $0302			sta 	VarMemPtr
.0199a4	a9 30		lda #$30			lda 	#VariableMemory >> 8
.0199a6	8d 03 03	sta $0303			sta 	VarMemPtr+1
.0199a9	fa		plx				plx 							; restore registers
.0199aa	68		pla				pla
.0199ab	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/extract.asm

.0199ac					VariableNameError:
.0199ac	20 79 85	jsr $018579			jsr ERR_Handler
>0199af	42 61 64 20 56 61 72 69			.text "Bad Variable Name",0
>0199b7	61 62 6c 65 20 4e 61 6d 65 00
.0199c1					VariableExtract:
.0199c1	da		phx				phx 							; save X.
.0199c2	a9 ba		lda #$ba			lda 	#token_hashlParen  		; set the type to #( e.g. real array.
.0199c4	8d 95 03	sta $0395			sta 	Var_Type
.0199c7	8d 96 03	sta $0396			sta 	Var_Hash 				; we initialise the hash with this. It doesn't matter
.0199ca	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0199cc	c9 00		cmp #$00			cmp 	#0 						; first one must be A-Z
.0199ce	f0 dc		beq $0199ac			beq 	VariableNameError
.0199d0	c9 1b		cmp #$1b			cmp 	#26+1
.0199d2	b0 d8		bcs $0199ac			bcs 	VariableNameError
.0199d4	a2 ff		ldx #$ff			ldx 	#255 					; now copy it into the variable buffer.
.0199d6					_VECopyBuffer:
.0199d6	e8		inx				inx
.0199d7	e0 1f		cpx #$1f			cpx 	#31 					; too long
.0199d9	f0 d1		beq $0199ac			beq 	VariableNameError
.0199db	9d 15 03	sta $0315,x			sta 	Var_Buffer,x 			; save character
.0199de	18		clc				clc  							; update the hash value for it.
.0199df	6d 96 03	adc $0396			adc 	Var_Hash
.0199e2	8d 96 03	sta $0396			sta 	Var_Hash
.0199e5	c8		iny				iny
.0199e6	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0199e8	c9 00		cmp #$00			cmp 	#0 						; zero or token, end of variable
.0199ea	f0 0e		beq $0199fa			beq 	_VECopyEnd
.0199ec	30 0c		bmi $0199fa			bmi 	_VECopyEnd
.0199ee	c9 1b		cmp #$1b			cmp 	#26+1 					; A-Z continue copying
.0199f0	90 e4		bcc $0199d6			bcc 	_VECopyBuffer
.0199f2	c9 30		cmp #$30			cmp 	#"0" 					; 0-9 copy as well.
.0199f4	90 04		bcc $0199fa			bcc 	_VECopyEnd
.0199f6	c9 3a		cmp #$3a			cmp 	#"9"+1
.0199f8	90 dc		bcc $0199d6			bcc 	_VECopyBuffer
.0199fa					_VECopyEnd:
.0199fa	c8		iny				iny
.0199fb	c9 b7		cmp #$b7			cmp 	#token_Dollar 			; first type token.
.0199fd	90 04		bcc $019a03			bcc 	_VEDefaultRequired
.0199ff	c9 bd		cmp #$bd			cmp 	#token_PercentLParen+1	; last type token.
.019a01	90 0b		bcc $019a0e			bcc 	_VEHaveType
.019a03					_VEDefaultRequired:
.019a03	c9 bd		cmp #$bd			cmp 	#token_LParen 			; if it ends in ( then use the real array
.019a05	f0 04		beq $019a0b			beq 	_VESetType 				; default set above.
.019a07	ce 95 03	dec $0395			dec 	Var_Type 				; this changes that default to the variable default
.019a0a	88		dey				dey
.019a0b					_VESetType:
.019a0b	ad 95 03	lda $0395			lda 	Var_Type 				; get type ....
.019a0e					_VEHaveType:
.019a0e	8d 95 03	sta $0395			sta 	Var_Type 				; save as type.
.019a11	bd 15 03	lda $0315,x			lda 	Var_Buffer,x 			; set bit 7 of name, marks the end.
.019a14	09 80		ora #$80			ora 	#$80
.019a16	9d 15 03	sta $0315,x			sta 	Var_Buffer,x
.019a19	e8		inx				inx 							; offset 3 => length 4.
.019a1a	8e 97 03	stx $0397			stx 	Var_Length 				; save length of variable name.
.019a1d	ad 95 03	lda $0395			lda 	Var_Type 				; get offset of var type from first type token
.019a20	38		sec				sec
.019a21	e9 b7		sbc #$b7			sbc 	#token_Dollar
.019a23	0a		asl a				asl 	a 						; multiply by 16. This requires HashTableSize
.019a24	0a		asl a				asl 	a 						; in data.asm to be 8 (8 sets of links,2 bytes each)
.019a25	0a		asl a				asl 	a
.019a26	0a		asl a				asl 	a
.019a27	8d 98 03	sta $0398			sta 	Var_HashAddress
.019a2a	ad 96 03	lda $0396			lda 	Var_Hash 				; get the hash
.019a2d	29 07		and #$07			and 	#(HashTableSize-1) 		; force into range 0-tableSize-1
.019a2f	0a		asl a				asl 	a 						; double it (2 bytes per entry) & clears carry
.019a30	6d 98 03	adc $0398			adc 	Var_HashAddress 		; add table offset.
.019a33	69 35		adc #$35			adc 	#HashTableBase & $FF 	; now the low byte of the actual table address
.019a35	8d 98 03	sta $0398			sta 	Var_HashAddress
.019a38	a2 05		ldx #$05			ldx 	#5 						; hash is 5 bytes (real)
.019a3a	ad 95 03	lda $0395			lda 	Var_Type
.019a3d	c9 b9		cmp #$b9			cmp 	#token_Hash
.019a3f	f0 07		beq $019a48			beq 	_VEHaveSize
.019a41	ca		dex				dex
.019a42	c9 bb		cmp #$bb			cmp 	#token_Percent 			; percent is 4 bytes (integer)
.019a44	f0 02		beq $019a48			beq 	_VEHaveSize
.019a46	a2 02		ldx #$02			ldx 	#2 						; everything else is two.
.019a48					_VEHaveSize:
.019a48	8e 99 03	stx $0399			stx 	Var_DataSize
.019a4b	fa		plx				plx
.019a4c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varcreate.asm

.019a4d					VariableCreate:
.019a4d	da		phx				phx
.019a4e	5a		phy				phy
.019a4f	ad 02 03	lda $0302			lda 	VarMemPtr 					; get address of next free into zTemp1
.019a52	85 10		sta $10				sta 	zTemp1
.019a54	ad 03 03	lda $0303			lda 	VarMemPtr+1
.019a57	85 11		sta $11				sta 	zTemp1+1
.019a59	ad 99 03	lda $0399			lda 	Var_DataSize 				; bytes for the data bit
.019a5c	18		clc				clc
.019a5d	6d 97 03	adc $0397			adc 	Var_Length 					; add the length of the name
.019a60	69 03		adc #$03			adc 	#3 							; 3 for the link and the hash.
.019a62	6d 02 03	adc $0302			adc 	VarMemPtr 					; add to variable memory pointer
.019a65	8d 02 03	sta $0302			sta 	VarMemPtr
.019a68	90 03		bcc $019a6d			bcc 	_VCNoCarry
.019a6a	ee 03 03	inc $0303			inc 	VarMemPtr+1
.019a6d					_VCNoCarry:
.019a6d	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.019a70	85 12		sta $12				sta 	zTemp2
.019a72	a9 03		lda #$03			lda 	#HashTableBase >> 8
.019a74	85 13		sta $13				sta 	zTemp2+1
.019a76	a0 00		ldy #$00			ldy 	#0 							; put current hash link in position.
.019a78	b1 12		lda ($12),y			lda 	(zTemp2),y
.019a7a	91 10		sta ($10),y			sta 	(zTemp1),y
.019a7c	c8		iny				iny
.019a7d	b1 12		lda ($12),y			lda 	(zTemp2),y
.019a7f	91 10		sta ($10),y			sta 	(zTemp1),y
.019a81	c8		iny				iny
.019a82	ad 96 03	lda $0396			lda 	Var_Hash 					; write the hash out.
.019a85	91 10		sta ($10),y			sta 	(zTemp1),y
.019a87	c8		iny				iny
.019a88	a2 00		ldx #$00			ldx 	#0 							; copy the name out.
.019a8a					_VCCopyName:
.019a8a	bd 15 03	lda $0315,x			lda 	Var_Buffer,x
.019a8d	91 10		sta ($10),y			sta 	(zTemp1),y
.019a8f	e8		inx				inx
.019a90	c8		iny				iny
.019a91	ec 97 03	cpx $0397			cpx 	Var_Length
.019a94	d0 f4		bne $019a8a			bne 	_VCCopyName
.019a96	5a		phy				phy 								; save the data offset.
.019a97	ae 99 03	ldx $0399			ldx 	Var_DataSize 				; and write the data out.
.019a9a	a9 00		lda #$00			lda 	#0 							; which is all zeroes.
.019a9c					_VCClearData:
.019a9c	91 10		sta ($10),y			sta 	(zTemp1),y
.019a9e	c8		iny				iny
.019a9f	ca		dex				dex
.019aa0	d0 fa		bne $019a9c			bne 	_VCClearData
.019aa2	68		pla				pla 								; offset to the data
.019aa3	18		clc				clc
.019aa4	65 10		adc $10				adc 	zTemp1 						; add to start and save as data pointer.
.019aa6	85 22		sta $22				sta 	zVarDataPtr
.019aa8	a5 11		lda $11				lda 	zTemp1+1
.019aaa	69 00		adc #$00			adc 	#0
.019aac	85 23		sta $23				sta 	zVarDataPtr+1
.019aae	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.019ab1	85 24		sta $24				sta 	zVarType
.019ab3	a5 10		lda $10				lda 	zTemp1 						; fix hash link to point to new record
.019ab5	a0 00		ldy #$00			ldy 	#0
.019ab7	91 12		sta ($12),y			sta 	(zTemp2),y
.019ab9	c8		iny				iny
.019aba	a5 11		lda $11				lda 	zTemp1+1
.019abc	91 12		sta ($12),y			sta 	(zTemp2),y
.019abe	ad 95 03	lda $0395			lda 	Var_Type 					; array ? if so create the empty one.
.019ac1	29 01		and #$01			and 	#1
.019ac3	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.019ac5	d0 0e		bne $019ad5			bne 	_VCNotArray
.019ac7	a2 00		ldx #$00			ldx 	#0 							; call recursive array creator
.019ac9	20 6f 9b	jsr $019b6f			jsr 	ArrayCreate
.019acc	5a		phy				phy 								; save YA at zVarDataPtr
.019acd	a0 00		ldy #$00			ldy 	#0
.019acf	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019ad1	c8		iny				iny
.019ad2	68		pla				pla
.019ad3	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019ad5					_VCNotArray:
.019ad5	7a		ply				ply
.019ad6	fa		plx				plx
.019ad7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arrayidx.asm

.019ad8					ArrayIndexFollow:
.019ad8	5a		phy				phy
.019ad9	a0 00		ldy #$00			ldy 	#0 							; make zVarDataPtr point to the array.
.019adb	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; e.g. it points to itself.
.019add	48		pha				pha
.019ade	c8		iny				iny
.019adf	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019ae1	85 23		sta $23				sta 	zVarDataPtr+1
.019ae3	68		pla				pla
.019ae4	85 22		sta $22				sta 	zVarDataPtr
.019ae6	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; MSB of 16 bit integer and bytes 2&3
.019ae8	29 80		and #$80			and 	#$80 						; must be zero.
.019aea	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019aec	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019aee	d0 59		bne $019b49			bne 	_AIFError
.019af0	a0 00		ldy #$00			ldy 	#0 							; calculate size - current - 1
.019af2	18		clc				clc
.019af3	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019af5	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.019af7	c8		iny				iny
.019af8	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019afa	08		php				php 								; clear bit 7 retaining borrow.
.019afb	29 7f		and #$7f			and 	#$7F
.019afd	28		plp				plp
.019afe	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.019b00	90 47		bcc $019b49			bcc 	_AIFError 					; eror if size-current < 0
.019b02	b5 80		lda $80,x			lda  	XS_Mantissa+0,x 			; copy and double the index
.019b04	0a		asl a				asl 	a 							; (e.g. index * 2)
.019b05	85 10		sta $10				sta 	zTemp1
.019b07	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019b09	2a		rol a				rol 	a
.019b0a	85 11		sta $11				sta 	zTemp1+1
.019b0c	a0 01		ldy #$01			ldy 	#1 							; is this a data entry.
.019b0e	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; if so, then type is unchanged, offset set
.019b10	30 1d		bmi $019b2f			bmi 	_AIFCalculate
.019b12	c6 24		dec $24				dec 	zVarType 					; converts from an array to a type.
.019b14	a5 24		lda $24				lda 	zVarType 					; check that type
.019b16	c9 b7		cmp #$b7			cmp 	#token_Dollar 				; if string, use x 2
.019b18	f0 15		beq $019b2f			beq 	_AIFCalculate
.019b1a	06 10		asl $10				asl 	zTemp1			 			; double the index
.019b1c	26 11		rol $11				rol 	zTemp1+1					; (e.g. index * 4)
.019b1e	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if integer, use x 4
.019b20	f0 0d		beq $019b2f			beq 	_AIFCalculate
.019b22	18		clc				clc 								; add the original mantissa in again
.019b23	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; which makes it x5, for float.
.019b25	65 10		adc $10				adc 	zTemp1
.019b27	85 10		sta $10				sta 	zTemp1
.019b29	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019b2b	65 11		adc $11				adc 	zTemp1+1
.019b2d	85 11		sta $11				sta 	zTemp1+1
.019b2f					_AIFCalculate:
.019b2f	18		clc				clc 								; add index x 2,4 or 5 to base
.019b30	a5 22		lda $22				lda 	zVarDataPtr
.019b32	65 10		adc $10				adc 	zTemp1
.019b34	85 22		sta $22				sta 	zVarDataPtr
.019b36	a5 23		lda $23				lda 	zVarDataPtr+1
.019b38	65 11		adc $11				adc 	zTemp1+1
.019b3a	85 23		sta $23				sta 	zVarDataPtr+1
.019b3c	18		clc				clc 								; add 2 more for the length prefix.
.019b3d	a5 22		lda $22				lda 	zVarDataPtr
.019b3f	69 02		adc #$02			adc 	#2
.019b41	85 22		sta $22				sta 	zVarDataPtr
.019b43	90 02		bcc $019b47			bcc 	_AIFNoBump
.019b45	e6 23		inc $23				inc 	zVarDataPtr+1
.019b47					_AIFNoBump:
.019b47	7a		ply				ply
.019b48	60		rts				rts
.019b49					_AIFError:
.019b49	20 79 85	jsr $018579			jsr ERR_Handler
>019b4c	42 61 64 20 61 72 72 61			.text "Bad array index",0
>019b54	79 20 69 6e 64 65 78 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arraydef.asm

.019b5c					ArrayResetDefault:
.019b5c	a9 0b		lda #$0b			lda 	#11 						; 0..10 one array
.019b5e	8d a9 03	sta $03a9			sta 	ArrayDef+0
.019b61	a9 00		lda #$00			lda 	#0
.019b63	8d aa 03	sta $03aa			sta 	ArrayDef+1
.019b66	a9 ff		lda #$ff			lda 	#$FF
.019b68	8d ab 03	sta $03ab			sta 	ArrayDef+2 					; $FFFF implies no second element.
.019b6b	8d ac 03	sta $03ac			sta 	ArrayDef+3					; (test bit 7 of 2nd byte)
.019b6e	60		rts				rts
.019b6f					ArrayCreate:
.019b6f	bd a9 03	lda $03a9,x			lda 	ArrayDef+0,x 				; put size x 2 in zTemp1
.019b72	0a		asl a				asl 	a
.019b73	85 10		sta $10				sta 	zTemp1
.019b75	bd aa 03	lda $03aa,x			lda 	ArrayDef+1,x
.019b78	2a		rol a				rol 	a
.019b79	85 11		sta $11				sta 	zTemp1+1
.019b7b	bd ac 03	lda $03ac,x			lda 	ArrayDef+3,x 				; if this is the last element it's array of ptrs.
.019b7e	10 22		bpl $019ba2			bpl 	_ACSized 					; if not multiply size x 2 (str) 4 (int) 5 (real)
.019b80	ad 95 03	lda $0395			lda 	Var_Type 					; check the type
.019b83	c9 b8		cmp #$b8			cmp 	#token_DollarLParen 		; also if it is an array of strings $(
.019b85	f0 1b		beq $019ba2			beq 	_ACSized
.019b87	06 10		asl $10				asl 	zTemp1 						; double again
.019b89	26 11		rol $11				rol 	zTemp1+1
.019b8b	b0 6f		bcs $019bfc			bcs 	ArrayIndexError 			; too large.
.019b8d	c9 bc		cmp #$bc			cmp 	#token_PercentLParen 		; if %( four bytes/entry is enough.
.019b8f	f0 11		beq $019ba2			beq 	_ACSized
.019b91	18		clc				clc 								; add original value x 5 for reals.
.019b92	a5 10		lda $10				lda 	zTemp1
.019b94	7d a9 03	adc $03a9,x			adc 	ArrayDef+0,x
.019b97	85 10		sta $10				sta 	zTemp1
.019b99	a5 11		lda $11				lda 	zTemp1+1
.019b9b	7d aa 03	adc $03aa,x			adc 	ArrayDef+1,x
.019b9e	85 11		sta $11				sta 	zTemp1+1
.019ba0	b0 5a		bcs $019bfc			bcs 	ArrayIndexError
.019ba2					_ACSized:
.019ba2	18		clc				clc
.019ba3	a5 10		lda $10				lda 	zTemp1
.019ba5	69 02		adc #$02			adc 	#2
.019ba7	85 10		sta $10				sta 	zTemp1
.019ba9	90 04		bcc $019baf			bcc 	_ACNoBump
.019bab	e6 10		inc $10				inc 	zTemp1
.019bad	f0 4d		beq $019bfc			beq 	ArrayIndexError
.019baf					_ACNoBump:
.019baf	18		clc				clc
.019bb0	ad 02 03	lda $0302			lda 	VarMemPtr 					; add this allocated count to VarMemPtr
.019bb3	85 12		sta $12				sta 	zTemp2						; save start in zTemp2/zTemp3
.019bb5	85 14		sta $14				sta 	zTemp3
.019bb7	65 10		adc $10				adc 	zTemp1
.019bb9	8d 02 03	sta $0302			sta 	VarMemPtr
.019bbc	ad 03 03	lda $0303			lda 	VarMemPtr+1
.019bbf	85 13		sta $13				sta 	zTemp2+1
.019bc1	85 15		sta $15				sta 	zTemp3+1
.019bc3	65 11		adc $11				adc 	zTemp1+1
.019bc5	8d 03 03	sta $0303			sta 	VarMemPtr+1
.019bc8	85 11		sta $11				sta 	zTemp1+1
.019bca	b0 30		bcs $019bfc			bcs 	ArrayIndexError
.019bcc	a0 00		ldy #$00			ldy 	#0							; write $00 out.
.019bce					_ACClear:
.019bce	98		tya				tya
.019bcf	91 12		sta ($12),y			sta 	(zTemp2),y
.019bd1	e6 12		inc $12				inc 	zTemp2
.019bd3	d0 02		bne $019bd7			bne 	_ACCBump
.019bd5	e6 13		inc $13				inc 	zTemp2+1
.019bd7					_ACCBump:
.019bd7	a5 12		lda $12				lda 	zTemp2
.019bd9	cd 02 03	cmp $0302			cmp 	VarMemPtr
.019bdc	d0 f0		bne $019bce			bne 	_ACClear
.019bde	a5 13		lda $13				lda 	zTemp2+1
.019be0	cd 03 03	cmp $0303			cmp 	VarMemPtr+1
.019be3	d0 e9		bne $019bce			bne 	_ACClear
.019be5	a0 00		ldy #$00			ldy 	#0
.019be7	bd a9 03	lda $03a9,x			lda 	ArrayDef+0,x 				; copy the size into the start
.019bea	91 14		sta ($14),y			sta 	(zTemp3),y
.019bec	c8		iny				iny
.019bed	bd aa 03	lda $03aa,x			lda 	ArrayDef+1,x
.019bf0	91 14		sta ($14),y			sta 	(zTemp3),y
.019bf2	bd ac 03	lda $03ac,x			lda 	ArrayDef+3,x 				; have we reached the end
.019bf5	10 18		bpl $019c0f			bpl 	ACCFillRecursive
.019bf7	a4 15		ldy $15				ldy 	zTemp3+1 					; return address
.019bf9	a5 14		lda $14				lda 	zTemp3
.019bfb	60		rts				rts
.019bfc					ArrayIndexError:
.019bfc	20 79 85	jsr $018579			jsr ERR_Handler
>019bff	42 61 64 20 61 72 72 61			.text "Bad array index",0
>019c07	79 20 69 6e 64 65 78 00
.019c0f					ACCFillRecursive:
.019c0f	a9 ff		lda #$ff			lda 	#$FF 						; we mark the end, this is free space.
.019c11	a0 00		ldy #$00			ldy 	#0 							; this is overwritten by size of next allocated
.019c13	91 12		sta ($12),y			sta 	(zTemp2),y 					; array, but we might change that.
.019c15	c8		iny				iny
.019c16	b1 14		lda ($14),y			lda 	(zTemp3),y 					; set bit 15 of the max index indicating
.019c18	09 80		ora #$80			ora 	#$80 						; an array of pointers
.019c1a	91 14		sta ($14),y			sta 	(zTemp3),y
.019c1c	a5 14		lda $14				lda 	zTemp3 						; push the start on the stack
.019c1e	48		pha				pha
.019c1f	a5 15		lda $15				lda 	zTemp3+1
.019c21	48		pha				pha
.019c22					_ACCFillLoop:
.019c22	18		clc				clc
.019c23	a5 14		lda $14				lda 	zTemp3 						; and work forwards.
.019c25	69 02		adc #$02			adc 	#2
.019c27	85 14		sta $14				sta 	zTemp3
.019c29	90 02		bcc $019c2d			bcc 	_ACCSkip2
.019c2b	e6 15		inc $15				inc 	zTemp3+1
.019c2d					_ACCSkip2:
.019c2d	a0 00		ldy #$00			ldy 	#0 							; reached the end ?
.019c2f	b1 14		lda ($14),y			lda 	(zTemp3),y					; (looking for FF marker, everything else 00)
.019c31	c8		iny				iny
.019c32	11 14		ora ($14),y			ora 	(zTemp3),y
.019c34	d0 21		bne $019c57			bne 	_ACCExit
.019c36	a5 14		lda $14				lda 	zTemp3 						; push zTemp3
.019c38	48		pha				pha
.019c39	a5 15		lda $15				lda 	zTemp3+1
.019c3b	48		pha				pha
.019c3c	e8		inx				inx
.019c3d	e8		inx				inx
.019c3e	20 6f 9b	jsr $019b6f			jsr 	ArrayCreate 				; create array recursively.
.019c41	ca		dex				dex
.019c42	ca		dex				dex
.019c43	85 12		sta $12				sta 	zTemp2 						; save A
.019c45	68		pla				pla
.019c46	85 15		sta $15				sta 	zTemp3+1 					; restore zTemp3
.019c48	68		pla				pla
.019c49	85 14		sta $14				sta 	zTemp3
.019c4b	98		tya				tya 								; write high bye from Y
.019c4c	a0 01		ldy #$01			ldy 	#1
.019c4e	91 14		sta ($14),y			sta 	(zTemp3),y
.019c50	88		dey				dey 								; write low byte out.
.019c51	a5 12		lda $12				lda 	zTemp2
.019c53	91 14		sta ($14),y			sta 	(zTemp3),y
.019c55	80 cb		bra $019c22			bra 	_ACCFillLoop 				; and try again.
.019c57					_ACCExit:
.019c57	7a		ply				ply 								; restore the original address
.019c58	68		pla				pla
.019c59	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varfind.asm

.019c5a					VariableLocate:
.019c5a	da		phx				phx
.019c5b	5a		phy				phy
.019c5c	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.019c5f	85 12		sta $12				sta 	zTemp2 						; points to first address.
.019c61	a9 03		lda #$03			lda 	#HashTableBase >> 8
.019c63	85 13		sta $13				sta 	zTemp2+1
.019c65	a0 00		ldy #$00	_VLNext:ldy 	#0 							; get next link into AX
.019c67	b1 12		lda ($12),y			lda 	(zTemp2),y
.019c69	aa		tax				tax
.019c6a	c8		iny				iny
.019c6b	b1 12		lda ($12),y			lda 	(zTemp2),y
.019c6d	85 13		sta $13				sta 	zTemp2+1 					; save in zTemp
.019c6f	86 12		stx $12				stx 	zTemp2
.019c71	05 12		ora $12				ora 	zTemp2 						; got zero
.019c73	18		clc				clc
.019c74	f0 25		beq $019c9b			beq 	_VLExit 					; if so, then fail as end of chain.
.019c76	c8		iny				iny 								; point to hash (offset + 2)
.019c77	b1 12		lda ($12),y			lda 	(zTemp2),y
.019c79	cd 96 03	cmp $0396			cmp 	Var_Hash
.019c7c	d0 e7		bne $019c65			bne 	_VLNext 					; try next if different.
.019c7e					_VLCompare:
.019c7e	c8		iny				iny 								; next character
.019c7f	b1 12		lda ($12),y			lda 	(zTemp2),y 					; compare variable field against buffer.
.019c81	d9 12 03	cmp $0312,y			cmp 	Var_Buffer-3,y 				; the -3 is because name starts at 3.
.019c84	d0 df		bne $019c65			bne 	_VLNext 					; fail if different, try next.
.019c86	0a		asl a				asl 	a 							; until end character (bit 7 set) matched
.019c87	90 f5		bcc $019c7e			bcc 	_VLCompare
.019c89	98		tya				tya
.019c8a	38		sec				sec 								; add 1 as Y points to last character
.019c8b	65 12		adc $12				adc 	zTemp2 						; add to the current address
.019c8d	85 22		sta $22				sta 	zVarDataPtr
.019c8f	a5 13		lda $13				lda 	zTemp2+1
.019c91	69 00		adc #$00			adc 	#0
.019c93	85 23		sta $23				sta 	zVarDataPtr+1
.019c95	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.019c98	85 24		sta $24				sta 	zVarType
.019c9a	38		sec				sec 								; return CS
.019c9b	7a		ply		_VLExit:ply
.019c9c	fa		plx				plx
.019c9d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/vargetset.asm

.019c9e					VariableGet:
.019c9e	5a		phy				phy
.019c9f	a0 00		ldy #$00			ldy 	#0 							; copy first two bytes
.019ca1	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019ca3	95 80		sta $80,x			sta 	XS_Mantissa,x
.019ca5	c8		iny				iny
.019ca6	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019ca8	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019caa	c8		iny				iny
.019cab	a5 24		lda $24				lda 	zVarType 					; if it is a string, set up for that.
.019cad	c9 b7		cmp #$b7			cmp 	#token_Dollar
.019caf	f0 2c		beq $019cdd			beq 	_VGString
.019cb1	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; copy the next two bytes.
.019cb3	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019cb5	c8		iny				iny
.019cb6	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019cb8	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019cba	c8		iny				iny
.019cbb	a9 01		lda #$01			lda 	#1 							; set type to 1.
.019cbd	95 85		sta $85,x			sta 	XS_Type,x
.019cbf	a5 24		lda $24				lda 	zVarType
.019cc1	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if it is a %, then exit with default integer.
.019cc3	f0 28		beq $019ced			beq 	_VGExit
.019cc5	a9 40		lda #$40			lda 	#$40 						; set type byte to zero
.019cc7	95 85		sta $85,x			sta 	XS_Type,x 					; which is the code for zero/float.
.019cc9	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; the last value to copy is the exponent.
.019ccb	95 84		sta $84,x			sta 	XS_Exponent,x
.019ccd	f0 1e		beq $019ced			beq 	_VGExit 					; if exponent is zero ... it's zero.
.019ccf	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; the sign bit is the top mantissa bit.
.019cd1	48		pha				pha
.019cd2	29 80		and #$80			and 	#$80
.019cd4	95 85		sta $85,x			sta 	XS_Type,x 					; this is the type byte.
.019cd6	68		pla				pla
.019cd7	09 80		ora #$80			ora 	#$80 						; set the MSB as you would expect.
.019cd9	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; so it's a normalised float.
.019cdb	80 10		bra $019ced			bra 	_VGExit
.019cdd					_VGString:
.019cdd	a9 02		lda #$02			lda 	#2 							; set type to 2, a string
.019cdf	95 85		sta $85,x			sta 	XS_Type,x
.019ce1	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; is the value there $0000
.019ce3	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019ce5	d0 06		bne $019ced			bne 	_VGExit 					; if not, exit.
.019ce7	85 25		sta $25				sta 	zNullString 				; make zNullString a 00 string.
.019ce9	a9 25		lda #$25			lda 	#zNullString
.019ceb	95 80		sta $80,x			sta 	XS_Mantissa,x 				; make it point to it.
.019ced					_VGExit:
.019ced	7a		ply				ply
.019cee	60		rts				rts
.019cef					VariableSet:
.019cef	b5 85		lda $85,x			lda 	XS_Type,x 					; is the result a string
.019cf1	29 02		and #$02			and 	#2 							; if so, it has to be
.019cf3	d0 4b		bne $019d40			bne 	_VSString
.019cf5	a5 24		lda $24				lda 	zVarType 					; if type is $ there's an error.
.019cf7	c9 b7		cmp #$b7			cmp 	#token_Dollar
.019cf9	f0 42		beq $019d3d			beq 	_VSBadType
.019cfb	c9 bb		cmp #$bb			cmp 	#token_Percent 				; type convert to float/int
.019cfd	f0 05		beq $019d04			beq 	_VSMakeInt
.019cff	20 65 a2	jsr $01a265			jsr 	FPUToFloat
.019d02	80 03		bra $019d07			bra 	_VSCopy
.019d04					_VSMakeInt:
.019d04	20 b1 a2	jsr $01a2b1			jsr 	FPUToInteger
.019d07					_VSCopy:
.019d07	5a		phy				phy
.019d08	a0 00		ldy #$00			ldy 	#0 							; copy mantissa to target.
.019d0a	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019d0c	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019d0e	c8		iny				iny
.019d0f	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019d11	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019d13	c8		iny				iny
.019d14	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019d16	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019d18	c8		iny				iny
.019d19	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019d1b	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019d1d	a5 24		lda $24				lda 	zVarType 					; if target is integer, alrady done.
.019d1f	c9 bb		cmp #$bb			cmp 	#token_Percent
.019d21	f0 18		beq $019d3b			beq 	_VSExit
.019d23	b5 85		lda $85,x			lda 	XS_Type,x 					; get the sign bit into carry flag.
.019d25	0a		asl a				asl 	a
.019d26	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; shift the sign into the mantissa high.
.019d28	08		php				php
.019d29	0a		asl a				asl 	a
.019d2a	28		plp				plp
.019d2b	6a		ror a				ror 	a
.019d2c	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019d2e	c8		iny				iny
.019d2f	b5 84		lda $84,x			lda 	XS_Exponent,x 				; copy the exponent in
.019d31	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019d33	34 85		bit $85,x			bit 	XS_Type,x 					; if the result is non zero
.019d35	50 04		bvc $019d3b			bvc 	_VSExit
.019d37	a9 00		lda #$00			lda 	#00 						; zero exponent indicating 0.
.019d39	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019d3b					_VSExit:
.019d3b	7a		ply				ply
.019d3c	60		rts				rts
.019d3d					_VSBadType:
.019d3d	4c 5a 85	jmp $01855a			jmp 	TypeError
.019d40					_VSString:
.019d40	a5 24		lda $24				lda 	zVarType 					; type must be $
.019d42	c9 b7		cmp #$b7			cmp 	#token_Dollar
.019d44	d0 f7		bne $019d3d			bne 	_VSBadType
.019d46	da		phx				phx
.019d47	5a		phy				phy
.019d48	20 b8 98	jsr $0198b8			jsr 	StringConcrete 				; concrete the string in the mantissa -> AX
.019d4b	a0 01		ldy #$01			ldy 	#1 							; save high byte
.019d4d	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019d4f	88		dey				dey 								; save low byte
.019d50	8a		txa				txa
.019d51	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019d53	7a		ply				ply 								; and exit.
.019d54	fa		plx				plx
.019d55	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.019d56					MulInteger32:
.019d56	b5 80		lda $80,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.019d58	95 8c		sta $8c,x			sta 	XS3_Mantissa,x
.019d5a	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019d5c	95 8d		sta $8d,x			sta 	XS3_Mantissa+1,x
.019d5e	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019d60	95 8e		sta $8e,x			sta 	XS3_Mantissa+2,x
.019d62	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019d64	95 8f		sta $8f,x			sta 	XS3_Mantissa+3,x
.019d66	a9 00		lda #$00			lda 	#0
.019d68	95 80		sta $80,x			sta 	XS_Mantissa+0,x 				; zero +0
.019d6a	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019d6c	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019d6e	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019d70					_BFMMultiply:
.019d70	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.019d72	29 01		and #$01			and 	#1
.019d74	f0 03		beq $019d79			beq 	_BFMNoAdd
.019d76	20 04 94	jsr $019404			jsr 	AddInteger32
.019d79					_BFMNoAdd:
.019d79	16 86		asl $86,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.019d7b	36 87		rol $87,x			rol 	XS2_Mantissa+1,x
.019d7d	36 88		rol $88,x			rol 	XS2_Mantissa+2,x
.019d7f	36 89		rol $89,x			rol 	XS2_Mantissa+3,x
.019d81	56 8f		lsr $8f,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.019d83	76 8e		ror $8e,x			ror 	XS3_Mantissa+2,x
.019d85	76 8d		ror $8d,x			ror 	XS3_Mantissa+1,x
.019d87	76 8c		ror $8c,x			ror 	XS3_Mantissa,x
.019d89	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.019d8b	15 8d		ora $8d,x			ora 	XS3_Mantissa+1,x
.019d8d	15 8e		ora $8e,x			ora 	XS3_Mantissa+2,x
.019d8f	15 8f		ora $8f,x			ora 	XS3_Mantissa+3,x
.019d91	d0 dd		bne $019d70			bne 	_BFMMultiply
.019d93	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.019d94					DivInteger32:
.019d94	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; check for /0
.019d96	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.019d98	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.019d9a	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.019d9c	d0 14		bne $019db2			bne 	_BFDOkay
.019d9e	20 79 85	jsr $018579			jsr ERR_Handler
>019da1	44 69 76 69 73 69 6f 6e			.text "Division by Zero",0
>019da9	20 62 79 20 5a 65 72 6f 00
.019db2					_BFDOkay:
.019db2	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.019db4	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.019db6	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.019db8	85 1c		sta $1c				sta 	zLTemp1+2
.019dba	85 1d		sta $1d				sta 	zLTemp1+3
.019dbc	8d 9e 03	sta $039e			sta 	SignCount 					; Count of signs.
.019dbf	20 16 9e	jsr $019e16			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.019dc2	da		phx				phx
.019dc3	e8		inx				inx
.019dc4	e8		inx				inx
.019dc5	e8		inx				inx
.019dc6	e8		inx				inx
.019dc7	e8		inx				inx
.019dc8	e8		inx				inx
.019dc9	20 16 9e	jsr $019e16			jsr 	CheckIntegerNegate
.019dcc	fa		plx				plx
.019dcd	5a		phy				phy 								; Y is the counter
.019dce	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.019dd0					_BFDLoop:
.019dd0	16 80		asl $80,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.019dd2	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.019dd4	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.019dd6	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.019dd8	26 1a		rol $1a				rol 	zLTemp1
.019dda	26 1b		rol $1b				rol 	zLTemp1+1
.019ddc	26 1c		rol $1c				rol 	zLTemp1+2
.019dde	26 1d		rol $1d				rol 	zLTemp1+3
.019de0	38		sec				sec
.019de1	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.019de3	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.019de5	48		pha				pha
.019de6	a5 1b		lda $1b				lda 	zLTemp1+1
.019de8	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.019dea	48		pha				pha
.019deb	a5 1c		lda $1c				lda 	zLTemp1+2
.019ded	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.019def	48		pha				pha
.019df0	a5 1d		lda $1d				lda 	zLTemp1+3
.019df2	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.019df4	90 13		bcc $019e09			bcc 	_BFDNoAdd
.019df6	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.019df8	68		pla				pla
.019df9	85 1c		sta $1c				sta 	zLTemp1+2
.019dfb	68		pla				pla
.019dfc	85 1b		sta $1b				sta 	zLTemp1+1
.019dfe	68		pla				pla
.019dff	85 1a		sta $1a				sta 	zLTemp1+0
.019e01	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.019e03	09 01		ora #$01			ora 	#1
.019e05	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019e07	80 03		bra $019e0c			bra 	_BFDNext
.019e09					_BFDNoAdd:
.019e09	68		pla				pla 								; Throw away the intermediate calculations
.019e0a	68		pla				pla
.019e0b	68		pla				pla
.019e0c					_BFDNext:
.019e0c	88		dey				dey
.019e0d	d0 c1		bne $019dd0			bne 	_BFDLoop
.019e0f	7a		ply				ply 								; restore Y and exit
.019e10	4e 9e 03	lsr $039e			lsr 	SignCount 					; if sign count odd,
.019e13	b0 06		bcs $019e1b			bcs		IntegerNegateAlways 			; negate the result
.019e15	60		rts				rts
.019e16					CheckIntegerNegate:
.019e16	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019e18	30 01		bmi $019e1b			bmi 	IntegerNegateAlways
.019e1a	60		rts				rts
.019e1b					IntegerNegateAlways:
.019e1b	ee 9e 03	inc $039e			inc 	SignCount
.019e1e	38		sec				sec
.019e1f	a9 00		lda #$00			lda 	#0
.019e21	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.019e23	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019e25	a9 00		lda #$00			lda 	#0
.019e27	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.019e29	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019e2b	a9 00		lda #$00			lda 	#0
.019e2d	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.019e2f	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019e31	a9 00		lda #$00			lda 	#0
.019e33	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.019e35	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019e37	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.019e38					INTToString:
.019e38	48		pha				pha
.019e39	5a		phy				phy
.019e3a	b5 83		lda $83,x			lda 		XS_Mantissa+3,x 		; check -ve
.019e3c	10 08		bpl $019e46			bpl 		_ITSNotMinus
.019e3e	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.019e40	20 da 9e	jsr $019eda			jsr 		ITSOutputCharacter
.019e43	20 1b 9e	jsr $019e1b			jsr 		IntegerNegateAlways 	; negate the number.
.019e46					_ITSNotMinus:
.019e46	a9 00		lda #$00			lda 		#0
.019e48	8d 9a 03	sta $039a			sta 		NumSuppress 			; clear the suppression flag.
.019e4b	8a		txa				txa 								; use Y for the mantissa index.
.019e4c	a8		tay				tay
.019e4d	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.019e4f					_ITSNextSubtractor:
.019e4f	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.019e51	8d 9b 03	sta $039b			sta 		NumConvCount
.019e54					_ITSSubtract:
.019e54	38		sec				sec
.019e55	b9 80 00	lda $0080,y			lda 		XS_Mantissa,y 			; subtract number and push on stack
.019e58	ff b6 9e 01	sbc $019eb6,x			sbc 		_ITSSubtractors+0,x
.019e5c	48		pha				pha
.019e5d	b9 81 00	lda $0081,y			lda 		XS_Mantissa+1,y
.019e60	ff b7 9e 01	sbc $019eb7,x			sbc 		_ITSSubtractors+1,x
.019e64	48		pha				pha
.019e65	b9 82 00	lda $0082,y			lda 		XS_Mantissa+2,y
.019e68	ff b8 9e 01	sbc $019eb8,x			sbc 		_ITSSubtractors+2,x
.019e6c	48		pha				pha
.019e6d	b9 83 00	lda $0083,y			lda 		XS_Mantissa+3,y
.019e70	ff b9 9e 01	sbc $019eb9,x			sbc 		_ITSSubtractors+3,x
.019e74	90 14		bcc $019e8a			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.019e76	99 83 00	sta $0083,y			sta 		XS_Mantissa+3,y 		; save subtract off stack
.019e79	68		pla				pla
.019e7a	99 82 00	sta $0082,y			sta 		XS_Mantissa+2,y
.019e7d	68		pla				pla
.019e7e	99 81 00	sta $0081,y			sta 		XS_Mantissa+1,y
.019e81	68		pla				pla
.019e82	99 80 00	sta $0080,y			sta 		XS_Mantissa+0,y
.019e85	ee 9b 03	inc $039b			inc 		NumConvCount 			; bump count.
.019e88	80 ca		bra $019e54			bra 		_ITSSubtract 			; go round again.
.019e8a					_ITSCantSubtract:
.019e8a	68		pla				pla 								; throw away interim answers
.019e8b	68		pla				pla
.019e8c	68		pla				pla
.019e8d	ad 9b 03	lda $039b			lda 		NumConvCount 			; if not zero then no suppression check
.019e90	c9 30		cmp #$30			cmp 		#"0"
.019e92	d0 05		bne $019e99			bne 		_ITSOutputDigit
.019e94	ad 9a 03	lda $039a			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.019e97	10 09		bpl $019ea2			bpl	 		_ITSGoNextSubtractor
.019e99					_ITSOutputDigit:
.019e99	ce 9a 03	dec $039a			dec 		NumSuppress 			; suppression check will be non-zero.
.019e9c	ad 9b 03	lda $039b			lda 		NumConvCount 			; count of subtractions
.019e9f	20 da 9e	jsr $019eda			jsr 		ITSOutputCharacter 		; output it.
.019ea2					_ITSGoNextSubtractor:
.019ea2	e8		inx				inx 								; next dword
.019ea3	e8		inx				inx
.019ea4	e8		inx				inx
.019ea5	e8		inx				inx
.019ea6	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.019ea8	d0 a5		bne $019e4f			bne 		_ITSNextSubtractor 		; do all the subtractors.
.019eaa	98		tya				tya 								; X is back as the mantissa index
.019eab	aa		tax				tax
.019eac	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.019eae	09 30		ora #$30			ora 		#"0"
.019eb0	20 da 9e	jsr $019eda			jsr 		ITSOutputCharacter
.019eb3	7a		ply				ply 								; and exit
.019eb4	68		pla				pla
.019eb5	60		rts				rts
.019eb6					_ITSSubtractors:
>019eb6	00 ca 9a 3b					.dword 		1000000000
>019eba	00 e1 f5 05					.dword 		100000000
>019ebe	80 96 98 00					.dword 		10000000
>019ec2	40 42 0f 00					.dword 		1000000
>019ec6	a0 86 01 00					.dword 		100000
>019eca	10 27 00 00					.dword 		10000
>019ece	e8 03 00 00					.dword 		1000
>019ed2	64 00 00 00					.dword 		100
>019ed6	0a 00 00 00					.dword 		10
.019eda					_ITSSubtractorsEnd:
.019eda					ITSOutputCharacter:
.019eda	48		pha				pha
.019edb	da		phx				phx
.019edc	ae 14 03	ldx $0314			ldx 	NumBufX 					; save digit
.019edf	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.019ee2	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.019ee4	9d 16 03	sta $0316,x			sta 	Num_Buffer+1,x
.019ee7	ee 14 03	inc $0314			inc 	NumBufX						; bump pointer.
.019eea	fa		plx				plx
.019eeb	68		pla				pla
.019eec	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.019eed					IntFromString:
.019eed	a0 00		ldy #$00			ldy 	#0
.019eef	8c 9c 03	sty $039c			sty 	ExpTemp 					; this is the converted digit count.
.019ef2					IntFromStringY:
.019ef2	48		pha				pha
.019ef3	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.019ef5	95 80		sta $80,x			sta 	XS_Mantissa,x
.019ef7	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019ef9	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019efb	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019efd	a9 01		lda #$01			lda 	#1
.019eff	95 85		sta $85,x			sta 	XS_Type,x
.019f01					_IFSLoop:
.019f01	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.019f03	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.019f05	90 4e		bcc $019f55			bcc 	_IFSExit
.019f07	c9 3a		cmp #$3a			cmp 	#"9"+1
.019f09	b0 4a		bcs $019f55			bcs 	_IFSExit
.019f0b	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.019f0d	c9 0c		cmp #$0c			cmp 	#12
.019f0f	b0 4e		bcs $019f5f			bcs 	_IFSOverflow
.019f11	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.019f13	48		pha				pha
.019f14	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019f16	48		pha				pha
.019f17	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019f19	48		pha				pha
.019f1a	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019f1c	48		pha				pha
.019f1d	20 74 9f	jsr $019f74			jsr 	IFSX1ShiftLeft 				; double
.019f20	20 74 9f	jsr $019f74			jsr 	IFSX1ShiftLeft 				; x 4
.019f23	18		clc				clc 								; add saved value x 5
.019f24	68		pla				pla
.019f25	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.019f27	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019f29	68		pla				pla
.019f2a	75 81		adc $81,x			adc 	XS_Mantissa+1,x
.019f2c	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019f2e	68		pla				pla
.019f2f	75 82		adc $82,x			adc 	XS_Mantissa+2,x
.019f31	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019f33	68		pla				pla
.019f34	75 83		adc $83,x			adc 	XS_Mantissa+3,x
.019f36	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019f38	20 74 9f	jsr $019f74			jsr 	IFSX1ShiftLeft 				; x 10
.019f3b	ee 9c 03	inc $039c			inc 	ExpTemp 					; bump count of digits processed.
.019f3e	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.019f40	29 0f		and #$0f			and 	#15
.019f42	c8		iny				iny
.019f43	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.019f45	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019f47	90 b8		bcc $019f01			bcc 	_IFSLoop
.019f49	f6 81		inc $81,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.019f4b	d0 b4		bne $019f01			bne 	_IFSLoop
.019f4d	f6 82		inc $82,x			inc 	XS_Mantissa+2,x
.019f4f	d0 b0		bne $019f01			bne 	_IFSLoop
.019f51	f6 83		inc $83,x			inc 	XS_Mantissa+3,x
.019f53	80 ac		bra $019f01			bra 	_IFSLoop
.019f55					_IFSExit:
.019f55	98		tya				tya 								; get offset
.019f56					_IFSOkay:
.019f56	38		sec				sec
.019f57	ad 9c 03	lda $039c			lda 	ExpTemp
.019f5a	f0 01		beq $019f5d			beq 	_IFSSkipFail
.019f5c	18		clc				clc
.019f5d					_IFSSkipFail:
.019f5d	68		pla				pla 								; and exit.
.019f5e	60		rts				rts
.019f5f					_IFSOverflow:
.019f5f	20 79 85	jsr $018579			jsr 	ERR_Handler
>019f62	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>019f6a	20 6f 76 65 72 66 6c 6f 77 00
.019f74					IFSX1ShiftLeft:
.019f74	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.019f76	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.019f78	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.019f7a	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.019f7c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.019f7d					FPSubtract:
.019f7d	48		pha				pha
.019f7e	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.019f80	49 80		eor #$80			eor 	#$80
.019f82	95 8b		sta $8b,x			sta 	XS2_Type,x
.019f84	68		pla				pla 								; --- and fall through ---
.019f85					FPAdd:
.019f85	48		pha				pha
.019f86	b5 85		lda $85,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.019f88	d0 05		bne $019f8f			bne 	_FPA_NegativeLHS
.019f8a	20 a6 9f	jsr $019fa6			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.019f8d	68		pla				pla
.019f8e	60		rts				rts
.019f8f					_FPA_NegativeLHS:
.019f8f	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.019f91	49 80		eor #$80			eor 	#$80
.019f93	95 85		sta $85,x			sta 	XS_Type,x
.019f95	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of B and add
.019f97	49 80		eor #$80			eor 	#$80
.019f99	95 8b		sta $8b,x			sta 	XS2_Type,x
.019f9b	20 a6 9f	jsr $019fa6			jsr 	FPAdd_Worker 				; do the add calculation.
.019f9e	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 back
.019fa0	49 80		eor #$80			eor 	#$80
.019fa2	95 85		sta $85,x			sta 	XS_Type,x
.019fa4	68		pla				pla
.019fa5	60		rts				rts
.019fa6					FPAdd_Worker:
.019fa6	34 8b		bit $8b,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.019fa8	70 07		bvs $019fb1			bvs 	_FPAWExit 					; no change.
.019faa	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.019fac	50 07		bvc $019fb5			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.019fae	20 23 a2	jsr $01a223			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.019fb1					_FPAWExit:
.019fb1	20 92 a2	jsr $01a292			jsr 	FPUNormalise 				; normalise the result.
.019fb4	60		rts				rts
.019fb5					_FPAWMakeSame:
.019fb5	b5 84		lda $84,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.019fb7	38		sec				sec
.019fb8	f5 8a		sbc $8a,x			sbc	 	XS2_Exponent,x 				; using subtraction
.019fba	f0 16		beq $019fd2			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.019fbc	da		phx				phx 								; save X
.019fbd	90 06		bcc $019fc5			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.019fbf	e8		inx				inx
.019fc0	e8		inx				inx
.019fc1	e8		inx				inx
.019fc2	e8		inx				inx
.019fc3	e8		inx				inx
.019fc4	e8		inx				inx
.019fc5					_FPAWShiftA:
.019fc5	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.019fc7	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.019fc9	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.019fcb	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.019fcd	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.019fcf	fa		plx				plx 								; restore original X
.019fd0	80 e3		bra $019fb5			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.019fd2					_FPAW_DoArithmetic:
.019fd2	34 8b		bit $8b,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.019fd4	30 28		bmi $019ffe			bmi 	_FPAW_BNegative
.019fd6	18		clc				clc
.019fd7	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019fd9	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.019fdb	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019fdd	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019fdf	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.019fe1	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019fe3	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019fe5	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.019fe7	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019fe9	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019feb	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.019fed	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019fef	90 c0		bcc $019fb1			bcc 	_FPAWExit 					; no carry.
.019ff1	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.019ff3	38		sec				sec
.019ff4	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.019ff6	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.019ff8	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.019ffa	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.019ffc	80 b3		bra $019fb1			bra 	_FPAWExit
.019ffe					_FPAW_BNegative:
.019ffe	38		sec				sec
.019fff	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01a001	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.01a003	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a005	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a007	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.01a009	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a00b	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a00d	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.01a00f	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a011	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a013	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.01a015	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a017	b0 09		bcs $01a022			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.01a019	20 49 a2	jsr $01a249			jsr 	FPUNegateInteger			; negate the mantissa
.01a01c	b5 85		lda $85,x			lda 	XS_Type,x 					; flip result sign
.01a01e	49 80		eor #$80			eor 	#$80
.01a020	95 85		sta $85,x			sta 	XS_Type,x
.01a022					_FPAWGoExit:
.01a022	4c b1 9f	jmp $019fb1			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.01a025					FPD_IsDivZero:
.01a025	20 79 85	jsr $018579			jsr ERR_Handler
>01a028	44 69 76 69 73 69 6f 6e			.text "Division by zero",0
>01a030	20 62 79 20 7a 65 72 6f 00
.01a039					FPDivide:
.01a039	48		pha				pha
.01a03a	5a		phy				phy
.01a03b	34 8b		bit $8b,x			bit 	XS2_Type,x 					; check if division by zero
.01a03d	70 e6		bvs $01a025			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.01a03f	34 85		bit $85,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.01a041	f0 03		beq $01a046			beq 	_FPDCalculateExp
.01a043					_FPD_Exit:
.01a043	7a		ply				ply
.01a044	68		pla				pla
.01a045	60		rts				rts
.01a046					_FPDCalculateExp:
.01a046	b5 8a		lda $8a,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.01a048	49 ff		eor #$ff			eor 	#$FF
.01a04a	1a		inc a				inc 	a
.01a04b	95 8a		sta $8a,x			sta 	XS2_Exponent,x
.01a04d	20 1d a1	jsr $01a11d			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.01a050	18		clc				clc 	 							; add 1 to the resulting exponent
.01a051	69 01		adc #$01			adc 	#1
.01a053	b0 54		bcs $01a0a9			bcs 	_FPD_Overflow 				; which can overflow.
.01a055	95 84		sta $84,x			sta 	XS_Exponent,x
.01a057	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.01a059	85 1a		sta $1a				sta 	zLTemp1+0
.01a05b	85 1b		sta $1b				sta 	zLTemp1+1
.01a05d	85 1c		sta $1c				sta 	zLTemp1+2
.01a05f	85 1d		sta $1d				sta 	zLTemp1+3
.01a061	a0 20		ldy #$20			ldy 	#32 						; times round.
.01a063					_FPD_Loop:
.01a063	38		sec				sec 								; calculate X1-X2 stacking result because we might
.01a064	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; not save it.
.01a066	f5 86		sbc $86,x			sbc 	XS2_Mantissa,x
.01a068	48		pha				pha
.01a069	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a06b	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.01a06d	48		pha				pha
.01a06e	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a070	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.01a072	48		pha				pha
.01a073	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a075	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.01a077	90 13		bcc $01a08c			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.01a079	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; save results out to A
.01a07b	68		pla				pla
.01a07c	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a07e	68		pla				pla
.01a07f	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a081	68		pla				pla
.01a082	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a084	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.01a086	09 80		ora #$80			ora 	#$80
.01a088	85 1d		sta $1d				sta 	zLTemp1+3
.01a08a	80 03		bra $01a08f			bra 	_FPD_Rotates
.01a08c					_FPD_NoSubtract:
.01a08c	68		pla				pla 								; throw away unwanted results
.01a08d	68		pla				pla
.01a08e	68		pla				pla
.01a08f					_FPD_Rotates:
.01a08f	56 89		lsr $89,x			lsr 	3+XS2_Mantissa,x
.01a091	76 88		ror $88,x			ror 	2+XS2_Mantissa,x
.01a093	76 87		ror $87,x			ror 	1+XS2_Mantissa,x
.01a095	76 86		ror $86,x			ror 	0+XS2_Mantissa,x
.01a097	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.01a099	26 1b		rol $1b				rol 	zLTemp1+1
.01a09b	26 1c		rol $1c				rol 	zLTemp1+2
.01a09d	26 1d		rol $1d				rol 	zLTemp1+3
.01a09f	90 02		bcc $01a0a3			bcc 	_FPD_NoCarry
.01a0a1	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.01a0a3					_FPD_NoCarry:
.01a0a3	88		dey				dey 								; do 32 times
.01a0a4	d0 bd		bne $01a063			bne 	_FPD_Loop
.01a0a6	4c 01 a1	jmp $01a101			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.01a0a9					_FPD_Overflow:
.01a0a9	4c ef a2	jmp $01a2ef			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.01a0ac					FPMultiply:
.01a0ac	48		pha				pha
.01a0ad	5a		phy				phy
.01a0ae	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.01a0b0	70 07		bvs $01a0b9			bvs 	_FPM_Exit
.01a0b2	34 8b		bit $8b,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.01a0b4	50 06		bvc $01a0bc			bvc 	_FPM_CalcExponent
.01a0b6	20 23 a2	jsr $01a223			jsr 	FPUCopyX2ToX1
.01a0b9					_FPM_Exit:
.01a0b9	7a		ply				ply
.01a0ba	68		pla				pla
.01a0bb	60		rts				rts
.01a0bc					_FPM_CalcExponent:
.01a0bc	18		clc				clc
.01a0bd	20 1d a1	jsr $01a11d			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.01a0c0	95 84		sta $84,x			sta 	XS_Exponent,x 				; save the result.
.01a0c2	a9 00		lda #$00			lda 	#0
.01a0c4	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.01a0c6	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.01a0c8	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.01a0ca	85 1d		sta $1d				sta 	zLTemp1+3
.01a0cc	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.01a0ce					_FPM_Loop:
.01a0ce	b5 80		lda $80,x			lda 	XS_Mantissa,x				; check LSB of long product
.01a0d0	29 01		and #$01			and 	#1
.01a0d2	18		clc				clc 								; clear carry for the long rotate.
.01a0d3	f0 19		beq $01a0ee			beq 	_FPM_NoAddition
.01a0d5	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.01a0d6	a5 1a		lda $1a				lda 	zLTemp1+0
.01a0d8	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.01a0da	85 1a		sta $1a				sta 	zLTemp1+0
.01a0dc	a5 1b		lda $1b				lda 	zLTemp1+1
.01a0de	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.01a0e0	85 1b		sta $1b				sta 	zLTemp1+1
.01a0e2	a5 1c		lda $1c				lda 	zLTemp1+2
.01a0e4	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.01a0e6	85 1c		sta $1c				sta 	zLTemp1+2
.01a0e8	a5 1d		lda $1d				lda 	zLTemp1+3
.01a0ea	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.01a0ec	85 1d		sta $1d				sta 	zLTemp1+3
.01a0ee					_FPM_NoAddition:
.01a0ee	66 1d		ror $1d				ror 	3+zLTemp1
.01a0f0	66 1c		ror $1c				ror 	2+zLTemp1
.01a0f2	66 1b		ror $1b				ror 	1+zLTemp1
.01a0f4	66 1a		ror $1a				ror 	0+zLTemp1
.01a0f6	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.01a0f8	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a0fa	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a0fc	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a0fe	88		dey				dey
.01a0ff	d0 cd		bne $01a0ce			bne 	_FPM_Loop 					; do this 32 times.
.01a101					FPM_CopySignNormalize:
.01a101	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.01a103	95 80		sta $80,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.01a105	a5 1b		lda $1b				lda 	zLTemp1+1
.01a107	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a109	a5 1c		lda $1c				lda 	zLTemp1+2
.01a10b	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a10d	a5 1d		lda $1d				lda 	zLTemp1+3
.01a10f	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a111	b5 85		lda $85,x			lda 	XS_Type,x 					; sign is xor of signs
.01a113	55 8b		eor $8b,x			eor 	XS2_Type,x
.01a115	95 85		sta $85,x			sta 	XS_Type,x
.01a117	20 92 a2	jsr $01a292			jsr 	FPUNormalise 				; normalise and exit.
.01a11a	7a		ply				ply
.01a11b	68		pla				pla
.01a11c	60		rts				rts
.01a11d					FPCalculateExponent:
.01a11d	18		clc				clc
.01a11e	b5 84		lda $84,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.01a120	75 8a		adc $8a,x			adc 	XS2_Exponent,x
.01a122	b0 08		bcs $01a12c			bcs 	_FPCECarry 					; carry out ?
.01a124	10 03		bpl $01a129			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.01a126	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.01a128	60		rts				rts
.01a129					_FPCEExpZero:
.01a129	a9 00		lda #$00			lda 	#0
.01a12b	60		rts				rts
.01a12c					_FPCECarry:
.01a12c	30 03		bmi $01a131			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.01a12e	09 80		ora #$80			ora 	#$80 						; put in right range
.01a130	60		rts				rts
.01a131					_FPCEOverflow:
.01a131	4c ef a2	jmp $01a2ef			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.01a134					FPFractionalPart:
.01a134	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.01a136	38		sec				sec 								; this flag tells us to keep the fractional part
.01a137	30 0d		bmi $01a146			bmi 	FPGetPart
.01a139	60		rts				rts
.01a13a					FPIntegerPart:
.01a13a	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.01a13c	18		clc				clc 								; this flag says keep the integer part.
.01a13d	30 07		bmi $01a146			bmi 	FPGetPart 					; -ve exponents are 0..127
.01a13f	48		pha				pha
.01a140	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.01a142	95 85		sta $85,x			sta 	XS_Type,x
.01a144	68		pla				pla
.01a145	60		rts				rts
.01a146					FPGetPart:
.01a146	48		pha				pha
.01a147	5a		phy				phy 								; save Y
.01a148	08		php				php 								; save action
.01a149	34 85		bit $85,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.01a14b	70 59		bvs $01a1a6			bvs 	_FPGP_Exit 					; then do nothing.
.01a14d	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.01a14f	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.01a151	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.01a153	85 1c		sta $1c				sta 	zLTemp1+2
.01a155	85 1d		sta $1d				sta 	zLTemp1+3
.01a157	b5 84		lda $84,x			lda 	XS_Exponent,x				; the number of shifts.
.01a159	38		sec				sec
.01a15a	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.01a15c	f0 12		beq $01a170			beq 	_FPGP_NoShift 				; ... if any
.01a15e	c9 20		cmp #$20			cmp 	#32
.01a160	90 02		bcc $01a164			bcc 	_FPGP_NotMax
.01a162	a9 20		lda #$20			lda 	#32 						; max of 32.
.01a164					_FPGP_NotMax:
.01a164	a8		tay				tay 								; Y is the mask shift count.
.01a165					_FPGP_ShiftMask:
.01a165	46 1d		lsr $1d				lsr 	3+zLTemp1
.01a167	66 1c		ror $1c				ror 	2+zLTemp1
.01a169	66 1b		ror $1b				ror 	1+zLTemp1
.01a16b	66 1a		ror $1a				ror 	0+zLTemp1
.01a16d	88		dey				dey
.01a16e	d0 f5		bne $01a165			bne 	_FPGP_ShiftMask
.01a170					_FPGP_NoShift:
.01a170	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.01a172	8e 9c 03	stx $039c			stx 	ExpTemp						; save X
.01a175					_FPGP_MaskLoop:
.01a175	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.01a178	28		plp				plp 								; if CC we keep the top part, so we
.01a179	08		php				php		 							; flip the mask.
.01a17a	b0 02		bcs $01a17e			bcs		_FPGP_NoFlip
.01a17c	49 ff		eor #$ff			eor 	#$FF
.01a17e					_FPGP_NoFlip:
.01a17e	35 80		and $80,x			and 	XS_Mantissa,x 				; and into the mantissa.
.01a180	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a182	e8		inx				inx
.01a183	c8		iny				iny
.01a184	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.01a186	d0 ed		bne $01a175			bne 	_FPGP_MaskLoop
.01a188	ae 9c 03	ldx $039c			ldx 	ExpTemp						; restore X
.01a18b	28		plp				plp
.01a18c	08		php				php 								; get action flag on the stack
.01a18d	90 04		bcc $01a193			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.01a18f	a9 00		lda #$00			lda 	#0
.01a191	95 85		sta $85,x			sta 	XS_Type,x
.01a193					_FPGP_NotFractional:
.01a193	b5 80		lda $80,x			lda 	XS_Mantissa,x 						; check if \1 zero
.01a195	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.01a197	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01a199	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01a19b	f0 05		beq $01a1a2			beq 	_FPGP_Zero 					; if zero, return zero
.01a19d	20 92 a2	jsr $01a292			jsr 	FPUNormalise
.01a1a0	80 04		bra $01a1a6			bra 	_FPGP_Exit 					; and exit
.01a1a2					_FPGP_Zero:
.01a1a2	a9 40		lda #$40			lda 	#$40 						; set zero flag
.01a1a4	95 85		sta $85,x			sta 	XS_Type,x
.01a1a6					_FPGP_Exit:
.01a1a6	68		pla				pla 								; throw saved action flag.
.01a1a7	7a		ply				ply
.01a1a8	68		pla				pla
.01a1a9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.01a1aa					FPCompare:
.01a1aa	20 eb a1	jsr $01a1eb			jsr 	FPFastCompare 				; fast compare try first
.01a1ad	b0 3b		bcs $01a1ea			bcs 	_FPCExit 					; that worked.
.01a1af	b5 84		lda $84,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.01a1b1	48		pha				pha
.01a1b2	b5 8a		lda $8a,x			lda 	XS2_Exponent,x
.01a1b4	48		pha				pha
.01a1b5	20 7d 9f	jsr $019f7d			jsr 	FPSubtract 					; calculate X1-X2
.01a1b8	34 85		bit $85,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.01a1ba	70 2a		bvs $01a1e6			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.01a1bc	68		pla				pla
.01a1bd	8d 9c 03	sta $039c			sta 	ExpTemp						; save first exponent in temporary reg.
.01a1c0	68		pla				pla
.01a1c1	38		sec				sec
.01a1c2	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; calculate AX-BX
.01a1c5	70 14		bvs $01a1db			bvs 	_FPCNotEqual				; overflow, can't be equal.
.01a1c7	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.01a1c8	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.01a1ca	b0 0f		bcs $01a1db			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.01a1cc	38		sec				sec
.01a1cd	ad 9c 03	lda $039c			lda 	ExpTemp 					; get one of the exponents back.
.01a1d0	e9 12		sbc #$12			sbc 	#18 						; allow for 2^18 error, relatively.
.01a1d2	b0 02		bcs $01a1d6			bcs 	_FPCNotRange 				; keep in range.
.01a1d4	a9 01		lda #$01			lda 	#1
.01a1d6					_FPCNotRange:
.01a1d6	38		sec				sec
.01a1d7	f5 84		sbc $84,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.01a1d9	b0 0d		bcs $01a1e8			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.01a1db					_FPCNotEqual:
.01a1db	b5 85		lda $85,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.01a1dd	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.01a1df	f0 02		beq $01a1e3			beq 	_FPCNE2
.01a1e1	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.01a1e3	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.01a1e4	80 04		bra $01a1ea			bra 	_FPCExit
.01a1e6					_FPCPullZero:
.01a1e6	68		pla				pla 								; throw saved exponents
.01a1e7	68		pla				pla
.01a1e8					_FPCZero:
.01a1e8	a9 00		lda #$00			lda 	#0 							; and return zero
.01a1ea					_FPCExit:
.01a1ea	60		rts				rts
.01a1eb					FPFastCompare:
.01a1eb	34 85		bit $85,x			bit 	XS_Type,x 					; n1 is zero.
.01a1ed	70 23		bvs $01a212			bvs 	_FPFLeftZero
.01a1ef	34 8b		bit $8b,x			bit 	XS2_Type,x 					; n2 is zero
.01a1f1	b5 85		lda $85,x			lda 	XS_Type,x 					; if so, return sign bit of 1 (n-0)
.01a1f3	70 25		bvs $01a21a			bvs 	_FPFSignBit
.01a1f5	55 8b		eor $8b,x			eor 	XS2_Type,x 					; eor 2 type bits. now know both non-zero
.01a1f7	0a		asl a				asl 	a 							; put in CS if different.
.01a1f8	b5 85		lda $85,x			lda 	XS_Type,x 					; if signs different return sign of first
.01a1fa	b0 1e		bcs $01a21a			bcs 	_FPFSignBit
.01a1fc	38		sec				sec 								; same sign and not-zero. compare exponents
.01a1fd	b5 84		lda $84,x			lda 	XS_Exponent,x 				; compare exponents. if the same, then fail.
.01a1ff	f5 8a		sbc $8a,x			sbc 	XS2_Exponent,x 				; e.g. we have to do it via subtraction.
.01a201	f0 09		beq $01a20c			beq 	_FPNoFastCompare
.01a203	6a		ror a				ror 	a 							; put carry into bit 7.
.01a204	34 85		bit $85,x			bit 	XS_Type,X 					; if it is +x then flip it.
.01a206	30 02		bmi $01a20a			bmi		_FPFCNotMinus
.01a208	49 80		eor #$80			eor 	#$80
.01a20a					_FPFCNotMinus:
.01a20a	80 0e		bra $01a21a			bra		_FPFSignBit
.01a20c					_FPNoFastCompare:
.01a20c	18		clc				clc
.01a20d	60		rts				rts
.01a20e					_FPFZero:
.01a20e	a9 00		lda #$00			lda 	#0
.01a210					_FPFExitSet:
.01a210	38		sec				sec
.01a211	60		rts				rts
.01a212					_FPFLeftZero:
.01a212	34 8b		bit $8b,x			bit 	XS2_Type,x 					; if right is zero, return zero.
.01a214	70 f8		bvs $01a20e			bvs 	_FPFZero
.01a216	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip sign bit
.01a218	49 80		eor #$80			eor 	#$80						; return that as a sign.
.01a21a					_FPFSignBit:
.01a21a	0a		asl a				asl 	a
.01a21b	a9 01		lda #$01			lda 	#1
.01a21d	90 f1		bcc $01a210			bcc		_FPFExitSet
.01a21f	a9 ff		lda #$ff			lda 	#$FF
.01a221	38		sec				sec
.01a222	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.01a223					FPUCopyX2ToX1:
.01a223	48		pha				pha
.01a224	da		phx				phx
.01a225	5a		phy				phy
.01a226	a0 08		ldy #$08			ldy 	#8
.01a228	b5 86		lda $86,x	_FPUC21:lda 	XS2_Mantissa,x
.01a22a	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a22c	e8		inx				inx
.01a22d	88		dey				dey
.01a22e	10 f8		bpl $01a228			bpl 	_FPUC21
.01a230	7a		ply				ply
.01a231	fa		plx				plx
.01a232	68		pla				pla
.01a233	60		rts				rts
.01a234					FPUSetInteger:
.01a234	48		pha				pha
.01a235	95 80		sta $80,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.01a237	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.01a239	10 02		bpl $01a23d			bpl 	_FPUSIExtend
.01a23b	a9 ff		lda #$ff			lda 	#$FF
.01a23d					_FPUSIExtend:
.01a23d	95 81		sta $81,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.01a23f	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a241	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a243	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.01a245	95 85		sta $85,x			sta 	XS_Type,x
.01a247	68		pla				pla
.01a248	60		rts				rts
.01a249					FPUNegateInteger:
.01a249	48		pha				pha
.01a24a	38		sec				sec
.01a24b	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.01a24d	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.01a24f	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a251	a9 00		lda #$00			lda 	#0
.01a253	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.01a255	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a257	a9 00		lda #$00			lda 	#0
.01a259	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.01a25b	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a25d	a9 00		lda #$00			lda 	#0
.01a25f	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.01a261	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a263	68		pla				pla
.01a264	60		rts				rts
.01a265					FPUToFloat:
.01a265	48		pha				pha
.01a266	b5 85		lda $85,x			lda 	XS_Type,x					; exit if already float.
.01a268	29 0f		and #$0f			and 	#$0F
.01a26a	f0 24		beq $01a290			beq 	_FPUFExit
.01a26c	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.01a26e	95 85		sta $85,x			sta 	XS_Type,x
.01a270	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.01a272	95 84		sta $84,x			sta 	XS_Exponent,x 				; x mantissa.
.01a274	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.01a276	10 07		bpl $01a27f			bpl		_FPUFPositive
.01a278	20 49 a2	jsr $01a249			jsr 	FPUNegateInteger 			; negate the mantissa
.01a27b	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.01a27d	95 85		sta $85,x			sta 	XS_Type,x
.01a27f					_FPUFPositive:
.01a27f	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.01a281	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.01a283	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01a285	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01a287	d0 04		bne $01a28d			bne 	_FPUFNonZero
.01a289	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.01a28b	95 85		sta $85,x			sta 	XS_Type,x
.01a28d					_FPUFNonZero:
.01a28d	20 92 a2	jsr $01a292			jsr 	FPUNormalise 				; normalise the floating point.
.01a290					_FPUFExit:
.01a290	68		pla				pla
.01a291	60		rts				rts
.01a292					FPUNormalise:
.01a292	48		pha				pha
.01a293	34 85		bit $85,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.01a295	70 18		bvs $01a2af			bvs 	_FPUNExit
.01a297	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.01a299	f0 10		beq $01a2ab			beq 	_FPUNSetZero
.01a29b					_FPUNLoop:
.01a29b	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.01a29d	30 10		bmi $01a2af			bmi 	_FPUNExit 					; if so, we are normalised.
.01a29f	16 80		asl $80,x			asl 	0+XS_Mantissa+0,x
.01a2a1	36 81		rol $81,x			rol 	1+XS_Mantissa+0,x
.01a2a3	36 82		rol $82,x			rol 	2+XS_Mantissa+0,x
.01a2a5	36 83		rol $83,x			rol 	3+XS_Mantissa+0,x
.01a2a7	d6 84		dec $84,x			dec 	XS_Exponent,x 				; decrement exponent
.01a2a9	d0 f0		bne $01a29b			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.01a2ab					_FPUNSetZero:
.01a2ab	a9 40		lda #$40			lda 	#$40
.01a2ad	95 85		sta $85,x			sta 	XS_Type,x 					; the result is now zero.
.01a2af					_FPUNExit:
.01a2af	68		pla				pla
.01a2b0	60		rts				rts
.01a2b1					FPUToInteger:
.01a2b1	48		pha				pha
.01a2b2	b5 85		lda $85,x			lda 	XS_Type,x 					; if already integer, exit
.01a2b4	29 01		and #$01			and 	#1
.01a2b6	d0 31		bne $01a2e9			bne 	_FPUTOI_Exit
.01a2b8	34 85		bit $85,x			bit 	XS_Type,x					; if zero, return zero.
.01a2ba	70 23		bvs $01a2df			bvs 	_FPUTOI_Zero
.01a2bc	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.01a2be	10 1f		bpl $01a2df			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.01a2c0	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.01a2c2	b0 2b		bcs $01a2ef			bcs 	FP_Overflow
.01a2c4					_FPUToIToInteger:
.01a2c4	b5 84		lda $84,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.01a2c6	c9 a0		cmp #$a0			cmp 	#128+32
.01a2c8	f0 0c		beq $01a2d6			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.01a2ca	f6 84		inc $84,x			inc 	XS_Exponent,X 				; increment Exponent
.01a2cc	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.01a2ce	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a2d0	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a2d2	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a2d4	80 ee		bra $01a2c4			bra 	_FPUToIToInteger 			; keep going.
.01a2d6					_FPUToICheckSign:
.01a2d6	b5 85		lda $85,x			lda 	XS_Type,x 					; check sign
.01a2d8	10 0f		bpl $01a2e9			bpl 	_FPUToI_Exit 				; exit if unsigned.
.01a2da	20 49 a2	jsr $01a249			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.01a2dd	80 0a		bra $01a2e9			bra 	_FPUTOI_Exit
.01a2df					_FPUTOI_Zero:
.01a2df	a9 00		lda #$00			lda 	#0 							; return zero integer.
.01a2e1	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a2e3	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a2e5	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a2e7	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a2e9					_FPUToI_Exit:
.01a2e9	a9 01		lda #$01			lda 	#1 							; set type to integer
.01a2eb	95 85		sta $85,x			sta 	XS_Type,x
.01a2ed	68		pla				pla
.01a2ee	60		rts				rts
.01a2ef					FP_Overflow:
.01a2ef	20 79 85	jsr $018579			jsr ERR_Handler
>01a2f2	46 6c 6f 61 74 69 6e 67			.text "Floating Point overflow",0
>01a2fa	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.01a30a					FPUTimes10:
.01a30a	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.01a30c	85 1a		sta $1a				sta 	ZLTemp1+0
.01a30e	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a310	85 1b		sta $1b				sta 	ZLTemp1+1
.01a312	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a314	85 1c		sta $1c				sta 	ZLTemp1+2
.01a316	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a318	85 1d		sta $1d				sta 	ZLTemp1+3
.01a31a	20 4f a3	jsr $01a34f			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.01a31d	20 4f a3	jsr $01a34f			jsr 	_FPUT_LSR_ZLTemp1
.01a320	18		clc				clc
.01a321	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.01a323	65 1a		adc $1a				adc 	ZLTemp1+0
.01a325	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a327	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a329	65 1b		adc $1b				adc 	ZLTemp1+1
.01a32b	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a32d	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a32f	65 1c		adc $1c				adc 	ZLTemp1+2
.01a331	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a333	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a335	65 1d		adc $1d				adc 	ZLTemp1+3
.01a337	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a339	90 0a		bcc $01a345			bcc 	_FPUTimes10
.01a33b	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.01a33d	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a33f	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a341	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a343	f6 84		inc $84,x			inc 	XS_Exponent,x				; fix exponent
.01a345					_FPUTimes10:
.01a345	b5 84		lda $84,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.01a347	18		clc				clc
.01a348	69 03		adc #$03			adc 	#3
.01a34a	95 84		sta $84,x			sta 	XS_Exponent,x
.01a34c	b0 a1		bcs $01a2ef			bcs 	FP_Overflow 				; error
.01a34e	60		rts				rts
.01a34f					_FPUT_LSR_ZLTemp1:
.01a34f	46 1d		lsr $1d				lsr 	ZLTemp1+3
.01a351	66 1c		ror $1c				ror 	ZLTemp1+2
.01a353	66 1b		ror $1b				ror 	ZLTemp1+1
.01a355	66 1a		ror $1a				ror 	ZLTemp1+0
.01a357	60		rts				rts
.01a358					FPUScale10A:
.01a358	5a		phy				phy
.01a359	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.01a35b	f0 37		beq $01a394			beq 	_FPUScaleExit
.01a35d	da		phx				phx 								; save X
.01a35e	e8		inx				inx
.01a35f	e8		inx				inx
.01a360	e8		inx				inx
.01a361	e8		inx				inx
.01a362	e8		inx				inx
.01a363	e8		inx				inx
.01a364	a8		tay				tay 								; save power scalar in Y.
.01a365	a9 00		lda #$00			lda 	#0
.01a367	95 80		sta $80,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.01a369	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a36b	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a36d	95 85		sta $85,x			sta 	XS_Type,x
.01a36f	a9 80		lda #$80			lda 	#$80
.01a371	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a373	a9 81		lda #$81			lda 	#$81
.01a375	95 84		sta $84,x			sta 	XS_Exponent,x
.01a377	5a		phy				phy 								; save 10^n on stack.
.01a378	c0 00		cpy #$00			cpy 	#0
.01a37a	10 05		bpl $01a381			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.01a37c	98		tya				tya
.01a37d	49 ff		eor #$ff			eor 	#$FF
.01a37f	1a		inc a				inc 	a
.01a380	a8		tay				tay
.01a381					_FPUSAbs:
.01a381	20 0a a3	jsr $01a30a			jsr 	FPUTimes10
.01a384	88		dey				dey
.01a385	d0 fa		bne $01a381			bne 	_FPUSAbs 					; tos is now 10^|AC|
.01a387	68		pla				pla 								; restore count in A
.01a388	fa		plx				plx 								; restore X pointing to number to scale.
.01a389	0a		asl a				asl 	a
.01a38a	b0 05		bcs $01a391			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.01a38c	20 ac a0	jsr $01a0ac			jsr 	FPMultiply 					; if clear multiply.
.01a38f	80 03		bra $01a394			bra		_FPUScaleExit
.01a391					_FPUSDivide:
.01a391	20 39 a0	jsr $01a039			jsr 	FPDivide
.01a394					_FPUScaleExit:
.01a394	7a		ply				ply
.01a395	60		rts				rts
.01a396					FPUCopyToNext:
.01a396	a0 06		ldy #$06			ldy 		#6
.01a398	da		phx				phx
.01a399					_FPUCopy1:
.01a399	b5 80		lda $80,x			lda 	XS_Mantissa,x
.01a39b	95 86		sta $86,x			sta 	XS2_Mantissa,x
.01a39d	e8		inx				inx
.01a39e	88		dey				dey
.01a39f	d0 f8		bne $01a399			bne 	_FPUCopy1
.01a3a1	fa		plx				plx
.01a3a2	60		rts				rts
.01a3a3					FPUCopyFromNext:
.01a3a3	a0 06		ldy #$06			ldy 		#6
.01a3a5	da		phx				phx
.01a3a6					_FPUCopy1:
.01a3a6	b5 86		lda $86,x			lda 	XS2_Mantissa,x
.01a3a8	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a3aa	e8		inx				inx
.01a3ab	88		dey				dey
.01a3ac	d0 f8		bne $01a3a6			bne 	_FPUCopy1
.01a3ae	fa		plx				plx
.01a3af	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.01a3b0					FPToString:
.01a3b0	48		pha				pha
.01a3b1	5a		phy				phy
.01a3b2	34 85		bit $85,x			bit 		XS_Type,x 				; check zero flag
.01a3b4	50 0a		bvc $01a3c0			bvc 		_FPTSIsFloat 			; if zero,
.01a3b6					_FPTSZero:
.01a3b6	a9 30		lda #$30			lda 		#"0"
.01a3b8	20 da 9e	jsr $019eda			jsr 		ITSOutputCharacter
.01a3bb					_FPTSExit:
.01a3bb	7a		ply				ply
.01a3bc	68		pla				pla
.01a3bd	60		rts				rts
.01a3be	80 fb		bra $01a3bb			bra 		_FPTSExit
.01a3c0					_FPTSIsFloat:
.01a3c0	b5 85		lda $85,x			lda 		XS_Type,x 				; is it signed ?
.01a3c2	10 09		bpl $01a3cd			bpl 		_FPTSNotSigned
.01a3c4	a9 00		lda #$00			lda 		#0 						; clear sign flag
.01a3c6	95 85		sta $85,x			sta 		XS_Type,x
.01a3c8	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.01a3ca	20 da 9e	jsr $019eda			jsr 		ITSOutputCharacter
.01a3cd					_FPTSNotSigned:
.01a3cd	b5 84		lda $84,x			lda 		XS_Exponent,x
.01a3cf	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.01a3d1	b0 09		bcs $01a3dc			bcs 		_FPTSExponent
.01a3d3	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.01a3d5	90 05		bcc $01a3dc			bcc 		_FPTSExponent 			;
.01a3d7					_FPTSStandard:
.01a3d7	20 1b a4	jsr $01a41b			jsr 		FPTOutputBody 			; output the body.
.01a3da	80 df		bra $01a3bb			bra 		_FPTSExit
.01a3dc					_FPTSExponent:
.01a3dc	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.01a3de	8d 9d 03	sta $039d			sta 		ExpCount
.01a3e1					_FPTSExponentLoop:
.01a3e1	b5 84		lda $84,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.01a3e3	10 0e		bpl $01a3f3			bpl 		_FPTSTimes
.01a3e5	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.01a3e7	90 14		bcc $01a3fd			bcc 		_FPTSScaledToExp
.01a3e9	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.01a3eb	20 58 a3	jsr $01a358			jsr 		FPUScale10A
.01a3ee	ee 9d 03	inc $039d			inc 		ExpCount
.01a3f1	80 ee		bra $01a3e1			bra 		_FPTSExponentLoop
.01a3f3					_FPTSTimes:
.01a3f3	a9 01		lda #$01			lda 		#1
.01a3f5	20 58 a3	jsr $01a358			jsr 		FPUScale10A
.01a3f8	ce 9d 03	dec $039d			dec 		ExpCount
.01a3fb	80 e4		bra $01a3e1			bra 		_FPTSExponentLoop
.01a3fd					_FPTSScaledToExp:
.01a3fd	20 1b a4	jsr $01a41b			jsr 		FPTOutputBody 			; output the body.
.01a400	a9 65		lda #$65			lda 		#"e"					; output E
.01a402	20 da 9e	jsr $019eda			jsr 		ITSOutputCharacter
.01a405	ad 9d 03	lda $039d			lda 		ExpCount 				; get the exponent
.01a408	95 80		sta $80,x			sta 		XS_Mantissa,x
.01a40a	29 80		and #$80			and 		#$80 					; sign extend it
.01a40c	f0 02		beq $01a410			beq 		_FPTSSExt
.01a40e	a9 ff		lda #$ff			lda 		#$FF
.01a410					_FPTSSExt:
.01a410	95 81		sta $81,x			sta 		XS_Mantissa+1,x
.01a412	95 82		sta $82,x			sta 		XS_Mantissa+2,x
.01a414	95 83		sta $83,x			sta 		XS_Mantissa+3,x
.01a416	20 38 9e	jsr $019e38			jsr 		INTToString 			; output the exponent.
.01a419	80 a0		bra $01a3bb			bra			_FPTSExit 				; and exit.
.01a41b					FPTOutputBody:
.01a41b	20 96 a3	jsr $01a396			jsr 		FPUCopyToNext 			; copy to next slot.
.01a41e	20 b1 a2	jsr $01a2b1			jsr 		FPUToInteger 			; convert to an integer
.01a421	20 38 9e	jsr $019e38			jsr 		INTToString 			; output the main integer part.
.01a424	20 a3 a3	jsr $01a3a3			jsr 		FPUCopyFromNext 		; get the fractional part back.
.01a427	20 34 a1	jsr $01a134			jsr 		FPFractionalPart 		; get the decimal part.
.01a42a	34 85		bit $85,x			bit 		XS_Type,x 				; any fractional part.
.01a42c	70 3c		bvs $01a46a			bvs 		_FPTOExit 				; if not, exit now.
.01a42e	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.01a430	20 da 9e	jsr $019eda			jsr 		ITSOutputCharacter
.01a433					_FPOutLoop:
.01a433	34 85		bit $85,x			bit 		XS_Type,x 				; finally reached zero.
.01a435	70 1d		bvs $01a454			bvs 		_FPStripZeros 			; strip trailing zeros
.01a437	20 0a a3	jsr $01a30a			jsr 		FPUTimes10 				; multiply by 10
.01a43a	20 96 a3	jsr $01a396			jsr 		FPUCopyToNext			; copy to next slot.
.01a43d	20 b1 a2	jsr $01a2b1			jsr 		FPUToInteger 			; convert to integer
.01a440	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; print digit.
.01a442	09 30		ora #$30			ora 		#"0"
.01a444	20 da 9e	jsr $019eda			jsr 		ITSOutputCharacter
.01a447	20 a3 a3	jsr $01a3a3			jsr 		FPUCopyFromNext 		; get it back
.01a44a	20 34 a1	jsr $01a134			jsr 		FPFractionalPart 		; get fractional part
.01a44d	ad 14 03	lda $0314			lda 		NumBufX 				; done 11 characters yet ?
.01a450	c9 0b		cmp #$0b			cmp 	 	#11
.01a452	90 df		bcc $01a433			bcc 		_FPOutLoop 				; if so, keep going till zero.
.01a454					_FPStripZeros:
.01a454	ac 14 03	ldy $0314			ldy 		NumBufX 				; strip trailing zeros.
.01a457					_FPStripLoop:
.01a457	88		dey				dey 								; back one, if at start then no strip
.01a458	f0 10		beq $01a46a			beq 		_FPToExit
.01a45a	b9 15 03	lda $0315,y			lda 		Num_Buffer,y 			; keep going if "0"
.01a45d	c9 30		cmp #$30			cmp 		#"0"
.01a45f	f0 f6		beq $01a457			beq 		_FPStripLoop
.01a461	c8		iny				iny
.01a462	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.01a464	99 15 03	sta $0315,y			sta 		Num_Buffer,y
.01a467	8c 14 03	sty $0314			sty 		NumBufX 				; update position.
.01a46a					_FPTOExit:
.01a46a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.01a46b					FPFromString:
.01a46b	48		pha				pha 								; push A
.01a46c	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.01a46e	c9 2e		cmp #$2e			cmp 	#"."
.01a470	f0 03		beq $01a475			beq	 	_FPFIsDecimal
.01a472	4c d1 a4	jmp $01a4d1			jmp 	_FPFNotDecimal
.01a475					_FPFIsDecimal:
.01a475	c8		iny				iny 								; consume the decimal.
.01a476	20 65 a2	jsr $01a265			jsr 	FPUToFloat 					; convert the integer to float.
.01a479	da		phx				phx 								; save X.
.01a47a	5a		phy				phy 								; save decimal start position
.01a47b	e8		inx				inx
.01a47c	e8		inx				inx
.01a47d	e8		inx				inx
.01a47e	e8		inx				inx
.01a47f	e8		inx				inx
.01a480	e8		inx				inx
.01a481	20 f2 9e	jsr $019ef2			jsr 	INTFromStringY 				; get the part after the DP.
.01a484	20 65 a2	jsr $01a265			jsr 	FPUToFloat 					; convert that to a float.
.01a487	68		pla				pla 								; calculate - chars consumed.
.01a488	8c 9c 03	sty $039c			sty 	ExpTemp
.01a48b	38		sec				sec
.01a48c	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; this is the shift amount
.01a48f	20 58 a3	jsr $01a358			jsr 	FPUScale10A 				; scale it by 10^AC
.01a492	fa		plx				plx 								; restore original X
.01a493	20 85 9f	jsr $019f85			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.01a496	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.01a498	c9 45		cmp #$45			cmp 	#"E"
.01a49a	f0 04		beq $01a4a0			beq 	_FPFExponent
.01a49c	c9 65		cmp #$65			cmp 	#"e"
.01a49e	d0 31		bne $01a4d1			bne 	_FPFNotDecimal 				; no, then exit normally.
.01a4a0					_FPFExponent:
.01a4a0	c8		iny				iny 								; skip over E symbol.
.01a4a1	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.01a4a3	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.01a4a5	d0 01		bne $01a4a8			bne 	_FPFGotSign
.01a4a7	c8		iny				iny 								; if it was - skip over it.
.01a4a8					_FPFGotSign:
.01a4a8	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.01a4a9	da		phx				phx
.01a4aa	e8		inx				inx
.01a4ab	e8		inx				inx
.01a4ac	e8		inx				inx
.01a4ad	e8		inx				inx
.01a4ae	e8		inx				inx
.01a4af	e8		inx				inx
.01a4b0	20 f2 9e	jsr $019ef2			jsr 	INTFromStringY 				; get the exponent
.01a4b3	fa		plx				plx 								; restore X.
.01a4b4	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.01a4b6	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.01a4b8	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.01a4ba	d0 17		bne $01a4d3			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.01a4bc	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.01a4be	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.01a4c0	b0 11		bcs $01a4d3			bcs 	_FPFXOverflow
.01a4c2	68		pla				pla 								; get direction
.01a4c3	d0 07		bne $01a4cc			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.01a4c5	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.01a4c7	49 ff		eor #$ff			eor 	#$FF
.01a4c9	1a		inc a				inc 	a
.01a4ca	95 86		sta $86,x			sta 	XS2_Mantissa+0,x
.01a4cc					_FPFXScale:
.01a4cc	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.01a4ce	20 58 a3	jsr $01a358			jsr 	FPUScale10A 				; scale by the exponent.
.01a4d1					_FPFNotDecimal:
.01a4d1	68		pla				pla
.01a4d2	60		rts				rts
.01a4d3					_FPFXOverflow:
.01a4d3	20 79 85	jsr $018579			jsr 	ERR_Handler
>01a4d6	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>01a4de	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.01a4e5					Unary_Rnd:
.01a4e5	20 58 92	jsr $019258			jsr 	EvaluateNumberX 			; get value
.01a4e8	20 a8 98	jsr $0198a8			jsr 	CheckNextRParen 			; check right bracket.
.01a4eb	20 d6 94	jsr $0194d6			jsr 	GetSignCurrent 				; get sign -1,0,1.
.01a4ee	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.01a4f0	30 10		bmi $01a502			bmi 	_URSetSeed
.01a4f2	f0 28		beq $01a51c			beq 	_URMakeRandom 				; if zero return same number.
.01a4f4	da		phx				phx
.01a4f5	a2 00		ldx #$00			ldx 	#0
.01a4f7	20 53 a5	jsr $01a553			jsr 	Random16
.01a4fa	a2 02		ldx #$02			ldx 	#2
.01a4fc	20 53 a5	jsr $01a553			jsr 	Random16
.01a4ff	fa		plx				plx
.01a500	80 1a		bra $01a51c			bra 	_URMakeRandom
.01a502					_URSetSeed:
.01a502	20 65 a2	jsr $01a265			jsr 	FPUToFloat 					; make it a float to twiddle it.
.01a505	b5 80		lda $80,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.01a507	8d a3 03	sta $03a3			sta 	RandomSeed+0
.01a50a	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.01a50c	8d a4 03	sta $03a4			sta 	RandomSeed+1
.01a50f	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.01a511	8d a5 03	sta $03a5			sta 	RandomSeed+2
.01a514	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.01a516	0a		asl a				asl 	a
.01a517	49 db		eor #$db			eor 	#$DB
.01a519	8d a6 03	sta $03a6			sta 	RandomSeed+3
.01a51c					_URMakeRandom:
.01a51c	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; check if seed is zero.
.01a51f	0d a4 03	ora $03a4			ora 	RandomSeed+1
.01a522	0d a5 03	ora $03a5			ora 	RandomSeed+2
.01a525	0d a6 03	ora $03a6			ora 	RandomSeed+3
.01a528	d0 0a		bne $01a534			bne 	_URNotZero
.01a52a	a9 47		lda #$47			lda 	#$47
.01a52c	8d a4 03	sta $03a4			sta 	RandomSeed+1				; if it is, make it non zero.
.01a52f	a9 3d		lda #$3d			lda 	#$3D
.01a531	8d a6 03	sta $03a6			sta 	RandomSeed+3
.01a534					_URNotZero:
.01a534	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; copy seed into mantissa.
.01a537	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a539	ad a4 03	lda $03a4			lda 	RandomSeed+1
.01a53c	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a53e	ad a5 03	lda $03a5			lda 	RandomSeed+2
.01a541	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a543	ad a6 03	lda $03a6			lda 	RandomSeed+3
.01a546	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a548	a9 00		lda #$00			lda 	#$00 						; set type to float.
.01a54a	95 85		sta $85,x			sta 	XS_Type,x
.01a54c	a9 80		lda #$80			lda 	#$80
.01a54e	95 84		sta $84,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.01a550	4c 92 a2	jmp $01a292			jmp 	FPUNormalise
.01a553					Random16:
.01a553	5e a4 03	lsr $03a4,x			lsr 	RandomSeed+1,x				; shift seed right
.01a556	7e a3 03	ror $03a3,x			ror 	RandomSeed,x
.01a559	90 08		bcc $01a563			bcc 	_R16_NoXor
.01a55b	bd a4 03	lda $03a4,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.01a55e	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.01a560	9d a4 03	sta $03a4,x			sta 	RandomSeed+1,x
.01a563					_R16_NoXor:
.01a563	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.01a564					Unary_Int:
.01a564	20 58 92	jsr $019258			jsr 	EvaluateNumberX 			; get value
.01a567	20 a8 98	jsr $0198a8			jsr 	CheckNextRParen 			; check right bracket.
.01a56a	4c b1 a2	jmp $01a2b1			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Return to file: basic.asm

>01a56d	02						.byte 	2
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 c0						.word 	StartROM
>fffe	19 c0					.word TIM_BreakHandler

;******  End of listing
