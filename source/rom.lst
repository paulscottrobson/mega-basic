
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Wed Aug 28 10:18:30 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="65816"				cpu = "65816"
="em65816"				hardware = "em65816"
=1					exitonend = 1
=1					autorun = 1
=2					loadtest = 2
=1					hasfloat = 1
=1					hasinteger = 1
=253					maxstring = 253

;******  Processing file: modules/float/fpmacros.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/em65816/src_em65816.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0020					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0022					zVarDataPtr: .word ? 						; position of variable data.
>0024					zVarType: 	.byte ? 						; type of data (token)
>0025					zNullString:.byte ? 						; represents a NULL string.
>0200					IFT_XCursor:.byte ?							; current logical position on screen
>0201					IFT_YCursor:.byte ?
>0202					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0266					IFT_LineBuffer: .fill 100 					; line input buffer.
>0300					UserVector .fill 4 							; USR(x) calls this.
>0304					LocalVector .fill 4 						; Indirect calls call this.
>0308					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>030c					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>030d					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=782					XS2_Mantissa = XS_Mantissa+XS_Size
=786					XS2_Exponent = XS_Exponent+XS_Size
=787					XS2_Type = XS_Type+XS_Size
=788					XS3_Mantissa = XS_Mantissa+XS_Size*2
=792					XS3_Exponent = XS_Exponent+XS_Size*2
=793					XS3_Type = XS_Type+XS_Size*2
>0400					StringPtr:	.word ? 						; Top of free memory (for string allocation)
>0402					VarMemPtr: 	.word ?							; Bottom of free memory (for variables)
>0404					NumBufX 	.byte 	?						; buffer index position
>0405					Num_Buffer	.fill 	32 						; buffer for numeric conversions
=6					HashTableCount = 6 							; there are 6 hash tables, in token order.
=8					HashTableSize = 8 							; each hash table as 8 links.
.0425					HashTableBase:
>0425								.fill	HashTableCount * HashTableSize * 2
.0485					HashTableEnd:
=$405					Var_Buffer 	= Num_Buffer 					; buffer for variable name (same space)
>0485					Var_Type    .byte ? 						; type of variable (as a type token)
>0486					Var_Hash 	.byte ? 						; hash of identifier name.
>0487					Var_Length 	.byte ? 						; length of variable name
>0488					Var_HashAddress .byte ?						; low byte of hash table entry.
>0489					Var_DataSize .byte ?						; size of one element.
>048a					NumSuppress	.byte 	?						; leading zero suppression flag
>048b					NumConvCount .byte 	? 						; count for conversions.
>048c					ExpTemp:	.byte ?							; Working temp for exponents.
>048d					ExpCount:	.byte ? 						; Count of decimal exponents.
>048e					SignCount:	.byte ?							; Integer Divide Sign Counts.
>048f					TempStringWriteIndex: .byte ? 				; Write offset.
>0490					ValSign: 	.byte ? 						; sign flag for val()
>0491					SliceStart:	.byte ? 						; string slice parts
>0492					SliceCount:	.byte ?
>0493					RandomSeed:	.dword ? 						; Random seed.
=3					ArrayMaxDim = 3 							; number of dimensions.
>0497					ArrayDef:	.fill (ArrayMaxDim+1)*2 		; dimensions for auto-creation
>049f					UsrArrayDef:.fill (ArrayMaxDim+1)*2 		; dimensions created in DIM
>04a7					UsrArrayIdx:.byte ? 						; index into UsrArrayDef
>04a8					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>04aa					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>04ac					Tim_SR:		.byte ? 						; Processor Status
>04ad					Tim_A:		.byte ? 						; Processor Registers
>04ae					Tim_X:		.byte ?
>04af					Tim_Y:		.byte ?
>04b0					Tim_Z:		.byte ?
>04b1					Tim_SP:		.word ?							; Stack Pointer (just in cases)

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/em65816.asm

=$8000					HighMemory = $8000
=$4000					VariableMemory = $4000
.1000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testassign.src

>1000	0b 02 00 c7 03 39 0c ba			.byte	$0b,$02,$00,$c7,$03,$39,$0c,$ba
>1008	41 be 00 0d 03 00 c7 08			.byte	$41,$be,$00,$0d,$03,$00,$c7,$08
>1010	39 01 19 19 ba 42 be 00			.byte	$39,$01,$19,$19,$ba,$42,$be,$00
>1018	0d 04 00 c7 0c 36 02 1a			.byte	$0d,$04,$00,$c7,$0c,$36,$02,$1a
>1020	11 ba 42 be 00 0d 05 00			.byte	$11,$ba,$42,$be,$00,$0d,$05,$00
>1028	c7 19 35 18 14 12 bd 41			.byte	$c7,$19,$35,$18,$14,$12,$bd,$41
>1030	be 00 0b 06 00 c7 04 34			.byte	$be,$00,$0b,$06,$00,$c7,$04,$34
>1038	02 ba 42 be 00 0d 07 00			.byte	$02,$ba,$42,$be,$00,$0d,$07,$00
>1040	c7 0c 37 04 bd 41 bf 41			.byte	$c7,$0c,$37,$04,$bd,$41,$bf,$41
>1048	be 00 0b 08 00 c7 12 36			.byte	$be,$00,$0b,$08,$00,$c7,$12,$36
>1050	16 ba 42 be 00 0c 09 00			.byte	$16,$ba,$42,$be,$00,$0c,$09,$00
>1058	c7 13 31 0a 02 b8 41 be			.byte	$c7,$13,$31,$0a,$02,$b8,$41,$be
>1060	00 0d 0a 00 c7 10 34 01			.byte	$00,$0d,$0a,$00,$c7,$10,$34,$01
>1068	bc 42 bf 42 be 00 0c 0b			.byte	$bc,$42,$bf,$42,$be,$00,$0c,$0b
>1070	00 c7 09 37 04 12 bc 41			.byte	$00,$c7,$09,$37,$04,$12,$bc,$41
>1078	be 00 0b 0c 00 c7 10 39			.byte	$be,$00,$0b,$0c,$00,$c7,$10,$39
>1080	10 bc 42 be 00 0d 0d 00			.byte	$10,$bc,$42,$be,$00,$0d,$0d,$00
>1088	c7 10 39 14 03 04 bc 41			.byte	$c7,$10,$39,$14,$03,$04,$bc,$41
>1090	be 00 13 0e 00 cf 01 31			.byte	$be,$00,$13,$0e,$00,$cf,$01,$31
>1098	02 0a 05 b9 84 8b 45 68			.byte	$02,$0a,$05,$b9,$84,$8b,$45,$68
>10a0	fd 04 37 35 00 0e 0f 00			.byte	$fd,$04,$37,$35,$00,$0e,$0f,$00
>10a8	cf 0b 33 17 14 bb 84 8b			.byte	$cf,$0b,$33,$17,$14,$bb,$84,$8b
>10b0	46 46 00 0c 10 00 cf 06			.byte	$46,$46,$00,$0c,$10,$00,$cf,$06
>10b8	35 13 bb 84 48 41 00 13			.byte	$35,$13,$bb,$84,$48,$41,$00,$13
>10c0	11 00 cf 15 32 14 11 13			.byte	$11,$00,$cf,$15,$32,$14,$11,$13
>10c8	b7 84 fe 07 4b 35 4c 4c			.byte	$b7,$84,$fe,$07,$4b,$35,$4c,$4c
>10d0	56 00 11 12 00 cf 13 33			.byte	$56,$00,$11,$12,$00,$cf,$13,$33
>10d8	13 84 8b 43 60 fd 05 38			.byte	$13,$84,$8b,$43,$60,$fd,$05,$38
>10e0	37 35 00 0f 13 00 cf 1a			.byte	$37,$35,$00,$0f,$13,$00,$cf,$1a
>10e8	b9 84 8b 43 75 fd 04 37			.byte	$b9,$84,$8b,$43,$75,$fd,$04,$37
>10f0	35 00 12 14 00 cf 0c 35			.byte	$35,$00,$12,$14,$00,$cf,$0c,$35
>10f8	08 0c 05 b7 84 fe 06 57			.byte	$08,$0c,$05,$b7,$84,$fe,$06,$57
>1100	36 50 4b 00 12 15 00 cf			.byte	$36,$50,$4b,$00,$12,$15,$00,$cf
>1108	0e 31 03 b9 84 45 68 fd			.byte	$0e,$31,$03,$b9,$84,$45,$68,$fd
>1110	06 36 38 37 35 00 0f 16			.byte	$06,$36,$38,$37,$35,$00,$0f,$16
>1118	00 cf 02 35 0b b7 84 fe			.byte	$00,$cf,$02,$35,$0b,$b7,$84,$fe
>1120	05 4c 33 4a 00 0d 17 00			.byte	$05,$4c,$33,$4a,$00,$0d,$17,$00
>1128	cf 17 35 09 08 12 bb 84			.byte	$cf,$17,$35,$09,$08,$12,$bb,$84
>1130	66 00 0d 18 00 cf 01 31			.byte	$66,$00,$0d,$18,$00,$cf,$01,$31
>1138	08 b7 84 fe 03 4a 00 10			.byte	$08,$b7,$84,$fe,$03,$4a,$00,$10
>1140	19 00 cf 0c b9 84 44 65			.byte	$19,$00,$cf,$0c,$b9,$84,$44,$65
>1148	fd 06 39 33 37 35 00 11			.byte	$fd,$06,$39,$33,$37,$35,$00,$11
>1150	1a 00 cf 0d b9 84 8b 44			.byte	$1a,$00,$cf,$0d,$b9,$84,$8b,$44
>1158	72 fd 06 36 38 37 35 00			.byte	$72,$fd,$06,$36,$38,$37,$35,$00
>1160	14 1b 00 cf 14 33 0b 10			.byte	$14,$1b,$00,$cf,$14,$33,$0b,$10
>1168	17 b9 84 48 73 fd 06 38			.byte	$17,$b9,$84,$48,$73,$fd,$06,$38
>1170	31 32 35 00 10 1c 00 cf			.byte	$31,$32,$35,$00,$10,$1c,$00,$cf
>1178	04 30 07 b7 84 fe 06 43			.byte	$04,$30,$07,$b7,$84,$fe,$06,$43
>1180	38 4f 43 00 11 1d 00 cf			.byte	$38,$4f,$43,$00,$11,$1d,$00,$cf
>1188	10 39 14 03 04 bc 40 be			.byte	$10,$39,$14,$03,$04,$bc,$40,$be
>1190	84 8b 4b 4e 00 11 1e 00			.byte	$84,$8b,$4b,$4e,$00,$11,$1e,$00
>1198	cf 13 31 0a 02 b8 41 be			.byte	$cf,$13,$31,$0a,$02,$b8,$41,$be
>11a0	84 fe 04 4a 33 00 12 1f			.byte	$84,$fe,$04,$4a,$33,$00,$12,$1f
>11a8	00 cf 11 32 04 b9 84 8b			.byte	$00,$cf,$11,$32,$04,$b9,$84,$8b
>11b0	4a fd 06 35 36 32 35 00			.byte	$4a,$fd,$06,$35,$36,$32,$35,$00
>11b8	0f 20 00 cf 17 34 09 04			.byte	$0f,$20,$00,$cf,$17,$34,$09,$04
>11c0	14 b7 84 fe 03 48 00 11			.byte	$14,$b7,$84,$fe,$03,$48,$00,$11
>11c8	21 00 cf 0a 39 1a 05 0a			.byte	$21,$00,$cf,$0a,$39,$1a,$05,$0a
>11d0	84 8b 67 fd 04 32 35 00			.byte	$84,$8b,$67,$fd,$04,$32,$35,$00
>11d8	0d 22 00 cf 04 32 08 15			.byte	$0d,$22,$00,$cf,$04,$32,$08,$15
>11e0	bb 84 4b 48 00 0f 23 00			.byte	$bb,$84,$4b,$48,$00,$0f,$23,$00
>11e8	cf 16 b7 84 fe 07 41 38			.byte	$cf,$16,$b7,$84,$fe,$07,$41,$38
>11f0	52 52 50 00 10 24 00 cf			.byte	$52,$52,$50,$00,$10,$24,$00,$cf
>11f8	19 84 8b 49 5e fd 06 39			.byte	$19,$84,$8b,$49,$5e,$fd,$06,$39
>1200	33 37 35 00 0d 25 00 cf			.byte	$33,$37,$35,$00,$0d,$25,$00,$cf
>1208	12 31 02 bb 84 8b 49 7d			.byte	$12,$31,$02,$bb,$84,$8b,$49,$7d
>1210	00 0c 26 00 cf 04 32 08			.byte	$00,$0c,$26,$00,$cf,$04,$32,$08
>1218	15 bb 84 41 00 0f 27 00			.byte	$15,$bb,$84,$41,$00,$0f,$27,$00
>1220	cf 08 32 0b 84 8b 48 76			.byte	$cf,$08,$32,$0b,$84,$8b,$48,$76
>1228	fd 03 35 00 14 28 00 cf			.byte	$fd,$03,$35,$00,$14,$28,$00,$cf
>1230	0a 39 1a 05 0a 84 8b 43			.byte	$0a,$39,$1a,$05,$0a,$84,$8b,$43
>1238	6a fd 06 38 31 32 35 00			.byte	$6a,$fd,$06,$38,$31,$32,$35,$00
>1240	13 29 00 cf 0e 31 03 b9			.byte	$13,$29,$00,$cf,$0e,$31,$03,$b9
>1248	84 8b 47 56 fd 06 39 33			.byte	$84,$8b,$47,$56,$fd,$06,$39,$33
>1250	37 35 00 13 2a 00 cf 15			.byte	$37,$35,$00,$13,$2a,$00,$cf,$15
>1258	34 09 03 b9 84 46 4e fd			.byte	$34,$09,$03,$b9,$84,$46,$4e,$fd
>1260	06 39 33 37 35 00 11 2b			.byte	$06,$39,$33,$37,$35,$00,$11,$2b
>1268	00 cf 0c 35 08 0c 05 b7			.byte	$00,$cf,$0c,$35,$08,$0c,$05,$b7
>1270	84 fe 05 4e 35 59 00 17			.byte	$84,$fe,$05,$4e,$35,$59,$00,$17
>1278	2c 00 cf 0c 36 02 1a 11			.byte	$2c,$00,$cf,$0c,$36,$02,$1a,$11
>1280	ba 40 be 84 8b 48 46 fd			.byte	$ba,$40,$be,$84,$8b,$48,$46,$fd
>1288	06 36 38 37 35 00 12 2d			.byte	$06,$36,$38,$37,$35,$00,$12,$2d
>1290	00 cf 18 35 1a 02 b7 84			.byte	$00,$cf,$18,$35,$1a,$02,$b7,$84
>1298	fe 07 54 30 4d 46 59 00			.byte	$fe,$07,$54,$30,$4d,$46,$59,$00
>12a0	0d 2e 00 cf 03 36 09 bb			.byte	$0d,$2e,$00,$cf,$03,$36,$09,$bb
>12a8	84 8b 45 56 00 11 2f 00			.byte	$84,$8b,$45,$56,$00,$11,$2f,$00
>12b0	cf 02 32 08 17 b7 84 fe			.byte	$cf,$02,$32,$08,$17,$b7,$84,$fe
>12b8	06 4d 32 45 5a 00 11 30			.byte	$06,$4d,$32,$45,$5a,$00,$11,$30
>12c0	00 cf 0c b9 84 8b 49 56			.byte	$00,$cf,$0c,$b9,$84,$8b,$49,$56
>12c8	fd 06 33 31 32 35 00 0e			.byte	$fd,$06,$33,$31,$32,$35,$00,$0e
>12d0	31 00 cf 0f 34 0d 1a 0d			.byte	$31,$00,$cf,$0f,$34,$0d,$1a,$0d
>12d8	b7 84 fe 02 00 0e 32 00			.byte	$b7,$84,$fe,$02,$00,$0e,$32,$00
>12e0	cf 05 38 10 07 0e bb 84			.byte	$cf,$05,$38,$10,$07,$0e,$bb,$84
>12e8	4a 5a 00 14 33 00 cf 17			.byte	$4a,$5a,$00,$14,$33,$00,$cf,$17
>12f0	38 16 06 1a 84 8b 47 48			.byte	$38,$16,$06,$1a,$84,$8b,$47,$48
>12f8	fd 06 33 31 32 35 00 13			.byte	$fd,$06,$33,$31,$32,$35,$00,$13
>1300	34 00 cf 14 30 0f 17 0f			.byte	$34,$00,$cf,$14,$30,$0f,$17,$0f
>1308	84 8b 49 70 fd 05 33 37			.byte	$84,$8b,$49,$70,$fd,$05,$33,$37
>1310	35 00 11 35 00 cf 10 33			.byte	$35,$00,$11,$35,$00,$cf,$10,$33
>1318	09 84 46 6e fd 06 35 36			.byte	$09,$84,$46,$6e,$fd,$06,$35,$36
>1320	32 35 00 12 36 00 cf 0d			.byte	$32,$35,$00,$12,$36,$00,$cf,$0d
>1328	34 11 12 05 b9 84 8b 48			.byte	$34,$11,$12,$05,$b9,$84,$8b,$48
>1330	55 fd 03 35 00 0d 37 00			.byte	$55,$fd,$03,$35,$00,$0d,$37,$00
>1338	cf 1a 35 18 b7 84 fe 03			.byte	$cf,$1a,$35,$18,$b7,$84,$fe,$03
>1340	44 00 12 38 00 cf 11 32			.byte	$44,$00,$12,$38,$00,$cf,$11,$32
>1348	04 b9 84 45 5f fd 06 36			.byte	$04,$b9,$84,$45,$5f,$fd,$06,$36
>1350	38 37 35 00 0f 39 00 cf			.byte	$38,$37,$35,$00,$0f,$39,$00,$cf
>1358	0c 32 13 84 7a fd 05 33			.byte	$0c,$32,$13,$84,$7a,$fd,$05,$33
>1360	37 35 00 14 3a 00 cf 01			.byte	$37,$35,$00,$14,$3a,$00,$cf,$01
>1368	31 02 0a 05 b9 84 42 70			.byte	$31,$02,$0a,$05,$b9,$84,$42,$70
>1370	fd 06 38 31 32 35 00 13			.byte	$fd,$06,$38,$31,$32,$35,$00,$13
>1378	3b 00 cf 14 33 0b 10 17			.byte	$3b,$00,$cf,$14,$33,$0b,$10,$17
>1380	b9 84 44 65 fd 05 38 37			.byte	$b9,$84,$44,$65,$fd,$05,$38,$37
>1388	35 00 14 3c 00 cf 0c 34			.byte	$35,$00,$14,$3c,$00,$cf,$0c,$34
>1390	04 04 1a 84 8b 42 7f fd			.byte	$04,$04,$1a,$84,$8b,$42,$7f,$fd
>1398	06 33 31 32 35 00 0f 3d			.byte	$06,$33,$31,$32,$35,$00,$0f,$3d
>13a0	00 cf 0d 35 06 0b 14 bb			.byte	$00,$cf,$0d,$35,$06,$0b,$14,$bb
>13a8	84 8b 48 5a 00 0e 3e 00			.byte	$84,$8b,$48,$5a,$00,$0e,$3e,$00
>13b0	cf 04 32 08 15 bb 84 8b			.byte	$cf,$04,$32,$08,$15,$bb,$84,$8b
>13b8	4e 40 00 10 3f 00 cf 0f			.byte	$4e,$40,$00,$10,$3f,$00,$cf,$0f
>13c0	32 14 84 61 fd 06 38 31			.byte	$32,$14,$84,$61,$fd,$06,$38,$31
>13c8	32 35 00 0b 40 00 cf 06			.byte	$32,$35,$00,$0b,$40,$00,$cf,$06
>13d0	35 13 bb 84 78 00 13 41			.byte	$35,$13,$bb,$84,$78,$00,$13,$41
>13d8	00 cf 13 35 0a 19 b9 84			.byte	$00,$cf,$13,$35,$0a,$19,$b9,$84
>13e0	8b 49 fd 06 35 36 32 35			.byte	$8b,$49,$fd,$06,$35,$36,$32,$35
>13e8	00 0e 42 00 cf 0f 34 0d			.byte	$00,$0e,$42,$00,$cf,$0f,$34,$0d
>13f0	1a 0d b7 84 fe 02 00 10			.byte	$1a,$0d,$b7,$84,$fe,$02,$00,$10
>13f8	43 00 cf 1a b9 84 42 71			.byte	$43,$00,$cf,$1a,$b9,$84,$42,$71
>1400	fd 06 31 38 37 35 00 10			.byte	$fd,$06,$31,$38,$37,$35,$00,$10
>1408	44 00 cf 0d b9 84 8b 49			.byte	$44,$00,$cf,$0d,$b9,$84,$8b,$49
>1410	6c fd 05 31 32 35 00 12			.byte	$6c,$fd,$05,$31,$32,$35,$00,$12
>1418	45 00 cf 0a 39 1a 05 0a			.byte	$45,$00,$cf,$0a,$39,$1a,$05,$0a
>1420	84 43 7c fd 05 31 32 35			.byte	$84,$43,$7c,$fd,$05,$31,$32,$35
>1428	00 11 46 00 cf 11 32 04			.byte	$00,$11,$46,$00,$cf,$11,$32,$04
>1430	b9 84 43 7c fd 05 36 32			.byte	$b9,$84,$43,$7c,$fd,$05,$36,$32
>1438	35 00 0d 47 00 cf 16 37			.byte	$35,$00,$0d,$47,$00,$cf,$16,$37
>1440	1a 05 b7 84 fe 02 00 10			.byte	$1a,$05,$b7,$84,$fe,$02,$00,$10
>1448	48 00 cf 0c b9 84 44 76			.byte	$48,$00,$cf,$0c,$b9,$84,$44,$76
>1450	fd 06 30 36 32 35 00 12			.byte	$fd,$06,$30,$36,$32,$35,$00,$12
>1458	49 00 cf 13 31 0a 02 b8			.byte	$49,$00,$cf,$13,$31,$0a,$02,$b8
>1460	40 be 84 fe 05 56 35 57			.byte	$40,$be,$84,$fe,$05,$56,$35,$57
>1468	00 0e 4a 00 cf 02 32 14			.byte	$00,$0e,$4a,$00,$cf,$02,$32,$14
>1470	06 12 bb 84 44 78 00 0f			.byte	$06,$12,$bb,$84,$44,$78,$00,$0f
>1478	4b 00 cf 02 32 14 06 12			.byte	$4b,$00,$cf,$02,$32,$14,$06,$12
>1480	bb 84 8b 4c 44 00 10 4c			.byte	$bb,$84,$8b,$4c,$44,$00,$10,$4c
>1488	00 cf 10 39 14 03 04 bc			.byte	$00,$cf,$10,$39,$14,$03,$04,$bc
>1490	40 be 84 48 41 00 0c 4d			.byte	$40,$be,$84,$48,$41,$00,$0c,$4d
>1498	00 cf 10 34 0b b7 84 fe			.byte	$00,$cf,$10,$34,$0b,$b7,$84,$fe
>14a0	02 00 0d 4e 00 cf 01 31			.byte	$02,$00,$0d,$4e,$00,$cf,$01,$31
>14a8	08 b7 84 fe 03 53 00 10			.byte	$08,$b7,$84,$fe,$03,$53,$00,$10
>14b0	4f 00 cf 11 38 08 19 b9			.byte	$4f,$00,$cf,$11,$38,$08,$19,$b9
>14b8	84 48 60 fd 03 35 00 0f			.byte	$84,$48,$60,$fd,$03,$35,$00,$0f
>14c0	50 00 cf 04 35 0a b7 84			.byte	$50,$00,$cf,$04,$35,$0a,$b7,$84
>14c8	fe 05 45 33 55 00 0d 51			.byte	$fe,$05,$45,$33,$55,$00,$0d,$51
>14d0	00 cf 06 35 18 b7 84 fe			.byte	$00,$cf,$06,$35,$18,$b7,$84,$fe
>14d8	03 42 00 0d 52 00 cf 0b			.byte	$03,$42,$00,$0d,$52,$00,$cf,$0b
>14e0	33 17 14 bb 84 8b 74 00			.byte	$33,$17,$14,$bb,$84,$8b,$74,$00
>14e8	11 53 00 cf 01 35 19 b9			.byte	$11,$53,$00,$cf,$01,$35,$19,$b9
>14f0	84 8b 42 50 fd 04 32 35			.byte	$84,$8b,$42,$50,$fd,$04,$32,$35
>14f8	00 15 54 00 cf 0b 37 16			.byte	$00,$15,$54,$00,$cf,$0b,$37,$16
>1500	05 17 b9 84 8b 48 5b fd			.byte	$05,$17,$b9,$84,$8b,$48,$5b,$fd
>1508	06 35 36 32 35 00 12 55			.byte	$06,$35,$36,$32,$35,$00,$12,$55
>1510	00 cf 11 35 15 0f b7 84			.byte	$00,$cf,$11,$35,$15,$0f,$b7,$84
>1518	fe 07 48 38 53 49 45 00			.byte	$fe,$07,$48,$38,$53,$49,$45,$00
>1520	12 56 00 cf 0f 32 14 84			.byte	$12,$56,$00,$cf,$0f,$32,$14,$84
>1528	8b 47 4f fd 06 31 38 37			.byte	$8b,$47,$4f,$fd,$06,$31,$38,$37
>1530	35 00 10 57 00 cf 10 34			.byte	$35,$00,$10,$57,$00,$cf,$10,$34
>1538	0b b7 84 fe 06 4e 32 4b			.byte	$0b,$b7,$84,$fe,$06,$4e,$32,$4b
>1540	59 00 0e 58 00 cf 02 32			.byte	$59,$00,$0e,$58,$00,$cf,$02,$32
>1548	14 06 12 bb 84 47 43 00			.byte	$14,$06,$12,$bb,$84,$47,$43,$00
>1550	14 59 00 cf 11 38 08 19			.byte	$14,$59,$00,$cf,$11,$38,$08,$19
>1558	b9 84 8b 42 67 fd 06 35			.byte	$b9,$84,$8b,$42,$67,$fd,$06,$35
>1560	36 32 35 00 12 5a 00 cf			.byte	$36,$32,$35,$00,$12,$5a,$00,$cf
>1568	08 32 0b 84 8b 45 54 fd			.byte	$08,$32,$0b,$84,$8b,$45,$54,$fd
>1570	06 31 38 37 35 00 0d 5b			.byte	$06,$31,$38,$37,$35,$00,$0d,$5b
>1578	00 cf 0c 33 0e bb 84 8b			.byte	$00,$cf,$0c,$33,$0e,$bb,$84,$8b
>1580	4c 43 00 15 5c 00 cf 02			.byte	$4c,$43,$00,$15,$5c,$00,$cf,$02
>1588	36 02 0c 12 b9 84 8b 42			.byte	$36,$02,$0c,$12,$b9,$84,$8b,$42
>1590	66 fd 06 38 31 32 35 00			.byte	$66,$fd,$06,$38,$31,$32,$35,$00
>1598	0e 5d 00 cf 01 31 08 b7			.byte	$0e,$5d,$00,$cf,$01,$31,$08,$b7
>15a0	84 fe 04 5a 34 00 14 5e			.byte	$84,$fe,$04,$5a,$34,$00,$14,$5e
>15a8	00 cf 14 33 0b 10 17 b9			.byte	$00,$cf,$14,$33,$0b,$10,$17,$b9
>15b0	84 47 63 fd 06 38 31 32			.byte	$84,$47,$63,$fd,$06,$38,$31,$32
>15b8	35 00 11 5f 00 cf 11 32			.byte	$35,$00,$11,$5f,$00,$cf,$11,$32
>15c0	04 b9 84 72 fd 06 34 33			.byte	$04,$b9,$84,$72,$fd,$06,$34,$33
>15c8	37 35 00 11 60 00 cf 04			.byte	$37,$35,$00,$11,$60,$00,$cf,$04
>15d0	35 08 84 44 4d fd 06 35			.byte	$35,$08,$84,$44,$4d,$fd,$06,$35
>15d8	36 32 35 00 13 61 00 cf			.byte	$36,$32,$35,$00,$13,$61,$00,$cf
>15e0	0c 30 0c 17 b9 84 44 50			.byte	$0c,$30,$0c,$17,$b9,$84,$44,$50
>15e8	fd 06 39 33 37 35 00 12			.byte	$fd,$06,$39,$33,$37,$35,$00,$12
>15f0	62 00 cf 0f 39 15 0d 84			.byte	$62,$00,$cf,$0f,$39,$15,$0d,$84
>15f8	8b 46 49 fd 05 38 37 35			.byte	$8b,$46,$49,$fd,$05,$38,$37,$35
>1600	00 0e 63 00 cf 02 35 0b			.byte	$00,$0e,$63,$00,$cf,$02,$35,$0b
>1608	b7 84 fe 04 4d 36 00 0f			.byte	$b7,$84,$fe,$04,$4d,$36,$00,$0f
>1610	64 00 cf 01 84 45 72 fd			.byte	$64,$00,$cf,$01,$84,$45,$72,$fd
>1618	06 38 31 32 35 00 0c 65			.byte	$06,$38,$31,$32,$35,$00,$0c,$65
>1620	00 cf 08 36 09 bb 84 41			.byte	$00,$cf,$08,$36,$09,$bb,$84,$41
>1628	4a 00 11 66 00 cf 13 35			.byte	$4a,$00,$11,$66,$00,$cf,$13,$35
>1630	0a 19 b9 84 8b 46 52 fd			.byte	$0a,$19,$b9,$84,$8b,$46,$52,$fd
>1638	03 30 00 0d 67 00 cf 03			.byte	$03,$30,$00,$0d,$67,$00,$cf,$03
>1640	36 09 bb 84 8b 4c 5f 00			.byte	$36,$09,$bb,$84,$8b,$4c,$5f,$00
>1648	10 68 00 cf 02 32 08 17			.byte	$10,$68,$00,$cf,$02,$32,$08,$17
>1650	b7 84 fe 05 46 33 4c 00			.byte	$b7,$84,$fe,$05,$46,$33,$4c,$00
>1658	12 69 00 cf 10 39 08 02			.byte	$12,$69,$00,$cf,$10,$39,$08,$02
>1660	18 b9 84 8b 45 48 fd 03			.byte	$18,$b9,$84,$8b,$45,$48,$fd,$03
>1668	35 00 12 6a 00 cf 0c 37			.byte	$35,$00,$12,$6a,$00,$cf,$0c,$37
>1670	04 bd 40 bf 40 be 84 73			.byte	$04,$bd,$40,$bf,$40,$be,$84,$73
>1678	fd 03 30 00 10 6b 00 cf			.byte	$fd,$03,$30,$00,$10,$6b,$00,$cf
>1680	08 b9 84 8b 45 5a fd 05			.byte	$08,$b9,$84,$8b,$45,$5a,$fd,$05
>1688	36 32 35 00 0e 6c 00 cf			.byte	$36,$32,$35,$00,$0e,$6c,$00,$cf
>1690	0d b9 84 44 59 fd 04 32			.byte	$0d,$b9,$84,$44,$59,$fd,$04,$32
>1698	35 00 0e 6d 00 cf 0c 35			.byte	$35,$00,$0e,$6d,$00,$cf,$0c,$35
>16a0	08 0c 05 b7 84 fe 02 00			.byte	$08,$0c,$05,$b7,$84,$fe,$02,$00
>16a8	0e 6e 00 cf 07 35 10 02			.byte	$0e,$6e,$00,$cf,$07,$35,$10,$02
>16b0	bb 84 8b 44 52 00 12 6f			.byte	$bb,$84,$8b,$44,$52,$00,$12,$6f
>16b8	00 cf 17 34 09 04 14 b7			.byte	$00,$cf,$17,$34,$09,$04,$14,$b7
>16c0	84 fe 06 4d 31 58 53 00			.byte	$84,$fe,$06,$4d,$31,$58,$53,$00
>16c8	10 70 00 cf 12 b9 84 44			.byte	$10,$70,$00,$cf,$12,$b9,$84,$44
>16d0	44 fd 06 36 38 37 35 00			.byte	$44,$fd,$06,$36,$38,$37,$35,$00
>16d8	12 71 00 cf 0f 35 0a 13			.byte	$12,$71,$00,$cf,$0f,$35,$0a,$13
>16e0	0f b7 84 fe 06 50 31 4a			.byte	$0f,$b7,$84,$fe,$06,$50,$31,$4a
>16e8	4b 00 0e 72 00 cf 05 33			.byte	$4b,$00,$0e,$72,$00,$cf,$05,$33
>16f0	04 04 07 bb 84 43 56 00			.byte	$04,$04,$07,$bb,$84,$43,$56,$00
>16f8	15 73 00 cf 0b 31 04 19			.byte	$15,$73,$00,$cf,$0b,$31,$04,$19
>1700	02 b9 84 8b 47 70 fd 06			.byte	$02,$b9,$84,$8b,$47,$70,$fd,$06
>1708	30 36 32 35 00 11 74 00			.byte	$30,$36,$32,$35,$00,$11,$74,$00
>1710	cf 12 b9 84 8b 45 7f fd			.byte	$cf,$12,$b9,$84,$8b,$45,$7f,$fd
>1718	06 33 31 32 35 00 11 75			.byte	$06,$33,$31,$32,$35,$00,$11,$75
>1720	00 cf 0c b9 84 8b 44 5d			.byte	$00,$cf,$0c,$b9,$84,$8b,$44,$5d
>1728	fd 06 39 33 37 35 00 10			.byte	$fd,$06,$39,$33,$37,$35,$00,$10
>1730	76 00 cf 10 33 09 84 6d			.byte	$76,$00,$cf,$10,$33,$09,$84,$6d
>1738	fd 06 36 38 37 35 00 12			.byte	$fd,$06,$36,$38,$37,$35,$00,$12
>1740	77 00 cf 12 36 16 ba 41			.byte	$77,$00,$cf,$12,$36,$16,$ba,$41
>1748	be 84 8b 44 7c fd 03 30			.byte	$be,$84,$8b,$44,$7c,$fd,$03,$30
>1750	00 10 78 00 cf 0f 32 14			.byte	$00,$10,$78,$00,$cf,$0f,$32,$14
>1758	84 8b 44 7d fd 04 37 35			.byte	$84,$8b,$44,$7d,$fd,$04,$37,$35
>1760	00 12 79 00 cf 11 39 08			.byte	$00,$12,$79,$00,$cf,$11,$39,$08
>1768	b9 84 49 60 fd 06 36 38			.byte	$b9,$84,$49,$60,$fd,$06,$36,$38
>1770	37 35 00 13 7a 00 cf 0f			.byte	$37,$35,$00,$13,$7a,$00,$cf,$0f
>1778	34 0d 1a 0d b7 84 fe 07			.byte	$34,$0d,$1a,$0d,$b7,$84,$fe,$07
>1780	50 31 50 51 45 00 0f 7b			.byte	$50,$31,$50,$51,$45,$00,$0f,$7b
>1788	00 cf 12 b9 84 46 fd 06			.byte	$00,$cf,$12,$b9,$84,$46,$fd,$06
>1790	33 31 32 35 00 12 7c 00			.byte	$33,$31,$32,$35,$00,$12,$7c,$00
>1798	cf 0e 31 03 b9 84 8b 44			.byte	$cf,$0e,$31,$03,$b9,$84,$8b,$44
>17a0	73 fd 05 38 37 35 00 12			.byte	$73,$fd,$05,$38,$37,$35,$00,$12
>17a8	7d 00 cf 16 31 15 b9 84			.byte	$7d,$00,$cf,$16,$31,$15,$b9,$84
>17b0	48 44 fd 06 39 33 37 35			.byte	$48,$44,$fd,$06,$39,$33,$37,$35
>17b8	00 12 7e 00 cf 0c 34 04			.byte	$00,$12,$7e,$00,$cf,$0c,$34,$04
>17c0	04 1a 84 46 63 fd 05 38			.byte	$04,$1a,$84,$46,$63,$fd,$05,$38
>17c8	37 35 00 0d 7f 00 cf 0c			.byte	$37,$35,$00,$0d,$7f,$00,$cf,$0c
>17d0	33 0e bb 84 8b 4b 77 00			.byte	$33,$0e,$bb,$84,$8b,$4b,$77,$00
>17d8	0d 80 00 cf 19 30 01 b7			.byte	$0d,$80,$00,$cf,$19,$30,$01,$b7
>17e0	84 fe 03 48 00 0b 81 00			.byte	$84,$fe,$03,$48,$00,$0b,$81,$00
>17e8	cf 14 bb 84 8b 4e 45 00			.byte	$cf,$14,$bb,$84,$8b,$4e,$45,$00
>17f0	0e 82 00 cf 0f 32 14 84			.byte	$0e,$82,$00,$cf,$0f,$32,$14,$84
>17f8	46 48 fd 03 35 00 10 83			.byte	$46,$48,$fd,$03,$35,$00,$10,$83
>1800	00 cf 08 b9 84 8b 46 69			.byte	$00,$cf,$08,$b9,$84,$8b,$46,$69
>1808	fd 05 33 37 35 00 14 84			.byte	$fd,$05,$33,$37,$35,$00,$14,$84
>1810	00 cf 14 30 0f 17 0f 84			.byte	$00,$cf,$14,$30,$0f,$17,$0f,$84
>1818	8b 48 64 fd 06 36 38 37			.byte	$8b,$48,$64,$fd,$06,$36,$38,$37
>1820	35 00 10 85 00 cf 13 35			.byte	$35,$00,$10,$85,$00,$cf,$13,$35
>1828	0a 19 b9 84 49 62 fd 03			.byte	$0a,$19,$b9,$84,$49,$62,$fd,$03
>1830	35 00 0b 86 00 cf 14 bb			.byte	$35,$00,$0b,$86,$00,$cf,$14,$bb
>1838	84 8b 43 45 00 0e 87 00			.byte	$84,$8b,$43,$45,$00,$0e,$87,$00
>1840	cf 01 84 64 fd 06 30 36			.byte	$cf,$01,$84,$64,$fd,$06,$30,$36
>1848	32 35 00 10 88 00 cf 11			.byte	$32,$35,$00,$10,$88,$00,$cf,$11
>1850	35 15 0f b7 84 fe 05 54			.byte	$35,$15,$0f,$b7,$84,$fe,$05,$54
>1858	36 53 00 0d 89 00 cf 04			.byte	$36,$53,$00,$0d,$89,$00,$cf,$04
>1860	32 08 15 bb 84 4a 7b 00			.byte	$32,$08,$15,$bb,$84,$4a,$7b,$00
>1868	11 8a 00 cf 06 b9 84 8b			.byte	$11,$8a,$00,$cf,$06,$b9,$84,$8b
>1870	48 44 fd 06 34 33 37 35			.byte	$48,$44,$fd,$06,$34,$33,$37,$35
>1878	00 10 8b 00 cf 0c 30 0c			.byte	$00,$10,$8b,$00,$cf,$0c,$30,$0c
>1880	17 b9 84 44 45 fd 03 35			.byte	$17,$b9,$84,$44,$45,$fd,$03,$35
>1888	00 13 8c 00 cf 0f 36 19			.byte	$00,$13,$8c,$00,$cf,$0f,$36,$19
>1890	b9 84 8b 44 41 fd 06 34			.byte	$b9,$84,$8b,$44,$41,$fd,$06,$34
>1898	33 37 35 00 15 8d 00 cf			.byte	$33,$37,$35,$00,$15,$8d,$00,$cf
>18a0	14 33 0b 10 17 b9 84 8b			.byte	$14,$33,$0b,$10,$17,$b9,$84,$8b
>18a8	43 61 fd 06 30 36 32 35			.byte	$43,$61,$fd,$06,$30,$36,$32,$35
>18b0	00 11 8e 00 cf 08 37 10			.byte	$00,$11,$8e,$00,$cf,$08,$37,$10
>18b8	17 b9 84 41 66 fd 04 37			.byte	$17,$b9,$84,$41,$66,$fd,$04,$37
>18c0	35 00 12 8f 00 cf 17 34			.byte	$35,$00,$12,$8f,$00,$cf,$17,$34
>18c8	09 04 14 b7 84 fe 06 41			.byte	$09,$04,$14,$b7,$84,$fe,$06,$41
>18d0	38 59 44 00 0e 90 00 cf			.byte	$38,$59,$44,$00,$0e,$90,$00,$cf
>18d8	0c 35 07 19 bb 84 8b 4e			.byte	$0c,$35,$07,$19,$bb,$84,$8b,$4e
>18e0	5c 00 0d 91 00 cf 15 34			.byte	$5c,$00,$0d,$91,$00,$cf,$15,$34
>18e8	16 b7 84 fe 03 43 00 11			.byte	$16,$b7,$84,$fe,$03,$43,$00,$11
>18f0	92 00 cf 0c b9 84 8b 47			.byte	$92,$00,$cf,$0c,$b9,$84,$8b,$47
>18f8	69 fd 06 34 33 37 35 00			.byte	$69,$fd,$06,$34,$33,$37,$35,$00
>1900	11 93 00 cf 16 31 15 b9			.byte	$11,$93,$00,$cf,$16,$31,$15,$b9
>1908	84 44 5c fd 05 36 32 35			.byte	$84,$44,$5c,$fd,$05,$36,$32,$35
>1910	00 0e 94 00 cf 15 30 14			.byte	$00,$0e,$94,$00,$cf,$15,$30,$14
>1918	04 10 bb 84 4c 7f 00 12			.byte	$04,$10,$bb,$84,$4c,$7f,$00,$12
>1920	95 00 cf 11 32 04 b9 84			.byte	$95,$00,$cf,$11,$32,$04,$b9,$84
>1928	41 5f fd 06 33 31 32 35			.byte	$41,$5f,$fd,$06,$33,$31,$32,$35
>1930	00 11 96 00 cf 18 38 13			.byte	$00,$11,$96,$00,$cf,$18,$38,$13
>1938	84 41 55 fd 06 34 33 37			.byte	$84,$41,$55,$fd,$06,$34,$33,$37
>1940	35 00 10 97 00 cf 09 31			.byte	$35,$00,$10,$97,$00,$cf,$09,$31
>1948	02 14 b7 84 fe 05 53 39			.byte	$02,$14,$b7,$84,$fe,$05,$53,$39
>1950	4e 00 0e 98 00 cf 10 39			.byte	$4e,$00,$0e,$98,$00,$cf,$10,$39
>1958	10 bc 42 be 84 44 79 00			.byte	$10,$bc,$42,$be,$84,$44,$79,$00
>1960	14 99 00 cf 08 37 10 17			.byte	$14,$99,$00,$cf,$08,$37,$10,$17
>1968	b9 84 8b 44 5e fd 06 35			.byte	$b9,$84,$8b,$44,$5e,$fd,$06,$35
>1970	36 32 35 00 11 9a 00 cf			.byte	$36,$32,$35,$00,$11,$9a,$00,$cf
>1978	03 39 01 b7 84 fe 07 43			.byte	$03,$39,$01,$b7,$84,$fe,$07,$43
>1980	39 41 47 57 00 13 9b 00			.byte	$39,$41,$47,$57,$00,$13,$9b,$00
>1988	cf 16 35 14 12 b9 84 41			.byte	$cf,$16,$35,$14,$12,$b9,$84,$41
>1990	4f fd 06 31 38 37 35 00			.byte	$4f,$fd,$06,$31,$38,$37,$35,$00
>1998	10 9c 00 cf 03 39 01 b7			.byte	$10,$9c,$00,$cf,$03,$39,$01,$b7
>19a0	84 fe 06 43 37 4e 51 00			.byte	$84,$fe,$06,$43,$37,$4e,$51,$00
>19a8	11 9d 00 cf 15 34 09 03			.byte	$11,$9d,$00,$cf,$15,$34,$09,$03
>19b0	b9 84 8b 45 7e fd 03 35			.byte	$b9,$84,$8b,$45,$7e,$fd,$03,$35
>19b8	00 12 9e 00 cf 0a 31 11			.byte	$00,$12,$9e,$00,$cf,$0a,$31,$11
>19c0	13 b7 84 fe 07 44 32 57			.byte	$13,$b7,$84,$fe,$07,$44,$32,$57
>19c8	57 53 00 11 9f 00 cf 12			.byte	$57,$53,$00,$11,$9f,$00,$cf,$12
>19d0	b9 84 8b 42 75 fd 06 33			.byte	$b9,$84,$8b,$42,$75,$fd,$06,$33
>19d8	31 32 35 00 0f a0 00 cf			.byte	$31,$32,$35,$00,$0f,$a0,$00,$cf
>19e0	0f 39 0a 84 8b 47 51 fd			.byte	$0f,$39,$0a,$84,$8b,$47,$51,$fd
>19e8	03 30 00 11 a1 00 cf 04			.byte	$03,$30,$00,$11,$a1,$00,$cf,$04
>19f0	35 0a b7 84 fe 07 49 39			.byte	$35,$0a,$b7,$84,$fe,$07,$49,$39
>19f8	4e 48 58 00 16 a2 00 cf			.byte	$4e,$48,$58,$00,$16,$a2,$00,$cf
>1a00	19 35 18 14 12 bd 40 be			.byte	$19,$35,$18,$14,$12,$bd,$40,$be
>1a08	84 42 60 fd 06 33 31 32			.byte	$84,$42,$60,$fd,$06,$33,$31,$32
>1a10	35 00 0c a3 00 cf 0c 33			.byte	$35,$00,$0c,$a3,$00,$cf,$0c,$33
>1a18	0e bb 84 4c 79 00 0c a4			.byte	$0e,$bb,$84,$4c,$79,$00,$0c,$a4
>1a20	00 cf 19 38 17 bb 84 49			.byte	$00,$cf,$19,$38,$17,$bb,$84,$49
>1a28	7a 00 0e a5 00 cf 05 33			.byte	$7a,$00,$0e,$a5,$00,$cf,$05,$33
>1a30	04 04 07 bb 84 41 50 00			.byte	$04,$04,$07,$bb,$84,$41,$50,$00
>1a38	11 a6 00 cf 17 38 16 06			.byte	$11,$a6,$00,$cf,$17,$38,$16,$06
>1a40	1a 84 8b 47 60 fd 03 30			.byte	$1a,$84,$8b,$47,$60,$fd,$03,$30
>1a48	00 0f a7 00 cf 0f 32 14			.byte	$00,$0f,$a7,$00,$cf,$0f,$32,$14
>1a50	84 8b 6b fd 04 32 35 00			.byte	$84,$8b,$6b,$fd,$04,$32,$35,$00
>1a58	11 a8 00 cf 18 38 13 84			.byte	$11,$a8,$00,$cf,$18,$38,$13,$84
>1a60	8b 46 77 fd 05 38 37 35			.byte	$8b,$46,$77,$fd,$05,$38,$37,$35
>1a68	00 10 a9 00 cf 02 32 08			.byte	$00,$10,$a9,$00,$cf,$02,$32,$08
>1a70	17 b7 84 fe 05 52 36 42			.byte	$17,$b7,$84,$fe,$05,$52,$36,$42
>1a78	00 11 aa 00 cf 04 35 08			.byte	$00,$11,$aa,$00,$cf,$04,$35,$08
>1a80	84 8b 45 45 fd 05 36 32			.byte	$84,$8b,$45,$45,$fd,$05,$36,$32
>1a88	35 00 0f ab 00 cf 11 35			.byte	$35,$00,$0f,$ab,$00,$cf,$11,$35
>1a90	15 0f b7 84 fe 04 42 38			.byte	$15,$0f,$b7,$84,$fe,$04,$42,$38
>1a98	00 0f ac 00 cf 12 b9 84			.byte	$00,$0f,$ac,$00,$cf,$12,$b9,$84
>1aa0	8b 45 fd 05 38 37 35 00			.byte	$8b,$45,$fd,$05,$38,$37,$35,$00
>1aa8	12 ad 00 cf 0a 31 11 13			.byte	$12,$ad,$00,$cf,$0a,$31,$11,$13
>1ab0	b7 84 fe 07 4c 37 4f 55			.byte	$b7,$84,$fe,$07,$4c,$37,$4f,$55
>1ab8	52 00 0e ae 00 cf 05 38			.byte	$52,$00,$0e,$ae,$00,$cf,$05,$38
>1ac0	10 07 0e bb 84 48 4d 00			.byte	$10,$07,$0e,$bb,$84,$48,$4d,$00
>1ac8	10 af 00 cf 18 35 1a 02			.byte	$10,$af,$00,$cf,$18,$35,$1a,$02
>1ad0	b7 84 fe 05 5a 33 4e 00			.byte	$b7,$84,$fe,$05,$5a,$33,$4e,$00
>1ad8	10 b0 00 cf 06 32 10 b9			.byte	$10,$b0,$00,$cf,$06,$32,$10,$b9
>1ae0	84 49 5f fd 04 32 35 00			.byte	$84,$49,$5f,$fd,$04,$32,$35,$00
>1ae8	0e b1 00 cf 05 38 10 07			.byte	$0e,$b1,$00,$cf,$05,$38,$10,$07
>1af0	0e bb 84 4c 48 00 12 b2			.byte	$0e,$bb,$84,$4c,$48,$00,$12,$b2
>1af8	00 cf 0c 35 08 0c 05 b7			.byte	$00,$cf,$0c,$35,$08,$0c,$05,$b7
>1b00	84 fe 06 4c 34 48 4a 00			.byte	$84,$fe,$06,$4c,$34,$48,$4a,$00
>1b08	11 b3 00 cf 0c 35 08 0c			.byte	$11,$b3,$00,$cf,$0c,$35,$08,$0c
>1b10	05 b7 84 fe 05 56 37 52			.byte	$05,$b7,$84,$fe,$05,$56,$37,$52
>1b18	00 0b b4 00 cf 14 bb 84			.byte	$00,$0b,$b4,$00,$cf,$14,$bb,$84
>1b20	8b 48 46 00 12 b5 00 cf			.byte	$8b,$48,$46,$00,$12,$b5,$00,$cf
>1b28	0c 34 04 04 1a 84 7f fd			.byte	$0c,$34,$04,$04,$1a,$84,$7f,$fd
>1b30	06 34 33 37 35 00 0c b6			.byte	$06,$34,$33,$37,$35,$00,$0c,$b6
>1b38	00 cf 06 35 13 bb 84 47			.byte	$00,$cf,$06,$35,$13,$bb,$84,$47
>1b40	5a 00 0d b7 00 cf 02 32			.byte	$5a,$00,$0d,$b7,$00,$cf,$02,$32
>1b48	14 06 12 bb 84 7b 00 0b			.byte	$14,$06,$12,$bb,$84,$7b,$00,$0b
>1b50	b8 00 cf 0a b7 84 fe 03			.byte	$b8,$00,$cf,$0a,$b7,$84,$fe,$03
>1b58	59 00 12 b9 00 cf 11 39			.byte	$59,$00,$12,$b9,$00,$cf,$11,$39
>1b60	08 b9 84 8b 46 6a fd 05			.byte	$08,$b9,$84,$8b,$46,$6a,$fd,$05
>1b68	38 37 35 00 15 ba 00 cf			.byte	$38,$37,$35,$00,$15,$ba,$00,$cf
>1b70	04 34 02 ba 40 be 84 8b			.byte	$04,$34,$02,$ba,$40,$be,$84,$8b
>1b78	45 59 fd 06 35 36 32 35			.byte	$45,$59,$fd,$06,$35,$36,$32,$35
>1b80	00 10 bb 00 cf 11 32 04			.byte	$00,$10,$bb,$00,$cf,$11,$32,$04
>1b88	b9 84 8b 44 6b fd 03 35			.byte	$b9,$84,$8b,$44,$6b,$fd,$03,$35
>1b90	00 13 bc 00 cf 0b 37 16			.byte	$00,$13,$bc,$00,$cf,$0b,$37,$16
>1b98	05 17 b9 84 48 65 fd 05			.byte	$05,$17,$b9,$84,$48,$65,$fd,$05
>1ba0	36 32 35 00 0f bd 00 cf			.byte	$36,$32,$35,$00,$0f,$bd,$00,$cf
>1ba8	12 b9 84 43 45 fd 05 31			.byte	$12,$b9,$84,$43,$45,$fd,$05,$31
>1bb0	32 35 00 12 be 00 cf 10			.byte	$32,$35,$00,$12,$be,$00,$cf,$10
>1bb8	33 09 84 8b 43 74 fd 06			.byte	$33,$09,$84,$8b,$43,$74,$fd,$06
>1bc0	36 38 37 35 00 09 bf 00			.byte	$36,$38,$37,$35,$00,$09,$bf,$00
>1bc8	cf 14 bb 84 70 00 16 c0			.byte	$cf,$14,$bb,$84,$70,$00,$16,$c0
>1bd0	00 cf 0c 37 04 bd 40 bf			.byte	$00,$cf,$0c,$37,$04,$bd,$40,$bf
>1bd8	40 be 84 43 7c fd 06 34			.byte	$40,$be,$84,$43,$7c,$fd,$06,$34
>1be0	33 37 35 00 10 c1 00 cf			.byte	$33,$37,$35,$00,$10,$c1,$00,$cf
>1be8	01 84 8b 42 50 fd 06 31			.byte	$01,$84,$8b,$42,$50,$fd,$06,$31
>1bf0	38 37 35 00 0c c2 00 cf			.byte	$38,$37,$35,$00,$0c,$c2,$00,$cf
>1bf8	19 38 17 bb 84 4d 44 00			.byte	$19,$38,$17,$bb,$84,$4d,$44,$00
>1c00	0f c3 00 cf 0f b9 84 8b			.byte	$0f,$c3,$00,$cf,$0f,$b9,$84,$8b
>1c08	47 7e fd 04 37 35 00 13			.byte	$47,$7e,$fd,$04,$37,$35,$00,$13
>1c10	c4 00 cf 11 38 08 19 b9			.byte	$c4,$00,$cf,$11,$38,$08,$19,$b9
>1c18	84 42 46 fd 06 34 33 37			.byte	$84,$42,$46,$fd,$06,$34,$33,$37
>1c20	35 00 11 c5 00 cf 01 31			.byte	$35,$00,$11,$c5,$00,$cf,$01,$31
>1c28	02 0a 05 b9 84 44 73 fd			.byte	$02,$0a,$05,$b9,$84,$44,$73,$fd
>1c30	03 35 00 10 c6 00 cf 10			.byte	$03,$35,$00,$10,$c6,$00,$cf,$10
>1c38	34 01 bc 42 bf 40 be 84			.byte	$34,$01,$bc,$42,$bf,$40,$be,$84
>1c40	4e 55 00 0e c7 00 cf 0e			.byte	$4e,$55,$00,$0e,$c7,$00,$cf,$0e
>1c48	39 0f 04 08 bb 84 4e 55			.byte	$39,$0f,$04,$08,$bb,$84,$4e,$55
>1c50	00 12 c8 00 cf 18 38 13			.byte	$00,$12,$c8,$00,$cf,$18,$38,$13
>1c58	84 8b 49 44 fd 06 38 31			.byte	$84,$8b,$49,$44,$fd,$06,$38,$31
>1c60	32 35 00 12 c9 00 cf 0c			.byte	$32,$35,$00,$12,$c9,$00,$cf,$0c
>1c68	30 0c 17 b9 84 44 5f fd			.byte	$30,$0c,$17,$b9,$84,$44,$5f,$fd
>1c70	05 33 37 35 00 10 ca 00			.byte	$05,$33,$37,$35,$00,$10,$ca,$00
>1c78	cf 08 b9 84 8b 45 62 fd			.byte	$cf,$08,$b9,$84,$8b,$45,$62,$fd
>1c80	05 33 37 35 00 0d cb 00			.byte	$05,$33,$37,$35,$00,$0d,$cb,$00
>1c88	cf 06 35 13 bb 84 8b 44			.byte	$cf,$06,$35,$13,$bb,$84,$8b,$44
>1c90	6d 00 12 cc 00 cf 17 38			.byte	$6d,$00,$12,$cc,$00,$cf,$17,$38
>1c98	16 06 1a 84 47 64 fd 05			.byte	$16,$06,$1a,$84,$47,$64,$fd,$05
>1ca0	33 37 35 00 13 cd 00 cf			.byte	$33,$37,$35,$00,$13,$cd,$00,$cf
>1ca8	04 34 02 ba 41 be 84 41			.byte	$04,$34,$02,$ba,$41,$be,$84,$41
>1cb0	67 fd 05 36 32 35 00 13			.byte	$67,$fd,$05,$36,$32,$35,$00,$13
>1cb8	ce 00 cf 19 36 04 18 84			.byte	$ce,$00,$cf,$19,$36,$04,$18,$84
>1cc0	8b 46 71 fd 06 36 38 37			.byte	$8b,$46,$71,$fd,$06,$36,$38,$37
>1cc8	35 00 0b cf 00 cf 13 bb			.byte	$35,$00,$0b,$cf,$00,$cf,$13,$bb
>1cd0	84 8b 4c 52 00 0e d0 00			.byte	$84,$8b,$4c,$52,$00,$0e,$d0,$00
>1cd8	cf 15 34 16 b7 84 fe 04			.byte	$cf,$15,$34,$16,$b7,$84,$fe,$04
>1ce0	51 35 00 0d d1 00 cf 0a			.byte	$51,$35,$00,$0d,$d1,$00,$cf,$0a
>1ce8	31 11 13 b7 84 fe 02 00			.byte	$31,$11,$13,$b7,$84,$fe,$02,$00
>1cf0	0d d2 00 cf 08 36 09 bb			.byte	$0d,$d2,$00,$cf,$08,$36,$09,$bb
>1cf8	84 8b 4c 6f 00 0e d3 00			.byte	$84,$8b,$4c,$6f,$00,$0e,$d3,$00
>1d00	cf 0c 35 07 19 bb 84 8b			.byte	$cf,$0c,$35,$07,$19,$bb,$84,$8b
>1d08	4f 43 00 15 d4 00 cf 12			.byte	$4f,$43,$00,$15,$d4,$00,$cf,$12
>1d10	36 16 ba 40 be 84 8b 42			.byte	$36,$16,$ba,$40,$be,$84,$8b,$42
>1d18	6f fd 06 35 36 32 35 00			.byte	$6f,$fd,$06,$35,$36,$32,$35,$00
>1d20	13 d5 00 cf 0f 34 0d 1a			.byte	$13,$d5,$00,$cf,$0f,$34,$0d,$1a
>1d28	0d b7 84 fe 07 59 37 57			.byte	$0d,$b7,$84,$fe,$07,$59,$37,$57
>1d30	56 4a 00 0e d6 00 dc 0e			.byte	$56,$4a,$00,$0e,$d6,$00,$dc,$0e
>1d38	39 0f 04 08 bb 84 4e 55			.byte	$39,$0f,$04,$08,$bb,$84,$4e,$55
>1d40	00 11 d7 00 dc 01 35 19			.byte	$00,$11,$d7,$00,$dc,$01,$35,$19
>1d48	b9 84 8b 42 50 fd 04 32			.byte	$b9,$84,$8b,$42,$50,$fd,$04,$32
>1d50	35 00 0e d8 00 dc 15 34			.byte	$35,$00,$0e,$d8,$00,$dc,$15,$34
>1d58	16 b7 84 fe 04 51 35 00			.byte	$16,$b7,$84,$fe,$04,$51,$35,$00
>1d60	0d d9 00 dc 14 37 0c 09			.byte	$0d,$d9,$00,$dc,$14,$37,$0c,$09
>1d68	0f b9 84 40 00 10 da 00			.byte	$0f,$b9,$84,$40,$00,$10,$da,$00
>1d70	dc 08 b9 84 8b 45 62 fd			.byte	$dc,$08,$b9,$84,$8b,$45,$62,$fd
>1d78	05 33 37 35 00 12 db 00			.byte	$05,$33,$37,$35,$00,$12,$db,$00
>1d80	dc 10 39 08 02 18 b9 84			.byte	$dc,$10,$39,$08,$02,$18,$b9,$84
>1d88	8b 45 48 fd 03 35 00 15			.byte	$8b,$45,$48,$fd,$03,$35,$00,$15
>1d90	dc 00 dc 14 33 0b 10 17			.byte	$dc,$00,$dc,$14,$33,$0b,$10,$17
>1d98	b9 84 8b 43 61 fd 06 30			.byte	$b9,$84,$8b,$43,$61,$fd,$06,$30
>1da0	36 32 35 00 0c dd 00 dc			.byte	$36,$32,$35,$00,$0c,$dd,$00,$dc
>1da8	19 33 09 18 b9 84 40 00			.byte	$19,$33,$09,$18,$b9,$84,$40,$00
>1db0	10 de 00 dc 11 32 04 b9			.byte	$10,$de,$00,$dc,$11,$32,$04,$b9
>1db8	84 8b 44 6b fd 03 35 00			.byte	$84,$8b,$44,$6b,$fd,$03,$35,$00
>1dc0	11 df 00 dc 0c b9 84 8b			.byte	$11,$df,$00,$dc,$0c,$b9,$84,$8b
>1dc8	47 69 fd 06 34 33 37 35			.byte	$47,$69,$fd,$06,$34,$33,$37,$35
>1dd0	00 0e e0 00 dc 07 35 10			.byte	$00,$0e,$e0,$00,$dc,$07,$35,$10
>1dd8	02 bb 84 8b 44 52 00 10			.byte	$02,$bb,$84,$8b,$44,$52,$00,$10
>1de0	e1 00 dc 06 32 10 b9 84			.byte	$e1,$00,$dc,$06,$32,$10,$b9,$84
>1de8	49 5f fd 04 32 35 00 0a			.byte	$49,$5f,$fd,$04,$32,$35,$00,$0a
>1df0	e2 00 dc 17 b7 84 fe 02			.byte	$e2,$00,$dc,$17,$b7,$84,$fe,$02
>1df8	00 0b e3 00 dc 13 bb 84			.byte	$00,$0b,$e3,$00,$dc,$13,$bb,$84
>1e00	8b 4c 52 00 0e e4 00 dc			.byte	$8b,$4c,$52,$00,$0e,$e4,$00,$dc
>1e08	05 38 10 07 0e bb 84 4c			.byte	$05,$38,$10,$07,$0e,$bb,$84,$4c
>1e10	48 00 0e e5 00 dc 0c 35			.byte	$48,$00,$0e,$e5,$00,$dc,$0c,$35
>1e18	07 19 bb 84 8b 4f 43 00			.byte	$07,$19,$bb,$84,$8b,$4f,$43,$00
>1e20	13 e6 00 dc 15 32 14 11			.byte	$13,$e6,$00,$dc,$15,$32,$14,$11
>1e28	13 b7 84 fe 07 4b 35 4c			.byte	$13,$b7,$84,$fe,$07,$4b,$35,$4c
>1e30	4c 56 00 13 e7 00 dc 11			.byte	$4c,$56,$00,$13,$e7,$00,$dc,$11
>1e38	38 08 19 b9 84 42 46 fd			.byte	$38,$08,$19,$b9,$84,$42,$46,$fd
>1e40	06 34 33 37 35 00 12 e8			.byte	$06,$34,$33,$37,$35,$00,$12,$e8
>1e48	00 dc 17 34 09 04 14 b7			.byte	$00,$dc,$17,$34,$09,$04,$14,$b7
>1e50	84 fe 06 41 38 59 44 00			.byte	$84,$fe,$06,$41,$38,$59,$44,$00
>1e58	0c e9 00 dc 19 38 17 bb			.byte	$0c,$e9,$00,$dc,$19,$38,$17,$bb
>1e60	84 4d 44 00 12 ea 00 dc			.byte	$84,$4d,$44,$00,$12,$ea,$00,$dc
>1e68	0d 34 11 12 05 b9 84 8b			.byte	$0d,$34,$11,$12,$05,$b9,$84,$8b
>1e70	48 55 fd 03 35 00 0c eb			.byte	$48,$55,$fd,$03,$35,$00,$0c,$eb
>1e78	00 dc 0b 34 12 b7 84 fe			.byte	$00,$dc,$0b,$34,$12,$b7,$84,$fe
>1e80	02 00 14 ec 00 dc 08 37			.byte	$02,$00,$14,$ec,$00,$dc,$08,$37
>1e88	10 17 b9 84 8b 44 5e fd			.byte	$10,$17,$b9,$84,$8b,$44,$5e,$fd
>1e90	06 35 36 32 35 00 0c ed			.byte	$06,$35,$36,$32,$35,$00,$0c,$ed
>1e98	00 dc 01 30 05 10 bb 84			.byte	$00,$dc,$01,$30,$05,$10,$bb,$84
>1ea0	40 00 09 ee 00 dc 14 bb			.byte	$40,$00,$09,$ee,$00,$dc,$14,$bb
>1ea8	84 70 00 0e ef 00 dc 02			.byte	$84,$70,$00,$0e,$ef,$00,$dc,$02
>1eb0	35 0b b7 84 fe 04 4d 36			.byte	$35,$0b,$b7,$84,$fe,$04,$4d,$36
>1eb8	00 15 f0 00 dc 02 36 02			.byte	$00,$15,$f0,$00,$dc,$02,$36,$02
>1ec0	0c 12 b9 84 8b 42 66 fd			.byte	$0c,$12,$b9,$84,$8b,$42,$66,$fd
>1ec8	06 38 31 32 35 00 0c f1			.byte	$06,$38,$31,$32,$35,$00,$0c,$f1
>1ed0	00 dc 08 31 05 09 b9 84			.byte	$00,$dc,$08,$31,$05,$09,$b9,$84
>1ed8	40 00 10 f2 00 dc 01 84			.byte	$40,$00,$10,$f2,$00,$dc,$01,$84
>1ee0	8b 42 50 fd 06 31 38 37			.byte	$8b,$42,$50,$fd,$06,$31,$38,$37
>1ee8	35 00 08 f3 00 dc 0e 84			.byte	$35,$00,$08,$f3,$00,$dc,$0e,$84
>1ef0	40 00 0d f4 00 dc 0b 33			.byte	$40,$00,$0d,$f4,$00,$dc,$0b,$33
>1ef8	17 14 bb 84 8b 74 00 12			.byte	$17,$14,$bb,$84,$8b,$74,$00,$12
>1f00	f5 00 dc 0e 31 03 b9 84			.byte	$f5,$00,$dc,$0e,$31,$03,$b9,$84
>1f08	8b 44 73 fd 05 38 37 35			.byte	$8b,$44,$73,$fd,$05,$38,$37,$35
>1f10	00 11 f6 00 dc 04 35 0a			.byte	$00,$11,$f6,$00,$dc,$04,$35,$0a
>1f18	b7 84 fe 07 49 39 4e 48			.byte	$b7,$84,$fe,$07,$49,$39,$4e,$48
>1f20	58 00 12 f7 00 dc 08 32			.byte	$58,$00,$12,$f7,$00,$dc,$08,$32
>1f28	0b 84 8b 45 54 fd 06 31			.byte	$0b,$84,$8b,$45,$54,$fd,$06,$31
>1f30	38 37 35 00 12 f8 00 dc			.byte	$38,$37,$35,$00,$12,$f8,$00,$dc
>1f38	0f 39 15 0d 84 8b 46 49			.byte	$0f,$39,$15,$0d,$84,$8b,$46,$49
>1f40	fd 05 38 37 35 00 0e f9			.byte	$fd,$05,$38,$37,$35,$00,$0e,$f9
>1f48	00 dc 15 39 02 0c 03 b7			.byte	$00,$dc,$15,$39,$02,$0c,$03,$b7
>1f50	84 fe 02 00 0d fa 00 dc			.byte	$84,$fe,$02,$00,$0d,$fa,$00,$dc
>1f58	06 35 18 b7 84 fe 03 42			.byte	$06,$35,$18,$b7,$84,$fe,$03,$42
>1f60	00 0d fb 00 dc 12 31 02			.byte	$00,$0d,$fb,$00,$dc,$12,$31,$02
>1f68	bb 84 8b 49 7d 00 11 fc			.byte	$bb,$84,$8b,$49,$7d,$00,$11,$fc
>1f70	00 dc 13 33 13 84 8b 43			.byte	$00,$dc,$13,$33,$13,$84,$8b,$43
>1f78	60 fd 05 38 37 35 00 13			.byte	$60,$fd,$05,$38,$37,$35,$00,$13
>1f80	fd 00 dc 0f 36 19 b9 84			.byte	$fd,$00,$dc,$0f,$36,$19,$b9,$84
>1f88	8b 44 41 fd 06 34 33 37			.byte	$8b,$44,$41,$fd,$06,$34,$33,$37
>1f90	35 00 11 fe 00 dc 0c 35			.byte	$35,$00,$11,$fe,$00,$dc,$0c,$35
>1f98	08 0c 05 b7 84 fe 05 56			.byte	$08,$0c,$05,$b7,$84,$fe,$05,$56
>1fa0	37 52 00 12 ff 00 dc 11			.byte	$37,$52,$00,$12,$ff,$00,$dc,$11
>1fa8	39 08 b9 84 8b 46 6a fd			.byte	$39,$08,$b9,$84,$8b,$46,$6a,$fd
>1fb0	05 38 37 35 00 0e 00 01			.byte	$05,$38,$37,$35,$00,$0e,$00,$01
>1fb8	dc 01 31 08 b7 84 fe 04			.byte	$dc,$01,$31,$08,$b7,$84,$fe,$04
>1fc0	5a 34 00 09 01 01 dc 15			.byte	$5a,$34,$00,$09,$01,$01,$dc,$15
>1fc8	bb 84 40 00 0a 02 01 dc			.byte	$bb,$84,$40,$00,$0a,$02,$01,$dc
>1fd0	19 31 10 84 40 00 0c 03			.byte	$19,$31,$10,$84,$40,$00,$0c,$03
>1fd8	01 dc 0c 33 0e bb 84 4c			.byte	$01,$dc,$0c,$33,$0e,$bb,$84,$4c
>1fe0	79 00 0a 04 01 dc 13 30			.byte	$79,$00,$0a,$04,$01,$dc,$13,$30
>1fe8	14 84 40 00 0f 05 01 dc			.byte	$14,$84,$40,$00,$0f,$05,$01,$dc
>1ff0	0f b9 84 8b 47 7e fd 04			.byte	$0f,$b9,$84,$8b,$47,$7e,$fd,$04
>1ff8	37 35 00 0d 06 01 dc 1a			.byte	$37,$35,$00,$0d,$06,$01,$dc,$1a
>2000	35 18 b7 84 fe 03 44 00			.byte	$35,$18,$b7,$84,$fe,$03,$44,$00
>2008	0f 07 01 dc 0f 39 0a 84			.byte	$0f,$07,$01,$dc,$0f,$39,$0a,$84
>2010	8b 47 51 fd 03 30 00 0e			.byte	$8b,$47,$51,$fd,$03,$30,$00,$0e
>2018	08 01 dc 05 33 04 04 07			.byte	$08,$01,$dc,$05,$33,$04,$04,$07
>2020	bb 84 41 50 00 0b 09 01			.byte	$bb,$84,$41,$50,$00,$0b,$09,$01
>2028	dc 0a b7 84 fe 03 59 00			.byte	$dc,$0a,$b7,$84,$fe,$03,$59,$00
>2030	0d 0a 01 dc 03 36 09 bb			.byte	$0d,$0a,$01,$dc,$03,$36,$09,$bb
>2038	84 8b 4c 5f 00 11 0b 01			.byte	$84,$8b,$4c,$5f,$00,$11,$0b,$01
>2040	dc 01 31 02 0a 05 b9 84			.byte	$dc,$01,$31,$02,$0a,$05,$b9,$84
>2048	44 73 fd 03 35 00 12 0c			.byte	$44,$73,$fd,$03,$35,$00,$12,$0c
>2050	01 dc 18 38 13 84 8b 49			.byte	$01,$dc,$18,$38,$13,$84,$8b,$49
>2058	44 fd 06 38 31 32 35 00			.byte	$44,$fd,$06,$38,$31,$32,$35,$00
>2060	08 0d 01 dc 11 84 40 00			.byte	$08,$0d,$01,$dc,$11,$84,$40,$00
>2068	13 0e 01 dc 19 36 04 18			.byte	$13,$0e,$01,$dc,$19,$36,$04,$18
>2070	84 8b 46 71 fd 06 36 38			.byte	$84,$8b,$46,$71,$fd,$06,$36,$38
>2078	37 35 00 10 0f 01 dc 02			.byte	$37,$35,$00,$10,$0f,$01,$dc,$02
>2080	32 08 17 b7 84 fe 05 52			.byte	$32,$08,$17,$b7,$84,$fe,$05,$52
>2088	36 42 00 11 10 01 dc 15			.byte	$36,$42,$00,$11,$10,$01,$dc,$15
>2090	34 09 03 b9 84 8b 45 7e			.byte	$34,$09,$03,$b9,$84,$8b,$45,$7e
>2098	fd 03 35 00 10 11 01 dc			.byte	$fd,$03,$35,$00,$10,$11,$01,$dc
>20a0	18 35 1a 02 b7 84 fe 05			.byte	$18,$35,$1a,$02,$b7,$84,$fe,$05
>20a8	5a 33 4e 00 10 12 01 dc			.byte	$5a,$33,$4e,$00,$10,$12,$01,$dc
>20b0	09 31 02 14 b7 84 fe 05			.byte	$09,$31,$02,$14,$b7,$84,$fe,$05
>20b8	53 39 4e 00 11 13 01 dc			.byte	$53,$39,$4e,$00,$11,$13,$01,$dc
>20c0	16 31 15 b9 84 44 5c fd			.byte	$16,$31,$15,$b9,$84,$44,$5c,$fd
>20c8	05 36 32 35 00 0a 14 01			.byte	$05,$36,$32,$35,$00,$0a,$14,$01
>20d0	dc 05 35 07 84 40 00 12			.byte	$dc,$05,$35,$07,$84,$40,$00,$12
>20d8	15 01 dc 17 38 16 06 1a			.byte	$15,$01,$dc,$17,$38,$16,$06,$1a
>20e0	84 47 64 fd 05 33 37 35			.byte	$84,$47,$64,$fd,$05,$33,$37,$35
>20e8	00 0d 16 01 dc 02 32 14			.byte	$00,$0d,$16,$01,$dc,$02,$32,$14
>20f0	06 12 bb 84 7b 00 10 17			.byte	$06,$12,$bb,$84,$7b,$00,$10,$17
>20f8	01 dc 1a b9 84 42 71 fd			.byte	$01,$dc,$1a,$b9,$84,$42,$71,$fd
>2100	06 31 38 37 35 00 0f 18			.byte	$06,$31,$38,$37,$35,$00,$0f,$18
>2108	01 dc 0c 32 13 84 7a fd			.byte	$01,$dc,$0c,$32,$13,$84,$7a,$fd
>2110	05 33 37 35 00 12 19 01			.byte	$05,$33,$37,$35,$00,$12,$19,$01
>2118	dc 0c 34 04 04 1a 84 7f			.byte	$dc,$0c,$34,$04,$04,$1a,$84,$7f
>2120	fd 06 34 33 37 35 00 13			.byte	$fd,$06,$34,$33,$37,$35,$00,$13
>2128	1a 01 dc 0b 37 16 05 17			.byte	$1a,$01,$dc,$0b,$37,$16,$05,$17
>2130	b9 84 48 65 fd 05 36 32			.byte	$b9,$84,$48,$65,$fd,$05,$36,$32
>2138	35 00 13 1b 01 dc 16 35			.byte	$35,$00,$13,$1b,$01,$dc,$16,$35
>2140	14 12 b9 84 41 4f fd 06			.byte	$14,$12,$b9,$84,$41,$4f,$fd,$06
>2148	31 38 37 35 00 0f 1c 01			.byte	$31,$38,$37,$35,$00,$0f,$1c,$01
>2150	dc 0d 35 06 0b 14 bb 84			.byte	$dc,$0d,$35,$06,$0b,$14,$bb,$84
>2158	8b 48 5a 00 11 1d 01 dc			.byte	$8b,$48,$5a,$00,$11,$1d,$01,$dc
>2160	04 35 08 84 8b 45 45 fd			.byte	$04,$35,$08,$84,$8b,$45,$45,$fd
>2168	05 36 32 35 00 12 1e 01			.byte	$05,$36,$32,$35,$00,$12,$1e,$01
>2170	dc 0a 39 1a 05 0a 84 43			.byte	$dc,$0a,$39,$1a,$05,$0a,$84,$43
>2178	7c fd 05 31 32 35 00 10			.byte	$7c,$fd,$05,$31,$32,$35,$00,$10
>2180	1f 01 dc 04 30 07 b7 84			.byte	$1f,$01,$dc,$04,$30,$07,$b7,$84
>2188	fe 06 43 38 4f 43 00 14			.byte	$fe,$06,$43,$38,$4f,$43,$00,$14
>2190	20 01 dc 14 30 0f 17 0f			.byte	$20,$01,$dc,$14,$30,$0f,$17,$0f
>2198	84 8b 48 64 fd 06 36 38			.byte	$84,$8b,$48,$64,$fd,$06,$36,$38
>21a0	37 35 00 0c 21 01 dc 04			.byte	$37,$35,$00,$0c,$21,$01,$dc,$04
>21a8	37 03 1a bb 84 40 00 0d			.byte	$37,$03,$1a,$bb,$84,$40,$00,$0d
>21b0	22 01 dc 17 35 09 08 12			.byte	$22,$01,$dc,$17,$35,$09,$08,$12
>21b8	bb 84 66 00 0d 23 01 dc			.byte	$bb,$84,$66,$00,$0d,$23,$01,$dc
>21c0	19 30 01 b7 84 fe 03 48			.byte	$19,$30,$01,$b7,$84,$fe,$03,$48
>21c8	00 0e 24 01 dc 0d b9 84			.byte	$00,$0e,$24,$01,$dc,$0d,$b9,$84
>21d0	44 59 fd 04 32 35 00 0d			.byte	$44,$59,$fd,$04,$32,$35,$00,$0d
>21d8	25 01 dc 06 35 13 bb 84			.byte	$25,$01,$dc,$06,$35,$13,$bb,$84
>21e0	8b 44 6d 00 13 26 01 dc			.byte	$8b,$44,$6d,$00,$13,$26,$01,$dc
>21e8	0f 34 0d 1a 0d b7 84 fe			.byte	$0f,$34,$0d,$1a,$0d,$b7,$84,$fe
>21f0	07 59 37 57 56 4a 00 10			.byte	$07,$59,$37,$57,$56,$4a,$00,$10
>21f8	27 01 dc 19 84 8b 49 5e			.byte	$27,$01,$dc,$19,$84,$8b,$49,$5e
>2200	fd 06 39 33 37 35 00 12			.byte	$fd,$06,$39,$33,$37,$35,$00,$12
>2208	28 01 dc 0f 35 0a 13 0f			.byte	$28,$01,$dc,$0f,$35,$0a,$13,$0f
>2210	b7 84 fe 06 50 31 4a 4b			.byte	$b7,$84,$fe,$06,$50,$31,$4a,$4b
>2218	00 0f 29 01 dc 0f 32 14			.byte	$00,$0f,$29,$01,$dc,$0f,$32,$14
>2220	84 8b 6b fd 04 32 35 00			.byte	$84,$8b,$6b,$fd,$04,$32,$35,$00
>2228	0f 2a 01 dc 11 35 15 0f			.byte	$0f,$2a,$01,$dc,$11,$35,$15,$0f
>2230	b7 84 fe 04 42 38 00 10			.byte	$b7,$84,$fe,$04,$42,$38,$00,$10
>2238	2b 01 dc 13 35 0a 19 b9			.byte	$2b,$01,$dc,$13,$35,$0a,$19,$b9
>2240	84 49 62 fd 03 35 00 12			.byte	$84,$49,$62,$fd,$03,$35,$00,$12
>2248	2c 01 dc 10 33 09 84 8b			.byte	$2c,$01,$dc,$10,$33,$09,$84,$8b
>2250	43 74 fd 06 36 38 37 35			.byte	$43,$74,$fd,$06,$36,$38,$37,$35
>2258	00 0e 2d 01 dc 15 30 14			.byte	$00,$0e,$2d,$01,$dc,$15,$30,$14
>2260	04 10 bb 84 4c 7f 00 0f			.byte	$04,$10,$bb,$84,$4c,$7f,$00,$0f
>2268	2e 01 dc 12 b9 84 43 45			.byte	$2e,$01,$dc,$12,$b9,$84,$43,$45
>2270	fd 05 31 32 35 00 0d 2f			.byte	$fd,$05,$31,$32,$35,$00,$0d,$2f
>2278	01 dc 16 37 1a 05 b7 84			.byte	$01,$dc,$16,$37,$1a,$05,$b7,$84
>2280	fe 02 00 0d 30 01 dc 04			.byte	$fe,$02,$00,$0d,$30,$01,$dc,$04
>2288	32 08 15 bb 84 4a 7b 00			.byte	$32,$08,$15,$bb,$84,$4a,$7b,$00
>2290	0d 31 01 dc 0a 31 11 13			.byte	$0d,$31,$01,$dc,$0a,$31,$11,$13
>2298	b7 84 fe 02 00 0f 32 01			.byte	$b7,$84,$fe,$02,$00,$0f,$32,$01
>22a0	dc 16 b7 84 fe 07 41 38			.byte	$dc,$16,$b7,$84,$fe,$07,$41,$38
>22a8	52 52 50 00 11 33 01 dc			.byte	$52,$52,$50,$00,$11,$33,$01,$dc
>22b0	06 b9 84 8b 48 44 fd 06			.byte	$06,$b9,$84,$8b,$48,$44,$fd,$06
>22b8	34 33 37 35 00 0c 34 01			.byte	$34,$33,$37,$35,$00,$0c,$34,$01
>22c0	dc 11 34 11 08 10 84 40			.byte	$dc,$11,$34,$11,$08,$10,$84,$40
>22c8	00 15 35 01 dc 0b 31 04			.byte	$00,$15,$35,$01,$dc,$0b,$31,$04
>22d0	19 02 b9 84 8b 47 70 fd			.byte	$19,$02,$b9,$84,$8b,$47,$70,$fd
>22d8	06 30 36 32 35 00 10 36			.byte	$06,$30,$36,$32,$35,$00,$10,$36
>22e0	01 dc 03 39 01 b7 84 fe			.byte	$01,$dc,$03,$39,$01,$b7,$84,$fe
>22e8	06 43 37 4e 51 00 10 37			.byte	$06,$43,$37,$4e,$51,$00,$10,$37
>22f0	01 dc 10 34 0b b7 84 fe			.byte	$01,$dc,$10,$34,$0b,$b7,$84,$fe
>22f8	06 4e 32 4b 59 00 12 38			.byte	$06,$4e,$32,$4b,$59,$00,$12,$38
>2300	01 dc 0c 30 0c 17 b9 84			.byte	$01,$dc,$0c,$30,$0c,$17,$b9,$84
>2308	44 5f fd 05 33 37 35 00			.byte	$44,$5f,$fd,$05,$33,$37,$35,$00
>2310	0d 39 01 dc 08 36 09 bb			.byte	$0d,$39,$01,$dc,$08,$36,$09,$bb
>2318	84 8b 4c 6f 00 17 3a 01			.byte	$84,$8b,$4c,$6f,$00,$17,$3a,$01
>2320	dc 03 39 0c ba 40 be 84			.byte	$dc,$03,$39,$0c,$ba,$40,$be,$84
>2328	40 c0 dc 03 39 0c ba 41			.byte	$40,$c0,$dc,$03,$39,$0c,$ba,$41
>2330	be 84 40 00 27 3b 01 dc			.byte	$be,$84,$40,$00,$27,$3b,$01,$dc
>2338	08 39 01 19 19 ba 40 be			.byte	$08,$39,$01,$19,$19,$ba,$40,$be
>2340	84 40 c0 dc 08 39 01 19			.byte	$84,$40,$c0,$dc,$08,$39,$01,$19
>2348	19 ba 41 be 84 40 c0 dc			.byte	$19,$ba,$41,$be,$84,$40,$c0,$dc
>2350	08 39 01 19 19 ba 42 be			.byte	$08,$39,$01,$19,$19,$ba,$42,$be
>2358	84 40 00 2f 3c 01 dc 0c			.byte	$84,$40,$00,$2f,$3c,$01,$dc,$0c
>2360	36 02 1a 11 ba 40 be 84			.byte	$36,$02,$1a,$11,$ba,$40,$be,$84
>2368	8b 48 46 fd 06 36 38 37			.byte	$8b,$48,$46,$fd,$06,$36,$38,$37
>2370	35 c0 dc 0c 36 02 1a 11			.byte	$35,$c0,$dc,$0c,$36,$02,$1a,$11
>2378	ba 41 be 84 40 c0 dc 0c			.byte	$ba,$41,$be,$84,$40,$c0,$dc,$0c
>2380	36 02 1a 11 ba 42 be 84			.byte	$36,$02,$1a,$11,$ba,$42,$be,$84
>2388	40 00 22 3d 01 dc 19 35			.byte	$40,$00,$22,$3d,$01,$dc,$19,$35
>2390	18 14 12 bd 40 be 84 42			.byte	$18,$14,$12,$bd,$40,$be,$84,$42
>2398	60 fd 06 33 31 32 35 c0			.byte	$60,$fd,$06,$33,$31,$32,$35,$c0
>23a0	dc 19 35 18 14 12 bd 41			.byte	$dc,$19,$35,$18,$14,$12,$bd,$41
>23a8	be 84 40 00 2f 3e 01 dc			.byte	$be,$84,$40,$00,$2f,$3e,$01,$dc
>23b0	04 34 02 ba 40 be 84 8b			.byte	$04,$34,$02,$ba,$40,$be,$84,$8b
>23b8	45 59 fd 06 35 36 32 35			.byte	$45,$59,$fd,$06,$35,$36,$32,$35
>23c0	c0 dc 04 34 02 ba 41 be			.byte	$c0,$dc,$04,$34,$02,$ba,$41,$be
>23c8	84 41 67 fd 05 36 32 35			.byte	$84,$41,$67,$fd,$05,$36,$32,$35
>23d0	c0 dc 04 34 02 ba 42 be			.byte	$c0,$dc,$04,$34,$02,$ba,$42,$be
>23d8	84 40 00 3a 3f 01 dc 0c			.byte	$84,$40,$00,$3a,$3f,$01,$dc,$0c
>23e0	37 04 bd 40 bf 40 be 84			.byte	$37,$04,$bd,$40,$bf,$40,$be,$84
>23e8	43 7c fd 06 34 33 37 35			.byte	$43,$7c,$fd,$06,$34,$33,$37,$35
>23f0	c0 dc 0c 37 04 bd 40 bf			.byte	$c0,$dc,$0c,$37,$04,$bd,$40,$bf
>23f8	41 be 84 40 c0 dc 0c 37			.byte	$41,$be,$84,$40,$c0,$dc,$0c,$37
>2400	04 bd 41 bf 40 be 84 40			.byte	$04,$bd,$41,$bf,$40,$be,$84,$40
>2408	c0 dc 0c 37 04 bd 41 bf			.byte	$c0,$dc,$0c,$37,$04,$bd,$41,$bf
>2410	41 be 84 40 00 2e 40 01			.byte	$41,$be,$84,$40,$00,$2e,$40,$01
>2418	dc 12 36 16 ba 40 be 84			.byte	$dc,$12,$36,$16,$ba,$40,$be,$84
>2420	8b 42 6f fd 06 35 36 32			.byte	$8b,$42,$6f,$fd,$06,$35,$36,$32
>2428	35 c0 dc 12 36 16 ba 41			.byte	$35,$c0,$dc,$12,$36,$16,$ba,$41
>2430	be 84 8b 44 7c fd 03 30			.byte	$be,$84,$8b,$44,$7c,$fd,$03,$30
>2438	c0 dc 12 36 16 ba 42 be			.byte	$c0,$dc,$12,$36,$16,$ba,$42,$be
>2440	84 40 00 20 41 01 dc 13			.byte	$84,$40,$00,$20,$41,$01,$dc,$13
>2448	31 0a 02 b8 40 be 84 fe			.byte	$31,$0a,$02,$b8,$40,$be,$84,$fe
>2450	05 56 35 57 c0 dc 13 31			.byte	$05,$56,$35,$57,$c0,$dc,$13,$31
>2458	0a 02 b8 41 be 84 fe 04			.byte	$0a,$02,$b8,$41,$be,$84,$fe,$04
>2460	4a 33 00 70 42 01 dc 10			.byte	$4a,$33,$00,$70,$42,$01,$dc,$10
>2468	34 01 bc 40 bf 40 be 84			.byte	$34,$01,$bc,$40,$bf,$40,$be,$84
>2470	40 c0 dc 10 34 01 bc 40			.byte	$40,$c0,$dc,$10,$34,$01,$bc,$40
>2478	bf 41 be 84 40 c0 dc 10			.byte	$bf,$41,$be,$84,$40,$c0,$dc,$10
>2480	34 01 bc 40 bf 42 be 84			.byte	$34,$01,$bc,$40,$bf,$42,$be,$84
>2488	40 c0 dc 10 34 01 bc 41			.byte	$40,$c0,$dc,$10,$34,$01,$bc,$41
>2490	bf 40 be 84 40 c0 dc 10			.byte	$bf,$40,$be,$84,$40,$c0,$dc,$10
>2498	34 01 bc 41 bf 41 be 84			.byte	$34,$01,$bc,$41,$bf,$41,$be,$84
>24a0	40 c0 dc 10 34 01 bc 41			.byte	$40,$c0,$dc,$10,$34,$01,$bc,$41
>24a8	bf 42 be 84 40 c0 dc 10			.byte	$bf,$42,$be,$84,$40,$c0,$dc,$10
>24b0	34 01 bc 42 bf 40 be 84			.byte	$34,$01,$bc,$42,$bf,$40,$be,$84
>24b8	4e 55 c0 dc 10 34 01 bc			.byte	$4e,$55,$c0,$dc,$10,$34,$01,$bc
>24c0	42 bf 41 be 84 40 c0 dc			.byte	$42,$bf,$41,$be,$84,$40,$c0,$dc
>24c8	10 34 01 bc 42 bf 42 be			.byte	$10,$34,$01,$bc,$42,$bf,$42,$be
>24d0	84 40 00 19 43 01 dc 09			.byte	$84,$40,$00,$19,$43,$01,$dc,$09
>24d8	37 04 12 bc 40 be 84 40			.byte	$37,$04,$12,$bc,$40,$be,$84,$40
>24e0	c0 dc 09 37 04 12 bc 41			.byte	$c0,$dc,$09,$37,$04,$12,$bc,$41
>24e8	be 84 40 00 22 44 01 dc			.byte	$be,$84,$40,$00,$22,$44,$01,$dc
>24f0	10 39 10 bc 40 be 84 40			.byte	$10,$39,$10,$bc,$40,$be,$84,$40
>24f8	c0 dc 10 39 10 bc 41 be			.byte	$c0,$dc,$10,$39,$10,$bc,$41,$be
>2500	84 40 c0 dc 10 39 10 bc			.byte	$84,$40,$c0,$dc,$10,$39,$10,$bc
>2508	42 be 84 44 79 00 1c 45			.byte	$42,$be,$84,$44,$79,$00,$1c,$45
>2510	01 dc 10 39 14 03 04 bc			.byte	$01,$dc,$10,$39,$14,$03,$04,$bc
>2518	40 be 84 48 41 c0 dc 10			.byte	$40,$be,$84,$48,$41,$c0,$dc,$10
>2520	39 14 03 04 bc 41 be 84			.byte	$39,$14,$03,$04,$bc,$41,$be,$84
>2528	40 00 1b 46 01 d6 fe 14			.byte	$40,$00,$1b,$46,$01,$d6,$fe,$14
>2530	50 61 73 73 65 64 20 41			.byte	$50,$61,$73,$73,$65,$64,$20,$41
>2538	73 73 69 67 6e 6d 65 6e			.byte	$73,$73,$69,$67,$6e,$6d,$65,$6e
>2540	74 2e c0 c4 00 00			.byte	$74,$2e,$c0,$c4,$00,$00

;******  Return to file: modules/hardware/em65816.asm

.c000					StartROM:
.c000	18		clc				clc
.c001	fb		xce				xce
.c002	c2 30		rep #$30			rep 	#$30
.c004	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.c007	1b		tcs				tcs
.c008	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.c00b	e2 30		sep #$30			sep 	#$30
.c00d	c2 30		rep #$30			rep 	#$30						; clear AXY in 16 bit.
.c00f	a9 00		lda #$00			lda 	#$0000
.c011	aa		tax				tax
.c012	a8		tay				tay
.c013	e2 30		sep #$30			sep 	#$30
.c015	5c b4 86 01	jmp $0186b4		jmp BASIC_Start
.c019					TIM_BreakHandler:
.c019	5c 76 83 01	jmp $018376			jmp 	TIM_BreakVector

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.018000					IFT_ClearScreen:
.018000	48		pha				pha
.018001	da		phx				phx
.018002	5a		phy				phy
.018003	20 a9 81	jsr $0181a9			jsr 	IF_Home 					; home cursor
.018006	a2 20		ldx #$20			ldx 	#IF_Height 					; this many lines.
.018008					_IFT_CS0:
.018008	a0 40		ldy #$40			ldy 	#IF_Width 					; this many chars/line
.01800a					_IFT_CS1:
.01800a	a9 20		lda #$20			lda 	#' '						; clear line.
.01800c	20 d5 81	jsr $0181d5			jsr 	IF_Write
.01800f	88		dey				dey
.018010	d0 f8		bne $01800a			bne 	_IFT_CS1
.018012	20 bc 81	jsr $0181bc			jsr 	IF_NewLine 					; next line down
.018015	ca		dex				dex
.018016	d0 f0		bne $018008			bne 	_IFT_CS0
.018018	7a		ply				ply
.018019	fa		plx				plx
.01801a	68		pla				pla
.01801b					IFT_HomeCursor:
.01801b	48		pha				pha
.01801c	20 a9 81	jsr $0181a9			jsr 	IF_Home
.01801f	a9 00		lda #$00			lda 	#0
.018021	8d 00 02	sta $0200			sta 	IFT_XCursor
.018024	8d 01 02	sta $0201			sta 	IFT_YCursor
.018027	68		pla				pla
.018028	60		rts				rts
.018029					IFT_UpLine:
.018029	48		pha				pha
.01802a	ad 01 02	lda $0201			lda  	IFT_YCursor 				; get Y
.01802d	3a		dec a				dec 	a 							; line above
.01802e	30 03		bmi $018033			bmi 	_IFTULExit 					; too far, abort
.018030	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos					; set to that line.
.018033					_IFTULExit:
.018033	68		pla				pla
.018034	60		rts				rts
.018035					IFT_PrintCharacter:
.018035	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.018037	f0 23		beq $01805c			beq 	IFT_NewLine
.018039	48		pha				pha
.01803a	20 74 80	jsr $018074			jsr 	IFT_UpperCase 				; make upper case
.01803d	20 d5 81	jsr $0181d5			jsr 	IF_Write 					; write out.
.018040	ee 00 02	inc $0200			inc 	IFT_XCursor 				; bump x cursor
.018043	ad 00 02	lda $0200			lda 	IFT_XCursor 				; reached RHS ?
.018046	c9 40		cmp #$40			cmp 	#IF_Width
.018048	d0 03		bne $01804d			bne 	_IFT_PCNotEOL
.01804a	20 5c 80	jsr $01805c			jsr 	IFT_NewLine 				; if so do new line.
.01804d					_IFT_PCNotEOL:
.01804d	68		pla				pla
.01804e	60		rts				rts
.01804f					IFT_Tab:
.01804f	a9 20		lda #$20			lda 	#" " 						; space
.018051	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018054	ad 00 02	lda $0200			lda 	IFT_XCursor 				; until x % 8 == 0
.018057	29 07		and #$07			and 	#7
.018059	d0 f4		bne $01804f			bne 	IFT_Tab
.01805b	60		rts				rts
.01805c					IFT_NewLine:
.01805c	48		pha				pha
.01805d	20 bc 81	jsr $0181bc			jsr 	IF_NewLine 					; new line on actual screen.
.018060	a9 00		lda #$00			lda 	#0 							; reset x position
.018062	8d 00 02	sta $0200			sta 	IFT_XCursor
.018065	ee 01 02	inc $0201			inc 	IFT_YCursor 				; move down.
.018068	ad 01 02	lda $0201			lda 	IFT_YCursor
.01806b	c9 20		cmp #$20			cmp 	#IF_Height 					; reached bottom.
.01806d	d0 03		bne $018072			bne 	_IFT_NL_NotEOS
.01806f	20 7f 80	jsr $01807f			jsr 	IFT_Scroll 					; scroll screen up.
.018072					_IFT_NL_NotEOS:
.018072	68		pla				pla
.018073	60		rts				rts
.018074					IFT_UpperCase:
.018074	c9 61		cmp #$61			cmp 	#"a"
.018076	90 06		bcc $01807e			bcc 	_IFT_UCExit
.018078	c9 7b		cmp #$7b			cmp 	#"z"+1
.01807a	b0 02		bcs $01807e			bcs 	_IFT_UCExit
.01807c	49 20		eor #$20			eor 	#$20
.01807e					_IFT_UCExit:
.01807e	60		rts				rts
.01807f					IFT_Scroll:
.01807f	48		pha				pha 								; save AXY
.018080	da		phx				phx
.018081	5a		phy				phy
.018082	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.018084					_IFT_SLoop:
.018084	20 a4 80	jsr $0180a4			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.018087	e8		inx				inx
.018088	e0 1f		cpx #$1f			cpx 	#IF_Height-1				; do whole screen
.01808a	d0 f8		bne $018084			bne 	_IFT_SLoop
.01808c	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.01808e	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.018091	a2 40		ldx #$40			ldx 	#IF_Width 					; blank line
.018093					_IFT_SBlank:
.018093	a9 20		lda #$20			lda 	#32
.018095	20 d5 81	jsr $0181d5			jsr 	IF_Write
.018098	ca		dex				dex
.018099	d0 f8		bne $018093			bne 	_IFT_SBlank
.01809b	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.01809d	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.0180a0	7a		ply				ply
.0180a1	fa		plx				plx
.0180a2	68		pla				pla
.0180a3	60		rts				rts
.0180a4					_IFT_ScrollLine:
.0180a4	da		phx				phx
.0180a5	da		phx				phx
.0180a6	8a		txa				txa 								; copy line into buffer.
.0180a7	1a		inc a				inc 	a 							; next line down.
.0180a8	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.0180ab	a2 00		ldx #$00			ldx 	#0
.0180ad					_IFTScrollCopy1:
.0180ad	20 cc 81	jsr $0181cc			jsr 	IF_Read
.0180b0	9d 02 02	sta $0202,x			sta 	IFT_Buffer,x
.0180b3	e8		inx				inx
.0180b4	e0 40		cpx #$40			cpx 	#IF_Width
.0180b6	d0 f5		bne $0180ad			bne 	_IFTScrollCopy1
.0180b8	68		pla				pla
.0180b9	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.0180bc	a2 00		ldx #$00			ldx 	#0
.0180be					_IFTScrollCopy2:
.0180be	bd 02 02	lda $0202,x			lda 	IFT_Buffer,x
.0180c1	20 d5 81	jsr $0181d5			jsr 	IF_Write
.0180c4	e8		inx				inx
.0180c5	e0 40		cpx #$40			cpx 	#IF_Width
.0180c7	d0 f5		bne $0180be			bne 	_IFTScrollCopy2
.0180c9	fa		plx				plx
.0180ca	60		rts				rts
.0180cb					IFT_SetYPos:
.0180cb	48		pha				pha
.0180cc	da		phx				phx
.0180cd	aa		tax				tax
.0180ce	20 1b 80	jsr $01801b			jsr 	IFT_HomeCursor
.0180d1	e0 00		cpx #$00			cpx 	#0
.0180d3	f0 09		beq $0180de			beq 	_IFT_MOAExit
.0180d5					_IFT_MOALoop:
.0180d5	20 bc 81	jsr $0181bc			jsr 	IF_NewLine
.0180d8	ee 01 02	inc $0201			inc 	IFT_YCursor
.0180db	ca		dex				dex
.0180dc	d0 f7		bne $0180d5			bne		_IFT_MOALoop
.0180de					_IFT_MOAExit:
.0180de	fa		plx				plx
.0180df	68		pla				pla
.0180e0	60		rts				rts
.0180e1					IFT_GetKeyCursor:
.0180e1	20 e9 80	jsr $0180e9			jsr 	_IFT_FlipCursor 			; reverse current
.0180e4					_IFT_GKCWait:
.0180e4	20 e6 81	jsr $0181e6			jsr 	IF_GetKey 					; get key
.0180e7	f0 fb		beq $0180e4			beq 	_IFT_GKCWait
.0180e9					_IFT_FlipCursor:
.0180e9	48		pha				pha 								; save
.0180ea	20 cc 81	jsr $0181cc			jsr 	IF_Read 					; read
.0180ed	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.0180f0	49 80		eor #$80			eor 	#$80 						; reverse
.0180f2	20 d5 81	jsr $0181d5			jsr 	IF_Write 					; write
.0180f5	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.0180f8	68		pla				pla
.0180f9	60		rts				rts
.0180fa					IFT_ReadLine:
.0180fa	48		pha				pha
.0180fb					_IFT_RLLoop:
.0180fb	20 e1 80	jsr $0180e1			jsr 	IFT_GetKeyCursor 			; get keystroke
.0180fe	c9 0d		cmp #$0d			cmp 	#13							; return
.018100	f0 7d		beq $01817f			beq 	_IFT_RLExit
.018102	c9 20		cmp #$20			cmp 	#32 						; control character
.018104	90 05		bcc $01810b			bcc 	_IFT_Control
.018106	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018109	80 f0		bra $0180fb			bra 	_IFT_RLLoop
.01810b					_IFT_Control:
.01810b	c9 01		cmp #$01			cmp 	#"A"-64
.01810d	f0 26		beq $018135			beq 	_IFT_Left
.01810f	c9 04		cmp #$04			cmp 	#"D"-64
.018111	f0 2e		beq $018141			beq 	_IFT_Right
.018113	c9 17		cmp #$17			cmp 	#"W"-64
.018115	f0 36		beq $01814d			beq 	_IFT_Up
.018117	c9 13		cmp #$13			cmp 	#"S"-64
.018119	f0 3e		beq $018159			beq 	_IFT_Down
.01811b	c9 08		cmp #$08			cmp 	#"H"-64
.01811d	f0 09		beq $018128			beq 	_IFT_Backspace
.01811f	c9 1a		cmp #$1a			cmp 	#"Z"-64
.018121	d0 d8		bne $0180fb			bne 	_IFT_RLLoop
.018123	20 00 80	jsr $018000			jsr 	IFT_ClearScreen				; clear CTL-Z
.018126	80 d3		bra $0180fb			bra 	_IFT_RLLoop
.018128					_IFT_Backspace:
.018128	ad 00 02	lda $0200			lda 	IFT_XCursor 				; check not start of line.
.01812b	f0 ce		beq $0180fb			beq 	_IFT_RLLoop
.01812d	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.018130	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.018132	20 d5 81	jsr $0181d5			jsr 	IF_Write
.018135					_IFT_Left:
.018135	ce 00 02	dec $0200			dec 	IFT_XCursor 				; left CTL-W
.018138	10 29		bpl $018163			bpl 	_IFT_Reposition
.01813a	a9 3f		lda #$3f			lda 	#IF_Width-1
.01813c					_IFT_SetX:
.01813c	8d 00 02	sta $0200			sta 	IFT_XCursor
.01813f	80 22		bra $018163			bra 	_IFT_Reposition
.018141					_IFT_Right:
.018141	ee 00 02	inc $0200			inc 	IFT_XCursor
.018144	ad 00 02	lda $0200			lda 	IFT_XCursor
.018147	49 40		eor #$40			eor 	#IF_Width
.018149	f0 f1		beq $01813c			beq 	_IFT_SetX
.01814b	80 16		bra $018163			bra 	_IFT_Reposition
.01814d					_IFT_Up:
.01814d	ce 01 02	dec $0201			dec 	IFT_YCursor
.018150	10 11		bpl $018163			bpl 	_IFT_Reposition
.018152	a9 1f		lda #$1f			lda 	#IF_Height-1
.018154					_IFT_SetY:
.018154	8d 01 02	sta $0201			sta 	IFT_YCursor
.018157	80 0a		bra $018163			bra 	_IFT_Reposition
.018159					_IFT_Down:
.018159	ee 01 02	inc $0201			inc 	IFT_YCursor
.01815c	ad 01 02	lda $0201			lda 	IFT_YCursor
.01815f	49 20		eor #$20			eor 	#IF_Height
.018161	f0 f1		beq $018154			beq 	_IFT_SetY
.018163					_IFT_Reposition:
.018163	ad 00 02	lda $0200			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.018166	48		pha				pha
.018167	ad 01 02	lda $0201			lda 	IFT_YCursor
.01816a	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.01816d	68		pla				pla
.01816e	aa		tax				tax
.01816f	e0 00		cpx #$00			cpx 	#0
.018171	f0 88		beq $0180fb			beq 	_IFT_RLLoop
.018173					_IFT_MoveRight:
.018173	20 cc 81	jsr $0181cc			jsr 	IF_Read
.018176	ee 00 02	inc $0200			inc 	IFT_XCursor
.018179	ca		dex				dex
.01817a	d0 f7		bne $018173			bne 	_IFT_MoveRight
.01817c	4c fb 80	jmp $0180fb			jmp 	_IFT_RLLoop
.01817f					_IFT_RLExit:
.01817f	ad 01 02	lda $0201			lda 	IFT_YCursor 				; go to start of line.
.018182	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.018185	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.018187					_IFT_RLRead:
.018187	20 cc 81	jsr $0181cc			jsr 	IF_Read
.01818a	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.01818d	e8		inx				inx
.01818e	e0 40		cpx #$40			cpx 	#IF_Width
.018190	d0 f5		bne $018187			bne 	_IFT_RLRead
.018192					_IFT_RL_Trim:
.018192	ca		dex				dex 	 							; previous char
.018193	30 07		bmi $01819c			bmi 	_IFT_Found 					; gone too far
.018195	bd 66 02	lda $0266,x			lda 	IFT_LineBuffer,x			; go back if space
.018198	c9 20		cmp #$20			cmp 	#" "
.01819a	f0 f6		beq $018192			beq 	_IFT_RL_Trim
.01819c					_IFT_Found:
.01819c	e8		inx				inx 								; forward to non-space
.01819d	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.01819f	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.0181a2	68		pla				pla
.0181a3	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.0181a5	a0 02		ldy #$02			ldy 	#IFT_LineBuffer >> 8
.0181a7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_em65816.asm

=64					IF_Width 	= 64 							; characters across
=32					IF_Height 	= 32 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line.
=8					IF_XPos 	= 8 							; current position, horizontal.
=$f0000					IF_Screen = $F0000							; 2k screen RAM here
=$f8010					IF_PKeyboard = $F8010						; Keyboard port.
=$f8000					IF_PBreak = $F8000 							; Break key.
.0181a8					IF_Reset:
.0181a8	60		rts				rts
.0181a9					IF_Home:
.0181a9	48		pha				pha
.0181aa	64 08		stz $08				stz 	IF_XPos 					; zero X position
.0181ac	a9 00		lda #$00			lda 	#IF_Screen & $FF 			; set r/w pos.
.0181ae	85 04		sta $04				sta 	IF_Pos
.0181b0	a9 00		lda #$00			lda 	#(IF_Screen >> 8) & $FF
.0181b2	85 05		sta $05				sta 	IF_Pos+1
.0181b4	a9 0f		lda #$0f			lda 	#IF_Screen >> 16
.0181b6	85 06		sta $06				sta 	IF_Pos+2
.0181b8	64 07		stz $07				stz 	IF_Pos+3
.0181ba	68		pla				pla
.0181bb	60		rts				rts
.0181bc					IF_NewLine:
.0181bc	48		pha				pha
.0181bd	64 08		stz $08				stz 	IF_XPos						; back to start of line
.0181bf	18		clc				clc 								; down one line
.0181c0	a5 04		lda $04				lda 	IF_Pos
.0181c2	69 40		adc #$40			adc 	#64
.0181c4	85 04		sta $04				sta 	IF_Pos
.0181c6	90 02		bcc $0181ca			bcc 	_IF_NoCarry 				; carry through.
.0181c8	e6 05		inc $05				inc 	IF_Pos+1
.0181ca					_IF_NoCarry:
.0181ca	68		pla				pla
.0181cb	60		rts				rts
.0181cc					IF_Read:
.0181cc	5a		phy				phy 								; save current Y
.0181cd	a4 08		ldy $08				ldy 	IF_XPos 					; read character at current position
.0181cf	b7 04		lda [$04],y			lda 	[IF_Pos],y
.0181d1	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181d3	7a		ply				ply									; restore Y
.0181d4	60		rts				rts
.0181d5					IF_Write:
.0181d5	5a		phy				phy 								; save current Y
.0181d6	a4 08		ldy $08				ldy 	IF_XPos 					; write character at current position
.0181d8	97 04		sta [$04],y			sta 	[IF_Pos],y
.0181da	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181dc	7a		ply				ply									; restore Y
.0181dd	60		rts				rts
.0181de					IF_LeftOne:
.0181de	c6 08		dec $08				dec 	IF_XPos
.0181e0	60		rts				rts
.0181e1					IF_CheckBreak:
.0181e1	af 00 80 0f	lda $0f8000			lda 	IF_PBreak					; non-zero if Ctrl+C pressed.
.0181e5	60		rts				rts
.0181e6					IF_GetKey:
.0181e6	af 10 80 0f	lda $0f8010			lda 	IF_PKeyboard				; read keyboard
.0181ea	f0 08		beq $0181f4			beq		_IFGK_NoKey 				; skip if zero,no key pressed
.0181ec	48		pha				pha 								; key pressed, clear queue.
.0181ed	a9 00		lda #$00			lda 	#0
.0181ef	8f 10 80 0f	sta $0f8010			sta 	IF_PKeyboard
.0181f3	68		pla				pla
.0181f4					_IFGK_NoKey:
.0181f4	09 00		ora #$00			ora 	#0							; set Z flag appropriately.
.0181f6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.0181f7					TIM_Error:
.0181f7	20 29 80	jsr $018029			jsr 	IFT_UpLine 					; go up one line.
.0181fa	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.0181fc	80 02		bra $018200			bra 	TIM_ShowPrompt
.0181fe					TIM_NewCommand:
.0181fe	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.018200					TIM_ShowPrompt:
.018200	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.018203	20 fa 80	jsr $0180fa			jsr 	IFT_ReadLine	 			; get character, go to next line
.018206	20 5c 80	jsr $01805c			jsr 	IFT_NewLine					; go to next line.
.018209	86 10		stx $10				stx 	zTemp1 						; save line read address
.01820b	84 11		sty $11				sty 	zTemp1+1
.01820d	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.01820f	b1 10		lda ($10),y			lda 	(zTemp1),y
.018211	c9 3f		cmp #$3f			cmp 	#"?"
.018213	f0 04		beq $018219			beq 	TIM_SkipFirst
.018215	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.018217	d0 01		bne $01821a			bne 	TIM_NotDot
.018219					TIM_SkipFirst:
.018219	c8		iny				iny
.01821a					TIM_NotDot:
.01821a	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.01821c	c9 52		cmp #$52			cmp 	#"R"						; show registers
.01821e	f0 6b		beq $01828b			beq 	TIM_ShowRegisters
.018220	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.018222	f0 12		beq $018236			beq 	TIM_ShowMemory
.018224	c9 47		cmp #$47			cmp 	#"G"						; execute
.018226	f0 49		beq $018271			beq 	TIM_Execute
.018228	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.01822a	f0 07		beq $018233			beq 	TIM_GoLoadMemory
.01822c	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.01822e	d0 c7		bne $0181f7			bne 	TIM_Error
.018230	4c af 83	jmp $0183af			jmp 	TIM_UpdateRegisters
.018233					TIM_GoLoadMemory:
.018233	4c df 83	jmp $0183df			jmp 	TIM_LoadMemory
.018236					TIM_ShowMemory:
.018236	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.018239	b0 bc		bcs $0181f7			bcs 	TIM_Error
.01823b	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.01823d	85 12		sta $12				sta 	zTemp2
.01823f	a5 15		lda $15				lda 	zTemp3+1
.018241	85 13		sta $13				sta 	zTemp2+1
.018243	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.018246	90 08		bcc $018250			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.018248	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.01824a	85 14		sta $14				sta 	zTemp3
.01824c	a5 13		lda $13				lda 	zTemp2+1
.01824e	85 15		sta $15				sta 	zTemp3+1
.018250					_TIMSM_Start:
.018250	20 03 83	jsr $018303			jsr 	TIM_WriteLine 				; write one line of hex out
.018253	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.018255	18		clc				clc
.018256	69 10		adc #$10			adc 	#16
.018258	85 12		sta $12				sta 	zTemp2
.01825a	90 02		bcc $01825e			bcc 	_TIMSM_NoCarry
.01825c	e6 13		inc $13				inc 	zTemp2+1
.01825e					_TIMSM_NoCarry:
.01825e	20 e1 81	jsr $0181e1			jsr 	IF_CheckBreak 				; check CTL+C
.018261	d0 0b		bne $01826e			bne 	_TIMSM_Ends 				; if pressed break out.
.018263	38		sec				sec 								; check past the end address in zTemp3
.018264	a5 14		lda $14				lda 	zTemp3
.018266	e5 12		sbc $12				sbc 	zTemp2
.018268	a5 15		lda $15				lda 	zTemp3+1
.01826a	e5 13		sbc $13				sbc 	zTemp2+1
.01826c	10 e2		bpl $018250			bpl 	_TIMSM_Start
.01826e					_TIMSM_Ends:
.01826e	4c fe 81	jmp $0181fe			jmp 	TIM_NewCommand
.018271					TIM_Execute:
.018271	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; get the execute address
.018274	b0 81		bcs $0181f7			bcs 	TIM_Error 					; not legitimate
.018276	ae b1 04	ldx $04b1			ldx 	TIM_SP 						; set up SP
.018279	9a		txs				txs
.01827a	ad ac 04	lda $04ac			lda 	TIM_SR 						; Status for PLP
.01827d	48		pha				pha
.01827e	ad ad 04	lda $04ad			lda 	TIM_A 						; restore AXYZ
.018281	ae ae 04	ldx $04ae			ldx 	TIM_X
.018284	ac af 04	ldy $04af			ldy 	TIM_Y
.018287	28		plp				plp 								; and PS Byte.
.018288	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.01828b					TIM_Start:
.01828b					TIM_ShowRegisters:
.01828b	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.01828e	8d ab 04	sta $04ab			sta 	TIM_IRQ+1
.018291	ad ff ff	lda $ffff			lda 	$FFFF
.018294	8d aa 04	sta $04aa			sta 	TIM_IRQ
.018297	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.018299					_TIMSR_Text:
.018299	bf ca 82 01	lda $0182ca,x			lda 	_TIMSR_Label,x
.01829d	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182a0	e8		inx				inx
.0182a1	e0 20		cpx #$20			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.0182a3	d0 f4		bne $018299			bne 	_TIMSR_Text
.0182a5	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.0182a7					_TIMSR_Skip:
.0182a7	e8		inx				inx
.0182a8					_TIMSR_LoopSpace:
.0182a8	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.0182aa	b0 04		bcs $0182b0			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.0182ac	8a		txa				txa
.0182ad	4a		lsr a				lsr 	a
.0182ae	b0 05		bcs $0182b5			bcs 	_TIMSR_NoSpace
.0182b0					_TIMSR_Space:
.0182b0	a9 20		lda #$20			lda 	#" "
.0182b2	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182b5					_TIMSR_NoSpace:
.0182b5	bd a8 04	lda $04a8,x			lda 	TIM_PC,x 					; output hex value.
.0182b8	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.0182bb	e8		inx				inx
.0182bc	e0 08		cpx #$08			cpx 	#TIM_Z-TIM_PC
.0182be	f0 e7		beq $0182a7			beq 	_TIMSR_Skip
.0182c0	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.0182c2	d0 e4		bne $0182a8			bne 	_TimSR_LoopSpace
.0182c4	20 5c 80	jsr $01805c			jsr 	IFT_NewLine 				; new line
.0182c7	4c fe 81	jmp $0181fe			jmp	 	TIM_NewCommand 				; new command.
.0182ca					_TIMSR_Label:
>0182ca	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>0182d2	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>0182e2	52
>0182e3	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.0182ea					_TIMSR_LabelEnd:
.0182ea					TIM_WriteHex:
.0182ea	48		pha				pha 								; save A
.0182eb	4a		lsr a				lsr 	a 							; shift MSB->LSB
.0182ec	4a		lsr a				lsr 	a
.0182ed	4a		lsr a				lsr 	a
.0182ee	4a		lsr a				lsr 	a
.0182ef	20 f3 82	jsr $0182f3			jsr 	_TIMWH_Nibble 				; print MSB
.0182f2	68		pla				pla 								; restore and print LSB
.0182f3					_TIMWH_Nibble:
.0182f3	48		pha				pha
.0182f4	29 0f		and #$0f			and 	#15 						; mask out
.0182f6	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.0182f8	90 02		bcc $0182fc			bcc 	_TIMWHNoLetter
.0182fa	69 06		adc #$06			adc 	#6
.0182fc					_TIMWHNoLetter:
.0182fc	69 30		adc #$30			adc 	#48
.0182fe	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter 			; print it out.
.018301	68		pla				pla
.018302	60		rts				rts
.018303					TIM_WriteLine:
.018303	a9 2e		lda #$2e			lda 	#"." 						; prompt
.018305	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018308	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.01830a	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01830d	a5 13		lda $13				lda 	zTemp2+1 					; write address
.01830f	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.018312	a5 12		lda $12				lda 	zTemp2
.018314	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.018317	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.018319					_TIMWL_Loop:
.018319	a9 20		lda #$20			lda 	#" "
.01831b	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01831e	b1 12		lda ($12),y			lda 	(zTemp2),y
.018320	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.018323	c8		iny				iny
.018324	c0 10		cpy #$10			cpy 	#16
.018326	d0 f1		bne $018319			bne 	_TIMWL_Loop
.018328	4c 5c 80	jmp $01805c			jmp 	IFT_NewLine 				; new line and exit
.01832b					TIM_GetHex:
.01832b	c8		iny				iny
.01832c	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.01832e	c9 20		cmp #$20			cmp 	#32
.018330	f0 f9		beq $01832b			beq 	TIM_GetHex
.018332	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.018334	f0 f5		beq $01832b			beq 	TIM_GetHex
.018336	20 5f 83	jsr $01835f			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.018339	b0 23		bcs $01835e			bcs 	_TIMGH_Exit					; if first bad then exit now.
.01833b	a9 00		lda #$00			lda 	#0 							; zero result
.01833d	85 14		sta $14				sta 	zTemp3
.01833f	85 15		sta $15				sta 	zTemp3+1
.018341					_TIM_GHLoop:
.018341	20 5f 83	jsr $01835f			jsr 	TIM_GetHexCharacter 		; get next character
.018344	b0 17		bcs $01835d			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.018346	c8		iny				iny 								; skip over it.
.018347	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.018349	26 15		rol $15				rol 	zTemp3+1
.01834b	06 14		asl $14				asl 	zTemp3 						; now x 2
.01834d	26 15		rol $15				rol 	zTemp3+1
.01834f	06 14		asl $14				asl 	zTemp3						; now x 4
.018351	26 15		rol $15				rol 	zTemp3+1
.018353	06 14		asl $14				asl 	zTemp3 						; now x 8
.018355	26 15		rol $15				rol 	zTemp3+1
.018357	05 14		ora $14				ora 	zTemp3 						; OR result in
.018359	85 14		sta $14				sta 	zTemp3
.01835b	80 e4		bra $018341			bra 	_TIM_GHLoop 				; loop round again.
.01835d					_TIMGH_Okay:
.01835d	18		clc				clc
.01835e					_TIMGH_Exit:
.01835e	60		rts				rts
.01835f					TIM_GetHexCharacter:
.01835f	b1 10		lda ($10),y			lda 	(zTemp1),y
.018361	38		sec				sec
.018362	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.018364	90 0e		bcc $018374			bcc 	_TIM_GHCFail
.018366	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.018368	90 0b		bcc $018375			bcc 	_TIM_GHCExit
.01836a	c9 11		cmp #$11			cmp 	#65-48						; < A
.01836c	90 06		bcc $018374			bcc		_TIM_GHCFail
.01836e	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.018370	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.018372	90 01		bcc $018375			bcc		_TIM_GHCExit
.018374					_TIM_GHCFail:
.018374	38		sec				sec
.018375					_TIM_GHCExit:
.018375	60		rts				rts
.018376					TIM_BreakVector:
.018376	da		phx				phx									; save X/A on stack
.018377	48		pha				pha
.018378	ba		tsx				tsx 								; X points to S
.018379	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.01837c	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.01837e	d0 03		bne $018383			bne 	_TIMBreak					; if set, it's BRK
.018380	68		pla				pla 								; abandon routine.
.018381	fa		plx				plx
.018382	40		rti				rti
.018383					_TIMBreak:
.018383	68		pla				pla 								; save A X Y and maybe Z
.018384	8d ad 04	sta $04ad			sta 	TIM_A
.018387	fa		plx				plx
.018388	8e ae 04	stx $04ae			stx 	TIM_X
.01838b	8c af 04	sty $04af			sty 	TIM_Y
.01838e	68		pla				pla 								; get Status Register
.01838f	8d ac 04	sta $04ac			sta 	TIM_SR
.018392	68		pla				pla
.018393	8d a9 04	sta $04a9			sta 	TIM_PC+1 					; save calling address
.018396	68		pla				pla
.018397	8d a8 04	sta $04a8			sta 	TIM_PC 						; high byte
.01839a	ad a9 04	lda $04a9			lda 	TIM_PC+1 					; dec PC to point right.
.01839d	d0 03		bne $0183a2			bne 	_TIMDecrement 				; brk bumps it.
.01839f	ce a8 04	dec $04a8			dec 	TIM_PC
.0183a2					_TIMDecrement:
.0183a2	ce a9 04	dec $04a9			dec 	TIM_PC+1
.0183a5	ba		tsx				tsx 								; and copy SP
.0183a6	8e b1 04	stx $04b1			stx 	TIM_SP
.0183a9	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.0183ab	9a		txs				txs
.0183ac	4c 8b 82	jmp $01828b			jmp 	TIM_Start 					; and start up TIM monitor.
.0183af					TIM_UpdateRegisters:
.0183af	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; PC
.0183b2	b0 28		bcs $0183dc			bcs 	_TIMURFail
.0183b4	a5 14		lda $14				lda 	zTemp3
.0183b6	8d a9 04	sta $04a9			sta 	Tim_PC+1
.0183b9	a5 15		lda $15				lda 	zTemp3+1
.0183bb	8d a8 04	sta $04a8			sta 	Tim_PC
.0183be	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; ignore IRQ
.0183c1	b0 19		bcs $0183dc			bcs 	_TIMURFail
.0183c3	a2 00		ldx #$00			ldx 	#0
.0183c5					_TIM_URLoop:
.0183c5	e0 04		cpx #$04			cpx 	#Tim_Z-Tim_SR
.0183c7	d0 01		bne $0183ca			bne 	_TIM_1
.0183c9	e8		inx				inx
.0183ca					_TIM_1:
.0183ca	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; registers
.0183cd	b0 0d		bcs $0183dc			bcs 	_TIMURFail
.0183cf	a5 14		lda $14				lda 	zTemp3
.0183d1	9d ac 04	sta $04ac,x			sta 	Tim_SR,x
.0183d4	e8		inx				inx
.0183d5	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.0183d7	d0 ec		bne $0183c5			bne 	_TIM_URLoop
.0183d9	4c fe 81	jmp $0181fe			jmp 	TIM_NewCommand
.0183dc					_TIMURFail:
.0183dc	4c f7 81	jmp $0181f7			jmp 	TIM_Error
.0183df					TIM_LoadMemory:
.0183df	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; target address => zTemp2
.0183e2	a5 14		lda $14				lda 	zTemp3
.0183e4	85 12		sta $12				sta 	zTemp2
.0183e6	a5 15		lda $15				lda 	zTemp3+1
.0183e8	85 13		sta $13				sta 	zTemp2+1
.0183ea					_TIM_LMLoop:
.0183ea	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; next byte ?
.0183ed	b0 0e		bcs $0183fd			bcs 	_TIMLMDone 					; no more
.0183ef	a2 00		ldx #$00			ldx 	#0							; write out.
.0183f1	a5 14		lda $14				lda 	zTemp3
.0183f3	81 12		sta ($12,x)			sta 	(zTemp2,x)
.0183f5	e6 12		inc $12				inc 	zTemp2 						; bump address
.0183f7	d0 f1		bne $0183ea			bne 	_TIM_LMLoop
.0183f9	e6 13		inc $13				inc 	zTemp2+1
.0183fb	80 ed		bra $0183ea			bra 	_TIM_LMLoop
.0183fd					_TIMLMDone:
.0183fd	4c fe 81	jmp $0181fe			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/errors.asm

.018400					SyntaxError:
.018400	20 2f 84	jsr $01842f			jsr 	ERR_Handler
>018403	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>01840b	72 72 6f 72 00
.018410					TypeError:
.018410	20 2f 84	jsr $01842f			jsr 	ERR_Handler
>018413	57 72 6f 6e 67 20 74 79				.text 	"Wrong type",0
>01841b	70 65 00
.01841e					BadParamError:
.01841e	20 2f 84	jsr $01842f			jsr 	ERR_Handler
>018421	42 61 64 20 50 61 72 61				.text 	"Bad Parameter",0
>018429	6d 65 74 65 72 00
.01842f					ERR_Handler:
.01842f	a0 00		ldy #$00			ldy 	#0
.018431	c8		iny				iny
.018432	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018434	8d 08 03	sta $0308			sta 	XS_Mantissa
.018437	c8		iny				iny
.018438	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01843a	8d 09 03	sta $0309			sta 	XS_Mantissa+1
.01843d	fa		plx				plx 								; address in XY
.01843e	7a		ply				ply
.01843f	e8		inx				inx 								; bump, because of RTS/JSR address -1
.018440	d0 01		bne $018443			bne 	_EHNoSkip
.018442	c8		iny				iny
.018443					_EHNoSkip:
.018443	20 64 84	jsr $018464			jsr 	PrintROMMessage 			; print message from ROM.
.018446	ad 08 03	lda $0308			lda 	XS_Mantissa					; line number = 0
.018449	0d 09 03	ora $0309			ora 	XS_Mantissa+1
.01844c	f0 0c		beq $01845a			beq 	_EHNoLine
.01844e	a2 5f		ldx #$5f			ldx 	#_EHAt & $FF 				; print " at "
.018450	a0 84		ldy #$84			ldy 	#(_EHAt >> 8) & $FF
.018452	20 64 84	jsr $018464			jsr 	PrintROMMessage
.018455	a2 00		ldx #$00			ldx 	#0 							; Print line number
.018457	20 79 84	jsr $018479			jsr 	Print16BitInteger
.01845a					_EHNoLine:
.01845a	80 fe		bra $01845a			bra 	_EHNoLine
.01845c	4c d4 86	jmp $0186d4			jmp 	WarmStart
>01845f	20 61 74 20 00			_EHAt:	.text 	" at ",0
.018464					PrintROMMessage:
.018464	86 1a		stx $1a				stx 	zLTemp1 					; save addres
.018466	84 1b		sty $1b				sty 	zLTemp1+1
.018468	4b		phk				phk
.018469	68		pla				pla
.01846a	85 1c		sta $1c				sta 	ZLTemp1+2
.01846c	a0 00		ldy #$00			ldy 	#0
.01846e					_PRMLoop:
.01846e	b7 1a		lda [$1a],y			lda 	[zLTemp1],y
.018470	f0 06		beq $018478			beq		_PRMExit
.018472	c8		iny				iny
.018473	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018476	80 f6		bra $01846e			bra 	_PRMLoop
.018478					_PRMExit:
.018478	60		rts				rts
.018479					Print16BitInteger:
.018479	a9 00		lda #$00			lda 	#0 							; make 32 bit
.01847b	8d 0a 03	sta $030a			sta 	XS_Mantissa+2
.01847e	8d 0b 03	sta $030b			sta 	XS_Mantissa+3
.018481	8d 04 04	sta $0404			sta 	NumBufX 					; reset the conversion pointer
.018484	aa		tax				tax 								; convert bottom level.
.018485	20 c6 96	jsr $0196c6			jsr 	INTToString 				; make string
.018488	a2 00		ldx #$00			ldx 	#0 							; print buffer
.01848a	bd 05 04	lda $0405,x	_P1Loop:lda 	Num_Buffer,x
.01848d	f0 06		beq $018495			beq 	_P1Exit
.01848f	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018492	e8		inx				inx
.018493	80 f5		bra $01848a			bra 	_P1Loop
.018495	60		rts		_P1Exit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm


;******  Processing file: modules/basic/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b6					lastUnaryFunction = $b6
.018496					VectorTable:
>018496	91 8a					.word BinaryOp_And         & $FFFF ; $80 and
>018498	b9 8a					.word BinaryOp_Or          & $FFFF ; $81 or
>01849a	e1 8a					.word BinaryOp_Xor         & $FFFF ; $82 xor
>01849c	e1 8a					.word BinaryOp_Eor         & $FFFF ; $83 eor
>01849e	25 8b					.word Binary_Equal         & $FFFF ; $84 =
>0184a0	44 8b					.word Binary_NotEqual      & $FFFF ; $85 <>
>0184a2	4d 8b					.word Binary_Less          & $FFFF ; $86 <
>0184a4	56 8b					.word Binary_LessEqual     & $FFFF ; $87 <=
>0184a6	68 8b					.word Binary_Greater       & $FFFF ; $88 >
>0184a8	5f 8b					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>0184aa	fd 8b					.word BinaryOp_Add         & $FFFF ; $8a +
>0184ac	1d 8c					.word BinaryOp_Subtract    & $FFFF ; $8b -
>0184ae	30 8c					.word BinaryOp_Multiply    & $FFFF ; $8c *
>0184b0	43 8c					.word BinaryOp_Divide      & $FFFF ; $8d /
>0184b2	52 85					.word NotImplemented       & $FFFF ; $8e ^
>0184b4	52 85					.word NotImplemented       & $FFFF ; $8f if
>0184b6	52 85					.word NotImplemented       & $FFFF ; $90 while
>0184b8	52 85					.word NotImplemented       & $FFFF ; $91 repeat
>0184ba	52 85					.word NotImplemented       & $FFFF ; $92 for
>0184bc	52 85					.word NotImplemented       & $FFFF ; $93 then
>0184be	52 85					.word NotImplemented       & $FFFF ; $94 endif
>0184c0	52 85					.word NotImplemented       & $FFFF ; $95 wend
>0184c2	52 85					.word NotImplemented       & $FFFF ; $96 until
>0184c4	52 85					.word NotImplemented       & $FFFF ; $97 next
>0184c6	52 85					.word NotImplemented       & $FFFF ; $98 not
>0184c8	52 85					.word NotImplemented       & $FFFF ; $99 fn(
>0184ca	77 8d					.word Unary_Abs            & $FFFF ; $9a abs(
>0184cc	cf 8e					.word Unary_Asc            & $FFFF ; $9b asc(
>0184ce	ab 9e					.word Unary_Int            & $FFFF ; $9c int(
>0184d0	95 8d					.word Unary_Peek           & $FFFF ; $9d peek(
>0184d2	22 9e					.word Unary_Rnd            & $FFFF ; $9e rnd(
>0184d4	09 8e					.word Unary_Usr            & $FFFF ; $9f usr(
>0184d6	10 8f					.word Unary_Left           & $FFFF ; $a0 left$(
>0184d8	27 8f					.word Unary_Right          & $FFFF ; $a1 right$(
>0184da	f5 8e					.word Unary_Mid            & $FFFF ; $a2 mid$(
>0184dc	89 90					.word Unary_Spc            & $FFFF ; $a3 spc(
>0184de	9c 8e					.word Unary_Str            & $FFFF ; $a4 str$(
>0184e0	2b 8e					.word Unary_Val            & $FFFF ; $a5 val(
>0184e2	e6 8e					.word Unary_Len            & $FFFF ; $a6 len(
>0184e4	a5 8f					.word Unary_Hex            & $FFFF ; $a7 hex$(
>0184e6	52 85					.word NotImplemented       & $FFFF ; $a8 sin(
>0184e8	52 85					.word NotImplemented       & $FFFF ; $a9 cos(
>0184ea	52 85					.word NotImplemented       & $FFFF ; $aa tan(
>0184ec	52 85					.word NotImplemented       & $FFFF ; $ab atn(
>0184ee	52 85					.word NotImplemented       & $FFFF ; $ac exp(
>0184f0	52 85					.word NotImplemented       & $FFFF ; $ad log(
>0184f2	52 85					.word NotImplemented       & $FFFF ; $ae sqr(
>0184f4	ff 8f					.word Unary_Dec            & $FFFF ; $af dec(
>0184f6	99 8d					.word Unary_Deek           & $FFFF ; $b0 deek(
>0184f8	9d 8d					.word Unary_Leek           & $FFFF ; $b1 leek(
>0184fa	d1 8d					.word Unary_Mod            & $FFFF ; $b2 mod(
>0184fc	25 8d					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>0184fe	67 90					.word Unary_Chr            & $FFFF ; $b4 chr$(
>018500	52 85					.word NotImplemented       & $FFFF ; $b5 pos(
>018502	52 85					.word NotImplemented       & $FFFF ; $b6 tab(
>018504	52 85					.word NotImplemented       & $FFFF ; $b7 $
>018506	52 85					.word NotImplemented       & $FFFF ; $b8 $(
>018508	52 85					.word NotImplemented       & $FFFF ; $b9 #
>01850a	52 85					.word NotImplemented       & $FFFF ; $ba #(
>01850c	52 85					.word NotImplemented       & $FFFF ; $bb %
>01850e	52 85					.word NotImplemented       & $FFFF ; $bc %(
>018510	52 85					.word NotImplemented       & $FFFF ; $bd (
>018512	52 85					.word NotImplemented       & $FFFF ; $be )
>018514	52 85					.word NotImplemented       & $FFFF ; $bf ,
>018516	e9 87					.word Command_COLON        & $FFFF ; $c0 :
>018518	52 85					.word NotImplemented       & $FFFF ; $c1 ;
>01851a	52 85					.word NotImplemented       & $FFFF ; $c2 def
>01851c	9e 88					.word Command_CLR          & $FFFF ; $c3 clr
>01851e	af 88					.word Command_STOP         & $FFFF ; $c4 stop
>018520	52 85					.word NotImplemented       & $FFFF ; $c5 data
>018522	52 85					.word NotImplemented       & $FFFF ; $c6 read
>018524	e2 86					.word Command_DIM          & $FFFF ; $c7 dim
>018526	52 85					.word NotImplemented       & $FFFF ; $c8 to
>018528	52 85					.word NotImplemented       & $FFFF ; $c9 step
>01852a	52 85					.word NotImplemented       & $FFFF ; $ca gosub
>01852c	52 85					.word NotImplemented       & $FFFF ; $cb return
>01852e	52 85					.word NotImplemented       & $FFFF ; $cc goto
>018530	0b 88					.word Command_END          & $FFFF ; $cd end
>018532	52 85					.word NotImplemented       & $FFFF ; $ce input
>018534	ea 87					.word Command_LET          & $FFFF ; $cf let
>018536	52 85					.word NotImplemented       & $FFFF ; $d0 list
>018538	52 85					.word NotImplemented       & $FFFF ; $d1 new
>01853a	52 85					.word NotImplemented       & $FFFF ; $d2 old
>01853c	52 85					.word NotImplemented       & $FFFF ; $d3 on
>01853e	52 85					.word NotImplemented       & $FFFF ; $d4 restore
>018540	52 85					.word NotImplemented       & $FFFF ; $d5 poke
>018542	0f 88					.word Command_PRINT        & $FFFF ; $d6 print
>018544	6f 87					.word Command_RUN          & $FFFF ; $d7 run
>018546	52 85					.word NotImplemented       & $FFFF ; $d8 wait
>018548	52 85					.word NotImplemented       & $FFFF ; $d9 sys
>01854a	52 85					.word NotImplemented       & $FFFF ; $da doke
>01854c	52 85					.word NotImplemented       & $FFFF ; $db loke
>01854e	82 88					.word Command_ASSERT       & $FFFF ; $dc assert
>018550	52 85					.word NotImplemented       & $FFFF ; $dd get
.018552					NotImplemented:
.018552	20 2f 84	jsr $01842f			jsr ERR_Handler
>018555	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>01855d	65 6d 65 6e 74 65 64 00
.018565					BinaryPrecedence:
>018565	01					.byte 1    ; $80 and
>018566	01					.byte 1    ; $81 or
>018567	01					.byte 1    ; $82 xor
>018568	01					.byte 1    ; $83 eor
>018569	02					.byte 2    ; $84 =
>01856a	02					.byte 2    ; $85 <>
>01856b	02					.byte 2    ; $86 <
>01856c	02					.byte 2    ; $87 <=
>01856d	02					.byte 2    ; $88 >
>01856e	02					.byte 2    ; $89 >=
>01856f	03					.byte 3    ; $8a +
>018570	03					.byte 3    ; $8b -
>018571	04					.byte 4    ; $8c *
>018572	04					.byte 4    ; $8d /
>018573	05					.byte 5    ; $8e ^
.018574					KeywordText:
>018574	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>018577	4f d2					.byte $4f,$d2                          ; $81 or
>018579	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>01857c	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>01857f	bd					.byte $bd                              ; $84 =
>018580	3c be					.byte $3c,$be                          ; $85 <>
>018582	bc					.byte $bc                              ; $86 <
>018583	3c bd					.byte $3c,$bd                          ; $87 <=
>018585	be					.byte $be                              ; $88 >
>018586	3e bd					.byte $3e,$bd                          ; $89 >=
>018588	ab					.byte $ab                              ; $8a +
>018589	ad					.byte $ad                              ; $8b -
>01858a	aa					.byte $aa                              ; $8c *
>01858b	af					.byte $af                              ; $8d /
>01858c	de					.byte $de                              ; $8e ^
>01858d	49 c6					.byte $49,$c6                          ; $8f if
>01858f	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>018594	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>01859a	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>01859d	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>0185a1	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>0185a6	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>0185aa	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>0185af	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>0185b3	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>0185b6	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>0185b9	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>0185bd	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>0185c1	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>0185c5	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>0185ca	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>0185ce	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>0185d2	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>0185d8	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>0185df	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>0185e4	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>0185e8	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>0185ed	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>0185f1	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>0185f5	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>0185fa	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>0185fe	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>018602	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>018606	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>01860a	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>01860e	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>018612	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>018616	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>01861a	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>01861f	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>018624	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>018628	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>01862c	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>018631	50 4f 53 a8				.byte $50,$4f,$53,$a8                  ; $b5 pos(
>018635	54 41 42 a8				.byte $54,$41,$42,$a8                  ; $b6 tab(
>018639	a4					.byte $a4                              ; $b7 $
>01863a	24 a8					.byte $24,$a8                          ; $b8 $(
>01863c	a3					.byte $a3                              ; $b9 #
>01863d	23 a8					.byte $23,$a8                          ; $ba #(
>01863f	a5					.byte $a5                              ; $bb %
>018640	25 a8					.byte $25,$a8                          ; $bc %(
>018642	a8					.byte $a8                              ; $bd (
>018643	a9					.byte $a9                              ; $be )
>018644	ac					.byte $ac                              ; $bf ,
>018645	ba					.byte $ba                              ; $c0 :
>018646	bb					.byte $bb                              ; $c1 ;
>018647	44 45 c6				.byte $44,$45,$c6                      ; $c2 def
>01864a	43 4c d2				.byte $43,$4c,$d2                      ; $c3 clr
>01864d	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $c4 stop
>018651	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c5 data
>018655	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c6 read
>018659	44 49 cd				.byte $44,$49,$cd                      ; $c7 dim
>01865c	54 cf					.byte $54,$cf                          ; $c8 to
>01865e	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c9 step
>018662	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $ca gosub
>018667	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $cb return
>01866d	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $cc goto
>018671	45 4e c4				.byte $45,$4e,$c4                      ; $cd end
>018674	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $ce input
>018679	4c 45 d4				.byte $4c,$45,$d4                      ; $cf let
>01867c	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $d0 list
>018680	4e 45 d7				.byte $4e,$45,$d7                      ; $d1 new
>018683	4f 4c c4				.byte $4f,$4c,$c4                      ; $d2 old
>018686	4f ce					.byte $4f,$ce                          ; $d3 on
>018688	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d4 restore
>01868f	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d5 poke
>018693	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d6 print
>018698	52 55 ce				.byte $52,$55,$ce                      ; $d7 run
>01869b	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d8 wait
>01869f	53 59 d3				.byte $53,$59,$d3                      ; $d9 sys
>0186a2	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $da doke
>0186a6	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $db loke
>0186aa	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $dc assert
>0186b0	47 45 d4				.byte $47,$45,$d4                      ; $dd get
>0186b3	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_pos = $b5
=$b6					token_tab = $b6
=$b7					token_dollar = $b7
=$b8					token_dollarlparen = $b8
=$b9					token_hash = $b9
=$ba					token_hashlparen = $ba
=$bb					token_percent = $bb
=$bc					token_percentlparen = $bc
=$bd					token_lparen = $bd
=$be					token_rparen = $be
=$bf					token_comma = $bf
=$c0					token_colon = $c0
=$c1					token_semicolon = $c1
=$c2					token_def = $c2
=$c3					token_clr = $c3
=$c4					token_stop = $c4
=$c5					token_data = $c5
=$c6					token_read = $c6
=$c7					token_dim = $c7
=$c8					token_to = $c8
=$c9					token_step = $c9
=$ca					token_gosub = $ca
=$cb					token_return = $cb
=$cc					token_goto = $cc
=$cd					token_end = $cd
=$ce					token_input = $ce
=$cf					token_let = $cf
=$d0					token_list = $d0
=$d1					token_new = $d1
=$d2					token_old = $d2
=$d3					token_on = $d3
=$d4					token_restore = $d4
=$d5					token_poke = $d5
=$d6					token_print = $d6
=$d7					token_run = $d7
=$d8					token_wait = $d8
=$d9					token_sys = $d9
=$da					token_doke = $da
=$db					token_loke = $db
=$dc					token_assert = $dc
=$dd					token_get = $dd

;******  Return to file: modules/basic/core.asm

.0186b4					BASIC_Start:
.0186b4	20 a8 81	jsr $0181a8			jsr 	IF_Reset 					; set up and clear screen.
.0186b7	20 00 80	jsr $018000			jsr 	IFT_ClearScreen
.0186ba	a9 5c		lda #$5c			lda 	#$5C 						; JMP Long opcode
.0186bc	8d 04 03	sta $0304			sta 	LocalVector
.0186bf	8d 00 03	sta $0300			sta 	UserVector
.0186c2	a9 19		lda #$19			lda 	#USRDefault & $FF 			; reset USR vector
.0186c4	8d 01 03	sta $0301			sta 	UserVector+1
.0186c7	a9 8e		lda #$8e			lda 	#(USRDefault >> 8) & $FF
.0186c9	8d 02 03	sta $0302			sta 	UserVector+2
.0186cc	a9 01		lda #$01			lda 	#(USRDefault >> 16) & $FF
.0186ce	8d 03 03	sta $0303			sta 	UserVector+3
.0186d1	20 9e 88	jsr $01889e			jsr 	ResetRunStatus 				; clear everything (CLR command)
.0186d4					WarmStart:
.0186d4	c2 30		rep #$30			rep 	#$30
.0186d6	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.0186d9	1b		tcs				tcs
.0186da	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.0186dd	e2 30		sep #$30			sep 	#$30
.0186df	4c 6f 87	jmp $01876f			jmp 	COMMAND_Run

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/dim.asm

.0186e2					Command_DIM:
.0186e2	98		tya				tya
.0186e3	48		pha				pha 								; push on stack.
.0186e4	20 ff 91	jsr $0191ff			jsr 	VariableExtract 			; get the identifier
.0186e7	ad 85 04	lda $0485			lda 	Var_Type 					; check it is an array
.0186ea	29 01		and #$01			and 	#1
.0186ec	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.0186ee	d0 71		bne $018761			bne 	_CDIError
.0186f0	a9 00		lda #$00			lda 	#0 							; reset the DIM index. The dimensions are
.0186f2	8d a7 04	sta $04a7			sta 	UsrArrayIdx 				; built up here and copied in case we autodim
.0186f5					_CDIGetDimension:
.0186f5	ad a7 04	lda $04a7			lda 	UsrArrayIdx 				; done too many ?
.0186f8	c9 06		cmp #$06			cmp 	#ArrayMaxDim*2
.0186fa	f0 65		beq $018761			beq 	_CDIError
.0186fc	20 ba 88	jsr $0188ba			jsr 	EvaluateExpression 			; evaluate an index size
.0186ff	ad 09 03	lda $0309			lda 	XS_Mantissa+1 				; check in range 0-7FFF
.018702	29 80		and #$80			and 	#$80
.018704	0d 0a 03	ora $030a			ora 	XS_Mantissa+2
.018707	0d 0b 03	ora $030b			ora 	XS_Mantissa+3
.01870a	d0 55		bne $018761			bne 	_CDIError
.01870c	ae a7 04	ldx $04a7			ldx 	UsrArrayIdx 				; copy into the array table.
.01870f	18		clc				clc 								; add 1 - max index => size.
.018710	ad 08 03	lda $0308			lda 	XS_Mantissa+0
.018713	69 01		adc #$01			adc 	#1
.018715	9d 9f 04	sta $049f,x			sta 	UsrArrayDef+0,x
.018718	ad 09 03	lda $0309			lda 	XS_Mantissa+1
.01871b	69 00		adc #$00			adc 	#0
.01871d	9d a0 04	sta $04a0,x			sta 	UsrArrayDef+1,x
.018720	30 3f		bmi $018761			bmi 	_CDIError 					; could be dim a(32767)
.018722	e8		inx				inx 								; bump index.
.018723	e8		inx				inx
.018724	8e a7 04	stx $04a7			stx 	UsrArrayIdx
.018727	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018729	c8		iny				iny
.01872a	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another dimension
.01872c	f0 c7		beq $0186f5			beq 	_CDIGetDimension
.01872e	88		dey				dey
.01872f	20 f1 90	jsr $0190f1			jsr 	CheckNextRParen 			; closing ) present ?
.018732	ae a7 04	ldx $04a7			ldx 	UsrArrayIdx 				; copy USR array to default
.018735	a9 ff		lda #$ff			lda 	#$FF 						; put end marker in ArrayDef
.018737	9d 98 04	sta $0498,x			sta 	ArrayDef+1,x
.01873a					_CDICopy:
.01873a	bd 9f 04	lda $049f,x			lda 	UsrArrayDef,x
.01873d	9d 97 04	sta $0497,x			sta 	ArrayDef,x
.018740	ca		dex				dex
.018741	10 f7		bpl $01873a			bpl 	_CDICopy
.018743	68		pla				pla									; position of array identifier
.018744	85 10		sta $10				sta 	zTemp1
.018746	98		tya				tya
.018747	48		pha				pha
.018748	a5 10		lda $10				lda 	zTemp1 						; point to identifier
.01874a	a8		tay				tay
.01874b	20 ff 91	jsr $0191ff			jsr 	VariableExtract 			; get the identifier
.01874e	20 a1 94	jsr $0194a1			jsr 	VariableLocate 				; check if it exists already.
.018751	b0 0e		bcs $018761			bcs 	_CDIError
.018753	20 8b 92	jsr $01928b			jsr 	VariableCreate 				; create it using the current ArrayDef
.018756	68		pla				pla 								; restore code position
.018757	a8		tay				tay
.018758	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01875a	c8		iny				iny
.01875b	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another DIM
.01875d	f0 83		beq $0186e2			beq 	Command_DIM
.01875f	88		dey				dey
.018760	60		rts				rts
.018761					_CDIError:
.018761	20 2f 84	jsr $01842f			jsr ERR_Handler
>018764	42 61 64 20 44 49 4d 00			.text "Bad DIM",0
.01876c					_CDISyntax:
.01876c	4c 00 84	jmp $018400			jmp 	SyntaxError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/run.asm

.01876f					Command_RUN:
.01876f	20 9e 88	jsr $01889e			jsr 	ResetRunStatus 				; clear, reset stacks etc.
.018772	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018774	85 16		sta $16				sta 	zCodePtr+0
.018776	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018778	85 17		sta $17				sta 	zCodePtr+1
.01877a	a9 00		lda #$00			lda 	#0
.01877c	85 18		sta $18				sta 	zCodePtr+2
.01877e	85 19		sta $19				sta 	zCodePtr+3
.018780	a0 03		ldy #$03			ldy 	#3
.018782					RUN_NewLine:
.018782	a0 00		ldy #$00			ldy 	#0
.018784	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018786	c8		iny				iny
.018787	c8		iny				iny
.018788	c8		iny				iny
.018789	c9 00		cmp #$00			cmp 	#0 							; if the offset is zero then END.
.01878b	d0 16		bne $0187a3			bne 	RUN_NextCommand
.01878d	4c af 88	jmp $0188af			jmp 	Command_STOP 				; go do the command code.
.018790					RUN_Skip:
.018790	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018792	c8		iny				iny 								; skip
.018793	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018795	90 0c		bcc $0187a3			bcc 	_SEDone 					; so just skip over it.
.018797	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018799	90 07		bcc $0187a2			bcc 	_SEDouble
.01879b	98		tya				tya 								; this is Y + 1
.01879c	18		clc				clc
.01879d	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.01879f	a8		tay				tay 								; back in Y.
.0187a0	88		dey				dey 								; fix up, one for the +1, one for the iny
.0187a1	88		dey				dey
.0187a2					_SEDouble:
.0187a2	c8		iny				iny
.0187a3					_SEDone:
.0187a3					RUN_NextCommand:
.0187a3	a9 00		lda #$00			lda 	#0 							; this resets temporary string allocation.
.0187a5	85 21		sta $21				sta 	zTempStr+1 					; (initialised when first called)
.0187a7	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0187a9	c9 c0		cmp #$c0			cmp 	#token_Colon 				; skip over colons
.0187ab	f0 e3		beq $018790			beq 	RUN_Skip
.0187ad	c9 00		cmp #$00			cmp 	#0 							; if non-zero execute whatever
.0187af	d0 0f		bne $0187c0			bne 	RUN_Execute
.0187b1					RUN_NextLine:
.0187b1	a0 00		ldy #$00			ldy 	#0 							; point to offset
.0187b3	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.0187b5	18		clc				clc
.0187b6	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.0187b8	85 16		sta $16				sta 	zCodePtr
.0187ba	90 02		bcc $0187be			bcc 	_SNLNoCarry
.0187bc	e6 17		inc $17				inc 	zCodePtr+1
.0187be					_SNLNoCarry:
.0187be	80 c2		bra $018782			bra 	RUN_NewLine 				; go do the new line code
.0187c0					RUN_Execute:
.0187c0	c9 f8		cmp #$f8			cmp 	#$F8 						; handle shifts, REM etc.
.0187c2	b0 1e		bcs $0187e2			bcs 	RUN_Extension
.0187c4	c8		iny				iny
.0187c5	0a		asl a				asl 	a 							; double the character read.
.0187c6	90 14		bcc $0187dc			bcc 	RUN_Default 				; if carry clear was $00-$7F, so try LET.
.0187c8	aa		tax				tax 								; ready to look up.
.0187c9	bf 96 84 01	lda $018496,x			lda 	VectorTable,x 				; copy address into LocalVector
.0187cd	8d 05 03	sta $0305			sta 	LocalVector+1
.0187d0	bf 97 84 01	lda $018497,x			lda 	VectorTable+1,x
.0187d4	8d 06 03	sta $0306			sta 	LocalVector+2
.0187d7	20 ca 89	jsr $0189ca			jsr 	EVCallLocalVector 			; execute the appropriate code.
.0187da	80 c7		bra $0187a3			bra 	RUN_NextCommand 			; do the next command.
.0187dc					RUN_Default:
.0187dc	88		dey				dey
.0187dd	20 ea 87	jsr $0187ea			jsr 	Command_LET 				; and try LET.
.0187e0	80 c1		bra $0187a3			bra 	RUN_NextCommand
.0187e2					RUN_Extension:
.0187e2	c9 ff		cmp #$ff			cmp 	#$FF 						; if $FF (REM)
.0187e4	f0 aa		beq $018790			beq 	RUN_Skip 					; skip over it.
.0187e6	4c 00 84	jmp $018400			jmp 	SyntaxError
.0187e9					Command_COLON:
.0187e9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/let.asm

.0187ea					Command_LET:
.0187ea	20 94 91	jsr $019194			jsr 	VariableFind 				; get reference to one variable.
.0187ed	a9 84		lda #$84			lda 	#token_Equal  				; get equals
.0187ef	20 da 90	jsr $0190da			jsr 	CheckNextToken
.0187f2	a5 22		lda $22				lda 	zVarDataPtr 				; save variable info on stack
.0187f4	48		pha				pha
.0187f5	a5 23		lda $23				lda 	zVarDataPtr+1
.0187f7	48		pha				pha
.0187f8	a5 24		lda $24				lda 	zVarType
.0187fa	48		pha				pha
.0187fb	20 ba 88	jsr $0188ba			jsr 	EvaluateExpression 			; evaluate the RHS.
.0187fe	68		pla				pla 								; restore target variable information.
.0187ff	85 24		sta $24				sta 	zVarType
.018801	68		pla				pla
.018802	85 23		sta $23				sta 	zVarDataPtr+1
.018804	68		pla				pla
.018805	85 22		sta $22				sta 	zVarDataPtr
.018807	20 44 95	jsr $019544			jsr 	VariableSet 				; set the value out.
.01880a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/end.asm

.01880b					Command_END:
>01880b	02						.byte 	2
.01880c	4c d4 86	jmp $0186d4			jmp 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/print.asm

.01880f					Command_PRINT:
.01880f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018811	c9 00		cmp #$00			cmp 	#0 							; end
.018813	f0 69		beq $01887e			beq 	_CPR_NewLine
.018815	c9 c0		cmp #$c0			cmp 	#token_Colon
.018817	f0 65		beq $01887e			beq 	_CPR_NewLine
.018819	c9 c1		cmp #$c1			cmp 	#token_SemiColon
.01881b	f0 54		beq $018871			beq 	_CPR_Skip
.01881d	c9 bf		cmp #$bf			cmp 	#token_Comma
.01881f	f0 4d		beq $01886e			beq 	_CPR_Tab
.018821	20 ba 88	jsr $0188ba			jsr 	EvaluateExpression 			; get expression.
.018824	ad 0d 03	lda $030d			lda 	XS_Type 					; get type.
.018827	29 02		and #$02			and 	#2
.018829	d0 25		bne $018850			bne 	_CPR_String 				; if type = 2 output as string.
.01882b					_CPR_Number:
.01882b	a9 00		lda #$00			lda 	#0 							; reset buffer index
.01882d	8d 04 04	sta $0404			sta 	NumBufX
.018830	ad 0d 03	lda $030d			lda 	XS_Type 					; get type
.018833	4a		lsr a				lsr 	a
.018834	b0 05		bcs $01883b			bcs 	_CPRInt 					; if msb set do as integer
.018836	20 da 9c	jsr $019cda			jsr 	FPToString 					; call fp to str otherwise
.018839	80 03		bra $01883e			bra 	_CPRNPrint
.01883b	20 c6 96	jsr $0196c6	_CPRInt:jsr 	IntToString
.01883e					_CPRNPrint:
.01883e	ad 05 04	lda $0405			lda 	Num_Buffer 					; is first character -
.018841	c9 2d		cmp #$2d			cmp 	#"-"
.018843	f0 05		beq $01884a			beq 	_CPRNoSpace
.018845	a9 20		lda #$20			lda 	#" "						; print the leading space
.018847	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter 			; so beloved of MS Basics.
.01884a					_CPRNoSpace:
.01884a	a2 04		ldx #$04			ldx 	#(Num_Buffer-1) & $FF
.01884c	a9 04		lda #$04			lda 	#(Num_Buffer-1) >> 8
.01884e	80 06		bra $018856			bra 	_CPRPrint
.018850					_CPR_String:
.018850	ae 08 03	ldx $0308			ldx 	XS_Mantissa
.018853	ad 09 03	lda $0309			lda 	XS_Mantissa+1
.018856					_CPRPrint:
.018856	86 1e		stx $1e				stx 	zGenPtr
.018858	85 1f		sta $1f				sta 	zGenPtr+1
.01885a	5a		phy				phy
.01885b	a0 00		ldy #$00			ldy 	#0							; get length into X
.01885d	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.01885f	aa		tax				tax
.018860	f0 09		beq $01886b			beq 	_CPREndPrint 				; nothing to print
.018862					_CPRLoop:
.018862	c8		iny				iny
.018863	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018865	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018868	ca		dex				dex
.018869	d0 f7		bne $018862			bne 	_CPRLoop
.01886b					_CPREndPrint:
.01886b	7a		ply				ply
.01886c	80 a1		bra $01880f			bra 	Command_Print
.01886e					_CPR_Tab:
.01886e	20 4f 80	jsr $01804f			jsr 	IFT_Tab
.018871					_CPR_Skip:
.018871	c8		iny				iny
.018872	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018874	c9 c0		cmp #$c0			cmp 	#token_Colon 				; colon or $00, exit
.018876	f0 09		beq $018881			beq 	_CPR_Exit
.018878	c9 00		cmp #$00			cmp 	#0
.01887a	d0 93		bne $01880f			bne 	Command_PRINT 				; if not go round again.
.01887c	80 03		bra $018881			bra 	_CPR_Exit
.01887e					_CPR_NewLine:
.01887e	20 5c 80	jsr $01805c			jsr 	IFT_NewLine
.018881					_CPR_Exit:
.018881	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/assert.asm

.018882					Command_ASSERT:
.018882	20 60 8a	jsr $018a60			jsr 	EvaluateNumber 				; calculate thing being asserted
.018885	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; check if true (non-zero)
.018888	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.01888b	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.01888e	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.018891	f0 01		beq $018894			beq 	_ASFail
.018893	60		rts				rts
.018894					_ASFail:
.018894	20 2f 84	jsr $01842f			jsr ERR_Handler
>018897	41 73 73 65 72 74 00			.text "Assert",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.01889e					Command_CLR:
.01889e					ResetRunStatus:
.01889e	20 d0 91	jsr $0191d0			jsr 	VariableClear
.0188a1	a9 00		lda #$00			lda 	#HighMemory & $FF
.0188a3	8d 00 04	sta $0400			sta 	StringPtr
.0188a6	a9 80		lda #$80			lda 	#HighMemory >> 8
.0188a8	8d 01 04	sta $0401			sta 	StringPtr+1
.0188ab	20 a3 93	jsr $0193a3			jsr 	ArrayResetDefault
.0188ae	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/stop.asm

.0188af					Command_STOP:
.0188af	20 2f 84	jsr $01842f			jsr ERR_Handler
>0188b2	53 74 6f 70 00				.text "Stop",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.0188b7					EVESyntax:
.0188b7	4c 00 84	jmp $018400			jmp 	SyntaxError
.0188ba					EvaluateExpression:
.0188ba	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.0188bc					EvaluateExpressionX:
.0188bc	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.0188be					EvaluateExpressionXA:
.0188be	48		pha				pha 								; save precedence on stack.
.0188bf	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0188c1	f0 f4		beq $0188b7			beq 	EVESyntax 					; end of line, syntax error.
.0188c3	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.0188c5	b0 03		bcs $0188ca			bcs 	_EVNotVariable
.0188c7	4c c1 89	jmp $0189c1			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.0188ca					_EVNotVariable:
.0188ca	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.0188cc	90 e9		bcc $0188b7			bcc 	EVESyntax
.0188ce	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.0188d0	b0 7f		bcs $018951			bcs 	_EVNotInteger
.0188d2	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.0188d4	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.0188d7	a9 00		lda #$00			lda 	#0
.0188d9	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0188dc	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0188df	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0188e2	1a		inc a				inc 	a 							; set to type 1 (integer)
.0188e3	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0188e6					_EVCheckNextInteger:
.0188e6	c8		iny				iny
.0188e7	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0188e9	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.0188eb	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.0188ed	b0 0d		bcs $0188fc			bcs 	_EVCheckDecimal
.0188ef	48		pha				pha 								; save it.
.0188f0	20 cd 89	jsr $0189cd			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.0188f3	68		pla				pla
.0188f4	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.0188f7	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0188fa	80 ea		bra $0188e6			bra 	_EVCheckNextInteger
.0188fc					_EVCheckDecimal:
.0188fc	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0188fe	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.018900	d0 05		bne $018907			bne 	_EVGotAtom 					; no, get atom.
.018902					_EVIsDecimal:
.018902	20 fd 89	jsr $0189fd			jsr 	EVGetDecimal 				; extend to the decimal part.
.018905	80 00		bra $018907			bra 	_EVGotAtom 					; and continue to got atom.
.018907					_EVGotAtom:
.018907	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018909	10 44		bpl $01894f			bpl 	_EVExitDrop 				; must be a token.
.01890b	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.01890d	b0 40		bcs $01894f			bcs 	_EVExitDrop
.01890f	68		pla				pla 								; get current precedence
.018910	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.018912	da		phx				phx 								; save X
.018913	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018915	aa		tax				tax 								; put in X
.018916	bf e5 84 01	lda $0184e5,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.01891a	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.01891c	fa		plx				plx 								; restore X
.01891d	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.01891f	90 2f		bcc $018950			bcc 	_EVExit 					; exit if too low.
.018921	f0 2d		beq $018950			beq 	_EVExit 					; exit if equals
.018923	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.018925	48		pha				pha
.018926	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018928	48		pha				pha
.018929	c8		iny				iny
.01892a	da		phx				phx 								; save current position
.01892b	e8		inx				inx
.01892c	e8		inx				inx
.01892d	e8		inx				inx
.01892e	e8		inx				inx
.01892f	e8		inx				inx
.018930	e8		inx				inx
.018931	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.018933	20 be 88	jsr $0188be			jsr 	EvaluateExpressionXA 		; do the RHS.
.018936	fa		plx				plx 								; restore X
.018937	68		pla				pla 								; get the binary operator in A.
.018938					_EVCallA:
.018938	da		phx				phx 								; save X again
.018939	0a		asl a				asl 	a 							; double, lose the MSB.
.01893a	aa		tax				tax									; put in X
.01893b	bf 96 84 01	lda $018496,x			lda 	VectorTable,x 				; copy address into zGenPtr
.01893f	8d 05 03	sta $0305			sta 	LocalVector+1
.018942	bf 97 84 01	lda $018497,x			lda 	VectorTable+1,x
.018946	8d 06 03	sta $0306			sta 	LocalVector+2
.018949	fa		plx				plx 								; restore X
.01894a	20 ca 89	jsr $0189ca			jsr 	EVCallLocalVector
.01894d	80 b8		bra $018907			bra 	_EVGotAtom 					; and loop back.
.01894f					_EVExitDrop:
.01894f	68		pla				pla
.018950					_EVExit:
.018950	60		rts				rts
.018951					_EVNotInteger:
.018951	c8		iny				iny
.018952	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.018954	d0 19		bne $01896f			bne 	_EVNotMinus
.018956	20 4e 8a	jsr $018a4e			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.018959	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.01895c	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.01895e	f0 05		beq $018965			beq 	_EVMinusFloat
.018960	20 a1 96	jsr $0196a1			jsr 	IntegerNegateAlways 		; negation
.018963	80 a2		bra $018907			bra 	_EVGotAtom 					; and go back.
.018965					_EVMinusFloat:
.018965	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; invert the sign bit.
.018968	49 80		eor #$80			eor 	#$80
.01896a	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.01896d	80 98		bra $018907			bra 	_EVGotAtom
.01896f					_EVNotMinus:
.01896f	c9 bd		cmp #$bd			cmp 	#token_lparen 				; is it left parenthesis
.018971	d0 17		bne $01898a			bne 	_EVNotParenthesis
.018973	20 bc 88	jsr $0188bc			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.018976	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018978	c8		iny				iny
.018979	c9 be		cmp #$be			cmp 	#token_rparen 				; okay if right bracket.
.01897b	f0 8a		beq $018907			beq 	_EVGotAtom
.01897d	20 2f 84	jsr $01842f			jsr ERR_Handler
>018980	4d 69 73 73 69 6e 67 20			.text "Missing )",0
>018988	29 00
.01898a					_EVNotParenthesis:
.01898a	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.01898c	d0 0c		bne $01899a			bne 	_EVNotNot
.01898e	20 4e 8a	jsr $018a4e			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.018991	20 af 9b	jsr $019baf			jsr 	FPUToInteger 				; make it an integer - if possible.
.018994	20 2b 8a	jsr $018a2b			jsr 	NotInteger 					; do the not calculation
.018997	4c 07 89	jmp $018907			jmp 	_EVGotAtom
.01899a					_EVNotNot:
.01899a	c9 fe		cmp #$fe			cmp 	#$FE
.01899c	d0 15		bne $0189b3			bne 	_EVNotString
.01899e	20 6e 91	jsr $01916e			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.0189a1	a5 20		lda $20				lda 	zTempStr 					; copy address of string into mantissa
.0189a3	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0189a6	a5 21		lda $21				lda 	zTempStr+1
.0189a8	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0189ab	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.0189ad	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0189b0	4c 07 89	jmp $018907			jmp 	_EVGotAtom
.0189b3					_EVNotString:
.0189b3	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.0189b5	90 04		bcc $0189bb			bcc 	_EVBadElement
.0189b7	c9 b7		cmp #$b7			cmp 	#lastUnaryFunction+1
.0189b9	90 03		bcc $0189be			bcc 	_EVUnaryFunction
.0189bb					_EVBadElement:
.0189bb	4c 00 84	jmp $018400			jmp 	SyntaxError
.0189be					_EVUnaryFunction:
.0189be	4c 38 89	jmp $018938			jmp 	_EVCallA
.0189c1					_EVVariableHandler:
.0189c1	20 94 91	jsr $019194			jsr 	VariableFind 				; locate a variable
.0189c4	20 e5 94	jsr $0194e5			jsr 	VariableGet 				; copy into memory.
.0189c7	4c 07 89	jmp $018907			jmp 	_EVGotAtom 					; and go round.
.0189ca					EVCallLocalVector:
.0189ca	6c 05 03	jmp ($0305)			jmp 	(LocalVector+1)
.0189cd					EVShiftMantissaLeft6:
.0189cd	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.0189d0	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.0189d3	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.0189d6	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0189d9	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0189dc	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0189df	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.0189e2	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0189e5	a9 00		lda #$00			lda 	#0
.0189e7	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0189ea	20 ed 89	jsr $0189ed			jsr 	_EVSMLShift 					; call it here to do it twice
.0189ed					_EVSMLShift:
.0189ed	5e 0c 03	lsr $030c,x			lsr 	XS_Exponent,x
.0189f0	7e 0b 03	ror $030b,x			ror 	XS_Mantissa+3,x
.0189f3	7e 0a 03	ror $030a,x			ror 	XS_Mantissa+2,x
.0189f6	7e 09 03	ror $0309,x			ror 	XS_Mantissa+1,x
.0189f9	7e 08 03	ror $0308,x			ror 	XS_Mantissa+0,x
.0189fc	60		rts				rts
.0189fd					EVGetDecimal:
.0189fd	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.0189ff	8d 05 04	sta $0405			sta 	Num_Buffer
.018a02	da		phx				phx
.018a03	c8		iny				iny
.018a04	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018a06	c8		iny				iny
.018a07	3a		dec a				dec 	a								; convert to a string length.
.018a08	3a		dec a				dec 	a
.018a09	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.018a0b					_EVGDCopy:
.018a0b	48		pha				pha 									; save count
.018a0c	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018a0e	9d 05 04	sta $0405,x			sta 	Num_Buffer,x
.018a11	e8		inx				inx 									; forward ....
.018a12	c8		iny				iny
.018a13	68		pla				pla 									; get count
.018a14	3a		dec a				dec 	a 								; until zero
.018a15	d0 f4		bne $018a0b			bne 	_EVGDCopy
.018a17	9d 05 04	sta $0405,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.018a1a	fa		plx				plx 									; restore X
.018a1b	a9 05		lda #$05			lda 	#Num_Buffer & $FF 				; set zGenPtr
.018a1d	85 1e		sta $1e				sta 	zGenPtr
.018a1f	a9 04		lda #$04			lda 	#Num_Buffer >> 8
.018a21	85 1f		sta $1f				sta 	zGenPtr+1
.018a23	5a		phy				phy 									; save Y
.018a24	a0 00		ldy #$00			ldy 	#0 								; start position
.018a26	20 a1 9d	jsr $019da1			jsr 	FPFromString 					; convert current
.018a29	7a		ply				ply 									; restore Y
.018a2a	60		rts				rts
.018a2b					NotInteger:
.018a2b	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018a2e	49 ff		eor #$ff			eor 	#$FF
.018a30	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018a33	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018a36	49 ff		eor #$ff			eor 	#$FF
.018a38	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018a3b	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018a3e	49 ff		eor #$ff			eor 	#$FF
.018a40	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018a43	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.018a46	49 ff		eor #$ff			eor 	#$FF
.018a48	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018a4b	60		rts				rts
.018a4c					EvaluateGetAtom:
.018a4c	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.018a4e					EvaluateGetAtomX:
.018a4e	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.018a50	20 be 88	jsr $0188be			jsr 	EvaluateExpressionXA
.018a53	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.018a56	29 0f		and #$0f			and 	#15
.018a58	c9 02		cmp #$02			cmp 	#2
.018a5a	b0 01		bcs $018a5d			bcs 	EvaluateType
.018a5c	60		rts				rts
.018a5d					EvaluateType:
.018a5d	4c 10 84	jmp $018410			jmp 	TypeError
.018a60					EvaluateNumber:
.018a60	a2 00		ldx #$00			ldx 	#0
.018a62					EvaluateNumberX:
.018a62	20 bc 88	jsr $0188bc			jsr 	EvaluateExpressionX
.018a65	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 0/1
.018a68	29 0f		and #$0f			and 	#15
.018a6a	c9 02		cmp #$02			cmp 	#2
.018a6c	b0 ef		bcs $018a5d			bcs 	EvaluateType
.018a6e	60		rts				rts
.018a6f					EvaluateInteger:
.018a6f	a2 00		ldx #$00			ldx 	#0
.018a71					EvaluateIntegerX:
.018a71	20 62 8a	jsr $018a62			jsr 	EvaluateNumberX
.018a74	20 af 9b	jsr $019baf			jsr 	FPUToInteger
.018a77	60		rts				rts
.018a78					EvaluateString:
.018a78	a2 00		ldx #$00			ldx 	#0
.018a7a					EvaluateStringX:
.018a7a	20 bc 88	jsr $0188bc			jsr 	EvaluateExpressionX
.018a7d	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 2
.018a80	29 0f		and #$0f			and 	#15
.018a82	c9 02		cmp #$02			cmp 	#2
.018a84	d0 d7		bne $018a5d			bne 	EvaluateType
.018a86	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.018a89	85 1e		sta $1e				sta 	zGenPtr
.018a8b	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018a8e	85 1f		sta $1f				sta 	zGenPtr+1
.018a90	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.018a91					BinaryOp_And:
.018a91	20 09 8b	jsr $018b09			jsr 	BinaryMakeBothInteger
.018a94	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.018a97	3d 0e 03	and $030e,x			and 	XS2_Mantissa+0,x
.018a9a	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018a9d	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.018aa0	3d 0f 03	and $030f,x			and 	XS2_Mantissa+1,x
.018aa3	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018aa6	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.018aa9	3d 10 03	and $0310,x			and 	XS2_Mantissa+2,x
.018aac	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018aaf	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.018ab2	3d 11 03	and $0311,x			and 	XS2_Mantissa+3,x
.018ab5	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018ab8	60		rts				rts
.018ab9					BinaryOp_Or:
.018ab9	20 09 8b	jsr $018b09			jsr 	BinaryMakeBothInteger
.018abc	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.018abf	1d 0e 03	ora $030e,x			ora 	XS2_Mantissa+0,x
.018ac2	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018ac5	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.018ac8	1d 0f 03	ora $030f,x			ora 	XS2_Mantissa+1,x
.018acb	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018ace	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.018ad1	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.018ad4	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018ad7	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.018ada	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.018add	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018ae0	60		rts				rts
.018ae1					BinaryOp_Eor:
.018ae1					BinaryOp_Xor:
.018ae1	20 09 8b	jsr $018b09			jsr 	BinaryMakeBothInteger
.018ae4	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.018ae7	5d 0e 03	eor $030e,x			eor 	XS2_Mantissa+0,x
.018aea	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018aed	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.018af0	5d 0f 03	eor $030f,x			eor 	XS2_Mantissa+1,x
.018af3	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018af6	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.018af9	5d 10 03	eor $0310,x			eor 	XS2_Mantissa+2,x
.018afc	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018aff	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.018b02	5d 11 03	eor $0311,x			eor 	XS2_Mantissa+3,x
.018b05	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018b08	60		rts				rts
.018b09					BinaryMakeBothInteger:
.018b09	da		phx				phx 								; save X
.018b0a	e8		inx				inx
.018b0b	e8		inx				inx
.018b0c	e8		inx				inx
.018b0d	e8		inx				inx
.018b0e	e8		inx				inx
.018b0f	e8		inx				inx
.018b10	20 14 8b	jsr $018b14			jsr 	BinaryMakeInteger 			; convert to integer.
.018b13	fa		plx				plx 								; restore X and fall through.
.018b14					BinaryMakeInteger:
.018b14	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type byte.
.018b17	29 0f		and #$0f			and 	#15 						; check type zero
.018b19	f0 04		beq $018b1f			beq 	_BMIConvert 				; if float convert to integer.
.018b1b	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.018b1c	90 04		bcc $018b22			bcc 	_BMIError
.018b1e	60		rts				rts
.018b1f					_BMIConvert:
.018b1f	4c af 9b	jmp $019baf			jmp 	FPUToInteger 				; convert to integer
.018b22					_BMIError:
.018b22	4c 10 84	jmp $018410			jmp 	TypeError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.018b25					Binary_Equal:
.018b25	20 71 8b	jsr $018b71			jsr 	CompareValues
.018b28	09 00		ora #$00			ora 	#0
.018b2a	f0 04		beq $018b30			beq 	CCTrue
.018b2c	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.018b2e	80 02		bra $018b32			bra 	CCWrite
.018b30	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.018b32	9d 08 03	sta $0308,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.018b35	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018b38	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018b3b	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018b3e	a9 01		lda #$01			lda 	#1
.018b40	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; set type to integer whatever.
.018b43	60		rts				rts
.018b44					Binary_NotEqual:
.018b44	20 71 8b	jsr $018b71			jsr 	CompareValues
.018b47	09 00		ora #$00			ora 	#0
.018b49	f0 e1		beq $018b2c			beq 	CCFalse
.018b4b	80 e3		bra $018b30			bra 	CCTrue
.018b4d					Binary_Less:
.018b4d	20 71 8b	jsr $018b71			jsr 	CompareValues
.018b50	09 00		ora #$00			ora 	#0
.018b52	30 dc		bmi $018b30			bmi 	CCTrue
.018b54	80 d6		bra $018b2c			bra 	CCFalse
.018b56					Binary_LessEqual:
.018b56	20 71 8b	jsr $018b71			jsr 	CompareValues
.018b59	c9 01		cmp #$01			cmp 	#1
.018b5b	d0 d3		bne $018b30			bne 	CCTrue
.018b5d	80 cd		bra $018b2c			bra 	CCFalse
.018b5f					Binary_GreaterEqual:
.018b5f	20 71 8b	jsr $018b71			jsr 	CompareValues
.018b62	09 00		ora #$00			ora 	#0
.018b64	10 ca		bpl $018b30			bpl 	CCTrue
.018b66	80 c4		bra $018b2c			bra 	CCFalse
.018b68					Binary_Greater:
.018b68	20 71 8b	jsr $018b71			jsr 	CompareValues
.018b6b	c9 01		cmp #$01			cmp 	#1
.018b6d	f0 c1		beq $018b30			beq 	CCTrue
.018b6f	80 bb		bra $018b2c			bra 	CCFalse
.018b71					CompareValues:
.018b71	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and the types together
.018b74	3d 13 03	and $0313,x			and 	XS2_Type,x
.018b77	c9 02		cmp #$02			cmp 	#2
.018b79	f0 13		beq $018b8e			beq 	_CVString
.018b7b	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018b7e	3d 13 03	and $0313,x			and 	XS2_Type,x
.018b81	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018b82	90 03		bcc $018b87			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018b84	4c d4 8b	jmp $018bd4			jmp 	CompareInteger32 							; so execute code at \1
.018b87					_BCFloat:
.018b87	20 a2 8c	jsr $018ca2			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018b8a	4c be 9a	jmp $019abe			jmp 	FPCompare 							; and execute code at \2
.018b8d	60		rts				rts
.018b8e					_CVString:
.018b8e	da		phx				phx 								; save XY
.018b8f	5a		phy				phy
.018b90	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.018b93	85 1a		sta $1a				sta		zLTemp1+0
.018b95	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018b98	85 1b		sta $1b				sta 	zLTemp1+1
.018b9a	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x
.018b9d	85 1c		sta $1c				sta 	zLTemp1+2
.018b9f	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.018ba2	85 1d		sta $1d				sta 	zLTemp1+3
.018ba4	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.018ba6	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.018ba8	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.018baa	90 02		bcc $018bae			bcc 	_CVCommon
.018bac	b1 1c		lda ($1c),y			lda 	(zLTemp1+2),y
.018bae					_CVCommon:
.018bae	aa		tax				tax 								; put shorter string length in zero.
.018baf	f0 0c		beq $018bbd			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.018bb1					_CVCompare:
.018bb1	c8		iny				iny 								; next character
.018bb2	b1 1a		lda ($1a),y			lda 	(zLTemp1),y 				; compare characters
.018bb4	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.018bb6	90 13		bcc $018bcb			bcc 	_CVReturnLess 				; <
.018bb8	d0 15		bne $018bcf			bne 	_CVReturnGreater 			; >
.018bba	ca		dex				dex 								; until common length matched.
.018bbb	d0 f4		bne $018bb1			bne 	_CVCompare
.018bbd					_CVMatch:
.018bbd	a0 00		ldy #$00			ldy 	#0
.018bbf	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.018bc1	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.018bc3	90 06		bcc $018bcb			bcc 	_CVReturnLess 				; <
.018bc5	d0 08		bne $018bcf			bne 	_CVReturnGreater 			; >
.018bc7	a9 00		lda #$00			lda 	#0
.018bc9	80 06		bra $018bd1			bra 	_CVExit 					; same common, same length, same string
.018bcb					_CVReturnLess:
.018bcb	a9 ff		lda #$ff			lda 	#$FF
.018bcd	80 02		bra $018bd1			bra 	_CVExit
.018bcf					_CVReturnGreater:
.018bcf	a9 01		lda #$01			lda 	#$01
.018bd1					_CVExit:
.018bd1	7a		ply				ply
.018bd2	fa		plx				plx
.018bd3	60		rts				rts
.018bd4					CompareInteger32:
.018bd4	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.018bd7	49 80		eor #$80			eor 	#$80
.018bd9	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018bdc	bd 11 03	lda $0311,x			lda 	XS2_Mantissa+3,x
.018bdf	49 80		eor #$80			eor 	#$80
.018be1	9d 11 03	sta $0311,x			sta 	XS2_Mantissa+3,x
.018be4	20 7c 8c	jsr $018c7c			jsr 	SubInteger32 				; subtraction
.018be7	90 11		bcc $018bfa			bcc 	_CI32Less 					; cc return -1
.018be9	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; check if zero
.018bec	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.018bef	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.018bf2	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.018bf5	f0 02		beq $018bf9			beq 	_CI32Exit
.018bf7	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.018bf9					_CI32Exit:
.018bf9	60		rts				rts
.018bfa					_CI32Less:
.018bfa	a9 ff		lda #$ff			lda 	#$FF
.018bfc	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.018bfd					BinaryOp_Add:
.018bfd	bd 0d 03	lda $030d,x			lda 	XS_Type,x  					; and types together
.018c00	3d 13 03	and $0313,x			and 	XS2_Type,x
.018c03	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.018c05	d0 13		bne $018c1a			bne 	_BOAString
.018c07	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018c0a	3d 13 03	and $0313,x			and 	XS2_Type,x
.018c0d	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018c0e	90 03		bcc $018c13			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018c10	4c 56 8c	jmp $018c56			jmp 	AddInteger32 							; so execute code at \1
.018c13					_BCFloat:
.018c13	20 a2 8c	jsr $018ca2			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018c16	4c 32 98	jmp $019832			jmp 	FPAdd 							; and execute code at \2
.018c19	60		rts				rts
.018c1a					_BOAString:
.018c1a	4c bd 8c	jmp $018cbd			jmp 	ConcatenateString 			; concatenate two strings.
.018c1d					BinaryOp_Subtract:
.018c1d	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018c20	3d 13 03	and $0313,x			and 	XS2_Type,x
.018c23	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018c24	90 03		bcc $018c29			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018c26	4c 7c 8c	jmp $018c7c			jmp 	SubInteger32 							; so execute code at \1
.018c29					_BCFloat:
.018c29	20 a2 8c	jsr $018ca2			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018c2c	4c 28 98	jmp $019828			jmp 	FPSubtract 							; and execute code at \2
.018c2f	60		rts				rts
.018c30					BinaryOp_Multiply:
.018c30	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018c33	3d 13 03	and $0313,x			and 	XS2_Type,x
.018c36	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018c37	90 03		bcc $018c3c			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018c39	4c b4 95	jmp $0195b4			jmp 	MulInteger32 							; so execute code at \1
.018c3c					_BCFloat:
.018c3c	20 a2 8c	jsr $018ca2			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018c3f	4c 9e 99	jmp $01999e			jmp 	FPMultiply 							; and execute code at \2
.018c42	60		rts				rts
.018c43					BinaryOp_Divide:
.018c43	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018c46	3d 13 03	and $0313,x			and 	XS2_Type,x
.018c49	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018c4a	90 03		bcc $018c4f			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018c4c	4c 0b 96	jmp $01960b			jmp 	DivInteger32 							; so execute code at \1
.018c4f					_BCFloat:
.018c4f	20 a2 8c	jsr $018ca2			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018c52	4c 16 99	jmp $019916			jmp 	FPDivide 							; and execute code at \2
.018c55	60		rts				rts
.018c56					AddInteger32:
.018c56	18		clc				clc
.018c57	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018c5a	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.018c5d	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018c60	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018c63	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.018c66	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018c69	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018c6c	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.018c6f	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018c72	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.018c75	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.018c78	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018c7b	60		rts				rts
.018c7c					SubInteger32:
.018c7c	38		sec				sec
.018c7d	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018c80	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.018c83	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018c86	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018c89	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.018c8c	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018c8f	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018c92	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.018c95	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018c98	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.018c9b	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.018c9e	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018ca1	60		rts				rts
.018ca2					BinaryMakeBothFloat:
.018ca2	da		phx				phx 								; save X
.018ca3	e8		inx				inx
.018ca4	e8		inx				inx
.018ca5	e8		inx				inx
.018ca6	e8		inx				inx
.018ca7	e8		inx				inx
.018ca8	e8		inx				inx
.018ca9	20 ad 8c	jsr $018cad			jsr 	BinaryMakeFloat 			; convert to float.
.018cac	fa		plx				plx 								; restore X and fall through.
.018cad					BinaryMakeFloat:
.018cad	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type byte.
.018cb0	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.018cb1	b0 04		bcs $018cb7			bcs 	_BMFConvert
.018cb3	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.018cb4	b0 04		bcs $018cba			bcs 	_BMFError
.018cb6	60		rts				rts
.018cb7					_BMFConvert:
.018cb7	4c 50 9b	jmp $019b50			jmp 	FPUToFloat 					; convert to float
.018cba					_BMFError:
.018cba	4c 10 84	jmp $018410			jmp 	TypeError
.018cbd					ConcatenateString:
.018cbd	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.018cc0	85 1a		sta $1a				sta		zLTemp1+0
.018cc2	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018cc5	85 1b		sta $1b				sta 	zLTemp1+1
.018cc7	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x
.018cca	85 1c		sta $1c				sta 	zLTemp1+2
.018ccc	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.018ccf	85 1d		sta $1d				sta 	zLTemp1+3
.018cd1	5a		phy				phy
.018cd2	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.018cd4	b1 1a		lda ($1a),y			lda 	(zlTemp1),y
.018cd6	71 1c		adc ($1c),y			adc 	(zlTemp1+2),y
.018cd8	7a		ply				ply
.018cd9	b0 37		bcs $018d12			bcs 	_CSError					; check in range.
.018cdb	c9 fe		cmp #$fe			cmp 	#maxString+1
.018cdd	b0 33		bcs $018d12			bcs 	_CSError
.018cdf	20 33 91	jsr $019133			jsr 	AllocateTempString 			; store the result
.018ce2	20 fd 8c	jsr $018cfd			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.018ce5	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.018ce8	85 1a		sta $1a				sta 	zLTemp1
.018cea	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.018ced	85 1b		sta $1b				sta 	zLTemp1+1
.018cef	20 fd 8c	jsr $018cfd			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.018cf2	a5 20		lda $20				lda 	zTempStr 					; point current to new string
.018cf4	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018cf7	a5 21		lda $21				lda 	zTempStr+1
.018cf9	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018cfc	60		rts				rts
.018cfd					_CSCopyString:
.018cfd	da		phx				phx
.018cfe	5a		phy				phy
.018cff	a0 00		ldy #$00			ldy 	#0 							; get length
.018d01	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.018d03	f0 0a		beq $018d0f			beq 	_CSCSExit 					; if zero, exit
.018d05	aa		tax				tax 								; put in X
.018d06					_CSCSLoop:
.018d06	c8		iny				iny 								; get next char
.018d07	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.018d09	20 5e 91	jsr $01915e			jsr		WriteTempString 			; copy out
.018d0c	ca		dex				dex 								; do whole string
.018d0d	d0 f7		bne $018d06			bne 	_CSCSLoop
.018d0f					_CSCSExit:
.018d0f	7a		ply				ply
.018d10	fa		plx				plx
.018d11	60		rts				rts
.018d12					_CSError:
.018d12	20 2f 84	jsr $01842f			jsr ERR_Handler
>018d15	53 74 72 69 6e 67 20 74			.text "String too long",0
>018d1d	6f 6f 20 6c 6f 6e 67 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.018d25					Unary_Sgn:
.018d25	20 62 8a	jsr $018a62			jsr 	EvaluateNumberX 			; get value
.018d28	20 f1 90	jsr $0190f1			jsr 	CheckNextRParen 			; check right bracket.
.018d2b	20 4f 8d	jsr $018d4f			jsr 	GetSignCurrent 				; get sign.
.018d2e	09 00		ora #$00			ora 	#0
.018d30	10 09		bpl $018d3b			bpl		UnarySetAInteger			; if 0,1 return that.
.018d32	80 00		bra $018d34			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.018d34					UnarySetAMinus1:
.018d34	a9 ff		lda #$ff			lda 	#$FF
.018d36	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.018d39	80 05		bra $018d40			bra 	UnarySetAFill
.018d3b					UnarySetAInteger:
.018d3b	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.018d3e	a9 00		lda #$00			lda 	#0
.018d40					UnarySetAFill:
.018d40	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018d43	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018d46	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018d49	a9 01		lda #$01			lda 	#1
.018d4b	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018d4e	60		rts				rts
.018d4f					GetSignCurrent:
.018d4f	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; identify type.
.018d52	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.018d53	90 19		bcc $018d6e			bcc 	_GSCFloat
.018d55	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.018d58	30 11		bmi $018d6b			bmi 	_GSCMinus1
.018d5a	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x
.018d5d	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.018d60	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.018d63	d0 03		bne $018d68			bne 	_GSCPlus1
.018d65					_GSCZero:
.018d65	a9 00		lda #$00			lda 	#0
.018d67	60		rts				rts
.018d68					_GSCPlus1:
.018d68	a9 01		lda #$01			lda 	#$01
.018d6a	60		rts				rts
.018d6b					_GSCMinus1:
.018d6b	a9 ff		lda #$ff			lda 	#$FF
.018d6d	60		rts				rts
.018d6e					_GSCFloat:
.018d6e	3c 0d 03	bit $030d,x			bit 	XS_Type,x
.018d71	70 f2		bvs $018d65			bvs 	_GSCZero
.018d73	30 f6		bmi $018d6b			bmi 	_GSCMinus1
.018d75	80 f1		bra $018d68			bra 	_GSCPlus1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.018d77					Unary_Abs:
.018d77	20 62 8a	jsr $018a62			jsr 	EvaluateNumberX 			; get value
.018d7a	20 f1 90	jsr $0190f1			jsr 	CheckNextRParen 			; check right bracket.
.018d7d	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.018d80	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.018d82	f0 08		beq $018d8c			beq 	_UAMinusFloat
.018d84	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; check MSB
.018d87	10 0b		bpl $018d94			bpl 	_UAExit
.018d89	4c a1 96	jmp $0196a1			jmp 	IntegerNegateAlways 		; negation
.018d8c					_UAMinusFloat:
.018d8c	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; clear the sign bit.
.018d8f	29 7f		and #$7f			and		#$7F
.018d91	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018d94					_UAExit:
.018d94	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.018d95					Unary_Peek:
.018d95	a9 01		lda #$01			lda 	#1
.018d97	80 06		bra $018d9f			bra 	UPMain
.018d99					Unary_Deek:
.018d99	a9 02		lda #$02			lda 	#2
.018d9b	80 02		bra $018d9f			bra 	UPMain
.018d9d					Unary_Leek:
.018d9d	a9 04		lda #$04			lda 	#4
.018d9f					UPMain:
.018d9f	48		pha				pha 								; set bytes to copy.
.018da0	20 71 8a	jsr $018a71			jsr 	EvaluateIntegerX 			; numeric parameter
.018da3	20 f1 90	jsr $0190f1			jsr 	CheckNextRParen 			; right bracket.
.018da6	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.018da9	85 1a		sta $1a				sta 	zLTemp1
.018dab	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018dae	85 1b		sta $1b				sta 	zLTemp1+1
.018db0	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018db3	85 1c		sta $1c				sta 	zLTemp1+2
.018db5	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.018db8	85 1d		sta $1d				sta 	zLTemp1+3
.018dba	a9 00		lda #$00			lda 	#0 							; clear target area
.018dbc	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018dbf	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018dc2	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018dc5	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018dc8	68		pla				pla 								; restore bytes to copy
.018dc9	da		phx				phx 								; save XY
.018dca	5a		phy				phy
.018dcb	20 c8 90	jsr $0190c8			jsr 	MemRead 					; read the bytes in
.018dce	7a		ply				ply 								; restore and exit
.018dcf	fa		plx				plx
.018dd0	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.018dd1					Unary_Mod:
.018dd1	20 fd 8d	jsr $018dfd			jsr 	_UMParameter 				; first parameter
.018dd4	20 f9 90	jsr $0190f9			jsr 	CheckNextComma
.018dd7	da		phx				phx 								; second parameter
.018dd8	e8		inx				inx
.018dd9	e8		inx				inx
.018dda	e8		inx				inx
.018ddb	e8		inx				inx
.018ddc	e8		inx				inx
.018ddd	e8		inx				inx
.018dde	20 fd 8d	jsr $018dfd			jsr 	_UMParameter
.018de1	fa		plx				plx
.018de2	20 f1 90	jsr $0190f1			jsr 	CheckNextRParen
.018de5	20 0b 96	jsr $01960b			jsr 	DivInteger32 				; divide
.018de8	a5 1a		lda $1a				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.018dea	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018ded	a5 1b		lda $1b				lda 	zLTemp1+1
.018def	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018df2	a5 1c		lda $1c				lda 	zLTemp1+2
.018df4	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018df7	a5 1d		lda $1d				lda 	zLTemp1+3
.018df9	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018dfc	60		rts				rts
.018dfd					_UMParameter:
.018dfd	20 71 8a	jsr $018a71			jsr 	EvaluateIntegerX 			; get value
.018e00	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; absolute value
.018e03	10 03		bpl $018e08			bpl 	_UMNotSigned
.018e05	20 a1 96	jsr $0196a1			jsr 	IntegerNegateAlways
.018e08					_UMNotSigned:
.018e08	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.018e09					Unary_Usr:
.018e09	20 62 8a	jsr $018a62			jsr 	EvaluateNumberX 			; numeric parameter
.018e0c	20 f1 90	jsr $0190f1			jsr 	CheckNextRParen 			; right bracket.
.018e0f	da		phx				phx 								; save XY
.018e10	5a		phy				phy
.018e11	ea		nop				nop
.018e12	22 00 03 00	jsl $000300			jsl 	UserVector
.018e16	7a		ply				ply 								; and exit
.018e17	fa		plx				plx
.018e18	60		rts				rts
.018e19					USRDefault:
.018e19	20 2f 84	jsr $01842f			jsr ERR_Handler
>018e1c	4e 6f 20 55 53 52 20 76			.text "No USR vector.",0
>018e24	65 63 74 6f 72 2e 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.018e2b					Unary_Val:
.018e2b	20 7a 8a	jsr $018a7a			jsr 	EvaluateStringX 			; get string
.018e2e	20 f1 90	jsr $0190f1			jsr 	CheckNextRParen 			; check right bracket.
.018e31	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.018e34	85 1e		sta $1e				sta 	zGenPtr
.018e36	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018e39	85 1f		sta $1f				sta 	zGenPtr+1
.018e3b	5a		phy				phy
.018e3c	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.018e3e	b1 1e		lda ($1e),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.018e40	f0 57		beq $018e99			beq 	_UVBadNumber
.018e42	48		pha				pha 								; save length.
.018e43	1a		inc a				inc 	a 							; one for the length, one for the terminator
.018e44	1a		inc a				inc 	a
.018e45	20 33 91	jsr $019133			jsr 	AllocateTempString
.018e48	c8		iny				iny 								; move to the next.
.018e49	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get character
.018e4b	49 2d		eor #$2d			eor 	#"-"						; zero if minus sign
.018e4d	8d 90 04	sta $0490			sta 	ValSign
.018e50	d0 04		bne $018e56			bne 	_UVNotMinus
.018e52	c8		iny				iny 								; skip over it.
.018e53	68		pla				pla 								; decrement character count.
.018e54	3a		dec a				dec 	a
.018e55	48		pha				pha
.018e56					_UVNotMinus:
.018e56	68		pla				pla 								; this is the count.
.018e57	48		pha		_UVCopy:pha									; copy into new temp string which is ASCIIZ
.018e58	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018e5a	c8		iny				iny
.018e5b	20 5e 91	jsr $01915e			jsr 	WriteTempString
.018e5e	68		pla				pla
.018e5f	3a		dec a				dec 	a
.018e60	d0 f5		bne $018e57			bne 	_UVCopy
.018e62	20 5e 91	jsr $01915e			jsr 	WriteTempString 			; make it ASCIIZ
.018e65	18		clc				clc
.018e66	a5 20		lda $20				lda 	zTempStr 					; tempstring +1 => genptr
.018e68	69 01		adc #$01			adc 	#1
.018e6a	85 1e		sta $1e				sta 	zGenPtr
.018e6c	a5 21		lda $21				lda 	zTempStr+1
.018e6e	69 00		adc #$00			adc 	#0
.018e70	85 1f		sta $1f				sta 	zGenPtr+1
.018e72	18		clc				clc
.018e73	20 7d 97	jsr $01977d			jsr 	IntFromString 				; first bit.
.018e76	b0 21		bcs $018e99			bcs 	_UVBadNumber
.018e78	20 a1 9d	jsr $019da1			jsr 	FPFromString				; try for a float part.
.018e7b	ad 90 04	lda $0490			lda 	ValSign 					; was it negative
.018e7e	d0 13		bne $018e93			bne 	_UVNotNegative
.018e80	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; check if integer
.018e83	4a		lsr a				lsr 	a
.018e84	b0 0a		bcs $018e90			bcs 	_UVInteger
.018e86	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; set sign bit
.018e89	09 80		ora #$80			ora 	#$80
.018e8b	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018e8e	80 03		bra $018e93			bra 	_UVNotNegative
.018e90					_UVInteger:
.018e90	20 a1 96	jsr $0196a1			jsr 	IntegerNegateAlways 		; sign it.
.018e93					_UVNotNegative:
.018e93	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; used everything
.018e95	d0 02		bne $018e99			bne 	_UVBadNumber
.018e97	7a		ply				ply
.018e98	60		rts				rts
.018e99					_UVBadNumber:
.018e99	4c 1e 84	jmp $01841e			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.018e9c					Unary_Str:
.018e9c	20 62 8a	jsr $018a62			jsr 	EvaluateNumberX 			; numeric parameter
.018e9f	20 f1 90	jsr $0190f1			jsr 	CheckNextRParen 			; right bracket.
.018ea2	a9 00		lda #$00			lda 	#0 							; reset buffer index
.018ea4	8d 04 04	sta $0404			sta 	NumBufX
.018ea7	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.018eaa	4a		lsr a				lsr 	a
.018eab	b0 05		bcs $018eb2			bcs 	_USInt 						; if msb set do as integer
.018ead	20 da 9c	jsr $019cda			jsr 	FPToString 					; call fp to str otherwise
.018eb0	80 03		bra $018eb5			bra 	_USDuplicate
.018eb2	20 c6 96	jsr $0196c6	_USInt:	jsr 	IntToString
.018eb5					_USDuplicate:
.018eb5	ad 04 04	lda $0404			lda 	NumBufX 					; chars in buffer
.018eb8	1a		inc a				inc 	a 							; one more for length
.018eb9	20 33 91	jsr $019133			jsr 	AllocateTempString 			; allocate space for it.
.018ebc	5a		phy				phy 								; save Y
.018ebd	a0 00		ldy #$00			ldy 	#0 							; start copying
.018ebf	b9 05 04	lda $0405,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.018ec2	20 5e 91	jsr $01915e			jsr 	WriteTempString
.018ec5	c8		iny				iny
.018ec6	cc 04 04	cpy $0404			cpy 	NumBufX 					; done the lot
.018ec9	d0 f4		bne $018ebf			bne 	_USCopy
.018ecb	7a		ply				ply 								; restore Y
.018ecc	4c b8 90	jmp $0190b8			jmp 	UnaryReturnTempStr 			; return new temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.018ecf					Unary_Asc:
.018ecf	20 7a 8a	jsr $018a7a			jsr 	EvaluateStringX 			; string parameter
.018ed2	20 f1 90	jsr $0190f1			jsr 	CheckNextRParen 			; right bracket.
.018ed5	5a		phy				phy 								; get the string length
.018ed6	a0 00		ldy #$00			ldy 	#0
.018ed8	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018eda	f0 07		beq $018ee3			beq 	_UAIllegal 					; must be at least one character
.018edc	c8		iny				iny
.018edd	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; read it.
.018edf	7a		ply				ply
.018ee0	4c 3b 8d	jmp $018d3b			jmp 	UnarySetAInteger
.018ee3					_UAIllegal:
.018ee3	4c 1e 84	jmp $01841e			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.018ee6					Unary_Len:
.018ee6	20 7a 8a	jsr $018a7a			jsr 	EvaluateStringX 			; string parameter
.018ee9	20 f1 90	jsr $0190f1			jsr 	CheckNextRParen 			; right bracket.
.018eec	5a		phy				phy 								; get the string length
.018eed	a0 00		ldy #$00			ldy 	#0
.018eef	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018ef1	7a		ply				ply
.018ef2	4c 3b 8d	jmp $018d3b			jmp 	UnarySetAInteger

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.018ef5					Unary_Mid:
.018ef5	20 7a 8a	jsr $018a7a			jsr 	EvaluateStringX 				; get string.
.018ef8	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.018efb	48		pha				pha
.018efc	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018eff	48		pha				pha
.018f00	20 f9 90	jsr $0190f9			jsr 	CheckNextComma 					; skip comma
.018f03	20 90 8f	jsr $018f90			jsr 	SLIByteParameter 				; get a byte parameter (start)
.018f06	48		pha				pha 									; and push it.
.018f07	20 f9 90	jsr $0190f9			jsr 	CheckNextComma 					; skip comma
.018f0a	20 90 8f	jsr $018f90			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.018f0d	48		pha				pha 									; and push it.
.018f0e	80 45		bra $018f55			bra 	SLIProcess
.018f10					Unary_Left:
.018f10	20 7a 8a	jsr $018a7a			jsr 	EvaluateStringX 				; get string.
.018f13	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.018f16	48		pha				pha
.018f17	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018f1a	48		pha				pha
.018f1b	a9 01		lda #$01			lda 	#1 								; push start position (1)
.018f1d	48		pha				pha
.018f1e	20 f9 90	jsr $0190f9			jsr 	CheckNextComma 					; skip comma
.018f21	20 90 8f	jsr $018f90			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.018f24	48		pha				pha 									; and push it.
.018f25	80 2e		bra $018f55			bra 	SLIProcess
.018f27					Unary_Right:
.018f27	20 7a 8a	jsr $018a7a			jsr 	EvaluateStringX 				; get string.
.018f2a	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.018f2d	48		pha				pha
.018f2e	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018f31	48		pha				pha
.018f32	da		phx				phx 									; get the string length and push on stack.
.018f33	a2 00		ldx #$00			ldx 	#0
.018f35	a1 1e		lda ($1e,x)			lda		(zGenPtr,x)
.018f37	fa		plx				plx
.018f38	48		pha				pha
.018f39	20 f9 90	jsr $0190f9			jsr 	CheckNextComma 					; skip comma
.018f3c	20 90 8f	jsr $018f90			jsr 	SLIByteParameter 				; get a byte parameter.
.018f3f	8d 8e 04	sta $048e			sta 	SignCount 						; save in temporary.
.018f42	68		pla				pla 									; restore string length.
.018f43	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.018f44	38		sec				sec
.018f45	ed 8e 04	sbc $048e			sbc 	SignCount 						; subtract characters needed, gives start position.
.018f48	f0 02		beq $018f4c			beq 	_URStart 						; if <= 0 start from 1.
.018f4a	10 02		bpl $018f4e			bpl 	_UROkay
.018f4c					_URStart:
.018f4c	a9 01		lda #$01			lda 	#1
.018f4e					_UROkay:
.018f4e	48		pha				pha 									; push start
.018f4f	ad 8e 04	lda $048e			lda 	SignCount 						; push count of characters
.018f52	48		pha				pha
.018f53	80 00		bra $018f55			bra 	SLIProcess
.018f55					SLIProcess:
.018f55	20 f1 90	jsr $0190f1			jsr 	CheckNextRParen 				; closing right bracket.
.018f58	68		pla				pla
.018f59	8d 92 04	sta $0492			sta 	SliceCount 						; count in signcount
.018f5c	1a		inc a				inc 	a 								; allocate +1 for it.
.018f5d	20 33 91	jsr $019133			jsr 	AllocateTempString
.018f60	68		pla				pla 									; pop start number off stack.
.018f61	f0 3f		beq $018fa2			beq 	SLIError 						; exit if start = 0
.018f63	8d 91 04	sta $0491			sta 	SliceStart
.018f66	68		pla				pla  									; pop string address.
.018f67	85 1f		sta $1f				sta 	zGenPtr+1
.018f69	68		pla				pla
.018f6a	85 1e		sta $1e				sta 	zGenPtr
.018f6c	da		phx				phx
.018f6d	5a		phy				phy
.018f6e	a2 00		ldx #$00			ldx 	#0 								; point to string length.
.018f70	ac 91 04	ldy $0491			ldy 	SliceStart 						; start of the string (+1 for count)
.018f73					_SLICopy:
.018f73	ad 92 04	lda $0492			lda 	SliceCount 						; done count characters
.018f76	f0 12		beq $018f8a			beq 	_SLIExit
.018f78	ce 92 04	dec $0492			dec 	SliceCount
.018f7b	98		tya				tya 									; index of character
.018f7c	c1 1e		cmp ($1e,x)			cmp 	(zGenPtr,x)						; compare against length
.018f7e	f0 02		beq $018f82			beq 	_SLIOk 							; if equal, okay.
.018f80	b0 08		bcs $018f8a			bcs 	_SLIExit 						; if past end, then exit.
.018f82	b1 1e		lda ($1e),y	_SLIOk:	lda 	(zGenPtr),y 					; copy one character
.018f84	c8		iny				iny
.018f85	20 5e 91	jsr $01915e			jsr 	WriteTempString
.018f88	80 e9		bra $018f73			bra 	_SLICopy 						; go round till copied characters
.018f8a					_SLIExit:
.018f8a	7a		ply				ply 									; restore YX
.018f8b	fa		plx				plx
.018f8c	4c b8 90	jmp $0190b8			jmp 	UnaryReturnTempStr 				; return new temporary string.
.018f8f	ea		nop				nop
.018f90					SLIByteParameter:
.018f90	20 71 8a	jsr $018a71			jsr 	EvaluateIntegerX 				; get integer
.018f93	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.018f96	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.018f99	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.018f9c	d0 04		bne $018fa2			bne 	SLIError
.018f9e	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018fa1	60		rts				rts
.018fa2					SLIError:
.018fa2	4c 1e 84	jmp $01841e			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.018fa5					Unary_Hex:
.018fa5	20 71 8a	jsr $018a71			jsr 	EvaluateIntegerX 			; numeric parameter
.018fa8	20 f1 90	jsr $0190f1			jsr 	CheckNextRParen 			; right bracket.
.018fab	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.018fad	20 33 91	jsr $019133			jsr 	AllocateTempString			; allocate string space
.018fb0	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.018fb3	20 da 8f	jsr $018fda			jsr 	_UHConvert
.018fb6	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018fb9	20 da 8f	jsr $018fda			jsr 	_UHConvert
.018fbc	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018fbf	20 da 8f	jsr $018fda			jsr 	_UHConvert
.018fc2	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018fc5	20 da 8f	jsr $018fda			jsr 	_UHConvert
.018fc8	5a		phy				phy 								; get length of new string
.018fc9	a0 00		ldy #$00			ldy 	#0
.018fcb	b1 20		lda ($20),y			lda 	(zTempStr),y
.018fcd	7a		ply				ply
.018fce	c9 00		cmp #$00			cmp 	#0
.018fd0	d0 05		bne $018fd7			bne 	_UHExit 					; if it was non zero okay
.018fd2	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.018fd4	20 5e 91	jsr $01915e			jsr 	WriteTempString
.018fd7					_UHExit:
.018fd7	4c b8 90	jmp $0190b8			jmp 	UnaryReturnTempStr 			; return new temporary string.
.018fda					_UHConvert:
.018fda	48		pha				pha
.018fdb	4a		lsr a				lsr 	a 							; do MSB
.018fdc	4a		lsr a				lsr 	a
.018fdd	4a		lsr a				lsr 	a
.018fde	4a		lsr a				lsr 	a
.018fdf	20 e3 8f	jsr $018fe3			jsr 	_UHNibble
.018fe2	68		pla				pla 								; do LSB
.018fe3					_UHNibble:
.018fe3	29 0f		and #$0f			and 	#15 						; get nibble
.018fe5	d0 0c		bne $018ff3			bne 	_UHNonZero
.018fe7	5a		phy				phy									; get the length
.018fe8	a0 00		ldy #$00			ldy 	#0
.018fea	b1 20		lda ($20),y			lda 	(zTempStr),y
.018fec	7a		ply				ply
.018fed	c9 00		cmp #$00			cmp 	#0 							; suppress leading zeros.
.018fef	f0 0d		beq $018ffe			beq 	_UHExit2
.018ff1	a9 00		lda #$00			lda 	#0
.018ff3					_UHNonZero:
.018ff3	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.018ff5	90 02		bcc $018ff9			bcc 	_UHDigit
.018ff7	69 06		adc #$06			adc 	#7-1
.018ff9					_UHDigit:
.018ff9	69 30		adc #$30			adc 	#48
.018ffb	20 5e 91	jsr $01915e			jsr 	WriteTempString				; output.
.018ffe					_UHExit2:
.018ffe	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.018fff					Unary_Dec:
.018fff	20 7a 8a	jsr $018a7a			jsr 	EvaluateStringX 			; string parameter
.019002	20 f1 90	jsr $0190f1			jsr 	CheckNextRParen 			; right bracket.
.019005	5a		phy				phy
.019006	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.019008	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.01900a	f0 4c		beq $019058			beq 	_UDFail 					; must fail if zero.
.01900c	8d 8e 04	sta $048e			sta 	SignCount 					; use SignCount as a counter
.01900f	a9 00		lda #$00			lda 	#0 							; set result to zero integer.
.019011	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019014	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019017	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01901a	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.01901d	a9 01		lda #$01			lda 	#1
.01901f	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019022					_UDConvertLoop:
.019022	5a		phy				phy 								; shift mantissa left 4
.019023	a0 04		ldy #$04			ldy 	#4
.019025					_UDShift:
.019025	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x
.019028	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.01902b	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.01902e	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.019031	88		dey				dey
.019032	d0 f1		bne $019025			bne 	_UDShift
.019034	7a		ply				ply
.019035	c8		iny				iny 								; next character
.019036	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; fetch it.
.019038	20 5b 90	jsr $01905b			jsr 	ConvertUpper 				; convert to U/C
.01903b	c9 30		cmp #$30			cmp 	#"0"
.01903d	90 19		bcc $019058			bcc 	_UDFail
.01903f	c9 3a		cmp #$3a			cmp 	#"9"+1
.019041	90 06		bcc $019049			bcc 	_UDOkay
.019043	e9 37		sbc #$37			sbc 	#7+"0" 						; alpha fudge
.019045	c9 10		cmp #$10			cmp 	#16
.019047	b0 0f		bcs $019058			bcs 	_UDFail
.019049					_UDOkay:
.019049	29 0f		and #$0f			and 	#15 						; nibble only
.01904b	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x
.01904e	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019051	ce 8e 04	dec $048e			dec 	SignCount 					; do it for each character
.019054	d0 cc		bne $019022			bne 	_UDConvertLoop
.019056	7a		ply				ply
.019057	60		rts				rts
.019058					_UDFail:
.019058	4c 1e 84	jmp $01841e			jmp 	BadParamError
.01905b					ConvertUpper:
.01905b	c9 61		cmp #$61			cmp 	#"a"
.01905d	90 07		bcc $019066			bcc 	_CUExit
.01905f	c9 7b		cmp #$7b			cmp 	#"z"+1
.019061	b0 03		bcs $019066			bcs 	_CUExit
.019063	38		sec				sec
.019064	e9 20		sbc #$20			sbc 	#32
.019066	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.019067					Unary_Chr:
.019067	20 71 8a	jsr $018a71			jsr 	EvaluateIntegerX			; numeric parameter
.01906a	20 f1 90	jsr $0190f1			jsr 	CheckNextRParen 			; right bracket.
.01906d	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.019070	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.019073	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.019076	d0 0e		bne $019086			bne 	_UCChar
.019078	a9 01		lda #$01			lda 	#1 							; one character string
.01907a	20 33 91	jsr $019133			jsr 	AllocateTempString
.01907d	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.019080	20 5e 91	jsr $01915e			jsr 	WriteTempString
.019083	4c b8 90	jmp $0190b8			jmp 	UnaryReturnTempStr
.019086					_UCChar:
.019086	4c 1e 84	jmp $01841e			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.019089					Unary_Spc:
.019089	20 71 8a	jsr $018a71			jsr 	EvaluateIntegerX 			; numeric parameter
.01908c	20 f1 90	jsr $0190f1			jsr 	CheckNextRParen 			; right bracket.
.01908f	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.019092	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.019095	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.019098	d0 1b		bne $0190b5			bne 	_USSize
.01909a	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.01909d	c9 fe		cmp #$fe			cmp 	#maxString+1
.01909f	b0 14		bcs $0190b5			bcs 	_USSize
.0190a1	48		pha				pha 								; save length
.0190a2	1a		inc a				inc 	a 							; allocate one more.
.0190a3	20 33 91	jsr $019133			jsr 	AllocateTempString
.0190a6	68		pla				pla 								; get length
.0190a7	f0 0f		beq $0190b8			beq 	UnaryReturnTempStr 			; return the current temp string
.0190a9					_USLoop:
.0190a9	48		pha				pha
.0190aa	a9 20		lda #$20			lda 	#" "
.0190ac	20 5e 91	jsr $01915e			jsr 	WriteTempString
.0190af	68		pla				pla
.0190b0	3a		dec a				dec 	a
.0190b1	d0 f6		bne $0190a9			bne 	_USLoop
.0190b3	80 03		bra $0190b8			bra 	UnaryReturnTempStr
.0190b5					_USSize:
.0190b5	4c 1e 84	jmp $01841e			jmp 	BadParamError
.0190b8					UnaryReturnTempStr:
.0190b8	a5 20		lda $20				lda 	zTempStr 					; copy temp string addr -> mantissa
.0190ba	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0190bd	a5 21		lda $21				lda 	zTempStr+1
.0190bf	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0190c2	a9 02		lda #$02			lda 	#2 							; set type to string
.0190c4	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0190c7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/65816.asm

.0190c8					MemRead:
.0190c8	8d 8e 04	sta $048e			sta 	SignCount 					; save count
.0190cb	a0 00		ldy #$00			ldy 	#0 							; start from here
.0190cd	b7 1a		lda [$1a],y	_MLoop1:lda 	[zlTemp1],y 				; read the long address
.0190cf	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; copy into mantissa
.0190d2	c8		iny				iny 								; next to copy
.0190d3	e8		inx				inx
.0190d4	cc 8e 04	cpy $048e			cpy 	SignCount 					; do required # of bytes.
.0190d7	d0 f4		bne $0190cd			bne 	_MLoop1
.0190d9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.0190da					CheckNextToken:
.0190da	d7 16		cmp [$16],y			cmp 	[zCodePtr],y
.0190dc	d0 02		bne $0190e0			bne 	CTFail 						; no, then fail
.0190de	c8		iny				iny
.0190df	60		rts				rts
.0190e0					CTFail:
.0190e0	20 2f 84	jsr $01842f			jsr ERR_Handler
>0190e3	4d 69 73 73 69 6e 67 20			.text "Missing token",0
>0190eb	74 6f 6b 65 6e 00
.0190f1					CheckNextRParen:
.0190f1	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0190f3	c9 be		cmp #$be			cmp 	#token_rparen
.0190f5	d0 e9		bne $0190e0			bne 	CTFail
.0190f7	c8		iny				iny
.0190f8	60		rts				rts
.0190f9					CheckNextComma:
.0190f9	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0190fb	c9 bf		cmp #$bf			cmp 	#token_comma
.0190fd	d0 e1		bne $0190e0			bne 	CTFail
.0190ff	c8		iny				iny
.019100	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/concrete.asm

.019101					StringConcrete:
.019101	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; save source to zTemp1
.019104	85 10		sta $10				sta 	zTemp1
.019106	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.019109	85 11		sta $11				sta 	zTemp1+1
.01910b	a0 00		ldy #$00			ldy 	#0 							; subtract the length+1 (clc) of the string.
.01910d	18		clc				clc 								; from the string pointer
.01910e	ad 00 04	lda $0400			lda 	StringPtr 					; and put in zTemp2 as well
.019111	f1 10		sbc ($10),y			sbc 	(zTemp1),y
.019113	8d 00 04	sta $0400			sta 	StringPtr
.019116	85 12		sta $12				sta 	zTemp2
.019118	ad 01 04	lda $0401			lda 	StringPtr+1
.01911b	e9 00		sbc #$00			sbc 	#0
.01911d	8d 01 04	sta $0401			sta 	StringPtr+1
.019120	85 13		sta $13				sta 	zTemp2+1
.019122	b1 10		lda ($10),y			lda 	(zTemp1),y 					; length add one for count
.019124	1a		inc a				inc 	a
.019125	aa		tax				tax
.019126	b1 10		lda ($10),y	_SCCopy:lda 	(zTemp1),y 					; copy whole thing including length
.019128	91 12		sta ($12),y			sta 	(zTemp2),y
.01912a	c8		iny				iny
.01912b	ca		dex				dex
.01912c	d0 f8		bne $019126			bne 	_SCCopy
.01912e	a5 13		lda $13				lda 	zTemp2+1 					; return concrete string in AX
.019130	a6 12		ldx $12				ldx 	zTemp2
.019132	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.019133					AllocateTempString:
.019133	48		pha				pha 								; save required count.
.019134	a5 21		lda $21				lda 	zTempStr+1 					; check if initialised yet ?
.019136	d0 0b		bne $019143			bne 	_ATSInitialised
.019138	ad 00 04	lda $0400			lda 	StringPtr 					; set temporary string ptr 1 page below available
.01913b	85 20		sta $20				sta 	zTempStr					; space, this is for strings to be concreted.
.01913d	ad 01 04	lda $0401			lda 	StringPtr+1
.019140	3a		dec a				dec 	a
.019141	85 21		sta $21				sta 	zTempStr+1
.019143					_ATSInitialised:
.019143	68		pla				pla 								; get required count back.
.019144	49 ff		eor #$ff			eor 	#$FF 						; negate 2's complement.
.019146	1a		inc a				inc 	a
.019147	18		clc				clc
.019148	65 20		adc $20				adc 	zTempStr 					; "add" to the temp string pointer
.01914a	85 20		sta $20				sta 	zTempStr
.01914c	a9 ff		lda #$ff			lda 	#$FF
.01914e	65 21		adc $21				adc 	zTempStr+1
.019150	85 21		sta $21				sta 	zTempStr+1
.019152	a9 00		lda #$00			lda 	#0 							; clear temp string.
.019154	5a		phy				phy
.019155	a8		tay				tay
.019156	91 20		sta ($20),y			sta 	(zTempStr),y
.019158	7a		ply				ply
.019159	1a		inc a				inc 	a 							; reset the write index.
.01915a	8d 8f 04	sta $048f			sta 	TempStringWriteIndex
.01915d	60		rts				rts
.01915e					WriteTempString:
.01915e	5a		phy				phy 								; save Y
.01915f	ac 8f 04	ldy $048f			ldy 	TempStringWriteIndex	 	; write position.
.019162	91 20		sta ($20),y			sta 	(zTempStr),y 				; write character out.
.019164	ee 8f 04	inc $048f			inc 	TempStringWriteIndex 		; increment the write position.
.019167	98		tya				tya 								; unchanged Y is now length
.019168	a0 00		ldy #$00			ldy 	#0
.01916a	91 20		sta ($20),y			sta 	(zTempStr),y
.01916c	7a		ply				ply 								; restore Y and exit
.01916d	60		rts				rts
.01916e					CreateTempStringCopy:
.01916e	da		phx				phx 								; save X
.01916f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019171	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.019172	20 33 91	jsr $019133			jsr 	AllocateTempString 			; allocate memory for temporary string.
.019175	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019177	c8		iny				iny
.019178	3a		dec a				dec 	a 							; make the actual length in charactes
.019179	3a		dec a				dec 	a
.01917a	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.01917c	81 20		sta ($20,x)			sta 	(zTempStr,x)
.01917e	85 1a		sta $1a				sta 	zLTemp1 					; that's used as a count.
.019180	09 00		ora #$00			ora 	#0 							; if zero already, exit
.019182	f0 0e		beq $019192			beq 	_CTSCExit
.019184					_CTSCLoop:
.019184	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019186	c8		iny				iny
.019187	5a		phy				phy 								; save in Y
.019188	e8		inx				inx 								; bump index
.019189	da		phx				phx 								; index into Y
.01918a	7a		ply				ply
.01918b	91 20		sta ($20),y			sta 	(zTempStr),y 				; save at index
.01918d	7a		ply				ply 								; restore Y
.01918e	c6 1a		dec $1a				dec 	zLTemp1 					; do for each character
.019190	d0 f2		bne $019184			bne 	_CTSCLoop
.019192					_CTSCExit:
.019192	fa		plx				plx 								; restore X
.019193	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/variables.asm

.019194					VariableFind:
.019194	20 ff 91	jsr $0191ff			jsr 	VariableExtract 		; find out all about it ....
.019197	20 a1 94	jsr $0194a1			jsr 	VariableLocate 			; does it already exist ?
.01919a	b0 03		bcs $01919f			bcs 	_VFExists 				; if so, use that.
.01919c	20 8b 92	jsr $01928b			jsr 	VariableCreate 			; otherwise create it.
.01919f					_VFExists:
.01919f	a5 24		lda $24				lda 	zVarType 				; is it still an array ?
.0191a1	29 01		and #$01			and 	#1
.0191a3	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.0191a5	d0 28		bne $0191cf			bne 	_VFSingleElement
.0191a7					_VFNextIndex:
.0191a7	a5 22		lda $22				lda 	zVarDataPtr 			; push the data ptr and type on the stack.
.0191a9	48		pha				pha
.0191aa	a5 23		lda $23				lda 	zVarDataPtr+1
.0191ac	48		pha				pha
.0191ad	a5 24		lda $24				lda 	zVarType
.0191af	48		pha				pha
.0191b0	20 71 8a	jsr $018a71			jsr 	EvaluateIntegerX 		; calculate the index.
.0191b3	68		pla				pla 							; restore and index.
.0191b4	85 24		sta $24				sta 	zVarType
.0191b6	68		pla				pla
.0191b7	85 23		sta $23				sta 	zVarDataPtr+1
.0191b9	68		pla				pla
.0191ba	85 22		sta $22				sta 	zVarDataPtr
.0191bc	20 16 93	jsr $019316			jsr 	ArrayIndexFollow 		; do the index.
.0191bf	a5 24		lda $24				lda 	zVarType 				; is it still an array ??
.0191c1	29 01		and #$01			and 	#1
.0191c3	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.0191c5	d0 05		bne $0191cc			bne 	_VFArrayDone 			; if so then exit.
.0191c7	20 f9 90	jsr $0190f9			jsr 	CheckNextComma 			; comma should follow
.0191ca	80 db		bra $0191a7			bra 	_VFNextIndex
.0191cc					_VFArrayDone:
.0191cc	20 f1 90	jsr $0190f1			jsr 	CheckNextRParen 		; check closing right bracket.
.0191cf					_VFSingleElement:
.0191cf	60		rts				rts
.0191d0					VariableClear:
.0191d0	48		pha				pha 							; save registers
.0191d1	da		phx				phx
.0191d2	a2 00		ldx #$00			ldx 	#0 						; clear out the hash table.
.0191d4	8a		txa				txa
.0191d5	9d 25 04	sta $0425,x	_VCLoop:sta 	HashTableBase,x
.0191d8	e8		inx				inx
.0191d9	e0 60		cpx #$60			cpx 	#HashTableEnd-HashTableBase
.0191db	d0 f8		bne $0191d5			bne 	_VCLoop
.0191dd	a9 00		lda #$00			lda 	#VariableMemory & $FF	; reset the free variable memory pointer
.0191df	8d 02 04	sta $0402			sta 	VarMemPtr
.0191e2	a9 40		lda #$40			lda 	#VariableMemory >> 8
.0191e4	8d 03 04	sta $0403			sta 	VarMemPtr+1
.0191e7	fa		plx				plx 							; restore registers
.0191e8	68		pla				pla
.0191e9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/extract.asm

.0191ea					VariableNameError:
.0191ea	20 2f 84	jsr $01842f			jsr ERR_Handler
>0191ed	42 61 64 20 56 61 72 69			.text "Bad Variable Name",0
>0191f5	61 62 6c 65 20 4e 61 6d 65 00
.0191ff					VariableExtract:
.0191ff	da		phx				phx 							; save X.
.019200	a9 ba		lda #$ba			lda 	#token_hashlParen  		; set the type to #( e.g. real array.
.019202	8d 85 04	sta $0485			sta 	Var_Type
.019205	8d 86 04	sta $0486			sta 	Var_Hash 				; we initialise the hash with this. It doesn't matter
.019208	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01920a	c9 00		cmp #$00			cmp 	#0 						; first one must be A-Z
.01920c	f0 dc		beq $0191ea			beq 	VariableNameError
.01920e	c9 1b		cmp #$1b			cmp 	#26+1
.019210	b0 d8		bcs $0191ea			bcs 	VariableNameError
.019212	a2 ff		ldx #$ff			ldx 	#255 					; now copy it into the variable buffer.
.019214					_VECopyBuffer:
.019214	e8		inx				inx
.019215	e0 1f		cpx #$1f			cpx 	#31 					; too long
.019217	f0 d1		beq $0191ea			beq 	VariableNameError
.019219	9d 05 04	sta $0405,x			sta 	Var_Buffer,x 			; save character
.01921c	18		clc				clc  							; update the hash value for it.
.01921d	6d 86 04	adc $0486			adc 	Var_Hash
.019220	8d 86 04	sta $0486			sta 	Var_Hash
.019223	c8		iny				iny
.019224	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019226	c9 00		cmp #$00			cmp 	#0 						; zero or token, end of variable
.019228	f0 0e		beq $019238			beq 	_VECopyEnd
.01922a	30 0c		bmi $019238			bmi 	_VECopyEnd
.01922c	c9 1b		cmp #$1b			cmp 	#26+1 					; A-Z continue copying
.01922e	90 e4		bcc $019214			bcc 	_VECopyBuffer
.019230	c9 30		cmp #$30			cmp 	#"0" 					; 0-9 copy as well.
.019232	90 04		bcc $019238			bcc 	_VECopyEnd
.019234	c9 3a		cmp #$3a			cmp 	#"9"+1
.019236	90 dc		bcc $019214			bcc 	_VECopyBuffer
.019238					_VECopyEnd:
.019238	c8		iny				iny
.019239	c9 b7		cmp #$b7			cmp 	#token_Dollar 			; first type token.
.01923b	90 04		bcc $019241			bcc 	_VEDefaultRequired
.01923d	c9 bd		cmp #$bd			cmp 	#token_PercentLParen+1	; last type token.
.01923f	90 0b		bcc $01924c			bcc 	_VEHaveType
.019241					_VEDefaultRequired:
.019241	c9 bd		cmp #$bd			cmp 	#token_LParen 			; if it ends in ( then use the real array
.019243	f0 04		beq $019249			beq 	_VESetType 				; default set above.
.019245	ce 85 04	dec $0485			dec 	Var_Type 				; this changes that default to the variable default
.019248	88		dey				dey
.019249					_VESetType:
.019249	ad 85 04	lda $0485			lda 	Var_Type 				; get type ....
.01924c					_VEHaveType:
.01924c	8d 85 04	sta $0485			sta 	Var_Type 				; save as type.
.01924f	bd 05 04	lda $0405,x			lda 	Var_Buffer,x 			; set bit 7 of name, marks the end.
.019252	09 80		ora #$80			ora 	#$80
.019254	9d 05 04	sta $0405,x			sta 	Var_Buffer,x
.019257	e8		inx				inx 							; offset 3 => length 4.
.019258	8e 87 04	stx $0487			stx 	Var_Length 				; save length of variable name.
.01925b	ad 85 04	lda $0485			lda 	Var_Type 				; get offset of var type from first type token
.01925e	38		sec				sec
.01925f	e9 b7		sbc #$b7			sbc 	#token_Dollar
.019261	0a		asl a				asl 	a 						; multiply by 16. This requires HashTableSize
.019262	0a		asl a				asl 	a 						; in data.asm to be 8 (8 sets of links,2 bytes each)
.019263	0a		asl a				asl 	a
.019264	0a		asl a				asl 	a
.019265	8d 88 04	sta $0488			sta 	Var_HashAddress
.019268	ad 86 04	lda $0486			lda 	Var_Hash 				; get the hash
.01926b	29 07		and #$07			and 	#(HashTableSize-1) 		; force into range 0-tableSize-1
.01926d	0a		asl a				asl 	a 						; double it (2 bytes per entry) & clears carry
.01926e	6d 88 04	adc $0488			adc 	Var_HashAddress 		; add table offset.
.019271	69 25		adc #$25			adc 	#HashTableBase & $FF 	; now the low byte of the actual table address
.019273	8d 88 04	sta $0488			sta 	Var_HashAddress
.019276	a2 05		ldx #$05			ldx 	#5 						; hash is 5 bytes (real)
.019278	ad 85 04	lda $0485			lda 	Var_Type
.01927b	c9 b9		cmp #$b9			cmp 	#token_Hash
.01927d	f0 07		beq $019286			beq 	_VEHaveSize
.01927f	ca		dex				dex
.019280	c9 bb		cmp #$bb			cmp 	#token_Percent 			; percent is 4 bytes (integer)
.019282	f0 02		beq $019286			beq 	_VEHaveSize
.019284	a2 02		ldx #$02			ldx 	#2 						; everything else is two.
.019286					_VEHaveSize:
.019286	8e 89 04	stx $0489			stx 	Var_DataSize
.019289	fa		plx				plx
.01928a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varcreate.asm

.01928b					VariableCreate:
.01928b	da		phx				phx
.01928c	5a		phy				phy
.01928d	ad 02 04	lda $0402			lda 	VarMemPtr 					; get address of next free into zTemp1
.019290	85 10		sta $10				sta 	zTemp1
.019292	ad 03 04	lda $0403			lda 	VarMemPtr+1
.019295	85 11		sta $11				sta 	zTemp1+1
.019297	ad 89 04	lda $0489			lda 	Var_DataSize 				; bytes for the data bit
.01929a	18		clc				clc
.01929b	6d 87 04	adc $0487			adc 	Var_Length 					; add the length of the name
.01929e	69 03		adc #$03			adc 	#3 							; 3 for the link and the hash.
.0192a0	6d 02 04	adc $0402			adc 	VarMemPtr 					; add to variable memory pointer
.0192a3	8d 02 04	sta $0402			sta 	VarMemPtr
.0192a6	90 03		bcc $0192ab			bcc 	_VCNoCarry
.0192a8	ee 03 04	inc $0403			inc 	VarMemPtr+1
.0192ab					_VCNoCarry:
.0192ab	ad 88 04	lda $0488			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.0192ae	85 12		sta $12				sta 	zTemp2
.0192b0	a9 04		lda #$04			lda 	#HashTableBase >> 8
.0192b2	85 13		sta $13				sta 	zTemp2+1
.0192b4	a0 00		ldy #$00			ldy 	#0 							; put current hash link in position.
.0192b6	b1 12		lda ($12),y			lda 	(zTemp2),y
.0192b8	91 10		sta ($10),y			sta 	(zTemp1),y
.0192ba	c8		iny				iny
.0192bb	b1 12		lda ($12),y			lda 	(zTemp2),y
.0192bd	91 10		sta ($10),y			sta 	(zTemp1),y
.0192bf	c8		iny				iny
.0192c0	ad 86 04	lda $0486			lda 	Var_Hash 					; write the hash out.
.0192c3	91 10		sta ($10),y			sta 	(zTemp1),y
.0192c5	c8		iny				iny
.0192c6	a2 00		ldx #$00			ldx 	#0 							; copy the name out.
.0192c8					_VCCopyName:
.0192c8	bd 05 04	lda $0405,x			lda 	Var_Buffer,x
.0192cb	91 10		sta ($10),y			sta 	(zTemp1),y
.0192cd	e8		inx				inx
.0192ce	c8		iny				iny
.0192cf	ec 87 04	cpx $0487			cpx 	Var_Length
.0192d2	d0 f4		bne $0192c8			bne 	_VCCopyName
.0192d4	5a		phy				phy 								; save the data offset.
.0192d5	ae 89 04	ldx $0489			ldx 	Var_DataSize 				; and write the data out.
.0192d8	a9 00		lda #$00			lda 	#0 							; which is all zeroes.
.0192da					_VCClearData:
.0192da	91 10		sta ($10),y			sta 	(zTemp1),y
.0192dc	c8		iny				iny
.0192dd	ca		dex				dex
.0192de	d0 fa		bne $0192da			bne 	_VCClearData
.0192e0	68		pla				pla 								; offset to the data
.0192e1	18		clc				clc
.0192e2	65 10		adc $10				adc 	zTemp1 						; add to start and save as data pointer.
.0192e4	85 22		sta $22				sta 	zVarDataPtr
.0192e6	a5 11		lda $11				lda 	zTemp1+1
.0192e8	69 00		adc #$00			adc 	#0
.0192ea	85 23		sta $23				sta 	zVarDataPtr+1
.0192ec	ad 85 04	lda $0485			lda 	Var_Type 					; and set the type.
.0192ef	85 24		sta $24				sta 	zVarType
.0192f1	a5 10		lda $10				lda 	zTemp1 						; fix hash link to point to new record
.0192f3	a0 00		ldy #$00			ldy 	#0
.0192f5	91 12		sta ($12),y			sta 	(zTemp2),y
.0192f7	c8		iny				iny
.0192f8	a5 11		lda $11				lda 	zTemp1+1
.0192fa	91 12		sta ($12),y			sta 	(zTemp2),y
.0192fc	ad 85 04	lda $0485			lda 	Var_Type 					; array ? if so create the empty one.
.0192ff	29 01		and #$01			and 	#1
.019301	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.019303	d0 0e		bne $019313			bne 	_VCNotArray
.019305	a2 00		ldx #$00			ldx 	#0 							; call recursive array creator
.019307	20 b6 93	jsr $0193b6			jsr 	ArrayCreate
.01930a	5a		phy				phy 								; save YA at zVarDataPtr
.01930b	a0 00		ldy #$00			ldy 	#0
.01930d	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.01930f	c8		iny				iny
.019310	68		pla				pla
.019311	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019313					_VCNotArray:
.019313	7a		ply				ply
.019314	fa		plx				plx
.019315	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arrayidx.asm

.019316					ArrayIndexFollow:
.019316	5a		phy				phy
.019317	a0 00		ldy #$00			ldy 	#0 							; make zVarDataPtr point to the array.
.019319	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; e.g. it points to itself.
.01931b	48		pha				pha
.01931c	c8		iny				iny
.01931d	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.01931f	85 23		sta $23				sta 	zVarDataPtr+1
.019321	68		pla				pla
.019322	85 22		sta $22				sta 	zVarDataPtr
.019324	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 			; MSB of 16 bit integer and bytes 2&3
.019327	29 80		and #$80			and 	#$80 						; must be zero.
.019329	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.01932c	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.01932f	d0 5f		bne $019390			bne 	_AIFError
.019331	a0 00		ldy #$00			ldy 	#0 							; calculate size - current - 1
.019333	18		clc				clc
.019334	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019336	fd 08 03	sbc $0308,x			sbc 	XS_Mantissa+0,x
.019339	c8		iny				iny
.01933a	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.01933c	08		php				php 								; clear bit 7 retaining borrow.
.01933d	29 7f		and #$7f			and 	#$7F
.01933f	28		plp				plp
.019340	fd 09 03	sbc $0309,x			sbc 	XS_Mantissa+1,x
.019343	90 4b		bcc $019390			bcc 	_AIFError 					; eror if size-current < 0
.019345	bd 08 03	lda $0308,x			lda  	XS_Mantissa+0,x 			; copy and double the index
.019348	0a		asl a				asl 	a 							; (e.g. index * 2)
.019349	85 10		sta $10				sta 	zTemp1
.01934b	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.01934e	2a		rol a				rol 	a
.01934f	85 11		sta $11				sta 	zTemp1+1
.019351	a0 01		ldy #$01			ldy 	#1 							; is this a data entry.
.019353	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; if so, then type is unchanged, offset set
.019355	30 1f		bmi $019376			bmi 	_AIFCalculate
.019357	c6 24		dec $24				dec 	zVarType 					; converts from an array to a type.
.019359	a5 24		lda $24				lda 	zVarType 					; check that type
.01935b	c9 b7		cmp #$b7			cmp 	#token_Dollar 				; if string, use x 2
.01935d	f0 17		beq $019376			beq 	_AIFCalculate
.01935f	06 10		asl $10				asl 	zTemp1			 			; double the index
.019361	26 11		rol $11				rol 	zTemp1+1					; (e.g. index * 4)
.019363	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if integer, use x 4
.019365	f0 0f		beq $019376			beq 	_AIFCalculate
.019367	18		clc				clc 								; add the original mantissa in again
.019368	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; which makes it x5, for float.
.01936b	65 10		adc $10				adc 	zTemp1
.01936d	85 10		sta $10				sta 	zTemp1
.01936f	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.019372	65 11		adc $11				adc 	zTemp1+1
.019374	85 11		sta $11				sta 	zTemp1+1
.019376					_AIFCalculate:
.019376	18		clc				clc 								; add index x 2,4 or 5 to base
.019377	a5 22		lda $22				lda 	zVarDataPtr
.019379	65 10		adc $10				adc 	zTemp1
.01937b	85 22		sta $22				sta 	zVarDataPtr
.01937d	a5 23		lda $23				lda 	zVarDataPtr+1
.01937f	65 11		adc $11				adc 	zTemp1+1
.019381	85 23		sta $23				sta 	zVarDataPtr+1
.019383	18		clc				clc 								; add 2 more for the length prefix.
.019384	a5 22		lda $22				lda 	zVarDataPtr
.019386	69 02		adc #$02			adc 	#2
.019388	85 22		sta $22				sta 	zVarDataPtr
.01938a	90 02		bcc $01938e			bcc 	_AIFNoBump
.01938c	e6 23		inc $23				inc 	zVarDataPtr+1
.01938e					_AIFNoBump:
.01938e	7a		ply				ply
.01938f	60		rts				rts
.019390					_AIFError:
.019390	20 2f 84	jsr $01842f			jsr ERR_Handler
>019393	42 61 64 20 61 72 72 61			.text "Bad array index",0
>01939b	79 20 69 6e 64 65 78 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arraydef.asm

.0193a3					ArrayResetDefault:
.0193a3	a9 0b		lda #$0b			lda 	#11 						; 0..10 one array
.0193a5	8d 97 04	sta $0497			sta 	ArrayDef+0
.0193a8	a9 00		lda #$00			lda 	#0
.0193aa	8d 98 04	sta $0498			sta 	ArrayDef+1
.0193ad	a9 ff		lda #$ff			lda 	#$FF
.0193af	8d 99 04	sta $0499			sta 	ArrayDef+2 					; $FFFF implies no second element.
.0193b2	8d 9a 04	sta $049a			sta 	ArrayDef+3					; (test bit 7 of 2nd byte)
.0193b5	60		rts				rts
.0193b6					ArrayCreate:
.0193b6	bd 97 04	lda $0497,x			lda 	ArrayDef+0,x 				; put size x 2 in zTemp1
.0193b9	0a		asl a				asl 	a
.0193ba	85 10		sta $10				sta 	zTemp1
.0193bc	bd 98 04	lda $0498,x			lda 	ArrayDef+1,x
.0193bf	2a		rol a				rol 	a
.0193c0	85 11		sta $11				sta 	zTemp1+1
.0193c2	bd 9a 04	lda $049a,x			lda 	ArrayDef+3,x 				; if this is the last element it's array of ptrs.
.0193c5	10 22		bpl $0193e9			bpl 	_ACSized 					; if not multiply size x 2 (str) 4 (int) 5 (real)
.0193c7	ad 85 04	lda $0485			lda 	Var_Type 					; check the type
.0193ca	c9 b8		cmp #$b8			cmp 	#token_DollarLParen 		; also if it is an array of strings $(
.0193cc	f0 1b		beq $0193e9			beq 	_ACSized
.0193ce	06 10		asl $10				asl 	zTemp1 						; double again
.0193d0	26 11		rol $11				rol 	zTemp1+1
.0193d2	b0 6f		bcs $019443			bcs 	ArrayIndexError 			; too large.
.0193d4	c9 bc		cmp #$bc			cmp 	#token_PercentLParen 		; if %( four bytes/entry is enough.
.0193d6	f0 11		beq $0193e9			beq 	_ACSized
.0193d8	18		clc				clc 								; add original value x 5 for reals.
.0193d9	a5 10		lda $10				lda 	zTemp1
.0193db	7d 97 04	adc $0497,x			adc 	ArrayDef+0,x
.0193de	85 10		sta $10				sta 	zTemp1
.0193e0	a5 11		lda $11				lda 	zTemp1+1
.0193e2	7d 98 04	adc $0498,x			adc 	ArrayDef+1,x
.0193e5	85 11		sta $11				sta 	zTemp1+1
.0193e7	b0 5a		bcs $019443			bcs 	ArrayIndexError
.0193e9					_ACSized:
.0193e9	18		clc				clc
.0193ea	a5 10		lda $10				lda 	zTemp1
.0193ec	69 02		adc #$02			adc 	#2
.0193ee	85 10		sta $10				sta 	zTemp1
.0193f0	90 04		bcc $0193f6			bcc 	_ACNoBump
.0193f2	e6 10		inc $10				inc 	zTemp1
.0193f4	f0 4d		beq $019443			beq 	ArrayIndexError
.0193f6					_ACNoBump:
.0193f6	18		clc				clc
.0193f7	ad 02 04	lda $0402			lda 	VarMemPtr 					; add this allocated count to VarMemPtr
.0193fa	85 12		sta $12				sta 	zTemp2						; save start in zTemp2/zTemp3
.0193fc	85 14		sta $14				sta 	zTemp3
.0193fe	65 10		adc $10				adc 	zTemp1
.019400	8d 02 04	sta $0402			sta 	VarMemPtr
.019403	ad 03 04	lda $0403			lda 	VarMemPtr+1
.019406	85 13		sta $13				sta 	zTemp2+1
.019408	85 15		sta $15				sta 	zTemp3+1
.01940a	65 11		adc $11				adc 	zTemp1+1
.01940c	8d 03 04	sta $0403			sta 	VarMemPtr+1
.01940f	85 11		sta $11				sta 	zTemp1+1
.019411	b0 30		bcs $019443			bcs 	ArrayIndexError
.019413	a0 00		ldy #$00			ldy 	#0							; write $00 out.
.019415					_ACClear:
.019415	98		tya				tya
.019416	91 12		sta ($12),y			sta 	(zTemp2),y
.019418	e6 12		inc $12				inc 	zTemp2
.01941a	d0 02		bne $01941e			bne 	_ACCBump
.01941c	e6 13		inc $13				inc 	zTemp2+1
.01941e					_ACCBump:
.01941e	a5 12		lda $12				lda 	zTemp2
.019420	cd 02 04	cmp $0402			cmp 	VarMemPtr
.019423	d0 f0		bne $019415			bne 	_ACClear
.019425	a5 13		lda $13				lda 	zTemp2+1
.019427	cd 03 04	cmp $0403			cmp 	VarMemPtr+1
.01942a	d0 e9		bne $019415			bne 	_ACClear
.01942c	a0 00		ldy #$00			ldy 	#0
.01942e	bd 97 04	lda $0497,x			lda 	ArrayDef+0,x 				; copy the size into the start
.019431	91 14		sta ($14),y			sta 	(zTemp3),y
.019433	c8		iny				iny
.019434	bd 98 04	lda $0498,x			lda 	ArrayDef+1,x
.019437	91 14		sta ($14),y			sta 	(zTemp3),y
.019439	bd 9a 04	lda $049a,x			lda 	ArrayDef+3,x 				; have we reached the end
.01943c	10 18		bpl $019456			bpl 	ACCFillRecursive
.01943e	a4 15		ldy $15				ldy 	zTemp3+1 					; return address
.019440	a5 14		lda $14				lda 	zTemp3
.019442	60		rts				rts
.019443					ArrayIndexError:
.019443	20 2f 84	jsr $01842f			jsr ERR_Handler
>019446	42 61 64 20 61 72 72 61			.text "Bad array index",0
>01944e	79 20 69 6e 64 65 78 00
.019456					ACCFillRecursive:
.019456	a9 ff		lda #$ff			lda 	#$FF 						; we mark the end, this is free space.
.019458	a0 00		ldy #$00			ldy 	#0 							; this is overwritten by size of next allocated
.01945a	91 12		sta ($12),y			sta 	(zTemp2),y 					; array, but we might change that.
.01945c	c8		iny				iny
.01945d	b1 14		lda ($14),y			lda 	(zTemp3),y 					; set bit 15 of the max index indicating
.01945f	09 80		ora #$80			ora 	#$80 						; an array of pointers
.019461	91 14		sta ($14),y			sta 	(zTemp3),y
.019463	a5 14		lda $14				lda 	zTemp3 						; push the start on the stack
.019465	48		pha				pha
.019466	a5 15		lda $15				lda 	zTemp3+1
.019468	48		pha				pha
.019469					_ACCFillLoop:
.019469	18		clc				clc
.01946a	a5 14		lda $14				lda 	zTemp3 						; and work forwards.
.01946c	69 02		adc #$02			adc 	#2
.01946e	85 14		sta $14				sta 	zTemp3
.019470	90 02		bcc $019474			bcc 	_ACCSkip2
.019472	e6 14		inc $14				inc 	zTemp3
.019474					_ACCSkip2:
.019474	a0 00		ldy #$00			ldy 	#0 							; reached the end ?
.019476	b1 14		lda ($14),y			lda 	(zTemp3),y					; (looking for FF marker, everything else 00)
.019478	c8		iny				iny
.019479	11 14		ora ($14),y			ora 	(zTemp3),y
.01947b	d0 21		bne $01949e			bne 	_ACCExit
.01947d	a5 14		lda $14				lda 	zTemp3 						; push zTemp3
.01947f	48		pha				pha
.019480	a5 15		lda $15				lda 	zTemp3+1
.019482	48		pha				pha
.019483	e8		inx				inx
.019484	e8		inx				inx
.019485	20 b6 93	jsr $0193b6			jsr 	ArrayCreate 				; create array recursively.
.019488	ca		dex				dex
.019489	ca		dex				dex
.01948a	85 12		sta $12				sta 	zTemp2 						; save A
.01948c	68		pla				pla
.01948d	85 15		sta $15				sta 	zTemp3+1 					; restore zTemp3
.01948f	68		pla				pla
.019490	85 14		sta $14				sta 	zTemp3
.019492	98		tya				tya 								; write high bye from Y
.019493	a0 01		ldy #$01			ldy 	#1
.019495	91 14		sta ($14),y			sta 	(zTemp3),y
.019497	88		dey				dey 								; write low byte out.
.019498	a5 12		lda $12				lda 	zTemp2
.01949a	91 14		sta ($14),y			sta 	(zTemp3),y
.01949c	80 cb		bra $019469			bra 	_ACCFillLoop 				; and try again.
.01949e					_ACCExit:
.01949e	7a		ply				ply 								; restore the original address
.01949f	68		pla				pla
.0194a0	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varfind.asm

.0194a1					VariableLocate:
.0194a1	da		phx				phx
.0194a2	5a		phy				phy
.0194a3	ad 88 04	lda $0488			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.0194a6	85 12		sta $12				sta 	zTemp2 						; points to first address.
.0194a8	a9 04		lda #$04			lda 	#HashTableBase >> 8
.0194aa	85 13		sta $13				sta 	zTemp2+1
.0194ac	a0 00		ldy #$00	_VLNext:ldy 	#0 							; get next link into AX
.0194ae	b1 12		lda ($12),y			lda 	(zTemp2),y
.0194b0	aa		tax				tax
.0194b1	c8		iny				iny
.0194b2	b1 12		lda ($12),y			lda 	(zTemp2),y
.0194b4	85 13		sta $13				sta 	zTemp2+1 					; save in zTemp
.0194b6	86 12		stx $12				stx 	zTemp2
.0194b8	05 12		ora $12				ora 	zTemp2 						; got zero
.0194ba	18		clc				clc
.0194bb	f0 25		beq $0194e2			beq 	_VLExit 					; if so, then fail as end of chain.
.0194bd	c8		iny				iny 								; point to hash (offset + 2)
.0194be	b1 12		lda ($12),y			lda 	(zTemp2),y
.0194c0	cd 86 04	cmp $0486			cmp 	Var_Hash
.0194c3	d0 e7		bne $0194ac			bne 	_VLNext 					; try next if different.
.0194c5					_VLCompare:
.0194c5	c8		iny				iny 								; next character
.0194c6	b1 12		lda ($12),y			lda 	(zTemp2),y 					; compare variable field against buffer.
.0194c8	d9 02 04	cmp $0402,y			cmp 	Var_Buffer-3,y 				; the -3 is because name starts at 3.
.0194cb	d0 df		bne $0194ac			bne 	_VLNext 					; fail if different, try next.
.0194cd	0a		asl a				asl 	a 							; until end character (bit 7 set) matched
.0194ce	90 f5		bcc $0194c5			bcc 	_VLCompare
.0194d0	98		tya				tya
.0194d1	38		sec				sec 								; add 1 as Y points to last character
.0194d2	65 12		adc $12				adc 	zTemp2 						; add to the current address
.0194d4	85 22		sta $22				sta 	zVarDataPtr
.0194d6	a5 13		lda $13				lda 	zTemp2+1
.0194d8	69 00		adc #$00			adc 	#0
.0194da	85 23		sta $23				sta 	zVarDataPtr+1
.0194dc	ad 85 04	lda $0485			lda 	Var_Type 					; and set the type.
.0194df	85 24		sta $24				sta 	zVarType
.0194e1	38		sec				sec 								; return CS
.0194e2	7a		ply		_VLExit:ply
.0194e3	fa		plx				plx
.0194e4	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/vargetset.asm

.0194e5					VariableGet:
.0194e5	5a		phy				phy
.0194e6	a0 00		ldy #$00			ldy 	#0 							; copy first two bytes
.0194e8	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.0194ea	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.0194ed	c8		iny				iny
.0194ee	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.0194f0	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0194f3	c8		iny				iny
.0194f4	a5 24		lda $24				lda 	zVarType 					; if it is a string, set up for that.
.0194f6	c9 b7		cmp #$b7			cmp 	#token_Dollar
.0194f8	f0 34		beq $01952e			beq 	_VGString
.0194fa	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; copy the next two bytes.
.0194fc	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0194ff	c8		iny				iny
.019500	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019502	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019505	c8		iny				iny
.019506	a9 01		lda #$01			lda 	#1 							; set type to 1.
.019508	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.01950b	a5 24		lda $24				lda 	zVarType
.01950d	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if it is a %, then exit with default integer.
.01950f	f0 31		beq $019542			beq 	_VGExit
.019511	a9 40		lda #$40			lda 	#$40 						; set type byte to zero
.019513	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; which is the code for zero/float.
.019516	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; the last value to copy is the exponent.
.019518	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.01951b	f0 25		beq $019542			beq 	_VGExit 					; if exponent is zero ... it's zero.
.01951d	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; the sign bit is the top mantissa bit.
.019520	48		pha				pha
.019521	29 80		and #$80			and 	#$80
.019523	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; this is the type byte.
.019526	68		pla				pla
.019527	09 80		ora #$80			ora 	#$80 						; set the MSB as you would expect.
.019529	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x 			; so it's a normalised float.
.01952c	80 14		bra $019542			bra 	_VGExit
.01952e					_VGString:
.01952e	a9 02		lda #$02			lda 	#2 							; set type to 2, a string
.019530	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019533	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; is the value there $0000
.019536	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.019539	d0 07		bne $019542			bne 	_VGExit 					; if not, exit.
.01953b	85 25		sta $25				sta 	zNullString 				; make zNullString a 00 string.
.01953d	a9 25		lda #$25			lda 	#zNullString
.01953f	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; make it point to it.
.019542					_VGExit:
.019542	7a		ply				ply
.019543	60		rts				rts
.019544					VariableSet:
.019544	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; is the result a string
.019547	29 02		and #$02			and 	#2 							; if so, it has to be
.019549	d0 53		bne $01959e			bne 	_VSString
.01954b	a5 24		lda $24				lda 	zVarType 					; if type is $ there's an error.
.01954d	c9 b7		cmp #$b7			cmp 	#token_Dollar
.01954f	f0 4a		beq $01959b			beq 	_VSBadType
.019551	c9 bb		cmp #$bb			cmp 	#token_Percent 				; type convert to float/int
.019553	f0 05		beq $01955a			beq 	_VSMakeInt
.019555	20 50 9b	jsr $019b50			jsr 	FPUToFloat
.019558	80 03		bra $01955d			bra 	_VSCopy
.01955a					_VSMakeInt:
.01955a	20 af 9b	jsr $019baf			jsr 	FPUToInteger
.01955d					_VSCopy:
.01955d	5a		phy				phy
.01955e	a0 00		ldy #$00			ldy 	#0 							; copy mantissa to target.
.019560	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.019563	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019565	c8		iny				iny
.019566	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.019569	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.01956b	c8		iny				iny
.01956c	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.01956f	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019571	c8		iny				iny
.019572	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.019575	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019577	a5 24		lda $24				lda 	zVarType 					; if target is integer, alrady done.
.019579	c9 bb		cmp #$bb			cmp 	#token_Percent
.01957b	f0 1c		beq $019599			beq 	_VSExit
.01957d	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get the sign bit into carry flag.
.019580	0a		asl a				asl 	a
.019581	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; shift the sign into the mantissa high.
.019584	08		php				php
.019585	0a		asl a				asl 	a
.019586	28		plp				plp
.019587	6a		ror a				ror 	a
.019588	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.01958a	c8		iny				iny
.01958b	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; copy the exponent in
.01958e	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019590	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if the result is non zero
.019593	50 04		bvc $019599			bvc 	_VSExit
.019595	a9 00		lda #$00			lda 	#00 						; zero exponent indicating 0.
.019597	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019599					_VSExit:
.019599	7a		ply				ply
.01959a	60		rts				rts
.01959b					_VSBadType:
.01959b	4c 10 84	jmp $018410			jmp 	TypeError
.01959e					_VSString:
.01959e	a5 24		lda $24				lda 	zVarType 					; type must be $
.0195a0	c9 b7		cmp #$b7			cmp 	#token_Dollar
.0195a2	d0 f7		bne $01959b			bne 	_VSBadType
.0195a4	da		phx				phx
.0195a5	5a		phy				phy
.0195a6	20 01 91	jsr $019101			jsr 	StringConcrete 				; concrete the string in the mantissa -> AX
.0195a9	a0 01		ldy #$01			ldy 	#1 							; save high byte
.0195ab	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0195ad	88		dey				dey 								; save low byte
.0195ae	8a		txa				txa
.0195af	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0195b1	7a		ply				ply 								; and exit.
.0195b2	fa		plx				plx
.0195b3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.0195b4					MulInteger32:
.0195b4	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.0195b7	9d 14 03	sta $0314,x			sta 	XS3_Mantissa,x
.0195ba	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0195bd	9d 15 03	sta $0315,x			sta 	XS3_Mantissa+1,x
.0195c0	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.0195c3	9d 16 03	sta $0316,x			sta 	XS3_Mantissa+2,x
.0195c6	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.0195c9	9d 17 03	sta $0317,x			sta 	XS3_Mantissa+3,x
.0195cc	a9 00		lda #$00			lda 	#0
.0195ce	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x 				; zero +0
.0195d1	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0195d4	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0195d7	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0195da					_BFMMultiply:
.0195da	bd 14 03	lda $0314,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.0195dd	29 01		and #$01			and 	#1
.0195df	f0 03		beq $0195e4			beq 	_BFMNoAdd
.0195e1	20 56 8c	jsr $018c56			jsr 	AddInteger32
.0195e4					_BFMNoAdd:
.0195e4	1e 0e 03	asl $030e,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.0195e7	3e 0f 03	rol $030f,x			rol 	XS2_Mantissa+1,x
.0195ea	3e 10 03	rol $0310,x			rol 	XS2_Mantissa+2,x
.0195ed	3e 11 03	rol $0311,x			rol 	XS2_Mantissa+3,x
.0195f0	5e 17 03	lsr $0317,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.0195f3	7e 16 03	ror $0316,x			ror 	XS3_Mantissa+2,x
.0195f6	7e 15 03	ror $0315,x			ror 	XS3_Mantissa+1,x
.0195f9	7e 14 03	ror $0314,x			ror 	XS3_Mantissa,x
.0195fc	bd 14 03	lda $0314,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.0195ff	1d 15 03	ora $0315,x			ora 	XS3_Mantissa+1,x
.019602	1d 16 03	ora $0316,x			ora 	XS3_Mantissa+2,x
.019605	1d 17 03	ora $0317,x			ora 	XS3_Mantissa+3,x
.019608	d0 d0		bne $0195da			bne 	_BFMMultiply
.01960a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.01960b					DivInteger32:
.01960b	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; check for /0
.01960e	1d 0f 03	ora $030f,x			ora 	XS2_Mantissa+1,x
.019611	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.019614	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.019617	d0 14		bne $01962d			bne 	_BFDOkay
.019619	20 2f 84	jsr $01842f			jsr ERR_Handler
>01961c	44 69 76 69 73 69 6f 6e			.text "Division by Zero",0
>019624	20 62 79 20 5a 65 72 6f 00
.01962d					_BFDOkay:
.01962d	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.01962f	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.019631	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.019633	85 1c		sta $1c				sta 	zLTemp1+2
.019635	85 1d		sta $1d				sta 	zLTemp1+3
.019637	8d 8e 04	sta $048e			sta 	SignCount 					; Count of signs.
.01963a	20 9b 96	jsr $01969b			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.01963d	da		phx				phx
.01963e	e8		inx				inx
.01963f	e8		inx				inx
.019640	e8		inx				inx
.019641	e8		inx				inx
.019642	e8		inx				inx
.019643	e8		inx				inx
.019644	20 9b 96	jsr $01969b			jsr 	CheckIntegerNegate
.019647	fa		plx				plx
.019648	5a		phy				phy 								; Y is the counter
.019649	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.01964b					_BFDLoop:
.01964b	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.01964e	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.019651	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.019654	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.019657	26 1a		rol $1a				rol 	zLTemp1
.019659	26 1b		rol $1b				rol 	zLTemp1+1
.01965b	26 1c		rol $1c				rol 	zLTemp1+2
.01965d	26 1d		rol $1d				rol 	zLTemp1+3
.01965f	38		sec				sec
.019660	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.019662	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.019665	48		pha				pha
.019666	a5 1b		lda $1b				lda 	zLTemp1+1
.019668	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.01966b	48		pha				pha
.01966c	a5 1c		lda $1c				lda 	zLTemp1+2
.01966e	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.019671	48		pha				pha
.019672	a5 1d		lda $1d				lda 	zLTemp1+3
.019674	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.019677	90 15		bcc $01968e			bcc 	_BFDNoAdd
.019679	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.01967b	68		pla				pla
.01967c	85 1c		sta $1c				sta 	zLTemp1+2
.01967e	68		pla				pla
.01967f	85 1b		sta $1b				sta 	zLTemp1+1
.019681	68		pla				pla
.019682	85 1a		sta $1a				sta 	zLTemp1+0
.019684	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.019687	09 01		ora #$01			ora 	#1
.019689	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.01968c	80 03		bra $019691			bra 	_BFDNext
.01968e					_BFDNoAdd:
.01968e	68		pla				pla 								; Throw away the intermediate calculations
.01968f	68		pla				pla
.019690	68		pla				pla
.019691					_BFDNext:
.019691	88		dey				dey
.019692	d0 b7		bne $01964b			bne 	_BFDLoop
.019694	7a		ply				ply 								; restore Y and exit
.019695	4e 8e 04	lsr $048e			lsr 	SignCount 					; if sign count odd,
.019698	b0 07		bcs $0196a1			bcs		IntegerNegateAlways 			; negate the result
.01969a	60		rts				rts
.01969b					CheckIntegerNegate:
.01969b	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.01969e	30 01		bmi $0196a1			bmi 	IntegerNegateAlways
.0196a0	60		rts				rts
.0196a1					IntegerNegateAlways:
.0196a1	ee 8e 04	inc $048e			inc 	SignCount
.0196a4	38		sec				sec
.0196a5	a9 00		lda #$00			lda 	#0
.0196a7	fd 08 03	sbc $0308,x			sbc 	XS_Mantissa+0,x
.0196aa	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0196ad	a9 00		lda #$00			lda 	#0
.0196af	fd 09 03	sbc $0309,x			sbc 	XS_Mantissa+1,x
.0196b2	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0196b5	a9 00		lda #$00			lda 	#0
.0196b7	fd 0a 03	sbc $030a,x			sbc 	XS_Mantissa+2,x
.0196ba	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0196bd	a9 00		lda #$00			lda 	#0
.0196bf	fd 0b 03	sbc $030b,x			sbc 	XS_Mantissa+3,x
.0196c2	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0196c5	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.0196c6					INTToString:
.0196c6	48		pha				pha
.0196c7	5a		phy				phy
.0196c8	bd 0b 03	lda $030b,x			lda 		XS_Mantissa+3,x 		; check -ve
.0196cb	10 08		bpl $0196d5			bpl 		_ITSNotMinus
.0196cd	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.0196cf	20 6a 97	jsr $01976a			jsr 		ITSOutputCharacter
.0196d2	20 a1 96	jsr $0196a1			jsr 		IntegerNegateAlways 	; negate the number.
.0196d5					_ITSNotMinus:
.0196d5	a9 00		lda #$00			lda 		#0
.0196d7	8d 8a 04	sta $048a			sta 		NumSuppress 			; clear the suppression flag.
.0196da	8a		txa				txa 								; use Y for the mantissa index.
.0196db	a8		tay				tay
.0196dc	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.0196de					_ITSNextSubtractor:
.0196de	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.0196e0	8d 8b 04	sta $048b			sta 		NumConvCount
.0196e3					_ITSSubtract:
.0196e3	38		sec				sec
.0196e4	b9 08 03	lda $0308,y			lda 		XS_Mantissa,y 			; subtract number and push on stack
.0196e7	ff 46 97 01	sbc $019746,x			sbc 		_ITSSubtractors+0,x
.0196eb	48		pha				pha
.0196ec	b9 09 03	lda $0309,y			lda 		XS_Mantissa+1,y
.0196ef	ff 47 97 01	sbc $019747,x			sbc 		_ITSSubtractors+1,x
.0196f3	48		pha				pha
.0196f4	b9 0a 03	lda $030a,y			lda 		XS_Mantissa+2,y
.0196f7	ff 48 97 01	sbc $019748,x			sbc 		_ITSSubtractors+2,x
.0196fb	48		pha				pha
.0196fc	b9 0b 03	lda $030b,y			lda 		XS_Mantissa+3,y
.0196ff	ff 49 97 01	sbc $019749,x			sbc 		_ITSSubtractors+3,x
.019703	90 14		bcc $019719			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.019705	99 0b 03	sta $030b,y			sta 		XS_Mantissa+3,y 		; save subtract off stack
.019708	68		pla				pla
.019709	99 0a 03	sta $030a,y			sta 		XS_Mantissa+2,y
.01970c	68		pla				pla
.01970d	99 09 03	sta $0309,y			sta 		XS_Mantissa+1,y
.019710	68		pla				pla
.019711	99 08 03	sta $0308,y			sta 		XS_Mantissa+0,y
.019714	ee 8b 04	inc $048b			inc 		NumConvCount 			; bump count.
.019717	80 ca		bra $0196e3			bra 		_ITSSubtract 			; go round again.
.019719					_ITSCantSubtract:
.019719	68		pla				pla 								; throw away interim answers
.01971a	68		pla				pla
.01971b	68		pla				pla
.01971c	ad 8b 04	lda $048b			lda 		NumConvCount 			; if not zero then no suppression check
.01971f	c9 30		cmp #$30			cmp 		#"0"
.019721	d0 05		bne $019728			bne 		_ITSOutputDigit
.019723	ad 8a 04	lda $048a			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.019726	10 09		bpl $019731			bpl	 		_ITSGoNextSubtractor
.019728					_ITSOutputDigit:
.019728	ce 8a 04	dec $048a			dec 		NumSuppress 			; suppression check will be non-zero.
.01972b	ad 8b 04	lda $048b			lda 		NumConvCount 			; count of subtractions
.01972e	20 6a 97	jsr $01976a			jsr 		ITSOutputCharacter 		; output it.
.019731					_ITSGoNextSubtractor:
.019731	e8		inx				inx 								; next dword
.019732	e8		inx				inx
.019733	e8		inx				inx
.019734	e8		inx				inx
.019735	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.019737	d0 a5		bne $0196de			bne 		_ITSNextSubtractor 		; do all the subtractors.
.019739	98		tya				tya 								; X is back as the mantissa index
.01973a	aa		tax				tax
.01973b	bd 08 03	lda $0308,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.01973e	09 30		ora #$30			ora 		#"0"
.019740	20 6a 97	jsr $01976a			jsr 		ITSOutputCharacter
.019743	7a		ply				ply 								; and exit
.019744	68		pla				pla
.019745	60		rts				rts
.019746					_ITSSubtractors:
>019746	00 ca 9a 3b					.dword 		1000000000
>01974a	00 e1 f5 05					.dword 		100000000
>01974e	80 96 98 00					.dword 		10000000
>019752	40 42 0f 00					.dword 		1000000
>019756	a0 86 01 00					.dword 		100000
>01975a	10 27 00 00					.dword 		10000
>01975e	e8 03 00 00					.dword 		1000
>019762	64 00 00 00					.dword 		100
>019766	0a 00 00 00					.dword 		10
.01976a					_ITSSubtractorsEnd:
.01976a					ITSOutputCharacter:
.01976a	48		pha				pha
.01976b	da		phx				phx
.01976c	ae 04 04	ldx $0404			ldx 	NumBufX 					; save digit
.01976f	9d 05 04	sta $0405,x			sta 	Num_Buffer,x
.019772	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.019774	9d 06 04	sta $0406,x			sta 	Num_Buffer+1,x
.019777	ee 04 04	inc $0404			inc 	NumBufX						; bump pointer.
.01977a	fa		plx				plx
.01977b	68		pla				pla
.01977c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.01977d					IntFromString:
.01977d	a0 00		ldy #$00			ldy 	#0
.01977f	8c 8c 04	sty $048c			sty 	ExpTemp 					; this is the converted digit count.
.019782					IntFromStringY:
.019782	48		pha				pha
.019783	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.019785	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.019788	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.01978b	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01978e	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019791	a9 01		lda #$01			lda 	#1
.019793	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019796					_IFSLoop:
.019796	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.019798	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.01979a	90 60		bcc $0197fc			bcc 	_IFSExit
.01979c	c9 3a		cmp #$3a			cmp 	#"9"+1
.01979e	b0 5c		bcs $0197fc			bcs 	_IFSExit
.0197a0	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.0197a3	c9 0c		cmp #$0c			cmp 	#12
.0197a5	b0 5f		bcs $019806			bcs 	_IFSOverflow
.0197a7	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.0197aa	48		pha				pha
.0197ab	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.0197ae	48		pha				pha
.0197af	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0197b2	48		pha				pha
.0197b3	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.0197b6	48		pha				pha
.0197b7	20 1b 98	jsr $01981b			jsr 	IFSX1ShiftLeft 				; double
.0197ba	20 1b 98	jsr $01981b			jsr 	IFSX1ShiftLeft 				; x 4
.0197bd	18		clc				clc 								; add saved value x 5
.0197be	68		pla				pla
.0197bf	7d 08 03	adc $0308,x			adc 	XS_Mantissa+0,x
.0197c2	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0197c5	68		pla				pla
.0197c6	7d 09 03	adc $0309,x			adc 	XS_Mantissa+1,x
.0197c9	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0197cc	68		pla				pla
.0197cd	7d 0a 03	adc $030a,x			adc 	XS_Mantissa+2,x
.0197d0	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0197d3	68		pla				pla
.0197d4	7d 0b 03	adc $030b,x			adc 	XS_Mantissa+3,x
.0197d7	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0197da	20 1b 98	jsr $01981b			jsr 	IFSX1ShiftLeft 				; x 10
.0197dd	ee 8c 04	inc $048c			inc 	ExpTemp 					; bump count of digits processed.
.0197e0	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.0197e2	29 0f		and #$0f			and 	#15
.0197e4	c8		iny				iny
.0197e5	7d 08 03	adc $0308,x			adc 	XS_Mantissa+0,x
.0197e8	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0197eb	90 a9		bcc $019796			bcc 	_IFSLoop
.0197ed	fe 09 03	inc $0309,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.0197f0	d0 a4		bne $019796			bne 	_IFSLoop
.0197f2	fe 0a 03	inc $030a,x			inc 	XS_Mantissa+2,x
.0197f5	d0 9f		bne $019796			bne 	_IFSLoop
.0197f7	fe 0b 03	inc $030b,x			inc 	XS_Mantissa+3,x
.0197fa	80 9a		bra $019796			bra 	_IFSLoop
.0197fc					_IFSExit:
.0197fc	98		tya				tya 								; get offset
.0197fd					_IFSOkay:
.0197fd	38		sec				sec
.0197fe	ad 8c 04	lda $048c			lda 	ExpTemp
.019801	f0 01		beq $019804			beq 	_IFSSkipFail
.019803	18		clc				clc
.019804					_IFSSkipFail:
.019804	68		pla				pla 								; and exit.
.019805	60		rts				rts
.019806					_IFSOverflow:
.019806	20 2f 84	jsr $01842f			jsr 	ERR_Handler
>019809	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>019811	20 6f 76 65 72 66 6c 6f 77 00
.01981b					IFSX1ShiftLeft:
.01981b	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x
.01981e	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.019821	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.019824	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.019827	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.019828					FPSubtract:
.019828	48		pha				pha
.019829	bd 13 03	lda $0313,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.01982c	49 80		eor #$80			eor 	#$80
.01982e	9d 13 03	sta $0313,x			sta 	XS2_Type,x
.019831	68		pla				pla 								; --- and fall through ---
.019832					FPAdd:
.019832	48		pha				pha
.019833	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.019836	d0 05		bne $01983d			bne 	_FPA_NegativeLHS
.019838	20 5a 98	jsr $01985a			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.01983b	68		pla				pla
.01983c	60		rts				rts
.01983d					_FPA_NegativeLHS:
.01983d	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.019840	49 80		eor #$80			eor 	#$80
.019842	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019845	bd 13 03	lda $0313,x			lda 	XS2_Type,x 					; flip the sign of B and add
.019848	49 80		eor #$80			eor 	#$80
.01984a	9d 13 03	sta $0313,x			sta 	XS2_Type,x
.01984d	20 5a 98	jsr $01985a			jsr 	FPAdd_Worker 				; do the add calculation.
.019850	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip sign of X1 back
.019853	49 80		eor #$80			eor 	#$80
.019855	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019858	68		pla				pla
.019859	60		rts				rts
.01985a					FPAdd_Worker:
.01985a	3c 13 03	bit $0313,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.01985d	70 08		bvs $019867			bvs 	_FPAWExit 					; no change.
.01985f	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.019862	50 07		bvc $01986b			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.019864	20 ff 9a	jsr $019aff			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.019867					_FPAWExit:
.019867	20 87 9b	jsr $019b87			jsr 	FPUNormalise 				; normalise the result.
.01986a	60		rts				rts
.01986b					_FPAWMakeSame:
.01986b	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.01986e	38		sec				sec
.01986f	fd 12 03	sbc $0312,x			sbc	 	XS2_Exponent,x 				; using subtraction
.019872	f0 1b		beq $01988f			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.019874	da		phx				phx 								; save X
.019875	90 06		bcc $01987d			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.019877	e8		inx				inx
.019878	e8		inx				inx
.019879	e8		inx				inx
.01987a	e8		inx				inx
.01987b	e8		inx				inx
.01987c	e8		inx				inx
.01987d					_FPAWShiftA:
.01987d	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x 				; so shift exponent up.
.019880	5e 0b 03	lsr $030b,x			lsr 	3+XS_Mantissa,x
.019883	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.019886	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.019889	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.01988c	fa		plx				plx 								; restore original X
.01988d	80 dc		bra $01986b			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.01988f					_FPAW_DoArithmetic:
.01988f	3c 13 03	bit $0313,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.019892	30 39		bmi $0198cd			bmi 	_FPAW_BNegative
.019894	18		clc				clc
.019895	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.019898	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.01989b	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.01989e	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0198a1	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.0198a4	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0198a7	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.0198aa	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.0198ad	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0198b0	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.0198b3	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.0198b6	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0198b9	90 ac		bcc $019867			bcc 	_FPAWExit 					; no carry.
.0198bb	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x 				; so shift exponent up.
.0198be	38		sec				sec
.0198bf	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.0198c2	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.0198c5	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.0198c8	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.0198cb	80 9a		bra $019867			bra 	_FPAWExit
.0198cd					_FPAW_BNegative:
.0198cd	38		sec				sec
.0198ce	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.0198d1	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.0198d4	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0198d7	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0198da	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.0198dd	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0198e0	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.0198e3	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.0198e6	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0198e9	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.0198ec	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.0198ef	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0198f2	b0 0b		bcs $0198ff			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.0198f4	20 2c 9b	jsr $019b2c			jsr 	FPUNegateInteger			; negate the mantissa
.0198f7	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip result sign
.0198fa	49 80		eor #$80			eor 	#$80
.0198fc	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0198ff					_FPAWGoExit:
.0198ff	4c 67 98	jmp $019867			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.019902					FPD_IsDivZero:
.019902	20 2f 84	jsr $01842f			jsr ERR_Handler
>019905	44 69 76 69 73 69 6f 6e			.text "Division by zero",0
>01990d	20 62 79 20 7a 65 72 6f 00
.019916					FPDivide:
.019916	48		pha				pha
.019917	5a		phy				phy
.019918	3c 13 03	bit $0313,x			bit 	XS2_Type,x 					; check if division by zero
.01991b	70 e5		bvs $019902			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.01991d	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.019920	f0 03		beq $019925			beq 	_FPDCalculateExp
.019922					_FPD_Exit:
.019922	7a		ply				ply
.019923	68		pla				pla
.019924	60		rts				rts
.019925					_FPDCalculateExp:
.019925	bd 12 03	lda $0312,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.019928	49 ff		eor #$ff			eor 	#$FF
.01992a	1a		inc a				inc 	a
.01992b	9d 12 03	sta $0312,x			sta 	XS2_Exponent,x
.01992e	20 22 9a	jsr $019a22			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.019931	18		clc				clc 	 							; add 1 to the resulting exponent
.019932	69 01		adc #$01			adc 	#1
.019934	b0 65		bcs $01999b			bcs 	_FPD_Overflow 				; which can overflow.
.019936	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.019939	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.01993b	85 1a		sta $1a				sta 	zLTemp1+0
.01993d	85 1b		sta $1b				sta 	zLTemp1+1
.01993f	85 1c		sta $1c				sta 	zLTemp1+2
.019941	85 1d		sta $1d				sta 	zLTemp1+3
.019943	a0 20		ldy #$20			ldy 	#32 						; times round.
.019945					_FPD_Loop:
.019945	38		sec				sec 								; calculate X1-X2 stacking result because we might
.019946	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; not save it.
.019949	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa,x
.01994c	48		pha				pha
.01994d	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.019950	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.019953	48		pha				pha
.019954	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.019957	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.01995a	48		pha				pha
.01995b	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.01995e	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.019961	90 17		bcc $01997a			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.019963	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x 			; save results out to A
.019966	68		pla				pla
.019967	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01996a	68		pla				pla
.01996b	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.01996e	68		pla				pla
.01996f	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019972	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.019974	09 80		ora #$80			ora 	#$80
.019976	85 1d		sta $1d				sta 	zLTemp1+3
.019978	80 03		bra $01997d			bra 	_FPD_Rotates
.01997a					_FPD_NoSubtract:
.01997a	68		pla				pla 								; throw away unwanted results
.01997b	68		pla				pla
.01997c	68		pla				pla
.01997d					_FPD_Rotates:
.01997d	5e 11 03	lsr $0311,x			lsr 	3+XS2_Mantissa,x
.019980	7e 10 03	ror $0310,x			ror 	2+XS2_Mantissa,x
.019983	7e 0f 03	ror $030f,x			ror 	1+XS2_Mantissa,x
.019986	7e 0e 03	ror $030e,x			ror 	0+XS2_Mantissa,x
.019989	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.01998b	26 1b		rol $1b				rol 	zLTemp1+1
.01998d	26 1c		rol $1c				rol 	zLTemp1+2
.01998f	26 1d		rol $1d				rol 	zLTemp1+3
.019991	90 02		bcc $019995			bcc 	_FPD_NoCarry
.019993	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.019995					_FPD_NoCarry:
.019995	88		dey				dey 								; do 32 times
.019996	d0 ad		bne $019945			bne 	_FPD_Loop
.019998	4c ff 99	jmp $0199ff			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.01999b					_FPD_Overflow:
.01999b	4c fc 9b	jmp $019bfc			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.01999e					FPMultiply:
.01999e	48		pha				pha
.01999f	5a		phy				phy
.0199a0	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.0199a3	70 08		bvs $0199ad			bvs 	_FPM_Exit
.0199a5	3c 13 03	bit $0313,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.0199a8	50 06		bvc $0199b0			bvc 	_FPM_CalcExponent
.0199aa	20 ff 9a	jsr $019aff			jsr 	FPUCopyX2ToX1
.0199ad					_FPM_Exit:
.0199ad	7a		ply				ply
.0199ae	68		pla				pla
.0199af	60		rts				rts
.0199b0					_FPM_CalcExponent:
.0199b0	18		clc				clc
.0199b1	20 22 9a	jsr $019a22			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.0199b4	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x 				; save the result.
.0199b7	a9 00		lda #$00			lda 	#0
.0199b9	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.0199bb	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.0199bd	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.0199bf	85 1d		sta $1d				sta 	zLTemp1+3
.0199c1	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.0199c3					_FPM_Loop:
.0199c3	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x				; check LSB of long product
.0199c6	29 01		and #$01			and 	#1
.0199c8	18		clc				clc 								; clear carry for the long rotate.
.0199c9	f0 1d		beq $0199e8			beq 	_FPM_NoAddition
.0199cb	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.0199cc	a5 1a		lda $1a				lda 	zLTemp1+0
.0199ce	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.0199d1	85 1a		sta $1a				sta 	zLTemp1+0
.0199d3	a5 1b		lda $1b				lda 	zLTemp1+1
.0199d5	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.0199d8	85 1b		sta $1b				sta 	zLTemp1+1
.0199da	a5 1c		lda $1c				lda 	zLTemp1+2
.0199dc	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.0199df	85 1c		sta $1c				sta 	zLTemp1+2
.0199e1	a5 1d		lda $1d				lda 	zLTemp1+3
.0199e3	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.0199e6	85 1d		sta $1d				sta 	zLTemp1+3
.0199e8					_FPM_NoAddition:
.0199e8	66 1d		ror $1d				ror 	3+zLTemp1
.0199ea	66 1c		ror $1c				ror 	2+zLTemp1
.0199ec	66 1b		ror $1b				ror 	1+zLTemp1
.0199ee	66 1a		ror $1a				ror 	0+zLTemp1
.0199f0	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.0199f3	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.0199f6	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.0199f9	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.0199fc	88		dey				dey
.0199fd	d0 c4		bne $0199c3			bne 	_FPM_Loop 					; do this 32 times.
.0199ff					FPM_CopySignNormalize:
.0199ff	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.019a01	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.019a04	a5 1b		lda $1b				lda 	zLTemp1+1
.019a06	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019a09	a5 1c		lda $1c				lda 	zLTemp1+2
.019a0b	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019a0e	a5 1d		lda $1d				lda 	zLTemp1+3
.019a10	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019a13	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; sign is xor of signs
.019a16	5d 13 03	eor $0313,x			eor 	XS2_Type,x
.019a19	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019a1c	20 87 9b	jsr $019b87			jsr 	FPUNormalise 				; normalise and exit.
.019a1f	7a		ply				ply
.019a20	68		pla				pla
.019a21	60		rts				rts
.019a22					FPCalculateExponent:
.019a22	18		clc				clc
.019a23	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.019a26	7d 12 03	adc $0312,x			adc 	XS2_Exponent,x
.019a29	b0 08		bcs $019a33			bcs 	_FPCECarry 					; carry out ?
.019a2b	10 03		bpl $019a30			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.019a2d	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.019a2f	60		rts				rts
.019a30					_FPCEExpZero:
.019a30	a9 00		lda #$00			lda 	#0
.019a32	60		rts				rts
.019a33					_FPCECarry:
.019a33	30 03		bmi $019a38			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.019a35	09 80		ora #$80			ora 	#$80 						; put in right range
.019a37	60		rts				rts
.019a38					_FPCEOverflow:
.019a38	4c fc 9b	jmp $019bfc			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.019a3b					FPFractionalPart:
.019a3b	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.019a3e	38		sec				sec 								; this flag tells us to keep the fractional part
.019a3f	30 0f		bmi $019a50			bmi 	FPGetPart
.019a41	60		rts				rts
.019a42					FPIntegerPart:
.019a42	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.019a45	18		clc				clc 								; this flag says keep the integer part.
.019a46	30 08		bmi $019a50			bmi 	FPGetPart 					; -ve exponents are 0..127
.019a48	48		pha				pha
.019a49	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.019a4b	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019a4e	68		pla				pla
.019a4f	60		rts				rts
.019a50					FPGetPart:
.019a50	48		pha				pha
.019a51	5a		phy				phy 								; save Y
.019a52	08		php				php 								; save action
.019a53	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.019a56	70 62		bvs $019aba			bvs 	_FPGP_Exit 					; then do nothing.
.019a58	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.019a5a	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.019a5c	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.019a5e	85 1c		sta $1c				sta 	zLTemp1+2
.019a60	85 1d		sta $1d				sta 	zLTemp1+3
.019a62	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x				; the number of shifts.
.019a65	38		sec				sec
.019a66	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.019a68	f0 12		beq $019a7c			beq 	_FPGP_NoShift 				; ... if any
.019a6a	c9 20		cmp #$20			cmp 	#32
.019a6c	90 02		bcc $019a70			bcc 	_FPGP_NotMax
.019a6e	a9 20		lda #$20			lda 	#32 						; max of 32.
.019a70					_FPGP_NotMax:
.019a70	a8		tay				tay 								; Y is the mask shift count.
.019a71					_FPGP_ShiftMask:
.019a71	46 1d		lsr $1d				lsr 	3+zLTemp1
.019a73	66 1c		ror $1c				ror 	2+zLTemp1
.019a75	66 1b		ror $1b				ror 	1+zLTemp1
.019a77	66 1a		ror $1a				ror 	0+zLTemp1
.019a79	88		dey				dey
.019a7a	d0 f5		bne $019a71			bne 	_FPGP_ShiftMask
.019a7c					_FPGP_NoShift:
.019a7c	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.019a7e	8e 8c 04	stx $048c			stx 	ExpTemp						; save X
.019a81					_FPGP_MaskLoop:
.019a81	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.019a84	28		plp				plp 								; if CC we keep the top part, so we
.019a85	08		php				php		 							; flip the mask.
.019a86	b0 02		bcs $019a8a			bcs		_FPGP_NoFlip
.019a88	49 ff		eor #$ff			eor 	#$FF
.019a8a					_FPGP_NoFlip:
.019a8a	3d 08 03	and $0308,x			and 	XS_Mantissa,x 				; and into the mantissa.
.019a8d	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.019a90	e8		inx				inx
.019a91	c8		iny				iny
.019a92	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.019a94	d0 eb		bne $019a81			bne 	_FPGP_MaskLoop
.019a96	ae 8c 04	ldx $048c			ldx 	ExpTemp						; restore X
.019a99	28		plp				plp
.019a9a	08		php				php 								; get action flag on the stack
.019a9b	90 05		bcc $019aa2			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.019a9d	a9 00		lda #$00			lda 	#0
.019a9f	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019aa2					_FPGP_NotFractional:
.019aa2	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 						; check if \1 zero
.019aa5	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.019aa8	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.019aab	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.019aae	f0 05		beq $019ab5			beq 	_FPGP_Zero 					; if zero, return zero
.019ab0	20 87 9b	jsr $019b87			jsr 	FPUNormalise
.019ab3	80 05		bra $019aba			bra 	_FPGP_Exit 					; and exit
.019ab5					_FPGP_Zero:
.019ab5	a9 40		lda #$40			lda 	#$40 						; set zero flag
.019ab7	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019aba					_FPGP_Exit:
.019aba	68		pla				pla 								; throw saved action flag.
.019abb	7a		ply				ply
.019abc	68		pla				pla
.019abd	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.019abe					FPCompare:
.019abe	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.019ac1	48		pha				pha
.019ac2	bd 12 03	lda $0312,x			lda 	XS2_Exponent,x
.019ac5	48		pha				pha
.019ac6	20 28 98	jsr $019828			jsr 	FPSubtract 					; calculate X1-X2
.019ac9	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.019acc	70 2c		bvs $019afa			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.019ace	68		pla				pla
.019acf	8d 8c 04	sta $048c			sta 	ExpTemp						; save first exponent in temporary reg.
.019ad2	68		pla				pla
.019ad3	38		sec				sec
.019ad4	ed 8c 04	sbc $048c			sbc 	ExpTemp 					; calculate AX-BX
.019ad7	70 15		bvs $019aee			bvs 	_FPCNotEqual				; overflow, can't be equal.
.019ad9	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.019ada	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.019adc	b0 10		bcs $019aee			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.019ade	38		sec				sec
.019adf	ad 8c 04	lda $048c			lda 	ExpTemp 					; get one of the exponents back.
.019ae2	e9 12		sbc #$12			sbc 	#18 						; allow for 2^18 error, relatively.
.019ae4	b0 02		bcs $019ae8			bcs 	_FPCNotRange 				; keep in range.
.019ae6	a9 01		lda #$01			lda 	#1
.019ae8					_FPCNotRange:
.019ae8	38		sec				sec
.019ae9	fd 0c 03	sbc $030c,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.019aec	b0 0e		bcs $019afc			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.019aee					_FPCNotEqual:
.019aee	bd 0d 03	lda $030d,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.019af1	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.019af3	f0 02		beq $019af7			beq 	_FPCNE2
.019af5	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.019af7	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.019af8	80 04		bra $019afe			bra 	_FPCExit
.019afa					_FPCPullZero:
.019afa	68		pla				pla 								; throw saved exponents
.019afb	68		pla				pla
.019afc					_FPCZero:
.019afc	a9 00		lda #$00			lda 	#0 							; and return zero
.019afe					_FPCExit:
.019afe	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.019aff					FPUCopyX2ToX1:
.019aff	48		pha				pha
.019b00	da		phx				phx
.019b01	5a		phy				phy
.019b02	a0 08		ldy #$08			ldy 	#8
.019b04	bd 0e 03	lda $030e,x	_FPUC21:lda 	XS2_Mantissa,x
.019b07	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.019b0a	e8		inx				inx
.019b0b	88		dey				dey
.019b0c	10 f6		bpl $019b04			bpl 	_FPUC21
.019b0e	7a		ply				ply
.019b0f	fa		plx				plx
.019b10	68		pla				pla
.019b11	60		rts				rts
.019b12					FPUSetInteger:
.019b12	48		pha				pha
.019b13	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.019b16	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.019b18	10 02		bpl $019b1c			bpl 	_FPUSIExtend
.019b1a	a9 ff		lda #$ff			lda 	#$FF
.019b1c					_FPUSIExtend:
.019b1c	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.019b1f	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019b22	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019b25	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.019b27	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019b2a	68		pla				pla
.019b2b	60		rts				rts
.019b2c					FPUNegateInteger:
.019b2c	48		pha				pha
.019b2d	38		sec				sec
.019b2e	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.019b30	fd 08 03	sbc $0308,x			sbc 	XS_Mantissa+0,x
.019b33	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019b36	a9 00		lda #$00			lda 	#0
.019b38	fd 09 03	sbc $0309,x			sbc 	XS_Mantissa+1,x
.019b3b	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019b3e	a9 00		lda #$00			lda 	#0
.019b40	fd 0a 03	sbc $030a,x			sbc 	XS_Mantissa+2,x
.019b43	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019b46	a9 00		lda #$00			lda 	#0
.019b48	fd 0b 03	sbc $030b,x			sbc 	XS_Mantissa+3,x
.019b4b	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019b4e	68		pla				pla
.019b4f	60		rts				rts
.019b50					FPUToFloat:
.019b50	48		pha				pha
.019b51	bd 0d 03	lda $030d,x			lda 	XS_Type,x					; exit if already float.
.019b54	29 0f		and #$0f			and 	#$0F
.019b56	f0 2d		beq $019b85			beq 	_FPUFExit
.019b58	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.019b5a	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019b5d	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.019b5f	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x 				; x mantissa.
.019b62	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.019b65	10 08		bpl $019b6f			bpl		_FPUFPositive
.019b67	20 2c 9b	jsr $019b2c			jsr 	FPUNegateInteger 			; negate the mantissa
.019b6a	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.019b6c	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019b6f					_FPUFPositive:
.019b6f	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.019b72	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.019b75	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.019b78	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.019b7b	d0 05		bne $019b82			bne 	_FPUFNonZero
.019b7d	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.019b7f	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019b82					_FPUFNonZero:
.019b82	20 87 9b	jsr $019b87			jsr 	FPUNormalise 				; normalise the floating point.
.019b85					_FPUFExit:
.019b85	68		pla				pla
.019b86	60		rts				rts
.019b87					FPUNormalise:
.019b87	48		pha				pha
.019b88	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.019b8b	70 20		bvs $019bad			bvs 	_FPUNExit
.019b8d	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.019b90	f0 16		beq $019ba8			beq 	_FPUNSetZero
.019b92					_FPUNLoop:
.019b92	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.019b95	30 16		bmi $019bad			bmi 	_FPUNExit 					; if so, we are normalised.
.019b97	1e 08 03	asl $0308,x			asl 	0+XS_Mantissa+0,x
.019b9a	3e 09 03	rol $0309,x			rol 	1+XS_Mantissa+0,x
.019b9d	3e 0a 03	rol $030a,x			rol 	2+XS_Mantissa+0,x
.019ba0	3e 0b 03	rol $030b,x			rol 	3+XS_Mantissa+0,x
.019ba3	de 0c 03	dec $030c,x			dec 	XS_Exponent,x 				; decrement exponent
.019ba6	d0 ea		bne $019b92			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.019ba8					_FPUNSetZero:
.019ba8	a9 40		lda #$40			lda 	#$40
.019baa	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; the result is now zero.
.019bad					_FPUNExit:
.019bad	68		pla				pla
.019bae	60		rts				rts
.019baf					FPUToInteger:
.019baf	48		pha				pha
.019bb0	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; if already integer, exit
.019bb3	29 01		and #$01			and 	#1
.019bb5	d0 3e		bne $019bf5			bne 	_FPUTOI_Exit
.019bb7	3c 0d 03	bit $030d,x			bit 	XS_Type,x					; if zero, return zero.
.019bba	70 2b		bvs $019be7			bvs 	_FPUTOI_Zero
.019bbc	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.019bbf	10 26		bpl $019be7			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.019bc1	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.019bc3	b0 37		bcs $019bfc			bcs 	FP_Overflow
.019bc5					_FPUToIToInteger:
.019bc5	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.019bc8	c9 a0		cmp #$a0			cmp 	#128+32
.019bca	f0 11		beq $019bdd			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.019bcc	fe 0c 03	inc $030c,x			inc 	XS_Exponent,X 				; increment Exponent
.019bcf	5e 0b 03	lsr $030b,x			lsr 	3+XS_Mantissa,x
.019bd2	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.019bd5	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.019bd8	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.019bdb	80 e8		bra $019bc5			bra 	_FPUToIToInteger 			; keep going.
.019bdd					_FPUToICheckSign:
.019bdd	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; check sign
.019be0	10 13		bpl $019bf5			bpl 	_FPUToI_Exit 				; exit if unsigned.
.019be2	20 2c 9b	jsr $019b2c			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.019be5	80 0e		bra $019bf5			bra 	_FPUTOI_Exit
.019be7					_FPUTOI_Zero:
.019be7	a9 00		lda #$00			lda 	#0 							; return zero integer.
.019be9	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019bec	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019bef	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019bf2	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019bf5					_FPUToI_Exit:
.019bf5	a9 01		lda #$01			lda 	#1 							; set type to integer
.019bf7	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019bfa	68		pla				pla
.019bfb	60		rts				rts
.019bfc					FP_Overflow:
.019bfc	20 2f 84	jsr $01842f			jsr ERR_Handler
>019bff	46 6c 6f 61 74 69 6e 67			.text "Floating Point overflow",0
>019c07	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.019c17					FPUTimes10:
.019c17	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.019c1a	85 1a		sta $1a				sta 	ZLTemp1+0
.019c1c	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.019c1f	85 1b		sta $1b				sta 	ZLTemp1+1
.019c21	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.019c24	85 1c		sta $1c				sta 	ZLTemp1+2
.019c26	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.019c29	85 1d		sta $1d				sta 	ZLTemp1+3
.019c2b	20 6f 9c	jsr $019c6f			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.019c2e	20 6f 9c	jsr $019c6f			jsr 	_FPUT_LSR_ZLTemp1
.019c31	18		clc				clc
.019c32	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.019c35	65 1a		adc $1a				adc 	ZLTemp1+0
.019c37	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019c3a	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.019c3d	65 1b		adc $1b				adc 	ZLTemp1+1
.019c3f	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019c42	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.019c45	65 1c		adc $1c				adc 	ZLTemp1+2
.019c47	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019c4a	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.019c4d	65 1d		adc $1d				adc 	ZLTemp1+3
.019c4f	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019c52	90 0f		bcc $019c63			bcc 	_FPUTimes10
.019c54	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.019c57	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.019c5a	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.019c5d	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.019c60	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x				; fix exponent
.019c63					_FPUTimes10:
.019c63	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.019c66	18		clc				clc
.019c67	69 03		adc #$03			adc 	#3
.019c69	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.019c6c	b0 8e		bcs $019bfc			bcs 	FP_Overflow 				; error
.019c6e	60		rts				rts
.019c6f					_FPUT_LSR_ZLTemp1:
.019c6f	46 1d		lsr $1d				lsr 	ZLTemp1+3
.019c71	66 1c		ror $1c				ror 	ZLTemp1+2
.019c73	66 1b		ror $1b				ror 	ZLTemp1+1
.019c75	66 1a		ror $1a				ror 	ZLTemp1+0
.019c77	60		rts				rts
.019c78					FPUScale10A:
.019c78	5a		phy				phy
.019c79	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.019c7b	f0 3d		beq $019cba			beq 	_FPUScaleExit
.019c7d	da		phx				phx 								; save X
.019c7e	e8		inx				inx
.019c7f	e8		inx				inx
.019c80	e8		inx				inx
.019c81	e8		inx				inx
.019c82	e8		inx				inx
.019c83	e8		inx				inx
.019c84	a8		tay				tay 								; save power scalar in Y.
.019c85	a9 00		lda #$00			lda 	#0
.019c87	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.019c8a	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019c8d	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019c90	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019c93	a9 80		lda #$80			lda 	#$80
.019c95	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019c98	a9 81		lda #$81			lda 	#$81
.019c9a	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.019c9d	5a		phy				phy 								; save 10^n on stack.
.019c9e	c0 00		cpy #$00			cpy 	#0
.019ca0	10 05		bpl $019ca7			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.019ca2	98		tya				tya
.019ca3	49 ff		eor #$ff			eor 	#$FF
.019ca5	1a		inc a				inc 	a
.019ca6	a8		tay				tay
.019ca7					_FPUSAbs:
.019ca7	20 17 9c	jsr $019c17			jsr 	FPUTimes10
.019caa	88		dey				dey
.019cab	d0 fa		bne $019ca7			bne 	_FPUSAbs 					; tos is now 10^|AC|
.019cad	68		pla				pla 								; restore count in A
.019cae	fa		plx				plx 								; restore X pointing to number to scale.
.019caf	0a		asl a				asl 	a
.019cb0	b0 05		bcs $019cb7			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.019cb2	20 9e 99	jsr $01999e			jsr 	FPMultiply 					; if clear multiply.
.019cb5	80 03		bra $019cba			bra		_FPUScaleExit
.019cb7					_FPUSDivide:
.019cb7	20 16 99	jsr $019916			jsr 	FPDivide
.019cba					_FPUScaleExit:
.019cba	7a		ply				ply
.019cbb	60		rts				rts
.019cbc					FPUCopyToNext:
.019cbc	a0 06		ldy #$06			ldy 		#6
.019cbe	da		phx				phx
.019cbf					_FPUCopy1:
.019cbf	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x
.019cc2	9d 0e 03	sta $030e,x			sta 	XS2_Mantissa,x
.019cc5	e8		inx				inx
.019cc6	88		dey				dey
.019cc7	d0 f6		bne $019cbf			bne 	_FPUCopy1
.019cc9	fa		plx				plx
.019cca	60		rts				rts
.019ccb					FPUCopyFromNext:
.019ccb	a0 06		ldy #$06			ldy 		#6
.019ccd	da		phx				phx
.019cce					_FPUCopy1:
.019cce	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa,x
.019cd1	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.019cd4	e8		inx				inx
.019cd5	88		dey				dey
.019cd6	d0 f6		bne $019cce			bne 	_FPUCopy1
.019cd8	fa		plx				plx
.019cd9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.019cda					FPToString:
.019cda	48		pha				pha
.019cdb	5a		phy				phy
.019cdc	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; check zero flag
.019cdf	50 0a		bvc $019ceb			bvc 		_FPTSIsFloat 			; if zero,
.019ce1					_FPTSZero:
.019ce1	a9 30		lda #$30			lda 		#"0"
.019ce3	20 6a 97	jsr $01976a			jsr 		ITSOutputCharacter
.019ce6					_FPTSExit:
.019ce6	7a		ply				ply
.019ce7	68		pla				pla
.019ce8	60		rts				rts
.019ce9	80 fb		bra $019ce6			bra 		_FPTSExit
.019ceb					_FPTSIsFloat:
.019ceb	bd 0d 03	lda $030d,x			lda 		XS_Type,x 				; is it signed ?
.019cee	10 0a		bpl $019cfa			bpl 		_FPTSNotSigned
.019cf0	a9 00		lda #$00			lda 		#0 						; clear sign flag
.019cf2	9d 0d 03	sta $030d,x			sta 		XS_Type,x
.019cf5	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.019cf7	20 6a 97	jsr $01976a			jsr 		ITSOutputCharacter
.019cfa					_FPTSNotSigned:
.019cfa	bd 0c 03	lda $030c,x			lda 		XS_Exponent,x
.019cfd	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.019cff	b0 09		bcs $019d0a			bcs 		_FPTSExponent
.019d01	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.019d03	90 05		bcc $019d0a			bcc 		_FPTSExponent 			;
.019d05					_FPTSStandard:
.019d05	20 4e 9d	jsr $019d4e			jsr 		FPTOutputBody 			; output the body.
.019d08	80 dc		bra $019ce6			bra 		_FPTSExit
.019d0a					_FPTSExponent:
.019d0a	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.019d0c	8d 8d 04	sta $048d			sta 		ExpCount
.019d0f					_FPTSExponentLoop:
.019d0f	bd 0c 03	lda $030c,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.019d12	10 0e		bpl $019d22			bpl 		_FPTSTimes
.019d14	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.019d16	90 14		bcc $019d2c			bcc 		_FPTSScaledToExp
.019d18	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.019d1a	20 78 9c	jsr $019c78			jsr 		FPUScale10A
.019d1d	ee 8d 04	inc $048d			inc 		ExpCount
.019d20	80 ed		bra $019d0f			bra 		_FPTSExponentLoop
.019d22					_FPTSTimes:
.019d22	a9 01		lda #$01			lda 		#1
.019d24	20 78 9c	jsr $019c78			jsr 		FPUScale10A
.019d27	ce 8d 04	dec $048d			dec 		ExpCount
.019d2a	80 e3		bra $019d0f			bra 		_FPTSExponentLoop
.019d2c					_FPTSScaledToExp:
.019d2c	20 4e 9d	jsr $019d4e			jsr 		FPTOutputBody 			; output the body.
.019d2f	a9 65		lda #$65			lda 		#"e"					; output E
.019d31	20 6a 97	jsr $01976a			jsr 		ITSOutputCharacter
.019d34	ad 8d 04	lda $048d			lda 		ExpCount 				; get the exponent
.019d37	9d 08 03	sta $0308,x			sta 		XS_Mantissa,x
.019d3a	29 80		and #$80			and 		#$80 					; sign extend it
.019d3c	f0 02		beq $019d40			beq 		_FPTSSExt
.019d3e	a9 ff		lda #$ff			lda 		#$FF
.019d40					_FPTSSExt:
.019d40	9d 09 03	sta $0309,x			sta 		XS_Mantissa+1,x
.019d43	9d 0a 03	sta $030a,x			sta 		XS_Mantissa+2,x
.019d46	9d 0b 03	sta $030b,x			sta 		XS_Mantissa+3,x
.019d49	20 c6 96	jsr $0196c6			jsr 		INTToString 			; output the exponent.
.019d4c	80 98		bra $019ce6			bra			_FPTSExit 				; and exit.
.019d4e					FPTOutputBody:
.019d4e	20 bc 9c	jsr $019cbc			jsr 		FPUCopyToNext 			; copy to next slot.
.019d51	20 af 9b	jsr $019baf			jsr 		FPUToInteger 			; convert to an integer
.019d54	20 c6 96	jsr $0196c6			jsr 		INTToString 			; output the main integer part.
.019d57	20 cb 9c	jsr $019ccb			jsr 		FPUCopyFromNext 		; get the fractional part back.
.019d5a	20 3b 9a	jsr $019a3b			jsr 		FPFractionalPart 		; get the decimal part.
.019d5d	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; any fractional part.
.019d60	70 3e		bvs $019da0			bvs 		_FPTOExit 				; if not, exit now.
.019d62	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.019d64	20 6a 97	jsr $01976a			jsr 		ITSOutputCharacter
.019d67					_FPOutLoop:
.019d67	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; finally reached zero.
.019d6a	70 1e		bvs $019d8a			bvs 		_FPStripZeros 			; strip trailing zeros
.019d6c	20 17 9c	jsr $019c17			jsr 		FPUTimes10 				; multiply by 10
.019d6f	20 bc 9c	jsr $019cbc			jsr 		FPUCopyToNext			; copy to next slot.
.019d72	20 af 9b	jsr $019baf			jsr 		FPUToInteger 			; convert to integer
.019d75	bd 08 03	lda $0308,x			lda 		XS_Mantissa+0,x 		; print digit.
.019d78	09 30		ora #$30			ora 		#"0"
.019d7a	20 6a 97	jsr $01976a			jsr 		ITSOutputCharacter
.019d7d	20 cb 9c	jsr $019ccb			jsr 		FPUCopyFromNext 		; get it back
.019d80	20 3b 9a	jsr $019a3b			jsr 		FPFractionalPart 		; get fractional part
.019d83	ad 04 04	lda $0404			lda 		NumBufX 				; done 11 characters yet ?
.019d86	c9 0b		cmp #$0b			cmp 	 	#11
.019d88	90 dd		bcc $019d67			bcc 		_FPOutLoop 				; if so, keep going till zero.
.019d8a					_FPStripZeros:
.019d8a	ac 04 04	ldy $0404			ldy 		NumBufX 				; strip trailing zeros.
.019d8d					_FPStripLoop:
.019d8d	88		dey				dey 								; back one, if at start then no strip
.019d8e	f0 10		beq $019da0			beq 		_FPToExit
.019d90	b9 05 04	lda $0405,y			lda 		Num_Buffer,y 			; keep going if "0"
.019d93	c9 30		cmp #$30			cmp 		#"0"
.019d95	f0 f6		beq $019d8d			beq 		_FPStripLoop
.019d97	c8		iny				iny
.019d98	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.019d9a	99 05 04	sta $0405,y			sta 		Num_Buffer,y
.019d9d	8c 04 04	sty $0404			sty 		NumBufX 				; update position.
.019da0					_FPTOExit:
.019da0	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.019da1					FPFromString:
.019da1	48		pha				pha 								; push A
.019da2	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.019da4	c9 2e		cmp #$2e			cmp 	#"."
.019da6	f0 03		beq $019dab			beq	 	_FPFIsDecimal
.019da8	4c 0e 9e	jmp $019e0e			jmp 	_FPFNotDecimal
.019dab					_FPFIsDecimal:
.019dab	c8		iny				iny 								; consume the decimal.
.019dac	20 50 9b	jsr $019b50			jsr 	FPUToFloat 					; convert the integer to float.
.019daf	da		phx				phx 								; save X.
.019db0	5a		phy				phy 								; save decimal start position
.019db1	e8		inx				inx
.019db2	e8		inx				inx
.019db3	e8		inx				inx
.019db4	e8		inx				inx
.019db5	e8		inx				inx
.019db6	e8		inx				inx
.019db7	20 82 97	jsr $019782			jsr 	INTFromStringY 				; get the part after the DP.
.019dba	20 50 9b	jsr $019b50			jsr 	FPUToFloat 					; convert that to a float.
.019dbd	68		pla				pla 								; calculate - chars consumed.
.019dbe	8c 8c 04	sty $048c			sty 	ExpTemp
.019dc1	38		sec				sec
.019dc2	ed 8c 04	sbc $048c			sbc 	ExpTemp 					; this is the shift amount
.019dc5	20 78 9c	jsr $019c78			jsr 	FPUScale10A 				; scale it by 10^AC
.019dc8	fa		plx				plx 								; restore original X
.019dc9	20 32 98	jsr $019832			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.019dcc	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.019dce	c9 45		cmp #$45			cmp 	#"E"
.019dd0	f0 04		beq $019dd6			beq 	_FPFExponent
.019dd2	c9 65		cmp #$65			cmp 	#"e"
.019dd4	d0 38		bne $019e0e			bne 	_FPFNotDecimal 				; no, then exit normally.
.019dd6					_FPFExponent:
.019dd6	c8		iny				iny 								; skip over E symbol.
.019dd7	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.019dd9	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.019ddb	d0 01		bne $019dde			bne 	_FPFGotSign
.019ddd	c8		iny				iny 								; if it was - skip over it.
.019dde					_FPFGotSign:
.019dde	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.019ddf	da		phx				phx
.019de0	e8		inx				inx
.019de1	e8		inx				inx
.019de2	e8		inx				inx
.019de3	e8		inx				inx
.019de4	e8		inx				inx
.019de5	e8		inx				inx
.019de6	20 82 97	jsr $019782			jsr 	INTFromStringY 				; get the exponent
.019de9	fa		plx				plx 								; restore X.
.019dea	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.019ded	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.019df0	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.019df3	d0 1b		bne $019e10			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.019df5	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.019df8	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.019dfa	b0 14		bcs $019e10			bcs 	_FPFXOverflow
.019dfc	68		pla				pla 								; get direction
.019dfd	d0 09		bne $019e08			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.019dff	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.019e02	49 ff		eor #$ff			eor 	#$FF
.019e04	1a		inc a				inc 	a
.019e05	9d 0e 03	sta $030e,x			sta 	XS2_Mantissa+0,x
.019e08					_FPFXScale:
.019e08	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.019e0b	20 78 9c	jsr $019c78			jsr 	FPUScale10A 				; scale by the exponent.
.019e0e					_FPFNotDecimal:
.019e0e	68		pla				pla
.019e0f	60		rts				rts
.019e10					_FPFXOverflow:
.019e10	20 2f 84	jsr $01842f			jsr 	ERR_Handler
>019e13	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>019e1b	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.019e22					Unary_Rnd:
.019e22	20 62 8a	jsr $018a62			jsr 	EvaluateNumberX 			; get value
.019e25	20 f1 90	jsr $0190f1			jsr 	CheckNextRParen 			; check right bracket.
.019e28	20 4f 8d	jsr $018d4f			jsr 	GetSignCurrent 				; get sign -1,0,1.
.019e2b	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.019e2d	30 10		bmi $019e3f			bmi 	_URSetSeed
.019e2f	f0 2c		beq $019e5d			beq 	_URMakeRandom 				; if zero return same number.
.019e31	da		phx				phx
.019e32	a2 00		ldx #$00			ldx 	#0
.019e34	20 9a 9e	jsr $019e9a			jsr 	Random16
.019e37	a2 02		ldx #$02			ldx 	#2
.019e39	20 9a 9e	jsr $019e9a			jsr 	Random16
.019e3c	fa		plx				plx
.019e3d	80 1e		bra $019e5d			bra 	_URMakeRandom
.019e3f					_URSetSeed:
.019e3f	20 50 9b	jsr $019b50			jsr 	FPUToFloat 					; make it a float to twiddle it.
.019e42	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.019e45	8d 93 04	sta $0493			sta 	RandomSeed+0
.019e48	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.019e4b	8d 94 04	sta $0494			sta 	RandomSeed+1
.019e4e	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.019e51	8d 95 04	sta $0495			sta 	RandomSeed+2
.019e54	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.019e57	0a		asl a				asl 	a
.019e58	49 db		eor #$db			eor 	#$DB
.019e5a	8d 96 04	sta $0496			sta 	RandomSeed+3
.019e5d					_URMakeRandom:
.019e5d	ad 93 04	lda $0493			lda 	RandomSeed+0 				; check if seed is zero.
.019e60	0d 94 04	ora $0494			ora 	RandomSeed+1
.019e63	0d 95 04	ora $0495			ora 	RandomSeed+2
.019e66	0d 96 04	ora $0496			ora 	RandomSeed+3
.019e69	d0 0a		bne $019e75			bne 	_URNotZero
.019e6b	a9 47		lda #$47			lda 	#$47
.019e6d	8d 94 04	sta $0494			sta 	RandomSeed+1				; if it is, make it non zero.
.019e70	a9 3d		lda #$3d			lda 	#$3D
.019e72	8d 96 04	sta $0496			sta 	RandomSeed+3
.019e75					_URNotZero:
.019e75	ad 93 04	lda $0493			lda 	RandomSeed+0 				; copy seed into mantissa.
.019e78	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019e7b	ad 94 04	lda $0494			lda 	RandomSeed+1
.019e7e	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019e81	ad 95 04	lda $0495			lda 	RandomSeed+2
.019e84	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019e87	ad 96 04	lda $0496			lda 	RandomSeed+3
.019e8a	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019e8d	a9 00		lda #$00			lda 	#$00 						; set type to float.
.019e8f	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019e92	a9 80		lda #$80			lda 	#$80
.019e94	9d 0c 03	sta $030c,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.019e97	4c 87 9b	jmp $019b87			jmp 	FPUNormalise
.019e9a					Random16:
.019e9a	5e 94 04	lsr $0494,x			lsr 	RandomSeed+1,x				; shift seed right
.019e9d	7e 93 04	ror $0493,x			ror 	RandomSeed,x
.019ea0	90 08		bcc $019eaa			bcc 	_R16_NoXor
.019ea2	bd 94 04	lda $0494,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.019ea5	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.019ea7	9d 94 04	sta $0494,x			sta 	RandomSeed+1,x
.019eaa					_R16_NoXor:
.019eaa	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.019eab					Unary_Int:
.019eab	20 62 8a	jsr $018a62			jsr 	EvaluateNumberX 			; get value
.019eae	20 f1 90	jsr $0190f1			jsr 	CheckNextRParen 			; check right bracket.
.019eb1	4c af 9b	jmp $019baf			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Return to file: basic.asm

>019eb4	02						.byte 	2
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 c0						.word 	StartROM
>fffe	19 c0					.word TIM_BreakHandler

;******  End of listing
