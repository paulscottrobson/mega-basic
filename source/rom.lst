
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Fri Aug 23 10:52:53 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="65816"				cpu = "65816"
="em65816"				hardware = "em65816"
=0					exitonend = 0
=1					hasFloat = 1
=1					hasInteger = 1
=253					maxString = 253

;******  Processing file: modules/float/fpmacros.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/em65816/src_em65816.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0020					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0200					IFT_XCursor:.byte ?							; current logical position on screen
>0201					IFT_YCursor:.byte ?
>0202					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0266					IFT_LineBuffer: .fill 100 					; line input buffer.
>0300					UserVector .fill 4 							; USR(x) calls this.
>0304					LocalVector .fill 4 						; Indirect calls call this.
>0308					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>030c					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>030d					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=782					XS2_Mantissa = XS_Mantissa+XS_Size
=786					XS2_Exponent = XS_Exponent+XS_Size
=787					XS2_Type = XS_Type+XS_Size
=788					XS3_Mantissa = XS_Mantissa+XS_Size*2
=792					XS3_Exponent = XS_Exponent+XS_Size*2
=793					XS3_Type = XS_Type+XS_Size*2
>0400					Num_Buffer	.fill 	32 						; buffer for numeric conversions
>0420					NumBufX 	.byte 	?						; buffer index position
>0421					NumSuppress	.byte 	?						; leading zero suppression flag
>0422					NumConvCount .byte 	? 						; count for conversions.
>0423					ExpTemp:	.byte ?							; Working temp for exponents.
>0424					ExpCount:	.byte ? 						; Count of decimal exponents.
>0425					SignCount:	.byte ?							; Integer Divide Sign Counts.
>0426					StringPtr:	.byte ? 						; Top of free memory (for string allocation)
>0427					TempStringWriteIndex: .byte ? 				; Write offset.
>0428					ValSign: 	.byte ? 						; sign flag for val()
>0429					SliceStart:	.byte ? 						; string slice parts
>042a					SliceCount:	.byte ?
>042b					RandomSeed:	.dword ? 						; Random seed.
>042f					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>0431					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>0433					Tim_SR:		.byte ? 						; Processor Status
>0434					Tim_A:		.byte ? 						; Processor Registers
>0435					Tim_X:		.byte ?
>0436					Tim_Y:		.byte ?
>0437					Tim_Z:		.byte ?
>0438					Tim_SP:		.byte ?							; Stack Pointer

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/em65816.asm

=$8000					HighMemory = $8000
.1000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testcode.src

>1000	1a 0a 00 da a6 a1 fe 08			.byte	$1a,$0a,$00,$da,$a6,$a1,$fe,$08
>1008	61 62 63 64 65 66 bd 50			.byte	$61,$62,$63,$64,$65,$66,$bd,$50
>1010	bc bc be ff 06 68 69 20			.byte	$bc,$bc,$be,$ff,$06,$68,$69,$20
>1018	21 00 00				.byte	$21,$00,$00

;******  Return to file: modules/hardware/em65816.asm

.c000					StartROM:
.c000	18		clc				clc
.c001	fb		xce				xce
.c002	c2 30		rep #$30			rep 	#$30
.c004	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.c007	1b		tcs				tcs
.c008	e2 30		sep #$30			sep 	#$30
.c00a	c2 30		rep #$30			rep 	#$30						; clear AXY in 16 bit.
.c00c	a9 00		lda #$00			lda 	#$0000
.c00e	aa		tax				tax
.c00f	a8		tay				tay
.c010	e2 30		sep #$30			sep 	#$30
.c012	5c 82 84 01	jmp $018482		jmp BASIC_Start
.c016					TIM_BreakHandler:
.c016	5c 13 98 01	jmp $019813			jmp 	TIM_BreakVector

;******  Processing file: modules/hardware/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b4					lastUnaryFunction = $b4
.018000					VectorTable:
>018000	c9 86					.word BinaryOp_And         & $FFFF ; $80 and
>018002	f1 86					.word BinaryOp_Or          & $FFFF ; $81 or
>018004	19 87					.word BinaryOp_Xor         & $FFFF ; $82 xor
>018006	19 87					.word BinaryOp_Eor         & $FFFF ; $83 eor
>018008	5d 87					.word Binary_Equal         & $FFFF ; $84 =
>01800a	7c 87					.word Binary_NotEqual      & $FFFF ; $85 <>
>01800c	85 87					.word Binary_Less          & $FFFF ; $86 <
>01800e	8e 87					.word Binary_LessEqual     & $FFFF ; $87 <=
>018010	a0 87					.word Binary_Greater       & $FFFF ; $88 >
>018012	97 87					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>018014	35 88					.word BinaryOp_Add         & $FFFF ; $8a +
>018016	55 88					.word BinaryOp_Subtract    & $FFFF ; $8b -
>018018	68 88					.word BinaryOp_Multiply    & $FFFF ; $8c *
>01801a	7b 88					.word BinaryOp_Divide      & $FFFF ; $8d /
>01801c	b4 80					.word NotImplemented       & $FFFF ; $8e ^
>01801e	b4 80					.word NotImplemented       & $FFFF ; $8f if
>018020	b4 80					.word NotImplemented       & $FFFF ; $90 while
>018022	b4 80					.word NotImplemented       & $FFFF ; $91 repeat
>018024	b4 80					.word NotImplemented       & $FFFF ; $92 for
>018026	b4 80					.word NotImplemented       & $FFFF ; $93 then
>018028	b4 80					.word NotImplemented       & $FFFF ; $94 endif
>01802a	b4 80					.word NotImplemented       & $FFFF ; $95 wend
>01802c	b4 80					.word NotImplemented       & $FFFF ; $96 until
>01802e	b4 80					.word NotImplemented       & $FFFF ; $97 next
>018030	b4 80					.word NotImplemented       & $FFFF ; $98 not
>018032	b4 80					.word NotImplemented       & $FFFF ; $99 fn(
>018034	af 89					.word Unary_Abs            & $FFFF ; $9a abs(
>018036	04 8b					.word Unary_Asc            & $FFFF ; $9b asc(
>018038	8b 96					.word Unary_Int            & $FFFF ; $9c int(
>01803a	cd 89					.word Unary_Peek           & $FFFF ; $9d peek(
>01803c	02 96					.word Unary_Rnd            & $FFFF ; $9e rnd(
>01803e	41 8a					.word Unary_Usr            & $FFFF ; $9f usr(
>018040	45 8b					.word Unary_Left           & $FFFF ; $a0 left$(
>018042	5c 8b					.word Unary_Right          & $FFFF ; $a1 right$(
>018044	2a 8b					.word Unary_Mid            & $FFFF ; $a2 mid$(
>018046	be 8c					.word Unary_Spc            & $FFFF ; $a3 spc(
>018048	d1 8a					.word Unary_Str            & $FFFF ; $a4 str$(
>01804a	63 8a					.word Unary_Val            & $FFFF ; $a5 val(
>01804c	1b 8b					.word Unary_Len            & $FFFF ; $a6 len(
>01804e	da 8b					.word Unary_Hex            & $FFFF ; $a7 hex$(
>018050	b4 80					.word NotImplemented       & $FFFF ; $a8 sin(
>018052	b4 80					.word NotImplemented       & $FFFF ; $a9 cos(
>018054	b4 80					.word NotImplemented       & $FFFF ; $aa tan(
>018056	b4 80					.word NotImplemented       & $FFFF ; $ab atn(
>018058	b4 80					.word NotImplemented       & $FFFF ; $ac exp(
>01805a	b4 80					.word NotImplemented       & $FFFF ; $ad log(
>01805c	b4 80					.word NotImplemented       & $FFFF ; $ae sqr(
>01805e	34 8c					.word Unary_Dec            & $FFFF ; $af dec(
>018060	d1 89					.word Unary_Deek           & $FFFF ; $b0 deek(
>018062	d5 89					.word Unary_Leek           & $FFFF ; $b1 leek(
>018064	09 8a					.word Unary_Mod            & $FFFF ; $b2 mod(
>018066	5d 89					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>018068	9c 8c					.word Unary_Chr            & $FFFF ; $b4 chr$(
>01806a	b4 80					.word NotImplemented       & $FFFF ; $b5 $(
>01806c	b4 80					.word NotImplemented       & $FFFF ; $b6 $
>01806e	b4 80					.word NotImplemented       & $FFFF ; $b7 #(
>018070	b4 80					.word NotImplemented       & $FFFF ; $b8 #
>018072	b4 80					.word NotImplemented       & $FFFF ; $b9 %(
>018074	b4 80					.word NotImplemented       & $FFFF ; $ba %
>018076	b4 80					.word NotImplemented       & $FFFF ; $bb (
>018078	b4 80					.word NotImplemented       & $FFFF ; $bc )
>01807a	b4 80					.word NotImplemented       & $FFFF ; $bd ,
>01807c	b4 80					.word NotImplemented       & $FFFF ; $be :
>01807e	b4 80					.word NotImplemented       & $FFFF ; $bf ;
>018080	b4 80					.word NotImplemented       & $FFFF ; $c0 def
>018082	e4 84					.word CLR_Command          & $FFFF ; $c1 clr
>018084	b4 80					.word NotImplemented       & $FFFF ; $c3 data
>018086	b4 80					.word NotImplemented       & $FFFF ; $c4 read
>018088	b4 80					.word NotImplemented       & $FFFF ; $c5 dim
>01808a	b4 80					.word NotImplemented       & $FFFF ; $c6 to
>01808c	b4 80					.word NotImplemented       & $FFFF ; $c7 step
>01808e	b4 80					.word NotImplemented       & $FFFF ; $c8 gosub
>018090	b4 80					.word NotImplemented       & $FFFF ; $c9 return
>018092	b4 80					.word NotImplemented       & $FFFF ; $ca goto
>018094	c5 84					.word END_Command          & $FFFF ; $cb end
>018096	b4 80					.word NotImplemented       & $FFFF ; $cc input
>018098	b4 80					.word NotImplemented       & $FFFF ; $cd let
>01809a	b4 80					.word NotImplemented       & $FFFF ; $ce list
>01809c	b4 80					.word NotImplemented       & $FFFF ; $cf new
>01809e	b4 80					.word NotImplemented       & $FFFF ; $d0 old
>0180a0	b4 80					.word NotImplemented       & $FFFF ; $d1 on
>0180a2	b4 80					.word NotImplemented       & $FFFF ; $d2 restore
>0180a4	b4 80					.word NotImplemented       & $FFFF ; $d3 poke
>0180a6	b4 80					.word NotImplemented       & $FFFF ; $d4 print
>0180a8	b4 80					.word NotImplemented       & $FFFF ; $d5 run
>0180aa	ef 84					.word STOP_Command         & $FFFF ; $d6 stop
>0180ac	b4 80					.word NotImplemented       & $FFFF ; $d7 wait
>0180ae	b4 80					.word NotImplemented       & $FFFF ; $d8 doke
>0180b0	b4 80					.word NotImplemented       & $FFFF ; $d9 loke
>0180b2	c8 84					.word ASSERT_Command       & $FFFF ; $da assert
.0180b4					NotImplemented:
.0180b4	20 21 84	jsr $018421			jsr ERR_Handler
>0180b7	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>0180bf	65 6d 65 6e 74 65 64 00
.0180c7					BinaryPrecedence:
>0180c7	01					.byte 1    ; $80 and
>0180c8	01					.byte 1    ; $81 or
>0180c9	01					.byte 1    ; $82 xor
>0180ca	01					.byte 1    ; $83 eor
>0180cb	02					.byte 2    ; $84 =
>0180cc	02					.byte 2    ; $85 <>
>0180cd	02					.byte 2    ; $86 <
>0180ce	02					.byte 2    ; $87 <=
>0180cf	02					.byte 2    ; $88 >
>0180d0	02					.byte 2    ; $89 >=
>0180d1	03					.byte 3    ; $8a +
>0180d2	03					.byte 3    ; $8b -
>0180d3	04					.byte 4    ; $8c *
>0180d4	04					.byte 4    ; $8d /
>0180d5	05					.byte 5    ; $8e ^
.0180d6					KeywordText:
>0180d6	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>0180d9	4f d2					.byte $4f,$d2                          ; $81 or
>0180db	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>0180de	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>0180e1	bd					.byte $bd                              ; $84 =
>0180e2	3c be					.byte $3c,$be                          ; $85 <>
>0180e4	bc					.byte $bc                              ; $86 <
>0180e5	3c bd					.byte $3c,$bd                          ; $87 <=
>0180e7	be					.byte $be                              ; $88 >
>0180e8	3e bd					.byte $3e,$bd                          ; $89 >=
>0180ea	ab					.byte $ab                              ; $8a +
>0180eb	ad					.byte $ad                              ; $8b -
>0180ec	aa					.byte $aa                              ; $8c *
>0180ed	af					.byte $af                              ; $8d /
>0180ee	de					.byte $de                              ; $8e ^
>0180ef	49 c6					.byte $49,$c6                          ; $8f if
>0180f1	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>0180f6	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>0180fc	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>0180ff	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>018103	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>018108	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>01810c	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>018111	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>018115	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>018118	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>01811b	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>01811f	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>018123	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>018127	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>01812c	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>018130	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>018134	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>01813a	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>018141	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>018146	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>01814a	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>01814f	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>018153	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>018157	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>01815c	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>018160	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>018164	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>018168	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>01816c	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>018170	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>018174	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>018178	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>01817c	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>018181	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>018186	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>01818a	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>01818e	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>018193	24 a8					.byte $24,$a8                          ; $b5 $(
>018195	a4					.byte $a4                              ; $b6 $
>018196	23 a8					.byte $23,$a8                          ; $b7 #(
>018198	a3					.byte $a3                              ; $b8 #
>018199	25 a8					.byte $25,$a8                          ; $b9 %(
>01819b	a5					.byte $a5                              ; $ba %
>01819c	a8					.byte $a8                              ; $bb (
>01819d	a9					.byte $a9                              ; $bc )
>01819e	ac					.byte $ac                              ; $bd ,
>01819f	ba					.byte $ba                              ; $be :
>0181a0	bb					.byte $bb                              ; $bf ;
>0181a1	44 45 c6				.byte $44,$45,$c6                      ; $c0 def
>0181a4	43 4c d2				.byte $43,$4c,$d2                      ; $c1 clr
>0181a7	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c3 data
>0181ab	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c4 read
>0181af	44 49 cd				.byte $44,$49,$cd                      ; $c5 dim
>0181b2	54 cf					.byte $54,$cf                          ; $c6 to
>0181b4	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c7 step
>0181b8	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $c8 gosub
>0181bd	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $c9 return
>0181c3	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $ca goto
>0181c7	45 4e c4				.byte $45,$4e,$c4                      ; $cb end
>0181ca	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $cc input
>0181cf	4c 45 d4				.byte $4c,$45,$d4                      ; $cd let
>0181d2	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $ce list
>0181d6	4e 45 d7				.byte $4e,$45,$d7                      ; $cf new
>0181d9	4f 4c c4				.byte $4f,$4c,$c4                      ; $d0 old
>0181dc	4f ce					.byte $4f,$ce                          ; $d1 on
>0181de	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d2 restore
>0181e5	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d3 poke
>0181e9	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d4 print
>0181ee	52 55 ce				.byte $52,$55,$ce                      ; $d5 run
>0181f1	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $d6 stop
>0181f5	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d7 wait
>0181f9	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $d8 doke
>0181fd	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $d9 loke
>018201	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $da assert
>018207	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_dollarlparen = $b5
=$b6					token_dollar = $b6
=$b7					token_hashlparen = $b7
=$b8					token_hash = $b8
=$b9					token_percentlparen = $b9
=$ba					token_percent = $ba
=$bb					token_lparen = $bb
=$bc					token_rparen = $bc
=$bd					token_comma = $bd
=$be					token_colon = $be
=$bf					token_semicolon = $bf
=$c0					token_def = $c0
=$c1					token_clr = $c1
=$c3					token_data = $c3
=$c4					token_read = $c4
=$c5					token_dim = $c5
=$c6					token_to = $c6
=$c7					token_step = $c7
=$c8					token_gosub = $c8
=$c9					token_return = $c9
=$ca					token_goto = $ca
=$cb					token_end = $cb
=$cc					token_input = $cc
=$cd					token_let = $cd
=$ce					token_list = $ce
=$cf					token_new = $cf
=$d0					token_old = $d0
=$d1					token_on = $d1
=$d2					token_restore = $d2
=$d3					token_poke = $d3
=$d4					token_print = $d4
=$d5					token_run = $d5
=$d6					token_stop = $d6
=$d7					token_wait = $d7
=$d8					token_doke = $d8
=$d9					token_loke = $d9
=$da					token_assert = $da

;******  Return to file: modules/hardware/em65816.asm


;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.018208					IFT_ClearScreen:
.018208	48		pha				pha
.018209	da		phx				phx
.01820a	5a		phy				phy
.01820b	20 a4 83	jsr $0183a4			jsr 	IF_Home 					; home cursor
.01820e	a2 20		ldx #$20			ldx 	#IF_Height 					; this many lines.
.018210					_IFT_CS0:
.018210	a0 40		ldy #$40			ldy 	#IF_Width 					; this many chars/line
.018212					_IFT_CS1:
.018212	a9 20		lda #$20			lda 	#' '						; clear line.
.018214	20 d0 83	jsr $0183d0			jsr 	IF_Write
.018217	88		dey				dey
.018218	d0 f8		bne $018212			bne 	_IFT_CS1
.01821a	20 b7 83	jsr $0183b7			jsr 	IF_NewLine 					; next line down
.01821d	ca		dex				dex
.01821e	d0 f0		bne $018210			bne 	_IFT_CS0
.018220	7a		ply				ply
.018221	fa		plx				plx
.018222	68		pla				pla
.018223					IFT_HomeCursor:
.018223	48		pha				pha
.018224	20 a4 83	jsr $0183a4			jsr 	IF_Home
.018227	a9 00		lda #$00			lda 	#0
.018229	8d 00 02	sta $0200			sta 	IFT_XCursor
.01822c	8d 01 02	sta $0201			sta 	IFT_YCursor
.01822f	68		pla				pla
.018230	60		rts				rts
.018231					IFT_UpLine:
.018231	48		pha				pha
.018232	ad 01 02	lda $0201			lda  	IFT_YCursor 				; get Y
.018235	3a		dec a				dec 	a 							; line above
.018236	30 03		bmi $01823b			bmi 	_IFTULExit 					; too far, abort
.018238	20 c6 82	jsr $0182c6			jsr 	IFT_SetYPos					; set to that line.
.01823b					_IFTULExit:
.01823b	68		pla				pla
.01823c	60		rts				rts
.01823d					IFT_PrintCharacter:
.01823d	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.01823f	f0 16		beq $018257			beq 	IFT_NewLine
.018241	48		pha				pha
.018242	20 6f 82	jsr $01826f			jsr 	IFT_UpperCase 				; make upper case
.018245	20 d0 83	jsr $0183d0			jsr 	IF_Write 					; write out.
.018248	ee 00 02	inc $0200			inc 	IFT_XCursor 				; bump x cursor
.01824b	ad 00 02	lda $0200			lda 	IFT_XCursor 				; reached RHS ?
.01824e	c9 40		cmp #$40			cmp 	#IF_Width
.018250	d0 03		bne $018255			bne 	_IFT_PCNotEOL
.018252	20 57 82	jsr $018257			jsr 	IFT_NewLine 				; if so do new line.
.018255					_IFT_PCNotEOL:
.018255	68		pla				pla
.018256	60		rts				rts
.018257					IFT_NewLine:
.018257	48		pha				pha
.018258	20 b7 83	jsr $0183b7			jsr 	IF_NewLine 					; new line on actual screen.
.01825b	a9 00		lda #$00			lda 	#0 							; reset x position
.01825d	8d 00 02	sta $0200			sta 	IFT_XCursor
.018260	ee 01 02	inc $0201			inc 	IFT_YCursor 				; move down.
.018263	ad 01 02	lda $0201			lda 	IFT_YCursor
.018266	c9 20		cmp #$20			cmp 	#IF_Height 					; reached bottom.
.018268	d0 03		bne $01826d			bne 	_IFT_NL_NotEOS
.01826a	20 7a 82	jsr $01827a			jsr 	IFT_Scroll 					; scroll screen up.
.01826d					_IFT_NL_NotEOS:
.01826d	68		pla				pla
.01826e	60		rts				rts
.01826f					IFT_UpperCase:
.01826f	c9 61		cmp #$61			cmp 	#"a"
.018271	90 06		bcc $018279			bcc 	_IFT_UCExit
.018273	c9 7b		cmp #$7b			cmp 	#"z"+1
.018275	b0 02		bcs $018279			bcs 	_IFT_UCExit
.018277	49 20		eor #$20			eor 	#$20
.018279					_IFT_UCExit:
.018279	60		rts				rts
.01827a					IFT_Scroll:
.01827a	48		pha				pha 								; save AXY
.01827b	da		phx				phx
.01827c	5a		phy				phy
.01827d	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.01827f					_IFT_SLoop:
.01827f	20 9f 82	jsr $01829f			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.018282	e8		inx				inx
.018283	e0 1f		cpx #$1f			cpx 	#IF_Height-1				; do whole screen
.018285	d0 f8		bne $01827f			bne 	_IFT_SLoop
.018287	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.018289	20 c6 82	jsr $0182c6			jsr 	IFT_SetYPos
.01828c	a2 40		ldx #$40			ldx 	#IF_Width 					; blank line
.01828e					_IFT_SBlank:
.01828e	a9 20		lda #$20			lda 	#32
.018290	20 d0 83	jsr $0183d0			jsr 	IF_Write
.018293	ca		dex				dex
.018294	d0 f8		bne $01828e			bne 	_IFT_SBlank
.018296	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.018298	20 c6 82	jsr $0182c6			jsr 	IFT_SetYPos
.01829b	7a		ply				ply
.01829c	fa		plx				plx
.01829d	68		pla				pla
.01829e	60		rts				rts
.01829f					_IFT_ScrollLine:
.01829f	da		phx				phx
.0182a0	da		phx				phx
.0182a1	8a		txa				txa 								; copy line into buffer.
.0182a2	1a		inc a				inc 	a 							; next line down.
.0182a3	20 c6 82	jsr $0182c6			jsr 	IFT_SetYPos
.0182a6	a2 00		ldx #$00			ldx 	#0
.0182a8					_IFTScrollCopy1:
.0182a8	20 c7 83	jsr $0183c7			jsr 	IF_Read
.0182ab	9d 02 02	sta $0202,x			sta 	IFT_Buffer,x
.0182ae	e8		inx				inx
.0182af	e0 40		cpx #$40			cpx 	#IF_Width
.0182b1	d0 f5		bne $0182a8			bne 	_IFTScrollCopy1
.0182b3	68		pla				pla
.0182b4	20 c6 82	jsr $0182c6			jsr 	IFT_SetYPos
.0182b7	a2 00		ldx #$00			ldx 	#0
.0182b9					_IFTScrollCopy2:
.0182b9	bd 02 02	lda $0202,x			lda 	IFT_Buffer,x
.0182bc	20 d0 83	jsr $0183d0			jsr 	IF_Write
.0182bf	e8		inx				inx
.0182c0	e0 40		cpx #$40			cpx 	#IF_Width
.0182c2	d0 f5		bne $0182b9			bne 	_IFTScrollCopy2
.0182c4	fa		plx				plx
.0182c5	60		rts				rts
.0182c6					IFT_SetYPos:
.0182c6	48		pha				pha
.0182c7	da		phx				phx
.0182c8	aa		tax				tax
.0182c9	20 23 82	jsr $018223			jsr 	IFT_HomeCursor
.0182cc	e0 00		cpx #$00			cpx 	#0
.0182ce	f0 09		beq $0182d9			beq 	_IFT_MOAExit
.0182d0					_IFT_MOALoop:
.0182d0	20 b7 83	jsr $0183b7			jsr 	IF_NewLine
.0182d3	ee 01 02	inc $0201			inc 	IFT_YCursor
.0182d6	ca		dex				dex
.0182d7	d0 f7		bne $0182d0			bne		_IFT_MOALoop
.0182d9					_IFT_MOAExit:
.0182d9	fa		plx				plx
.0182da	68		pla				pla
.0182db	60		rts				rts
.0182dc					IFT_GetKeyCursor:
.0182dc	20 e4 82	jsr $0182e4			jsr 	_IFT_FlipCursor 			; reverse current
.0182df					_IFT_GKCWait:
.0182df	20 e1 83	jsr $0183e1			jsr 	IF_GetKey 					; get key
.0182e2	f0 fb		beq $0182df			beq 	_IFT_GKCWait
.0182e4					_IFT_FlipCursor:
.0182e4	48		pha				pha 								; save
.0182e5	20 c7 83	jsr $0183c7			jsr 	IF_Read 					; read
.0182e8	20 d9 83	jsr $0183d9			jsr 	IF_LeftOne
.0182eb	49 80		eor #$80			eor 	#$80 						; reverse
.0182ed	20 d0 83	jsr $0183d0			jsr 	IF_Write 					; write
.0182f0	20 d9 83	jsr $0183d9			jsr 	IF_LeftOne
.0182f3	68		pla				pla
.0182f4	60		rts				rts
.0182f5					IFT_ReadLine:
.0182f5	48		pha				pha
.0182f6					_IFT_RLLoop:
.0182f6	20 dc 82	jsr $0182dc			jsr 	IFT_GetKeyCursor 			; get keystroke
.0182f9	c9 0d		cmp #$0d			cmp 	#13							; return
.0182fb	f0 7d		beq $01837a			beq 	_IFT_RLExit
.0182fd	c9 20		cmp #$20			cmp 	#32 						; control character
.0182ff	90 05		bcc $018306			bcc 	_IFT_Control
.018301	20 3d 82	jsr $01823d			jsr 	IFT_PrintCharacter
.018304	80 f0		bra $0182f6			bra 	_IFT_RLLoop
.018306					_IFT_Control:
.018306	c9 01		cmp #$01			cmp 	#"A"-64
.018308	f0 26		beq $018330			beq 	_IFT_Left
.01830a	c9 04		cmp #$04			cmp 	#"D"-64
.01830c	f0 2e		beq $01833c			beq 	_IFT_Right
.01830e	c9 17		cmp #$17			cmp 	#"W"-64
.018310	f0 36		beq $018348			beq 	_IFT_Up
.018312	c9 13		cmp #$13			cmp 	#"S"-64
.018314	f0 3e		beq $018354			beq 	_IFT_Down
.018316	c9 08		cmp #$08			cmp 	#"H"-64
.018318	f0 09		beq $018323			beq 	_IFT_Backspace
.01831a	c9 1a		cmp #$1a			cmp 	#"Z"-64
.01831c	d0 d8		bne $0182f6			bne 	_IFT_RLLoop
.01831e	20 08 82	jsr $018208			jsr 	IFT_ClearScreen				; clear CTL-Z
.018321	80 d3		bra $0182f6			bra 	_IFT_RLLoop
.018323					_IFT_Backspace:
.018323	ad 00 02	lda $0200			lda 	IFT_XCursor 				; check not start of line.
.018326	f0 ce		beq $0182f6			beq 	_IFT_RLLoop
.018328	20 d9 83	jsr $0183d9			jsr 	IF_LeftOne
.01832b	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.01832d	20 d0 83	jsr $0183d0			jsr 	IF_Write
.018330					_IFT_Left:
.018330	ce 00 02	dec $0200			dec 	IFT_XCursor 				; left CTL-W
.018333	10 29		bpl $01835e			bpl 	_IFT_Reposition
.018335	a9 3f		lda #$3f			lda 	#IF_Width-1
.018337					_IFT_SetX:
.018337	8d 00 02	sta $0200			sta 	IFT_XCursor
.01833a	80 22		bra $01835e			bra 	_IFT_Reposition
.01833c					_IFT_Right:
.01833c	ee 00 02	inc $0200			inc 	IFT_XCursor
.01833f	ad 00 02	lda $0200			lda 	IFT_XCursor
.018342	49 40		eor #$40			eor 	#IF_Width
.018344	f0 f1		beq $018337			beq 	_IFT_SetX
.018346	80 16		bra $01835e			bra 	_IFT_Reposition
.018348					_IFT_Up:
.018348	ce 01 02	dec $0201			dec 	IFT_YCursor
.01834b	10 11		bpl $01835e			bpl 	_IFT_Reposition
.01834d	a9 1f		lda #$1f			lda 	#IF_Height-1
.01834f					_IFT_SetY:
.01834f	8d 01 02	sta $0201			sta 	IFT_YCursor
.018352	80 0a		bra $01835e			bra 	_IFT_Reposition
.018354					_IFT_Down:
.018354	ee 01 02	inc $0201			inc 	IFT_YCursor
.018357	ad 01 02	lda $0201			lda 	IFT_YCursor
.01835a	49 20		eor #$20			eor 	#IF_Height
.01835c	f0 f1		beq $01834f			beq 	_IFT_SetY
.01835e					_IFT_Reposition:
.01835e	ad 00 02	lda $0200			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.018361	48		pha				pha
.018362	ad 01 02	lda $0201			lda 	IFT_YCursor
.018365	20 c6 82	jsr $0182c6			jsr 	IFT_SetYPos
.018368	68		pla				pla
.018369	aa		tax				tax
.01836a	e0 00		cpx #$00			cpx 	#0
.01836c	f0 88		beq $0182f6			beq 	_IFT_RLLoop
.01836e					_IFT_MoveRight:
.01836e	20 c7 83	jsr $0183c7			jsr 	IF_Read
.018371	ee 00 02	inc $0200			inc 	IFT_XCursor
.018374	ca		dex				dex
.018375	d0 f7		bne $01836e			bne 	_IFT_MoveRight
.018377	4c f6 82	jmp $0182f6			jmp 	_IFT_RLLoop
.01837a					_IFT_RLExit:
.01837a	ad 01 02	lda $0201			lda 	IFT_YCursor 				; go to start of line.
.01837d	20 c6 82	jsr $0182c6			jsr 	IFT_SetYPos
.018380	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.018382					_IFT_RLRead:
.018382	20 c7 83	jsr $0183c7			jsr 	IF_Read
.018385	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.018388	e8		inx				inx
.018389	e0 40		cpx #$40			cpx 	#IF_Width
.01838b	d0 f5		bne $018382			bne 	_IFT_RLRead
.01838d					_IFT_RL_Trim:
.01838d	ca		dex				dex 	 							; previous char
.01838e	30 07		bmi $018397			bmi 	_IFT_Found 					; gone too far
.018390	bd 66 02	lda $0266,x			lda 	IFT_LineBuffer,x			; go back if space
.018393	c9 20		cmp #$20			cmp 	#" "
.018395	f0 f6		beq $01838d			beq 	_IFT_RL_Trim
.018397					_IFT_Found:
.018397	e8		inx				inx 								; forward to non-space
.018398	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.01839a	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.01839d	68		pla				pla
.01839e	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.0183a0	a0 02		ldy #$02			ldy 	#IFT_LineBuffer >> 8
.0183a2	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_em65816.asm

=64					IF_Width 	= 64 							; characters across
=32					IF_Height 	= 32 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line.
=8					IF_XPos 	= 8 							; current position, horizontal.
=$f0000					IF_Screen = $F0000							; 2k screen RAM here
=$f8010					IF_PKeyboard = $F8010						; Keyboard port.
=$f8000					IF_PBreak = $F8000 							; Break key.
.0183a3					IF_Reset:
.0183a3	60		rts				rts
.0183a4					IF_Home:
.0183a4	48		pha				pha
.0183a5	64 08		stz $08				stz 	IF_XPos 					; zero X position
.0183a7	a9 00		lda #$00			lda 	#IF_Screen & $FF 			; set r/w pos.
.0183a9	85 04		sta $04				sta 	IF_Pos
.0183ab	a9 00		lda #$00			lda 	#(IF_Screen >> 8) & $FF
.0183ad	85 05		sta $05				sta 	IF_Pos+1
.0183af	a9 0f		lda #$0f			lda 	#IF_Screen >> 16
.0183b1	85 06		sta $06				sta 	IF_Pos+2
.0183b3	64 07		stz $07				stz 	IF_Pos+3
.0183b5	68		pla				pla
.0183b6	60		rts				rts
.0183b7					IF_NewLine:
.0183b7	48		pha				pha
.0183b8	64 08		stz $08				stz 	IF_XPos						; back to start of line
.0183ba	18		clc				clc 								; down one line
.0183bb	a5 04		lda $04				lda 	IF_Pos
.0183bd	69 40		adc #$40			adc 	#64
.0183bf	85 04		sta $04				sta 	IF_Pos
.0183c1	90 02		bcc $0183c5			bcc 	_IF_NoCarry 				; carry through.
.0183c3	e6 05		inc $05				inc 	IF_Pos+1
.0183c5					_IF_NoCarry:
.0183c5	68		pla				pla
.0183c6	60		rts				rts
.0183c7					IF_Read:
.0183c7	5a		phy				phy 								; save current Y
.0183c8	a4 08		ldy $08				ldy 	IF_XPos 					; read character at current position
.0183ca	b7 04		lda [$04],y			lda 	[IF_Pos],y
.0183cc	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0183ce	7a		ply				ply									; restore Y
.0183cf	60		rts				rts
.0183d0					IF_Write:
.0183d0	5a		phy				phy 								; save current Y
.0183d1	a4 08		ldy $08				ldy 	IF_XPos 					; write character at current position
.0183d3	97 04		sta [$04],y			sta 	[IF_Pos],y
.0183d5	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0183d7	7a		ply				ply									; restore Y
.0183d8	60		rts				rts
.0183d9					IF_LeftOne:
.0183d9	c6 08		dec $08				dec 	IF_XPos
.0183db	60		rts				rts
.0183dc					IF_CheckBreak:
.0183dc	af 00 80 0f	lda $0f8000			lda 	IF_PBreak					; non-zero if Ctrl+C pressed.
.0183e0	60		rts				rts
.0183e1					IF_GetKey:
.0183e1	af 10 80 0f	lda $0f8010			lda 	IF_PKeyboard				; read keyboard
.0183e5	f0 08		beq $0183ef			beq		_IFGK_NoKey 				; skip if zero,no key pressed
.0183e7	48		pha				pha 								; key pressed, clear queue.
.0183e8	a9 00		lda #$00			lda 	#0
.0183ea	8f 10 80 0f	sta $0f8010			sta 	IF_PKeyboard
.0183ee	68		pla				pla
.0183ef					_IFGK_NoKey:
.0183ef	09 00		ora #$00			ora 	#0							; set Z flag appropriately.
.0183f1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/errors.asm

.0183f2					SyntaxError:
.0183f2	20 21 84	jsr $018421			jsr 	ERR_Handler
>0183f5	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>0183fd	72 72 6f 72 00
.018402					TypeError:
.018402	20 21 84	jsr $018421			jsr 	ERR_Handler
>018405	57 72 6f 6e 67 20 74 79				.text 	"Wrong type",0
>01840d	70 65 00
.018410					BadParamError:
.018410	20 21 84	jsr $018421			jsr 	ERR_Handler
>018413	42 61 64 20 50 61 72 61				.text 	"Bad Parameter",0
>01841b	6d 65 74 65 72 00
.018421					ERR_Handler:
.018421	a0 00		ldy #$00			ldy 	#0
.018423	c8		iny				iny
.018424	b1 16		lda ($16),y			lda 	(zCodePtr),y
.018426	8d 08 03	sta $0308			sta 	XS_Mantissa
.018429	c8		iny				iny
.01842a	b1 16		lda ($16),y			lda 	(zCodePtr),y
.01842c	8d 09 03	sta $0309			sta 	XS_Mantissa+1
.01842f	fa		plx				plx 								; address in XY
.018430	7a		ply				ply
.018431	e8		inx				inx 								; bump, because of RTS/JSR address -1
.018432	d0 01		bne $018435			bne 	_EHNoSkip
.018434	c8		iny				iny
.018435					_EHNoSkip:
.018435	20 54 84	jsr $018454			jsr 	PrintROMMessage 			; print message from ROM.
.018438	ad 08 03	lda $0308			lda 	XS_Mantissa					; line number = 0
.01843b	0d 09 03	ora $0309			ora 	XS_Mantissa+1
.01843e	f0 0c		beq $01844c			beq 	_EHNoLine
.018440	a2 4f		ldx #$4f			ldx 	#_EHAt & $FF 				; print " at "
.018442	a0 84		ldy #$84			ldy 	#(_EHAt >> 8) & $FF
.018444	20 54 84	jsr $018454			jsr 	PrintROMMessage
.018447	a2 00		ldx #$00			ldx 	#0 							; Print line number
.018449	20 69 84	jsr $018469			jsr 	Print16BitInteger
.01844c					_EHNoLine:
.01844c	4c a2 84	jmp $0184a2			jmp 	WarmStart
>01844f	20 61 74 20 00			_EHAt:	.text 	" at ",0
.018454					PrintROMMessage:
.018454	86 1a		stx $1a				stx 	zLTemp1 					; save addres
.018456	84 1b		sty $1b				sty 	zLTemp1+1
.018458	4b		phk				phk
.018459	68		pla				pla
.01845a	85 1c		sta $1c				sta 	ZLTemp1+2
.01845c	a0 00		ldy #$00			ldy 	#0
.01845e					_PRMLoop:
.01845e	b7 1a		lda [$1a],y			lda 	[zLTemp1],y
.018460	f0 06		beq $018468			beq		_PRMExit
.018462	c8		iny				iny
.018463	20 3d 82	jsr $01823d			jsr 	IFT_PrintCharacter
.018466	80 f6		bra $01845e			bra 	_PRMLoop
.018468					_PRMExit:
.018468	60		rts				rts
.018469					Print16BitInteger:
.018469	a9 00		lda #$00			lda 	#0 							; make 32 bit
.01846b	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01846e	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018471	20 a8 8e	jsr $018ea8			jsr 	INTToString 				; make string
.018474	a2 00		ldx #$00			ldx 	#0 							; print buffer
.018476	bd 00 04	lda $0400,x	_P1Loop:lda 	Num_Buffer,x
.018479	f0 06		beq $018481			beq 	_P1Exit
.01847b	20 3d 82	jsr $01823d			jsr 	IFT_PrintCharacter
.01847e	e8		inx				inx
.01847f	80 f5		bra $018476			bra 	_P1Loop
.018481	60		rts		_P1Exit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm

.018482					BASIC_Start:
.018482	20 a3 83	jsr $0183a3			jsr 	IF_Reset 					; set up and clear screen.
.018485	20 08 82	jsr $018208			jsr 	IFT_ClearScreen
.018488	a9 5c		lda #$5c			lda 	#$5C 						; JMP Long opcode
.01848a	8d 04 03	sta $0304			sta 	LocalVector
.01848d	8d 00 03	sta $0300			sta 	UserVector
.018490	a9 51		lda #$51			lda 	#USRDefault & $FF 			; reset USR vector
.018492	8d 01 03	sta $0301			sta 	UserVector+1
.018495	a9 8a		lda #$8a			lda 	#(USRDefault >> 8) & $FF
.018497	8d 02 03	sta $0302			sta 	UserVector+2
.01849a	a9 01		lda #$01			lda 	#(USRDefault >> 16) & $FF
.01849c	8d 03 03	sta $0303			sta 	UserVector+3
.01849f	20 e4 84	jsr $0184e4			jsr 	ResetRunStatus 				; clear everything (CLR command)
.0184a2					WarmStart:
.0184a2	c2 30		rep #$30			rep 	#$30
.0184a4	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.0184a7	1b		tcs				tcs
.0184a8	e2 30		sep #$30			sep 	#$30
.0184aa	a9 00		lda #$00			lda 	#0 							; mark temp string pointer uninitialised.
.0184ac	85 21		sta $21				sta 	zTempStr+1 					; (done before every base level evaluation/or command)
.0184ae	a9 00		lda #$00			lda 	#BasicProgram & $FF
.0184b0	85 16		sta $16				sta 	zCodePtr+0
.0184b2	a9 10		lda #$10			lda 	#BasicProgram >> 8
.0184b4	85 17		sta $17				sta 	zCodePtr+1
.0184b6	a9 00		lda #$00			lda 	#0
.0184b8	85 18		sta $18				sta 	zCodePtr+2
.0184ba	85 19		sta $19				sta 	zCodePtr+3
.0184bc	a0 03		ldy #$03			ldy 	#3
.0184be	c8		iny				iny
.0184bf	b1 16		lda ($16),y			lda 	(zCodePtr),y
.0184c1	20 fa 84	jsr $0184fa			jsr 	EvaluateExpression
>0184c4	02						.byte 	2

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/end.asm

.0184c5					END_Command:
.0184c5	4c a2 84	jmp $0184a2			jmp 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/assert.asm

.0184c8					ASSERT_Command:
.0184c8	20 98 86	jsr $018698			jsr 	EvaluateNumber 				; calculate thing being asserted
.0184cb	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; check if true (non-zero)
.0184ce	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.0184d1	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.0184d4	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.0184d7	f0 01		beq $0184da			beq 	_ASFail
.0184d9	60		rts				rts
.0184da					_ASFail:
.0184da	20 21 84	jsr $018421			jsr ERR_Handler
>0184dd	41 73 73 65 72 74 00			.text "Assert",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.0184e4					CLR_Command:
.0184e4					ResetRunStatus:
.0184e4	a9 00		lda #$00			lda 	#HighMemory & $FF
.0184e6	8d 26 04	sta $0426			sta 	StringPtr
.0184e9	a9 80		lda #$80			lda 	#HighMemory >> 8
.0184eb	8d 27 04	sta $0427			sta 	StringPtr+1
.0184ee	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/stop.asm

.0184ef					STOP_Command:
.0184ef	20 21 84	jsr $018421			jsr ERR_Handler
>0184f2	53 74 6f 70 00				.text "Stop",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.0184f7					EVESyntax:
.0184f7	4c f2 83	jmp $0183f2			jmp 	SyntaxError
.0184fa					EvaluateExpression:
.0184fa	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.0184fc					EvaluateExpressionX:
.0184fc	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.0184fe					EvaluateExpressionXA:
.0184fe	48		pha				pha 								; save precedence on stack.
.0184ff	b1 16		lda ($16),y			lda 	(zCodePtr),y
.018501	f0 f4		beq $0184f7			beq 	EVESyntax 					; end of line, syntax error.
.018503	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.018505	b0 03		bcs $01850a			bcs 	_EVNotVariable
.018507	4c 04 86	jmp $018604			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.01850a					_EVNotVariable:
.01850a	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.01850c	90 e9		bcc $0184f7			bcc 	EVESyntax
.01850e	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.018510	b0 7f		bcs $018591			bcs 	_EVNotInteger
.018512	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.018514	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.018517	a9 00		lda #$00			lda 	#0
.018519	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.01851c	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01851f	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018522	1a		inc a				inc 	a 							; set to type 1 (integer)
.018523	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018526					_EVCheckNextInteger:
.018526	c8		iny				iny
.018527	b1 16		lda ($16),y			lda 	(zCodePtr),y
.018529	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.01852b	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.01852d	b0 0d		bcs $01853c			bcs 	_EVCheckDecimal
.01852f	48		pha				pha 								; save it.
.018530	20 05 86	jsr $018605			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.018533	68		pla				pla
.018534	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.018537	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.01853a	80 ea		bra $018526			bra 	_EVCheckNextInteger
.01853c					_EVCheckDecimal:
.01853c	b1 16		lda ($16),y			lda 	(zCodePtr),y
.01853e	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.018540	d0 05		bne $018547			bne 	_EVGotAtom 					; no, get atom.
.018542					_EVIsDecimal:
.018542	20 35 86	jsr $018635			jsr 	EVGetDecimal 				; extend to the decimal part.
.018545	80 00		bra $018547			bra 	_EVGotAtom 					; and continue to got atom.
.018547					_EVGotAtom:
.018547	b1 16		lda ($16),y			lda 	(zCodePtr),y
.018549	10 44		bpl $01858f			bpl 	_EVExitDrop 				; must be a token.
.01854b	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.01854d	b0 40		bcs $01858f			bcs 	_EVExitDrop
.01854f	68		pla				pla 								; get current precedence
.018550	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.018552	da		phx				phx 								; save X
.018553	b1 16		lda ($16),y			lda 	(zCodePtr),y
.018555	aa		tax				tax 								; put in X
.018556	bf 47 80 01	lda $018047,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.01855a	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.01855c	fa		plx				plx 								; restore X
.01855d	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.01855f	90 2f		bcc $018590			bcc 	_EVExit 					; exit if too low.
.018561	f0 2d		beq $018590			beq 	_EVExit 					; exit if equals
.018563	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.018565	48		pha				pha
.018566	b1 16		lda ($16),y			lda 	(zCodePtr),y
.018568	48		pha				pha
.018569	c8		iny				iny
.01856a	da		phx				phx 								; save current position
.01856b	e8		inx				inx
.01856c	e8		inx				inx
.01856d	e8		inx				inx
.01856e	e8		inx				inx
.01856f	e8		inx				inx
.018570	e8		inx				inx
.018571	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.018573	20 fe 84	jsr $0184fe			jsr 	EvaluateExpressionXA 		; do the RHS.
.018576	fa		plx				plx 								; restore X
.018577	68		pla				pla 								; get the binary operator in A.
.018578					_EVCallA:
.018578	da		phx				phx 								; save X again
.018579	0a		asl a				asl 	a 							; double, lose the MSB.
.01857a	aa		tax				tax									; put in X
.01857b	bf 00 80 01	lda $018000,x			lda 	VectorTable,x 				; copy address into zGenPtr
.01857f	8d 05 03	sta $0305			sta 	LocalVector+1
.018582	bf 01 80 01	lda $018001,x			lda 	VectorTable+1,x
.018586	8d 06 03	sta $0306			sta 	LocalVector+2
.018589	fa		plx				plx 								; restore X
.01858a	20 01 86	jsr $018601			jsr 	_EVCallLocalVector
.01858d	80 b8		bra $018547			bra 	_EVGotAtom 					; and loop back.
.01858f					_EVExitDrop:
.01858f	68		pla				pla
.018590					_EVExit:
.018590	60		rts				rts
.018591					_EVNotInteger:
.018591	c8		iny				iny
.018592	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.018594	d0 19		bne $0185af			bne 	_EVNotMinus
.018596	20 86 86	jsr $018686			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.018599	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.01859c	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.01859e	f0 05		beq $0185a5			beq 	_EVMinusFloat
.0185a0	20 83 8e	jsr $018e83			jsr 	IntegerNegateAlways 		; negation
.0185a3	80 a2		bra $018547			bra 	_EVGotAtom 					; and go back.
.0185a5					_EVMinusFloat:
.0185a5	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; invert the sign bit.
.0185a8	49 80		eor #$80			eor 	#$80
.0185aa	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0185ad	80 98		bra $018547			bra 	_EVGotAtom
.0185af					_EVNotMinus:
.0185af	c9 bb		cmp #$bb			cmp 	#token_lparen 				; is it left parenthesis
.0185b1	d0 17		bne $0185ca			bne 	_EVNotParenthesis
.0185b3	20 fc 84	jsr $0184fc			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.0185b6	b1 16		lda ($16),y			lda 	(zCodePtr),y
.0185b8	c8		iny				iny
.0185b9	c9 bc		cmp #$bc			cmp 	#token_rparen 				; okay if right bracket.
.0185bb	f0 8a		beq $018547			beq 	_EVGotAtom
.0185bd	20 21 84	jsr $018421			jsr ERR_Handler
>0185c0	4d 69 73 73 69 6e 67 20			.text "Missing )",0
>0185c8	29 00
.0185ca					_EVNotParenthesis:
.0185ca	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.0185cc	d0 0c		bne $0185da			bne 	_EVNotNot
.0185ce	20 86 86	jsr $018686			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.0185d1	20 8f 93	jsr $01938f			jsr 	FPUToInteger 				; make it an integer - if possible.
.0185d4	20 63 86	jsr $018663			jsr 	NotInteger 					; do the not calculation
.0185d7	4c 47 85	jmp $018547			jmp 	_EVGotAtom
.0185da					_EVNotNot:
.0185da	c9 fe		cmp #$fe			cmp 	#$FE
.0185dc	d0 15		bne $0185f3			bne 	_EVNotString
.0185de	20 71 8d	jsr $018d71			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.0185e1	a5 20		lda $20				lda 	zTempStr 					; copy address of string into mantissa
.0185e3	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0185e6	a5 21		lda $21				lda 	zTempStr+1
.0185e8	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0185eb	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.0185ed	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0185f0	4c 47 85	jmp $018547			jmp 	_EVGotAtom
.0185f3					_EVNotString:
.0185f3	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.0185f5	90 04		bcc $0185fb			bcc 	_EVBadElement
.0185f7	c9 b5		cmp #$b5			cmp 	#lastUnaryFunction+1
.0185f9	90 03		bcc $0185fe			bcc 	_EVUnaryFunction
.0185fb					_EVBadElement:
.0185fb	4c f2 83	jmp $0183f2			jmp 	SyntaxError
.0185fe					_EVUnaryFunction:
.0185fe	4c 78 85	jmp $018578			jmp 	_EVCallA
.018601					_EVCallLocalVector:
.018601	6c 05 03	jmp ($0305)			jmp 	(LocalVector+1)
.018604					_EVVariableHandler:
.018604	ea		nop				nop
.018605					EVShiftMantissaLeft6:
.018605	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.018608	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.01860b	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.01860e	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018611	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018614	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018617	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.01861a	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.01861d	a9 00		lda #$00			lda 	#0
.01861f	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018622	20 25 86	jsr $018625			jsr 	_EVSMLShift 					; call it here to do it twice
.018625					_EVSMLShift:
.018625	5e 0c 03	lsr $030c,x			lsr 	XS_Exponent,x
.018628	7e 0b 03	ror $030b,x			ror 	XS_Mantissa+3,x
.01862b	7e 0a 03	ror $030a,x			ror 	XS_Mantissa+2,x
.01862e	7e 09 03	ror $0309,x			ror 	XS_Mantissa+1,x
.018631	7e 08 03	ror $0308,x			ror 	XS_Mantissa+0,x
.018634	60		rts				rts
.018635					EVGetDecimal:
.018635	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.018637	8d 00 04	sta $0400			sta 	Num_Buffer
.01863a	da		phx				phx
.01863b	c8		iny				iny
.01863c	b1 16		lda ($16),y			lda 	(zCodePtr),y
.01863e	c8		iny				iny
.01863f	3a		dec a				dec 	a								; convert to a string length.
.018640	3a		dec a				dec 	a
.018641	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.018643					_EVGDCopy:
.018643	48		pha				pha 									; save count
.018644	b1 16		lda ($16),y			lda 	(zCodePtr),y
.018646	9d 00 04	sta $0400,x			sta 	Num_Buffer,x
.018649	e8		inx				inx 									; forward ....
.01864a	c8		iny				iny
.01864b	68		pla				pla 									; get count
.01864c	3a		dec a				dec 	a 								; until zero
.01864d	d0 f4		bne $018643			bne 	_EVGDCopy
.01864f	9d 00 04	sta $0400,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.018652	fa		plx				plx 									; restore X
.018653	a9 00		lda #$00			lda 	#Num_Buffer & $FF 				; set zGenPtr
.018655	85 1e		sta $1e				sta 	zGenPtr
.018657	a9 04		lda #$04			lda 	#Num_Buffer >> 8
.018659	85 1f		sta $1f				sta 	zGenPtr+1
.01865b	5a		phy				phy 									; save Y
.01865c	a0 00		ldy #$00			ldy 	#0 								; start position
.01865e	20 81 95	jsr $019581			jsr 	FPFromString 					; convert current
.018661	7a		ply				ply 									; restore Y
.018662	60		rts				rts
.018663					NotInteger:
.018663	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018666	49 ff		eor #$ff			eor 	#$FF
.018668	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.01866b	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.01866e	49 ff		eor #$ff			eor 	#$FF
.018670	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018673	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018676	49 ff		eor #$ff			eor 	#$FF
.018678	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01867b	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.01867e	49 ff		eor #$ff			eor 	#$FF
.018680	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018683	60		rts				rts
.018684					EvaluateGetAtom:
.018684	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.018686					EvaluateGetAtomX:
.018686	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.018688	20 fe 84	jsr $0184fe			jsr 	EvaluateExpressionXA
.01868b	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.01868e	29 0f		and #$0f			and 	#15
.018690	c9 02		cmp #$02			cmp 	#2
.018692	b0 01		bcs $018695			bcs 	EvaluateType
.018694	60		rts				rts
.018695					EvaluateType:
.018695	4c 02 84	jmp $018402			jmp 	TypeError
.018698					EvaluateNumber:
.018698	a2 00		ldx #$00			ldx 	#0
.01869a					EvaluateNumberX:
.01869a	20 fc 84	jsr $0184fc			jsr 	EvaluateExpressionX
.01869d	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 0/1
.0186a0	29 0f		and #$0f			and 	#15
.0186a2	c9 02		cmp #$02			cmp 	#2
.0186a4	b0 ef		bcs $018695			bcs 	EvaluateType
.0186a6	60		rts				rts
.0186a7					EvaluateInteger:
.0186a7	a2 00		ldx #$00			ldx 	#0
.0186a9					EvaluateIntegerX:
.0186a9	20 9a 86	jsr $01869a			jsr 	EvaluateNumberX
.0186ac	20 8f 93	jsr $01938f			jsr 	FPUToInteger
.0186af	60		rts				rts
.0186b0					EvaluateString:
.0186b0	a2 00		ldx #$00			ldx 	#0
.0186b2					EvaluateStringX:
.0186b2	20 fc 84	jsr $0184fc			jsr 	EvaluateExpressionX
.0186b5	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 2
.0186b8	29 0f		and #$0f			and 	#15
.0186ba	c9 02		cmp #$02			cmp 	#2
.0186bc	d0 d7		bne $018695			bne 	EvaluateType
.0186be	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.0186c1	85 1e		sta $1e				sta 	zGenPtr
.0186c3	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0186c6	85 1f		sta $1f				sta 	zGenPtr+1
.0186c8	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.0186c9					BinaryOp_And:
.0186c9	20 41 87	jsr $018741			jsr 	BinaryMakeBothInteger
.0186cc	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.0186cf	3d 0e 03	and $030e,x			and 	XS2_Mantissa+0,x
.0186d2	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0186d5	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.0186d8	3d 0f 03	and $030f,x			and 	XS2_Mantissa+1,x
.0186db	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0186de	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.0186e1	3d 10 03	and $0310,x			and 	XS2_Mantissa+2,x
.0186e4	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0186e7	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.0186ea	3d 11 03	and $0311,x			and 	XS2_Mantissa+3,x
.0186ed	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0186f0	60		rts				rts
.0186f1					BinaryOp_Or:
.0186f1	20 41 87	jsr $018741			jsr 	BinaryMakeBothInteger
.0186f4	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.0186f7	1d 0e 03	ora $030e,x			ora 	XS2_Mantissa+0,x
.0186fa	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0186fd	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.018700	1d 0f 03	ora $030f,x			ora 	XS2_Mantissa+1,x
.018703	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018706	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.018709	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.01870c	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01870f	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.018712	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.018715	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018718	60		rts				rts
.018719					BinaryOp_Eor:
.018719					BinaryOp_Xor:
.018719	20 41 87	jsr $018741			jsr 	BinaryMakeBothInteger
.01871c	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.01871f	5d 0e 03	eor $030e,x			eor 	XS2_Mantissa+0,x
.018722	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018725	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.018728	5d 0f 03	eor $030f,x			eor 	XS2_Mantissa+1,x
.01872b	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.01872e	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.018731	5d 10 03	eor $0310,x			eor 	XS2_Mantissa+2,x
.018734	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018737	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.01873a	5d 11 03	eor $0311,x			eor 	XS2_Mantissa+3,x
.01873d	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018740	60		rts				rts
.018741					BinaryMakeBothInteger:
.018741	da		phx				phx 								; save X
.018742	e8		inx				inx
.018743	e8		inx				inx
.018744	e8		inx				inx
.018745	e8		inx				inx
.018746	e8		inx				inx
.018747	e8		inx				inx
.018748	20 4c 87	jsr $01874c			jsr 	BinaryMakeInteger 			; convert to integer.
.01874b	fa		plx				plx 								; restore X and fall through.
.01874c					BinaryMakeInteger:
.01874c	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type byte.
.01874f	29 0f		and #$0f			and 	#15 						; check type zero
.018751	f0 04		beq $018757			beq 	_BMIConvert 				; if float convert to integer.
.018753	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.018754	90 04		bcc $01875a			bcc 	_BMIError
.018756	60		rts				rts
.018757					_BMIConvert:
.018757	4c 8f 93	jmp $01938f			jmp 	FPUToInteger 				; convert to integer
.01875a					_BMIError:
.01875a	4c 02 84	jmp $018402			jmp 	TypeError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.01875d					Binary_Equal:
.01875d	20 a9 87	jsr $0187a9			jsr 	CompareValues
.018760	09 00		ora #$00			ora 	#0
.018762	f0 04		beq $018768			beq 	CCTrue
.018764	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.018766	80 02		bra $01876a			bra 	CCWrite
.018768	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.01876a	9d 08 03	sta $0308,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.01876d	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018770	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018773	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018776	a9 01		lda #$01			lda 	#1
.018778	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; set type to integer whatever.
.01877b	60		rts				rts
.01877c					Binary_NotEqual:
.01877c	20 a9 87	jsr $0187a9			jsr 	CompareValues
.01877f	09 00		ora #$00			ora 	#0
.018781	d0 e1		bne $018764			bne 	CCFalse
.018783	80 e3		bra $018768			bra 	CCTrue
.018785					Binary_Less:
.018785	20 a9 87	jsr $0187a9			jsr 	CompareValues
.018788	09 00		ora #$00			ora 	#0
.01878a	30 dc		bmi $018768			bmi 	CCTrue
.01878c	80 d6		bra $018764			bra 	CCFalse
.01878e					Binary_LessEqual:
.01878e	20 a9 87	jsr $0187a9			jsr 	CompareValues
.018791	c9 01		cmp #$01			cmp 	#1
.018793	d0 d3		bne $018768			bne 	CCTrue
.018795	80 cd		bra $018764			bra 	CCFalse
.018797					Binary_GreaterEqual:
.018797	20 a9 87	jsr $0187a9			jsr 	CompareValues
.01879a	09 00		ora #$00			ora 	#0
.01879c	10 ca		bpl $018768			bpl 	CCTrue
.01879e	80 c4		bra $018764			bra 	CCFalse
.0187a0					Binary_Greater:
.0187a0	20 a9 87	jsr $0187a9			jsr 	CompareValues
.0187a3	c9 01		cmp #$01			cmp 	#1
.0187a5	d0 c1		bne $018768			bne 	CCTrue
.0187a7	80 bb		bra $018764			bra 	CCFalse
.0187a9					CompareValues:
.0187a9	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and the types together
.0187ac	3d 13 03	and $0313,x			and 	XS2_Type,x
.0187af	c9 02		cmp #$02			cmp 	#2
.0187b1	f0 13		beq $0187c6			beq 	_CVString
.0187b3	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.0187b6	3d 13 03	and $0313,x			and 	XS2_Type,x
.0187b9	4a		lsr a				lsr 	a 							; shift bit 0 into C
.0187ba	90 03		bcc $0187bf			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.0187bc	4c 0c 88	jmp $01880c			jmp 	CompareInteger32 							; so execute code at \1
.0187bf					_BCFloat:
.0187bf	20 da 88	jsr $0188da			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.0187c2	4c 9e 92	jmp $01929e			jmp 	FPCompare 							; and execute code at \2
.0187c5	60		rts				rts
.0187c6					_CVString:
.0187c6	da		phx				phx 								; save XY
.0187c7	5a		phy				phy
.0187c8	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.0187cb	85 1a		sta $1a				sta		zLTemp1+0
.0187cd	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0187d0	85 1b		sta $1b				sta 	zLTemp1+1
.0187d2	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x
.0187d5	85 1c		sta $1c				sta 	zLTemp1+2
.0187d7	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.0187da	85 1d		sta $1d				sta 	zLTemp1+3
.0187dc	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.0187de	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.0187e0	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.0187e2	90 02		bcc $0187e6			bcc 	_CVCommon
.0187e4	b1 1c		lda ($1c),y			lda 	(zLTemp1+2),y
.0187e6					_CVCommon:
.0187e6	aa		tax				tax 								; put shorter string length in zero.
.0187e7	f0 0c		beq $0187f5			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.0187e9					_CVCompare:
.0187e9	c8		iny				iny 								; next character
.0187ea	b1 1a		lda ($1a),y			lda 	(zLTemp1),y 				; compare characters
.0187ec	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.0187ee	90 13		bcc $018803			bcc 	_CVReturnLess 				; <
.0187f0	d0 15		bne $018807			bne 	_CVReturnGreater 			; >
.0187f2	ca		dex				dex 								; until common length matched.
.0187f3	d0 f4		bne $0187e9			bne 	_CVCompare
.0187f5					_CVMatch:
.0187f5	a0 00		ldy #$00			ldy 	#0
.0187f7	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.0187f9	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.0187fb	90 06		bcc $018803			bcc 	_CVReturnLess 				; <
.0187fd	d0 08		bne $018807			bne 	_CVReturnGreater 			; >
.0187ff	a9 00		lda #$00			lda 	#0
.018801	80 06		bra $018809			bra 	_CVExit 					; same common, same length, same string
.018803					_CVReturnLess:
.018803	a9 ff		lda #$ff			lda 	#$FF
.018805	80 02		bra $018809			bra 	_CVExit
.018807					_CVReturnGreater:
.018807	a9 01		lda #$01			lda 	#$01
.018809					_CVExit:
.018809	7a		ply				ply
.01880a	fa		plx				plx
.01880b	60		rts				rts
.01880c					CompareInteger32:
.01880c	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.01880f	49 80		eor #$80			eor 	#$80
.018811	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018814	bd 11 03	lda $0311,x			lda 	XS2_Mantissa+3,x
.018817	49 80		eor #$80			eor 	#$80
.018819	9d 11 03	sta $0311,x			sta 	XS2_Mantissa+3,x
.01881c	20 b4 88	jsr $0188b4			jsr 	SubInteger32 				; subtraction
.01881f	90 11		bcc $018832			bcc 	_CI32Less 					; cc return -1
.018821	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; check if zero
.018824	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.018827	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.01882a	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.01882d	f0 02		beq $018831			beq 	_CI32Exit
.01882f	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.018831					_CI32Exit:
.018831	60		rts				rts
.018832					_CI32Less:
.018832	a9 ff		lda #$ff			lda 	#$FF
.018834	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.018835					BinaryOp_Add:
.018835	bd 0d 03	lda $030d,x			lda 	XS_Type,x  					; and types together
.018838	3d 13 03	and $0313,x			and 	XS2_Type,x
.01883b	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.01883d	d0 13		bne $018852			bne 	_BOAString
.01883f	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018842	3d 13 03	and $0313,x			and 	XS2_Type,x
.018845	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018846	90 03		bcc $01884b			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018848	4c 8e 88	jmp $01888e			jmp 	AddInteger32 							; so execute code at \1
.01884b					_BCFloat:
.01884b	20 da 88	jsr $0188da			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.01884e	4c 12 90	jmp $019012			jmp 	FPAdd 							; and execute code at \2
.018851	60		rts				rts
.018852					_BOAString:
.018852	4c f5 88	jmp $0188f5			jmp 	ConcatenateString 			; concatenate two strings.
.018855					BinaryOp_Subtract:
.018855	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018858	3d 13 03	and $0313,x			and 	XS2_Type,x
.01885b	4a		lsr a				lsr 	a 							; shift bit 0 into C
.01885c	90 03		bcc $018861			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.01885e	4c b4 88	jmp $0188b4			jmp 	SubInteger32 							; so execute code at \1
.018861					_BCFloat:
.018861	20 da 88	jsr $0188da			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018864	4c 08 90	jmp $019008			jmp 	FPSubtract 							; and execute code at \2
.018867	60		rts				rts
.018868					BinaryOp_Multiply:
.018868	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.01886b	3d 13 03	and $0313,x			and 	XS2_Type,x
.01886e	4a		lsr a				lsr 	a 							; shift bit 0 into C
.01886f	90 03		bcc $018874			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018871	4c 96 8d	jmp $018d96			jmp 	MulInteger32 							; so execute code at \1
.018874					_BCFloat:
.018874	20 da 88	jsr $0188da			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018877	4c 7e 91	jmp $01917e			jmp 	FPMultiply 							; and execute code at \2
.01887a	60		rts				rts
.01887b					BinaryOp_Divide:
.01887b	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.01887e	3d 13 03	and $0313,x			and 	XS2_Type,x
.018881	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018882	90 03		bcc $018887			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018884	4c ed 8d	jmp $018ded			jmp 	DivInteger32 							; so execute code at \1
.018887					_BCFloat:
.018887	20 da 88	jsr $0188da			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.01888a	4c f6 90	jmp $0190f6			jmp 	FPDivide 							; and execute code at \2
.01888d	60		rts				rts
.01888e					AddInteger32:
.01888e	18		clc				clc
.01888f	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018892	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.018895	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018898	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.01889b	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.01889e	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0188a1	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.0188a4	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.0188a7	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0188aa	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.0188ad	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.0188b0	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0188b3	60		rts				rts
.0188b4					SubInteger32:
.0188b4	38		sec				sec
.0188b5	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.0188b8	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.0188bb	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0188be	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0188c1	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.0188c4	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0188c7	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.0188ca	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.0188cd	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0188d0	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.0188d3	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.0188d6	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0188d9	60		rts				rts
.0188da					BinaryMakeBothFloat:
.0188da	da		phx				phx 								; save X
.0188db	e8		inx				inx
.0188dc	e8		inx				inx
.0188dd	e8		inx				inx
.0188de	e8		inx				inx
.0188df	e8		inx				inx
.0188e0	e8		inx				inx
.0188e1	20 e5 88	jsr $0188e5			jsr 	BinaryMakeFloat 			; convert to float.
.0188e4	fa		plx				plx 								; restore X and fall through.
.0188e5					BinaryMakeFloat:
.0188e5	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type byte.
.0188e8	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.0188e9	b0 04		bcs $0188ef			bcs 	_BMFConvert
.0188eb	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.0188ec	b0 04		bcs $0188f2			bcs 	_BMFError
.0188ee	60		rts				rts
.0188ef					_BMFConvert:
.0188ef	4c 30 93	jmp $019330			jmp 	FPUToFloat 					; convert to float
.0188f2					_BMFError:
.0188f2	4c 02 84	jmp $018402			jmp 	TypeError
.0188f5					ConcatenateString:
.0188f5	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.0188f8	85 1a		sta $1a				sta		zLTemp1+0
.0188fa	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0188fd	85 1b		sta $1b				sta 	zLTemp1+1
.0188ff	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x
.018902	85 1c		sta $1c				sta 	zLTemp1+2
.018904	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.018907	85 1d		sta $1d				sta 	zLTemp1+3
.018909	5a		phy				phy
.01890a	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.01890c	b1 1a		lda ($1a),y			lda 	(zlTemp1),y
.01890e	71 1c		adc ($1c),y			adc 	(zlTemp1+2),y
.018910	7a		ply				ply
.018911	b0 37		bcs $01894a			bcs 	_CSError					; check in range.
.018913	c9 fe		cmp #$fe			cmp 	#maxString+1
.018915	b0 33		bcs $01894a			bcs 	_CSError
.018917	20 36 8d	jsr $018d36			jsr 	AllocateTempString 			; store the result
.01891a	20 35 89	jsr $018935			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.01891d	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.018920	85 1a		sta $1a				sta 	zLTemp1
.018922	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.018925	85 1b		sta $1b				sta 	zLTemp1+1
.018927	20 35 89	jsr $018935			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.01892a	a5 20		lda $20				lda 	zTempStr 					; point current to new string
.01892c	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.01892f	a5 21		lda $21				lda 	zTempStr+1
.018931	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018934	60		rts				rts
.018935					_CSCopyString:
.018935	da		phx				phx
.018936	5a		phy				phy
.018937	a0 00		ldy #$00			ldy 	#0 							; get length
.018939	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.01893b	f0 0a		beq $018947			beq 	_CSCSExit 					; if zero, exit
.01893d	aa		tax				tax 								; put in X
.01893e					_CSCSLoop:
.01893e	c8		iny				iny 								; get next char
.01893f	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.018941	20 61 8d	jsr $018d61			jsr		WriteTempString 			; copy out
.018944	ca		dex				dex 								; do whole string
.018945	d0 f7		bne $01893e			bne 	_CSCSLoop
.018947					_CSCSExit:
.018947	7a		ply				ply
.018948	fa		plx				plx
.018949	60		rts				rts
.01894a					_CSError:
.01894a	20 21 84	jsr $018421			jsr ERR_Handler
>01894d	53 74 72 69 6e 67 20 74			.text "String too long",0
>018955	6f 6f 20 6c 6f 6e 67 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.01895d					Unary_Sgn:
.01895d	20 9a 86	jsr $01869a			jsr 	EvaluateNumberX 			; get value
.018960	20 26 8d	jsr $018d26			jsr 	CheckNextRParen 			; check right bracket.
.018963	20 87 89	jsr $018987			jsr 	GetSignCurrent 				; get sign.
.018966	09 00		ora #$00			ora 	#0
.018968	10 09		bpl $018973			bpl		UnarySetAInteger			; if 0,1 return that.
.01896a	80 00		bra $01896c			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.01896c					UnarySetAMinus1:
.01896c	a9 ff		lda #$ff			lda 	#$FF
.01896e	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.018971	80 05		bra $018978			bra 	UnarySetAFill
.018973					UnarySetAInteger:
.018973	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.018976	a9 00		lda #$00			lda 	#0
.018978					UnarySetAFill:
.018978	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.01897b	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01897e	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018981	a9 01		lda #$01			lda 	#1
.018983	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018986	60		rts				rts
.018987					GetSignCurrent:
.018987	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; identify type.
.01898a	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.01898b	90 19		bcc $0189a6			bcc 	_GSCFloat
.01898d	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.018990	30 11		bmi $0189a3			bmi 	_GSCMinus1
.018992	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x
.018995	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.018998	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.01899b	d0 03		bne $0189a0			bne 	_GSCPlus1
.01899d					_GSCZero:
.01899d	a9 00		lda #$00			lda 	#0
.01899f	60		rts				rts
.0189a0					_GSCPlus1:
.0189a0	a9 01		lda #$01			lda 	#$01
.0189a2	60		rts				rts
.0189a3					_GSCMinus1:
.0189a3	a9 ff		lda #$ff			lda 	#$FF
.0189a5	60		rts				rts
.0189a6					_GSCFloat:
.0189a6	3c 0d 03	bit $030d,x			bit 	XS_Type,x
.0189a9	70 f2		bvs $01899d			bvs 	_GSCZero
.0189ab	30 f6		bmi $0189a3			bmi 	_GSCMinus1
.0189ad	80 f1		bra $0189a0			bra 	_GSCPlus1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.0189af					Unary_Abs:
.0189af	20 9a 86	jsr $01869a			jsr 	EvaluateNumberX 			; get value
.0189b2	20 26 8d	jsr $018d26			jsr 	CheckNextRParen 			; check right bracket.
.0189b5	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.0189b8	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.0189ba	f0 08		beq $0189c4			beq 	_UAMinusFloat
.0189bc	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; check MSB
.0189bf	10 0b		bpl $0189cc			bpl 	_UAExit
.0189c1	4c 83 8e	jmp $018e83			jmp 	IntegerNegateAlways 		; negation
.0189c4					_UAMinusFloat:
.0189c4	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; clear the sign bit.
.0189c7	29 7f		and #$7f			and		#$7F
.0189c9	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0189cc					_UAExit:
.0189cc	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.0189cd					Unary_Peek:
.0189cd	a9 01		lda #$01			lda 	#1
.0189cf	80 06		bra $0189d7			bra 	UPMain
.0189d1					Unary_Deek:
.0189d1	a9 02		lda #$02			lda 	#2
.0189d3	80 02		bra $0189d7			bra 	UPMain
.0189d5					Unary_Leek:
.0189d5	a9 04		lda #$04			lda 	#4
.0189d7					UPMain:
.0189d7	48		pha				pha 								; set bytes to copy.
.0189d8	20 a9 86	jsr $0186a9			jsr 	EvaluateIntegerX 			; numeric parameter
.0189db	20 26 8d	jsr $018d26			jsr 	CheckNextRParen 			; right bracket.
.0189de	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.0189e1	85 1a		sta $1a				sta 	zLTemp1
.0189e3	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0189e6	85 1b		sta $1b				sta 	zLTemp1+1
.0189e8	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.0189eb	85 1c		sta $1c				sta 	zLTemp1+2
.0189ed	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.0189f0	85 1d		sta $1d				sta 	zLTemp1+3
.0189f2	a9 00		lda #$00			lda 	#0 							; clear target area
.0189f4	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0189f7	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0189fa	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0189fd	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018a00	68		pla				pla 								; restore bytes to copy
.018a01	da		phx				phx 								; save XY
.018a02	5a		phy				phy
.018a03	20 fd 8c	jsr $018cfd			jsr 	MemRead 					; read the bytes in
.018a06	7a		ply				ply 								; restore and exit
.018a07	fa		plx				plx
.018a08	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.018a09					Unary_Mod:
.018a09	20 35 8a	jsr $018a35			jsr 	_UMParameter 				; first parameter
.018a0c	20 2e 8d	jsr $018d2e			jsr 	CheckNextComma
.018a0f	da		phx				phx 								; second parameter
.018a10	e8		inx				inx
.018a11	e8		inx				inx
.018a12	e8		inx				inx
.018a13	e8		inx				inx
.018a14	e8		inx				inx
.018a15	e8		inx				inx
.018a16	20 35 8a	jsr $018a35			jsr 	_UMParameter
.018a19	fa		plx				plx
.018a1a	20 26 8d	jsr $018d26			jsr 	CheckNextRParen
.018a1d	20 ed 8d	jsr $018ded			jsr 	DivInteger32 				; divide
.018a20	a5 1a		lda $1a				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.018a22	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018a25	a5 1b		lda $1b				lda 	zLTemp1+1
.018a27	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018a2a	a5 1c		lda $1c				lda 	zLTemp1+2
.018a2c	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018a2f	a5 1d		lda $1d				lda 	zLTemp1+3
.018a31	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018a34	60		rts				rts
.018a35					_UMParameter:
.018a35	20 a9 86	jsr $0186a9			jsr 	EvaluateIntegerX 			; get value
.018a38	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; absolute value
.018a3b	10 03		bpl $018a40			bpl 	_UMNotSigned
.018a3d	20 83 8e	jsr $018e83			jsr 	IntegerNegateAlways
.018a40					_UMNotSigned:
.018a40	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.018a41					Unary_Usr:
.018a41	20 9a 86	jsr $01869a			jsr 	EvaluateNumberX 			; numeric parameter
.018a44	20 26 8d	jsr $018d26			jsr 	CheckNextRParen 			; right bracket.
.018a47	da		phx				phx 								; save XY
.018a48	5a		phy				phy
.018a49	ea		nop				nop
.018a4a	22 00 03 00	jsl $000300			jsl 	UserVector
.018a4e	7a		ply				ply 								; and exit
.018a4f	fa		plx				plx
.018a50	60		rts				rts
.018a51					USRDefault:
.018a51	20 21 84	jsr $018421			jsr ERR_Handler
>018a54	4e 6f 20 55 53 52 20 76			.text "No USR vector.",0
>018a5c	65 63 74 6f 72 2e 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.018a63					Unary_Val:
.018a63	20 b2 86	jsr $0186b2			jsr 	EvaluateStringX 			; get string
.018a66	20 26 8d	jsr $018d26			jsr 	CheckNextRParen 			; check right bracket.
.018a69	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.018a6c	85 1e		sta $1e				sta 	zGenPtr
.018a6e	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018a71	85 1f		sta $1f				sta 	zGenPtr+1
.018a73	5a		phy				phy
.018a74	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.018a76	b1 1e		lda ($1e),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.018a78	f0 54		beq $018ace			beq 	_UVBadNumber
.018a7a	48		pha				pha 								; save length.
.018a7b	1a		inc a				inc 	a 							; one for the length, one for the terminator
.018a7c	1a		inc a				inc 	a
.018a7d	20 36 8d	jsr $018d36			jsr 	AllocateTempString
.018a80	c8		iny				iny 								; move to the next.
.018a81	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get character
.018a83	49 2d		eor #$2d			eor 	#"-"						; zero if minus sign
.018a85	8d 28 04	sta $0428			sta 	ValSign
.018a88	d0 01		bne $018a8b			bne 	_UVNotMinus
.018a8a	c8		iny				iny 								; skip over it.
.018a8b					_UVNotMinus:
.018a8b	68		pla				pla 								; this is the count.
.018a8c	48		pha		_UVCopy:pha									; copy into new temp string which is ASCIIZ
.018a8d	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018a8f	c8		iny				iny
.018a90	20 61 8d	jsr $018d61			jsr 	WriteTempString
.018a93	68		pla				pla
.018a94	3a		dec a				dec 	a
.018a95	d0 f5		bne $018a8c			bne 	_UVCopy
.018a97	20 61 8d	jsr $018d61			jsr 	WriteTempString 			; make it ASCIIZ
.018a9a	18		clc				clc
.018a9b	a5 20		lda $20				lda 	zTempStr 					; tempstring +1 => genptr
.018a9d	69 01		adc #$01			adc 	#1
.018a9f	85 1e		sta $1e				sta 	zGenPtr
.018aa1	a5 21		lda $21				lda 	zTempStr+1
.018aa3	69 00		adc #$00			adc 	#0
.018aa5	85 1f		sta $1f				sta 	zGenPtr+1
.018aa7	18		clc				clc
.018aa8	20 5d 8f	jsr $018f5d			jsr 	IntFromString 				; first bit.
.018aab	b0 21		bcs $018ace			bcs 	_UVBadNumber
.018aad	20 81 95	jsr $019581			jsr 	FPFromString				; try for a float part.
.018ab0	ad 28 04	lda $0428			lda 	ValSign 					; was it negative
.018ab3	d0 13		bne $018ac8			bne 	_UVNotNegative
.018ab5	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; check if integer
.018ab8	4a		lsr a				lsr 	a
.018ab9	b0 0a		bcs $018ac5			bcs 	_UVInteger
.018abb	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; set sign bit
.018abe	09 80		ora #$80			ora 	#$80
.018ac0	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018ac3	80 03		bra $018ac8			bra 	_UVNotNegative
.018ac5					_UVInteger:
.018ac5	20 83 8e	jsr $018e83			jsr 	IntegerNegateAlways 		; sign it.
.018ac8					_UVNotNegative:
.018ac8	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; used everything
.018aca	d0 02		bne $018ace			bne 	_UVBadNumber
.018acc	7a		ply				ply
.018acd	60		rts				rts
.018ace					_UVBadNumber:
.018ace	4c 10 84	jmp $018410			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.018ad1					Unary_Str:
.018ad1	20 9a 86	jsr $01869a			jsr 	EvaluateNumberX 			; numeric parameter
.018ad4	20 26 8d	jsr $018d26			jsr 	CheckNextRParen 			; right bracket.
.018ad7	a9 00		lda #$00			lda 	#0 							; reset buffer index
.018ad9	8d 20 04	sta $0420			sta 	NumBufX
.018adc	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.018adf	4a		lsr a				lsr 	a
.018ae0	b0 05		bcs $018ae7			bcs 	_USInt 						; if msb set do as integer
.018ae2	20 ba 94	jsr $0194ba			jsr 	FPToString 					; call fp to str otherwise
.018ae5	80 03		bra $018aea			bra 	_USDuplicate
.018ae7	20 a8 8e	jsr $018ea8	_USInt:	jsr 	IntToString
.018aea					_USDuplicate:
.018aea	ad 20 04	lda $0420			lda 	NumBufX 					; chars in buffer
.018aed	1a		inc a				inc 	a 							; one more for length
.018aee	20 36 8d	jsr $018d36			jsr 	AllocateTempString 			; allocate space for it.
.018af1	5a		phy				phy 								; save Y
.018af2	a0 00		ldy #$00			ldy 	#0 							; start copying
.018af4	b9 00 04	lda $0400,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.018af7	20 61 8d	jsr $018d61			jsr 	WriteTempString
.018afa	c8		iny				iny
.018afb	cc 20 04	cpy $0420			cpy 	NumBufX 					; done the lot
.018afe	d0 f4		bne $018af4			bne 	_USCopy
.018b00	7a		ply				ply 								; restore Y
.018b01	4c ed 8c	jmp $018ced			jmp 	UnaryReturnTempStr 			; return new temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.018b04					Unary_Asc:
.018b04	20 b2 86	jsr $0186b2			jsr 	EvaluateStringX 			; string parameter
.018b07	20 26 8d	jsr $018d26			jsr 	CheckNextRParen 			; right bracket.
.018b0a	5a		phy				phy 								; get the string length
.018b0b	a0 00		ldy #$00			ldy 	#0
.018b0d	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018b0f	f0 07		beq $018b18			beq 	_UAIllegal 					; must be at least one character
.018b11	c8		iny				iny
.018b12	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; read it.
.018b14	7a		ply				ply
.018b15	4c 73 89	jmp $018973			jmp 	UnarySetAInteger
.018b18					_UAIllegal:
.018b18	4c 10 84	jmp $018410			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.018b1b					Unary_Len:
.018b1b	20 b2 86	jsr $0186b2			jsr 	EvaluateStringX 			; string parameter
.018b1e	20 26 8d	jsr $018d26			jsr 	CheckNextRParen 			; right bracket.
.018b21	5a		phy				phy 								; get the string length
.018b22	a0 00		ldy #$00			ldy 	#0
.018b24	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018b26	7a		ply				ply
.018b27	4c 73 89	jmp $018973			jmp 	UnarySetAInteger

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.018b2a					Unary_Mid:
.018b2a	20 b2 86	jsr $0186b2			jsr 	EvaluateStringX 				; get string.
.018b2d	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.018b30	48		pha				pha
.018b31	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018b34	48		pha				pha
.018b35	20 2e 8d	jsr $018d2e			jsr 	CheckNextComma 					; skip comma
.018b38	20 c5 8b	jsr $018bc5			jsr 	SLIByteParameter 				; get a byte parameter (start)
.018b3b	48		pha				pha 									; and push it.
.018b3c	20 2e 8d	jsr $018d2e			jsr 	CheckNextComma 					; skip comma
.018b3f	20 c5 8b	jsr $018bc5			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.018b42	48		pha				pha 									; and push it.
.018b43	80 45		bra $018b8a			bra 	SLIProcess
.018b45					Unary_Left:
.018b45	20 b2 86	jsr $0186b2			jsr 	EvaluateStringX 				; get string.
.018b48	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.018b4b	48		pha				pha
.018b4c	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018b4f	48		pha				pha
.018b50	a9 01		lda #$01			lda 	#1 								; push start position (1)
.018b52	48		pha				pha
.018b53	20 2e 8d	jsr $018d2e			jsr 	CheckNextComma 					; skip comma
.018b56	20 c5 8b	jsr $018bc5			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.018b59	48		pha				pha 									; and push it.
.018b5a	80 2e		bra $018b8a			bra 	SLIProcess
.018b5c					Unary_Right:
.018b5c	20 b2 86	jsr $0186b2			jsr 	EvaluateStringX 				; get string.
.018b5f	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.018b62	48		pha				pha
.018b63	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018b66	48		pha				pha
.018b67	da		phx				phx 									; get the string length and push on stack.
.018b68	a2 00		ldx #$00			ldx 	#0
.018b6a	a1 1e		lda ($1e,x)			lda		(zGenPtr,x)
.018b6c	fa		plx				plx
.018b6d	48		pha				pha
.018b6e	20 2e 8d	jsr $018d2e			jsr 	CheckNextComma 					; skip comma
.018b71	20 c5 8b	jsr $018bc5			jsr 	SLIByteParameter 				; get a byte parameter.
.018b74	8d 25 04	sta $0425			sta 	SignCount 						; save in temporary.
.018b77	68		pla				pla 									; restore string length.
.018b78	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.018b79	38		sec				sec
.018b7a	ed 25 04	sbc $0425			sbc 	SignCount 						; subtract characters needed, gives start position.
.018b7d	f0 02		beq $018b81			beq 	_URStart 						; if <= 0 start from 1.
.018b7f	10 02		bpl $018b83			bpl 	_UROkay
.018b81					_URStart:
.018b81	a9 01		lda #$01			lda 	#1
.018b83					_UROkay:
.018b83	48		pha				pha 									; push start
.018b84	ad 25 04	lda $0425			lda 	SignCount 						; push count of characters
.018b87	48		pha				pha
.018b88	80 00		bra $018b8a			bra 	SLIProcess
.018b8a					SLIProcess:
.018b8a	20 26 8d	jsr $018d26			jsr 	CheckNextRParen 				; closing right bracket.
.018b8d	68		pla				pla
.018b8e	8d 2a 04	sta $042a			sta 	SliceCount 						; count in signcount
.018b91	1a		inc a				inc 	a 								; allocate +1 for it.
.018b92	20 36 8d	jsr $018d36			jsr 	AllocateTempString
.018b95	68		pla				pla 									; pop start number off stack.
.018b96	f0 3f		beq $018bd7			beq 	SLIError 						; exit if start = 0
.018b98	8d 29 04	sta $0429			sta 	SliceStart
.018b9b	68		pla				pla  									; pop string address.
.018b9c	85 1f		sta $1f				sta 	zGenPtr+1
.018b9e	68		pla				pla
.018b9f	85 1e		sta $1e				sta 	zGenPtr
.018ba1	da		phx				phx
.018ba2	5a		phy				phy
.018ba3	a2 00		ldx #$00			ldx 	#0 								; point to string length.
.018ba5	ac 29 04	ldy $0429			ldy 	SliceStart 						; start of the string (+1 for count)
.018ba8					_SLICopy:
.018ba8	ad 2a 04	lda $042a			lda 	SliceCount 						; done count characters
.018bab	f0 12		beq $018bbf			beq 	_SLIExit
.018bad	ce 2a 04	dec $042a			dec 	SliceCount
.018bb0	98		tya				tya 									; index of character
.018bb1	c1 1e		cmp ($1e,x)			cmp 	(zGenPtr,x)						; compare against length
.018bb3	f0 02		beq $018bb7			beq 	_SLIOk 							; if equal, okay.
.018bb5	b0 08		bcs $018bbf			bcs 	_SLIExit 						; if past end, then exit.
.018bb7	b1 1e		lda ($1e),y	_SLIOk:	lda 	(zGenPtr),y 					; copy one character
.018bb9	c8		iny				iny
.018bba	20 61 8d	jsr $018d61			jsr 	WriteTempString
.018bbd	80 e9		bra $018ba8			bra 	_SLICopy 						; go round till copied characters
.018bbf					_SLIExit:
.018bbf	7a		ply				ply 									; restore YX
.018bc0	fa		plx				plx
.018bc1	4c ed 8c	jmp $018ced			jmp 	UnaryReturnTempStr 				; return new temporary string.
.018bc4	ea		nop				nop
.018bc5					SLIByteParameter:
.018bc5	20 a9 86	jsr $0186a9			jsr 	EvaluateIntegerX 				; get integer
.018bc8	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.018bcb	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.018bce	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.018bd1	d0 04		bne $018bd7			bne 	SLIError
.018bd3	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018bd6	60		rts				rts
.018bd7					SLIError:
.018bd7	4c 10 84	jmp $018410			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.018bda					Unary_Hex:
.018bda	20 a9 86	jsr $0186a9			jsr 	EvaluateIntegerX 			; numeric parameter
.018bdd	20 26 8d	jsr $018d26			jsr 	CheckNextRParen 			; right bracket.
.018be0	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.018be2	20 36 8d	jsr $018d36			jsr 	AllocateTempString			; allocate string space
.018be5	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.018be8	20 0f 8c	jsr $018c0f			jsr 	_UHConvert
.018beb	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018bee	20 0f 8c	jsr $018c0f			jsr 	_UHConvert
.018bf1	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018bf4	20 0f 8c	jsr $018c0f			jsr 	_UHConvert
.018bf7	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018bfa	20 0f 8c	jsr $018c0f			jsr 	_UHConvert
.018bfd	5a		phy				phy 								; get length of new string
.018bfe	a0 00		ldy #$00			ldy 	#0
.018c00	b1 20		lda ($20),y			lda 	(zTempStr),y
.018c02	7a		ply				ply
.018c03	c9 00		cmp #$00			cmp 	#0
.018c05	d0 05		bne $018c0c			bne 	_UHExit 					; if it was non zero okay
.018c07	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.018c09	20 61 8d	jsr $018d61			jsr 	WriteTempString
.018c0c					_UHExit:
.018c0c	4c ed 8c	jmp $018ced			jmp 	UnaryReturnTempStr 			; return new temporary string.
.018c0f					_UHConvert:
.018c0f	48		pha				pha
.018c10	4a		lsr a				lsr 	a 							; do MSB
.018c11	4a		lsr a				lsr 	a
.018c12	4a		lsr a				lsr 	a
.018c13	4a		lsr a				lsr 	a
.018c14	20 18 8c	jsr $018c18			jsr 	_UHNibble
.018c17	68		pla				pla 								; do LSB
.018c18					_UHNibble:
.018c18	29 0f		and #$0f			and 	#15 						; get nibble
.018c1a	d0 0c		bne $018c28			bne 	_UHNonZero
.018c1c	5a		phy				phy									; get the length
.018c1d	a0 00		ldy #$00			ldy 	#0
.018c1f	b1 20		lda ($20),y			lda 	(zTempStr),y
.018c21	7a		ply				ply
.018c22	c9 00		cmp #$00			cmp 	#0 							; suppress leading zeros.
.018c24	f0 0d		beq $018c33			beq 	_UHExit2
.018c26	a9 00		lda #$00			lda 	#0
.018c28					_UHNonZero:
.018c28	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.018c2a	90 02		bcc $018c2e			bcc 	_UHDigit
.018c2c	69 06		adc #$06			adc 	#7-1
.018c2e					_UHDigit:
.018c2e	69 30		adc #$30			adc 	#48
.018c30	20 61 8d	jsr $018d61			jsr 	WriteTempString				; output.
.018c33					_UHExit2:
.018c33	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.018c34					Unary_Dec:
.018c34	20 b2 86	jsr $0186b2			jsr 	EvaluateStringX 			; string parameter
.018c37	20 26 8d	jsr $018d26			jsr 	CheckNextRParen 			; right bracket.
.018c3a	5a		phy				phy
.018c3b	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.018c3d	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018c3f	f0 4c		beq $018c8d			beq 	_UDFail 					; must fail if zero.
.018c41	8d 25 04	sta $0425			sta 	SignCount 					; use SignCount as a counter
.018c44	a9 00		lda #$00			lda 	#0 							; set result to zero integer.
.018c46	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018c49	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018c4c	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018c4f	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018c52	a9 01		lda #$01			lda 	#1
.018c54	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018c57					_UDConvertLoop:
.018c57	5a		phy				phy 								; shift mantissa left 4
.018c58	a0 04		ldy #$04			ldy 	#4
.018c5a					_UDShift:
.018c5a	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x
.018c5d	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.018c60	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.018c63	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.018c66	88		dey				dey
.018c67	d0 f1		bne $018c5a			bne 	_UDShift
.018c69	7a		ply				ply
.018c6a	c8		iny				iny 								; next character
.018c6b	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; fetch it.
.018c6d	20 90 8c	jsr $018c90			jsr 	ConvertUpper 				; convert to U/C
.018c70	c9 30		cmp #$30			cmp 	#"0"
.018c72	90 19		bcc $018c8d			bcc 	_UDFail
.018c74	c9 3a		cmp #$3a			cmp 	#"9"+1
.018c76	90 06		bcc $018c7e			bcc 	_UDOkay
.018c78	e9 37		sbc #$37			sbc 	#7+"0" 						; alpha fudge
.018c7a	c9 10		cmp #$10			cmp 	#16
.018c7c	b0 0f		bcs $018c8d			bcs 	_UDFail
.018c7e					_UDOkay:
.018c7e	29 0f		and #$0f			and 	#15 						; nibble only
.018c80	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x
.018c83	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018c86	ce 25 04	dec $0425			dec 	SignCount 					; do it for each character
.018c89	d0 cc		bne $018c57			bne 	_UDConvertLoop
.018c8b	7a		ply				ply
.018c8c	60		rts				rts
.018c8d					_UDFail:
.018c8d	4c 10 84	jmp $018410			jmp 	BadParamError
.018c90					ConvertUpper:
.018c90	c9 61		cmp #$61			cmp 	#"a"
.018c92	90 07		bcc $018c9b			bcc 	_CUExit
.018c94	c9 7b		cmp #$7b			cmp 	#"z"+1
.018c96	b0 03		bcs $018c9b			bcs 	_CUExit
.018c98	38		sec				sec
.018c99	e9 20		sbc #$20			sbc 	#32
.018c9b	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.018c9c					Unary_Chr:
.018c9c	20 a9 86	jsr $0186a9			jsr 	EvaluateIntegerX			; numeric parameter
.018c9f	20 26 8d	jsr $018d26			jsr 	CheckNextRParen 			; right bracket.
.018ca2	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.018ca5	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.018ca8	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.018cab	d0 0e		bne $018cbb			bne 	_UCChar
.018cad	a9 01		lda #$01			lda 	#1 							; one character string
.018caf	20 36 8d	jsr $018d36			jsr 	AllocateTempString
.018cb2	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.018cb5	20 61 8d	jsr $018d61			jsr 	WriteTempString
.018cb8	4c ed 8c	jmp $018ced			jmp 	UnaryReturnTempStr
.018cbb					_UCChar:
.018cbb	4c 10 84	jmp $018410			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.018cbe					Unary_Spc:
.018cbe	20 a9 86	jsr $0186a9			jsr 	EvaluateIntegerX 			; numeric parameter
.018cc1	20 26 8d	jsr $018d26			jsr 	CheckNextRParen 			; right bracket.
.018cc4	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.018cc7	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.018cca	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.018ccd	d0 1b		bne $018cea			bne 	_USSize
.018ccf	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018cd2	c9 fe		cmp #$fe			cmp 	#maxString+1
.018cd4	b0 14		bcs $018cea			bcs 	_USSize
.018cd6	48		pha				pha 								; save length
.018cd7	1a		inc a				inc 	a 							; allocate one more.
.018cd8	20 36 8d	jsr $018d36			jsr 	AllocateTempString
.018cdb	68		pla				pla 								; get length
.018cdc	f0 0f		beq $018ced			beq 	UnaryReturnTempStr 			; return the current temp string
.018cde					_USLoop:
.018cde	48		pha				pha
.018cdf	a9 20		lda #$20			lda 	#" "
.018ce1	20 61 8d	jsr $018d61			jsr 	WriteTempString
.018ce4	68		pla				pla
.018ce5	3a		dec a				dec 	a
.018ce6	d0 f6		bne $018cde			bne 	_USLoop
.018ce8	80 03		bra $018ced			bra 	UnaryReturnTempStr
.018cea					_USSize:
.018cea	4c 10 84	jmp $018410			jmp 	BadParamError
.018ced					UnaryReturnTempStr:
.018ced	a5 20		lda $20				lda 	zTempStr 					; copy temp string addr -> mantissa
.018cef	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018cf2	a5 21		lda $21				lda 	zTempStr+1
.018cf4	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018cf7	a9 02		lda #$02			lda 	#2 							; set type to string
.018cf9	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018cfc	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/65816.asm

.018cfd					MemRead:
.018cfd	8d 25 04	sta $0425			sta 	SignCount 					; save count
.018d00	a0 00		ldy #$00			ldy 	#0 							; start from here
.018d02	b7 1a		lda [$1a],y	_MLoop1:lda 	[zlTemp1],y 				; read the long address
.018d04	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; copy into mantissa
.018d07	c8		iny				iny 								; next to copy
.018d08	e8		inx				inx
.018d09	cc 25 04	cpy $0425			cpy 	SignCount 					; do required # of bytes.
.018d0c	d0 f4		bne $018d02			bne 	_MLoop1
.018d0e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.018d0f					CheckNextToken:
.018d0f	d1 16		cmp ($16),y			cmp 	(zCodePtr),y
.018d11	d0 02		bne $018d15			bne 	CTFail 						; no, then fail
.018d13	c8		iny				iny
.018d14	60		rts				rts
.018d15					CTFail:
.018d15	20 21 84	jsr $018421			jsr ERR_Handler
>018d18	4d 69 73 73 69 6e 67 20			.text "Missing token",0
>018d20	74 6f 6b 65 6e 00
.018d26					CheckNextRParen:
.018d26	b1 16		lda ($16),y			lda 	(zCodePtr),y
.018d28	c9 bc		cmp #$bc			cmp 	#token_rparen
.018d2a	d0 e9		bne $018d15			bne 	CTFail
.018d2c	c8		iny				iny
.018d2d	60		rts				rts
.018d2e					CheckNextComma:
.018d2e	b1 16		lda ($16),y			lda 	(zCodePtr),y
.018d30	c9 bd		cmp #$bd			cmp 	#token_comma
.018d32	d0 e1		bne $018d15			bne 	CTFail
.018d34	c8		iny				iny
.018d35	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.018d36					AllocateTempString:
.018d36	48		pha				pha 								; save required count.
.018d37	a5 21		lda $21				lda 	zTempStr+1 					; check if initialised yet ?
.018d39	d0 0b		bne $018d46			bne 	_ATSInitialised
.018d3b	ad 26 04	lda $0426			lda 	StringPtr 					; set temporary string ptr 1 page below available
.018d3e	85 20		sta $20				sta 	zTempStr					; space, this is for strings to be concreted.
.018d40	ad 27 04	lda $0427			lda 	StringPtr+1
.018d43	3a		dec a				dec 	a
.018d44	85 21		sta $21				sta 	zTempStr+1
.018d46					_ATSInitialised:
.018d46	68		pla				pla 								; get required count back.
.018d47	49 ff		eor #$ff			eor 	#$FF 						; negate 2's complement.
.018d49	1a		inc a				inc 	a
.018d4a	18		clc				clc
.018d4b	65 20		adc $20				adc 	zTempStr 					; "add" to the temp string pointer
.018d4d	85 20		sta $20				sta 	zTempStr
.018d4f	a9 ff		lda #$ff			lda 	#$FF
.018d51	65 21		adc $21				adc 	zTempStr+1
.018d53	85 21		sta $21				sta 	zTempStr+1
.018d55	a9 00		lda #$00			lda 	#0 							; clear temp string.
.018d57	5a		phy				phy
.018d58	a8		tay				tay
.018d59	91 20		sta ($20),y			sta 	(zTempStr),y
.018d5b	7a		ply				ply
.018d5c	1a		inc a				inc 	a 							; reset the write index.
.018d5d	8d 27 04	sta $0427			sta 	TempStringWriteIndex
.018d60	60		rts				rts
.018d61					WriteTempString:
.018d61	5a		phy				phy 								; save Y
.018d62	ac 27 04	ldy $0427			ldy 	TempStringWriteIndex	 	; write position.
.018d65	91 20		sta ($20),y			sta 	(zTempStr),y 				; write character out.
.018d67	ee 27 04	inc $0427			inc 	TempStringWriteIndex 		; increment the write position.
.018d6a	98		tya				tya 								; unchanged Y is now length
.018d6b	a0 00		ldy #$00			ldy 	#0
.018d6d	91 20		sta ($20),y			sta 	(zTempStr),y
.018d6f	7a		ply				ply 								; restore Y and exit
.018d70	60		rts				rts
.018d71					CreateTempStringCopy:
.018d71	da		phx				phx 								; save X
.018d72	b1 16		lda ($16),y			lda 	(zCodePtr),y
.018d74	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.018d75	20 36 8d	jsr $018d36			jsr 	AllocateTempString 			; allocate memory for temporary string.
.018d78	b1 16		lda ($16),y			lda 	(zCodePtr),y
.018d7a	c8		iny				iny
.018d7b	3a		dec a				dec 	a 							; make the actual length in charactes
.018d7c	3a		dec a				dec 	a
.018d7d	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.018d7f	81 20		sta ($20,x)			sta 	(zTempStr,x)
.018d81	85 1a		sta $1a				sta 	zLTemp1 					; that's used as a count.
.018d83	09 00		ora #$00			ora 	#0 							; if zero already, exit
.018d85	f0 0d		beq $018d94			beq 	_CTSCExit
.018d87					_CTSCLoop:
.018d87	b1 16		lda ($16),y			lda 	(zCodePtr),y
.018d89	c8		iny				iny
.018d8a	5a		phy				phy 								; save in Y
.018d8b	e8		inx				inx 								; bump index
.018d8c	9b		txy				txy 								; index into Y
.018d8d	91 20		sta ($20),y			sta 	(zTempStr),y 				; save at index
.018d8f	7a		ply				ply 								; restore Y
.018d90	c6 1a		dec $1a				dec 	zLTemp1 					; do for each character
.018d92	d0 f3		bne $018d87			bne 	_CTSCLoop
.018d94					_CTSCExit:
.018d94	fa		plx				plx 								; restore X
.018d95	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.018d96					MulInteger32:
.018d96	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.018d99	9d 14 03	sta $0314,x			sta 	XS3_Mantissa,x
.018d9c	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018d9f	9d 15 03	sta $0315,x			sta 	XS3_Mantissa+1,x
.018da2	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018da5	9d 16 03	sta $0316,x			sta 	XS3_Mantissa+2,x
.018da8	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.018dab	9d 17 03	sta $0317,x			sta 	XS3_Mantissa+3,x
.018dae	a9 00		lda #$00			lda 	#0
.018db0	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x 				; zero +0
.018db3	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018db6	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018db9	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018dbc					_BFMMultiply:
.018dbc	bd 14 03	lda $0314,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.018dbf	29 01		and #$01			and 	#1
.018dc1	f0 03		beq $018dc6			beq 	_BFMNoAdd
.018dc3	20 8e 88	jsr $01888e			jsr 	AddInteger32
.018dc6					_BFMNoAdd:
.018dc6	1e 0e 03	asl $030e,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.018dc9	3e 0f 03	rol $030f,x			rol 	XS2_Mantissa+1,x
.018dcc	3e 10 03	rol $0310,x			rol 	XS2_Mantissa+2,x
.018dcf	3e 11 03	rol $0311,x			rol 	XS2_Mantissa+3,x
.018dd2	5e 17 03	lsr $0317,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.018dd5	7e 16 03	ror $0316,x			ror 	XS3_Mantissa+2,x
.018dd8	7e 15 03	ror $0315,x			ror 	XS3_Mantissa+1,x
.018ddb	7e 14 03	ror $0314,x			ror 	XS3_Mantissa,x
.018dde	bd 14 03	lda $0314,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.018de1	1d 15 03	ora $0315,x			ora 	XS3_Mantissa+1,x
.018de4	1d 16 03	ora $0316,x			ora 	XS3_Mantissa+2,x
.018de7	1d 17 03	ora $0317,x			ora 	XS3_Mantissa+3,x
.018dea	d0 d0		bne $018dbc			bne 	_BFMMultiply
.018dec	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.018ded					DivInteger32:
.018ded	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; check for /0
.018df0	1d 0f 03	ora $030f,x			ora 	XS2_Mantissa+1,x
.018df3	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.018df6	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.018df9	d0 14		bne $018e0f			bne 	_BFDOkay
.018dfb	20 21 84	jsr $018421			jsr ERR_Handler
>018dfe	44 69 76 69 73 69 6f 6e			.text "Division by Zero",0
>018e06	20 62 79 20 5a 65 72 6f 00
.018e0f					_BFDOkay:
.018e0f	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.018e11	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.018e13	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.018e15	85 1c		sta $1c				sta 	zLTemp1+2
.018e17	85 1d		sta $1d				sta 	zLTemp1+3
.018e19	8d 25 04	sta $0425			sta 	SignCount 					; Count of signs.
.018e1c	20 7d 8e	jsr $018e7d			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.018e1f	da		phx				phx
.018e20	e8		inx				inx
.018e21	e8		inx				inx
.018e22	e8		inx				inx
.018e23	e8		inx				inx
.018e24	e8		inx				inx
.018e25	e8		inx				inx
.018e26	20 7d 8e	jsr $018e7d			jsr 	CheckIntegerNegate
.018e29	fa		plx				plx
.018e2a	5a		phy				phy 								; Y is the counter
.018e2b	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.018e2d					_BFDLoop:
.018e2d	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.018e30	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.018e33	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.018e36	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.018e39	26 1a		rol $1a				rol 	zLTemp1
.018e3b	26 1b		rol $1b				rol 	zLTemp1+1
.018e3d	26 1c		rol $1c				rol 	zLTemp1+2
.018e3f	26 1d		rol $1d				rol 	zLTemp1+3
.018e41	38		sec				sec
.018e42	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.018e44	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.018e47	48		pha				pha
.018e48	a5 1b		lda $1b				lda 	zLTemp1+1
.018e4a	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.018e4d	48		pha				pha
.018e4e	a5 1c		lda $1c				lda 	zLTemp1+2
.018e50	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.018e53	48		pha				pha
.018e54	a5 1d		lda $1d				lda 	zLTemp1+3
.018e56	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.018e59	90 15		bcc $018e70			bcc 	_BFDNoAdd
.018e5b	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.018e5d	68		pla				pla
.018e5e	85 1c		sta $1c				sta 	zLTemp1+2
.018e60	68		pla				pla
.018e61	85 1b		sta $1b				sta 	zLTemp1+1
.018e63	68		pla				pla
.018e64	85 1a		sta $1a				sta 	zLTemp1+0
.018e66	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.018e69	09 01		ora #$01			ora 	#1
.018e6b	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018e6e	80 03		bra $018e73			bra 	_BFDNext
.018e70					_BFDNoAdd:
.018e70	68		pla				pla 								; Throw away the intermediate calculations
.018e71	68		pla				pla
.018e72	68		pla				pla
.018e73					_BFDNext:
.018e73	88		dey				dey
.018e74	d0 b7		bne $018e2d			bne 	_BFDLoop
.018e76	7a		ply				ply 								; restore Y and exit
.018e77	4e 25 04	lsr $0425			lsr 	SignCount 					; if sign count odd,
.018e7a	b0 07		bcs $018e83			bcs		IntegerNegateAlways 			; negate the result
.018e7c	60		rts				rts
.018e7d					CheckIntegerNegate:
.018e7d	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.018e80	30 01		bmi $018e83			bmi 	IntegerNegateAlways
.018e82	60		rts				rts
.018e83					IntegerNegateAlways:
.018e83	ee 25 04	inc $0425			inc 	SignCount
.018e86	38		sec				sec
.018e87	a9 00		lda #$00			lda 	#0
.018e89	fd 08 03	sbc $0308,x			sbc 	XS_Mantissa+0,x
.018e8c	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018e8f	a9 00		lda #$00			lda 	#0
.018e91	fd 09 03	sbc $0309,x			sbc 	XS_Mantissa+1,x
.018e94	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018e97	a9 00		lda #$00			lda 	#0
.018e99	fd 0a 03	sbc $030a,x			sbc 	XS_Mantissa+2,x
.018e9c	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018e9f	a9 00		lda #$00			lda 	#0
.018ea1	fd 0b 03	sbc $030b,x			sbc 	XS_Mantissa+3,x
.018ea4	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018ea7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.018ea8					INTToString:
.018ea8	48		pha				pha
.018ea9	5a		phy				phy
.018eaa	bd 0b 03	lda $030b,x			lda 		XS_Mantissa+3,x 		; check -ve
.018ead	10 08		bpl $018eb7			bpl 		_ITSNotMinus
.018eaf	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.018eb1	20 4a 8f	jsr $018f4a			jsr 		ITSOutputCharacter
.018eb4	20 83 8e	jsr $018e83			jsr 		IntegerNegateAlways 	; negate the number.
.018eb7					_ITSNotMinus:
.018eb7	a9 00		lda #$00			lda 		#0
.018eb9	8d 21 04	sta $0421			sta 		NumSuppress 			; clear the suppression flag.
.018ebc	9b		txy				txy 								; use Y for the mantissa index.
.018ebd	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.018ebf					_ITSNextSubtractor:
.018ebf	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.018ec1	8d 22 04	sta $0422			sta 		NumConvCount
.018ec4					_ITSSubtract:
.018ec4	38		sec				sec
.018ec5	b9 08 03	lda $0308,y			lda 		XS_Mantissa,y 			; subtract number and push on stack
.018ec8	ff 26 8f 01	sbc $018f26,x			sbc 		_ITSSubtractors+0,x
.018ecc	48		pha				pha
.018ecd	b9 09 03	lda $0309,y			lda 		XS_Mantissa+1,y
.018ed0	ff 27 8f 01	sbc $018f27,x			sbc 		_ITSSubtractors+1,x
.018ed4	48		pha				pha
.018ed5	b9 0a 03	lda $030a,y			lda 		XS_Mantissa+2,y
.018ed8	ff 28 8f 01	sbc $018f28,x			sbc 		_ITSSubtractors+2,x
.018edc	48		pha				pha
.018edd	b9 0b 03	lda $030b,y			lda 		XS_Mantissa+3,y
.018ee0	ff 29 8f 01	sbc $018f29,x			sbc 		_ITSSubtractors+3,x
.018ee4	90 14		bcc $018efa			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.018ee6	99 0b 03	sta $030b,y			sta 		XS_Mantissa+3,y 		; save subtract off stack
.018ee9	68		pla				pla
.018eea	99 0a 03	sta $030a,y			sta 		XS_Mantissa+2,y
.018eed	68		pla				pla
.018eee	99 09 03	sta $0309,y			sta 		XS_Mantissa+1,y
.018ef1	68		pla				pla
.018ef2	99 08 03	sta $0308,y			sta 		XS_Mantissa+0,y
.018ef5	ee 22 04	inc $0422			inc 		NumConvCount 			; bump count.
.018ef8	80 ca		bra $018ec4			bra 		_ITSSubtract 			; go round again.
.018efa					_ITSCantSubtract:
.018efa	68		pla				pla 								; throw away interim answers
.018efb	68		pla				pla
.018efc	68		pla				pla
.018efd	ad 22 04	lda $0422			lda 		NumConvCount 			; if not zero then no suppression check
.018f00	c9 30		cmp #$30			cmp 		#"0"
.018f02	d0 05		bne $018f09			bne 		_ITSOutputDigit
.018f04	ad 21 04	lda $0421			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.018f07	10 09		bpl $018f12			bpl 		_ITSGoNextSubtractor
.018f09					_ITSOutputDigit:
.018f09	ce 21 04	dec $0421			dec 		NumSuppress 			; suppression check will be non-zero.
.018f0c	ad 22 04	lda $0422			lda 		NumConvCount 			; count of subtractions
.018f0f	20 4a 8f	jsr $018f4a			jsr 		ITSOutputCharacter 		; output it.
.018f12					_ITSGoNextSubtractor:
.018f12	e8		inx				inx 								; next dword
.018f13	e8		inx				inx
.018f14	e8		inx				inx
.018f15	e8		inx				inx
.018f16	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.018f18	d0 a5		bne $018ebf			bne 		_ITSNextSubtractor 		; do all the subtractors.
.018f1a	bb		tyx				tyx 								; X is back as the mantissa index
.018f1b	bd 08 03	lda $0308,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.018f1e	09 30		ora #$30			ora 		#"0"
.018f20	20 4a 8f	jsr $018f4a			jsr 		ITSOutputCharacter
.018f23	7a		ply				ply 								; and exit
.018f24	68		pla				pla
.018f25	60		rts				rts
.018f26					_ITSSubtractors:
>018f26	00 ca 9a 3b					.dword 		1000000000
>018f2a	00 e1 f5 05					.dword 		100000000
>018f2e	80 96 98 00					.dword 		10000000
>018f32	40 42 0f 00					.dword 		1000000
>018f36	a0 86 01 00					.dword 		100000
>018f3a	10 27 00 00					.dword 		10000
>018f3e	e8 03 00 00					.dword 		1000
>018f42	64 00 00 00					.dword 		100
>018f46	0a 00 00 00					.dword 		10
.018f4a					_ITSSubtractorsEnd:
.018f4a					ITSOutputCharacter:
.018f4a	48		pha				pha
.018f4b	da		phx				phx
.018f4c	ae 20 04	ldx $0420			ldx 	NumBufX 					; save digit
.018f4f	9d 00 04	sta $0400,x			sta 	Num_Buffer,x
.018f52	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.018f54	9d 01 04	sta $0401,x			sta 	Num_Buffer+1,x
.018f57	ee 20 04	inc $0420			inc 	NumBufX						; bump pointer.
.018f5a	fa		plx				plx
.018f5b	68		pla				pla
.018f5c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.018f5d					IntFromString:
.018f5d	a0 00		ldy #$00			ldy 	#0
.018f5f	8c 23 04	sty $0423			sty 	ExpTemp 					; this is the converted digit count.
.018f62					IntFromStringY:
.018f62	48		pha				pha
.018f63	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.018f65	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.018f68	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018f6b	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018f6e	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018f71	a9 01		lda #$01			lda 	#1
.018f73	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018f76					_IFSLoop:
.018f76	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.018f78	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.018f7a	90 60		bcc $018fdc			bcc 	_IFSExit
.018f7c	c9 3a		cmp #$3a			cmp 	#"9"+1
.018f7e	b0 5c		bcs $018fdc			bcs 	_IFSExit
.018f80	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.018f83	c9 0c		cmp #$0c			cmp 	#12
.018f85	b0 5f		bcs $018fe6			bcs 	_IFSOverflow
.018f87	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.018f8a	48		pha				pha
.018f8b	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018f8e	48		pha				pha
.018f8f	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018f92	48		pha				pha
.018f93	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018f96	48		pha				pha
.018f97	20 fb 8f	jsr $018ffb			jsr 	IFSX1ShiftLeft 				; double
.018f9a	20 fb 8f	jsr $018ffb			jsr 	IFSX1ShiftLeft 				; x 4
.018f9d	18		clc				clc 								; add saved value x 5
.018f9e	68		pla				pla
.018f9f	7d 08 03	adc $0308,x			adc 	XS_Mantissa+0,x
.018fa2	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018fa5	68		pla				pla
.018fa6	7d 09 03	adc $0309,x			adc 	XS_Mantissa+1,x
.018fa9	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018fac	68		pla				pla
.018fad	7d 0a 03	adc $030a,x			adc 	XS_Mantissa+2,x
.018fb0	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018fb3	68		pla				pla
.018fb4	7d 0b 03	adc $030b,x			adc 	XS_Mantissa+3,x
.018fb7	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018fba	20 fb 8f	jsr $018ffb			jsr 	IFSX1ShiftLeft 				; x 10
.018fbd	ee 23 04	inc $0423			inc 	ExpTemp 					; bump count of digits processed.
.018fc0	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.018fc2	29 0f		and #$0f			and 	#15
.018fc4	c8		iny				iny
.018fc5	7d 08 03	adc $0308,x			adc 	XS_Mantissa+0,x
.018fc8	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018fcb	90 a9		bcc $018f76			bcc 	_IFSLoop
.018fcd	fe 09 03	inc $0309,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.018fd0	d0 a4		bne $018f76			bne 	_IFSLoop
.018fd2	fe 0a 03	inc $030a,x			inc 	XS_Mantissa+2,x
.018fd5	d0 9f		bne $018f76			bne 	_IFSLoop
.018fd7	fe 0b 03	inc $030b,x			inc 	XS_Mantissa+3,x
.018fda	80 9a		bra $018f76			bra 	_IFSLoop
.018fdc					_IFSExit:
.018fdc	98		tya				tya 								; get offset
.018fdd					_IFSOkay:
.018fdd	38		sec				sec
.018fde	ad 23 04	lda $0423			lda 	ExpTemp
.018fe1	f0 01		beq $018fe4			beq 	_IFSSkipFail
.018fe3	18		clc				clc
.018fe4					_IFSSkipFail:
.018fe4	68		pla				pla 								; and exit.
.018fe5	60		rts				rts
.018fe6					_IFSOverflow:
.018fe6	20 21 84	jsr $018421			jsr 	ERR_Handler
>018fe9	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>018ff1	20 6f 76 65 72 66 6c 6f 77 00
.018ffb					IFSX1ShiftLeft:
.018ffb	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x
.018ffe	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.019001	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.019004	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.019007	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.019008					FPSubtract:
.019008	48		pha				pha
.019009	bd 13 03	lda $0313,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.01900c	49 80		eor #$80			eor 	#$80
.01900e	9d 13 03	sta $0313,x			sta 	XS2_Type,x
.019011	68		pla				pla 								; --- and fall through ---
.019012					FPAdd:
.019012	48		pha				pha
.019013	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.019016	d0 05		bne $01901d			bne 	_FPA_NegativeLHS
.019018	20 3a 90	jsr $01903a			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.01901b	68		pla				pla
.01901c	60		rts				rts
.01901d					_FPA_NegativeLHS:
.01901d	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.019020	49 80		eor #$80			eor 	#$80
.019022	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019025	bd 13 03	lda $0313,x			lda 	XS2_Type,x 					; flip the sign of B and add
.019028	49 80		eor #$80			eor 	#$80
.01902a	9d 13 03	sta $0313,x			sta 	XS2_Type,x
.01902d	20 3a 90	jsr $01903a			jsr 	FPAdd_Worker 				; do the add calculation.
.019030	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip sign of X1 back
.019033	49 80		eor #$80			eor 	#$80
.019035	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019038	68		pla				pla
.019039	60		rts				rts
.01903a					FPAdd_Worker:
.01903a	3c 13 03	bit $0313,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.01903d	70 08		bvs $019047			bvs 	_FPAWExit 					; no change.
.01903f	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.019042	50 07		bvc $01904b			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.019044	20 df 92	jsr $0192df			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.019047					_FPAWExit:
.019047	20 67 93	jsr $019367			jsr 	FPUNormalise 				; normalise the result.
.01904a	60		rts				rts
.01904b					_FPAWMakeSame:
.01904b	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.01904e	38		sec				sec
.01904f	fd 12 03	sbc $0312,x			sbc	 	XS2_Exponent,x 				; using subtraction
.019052	f0 1b		beq $01906f			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.019054	da		phx				phx 								; save X
.019055	90 06		bcc $01905d			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.019057	e8		inx				inx
.019058	e8		inx				inx
.019059	e8		inx				inx
.01905a	e8		inx				inx
.01905b	e8		inx				inx
.01905c	e8		inx				inx
.01905d					_FPAWShiftA:
.01905d	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x 				; so shift exponent up.
.019060	5e 0b 03	lsr $030b,x			lsr 	3+XS_Mantissa,x
.019063	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.019066	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.019069	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.01906c	fa		plx				plx 								; restore original X
.01906d	80 dc		bra $01904b			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.01906f					_FPAW_DoArithmetic:
.01906f	3c 13 03	bit $0313,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.019072	30 39		bmi $0190ad			bmi 	_FPAW_BNegative
.019074	18		clc				clc
.019075	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.019078	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.01907b	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.01907e	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.019081	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.019084	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019087	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.01908a	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.01908d	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019090	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.019093	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.019096	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019099	90 ac		bcc $019047			bcc 	_FPAWExit 					; no carry.
.01909b	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x 				; so shift exponent up.
.01909e	38		sec				sec
.01909f	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.0190a2	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.0190a5	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.0190a8	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.0190ab	80 9a		bra $019047			bra 	_FPAWExit
.0190ad					_FPAW_BNegative:
.0190ad	38		sec				sec
.0190ae	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.0190b1	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.0190b4	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0190b7	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0190ba	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.0190bd	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0190c0	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.0190c3	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.0190c6	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0190c9	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.0190cc	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.0190cf	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0190d2	b0 0b		bcs $0190df			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.0190d4	20 0c 93	jsr $01930c			jsr 	FPUNegateInteger			; negate the mantissa
.0190d7	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip result sign
.0190da	49 80		eor #$80			eor 	#$80
.0190dc	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0190df					_FPAWGoExit:
.0190df	4c 47 90	jmp $019047			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.0190e2					FPD_IsDivZero:
.0190e2	20 21 84	jsr $018421			jsr ERR_Handler
>0190e5	44 69 76 69 73 69 6f 6e			.text "Division by zero",0
>0190ed	20 62 79 20 7a 65 72 6f 00
.0190f6					FPDivide:
.0190f6	48		pha				pha
.0190f7	5a		phy				phy
.0190f8	3c 13 03	bit $0313,x			bit 	XS2_Type,x 					; check if division by zero
.0190fb	70 e5		bvs $0190e2			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.0190fd	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.019100	f0 03		beq $019105			beq 	_FPDCalculateExp
.019102					_FPD_Exit:
.019102	7a		ply				ply
.019103	68		pla				pla
.019104	60		rts				rts
.019105					_FPDCalculateExp:
.019105	bd 12 03	lda $0312,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.019108	49 ff		eor #$ff			eor 	#$FF
.01910a	1a		inc a				inc 	a
.01910b	9d 12 03	sta $0312,x			sta 	XS2_Exponent,x
.01910e	20 02 92	jsr $019202			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.019111	18		clc				clc 	 							; add 1 to the resulting exponent
.019112	69 01		adc #$01			adc 	#1
.019114	b0 65		bcs $01917b			bcs 	_FPD_Overflow 				; which can overflow.
.019116	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.019119	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.01911b	85 1a		sta $1a				sta 	zLTemp1+0
.01911d	85 1b		sta $1b				sta 	zLTemp1+1
.01911f	85 1c		sta $1c				sta 	zLTemp1+2
.019121	85 1d		sta $1d				sta 	zLTemp1+3
.019123	a0 20		ldy #$20			ldy 	#32 						; times round.
.019125					_FPD_Loop:
.019125	38		sec				sec 								; calculate X1-X2 stacking result because we might
.019126	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; not save it.
.019129	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa,x
.01912c	48		pha				pha
.01912d	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.019130	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.019133	48		pha				pha
.019134	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.019137	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.01913a	48		pha				pha
.01913b	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.01913e	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.019141	90 17		bcc $01915a			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.019143	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x 			; save results out to A
.019146	68		pla				pla
.019147	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01914a	68		pla				pla
.01914b	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.01914e	68		pla				pla
.01914f	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019152	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.019154	09 80		ora #$80			ora 	#$80
.019156	85 1d		sta $1d				sta 	zLTemp1+3
.019158	80 03		bra $01915d			bra 	_FPD_Rotates
.01915a					_FPD_NoSubtract:
.01915a	68		pla				pla 								; throw away unwanted results
.01915b	68		pla				pla
.01915c	68		pla				pla
.01915d					_FPD_Rotates:
.01915d	5e 11 03	lsr $0311,x			lsr 	3+XS2_Mantissa,x
.019160	7e 10 03	ror $0310,x			ror 	2+XS2_Mantissa,x
.019163	7e 0f 03	ror $030f,x			ror 	1+XS2_Mantissa,x
.019166	7e 0e 03	ror $030e,x			ror 	0+XS2_Mantissa,x
.019169	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.01916b	26 1b		rol $1b				rol 	zLTemp1+1
.01916d	26 1c		rol $1c				rol 	zLTemp1+2
.01916f	26 1d		rol $1d				rol 	zLTemp1+3
.019171	90 02		bcc $019175			bcc 	_FPD_NoCarry
.019173	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.019175					_FPD_NoCarry:
.019175	88		dey				dey 								; do 32 times
.019176	d0 ad		bne $019125			bne 	_FPD_Loop
.019178	4c df 91	jmp $0191df			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.01917b					_FPD_Overflow:
.01917b	4c dc 93	jmp $0193dc			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.01917e					FPMultiply:
.01917e	48		pha				pha
.01917f	5a		phy				phy
.019180	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.019183	70 08		bvs $01918d			bvs 	_FPM_Exit
.019185	3c 13 03	bit $0313,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.019188	50 06		bvc $019190			bvc 	_FPM_CalcExponent
.01918a	20 df 92	jsr $0192df			jsr 	FPUCopyX2ToX1
.01918d					_FPM_Exit:
.01918d	7a		ply				ply
.01918e	68		pla				pla
.01918f	60		rts				rts
.019190					_FPM_CalcExponent:
.019190	18		clc				clc
.019191	20 02 92	jsr $019202			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.019194	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x 				; save the result.
.019197	a9 00		lda #$00			lda 	#0
.019199	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.01919b	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.01919d	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.01919f	85 1d		sta $1d				sta 	zLTemp1+3
.0191a1	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.0191a3					_FPM_Loop:
.0191a3	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x				; check LSB of long product
.0191a6	29 01		and #$01			and 	#1
.0191a8	18		clc				clc 								; clear carry for the long rotate.
.0191a9	f0 1d		beq $0191c8			beq 	_FPM_NoAddition
.0191ab	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.0191ac	a5 1a		lda $1a				lda 	zLTemp1+0
.0191ae	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.0191b1	85 1a		sta $1a				sta 	zLTemp1+0
.0191b3	a5 1b		lda $1b				lda 	zLTemp1+1
.0191b5	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.0191b8	85 1b		sta $1b				sta 	zLTemp1+1
.0191ba	a5 1c		lda $1c				lda 	zLTemp1+2
.0191bc	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.0191bf	85 1c		sta $1c				sta 	zLTemp1+2
.0191c1	a5 1d		lda $1d				lda 	zLTemp1+3
.0191c3	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.0191c6	85 1d		sta $1d				sta 	zLTemp1+3
.0191c8					_FPM_NoAddition:
.0191c8	66 1d		ror $1d				ror 	3+zLTemp1
.0191ca	66 1c		ror $1c				ror 	2+zLTemp1
.0191cc	66 1b		ror $1b				ror 	1+zLTemp1
.0191ce	66 1a		ror $1a				ror 	0+zLTemp1
.0191d0	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.0191d3	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.0191d6	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.0191d9	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.0191dc	88		dey				dey
.0191dd	d0 c4		bne $0191a3			bne 	_FPM_Loop 					; do this 32 times.
.0191df					FPM_CopySignNormalize:
.0191df	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.0191e1	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.0191e4	a5 1b		lda $1b				lda 	zLTemp1+1
.0191e6	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0191e9	a5 1c		lda $1c				lda 	zLTemp1+2
.0191eb	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0191ee	a5 1d		lda $1d				lda 	zLTemp1+3
.0191f0	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0191f3	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; sign is xor of signs
.0191f6	5d 13 03	eor $0313,x			eor 	XS2_Type,x
.0191f9	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0191fc	20 67 93	jsr $019367			jsr 	FPUNormalise 				; normalise and exit.
.0191ff	7a		ply				ply
.019200	68		pla				pla
.019201	60		rts				rts
.019202					FPCalculateExponent:
.019202	18		clc				clc
.019203	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.019206	7d 12 03	adc $0312,x			adc 	XS2_Exponent,x
.019209	b0 08		bcs $019213			bcs 	_FPCECarry 					; carry out ?
.01920b	10 03		bpl $019210			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.01920d	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.01920f	60		rts				rts
.019210					_FPCEExpZero:
.019210	a9 00		lda #$00			lda 	#0
.019212	60		rts				rts
.019213					_FPCECarry:
.019213	30 03		bmi $019218			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.019215	09 80		ora #$80			ora 	#$80 						; put in right range
.019217	60		rts				rts
.019218					_FPCEOverflow:
.019218	4c dc 93	jmp $0193dc			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.01921b					FPFractionalPart:
.01921b	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.01921e	38		sec				sec 								; this flag tells us to keep the fractional part
.01921f	30 0f		bmi $019230			bmi 	FPGetPart
.019221	60		rts				rts
.019222					FPIntegerPart:
.019222	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.019225	18		clc				clc 								; this flag says keep the integer part.
.019226	30 08		bmi $019230			bmi 	FPGetPart 					; -ve exponents are 0..127
.019228	48		pha				pha
.019229	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.01922b	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.01922e	68		pla				pla
.01922f	60		rts				rts
.019230					FPGetPart:
.019230	48		pha				pha
.019231	5a		phy				phy 								; save Y
.019232	08		php				php 								; save action
.019233	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.019236	70 62		bvs $01929a			bvs 	_FPGP_Exit 					; then do nothing.
.019238	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.01923a	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.01923c	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.01923e	85 1c		sta $1c				sta 	zLTemp1+2
.019240	85 1d		sta $1d				sta 	zLTemp1+3
.019242	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x				; the number of shifts.
.019245	38		sec				sec
.019246	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.019248	f0 12		beq $01925c			beq 	_FPGP_NoShift 				; ... if any
.01924a	c9 20		cmp #$20			cmp 	#32
.01924c	90 02		bcc $019250			bcc 	_FPGP_NotMax
.01924e	a9 20		lda #$20			lda 	#32 						; max of 32.
.019250					_FPGP_NotMax:
.019250	a8		tay				tay 								; Y is the mask shift count.
.019251					_FPGP_ShiftMask:
.019251	46 1d		lsr $1d				lsr 	3+zLTemp1
.019253	66 1c		ror $1c				ror 	2+zLTemp1
.019255	66 1b		ror $1b				ror 	1+zLTemp1
.019257	66 1a		ror $1a				ror 	0+zLTemp1
.019259	88		dey				dey
.01925a	d0 f5		bne $019251			bne 	_FPGP_ShiftMask
.01925c					_FPGP_NoShift:
.01925c	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.01925e	8e 23 04	stx $0423			stx 	ExpTemp						; save X
.019261					_FPGP_MaskLoop:
.019261	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.019264	28		plp				plp 								; if CC we keep the top part, so we
.019265	08		php				php		 							; flip the mask.
.019266	b0 02		bcs $01926a			bcs		_FPGP_NoFlip
.019268	49 ff		eor #$ff			eor 	#$FF
.01926a					_FPGP_NoFlip:
.01926a	3d 08 03	and $0308,x			and 	XS_Mantissa,x 				; and into the mantissa.
.01926d	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.019270	e8		inx				inx
.019271	c8		iny				iny
.019272	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.019274	d0 eb		bne $019261			bne 	_FPGP_MaskLoop
.019276	ae 23 04	ldx $0423			ldx 	ExpTemp						; restore X
.019279	28		plp				plp
.01927a	08		php				php 								; get action flag on the stack
.01927b	90 05		bcc $019282			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.01927d	a9 00		lda #$00			lda 	#0
.01927f	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019282					_FPGP_NotFractional:
.019282	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 						; check if \1 zero
.019285	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.019288	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.01928b	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.01928e	f0 05		beq $019295			beq 	_FPGP_Zero 					; if zero, return zero
.019290	20 67 93	jsr $019367			jsr 	FPUNormalise
.019293	80 05		bra $01929a			bra 	_FPGP_Exit 					; and exit
.019295					_FPGP_Zero:
.019295	a9 40		lda #$40			lda 	#$40 						; set zero flag
.019297	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.01929a					_FPGP_Exit:
.01929a	68		pla				pla 								; throw saved action flag.
.01929b	7a		ply				ply
.01929c	68		pla				pla
.01929d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.01929e					FPCompare:
.01929e	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.0192a1	48		pha				pha
.0192a2	bd 12 03	lda $0312,x			lda 	XS2_Exponent,x
.0192a5	48		pha				pha
.0192a6	20 08 90	jsr $019008			jsr 	FPSubtract 					; calculate X1-X2
.0192a9	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.0192ac	70 2c		bvs $0192da			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.0192ae	68		pla				pla
.0192af	8d 23 04	sta $0423			sta 	ExpTemp						; save first exponent in temporary reg.
.0192b2	68		pla				pla
.0192b3	38		sec				sec
.0192b4	ed 23 04	sbc $0423			sbc 	ExpTemp 					; calculate AX-BX
.0192b7	70 15		bvs $0192ce			bvs 	_FPCNotEqual				; overflow, can't be equal.
.0192b9	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.0192ba	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.0192bc	b0 10		bcs $0192ce			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.0192be	38		sec				sec
.0192bf	ad 23 04	lda $0423			lda 	ExpTemp 					; get one of the exponents back.
.0192c2	e9 18		sbc #$18			sbc 	#24 						; allow for 2^24 error, relatively.
.0192c4	b0 02		bcs $0192c8			bcs 	_FPCNotRange 				; keep in range.
.0192c6	a9 01		lda #$01			lda 	#1
.0192c8					_FPCNotRange:
.0192c8	38		sec				sec
.0192c9	fd 0c 03	sbc $030c,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.0192cc	b0 0e		bcs $0192dc			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.0192ce					_FPCNotEqual:
.0192ce	bd 0d 03	lda $030d,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.0192d1	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.0192d3	f0 02		beq $0192d7			beq 	_FPCNE2
.0192d5	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.0192d7	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.0192d8	80 04		bra $0192de			bra 	_FPCExit
.0192da					_FPCPullZero:
.0192da	68		pla				pla 								; throw saved exponents
.0192db	68		pla				pla
.0192dc					_FPCZero:
.0192dc	a9 00		lda #$00			lda 	#0 							; and return zero
.0192de					_FPCExit:
.0192de	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.0192df					FPUCopyX2ToX1:
.0192df	48		pha				pha
.0192e0	da		phx				phx
.0192e1	5a		phy				phy
.0192e2	a0 08		ldy #$08			ldy 	#8
.0192e4	bd 0e 03	lda $030e,x	_FPUC21:lda 	XS2_Mantissa,x
.0192e7	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.0192ea	e8		inx				inx
.0192eb	88		dey				dey
.0192ec	10 f6		bpl $0192e4			bpl 	_FPUC21
.0192ee	7a		ply				ply
.0192ef	fa		plx				plx
.0192f0	68		pla				pla
.0192f1	60		rts				rts
.0192f2					FPUSetInteger:
.0192f2	48		pha				pha
.0192f3	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.0192f6	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.0192f8	10 02		bpl $0192fc			bpl 	_FPUSIExtend
.0192fa	a9 ff		lda #$ff			lda 	#$FF
.0192fc					_FPUSIExtend:
.0192fc	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.0192ff	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019302	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019305	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.019307	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.01930a	68		pla				pla
.01930b	60		rts				rts
.01930c					FPUNegateInteger:
.01930c	48		pha				pha
.01930d	38		sec				sec
.01930e	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.019310	fd 08 03	sbc $0308,x			sbc 	XS_Mantissa+0,x
.019313	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019316	a9 00		lda #$00			lda 	#0
.019318	fd 09 03	sbc $0309,x			sbc 	XS_Mantissa+1,x
.01931b	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.01931e	a9 00		lda #$00			lda 	#0
.019320	fd 0a 03	sbc $030a,x			sbc 	XS_Mantissa+2,x
.019323	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019326	a9 00		lda #$00			lda 	#0
.019328	fd 0b 03	sbc $030b,x			sbc 	XS_Mantissa+3,x
.01932b	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.01932e	68		pla				pla
.01932f	60		rts				rts
.019330					FPUToFloat:
.019330	48		pha				pha
.019331	bd 0d 03	lda $030d,x			lda 	XS_Type,x					; exit if already float.
.019334	29 0f		and #$0f			and 	#$0F
.019336	f0 2d		beq $019365			beq 	_FPUFExit
.019338	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.01933a	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.01933d	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.01933f	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x 				; x mantissa.
.019342	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.019345	10 08		bpl $01934f			bpl		_FPUFPositive
.019347	20 0c 93	jsr $01930c			jsr 	FPUNegateInteger 			; negate the mantissa
.01934a	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.01934c	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.01934f					_FPUFPositive:
.01934f	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.019352	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.019355	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.019358	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.01935b	d0 05		bne $019362			bne 	_FPUFNonZero
.01935d	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.01935f	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019362					_FPUFNonZero:
.019362	20 67 93	jsr $019367			jsr 	FPUNormalise 				; normalise the floating point.
.019365					_FPUFExit:
.019365	68		pla				pla
.019366	60		rts				rts
.019367					FPUNormalise:
.019367	48		pha				pha
.019368	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.01936b	70 20		bvs $01938d			bvs 	_FPUNExit
.01936d	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.019370	f0 16		beq $019388			beq 	_FPUNSetZero
.019372					_FPUNLoop:
.019372	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.019375	30 16		bmi $01938d			bmi 	_FPUNExit 					; if so, we are normalised.
.019377	1e 08 03	asl $0308,x			asl 	0+XS_Mantissa+0,x
.01937a	3e 09 03	rol $0309,x			rol 	1+XS_Mantissa+0,x
.01937d	3e 0a 03	rol $030a,x			rol 	2+XS_Mantissa+0,x
.019380	3e 0b 03	rol $030b,x			rol 	3+XS_Mantissa+0,x
.019383	de 0c 03	dec $030c,x			dec 	XS_Exponent,x 				; decrement exponent
.019386	d0 ea		bne $019372			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.019388					_FPUNSetZero:
.019388	a9 40		lda #$40			lda 	#$40
.01938a	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; the result is now zero.
.01938d					_FPUNExit:
.01938d	68		pla				pla
.01938e	60		rts				rts
.01938f					FPUToInteger:
.01938f	48		pha				pha
.019390	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; if already integer, exit
.019393	29 01		and #$01			and 	#1
.019395	d0 3e		bne $0193d5			bne 	_FPUTOI_Exit
.019397	3c 0d 03	bit $030d,x			bit 	XS_Type,x					; if zero, return zero.
.01939a	70 2b		bvs $0193c7			bvs 	_FPUTOI_Zero
.01939c	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.01939f	10 26		bpl $0193c7			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.0193a1	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.0193a3	b0 37		bcs $0193dc			bcs 	FP_Overflow
.0193a5					_FPUToIToInteger:
.0193a5	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.0193a8	c9 a0		cmp #$a0			cmp 	#128+32
.0193aa	f0 11		beq $0193bd			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.0193ac	fe 0c 03	inc $030c,x			inc 	XS_Exponent,X 				; increment Exponent
.0193af	5e 0b 03	lsr $030b,x			lsr 	3+XS_Mantissa,x
.0193b2	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.0193b5	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.0193b8	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.0193bb	80 e8		bra $0193a5			bra 	_FPUToIToInteger 			; keep going.
.0193bd					_FPUToICheckSign:
.0193bd	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; check sign
.0193c0	10 13		bpl $0193d5			bpl 	_FPUToI_Exit 				; exit if unsigned.
.0193c2	20 0c 93	jsr $01930c			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.0193c5	80 0e		bra $0193d5			bra 	_FPUTOI_Exit
.0193c7					_FPUTOI_Zero:
.0193c7	a9 00		lda #$00			lda 	#0 							; return zero integer.
.0193c9	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0193cc	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0193cf	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0193d2	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0193d5					_FPUToI_Exit:
.0193d5	a9 01		lda #$01			lda 	#1 							; set type to integer
.0193d7	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0193da	68		pla				pla
.0193db	60		rts				rts
.0193dc					FP_Overflow:
.0193dc	20 21 84	jsr $018421			jsr ERR_Handler
>0193df	46 6c 6f 61 74 69 6e 67			.text "Floating Point overflow",0
>0193e7	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.0193f7					FPUTimes10:
.0193f7	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.0193fa	85 1a		sta $1a				sta 	ZLTemp1+0
.0193fc	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0193ff	85 1b		sta $1b				sta 	ZLTemp1+1
.019401	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.019404	85 1c		sta $1c				sta 	ZLTemp1+2
.019406	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.019409	85 1d		sta $1d				sta 	ZLTemp1+3
.01940b	20 4f 94	jsr $01944f			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.01940e	20 4f 94	jsr $01944f			jsr 	_FPUT_LSR_ZLTemp1
.019411	18		clc				clc
.019412	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.019415	65 1a		adc $1a				adc 	ZLTemp1+0
.019417	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.01941a	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.01941d	65 1b		adc $1b				adc 	ZLTemp1+1
.01941f	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019422	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.019425	65 1c		adc $1c				adc 	ZLTemp1+2
.019427	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01942a	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.01942d	65 1d		adc $1d				adc 	ZLTemp1+3
.01942f	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019432	90 0f		bcc $019443			bcc 	_FPUTimes10
.019434	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.019437	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.01943a	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.01943d	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.019440	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x				; fix exponent
.019443					_FPUTimes10:
.019443	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.019446	18		clc				clc
.019447	69 03		adc #$03			adc 	#3
.019449	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.01944c	b0 8e		bcs $0193dc			bcs 	FP_Overflow 				; error
.01944e	60		rts				rts
.01944f					_FPUT_LSR_ZLTemp1:
.01944f	46 1d		lsr $1d				lsr 	ZLTemp1+3
.019451	66 1c		ror $1c				ror 	ZLTemp1+2
.019453	66 1b		ror $1b				ror 	ZLTemp1+1
.019455	66 1a		ror $1a				ror 	ZLTemp1+0
.019457	60		rts				rts
.019458					FPUScale10A:
.019458	5a		phy				phy
.019459	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.01945b	f0 3d		beq $01949a			beq 	_FPUScaleExit
.01945d	da		phx				phx 								; save X
.01945e	e8		inx				inx
.01945f	e8		inx				inx
.019460	e8		inx				inx
.019461	e8		inx				inx
.019462	e8		inx				inx
.019463	e8		inx				inx
.019464	a8		tay				tay 								; save power scalar in Y.
.019465	a9 00		lda #$00			lda 	#0
.019467	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.01946a	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.01946d	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019470	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019473	a9 80		lda #$80			lda 	#$80
.019475	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019478	a9 81		lda #$81			lda 	#$81
.01947a	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.01947d	5a		phy				phy 								; save 10^n on stack.
.01947e	c0 00		cpy #$00			cpy 	#0
.019480	10 05		bpl $019487			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.019482	98		tya				tya
.019483	49 ff		eor #$ff			eor 	#$FF
.019485	1a		inc a				inc 	a
.019486	a8		tay				tay
.019487					_FPUSAbs:
.019487	20 f7 93	jsr $0193f7			jsr 	FPUTimes10
.01948a	88		dey				dey
.01948b	d0 fa		bne $019487			bne 	_FPUSAbs 					; tos is now 10^|AC|
.01948d	68		pla				pla 								; restore count in A
.01948e	fa		plx				plx 								; restore X pointing to number to scale.
.01948f	0a		asl a				asl 	a
.019490	b0 05		bcs $019497			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.019492	20 7e 91	jsr $01917e			jsr 	FPMultiply 					; if clear multiply.
.019495	80 03		bra $01949a			bra		_FPUScaleExit
.019497					_FPUSDivide:
.019497	20 f6 90	jsr $0190f6			jsr 	FPDivide
.01949a					_FPUScaleExit:
.01949a	7a		ply				ply
.01949b	60		rts				rts
.01949c					FPUCopyToNext:
.01949c	a0 06		ldy #$06			ldy 		#6
.01949e	da		phx				phx
.01949f					_FPUCopy1:
.01949f	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x
.0194a2	9d 0e 03	sta $030e,x			sta 	XS2_Mantissa,x
.0194a5	e8		inx				inx
.0194a6	88		dey				dey
.0194a7	d0 f6		bne $01949f			bne 	_FPUCopy1
.0194a9	fa		plx				plx
.0194aa	60		rts				rts
.0194ab					FPUCopyFromNext:
.0194ab	a0 06		ldy #$06			ldy 		#6
.0194ad	da		phx				phx
.0194ae					_FPUCopy1:
.0194ae	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa,x
.0194b1	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.0194b4	e8		inx				inx
.0194b5	88		dey				dey
.0194b6	d0 f6		bne $0194ae			bne 	_FPUCopy1
.0194b8	fa		plx				plx
.0194b9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.0194ba					FPToString:
.0194ba	48		pha				pha
.0194bb	5a		phy				phy
.0194bc	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; check zero flag
.0194bf	50 0a		bvc $0194cb			bvc 		_FPTSIsFloat 			; if zero,
.0194c1					_FPTSZero:
.0194c1	a9 30		lda #$30			lda 		#"0"
.0194c3	20 4a 8f	jsr $018f4a			jsr 		ITSOutputCharacter
.0194c6					_FPTSExit:
.0194c6	7a		ply				ply
.0194c7	68		pla				pla
.0194c8	60		rts				rts
.0194c9	80 fb		bra $0194c6			bra 		_FPTSExit
.0194cb					_FPTSIsFloat:
.0194cb	bd 0d 03	lda $030d,x			lda 		XS_Type,x 				; is it signed ?
.0194ce	10 0a		bpl $0194da			bpl 		_FPTSNotSigned
.0194d0	a9 00		lda #$00			lda 		#0 						; clear sign flag
.0194d2	9d 0d 03	sta $030d,x			sta 		XS_Type,x
.0194d5	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.0194d7	20 4a 8f	jsr $018f4a			jsr 		ITSOutputCharacter
.0194da					_FPTSNotSigned:
.0194da	bd 0c 03	lda $030c,x			lda 		XS_Exponent,x
.0194dd	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.0194df	b0 09		bcs $0194ea			bcs 		_FPTSExponent
.0194e1	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.0194e3	90 05		bcc $0194ea			bcc 		_FPTSExponent 			;
.0194e5					_FPTSStandard:
.0194e5	20 2e 95	jsr $01952e			jsr 		FPTOutputBody 			; output the body.
.0194e8	80 dc		bra $0194c6			bra 		_FPTSExit
.0194ea					_FPTSExponent:
.0194ea	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.0194ec	8d 24 04	sta $0424			sta 		ExpCount
.0194ef					_FPTSExponentLoop:
.0194ef	bd 0c 03	lda $030c,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.0194f2	10 0e		bpl $019502			bpl 		_FPTSTimes
.0194f4	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.0194f6	90 14		bcc $01950c			bcc 		_FPTSScaledToExp
.0194f8	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.0194fa	20 58 94	jsr $019458			jsr 		FPUScale10A
.0194fd	ee 24 04	inc $0424			inc 		ExpCount
.019500	80 ed		bra $0194ef			bra 		_FPTSExponentLoop
.019502					_FPTSTimes:
.019502	a9 01		lda #$01			lda 		#1
.019504	20 58 94	jsr $019458			jsr 		FPUScale10A
.019507	ce 24 04	dec $0424			dec 		ExpCount
.01950a	80 e3		bra $0194ef			bra 		_FPTSExponentLoop
.01950c					_FPTSScaledToExp:
.01950c	20 2e 95	jsr $01952e			jsr 		FPTOutputBody 			; output the body.
.01950f	a9 65		lda #$65			lda 		#"e"					; output E
.019511	20 4a 8f	jsr $018f4a			jsr 		ITSOutputCharacter
.019514	ad 24 04	lda $0424			lda 		ExpCount 				; get the exponent
.019517	9d 08 03	sta $0308,x			sta 		XS_Mantissa,x
.01951a	29 80		and #$80			and 		#$80 					; sign extend it
.01951c	f0 02		beq $019520			beq 		_FPTSSExt
.01951e	a9 ff		lda #$ff			lda 		#$FF
.019520					_FPTSSExt:
.019520	9d 09 03	sta $0309,x			sta 		XS_Mantissa+1,x
.019523	9d 0a 03	sta $030a,x			sta 		XS_Mantissa+2,x
.019526	9d 0b 03	sta $030b,x			sta 		XS_Mantissa+3,x
.019529	20 a8 8e	jsr $018ea8			jsr 		INTToString 			; output the exponent.
.01952c	80 98		bra $0194c6			bra			_FPTSExit 				; and exit.
.01952e					FPTOutputBody:
.01952e	20 9c 94	jsr $01949c			jsr 		FPUCopyToNext 			; copy to next slot.
.019531	20 8f 93	jsr $01938f			jsr 		FPUToInteger 			; convert to an integer
.019534	20 a8 8e	jsr $018ea8			jsr 		INTToString 			; output the main integer part.
.019537	20 ab 94	jsr $0194ab			jsr 		FPUCopyFromNext 		; get the fractional part back.
.01953a	20 1b 92	jsr $01921b			jsr 		FPFractionalPart 		; get the decimal part.
.01953d	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; any fractional part.
.019540	70 3e		bvs $019580			bvs 		_FPTOExit 				; if not, exit now.
.019542	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.019544	20 4a 8f	jsr $018f4a			jsr 		ITSOutputCharacter
.019547					_FPOutLoop:
.019547	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; finally reached zero.
.01954a	70 1e		bvs $01956a			bvs 		_FPStripZeros 			; strip trailing zeros
.01954c	20 f7 93	jsr $0193f7			jsr 		FPUTimes10 				; multiply by 10
.01954f	20 9c 94	jsr $01949c			jsr 		FPUCopyToNext			; copy to next slot.
.019552	20 8f 93	jsr $01938f			jsr 		FPUToInteger 			; convert to integer
.019555	bd 08 03	lda $0308,x			lda 		XS_Mantissa+0,x 		; print digit.
.019558	09 30		ora #$30			ora 		#"0"
.01955a	20 4a 8f	jsr $018f4a			jsr 		ITSOutputCharacter
.01955d	20 ab 94	jsr $0194ab			jsr 		FPUCopyFromNext 		; get it back
.019560	20 1b 92	jsr $01921b			jsr 		FPFractionalPart 		; get fractional part
.019563	ad 20 04	lda $0420			lda 		NumBufX 				; done 11 characters yet ?
.019566	c9 0b		cmp #$0b			cmp 	 	#11
.019568	90 dd		bcc $019547			bcc 		_FPOutLoop 				; if so, keep going till zero.
.01956a					_FPStripZeros:
.01956a	ac 20 04	ldy $0420			ldy 		NumBufX 				; strip trailing zeros.
.01956d					_FPStripLoop:
.01956d	88		dey				dey 								; back one, if at start then no strip
.01956e	f0 10		beq $019580			beq 		_FPToExit
.019570	b9 00 04	lda $0400,y			lda 		Num_Buffer,y 			; keep going if "0"
.019573	c9 30		cmp #$30			cmp 		#"0"
.019575	f0 f6		beq $01956d			beq 		_FPStripLoop
.019577	c8		iny				iny
.019578	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.01957a	99 00 04	sta $0400,y			sta 		Num_Buffer,y
.01957d	8c 20 04	sty $0420			sty 		NumBufX 				; update position.
.019580					_FPTOExit:
.019580	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.019581					FPFromString:
.019581	48		pha				pha 								; push A
.019582	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.019584	c9 2e		cmp #$2e			cmp 	#"."
.019586	f0 03		beq $01958b			beq	 	_FPFIsDecimal
.019588	4c ee 95	jmp $0195ee			jmp 	_FPFNotDecimal
.01958b					_FPFIsDecimal:
.01958b	c8		iny				iny 								; consume the decimal.
.01958c	20 30 93	jsr $019330			jsr 	FPUToFloat 					; convert the integer to float.
.01958f	da		phx				phx 								; save X.
.019590	5a		phy				phy 								; save decimal start position
.019591	e8		inx				inx
.019592	e8		inx				inx
.019593	e8		inx				inx
.019594	e8		inx				inx
.019595	e8		inx				inx
.019596	e8		inx				inx
.019597	20 62 8f	jsr $018f62			jsr 	INTFromStringY 				; get the part after the DP.
.01959a	20 30 93	jsr $019330			jsr 	FPUToFloat 					; convert that to a float.
.01959d	68		pla				pla 								; calculate - chars consumed.
.01959e	8c 23 04	sty $0423			sty 	ExpTemp
.0195a1	38		sec				sec
.0195a2	ed 23 04	sbc $0423			sbc 	ExpTemp 					; this is the shift amount
.0195a5	20 58 94	jsr $019458			jsr 	FPUScale10A 				; scale it by 10^AC
.0195a8	fa		plx				plx 								; restore original X
.0195a9	20 12 90	jsr $019012			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.0195ac	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.0195ae	c9 45		cmp #$45			cmp 	#"E"
.0195b0	f0 04		beq $0195b6			beq 	_FPFExponent
.0195b2	c9 65		cmp #$65			cmp 	#"e"
.0195b4	d0 38		bne $0195ee			bne 	_FPFNotDecimal 				; no, then exit normally.
.0195b6					_FPFExponent:
.0195b6	c8		iny				iny 								; skip over E symbol.
.0195b7	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.0195b9	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.0195bb	d0 01		bne $0195be			bne 	_FPFGotSign
.0195bd	c8		iny				iny 								; if it was - skip over it.
.0195be					_FPFGotSign:
.0195be	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.0195bf	da		phx				phx
.0195c0	e8		inx				inx
.0195c1	e8		inx				inx
.0195c2	e8		inx				inx
.0195c3	e8		inx				inx
.0195c4	e8		inx				inx
.0195c5	e8		inx				inx
.0195c6	20 62 8f	jsr $018f62			jsr 	INTFromStringY 				; get the exponent
.0195c9	fa		plx				plx 								; restore X.
.0195ca	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.0195cd	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.0195d0	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.0195d3	d0 1b		bne $0195f0			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.0195d5	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.0195d8	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.0195da	b0 14		bcs $0195f0			bcs 	_FPFXOverflow
.0195dc	68		pla				pla 								; get direction
.0195dd	d0 09		bne $0195e8			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.0195df	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.0195e2	49 ff		eor #$ff			eor 	#$FF
.0195e4	1a		inc a				inc 	a
.0195e5	9d 0e 03	sta $030e,x			sta 	XS2_Mantissa+0,x
.0195e8					_FPFXScale:
.0195e8	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.0195eb	20 58 94	jsr $019458			jsr 	FPUScale10A 				; scale by the exponent.
.0195ee					_FPFNotDecimal:
.0195ee	68		pla				pla
.0195ef	60		rts				rts
.0195f0					_FPFXOverflow:
.0195f0	20 21 84	jsr $018421			jsr 	ERR_Handler
>0195f3	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>0195fb	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.019602					Unary_Rnd:
.019602	20 9a 86	jsr $01869a			jsr 	EvaluateNumberX 			; get value
.019605	20 26 8d	jsr $018d26			jsr 	CheckNextRParen 			; check right bracket.
.019608	20 87 89	jsr $018987			jsr 	GetSignCurrent 				; get sign -1,0,1.
.01960b	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.01960d	30 10		bmi $01961f			bmi 	_URSetSeed
.01960f	f0 2c		beq $01963d			beq 	_URMakeRandom 				; if zero return same number.
.019611	da		phx				phx
.019612	a2 00		ldx #$00			ldx 	#0
.019614	20 7a 96	jsr $01967a			jsr 	Random16
.019617	a2 02		ldx #$02			ldx 	#2
.019619	20 7a 96	jsr $01967a			jsr 	Random16
.01961c	fa		plx				plx
.01961d	80 1e		bra $01963d			bra 	_URMakeRandom
.01961f					_URSetSeed:
.01961f	20 30 93	jsr $019330			jsr 	FPUToFloat 					; make it a float to twiddle it.
.019622	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.019625	8d 2b 04	sta $042b			sta 	RandomSeed+0
.019628	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.01962b	8d 2c 04	sta $042c			sta 	RandomSeed+1
.01962e	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.019631	8d 2d 04	sta $042d			sta 	RandomSeed+2
.019634	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.019637	0a		asl a				asl 	a
.019638	49 db		eor #$db			eor 	#$DB
.01963a	8d 2e 04	sta $042e			sta 	RandomSeed+3
.01963d					_URMakeRandom:
.01963d	ad 2b 04	lda $042b			lda 	RandomSeed+0 				; check if seed is zero.
.019640	0d 2c 04	ora $042c			ora 	RandomSeed+1
.019643	0d 2d 04	ora $042d			ora 	RandomSeed+2
.019646	0d 2e 04	ora $042e			ora 	RandomSeed+3
.019649	d0 0a		bne $019655			bne 	_URNotZero
.01964b	a9 47		lda #$47			lda 	#$47
.01964d	8d 2c 04	sta $042c			sta 	RandomSeed+1				; if it is, make it non zero.
.019650	a9 3d		lda #$3d			lda 	#$3D
.019652	8d 2e 04	sta $042e			sta 	RandomSeed+3
.019655					_URNotZero:
.019655	ad 2b 04	lda $042b			lda 	RandomSeed+0 				; copy seed into mantissa.
.019658	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.01965b	ad 2c 04	lda $042c			lda 	RandomSeed+1
.01965e	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019661	ad 2d 04	lda $042d			lda 	RandomSeed+2
.019664	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019667	ad 2e 04	lda $042e			lda 	RandomSeed+3
.01966a	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.01966d	a9 00		lda #$00			lda 	#$00 						; set type to float.
.01966f	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019672	a9 80		lda #$80			lda 	#$80
.019674	9d 0c 03	sta $030c,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.019677	4c 67 93	jmp $019367			jmp 	FPUNormalise
.01967a					Random16:
.01967a	5e 2c 04	lsr $042c,x			lsr 	RandomSeed+1,x				; shift seed right
.01967d	7e 2b 04	ror $042b,x			ror 	RandomSeed,x
.019680	90 08		bcc $01968a			bcc 	_R16_NoXor
.019682	bd 2c 04	lda $042c,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.019685	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.019687	9d 2c 04	sta $042c,x			sta 	RandomSeed+1,x
.01968a					_R16_NoXor:
.01968a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.01968b					Unary_Int:
.01968b	20 9a 86	jsr $01869a			jsr 	EvaluateNumberX 			; get value
.01968e	20 26 8d	jsr $018d26			jsr 	CheckNextRParen 			; check right bracket.
.019691	4c 8f 93	jmp $01938f			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.019694					TIM_Error:
.019694	20 31 82	jsr $018231			jsr 	IFT_UpLine 					; go up one line.
.019697	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.019699	80 02		bra $01969d			bra 	TIM_ShowPrompt
.01969b					TIM_NewCommand:
.01969b	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.01969d					TIM_ShowPrompt:
.01969d	20 3d 82	jsr $01823d			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.0196a0	20 f5 82	jsr $0182f5			jsr 	IFT_ReadLine	 			; get character, go to next line
.0196a3	20 57 82	jsr $018257			jsr 	IFT_NewLine					; go to next line.
.0196a6	86 10		stx $10				stx 	zTemp1 						; save line read address
.0196a8	84 11		sty $11				sty 	zTemp1+1
.0196aa	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.0196ac	b1 10		lda ($10),y			lda 	(zTemp1),y
.0196ae	c9 3f		cmp #$3f			cmp 	#"?"
.0196b0	f0 04		beq $0196b6			beq 	TIM_SkipFirst
.0196b2	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.0196b4	d0 01		bne $0196b7			bne 	TIM_NotDot
.0196b6					TIM_SkipFirst:
.0196b6	c8		iny				iny
.0196b7					TIM_NotDot:
.0196b7	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.0196b9	c9 52		cmp #$52			cmp 	#"R"						; show registers
.0196bb	f0 6b		beq $019728			beq 	TIM_ShowRegisters
.0196bd	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.0196bf	f0 12		beq $0196d3			beq 	TIM_ShowMemory
.0196c1	c9 47		cmp #$47			cmp 	#"G"						; execute
.0196c3	f0 49		beq $01970e			beq 	TIM_Execute
.0196c5	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.0196c7	f0 07		beq $0196d0			beq 	TIM_GoLoadMemory
.0196c9	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.0196cb	d0 c7		bne $019694			bne 	TIM_Error
.0196cd	4c 4c 98	jmp $01984c			jmp 	TIM_UpdateRegisters
.0196d0					TIM_GoLoadMemory:
.0196d0	4c 7c 98	jmp $01987c			jmp 	TIM_LoadMemory
.0196d3					TIM_ShowMemory:
.0196d3	20 c8 97	jsr $0197c8			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.0196d6	b0 bc		bcs $019694			bcs 	TIM_Error
.0196d8	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.0196da	85 12		sta $12				sta 	zTemp2
.0196dc	a5 15		lda $15				lda 	zTemp3+1
.0196de	85 13		sta $13				sta 	zTemp2+1
.0196e0	20 c8 97	jsr $0197c8			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.0196e3	90 08		bcc $0196ed			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.0196e5	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.0196e7	85 14		sta $14				sta 	zTemp3
.0196e9	a5 13		lda $13				lda 	zTemp2+1
.0196eb	85 15		sta $15				sta 	zTemp3+1
.0196ed					_TIMSM_Start:
.0196ed	20 a0 97	jsr $0197a0			jsr 	TIM_WriteLine 				; write one line of hex out
.0196f0	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.0196f2	18		clc				clc
.0196f3	69 10		adc #$10			adc 	#16
.0196f5	85 12		sta $12				sta 	zTemp2
.0196f7	90 02		bcc $0196fb			bcc 	_TIMSM_NoCarry
.0196f9	e6 13		inc $13				inc 	zTemp2+1
.0196fb					_TIMSM_NoCarry:
.0196fb	20 dc 83	jsr $0183dc			jsr 	IF_CheckBreak 				; check CTL+C
.0196fe	d0 0b		bne $01970b			bne 	_TIMSM_Ends 				; if pressed break out.
.019700	38		sec				sec 								; check past the end address in zTemp3
.019701	a5 14		lda $14				lda 	zTemp3
.019703	e5 12		sbc $12				sbc 	zTemp2
.019705	a5 15		lda $15				lda 	zTemp3+1
.019707	e5 13		sbc $13				sbc 	zTemp2+1
.019709	10 e2		bpl $0196ed			bpl 	_TIMSM_Start
.01970b					_TIMSM_Ends:
.01970b	4c 9b 96	jmp $01969b			jmp 	TIM_NewCommand
.01970e					TIM_Execute:
.01970e	20 c8 97	jsr $0197c8			jsr 	TIM_GetHex 					; get the execute address
.019711	b0 81		bcs $019694			bcs 	TIM_Error 					; not legitimate
.019713	ae 38 04	ldx $0438			ldx 	TIM_SP 						; set up SP
.019716	9a		txs				txs
.019717	ad 33 04	lda $0433			lda 	TIM_SR 						; Status for PLP
.01971a	48		pha				pha
.01971b	ad 34 04	lda $0434			lda 	TIM_A 						; restore AXYZ
.01971e	ae 35 04	ldx $0435			ldx 	TIM_X
.019721	ac 36 04	ldy $0436			ldy 	TIM_Y
.019724	28		plp				plp 								; and PS Byte.
.019725	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.019728					TIM_Start:
.019728					TIM_ShowRegisters:
.019728	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.01972b	8d 32 04	sta $0432			sta 	TIM_IRQ+1
.01972e	ad ff ff	lda $ffff			lda 	$FFFF
.019731	8d 31 04	sta $0431			sta 	TIM_IRQ
.019734	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.019736					_TIMSR_Text:
.019736	bf 67 97 01	lda $019767,x			lda 	_TIMSR_Label,x
.01973a	20 3d 82	jsr $01823d			jsr 	IFT_PrintCharacter
.01973d	e8		inx				inx
.01973e	e0 20		cpx #$20			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.019740	d0 f4		bne $019736			bne 	_TIMSR_Text
.019742	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.019744					_TIMSR_Skip:
.019744	e8		inx				inx
.019745					_TIMSR_LoopSpace:
.019745	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.019747	b0 04		bcs $01974d			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.019749	8a		txa				txa
.01974a	4a		lsr a				lsr 	a
.01974b	b0 05		bcs $019752			bcs 	_TIMSR_NoSpace
.01974d					_TIMSR_Space:
.01974d	a9 20		lda #$20			lda 	#" "
.01974f	20 3d 82	jsr $01823d			jsr 	IFT_PrintCharacter
.019752					_TIMSR_NoSpace:
.019752	bd 2f 04	lda $042f,x			lda 	TIM_PC,x 					; output hex value.
.019755	20 87 97	jsr $019787			jsr 	TIM_WriteHex
.019758	e8		inx				inx
.019759	e0 08		cpx #$08			cpx 	#TIM_Z-TIM_PC
.01975b	f0 e7		beq $019744			beq 	_TIMSR_Skip
.01975d	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.01975f	d0 e4		bne $019745			bne 	_TimSR_LoopSpace
.019761	20 57 82	jsr $018257			jsr 	IFT_NewLine 				; new line
.019764	4c 9b 96	jmp $01969b			jmp	 	TIM_NewCommand 				; new command.
.019767					_TIMSR_Label:
>019767	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>01976f	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>01977f	52
>019780	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.019787					_TIMSR_LabelEnd:
.019787					TIM_WriteHex:
.019787	48		pha				pha 								; save A
.019788	4a		lsr a				lsr 	a 							; shift MSB->LSB
.019789	4a		lsr a				lsr 	a
.01978a	4a		lsr a				lsr 	a
.01978b	4a		lsr a				lsr 	a
.01978c	20 90 97	jsr $019790			jsr 	_TIMWH_Nibble 				; print MSB
.01978f	68		pla				pla 								; restore and print LSB
.019790					_TIMWH_Nibble:
.019790	48		pha				pha
.019791	29 0f		and #$0f			and 	#15 						; mask out
.019793	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.019795	90 02		bcc $019799			bcc 	_TIMWHNoLetter
.019797	69 06		adc #$06			adc 	#6
.019799					_TIMWHNoLetter:
.019799	69 30		adc #$30			adc 	#48
.01979b	20 3d 82	jsr $01823d			jsr 	IFT_PrintCharacter 			; print it out.
.01979e	68		pla				pla
.01979f	60		rts				rts
.0197a0					TIM_WriteLine:
.0197a0	a9 2e		lda #$2e			lda 	#"." 						; prompt
.0197a2	20 3d 82	jsr $01823d			jsr 	IFT_PrintCharacter
.0197a5	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.0197a7	20 3d 82	jsr $01823d			jsr 	IFT_PrintCharacter
.0197aa	a5 13		lda $13				lda 	zTemp2+1 					; write address
.0197ac	20 87 97	jsr $019787			jsr 	TIM_WriteHex
.0197af	a5 12		lda $12				lda 	zTemp2
.0197b1	20 87 97	jsr $019787			jsr 	TIM_WriteHex
.0197b4	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.0197b6					_TIMWL_Loop:
.0197b6	a9 20		lda #$20			lda 	#" "
.0197b8	20 3d 82	jsr $01823d			jsr 	IFT_PrintCharacter
.0197bb	b1 12		lda ($12),y			lda 	(zTemp2),y
.0197bd	20 87 97	jsr $019787			jsr 	TIM_WriteHex
.0197c0	c8		iny				iny
.0197c1	c0 10		cpy #$10			cpy 	#16
.0197c3	d0 f1		bne $0197b6			bne 	_TIMWL_Loop
.0197c5	4c 57 82	jmp $018257			jmp 	IFT_NewLine 				; new line and exit
.0197c8					TIM_GetHex:
.0197c8	c8		iny				iny
.0197c9	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.0197cb	c9 20		cmp #$20			cmp 	#32
.0197cd	f0 f9		beq $0197c8			beq 	TIM_GetHex
.0197cf	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.0197d1	f0 f5		beq $0197c8			beq 	TIM_GetHex
.0197d3	20 fc 97	jsr $0197fc			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.0197d6	b0 23		bcs $0197fb			bcs 	_TIMGH_Exit					; if first bad then exit now.
.0197d8	a9 00		lda #$00			lda 	#0 							; zero result
.0197da	85 14		sta $14				sta 	zTemp3
.0197dc	85 15		sta $15				sta 	zTemp3+1
.0197de					_TIM_GHLoop:
.0197de	20 fc 97	jsr $0197fc			jsr 	TIM_GetHexCharacter 		; get next character
.0197e1	b0 17		bcs $0197fa			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.0197e3	c8		iny				iny 								; skip over it.
.0197e4	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.0197e6	26 15		rol $15				rol 	zTemp3+1
.0197e8	06 14		asl $14				asl 	zTemp3 						; now x 2
.0197ea	26 15		rol $15				rol 	zTemp3+1
.0197ec	06 14		asl $14				asl 	zTemp3						; now x 4
.0197ee	26 15		rol $15				rol 	zTemp3+1
.0197f0	06 14		asl $14				asl 	zTemp3 						; now x 8
.0197f2	26 15		rol $15				rol 	zTemp3+1
.0197f4	05 14		ora $14				ora 	zTemp3 						; OR result in
.0197f6	85 14		sta $14				sta 	zTemp3
.0197f8	80 e4		bra $0197de			bra 	_TIM_GHLoop 				; loop round again.
.0197fa					_TIMGH_Okay:
.0197fa	18		clc				clc
.0197fb					_TIMGH_Exit:
.0197fb	60		rts				rts
.0197fc					TIM_GetHexCharacter:
.0197fc	b1 10		lda ($10),y			lda 	(zTemp1),y
.0197fe	38		sec				sec
.0197ff	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.019801	90 0e		bcc $019811			bcc 	_TIM_GHCFail
.019803	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.019805	90 0b		bcc $019812			bcc 	_TIM_GHCExit
.019807	c9 11		cmp #$11			cmp 	#65-48						; < A
.019809	90 06		bcc $019811			bcc		_TIM_GHCFail
.01980b	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.01980d	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.01980f	90 01		bcc $019812			bcc		_TIM_GHCExit
.019811					_TIM_GHCFail:
.019811	38		sec				sec
.019812					_TIM_GHCExit:
.019812	60		rts				rts
.019813					TIM_BreakVector:
.019813	da		phx				phx									; save X/A on stack
.019814	48		pha				pha
.019815	ba		tsx				tsx 								; X points to S
.019816	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.019819	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.01981b	d0 03		bne $019820			bne 	_TIMBreak					; if set, it's BRK
.01981d	68		pla				pla 								; abandon routine.
.01981e	fa		plx				plx
.01981f	40		rti				rti
.019820					_TIMBreak:
.019820	68		pla				pla 								; save A X Y and maybe Z
.019821	8d 34 04	sta $0434			sta 	TIM_A
.019824	fa		plx				plx
.019825	8e 35 04	stx $0435			stx 	TIM_X
.019828	8c 36 04	sty $0436			sty 	TIM_Y
.01982b	68		pla				pla 								; get Status Register
.01982c	8d 33 04	sta $0433			sta 	TIM_SR
.01982f	68		pla				pla
.019830	8d 30 04	sta $0430			sta 	TIM_PC+1 					; save calling address
.019833	68		pla				pla
.019834	8d 2f 04	sta $042f			sta 	TIM_PC 						; high byte
.019837	ad 30 04	lda $0430			lda 	TIM_PC+1 					; dec PC to point right.
.01983a	d0 03		bne $01983f			bne 	_TIMDecrement 				; brk bumps it.
.01983c	ce 2f 04	dec $042f			dec 	TIM_PC
.01983f					_TIMDecrement:
.01983f	ce 30 04	dec $0430			dec 	TIM_PC+1
.019842	ba		tsx				tsx 								; and copy SP
.019843	8e 38 04	stx $0438			stx 	TIM_SP
.019846	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.019848	9a		txs				txs
.019849	4c 28 97	jmp $019728			jmp 	TIM_Start 					; and start up TIM monitor.
.01984c					TIM_UpdateRegisters:
.01984c	20 c8 97	jsr $0197c8			jsr 	TIM_GetHex 					; PC
.01984f	b0 28		bcs $019879			bcs 	_TIMURFail
.019851	a5 14		lda $14				lda 	zTemp3
.019853	8d 30 04	sta $0430			sta 	Tim_PC+1
.019856	a5 15		lda $15				lda 	zTemp3+1
.019858	8d 2f 04	sta $042f			sta 	Tim_PC
.01985b	20 c8 97	jsr $0197c8			jsr 	TIM_GetHex 					; ignore IRQ
.01985e	b0 19		bcs $019879			bcs 	_TIMURFail
.019860	a2 00		ldx #$00			ldx 	#0
.019862					_TIM_URLoop:
.019862	e0 04		cpx #$04			cpx 	#Tim_Z-Tim_SR
.019864	d0 01		bne $019867			bne 	_TIM_1
.019866	e8		inx				inx
.019867					_TIM_1:
.019867	20 c8 97	jsr $0197c8			jsr 	TIM_GetHex 					; registers
.01986a	b0 0d		bcs $019879			bcs 	_TIMURFail
.01986c	a5 14		lda $14				lda 	zTemp3
.01986e	9d 33 04	sta $0433,x			sta 	Tim_SR,x
.019871	e8		inx				inx
.019872	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.019874	d0 ec		bne $019862			bne 	_TIM_URLoop
.019876	4c 9b 96	jmp $01969b			jmp 	TIM_NewCommand
.019879					_TIMURFail:
.019879	4c 94 96	jmp $019694			jmp 	TIM_Error
.01987c					TIM_LoadMemory:
.01987c	20 c8 97	jsr $0197c8			jsr 	TIM_GetHex 					; target address => zTemp2
.01987f	a5 14		lda $14				lda 	zTemp3
.019881	85 12		sta $12				sta 	zTemp2
.019883	a5 15		lda $15				lda 	zTemp3+1
.019885	85 13		sta $13				sta 	zTemp2+1
.019887					_TIM_LMLoop:
.019887	20 c8 97	jsr $0197c8			jsr 	TIM_GetHex 					; next byte ?
.01988a	b0 0e		bcs $01989a			bcs 	_TIMLMDone 					; no more
.01988c	a2 00		ldx #$00			ldx 	#0							; write out.
.01988e	a5 14		lda $14				lda 	zTemp3
.019890	81 12		sta ($12,x)			sta 	(zTemp2,x)
.019892	e6 12		inc $12				inc 	zTemp2 						; bump address
.019894	d0 f1		bne $019887			bne 	_TIM_LMLoop
.019896	e6 13		inc $13				inc 	zTemp2+1
.019898	80 ed		bra $019887			bra 	_TIM_LMLoop
.01989a					_TIMLMDone:
.01989a	4c 9b 96	jmp $01969b			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Return to file: basic.asm

>01989d	02						.byte 	2
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 c0						.word 	StartROM
>fffe	16 c0					.word TIM_BreakHandler

;******  End of listing
