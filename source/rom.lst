
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Sun Sep  1 12:39:58 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="65816"				cpu = "65816"
="em65816"				hardware = "em65816"
=1					exitonend = 1
=0					autorun = 0
=1					loadtest = 1
=1					hasfloat = 1
=1					hasinteger = 1
=253					maxstring = 253

;******  Processing file: modules/basic/pointer/em65816/src_em65816.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stackmarkers.inc

=5					SourcePosSize   =   5 							; Source position stack space needed.
=1					SMark_Gosub 	= 	1 							; 0 is GOSUB/RETURN.
=2					SMark_Repeat 	= 	2 							; 1 is REPEAT/UNTIL.
=3					SMark_While 	= 	3 							; 2 is WHILE/WEND.
=4					SMark_If 		= 	4 							; 3 is IF/ENDIF
=5					SMark_For 		= 	5 							; 4 is FOR/NEXT

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/hardware/common/macros32.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0020					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0022					zVarDataPtr: .word ? 						; position of variable data.
>0024					zVarType: 	.byte ? 						; type of data (token)
>0025					zNullString:.byte ? 						; represents a NULL string.
>0026					zBasicSP:	.word ? 						; stack pointer
>0080					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>0084					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>0085					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=134					XS2_Mantissa = XS_Mantissa+XS_Size
=138					XS2_Exponent = XS_Exponent+XS_Size
=139					XS2_Type = XS_Type+XS_Size
=140					XS3_Mantissa = XS_Mantissa+XS_Size*2
=144					XS3_Exponent = XS_Exponent+XS_Size*2
=145					XS3_Type = XS_Type+XS_Size*2
>0300					StringPtr:	.word ? 						; Top of free memory (for string allocation)
>0302					VarMemPtr: 	.word ?							; Bottom of free memory (for variables)
>0304					endOfProgram: .dword ? 						; End of Program Memory (long)
>0308					vecPrintCharacter .word ?
>030a					vecInputCharacter .word ?
>030c					UserVector .fill 4 							; USR(x) calls this.
>0310					LocalVector .fill 4 						; Indirect calls call this.
>0314					NumBufX 	.byte 	?						; buffer index position
>0315					Num_Buffer	.fill 	32 						; buffer for numeric conversions
=6					HashTableCount = 6 							; there are 6 hash tables, in token order.
=8					HashTableSize = 8 							; each hash table as 8 links.
.0335					HashTableBase:
>0335								.fill	HashTableCount * HashTableSize * 2
.0395					HashTableEnd:
=$315					Var_Buffer 	= Num_Buffer 					; buffer for variable name (same space)
>0395					Var_Type    .byte ? 						; type of variable (as a type token)
>0396					Var_Hash 	.byte ? 						; hash of identifier name.
>0397					Var_Length 	.byte ? 						; length of variable name
>0398					Var_HashAddress .byte ?						; low byte of hash table entry.
>0399					Var_DataSize .byte ?						; size of one element.
>039a					NumSuppress	.byte 	?						; leading zero suppression flag
>039b					NumConvCount .byte 	? 						; count for conversions.
>039c					ExpTemp:	.byte ?							; Working temp for exponents.
>039d					ExpCount:	.byte ? 						; Count of decimal exponents.
>039e					SignCount:	.byte ?							; Integer Divide Sign Counts.
>039f					TempStringWriteIndex: .byte ? 				; Write offset.
>03a0					ValSign: 	.byte ? 						; sign flag for val()
>03a1					SliceStart:	.byte ? 						; string slice parts
>03a2					SliceCount:	.byte ?
>03a3					RandomSeed:	.dword ? 						; Random seed.
>03a7					SignNext:	.byte ? 						; Used for keeping sign of STEP in FOR/NEXT
>03a8					BreakCount:	.byte ? 						; Counter, avoid checking break every command.
=3					ArrayMaxDim = 3 							; number of dimensions.
>03a9					ArrayDef:	.fill (ArrayMaxDim+1)*2 		; dimensions for auto-creation
>03b1					UsrArrayDef:.fill (ArrayMaxDim+1)*2 		; dimensions created in DIM
>03b9					UsrArrayIdx:.byte ? 						; index into UsrArrayDef
>03ba					LastPrinted:.byte ? 						; last printed char ?
>03bb					ListIndent: .byte ? 						; list indent level
>03bc					LastListIndent:.byte ? 						; previous one.
>03bd					DataLPtr: 	.dword ?						; the data long ptr (swapped with zCodePtr)
>03c1					DataIndex:	.byte ?							; index position.
>03c2					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>03c4					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>03c6					Tim_SR:		.byte ? 						; Processor Status
>03c7					Tim_A:		.byte ? 						; Processor Registers
>03c8					Tim_X:		.byte ?
>03c9					Tim_Y:		.byte ?
>03ca					Tim_Z:		.byte ?
>03cb					Tim_SP:		.word ?							; Stack Pointer (just in cases)
>0400					BasicStack:	.fill 	256 					; and occupy whole pages.
.0500					EndBasicStack:
>0500					IFT_XCursor:.byte ?							; current logical position on screen
>0501					IFT_YCursor:.byte ?
>0502					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0566					IFT_LineBuffer: .fill 100 					; line input buffer.

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/em65816.asm

=$7f00					HighMemory = $7F00
=$3000					VariableMemory = $3000
.1000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testcode.src

>1000	0f 0a 00 c6 01 bf 02 bb			.byte	$0f,$0a,$00,$c6,$01,$bf,$02,$bb
>1008	bf 03 c0 c6 04 b7 00 19			.byte	$bf,$03,$c0,$c6,$04,$b7,$00,$19
>1010	14 00 c5 58 bf 71 bf 41			.byte	$14,$00,$c5,$58,$bf,$71,$bf,$41
>1018	7c fd 03 37 c0 d6 fe 09			.byte	$7c,$fd,$03,$37,$c0,$d6,$fe,$09
>1020	52 65 61 64 2e 2e 2e 00			.byte	$52,$65,$61,$64,$2e,$2e,$2e,$00
>1028	1a 1e 00 c5 fe 07 48 65			.byte	$1a,$1e,$00,$c5,$fe,$07,$48,$65
>1030	6c 6c 6f c0 d6 fe 0c 61			.byte	$6c,$6c,$6f,$c0,$d6,$fe,$0c,$61
>1038	67 61 69 6e 20 2e 2e 2e			.byte	$67,$61,$69,$6e,$20,$2e,$2e,$2e
>1040	2e 00 39 28 00 d6 fe 34			.byte	$2e,$00,$39,$28,$00,$d6,$fe,$34
>1048	30 31 32 33 34 35 36 37			.byte	$30,$31,$32,$33,$34,$35,$36,$37
>1050	38 39 30 31 32 33 34 35			.byte	$38,$39,$30,$31,$32,$33,$34,$35
>1058	36 37 38 39 30 31 32 33			.byte	$36,$37,$38,$39,$30,$31,$32,$33
>1060	34 35 36 37 38 39 30 31			.byte	$34,$35,$36,$37,$38,$39,$30,$31
>1068	32 33 34 35 36 37 38 39			.byte	$32,$33,$34,$35,$36,$37,$38,$39
>1070	30 31 32 33 34 35 36 37			.byte	$30,$31,$32,$33,$34,$35,$36,$37
>1078	38 39 00 0e 32 00 d6 01			.byte	$38,$39,$00,$0e,$32,$00,$d6,$01
>1080	bf 02 bb bf 03 bf 04 b7			.byte	$bf,$02,$bb,$bf,$03,$bf,$04,$b7
>1088	00 05 3c 00 d4 00 0f 46			.byte	$00,$05,$3c,$00,$d4,$00,$0f,$46
>1090	00 c6 01 bf 02 bb bf 03			.byte	$00,$c6,$01,$bf,$02,$bb,$bf,$03
>1098	c0 c6 04 b7 00 0e 50 00			.byte	$c0,$c6,$04,$b7,$00,$0e,$50,$00
>10a0	d6 01 bf 02 bb bf 03 bf			.byte	$d6,$01,$bf,$02,$bb,$bf,$03,$bf
>10a8	04 b7 00 0c 5a 00 d6 fe			.byte	$04,$b7,$00,$0c,$5a,$00,$d6,$fe
>10b0	03 61 c1 fe 03 62 00 08			.byte	$03,$61,$c1,$fe,$03,$62,$00,$08
>10b8	64 00 d6 41 c1 42 00 0a			.byte	$64,$00,$d6,$41,$c1,$42,$00,$0a
>10c0	6e 00 d6 8b 41 c1 8b 42			.byte	$6e,$00,$d6,$8b,$41,$c1,$8b,$42
>10c8	00 05 78 00 c4 00 00			.byte	$00,$05,$78,$00,$c4,$00,$00

;******  Return to file: modules/hardware/em65816.asm

.c000					StartROM:
.c000	18		clc				clc
.c001	fb		xce				xce
.c002	c2 30		rep #$30			rep 	#$30
.c004	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.c007	1b		tcs				tcs
.c008	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.c00b	e2 30		sep #$30			sep 	#$30
.c00d	c2 30		rep #$30			rep 	#$30						; clear AXY in 16 bit.
.c00f	a9 00		lda #$00			lda 	#$0000
.c011	aa		tax				tax
.c012	a8		tay				tay
.c013	e2 30		sep #$30			sep 	#$30
.c015	5c 01 88 01	jmp $018801		jmp BASIC_Start
.c019					TIM_BreakHandler:
.c019	5c 69 83 01	jmp $018369			jmp 	TIM_BreakVector

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.018000					IFT_ClearScreen:
.018000	48		pha				pha
.018001	da		phx				phx
.018002	5a		phy				phy
.018003	20 9c 81	jsr $01819c			jsr 	IF_Home 					; home cursor
.018006	a2 20		ldx #$20			ldx 	#IF_Height 					; this many lines.
.018008					_IFT_CS0:
.018008	a0 40		ldy #$40			ldy 	#IF_Width 					; this many chars/line
.01800a					_IFT_CS1:
.01800a	a9 20		lda #$20			lda 	#' '						; clear line.
.01800c	20 c8 81	jsr $0181c8			jsr 	IF_Write
.01800f	88		dey				dey
.018010	d0 f8		bne $01800a			bne 	_IFT_CS1
.018012	20 af 81	jsr $0181af			jsr 	IF_NewLine 					; next line down
.018015	ca		dex				dex
.018016	d0 f0		bne $018008			bne 	_IFT_CS0
.018018	7a		ply				ply
.018019	fa		plx				plx
.01801a	68		pla				pla
.01801b					IFT_HomeCursor:
.01801b	48		pha				pha
.01801c	20 9c 81	jsr $01819c			jsr 	IF_Home
.01801f	a9 00		lda #$00			lda 	#0
.018021	8d 00 05	sta $0500			sta 	IFT_XCursor
.018024	8d 01 05	sta $0501			sta 	IFT_YCursor
.018027	68		pla				pla
.018028	60		rts				rts
.018029					IFT_UpLine:
.018029	48		pha				pha
.01802a	ad 01 05	lda $0501			lda  	IFT_YCursor 				; get Y
.01802d	3a		dec a				dec 	a 							; line above
.01802e	30 03		bmi $018033			bmi 	_IFTULExit 					; too far, abort
.018030	20 be 80	jsr $0180be			jsr 	IFT_SetYPos					; set to that line.
.018033					_IFTULExit:
.018033	68		pla				pla
.018034	60		rts				rts
.018035					IFT_PrintCharacter:
.018035	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.018037	f0 16		beq $01804f			beq 	IFT_NewLine
.018039	48		pha				pha
.01803a	20 67 80	jsr $018067			jsr 	IFT_UpperCase 				; make upper case
.01803d	20 c8 81	jsr $0181c8			jsr 	IF_Write 					; write out.
.018040	ee 00 05	inc $0500			inc 	IFT_XCursor 				; bump x cursor
.018043	ad 00 05	lda $0500			lda 	IFT_XCursor 				; reached RHS ?
.018046	c9 40		cmp #$40			cmp 	#IF_Width
.018048	d0 03		bne $01804d			bne 	_IFT_PCNotEOL
.01804a	20 4f 80	jsr $01804f			jsr 	IFT_NewLine 				; if so do new line.
.01804d					_IFT_PCNotEOL:
.01804d	68		pla				pla
.01804e	60		rts				rts
.01804f					IFT_NewLine:
.01804f	48		pha				pha
.018050	20 af 81	jsr $0181af			jsr 	IF_NewLine 					; new line on actual screen.
.018053	a9 00		lda #$00			lda 	#0 							; reset x position
.018055	8d 00 05	sta $0500			sta 	IFT_XCursor
.018058	ee 01 05	inc $0501			inc 	IFT_YCursor 				; move down.
.01805b	ad 01 05	lda $0501			lda 	IFT_YCursor
.01805e	c9 20		cmp #$20			cmp 	#IF_Height 					; reached bottom.
.018060	d0 03		bne $018065			bne 	_IFT_NL_NotEOS
.018062	20 72 80	jsr $018072			jsr 	IFT_Scroll 					; scroll screen up.
.018065					_IFT_NL_NotEOS:
.018065	68		pla				pla
.018066	60		rts				rts
.018067					IFT_UpperCase:
.018067	c9 61		cmp #$61			cmp 	#"a"
.018069	90 06		bcc $018071			bcc 	_IFT_UCExit
.01806b	c9 7b		cmp #$7b			cmp 	#"z"+1
.01806d	b0 02		bcs $018071			bcs 	_IFT_UCExit
.01806f	49 20		eor #$20			eor 	#$20
.018071					_IFT_UCExit:
.018071	60		rts				rts
.018072					IFT_Scroll:
.018072	48		pha				pha 								; save AXY
.018073	da		phx				phx
.018074	5a		phy				phy
.018075	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.018077					_IFT_SLoop:
.018077	20 97 80	jsr $018097			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.01807a	e8		inx				inx
.01807b	e0 1f		cpx #$1f			cpx 	#IF_Height-1				; do whole screen
.01807d	d0 f8		bne $018077			bne 	_IFT_SLoop
.01807f	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.018081	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.018084	a2 40		ldx #$40			ldx 	#IF_Width 					; blank line
.018086					_IFT_SBlank:
.018086	a9 20		lda #$20			lda 	#32
.018088	20 c8 81	jsr $0181c8			jsr 	IF_Write
.01808b	ca		dex				dex
.01808c	d0 f8		bne $018086			bne 	_IFT_SBlank
.01808e	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.018090	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.018093	7a		ply				ply
.018094	fa		plx				plx
.018095	68		pla				pla
.018096	60		rts				rts
.018097					_IFT_ScrollLine:
.018097	da		phx				phx
.018098	da		phx				phx
.018099	8a		txa				txa 								; copy line into buffer.
.01809a	1a		inc a				inc 	a 							; next line down.
.01809b	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.01809e	a2 00		ldx #$00			ldx 	#0
.0180a0					_IFTScrollCopy1:
.0180a0	20 bf 81	jsr $0181bf			jsr 	IF_Read
.0180a3	9d 02 05	sta $0502,x			sta 	IFT_Buffer,x
.0180a6	e8		inx				inx
.0180a7	e0 40		cpx #$40			cpx 	#IF_Width
.0180a9	d0 f5		bne $0180a0			bne 	_IFTScrollCopy1
.0180ab	68		pla				pla
.0180ac	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.0180af	a2 00		ldx #$00			ldx 	#0
.0180b1					_IFTScrollCopy2:
.0180b1	bd 02 05	lda $0502,x			lda 	IFT_Buffer,x
.0180b4	20 c8 81	jsr $0181c8			jsr 	IF_Write
.0180b7	e8		inx				inx
.0180b8	e0 40		cpx #$40			cpx 	#IF_Width
.0180ba	d0 f5		bne $0180b1			bne 	_IFTScrollCopy2
.0180bc	fa		plx				plx
.0180bd	60		rts				rts
.0180be					IFT_SetYPos:
.0180be	48		pha				pha
.0180bf	da		phx				phx
.0180c0	aa		tax				tax
.0180c1	20 1b 80	jsr $01801b			jsr 	IFT_HomeCursor
.0180c4	e0 00		cpx #$00			cpx 	#0
.0180c6	f0 09		beq $0180d1			beq 	_IFT_MOAExit
.0180c8					_IFT_MOALoop:
.0180c8	20 af 81	jsr $0181af			jsr 	IF_NewLine
.0180cb	ee 01 05	inc $0501			inc 	IFT_YCursor
.0180ce	ca		dex				dex
.0180cf	d0 f7		bne $0180c8			bne		_IFT_MOALoop
.0180d1					_IFT_MOAExit:
.0180d1	fa		plx				plx
.0180d2	68		pla				pla
.0180d3	60		rts				rts
.0180d4					IFT_GetKeyCursor:
.0180d4	20 dc 80	jsr $0180dc			jsr 	_IFT_FlipCursor 			; reverse current
.0180d7					_IFT_GKCWait:
.0180d7	20 d9 81	jsr $0181d9			jsr 	IF_GetKey 					; get key
.0180da	f0 fb		beq $0180d7			beq 	_IFT_GKCWait
.0180dc					_IFT_FlipCursor:
.0180dc	48		pha				pha 								; save
.0180dd	20 bf 81	jsr $0181bf			jsr 	IF_Read 					; read
.0180e0	20 d1 81	jsr $0181d1			jsr 	IF_LeftOne
.0180e3	49 80		eor #$80			eor 	#$80 						; reverse
.0180e5	20 c8 81	jsr $0181c8			jsr 	IF_Write 					; write
.0180e8	20 d1 81	jsr $0181d1			jsr 	IF_LeftOne
.0180eb	68		pla				pla
.0180ec	60		rts				rts
.0180ed					IFT_ReadLine:
.0180ed	48		pha				pha
.0180ee					_IFT_RLLoop:
.0180ee	20 d4 80	jsr $0180d4			jsr 	IFT_GetKeyCursor 			; get keystroke
.0180f1	c9 0d		cmp #$0d			cmp 	#13							; return
.0180f3	f0 7d		beq $018172			beq 	_IFT_RLExit
.0180f5	c9 20		cmp #$20			cmp 	#32 						; control character
.0180f7	90 05		bcc $0180fe			bcc 	_IFT_Control
.0180f9	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0180fc	80 f0		bra $0180ee			bra 	_IFT_RLLoop
.0180fe					_IFT_Control:
.0180fe	c9 01		cmp #$01			cmp 	#"A"-64
.018100	f0 26		beq $018128			beq 	_IFT_Left
.018102	c9 04		cmp #$04			cmp 	#"D"-64
.018104	f0 2e		beq $018134			beq 	_IFT_Right
.018106	c9 17		cmp #$17			cmp 	#"W"-64
.018108	f0 36		beq $018140			beq 	_IFT_Up
.01810a	c9 13		cmp #$13			cmp 	#"S"-64
.01810c	f0 3e		beq $01814c			beq 	_IFT_Down
.01810e	c9 08		cmp #$08			cmp 	#"H"-64
.018110	f0 09		beq $01811b			beq 	_IFT_Backspace
.018112	c9 1a		cmp #$1a			cmp 	#"Z"-64
.018114	d0 d8		bne $0180ee			bne 	_IFT_RLLoop
.018116	20 00 80	jsr $018000			jsr 	IFT_ClearScreen				; clear CTL-Z
.018119	80 d3		bra $0180ee			bra 	_IFT_RLLoop
.01811b					_IFT_Backspace:
.01811b	ad 00 05	lda $0500			lda 	IFT_XCursor 				; check not start of line.
.01811e	f0 ce		beq $0180ee			beq 	_IFT_RLLoop
.018120	20 d1 81	jsr $0181d1			jsr 	IF_LeftOne
.018123	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.018125	20 c8 81	jsr $0181c8			jsr 	IF_Write
.018128					_IFT_Left:
.018128	ce 00 05	dec $0500			dec 	IFT_XCursor 				; left CTL-W
.01812b	10 29		bpl $018156			bpl 	_IFT_Reposition
.01812d	a9 3f		lda #$3f			lda 	#IF_Width-1
.01812f					_IFT_SetX:
.01812f	8d 00 05	sta $0500			sta 	IFT_XCursor
.018132	80 22		bra $018156			bra 	_IFT_Reposition
.018134					_IFT_Right:
.018134	ee 00 05	inc $0500			inc 	IFT_XCursor
.018137	ad 00 05	lda $0500			lda 	IFT_XCursor
.01813a	49 40		eor #$40			eor 	#IF_Width
.01813c	f0 f1		beq $01812f			beq 	_IFT_SetX
.01813e	80 16		bra $018156			bra 	_IFT_Reposition
.018140					_IFT_Up:
.018140	ce 01 05	dec $0501			dec 	IFT_YCursor
.018143	10 11		bpl $018156			bpl 	_IFT_Reposition
.018145	a9 1f		lda #$1f			lda 	#IF_Height-1
.018147					_IFT_SetY:
.018147	8d 01 05	sta $0501			sta 	IFT_YCursor
.01814a	80 0a		bra $018156			bra 	_IFT_Reposition
.01814c					_IFT_Down:
.01814c	ee 01 05	inc $0501			inc 	IFT_YCursor
.01814f	ad 01 05	lda $0501			lda 	IFT_YCursor
.018152	49 20		eor #$20			eor 	#IF_Height
.018154	f0 f1		beq $018147			beq 	_IFT_SetY
.018156					_IFT_Reposition:
.018156	ad 00 05	lda $0500			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.018159	48		pha				pha
.01815a	ad 01 05	lda $0501			lda 	IFT_YCursor
.01815d	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.018160	68		pla				pla
.018161	aa		tax				tax
.018162	e0 00		cpx #$00			cpx 	#0
.018164	f0 88		beq $0180ee			beq 	_IFT_RLLoop
.018166					_IFT_MoveRight:
.018166	20 bf 81	jsr $0181bf			jsr 	IF_Read
.018169	ee 00 05	inc $0500			inc 	IFT_XCursor
.01816c	ca		dex				dex
.01816d	d0 f7		bne $018166			bne 	_IFT_MoveRight
.01816f	4c ee 80	jmp $0180ee			jmp 	_IFT_RLLoop
.018172					_IFT_RLExit:
.018172	ad 01 05	lda $0501			lda 	IFT_YCursor 				; go to start of line.
.018175	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.018178	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.01817a					_IFT_RLRead:
.01817a	20 bf 81	jsr $0181bf			jsr 	IF_Read
.01817d	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.018180	e8		inx				inx
.018181	e0 40		cpx #$40			cpx 	#IF_Width
.018183	d0 f5		bne $01817a			bne 	_IFT_RLRead
.018185					_IFT_RL_Trim:
.018185	ca		dex				dex 	 							; previous char
.018186	30 07		bmi $01818f			bmi 	_IFT_Found 					; gone too far
.018188	bd 66 05	lda $0566,x			lda 	IFT_LineBuffer,x			; go back if space
.01818b	c9 20		cmp #$20			cmp 	#" "
.01818d	f0 f6		beq $018185			beq 	_IFT_RL_Trim
.01818f					_IFT_Found:
.01818f	e8		inx				inx 								; forward to non-space
.018190	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.018192	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.018195	68		pla				pla
.018196	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.018198	a0 05		ldy #$05			ldy 	#IFT_LineBuffer >> 8
.01819a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_em65816.asm

=64					IF_Width 	= 64 							; characters across
=32					IF_Height 	= 32 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line.
=8					IF_XPos 	= 8 							; current position, horizontal.
=$f0000					IF_Screen = $F0000							; 2k screen RAM here
=$f8010					IF_PKeyboard = $F8010						; Keyboard port.
=$f8000					IF_PBreak = $F8000 							; Break key.
.01819b					IF_Reset:
.01819b	60		rts				rts
.01819c					IF_Home:
.01819c	48		pha				pha
.01819d	64 08		stz $08				stz 	IF_XPos 					; zero X position
.01819f	a9 00		lda #$00			lda 	#IF_Screen & $FF 			; set r/w pos.
.0181a1	85 04		sta $04				sta 	IF_Pos
.0181a3	a9 00		lda #$00			lda 	#(IF_Screen >> 8) & $FF
.0181a5	85 05		sta $05				sta 	IF_Pos+1
.0181a7	a9 0f		lda #$0f			lda 	#IF_Screen >> 16
.0181a9	85 06		sta $06				sta 	IF_Pos+2
.0181ab	64 07		stz $07				stz 	IF_Pos+3
.0181ad	68		pla				pla
.0181ae	60		rts				rts
.0181af					IF_NewLine:
.0181af	48		pha				pha
.0181b0	64 08		stz $08				stz 	IF_XPos						; back to start of line
.0181b2	18		clc				clc 								; down one line
.0181b3	a5 04		lda $04				lda 	IF_Pos
.0181b5	69 40		adc #$40			adc 	#64
.0181b7	85 04		sta $04				sta 	IF_Pos
.0181b9	90 02		bcc $0181bd			bcc 	_IF_NoCarry 				; carry through.
.0181bb	e6 05		inc $05				inc 	IF_Pos+1
.0181bd					_IF_NoCarry:
.0181bd	68		pla				pla
.0181be	60		rts				rts
.0181bf					IF_Read:
.0181bf	5a		phy				phy 								; save current Y
.0181c0	a4 08		ldy $08				ldy 	IF_XPos 					; read character at current position
.0181c2	b7 04		lda [$04],y			lda 	[IF_Pos],y
.0181c4	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181c6	7a		ply				ply									; restore Y
.0181c7	60		rts				rts
.0181c8					IF_Write:
.0181c8	5a		phy				phy 								; save current Y
.0181c9	a4 08		ldy $08				ldy 	IF_XPos 					; write character at current position
.0181cb	97 04		sta [$04],y			sta 	[IF_Pos],y
.0181cd	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181cf	7a		ply				ply									; restore Y
.0181d0	60		rts				rts
.0181d1					IF_LeftOne:
.0181d1	c6 08		dec $08				dec 	IF_XPos
.0181d3	60		rts				rts
.0181d4					IF_CheckBreak:
.0181d4	af 00 80 0f	lda $0f8000			lda 	IF_PBreak					; non-zero if Ctrl+C pressed.
.0181d8	60		rts				rts
.0181d9					IF_GetKey:
.0181d9	af 10 80 0f	lda $0f8010			lda 	IF_PKeyboard				; read keyboard
.0181dd	f0 08		beq $0181e7			beq		_IFGK_NoKey 				; skip if zero,no key pressed
.0181df	48		pha				pha 								; key pressed, clear queue.
.0181e0	a9 00		lda #$00			lda 	#0
.0181e2	8f 10 80 0f	sta $0f8010			sta 	IF_PKeyboard
.0181e6	68		pla				pla
.0181e7					_IFGK_NoKey:
.0181e7	09 00		ora #$00			ora 	#0							; set Z flag appropriately.
.0181e9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.0181ea					TIM_Error:
.0181ea	20 29 80	jsr $018029			jsr 	IFT_UpLine 					; go up one line.
.0181ed	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.0181ef	80 02		bra $0181f3			bra 	TIM_ShowPrompt
.0181f1					TIM_NewCommand:
.0181f1	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.0181f3					TIM_ShowPrompt:
.0181f3	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.0181f6	20 ed 80	jsr $0180ed			jsr 	IFT_ReadLine	 			; get character, go to next line
.0181f9	20 4f 80	jsr $01804f			jsr 	IFT_NewLine					; go to next line.
.0181fc	86 10		stx $10				stx 	zTemp1 						; save line read address
.0181fe	84 11		sty $11				sty 	zTemp1+1
.018200	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.018202	b1 10		lda ($10),y			lda 	(zTemp1),y
.018204	c9 3f		cmp #$3f			cmp 	#"?"
.018206	f0 04		beq $01820c			beq 	TIM_SkipFirst
.018208	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.01820a	d0 01		bne $01820d			bne 	TIM_NotDot
.01820c					TIM_SkipFirst:
.01820c	c8		iny				iny
.01820d					TIM_NotDot:
.01820d	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.01820f	c9 52		cmp #$52			cmp 	#"R"						; show registers
.018211	f0 6b		beq $01827e			beq 	TIM_ShowRegisters
.018213	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.018215	f0 12		beq $018229			beq 	TIM_ShowMemory
.018217	c9 47		cmp #$47			cmp 	#"G"						; execute
.018219	f0 49		beq $018264			beq 	TIM_Execute
.01821b	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.01821d	f0 07		beq $018226			beq 	TIM_GoLoadMemory
.01821f	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.018221	d0 c7		bne $0181ea			bne 	TIM_Error
.018223	4c a2 83	jmp $0183a2			jmp 	TIM_UpdateRegisters
.018226					TIM_GoLoadMemory:
.018226	4c d2 83	jmp $0183d2			jmp 	TIM_LoadMemory
.018229					TIM_ShowMemory:
.018229	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.01822c	b0 bc		bcs $0181ea			bcs 	TIM_Error
.01822e	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.018230	85 12		sta $12				sta 	zTemp2
.018232	a5 15		lda $15				lda 	zTemp3+1
.018234	85 13		sta $13				sta 	zTemp2+1
.018236	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.018239	90 08		bcc $018243			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.01823b	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.01823d	85 14		sta $14				sta 	zTemp3
.01823f	a5 13		lda $13				lda 	zTemp2+1
.018241	85 15		sta $15				sta 	zTemp3+1
.018243					_TIMSM_Start:
.018243	20 f6 82	jsr $0182f6			jsr 	TIM_WriteLine 				; write one line of hex out
.018246	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.018248	18		clc				clc
.018249	69 10		adc #$10			adc 	#16
.01824b	85 12		sta $12				sta 	zTemp2
.01824d	90 02		bcc $018251			bcc 	_TIMSM_NoCarry
.01824f	e6 13		inc $13				inc 	zTemp2+1
.018251					_TIMSM_NoCarry:
.018251	20 d4 81	jsr $0181d4			jsr 	IF_CheckBreak 				; check CTL+C
.018254	d0 0b		bne $018261			bne 	_TIMSM_Ends 				; if pressed break out.
.018256	38		sec				sec 								; check past the end address in zTemp3
.018257	a5 14		lda $14				lda 	zTemp3
.018259	e5 12		sbc $12				sbc 	zTemp2
.01825b	a5 15		lda $15				lda 	zTemp3+1
.01825d	e5 13		sbc $13				sbc 	zTemp2+1
.01825f	10 e2		bpl $018243			bpl 	_TIMSM_Start
.018261					_TIMSM_Ends:
.018261	4c f1 81	jmp $0181f1			jmp 	TIM_NewCommand
.018264					TIM_Execute:
.018264	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; get the execute address
.018267	b0 81		bcs $0181ea			bcs 	TIM_Error 					; not legitimate
.018269	ae cb 03	ldx $03cb			ldx 	TIM_SP 						; set up SP
.01826c	9a		txs				txs
.01826d	ad c6 03	lda $03c6			lda 	TIM_SR 						; Status for PLP
.018270	48		pha				pha
.018271	ad c7 03	lda $03c7			lda 	TIM_A 						; restore AXYZ
.018274	ae c8 03	ldx $03c8			ldx 	TIM_X
.018277	ac c9 03	ldy $03c9			ldy 	TIM_Y
.01827a	28		plp				plp 								; and PS Byte.
.01827b	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.01827e					TIM_Start:
.01827e					TIM_ShowRegisters:
.01827e	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.018281	8d c5 03	sta $03c5			sta 	TIM_IRQ+1
.018284	ad ff ff	lda $ffff			lda 	$FFFF
.018287	8d c4 03	sta $03c4			sta 	TIM_IRQ
.01828a	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.01828c					_TIMSR_Text:
.01828c	bf bd 82 01	lda $0182bd,x			lda 	_TIMSR_Label,x
.018290	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018293	e8		inx				inx
.018294	e0 20		cpx #$20			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.018296	d0 f4		bne $01828c			bne 	_TIMSR_Text
.018298	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.01829a					_TIMSR_Skip:
.01829a	e8		inx				inx
.01829b					_TIMSR_LoopSpace:
.01829b	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.01829d	b0 04		bcs $0182a3			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.01829f	8a		txa				txa
.0182a0	4a		lsr a				lsr 	a
.0182a1	b0 05		bcs $0182a8			bcs 	_TIMSR_NoSpace
.0182a3					_TIMSR_Space:
.0182a3	a9 20		lda #$20			lda 	#" "
.0182a5	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182a8					_TIMSR_NoSpace:
.0182a8	bd c2 03	lda $03c2,x			lda 	TIM_PC,x 					; output hex value.
.0182ab	20 dd 82	jsr $0182dd			jsr 	TIM_WriteHex
.0182ae	e8		inx				inx
.0182af	e0 08		cpx #$08			cpx 	#TIM_Z-TIM_PC
.0182b1	f0 e7		beq $01829a			beq 	_TIMSR_Skip
.0182b3	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.0182b5	d0 e4		bne $01829b			bne 	_TimSR_LoopSpace
.0182b7	20 4f 80	jsr $01804f			jsr 	IFT_NewLine 				; new line
.0182ba	4c f1 81	jmp $0181f1			jmp	 	TIM_NewCommand 				; new command.
.0182bd					_TIMSR_Label:
>0182bd	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>0182c5	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>0182d5	52
>0182d6	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.0182dd					_TIMSR_LabelEnd:
.0182dd					TIM_WriteHex:
.0182dd	48		pha				pha 								; save A
.0182de	4a		lsr a				lsr 	a 							; shift MSB->LSB
.0182df	4a		lsr a				lsr 	a
.0182e0	4a		lsr a				lsr 	a
.0182e1	4a		lsr a				lsr 	a
.0182e2	20 e6 82	jsr $0182e6			jsr 	_TIMWH_Nibble 				; print MSB
.0182e5	68		pla				pla 								; restore and print LSB
.0182e6					_TIMWH_Nibble:
.0182e6	48		pha				pha
.0182e7	29 0f		and #$0f			and 	#15 						; mask out
.0182e9	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.0182eb	90 02		bcc $0182ef			bcc 	_TIMWHNoLetter
.0182ed	69 06		adc #$06			adc 	#6
.0182ef					_TIMWHNoLetter:
.0182ef	69 30		adc #$30			adc 	#48
.0182f1	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter 			; print it out.
.0182f4	68		pla				pla
.0182f5	60		rts				rts
.0182f6					TIM_WriteLine:
.0182f6	a9 2e		lda #$2e			lda 	#"." 						; prompt
.0182f8	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182fb	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.0182fd	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018300	a5 13		lda $13				lda 	zTemp2+1 					; write address
.018302	20 dd 82	jsr $0182dd			jsr 	TIM_WriteHex
.018305	a5 12		lda $12				lda 	zTemp2
.018307	20 dd 82	jsr $0182dd			jsr 	TIM_WriteHex
.01830a	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.01830c					_TIMWL_Loop:
.01830c	a9 20		lda #$20			lda 	#" "
.01830e	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018311	b1 12		lda ($12),y			lda 	(zTemp2),y
.018313	20 dd 82	jsr $0182dd			jsr 	TIM_WriteHex
.018316	c8		iny				iny
.018317	c0 10		cpy #$10			cpy 	#16
.018319	d0 f1		bne $01830c			bne 	_TIMWL_Loop
.01831b	4c 4f 80	jmp $01804f			jmp 	IFT_NewLine 				; new line and exit
.01831e					TIM_GetHex:
.01831e	c8		iny				iny
.01831f	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.018321	c9 20		cmp #$20			cmp 	#32
.018323	f0 f9		beq $01831e			beq 	TIM_GetHex
.018325	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.018327	f0 f5		beq $01831e			beq 	TIM_GetHex
.018329	20 52 83	jsr $018352			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.01832c	b0 23		bcs $018351			bcs 	_TIMGH_Exit					; if first bad then exit now.
.01832e	a9 00		lda #$00			lda 	#0 							; zero result
.018330	85 14		sta $14				sta 	zTemp3
.018332	85 15		sta $15				sta 	zTemp3+1
.018334					_TIM_GHLoop:
.018334	20 52 83	jsr $018352			jsr 	TIM_GetHexCharacter 		; get next character
.018337	b0 17		bcs $018350			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.018339	c8		iny				iny 								; skip over it.
.01833a	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.01833c	26 15		rol $15				rol 	zTemp3+1
.01833e	06 14		asl $14				asl 	zTemp3 						; now x 2
.018340	26 15		rol $15				rol 	zTemp3+1
.018342	06 14		asl $14				asl 	zTemp3						; now x 4
.018344	26 15		rol $15				rol 	zTemp3+1
.018346	06 14		asl $14				asl 	zTemp3 						; now x 8
.018348	26 15		rol $15				rol 	zTemp3+1
.01834a	05 14		ora $14				ora 	zTemp3 						; OR result in
.01834c	85 14		sta $14				sta 	zTemp3
.01834e	80 e4		bra $018334			bra 	_TIM_GHLoop 				; loop round again.
.018350					_TIMGH_Okay:
.018350	18		clc				clc
.018351					_TIMGH_Exit:
.018351	60		rts				rts
.018352					TIM_GetHexCharacter:
.018352	b1 10		lda ($10),y			lda 	(zTemp1),y
.018354	38		sec				sec
.018355	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.018357	90 0e		bcc $018367			bcc 	_TIM_GHCFail
.018359	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.01835b	90 0b		bcc $018368			bcc 	_TIM_GHCExit
.01835d	c9 11		cmp #$11			cmp 	#65-48						; < A
.01835f	90 06		bcc $018367			bcc		_TIM_GHCFail
.018361	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.018363	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.018365	90 01		bcc $018368			bcc		_TIM_GHCExit
.018367					_TIM_GHCFail:
.018367	38		sec				sec
.018368					_TIM_GHCExit:
.018368	60		rts				rts
.018369					TIM_BreakVector:
.018369	da		phx				phx									; save X/A on stack
.01836a	48		pha				pha
.01836b	ba		tsx				tsx 								; X points to S
.01836c	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.01836f	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.018371	d0 03		bne $018376			bne 	_TIMBreak					; if set, it's BRK
.018373	68		pla				pla 								; abandon routine.
.018374	fa		plx				plx
.018375	40		rti				rti
.018376					_TIMBreak:
.018376	68		pla				pla 								; save A X Y and maybe Z
.018377	8d c7 03	sta $03c7			sta 	TIM_A
.01837a	fa		plx				plx
.01837b	8e c8 03	stx $03c8			stx 	TIM_X
.01837e	8c c9 03	sty $03c9			sty 	TIM_Y
.018381	68		pla				pla 								; get Status Register
.018382	8d c6 03	sta $03c6			sta 	TIM_SR
.018385	68		pla				pla
.018386	8d c3 03	sta $03c3			sta 	TIM_PC+1 					; save calling address
.018389	68		pla				pla
.01838a	8d c2 03	sta $03c2			sta 	TIM_PC 						; high byte
.01838d	ad c3 03	lda $03c3			lda 	TIM_PC+1 					; dec PC to point right.
.018390	d0 03		bne $018395			bne 	_TIMDecrement 				; brk bumps it.
.018392	ce c2 03	dec $03c2			dec 	TIM_PC
.018395					_TIMDecrement:
.018395	ce c3 03	dec $03c3			dec 	TIM_PC+1
.018398	ba		tsx				tsx 								; and copy SP
.018399	8e cb 03	stx $03cb			stx 	TIM_SP
.01839c	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.01839e	9a		txs				txs
.01839f	4c 7e 82	jmp $01827e			jmp 	TIM_Start 					; and start up TIM monitor.
.0183a2					TIM_UpdateRegisters:
.0183a2	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; PC
.0183a5	b0 28		bcs $0183cf			bcs 	_TIMURFail
.0183a7	a5 14		lda $14				lda 	zTemp3
.0183a9	8d c3 03	sta $03c3			sta 	Tim_PC+1
.0183ac	a5 15		lda $15				lda 	zTemp3+1
.0183ae	8d c2 03	sta $03c2			sta 	Tim_PC
.0183b1	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; ignore IRQ
.0183b4	b0 19		bcs $0183cf			bcs 	_TIMURFail
.0183b6	a2 00		ldx #$00			ldx 	#0
.0183b8					_TIM_URLoop:
.0183b8	e0 04		cpx #$04			cpx 	#Tim_Z-Tim_SR
.0183ba	d0 01		bne $0183bd			bne 	_TIM_1
.0183bc	e8		inx				inx
.0183bd					_TIM_1:
.0183bd	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; registers
.0183c0	b0 0d		bcs $0183cf			bcs 	_TIMURFail
.0183c2	a5 14		lda $14				lda 	zTemp3
.0183c4	9d c6 03	sta $03c6,x			sta 	Tim_SR,x
.0183c7	e8		inx				inx
.0183c8	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.0183ca	d0 ec		bne $0183b8			bne 	_TIM_URLoop
.0183cc	4c f1 81	jmp $0181f1			jmp 	TIM_NewCommand
.0183cf					_TIMURFail:
.0183cf	4c ea 81	jmp $0181ea			jmp 	TIM_Error
.0183d2					TIM_LoadMemory:
.0183d2	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; target address => zTemp2
.0183d5	a5 14		lda $14				lda 	zTemp3
.0183d7	85 12		sta $12				sta 	zTemp2
.0183d9	a5 15		lda $15				lda 	zTemp3+1
.0183db	85 13		sta $13				sta 	zTemp2+1
.0183dd					_TIM_LMLoop:
.0183dd	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; next byte ?
.0183e0	b0 0e		bcs $0183f0			bcs 	_TIMLMDone 					; no more
.0183e2	a2 00		ldx #$00			ldx 	#0							; write out.
.0183e4	a5 14		lda $14				lda 	zTemp3
.0183e6	81 12		sta ($12,x)			sta 	(zTemp2,x)
.0183e8	e6 12		inc $12				inc 	zTemp2 						; bump address
.0183ea	d0 f1		bne $0183dd			bne 	_TIM_LMLoop
.0183ec	e6 13		inc $13				inc 	zTemp2+1
.0183ee	80 ed		bra $0183dd			bra 	_TIM_LMLoop
.0183f0					_TIMLMDone:
.0183f0	4c f1 81	jmp $0181f1			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/skip.asm

.0183f3					StructureSearchSingle:
.0183f3	a2 00		ldx #$00			ldx 	#0
.0183f5					StructureSearchDouble:
.0183f5	85 10		sta $10				sta 	zTemp1 						; save the target on zTemp1,zTemp1+1
.0183f7	86 11		stx $11				stx 	zTemp1+1
.0183f9	a9 00		lda #$00			lda 	#0 							; set the structure depth to zero (zTemp2)
.0183fb	85 12		sta $12				sta 	zTemp2
.0183fd	80 18		bra $018417			bra 	_SSWLoop 					; jump in, start scanning from here.
.0183ff					_SSWNextLine:
.0183ff	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018401	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.018403	18		clc				clc
.018404	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018406	85 16		sta $16				sta 	zCodePtr
.018408	90 02		bcc $01840c			bcc 	_SNLNoCarry
.01840a	e6 17		inc $17				inc 	zCodePtr+1
.01840c					_SNLNoCarry:
.01840c	a0 00		ldy #$00			ldy 	#0
.01840e	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018410	c9 00		cmp #$00			cmp 	#0					 		; if zero, fail.
.018412	f0 54		beq $018468			beq 	_SSWFail
.018414	c8		iny				iny
.018415	c8		iny				iny
.018416					_SSWNextSimple:
.018416	c8		iny				iny
.018417					_SSWLoop:
.018417	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018419	c9 00		cmp #$00			cmp 	#0 							; end of line ?
.01841b	f0 e2		beq $0183ff			beq 	_SSWNextLine 				; if so, then next line
.01841d	10 f7		bpl $018416			bpl 	_SSWNextSimple 				; needs to be a token, just skip char/number.
.01841f	a6 12		ldx $12				ldx 	zTemp2 						; check structure count
.018421	d0 08		bne $01842b			bne 	_SSWCheckUpDown 			; if it's non zero, then a match doesn't work.
.018423	c5 10		cmp $10				cmp 	zTemp1 						; found the right keyword, either choice.
.018425	f0 2d		beq $018454			beq 	_SSWFound 					; so exit.
.018427	c5 11		cmp $11				cmp 	zTemp1+1
.018429	f0 29		beq $018454			beq 	_SSWFound
.01842b					_SSWCheckUpDown:
.01842b	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus 			; if < keyword +
.01842d	90 10		bcc $01843f			bcc 	_SSWNext
.01842f	c9 93		cmp #$93			cmp 	#firstKeywordMinus 			; if < keyword - then as keyword +
.018431	90 08		bcc $01843b			bcc 	_SSWPlus
.018433	c9 98		cmp #$98			cmp 	#firstUnaryFunction			; if < first unary down as keyword -
.018435	b0 08		bcs $01843f			bcs 	_SSWNext
.018437	c6 12		dec $12				dec 	zTemp2 						; reduce structure count.
.018439	c6 12		dec $12				dec 	zTemp2
.01843b					_SSWPlus:
.01843b	e6 12		inc $12				inc 	zTemp2
.01843d	30 16		bmi $018455			bmi 	_SSWUnder					; error if driven -ve
.01843f					_SSWNext:
.01843f	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018441	c8		iny				iny 								; skip
.018442	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018444	90 0c		bcc $018452			bcc 	_SEDone 					; so just skip over it.
.018446	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018448	90 07		bcc $018451			bcc 	_SEDouble
.01844a	98		tya				tya 								; this is Y + 1
.01844b	18		clc				clc
.01844c	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.01844e	a8		tay				tay 								; back in Y.
.01844f	88		dey				dey 								; fix up, one for the +1, one for the iny
.018450	88		dey				dey
.018451					_SEDouble:
.018451	c8		iny				iny
.018452					_SEDone:
.018452	80 c3		bra $018417			bra 	_SSWLoop
.018454					_SSWFound:
.018454	60		rts				rts
.018455					_SSWUnder:
.018455	20 79 85	jsr $018579			jsr ERR_Handler
>018458	53 74 72 75 63 74 75 72			.text "Structure order",0
>018460	65 20 6f 72 64 65 72 00
.018468					_SSWFail:
.018468	20 79 85	jsr $018579			jsr ERR_Handler
>01846b	43 61 6e 27 74 20 66 69			.text "Can't find structure",0
>018473	6e 64 20 73 74 72 75 63 74 75 72 65 00
.018480					SkipEndOfCommand:
.018480	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018482	c9 00		cmp #$00			cmp 	#0 							; if zero, end of line, so exit
.018484	f0 19		beq $01849f			beq 	_SOCExit
.018486	c9 c0		cmp #$c0			cmp 	#token_Colon 				; if colon, end of command
.018488	f0 15		beq $01849f			beq 	_SOCExit
.01848a	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.01848c	c8		iny				iny 								; skip
.01848d	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.01848f	90 0c		bcc $01849d			bcc 	_SEDone 					; so just skip over it.
.018491	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018493	90 07		bcc $01849c			bcc 	_SEDouble
.018495	98		tya				tya 								; this is Y + 1
.018496	18		clc				clc
.018497	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018499	a8		tay				tay 								; back in Y.
.01849a	88		dey				dey 								; fix up, one for the +1, one for the iny
.01849b	88		dey				dey
.01849c					_SEDouble:
.01849c	c8		iny				iny
.01849d					_SEDone:
.01849d	80 e1		bra $018480			bra 	SkipEndOfCommand
.01849f					_SOCExit:
.01849f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stack.asm

.0184a0					StackReset:
.0184a0	48		pha				pha
.0184a1	5a		phy				phy
.0184a2	a9 00		lda #$00			lda 	#(BasicStack & $FF) 		; reset pointer
.0184a4	85 26		sta $26				sta 	zBasicSP
.0184a6	a9 04		lda #$04			lda 	#(BasicStack >> 8)
.0184a8	85 27		sta $27				sta 	zBasicSP+1
.0184aa	a0 00		ldy #$00			ldy 	#0 							; reset stack top to $00 which cannot
.0184ac	98		tya				tya 								; be a legal token.
.0184ad	91 26		sta ($26),y			sta 	(zBasicSP),y
.0184af	7a		ply				ply
.0184b0	68		pla				pla
.0184b1	60		rts				rts
.0184b2					StackPushFrame:
.0184b2	48		pha				pha
.0184b3	5a		phy				phy
.0184b4	1a		inc a				inc 	a 							; one extra byte in frame, for the marker.
.0184b5	48		pha				pha 								; save it.
.0184b6	29 0f		and #$0f			and 	#$0F 						; lower 4 bits
.0184b8	18		clc				clc 								; add to Basic Stack
.0184b9	65 26		adc $26				adc 	zBasicSP
.0184bb	85 26		sta $26				sta 	zBasicSP
.0184bd	90 02		bcc $0184c1			bcc 	_SPFNoBump
.0184bf	e6 27		inc $27				inc 	zBasicSP+1
.0184c1					_SPFNoBump:
.0184c1	a0 00		ldy #$00			ldy 	#0
.0184c3	68		pla				pla
.0184c4	91 26		sta ($26),y			sta 	(zBasicSP),y
.0184c6	7a		ply				ply
.0184c7	68		pla				pla
.0184c8	60		rts				rts
.0184c9					StackPopFrame:
.0184c9	48		pha				pha
.0184ca	5a		phy				phy
.0184cb	a0 00		ldy #$00			ldy 	#0 							; compare with top of stack using EOR
.0184cd	51 26		eor ($26),y			eor 	(zBasicSP),y
.0184cf	29 f0		and #$f0			and 	#$F0 						; top 4 bits zero, match
.0184d1	d0 12		bne $0184e5			bne 	SPFError 					; mixed structures
.0184d3	b1 26		lda ($26),y			lda 	(zBasicSP),y 				; get size from byte
.0184d5	29 0f		and #$0f			and 	#$0F
.0184d7	49 ff		eor #$ff			eor 	#$FF						; 2's complement
.0184d9	38		sec				sec
.0184da	65 26		adc $26				adc 	zBasicSP
.0184dc	85 26		sta $26				sta 	zBasicSP
.0184de	b0 02		bcs $0184e2			bcs 	_SPFNoBump
.0184e0	c6 27		dec $27				dec 	zBasicSP+1
.0184e2					_SPFNoBump:
.0184e2	7a		ply				ply
.0184e3	68		pla				pla
.0184e4	60		rts				rts
.0184e5					SPFError:
.0184e5	20 79 85	jsr $018579			jsr ERR_Handler
>0184e8	4d 69 78 65 64 20 53 74			.text "Mixed Structures",0
>0184f0	72 75 63 74 75 72 65 73 00
.0184f9					StackSavePosition:
.0184f9	98		tya				tya
.0184fa	5a		phy				phy
.0184fb	a0 05		ldy #$05			ldy 	#5
.0184fd	91 26		sta ($26),y			sta 	(zBasicSP),y
.0184ff	a0 01		ldy #$01			ldy 	#1
.018501	a5 16		lda $16				lda 	zCodePtr+0 					; 4 bytes, could reduce this for 65816/6502
.018503	91 26		sta ($26),y			sta 	(zBasicSP),y
.018505	c8		iny				iny
.018506	a5 17		lda $17				lda 	zCodePtr+1
.018508	91 26		sta ($26),y			sta 	(zBasicSP),y
.01850a	c8		iny				iny
.01850b	a5 18		lda $18				lda 	zCodePtr+2
.01850d	91 26		sta ($26),y			sta 	(zBasicSP),y
.01850f	c8		iny				iny
.018510	a5 19		lda $19				lda 	zCodePtr+3
.018512	91 26		sta ($26),y			sta 	(zBasicSP),y
.018514	7a		ply				ply
.018515	60		rts				rts
.018516					StackRestorePosition:
.018516	5a		phy				phy
.018517	a0 01		ldy #$01			ldy 	#1 							; copy 4 bytes that are the pointer
.018519	b1 26		lda ($26),y			lda 	(zBasicSP),y
.01851b	85 16		sta $16				sta 	zCodePtr+0
.01851d	c8		iny				iny
.01851e	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018520	85 17		sta $17				sta 	zCodePtr+1
.018522	c8		iny				iny
.018523	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018525	85 18		sta $18				sta 	zCodePtr+2
.018527	c8		iny				iny
.018528	b1 26		lda ($26),y			lda 	(zBasicSP),y
.01852a	85 19		sta $19				sta 	zCodePtr+3
.01852c	c8		iny				iny
.01852d	b1 26		lda ($26),y			lda 	(zBasicSP),y 				; offset
.01852f	7a		ply				ply 								; restore Y
.018530	a8		tay				tay
.018531	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/vectors.asm

.018532					VIOCharPrint:
.018532	4c 35 80	jmp $018035			jmp 	IFT_PrintCharacter
.018535					VIOCharGet:
.018535	20 d9 81	jsr $0181d9			jsr 	IF_GetKey
.018538	c9 00		cmp #$00			cmp 	#0
.01853a	f0 02		beq $01853e			beq 	_VCG0
.01853c	38		sec				sec
.01853d	60		rts				rts
.01853e	18		clc		_VCG0:	clc
.01853f	60		rts				rts
.018540					VIOCheckBreak:
.018540	4c d4 81	jmp $0181d4			jmp 	IF_CheckBreak
.018543					VIOCharGetPosition:
.018543	ad 00 05	lda $0500			lda 	IFT_XCursor
.018546	60		rts				rts
.018547					VIOReadLine:
.018547	4c ed 80	jmp $0180ed			jmp 	IFT_ReadLine

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/errors.asm

.01854a					SyntaxError:
.01854a	20 79 85	jsr $018579			jsr 	ERR_Handler
>01854d	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>018555	72 72 6f 72 00
.01855a					TypeError:
.01855a	20 79 85	jsr $018579			jsr 	ERR_Handler
>01855d	57 72 6f 6e 67 20 74 79				.text 	"Wrong type",0
>018565	70 65 00
.018568					BadParamError:
.018568	20 79 85	jsr $018579			jsr 	ERR_Handler
>01856b	42 61 64 20 50 61 72 61				.text 	"Bad Parameter",0
>018573	6d 65 74 65 72 00
.018579					ERR_Handler:
.018579	a0 00		ldy #$00			ldy 	#0
.01857b	c8		iny				iny
.01857c	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01857e	85 80		sta $80				sta 	XS_Mantissa
.018580	c8		iny				iny
.018581	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018583	85 81		sta $81				sta 	XS_Mantissa+1
.018585	fa		plx				plx 								; address in XY
.018586	7a		ply				ply
.018587	e8		inx				inx 								; bump, because of RTS/JSR address -1
.018588	d0 01		bne $01858b			bne 	_EHNoSkip
.01858a	c8		iny				iny
.01858b					_EHNoSkip:
.01858b	20 aa 85	jsr $0185aa			jsr 	PrintROMMessage 			; print message from ROM.
.01858e	a5 80		lda $80				lda 	XS_Mantissa					; line number = 0
.018590	05 81		ora $81				ora 	XS_Mantissa+1
.018592	f0 0c		beq $0185a0			beq 	_EHNoLine
.018594	a2 a5		ldx #$a5			ldx 	#_EHAt & $FF 				; print " at "
.018596	a0 85		ldy #$85			ldy 	#(_EHAt >> 8) & $FF
.018598	20 aa 85	jsr $0185aa			jsr 	PrintROMMessage
.01859b	a2 00		ldx #$00			ldx 	#0 							; Print line number
.01859d	20 bf 85	jsr $0185bf			jsr 	Print16BitInteger
.0185a0					_EHNoLine:
.0185a0	80 fe		bra $0185a0			bra 	_EHNoLine
.0185a2	4c 32 88	jmp $018832			jmp 	WarmStart
>0185a5	20 61 74 20 00			_EHAt:	.text 	" at ",0
.0185aa					PrintROMMessage:
.0185aa	86 1a		stx $1a				stx 	zLTemp1 					; save addres
.0185ac	84 1b		sty $1b				sty 	zLTemp1+1
.0185ae	4b		phk				phk
.0185af	68		pla				pla
.0185b0	85 1c		sta $1c				sta 	ZLTemp1+2
.0185b2	a0 00		ldy #$00			ldy 	#0
.0185b4					_PRMLoop:
.0185b4	b7 1a		lda [$1a],y			lda 	[zLTemp1],y
.0185b6	f0 06		beq $0185be			beq		_PRMExit
.0185b8	c8		iny				iny
.0185b9	20 32 85	jsr $018532			jsr 	VIOCharPrint
.0185bc	80 f6		bra $0185b4			bra 	_PRMLoop
.0185be					_PRMExit:
.0185be	60		rts				rts
.0185bf					Print16BitInteger:
.0185bf	a9 00		lda #$00			lda 	#0 							; make 32 bit
.0185c1	85 82		sta $82				sta 	XS_Mantissa+2
.0185c3	85 83		sta $83				sta 	XS_Mantissa+3
.0185c5					Print32BitInteger:
.0185c5	a9 00		lda #$00			lda 	#0
.0185c7	8d 14 03	sta $0314			sta 	NumBufX 					; reset the conversion pointer
.0185ca	aa		tax				tax 								; convert bottom level.
.0185cb	20 e1 9d	jsr $019de1			jsr 	INTToString 				; make string
.0185ce	a2 00		ldx #$00			ldx 	#0 							; print buffer
.0185d0	bd 15 03	lda $0315,x	_P1Loop:lda 	Num_Buffer,x
.0185d3	f0 06		beq $0185db			beq 	_P1Exit
.0185d5	20 32 85	jsr $018532			jsr 	VIOCharPrint
.0185d8	e8		inx				inx
.0185d9	80 f5		bra $0185d0			bra 	_P1Loop
.0185db	8a		txa		_P1Exit:txa 								; return chars printed.
.0185dc	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm


;******  Processing file: modules/basic/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b6					lastUnaryFunction = $b6
.0185dd					VectorTable:
>0185dd	39 92					.word BinaryOp_And         & $FFFF ; $80 and
>0185df	55 92					.word BinaryOp_Or          & $FFFF ; $81 or
>0185e1	71 92					.word BinaryOp_Xor         & $FFFF ; $82 xor
>0185e3	71 92					.word BinaryOp_Eor         & $FFFF ; $83 eor
>0185e5	a8 92					.word Binary_Equal         & $FFFF ; $84 =
>0185e7	c2 92					.word Binary_NotEqual      & $FFFF ; $85 <>
>0185e9	cb 92					.word Binary_Less          & $FFFF ; $86 <
>0185eb	d4 92					.word Binary_LessEqual     & $FFFF ; $87 <=
>0185ed	e6 92					.word Binary_Greater       & $FFFF ; $88 >
>0185ef	dd 92					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>0185f1	6b 93					.word BinaryOp_Add         & $FFFF ; $8a +
>0185f3	87 93					.word BinaryOp_Subtract    & $FFFF ; $8b -
>0185f5	98 93					.word BinaryOp_Multiply    & $FFFF ; $8c *
>0185f7	a9 93					.word BinaryOp_Divide      & $FFFF ; $8d /
>0185f9	9b 86					.word NotImplemented       & $FFFF ; $8e ^
>0185fb	c7 8b					.word Command_IF           & $FFFF ; $8f if
>0185fd	35 90					.word Command_WHILE        & $FFFF ; $90 while
>0185ff	5d 90					.word Command_REPEAT       & $FFFF ; $91 repeat
>018601	94 89					.word Command_FOR          & $FFFF ; $92 for
>018603	9b 86					.word NotImplemented       & $FFFF ; $93 then
>018605	24 8c					.word Command_ENDIF        & $FFFF ; $94 endif
>018607	52 90					.word Command_WEND         & $FFFF ; $95 wend
>018609	66 90					.word Command_UNTIL        & $FFFF ; $96 until
>01860b	11 8a					.word Command_NEXT         & $FFFF ; $97 next
>01860d	9b 86					.word NotImplemented       & $FFFF ; $98 not
>01860f	9b 86					.word NotImplemented       & $FFFF ; $99 fn(
>018611	ae 94					.word Unary_Abs            & $FFFF ; $9a abs(
>018613	fb 95					.word Unary_Asc            & $FFFF ; $9b asc(
>018615	0d a5					.word Unary_Int            & $FFFF ; $9c int(
>018617	c8 94					.word Unary_Peek           & $FFFF ; $9d peek(
>018619	8e a4					.word Unary_Rnd            & $FFFF ; $9e rnd(
>01861b	3b 95					.word Unary_Usr            & $FFFF ; $9f usr(
>01861d	3a 96					.word Unary_Left           & $FFFF ; $a0 left$(
>01861f	4f 96					.word Unary_Right          & $FFFF ; $a1 right$(
>018621	21 96					.word Unary_Mid            & $FFFF ; $a2 mid$(
>018623	98 97					.word Unary_Spc            & $FFFF ; $a3 spc(
>018625	c9 95					.word Unary_Str            & $FFFF ; $a4 str$(
>018627	5d 95					.word Unary_Val            & $FFFF ; $a5 val(
>018629	12 96					.word Unary_Len            & $FFFF ; $a6 len(
>01862b	c7 96					.word Unary_Hex            & $FFFF ; $a7 hex$(
>01862d	9b 86					.word NotImplemented       & $FFFF ; $a8 sin(
>01862f	9b 86					.word NotImplemented       & $FFFF ; $a9 cos(
>018631	9b 86					.word NotImplemented       & $FFFF ; $aa tan(
>018633	9b 86					.word NotImplemented       & $FFFF ; $ab atn(
>018635	9b 86					.word NotImplemented       & $FFFF ; $ac exp(
>018637	9b 86					.word NotImplemented       & $FFFF ; $ad log(
>018639	9b 86					.word NotImplemented       & $FFFF ; $ae sqr(
>01863b	1d 97					.word Unary_Dec            & $FFFF ; $af dec(
>01863d	cc 94					.word Unary_Deek           & $FFFF ; $b0 deek(
>01863f	d0 94					.word Unary_Leek           & $FFFF ; $b1 leek(
>018641	08 95					.word Unary_Mod            & $FFFF ; $b2 mod(
>018643	68 94					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>018645	7a 97					.word Unary_Chr            & $FFFF ; $b4 chr$(
>018647	fc 94					.word Unary_Pos            & $FFFF ; $b5 pos(
>018649	bb 97					.word Unary_Tab            & $FFFF ; $b6 tab(
>01864b	9b 86					.word NotImplemented       & $FFFF ; $b7 $
>01864d	9b 86					.word NotImplemented       & $FFFF ; $b8 $(
>01864f	9b 86					.word NotImplemented       & $FFFF ; $b9 #
>018651	9b 86					.word NotImplemented       & $FFFF ; $ba #(
>018653	9b 86					.word NotImplemented       & $FFFF ; $bb %
>018655	9b 86					.word NotImplemented       & $FFFF ; $bc %(
>018657	9b 86					.word NotImplemented       & $FFFF ; $bd (
>018659	9b 86					.word NotImplemented       & $FFFF ; $be )
>01865b	9b 86					.word NotImplemented       & $FFFF ; $bf ,
>01865d	93 89					.word Command_COLON        & $FFFF ; $c0 :
>01865f	9b 86					.word NotImplemented       & $FFFF ; $c1 ;
>018661	9b 86					.word NotImplemented       & $FFFF ; $c2 def
>018663	16 90					.word Command_CLR          & $FFFF ; $c3 clr
>018665	2d 90					.word Command_STOP         & $FFFF ; $c4 stop
>018667	ea 8a					.word Command_DATA         & $FFFF ; $c5 data
>018669	c4 8a					.word Command_READ         & $FFFF ; $c6 read
>01866b	3f 88					.word Command_DIM          & $FFFF ; $c7 dim
>01866d	9b 86					.word NotImplemented       & $FFFF ; $c8 to
>01866f	9b 86					.word NotImplemented       & $FFFF ; $c9 step
>018671	5c 8f					.word Command_GOSUB        & $FFFF ; $ca gosub
>018673	6c 8f					.word Command_RETURN       & $FFFF ; $cb return
>018675	54 8f					.word Command_GOTO         & $FFFF ; $cc goto
>018677	c3 8b					.word Command_END          & $FFFF ; $cd end
>018679	9b 86					.word NotImplemented       & $FFFF ; $ce input
>01867b	88 8b					.word Command_LET          & $FFFF ; $cf let
>01867d	2a 8c					.word Command_LIST         & $FFFF ; $d0 list
>01867f	fd 8e					.word Command_NEW          & $FFFF ; $d1 new
>018681	19 8f					.word Command_OLD          & $FFFF ; $d2 old
>018683	75 8f					.word Command_ON           & $FFFF ; $d3 on
>018685	ed 8a					.word Command_RESTORE      & $FFFF ; $d4 restore
>018687	cc 8e					.word Command_POKE         & $FFFF ; $d5 poke
>018689	1e 8e					.word Command_PRINT        & $FFFF ; $d6 print
>01868b	05 89					.word Command_RUN          & $FFFF ; $d7 run
>01868d	c7 88					.word Command_WAIT         & $FFFF ; $d8 wait
>01868f	a9 8b					.word Command_SYS          & $FFFF ; $d9 sys
>018691	d0 8e					.word Command_DOKE         & $FFFF ; $da doke
>018693	d4 8e					.word Command_LOKE         & $FFFF ; $db loke
>018695	b4 8e					.word Command_ASSERT       & $FFFF ; $dc assert
>018697	9b 86					.word NotImplemented       & $FFFF ; $dd get
>018699	1e 8c					.word Command_ELSE         & $FFFF ; $de else
.01869b					NotImplemented:
.01869b	20 79 85	jsr $018579			jsr ERR_Handler
>01869e	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>0186a6	65 6d 65 6e 74 65 64 00
.0186ae					BinaryPrecedence:
>0186ae	01					.byte 1    ; $80 and
>0186af	01					.byte 1    ; $81 or
>0186b0	01					.byte 1    ; $82 xor
>0186b1	01					.byte 1    ; $83 eor
>0186b2	02					.byte 2    ; $84 =
>0186b3	02					.byte 2    ; $85 <>
>0186b4	02					.byte 2    ; $86 <
>0186b5	02					.byte 2    ; $87 <=
>0186b6	02					.byte 2    ; $88 >
>0186b7	02					.byte 2    ; $89 >=
>0186b8	03					.byte 3    ; $8a +
>0186b9	03					.byte 3    ; $8b -
>0186ba	04					.byte 4    ; $8c *
>0186bb	04					.byte 4    ; $8d /
>0186bc	05					.byte 5    ; $8e ^
.0186bd					KeywordText:
>0186bd	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>0186c0	4f d2					.byte $4f,$d2                          ; $81 or
>0186c2	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>0186c5	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>0186c8	bd					.byte $bd                              ; $84 =
>0186c9	3c be					.byte $3c,$be                          ; $85 <>
>0186cb	bc					.byte $bc                              ; $86 <
>0186cc	3c bd					.byte $3c,$bd                          ; $87 <=
>0186ce	be					.byte $be                              ; $88 >
>0186cf	3e bd					.byte $3e,$bd                          ; $89 >=
>0186d1	ab					.byte $ab                              ; $8a +
>0186d2	ad					.byte $ad                              ; $8b -
>0186d3	aa					.byte $aa                              ; $8c *
>0186d4	af					.byte $af                              ; $8d /
>0186d5	de					.byte $de                              ; $8e ^
>0186d6	49 c6					.byte $49,$c6                          ; $8f if
>0186d8	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>0186dd	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>0186e3	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>0186e6	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>0186ea	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>0186ef	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>0186f3	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>0186f8	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>0186fc	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>0186ff	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>018702	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>018706	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>01870a	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>01870e	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>018713	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>018717	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>01871b	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>018721	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>018728	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>01872d	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>018731	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>018736	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>01873a	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>01873e	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>018743	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>018747	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>01874b	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>01874f	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>018753	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>018757	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>01875b	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>01875f	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>018763	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>018768	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>01876d	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>018771	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>018775	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>01877a	50 4f 53 a8				.byte $50,$4f,$53,$a8                  ; $b5 pos(
>01877e	54 41 42 a8				.byte $54,$41,$42,$a8                  ; $b6 tab(
>018782	a4					.byte $a4                              ; $b7 $
>018783	24 a8					.byte $24,$a8                          ; $b8 $(
>018785	a3					.byte $a3                              ; $b9 #
>018786	23 a8					.byte $23,$a8                          ; $ba #(
>018788	a5					.byte $a5                              ; $bb %
>018789	25 a8					.byte $25,$a8                          ; $bc %(
>01878b	a8					.byte $a8                              ; $bd (
>01878c	a9					.byte $a9                              ; $be )
>01878d	ac					.byte $ac                              ; $bf ,
>01878e	ba					.byte $ba                              ; $c0 :
>01878f	bb					.byte $bb                              ; $c1 ;
>018790	44 45 c6				.byte $44,$45,$c6                      ; $c2 def
>018793	43 4c d2				.byte $43,$4c,$d2                      ; $c3 clr
>018796	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $c4 stop
>01879a	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c5 data
>01879e	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c6 read
>0187a2	44 49 cd				.byte $44,$49,$cd                      ; $c7 dim
>0187a5	54 cf					.byte $54,$cf                          ; $c8 to
>0187a7	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c9 step
>0187ab	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $ca gosub
>0187b0	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $cb return
>0187b6	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $cc goto
>0187ba	45 4e c4				.byte $45,$4e,$c4                      ; $cd end
>0187bd	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $ce input
>0187c2	4c 45 d4				.byte $4c,$45,$d4                      ; $cf let
>0187c5	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $d0 list
>0187c9	4e 45 d7				.byte $4e,$45,$d7                      ; $d1 new
>0187cc	4f 4c c4				.byte $4f,$4c,$c4                      ; $d2 old
>0187cf	4f ce					.byte $4f,$ce                          ; $d3 on
>0187d1	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d4 restore
>0187d8	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d5 poke
>0187dc	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d6 print
>0187e1	52 55 ce				.byte $52,$55,$ce                      ; $d7 run
>0187e4	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d8 wait
>0187e8	53 59 d3				.byte $53,$59,$d3                      ; $d9 sys
>0187eb	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $da doke
>0187ef	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $db loke
>0187f3	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $dc assert
>0187f9	47 45 d4				.byte $47,$45,$d4                      ; $dd get
>0187fc	45 4c 53 c5				.byte $45,$4c,$53,$c5                  ; $de else
>018800	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_pos = $b5
=$b6					token_tab = $b6
=$b7					token_dollar = $b7
=$b8					token_dollarlparen = $b8
=$b9					token_hash = $b9
=$ba					token_hashlparen = $ba
=$bb					token_percent = $bb
=$bc					token_percentlparen = $bc
=$bd					token_lparen = $bd
=$be					token_rparen = $be
=$bf					token_comma = $bf
=$c0					token_colon = $c0
=$c1					token_semicolon = $c1
=$c2					token_def = $c2
=$c3					token_clr = $c3
=$c4					token_stop = $c4
=$c5					token_data = $c5
=$c6					token_read = $c6
=$c7					token_dim = $c7
=$c8					token_to = $c8
=$c9					token_step = $c9
=$ca					token_gosub = $ca
=$cb					token_return = $cb
=$cc					token_goto = $cc
=$cd					token_end = $cd
=$ce					token_input = $ce
=$cf					token_let = $cf
=$d0					token_list = $d0
=$d1					token_new = $d1
=$d2					token_old = $d2
=$d3					token_on = $d3
=$d4					token_restore = $d4
=$d5					token_poke = $d5
=$d6					token_print = $d6
=$d7					token_run = $d7
=$d8					token_wait = $d8
=$d9					token_sys = $d9
=$da					token_doke = $da
=$db					token_loke = $db
=$dc					token_assert = $dc
=$dd					token_get = $dd
=$de					token_else = $de

;******  Return to file: modules/basic/core.asm

.018801					BASIC_Start:
.018801	20 9b 81	jsr $01819b			jsr 	IF_Reset 					; set up and clear screen.
.018804	20 00 80	jsr $018000			jsr 	IFT_ClearScreen
.018807	a9 5c		lda #$5c			lda 	#$5C 						; JMP Long opcode
.018809	8d 10 03	sta $0310			sta 	LocalVector
.01880c	8d 0c 03	sta $030c			sta 	UserVector
.01880f	a9 4b		lda #$4b			lda 	#USRDefault & $FF 			; reset USR vector
.018811	8d 0d 03	sta $030d			sta 	UserVector+1
.018814	a9 95		lda #$95			lda 	#(USRDefault >> 8) & $FF
.018816	8d 0e 03	sta $030e			sta 	UserVector+2
.018819	a9 01		lda #$01			lda 	#(USRDefault >> 16) & $FF
.01881b	8d 0f 03	sta $030f			sta 	UserVector+3
.01881e	20 02 98	jsr $019802			jsr 	UpdateProgramEnd 			; update the program end.
.018821	20 16 90	jsr $019016			jsr 	ResetRunStatus 				; clear everything (CLR command)
.018824	c2 30		rep #$30			rep 	#$30
.018826	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.018829	1b		tcs				tcs
.01882a	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.01882d	e2 30		sep #$30			sep 	#$30
.01882f	4c 05 89	jmp $018905			jmp 	COMMAND_Run
.018832					WarmStart:
.018832	c2 30		rep #$30			rep 	#$30
.018834	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.018837	1b		tcs				tcs
.018838	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.01883b	e2 30		sep #$30			sep 	#$30
.01883d	80 f3		bra $018832			bra 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/dim.asm

.01883f					Command_DIM:
.01883f	98		tya				tya
.018840	48		pha				pha 								; push on stack.
.018841	20 6a 99	jsr $01996a			jsr 	VariableExtract 			; get the identifier
.018844	ad 95 03	lda $0395			lda 	Var_Type 					; check it is an array
.018847	29 01		and #$01			and 	#1
.018849	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.01884b	d0 6c		bne $0188b9			bne 	_CDIError
.01884d	a9 00		lda #$00			lda 	#0 							; reset the DIM index. The dimensions are
.01884f	8d b9 03	sta $03b9			sta 	UsrArrayIdx 				; built up here and copied in case we autodim
.018852					_CDIGetDimension:
.018852	ad b9 03	lda $03b9			lda 	UsrArrayIdx 				; done too many ?
.018855	c9 06		cmp #$06			cmp 	#ArrayMaxDim*2
.018857	f0 60		beq $0188b9			beq 	_CDIError
.018859	20 1a 92	jsr $01921a			jsr 	EvaluateInteger 			; evaluate an index size
.01885c	a5 81		lda $81				lda 	XS_Mantissa+1 				; check in range 0-7FFF
.01885e	29 80		and #$80			and 	#$80
.018860	05 82		ora $82				ora 	XS_Mantissa+2
.018862	05 83		ora $83				ora 	XS_Mantissa+3
.018864	d0 53		bne $0188b9			bne 	_CDIError
.018866	ae b9 03	ldx $03b9			ldx 	UsrArrayIdx 				; copy into the array table.
.018869	18		clc				clc 								; add 1 - max index => size.
.01886a	a5 80		lda $80				lda 	XS_Mantissa+0
.01886c	69 01		adc #$01			adc 	#1
.01886e	9d b1 03	sta $03b1,x			sta 	UsrArrayDef+0,x
.018871	a5 81		lda $81				lda 	XS_Mantissa+1
.018873	69 00		adc #$00			adc 	#0
.018875	9d b2 03	sta $03b2,x			sta 	UsrArrayDef+1,x
.018878	30 3f		bmi $0188b9			bmi 	_CDIError 					; could be dim a(32767)
.01887a	e8		inx				inx 								; bump index.
.01887b	e8		inx				inx
.01887c	8e b9 03	stx $03b9			stx 	UsrArrayIdx
.01887f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018881	c8		iny				iny
.018882	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another dimension
.018884	f0 cc		beq $018852			beq 	_CDIGetDimension
.018886	88		dey				dey
.018887	20 5e 98	jsr $01985e			jsr 	CheckNextRParen 			; closing ) present ?
.01888a	ae b9 03	ldx $03b9			ldx 	UsrArrayIdx 				; copy USR array to default
.01888d	a9 ff		lda #$ff			lda 	#$FF 						; put end marker in ArrayDef
.01888f	9d aa 03	sta $03aa,x			sta 	ArrayDef+1,x
.018892					_CDICopy:
.018892	bd b1 03	lda $03b1,x			lda 	UsrArrayDef,x
.018895	9d a9 03	sta $03a9,x			sta 	ArrayDef,x
.018898	ca		dex				dex
.018899	10 f7		bpl $018892			bpl 	_CDICopy
.01889b	68		pla				pla									; position of array identifier
.01889c	85 10		sta $10				sta 	zTemp1
.01889e	98		tya				tya
.01889f	48		pha				pha
.0188a0	a5 10		lda $10				lda 	zTemp1 						; point to identifier
.0188a2	a8		tay				tay
.0188a3	20 6a 99	jsr $01996a			jsr 	VariableExtract 			; get the identifier
.0188a6	20 03 9c	jsr $019c03			jsr 	VariableLocate 				; check if it exists already.
.0188a9	b0 0e		bcs $0188b9			bcs 	_CDIError
.0188ab	20 f6 99	jsr $0199f6			jsr 	VariableCreate 				; create it using the current ArrayDef
.0188ae	68		pla				pla 								; restore code position
.0188af	a8		tay				tay
.0188b0	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0188b2	c8		iny				iny
.0188b3	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another DIM
.0188b5	f0 88		beq $01883f			beq 	Command_DIM
.0188b7	88		dey				dey
.0188b8	60		rts				rts
.0188b9					_CDIError:
.0188b9	20 79 85	jsr $018579			jsr ERR_Handler
>0188bc	42 61 64 20 44 49 4d 00			.text "Bad DIM",0
.0188c4					_CDISyntax:
.0188c4	4c 4a 85	jmp $01854a			jmp 	SyntaxError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/wait.asm

.0188c7					Command_WAIT:
.0188c7	20 1a 92	jsr $01921a			jsr		EvaluateInteger 			; address
.0188ca	a2 06		ldx #$06			ldx 	#XS_Size 					; and mask.
.0188cc	20 66 98	jsr $019866			jsr 	CheckNextComma
.0188cf	20 1c 92	jsr $01921c			jsr 	EvaluateIntegerX
.0188d2	a9 00		lda #$00			lda 	#0							; set default xor.
.0188d4	85 8c		sta $8c				sta 	XS_Mantissa+XS_Size*2
.0188d6	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0188d8	c9 bf		cmp #$bf			cmp 	#token_Comma 				; no use the default
.0188da	d0 06		bne $0188e2			bne 	_CWAXorDefault
.0188dc	c8		iny				iny
.0188dd	a2 0c		ldx #$0c			ldx 	#XS_Size*2
.0188df	20 1c 92	jsr $01921c			jsr 	EvaluateIntegerX
.0188e2					_CWAXorDefault:
.0188e2	a5 80		lda $80				lda 	XS_Mantissa 				; copy 24 bits of mantissa to ZLTemp1
.0188e4	85 1a		sta $1a				sta 	zLTemp1
.0188e6	a5 81		lda $81				lda 	XS_Mantissa+1
.0188e8	85 1b		sta $1b				sta 	zLTemp1+1
.0188ea	a5 82		lda $82				lda 	XS_Mantissa+2
.0188ec	85 1c		sta $1c				sta 	zLTemp1+2
.0188ee					_CWAWaitLoop:
.0188ee	20 40 85	jsr $018540			jsr 	VIOCheckBreak 				; exit on break.
.0188f1	c9 00		cmp #$00			cmp 	#0
.0188f3	d0 0f		bne $018904			bne 	_CWAWaitExit
.0188f5	a9 01		lda #$01			lda 	#1							; read 1 byte to mantissa/0
.0188f7	a2 00		ldx #$00			ldx 	#0
.0188f9	5a		phy				phy 								; this is the same routine as PEEK.
.0188fa	20 e0 97	jsr $0197e0			jsr 	MemRead
.0188fd	7a		ply				ply
.0188fe	25 86		and $86				and 	XS_Mantissa+XS_Size 		; process it
.018900	45 8c		eor $8c				eor 	XS_Mantissa+XS_Size*2
.018902	f0 ea		beq $0188ee			beq 	_CWAWaitLoop
.018904					_CWAWaitExit:
.018904	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/run.asm

.018905					Command_RUN:
.018905	20 16 90	jsr $019016			jsr 	ResetRunStatus 				; clear, reset stacks etc.
.018908	a9 00		lda #$00			lda 	#BasicProgram & $FF
.01890a	85 16		sta $16				sta 	zCodePtr+0
.01890c	a9 10		lda #$10			lda 	#BasicProgram >> 8
.01890e	85 17		sta $17				sta 	zCodePtr+1
.018910	a9 00		lda #$00			lda 	#0
.018912	85 18		sta $18				sta 	zCodePtr+2
.018914	85 19		sta $19				sta 	zCodePtr+3
.018916	a0 03		ldy #$03			ldy 	#3
.018918					RUN_NewLine:
.018918	a0 00		ldy #$00			ldy 	#0
.01891a	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01891c	c8		iny				iny
.01891d	c8		iny				iny
.01891e	c8		iny				iny
.01891f	c9 00		cmp #$00			cmp 	#0 							; if the offset is zero then END.
.018921	d0 16		bne $018939			bne 	RUN_NextCommand
.018923	4c c3 8b	jmp $018bc3			jmp 	Command_END 				; go do the command code.
.018926					RUN_Skip:
.018926	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018928	c8		iny				iny 								; skip
.018929	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.01892b	90 0c		bcc $018939			bcc 	_SEDone 					; so just skip over it.
.01892d	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.01892f	90 07		bcc $018938			bcc 	_SEDouble
.018931	98		tya				tya 								; this is Y + 1
.018932	18		clc				clc
.018933	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018935	a8		tay				tay 								; back in Y.
.018936	88		dey				dey 								; fix up, one for the +1, one for the iny
.018937	88		dey				dey
.018938					_SEDouble:
.018938	c8		iny				iny
.018939					_SEDone:
.018939					RUN_NextCommand:
.018939	ad a8 03	lda $03a8			lda 	BreakCount 					; break counter
.01893c	69 10		adc #$10			adc 	#16 						; one time in 16
.01893e	8d a8 03	sta $03a8			sta 	BreakCount
.018941	90 0a		bcc $01894d			bcc 	RUN_NoCheckBreak
.018943	20 40 85	jsr $018540			jsr 	VIOCheckBreak 				; check for break
.018946	c9 00		cmp #$00			cmp 	#0
.018948	f0 03		beq $01894d			beq 	RUN_NoCheckBreak
.01894a	4c 2d 90	jmp $01902d			jmp 	Command_STOP 				; stop on BREAK.
.01894d					RUN_NoCheckBreak:
.01894d	a9 00		lda #$00			lda 	#0 							; this resets temporary string allocation.
.01894f	85 21		sta $21				sta 	zTempStr+1 					; (initialised when first called)
.018951	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018953	c9 c0		cmp #$c0			cmp 	#token_Colon 				; skip over colons
.018955	f0 cf		beq $018926			beq 	RUN_Skip
.018957	c9 00		cmp #$00			cmp 	#0 							; if non-zero execute whatever
.018959	d0 0f		bne $01896a			bne 	RUN_Execute
.01895b					RUN_NextLine:
.01895b	a0 00		ldy #$00			ldy 	#0 							; point to offset
.01895d	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.01895f	18		clc				clc
.018960	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018962	85 16		sta $16				sta 	zCodePtr
.018964	90 02		bcc $018968			bcc 	_SNLNoCarry
.018966	e6 17		inc $17				inc 	zCodePtr+1
.018968					_SNLNoCarry:
.018968	80 ae		bra $018918			bra 	RUN_NewLine 				; go do the new line code
.01896a					RUN_Execute:
.01896a	c9 f8		cmp #$f8			cmp 	#$F8 						; handle shifts, REM etc.
.01896c	b0 1e		bcs $01898c			bcs 	RUN_Extension
.01896e	c8		iny				iny
.01896f	0a		asl a				asl 	a 							; double the character read.
.018970	90 14		bcc $018986			bcc 	RUN_Default 				; if carry clear was $00-$7F, so try LET.
.018972	aa		tax				tax 								; ready to look up.
.018973	bf dd 85 01	lda $0185dd,x			lda 	VectorTable,x 				; copy address into LocalVector
.018977	8d 11 03	sta $0311			sta 	LocalVector+1
.01897a	bf de 85 01	lda $0185de,x			lda 	VectorTable+1,x
.01897e	8d 12 03	sta $0312			sta 	LocalVector+2
.018981	20 67 91	jsr $019167			jsr 	EVCallLocalVector 			; execute the appropriate code.
.018984	80 b3		bra $018939			bra 	RUN_NextCommand 			; do the next command.
.018986					RUN_Default:
.018986	88		dey				dey
.018987	20 88 8b	jsr $018b88			jsr 	Command_LET 				; and try LET.
.01898a	80 ad		bra $018939			bra 	RUN_NextCommand
.01898c					RUN_Extension:
.01898c	c9 ff		cmp #$ff			cmp 	#$FF 						; if $FF (REM)
.01898e	f0 96		beq $018926			beq 	RUN_Skip 					; skip over it.
.018990	4c 4a 85	jmp $01854a			jmp 	SyntaxError
.018993					Command_COLON:
.018993	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/for.asm

.018994					Command_FOR:
.018994	20 88 8b	jsr $018b88			jsr 	Command_LET 				; do the A = 99 bit
.018997	a5 24		lda $24				lda 	zVarType 					; obviously has to be integer/real.
.018999	c9 b7		cmp #$b7			cmp 	#token_Dollar
.01899b	f0 71		beq $018a0e			beq 	_CFOError
.01899d	48		pha				pha 								; save the variable type.
.01899e	5a		phy				phy 								; save type/variable address.
.01899f	a0 01		ldy #$01			ldy 	#1							; type at + 1
.0189a1	91 26		sta ($26),y			sta 	(zBasicSP),y
.0189a3	c8		iny				iny
.0189a4	a5 22		lda $22				lda 	zVarDataPtr 				; data low at +2
.0189a6	91 26		sta ($26),y			sta 	(zBasicSP),y
.0189a8	c8		iny				iny
.0189a9	a5 23		lda $23				lda 	zVarDataPtr+1 				; data high at +3
.0189ab	91 26		sta ($26),y			sta 	(zBasicSP),y
.0189ad	7a		ply				ply
.0189ae	a9 53		lda #$53			lda 	#(SMark_For << 4) + 3
.0189b0	20 b2 84	jsr $0184b2			jsr 	StackPushFrame 				; push on the stack with FOR marker.
.0189b3	a9 c8		lda #$c8			lda 	#token_TO
.0189b5	20 47 98	jsr $019847			jsr 	CheckNextToken
.0189b8	a2 00		ldx #$00			ldx 	#0 							; put in Mantissa, bottom
.0189ba	20 84 90	jsr $019084			jsr 	EvaluateExpression
.0189bd	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0189bf	a2 06		ldx #$06			ldx 	#XS_Size 					; X to second level
.0189c1	c9 c9		cmp #$c9			cmp 	#token_STEP
.0189c3	d0 06		bne $0189cb			bne 	_CFOStep1
.0189c5	c8		iny				iny
.0189c6	20 86 90	jsr $019086			jsr 	EvaluateExpressionX 		; get STEP value.
.0189c9	80 0e		bra $0189d9			bra 	_CFOHaveStep
.0189cb					_CFOStep1:
.0189cb	a9 00		lda #$00			lda 	#0							; set step to integer 1.
.0189cd	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0189cf	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0189d1	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0189d3	a9 01		lda #$01			lda 	#1
.0189d5	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0189d7	95 85		sta $85,x			sta 	XS_Type,x
.0189d9					_CFOHaveStep:
.0189d9	68		pla				pla 								; restore variable type
.0189da	a2 00		ldx #$00			ldx 	#0
.0189dc	c9 bb		cmp #$bb			cmp 	#token_Percent 				; do conversion to type
.0189de	f0 0a		beq $0189ea			beq 	_CFOInteger
.0189e0	20 0e a2	jsr $01a20e			jsr 	FPUToFloat
.0189e3	a2 06		ldx #$06			ldx 	#6
.0189e5	20 0e a2	jsr $01a20e			jsr 	FPUToFloat
.0189e8	80 08		bra $0189f2			bra 	_CFOEndConv
.0189ea					_CFOInteger:
.0189ea	20 5a a2	jsr $01a25a			jsr 	FPUToInteger
.0189ed	a2 06		ldx #$06			ldx 	#6
.0189ef	20 5a a2	jsr $01a25a			jsr 	FPUToInteger
.0189f2					_CFOEndConv:
.0189f2	20 f9 84	jsr $0184f9			jsr 	StackSavePosition 			; save the loop position at 1-5
.0189f5	a9 55		lda #$55			lda 	#(SMark_For << 4)+SourcePosSize
.0189f7	20 b2 84	jsr $0184b2			jsr 	StackPushFrame 				; push the loop address frame.
.0189fa	5a		phy				phy
.0189fb	a0 00		ldy #$00			ldy 	#0
.0189fd					_CFOCopy:
.0189fd	b9 80 00	lda $0080,y			lda 	XS_Mantissa+0,y
.018a00	c8		iny				iny
.018a01	91 26		sta ($26),y			sta 	(zBasicSP),y
.018a03	c0 0c		cpy #$0c			cpy 	#XS_Size*2
.018a05	d0 f6		bne $0189fd			bne 	_CFOCopy
.018a07	7a		ply				ply
.018a08	a9 5c		lda #$5c			lda 	#(SMark_For << 4)+(XS_Size*2)
.018a0a	20 b2 84	jsr $0184b2			jsr 	StackPushFrame
.018a0d	60		rts				rts
.018a0e					_CFOError:
.018a0e	4c 5a 85	jmp $01855a			jmp 	TypeError 					; wrong type.
.018a11					Command_NEXT:
.018a11	a9 00		lda #$00			lda 	#0 							; set variable data pointer+1 to zero
.018a13	85 23		sta $23				sta 	zVarDataPtr+1 				; this means we don't check
.018a15	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018a17	c9 00		cmp #$00			cmp 	#0 							; EOL
.018a19	f0 07		beq $018a22			beq 	_CNextNoVariable
.018a1b	c9 40		cmp #$40			cmp 	#$40
.018a1d	b0 03		bcs $018a22			bcs 	_CNextNoVariable
.018a1f	20 ff 98	jsr $0198ff			jsr 	VariableFind
.018a22					_CNextNoVariable:
.018a22	a5 26		lda $26				lda 	zBasicSP 					; save on stack
.018a24	48		pha				pha
.018a25	a5 27		lda $27				lda 	zBasicSP+1
.018a27	48		pha				pha
.018a28	a9 50		lda #$50			lda 	#(SMark_For << 4) 			; pop loop address frame
.018a2a	20 c9 84	jsr $0184c9			jsr 	StackPopFrame
.018a2d	a9 50		lda #$50			lda 	#(SMark_For << 4) 			; pop STEP/TARGET frame.
.018a2f	20 c9 84	jsr $0184c9			jsr 	StackPopFrame
.018a32	a9 50		lda #$50			lda 	#(Smark_For << 4) 			; pop variable address frame.
.018a34	20 c9 84	jsr $0184c9			jsr 	StackPopFrame
.018a37	a5 23		lda $23				lda 	zVarDataPtr+1 				; if zero, then no variable provided
.018a39	f0 11		beq $018a4c			beq 	_CNextGetTarget 			; e.g. just NEXT not NEXT x
.018a3b	5a		phy				phy 								; check addresses match.
.018a3c	a0 02		ldy #$02			ldy 	#2
.018a3e	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a40	c5 22		cmp $22				cmp 	zVarDataPtr
.018a42	d0 69		bne $018aad			bne 	_CNextWrong
.018a44	c8		iny				iny
.018a45	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a47	c5 23		cmp $23				cmp 	zVarDataPtr+1
.018a49	d0 62		bne $018aad			bne 	_CNextWrong
.018a4b	7a		ply				ply
.018a4c					_CNextGetTarget:
.018a4c	5a		phy				phy
.018a4d	a0 01		ldy #$01			ldy 	#1 							; restore variable type and data.
.018a4f	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a51	85 24		sta $24				sta 	zVarType
.018a53	c8		iny				iny
.018a54	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a56	85 22		sta $22				sta 	zVarDataPtr
.018a58	c8		iny				iny
.018a59	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a5b	85 23		sta $23				sta 	zVarDataPtr+1
.018a5d	a2 0c		ldx #$0c			ldx 	#12
.018a5f	20 47 9c	jsr $019c47			jsr 	VariableGet 				; get that variable value into expr[2]
.018a62	a2 00		ldx #$00			ldx 	#0 							; copy stacked Target/Step into expr[0] and [1]
.018a64	a0 0b		ldy #$0b			ldy 	#11
.018a66					_CNXCopy:
.018a66	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a68	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018a6a	e8		inx				inx
.018a6b	c8		iny				iny
.018a6c	e0 0c		cpx #$0c			cpx 	#XS_Size*2
.018a6e	d0 f6		bne $018a66			bne 	_CNXCopy
.018a70	7a		ply				ply
.018a71	a2 06		ldx #$06			ldx 	#6 							; point at expr[1] s
.018a73	20 8c 94	jsr $01948c			jsr 	GetSignCurrent
.018a76	8d a7 03	sta $03a7			sta 	SignNext 					; save in temporary.
.018a79	a2 06		ldx #$06			ldx 	#6 							; add them, however
.018a7b	20 6b 93	jsr $01936b			jsr 	BinaryOp_Add
.018a7e	20 98 9c	jsr $019c98			jsr 	VariableSet					; and write variable back.
.018a81	a2 00		ldx #$00			ldx 	#0
.018a83	20 ef 92	jsr $0192ef			jsr 	CompareValues
.018a86	09 00		ora #$00			ora 	#0
.018a88	f0 05		beq $018a8f			beq 	_CNXAgain 					; if true, then do it again.
.018a8a	cd a7 03	cmp $03a7			cmp 	SignNext 					; if sign different, then loop has finished.
.018a8d	d0 0f		bne $018a9e			bne 	_CNXLoopDone
.018a8f					_CNXAgain:
.018a8f	a9 53		lda #$53			lda 	#(SMark_For << 4) + 3		; re-stack variable address
.018a91	20 b2 84	jsr $0184b2			jsr 	StackPushFrame
.018a94	20 16 85	jsr $018516			jsr 	StackRestorePosition 		; get restore position back, e.g. loop round.
.018a97	68		pla				pla
.018a98	85 27		sta $27				sta 	zBasicSP+1
.018a9a	68		pla				pla
.018a9b	85 26		sta $26				sta 	zBasicSP
.018a9d					_CNXExit:
.018a9d	60		rts				rts
.018a9e					_CNXLoopDone:
.018a9e	68		pla				pla
.018a9f	68		pla				pla
.018aa0	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018aa2	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma ?
.018aa4	d0 f7		bne $018a9d			bne 	_CNXExit
.018aa6	c8		iny				iny
.018aa7	20 ff 98	jsr $0198ff			jsr 	VariableFind 				; identify the variable
.018aaa	4c 22 8a	jmp $018a22			jmp 	_CNextNoVariable 			; go back with variable pre-found
.018aad					_CNextWrong:
.018aad	20 79 85	jsr $018579			jsr ERR_Handler
>018ab0	57 72 6f 6e 67 20 4e 65			.text "Wrong Next Variable",0
>018ab8	78 74 20 56 61 72 69 61 62 6c 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/read.asm

.018ac4					Command_READ:
.018ac4	20 ff 98	jsr $0198ff			jsr 	VariableFind 				; get variable/value into zVarDataPtr,zVarType
.018ac7	a5 22		lda $22				lda 	zVarDataPtr 				; save variable info on stack
.018ac9	48		pha				pha
.018aca	a5 23		lda $23				lda 	zVarDataPtr+1
.018acc	48		pha				pha
.018acd	a5 24		lda $24				lda 	zVarType
.018acf	48		pha				pha
.018ad0	20 16 8b	jsr $018b16			jsr 	READGetDataItem 			; get the next data item
.018ad3	68		pla				pla 								; restore target variable information.
.018ad4	85 24		sta $24				sta 	zVarType
.018ad6	68		pla				pla
.018ad7	85 23		sta $23				sta 	zVarDataPtr+1
.018ad9	68		pla				pla
.018ada	85 22		sta $22				sta 	zVarDataPtr
.018adc	a2 00		ldx #$00			ldx 	#0
.018ade	20 98 9c	jsr $019c98			jsr 	VariableSet 				; set the value out.
.018ae1	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018ae3	c8		iny				iny
.018ae4	c9 bf		cmp #$bf			cmp 	#token_Comma
.018ae6	f0 dc		beq $018ac4			beq 	Command_READ 				; found, do another READ
.018ae8	88		dey				dey
.018ae9	60		rts				rts
.018aea					Command_DATA:
.018aea	4c 80 84	jmp $018480			jmp 	SkipEndOfCommand
.018aed					Command_RESTORE:
.018aed	48		pha				pha
.018aee	a9 00		lda #$00			lda 	#0 							; this being zero means 'initialise next read'
.018af0	8d bd 03	sta $03bd			sta 	DataLPtr+0
.018af3	8d be 03	sta $03be			sta 	DataLPtr+1
.018af6	68		pla				pla
.018af7	60		rts				rts
.018af8					READSwapPointers:
.018af8	98		tya				tya
.018af9	48		pha				pha 								; save it
.018afa	ad c1 03	lda $03c1			lda 	DataIndex 					; get data offset, and copy to offset
.018afd	a8		tay				tay
.018afe	68		pla				pla 								; get code offset and save in DataIndex
.018aff	8d c1 03	sta $03c1			sta 	DataIndex
.018b02	da		phx				phx
.018b03	a2 03		ldx #$03			ldx 	#3 							; swap the Data Pointers (4 bytes) round.
.018b05					_RSWLoop:
.018b05	bd bd 03	lda $03bd,x			lda 	DataLPtr+0,x
.018b08	48		pha				pha
.018b09	b5 16		lda $16,x			lda 	zCodePtr+0,x
.018b0b	9d bd 03	sta $03bd,x			sta 	DataLPtr+0,x
.018b0e	68		pla				pla
.018b0f	95 16		sta $16,x			sta 	zCodePtr+0,x
.018b11	ca		dex				dex
.018b12	10 f1		bpl $018b05			bpl 	_RSWLoop
.018b14	fa		plx				plx
.018b15	60		rts				rts
.018b16					READGetDataItem:
.018b16	20 f8 8a	jsr $018af8			jsr 	ReadSwapPointers 			; swap code and data pointer.
.018b19	a5 16		lda $16				lda		zCodePtr+0 					; initialise ?
.018b1b	05 17		ora $17				ora 	zCodePtr+1
.018b1d	d0 12		bne $018b31			bne 	_RGDIIsInitialised
.018b1f	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018b21	85 16		sta $16				sta 	zCodePtr+0
.018b23	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018b25	85 17		sta $17				sta 	zCodePtr+1
.018b27	a9 00		lda #$00			lda 	#0
.018b29	85 18		sta $18				sta 	zCodePtr+2
.018b2b	85 19		sta $19				sta 	zCodePtr+3
.018b2d	a0 03		ldy #$03			ldy 	#3
.018b2f	80 06		bra $018b37			bra 	_RGDIFindData 				; locate next data from start and read that.
.018b31					_RGDIIsInitialised:
.018b31	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018b33	c9 bf		cmp #$bf			cmp 	#token_Comma
.018b35	f0 49		beq $018b80			beq 	_RGDISkipEvaluateExit
.018b37					_RGDIFindData:
.018b37	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018b39	c9 00		cmp #$00			cmp 	#0 							; end of line
.018b3b	f0 19		beq $018b56			beq 	_RGDIFindNextLine
.018b3d	c9 c5		cmp #$c5			cmp 	#token_DATA 				; found data token
.018b3f	f0 3f		beq $018b80			beq 	_RGDISkipEvaluateExit 		; then skip it and evaluate
.018b41	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018b43	c8		iny				iny 								; skip
.018b44	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018b46	90 0c		bcc $018b54			bcc 	_SEDone 					; so just skip over it.
.018b48	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018b4a	90 07		bcc $018b53			bcc 	_SEDouble
.018b4c	98		tya				tya 								; this is Y + 1
.018b4d	18		clc				clc
.018b4e	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018b50	a8		tay				tay 								; back in Y.
.018b51	88		dey				dey 								; fix up, one for the +1, one for the iny
.018b52	88		dey				dey
.018b53					_SEDouble:
.018b53	c8		iny				iny
.018b54					_SEDone:
.018b54	80 e1		bra $018b37			bra 	_RGDIFindData
.018b56					_RGDIFindNextLine:
.018b56	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018b58	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.018b5a	18		clc				clc
.018b5b	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018b5d	85 16		sta $16				sta 	zCodePtr
.018b5f	90 02		bcc $018b63			bcc 	_SNLNoCarry
.018b61	e6 17		inc $17				inc 	zCodePtr+1
.018b63					_SNLNoCarry:
.018b63	a0 00		ldy #$00			ldy 	#0
.018b65	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018b67	48		pha				pha
.018b68	c8		iny				iny
.018b69	c8		iny				iny
.018b6a	c8		iny				iny
.018b6b	68		pla				pla
.018b6c	d0 c9		bne $018b37			bne 	_RGDIFindData 				; back to scanning.
.018b6e	20 f8 8a	jsr $018af8			jsr 	ReadSwapPointers 			; so we get error in line number of READ
.018b71	20 79 85	jsr $018579			jsr ERR_Handler
>018b74	4f 75 74 20 6f 66 20 44			.text "Out of Data",0
>018b7c	61 74 61 00
.018b80					_RGDISkipEvaluateExit:
.018b80	c8		iny				iny
.018b81	20 84 90	jsr $019084			jsr 	EvaluateExpression 			; evaluate the expression
.018b84	20 f8 8a	jsr $018af8			jsr 	ReadSwapPointers 			; swap the pointers around.
.018b87	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/let.asm

.018b88					Command_LET:
.018b88	20 ff 98	jsr $0198ff			jsr 	VariableFind 				; get reference to one variable.
.018b8b	a9 84		lda #$84			lda 	#token_Equal  				; get equals
.018b8d	20 47 98	jsr $019847			jsr 	CheckNextToken
.018b90	a5 22		lda $22				lda 	zVarDataPtr 				; save variable info on stack
.018b92	48		pha				pha
.018b93	a5 23		lda $23				lda 	zVarDataPtr+1
.018b95	48		pha				pha
.018b96	a5 24		lda $24				lda 	zVarType
.018b98	48		pha				pha
.018b99	20 84 90	jsr $019084			jsr 	EvaluateExpression 			; evaluate the RHS, set X to zero.
.018b9c	68		pla				pla 								; restore target variable information.
.018b9d	85 24		sta $24				sta 	zVarType
.018b9f	68		pla				pla
.018ba0	85 23		sta $23				sta 	zVarDataPtr+1
.018ba2	68		pla				pla
.018ba3	85 22		sta $22				sta 	zVarDataPtr
.018ba5	20 98 9c	jsr $019c98			jsr 	VariableSet 				; set the value out.
.018ba8	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/sys.asm

.018ba9					Command_SYS:
.018ba9	20 1a 92	jsr $01921a			jsr 	EvaluateInteger 			; address
.018bac	a5 80		lda $80				lda 	XS_Mantissa+0				; copy to localvector
.018bae	8d 10 03	sta $0310			sta 	LocalVector+0 				; only three, can only do 24 bit calls
.018bb1	a5 81		lda $81				lda 	XS_Mantissa+1 				; and that only on 65816
.018bb3	8d 11 03	sta $0311			sta 	LocalVector+1
.018bb6	a5 82		lda $82				lda 	XS_Mantissa+2
.018bb8	8d 12 03	sta $0312			sta 	LocalVector+2
.018bbb	22 c0 8b 01	jsl $018bc0			jsl 	_CSYLocalCall
.018bbf	60		rts				rts
.018bc0					_CSYLocalCall:
.018bc0	dc 10 03	jmp [$0310]			jmp 	[LocalVector]

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/end.asm

.018bc3					Command_END:
>018bc3	02						.byte 	2
.018bc4	4c 32 88	jmp $018832			jmp 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/if.asm

.018bc7					Command_IF:
.018bc7	20 1a 92	jsr $01921a			jsr 	EvaluateInteger 			; check success.
.018bca	a5 80		lda $80				lda 	XS_Mantissa+0				; check the result if zero
.018bcc	05 81		ora $81				ora 	XS_Mantissa+1
.018bce	05 82		ora $82				ora 	XS_Mantissa+2
.018bd0	05 83		ora $83				ora 	XS_Mantissa+3
.018bd2	aa		tax				tax 								; put into X.
.018bd3	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018bd5	c9 93		cmp #$93			cmp 	#token_Then 				; then found.
.018bd7	d0 2c		bne $018c05			bne 	_FIFExtended
.018bd9	c8		iny				iny
.018bda	e0 00		cpx #$00			cpx 	#0 							; was it successful.
.018bdc	f0 0b		beq $018be9			beq 	_FIFEndOfLine 				; if not, go to the end of the line.
.018bde	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018be0	29 c0		and #$c0			and 	#$C0 						; is it a number
.018be2	c9 40		cmp #$40			cmp 	#$40
.018be4	d0 1e		bne $018c04			bne 	_FIFContinue 				; if not, do what ever follows.
.018be6	4c 54 8f	jmp $018f54			jmp		Command_GOTO 				; we have IF <expr> THEN <number> so we do GOTO code.
.018be9					_FIFEndOfLine:
.018be9	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018beb	c9 00		cmp #$00			cmp 	#0 							; if zero, end of line, so exit
.018bed	f0 15		beq $018c04			beq 	_FIFContinue
.018bef	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018bf1	c8		iny				iny 								; skip
.018bf2	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018bf4	90 0c		bcc $018c02			bcc 	_SEDone 					; so just skip over it.
.018bf6	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018bf8	90 07		bcc $018c01			bcc 	_SEDouble
.018bfa	98		tya				tya 								; this is Y + 1
.018bfb	18		clc				clc
.018bfc	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018bfe	a8		tay				tay 								; back in Y.
.018bff	88		dey				dey 								; fix up, one for the +1, one for the iny
.018c00	88		dey				dey
.018c01					_SEDouble:
.018c01	c8		iny				iny
.018c02					_SEDone:
.018c02	80 e5		bra $018be9			bra 	_FIFEndOfLine
.018c04					_FIFContinue:
.018c04	60		rts				rts
.018c05					_FIFExtended:
.018c05	da		phx				phx 								; save result
.018c06	a9 40		lda #$40			lda 	#(SMark_If << 4) 			; push marker on the stack, nothing else.
.018c08	20 b2 84	jsr $0184b2			jsr 	StackPushFrame
.018c0b	68		pla				pla 								; restore result
.018c0c	f0 01		beq $018c0f			beq 	_FIXSkip 					; if zero then it has failed.
.018c0e	60		rts				rts 								; test passed, so continue executing
.018c0f					_FIXSkip:
.018c0f	a9 94		lda #$94			lda 	#token_endif 				; scan forward till found either ELSE or ENDIF
.018c11	a2 de		ldx #$de			ldx 	#token_else 				; at the same level.
.018c13	20 f5 83	jsr $0183f5			jsr 	StructureSearchDouble
.018c16	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c18	c8		iny				iny
.018c19	c9 94		cmp #$94			cmp 	#token_endif 				; if endif, handle endif code.
.018c1b	f0 07		beq $018c24			beq 	Command_ENDIF
.018c1d	60		rts				rts
.018c1e					Command_ELSE:
.018c1e	a9 94		lda #$94			lda 	#token_endif 				; scan forward till found ENDIF
.018c20	20 f3 83	jsr $0183f3			jsr 	StructureSearchSingle 		; then do the ENDIF pop.
.018c23	c8		iny				iny
.018c24					Command_ENDIF:
.018c24	a9 40		lda #$40			lda 	#(SMark_If << 4)
.018c26	20 c9 84	jsr $0184c9			jsr 	StackPopFrame
.018c29	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/list.asm

.018c2a					Command_LIST:
.018c2a	20 b7 8d	jsr $018db7			jsr 	ListGetRange				; get any parameters
.018c2d	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018c2f	85 16		sta $16				sta 	zCodePtr+0
.018c31	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018c33	85 17		sta $17				sta 	zCodePtr+1
.018c35	a9 00		lda #$00			lda 	#0
.018c37	85 18		sta $18				sta 	zCodePtr+2
.018c39	85 19		sta $19				sta 	zCodePtr+3
.018c3b	a0 03		ldy #$03			ldy 	#3
.018c3d	a9 00		lda #$00			lda 	#0 							; reset the indent & last indent
.018c3f	8d bc 03	sta $03bc			sta 	LastListIndent
.018c42	8d bb 03	sta $03bb			sta 	ListIndent
.018c45					_CILLoop:
.018c45	a0 00		ldy #$00			ldy 	#0
.018c47	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c49	c9 00		cmp #$00			cmp 	#0 							; if zero, end of program
.018c4b	f0 23		beq $018c70			beq 	_CILExit
.018c4d	20 40 85	jsr $018540			jsr 	VIOCheckBreak 				; check break
.018c50	c9 00		cmp #$00			cmp 	#0
.018c52	d0 1c		bne $018c70			bne 	_CILExit
.018c54	20 fe 8d	jsr $018dfe			jsr 	ListCheckRange 				; check current line in range.
.018c57	b0 08		bcs $018c61			bcs		_CILNext
.018c59	a0 00		ldy #$00			ldy 	#0
.018c5b	c8		iny				iny
.018c5c	c8		iny				iny
.018c5d	c8		iny				iny
.018c5e	20 73 8c	jsr $018c73			jsr 	ListLine 					; list one line.
.018c61					_CILNext:
.018c61	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018c63	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.018c65	18		clc				clc
.018c66	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018c68	85 16		sta $16				sta 	zCodePtr
.018c6a	90 02		bcc $018c6e			bcc 	_SNLNoCarry
.018c6c	e6 17		inc $17				inc 	zCodePtr+1
.018c6e					_SNLNoCarry:
.018c6e	80 d5		bra $018c45			bra 	_CILLoop
.018c70					_CILExit:
.018c70	4c 32 88	jmp $018832			jmp 	WarmStart
.018c73					ListLine:
.018c73	ad bb 03	lda $03bb			lda 	ListIndent 					; copy current list indent -> last
.018c76	8d bc 03	sta $03bc			sta 	LastListIndent
.018c79					_LICountIndent:
.018c79	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c7b	c9 00		cmp #$00			cmp 	#0
.018c7d	f0 2f		beq $018cae			beq 	_LIDoneIndent
.018c7f	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus
.018c81	90 16		bcc $018c99			bcc 	_LICINext
.018c83	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.018c85	b0 12		bcs $018c99			bcs 	_LICINext
.018c87	ee bb 03	inc $03bb			inc 	ListIndent
.018c8a	c9 93		cmp #$93			cmp 	#firstKeywordMinus
.018c8c	90 0b		bcc $018c99			bcc 	_LICINext
.018c8e	ce bb 03	dec $03bb			dec 	ListIndent
.018c91	ce bb 03	dec $03bb			dec 	ListIndent
.018c94	10 03		bpl $018c99			bpl 	_LICINext
.018c96	ee bb 03	inc $03bb			inc 	ListIndent
.018c99					_LICINext:
.018c99	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018c9b	c8		iny				iny 								; skip
.018c9c	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018c9e	90 0c		bcc $018cac			bcc 	_SEDone 					; so just skip over it.
.018ca0	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018ca2	90 07		bcc $018cab			bcc 	_SEDouble
.018ca4	98		tya				tya 								; this is Y + 1
.018ca5	18		clc				clc
.018ca6	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018ca8	a8		tay				tay 								; back in Y.
.018ca9	88		dey				dey 								; fix up, one for the +1, one for the iny
.018caa	88		dey				dey
.018cab					_SEDouble:
.018cab	c8		iny				iny
.018cac					_SEDone:
.018cac	80 cb		bra $018c79			bra 	_LICountIndent
.018cae					_LIDoneIndent:
.018cae	a0 00		ldy #$00			ldy 	#0
.018cb0	c8		iny				iny
.018cb1	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018cb3	85 80		sta $80				sta 	XS_Mantissa
.018cb5	c8		iny				iny
.018cb6	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018cb8	85 81		sta $81				sta 	XS_Mantissa+1
.018cba	20 bf 85	jsr $0185bf			jsr 	Print16BitInteger 			; print integer.
.018cbd	85 10		sta $10				sta 	zTemp1 						; save spaces printed.
.018cbf	ad bb 03	lda $03bb			lda 	ListIndent 					; smaller of current/prev indent
.018cc2	cd bc 03	cmp $03bc			cmp 	LastListIndent
.018cc5	90 03		bcc $018cca			bcc 	_LISmaller
.018cc7	ad bc 03	lda $03bc			lda 	LastListIndent
.018cca					_LISmaller:
.018cca	0a		asl a				asl 	a 							; double indent
.018ccb	49 ff		eor #$ff			eor 	#$FF 						; 2's complement arithmetic
.018ccd	38		sec				sec
.018cce	65 10		adc $10				adc 	zTemp1 						; "subtract" indent e.g. print more.
.018cd0	aa		tax				tax 								; print spaces to column 6
.018cd1					_LISpace:
.018cd1	a9 20		lda #$20			lda 	#" "
.018cd3	20 a7 8d	jsr $018da7			jsr 	ListPrintLC
.018cd6	e8		inx				inx
.018cd7	e0 06		cpx #$06			cpx 	#6
.018cd9	d0 f6		bne $018cd1			bne 	_LISpace
.018cdb					_LIDecode:
.018cdb	c8		iny				iny
.018cdc	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018cde	c9 00		cmp #$00			cmp 	#0 							; zero, exit.
.018ce0	f0 0f		beq $018cf1			beq 	_LIExit
.018ce2	30 12		bmi $018cf6			bmi 	_LIToken
.018ce4	c9 40		cmp #$40			cmp 	#$40 						; 01-$3F, character.
.018ce6	b0 50		bcs $018d38			bcs 	_LIInteger
.018ce8	49 20		eor #$20			eor 	#$20 						; make 7 bit
.018cea	69 20		adc #$20			adc 	#$20
.018cec	20 a7 8d	jsr $018da7			jsr 	ListPrintLC 				; print in LC
.018cef	80 ea		bra $018cdb			bra 	_LIDecode
.018cf1					_LIExit:
.018cf1	a9 0d		lda #$0d			lda 	#13 						; print new line.
.018cf3	4c a7 8d	jmp $018da7			jmp 	ListPrintLC
.018cf6					_LIToken:
.018cf6	c9 fc		cmp #$fc			cmp 	#$FC 						; $FC-$FF ?
.018cf8	90 49		bcc $018d43			bcc		_LICommandToken
.018cfa	48		pha				pha 								; save in case end
.018cfb	a2 22		ldx #$22			ldx 	#'"'						; print if $FE quoted string
.018cfd	c9 fe		cmp #$fe			cmp 	#$FE
.018cff	f0 17		beq $018d18			beq 	_LIPrint
.018d01	a2 2e		ldx #$2e			ldx 	#'.'						; print if $FD decimals
.018d03	c9 fd		cmp #$fd			cmp 	#$FD
.018d05	f0 11		beq $018d18			beq 	_LIPrint
.018d07	a9 52		lda #$52			lda 	#'R'						; must be REM
.018d09	20 a7 8d	jsr $018da7			jsr 	ListPrintLC
.018d0c	a9 45		lda #$45			lda 	#'E'
.018d0e	20 a7 8d	jsr $018da7			jsr 	ListPrintLC
.018d11	a9 4d		lda #$4d			lda 	#'M'
.018d13	20 a7 8d	jsr $018da7			jsr 	ListPrintLC
.018d16	a2 20		ldx #$20			ldx 	#' '
.018d18					_LIPrint:
.018d18	8a		txa				txa
.018d19	20 a7 8d	jsr $018da7			jsr 	ListPrintLC
.018d1c	c8		iny				iny
.018d1d	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018d1f	aa		tax				tax 								; put in X
.018d20	ca		dex				dex
.018d21					_LILoop:
.018d21	ca		dex				dex 								; exit when count reached zero.
.018d22	f0 08		beq $018d2c			beq 	_LIEnd
.018d24	c8		iny				iny
.018d25	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018d27	20 a7 8d	jsr $018da7			jsr 	ListPrintLC
.018d2a	80 f5		bra $018d21			bra 	_LILoop
.018d2c	68		pla		_LIEnd:	pla 								; get A back
.018d2d	c9 fe		cmp #$fe			cmp 	#$FE 						; if '"' need closing quotes
.018d2f	d0 aa		bne $018cdb			bne 	_LIDecode
.018d31	a9 22		lda #$22			lda 	#'"'
.018d33	20 a7 8d	jsr $018da7			jsr 	ListPrintLC
.018d36	80 a3		bra $018cdb			bra 	_LIDecode
.018d38					_LIInteger:
.018d38	a2 00		ldx #$00			ldx 	#0
.018d3a	20 8c 91	jsr $01918c			jsr 	EvaluateGetInteger 			; get an atom
.018d3d	88		dey				dey
.018d3e	20 c5 85	jsr $0185c5			jsr 	Print32BitInteger 			; print integer.
.018d41	80 98		bra $018cdb			bra 	_LIDecode
.018d43					_LICommandToken:
.018d43	5a		phy				phy 								; save Y
.018d44	48		pha				pha 								; save token
.018d45	a2 bd		ldx #$bd			ldx  	#KeywordText & $FF 			; address of keyword text table.
.018d47	a9 86		lda #$86			lda 	(#KeywordText >> 8) & $FF
.018d49	86 1a		stx $1a				stx 	zLTemp1
.018d4b	85 1b		sta $1b				sta 	zLTemp1+1
.018d4d	a9 01		lda #$01			lda 	(#KeywordText >> 16) & $FF 	; this is for 65816 (it's a table in code
.018d4f	85 1c		sta $1c				sta 	zLTemp1+2 					; space) and won't affect a 6502 at all.
.018d51	68		pla				pla 								; get token
.018d52	29 7f		and #$7f			and 	#127 						; chuck bit 7.
.018d54	f0 16		beq $018d6c			beq 	_LIFoundToken
.018d56	aa		tax				tax
.018d57					_LITokenLoop:
.018d57	a0 00		ldy #$00			ldy 	#0 							; last character not a token.
.018d59					_LIFindEnd:
.018d59	b7 1a		lda [$1a],y			lda 	[zLTemp1],y
.018d5b	c8		iny				iny
.018d5c	0a		asl a				asl 	a
.018d5d	90 fa		bcc $018d59			bcc 	_LIFindEnd
.018d5f	98		tya				tya 								; that is step to the next
.018d60	18		clc				clc 								; we don't bother bumping the 3rd byte
.018d61	65 1a		adc $1a				adc 	zLTemp1 					; here.
.018d63	85 1a		sta $1a				sta 	zLTemp1
.018d65	90 02		bcc $018d69			bcc 	_LINoBump
.018d67	e6 1b		inc $1b				inc 	zLTemp1+1
.018d69					_LINoBump:
.018d69	ca		dex				dex 								; no go round again.
.018d6a	d0 eb		bne $018d57			bne 	_LITokenLoop
.018d6c					_LIFoundToken:
.018d6c	a0 00		ldy #$00			ldy 	#0
.018d6e					_LIPrintToken:
.018d6e	b7 1a		lda [$1a],y			lda 	[zLTemp1],y
.018d70	c0 00		cpy #$00			cpy 	#0 							; see if needs prefix space
.018d72	d0 16		bne $018d8a			bne 	_LINoPrefixSpace
.018d74	c9 41		cmp #$41			cmp 	#"A" 						; e.g. alphabetic token.
.018d76	90 12		bcc $018d8a			bcc 	_LINoPrefixSpace
.018d78	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018d7a	b0 0e		bcs $018d8a			bcs 	_LINoPrefixSpace
.018d7c	ae ba 03	ldx $03ba			ldx 	LastPrinted 				; if last was space not required
.018d7f	e0 20		cpx #$20			cpx 	#" "
.018d81	f0 07		beq $018d8a			beq 	_LINoPrefixSpace
.018d83	48		pha				pha
.018d84	a9 20		lda #$20			lda 	#" "
.018d86	20 a7 8d	jsr $018da7			jsr 	ListPrintLC
.018d89	68		pla				pla
.018d8a					_LINoPrefixSpace:
.018d8a	c8		iny				iny
.018d8b	48		pha				pha 								; save it
.018d8c	29 7f		and #$7f			and 	#$7F
.018d8e	20 a7 8d	jsr $018da7			jsr 	ListPrintLC
.018d91	68		pla				pla
.018d92	10 da		bpl $018d6e			bpl 	_LIPrintToken 				; go back if not end
.018d94	7a		ply				ply 								; restore Y
.018d95	29 7f		and #$7f			and 	#$7F 						; if last char is a letter
.018d97	c9 41		cmp #$41			cmp 	#"A"
.018d99	90 09		bcc $018da4			bcc 	_LINotLetter2
.018d9b	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018d9d	b0 05		bcs $018da4			bcs 	_LINotLetter2
.018d9f	a9 20		lda #$20			lda 	#" " 						; add spacing
.018da1	20 a7 8d	jsr $018da7			jsr 	ListPrintLC
.018da4					_LINotLetter2:
.018da4	4c db 8c	jmp $018cdb			jmp 	_LIDecode
.018da7					ListPrintLC:
.018da7	8d ba 03	sta $03ba			sta 	LastPrinted
.018daa	c9 41		cmp #$41			cmp 	#"A"
.018dac	90 06		bcc $018db4			bcc 	_LPLC0
.018dae	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018db0	b0 02		bcs $018db4			bcs 	_LPLC0
.018db2	69 20		adc #$20			adc 	#$20
.018db4	4c 32 85	jmp $018532	_LPLC0:	jmp 	VIOCharPrint
.018db7					ListGetRange:
.018db7	a2 0b		ldx #$0b			ldx 	#XS_Size*2-1 				; clear first 2 slots back to defaults.
.018db9					_LGRClear:
.018db9	a9 00		lda #$00			lda 	#0
.018dbb	95 80		sta $80,x			sta 	XS_Mantissa,x
.018dbd	ca		dex				dex
.018dbe	10 f9		bpl $018db9			bpl 	_LGRClear
.018dc0	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018dc2	c9 00		cmp #$00			cmp 	#0 							; nothing
.018dc4	f0 21		beq $018de7			beq 	_LGRBlank
.018dc6	c9 c0		cmp #$c0			cmp 	#token_Colon 				; or colon
.018dc8	f0 1d		beq $018de7			beq 	_LGRBlank
.018dca	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma
.018dcc	f0 18		beq $018de6			beq 	_LGREnd 					; then it's LIST ,x
.018dce	20 1a 92	jsr $01921a			jsr 	EvaluateInteger 			; get the first number into bottom
.018dd1	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018dd3	c9 bf		cmp #$bf			cmp 	#token_Comma
.018dd5	f0 0f		beq $018de6			beq 	_LGREnd 					; then it is LIST a,b
.018dd7	a5 80		lda $80				lda 	XS_Mantissa+0 				; copy first to second LIST n is n,n
.018dd9	85 86		sta $86				sta 	XS_Mantissa+XS_Size+0
.018ddb	a5 81		lda $81				lda 	XS_Mantissa+1
.018ddd	85 87		sta $87				sta 	XS_Mantissa+XS_Size+1
.018ddf					_LGRBumpExit:
.018ddf	e6 86		inc $86				inc 	XS_Mantissa+XS_Size 		; bump it so we can use cc.
.018de1	d0 02		bne $018de5			bne 	_LGRBump2
.018de3	e6 87		inc $87				inc 	XS_Mantissa+XS_Size+1
.018de5					_LGRBump2:
.018de5	60		rts				rts
.018de6					_LGREnd:
.018de6	c8		iny				iny
.018de7					_LGRBlank:
.018de7	a9 ff		lda #$ff			lda 	#$FF 						; default to the end.
.018de9	85 86		sta $86				sta 	XS_Mantissa+XS_Size
.018deb	85 87		sta $87				sta 	XS_Mantissa+XS_Size+1
.018ded	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018def	c9 00		cmp #$00			cmp 	#0
.018df1	f0 f2		beq $018de5			beq 	_LGRBump2
.018df3	0a		asl a				asl 	a 							; if not a number, then exit (to end)
.018df4	b0 ef		bcs $018de5			bcs 	_LGRBump2
.018df6	a2 06		ldx #$06			ldx 	#XS_Size 					; get to range
.018df8	20 1c 92	jsr $01921c			jsr 	EvaluateIntegerX
.018dfb	80 e2		bra $018ddf			bra 	_LGRBumpExit
.018dfd	60		rts				rts
.018dfe					ListCheckRange:
.018dfe	c8		iny				iny
.018dff	a2 00		ldx #$00			ldx 	#0 							; test low
.018e01	20 0e 8e	jsr $018e0e			jsr 	_LCRCompare
.018e04	90 06		bcc $018e0c			bcc 	_LCRFail
.018e06	a2 06		ldx #$06			ldx 	#XS_Size 					; test high
.018e08	20 0e 8e	jsr $018e0e			jsr 	_LCRCompare
.018e0b	60		rts				rts
.018e0c					_LCRFail:
.018e0c	38		sec				sec
.018e0d	60		rts				rts
.018e0e					_LCRCompare:
.018e0e	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e10	38		sec				sec
.018e11	f5 80		sbc $80,x			sbc	 	XS_Mantissa+0,x
.018e13	08		php				php
.018e14	c8		iny				iny
.018e15	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e17	28		plp				plp
.018e18	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.018e1a	08		php				php
.018e1b	88		dey				dey
.018e1c	28		plp				plp
.018e1d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/print.asm

.018e1e					Command_PRINT:
.018e1e	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e20	c9 00		cmp #$00			cmp 	#0 							; end
.018e22	f0 24		beq $018e48			beq 	_CPR_GoNewLine
.018e24	c9 c0		cmp #$c0			cmp 	#token_Colon
.018e26	f0 20		beq $018e48			beq 	_CPR_GoNewLine
.018e28	c9 c1		cmp #$c1			cmp 	#token_SemiColon
.018e2a	f0 74		beq $018ea0			beq 	_CPR_Skip
.018e2c	c9 bf		cmp #$bf			cmp 	#token_Comma
.018e2e	f0 57		beq $018e87			beq 	_CPR_Tab
.018e30	20 84 90	jsr $019084			jsr 	EvaluateExpression 			; get expression.
.018e33	a5 85		lda $85				lda 	XS_Type 					; get type.
.018e35	29 02		and #$02			and 	#2
.018e37	d0 27		bne $018e60			bne 	_CPR_String 				; if type = 2 output as string.
.018e39					_CPR_Number:
.018e39	a9 00		lda #$00			lda 	#0 							; reset buffer index
.018e3b	8d 14 03	sta $0314			sta 	NumBufX
.018e3e	a5 85		lda $85				lda 	XS_Type 					; get type
.018e40	4a		lsr a				lsr 	a
.018e41	b0 08		bcs $018e4b			bcs 	_CPRInt 					; if msb set do as integer
.018e43	20 59 a3	jsr $01a359			jsr 	FPToString 					; call fp to str otherwise
.018e46	80 06		bra $018e4e			bra 	_CPRNPrint
.018e48					_CPR_GoNewLine:
.018e48	4c ae 8e	jmp $018eae			jmp 	_CPR_NewLine
.018e4b	20 e1 9d	jsr $019de1	_CPRInt:jsr 	IntToString
.018e4e					_CPRNPrint:
.018e4e	ad 15 03	lda $0315			lda 	Num_Buffer 					; is first character -
.018e51	c9 2d		cmp #$2d			cmp 	#"-"
.018e53	f0 05		beq $018e5a			beq 	_CPRNoSpace
.018e55	a9 20		lda #$20			lda 	#" "						; print the leading space
.018e57	20 32 85	jsr $018532			jsr 	VIOCharPrint 				; so beloved of MS Basics.
.018e5a					_CPRNoSpace:
.018e5a	a2 14		ldx #$14			ldx 	#(Num_Buffer-1) & $FF
.018e5c	a9 03		lda #$03			lda 	#(Num_Buffer-1) >> 8
.018e5e	80 04		bra $018e64			bra 	_CPRPrint
.018e60					_CPR_String:
.018e60	a6 80		ldx $80				ldx 	XS_Mantissa
.018e62	a5 81		lda $81				lda 	XS_Mantissa+1
.018e64					_CPRPrint:
.018e64	86 1e		stx $1e				stx 	zGenPtr
.018e66	85 1f		sta $1f				sta 	zGenPtr+1
.018e68	5a		phy				phy
.018e69	a0 00		ldy #$00			ldy 	#0							; get length into X
.018e6b	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018e6d	aa		tax				tax
.018e6e	f0 09		beq $018e79			beq 	_CPREndPrint 				; nothing to print
.018e70					_CPRLoop:
.018e70	c8		iny				iny
.018e71	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018e73	20 32 85	jsr $018532			jsr 	VIOCharPrint
.018e76	ca		dex				dex
.018e77	d0 f7		bne $018e70			bne 	_CPRLoop
.018e79					_CPREndPrint:
.018e79	a5 85		lda $85				lda 	XS_Type 					; if numeric add trailing space
.018e7b	29 02		and #$02			and 	#2
.018e7d	d0 05		bne $018e84			bne 	_CPRNoTrail
.018e7f	a9 20		lda #$20			lda 	#" "
.018e81	20 32 85	jsr $018532			jsr 	VIOCharPrint
.018e84					_CPRNoTrail:
.018e84	7a		ply				ply
.018e85	80 97		bra $018e1e			bra 	Command_Print
.018e87					_CPR_Tab:
.018e87	20 43 85	jsr $018543			jsr 	VIOCharGetPosition 			; print until position % 8 = 0
.018e8a					_CPR_CalcSpaces:
.018e8a	38		sec				sec 								; calculate position mod 10.
.018e8b	e9 0a		sbc #$0a			sbc 	#10
.018e8d	b0 fb		bcs $018e8a			bcs 	_CPR_CalcSpaces
.018e8f	69 0a		adc #$0a			adc 	#10
.018e91	f0 0d		beq $018ea0			beq 	_CPR_Skip 					; nothing to print
.018e93	aa		tax				tax 								; print out spaces to mod 10
.018e94					_CPRTabSpaces:
.018e94	a9 20		lda #$20			lda 	#" "
.018e96	20 32 85	jsr $018532			jsr 	VIOCharPrint
.018e99	e8		inx				inx
.018e9a	e0 0a		cpx #$0a			cpx 	#10
.018e9c	d0 f6		bne $018e94			bne 	_CPRTabSpaces
.018e9e	80 e7		bra $018e87			bra 	_CPR_Tab
.018ea0					_CPR_Skip:
.018ea0	c8		iny				iny
.018ea1	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018ea3	c9 c0		cmp #$c0			cmp 	#token_Colon 				; colon or $00, exit
.018ea5	f0 0c		beq $018eb3			beq 	_CPR_Exit
.018ea7	c9 00		cmp #$00			cmp 	#0
.018ea9	f0 08		beq $018eb3			beq 	_CPR_Exit 					; if not go round again.
.018eab	4c 1e 8e	jmp $018e1e			jmp 	Command_Print
.018eae					_CPR_NewLine:
.018eae	a9 0d		lda #$0d			lda 	#13
.018eb0	20 32 85	jsr $018532			jsr 	VIOCharPrint
.018eb3					_CPR_Exit:
.018eb3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/assert.asm

.018eb4					Command_ASSERT:
.018eb4	20 1a 92	jsr $01921a			jsr 	EvaluateInteger 			; calculate thing being asserted
.018eb7	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; check if true (non-zero)
.018eb9	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.018ebb	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.018ebd	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.018ebf	f0 01		beq $018ec2			beq 	_ASFail
.018ec1	60		rts				rts
.018ec2					_ASFail:
.018ec2	20 79 85	jsr $018579			jsr ERR_Handler
>018ec5	41 73 73 65 72 74 00			.text "Assert",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/poke.asm

.018ecc					Command_POKE:
.018ecc	a9 01		lda #$01			lda 	#1
.018ece	80 06		bra $018ed6			bra 	CmdPoke_Main
.018ed0					Command_DOKE:
.018ed0	a9 02		lda #$02			lda 	#2
.018ed2	80 02		bra $018ed6			bra 	CmdPoke_Main
.018ed4					Command_LOKE:
.018ed4	a9 04		lda #$04			lda 	#4
.018ed6					CmdPoke_Main:
.018ed6	48		pha				pha
.018ed7	20 1a 92	jsr $01921a			jsr 	EvaluateInteger 			; get two parameters.
.018eda	e8		inx				inx
.018edb	e8		inx				inx
.018edc	e8		inx				inx
.018edd	e8		inx				inx
.018ede	e8		inx				inx
.018edf	e8		inx				inx
.018ee0	20 66 98	jsr $019866			jsr 	CheckNextComma
.018ee3	20 1c 92	jsr $01921c			jsr 	EvaluateIntegerX
.018ee6	a5 80		lda $80				lda 	XS_Mantissa+0 			; copy the mantissa into ZLTemp1 (address)
.018ee8	85 1a		sta $1a				sta 	zLTemp1
.018eea	a5 81		lda $81				lda 	XS_Mantissa+1
.018eec	85 1b		sta $1b				sta 	zLTemp1+1
.018eee	a5 82		lda $82				lda 	XS_Mantissa+2
.018ef0	85 1c		sta $1c				sta 	zLTemp1+2
.018ef2	a5 83		lda $83				lda 	XS_Mantissa+3
.018ef4	85 1d		sta $1d				sta 	zLTemp1+3
.018ef6	68		pla				pla 								; get count
.018ef7	5a		phy				phy 								; save Y
.018ef8	20 f1 97	jsr $0197f1			jsr 	MemWrite 					; write it out
.018efb	7a		ply				ply 								; restore Y and done.
.018efc	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/newold.asm

.018efd					Command_NEW:
.018efd	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018eff	85 16		sta $16				sta 	zCodePtr+0
.018f01	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018f03	85 17		sta $17				sta 	zCodePtr+1
.018f05	a9 00		lda #$00			lda 	#0
.018f07	85 18		sta $18				sta 	zCodePtr+2
.018f09	85 19		sta $19				sta 	zCodePtr+3
.018f0b	a0 03		ldy #$03			ldy 	#3
.018f0d	a0 00		ldy #$00			ldy 	#0
.018f0f	a9 00		lda #$00			lda 	#0 							; write a 0 there.
.018f11	97 16		sta [$16],y			sta 	[zCodePtr],y
.018f13	20 02 98	jsr $019802			jsr 	UpdateProgramEnd 			; update program end.
.018f16	4c 32 88	jmp $018832			jmp 	WarmStart
.018f19					Command_OLD:
.018f19	ea		nop				nop
.018f1a	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018f1c	85 16		sta $16				sta 	zCodePtr+0
.018f1e	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018f20	85 17		sta $17				sta 	zCodePtr+1
.018f22	a9 00		lda #$00			lda 	#0
.018f24	85 18		sta $18				sta 	zCodePtr+2
.018f26	85 19		sta $19				sta 	zCodePtr+3
.018f28	a0 03		ldy #$03			ldy 	#3
.018f2a					_COL_Find:
.018f2a	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018f2c	c8		iny				iny
.018f2d	c9 00		cmp #$00			cmp 	#0 							; if zero, then the position Y/Z is new offset
.018f2f	f0 18		beq $018f49			beq 	_COL_Found
.018f31	98		tya				tya
.018f32	c9 00		cmp #$00			cmp 	#0
.018f34	d0 f4		bne $018f2a			bne 	_COL_Find 					; can't find old EOL, give up.
.018f36	20 79 85	jsr $018579			jsr ERR_Handler
>018f39	50 72 6f 67 72 61 6d 20			.text "Program Corrupt",0
>018f41	43 6f 72 72 75 70 74 00
.018f49					_COL_Found:
.018f49	98		tya				tya
.018f4a	48		pha				pha
.018f4b	a0 00		ldy #$00			ldy 	#0
.018f4d	68		pla				pla
.018f4e	97 16		sta [$16],y			sta 	[zCodePtr],y
.018f50	20 02 98	jsr $019802			jsr 	UpdateProgramEnd 			; reset variable pointer
.018f53	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/branch.asm

.018f54					Command_GOTO:
.018f54	20 a9 8f	jsr $018fa9			jsr 	GotoGetLineNumber
.018f57					CmdGOTO:
.018f57	a2 00		ldx #$00			ldx 	#0
.018f59	4c c6 8f	jmp $018fc6			jmp 	GotoChangeToLineNumberX
.018f5c					Command_GOSUB:
.018f5c	20 a9 8f	jsr $018fa9			jsr 	GotoGetLineNumber
.018f5f					CmdGOSUB:
.018f5f	20 f9 84	jsr $0184f9			jsr 	StackSavePosition
.018f62	a9 15		lda #$15			lda 	#(SMark_Gosub << 4)+SourcePosSize
.018f64	20 b2 84	jsr $0184b2			jsr 	StackPushFrame
.018f67	a2 00		ldx #$00			ldx		#0
.018f69	4c c6 8f	jmp $018fc6			jmp 	GotoChangeToLineNumberX
.018f6c					Command_RETURN:
.018f6c	a9 10		lda #$10			lda 	#(SMark_Gosub << 4)
.018f6e	20 c9 84	jsr $0184c9			jsr 	StackPopFrame
.018f71	20 16 85	jsr $018516			jsr 	StackRestorePosition
.018f74	60		rts				rts
.018f75					Command_ON:
.018f75	a2 00		ldx #$00			ldx 	#0 							; get the ON.
.018f77	20 b6 96	jsr $0196b6			jsr 	SLIByteParameter
.018f7a	a5 80		lda $80				lda 	XS_Mantissa+0 				; get the count
.018f7c	f0 28		beq $018fa6			beq 	_CONFail 					; can't be zero.
.018f7e	aa		tax				tax 								; save in X.
.018f7f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018f81	c8		iny				iny
.018f82	48		pha				pha
.018f83	c9 cc		cmp #$cc			cmp 	#token_GOTO 				; must be GOTO or GOSUB
.018f85	f0 07		beq $018f8e			beq 	_CONOkayToken
.018f87	c9 ca		cmp #$ca			cmp 	#token_GOSUB
.018f89	f0 03		beq $018f8e			beq 	_CONOkayToken
.018f8b	4c 4a 85	jmp $01854a			jmp 	SyntaxError
.018f8e					_CONOkayToken:
.018f8e	da		phx				phx 								; count on top, GOTO/GOSUB token 2nd.
.018f8f					_CONFindNumber:
.018f8f	20 a9 8f	jsr $018fa9			jsr 	GotoGetLineNumber 			; get a line number.
.018f92	fa		plx				plx 								; restore count
.018f93	ca		dex				dex  								; decrement, exit if zero.
.018f94	f0 06		beq $018f9c			beq 	_CONFound
.018f96	da		phx				phx 								; push back
.018f97	20 66 98	jsr $019866			jsr 	CheckNextComma				; check for comma
.018f9a	80 f3		bra $018f8f			bra 	_CONFindNumber
.018f9c					_CONFound:
.018f9c	68		pla				pla 								; get token
.018f9d	c9 cc		cmp #$cc			cmp 	#token_GOTO 				; if GOTO
.018f9f	f0 b6		beq $018f57			beq		CmdGOTO 					; then just branch.
.018fa1	20 80 84	jsr $018480			jsr 	SkipEndOfCommand 			; go to end of command
.018fa4	80 b9		bra $018f5f			bra 	CmdGOSUB 					; and do a GOSUB.
.018fa6					_CONFail:
.018fa6	4c 68 85	jmp $018568			jmp 	BadParamError
.018fa9					GotoGetLineNumber:
.018fa9	20 1a 92	jsr $01921a			jsr 	EvaluateInteger
.018fac	a5 82		lda $82				lda 	XS_Mantissa+2 				; check range
.018fae	05 83		ora $83				ora 	XS_Mantissa+3
.018fb0	d0 01		bne $018fb3			bne 	_GLINError
.018fb2	60		rts				rts
.018fb3					_GLINError:
.018fb3	20 79 85	jsr $018579			jsr ERR_Handler
>018fb6	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>018fbe	20 4e 75 6d 62 65 72 00
.018fc6					GotoChangeToLineNumberX:
.018fc6	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check line number not zero
.018fc8	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.018fca	f0 37		beq $019003			beq 	_GCTLFail
.018fcc	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018fce	85 16		sta $16				sta 	zCodePtr+0
.018fd0	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018fd2	85 17		sta $17				sta 	zCodePtr+1
.018fd4	a9 00		lda #$00			lda 	#0
.018fd6	85 18		sta $18				sta 	zCodePtr+2
.018fd8	85 19		sta $19				sta 	zCodePtr+3
.018fda	a0 03		ldy #$03			ldy 	#3
.018fdc					_GCTLLoop:
.018fdc	a0 00		ldy #$00			ldy 	#0
.018fde	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018fe0	c9 00		cmp #$00			cmp 	#0
.018fe2	f0 1f		beq $019003			beq 	_GCTLFail
.018fe4	c8		iny				iny
.018fe5	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018fe7	d5 80		cmp $80,x			cmp 	XS_Mantissa+0,x
.018fe9	d0 07		bne $018ff2			bne 	_GCTLNext
.018feb	c8		iny				iny
.018fec	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018fee	d5 81		cmp $81,x			cmp 	XS_Mantissa+1,x
.018ff0	f0 0f		beq $019001			beq 	_GCTLExit
.018ff2					_GCTLNext:
.018ff2	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018ff4	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.018ff6	18		clc				clc
.018ff7	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018ff9	85 16		sta $16				sta 	zCodePtr
.018ffb	90 02		bcc $018fff			bcc 	_SNLNoCarry
.018ffd	e6 17		inc $17				inc 	zCodePtr+1
.018fff					_SNLNoCarry:
.018fff	80 db		bra $018fdc			bra 	_GCTLLoop 					; try next line.
.019001					_GCTLExit:
.019001	c8		iny				iny
.019002	60		rts				rts
.019003					_GCTLFail:
.019003	20 79 85	jsr $018579			jsr ERR_Handler
>019006	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>01900e	20 4e 75 6d 62 65 72 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.019016					Command_CLR:
.019016					ResetRunStatus:
.019016	20 3b 99	jsr $01993b			jsr 	VariableClear
.019019	20 a0 84	jsr $0184a0			jsr 	StackReset
.01901c	a9 00		lda #$00			lda 	#HighMemory & $FF
.01901e	8d 00 03	sta $0300			sta 	StringPtr
.019021	a9 7f		lda #$7f			lda 	#HighMemory >> 8
.019023	8d 01 03	sta $0301			sta 	StringPtr+1
.019026	20 05 9b	jsr $019b05			jsr 	ArrayResetDefault
.019029	20 ed 8a	jsr $018aed			jsr 	Command_RESTORE
.01902c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/stop.asm

.01902d					Command_STOP:
.01902d	20 79 85	jsr $018579			jsr ERR_Handler
>019030	53 74 6f 70 00				.text "Stop",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/while.asm

.019035					Command_WHILE:
.019035	20 f9 84	jsr $0184f9			jsr 	StackSavePosition			; save position into stack, but don't yet push.
.019038	20 1a 92	jsr $01921a			jsr 	EvaluateInteger 			; calculate the while loop value.
.01903b	a5 80		lda $80				lda 	XS_Mantissa+0				; check the result if zero
.01903d	05 81		ora $81				ora 	XS_Mantissa+1
.01903f	05 82		ora $82				ora 	XS_Mantissa+2
.019041	05 83		ora $83				ora 	XS_Mantissa+3
.019043	f0 06		beq $01904b			beq 	_CWHSkip 					; if it is zero, then skip to WEND.
.019045	a9 35		lda #$35			lda 	#(SMark_While << 4)+SourcePosSize
.019047	20 b2 84	jsr $0184b2			jsr 	StackPushFrame 				; push on stack
.01904a	60		rts				rts
.01904b					_CWHSkip:
.01904b	a9 95		lda #$95			lda 	#token_Wend 				; look for the WEND token.
.01904d	20 f3 83	jsr $0183f3			jsr 	StructureSearchSingle
.019050	c8		iny				iny
.019051	60		rts				rts
.019052					Command_WEND:
.019052	a9 30		lda #$30			lda 	#(SMark_While << 4)			; remove the frame
.019054	20 c9 84	jsr $0184c9			jsr 	StackPopFrame
.019057	20 16 85	jsr $018516			jsr 	StackRestorePosition
.01905a	80 d9		bra $019035			bra 	Command_WHILE 				; and do the while again.
.01905c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/repeat.asm

.01905d					Command_REPEAT:
.01905d	20 f9 84	jsr $0184f9			jsr 	StackSavePosition			; save position into stack
.019060	a9 25		lda #$25			lda 	#(SMark_Repeat << 4)+SourcePosSize
.019062	20 b2 84	jsr $0184b2			jsr 	StackPushFrame 				; push on stack
.019065	60		rts				rts
.019066					Command_UNTIL:
.019066	a9 20		lda #$20			lda 	#(SMark_Repeat << 4)		; remove the frame
.019068	20 c9 84	jsr $0184c9			jsr 	StackPopFrame
.01906b	20 1a 92	jsr $01921a			jsr 	EvaluateInteger				; work out UNTIL
.01906e	a5 80		lda $80				lda 	XS_Mantissa+0 				; check if zero.
.019070	05 81		ora $81				ora 	XS_Mantissa+1
.019072	05 82		ora $82				ora 	XS_Mantissa+2
.019074	05 83		ora $83				ora 	XS_Mantissa+3
.019076	d0 08		bne $019080			bne 	_CUTExit 					; if not, just exit
.019078	20 16 85	jsr $018516			jsr 	StackRestorePosition 		; otherwise loop round again.
.01907b	a9 25		lda #$25			lda 	#(SMark_Repeat << 4)+SourcePosSize
.01907d	20 b2 84	jsr $0184b2			jsr 	StackPushFrame 				; fix the stack back.
.019080					_CUTExit:
.019080	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.019081					EVESyntax:
.019081	4c 4a 85	jmp $01854a			jmp 	SyntaxError
.019084					EvaluateExpression:
.019084	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.019086					EvaluateExpressionX:
.019086	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.019088					EvaluateExpressionXA:
.019088	48		pha				pha 								; save precedence on stack.
.019089	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01908b	f0 f4		beq $019081			beq 	EVESyntax 					; end of line, syntax error.
.01908d	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.01908f	b0 03		bcs $019094			bcs 	_EVNotVariable
.019091	4c 5e 91	jmp $01915e			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.019094					_EVNotVariable:
.019094	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.019096	90 e9		bcc $019081			bcc 	EVESyntax
.019098	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.01909a	b0 58		bcs $0190f4			bcs 	_EVNotInteger
.01909c	20 8c 91	jsr $01918c			jsr 	EvaluateGetInteger
.01909f					_EVCheckDecimal:
.01909f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0190a1	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.0190a3	d0 05		bne $0190aa			bne 	_EVGotAtom 					; no, get atom.
.0190a5					_EVIsDecimal:
.0190a5	20 b2 91	jsr $0191b2			jsr 	EVGetDecimal 				; extend to the decimal part.
.0190a8	80 00		bra $0190aa			bra 	_EVGotAtom 					; and continue to got atom.
.0190aa					_EVGotAtom:
.0190aa	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0190ac	10 44		bpl $0190f2			bpl 	_EVExitDrop 				; must be a token.
.0190ae	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.0190b0	b0 40		bcs $0190f2			bcs 	_EVExitDrop
.0190b2	68		pla				pla 								; get current precedence
.0190b3	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.0190b5	da		phx				phx 								; save X
.0190b6	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0190b8	aa		tax				tax 								; put in X
.0190b9	bf 2e 86 01	lda $01862e,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.0190bd	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.0190bf	fa		plx				plx 								; restore X
.0190c0	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.0190c2	90 2f		bcc $0190f3			bcc 	_EVExit 					; exit if too low.
.0190c4	f0 2d		beq $0190f3			beq 	_EVExit 					; exit if equals
.0190c6	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.0190c8	48		pha				pha
.0190c9	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0190cb	48		pha				pha
.0190cc	c8		iny				iny
.0190cd	da		phx				phx 								; save current position
.0190ce	e8		inx				inx
.0190cf	e8		inx				inx
.0190d0	e8		inx				inx
.0190d1	e8		inx				inx
.0190d2	e8		inx				inx
.0190d3	e8		inx				inx
.0190d4	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.0190d6	20 88 90	jsr $019088			jsr 	EvaluateExpressionXA 		; do the RHS.
.0190d9	fa		plx				plx 								; restore X
.0190da	68		pla				pla 								; get the binary operator in A.
.0190db					_EVCallA:
.0190db	da		phx				phx 								; save X again
.0190dc	0a		asl a				asl 	a 							; double, lose the MSB.
.0190dd	aa		tax				tax									; put in X
.0190de	bf dd 85 01	lda $0185dd,x			lda 	VectorTable,x 				; copy address into zGenPtr
.0190e2	8d 11 03	sta $0311			sta 	LocalVector+1
.0190e5	bf de 85 01	lda $0185de,x			lda 	VectorTable+1,x
.0190e9	8d 12 03	sta $0312			sta 	LocalVector+2
.0190ec	fa		plx				plx 								; restore X
.0190ed	20 67 91	jsr $019167			jsr 	EVCallLocalVector
.0190f0	80 b8		bra $0190aa			bra 	_EVGotAtom 					; and loop back.
.0190f2					_EVExitDrop:
.0190f2	68		pla				pla
.0190f3					_EVExit:
.0190f3	60		rts				rts
.0190f4					_EVNotInteger:
.0190f4	c8		iny				iny
.0190f5	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.0190f7	d0 16		bne $01910f			bne 	_EVNotMinus
.0190f9	20 fb 91	jsr $0191fb			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.0190fc	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.0190fe	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.019100	f0 05		beq $019107			beq 	_EVMinusFloat
.019102	20 c4 9d	jsr $019dc4			jsr 	IntegerNegateAlways 		; negation
.019105	80 a3		bra $0190aa			bra 	_EVGotAtom 					; and go back.
.019107					_EVMinusFloat:
.019107	b5 85		lda $85,x			lda 	XS_Type,x 					; invert the sign bit.
.019109	49 80		eor #$80			eor 	#$80
.01910b	95 85		sta $85,x			sta 	XS_Type,x
.01910d	80 9b		bra $0190aa			bra 	_EVGotAtom
.01910f					_EVNotMinus:
.01910f	c9 bd		cmp #$bd			cmp 	#token_lparen 				; is it left parenthesis
.019111	d0 17		bne $01912a			bne 	_EVNotParenthesis
.019113	20 86 90	jsr $019086			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.019116	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019118	c8		iny				iny
.019119	c9 be		cmp #$be			cmp 	#token_rparen 				; okay if right bracket.
.01911b	f0 8d		beq $0190aa			beq 	_EVGotAtom
.01911d	20 79 85	jsr $018579			jsr ERR_Handler
>019120	4d 69 73 73 69 6e 67 20			.text "Missing )",0
>019128	29 00
.01912a					_EVNotParenthesis:
.01912a	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.01912c	d0 0c		bne $01913a			bne 	_EVNotNot
.01912e	20 fb 91	jsr $0191fb			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.019131	20 5a a2	jsr $01a25a			jsr 	FPUToInteger 				; make it an integer - if possible.
.019134	20 e0 91	jsr $0191e0			jsr 	NotInteger 					; do the not calculation
.019137	4c aa 90	jmp $0190aa			jmp 	_EVGotAtom
.01913a					_EVNotNot:
.01913a	c9 fe		cmp #$fe			cmp 	#$FE
.01913c	d0 12		bne $019150			bne 	_EVNotString
.01913e	20 d9 98	jsr $0198d9			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.019141	a5 20		lda $20				lda 	zTempStr 					; copy address of string into mantissa
.019143	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019145	a5 21		lda $21				lda 	zTempStr+1
.019147	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019149	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.01914b	95 85		sta $85,x			sta 	XS_Type,x
.01914d	4c aa 90	jmp $0190aa			jmp 	_EVGotAtom
.019150					_EVNotString:
.019150	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.019152	90 04		bcc $019158			bcc 	_EVBadElement
.019154	c9 b7		cmp #$b7			cmp 	#lastUnaryFunction+1
.019156	90 03		bcc $01915b			bcc 	_EVUnaryFunction
.019158					_EVBadElement:
.019158	4c 4a 85	jmp $01854a			jmp 	SyntaxError
.01915b					_EVUnaryFunction:
.01915b	4c db 90	jmp $0190db			jmp 	_EVCallA
.01915e					_EVVariableHandler:
.01915e	20 ff 98	jsr $0198ff			jsr 	VariableFind 				; locate a variable
.019161	20 47 9c	jsr $019c47			jsr 	VariableGet 				; copy into memory.
.019164	4c aa 90	jmp $0190aa			jmp 	_EVGotAtom 					; and go round.
.019167					EVCallLocalVector:
.019167	6c 11 03	jmp ($0311)			jmp 	(LocalVector+1)
.01916a					EVShiftMantissaLeft6:
.01916a	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.01916c	95 84		sta $84,x			sta 	XS_Exponent,x
.01916e	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019170	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019172	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019174	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019176	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019178	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01917a	a9 00		lda #$00			lda 	#0
.01917c	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01917e	20 81 91	jsr $019181			jsr 	_EVSMLShift 					; call it here to do it twice
.019181					_EVSMLShift:
.019181	56 84		lsr $84,x			lsr 	XS_Exponent,x
.019183	76 83		ror $83,x			ror 	XS_Mantissa+3,x
.019185	76 82		ror $82,x			ror 	XS_Mantissa+2,x
.019187	76 81		ror $81,x			ror 	XS_Mantissa+1,x
.019189	76 80		ror $80,x			ror 	XS_Mantissa+0,x
.01918b	60		rts				rts
.01918c					EvaluateGetInteger:
.01918c	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01918e	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.019190	95 80		sta $80,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.019192	a9 00		lda #$00			lda 	#0
.019194	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019196	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019198	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01919a	1a		inc a				inc 	a 							; set to type 1 (integer)
.01919b	95 85		sta $85,x			sta 	XS_Type,x
.01919d					_EVCheckNextInteger:
.01919d	c8		iny				iny
.01919e	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0191a0	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.0191a2	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.0191a4	b0 0b		bcs $0191b1			bcs 	_EVEndInteger
.0191a6	48		pha				pha 								; save it.
.0191a7	20 6a 91	jsr $01916a			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.0191aa	68		pla				pla
.0191ab	15 80		ora $80,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.0191ad	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0191af	80 ec		bra $01919d			bra 	_EVCheckNextInteger
.0191b1					_EVEndInteger:
.0191b1	60		rts				rts
.0191b2					EVGetDecimal:
.0191b2	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.0191b4	8d 15 03	sta $0315			sta 	Num_Buffer
.0191b7	da		phx				phx
.0191b8	c8		iny				iny
.0191b9	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0191bb	c8		iny				iny
.0191bc	3a		dec a				dec 	a								; convert to a string length.
.0191bd	3a		dec a				dec 	a
.0191be	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.0191c0					_EVGDCopy:
.0191c0	48		pha				pha 									; save count
.0191c1	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0191c3	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.0191c6	e8		inx				inx 									; forward ....
.0191c7	c8		iny				iny
.0191c8	68		pla				pla 									; get count
.0191c9	3a		dec a				dec 	a 								; until zero
.0191ca	d0 f4		bne $0191c0			bne 	_EVGDCopy
.0191cc	9d 15 03	sta $0315,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.0191cf	fa		plx				plx 									; restore X
.0191d0	a9 15		lda #$15			lda 	#Num_Buffer & $FF 				; set zGenPtr
.0191d2	85 1e		sta $1e				sta 	zGenPtr
.0191d4	a9 03		lda #$03			lda 	#Num_Buffer >> 8
.0191d6	85 1f		sta $1f				sta 	zGenPtr+1
.0191d8	5a		phy				phy 									; save Y
.0191d9	a0 00		ldy #$00			ldy 	#0 								; start position
.0191db	20 14 a4	jsr $01a414			jsr 	FPFromString 					; convert current
.0191de	7a		ply				ply 									; restore Y
.0191df	60		rts				rts
.0191e0					NotInteger:
.0191e0	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0191e2	49 ff		eor #$ff			eor 	#$FF
.0191e4	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0191e6	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0191e8	49 ff		eor #$ff			eor 	#$FF
.0191ea	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0191ec	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0191ee	49 ff		eor #$ff			eor 	#$FF
.0191f0	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0191f2	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.0191f4	49 ff		eor #$ff			eor 	#$FF
.0191f6	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0191f8	60		rts				rts
.0191f9					EvaluateGetAtom:
.0191f9	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.0191fb					EvaluateGetAtomX:
.0191fb	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.0191fd	20 88 90	jsr $019088			jsr 	EvaluateExpressionXA
.019200	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.019202	29 0f		and #$0f			and 	#15
.019204	c9 02		cmp #$02			cmp 	#2
.019206	b0 01		bcs $019209			bcs 	EvaluateType
.019208	60		rts				rts
.019209					EvaluateType:
.019209	4c 5a 85	jmp $01855a			jmp 	TypeError
.01920c					EvaluateNumber:
.01920c	a2 00		ldx #$00			ldx 	#0
.01920e					EvaluateNumberX:
.01920e	20 86 90	jsr $019086			jsr 	EvaluateExpressionX
.019211	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0/1
.019213	29 0f		and #$0f			and 	#15
.019215	c9 02		cmp #$02			cmp 	#2
.019217	b0 f0		bcs $019209			bcs 	EvaluateType
.019219	60		rts				rts
.01921a					EvaluateInteger:
.01921a	a2 00		ldx #$00			ldx 	#0
.01921c					EvaluateIntegerX:
.01921c	20 0e 92	jsr $01920e			jsr 	EvaluateNumberX
.01921f	20 5a a2	jsr $01a25a			jsr 	FPUToInteger
.019222	60		rts				rts
.019223					EvaluateString:
.019223	a2 00		ldx #$00			ldx 	#0
.019225					EvaluateStringX:
.019225	20 86 90	jsr $019086			jsr 	EvaluateExpressionX
.019228	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 2
.01922a	29 0f		and #$0f			and 	#15
.01922c	c9 02		cmp #$02			cmp 	#2
.01922e	d0 d9		bne $019209			bne 	EvaluateType
.019230	b5 80		lda $80,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.019232	85 1e		sta $1e				sta 	zGenPtr
.019234	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019236	85 1f		sta $1f				sta 	zGenPtr+1
.019238	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.019239					BinaryOp_And:
.019239	20 8d 92	jsr $01928d			jsr 	BinaryMakeBothInteger
.01923c	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.01923e	35 86		and $86,x			and 	XS2_Mantissa+0,x
.019240	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019242	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.019244	35 87		and $87,x			and 	XS2_Mantissa+1,x
.019246	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019248	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.01924a	35 88		and $88,x			and 	XS2_Mantissa+2,x
.01924c	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01924e	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.019250	35 89		and $89,x			and 	XS2_Mantissa+3,x
.019252	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019254	60		rts				rts
.019255					BinaryOp_Or:
.019255	20 8d 92	jsr $01928d			jsr 	BinaryMakeBothInteger
.019258	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.01925a	15 86		ora $86,x			ora 	XS2_Mantissa+0,x
.01925c	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01925e	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.019260	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.019262	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019264	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.019266	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.019268	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01926a	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.01926c	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.01926e	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019270	60		rts				rts
.019271					BinaryOp_Eor:
.019271					BinaryOp_Xor:
.019271	20 8d 92	jsr $01928d			jsr 	BinaryMakeBothInteger
.019274	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.019276	55 86		eor $86,x			eor 	XS2_Mantissa+0,x
.019278	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01927a	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.01927c	55 87		eor $87,x			eor 	XS2_Mantissa+1,x
.01927e	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019280	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.019282	55 88		eor $88,x			eor 	XS2_Mantissa+2,x
.019284	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019286	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.019288	55 89		eor $89,x			eor 	XS2_Mantissa+3,x
.01928a	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01928c	60		rts				rts
.01928d					BinaryMakeBothInteger:
.01928d	da		phx				phx 								; save X
.01928e	e8		inx				inx
.01928f	e8		inx				inx
.019290	e8		inx				inx
.019291	e8		inx				inx
.019292	e8		inx				inx
.019293	e8		inx				inx
.019294	20 98 92	jsr $019298			jsr 	BinaryMakeInteger 			; convert to integer.
.019297	fa		plx				plx 								; restore X and fall through.
.019298					BinaryMakeInteger:
.019298	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.01929a	29 0f		and #$0f			and 	#15 						; check type zero
.01929c	f0 04		beq $0192a2			beq 	_BMIConvert 				; if float convert to integer.
.01929e	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.01929f	90 04		bcc $0192a5			bcc 	_BMIError
.0192a1	60		rts				rts
.0192a2					_BMIConvert:
.0192a2	4c 5a a2	jmp $01a25a			jmp 	FPUToInteger 				; convert to integer
.0192a5					_BMIError:
.0192a5	4c 5a 85	jmp $01855a			jmp 	TypeError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.0192a8					Binary_Equal:
.0192a8	20 ef 92	jsr $0192ef			jsr 	CompareValues
.0192ab	09 00		ora #$00			ora 	#0
.0192ad	f0 04		beq $0192b3			beq 	CCTrue
.0192af	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.0192b1	80 02		bra $0192b5			bra 	CCWrite
.0192b3	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.0192b5	95 80		sta $80,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.0192b7	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0192b9	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0192bb	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0192bd	a9 01		lda #$01			lda 	#1
.0192bf	95 85		sta $85,x			sta 	XS_Type,x 					; set type to integer whatever.
.0192c1	60		rts				rts
.0192c2					Binary_NotEqual:
.0192c2	20 ef 92	jsr $0192ef			jsr 	CompareValues
.0192c5	09 00		ora #$00			ora 	#0
.0192c7	f0 e6		beq $0192af			beq 	CCFalse
.0192c9	80 e8		bra $0192b3			bra 	CCTrue
.0192cb					Binary_Less:
.0192cb	20 ef 92	jsr $0192ef			jsr 	CompareValues
.0192ce	09 00		ora #$00			ora 	#0
.0192d0	30 e1		bmi $0192b3			bmi 	CCTrue
.0192d2	80 db		bra $0192af			bra 	CCFalse
.0192d4					Binary_LessEqual:
.0192d4	20 ef 92	jsr $0192ef			jsr 	CompareValues
.0192d7	c9 01		cmp #$01			cmp 	#1
.0192d9	d0 d8		bne $0192b3			bne 	CCTrue
.0192db	80 d2		bra $0192af			bra 	CCFalse
.0192dd					Binary_GreaterEqual:
.0192dd	20 ef 92	jsr $0192ef			jsr 	CompareValues
.0192e0	09 00		ora #$00			ora 	#0
.0192e2	10 cf		bpl $0192b3			bpl 	CCTrue
.0192e4	80 c9		bra $0192af			bra 	CCFalse
.0192e6					Binary_Greater:
.0192e6	20 ef 92	jsr $0192ef			jsr 	CompareValues
.0192e9	c9 01		cmp #$01			cmp 	#1
.0192eb	f0 c6		beq $0192b3			beq 	CCTrue
.0192ed	80 c0		bra $0192af			bra 	CCFalse
.0192ef					CompareValues:
.0192ef	b5 85		lda $85,x			lda 	XS_Type,x 					; and the types together
.0192f1	35 8b		and $8b,x			and 	XS2_Type,x
.0192f3	c9 02		cmp #$02			cmp 	#2
.0192f5	f0 11		beq $019308			beq 	_CVString
.0192f7	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.0192f9	35 8b		and $8b,x			and 	XS2_Type,x
.0192fb	4a		lsr a				lsr 	a 							; shift bit 0 into C
.0192fc	90 03		bcc $019301			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.0192fe	4c 4a 93	jmp $01934a			jmp 	CompareInteger32 							; so execute code at \1
.019301					_BCFloat:
.019301	20 ee 93	jsr $0193ee			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.019304	4c 53 a1	jmp $01a153			jmp 	FPCompare 							; and execute code at \2
.019307	60		rts				rts
.019308					_CVString:
.019308	da		phx				phx 								; save XY
.019309	5a		phy				phy
.01930a	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.01930c	85 1a		sta $1a				sta		zLTemp1+0
.01930e	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019310	85 1b		sta $1b				sta 	zLTemp1+1
.019312	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.019314	85 1c		sta $1c				sta 	zLTemp1+2
.019316	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.019318	85 1d		sta $1d				sta 	zLTemp1+3
.01931a	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.01931c	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.01931e	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.019320	90 02		bcc $019324			bcc 	_CVCommon
.019322	b1 1c		lda ($1c),y			lda 	(zLTemp1+2),y
.019324					_CVCommon:
.019324	aa		tax				tax 								; put shorter string length in zero.
.019325	f0 0c		beq $019333			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.019327					_CVCompare:
.019327	c8		iny				iny 								; next character
.019328	b1 1a		lda ($1a),y			lda 	(zLTemp1),y 				; compare characters
.01932a	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.01932c	90 13		bcc $019341			bcc 	_CVReturnLess 				; <
.01932e	d0 15		bne $019345			bne 	_CVReturnGreater 			; >
.019330	ca		dex				dex 								; until common length matched.
.019331	d0 f4		bne $019327			bne 	_CVCompare
.019333					_CVMatch:
.019333	a0 00		ldy #$00			ldy 	#0
.019335	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.019337	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.019339	90 06		bcc $019341			bcc 	_CVReturnLess 				; <
.01933b	d0 08		bne $019345			bne 	_CVReturnGreater 			; >
.01933d	a9 00		lda #$00			lda 	#0
.01933f	80 06		bra $019347			bra 	_CVExit 					; same common, same length, same string
.019341					_CVReturnLess:
.019341	a9 ff		lda #$ff			lda 	#$FF
.019343	80 02		bra $019347			bra 	_CVExit
.019345					_CVReturnGreater:
.019345	a9 01		lda #$01			lda 	#$01
.019347					_CVExit:
.019347	7a		ply				ply
.019348	fa		plx				plx
.019349	60		rts				rts
.01934a					CompareInteger32:
.01934a	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.01934c	49 80		eor #$80			eor 	#$80
.01934e	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019350	b5 89		lda $89,x			lda 	XS2_Mantissa+3,x
.019352	49 80		eor #$80			eor 	#$80
.019354	95 89		sta $89,x			sta 	XS2_Mantissa+3,x
.019356	20 d4 93	jsr $0193d4			jsr 	SubInteger32 				; subtraction
.019359	90 0d		bcc $019368			bcc 	_CI32Less 					; cc return -1
.01935b	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check if zero
.01935d	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.01935f	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019361	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019363	f0 02		beq $019367			beq 	_CI32Exit
.019365	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.019367					_CI32Exit:
.019367	60		rts				rts
.019368					_CI32Less:
.019368	a9 ff		lda #$ff			lda 	#$FF
.01936a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.01936b					BinaryOp_Add:
.01936b	b5 85		lda $85,x			lda 	XS_Type,x  					; and types together
.01936d	35 8b		and $8b,x			and 	XS2_Type,x
.01936f	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.019371	d0 11		bne $019384			bne 	_BOAString
.019373	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.019375	35 8b		and $8b,x			and 	XS2_Type,x
.019377	4a		lsr a				lsr 	a 							; shift bit 0 into C
.019378	90 03		bcc $01937d			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.01937a	4c ba 93	jmp $0193ba			jmp 	AddInteger32 							; so execute code at \1
.01937d					_BCFloat:
.01937d	20 ee 93	jsr $0193ee			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.019380	4c 2e 9f	jmp $019f2e			jmp 	FPAdd 							; and execute code at \2
.019383	60		rts				rts
.019384					_BOAString:
.019384	4c 08 94	jmp $019408			jmp 	ConcatenateString 			; concatenate two strings.
.019387					BinaryOp_Subtract:
.019387	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.019389	35 8b		and $8b,x			and 	XS2_Type,x
.01938b	4a		lsr a				lsr 	a 							; shift bit 0 into C
.01938c	90 03		bcc $019391			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.01938e	4c d4 93	jmp $0193d4			jmp 	SubInteger32 							; so execute code at \1
.019391					_BCFloat:
.019391	20 ee 93	jsr $0193ee			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.019394	4c 26 9f	jmp $019f26			jmp 	FPSubtract 							; and execute code at \2
.019397	60		rts				rts
.019398					BinaryOp_Multiply:
.019398	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.01939a	35 8b		and $8b,x			and 	XS2_Type,x
.01939c	4a		lsr a				lsr 	a 							; shift bit 0 into C
.01939d	90 03		bcc $0193a2			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.01939f	4c ff 9c	jmp $019cff			jmp 	MulInteger32 							; so execute code at \1
.0193a2					_BCFloat:
.0193a2	20 ee 93	jsr $0193ee			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.0193a5	4c 55 a0	jmp $01a055			jmp 	FPMultiply 							; and execute code at \2
.0193a8	60		rts				rts
.0193a9					BinaryOp_Divide:
.0193a9	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.0193ab	35 8b		and $8b,x			and 	XS2_Type,x
.0193ad	4a		lsr a				lsr 	a 							; shift bit 0 into C
.0193ae	90 03		bcc $0193b3			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.0193b0	4c 3d 9d	jmp $019d3d			jmp 	DivInteger32 							; so execute code at \1
.0193b3					_BCFloat:
.0193b3	20 ee 93	jsr $0193ee			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.0193b6	4c e2 9f	jmp $019fe2			jmp 	FPDivide 							; and execute code at \2
.0193b9	60		rts				rts
.0193ba					AddInteger32:
.0193ba	18		clc				clc
.0193bb	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0193bd	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.0193bf	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0193c1	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0193c3	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.0193c5	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0193c7	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0193c9	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.0193cb	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0193cd	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.0193cf	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.0193d1	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0193d3	60		rts				rts
.0193d4					SubInteger32:
.0193d4	38		sec				sec
.0193d5	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0193d7	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.0193d9	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0193db	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0193dd	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.0193df	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0193e1	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0193e3	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.0193e5	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0193e7	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.0193e9	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.0193eb	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0193ed	60		rts				rts
.0193ee					BinaryMakeBothFloat:
.0193ee	da		phx				phx 								; save X
.0193ef	e8		inx				inx
.0193f0	e8		inx				inx
.0193f1	e8		inx				inx
.0193f2	e8		inx				inx
.0193f3	e8		inx				inx
.0193f4	e8		inx				inx
.0193f5	20 f9 93	jsr $0193f9			jsr 	BinaryMakeFloat 			; convert to float.
.0193f8	fa		plx				plx 								; restore X and fall through.
.0193f9					BinaryMakeFloat:
.0193f9	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.0193fb	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.0193fc	b0 04		bcs $019402			bcs 	_BMFConvert
.0193fe	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.0193ff	b0 04		bcs $019405			bcs 	_BMFError
.019401	60		rts				rts
.019402					_BMFConvert:
.019402	4c 0e a2	jmp $01a20e			jmp 	FPUToFloat 					; convert to float
.019405					_BMFError:
.019405	4c 5a 85	jmp $01855a			jmp 	TypeError
.019408					ConcatenateString:
.019408	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.01940a	85 1a		sta $1a				sta		zLTemp1+0
.01940c	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01940e	85 1b		sta $1b				sta 	zLTemp1+1
.019410	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.019412	85 1c		sta $1c				sta 	zLTemp1+2
.019414	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.019416	85 1d		sta $1d				sta 	zLTemp1+3
.019418	5a		phy				phy
.019419	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.01941b	b1 1a		lda ($1a),y			lda 	(zlTemp1),y
.01941d	71 1c		adc ($1c),y			adc 	(zlTemp1+2),y
.01941f	7a		ply				ply
.019420	b0 33		bcs $019455			bcs 	_CSError					; check in range.
.019422	c9 fe		cmp #$fe			cmp 	#maxString+1
.019424	b0 2f		bcs $019455			bcs 	_CSError
.019426	20 9e 98	jsr $01989e			jsr 	AllocateTempString 			; store the result
.019429	20 40 94	jsr $019440			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.01942c	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.01942e	85 1a		sta $1a				sta 	zLTemp1
.019430	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.019432	85 1b		sta $1b				sta 	zLTemp1+1
.019434	20 40 94	jsr $019440			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.019437	a5 20		lda $20				lda 	zTempStr 					; point current to new string
.019439	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01943b	a5 21		lda $21				lda 	zTempStr+1
.01943d	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01943f	60		rts				rts
.019440					_CSCopyString:
.019440	da		phx				phx
.019441	5a		phy				phy
.019442	a0 00		ldy #$00			ldy 	#0 							; get length
.019444	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.019446	f0 0a		beq $019452			beq 	_CSCSExit 					; if zero, exit
.019448	aa		tax				tax 								; put in X
.019449					_CSCSLoop:
.019449	c8		iny				iny 								; get next char
.01944a	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.01944c	20 c9 98	jsr $0198c9			jsr		WriteTempString 			; copy out
.01944f	ca		dex				dex 								; do whole string
.019450	d0 f7		bne $019449			bne 	_CSCSLoop
.019452					_CSCSExit:
.019452	7a		ply				ply
.019453	fa		plx				plx
.019454	60		rts				rts
.019455					_CSError:
.019455	20 79 85	jsr $018579			jsr ERR_Handler
>019458	53 74 72 69 6e 67 20 74			.text "String too long",0
>019460	6f 6f 20 6c 6f 6e 67 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.019468					Unary_Sgn:
.019468	20 0e 92	jsr $01920e			jsr 	EvaluateNumberX 			; get value
.01946b	20 5e 98	jsr $01985e			jsr 	CheckNextRParen 			; check right bracket.
.01946e	20 8c 94	jsr $01948c			jsr 	GetSignCurrent 				; get sign.
.019471	09 00		ora #$00			ora 	#0
.019473	10 08		bpl $01947d			bpl		UnarySetAInteger			; if 0,1 return that.
.019475	80 00		bra $019477			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.019477					UnarySetAMinus1:
.019477	a9 ff		lda #$ff			lda 	#$FF
.019479	95 80		sta $80,x			sta 	XS_Mantissa,x
.01947b	80 04		bra $019481			bra 	UnarySetAFill
.01947d					UnarySetAInteger:
.01947d	95 80		sta $80,x			sta 	XS_Mantissa,x
.01947f	a9 00		lda #$00			lda 	#0
.019481					UnarySetAFill:
.019481	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019483	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019485	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019487	a9 01		lda #$01			lda 	#1
.019489	95 85		sta $85,x			sta 	XS_Type,x
.01948b	60		rts				rts
.01948c					GetSignCurrent:
.01948c	b5 85		lda $85,x			lda 	XS_Type,x 					; identify type.
.01948e	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.01948f	90 15		bcc $0194a6			bcc 	_GSCFloat
.019491	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019493	30 0e		bmi $0194a3			bmi 	_GSCMinus1
.019495	15 80		ora $80,x			ora 	XS_Mantissa+0,x
.019497	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019499	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01949b	d0 03		bne $0194a0			bne 	_GSCPlus1
.01949d					_GSCZero:
.01949d	a9 00		lda #$00			lda 	#0
.01949f	60		rts				rts
.0194a0					_GSCPlus1:
.0194a0	a9 01		lda #$01			lda 	#$01
.0194a2	60		rts				rts
.0194a3					_GSCMinus1:
.0194a3	a9 ff		lda #$ff			lda 	#$FF
.0194a5	60		rts				rts
.0194a6					_GSCFloat:
.0194a6	34 85		bit $85,x			bit 	XS_Type,x
.0194a8	70 f3		bvs $01949d			bvs 	_GSCZero
.0194aa	30 f7		bmi $0194a3			bmi 	_GSCMinus1
.0194ac	80 f2		bra $0194a0			bra 	_GSCPlus1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.0194ae					Unary_Abs:
.0194ae	20 0e 92	jsr $01920e			jsr 	EvaluateNumberX 			; get value
.0194b1	20 5e 98	jsr $01985e			jsr 	CheckNextRParen 			; check right bracket.
.0194b4	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.0194b6	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.0194b8	f0 07		beq $0194c1			beq 	_UAMinusFloat
.0194ba	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; check MSB
.0194bc	10 09		bpl $0194c7			bpl 	_UAExit
.0194be	4c c4 9d	jmp $019dc4			jmp 	IntegerNegateAlways 		; negation
.0194c1					_UAMinusFloat:
.0194c1	b5 85		lda $85,x			lda 	XS_Type,x 					; clear the sign bit.
.0194c3	29 7f		and #$7f			and		#$7F
.0194c5	95 85		sta $85,x			sta 	XS_Type,x
.0194c7					_UAExit:
.0194c7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.0194c8					Unary_Peek:
.0194c8	a9 01		lda #$01			lda 	#1
.0194ca	80 06		bra $0194d2			bra 	UPMain
.0194cc					Unary_Deek:
.0194cc	a9 02		lda #$02			lda 	#2
.0194ce	80 02		bra $0194d2			bra 	UPMain
.0194d0					Unary_Leek:
.0194d0	a9 04		lda #$04			lda 	#4
.0194d2					UPMain:
.0194d2	48		pha				pha 								; set bytes to copy.
.0194d3	20 1c 92	jsr $01921c			jsr 	EvaluateIntegerX 			; numeric parameter
.0194d6	20 5e 98	jsr $01985e			jsr 	CheckNextRParen 			; right bracket.
.0194d9	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.0194db	85 1a		sta $1a				sta 	zLTemp1
.0194dd	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0194df	85 1b		sta $1b				sta 	zLTemp1+1
.0194e1	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0194e3	85 1c		sta $1c				sta 	zLTemp1+2
.0194e5	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.0194e7	85 1d		sta $1d				sta 	zLTemp1+3
.0194e9	a9 00		lda #$00			lda 	#0 							; clear target area
.0194eb	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0194ed	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0194ef	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0194f1	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0194f3	68		pla				pla 								; restore bytes to copy
.0194f4	da		phx				phx 								; save XY
.0194f5	5a		phy				phy
.0194f6	20 e0 97	jsr $0197e0			jsr 	MemRead 					; read the bytes in
.0194f9	7a		ply				ply 								; restore and exit
.0194fa	fa		plx				plx
.0194fb	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/pos.asm

.0194fc					Unary_Pos:
.0194fc	20 0e 92	jsr $01920e			jsr 	EvaluateNumberX 			; get value
.0194ff	20 5e 98	jsr $01985e			jsr 	CheckNextRParen 			; check right bracket.
.019502	20 43 85	jsr $018543			jsr 	VIOCharGetPosition 			; get the position
.019505	4c 7d 94	jmp $01947d			jmp		UnarySetAInteger			; if 0,1 return that.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.019508					Unary_Mod:
.019508	20 30 95	jsr $019530			jsr 	_UMParameter 				; first parameter
.01950b	20 66 98	jsr $019866			jsr 	CheckNextComma
.01950e	da		phx				phx 								; second parameter
.01950f	e8		inx				inx
.019510	e8		inx				inx
.019511	e8		inx				inx
.019512	e8		inx				inx
.019513	e8		inx				inx
.019514	e8		inx				inx
.019515	20 30 95	jsr $019530			jsr 	_UMParameter
.019518	fa		plx				plx
.019519	20 5e 98	jsr $01985e			jsr 	CheckNextRParen
.01951c	20 3d 9d	jsr $019d3d			jsr 	DivInteger32 				; divide
.01951f	a5 1a		lda $1a				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.019521	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019523	a5 1b		lda $1b				lda 	zLTemp1+1
.019525	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019527	a5 1c		lda $1c				lda 	zLTemp1+2
.019529	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01952b	a5 1d		lda $1d				lda 	zLTemp1+3
.01952d	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01952f	60		rts				rts
.019530					_UMParameter:
.019530	20 1c 92	jsr $01921c			jsr 	EvaluateIntegerX 			; get value
.019533	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; absolute value
.019535	10 03		bpl $01953a			bpl 	_UMNotSigned
.019537	20 c4 9d	jsr $019dc4			jsr 	IntegerNegateAlways
.01953a					_UMNotSigned:
.01953a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.01953b					Unary_Usr:
.01953b	20 0e 92	jsr $01920e			jsr 	EvaluateNumberX 			; numeric parameter
.01953e	20 5e 98	jsr $01985e			jsr 	CheckNextRParen 			; right bracket.
.019541	da		phx				phx 								; save XY
.019542	5a		phy				phy
.019543	ea		nop				nop
.019544	22 0c 03 00	jsl $00030c			jsl 	UserVector
.019548	7a		ply				ply 								; and exit
.019549	fa		plx				plx
.01954a	60		rts				rts
.01954b					USRDefault:
.01954b	20 79 85	jsr $018579			jsr ERR_Handler
>01954e	4e 6f 20 55 53 52 20 76			.text "No USR vector.",0
>019556	65 63 74 6f 72 2e 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.01955d					Unary_Val:
.01955d	20 25 92	jsr $019225			jsr 	EvaluateStringX 			; get string
.019560	20 5e 98	jsr $01985e			jsr 	CheckNextRParen 			; check right bracket.
.019563	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.019565	85 1e		sta $1e				sta 	zGenPtr
.019567	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019569	85 1f		sta $1f				sta 	zGenPtr+1
.01956b	5a		phy				phy
.01956c	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.01956e	b1 1e		lda ($1e),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.019570	f0 54		beq $0195c6			beq 	_UVBadNumber
.019572	48		pha				pha 								; save length.
.019573	1a		inc a				inc 	a 							; one for the length, one for the terminator
.019574	1a		inc a				inc 	a
.019575	20 9e 98	jsr $01989e			jsr 	AllocateTempString
.019578	c8		iny				iny 								; move to the next.
.019579	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get character
.01957b	49 2d		eor #$2d			eor 	#"-"						; zero if minus sign
.01957d	8d a0 03	sta $03a0			sta 	ValSign
.019580	d0 04		bne $019586			bne 	_UVNotMinus
.019582	c8		iny				iny 								; skip over it.
.019583	68		pla				pla 								; decrement character count.
.019584	3a		dec a				dec 	a
.019585	48		pha				pha
.019586					_UVNotMinus:
.019586	68		pla				pla 								; this is the count.
.019587	48		pha		_UVCopy:pha									; copy into new temp string which is ASCIIZ
.019588	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.01958a	c8		iny				iny
.01958b	20 c9 98	jsr $0198c9			jsr 	WriteTempString
.01958e	68		pla				pla
.01958f	3a		dec a				dec 	a
.019590	d0 f5		bne $019587			bne 	_UVCopy
.019592	20 c9 98	jsr $0198c9			jsr 	WriteTempString 			; make it ASCIIZ
.019595	18		clc				clc
.019596	a5 20		lda $20				lda 	zTempStr 					; tempstring +1 => genptr
.019598	69 01		adc #$01			adc 	#1
.01959a	85 1e		sta $1e				sta 	zGenPtr
.01959c	a5 21		lda $21				lda 	zTempStr+1
.01959e	69 00		adc #$00			adc 	#0
.0195a0	85 1f		sta $1f				sta 	zGenPtr+1
.0195a2	18		clc				clc
.0195a3	20 96 9e	jsr $019e96			jsr 	IntFromString 				; first bit.
.0195a6	b0 1e		bcs $0195c6			bcs 	_UVBadNumber
.0195a8	20 14 a4	jsr $01a414			jsr 	FPFromString				; try for a float part.
.0195ab	ad a0 03	lda $03a0			lda 	ValSign 					; was it negative
.0195ae	d0 10		bne $0195c0			bne 	_UVNotNegative
.0195b0	b5 85		lda $85,x			lda 	XS_Type,x 					; check if integer
.0195b2	4a		lsr a				lsr 	a
.0195b3	b0 08		bcs $0195bd			bcs 	_UVInteger
.0195b5	b5 85		lda $85,x			lda 	XS_Type,x 					; set sign bit
.0195b7	09 80		ora #$80			ora 	#$80
.0195b9	95 85		sta $85,x			sta 	XS_Type,x
.0195bb	80 03		bra $0195c0			bra 	_UVNotNegative
.0195bd					_UVInteger:
.0195bd	20 c4 9d	jsr $019dc4			jsr 	IntegerNegateAlways 		; sign it.
.0195c0					_UVNotNegative:
.0195c0	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; used everything
.0195c2	d0 02		bne $0195c6			bne 	_UVBadNumber
.0195c4	7a		ply				ply
.0195c5	60		rts				rts
.0195c6					_UVBadNumber:
.0195c6	4c 68 85	jmp $018568			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.0195c9					Unary_Str:
.0195c9	20 0e 92	jsr $01920e			jsr 	EvaluateNumberX 			; numeric parameter
.0195cc	20 5e 98	jsr $01985e			jsr 	CheckNextRParen 			; right bracket.
.0195cf	a9 00		lda #$00			lda 	#0 							; reset buffer index
.0195d1	8d 14 03	sta $0314			sta 	NumBufX
.0195d4	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.0195d6	4a		lsr a				lsr 	a
.0195d7	b0 05		bcs $0195de			bcs 	_USInt 						; if msb set do as integer
.0195d9	20 59 a3	jsr $01a359			jsr 	FPToString 					; call fp to str otherwise
.0195dc	80 03		bra $0195e1			bra 	_USDuplicate
.0195de	20 e1 9d	jsr $019de1	_USInt:	jsr 	IntToString
.0195e1					_USDuplicate:
.0195e1	ad 14 03	lda $0314			lda 	NumBufX 					; chars in buffer
.0195e4	1a		inc a				inc 	a 							; one more for length
.0195e5	20 9e 98	jsr $01989e			jsr 	AllocateTempString 			; allocate space for it.
.0195e8	5a		phy				phy 								; save Y
.0195e9	a0 00		ldy #$00			ldy 	#0 							; start copying
.0195eb	b9 15 03	lda $0315,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.0195ee	20 c9 98	jsr $0198c9			jsr 	WriteTempString
.0195f1	c8		iny				iny
.0195f2	cc 14 03	cpy $0314			cpy 	NumBufX 					; done the lot
.0195f5	d0 f4		bne $0195eb			bne 	_USCopy
.0195f7	7a		ply				ply 								; restore Y
.0195f8	4c d3 97	jmp $0197d3			jmp 	UnaryReturnTempStr 			; return new temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.0195fb					Unary_Asc:
.0195fb	20 25 92	jsr $019225			jsr 	EvaluateStringX 			; string parameter
.0195fe	20 5e 98	jsr $01985e			jsr 	CheckNextRParen 			; right bracket.
.019601	5a		phy				phy 								; get the string length
.019602	a0 00		ldy #$00			ldy 	#0
.019604	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.019606	f0 07		beq $01960f			beq 	_UAIllegal 					; must be at least one character
.019608	c8		iny				iny
.019609	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; read it.
.01960b	7a		ply				ply
.01960c	4c 7d 94	jmp $01947d			jmp 	UnarySetAInteger
.01960f					_UAIllegal:
.01960f	4c 68 85	jmp $018568			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.019612					Unary_Len:
.019612	20 25 92	jsr $019225			jsr 	EvaluateStringX 			; string parameter
.019615	20 5e 98	jsr $01985e			jsr 	CheckNextRParen 			; right bracket.
.019618	5a		phy				phy 								; get the string length
.019619	a0 00		ldy #$00			ldy 	#0
.01961b	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.01961d	7a		ply				ply
.01961e	4c 7d 94	jmp $01947d			jmp 	UnarySetAInteger

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.019621					Unary_Mid:
.019621	20 25 92	jsr $019225			jsr 	EvaluateStringX 				; get string.
.019624	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.019626	48		pha				pha
.019627	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019629	48		pha				pha
.01962a	20 66 98	jsr $019866			jsr 	CheckNextComma 					; skip comma
.01962d	20 b6 96	jsr $0196b6			jsr 	SLIByteParameter 				; get a byte parameter (start)
.019630	48		pha				pha 									; and push it.
.019631	20 66 98	jsr $019866			jsr 	CheckNextComma 					; skip comma
.019634	20 b6 96	jsr $0196b6			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.019637	48		pha				pha 									; and push it.
.019638	80 41		bra $01967b			bra 	SLIProcess
.01963a					Unary_Left:
.01963a	20 25 92	jsr $019225			jsr 	EvaluateStringX 				; get string.
.01963d	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.01963f	48		pha				pha
.019640	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019642	48		pha				pha
.019643	a9 01		lda #$01			lda 	#1 								; push start position (1)
.019645	48		pha				pha
.019646	20 66 98	jsr $019866			jsr 	CheckNextComma 					; skip comma
.019649	20 b6 96	jsr $0196b6			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.01964c	48		pha				pha 									; and push it.
.01964d	80 2c		bra $01967b			bra 	SLIProcess
.01964f					Unary_Right:
.01964f	20 25 92	jsr $019225			jsr 	EvaluateStringX 				; get string.
.019652	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.019654	48		pha				pha
.019655	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019657	48		pha				pha
.019658	da		phx				phx 									; get the string length and push on stack.
.019659	a2 00		ldx #$00			ldx 	#0
.01965b	a1 1e		lda ($1e,x)			lda		(zGenPtr,x)
.01965d	fa		plx				plx
.01965e	48		pha				pha
.01965f	20 66 98	jsr $019866			jsr 	CheckNextComma 					; skip comma
.019662	20 b6 96	jsr $0196b6			jsr 	SLIByteParameter 				; get a byte parameter.
.019665	8d 9e 03	sta $039e			sta 	SignCount 						; save in temporary.
.019668	68		pla				pla 									; restore string length.
.019669	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.01966a	38		sec				sec
.01966b	ed 9e 03	sbc $039e			sbc 	SignCount 						; subtract characters needed, gives start position.
.01966e	f0 02		beq $019672			beq 	_URStart 						; if <= 0 start from 1.
.019670	10 02		bpl $019674			bpl 	_UROkay
.019672					_URStart:
.019672	a9 01		lda #$01			lda 	#1
.019674					_UROkay:
.019674	48		pha				pha 									; push start
.019675	ad 9e 03	lda $039e			lda 	SignCount 						; push count of characters
.019678	48		pha				pha
.019679	80 00		bra $01967b			bra 	SLIProcess
.01967b					SLIProcess:
.01967b	20 5e 98	jsr $01985e			jsr 	CheckNextRParen 				; closing right bracket.
.01967e	68		pla				pla
.01967f	8d a2 03	sta $03a2			sta 	SliceCount 						; count in signcount
.019682	1a		inc a				inc 	a 								; allocate +1 for it.
.019683	20 9e 98	jsr $01989e			jsr 	AllocateTempString
.019686	68		pla				pla 									; pop start number off stack.
.019687	f0 3b		beq $0196c4			beq 	SLIError 						; exit if start = 0
.019689	8d a1 03	sta $03a1			sta 	SliceStart
.01968c	68		pla				pla  									; pop string address.
.01968d	85 1f		sta $1f				sta 	zGenPtr+1
.01968f	68		pla				pla
.019690	85 1e		sta $1e				sta 	zGenPtr
.019692	da		phx				phx
.019693	5a		phy				phy
.019694	a2 00		ldx #$00			ldx 	#0 								; point to string length.
.019696	ac a1 03	ldy $03a1			ldy 	SliceStart 						; start of the string (+1 for count)
.019699					_SLICopy:
.019699	ad a2 03	lda $03a2			lda 	SliceCount 						; done count characters
.01969c	f0 12		beq $0196b0			beq 	_SLIExit
.01969e	ce a2 03	dec $03a2			dec 	SliceCount
.0196a1	98		tya				tya 									; index of character
.0196a2	c1 1e		cmp ($1e,x)			cmp 	(zGenPtr,x)						; compare against length
.0196a4	f0 02		beq $0196a8			beq 	_SLIOk 							; if equal, okay.
.0196a6	b0 08		bcs $0196b0			bcs 	_SLIExit 						; if past end, then exit.
.0196a8	b1 1e		lda ($1e),y	_SLIOk:	lda 	(zGenPtr),y 					; copy one character
.0196aa	c8		iny				iny
.0196ab	20 c9 98	jsr $0198c9			jsr 	WriteTempString
.0196ae	80 e9		bra $019699			bra 	_SLICopy 						; go round till copied characters
.0196b0					_SLIExit:
.0196b0	7a		ply				ply 									; restore YX
.0196b1	fa		plx				plx
.0196b2	4c d3 97	jmp $0197d3			jmp 	UnaryReturnTempStr 				; return new temporary string.
.0196b5	ea		nop				nop
.0196b6					SLIByteParameter:
.0196b6	20 1c 92	jsr $01921c			jsr 	EvaluateIntegerX 				; get integer
.0196b9	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.0196bb	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.0196bd	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.0196bf	d0 03		bne $0196c4			bne 	SLIError
.0196c1	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0196c3	60		rts				rts
.0196c4					SLIError:
.0196c4	4c 68 85	jmp $018568			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.0196c7					Unary_Hex:
.0196c7	20 1c 92	jsr $01921c			jsr 	EvaluateIntegerX 			; numeric parameter
.0196ca	20 5e 98	jsr $01985e			jsr 	CheckNextRParen 			; right bracket.
.0196cd	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.0196cf	20 9e 98	jsr $01989e			jsr 	AllocateTempString			; allocate string space
.0196d2	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.0196d4	20 f8 96	jsr $0196f8			jsr 	_UHConvert
.0196d7	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0196d9	20 f8 96	jsr $0196f8			jsr 	_UHConvert
.0196dc	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0196de	20 f8 96	jsr $0196f8			jsr 	_UHConvert
.0196e1	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0196e3	20 f8 96	jsr $0196f8			jsr 	_UHConvert
.0196e6	5a		phy				phy 								; get length of new string
.0196e7	a0 00		ldy #$00			ldy 	#0
.0196e9	b1 20		lda ($20),y			lda 	(zTempStr),y
.0196eb	7a		ply				ply
.0196ec	c9 00		cmp #$00			cmp 	#0
.0196ee	d0 05		bne $0196f5			bne 	_UHExit 					; if it was non zero okay
.0196f0	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.0196f2	20 c9 98	jsr $0198c9			jsr 	WriteTempString
.0196f5					_UHExit:
.0196f5	4c d3 97	jmp $0197d3			jmp 	UnaryReturnTempStr 			; return new temporary string.
.0196f8					_UHConvert:
.0196f8	48		pha				pha
.0196f9	4a		lsr a				lsr 	a 							; do MSB
.0196fa	4a		lsr a				lsr 	a
.0196fb	4a		lsr a				lsr 	a
.0196fc	4a		lsr a				lsr 	a
.0196fd	20 01 97	jsr $019701			jsr 	_UHNibble
.019700	68		pla				pla 								; do LSB
.019701					_UHNibble:
.019701	29 0f		and #$0f			and 	#15 						; get nibble
.019703	d0 0c		bne $019711			bne 	_UHNonZero
.019705	5a		phy				phy									; get the length
.019706	a0 00		ldy #$00			ldy 	#0
.019708	b1 20		lda ($20),y			lda 	(zTempStr),y
.01970a	7a		ply				ply
.01970b	c9 00		cmp #$00			cmp 	#0 							; suppress leading zeros.
.01970d	f0 0d		beq $01971c			beq 	_UHExit2
.01970f	a9 00		lda #$00			lda 	#0
.019711					_UHNonZero:
.019711	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.019713	90 02		bcc $019717			bcc 	_UHDigit
.019715	69 06		adc #$06			adc 	#7-1
.019717					_UHDigit:
.019717	69 30		adc #$30			adc 	#48
.019719	20 c9 98	jsr $0198c9			jsr 	WriteTempString				; output.
.01971c					_UHExit2:
.01971c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.01971d					Unary_Dec:
.01971d	20 25 92	jsr $019225			jsr 	EvaluateStringX 			; string parameter
.019720	20 5e 98	jsr $01985e			jsr 	CheckNextRParen 			; right bracket.
.019723	5a		phy				phy
.019724	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.019726	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.019728	f0 41		beq $01976b			beq 	_UDFail 					; must fail if zero.
.01972a	8d 9e 03	sta $039e			sta 	SignCount 					; use SignCount as a counter
.01972d	a9 00		lda #$00			lda 	#0 							; set result to zero integer.
.01972f	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019731	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019733	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019735	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019737	a9 01		lda #$01			lda 	#1
.019739	95 85		sta $85,x			sta 	XS_Type,x
.01973b					_UDConvertLoop:
.01973b	5a		phy				phy 								; shift mantissa left 4
.01973c	a0 04		ldy #$04			ldy 	#4
.01973e					_UDShift:
.01973e	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.019740	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.019742	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.019744	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.019746	88		dey				dey
.019747	d0 f5		bne $01973e			bne 	_UDShift
.019749	7a		ply				ply
.01974a	c8		iny				iny 								; next character
.01974b	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; fetch it.
.01974d	20 6e 97	jsr $01976e			jsr 	ConvertUpper 				; convert to U/C
.019750	c9 30		cmp #$30			cmp 	#"0"
.019752	90 17		bcc $01976b			bcc 	_UDFail
.019754	c9 3a		cmp #$3a			cmp 	#"9"+1
.019756	90 06		bcc $01975e			bcc 	_UDOkay
.019758	e9 37		sbc #$37			sbc 	#7+"0" 						; alpha fudge
.01975a	c9 10		cmp #$10			cmp 	#16
.01975c	b0 0d		bcs $01976b			bcs 	_UDFail
.01975e					_UDOkay:
.01975e	29 0f		and #$0f			and 	#15 						; nibble only
.019760	15 80		ora $80,x			ora 	XS_Mantissa+0,x
.019762	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019764	ce 9e 03	dec $039e			dec 	SignCount 					; do it for each character
.019767	d0 d2		bne $01973b			bne 	_UDConvertLoop
.019769	7a		ply				ply
.01976a	60		rts				rts
.01976b					_UDFail:
.01976b	4c 68 85	jmp $018568			jmp 	BadParamError
.01976e					ConvertUpper:
.01976e	c9 61		cmp #$61			cmp 	#"a"
.019770	90 07		bcc $019779			bcc 	_CUExit
.019772	c9 7b		cmp #$7b			cmp 	#"z"+1
.019774	b0 03		bcs $019779			bcs 	_CUExit
.019776	38		sec				sec
.019777	e9 20		sbc #$20			sbc 	#32
.019779	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.01977a					Unary_Chr:
.01977a	20 1c 92	jsr $01921c			jsr 	EvaluateIntegerX			; numeric parameter
.01977d	20 5e 98	jsr $01985e			jsr 	CheckNextRParen 			; right bracket.
.019780	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.019782	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019784	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019786	d0 0d		bne $019795			bne 	_UCChar
.019788	a9 01		lda #$01			lda 	#1 							; one character string
.01978a	20 9e 98	jsr $01989e			jsr 	AllocateTempString
.01978d	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.01978f	20 c9 98	jsr $0198c9			jsr 	WriteTempString
.019792	4c d3 97	jmp $0197d3			jmp 	UnaryReturnTempStr
.019795					_UCChar:
.019795	4c 68 85	jmp $018568			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.019798					Unary_Spc:
.019798	20 b6 96	jsr $0196b6			jsr 	SLIByteParameter 			; check space.
.01979b	20 5e 98	jsr $01985e			jsr 	CheckNextRParen
.01979e	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0197a0					UnarySpcCreate:
.0197a0	c9 fe		cmp #$fe			cmp 	#maxString+1
.0197a2	b0 14		bcs $0197b8			bcs 	_USSize
.0197a4	48		pha				pha 								; save length
.0197a5	1a		inc a				inc 	a 							; allocate one more.
.0197a6	20 9e 98	jsr $01989e			jsr 	AllocateTempString
.0197a9	68		pla				pla 								; get length
.0197aa	f0 27		beq $0197d3			beq 	UnaryReturnTempStr 			; return the current temp string
.0197ac					_USLoop:
.0197ac	48		pha				pha
.0197ad	a9 20		lda #$20			lda 	#" "
.0197af	20 c9 98	jsr $0198c9			jsr 	WriteTempString
.0197b2	68		pla				pla
.0197b3	3a		dec a				dec 	a
.0197b4	d0 f6		bne $0197ac			bne 	_USLoop
.0197b6	80 1b		bra $0197d3			bra 	UnaryReturnTempStr
.0197b8					_USSize:
.0197b8	4c 68 85	jmp $018568			jmp 	BadParamError
.0197bb					Unary_Tab:
.0197bb	a2 00		ldx #$00			ldx 	#0 							; required TAB position.
.0197bd	20 b6 96	jsr $0196b6			jsr 	SLIByteParameter
.0197c0	20 5e 98	jsr $01985e			jsr 	CheckNextRParen
.0197c3	20 43 85	jsr $018543			jsr 	VIOCharGetPosition 			; were are we ?
.0197c6	85 10		sta $10				sta 	zTemp1
.0197c8	38		sec				sec
.0197c9	a5 80		lda $80				lda 	XS_Mantissa+0 				; return chars required.
.0197cb	e5 10		sbc $10				sbc 	zTemp1
.0197cd	b0 d1		bcs $0197a0			bcs 	UnarySpcCreate
.0197cf	a9 00		lda #$00			lda 	#0
.0197d1	80 cd		bra $0197a0			bra 	UnarySpcCreate
.0197d3					UnaryReturnTempStr:
.0197d3	a5 20		lda $20				lda 	zTempStr 					; copy temp string addr -> mantissa
.0197d5	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0197d7	a5 21		lda $21				lda 	zTempStr+1
.0197d9	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0197db	a9 02		lda #$02			lda 	#2 							; set type to string
.0197dd	95 85		sta $85,x			sta 	XS_Type,x
.0197df	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/65816.asm

.0197e0					MemRead:
.0197e0	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.0197e3	a0 00		ldy #$00			ldy 	#0 							; start from here
.0197e5	b7 1a		lda [$1a],y	_MLoop1:lda 	[zlTemp1],y 				; read the long address
.0197e7	95 80		sta $80,x			sta 	XS_Mantissa,x 				; copy into mantissa
.0197e9	c8		iny				iny 								; next to copy
.0197ea	e8		inx				inx
.0197eb	cc 9e 03	cpy $039e			cpy 	SignCount 					; do required # of bytes.
.0197ee	d0 f5		bne $0197e5			bne 	_MLoop1
.0197f0	60		rts				rts
.0197f1					MemWrite:
.0197f1	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.0197f4	a0 00		ldy #$00			ldy 	#0 							; start from here
.0197f6	b5 80		lda $80,x	_MLoop1:lda 	XS_Mantissa,x 				; read mantisssa
.0197f8	97 1a		sta [$1a],y			sta 	[zlTemp1],y 				; write it out
.0197fa	c8		iny				iny 								; next to copy
.0197fb	e8		inx				inx
.0197fc	cc 9e 03	cpy $039e			cpy 	SignCount 					; do required # of bytes.
.0197ff	d0 f5		bne $0197f6			bne 	_MLoop1
.019801	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/programend.asm

.019802					UpdateProgramEnd:
.019802	a9 00		lda #$00			lda 	#BasicProgram & $FF
.019804	85 16		sta $16				sta 	zCodePtr+0
.019806	a9 10		lda #$10			lda 	#BasicProgram >> 8
.019808	85 17		sta $17				sta 	zCodePtr+1
.01980a	a9 00		lda #$00			lda 	#0
.01980c	85 18		sta $18				sta 	zCodePtr+2
.01980e	85 19		sta $19				sta 	zCodePtr+3
.019810	a0 03		ldy #$03			ldy 	#3
.019812					_UPDLoop:
.019812	a0 00		ldy #$00			ldy 	#0
.019814	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019816	c9 00		cmp #$00			cmp 	#0 							; end if offset is zero.
.019818	f0 0f		beq $019829			beq 	_UPDFoundEnd
.01981a	a0 00		ldy #$00			ldy 	#0 							; point to offset
.01981c	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.01981e	18		clc				clc
.01981f	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.019821	85 16		sta $16				sta 	zCodePtr
.019823	90 02		bcc $019827			bcc 	_SNLNoCarry
.019825	e6 17		inc $17				inc 	zCodePtr+1
.019827					_SNLNoCarry:
.019827	80 e9		bra $019812			bra 	_UPDLoop
.019829					_UPDFoundEnd:
.019829	18		clc				clc 								; end of program 2 on.
.01982a	a5 16		lda $16				lda 	zCodePtr
.01982c	69 02		adc #$02			adc 	#2
.01982e	8d 04 03	sta $0304			sta 	endOfProgram
.019831	a5 17		lda $17				lda 	zCodePtr+1
.019833	69 00		adc #$00			adc 	#0
.019835	8d 05 03	sta $0305			sta 	endOfProgram+1
.019838	a5 18		lda $18				lda 	zCodePtr+2
.01983a	69 00		adc #$00			adc		#0
.01983c	8d 06 03	sta $0306			sta 	endOfProgram+2
.01983f	a5 19		lda $19				lda 	zCodePtr+3
.019841	69 00		adc #$00			adc 	#0
.019843	8d 07 03	sta $0307			sta 	endOfProgram+3
.019846	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.019847					CheckNextToken:
.019847	d7 16		cmp [$16],y			cmp 	[zCodePtr],y
.019849	d0 02		bne $01984d			bne 	CTFail 						; no, then fail
.01984b	c8		iny				iny
.01984c	60		rts				rts
.01984d					CTFail:
.01984d	20 79 85	jsr $018579			jsr ERR_Handler
>019850	4d 69 73 73 69 6e 67 20			.text "Missing token",0
>019858	74 6f 6b 65 6e 00
.01985e					CheckNextRParen:
.01985e	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019860	c9 be		cmp #$be			cmp 	#token_rparen
.019862	d0 e9		bne $01984d			bne 	CTFail
.019864	c8		iny				iny
.019865	60		rts				rts
.019866					CheckNextComma:
.019866	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019868	c9 bf		cmp #$bf			cmp 	#token_comma
.01986a	d0 e1		bne $01984d			bne 	CTFail
.01986c	c8		iny				iny
.01986d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/concrete.asm

.01986e					StringConcrete:
.01986e	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; save source to zTemp1
.019870	85 10		sta $10				sta 	zTemp1
.019872	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019874	85 11		sta $11				sta 	zTemp1+1
.019876	a0 00		ldy #$00			ldy 	#0 							; subtract the length+1 (clc) of the string.
.019878	18		clc				clc 								; from the string pointer
.019879	ad 00 03	lda $0300			lda 	StringPtr 					; and put in zTemp2 as well
.01987c	f1 10		sbc ($10),y			sbc 	(zTemp1),y
.01987e	8d 00 03	sta $0300			sta 	StringPtr
.019881	85 12		sta $12				sta 	zTemp2
.019883	ad 01 03	lda $0301			lda 	StringPtr+1
.019886	e9 00		sbc #$00			sbc 	#0
.019888	8d 01 03	sta $0301			sta 	StringPtr+1
.01988b	85 13		sta $13				sta 	zTemp2+1
.01988d	b1 10		lda ($10),y			lda 	(zTemp1),y 					; length add one for count
.01988f	1a		inc a				inc 	a
.019890	aa		tax				tax
.019891	b1 10		lda ($10),y	_SCCopy:lda 	(zTemp1),y 					; copy whole thing including length
.019893	91 12		sta ($12),y			sta 	(zTemp2),y
.019895	c8		iny				iny
.019896	ca		dex				dex
.019897	d0 f8		bne $019891			bne 	_SCCopy
.019899	a5 13		lda $13				lda 	zTemp2+1 					; return concrete string in AX
.01989b	a6 12		ldx $12				ldx 	zTemp2
.01989d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.01989e					AllocateTempString:
.01989e	48		pha				pha 								; save required count.
.01989f	a5 21		lda $21				lda 	zTempStr+1 					; check if initialised yet ?
.0198a1	d0 0b		bne $0198ae			bne 	_ATSInitialised
.0198a3	ad 00 03	lda $0300			lda 	StringPtr 					; set temporary string ptr 1 page below available
.0198a6	85 20		sta $20				sta 	zTempStr					; space, this is for strings to be concreted.
.0198a8	ad 01 03	lda $0301			lda 	StringPtr+1
.0198ab	3a		dec a				dec 	a
.0198ac	85 21		sta $21				sta 	zTempStr+1
.0198ae					_ATSInitialised:
.0198ae	68		pla				pla 								; get required count back.
.0198af	49 ff		eor #$ff			eor 	#$FF 						; negate 2's complement.
.0198b1	1a		inc a				inc 	a
.0198b2	18		clc				clc
.0198b3	65 20		adc $20				adc 	zTempStr 					; "add" to the temp string pointer
.0198b5	85 20		sta $20				sta 	zTempStr
.0198b7	a9 ff		lda #$ff			lda 	#$FF
.0198b9	65 21		adc $21				adc 	zTempStr+1
.0198bb	85 21		sta $21				sta 	zTempStr+1
.0198bd	a9 00		lda #$00			lda 	#0 							; clear temp string.
.0198bf	5a		phy				phy
.0198c0	a8		tay				tay
.0198c1	91 20		sta ($20),y			sta 	(zTempStr),y
.0198c3	7a		ply				ply
.0198c4	1a		inc a				inc 	a 							; reset the write index.
.0198c5	8d 9f 03	sta $039f			sta 	TempStringWriteIndex
.0198c8	60		rts				rts
.0198c9					WriteTempString:
.0198c9	5a		phy				phy 								; save Y
.0198ca	ac 9f 03	ldy $039f			ldy 	TempStringWriteIndex	 	; write position.
.0198cd	91 20		sta ($20),y			sta 	(zTempStr),y 				; write character out.
.0198cf	ee 9f 03	inc $039f			inc 	TempStringWriteIndex 		; increment the write position.
.0198d2	98		tya				tya 								; unchanged Y is now length
.0198d3	a0 00		ldy #$00			ldy 	#0
.0198d5	91 20		sta ($20),y			sta 	(zTempStr),y
.0198d7	7a		ply				ply 								; restore Y and exit
.0198d8	60		rts				rts
.0198d9					CreateTempStringCopy:
.0198d9	da		phx				phx 								; save X
.0198da	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0198dc	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.0198dd	20 9e 98	jsr $01989e			jsr 	AllocateTempString 			; allocate memory for temporary string.
.0198e0	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0198e2	c8		iny				iny
.0198e3	3a		dec a				dec 	a 							; make the actual length in charactes
.0198e4	3a		dec a				dec 	a
.0198e5	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.0198e7	81 20		sta ($20,x)			sta 	(zTempStr,x)
.0198e9	85 1a		sta $1a				sta 	zLTemp1 					; that's used as a count.
.0198eb	09 00		ora #$00			ora 	#0 							; if zero already, exit
.0198ed	f0 0e		beq $0198fd			beq 	_CTSCExit
.0198ef					_CTSCLoop:
.0198ef	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0198f1	c8		iny				iny
.0198f2	5a		phy				phy 								; save in Y
.0198f3	e8		inx				inx 								; bump index
.0198f4	da		phx				phx 								; index into Y
.0198f5	7a		ply				ply
.0198f6	91 20		sta ($20),y			sta 	(zTempStr),y 				; save at index
.0198f8	7a		ply				ply 								; restore Y
.0198f9	c6 1a		dec $1a				dec 	zLTemp1 					; do for each character
.0198fb	d0 f2		bne $0198ef			bne 	_CTSCLoop
.0198fd					_CTSCExit:
.0198fd	fa		plx				plx 								; restore X
.0198fe	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/variables.asm

.0198ff					VariableFind:
.0198ff	20 6a 99	jsr $01996a			jsr 	VariableExtract 		; find out all about it ....
.019902	20 03 9c	jsr $019c03			jsr 	VariableLocate 			; does it already exist ?
.019905	b0 03		bcs $01990a			bcs 	_VFExists 				; if so, use that.
.019907	20 f6 99	jsr $0199f6			jsr 	VariableCreate 			; otherwise create it.
.01990a					_VFExists:
.01990a	a5 24		lda $24				lda 	zVarType 				; is it still an array ?
.01990c	29 01		and #$01			and 	#1
.01990e	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.019910	d0 28		bne $01993a			bne 	_VFSingleElement
.019912					_VFNextIndex:
.019912	a5 22		lda $22				lda 	zVarDataPtr 			; push the data ptr and type on the stack.
.019914	48		pha				pha
.019915	a5 23		lda $23				lda 	zVarDataPtr+1
.019917	48		pha				pha
.019918	a5 24		lda $24				lda 	zVarType
.01991a	48		pha				pha
.01991b	20 1c 92	jsr $01921c			jsr 	EvaluateIntegerX 		; calculate the index.
.01991e	68		pla				pla 							; restore and index.
.01991f	85 24		sta $24				sta 	zVarType
.019921	68		pla				pla
.019922	85 23		sta $23				sta 	zVarDataPtr+1
.019924	68		pla				pla
.019925	85 22		sta $22				sta 	zVarDataPtr
.019927	20 81 9a	jsr $019a81			jsr 	ArrayIndexFollow 		; do the index.
.01992a	a5 24		lda $24				lda 	zVarType 				; is it still an array ??
.01992c	29 01		and #$01			and 	#1
.01992e	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.019930	d0 05		bne $019937			bne 	_VFArrayDone 			; if so then exit.
.019932	20 66 98	jsr $019866			jsr 	CheckNextComma 			; comma should follow
.019935	80 db		bra $019912			bra 	_VFNextIndex
.019937					_VFArrayDone:
.019937	20 5e 98	jsr $01985e			jsr 	CheckNextRParen 		; check closing right bracket.
.01993a					_VFSingleElement:
.01993a	60		rts				rts
.01993b					VariableClear:
.01993b	48		pha				pha 							; save registers
.01993c	da		phx				phx
.01993d	a2 00		ldx #$00			ldx 	#0 						; clear out the hash table.
.01993f	8a		txa				txa
.019940	9d 35 03	sta $0335,x	_VCLoop:sta 	HashTableBase,x
.019943	e8		inx				inx
.019944	e0 60		cpx #$60			cpx 	#HashTableEnd-HashTableBase
.019946	d0 f8		bne $019940			bne 	_VCLoop
.019948	a9 00		lda #$00			lda 	#VariableMemory & $FF
.01994a	8d 02 03	sta $0302			sta 	VarMemPtr
.01994d	a9 30		lda #$30			lda 	#VariableMemory >> 8
.01994f	8d 03 03	sta $0303			sta 	VarMemPtr+1
.019952	fa		plx				plx 							; restore registers
.019953	68		pla				pla
.019954	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/extract.asm

.019955					VariableNameError:
.019955	20 79 85	jsr $018579			jsr ERR_Handler
>019958	42 61 64 20 56 61 72 69			.text "Bad Variable Name",0
>019960	61 62 6c 65 20 4e 61 6d 65 00
.01996a					VariableExtract:
.01996a	da		phx				phx 							; save X.
.01996b	a9 ba		lda #$ba			lda 	#token_hashlParen  		; set the type to #( e.g. real array.
.01996d	8d 95 03	sta $0395			sta 	Var_Type
.019970	8d 96 03	sta $0396			sta 	Var_Hash 				; we initialise the hash with this. It doesn't matter
.019973	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019975	c9 00		cmp #$00			cmp 	#0 						; first one must be A-Z
.019977	f0 dc		beq $019955			beq 	VariableNameError
.019979	c9 1b		cmp #$1b			cmp 	#26+1
.01997b	b0 d8		bcs $019955			bcs 	VariableNameError
.01997d	a2 ff		ldx #$ff			ldx 	#255 					; now copy it into the variable buffer.
.01997f					_VECopyBuffer:
.01997f	e8		inx				inx
.019980	e0 1f		cpx #$1f			cpx 	#31 					; too long
.019982	f0 d1		beq $019955			beq 	VariableNameError
.019984	9d 15 03	sta $0315,x			sta 	Var_Buffer,x 			; save character
.019987	18		clc				clc  							; update the hash value for it.
.019988	6d 96 03	adc $0396			adc 	Var_Hash
.01998b	8d 96 03	sta $0396			sta 	Var_Hash
.01998e	c8		iny				iny
.01998f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019991	c9 00		cmp #$00			cmp 	#0 						; zero or token, end of variable
.019993	f0 0e		beq $0199a3			beq 	_VECopyEnd
.019995	30 0c		bmi $0199a3			bmi 	_VECopyEnd
.019997	c9 1b		cmp #$1b			cmp 	#26+1 					; A-Z continue copying
.019999	90 e4		bcc $01997f			bcc 	_VECopyBuffer
.01999b	c9 30		cmp #$30			cmp 	#"0" 					; 0-9 copy as well.
.01999d	90 04		bcc $0199a3			bcc 	_VECopyEnd
.01999f	c9 3a		cmp #$3a			cmp 	#"9"+1
.0199a1	90 dc		bcc $01997f			bcc 	_VECopyBuffer
.0199a3					_VECopyEnd:
.0199a3	c8		iny				iny
.0199a4	c9 b7		cmp #$b7			cmp 	#token_Dollar 			; first type token.
.0199a6	90 04		bcc $0199ac			bcc 	_VEDefaultRequired
.0199a8	c9 bd		cmp #$bd			cmp 	#token_PercentLParen+1	; last type token.
.0199aa	90 0b		bcc $0199b7			bcc 	_VEHaveType
.0199ac					_VEDefaultRequired:
.0199ac	c9 bd		cmp #$bd			cmp 	#token_LParen 			; if it ends in ( then use the real array
.0199ae	f0 04		beq $0199b4			beq 	_VESetType 				; default set above.
.0199b0	ce 95 03	dec $0395			dec 	Var_Type 				; this changes that default to the variable default
.0199b3	88		dey				dey
.0199b4					_VESetType:
.0199b4	ad 95 03	lda $0395			lda 	Var_Type 				; get type ....
.0199b7					_VEHaveType:
.0199b7	8d 95 03	sta $0395			sta 	Var_Type 				; save as type.
.0199ba	bd 15 03	lda $0315,x			lda 	Var_Buffer,x 			; set bit 7 of name, marks the end.
.0199bd	09 80		ora #$80			ora 	#$80
.0199bf	9d 15 03	sta $0315,x			sta 	Var_Buffer,x
.0199c2	e8		inx				inx 							; offset 3 => length 4.
.0199c3	8e 97 03	stx $0397			stx 	Var_Length 				; save length of variable name.
.0199c6	ad 95 03	lda $0395			lda 	Var_Type 				; get offset of var type from first type token
.0199c9	38		sec				sec
.0199ca	e9 b7		sbc #$b7			sbc 	#token_Dollar
.0199cc	0a		asl a				asl 	a 						; multiply by 16. This requires HashTableSize
.0199cd	0a		asl a				asl 	a 						; in data.asm to be 8 (8 sets of links,2 bytes each)
.0199ce	0a		asl a				asl 	a
.0199cf	0a		asl a				asl 	a
.0199d0	8d 98 03	sta $0398			sta 	Var_HashAddress
.0199d3	ad 96 03	lda $0396			lda 	Var_Hash 				; get the hash
.0199d6	29 07		and #$07			and 	#(HashTableSize-1) 		; force into range 0-tableSize-1
.0199d8	0a		asl a				asl 	a 						; double it (2 bytes per entry) & clears carry
.0199d9	6d 98 03	adc $0398			adc 	Var_HashAddress 		; add table offset.
.0199dc	69 35		adc #$35			adc 	#HashTableBase & $FF 	; now the low byte of the actual table address
.0199de	8d 98 03	sta $0398			sta 	Var_HashAddress
.0199e1	a2 05		ldx #$05			ldx 	#5 						; hash is 5 bytes (real)
.0199e3	ad 95 03	lda $0395			lda 	Var_Type
.0199e6	c9 b9		cmp #$b9			cmp 	#token_Hash
.0199e8	f0 07		beq $0199f1			beq 	_VEHaveSize
.0199ea	ca		dex				dex
.0199eb	c9 bb		cmp #$bb			cmp 	#token_Percent 			; percent is 4 bytes (integer)
.0199ed	f0 02		beq $0199f1			beq 	_VEHaveSize
.0199ef	a2 02		ldx #$02			ldx 	#2 						; everything else is two.
.0199f1					_VEHaveSize:
.0199f1	8e 99 03	stx $0399			stx 	Var_DataSize
.0199f4	fa		plx				plx
.0199f5	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varcreate.asm

.0199f6					VariableCreate:
.0199f6	da		phx				phx
.0199f7	5a		phy				phy
.0199f8	ad 02 03	lda $0302			lda 	VarMemPtr 					; get address of next free into zTemp1
.0199fb	85 10		sta $10				sta 	zTemp1
.0199fd	ad 03 03	lda $0303			lda 	VarMemPtr+1
.019a00	85 11		sta $11				sta 	zTemp1+1
.019a02	ad 99 03	lda $0399			lda 	Var_DataSize 				; bytes for the data bit
.019a05	18		clc				clc
.019a06	6d 97 03	adc $0397			adc 	Var_Length 					; add the length of the name
.019a09	69 03		adc #$03			adc 	#3 							; 3 for the link and the hash.
.019a0b	6d 02 03	adc $0302			adc 	VarMemPtr 					; add to variable memory pointer
.019a0e	8d 02 03	sta $0302			sta 	VarMemPtr
.019a11	90 03		bcc $019a16			bcc 	_VCNoCarry
.019a13	ee 03 03	inc $0303			inc 	VarMemPtr+1
.019a16					_VCNoCarry:
.019a16	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.019a19	85 12		sta $12				sta 	zTemp2
.019a1b	a9 03		lda #$03			lda 	#HashTableBase >> 8
.019a1d	85 13		sta $13				sta 	zTemp2+1
.019a1f	a0 00		ldy #$00			ldy 	#0 							; put current hash link in position.
.019a21	b1 12		lda ($12),y			lda 	(zTemp2),y
.019a23	91 10		sta ($10),y			sta 	(zTemp1),y
.019a25	c8		iny				iny
.019a26	b1 12		lda ($12),y			lda 	(zTemp2),y
.019a28	91 10		sta ($10),y			sta 	(zTemp1),y
.019a2a	c8		iny				iny
.019a2b	ad 96 03	lda $0396			lda 	Var_Hash 					; write the hash out.
.019a2e	91 10		sta ($10),y			sta 	(zTemp1),y
.019a30	c8		iny				iny
.019a31	a2 00		ldx #$00			ldx 	#0 							; copy the name out.
.019a33					_VCCopyName:
.019a33	bd 15 03	lda $0315,x			lda 	Var_Buffer,x
.019a36	91 10		sta ($10),y			sta 	(zTemp1),y
.019a38	e8		inx				inx
.019a39	c8		iny				iny
.019a3a	ec 97 03	cpx $0397			cpx 	Var_Length
.019a3d	d0 f4		bne $019a33			bne 	_VCCopyName
.019a3f	5a		phy				phy 								; save the data offset.
.019a40	ae 99 03	ldx $0399			ldx 	Var_DataSize 				; and write the data out.
.019a43	a9 00		lda #$00			lda 	#0 							; which is all zeroes.
.019a45					_VCClearData:
.019a45	91 10		sta ($10),y			sta 	(zTemp1),y
.019a47	c8		iny				iny
.019a48	ca		dex				dex
.019a49	d0 fa		bne $019a45			bne 	_VCClearData
.019a4b	68		pla				pla 								; offset to the data
.019a4c	18		clc				clc
.019a4d	65 10		adc $10				adc 	zTemp1 						; add to start and save as data pointer.
.019a4f	85 22		sta $22				sta 	zVarDataPtr
.019a51	a5 11		lda $11				lda 	zTemp1+1
.019a53	69 00		adc #$00			adc 	#0
.019a55	85 23		sta $23				sta 	zVarDataPtr+1
.019a57	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.019a5a	85 24		sta $24				sta 	zVarType
.019a5c	a5 10		lda $10				lda 	zTemp1 						; fix hash link to point to new record
.019a5e	a0 00		ldy #$00			ldy 	#0
.019a60	91 12		sta ($12),y			sta 	(zTemp2),y
.019a62	c8		iny				iny
.019a63	a5 11		lda $11				lda 	zTemp1+1
.019a65	91 12		sta ($12),y			sta 	(zTemp2),y
.019a67	ad 95 03	lda $0395			lda 	Var_Type 					; array ? if so create the empty one.
.019a6a	29 01		and #$01			and 	#1
.019a6c	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.019a6e	d0 0e		bne $019a7e			bne 	_VCNotArray
.019a70	a2 00		ldx #$00			ldx 	#0 							; call recursive array creator
.019a72	20 18 9b	jsr $019b18			jsr 	ArrayCreate
.019a75	5a		phy				phy 								; save YA at zVarDataPtr
.019a76	a0 00		ldy #$00			ldy 	#0
.019a78	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019a7a	c8		iny				iny
.019a7b	68		pla				pla
.019a7c	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019a7e					_VCNotArray:
.019a7e	7a		ply				ply
.019a7f	fa		plx				plx
.019a80	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arrayidx.asm

.019a81					ArrayIndexFollow:
.019a81	5a		phy				phy
.019a82	a0 00		ldy #$00			ldy 	#0 							; make zVarDataPtr point to the array.
.019a84	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; e.g. it points to itself.
.019a86	48		pha				pha
.019a87	c8		iny				iny
.019a88	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019a8a	85 23		sta $23				sta 	zVarDataPtr+1
.019a8c	68		pla				pla
.019a8d	85 22		sta $22				sta 	zVarDataPtr
.019a8f	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; MSB of 16 bit integer and bytes 2&3
.019a91	29 80		and #$80			and 	#$80 						; must be zero.
.019a93	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019a95	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019a97	d0 59		bne $019af2			bne 	_AIFError
.019a99	a0 00		ldy #$00			ldy 	#0 							; calculate size - current - 1
.019a9b	18		clc				clc
.019a9c	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019a9e	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.019aa0	c8		iny				iny
.019aa1	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019aa3	08		php				php 								; clear bit 7 retaining borrow.
.019aa4	29 7f		and #$7f			and 	#$7F
.019aa6	28		plp				plp
.019aa7	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.019aa9	90 47		bcc $019af2			bcc 	_AIFError 					; eror if size-current < 0
.019aab	b5 80		lda $80,x			lda  	XS_Mantissa+0,x 			; copy and double the index
.019aad	0a		asl a				asl 	a 							; (e.g. index * 2)
.019aae	85 10		sta $10				sta 	zTemp1
.019ab0	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019ab2	2a		rol a				rol 	a
.019ab3	85 11		sta $11				sta 	zTemp1+1
.019ab5	a0 01		ldy #$01			ldy 	#1 							; is this a data entry.
.019ab7	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; if so, then type is unchanged, offset set
.019ab9	30 1d		bmi $019ad8			bmi 	_AIFCalculate
.019abb	c6 24		dec $24				dec 	zVarType 					; converts from an array to a type.
.019abd	a5 24		lda $24				lda 	zVarType 					; check that type
.019abf	c9 b7		cmp #$b7			cmp 	#token_Dollar 				; if string, use x 2
.019ac1	f0 15		beq $019ad8			beq 	_AIFCalculate
.019ac3	06 10		asl $10				asl 	zTemp1			 			; double the index
.019ac5	26 11		rol $11				rol 	zTemp1+1					; (e.g. index * 4)
.019ac7	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if integer, use x 4
.019ac9	f0 0d		beq $019ad8			beq 	_AIFCalculate
.019acb	18		clc				clc 								; add the original mantissa in again
.019acc	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; which makes it x5, for float.
.019ace	65 10		adc $10				adc 	zTemp1
.019ad0	85 10		sta $10				sta 	zTemp1
.019ad2	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019ad4	65 11		adc $11				adc 	zTemp1+1
.019ad6	85 11		sta $11				sta 	zTemp1+1
.019ad8					_AIFCalculate:
.019ad8	18		clc				clc 								; add index x 2,4 or 5 to base
.019ad9	a5 22		lda $22				lda 	zVarDataPtr
.019adb	65 10		adc $10				adc 	zTemp1
.019add	85 22		sta $22				sta 	zVarDataPtr
.019adf	a5 23		lda $23				lda 	zVarDataPtr+1
.019ae1	65 11		adc $11				adc 	zTemp1+1
.019ae3	85 23		sta $23				sta 	zVarDataPtr+1
.019ae5	18		clc				clc 								; add 2 more for the length prefix.
.019ae6	a5 22		lda $22				lda 	zVarDataPtr
.019ae8	69 02		adc #$02			adc 	#2
.019aea	85 22		sta $22				sta 	zVarDataPtr
.019aec	90 02		bcc $019af0			bcc 	_AIFNoBump
.019aee	e6 23		inc $23				inc 	zVarDataPtr+1
.019af0					_AIFNoBump:
.019af0	7a		ply				ply
.019af1	60		rts				rts
.019af2					_AIFError:
.019af2	20 79 85	jsr $018579			jsr ERR_Handler
>019af5	42 61 64 20 61 72 72 61			.text "Bad array index",0
>019afd	79 20 69 6e 64 65 78 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arraydef.asm

.019b05					ArrayResetDefault:
.019b05	a9 0b		lda #$0b			lda 	#11 						; 0..10 one array
.019b07	8d a9 03	sta $03a9			sta 	ArrayDef+0
.019b0a	a9 00		lda #$00			lda 	#0
.019b0c	8d aa 03	sta $03aa			sta 	ArrayDef+1
.019b0f	a9 ff		lda #$ff			lda 	#$FF
.019b11	8d ab 03	sta $03ab			sta 	ArrayDef+2 					; $FFFF implies no second element.
.019b14	8d ac 03	sta $03ac			sta 	ArrayDef+3					; (test bit 7 of 2nd byte)
.019b17	60		rts				rts
.019b18					ArrayCreate:
.019b18	bd a9 03	lda $03a9,x			lda 	ArrayDef+0,x 				; put size x 2 in zTemp1
.019b1b	0a		asl a				asl 	a
.019b1c	85 10		sta $10				sta 	zTemp1
.019b1e	bd aa 03	lda $03aa,x			lda 	ArrayDef+1,x
.019b21	2a		rol a				rol 	a
.019b22	85 11		sta $11				sta 	zTemp1+1
.019b24	bd ac 03	lda $03ac,x			lda 	ArrayDef+3,x 				; if this is the last element it's array of ptrs.
.019b27	10 22		bpl $019b4b			bpl 	_ACSized 					; if not multiply size x 2 (str) 4 (int) 5 (real)
.019b29	ad 95 03	lda $0395			lda 	Var_Type 					; check the type
.019b2c	c9 b8		cmp #$b8			cmp 	#token_DollarLParen 		; also if it is an array of strings $(
.019b2e	f0 1b		beq $019b4b			beq 	_ACSized
.019b30	06 10		asl $10				asl 	zTemp1 						; double again
.019b32	26 11		rol $11				rol 	zTemp1+1
.019b34	b0 6f		bcs $019ba5			bcs 	ArrayIndexError 			; too large.
.019b36	c9 bc		cmp #$bc			cmp 	#token_PercentLParen 		; if %( four bytes/entry is enough.
.019b38	f0 11		beq $019b4b			beq 	_ACSized
.019b3a	18		clc				clc 								; add original value x 5 for reals.
.019b3b	a5 10		lda $10				lda 	zTemp1
.019b3d	7d a9 03	adc $03a9,x			adc 	ArrayDef+0,x
.019b40	85 10		sta $10				sta 	zTemp1
.019b42	a5 11		lda $11				lda 	zTemp1+1
.019b44	7d aa 03	adc $03aa,x			adc 	ArrayDef+1,x
.019b47	85 11		sta $11				sta 	zTemp1+1
.019b49	b0 5a		bcs $019ba5			bcs 	ArrayIndexError
.019b4b					_ACSized:
.019b4b	18		clc				clc
.019b4c	a5 10		lda $10				lda 	zTemp1
.019b4e	69 02		adc #$02			adc 	#2
.019b50	85 10		sta $10				sta 	zTemp1
.019b52	90 04		bcc $019b58			bcc 	_ACNoBump
.019b54	e6 10		inc $10				inc 	zTemp1
.019b56	f0 4d		beq $019ba5			beq 	ArrayIndexError
.019b58					_ACNoBump:
.019b58	18		clc				clc
.019b59	ad 02 03	lda $0302			lda 	VarMemPtr 					; add this allocated count to VarMemPtr
.019b5c	85 12		sta $12				sta 	zTemp2						; save start in zTemp2/zTemp3
.019b5e	85 14		sta $14				sta 	zTemp3
.019b60	65 10		adc $10				adc 	zTemp1
.019b62	8d 02 03	sta $0302			sta 	VarMemPtr
.019b65	ad 03 03	lda $0303			lda 	VarMemPtr+1
.019b68	85 13		sta $13				sta 	zTemp2+1
.019b6a	85 15		sta $15				sta 	zTemp3+1
.019b6c	65 11		adc $11				adc 	zTemp1+1
.019b6e	8d 03 03	sta $0303			sta 	VarMemPtr+1
.019b71	85 11		sta $11				sta 	zTemp1+1
.019b73	b0 30		bcs $019ba5			bcs 	ArrayIndexError
.019b75	a0 00		ldy #$00			ldy 	#0							; write $00 out.
.019b77					_ACClear:
.019b77	98		tya				tya
.019b78	91 12		sta ($12),y			sta 	(zTemp2),y
.019b7a	e6 12		inc $12				inc 	zTemp2
.019b7c	d0 02		bne $019b80			bne 	_ACCBump
.019b7e	e6 13		inc $13				inc 	zTemp2+1
.019b80					_ACCBump:
.019b80	a5 12		lda $12				lda 	zTemp2
.019b82	cd 02 03	cmp $0302			cmp 	VarMemPtr
.019b85	d0 f0		bne $019b77			bne 	_ACClear
.019b87	a5 13		lda $13				lda 	zTemp2+1
.019b89	cd 03 03	cmp $0303			cmp 	VarMemPtr+1
.019b8c	d0 e9		bne $019b77			bne 	_ACClear
.019b8e	a0 00		ldy #$00			ldy 	#0
.019b90	bd a9 03	lda $03a9,x			lda 	ArrayDef+0,x 				; copy the size into the start
.019b93	91 14		sta ($14),y			sta 	(zTemp3),y
.019b95	c8		iny				iny
.019b96	bd aa 03	lda $03aa,x			lda 	ArrayDef+1,x
.019b99	91 14		sta ($14),y			sta 	(zTemp3),y
.019b9b	bd ac 03	lda $03ac,x			lda 	ArrayDef+3,x 				; have we reached the end
.019b9e	10 18		bpl $019bb8			bpl 	ACCFillRecursive
.019ba0	a4 15		ldy $15				ldy 	zTemp3+1 					; return address
.019ba2	a5 14		lda $14				lda 	zTemp3
.019ba4	60		rts				rts
.019ba5					ArrayIndexError:
.019ba5	20 79 85	jsr $018579			jsr ERR_Handler
>019ba8	42 61 64 20 61 72 72 61			.text "Bad array index",0
>019bb0	79 20 69 6e 64 65 78 00
.019bb8					ACCFillRecursive:
.019bb8	a9 ff		lda #$ff			lda 	#$FF 						; we mark the end, this is free space.
.019bba	a0 00		ldy #$00			ldy 	#0 							; this is overwritten by size of next allocated
.019bbc	91 12		sta ($12),y			sta 	(zTemp2),y 					; array, but we might change that.
.019bbe	c8		iny				iny
.019bbf	b1 14		lda ($14),y			lda 	(zTemp3),y 					; set bit 15 of the max index indicating
.019bc1	09 80		ora #$80			ora 	#$80 						; an array of pointers
.019bc3	91 14		sta ($14),y			sta 	(zTemp3),y
.019bc5	a5 14		lda $14				lda 	zTemp3 						; push the start on the stack
.019bc7	48		pha				pha
.019bc8	a5 15		lda $15				lda 	zTemp3+1
.019bca	48		pha				pha
.019bcb					_ACCFillLoop:
.019bcb	18		clc				clc
.019bcc	a5 14		lda $14				lda 	zTemp3 						; and work forwards.
.019bce	69 02		adc #$02			adc 	#2
.019bd0	85 14		sta $14				sta 	zTemp3
.019bd2	90 02		bcc $019bd6			bcc 	_ACCSkip2
.019bd4	e6 15		inc $15				inc 	zTemp3+1
.019bd6					_ACCSkip2:
.019bd6	a0 00		ldy #$00			ldy 	#0 							; reached the end ?
.019bd8	b1 14		lda ($14),y			lda 	(zTemp3),y					; (looking for FF marker, everything else 00)
.019bda	c8		iny				iny
.019bdb	11 14		ora ($14),y			ora 	(zTemp3),y
.019bdd	d0 21		bne $019c00			bne 	_ACCExit
.019bdf	a5 14		lda $14				lda 	zTemp3 						; push zTemp3
.019be1	48		pha				pha
.019be2	a5 15		lda $15				lda 	zTemp3+1
.019be4	48		pha				pha
.019be5	e8		inx				inx
.019be6	e8		inx				inx
.019be7	20 18 9b	jsr $019b18			jsr 	ArrayCreate 				; create array recursively.
.019bea	ca		dex				dex
.019beb	ca		dex				dex
.019bec	85 12		sta $12				sta 	zTemp2 						; save A
.019bee	68		pla				pla
.019bef	85 15		sta $15				sta 	zTemp3+1 					; restore zTemp3
.019bf1	68		pla				pla
.019bf2	85 14		sta $14				sta 	zTemp3
.019bf4	98		tya				tya 								; write high bye from Y
.019bf5	a0 01		ldy #$01			ldy 	#1
.019bf7	91 14		sta ($14),y			sta 	(zTemp3),y
.019bf9	88		dey				dey 								; write low byte out.
.019bfa	a5 12		lda $12				lda 	zTemp2
.019bfc	91 14		sta ($14),y			sta 	(zTemp3),y
.019bfe	80 cb		bra $019bcb			bra 	_ACCFillLoop 				; and try again.
.019c00					_ACCExit:
.019c00	7a		ply				ply 								; restore the original address
.019c01	68		pla				pla
.019c02	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varfind.asm

.019c03					VariableLocate:
.019c03	da		phx				phx
.019c04	5a		phy				phy
.019c05	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.019c08	85 12		sta $12				sta 	zTemp2 						; points to first address.
.019c0a	a9 03		lda #$03			lda 	#HashTableBase >> 8
.019c0c	85 13		sta $13				sta 	zTemp2+1
.019c0e	a0 00		ldy #$00	_VLNext:ldy 	#0 							; get next link into AX
.019c10	b1 12		lda ($12),y			lda 	(zTemp2),y
.019c12	aa		tax				tax
.019c13	c8		iny				iny
.019c14	b1 12		lda ($12),y			lda 	(zTemp2),y
.019c16	85 13		sta $13				sta 	zTemp2+1 					; save in zTemp
.019c18	86 12		stx $12				stx 	zTemp2
.019c1a	05 12		ora $12				ora 	zTemp2 						; got zero
.019c1c	18		clc				clc
.019c1d	f0 25		beq $019c44			beq 	_VLExit 					; if so, then fail as end of chain.
.019c1f	c8		iny				iny 								; point to hash (offset + 2)
.019c20	b1 12		lda ($12),y			lda 	(zTemp2),y
.019c22	cd 96 03	cmp $0396			cmp 	Var_Hash
.019c25	d0 e7		bne $019c0e			bne 	_VLNext 					; try next if different.
.019c27					_VLCompare:
.019c27	c8		iny				iny 								; next character
.019c28	b1 12		lda ($12),y			lda 	(zTemp2),y 					; compare variable field against buffer.
.019c2a	d9 12 03	cmp $0312,y			cmp 	Var_Buffer-3,y 				; the -3 is because name starts at 3.
.019c2d	d0 df		bne $019c0e			bne 	_VLNext 					; fail if different, try next.
.019c2f	0a		asl a				asl 	a 							; until end character (bit 7 set) matched
.019c30	90 f5		bcc $019c27			bcc 	_VLCompare
.019c32	98		tya				tya
.019c33	38		sec				sec 								; add 1 as Y points to last character
.019c34	65 12		adc $12				adc 	zTemp2 						; add to the current address
.019c36	85 22		sta $22				sta 	zVarDataPtr
.019c38	a5 13		lda $13				lda 	zTemp2+1
.019c3a	69 00		adc #$00			adc 	#0
.019c3c	85 23		sta $23				sta 	zVarDataPtr+1
.019c3e	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.019c41	85 24		sta $24				sta 	zVarType
.019c43	38		sec				sec 								; return CS
.019c44	7a		ply		_VLExit:ply
.019c45	fa		plx				plx
.019c46	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/vargetset.asm

.019c47					VariableGet:
.019c47	5a		phy				phy
.019c48	a0 00		ldy #$00			ldy 	#0 							; copy first two bytes
.019c4a	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019c4c	95 80		sta $80,x			sta 	XS_Mantissa,x
.019c4e	c8		iny				iny
.019c4f	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019c51	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019c53	c8		iny				iny
.019c54	a5 24		lda $24				lda 	zVarType 					; if it is a string, set up for that.
.019c56	c9 b7		cmp #$b7			cmp 	#token_Dollar
.019c58	f0 2c		beq $019c86			beq 	_VGString
.019c5a	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; copy the next two bytes.
.019c5c	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019c5e	c8		iny				iny
.019c5f	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019c61	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019c63	c8		iny				iny
.019c64	a9 01		lda #$01			lda 	#1 							; set type to 1.
.019c66	95 85		sta $85,x			sta 	XS_Type,x
.019c68	a5 24		lda $24				lda 	zVarType
.019c6a	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if it is a %, then exit with default integer.
.019c6c	f0 28		beq $019c96			beq 	_VGExit
.019c6e	a9 40		lda #$40			lda 	#$40 						; set type byte to zero
.019c70	95 85		sta $85,x			sta 	XS_Type,x 					; which is the code for zero/float.
.019c72	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; the last value to copy is the exponent.
.019c74	95 84		sta $84,x			sta 	XS_Exponent,x
.019c76	f0 1e		beq $019c96			beq 	_VGExit 					; if exponent is zero ... it's zero.
.019c78	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; the sign bit is the top mantissa bit.
.019c7a	48		pha				pha
.019c7b	29 80		and #$80			and 	#$80
.019c7d	95 85		sta $85,x			sta 	XS_Type,x 					; this is the type byte.
.019c7f	68		pla				pla
.019c80	09 80		ora #$80			ora 	#$80 						; set the MSB as you would expect.
.019c82	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; so it's a normalised float.
.019c84	80 10		bra $019c96			bra 	_VGExit
.019c86					_VGString:
.019c86	a9 02		lda #$02			lda 	#2 							; set type to 2, a string
.019c88	95 85		sta $85,x			sta 	XS_Type,x
.019c8a	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; is the value there $0000
.019c8c	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019c8e	d0 06		bne $019c96			bne 	_VGExit 					; if not, exit.
.019c90	85 25		sta $25				sta 	zNullString 				; make zNullString a 00 string.
.019c92	a9 25		lda #$25			lda 	#zNullString
.019c94	95 80		sta $80,x			sta 	XS_Mantissa,x 				; make it point to it.
.019c96					_VGExit:
.019c96	7a		ply				ply
.019c97	60		rts				rts
.019c98					VariableSet:
.019c98	b5 85		lda $85,x			lda 	XS_Type,x 					; is the result a string
.019c9a	29 02		and #$02			and 	#2 							; if so, it has to be
.019c9c	d0 4b		bne $019ce9			bne 	_VSString
.019c9e	a5 24		lda $24				lda 	zVarType 					; if type is $ there's an error.
.019ca0	c9 b7		cmp #$b7			cmp 	#token_Dollar
.019ca2	f0 42		beq $019ce6			beq 	_VSBadType
.019ca4	c9 bb		cmp #$bb			cmp 	#token_Percent 				; type convert to float/int
.019ca6	f0 05		beq $019cad			beq 	_VSMakeInt
.019ca8	20 0e a2	jsr $01a20e			jsr 	FPUToFloat
.019cab	80 03		bra $019cb0			bra 	_VSCopy
.019cad					_VSMakeInt:
.019cad	20 5a a2	jsr $01a25a			jsr 	FPUToInteger
.019cb0					_VSCopy:
.019cb0	5a		phy				phy
.019cb1	a0 00		ldy #$00			ldy 	#0 							; copy mantissa to target.
.019cb3	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019cb5	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019cb7	c8		iny				iny
.019cb8	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019cba	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019cbc	c8		iny				iny
.019cbd	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019cbf	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019cc1	c8		iny				iny
.019cc2	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019cc4	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019cc6	a5 24		lda $24				lda 	zVarType 					; if target is integer, alrady done.
.019cc8	c9 bb		cmp #$bb			cmp 	#token_Percent
.019cca	f0 18		beq $019ce4			beq 	_VSExit
.019ccc	b5 85		lda $85,x			lda 	XS_Type,x 					; get the sign bit into carry flag.
.019cce	0a		asl a				asl 	a
.019ccf	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; shift the sign into the mantissa high.
.019cd1	08		php				php
.019cd2	0a		asl a				asl 	a
.019cd3	28		plp				plp
.019cd4	6a		ror a				ror 	a
.019cd5	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019cd7	c8		iny				iny
.019cd8	b5 84		lda $84,x			lda 	XS_Exponent,x 				; copy the exponent in
.019cda	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019cdc	34 85		bit $85,x			bit 	XS_Type,x 					; if the result is non zero
.019cde	50 04		bvc $019ce4			bvc 	_VSExit
.019ce0	a9 00		lda #$00			lda 	#00 						; zero exponent indicating 0.
.019ce2	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019ce4					_VSExit:
.019ce4	7a		ply				ply
.019ce5	60		rts				rts
.019ce6					_VSBadType:
.019ce6	4c 5a 85	jmp $01855a			jmp 	TypeError
.019ce9					_VSString:
.019ce9	a5 24		lda $24				lda 	zVarType 					; type must be $
.019ceb	c9 b7		cmp #$b7			cmp 	#token_Dollar
.019ced	d0 f7		bne $019ce6			bne 	_VSBadType
.019cef	da		phx				phx
.019cf0	5a		phy				phy
.019cf1	20 6e 98	jsr $01986e			jsr 	StringConcrete 				; concrete the string in the mantissa -> AX
.019cf4	a0 01		ldy #$01			ldy 	#1 							; save high byte
.019cf6	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019cf8	88		dey				dey 								; save low byte
.019cf9	8a		txa				txa
.019cfa	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019cfc	7a		ply				ply 								; and exit.
.019cfd	fa		plx				plx
.019cfe	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.019cff					MulInteger32:
.019cff	b5 80		lda $80,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.019d01	95 8c		sta $8c,x			sta 	XS3_Mantissa,x
.019d03	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019d05	95 8d		sta $8d,x			sta 	XS3_Mantissa+1,x
.019d07	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019d09	95 8e		sta $8e,x			sta 	XS3_Mantissa+2,x
.019d0b	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019d0d	95 8f		sta $8f,x			sta 	XS3_Mantissa+3,x
.019d0f	a9 00		lda #$00			lda 	#0
.019d11	95 80		sta $80,x			sta 	XS_Mantissa+0,x 				; zero +0
.019d13	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019d15	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019d17	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019d19					_BFMMultiply:
.019d19	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.019d1b	29 01		and #$01			and 	#1
.019d1d	f0 03		beq $019d22			beq 	_BFMNoAdd
.019d1f	20 ba 93	jsr $0193ba			jsr 	AddInteger32
.019d22					_BFMNoAdd:
.019d22	16 86		asl $86,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.019d24	36 87		rol $87,x			rol 	XS2_Mantissa+1,x
.019d26	36 88		rol $88,x			rol 	XS2_Mantissa+2,x
.019d28	36 89		rol $89,x			rol 	XS2_Mantissa+3,x
.019d2a	56 8f		lsr $8f,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.019d2c	76 8e		ror $8e,x			ror 	XS3_Mantissa+2,x
.019d2e	76 8d		ror $8d,x			ror 	XS3_Mantissa+1,x
.019d30	76 8c		ror $8c,x			ror 	XS3_Mantissa,x
.019d32	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.019d34	15 8d		ora $8d,x			ora 	XS3_Mantissa+1,x
.019d36	15 8e		ora $8e,x			ora 	XS3_Mantissa+2,x
.019d38	15 8f		ora $8f,x			ora 	XS3_Mantissa+3,x
.019d3a	d0 dd		bne $019d19			bne 	_BFMMultiply
.019d3c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.019d3d					DivInteger32:
.019d3d	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; check for /0
.019d3f	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.019d41	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.019d43	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.019d45	d0 14		bne $019d5b			bne 	_BFDOkay
.019d47	20 79 85	jsr $018579			jsr ERR_Handler
>019d4a	44 69 76 69 73 69 6f 6e			.text "Division by Zero",0
>019d52	20 62 79 20 5a 65 72 6f 00
.019d5b					_BFDOkay:
.019d5b	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.019d5d	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.019d5f	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.019d61	85 1c		sta $1c				sta 	zLTemp1+2
.019d63	85 1d		sta $1d				sta 	zLTemp1+3
.019d65	8d 9e 03	sta $039e			sta 	SignCount 					; Count of signs.
.019d68	20 bf 9d	jsr $019dbf			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.019d6b	da		phx				phx
.019d6c	e8		inx				inx
.019d6d	e8		inx				inx
.019d6e	e8		inx				inx
.019d6f	e8		inx				inx
.019d70	e8		inx				inx
.019d71	e8		inx				inx
.019d72	20 bf 9d	jsr $019dbf			jsr 	CheckIntegerNegate
.019d75	fa		plx				plx
.019d76	5a		phy				phy 								; Y is the counter
.019d77	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.019d79					_BFDLoop:
.019d79	16 80		asl $80,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.019d7b	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.019d7d	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.019d7f	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.019d81	26 1a		rol $1a				rol 	zLTemp1
.019d83	26 1b		rol $1b				rol 	zLTemp1+1
.019d85	26 1c		rol $1c				rol 	zLTemp1+2
.019d87	26 1d		rol $1d				rol 	zLTemp1+3
.019d89	38		sec				sec
.019d8a	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.019d8c	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.019d8e	48		pha				pha
.019d8f	a5 1b		lda $1b				lda 	zLTemp1+1
.019d91	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.019d93	48		pha				pha
.019d94	a5 1c		lda $1c				lda 	zLTemp1+2
.019d96	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.019d98	48		pha				pha
.019d99	a5 1d		lda $1d				lda 	zLTemp1+3
.019d9b	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.019d9d	90 13		bcc $019db2			bcc 	_BFDNoAdd
.019d9f	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.019da1	68		pla				pla
.019da2	85 1c		sta $1c				sta 	zLTemp1+2
.019da4	68		pla				pla
.019da5	85 1b		sta $1b				sta 	zLTemp1+1
.019da7	68		pla				pla
.019da8	85 1a		sta $1a				sta 	zLTemp1+0
.019daa	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.019dac	09 01		ora #$01			ora 	#1
.019dae	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019db0	80 03		bra $019db5			bra 	_BFDNext
.019db2					_BFDNoAdd:
.019db2	68		pla				pla 								; Throw away the intermediate calculations
.019db3	68		pla				pla
.019db4	68		pla				pla
.019db5					_BFDNext:
.019db5	88		dey				dey
.019db6	d0 c1		bne $019d79			bne 	_BFDLoop
.019db8	7a		ply				ply 								; restore Y and exit
.019db9	4e 9e 03	lsr $039e			lsr 	SignCount 					; if sign count odd,
.019dbc	b0 06		bcs $019dc4			bcs		IntegerNegateAlways 			; negate the result
.019dbe	60		rts				rts
.019dbf					CheckIntegerNegate:
.019dbf	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019dc1	30 01		bmi $019dc4			bmi 	IntegerNegateAlways
.019dc3	60		rts				rts
.019dc4					IntegerNegateAlways:
.019dc4	ee 9e 03	inc $039e			inc 	SignCount
.019dc7	38		sec				sec
.019dc8	a9 00		lda #$00			lda 	#0
.019dca	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.019dcc	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019dce	a9 00		lda #$00			lda 	#0
.019dd0	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.019dd2	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019dd4	a9 00		lda #$00			lda 	#0
.019dd6	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.019dd8	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019dda	a9 00		lda #$00			lda 	#0
.019ddc	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.019dde	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019de0	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.019de1					INTToString:
.019de1	48		pha				pha
.019de2	5a		phy				phy
.019de3	b5 83		lda $83,x			lda 		XS_Mantissa+3,x 		; check -ve
.019de5	10 08		bpl $019def			bpl 		_ITSNotMinus
.019de7	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.019de9	20 83 9e	jsr $019e83			jsr 		ITSOutputCharacter
.019dec	20 c4 9d	jsr $019dc4			jsr 		IntegerNegateAlways 	; negate the number.
.019def					_ITSNotMinus:
.019def	a9 00		lda #$00			lda 		#0
.019df1	8d 9a 03	sta $039a			sta 		NumSuppress 			; clear the suppression flag.
.019df4	8a		txa				txa 								; use Y for the mantissa index.
.019df5	a8		tay				tay
.019df6	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.019df8					_ITSNextSubtractor:
.019df8	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.019dfa	8d 9b 03	sta $039b			sta 		NumConvCount
.019dfd					_ITSSubtract:
.019dfd	38		sec				sec
.019dfe	b9 80 00	lda $0080,y			lda 		XS_Mantissa,y 			; subtract number and push on stack
.019e01	ff 5f 9e 01	sbc $019e5f,x			sbc 		_ITSSubtractors+0,x
.019e05	48		pha				pha
.019e06	b9 81 00	lda $0081,y			lda 		XS_Mantissa+1,y
.019e09	ff 60 9e 01	sbc $019e60,x			sbc 		_ITSSubtractors+1,x
.019e0d	48		pha				pha
.019e0e	b9 82 00	lda $0082,y			lda 		XS_Mantissa+2,y
.019e11	ff 61 9e 01	sbc $019e61,x			sbc 		_ITSSubtractors+2,x
.019e15	48		pha				pha
.019e16	b9 83 00	lda $0083,y			lda 		XS_Mantissa+3,y
.019e19	ff 62 9e 01	sbc $019e62,x			sbc 		_ITSSubtractors+3,x
.019e1d	90 14		bcc $019e33			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.019e1f	99 83 00	sta $0083,y			sta 		XS_Mantissa+3,y 		; save subtract off stack
.019e22	68		pla				pla
.019e23	99 82 00	sta $0082,y			sta 		XS_Mantissa+2,y
.019e26	68		pla				pla
.019e27	99 81 00	sta $0081,y			sta 		XS_Mantissa+1,y
.019e2a	68		pla				pla
.019e2b	99 80 00	sta $0080,y			sta 		XS_Mantissa+0,y
.019e2e	ee 9b 03	inc $039b			inc 		NumConvCount 			; bump count.
.019e31	80 ca		bra $019dfd			bra 		_ITSSubtract 			; go round again.
.019e33					_ITSCantSubtract:
.019e33	68		pla				pla 								; throw away interim answers
.019e34	68		pla				pla
.019e35	68		pla				pla
.019e36	ad 9b 03	lda $039b			lda 		NumConvCount 			; if not zero then no suppression check
.019e39	c9 30		cmp #$30			cmp 		#"0"
.019e3b	d0 05		bne $019e42			bne 		_ITSOutputDigit
.019e3d	ad 9a 03	lda $039a			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.019e40	10 09		bpl $019e4b			bpl	 		_ITSGoNextSubtractor
.019e42					_ITSOutputDigit:
.019e42	ce 9a 03	dec $039a			dec 		NumSuppress 			; suppression check will be non-zero.
.019e45	ad 9b 03	lda $039b			lda 		NumConvCount 			; count of subtractions
.019e48	20 83 9e	jsr $019e83			jsr 		ITSOutputCharacter 		; output it.
.019e4b					_ITSGoNextSubtractor:
.019e4b	e8		inx				inx 								; next dword
.019e4c	e8		inx				inx
.019e4d	e8		inx				inx
.019e4e	e8		inx				inx
.019e4f	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.019e51	d0 a5		bne $019df8			bne 		_ITSNextSubtractor 		; do all the subtractors.
.019e53	98		tya				tya 								; X is back as the mantissa index
.019e54	aa		tax				tax
.019e55	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.019e57	09 30		ora #$30			ora 		#"0"
.019e59	20 83 9e	jsr $019e83			jsr 		ITSOutputCharacter
.019e5c	7a		ply				ply 								; and exit
.019e5d	68		pla				pla
.019e5e	60		rts				rts
.019e5f					_ITSSubtractors:
>019e5f	00 ca 9a 3b					.dword 		1000000000
>019e63	00 e1 f5 05					.dword 		100000000
>019e67	80 96 98 00					.dword 		10000000
>019e6b	40 42 0f 00					.dword 		1000000
>019e6f	a0 86 01 00					.dword 		100000
>019e73	10 27 00 00					.dword 		10000
>019e77	e8 03 00 00					.dword 		1000
>019e7b	64 00 00 00					.dword 		100
>019e7f	0a 00 00 00					.dword 		10
.019e83					_ITSSubtractorsEnd:
.019e83					ITSOutputCharacter:
.019e83	48		pha				pha
.019e84	da		phx				phx
.019e85	ae 14 03	ldx $0314			ldx 	NumBufX 					; save digit
.019e88	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.019e8b	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.019e8d	9d 16 03	sta $0316,x			sta 	Num_Buffer+1,x
.019e90	ee 14 03	inc $0314			inc 	NumBufX						; bump pointer.
.019e93	fa		plx				plx
.019e94	68		pla				pla
.019e95	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.019e96					IntFromString:
.019e96	a0 00		ldy #$00			ldy 	#0
.019e98	8c 9c 03	sty $039c			sty 	ExpTemp 					; this is the converted digit count.
.019e9b					IntFromStringY:
.019e9b	48		pha				pha
.019e9c	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.019e9e	95 80		sta $80,x			sta 	XS_Mantissa,x
.019ea0	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019ea2	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019ea4	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019ea6	a9 01		lda #$01			lda 	#1
.019ea8	95 85		sta $85,x			sta 	XS_Type,x
.019eaa					_IFSLoop:
.019eaa	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.019eac	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.019eae	90 4e		bcc $019efe			bcc 	_IFSExit
.019eb0	c9 3a		cmp #$3a			cmp 	#"9"+1
.019eb2	b0 4a		bcs $019efe			bcs 	_IFSExit
.019eb4	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.019eb6	c9 0c		cmp #$0c			cmp 	#12
.019eb8	b0 4e		bcs $019f08			bcs 	_IFSOverflow
.019eba	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.019ebc	48		pha				pha
.019ebd	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019ebf	48		pha				pha
.019ec0	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019ec2	48		pha				pha
.019ec3	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019ec5	48		pha				pha
.019ec6	20 1d 9f	jsr $019f1d			jsr 	IFSX1ShiftLeft 				; double
.019ec9	20 1d 9f	jsr $019f1d			jsr 	IFSX1ShiftLeft 				; x 4
.019ecc	18		clc				clc 								; add saved value x 5
.019ecd	68		pla				pla
.019ece	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.019ed0	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019ed2	68		pla				pla
.019ed3	75 81		adc $81,x			adc 	XS_Mantissa+1,x
.019ed5	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019ed7	68		pla				pla
.019ed8	75 82		adc $82,x			adc 	XS_Mantissa+2,x
.019eda	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019edc	68		pla				pla
.019edd	75 83		adc $83,x			adc 	XS_Mantissa+3,x
.019edf	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019ee1	20 1d 9f	jsr $019f1d			jsr 	IFSX1ShiftLeft 				; x 10
.019ee4	ee 9c 03	inc $039c			inc 	ExpTemp 					; bump count of digits processed.
.019ee7	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.019ee9	29 0f		and #$0f			and 	#15
.019eeb	c8		iny				iny
.019eec	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.019eee	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019ef0	90 b8		bcc $019eaa			bcc 	_IFSLoop
.019ef2	f6 81		inc $81,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.019ef4	d0 b4		bne $019eaa			bne 	_IFSLoop
.019ef6	f6 82		inc $82,x			inc 	XS_Mantissa+2,x
.019ef8	d0 b0		bne $019eaa			bne 	_IFSLoop
.019efa	f6 83		inc $83,x			inc 	XS_Mantissa+3,x
.019efc	80 ac		bra $019eaa			bra 	_IFSLoop
.019efe					_IFSExit:
.019efe	98		tya				tya 								; get offset
.019eff					_IFSOkay:
.019eff	38		sec				sec
.019f00	ad 9c 03	lda $039c			lda 	ExpTemp
.019f03	f0 01		beq $019f06			beq 	_IFSSkipFail
.019f05	18		clc				clc
.019f06					_IFSSkipFail:
.019f06	68		pla				pla 								; and exit.
.019f07	60		rts				rts
.019f08					_IFSOverflow:
.019f08	20 79 85	jsr $018579			jsr 	ERR_Handler
>019f0b	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>019f13	20 6f 76 65 72 66 6c 6f 77 00
.019f1d					IFSX1ShiftLeft:
.019f1d	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.019f1f	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.019f21	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.019f23	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.019f25	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.019f26					FPSubtract:
.019f26	48		pha				pha
.019f27	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.019f29	49 80		eor #$80			eor 	#$80
.019f2b	95 8b		sta $8b,x			sta 	XS2_Type,x
.019f2d	68		pla				pla 								; --- and fall through ---
.019f2e					FPAdd:
.019f2e	48		pha				pha
.019f2f	b5 85		lda $85,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.019f31	d0 05		bne $019f38			bne 	_FPA_NegativeLHS
.019f33	20 4f 9f	jsr $019f4f			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.019f36	68		pla				pla
.019f37	60		rts				rts
.019f38					_FPA_NegativeLHS:
.019f38	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.019f3a	49 80		eor #$80			eor 	#$80
.019f3c	95 85		sta $85,x			sta 	XS_Type,x
.019f3e	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of B and add
.019f40	49 80		eor #$80			eor 	#$80
.019f42	95 8b		sta $8b,x			sta 	XS2_Type,x
.019f44	20 4f 9f	jsr $019f4f			jsr 	FPAdd_Worker 				; do the add calculation.
.019f47	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 back
.019f49	49 80		eor #$80			eor 	#$80
.019f4b	95 85		sta $85,x			sta 	XS_Type,x
.019f4d	68		pla				pla
.019f4e	60		rts				rts
.019f4f					FPAdd_Worker:
.019f4f	34 8b		bit $8b,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.019f51	70 07		bvs $019f5a			bvs 	_FPAWExit 					; no change.
.019f53	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.019f55	50 07		bvc $019f5e			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.019f57	20 cc a1	jsr $01a1cc			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.019f5a					_FPAWExit:
.019f5a	20 3b a2	jsr $01a23b			jsr 	FPUNormalise 				; normalise the result.
.019f5d	60		rts				rts
.019f5e					_FPAWMakeSame:
.019f5e	b5 84		lda $84,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.019f60	38		sec				sec
.019f61	f5 8a		sbc $8a,x			sbc	 	XS2_Exponent,x 				; using subtraction
.019f63	f0 16		beq $019f7b			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.019f65	da		phx				phx 								; save X
.019f66	90 06		bcc $019f6e			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.019f68	e8		inx				inx
.019f69	e8		inx				inx
.019f6a	e8		inx				inx
.019f6b	e8		inx				inx
.019f6c	e8		inx				inx
.019f6d	e8		inx				inx
.019f6e					_FPAWShiftA:
.019f6e	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.019f70	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.019f72	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.019f74	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.019f76	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.019f78	fa		plx				plx 								; restore original X
.019f79	80 e3		bra $019f5e			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.019f7b					_FPAW_DoArithmetic:
.019f7b	34 8b		bit $8b,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.019f7d	30 28		bmi $019fa7			bmi 	_FPAW_BNegative
.019f7f	18		clc				clc
.019f80	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019f82	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.019f84	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019f86	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019f88	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.019f8a	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019f8c	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019f8e	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.019f90	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019f92	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019f94	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.019f96	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019f98	90 c0		bcc $019f5a			bcc 	_FPAWExit 					; no carry.
.019f9a	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.019f9c	38		sec				sec
.019f9d	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.019f9f	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.019fa1	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.019fa3	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.019fa5	80 b3		bra $019f5a			bra 	_FPAWExit
.019fa7					_FPAW_BNegative:
.019fa7	38		sec				sec
.019fa8	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019faa	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.019fac	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019fae	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019fb0	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.019fb2	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019fb4	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019fb6	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.019fb8	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019fba	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019fbc	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.019fbe	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019fc0	b0 09		bcs $019fcb			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.019fc2	20 f2 a1	jsr $01a1f2			jsr 	FPUNegateInteger			; negate the mantissa
.019fc5	b5 85		lda $85,x			lda 	XS_Type,x 					; flip result sign
.019fc7	49 80		eor #$80			eor 	#$80
.019fc9	95 85		sta $85,x			sta 	XS_Type,x
.019fcb					_FPAWGoExit:
.019fcb	4c 5a 9f	jmp $019f5a			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.019fce					FPD_IsDivZero:
.019fce	20 79 85	jsr $018579			jsr ERR_Handler
>019fd1	44 69 76 69 73 69 6f 6e			.text "Division by zero",0
>019fd9	20 62 79 20 7a 65 72 6f 00
.019fe2					FPDivide:
.019fe2	48		pha				pha
.019fe3	5a		phy				phy
.019fe4	34 8b		bit $8b,x			bit 	XS2_Type,x 					; check if division by zero
.019fe6	70 e6		bvs $019fce			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.019fe8	34 85		bit $85,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.019fea	f0 03		beq $019fef			beq 	_FPDCalculateExp
.019fec					_FPD_Exit:
.019fec	7a		ply				ply
.019fed	68		pla				pla
.019fee	60		rts				rts
.019fef					_FPDCalculateExp:
.019fef	b5 8a		lda $8a,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.019ff1	49 ff		eor #$ff			eor 	#$FF
.019ff3	1a		inc a				inc 	a
.019ff4	95 8a		sta $8a,x			sta 	XS2_Exponent,x
.019ff6	20 c6 a0	jsr $01a0c6			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.019ff9	18		clc				clc 	 							; add 1 to the resulting exponent
.019ffa	69 01		adc #$01			adc 	#1
.019ffc	b0 54		bcs $01a052			bcs 	_FPD_Overflow 				; which can overflow.
.019ffe	95 84		sta $84,x			sta 	XS_Exponent,x
.01a000	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.01a002	85 1a		sta $1a				sta 	zLTemp1+0
.01a004	85 1b		sta $1b				sta 	zLTemp1+1
.01a006	85 1c		sta $1c				sta 	zLTemp1+2
.01a008	85 1d		sta $1d				sta 	zLTemp1+3
.01a00a	a0 20		ldy #$20			ldy 	#32 						; times round.
.01a00c					_FPD_Loop:
.01a00c	38		sec				sec 								; calculate X1-X2 stacking result because we might
.01a00d	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; not save it.
.01a00f	f5 86		sbc $86,x			sbc 	XS2_Mantissa,x
.01a011	48		pha				pha
.01a012	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a014	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.01a016	48		pha				pha
.01a017	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a019	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.01a01b	48		pha				pha
.01a01c	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a01e	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.01a020	90 13		bcc $01a035			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.01a022	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; save results out to A
.01a024	68		pla				pla
.01a025	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a027	68		pla				pla
.01a028	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a02a	68		pla				pla
.01a02b	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a02d	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.01a02f	09 80		ora #$80			ora 	#$80
.01a031	85 1d		sta $1d				sta 	zLTemp1+3
.01a033	80 03		bra $01a038			bra 	_FPD_Rotates
.01a035					_FPD_NoSubtract:
.01a035	68		pla				pla 								; throw away unwanted results
.01a036	68		pla				pla
.01a037	68		pla				pla
.01a038					_FPD_Rotates:
.01a038	56 89		lsr $89,x			lsr 	3+XS2_Mantissa,x
.01a03a	76 88		ror $88,x			ror 	2+XS2_Mantissa,x
.01a03c	76 87		ror $87,x			ror 	1+XS2_Mantissa,x
.01a03e	76 86		ror $86,x			ror 	0+XS2_Mantissa,x
.01a040	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.01a042	26 1b		rol $1b				rol 	zLTemp1+1
.01a044	26 1c		rol $1c				rol 	zLTemp1+2
.01a046	26 1d		rol $1d				rol 	zLTemp1+3
.01a048	90 02		bcc $01a04c			bcc 	_FPD_NoCarry
.01a04a	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.01a04c					_FPD_NoCarry:
.01a04c	88		dey				dey 								; do 32 times
.01a04d	d0 bd		bne $01a00c			bne 	_FPD_Loop
.01a04f	4c aa a0	jmp $01a0aa			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.01a052					_FPD_Overflow:
.01a052	4c 98 a2	jmp $01a298			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.01a055					FPMultiply:
.01a055	48		pha				pha
.01a056	5a		phy				phy
.01a057	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.01a059	70 07		bvs $01a062			bvs 	_FPM_Exit
.01a05b	34 8b		bit $8b,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.01a05d	50 06		bvc $01a065			bvc 	_FPM_CalcExponent
.01a05f	20 cc a1	jsr $01a1cc			jsr 	FPUCopyX2ToX1
.01a062					_FPM_Exit:
.01a062	7a		ply				ply
.01a063	68		pla				pla
.01a064	60		rts				rts
.01a065					_FPM_CalcExponent:
.01a065	18		clc				clc
.01a066	20 c6 a0	jsr $01a0c6			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.01a069	95 84		sta $84,x			sta 	XS_Exponent,x 				; save the result.
.01a06b	a9 00		lda #$00			lda 	#0
.01a06d	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.01a06f	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.01a071	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.01a073	85 1d		sta $1d				sta 	zLTemp1+3
.01a075	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.01a077					_FPM_Loop:
.01a077	b5 80		lda $80,x			lda 	XS_Mantissa,x				; check LSB of long product
.01a079	29 01		and #$01			and 	#1
.01a07b	18		clc				clc 								; clear carry for the long rotate.
.01a07c	f0 19		beq $01a097			beq 	_FPM_NoAddition
.01a07e	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.01a07f	a5 1a		lda $1a				lda 	zLTemp1+0
.01a081	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.01a083	85 1a		sta $1a				sta 	zLTemp1+0
.01a085	a5 1b		lda $1b				lda 	zLTemp1+1
.01a087	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.01a089	85 1b		sta $1b				sta 	zLTemp1+1
.01a08b	a5 1c		lda $1c				lda 	zLTemp1+2
.01a08d	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.01a08f	85 1c		sta $1c				sta 	zLTemp1+2
.01a091	a5 1d		lda $1d				lda 	zLTemp1+3
.01a093	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.01a095	85 1d		sta $1d				sta 	zLTemp1+3
.01a097					_FPM_NoAddition:
.01a097	66 1d		ror $1d				ror 	3+zLTemp1
.01a099	66 1c		ror $1c				ror 	2+zLTemp1
.01a09b	66 1b		ror $1b				ror 	1+zLTemp1
.01a09d	66 1a		ror $1a				ror 	0+zLTemp1
.01a09f	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.01a0a1	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a0a3	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a0a5	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a0a7	88		dey				dey
.01a0a8	d0 cd		bne $01a077			bne 	_FPM_Loop 					; do this 32 times.
.01a0aa					FPM_CopySignNormalize:
.01a0aa	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.01a0ac	95 80		sta $80,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.01a0ae	a5 1b		lda $1b				lda 	zLTemp1+1
.01a0b0	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a0b2	a5 1c		lda $1c				lda 	zLTemp1+2
.01a0b4	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a0b6	a5 1d		lda $1d				lda 	zLTemp1+3
.01a0b8	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a0ba	b5 85		lda $85,x			lda 	XS_Type,x 					; sign is xor of signs
.01a0bc	55 8b		eor $8b,x			eor 	XS2_Type,x
.01a0be	95 85		sta $85,x			sta 	XS_Type,x
.01a0c0	20 3b a2	jsr $01a23b			jsr 	FPUNormalise 				; normalise and exit.
.01a0c3	7a		ply				ply
.01a0c4	68		pla				pla
.01a0c5	60		rts				rts
.01a0c6					FPCalculateExponent:
.01a0c6	18		clc				clc
.01a0c7	b5 84		lda $84,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.01a0c9	75 8a		adc $8a,x			adc 	XS2_Exponent,x
.01a0cb	b0 08		bcs $01a0d5			bcs 	_FPCECarry 					; carry out ?
.01a0cd	10 03		bpl $01a0d2			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.01a0cf	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.01a0d1	60		rts				rts
.01a0d2					_FPCEExpZero:
.01a0d2	a9 00		lda #$00			lda 	#0
.01a0d4	60		rts				rts
.01a0d5					_FPCECarry:
.01a0d5	30 03		bmi $01a0da			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.01a0d7	09 80		ora #$80			ora 	#$80 						; put in right range
.01a0d9	60		rts				rts
.01a0da					_FPCEOverflow:
.01a0da	4c 98 a2	jmp $01a298			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.01a0dd					FPFractionalPart:
.01a0dd	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.01a0df	38		sec				sec 								; this flag tells us to keep the fractional part
.01a0e0	30 0d		bmi $01a0ef			bmi 	FPGetPart
.01a0e2	60		rts				rts
.01a0e3					FPIntegerPart:
.01a0e3	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.01a0e5	18		clc				clc 								; this flag says keep the integer part.
.01a0e6	30 07		bmi $01a0ef			bmi 	FPGetPart 					; -ve exponents are 0..127
.01a0e8	48		pha				pha
.01a0e9	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.01a0eb	95 85		sta $85,x			sta 	XS_Type,x
.01a0ed	68		pla				pla
.01a0ee	60		rts				rts
.01a0ef					FPGetPart:
.01a0ef	48		pha				pha
.01a0f0	5a		phy				phy 								; save Y
.01a0f1	08		php				php 								; save action
.01a0f2	34 85		bit $85,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.01a0f4	70 59		bvs $01a14f			bvs 	_FPGP_Exit 					; then do nothing.
.01a0f6	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.01a0f8	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.01a0fa	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.01a0fc	85 1c		sta $1c				sta 	zLTemp1+2
.01a0fe	85 1d		sta $1d				sta 	zLTemp1+3
.01a100	b5 84		lda $84,x			lda 	XS_Exponent,x				; the number of shifts.
.01a102	38		sec				sec
.01a103	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.01a105	f0 12		beq $01a119			beq 	_FPGP_NoShift 				; ... if any
.01a107	c9 20		cmp #$20			cmp 	#32
.01a109	90 02		bcc $01a10d			bcc 	_FPGP_NotMax
.01a10b	a9 20		lda #$20			lda 	#32 						; max of 32.
.01a10d					_FPGP_NotMax:
.01a10d	a8		tay				tay 								; Y is the mask shift count.
.01a10e					_FPGP_ShiftMask:
.01a10e	46 1d		lsr $1d				lsr 	3+zLTemp1
.01a110	66 1c		ror $1c				ror 	2+zLTemp1
.01a112	66 1b		ror $1b				ror 	1+zLTemp1
.01a114	66 1a		ror $1a				ror 	0+zLTemp1
.01a116	88		dey				dey
.01a117	d0 f5		bne $01a10e			bne 	_FPGP_ShiftMask
.01a119					_FPGP_NoShift:
.01a119	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.01a11b	8e 9c 03	stx $039c			stx 	ExpTemp						; save X
.01a11e					_FPGP_MaskLoop:
.01a11e	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.01a121	28		plp				plp 								; if CC we keep the top part, so we
.01a122	08		php				php		 							; flip the mask.
.01a123	b0 02		bcs $01a127			bcs		_FPGP_NoFlip
.01a125	49 ff		eor #$ff			eor 	#$FF
.01a127					_FPGP_NoFlip:
.01a127	35 80		and $80,x			and 	XS_Mantissa,x 				; and into the mantissa.
.01a129	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a12b	e8		inx				inx
.01a12c	c8		iny				iny
.01a12d	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.01a12f	d0 ed		bne $01a11e			bne 	_FPGP_MaskLoop
.01a131	ae 9c 03	ldx $039c			ldx 	ExpTemp						; restore X
.01a134	28		plp				plp
.01a135	08		php				php 								; get action flag on the stack
.01a136	90 04		bcc $01a13c			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.01a138	a9 00		lda #$00			lda 	#0
.01a13a	95 85		sta $85,x			sta 	XS_Type,x
.01a13c					_FPGP_NotFractional:
.01a13c	b5 80		lda $80,x			lda 	XS_Mantissa,x 						; check if \1 zero
.01a13e	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.01a140	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01a142	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01a144	f0 05		beq $01a14b			beq 	_FPGP_Zero 					; if zero, return zero
.01a146	20 3b a2	jsr $01a23b			jsr 	FPUNormalise
.01a149	80 04		bra $01a14f			bra 	_FPGP_Exit 					; and exit
.01a14b					_FPGP_Zero:
.01a14b	a9 40		lda #$40			lda 	#$40 						; set zero flag
.01a14d	95 85		sta $85,x			sta 	XS_Type,x
.01a14f					_FPGP_Exit:
.01a14f	68		pla				pla 								; throw saved action flag.
.01a150	7a		ply				ply
.01a151	68		pla				pla
.01a152	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.01a153					FPCompare:
.01a153	20 94 a1	jsr $01a194			jsr 	FPFastCompare 				; fast compare try first
.01a156	b0 3b		bcs $01a193			bcs 	_FPCExit 					; that worked.
.01a158	b5 84		lda $84,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.01a15a	48		pha				pha
.01a15b	b5 8a		lda $8a,x			lda 	XS2_Exponent,x
.01a15d	48		pha				pha
.01a15e	20 26 9f	jsr $019f26			jsr 	FPSubtract 					; calculate X1-X2
.01a161	34 85		bit $85,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.01a163	70 2a		bvs $01a18f			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.01a165	68		pla				pla
.01a166	8d 9c 03	sta $039c			sta 	ExpTemp						; save first exponent in temporary reg.
.01a169	68		pla				pla
.01a16a	38		sec				sec
.01a16b	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; calculate AX-BX
.01a16e	70 14		bvs $01a184			bvs 	_FPCNotEqual				; overflow, can't be equal.
.01a170	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.01a171	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.01a173	b0 0f		bcs $01a184			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.01a175	38		sec				sec
.01a176	ad 9c 03	lda $039c			lda 	ExpTemp 					; get one of the exponents back.
.01a179	e9 12		sbc #$12			sbc 	#18 						; allow for 2^18 error, relatively.
.01a17b	b0 02		bcs $01a17f			bcs 	_FPCNotRange 				; keep in range.
.01a17d	a9 01		lda #$01			lda 	#1
.01a17f					_FPCNotRange:
.01a17f	38		sec				sec
.01a180	f5 84		sbc $84,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.01a182	b0 0d		bcs $01a191			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.01a184					_FPCNotEqual:
.01a184	b5 85		lda $85,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.01a186	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.01a188	f0 02		beq $01a18c			beq 	_FPCNE2
.01a18a	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.01a18c	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.01a18d	80 04		bra $01a193			bra 	_FPCExit
.01a18f					_FPCPullZero:
.01a18f	68		pla				pla 								; throw saved exponents
.01a190	68		pla				pla
.01a191					_FPCZero:
.01a191	a9 00		lda #$00			lda 	#0 							; and return zero
.01a193					_FPCExit:
.01a193	60		rts				rts
.01a194					FPFastCompare:
.01a194	34 85		bit $85,x			bit 	XS_Type,x 					; n1 is zero.
.01a196	70 23		bvs $01a1bb			bvs 	_FPFLeftZero
.01a198	34 8b		bit $8b,x			bit 	XS2_Type,x 					; n2 is zero
.01a19a	b5 85		lda $85,x			lda 	XS_Type,x 					; if so, return sign bit of 1 (n-0)
.01a19c	70 25		bvs $01a1c3			bvs 	_FPFSignBit
.01a19e	55 8b		eor $8b,x			eor 	XS2_Type,x 					; eor 2 type bits. now know both non-zero
.01a1a0	0a		asl a				asl 	a 							; put in CS if different.
.01a1a1	b5 85		lda $85,x			lda 	XS_Type,x 					; if signs different return sign of first
.01a1a3	b0 1e		bcs $01a1c3			bcs 	_FPFSignBit
.01a1a5	38		sec				sec 								; same sign and not-zero. compare exponents
.01a1a6	b5 84		lda $84,x			lda 	XS_Exponent,x 				; compare exponents. if the same, then fail.
.01a1a8	f5 8a		sbc $8a,x			sbc 	XS2_Exponent,x 				; e.g. we have to do it via subtraction.
.01a1aa	f0 09		beq $01a1b5			beq 	_FPNoFastCompare
.01a1ac	6a		ror a				ror 	a 							; put carry into bit 7.
.01a1ad	34 85		bit $85,x			bit 	XS_Type,X 					; if it is +x then flip it.
.01a1af	30 02		bmi $01a1b3			bmi		_FPFCNotMinus
.01a1b1	49 80		eor #$80			eor 	#$80
.01a1b3					_FPFCNotMinus:
.01a1b3	80 0e		bra $01a1c3			bra		_FPFSignBit
.01a1b5					_FPNoFastCompare:
.01a1b5	18		clc				clc
.01a1b6	60		rts				rts
.01a1b7					_FPFZero:
.01a1b7	a9 00		lda #$00			lda 	#0
.01a1b9					_FPFExitSet:
.01a1b9	38		sec				sec
.01a1ba	60		rts				rts
.01a1bb					_FPFLeftZero:
.01a1bb	34 8b		bit $8b,x			bit 	XS2_Type,x 					; if right is zero, return zero.
.01a1bd	70 f8		bvs $01a1b7			bvs 	_FPFZero
.01a1bf	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip sign bit
.01a1c1	49 80		eor #$80			eor 	#$80						; return that as a sign.
.01a1c3					_FPFSignBit:
.01a1c3	0a		asl a				asl 	a
.01a1c4	a9 01		lda #$01			lda 	#1
.01a1c6	90 f1		bcc $01a1b9			bcc		_FPFExitSet
.01a1c8	a9 ff		lda #$ff			lda 	#$FF
.01a1ca	38		sec				sec
.01a1cb	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.01a1cc					FPUCopyX2ToX1:
.01a1cc	48		pha				pha
.01a1cd	da		phx				phx
.01a1ce	5a		phy				phy
.01a1cf	a0 08		ldy #$08			ldy 	#8
.01a1d1	b5 86		lda $86,x	_FPUC21:lda 	XS2_Mantissa,x
.01a1d3	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a1d5	e8		inx				inx
.01a1d6	88		dey				dey
.01a1d7	10 f8		bpl $01a1d1			bpl 	_FPUC21
.01a1d9	7a		ply				ply
.01a1da	fa		plx				plx
.01a1db	68		pla				pla
.01a1dc	60		rts				rts
.01a1dd					FPUSetInteger:
.01a1dd	48		pha				pha
.01a1de	95 80		sta $80,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.01a1e0	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.01a1e2	10 02		bpl $01a1e6			bpl 	_FPUSIExtend
.01a1e4	a9 ff		lda #$ff			lda 	#$FF
.01a1e6					_FPUSIExtend:
.01a1e6	95 81		sta $81,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.01a1e8	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a1ea	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a1ec	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.01a1ee	95 85		sta $85,x			sta 	XS_Type,x
.01a1f0	68		pla				pla
.01a1f1	60		rts				rts
.01a1f2					FPUNegateInteger:
.01a1f2	48		pha				pha
.01a1f3	38		sec				sec
.01a1f4	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.01a1f6	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.01a1f8	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a1fa	a9 00		lda #$00			lda 	#0
.01a1fc	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.01a1fe	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a200	a9 00		lda #$00			lda 	#0
.01a202	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.01a204	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a206	a9 00		lda #$00			lda 	#0
.01a208	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.01a20a	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a20c	68		pla				pla
.01a20d	60		rts				rts
.01a20e					FPUToFloat:
.01a20e	48		pha				pha
.01a20f	b5 85		lda $85,x			lda 	XS_Type,x					; exit if already float.
.01a211	29 0f		and #$0f			and 	#$0F
.01a213	f0 24		beq $01a239			beq 	_FPUFExit
.01a215	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.01a217	95 85		sta $85,x			sta 	XS_Type,x
.01a219	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.01a21b	95 84		sta $84,x			sta 	XS_Exponent,x 				; x mantissa.
.01a21d	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.01a21f	10 07		bpl $01a228			bpl		_FPUFPositive
.01a221	20 f2 a1	jsr $01a1f2			jsr 	FPUNegateInteger 			; negate the mantissa
.01a224	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.01a226	95 85		sta $85,x			sta 	XS_Type,x
.01a228					_FPUFPositive:
.01a228	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.01a22a	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.01a22c	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01a22e	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01a230	d0 04		bne $01a236			bne 	_FPUFNonZero
.01a232	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.01a234	95 85		sta $85,x			sta 	XS_Type,x
.01a236					_FPUFNonZero:
.01a236	20 3b a2	jsr $01a23b			jsr 	FPUNormalise 				; normalise the floating point.
.01a239					_FPUFExit:
.01a239	68		pla				pla
.01a23a	60		rts				rts
.01a23b					FPUNormalise:
.01a23b	48		pha				pha
.01a23c	34 85		bit $85,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.01a23e	70 18		bvs $01a258			bvs 	_FPUNExit
.01a240	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.01a242	f0 10		beq $01a254			beq 	_FPUNSetZero
.01a244					_FPUNLoop:
.01a244	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.01a246	30 10		bmi $01a258			bmi 	_FPUNExit 					; if so, we are normalised.
.01a248	16 80		asl $80,x			asl 	0+XS_Mantissa+0,x
.01a24a	36 81		rol $81,x			rol 	1+XS_Mantissa+0,x
.01a24c	36 82		rol $82,x			rol 	2+XS_Mantissa+0,x
.01a24e	36 83		rol $83,x			rol 	3+XS_Mantissa+0,x
.01a250	d6 84		dec $84,x			dec 	XS_Exponent,x 				; decrement exponent
.01a252	d0 f0		bne $01a244			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.01a254					_FPUNSetZero:
.01a254	a9 40		lda #$40			lda 	#$40
.01a256	95 85		sta $85,x			sta 	XS_Type,x 					; the result is now zero.
.01a258					_FPUNExit:
.01a258	68		pla				pla
.01a259	60		rts				rts
.01a25a					FPUToInteger:
.01a25a	48		pha				pha
.01a25b	b5 85		lda $85,x			lda 	XS_Type,x 					; if already integer, exit
.01a25d	29 01		and #$01			and 	#1
.01a25f	d0 31		bne $01a292			bne 	_FPUTOI_Exit
.01a261	34 85		bit $85,x			bit 	XS_Type,x					; if zero, return zero.
.01a263	70 23		bvs $01a288			bvs 	_FPUTOI_Zero
.01a265	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.01a267	10 1f		bpl $01a288			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.01a269	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.01a26b	b0 2b		bcs $01a298			bcs 	FP_Overflow
.01a26d					_FPUToIToInteger:
.01a26d	b5 84		lda $84,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.01a26f	c9 a0		cmp #$a0			cmp 	#128+32
.01a271	f0 0c		beq $01a27f			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.01a273	f6 84		inc $84,x			inc 	XS_Exponent,X 				; increment Exponent
.01a275	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.01a277	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a279	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a27b	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a27d	80 ee		bra $01a26d			bra 	_FPUToIToInteger 			; keep going.
.01a27f					_FPUToICheckSign:
.01a27f	b5 85		lda $85,x			lda 	XS_Type,x 					; check sign
.01a281	10 0f		bpl $01a292			bpl 	_FPUToI_Exit 				; exit if unsigned.
.01a283	20 f2 a1	jsr $01a1f2			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.01a286	80 0a		bra $01a292			bra 	_FPUTOI_Exit
.01a288					_FPUTOI_Zero:
.01a288	a9 00		lda #$00			lda 	#0 							; return zero integer.
.01a28a	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a28c	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a28e	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a290	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a292					_FPUToI_Exit:
.01a292	a9 01		lda #$01			lda 	#1 							; set type to integer
.01a294	95 85		sta $85,x			sta 	XS_Type,x
.01a296	68		pla				pla
.01a297	60		rts				rts
.01a298					FP_Overflow:
.01a298	20 79 85	jsr $018579			jsr ERR_Handler
>01a29b	46 6c 6f 61 74 69 6e 67			.text "Floating Point overflow",0
>01a2a3	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.01a2b3					FPUTimes10:
.01a2b3	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.01a2b5	85 1a		sta $1a				sta 	ZLTemp1+0
.01a2b7	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a2b9	85 1b		sta $1b				sta 	ZLTemp1+1
.01a2bb	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a2bd	85 1c		sta $1c				sta 	ZLTemp1+2
.01a2bf	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a2c1	85 1d		sta $1d				sta 	ZLTemp1+3
.01a2c3	20 f8 a2	jsr $01a2f8			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.01a2c6	20 f8 a2	jsr $01a2f8			jsr 	_FPUT_LSR_ZLTemp1
.01a2c9	18		clc				clc
.01a2ca	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.01a2cc	65 1a		adc $1a				adc 	ZLTemp1+0
.01a2ce	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a2d0	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a2d2	65 1b		adc $1b				adc 	ZLTemp1+1
.01a2d4	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a2d6	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a2d8	65 1c		adc $1c				adc 	ZLTemp1+2
.01a2da	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a2dc	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a2de	65 1d		adc $1d				adc 	ZLTemp1+3
.01a2e0	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a2e2	90 0a		bcc $01a2ee			bcc 	_FPUTimes10
.01a2e4	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.01a2e6	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a2e8	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a2ea	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a2ec	f6 84		inc $84,x			inc 	XS_Exponent,x				; fix exponent
.01a2ee					_FPUTimes10:
.01a2ee	b5 84		lda $84,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.01a2f0	18		clc				clc
.01a2f1	69 03		adc #$03			adc 	#3
.01a2f3	95 84		sta $84,x			sta 	XS_Exponent,x
.01a2f5	b0 a1		bcs $01a298			bcs 	FP_Overflow 				; error
.01a2f7	60		rts				rts
.01a2f8					_FPUT_LSR_ZLTemp1:
.01a2f8	46 1d		lsr $1d				lsr 	ZLTemp1+3
.01a2fa	66 1c		ror $1c				ror 	ZLTemp1+2
.01a2fc	66 1b		ror $1b				ror 	ZLTemp1+1
.01a2fe	66 1a		ror $1a				ror 	ZLTemp1+0
.01a300	60		rts				rts
.01a301					FPUScale10A:
.01a301	5a		phy				phy
.01a302	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.01a304	f0 37		beq $01a33d			beq 	_FPUScaleExit
.01a306	da		phx				phx 								; save X
.01a307	e8		inx				inx
.01a308	e8		inx				inx
.01a309	e8		inx				inx
.01a30a	e8		inx				inx
.01a30b	e8		inx				inx
.01a30c	e8		inx				inx
.01a30d	a8		tay				tay 								; save power scalar in Y.
.01a30e	a9 00		lda #$00			lda 	#0
.01a310	95 80		sta $80,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.01a312	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a314	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a316	95 85		sta $85,x			sta 	XS_Type,x
.01a318	a9 80		lda #$80			lda 	#$80
.01a31a	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a31c	a9 81		lda #$81			lda 	#$81
.01a31e	95 84		sta $84,x			sta 	XS_Exponent,x
.01a320	5a		phy				phy 								; save 10^n on stack.
.01a321	c0 00		cpy #$00			cpy 	#0
.01a323	10 05		bpl $01a32a			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.01a325	98		tya				tya
.01a326	49 ff		eor #$ff			eor 	#$FF
.01a328	1a		inc a				inc 	a
.01a329	a8		tay				tay
.01a32a					_FPUSAbs:
.01a32a	20 b3 a2	jsr $01a2b3			jsr 	FPUTimes10
.01a32d	88		dey				dey
.01a32e	d0 fa		bne $01a32a			bne 	_FPUSAbs 					; tos is now 10^|AC|
.01a330	68		pla				pla 								; restore count in A
.01a331	fa		plx				plx 								; restore X pointing to number to scale.
.01a332	0a		asl a				asl 	a
.01a333	b0 05		bcs $01a33a			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.01a335	20 55 a0	jsr $01a055			jsr 	FPMultiply 					; if clear multiply.
.01a338	80 03		bra $01a33d			bra		_FPUScaleExit
.01a33a					_FPUSDivide:
.01a33a	20 e2 9f	jsr $019fe2			jsr 	FPDivide
.01a33d					_FPUScaleExit:
.01a33d	7a		ply				ply
.01a33e	60		rts				rts
.01a33f					FPUCopyToNext:
.01a33f	a0 06		ldy #$06			ldy 		#6
.01a341	da		phx				phx
.01a342					_FPUCopy1:
.01a342	b5 80		lda $80,x			lda 	XS_Mantissa,x
.01a344	95 86		sta $86,x			sta 	XS2_Mantissa,x
.01a346	e8		inx				inx
.01a347	88		dey				dey
.01a348	d0 f8		bne $01a342			bne 	_FPUCopy1
.01a34a	fa		plx				plx
.01a34b	60		rts				rts
.01a34c					FPUCopyFromNext:
.01a34c	a0 06		ldy #$06			ldy 		#6
.01a34e	da		phx				phx
.01a34f					_FPUCopy1:
.01a34f	b5 86		lda $86,x			lda 	XS2_Mantissa,x
.01a351	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a353	e8		inx				inx
.01a354	88		dey				dey
.01a355	d0 f8		bne $01a34f			bne 	_FPUCopy1
.01a357	fa		plx				plx
.01a358	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.01a359					FPToString:
.01a359	48		pha				pha
.01a35a	5a		phy				phy
.01a35b	34 85		bit $85,x			bit 		XS_Type,x 				; check zero flag
.01a35d	50 0a		bvc $01a369			bvc 		_FPTSIsFloat 			; if zero,
.01a35f					_FPTSZero:
.01a35f	a9 30		lda #$30			lda 		#"0"
.01a361	20 83 9e	jsr $019e83			jsr 		ITSOutputCharacter
.01a364					_FPTSExit:
.01a364	7a		ply				ply
.01a365	68		pla				pla
.01a366	60		rts				rts
.01a367	80 fb		bra $01a364			bra 		_FPTSExit
.01a369					_FPTSIsFloat:
.01a369	b5 85		lda $85,x			lda 		XS_Type,x 				; is it signed ?
.01a36b	10 09		bpl $01a376			bpl 		_FPTSNotSigned
.01a36d	a9 00		lda #$00			lda 		#0 						; clear sign flag
.01a36f	95 85		sta $85,x			sta 		XS_Type,x
.01a371	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.01a373	20 83 9e	jsr $019e83			jsr 		ITSOutputCharacter
.01a376					_FPTSNotSigned:
.01a376	b5 84		lda $84,x			lda 		XS_Exponent,x
.01a378	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.01a37a	b0 09		bcs $01a385			bcs 		_FPTSExponent
.01a37c	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.01a37e	90 05		bcc $01a385			bcc 		_FPTSExponent 			;
.01a380					_FPTSStandard:
.01a380	20 c4 a3	jsr $01a3c4			jsr 		FPTOutputBody 			; output the body.
.01a383	80 df		bra $01a364			bra 		_FPTSExit
.01a385					_FPTSExponent:
.01a385	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.01a387	8d 9d 03	sta $039d			sta 		ExpCount
.01a38a					_FPTSExponentLoop:
.01a38a	b5 84		lda $84,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.01a38c	10 0e		bpl $01a39c			bpl 		_FPTSTimes
.01a38e	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.01a390	90 14		bcc $01a3a6			bcc 		_FPTSScaledToExp
.01a392	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.01a394	20 01 a3	jsr $01a301			jsr 		FPUScale10A
.01a397	ee 9d 03	inc $039d			inc 		ExpCount
.01a39a	80 ee		bra $01a38a			bra 		_FPTSExponentLoop
.01a39c					_FPTSTimes:
.01a39c	a9 01		lda #$01			lda 		#1
.01a39e	20 01 a3	jsr $01a301			jsr 		FPUScale10A
.01a3a1	ce 9d 03	dec $039d			dec 		ExpCount
.01a3a4	80 e4		bra $01a38a			bra 		_FPTSExponentLoop
.01a3a6					_FPTSScaledToExp:
.01a3a6	20 c4 a3	jsr $01a3c4			jsr 		FPTOutputBody 			; output the body.
.01a3a9	a9 65		lda #$65			lda 		#"e"					; output E
.01a3ab	20 83 9e	jsr $019e83			jsr 		ITSOutputCharacter
.01a3ae	ad 9d 03	lda $039d			lda 		ExpCount 				; get the exponent
.01a3b1	95 80		sta $80,x			sta 		XS_Mantissa,x
.01a3b3	29 80		and #$80			and 		#$80 					; sign extend it
.01a3b5	f0 02		beq $01a3b9			beq 		_FPTSSExt
.01a3b7	a9 ff		lda #$ff			lda 		#$FF
.01a3b9					_FPTSSExt:
.01a3b9	95 81		sta $81,x			sta 		XS_Mantissa+1,x
.01a3bb	95 82		sta $82,x			sta 		XS_Mantissa+2,x
.01a3bd	95 83		sta $83,x			sta 		XS_Mantissa+3,x
.01a3bf	20 e1 9d	jsr $019de1			jsr 		INTToString 			; output the exponent.
.01a3c2	80 a0		bra $01a364			bra			_FPTSExit 				; and exit.
.01a3c4					FPTOutputBody:
.01a3c4	20 3f a3	jsr $01a33f			jsr 		FPUCopyToNext 			; copy to next slot.
.01a3c7	20 5a a2	jsr $01a25a			jsr 		FPUToInteger 			; convert to an integer
.01a3ca	20 e1 9d	jsr $019de1			jsr 		INTToString 			; output the main integer part.
.01a3cd	20 4c a3	jsr $01a34c			jsr 		FPUCopyFromNext 		; get the fractional part back.
.01a3d0	20 dd a0	jsr $01a0dd			jsr 		FPFractionalPart 		; get the decimal part.
.01a3d3	34 85		bit $85,x			bit 		XS_Type,x 				; any fractional part.
.01a3d5	70 3c		bvs $01a413			bvs 		_FPTOExit 				; if not, exit now.
.01a3d7	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.01a3d9	20 83 9e	jsr $019e83			jsr 		ITSOutputCharacter
.01a3dc					_FPOutLoop:
.01a3dc	34 85		bit $85,x			bit 		XS_Type,x 				; finally reached zero.
.01a3de	70 1d		bvs $01a3fd			bvs 		_FPStripZeros 			; strip trailing zeros
.01a3e0	20 b3 a2	jsr $01a2b3			jsr 		FPUTimes10 				; multiply by 10
.01a3e3	20 3f a3	jsr $01a33f			jsr 		FPUCopyToNext			; copy to next slot.
.01a3e6	20 5a a2	jsr $01a25a			jsr 		FPUToInteger 			; convert to integer
.01a3e9	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; print digit.
.01a3eb	09 30		ora #$30			ora 		#"0"
.01a3ed	20 83 9e	jsr $019e83			jsr 		ITSOutputCharacter
.01a3f0	20 4c a3	jsr $01a34c			jsr 		FPUCopyFromNext 		; get it back
.01a3f3	20 dd a0	jsr $01a0dd			jsr 		FPFractionalPart 		; get fractional part
.01a3f6	ad 14 03	lda $0314			lda 		NumBufX 				; done 11 characters yet ?
.01a3f9	c9 0b		cmp #$0b			cmp 	 	#11
.01a3fb	90 df		bcc $01a3dc			bcc 		_FPOutLoop 				; if so, keep going till zero.
.01a3fd					_FPStripZeros:
.01a3fd	ac 14 03	ldy $0314			ldy 		NumBufX 				; strip trailing zeros.
.01a400					_FPStripLoop:
.01a400	88		dey				dey 								; back one, if at start then no strip
.01a401	f0 10		beq $01a413			beq 		_FPToExit
.01a403	b9 15 03	lda $0315,y			lda 		Num_Buffer,y 			; keep going if "0"
.01a406	c9 30		cmp #$30			cmp 		#"0"
.01a408	f0 f6		beq $01a400			beq 		_FPStripLoop
.01a40a	c8		iny				iny
.01a40b	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.01a40d	99 15 03	sta $0315,y			sta 		Num_Buffer,y
.01a410	8c 14 03	sty $0314			sty 		NumBufX 				; update position.
.01a413					_FPTOExit:
.01a413	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.01a414					FPFromString:
.01a414	48		pha				pha 								; push A
.01a415	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.01a417	c9 2e		cmp #$2e			cmp 	#"."
.01a419	f0 03		beq $01a41e			beq	 	_FPFIsDecimal
.01a41b	4c 7a a4	jmp $01a47a			jmp 	_FPFNotDecimal
.01a41e					_FPFIsDecimal:
.01a41e	c8		iny				iny 								; consume the decimal.
.01a41f	20 0e a2	jsr $01a20e			jsr 	FPUToFloat 					; convert the integer to float.
.01a422	da		phx				phx 								; save X.
.01a423	5a		phy				phy 								; save decimal start position
.01a424	e8		inx				inx
.01a425	e8		inx				inx
.01a426	e8		inx				inx
.01a427	e8		inx				inx
.01a428	e8		inx				inx
.01a429	e8		inx				inx
.01a42a	20 9b 9e	jsr $019e9b			jsr 	INTFromStringY 				; get the part after the DP.
.01a42d	20 0e a2	jsr $01a20e			jsr 	FPUToFloat 					; convert that to a float.
.01a430	68		pla				pla 								; calculate - chars consumed.
.01a431	8c 9c 03	sty $039c			sty 	ExpTemp
.01a434	38		sec				sec
.01a435	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; this is the shift amount
.01a438	20 01 a3	jsr $01a301			jsr 	FPUScale10A 				; scale it by 10^AC
.01a43b	fa		plx				plx 								; restore original X
.01a43c	20 2e 9f	jsr $019f2e			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.01a43f	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.01a441	c9 45		cmp #$45			cmp 	#"E"
.01a443	f0 04		beq $01a449			beq 	_FPFExponent
.01a445	c9 65		cmp #$65			cmp 	#"e"
.01a447	d0 31		bne $01a47a			bne 	_FPFNotDecimal 				; no, then exit normally.
.01a449					_FPFExponent:
.01a449	c8		iny				iny 								; skip over E symbol.
.01a44a	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.01a44c	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.01a44e	d0 01		bne $01a451			bne 	_FPFGotSign
.01a450	c8		iny				iny 								; if it was - skip over it.
.01a451					_FPFGotSign:
.01a451	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.01a452	da		phx				phx
.01a453	e8		inx				inx
.01a454	e8		inx				inx
.01a455	e8		inx				inx
.01a456	e8		inx				inx
.01a457	e8		inx				inx
.01a458	e8		inx				inx
.01a459	20 9b 9e	jsr $019e9b			jsr 	INTFromStringY 				; get the exponent
.01a45c	fa		plx				plx 								; restore X.
.01a45d	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.01a45f	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.01a461	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.01a463	d0 17		bne $01a47c			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.01a465	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.01a467	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.01a469	b0 11		bcs $01a47c			bcs 	_FPFXOverflow
.01a46b	68		pla				pla 								; get direction
.01a46c	d0 07		bne $01a475			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.01a46e	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.01a470	49 ff		eor #$ff			eor 	#$FF
.01a472	1a		inc a				inc 	a
.01a473	95 86		sta $86,x			sta 	XS2_Mantissa+0,x
.01a475					_FPFXScale:
.01a475	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.01a477	20 01 a3	jsr $01a301			jsr 	FPUScale10A 				; scale by the exponent.
.01a47a					_FPFNotDecimal:
.01a47a	68		pla				pla
.01a47b	60		rts				rts
.01a47c					_FPFXOverflow:
.01a47c	20 79 85	jsr $018579			jsr 	ERR_Handler
>01a47f	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>01a487	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.01a48e					Unary_Rnd:
.01a48e	20 0e 92	jsr $01920e			jsr 	EvaluateNumberX 			; get value
.01a491	20 5e 98	jsr $01985e			jsr 	CheckNextRParen 			; check right bracket.
.01a494	20 8c 94	jsr $01948c			jsr 	GetSignCurrent 				; get sign -1,0,1.
.01a497	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.01a499	30 10		bmi $01a4ab			bmi 	_URSetSeed
.01a49b	f0 28		beq $01a4c5			beq 	_URMakeRandom 				; if zero return same number.
.01a49d	da		phx				phx
.01a49e	a2 00		ldx #$00			ldx 	#0
.01a4a0	20 fc a4	jsr $01a4fc			jsr 	Random16
.01a4a3	a2 02		ldx #$02			ldx 	#2
.01a4a5	20 fc a4	jsr $01a4fc			jsr 	Random16
.01a4a8	fa		plx				plx
.01a4a9	80 1a		bra $01a4c5			bra 	_URMakeRandom
.01a4ab					_URSetSeed:
.01a4ab	20 0e a2	jsr $01a20e			jsr 	FPUToFloat 					; make it a float to twiddle it.
.01a4ae	b5 80		lda $80,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.01a4b0	8d a3 03	sta $03a3			sta 	RandomSeed+0
.01a4b3	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.01a4b5	8d a4 03	sta $03a4			sta 	RandomSeed+1
.01a4b8	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.01a4ba	8d a5 03	sta $03a5			sta 	RandomSeed+2
.01a4bd	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.01a4bf	0a		asl a				asl 	a
.01a4c0	49 db		eor #$db			eor 	#$DB
.01a4c2	8d a6 03	sta $03a6			sta 	RandomSeed+3
.01a4c5					_URMakeRandom:
.01a4c5	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; check if seed is zero.
.01a4c8	0d a4 03	ora $03a4			ora 	RandomSeed+1
.01a4cb	0d a5 03	ora $03a5			ora 	RandomSeed+2
.01a4ce	0d a6 03	ora $03a6			ora 	RandomSeed+3
.01a4d1	d0 0a		bne $01a4dd			bne 	_URNotZero
.01a4d3	a9 47		lda #$47			lda 	#$47
.01a4d5	8d a4 03	sta $03a4			sta 	RandomSeed+1				; if it is, make it non zero.
.01a4d8	a9 3d		lda #$3d			lda 	#$3D
.01a4da	8d a6 03	sta $03a6			sta 	RandomSeed+3
.01a4dd					_URNotZero:
.01a4dd	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; copy seed into mantissa.
.01a4e0	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a4e2	ad a4 03	lda $03a4			lda 	RandomSeed+1
.01a4e5	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a4e7	ad a5 03	lda $03a5			lda 	RandomSeed+2
.01a4ea	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a4ec	ad a6 03	lda $03a6			lda 	RandomSeed+3
.01a4ef	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a4f1	a9 00		lda #$00			lda 	#$00 						; set type to float.
.01a4f3	95 85		sta $85,x			sta 	XS_Type,x
.01a4f5	a9 80		lda #$80			lda 	#$80
.01a4f7	95 84		sta $84,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.01a4f9	4c 3b a2	jmp $01a23b			jmp 	FPUNormalise
.01a4fc					Random16:
.01a4fc	5e a4 03	lsr $03a4,x			lsr 	RandomSeed+1,x				; shift seed right
.01a4ff	7e a3 03	ror $03a3,x			ror 	RandomSeed,x
.01a502	90 08		bcc $01a50c			bcc 	_R16_NoXor
.01a504	bd a4 03	lda $03a4,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.01a507	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.01a509	9d a4 03	sta $03a4,x			sta 	RandomSeed+1,x
.01a50c					_R16_NoXor:
.01a50c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.01a50d					Unary_Int:
.01a50d	20 0e 92	jsr $01920e			jsr 	EvaluateNumberX 			; get value
.01a510	20 5e 98	jsr $01985e			jsr 	CheckNextRParen 			; check right bracket.
.01a513	4c 5a a2	jmp $01a25a			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Return to file: basic.asm

>01a516	02						.byte 	2
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 c0						.word 	StartROM
>fffe	19 c0					.word TIM_BreakHandler

;******  End of listing
