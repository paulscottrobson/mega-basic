
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Fri Aug 23 09:21:42 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="65816"				cpu = "65816"
="em65816"				hardware = "em65816"
=1					hasFloat = 1
=1					hasInteger = 1
=253					maxString = 253

;******  Processing file: modules/float/fpmacros.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/em65816/src_em65816.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0020					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0200					IFT_XCursor:.byte ?							; current logical position on screen
>0201					IFT_YCursor:.byte ?
>0202					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0266					IFT_LineBuffer: .fill 100 					; line input buffer.
>0300					UserVector .fill 4 							; USR(x) calls this.
>0304					LocalVector .fill 4 						; Indirect calls call this.
>0308					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>030c					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>030d					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=782					XS2_Mantissa = XS_Mantissa+XS_Size
=786					XS2_Exponent = XS_Exponent+XS_Size
=787					XS2_Type = XS_Type+XS_Size
=788					XS3_Mantissa = XS_Mantissa+XS_Size*2
=792					XS3_Exponent = XS_Exponent+XS_Size*2
=793					XS3_Type = XS_Type+XS_Size*2
>0400					Num_Buffer	.fill 	32 						; buffer for numeric conversions
>0420					NumBufX 	.byte 	?						; buffer index position
>0421					NumSuppress	.byte 	?						; leading zero suppression flag
>0422					NumConvCount .byte 	? 						; count for conversions.
>0423					ExpTemp:	.byte ?							; Working temp for exponents.
>0424					ExpCount:	.byte ? 						; Count of decimal exponents.
>0425					SignCount:	.byte ?							; Integer Divide Sign Counts.
>0426					StringPtr:	.byte ? 						; Top of free memory (for string allocation)
>0427					TempStringWriteIndex: .byte ? 				; Write offset.
>0428					ValSign: 	.byte ? 						; sign flag for val()
>0429					SliceStart:	.byte ? 						; string slice parts
>042a					SliceCount:	.byte ?
>042b					RandomSeed:	.dword ? 						; Random seed.
>042f					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>0431					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>0433					Tim_SR:		.byte ? 						; Processor Status
>0434					Tim_A:		.byte ? 						; Processor Registers
>0435					Tim_X:		.byte ?
>0436					Tim_Y:		.byte ?
>0437					Tim_Z:		.byte ?
>0438					Tim_SP:		.byte ?							; Stack Pointer

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/em65816.asm

=$8000					HighMemory = $8000
.1000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testcode.src

>1000	1a 0a 00 d9 a6 a1 fe 08			.byte	$1a,$0a,$00,$d9,$a6,$a1,$fe,$08
>1008	61 62 63 64 65 66 bd 50			.byte	$61,$62,$63,$64,$65,$66,$bd,$50
>1010	bc bc be ff 06 68 69 20			.byte	$bc,$bc,$be,$ff,$06,$68,$69,$20
>1018	21 00 00				.byte	$21,$00,$00

;******  Return to file: modules/hardware/em65816.asm

.c000					StartROM:
.c000	18		clc				clc
.c001	fb		xce				xce
.c002	c2 30		rep #$30			rep 	#$30
.c004	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.c007	1b		tcs				tcs
.c008	e2 30		sep #$30			sep 	#$30 						; clear AXY in 16 bit.
.c00a	c2 30		rep #$30			rep 	#$30
.c00c	a9 00 00	lda #$0000			lda 	#$0000
.c00f	aa		tax				tax
.c010	a8		tay				tay
.c011	e2 30		sep #$30			sep 	#$30
.c013	5c dc 83 01	jmp $0183dc		jmp BASIC_Start
.c017					TIM_BreakHandler:
.c017	5c bf 96 01	jmp $0196bf			jmp 	TIM_BreakVector

;******  Processing file: modules/hardware/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b4					lastUnaryFunction = $b4
.018000					VectorTable:
>018000	ea 85					.word BinaryOp_And         & $FFFF ; $80 and
>018002	12 86					.word BinaryOp_Or          & $FFFF ; $81 or
>018004	3a 86					.word BinaryOp_Xor         & $FFFF ; $82 xor
>018006	3a 86					.word BinaryOp_Eor         & $FFFF ; $83 eor
>018008	7d 86					.word Binary_Equal         & $FFFF ; $84 =
>01800a	9c 86					.word Binary_NotEqual      & $FFFF ; $85 <>
>01800c	a5 86					.word Binary_Less          & $FFFF ; $86 <
>01800e	ae 86					.word Binary_LessEqual     & $FFFF ; $87 <=
>018010	c0 86					.word Binary_Greater       & $FFFF ; $88 >
>018012	b7 86					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>018014	55 87					.word BinaryOp_Add         & $FFFF ; $8a +
>018016	75 87					.word BinaryOp_Subtract    & $FFFF ; $8b -
>018018	88 87					.word BinaryOp_Multiply    & $FFFF ; $8c *
>01801a	9b 87					.word BinaryOp_Divide      & $FFFF ; $8d /
>01801c	b2 80					.word NotImplemented       & $FFFF ; $8e ^
>01801e	b2 80					.word NotImplemented       & $FFFF ; $8f if
>018020	b2 80					.word NotImplemented       & $FFFF ; $90 while
>018022	b2 80					.word NotImplemented       & $FFFF ; $91 repeat
>018024	b2 80					.word NotImplemented       & $FFFF ; $92 for
>018026	b2 80					.word NotImplemented       & $FFFF ; $93 then
>018028	b2 80					.word NotImplemented       & $FFFF ; $94 endif
>01802a	b2 80					.word NotImplemented       & $FFFF ; $95 wend
>01802c	b2 80					.word NotImplemented       & $FFFF ; $96 until
>01802e	b2 80					.word NotImplemented       & $FFFF ; $97 next
>018030	b2 80					.word NotImplemented       & $FFFF ; $98 not
>018032	b2 80					.word NotImplemented       & $FFFF ; $99 fn(
>018034	bd 88					.word Unary_Abs            & $FFFF ; $9a abs(
>018036	01 8a					.word Unary_Asc            & $FFFF ; $9b asc(
>018038	37 95					.word Unary_Int            & $FFFF ; $9c int(
>01803a	db 88					.word Unary_Peek           & $FFFF ; $9d peek(
>01803c	ae 94					.word Unary_Rnd            & $FFFF ; $9e rnd(
>01803e	4f 89					.word Unary_Usr            & $FFFF ; $9f usr(
>018040	41 8a					.word Unary_Left           & $FFFF ; $a0 left$(
>018042	58 8a					.word Unary_Right          & $FFFF ; $a1 right$(
>018044	26 8a					.word Unary_Mid            & $FFFF ; $a2 mid$(
>018046	b7 8b					.word Unary_Spc            & $FFFF ; $a3 spc(
>018048	ce 89					.word Unary_Str            & $FFFF ; $a4 str$(
>01804a	61 89					.word Unary_Val            & $FFFF ; $a5 val(
>01804c	17 8a					.word Unary_Len            & $FFFF ; $a6 len(
>01804e	d5 8a					.word Unary_Hex            & $FFFF ; $a7 hex$(
>018050	b2 80					.word NotImplemented       & $FFFF ; $a8 sin(
>018052	b2 80					.word NotImplemented       & $FFFF ; $a9 cos(
>018054	b2 80					.word NotImplemented       & $FFFF ; $aa tan(
>018056	b2 80					.word NotImplemented       & $FFFF ; $ab atn(
>018058	b2 80					.word NotImplemented       & $FFFF ; $ac exp(
>01805a	b2 80					.word NotImplemented       & $FFFF ; $ad log(
>01805c	b2 80					.word NotImplemented       & $FFFF ; $ae sqr(
>01805e	2f 8b					.word Unary_Dec            & $FFFF ; $af dec(
>018060	df 88					.word Unary_Deek           & $FFFF ; $b0 deek(
>018062	e3 88					.word Unary_Leek           & $FFFF ; $b1 leek(
>018064	17 89					.word Unary_Mod            & $FFFF ; $b2 mod(
>018066	6b 88					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>018068	96 8b					.word Unary_Chr            & $FFFF ; $b4 chr$(
>01806a	b2 80					.word NotImplemented       & $FFFF ; $b5 $(
>01806c	b2 80					.word NotImplemented       & $FFFF ; $b6 $
>01806e	b2 80					.word NotImplemented       & $FFFF ; $b7 #(
>018070	b2 80					.word NotImplemented       & $FFFF ; $b8 #
>018072	b2 80					.word NotImplemented       & $FFFF ; $b9 %(
>018074	b2 80					.word NotImplemented       & $FFFF ; $ba %
>018076	b2 80					.word NotImplemented       & $FFFF ; $bb (
>018078	b2 80					.word NotImplemented       & $FFFF ; $bc )
>01807a	b2 80					.word NotImplemented       & $FFFF ; $bd ,
>01807c	b2 80					.word NotImplemented       & $FFFF ; $be :
>01807e	b2 80					.word NotImplemented       & $FFFF ; $bf ;
>018080	b2 80					.word NotImplemented       & $FFFF ; $c0 def
>018082	19 84					.word CLR_Command          & $FFFF ; $c1 clr
>018084	b2 80					.word NotImplemented       & $FFFF ; $c3 data
>018086	b2 80					.word NotImplemented       & $FFFF ; $c4 read
>018088	b2 80					.word NotImplemented       & $FFFF ; $c5 dim
>01808a	b2 80					.word NotImplemented       & $FFFF ; $c6 to
>01808c	b2 80					.word NotImplemented       & $FFFF ; $c7 step
>01808e	b2 80					.word NotImplemented       & $FFFF ; $c8 gosub
>018090	b2 80					.word NotImplemented       & $FFFF ; $c9 return
>018092	b2 80					.word NotImplemented       & $FFFF ; $ca goto
>018094	b2 80					.word NotImplemented       & $FFFF ; $cb input
>018096	b2 80					.word NotImplemented       & $FFFF ; $cc let
>018098	b2 80					.word NotImplemented       & $FFFF ; $cd list
>01809a	b2 80					.word NotImplemented       & $FFFF ; $ce new
>01809c	b2 80					.word NotImplemented       & $FFFF ; $cf old
>01809e	b2 80					.word NotImplemented       & $FFFF ; $d0 on
>0180a0	b2 80					.word NotImplemented       & $FFFF ; $d1 restore
>0180a2	b2 80					.word NotImplemented       & $FFFF ; $d2 poke
>0180a4	b2 80					.word NotImplemented       & $FFFF ; $d3 print
>0180a6	b2 80					.word NotImplemented       & $FFFF ; $d4 run
>0180a8	b2 80					.word NotImplemented       & $FFFF ; $d5 stop
>0180aa	b2 80					.word NotImplemented       & $FFFF ; $d6 wait
>0180ac	b2 80					.word NotImplemented       & $FFFF ; $d7 doke
>0180ae	b2 80					.word NotImplemented       & $FFFF ; $d8 loke
>0180b0	b2 80					.word NotImplemented       & $FFFF ; $d9 assert
.0180b2					NotImplemented:
.0180b2	80 fe		bra $0180b2		_error: bra _error
.0180b4					BinaryPrecedence:
>0180b4	01					.byte 1    ; $80 and
>0180b5	01					.byte 1    ; $81 or
>0180b6	01					.byte 1    ; $82 xor
>0180b7	01					.byte 1    ; $83 eor
>0180b8	02					.byte 2    ; $84 =
>0180b9	02					.byte 2    ; $85 <>
>0180ba	02					.byte 2    ; $86 <
>0180bb	02					.byte 2    ; $87 <=
>0180bc	02					.byte 2    ; $88 >
>0180bd	02					.byte 2    ; $89 >=
>0180be	03					.byte 3    ; $8a +
>0180bf	03					.byte 3    ; $8b -
>0180c0	04					.byte 4    ; $8c *
>0180c1	04					.byte 4    ; $8d /
>0180c2	05					.byte 5    ; $8e ^
.0180c3					KeywordText:
>0180c3	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>0180c6	4f d2					.byte $4f,$d2                          ; $81 or
>0180c8	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>0180cb	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>0180ce	bd					.byte $bd                              ; $84 =
>0180cf	3c be					.byte $3c,$be                          ; $85 <>
>0180d1	bc					.byte $bc                              ; $86 <
>0180d2	3c bd					.byte $3c,$bd                          ; $87 <=
>0180d4	be					.byte $be                              ; $88 >
>0180d5	3e bd					.byte $3e,$bd                          ; $89 >=
>0180d7	ab					.byte $ab                              ; $8a +
>0180d8	ad					.byte $ad                              ; $8b -
>0180d9	aa					.byte $aa                              ; $8c *
>0180da	af					.byte $af                              ; $8d /
>0180db	de					.byte $de                              ; $8e ^
>0180dc	49 c6					.byte $49,$c6                          ; $8f if
>0180de	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>0180e3	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>0180e9	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>0180ec	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>0180f0	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>0180f5	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>0180f9	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>0180fe	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>018102	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>018105	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>018108	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>01810c	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>018110	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>018114	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>018119	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>01811d	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>018121	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>018127	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>01812e	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>018133	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>018137	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>01813c	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>018140	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>018144	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>018149	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>01814d	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>018151	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>018155	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>018159	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>01815d	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>018161	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>018165	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>018169	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>01816e	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>018173	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>018177	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>01817b	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>018180	24 a8					.byte $24,$a8                          ; $b5 $(
>018182	a4					.byte $a4                              ; $b6 $
>018183	23 a8					.byte $23,$a8                          ; $b7 #(
>018185	a3					.byte $a3                              ; $b8 #
>018186	25 a8					.byte $25,$a8                          ; $b9 %(
>018188	a5					.byte $a5                              ; $ba %
>018189	a8					.byte $a8                              ; $bb (
>01818a	a9					.byte $a9                              ; $bc )
>01818b	ac					.byte $ac                              ; $bd ,
>01818c	ba					.byte $ba                              ; $be :
>01818d	bb					.byte $bb                              ; $bf ;
>01818e	44 45 c6				.byte $44,$45,$c6                      ; $c0 def
>018191	43 4c d2				.byte $43,$4c,$d2                      ; $c1 clr
>018194	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c3 data
>018198	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c4 read
>01819c	44 49 cd				.byte $44,$49,$cd                      ; $c5 dim
>01819f	54 cf					.byte $54,$cf                          ; $c6 to
>0181a1	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c7 step
>0181a5	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $c8 gosub
>0181aa	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $c9 return
>0181b0	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $ca goto
>0181b4	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $cb input
>0181b9	4c 45 d4				.byte $4c,$45,$d4                      ; $cc let
>0181bc	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $cd list
>0181c0	4e 45 d7				.byte $4e,$45,$d7                      ; $ce new
>0181c3	4f 4c c4				.byte $4f,$4c,$c4                      ; $cf old
>0181c6	4f ce					.byte $4f,$ce                          ; $d0 on
>0181c8	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d1 restore
>0181cf	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d2 poke
>0181d3	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d3 print
>0181d8	52 55 ce				.byte $52,$55,$ce                      ; $d4 run
>0181db	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $d5 stop
>0181df	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d6 wait
>0181e3	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $d7 doke
>0181e7	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $d8 loke
>0181eb	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $d9 assert
>0181f1	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_dollarlparen = $b5
=$b6					token_dollar = $b6
=$b7					token_hashlparen = $b7
=$b8					token_hash = $b8
=$b9					token_percentlparen = $b9
=$ba					token_percent = $ba
=$bb					token_lparen = $bb
=$bc					token_rparen = $bc
=$bd					token_comma = $bd
=$be					token_colon = $be
=$bf					token_semicolon = $bf
=$c0					token_def = $c0
=$c1					token_clr = $c1
=$c3					token_data = $c3
=$c4					token_read = $c4
=$c5					token_dim = $c5
=$c6					token_to = $c6
=$c7					token_step = $c7
=$c8					token_gosub = $c8
=$c9					token_return = $c9
=$ca					token_goto = $ca
=$cb					token_input = $cb
=$cc					token_let = $cc
=$cd					token_list = $cd
=$ce					token_new = $ce
=$cf					token_old = $cf
=$d0					token_on = $d0
=$d1					token_restore = $d1
=$d2					token_poke = $d2
=$d3					token_print = $d3
=$d4					token_run = $d4
=$d5					token_stop = $d5
=$d6					token_wait = $d6
=$d7					token_doke = $d7
=$d8					token_loke = $d8
=$d9					token_assert = $d9

;******  Return to file: modules/hardware/em65816.asm


;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.0181f2					IFT_ClearScreen:
.0181f2	48		pha				pha
.0181f3	da		phx				phx
.0181f4	5a		phy				phy
.0181f5	20 8e 83	jsr $01838e			jsr 	IF_Home 					; home cursor
.0181f8	a2 20		ldx #$20			ldx 	#IF_Height 					; this many lines.
.0181fa					_IFT_CS0:
.0181fa	a0 40		ldy #$40			ldy 	#IF_Width 					; this many chars/line
.0181fc					_IFT_CS1:
.0181fc	a9 20		lda #$20			lda 	#' '						; clear line.
.0181fe	20 ba 83	jsr $0183ba			jsr 	IF_Write
.018201	88		dey				dey
.018202	d0 f8		bne $0181fc			bne 	_IFT_CS1
.018204	20 a1 83	jsr $0183a1			jsr 	IF_NewLine 					; next line down
.018207	ca		dex				dex
.018208	d0 f0		bne $0181fa			bne 	_IFT_CS0
.01820a	7a		ply				ply
.01820b	fa		plx				plx
.01820c	68		pla				pla
.01820d					IFT_HomeCursor:
.01820d	48		pha				pha
.01820e	20 8e 83	jsr $01838e			jsr 	IF_Home
.018211	a9 00		lda #$00			lda 	#0
.018213	8d 00 02	sta $0200			sta 	IFT_XCursor
.018216	8d 01 02	sta $0201			sta 	IFT_YCursor
.018219	68		pla				pla
.01821a	60		rts				rts
.01821b					IFT_UpLine:
.01821b	48		pha				pha
.01821c	ad 01 02	lda $0201			lda  	IFT_YCursor 				; get Y
.01821f	3a		dec a				dec 	a 							; line above
.018220	30 03		bmi $018225			bmi 	_IFTULExit 					; too far, abort
.018222	20 b0 82	jsr $0182b0			jsr 	IFT_SetYPos					; set to that line.
.018225					_IFTULExit:
.018225	68		pla				pla
.018226	60		rts				rts
.018227					IFT_PrintCharacter:
.018227	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.018229	f0 16		beq $018241			beq 	IFT_NewLine
.01822b	48		pha				pha
.01822c	20 59 82	jsr $018259			jsr 	IFT_UpperCase 				; make upper case
.01822f	20 ba 83	jsr $0183ba			jsr 	IF_Write 					; write out.
.018232	ee 00 02	inc $0200			inc 	IFT_XCursor 				; bump x cursor
.018235	ad 00 02	lda $0200			lda 	IFT_XCursor 				; reached RHS ?
.018238	c9 40		cmp #$40			cmp 	#IF_Width
.01823a	d0 03		bne $01823f			bne 	_IFT_PCNotEOL
.01823c	20 41 82	jsr $018241			jsr 	IFT_NewLine 				; if so do new line.
.01823f					_IFT_PCNotEOL:
.01823f	68		pla				pla
.018240	60		rts				rts
.018241					IFT_NewLine:
.018241	48		pha				pha
.018242	20 a1 83	jsr $0183a1			jsr 	IF_NewLine 					; new line on actual screen.
.018245	a9 00		lda #$00			lda 	#0 							; reset x position
.018247	8d 00 02	sta $0200			sta 	IFT_XCursor
.01824a	ee 01 02	inc $0201			inc 	IFT_YCursor 				; move down.
.01824d	ad 01 02	lda $0201			lda 	IFT_YCursor
.018250	c9 20		cmp #$20			cmp 	#IF_Height 					; reached bottom.
.018252	d0 03		bne $018257			bne 	_IFT_NL_NotEOS
.018254	20 64 82	jsr $018264			jsr 	IFT_Scroll 					; scroll screen up.
.018257					_IFT_NL_NotEOS:
.018257	68		pla				pla
.018258	60		rts				rts
.018259					IFT_UpperCase:
.018259	c9 61		cmp #$61			cmp 	#"a"
.01825b	90 06		bcc $018263			bcc 	_IFT_UCExit
.01825d	c9 7b		cmp #$7b			cmp 	#"z"+1
.01825f	b0 02		bcs $018263			bcs 	_IFT_UCExit
.018261	49 20		eor #$20			eor 	#$20
.018263					_IFT_UCExit:
.018263	60		rts				rts
.018264					IFT_Scroll:
.018264	48		pha				pha 								; save AXY
.018265	da		phx				phx
.018266	5a		phy				phy
.018267	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.018269					_IFT_SLoop:
.018269	20 89 82	jsr $018289			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.01826c	e8		inx				inx
.01826d	e0 1f		cpx #$1f			cpx 	#IF_Height-1				; do whole screen
.01826f	d0 f8		bne $018269			bne 	_IFT_SLoop
.018271	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.018273	20 b0 82	jsr $0182b0			jsr 	IFT_SetYPos
.018276	a2 40		ldx #$40			ldx 	#IF_Width 					; blank line
.018278					_IFT_SBlank:
.018278	a9 20		lda #$20			lda 	#32
.01827a	20 ba 83	jsr $0183ba			jsr 	IF_Write
.01827d	ca		dex				dex
.01827e	d0 f8		bne $018278			bne 	_IFT_SBlank
.018280	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.018282	20 b0 82	jsr $0182b0			jsr 	IFT_SetYPos
.018285	7a		ply				ply
.018286	fa		plx				plx
.018287	68		pla				pla
.018288	60		rts				rts
.018289					_IFT_ScrollLine:
.018289	da		phx				phx
.01828a	da		phx				phx
.01828b	8a		txa				txa 								; copy line into buffer.
.01828c	1a		inc a				inc 	a 							; next line down.
.01828d	20 b0 82	jsr $0182b0			jsr 	IFT_SetYPos
.018290	a2 00		ldx #$00			ldx 	#0
.018292					_IFTScrollCopy1:
.018292	20 b1 83	jsr $0183b1			jsr 	IF_Read
.018295	9d 02 02	sta $0202,x			sta 	IFT_Buffer,x
.018298	e8		inx				inx
.018299	e0 40		cpx #$40			cpx 	#IF_Width
.01829b	d0 f5		bne $018292			bne 	_IFTScrollCopy1
.01829d	68		pla				pla
.01829e	20 b0 82	jsr $0182b0			jsr 	IFT_SetYPos
.0182a1	a2 00		ldx #$00			ldx 	#0
.0182a3					_IFTScrollCopy2:
.0182a3	bd 02 02	lda $0202,x			lda 	IFT_Buffer,x
.0182a6	20 ba 83	jsr $0183ba			jsr 	IF_Write
.0182a9	e8		inx				inx
.0182aa	e0 40		cpx #$40			cpx 	#IF_Width
.0182ac	d0 f5		bne $0182a3			bne 	_IFTScrollCopy2
.0182ae	fa		plx				plx
.0182af	60		rts				rts
.0182b0					IFT_SetYPos:
.0182b0	48		pha				pha
.0182b1	da		phx				phx
.0182b2	aa		tax				tax
.0182b3	20 0d 82	jsr $01820d			jsr 	IFT_HomeCursor
.0182b6	e0 00		cpx #$00			cpx 	#0
.0182b8	f0 09		beq $0182c3			beq 	_IFT_MOAExit
.0182ba					_IFT_MOALoop:
.0182ba	20 a1 83	jsr $0183a1			jsr 	IF_NewLine
.0182bd	ee 01 02	inc $0201			inc 	IFT_YCursor
.0182c0	ca		dex				dex
.0182c1	d0 f7		bne $0182ba			bne		_IFT_MOALoop
.0182c3					_IFT_MOAExit:
.0182c3	fa		plx				plx
.0182c4	68		pla				pla
.0182c5	60		rts				rts
.0182c6					IFT_GetKeyCursor:
.0182c6	20 ce 82	jsr $0182ce			jsr 	_IFT_FlipCursor 			; reverse current
.0182c9					_IFT_GKCWait:
.0182c9	20 cb 83	jsr $0183cb			jsr 	IF_GetKey 					; get key
.0182cc	f0 fb		beq $0182c9			beq 	_IFT_GKCWait
.0182ce					_IFT_FlipCursor:
.0182ce	48		pha				pha 								; save
.0182cf	20 b1 83	jsr $0183b1			jsr 	IF_Read 					; read
.0182d2	20 c3 83	jsr $0183c3			jsr 	IF_LeftOne
.0182d5	49 80		eor #$80			eor 	#$80 						; reverse
.0182d7	20 ba 83	jsr $0183ba			jsr 	IF_Write 					; write
.0182da	20 c3 83	jsr $0183c3			jsr 	IF_LeftOne
.0182dd	68		pla				pla
.0182de	60		rts				rts
.0182df					IFT_ReadLine:
.0182df	48		pha				pha
.0182e0					_IFT_RLLoop:
.0182e0	20 c6 82	jsr $0182c6			jsr 	IFT_GetKeyCursor 			; get keystroke
.0182e3	c9 0d		cmp #$0d			cmp 	#13							; return
.0182e5	f0 7d		beq $018364			beq 	_IFT_RLExit
.0182e7	c9 20		cmp #$20			cmp 	#32 						; control character
.0182e9	90 05		bcc $0182f0			bcc 	_IFT_Control
.0182eb	20 27 82	jsr $018227			jsr 	IFT_PrintCharacter
.0182ee	80 f0		bra $0182e0			bra 	_IFT_RLLoop
.0182f0					_IFT_Control:
.0182f0	c9 01		cmp #$01			cmp 	#"A"-64
.0182f2	f0 26		beq $01831a			beq 	_IFT_Left
.0182f4	c9 04		cmp #$04			cmp 	#"D"-64
.0182f6	f0 2e		beq $018326			beq 	_IFT_Right
.0182f8	c9 17		cmp #$17			cmp 	#"W"-64
.0182fa	f0 36		beq $018332			beq 	_IFT_Up
.0182fc	c9 13		cmp #$13			cmp 	#"S"-64
.0182fe	f0 3e		beq $01833e			beq 	_IFT_Down
.018300	c9 08		cmp #$08			cmp 	#"H"-64
.018302	f0 09		beq $01830d			beq 	_IFT_Backspace
.018304	c9 1a		cmp #$1a			cmp 	#"Z"-64
.018306	d0 d8		bne $0182e0			bne 	_IFT_RLLoop
.018308	20 f2 81	jsr $0181f2			jsr 	IFT_ClearScreen				; clear CTL-Z
.01830b	80 d3		bra $0182e0			bra 	_IFT_RLLoop
.01830d					_IFT_Backspace:
.01830d	ad 00 02	lda $0200			lda 	IFT_XCursor 				; check not start of line.
.018310	f0 ce		beq $0182e0			beq 	_IFT_RLLoop
.018312	20 c3 83	jsr $0183c3			jsr 	IF_LeftOne
.018315	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.018317	20 ba 83	jsr $0183ba			jsr 	IF_Write
.01831a					_IFT_Left:
.01831a	ce 00 02	dec $0200			dec 	IFT_XCursor 				; left CTL-W
.01831d	10 29		bpl $018348			bpl 	_IFT_Reposition
.01831f	a9 3f		lda #$3f			lda 	#IF_Width-1
.018321					_IFT_SetX:
.018321	8d 00 02	sta $0200			sta 	IFT_XCursor
.018324	80 22		bra $018348			bra 	_IFT_Reposition
.018326					_IFT_Right:
.018326	ee 00 02	inc $0200			inc 	IFT_XCursor
.018329	ad 00 02	lda $0200			lda 	IFT_XCursor
.01832c	49 40		eor #$40			eor 	#IF_Width
.01832e	f0 f1		beq $018321			beq 	_IFT_SetX
.018330	80 16		bra $018348			bra 	_IFT_Reposition
.018332					_IFT_Up:
.018332	ce 01 02	dec $0201			dec 	IFT_YCursor
.018335	10 11		bpl $018348			bpl 	_IFT_Reposition
.018337	a9 1f		lda #$1f			lda 	#IF_Height-1
.018339					_IFT_SetY:
.018339	8d 01 02	sta $0201			sta 	IFT_YCursor
.01833c	80 0a		bra $018348			bra 	_IFT_Reposition
.01833e					_IFT_Down:
.01833e	ee 01 02	inc $0201			inc 	IFT_YCursor
.018341	ad 01 02	lda $0201			lda 	IFT_YCursor
.018344	49 20		eor #$20			eor 	#IF_Height
.018346	f0 f1		beq $018339			beq 	_IFT_SetY
.018348					_IFT_Reposition:
.018348	ad 00 02	lda $0200			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.01834b	48		pha				pha
.01834c	ad 01 02	lda $0201			lda 	IFT_YCursor
.01834f	20 b0 82	jsr $0182b0			jsr 	IFT_SetYPos
.018352	68		pla				pla
.018353	aa		tax				tax
.018354	e0 00		cpx #$00			cpx 	#0
.018356	f0 88		beq $0182e0			beq 	_IFT_RLLoop
.018358					_IFT_MoveRight:
.018358	20 b1 83	jsr $0183b1			jsr 	IF_Read
.01835b	ee 00 02	inc $0200			inc 	IFT_XCursor
.01835e	ca		dex				dex
.01835f	d0 f7		bne $018358			bne 	_IFT_MoveRight
.018361	4c e0 82	jmp $0182e0			jmp 	_IFT_RLLoop
.018364					_IFT_RLExit:
.018364	ad 01 02	lda $0201			lda 	IFT_YCursor 				; go to start of line.
.018367	20 b0 82	jsr $0182b0			jsr 	IFT_SetYPos
.01836a	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.01836c					_IFT_RLRead:
.01836c	20 b1 83	jsr $0183b1			jsr 	IF_Read
.01836f	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.018372	e8		inx				inx
.018373	e0 40		cpx #$40			cpx 	#IF_Width
.018375	d0 f5		bne $01836c			bne 	_IFT_RLRead
.018377					_IFT_RL_Trim:
.018377	ca		dex				dex 	 							; previous char
.018378	30 07		bmi $018381			bmi 	_IFT_Found 					; gone too far
.01837a	bd 66 02	lda $0266,x			lda 	IFT_LineBuffer,x			; go back if space
.01837d	c9 20		cmp #$20			cmp 	#" "
.01837f	f0 f6		beq $018377			beq 	_IFT_RL_Trim
.018381					_IFT_Found:
.018381	e8		inx				inx 								; forward to non-space
.018382	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.018384	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.018387	68		pla				pla
.018388	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.01838a	a0 02		ldy #$02			ldy 	#IFT_LineBuffer >> 8
.01838c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_em65816.asm

=64					IF_Width 	= 64 							; characters across
=32					IF_Height 	= 32 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line.
=8					IF_XPos 	= 8 							; current position, horizontal.
=$f0000					IF_Screen = $F0000							; 2k screen RAM here
=$f8010					IF_PKeyboard = $F8010						; Keyboard port.
=$f8000					IF_PBreak = $F8000 							; Break key.
.01838d					IF_Reset:
.01838d	60		rts				rts
.01838e					IF_Home:
.01838e	48		pha				pha
.01838f	64 08		stz $08				stz 	IF_XPos 					; zero X position
.018391	a9 00		lda #$00			lda 	#IF_Screen & $FF 			; set r/w pos.
.018393	85 04		sta $04				sta 	IF_Pos
.018395	a9 00		lda #$00			lda 	#(IF_Screen >> 8) & $FF
.018397	85 05		sta $05				sta 	IF_Pos+1
.018399	a9 0f		lda #$0f			lda 	#IF_Screen >> 16
.01839b	85 06		sta $06				sta 	IF_Pos+2
.01839d	64 07		stz $07				stz 	IF_Pos+3
.01839f	68		pla				pla
.0183a0	60		rts				rts
.0183a1					IF_NewLine:
.0183a1	48		pha				pha
.0183a2	64 08		stz $08				stz 	IF_XPos						; back to start of line
.0183a4	18		clc				clc 								; down one line
.0183a5	a5 04		lda $04				lda 	IF_Pos
.0183a7	69 40		adc #$40			adc 	#64
.0183a9	85 04		sta $04				sta 	IF_Pos
.0183ab	90 02		bcc $0183af			bcc 	_IF_NoCarry 				; carry through.
.0183ad	e6 05		inc $05				inc 	IF_Pos+1
.0183af					_IF_NoCarry:
.0183af	68		pla				pla
.0183b0	60		rts				rts
.0183b1					IF_Read:
.0183b1	5a		phy				phy 								; save current Y
.0183b2	a4 08		ldy $08				ldy 	IF_XPos 					; read character at current position
.0183b4	b7 04		lda [$04],y			lda 	[IF_Pos],y
.0183b6	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0183b8	7a		ply				ply									; restore Y
.0183b9	60		rts				rts
.0183ba					IF_Write:
.0183ba	5a		phy				phy 								; save current Y
.0183bb	a4 08		ldy $08				ldy 	IF_XPos 					; write character at current position
.0183bd	97 04		sta [$04],y			sta 	[IF_Pos],y
.0183bf	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0183c1	7a		ply				ply									; restore Y
.0183c2	60		rts				rts
.0183c3					IF_LeftOne:
.0183c3	c6 08		dec $08				dec 	IF_XPos
.0183c5	60		rts				rts
.0183c6					IF_CheckBreak:
.0183c6	af 00 80 0f	lda $0f8000			lda 	IF_PBreak					; non-zero if Ctrl+C pressed.
.0183ca	60		rts				rts
.0183cb					IF_GetKey:
.0183cb	af 10 80 0f	lda $0f8010			lda 	IF_PKeyboard				; read keyboard
.0183cf	f0 08		beq $0183d9			beq		_IFGK_NoKey 				; skip if zero,no key pressed
.0183d1	48		pha				pha 								; key pressed, clear queue.
.0183d2	a9 00		lda #$00			lda 	#0
.0183d4	8f 10 80 0f	sta $0f8010			sta 	IF_PKeyboard
.0183d8	68		pla				pla
.0183d9					_IFGK_NoKey:
.0183d9	09 00		ora #$00			ora 	#0							; set Z flag appropriately.
.0183db	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm

.0183dc					BASIC_Start:
.0183dc	20 8d 83	jsr $01838d			jsr 	IF_Reset 					; set up and clear screen.
.0183df	20 f2 81	jsr $0181f2			jsr 	IFT_ClearScreen
.0183e2	a9 5c		lda #$5c			lda 	#$5C 						; JMP Long opcode
.0183e4	8d 04 03	sta $0304			sta 	LocalVector
.0183e7	8d 00 03	sta $0300			sta 	UserVector
.0183ea	a9 5f		lda #$5f			lda 	#USRDefault & $FF 			; reset USR vector
.0183ec	8d 01 03	sta $0301			sta 	UserVector+1
.0183ef	a9 89		lda #$89			lda 	#(USRDefault >> 8) & $FF
.0183f1	8d 02 03	sta $0302			sta 	UserVector+2
.0183f4	a9 01		lda #$01			lda 	#(USRDefault >> 16) & $FF
.0183f6	8d 03 03	sta $0303			sta 	UserVector+3
.0183f9	20 19 84	jsr $018419			jsr 	ResetRunStatus 				; clear everything (CLR command)
.0183fc	a9 00		lda #$00			lda 	#0 							; mark temp string pointer uninitialised.
.0183fe	85 21		sta $21				sta 	zTempStr+1 					; (done before every base level evaluation/or command)
.018400	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018402	85 16		sta $16				sta 	zCodePtr+0
.018404	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018406	85 17		sta $17				sta 	zCodePtr+1
.018408	a9 00		lda #$00			lda 	#0
.01840a	85 18		sta $18				sta 	zCodePtr+2
.01840c	85 19		sta $19				sta 	zCodePtr+3
.01840e	a0 03		ldy #$03			ldy 	#3
.018410	c8		iny				iny
.018411	b1 16		lda ($16),y			lda 	(zCodePtr),y
.018413	20 27 84	jsr $018427			jsr 	EvaluateExpression
>018416	02						.byte 	2
.018417					SyntaxError:
.018417					ERR_Handler:
.018417	80 fe		bra $018417			bra 	ERR_Handler

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.018419					CLR_Command:
.018419					ResetRunStatus:
.018419	a9 00		lda #$00			lda 	#HighMemory & $FF
.01841b	8d 26 04	sta $0426			sta 	StringPtr
.01841e	a9 80		lda #$80			lda 	#HighMemory >> 8
.018420	8d 27 04	sta $0427			sta 	StringPtr+1
.018423	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.018424					EVESyntax:
.018424	4c 17 84	jmp $018417			jmp 	SyntaxError
.018427					EvaluateExpression:
.018427	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.018429					EvaluateExpressionX:
.018429	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.01842b					EvaluateExpressionXA:
.01842b	48		pha				pha 								; save precedence on stack.
.01842c	b1 16		lda ($16),y			lda 	(zCodePtr),y
.01842e	f0 f4		beq $018424			beq 	EVESyntax 					; end of line, syntax error.
.018430	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.018432	b0 03		bcs $018437			bcs 	_EVNotVariable
.018434	4c 26 85	jmp $018526			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.018437					_EVNotVariable:
.018437	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.018439	90 e9		bcc $018424			bcc 	EVESyntax
.01843b	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.01843d	b0 7f		bcs $0184be			bcs 	_EVNotInteger
.01843f	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.018441	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.018444	a9 00		lda #$00			lda 	#0
.018446	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018449	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01844c	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.01844f	1a		inc a				inc 	a 							; set to type 1 (integer)
.018450	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018453					_EVCheckNextInteger:
.018453	c8		iny				iny
.018454	b1 16		lda ($16),y			lda 	(zCodePtr),y
.018456	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.018458	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.01845a	b0 0d		bcs $018469			bcs 	_EVCheckDecimal
.01845c	48		pha				pha 								; save it.
.01845d	20 27 85	jsr $018527			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.018460	68		pla				pla
.018461	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.018464	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018467	80 ea		bra $018453			bra 	_EVCheckNextInteger
.018469					_EVCheckDecimal:
.018469	b1 16		lda ($16),y			lda 	(zCodePtr),y
.01846b	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.01846d	d0 05		bne $018474			bne 	_EVGotAtom 					; no, get atom.
.01846f					_EVIsDecimal:
.01846f	20 57 85	jsr $018557			jsr 	EVGetDecimal 				; extend to the decimal part.
.018472	80 00		bra $018474			bra 	_EVGotAtom 					; and continue to got atom.
.018474					_EVGotAtom:
.018474	b1 16		lda ($16),y			lda 	(zCodePtr),y
.018476	10 44		bpl $0184bc			bpl 	_EVExitDrop 				; must be a token.
.018478	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.01847a	b0 40		bcs $0184bc			bcs 	_EVExitDrop
.01847c	68		pla				pla 								; get current precedence
.01847d	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.01847f	da		phx				phx 								; save X
.018480	b1 16		lda ($16),y			lda 	(zCodePtr),y
.018482	aa		tax				tax 								; put in X
.018483	bf 34 80 01	lda $018034,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.018487	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.018489	fa		plx				plx 								; restore X
.01848a	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.01848c	90 2f		bcc $0184bd			bcc 	_EVExit 					; exit if too low.
.01848e	f0 2d		beq $0184bd			beq 	_EVExit 					; exit if equals
.018490	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.018492	48		pha				pha
.018493	b1 16		lda ($16),y			lda 	(zCodePtr),y
.018495	48		pha				pha
.018496	c8		iny				iny
.018497	da		phx				phx 								; save current position
.018498	e8		inx				inx
.018499	e8		inx				inx
.01849a	e8		inx				inx
.01849b	e8		inx				inx
.01849c	e8		inx				inx
.01849d	e8		inx				inx
.01849e	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.0184a0	20 2b 84	jsr $01842b			jsr 	EvaluateExpressionXA 		; do the RHS.
.0184a3	fa		plx				plx 								; restore X
.0184a4	68		pla				pla 								; get the binary operator in A.
.0184a5					_EVCallA:
.0184a5	da		phx				phx 								; save X again
.0184a6	0a		asl a				asl 	a 							; double, lose the MSB.
.0184a7	aa		tax				tax									; put in X
.0184a8	bf 00 80 01	lda $018000,x			lda 	VectorTable,x 				; copy address into zGenPtr
.0184ac	8d 05 03	sta $0305			sta 	LocalVector+1
.0184af	bf 01 80 01	lda $018001,x			lda 	VectorTable+1,x
.0184b3	8d 06 03	sta $0306			sta 	LocalVector+2
.0184b6	fa		plx				plx 								; restore X
.0184b7	20 23 85	jsr $018523			jsr 	_EVCallLocalVector
.0184ba	80 b8		bra $018474			bra 	_EVGotAtom 					; and loop back.
.0184bc					_EVExitDrop:
.0184bc	68		pla				pla
.0184bd					_EVExit:
.0184bd	60		rts				rts
.0184be					_EVNotInteger:
.0184be	c8		iny				iny
.0184bf	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.0184c1	d0 19		bne $0184dc			bne 	_EVNotMinus
.0184c3	20 a8 85	jsr $0185a8			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.0184c6	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.0184c9	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.0184cb	f0 05		beq $0184d2			beq 	_EVMinusFloat
.0184cd	20 5a 8d	jsr $018d5a			jsr 	IntegerNegateAlways 		; negation
.0184d0	80 a2		bra $018474			bra 	_EVGotAtom 					; and go back.
.0184d2					_EVMinusFloat:
.0184d2	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; invert the sign bit.
.0184d5	49 80		eor #$80			eor 	#$80
.0184d7	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0184da	80 98		bra $018474			bra 	_EVGotAtom
.0184dc					_EVNotMinus:
.0184dc	c9 bb		cmp #$bb			cmp 	#token_lparen 				; is it left parenthesis
.0184de	d0 0c		bne $0184ec			bne 	_EVNotParenthesis
.0184e0	20 29 84	jsr $018429			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.0184e3	b1 16		lda ($16),y			lda 	(zCodePtr),y
.0184e5	c8		iny				iny
.0184e6	c9 bc		cmp #$bc			cmp 	#token_rparen 				; okay if right bracket.
.0184e8	f0 8a		beq $018474			beq 	_EVGotAtom
.0184ea	80 fe		bra $0184ea		_error: bra _error
.0184ec					_EVNotParenthesis:
.0184ec	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.0184ee	d0 0c		bne $0184fc			bne 	_EVNotNot
.0184f0	20 a8 85	jsr $0185a8			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.0184f3	20 54 92	jsr $019254			jsr 	FPUToInteger 				; make it an integer - if possible.
.0184f6	20 85 85	jsr $018585			jsr 	NotInteger 					; do the not calculation
.0184f9	4c 74 84	jmp $018474			jmp 	_EVGotAtom
.0184fc					_EVNotNot:
.0184fc	c9 fe		cmp #$fe			cmp 	#$FE
.0184fe	d0 15		bne $018515			bne 	_EVNotString
.018500	20 5a 8c	jsr $018c5a			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.018503	a5 20		lda $20				lda 	zTempStr 					; copy address of string into mantissa
.018505	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018508	a5 21		lda $21				lda 	zTempStr+1
.01850a	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.01850d	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.01850f	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018512	4c 74 84	jmp $018474			jmp 	_EVGotAtom
.018515					_EVNotString:
.018515	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.018517	90 04		bcc $01851d			bcc 	_EVBadElement
.018519	c9 b5		cmp #$b5			cmp 	#lastUnaryFunction+1
.01851b	90 03		bcc $018520			bcc 	_EVUnaryFunction
.01851d					_EVBadElement:
.01851d	4c 17 84	jmp $018417			jmp 	SyntaxError
.018520					_EVUnaryFunction:
.018520	4c a5 84	jmp $0184a5			jmp 	_EVCallA
.018523					_EVCallLocalVector:
.018523	6c 05 03	jmp ($0305)			jmp 	(LocalVector+1)
.018526					_EVVariableHandler:
.018526	ea		nop				nop
.018527					EVShiftMantissaLeft6:
.018527	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.01852a	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.01852d	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018530	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018533	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018536	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018539	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.01853c	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.01853f	a9 00		lda #$00			lda 	#0
.018541	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018544	20 47 85	jsr $018547			jsr 	_EVSMLShift 					; call it here to do it twice
.018547					_EVSMLShift:
.018547	5e 0c 03	lsr $030c,x			lsr 	XS_Exponent,x
.01854a	7e 0b 03	ror $030b,x			ror 	XS_Mantissa+3,x
.01854d	7e 0a 03	ror $030a,x			ror 	XS_Mantissa+2,x
.018550	7e 09 03	ror $0309,x			ror 	XS_Mantissa+1,x
.018553	7e 08 03	ror $0308,x			ror 	XS_Mantissa+0,x
.018556	60		rts				rts
.018557					EVGetDecimal:
.018557	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.018559	8d 00 04	sta $0400			sta 	Num_Buffer
.01855c	da		phx				phx
.01855d	c8		iny				iny
.01855e	b1 16		lda ($16),y			lda 	(zCodePtr),y
.018560	c8		iny				iny
.018561	3a		dec a				dec 	a								; convert to a string length.
.018562	3a		dec a				dec 	a
.018563	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.018565					_EVGDCopy:
.018565	48		pha				pha 									; save count
.018566	b1 16		lda ($16),y			lda 	(zCodePtr),y
.018568	9d 00 04	sta $0400,x			sta 	Num_Buffer,x
.01856b	e8		inx				inx 									; forward ....
.01856c	c8		iny				iny
.01856d	68		pla				pla 									; get count
.01856e	3a		dec a				dec 	a 								; until zero
.01856f	d0 f4		bne $018565			bne 	_EVGDCopy
.018571	9d 00 04	sta $0400,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.018574	fa		plx				plx 									; restore X
.018575	a9 00		lda #$00			lda 	#Num_Buffer & $FF 				; set zGenPtr
.018577	85 1e		sta $1e				sta 	zGenPtr
.018579	a9 04		lda #$04			lda 	#Num_Buffer >> 8
.01857b	85 1f		sta $1f				sta 	zGenPtr+1
.01857d	5a		phy				phy 									; save Y
.01857e	a0 00		ldy #$00			ldy 	#0 								; start position
.018580	20 2d 94	jsr $01942d			jsr 	FPFromString 					; convert current
.018583	7a		ply				ply 									; restore Y
.018584	60		rts				rts
.018585					NotInteger:
.018585	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018588	49 ff		eor #$ff			eor 	#$FF
.01858a	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.01858d	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018590	49 ff		eor #$ff			eor 	#$FF
.018592	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018595	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018598	49 ff		eor #$ff			eor 	#$FF
.01859a	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01859d	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.0185a0	49 ff		eor #$ff			eor 	#$FF
.0185a2	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0185a5	60		rts				rts
.0185a6					EvaluateGetAtom:
.0185a6	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.0185a8					EvaluateGetAtomX:
.0185a8	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.0185aa	20 2b 84	jsr $01842b			jsr 	EvaluateExpressionXA
.0185ad	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.0185b0	29 0f		and #$0f			and 	#15
.0185b2	c9 02		cmp #$02			cmp 	#2
.0185b4	b0 01		bcs $0185b7			bcs 	EvaluateType
.0185b6	60		rts				rts
.0185b7					EvaluateType:
.0185b7	80 fe		bra $0185b7		_error: bra _error
.0185b9					EvaluateNumber:
.0185b9	a2 00		ldx #$00			ldx 	#0
.0185bb					EvaluateNumberX:
.0185bb	20 29 84	jsr $018429			jsr 	EvaluateExpressionX
.0185be	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 0/1
.0185c1	29 0f		and #$0f			and 	#15
.0185c3	c9 02		cmp #$02			cmp 	#2
.0185c5	b0 f0		bcs $0185b7			bcs 	EvaluateType
.0185c7	60		rts				rts
.0185c8					EvaluateInteger:
.0185c8	a2 00		ldx #$00			ldx 	#0
.0185ca					EvaluateIntegerX:
.0185ca	20 bb 85	jsr $0185bb			jsr 	EvaluateNumberX
.0185cd	20 54 92	jsr $019254			jsr 	FPUToInteger
.0185d0	60		rts				rts
.0185d1					EvaluateString:
.0185d1	a2 00		ldx #$00			ldx 	#0
.0185d3					EvaluateStringX:
.0185d3	20 29 84	jsr $018429			jsr 	EvaluateExpressionX
.0185d6	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 2
.0185d9	29 0f		and #$0f			and 	#15
.0185db	c9 02		cmp #$02			cmp 	#2
.0185dd	d0 d8		bne $0185b7			bne 	EvaluateType
.0185df	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.0185e2	85 1e		sta $1e				sta 	zGenPtr
.0185e4	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0185e7	85 1f		sta $1f				sta 	zGenPtr+1
.0185e9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.0185ea					BinaryOp_And:
.0185ea	20 62 86	jsr $018662			jsr 	BinaryMakeBothInteger
.0185ed	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.0185f0	3d 0e 03	and $030e,x			and 	XS2_Mantissa+0,x
.0185f3	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0185f6	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.0185f9	3d 0f 03	and $030f,x			and 	XS2_Mantissa+1,x
.0185fc	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0185ff	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.018602	3d 10 03	and $0310,x			and 	XS2_Mantissa+2,x
.018605	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018608	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.01860b	3d 11 03	and $0311,x			and 	XS2_Mantissa+3,x
.01860e	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018611	60		rts				rts
.018612					BinaryOp_Or:
.018612	20 62 86	jsr $018662			jsr 	BinaryMakeBothInteger
.018615	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.018618	1d 0e 03	ora $030e,x			ora 	XS2_Mantissa+0,x
.01861b	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.01861e	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.018621	1d 0f 03	ora $030f,x			ora 	XS2_Mantissa+1,x
.018624	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018627	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.01862a	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.01862d	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018630	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.018633	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.018636	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018639	60		rts				rts
.01863a					BinaryOp_Eor:
.01863a					BinaryOp_Xor:
.01863a	20 62 86	jsr $018662			jsr 	BinaryMakeBothInteger
.01863d	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.018640	5d 0e 03	eor $030e,x			eor 	XS2_Mantissa+0,x
.018643	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018646	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.018649	5d 0f 03	eor $030f,x			eor 	XS2_Mantissa+1,x
.01864c	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.01864f	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.018652	5d 10 03	eor $0310,x			eor 	XS2_Mantissa+2,x
.018655	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018658	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.01865b	5d 11 03	eor $0311,x			eor 	XS2_Mantissa+3,x
.01865e	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018661	60		rts				rts
.018662					BinaryMakeBothInteger:
.018662	da		phx				phx 								; save X
.018663	e8		inx				inx
.018664	e8		inx				inx
.018665	e8		inx				inx
.018666	e8		inx				inx
.018667	e8		inx				inx
.018668	e8		inx				inx
.018669	20 6d 86	jsr $01866d			jsr 	BinaryMakeInteger 			; convert to integer.
.01866c	fa		plx				plx 								; restore X and fall through.
.01866d					BinaryMakeInteger:
.01866d	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type byte.
.018670	29 0f		and #$0f			and 	#15 						; check type zero
.018672	f0 04		beq $018678			beq 	_BMIConvert 				; if float convert to integer.
.018674	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.018675	90 04		bcc $01867b			bcc 	_BMIError
.018677	60		rts				rts
.018678					_BMIConvert:
.018678	4c 54 92	jmp $019254			jmp 	FPUToInteger 				; convert to integer
.01867b					_BMIError:
.01867b	80 fe		bra $01867b		_error: bra _error

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.01867d					Binary_Equal:
.01867d	20 c9 86	jsr $0186c9			jsr 	CompareValues
.018680	09 00		ora #$00			ora 	#0
.018682	f0 04		beq $018688			beq 	CCTrue
.018684	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.018686	80 02		bra $01868a			bra 	CCWrite
.018688	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.01868a	9d 08 03	sta $0308,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.01868d	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018690	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018693	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018696	a9 01		lda #$01			lda 	#1
.018698	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; set type to integer whatever.
.01869b	60		rts				rts
.01869c					Binary_NotEqual:
.01869c	20 c9 86	jsr $0186c9			jsr 	CompareValues
.01869f	09 00		ora #$00			ora 	#0
.0186a1	d0 e1		bne $018684			bne 	CCFalse
.0186a3	80 e3		bra $018688			bra 	CCTrue
.0186a5					Binary_Less:
.0186a5	20 c9 86	jsr $0186c9			jsr 	CompareValues
.0186a8	09 00		ora #$00			ora 	#0
.0186aa	30 dc		bmi $018688			bmi 	CCTrue
.0186ac	80 d6		bra $018684			bra 	CCFalse
.0186ae					Binary_LessEqual:
.0186ae	20 c9 86	jsr $0186c9			jsr 	CompareValues
.0186b1	c9 01		cmp #$01			cmp 	#1
.0186b3	d0 d3		bne $018688			bne 	CCTrue
.0186b5	80 cd		bra $018684			bra 	CCFalse
.0186b7					Binary_GreaterEqual:
.0186b7	20 c9 86	jsr $0186c9			jsr 	CompareValues
.0186ba	09 00		ora #$00			ora 	#0
.0186bc	10 ca		bpl $018688			bpl 	CCTrue
.0186be	80 c4		bra $018684			bra 	CCFalse
.0186c0					Binary_Greater:
.0186c0	20 c9 86	jsr $0186c9			jsr 	CompareValues
.0186c3	c9 01		cmp #$01			cmp 	#1
.0186c5	d0 c1		bne $018688			bne 	CCTrue
.0186c7	80 bb		bra $018684			bra 	CCFalse
.0186c9					CompareValues:
.0186c9	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and the types together
.0186cc	3d 13 03	and $0313,x			and 	XS2_Type,x
.0186cf	c9 02		cmp #$02			cmp 	#2
.0186d1	f0 13		beq $0186e6			beq 	_CVString
.0186d3	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.0186d6	3d 13 03	and $0313,x			and 	XS2_Type,x
.0186d9	4a		lsr a				lsr 	a 							; shift bit 0 into C
.0186da	90 03		bcc $0186df			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.0186dc	4c 2c 87	jmp $01872c			jmp 	CompareInteger32 							; so execute code at \1
.0186df					_BCFloat:
.0186df	20 fa 87	jsr $0187fa			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.0186e2	4c 63 91	jmp $019163			jmp 	FPCompare 							; and execute code at \2
.0186e5	60		rts				rts
.0186e6					_CVString:
.0186e6	da		phx				phx 								; save XY
.0186e7	5a		phy				phy
.0186e8	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.0186eb	85 1a		sta $1a				sta		zLTemp1+0
.0186ed	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0186f0	85 1b		sta $1b				sta 	zLTemp1+1
.0186f2	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x
.0186f5	85 1c		sta $1c				sta 	zLTemp1+2
.0186f7	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.0186fa	85 1d		sta $1d				sta 	zLTemp1+3
.0186fc	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.0186fe	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.018700	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.018702	90 02		bcc $018706			bcc 	_CVCommon
.018704	b1 1c		lda ($1c),y			lda 	(zLTemp1+2),y
.018706					_CVCommon:
.018706	aa		tax				tax 								; put shorter string length in zero.
.018707	f0 0c		beq $018715			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.018709					_CVCompare:
.018709	c8		iny				iny 								; next character
.01870a	b1 1a		lda ($1a),y			lda 	(zLTemp1),y 				; compare characters
.01870c	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.01870e	90 13		bcc $018723			bcc 	_CVReturnLess 				; <
.018710	d0 15		bne $018727			bne 	_CVReturnGreater 			; >
.018712	ca		dex				dex 								; until common length matched.
.018713	d0 f4		bne $018709			bne 	_CVCompare
.018715					_CVMatch:
.018715	a0 00		ldy #$00			ldy 	#0
.018717	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.018719	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.01871b	90 06		bcc $018723			bcc 	_CVReturnLess 				; <
.01871d	d0 08		bne $018727			bne 	_CVReturnGreater 			; >
.01871f	a9 00		lda #$00			lda 	#0
.018721	80 06		bra $018729			bra 	_CVExit 					; same common, same length, same string
.018723					_CVReturnLess:
.018723	a9 ff		lda #$ff			lda 	#$FF
.018725	80 02		bra $018729			bra 	_CVExit
.018727					_CVReturnGreater:
.018727	a9 01		lda #$01			lda 	#$01
.018729					_CVExit:
.018729	7a		ply				ply
.01872a	fa		plx				plx
.01872b	60		rts				rts
.01872c					CompareInteger32:
.01872c	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.01872f	49 80		eor #$80			eor 	#$80
.018731	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018734	bd 11 03	lda $0311,x			lda 	XS2_Mantissa+3,x
.018737	49 80		eor #$80			eor 	#$80
.018739	9d 11 03	sta $0311,x			sta 	XS2_Mantissa+3,x
.01873c	20 d4 87	jsr $0187d4			jsr 	SubInteger32 				; subtraction
.01873f	90 11		bcc $018752			bcc 	_CI32Less 					; cc return -1
.018741	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; check if zero
.018744	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.018747	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.01874a	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.01874d	f0 02		beq $018751			beq 	_CI32Exit
.01874f	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.018751					_CI32Exit:
.018751	60		rts				rts
.018752					_CI32Less:
.018752	a9 ff		lda #$ff			lda 	#$FF
.018754	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.018755					BinaryOp_Add:
.018755	bd 0d 03	lda $030d,x			lda 	XS_Type,x  					; and types together
.018758	3d 13 03	and $0313,x			and 	XS2_Type,x
.01875b	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.01875d	d0 13		bne $018772			bne 	_BOAString
.01875f	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018762	3d 13 03	and $0313,x			and 	XS2_Type,x
.018765	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018766	90 03		bcc $01876b			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018768	4c ae 87	jmp $0187ae			jmp 	AddInteger32 							; so execute code at \1
.01876b					_BCFloat:
.01876b	20 fa 87	jsr $0187fa			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.01876e	4c e9 8e	jmp $018ee9			jmp 	FPAdd 							; and execute code at \2
.018771	60		rts				rts
.018772					_BOAString:
.018772	4c 14 88	jmp $018814			jmp 	ConcatenateString 			; concatenate two strings.
.018775					BinaryOp_Subtract:
.018775	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018778	3d 13 03	and $0313,x			and 	XS2_Type,x
.01877b	4a		lsr a				lsr 	a 							; shift bit 0 into C
.01877c	90 03		bcc $018781			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.01877e	4c d4 87	jmp $0187d4			jmp 	SubInteger32 							; so execute code at \1
.018781					_BCFloat:
.018781	20 fa 87	jsr $0187fa			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018784	4c df 8e	jmp $018edf			jmp 	FPSubtract 							; and execute code at \2
.018787	60		rts				rts
.018788					BinaryOp_Multiply:
.018788	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.01878b	3d 13 03	and $0313,x			and 	XS2_Type,x
.01878e	4a		lsr a				lsr 	a 							; shift bit 0 into C
.01878f	90 03		bcc $018794			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018791	4c 7f 8c	jmp $018c7f			jmp 	MulInteger32 							; so execute code at \1
.018794					_BCFloat:
.018794	20 fa 87	jsr $0187fa			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018797	4c 43 90	jmp $019043			jmp 	FPMultiply 							; and execute code at \2
.01879a	60		rts				rts
.01879b					BinaryOp_Divide:
.01879b	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.01879e	3d 13 03	and $0313,x			and 	XS2_Type,x
.0187a1	4a		lsr a				lsr 	a 							; shift bit 0 into C
.0187a2	90 03		bcc $0187a7			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.0187a4	4c d6 8c	jmp $018cd6			jmp 	DivInteger32 							; so execute code at \1
.0187a7					_BCFloat:
.0187a7	20 fa 87	jsr $0187fa			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.0187aa	4c bb 8f	jmp $018fbb			jmp 	FPDivide 							; and execute code at \2
.0187ad	60		rts				rts
.0187ae					AddInteger32:
.0187ae	18		clc				clc
.0187af	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.0187b2	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.0187b5	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0187b8	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0187bb	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.0187be	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0187c1	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.0187c4	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.0187c7	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0187ca	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.0187cd	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.0187d0	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0187d3	60		rts				rts
.0187d4					SubInteger32:
.0187d4	38		sec				sec
.0187d5	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.0187d8	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.0187db	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0187de	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0187e1	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.0187e4	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0187e7	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.0187ea	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.0187ed	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0187f0	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.0187f3	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.0187f6	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0187f9	60		rts				rts
.0187fa					BinaryMakeBothFloat:
.0187fa	da		phx				phx 								; save X
.0187fb	e8		inx				inx
.0187fc	e8		inx				inx
.0187fd	e8		inx				inx
.0187fe	e8		inx				inx
.0187ff	e8		inx				inx
.018800	e8		inx				inx
.018801	20 05 88	jsr $018805			jsr 	BinaryMakeFloat 			; convert to float.
.018804	fa		plx				plx 								; restore X and fall through.
.018805					BinaryMakeFloat:
.018805	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type byte.
.018808	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.018809	b0 04		bcs $01880f			bcs 	_BMFConvert
.01880b	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.01880c	b0 04		bcs $018812			bcs 	_BMFError
.01880e	60		rts				rts
.01880f					_BMFConvert:
.01880f	4c f5 91	jmp $0191f5			jmp 	FPUToFloat 					; convert to float
.018812					_BMFError:
.018812	80 fe		bra $018812		_error: bra _error
.018814					ConcatenateString:
.018814	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.018817	85 1a		sta $1a				sta		zLTemp1+0
.018819	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.01881c	85 1b		sta $1b				sta 	zLTemp1+1
.01881e	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x
.018821	85 1c		sta $1c				sta 	zLTemp1+2
.018823	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.018826	85 1d		sta $1d				sta 	zLTemp1+3
.018828	5a		phy				phy
.018829	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.01882b	b1 1a		lda ($1a),y			lda 	(zlTemp1),y
.01882d	71 1c		adc ($1c),y			adc 	(zlTemp1+2),y
.01882f	7a		ply				ply
.018830	b0 37		bcs $018869			bcs 	_CSError					; check in range.
.018832	c9 fe		cmp #$fe			cmp 	#maxString+1
.018834	b0 33		bcs $018869			bcs 	_CSError
.018836	20 1f 8c	jsr $018c1f			jsr 	AllocateTempString 			; store the result
.018839	20 54 88	jsr $018854			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.01883c	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.01883f	85 1a		sta $1a				sta 	zLTemp1
.018841	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.018844	85 1b		sta $1b				sta 	zLTemp1+1
.018846	20 54 88	jsr $018854			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.018849	a5 20		lda $20				lda 	zTempStr 					; point current to new string
.01884b	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.01884e	a5 21		lda $21				lda 	zTempStr+1
.018850	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018853	60		rts				rts
.018854					_CSCopyString:
.018854	da		phx				phx
.018855	5a		phy				phy
.018856	a0 00		ldy #$00			ldy 	#0 							; get length
.018858	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.01885a	f0 0a		beq $018866			beq 	_CSCSExit 					; if zero, exit
.01885c	aa		tax				tax 								; put in X
.01885d					_CSCSLoop:
.01885d	c8		iny				iny 								; get next char
.01885e	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.018860	20 4a 8c	jsr $018c4a			jsr		WriteTempString 			; copy out
.018863	ca		dex				dex 								; do whole string
.018864	d0 f7		bne $01885d			bne 	_CSCSLoop
.018866					_CSCSExit:
.018866	7a		ply				ply
.018867	fa		plx				plx
.018868	60		rts				rts
.018869					_CSError:
.018869	80 fe		bra $018869		_error: bra _error

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.01886b					Unary_Sgn:
.01886b	20 bb 85	jsr $0185bb			jsr 	EvaluateNumberX 			; get value
.01886e	20 0f 8c	jsr $018c0f			jsr 	CheckNextRParen 			; check right bracket.
.018871	20 95 88	jsr $018895			jsr 	GetSignCurrent 				; get sign.
.018874	09 00		ora #$00			ora 	#0
.018876	10 09		bpl $018881			bpl		UnarySetAInteger			; if 0,1 return that.
.018878	80 00		bra $01887a			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.01887a					UnarySetAMinus1:
.01887a	a9 ff		lda #$ff			lda 	#$FF
.01887c	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.01887f	80 05		bra $018886			bra 	UnarySetAFill
.018881					UnarySetAInteger:
.018881	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.018884	a9 00		lda #$00			lda 	#0
.018886					UnarySetAFill:
.018886	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018889	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01888c	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.01888f	a9 01		lda #$01			lda 	#1
.018891	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018894	60		rts				rts
.018895					GetSignCurrent:
.018895	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; identify type.
.018898	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.018899	90 19		bcc $0188b4			bcc 	_GSCFloat
.01889b	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.01889e	30 11		bmi $0188b1			bmi 	_GSCMinus1
.0188a0	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x
.0188a3	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.0188a6	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.0188a9	d0 03		bne $0188ae			bne 	_GSCPlus1
.0188ab					_GSCZero:
.0188ab	a9 00		lda #$00			lda 	#0
.0188ad	60		rts				rts
.0188ae					_GSCPlus1:
.0188ae	a9 01		lda #$01			lda 	#$01
.0188b0	60		rts				rts
.0188b1					_GSCMinus1:
.0188b1	a9 ff		lda #$ff			lda 	#$FF
.0188b3	60		rts				rts
.0188b4					_GSCFloat:
.0188b4	3c 0d 03	bit $030d,x			bit 	XS_Type,x
.0188b7	70 f2		bvs $0188ab			bvs 	_GSCZero
.0188b9	30 f6		bmi $0188b1			bmi 	_GSCMinus1
.0188bb	80 f1		bra $0188ae			bra 	_GSCPlus1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.0188bd					Unary_Abs:
.0188bd	20 bb 85	jsr $0185bb			jsr 	EvaluateNumberX 			; get value
.0188c0	20 0f 8c	jsr $018c0f			jsr 	CheckNextRParen 			; check right bracket.
.0188c3	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.0188c6	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.0188c8	f0 08		beq $0188d2			beq 	_UAMinusFloat
.0188ca	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; check MSB
.0188cd	10 0b		bpl $0188da			bpl 	_UAExit
.0188cf	4c 5a 8d	jmp $018d5a			jmp 	IntegerNegateAlways 		; negation
.0188d2					_UAMinusFloat:
.0188d2	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; clear the sign bit.
.0188d5	29 7f		and #$7f			and		#$7F
.0188d7	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0188da					_UAExit:
.0188da	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.0188db					Unary_Peek:
.0188db	a9 01		lda #$01			lda 	#1
.0188dd	80 06		bra $0188e5			bra 	UPMain
.0188df					Unary_Deek:
.0188df	a9 02		lda #$02			lda 	#2
.0188e1	80 02		bra $0188e5			bra 	UPMain
.0188e3					Unary_Leek:
.0188e3	a9 04		lda #$04			lda 	#4
.0188e5					UPMain:
.0188e5	48		pha				pha 								; set bytes to copy.
.0188e6	20 ca 85	jsr $0185ca			jsr 	EvaluateIntegerX 			; numeric parameter
.0188e9	20 0f 8c	jsr $018c0f			jsr 	CheckNextRParen 			; right bracket.
.0188ec	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.0188ef	85 1a		sta $1a				sta 	zLTemp1
.0188f1	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0188f4	85 1b		sta $1b				sta 	zLTemp1+1
.0188f6	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.0188f9	85 1c		sta $1c				sta 	zLTemp1+2
.0188fb	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.0188fe	85 1d		sta $1d				sta 	zLTemp1+3
.018900	a9 00		lda #$00			lda 	#0 							; clear target area
.018902	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018905	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018908	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01890b	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.01890e	68		pla				pla 								; restore bytes to copy
.01890f	da		phx				phx 								; save XY
.018910	5a		phy				phy
.018911	20 f5 8b	jsr $018bf5			jsr 	MemRead 					; read the bytes in
.018914	7a		ply				ply 								; restore and exit
.018915	fa		plx				plx
.018916	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.018917					Unary_Mod:
.018917	20 43 89	jsr $018943			jsr 	_UMParameter 				; first parameter
.01891a	20 17 8c	jsr $018c17			jsr 	CheckNextComma
.01891d	da		phx				phx 								; second parameter
.01891e	e8		inx				inx
.01891f	e8		inx				inx
.018920	e8		inx				inx
.018921	e8		inx				inx
.018922	e8		inx				inx
.018923	e8		inx				inx
.018924	20 43 89	jsr $018943			jsr 	_UMParameter
.018927	fa		plx				plx
.018928	20 0f 8c	jsr $018c0f			jsr 	CheckNextRParen
.01892b	20 d6 8c	jsr $018cd6			jsr 	DivInteger32 				; divide
.01892e	a5 1a		lda $1a				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.018930	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018933	a5 1b		lda $1b				lda 	zLTemp1+1
.018935	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018938	a5 1c		lda $1c				lda 	zLTemp1+2
.01893a	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01893d	a5 1d		lda $1d				lda 	zLTemp1+3
.01893f	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018942	60		rts				rts
.018943					_UMParameter:
.018943	20 ca 85	jsr $0185ca			jsr 	EvaluateIntegerX 			; get value
.018946	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; absolute value
.018949	10 03		bpl $01894e			bpl 	_UMNotSigned
.01894b	20 5a 8d	jsr $018d5a			jsr 	IntegerNegateAlways
.01894e					_UMNotSigned:
.01894e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.01894f					Unary_Usr:
.01894f	20 bb 85	jsr $0185bb			jsr 	EvaluateNumberX 			; numeric parameter
.018952	20 0f 8c	jsr $018c0f			jsr 	CheckNextRParen 			; right bracket.
.018955	da		phx				phx 								; save XY
.018956	5a		phy				phy
.018957	ea		nop				nop
.018958	22 00 03 00	jsl $000300			jsl 	UserVector
.01895c	7a		ply				ply 								; and exit
.01895d	fa		plx				plx
.01895e	60		rts				rts
.01895f					USRDefault:
.01895f	80 fe		bra $01895f		_error: bra _error

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.018961					Unary_Val:
.018961	20 d3 85	jsr $0185d3			jsr 	EvaluateStringX 			; get string
.018964	20 0f 8c	jsr $018c0f			jsr 	CheckNextRParen 			; check right bracket.
.018967	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.01896a	85 1e		sta $1e				sta 	zGenPtr
.01896c	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.01896f	85 1f		sta $1f				sta 	zGenPtr+1
.018971	5a		phy				phy
.018972	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.018974	b1 1e		lda ($1e),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.018976	f0 54		beq $0189cc			beq 	_UVBadNumber
.018978	48		pha				pha 								; save length.
.018979	1a		inc a				inc 	a 							; one for the length, one for the terminator
.01897a	1a		inc a				inc 	a
.01897b	20 1f 8c	jsr $018c1f			jsr 	AllocateTempString
.01897e	c8		iny				iny 								; move to the next.
.01897f	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get character
.018981	49 2d		eor #$2d			eor 	#"-"						; zero if minus sign
.018983	8d 28 04	sta $0428			sta 	ValSign
.018986	d0 01		bne $018989			bne 	_UVNotMinus
.018988	c8		iny				iny 								; skip over it.
.018989					_UVNotMinus:
.018989	68		pla				pla 								; this is the count.
.01898a	48		pha		_UVCopy:pha									; copy into new temp string which is ASCIIZ
.01898b	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.01898d	c8		iny				iny
.01898e	20 4a 8c	jsr $018c4a			jsr 	WriteTempString
.018991	68		pla				pla
.018992	3a		dec a				dec 	a
.018993	d0 f5		bne $01898a			bne 	_UVCopy
.018995	20 4a 8c	jsr $018c4a			jsr 	WriteTempString 			; make it ASCIIZ
.018998	18		clc				clc
.018999	a5 20		lda $20				lda 	zTempStr 					; tempstring +1 => genptr
.01899b	69 01		adc #$01			adc 	#1
.01899d	85 1e		sta $1e				sta 	zGenPtr
.01899f	a5 21		lda $21				lda 	zTempStr+1
.0189a1	69 00		adc #$00			adc 	#0
.0189a3	85 1f		sta $1f				sta 	zGenPtr+1
.0189a5	18		clc				clc
.0189a6	20 34 8e	jsr $018e34			jsr 	IntFromString 				; first bit.
.0189a9	b0 21		bcs $0189cc			bcs 	_UVBadNumber
.0189ab	20 2d 94	jsr $01942d			jsr 	FPFromString				; try for a float part.
.0189ae	ad 28 04	lda $0428			lda 	ValSign 					; was it negative
.0189b1	d0 13		bne $0189c6			bne 	_UVNotNegative
.0189b3	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; check if integer
.0189b6	4a		lsr a				lsr 	a
.0189b7	b0 0a		bcs $0189c3			bcs 	_UVInteger
.0189b9	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; set sign bit
.0189bc	09 80		ora #$80			ora 	#$80
.0189be	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0189c1	80 03		bra $0189c6			bra 	_UVNotNegative
.0189c3					_UVInteger:
.0189c3	20 5a 8d	jsr $018d5a			jsr 	IntegerNegateAlways 		; sign it.
.0189c6					_UVNotNegative:
.0189c6	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; used everything
.0189c8	d0 02		bne $0189cc			bne 	_UVBadNumber
.0189ca	7a		ply				ply
.0189cb	60		rts				rts
.0189cc					_UVBadNumber:
.0189cc	80 fe		bra $0189cc		_error: bra _error

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.0189ce					Unary_Str:
.0189ce	20 bb 85	jsr $0185bb			jsr 	EvaluateNumberX 			; numeric parameter
.0189d1	20 0f 8c	jsr $018c0f			jsr 	CheckNextRParen 			; right bracket.
.0189d4	a9 00		lda #$00			lda 	#0 							; reset buffer index
.0189d6	8d 20 04	sta $0420			sta 	NumBufX
.0189d9	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.0189dc	4a		lsr a				lsr 	a
.0189dd	b0 05		bcs $0189e4			bcs 	_USInt 						; if msb set do as integer
.0189df	20 66 93	jsr $019366			jsr 	FPToString 					; call fp to str otherwise
.0189e2	80 03		bra $0189e7			bra 	_USDuplicate
.0189e4	20 7f 8d	jsr $018d7f	_USInt:	jsr 	IntToString
.0189e7					_USDuplicate:
.0189e7	ad 20 04	lda $0420			lda 	NumBufX 					; chars in buffer
.0189ea	1a		inc a				inc 	a 							; one more for length
.0189eb	20 1f 8c	jsr $018c1f			jsr 	AllocateTempString 			; allocate space for it.
.0189ee	5a		phy				phy 								; save Y
.0189ef	a0 00		ldy #$00			ldy 	#0 							; start copying
.0189f1	b9 00 04	lda $0400,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.0189f4	20 4a 8c	jsr $018c4a			jsr 	WriteTempString
.0189f7	c8		iny				iny
.0189f8	cc 20 04	cpy $0420			cpy 	NumBufX 					; done the lot
.0189fb	d0 f4		bne $0189f1			bne 	_USCopy
.0189fd	7a		ply				ply 								; restore Y
.0189fe	4c e5 8b	jmp $018be5			jmp 	UnaryReturnTempStr 			; return new temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.018a01					Unary_Asc:
.018a01	20 d3 85	jsr $0185d3			jsr 	EvaluateStringX 			; string parameter
.018a04	20 0f 8c	jsr $018c0f			jsr 	CheckNextRParen 			; right bracket.
.018a07	5a		phy				phy 								; get the string length
.018a08	a0 00		ldy #$00			ldy 	#0
.018a0a	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018a0c	f0 07		beq $018a15			beq 	_UAIllegal 					; must be at least one character
.018a0e	c8		iny				iny
.018a0f	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; read it.
.018a11	7a		ply				ply
.018a12	4c 81 88	jmp $018881			jmp 	UnarySetAInteger
.018a15					_UAIllegal:
.018a15	80 fe		bra $018a15		_error: bra _error

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.018a17					Unary_Len:
.018a17	20 d3 85	jsr $0185d3			jsr 	EvaluateStringX 			; string parameter
.018a1a	20 0f 8c	jsr $018c0f			jsr 	CheckNextRParen 			; right bracket.
.018a1d	5a		phy				phy 								; get the string length
.018a1e	a0 00		ldy #$00			ldy 	#0
.018a20	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018a22	7a		ply				ply
.018a23	4c 81 88	jmp $018881			jmp 	UnarySetAInteger

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.018a26					Unary_Mid:
.018a26	20 d3 85	jsr $0185d3			jsr 	EvaluateStringX 				; get string.
.018a29	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.018a2c	48		pha				pha
.018a2d	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018a30	48		pha				pha
.018a31	20 17 8c	jsr $018c17			jsr 	CheckNextComma 					; skip comma
.018a34	20 c1 8a	jsr $018ac1			jsr 	SLIByteParameter 				; get a byte parameter (start)
.018a37	48		pha				pha 									; and push it.
.018a38	20 17 8c	jsr $018c17			jsr 	CheckNextComma 					; skip comma
.018a3b	20 c1 8a	jsr $018ac1			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.018a3e	48		pha				pha 									; and push it.
.018a3f	80 45		bra $018a86			bra 	SLIProcess
.018a41					Unary_Left:
.018a41	20 d3 85	jsr $0185d3			jsr 	EvaluateStringX 				; get string.
.018a44	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.018a47	48		pha				pha
.018a48	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018a4b	48		pha				pha
.018a4c	a9 01		lda #$01			lda 	#1 								; push start position (1)
.018a4e	48		pha				pha
.018a4f	20 17 8c	jsr $018c17			jsr 	CheckNextComma 					; skip comma
.018a52	20 c1 8a	jsr $018ac1			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.018a55	48		pha				pha 									; and push it.
.018a56	80 2e		bra $018a86			bra 	SLIProcess
.018a58					Unary_Right:
.018a58	20 d3 85	jsr $0185d3			jsr 	EvaluateStringX 				; get string.
.018a5b	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.018a5e	48		pha				pha
.018a5f	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018a62	48		pha				pha
.018a63	da		phx				phx 									; get the string length and push on stack.
.018a64	a2 00		ldx #$00			ldx 	#0
.018a66	a1 1e		lda ($1e,x)			lda		(zGenPtr,x)
.018a68	fa		plx				plx
.018a69	48		pha				pha
.018a6a	20 17 8c	jsr $018c17			jsr 	CheckNextComma 					; skip comma
.018a6d	20 c1 8a	jsr $018ac1			jsr 	SLIByteParameter 				; get a byte parameter.
.018a70	8d 25 04	sta $0425			sta 	SignCount 						; save in temporary.
.018a73	68		pla				pla 									; restore string length.
.018a74	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.018a75	38		sec				sec
.018a76	ed 25 04	sbc $0425			sbc 	SignCount 						; subtract characters needed, gives start position.
.018a79	f0 02		beq $018a7d			beq 	_URStart 						; if <= 0 start from 1.
.018a7b	10 02		bpl $018a7f			bpl 	_UROkay
.018a7d					_URStart:
.018a7d	a9 01		lda #$01			lda 	#1
.018a7f					_UROkay:
.018a7f	48		pha				pha 									; push start
.018a80	ad 25 04	lda $0425			lda 	SignCount 						; push count of characters
.018a83	48		pha				pha
.018a84	80 00		bra $018a86			bra 	SLIProcess
.018a86					SLIProcess:
.018a86	20 0f 8c	jsr $018c0f			jsr 	CheckNextRParen 				; closing right bracket.
.018a89	68		pla				pla
.018a8a	8d 2a 04	sta $042a			sta 	SliceCount 						; count in signcount
.018a8d	1a		inc a				inc 	a 								; allocate +1 for it.
.018a8e	20 1f 8c	jsr $018c1f			jsr 	AllocateTempString
.018a91	68		pla				pla 									; pop start number off stack.
.018a92	f0 3f		beq $018ad3			beq 	SLIError 						; exit if start = 0
.018a94	8d 29 04	sta $0429			sta 	SliceStart
.018a97	68		pla				pla  									; pop string address.
.018a98	85 1f		sta $1f				sta 	zGenPtr+1
.018a9a	68		pla				pla
.018a9b	85 1e		sta $1e				sta 	zGenPtr
.018a9d	da		phx				phx
.018a9e	5a		phy				phy
.018a9f	a2 00		ldx #$00			ldx 	#0 								; point to string length.
.018aa1	ac 29 04	ldy $0429			ldy 	SliceStart 						; start of the string (+1 for count)
.018aa4					_SLICopy:
.018aa4	ad 2a 04	lda $042a			lda 	SliceCount 						; done count characters
.018aa7	f0 12		beq $018abb			beq 	_SLIExit
.018aa9	ce 2a 04	dec $042a			dec 	SliceCount
.018aac	98		tya				tya 									; index of character
.018aad	c1 1e		cmp ($1e,x)			cmp 	(zGenPtr,x)						; compare against length
.018aaf	f0 02		beq $018ab3			beq 	_SLIOk 							; if equal, okay.
.018ab1	b0 08		bcs $018abb			bcs 	_SLIExit 						; if past end, then exit.
.018ab3	b1 1e		lda ($1e),y	_SLIOk:	lda 	(zGenPtr),y 					; copy one character
.018ab5	c8		iny				iny
.018ab6	20 4a 8c	jsr $018c4a			jsr 	WriteTempString
.018ab9	80 e9		bra $018aa4			bra 	_SLICopy 						; go round till copied characters
.018abb					_SLIExit:
.018abb	7a		ply				ply 									; restore YX
.018abc	fa		plx				plx
.018abd	4c e5 8b	jmp $018be5			jmp 	UnaryReturnTempStr 				; return new temporary string.
.018ac0	ea		nop				nop
.018ac1					SLIByteParameter:
.018ac1	20 ca 85	jsr $0185ca			jsr 	EvaluateIntegerX 				; get integer
.018ac4	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.018ac7	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.018aca	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.018acd	d0 04		bne $018ad3			bne 	SLIError
.018acf	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018ad2	60		rts				rts
.018ad3					SLIError:
.018ad3	80 fe		bra $018ad3		_error: bra _error

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.018ad5					Unary_Hex:
.018ad5	20 ca 85	jsr $0185ca			jsr 	EvaluateIntegerX 			; numeric parameter
.018ad8	20 0f 8c	jsr $018c0f			jsr 	CheckNextRParen 			; right bracket.
.018adb	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.018add	20 1f 8c	jsr $018c1f			jsr 	AllocateTempString			; allocate string space
.018ae0	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.018ae3	20 0a 8b	jsr $018b0a			jsr 	_UHConvert
.018ae6	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018ae9	20 0a 8b	jsr $018b0a			jsr 	_UHConvert
.018aec	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018aef	20 0a 8b	jsr $018b0a			jsr 	_UHConvert
.018af2	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018af5	20 0a 8b	jsr $018b0a			jsr 	_UHConvert
.018af8	5a		phy				phy 								; get length of new string
.018af9	a0 00		ldy #$00			ldy 	#0
.018afb	b1 20		lda ($20),y			lda 	(zTempStr),y
.018afd	7a		ply				ply
.018afe	c9 00		cmp #$00			cmp 	#0
.018b00	d0 05		bne $018b07			bne 	_UHExit 					; if it was non zero okay
.018b02	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.018b04	20 4a 8c	jsr $018c4a			jsr 	WriteTempString
.018b07					_UHExit:
.018b07	4c e5 8b	jmp $018be5			jmp 	UnaryReturnTempStr 			; return new temporary string.
.018b0a					_UHConvert:
.018b0a	48		pha				pha
.018b0b	4a		lsr a				lsr 	a 							; do MSB
.018b0c	4a		lsr a				lsr 	a
.018b0d	4a		lsr a				lsr 	a
.018b0e	4a		lsr a				lsr 	a
.018b0f	20 13 8b	jsr $018b13			jsr 	_UHNibble
.018b12	68		pla				pla 								; do LSB
.018b13					_UHNibble:
.018b13	29 0f		and #$0f			and 	#15 						; get nibble
.018b15	d0 0c		bne $018b23			bne 	_UHNonZero
.018b17	5a		phy				phy									; get the length
.018b18	a0 00		ldy #$00			ldy 	#0
.018b1a	b1 20		lda ($20),y			lda 	(zTempStr),y
.018b1c	7a		ply				ply
.018b1d	c9 00		cmp #$00			cmp 	#0 							; suppress leading zeros.
.018b1f	f0 0d		beq $018b2e			beq 	_UHExit2
.018b21	a9 00		lda #$00			lda 	#0
.018b23					_UHNonZero:
.018b23	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.018b25	90 02		bcc $018b29			bcc 	_UHDigit
.018b27	69 06		adc #$06			adc 	#7-1
.018b29					_UHDigit:
.018b29	69 30		adc #$30			adc 	#48
.018b2b	20 4a 8c	jsr $018c4a			jsr 	WriteTempString				; output.
.018b2e					_UHExit2:
.018b2e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.018b2f					Unary_Dec:
.018b2f	20 d3 85	jsr $0185d3			jsr 	EvaluateStringX 			; string parameter
.018b32	20 0f 8c	jsr $018c0f			jsr 	CheckNextRParen 			; right bracket.
.018b35	5a		phy				phy
.018b36	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.018b38	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018b3a	f0 4c		beq $018b88			beq 	_UDFail 					; must fail if zero.
.018b3c	8d 25 04	sta $0425			sta 	SignCount 					; use SignCount as a counter
.018b3f	a9 00		lda #$00			lda 	#0 							; set result to zero integer.
.018b41	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018b44	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018b47	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018b4a	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018b4d	a9 01		lda #$01			lda 	#1
.018b4f	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018b52					_UDConvertLoop:
.018b52	5a		phy				phy 								; shift mantissa left 4
.018b53	a0 04		ldy #$04			ldy 	#4
.018b55					_UDShift:
.018b55	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x
.018b58	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.018b5b	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.018b5e	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.018b61	88		dey				dey
.018b62	d0 f1		bne $018b55			bne 	_UDShift
.018b64	7a		ply				ply
.018b65	c8		iny				iny 								; next character
.018b66	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; fetch it.
.018b68	20 8a 8b	jsr $018b8a			jsr 	ConvertUpper 				; convert to U/C
.018b6b	c9 30		cmp #$30			cmp 	#"0"
.018b6d	90 19		bcc $018b88			bcc 	_UDFail
.018b6f	c9 3a		cmp #$3a			cmp 	#"9"+1
.018b71	90 06		bcc $018b79			bcc 	_UDOkay
.018b73	e9 37		sbc #$37			sbc 	#7+"0" 						; alpha fudge
.018b75	c9 10		cmp #$10			cmp 	#16
.018b77	b0 0f		bcs $018b88			bcs 	_UDFail
.018b79					_UDOkay:
.018b79	29 0f		and #$0f			and 	#15 						; nibble only
.018b7b	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x
.018b7e	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018b81	ce 25 04	dec $0425			dec 	SignCount 					; do it for each character
.018b84	d0 cc		bne $018b52			bne 	_UDConvertLoop
.018b86	7a		ply				ply
.018b87	60		rts				rts
.018b88					_UDFail:
.018b88	80 fe		bra $018b88		_error: bra _error
.018b8a					ConvertUpper:
.018b8a	c9 61		cmp #$61			cmp 	#"a"
.018b8c	90 07		bcc $018b95			bcc 	_CUExit
.018b8e	c9 7b		cmp #$7b			cmp 	#"z"+1
.018b90	b0 03		bcs $018b95			bcs 	_CUExit
.018b92	38		sec				sec
.018b93	e9 20		sbc #$20			sbc 	#32
.018b95	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.018b96					Unary_Chr:
.018b96	20 ca 85	jsr $0185ca			jsr 	EvaluateIntegerX			; numeric parameter
.018b99	20 0f 8c	jsr $018c0f			jsr 	CheckNextRParen 			; right bracket.
.018b9c	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.018b9f	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.018ba2	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.018ba5	d0 0e		bne $018bb5			bne 	_UCChar
.018ba7	a9 01		lda #$01			lda 	#1 							; one character string
.018ba9	20 1f 8c	jsr $018c1f			jsr 	AllocateTempString
.018bac	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.018baf	20 4a 8c	jsr $018c4a			jsr 	WriteTempString
.018bb2	4c e5 8b	jmp $018be5			jmp 	UnaryReturnTempStr
.018bb5					_UCChar:
.018bb5	80 fe		bra $018bb5		_error: bra _error

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.018bb7					Unary_Spc:
.018bb7	20 ca 85	jsr $0185ca			jsr 	EvaluateIntegerX 			; numeric parameter
.018bba	20 0f 8c	jsr $018c0f			jsr 	CheckNextRParen 			; right bracket.
.018bbd	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.018bc0	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.018bc3	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.018bc6	d0 1b		bne $018be3			bne 	_USSize
.018bc8	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018bcb	c9 fe		cmp #$fe			cmp 	#maxString+1
.018bcd	b0 14		bcs $018be3			bcs 	_USSize
.018bcf	48		pha				pha 								; save length
.018bd0	1a		inc a				inc 	a 							; allocate one more.
.018bd1	20 1f 8c	jsr $018c1f			jsr 	AllocateTempString
.018bd4	68		pla				pla 								; get length
.018bd5	f0 0e		beq $018be5			beq 	UnaryReturnTempStr 			; return the current temp string
.018bd7					_USLoop:
.018bd7	48		pha				pha
.018bd8	a9 20		lda #$20			lda 	#" "
.018bda	20 4a 8c	jsr $018c4a			jsr 	WriteTempString
.018bdd	68		pla				pla
.018bde	3a		dec a				dec 	a
.018bdf	d0 f6		bne $018bd7			bne 	_USLoop
.018be1	80 02		bra $018be5			bra 	UnaryReturnTempStr
.018be3					_USSize:
.018be3	80 fe		bra $018be3		_error: bra _error
.018be5					UnaryReturnTempStr:
.018be5	a5 20		lda $20				lda 	zTempStr 					; copy temp string addr -> mantissa
.018be7	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018bea	a5 21		lda $21				lda 	zTempStr+1
.018bec	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018bef	a9 02		lda #$02			lda 	#2 							; set type to string
.018bf1	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018bf4	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/65816.asm

.018bf5					MemRead:
.018bf5	8d 25 04	sta $0425			sta 	SignCount 					; save count
.018bf8	a0 00		ldy #$00			ldy 	#0 							; start from here
.018bfa	b7 1a		lda [$1a],y	_MLoop1:lda 	[zlTemp1],y 				; read the long address
.018bfc	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; copy into mantissa
.018bff	c8		iny				iny 								; next to copy
.018c00	e8		inx				inx
.018c01	cc 25 04	cpy $0425			cpy 	SignCount 					; do required # of bytes.
.018c04	d0 f4		bne $018bfa			bne 	_MLoop1
.018c06	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.018c07					CheckNextToken:
.018c07	d1 16		cmp ($16),y			cmp 	(zCodePtr),y
.018c09	d0 02		bne $018c0d			bne 	CTFail 						; no, then fail
.018c0b	c8		iny				iny
.018c0c	60		rts				rts
.018c0d					CTFail:
.018c0d	80 fe		bra $018c0d		_error: bra _error
.018c0f					CheckNextRParen:
.018c0f	b1 16		lda ($16),y			lda 	(zCodePtr),y
.018c11	c9 bc		cmp #$bc			cmp 	#token_rparen
.018c13	d0 f8		bne $018c0d			bne 	CTFail
.018c15	c8		iny				iny
.018c16	60		rts				rts
.018c17					CheckNextComma:
.018c17	b1 16		lda ($16),y			lda 	(zCodePtr),y
.018c19	c9 bd		cmp #$bd			cmp 	#token_comma
.018c1b	d0 f0		bne $018c0d			bne 	CTFail
.018c1d	c8		iny				iny
.018c1e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.018c1f					AllocateTempString:
.018c1f	48		pha				pha 								; save required count.
.018c20	a5 21		lda $21				lda 	zTempStr+1 					; check if initialised yet ?
.018c22	d0 0b		bne $018c2f			bne 	_ATSInitialised
.018c24	ad 26 04	lda $0426			lda 	StringPtr 					; set temporary string ptr 1 page below available
.018c27	85 20		sta $20				sta 	zTempStr					; space, this is for strings to be concreted.
.018c29	ad 27 04	lda $0427			lda 	StringPtr+1
.018c2c	3a		dec a				dec 	a
.018c2d	85 21		sta $21				sta 	zTempStr+1
.018c2f					_ATSInitialised:
.018c2f	68		pla				pla 								; get required count back.
.018c30	49 ff		eor #$ff			eor 	#$FF 						; negate 2's complement.
.018c32	1a		inc a				inc 	a
.018c33	18		clc				clc
.018c34	65 20		adc $20				adc 	zTempStr 					; "add" to the temp string pointer
.018c36	85 20		sta $20				sta 	zTempStr
.018c38	a9 ff		lda #$ff			lda 	#$FF
.018c3a	65 21		adc $21				adc 	zTempStr+1
.018c3c	85 21		sta $21				sta 	zTempStr+1
.018c3e	a9 00		lda #$00			lda 	#0 							; clear temp string.
.018c40	5a		phy				phy
.018c41	a8		tay				tay
.018c42	91 20		sta ($20),y			sta 	(zTempStr),y
.018c44	7a		ply				ply
.018c45	1a		inc a				inc 	a 							; reset the write index.
.018c46	8d 27 04	sta $0427			sta 	TempStringWriteIndex
.018c49	60		rts				rts
.018c4a					WriteTempString:
.018c4a	5a		phy				phy 								; save Y
.018c4b	ac 27 04	ldy $0427			ldy 	TempStringWriteIndex	 	; write position.
.018c4e	91 20		sta ($20),y			sta 	(zTempStr),y 				; write character out.
.018c50	ee 27 04	inc $0427			inc 	TempStringWriteIndex 		; increment the write position.
.018c53	98		tya				tya 								; unchanged Y is now length
.018c54	a0 00		ldy #$00			ldy 	#0
.018c56	91 20		sta ($20),y			sta 	(zTempStr),y
.018c58	7a		ply				ply 								; restore Y and exit
.018c59	60		rts				rts
.018c5a					CreateTempStringCopy:
.018c5a	da		phx				phx 								; save X
.018c5b	b1 16		lda ($16),y			lda 	(zCodePtr),y
.018c5d	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.018c5e	20 1f 8c	jsr $018c1f			jsr 	AllocateTempString 			; allocate memory for temporary string.
.018c61	b1 16		lda ($16),y			lda 	(zCodePtr),y
.018c63	c8		iny				iny
.018c64	3a		dec a				dec 	a 							; make the actual length in charactes
.018c65	3a		dec a				dec 	a
.018c66	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.018c68	81 20		sta ($20,x)			sta 	(zTempStr,x)
.018c6a	85 1a		sta $1a				sta 	zLTemp1 					; that's used as a count.
.018c6c	09 00		ora #$00			ora 	#0 							; if zero already, exit
.018c6e	f0 0d		beq $018c7d			beq 	_CTSCExit
.018c70					_CTSCLoop:
.018c70	b1 16		lda ($16),y			lda 	(zCodePtr),y
.018c72	c8		iny				iny
.018c73	5a		phy				phy 								; save in Y
.018c74	e8		inx				inx 								; bump index
.018c75	9b		txy				txy 								; index into Y
.018c76	91 20		sta ($20),y			sta 	(zTempStr),y 				; save at index
.018c78	7a		ply				ply 								; restore Y
.018c79	c6 1a		dec $1a				dec 	zLTemp1 					; do for each character
.018c7b	d0 f3		bne $018c70			bne 	_CTSCLoop
.018c7d					_CTSCExit:
.018c7d	fa		plx				plx 								; restore X
.018c7e	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.018c7f					MulInteger32:
.018c7f	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.018c82	9d 14 03	sta $0314,x			sta 	XS3_Mantissa,x
.018c85	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018c88	9d 15 03	sta $0315,x			sta 	XS3_Mantissa+1,x
.018c8b	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018c8e	9d 16 03	sta $0316,x			sta 	XS3_Mantissa+2,x
.018c91	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.018c94	9d 17 03	sta $0317,x			sta 	XS3_Mantissa+3,x
.018c97	a9 00		lda #$00			lda 	#0
.018c99	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x 				; zero +0
.018c9c	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018c9f	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018ca2	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018ca5					_BFMMultiply:
.018ca5	bd 14 03	lda $0314,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.018ca8	29 01		and #$01			and 	#1
.018caa	f0 03		beq $018caf			beq 	_BFMNoAdd
.018cac	20 ae 87	jsr $0187ae			jsr 	AddInteger32
.018caf					_BFMNoAdd:
.018caf	1e 0e 03	asl $030e,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.018cb2	3e 0f 03	rol $030f,x			rol 	XS2_Mantissa+1,x
.018cb5	3e 10 03	rol $0310,x			rol 	XS2_Mantissa+2,x
.018cb8	3e 11 03	rol $0311,x			rol 	XS2_Mantissa+3,x
.018cbb	5e 17 03	lsr $0317,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.018cbe	7e 16 03	ror $0316,x			ror 	XS3_Mantissa+2,x
.018cc1	7e 15 03	ror $0315,x			ror 	XS3_Mantissa+1,x
.018cc4	7e 14 03	ror $0314,x			ror 	XS3_Mantissa,x
.018cc7	bd 14 03	lda $0314,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.018cca	1d 15 03	ora $0315,x			ora 	XS3_Mantissa+1,x
.018ccd	1d 16 03	ora $0316,x			ora 	XS3_Mantissa+2,x
.018cd0	1d 17 03	ora $0317,x			ora 	XS3_Mantissa+3,x
.018cd3	d0 d0		bne $018ca5			bne 	_BFMMultiply
.018cd5	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.018cd6					DivInteger32:
.018cd6	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; check for /0
.018cd9	1d 0f 03	ora $030f,x			ora 	XS2_Mantissa+1,x
.018cdc	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.018cdf	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.018ce2	d0 02		bne $018ce6			bne 	_BFDOkay
.018ce4	80 fe		bra $018ce4		_error: bra _error
.018ce6					_BFDOkay:
.018ce6	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.018ce8	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.018cea	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.018cec	85 1c		sta $1c				sta 	zLTemp1+2
.018cee	85 1d		sta $1d				sta 	zLTemp1+3
.018cf0	8d 25 04	sta $0425			sta 	SignCount 					; Count of signs.
.018cf3	20 54 8d	jsr $018d54			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.018cf6	da		phx				phx
.018cf7	e8		inx				inx
.018cf8	e8		inx				inx
.018cf9	e8		inx				inx
.018cfa	e8		inx				inx
.018cfb	e8		inx				inx
.018cfc	e8		inx				inx
.018cfd	20 54 8d	jsr $018d54			jsr 	CheckIntegerNegate
.018d00	fa		plx				plx
.018d01	5a		phy				phy 								; Y is the counter
.018d02	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.018d04					_BFDLoop:
.018d04	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.018d07	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.018d0a	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.018d0d	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.018d10	26 1a		rol $1a				rol 	zLTemp1
.018d12	26 1b		rol $1b				rol 	zLTemp1+1
.018d14	26 1c		rol $1c				rol 	zLTemp1+2
.018d16	26 1d		rol $1d				rol 	zLTemp1+3
.018d18	38		sec				sec
.018d19	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.018d1b	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.018d1e	48		pha				pha
.018d1f	a5 1b		lda $1b				lda 	zLTemp1+1
.018d21	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.018d24	48		pha				pha
.018d25	a5 1c		lda $1c				lda 	zLTemp1+2
.018d27	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.018d2a	48		pha				pha
.018d2b	a5 1d		lda $1d				lda 	zLTemp1+3
.018d2d	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.018d30	90 15		bcc $018d47			bcc 	_BFDNoAdd
.018d32	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.018d34	68		pla				pla
.018d35	85 1c		sta $1c				sta 	zLTemp1+2
.018d37	68		pla				pla
.018d38	85 1b		sta $1b				sta 	zLTemp1+1
.018d3a	68		pla				pla
.018d3b	85 1a		sta $1a				sta 	zLTemp1+0
.018d3d	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.018d40	09 01		ora #$01			ora 	#1
.018d42	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018d45	80 03		bra $018d4a			bra 	_BFDNext
.018d47					_BFDNoAdd:
.018d47	68		pla				pla 								; Throw away the intermediate calculations
.018d48	68		pla				pla
.018d49	68		pla				pla
.018d4a					_BFDNext:
.018d4a	88		dey				dey
.018d4b	d0 b7		bne $018d04			bne 	_BFDLoop
.018d4d	7a		ply				ply 								; restore Y and exit
.018d4e	4e 25 04	lsr $0425			lsr 	SignCount 					; if sign count odd,
.018d51	b0 07		bcs $018d5a			bcs		IntegerNegateAlways 			; negate the result
.018d53	60		rts				rts
.018d54					CheckIntegerNegate:
.018d54	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.018d57	30 01		bmi $018d5a			bmi 	IntegerNegateAlways
.018d59	60		rts				rts
.018d5a					IntegerNegateAlways:
.018d5a	ee 25 04	inc $0425			inc 	SignCount
.018d5d	38		sec				sec
.018d5e	a9 00		lda #$00			lda 	#0
.018d60	fd 08 03	sbc $0308,x			sbc 	XS_Mantissa+0,x
.018d63	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018d66	a9 00		lda #$00			lda 	#0
.018d68	fd 09 03	sbc $0309,x			sbc 	XS_Mantissa+1,x
.018d6b	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018d6e	a9 00		lda #$00			lda 	#0
.018d70	fd 0a 03	sbc $030a,x			sbc 	XS_Mantissa+2,x
.018d73	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018d76	a9 00		lda #$00			lda 	#0
.018d78	fd 0b 03	sbc $030b,x			sbc 	XS_Mantissa+3,x
.018d7b	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018d7e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.018d7f					INTToString:
.018d7f	48		pha				pha
.018d80	5a		phy				phy
.018d81	bd 0b 03	lda $030b,x			lda 		XS_Mantissa+3,x 		; check -ve
.018d84	10 08		bpl $018d8e			bpl 		_ITSNotMinus
.018d86	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.018d88	20 21 8e	jsr $018e21			jsr 		ITSOutputCharacter
.018d8b	20 5a 8d	jsr $018d5a			jsr 		IntegerNegateAlways 	; negate the number.
.018d8e					_ITSNotMinus:
.018d8e	a9 00		lda #$00			lda 		#0
.018d90	8d 21 04	sta $0421			sta 		NumSuppress 			; clear the suppression flag.
.018d93	9b		txy				txy 								; use Y for the mantissa index.
.018d94	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.018d96					_ITSNextSubtractor:
.018d96	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.018d98	8d 22 04	sta $0422			sta 		NumConvCount
.018d9b					_ITSSubtract:
.018d9b	38		sec				sec
.018d9c	b9 08 03	lda $0308,y			lda 		XS_Mantissa,y 			; subtract number and push on stack
.018d9f	ff fd 8d 01	sbc $018dfd,x			sbc 		_ITSSubtractors+0,x
.018da3	48		pha				pha
.018da4	b9 09 03	lda $0309,y			lda 		XS_Mantissa+1,y
.018da7	ff fe 8d 01	sbc $018dfe,x			sbc 		_ITSSubtractors+1,x
.018dab	48		pha				pha
.018dac	b9 0a 03	lda $030a,y			lda 		XS_Mantissa+2,y
.018daf	ff ff 8d 01	sbc $018dff,x			sbc 		_ITSSubtractors+2,x
.018db3	48		pha				pha
.018db4	b9 0b 03	lda $030b,y			lda 		XS_Mantissa+3,y
.018db7	ff 00 8e 01	sbc $018e00,x			sbc 		_ITSSubtractors+3,x
.018dbb	90 14		bcc $018dd1			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.018dbd	99 0b 03	sta $030b,y			sta 		XS_Mantissa+3,y 		; save subtract off stack
.018dc0	68		pla				pla
.018dc1	99 0a 03	sta $030a,y			sta 		XS_Mantissa+2,y
.018dc4	68		pla				pla
.018dc5	99 09 03	sta $0309,y			sta 		XS_Mantissa+1,y
.018dc8	68		pla				pla
.018dc9	99 08 03	sta $0308,y			sta 		XS_Mantissa+0,y
.018dcc	ee 22 04	inc $0422			inc 		NumConvCount 			; bump count.
.018dcf	80 ca		bra $018d9b			bra 		_ITSSubtract 			; go round again.
.018dd1					_ITSCantSubtract:
.018dd1	68		pla				pla 								; throw away interim answers
.018dd2	68		pla				pla
.018dd3	68		pla				pla
.018dd4	ad 22 04	lda $0422			lda 		NumConvCount 			; if not zero then no suppression check
.018dd7	c9 30		cmp #$30			cmp 		#"0"
.018dd9	d0 05		bne $018de0			bne 		_ITSOutputDigit
.018ddb	ad 21 04	lda $0421			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.018dde	10 09		bpl $018de9			bpl 		_ITSGoNextSubtractor
.018de0					_ITSOutputDigit:
.018de0	ce 21 04	dec $0421			dec 		NumSuppress 			; suppression check will be non-zero.
.018de3	ad 22 04	lda $0422			lda 		NumConvCount 			; count of subtractions
.018de6	20 21 8e	jsr $018e21			jsr 		ITSOutputCharacter 		; output it.
.018de9					_ITSGoNextSubtractor:
.018de9	e8		inx				inx 								; next dword
.018dea	e8		inx				inx
.018deb	e8		inx				inx
.018dec	e8		inx				inx
.018ded	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.018def	d0 a5		bne $018d96			bne 		_ITSNextSubtractor 		; do all the subtractors.
.018df1	bb		tyx				tyx 								; X is back as the mantissa index
.018df2	bd 08 03	lda $0308,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.018df5	09 30		ora #$30			ora 		#"0"
.018df7	20 21 8e	jsr $018e21			jsr 		ITSOutputCharacter
.018dfa	7a		ply				ply 								; and exit
.018dfb	68		pla				pla
.018dfc	60		rts				rts
.018dfd					_ITSSubtractors:
>018dfd	00 ca 9a 3b					.dword 		1000000000
>018e01	00 e1 f5 05					.dword 		100000000
>018e05	80 96 98 00					.dword 		10000000
>018e09	40 42 0f 00					.dword 		1000000
>018e0d	a0 86 01 00					.dword 		100000
>018e11	10 27 00 00					.dword 		10000
>018e15	e8 03 00 00					.dword 		1000
>018e19	64 00 00 00					.dword 		100
>018e1d	0a 00 00 00					.dword 		10
.018e21					_ITSSubtractorsEnd:
.018e21					ITSOutputCharacter:
.018e21	48		pha				pha
.018e22	da		phx				phx
.018e23	ae 20 04	ldx $0420			ldx 	NumBufX 					; save digit
.018e26	9d 00 04	sta $0400,x			sta 	Num_Buffer,x
.018e29	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.018e2b	9d 01 04	sta $0401,x			sta 	Num_Buffer+1,x
.018e2e	ee 20 04	inc $0420			inc 	NumBufX						; bump pointer.
.018e31	fa		plx				plx
.018e32	68		pla				pla
.018e33	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.018e34					IntFromString:
.018e34	a0 00		ldy #$00			ldy 	#0
.018e36	8c 23 04	sty $0423			sty 	ExpTemp 					; this is the converted digit count.
.018e39					IntFromStringY:
.018e39	48		pha				pha
.018e3a	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.018e3c	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.018e3f	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018e42	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018e45	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018e48	a9 01		lda #$01			lda 	#1
.018e4a	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018e4d					_IFSLoop:
.018e4d	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.018e4f	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.018e51	90 60		bcc $018eb3			bcc 	_IFSExit
.018e53	c9 3a		cmp #$3a			cmp 	#"9"+1
.018e55	b0 5c		bcs $018eb3			bcs 	_IFSExit
.018e57	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.018e5a	c9 0c		cmp #$0c			cmp 	#12
.018e5c	b0 5f		bcs $018ebd			bcs 	_IFSOverflow
.018e5e	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.018e61	48		pha				pha
.018e62	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018e65	48		pha				pha
.018e66	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018e69	48		pha				pha
.018e6a	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018e6d	48		pha				pha
.018e6e	20 d2 8e	jsr $018ed2			jsr 	IFSX1ShiftLeft 				; double
.018e71	20 d2 8e	jsr $018ed2			jsr 	IFSX1ShiftLeft 				; x 4
.018e74	18		clc				clc 								; add saved value x 5
.018e75	68		pla				pla
.018e76	7d 08 03	adc $0308,x			adc 	XS_Mantissa+0,x
.018e79	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018e7c	68		pla				pla
.018e7d	7d 09 03	adc $0309,x			adc 	XS_Mantissa+1,x
.018e80	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018e83	68		pla				pla
.018e84	7d 0a 03	adc $030a,x			adc 	XS_Mantissa+2,x
.018e87	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018e8a	68		pla				pla
.018e8b	7d 0b 03	adc $030b,x			adc 	XS_Mantissa+3,x
.018e8e	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018e91	20 d2 8e	jsr $018ed2			jsr 	IFSX1ShiftLeft 				; x 10
.018e94	ee 23 04	inc $0423			inc 	ExpTemp 					; bump count of digits processed.
.018e97	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.018e99	29 0f		and #$0f			and 	#15
.018e9b	c8		iny				iny
.018e9c	7d 08 03	adc $0308,x			adc 	XS_Mantissa+0,x
.018e9f	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018ea2	90 a9		bcc $018e4d			bcc 	_IFSLoop
.018ea4	fe 09 03	inc $0309,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.018ea7	d0 a4		bne $018e4d			bne 	_IFSLoop
.018ea9	fe 0a 03	inc $030a,x			inc 	XS_Mantissa+2,x
.018eac	d0 9f		bne $018e4d			bne 	_IFSLoop
.018eae	fe 0b 03	inc $030b,x			inc 	XS_Mantissa+3,x
.018eb1	80 9a		bra $018e4d			bra 	_IFSLoop
.018eb3					_IFSExit:
.018eb3	98		tya				tya 								; get offset
.018eb4					_IFSOkay:
.018eb4	38		sec				sec
.018eb5	ad 23 04	lda $0423			lda 	ExpTemp
.018eb8	f0 01		beq $018ebb			beq 	_IFSSkipFail
.018eba	18		clc				clc
.018ebb					_IFSSkipFail:
.018ebb	68		pla				pla 								; and exit.
.018ebc	60		rts				rts
.018ebd					_IFSOverflow:
.018ebd	20 17 84	jsr $018417			jsr 	ERR_Handler
>018ec0	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>018ec8	20 6f 76 65 72 66 6c 6f 77 00
.018ed2					IFSX1ShiftLeft:
.018ed2	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x
.018ed5	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.018ed8	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.018edb	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.018ede	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.018edf					FPSubtract:
.018edf	48		pha				pha
.018ee0	bd 13 03	lda $0313,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.018ee3	49 80		eor #$80			eor 	#$80
.018ee5	9d 13 03	sta $0313,x			sta 	XS2_Type,x
.018ee8	68		pla				pla 								; --- and fall through ---
.018ee9					FPAdd:
.018ee9	48		pha				pha
.018eea	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.018eed	d0 05		bne $018ef4			bne 	_FPA_NegativeLHS
.018eef	20 11 8f	jsr $018f11			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.018ef2	68		pla				pla
.018ef3	60		rts				rts
.018ef4					_FPA_NegativeLHS:
.018ef4	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.018ef7	49 80		eor #$80			eor 	#$80
.018ef9	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018efc	bd 13 03	lda $0313,x			lda 	XS2_Type,x 					; flip the sign of B and add
.018eff	49 80		eor #$80			eor 	#$80
.018f01	9d 13 03	sta $0313,x			sta 	XS2_Type,x
.018f04	20 11 8f	jsr $018f11			jsr 	FPAdd_Worker 				; do the add calculation.
.018f07	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip sign of X1 back
.018f0a	49 80		eor #$80			eor 	#$80
.018f0c	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018f0f	68		pla				pla
.018f10	60		rts				rts
.018f11					FPAdd_Worker:
.018f11	3c 13 03	bit $0313,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.018f14	70 08		bvs $018f1e			bvs 	_FPAWExit 					; no change.
.018f16	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.018f19	50 07		bvc $018f22			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.018f1b	20 a4 91	jsr $0191a4			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.018f1e					_FPAWExit:
.018f1e	20 2c 92	jsr $01922c			jsr 	FPUNormalise 				; normalise the result.
.018f21	60		rts				rts
.018f22					_FPAWMakeSame:
.018f22	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.018f25	38		sec				sec
.018f26	fd 12 03	sbc $0312,x			sbc	 	XS2_Exponent,x 				; using subtraction
.018f29	f0 1b		beq $018f46			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.018f2b	da		phx				phx 								; save X
.018f2c	90 06		bcc $018f34			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.018f2e	e8		inx				inx
.018f2f	e8		inx				inx
.018f30	e8		inx				inx
.018f31	e8		inx				inx
.018f32	e8		inx				inx
.018f33	e8		inx				inx
.018f34					_FPAWShiftA:
.018f34	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x 				; so shift exponent up.
.018f37	5e 0b 03	lsr $030b,x			lsr 	3+XS_Mantissa,x
.018f3a	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.018f3d	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.018f40	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.018f43	fa		plx				plx 								; restore original X
.018f44	80 dc		bra $018f22			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.018f46					_FPAW_DoArithmetic:
.018f46	3c 13 03	bit $0313,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.018f49	30 39		bmi $018f84			bmi 	_FPAW_BNegative
.018f4b	18		clc				clc
.018f4c	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018f4f	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.018f52	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018f55	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018f58	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.018f5b	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018f5e	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018f61	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.018f64	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018f67	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.018f6a	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.018f6d	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018f70	90 ac		bcc $018f1e			bcc 	_FPAWExit 					; no carry.
.018f72	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x 				; so shift exponent up.
.018f75	38		sec				sec
.018f76	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.018f79	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.018f7c	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.018f7f	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.018f82	80 9a		bra $018f1e			bra 	_FPAWExit
.018f84					_FPAW_BNegative:
.018f84	38		sec				sec
.018f85	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018f88	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.018f8b	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018f8e	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018f91	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.018f94	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018f97	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018f9a	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.018f9d	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018fa0	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.018fa3	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.018fa6	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018fa9	b0 0b		bcs $018fb6			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.018fab	20 d1 91	jsr $0191d1			jsr 	FPUNegateInteger			; negate the mantissa
.018fae	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip result sign
.018fb1	49 80		eor #$80			eor 	#$80
.018fb3	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018fb6					_FPAWGoExit:
.018fb6	4c 1e 8f	jmp $018f1e			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.018fb9					FPD_IsDivZero:
.018fb9	80 fe		bra $018fb9		_error: bra _error
.018fbb					FPDivide:
.018fbb	48		pha				pha
.018fbc	5a		phy				phy
.018fbd	3c 13 03	bit $0313,x			bit 	XS2_Type,x 					; check if division by zero
.018fc0	70 f7		bvs $018fb9			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.018fc2	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.018fc5	f0 03		beq $018fca			beq 	_FPDCalculateExp
.018fc7					_FPD_Exit:
.018fc7	7a		ply				ply
.018fc8	68		pla				pla
.018fc9	60		rts				rts
.018fca					_FPDCalculateExp:
.018fca	bd 12 03	lda $0312,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.018fcd	49 ff		eor #$ff			eor 	#$FF
.018fcf	1a		inc a				inc 	a
.018fd0	9d 12 03	sta $0312,x			sta 	XS2_Exponent,x
.018fd3	20 c7 90	jsr $0190c7			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.018fd6	18		clc				clc 	 							; add 1 to the resulting exponent
.018fd7	69 01		adc #$01			adc 	#1
.018fd9	b0 65		bcs $019040			bcs 	_FPD_Overflow 				; which can overflow.
.018fdb	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.018fde	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.018fe0	85 1a		sta $1a				sta 	zLTemp1+0
.018fe2	85 1b		sta $1b				sta 	zLTemp1+1
.018fe4	85 1c		sta $1c				sta 	zLTemp1+2
.018fe6	85 1d		sta $1d				sta 	zLTemp1+3
.018fe8	a0 20		ldy #$20			ldy 	#32 						; times round.
.018fea					_FPD_Loop:
.018fea	38		sec				sec 								; calculate X1-X2 stacking result because we might
.018feb	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; not save it.
.018fee	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa,x
.018ff1	48		pha				pha
.018ff2	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018ff5	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.018ff8	48		pha				pha
.018ff9	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018ffc	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.018fff	48		pha				pha
.019000	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.019003	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.019006	90 17		bcc $01901f			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.019008	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x 			; save results out to A
.01900b	68		pla				pla
.01900c	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01900f	68		pla				pla
.019010	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019013	68		pla				pla
.019014	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019017	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.019019	09 80		ora #$80			ora 	#$80
.01901b	85 1d		sta $1d				sta 	zLTemp1+3
.01901d	80 03		bra $019022			bra 	_FPD_Rotates
.01901f					_FPD_NoSubtract:
.01901f	68		pla				pla 								; throw away unwanted results
.019020	68		pla				pla
.019021	68		pla				pla
.019022					_FPD_Rotates:
.019022	5e 11 03	lsr $0311,x			lsr 	3+XS2_Mantissa,x
.019025	7e 10 03	ror $0310,x			ror 	2+XS2_Mantissa,x
.019028	7e 0f 03	ror $030f,x			ror 	1+XS2_Mantissa,x
.01902b	7e 0e 03	ror $030e,x			ror 	0+XS2_Mantissa,x
.01902e	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.019030	26 1b		rol $1b				rol 	zLTemp1+1
.019032	26 1c		rol $1c				rol 	zLTemp1+2
.019034	26 1d		rol $1d				rol 	zLTemp1+3
.019036	90 02		bcc $01903a			bcc 	_FPD_NoCarry
.019038	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.01903a					_FPD_NoCarry:
.01903a	88		dey				dey 								; do 32 times
.01903b	d0 ad		bne $018fea			bne 	_FPD_Loop
.01903d	4c a4 90	jmp $0190a4			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.019040					_FPD_Overflow:
.019040	4c a1 92	jmp $0192a1			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.019043					FPMultiply:
.019043	48		pha				pha
.019044	5a		phy				phy
.019045	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.019048	70 08		bvs $019052			bvs 	_FPM_Exit
.01904a	3c 13 03	bit $0313,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.01904d	50 06		bvc $019055			bvc 	_FPM_CalcExponent
.01904f	20 a4 91	jsr $0191a4			jsr 	FPUCopyX2ToX1
.019052					_FPM_Exit:
.019052	7a		ply				ply
.019053	68		pla				pla
.019054	60		rts				rts
.019055					_FPM_CalcExponent:
.019055	18		clc				clc
.019056	20 c7 90	jsr $0190c7			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.019059	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x 				; save the result.
.01905c	a9 00		lda #$00			lda 	#0
.01905e	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.019060	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.019062	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.019064	85 1d		sta $1d				sta 	zLTemp1+3
.019066	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.019068					_FPM_Loop:
.019068	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x				; check LSB of long product
.01906b	29 01		and #$01			and 	#1
.01906d	18		clc				clc 								; clear carry for the long rotate.
.01906e	f0 1d		beq $01908d			beq 	_FPM_NoAddition
.019070	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.019071	a5 1a		lda $1a				lda 	zLTemp1+0
.019073	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.019076	85 1a		sta $1a				sta 	zLTemp1+0
.019078	a5 1b		lda $1b				lda 	zLTemp1+1
.01907a	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.01907d	85 1b		sta $1b				sta 	zLTemp1+1
.01907f	a5 1c		lda $1c				lda 	zLTemp1+2
.019081	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.019084	85 1c		sta $1c				sta 	zLTemp1+2
.019086	a5 1d		lda $1d				lda 	zLTemp1+3
.019088	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.01908b	85 1d		sta $1d				sta 	zLTemp1+3
.01908d					_FPM_NoAddition:
.01908d	66 1d		ror $1d				ror 	3+zLTemp1
.01908f	66 1c		ror $1c				ror 	2+zLTemp1
.019091	66 1b		ror $1b				ror 	1+zLTemp1
.019093	66 1a		ror $1a				ror 	0+zLTemp1
.019095	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.019098	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.01909b	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.01909e	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.0190a1	88		dey				dey
.0190a2	d0 c4		bne $019068			bne 	_FPM_Loop 					; do this 32 times.
.0190a4					FPM_CopySignNormalize:
.0190a4	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.0190a6	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.0190a9	a5 1b		lda $1b				lda 	zLTemp1+1
.0190ab	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0190ae	a5 1c		lda $1c				lda 	zLTemp1+2
.0190b0	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0190b3	a5 1d		lda $1d				lda 	zLTemp1+3
.0190b5	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0190b8	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; sign is xor of signs
.0190bb	5d 13 03	eor $0313,x			eor 	XS2_Type,x
.0190be	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0190c1	20 2c 92	jsr $01922c			jsr 	FPUNormalise 				; normalise and exit.
.0190c4	7a		ply				ply
.0190c5	68		pla				pla
.0190c6	60		rts				rts
.0190c7					FPCalculateExponent:
.0190c7	18		clc				clc
.0190c8	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.0190cb	7d 12 03	adc $0312,x			adc 	XS2_Exponent,x
.0190ce	b0 08		bcs $0190d8			bcs 	_FPCECarry 					; carry out ?
.0190d0	10 03		bpl $0190d5			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.0190d2	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.0190d4	60		rts				rts
.0190d5					_FPCEExpZero:
.0190d5	a9 00		lda #$00			lda 	#0
.0190d7	60		rts				rts
.0190d8					_FPCECarry:
.0190d8	30 03		bmi $0190dd			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.0190da	09 80		ora #$80			ora 	#$80 						; put in right range
.0190dc	60		rts				rts
.0190dd					_FPCEOverflow:
.0190dd	4c a1 92	jmp $0192a1			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.0190e0					FPFractionalPart:
.0190e0	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.0190e3	38		sec				sec 								; this flag tells us to keep the fractional part
.0190e4	30 0f		bmi $0190f5			bmi 	FPGetPart
.0190e6	60		rts				rts
.0190e7					FPIntegerPart:
.0190e7	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.0190ea	18		clc				clc 								; this flag says keep the integer part.
.0190eb	30 08		bmi $0190f5			bmi 	FPGetPart 					; -ve exponents are 0..127
.0190ed	48		pha				pha
.0190ee	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.0190f0	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0190f3	68		pla				pla
.0190f4	60		rts				rts
.0190f5					FPGetPart:
.0190f5	48		pha				pha
.0190f6	5a		phy				phy 								; save Y
.0190f7	08		php				php 								; save action
.0190f8	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.0190fb	70 62		bvs $01915f			bvs 	_FPGP_Exit 					; then do nothing.
.0190fd	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.0190ff	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.019101	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.019103	85 1c		sta $1c				sta 	zLTemp1+2
.019105	85 1d		sta $1d				sta 	zLTemp1+3
.019107	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x				; the number of shifts.
.01910a	38		sec				sec
.01910b	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.01910d	f0 12		beq $019121			beq 	_FPGP_NoShift 				; ... if any
.01910f	c9 20		cmp #$20			cmp 	#32
.019111	90 02		bcc $019115			bcc 	_FPGP_NotMax
.019113	a9 20		lda #$20			lda 	#32 						; max of 32.
.019115					_FPGP_NotMax:
.019115	a8		tay				tay 								; Y is the mask shift count.
.019116					_FPGP_ShiftMask:
.019116	46 1d		lsr $1d				lsr 	3+zLTemp1
.019118	66 1c		ror $1c				ror 	2+zLTemp1
.01911a	66 1b		ror $1b				ror 	1+zLTemp1
.01911c	66 1a		ror $1a				ror 	0+zLTemp1
.01911e	88		dey				dey
.01911f	d0 f5		bne $019116			bne 	_FPGP_ShiftMask
.019121					_FPGP_NoShift:
.019121	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.019123	8e 23 04	stx $0423			stx 	ExpTemp						; save X
.019126					_FPGP_MaskLoop:
.019126	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.019129	28		plp				plp 								; if CC we keep the top part, so we
.01912a	08		php				php		 							; flip the mask.
.01912b	b0 02		bcs $01912f			bcs		_FPGP_NoFlip
.01912d	49 ff		eor #$ff			eor 	#$FF
.01912f					_FPGP_NoFlip:
.01912f	3d 08 03	and $0308,x			and 	XS_Mantissa,x 				; and into the mantissa.
.019132	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.019135	e8		inx				inx
.019136	c8		iny				iny
.019137	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.019139	d0 eb		bne $019126			bne 	_FPGP_MaskLoop
.01913b	ae 23 04	ldx $0423			ldx 	ExpTemp						; restore X
.01913e	28		plp				plp
.01913f	08		php				php 								; get action flag on the stack
.019140	90 05		bcc $019147			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.019142	a9 00		lda #$00			lda 	#0
.019144	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019147					_FPGP_NotFractional:
.019147	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 						; check if \1 zero
.01914a	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.01914d	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.019150	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.019153	f0 05		beq $01915a			beq 	_FPGP_Zero 					; if zero, return zero
.019155	20 2c 92	jsr $01922c			jsr 	FPUNormalise
.019158	80 05		bra $01915f			bra 	_FPGP_Exit 					; and exit
.01915a					_FPGP_Zero:
.01915a	a9 40		lda #$40			lda 	#$40 						; set zero flag
.01915c	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.01915f					_FPGP_Exit:
.01915f	68		pla				pla 								; throw saved action flag.
.019160	7a		ply				ply
.019161	68		pla				pla
.019162	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.019163					FPCompare:
.019163	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.019166	48		pha				pha
.019167	bd 12 03	lda $0312,x			lda 	XS2_Exponent,x
.01916a	48		pha				pha
.01916b	20 df 8e	jsr $018edf			jsr 	FPSubtract 					; calculate X1-X2
.01916e	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.019171	70 2c		bvs $01919f			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.019173	68		pla				pla
.019174	8d 23 04	sta $0423			sta 	ExpTemp						; save first exponent in temporary reg.
.019177	68		pla				pla
.019178	38		sec				sec
.019179	ed 23 04	sbc $0423			sbc 	ExpTemp 					; calculate AX-BX
.01917c	70 15		bvs $019193			bvs 	_FPCNotEqual				; overflow, can't be equal.
.01917e	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.01917f	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.019181	b0 10		bcs $019193			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.019183	38		sec				sec
.019184	ad 23 04	lda $0423			lda 	ExpTemp 					; get one of the exponents back.
.019187	e9 18		sbc #$18			sbc 	#24 						; allow for 2^24 error, relatively.
.019189	b0 02		bcs $01918d			bcs 	_FPCNotRange 				; keep in range.
.01918b	a9 01		lda #$01			lda 	#1
.01918d					_FPCNotRange:
.01918d	38		sec				sec
.01918e	fd 0c 03	sbc $030c,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.019191	b0 0e		bcs $0191a1			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.019193					_FPCNotEqual:
.019193	bd 0d 03	lda $030d,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.019196	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.019198	f0 02		beq $01919c			beq 	_FPCNE2
.01919a	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.01919c	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.01919d	80 04		bra $0191a3			bra 	_FPCExit
.01919f					_FPCPullZero:
.01919f	68		pla				pla 								; throw saved exponents
.0191a0	68		pla				pla
.0191a1					_FPCZero:
.0191a1	a9 00		lda #$00			lda 	#0 							; and return zero
.0191a3					_FPCExit:
.0191a3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.0191a4					FPUCopyX2ToX1:
.0191a4	48		pha				pha
.0191a5	da		phx				phx
.0191a6	5a		phy				phy
.0191a7	a0 08		ldy #$08			ldy 	#8
.0191a9	bd 0e 03	lda $030e,x	_FPUC21:lda 	XS2_Mantissa,x
.0191ac	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.0191af	e8		inx				inx
.0191b0	88		dey				dey
.0191b1	10 f6		bpl $0191a9			bpl 	_FPUC21
.0191b3	7a		ply				ply
.0191b4	fa		plx				plx
.0191b5	68		pla				pla
.0191b6	60		rts				rts
.0191b7					FPUSetInteger:
.0191b7	48		pha				pha
.0191b8	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.0191bb	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.0191bd	10 02		bpl $0191c1			bpl 	_FPUSIExtend
.0191bf	a9 ff		lda #$ff			lda 	#$FF
.0191c1					_FPUSIExtend:
.0191c1	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.0191c4	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0191c7	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0191ca	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.0191cc	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0191cf	68		pla				pla
.0191d0	60		rts				rts
.0191d1					FPUNegateInteger:
.0191d1	48		pha				pha
.0191d2	38		sec				sec
.0191d3	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.0191d5	fd 08 03	sbc $0308,x			sbc 	XS_Mantissa+0,x
.0191d8	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0191db	a9 00		lda #$00			lda 	#0
.0191dd	fd 09 03	sbc $0309,x			sbc 	XS_Mantissa+1,x
.0191e0	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0191e3	a9 00		lda #$00			lda 	#0
.0191e5	fd 0a 03	sbc $030a,x			sbc 	XS_Mantissa+2,x
.0191e8	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0191eb	a9 00		lda #$00			lda 	#0
.0191ed	fd 0b 03	sbc $030b,x			sbc 	XS_Mantissa+3,x
.0191f0	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0191f3	68		pla				pla
.0191f4	60		rts				rts
.0191f5					FPUToFloat:
.0191f5	48		pha				pha
.0191f6	bd 0d 03	lda $030d,x			lda 	XS_Type,x					; exit if already float.
.0191f9	29 0f		and #$0f			and 	#$0F
.0191fb	f0 2d		beq $01922a			beq 	_FPUFExit
.0191fd	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.0191ff	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019202	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.019204	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x 				; x mantissa.
.019207	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.01920a	10 08		bpl $019214			bpl		_FPUFPositive
.01920c	20 d1 91	jsr $0191d1			jsr 	FPUNegateInteger 			; negate the mantissa
.01920f	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.019211	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019214					_FPUFPositive:
.019214	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.019217	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.01921a	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.01921d	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.019220	d0 05		bne $019227			bne 	_FPUFNonZero
.019222	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.019224	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019227					_FPUFNonZero:
.019227	20 2c 92	jsr $01922c			jsr 	FPUNormalise 				; normalise the floating point.
.01922a					_FPUFExit:
.01922a	68		pla				pla
.01922b	60		rts				rts
.01922c					FPUNormalise:
.01922c	48		pha				pha
.01922d	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.019230	70 20		bvs $019252			bvs 	_FPUNExit
.019232	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.019235	f0 16		beq $01924d			beq 	_FPUNSetZero
.019237					_FPUNLoop:
.019237	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.01923a	30 16		bmi $019252			bmi 	_FPUNExit 					; if so, we are normalised.
.01923c	1e 08 03	asl $0308,x			asl 	0+XS_Mantissa+0,x
.01923f	3e 09 03	rol $0309,x			rol 	1+XS_Mantissa+0,x
.019242	3e 0a 03	rol $030a,x			rol 	2+XS_Mantissa+0,x
.019245	3e 0b 03	rol $030b,x			rol 	3+XS_Mantissa+0,x
.019248	de 0c 03	dec $030c,x			dec 	XS_Exponent,x 				; decrement exponent
.01924b	d0 ea		bne $019237			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.01924d					_FPUNSetZero:
.01924d	a9 40		lda #$40			lda 	#$40
.01924f	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; the result is now zero.
.019252					_FPUNExit:
.019252	68		pla				pla
.019253	60		rts				rts
.019254					FPUToInteger:
.019254	48		pha				pha
.019255	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; if already integer, exit
.019258	29 01		and #$01			and 	#1
.01925a	d0 3e		bne $01929a			bne 	_FPUTOI_Exit
.01925c	3c 0d 03	bit $030d,x			bit 	XS_Type,x					; if zero, return zero.
.01925f	70 2b		bvs $01928c			bvs 	_FPUTOI_Zero
.019261	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.019264	10 26		bpl $01928c			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.019266	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.019268	b0 37		bcs $0192a1			bcs 	FP_Overflow
.01926a					_FPUToIToInteger:
.01926a	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.01926d	c9 a0		cmp #$a0			cmp 	#128+32
.01926f	f0 11		beq $019282			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.019271	fe 0c 03	inc $030c,x			inc 	XS_Exponent,X 				; increment Exponent
.019274	5e 0b 03	lsr $030b,x			lsr 	3+XS_Mantissa,x
.019277	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.01927a	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.01927d	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.019280	80 e8		bra $01926a			bra 	_FPUToIToInteger 			; keep going.
.019282					_FPUToICheckSign:
.019282	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; check sign
.019285	10 13		bpl $01929a			bpl 	_FPUToI_Exit 				; exit if unsigned.
.019287	20 d1 91	jsr $0191d1			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.01928a	80 0e		bra $01929a			bra 	_FPUTOI_Exit
.01928c					_FPUTOI_Zero:
.01928c	a9 00		lda #$00			lda 	#0 							; return zero integer.
.01928e	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019291	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019294	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019297	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.01929a					_FPUToI_Exit:
.01929a	a9 01		lda #$01			lda 	#1 							; set type to integer
.01929c	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.01929f	68		pla				pla
.0192a0	60		rts				rts
.0192a1					FP_Overflow:
.0192a1	80 fe		bra $0192a1		_error: bra _error
.0192a3					FPUTimes10:
.0192a3	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.0192a6	85 1a		sta $1a				sta 	ZLTemp1+0
.0192a8	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0192ab	85 1b		sta $1b				sta 	ZLTemp1+1
.0192ad	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.0192b0	85 1c		sta $1c				sta 	ZLTemp1+2
.0192b2	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.0192b5	85 1d		sta $1d				sta 	ZLTemp1+3
.0192b7	20 fb 92	jsr $0192fb			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.0192ba	20 fb 92	jsr $0192fb			jsr 	_FPUT_LSR_ZLTemp1
.0192bd	18		clc				clc
.0192be	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.0192c1	65 1a		adc $1a				adc 	ZLTemp1+0
.0192c3	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0192c6	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0192c9	65 1b		adc $1b				adc 	ZLTemp1+1
.0192cb	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0192ce	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.0192d1	65 1c		adc $1c				adc 	ZLTemp1+2
.0192d3	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0192d6	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.0192d9	65 1d		adc $1d				adc 	ZLTemp1+3
.0192db	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0192de	90 0f		bcc $0192ef			bcc 	_FPUTimes10
.0192e0	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.0192e3	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.0192e6	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.0192e9	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.0192ec	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x				; fix exponent
.0192ef					_FPUTimes10:
.0192ef	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.0192f2	18		clc				clc
.0192f3	69 03		adc #$03			adc 	#3
.0192f5	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.0192f8	b0 a7		bcs $0192a1			bcs 	FP_Overflow 				; error
.0192fa	60		rts				rts
.0192fb					_FPUT_LSR_ZLTemp1:
.0192fb	46 1d		lsr $1d				lsr 	ZLTemp1+3
.0192fd	66 1c		ror $1c				ror 	ZLTemp1+2
.0192ff	66 1b		ror $1b				ror 	ZLTemp1+1
.019301	66 1a		ror $1a				ror 	ZLTemp1+0
.019303	60		rts				rts
.019304					FPUScale10A:
.019304	5a		phy				phy
.019305	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.019307	f0 3d		beq $019346			beq 	_FPUScaleExit
.019309	da		phx				phx 								; save X
.01930a	e8		inx				inx
.01930b	e8		inx				inx
.01930c	e8		inx				inx
.01930d	e8		inx				inx
.01930e	e8		inx				inx
.01930f	e8		inx				inx
.019310	a8		tay				tay 								; save power scalar in Y.
.019311	a9 00		lda #$00			lda 	#0
.019313	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.019316	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019319	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01931c	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.01931f	a9 80		lda #$80			lda 	#$80
.019321	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019324	a9 81		lda #$81			lda 	#$81
.019326	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.019329	5a		phy				phy 								; save 10^n on stack.
.01932a	c0 00		cpy #$00			cpy 	#0
.01932c	10 05		bpl $019333			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.01932e	98		tya				tya
.01932f	49 ff		eor #$ff			eor 	#$FF
.019331	1a		inc a				inc 	a
.019332	a8		tay				tay
.019333					_FPUSAbs:
.019333	20 a3 92	jsr $0192a3			jsr 	FPUTimes10
.019336	88		dey				dey
.019337	d0 fa		bne $019333			bne 	_FPUSAbs 					; tos is now 10^|AC|
.019339	68		pla				pla 								; restore count in A
.01933a	fa		plx				plx 								; restore X pointing to number to scale.
.01933b	0a		asl a				asl 	a
.01933c	b0 05		bcs $019343			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.01933e	20 43 90	jsr $019043			jsr 	FPMultiply 					; if clear multiply.
.019341	80 03		bra $019346			bra		_FPUScaleExit
.019343					_FPUSDivide:
.019343	20 bb 8f	jsr $018fbb			jsr 	FPDivide
.019346					_FPUScaleExit:
.019346	7a		ply				ply
.019347	60		rts				rts
.019348					FPUCopyToNext:
.019348	a0 06		ldy #$06			ldy 		#6
.01934a	da		phx				phx
.01934b					_FPUCopy1:
.01934b	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x
.01934e	9d 0e 03	sta $030e,x			sta 	XS2_Mantissa,x
.019351	e8		inx				inx
.019352	88		dey				dey
.019353	d0 f6		bne $01934b			bne 	_FPUCopy1
.019355	fa		plx				plx
.019356	60		rts				rts
.019357					FPUCopyFromNext:
.019357	a0 06		ldy #$06			ldy 		#6
.019359	da		phx				phx
.01935a					_FPUCopy1:
.01935a	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa,x
.01935d	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.019360	e8		inx				inx
.019361	88		dey				dey
.019362	d0 f6		bne $01935a			bne 	_FPUCopy1
.019364	fa		plx				plx
.019365	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.019366					FPToString:
.019366	48		pha				pha
.019367	5a		phy				phy
.019368	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; check zero flag
.01936b	50 0a		bvc $019377			bvc 		_FPTSIsFloat 			; if zero,
.01936d					_FPTSZero:
.01936d	a9 30		lda #$30			lda 		#"0"
.01936f	20 21 8e	jsr $018e21			jsr 		ITSOutputCharacter
.019372					_FPTSExit:
.019372	7a		ply				ply
.019373	68		pla				pla
.019374	60		rts				rts
.019375	80 fb		bra $019372			bra 		_FPTSExit
.019377					_FPTSIsFloat:
.019377	bd 0d 03	lda $030d,x			lda 		XS_Type,x 				; is it signed ?
.01937a	10 0a		bpl $019386			bpl 		_FPTSNotSigned
.01937c	a9 00		lda #$00			lda 		#0 						; clear sign flag
.01937e	9d 0d 03	sta $030d,x			sta 		XS_Type,x
.019381	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.019383	20 21 8e	jsr $018e21			jsr 		ITSOutputCharacter
.019386					_FPTSNotSigned:
.019386	bd 0c 03	lda $030c,x			lda 		XS_Exponent,x
.019389	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.01938b	b0 09		bcs $019396			bcs 		_FPTSExponent
.01938d	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.01938f	90 05		bcc $019396			bcc 		_FPTSExponent 			;
.019391					_FPTSStandard:
.019391	20 da 93	jsr $0193da			jsr 		FPTOutputBody 			; output the body.
.019394	80 dc		bra $019372			bra 		_FPTSExit
.019396					_FPTSExponent:
.019396	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.019398	8d 24 04	sta $0424			sta 		ExpCount
.01939b					_FPTSExponentLoop:
.01939b	bd 0c 03	lda $030c,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.01939e	10 0e		bpl $0193ae			bpl 		_FPTSTimes
.0193a0	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.0193a2	90 14		bcc $0193b8			bcc 		_FPTSScaledToExp
.0193a4	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.0193a6	20 04 93	jsr $019304			jsr 		FPUScale10A
.0193a9	ee 24 04	inc $0424			inc 		ExpCount
.0193ac	80 ed		bra $01939b			bra 		_FPTSExponentLoop
.0193ae					_FPTSTimes:
.0193ae	a9 01		lda #$01			lda 		#1
.0193b0	20 04 93	jsr $019304			jsr 		FPUScale10A
.0193b3	ce 24 04	dec $0424			dec 		ExpCount
.0193b6	80 e3		bra $01939b			bra 		_FPTSExponentLoop
.0193b8					_FPTSScaledToExp:
.0193b8	20 da 93	jsr $0193da			jsr 		FPTOutputBody 			; output the body.
.0193bb	a9 65		lda #$65			lda 		#"e"					; output E
.0193bd	20 21 8e	jsr $018e21			jsr 		ITSOutputCharacter
.0193c0	ad 24 04	lda $0424			lda 		ExpCount 				; get the exponent
.0193c3	9d 08 03	sta $0308,x			sta 		XS_Mantissa,x
.0193c6	29 80		and #$80			and 		#$80 					; sign extend it
.0193c8	f0 02		beq $0193cc			beq 		_FPTSSExt
.0193ca	a9 ff		lda #$ff			lda 		#$FF
.0193cc					_FPTSSExt:
.0193cc	9d 09 03	sta $0309,x			sta 		XS_Mantissa+1,x
.0193cf	9d 0a 03	sta $030a,x			sta 		XS_Mantissa+2,x
.0193d2	9d 0b 03	sta $030b,x			sta 		XS_Mantissa+3,x
.0193d5	20 7f 8d	jsr $018d7f			jsr 		INTToString 			; output the exponent.
.0193d8	80 98		bra $019372			bra			_FPTSExit 				; and exit.
.0193da					FPTOutputBody:
.0193da	20 48 93	jsr $019348			jsr 		FPUCopyToNext 			; copy to next slot.
.0193dd	20 54 92	jsr $019254			jsr 		FPUToInteger 			; convert to an integer
.0193e0	20 7f 8d	jsr $018d7f			jsr 		INTToString 			; output the main integer part.
.0193e3	20 57 93	jsr $019357			jsr 		FPUCopyFromNext 		; get the fractional part back.
.0193e6	20 e0 90	jsr $0190e0			jsr 		FPFractionalPart 		; get the decimal part.
.0193e9	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; any fractional part.
.0193ec	70 3e		bvs $01942c			bvs 		_FPTOExit 				; if not, exit now.
.0193ee	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.0193f0	20 21 8e	jsr $018e21			jsr 		ITSOutputCharacter
.0193f3					_FPOutLoop:
.0193f3	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; finally reached zero.
.0193f6	70 1e		bvs $019416			bvs 		_FPStripZeros 			; strip trailing zeros
.0193f8	20 a3 92	jsr $0192a3			jsr 		FPUTimes10 				; multiply by 10
.0193fb	20 48 93	jsr $019348			jsr 		FPUCopyToNext			; copy to next slot.
.0193fe	20 54 92	jsr $019254			jsr 		FPUToInteger 			; convert to integer
.019401	bd 08 03	lda $0308,x			lda 		XS_Mantissa+0,x 		; print digit.
.019404	09 30		ora #$30			ora 		#"0"
.019406	20 21 8e	jsr $018e21			jsr 		ITSOutputCharacter
.019409	20 57 93	jsr $019357			jsr 		FPUCopyFromNext 		; get it back
.01940c	20 e0 90	jsr $0190e0			jsr 		FPFractionalPart 		; get fractional part
.01940f	ad 20 04	lda $0420			lda 		NumBufX 				; done 11 characters yet ?
.019412	c9 0b		cmp #$0b			cmp 	 	#11
.019414	90 dd		bcc $0193f3			bcc 		_FPOutLoop 				; if so, keep going till zero.
.019416					_FPStripZeros:
.019416	ac 20 04	ldy $0420			ldy 		NumBufX 				; strip trailing zeros.
.019419					_FPStripLoop:
.019419	88		dey				dey 								; back one, if at start then no strip
.01941a	f0 10		beq $01942c			beq 		_FPToExit
.01941c	b9 00 04	lda $0400,y			lda 		Num_Buffer,y 			; keep going if "0"
.01941f	c9 30		cmp #$30			cmp 		#"0"
.019421	f0 f6		beq $019419			beq 		_FPStripLoop
.019423	c8		iny				iny
.019424	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.019426	99 00 04	sta $0400,y			sta 		Num_Buffer,y
.019429	8c 20 04	sty $0420			sty 		NumBufX 				; update position.
.01942c					_FPTOExit:
.01942c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.01942d					FPFromString:
.01942d	48		pha				pha 								; push A
.01942e	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.019430	c9 2e		cmp #$2e			cmp 	#"."
.019432	f0 03		beq $019437			beq	 	_FPFIsDecimal
.019434	4c 9a 94	jmp $01949a			jmp 	_FPFNotDecimal
.019437					_FPFIsDecimal:
.019437	c8		iny				iny 								; consume the decimal.
.019438	20 f5 91	jsr $0191f5			jsr 	FPUToFloat 					; convert the integer to float.
.01943b	da		phx				phx 								; save X.
.01943c	5a		phy				phy 								; save decimal start position
.01943d	e8		inx				inx
.01943e	e8		inx				inx
.01943f	e8		inx				inx
.019440	e8		inx				inx
.019441	e8		inx				inx
.019442	e8		inx				inx
.019443	20 39 8e	jsr $018e39			jsr 	INTFromStringY 				; get the part after the DP.
.019446	20 f5 91	jsr $0191f5			jsr 	FPUToFloat 					; convert that to a float.
.019449	68		pla				pla 								; calculate - chars consumed.
.01944a	8c 23 04	sty $0423			sty 	ExpTemp
.01944d	38		sec				sec
.01944e	ed 23 04	sbc $0423			sbc 	ExpTemp 					; this is the shift amount
.019451	20 04 93	jsr $019304			jsr 	FPUScale10A 				; scale it by 10^AC
.019454	fa		plx				plx 								; restore original X
.019455	20 e9 8e	jsr $018ee9			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.019458	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.01945a	c9 45		cmp #$45			cmp 	#"E"
.01945c	f0 04		beq $019462			beq 	_FPFExponent
.01945e	c9 65		cmp #$65			cmp 	#"e"
.019460	d0 38		bne $01949a			bne 	_FPFNotDecimal 				; no, then exit normally.
.019462					_FPFExponent:
.019462	c8		iny				iny 								; skip over E symbol.
.019463	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.019465	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.019467	d0 01		bne $01946a			bne 	_FPFGotSign
.019469	c8		iny				iny 								; if it was - skip over it.
.01946a					_FPFGotSign:
.01946a	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.01946b	da		phx				phx
.01946c	e8		inx				inx
.01946d	e8		inx				inx
.01946e	e8		inx				inx
.01946f	e8		inx				inx
.019470	e8		inx				inx
.019471	e8		inx				inx
.019472	20 39 8e	jsr $018e39			jsr 	INTFromStringY 				; get the exponent
.019475	fa		plx				plx 								; restore X.
.019476	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.019479	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.01947c	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.01947f	d0 1b		bne $01949c			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.019481	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.019484	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.019486	b0 14		bcs $01949c			bcs 	_FPFXOverflow
.019488	68		pla				pla 								; get direction
.019489	d0 09		bne $019494			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.01948b	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.01948e	49 ff		eor #$ff			eor 	#$FF
.019490	1a		inc a				inc 	a
.019491	9d 0e 03	sta $030e,x			sta 	XS2_Mantissa+0,x
.019494					_FPFXScale:
.019494	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.019497	20 04 93	jsr $019304			jsr 	FPUScale10A 				; scale by the exponent.
.01949a					_FPFNotDecimal:
.01949a	68		pla				pla
.01949b	60		rts				rts
.01949c					_FPFXOverflow:
.01949c	20 17 84	jsr $018417			jsr 	ERR_Handler
>01949f	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>0194a7	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.0194ae					Unary_Rnd:
.0194ae	20 bb 85	jsr $0185bb			jsr 	EvaluateNumberX 			; get value
.0194b1	20 0f 8c	jsr $018c0f			jsr 	CheckNextRParen 			; check right bracket.
.0194b4	20 95 88	jsr $018895			jsr 	GetSignCurrent 				; get sign -1,0,1.
.0194b7	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.0194b9	30 10		bmi $0194cb			bmi 	_URSetSeed
.0194bb	f0 2c		beq $0194e9			beq 	_URMakeRandom 				; if zero return same number.
.0194bd	da		phx				phx
.0194be	a2 00		ldx #$00			ldx 	#0
.0194c0	20 26 95	jsr $019526			jsr 	Random16
.0194c3	a2 02		ldx #$02			ldx 	#2
.0194c5	20 26 95	jsr $019526			jsr 	Random16
.0194c8	fa		plx				plx
.0194c9	80 1e		bra $0194e9			bra 	_URMakeRandom
.0194cb					_URSetSeed:
.0194cb	20 f5 91	jsr $0191f5			jsr 	FPUToFloat 					; make it a float to twiddle it.
.0194ce	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.0194d1	8d 2b 04	sta $042b			sta 	RandomSeed+0
.0194d4	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.0194d7	8d 2c 04	sta $042c			sta 	RandomSeed+1
.0194da	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.0194dd	8d 2d 04	sta $042d			sta 	RandomSeed+2
.0194e0	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.0194e3	0a		asl a				asl 	a
.0194e4	49 db		eor #$db			eor 	#$DB
.0194e6	8d 2e 04	sta $042e			sta 	RandomSeed+3
.0194e9					_URMakeRandom:
.0194e9	ad 2b 04	lda $042b			lda 	RandomSeed+0 				; check if seed is zero.
.0194ec	0d 2c 04	ora $042c			ora 	RandomSeed+1
.0194ef	0d 2d 04	ora $042d			ora 	RandomSeed+2
.0194f2	0d 2e 04	ora $042e			ora 	RandomSeed+3
.0194f5	d0 0a		bne $019501			bne 	_URNotZero
.0194f7	a9 47		lda #$47			lda 	#$47
.0194f9	8d 2c 04	sta $042c			sta 	RandomSeed+1				; if it is, make it non zero.
.0194fc	a9 3d		lda #$3d			lda 	#$3D
.0194fe	8d 2e 04	sta $042e			sta 	RandomSeed+3
.019501					_URNotZero:
.019501	ad 2b 04	lda $042b			lda 	RandomSeed+0 				; copy seed into mantissa.
.019504	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019507	ad 2c 04	lda $042c			lda 	RandomSeed+1
.01950a	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.01950d	ad 2d 04	lda $042d			lda 	RandomSeed+2
.019510	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019513	ad 2e 04	lda $042e			lda 	RandomSeed+3
.019516	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019519	a9 00		lda #$00			lda 	#$00 						; set type to float.
.01951b	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.01951e	a9 80		lda #$80			lda 	#$80
.019520	9d 0c 03	sta $030c,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.019523	4c 2c 92	jmp $01922c			jmp 	FPUNormalise
.019526					Random16:
.019526	5e 2c 04	lsr $042c,x			lsr 	RandomSeed+1,x				; shift seed right
.019529	7e 2b 04	ror $042b,x			ror 	RandomSeed,x
.01952c	90 08		bcc $019536			bcc 	_R16_NoXor
.01952e	bd 2c 04	lda $042c,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.019531	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.019533	9d 2c 04	sta $042c,x			sta 	RandomSeed+1,x
.019536					_R16_NoXor:
.019536	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.019537					Unary_Int:
.019537	20 bb 85	jsr $0185bb			jsr 	EvaluateNumberX 			; get value
.01953a	20 0f 8c	jsr $018c0f			jsr 	CheckNextRParen 			; check right bracket.
.01953d	4c 54 92	jmp $019254			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.019540					TIM_Error:
.019540	20 1b 82	jsr $01821b			jsr 	IFT_UpLine 					; go up one line.
.019543	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.019545	80 02		bra $019549			bra 	TIM_ShowPrompt
.019547					TIM_NewCommand:
.019547	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.019549					TIM_ShowPrompt:
.019549	20 27 82	jsr $018227			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.01954c	20 df 82	jsr $0182df			jsr 	IFT_ReadLine	 			; get character, go to next line
.01954f	20 41 82	jsr $018241			jsr 	IFT_NewLine					; go to next line.
.019552	86 10		stx $10				stx 	zTemp1 						; save line read address
.019554	84 11		sty $11				sty 	zTemp1+1
.019556	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.019558	b1 10		lda ($10),y			lda 	(zTemp1),y
.01955a	c9 3f		cmp #$3f			cmp 	#"?"
.01955c	f0 04		beq $019562			beq 	TIM_SkipFirst
.01955e	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.019560	d0 01		bne $019563			bne 	TIM_NotDot
.019562					TIM_SkipFirst:
.019562	c8		iny				iny
.019563					TIM_NotDot:
.019563	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.019565	c9 52		cmp #$52			cmp 	#"R"						; show registers
.019567	f0 6b		beq $0195d4			beq 	TIM_ShowRegisters
.019569	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.01956b	f0 12		beq $01957f			beq 	TIM_ShowMemory
.01956d	c9 47		cmp #$47			cmp 	#"G"						; execute
.01956f	f0 49		beq $0195ba			beq 	TIM_Execute
.019571	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.019573	f0 07		beq $01957c			beq 	TIM_GoLoadMemory
.019575	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.019577	d0 c7		bne $019540			bne 	TIM_Error
.019579	4c f8 96	jmp $0196f8			jmp 	TIM_UpdateRegisters
.01957c					TIM_GoLoadMemory:
.01957c	4c 28 97	jmp $019728			jmp 	TIM_LoadMemory
.01957f					TIM_ShowMemory:
.01957f	20 74 96	jsr $019674			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.019582	b0 bc		bcs $019540			bcs 	TIM_Error
.019584	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.019586	85 12		sta $12				sta 	zTemp2
.019588	a5 15		lda $15				lda 	zTemp3+1
.01958a	85 13		sta $13				sta 	zTemp2+1
.01958c	20 74 96	jsr $019674			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.01958f	90 08		bcc $019599			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.019591	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.019593	85 14		sta $14				sta 	zTemp3
.019595	a5 13		lda $13				lda 	zTemp2+1
.019597	85 15		sta $15				sta 	zTemp3+1
.019599					_TIMSM_Start:
.019599	20 4c 96	jsr $01964c			jsr 	TIM_WriteLine 				; write one line of hex out
.01959c	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.01959e	18		clc				clc
.01959f	69 10		adc #$10			adc 	#16
.0195a1	85 12		sta $12				sta 	zTemp2
.0195a3	90 02		bcc $0195a7			bcc 	_TIMSM_NoCarry
.0195a5	e6 13		inc $13				inc 	zTemp2+1
.0195a7					_TIMSM_NoCarry:
.0195a7	20 c6 83	jsr $0183c6			jsr 	IF_CheckBreak 				; check CTL+C
.0195aa	d0 0b		bne $0195b7			bne 	_TIMSM_Ends 				; if pressed break out.
.0195ac	38		sec				sec 								; check past the end address in zTemp3
.0195ad	a5 14		lda $14				lda 	zTemp3
.0195af	e5 12		sbc $12				sbc 	zTemp2
.0195b1	a5 15		lda $15				lda 	zTemp3+1
.0195b3	e5 13		sbc $13				sbc 	zTemp2+1
.0195b5	10 e2		bpl $019599			bpl 	_TIMSM_Start
.0195b7					_TIMSM_Ends:
.0195b7	4c 47 95	jmp $019547			jmp 	TIM_NewCommand
.0195ba					TIM_Execute:
.0195ba	20 74 96	jsr $019674			jsr 	TIM_GetHex 					; get the execute address
.0195bd	b0 81		bcs $019540			bcs 	TIM_Error 					; not legitimate
.0195bf	ae 38 04	ldx $0438			ldx 	TIM_SP 						; set up SP
.0195c2	9a		txs				txs
.0195c3	ad 33 04	lda $0433			lda 	TIM_SR 						; Status for PLP
.0195c6	48		pha				pha
.0195c7	ad 34 04	lda $0434			lda 	TIM_A 						; restore AXYZ
.0195ca	ae 35 04	ldx $0435			ldx 	TIM_X
.0195cd	ac 36 04	ldy $0436			ldy 	TIM_Y
.0195d0	28		plp				plp 								; and PS Byte.
.0195d1	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.0195d4					TIM_Start:
.0195d4					TIM_ShowRegisters:
.0195d4	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.0195d7	8d 32 04	sta $0432			sta 	TIM_IRQ+1
.0195da	ad ff ff	lda $ffff			lda 	$FFFF
.0195dd	8d 31 04	sta $0431			sta 	TIM_IRQ
.0195e0	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.0195e2					_TIMSR_Text:
.0195e2	bf 13 96 01	lda $019613,x			lda 	_TIMSR_Label,x
.0195e6	20 27 82	jsr $018227			jsr 	IFT_PrintCharacter
.0195e9	e8		inx				inx
.0195ea	e0 20		cpx #$20			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.0195ec	d0 f4		bne $0195e2			bne 	_TIMSR_Text
.0195ee	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.0195f0					_TIMSR_Skip:
.0195f0	e8		inx				inx
.0195f1					_TIMSR_LoopSpace:
.0195f1	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.0195f3	b0 04		bcs $0195f9			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.0195f5	8a		txa				txa
.0195f6	4a		lsr a				lsr 	a
.0195f7	b0 05		bcs $0195fe			bcs 	_TIMSR_NoSpace
.0195f9					_TIMSR_Space:
.0195f9	a9 20		lda #$20			lda 	#" "
.0195fb	20 27 82	jsr $018227			jsr 	IFT_PrintCharacter
.0195fe					_TIMSR_NoSpace:
.0195fe	bd 2f 04	lda $042f,x			lda 	TIM_PC,x 					; output hex value.
.019601	20 33 96	jsr $019633			jsr 	TIM_WriteHex
.019604	e8		inx				inx
.019605	e0 08		cpx #$08			cpx 	#TIM_Z-TIM_PC
.019607	f0 e7		beq $0195f0			beq 	_TIMSR_Skip
.019609	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.01960b	d0 e4		bne $0195f1			bne 	_TimSR_LoopSpace
.01960d	20 41 82	jsr $018241			jsr 	IFT_NewLine 				; new line
.019610	4c 47 95	jmp $019547			jmp	 	TIM_NewCommand 				; new command.
.019613					_TIMSR_Label:
>019613	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>01961b	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>01962b	52
>01962c	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.019633					_TIMSR_LabelEnd:
.019633					TIM_WriteHex:
.019633	48		pha				pha 								; save A
.019634	4a		lsr a				lsr 	a 							; shift MSB->LSB
.019635	4a		lsr a				lsr 	a
.019636	4a		lsr a				lsr 	a
.019637	4a		lsr a				lsr 	a
.019638	20 3c 96	jsr $01963c			jsr 	_TIMWH_Nibble 				; print MSB
.01963b	68		pla				pla 								; restore and print LSB
.01963c					_TIMWH_Nibble:
.01963c	48		pha				pha
.01963d	29 0f		and #$0f			and 	#15 						; mask out
.01963f	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.019641	90 02		bcc $019645			bcc 	_TIMWHNoLetter
.019643	69 06		adc #$06			adc 	#6
.019645					_TIMWHNoLetter:
.019645	69 30		adc #$30			adc 	#48
.019647	20 27 82	jsr $018227			jsr 	IFT_PrintCharacter 			; print it out.
.01964a	68		pla				pla
.01964b	60		rts				rts
.01964c					TIM_WriteLine:
.01964c	a9 2e		lda #$2e			lda 	#"." 						; prompt
.01964e	20 27 82	jsr $018227			jsr 	IFT_PrintCharacter
.019651	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.019653	20 27 82	jsr $018227			jsr 	IFT_PrintCharacter
.019656	a5 13		lda $13				lda 	zTemp2+1 					; write address
.019658	20 33 96	jsr $019633			jsr 	TIM_WriteHex
.01965b	a5 12		lda $12				lda 	zTemp2
.01965d	20 33 96	jsr $019633			jsr 	TIM_WriteHex
.019660	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.019662					_TIMWL_Loop:
.019662	a9 20		lda #$20			lda 	#" "
.019664	20 27 82	jsr $018227			jsr 	IFT_PrintCharacter
.019667	b1 12		lda ($12),y			lda 	(zTemp2),y
.019669	20 33 96	jsr $019633			jsr 	TIM_WriteHex
.01966c	c8		iny				iny
.01966d	c0 10		cpy #$10			cpy 	#16
.01966f	d0 f1		bne $019662			bne 	_TIMWL_Loop
.019671	4c 41 82	jmp $018241			jmp 	IFT_NewLine 				; new line and exit
.019674					TIM_GetHex:
.019674	c8		iny				iny
.019675	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.019677	c9 20		cmp #$20			cmp 	#32
.019679	f0 f9		beq $019674			beq 	TIM_GetHex
.01967b	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.01967d	f0 f5		beq $019674			beq 	TIM_GetHex
.01967f	20 a8 96	jsr $0196a8			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.019682	b0 23		bcs $0196a7			bcs 	_TIMGH_Exit					; if first bad then exit now.
.019684	a9 00		lda #$00			lda 	#0 							; zero result
.019686	85 14		sta $14				sta 	zTemp3
.019688	85 15		sta $15				sta 	zTemp3+1
.01968a					_TIM_GHLoop:
.01968a	20 a8 96	jsr $0196a8			jsr 	TIM_GetHexCharacter 		; get next character
.01968d	b0 17		bcs $0196a6			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.01968f	c8		iny				iny 								; skip over it.
.019690	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.019692	26 15		rol $15				rol 	zTemp3+1
.019694	06 14		asl $14				asl 	zTemp3 						; now x 2
.019696	26 15		rol $15				rol 	zTemp3+1
.019698	06 14		asl $14				asl 	zTemp3						; now x 4
.01969a	26 15		rol $15				rol 	zTemp3+1
.01969c	06 14		asl $14				asl 	zTemp3 						; now x 8
.01969e	26 15		rol $15				rol 	zTemp3+1
.0196a0	05 14		ora $14				ora 	zTemp3 						; OR result in
.0196a2	85 14		sta $14				sta 	zTemp3
.0196a4	80 e4		bra $01968a			bra 	_TIM_GHLoop 				; loop round again.
.0196a6					_TIMGH_Okay:
.0196a6	18		clc				clc
.0196a7					_TIMGH_Exit:
.0196a7	60		rts				rts
.0196a8					TIM_GetHexCharacter:
.0196a8	b1 10		lda ($10),y			lda 	(zTemp1),y
.0196aa	38		sec				sec
.0196ab	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.0196ad	90 0e		bcc $0196bd			bcc 	_TIM_GHCFail
.0196af	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.0196b1	90 0b		bcc $0196be			bcc 	_TIM_GHCExit
.0196b3	c9 11		cmp #$11			cmp 	#65-48						; < A
.0196b5	90 06		bcc $0196bd			bcc		_TIM_GHCFail
.0196b7	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.0196b9	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.0196bb	90 01		bcc $0196be			bcc		_TIM_GHCExit
.0196bd					_TIM_GHCFail:
.0196bd	38		sec				sec
.0196be					_TIM_GHCExit:
.0196be	60		rts				rts
.0196bf					TIM_BreakVector:
.0196bf	da		phx				phx									; save X/A on stack
.0196c0	48		pha				pha
.0196c1	ba		tsx				tsx 								; X points to S
.0196c2	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.0196c5	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.0196c7	d0 03		bne $0196cc			bne 	_TIMBreak					; if set, it's BRK
.0196c9	68		pla				pla 								; abandon routine.
.0196ca	fa		plx				plx
.0196cb	40		rti				rti
.0196cc					_TIMBreak:
.0196cc	68		pla				pla 								; save A X Y and maybe Z
.0196cd	8d 34 04	sta $0434			sta 	TIM_A
.0196d0	fa		plx				plx
.0196d1	8e 35 04	stx $0435			stx 	TIM_X
.0196d4	8c 36 04	sty $0436			sty 	TIM_Y
.0196d7	68		pla				pla 								; get Status Register
.0196d8	8d 33 04	sta $0433			sta 	TIM_SR
.0196db	68		pla				pla
.0196dc	8d 30 04	sta $0430			sta 	TIM_PC+1 					; save calling address
.0196df	68		pla				pla
.0196e0	8d 2f 04	sta $042f			sta 	TIM_PC 						; high byte
.0196e3	ad 30 04	lda $0430			lda 	TIM_PC+1 					; dec PC to point right.
.0196e6	d0 03		bne $0196eb			bne 	_TIMDecrement 				; brk bumps it.
.0196e8	ce 2f 04	dec $042f			dec 	TIM_PC
.0196eb					_TIMDecrement:
.0196eb	ce 30 04	dec $0430			dec 	TIM_PC+1
.0196ee	ba		tsx				tsx 								; and copy SP
.0196ef	8e 38 04	stx $0438			stx 	TIM_SP
.0196f2	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.0196f4	9a		txs				txs
.0196f5	4c d4 95	jmp $0195d4			jmp 	TIM_Start 					; and start up TIM monitor.
.0196f8					TIM_UpdateRegisters:
.0196f8	20 74 96	jsr $019674			jsr 	TIM_GetHex 					; PC
.0196fb	b0 28		bcs $019725			bcs 	_TIMURFail
.0196fd	a5 14		lda $14				lda 	zTemp3
.0196ff	8d 30 04	sta $0430			sta 	Tim_PC+1
.019702	a5 15		lda $15				lda 	zTemp3+1
.019704	8d 2f 04	sta $042f			sta 	Tim_PC
.019707	20 74 96	jsr $019674			jsr 	TIM_GetHex 					; ignore IRQ
.01970a	b0 19		bcs $019725			bcs 	_TIMURFail
.01970c	a2 00		ldx #$00			ldx 	#0
.01970e					_TIM_URLoop:
.01970e	e0 04		cpx #$04			cpx 	#Tim_Z-Tim_SR
.019710	d0 01		bne $019713			bne 	_TIM_1
.019712	e8		inx				inx
.019713					_TIM_1:
.019713	20 74 96	jsr $019674			jsr 	TIM_GetHex 					; registers
.019716	b0 0d		bcs $019725			bcs 	_TIMURFail
.019718	a5 14		lda $14				lda 	zTemp3
.01971a	9d 33 04	sta $0433,x			sta 	Tim_SR,x
.01971d	e8		inx				inx
.01971e	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.019720	d0 ec		bne $01970e			bne 	_TIM_URLoop
.019722	4c 47 95	jmp $019547			jmp 	TIM_NewCommand
.019725					_TIMURFail:
.019725	4c 40 95	jmp $019540			jmp 	TIM_Error
.019728					TIM_LoadMemory:
.019728	20 74 96	jsr $019674			jsr 	TIM_GetHex 					; target address => zTemp2
.01972b	a5 14		lda $14				lda 	zTemp3
.01972d	85 12		sta $12				sta 	zTemp2
.01972f	a5 15		lda $15				lda 	zTemp3+1
.019731	85 13		sta $13				sta 	zTemp2+1
.019733					_TIM_LMLoop:
.019733	20 74 96	jsr $019674			jsr 	TIM_GetHex 					; next byte ?
.019736	b0 0e		bcs $019746			bcs 	_TIMLMDone 					; no more
.019738	a2 00		ldx #$00			ldx 	#0							; write out.
.01973a	a5 14		lda $14				lda 	zTemp3
.01973c	81 12		sta ($12,x)			sta 	(zTemp2,x)
.01973e	e6 12		inc $12				inc 	zTemp2 						; bump address
.019740	d0 f1		bne $019733			bne 	_TIM_LMLoop
.019742	e6 13		inc $13				inc 	zTemp2+1
.019744	80 ed		bra $019733			bra 	_TIM_LMLoop
.019746					_TIMLMDone:
.019746	4c 47 95	jmp $019547			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Return to file: basic.asm

>019749	02						.byte 	2
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 c0						.word 	StartROM
>fffe	17 c0					.word TIM_BreakHandler

;******  End of listing
