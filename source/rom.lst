
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Wed Aug 21 16:45:07 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="65816"				cpu = "65816"
="em65816"				hardware = "em65816"

;******  Processing file: modules/common/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0200					IFT_XCursor:.byte ?							; current logical position on screen
>0201					IFT_YCursor:.byte ?
>0202					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0266					IFT_LineBuffer: .fill 100 					; line input buffer.
>0300					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>0304					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>0305					XS_Type 	.byte ? 						; bit 7 sign (float only)
=774					XS2_Mantissa = XS_Mantissa+6
=778					XS2_Exponent = XS_Exponent+6
=779					XS2_Type = XS_Type+6
>0400					Num_Buffer	.fill 	32 						; buffer for numeric conversions
>0420					NumBufX 	.byte 	?						; buffer index position
>0421					NumSuppress	.byte 	?						; leading zero suppression flag
>0422					NumConvCount .byte 	? 						; count for conversions.
>0423					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>0425					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>0427					Tim_SR:		.byte ? 						; Processor Status
>0428					Tim_A:		.byte ? 						; Processor Registers
>0429					Tim_X:		.byte ?
>042a					Tim_Y:		.byte ?
>042b					Tim_Z:		.byte ?
>042c					Tim_SP:		.byte ?							; Stack Pointer
>042d					ExpTemp:	.byte ?							; Working temp for exponents.
>042e					ExpCount:	.byte ? 						; Count of decimal exponents.

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/em65816.asm

.1000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testcode.src

>1000	18 0a 00 d6 40 fd 0b 30			.byte	$18,$0a,$00,$d6,$40,$fd,$0b,$30
>1008	30 35 34 33 65 2d 31 33			.byte	$30,$35,$34,$33,$65,$2d,$31,$33
>1010	bb ff 06 68 69 20 21 00			.byte	$bb,$ff,$06,$68,$69,$20,$21,$00
>1018	00					.byte	$00

;******  Return to file: modules/hardware/em65816.asm


;******  Processing file: modules/hardware/../common/header/header.src

=$92					firstKeywordMinus = $92
=$8e					firstKeywordPlus = $8e
=$97					firstUnaryFunction = $97
=$b1					lastUnaryFunction = $b1
.c000					VectorTable:
>c000	ac c0					.word NotImplemented ; $80 and
>c002	ac c0					.word NotImplemented ; $81 or
>c004	ac c0					.word NotImplemented ; $82 xor
>c006	ac c0					.word NotImplemented ; $83 =
>c008	ac c0					.word NotImplemented ; $84 <>
>c00a	ac c0					.word NotImplemented ; $85 <
>c00c	ac c0					.word NotImplemented ; $86 <=
>c00e	ac c0					.word NotImplemented ; $87 >
>c010	ac c0					.word NotImplemented ; $88 >=
>c012	ac c0					.word NotImplemented ; $89 +
>c014	ac c0					.word NotImplemented ; $8a -
>c016	ac c0					.word NotImplemented ; $8b *
>c018	ac c0					.word NotImplemented ; $8c /
>c01a	ac c0					.word NotImplemented ; $8d ^
>c01c	ac c0					.word NotImplemented ; $8e if
>c01e	ac c0					.word NotImplemented ; $8f while
>c020	ac c0					.word NotImplemented ; $90 repeat
>c022	ac c0					.word NotImplemented ; $91 for
>c024	ac c0					.word NotImplemented ; $92 then
>c026	ac c0					.word NotImplemented ; $93 endif
>c028	ac c0					.word NotImplemented ; $94 wend
>c02a	ac c0					.word NotImplemented ; $95 until
>c02c	ac c0					.word NotImplemented ; $96 next
>c02e	ac c0					.word NotImplemented ; $97 not
>c030	ac c0					.word NotImplemented ; $98 fn(
>c032	ac c0					.word NotImplemented ; $99 abs(
>c034	ac c0					.word NotImplemented ; $9a asc(
>c036	ac c0					.word NotImplemented ; $9b int(
>c038	ac c0					.word NotImplemented ; $9c peek(
>c03a	ac c0					.word NotImplemented ; $9d rnd(
>c03c	ac c0					.word NotImplemented ; $9e usr(
>c03e	ac c0					.word NotImplemented ; $9f left$(
>c040	ac c0					.word NotImplemented ; $a0 right$(
>c042	ac c0					.word NotImplemented ; $a1 mid$(
>c044	ac c0					.word NotImplemented ; $a2 spc(
>c046	ac c0					.word NotImplemented ; $a3 str$(
>c048	ac c0					.word NotImplemented ; $a4 val(
>c04a	ac c0					.word NotImplemented ; $a5 len(
>c04c	ac c0					.word NotImplemented ; $a6 hex$(
>c04e	ac c0					.word NotImplemented ; $a7 sin(
>c050	ac c0					.word NotImplemented ; $a8 cos(
>c052	ac c0					.word NotImplemented ; $a9 tan(
>c054	ac c0					.word NotImplemented ; $aa atn(
>c056	ac c0					.word NotImplemented ; $ab exp(
>c058	ac c0					.word NotImplemented ; $ac log(
>c05a	ac c0					.word NotImplemented ; $ad sqr(
>c05c	ac c0					.word NotImplemented ; $ae dec(
>c05e	ac c0					.word NotImplemented ; $af deek(
>c060	ac c0					.word NotImplemented ; $b0 leek(
>c062	ac c0					.word NotImplemented ; $b1 mod(
>c064	ac c0					.word NotImplemented ; $b2 $(
>c066	ac c0					.word NotImplemented ; $b3 $
>c068	ac c0					.word NotImplemented ; $b4 #(
>c06a	ac c0					.word NotImplemented ; $b5 #
>c06c	ac c0					.word NotImplemented ; $b6 %(
>c06e	ac c0					.word NotImplemented ; $b7 %
>c070	ac c0					.word NotImplemented ; $b8 (
>c072	ac c0					.word NotImplemented ; $b9 )
>c074	ac c0					.word NotImplemented ; $ba ,
>c076	ac c0					.word NotImplemented ; $bb :
>c078	ac c0					.word NotImplemented ; $bc ;
>c07a	ac c0					.word NotImplemented ; $bd def
>c07c	ac c0					.word NotImplemented ; $be clr
>c07e	ac c0					.word NotImplemented ; $c0 data
>c080	ac c0					.word NotImplemented ; $c1 read
>c082	ac c0					.word NotImplemented ; $c2 dim
>c084	ac c0					.word NotImplemented ; $c3 to
>c086	ac c0					.word NotImplemented ; $c4 step
>c088	ac c0					.word NotImplemented ; $c5 gosub
>c08a	ac c0					.word NotImplemented ; $c6 return
>c08c	ac c0					.word NotImplemented ; $c7 goto
>c08e	ac c0					.word NotImplemented ; $c8 input
>c090	ac c0					.word NotImplemented ; $c9 let
>c092	ac c0					.word NotImplemented ; $ca list
>c094	ac c0					.word NotImplemented ; $cb new
>c096	ac c0					.word NotImplemented ; $cc old
>c098	ac c0					.word NotImplemented ; $cd on
>c09a	ac c0					.word NotImplemented ; $ce restore
>c09c	ac c0					.word NotImplemented ; $cf poke
>c09e	ac c0					.word NotImplemented ; $d0 print
>c0a0	ac c0					.word NotImplemented ; $d1 run
>c0a2	ac c0					.word NotImplemented ; $d2 stop
>c0a4	ac c0					.word NotImplemented ; $d3 wait
>c0a6	ac c0					.word NotImplemented ; $d4 doke
>c0a8	ac c0					.word NotImplemented ; $d5 loke
>c0aa	ac c0					.word NotImplemented ; $d6 assert
.c0ac					NotImplemented:
.c0ac	80 fe		bra $c0ac		_error: bra _error
>c0ae	53 79 6e 74 61 78 20 45			.text "Syntax Error",0
>c0b6	72 72 6f 72 00
.c0bb					BinaryPrecedence:
>c0bb	00					.byte 0    ; $80 and
>c0bc	00					.byte 0    ; $81 or
>c0bd	00					.byte 0    ; $82 xor
>c0be	01					.byte 1    ; $83 =
>c0bf	01					.byte 1    ; $84 <>
>c0c0	01					.byte 1    ; $85 <
>c0c1	01					.byte 1    ; $86 <=
>c0c2	01					.byte 1    ; $87 >
>c0c3	01					.byte 1    ; $88 >=
>c0c4	02					.byte 2    ; $89 +
>c0c5	02					.byte 2    ; $8a -
>c0c6	03					.byte 3    ; $8b *
>c0c7	03					.byte 3    ; $8c /
>c0c8	04					.byte 4    ; $8d ^
.c0c9					KeywordText:
>c0c9	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>c0cc	4f d2					.byte $4f,$d2                          ; $81 or
>c0ce	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>c0d1	bd					.byte $bd                              ; $83 =
>c0d2	3c be					.byte $3c,$be                          ; $84 <>
>c0d4	bc					.byte $bc                              ; $85 <
>c0d5	3c bd					.byte $3c,$bd                          ; $86 <=
>c0d7	be					.byte $be                              ; $87 >
>c0d8	3e bd					.byte $3e,$bd                          ; $88 >=
>c0da	ab					.byte $ab                              ; $89 +
>c0db	ad					.byte $ad                              ; $8a -
>c0dc	aa					.byte $aa                              ; $8b *
>c0dd	af					.byte $af                              ; $8c /
>c0de	de					.byte $de                              ; $8d ^
>c0df	49 c6					.byte $49,$c6                          ; $8e if
>c0e1	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $8f while
>c0e6	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $90 repeat
>c0ec	46 4f d2				.byte $46,$4f,$d2                      ; $91 for
>c0ef	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $92 then
>c0f3	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $93 endif
>c0f8	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $94 wend
>c0fc	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $95 until
>c101	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $96 next
>c105	4e 4f d4				.byte $4e,$4f,$d4                      ; $97 not
>c108	46 4e a8				.byte $46,$4e,$a8                      ; $98 fn(
>c10b	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $99 abs(
>c10f	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9a asc(
>c113	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9b int(
>c117	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9c peek(
>c11c	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9d rnd(
>c120	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9e usr(
>c124	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $9f left$(
>c12a	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a0 right$(
>c131	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a1 mid$(
>c136	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a2 spc(
>c13a	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a3 str$(
>c13f	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a4 val(
>c143	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a5 len(
>c147	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a6 hex$(
>c14c	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a7 sin(
>c150	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a8 cos(
>c154	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $a9 tan(
>c158	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $aa atn(
>c15c	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ab exp(
>c160	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ac log(
>c164	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ad sqr(
>c168	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $ae dec(
>c16c	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $af deek(
>c171	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b0 leek(
>c176	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b1 mod(
>c17a	24 a8					.byte $24,$a8                          ; $b2 $(
>c17c	a4					.byte $a4                              ; $b3 $
>c17d	23 a8					.byte $23,$a8                          ; $b4 #(
>c17f	a3					.byte $a3                              ; $b5 #
>c180	25 a8					.byte $25,$a8                          ; $b6 %(
>c182	a5					.byte $a5                              ; $b7 %
>c183	a8					.byte $a8                              ; $b8 (
>c184	a9					.byte $a9                              ; $b9 )
>c185	ac					.byte $ac                              ; $ba ,
>c186	ba					.byte $ba                              ; $bb :
>c187	bb					.byte $bb                              ; $bc ;
>c188	44 45 c6				.byte $44,$45,$c6                      ; $bd def
>c18b	43 4c d2				.byte $43,$4c,$d2                      ; $be clr
>c18e	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c0 data
>c192	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c1 read
>c196	44 49 cd				.byte $44,$49,$cd                      ; $c2 dim
>c199	54 cf					.byte $54,$cf                          ; $c3 to
>c19b	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c4 step
>c19f	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $c5 gosub
>c1a4	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $c6 return
>c1aa	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $c7 goto
>c1ae	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $c8 input
>c1b3	4c 45 d4				.byte $4c,$45,$d4                      ; $c9 let
>c1b6	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $ca list
>c1ba	4e 45 d7				.byte $4e,$45,$d7                      ; $cb new
>c1bd	4f 4c c4				.byte $4f,$4c,$c4                      ; $cc old
>c1c0	4f ce					.byte $4f,$ce                          ; $cd on
>c1c2	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $ce restore
>c1c9	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $cf poke
>c1cd	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d0 print
>c1d2	52 55 ce				.byte $52,$55,$ce                      ; $d1 run
>c1d5	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $d2 stop
>c1d9	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d3 wait
>c1dd	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $d4 doke
>c1e1	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $d5 loke
>c1e5	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $d6 assert
>c1eb	00					.byte $00

;******  Return to file: modules/hardware/em65816.asm

.c1ec					StartROM:
.c1ec	18		clc				clc
.c1ed	fb		xce				xce
.c1ee	c2 30		rep #$30			rep 	#$30
.c1f0	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.c1f3	1b		tcs				tcs
.c1f4	e2 30		sep #$30			sep 	#$30 						; clear AXY in 16 bit.
.c1f6	c2 30		rep #$30			rep 	#$30
.c1f8	a9 00 00	lda #$0000			lda 	#$0000
.c1fb	aa		tax				tax
.c1fc	a8		tay				tay
.c1fd	e2 30		sep #$30			sep 	#$30
.c1ff	20 a3 c3	jsr $c3a3			jsr 	IF_Reset 					; reset external interface
.c202	20 08 c2	jsr $c208			jsr 	IFT_ClearScreen
.c205	4c 82 c4	jmp $c482		jmp TIM_Start

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.c208					IFT_ClearScreen:
.c208	48		pha				pha
.c209	da		phx				phx
.c20a	5a		phy				phy
.c20b	20 a4 c3	jsr $c3a4			jsr 	IF_Home 					; home cursor
.c20e	a2 20		ldx #$20			ldx 	#IF_Height 					; this many lines.
.c210					_IFT_CS0:
.c210	a0 40		ldy #$40			ldy 	#IF_Width 					; this many chars/line
.c212					_IFT_CS1:
.c212	a9 20		lda #$20			lda 	#' '						; clear line.
.c214	20 d0 c3	jsr $c3d0			jsr 	IF_Write
.c217	88		dey				dey
.c218	d0 f8		bne $c212			bne 	_IFT_CS1
.c21a	20 b7 c3	jsr $c3b7			jsr 	IF_NewLine 					; next line down
.c21d	ca		dex				dex
.c21e	d0 f0		bne $c210			bne 	_IFT_CS0
.c220	7a		ply				ply
.c221	fa		plx				plx
.c222	68		pla				pla
.c223					IFT_HomeCursor:
.c223	48		pha				pha
.c224	20 a4 c3	jsr $c3a4			jsr 	IF_Home
.c227	a9 00		lda #$00			lda 	#0
.c229	8d 00 02	sta $0200			sta 	IFT_XCursor
.c22c	8d 01 02	sta $0201			sta 	IFT_YCursor
.c22f	68		pla				pla
.c230	60		rts				rts
.c231					IFT_UpLine:
.c231	48		pha				pha
.c232	ad 01 02	lda $0201			lda  	IFT_YCursor 				; get Y
.c235	3a		dec a				dec 	a 							; line above
.c236	30 03		bmi $c23b			bmi 	_IFTULExit 					; too far, abort
.c238	20 c6 c2	jsr $c2c6			jsr 	IFT_SetYPos					; set to that line.
.c23b					_IFTULExit:
.c23b	68		pla				pla
.c23c	60		rts				rts
.c23d					IFT_PrintCharacter:
.c23d	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.c23f	f0 16		beq $c257			beq 	IFT_NewLine
.c241	48		pha				pha
.c242	20 6f c2	jsr $c26f			jsr 	IFT_UpperCase 				; make upper case
.c245	20 d0 c3	jsr $c3d0			jsr 	IF_Write 					; write out.
.c248	ee 00 02	inc $0200			inc 	IFT_XCursor 				; bump x cursor
.c24b	ad 00 02	lda $0200			lda 	IFT_XCursor 				; reached RHS ?
.c24e	c9 40		cmp #$40			cmp 	#IF_Width
.c250	d0 03		bne $c255			bne 	_IFT_PCNotEOL
.c252	20 57 c2	jsr $c257			jsr 	IFT_NewLine 				; if so do new line.
.c255					_IFT_PCNotEOL:
.c255	68		pla				pla
.c256	60		rts				rts
.c257					IFT_NewLine:
.c257	48		pha				pha
.c258	20 b7 c3	jsr $c3b7			jsr 	IF_NewLine 					; new line on actual screen.
.c25b	a9 00		lda #$00			lda 	#0 							; reset x position
.c25d	8d 00 02	sta $0200			sta 	IFT_XCursor
.c260	ee 01 02	inc $0201			inc 	IFT_YCursor 				; move down.
.c263	ad 01 02	lda $0201			lda 	IFT_YCursor
.c266	c9 20		cmp #$20			cmp 	#IF_Height 					; reached bottom.
.c268	d0 03		bne $c26d			bne 	_IFT_NL_NotEOS
.c26a	20 7a c2	jsr $c27a			jsr 	IFT_Scroll 					; scroll screen up.
.c26d					_IFT_NL_NotEOS:
.c26d	68		pla				pla
.c26e	60		rts				rts
.c26f					IFT_UpperCase:
.c26f	c9 61		cmp #$61			cmp 	#"a"
.c271	90 06		bcc $c279			bcc 	_IFT_UCExit
.c273	c9 7b		cmp #$7b			cmp 	#"z"+1
.c275	b0 02		bcs $c279			bcs 	_IFT_UCExit
.c277	49 20		eor #$20			eor 	#$20
.c279					_IFT_UCExit:
.c279	60		rts				rts
.c27a					IFT_Scroll:
.c27a	48		pha				pha 								; save AXY
.c27b	da		phx				phx
.c27c	5a		phy				phy
.c27d	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.c27f					_IFT_SLoop:
.c27f	20 9f c2	jsr $c29f			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.c282	e8		inx				inx
.c283	e0 1f		cpx #$1f			cpx 	#IF_Height-1				; do whole screen
.c285	d0 f8		bne $c27f			bne 	_IFT_SLoop
.c287	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.c289	20 c6 c2	jsr $c2c6			jsr 	IFT_SetYPos
.c28c	a2 40		ldx #$40			ldx 	#IF_Width 					; blank line
.c28e					_IFT_SBlank:
.c28e	a9 20		lda #$20			lda 	#32
.c290	20 d0 c3	jsr $c3d0			jsr 	IF_Write
.c293	ca		dex				dex
.c294	d0 f8		bne $c28e			bne 	_IFT_SBlank
.c296	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.c298	20 c6 c2	jsr $c2c6			jsr 	IFT_SetYPos
.c29b	7a		ply				ply
.c29c	fa		plx				plx
.c29d	68		pla				pla
.c29e	60		rts				rts
.c29f					_IFT_ScrollLine:
.c29f	da		phx				phx
.c2a0	da		phx				phx
.c2a1	8a		txa				txa 								; copy line into buffer.
.c2a2	1a		inc a				inc 	a 							; next line down.
.c2a3	20 c6 c2	jsr $c2c6			jsr 	IFT_SetYPos
.c2a6	a2 00		ldx #$00			ldx 	#0
.c2a8					_IFTScrollCopy1:
.c2a8	20 c7 c3	jsr $c3c7			jsr 	IF_Read
.c2ab	9d 02 02	sta $0202,x			sta 	IFT_Buffer,x
.c2ae	e8		inx				inx
.c2af	e0 40		cpx #$40			cpx 	#IF_Width
.c2b1	d0 f5		bne $c2a8			bne 	_IFTScrollCopy1
.c2b3	68		pla				pla
.c2b4	20 c6 c2	jsr $c2c6			jsr 	IFT_SetYPos
.c2b7	a2 00		ldx #$00			ldx 	#0
.c2b9					_IFTScrollCopy2:
.c2b9	bd 02 02	lda $0202,x			lda 	IFT_Buffer,x
.c2bc	20 d0 c3	jsr $c3d0			jsr 	IF_Write
.c2bf	e8		inx				inx
.c2c0	e0 40		cpx #$40			cpx 	#IF_Width
.c2c2	d0 f5		bne $c2b9			bne 	_IFTScrollCopy2
.c2c4	fa		plx				plx
.c2c5	60		rts				rts
.c2c6					IFT_SetYPos:
.c2c6	48		pha				pha
.c2c7	da		phx				phx
.c2c8	aa		tax				tax
.c2c9	20 23 c2	jsr $c223			jsr 	IFT_HomeCursor
.c2cc	e0 00		cpx #$00			cpx 	#0
.c2ce	f0 09		beq $c2d9			beq 	_IFT_MOAExit
.c2d0					_IFT_MOALoop:
.c2d0	20 b7 c3	jsr $c3b7			jsr 	IF_NewLine
.c2d3	ee 01 02	inc $0201			inc 	IFT_YCursor
.c2d6	ca		dex				dex
.c2d7	d0 f7		bne $c2d0			bne		_IFT_MOALoop
.c2d9					_IFT_MOAExit:
.c2d9	fa		plx				plx
.c2da	68		pla				pla
.c2db	60		rts				rts
.c2dc					IFT_GetKeyCursor:
.c2dc	20 e4 c2	jsr $c2e4			jsr 	_IFT_FlipCursor 			; reverse current
.c2df					_IFT_GKCWait:
.c2df	20 e1 c3	jsr $c3e1			jsr 	IF_GetKey 					; get key
.c2e2	f0 fb		beq $c2df			beq 	_IFT_GKCWait
.c2e4					_IFT_FlipCursor:
.c2e4	48		pha				pha 								; save
.c2e5	20 c7 c3	jsr $c3c7			jsr 	IF_Read 					; read
.c2e8	20 d9 c3	jsr $c3d9			jsr 	IF_LeftOne
.c2eb	49 80		eor #$80			eor 	#$80 						; reverse
.c2ed	20 d0 c3	jsr $c3d0			jsr 	IF_Write 					; write
.c2f0	20 d9 c3	jsr $c3d9			jsr 	IF_LeftOne
.c2f3	68		pla				pla
.c2f4	60		rts				rts
.c2f5					IFT_ReadLine:
.c2f5	48		pha				pha
.c2f6					_IFT_RLLoop:
.c2f6	20 dc c2	jsr $c2dc			jsr 	IFT_GetKeyCursor 			; get keystroke
.c2f9	c9 0d		cmp #$0d			cmp 	#13							; return
.c2fb	f0 7d		beq $c37a			beq 	_IFT_RLExit
.c2fd	c9 20		cmp #$20			cmp 	#32 						; control character
.c2ff	90 05		bcc $c306			bcc 	_IFT_Control
.c301	20 3d c2	jsr $c23d			jsr 	IFT_PrintCharacter
.c304	80 f0		bra $c2f6			bra 	_IFT_RLLoop
.c306					_IFT_Control:
.c306	c9 01		cmp #$01			cmp 	#"A"-64
.c308	f0 26		beq $c330			beq 	_IFT_Left
.c30a	c9 04		cmp #$04			cmp 	#"D"-64
.c30c	f0 2e		beq $c33c			beq 	_IFT_Right
.c30e	c9 17		cmp #$17			cmp 	#"W"-64
.c310	f0 36		beq $c348			beq 	_IFT_Up
.c312	c9 13		cmp #$13			cmp 	#"S"-64
.c314	f0 3e		beq $c354			beq 	_IFT_Down
.c316	c9 08		cmp #$08			cmp 	#"H"-64
.c318	f0 09		beq $c323			beq 	_IFT_Backspace
.c31a	c9 1a		cmp #$1a			cmp 	#"Z"-64
.c31c	d0 d8		bne $c2f6			bne 	_IFT_RLLoop
.c31e	20 08 c2	jsr $c208			jsr 	IFT_ClearScreen				; clear CTL-Z
.c321	80 d3		bra $c2f6			bra 	_IFT_RLLoop
.c323					_IFT_Backspace:
.c323	ad 00 02	lda $0200			lda 	IFT_XCursor 				; check not start of line.
.c326	f0 ce		beq $c2f6			beq 	_IFT_RLLoop
.c328	20 d9 c3	jsr $c3d9			jsr 	IF_LeftOne
.c32b	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.c32d	20 d0 c3	jsr $c3d0			jsr 	IF_Write
.c330					_IFT_Left:
.c330	ce 00 02	dec $0200			dec 	IFT_XCursor 				; left CTL-W
.c333	10 29		bpl $c35e			bpl 	_IFT_Reposition
.c335	a9 3f		lda #$3f			lda 	#IF_Width-1
.c337					_IFT_SetX:
.c337	8d 00 02	sta $0200			sta 	IFT_XCursor
.c33a	80 22		bra $c35e			bra 	_IFT_Reposition
.c33c					_IFT_Right:
.c33c	ee 00 02	inc $0200			inc 	IFT_XCursor
.c33f	ad 00 02	lda $0200			lda 	IFT_XCursor
.c342	49 40		eor #$40			eor 	#IF_Width
.c344	f0 f1		beq $c337			beq 	_IFT_SetX
.c346	80 16		bra $c35e			bra 	_IFT_Reposition
.c348					_IFT_Up:
.c348	ce 01 02	dec $0201			dec 	IFT_YCursor
.c34b	10 11		bpl $c35e			bpl 	_IFT_Reposition
.c34d	a9 1f		lda #$1f			lda 	#IF_Height-1
.c34f					_IFT_SetY:
.c34f	8d 01 02	sta $0201			sta 	IFT_YCursor
.c352	80 0a		bra $c35e			bra 	_IFT_Reposition
.c354					_IFT_Down:
.c354	ee 01 02	inc $0201			inc 	IFT_YCursor
.c357	ad 01 02	lda $0201			lda 	IFT_YCursor
.c35a	49 20		eor #$20			eor 	#IF_Height
.c35c	f0 f1		beq $c34f			beq 	_IFT_SetY
.c35e					_IFT_Reposition:
.c35e	ad 00 02	lda $0200			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.c361	48		pha				pha
.c362	ad 01 02	lda $0201			lda 	IFT_YCursor
.c365	20 c6 c2	jsr $c2c6			jsr 	IFT_SetYPos
.c368	68		pla				pla
.c369	aa		tax				tax
.c36a	e0 00		cpx #$00			cpx 	#0
.c36c	f0 88		beq $c2f6			beq 	_IFT_RLLoop
.c36e					_IFT_MoveRight:
.c36e	20 c7 c3	jsr $c3c7			jsr 	IF_Read
.c371	ee 00 02	inc $0200			inc 	IFT_XCursor
.c374	ca		dex				dex
.c375	d0 f7		bne $c36e			bne 	_IFT_MoveRight
.c377	4c f6 c2	jmp $c2f6			jmp 	_IFT_RLLoop
.c37a					_IFT_RLExit:
.c37a	ad 01 02	lda $0201			lda 	IFT_YCursor 				; go to start of line.
.c37d	20 c6 c2	jsr $c2c6			jsr 	IFT_SetYPos
.c380	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.c382					_IFT_RLRead:
.c382	20 c7 c3	jsr $c3c7			jsr 	IF_Read
.c385	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.c388	e8		inx				inx
.c389	e0 40		cpx #$40			cpx 	#IF_Width
.c38b	d0 f5		bne $c382			bne 	_IFT_RLRead
.c38d					_IFT_RL_Trim:
.c38d	ca		dex				dex 	 							; previous char
.c38e	30 07		bmi $c397			bmi 	_IFT_Found 					; gone too far
.c390	bd 66 02	lda $0266,x			lda 	IFT_LineBuffer,x			; go back if space
.c393	c9 20		cmp #$20			cmp 	#" "
.c395	f0 f6		beq $c38d			beq 	_IFT_RL_Trim
.c397					_IFT_Found:
.c397	e8		inx				inx 								; forward to non-space
.c398	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.c39a	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.c39d	68		pla				pla
.c39e	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.c3a0	a0 02		ldy #$02			ldy 	#IFT_LineBuffer >> 8
.c3a2	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_em65816.asm

=64					IF_Width 	= 64 							; characters across
=32					IF_Height 	= 32 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line.
=8					IF_XPos 	= 8 							; current position, horizontal.
=$f0000					IF_Screen = $F0000							; 2k screen RAM here
=$f8010					IF_PKeyboard = $F8010						; Keyboard port.
=$f8000					IF_PBreak = $F8000 							; Break key.
.c3a3					IF_Reset:
.c3a3	60		rts				rts
.c3a4					IF_Home:
.c3a4	48		pha				pha
.c3a5	64 08		stz $08				stz 	IF_XPos 					; zero X position
.c3a7	a9 00		lda #$00			lda 	#IF_Screen & $FF 			; set r/w pos.
.c3a9	85 04		sta $04				sta 	IF_Pos
.c3ab	a9 00		lda #$00			lda 	#(IF_Screen >> 8) & $FF
.c3ad	85 05		sta $05				sta 	IF_Pos+1
.c3af	a9 0f		lda #$0f			lda 	#IF_Screen >> 16
.c3b1	85 06		sta $06				sta 	IF_Pos+2
.c3b3	64 07		stz $07				stz 	IF_Pos+3
.c3b5	68		pla				pla
.c3b6	60		rts				rts
.c3b7					IF_NewLine:
.c3b7	48		pha				pha
.c3b8	64 08		stz $08				stz 	IF_XPos						; back to start of line
.c3ba	18		clc				clc 								; down one line
.c3bb	a5 04		lda $04				lda 	IF_Pos
.c3bd	69 40		adc #$40			adc 	#64
.c3bf	85 04		sta $04				sta 	IF_Pos
.c3c1	90 02		bcc $c3c5			bcc 	_IF_NoCarry 				; carry through.
.c3c3	e6 05		inc $05				inc 	IF_Pos+1
.c3c5					_IF_NoCarry:
.c3c5	68		pla				pla
.c3c6	60		rts				rts
.c3c7					IF_Read:
.c3c7	5a		phy				phy 								; save current Y
.c3c8	a4 08		ldy $08				ldy 	IF_XPos 					; read character at current position
.c3ca	b7 04		lda [$04],y			lda 	[IF_Pos],y
.c3cc	e6 08		inc $08				inc 	IF_XPos 					; step right.
.c3ce	7a		ply				ply									; restore Y
.c3cf	60		rts				rts
.c3d0					IF_Write:
.c3d0	5a		phy				phy 								; save current Y
.c3d1	a4 08		ldy $08				ldy 	IF_XPos 					; write character at current position
.c3d3	97 04		sta [$04],y			sta 	[IF_Pos],y
.c3d5	e6 08		inc $08				inc 	IF_XPos 					; step right.
.c3d7	7a		ply				ply									; restore Y
.c3d8	60		rts				rts
.c3d9					IF_LeftOne:
.c3d9	c6 08		dec $08				dec 	IF_XPos
.c3db	60		rts				rts
.c3dc					IF_CheckBreak:
.c3dc	af 00 80 0f	lda $0f8000			lda 	IF_PBreak					; non-zero if Ctrl+C pressed.
.c3e0	60		rts				rts
.c3e1					IF_GetKey:
.c3e1	af 10 80 0f	lda $0f8010			lda 	IF_PKeyboard				; read keyboard
.c3e5	f0 08		beq $c3ef			beq		_IFGK_NoKey 				; skip if zero,no key pressed
.c3e7	48		pha				pha 								; key pressed, clear queue.
.c3e8	a9 00		lda #$00			lda 	#0
.c3ea	8f 10 80 0f	sta $0f8010			sta 	IF_PKeyboard
.c3ee	68		pla				pla
.c3ef					_IFGK_NoKey:
.c3ef	09 00		ora #$00			ora 	#0							; set Z flag appropriately.
.c3f1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.c3f2					TIM_Error:
.c3f2	20 31 c2	jsr $c231			jsr 	IFT_UpLine 					; go up one line.
.c3f5	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.c3f7	80 02		bra $c3fb			bra 	TIM_ShowPrompt
.c3f9					TIM_NewCommand:
.c3f9	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.c3fb					TIM_ShowPrompt:
.c3fb	20 3d c2	jsr $c23d			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.c3fe	20 f5 c2	jsr $c2f5			jsr 	IFT_ReadLine	 			; get character, go to next line
.c401	20 57 c2	jsr $c257			jsr 	IFT_NewLine					; go to next line.
.c404	86 10		stx $10				stx 	zTemp1 						; save line read address
.c406	84 11		sty $11				sty 	zTemp1+1
.c408	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.c40a	b1 10		lda ($10),y			lda 	(zTemp1),y
.c40c	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.c40e	d0 01		bne $c411			bne 	TIM_NotDot
.c410	c8		iny				iny
.c411					TIM_NotDot:
.c411	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.c413	c9 52		cmp #$52			cmp 	#"R"						; show registers
.c415	f0 6b		beq $c482			beq 	TIM_ShowRegisters
.c417	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.c419	f0 12		beq $c42d			beq 	TIM_ShowMemory
.c41b	c9 47		cmp #$47			cmp 	#"G"						; execute
.c41d	f0 49		beq $c468			beq 	TIM_Execute
.c41f	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.c421	f0 07		beq $c42a			beq 	TIM_GoLoadMemory
.c423	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.c425	d0 cb		bne $c3f2			bne 	TIM_Error
.c427	4c a5 c5	jmp $c5a5			jmp 	TIM_UpdateRegisters
.c42a					TIM_GoLoadMemory:
.c42a	4c d6 c5	jmp $c5d6			jmp 	TIM_LoadMemory
.c42d					TIM_ShowMemory:
.c42d	20 21 c5	jsr $c521			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.c430	b0 c0		bcs $c3f2			bcs 	TIM_Error
.c432	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.c434	85 12		sta $12				sta 	zTemp2
.c436	a5 15		lda $15				lda 	zTemp3+1
.c438	85 13		sta $13				sta 	zTemp2+1
.c43a	20 21 c5	jsr $c521			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.c43d	90 08		bcc $c447			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.c43f	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.c441	85 14		sta $14				sta 	zTemp3
.c443	a5 13		lda $13				lda 	zTemp2+1
.c445	85 15		sta $15				sta 	zTemp3+1
.c447					_TIMSM_Start:
.c447	20 f9 c4	jsr $c4f9			jsr 	TIM_WriteLine 				; write one line of hex out
.c44a	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.c44c	18		clc				clc
.c44d	69 10		adc #$10			adc 	#16
.c44f	85 12		sta $12				sta 	zTemp2
.c451	90 02		bcc $c455			bcc 	_TIMSM_NoCarry
.c453	e6 13		inc $13				inc 	zTemp2+1
.c455					_TIMSM_NoCarry:
.c455	20 dc c3	jsr $c3dc			jsr 	IF_CheckBreak 				; check CTL+C
.c458	d0 0b		bne $c465			bne 	_TIMSM_Ends 				; if pressed break out.
.c45a	38		sec				sec 								; check past the end address in zTemp3
.c45b	a5 14		lda $14				lda 	zTemp3
.c45d	e5 12		sbc $12				sbc 	zTemp2
.c45f	a5 15		lda $15				lda 	zTemp3+1
.c461	e5 13		sbc $13				sbc 	zTemp2+1
.c463	10 e2		bpl $c447			bpl 	_TIMSM_Start
.c465					_TIMSM_Ends:
.c465	4c f9 c3	jmp $c3f9			jmp 	TIM_NewCommand
.c468					TIM_Execute:
.c468	20 21 c5	jsr $c521			jsr 	TIM_GetHex 					; get the execute address
.c46b	b0 85		bcs $c3f2			bcs 	TIM_Error 					; not legitimate
.c46d	ae 2c 04	ldx $042c			ldx 	TIM_SP 						; set up SP
.c470	9a		txs				txs
.c471	ad 27 04	lda $0427			lda 	TIM_SR 						; Status for PLP
.c474	48		pha				pha
.c475	ad 28 04	lda $0428			lda 	TIM_A 						; restore AXYZ
.c478	ae 29 04	ldx $0429			ldx 	TIM_X
.c47b	ac 2a 04	ldy $042a			ldy 	TIM_Y
.c47e	28		plp				plp 								; and PS Byte.
.c47f	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.c482					TIM_Start:
.c482					TIM_ShowRegisters:
.c482	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.c485	8d 26 04	sta $0426			sta 	TIM_IRQ+1
.c488	ad ff ff	lda $ffff			lda 	$FFFF
.c48b	8d 25 04	sta $0425			sta 	TIM_IRQ
.c48e	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.c490					_TIMSR_Text:
.c490	bd c0 c4	lda $c4c0,x			lda 	_TIMSR_Label,x
.c493	20 3d c2	jsr $c23d			jsr 	IFT_PrintCharacter
.c496	e8		inx				inx
.c497	e0 20		cpx #$20			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.c499	d0 f5		bne $c490			bne 	_TIMSR_Text
.c49b	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.c49d					_TIMSR_Skip:
.c49d	e8		inx				inx
.c49e					_TIMSR_LoopSpace:
.c49e	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.c4a0	b0 04		bcs $c4a6			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.c4a2	8a		txa				txa
.c4a3	4a		lsr a				lsr 	a
.c4a4	b0 05		bcs $c4ab			bcs 	_TIMSR_NoSpace
.c4a6					_TIMSR_Space:
.c4a6	a9 20		lda #$20			lda 	#" "
.c4a8	20 3d c2	jsr $c23d			jsr 	IFT_PrintCharacter
.c4ab					_TIMSR_NoSpace:
.c4ab	bd 23 04	lda $0423,x			lda 	TIM_PC,x 					; output hex value.
.c4ae	20 e0 c4	jsr $c4e0			jsr 	TIM_WriteHex
.c4b1	e8		inx				inx
.c4b2	e0 08		cpx #$08			cpx 	#TIM_Z-TIM_PC
.c4b4	f0 e7		beq $c49d			beq 	_TIMSR_Skip
.c4b6	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.c4b8	d0 e4		bne $c49e			bne 	_TimSR_LoopSpace
.c4ba	20 57 c2	jsr $c257			jsr 	IFT_NewLine 				; new line
.c4bd	4c f9 c3	jmp $c3f9			jmp	 	TIM_NewCommand 				; new command.
.c4c0					_TIMSR_Label:
>c4c0	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>c4c8	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>c4d8	52
>c4d9	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.c4e0					_TIMSR_LabelEnd:
.c4e0					TIM_WriteHex:
.c4e0	48		pha				pha 								; save A
.c4e1	4a		lsr a				lsr 	a 							; shift MSB->LSB
.c4e2	4a		lsr a				lsr 	a
.c4e3	4a		lsr a				lsr 	a
.c4e4	4a		lsr a				lsr 	a
.c4e5	20 e9 c4	jsr $c4e9			jsr 	_TIMWH_Nibble 				; print MSB
.c4e8	68		pla				pla 								; restore and print LSB
.c4e9					_TIMWH_Nibble:
.c4e9	48		pha				pha
.c4ea	29 0f		and #$0f			and 	#15 						; mask out
.c4ec	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.c4ee	90 02		bcc $c4f2			bcc 	_TIMWHNoLetter
.c4f0	69 06		adc #$06			adc 	#6
.c4f2					_TIMWHNoLetter:
.c4f2	69 30		adc #$30			adc 	#48
.c4f4	20 3d c2	jsr $c23d			jsr 	IFT_PrintCharacter 			; print it out.
.c4f7	68		pla				pla
.c4f8	60		rts				rts
.c4f9					TIM_WriteLine:
.c4f9	a9 2e		lda #$2e			lda 	#"." 						; prompt
.c4fb	20 3d c2	jsr $c23d			jsr 	IFT_PrintCharacter
.c4fe	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.c500	20 3d c2	jsr $c23d			jsr 	IFT_PrintCharacter
.c503	a5 13		lda $13				lda 	zTemp2+1 					; write address
.c505	20 e0 c4	jsr $c4e0			jsr 	TIM_WriteHex
.c508	a5 12		lda $12				lda 	zTemp2
.c50a	20 e0 c4	jsr $c4e0			jsr 	TIM_WriteHex
.c50d	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.c50f					_TIMWL_Loop:
.c50f	a9 20		lda #$20			lda 	#" "
.c511	20 3d c2	jsr $c23d			jsr 	IFT_PrintCharacter
.c514	b1 12		lda ($12),y			lda 	(zTemp2),y
.c516	20 e0 c4	jsr $c4e0			jsr 	TIM_WriteHex
.c519	c8		iny				iny
.c51a	c0 10		cpy #$10			cpy 	#16
.c51c	d0 f1		bne $c50f			bne 	_TIMWL_Loop
.c51e	4c 57 c2	jmp $c257			jmp 	IFT_NewLine 				; new line and exit
.c521					TIM_GetHex:
.c521	c8		iny				iny
.c522	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.c524	c9 20		cmp #$20			cmp 	#32
.c526	f0 f9		beq $c521			beq 	TIM_GetHex
.c528	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.c52a	f0 f5		beq $c521			beq 	TIM_GetHex
.c52c	20 55 c5	jsr $c555			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.c52f	b0 23		bcs $c554			bcs 	_TIMGH_Exit					; if first bad then exit now.
.c531	a9 00		lda #$00			lda 	#0 							; zero result
.c533	85 14		sta $14				sta 	zTemp3
.c535	85 15		sta $15				sta 	zTemp3+1
.c537					_TIM_GHLoop:
.c537	20 55 c5	jsr $c555			jsr 	TIM_GetHexCharacter 		; get next character
.c53a	b0 17		bcs $c553			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.c53c	c8		iny				iny 								; skip over it.
.c53d	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.c53f	26 15		rol $15				rol 	zTemp3+1
.c541	06 14		asl $14				asl 	zTemp3 						; now x 2
.c543	26 15		rol $15				rol 	zTemp3+1
.c545	06 14		asl $14				asl 	zTemp3						; now x 4
.c547	26 15		rol $15				rol 	zTemp3+1
.c549	06 14		asl $14				asl 	zTemp3 						; now x 8
.c54b	26 15		rol $15				rol 	zTemp3+1
.c54d	05 14		ora $14				ora 	zTemp3 						; OR result in
.c54f	85 14		sta $14				sta 	zTemp3
.c551	80 e4		bra $c537			bra 	_TIM_GHLoop 				; loop round again.
.c553					_TIMGH_Okay:
.c553	18		clc				clc
.c554					_TIMGH_Exit:
.c554	60		rts				rts
.c555					TIM_GetHexCharacter:
.c555	b1 10		lda ($10),y			lda 	(zTemp1),y
.c557	38		sec				sec
.c558	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.c55a	90 0e		bcc $c56a			bcc 	_TIM_GHCFail
.c55c	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.c55e	90 0b		bcc $c56b			bcc 	_TIM_GHCExit
.c560	c9 11		cmp #$11			cmp 	#65-48						; < A
.c562	90 06		bcc $c56a			bcc		_TIM_GHCFail
.c564	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.c566	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.c568	90 01		bcc $c56b			bcc		_TIM_GHCExit
.c56a					_TIM_GHCFail:
.c56a	38		sec				sec
.c56b					_TIM_GHCExit:
.c56b	60		rts				rts
.c56c					TIM_BreakVector:
.c56c	da		phx				phx									; save X/A on stack
.c56d	48		pha				pha
.c56e	ba		tsx				tsx 								; X points to S
.c56f	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.c572	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.c574	d0 03		bne $c579			bne 	_TIMBreak					; if set, it's BRK
.c576	68		pla				pla 								; abandon routine.
.c577	fa		plx				plx
.c578	40		rti				rti
.c579					_TIMBreak:
.c579	68		pla				pla 								; save A X Y and maybe Z
.c57a	8d 28 04	sta $0428			sta 	TIM_A
.c57d	fa		plx				plx
.c57e	8e 29 04	stx $0429			stx 	TIM_X
.c581	8c 2a 04	sty $042a			sty 	TIM_Y
.c584	68		pla				pla 								; get Status Register
.c585	8d 27 04	sta $0427			sta 	TIM_SR
.c588	68		pla				pla
.c589	8d 24 04	sta $0424			sta 	TIM_PC+1 					; save calling address
.c58c	68		pla				pla
.c58d	8d 23 04	sta $0423			sta 	TIM_PC 						; high byte
.c590	ad 24 04	lda $0424			lda 	TIM_PC+1 					; dec PC to point right.
.c593	d0 03		bne $c598			bne 	_TIMDecrement 				; brk bumps it.
.c595	ce 23 04	dec $0423			dec 	TIM_PC
.c598					_TIMDecrement:
.c598	ce 24 04	dec $0424			dec 	TIM_PC+1
.c59b	ba		tsx				tsx 								; and copy SP
.c59c	8e 2c 04	stx $042c			stx 	TIM_SP
.c59f	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.c5a1	9a		txs				txs
.c5a2	4c 82 c4	jmp $c482			jmp 	TIM_Start 					; and start up TIM monitor.
.c5a5					TIM_UpdateRegisters:
.c5a5	20 21 c5	jsr $c521			jsr 	TIM_GetHex 					; PC
.c5a8	b0 29		bcs $c5d3			bcs 	_TIMURFail
.c5aa	a5 14		lda $14				lda 	zTemp3
.c5ac	8d 24 04	sta $0424			sta 	Tim_PC+1
.c5af	a5 15		lda $15				lda 	zTemp3+1
.c5b1	8d 23 04	sta $0423			sta 	Tim_PC
.c5b4	20 21 c5	jsr $c521			jsr 	TIM_GetHex 					; ignore IRQ
.c5b7	b0 1a		bcs $c5d3			bcs 	_TIMURFail
.c5b9	a2 00		ldx #$00			ldx 	#0
.c5bb	ea		nop				nop
.c5bc					_TIM_URLoop:
.c5bc	e0 04		cpx #$04			cpx 	#Tim_Z-Tim_SR
.c5be	d0 01		bne $c5c1			bne 	_TIM_1
.c5c0	e8		inx				inx
.c5c1					_TIM_1:
.c5c1	20 21 c5	jsr $c521			jsr 	TIM_GetHex 					; registers
.c5c4	b0 0d		bcs $c5d3			bcs 	_TIMURFail
.c5c6	a5 14		lda $14				lda 	zTemp3
.c5c8	9d 27 04	sta $0427,x			sta 	Tim_SR,x
.c5cb	e8		inx				inx
.c5cc	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.c5ce	d0 ec		bne $c5bc			bne 	_TIM_URLoop
.c5d0	4c f9 c3	jmp $c3f9			jmp 	TIM_NewCommand
.c5d3					_TIMURFail:
.c5d3	4c f2 c3	jmp $c3f2			jmp 	TIM_Error
.c5d6					TIM_LoadMemory:
.c5d6	20 21 c5	jsr $c521			jsr 	TIM_GetHex 					; target address => zTemp2
.c5d9	a5 14		lda $14				lda 	zTemp3
.c5db	85 12		sta $12				sta 	zTemp2
.c5dd	a5 15		lda $15				lda 	zTemp3+1
.c5df	85 13		sta $13				sta 	zTemp2+1
.c5e1					_TIM_LMLoop:
.c5e1	20 21 c5	jsr $c521			jsr 	TIM_GetHex 					; next byte ?
.c5e4	b0 0e		bcs $c5f4			bcs 	_TIMLMDone 					; no more
.c5e6	a2 00		ldx #$00			ldx 	#0							; write out.
.c5e8	a5 14		lda $14				lda 	zTemp3
.c5ea	81 12		sta ($12,x)			sta 	(zTemp2,x)
.c5ec	e6 12		inc $12				inc 	zTemp2 						; bump address
.c5ee	d0 f1		bne $c5e1			bne 	_TIM_LMLoop
.c5f0	e6 13		inc $13				inc 	zTemp2+1
.c5f2	80 ed		bra $c5e1			bra 	_TIM_LMLoop
.c5f4					_TIMLMDone:
.c5f4	4c f9 c3	jmp $c3f9			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Return to file: basic.asm

>c5f7	02						.byte 	2
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	ec c1						.word 	StartROM
>fffe	6c c5					.word TIM_BreakVector

;******  End of listing
