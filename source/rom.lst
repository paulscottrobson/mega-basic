
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Tue Aug 27 20:52:17 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="4510"					cpu = "4510"
="mega65"				hardware = "mega65"
=1					exitonend = 1
=1					autorun = 1
=2					loadtest = 2
=1					hasfloat = 1
=1					hasinteger = 1
=253					maxstring = 253

;******  Processing file: modules/float/fpmacros.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/mega65/src_mega65.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0020					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0022					zVarDataPtr: .word ? 						; position of variable data.
>0024					zVarType: 	.byte ? 						; type of data (token)
>0025					zNullString:.byte ? 						; represents a NULL string.
>0200					IFT_XCursor:.byte ?							; current logical position on screen
>0201					IFT_YCursor:.byte ?
>0202					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0266					IFT_LineBuffer: .fill 100 					; line input buffer.
>0300					UserVector .fill 4 							; USR(x) calls this.
>0304					LocalVector .fill 4 						; Indirect calls call this.
>0308					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>030c					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>030d					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=782					XS2_Mantissa = XS_Mantissa+XS_Size
=786					XS2_Exponent = XS_Exponent+XS_Size
=787					XS2_Type = XS_Type+XS_Size
=788					XS3_Mantissa = XS_Mantissa+XS_Size*2
=792					XS3_Exponent = XS_Exponent+XS_Size*2
=793					XS3_Type = XS_Type+XS_Size*2
>0400					StringPtr:	.word ? 						; Top of free memory (for string allocation)
>0402					VarMemPtr: 	.word ?							; Bottom of free memory (for variables)
>0404					NumBufX 	.byte 	?						; buffer index position
>0405					Num_Buffer	.fill 	32 						; buffer for numeric conversions
=6					HashTableCount = 6 							; there are 6 hash tables, in token order.
=8					HashTableSize = 8 							; each hash table as 8 links.
.0425					HashTableBase:
>0425								.fill	HashTableCount * HashTableSize * 2
.0485					HashTableEnd:
=$405					Var_Buffer 	= Num_Buffer 					; buffer for variable name (same space)
>0485					Var_Type    .byte ? 						; type of variable (as a type token)
>0486					Var_Hash 	.byte ? 						; hash of identifier name.
>0487					Var_Length 	.byte ? 						; length of variable name
>0488					Var_HashAddress .byte ?						; low byte of hash table entry.
>0489					Var_DataSize .byte ?						; size of one element.
>048a					NumSuppress	.byte 	?						; leading zero suppression flag
>048b					NumConvCount .byte 	? 						; count for conversions.
>048c					ExpTemp:	.byte ?							; Working temp for exponents.
>048d					ExpCount:	.byte ? 						; Count of decimal exponents.
>048e					SignCount:	.byte ?							; Integer Divide Sign Counts.
>048f					TempStringWriteIndex: .byte ? 				; Write offset.
>0490					ValSign: 	.byte ? 						; sign flag for val()
>0491					SliceStart:	.byte ? 						; string slice parts
>0492					SliceCount:	.byte ?
>0493					RandomSeed:	.dword ? 						; Random seed.
=3					ArrayMaxDim = 3 							; number of dimensions.
>0497					ArrayDef:	.fill (ArrayMaxDim+1)*2 		; dimensions for auto-creation
>049f					UsrArrayDef:.fill (ArrayMaxDim+1)*2 		; dimensions created in DIM
>04a7					UsrArrayIdx:.byte ? 						; index into UsrArrayDef
>04a8					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>04aa					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>04ac					Tim_SR:		.byte ? 						; Processor Status
>04ad					Tim_A:		.byte ? 						; Processor Registers
>04ae					Tim_X:		.byte ?
>04af					Tim_Y:		.byte ?
>04b0					Tim_Z:		.byte ?
>04b1					Tim_SP:		.word ?							; Stack Pointer (just in cases)

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/mega65.asm

=$7000					HighMemory = $7000
=$4000					VariableMemory = $4000
.8000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testassign.src

>8000	0a 02 00 c7 17 15 b8 41			.byte	$0a,$02,$00,$c7,$17,$15,$b8,$41
>8008	be 00 0b 03 00 c7 1a 01			.byte	$be,$00,$0b,$03,$00,$c7,$1a,$01
>8010	19 ba 42 be 00 09 04 00			.byte	$19,$ba,$42,$be,$00,$09,$04,$00
>8018	dc 01 bb 84 40 00 09 05			.byte	$dc,$01,$bb,$84,$40,$00,$09,$05
>8020	00 dc 08 05 84 40 00 0a			.byte	$00,$dc,$08,$05,$84,$40,$00,$0a
>8028	06 00 dc 13 b7 84 fe 02			.byte	$06,$00,$dc,$13,$b7,$84,$fe,$02
>8030	00 09 07 00 dc 08 11 84			.byte	$00,$09,$07,$00,$dc,$08,$11,$84
>8038	40 00 17 08 00 dc 17 15			.byte	$40,$00,$17,$08,$00,$dc,$17,$15
>8040	b8 40 be 84 fe 02 c0 dc			.byte	$b8,$40,$be,$84,$fe,$02,$c0,$dc
>8048	17 15 b8 41 be 84 fe 02			.byte	$17,$15,$b8,$41,$be,$84,$fe,$02
>8050	00 21 09 00 dc 1a 01 19			.byte	$00,$21,$09,$00,$dc,$1a,$01,$19
>8058	ba 40 be 84 40 c0 dc 1a			.byte	$ba,$40,$be,$84,$40,$c0,$dc,$1a
>8060	01 19 ba 41 be 84 40 c0			.byte	$01,$19,$ba,$41,$be,$84,$40,$c0
>8068	dc 1a 01 19 ba 42 be 84			.byte	$dc,$1a,$01,$19,$ba,$42,$be,$84
>8070	40 00 1b 0a 00 d6 fe 14			.byte	$40,$00,$1b,$0a,$00,$d6,$fe,$14
>8078	50 61 73 73 65 64 20 41			.byte	$50,$61,$73,$73,$65,$64,$20,$41
>8080	73 73 69 67 6e 6d 65 6e			.byte	$73,$73,$69,$67,$6e,$6d,$65,$6e
>8088	74 2e c0 c4 00 00			.byte	$74,$2e,$c0,$c4,$00,$00

;******  Return to file: modules/hardware/mega65.asm

.a000					StartROM:
.a000	a2 ff		ldx #$ff			ldx 		#$FF 					; empty stack
.a002	9a		txs				txs
.a003	20 4d a2	jsr $a24d			jsr 	IF_Reset 					; reset external interface
.a006	20 0c a0	jsr $a00c			jsr 	IFT_ClearScreen
.a009	4c cf af	jmp $afcf		jmp BASIC_Start

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.a00c					IFT_ClearScreen:
.a00c	48		pha				pha
.a00d	da		phx				phx
.a00e	5a		phy				phy
.a00f	20 b4 a1	jsr $a1b4			jsr 	IF_Home 					; home cursor
.a012	a2 19		ldx #$19			ldx 	#IF_Height 					; this many lines.
.a014					_IFT_CS0:
.a014	a0 50		ldy #$50			ldy 	#IF_Width 					; this many chars/line
.a016					_IFT_CS1:
.a016	a9 20		lda #$20			lda 	#' '						; clear line.
.a018	20 e3 a1	jsr $a1e3			jsr 	IF_Write
.a01b	88		dey				dey
.a01c	d0 f8		bne $a016			bne 	_IFT_CS1
.a01e	20 c3 a1	jsr $a1c3			jsr 	IF_NewLine 					; next line down
.a021	ca		dex				dex
.a022	d0 f0		bne $a014			bne 	_IFT_CS0
.a024	7a		ply				ply
.a025	fa		plx				plx
.a026	68		pla				pla
.a027					IFT_HomeCursor:
.a027	48		pha				pha
.a028	20 b4 a1	jsr $a1b4			jsr 	IF_Home
.a02b	a9 00		lda #$00			lda 	#0
.a02d	8d 00 02	sta $0200			sta 	IFT_XCursor
.a030	8d 01 02	sta $0201			sta 	IFT_YCursor
.a033	68		pla				pla
.a034	60		rts				rts
.a035					IFT_UpLine:
.a035	48		pha				pha
.a036	ad 01 02	lda $0201			lda  	IFT_YCursor 				; get Y
.a039	3a		dec a				dec 	a 							; line above
.a03a	30 03		bmi $a03f			bmi 	_IFTULExit 					; too far, abort
.a03c	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos					; set to that line.
.a03f					_IFTULExit:
.a03f	68		pla				pla
.a040	60		rts				rts
.a041					IFT_PrintCharacter:
.a041	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.a043	f0 23		beq $a068			beq 	IFT_NewLine
.a045	48		pha				pha
.a046	20 80 a0	jsr $a080			jsr 	IFT_UpperCase 				; make upper case
.a049	20 e3 a1	jsr $a1e3			jsr 	IF_Write 					; write out.
.a04c	ee 00 02	inc $0200			inc 	IFT_XCursor 				; bump x cursor
.a04f	ad 00 02	lda $0200			lda 	IFT_XCursor 				; reached RHS ?
.a052	c9 50		cmp #$50			cmp 	#IF_Width
.a054	d0 03		bne $a059			bne 	_IFT_PCNotEOL
.a056	20 68 a0	jsr $a068			jsr 	IFT_NewLine 				; if so do new line.
.a059					_IFT_PCNotEOL:
.a059	68		pla				pla
.a05a	60		rts				rts
.a05b					IFT_Tab:
.a05b	a9 20		lda #$20			lda 	#" " 						; space
.a05d	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.a060	ad 00 02	lda $0200			lda 	IFT_XCursor 				; until x % 8 == 0
.a063	29 07		and #$07			and 	#7
.a065	d0 f4		bne $a05b			bne 	IFT_Tab
.a067	60		rts				rts
.a068					IFT_NewLine:
.a068	48		pha				pha
.a069	20 c3 a1	jsr $a1c3			jsr 	IF_NewLine 					; new line on actual screen.
.a06c	a9 00		lda #$00			lda 	#0 							; reset x position
.a06e	8d 00 02	sta $0200			sta 	IFT_XCursor
.a071	ee 01 02	inc $0201			inc 	IFT_YCursor 				; move down.
.a074	ad 01 02	lda $0201			lda 	IFT_YCursor
.a077	c9 19		cmp #$19			cmp 	#IF_Height 					; reached bottom.
.a079	d0 03		bne $a07e			bne 	_IFT_NL_NotEOS
.a07b	20 8b a0	jsr $a08b			jsr 	IFT_Scroll 					; scroll screen up.
.a07e					_IFT_NL_NotEOS:
.a07e	68		pla				pla
.a07f	60		rts				rts
.a080					IFT_UpperCase:
.a080	c9 61		cmp #$61			cmp 	#"a"
.a082	90 06		bcc $a08a			bcc 	_IFT_UCExit
.a084	c9 7b		cmp #$7b			cmp 	#"z"+1
.a086	b0 02		bcs $a08a			bcs 	_IFT_UCExit
.a088	49 20		eor #$20			eor 	#$20
.a08a					_IFT_UCExit:
.a08a	60		rts				rts
.a08b					IFT_Scroll:
.a08b	48		pha				pha 								; save AXY
.a08c	da		phx				phx
.a08d	5a		phy				phy
.a08e	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.a090					_IFT_SLoop:
.a090	20 b0 a0	jsr $a0b0			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.a093	e8		inx				inx
.a094	e0 18		cpx #$18			cpx 	#IF_Height-1				; do whole screen
.a096	d0 f8		bne $a090			bne 	_IFT_SLoop
.a098	a9 18		lda #$18			lda 	#IF_Height-1 				; move to X = 0,Y = A
.a09a	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a09d	a2 50		ldx #$50			ldx 	#IF_Width 					; blank line
.a09f					_IFT_SBlank:
.a09f	a9 20		lda #$20			lda 	#32
.a0a1	20 e3 a1	jsr $a1e3			jsr 	IF_Write
.a0a4	ca		dex				dex
.a0a5	d0 f8		bne $a09f			bne 	_IFT_SBlank
.a0a7	a9 18		lda #$18			lda 	#IF_Height-1 				; move to X = 0,Y = A
.a0a9	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a0ac	7a		ply				ply
.a0ad	fa		plx				plx
.a0ae	68		pla				pla
.a0af	60		rts				rts
.a0b0					_IFT_ScrollLine:
.a0b0	da		phx				phx
.a0b1	da		phx				phx
.a0b2	8a		txa				txa 								; copy line into buffer.
.a0b3	1a		inc a				inc 	a 							; next line down.
.a0b4	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a0b7	a2 00		ldx #$00			ldx 	#0
.a0b9					_IFTScrollCopy1:
.a0b9	20 d5 a1	jsr $a1d5			jsr 	IF_Read
.a0bc	9d 02 02	sta $0202,x			sta 	IFT_Buffer,x
.a0bf	e8		inx				inx
.a0c0	e0 50		cpx #$50			cpx 	#IF_Width
.a0c2	d0 f5		bne $a0b9			bne 	_IFTScrollCopy1
.a0c4	68		pla				pla
.a0c5	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a0c8	a2 00		ldx #$00			ldx 	#0
.a0ca					_IFTScrollCopy2:
.a0ca	bd 02 02	lda $0202,x			lda 	IFT_Buffer,x
.a0cd	20 e3 a1	jsr $a1e3			jsr 	IF_Write
.a0d0	e8		inx				inx
.a0d1	e0 50		cpx #$50			cpx 	#IF_Width
.a0d3	d0 f5		bne $a0ca			bne 	_IFTScrollCopy2
.a0d5	fa		plx				plx
.a0d6	60		rts				rts
.a0d7					IFT_SetYPos:
.a0d7	48		pha				pha
.a0d8	da		phx				phx
.a0d9	aa		tax				tax
.a0da	20 27 a0	jsr $a027			jsr 	IFT_HomeCursor
.a0dd	e0 00		cpx #$00			cpx 	#0
.a0df	f0 09		beq $a0ea			beq 	_IFT_MOAExit
.a0e1					_IFT_MOALoop:
.a0e1	20 c3 a1	jsr $a1c3			jsr 	IF_NewLine
.a0e4	ee 01 02	inc $0201			inc 	IFT_YCursor
.a0e7	ca		dex				dex
.a0e8	d0 f7		bne $a0e1			bne		_IFT_MOALoop
.a0ea					_IFT_MOAExit:
.a0ea	fa		plx				plx
.a0eb	68		pla				pla
.a0ec	60		rts				rts
.a0ed					IFT_GetKeyCursor:
.a0ed	20 f5 a0	jsr $a0f5			jsr 	_IFT_FlipCursor 			; reverse current
.a0f0					_IFT_GKCWait:
.a0f0	20 06 a2	jsr $a206			jsr 	IF_GetKey 					; get key
.a0f3	f0 fb		beq $a0f0			beq 	_IFT_GKCWait
.a0f5					_IFT_FlipCursor:
.a0f5	48		pha				pha 								; save
.a0f6	20 d5 a1	jsr $a1d5			jsr 	IF_Read 					; read
.a0f9	20 ee a1	jsr $a1ee			jsr 	IF_LeftOne
.a0fc	49 80		eor #$80			eor 	#$80 						; reverse
.a0fe	20 e3 a1	jsr $a1e3			jsr 	IF_Write 					; write
.a101	20 ee a1	jsr $a1ee			jsr 	IF_LeftOne
.a104	68		pla				pla
.a105	60		rts				rts
.a106					IFT_ReadLine:
.a106	48		pha				pha
.a107					_IFT_RLLoop:
.a107	20 ed a0	jsr $a0ed			jsr 	IFT_GetKeyCursor 			; get keystroke
.a10a	c9 0d		cmp #$0d			cmp 	#13							; return
.a10c	f0 7d		beq $a18b			beq 	_IFT_RLExit
.a10e	c9 20		cmp #$20			cmp 	#32 						; control character
.a110	90 05		bcc $a117			bcc 	_IFT_Control
.a112	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.a115	80 f0		bra $a107			bra 	_IFT_RLLoop
.a117					_IFT_Control:
.a117	c9 01		cmp #$01			cmp 	#"A"-64
.a119	f0 26		beq $a141			beq 	_IFT_Left
.a11b	c9 04		cmp #$04			cmp 	#"D"-64
.a11d	f0 2e		beq $a14d			beq 	_IFT_Right
.a11f	c9 17		cmp #$17			cmp 	#"W"-64
.a121	f0 36		beq $a159			beq 	_IFT_Up
.a123	c9 13		cmp #$13			cmp 	#"S"-64
.a125	f0 3e		beq $a165			beq 	_IFT_Down
.a127	c9 08		cmp #$08			cmp 	#"H"-64
.a129	f0 09		beq $a134			beq 	_IFT_Backspace
.a12b	c9 1a		cmp #$1a			cmp 	#"Z"-64
.a12d	d0 d8		bne $a107			bne 	_IFT_RLLoop
.a12f	20 0c a0	jsr $a00c			jsr 	IFT_ClearScreen				; clear CTL-Z
.a132	80 d3		bra $a107			bra 	_IFT_RLLoop
.a134					_IFT_Backspace:
.a134	ad 00 02	lda $0200			lda 	IFT_XCursor 				; check not start of line.
.a137	f0 ce		beq $a107			beq 	_IFT_RLLoop
.a139	20 ee a1	jsr $a1ee			jsr 	IF_LeftOne
.a13c	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.a13e	20 e3 a1	jsr $a1e3			jsr 	IF_Write
.a141					_IFT_Left:
.a141	ce 00 02	dec $0200			dec 	IFT_XCursor 				; left CTL-W
.a144	10 29		bpl $a16f			bpl 	_IFT_Reposition
.a146	a9 4f		lda #$4f			lda 	#IF_Width-1
.a148					_IFT_SetX:
.a148	8d 00 02	sta $0200			sta 	IFT_XCursor
.a14b	80 22		bra $a16f			bra 	_IFT_Reposition
.a14d					_IFT_Right:
.a14d	ee 00 02	inc $0200			inc 	IFT_XCursor
.a150	ad 00 02	lda $0200			lda 	IFT_XCursor
.a153	49 50		eor #$50			eor 	#IF_Width
.a155	f0 f1		beq $a148			beq 	_IFT_SetX
.a157	80 16		bra $a16f			bra 	_IFT_Reposition
.a159					_IFT_Up:
.a159	ce 01 02	dec $0201			dec 	IFT_YCursor
.a15c	10 11		bpl $a16f			bpl 	_IFT_Reposition
.a15e	a9 18		lda #$18			lda 	#IF_Height-1
.a160					_IFT_SetY:
.a160	8d 01 02	sta $0201			sta 	IFT_YCursor
.a163	80 0a		bra $a16f			bra 	_IFT_Reposition
.a165					_IFT_Down:
.a165	ee 01 02	inc $0201			inc 	IFT_YCursor
.a168	ad 01 02	lda $0201			lda 	IFT_YCursor
.a16b	49 19		eor #$19			eor 	#IF_Height
.a16d	f0 f1		beq $a160			beq 	_IFT_SetY
.a16f					_IFT_Reposition:
.a16f	ad 00 02	lda $0200			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.a172	48		pha				pha
.a173	ad 01 02	lda $0201			lda 	IFT_YCursor
.a176	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a179	68		pla				pla
.a17a	aa		tax				tax
.a17b	e0 00		cpx #$00			cpx 	#0
.a17d	f0 88		beq $a107			beq 	_IFT_RLLoop
.a17f					_IFT_MoveRight:
.a17f	20 d5 a1	jsr $a1d5			jsr 	IF_Read
.a182	ee 00 02	inc $0200			inc 	IFT_XCursor
.a185	ca		dex				dex
.a186	d0 f7		bne $a17f			bne 	_IFT_MoveRight
.a188	4c 07 a1	jmp $a107			jmp 	_IFT_RLLoop
.a18b					_IFT_RLExit:
.a18b	ad 01 02	lda $0201			lda 	IFT_YCursor 				; go to start of line.
.a18e	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a191	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.a193					_IFT_RLRead:
.a193	20 d5 a1	jsr $a1d5			jsr 	IF_Read
.a196	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.a199	e8		inx				inx
.a19a	e0 50		cpx #$50			cpx 	#IF_Width
.a19c	d0 f5		bne $a193			bne 	_IFT_RLRead
.a19e					_IFT_RL_Trim:
.a19e	ca		dex				dex 	 							; previous char
.a19f	30 07		bmi $a1a8			bmi 	_IFT_Found 					; gone too far
.a1a1	bd 66 02	lda $0266,x			lda 	IFT_LineBuffer,x			; go back if space
.a1a4	c9 20		cmp #$20			cmp 	#" "
.a1a6	f0 f6		beq $a19e			beq 	_IFT_RL_Trim
.a1a8					_IFT_Found:
.a1a8	e8		inx				inx 								; forward to non-space
.a1a9	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.a1ab	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.a1ae	68		pla				pla
.a1af	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.a1b1	a0 02		ldy #$02			ldy 	#IFT_LineBuffer >> 8
.a1b3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_mega65.asm

=80					IF_Width 	= 80 							; characters across
=25					IF_Height 	= 25 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line
=6					IF_XPos 	= 6 							; current position, horizontal.
=8					IF_FarPtr 	= 8 							; far pointer (4 bytes)
=$1000					IF_Screen = $1000							; 2k screen RAM here
=$800					IF_CharSet = $800							; 2k character set (0-7F) here
.a1b4					IF_Home:
.a1b4	48		pha				pha 								; reset cursor position
.a1b5	a9 00		lda #$00			lda 	#IF_Screen & $FF
.a1b7	85 04		sta $04				sta 	IF_Pos
.a1b9	a9 10		lda #$10			lda 	#IF_Screen >> 8
.a1bb	85 05		sta $05				sta 	IF_Pos+1
.a1bd	a9 00		lda #$00			lda 	#0
.a1bf	85 06		sta $06				sta 	IF_XPos
.a1c1	68		pla				pla
.a1c2	60		rts				rts
.a1c3					IF_NewLine:
.a1c3	48		pha				pha
.a1c4	a9 00		lda #$00			lda 	#0 							; back to start of line
.a1c6	85 06		sta $06				sta 	IF_XPos
.a1c8	18		clc				clc 								; down one line
.a1c9	a5 04		lda $04				lda 	IF_Pos
.a1cb	69 50		adc #$50			adc 	#80
.a1cd	85 04		sta $04				sta 	IF_Pos
.a1cf	90 02		bcc $a1d3			bcc 	_IF_NoCarry 				; carry through.
.a1d1	e6 05		inc $05				inc 	IF_Pos+1
.a1d3					_IF_NoCarry:
.a1d3	68		pla				pla
.a1d4	60		rts				rts
.a1d5					IF_Read:
.a1d5	5a		phy				phy 								; save current Y
.a1d6	a4 06		ldy $06				ldy 	IF_XPos 					; read character at current position
.a1d8	b1 04		lda ($04),y			lda 	(IF_Pos),y
.a1da	49 20		eor #$20			eor 	#$20
.a1dc	18		clc				clc
.a1dd	69 20		adc #$20			adc 	#$20
.a1df	e6 06		inc $06				inc 	IF_XPos 					; step right.
.a1e1	7a		ply				ply									; restore Y
.a1e2	60		rts				rts
.a1e3					IF_Write:
.a1e3	5a		phy				phy 								; save current Y
.a1e4	a4 06		ldy $06				ldy 	IF_XPos 					; write character at current position
.a1e6	29 bf		and #$bf			and 	#63+128 					; PETSCII
.a1e8	91 04		sta ($04),y			sta 	(IF_Pos),y
.a1ea	e6 06		inc $06				inc 	IF_XPos 					; step right.
.a1ec	7a		ply				ply									; restore Y
.a1ed	60		rts				rts
.a1ee					IF_LeftOne:
.a1ee	c6 06		dec $06				dec 	IF_XPos
.a1f0	60		rts				rts
.a1f1					IF_CheckBreak:
.a1f1	db		phz				phz
.a1f2	20 3a a2	jsr $a23a			jsr 	IF_SetupKeyAddress 			; point to keyboard
.a1f5	e6 08		inc $08				inc 	IF_FarPtr 					; point to modifiers.
.a1f7	ea		nop				nop 								; read modifiers.
.a1f8	b2 08		lda ($08),z			lda 	(IF_FarPtr),z
.a1fa	fb		plz				plz 								; restore Z
.a1fb	29 05		and #$05			and 	#5							; break is LeftShift+Ctrl
.a1fd	c9 05		cmp #$05			cmp 	#5
.a1ff	f0 02		beq $a203			beq 	_IF_CBExit
.a201	a9 00		lda #$00			lda 	#0
.a203					_IF_CBExit:
.a203	c9 00		cmp #$00			cmp 	#0
.a205	60		rts				rts
.a206					IF_GetKey:
.a206	db		phz				phz
.a207	20 3a a2	jsr $a23a			jsr 	IF_SetupKeyAddress
.a20a	ea		nop				nop 								; read keyboard
.a20b	b2 08		lda ($08),z			lda 	(IF_FarPtr),z
.a20d	c9 14		cmp #$14			cmp 	#20
.a20f	d0 02		bne $a213			bne 	_KMNo
.a211	a9 08		lda #$08			lda 	#"H"-64
.a213					_KMNo:
.a213	c9 91		cmp #$91			cmp 	#145
.a215	d0 02		bne $a219			bne 	_KMNo
.a217	a9 17		lda #$17			lda 	#"W"-64
.a219					_KMNo:
.a219	c9 11		cmp #$11			cmp 	#17
.a21b	d0 02		bne $a21f			bne 	_KMNo
.a21d	a9 13		lda #$13			lda 	#"S"-64
.a21f					_KMNo:
.a21f	c9 9d		cmp #$9d			cmp 	#157
.a221	d0 02		bne $a225			bne 	_KMNo
.a223	a9 01		lda #$01			lda 	#"A"-64
.a225					_KMNo:
.a225	c9 1d		cmp #$1d			cmp 	#29
.a227	d0 02		bne $a22b			bne 	_KMNo
.a229	a9 04		lda #$04			lda 	#"D"-64
.a22b					_KMNo:
.a22b	c9 00		cmp #$00			cmp 	#0
.a22d	f0 07		beq $a236			beq 	_IFGKEmpty
.a22f	48		pha				pha
.a230	a9 00		lda #$00			lda 	#0
.a232	ea		nop				nop
.a233	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a235	68		pla				pla
.a236					_IFGKEmpty:
.a236	fb		plz				plz
.a237	c9 00		cmp #$00			cmp 	#0 							; set Z
.a239	60		rts				rts
.a23a					IF_SetupKeyAddress:
.a23a	a9 0f		lda #$0f			lda 	#$0F 						; set up to write to read keyboard.
.a23c	85 0b		sta $0b				sta 	IF_FarPtr+3
.a23e	a9 fd		lda #$fd			lda 	#$FD
.a240	85 0a		sta $0a				sta 	IF_FarPtr+2
.a242	a9 36		lda #$36			lda 	#$36
.a244	85 09		sta $09				sta 	IF_FarPtr+1
.a246	a9 10		lda #$10			lda 	#$10
.a248	85 08		sta $08				sta 	IF_FarPtr+0
.a24a	a3 00		ldz #$00			ldz 	#0
.a24c	60		rts				rts
.a24d					IF_Reset:
.a24d	48		pha				pha 								; save registers
.a24e	da		phx				phx
.a24f	5a		phy				phy
.a250	a9 0f		lda #$0f			lda 	#$0F 						; set up to write to video system.
.a252	85 0b		sta $0b				sta 	IF_FarPtr+3
.a254	a9 fd		lda #$fd			lda 	#$FD
.a256	85 0a		sta $0a				sta 	IF_FarPtr+2
.a258	a9 30		lda #$30			lda 	#$30
.a25a	85 09		sta $09				sta 	IF_FarPtr+1
.a25c	a9 00		lda #$00			lda 	#$00
.a25e	85 08		sta $08				sta 	IF_FarPtr+0
.a260	a3 2f		ldz #$2f			ldz 	#$2F 						; address already set up
.a262	a9 47		lda #$47			lda 	#$47
.a264	ea		nop				nop
.a265	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a267	a3 2f		ldz #$2f			ldz 	#$2F 						; address already set up
.a269	a9 53		lda #$53			lda 	#$53
.a26b	ea		nop				nop
.a26c	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a26e	a3 30		ldz #$30			ldz 	#$30 						; address already set up
.a270	a9 40		lda #$40			lda 	#$40
.a272	ea		nop				nop
.a273	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a275	a3 31		ldz #$31			ldz 	#$31 						; address already set up
.a277	a9 c0		lda #$c0			lda 	#$80+$40
.a279	ea		nop				nop
.a27a	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a27c	a3 20		ldz #$20			ldz 	#$20 						; address already set up
.a27e	a9 00		lda #$00			lda 	#0
.a280	ea		nop				nop
.a281	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a283	a3 21		ldz #$21			ldz 	#$21 						; address already set up
.a285	a9 00		lda #$00			lda 	#0
.a287	ea		nop				nop
.a288	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a28a	a3 54		ldz #$54			ldz 	#$54 						; address already set up
.a28c	a9 40		lda #$40			lda 	#$40
.a28e	ea		nop				nop
.a28f	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a291	a3 01		ldz #$01			ldz 	#$01 						; address already set up
.a293	a9 ff		lda #$ff			lda 	#$FF
.a295	ea		nop				nop
.a296	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a298	a3 00		ldz #$00			ldz 	#$00 						; address already set up
.a29a	a9 ff		lda #$ff			lda 	#$FF
.a29c	ea		nop				nop
.a29d	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a29f	a3 16		ldz #$16			ldz 	#$16 						; address already set up
.a2a1	a9 cc		lda #$cc			lda 	#$CC
.a2a3	ea		nop				nop
.a2a4	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2a6	a3 18		ldz #$18			ldz 	#$18 						; address already set up
.a2a8	a9 42		lda #$42			lda 	#$42
.a2aa	ea		nop				nop
.a2ab	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2ad	a3 11		ldz #$11			ldz 	#$11 						; address already set up
.a2af	a9 1b		lda #$1b			lda 	#$1B
.a2b1	ea		nop				nop
.a2b2	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2b4	a9 00		lda #$00			lda 	#$00						; colour RAM at $1F800-1FFFF (2kb)
.a2b6	85 0b		sta $0b				sta 	IF_FarPtr+3
.a2b8	a9 01		lda #$01			lda 	#$01
.a2ba	85 0a		sta $0a				sta 	IF_FarPtr+2
.a2bc	a9 f8		lda #$f8			lda 	#$F8
.a2be	85 09		sta $09				sta 	IF_FarPtr+1
.a2c0	a9 00		lda #$00			lda 	#$00
.a2c2	85 08		sta $08				sta 	IF_FarPtr+0
.a2c4	a3 00		ldz #$00			ldz 	#0
.a2c6					_EXTClearColorRam:
.a2c6	a9 05		lda #$05			lda 	#5							; fill that with this colour.
.a2c8	ea		nop				nop
.a2c9	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2cb	3b		dez				dez
.a2cc	d0 f8		bne $a2c6			bne 	_EXTClearColorRam
.a2ce	e6 09		inc $09				inc 	IF_FarPtr+1
.a2d0	d0 f4		bne $a2c6			bne 	_EXTClearColorRam
.a2d2	a2 00		ldx #$00			ldx 	#0 							; copy PET Font into memory.
.a2d4					_EXTCopyCBMFont:
.a2d4	bd 15 a3	lda $a315,x			lda 	IF_CBMFont,x 				; +$800 uses the lower case c/set
.a2d7	9d 00 08	sta $0800,x			sta 	IF_CharSet,x
.a2da	49 ff		eor #$ff			eor 	#$FF
.a2dc	9d 00 0c	sta $0c00,x			sta 	IF_CharSet+$400,x
.a2df	bd 15 a4	lda $a415,x			lda 	IF_CBMFont+$100,x
.a2e2	9d 00 09	sta $0900,x			sta 	IF_CharSet+$100,x
.a2e5	49 ff		eor #$ff			eor 	#$FF
.a2e7	9d 00 0d	sta $0d00,x			sta 	IF_CharSet+$500,x
.a2ea	bd 15 a5	lda $a515,x			lda 	IF_CBMFont+$200,x
.a2ed	9d 00 0a	sta $0a00,x			sta 	IF_CharSet+$200,x
.a2f0	49 ff		eor #$ff			eor 	#$FF
.a2f2	9d 00 0e	sta $0e00,x			sta 	IF_CharSet+$600,x
.a2f5	bd 15 a6	lda $a615,x			lda 	IF_CBMFont+$300,x
.a2f8	9d 00 0b	sta $0b00,x			sta 	IF_CharSet+$300,x
.a2fb	49 ff		eor #$ff			eor 	#$FF
.a2fd	9d 00 0f	sta $0f00,x			sta 	IF_CharSet+$700,x
.a300	ca		dex				dex
.a301	d0 d1		bne $a2d4			bne 	_EXTCopyCBMFont
.a303	a9 3b		lda #$3b			lda 	#$3F-4  					; puts ROM back in the map (the -4)
.a305	85 01		sta $01				sta 	$01
.a307	a9 00		lda #$00			lda 	#$00						; do not map bytes 0000-7FFF
.a309	a2 00		ldx #$00			ldx 	#$00						; (so we use the RAM physically at $0000-$7FFF)
.a30b	a0 00		ldy #$00			ldy 	#$00 						; 8000-FFFF offset by $200. The lower 8 bits are $00
.a30d	a3 f2		ldz #$f2			ldz 	#$F2 						; so this is an actual offset of $20000. So the space at
.a30f	5c		map				map
.a310	ea		nop				eom
.a311	7a		ply				ply 								; restore and exit.
.a312	fa		plx				plx
.a313	68		pla				pla
.a314	60		rts				rts
.a315					IF_CBMFont:
>a315	1c 22 4a 56 4c 20 1e 00				.binary "pet-font.bin"
>a31d	18 24 42 7e 42 42 42 00 7c 22 22 3c 22 22 7c 00
>a32d	1c 22 40 40 40 22 1c 00 78 24 22 22 22 24 78 00
>a33d	7e 40 40 78 40 40 7e 00 7e 40 40 78 40 40 40 00
>a34d	1c 22 40 4e 42 22 1c 00 42 42 42 7e 42 42 42 00
>a35d	1c 08 08 08 08 08 1c 00 0e 04 04 04 04 44 38 00
>a36d	42 44 48 70 48 44 42 00 40 40 40 40 40 40 7e 00
>a37d	42 66 5a 5a 42 42 42 00 42 62 52 4a 46 42 42 00
>a38d	18 24 42 42 42 24 18 00 7c 42 42 7c 40 40 40 00
>a39d	18 24 42 42 4a 24 1a 00 7c 42 42 7c 48 44 42 00
>a3ad	3c 42 40 3c 02 42 3c 00 3e 08 08 08 08 08 08 00
>a3bd	42 42 42 42 42 42 3c 00 42 42 42 24 24 18 18 00
>a3cd	42 42 42 5a 5a 66 42 00 42 42 24 18 24 42 42 00
>a3dd	22 22 22 1c 08 08 08 00 7e 02 04 18 20 40 7e 00
>a3ed	3c 20 20 20 20 20 3c 00 00 40 20 10 08 04 02 00
>a3fd	3c 04 04 04 04 04 3c 00 00 08 1c 2a 08 08 08 08
>a40d	00 00 10 20 7f 20 10 00 00 00 00 00 00 00 00 00
>a41d	08 08 08 08 00 00 08 00 24 24 24 00 00 00 00 00
>a42d	24 24 7e 24 7e 24 24 00 08 1e 28 1c 0a 3c 08 00
>a43d	00 62 64 08 10 26 46 00 30 48 48 30 4a 44 3a 00
>a44d	04 08 10 00 00 00 00 00 04 08 10 10 10 08 04 00
>a45d	20 10 08 08 08 10 20 00 08 2a 1c 3e 1c 2a 08 00
>a46d	00 08 08 3e 08 08 00 00 00 00 00 00 00 08 08 10
>a47d	00 00 00 7e 00 00 00 00 00 00 00 00 00 18 18 00
>a48d	00 02 04 08 10 20 40 00 3c 42 46 5a 62 42 3c 00
>a49d	08 18 28 08 08 08 3e 00 3c 42 02 0c 30 40 7e 00
>a4ad	3c 42 02 1c 02 42 3c 00 04 0c 14 24 7e 04 04 00
>a4bd	7e 40 78 04 02 44 38 00 1c 20 40 7c 42 42 3c 00
>a4cd	7e 42 04 08 10 10 10 00 3c 42 42 3c 42 42 3c 00
>a4dd	3c 42 42 3e 02 04 38 00 00 00 08 00 00 08 00 00
>a4ed	00 00 08 00 00 08 08 10 0e 18 30 60 30 18 0e 00
>a4fd	00 00 7e 00 7e 00 00 00 70 18 0c 06 0c 18 70 00
>a50d	3c 42 02 0c 10 00 10 00 00 00 00 00 ff 00 00 00
>a51d	08 1c 3e 7f 7f 1c 3e 00 10 10 10 10 10 10 10 10
>a52d	00 00 00 ff 00 00 00 00 00 00 ff 00 00 00 00 00
>a53d	00 ff 00 00 00 00 00 00 00 00 00 00 00 ff 00 00
>a54d	20 20 20 20 20 20 20 20 04 04 04 04 04 04 04 04
>a55d	00 00 00 00 e0 10 08 08 08 08 08 04 03 00 00 00
>a56d	08 08 08 10 e0 00 00 00 80 80 80 80 80 80 80 ff
>a57d	80 40 20 10 08 04 02 01 01 02 04 08 10 20 40 80
>a58d	ff 80 80 80 80 80 80 80 ff 01 01 01 01 01 01 01
>a59d	00 3c 7e 7e 7e 7e 3c 00 00 00 00 00 00 00 ff 00
>a5ad	36 7f 7f 7f 3e 1c 08 00 40 40 40 40 40 40 40 40
>a5bd	00 00 00 00 03 04 08 08 81 42 24 18 18 24 42 81
>a5cd	00 3c 42 42 42 42 3c 00 08 1c 2a 77 2a 08 08 00
>a5dd	02 02 02 02 02 02 02 02 08 1c 3e 7f 3e 1c 08 00
>a5ed	08 08 08 08 ff 08 08 08 a0 50 a0 50 a0 50 a0 50
>a5fd	08 08 08 08 08 08 08 08 00 00 01 3e 54 14 14 00
>a60d	ff 7f 3f 1f 0f 07 03 01 00 00 00 00 00 00 00 00
>a61d	f0 f0 f0 f0 f0 f0 f0 f0 00 00 00 00 ff ff ff ff
>a62d	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff
>a63d	80 80 80 80 80 80 80 80 aa 55 aa 55 aa 55 aa 55
>a64d	01 01 01 01 01 01 01 01 00 00 00 00 aa 55 aa 55
>a65d	ff fe fc f8 f0 e0 c0 80 03 03 03 03 03 03 03 03
>a66d	08 08 08 08 0f 08 08 08 00 00 00 00 0f 0f 0f 0f
>a67d	08 08 08 08 0f 00 00 00 00 00 00 00 f8 08 08 08
>a68d	00 00 00 00 00 00 ff ff 00 00 00 00 0f 08 08 08
>a69d	08 08 08 08 ff 00 00 00 00 00 00 00 ff 08 08 08
>a6ad	08 08 08 08 f8 08 08 08 c0 c0 c0 c0 c0 c0 c0 c0
>a6bd	e0 e0 e0 e0 e0 e0 e0 e0 07 07 07 07 07 07 07 07
>a6cd	ff ff 00 00 00 00 00 00 ff ff ff 00 00 00 00 00
>a6dd	00 00 00 00 00 ff ff ff 01 01 01 01 01 01 01 ff
>a6ed	00 00 00 00 f0 f0 f0 f0 0f 0f 0f 0f 00 00 00 00
>a6fd	08 08 08 08 f8 00 00 00 f0 f0 f0 f0 00 00 00 00
>a70d	f0 f0 f0 f0 0f 0f 0f 0f 1c 22 4a 56 4c 20 1e 00
>a71d	18 24 42 7e 42 42 42 00 7c 22 22 3c 22 22 7c 00
>a72d	1c 22 40 40 40 22 1c 00 78 24 22 22 22 24 78 00
>a73d	7e 40 40 78 40 40 7e 00 7e 40 40 78 40 40 40 00
>a74d	1c 22 40 4e 42 22 1c 00 42 42 42 7e 42 42 42 00
>a75d	1c 08 08 08 08 08 1c 00 0e 04 04 04 04 44 38 00
>a76d	42 44 48 70 48 44 42 00 40 40 40 40 40 40 7e 00
>a77d	42 66 5a 5a 42 42 42 00 42 62 52 4a 46 42 42 00
>a78d	18 24 42 42 42 24 18 00 7c 42 42 7c 40 40 40 00
>a79d	18 24 42 42 4a 24 1a 00 7c 42 42 7c 48 44 42 00
>a7ad	3c 42 40 3c 02 42 3c 00 3e 08 08 08 08 08 08 00
>a7bd	42 42 42 42 42 42 3c 00 42 42 42 24 24 18 18 00
>a7cd	42 42 42 5a 5a 66 42 00 42 42 24 18 24 42 42 00
>a7dd	22 22 22 1c 08 08 08 00 7e 02 04 18 20 40 7e 00
>a7ed	3c 20 20 20 20 20 3c 00 00 40 20 10 08 04 02 00
>a7fd	3c 04 04 04 04 04 3c 00 00 08 1c 2a 08 08 08 08
>a80d	00 00 10 20 7f 20 10 00 00 00 00 00 00 00 00 00
>a81d	08 08 08 08 00 00 08 00 24 24 24 00 00 00 00 00
>a82d	24 24 7e 24 7e 24 24 00 08 1e 28 1c 0a 3c 08 00
>a83d	00 62 64 08 10 26 46 00 30 48 48 30 4a 44 3a 00
>a84d	04 08 10 00 00 00 00 00 04 08 10 10 10 08 04 00
>a85d	20 10 08 08 08 10 20 00 08 2a 1c 3e 1c 2a 08 00
>a86d	00 08 08 3e 08 08 00 00 00 00 00 00 00 08 08 10
>a87d	00 00 00 7e 00 00 00 00 00 00 00 00 00 18 18 00
>a88d	00 02 04 08 10 20 40 00 3c 42 46 5a 62 42 3c 00
>a89d	08 18 28 08 08 08 3e 00 3c 42 02 0c 30 40 7e 00
>a8ad	3c 42 02 1c 02 42 3c 00 04 0c 14 24 7e 04 04 00
>a8bd	7e 40 78 04 02 44 38 00 1c 20 40 7c 42 42 3c 00
>a8cd	7e 42 04 08 10 10 10 00 3c 42 42 3c 42 42 3c 00
>a8dd	3c 42 42 3e 02 04 38 00 00 00 08 00 00 08 00 00
>a8ed	00 00 08 00 00 08 08 10 0e 18 30 60 30 18 0e 00
>a8fd	00 00 7e 00 7e 00 00 00 70 18 0c 06 0c 18 70 00
>a90d	3c 42 02 0c 10 00 10 00 00 00 00 00 ff 00 00 00
>a91d	00 00 38 04 3c 44 3a 00 40 40 5c 62 42 62 5c 00
>a92d	00 00 3c 42 40 42 3c 00 02 02 3a 46 42 46 3a 00
>a93d	00 00 3c 42 7e 40 3c 00 0c 12 10 7c 10 10 10 00
>a94d	00 00 3a 46 46 3a 02 3c 40 40 5c 62 42 42 42 00
>a95d	08 00 18 08 08 08 1c 00 04 00 0c 04 04 04 44 38
>a96d	40 40 44 48 50 68 44 00 18 08 08 08 08 08 1c 00
>a97d	00 00 76 49 49 49 49 00 00 00 5c 62 42 42 42 00
>a98d	00 00 3c 42 42 42 3c 00 00 00 5c 62 62 5c 40 40
>a99d	00 00 3a 46 46 3a 02 02 00 00 5c 62 40 40 40 00
>a9ad	00 00 3e 40 3c 02 7c 00 10 10 7c 10 10 12 0c 00
>a9bd	00 00 42 42 42 46 3a 00 00 00 42 42 42 24 18 00
>a9cd	00 00 41 49 49 49 36 00 00 00 42 24 18 24 42 00
>a9dd	00 00 42 42 46 3a 02 3c 00 00 7e 04 18 20 7e 00
>a9ed	08 08 08 08 ff 08 08 08 a0 50 a0 50 a0 50 a0 50
>a9fd	08 08 08 08 08 08 08 08 cc cc 33 33 cc cc 33 33
>aa0d	cc 66 33 99 cc 66 33 99 00 00 00 00 00 00 00 00
>aa1d	f0 f0 f0 f0 f0 f0 f0 f0 00 00 00 00 ff ff ff ff
>aa2d	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff
>aa3d	80 80 80 80 80 80 80 80 aa 55 aa 55 aa 55 aa 55
>aa4d	01 01 01 01 01 01 01 01 00 00 00 00 aa 55 aa 55
>aa5d	99 33 66 cc 99 33 66 cc 03 03 03 03 03 03 03 03
>aa6d	08 08 08 08 0f 08 08 08 00 00 00 00 0f 0f 0f 0f
>aa7d	08 08 08 08 0f 00 00 00 00 00 00 00 f8 08 08 08
>aa8d	00 00 00 00 00 00 ff ff 00 00 00 00 0f 08 08 08
>aa9d	08 08 08 08 ff 00 00 00 00 00 00 00 ff 08 08 08
>aaad	08 08 08 08 f8 08 08 08 c0 c0 c0 c0 c0 c0 c0 c0
>aabd	e0 e0 e0 e0 e0 e0 e0 e0 07 07 07 07 07 07 07 07
>aacd	ff ff 00 00 00 00 00 00 ff ff ff 00 00 00 00 00
>aadd	00 00 00 00 00 ff ff ff 01 02 44 48 50 60 40 00
>aaed	00 00 00 00 f0 f0 f0 f0 0f 0f 0f 0f 00 00 00 00
>aafd	08 08 08 08 f8 00 00 00 f0 f0 f0 f0 00 00 00 00
>ab0d	f0 f0 f0 f0 0f 0f 0f 0f

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.ab15					TIM_Error:
.ab15	20 35 a0	jsr $a035			jsr 	IFT_UpLine 					; go up one line.
.ab18	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.ab1a	80 02		bra $ab1e			bra 	TIM_ShowPrompt
.ab1c					TIM_NewCommand:
.ab1c	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.ab1e					TIM_ShowPrompt:
.ab1e	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.ab21	20 06 a1	jsr $a106			jsr 	IFT_ReadLine	 			; get character, go to next line
.ab24	20 68 a0	jsr $a068			jsr 	IFT_NewLine					; go to next line.
.ab27	86 10		stx $10				stx 	zTemp1 						; save line read address
.ab29	84 11		sty $11				sty 	zTemp1+1
.ab2b	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.ab2d	b1 10		lda ($10),y			lda 	(zTemp1),y
.ab2f	c9 3f		cmp #$3f			cmp 	#"?"
.ab31	f0 04		beq $ab37			beq 	TIM_SkipFirst
.ab33	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.ab35	d0 01		bne $ab38			bne 	TIM_NotDot
.ab37					TIM_SkipFirst:
.ab37	c8		iny				iny
.ab38					TIM_NotDot:
.ab38	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.ab3a	c9 52		cmp #$52			cmp 	#"R"						; show registers
.ab3c	f0 6e		beq $abac			beq 	TIM_ShowRegisters
.ab3e	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.ab40	f0 12		beq $ab54			beq 	TIM_ShowMemory
.ab42	c9 47		cmp #$47			cmp 	#"G"						; execute
.ab44	f0 49		beq $ab8f			beq 	TIM_Execute
.ab46	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.ab48	f0 07		beq $ab51			beq 	TIM_GoLoadMemory
.ab4a	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.ab4c	d0 c7		bne $ab15			bne 	TIM_Error
.ab4e	4c d1 ac	jmp $acd1			jmp 	TIM_UpdateRegisters
.ab51					TIM_GoLoadMemory:
.ab51	4c fc ac	jmp $acfc			jmp 	TIM_LoadMemory
.ab54					TIM_ShowMemory:
.ab54	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.ab57	b0 bc		bcs $ab15			bcs 	TIM_Error
.ab59	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.ab5b	85 12		sta $12				sta 	zTemp2
.ab5d	a5 15		lda $15				lda 	zTemp3+1
.ab5f	85 13		sta $13				sta 	zTemp2+1
.ab61	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.ab64	90 08		bcc $ab6e			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.ab66	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.ab68	85 14		sta $14				sta 	zTemp3
.ab6a	a5 13		lda $13				lda 	zTemp2+1
.ab6c	85 15		sta $15				sta 	zTemp3+1
.ab6e					_TIMSM_Start:
.ab6e	20 22 ac	jsr $ac22			jsr 	TIM_WriteLine 				; write one line of hex out
.ab71	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.ab73	18		clc				clc
.ab74	69 10		adc #$10			adc 	#16
.ab76	85 12		sta $12				sta 	zTemp2
.ab78	90 02		bcc $ab7c			bcc 	_TIMSM_NoCarry
.ab7a	e6 13		inc $13				inc 	zTemp2+1
.ab7c					_TIMSM_NoCarry:
.ab7c	20 f1 a1	jsr $a1f1			jsr 	IF_CheckBreak 				; check CTL+C
.ab7f	d0 0b		bne $ab8c			bne 	_TIMSM_Ends 				; if pressed break out.
.ab81	38		sec				sec 								; check past the end address in zTemp3
.ab82	a5 14		lda $14				lda 	zTemp3
.ab84	e5 12		sbc $12				sbc 	zTemp2
.ab86	a5 15		lda $15				lda 	zTemp3+1
.ab88	e5 13		sbc $13				sbc 	zTemp2+1
.ab8a	10 e2		bpl $ab6e			bpl 	_TIMSM_Start
.ab8c					_TIMSM_Ends:
.ab8c	4c 1c ab	jmp $ab1c			jmp 	TIM_NewCommand
.ab8f					TIM_Execute:
.ab8f	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; get the execute address
.ab92	b0 81		bcs $ab15			bcs 	TIM_Error 					; not legitimate
.ab94	ae b1 04	ldx $04b1			ldx 	TIM_SP 						; set up SP
.ab97	9a		txs				txs
.ab98	ad ac 04	lda $04ac			lda 	TIM_SR 						; Status for PLP
.ab9b	48		pha				pha
.ab9c	ad ad 04	lda $04ad			lda 	TIM_A 						; restore AXYZ
.ab9f	ae ae 04	ldx $04ae			ldx 	TIM_X
.aba2	ac af 04	ldy $04af			ldy 	TIM_Y
.aba5	ab b0 04	ldz $04b0			ldz 	TIM_Z
.aba8	28		plp				plp 								; and PS Byte.
.aba9	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.abac					TIM_Start:
.abac					TIM_ShowRegisters:
.abac	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.abaf	8d ab 04	sta $04ab			sta 	TIM_IRQ+1
.abb2	ad ff ff	lda $ffff			lda 	$FFFF
.abb5	8d aa 04	sta $04aa			sta 	TIM_IRQ
.abb8	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.abba					_TIMSR_Text:
.abba	bd e6 ab	lda $abe6,x			lda 	_TIMSR_Label,x
.abbd	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.abc0	e8		inx				inx
.abc1	e0 23		cpx #$23			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.abc3	d0 f5		bne $abba			bne 	_TIMSR_Text
.abc5	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.abc7					_TIMSR_Skip:
.abc7	e8		inx				inx
.abc8					_TIMSR_LoopSpace:
.abc8	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.abca	b0 04		bcs $abd0			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.abcc	8a		txa				txa
.abcd	4a		lsr a				lsr 	a
.abce	b0 05		bcs $abd5			bcs 	_TIMSR_NoSpace
.abd0					_TIMSR_Space:
.abd0	a9 20		lda #$20			lda 	#" "
.abd2	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.abd5					_TIMSR_NoSpace:
.abd5	bd a8 04	lda $04a8,x			lda 	TIM_PC,x 					; output hex value.
.abd8	20 09 ac	jsr $ac09			jsr 	TIM_WriteHex
.abdb	e8		inx				inx
.abdc	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.abde	d0 e8		bne $abc8			bne 	_TimSR_LoopSpace
.abe0	20 68 a0	jsr $a068			jsr 	IFT_NewLine 				; new line
.abe3	4c 1c ab	jmp $ab1c			jmp	 	TIM_NewCommand 				; new command.
.abe6					_TIMSR_Label:
>abe6	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>abee	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>abfe	52
>abff	20 5a 52					.text 	" ZR"
>ac02	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.ac09					_TIMSR_LabelEnd:
.ac09					TIM_WriteHex:
.ac09	48		pha				pha 								; save A
.ac0a	4a		lsr a				lsr 	a 							; shift MSB->LSB
.ac0b	4a		lsr a				lsr 	a
.ac0c	4a		lsr a				lsr 	a
.ac0d	4a		lsr a				lsr 	a
.ac0e	20 12 ac	jsr $ac12			jsr 	_TIMWH_Nibble 				; print MSB
.ac11	68		pla				pla 								; restore and print LSB
.ac12					_TIMWH_Nibble:
.ac12	48		pha				pha
.ac13	29 0f		and #$0f			and 	#15 						; mask out
.ac15	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.ac17	90 02		bcc $ac1b			bcc 	_TIMWHNoLetter
.ac19	69 06		adc #$06			adc 	#6
.ac1b					_TIMWHNoLetter:
.ac1b	69 30		adc #$30			adc 	#48
.ac1d	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter 			; print it out.
.ac20	68		pla				pla
.ac21	60		rts				rts
.ac22					TIM_WriteLine:
.ac22	a9 2e		lda #$2e			lda 	#"." 						; prompt
.ac24	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.ac27	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.ac29	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.ac2c	a5 13		lda $13				lda 	zTemp2+1 					; write address
.ac2e	20 09 ac	jsr $ac09			jsr 	TIM_WriteHex
.ac31	a5 12		lda $12				lda 	zTemp2
.ac33	20 09 ac	jsr $ac09			jsr 	TIM_WriteHex
.ac36	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.ac38					_TIMWL_Loop:
.ac38	a9 20		lda #$20			lda 	#" "
.ac3a	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.ac3d	b1 12		lda ($12),y			lda 	(zTemp2),y
.ac3f	20 09 ac	jsr $ac09			jsr 	TIM_WriteHex
.ac42	c8		iny				iny
.ac43	c0 10		cpy #$10			cpy 	#16
.ac45	d0 f1		bne $ac38			bne 	_TIMWL_Loop
.ac47	4c 68 a0	jmp $a068			jmp 	IFT_NewLine 				; new line and exit
.ac4a					TIM_GetHex:
.ac4a	c8		iny				iny
.ac4b	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.ac4d	c9 20		cmp #$20			cmp 	#32
.ac4f	f0 f9		beq $ac4a			beq 	TIM_GetHex
.ac51	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.ac53	f0 f5		beq $ac4a			beq 	TIM_GetHex
.ac55	20 7e ac	jsr $ac7e			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.ac58	b0 23		bcs $ac7d			bcs 	_TIMGH_Exit					; if first bad then exit now.
.ac5a	a9 00		lda #$00			lda 	#0 							; zero result
.ac5c	85 14		sta $14				sta 	zTemp3
.ac5e	85 15		sta $15				sta 	zTemp3+1
.ac60					_TIM_GHLoop:
.ac60	20 7e ac	jsr $ac7e			jsr 	TIM_GetHexCharacter 		; get next character
.ac63	b0 17		bcs $ac7c			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.ac65	c8		iny				iny 								; skip over it.
.ac66	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.ac68	26 15		rol $15				rol 	zTemp3+1
.ac6a	06 14		asl $14				asl 	zTemp3 						; now x 2
.ac6c	26 15		rol $15				rol 	zTemp3+1
.ac6e	06 14		asl $14				asl 	zTemp3						; now x 4
.ac70	26 15		rol $15				rol 	zTemp3+1
.ac72	06 14		asl $14				asl 	zTemp3 						; now x 8
.ac74	26 15		rol $15				rol 	zTemp3+1
.ac76	05 14		ora $14				ora 	zTemp3 						; OR result in
.ac78	85 14		sta $14				sta 	zTemp3
.ac7a	80 e4		bra $ac60			bra 	_TIM_GHLoop 				; loop round again.
.ac7c					_TIMGH_Okay:
.ac7c	18		clc				clc
.ac7d					_TIMGH_Exit:
.ac7d	60		rts				rts
.ac7e					TIM_GetHexCharacter:
.ac7e	b1 10		lda ($10),y			lda 	(zTemp1),y
.ac80	38		sec				sec
.ac81	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.ac83	90 0e		bcc $ac93			bcc 	_TIM_GHCFail
.ac85	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.ac87	90 0b		bcc $ac94			bcc 	_TIM_GHCExit
.ac89	c9 11		cmp #$11			cmp 	#65-48						; < A
.ac8b	90 06		bcc $ac93			bcc		_TIM_GHCFail
.ac8d	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.ac8f	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.ac91	90 01		bcc $ac94			bcc		_TIM_GHCExit
.ac93					_TIM_GHCFail:
.ac93	38		sec				sec
.ac94					_TIM_GHCExit:
.ac94	60		rts				rts
.ac95					TIM_BreakVector:
.ac95	da		phx				phx									; save X/A on stack
.ac96	48		pha				pha
.ac97	ba		tsx				tsx 								; X points to S
.ac98	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.ac9b	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.ac9d	d0 03		bne $aca2			bne 	_TIMBreak					; if set, it's BRK
.ac9f	68		pla				pla 								; abandon routine.
.aca0	fa		plx				plx
.aca1	40		rti				rti
.aca2					_TIMBreak:
.aca2	68		pla				pla 								; save A X Y and maybe Z
.aca3	8d ad 04	sta $04ad			sta 	TIM_A
.aca6	fa		plx				plx
.aca7	8e ae 04	stx $04ae			stx 	TIM_X
.acaa	8c af 04	sty $04af			sty 	TIM_Y
.acad	9c b0 04	stz $04b0			stz 	TIM_Z
.acb0	68		pla				pla 								; get Status Register
.acb1	8d ac 04	sta $04ac			sta 	TIM_SR
.acb4	68		pla				pla
.acb5	8d a9 04	sta $04a9			sta 	TIM_PC+1 					; save calling address
.acb8	68		pla				pla
.acb9	8d a8 04	sta $04a8			sta 	TIM_PC 						; high byte
.acbc	ad a9 04	lda $04a9			lda 	TIM_PC+1 					; dec PC to point right.
.acbf	d0 03		bne $acc4			bne 	_TIMDecrement 				; brk bumps it.
.acc1	ce a8 04	dec $04a8			dec 	TIM_PC
.acc4					_TIMDecrement:
.acc4	ce a9 04	dec $04a9			dec 	TIM_PC+1
.acc7	ba		tsx				tsx 								; and copy SP
.acc8	8e b1 04	stx $04b1			stx 	TIM_SP
.accb	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.accd	9a		txs				txs
.acce	4c ac ab	jmp $abac			jmp 	TIM_Start 					; and start up TIM monitor.
.acd1					TIM_UpdateRegisters:
.acd1	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; PC
.acd4	b0 23		bcs $acf9			bcs 	_TIMURFail
.acd6	a5 14		lda $14				lda 	zTemp3
.acd8	8d a9 04	sta $04a9			sta 	Tim_PC+1
.acdb	a5 15		lda $15				lda 	zTemp3+1
.acdd	8d a8 04	sta $04a8			sta 	Tim_PC
.ace0	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; ignore IRQ
.ace3	b0 14		bcs $acf9			bcs 	_TIMURFail
.ace5	a2 00		ldx #$00			ldx 	#0
.ace7					_TIM_URLoop:
.ace7	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; registers
.acea	b0 0d		bcs $acf9			bcs 	_TIMURFail
.acec	a5 14		lda $14				lda 	zTemp3
.acee	9d ac 04	sta $04ac,x			sta 	Tim_SR,x
.acf1	e8		inx				inx
.acf2	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.acf4	d0 f1		bne $ace7			bne 	_TIM_URLoop
.acf6	4c 1c ab	jmp $ab1c			jmp 	TIM_NewCommand
.acf9					_TIMURFail:
.acf9	4c 15 ab	jmp $ab15			jmp 	TIM_Error
.acfc					TIM_LoadMemory:
.acfc	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; target address => zTemp2
.acff	a5 14		lda $14				lda 	zTemp3
.ad01	85 12		sta $12				sta 	zTemp2
.ad03	a5 15		lda $15				lda 	zTemp3+1
.ad05	85 13		sta $13				sta 	zTemp2+1
.ad07					_TIM_LMLoop:
.ad07	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; next byte ?
.ad0a	b0 0e		bcs $ad1a			bcs 	_TIMLMDone 					; no more
.ad0c	a2 00		ldx #$00			ldx 	#0							; write out.
.ad0e	a5 14		lda $14				lda 	zTemp3
.ad10	81 12		sta ($12,x)			sta 	(zTemp2,x)
.ad12	e6 12		inc $12				inc 	zTemp2 						; bump address
.ad14	d0 f1		bne $ad07			bne 	_TIM_LMLoop
.ad16	e6 13		inc $13				inc 	zTemp2+1
.ad18	80 ed		bra $ad07			bra 	_TIM_LMLoop
.ad1a					_TIMLMDone:
.ad1a	4c 1c ab	jmp $ab1c			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/errors.asm

.ad1d					SyntaxError:
.ad1d	20 4c ad	jsr $ad4c			jsr 	ERR_Handler
>ad20	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>ad28	72 72 6f 72 00
.ad2d					TypeError:
.ad2d	20 4c ad	jsr $ad4c			jsr 	ERR_Handler
>ad30	57 72 6f 6e 67 20 74 79				.text 	"Wrong type",0
>ad38	70 65 00
.ad3b					BadParamError:
.ad3b	20 4c ad	jsr $ad4c			jsr 	ERR_Handler
>ad3e	42 61 64 20 50 61 72 61				.text 	"Bad Parameter",0
>ad46	6d 65 74 65 72 00
.ad4c					ERR_Handler:
.ad4c	a3 00		ldz #$00			ldz 	#0
.ad4e	1b		inz				inz
.ad4f	ea		nop				nop
.ad50	b2 16		lda ($16),z			lda 	(zCodePtr),z
.ad52	8d 08 03	sta $0308			sta 	XS_Mantissa
.ad55	1b		inz				inz
.ad56	ea		nop				nop
.ad57	b2 16		lda ($16),z			lda 	(zCodePtr),z
.ad59	8d 09 03	sta $0309			sta 	XS_Mantissa+1
.ad5c	fa		plx				plx 								; address in XY
.ad5d	7a		ply				ply
.ad5e	e8		inx				inx 								; bump, because of RTS/JSR address -1
.ad5f	d0 01		bne $ad62			bne 	_EHNoSkip
.ad61	c8		iny				iny
.ad62					_EHNoSkip:
.ad62	20 83 ad	jsr $ad83			jsr 	PrintROMMessage 			; print message from ROM.
.ad65	ad 08 03	lda $0308			lda 	XS_Mantissa					; line number = 0
.ad68	0d 09 03	ora $0309			ora 	XS_Mantissa+1
.ad6b	f0 0c		beq $ad79			beq 	_EHNoLine
.ad6d	a2 7e		ldx #$7e			ldx 	#_EHAt & $FF 				; print " at "
.ad6f	a0 ad		ldy #$ad			ldy 	#(_EHAt >> 8) & $FF
.ad71	20 83 ad	jsr $ad83			jsr 	PrintROMMessage
.ad74	a2 00		ldx #$00			ldx 	#0 							; Print line number
.ad76	20 94 ad	jsr $ad94			jsr 	Print16BitInteger
.ad79					_EHNoLine:
.ad79	80 fe		bra $ad79			bra 	_EHNoLine
.ad7b	4c ef af	jmp $afef			jmp 	WarmStart
>ad7e	20 61 74 20 00			_EHAt:	.text 	" at ",0
.ad83					PrintROMMessage:
.ad83	86 1a		stx $1a				stx 	zLTemp1 					; save addres
.ad85	84 1b		sty $1b				sty 	zLTemp1+1
.ad87	a0 00		ldy #$00			ldy 	#0
.ad89					_PRMLoop:
.ad89	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.ad8b	f0 06		beq $ad93			beq		_PRMExit
.ad8d	c8		iny				iny
.ad8e	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.ad91	80 f6		bra $ad89			bra 	_PRMLoop
.ad93					_PRMExit:
.ad93	60		rts				rts
.ad94					Print16BitInteger:
.ad94	a9 00		lda #$00			lda 	#0 							; make 32 bit
.ad96	8d 0a 03	sta $030a			sta 	XS_Mantissa+2
.ad99	8d 0b 03	sta $030b			sta 	XS_Mantissa+3
.ad9c	8d 04 04	sta $0404			sta 	NumBufX 					; reset the conversion pointer
.ad9f	aa		tax				tax 								; convert bottom level.
.ada0	20 ed bf	jsr $bfed			jsr 	INTToString 				; make string
.ada3	a2 00		ldx #$00			ldx 	#0 							; print buffer
.ada5	bd 05 04	lda $0405,x	_P1Loop:lda 	Num_Buffer,x
.ada8	f0 06		beq $adb0			beq 	_P1Exit
.adaa	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.adad	e8		inx				inx
.adae	80 f5		bra $ada5			bra 	_P1Loop
.adb0	60		rts		_P1Exit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm


;******  Processing file: modules/basic/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b6					lastUnaryFunction = $b6
.adb1					VectorTable:
>adb1	ae b3					.word BinaryOp_And         & $FFFF ; $80 and
>adb3	d6 b3					.word BinaryOp_Or          & $FFFF ; $81 or
>adb5	fe b3					.word BinaryOp_Xor         & $FFFF ; $82 xor
>adb7	fe b3					.word BinaryOp_Eor         & $FFFF ; $83 eor
>adb9	42 b4					.word Binary_Equal         & $FFFF ; $84 =
>adbb	61 b4					.word Binary_NotEqual      & $FFFF ; $85 <>
>adbd	6a b4					.word Binary_Less          & $FFFF ; $86 <
>adbf	73 b4					.word Binary_LessEqual     & $FFFF ; $87 <=
>adc1	85 b4					.word Binary_Greater       & $FFFF ; $88 >
>adc3	7c b4					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>adc5	1a b5					.word BinaryOp_Add         & $FFFF ; $8a +
>adc7	3a b5					.word BinaryOp_Subtract    & $FFFF ; $8b -
>adc9	4d b5					.word BinaryOp_Multiply    & $FFFF ; $8c *
>adcb	60 b5					.word BinaryOp_Divide      & $FFFF ; $8d /
>adcd	6d ae					.word NotImplemented       & $FFFF ; $8e ^
>adcf	6d ae					.word NotImplemented       & $FFFF ; $8f if
>add1	6d ae					.word NotImplemented       & $FFFF ; $90 while
>add3	6d ae					.word NotImplemented       & $FFFF ; $91 repeat
>add5	6d ae					.word NotImplemented       & $FFFF ; $92 for
>add7	6d ae					.word NotImplemented       & $FFFF ; $93 then
>add9	6d ae					.word NotImplemented       & $FFFF ; $94 endif
>addb	6d ae					.word NotImplemented       & $FFFF ; $95 wend
>addd	6d ae					.word NotImplemented       & $FFFF ; $96 until
>addf	6d ae					.word NotImplemented       & $FFFF ; $97 next
>ade1	6d ae					.word NotImplemented       & $FFFF ; $98 not
>ade3	6d ae					.word NotImplemented       & $FFFF ; $99 fn(
>ade5	94 b6					.word Unary_Abs            & $FFFF ; $9a abs(
>ade7	eb b7					.word Unary_Asc            & $FFFF ; $9b asc(
>ade9	ce c7					.word Unary_Int            & $FFFF ; $9c int(
>adeb	b2 b6					.word Unary_Peek           & $FFFF ; $9d peek(
>aded	45 c7					.word Unary_Rnd            & $FFFF ; $9e rnd(
>adef	26 b7					.word Unary_Usr            & $FFFF ; $9f usr(
>adf1	2c b8					.word Unary_Left           & $FFFF ; $a0 left$(
>adf3	43 b8					.word Unary_Right          & $FFFF ; $a1 right$(
>adf5	11 b8					.word Unary_Mid            & $FFFF ; $a2 mid$(
>adf7	a5 b9					.word Unary_Spc            & $FFFF ; $a3 spc(
>adf9	b8 b7					.word Unary_Str            & $FFFF ; $a4 str$(
>adfb	47 b7					.word Unary_Val            & $FFFF ; $a5 val(
>adfd	02 b8					.word Unary_Len            & $FFFF ; $a6 len(
>adff	c1 b8					.word Unary_Hex            & $FFFF ; $a7 hex$(
>ae01	6d ae					.word NotImplemented       & $FFFF ; $a8 sin(
>ae03	6d ae					.word NotImplemented       & $FFFF ; $a9 cos(
>ae05	6d ae					.word NotImplemented       & $FFFF ; $aa tan(
>ae07	6d ae					.word NotImplemented       & $FFFF ; $ab atn(
>ae09	6d ae					.word NotImplemented       & $FFFF ; $ac exp(
>ae0b	6d ae					.word NotImplemented       & $FFFF ; $ad log(
>ae0d	6d ae					.word NotImplemented       & $FFFF ; $ae sqr(
>ae0f	1b b9					.word Unary_Dec            & $FFFF ; $af dec(
>ae11	b6 b6					.word Unary_Deek           & $FFFF ; $b0 deek(
>ae13	ba b6					.word Unary_Leek           & $FFFF ; $b1 leek(
>ae15	ee b6					.word Unary_Mod            & $FFFF ; $b2 mod(
>ae17	42 b6					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>ae19	83 b9					.word Unary_Chr            & $FFFF ; $b4 chr$(
>ae1b	6d ae					.word NotImplemented       & $FFFF ; $b5 pos(
>ae1d	6d ae					.word NotImplemented       & $FFFF ; $b6 tab(
>ae1f	6d ae					.word NotImplemented       & $FFFF ; $b7 $
>ae21	6d ae					.word NotImplemented       & $FFFF ; $b8 $(
>ae23	6d ae					.word NotImplemented       & $FFFF ; $b9 #
>ae25	6d ae					.word NotImplemented       & $FFFF ; $ba #(
>ae27	6d ae					.word NotImplemented       & $FFFF ; $bb %
>ae29	6d ae					.word NotImplemented       & $FFFF ; $bc %(
>ae2b	6d ae					.word NotImplemented       & $FFFF ; $bd (
>ae2d	6d ae					.word NotImplemented       & $FFFF ; $be )
>ae2f	6d ae					.word NotImplemented       & $FFFF ; $bf ,
>ae31	fc b0					.word Command_COLON        & $FFFF ; $c0 :
>ae33	6d ae					.word NotImplemented       & $FFFF ; $c1 ;
>ae35	6d ae					.word NotImplemented       & $FFFF ; $c2 def
>ae37	b4 b1					.word Command_CLR          & $FFFF ; $c3 clr
>ae39	c5 b1					.word Command_STOP         & $FFFF ; $c4 stop
>ae3b	6d ae					.word NotImplemented       & $FFFF ; $c5 data
>ae3d	6d ae					.word NotImplemented       & $FFFF ; $c6 read
>ae3f	f5 af					.word Command_DIM          & $FFFF ; $c7 dim
>ae41	6d ae					.word NotImplemented       & $FFFF ; $c8 to
>ae43	6d ae					.word NotImplemented       & $FFFF ; $c9 step
>ae45	6d ae					.word NotImplemented       & $FFFF ; $ca gosub
>ae47	6d ae					.word NotImplemented       & $FFFF ; $cb return
>ae49	6d ae					.word NotImplemented       & $FFFF ; $cc goto
>ae4b	1e b1					.word Command_END          & $FFFF ; $cd end
>ae4d	6d ae					.word NotImplemented       & $FFFF ; $ce input
>ae4f	fd b0					.word Command_LET          & $FFFF ; $cf let
>ae51	6d ae					.word NotImplemented       & $FFFF ; $d0 list
>ae53	6d ae					.word NotImplemented       & $FFFF ; $d1 new
>ae55	6d ae					.word NotImplemented       & $FFFF ; $d2 old
>ae57	6d ae					.word NotImplemented       & $FFFF ; $d3 on
>ae59	6d ae					.word NotImplemented       & $FFFF ; $d4 restore
>ae5b	6d ae					.word NotImplemented       & $FFFF ; $d5 poke
>ae5d	23 b1					.word Command_PRINT        & $FFFF ; $d6 print
>ae5f	7d b0					.word Command_RUN          & $FFFF ; $d7 run
>ae61	6d ae					.word NotImplemented       & $FFFF ; $d8 wait
>ae63	6d ae					.word NotImplemented       & $FFFF ; $d9 sys
>ae65	6d ae					.word NotImplemented       & $FFFF ; $da doke
>ae67	6d ae					.word NotImplemented       & $FFFF ; $db loke
>ae69	98 b1					.word Command_ASSERT       & $FFFF ; $dc assert
>ae6b	6d ae					.word NotImplemented       & $FFFF ; $dd get
.ae6d					NotImplemented:
.ae6d	20 4c ad	jsr $ad4c			jsr ERR_Handler
>ae70	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>ae78	65 6d 65 6e 74 65 64 00
.ae80					BinaryPrecedence:
>ae80	01					.byte 1    ; $80 and
>ae81	01					.byte 1    ; $81 or
>ae82	01					.byte 1    ; $82 xor
>ae83	01					.byte 1    ; $83 eor
>ae84	02					.byte 2    ; $84 =
>ae85	02					.byte 2    ; $85 <>
>ae86	02					.byte 2    ; $86 <
>ae87	02					.byte 2    ; $87 <=
>ae88	02					.byte 2    ; $88 >
>ae89	02					.byte 2    ; $89 >=
>ae8a	03					.byte 3    ; $8a +
>ae8b	03					.byte 3    ; $8b -
>ae8c	04					.byte 4    ; $8c *
>ae8d	04					.byte 4    ; $8d /
>ae8e	05					.byte 5    ; $8e ^
.ae8f					KeywordText:
>ae8f	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>ae92	4f d2					.byte $4f,$d2                          ; $81 or
>ae94	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>ae97	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>ae9a	bd					.byte $bd                              ; $84 =
>ae9b	3c be					.byte $3c,$be                          ; $85 <>
>ae9d	bc					.byte $bc                              ; $86 <
>ae9e	3c bd					.byte $3c,$bd                          ; $87 <=
>aea0	be					.byte $be                              ; $88 >
>aea1	3e bd					.byte $3e,$bd                          ; $89 >=
>aea3	ab					.byte $ab                              ; $8a +
>aea4	ad					.byte $ad                              ; $8b -
>aea5	aa					.byte $aa                              ; $8c *
>aea6	af					.byte $af                              ; $8d /
>aea7	de					.byte $de                              ; $8e ^
>aea8	49 c6					.byte $49,$c6                          ; $8f if
>aeaa	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>aeaf	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>aeb5	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>aeb8	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>aebc	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>aec1	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>aec5	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>aeca	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>aece	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>aed1	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>aed4	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>aed8	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>aedc	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>aee0	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>aee5	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>aee9	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>aeed	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>aef3	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>aefa	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>aeff	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>af03	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>af08	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>af0c	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>af10	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>af15	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>af19	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>af1d	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>af21	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>af25	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>af29	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>af2d	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>af31	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>af35	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>af3a	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>af3f	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>af43	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>af47	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>af4c	50 4f 53 a8				.byte $50,$4f,$53,$a8                  ; $b5 pos(
>af50	54 41 42 a8				.byte $54,$41,$42,$a8                  ; $b6 tab(
>af54	a4					.byte $a4                              ; $b7 $
>af55	24 a8					.byte $24,$a8                          ; $b8 $(
>af57	a3					.byte $a3                              ; $b9 #
>af58	23 a8					.byte $23,$a8                          ; $ba #(
>af5a	a5					.byte $a5                              ; $bb %
>af5b	25 a8					.byte $25,$a8                          ; $bc %(
>af5d	a8					.byte $a8                              ; $bd (
>af5e	a9					.byte $a9                              ; $be )
>af5f	ac					.byte $ac                              ; $bf ,
>af60	ba					.byte $ba                              ; $c0 :
>af61	bb					.byte $bb                              ; $c1 ;
>af62	44 45 c6				.byte $44,$45,$c6                      ; $c2 def
>af65	43 4c d2				.byte $43,$4c,$d2                      ; $c3 clr
>af68	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $c4 stop
>af6c	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c5 data
>af70	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c6 read
>af74	44 49 cd				.byte $44,$49,$cd                      ; $c7 dim
>af77	54 cf					.byte $54,$cf                          ; $c8 to
>af79	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c9 step
>af7d	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $ca gosub
>af82	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $cb return
>af88	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $cc goto
>af8c	45 4e c4				.byte $45,$4e,$c4                      ; $cd end
>af8f	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $ce input
>af94	4c 45 d4				.byte $4c,$45,$d4                      ; $cf let
>af97	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $d0 list
>af9b	4e 45 d7				.byte $4e,$45,$d7                      ; $d1 new
>af9e	4f 4c c4				.byte $4f,$4c,$c4                      ; $d2 old
>afa1	4f ce					.byte $4f,$ce                          ; $d3 on
>afa3	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d4 restore
>afaa	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d5 poke
>afae	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d6 print
>afb3	52 55 ce				.byte $52,$55,$ce                      ; $d7 run
>afb6	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d8 wait
>afba	53 59 d3				.byte $53,$59,$d3                      ; $d9 sys
>afbd	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $da doke
>afc1	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $db loke
>afc5	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $dc assert
>afcb	47 45 d4				.byte $47,$45,$d4                      ; $dd get
>afce	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_pos = $b5
=$b6					token_tab = $b6
=$b7					token_dollar = $b7
=$b8					token_dollarlparen = $b8
=$b9					token_hash = $b9
=$ba					token_hashlparen = $ba
=$bb					token_percent = $bb
=$bc					token_percentlparen = $bc
=$bd					token_lparen = $bd
=$be					token_rparen = $be
=$bf					token_comma = $bf
=$c0					token_colon = $c0
=$c1					token_semicolon = $c1
=$c2					token_def = $c2
=$c3					token_clr = $c3
=$c4					token_stop = $c4
=$c5					token_data = $c5
=$c6					token_read = $c6
=$c7					token_dim = $c7
=$c8					token_to = $c8
=$c9					token_step = $c9
=$ca					token_gosub = $ca
=$cb					token_return = $cb
=$cc					token_goto = $cc
=$cd					token_end = $cd
=$ce					token_input = $ce
=$cf					token_let = $cf
=$d0					token_list = $d0
=$d1					token_new = $d1
=$d2					token_old = $d2
=$d3					token_on = $d3
=$d4					token_restore = $d4
=$d5					token_poke = $d5
=$d6					token_print = $d6
=$d7					token_run = $d7
=$d8					token_wait = $d8
=$d9					token_sys = $d9
=$da					token_doke = $da
=$db					token_loke = $db
=$dc					token_assert = $dc
=$dd					token_get = $dd

;******  Return to file: modules/basic/core.asm

.afcf					BASIC_Start:
.afcf	20 4d a2	jsr $a24d			jsr 	IF_Reset 					; set up and clear screen.
.afd2	20 0c a0	jsr $a00c			jsr 	IFT_ClearScreen
.afd5	a9 4c		lda #$4c			lda 	#$4C 						; JMP opcode
.afd7	8d 04 03	sta $0304			sta 	LocalVector
.afda	8d 00 03	sta $0300			sta 	UserVector
.afdd	a9 35		lda #$35			lda 	#USRDefault & $FF 			; reset USR vector
.afdf	8d 01 03	sta $0301			sta 	UserVector+1
.afe2	a9 b7		lda #$b7			lda 	#(USRDefault >> 8) & $FF
.afe4	8d 02 03	sta $0302			sta 	UserVector+2
.afe7	a9 00		lda #$00			lda 	#(USRDefault >> 16) & $FF
.afe9	8d 03 03	sta $0303			sta 	UserVector+3
.afec	20 b4 b1	jsr $b1b4			jsr 	ResetRunStatus 				; clear everything (CLR command)
.afef					WarmStart:
.afef	a2 ff		ldx #$ff			ldx 		#$FF 					; empty stack
.aff1	9a		txs				txs
.aff2	4c 7d b0	jmp $b07d			jmp 	COMMAND_Run

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/dim.asm

.aff5					Command_DIM:
.aff5	5a		phy				phy 								; save Y which is the start of the name.
.aff6	20 24 bb	jsr $bb24			jsr 	VariableExtract 			; get the identifier
.aff9	ad 85 04	lda $0485			lda 	Var_Type 					; check it is an array
.affc	29 01		and #$01			and 	#1
.affe	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.b000	d0 6d		bne $b06f			bne 	_CDIError
.b002	a9 00		lda #$00			lda 	#0 							; reset the DIM index. The dimensions are
.b004	8d a7 04	sta $04a7			sta 	UsrArrayIdx 				; built up here and copied in case we autodim
.b007					_CDIGetDimension:
.b007	ad a7 04	lda $04a7			lda 	UsrArrayIdx 				; done too many ?
.b00a	c9 06		cmp #$06			cmp 	#ArrayMaxDim*2
.b00c	f0 61		beq $b06f			beq 	_CDIError
.b00e	20 d0 b1	jsr $b1d0			jsr 	EvaluateExpression 			; evaluate an index size
.b011	ad 09 03	lda $0309			lda 	XS_Mantissa+1 				; check in range 0-7FFF
.b014	29 80		and #$80			and 	#$80
.b016	0d 0a 03	ora $030a			ora 	XS_Mantissa+2
.b019	0d 0b 03	ora $030b			ora 	XS_Mantissa+3
.b01c	d0 51		bne $b06f			bne 	_CDIError
.b01e	ae a7 04	ldx $04a7			ldx 	UsrArrayIdx 				; copy into the array table.
.b021	18		clc				clc 								; add 1 - max index => size.
.b022	ad 08 03	lda $0308			lda 	XS_Mantissa+0
.b025	69 01		adc #$01			adc 	#1
.b027	9d 9f 04	sta $049f,x			sta 	UsrArrayDef+0,x
.b02a	ad 09 03	lda $0309			lda 	XS_Mantissa+1
.b02d	69 00		adc #$00			adc 	#0
.b02f	9d a0 04	sta $04a0,x			sta 	UsrArrayDef+1,x
.b032	30 3b		bmi $b06f			bmi 	_CDIError 					; could be dim a(32767)
.b034	e8		inx				inx 								; bump index.
.b035	e8		inx				inx
.b036	8e a7 04	stx $04a7			stx 	UsrArrayIdx
.b039	ea		nop				nop
.b03a	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b03c	1b		inz				inz
.b03d	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another dimension
.b03f	f0 c6		beq $b007			beq 	_CDIGetDimension
.b041	3b		dez				dez
.b042	20 11 ba	jsr $ba11			jsr 	CheckNextRParen 			; closing ) present ?
.b045	ae a7 04	ldx $04a7			ldx 	UsrArrayIdx 				; copy USR array to default
.b048	a9 ff		lda #$ff			lda 	#$FF 						; put end marker in ArrayDef
.b04a	9d 98 04	sta $0498,x			sta 	ArrayDef+1,x
.b04d					_CDICopy:
.b04d	bd 9f 04	lda $049f,x			lda 	UsrArrayDef,x
.b050	9d 97 04	sta $0497,x			sta 	ArrayDef,x
.b053	ca		dex				dex
.b054	10 f7		bpl $b04d			bpl 	_CDICopy
.b056	68		pla				pla									; position of array identifier
.b057	5a		phy				phy 								; save end position.
.b058	a8		tay				tay 								; point to identifier
.b059	20 24 bb	jsr $bb24			jsr 	VariableExtract 			; get the identifier
.b05c	20 c8 bd	jsr $bdc8			jsr 	VariableLocate 				; check if it exists already.
.b05f	b0 0e		bcs $b06f			bcs 	_CDIError
.b061	20 b2 bb	jsr $bbb2			jsr 	VariableCreate 				; create it using the current ArrayDef
.b064	7a		ply				ply 								; restore code position
.b065	ea		nop				nop
.b066	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b068	1b		inz				inz
.b069	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another DIM
.b06b	f0 88		beq $aff5			beq 	Command_DIM
.b06d	3b		dez				dez
.b06e	60		rts				rts
.b06f					_CDIError:
.b06f	20 4c ad	jsr $ad4c			jsr ERR_Handler
>b072	42 61 64 20 44 49 4d 00			.text "Bad DIM",0
.b07a					_CDISyntax:
.b07a	4c 1d ad	jmp $ad1d			jmp 	SyntaxError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/run.asm

.b07d					Command_RUN:
.b07d	20 b4 b1	jsr $b1b4			jsr 	ResetRunStatus 				; clear, reset stacks etc.
.b080	a9 00		lda #$00			lda 	#BasicProgram & $FF
.b082	85 16		sta $16				sta 	zCodePtr+0
.b084	a9 80		lda #$80			lda 	#BasicProgram >> 8
.b086	85 17		sta $17				sta 	zCodePtr+1
.b088	a9 02		lda #$02			lda 	#2
.b08a	85 18		sta $18				sta 	zCodePtr+2
.b08c	a9 00		lda #$00			lda 	#0
.b08e	85 19		sta $19				sta 	zCodePtr+3
.b090	a3 03		ldz #$03			ldz 	#3
.b092					RUN_NewLine:
.b092	a3 00		ldz #$00			ldz 	#0
.b094	ea		nop				nop
.b095	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b097	1b		inz				inz
.b098	1b		inz				inz
.b099	1b		inz				inz
.b09a	c9 00		cmp #$00			cmp 	#0 							; if the offset is zero then END.
.b09c	d0 18		bne $b0b6			bne 	RUN_NextCommand
.b09e	4c c5 b1	jmp $b1c5			jmp 	Command_STOP 				; go do the command code.
.b0a1					RUN_Skip:
.b0a1	ea		nop				nop
.b0a2	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read element
.b0a4	1b		inz				inz 								; skip
.b0a5	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.b0a7	90 0d		bcc $b0b6			bcc 	_SEDone 					; so just skip over it.
.b0a9	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.b0ab	90 08		bcc $b0b5			bcc 	_SEDouble
.b0ad	6b		tza				tza 								; this is Y + 1
.b0ae	18		clc				clc
.b0af	ea		nop				nop
.b0b0	72 16		adc ($16),z			adc 	(zCodePtr),z 				; add total length of element
.b0b2	4b		taz				taz 								; back in Y.
.b0b3	3b		dez				dez 								; fix up, one for the +1, one for the iny
.b0b4	3b		dez				dez
.b0b5					_SEDouble:
.b0b5	1b		inz				inz
.b0b6					_SEDone:
.b0b6					RUN_NextCommand:
.b0b6	a9 00		lda #$00			lda 	#0 							; this resets temporary string allocation.
.b0b8	85 21		sta $21				sta 	zTempStr+1 					; (initialised when first called)
.b0ba	ea		nop				nop
.b0bb	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b0bd	c9 c0		cmp #$c0			cmp 	#token_Colon 				; skip over colons
.b0bf	f0 e0		beq $b0a1			beq 	RUN_Skip
.b0c1	c9 00		cmp #$00			cmp 	#0 							; if non-zero execute whatever
.b0c3	d0 10		bne $b0d5			bne 	RUN_Execute
.b0c5					RUN_NextLine:
.b0c5	a3 00		ldz #$00			ldz 	#0 							; point to offset
.b0c7	ea		nop				nop
.b0c8	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read it
.b0ca	18		clc				clc
.b0cb	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.b0cd	85 16		sta $16				sta 	zCodePtr
.b0cf	90 02		bcc $b0d3			bcc 	_SNLNoCarry
.b0d1	e6 17		inc $17				inc 	zCodePtr+1
.b0d3					_SNLNoCarry:
.b0d3	80 bd		bra $b092			bra 	RUN_NewLine 				; go do the new line code
.b0d5					RUN_Execute:
.b0d5	c9 f8		cmp #$f8			cmp 	#$F8 						; handle shifts, REM etc.
.b0d7	b0 1c		bcs $b0f5			bcs 	RUN_Extension
.b0d9	1b		inz				inz
.b0da	0a		asl a				asl 	a 							; double the character read.
.b0db	90 12		bcc $b0ef			bcc 	RUN_Default 				; if carry clear was $00-$7F, so try LET.
.b0dd	aa		tax				tax 								; ready to look up.
.b0de	bd b1 ad	lda $adb1,x			lda 	VectorTable,x 				; copy address into LocalVector
.b0e1	8d 05 03	sta $0305			sta 	LocalVector+1
.b0e4	bd b2 ad	lda $adb2,x			lda 	VectorTable+1,x
.b0e7	8d 06 03	sta $0306			sta 	LocalVector+2
.b0ea	20 e5 b2	jsr $b2e5			jsr 	EVCallLocalVector 			; execute the appropriate code.
.b0ed	80 c7		bra $b0b6			bra 	RUN_NextCommand 			; do the next command.
.b0ef					RUN_Default:
.b0ef	3b		dez				dez
.b0f0	20 fd b0	jsr $b0fd			jsr 	Command_LET 				; and try LET.
.b0f3	80 c1		bra $b0b6			bra 	RUN_NextCommand
.b0f5					RUN_Extension:
.b0f5	c9 ff		cmp #$ff			cmp 	#$FF 						; if $FF (REM)
.b0f7	f0 a8		beq $b0a1			beq 	RUN_Skip 					; skip over it.
.b0f9	4c 1d ad	jmp $ad1d			jmp 	SyntaxError
.b0fc					Command_COLON:
.b0fc	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/let.asm

.b0fd					Command_LET:
.b0fd	20 b9 ba	jsr $bab9			jsr 	VariableFind 				; get reference to one variable.
.b100	a9 84		lda #$84			lda 	#token_Equal  				; get equals
.b102	20 f9 b9	jsr $b9f9			jsr 	CheckNextToken
.b105	a5 22		lda $22				lda 	zVarDataPtr 				; save variable info on stack
.b107	48		pha				pha
.b108	a5 23		lda $23				lda 	zVarDataPtr+1
.b10a	48		pha				pha
.b10b	a5 24		lda $24				lda 	zVarType
.b10d	48		pha				pha
.b10e	20 d0 b1	jsr $b1d0			jsr 	EvaluateExpression 			; evaluate the RHS.
.b111	68		pla				pla 								; restore target variable information.
.b112	85 24		sta $24				sta 	zVarType
.b114	68		pla				pla
.b115	85 23		sta $23				sta 	zVarDataPtr+1
.b117	68		pla				pla
.b118	85 22		sta $22				sta 	zVarDataPtr
.b11a	20 6b be	jsr $be6b			jsr 	VariableSet 				; set the value out.
.b11d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/end.asm

.b11e					Command_END:
.b11e	80 fe		bra $b11e	_halt:	bra 		_halt
.b120	4c ef af	jmp $afef			jmp 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/print.asm

.b123					Command_PRINT:
.b123	ea		nop				nop
.b124	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b126	c9 00		cmp #$00			cmp 	#0 							; end
.b128	f0 6a		beq $b194			beq 	_CPR_NewLine
.b12a	c9 c0		cmp #$c0			cmp 	#token_Colon
.b12c	f0 66		beq $b194			beq 	_CPR_NewLine
.b12e	c9 c1		cmp #$c1			cmp 	#token_SemiColon
.b130	f0 54		beq $b186			beq 	_CPR_Skip
.b132	c9 bf		cmp #$bf			cmp 	#token_Comma
.b134	f0 4d		beq $b183			beq 	_CPR_Tab
.b136	20 d0 b1	jsr $b1d0			jsr 	EvaluateExpression 			; get expression.
.b139	ad 0d 03	lda $030d			lda 	XS_Type 					; get type.
.b13c	29 02		and #$02			and 	#2
.b13e	d0 25		bne $b165			bne 	_CPR_String 				; if type = 2 output as string.
.b140					_CPR_Number:
.b140	a9 00		lda #$00			lda 	#0 							; reset buffer index
.b142	8d 04 04	sta $0404			sta 	NumBufX
.b145	ad 0d 03	lda $030d			lda 	XS_Type 					; get type
.b148	4a		lsr a				lsr 	a
.b149	b0 05		bcs $b150			bcs 	_CPRInt 					; if msb set do as integer
.b14b	20 fd c5	jsr $c5fd			jsr 	FPToString 					; call fp to str otherwise
.b14e	80 03		bra $b153			bra 	_CPRNPrint
.b150	20 ed bf	jsr $bfed	_CPRInt:jsr 	IntToString
.b153					_CPRNPrint:
.b153	ad 05 04	lda $0405			lda 	Num_Buffer 					; is first character -
.b156	c9 2d		cmp #$2d			cmp 	#"-"
.b158	f0 05		beq $b15f			beq 	_CPRNoSpace
.b15a	a9 20		lda #$20			lda 	#" "						; print the leading space
.b15c	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter 			; so beloved of MS Basics.
.b15f					_CPRNoSpace:
.b15f	a2 04		ldx #$04			ldx 	#(Num_Buffer-1) & $FF
.b161	a9 04		lda #$04			lda 	#(Num_Buffer-1) >> 8
.b163	80 06		bra $b16b			bra 	_CPRPrint
.b165					_CPR_String:
.b165	ae 08 03	ldx $0308			ldx 	XS_Mantissa
.b168	ad 09 03	lda $0309			lda 	XS_Mantissa+1
.b16b					_CPRPrint:
.b16b	86 1e		stx $1e				stx 	zGenPtr
.b16d	85 1f		sta $1f				sta 	zGenPtr+1
.b16f	5a		phy				phy
.b170	a0 00		ldy #$00			ldy 	#0							; get length into X
.b172	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b174	aa		tax				tax
.b175	f0 09		beq $b180			beq 	_CPREndPrint 				; nothing to print
.b177					_CPRLoop:
.b177	c8		iny				iny
.b178	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b17a	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.b17d	ca		dex				dex
.b17e	d0 f7		bne $b177			bne 	_CPRLoop
.b180					_CPREndPrint:
.b180	7a		ply				ply
.b181	80 a0		bra $b123			bra 	Command_Print
.b183					_CPR_Tab:
.b183	20 5b a0	jsr $a05b			jsr 	IFT_Tab
.b186					_CPR_Skip:
.b186	1b		inz				inz
.b187	ea		nop				nop
.b188	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b18a	c9 c0		cmp #$c0			cmp 	#token_Colon 				; colon or $00, exit
.b18c	f0 09		beq $b197			beq 	_CPR_Exit
.b18e	c9 00		cmp #$00			cmp 	#0
.b190	d0 91		bne $b123			bne 	Command_PRINT 				; if not go round again.
.b192	80 03		bra $b197			bra 	_CPR_Exit
.b194					_CPR_NewLine:
.b194	20 68 a0	jsr $a068			jsr 	IFT_NewLine
.b197					_CPR_Exit:
.b197	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/assert.asm

.b198					Command_ASSERT:
.b198	20 7d b3	jsr $b37d			jsr 	EvaluateNumber 				; calculate thing being asserted
.b19b	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; check if true (non-zero)
.b19e	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.b1a1	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.b1a4	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.b1a7	f0 01		beq $b1aa			beq 	_ASFail
.b1a9	60		rts				rts
.b1aa					_ASFail:
.b1aa	20 4c ad	jsr $ad4c			jsr ERR_Handler
>b1ad	41 73 73 65 72 74 00			.text "Assert",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.b1b4					Command_CLR:
.b1b4					ResetRunStatus:
.b1b4	20 f5 ba	jsr $baf5			jsr 	VariableClear
.b1b7	a9 00		lda #$00			lda 	#HighMemory & $FF
.b1b9	8d 00 04	sta $0400			sta 	StringPtr
.b1bc	a9 70		lda #$70			lda 	#HighMemory >> 8
.b1be	8d 01 04	sta $0401			sta 	StringPtr+1
.b1c1	20 ca bc	jsr $bcca			jsr 	ArrayResetDefault
.b1c4	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/stop.asm

.b1c5					Command_STOP:
.b1c5	20 4c ad	jsr $ad4c			jsr ERR_Handler
>b1c8	53 74 6f 70 00				.text "Stop",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.b1cd					EVESyntax:
.b1cd	4c 1d ad	jmp $ad1d			jmp 	SyntaxError
.b1d0					EvaluateExpression:
.b1d0	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.b1d2					EvaluateExpressionX:
.b1d2	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.b1d4					EvaluateExpressionXA:
.b1d4	48		pha				pha 								; save precedence on stack.
.b1d5	ea		nop				nop
.b1d6	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b1d8	f0 f3		beq $b1cd			beq 	EVESyntax 					; end of line, syntax error.
.b1da	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.b1dc	b0 03		bcs $b1e1			bcs 	_EVNotVariable
.b1de	4c dc b2	jmp $b2dc			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.b1e1					_EVNotVariable:
.b1e1	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.b1e3	90 e8		bcc $b1cd			bcc 	EVESyntax
.b1e5	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.b1e7	b3 82 00	bcs $b26b			bcs 	_EVNotInteger
.b1ea	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.b1ec	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.b1ef	a9 00		lda #$00			lda 	#0
.b1f1	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b1f4	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b1f7	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b1fa	1a		inc a				inc 	a 							; set to type 1 (integer)
.b1fb	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.b1fe					_EVCheckNextInteger:
.b1fe	1b		inz				inz
.b1ff	ea		nop				nop
.b200	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b202	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.b204	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.b206	b0 0d		bcs $b215			bcs 	_EVCheckDecimal
.b208	48		pha				pha 								; save it.
.b209	20 e8 b2	jsr $b2e8			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.b20c	68		pla				pla
.b20d	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.b210	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b213	80 e9		bra $b1fe			bra 	_EVCheckNextInteger
.b215					_EVCheckDecimal:
.b215	ea		nop				nop
.b216	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b218	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.b21a	d0 05		bne $b221			bne 	_EVGotAtom 					; no, get atom.
.b21c					_EVIsDecimal:
.b21c	20 18 b3	jsr $b318			jsr 	EVGetDecimal 				; extend to the decimal part.
.b21f	80 00		bra $b221			bra 	_EVGotAtom 					; and continue to got atom.
.b221					_EVGotAtom:
.b221	ea		nop				nop
.b222	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b224	10 43		bpl $b269			bpl 	_EVExitDrop 				; must be a token.
.b226	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.b228	b0 3f		bcs $b269			bcs 	_EVExitDrop
.b22a	68		pla				pla 								; get current precedence
.b22b	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.b22d	da		phx				phx 								; save X
.b22e	ea		nop				nop
.b22f	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b231	aa		tax				tax 								; put in X
.b232	bd 00 ae	lda $ae00,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.b235	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.b237	fa		plx				plx 								; restore X
.b238	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.b23a	90 2e		bcc $b26a			bcc 	_EVExit 					; exit if too low.
.b23c	f0 2c		beq $b26a			beq 	_EVExit 					; exit if equals
.b23e	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.b240	48		pha				pha
.b241	ea		nop				nop
.b242	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b244	48		pha				pha
.b245	1b		inz				inz
.b246	da		phx				phx 								; save current position
.b247	e8		inx				inx
.b248	e8		inx				inx
.b249	e8		inx				inx
.b24a	e8		inx				inx
.b24b	e8		inx				inx
.b24c	e8		inx				inx
.b24d	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.b24f	20 d4 b1	jsr $b1d4			jsr 	EvaluateExpressionXA 		; do the RHS.
.b252	fa		plx				plx 								; restore X
.b253	68		pla				pla 								; get the binary operator in A.
.b254					_EVCallA:
.b254	da		phx				phx 								; save X again
.b255	0a		asl a				asl 	a 							; double, lose the MSB.
.b256	aa		tax				tax									; put in X
.b257	bd b1 ad	lda $adb1,x			lda 	VectorTable,x 				; copy address into zGenPtr
.b25a	8d 05 03	sta $0305			sta 	LocalVector+1
.b25d	bd b2 ad	lda $adb2,x			lda 	VectorTable+1,x
.b260	8d 06 03	sta $0306			sta 	LocalVector+2
.b263	fa		plx				plx 								; restore X
.b264	20 e5 b2	jsr $b2e5			jsr 	EVCallLocalVector
.b267	80 b8		bra $b221			bra 	_EVGotAtom 					; and loop back.
.b269					_EVExitDrop:
.b269	68		pla				pla
.b26a					_EVExit:
.b26a	60		rts				rts
.b26b					_EVNotInteger:
.b26b	1b		inz				inz
.b26c	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.b26e	d0 19		bne $b289			bne 	_EVNotMinus
.b270	20 6b b3	jsr $b36b			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.b273	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.b276	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.b278	f0 05		beq $b27f			beq 	_EVMinusFloat
.b27a	20 c8 bf	jsr $bfc8			jsr 	IntegerNegateAlways 		; negation
.b27d	80 a2		bra $b221			bra 	_EVGotAtom 					; and go back.
.b27f					_EVMinusFloat:
.b27f	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; invert the sign bit.
.b282	49 80		eor #$80			eor 	#$80
.b284	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.b287	80 98		bra $b221			bra 	_EVGotAtom
.b289					_EVNotMinus:
.b289	c9 bd		cmp #$bd			cmp 	#token_lparen 				; is it left parenthesis
.b28b	d0 18		bne $b2a5			bne 	_EVNotParenthesis
.b28d	20 d2 b1	jsr $b1d2			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.b290	ea		nop				nop
.b291	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b293	1b		inz				inz
.b294	c9 be		cmp #$be			cmp 	#token_rparen 				; okay if right bracket.
.b296	f0 89		beq $b221			beq 	_EVGotAtom
.b298	20 4c ad	jsr $ad4c			jsr ERR_Handler
>b29b	4d 69 73 73 69 6e 67 20			.text "Missing )",0
>b2a3	29 00
.b2a5					_EVNotParenthesis:
.b2a5	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.b2a7	d0 0c		bne $b2b5			bne 	_EVNotNot
.b2a9	20 6b b3	jsr $b36b			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.b2ac	20 d2 c4	jsr $c4d2			jsr 	FPUToInteger 				; make it an integer - if possible.
.b2af	20 48 b3	jsr $b348			jsr 	NotInteger 					; do the not calculation
.b2b2	4c 21 b2	jmp $b221			jmp 	_EVGotAtom
.b2b5					_EVNotNot:
.b2b5	c9 fe		cmp #$fe			cmp 	#$FE
.b2b7	d0 15		bne $b2ce			bne 	_EVNotString
.b2b9	20 90 ba	jsr $ba90			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.b2bc	a5 20		lda $20				lda 	zTempStr 					; copy address of string into mantissa
.b2be	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b2c1	a5 21		lda $21				lda 	zTempStr+1
.b2c3	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b2c6	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.b2c8	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.b2cb	4c 21 b2	jmp $b221			jmp 	_EVGotAtom
.b2ce					_EVNotString:
.b2ce	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.b2d0	90 04		bcc $b2d6			bcc 	_EVBadElement
.b2d2	c9 b7		cmp #$b7			cmp 	#lastUnaryFunction+1
.b2d4	90 03		bcc $b2d9			bcc 	_EVUnaryFunction
.b2d6					_EVBadElement:
.b2d6	4c 1d ad	jmp $ad1d			jmp 	SyntaxError
.b2d9					_EVUnaryFunction:
.b2d9	4c 54 b2	jmp $b254			jmp 	_EVCallA
.b2dc					_EVVariableHandler:
.b2dc	20 b9 ba	jsr $bab9			jsr 	VariableFind 				; locate a variable
.b2df	20 0c be	jsr $be0c			jsr 	VariableGet 				; copy into memory.
.b2e2	4c 21 b2	jmp $b221			jmp 	_EVGotAtom 					; and go round.
.b2e5					EVCallLocalVector:
.b2e5	6c 05 03	jmp ($0305)			jmp 	(LocalVector+1)
.b2e8					EVShiftMantissaLeft6:
.b2e8	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.b2eb	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.b2ee	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.b2f1	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b2f4	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b2f7	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b2fa	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b2fd	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b300	a9 00		lda #$00			lda 	#0
.b302	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b305	20 08 b3	jsr $b308			jsr 	_EVSMLShift 					; call it here to do it twice
.b308					_EVSMLShift:
.b308	5e 0c 03	lsr $030c,x			lsr 	XS_Exponent,x
.b30b	7e 0b 03	ror $030b,x			ror 	XS_Mantissa+3,x
.b30e	7e 0a 03	ror $030a,x			ror 	XS_Mantissa+2,x
.b311	7e 09 03	ror $0309,x			ror 	XS_Mantissa+1,x
.b314	7e 08 03	ror $0308,x			ror 	XS_Mantissa+0,x
.b317	60		rts				rts
.b318					EVGetDecimal:
.b318	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.b31a	8d 05 04	sta $0405			sta 	Num_Buffer
.b31d	da		phx				phx
.b31e	1b		inz				inz
.b31f	ea		nop				nop
.b320	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b322	1b		inz				inz
.b323	3a		dec a				dec 	a								; convert to a string length.
.b324	3a		dec a				dec 	a
.b325	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.b327					_EVGDCopy:
.b327	48		pha				pha 									; save count
.b328	ea		nop				nop
.b329	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b32b	9d 05 04	sta $0405,x			sta 	Num_Buffer,x
.b32e	e8		inx				inx 									; forward ....
.b32f	1b		inz				inz
.b330	68		pla				pla 									; get count
.b331	3a		dec a				dec 	a 								; until zero
.b332	d0 f3		bne $b327			bne 	_EVGDCopy
.b334	9d 05 04	sta $0405,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.b337	fa		plx				plx 									; restore X
.b338	a9 05		lda #$05			lda 	#Num_Buffer & $FF 				; set zGenPtr
.b33a	85 1e		sta $1e				sta 	zGenPtr
.b33c	a9 04		lda #$04			lda 	#Num_Buffer >> 8
.b33e	85 1f		sta $1f				sta 	zGenPtr+1
.b340	5a		phy				phy 									; save Y
.b341	a0 00		ldy #$00			ldy 	#0 								; start position
.b343	20 c4 c6	jsr $c6c4			jsr 	FPFromString 					; convert current
.b346	7a		ply				ply 									; restore Y
.b347	60		rts				rts
.b348					NotInteger:
.b348	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b34b	49 ff		eor #$ff			eor 	#$FF
.b34d	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b350	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b353	49 ff		eor #$ff			eor 	#$FF
.b355	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b358	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.b35b	49 ff		eor #$ff			eor 	#$FF
.b35d	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b360	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.b363	49 ff		eor #$ff			eor 	#$FF
.b365	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b368	60		rts				rts
.b369					EvaluateGetAtom:
.b369	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.b36b					EvaluateGetAtomX:
.b36b	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.b36d	20 d4 b1	jsr $b1d4			jsr 	EvaluateExpressionXA
.b370	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.b373	29 0f		and #$0f			and 	#15
.b375	c9 02		cmp #$02			cmp 	#2
.b377	b0 01		bcs $b37a			bcs 	EvaluateType
.b379	60		rts				rts
.b37a					EvaluateType:
.b37a	4c 2d ad	jmp $ad2d			jmp 	TypeError
.b37d					EvaluateNumber:
.b37d	a2 00		ldx #$00			ldx 	#0
.b37f					EvaluateNumberX:
.b37f	20 d2 b1	jsr $b1d2			jsr 	EvaluateExpressionX
.b382	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 0/1
.b385	29 0f		and #$0f			and 	#15
.b387	c9 02		cmp #$02			cmp 	#2
.b389	b0 ef		bcs $b37a			bcs 	EvaluateType
.b38b	60		rts				rts
.b38c					EvaluateInteger:
.b38c	a2 00		ldx #$00			ldx 	#0
.b38e					EvaluateIntegerX:
.b38e	20 7f b3	jsr $b37f			jsr 	EvaluateNumberX
.b391	20 d2 c4	jsr $c4d2			jsr 	FPUToInteger
.b394	60		rts				rts
.b395					EvaluateString:
.b395	a2 00		ldx #$00			ldx 	#0
.b397					EvaluateStringX:
.b397	20 d2 b1	jsr $b1d2			jsr 	EvaluateExpressionX
.b39a	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 2
.b39d	29 0f		and #$0f			and 	#15
.b39f	c9 02		cmp #$02			cmp 	#2
.b3a1	d0 d7		bne $b37a			bne 	EvaluateType
.b3a3	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.b3a6	85 1e		sta $1e				sta 	zGenPtr
.b3a8	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b3ab	85 1f		sta $1f				sta 	zGenPtr+1
.b3ad	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.b3ae					BinaryOp_And:
.b3ae	20 26 b4	jsr $b426			jsr 	BinaryMakeBothInteger
.b3b1	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.b3b4	3d 0e 03	and $030e,x			and 	XS2_Mantissa+0,x
.b3b7	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b3ba	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.b3bd	3d 0f 03	and $030f,x			and 	XS2_Mantissa+1,x
.b3c0	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b3c3	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.b3c6	3d 10 03	and $0310,x			and 	XS2_Mantissa+2,x
.b3c9	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b3cc	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.b3cf	3d 11 03	and $0311,x			and 	XS2_Mantissa+3,x
.b3d2	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b3d5	60		rts				rts
.b3d6					BinaryOp_Or:
.b3d6	20 26 b4	jsr $b426			jsr 	BinaryMakeBothInteger
.b3d9	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.b3dc	1d 0e 03	ora $030e,x			ora 	XS2_Mantissa+0,x
.b3df	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b3e2	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.b3e5	1d 0f 03	ora $030f,x			ora 	XS2_Mantissa+1,x
.b3e8	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b3eb	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.b3ee	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.b3f1	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b3f4	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.b3f7	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.b3fa	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b3fd	60		rts				rts
.b3fe					BinaryOp_Eor:
.b3fe					BinaryOp_Xor:
.b3fe	20 26 b4	jsr $b426			jsr 	BinaryMakeBothInteger
.b401	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.b404	5d 0e 03	eor $030e,x			eor 	XS2_Mantissa+0,x
.b407	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b40a	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.b40d	5d 0f 03	eor $030f,x			eor 	XS2_Mantissa+1,x
.b410	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b413	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.b416	5d 10 03	eor $0310,x			eor 	XS2_Mantissa+2,x
.b419	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b41c	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.b41f	5d 11 03	eor $0311,x			eor 	XS2_Mantissa+3,x
.b422	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b425	60		rts				rts
.b426					BinaryMakeBothInteger:
.b426	da		phx				phx 								; save X
.b427	e8		inx				inx
.b428	e8		inx				inx
.b429	e8		inx				inx
.b42a	e8		inx				inx
.b42b	e8		inx				inx
.b42c	e8		inx				inx
.b42d	20 31 b4	jsr $b431			jsr 	BinaryMakeInteger 			; convert to integer.
.b430	fa		plx				plx 								; restore X and fall through.
.b431					BinaryMakeInteger:
.b431	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type byte.
.b434	29 0f		and #$0f			and 	#15 						; check type zero
.b436	f0 04		beq $b43c			beq 	_BMIConvert 				; if float convert to integer.
.b438	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.b439	90 04		bcc $b43f			bcc 	_BMIError
.b43b	60		rts				rts
.b43c					_BMIConvert:
.b43c	4c d2 c4	jmp $c4d2			jmp 	FPUToInteger 				; convert to integer
.b43f					_BMIError:
.b43f	4c 2d ad	jmp $ad2d			jmp 	TypeError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.b442					Binary_Equal:
.b442	20 8e b4	jsr $b48e			jsr 	CompareValues
.b445	09 00		ora #$00			ora 	#0
.b447	f0 04		beq $b44d			beq 	CCTrue
.b449	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.b44b	80 02		bra $b44f			bra 	CCWrite
.b44d	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.b44f	9d 08 03	sta $0308,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.b452	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b455	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b458	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b45b	a9 01		lda #$01			lda 	#1
.b45d	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; set type to integer whatever.
.b460	60		rts				rts
.b461					Binary_NotEqual:
.b461	20 8e b4	jsr $b48e			jsr 	CompareValues
.b464	09 00		ora #$00			ora 	#0
.b466	f0 e1		beq $b449			beq 	CCFalse
.b468	80 e3		bra $b44d			bra 	CCTrue
.b46a					Binary_Less:
.b46a	20 8e b4	jsr $b48e			jsr 	CompareValues
.b46d	09 00		ora #$00			ora 	#0
.b46f	30 dc		bmi $b44d			bmi 	CCTrue
.b471	80 d6		bra $b449			bra 	CCFalse
.b473					Binary_LessEqual:
.b473	20 8e b4	jsr $b48e			jsr 	CompareValues
.b476	c9 01		cmp #$01			cmp 	#1
.b478	d0 d3		bne $b44d			bne 	CCTrue
.b47a	80 cd		bra $b449			bra 	CCFalse
.b47c					Binary_GreaterEqual:
.b47c	20 8e b4	jsr $b48e			jsr 	CompareValues
.b47f	09 00		ora #$00			ora 	#0
.b481	10 ca		bpl $b44d			bpl 	CCTrue
.b483	80 c4		bra $b449			bra 	CCFalse
.b485					Binary_Greater:
.b485	20 8e b4	jsr $b48e			jsr 	CompareValues
.b488	c9 01		cmp #$01			cmp 	#1
.b48a	f0 c1		beq $b44d			beq 	CCTrue
.b48c	80 bb		bra $b449			bra 	CCFalse
.b48e					CompareValues:
.b48e	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and the types together
.b491	3d 13 03	and $0313,x			and 	XS2_Type,x
.b494	c9 02		cmp #$02			cmp 	#2
.b496	f0 13		beq $b4ab			beq 	_CVString
.b498	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b49b	3d 13 03	and $0313,x			and 	XS2_Type,x
.b49e	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b49f	90 03		bcc $b4a4			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b4a1	4c f1 b4	jmp $b4f1			jmp 	CompareInteger32 							; so execute code at \1
.b4a4					_BCFloat:
.b4a4	20 bf b5	jsr $b5bf			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b4a7	4c e1 c3	jmp $c3e1			jmp 	FPCompare 							; and execute code at \2
.b4aa	60		rts				rts
.b4ab					_CVString:
.b4ab	da		phx				phx 								; save XY
.b4ac	5a		phy				phy
.b4ad	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.b4b0	85 1a		sta $1a				sta		zLTemp1+0
.b4b2	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b4b5	85 1b		sta $1b				sta 	zLTemp1+1
.b4b7	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x
.b4ba	85 1c		sta $1c				sta 	zLTemp1+2
.b4bc	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.b4bf	85 1d		sta $1d				sta 	zLTemp1+3
.b4c1	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.b4c3	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b4c5	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.b4c7	90 02		bcc $b4cb			bcc 	_CVCommon
.b4c9	b1 1c		lda ($1c),y			lda 	(zLTemp1+2),y
.b4cb					_CVCommon:
.b4cb	aa		tax				tax 								; put shorter string length in zero.
.b4cc	f0 0c		beq $b4da			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.b4ce					_CVCompare:
.b4ce	c8		iny				iny 								; next character
.b4cf	b1 1a		lda ($1a),y			lda 	(zLTemp1),y 				; compare characters
.b4d1	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.b4d3	90 13		bcc $b4e8			bcc 	_CVReturnLess 				; <
.b4d5	d0 15		bne $b4ec			bne 	_CVReturnGreater 			; >
.b4d7	ca		dex				dex 								; until common length matched.
.b4d8	d0 f4		bne $b4ce			bne 	_CVCompare
.b4da					_CVMatch:
.b4da	a0 00		ldy #$00			ldy 	#0
.b4dc	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b4de	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.b4e0	90 06		bcc $b4e8			bcc 	_CVReturnLess 				; <
.b4e2	d0 08		bne $b4ec			bne 	_CVReturnGreater 			; >
.b4e4	a9 00		lda #$00			lda 	#0
.b4e6	80 06		bra $b4ee			bra 	_CVExit 					; same common, same length, same string
.b4e8					_CVReturnLess:
.b4e8	a9 ff		lda #$ff			lda 	#$FF
.b4ea	80 02		bra $b4ee			bra 	_CVExit
.b4ec					_CVReturnGreater:
.b4ec	a9 01		lda #$01			lda 	#$01
.b4ee					_CVExit:
.b4ee	7a		ply				ply
.b4ef	fa		plx				plx
.b4f0	60		rts				rts
.b4f1					CompareInteger32:
.b4f1	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.b4f4	49 80		eor #$80			eor 	#$80
.b4f6	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b4f9	bd 11 03	lda $0311,x			lda 	XS2_Mantissa+3,x
.b4fc	49 80		eor #$80			eor 	#$80
.b4fe	9d 11 03	sta $0311,x			sta 	XS2_Mantissa+3,x
.b501	20 99 b5	jsr $b599			jsr 	SubInteger32 				; subtraction
.b504	90 11		bcc $b517			bcc 	_CI32Less 					; cc return -1
.b506	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; check if zero
.b509	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.b50c	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.b50f	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.b512	f0 02		beq $b516			beq 	_CI32Exit
.b514	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.b516					_CI32Exit:
.b516	60		rts				rts
.b517					_CI32Less:
.b517	a9 ff		lda #$ff			lda 	#$FF
.b519	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.b51a					BinaryOp_Add:
.b51a	bd 0d 03	lda $030d,x			lda 	XS_Type,x  					; and types together
.b51d	3d 13 03	and $0313,x			and 	XS2_Type,x
.b520	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.b522	d0 13		bne $b537			bne 	_BOAString
.b524	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b527	3d 13 03	and $0313,x			and 	XS2_Type,x
.b52a	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b52b	90 03		bcc $b530			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b52d	4c 73 b5	jmp $b573			jmp 	AddInteger32 							; so execute code at \1
.b530					_BCFloat:
.b530	20 bf b5	jsr $b5bf			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b533	4c 55 c1	jmp $c155			jmp 	FPAdd 							; and execute code at \2
.b536	60		rts				rts
.b537					_BOAString:
.b537	4c da b5	jmp $b5da			jmp 	ConcatenateString 			; concatenate two strings.
.b53a					BinaryOp_Subtract:
.b53a	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b53d	3d 13 03	and $0313,x			and 	XS2_Type,x
.b540	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b541	90 03		bcc $b546			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b543	4c 99 b5	jmp $b599			jmp 	SubInteger32 							; so execute code at \1
.b546					_BCFloat:
.b546	20 bf b5	jsr $b5bf			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b549	4c 4b c1	jmp $c14b			jmp 	FPSubtract 							; and execute code at \2
.b54c	60		rts				rts
.b54d					BinaryOp_Multiply:
.b54d	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b550	3d 13 03	and $0313,x			and 	XS2_Type,x
.b553	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b554	90 03		bcc $b559			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b556	4c db be	jmp $bedb			jmp 	MulInteger32 							; so execute code at \1
.b559					_BCFloat:
.b559	20 bf b5	jsr $b5bf			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b55c	4c c1 c2	jmp $c2c1			jmp 	FPMultiply 							; and execute code at \2
.b55f	60		rts				rts
.b560					BinaryOp_Divide:
.b560	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b563	3d 13 03	and $0313,x			and 	XS2_Type,x
.b566	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b567	90 03		bcc $b56c			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b569	4c 32 bf	jmp $bf32			jmp 	DivInteger32 							; so execute code at \1
.b56c					_BCFloat:
.b56c	20 bf b5	jsr $b5bf			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b56f	4c 39 c2	jmp $c239			jmp 	FPDivide 							; and execute code at \2
.b572	60		rts				rts
.b573					AddInteger32:
.b573	18		clc				clc
.b574	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b577	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.b57a	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b57d	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b580	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.b583	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b586	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.b589	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.b58c	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b58f	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.b592	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.b595	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b598	60		rts				rts
.b599					SubInteger32:
.b599	38		sec				sec
.b59a	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b59d	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.b5a0	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b5a3	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b5a6	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.b5a9	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b5ac	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.b5af	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.b5b2	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b5b5	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.b5b8	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.b5bb	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b5be	60		rts				rts
.b5bf					BinaryMakeBothFloat:
.b5bf	da		phx				phx 								; save X
.b5c0	e8		inx				inx
.b5c1	e8		inx				inx
.b5c2	e8		inx				inx
.b5c3	e8		inx				inx
.b5c4	e8		inx				inx
.b5c5	e8		inx				inx
.b5c6	20 ca b5	jsr $b5ca			jsr 	BinaryMakeFloat 			; convert to float.
.b5c9	fa		plx				plx 								; restore X and fall through.
.b5ca					BinaryMakeFloat:
.b5ca	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type byte.
.b5cd	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.b5ce	b0 04		bcs $b5d4			bcs 	_BMFConvert
.b5d0	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.b5d1	b0 04		bcs $b5d7			bcs 	_BMFError
.b5d3	60		rts				rts
.b5d4					_BMFConvert:
.b5d4	4c 73 c4	jmp $c473			jmp 	FPUToFloat 					; convert to float
.b5d7					_BMFError:
.b5d7	4c 2d ad	jmp $ad2d			jmp 	TypeError
.b5da					ConcatenateString:
.b5da	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.b5dd	85 1a		sta $1a				sta		zLTemp1+0
.b5df	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b5e2	85 1b		sta $1b				sta 	zLTemp1+1
.b5e4	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x
.b5e7	85 1c		sta $1c				sta 	zLTemp1+2
.b5e9	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.b5ec	85 1d		sta $1d				sta 	zLTemp1+3
.b5ee	5a		phy				phy
.b5ef	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.b5f1	b1 1a		lda ($1a),y			lda 	(zlTemp1),y
.b5f3	71 1c		adc ($1c),y			adc 	(zlTemp1+2),y
.b5f5	7a		ply				ply
.b5f6	b0 37		bcs $b62f			bcs 	_CSError					; check in range.
.b5f8	c9 fe		cmp #$fe			cmp 	#maxString+1
.b5fa	b0 33		bcs $b62f			bcs 	_CSError
.b5fc	20 55 ba	jsr $ba55			jsr 	AllocateTempString 			; store the result
.b5ff	20 1a b6	jsr $b61a			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.b602	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.b605	85 1a		sta $1a				sta 	zLTemp1
.b607	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.b60a	85 1b		sta $1b				sta 	zLTemp1+1
.b60c	20 1a b6	jsr $b61a			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.b60f	a5 20		lda $20				lda 	zTempStr 					; point current to new string
.b611	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b614	a5 21		lda $21				lda 	zTempStr+1
.b616	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b619	60		rts				rts
.b61a					_CSCopyString:
.b61a	da		phx				phx
.b61b	5a		phy				phy
.b61c	a0 00		ldy #$00			ldy 	#0 							; get length
.b61e	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b620	f0 0a		beq $b62c			beq 	_CSCSExit 					; if zero, exit
.b622	aa		tax				tax 								; put in X
.b623					_CSCSLoop:
.b623	c8		iny				iny 								; get next char
.b624	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b626	20 80 ba	jsr $ba80			jsr		WriteTempString 			; copy out
.b629	ca		dex				dex 								; do whole string
.b62a	d0 f7		bne $b623			bne 	_CSCSLoop
.b62c					_CSCSExit:
.b62c	7a		ply				ply
.b62d	fa		plx				plx
.b62e	60		rts				rts
.b62f					_CSError:
.b62f	20 4c ad	jsr $ad4c			jsr ERR_Handler
>b632	53 74 72 69 6e 67 20 74			.text "String too long",0
>b63a	6f 6f 20 6c 6f 6e 67 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.b642					Unary_Sgn:
.b642	20 7f b3	jsr $b37f			jsr 	EvaluateNumberX 			; get value
.b645	20 11 ba	jsr $ba11			jsr 	CheckNextRParen 			; check right bracket.
.b648	20 6c b6	jsr $b66c			jsr 	GetSignCurrent 				; get sign.
.b64b	09 00		ora #$00			ora 	#0
.b64d	10 09		bpl $b658			bpl		UnarySetAInteger			; if 0,1 return that.
.b64f	80 00		bra $b651			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.b651					UnarySetAMinus1:
.b651	a9 ff		lda #$ff			lda 	#$FF
.b653	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.b656	80 05		bra $b65d			bra 	UnarySetAFill
.b658					UnarySetAInteger:
.b658	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.b65b	a9 00		lda #$00			lda 	#0
.b65d					UnarySetAFill:
.b65d	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b660	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b663	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b666	a9 01		lda #$01			lda 	#1
.b668	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.b66b	60		rts				rts
.b66c					GetSignCurrent:
.b66c	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; identify type.
.b66f	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.b670	90 19		bcc $b68b			bcc 	_GSCFloat
.b672	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.b675	30 11		bmi $b688			bmi 	_GSCMinus1
.b677	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x
.b67a	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.b67d	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.b680	d0 03		bne $b685			bne 	_GSCPlus1
.b682					_GSCZero:
.b682	a9 00		lda #$00			lda 	#0
.b684	60		rts				rts
.b685					_GSCPlus1:
.b685	a9 01		lda #$01			lda 	#$01
.b687	60		rts				rts
.b688					_GSCMinus1:
.b688	a9 ff		lda #$ff			lda 	#$FF
.b68a	60		rts				rts
.b68b					_GSCFloat:
.b68b	3c 0d 03	bit $030d,x			bit 	XS_Type,x
.b68e	70 f2		bvs $b682			bvs 	_GSCZero
.b690	30 f6		bmi $b688			bmi 	_GSCMinus1
.b692	80 f1		bra $b685			bra 	_GSCPlus1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.b694					Unary_Abs:
.b694	20 7f b3	jsr $b37f			jsr 	EvaluateNumberX 			; get value
.b697	20 11 ba	jsr $ba11			jsr 	CheckNextRParen 			; check right bracket.
.b69a	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.b69d	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.b69f	f0 08		beq $b6a9			beq 	_UAMinusFloat
.b6a1	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; check MSB
.b6a4	10 0b		bpl $b6b1			bpl 	_UAExit
.b6a6	4c c8 bf	jmp $bfc8			jmp 	IntegerNegateAlways 		; negation
.b6a9					_UAMinusFloat:
.b6a9	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; clear the sign bit.
.b6ac	29 7f		and #$7f			and		#$7F
.b6ae	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.b6b1					_UAExit:
.b6b1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.b6b2					Unary_Peek:
.b6b2	a9 01		lda #$01			lda 	#1
.b6b4	80 06		bra $b6bc			bra 	UPMain
.b6b6					Unary_Deek:
.b6b6	a9 02		lda #$02			lda 	#2
.b6b8	80 02		bra $b6bc			bra 	UPMain
.b6ba					Unary_Leek:
.b6ba	a9 04		lda #$04			lda 	#4
.b6bc					UPMain:
.b6bc	48		pha				pha 								; set bytes to copy.
.b6bd	20 8e b3	jsr $b38e			jsr 	EvaluateIntegerX 			; numeric parameter
.b6c0	20 11 ba	jsr $ba11			jsr 	CheckNextRParen 			; right bracket.
.b6c3	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.b6c6	85 1a		sta $1a				sta 	zLTemp1
.b6c8	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b6cb	85 1b		sta $1b				sta 	zLTemp1+1
.b6cd	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.b6d0	85 1c		sta $1c				sta 	zLTemp1+2
.b6d2	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.b6d5	85 1d		sta $1d				sta 	zLTemp1+3
.b6d7	a9 00		lda #$00			lda 	#0 							; clear target area
.b6d9	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b6dc	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b6df	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b6e2	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b6e5	68		pla				pla 								; restore bytes to copy
.b6e6	da		phx				phx 								; save XY
.b6e7	5a		phy				phy
.b6e8	20 e4 b9	jsr $b9e4			jsr 	MemRead 					; read the bytes in
.b6eb	7a		ply				ply 								; restore and exit
.b6ec	fa		plx				plx
.b6ed	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.b6ee					Unary_Mod:
.b6ee	20 1a b7	jsr $b71a			jsr 	_UMParameter 				; first parameter
.b6f1	20 1a ba	jsr $ba1a			jsr 	CheckNextComma
.b6f4	da		phx				phx 								; second parameter
.b6f5	e8		inx				inx
.b6f6	e8		inx				inx
.b6f7	e8		inx				inx
.b6f8	e8		inx				inx
.b6f9	e8		inx				inx
.b6fa	e8		inx				inx
.b6fb	20 1a b7	jsr $b71a			jsr 	_UMParameter
.b6fe	fa		plx				plx
.b6ff	20 11 ba	jsr $ba11			jsr 	CheckNextRParen
.b702	20 32 bf	jsr $bf32			jsr 	DivInteger32 				; divide
.b705	a5 1a		lda $1a				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.b707	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b70a	a5 1b		lda $1b				lda 	zLTemp1+1
.b70c	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b70f	a5 1c		lda $1c				lda 	zLTemp1+2
.b711	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b714	a5 1d		lda $1d				lda 	zLTemp1+3
.b716	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b719	60		rts				rts
.b71a					_UMParameter:
.b71a	20 8e b3	jsr $b38e			jsr 	EvaluateIntegerX 			; get value
.b71d	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; absolute value
.b720	10 03		bpl $b725			bpl 	_UMNotSigned
.b722	20 c8 bf	jsr $bfc8			jsr 	IntegerNegateAlways
.b725					_UMNotSigned:
.b725	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.b726					Unary_Usr:
.b726	20 7f b3	jsr $b37f			jsr 	EvaluateNumberX 			; numeric parameter
.b729	20 11 ba	jsr $ba11			jsr 	CheckNextRParen 			; right bracket.
.b72c	da		phx				phx 								; save XY
.b72d	5a		phy				phy
.b72e	ea		nop				nop
.b72f	20 00 03	jsr $0300			jsr 	UserVector 					; call the USR function.
.b732	7a		ply				ply 								; and exit
.b733	fa		plx				plx
.b734	60		rts				rts
.b735					USRDefault:
.b735	20 4c ad	jsr $ad4c			jsr ERR_Handler
>b738	4e 6f 20 55 53 52 20 76			.text "No USR vector.",0
>b740	65 63 74 6f 72 2e 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.b747					Unary_Val:
.b747	20 97 b3	jsr $b397			jsr 	EvaluateStringX 			; get string
.b74a	20 11 ba	jsr $ba11			jsr 	CheckNextRParen 			; check right bracket.
.b74d	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.b750	85 1e		sta $1e				sta 	zGenPtr
.b752	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b755	85 1f		sta $1f				sta 	zGenPtr+1
.b757	5a		phy				phy
.b758	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.b75a	b1 1e		lda ($1e),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.b75c	f0 57		beq $b7b5			beq 	_UVBadNumber
.b75e	48		pha				pha 								; save length.
.b75f	1a		inc a				inc 	a 							; one for the length, one for the terminator
.b760	1a		inc a				inc 	a
.b761	20 55 ba	jsr $ba55			jsr 	AllocateTempString
.b764	c8		iny				iny 								; move to the next.
.b765	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get character
.b767	49 2d		eor #$2d			eor 	#"-"						; zero if minus sign
.b769	8d 90 04	sta $0490			sta 	ValSign
.b76c	d0 04		bne $b772			bne 	_UVNotMinus
.b76e	c8		iny				iny 								; skip over it.
.b76f	68		pla				pla 								; decrement character count.
.b770	3a		dec a				dec 	a
.b771	48		pha				pha
.b772					_UVNotMinus:
.b772	68		pla				pla 								; this is the count.
.b773	48		pha		_UVCopy:pha									; copy into new temp string which is ASCIIZ
.b774	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b776	c8		iny				iny
.b777	20 80 ba	jsr $ba80			jsr 	WriteTempString
.b77a	68		pla				pla
.b77b	3a		dec a				dec 	a
.b77c	d0 f5		bne $b773			bne 	_UVCopy
.b77e	20 80 ba	jsr $ba80			jsr 	WriteTempString 			; make it ASCIIZ
.b781	18		clc				clc
.b782	a5 20		lda $20				lda 	zTempStr 					; tempstring +1 => genptr
.b784	69 01		adc #$01			adc 	#1
.b786	85 1e		sta $1e				sta 	zGenPtr
.b788	a5 21		lda $21				lda 	zTempStr+1
.b78a	69 00		adc #$00			adc 	#0
.b78c	85 1f		sta $1f				sta 	zGenPtr+1
.b78e	18		clc				clc
.b78f	20 a0 c0	jsr $c0a0			jsr 	IntFromString 				; first bit.
.b792	b0 21		bcs $b7b5			bcs 	_UVBadNumber
.b794	20 c4 c6	jsr $c6c4			jsr 	FPFromString				; try for a float part.
.b797	ad 90 04	lda $0490			lda 	ValSign 					; was it negative
.b79a	d0 13		bne $b7af			bne 	_UVNotNegative
.b79c	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; check if integer
.b79f	4a		lsr a				lsr 	a
.b7a0	b0 0a		bcs $b7ac			bcs 	_UVInteger
.b7a2	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; set sign bit
.b7a5	09 80		ora #$80			ora 	#$80
.b7a7	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.b7aa	80 03		bra $b7af			bra 	_UVNotNegative
.b7ac					_UVInteger:
.b7ac	20 c8 bf	jsr $bfc8			jsr 	IntegerNegateAlways 		; sign it.
.b7af					_UVNotNegative:
.b7af	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; used everything
.b7b1	d0 02		bne $b7b5			bne 	_UVBadNumber
.b7b3	7a		ply				ply
.b7b4	60		rts				rts
.b7b5					_UVBadNumber:
.b7b5	4c 3b ad	jmp $ad3b			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.b7b8					Unary_Str:
.b7b8	20 7f b3	jsr $b37f			jsr 	EvaluateNumberX 			; numeric parameter
.b7bb	20 11 ba	jsr $ba11			jsr 	CheckNextRParen 			; right bracket.
.b7be	a9 00		lda #$00			lda 	#0 							; reset buffer index
.b7c0	8d 04 04	sta $0404			sta 	NumBufX
.b7c3	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.b7c6	4a		lsr a				lsr 	a
.b7c7	b0 05		bcs $b7ce			bcs 	_USInt 						; if msb set do as integer
.b7c9	20 fd c5	jsr $c5fd			jsr 	FPToString 					; call fp to str otherwise
.b7cc	80 03		bra $b7d1			bra 	_USDuplicate
.b7ce	20 ed bf	jsr $bfed	_USInt:	jsr 	IntToString
.b7d1					_USDuplicate:
.b7d1	ad 04 04	lda $0404			lda 	NumBufX 					; chars in buffer
.b7d4	1a		inc a				inc 	a 							; one more for length
.b7d5	20 55 ba	jsr $ba55			jsr 	AllocateTempString 			; allocate space for it.
.b7d8	5a		phy				phy 								; save Y
.b7d9	a0 00		ldy #$00			ldy 	#0 							; start copying
.b7db	b9 05 04	lda $0405,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.b7de	20 80 ba	jsr $ba80			jsr 	WriteTempString
.b7e1	c8		iny				iny
.b7e2	cc 04 04	cpy $0404			cpy 	NumBufX 					; done the lot
.b7e5	d0 f4		bne $b7db			bne 	_USCopy
.b7e7	7a		ply				ply 								; restore Y
.b7e8	4c d4 b9	jmp $b9d4			jmp 	UnaryReturnTempStr 			; return new temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.b7eb					Unary_Asc:
.b7eb	20 97 b3	jsr $b397			jsr 	EvaluateStringX 			; string parameter
.b7ee	20 11 ba	jsr $ba11			jsr 	CheckNextRParen 			; right bracket.
.b7f1	5a		phy				phy 								; get the string length
.b7f2	a0 00		ldy #$00			ldy 	#0
.b7f4	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b7f6	f0 07		beq $b7ff			beq 	_UAIllegal 					; must be at least one character
.b7f8	c8		iny				iny
.b7f9	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; read it.
.b7fb	7a		ply				ply
.b7fc	4c 58 b6	jmp $b658			jmp 	UnarySetAInteger
.b7ff					_UAIllegal:
.b7ff	4c 3b ad	jmp $ad3b			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.b802					Unary_Len:
.b802	20 97 b3	jsr $b397			jsr 	EvaluateStringX 			; string parameter
.b805	20 11 ba	jsr $ba11			jsr 	CheckNextRParen 			; right bracket.
.b808	5a		phy				phy 								; get the string length
.b809	a0 00		ldy #$00			ldy 	#0
.b80b	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b80d	7a		ply				ply
.b80e	4c 58 b6	jmp $b658			jmp 	UnarySetAInteger

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.b811					Unary_Mid:
.b811	20 97 b3	jsr $b397			jsr 	EvaluateStringX 				; get string.
.b814	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.b817	48		pha				pha
.b818	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b81b	48		pha				pha
.b81c	20 1a ba	jsr $ba1a			jsr 	CheckNextComma 					; skip comma
.b81f	20 ac b8	jsr $b8ac			jsr 	SLIByteParameter 				; get a byte parameter (start)
.b822	48		pha				pha 									; and push it.
.b823	20 1a ba	jsr $ba1a			jsr 	CheckNextComma 					; skip comma
.b826	20 ac b8	jsr $b8ac			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.b829	48		pha				pha 									; and push it.
.b82a	80 45		bra $b871			bra 	SLIProcess
.b82c					Unary_Left:
.b82c	20 97 b3	jsr $b397			jsr 	EvaluateStringX 				; get string.
.b82f	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.b832	48		pha				pha
.b833	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b836	48		pha				pha
.b837	a9 01		lda #$01			lda 	#1 								; push start position (1)
.b839	48		pha				pha
.b83a	20 1a ba	jsr $ba1a			jsr 	CheckNextComma 					; skip comma
.b83d	20 ac b8	jsr $b8ac			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.b840	48		pha				pha 									; and push it.
.b841	80 2e		bra $b871			bra 	SLIProcess
.b843					Unary_Right:
.b843	20 97 b3	jsr $b397			jsr 	EvaluateStringX 				; get string.
.b846	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.b849	48		pha				pha
.b84a	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b84d	48		pha				pha
.b84e	da		phx				phx 									; get the string length and push on stack.
.b84f	a2 00		ldx #$00			ldx 	#0
.b851	a1 1e		lda ($1e,x)			lda		(zGenPtr,x)
.b853	fa		plx				plx
.b854	48		pha				pha
.b855	20 1a ba	jsr $ba1a			jsr 	CheckNextComma 					; skip comma
.b858	20 ac b8	jsr $b8ac			jsr 	SLIByteParameter 				; get a byte parameter.
.b85b	8d 8e 04	sta $048e			sta 	SignCount 						; save in temporary.
.b85e	68		pla				pla 									; restore string length.
.b85f	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.b860	38		sec				sec
.b861	ed 8e 04	sbc $048e			sbc 	SignCount 						; subtract characters needed, gives start position.
.b864	f0 02		beq $b868			beq 	_URStart 						; if <= 0 start from 1.
.b866	10 02		bpl $b86a			bpl 	_UROkay
.b868					_URStart:
.b868	a9 01		lda #$01			lda 	#1
.b86a					_UROkay:
.b86a	48		pha				pha 									; push start
.b86b	ad 8e 04	lda $048e			lda 	SignCount 						; push count of characters
.b86e	48		pha				pha
.b86f	80 00		bra $b871			bra 	SLIProcess
.b871					SLIProcess:
.b871	20 11 ba	jsr $ba11			jsr 	CheckNextRParen 				; closing right bracket.
.b874	68		pla				pla
.b875	8d 92 04	sta $0492			sta 	SliceCount 						; count in signcount
.b878	1a		inc a				inc 	a 								; allocate +1 for it.
.b879	20 55 ba	jsr $ba55			jsr 	AllocateTempString
.b87c	68		pla				pla 									; pop start number off stack.
.b87d	f0 3f		beq $b8be			beq 	SLIError 						; exit if start = 0
.b87f	8d 91 04	sta $0491			sta 	SliceStart
.b882	68		pla				pla  									; pop string address.
.b883	85 1f		sta $1f				sta 	zGenPtr+1
.b885	68		pla				pla
.b886	85 1e		sta $1e				sta 	zGenPtr
.b888	da		phx				phx
.b889	5a		phy				phy
.b88a	a2 00		ldx #$00			ldx 	#0 								; point to string length.
.b88c	ac 91 04	ldy $0491			ldy 	SliceStart 						; start of the string (+1 for count)
.b88f					_SLICopy:
.b88f	ad 92 04	lda $0492			lda 	SliceCount 						; done count characters
.b892	f0 12		beq $b8a6			beq 	_SLIExit
.b894	ce 92 04	dec $0492			dec 	SliceCount
.b897	98		tya				tya 									; index of character
.b898	c1 1e		cmp ($1e,x)			cmp 	(zGenPtr,x)						; compare against length
.b89a	f0 02		beq $b89e			beq 	_SLIOk 							; if equal, okay.
.b89c	b0 08		bcs $b8a6			bcs 	_SLIExit 						; if past end, then exit.
.b89e	b1 1e		lda ($1e),y	_SLIOk:	lda 	(zGenPtr),y 					; copy one character
.b8a0	c8		iny				iny
.b8a1	20 80 ba	jsr $ba80			jsr 	WriteTempString
.b8a4	80 e9		bra $b88f			bra 	_SLICopy 						; go round till copied characters
.b8a6					_SLIExit:
.b8a6	7a		ply				ply 									; restore YX
.b8a7	fa		plx				plx
.b8a8	4c d4 b9	jmp $b9d4			jmp 	UnaryReturnTempStr 				; return new temporary string.
.b8ab	ea		nop				nop
.b8ac					SLIByteParameter:
.b8ac	20 8e b3	jsr $b38e			jsr 	EvaluateIntegerX 				; get integer
.b8af	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.b8b2	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.b8b5	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.b8b8	d0 04		bne $b8be			bne 	SLIError
.b8ba	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b8bd	60		rts				rts
.b8be					SLIError:
.b8be	4c 3b ad	jmp $ad3b			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.b8c1					Unary_Hex:
.b8c1	20 8e b3	jsr $b38e			jsr 	EvaluateIntegerX 			; numeric parameter
.b8c4	20 11 ba	jsr $ba11			jsr 	CheckNextRParen 			; right bracket.
.b8c7	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.b8c9	20 55 ba	jsr $ba55			jsr 	AllocateTempString			; allocate string space
.b8cc	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.b8cf	20 f6 b8	jsr $b8f6			jsr 	_UHConvert
.b8d2	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.b8d5	20 f6 b8	jsr $b8f6			jsr 	_UHConvert
.b8d8	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b8db	20 f6 b8	jsr $b8f6			jsr 	_UHConvert
.b8de	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b8e1	20 f6 b8	jsr $b8f6			jsr 	_UHConvert
.b8e4	5a		phy				phy 								; get length of new string
.b8e5	a0 00		ldy #$00			ldy 	#0
.b8e7	b1 20		lda ($20),y			lda 	(zTempStr),y
.b8e9	7a		ply				ply
.b8ea	c9 00		cmp #$00			cmp 	#0
.b8ec	d0 05		bne $b8f3			bne 	_UHExit 					; if it was non zero okay
.b8ee	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.b8f0	20 80 ba	jsr $ba80			jsr 	WriteTempString
.b8f3					_UHExit:
.b8f3	4c d4 b9	jmp $b9d4			jmp 	UnaryReturnTempStr 			; return new temporary string.
.b8f6					_UHConvert:
.b8f6	48		pha				pha
.b8f7	4a		lsr a				lsr 	a 							; do MSB
.b8f8	4a		lsr a				lsr 	a
.b8f9	4a		lsr a				lsr 	a
.b8fa	4a		lsr a				lsr 	a
.b8fb	20 ff b8	jsr $b8ff			jsr 	_UHNibble
.b8fe	68		pla				pla 								; do LSB
.b8ff					_UHNibble:
.b8ff	29 0f		and #$0f			and 	#15 						; get nibble
.b901	d0 0c		bne $b90f			bne 	_UHNonZero
.b903	5a		phy				phy									; get the length
.b904	a0 00		ldy #$00			ldy 	#0
.b906	b1 20		lda ($20),y			lda 	(zTempStr),y
.b908	7a		ply				ply
.b909	c9 00		cmp #$00			cmp 	#0 							; suppress leading zeros.
.b90b	f0 0d		beq $b91a			beq 	_UHExit2
.b90d	a9 00		lda #$00			lda 	#0
.b90f					_UHNonZero:
.b90f	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.b911	90 02		bcc $b915			bcc 	_UHDigit
.b913	69 06		adc #$06			adc 	#7-1
.b915					_UHDigit:
.b915	69 30		adc #$30			adc 	#48
.b917	20 80 ba	jsr $ba80			jsr 	WriteTempString				; output.
.b91a					_UHExit2:
.b91a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.b91b					Unary_Dec:
.b91b	20 97 b3	jsr $b397			jsr 	EvaluateStringX 			; string parameter
.b91e	20 11 ba	jsr $ba11			jsr 	CheckNextRParen 			; right bracket.
.b921	5a		phy				phy
.b922	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.b924	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b926	f0 4c		beq $b974			beq 	_UDFail 					; must fail if zero.
.b928	8d 8e 04	sta $048e			sta 	SignCount 					; use SignCount as a counter
.b92b	a9 00		lda #$00			lda 	#0 							; set result to zero integer.
.b92d	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b930	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b933	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b936	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b939	a9 01		lda #$01			lda 	#1
.b93b	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.b93e					_UDConvertLoop:
.b93e	5a		phy				phy 								; shift mantissa left 4
.b93f	a0 04		ldy #$04			ldy 	#4
.b941					_UDShift:
.b941	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x
.b944	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.b947	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.b94a	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.b94d	88		dey				dey
.b94e	d0 f1		bne $b941			bne 	_UDShift
.b950	7a		ply				ply
.b951	c8		iny				iny 								; next character
.b952	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; fetch it.
.b954	20 77 b9	jsr $b977			jsr 	ConvertUpper 				; convert to U/C
.b957	c9 30		cmp #$30			cmp 	#"0"
.b959	90 19		bcc $b974			bcc 	_UDFail
.b95b	c9 3a		cmp #$3a			cmp 	#"9"+1
.b95d	90 06		bcc $b965			bcc 	_UDOkay
.b95f	e9 37		sbc #$37			sbc 	#7+"0" 						; alpha fudge
.b961	c9 10		cmp #$10			cmp 	#16
.b963	b0 0f		bcs $b974			bcs 	_UDFail
.b965					_UDOkay:
.b965	29 0f		and #$0f			and 	#15 						; nibble only
.b967	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x
.b96a	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b96d	ce 8e 04	dec $048e			dec 	SignCount 					; do it for each character
.b970	d0 cc		bne $b93e			bne 	_UDConvertLoop
.b972	7a		ply				ply
.b973	60		rts				rts
.b974					_UDFail:
.b974	4c 3b ad	jmp $ad3b			jmp 	BadParamError
.b977					ConvertUpper:
.b977	c9 61		cmp #$61			cmp 	#"a"
.b979	90 07		bcc $b982			bcc 	_CUExit
.b97b	c9 7b		cmp #$7b			cmp 	#"z"+1
.b97d	b0 03		bcs $b982			bcs 	_CUExit
.b97f	38		sec				sec
.b980	e9 20		sbc #$20			sbc 	#32
.b982	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.b983					Unary_Chr:
.b983	20 8e b3	jsr $b38e			jsr 	EvaluateIntegerX			; numeric parameter
.b986	20 11 ba	jsr $ba11			jsr 	CheckNextRParen 			; right bracket.
.b989	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.b98c	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.b98f	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.b992	d0 0e		bne $b9a2			bne 	_UCChar
.b994	a9 01		lda #$01			lda 	#1 							; one character string
.b996	20 55 ba	jsr $ba55			jsr 	AllocateTempString
.b999	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.b99c	20 80 ba	jsr $ba80			jsr 	WriteTempString
.b99f	4c d4 b9	jmp $b9d4			jmp 	UnaryReturnTempStr
.b9a2					_UCChar:
.b9a2	4c 3b ad	jmp $ad3b			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.b9a5					Unary_Spc:
.b9a5	20 8e b3	jsr $b38e			jsr 	EvaluateIntegerX 			; numeric parameter
.b9a8	20 11 ba	jsr $ba11			jsr 	CheckNextRParen 			; right bracket.
.b9ab	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.b9ae	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.b9b1	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.b9b4	d0 1b		bne $b9d1			bne 	_USSize
.b9b6	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b9b9	c9 fe		cmp #$fe			cmp 	#maxString+1
.b9bb	b0 14		bcs $b9d1			bcs 	_USSize
.b9bd	48		pha				pha 								; save length
.b9be	1a		inc a				inc 	a 							; allocate one more.
.b9bf	20 55 ba	jsr $ba55			jsr 	AllocateTempString
.b9c2	68		pla				pla 								; get length
.b9c3	f0 0f		beq $b9d4			beq 	UnaryReturnTempStr 			; return the current temp string
.b9c5					_USLoop:
.b9c5	48		pha				pha
.b9c6	a9 20		lda #$20			lda 	#" "
.b9c8	20 80 ba	jsr $ba80			jsr 	WriteTempString
.b9cb	68		pla				pla
.b9cc	3a		dec a				dec 	a
.b9cd	d0 f6		bne $b9c5			bne 	_USLoop
.b9cf	80 03		bra $b9d4			bra 	UnaryReturnTempStr
.b9d1					_USSize:
.b9d1	4c 3b ad	jmp $ad3b			jmp 	BadParamError
.b9d4					UnaryReturnTempStr:
.b9d4	a5 20		lda $20				lda 	zTempStr 					; copy temp string addr -> mantissa
.b9d6	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b9d9	a5 21		lda $21				lda 	zTempStr+1
.b9db	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b9de	a9 02		lda #$02			lda 	#2 							; set type to string
.b9e0	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.b9e3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/4510.asm

.b9e4	db		phz		MemRead:phz
.b9e5	8d 8e 04	sta $048e			sta 	SignCount 					; save count
.b9e8	a3 00		ldz #$00			ldz 	#0 							; start from here
.b9ea	ea		nop		_MLoop1:nop
.b9eb	b2 1a		lda ($1a),z			lda 	(zlTemp1),z 				; read the long address
.b9ed	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; copy into mantissa
.b9f0	1b		inz				inz 								; next to copy
.b9f1	e8		inx				inx
.b9f2	dc 8e 04	cpz $048e			cpz 	SignCount 					; do required # of bytes.
.b9f5	d0 f3		bne $b9ea			bne 	_MLoop1
.b9f7	fb		plz				plz
.b9f8	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.b9f9					CheckNextToken:
.b9f9	ea		nop				nop
.b9fa	d2 16		cmp ($16),z			cmp 	(zCodePtr),z
.b9fc	d0 02		bne $ba00			bne 	CTFail 						; no, then fail
.b9fe	1b		inz				inz
.b9ff	60		rts				rts
.ba00					CTFail:
.ba00	20 4c ad	jsr $ad4c			jsr ERR_Handler
>ba03	4d 69 73 73 69 6e 67 20			.text "Missing token",0
>ba0b	74 6f 6b 65 6e 00
.ba11					CheckNextRParen:
.ba11	ea		nop				nop
.ba12	b2 16		lda ($16),z			lda 	(zCodePtr),z
.ba14	c9 be		cmp #$be			cmp 	#token_rparen
.ba16	d0 e8		bne $ba00			bne 	CTFail
.ba18	1b		inz				inz
.ba19	60		rts				rts
.ba1a					CheckNextComma:
.ba1a	ea		nop				nop
.ba1b	b2 16		lda ($16),z			lda 	(zCodePtr),z
.ba1d	c9 bf		cmp #$bf			cmp 	#token_comma
.ba1f	d0 df		bne $ba00			bne 	CTFail
.ba21	1b		inz				inz
.ba22	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/concrete.asm

.ba23					StringConcrete:
.ba23	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; save source to zTemp1
.ba26	85 10		sta $10				sta 	zTemp1
.ba28	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.ba2b	85 11		sta $11				sta 	zTemp1+1
.ba2d	a0 00		ldy #$00			ldy 	#0 							; subtract the length+1 (clc) of the string.
.ba2f	18		clc				clc 								; from the string pointer
.ba30	ad 00 04	lda $0400			lda 	StringPtr 					; and put in zTemp2 as well
.ba33	f1 10		sbc ($10),y			sbc 	(zTemp1),y
.ba35	8d 00 04	sta $0400			sta 	StringPtr
.ba38	85 12		sta $12				sta 	zTemp2
.ba3a	ad 01 04	lda $0401			lda 	StringPtr+1
.ba3d	e9 00		sbc #$00			sbc 	#0
.ba3f	8d 01 04	sta $0401			sta 	StringPtr+1
.ba42	85 13		sta $13				sta 	zTemp2+1
.ba44	b1 10		lda ($10),y			lda 	(zTemp1),y 					; length add one for count
.ba46	1a		inc a				inc 	a
.ba47	aa		tax				tax
.ba48	b1 10		lda ($10),y	_SCCopy:lda 	(zTemp1),y 					; copy whole thing including length
.ba4a	91 12		sta ($12),y			sta 	(zTemp2),y
.ba4c	c8		iny				iny
.ba4d	ca		dex				dex
.ba4e	d0 f8		bne $ba48			bne 	_SCCopy
.ba50	a5 13		lda $13				lda 	zTemp2+1 					; return concrete string in AX
.ba52	a6 12		ldx $12				ldx 	zTemp2
.ba54	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.ba55					AllocateTempString:
.ba55	48		pha				pha 								; save required count.
.ba56	a5 21		lda $21				lda 	zTempStr+1 					; check if initialised yet ?
.ba58	d0 0b		bne $ba65			bne 	_ATSInitialised
.ba5a	ad 00 04	lda $0400			lda 	StringPtr 					; set temporary string ptr 1 page below available
.ba5d	85 20		sta $20				sta 	zTempStr					; space, this is for strings to be concreted.
.ba5f	ad 01 04	lda $0401			lda 	StringPtr+1
.ba62	3a		dec a				dec 	a
.ba63	85 21		sta $21				sta 	zTempStr+1
.ba65					_ATSInitialised:
.ba65	68		pla				pla 								; get required count back.
.ba66	49 ff		eor #$ff			eor 	#$FF 						; negate 2's complement.
.ba68	1a		inc a				inc 	a
.ba69	18		clc				clc
.ba6a	65 20		adc $20				adc 	zTempStr 					; "add" to the temp string pointer
.ba6c	85 20		sta $20				sta 	zTempStr
.ba6e	a9 ff		lda #$ff			lda 	#$FF
.ba70	65 21		adc $21				adc 	zTempStr+1
.ba72	85 21		sta $21				sta 	zTempStr+1
.ba74	a9 00		lda #$00			lda 	#0 							; clear temp string.
.ba76	5a		phy				phy
.ba77	a8		tay				tay
.ba78	91 20		sta ($20),y			sta 	(zTempStr),y
.ba7a	7a		ply				ply
.ba7b	1a		inc a				inc 	a 							; reset the write index.
.ba7c	8d 8f 04	sta $048f			sta 	TempStringWriteIndex
.ba7f	60		rts				rts
.ba80					WriteTempString:
.ba80	5a		phy				phy 								; save Y
.ba81	ac 8f 04	ldy $048f			ldy 	TempStringWriteIndex	 	; write position.
.ba84	91 20		sta ($20),y			sta 	(zTempStr),y 				; write character out.
.ba86	ee 8f 04	inc $048f			inc 	TempStringWriteIndex 		; increment the write position.
.ba89	98		tya				tya 								; unchanged Y is now length
.ba8a	a0 00		ldy #$00			ldy 	#0
.ba8c	91 20		sta ($20),y			sta 	(zTempStr),y
.ba8e	7a		ply				ply 								; restore Y and exit
.ba8f	60		rts				rts
.ba90					CreateTempStringCopy:
.ba90	da		phx				phx 								; save X
.ba91	ea		nop				nop
.ba92	b2 16		lda ($16),z			lda 	(zCodePtr),z
.ba94	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.ba95	20 55 ba	jsr $ba55			jsr 	AllocateTempString 			; allocate memory for temporary string.
.ba98	ea		nop				nop
.ba99	b2 16		lda ($16),z			lda 	(zCodePtr),z
.ba9b	1b		inz				inz
.ba9c	3a		dec a				dec 	a 							; make the actual length in charactes
.ba9d	3a		dec a				dec 	a
.ba9e	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.baa0	81 20		sta ($20,x)			sta 	(zTempStr,x)
.baa2	85 1a		sta $1a				sta 	zLTemp1 					; that's used as a count.
.baa4	09 00		ora #$00			ora 	#0 							; if zero already, exit
.baa6	f0 0f		beq $bab7			beq 	_CTSCExit
.baa8					_CTSCLoop:
.baa8	ea		nop				nop
.baa9	b2 16		lda ($16),z			lda 	(zCodePtr),z
.baab	1b		inz				inz
.baac	5a		phy				phy 								; save in Y
.baad	e8		inx				inx 								; bump index
.baae	da		phx				phx 								; index into Y
.baaf	7a		ply				ply
.bab0	91 20		sta ($20),y			sta 	(zTempStr),y 				; save at index
.bab2	7a		ply				ply 								; restore Y
.bab3	c6 1a		dec $1a				dec 	zLTemp1 					; do for each character
.bab5	d0 f1		bne $baa8			bne 	_CTSCLoop
.bab7					_CTSCExit:
.bab7	fa		plx				plx 								; restore X
.bab8	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/variables.asm

.bab9					VariableFind:
.bab9	20 24 bb	jsr $bb24			jsr 	VariableExtract 		; find out all about it ....
.babc	20 c8 bd	jsr $bdc8			jsr 	VariableLocate 			; does it already exist ?
.babf	b0 03		bcs $bac4			bcs 	_VFExists 				; if so, use that.
.bac1	20 b2 bb	jsr $bbb2			jsr 	VariableCreate 			; otherwise create it.
.bac4					_VFExists:
.bac4	a5 24		lda $24				lda 	zVarType 				; is it still an array ?
.bac6	29 01		and #$01			and 	#1
.bac8	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.baca	d0 28		bne $baf4			bne 	_VFSingleElement
.bacc					_VFNextIndex:
.bacc	a5 22		lda $22				lda 	zVarDataPtr 			; push the data ptr and type on the stack.
.bace	48		pha				pha
.bacf	a5 23		lda $23				lda 	zVarDataPtr+1
.bad1	48		pha				pha
.bad2	a5 24		lda $24				lda 	zVarType
.bad4	48		pha				pha
.bad5	20 8e b3	jsr $b38e			jsr 	EvaluateIntegerX 		; calculate the index.
.bad8	68		pla				pla 							; restore and index.
.bad9	85 24		sta $24				sta 	zVarType
.badb	68		pla				pla
.badc	85 23		sta $23				sta 	zVarDataPtr+1
.bade	68		pla				pla
.badf	85 22		sta $22				sta 	zVarDataPtr
.bae1	20 3d bc	jsr $bc3d			jsr 	ArrayIndexFollow 		; do the index.
.bae4	a5 24		lda $24				lda 	zVarType 				; is it still an array ??
.bae6	29 01		and #$01			and 	#1
.bae8	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.baea	d0 05		bne $baf1			bne 	_VFArrayDone 			; if so then exit.
.baec	20 1a ba	jsr $ba1a			jsr 	CheckNextComma 			; comma should follow
.baef	80 db		bra $bacc			bra 	_VFNextIndex
.baf1					_VFArrayDone:
.baf1	20 11 ba	jsr $ba11			jsr 	CheckNextRParen 		; check closing right bracket.
.baf4					_VFSingleElement:
.baf4	60		rts				rts
.baf5					VariableClear:
.baf5	48		pha				pha 							; save registers
.baf6	da		phx				phx
.baf7	a2 00		ldx #$00			ldx 	#0 						; clear out the hash table.
.baf9	8a		txa				txa
.bafa	9d 25 04	sta $0425,x	_VCLoop:sta 	HashTableBase,x
.bafd	e8		inx				inx
.bafe	e0 60		cpx #$60			cpx 	#HashTableEnd-HashTableBase
.bb00	d0 f8		bne $bafa			bne 	_VCLoop
.bb02	a9 00		lda #$00			lda 	#VariableMemory & $FF	; reset the free variable memory pointer
.bb04	8d 02 04	sta $0402			sta 	VarMemPtr
.bb07	a9 40		lda #$40			lda 	#VariableMemory >> 8
.bb09	8d 03 04	sta $0403			sta 	VarMemPtr+1
.bb0c	fa		plx				plx 							; restore registers
.bb0d	68		pla				pla
.bb0e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/extract.asm

.bb0f					VariableNameError:
.bb0f	20 4c ad	jsr $ad4c			jsr ERR_Handler
>bb12	42 61 64 20 56 61 72 69			.text "Bad Variable Name",0
>bb1a	61 62 6c 65 20 4e 61 6d 65 00
.bb24					VariableExtract:
.bb24	da		phx				phx 							; save X.
.bb25	a9 ba		lda #$ba			lda 	#token_hashlParen  		; set the type to #( e.g. real array.
.bb27	8d 85 04	sta $0485			sta 	Var_Type
.bb2a	8d 86 04	sta $0486			sta 	Var_Hash 				; we initialise the hash with this. It doesn't matter
.bb2d	ea		nop				nop
.bb2e	b2 16		lda ($16),z			lda 	(zCodePtr),z
.bb30	c9 00		cmp #$00			cmp 	#0 						; first one must be A-Z
.bb32	f0 db		beq $bb0f			beq 	VariableNameError
.bb34	c9 1b		cmp #$1b			cmp 	#26+1
.bb36	b0 d7		bcs $bb0f			bcs 	VariableNameError
.bb38	a2 ff		ldx #$ff			ldx 	#255 					; now copy it into the variable buffer.
.bb3a					_VECopyBuffer:
.bb3a	e8		inx				inx
.bb3b	e0 1f		cpx #$1f			cpx 	#31 					; too long
.bb3d	f0 d0		beq $bb0f			beq 	VariableNameError
.bb3f	9d 05 04	sta $0405,x			sta 	Var_Buffer,x 			; save character
.bb42	18		clc				clc  							; update the hash value for it.
.bb43	6d 86 04	adc $0486			adc 	Var_Hash
.bb46	8d 86 04	sta $0486			sta 	Var_Hash
.bb49	1b		inz				inz
.bb4a	ea		nop				nop
.bb4b	b2 16		lda ($16),z			lda 	(zCodePtr),z
.bb4d	c9 00		cmp #$00			cmp 	#0 						; zero or token, end of variable
.bb4f	f0 0e		beq $bb5f			beq 	_VECopyEnd
.bb51	30 0c		bmi $bb5f			bmi 	_VECopyEnd
.bb53	c9 1b		cmp #$1b			cmp 	#26+1 					; A-Z continue copying
.bb55	90 e3		bcc $bb3a			bcc 	_VECopyBuffer
.bb57	c9 30		cmp #$30			cmp 	#"0" 					; 0-9 copy as well.
.bb59	90 04		bcc $bb5f			bcc 	_VECopyEnd
.bb5b	c9 3a		cmp #$3a			cmp 	#"9"+1
.bb5d	90 db		bcc $bb3a			bcc 	_VECopyBuffer
.bb5f					_VECopyEnd:
.bb5f	1b		inz				inz
.bb60	c9 b7		cmp #$b7			cmp 	#token_Dollar 			; first type token.
.bb62	90 04		bcc $bb68			bcc 	_VEDefaultRequired
.bb64	c9 bd		cmp #$bd			cmp 	#token_PercentLParen+1	; last type token.
.bb66	90 0b		bcc $bb73			bcc 	_VEHaveType
.bb68					_VEDefaultRequired:
.bb68	c9 bd		cmp #$bd			cmp 	#token_LParen 			; if it ends in ( then use the real array
.bb6a	f0 04		beq $bb70			beq 	_VESetType 				; default set above.
.bb6c	ce 85 04	dec $0485			dec 	Var_Type 				; this changes that default to the variable default
.bb6f	3b		dez				dez
.bb70					_VESetType:
.bb70	ad 85 04	lda $0485			lda 	Var_Type 				; get type ....
.bb73					_VEHaveType:
.bb73	8d 85 04	sta $0485			sta 	Var_Type 				; save as type.
.bb76	bd 05 04	lda $0405,x			lda 	Var_Buffer,x 			; set bit 7 of name, marks the end.
.bb79	09 80		ora #$80			ora 	#$80
.bb7b	9d 05 04	sta $0405,x			sta 	Var_Buffer,x
.bb7e	e8		inx				inx 							; offset 3 => length 4.
.bb7f	8e 87 04	stx $0487			stx 	Var_Length 				; save length of variable name.
.bb82	ad 85 04	lda $0485			lda 	Var_Type 				; get offset of var type from first type token
.bb85	38		sec				sec
.bb86	e9 b7		sbc #$b7			sbc 	#token_Dollar
.bb88	0a		asl a				asl 	a 						; multiply by 16. This requires HashTableSize
.bb89	0a		asl a				asl 	a 						; in data.asm to be 8 (8 sets of links,2 bytes each)
.bb8a	0a		asl a				asl 	a
.bb8b	0a		asl a				asl 	a
.bb8c	8d 88 04	sta $0488			sta 	Var_HashAddress
.bb8f	ad 86 04	lda $0486			lda 	Var_Hash 				; get the hash
.bb92	29 07		and #$07			and 	#(HashTableSize-1) 		; force into range 0-tableSize-1
.bb94	0a		asl a				asl 	a 						; double it (2 bytes per entry) & clears carry
.bb95	6d 88 04	adc $0488			adc 	Var_HashAddress 		; add table offset.
.bb98	69 25		adc #$25			adc 	#HashTableBase & $FF 	; now the low byte of the actual table address
.bb9a	8d 88 04	sta $0488			sta 	Var_HashAddress
.bb9d	a2 05		ldx #$05			ldx 	#5 						; hash is 5 bytes (real)
.bb9f	ad 85 04	lda $0485			lda 	Var_Type
.bba2	c9 b9		cmp #$b9			cmp 	#token_Hash
.bba4	f0 07		beq $bbad			beq 	_VEHaveSize
.bba6	ca		dex				dex
.bba7	c9 bb		cmp #$bb			cmp 	#token_Percent 			; percent is 4 bytes (integer)
.bba9	f0 02		beq $bbad			beq 	_VEHaveSize
.bbab	a2 02		ldx #$02			ldx 	#2 						; everything else is two.
.bbad					_VEHaveSize:
.bbad	8e 89 04	stx $0489			stx 	Var_DataSize
.bbb0	fa		plx				plx
.bbb1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varcreate.asm

.bbb2					VariableCreate:
.bbb2	da		phx				phx
.bbb3	5a		phy				phy
.bbb4	ad 02 04	lda $0402			lda 	VarMemPtr 					; get address of next free into zTemp1
.bbb7	85 10		sta $10				sta 	zTemp1
.bbb9	ad 03 04	lda $0403			lda 	VarMemPtr+1
.bbbc	85 11		sta $11				sta 	zTemp1+1
.bbbe	ad 89 04	lda $0489			lda 	Var_DataSize 				; bytes for the data bit
.bbc1	18		clc				clc
.bbc2	6d 87 04	adc $0487			adc 	Var_Length 					; add the length of the name
.bbc5	69 03		adc #$03			adc 	#3 							; 3 for the link and the hash.
.bbc7	6d 02 04	adc $0402			adc 	VarMemPtr 					; add to variable memory pointer
.bbca	8d 02 04	sta $0402			sta 	VarMemPtr
.bbcd	90 03		bcc $bbd2			bcc 	_VCNoCarry
.bbcf	ee 03 04	inc $0403			inc 	VarMemPtr+1
.bbd2					_VCNoCarry:
.bbd2	ad 88 04	lda $0488			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.bbd5	85 12		sta $12				sta 	zTemp2
.bbd7	a9 04		lda #$04			lda 	#HashTableBase >> 8
.bbd9	85 13		sta $13				sta 	zTemp2+1
.bbdb	a0 00		ldy #$00			ldy 	#0 							; put current hash link in position.
.bbdd	b1 12		lda ($12),y			lda 	(zTemp2),y
.bbdf	91 10		sta ($10),y			sta 	(zTemp1),y
.bbe1	c8		iny				iny
.bbe2	b1 12		lda ($12),y			lda 	(zTemp2),y
.bbe4	91 10		sta ($10),y			sta 	(zTemp1),y
.bbe6	c8		iny				iny
.bbe7	ad 86 04	lda $0486			lda 	Var_Hash 					; write the hash out.
.bbea	91 10		sta ($10),y			sta 	(zTemp1),y
.bbec	c8		iny				iny
.bbed	a2 00		ldx #$00			ldx 	#0 							; copy the name out.
.bbef					_VCCopyName:
.bbef	bd 05 04	lda $0405,x			lda 	Var_Buffer,x
.bbf2	91 10		sta ($10),y			sta 	(zTemp1),y
.bbf4	e8		inx				inx
.bbf5	c8		iny				iny
.bbf6	ec 87 04	cpx $0487			cpx 	Var_Length
.bbf9	d0 f4		bne $bbef			bne 	_VCCopyName
.bbfb	5a		phy				phy 								; save the data offset.
.bbfc	ae 89 04	ldx $0489			ldx 	Var_DataSize 				; and write the data out.
.bbff	a9 00		lda #$00			lda 	#0 							; which is all zeroes.
.bc01					_VCClearData:
.bc01	91 10		sta ($10),y			sta 	(zTemp1),y
.bc03	c8		iny				iny
.bc04	ca		dex				dex
.bc05	d0 fa		bne $bc01			bne 	_VCClearData
.bc07	68		pla				pla 								; offset to the data
.bc08	18		clc				clc
.bc09	65 10		adc $10				adc 	zTemp1 						; add to start and save as data pointer.
.bc0b	85 22		sta $22				sta 	zVarDataPtr
.bc0d	a5 11		lda $11				lda 	zTemp1+1
.bc0f	69 00		adc #$00			adc 	#0
.bc11	85 23		sta $23				sta 	zVarDataPtr+1
.bc13	ad 85 04	lda $0485			lda 	Var_Type 					; and set the type.
.bc16	85 24		sta $24				sta 	zVarType
.bc18	a5 10		lda $10				lda 	zTemp1 						; fix hash link to point to new record
.bc1a	a0 00		ldy #$00			ldy 	#0
.bc1c	91 12		sta ($12),y			sta 	(zTemp2),y
.bc1e	c8		iny				iny
.bc1f	a5 11		lda $11				lda 	zTemp1+1
.bc21	91 12		sta ($12),y			sta 	(zTemp2),y
.bc23	ad 85 04	lda $0485			lda 	Var_Type 					; array ? if so create the empty one.
.bc26	29 01		and #$01			and 	#1
.bc28	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.bc2a	d0 0e		bne $bc3a			bne 	_VCNotArray
.bc2c	a2 00		ldx #$00			ldx 	#0 							; call recursive array creator
.bc2e	20 dd bc	jsr $bcdd			jsr 	ArrayCreate
.bc31	5a		phy				phy 								; save YA at zVarDataPtr
.bc32	a0 00		ldy #$00			ldy 	#0
.bc34	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.bc36	c8		iny				iny
.bc37	68		pla				pla
.bc38	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.bc3a					_VCNotArray:
.bc3a	7a		ply				ply
.bc3b	fa		plx				plx
.bc3c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arrayidx.asm

.bc3d					ArrayIndexFollow:
.bc3d	5a		phy				phy
.bc3e	a0 00		ldy #$00			ldy 	#0 							; make zVarDataPtr point to the array.
.bc40	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; e.g. it points to itself.
.bc42	48		pha				pha
.bc43	c8		iny				iny
.bc44	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.bc46	85 23		sta $23				sta 	zVarDataPtr+1
.bc48	68		pla				pla
.bc49	85 22		sta $22				sta 	zVarDataPtr
.bc4b	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 			; MSB of 16 bit integer and bytes 2&3
.bc4e	29 80		and #$80			and 	#$80 						; must be zero.
.bc50	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.bc53	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.bc56	d0 5f		bne $bcb7			bne 	_AIFError
.bc58	a0 00		ldy #$00			ldy 	#0 							; calculate size - current - 1
.bc5a	18		clc				clc
.bc5b	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.bc5d	fd 08 03	sbc $0308,x			sbc 	XS_Mantissa+0,x
.bc60	c8		iny				iny
.bc61	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.bc63	08		php				php 								; clear bit 7 retaining borrow.
.bc64	29 7f		and #$7f			and 	#$7F
.bc66	28		plp				plp
.bc67	fd 09 03	sbc $0309,x			sbc 	XS_Mantissa+1,x
.bc6a	90 4b		bcc $bcb7			bcc 	_AIFError 					; eror if size-current < 0
.bc6c	bd 08 03	lda $0308,x			lda  	XS_Mantissa+0,x 			; copy and double the index
.bc6f	0a		asl a				asl 	a 							; (e.g. index * 2)
.bc70	85 10		sta $10				sta 	zTemp1
.bc72	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.bc75	2a		rol a				rol 	a
.bc76	85 11		sta $11				sta 	zTemp1+1
.bc78	a0 01		ldy #$01			ldy 	#1 							; is this a data entry.
.bc7a	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; if so, then type is unchanged, offset set
.bc7c	30 1f		bmi $bc9d			bmi 	_AIFCalculate
.bc7e	c6 24		dec $24				dec 	zVarType 					; converts from an array to a type.
.bc80	a5 24		lda $24				lda 	zVarType 					; check that type
.bc82	c9 b7		cmp #$b7			cmp 	#token_Dollar 				; if string, use x 2
.bc84	f0 17		beq $bc9d			beq 	_AIFCalculate
.bc86	06 10		asl $10				asl 	zTemp1			 			; double the index
.bc88	26 11		rol $11				rol 	zTemp1+1					; (e.g. index * 4)
.bc8a	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if integer, use x 4
.bc8c	f0 0f		beq $bc9d			beq 	_AIFCalculate
.bc8e	18		clc				clc 								; add the original mantissa in again
.bc8f	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; which makes it x5, for float.
.bc92	65 10		adc $10				adc 	zTemp1
.bc94	85 10		sta $10				sta 	zTemp1
.bc96	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.bc99	65 11		adc $11				adc 	zTemp1+1
.bc9b	85 11		sta $11				sta 	zTemp1+1
.bc9d					_AIFCalculate:
.bc9d	18		clc				clc 								; add index x 2,4 or 5 to base
.bc9e	a5 22		lda $22				lda 	zVarDataPtr
.bca0	65 10		adc $10				adc 	zTemp1
.bca2	85 22		sta $22				sta 	zVarDataPtr
.bca4	a5 23		lda $23				lda 	zVarDataPtr+1
.bca6	65 11		adc $11				adc 	zTemp1+1
.bca8	85 23		sta $23				sta 	zVarDataPtr+1
.bcaa	18		clc				clc 								; add 2 more for the length prefix.
.bcab	a5 22		lda $22				lda 	zVarDataPtr
.bcad	69 02		adc #$02			adc 	#2
.bcaf	85 22		sta $22				sta 	zVarDataPtr
.bcb1	90 02		bcc $bcb5			bcc 	_AIFNoBump
.bcb3	e6 23		inc $23				inc 	zVarDataPtr+1
.bcb5					_AIFNoBump:
.bcb5	7a		ply				ply
.bcb6	60		rts				rts
.bcb7					_AIFError:
.bcb7	20 4c ad	jsr $ad4c			jsr ERR_Handler
>bcba	42 61 64 20 61 72 72 61			.text "Bad array index",0
>bcc2	79 20 69 6e 64 65 78 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arraydef.asm

.bcca					ArrayResetDefault:
.bcca	a9 0b		lda #$0b			lda 	#11 						; 0..10 one array
.bccc	8d 97 04	sta $0497			sta 	ArrayDef+0
.bccf	a9 00		lda #$00			lda 	#0
.bcd1	8d 98 04	sta $0498			sta 	ArrayDef+1
.bcd4	a9 ff		lda #$ff			lda 	#$FF
.bcd6	8d 99 04	sta $0499			sta 	ArrayDef+2 					; $FFFF implies no second element.
.bcd9	8d 9a 04	sta $049a			sta 	ArrayDef+3					; (test bit 7 of 2nd byte)
.bcdc	60		rts				rts
.bcdd					ArrayCreate:
.bcdd	bd 97 04	lda $0497,x			lda 	ArrayDef+0,x 				; put size x 2 in zTemp1
.bce0	0a		asl a				asl 	a
.bce1	85 10		sta $10				sta 	zTemp1
.bce3	bd 98 04	lda $0498,x			lda 	ArrayDef+1,x
.bce6	2a		rol a				rol 	a
.bce7	85 11		sta $11				sta 	zTemp1+1
.bce9	bd 9a 04	lda $049a,x			lda 	ArrayDef+3,x 				; if this is the last element it's array of ptrs.
.bcec	10 22		bpl $bd10			bpl 	_ACSized 					; if not multiply size x 2 (str) 4 (int) 5 (real)
.bcee	ad 85 04	lda $0485			lda 	Var_Type 					; check the type
.bcf1	c9 b8		cmp #$b8			cmp 	#token_DollarLParen 		; also if it is an array of strings $(
.bcf3	f0 1b		beq $bd10			beq 	_ACSized
.bcf5	06 10		asl $10				asl 	zTemp1 						; double again
.bcf7	26 11		rol $11				rol 	zTemp1+1
.bcf9	b0 6f		bcs $bd6a			bcs 	ArrayIndexError 			; too large.
.bcfb	c9 bc		cmp #$bc			cmp 	#token_PercentLParen 		; if %( four bytes/entry is enough.
.bcfd	f0 11		beq $bd10			beq 	_ACSized
.bcff	18		clc				clc 								; add original value x 5 for reals.
.bd00	a5 10		lda $10				lda 	zTemp1
.bd02	7d 97 04	adc $0497,x			adc 	ArrayDef+0,x
.bd05	85 10		sta $10				sta 	zTemp1
.bd07	a5 11		lda $11				lda 	zTemp1+1
.bd09	7d 98 04	adc $0498,x			adc 	ArrayDef+1,x
.bd0c	85 11		sta $11				sta 	zTemp1+1
.bd0e	b0 5a		bcs $bd6a			bcs 	ArrayIndexError
.bd10					_ACSized:
.bd10	18		clc				clc
.bd11	a5 10		lda $10				lda 	zTemp1
.bd13	69 02		adc #$02			adc 	#2
.bd15	85 10		sta $10				sta 	zTemp1
.bd17	90 04		bcc $bd1d			bcc 	_ACNoBump
.bd19	e6 10		inc $10				inc 	zTemp1
.bd1b	f0 4d		beq $bd6a			beq 	ArrayIndexError
.bd1d					_ACNoBump:
.bd1d	18		clc				clc
.bd1e	ad 02 04	lda $0402			lda 	VarMemPtr 					; add this allocated count to VarMemPtr
.bd21	85 12		sta $12				sta 	zTemp2						; save start in zTemp2/zTemp3
.bd23	85 14		sta $14				sta 	zTemp3
.bd25	65 10		adc $10				adc 	zTemp1
.bd27	8d 02 04	sta $0402			sta 	VarMemPtr
.bd2a	ad 03 04	lda $0403			lda 	VarMemPtr+1
.bd2d	85 13		sta $13				sta 	zTemp2+1
.bd2f	85 15		sta $15				sta 	zTemp3+1
.bd31	65 11		adc $11				adc 	zTemp1+1
.bd33	8d 03 04	sta $0403			sta 	VarMemPtr+1
.bd36	85 11		sta $11				sta 	zTemp1+1
.bd38	b0 30		bcs $bd6a			bcs 	ArrayIndexError
.bd3a	a0 00		ldy #$00			ldy 	#0							; write $00 out.
.bd3c					_ACClear:
.bd3c	98		tya				tya
.bd3d	91 12		sta ($12),y			sta 	(zTemp2),y
.bd3f	e6 12		inc $12				inc 	zTemp2
.bd41	d0 02		bne $bd45			bne 	_ACCBump
.bd43	e6 13		inc $13				inc 	zTemp2+1
.bd45					_ACCBump:
.bd45	a5 12		lda $12				lda 	zTemp2
.bd47	cd 02 04	cmp $0402			cmp 	VarMemPtr
.bd4a	d0 f0		bne $bd3c			bne 	_ACClear
.bd4c	a5 13		lda $13				lda 	zTemp2+1
.bd4e	cd 03 04	cmp $0403			cmp 	VarMemPtr+1
.bd51	d0 e9		bne $bd3c			bne 	_ACClear
.bd53	a0 00		ldy #$00			ldy 	#0
.bd55	bd 97 04	lda $0497,x			lda 	ArrayDef+0,x 				; copy the size into the start
.bd58	91 14		sta ($14),y			sta 	(zTemp3),y
.bd5a	c8		iny				iny
.bd5b	bd 98 04	lda $0498,x			lda 	ArrayDef+1,x
.bd5e	91 14		sta ($14),y			sta 	(zTemp3),y
.bd60	bd 9a 04	lda $049a,x			lda 	ArrayDef+3,x 				; have we reached the end
.bd63	10 18		bpl $bd7d			bpl 	ACCFillRecursive
.bd65	a4 15		ldy $15				ldy 	zTemp3+1 					; return address
.bd67	a5 14		lda $14				lda 	zTemp3
.bd69	60		rts				rts
.bd6a					ArrayIndexError:
.bd6a	20 4c ad	jsr $ad4c			jsr ERR_Handler
>bd6d	42 61 64 20 61 72 72 61			.text "Bad array index",0
>bd75	79 20 69 6e 64 65 78 00
.bd7d					ACCFillRecursive:
.bd7d	a9 ff		lda #$ff			lda 	#$FF 						; we mark the end, this is free space.
.bd7f	a0 00		ldy #$00			ldy 	#0 							; this is overwritten by size of next allocated
.bd81	91 12		sta ($12),y			sta 	(zTemp2),y 					; array, but we might change that.
.bd83	c8		iny				iny
.bd84	b1 14		lda ($14),y			lda 	(zTemp3),y 					; set bit 15 of the max index indicating
.bd86	09 80		ora #$80			ora 	#$80 						; an array of pointers
.bd88	91 14		sta ($14),y			sta 	(zTemp3),y
.bd8a	a5 14		lda $14				lda 	zTemp3 						; push the start on the stack
.bd8c	48		pha				pha
.bd8d	a5 15		lda $15				lda 	zTemp3+1
.bd8f	48		pha				pha
.bd90					_ACCFillLoop:
.bd90	18		clc				clc
.bd91	a5 14		lda $14				lda 	zTemp3 						; and work forwards.
.bd93	69 02		adc #$02			adc 	#2
.bd95	85 14		sta $14				sta 	zTemp3
.bd97	90 02		bcc $bd9b			bcc 	_ACCSkip2
.bd99	e6 14		inc $14				inc 	zTemp3
.bd9b					_ACCSkip2:
.bd9b	a0 00		ldy #$00			ldy 	#0 							; reached the end ?
.bd9d	b1 14		lda ($14),y			lda 	(zTemp3),y					; (looking for FF marker, everything else 00)
.bd9f	c8		iny				iny
.bda0	11 14		ora ($14),y			ora 	(zTemp3),y
.bda2	d0 21		bne $bdc5			bne 	_ACCExit
.bda4	a5 14		lda $14				lda 	zTemp3 						; push zTemp3
.bda6	48		pha				pha
.bda7	a5 15		lda $15				lda 	zTemp3+1
.bda9	48		pha				pha
.bdaa	e8		inx				inx
.bdab	e8		inx				inx
.bdac	20 dd bc	jsr $bcdd			jsr 	ArrayCreate 				; create array recursively.
.bdaf	ca		dex				dex
.bdb0	ca		dex				dex
.bdb1	85 12		sta $12				sta 	zTemp2 						; save A
.bdb3	68		pla				pla
.bdb4	85 15		sta $15				sta 	zTemp3+1 					; restore zTemp3
.bdb6	68		pla				pla
.bdb7	85 14		sta $14				sta 	zTemp3
.bdb9	98		tya				tya 								; write high bye from Y
.bdba	a0 01		ldy #$01			ldy 	#1
.bdbc	91 14		sta ($14),y			sta 	(zTemp3),y
.bdbe	88		dey				dey 								; write low byte out.
.bdbf	a5 12		lda $12				lda 	zTemp2
.bdc1	91 14		sta ($14),y			sta 	(zTemp3),y
.bdc3	80 cb		bra $bd90			bra 	_ACCFillLoop 				; and try again.
.bdc5					_ACCExit:
.bdc5	7a		ply				ply 								; restore the original address
.bdc6	68		pla				pla
.bdc7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varfind.asm

.bdc8					VariableLocate:
.bdc8	da		phx				phx
.bdc9	5a		phy				phy
.bdca	ad 88 04	lda $0488			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.bdcd	85 12		sta $12				sta 	zTemp2 						; points to first address.
.bdcf	a9 04		lda #$04			lda 	#HashTableBase >> 8
.bdd1	85 13		sta $13				sta 	zTemp2+1
.bdd3	a0 00		ldy #$00	_VLNext:ldy 	#0 							; get next link into AX
.bdd5	b1 12		lda ($12),y			lda 	(zTemp2),y
.bdd7	aa		tax				tax
.bdd8	c8		iny				iny
.bdd9	b1 12		lda ($12),y			lda 	(zTemp2),y
.bddb	85 13		sta $13				sta 	zTemp2+1 					; save in zTemp
.bddd	86 12		stx $12				stx 	zTemp2
.bddf	05 12		ora $12				ora 	zTemp2 						; got zero
.bde1	18		clc				clc
.bde2	f0 25		beq $be09			beq 	_VLExit 					; if so, then fail as end of chain.
.bde4	c8		iny				iny 								; point to hash (offset + 2)
.bde5	b1 12		lda ($12),y			lda 	(zTemp2),y
.bde7	cd 86 04	cmp $0486			cmp 	Var_Hash
.bdea	d0 e7		bne $bdd3			bne 	_VLNext 					; try next if different.
.bdec					_VLCompare:
.bdec	c8		iny				iny 								; next character
.bded	b1 12		lda ($12),y			lda 	(zTemp2),y 					; compare variable field against buffer.
.bdef	d9 02 04	cmp $0402,y			cmp 	Var_Buffer-3,y 				; the -3 is because name starts at 3.
.bdf2	d0 df		bne $bdd3			bne 	_VLNext 					; fail if different, try next.
.bdf4	0a		asl a				asl 	a 							; until end character (bit 7 set) matched
.bdf5	90 f5		bcc $bdec			bcc 	_VLCompare
.bdf7	98		tya				tya
.bdf8	38		sec				sec 								; add 1 as Y points to last character
.bdf9	65 12		adc $12				adc 	zTemp2 						; add to the current address
.bdfb	85 22		sta $22				sta 	zVarDataPtr
.bdfd	a5 13		lda $13				lda 	zTemp2+1
.bdff	69 00		adc #$00			adc 	#0
.be01	85 23		sta $23				sta 	zVarDataPtr+1
.be03	ad 85 04	lda $0485			lda 	Var_Type 					; and set the type.
.be06	85 24		sta $24				sta 	zVarType
.be08	38		sec				sec 								; return CS
.be09	7a		ply		_VLExit:ply
.be0a	fa		plx				plx
.be0b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/vargetset.asm

.be0c					VariableGet:
.be0c	5a		phy				phy
.be0d	a0 00		ldy #$00			ldy 	#0 							; copy first two bytes
.be0f	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.be11	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.be14	c8		iny				iny
.be15	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.be17	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.be1a	c8		iny				iny
.be1b	a5 24		lda $24				lda 	zVarType 					; if it is a string, set up for that.
.be1d	c9 b7		cmp #$b7			cmp 	#token_Dollar
.be1f	f0 34		beq $be55			beq 	_VGString
.be21	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; copy the next two bytes.
.be23	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.be26	c8		iny				iny
.be27	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.be29	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.be2c	c8		iny				iny
.be2d	a9 01		lda #$01			lda 	#1 							; set type to 1.
.be2f	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.be32	a5 24		lda $24				lda 	zVarType
.be34	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if it is a %, then exit with default integer.
.be36	f0 31		beq $be69			beq 	_VGExit
.be38	a9 40		lda #$40			lda 	#$40 						; set type byte to zero
.be3a	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; which is the code for zero/float.
.be3d	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; the last value to copy is the exponent.
.be3f	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.be42	f0 25		beq $be69			beq 	_VGExit 					; if exponent is zero ... it's zero.
.be44	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; the sign bit is the top mantissa bit.
.be47	48		pha				pha
.be48	29 80		and #$80			and 	#$80
.be4a	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; this is the type byte.
.be4d	68		pla				pla
.be4e	09 80		ora #$80			ora 	#$80 						; set the MSB as you would expect.
.be50	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x 			; so it's a normalised float.
.be53	80 14		bra $be69			bra 	_VGExit
.be55					_VGString:
.be55	a9 02		lda #$02			lda 	#2 							; set type to 2, a string
.be57	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.be5a	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; is the value there $0000
.be5d	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.be60	d0 07		bne $be69			bne 	_VGExit 					; if not, exit.
.be62	85 25		sta $25				sta 	zNullString 				; make zNullString a 00 string.
.be64	a9 25		lda #$25			lda 	#zNullString
.be66	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; make it point to it.
.be69					_VGExit:
.be69	7a		ply				ply
.be6a	60		rts				rts
.be6b					VariableSet:
.be6b	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; is the result a string
.be6e	29 02		and #$02			and 	#2 							; if so, it has to be
.be70	d0 53		bne $bec5			bne 	_VSString
.be72	a5 24		lda $24				lda 	zVarType 					; if type is $ there's an error.
.be74	c9 b7		cmp #$b7			cmp 	#token_Dollar
.be76	f0 4a		beq $bec2			beq 	_VSBadType
.be78	c9 bb		cmp #$bb			cmp 	#token_Percent 				; type convert to float/int
.be7a	f0 05		beq $be81			beq 	_VSMakeInt
.be7c	20 73 c4	jsr $c473			jsr 	FPUToFloat
.be7f	80 03		bra $be84			bra 	_VSCopy
.be81					_VSMakeInt:
.be81	20 d2 c4	jsr $c4d2			jsr 	FPUToInteger
.be84					_VSCopy:
.be84	5a		phy				phy
.be85	a0 00		ldy #$00			ldy 	#0 							; copy mantissa to target.
.be87	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.be8a	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.be8c	c8		iny				iny
.be8d	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.be90	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.be92	c8		iny				iny
.be93	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.be96	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.be98	c8		iny				iny
.be99	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.be9c	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.be9e	a5 24		lda $24				lda 	zVarType 					; if target is integer, alrady done.
.bea0	c9 bb		cmp #$bb			cmp 	#token_Percent
.bea2	f0 1c		beq $bec0			beq 	_VSExit
.bea4	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get the sign bit into carry flag.
.bea7	0a		asl a				asl 	a
.bea8	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; shift the sign into the mantissa high.
.beab	08		php				php
.beac	0a		asl a				asl 	a
.bead	28		plp				plp
.beae	6a		ror a				ror 	a
.beaf	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.beb1	c8		iny				iny
.beb2	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; copy the exponent in
.beb5	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.beb7	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if the result is non zero
.beba	50 04		bvc $bec0			bvc 	_VSExit
.bebc	a9 00		lda #$00			lda 	#00 						; zero exponent indicating 0.
.bebe	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.bec0					_VSExit:
.bec0	7a		ply				ply
.bec1	60		rts				rts
.bec2					_VSBadType:
.bec2	4c 2d ad	jmp $ad2d			jmp 	TypeError
.bec5					_VSString:
.bec5	a5 24		lda $24				lda 	zVarType 					; type must be $
.bec7	c9 b7		cmp #$b7			cmp 	#token_Dollar
.bec9	d0 f7		bne $bec2			bne 	_VSBadType
.becb	da		phx				phx
.becc	5a		phy				phy
.becd	20 23 ba	jsr $ba23			jsr 	StringConcrete 				; concrete the string in the mantissa -> AX
.bed0	a0 01		ldy #$01			ldy 	#1 							; save high byte
.bed2	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.bed4	88		dey				dey 								; save low byte
.bed5	8a		txa				txa
.bed6	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.bed8	7a		ply				ply 								; and exit.
.bed9	fa		plx				plx
.beda	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.bedb					MulInteger32:
.bedb	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.bede	9d 14 03	sta $0314,x			sta 	XS3_Mantissa,x
.bee1	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.bee4	9d 15 03	sta $0315,x			sta 	XS3_Mantissa+1,x
.bee7	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.beea	9d 16 03	sta $0316,x			sta 	XS3_Mantissa+2,x
.beed	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.bef0	9d 17 03	sta $0317,x			sta 	XS3_Mantissa+3,x
.bef3	a9 00		lda #$00			lda 	#0
.bef5	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x 				; zero +0
.bef8	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.befb	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.befe	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.bf01					_BFMMultiply:
.bf01	bd 14 03	lda $0314,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.bf04	29 01		and #$01			and 	#1
.bf06	f0 03		beq $bf0b			beq 	_BFMNoAdd
.bf08	20 73 b5	jsr $b573			jsr 	AddInteger32
.bf0b					_BFMNoAdd:
.bf0b	1e 0e 03	asl $030e,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.bf0e	3e 0f 03	rol $030f,x			rol 	XS2_Mantissa+1,x
.bf11	3e 10 03	rol $0310,x			rol 	XS2_Mantissa+2,x
.bf14	3e 11 03	rol $0311,x			rol 	XS2_Mantissa+3,x
.bf17	5e 17 03	lsr $0317,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.bf1a	7e 16 03	ror $0316,x			ror 	XS3_Mantissa+2,x
.bf1d	7e 15 03	ror $0315,x			ror 	XS3_Mantissa+1,x
.bf20	7e 14 03	ror $0314,x			ror 	XS3_Mantissa,x
.bf23	bd 14 03	lda $0314,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.bf26	1d 15 03	ora $0315,x			ora 	XS3_Mantissa+1,x
.bf29	1d 16 03	ora $0316,x			ora 	XS3_Mantissa+2,x
.bf2c	1d 17 03	ora $0317,x			ora 	XS3_Mantissa+3,x
.bf2f	d0 d0		bne $bf01			bne 	_BFMMultiply
.bf31	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.bf32					DivInteger32:
.bf32	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; check for /0
.bf35	1d 0f 03	ora $030f,x			ora 	XS2_Mantissa+1,x
.bf38	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.bf3b	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.bf3e	d0 14		bne $bf54			bne 	_BFDOkay
.bf40	20 4c ad	jsr $ad4c			jsr ERR_Handler
>bf43	44 69 76 69 73 69 6f 6e			.text "Division by Zero",0
>bf4b	20 62 79 20 5a 65 72 6f 00
.bf54					_BFDOkay:
.bf54	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.bf56	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.bf58	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.bf5a	85 1c		sta $1c				sta 	zLTemp1+2
.bf5c	85 1d		sta $1d				sta 	zLTemp1+3
.bf5e	8d 8e 04	sta $048e			sta 	SignCount 					; Count of signs.
.bf61	20 c2 bf	jsr $bfc2			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.bf64	da		phx				phx
.bf65	e8		inx				inx
.bf66	e8		inx				inx
.bf67	e8		inx				inx
.bf68	e8		inx				inx
.bf69	e8		inx				inx
.bf6a	e8		inx				inx
.bf6b	20 c2 bf	jsr $bfc2			jsr 	CheckIntegerNegate
.bf6e	fa		plx				plx
.bf6f	5a		phy				phy 								; Y is the counter
.bf70	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.bf72					_BFDLoop:
.bf72	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.bf75	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.bf78	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.bf7b	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.bf7e	26 1a		rol $1a				rol 	zLTemp1
.bf80	26 1b		rol $1b				rol 	zLTemp1+1
.bf82	26 1c		rol $1c				rol 	zLTemp1+2
.bf84	26 1d		rol $1d				rol 	zLTemp1+3
.bf86	38		sec				sec
.bf87	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.bf89	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.bf8c	48		pha				pha
.bf8d	a5 1b		lda $1b				lda 	zLTemp1+1
.bf8f	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.bf92	48		pha				pha
.bf93	a5 1c		lda $1c				lda 	zLTemp1+2
.bf95	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.bf98	48		pha				pha
.bf99	a5 1d		lda $1d				lda 	zLTemp1+3
.bf9b	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.bf9e	90 15		bcc $bfb5			bcc 	_BFDNoAdd
.bfa0	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.bfa2	68		pla				pla
.bfa3	85 1c		sta $1c				sta 	zLTemp1+2
.bfa5	68		pla				pla
.bfa6	85 1b		sta $1b				sta 	zLTemp1+1
.bfa8	68		pla				pla
.bfa9	85 1a		sta $1a				sta 	zLTemp1+0
.bfab	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.bfae	09 01		ora #$01			ora 	#1
.bfb0	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.bfb3	80 03		bra $bfb8			bra 	_BFDNext
.bfb5					_BFDNoAdd:
.bfb5	68		pla				pla 								; Throw away the intermediate calculations
.bfb6	68		pla				pla
.bfb7	68		pla				pla
.bfb8					_BFDNext:
.bfb8	88		dey				dey
.bfb9	d0 b7		bne $bf72			bne 	_BFDLoop
.bfbb	7a		ply				ply 								; restore Y and exit
.bfbc	4e 8e 04	lsr $048e			lsr 	SignCount 					; if sign count odd,
.bfbf	b0 07		bcs $bfc8			bcs		IntegerNegateAlways 			; negate the result
.bfc1	60		rts				rts
.bfc2					CheckIntegerNegate:
.bfc2	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.bfc5	30 01		bmi $bfc8			bmi 	IntegerNegateAlways
.bfc7	60		rts				rts
.bfc8					IntegerNegateAlways:
.bfc8	ee 8e 04	inc $048e			inc 	SignCount
.bfcb	38		sec				sec
.bfcc	a9 00		lda #$00			lda 	#0
.bfce	fd 08 03	sbc $0308,x			sbc 	XS_Mantissa+0,x
.bfd1	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.bfd4	a9 00		lda #$00			lda 	#0
.bfd6	fd 09 03	sbc $0309,x			sbc 	XS_Mantissa+1,x
.bfd9	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.bfdc	a9 00		lda #$00			lda 	#0
.bfde	fd 0a 03	sbc $030a,x			sbc 	XS_Mantissa+2,x
.bfe1	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.bfe4	a9 00		lda #$00			lda 	#0
.bfe6	fd 0b 03	sbc $030b,x			sbc 	XS_Mantissa+3,x
.bfe9	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.bfec	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.bfed					INTToString:
.bfed	48		pha				pha
.bfee	5a		phy				phy
.bfef	bd 0b 03	lda $030b,x			lda 		XS_Mantissa+3,x 		; check -ve
.bff2	10 08		bpl $bffc			bpl 		_ITSNotMinus
.bff4	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.bff6	20 8d c0	jsr $c08d			jsr 		ITSOutputCharacter
.bff9	20 c8 bf	jsr $bfc8			jsr 		IntegerNegateAlways 	; negate the number.
.bffc					_ITSNotMinus:
.bffc	a9 00		lda #$00			lda 		#0
.bffe	8d 8a 04	sta $048a			sta 		NumSuppress 			; clear the suppression flag.
.c001	8a		txa				txa 								; use Y for the mantissa index.
.c002	a8		tay				tay
.c003	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.c005					_ITSNextSubtractor:
.c005	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.c007	8d 8b 04	sta $048b			sta 		NumConvCount
.c00a					_ITSSubtract:
.c00a	38		sec				sec
.c00b	b9 08 03	lda $0308,y			lda 		XS_Mantissa,y 			; subtract number and push on stack
.c00e	fd 69 c0	sbc $c069,x			sbc 		_ITSSubtractors+0,x
.c011	48		pha				pha
.c012	b9 09 03	lda $0309,y			lda 		XS_Mantissa+1,y
.c015	fd 6a c0	sbc $c06a,x			sbc 		_ITSSubtractors+1,x
.c018	48		pha				pha
.c019	b9 0a 03	lda $030a,y			lda 		XS_Mantissa+2,y
.c01c	fd 6b c0	sbc $c06b,x			sbc 		_ITSSubtractors+2,x
.c01f	48		pha				pha
.c020	b9 0b 03	lda $030b,y			lda 		XS_Mantissa+3,y
.c023	fd 6c c0	sbc $c06c,x			sbc 		_ITSSubtractors+3,x
.c026	90 14		bcc $c03c			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.c028	99 0b 03	sta $030b,y			sta 		XS_Mantissa+3,y 		; save subtract off stack
.c02b	68		pla				pla
.c02c	99 0a 03	sta $030a,y			sta 		XS_Mantissa+2,y
.c02f	68		pla				pla
.c030	99 09 03	sta $0309,y			sta 		XS_Mantissa+1,y
.c033	68		pla				pla
.c034	99 08 03	sta $0308,y			sta 		XS_Mantissa+0,y
.c037	ee 8b 04	inc $048b			inc 		NumConvCount 			; bump count.
.c03a	80 ce		bra $c00a			bra 		_ITSSubtract 			; go round again.
.c03c					_ITSCantSubtract:
.c03c	68		pla				pla 								; throw away interim answers
.c03d	68		pla				pla
.c03e	68		pla				pla
.c03f	ad 8b 04	lda $048b			lda 		NumConvCount 			; if not zero then no suppression check
.c042	c9 30		cmp #$30			cmp 		#"0"
.c044	d0 05		bne $c04b			bne 		_ITSOutputDigit
.c046	ad 8a 04	lda $048a			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.c049	10 09		bpl $c054			bpl	 		_ITSGoNextSubtractor
.c04b					_ITSOutputDigit:
.c04b	ce 8a 04	dec $048a			dec 		NumSuppress 			; suppression check will be non-zero.
.c04e	ad 8b 04	lda $048b			lda 		NumConvCount 			; count of subtractions
.c051	20 8d c0	jsr $c08d			jsr 		ITSOutputCharacter 		; output it.
.c054					_ITSGoNextSubtractor:
.c054	e8		inx				inx 								; next dword
.c055	e8		inx				inx
.c056	e8		inx				inx
.c057	e8		inx				inx
.c058	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.c05a	d0 a9		bne $c005			bne 		_ITSNextSubtractor 		; do all the subtractors.
.c05c	98		tya				tya 								; X is back as the mantissa index
.c05d	aa		tax				tax
.c05e	bd 08 03	lda $0308,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.c061	09 30		ora #$30			ora 		#"0"
.c063	20 8d c0	jsr $c08d			jsr 		ITSOutputCharacter
.c066	7a		ply				ply 								; and exit
.c067	68		pla				pla
.c068	60		rts				rts
.c069					_ITSSubtractors:
>c069	00 ca 9a 3b					.dword 		1000000000
>c06d	00 e1 f5 05					.dword 		100000000
>c071	80 96 98 00					.dword 		10000000
>c075	40 42 0f 00					.dword 		1000000
>c079	a0 86 01 00					.dword 		100000
>c07d	10 27 00 00					.dword 		10000
>c081	e8 03 00 00					.dword 		1000
>c085	64 00 00 00					.dword 		100
>c089	0a 00 00 00					.dword 		10
.c08d					_ITSSubtractorsEnd:
.c08d					ITSOutputCharacter:
.c08d	48		pha				pha
.c08e	da		phx				phx
.c08f	ae 04 04	ldx $0404			ldx 	NumBufX 					; save digit
.c092	9d 05 04	sta $0405,x			sta 	Num_Buffer,x
.c095	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.c097	9d 06 04	sta $0406,x			sta 	Num_Buffer+1,x
.c09a	ee 04 04	inc $0404			inc 	NumBufX						; bump pointer.
.c09d	fa		plx				plx
.c09e	68		pla				pla
.c09f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.c0a0					IntFromString:
.c0a0	a0 00		ldy #$00			ldy 	#0
.c0a2	8c 8c 04	sty $048c			sty 	ExpTemp 					; this is the converted digit count.
.c0a5					IntFromStringY:
.c0a5	48		pha				pha
.c0a6	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.c0a8	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.c0ab	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.c0ae	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.c0b1	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.c0b4	a9 01		lda #$01			lda 	#1
.c0b6	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.c0b9					_IFSLoop:
.c0b9	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.c0bb	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.c0bd	90 60		bcc $c11f			bcc 	_IFSExit
.c0bf	c9 3a		cmp #$3a			cmp 	#"9"+1
.c0c1	b0 5c		bcs $c11f			bcs 	_IFSExit
.c0c3	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.c0c6	c9 0c		cmp #$0c			cmp 	#12
.c0c8	b0 5f		bcs $c129			bcs 	_IFSOverflow
.c0ca	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.c0cd	48		pha				pha
.c0ce	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.c0d1	48		pha				pha
.c0d2	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.c0d5	48		pha				pha
.c0d6	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.c0d9	48		pha				pha
.c0da	20 3e c1	jsr $c13e			jsr 	IFSX1ShiftLeft 				; double
.c0dd	20 3e c1	jsr $c13e			jsr 	IFSX1ShiftLeft 				; x 4
.c0e0	18		clc				clc 								; add saved value x 5
.c0e1	68		pla				pla
.c0e2	7d 08 03	adc $0308,x			adc 	XS_Mantissa+0,x
.c0e5	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.c0e8	68		pla				pla
.c0e9	7d 09 03	adc $0309,x			adc 	XS_Mantissa+1,x
.c0ec	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.c0ef	68		pla				pla
.c0f0	7d 0a 03	adc $030a,x			adc 	XS_Mantissa+2,x
.c0f3	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.c0f6	68		pla				pla
.c0f7	7d 0b 03	adc $030b,x			adc 	XS_Mantissa+3,x
.c0fa	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.c0fd	20 3e c1	jsr $c13e			jsr 	IFSX1ShiftLeft 				; x 10
.c100	ee 8c 04	inc $048c			inc 	ExpTemp 					; bump count of digits processed.
.c103	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.c105	29 0f		and #$0f			and 	#15
.c107	c8		iny				iny
.c108	7d 08 03	adc $0308,x			adc 	XS_Mantissa+0,x
.c10b	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.c10e	90 a9		bcc $c0b9			bcc 	_IFSLoop
.c110	fe 09 03	inc $0309,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.c113	d0 a4		bne $c0b9			bne 	_IFSLoop
.c115	fe 0a 03	inc $030a,x			inc 	XS_Mantissa+2,x
.c118	d0 9f		bne $c0b9			bne 	_IFSLoop
.c11a	fe 0b 03	inc $030b,x			inc 	XS_Mantissa+3,x
.c11d	80 9a		bra $c0b9			bra 	_IFSLoop
.c11f					_IFSExit:
.c11f	98		tya				tya 								; get offset
.c120					_IFSOkay:
.c120	38		sec				sec
.c121	ad 8c 04	lda $048c			lda 	ExpTemp
.c124	f0 01		beq $c127			beq 	_IFSSkipFail
.c126	18		clc				clc
.c127					_IFSSkipFail:
.c127	68		pla				pla 								; and exit.
.c128	60		rts				rts
.c129					_IFSOverflow:
.c129	20 4c ad	jsr $ad4c			jsr 	ERR_Handler
>c12c	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>c134	20 6f 76 65 72 66 6c 6f 77 00
.c13e					IFSX1ShiftLeft:
.c13e	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x
.c141	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.c144	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.c147	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.c14a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.c14b					FPSubtract:
.c14b	48		pha				pha
.c14c	bd 13 03	lda $0313,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.c14f	49 80		eor #$80			eor 	#$80
.c151	9d 13 03	sta $0313,x			sta 	XS2_Type,x
.c154	68		pla				pla 								; --- and fall through ---
.c155					FPAdd:
.c155	48		pha				pha
.c156	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.c159	d0 05		bne $c160			bne 	_FPA_NegativeLHS
.c15b	20 7d c1	jsr $c17d			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.c15e	68		pla				pla
.c15f	60		rts				rts
.c160					_FPA_NegativeLHS:
.c160	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.c163	49 80		eor #$80			eor 	#$80
.c165	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.c168	bd 13 03	lda $0313,x			lda 	XS2_Type,x 					; flip the sign of B and add
.c16b	49 80		eor #$80			eor 	#$80
.c16d	9d 13 03	sta $0313,x			sta 	XS2_Type,x
.c170	20 7d c1	jsr $c17d			jsr 	FPAdd_Worker 				; do the add calculation.
.c173	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip sign of X1 back
.c176	49 80		eor #$80			eor 	#$80
.c178	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.c17b	68		pla				pla
.c17c	60		rts				rts
.c17d					FPAdd_Worker:
.c17d	3c 13 03	bit $0313,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.c180	70 08		bvs $c18a			bvs 	_FPAWExit 					; no change.
.c182	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.c185	50 07		bvc $c18e			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.c187	20 22 c4	jsr $c422			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.c18a					_FPAWExit:
.c18a	20 aa c4	jsr $c4aa			jsr 	FPUNormalise 				; normalise the result.
.c18d	60		rts				rts
.c18e					_FPAWMakeSame:
.c18e	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.c191	38		sec				sec
.c192	fd 12 03	sbc $0312,x			sbc	 	XS2_Exponent,x 				; using subtraction
.c195	f0 1b		beq $c1b2			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.c197	da		phx				phx 								; save X
.c198	90 06		bcc $c1a0			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.c19a	e8		inx				inx
.c19b	e8		inx				inx
.c19c	e8		inx				inx
.c19d	e8		inx				inx
.c19e	e8		inx				inx
.c19f	e8		inx				inx
.c1a0					_FPAWShiftA:
.c1a0	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x 				; so shift exponent up.
.c1a3	5e 0b 03	lsr $030b,x			lsr 	3+XS_Mantissa,x
.c1a6	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.c1a9	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.c1ac	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.c1af	fa		plx				plx 								; restore original X
.c1b0	80 dc		bra $c18e			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.c1b2					_FPAW_DoArithmetic:
.c1b2	3c 13 03	bit $0313,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.c1b5	30 39		bmi $c1f0			bmi 	_FPAW_BNegative
.c1b7	18		clc				clc
.c1b8	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.c1bb	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.c1be	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.c1c1	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.c1c4	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.c1c7	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.c1ca	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.c1cd	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.c1d0	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.c1d3	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.c1d6	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.c1d9	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.c1dc	90 ac		bcc $c18a			bcc 	_FPAWExit 					; no carry.
.c1de	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x 				; so shift exponent up.
.c1e1	38		sec				sec
.c1e2	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.c1e5	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.c1e8	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.c1eb	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.c1ee	80 9a		bra $c18a			bra 	_FPAWExit
.c1f0					_FPAW_BNegative:
.c1f0	38		sec				sec
.c1f1	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.c1f4	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.c1f7	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.c1fa	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.c1fd	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.c200	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.c203	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.c206	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.c209	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.c20c	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.c20f	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.c212	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.c215	b0 0b		bcs $c222			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.c217	20 4f c4	jsr $c44f			jsr 	FPUNegateInteger			; negate the mantissa
.c21a	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip result sign
.c21d	49 80		eor #$80			eor 	#$80
.c21f	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.c222					_FPAWGoExit:
.c222	4c 8a c1	jmp $c18a			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.c225					FPD_IsDivZero:
.c225	20 4c ad	jsr $ad4c			jsr ERR_Handler
>c228	44 69 76 69 73 69 6f 6e			.text "Division by zero",0
>c230	20 62 79 20 7a 65 72 6f 00
.c239					FPDivide:
.c239	48		pha				pha
.c23a	5a		phy				phy
.c23b	3c 13 03	bit $0313,x			bit 	XS2_Type,x 					; check if division by zero
.c23e	70 e5		bvs $c225			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.c240	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.c243	f0 03		beq $c248			beq 	_FPDCalculateExp
.c245					_FPD_Exit:
.c245	7a		ply				ply
.c246	68		pla				pla
.c247	60		rts				rts
.c248					_FPDCalculateExp:
.c248	bd 12 03	lda $0312,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.c24b	49 ff		eor #$ff			eor 	#$FF
.c24d	1a		inc a				inc 	a
.c24e	9d 12 03	sta $0312,x			sta 	XS2_Exponent,x
.c251	20 45 c3	jsr $c345			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.c254	18		clc				clc 	 							; add 1 to the resulting exponent
.c255	69 01		adc #$01			adc 	#1
.c257	b0 65		bcs $c2be			bcs 	_FPD_Overflow 				; which can overflow.
.c259	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.c25c	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.c25e	85 1a		sta $1a				sta 	zLTemp1+0
.c260	85 1b		sta $1b				sta 	zLTemp1+1
.c262	85 1c		sta $1c				sta 	zLTemp1+2
.c264	85 1d		sta $1d				sta 	zLTemp1+3
.c266	a0 20		ldy #$20			ldy 	#32 						; times round.
.c268					_FPD_Loop:
.c268	38		sec				sec 								; calculate X1-X2 stacking result because we might
.c269	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; not save it.
.c26c	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa,x
.c26f	48		pha				pha
.c270	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.c273	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.c276	48		pha				pha
.c277	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.c27a	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.c27d	48		pha				pha
.c27e	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.c281	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.c284	90 17		bcc $c29d			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.c286	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x 			; save results out to A
.c289	68		pla				pla
.c28a	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.c28d	68		pla				pla
.c28e	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.c291	68		pla				pla
.c292	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.c295	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.c297	09 80		ora #$80			ora 	#$80
.c299	85 1d		sta $1d				sta 	zLTemp1+3
.c29b	80 03		bra $c2a0			bra 	_FPD_Rotates
.c29d					_FPD_NoSubtract:
.c29d	68		pla				pla 								; throw away unwanted results
.c29e	68		pla				pla
.c29f	68		pla				pla
.c2a0					_FPD_Rotates:
.c2a0	5e 11 03	lsr $0311,x			lsr 	3+XS2_Mantissa,x
.c2a3	7e 10 03	ror $0310,x			ror 	2+XS2_Mantissa,x
.c2a6	7e 0f 03	ror $030f,x			ror 	1+XS2_Mantissa,x
.c2a9	7e 0e 03	ror $030e,x			ror 	0+XS2_Mantissa,x
.c2ac	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.c2ae	26 1b		rol $1b				rol 	zLTemp1+1
.c2b0	26 1c		rol $1c				rol 	zLTemp1+2
.c2b2	26 1d		rol $1d				rol 	zLTemp1+3
.c2b4	90 02		bcc $c2b8			bcc 	_FPD_NoCarry
.c2b6	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.c2b8					_FPD_NoCarry:
.c2b8	88		dey				dey 								; do 32 times
.c2b9	d0 ad		bne $c268			bne 	_FPD_Loop
.c2bb	4c 22 c3	jmp $c322			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.c2be					_FPD_Overflow:
.c2be	4c 1f c5	jmp $c51f			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.c2c1					FPMultiply:
.c2c1	48		pha				pha
.c2c2	5a		phy				phy
.c2c3	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.c2c6	70 08		bvs $c2d0			bvs 	_FPM_Exit
.c2c8	3c 13 03	bit $0313,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.c2cb	50 06		bvc $c2d3			bvc 	_FPM_CalcExponent
.c2cd	20 22 c4	jsr $c422			jsr 	FPUCopyX2ToX1
.c2d0					_FPM_Exit:
.c2d0	7a		ply				ply
.c2d1	68		pla				pla
.c2d2	60		rts				rts
.c2d3					_FPM_CalcExponent:
.c2d3	18		clc				clc
.c2d4	20 45 c3	jsr $c345			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.c2d7	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x 				; save the result.
.c2da	a9 00		lda #$00			lda 	#0
.c2dc	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.c2de	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.c2e0	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.c2e2	85 1d		sta $1d				sta 	zLTemp1+3
.c2e4	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.c2e6					_FPM_Loop:
.c2e6	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x				; check LSB of long product
.c2e9	29 01		and #$01			and 	#1
.c2eb	18		clc				clc 								; clear carry for the long rotate.
.c2ec	f0 1d		beq $c30b			beq 	_FPM_NoAddition
.c2ee	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.c2ef	a5 1a		lda $1a				lda 	zLTemp1+0
.c2f1	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.c2f4	85 1a		sta $1a				sta 	zLTemp1+0
.c2f6	a5 1b		lda $1b				lda 	zLTemp1+1
.c2f8	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.c2fb	85 1b		sta $1b				sta 	zLTemp1+1
.c2fd	a5 1c		lda $1c				lda 	zLTemp1+2
.c2ff	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.c302	85 1c		sta $1c				sta 	zLTemp1+2
.c304	a5 1d		lda $1d				lda 	zLTemp1+3
.c306	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.c309	85 1d		sta $1d				sta 	zLTemp1+3
.c30b					_FPM_NoAddition:
.c30b	66 1d		ror $1d				ror 	3+zLTemp1
.c30d	66 1c		ror $1c				ror 	2+zLTemp1
.c30f	66 1b		ror $1b				ror 	1+zLTemp1
.c311	66 1a		ror $1a				ror 	0+zLTemp1
.c313	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.c316	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.c319	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.c31c	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.c31f	88		dey				dey
.c320	d0 c4		bne $c2e6			bne 	_FPM_Loop 					; do this 32 times.
.c322					FPM_CopySignNormalize:
.c322	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.c324	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.c327	a5 1b		lda $1b				lda 	zLTemp1+1
.c329	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.c32c	a5 1c		lda $1c				lda 	zLTemp1+2
.c32e	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.c331	a5 1d		lda $1d				lda 	zLTemp1+3
.c333	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.c336	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; sign is xor of signs
.c339	5d 13 03	eor $0313,x			eor 	XS2_Type,x
.c33c	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.c33f	20 aa c4	jsr $c4aa			jsr 	FPUNormalise 				; normalise and exit.
.c342	7a		ply				ply
.c343	68		pla				pla
.c344	60		rts				rts
.c345					FPCalculateExponent:
.c345	18		clc				clc
.c346	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.c349	7d 12 03	adc $0312,x			adc 	XS2_Exponent,x
.c34c	b0 08		bcs $c356			bcs 	_FPCECarry 					; carry out ?
.c34e	10 03		bpl $c353			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.c350	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.c352	60		rts				rts
.c353					_FPCEExpZero:
.c353	a9 00		lda #$00			lda 	#0
.c355	60		rts				rts
.c356					_FPCECarry:
.c356	30 03		bmi $c35b			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.c358	09 80		ora #$80			ora 	#$80 						; put in right range
.c35a	60		rts				rts
.c35b					_FPCEOverflow:
.c35b	4c 1f c5	jmp $c51f			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.c35e					FPFractionalPart:
.c35e	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.c361	38		sec				sec 								; this flag tells us to keep the fractional part
.c362	30 0f		bmi $c373			bmi 	FPGetPart
.c364	60		rts				rts
.c365					FPIntegerPart:
.c365	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.c368	18		clc				clc 								; this flag says keep the integer part.
.c369	30 08		bmi $c373			bmi 	FPGetPart 					; -ve exponents are 0..127
.c36b	48		pha				pha
.c36c	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.c36e	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.c371	68		pla				pla
.c372	60		rts				rts
.c373					FPGetPart:
.c373	48		pha				pha
.c374	5a		phy				phy 								; save Y
.c375	08		php				php 								; save action
.c376	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.c379	70 62		bvs $c3dd			bvs 	_FPGP_Exit 					; then do nothing.
.c37b	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.c37d	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.c37f	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.c381	85 1c		sta $1c				sta 	zLTemp1+2
.c383	85 1d		sta $1d				sta 	zLTemp1+3
.c385	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x				; the number of shifts.
.c388	38		sec				sec
.c389	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.c38b	f0 12		beq $c39f			beq 	_FPGP_NoShift 				; ... if any
.c38d	c9 20		cmp #$20			cmp 	#32
.c38f	90 02		bcc $c393			bcc 	_FPGP_NotMax
.c391	a9 20		lda #$20			lda 	#32 						; max of 32.
.c393					_FPGP_NotMax:
.c393	a8		tay				tay 								; Y is the mask shift count.
.c394					_FPGP_ShiftMask:
.c394	46 1d		lsr $1d				lsr 	3+zLTemp1
.c396	66 1c		ror $1c				ror 	2+zLTemp1
.c398	66 1b		ror $1b				ror 	1+zLTemp1
.c39a	66 1a		ror $1a				ror 	0+zLTemp1
.c39c	88		dey				dey
.c39d	d0 f5		bne $c394			bne 	_FPGP_ShiftMask
.c39f					_FPGP_NoShift:
.c39f	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.c3a1	8e 8c 04	stx $048c			stx 	ExpTemp						; save X
.c3a4					_FPGP_MaskLoop:
.c3a4	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.c3a7	28		plp				plp 								; if CC we keep the top part, so we
.c3a8	08		php				php		 							; flip the mask.
.c3a9	b0 02		bcs $c3ad			bcs		_FPGP_NoFlip
.c3ab	49 ff		eor #$ff			eor 	#$FF
.c3ad					_FPGP_NoFlip:
.c3ad	3d 08 03	and $0308,x			and 	XS_Mantissa,x 				; and into the mantissa.
.c3b0	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.c3b3	e8		inx				inx
.c3b4	c8		iny				iny
.c3b5	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.c3b7	d0 eb		bne $c3a4			bne 	_FPGP_MaskLoop
.c3b9	ae 8c 04	ldx $048c			ldx 	ExpTemp						; restore X
.c3bc	28		plp				plp
.c3bd	08		php				php 								; get action flag on the stack
.c3be	90 05		bcc $c3c5			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.c3c0	a9 00		lda #$00			lda 	#0
.c3c2	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.c3c5					_FPGP_NotFractional:
.c3c5	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 						; check if \1 zero
.c3c8	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.c3cb	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.c3ce	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.c3d1	f0 05		beq $c3d8			beq 	_FPGP_Zero 					; if zero, return zero
.c3d3	20 aa c4	jsr $c4aa			jsr 	FPUNormalise
.c3d6	80 05		bra $c3dd			bra 	_FPGP_Exit 					; and exit
.c3d8					_FPGP_Zero:
.c3d8	a9 40		lda #$40			lda 	#$40 						; set zero flag
.c3da	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.c3dd					_FPGP_Exit:
.c3dd	68		pla				pla 								; throw saved action flag.
.c3de	7a		ply				ply
.c3df	68		pla				pla
.c3e0	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.c3e1					FPCompare:
.c3e1	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.c3e4	48		pha				pha
.c3e5	bd 12 03	lda $0312,x			lda 	XS2_Exponent,x
.c3e8	48		pha				pha
.c3e9	20 4b c1	jsr $c14b			jsr 	FPSubtract 					; calculate X1-X2
.c3ec	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.c3ef	70 2c		bvs $c41d			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.c3f1	68		pla				pla
.c3f2	8d 8c 04	sta $048c			sta 	ExpTemp						; save first exponent in temporary reg.
.c3f5	68		pla				pla
.c3f6	38		sec				sec
.c3f7	ed 8c 04	sbc $048c			sbc 	ExpTemp 					; calculate AX-BX
.c3fa	70 15		bvs $c411			bvs 	_FPCNotEqual				; overflow, can't be equal.
.c3fc	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.c3fd	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.c3ff	b0 10		bcs $c411			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.c401	38		sec				sec
.c402	ad 8c 04	lda $048c			lda 	ExpTemp 					; get one of the exponents back.
.c405	e9 12		sbc #$12			sbc 	#18 						; allow for 2^18 error, relatively.
.c407	b0 02		bcs $c40b			bcs 	_FPCNotRange 				; keep in range.
.c409	a9 01		lda #$01			lda 	#1
.c40b					_FPCNotRange:
.c40b	38		sec				sec
.c40c	fd 0c 03	sbc $030c,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.c40f	b0 0e		bcs $c41f			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.c411					_FPCNotEqual:
.c411	bd 0d 03	lda $030d,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.c414	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.c416	f0 02		beq $c41a			beq 	_FPCNE2
.c418	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.c41a	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.c41b	80 04		bra $c421			bra 	_FPCExit
.c41d					_FPCPullZero:
.c41d	68		pla				pla 								; throw saved exponents
.c41e	68		pla				pla
.c41f					_FPCZero:
.c41f	a9 00		lda #$00			lda 	#0 							; and return zero
.c421					_FPCExit:
.c421	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.c422					FPUCopyX2ToX1:
.c422	48		pha				pha
.c423	da		phx				phx
.c424	5a		phy				phy
.c425	a0 08		ldy #$08			ldy 	#8
.c427	bd 0e 03	lda $030e,x	_FPUC21:lda 	XS2_Mantissa,x
.c42a	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.c42d	e8		inx				inx
.c42e	88		dey				dey
.c42f	10 f6		bpl $c427			bpl 	_FPUC21
.c431	7a		ply				ply
.c432	fa		plx				plx
.c433	68		pla				pla
.c434	60		rts				rts
.c435					FPUSetInteger:
.c435	48		pha				pha
.c436	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.c439	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.c43b	10 02		bpl $c43f			bpl 	_FPUSIExtend
.c43d	a9 ff		lda #$ff			lda 	#$FF
.c43f					_FPUSIExtend:
.c43f	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.c442	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.c445	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.c448	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.c44a	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.c44d	68		pla				pla
.c44e	60		rts				rts
.c44f					FPUNegateInteger:
.c44f	48		pha				pha
.c450	38		sec				sec
.c451	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.c453	fd 08 03	sbc $0308,x			sbc 	XS_Mantissa+0,x
.c456	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.c459	a9 00		lda #$00			lda 	#0
.c45b	fd 09 03	sbc $0309,x			sbc 	XS_Mantissa+1,x
.c45e	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.c461	a9 00		lda #$00			lda 	#0
.c463	fd 0a 03	sbc $030a,x			sbc 	XS_Mantissa+2,x
.c466	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.c469	a9 00		lda #$00			lda 	#0
.c46b	fd 0b 03	sbc $030b,x			sbc 	XS_Mantissa+3,x
.c46e	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.c471	68		pla				pla
.c472	60		rts				rts
.c473					FPUToFloat:
.c473	48		pha				pha
.c474	bd 0d 03	lda $030d,x			lda 	XS_Type,x					; exit if already float.
.c477	29 0f		and #$0f			and 	#$0F
.c479	f0 2d		beq $c4a8			beq 	_FPUFExit
.c47b	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.c47d	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.c480	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.c482	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x 				; x mantissa.
.c485	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.c488	10 08		bpl $c492			bpl		_FPUFPositive
.c48a	20 4f c4	jsr $c44f			jsr 	FPUNegateInteger 			; negate the mantissa
.c48d	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.c48f	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.c492					_FPUFPositive:
.c492	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.c495	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.c498	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.c49b	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.c49e	d0 05		bne $c4a5			bne 	_FPUFNonZero
.c4a0	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.c4a2	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.c4a5					_FPUFNonZero:
.c4a5	20 aa c4	jsr $c4aa			jsr 	FPUNormalise 				; normalise the floating point.
.c4a8					_FPUFExit:
.c4a8	68		pla				pla
.c4a9	60		rts				rts
.c4aa					FPUNormalise:
.c4aa	48		pha				pha
.c4ab	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.c4ae	70 20		bvs $c4d0			bvs 	_FPUNExit
.c4b0	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.c4b3	f0 16		beq $c4cb			beq 	_FPUNSetZero
.c4b5					_FPUNLoop:
.c4b5	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.c4b8	30 16		bmi $c4d0			bmi 	_FPUNExit 					; if so, we are normalised.
.c4ba	1e 08 03	asl $0308,x			asl 	0+XS_Mantissa+0,x
.c4bd	3e 09 03	rol $0309,x			rol 	1+XS_Mantissa+0,x
.c4c0	3e 0a 03	rol $030a,x			rol 	2+XS_Mantissa+0,x
.c4c3	3e 0b 03	rol $030b,x			rol 	3+XS_Mantissa+0,x
.c4c6	de 0c 03	dec $030c,x			dec 	XS_Exponent,x 				; decrement exponent
.c4c9	d0 ea		bne $c4b5			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.c4cb					_FPUNSetZero:
.c4cb	a9 40		lda #$40			lda 	#$40
.c4cd	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; the result is now zero.
.c4d0					_FPUNExit:
.c4d0	68		pla				pla
.c4d1	60		rts				rts
.c4d2					FPUToInteger:
.c4d2	48		pha				pha
.c4d3	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; if already integer, exit
.c4d6	29 01		and #$01			and 	#1
.c4d8	d0 3e		bne $c518			bne 	_FPUTOI_Exit
.c4da	3c 0d 03	bit $030d,x			bit 	XS_Type,x					; if zero, return zero.
.c4dd	70 2b		bvs $c50a			bvs 	_FPUTOI_Zero
.c4df	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.c4e2	10 26		bpl $c50a			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.c4e4	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.c4e6	b0 37		bcs $c51f			bcs 	FP_Overflow
.c4e8					_FPUToIToInteger:
.c4e8	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.c4eb	c9 a0		cmp #$a0			cmp 	#128+32
.c4ed	f0 11		beq $c500			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.c4ef	fe 0c 03	inc $030c,x			inc 	XS_Exponent,X 				; increment Exponent
.c4f2	5e 0b 03	lsr $030b,x			lsr 	3+XS_Mantissa,x
.c4f5	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.c4f8	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.c4fb	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.c4fe	80 e8		bra $c4e8			bra 	_FPUToIToInteger 			; keep going.
.c500					_FPUToICheckSign:
.c500	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; check sign
.c503	10 13		bpl $c518			bpl 	_FPUToI_Exit 				; exit if unsigned.
.c505	20 4f c4	jsr $c44f			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.c508	80 0e		bra $c518			bra 	_FPUTOI_Exit
.c50a					_FPUTOI_Zero:
.c50a	a9 00		lda #$00			lda 	#0 							; return zero integer.
.c50c	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.c50f	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.c512	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.c515	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.c518					_FPUToI_Exit:
.c518	a9 01		lda #$01			lda 	#1 							; set type to integer
.c51a	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.c51d	68		pla				pla
.c51e	60		rts				rts
.c51f					FP_Overflow:
.c51f	20 4c ad	jsr $ad4c			jsr ERR_Handler
>c522	46 6c 6f 61 74 69 6e 67			.text "Floating Point overflow",0
>c52a	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.c53a					FPUTimes10:
.c53a	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.c53d	85 1a		sta $1a				sta 	ZLTemp1+0
.c53f	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.c542	85 1b		sta $1b				sta 	ZLTemp1+1
.c544	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.c547	85 1c		sta $1c				sta 	ZLTemp1+2
.c549	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.c54c	85 1d		sta $1d				sta 	ZLTemp1+3
.c54e	20 92 c5	jsr $c592			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.c551	20 92 c5	jsr $c592			jsr 	_FPUT_LSR_ZLTemp1
.c554	18		clc				clc
.c555	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.c558	65 1a		adc $1a				adc 	ZLTemp1+0
.c55a	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.c55d	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.c560	65 1b		adc $1b				adc 	ZLTemp1+1
.c562	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.c565	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.c568	65 1c		adc $1c				adc 	ZLTemp1+2
.c56a	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.c56d	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.c570	65 1d		adc $1d				adc 	ZLTemp1+3
.c572	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.c575	90 0f		bcc $c586			bcc 	_FPUTimes10
.c577	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.c57a	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.c57d	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.c580	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.c583	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x				; fix exponent
.c586					_FPUTimes10:
.c586	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.c589	18		clc				clc
.c58a	69 03		adc #$03			adc 	#3
.c58c	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.c58f	b0 8e		bcs $c51f			bcs 	FP_Overflow 				; error
.c591	60		rts				rts
.c592					_FPUT_LSR_ZLTemp1:
.c592	46 1d		lsr $1d				lsr 	ZLTemp1+3
.c594	66 1c		ror $1c				ror 	ZLTemp1+2
.c596	66 1b		ror $1b				ror 	ZLTemp1+1
.c598	66 1a		ror $1a				ror 	ZLTemp1+0
.c59a	60		rts				rts
.c59b					FPUScale10A:
.c59b	5a		phy				phy
.c59c	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.c59e	f0 3d		beq $c5dd			beq 	_FPUScaleExit
.c5a0	da		phx				phx 								; save X
.c5a1	e8		inx				inx
.c5a2	e8		inx				inx
.c5a3	e8		inx				inx
.c5a4	e8		inx				inx
.c5a5	e8		inx				inx
.c5a6	e8		inx				inx
.c5a7	a8		tay				tay 								; save power scalar in Y.
.c5a8	a9 00		lda #$00			lda 	#0
.c5aa	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.c5ad	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.c5b0	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.c5b3	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.c5b6	a9 80		lda #$80			lda 	#$80
.c5b8	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.c5bb	a9 81		lda #$81			lda 	#$81
.c5bd	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.c5c0	5a		phy				phy 								; save 10^n on stack.
.c5c1	c0 00		cpy #$00			cpy 	#0
.c5c3	10 05		bpl $c5ca			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.c5c5	98		tya				tya
.c5c6	49 ff		eor #$ff			eor 	#$FF
.c5c8	1a		inc a				inc 	a
.c5c9	a8		tay				tay
.c5ca					_FPUSAbs:
.c5ca	20 3a c5	jsr $c53a			jsr 	FPUTimes10
.c5cd	88		dey				dey
.c5ce	d0 fa		bne $c5ca			bne 	_FPUSAbs 					; tos is now 10^|AC|
.c5d0	68		pla				pla 								; restore count in A
.c5d1	fa		plx				plx 								; restore X pointing to number to scale.
.c5d2	0a		asl a				asl 	a
.c5d3	b0 05		bcs $c5da			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.c5d5	20 c1 c2	jsr $c2c1			jsr 	FPMultiply 					; if clear multiply.
.c5d8	80 03		bra $c5dd			bra		_FPUScaleExit
.c5da					_FPUSDivide:
.c5da	20 39 c2	jsr $c239			jsr 	FPDivide
.c5dd					_FPUScaleExit:
.c5dd	7a		ply				ply
.c5de	60		rts				rts
.c5df					FPUCopyToNext:
.c5df	a0 06		ldy #$06			ldy 		#6
.c5e1	da		phx				phx
.c5e2					_FPUCopy1:
.c5e2	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x
.c5e5	9d 0e 03	sta $030e,x			sta 	XS2_Mantissa,x
.c5e8	e8		inx				inx
.c5e9	88		dey				dey
.c5ea	d0 f6		bne $c5e2			bne 	_FPUCopy1
.c5ec	fa		plx				plx
.c5ed	60		rts				rts
.c5ee					FPUCopyFromNext:
.c5ee	a0 06		ldy #$06			ldy 		#6
.c5f0	da		phx				phx
.c5f1					_FPUCopy1:
.c5f1	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa,x
.c5f4	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.c5f7	e8		inx				inx
.c5f8	88		dey				dey
.c5f9	d0 f6		bne $c5f1			bne 	_FPUCopy1
.c5fb	fa		plx				plx
.c5fc	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.c5fd					FPToString:
.c5fd	48		pha				pha
.c5fe	5a		phy				phy
.c5ff	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; check zero flag
.c602	50 0a		bvc $c60e			bvc 		_FPTSIsFloat 			; if zero,
.c604					_FPTSZero:
.c604	a9 30		lda #$30			lda 		#"0"
.c606	20 8d c0	jsr $c08d			jsr 		ITSOutputCharacter
.c609					_FPTSExit:
.c609	7a		ply				ply
.c60a	68		pla				pla
.c60b	60		rts				rts
.c60c	80 fb		bra $c609			bra 		_FPTSExit
.c60e					_FPTSIsFloat:
.c60e	bd 0d 03	lda $030d,x			lda 		XS_Type,x 				; is it signed ?
.c611	10 0a		bpl $c61d			bpl 		_FPTSNotSigned
.c613	a9 00		lda #$00			lda 		#0 						; clear sign flag
.c615	9d 0d 03	sta $030d,x			sta 		XS_Type,x
.c618	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.c61a	20 8d c0	jsr $c08d			jsr 		ITSOutputCharacter
.c61d					_FPTSNotSigned:
.c61d	bd 0c 03	lda $030c,x			lda 		XS_Exponent,x
.c620	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.c622	b0 09		bcs $c62d			bcs 		_FPTSExponent
.c624	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.c626	90 05		bcc $c62d			bcc 		_FPTSExponent 			;
.c628					_FPTSStandard:
.c628	20 71 c6	jsr $c671			jsr 		FPTOutputBody 			; output the body.
.c62b	80 dc		bra $c609			bra 		_FPTSExit
.c62d					_FPTSExponent:
.c62d	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.c62f	8d 8d 04	sta $048d			sta 		ExpCount
.c632					_FPTSExponentLoop:
.c632	bd 0c 03	lda $030c,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.c635	10 0e		bpl $c645			bpl 		_FPTSTimes
.c637	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.c639	90 14		bcc $c64f			bcc 		_FPTSScaledToExp
.c63b	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.c63d	20 9b c5	jsr $c59b			jsr 		FPUScale10A
.c640	ee 8d 04	inc $048d			inc 		ExpCount
.c643	80 ed		bra $c632			bra 		_FPTSExponentLoop
.c645					_FPTSTimes:
.c645	a9 01		lda #$01			lda 		#1
.c647	20 9b c5	jsr $c59b			jsr 		FPUScale10A
.c64a	ce 8d 04	dec $048d			dec 		ExpCount
.c64d	80 e3		bra $c632			bra 		_FPTSExponentLoop
.c64f					_FPTSScaledToExp:
.c64f	20 71 c6	jsr $c671			jsr 		FPTOutputBody 			; output the body.
.c652	a9 65		lda #$65			lda 		#"e"					; output E
.c654	20 8d c0	jsr $c08d			jsr 		ITSOutputCharacter
.c657	ad 8d 04	lda $048d			lda 		ExpCount 				; get the exponent
.c65a	9d 08 03	sta $0308,x			sta 		XS_Mantissa,x
.c65d	29 80		and #$80			and 		#$80 					; sign extend it
.c65f	f0 02		beq $c663			beq 		_FPTSSExt
.c661	a9 ff		lda #$ff			lda 		#$FF
.c663					_FPTSSExt:
.c663	9d 09 03	sta $0309,x			sta 		XS_Mantissa+1,x
.c666	9d 0a 03	sta $030a,x			sta 		XS_Mantissa+2,x
.c669	9d 0b 03	sta $030b,x			sta 		XS_Mantissa+3,x
.c66c	20 ed bf	jsr $bfed			jsr 		INTToString 			; output the exponent.
.c66f	80 98		bra $c609			bra			_FPTSExit 				; and exit.
.c671					FPTOutputBody:
.c671	20 df c5	jsr $c5df			jsr 		FPUCopyToNext 			; copy to next slot.
.c674	20 d2 c4	jsr $c4d2			jsr 		FPUToInteger 			; convert to an integer
.c677	20 ed bf	jsr $bfed			jsr 		INTToString 			; output the main integer part.
.c67a	20 ee c5	jsr $c5ee			jsr 		FPUCopyFromNext 		; get the fractional part back.
.c67d	20 5e c3	jsr $c35e			jsr 		FPFractionalPart 		; get the decimal part.
.c680	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; any fractional part.
.c683	70 3e		bvs $c6c3			bvs 		_FPTOExit 				; if not, exit now.
.c685	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.c687	20 8d c0	jsr $c08d			jsr 		ITSOutputCharacter
.c68a					_FPOutLoop:
.c68a	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; finally reached zero.
.c68d	70 1e		bvs $c6ad			bvs 		_FPStripZeros 			; strip trailing zeros
.c68f	20 3a c5	jsr $c53a			jsr 		FPUTimes10 				; multiply by 10
.c692	20 df c5	jsr $c5df			jsr 		FPUCopyToNext			; copy to next slot.
.c695	20 d2 c4	jsr $c4d2			jsr 		FPUToInteger 			; convert to integer
.c698	bd 08 03	lda $0308,x			lda 		XS_Mantissa+0,x 		; print digit.
.c69b	09 30		ora #$30			ora 		#"0"
.c69d	20 8d c0	jsr $c08d			jsr 		ITSOutputCharacter
.c6a0	20 ee c5	jsr $c5ee			jsr 		FPUCopyFromNext 		; get it back
.c6a3	20 5e c3	jsr $c35e			jsr 		FPFractionalPart 		; get fractional part
.c6a6	ad 04 04	lda $0404			lda 		NumBufX 				; done 11 characters yet ?
.c6a9	c9 0b		cmp #$0b			cmp 	 	#11
.c6ab	90 dd		bcc $c68a			bcc 		_FPOutLoop 				; if so, keep going till zero.
.c6ad					_FPStripZeros:
.c6ad	ac 04 04	ldy $0404			ldy 		NumBufX 				; strip trailing zeros.
.c6b0					_FPStripLoop:
.c6b0	88		dey				dey 								; back one, if at start then no strip
.c6b1	f0 10		beq $c6c3			beq 		_FPToExit
.c6b3	b9 05 04	lda $0405,y			lda 		Num_Buffer,y 			; keep going if "0"
.c6b6	c9 30		cmp #$30			cmp 		#"0"
.c6b8	f0 f6		beq $c6b0			beq 		_FPStripLoop
.c6ba	c8		iny				iny
.c6bb	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.c6bd	99 05 04	sta $0405,y			sta 		Num_Buffer,y
.c6c0	8c 04 04	sty $0404			sty 		NumBufX 				; update position.
.c6c3					_FPTOExit:
.c6c3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.c6c4					FPFromString:
.c6c4	48		pha				pha 								; push A
.c6c5	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.c6c7	c9 2e		cmp #$2e			cmp 	#"."
.c6c9	f0 03		beq $c6ce			beq	 	_FPFIsDecimal
.c6cb	4c 31 c7	jmp $c731			jmp 	_FPFNotDecimal
.c6ce					_FPFIsDecimal:
.c6ce	c8		iny				iny 								; consume the decimal.
.c6cf	20 73 c4	jsr $c473			jsr 	FPUToFloat 					; convert the integer to float.
.c6d2	da		phx				phx 								; save X.
.c6d3	5a		phy				phy 								; save decimal start position
.c6d4	e8		inx				inx
.c6d5	e8		inx				inx
.c6d6	e8		inx				inx
.c6d7	e8		inx				inx
.c6d8	e8		inx				inx
.c6d9	e8		inx				inx
.c6da	20 a5 c0	jsr $c0a5			jsr 	INTFromStringY 				; get the part after the DP.
.c6dd	20 73 c4	jsr $c473			jsr 	FPUToFloat 					; convert that to a float.
.c6e0	68		pla				pla 								; calculate - chars consumed.
.c6e1	8c 8c 04	sty $048c			sty 	ExpTemp
.c6e4	38		sec				sec
.c6e5	ed 8c 04	sbc $048c			sbc 	ExpTemp 					; this is the shift amount
.c6e8	20 9b c5	jsr $c59b			jsr 	FPUScale10A 				; scale it by 10^AC
.c6eb	fa		plx				plx 								; restore original X
.c6ec	20 55 c1	jsr $c155			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.c6ef	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.c6f1	c9 45		cmp #$45			cmp 	#"E"
.c6f3	f0 04		beq $c6f9			beq 	_FPFExponent
.c6f5	c9 65		cmp #$65			cmp 	#"e"
.c6f7	d0 38		bne $c731			bne 	_FPFNotDecimal 				; no, then exit normally.
.c6f9					_FPFExponent:
.c6f9	c8		iny				iny 								; skip over E symbol.
.c6fa	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.c6fc	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.c6fe	d0 01		bne $c701			bne 	_FPFGotSign
.c700	c8		iny				iny 								; if it was - skip over it.
.c701					_FPFGotSign:
.c701	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.c702	da		phx				phx
.c703	e8		inx				inx
.c704	e8		inx				inx
.c705	e8		inx				inx
.c706	e8		inx				inx
.c707	e8		inx				inx
.c708	e8		inx				inx
.c709	20 a5 c0	jsr $c0a5			jsr 	INTFromStringY 				; get the exponent
.c70c	fa		plx				plx 								; restore X.
.c70d	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.c710	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.c713	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.c716	d0 1b		bne $c733			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.c718	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.c71b	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.c71d	b0 14		bcs $c733			bcs 	_FPFXOverflow
.c71f	68		pla				pla 								; get direction
.c720	d0 09		bne $c72b			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.c722	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.c725	49 ff		eor #$ff			eor 	#$FF
.c727	1a		inc a				inc 	a
.c728	9d 0e 03	sta $030e,x			sta 	XS2_Mantissa+0,x
.c72b					_FPFXScale:
.c72b	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.c72e	20 9b c5	jsr $c59b			jsr 	FPUScale10A 				; scale by the exponent.
.c731					_FPFNotDecimal:
.c731	68		pla				pla
.c732	60		rts				rts
.c733					_FPFXOverflow:
.c733	20 4c ad	jsr $ad4c			jsr 	ERR_Handler
>c736	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>c73e	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.c745					Unary_Rnd:
.c745	20 7f b3	jsr $b37f			jsr 	EvaluateNumberX 			; get value
.c748	20 11 ba	jsr $ba11			jsr 	CheckNextRParen 			; check right bracket.
.c74b	20 6c b6	jsr $b66c			jsr 	GetSignCurrent 				; get sign -1,0,1.
.c74e	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.c750	30 10		bmi $c762			bmi 	_URSetSeed
.c752	f0 2c		beq $c780			beq 	_URMakeRandom 				; if zero return same number.
.c754	da		phx				phx
.c755	a2 00		ldx #$00			ldx 	#0
.c757	20 bd c7	jsr $c7bd			jsr 	Random16
.c75a	a2 02		ldx #$02			ldx 	#2
.c75c	20 bd c7	jsr $c7bd			jsr 	Random16
.c75f	fa		plx				plx
.c760	80 1e		bra $c780			bra 	_URMakeRandom
.c762					_URSetSeed:
.c762	20 73 c4	jsr $c473			jsr 	FPUToFloat 					; make it a float to twiddle it.
.c765	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.c768	8d 93 04	sta $0493			sta 	RandomSeed+0
.c76b	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.c76e	8d 94 04	sta $0494			sta 	RandomSeed+1
.c771	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.c774	8d 95 04	sta $0495			sta 	RandomSeed+2
.c777	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.c77a	0a		asl a				asl 	a
.c77b	49 db		eor #$db			eor 	#$DB
.c77d	8d 96 04	sta $0496			sta 	RandomSeed+3
.c780					_URMakeRandom:
.c780	ad 93 04	lda $0493			lda 	RandomSeed+0 				; check if seed is zero.
.c783	0d 94 04	ora $0494			ora 	RandomSeed+1
.c786	0d 95 04	ora $0495			ora 	RandomSeed+2
.c789	0d 96 04	ora $0496			ora 	RandomSeed+3
.c78c	d0 0a		bne $c798			bne 	_URNotZero
.c78e	a9 47		lda #$47			lda 	#$47
.c790	8d 94 04	sta $0494			sta 	RandomSeed+1				; if it is, make it non zero.
.c793	a9 3d		lda #$3d			lda 	#$3D
.c795	8d 96 04	sta $0496			sta 	RandomSeed+3
.c798					_URNotZero:
.c798	ad 93 04	lda $0493			lda 	RandomSeed+0 				; copy seed into mantissa.
.c79b	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.c79e	ad 94 04	lda $0494			lda 	RandomSeed+1
.c7a1	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.c7a4	ad 95 04	lda $0495			lda 	RandomSeed+2
.c7a7	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.c7aa	ad 96 04	lda $0496			lda 	RandomSeed+3
.c7ad	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.c7b0	a9 00		lda #$00			lda 	#$00 						; set type to float.
.c7b2	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.c7b5	a9 80		lda #$80			lda 	#$80
.c7b7	9d 0c 03	sta $030c,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.c7ba	4c aa c4	jmp $c4aa			jmp 	FPUNormalise
.c7bd					Random16:
.c7bd	5e 94 04	lsr $0494,x			lsr 	RandomSeed+1,x				; shift seed right
.c7c0	7e 93 04	ror $0493,x			ror 	RandomSeed,x
.c7c3	90 08		bcc $c7cd			bcc 	_R16_NoXor
.c7c5	bd 94 04	lda $0494,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.c7c8	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.c7ca	9d 94 04	sta $0494,x			sta 	RandomSeed+1,x
.c7cd					_R16_NoXor:
.c7cd	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.c7ce					Unary_Int:
.c7ce	20 7f b3	jsr $b37f			jsr 	EvaluateNumberX 			; get value
.c7d1	20 11 ba	jsr $ba11			jsr 	CheckNextRParen 			; check right bracket.
.c7d4	4c d2 c4	jmp $c4d2			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Return to file: basic.asm

.c7d7	80 fe		bra $c7d7	_halt:	bra 		_halt
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 a0						.word 	StartROM
>fffe	95 ac					.word TIM_BreakVector

;******  End of listing
