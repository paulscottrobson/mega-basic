
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Sun Aug 25 22:20:58 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="65816"				cpu = "65816"
="em65816"				hardware = "em65816"
=1					exitonend = 1
=0					autorun = 0
=0					loadtest = 0
=1					hasfloat = 1
=1					hasinteger = 1
=253					maxstring = 253

;******  Processing file: modules/float/fpmacros.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/em65816/src_em65816.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0020					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0022					zVarDataPtr: .word ? 						; position of variable data.
>0024					zVarType: 	.byte ? 						; type of data (token)
>0025					zNullString:.byte ? 						; represents a NULL string.
>0200					IFT_XCursor:.byte ?							; current logical position on screen
>0201					IFT_YCursor:.byte ?
>0202					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0266					IFT_LineBuffer: .fill 100 					; line input buffer.
>0300					UserVector .fill 4 							; USR(x) calls this.
>0304					LocalVector .fill 4 						; Indirect calls call this.
>0308					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>030c					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>030d					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=782					XS2_Mantissa = XS_Mantissa+XS_Size
=786					XS2_Exponent = XS_Exponent+XS_Size
=787					XS2_Type = XS_Type+XS_Size
=788					XS3_Mantissa = XS_Mantissa+XS_Size*2
=792					XS3_Exponent = XS_Exponent+XS_Size*2
=793					XS3_Type = XS_Type+XS_Size*2
>0400					StringPtr:	.word ? 						; Top of free memory (for string allocation)
>0402					VarMemPtr: 	.word ?							; Bottom of free memory (for variables)
>0404					NumBufX 	.byte 	?						; buffer index position
>0405					Num_Buffer	.fill 	32 						; buffer for numeric conversions
=6					HashTableCount = 6 							; there are 6 hash tables, in token order.
=8					HashTableSize = 8 							; each hash table as 8 links.
.0425					HashTableBase:
>0425								.fill	HashTableCount * HashTableSize * 2
.0485					HashTableEnd:
=$405					Var_Buffer 	= Num_Buffer 					; buffer for variable name (same space)
>0485					Var_Type    .byte ? 						; type of variable (as a type token)
>0486					Var_Hash 	.byte ? 						; hash of identifier name.
>0487					Var_Length 	.byte ? 						; length of variable name
>0488					Var_HashAddress .byte ?						; low byte of hash table entry.
>0489					Var_DataSize .byte ?						; size of one element.
>048a					NumSuppress	.byte 	?						; leading zero suppression flag
>048b					NumConvCount .byte 	? 						; count for conversions.
>048c					ExpTemp:	.byte ?							; Working temp for exponents.
>048d					ExpCount:	.byte ? 						; Count of decimal exponents.
>048e					SignCount:	.byte ?							; Integer Divide Sign Counts.
>048f					TempStringWriteIndex: .byte ? 				; Write offset.
>0490					ValSign: 	.byte ? 						; sign flag for val()
>0491					SliceStart:	.byte ? 						; string slice parts
>0492					SliceCount:	.byte ?
>0493					RandomSeed:	.dword ? 						; Random seed.
>0497					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>0499					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>049b					Tim_SR:		.byte ? 						; Processor Status
>049c					Tim_A:		.byte ? 						; Processor Registers
>049d					Tim_X:		.byte ?
>049e					Tim_Y:		.byte ?
>049f					Tim_Z:		.byte ?
>04a0					Tim_SP:		.word ?							; Stack Pointer (just in cases)

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/em65816.asm

=$8000					HighMemory = $8000
=$4000					VariableMemory = $4000
.1000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testcode.src

>1000	0e 64 00 cd 14 05 13 14			.byte	$0e,$64,$00,$cd,$14,$05,$13,$14
>1008	84 6a fd 03 35 00 1d 65			.byte	$84,$6a,$fd,$03,$35,$00,$1d,$65
>1010	00 cd 01 84 40 fd 03 30			.byte	$00,$cd,$01,$84,$40,$fd,$03,$30
>1018	be cd 14 05 13 14 31 84			.byte	$be,$cd,$14,$05,$13,$14,$31,$84
>1020	41 fd 06 32 65 32 34 8d			.byte	$41,$fd,$06,$32,$65,$32,$34,$8d
>1028	41 64 00 0c 66 00 cd 02			.byte	$41,$64,$00,$0c,$66,$00,$cd,$02
>1030	31 32 b9 84 8b 42 00 24			.byte	$31,$32,$b9,$84,$8b,$42,$00,$24
>1038	67 00 03 84 8b 40 be cd			.byte	$67,$00,$03,$84,$8b,$40,$be,$cd
>1040	0e 01 0d 05 b5 84 fe 07			.byte	$0e,$01,$0d,$05,$b5,$84,$fe,$07
>1048	48 65 6c 6c 6f be 03 b5			.byte	$48,$65,$6c,$6c,$6f,$be,$03,$b5
>1050	84 fe 09 2c 77 6f 72 6c			.byte	$84,$fe,$09,$2c,$77,$6f,$72,$6c
>1058	64 21 00 05 68 00 c2 00			.byte	$64,$21,$00,$05,$68,$00,$c2,$00
>1060	00					.byte	$00

;******  Return to file: modules/hardware/em65816.asm

.c000					StartROM:
.c000	18		clc				clc
.c001	fb		xce				xce
.c002	c2 30		rep #$30			rep 	#$30
.c004	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.c007	1b		tcs				tcs
.c008	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.c00b	e2 30		sep #$30			sep 	#$30
.c00d	c2 30		rep #$30			rep 	#$30						; clear AXY in 16 bit.
.c00f	a9 00		lda #$00			lda 	#$0000
.c011	aa		tax				tax
.c012	a8		tay				tay
.c013	e2 30		sep #$30			sep 	#$30
.c015	5c 95 84 01	jmp $018495		jmp BASIC_Start
.c019					TIM_BreakHandler:
.c019	5c 70 9b 01	jmp $019b70			jmp 	TIM_BreakVector

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.018000					IFT_ClearScreen:
.018000	48		pha				pha
.018001	da		phx				phx
.018002	5a		phy				phy
.018003	20 a9 81	jsr $0181a9			jsr 	IF_Home 					; home cursor
.018006	a2 20		ldx #$20			ldx 	#IF_Height 					; this many lines.
.018008					_IFT_CS0:
.018008	a0 40		ldy #$40			ldy 	#IF_Width 					; this many chars/line
.01800a					_IFT_CS1:
.01800a	a9 20		lda #$20			lda 	#' '						; clear line.
.01800c	20 d5 81	jsr $0181d5			jsr 	IF_Write
.01800f	88		dey				dey
.018010	d0 f8		bne $01800a			bne 	_IFT_CS1
.018012	20 bc 81	jsr $0181bc			jsr 	IF_NewLine 					; next line down
.018015	ca		dex				dex
.018016	d0 f0		bne $018008			bne 	_IFT_CS0
.018018	7a		ply				ply
.018019	fa		plx				plx
.01801a	68		pla				pla
.01801b					IFT_HomeCursor:
.01801b	48		pha				pha
.01801c	20 a9 81	jsr $0181a9			jsr 	IF_Home
.01801f	a9 00		lda #$00			lda 	#0
.018021	8d 00 02	sta $0200			sta 	IFT_XCursor
.018024	8d 01 02	sta $0201			sta 	IFT_YCursor
.018027	68		pla				pla
.018028	60		rts				rts
.018029					IFT_UpLine:
.018029	48		pha				pha
.01802a	ad 01 02	lda $0201			lda  	IFT_YCursor 				; get Y
.01802d	3a		dec a				dec 	a 							; line above
.01802e	30 03		bmi $018033			bmi 	_IFTULExit 					; too far, abort
.018030	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos					; set to that line.
.018033					_IFTULExit:
.018033	68		pla				pla
.018034	60		rts				rts
.018035					IFT_PrintCharacter:
.018035	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.018037	f0 23		beq $01805c			beq 	IFT_NewLine
.018039	48		pha				pha
.01803a	20 74 80	jsr $018074			jsr 	IFT_UpperCase 				; make upper case
.01803d	20 d5 81	jsr $0181d5			jsr 	IF_Write 					; write out.
.018040	ee 00 02	inc $0200			inc 	IFT_XCursor 				; bump x cursor
.018043	ad 00 02	lda $0200			lda 	IFT_XCursor 				; reached RHS ?
.018046	c9 40		cmp #$40			cmp 	#IF_Width
.018048	d0 03		bne $01804d			bne 	_IFT_PCNotEOL
.01804a	20 5c 80	jsr $01805c			jsr 	IFT_NewLine 				; if so do new line.
.01804d					_IFT_PCNotEOL:
.01804d	68		pla				pla
.01804e	60		rts				rts
.01804f					IFT_Tab:
.01804f	a9 20		lda #$20			lda 	#" " 						; space
.018051	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018054	ad 00 02	lda $0200			lda 	IFT_XCursor 				; until x % 8 == 0
.018057	29 07		and #$07			and 	#7
.018059	d0 f4		bne $01804f			bne 	IFT_Tab
.01805b	60		rts				rts
.01805c					IFT_NewLine:
.01805c	48		pha				pha
.01805d	20 bc 81	jsr $0181bc			jsr 	IF_NewLine 					; new line on actual screen.
.018060	a9 00		lda #$00			lda 	#0 							; reset x position
.018062	8d 00 02	sta $0200			sta 	IFT_XCursor
.018065	ee 01 02	inc $0201			inc 	IFT_YCursor 				; move down.
.018068	ad 01 02	lda $0201			lda 	IFT_YCursor
.01806b	c9 20		cmp #$20			cmp 	#IF_Height 					; reached bottom.
.01806d	d0 03		bne $018072			bne 	_IFT_NL_NotEOS
.01806f	20 7f 80	jsr $01807f			jsr 	IFT_Scroll 					; scroll screen up.
.018072					_IFT_NL_NotEOS:
.018072	68		pla				pla
.018073	60		rts				rts
.018074					IFT_UpperCase:
.018074	c9 61		cmp #$61			cmp 	#"a"
.018076	90 06		bcc $01807e			bcc 	_IFT_UCExit
.018078	c9 7b		cmp #$7b			cmp 	#"z"+1
.01807a	b0 02		bcs $01807e			bcs 	_IFT_UCExit
.01807c	49 20		eor #$20			eor 	#$20
.01807e					_IFT_UCExit:
.01807e	60		rts				rts
.01807f					IFT_Scroll:
.01807f	48		pha				pha 								; save AXY
.018080	da		phx				phx
.018081	5a		phy				phy
.018082	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.018084					_IFT_SLoop:
.018084	20 a4 80	jsr $0180a4			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.018087	e8		inx				inx
.018088	e0 1f		cpx #$1f			cpx 	#IF_Height-1				; do whole screen
.01808a	d0 f8		bne $018084			bne 	_IFT_SLoop
.01808c	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.01808e	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.018091	a2 40		ldx #$40			ldx 	#IF_Width 					; blank line
.018093					_IFT_SBlank:
.018093	a9 20		lda #$20			lda 	#32
.018095	20 d5 81	jsr $0181d5			jsr 	IF_Write
.018098	ca		dex				dex
.018099	d0 f8		bne $018093			bne 	_IFT_SBlank
.01809b	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.01809d	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.0180a0	7a		ply				ply
.0180a1	fa		plx				plx
.0180a2	68		pla				pla
.0180a3	60		rts				rts
.0180a4					_IFT_ScrollLine:
.0180a4	da		phx				phx
.0180a5	da		phx				phx
.0180a6	8a		txa				txa 								; copy line into buffer.
.0180a7	1a		inc a				inc 	a 							; next line down.
.0180a8	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.0180ab	a2 00		ldx #$00			ldx 	#0
.0180ad					_IFTScrollCopy1:
.0180ad	20 cc 81	jsr $0181cc			jsr 	IF_Read
.0180b0	9d 02 02	sta $0202,x			sta 	IFT_Buffer,x
.0180b3	e8		inx				inx
.0180b4	e0 40		cpx #$40			cpx 	#IF_Width
.0180b6	d0 f5		bne $0180ad			bne 	_IFTScrollCopy1
.0180b8	68		pla				pla
.0180b9	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.0180bc	a2 00		ldx #$00			ldx 	#0
.0180be					_IFTScrollCopy2:
.0180be	bd 02 02	lda $0202,x			lda 	IFT_Buffer,x
.0180c1	20 d5 81	jsr $0181d5			jsr 	IF_Write
.0180c4	e8		inx				inx
.0180c5	e0 40		cpx #$40			cpx 	#IF_Width
.0180c7	d0 f5		bne $0180be			bne 	_IFTScrollCopy2
.0180c9	fa		plx				plx
.0180ca	60		rts				rts
.0180cb					IFT_SetYPos:
.0180cb	48		pha				pha
.0180cc	da		phx				phx
.0180cd	aa		tax				tax
.0180ce	20 1b 80	jsr $01801b			jsr 	IFT_HomeCursor
.0180d1	e0 00		cpx #$00			cpx 	#0
.0180d3	f0 09		beq $0180de			beq 	_IFT_MOAExit
.0180d5					_IFT_MOALoop:
.0180d5	20 bc 81	jsr $0181bc			jsr 	IF_NewLine
.0180d8	ee 01 02	inc $0201			inc 	IFT_YCursor
.0180db	ca		dex				dex
.0180dc	d0 f7		bne $0180d5			bne		_IFT_MOALoop
.0180de					_IFT_MOAExit:
.0180de	fa		plx				plx
.0180df	68		pla				pla
.0180e0	60		rts				rts
.0180e1					IFT_GetKeyCursor:
.0180e1	20 e9 80	jsr $0180e9			jsr 	_IFT_FlipCursor 			; reverse current
.0180e4					_IFT_GKCWait:
.0180e4	20 e6 81	jsr $0181e6			jsr 	IF_GetKey 					; get key
.0180e7	f0 fb		beq $0180e4			beq 	_IFT_GKCWait
.0180e9					_IFT_FlipCursor:
.0180e9	48		pha				pha 								; save
.0180ea	20 cc 81	jsr $0181cc			jsr 	IF_Read 					; read
.0180ed	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.0180f0	49 80		eor #$80			eor 	#$80 						; reverse
.0180f2	20 d5 81	jsr $0181d5			jsr 	IF_Write 					; write
.0180f5	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.0180f8	68		pla				pla
.0180f9	60		rts				rts
.0180fa					IFT_ReadLine:
.0180fa	48		pha				pha
.0180fb					_IFT_RLLoop:
.0180fb	20 e1 80	jsr $0180e1			jsr 	IFT_GetKeyCursor 			; get keystroke
.0180fe	c9 0d		cmp #$0d			cmp 	#13							; return
.018100	f0 7d		beq $01817f			beq 	_IFT_RLExit
.018102	c9 20		cmp #$20			cmp 	#32 						; control character
.018104	90 05		bcc $01810b			bcc 	_IFT_Control
.018106	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018109	80 f0		bra $0180fb			bra 	_IFT_RLLoop
.01810b					_IFT_Control:
.01810b	c9 01		cmp #$01			cmp 	#"A"-64
.01810d	f0 26		beq $018135			beq 	_IFT_Left
.01810f	c9 04		cmp #$04			cmp 	#"D"-64
.018111	f0 2e		beq $018141			beq 	_IFT_Right
.018113	c9 17		cmp #$17			cmp 	#"W"-64
.018115	f0 36		beq $01814d			beq 	_IFT_Up
.018117	c9 13		cmp #$13			cmp 	#"S"-64
.018119	f0 3e		beq $018159			beq 	_IFT_Down
.01811b	c9 08		cmp #$08			cmp 	#"H"-64
.01811d	f0 09		beq $018128			beq 	_IFT_Backspace
.01811f	c9 1a		cmp #$1a			cmp 	#"Z"-64
.018121	d0 d8		bne $0180fb			bne 	_IFT_RLLoop
.018123	20 00 80	jsr $018000			jsr 	IFT_ClearScreen				; clear CTL-Z
.018126	80 d3		bra $0180fb			bra 	_IFT_RLLoop
.018128					_IFT_Backspace:
.018128	ad 00 02	lda $0200			lda 	IFT_XCursor 				; check not start of line.
.01812b	f0 ce		beq $0180fb			beq 	_IFT_RLLoop
.01812d	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.018130	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.018132	20 d5 81	jsr $0181d5			jsr 	IF_Write
.018135					_IFT_Left:
.018135	ce 00 02	dec $0200			dec 	IFT_XCursor 				; left CTL-W
.018138	10 29		bpl $018163			bpl 	_IFT_Reposition
.01813a	a9 3f		lda #$3f			lda 	#IF_Width-1
.01813c					_IFT_SetX:
.01813c	8d 00 02	sta $0200			sta 	IFT_XCursor
.01813f	80 22		bra $018163			bra 	_IFT_Reposition
.018141					_IFT_Right:
.018141	ee 00 02	inc $0200			inc 	IFT_XCursor
.018144	ad 00 02	lda $0200			lda 	IFT_XCursor
.018147	49 40		eor #$40			eor 	#IF_Width
.018149	f0 f1		beq $01813c			beq 	_IFT_SetX
.01814b	80 16		bra $018163			bra 	_IFT_Reposition
.01814d					_IFT_Up:
.01814d	ce 01 02	dec $0201			dec 	IFT_YCursor
.018150	10 11		bpl $018163			bpl 	_IFT_Reposition
.018152	a9 1f		lda #$1f			lda 	#IF_Height-1
.018154					_IFT_SetY:
.018154	8d 01 02	sta $0201			sta 	IFT_YCursor
.018157	80 0a		bra $018163			bra 	_IFT_Reposition
.018159					_IFT_Down:
.018159	ee 01 02	inc $0201			inc 	IFT_YCursor
.01815c	ad 01 02	lda $0201			lda 	IFT_YCursor
.01815f	49 20		eor #$20			eor 	#IF_Height
.018161	f0 f1		beq $018154			beq 	_IFT_SetY
.018163					_IFT_Reposition:
.018163	ad 00 02	lda $0200			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.018166	48		pha				pha
.018167	ad 01 02	lda $0201			lda 	IFT_YCursor
.01816a	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.01816d	68		pla				pla
.01816e	aa		tax				tax
.01816f	e0 00		cpx #$00			cpx 	#0
.018171	f0 88		beq $0180fb			beq 	_IFT_RLLoop
.018173					_IFT_MoveRight:
.018173	20 cc 81	jsr $0181cc			jsr 	IF_Read
.018176	ee 00 02	inc $0200			inc 	IFT_XCursor
.018179	ca		dex				dex
.01817a	d0 f7		bne $018173			bne 	_IFT_MoveRight
.01817c	4c fb 80	jmp $0180fb			jmp 	_IFT_RLLoop
.01817f					_IFT_RLExit:
.01817f	ad 01 02	lda $0201			lda 	IFT_YCursor 				; go to start of line.
.018182	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.018185	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.018187					_IFT_RLRead:
.018187	20 cc 81	jsr $0181cc			jsr 	IF_Read
.01818a	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.01818d	e8		inx				inx
.01818e	e0 40		cpx #$40			cpx 	#IF_Width
.018190	d0 f5		bne $018187			bne 	_IFT_RLRead
.018192					_IFT_RL_Trim:
.018192	ca		dex				dex 	 							; previous char
.018193	30 07		bmi $01819c			bmi 	_IFT_Found 					; gone too far
.018195	bd 66 02	lda $0266,x			lda 	IFT_LineBuffer,x			; go back if space
.018198	c9 20		cmp #$20			cmp 	#" "
.01819a	f0 f6		beq $018192			beq 	_IFT_RL_Trim
.01819c					_IFT_Found:
.01819c	e8		inx				inx 								; forward to non-space
.01819d	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.01819f	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.0181a2	68		pla				pla
.0181a3	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.0181a5	a0 02		ldy #$02			ldy 	#IFT_LineBuffer >> 8
.0181a7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_em65816.asm

=64					IF_Width 	= 64 							; characters across
=32					IF_Height 	= 32 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line.
=8					IF_XPos 	= 8 							; current position, horizontal.
=$f0000					IF_Screen = $F0000							; 2k screen RAM here
=$f8010					IF_PKeyboard = $F8010						; Keyboard port.
=$f8000					IF_PBreak = $F8000 							; Break key.
.0181a8					IF_Reset:
.0181a8	60		rts				rts
.0181a9					IF_Home:
.0181a9	48		pha				pha
.0181aa	64 08		stz $08				stz 	IF_XPos 					; zero X position
.0181ac	a9 00		lda #$00			lda 	#IF_Screen & $FF 			; set r/w pos.
.0181ae	85 04		sta $04				sta 	IF_Pos
.0181b0	a9 00		lda #$00			lda 	#(IF_Screen >> 8) & $FF
.0181b2	85 05		sta $05				sta 	IF_Pos+1
.0181b4	a9 0f		lda #$0f			lda 	#IF_Screen >> 16
.0181b6	85 06		sta $06				sta 	IF_Pos+2
.0181b8	64 07		stz $07				stz 	IF_Pos+3
.0181ba	68		pla				pla
.0181bb	60		rts				rts
.0181bc					IF_NewLine:
.0181bc	48		pha				pha
.0181bd	64 08		stz $08				stz 	IF_XPos						; back to start of line
.0181bf	18		clc				clc 								; down one line
.0181c0	a5 04		lda $04				lda 	IF_Pos
.0181c2	69 40		adc #$40			adc 	#64
.0181c4	85 04		sta $04				sta 	IF_Pos
.0181c6	90 02		bcc $0181ca			bcc 	_IF_NoCarry 				; carry through.
.0181c8	e6 05		inc $05				inc 	IF_Pos+1
.0181ca					_IF_NoCarry:
.0181ca	68		pla				pla
.0181cb	60		rts				rts
.0181cc					IF_Read:
.0181cc	5a		phy				phy 								; save current Y
.0181cd	a4 08		ldy $08				ldy 	IF_XPos 					; read character at current position
.0181cf	b7 04		lda [$04],y			lda 	[IF_Pos],y
.0181d1	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181d3	7a		ply				ply									; restore Y
.0181d4	60		rts				rts
.0181d5					IF_Write:
.0181d5	5a		phy				phy 								; save current Y
.0181d6	a4 08		ldy $08				ldy 	IF_XPos 					; write character at current position
.0181d8	97 04		sta [$04],y			sta 	[IF_Pos],y
.0181da	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181dc	7a		ply				ply									; restore Y
.0181dd	60		rts				rts
.0181de					IF_LeftOne:
.0181de	c6 08		dec $08				dec 	IF_XPos
.0181e0	60		rts				rts
.0181e1					IF_CheckBreak:
.0181e1	af 00 80 0f	lda $0f8000			lda 	IF_PBreak					; non-zero if Ctrl+C pressed.
.0181e5	60		rts				rts
.0181e6					IF_GetKey:
.0181e6	af 10 80 0f	lda $0f8010			lda 	IF_PKeyboard				; read keyboard
.0181ea	f0 08		beq $0181f4			beq		_IFGK_NoKey 				; skip if zero,no key pressed
.0181ec	48		pha				pha 								; key pressed, clear queue.
.0181ed	a9 00		lda #$00			lda 	#0
.0181ef	8f 10 80 0f	sta $0f8010			sta 	IF_PKeyboard
.0181f3	68		pla				pla
.0181f4					_IFGK_NoKey:
.0181f4	09 00		ora #$00			ora 	#0							; set Z flag appropriately.
.0181f6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/errors.asm

.0181f7					SyntaxError:
.0181f7	20 26 82	jsr $018226			jsr 	ERR_Handler
>0181fa	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>018202	72 72 6f 72 00
.018207					TypeError:
.018207	20 26 82	jsr $018226			jsr 	ERR_Handler
>01820a	57 72 6f 6e 67 20 74 79				.text 	"Wrong type",0
>018212	70 65 00
.018215					BadParamError:
.018215	20 26 82	jsr $018226			jsr 	ERR_Handler
>018218	42 61 64 20 50 61 72 61				.text 	"Bad Parameter",0
>018220	6d 65 74 65 72 00
.018226					ERR_Handler:
.018226	a0 00		ldy #$00			ldy 	#0
.018228	c8		iny				iny
.018229	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01822b	8d 08 03	sta $0308			sta 	XS_Mantissa
.01822e	c8		iny				iny
.01822f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018231	8d 09 03	sta $0309			sta 	XS_Mantissa+1
.018234	fa		plx				plx 								; address in XY
.018235	7a		ply				ply
.018236	e8		inx				inx 								; bump, because of RTS/JSR address -1
.018237	d0 01		bne $01823a			bne 	_EHNoSkip
.018239	c8		iny				iny
.01823a					_EHNoSkip:
.01823a	20 5b 82	jsr $01825b			jsr 	PrintROMMessage 			; print message from ROM.
.01823d	ad 08 03	lda $0308			lda 	XS_Mantissa					; line number = 0
.018240	0d 09 03	ora $0309			ora 	XS_Mantissa+1
.018243	f0 0c		beq $018251			beq 	_EHNoLine
.018245	a2 56		ldx #$56			ldx 	#_EHAt & $FF 				; print " at "
.018247	a0 82		ldy #$82			ldy 	#(_EHAt >> 8) & $FF
.018249	20 5b 82	jsr $01825b			jsr 	PrintROMMessage
.01824c	a2 00		ldx #$00			ldx 	#0 							; Print line number
.01824e	20 70 82	jsr $018270			jsr 	Print16BitInteger
.018251					_EHNoLine:
.018251	80 fe		bra $018251			bra 	_EHNoLine
.018253	4c b5 84	jmp $0184b5			jmp 	WarmStart
>018256	20 61 74 20 00			_EHAt:	.text 	" at ",0
.01825b					PrintROMMessage:
.01825b	86 1a		stx $1a				stx 	zLTemp1 					; save addres
.01825d	84 1b		sty $1b				sty 	zLTemp1+1
.01825f	4b		phk				phk
.018260	68		pla				pla
.018261	85 1c		sta $1c				sta 	ZLTemp1+2
.018263	a0 00		ldy #$00			ldy 	#0
.018265					_PRMLoop:
.018265	b7 1a		lda [$1a],y			lda 	[zLTemp1],y
.018267	f0 06		beq $01826f			beq		_PRMExit
.018269	c8		iny				iny
.01826a	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01826d	80 f6		bra $018265			bra 	_PRMLoop
.01826f					_PRMExit:
.01826f	60		rts				rts
.018270					Print16BitInteger:
.018270	a9 00		lda #$00			lda 	#0 							; make 32 bit
.018272	8d 0a 03	sta $030a			sta 	XS_Mantissa+2
.018275	8d 0b 03	sta $030b			sta 	XS_Mantissa+3
.018278	8d 04 04	sta $0404			sta 	NumBufX 					; reset the conversion pointer
.01827b	aa		tax				tax 								; convert bottom level.
.01827c	20 03 92	jsr $019203			jsr 	INTToString 				; make string
.01827f	a2 00		ldx #$00			ldx 	#0 							; print buffer
.018281	bd 05 04	lda $0405,x	_P1Loop:lda 	Num_Buffer,x
.018284	f0 06		beq $01828c			beq 	_P1Exit
.018286	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018289	e8		inx				inx
.01828a	80 f5		bra $018281			bra 	_P1Loop
.01828c	60		rts		_P1Exit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm


;******  Processing file: modules/basic/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b4					lastUnaryFunction = $b4
.01828d					VectorTable:
>01828d	e2 87					.word BinaryOp_And         & $FFFF ; $80 and
>01828f	0a 88					.word BinaryOp_Or          & $FFFF ; $81 or
>018291	32 88					.word BinaryOp_Xor         & $FFFF ; $82 xor
>018293	32 88					.word BinaryOp_Eor         & $FFFF ; $83 eor
>018295	76 88					.word Binary_Equal         & $FFFF ; $84 =
>018297	95 88					.word Binary_NotEqual      & $FFFF ; $85 <>
>018299	9e 88					.word Binary_Less          & $FFFF ; $86 <
>01829b	a7 88					.word Binary_LessEqual     & $FFFF ; $87 <=
>01829d	b9 88					.word Binary_Greater       & $FFFF ; $88 >
>01829f	b0 88					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>0182a1	4e 89					.word BinaryOp_Add         & $FFFF ; $8a +
>0182a3	6e 89					.word BinaryOp_Subtract    & $FFFF ; $8b -
>0182a5	81 89					.word BinaryOp_Multiply    & $FFFF ; $8c *
>0182a7	94 89					.word BinaryOp_Divide      & $FFFF ; $8d /
>0182a9	41 83					.word NotImplemented       & $FFFF ; $8e ^
>0182ab	41 83					.word NotImplemented       & $FFFF ; $8f if
>0182ad	41 83					.word NotImplemented       & $FFFF ; $90 while
>0182af	41 83					.word NotImplemented       & $FFFF ; $91 repeat
>0182b1	41 83					.word NotImplemented       & $FFFF ; $92 for
>0182b3	41 83					.word NotImplemented       & $FFFF ; $93 then
>0182b5	41 83					.word NotImplemented       & $FFFF ; $94 endif
>0182b7	41 83					.word NotImplemented       & $FFFF ; $95 wend
>0182b9	41 83					.word NotImplemented       & $FFFF ; $96 until
>0182bb	41 83					.word NotImplemented       & $FFFF ; $97 next
>0182bd	41 83					.word NotImplemented       & $FFFF ; $98 not
>0182bf	41 83					.word NotImplemented       & $FFFF ; $99 fn(
>0182c1	c8 8a					.word Unary_Abs            & $FFFF ; $9a abs(
>0182c3	20 8c					.word Unary_Asc            & $FFFF ; $9b asc(
>0182c5	e8 99					.word Unary_Int            & $FFFF ; $9c int(
>0182c7	e6 8a					.word Unary_Peek           & $FFFF ; $9d peek(
>0182c9	5f 99					.word Unary_Rnd            & $FFFF ; $9e rnd(
>0182cb	5a 8b					.word Unary_Usr            & $FFFF ; $9f usr(
>0182cd	61 8c					.word Unary_Left           & $FFFF ; $a0 left$(
>0182cf	78 8c					.word Unary_Right          & $FFFF ; $a1 right$(
>0182d1	46 8c					.word Unary_Mid            & $FFFF ; $a2 mid$(
>0182d3	da 8d					.word Unary_Spc            & $FFFF ; $a3 spc(
>0182d5	ed 8b					.word Unary_Str            & $FFFF ; $a4 str$(
>0182d7	7c 8b					.word Unary_Val            & $FFFF ; $a5 val(
>0182d9	37 8c					.word Unary_Len            & $FFFF ; $a6 len(
>0182db	f6 8c					.word Unary_Hex            & $FFFF ; $a7 hex$(
>0182dd	41 83					.word NotImplemented       & $FFFF ; $a8 sin(
>0182df	41 83					.word NotImplemented       & $FFFF ; $a9 cos(
>0182e1	41 83					.word NotImplemented       & $FFFF ; $aa tan(
>0182e3	41 83					.word NotImplemented       & $FFFF ; $ab atn(
>0182e5	41 83					.word NotImplemented       & $FFFF ; $ac exp(
>0182e7	41 83					.word NotImplemented       & $FFFF ; $ad log(
>0182e9	41 83					.word NotImplemented       & $FFFF ; $ae sqr(
>0182eb	50 8d					.word Unary_Dec            & $FFFF ; $af dec(
>0182ed	ea 8a					.word Unary_Deek           & $FFFF ; $b0 deek(
>0182ef	ee 8a					.word Unary_Leek           & $FFFF ; $b1 leek(
>0182f1	22 8b					.word Unary_Mod            & $FFFF ; $b2 mod(
>0182f3	76 8a					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>0182f5	b8 8d					.word Unary_Chr            & $FFFF ; $b4 chr$(
>0182f7	41 83					.word NotImplemented       & $FFFF ; $b5 $
>0182f9	41 83					.word NotImplemented       & $FFFF ; $b6 $(
>0182fb	41 83					.word NotImplemented       & $FFFF ; $b7 #
>0182fd	41 83					.word NotImplemented       & $FFFF ; $b8 #(
>0182ff	41 83					.word NotImplemented       & $FFFF ; $b9 %
>018301	41 83					.word NotImplemented       & $FFFF ; $ba %(
>018303	41 83					.word NotImplemented       & $FFFF ; $bb (
>018305	41 83					.word NotImplemented       & $FFFF ; $bc )
>018307	41 83					.word NotImplemented       & $FFFF ; $bd ,
>018309	3d 85					.word Command_COLON        & $FFFF ; $be :
>01830b	41 83					.word NotImplemented       & $FFFF ; $bf ;
>01830d	41 83					.word NotImplemented       & $FFFF ; $c0 def
>01830f	f2 85					.word Command_CLR          & $FFFF ; $c1 clr
>018311	00 86					.word Command_STOP         & $FFFF ; $c2 stop
>018313	41 83					.word NotImplemented       & $FFFF ; $c3 data
>018315	41 83					.word NotImplemented       & $FFFF ; $c4 read
>018317	41 83					.word NotImplemented       & $FFFF ; $c5 dim
>018319	41 83					.word NotImplemented       & $FFFF ; $c6 to
>01831b	41 83					.word NotImplemented       & $FFFF ; $c7 step
>01831d	41 83					.word NotImplemented       & $FFFF ; $c8 gosub
>01831f	41 83					.word NotImplemented       & $FFFF ; $c9 return
>018321	41 83					.word NotImplemented       & $FFFF ; $ca goto
>018323	5f 85					.word Command_END          & $FFFF ; $cb end
>018325	41 83					.word NotImplemented       & $FFFF ; $cc input
>018327	3e 85					.word Command_LET          & $FFFF ; $cd let
>018329	41 83					.word NotImplemented       & $FFFF ; $ce list
>01832b	41 83					.word NotImplemented       & $FFFF ; $cf new
>01832d	41 83					.word NotImplemented       & $FFFF ; $d0 old
>01832f	41 83					.word NotImplemented       & $FFFF ; $d1 on
>018331	41 83					.word NotImplemented       & $FFFF ; $d2 restore
>018333	41 83					.word NotImplemented       & $FFFF ; $d3 poke
>018335	63 85					.word Command_PRINT        & $FFFF ; $d4 print
>018337	c3 84					.word Command_RUN          & $FFFF ; $d5 run
>018339	41 83					.word NotImplemented       & $FFFF ; $d6 wait
>01833b	41 83					.word NotImplemented       & $FFFF ; $d7 doke
>01833d	41 83					.word NotImplemented       & $FFFF ; $d8 loke
>01833f	d6 85					.word Command_ASSERT       & $FFFF ; $d9 assert
.018341					NotImplemented:
.018341	20 26 82	jsr $018226			jsr ERR_Handler
>018344	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>01834c	65 6d 65 6e 74 65 64 00
.018354					BinaryPrecedence:
>018354	01					.byte 1    ; $80 and
>018355	01					.byte 1    ; $81 or
>018356	01					.byte 1    ; $82 xor
>018357	01					.byte 1    ; $83 eor
>018358	02					.byte 2    ; $84 =
>018359	02					.byte 2    ; $85 <>
>01835a	02					.byte 2    ; $86 <
>01835b	02					.byte 2    ; $87 <=
>01835c	02					.byte 2    ; $88 >
>01835d	02					.byte 2    ; $89 >=
>01835e	03					.byte 3    ; $8a +
>01835f	03					.byte 3    ; $8b -
>018360	04					.byte 4    ; $8c *
>018361	04					.byte 4    ; $8d /
>018362	05					.byte 5    ; $8e ^
.018363					KeywordText:
>018363	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>018366	4f d2					.byte $4f,$d2                          ; $81 or
>018368	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>01836b	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>01836e	bd					.byte $bd                              ; $84 =
>01836f	3c be					.byte $3c,$be                          ; $85 <>
>018371	bc					.byte $bc                              ; $86 <
>018372	3c bd					.byte $3c,$bd                          ; $87 <=
>018374	be					.byte $be                              ; $88 >
>018375	3e bd					.byte $3e,$bd                          ; $89 >=
>018377	ab					.byte $ab                              ; $8a +
>018378	ad					.byte $ad                              ; $8b -
>018379	aa					.byte $aa                              ; $8c *
>01837a	af					.byte $af                              ; $8d /
>01837b	de					.byte $de                              ; $8e ^
>01837c	49 c6					.byte $49,$c6                          ; $8f if
>01837e	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>018383	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>018389	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>01838c	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>018390	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>018395	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>018399	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>01839e	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>0183a2	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>0183a5	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>0183a8	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>0183ac	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>0183b0	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>0183b4	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>0183b9	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>0183bd	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>0183c1	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>0183c7	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>0183ce	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>0183d3	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>0183d7	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>0183dc	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>0183e0	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>0183e4	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>0183e9	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>0183ed	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>0183f1	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>0183f5	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>0183f9	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>0183fd	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>018401	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>018405	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>018409	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>01840e	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>018413	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>018417	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>01841b	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>018420	a4					.byte $a4                              ; $b5 $
>018421	24 a8					.byte $24,$a8                          ; $b6 $(
>018423	a3					.byte $a3                              ; $b7 #
>018424	23 a8					.byte $23,$a8                          ; $b8 #(
>018426	a5					.byte $a5                              ; $b9 %
>018427	25 a8					.byte $25,$a8                          ; $ba %(
>018429	a8					.byte $a8                              ; $bb (
>01842a	a9					.byte $a9                              ; $bc )
>01842b	ac					.byte $ac                              ; $bd ,
>01842c	ba					.byte $ba                              ; $be :
>01842d	bb					.byte $bb                              ; $bf ;
>01842e	44 45 c6				.byte $44,$45,$c6                      ; $c0 def
>018431	43 4c d2				.byte $43,$4c,$d2                      ; $c1 clr
>018434	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $c2 stop
>018438	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c3 data
>01843c	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c4 read
>018440	44 49 cd				.byte $44,$49,$cd                      ; $c5 dim
>018443	54 cf					.byte $54,$cf                          ; $c6 to
>018445	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c7 step
>018449	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $c8 gosub
>01844e	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $c9 return
>018454	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $ca goto
>018458	45 4e c4				.byte $45,$4e,$c4                      ; $cb end
>01845b	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $cc input
>018460	4c 45 d4				.byte $4c,$45,$d4                      ; $cd let
>018463	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $ce list
>018467	4e 45 d7				.byte $4e,$45,$d7                      ; $cf new
>01846a	4f 4c c4				.byte $4f,$4c,$c4                      ; $d0 old
>01846d	4f ce					.byte $4f,$ce                          ; $d1 on
>01846f	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d2 restore
>018476	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d3 poke
>01847a	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d4 print
>01847f	52 55 ce				.byte $52,$55,$ce                      ; $d5 run
>018482	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d6 wait
>018486	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $d7 doke
>01848a	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $d8 loke
>01848e	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $d9 assert
>018494	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_dollar = $b5
=$b6					token_dollarlparen = $b6
=$b7					token_hash = $b7
=$b8					token_hashlparen = $b8
=$b9					token_percent = $b9
=$ba					token_percentlparen = $ba
=$bb					token_lparen = $bb
=$bc					token_rparen = $bc
=$bd					token_comma = $bd
=$be					token_colon = $be
=$bf					token_semicolon = $bf
=$c0					token_def = $c0
=$c1					token_clr = $c1
=$c2					token_stop = $c2
=$c3					token_data = $c3
=$c4					token_read = $c4
=$c5					token_dim = $c5
=$c6					token_to = $c6
=$c7					token_step = $c7
=$c8					token_gosub = $c8
=$c9					token_return = $c9
=$ca					token_goto = $ca
=$cb					token_end = $cb
=$cc					token_input = $cc
=$cd					token_let = $cd
=$ce					token_list = $ce
=$cf					token_new = $cf
=$d0					token_old = $d0
=$d1					token_on = $d1
=$d2					token_restore = $d2
=$d3					token_poke = $d3
=$d4					token_print = $d4
=$d5					token_run = $d5
=$d6					token_wait = $d6
=$d7					token_doke = $d7
=$d8					token_loke = $d8
=$d9					token_assert = $d9

;******  Return to file: modules/basic/core.asm

.018495					BASIC_Start:
.018495	20 a8 81	jsr $0181a8			jsr 	IF_Reset 					; set up and clear screen.
.018498	20 00 80	jsr $018000			jsr 	IFT_ClearScreen
.01849b	a9 5c		lda #$5c			lda 	#$5C 						; JMP Long opcode
.01849d	8d 04 03	sta $0304			sta 	LocalVector
.0184a0	8d 00 03	sta $0300			sta 	UserVector
.0184a3	a9 6a		lda #$6a			lda 	#USRDefault & $FF 			; reset USR vector
.0184a5	8d 01 03	sta $0301			sta 	UserVector+1
.0184a8	a9 8b		lda #$8b			lda 	#(USRDefault >> 8) & $FF
.0184aa	8d 02 03	sta $0302			sta 	UserVector+2
.0184ad	a9 01		lda #$01			lda 	#(USRDefault >> 16) & $FF
.0184af	8d 03 03	sta $0303			sta 	UserVector+3
.0184b2	20 f2 85	jsr $0185f2			jsr 	ResetRunStatus 				; clear everything (CLR command)
.0184b5					WarmStart:
.0184b5	c2 30		rep #$30			rep 	#$30
.0184b7	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.0184ba	1b		tcs				tcs
.0184bb	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.0184be	e2 30		sep #$30			sep 	#$30
.0184c0	4c c3 84	jmp $0184c3			jmp 	COMMAND_Run

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/run.asm

.0184c3					Command_RUN:
.0184c3	20 f2 85	jsr $0185f2			jsr 	ResetRunStatus 				; clear, reset stacks etc.
.0184c6	a9 00		lda #$00			lda 	#BasicProgram & $FF
.0184c8	85 16		sta $16				sta 	zCodePtr+0
.0184ca	a9 10		lda #$10			lda 	#BasicProgram >> 8
.0184cc	85 17		sta $17				sta 	zCodePtr+1
.0184ce	a9 00		lda #$00			lda 	#0
.0184d0	85 18		sta $18				sta 	zCodePtr+2
.0184d2	85 19		sta $19				sta 	zCodePtr+3
.0184d4	a0 03		ldy #$03			ldy 	#3
.0184d6					RUN_NewLine:
.0184d6	a0 00		ldy #$00			ldy 	#0
.0184d8	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0184da	c8		iny				iny
.0184db	c8		iny				iny
.0184dc	c8		iny				iny
.0184dd	c9 00		cmp #$00			cmp 	#0 							; if the offset is zero then END.
.0184df	d0 16		bne $0184f7			bne 	RUN_NextCommand
.0184e1	4c 00 86	jmp $018600			jmp 	Command_STOP 				; go do the command code.
.0184e4					RUN_Skip:
.0184e4	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.0184e6	c8		iny				iny 								; skip
.0184e7	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.0184e9	90 0c		bcc $0184f7			bcc 	_SEDone 					; so just skip over it.
.0184eb	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.0184ed	90 07		bcc $0184f6			bcc 	_SEDouble
.0184ef	98		tya				tya 								; this is Y + 1
.0184f0	18		clc				clc
.0184f1	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.0184f3	a8		tay				tay 								; back in Y.
.0184f4	88		dey				dey 								; fix up, one for the +1, one for the iny
.0184f5	88		dey				dey
.0184f6					_SEDouble:
.0184f6	c8		iny				iny
.0184f7					_SEDone:
.0184f7					RUN_NextCommand:
.0184f7	a9 00		lda #$00			lda 	#0 							; this resets temporary string allocation.
.0184f9	85 21		sta $21				sta 	zTempStr+1 					; (initialised when first called)
.0184fb	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0184fd	c9 be		cmp #$be			cmp 	#token_Colon 				; skip over colons
.0184ff	f0 e3		beq $0184e4			beq 	RUN_Skip
.018501	c9 00		cmp #$00			cmp 	#0 							; if non-zero execute whatever
.018503	d0 0f		bne $018514			bne 	RUN_Execute
.018505					RUN_NextLine:
.018505	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018507	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.018509	18		clc				clc
.01850a	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.01850c	85 16		sta $16				sta 	zCodePtr
.01850e	90 02		bcc $018512			bcc 	_SNLNoCarry
.018510	e6 17		inc $17				inc 	zCodePtr+1
.018512					_SNLNoCarry:
.018512	80 c2		bra $0184d6			bra 	RUN_NewLine 				; go do the new line code
.018514					RUN_Execute:
.018514	c9 f8		cmp #$f8			cmp 	#$F8 						; handle shifts, REM etc.
.018516	b0 1e		bcs $018536			bcs 	RUN_Extension
.018518	c8		iny				iny
.018519	0a		asl a				asl 	a 							; double the character read.
.01851a	90 14		bcc $018530			bcc 	RUN_Default 				; if carry clear was $00-$7F, so try LET.
.01851c	aa		tax				tax 								; ready to look up.
.01851d	bf 8d 82 01	lda $01828d,x			lda 	VectorTable,x 				; copy address into LocalVector
.018521	8d 05 03	sta $0305			sta 	LocalVector+1
.018524	bf 8e 82 01	lda $01828e,x			lda 	VectorTable+1,x
.018528	8d 06 03	sta $0306			sta 	LocalVector+2
.01852b	20 1b 87	jsr $01871b			jsr 	EVCallLocalVector 			; execute the appropriate code.
.01852e	80 c7		bra $0184f7			bra 	RUN_NextCommand 			; do the next command.
.018530					RUN_Default:
.018530	88		dey				dey
.018531	20 3e 85	jsr $01853e			jsr 	Command_LET 				; and try LET.
.018534	80 c1		bra $0184f7			bra 	RUN_NextCommand
.018536					RUN_Extension:
.018536	c9 ff		cmp #$ff			cmp 	#$FF 						; if $FF (REM)
.018538	f0 aa		beq $0184e4			beq 	RUN_Skip 					; skip over it.
.01853a	4c f7 81	jmp $0181f7			jmp 	SyntaxError
.01853d					Command_COLON:
.01853d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/let.asm

.01853e					Command_LET:
.01853e	20 e5 8e	jsr $018ee5			jsr 	VariableFind 				; get reference to one variable.
.018541	a9 84		lda #$84			lda 	#token_Equal  				; get equals
.018543	20 2b 8e	jsr $018e2b			jsr 	CheckNextToken
.018546	a5 22		lda $22				lda 	zVarDataPtr 				; save variable info on stack
.018548	48		pha				pha
.018549	a5 23		lda $23				lda 	zVarDataPtr+1
.01854b	48		pha				pha
.01854c	a5 24		lda $24				lda 	zVarType
.01854e	48		pha				pha
.01854f	20 0b 86	jsr $01860b			jsr 	EvaluateExpression 			; evaluate the RHS.
.018552	68		pla				pla 								; restore target variable information.
.018553	85 24		sta $24				sta 	zVarType
.018555	68		pla				pla
.018556	85 23		sta $23				sta 	zVarDataPtr+1
.018558	68		pla				pla
.018559	85 22		sta $22				sta 	zVarDataPtr
.01855b	20 81 90	jsr $019081			jsr 	VariableSet 				; set the value out.
.01855e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/end.asm

.01855f					Command_END:
>01855f	02						.byte 	2
.018560	4c b5 84	jmp $0184b5			jmp 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/print.asm

.018563					Command_PRINT:
.018563	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018565	c9 00		cmp #$00			cmp 	#0 							; end
.018567	f0 69		beq $0185d2			beq 	_CPR_NewLine
.018569	c9 be		cmp #$be			cmp 	#token_Colon
.01856b	f0 65		beq $0185d2			beq 	_CPR_NewLine
.01856d	c9 bf		cmp #$bf			cmp 	#token_SemiColon
.01856f	f0 54		beq $0185c5			beq 	_CPR_Skip
.018571	c9 bd		cmp #$bd			cmp 	#token_Comma
.018573	f0 4d		beq $0185c2			beq 	_CPR_Tab
.018575	20 0b 86	jsr $01860b			jsr 	EvaluateExpression 			; get expression.
.018578	ad 0d 03	lda $030d			lda 	XS_Type 					; get type.
.01857b	29 02		and #$02			and 	#2
.01857d	d0 25		bne $0185a4			bne 	_CPR_String 				; if type = 2 output as string.
.01857f					_CPR_Number:
.01857f	a9 00		lda #$00			lda 	#0 							; reset buffer index
.018581	8d 04 04	sta $0404			sta 	NumBufX
.018584	ad 0d 03	lda $030d			lda 	XS_Type 					; get type
.018587	4a		lsr a				lsr 	a
.018588	b0 05		bcs $01858f			bcs 	_CPRInt 					; if msb set do as integer
.01858a	20 17 98	jsr $019817			jsr 	FPToString 					; call fp to str otherwise
.01858d	80 03		bra $018592			bra 	_CPRNPrint
.01858f	20 03 92	jsr $019203	_CPRInt:jsr 	IntToString
.018592					_CPRNPrint:
.018592	ad 05 04	lda $0405			lda 	Num_Buffer 					; is first character -
.018595	c9 2d		cmp #$2d			cmp 	#"-"
.018597	f0 05		beq $01859e			beq 	_CPRNoSpace
.018599	a9 20		lda #$20			lda 	#" "						; print the leading space
.01859b	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter 			; so beloved of MS Basics.
.01859e					_CPRNoSpace:
.01859e	a2 04		ldx #$04			ldx 	#(Num_Buffer-1) & $FF
.0185a0	a9 04		lda #$04			lda 	#(Num_Buffer-1) >> 8
.0185a2	80 06		bra $0185aa			bra 	_CPRPrint
.0185a4					_CPR_String:
.0185a4	ae 08 03	ldx $0308			ldx 	XS_Mantissa
.0185a7	ad 09 03	lda $0309			lda 	XS_Mantissa+1
.0185aa					_CPRPrint:
.0185aa	86 1e		stx $1e				stx 	zGenPtr
.0185ac	85 1f		sta $1f				sta 	zGenPtr+1
.0185ae	5a		phy				phy
.0185af	a0 00		ldy #$00			ldy 	#0							; get length into X
.0185b1	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.0185b3	aa		tax				tax
.0185b4	f0 09		beq $0185bf			beq 	_CPREndPrint 				; nothing to print
.0185b6					_CPRLoop:
.0185b6	c8		iny				iny
.0185b7	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.0185b9	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0185bc	ca		dex				dex
.0185bd	d0 f7		bne $0185b6			bne 	_CPRLoop
.0185bf					_CPREndPrint:
.0185bf	7a		ply				ply
.0185c0	80 a1		bra $018563			bra 	Command_Print
.0185c2					_CPR_Tab:
.0185c2	20 4f 80	jsr $01804f			jsr 	IFT_Tab
.0185c5					_CPR_Skip:
.0185c5	c8		iny				iny
.0185c6	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0185c8	c9 be		cmp #$be			cmp 	#token_Colon 				; colon or $00, exit
.0185ca	f0 09		beq $0185d5			beq 	_CPR_Exit
.0185cc	c9 00		cmp #$00			cmp 	#0
.0185ce	d0 93		bne $018563			bne 	Command_PRINT 				; if not go round again.
.0185d0	80 03		bra $0185d5			bra 	_CPR_Exit
.0185d2					_CPR_NewLine:
.0185d2	20 5c 80	jsr $01805c			jsr 	IFT_NewLine
.0185d5					_CPR_Exit:
.0185d5	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/assert.asm

.0185d6					Command_ASSERT:
.0185d6	20 b1 87	jsr $0187b1			jsr 	EvaluateNumber 				; calculate thing being asserted
.0185d9	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; check if true (non-zero)
.0185dc	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.0185df	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.0185e2	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.0185e5	f0 01		beq $0185e8			beq 	_ASFail
.0185e7	60		rts				rts
.0185e8					_ASFail:
.0185e8	20 26 82	jsr $018226			jsr ERR_Handler
>0185eb	41 73 73 65 72 74 00			.text "Assert",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.0185f2					Command_CLR:
.0185f2					ResetRunStatus:
.0185f2	20 f1 8e	jsr $018ef1			jsr 	VariableClear
.0185f5	a9 00		lda #$00			lda 	#HighMemory & $FF
.0185f7	8d 00 04	sta $0400			sta 	StringPtr
.0185fa	a9 80		lda #$80			lda 	#HighMemory >> 8
.0185fc	8d 01 04	sta $0401			sta 	StringPtr+1
.0185ff	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/stop.asm

.018600					Command_STOP:
.018600	20 26 82	jsr $018226			jsr ERR_Handler
>018603	53 74 6f 70 00				.text "Stop",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.018608					EVESyntax:
.018608	4c f7 81	jmp $0181f7			jmp 	SyntaxError
.01860b					EvaluateExpression:
.01860b	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.01860d					EvaluateExpressionX:
.01860d	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.01860f					EvaluateExpressionXA:
.01860f	48		pha				pha 								; save precedence on stack.
.018610	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018612	f0 f4		beq $018608			beq 	EVESyntax 					; end of line, syntax error.
.018614	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.018616	b0 03		bcs $01861b			bcs 	_EVNotVariable
.018618	4c 12 87	jmp $018712			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.01861b					_EVNotVariable:
.01861b	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.01861d	90 e9		bcc $018608			bcc 	EVESyntax
.01861f	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.018621	b0 7f		bcs $0186a2			bcs 	_EVNotInteger
.018623	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.018625	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.018628	a9 00		lda #$00			lda 	#0
.01862a	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.01862d	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018630	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018633	1a		inc a				inc 	a 							; set to type 1 (integer)
.018634	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018637					_EVCheckNextInteger:
.018637	c8		iny				iny
.018638	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01863a	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.01863c	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.01863e	b0 0d		bcs $01864d			bcs 	_EVCheckDecimal
.018640	48		pha				pha 								; save it.
.018641	20 1e 87	jsr $01871e			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.018644	68		pla				pla
.018645	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.018648	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.01864b	80 ea		bra $018637			bra 	_EVCheckNextInteger
.01864d					_EVCheckDecimal:
.01864d	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01864f	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.018651	d0 05		bne $018658			bne 	_EVGotAtom 					; no, get atom.
.018653					_EVIsDecimal:
.018653	20 4e 87	jsr $01874e			jsr 	EVGetDecimal 				; extend to the decimal part.
.018656	80 00		bra $018658			bra 	_EVGotAtom 					; and continue to got atom.
.018658					_EVGotAtom:
.018658	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01865a	10 44		bpl $0186a0			bpl 	_EVExitDrop 				; must be a token.
.01865c	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.01865e	b0 40		bcs $0186a0			bcs 	_EVExitDrop
.018660	68		pla				pla 								; get current precedence
.018661	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.018663	da		phx				phx 								; save X
.018664	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018666	aa		tax				tax 								; put in X
.018667	bf d4 82 01	lda $0182d4,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.01866b	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.01866d	fa		plx				plx 								; restore X
.01866e	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.018670	90 2f		bcc $0186a1			bcc 	_EVExit 					; exit if too low.
.018672	f0 2d		beq $0186a1			beq 	_EVExit 					; exit if equals
.018674	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.018676	48		pha				pha
.018677	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018679	48		pha				pha
.01867a	c8		iny				iny
.01867b	da		phx				phx 								; save current position
.01867c	e8		inx				inx
.01867d	e8		inx				inx
.01867e	e8		inx				inx
.01867f	e8		inx				inx
.018680	e8		inx				inx
.018681	e8		inx				inx
.018682	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.018684	20 0f 86	jsr $01860f			jsr 	EvaluateExpressionXA 		; do the RHS.
.018687	fa		plx				plx 								; restore X
.018688	68		pla				pla 								; get the binary operator in A.
.018689					_EVCallA:
.018689	da		phx				phx 								; save X again
.01868a	0a		asl a				asl 	a 							; double, lose the MSB.
.01868b	aa		tax				tax									; put in X
.01868c	bf 8d 82 01	lda $01828d,x			lda 	VectorTable,x 				; copy address into zGenPtr
.018690	8d 05 03	sta $0305			sta 	LocalVector+1
.018693	bf 8e 82 01	lda $01828e,x			lda 	VectorTable+1,x
.018697	8d 06 03	sta $0306			sta 	LocalVector+2
.01869a	fa		plx				plx 								; restore X
.01869b	20 1b 87	jsr $01871b			jsr 	EVCallLocalVector
.01869e	80 b8		bra $018658			bra 	_EVGotAtom 					; and loop back.
.0186a0					_EVExitDrop:
.0186a0	68		pla				pla
.0186a1					_EVExit:
.0186a1	60		rts				rts
.0186a2					_EVNotInteger:
.0186a2	c8		iny				iny
.0186a3	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.0186a5	d0 19		bne $0186c0			bne 	_EVNotMinus
.0186a7	20 9f 87	jsr $01879f			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.0186aa	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.0186ad	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.0186af	f0 05		beq $0186b6			beq 	_EVMinusFloat
.0186b1	20 de 91	jsr $0191de			jsr 	IntegerNegateAlways 		; negation
.0186b4	80 a2		bra $018658			bra 	_EVGotAtom 					; and go back.
.0186b6					_EVMinusFloat:
.0186b6	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; invert the sign bit.
.0186b9	49 80		eor #$80			eor 	#$80
.0186bb	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0186be	80 98		bra $018658			bra 	_EVGotAtom
.0186c0					_EVNotMinus:
.0186c0	c9 bb		cmp #$bb			cmp 	#token_lparen 				; is it left parenthesis
.0186c2	d0 17		bne $0186db			bne 	_EVNotParenthesis
.0186c4	20 0d 86	jsr $01860d			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.0186c7	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0186c9	c8		iny				iny
.0186ca	c9 bc		cmp #$bc			cmp 	#token_rparen 				; okay if right bracket.
.0186cc	f0 8a		beq $018658			beq 	_EVGotAtom
.0186ce	20 26 82	jsr $018226			jsr ERR_Handler
>0186d1	4d 69 73 73 69 6e 67 20			.text "Missing )",0
>0186d9	29 00
.0186db					_EVNotParenthesis:
.0186db	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.0186dd	d0 0c		bne $0186eb			bne 	_EVNotNot
.0186df	20 9f 87	jsr $01879f			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.0186e2	20 ec 96	jsr $0196ec			jsr 	FPUToInteger 				; make it an integer - if possible.
.0186e5	20 7c 87	jsr $01877c			jsr 	NotInteger 					; do the not calculation
.0186e8	4c 58 86	jmp $018658			jmp 	_EVGotAtom
.0186eb					_EVNotNot:
.0186eb	c9 fe		cmp #$fe			cmp 	#$FE
.0186ed	d0 15		bne $018704			bne 	_EVNotString
.0186ef	20 bf 8e	jsr $018ebf			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.0186f2	a5 20		lda $20				lda 	zTempStr 					; copy address of string into mantissa
.0186f4	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0186f7	a5 21		lda $21				lda 	zTempStr+1
.0186f9	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0186fc	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.0186fe	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018701	4c 58 86	jmp $018658			jmp 	_EVGotAtom
.018704					_EVNotString:
.018704	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.018706	90 04		bcc $01870c			bcc 	_EVBadElement
.018708	c9 b5		cmp #$b5			cmp 	#lastUnaryFunction+1
.01870a	90 03		bcc $01870f			bcc 	_EVUnaryFunction
.01870c					_EVBadElement:
.01870c	4c f7 81	jmp $0181f7			jmp 	SyntaxError
.01870f					_EVUnaryFunction:
.01870f	4c 89 86	jmp $018689			jmp 	_EVCallA
.018712					_EVVariableHandler:
.018712	20 e5 8e	jsr $018ee5			jsr 	VariableFind 				; locate a variable
.018715	20 22 90	jsr $019022			jsr 	VariableGet 				; copy into memory.
.018718	4c 58 86	jmp $018658			jmp 	_EVGotAtom 					; and go round.
.01871b					EVCallLocalVector:
.01871b	6c 05 03	jmp ($0305)			jmp 	(LocalVector+1)
.01871e					EVShiftMantissaLeft6:
.01871e	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.018721	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.018724	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018727	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.01872a	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.01872d	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018730	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018733	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018736	a9 00		lda #$00			lda 	#0
.018738	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.01873b	20 3e 87	jsr $01873e			jsr 	_EVSMLShift 					; call it here to do it twice
.01873e					_EVSMLShift:
.01873e	5e 0c 03	lsr $030c,x			lsr 	XS_Exponent,x
.018741	7e 0b 03	ror $030b,x			ror 	XS_Mantissa+3,x
.018744	7e 0a 03	ror $030a,x			ror 	XS_Mantissa+2,x
.018747	7e 09 03	ror $0309,x			ror 	XS_Mantissa+1,x
.01874a	7e 08 03	ror $0308,x			ror 	XS_Mantissa+0,x
.01874d	60		rts				rts
.01874e					EVGetDecimal:
.01874e	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.018750	8d 05 04	sta $0405			sta 	Num_Buffer
.018753	da		phx				phx
.018754	c8		iny				iny
.018755	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018757	c8		iny				iny
.018758	3a		dec a				dec 	a								; convert to a string length.
.018759	3a		dec a				dec 	a
.01875a	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.01875c					_EVGDCopy:
.01875c	48		pha				pha 									; save count
.01875d	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01875f	9d 05 04	sta $0405,x			sta 	Num_Buffer,x
.018762	e8		inx				inx 									; forward ....
.018763	c8		iny				iny
.018764	68		pla				pla 									; get count
.018765	3a		dec a				dec 	a 								; until zero
.018766	d0 f4		bne $01875c			bne 	_EVGDCopy
.018768	9d 05 04	sta $0405,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.01876b	fa		plx				plx 									; restore X
.01876c	a9 05		lda #$05			lda 	#Num_Buffer & $FF 				; set zGenPtr
.01876e	85 1e		sta $1e				sta 	zGenPtr
.018770	a9 04		lda #$04			lda 	#Num_Buffer >> 8
.018772	85 1f		sta $1f				sta 	zGenPtr+1
.018774	5a		phy				phy 									; save Y
.018775	a0 00		ldy #$00			ldy 	#0 								; start position
.018777	20 de 98	jsr $0198de			jsr 	FPFromString 					; convert current
.01877a	7a		ply				ply 									; restore Y
.01877b	60		rts				rts
.01877c					NotInteger:
.01877c	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.01877f	49 ff		eor #$ff			eor 	#$FF
.018781	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018784	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018787	49 ff		eor #$ff			eor 	#$FF
.018789	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.01878c	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.01878f	49 ff		eor #$ff			eor 	#$FF
.018791	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018794	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.018797	49 ff		eor #$ff			eor 	#$FF
.018799	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.01879c	60		rts				rts
.01879d					EvaluateGetAtom:
.01879d	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.01879f					EvaluateGetAtomX:
.01879f	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.0187a1	20 0f 86	jsr $01860f			jsr 	EvaluateExpressionXA
.0187a4	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.0187a7	29 0f		and #$0f			and 	#15
.0187a9	c9 02		cmp #$02			cmp 	#2
.0187ab	b0 01		bcs $0187ae			bcs 	EvaluateType
.0187ad	60		rts				rts
.0187ae					EvaluateType:
.0187ae	4c 07 82	jmp $018207			jmp 	TypeError
.0187b1					EvaluateNumber:
.0187b1	a2 00		ldx #$00			ldx 	#0
.0187b3					EvaluateNumberX:
.0187b3	20 0d 86	jsr $01860d			jsr 	EvaluateExpressionX
.0187b6	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 0/1
.0187b9	29 0f		and #$0f			and 	#15
.0187bb	c9 02		cmp #$02			cmp 	#2
.0187bd	b0 ef		bcs $0187ae			bcs 	EvaluateType
.0187bf	60		rts				rts
.0187c0					EvaluateInteger:
.0187c0	a2 00		ldx #$00			ldx 	#0
.0187c2					EvaluateIntegerX:
.0187c2	20 b3 87	jsr $0187b3			jsr 	EvaluateNumberX
.0187c5	20 ec 96	jsr $0196ec			jsr 	FPUToInteger
.0187c8	60		rts				rts
.0187c9					EvaluateString:
.0187c9	a2 00		ldx #$00			ldx 	#0
.0187cb					EvaluateStringX:
.0187cb	20 0d 86	jsr $01860d			jsr 	EvaluateExpressionX
.0187ce	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 2
.0187d1	29 0f		and #$0f			and 	#15
.0187d3	c9 02		cmp #$02			cmp 	#2
.0187d5	d0 d7		bne $0187ae			bne 	EvaluateType
.0187d7	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.0187da	85 1e		sta $1e				sta 	zGenPtr
.0187dc	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0187df	85 1f		sta $1f				sta 	zGenPtr+1
.0187e1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.0187e2					BinaryOp_And:
.0187e2	20 5a 88	jsr $01885a			jsr 	BinaryMakeBothInteger
.0187e5	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.0187e8	3d 0e 03	and $030e,x			and 	XS2_Mantissa+0,x
.0187eb	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0187ee	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.0187f1	3d 0f 03	and $030f,x			and 	XS2_Mantissa+1,x
.0187f4	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0187f7	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.0187fa	3d 10 03	and $0310,x			and 	XS2_Mantissa+2,x
.0187fd	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018800	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.018803	3d 11 03	and $0311,x			and 	XS2_Mantissa+3,x
.018806	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018809	60		rts				rts
.01880a					BinaryOp_Or:
.01880a	20 5a 88	jsr $01885a			jsr 	BinaryMakeBothInteger
.01880d	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.018810	1d 0e 03	ora $030e,x			ora 	XS2_Mantissa+0,x
.018813	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018816	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.018819	1d 0f 03	ora $030f,x			ora 	XS2_Mantissa+1,x
.01881c	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.01881f	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.018822	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.018825	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018828	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.01882b	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.01882e	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018831	60		rts				rts
.018832					BinaryOp_Eor:
.018832					BinaryOp_Xor:
.018832	20 5a 88	jsr $01885a			jsr 	BinaryMakeBothInteger
.018835	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.018838	5d 0e 03	eor $030e,x			eor 	XS2_Mantissa+0,x
.01883b	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.01883e	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.018841	5d 0f 03	eor $030f,x			eor 	XS2_Mantissa+1,x
.018844	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018847	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.01884a	5d 10 03	eor $0310,x			eor 	XS2_Mantissa+2,x
.01884d	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018850	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.018853	5d 11 03	eor $0311,x			eor 	XS2_Mantissa+3,x
.018856	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018859	60		rts				rts
.01885a					BinaryMakeBothInteger:
.01885a	da		phx				phx 								; save X
.01885b	e8		inx				inx
.01885c	e8		inx				inx
.01885d	e8		inx				inx
.01885e	e8		inx				inx
.01885f	e8		inx				inx
.018860	e8		inx				inx
.018861	20 65 88	jsr $018865			jsr 	BinaryMakeInteger 			; convert to integer.
.018864	fa		plx				plx 								; restore X and fall through.
.018865					BinaryMakeInteger:
.018865	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type byte.
.018868	29 0f		and #$0f			and 	#15 						; check type zero
.01886a	f0 04		beq $018870			beq 	_BMIConvert 				; if float convert to integer.
.01886c	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.01886d	90 04		bcc $018873			bcc 	_BMIError
.01886f	60		rts				rts
.018870					_BMIConvert:
.018870	4c ec 96	jmp $0196ec			jmp 	FPUToInteger 				; convert to integer
.018873					_BMIError:
.018873	4c 07 82	jmp $018207			jmp 	TypeError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.018876					Binary_Equal:
.018876	20 c2 88	jsr $0188c2			jsr 	CompareValues
.018879	09 00		ora #$00			ora 	#0
.01887b	f0 04		beq $018881			beq 	CCTrue
.01887d	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.01887f	80 02		bra $018883			bra 	CCWrite
.018881	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.018883	9d 08 03	sta $0308,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.018886	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018889	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01888c	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.01888f	a9 01		lda #$01			lda 	#1
.018891	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; set type to integer whatever.
.018894	60		rts				rts
.018895					Binary_NotEqual:
.018895	20 c2 88	jsr $0188c2			jsr 	CompareValues
.018898	09 00		ora #$00			ora 	#0
.01889a	f0 e1		beq $01887d			beq 	CCFalse
.01889c	80 e3		bra $018881			bra 	CCTrue
.01889e					Binary_Less:
.01889e	20 c2 88	jsr $0188c2			jsr 	CompareValues
.0188a1	09 00		ora #$00			ora 	#0
.0188a3	30 dc		bmi $018881			bmi 	CCTrue
.0188a5	80 d6		bra $01887d			bra 	CCFalse
.0188a7					Binary_LessEqual:
.0188a7	20 c2 88	jsr $0188c2			jsr 	CompareValues
.0188aa	c9 01		cmp #$01			cmp 	#1
.0188ac	d0 d3		bne $018881			bne 	CCTrue
.0188ae	80 cd		bra $01887d			bra 	CCFalse
.0188b0					Binary_GreaterEqual:
.0188b0	20 c2 88	jsr $0188c2			jsr 	CompareValues
.0188b3	09 00		ora #$00			ora 	#0
.0188b5	10 ca		bpl $018881			bpl 	CCTrue
.0188b7	80 c4		bra $01887d			bra 	CCFalse
.0188b9					Binary_Greater:
.0188b9	20 c2 88	jsr $0188c2			jsr 	CompareValues
.0188bc	c9 01		cmp #$01			cmp 	#1
.0188be	f0 c1		beq $018881			beq 	CCTrue
.0188c0	80 bb		bra $01887d			bra 	CCFalse
.0188c2					CompareValues:
.0188c2	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and the types together
.0188c5	3d 13 03	and $0313,x			and 	XS2_Type,x
.0188c8	c9 02		cmp #$02			cmp 	#2
.0188ca	f0 13		beq $0188df			beq 	_CVString
.0188cc	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.0188cf	3d 13 03	and $0313,x			and 	XS2_Type,x
.0188d2	4a		lsr a				lsr 	a 							; shift bit 0 into C
.0188d3	90 03		bcc $0188d8			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.0188d5	4c 25 89	jmp $018925			jmp 	CompareInteger32 							; so execute code at \1
.0188d8					_BCFloat:
.0188d8	20 f3 89	jsr $0189f3			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.0188db	4c fb 95	jmp $0195fb			jmp 	FPCompare 							; and execute code at \2
.0188de	60		rts				rts
.0188df					_CVString:
.0188df	da		phx				phx 								; save XY
.0188e0	5a		phy				phy
.0188e1	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.0188e4	85 1a		sta $1a				sta		zLTemp1+0
.0188e6	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0188e9	85 1b		sta $1b				sta 	zLTemp1+1
.0188eb	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x
.0188ee	85 1c		sta $1c				sta 	zLTemp1+2
.0188f0	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.0188f3	85 1d		sta $1d				sta 	zLTemp1+3
.0188f5	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.0188f7	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.0188f9	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.0188fb	90 02		bcc $0188ff			bcc 	_CVCommon
.0188fd	b1 1c		lda ($1c),y			lda 	(zLTemp1+2),y
.0188ff					_CVCommon:
.0188ff	aa		tax				tax 								; put shorter string length in zero.
.018900	f0 0c		beq $01890e			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.018902					_CVCompare:
.018902	c8		iny				iny 								; next character
.018903	b1 1a		lda ($1a),y			lda 	(zLTemp1),y 				; compare characters
.018905	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.018907	90 13		bcc $01891c			bcc 	_CVReturnLess 				; <
.018909	d0 15		bne $018920			bne 	_CVReturnGreater 			; >
.01890b	ca		dex				dex 								; until common length matched.
.01890c	d0 f4		bne $018902			bne 	_CVCompare
.01890e					_CVMatch:
.01890e	a0 00		ldy #$00			ldy 	#0
.018910	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.018912	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.018914	90 06		bcc $01891c			bcc 	_CVReturnLess 				; <
.018916	d0 08		bne $018920			bne 	_CVReturnGreater 			; >
.018918	a9 00		lda #$00			lda 	#0
.01891a	80 06		bra $018922			bra 	_CVExit 					; same common, same length, same string
.01891c					_CVReturnLess:
.01891c	a9 ff		lda #$ff			lda 	#$FF
.01891e	80 02		bra $018922			bra 	_CVExit
.018920					_CVReturnGreater:
.018920	a9 01		lda #$01			lda 	#$01
.018922					_CVExit:
.018922	7a		ply				ply
.018923	fa		plx				plx
.018924	60		rts				rts
.018925					CompareInteger32:
.018925	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.018928	49 80		eor #$80			eor 	#$80
.01892a	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.01892d	bd 11 03	lda $0311,x			lda 	XS2_Mantissa+3,x
.018930	49 80		eor #$80			eor 	#$80
.018932	9d 11 03	sta $0311,x			sta 	XS2_Mantissa+3,x
.018935	20 cd 89	jsr $0189cd			jsr 	SubInteger32 				; subtraction
.018938	90 11		bcc $01894b			bcc 	_CI32Less 					; cc return -1
.01893a	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; check if zero
.01893d	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.018940	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.018943	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.018946	f0 02		beq $01894a			beq 	_CI32Exit
.018948	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.01894a					_CI32Exit:
.01894a	60		rts				rts
.01894b					_CI32Less:
.01894b	a9 ff		lda #$ff			lda 	#$FF
.01894d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.01894e					BinaryOp_Add:
.01894e	bd 0d 03	lda $030d,x			lda 	XS_Type,x  					; and types together
.018951	3d 13 03	and $0313,x			and 	XS2_Type,x
.018954	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.018956	d0 13		bne $01896b			bne 	_BOAString
.018958	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.01895b	3d 13 03	and $0313,x			and 	XS2_Type,x
.01895e	4a		lsr a				lsr 	a 							; shift bit 0 into C
.01895f	90 03		bcc $018964			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018961	4c a7 89	jmp $0189a7			jmp 	AddInteger32 							; so execute code at \1
.018964					_BCFloat:
.018964	20 f3 89	jsr $0189f3			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018967	4c 6f 93	jmp $01936f			jmp 	FPAdd 							; and execute code at \2
.01896a	60		rts				rts
.01896b					_BOAString:
.01896b	4c 0e 8a	jmp $018a0e			jmp 	ConcatenateString 			; concatenate two strings.
.01896e					BinaryOp_Subtract:
.01896e	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018971	3d 13 03	and $0313,x			and 	XS2_Type,x
.018974	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018975	90 03		bcc $01897a			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018977	4c cd 89	jmp $0189cd			jmp 	SubInteger32 							; so execute code at \1
.01897a					_BCFloat:
.01897a	20 f3 89	jsr $0189f3			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.01897d	4c 65 93	jmp $019365			jmp 	FPSubtract 							; and execute code at \2
.018980	60		rts				rts
.018981					BinaryOp_Multiply:
.018981	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018984	3d 13 03	and $0313,x			and 	XS2_Type,x
.018987	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018988	90 03		bcc $01898d			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.01898a	4c f1 90	jmp $0190f1			jmp 	MulInteger32 							; so execute code at \1
.01898d					_BCFloat:
.01898d	20 f3 89	jsr $0189f3			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018990	4c db 94	jmp $0194db			jmp 	FPMultiply 							; and execute code at \2
.018993	60		rts				rts
.018994					BinaryOp_Divide:
.018994	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018997	3d 13 03	and $0313,x			and 	XS2_Type,x
.01899a	4a		lsr a				lsr 	a 							; shift bit 0 into C
.01899b	90 03		bcc $0189a0			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.01899d	4c 48 91	jmp $019148			jmp 	DivInteger32 							; so execute code at \1
.0189a0					_BCFloat:
.0189a0	20 f3 89	jsr $0189f3			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.0189a3	4c 53 94	jmp $019453			jmp 	FPDivide 							; and execute code at \2
.0189a6	60		rts				rts
.0189a7					AddInteger32:
.0189a7	18		clc				clc
.0189a8	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.0189ab	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.0189ae	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0189b1	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0189b4	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.0189b7	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0189ba	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.0189bd	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.0189c0	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0189c3	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.0189c6	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.0189c9	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0189cc	60		rts				rts
.0189cd					SubInteger32:
.0189cd	38		sec				sec
.0189ce	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.0189d1	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.0189d4	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0189d7	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0189da	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.0189dd	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0189e0	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.0189e3	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.0189e6	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0189e9	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.0189ec	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.0189ef	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0189f2	60		rts				rts
.0189f3					BinaryMakeBothFloat:
.0189f3	da		phx				phx 								; save X
.0189f4	e8		inx				inx
.0189f5	e8		inx				inx
.0189f6	e8		inx				inx
.0189f7	e8		inx				inx
.0189f8	e8		inx				inx
.0189f9	e8		inx				inx
.0189fa	20 fe 89	jsr $0189fe			jsr 	BinaryMakeFloat 			; convert to float.
.0189fd	fa		plx				plx 								; restore X and fall through.
.0189fe					BinaryMakeFloat:
.0189fe	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type byte.
.018a01	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.018a02	b0 04		bcs $018a08			bcs 	_BMFConvert
.018a04	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.018a05	b0 04		bcs $018a0b			bcs 	_BMFError
.018a07	60		rts				rts
.018a08					_BMFConvert:
.018a08	4c 8d 96	jmp $01968d			jmp 	FPUToFloat 					; convert to float
.018a0b					_BMFError:
.018a0b	4c 07 82	jmp $018207			jmp 	TypeError
.018a0e					ConcatenateString:
.018a0e	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.018a11	85 1a		sta $1a				sta		zLTemp1+0
.018a13	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018a16	85 1b		sta $1b				sta 	zLTemp1+1
.018a18	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x
.018a1b	85 1c		sta $1c				sta 	zLTemp1+2
.018a1d	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.018a20	85 1d		sta $1d				sta 	zLTemp1+3
.018a22	5a		phy				phy
.018a23	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.018a25	b1 1a		lda ($1a),y			lda 	(zlTemp1),y
.018a27	71 1c		adc ($1c),y			adc 	(zlTemp1+2),y
.018a29	7a		ply				ply
.018a2a	b0 37		bcs $018a63			bcs 	_CSError					; check in range.
.018a2c	c9 fe		cmp #$fe			cmp 	#maxString+1
.018a2e	b0 33		bcs $018a63			bcs 	_CSError
.018a30	20 84 8e	jsr $018e84			jsr 	AllocateTempString 			; store the result
.018a33	20 4e 8a	jsr $018a4e			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.018a36	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.018a39	85 1a		sta $1a				sta 	zLTemp1
.018a3b	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.018a3e	85 1b		sta $1b				sta 	zLTemp1+1
.018a40	20 4e 8a	jsr $018a4e			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.018a43	a5 20		lda $20				lda 	zTempStr 					; point current to new string
.018a45	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018a48	a5 21		lda $21				lda 	zTempStr+1
.018a4a	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018a4d	60		rts				rts
.018a4e					_CSCopyString:
.018a4e	da		phx				phx
.018a4f	5a		phy				phy
.018a50	a0 00		ldy #$00			ldy 	#0 							; get length
.018a52	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.018a54	f0 0a		beq $018a60			beq 	_CSCSExit 					; if zero, exit
.018a56	aa		tax				tax 								; put in X
.018a57					_CSCSLoop:
.018a57	c8		iny				iny 								; get next char
.018a58	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.018a5a	20 af 8e	jsr $018eaf			jsr		WriteTempString 			; copy out
.018a5d	ca		dex				dex 								; do whole string
.018a5e	d0 f7		bne $018a57			bne 	_CSCSLoop
.018a60					_CSCSExit:
.018a60	7a		ply				ply
.018a61	fa		plx				plx
.018a62	60		rts				rts
.018a63					_CSError:
.018a63	20 26 82	jsr $018226			jsr ERR_Handler
>018a66	53 74 72 69 6e 67 20 74			.text "String too long",0
>018a6e	6f 6f 20 6c 6f 6e 67 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.018a76					Unary_Sgn:
.018a76	20 b3 87	jsr $0187b3			jsr 	EvaluateNumberX 			; get value
.018a79	20 42 8e	jsr $018e42			jsr 	CheckNextRParen 			; check right bracket.
.018a7c	20 a0 8a	jsr $018aa0			jsr 	GetSignCurrent 				; get sign.
.018a7f	09 00		ora #$00			ora 	#0
.018a81	10 09		bpl $018a8c			bpl		UnarySetAInteger			; if 0,1 return that.
.018a83	80 00		bra $018a85			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.018a85					UnarySetAMinus1:
.018a85	a9 ff		lda #$ff			lda 	#$FF
.018a87	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.018a8a	80 05		bra $018a91			bra 	UnarySetAFill
.018a8c					UnarySetAInteger:
.018a8c	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.018a8f	a9 00		lda #$00			lda 	#0
.018a91					UnarySetAFill:
.018a91	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018a94	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018a97	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018a9a	a9 01		lda #$01			lda 	#1
.018a9c	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018a9f	60		rts				rts
.018aa0					GetSignCurrent:
.018aa0	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; identify type.
.018aa3	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.018aa4	90 19		bcc $018abf			bcc 	_GSCFloat
.018aa6	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.018aa9	30 11		bmi $018abc			bmi 	_GSCMinus1
.018aab	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x
.018aae	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.018ab1	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.018ab4	d0 03		bne $018ab9			bne 	_GSCPlus1
.018ab6					_GSCZero:
.018ab6	a9 00		lda #$00			lda 	#0
.018ab8	60		rts				rts
.018ab9					_GSCPlus1:
.018ab9	a9 01		lda #$01			lda 	#$01
.018abb	60		rts				rts
.018abc					_GSCMinus1:
.018abc	a9 ff		lda #$ff			lda 	#$FF
.018abe	60		rts				rts
.018abf					_GSCFloat:
.018abf	3c 0d 03	bit $030d,x			bit 	XS_Type,x
.018ac2	70 f2		bvs $018ab6			bvs 	_GSCZero
.018ac4	30 f6		bmi $018abc			bmi 	_GSCMinus1
.018ac6	80 f1		bra $018ab9			bra 	_GSCPlus1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.018ac8					Unary_Abs:
.018ac8	20 b3 87	jsr $0187b3			jsr 	EvaluateNumberX 			; get value
.018acb	20 42 8e	jsr $018e42			jsr 	CheckNextRParen 			; check right bracket.
.018ace	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.018ad1	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.018ad3	f0 08		beq $018add			beq 	_UAMinusFloat
.018ad5	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; check MSB
.018ad8	10 0b		bpl $018ae5			bpl 	_UAExit
.018ada	4c de 91	jmp $0191de			jmp 	IntegerNegateAlways 		; negation
.018add					_UAMinusFloat:
.018add	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; clear the sign bit.
.018ae0	29 7f		and #$7f			and		#$7F
.018ae2	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018ae5					_UAExit:
.018ae5	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.018ae6					Unary_Peek:
.018ae6	a9 01		lda #$01			lda 	#1
.018ae8	80 06		bra $018af0			bra 	UPMain
.018aea					Unary_Deek:
.018aea	a9 02		lda #$02			lda 	#2
.018aec	80 02		bra $018af0			bra 	UPMain
.018aee					Unary_Leek:
.018aee	a9 04		lda #$04			lda 	#4
.018af0					UPMain:
.018af0	48		pha				pha 								; set bytes to copy.
.018af1	20 c2 87	jsr $0187c2			jsr 	EvaluateIntegerX 			; numeric parameter
.018af4	20 42 8e	jsr $018e42			jsr 	CheckNextRParen 			; right bracket.
.018af7	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.018afa	85 1a		sta $1a				sta 	zLTemp1
.018afc	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018aff	85 1b		sta $1b				sta 	zLTemp1+1
.018b01	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018b04	85 1c		sta $1c				sta 	zLTemp1+2
.018b06	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.018b09	85 1d		sta $1d				sta 	zLTemp1+3
.018b0b	a9 00		lda #$00			lda 	#0 							; clear target area
.018b0d	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018b10	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018b13	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018b16	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018b19	68		pla				pla 								; restore bytes to copy
.018b1a	da		phx				phx 								; save XY
.018b1b	5a		phy				phy
.018b1c	20 19 8e	jsr $018e19			jsr 	MemRead 					; read the bytes in
.018b1f	7a		ply				ply 								; restore and exit
.018b20	fa		plx				plx
.018b21	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.018b22					Unary_Mod:
.018b22	20 4e 8b	jsr $018b4e			jsr 	_UMParameter 				; first parameter
.018b25	20 4a 8e	jsr $018e4a			jsr 	CheckNextComma
.018b28	da		phx				phx 								; second parameter
.018b29	e8		inx				inx
.018b2a	e8		inx				inx
.018b2b	e8		inx				inx
.018b2c	e8		inx				inx
.018b2d	e8		inx				inx
.018b2e	e8		inx				inx
.018b2f	20 4e 8b	jsr $018b4e			jsr 	_UMParameter
.018b32	fa		plx				plx
.018b33	20 42 8e	jsr $018e42			jsr 	CheckNextRParen
.018b36	20 48 91	jsr $019148			jsr 	DivInteger32 				; divide
.018b39	a5 1a		lda $1a				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.018b3b	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018b3e	a5 1b		lda $1b				lda 	zLTemp1+1
.018b40	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018b43	a5 1c		lda $1c				lda 	zLTemp1+2
.018b45	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018b48	a5 1d		lda $1d				lda 	zLTemp1+3
.018b4a	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018b4d	60		rts				rts
.018b4e					_UMParameter:
.018b4e	20 c2 87	jsr $0187c2			jsr 	EvaluateIntegerX 			; get value
.018b51	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; absolute value
.018b54	10 03		bpl $018b59			bpl 	_UMNotSigned
.018b56	20 de 91	jsr $0191de			jsr 	IntegerNegateAlways
.018b59					_UMNotSigned:
.018b59	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.018b5a					Unary_Usr:
.018b5a	20 b3 87	jsr $0187b3			jsr 	EvaluateNumberX 			; numeric parameter
.018b5d	20 42 8e	jsr $018e42			jsr 	CheckNextRParen 			; right bracket.
.018b60	da		phx				phx 								; save XY
.018b61	5a		phy				phy
.018b62	ea		nop				nop
.018b63	22 00 03 00	jsl $000300			jsl 	UserVector
.018b67	7a		ply				ply 								; and exit
.018b68	fa		plx				plx
.018b69	60		rts				rts
.018b6a					USRDefault:
.018b6a	20 26 82	jsr $018226			jsr ERR_Handler
>018b6d	4e 6f 20 55 53 52 20 76			.text "No USR vector.",0
>018b75	65 63 74 6f 72 2e 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.018b7c					Unary_Val:
.018b7c	20 cb 87	jsr $0187cb			jsr 	EvaluateStringX 			; get string
.018b7f	20 42 8e	jsr $018e42			jsr 	CheckNextRParen 			; check right bracket.
.018b82	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.018b85	85 1e		sta $1e				sta 	zGenPtr
.018b87	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018b8a	85 1f		sta $1f				sta 	zGenPtr+1
.018b8c	5a		phy				phy
.018b8d	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.018b8f	b1 1e		lda ($1e),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.018b91	f0 57		beq $018bea			beq 	_UVBadNumber
.018b93	48		pha				pha 								; save length.
.018b94	1a		inc a				inc 	a 							; one for the length, one for the terminator
.018b95	1a		inc a				inc 	a
.018b96	20 84 8e	jsr $018e84			jsr 	AllocateTempString
.018b99	c8		iny				iny 								; move to the next.
.018b9a	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get character
.018b9c	49 2d		eor #$2d			eor 	#"-"						; zero if minus sign
.018b9e	8d 90 04	sta $0490			sta 	ValSign
.018ba1	d0 04		bne $018ba7			bne 	_UVNotMinus
.018ba3	c8		iny				iny 								; skip over it.
.018ba4	68		pla				pla 								; decrement character count.
.018ba5	3a		dec a				dec 	a
.018ba6	48		pha				pha
.018ba7					_UVNotMinus:
.018ba7	68		pla				pla 								; this is the count.
.018ba8	48		pha		_UVCopy:pha									; copy into new temp string which is ASCIIZ
.018ba9	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018bab	c8		iny				iny
.018bac	20 af 8e	jsr $018eaf			jsr 	WriteTempString
.018baf	68		pla				pla
.018bb0	3a		dec a				dec 	a
.018bb1	d0 f5		bne $018ba8			bne 	_UVCopy
.018bb3	20 af 8e	jsr $018eaf			jsr 	WriteTempString 			; make it ASCIIZ
.018bb6	18		clc				clc
.018bb7	a5 20		lda $20				lda 	zTempStr 					; tempstring +1 => genptr
.018bb9	69 01		adc #$01			adc 	#1
.018bbb	85 1e		sta $1e				sta 	zGenPtr
.018bbd	a5 21		lda $21				lda 	zTempStr+1
.018bbf	69 00		adc #$00			adc 	#0
.018bc1	85 1f		sta $1f				sta 	zGenPtr+1
.018bc3	18		clc				clc
.018bc4	20 ba 92	jsr $0192ba			jsr 	IntFromString 				; first bit.
.018bc7	b0 21		bcs $018bea			bcs 	_UVBadNumber
.018bc9	20 de 98	jsr $0198de			jsr 	FPFromString				; try for a float part.
.018bcc	ad 90 04	lda $0490			lda 	ValSign 					; was it negative
.018bcf	d0 13		bne $018be4			bne 	_UVNotNegative
.018bd1	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; check if integer
.018bd4	4a		lsr a				lsr 	a
.018bd5	b0 0a		bcs $018be1			bcs 	_UVInteger
.018bd7	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; set sign bit
.018bda	09 80		ora #$80			ora 	#$80
.018bdc	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018bdf	80 03		bra $018be4			bra 	_UVNotNegative
.018be1					_UVInteger:
.018be1	20 de 91	jsr $0191de			jsr 	IntegerNegateAlways 		; sign it.
.018be4					_UVNotNegative:
.018be4	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; used everything
.018be6	d0 02		bne $018bea			bne 	_UVBadNumber
.018be8	7a		ply				ply
.018be9	60		rts				rts
.018bea					_UVBadNumber:
.018bea	4c 15 82	jmp $018215			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.018bed					Unary_Str:
.018bed	20 b3 87	jsr $0187b3			jsr 	EvaluateNumberX 			; numeric parameter
.018bf0	20 42 8e	jsr $018e42			jsr 	CheckNextRParen 			; right bracket.
.018bf3	a9 00		lda #$00			lda 	#0 							; reset buffer index
.018bf5	8d 04 04	sta $0404			sta 	NumBufX
.018bf8	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.018bfb	4a		lsr a				lsr 	a
.018bfc	b0 05		bcs $018c03			bcs 	_USInt 						; if msb set do as integer
.018bfe	20 17 98	jsr $019817			jsr 	FPToString 					; call fp to str otherwise
.018c01	80 03		bra $018c06			bra 	_USDuplicate
.018c03	20 03 92	jsr $019203	_USInt:	jsr 	IntToString
.018c06					_USDuplicate:
.018c06	ad 04 04	lda $0404			lda 	NumBufX 					; chars in buffer
.018c09	1a		inc a				inc 	a 							; one more for length
.018c0a	20 84 8e	jsr $018e84			jsr 	AllocateTempString 			; allocate space for it.
.018c0d	5a		phy				phy 								; save Y
.018c0e	a0 00		ldy #$00			ldy 	#0 							; start copying
.018c10	b9 05 04	lda $0405,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.018c13	20 af 8e	jsr $018eaf			jsr 	WriteTempString
.018c16	c8		iny				iny
.018c17	cc 04 04	cpy $0404			cpy 	NumBufX 					; done the lot
.018c1a	d0 f4		bne $018c10			bne 	_USCopy
.018c1c	7a		ply				ply 								; restore Y
.018c1d	4c 09 8e	jmp $018e09			jmp 	UnaryReturnTempStr 			; return new temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.018c20					Unary_Asc:
.018c20	20 cb 87	jsr $0187cb			jsr 	EvaluateStringX 			; string parameter
.018c23	20 42 8e	jsr $018e42			jsr 	CheckNextRParen 			; right bracket.
.018c26	5a		phy				phy 								; get the string length
.018c27	a0 00		ldy #$00			ldy 	#0
.018c29	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018c2b	f0 07		beq $018c34			beq 	_UAIllegal 					; must be at least one character
.018c2d	c8		iny				iny
.018c2e	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; read it.
.018c30	7a		ply				ply
.018c31	4c 8c 8a	jmp $018a8c			jmp 	UnarySetAInteger
.018c34					_UAIllegal:
.018c34	4c 15 82	jmp $018215			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.018c37					Unary_Len:
.018c37	20 cb 87	jsr $0187cb			jsr 	EvaluateStringX 			; string parameter
.018c3a	20 42 8e	jsr $018e42			jsr 	CheckNextRParen 			; right bracket.
.018c3d	5a		phy				phy 								; get the string length
.018c3e	a0 00		ldy #$00			ldy 	#0
.018c40	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018c42	7a		ply				ply
.018c43	4c 8c 8a	jmp $018a8c			jmp 	UnarySetAInteger

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.018c46					Unary_Mid:
.018c46	20 cb 87	jsr $0187cb			jsr 	EvaluateStringX 				; get string.
.018c49	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.018c4c	48		pha				pha
.018c4d	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018c50	48		pha				pha
.018c51	20 4a 8e	jsr $018e4a			jsr 	CheckNextComma 					; skip comma
.018c54	20 e1 8c	jsr $018ce1			jsr 	SLIByteParameter 				; get a byte parameter (start)
.018c57	48		pha				pha 									; and push it.
.018c58	20 4a 8e	jsr $018e4a			jsr 	CheckNextComma 					; skip comma
.018c5b	20 e1 8c	jsr $018ce1			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.018c5e	48		pha				pha 									; and push it.
.018c5f	80 45		bra $018ca6			bra 	SLIProcess
.018c61					Unary_Left:
.018c61	20 cb 87	jsr $0187cb			jsr 	EvaluateStringX 				; get string.
.018c64	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.018c67	48		pha				pha
.018c68	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018c6b	48		pha				pha
.018c6c	a9 01		lda #$01			lda 	#1 								; push start position (1)
.018c6e	48		pha				pha
.018c6f	20 4a 8e	jsr $018e4a			jsr 	CheckNextComma 					; skip comma
.018c72	20 e1 8c	jsr $018ce1			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.018c75	48		pha				pha 									; and push it.
.018c76	80 2e		bra $018ca6			bra 	SLIProcess
.018c78					Unary_Right:
.018c78	20 cb 87	jsr $0187cb			jsr 	EvaluateStringX 				; get string.
.018c7b	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.018c7e	48		pha				pha
.018c7f	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018c82	48		pha				pha
.018c83	da		phx				phx 									; get the string length and push on stack.
.018c84	a2 00		ldx #$00			ldx 	#0
.018c86	a1 1e		lda ($1e,x)			lda		(zGenPtr,x)
.018c88	fa		plx				plx
.018c89	48		pha				pha
.018c8a	20 4a 8e	jsr $018e4a			jsr 	CheckNextComma 					; skip comma
.018c8d	20 e1 8c	jsr $018ce1			jsr 	SLIByteParameter 				; get a byte parameter.
.018c90	8d 8e 04	sta $048e			sta 	SignCount 						; save in temporary.
.018c93	68		pla				pla 									; restore string length.
.018c94	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.018c95	38		sec				sec
.018c96	ed 8e 04	sbc $048e			sbc 	SignCount 						; subtract characters needed, gives start position.
.018c99	f0 02		beq $018c9d			beq 	_URStart 						; if <= 0 start from 1.
.018c9b	10 02		bpl $018c9f			bpl 	_UROkay
.018c9d					_URStart:
.018c9d	a9 01		lda #$01			lda 	#1
.018c9f					_UROkay:
.018c9f	48		pha				pha 									; push start
.018ca0	ad 8e 04	lda $048e			lda 	SignCount 						; push count of characters
.018ca3	48		pha				pha
.018ca4	80 00		bra $018ca6			bra 	SLIProcess
.018ca6					SLIProcess:
.018ca6	20 42 8e	jsr $018e42			jsr 	CheckNextRParen 				; closing right bracket.
.018ca9	68		pla				pla
.018caa	8d 92 04	sta $0492			sta 	SliceCount 						; count in signcount
.018cad	1a		inc a				inc 	a 								; allocate +1 for it.
.018cae	20 84 8e	jsr $018e84			jsr 	AllocateTempString
.018cb1	68		pla				pla 									; pop start number off stack.
.018cb2	f0 3f		beq $018cf3			beq 	SLIError 						; exit if start = 0
.018cb4	8d 91 04	sta $0491			sta 	SliceStart
.018cb7	68		pla				pla  									; pop string address.
.018cb8	85 1f		sta $1f				sta 	zGenPtr+1
.018cba	68		pla				pla
.018cbb	85 1e		sta $1e				sta 	zGenPtr
.018cbd	da		phx				phx
.018cbe	5a		phy				phy
.018cbf	a2 00		ldx #$00			ldx 	#0 								; point to string length.
.018cc1	ac 91 04	ldy $0491			ldy 	SliceStart 						; start of the string (+1 for count)
.018cc4					_SLICopy:
.018cc4	ad 92 04	lda $0492			lda 	SliceCount 						; done count characters
.018cc7	f0 12		beq $018cdb			beq 	_SLIExit
.018cc9	ce 92 04	dec $0492			dec 	SliceCount
.018ccc	98		tya				tya 									; index of character
.018ccd	c1 1e		cmp ($1e,x)			cmp 	(zGenPtr,x)						; compare against length
.018ccf	f0 02		beq $018cd3			beq 	_SLIOk 							; if equal, okay.
.018cd1	b0 08		bcs $018cdb			bcs 	_SLIExit 						; if past end, then exit.
.018cd3	b1 1e		lda ($1e),y	_SLIOk:	lda 	(zGenPtr),y 					; copy one character
.018cd5	c8		iny				iny
.018cd6	20 af 8e	jsr $018eaf			jsr 	WriteTempString
.018cd9	80 e9		bra $018cc4			bra 	_SLICopy 						; go round till copied characters
.018cdb					_SLIExit:
.018cdb	7a		ply				ply 									; restore YX
.018cdc	fa		plx				plx
.018cdd	4c 09 8e	jmp $018e09			jmp 	UnaryReturnTempStr 				; return new temporary string.
.018ce0	ea		nop				nop
.018ce1					SLIByteParameter:
.018ce1	20 c2 87	jsr $0187c2			jsr 	EvaluateIntegerX 				; get integer
.018ce4	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.018ce7	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.018cea	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.018ced	d0 04		bne $018cf3			bne 	SLIError
.018cef	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018cf2	60		rts				rts
.018cf3					SLIError:
.018cf3	4c 15 82	jmp $018215			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.018cf6					Unary_Hex:
.018cf6	20 c2 87	jsr $0187c2			jsr 	EvaluateIntegerX 			; numeric parameter
.018cf9	20 42 8e	jsr $018e42			jsr 	CheckNextRParen 			; right bracket.
.018cfc	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.018cfe	20 84 8e	jsr $018e84			jsr 	AllocateTempString			; allocate string space
.018d01	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.018d04	20 2b 8d	jsr $018d2b			jsr 	_UHConvert
.018d07	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018d0a	20 2b 8d	jsr $018d2b			jsr 	_UHConvert
.018d0d	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018d10	20 2b 8d	jsr $018d2b			jsr 	_UHConvert
.018d13	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018d16	20 2b 8d	jsr $018d2b			jsr 	_UHConvert
.018d19	5a		phy				phy 								; get length of new string
.018d1a	a0 00		ldy #$00			ldy 	#0
.018d1c	b1 20		lda ($20),y			lda 	(zTempStr),y
.018d1e	7a		ply				ply
.018d1f	c9 00		cmp #$00			cmp 	#0
.018d21	d0 05		bne $018d28			bne 	_UHExit 					; if it was non zero okay
.018d23	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.018d25	20 af 8e	jsr $018eaf			jsr 	WriteTempString
.018d28					_UHExit:
.018d28	4c 09 8e	jmp $018e09			jmp 	UnaryReturnTempStr 			; return new temporary string.
.018d2b					_UHConvert:
.018d2b	48		pha				pha
.018d2c	4a		lsr a				lsr 	a 							; do MSB
.018d2d	4a		lsr a				lsr 	a
.018d2e	4a		lsr a				lsr 	a
.018d2f	4a		lsr a				lsr 	a
.018d30	20 34 8d	jsr $018d34			jsr 	_UHNibble
.018d33	68		pla				pla 								; do LSB
.018d34					_UHNibble:
.018d34	29 0f		and #$0f			and 	#15 						; get nibble
.018d36	d0 0c		bne $018d44			bne 	_UHNonZero
.018d38	5a		phy				phy									; get the length
.018d39	a0 00		ldy #$00			ldy 	#0
.018d3b	b1 20		lda ($20),y			lda 	(zTempStr),y
.018d3d	7a		ply				ply
.018d3e	c9 00		cmp #$00			cmp 	#0 							; suppress leading zeros.
.018d40	f0 0d		beq $018d4f			beq 	_UHExit2
.018d42	a9 00		lda #$00			lda 	#0
.018d44					_UHNonZero:
.018d44	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.018d46	90 02		bcc $018d4a			bcc 	_UHDigit
.018d48	69 06		adc #$06			adc 	#7-1
.018d4a					_UHDigit:
.018d4a	69 30		adc #$30			adc 	#48
.018d4c	20 af 8e	jsr $018eaf			jsr 	WriteTempString				; output.
.018d4f					_UHExit2:
.018d4f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.018d50					Unary_Dec:
.018d50	20 cb 87	jsr $0187cb			jsr 	EvaluateStringX 			; string parameter
.018d53	20 42 8e	jsr $018e42			jsr 	CheckNextRParen 			; right bracket.
.018d56	5a		phy				phy
.018d57	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.018d59	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018d5b	f0 4c		beq $018da9			beq 	_UDFail 					; must fail if zero.
.018d5d	8d 8e 04	sta $048e			sta 	SignCount 					; use SignCount as a counter
.018d60	a9 00		lda #$00			lda 	#0 							; set result to zero integer.
.018d62	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018d65	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018d68	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018d6b	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018d6e	a9 01		lda #$01			lda 	#1
.018d70	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018d73					_UDConvertLoop:
.018d73	5a		phy				phy 								; shift mantissa left 4
.018d74	a0 04		ldy #$04			ldy 	#4
.018d76					_UDShift:
.018d76	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x
.018d79	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.018d7c	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.018d7f	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.018d82	88		dey				dey
.018d83	d0 f1		bne $018d76			bne 	_UDShift
.018d85	7a		ply				ply
.018d86	c8		iny				iny 								; next character
.018d87	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; fetch it.
.018d89	20 ac 8d	jsr $018dac			jsr 	ConvertUpper 				; convert to U/C
.018d8c	c9 30		cmp #$30			cmp 	#"0"
.018d8e	90 19		bcc $018da9			bcc 	_UDFail
.018d90	c9 3a		cmp #$3a			cmp 	#"9"+1
.018d92	90 06		bcc $018d9a			bcc 	_UDOkay
.018d94	e9 37		sbc #$37			sbc 	#7+"0" 						; alpha fudge
.018d96	c9 10		cmp #$10			cmp 	#16
.018d98	b0 0f		bcs $018da9			bcs 	_UDFail
.018d9a					_UDOkay:
.018d9a	29 0f		and #$0f			and 	#15 						; nibble only
.018d9c	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x
.018d9f	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018da2	ce 8e 04	dec $048e			dec 	SignCount 					; do it for each character
.018da5	d0 cc		bne $018d73			bne 	_UDConvertLoop
.018da7	7a		ply				ply
.018da8	60		rts				rts
.018da9					_UDFail:
.018da9	4c 15 82	jmp $018215			jmp 	BadParamError
.018dac					ConvertUpper:
.018dac	c9 61		cmp #$61			cmp 	#"a"
.018dae	90 07		bcc $018db7			bcc 	_CUExit
.018db0	c9 7b		cmp #$7b			cmp 	#"z"+1
.018db2	b0 03		bcs $018db7			bcs 	_CUExit
.018db4	38		sec				sec
.018db5	e9 20		sbc #$20			sbc 	#32
.018db7	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.018db8					Unary_Chr:
.018db8	20 c2 87	jsr $0187c2			jsr 	EvaluateIntegerX			; numeric parameter
.018dbb	20 42 8e	jsr $018e42			jsr 	CheckNextRParen 			; right bracket.
.018dbe	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.018dc1	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.018dc4	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.018dc7	d0 0e		bne $018dd7			bne 	_UCChar
.018dc9	a9 01		lda #$01			lda 	#1 							; one character string
.018dcb	20 84 8e	jsr $018e84			jsr 	AllocateTempString
.018dce	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.018dd1	20 af 8e	jsr $018eaf			jsr 	WriteTempString
.018dd4	4c 09 8e	jmp $018e09			jmp 	UnaryReturnTempStr
.018dd7					_UCChar:
.018dd7	4c 15 82	jmp $018215			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.018dda					Unary_Spc:
.018dda	20 c2 87	jsr $0187c2			jsr 	EvaluateIntegerX 			; numeric parameter
.018ddd	20 42 8e	jsr $018e42			jsr 	CheckNextRParen 			; right bracket.
.018de0	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.018de3	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.018de6	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.018de9	d0 1b		bne $018e06			bne 	_USSize
.018deb	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018dee	c9 fe		cmp #$fe			cmp 	#maxString+1
.018df0	b0 14		bcs $018e06			bcs 	_USSize
.018df2	48		pha				pha 								; save length
.018df3	1a		inc a				inc 	a 							; allocate one more.
.018df4	20 84 8e	jsr $018e84			jsr 	AllocateTempString
.018df7	68		pla				pla 								; get length
.018df8	f0 0f		beq $018e09			beq 	UnaryReturnTempStr 			; return the current temp string
.018dfa					_USLoop:
.018dfa	48		pha				pha
.018dfb	a9 20		lda #$20			lda 	#" "
.018dfd	20 af 8e	jsr $018eaf			jsr 	WriteTempString
.018e00	68		pla				pla
.018e01	3a		dec a				dec 	a
.018e02	d0 f6		bne $018dfa			bne 	_USLoop
.018e04	80 03		bra $018e09			bra 	UnaryReturnTempStr
.018e06					_USSize:
.018e06	4c 15 82	jmp $018215			jmp 	BadParamError
.018e09					UnaryReturnTempStr:
.018e09	a5 20		lda $20				lda 	zTempStr 					; copy temp string addr -> mantissa
.018e0b	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018e0e	a5 21		lda $21				lda 	zTempStr+1
.018e10	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018e13	a9 02		lda #$02			lda 	#2 							; set type to string
.018e15	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018e18	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/65816.asm

.018e19					MemRead:
.018e19	8d 8e 04	sta $048e			sta 	SignCount 					; save count
.018e1c	a0 00		ldy #$00			ldy 	#0 							; start from here
.018e1e	b7 1a		lda [$1a],y	_MLoop1:lda 	[zlTemp1],y 				; read the long address
.018e20	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; copy into mantissa
.018e23	c8		iny				iny 								; next to copy
.018e24	e8		inx				inx
.018e25	cc 8e 04	cpy $048e			cpy 	SignCount 					; do required # of bytes.
.018e28	d0 f4		bne $018e1e			bne 	_MLoop1
.018e2a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.018e2b					CheckNextToken:
.018e2b	d7 16		cmp [$16],y			cmp 	[zCodePtr],y
.018e2d	d0 02		bne $018e31			bne 	CTFail 						; no, then fail
.018e2f	c8		iny				iny
.018e30	60		rts				rts
.018e31					CTFail:
.018e31	20 26 82	jsr $018226			jsr ERR_Handler
>018e34	4d 69 73 73 69 6e 67 20			.text "Missing token",0
>018e3c	74 6f 6b 65 6e 00
.018e42					CheckNextRParen:
.018e42	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e44	c9 bc		cmp #$bc			cmp 	#token_rparen
.018e46	d0 e9		bne $018e31			bne 	CTFail
.018e48	c8		iny				iny
.018e49	60		rts				rts
.018e4a					CheckNextComma:
.018e4a	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e4c	c9 bd		cmp #$bd			cmp 	#token_comma
.018e4e	d0 e1		bne $018e31			bne 	CTFail
.018e50	c8		iny				iny
.018e51	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/concrete.asm

.018e52					StringConcrete:
.018e52	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; save source to zTemp1
.018e55	85 10		sta $10				sta 	zTemp1
.018e57	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018e5a	85 11		sta $11				sta 	zTemp1+1
.018e5c	a0 00		ldy #$00			ldy 	#0 							; subtract the length+1 (clc) of the string.
.018e5e	18		clc				clc 								; from the string pointer
.018e5f	ad 00 04	lda $0400			lda 	StringPtr 					; and put in zTemp2 as well
.018e62	f1 10		sbc ($10),y			sbc 	(zTemp1),y
.018e64	8d 00 04	sta $0400			sta 	StringPtr
.018e67	85 12		sta $12				sta 	zTemp2
.018e69	ad 01 04	lda $0401			lda 	StringPtr+1
.018e6c	e9 00		sbc #$00			sbc 	#0
.018e6e	8d 01 04	sta $0401			sta 	StringPtr+1
.018e71	85 13		sta $13				sta 	zTemp2+1
.018e73	b1 10		lda ($10),y			lda 	(zTemp1),y 					; length add one for count
.018e75	1a		inc a				inc 	a
.018e76	aa		tax				tax
.018e77	b1 10		lda ($10),y	_SCCopy:lda 	(zTemp1),y 					; copy whole thing including length
.018e79	91 12		sta ($12),y			sta 	(zTemp2),y
.018e7b	c8		iny				iny
.018e7c	ca		dex				dex
.018e7d	d0 f8		bne $018e77			bne 	_SCCopy
.018e7f	a5 13		lda $13				lda 	zTemp2+1 					; return concrete string in AX
.018e81	a6 12		ldx $12				ldx 	zTemp2
.018e83	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.018e84					AllocateTempString:
.018e84	48		pha				pha 								; save required count.
.018e85	a5 21		lda $21				lda 	zTempStr+1 					; check if initialised yet ?
.018e87	d0 0b		bne $018e94			bne 	_ATSInitialised
.018e89	ad 00 04	lda $0400			lda 	StringPtr 					; set temporary string ptr 1 page below available
.018e8c	85 20		sta $20				sta 	zTempStr					; space, this is for strings to be concreted.
.018e8e	ad 01 04	lda $0401			lda 	StringPtr+1
.018e91	3a		dec a				dec 	a
.018e92	85 21		sta $21				sta 	zTempStr+1
.018e94					_ATSInitialised:
.018e94	68		pla				pla 								; get required count back.
.018e95	49 ff		eor #$ff			eor 	#$FF 						; negate 2's complement.
.018e97	1a		inc a				inc 	a
.018e98	18		clc				clc
.018e99	65 20		adc $20				adc 	zTempStr 					; "add" to the temp string pointer
.018e9b	85 20		sta $20				sta 	zTempStr
.018e9d	a9 ff		lda #$ff			lda 	#$FF
.018e9f	65 21		adc $21				adc 	zTempStr+1
.018ea1	85 21		sta $21				sta 	zTempStr+1
.018ea3	a9 00		lda #$00			lda 	#0 							; clear temp string.
.018ea5	5a		phy				phy
.018ea6	a8		tay				tay
.018ea7	91 20		sta ($20),y			sta 	(zTempStr),y
.018ea9	7a		ply				ply
.018eaa	1a		inc a				inc 	a 							; reset the write index.
.018eab	8d 8f 04	sta $048f			sta 	TempStringWriteIndex
.018eae	60		rts				rts
.018eaf					WriteTempString:
.018eaf	5a		phy				phy 								; save Y
.018eb0	ac 8f 04	ldy $048f			ldy 	TempStringWriteIndex	 	; write position.
.018eb3	91 20		sta ($20),y			sta 	(zTempStr),y 				; write character out.
.018eb5	ee 8f 04	inc $048f			inc 	TempStringWriteIndex 		; increment the write position.
.018eb8	98		tya				tya 								; unchanged Y is now length
.018eb9	a0 00		ldy #$00			ldy 	#0
.018ebb	91 20		sta ($20),y			sta 	(zTempStr),y
.018ebd	7a		ply				ply 								; restore Y and exit
.018ebe	60		rts				rts
.018ebf					CreateTempStringCopy:
.018ebf	da		phx				phx 								; save X
.018ec0	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018ec2	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.018ec3	20 84 8e	jsr $018e84			jsr 	AllocateTempString 			; allocate memory for temporary string.
.018ec6	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018ec8	c8		iny				iny
.018ec9	3a		dec a				dec 	a 							; make the actual length in charactes
.018eca	3a		dec a				dec 	a
.018ecb	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.018ecd	81 20		sta ($20,x)			sta 	(zTempStr,x)
.018ecf	85 1a		sta $1a				sta 	zLTemp1 					; that's used as a count.
.018ed1	09 00		ora #$00			ora 	#0 							; if zero already, exit
.018ed3	f0 0e		beq $018ee3			beq 	_CTSCExit
.018ed5					_CTSCLoop:
.018ed5	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018ed7	c8		iny				iny
.018ed8	5a		phy				phy 								; save in Y
.018ed9	e8		inx				inx 								; bump index
.018eda	da		phx				phx 								; index into Y
.018edb	7a		ply				ply
.018edc	91 20		sta ($20),y			sta 	(zTempStr),y 				; save at index
.018ede	7a		ply				ply 								; restore Y
.018edf	c6 1a		dec $1a				dec 	zLTemp1 					; do for each character
.018ee1	d0 f2		bne $018ed5			bne 	_CTSCLoop
.018ee3					_CTSCExit:
.018ee3	fa		plx				plx 								; restore X
.018ee4	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/variables.asm

.018ee5					VariableFind:
.018ee5	20 20 8f	jsr $018f20			jsr 	VariableExtract 		; find out all about it ....
.018ee8	20 20 90	jsr $019020			jsr 	VariableLocate 			; does it already exist ?
.018eeb	b0 03		bcs $018ef0			bcs 	_VFExists 				; if so, use that.
.018eed	20 ac 8f	jsr $018fac			jsr 	VariableCreate 			; otherwise create it.
.018ef0					_VFExists:
.018ef0	60		rts				rts
.018ef1					VariableClear:
.018ef1	48		pha				pha 							; save registers
.018ef2	da		phx				phx
.018ef3	a2 00		ldx #$00			ldx 	#0 						; clear out the hash table.
.018ef5	8a		txa				txa
.018ef6	9d 25 04	sta $0425,x	_VCLoop:sta 	HashTableBase,x
.018ef9	e8		inx				inx
.018efa	e0 60		cpx #$60			cpx 	#HashTableEnd-HashTableBase
.018efc	d0 f8		bne $018ef6			bne 	_VCLoop
.018efe	a9 00		lda #$00			lda 	#VariableMemory & $FF	; reset the free variable memory pointer
.018f00	8d 02 04	sta $0402			sta 	VarMemPtr
.018f03	a9 40		lda #$40			lda 	#VariableMemory >> 8
.018f05	8d 03 04	sta $0403			sta 	VarMemPtr+1
.018f08	fa		plx				plx 							; restore registers
.018f09	68		pla				pla
.018f0a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/extract.asm

.018f0b					VariableNameError:
.018f0b	20 26 82	jsr $018226			jsr ERR_Handler
>018f0e	42 61 64 20 56 61 72 69			.text "Bad Variable Name",0
>018f16	61 62 6c 65 20 4e 61 6d 65 00
.018f20					VariableExtract:
.018f20	da		phx				phx 							; save X.
.018f21	a9 b8		lda #$b8			lda 	#token_hashlParen  		; set the type to #( e.g. real array.
.018f23	8d 85 04	sta $0485			sta 	Var_Type
.018f26	8d 86 04	sta $0486			sta 	Var_Hash 				; we initialise the hash with this. It doesn't matter
.018f29	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018f2b	c9 00		cmp #$00			cmp 	#0 						; first one must be A-Z
.018f2d	f0 dc		beq $018f0b			beq 	VariableNameError
.018f2f	c9 1b		cmp #$1b			cmp 	#26+1
.018f31	b0 d8		bcs $018f0b			bcs 	VariableNameError
.018f33	a2 ff		ldx #$ff			ldx 	#255 					; now copy it into the variable buffer.
.018f35					_VECopyBuffer:
.018f35	e8		inx				inx
.018f36	e0 1f		cpx #$1f			cpx 	#31 					; too long
.018f38	f0 d1		beq $018f0b			beq 	VariableNameError
.018f3a	9d 05 04	sta $0405,x			sta 	Var_Buffer,x 			; save character
.018f3d	18		clc				clc  							; update the hash value for it.
.018f3e	6d 86 04	adc $0486			adc 	Var_Hash
.018f41	8d 86 04	sta $0486			sta 	Var_Hash
.018f44	c8		iny				iny
.018f45	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018f47	c9 00		cmp #$00			cmp 	#0 						; zero or token, end of variable
.018f49	f0 0e		beq $018f59			beq 	_VECopyEnd
.018f4b	30 0c		bmi $018f59			bmi 	_VECopyEnd
.018f4d	c9 1b		cmp #$1b			cmp 	#26+1 					; A-Z continue copying
.018f4f	90 e4		bcc $018f35			bcc 	_VECopyBuffer
.018f51	c9 30		cmp #$30			cmp 	#"0" 					; 0-9 copy as well.
.018f53	90 04		bcc $018f59			bcc 	_VECopyEnd
.018f55	c9 3a		cmp #$3a			cmp 	#"9"+1
.018f57	90 dc		bcc $018f35			bcc 	_VECopyBuffer
.018f59					_VECopyEnd:
.018f59	c8		iny				iny
.018f5a	c9 b5		cmp #$b5			cmp 	#token_Dollar 			; first type token.
.018f5c	90 04		bcc $018f62			bcc 	_VEDefaultRequired
.018f5e	c9 bb		cmp #$bb			cmp 	#token_PercentLParen+1	; last type token.
.018f60	90 0b		bcc $018f6d			bcc 	_VEHaveType
.018f62					_VEDefaultRequired:
.018f62	c9 bb		cmp #$bb			cmp 	#token_LParen 			; if it ends in ( then use the real array
.018f64	f0 04		beq $018f6a			beq 	_VESetType 				; default set above.
.018f66	ce 85 04	dec $0485			dec 	Var_Type 				; this changes that default to the variable default
.018f69	88		dey				dey
.018f6a					_VESetType:
.018f6a	ad 85 04	lda $0485			lda 	Var_Type 				; get type ....
.018f6d					_VEHaveType:
.018f6d	8d 85 04	sta $0485			sta 	Var_Type 				; save as type.
.018f70	bd 05 04	lda $0405,x			lda 	Var_Buffer,x 			; set bit 7 of name, marks the end.
.018f73	09 80		ora #$80			ora 	#$80
.018f75	9d 05 04	sta $0405,x			sta 	Var_Buffer,x
.018f78	e8		inx				inx 							; offset 3 => length 4.
.018f79	8e 87 04	stx $0487			stx 	Var_Length 				; save length of variable name.
.018f7c	ad 85 04	lda $0485			lda 	Var_Type 				; get offset of var type from first type token
.018f7f	38		sec				sec
.018f80	e9 b5		sbc #$b5			sbc 	#token_Dollar
.018f82	0a		asl a				asl 	a 						; multiply by 16. This requires HashTableSize
.018f83	0a		asl a				asl 	a 						; in data.asm to be 8 (8 sets of links,2 bytes each)
.018f84	0a		asl a				asl 	a
.018f85	0a		asl a				asl 	a
.018f86	8d 88 04	sta $0488			sta 	Var_HashAddress
.018f89	ad 86 04	lda $0486			lda 	Var_Hash 				; get the hash
.018f8c	29 07		and #$07			and 	#(HashTableSize-1) 		; force into range 0-tableSize-1
.018f8e	0a		asl a				asl 	a 						; double it (2 bytes per entry) & clears carry
.018f8f	6d 88 04	adc $0488			adc 	Var_HashAddress 		; add table offset.
.018f92	69 25		adc #$25			adc 	#HashTableBase & $FF 	; now the low byte of the actual table address
.018f94	8d 88 04	sta $0488			sta 	Var_HashAddress
.018f97	a2 05		ldx #$05			ldx 	#5 						; hash is 5 bytes (real)
.018f99	ad 85 04	lda $0485			lda 	Var_Type
.018f9c	c9 b7		cmp #$b7			cmp 	#token_Hash
.018f9e	f0 07		beq $018fa7			beq 	_VEHaveSize
.018fa0	ca		dex				dex
.018fa1	c9 b9		cmp #$b9			cmp 	#token_Percent 			; percent is 4 bytes (integer)
.018fa3	f0 02		beq $018fa7			beq 	_VEHaveSize
.018fa5	a2 02		ldx #$02			ldx 	#2 						; everything else is two.
.018fa7					_VEHaveSize:
.018fa7	8e 89 04	stx $0489			stx 	Var_DataSize
.018faa	fa		plx				plx
.018fab	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varcreate.asm

.018fac					VariableCreate:
.018fac	da		phx				phx
.018fad	5a		phy				phy
.018fae	ad 02 04	lda $0402			lda 	VarMemPtr 					; get address of next free into zTemp1
.018fb1	85 10		sta $10				sta 	zTemp1
.018fb3	ad 03 04	lda $0403			lda 	VarMemPtr+1
.018fb6	85 11		sta $11				sta 	zTemp1+1
.018fb8	ad 89 04	lda $0489			lda 	Var_DataSize 				; bytes for the data bit
.018fbb	18		clc				clc
.018fbc	6d 87 04	adc $0487			adc 	Var_Length 					; add the length of the name
.018fbf	69 03		adc #$03			adc 	#3 							; 3 for the link and the hash.
.018fc1	6d 02 04	adc $0402			adc 	VarMemPtr 					; add to variable memory pointer
.018fc4	8d 02 04	sta $0402			sta 	VarMemPtr
.018fc7	90 03		bcc $018fcc			bcc 	_VCNoCarry
.018fc9	ee 03 04	inc $0403			inc 	VarMemPtr+1
.018fcc					_VCNoCarry:
.018fcc	ad 88 04	lda $0488			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.018fcf	85 12		sta $12				sta 	zTemp2
.018fd1	a9 04		lda #$04			lda 	#HashTableBase >> 8
.018fd3	85 13		sta $13				sta 	zTemp2+1
.018fd5	a0 00		ldy #$00			ldy 	#0 							; put current hash link in position.
.018fd7	b1 12		lda ($12),y			lda 	(zTemp2),y
.018fd9	91 10		sta ($10),y			sta 	(zTemp1),y
.018fdb	c8		iny				iny
.018fdc	b1 12		lda ($12),y			lda 	(zTemp2),y
.018fde	91 10		sta ($10),y			sta 	(zTemp1),y
.018fe0	c8		iny				iny
.018fe1	ad 86 04	lda $0486			lda 	Var_Hash 					; write the hash out.
.018fe4	91 10		sta ($10),y			sta 	(zTemp1),y
.018fe6	c8		iny				iny
.018fe7	a2 00		ldx #$00			ldx 	#0 							; copy the name out.
.018fe9					_VCCopyName:
.018fe9	bd 05 04	lda $0405,x			lda 	Var_Buffer,x
.018fec	91 10		sta ($10),y			sta 	(zTemp1),y
.018fee	e8		inx				inx
.018fef	c8		iny				iny
.018ff0	ec 87 04	cpx $0487			cpx 	Var_Length
.018ff3	d0 f4		bne $018fe9			bne 	_VCCopyName
.018ff5	5a		phy				phy 								; save the data offset.
.018ff6	ae 89 04	ldx $0489			ldx 	Var_DataSize 				; and write the data out.
.018ff9	a9 00		lda #$00			lda 	#0 							; which is all zeroes.
.018ffb					_VCClearData:
.018ffb	91 10		sta ($10),y			sta 	(zTemp1),y
.018ffd	c8		iny				iny
.018ffe	ca		dex				dex
.018fff	d0 fa		bne $018ffb			bne 	_VCClearData
.019001	68		pla				pla 								; offset to the data
.019002	18		clc				clc
.019003	65 10		adc $10				adc 	zTemp1 						; add to start and save as data pointer.
.019005	85 22		sta $22				sta 	zVarDataPtr
.019007	a5 11		lda $11				lda 	zTemp1+1
.019009	69 00		adc #$00			adc 	#0
.01900b	85 23		sta $23				sta 	zVarDataPtr+1
.01900d	ad 85 04	lda $0485			lda 	Var_Type 					; and set the type.
.019010	85 24		sta $24				sta 	zVarType
.019012	a5 10		lda $10				lda 	zTemp1 						; fix hash link to point to new record
.019014	a0 00		ldy #$00			ldy 	#0
.019016	91 12		sta ($12),y			sta 	(zTemp2),y
.019018	c8		iny				iny
.019019	a5 11		lda $11				lda 	zTemp1+1
.01901b	91 12		sta ($12),y			sta 	(zTemp2),y
.01901d	7a		ply				ply
.01901e	fa		plx				plx
.01901f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varfind.asm

.019020					VariableLocate:
.019020	18		clc				clc
.019021	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/vargetset.asm

.019022					VariableGet:
.019022	5a		phy				phy
.019023	a0 00		ldy #$00			ldy 	#0 							; copy first two bytes
.019025	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019027	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.01902a	c8		iny				iny
.01902b	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.01902d	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019030	c8		iny				iny
.019031	ad 85 04	lda $0485			lda 	Var_Type 					; if it is a string, set up for that.
.019034	c9 b5		cmp #$b5			cmp 	#token_Dollar
.019036	f0 33		beq $01906b			beq 	_VGString
.019038	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; copy the next two bytes.
.01903a	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01903d	c8		iny				iny
.01903e	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019040	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019043	c8		iny				iny
.019044	a9 01		lda #$01			lda 	#1 							; set type to 1.
.019046	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019049	ad 85 04	lda $0485			lda 	Var_Type
.01904c	c9 b9		cmp #$b9			cmp 	#token_Percent 				; if it is a %, then exit with default integer.
.01904e	f0 2f		beq $01907f			beq 	_VGExit
.019050	a9 40		lda #$40			lda 	#$40 						; set type byte to zero
.019052	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; which is the code for zero/float.
.019055	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; the last value to copy is the exponent.
.019057	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.01905a	f0 23		beq $01907f			beq 	_VGExit 					; if exponent is zero ... it's zero.
.01905c	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; the sign bit is the top mantissa bit.
.01905f	48		pha				pha
.019060	29 80		and #$80			and 	#$80
.019062	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; this is the type byte.
.019065	68		pla				pla
.019066	09 80		ora #$80			ora 	#$80 						; set the MSB as you would expect.
.019068	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x 			; so it's a normalised float.
.01906b					_VGString:
.01906b	a9 02		lda #$02			lda 	#2 							; set type to 2, a string
.01906d	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019070	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; is the value there $0000
.019073	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.019076	d0 07		bne $01907f			bne 	_VGExit 					; if not, exit.
.019078	85 25		sta $25				sta 	zNullString 				; make zNullString a 00 string.
.01907a	a9 25		lda #$25			lda 	#zNullString
.01907c	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; make it point to it.
.01907f					_VGExit:
.01907f	7a		ply				ply
.019080	60		rts				rts
.019081					VariableSet:
.019081	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; is the result a string
.019084	29 02		and #$02			and 	#2 							; if so, it has to be
.019086	d0 53		bne $0190db			bne 	_VSString
.019088	a5 24		lda $24				lda 	zVarType 					; if type is $ there's an error.
.01908a	c9 b5		cmp #$b5			cmp 	#token_Dollar
.01908c	f0 4a		beq $0190d8			beq 	_VSBadType
.01908e	c9 b9		cmp #$b9			cmp 	#token_Percent 				; type convert to float/int
.019090	f0 05		beq $019097			beq 	_VSMakeInt
.019092	20 8d 96	jsr $01968d			jsr 	FPUToFloat
.019095	80 03		bra $01909a			bra 	_VSCopy
.019097					_VSMakeInt:
.019097	20 ec 96	jsr $0196ec			jsr 	FPUToInteger
.01909a					_VSCopy:
.01909a	5a		phy				phy
.01909b	a0 00		ldy #$00			ldy 	#0 							; copy mantissa to target.
.01909d	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.0190a0	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0190a2	c8		iny				iny
.0190a3	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0190a6	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0190a8	c8		iny				iny
.0190a9	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.0190ac	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0190ae	c8		iny				iny
.0190af	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.0190b2	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0190b4	a5 24		lda $24				lda 	zVarType 					; if target is integer, alrady done.
.0190b6	c9 b9		cmp #$b9			cmp 	#token_Percent
.0190b8	f0 1c		beq $0190d6			beq 	_VSExit
.0190ba	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get the sign bit into carry flag.
.0190bd	0a		asl a				asl 	a
.0190be	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; shift the sign into the mantissa high.
.0190c1	08		php				php
.0190c2	0a		asl a				asl 	a
.0190c3	28		plp				plp
.0190c4	6a		ror a				ror 	a
.0190c5	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0190c7	c8		iny				iny
.0190c8	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; copy the exponent in
.0190cb	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0190cd	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if the result is non zero
.0190d0	50 04		bvc $0190d6			bvc 	_VSExit
.0190d2	a9 00		lda #$00			lda 	#00 						; zero exponent indicating 0.
.0190d4	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0190d6					_VSExit:
.0190d6	7a		ply				ply
.0190d7	60		rts				rts
.0190d8					_VSBadType:
.0190d8	4c 07 82	jmp $018207			jmp 	TypeError
.0190db					_VSString:
.0190db	a5 24		lda $24				lda 	zVarType 					; type must be $
.0190dd	c9 b5		cmp #$b5			cmp 	#token_Dollar
.0190df	d0 f7		bne $0190d8			bne 	_VSBadType
.0190e1	da		phx				phx
.0190e2	5a		phy				phy
.0190e3	20 52 8e	jsr $018e52			jsr 	StringConcrete 				; concrete the string in the mantissa -> AX
.0190e6	a0 01		ldy #$01			ldy 	#1 							; save high byte
.0190e8	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0190ea	88		dey				dey 								; save low byte
.0190eb	8a		txa				txa
.0190ec	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0190ee	7a		ply				ply 								; and exit.
.0190ef	fa		plx				plx
.0190f0	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.0190f1					MulInteger32:
.0190f1	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.0190f4	9d 14 03	sta $0314,x			sta 	XS3_Mantissa,x
.0190f7	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0190fa	9d 15 03	sta $0315,x			sta 	XS3_Mantissa+1,x
.0190fd	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.019100	9d 16 03	sta $0316,x			sta 	XS3_Mantissa+2,x
.019103	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.019106	9d 17 03	sta $0317,x			sta 	XS3_Mantissa+3,x
.019109	a9 00		lda #$00			lda 	#0
.01910b	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x 				; zero +0
.01910e	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019111	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019114	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019117					_BFMMultiply:
.019117	bd 14 03	lda $0314,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.01911a	29 01		and #$01			and 	#1
.01911c	f0 03		beq $019121			beq 	_BFMNoAdd
.01911e	20 a7 89	jsr $0189a7			jsr 	AddInteger32
.019121					_BFMNoAdd:
.019121	1e 0e 03	asl $030e,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.019124	3e 0f 03	rol $030f,x			rol 	XS2_Mantissa+1,x
.019127	3e 10 03	rol $0310,x			rol 	XS2_Mantissa+2,x
.01912a	3e 11 03	rol $0311,x			rol 	XS2_Mantissa+3,x
.01912d	5e 17 03	lsr $0317,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.019130	7e 16 03	ror $0316,x			ror 	XS3_Mantissa+2,x
.019133	7e 15 03	ror $0315,x			ror 	XS3_Mantissa+1,x
.019136	7e 14 03	ror $0314,x			ror 	XS3_Mantissa,x
.019139	bd 14 03	lda $0314,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.01913c	1d 15 03	ora $0315,x			ora 	XS3_Mantissa+1,x
.01913f	1d 16 03	ora $0316,x			ora 	XS3_Mantissa+2,x
.019142	1d 17 03	ora $0317,x			ora 	XS3_Mantissa+3,x
.019145	d0 d0		bne $019117			bne 	_BFMMultiply
.019147	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.019148					DivInteger32:
.019148	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; check for /0
.01914b	1d 0f 03	ora $030f,x			ora 	XS2_Mantissa+1,x
.01914e	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.019151	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.019154	d0 14		bne $01916a			bne 	_BFDOkay
.019156	20 26 82	jsr $018226			jsr ERR_Handler
>019159	44 69 76 69 73 69 6f 6e			.text "Division by Zero",0
>019161	20 62 79 20 5a 65 72 6f 00
.01916a					_BFDOkay:
.01916a	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.01916c	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.01916e	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.019170	85 1c		sta $1c				sta 	zLTemp1+2
.019172	85 1d		sta $1d				sta 	zLTemp1+3
.019174	8d 8e 04	sta $048e			sta 	SignCount 					; Count of signs.
.019177	20 d8 91	jsr $0191d8			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.01917a	da		phx				phx
.01917b	e8		inx				inx
.01917c	e8		inx				inx
.01917d	e8		inx				inx
.01917e	e8		inx				inx
.01917f	e8		inx				inx
.019180	e8		inx				inx
.019181	20 d8 91	jsr $0191d8			jsr 	CheckIntegerNegate
.019184	fa		plx				plx
.019185	5a		phy				phy 								; Y is the counter
.019186	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.019188					_BFDLoop:
.019188	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.01918b	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.01918e	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.019191	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.019194	26 1a		rol $1a				rol 	zLTemp1
.019196	26 1b		rol $1b				rol 	zLTemp1+1
.019198	26 1c		rol $1c				rol 	zLTemp1+2
.01919a	26 1d		rol $1d				rol 	zLTemp1+3
.01919c	38		sec				sec
.01919d	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.01919f	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.0191a2	48		pha				pha
.0191a3	a5 1b		lda $1b				lda 	zLTemp1+1
.0191a5	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.0191a8	48		pha				pha
.0191a9	a5 1c		lda $1c				lda 	zLTemp1+2
.0191ab	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.0191ae	48		pha				pha
.0191af	a5 1d		lda $1d				lda 	zLTemp1+3
.0191b1	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.0191b4	90 15		bcc $0191cb			bcc 	_BFDNoAdd
.0191b6	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.0191b8	68		pla				pla
.0191b9	85 1c		sta $1c				sta 	zLTemp1+2
.0191bb	68		pla				pla
.0191bc	85 1b		sta $1b				sta 	zLTemp1+1
.0191be	68		pla				pla
.0191bf	85 1a		sta $1a				sta 	zLTemp1+0
.0191c1	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.0191c4	09 01		ora #$01			ora 	#1
.0191c6	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0191c9	80 03		bra $0191ce			bra 	_BFDNext
.0191cb					_BFDNoAdd:
.0191cb	68		pla				pla 								; Throw away the intermediate calculations
.0191cc	68		pla				pla
.0191cd	68		pla				pla
.0191ce					_BFDNext:
.0191ce	88		dey				dey
.0191cf	d0 b7		bne $019188			bne 	_BFDLoop
.0191d1	7a		ply				ply 								; restore Y and exit
.0191d2	4e 8e 04	lsr $048e			lsr 	SignCount 					; if sign count odd,
.0191d5	b0 07		bcs $0191de			bcs		IntegerNegateAlways 			; negate the result
.0191d7	60		rts				rts
.0191d8					CheckIntegerNegate:
.0191d8	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.0191db	30 01		bmi $0191de			bmi 	IntegerNegateAlways
.0191dd	60		rts				rts
.0191de					IntegerNegateAlways:
.0191de	ee 8e 04	inc $048e			inc 	SignCount
.0191e1	38		sec				sec
.0191e2	a9 00		lda #$00			lda 	#0
.0191e4	fd 08 03	sbc $0308,x			sbc 	XS_Mantissa+0,x
.0191e7	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0191ea	a9 00		lda #$00			lda 	#0
.0191ec	fd 09 03	sbc $0309,x			sbc 	XS_Mantissa+1,x
.0191ef	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0191f2	a9 00		lda #$00			lda 	#0
.0191f4	fd 0a 03	sbc $030a,x			sbc 	XS_Mantissa+2,x
.0191f7	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0191fa	a9 00		lda #$00			lda 	#0
.0191fc	fd 0b 03	sbc $030b,x			sbc 	XS_Mantissa+3,x
.0191ff	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019202	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.019203					INTToString:
.019203	48		pha				pha
.019204	5a		phy				phy
.019205	bd 0b 03	lda $030b,x			lda 		XS_Mantissa+3,x 		; check -ve
.019208	10 08		bpl $019212			bpl 		_ITSNotMinus
.01920a	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.01920c	20 a7 92	jsr $0192a7			jsr 		ITSOutputCharacter
.01920f	20 de 91	jsr $0191de			jsr 		IntegerNegateAlways 	; negate the number.
.019212					_ITSNotMinus:
.019212	a9 00		lda #$00			lda 		#0
.019214	8d 8a 04	sta $048a			sta 		NumSuppress 			; clear the suppression flag.
.019217	8a		txa				txa 								; use Y for the mantissa index.
.019218	a8		tay				tay
.019219	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.01921b					_ITSNextSubtractor:
.01921b	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.01921d	8d 8b 04	sta $048b			sta 		NumConvCount
.019220					_ITSSubtract:
.019220	38		sec				sec
.019221	b9 08 03	lda $0308,y			lda 		XS_Mantissa,y 			; subtract number and push on stack
.019224	ff 83 92 01	sbc $019283,x			sbc 		_ITSSubtractors+0,x
.019228	48		pha				pha
.019229	b9 09 03	lda $0309,y			lda 		XS_Mantissa+1,y
.01922c	ff 84 92 01	sbc $019284,x			sbc 		_ITSSubtractors+1,x
.019230	48		pha				pha
.019231	b9 0a 03	lda $030a,y			lda 		XS_Mantissa+2,y
.019234	ff 85 92 01	sbc $019285,x			sbc 		_ITSSubtractors+2,x
.019238	48		pha				pha
.019239	b9 0b 03	lda $030b,y			lda 		XS_Mantissa+3,y
.01923c	ff 86 92 01	sbc $019286,x			sbc 		_ITSSubtractors+3,x
.019240	90 14		bcc $019256			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.019242	99 0b 03	sta $030b,y			sta 		XS_Mantissa+3,y 		; save subtract off stack
.019245	68		pla				pla
.019246	99 0a 03	sta $030a,y			sta 		XS_Mantissa+2,y
.019249	68		pla				pla
.01924a	99 09 03	sta $0309,y			sta 		XS_Mantissa+1,y
.01924d	68		pla				pla
.01924e	99 08 03	sta $0308,y			sta 		XS_Mantissa+0,y
.019251	ee 8b 04	inc $048b			inc 		NumConvCount 			; bump count.
.019254	80 ca		bra $019220			bra 		_ITSSubtract 			; go round again.
.019256					_ITSCantSubtract:
.019256	68		pla				pla 								; throw away interim answers
.019257	68		pla				pla
.019258	68		pla				pla
.019259	ad 8b 04	lda $048b			lda 		NumConvCount 			; if not zero then no suppression check
.01925c	c9 30		cmp #$30			cmp 		#"0"
.01925e	d0 05		bne $019265			bne 		_ITSOutputDigit
.019260	ad 8a 04	lda $048a			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.019263	10 09		bpl $01926e			bpl	 		_ITSGoNextSubtractor
.019265					_ITSOutputDigit:
.019265	ce 8a 04	dec $048a			dec 		NumSuppress 			; suppression check will be non-zero.
.019268	ad 8b 04	lda $048b			lda 		NumConvCount 			; count of subtractions
.01926b	20 a7 92	jsr $0192a7			jsr 		ITSOutputCharacter 		; output it.
.01926e					_ITSGoNextSubtractor:
.01926e	e8		inx				inx 								; next dword
.01926f	e8		inx				inx
.019270	e8		inx				inx
.019271	e8		inx				inx
.019272	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.019274	d0 a5		bne $01921b			bne 		_ITSNextSubtractor 		; do all the subtractors.
.019276	98		tya				tya 								; X is back as the mantissa index
.019277	aa		tax				tax
.019278	bd 08 03	lda $0308,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.01927b	09 30		ora #$30			ora 		#"0"
.01927d	20 a7 92	jsr $0192a7			jsr 		ITSOutputCharacter
.019280	7a		ply				ply 								; and exit
.019281	68		pla				pla
.019282	60		rts				rts
.019283					_ITSSubtractors:
>019283	00 ca 9a 3b					.dword 		1000000000
>019287	00 e1 f5 05					.dword 		100000000
>01928b	80 96 98 00					.dword 		10000000
>01928f	40 42 0f 00					.dword 		1000000
>019293	a0 86 01 00					.dword 		100000
>019297	10 27 00 00					.dword 		10000
>01929b	e8 03 00 00					.dword 		1000
>01929f	64 00 00 00					.dword 		100
>0192a3	0a 00 00 00					.dword 		10
.0192a7					_ITSSubtractorsEnd:
.0192a7					ITSOutputCharacter:
.0192a7	48		pha				pha
.0192a8	da		phx				phx
.0192a9	ae 04 04	ldx $0404			ldx 	NumBufX 					; save digit
.0192ac	9d 05 04	sta $0405,x			sta 	Num_Buffer,x
.0192af	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.0192b1	9d 06 04	sta $0406,x			sta 	Num_Buffer+1,x
.0192b4	ee 04 04	inc $0404			inc 	NumBufX						; bump pointer.
.0192b7	fa		plx				plx
.0192b8	68		pla				pla
.0192b9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.0192ba					IntFromString:
.0192ba	a0 00		ldy #$00			ldy 	#0
.0192bc	8c 8c 04	sty $048c			sty 	ExpTemp 					; this is the converted digit count.
.0192bf					IntFromStringY:
.0192bf	48		pha				pha
.0192c0	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.0192c2	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.0192c5	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0192c8	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0192cb	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0192ce	a9 01		lda #$01			lda 	#1
.0192d0	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0192d3					_IFSLoop:
.0192d3	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.0192d5	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.0192d7	90 60		bcc $019339			bcc 	_IFSExit
.0192d9	c9 3a		cmp #$3a			cmp 	#"9"+1
.0192db	b0 5c		bcs $019339			bcs 	_IFSExit
.0192dd	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.0192e0	c9 0c		cmp #$0c			cmp 	#12
.0192e2	b0 5f		bcs $019343			bcs 	_IFSOverflow
.0192e4	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.0192e7	48		pha				pha
.0192e8	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.0192eb	48		pha				pha
.0192ec	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0192ef	48		pha				pha
.0192f0	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.0192f3	48		pha				pha
.0192f4	20 58 93	jsr $019358			jsr 	IFSX1ShiftLeft 				; double
.0192f7	20 58 93	jsr $019358			jsr 	IFSX1ShiftLeft 				; x 4
.0192fa	18		clc				clc 								; add saved value x 5
.0192fb	68		pla				pla
.0192fc	7d 08 03	adc $0308,x			adc 	XS_Mantissa+0,x
.0192ff	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019302	68		pla				pla
.019303	7d 09 03	adc $0309,x			adc 	XS_Mantissa+1,x
.019306	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019309	68		pla				pla
.01930a	7d 0a 03	adc $030a,x			adc 	XS_Mantissa+2,x
.01930d	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019310	68		pla				pla
.019311	7d 0b 03	adc $030b,x			adc 	XS_Mantissa+3,x
.019314	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019317	20 58 93	jsr $019358			jsr 	IFSX1ShiftLeft 				; x 10
.01931a	ee 8c 04	inc $048c			inc 	ExpTemp 					; bump count of digits processed.
.01931d	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.01931f	29 0f		and #$0f			and 	#15
.019321	c8		iny				iny
.019322	7d 08 03	adc $0308,x			adc 	XS_Mantissa+0,x
.019325	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019328	90 a9		bcc $0192d3			bcc 	_IFSLoop
.01932a	fe 09 03	inc $0309,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.01932d	d0 a4		bne $0192d3			bne 	_IFSLoop
.01932f	fe 0a 03	inc $030a,x			inc 	XS_Mantissa+2,x
.019332	d0 9f		bne $0192d3			bne 	_IFSLoop
.019334	fe 0b 03	inc $030b,x			inc 	XS_Mantissa+3,x
.019337	80 9a		bra $0192d3			bra 	_IFSLoop
.019339					_IFSExit:
.019339	98		tya				tya 								; get offset
.01933a					_IFSOkay:
.01933a	38		sec				sec
.01933b	ad 8c 04	lda $048c			lda 	ExpTemp
.01933e	f0 01		beq $019341			beq 	_IFSSkipFail
.019340	18		clc				clc
.019341					_IFSSkipFail:
.019341	68		pla				pla 								; and exit.
.019342	60		rts				rts
.019343					_IFSOverflow:
.019343	20 26 82	jsr $018226			jsr 	ERR_Handler
>019346	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>01934e	20 6f 76 65 72 66 6c 6f 77 00
.019358					IFSX1ShiftLeft:
.019358	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x
.01935b	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.01935e	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.019361	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.019364	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.019365					FPSubtract:
.019365	48		pha				pha
.019366	bd 13 03	lda $0313,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.019369	49 80		eor #$80			eor 	#$80
.01936b	9d 13 03	sta $0313,x			sta 	XS2_Type,x
.01936e	68		pla				pla 								; --- and fall through ---
.01936f					FPAdd:
.01936f	48		pha				pha
.019370	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.019373	d0 05		bne $01937a			bne 	_FPA_NegativeLHS
.019375	20 97 93	jsr $019397			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.019378	68		pla				pla
.019379	60		rts				rts
.01937a					_FPA_NegativeLHS:
.01937a	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.01937d	49 80		eor #$80			eor 	#$80
.01937f	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019382	bd 13 03	lda $0313,x			lda 	XS2_Type,x 					; flip the sign of B and add
.019385	49 80		eor #$80			eor 	#$80
.019387	9d 13 03	sta $0313,x			sta 	XS2_Type,x
.01938a	20 97 93	jsr $019397			jsr 	FPAdd_Worker 				; do the add calculation.
.01938d	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip sign of X1 back
.019390	49 80		eor #$80			eor 	#$80
.019392	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019395	68		pla				pla
.019396	60		rts				rts
.019397					FPAdd_Worker:
.019397	3c 13 03	bit $0313,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.01939a	70 08		bvs $0193a4			bvs 	_FPAWExit 					; no change.
.01939c	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.01939f	50 07		bvc $0193a8			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.0193a1	20 3c 96	jsr $01963c			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.0193a4					_FPAWExit:
.0193a4	20 c4 96	jsr $0196c4			jsr 	FPUNormalise 				; normalise the result.
.0193a7	60		rts				rts
.0193a8					_FPAWMakeSame:
.0193a8	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.0193ab	38		sec				sec
.0193ac	fd 12 03	sbc $0312,x			sbc	 	XS2_Exponent,x 				; using subtraction
.0193af	f0 1b		beq $0193cc			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.0193b1	da		phx				phx 								; save X
.0193b2	90 06		bcc $0193ba			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.0193b4	e8		inx				inx
.0193b5	e8		inx				inx
.0193b6	e8		inx				inx
.0193b7	e8		inx				inx
.0193b8	e8		inx				inx
.0193b9	e8		inx				inx
.0193ba					_FPAWShiftA:
.0193ba	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x 				; so shift exponent up.
.0193bd	5e 0b 03	lsr $030b,x			lsr 	3+XS_Mantissa,x
.0193c0	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.0193c3	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.0193c6	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.0193c9	fa		plx				plx 								; restore original X
.0193ca	80 dc		bra $0193a8			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.0193cc					_FPAW_DoArithmetic:
.0193cc	3c 13 03	bit $0313,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.0193cf	30 39		bmi $01940a			bmi 	_FPAW_BNegative
.0193d1	18		clc				clc
.0193d2	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.0193d5	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.0193d8	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0193db	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0193de	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.0193e1	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0193e4	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.0193e7	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.0193ea	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0193ed	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.0193f0	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.0193f3	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0193f6	90 ac		bcc $0193a4			bcc 	_FPAWExit 					; no carry.
.0193f8	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x 				; so shift exponent up.
.0193fb	38		sec				sec
.0193fc	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.0193ff	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.019402	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.019405	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.019408	80 9a		bra $0193a4			bra 	_FPAWExit
.01940a					_FPAW_BNegative:
.01940a	38		sec				sec
.01940b	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.01940e	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.019411	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019414	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.019417	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.01941a	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.01941d	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.019420	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.019423	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019426	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.019429	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.01942c	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.01942f	b0 0b		bcs $01943c			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.019431	20 69 96	jsr $019669			jsr 	FPUNegateInteger			; negate the mantissa
.019434	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip result sign
.019437	49 80		eor #$80			eor 	#$80
.019439	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.01943c					_FPAWGoExit:
.01943c	4c a4 93	jmp $0193a4			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.01943f					FPD_IsDivZero:
.01943f	20 26 82	jsr $018226			jsr ERR_Handler
>019442	44 69 76 69 73 69 6f 6e			.text "Division by zero",0
>01944a	20 62 79 20 7a 65 72 6f 00
.019453					FPDivide:
.019453	48		pha				pha
.019454	5a		phy				phy
.019455	3c 13 03	bit $0313,x			bit 	XS2_Type,x 					; check if division by zero
.019458	70 e5		bvs $01943f			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.01945a	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.01945d	f0 03		beq $019462			beq 	_FPDCalculateExp
.01945f					_FPD_Exit:
.01945f	7a		ply				ply
.019460	68		pla				pla
.019461	60		rts				rts
.019462					_FPDCalculateExp:
.019462	bd 12 03	lda $0312,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.019465	49 ff		eor #$ff			eor 	#$FF
.019467	1a		inc a				inc 	a
.019468	9d 12 03	sta $0312,x			sta 	XS2_Exponent,x
.01946b	20 5f 95	jsr $01955f			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.01946e	18		clc				clc 	 							; add 1 to the resulting exponent
.01946f	69 01		adc #$01			adc 	#1
.019471	b0 65		bcs $0194d8			bcs 	_FPD_Overflow 				; which can overflow.
.019473	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.019476	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.019478	85 1a		sta $1a				sta 	zLTemp1+0
.01947a	85 1b		sta $1b				sta 	zLTemp1+1
.01947c	85 1c		sta $1c				sta 	zLTemp1+2
.01947e	85 1d		sta $1d				sta 	zLTemp1+3
.019480	a0 20		ldy #$20			ldy 	#32 						; times round.
.019482					_FPD_Loop:
.019482	38		sec				sec 								; calculate X1-X2 stacking result because we might
.019483	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; not save it.
.019486	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa,x
.019489	48		pha				pha
.01948a	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.01948d	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.019490	48		pha				pha
.019491	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.019494	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.019497	48		pha				pha
.019498	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.01949b	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.01949e	90 17		bcc $0194b7			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.0194a0	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x 			; save results out to A
.0194a3	68		pla				pla
.0194a4	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0194a7	68		pla				pla
.0194a8	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0194ab	68		pla				pla
.0194ac	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0194af	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.0194b1	09 80		ora #$80			ora 	#$80
.0194b3	85 1d		sta $1d				sta 	zLTemp1+3
.0194b5	80 03		bra $0194ba			bra 	_FPD_Rotates
.0194b7					_FPD_NoSubtract:
.0194b7	68		pla				pla 								; throw away unwanted results
.0194b8	68		pla				pla
.0194b9	68		pla				pla
.0194ba					_FPD_Rotates:
.0194ba	5e 11 03	lsr $0311,x			lsr 	3+XS2_Mantissa,x
.0194bd	7e 10 03	ror $0310,x			ror 	2+XS2_Mantissa,x
.0194c0	7e 0f 03	ror $030f,x			ror 	1+XS2_Mantissa,x
.0194c3	7e 0e 03	ror $030e,x			ror 	0+XS2_Mantissa,x
.0194c6	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.0194c8	26 1b		rol $1b				rol 	zLTemp1+1
.0194ca	26 1c		rol $1c				rol 	zLTemp1+2
.0194cc	26 1d		rol $1d				rol 	zLTemp1+3
.0194ce	90 02		bcc $0194d2			bcc 	_FPD_NoCarry
.0194d0	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.0194d2					_FPD_NoCarry:
.0194d2	88		dey				dey 								; do 32 times
.0194d3	d0 ad		bne $019482			bne 	_FPD_Loop
.0194d5	4c 3c 95	jmp $01953c			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.0194d8					_FPD_Overflow:
.0194d8	4c 39 97	jmp $019739			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.0194db					FPMultiply:
.0194db	48		pha				pha
.0194dc	5a		phy				phy
.0194dd	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.0194e0	70 08		bvs $0194ea			bvs 	_FPM_Exit
.0194e2	3c 13 03	bit $0313,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.0194e5	50 06		bvc $0194ed			bvc 	_FPM_CalcExponent
.0194e7	20 3c 96	jsr $01963c			jsr 	FPUCopyX2ToX1
.0194ea					_FPM_Exit:
.0194ea	7a		ply				ply
.0194eb	68		pla				pla
.0194ec	60		rts				rts
.0194ed					_FPM_CalcExponent:
.0194ed	18		clc				clc
.0194ee	20 5f 95	jsr $01955f			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.0194f1	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x 				; save the result.
.0194f4	a9 00		lda #$00			lda 	#0
.0194f6	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.0194f8	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.0194fa	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.0194fc	85 1d		sta $1d				sta 	zLTemp1+3
.0194fe	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.019500					_FPM_Loop:
.019500	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x				; check LSB of long product
.019503	29 01		and #$01			and 	#1
.019505	18		clc				clc 								; clear carry for the long rotate.
.019506	f0 1d		beq $019525			beq 	_FPM_NoAddition
.019508	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.019509	a5 1a		lda $1a				lda 	zLTemp1+0
.01950b	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.01950e	85 1a		sta $1a				sta 	zLTemp1+0
.019510	a5 1b		lda $1b				lda 	zLTemp1+1
.019512	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.019515	85 1b		sta $1b				sta 	zLTemp1+1
.019517	a5 1c		lda $1c				lda 	zLTemp1+2
.019519	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.01951c	85 1c		sta $1c				sta 	zLTemp1+2
.01951e	a5 1d		lda $1d				lda 	zLTemp1+3
.019520	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.019523	85 1d		sta $1d				sta 	zLTemp1+3
.019525					_FPM_NoAddition:
.019525	66 1d		ror $1d				ror 	3+zLTemp1
.019527	66 1c		ror $1c				ror 	2+zLTemp1
.019529	66 1b		ror $1b				ror 	1+zLTemp1
.01952b	66 1a		ror $1a				ror 	0+zLTemp1
.01952d	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.019530	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.019533	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.019536	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.019539	88		dey				dey
.01953a	d0 c4		bne $019500			bne 	_FPM_Loop 					; do this 32 times.
.01953c					FPM_CopySignNormalize:
.01953c	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.01953e	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.019541	a5 1b		lda $1b				lda 	zLTemp1+1
.019543	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019546	a5 1c		lda $1c				lda 	zLTemp1+2
.019548	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01954b	a5 1d		lda $1d				lda 	zLTemp1+3
.01954d	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019550	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; sign is xor of signs
.019553	5d 13 03	eor $0313,x			eor 	XS2_Type,x
.019556	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019559	20 c4 96	jsr $0196c4			jsr 	FPUNormalise 				; normalise and exit.
.01955c	7a		ply				ply
.01955d	68		pla				pla
.01955e	60		rts				rts
.01955f					FPCalculateExponent:
.01955f	18		clc				clc
.019560	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.019563	7d 12 03	adc $0312,x			adc 	XS2_Exponent,x
.019566	b0 08		bcs $019570			bcs 	_FPCECarry 					; carry out ?
.019568	10 03		bpl $01956d			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.01956a	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.01956c	60		rts				rts
.01956d					_FPCEExpZero:
.01956d	a9 00		lda #$00			lda 	#0
.01956f	60		rts				rts
.019570					_FPCECarry:
.019570	30 03		bmi $019575			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.019572	09 80		ora #$80			ora 	#$80 						; put in right range
.019574	60		rts				rts
.019575					_FPCEOverflow:
.019575	4c 39 97	jmp $019739			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.019578					FPFractionalPart:
.019578	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.01957b	38		sec				sec 								; this flag tells us to keep the fractional part
.01957c	30 0f		bmi $01958d			bmi 	FPGetPart
.01957e	60		rts				rts
.01957f					FPIntegerPart:
.01957f	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.019582	18		clc				clc 								; this flag says keep the integer part.
.019583	30 08		bmi $01958d			bmi 	FPGetPart 					; -ve exponents are 0..127
.019585	48		pha				pha
.019586	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.019588	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.01958b	68		pla				pla
.01958c	60		rts				rts
.01958d					FPGetPart:
.01958d	48		pha				pha
.01958e	5a		phy				phy 								; save Y
.01958f	08		php				php 								; save action
.019590	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.019593	70 62		bvs $0195f7			bvs 	_FPGP_Exit 					; then do nothing.
.019595	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.019597	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.019599	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.01959b	85 1c		sta $1c				sta 	zLTemp1+2
.01959d	85 1d		sta $1d				sta 	zLTemp1+3
.01959f	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x				; the number of shifts.
.0195a2	38		sec				sec
.0195a3	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.0195a5	f0 12		beq $0195b9			beq 	_FPGP_NoShift 				; ... if any
.0195a7	c9 20		cmp #$20			cmp 	#32
.0195a9	90 02		bcc $0195ad			bcc 	_FPGP_NotMax
.0195ab	a9 20		lda #$20			lda 	#32 						; max of 32.
.0195ad					_FPGP_NotMax:
.0195ad	a8		tay				tay 								; Y is the mask shift count.
.0195ae					_FPGP_ShiftMask:
.0195ae	46 1d		lsr $1d				lsr 	3+zLTemp1
.0195b0	66 1c		ror $1c				ror 	2+zLTemp1
.0195b2	66 1b		ror $1b				ror 	1+zLTemp1
.0195b4	66 1a		ror $1a				ror 	0+zLTemp1
.0195b6	88		dey				dey
.0195b7	d0 f5		bne $0195ae			bne 	_FPGP_ShiftMask
.0195b9					_FPGP_NoShift:
.0195b9	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.0195bb	8e 8c 04	stx $048c			stx 	ExpTemp						; save X
.0195be					_FPGP_MaskLoop:
.0195be	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.0195c1	28		plp				plp 								; if CC we keep the top part, so we
.0195c2	08		php				php		 							; flip the mask.
.0195c3	b0 02		bcs $0195c7			bcs		_FPGP_NoFlip
.0195c5	49 ff		eor #$ff			eor 	#$FF
.0195c7					_FPGP_NoFlip:
.0195c7	3d 08 03	and $0308,x			and 	XS_Mantissa,x 				; and into the mantissa.
.0195ca	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.0195cd	e8		inx				inx
.0195ce	c8		iny				iny
.0195cf	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.0195d1	d0 eb		bne $0195be			bne 	_FPGP_MaskLoop
.0195d3	ae 8c 04	ldx $048c			ldx 	ExpTemp						; restore X
.0195d6	28		plp				plp
.0195d7	08		php				php 								; get action flag on the stack
.0195d8	90 05		bcc $0195df			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.0195da	a9 00		lda #$00			lda 	#0
.0195dc	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0195df					_FPGP_NotFractional:
.0195df	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 						; check if \1 zero
.0195e2	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.0195e5	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.0195e8	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.0195eb	f0 05		beq $0195f2			beq 	_FPGP_Zero 					; if zero, return zero
.0195ed	20 c4 96	jsr $0196c4			jsr 	FPUNormalise
.0195f0	80 05		bra $0195f7			bra 	_FPGP_Exit 					; and exit
.0195f2					_FPGP_Zero:
.0195f2	a9 40		lda #$40			lda 	#$40 						; set zero flag
.0195f4	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0195f7					_FPGP_Exit:
.0195f7	68		pla				pla 								; throw saved action flag.
.0195f8	7a		ply				ply
.0195f9	68		pla				pla
.0195fa	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.0195fb					FPCompare:
.0195fb	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.0195fe	48		pha				pha
.0195ff	bd 12 03	lda $0312,x			lda 	XS2_Exponent,x
.019602	48		pha				pha
.019603	20 65 93	jsr $019365			jsr 	FPSubtract 					; calculate X1-X2
.019606	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.019609	70 2c		bvs $019637			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.01960b	68		pla				pla
.01960c	8d 8c 04	sta $048c			sta 	ExpTemp						; save first exponent in temporary reg.
.01960f	68		pla				pla
.019610	38		sec				sec
.019611	ed 8c 04	sbc $048c			sbc 	ExpTemp 					; calculate AX-BX
.019614	70 15		bvs $01962b			bvs 	_FPCNotEqual				; overflow, can't be equal.
.019616	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.019617	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.019619	b0 10		bcs $01962b			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.01961b	38		sec				sec
.01961c	ad 8c 04	lda $048c			lda 	ExpTemp 					; get one of the exponents back.
.01961f	e9 12		sbc #$12			sbc 	#18 						; allow for 2^18 error, relatively.
.019621	b0 02		bcs $019625			bcs 	_FPCNotRange 				; keep in range.
.019623	a9 01		lda #$01			lda 	#1
.019625					_FPCNotRange:
.019625	38		sec				sec
.019626	fd 0c 03	sbc $030c,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.019629	b0 0e		bcs $019639			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.01962b					_FPCNotEqual:
.01962b	bd 0d 03	lda $030d,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.01962e	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.019630	f0 02		beq $019634			beq 	_FPCNE2
.019632	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.019634	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.019635	80 04		bra $01963b			bra 	_FPCExit
.019637					_FPCPullZero:
.019637	68		pla				pla 								; throw saved exponents
.019638	68		pla				pla
.019639					_FPCZero:
.019639	a9 00		lda #$00			lda 	#0 							; and return zero
.01963b					_FPCExit:
.01963b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.01963c					FPUCopyX2ToX1:
.01963c	48		pha				pha
.01963d	da		phx				phx
.01963e	5a		phy				phy
.01963f	a0 08		ldy #$08			ldy 	#8
.019641	bd 0e 03	lda $030e,x	_FPUC21:lda 	XS2_Mantissa,x
.019644	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.019647	e8		inx				inx
.019648	88		dey				dey
.019649	10 f6		bpl $019641			bpl 	_FPUC21
.01964b	7a		ply				ply
.01964c	fa		plx				plx
.01964d	68		pla				pla
.01964e	60		rts				rts
.01964f					FPUSetInteger:
.01964f	48		pha				pha
.019650	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.019653	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.019655	10 02		bpl $019659			bpl 	_FPUSIExtend
.019657	a9 ff		lda #$ff			lda 	#$FF
.019659					_FPUSIExtend:
.019659	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.01965c	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01965f	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019662	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.019664	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019667	68		pla				pla
.019668	60		rts				rts
.019669					FPUNegateInteger:
.019669	48		pha				pha
.01966a	38		sec				sec
.01966b	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.01966d	fd 08 03	sbc $0308,x			sbc 	XS_Mantissa+0,x
.019670	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019673	a9 00		lda #$00			lda 	#0
.019675	fd 09 03	sbc $0309,x			sbc 	XS_Mantissa+1,x
.019678	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.01967b	a9 00		lda #$00			lda 	#0
.01967d	fd 0a 03	sbc $030a,x			sbc 	XS_Mantissa+2,x
.019680	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019683	a9 00		lda #$00			lda 	#0
.019685	fd 0b 03	sbc $030b,x			sbc 	XS_Mantissa+3,x
.019688	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.01968b	68		pla				pla
.01968c	60		rts				rts
.01968d					FPUToFloat:
.01968d	48		pha				pha
.01968e	bd 0d 03	lda $030d,x			lda 	XS_Type,x					; exit if already float.
.019691	29 0f		and #$0f			and 	#$0F
.019693	f0 2d		beq $0196c2			beq 	_FPUFExit
.019695	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.019697	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.01969a	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.01969c	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x 				; x mantissa.
.01969f	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.0196a2	10 08		bpl $0196ac			bpl		_FPUFPositive
.0196a4	20 69 96	jsr $019669			jsr 	FPUNegateInteger 			; negate the mantissa
.0196a7	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.0196a9	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0196ac					_FPUFPositive:
.0196ac	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.0196af	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.0196b2	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.0196b5	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.0196b8	d0 05		bne $0196bf			bne 	_FPUFNonZero
.0196ba	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.0196bc	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0196bf					_FPUFNonZero:
.0196bf	20 c4 96	jsr $0196c4			jsr 	FPUNormalise 				; normalise the floating point.
.0196c2					_FPUFExit:
.0196c2	68		pla				pla
.0196c3	60		rts				rts
.0196c4					FPUNormalise:
.0196c4	48		pha				pha
.0196c5	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.0196c8	70 20		bvs $0196ea			bvs 	_FPUNExit
.0196ca	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.0196cd	f0 16		beq $0196e5			beq 	_FPUNSetZero
.0196cf					_FPUNLoop:
.0196cf	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.0196d2	30 16		bmi $0196ea			bmi 	_FPUNExit 					; if so, we are normalised.
.0196d4	1e 08 03	asl $0308,x			asl 	0+XS_Mantissa+0,x
.0196d7	3e 09 03	rol $0309,x			rol 	1+XS_Mantissa+0,x
.0196da	3e 0a 03	rol $030a,x			rol 	2+XS_Mantissa+0,x
.0196dd	3e 0b 03	rol $030b,x			rol 	3+XS_Mantissa+0,x
.0196e0	de 0c 03	dec $030c,x			dec 	XS_Exponent,x 				; decrement exponent
.0196e3	d0 ea		bne $0196cf			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.0196e5					_FPUNSetZero:
.0196e5	a9 40		lda #$40			lda 	#$40
.0196e7	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; the result is now zero.
.0196ea					_FPUNExit:
.0196ea	68		pla				pla
.0196eb	60		rts				rts
.0196ec					FPUToInteger:
.0196ec	48		pha				pha
.0196ed	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; if already integer, exit
.0196f0	29 01		and #$01			and 	#1
.0196f2	d0 3e		bne $019732			bne 	_FPUTOI_Exit
.0196f4	3c 0d 03	bit $030d,x			bit 	XS_Type,x					; if zero, return zero.
.0196f7	70 2b		bvs $019724			bvs 	_FPUTOI_Zero
.0196f9	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.0196fc	10 26		bpl $019724			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.0196fe	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.019700	b0 37		bcs $019739			bcs 	FP_Overflow
.019702					_FPUToIToInteger:
.019702	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.019705	c9 a0		cmp #$a0			cmp 	#128+32
.019707	f0 11		beq $01971a			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.019709	fe 0c 03	inc $030c,x			inc 	XS_Exponent,X 				; increment Exponent
.01970c	5e 0b 03	lsr $030b,x			lsr 	3+XS_Mantissa,x
.01970f	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.019712	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.019715	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.019718	80 e8		bra $019702			bra 	_FPUToIToInteger 			; keep going.
.01971a					_FPUToICheckSign:
.01971a	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; check sign
.01971d	10 13		bpl $019732			bpl 	_FPUToI_Exit 				; exit if unsigned.
.01971f	20 69 96	jsr $019669			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.019722	80 0e		bra $019732			bra 	_FPUTOI_Exit
.019724					_FPUTOI_Zero:
.019724	a9 00		lda #$00			lda 	#0 							; return zero integer.
.019726	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019729	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.01972c	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01972f	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019732					_FPUToI_Exit:
.019732	a9 01		lda #$01			lda 	#1 							; set type to integer
.019734	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019737	68		pla				pla
.019738	60		rts				rts
.019739					FP_Overflow:
.019739	20 26 82	jsr $018226			jsr ERR_Handler
>01973c	46 6c 6f 61 74 69 6e 67			.text "Floating Point overflow",0
>019744	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.019754					FPUTimes10:
.019754	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.019757	85 1a		sta $1a				sta 	ZLTemp1+0
.019759	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.01975c	85 1b		sta $1b				sta 	ZLTemp1+1
.01975e	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.019761	85 1c		sta $1c				sta 	ZLTemp1+2
.019763	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.019766	85 1d		sta $1d				sta 	ZLTemp1+3
.019768	20 ac 97	jsr $0197ac			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.01976b	20 ac 97	jsr $0197ac			jsr 	_FPUT_LSR_ZLTemp1
.01976e	18		clc				clc
.01976f	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.019772	65 1a		adc $1a				adc 	ZLTemp1+0
.019774	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019777	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.01977a	65 1b		adc $1b				adc 	ZLTemp1+1
.01977c	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.01977f	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.019782	65 1c		adc $1c				adc 	ZLTemp1+2
.019784	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019787	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.01978a	65 1d		adc $1d				adc 	ZLTemp1+3
.01978c	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.01978f	90 0f		bcc $0197a0			bcc 	_FPUTimes10
.019791	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.019794	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.019797	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.01979a	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.01979d	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x				; fix exponent
.0197a0					_FPUTimes10:
.0197a0	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.0197a3	18		clc				clc
.0197a4	69 03		adc #$03			adc 	#3
.0197a6	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.0197a9	b0 8e		bcs $019739			bcs 	FP_Overflow 				; error
.0197ab	60		rts				rts
.0197ac					_FPUT_LSR_ZLTemp1:
.0197ac	46 1d		lsr $1d				lsr 	ZLTemp1+3
.0197ae	66 1c		ror $1c				ror 	ZLTemp1+2
.0197b0	66 1b		ror $1b				ror 	ZLTemp1+1
.0197b2	66 1a		ror $1a				ror 	ZLTemp1+0
.0197b4	60		rts				rts
.0197b5					FPUScale10A:
.0197b5	5a		phy				phy
.0197b6	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.0197b8	f0 3d		beq $0197f7			beq 	_FPUScaleExit
.0197ba	da		phx				phx 								; save X
.0197bb	e8		inx				inx
.0197bc	e8		inx				inx
.0197bd	e8		inx				inx
.0197be	e8		inx				inx
.0197bf	e8		inx				inx
.0197c0	e8		inx				inx
.0197c1	a8		tay				tay 								; save power scalar in Y.
.0197c2	a9 00		lda #$00			lda 	#0
.0197c4	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.0197c7	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0197ca	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0197cd	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0197d0	a9 80		lda #$80			lda 	#$80
.0197d2	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0197d5	a9 81		lda #$81			lda 	#$81
.0197d7	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.0197da	5a		phy				phy 								; save 10^n on stack.
.0197db	c0 00		cpy #$00			cpy 	#0
.0197dd	10 05		bpl $0197e4			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.0197df	98		tya				tya
.0197e0	49 ff		eor #$ff			eor 	#$FF
.0197e2	1a		inc a				inc 	a
.0197e3	a8		tay				tay
.0197e4					_FPUSAbs:
.0197e4	20 54 97	jsr $019754			jsr 	FPUTimes10
.0197e7	88		dey				dey
.0197e8	d0 fa		bne $0197e4			bne 	_FPUSAbs 					; tos is now 10^|AC|
.0197ea	68		pla				pla 								; restore count in A
.0197eb	fa		plx				plx 								; restore X pointing to number to scale.
.0197ec	0a		asl a				asl 	a
.0197ed	b0 05		bcs $0197f4			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.0197ef	20 db 94	jsr $0194db			jsr 	FPMultiply 					; if clear multiply.
.0197f2	80 03		bra $0197f7			bra		_FPUScaleExit
.0197f4					_FPUSDivide:
.0197f4	20 53 94	jsr $019453			jsr 	FPDivide
.0197f7					_FPUScaleExit:
.0197f7	7a		ply				ply
.0197f8	60		rts				rts
.0197f9					FPUCopyToNext:
.0197f9	a0 06		ldy #$06			ldy 		#6
.0197fb	da		phx				phx
.0197fc					_FPUCopy1:
.0197fc	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x
.0197ff	9d 0e 03	sta $030e,x			sta 	XS2_Mantissa,x
.019802	e8		inx				inx
.019803	88		dey				dey
.019804	d0 f6		bne $0197fc			bne 	_FPUCopy1
.019806	fa		plx				plx
.019807	60		rts				rts
.019808					FPUCopyFromNext:
.019808	a0 06		ldy #$06			ldy 		#6
.01980a	da		phx				phx
.01980b					_FPUCopy1:
.01980b	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa,x
.01980e	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.019811	e8		inx				inx
.019812	88		dey				dey
.019813	d0 f6		bne $01980b			bne 	_FPUCopy1
.019815	fa		plx				plx
.019816	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.019817					FPToString:
.019817	48		pha				pha
.019818	5a		phy				phy
.019819	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; check zero flag
.01981c	50 0a		bvc $019828			bvc 		_FPTSIsFloat 			; if zero,
.01981e					_FPTSZero:
.01981e	a9 30		lda #$30			lda 		#"0"
.019820	20 a7 92	jsr $0192a7			jsr 		ITSOutputCharacter
.019823					_FPTSExit:
.019823	7a		ply				ply
.019824	68		pla				pla
.019825	60		rts				rts
.019826	80 fb		bra $019823			bra 		_FPTSExit
.019828					_FPTSIsFloat:
.019828	bd 0d 03	lda $030d,x			lda 		XS_Type,x 				; is it signed ?
.01982b	10 0a		bpl $019837			bpl 		_FPTSNotSigned
.01982d	a9 00		lda #$00			lda 		#0 						; clear sign flag
.01982f	9d 0d 03	sta $030d,x			sta 		XS_Type,x
.019832	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.019834	20 a7 92	jsr $0192a7			jsr 		ITSOutputCharacter
.019837					_FPTSNotSigned:
.019837	bd 0c 03	lda $030c,x			lda 		XS_Exponent,x
.01983a	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.01983c	b0 09		bcs $019847			bcs 		_FPTSExponent
.01983e	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.019840	90 05		bcc $019847			bcc 		_FPTSExponent 			;
.019842					_FPTSStandard:
.019842	20 8b 98	jsr $01988b			jsr 		FPTOutputBody 			; output the body.
.019845	80 dc		bra $019823			bra 		_FPTSExit
.019847					_FPTSExponent:
.019847	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.019849	8d 8d 04	sta $048d			sta 		ExpCount
.01984c					_FPTSExponentLoop:
.01984c	bd 0c 03	lda $030c,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.01984f	10 0e		bpl $01985f			bpl 		_FPTSTimes
.019851	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.019853	90 14		bcc $019869			bcc 		_FPTSScaledToExp
.019855	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.019857	20 b5 97	jsr $0197b5			jsr 		FPUScale10A
.01985a	ee 8d 04	inc $048d			inc 		ExpCount
.01985d	80 ed		bra $01984c			bra 		_FPTSExponentLoop
.01985f					_FPTSTimes:
.01985f	a9 01		lda #$01			lda 		#1
.019861	20 b5 97	jsr $0197b5			jsr 		FPUScale10A
.019864	ce 8d 04	dec $048d			dec 		ExpCount
.019867	80 e3		bra $01984c			bra 		_FPTSExponentLoop
.019869					_FPTSScaledToExp:
.019869	20 8b 98	jsr $01988b			jsr 		FPTOutputBody 			; output the body.
.01986c	a9 65		lda #$65			lda 		#"e"					; output E
.01986e	20 a7 92	jsr $0192a7			jsr 		ITSOutputCharacter
.019871	ad 8d 04	lda $048d			lda 		ExpCount 				; get the exponent
.019874	9d 08 03	sta $0308,x			sta 		XS_Mantissa,x
.019877	29 80		and #$80			and 		#$80 					; sign extend it
.019879	f0 02		beq $01987d			beq 		_FPTSSExt
.01987b	a9 ff		lda #$ff			lda 		#$FF
.01987d					_FPTSSExt:
.01987d	9d 09 03	sta $0309,x			sta 		XS_Mantissa+1,x
.019880	9d 0a 03	sta $030a,x			sta 		XS_Mantissa+2,x
.019883	9d 0b 03	sta $030b,x			sta 		XS_Mantissa+3,x
.019886	20 03 92	jsr $019203			jsr 		INTToString 			; output the exponent.
.019889	80 98		bra $019823			bra			_FPTSExit 				; and exit.
.01988b					FPTOutputBody:
.01988b	20 f9 97	jsr $0197f9			jsr 		FPUCopyToNext 			; copy to next slot.
.01988e	20 ec 96	jsr $0196ec			jsr 		FPUToInteger 			; convert to an integer
.019891	20 03 92	jsr $019203			jsr 		INTToString 			; output the main integer part.
.019894	20 08 98	jsr $019808			jsr 		FPUCopyFromNext 		; get the fractional part back.
.019897	20 78 95	jsr $019578			jsr 		FPFractionalPart 		; get the decimal part.
.01989a	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; any fractional part.
.01989d	70 3e		bvs $0198dd			bvs 		_FPTOExit 				; if not, exit now.
.01989f	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.0198a1	20 a7 92	jsr $0192a7			jsr 		ITSOutputCharacter
.0198a4					_FPOutLoop:
.0198a4	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; finally reached zero.
.0198a7	70 1e		bvs $0198c7			bvs 		_FPStripZeros 			; strip trailing zeros
.0198a9	20 54 97	jsr $019754			jsr 		FPUTimes10 				; multiply by 10
.0198ac	20 f9 97	jsr $0197f9			jsr 		FPUCopyToNext			; copy to next slot.
.0198af	20 ec 96	jsr $0196ec			jsr 		FPUToInteger 			; convert to integer
.0198b2	bd 08 03	lda $0308,x			lda 		XS_Mantissa+0,x 		; print digit.
.0198b5	09 30		ora #$30			ora 		#"0"
.0198b7	20 a7 92	jsr $0192a7			jsr 		ITSOutputCharacter
.0198ba	20 08 98	jsr $019808			jsr 		FPUCopyFromNext 		; get it back
.0198bd	20 78 95	jsr $019578			jsr 		FPFractionalPart 		; get fractional part
.0198c0	ad 04 04	lda $0404			lda 		NumBufX 				; done 11 characters yet ?
.0198c3	c9 0b		cmp #$0b			cmp 	 	#11
.0198c5	90 dd		bcc $0198a4			bcc 		_FPOutLoop 				; if so, keep going till zero.
.0198c7					_FPStripZeros:
.0198c7	ac 04 04	ldy $0404			ldy 		NumBufX 				; strip trailing zeros.
.0198ca					_FPStripLoop:
.0198ca	88		dey				dey 								; back one, if at start then no strip
.0198cb	f0 10		beq $0198dd			beq 		_FPToExit
.0198cd	b9 05 04	lda $0405,y			lda 		Num_Buffer,y 			; keep going if "0"
.0198d0	c9 30		cmp #$30			cmp 		#"0"
.0198d2	f0 f6		beq $0198ca			beq 		_FPStripLoop
.0198d4	c8		iny				iny
.0198d5	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.0198d7	99 05 04	sta $0405,y			sta 		Num_Buffer,y
.0198da	8c 04 04	sty $0404			sty 		NumBufX 				; update position.
.0198dd					_FPTOExit:
.0198dd	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.0198de					FPFromString:
.0198de	48		pha				pha 								; push A
.0198df	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.0198e1	c9 2e		cmp #$2e			cmp 	#"."
.0198e3	f0 03		beq $0198e8			beq	 	_FPFIsDecimal
.0198e5	4c 4b 99	jmp $01994b			jmp 	_FPFNotDecimal
.0198e8					_FPFIsDecimal:
.0198e8	c8		iny				iny 								; consume the decimal.
.0198e9	20 8d 96	jsr $01968d			jsr 	FPUToFloat 					; convert the integer to float.
.0198ec	da		phx				phx 								; save X.
.0198ed	5a		phy				phy 								; save decimal start position
.0198ee	e8		inx				inx
.0198ef	e8		inx				inx
.0198f0	e8		inx				inx
.0198f1	e8		inx				inx
.0198f2	e8		inx				inx
.0198f3	e8		inx				inx
.0198f4	20 bf 92	jsr $0192bf			jsr 	INTFromStringY 				; get the part after the DP.
.0198f7	20 8d 96	jsr $01968d			jsr 	FPUToFloat 					; convert that to a float.
.0198fa	68		pla				pla 								; calculate - chars consumed.
.0198fb	8c 8c 04	sty $048c			sty 	ExpTemp
.0198fe	38		sec				sec
.0198ff	ed 8c 04	sbc $048c			sbc 	ExpTemp 					; this is the shift amount
.019902	20 b5 97	jsr $0197b5			jsr 	FPUScale10A 				; scale it by 10^AC
.019905	fa		plx				plx 								; restore original X
.019906	20 6f 93	jsr $01936f			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.019909	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.01990b	c9 45		cmp #$45			cmp 	#"E"
.01990d	f0 04		beq $019913			beq 	_FPFExponent
.01990f	c9 65		cmp #$65			cmp 	#"e"
.019911	d0 38		bne $01994b			bne 	_FPFNotDecimal 				; no, then exit normally.
.019913					_FPFExponent:
.019913	c8		iny				iny 								; skip over E symbol.
.019914	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.019916	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.019918	d0 01		bne $01991b			bne 	_FPFGotSign
.01991a	c8		iny				iny 								; if it was - skip over it.
.01991b					_FPFGotSign:
.01991b	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.01991c	da		phx				phx
.01991d	e8		inx				inx
.01991e	e8		inx				inx
.01991f	e8		inx				inx
.019920	e8		inx				inx
.019921	e8		inx				inx
.019922	e8		inx				inx
.019923	20 bf 92	jsr $0192bf			jsr 	INTFromStringY 				; get the exponent
.019926	fa		plx				plx 								; restore X.
.019927	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.01992a	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.01992d	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.019930	d0 1b		bne $01994d			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.019932	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.019935	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.019937	b0 14		bcs $01994d			bcs 	_FPFXOverflow
.019939	68		pla				pla 								; get direction
.01993a	d0 09		bne $019945			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.01993c	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.01993f	49 ff		eor #$ff			eor 	#$FF
.019941	1a		inc a				inc 	a
.019942	9d 0e 03	sta $030e,x			sta 	XS2_Mantissa+0,x
.019945					_FPFXScale:
.019945	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.019948	20 b5 97	jsr $0197b5			jsr 	FPUScale10A 				; scale by the exponent.
.01994b					_FPFNotDecimal:
.01994b	68		pla				pla
.01994c	60		rts				rts
.01994d					_FPFXOverflow:
.01994d	20 26 82	jsr $018226			jsr 	ERR_Handler
>019950	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>019958	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.01995f					Unary_Rnd:
.01995f	20 b3 87	jsr $0187b3			jsr 	EvaluateNumberX 			; get value
.019962	20 42 8e	jsr $018e42			jsr 	CheckNextRParen 			; check right bracket.
.019965	20 a0 8a	jsr $018aa0			jsr 	GetSignCurrent 				; get sign -1,0,1.
.019968	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.01996a	30 10		bmi $01997c			bmi 	_URSetSeed
.01996c	f0 2c		beq $01999a			beq 	_URMakeRandom 				; if zero return same number.
.01996e	da		phx				phx
.01996f	a2 00		ldx #$00			ldx 	#0
.019971	20 d7 99	jsr $0199d7			jsr 	Random16
.019974	a2 02		ldx #$02			ldx 	#2
.019976	20 d7 99	jsr $0199d7			jsr 	Random16
.019979	fa		plx				plx
.01997a	80 1e		bra $01999a			bra 	_URMakeRandom
.01997c					_URSetSeed:
.01997c	20 8d 96	jsr $01968d			jsr 	FPUToFloat 					; make it a float to twiddle it.
.01997f	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.019982	8d 93 04	sta $0493			sta 	RandomSeed+0
.019985	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.019988	8d 94 04	sta $0494			sta 	RandomSeed+1
.01998b	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.01998e	8d 95 04	sta $0495			sta 	RandomSeed+2
.019991	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.019994	0a		asl a				asl 	a
.019995	49 db		eor #$db			eor 	#$DB
.019997	8d 96 04	sta $0496			sta 	RandomSeed+3
.01999a					_URMakeRandom:
.01999a	ad 93 04	lda $0493			lda 	RandomSeed+0 				; check if seed is zero.
.01999d	0d 94 04	ora $0494			ora 	RandomSeed+1
.0199a0	0d 95 04	ora $0495			ora 	RandomSeed+2
.0199a3	0d 96 04	ora $0496			ora 	RandomSeed+3
.0199a6	d0 0a		bne $0199b2			bne 	_URNotZero
.0199a8	a9 47		lda #$47			lda 	#$47
.0199aa	8d 94 04	sta $0494			sta 	RandomSeed+1				; if it is, make it non zero.
.0199ad	a9 3d		lda #$3d			lda 	#$3D
.0199af	8d 96 04	sta $0496			sta 	RandomSeed+3
.0199b2					_URNotZero:
.0199b2	ad 93 04	lda $0493			lda 	RandomSeed+0 				; copy seed into mantissa.
.0199b5	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0199b8	ad 94 04	lda $0494			lda 	RandomSeed+1
.0199bb	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0199be	ad 95 04	lda $0495			lda 	RandomSeed+2
.0199c1	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0199c4	ad 96 04	lda $0496			lda 	RandomSeed+3
.0199c7	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0199ca	a9 00		lda #$00			lda 	#$00 						; set type to float.
.0199cc	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0199cf	a9 80		lda #$80			lda 	#$80
.0199d1	9d 0c 03	sta $030c,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.0199d4	4c c4 96	jmp $0196c4			jmp 	FPUNormalise
.0199d7					Random16:
.0199d7	5e 94 04	lsr $0494,x			lsr 	RandomSeed+1,x				; shift seed right
.0199da	7e 93 04	ror $0493,x			ror 	RandomSeed,x
.0199dd	90 08		bcc $0199e7			bcc 	_R16_NoXor
.0199df	bd 94 04	lda $0494,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.0199e2	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.0199e4	9d 94 04	sta $0494,x			sta 	RandomSeed+1,x
.0199e7					_R16_NoXor:
.0199e7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.0199e8					Unary_Int:
.0199e8	20 b3 87	jsr $0187b3			jsr 	EvaluateNumberX 			; get value
.0199eb	20 42 8e	jsr $018e42			jsr 	CheckNextRParen 			; check right bracket.
.0199ee	4c ec 96	jmp $0196ec			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.0199f1					TIM_Error:
.0199f1	20 29 80	jsr $018029			jsr 	IFT_UpLine 					; go up one line.
.0199f4	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.0199f6	80 02		bra $0199fa			bra 	TIM_ShowPrompt
.0199f8					TIM_NewCommand:
.0199f8	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.0199fa					TIM_ShowPrompt:
.0199fa	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.0199fd	20 fa 80	jsr $0180fa			jsr 	IFT_ReadLine	 			; get character, go to next line
.019a00	20 5c 80	jsr $01805c			jsr 	IFT_NewLine					; go to next line.
.019a03	86 10		stx $10				stx 	zTemp1 						; save line read address
.019a05	84 11		sty $11				sty 	zTemp1+1
.019a07	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.019a09	b1 10		lda ($10),y			lda 	(zTemp1),y
.019a0b	c9 3f		cmp #$3f			cmp 	#"?"
.019a0d	f0 04		beq $019a13			beq 	TIM_SkipFirst
.019a0f	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.019a11	d0 01		bne $019a14			bne 	TIM_NotDot
.019a13					TIM_SkipFirst:
.019a13	c8		iny				iny
.019a14					TIM_NotDot:
.019a14	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.019a16	c9 52		cmp #$52			cmp 	#"R"						; show registers
.019a18	f0 6b		beq $019a85			beq 	TIM_ShowRegisters
.019a1a	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.019a1c	f0 12		beq $019a30			beq 	TIM_ShowMemory
.019a1e	c9 47		cmp #$47			cmp 	#"G"						; execute
.019a20	f0 49		beq $019a6b			beq 	TIM_Execute
.019a22	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.019a24	f0 07		beq $019a2d			beq 	TIM_GoLoadMemory
.019a26	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.019a28	d0 c7		bne $0199f1			bne 	TIM_Error
.019a2a	4c a9 9b	jmp $019ba9			jmp 	TIM_UpdateRegisters
.019a2d					TIM_GoLoadMemory:
.019a2d	4c d9 9b	jmp $019bd9			jmp 	TIM_LoadMemory
.019a30					TIM_ShowMemory:
.019a30	20 25 9b	jsr $019b25			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.019a33	b0 bc		bcs $0199f1			bcs 	TIM_Error
.019a35	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.019a37	85 12		sta $12				sta 	zTemp2
.019a39	a5 15		lda $15				lda 	zTemp3+1
.019a3b	85 13		sta $13				sta 	zTemp2+1
.019a3d	20 25 9b	jsr $019b25			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.019a40	90 08		bcc $019a4a			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.019a42	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.019a44	85 14		sta $14				sta 	zTemp3
.019a46	a5 13		lda $13				lda 	zTemp2+1
.019a48	85 15		sta $15				sta 	zTemp3+1
.019a4a					_TIMSM_Start:
.019a4a	20 fd 9a	jsr $019afd			jsr 	TIM_WriteLine 				; write one line of hex out
.019a4d	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.019a4f	18		clc				clc
.019a50	69 10		adc #$10			adc 	#16
.019a52	85 12		sta $12				sta 	zTemp2
.019a54	90 02		bcc $019a58			bcc 	_TIMSM_NoCarry
.019a56	e6 13		inc $13				inc 	zTemp2+1
.019a58					_TIMSM_NoCarry:
.019a58	20 e1 81	jsr $0181e1			jsr 	IF_CheckBreak 				; check CTL+C
.019a5b	d0 0b		bne $019a68			bne 	_TIMSM_Ends 				; if pressed break out.
.019a5d	38		sec				sec 								; check past the end address in zTemp3
.019a5e	a5 14		lda $14				lda 	zTemp3
.019a60	e5 12		sbc $12				sbc 	zTemp2
.019a62	a5 15		lda $15				lda 	zTemp3+1
.019a64	e5 13		sbc $13				sbc 	zTemp2+1
.019a66	10 e2		bpl $019a4a			bpl 	_TIMSM_Start
.019a68					_TIMSM_Ends:
.019a68	4c f8 99	jmp $0199f8			jmp 	TIM_NewCommand
.019a6b					TIM_Execute:
.019a6b	20 25 9b	jsr $019b25			jsr 	TIM_GetHex 					; get the execute address
.019a6e	b0 81		bcs $0199f1			bcs 	TIM_Error 					; not legitimate
.019a70	ae a0 04	ldx $04a0			ldx 	TIM_SP 						; set up SP
.019a73	9a		txs				txs
.019a74	ad 9b 04	lda $049b			lda 	TIM_SR 						; Status for PLP
.019a77	48		pha				pha
.019a78	ad 9c 04	lda $049c			lda 	TIM_A 						; restore AXYZ
.019a7b	ae 9d 04	ldx $049d			ldx 	TIM_X
.019a7e	ac 9e 04	ldy $049e			ldy 	TIM_Y
.019a81	28		plp				plp 								; and PS Byte.
.019a82	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.019a85					TIM_Start:
.019a85					TIM_ShowRegisters:
.019a85	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.019a88	8d 9a 04	sta $049a			sta 	TIM_IRQ+1
.019a8b	ad ff ff	lda $ffff			lda 	$FFFF
.019a8e	8d 99 04	sta $0499			sta 	TIM_IRQ
.019a91	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.019a93					_TIMSR_Text:
.019a93	bf c4 9a 01	lda $019ac4,x			lda 	_TIMSR_Label,x
.019a97	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.019a9a	e8		inx				inx
.019a9b	e0 20		cpx #$20			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.019a9d	d0 f4		bne $019a93			bne 	_TIMSR_Text
.019a9f	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.019aa1					_TIMSR_Skip:
.019aa1	e8		inx				inx
.019aa2					_TIMSR_LoopSpace:
.019aa2	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.019aa4	b0 04		bcs $019aaa			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.019aa6	8a		txa				txa
.019aa7	4a		lsr a				lsr 	a
.019aa8	b0 05		bcs $019aaf			bcs 	_TIMSR_NoSpace
.019aaa					_TIMSR_Space:
.019aaa	a9 20		lda #$20			lda 	#" "
.019aac	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.019aaf					_TIMSR_NoSpace:
.019aaf	bd 97 04	lda $0497,x			lda 	TIM_PC,x 					; output hex value.
.019ab2	20 e4 9a	jsr $019ae4			jsr 	TIM_WriteHex
.019ab5	e8		inx				inx
.019ab6	e0 08		cpx #$08			cpx 	#TIM_Z-TIM_PC
.019ab8	f0 e7		beq $019aa1			beq 	_TIMSR_Skip
.019aba	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.019abc	d0 e4		bne $019aa2			bne 	_TimSR_LoopSpace
.019abe	20 5c 80	jsr $01805c			jsr 	IFT_NewLine 				; new line
.019ac1	4c f8 99	jmp $0199f8			jmp	 	TIM_NewCommand 				; new command.
.019ac4					_TIMSR_Label:
>019ac4	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>019acc	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>019adc	52
>019add	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.019ae4					_TIMSR_LabelEnd:
.019ae4					TIM_WriteHex:
.019ae4	48		pha				pha 								; save A
.019ae5	4a		lsr a				lsr 	a 							; shift MSB->LSB
.019ae6	4a		lsr a				lsr 	a
.019ae7	4a		lsr a				lsr 	a
.019ae8	4a		lsr a				lsr 	a
.019ae9	20 ed 9a	jsr $019aed			jsr 	_TIMWH_Nibble 				; print MSB
.019aec	68		pla				pla 								; restore and print LSB
.019aed					_TIMWH_Nibble:
.019aed	48		pha				pha
.019aee	29 0f		and #$0f			and 	#15 						; mask out
.019af0	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.019af2	90 02		bcc $019af6			bcc 	_TIMWHNoLetter
.019af4	69 06		adc #$06			adc 	#6
.019af6					_TIMWHNoLetter:
.019af6	69 30		adc #$30			adc 	#48
.019af8	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter 			; print it out.
.019afb	68		pla				pla
.019afc	60		rts				rts
.019afd					TIM_WriteLine:
.019afd	a9 2e		lda #$2e			lda 	#"." 						; prompt
.019aff	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.019b02	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.019b04	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.019b07	a5 13		lda $13				lda 	zTemp2+1 					; write address
.019b09	20 e4 9a	jsr $019ae4			jsr 	TIM_WriteHex
.019b0c	a5 12		lda $12				lda 	zTemp2
.019b0e	20 e4 9a	jsr $019ae4			jsr 	TIM_WriteHex
.019b11	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.019b13					_TIMWL_Loop:
.019b13	a9 20		lda #$20			lda 	#" "
.019b15	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.019b18	b1 12		lda ($12),y			lda 	(zTemp2),y
.019b1a	20 e4 9a	jsr $019ae4			jsr 	TIM_WriteHex
.019b1d	c8		iny				iny
.019b1e	c0 10		cpy #$10			cpy 	#16
.019b20	d0 f1		bne $019b13			bne 	_TIMWL_Loop
.019b22	4c 5c 80	jmp $01805c			jmp 	IFT_NewLine 				; new line and exit
.019b25					TIM_GetHex:
.019b25	c8		iny				iny
.019b26	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.019b28	c9 20		cmp #$20			cmp 	#32
.019b2a	f0 f9		beq $019b25			beq 	TIM_GetHex
.019b2c	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.019b2e	f0 f5		beq $019b25			beq 	TIM_GetHex
.019b30	20 59 9b	jsr $019b59			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.019b33	b0 23		bcs $019b58			bcs 	_TIMGH_Exit					; if first bad then exit now.
.019b35	a9 00		lda #$00			lda 	#0 							; zero result
.019b37	85 14		sta $14				sta 	zTemp3
.019b39	85 15		sta $15				sta 	zTemp3+1
.019b3b					_TIM_GHLoop:
.019b3b	20 59 9b	jsr $019b59			jsr 	TIM_GetHexCharacter 		; get next character
.019b3e	b0 17		bcs $019b57			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.019b40	c8		iny				iny 								; skip over it.
.019b41	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.019b43	26 15		rol $15				rol 	zTemp3+1
.019b45	06 14		asl $14				asl 	zTemp3 						; now x 2
.019b47	26 15		rol $15				rol 	zTemp3+1
.019b49	06 14		asl $14				asl 	zTemp3						; now x 4
.019b4b	26 15		rol $15				rol 	zTemp3+1
.019b4d	06 14		asl $14				asl 	zTemp3 						; now x 8
.019b4f	26 15		rol $15				rol 	zTemp3+1
.019b51	05 14		ora $14				ora 	zTemp3 						; OR result in
.019b53	85 14		sta $14				sta 	zTemp3
.019b55	80 e4		bra $019b3b			bra 	_TIM_GHLoop 				; loop round again.
.019b57					_TIMGH_Okay:
.019b57	18		clc				clc
.019b58					_TIMGH_Exit:
.019b58	60		rts				rts
.019b59					TIM_GetHexCharacter:
.019b59	b1 10		lda ($10),y			lda 	(zTemp1),y
.019b5b	38		sec				sec
.019b5c	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.019b5e	90 0e		bcc $019b6e			bcc 	_TIM_GHCFail
.019b60	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.019b62	90 0b		bcc $019b6f			bcc 	_TIM_GHCExit
.019b64	c9 11		cmp #$11			cmp 	#65-48						; < A
.019b66	90 06		bcc $019b6e			bcc		_TIM_GHCFail
.019b68	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.019b6a	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.019b6c	90 01		bcc $019b6f			bcc		_TIM_GHCExit
.019b6e					_TIM_GHCFail:
.019b6e	38		sec				sec
.019b6f					_TIM_GHCExit:
.019b6f	60		rts				rts
.019b70					TIM_BreakVector:
.019b70	da		phx				phx									; save X/A on stack
.019b71	48		pha				pha
.019b72	ba		tsx				tsx 								; X points to S
.019b73	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.019b76	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.019b78	d0 03		bne $019b7d			bne 	_TIMBreak					; if set, it's BRK
.019b7a	68		pla				pla 								; abandon routine.
.019b7b	fa		plx				plx
.019b7c	40		rti				rti
.019b7d					_TIMBreak:
.019b7d	68		pla				pla 								; save A X Y and maybe Z
.019b7e	8d 9c 04	sta $049c			sta 	TIM_A
.019b81	fa		plx				plx
.019b82	8e 9d 04	stx $049d			stx 	TIM_X
.019b85	8c 9e 04	sty $049e			sty 	TIM_Y
.019b88	68		pla				pla 								; get Status Register
.019b89	8d 9b 04	sta $049b			sta 	TIM_SR
.019b8c	68		pla				pla
.019b8d	8d 98 04	sta $0498			sta 	TIM_PC+1 					; save calling address
.019b90	68		pla				pla
.019b91	8d 97 04	sta $0497			sta 	TIM_PC 						; high byte
.019b94	ad 98 04	lda $0498			lda 	TIM_PC+1 					; dec PC to point right.
.019b97	d0 03		bne $019b9c			bne 	_TIMDecrement 				; brk bumps it.
.019b99	ce 97 04	dec $0497			dec 	TIM_PC
.019b9c					_TIMDecrement:
.019b9c	ce 98 04	dec $0498			dec 	TIM_PC+1
.019b9f	ba		tsx				tsx 								; and copy SP
.019ba0	8e a0 04	stx $04a0			stx 	TIM_SP
.019ba3	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.019ba5	9a		txs				txs
.019ba6	4c 85 9a	jmp $019a85			jmp 	TIM_Start 					; and start up TIM monitor.
.019ba9					TIM_UpdateRegisters:
.019ba9	20 25 9b	jsr $019b25			jsr 	TIM_GetHex 					; PC
.019bac	b0 28		bcs $019bd6			bcs 	_TIMURFail
.019bae	a5 14		lda $14				lda 	zTemp3
.019bb0	8d 98 04	sta $0498			sta 	Tim_PC+1
.019bb3	a5 15		lda $15				lda 	zTemp3+1
.019bb5	8d 97 04	sta $0497			sta 	Tim_PC
.019bb8	20 25 9b	jsr $019b25			jsr 	TIM_GetHex 					; ignore IRQ
.019bbb	b0 19		bcs $019bd6			bcs 	_TIMURFail
.019bbd	a2 00		ldx #$00			ldx 	#0
.019bbf					_TIM_URLoop:
.019bbf	e0 04		cpx #$04			cpx 	#Tim_Z-Tim_SR
.019bc1	d0 01		bne $019bc4			bne 	_TIM_1
.019bc3	e8		inx				inx
.019bc4					_TIM_1:
.019bc4	20 25 9b	jsr $019b25			jsr 	TIM_GetHex 					; registers
.019bc7	b0 0d		bcs $019bd6			bcs 	_TIMURFail
.019bc9	a5 14		lda $14				lda 	zTemp3
.019bcb	9d 9b 04	sta $049b,x			sta 	Tim_SR,x
.019bce	e8		inx				inx
.019bcf	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.019bd1	d0 ec		bne $019bbf			bne 	_TIM_URLoop
.019bd3	4c f8 99	jmp $0199f8			jmp 	TIM_NewCommand
.019bd6					_TIMURFail:
.019bd6	4c f1 99	jmp $0199f1			jmp 	TIM_Error
.019bd9					TIM_LoadMemory:
.019bd9	20 25 9b	jsr $019b25			jsr 	TIM_GetHex 					; target address => zTemp2
.019bdc	a5 14		lda $14				lda 	zTemp3
.019bde	85 12		sta $12				sta 	zTemp2
.019be0	a5 15		lda $15				lda 	zTemp3+1
.019be2	85 13		sta $13				sta 	zTemp2+1
.019be4					_TIM_LMLoop:
.019be4	20 25 9b	jsr $019b25			jsr 	TIM_GetHex 					; next byte ?
.019be7	b0 0e		bcs $019bf7			bcs 	_TIMLMDone 					; no more
.019be9	a2 00		ldx #$00			ldx 	#0							; write out.
.019beb	a5 14		lda $14				lda 	zTemp3
.019bed	81 12		sta ($12,x)			sta 	(zTemp2,x)
.019bef	e6 12		inc $12				inc 	zTemp2 						; bump address
.019bf1	d0 f1		bne $019be4			bne 	_TIM_LMLoop
.019bf3	e6 13		inc $13				inc 	zTemp2+1
.019bf5	80 ed		bra $019be4			bra 	_TIM_LMLoop
.019bf7					_TIMLMDone:
.019bf7	4c f8 99	jmp $0199f8			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Return to file: basic.asm

>019bfa	02						.byte 	2
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 c0						.word 	StartROM
>fffe	19 c0					.word TIM_BreakHandler

;******  End of listing
