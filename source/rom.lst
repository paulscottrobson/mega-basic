
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -Wall -b -q -L rom.lst -o rom.bin basic.asm
; Sat Sep  7 17:09:18 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="65816"				cpu = "65816"
="em65816"				hardware = "em65816"
=1					exitonend = 1
=0					autorun = 0
=1					loadtest = 1
=0					loadrun = 0
=1					hasfloat = 1
=1					hasinteger = 1
=253					maxstring = 253

;******  Processing file: modules/basic/pointer/em65816/src_em65816.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stackmarkers.inc

=5					SourcePosSize   =   5 							; Source position stack space needed.
=1					SMark_Gosub 	= 	1 							; 0 is GOSUB/RETURN.
=2					SMark_Repeat 	= 	2 							; 1 is REPEAT/UNTIL.
=3					SMark_While 	= 	3 							; 2 is WHILE/WEND.
=4					SMark_If 		= 	4 							; 3 is IF/ENDIF
=5					SMark_For 		= 	5 							; 4 is FOR/NEXT

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/macros/65816/macros_32.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zTemp4: 	.word ?
>0018					zCodePtr:	.dword ? 						; code pointer (long)
>001c					zLTemp1:	.dword ?						; long word (used in multiply)
>0020					zGenPtr:	.word ? 						; general pointer.
>0022					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0024					zVarDataPtr: .word ? 						; position of variable data.
>0026					zVarType: 	.byte ? 						; type of data (token)
>0027					zNullString:.byte ? 						; represents a NULL string.
>0028					zBasicSP:	.word ? 						; stack pointer
>0080					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>0084					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>0085					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=134					XS2_Mantissa = XS_Mantissa+XS_Size
=138					XS2_Exponent = XS_Exponent+XS_Size
=139					XS2_Type = XS_Type+XS_Size
=140					XS3_Mantissa = XS_Mantissa+XS_Size*2
=144					XS3_Exponent = XS_Exponent+XS_Size*2
=145					XS3_Type = XS_Type+XS_Size*2
>0300					StringPtr:	.word ? 						; Top of free memory (for string allocation)
>0302					VarMemPtr: 	.word ?							; Bottom of free memory (for variables)
>0304					endOfProgram: .dword ? 						; End of Program Memory (long)
>0308					vecPrintCharacter .word ?
>030a					vecInputCharacter .word ?
>030c					UserVector .fill 4 							; USR(x) calls this.
>0310					LocalVector .fill 4 						; Indirect calls call this.
>0314					NumBufX 	.byte 	?						; buffer index position
>0315					Num_Buffer	.fill 	32 						; buffer for numeric conversions
=6					HashTableCount = 6 							; there are 6 hash tables, in token order.
=8					HashTableSize = 8 							; each hash table as 8 links.
.0335					HashTableBase:
>0335								.fill	HashTableCount * HashTableSize * 2
.0395					HashTableEnd:
=$315					Var_Buffer 	= Num_Buffer 					; buffer for variable name (same space)
>0395					Var_Type    .byte ? 						; type of variable (as a type token)
>0396					Var_Hash 	.byte ? 						; hash of identifier name.
>0397					Var_Length 	.byte ? 						; length of variable name
>0398					Var_HashAddress .byte ?						; low byte of hash table entry.
>0399					Var_DataSize .byte ?						; size of one element.
>039a					NumSuppress	.byte 	?						; leading zero suppression flag
>039b					NumConvCount .byte 	? 						; count for conversions.
>039c					ExpTemp:	.byte ?							; Working temp for exponents.
>039d					ExpCount:	.byte ? 						; Count of decimal exponents.
>039e					SignCount:	.byte ?							; Integer Divide Sign Counts.
>039f					TempStringWriteIndex: .byte ? 				; Write offset.
>03a0					ValSign: 	.byte ? 						; sign flag for val()
>03a1					SliceStart:	.byte ? 						; string slice parts
>03a2					SliceCount:	.byte ?
>03a3					RandomSeed:	.dword ? 						; Random seed.
>03a7					SignNext:	.byte ? 						; Used for keeping sign of STEP in FOR/NEXT
>03a8					BreakCount:	.byte ? 						; Counter, avoid checking break every command.
=3					ArrayMaxDim = 3 							; number of dimensions.
>03a9					ArrayDef:	.fill (ArrayMaxDim+1)*2 		; dimensions for auto-creation
>03b1					UsrArrayDef:.fill (ArrayMaxDim+1)*2 		; dimensions created in DIM
>03b9					UsrArrayIdx:.byte ? 						; index into UsrArrayDef
>03ba					LastPrinted:.byte ? 						; last printed char ?
>03bb					ListIndent: .byte ? 						; list indent level
>03bc					LastListIndent:.byte ? 						; previous one.
>03bd					DataLPtr: 	.dword ?						; the data long ptr (swapped with zCodePtr)
>03c1					DataIndex:	.byte ?							; index position.
>03c2					InputAvailable: .byte ? 					; characters available in input buffer.
>03c3					InputRetry:	.byte ? 						; true if INPUT is retrying.
>03c4					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>03c6					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>03c8					Tim_SR:		.byte ? 						; Processor Status
>03c9					Tim_A:		.byte ? 						; Processor Registers
>03ca					Tim_X:		.byte ?
>03cb					Tim_Y:		.byte ?
>03cc					Tim_Z:		.byte ?
>03cd					Tim_SP:		.word ?							; Stack Pointer (just in cases)
.0400					TokeniseBuffer:
>0400								.fill 	256
>0500					IFT_XCursor:.byte ?							; current logical position on screen
>0501					IFT_YCursor:.byte ?
>0502					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0566					IFT_LineBuffer: .fill 100 					; line input buffer.
>05ca					BasicStack:	.fill 	256 					; and occupy whole pages.
.06ca					EndBasicStack:

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/em65816.asm

=$7f00					HighMemory = $7F00
=$2000					VariableMemory = $2000
.012000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testcode.src

>012000	0a 0a 00 92 09 84 41 c8			.byte	$0a,$0a,$00,$92,$09,$84,$41,$c8
>012008	43 00 0a 14 00 92 0a 84			.byte	$43,$00,$0a,$14,$00,$92,$0a,$84
>012010	41 c8 44 00 09 1e 00 0b			.byte	$41,$c8,$44,$00,$09,$1e,$00,$0b
>012018	84 09 8a 0a 00 0a 28 00			.byte	$84,$09,$8a,$0a,$00,$0a,$28,$00
>012020	d6 09 bf 0a bf 0b 00 06			.byte	$d6,$09,$bf,$0a,$bf,$0b,$00,$06
>012028	32 00 97 0a 00 06 3c 00			.byte	$32,$00,$97,$0a,$00,$06,$3c,$00
>012030	97 09 00 05 46 00 c4 00			.byte	$97,$09,$00,$05,$46,$00,$c4,$00
>012038	00					.byte	$00

;******  Return to file: modules/hardware/em65816.asm

.c000					StartROM:
.c000	18		clc				clc
.c001	fb		xce				xce
.c002	c2 30		rep #$30			rep 	#$30
.c004	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.c007	1b		tcs				tcs
.c008	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.c00b	e2 30		sep #$30			sep 	#$30
.c00d	c2 30		rep #$30			rep 	#$30						; clear AXY in 16 bit.
.c00f	a9 00		lda #$00			lda 	#$0000
.c011	aa		tax				tax
.c012	a8		tay				tay
.c013	e2 30		sep #$30			sep 	#$30
.c015	5c 13 88 01	jmp $018813		jmp BASIC_Start
.c019					TIM_BreakHandler:
.c019	5c 76 83 01	jmp $018376			jmp 	TIM_BreakVector

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.018000					IFT_ClearScreen:
.018000	48		pha				pha
.018001	da		phx				phx
.018002	5a		phy				phy
.018003	20 a9 81	jsr $0181a9			jsr 	IF_Home 					; home cursor
.018006	a2 20		ldx #$20			ldx 	#IF_Height 					; this many lines.
.018008					_IFT_CS0:
.018008	a0 40		ldy #$40			ldy 	#IF_Width 					; this many chars/line
.01800a					_IFT_CS1:
.01800a	a9 20		lda #$20			lda 	#' '						; clear line.
.01800c	20 d5 81	jsr $0181d5			jsr 	IF_Write
.01800f	88		dey				dey
.018010	d0 f8		bne $01800a			bne 	_IFT_CS1
.018012	20 bc 81	jsr $0181bc			jsr 	IF_NewLine 					; next line down
.018015	ca		dex				dex
.018016	d0 f0		bne $018008			bne 	_IFT_CS0
.018018	7a		ply				ply
.018019	fa		plx				plx
.01801a	68		pla				pla
.01801b					IFT_HomeCursor:
.01801b	48		pha				pha
.01801c	20 a9 81	jsr $0181a9			jsr 	IF_Home
.01801f	a9 00		lda #$00			lda 	#0
.018021	8d 00 05	sta $0500			sta 	IFT_XCursor
.018024	8d 01 05	sta $0501			sta 	IFT_YCursor
.018027	68		pla				pla
.018028	60		rts				rts
.018029					IFT_UpLine:
.018029	48		pha				pha
.01802a	ad 01 05	lda $0501			lda  	IFT_YCursor 				; get Y
.01802d	3a		dec a				dec 	a 							; line above
.01802e	30 03		bmi $018033			bmi 	_IFTULExit 					; too far, abort
.018030	20 c8 80	jsr $0180c8			jsr 	IFT_SetYPos					; set to that line.
.018033					_IFTULExit:
.018033	68		pla				pla
.018034	60		rts				rts
.018035					IFT_PrintCharacter:
.018035	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.018037	f0 20		beq $018059			beq 	IFT_NewLine
.018039	c9 08		cmp #$08			cmp 	#8
.01803b	f0 16		beq $018053			beq 	_IFT_Left
.01803d	48		pha				pha
.01803e	20 71 80	jsr $018071			jsr 	IFT_UpperCase 				; make upper case
.018041	20 d5 81	jsr $0181d5			jsr 	IF_Write 					; write out.
.018044	ee 00 05	inc $0500			inc 	IFT_XCursor 				; bump x cursor
.018047	ad 00 05	lda $0500			lda 	IFT_XCursor 				; reached RHS ?
.01804a	c9 40		cmp #$40			cmp 	#IF_Width
.01804c	d0 03		bne $018051			bne 	_IFT_PCNotEOL
.01804e	20 59 80	jsr $018059			jsr 	IFT_NewLine 				; if so do new line.
.018051					_IFT_PCNotEOL:
.018051	68		pla				pla
.018052	60		rts				rts
.018053					_IFT_Left:
.018053	48		pha				pha
.018054	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.018057	68		pla				pla
.018058	60		rts				rts
.018059					IFT_NewLine:
.018059	48		pha				pha
.01805a	20 bc 81	jsr $0181bc			jsr 	IF_NewLine 					; new line on actual screen.
.01805d	a9 00		lda #$00			lda 	#0 							; reset x position
.01805f	8d 00 05	sta $0500			sta 	IFT_XCursor
.018062	ee 01 05	inc $0501			inc 	IFT_YCursor 				; move down.
.018065	ad 01 05	lda $0501			lda 	IFT_YCursor
.018068	c9 20		cmp #$20			cmp 	#IF_Height 					; reached bottom.
.01806a	d0 03		bne $01806f			bne 	_IFT_NL_NotEOS
.01806c	20 7c 80	jsr $01807c			jsr 	IFT_Scroll 					; scroll screen up.
.01806f					_IFT_NL_NotEOS:
.01806f	68		pla				pla
.018070	60		rts				rts
.018071					IFT_UpperCase:
.018071	c9 61		cmp #$61			cmp 	#"a"
.018073	90 06		bcc $01807b			bcc 	_IFT_UCExit
.018075	c9 7b		cmp #$7b			cmp 	#"z"+1
.018077	b0 02		bcs $01807b			bcs 	_IFT_UCExit
.018079	49 20		eor #$20			eor 	#$20
.01807b					_IFT_UCExit:
.01807b	60		rts				rts
.01807c					IFT_Scroll:
.01807c	48		pha				pha 								; save AXY
.01807d	da		phx				phx
.01807e	5a		phy				phy
.01807f	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.018081					_IFT_SLoop:
.018081	20 a1 80	jsr $0180a1			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.018084	e8		inx				inx
.018085	e0 1f		cpx #$1f			cpx 	#IF_Height-1				; do whole screen
.018087	d0 f8		bne $018081			bne 	_IFT_SLoop
.018089	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.01808b	20 c8 80	jsr $0180c8			jsr 	IFT_SetYPos
.01808e	a2 40		ldx #$40			ldx 	#IF_Width 					; blank line
.018090					_IFT_SBlank:
.018090	a9 20		lda #$20			lda 	#32
.018092	20 d5 81	jsr $0181d5			jsr 	IF_Write
.018095	ca		dex				dex
.018096	d0 f8		bne $018090			bne 	_IFT_SBlank
.018098	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.01809a	20 c8 80	jsr $0180c8			jsr 	IFT_SetYPos
.01809d	7a		ply				ply
.01809e	fa		plx				plx
.01809f	68		pla				pla
.0180a0	60		rts				rts
.0180a1					_IFT_ScrollLine:
.0180a1	da		phx				phx
.0180a2	da		phx				phx
.0180a3	8a		txa				txa 								; copy line into buffer.
.0180a4	1a		inc a				inc 	a 							; next line down.
.0180a5	20 c8 80	jsr $0180c8			jsr 	IFT_SetYPos
.0180a8	a2 00		ldx #$00			ldx 	#0
.0180aa					_IFTScrollCopy1:
.0180aa	20 cc 81	jsr $0181cc			jsr 	IF_Read
.0180ad	9d 02 05	sta $0502,x			sta 	IFT_Buffer,x
.0180b0	e8		inx				inx
.0180b1	e0 40		cpx #$40			cpx 	#IF_Width
.0180b3	d0 f5		bne $0180aa			bne 	_IFTScrollCopy1
.0180b5	68		pla				pla
.0180b6	20 c8 80	jsr $0180c8			jsr 	IFT_SetYPos
.0180b9	a2 00		ldx #$00			ldx 	#0
.0180bb					_IFTScrollCopy2:
.0180bb	bd 02 05	lda $0502,x			lda 	IFT_Buffer,x
.0180be	20 d5 81	jsr $0181d5			jsr 	IF_Write
.0180c1	e8		inx				inx
.0180c2	e0 40		cpx #$40			cpx 	#IF_Width
.0180c4	d0 f5		bne $0180bb			bne 	_IFTScrollCopy2
.0180c6	fa		plx				plx
.0180c7	60		rts				rts
.0180c8					IFT_SetYPos:
.0180c8	48		pha				pha
.0180c9	da		phx				phx
.0180ca	aa		tax				tax
.0180cb	20 1b 80	jsr $01801b			jsr 	IFT_HomeCursor
.0180ce	e0 00		cpx #$00			cpx 	#0
.0180d0	f0 09		beq $0180db			beq 	_IFT_MOAExit
.0180d2					_IFT_MOALoop:
.0180d2	20 bc 81	jsr $0181bc			jsr 	IF_NewLine
.0180d5	ee 01 05	inc $0501			inc 	IFT_YCursor
.0180d8	ca		dex				dex
.0180d9	d0 f7		bne $0180d2			bne		_IFT_MOALoop
.0180db					_IFT_MOAExit:
.0180db	fa		plx				plx
.0180dc	68		pla				pla
.0180dd	60		rts				rts
.0180de					IFT_GetKeyCursor:
.0180de	20 e6 80	jsr $0180e6			jsr 	_IFT_FlipCursor 			; reverse current
.0180e1					_IFT_GKCWait:
.0180e1	20 e6 81	jsr $0181e6			jsr 	IF_GetKey 					; get key
.0180e4	f0 fb		beq $0180e1			beq 	_IFT_GKCWait
.0180e6					_IFT_FlipCursor:
.0180e6	48		pha				pha 								; save
.0180e7	20 cc 81	jsr $0181cc			jsr 	IF_Read 					; read
.0180ea	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.0180ed	49 80		eor #$80			eor 	#$80 						; reverse
.0180ef	20 d5 81	jsr $0181d5			jsr 	IF_Write 					; write
.0180f2	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.0180f5	68		pla				pla
.0180f6	60		rts				rts
.0180f7					IFT_ReadLine:
.0180f7	48		pha				pha
.0180f8					_IFT_RLLoop:
.0180f8	20 de 80	jsr $0180de			jsr 	IFT_GetKeyCursor 			; get keystroke
.0180fb	c9 0d		cmp #$0d			cmp 	#13							; return
.0180fd	f0 7d		beq $01817c			beq 	_IFT_RLExit
.0180ff	c9 20		cmp #$20			cmp 	#32 						; control character
.018101	90 05		bcc $018108			bcc 	_IFT_Control
.018103	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018106	80 f0		bra $0180f8			bra 	_IFT_RLLoop
.018108					_IFT_Control:
.018108	c9 01		cmp #$01			cmp 	#"A"-64
.01810a	f0 26		beq $018132			beq 	_IFT_Left
.01810c	c9 04		cmp #$04			cmp 	#"D"-64
.01810e	f0 2e		beq $01813e			beq 	_IFT_Right
.018110	c9 17		cmp #$17			cmp 	#"W"-64
.018112	f0 36		beq $01814a			beq 	_IFT_Up
.018114	c9 13		cmp #$13			cmp 	#"S"-64
.018116	f0 3e		beq $018156			beq 	_IFT_Down
.018118	c9 08		cmp #$08			cmp 	#"H"-64
.01811a	f0 09		beq $018125			beq 	_IFT_Backspace
.01811c	c9 1a		cmp #$1a			cmp 	#"Z"-64
.01811e	d0 d8		bne $0180f8			bne 	_IFT_RLLoop
.018120	20 00 80	jsr $018000			jsr 	IFT_ClearScreen				; clear CTL-Z
.018123	80 d3		bra $0180f8			bra 	_IFT_RLLoop
.018125					_IFT_Backspace:
.018125	ad 00 05	lda $0500			lda 	IFT_XCursor 				; check not start of line.
.018128	f0 ce		beq $0180f8			beq 	_IFT_RLLoop
.01812a	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.01812d	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.01812f	20 d5 81	jsr $0181d5			jsr 	IF_Write
.018132					_IFT_Left:
.018132	ce 00 05	dec $0500			dec 	IFT_XCursor 				; left CTL-W
.018135	10 29		bpl $018160			bpl 	_IFT_Reposition
.018137	a9 3f		lda #$3f			lda 	#IF_Width-1
.018139					_IFT_SetX:
.018139	8d 00 05	sta $0500			sta 	IFT_XCursor
.01813c	80 22		bra $018160			bra 	_IFT_Reposition
.01813e					_IFT_Right:
.01813e	ee 00 05	inc $0500			inc 	IFT_XCursor
.018141	ad 00 05	lda $0500			lda 	IFT_XCursor
.018144	49 40		eor #$40			eor 	#IF_Width
.018146	f0 f1		beq $018139			beq 	_IFT_SetX
.018148	80 16		bra $018160			bra 	_IFT_Reposition
.01814a					_IFT_Up:
.01814a	ce 01 05	dec $0501			dec 	IFT_YCursor
.01814d	10 11		bpl $018160			bpl 	_IFT_Reposition
.01814f	a9 1f		lda #$1f			lda 	#IF_Height-1
.018151					_IFT_SetY:
.018151	8d 01 05	sta $0501			sta 	IFT_YCursor
.018154	80 0a		bra $018160			bra 	_IFT_Reposition
.018156					_IFT_Down:
.018156	ee 01 05	inc $0501			inc 	IFT_YCursor
.018159	ad 01 05	lda $0501			lda 	IFT_YCursor
.01815c	49 20		eor #$20			eor 	#IF_Height
.01815e	f0 f1		beq $018151			beq 	_IFT_SetY
.018160					_IFT_Reposition:
.018160	ad 00 05	lda $0500			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.018163	48		pha				pha
.018164	ad 01 05	lda $0501			lda 	IFT_YCursor
.018167	20 c8 80	jsr $0180c8			jsr 	IFT_SetYPos
.01816a	68		pla				pla
.01816b	aa		tax				tax
.01816c	e0 00		cpx #$00			cpx 	#0
.01816e	f0 88		beq $0180f8			beq 	_IFT_RLLoop
.018170					_IFT_MoveRight:
.018170	20 cc 81	jsr $0181cc			jsr 	IF_Read
.018173	ee 00 05	inc $0500			inc 	IFT_XCursor
.018176	ca		dex				dex
.018177	d0 f7		bne $018170			bne 	_IFT_MoveRight
.018179	4c f8 80	jmp $0180f8			jmp 	_IFT_RLLoop
.01817c					_IFT_RLExit:
.01817c	ad 01 05	lda $0501			lda 	IFT_YCursor 				; go to start of line.
.01817f	20 c8 80	jsr $0180c8			jsr 	IFT_SetYPos
.018182	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.018184					_IFT_RLRead:
.018184	20 cc 81	jsr $0181cc			jsr 	IF_Read
.018187	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.01818a	e8		inx				inx
.01818b	e0 40		cpx #$40			cpx 	#IF_Width
.01818d	d0 f5		bne $018184			bne 	_IFT_RLRead
.01818f					_IFT_RL_Trim:
.01818f	ca		dex				dex 	 							; previous char
.018190	30 07		bmi $018199			bmi 	_IFT_Found 					; gone too far
.018192	bd 66 05	lda $0566,x			lda 	IFT_LineBuffer,x			; go back if space
.018195	c9 20		cmp #$20			cmp 	#" "
.018197	f0 f6		beq $01818f			beq 	_IFT_RL_Trim
.018199					_IFT_Found:
.018199	e8		inx				inx 								; forward to non-space
.01819a	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.01819c	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.01819f	20 59 80	jsr $018059			jsr 	IFT_NewLine 				; go to next line.
.0181a2	68		pla				pla
.0181a3	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.0181a5	a0 05		ldy #$05			ldy 	#IFT_LineBuffer >> 8
.0181a7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_em65816.asm

=64					IF_Width 	= 64 							; characters across
=32					IF_Height 	= 32 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line.
=8					IF_XPos 	= 8 							; current position, horizontal.
=$f0000					IF_Screen = $F0000							; 2k screen RAM here
=$f8010					IF_PKeyboard = $F8010						; Keyboard port.
=$f8000					IF_PBreak = $F8000 							; Break key.
.0181a8					IF_Reset:
.0181a8	60		rts				rts
.0181a9					IF_Home:
.0181a9	48		pha				pha
.0181aa	64 08		stz $08				stz 	IF_XPos 					; zero X position
.0181ac	a9 00		lda #$00			lda 	#IF_Screen & $FF 			; set r/w pos.
.0181ae	85 04		sta $04				sta 	IF_Pos
.0181b0	a9 00		lda #$00			lda 	#(IF_Screen >> 8) & $FF
.0181b2	85 05		sta $05				sta 	IF_Pos+1
.0181b4	a9 0f		lda #$0f			lda 	#IF_Screen >> 16
.0181b6	85 06		sta $06				sta 	IF_Pos+2
.0181b8	64 07		stz $07				stz 	IF_Pos+3
.0181ba	68		pla				pla
.0181bb	60		rts				rts
.0181bc					IF_NewLine:
.0181bc	48		pha				pha
.0181bd	64 08		stz $08				stz 	IF_XPos						; back to start of line
.0181bf	18		clc				clc 								; down one line
.0181c0	a5 04		lda $04				lda 	IF_Pos
.0181c2	69 40		adc #$40			adc 	#64
.0181c4	85 04		sta $04				sta 	IF_Pos
.0181c6	90 02		bcc $0181ca			bcc 	_IF_NoCarry 				; carry through.
.0181c8	e6 05		inc $05				inc 	IF_Pos+1
.0181ca					_IF_NoCarry:
.0181ca	68		pla				pla
.0181cb	60		rts				rts
.0181cc					IF_Read:
.0181cc	5a		phy				phy 								; save current Y
.0181cd	a4 08		ldy $08				ldy 	IF_XPos 					; read character at current position
.0181cf	b7 04		lda [$04],y			lda 	[IF_Pos],y
.0181d1	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181d3	7a		ply				ply									; restore Y
.0181d4	60		rts				rts
.0181d5					IF_Write:
.0181d5	5a		phy				phy 								; save current Y
.0181d6	a4 08		ldy $08				ldy 	IF_XPos 					; write character at current position
.0181d8	97 04		sta [$04],y			sta 	[IF_Pos],y
.0181da	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181dc	7a		ply				ply									; restore Y
.0181dd	60		rts				rts
.0181de					IF_LeftOne:
.0181de	c6 08		dec $08				dec 	IF_XPos
.0181e0	60		rts				rts
.0181e1					IF_CheckBreak:
.0181e1	af 00 80 0f	lda $0f8000			lda 	IF_PBreak					; non-zero if Ctrl+C pressed.
.0181e5	60		rts				rts
.0181e6					IF_GetKey:
.0181e6	af 10 80 0f	lda $0f8010			lda 	IF_PKeyboard				; read keyboard
.0181ea	f0 08		beq $0181f4			beq		_IFGK_NoKey 				; skip if zero,no key pressed
.0181ec	48		pha				pha 								; key pressed, clear queue.
.0181ed	a9 00		lda #$00			lda 	#0
.0181ef	8f 10 80 0f	sta $0f8010			sta 	IF_PKeyboard
.0181f3	68		pla				pla
.0181f4					_IFGK_NoKey:
.0181f4	09 00		ora #$00			ora 	#0							; set Z flag appropriately.
.0181f6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.0181f7					TIM_Error:
.0181f7	20 29 80	jsr $018029			jsr 	IFT_UpLine 					; go up one line.
.0181fa	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.0181fc	80 02		bra $018200			bra 	TIM_ShowPrompt
.0181fe					TIM_NewCommand:
.0181fe	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.018200					TIM_ShowPrompt:
.018200	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.018203	20 f7 80	jsr $0180f7			jsr 	IFT_ReadLine	 			; get character, go to next line
.018206	20 59 80	jsr $018059			jsr 	IFT_NewLine					; go to next line.
.018209	86 10		stx $10				stx 	zTemp1 						; save line read address
.01820b	84 11		sty $11				sty 	zTemp1+1
.01820d	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.01820f	b1 10		lda ($10),y			lda 	(zTemp1),y
.018211	c9 3f		cmp #$3f			cmp 	#"?"
.018213	f0 04		beq $018219			beq 	TIM_SkipFirst
.018215	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.018217	d0 01		bne $01821a			bne 	TIM_NotDot
.018219					TIM_SkipFirst:
.018219	c8		iny				iny
.01821a					TIM_NotDot:
.01821a	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.01821c	c9 52		cmp #$52			cmp 	#"R"						; show registers
.01821e	f0 6b		beq $01828b			beq 	TIM_ShowRegisters
.018220	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.018222	f0 12		beq $018236			beq 	TIM_ShowMemory
.018224	c9 47		cmp #$47			cmp 	#"G"						; execute
.018226	f0 49		beq $018271			beq 	TIM_Execute
.018228	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.01822a	f0 07		beq $018233			beq 	TIM_GoLoadMemory
.01822c	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.01822e	d0 c7		bne $0181f7			bne 	TIM_Error
.018230	4c af 83	jmp $0183af			jmp 	TIM_UpdateRegisters
.018233					TIM_GoLoadMemory:
.018233	4c df 83	jmp $0183df			jmp 	TIM_LoadMemory
.018236					TIM_ShowMemory:
.018236	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.018239	b0 bc		bcs $0181f7			bcs 	TIM_Error
.01823b	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.01823d	85 12		sta $12				sta 	zTemp2
.01823f	a5 15		lda $15				lda 	zTemp3+1
.018241	85 13		sta $13				sta 	zTemp2+1
.018243	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.018246	90 08		bcc $018250			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.018248	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.01824a	85 14		sta $14				sta 	zTemp3
.01824c	a5 13		lda $13				lda 	zTemp2+1
.01824e	85 15		sta $15				sta 	zTemp3+1
.018250					_TIMSM_Start:
.018250	20 03 83	jsr $018303			jsr 	TIM_WriteLine 				; write one line of hex out
.018253	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.018255	18		clc				clc
.018256	69 10		adc #$10			adc 	#16
.018258	85 12		sta $12				sta 	zTemp2
.01825a	90 02		bcc $01825e			bcc 	_TIMSM_NoCarry
.01825c	e6 13		inc $13				inc 	zTemp2+1
.01825e					_TIMSM_NoCarry:
.01825e	20 e1 81	jsr $0181e1			jsr 	IF_CheckBreak 				; check CTL+C
.018261	d0 0b		bne $01826e			bne 	_TIMSM_Ends 				; if pressed break out.
.018263	38		sec				sec 								; check past the end address in zTemp3
.018264	a5 14		lda $14				lda 	zTemp3
.018266	e5 12		sbc $12				sbc 	zTemp2
.018268	a5 15		lda $15				lda 	zTemp3+1
.01826a	e5 13		sbc $13				sbc 	zTemp2+1
.01826c	10 e2		bpl $018250			bpl 	_TIMSM_Start
.01826e					_TIMSM_Ends:
.01826e	4c fe 81	jmp $0181fe			jmp 	TIM_NewCommand
.018271					TIM_Execute:
.018271	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; get the execute address
.018274	b0 81		bcs $0181f7			bcs 	TIM_Error 					; not legitimate
.018276	ae cd 03	ldx $03cd			ldx 	TIM_SP 						; set up SP
.018279	9a		txs				txs
.01827a	ad c8 03	lda $03c8			lda 	TIM_SR 						; Status for PLP
.01827d	48		pha				pha
.01827e	ad c9 03	lda $03c9			lda 	TIM_A 						; restore AXYZ
.018281	ae ca 03	ldx $03ca			ldx 	TIM_X
.018284	ac cb 03	ldy $03cb			ldy 	TIM_Y
.018287	28		plp				plp 								; and PS Byte.
.018288	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.01828b					TIM_Start:
.01828b					TIM_ShowRegisters:
.01828b	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.01828e	8d c7 03	sta $03c7			sta 	TIM_IRQ+1
.018291	ad ff ff	lda $ffff			lda 	$FFFF
.018294	8d c6 03	sta $03c6			sta 	TIM_IRQ
.018297	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.018299					_TIMSR_Text:
.018299	bf ca 82 01	lda $0182ca,x			lda 	_TIMSR_Label,x
.01829d	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182a0	e8		inx				inx
.0182a1	e0 20		cpx #$20			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.0182a3	d0 f4		bne $018299			bne 	_TIMSR_Text
.0182a5	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.0182a7					_TIMSR_Skip:
.0182a7	e8		inx				inx
.0182a8					_TIMSR_LoopSpace:
.0182a8	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.0182aa	b0 04		bcs $0182b0			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.0182ac	8a		txa				txa
.0182ad	4a		lsr a				lsr 	a
.0182ae	b0 05		bcs $0182b5			bcs 	_TIMSR_NoSpace
.0182b0					_TIMSR_Space:
.0182b0	a9 20		lda #$20			lda 	#" "
.0182b2	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182b5					_TIMSR_NoSpace:
.0182b5	bd c4 03	lda $03c4,x			lda 	TIM_PC,x 					; output hex value.
.0182b8	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.0182bb	e8		inx				inx
.0182bc	e0 08		cpx #$08			cpx 	#TIM_Z-TIM_PC
.0182be	f0 e7		beq $0182a7			beq 	_TIMSR_Skip
.0182c0	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.0182c2	d0 e4		bne $0182a8			bne 	_TimSR_LoopSpace
.0182c4	20 59 80	jsr $018059			jsr 	IFT_NewLine 				; new line
.0182c7	4c fe 81	jmp $0181fe			jmp	 	TIM_NewCommand 				; new command.
.0182ca					_TIMSR_Label:
>0182ca	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>0182d2	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>0182e2	52
>0182e3	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.0182ea					_TIMSR_LabelEnd:
.0182ea					TIM_WriteHex:
.0182ea	48		pha				pha 								; save A
.0182eb	4a		lsr a				lsr 	a 							; shift MSB->LSB
.0182ec	4a		lsr a				lsr 	a
.0182ed	4a		lsr a				lsr 	a
.0182ee	4a		lsr a				lsr 	a
.0182ef	20 f3 82	jsr $0182f3			jsr 	_TIMWH_Nibble 				; print MSB
.0182f2	68		pla				pla 								; restore and print LSB
.0182f3					_TIMWH_Nibble:
.0182f3	48		pha				pha
.0182f4	29 0f		and #$0f			and 	#15 						; mask out
.0182f6	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.0182f8	90 02		bcc $0182fc			bcc 	_TIMWHNoLetter
.0182fa	69 06		adc #$06			adc 	#6
.0182fc					_TIMWHNoLetter:
.0182fc	69 30		adc #$30			adc 	#48
.0182fe	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter 			; print it out.
.018301	68		pla				pla
.018302	60		rts				rts
.018303					TIM_WriteLine:
.018303	a9 2e		lda #$2e			lda 	#"." 						; prompt
.018305	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018308	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.01830a	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01830d	a5 13		lda $13				lda 	zTemp2+1 					; write address
.01830f	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.018312	a5 12		lda $12				lda 	zTemp2
.018314	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.018317	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.018319					_TIMWL_Loop:
.018319	a9 20		lda #$20			lda 	#" "
.01831b	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01831e	b1 12		lda ($12),y			lda 	(zTemp2),y
.018320	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.018323	c8		iny				iny
.018324	c0 10		cpy #$10			cpy 	#16
.018326	d0 f1		bne $018319			bne 	_TIMWL_Loop
.018328	4c 59 80	jmp $018059			jmp 	IFT_NewLine 				; new line and exit
.01832b					TIM_GetHex:
.01832b	c8		iny				iny
.01832c	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.01832e	c9 20		cmp #$20			cmp 	#32
.018330	f0 f9		beq $01832b			beq 	TIM_GetHex
.018332	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.018334	f0 f5		beq $01832b			beq 	TIM_GetHex
.018336	20 5f 83	jsr $01835f			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.018339	b0 23		bcs $01835e			bcs 	_TIMGH_Exit					; if first bad then exit now.
.01833b	a9 00		lda #$00			lda 	#0 							; zero result
.01833d	85 14		sta $14				sta 	zTemp3
.01833f	85 15		sta $15				sta 	zTemp3+1
.018341					_TIM_GHLoop:
.018341	20 5f 83	jsr $01835f			jsr 	TIM_GetHexCharacter 		; get next character
.018344	b0 17		bcs $01835d			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.018346	c8		iny				iny 								; skip over it.
.018347	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.018349	26 15		rol $15				rol 	zTemp3+1
.01834b	06 14		asl $14				asl 	zTemp3 						; now x 2
.01834d	26 15		rol $15				rol 	zTemp3+1
.01834f	06 14		asl $14				asl 	zTemp3						; now x 4
.018351	26 15		rol $15				rol 	zTemp3+1
.018353	06 14		asl $14				asl 	zTemp3 						; now x 8
.018355	26 15		rol $15				rol 	zTemp3+1
.018357	05 14		ora $14				ora 	zTemp3 						; OR result in
.018359	85 14		sta $14				sta 	zTemp3
.01835b	80 e4		bra $018341			bra 	_TIM_GHLoop 				; loop round again.
.01835d					_TIMGH_Okay:
.01835d	18		clc				clc
.01835e					_TIMGH_Exit:
.01835e	60		rts				rts
.01835f					TIM_GetHexCharacter:
.01835f	b1 10		lda ($10),y			lda 	(zTemp1),y
.018361	38		sec				sec
.018362	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.018364	90 0e		bcc $018374			bcc 	_TIM_GHCFail
.018366	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.018368	90 0b		bcc $018375			bcc 	_TIM_GHCExit
.01836a	c9 11		cmp #$11			cmp 	#65-48						; < A
.01836c	90 06		bcc $018374			bcc		_TIM_GHCFail
.01836e	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.018370	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.018372	90 01		bcc $018375			bcc		_TIM_GHCExit
.018374					_TIM_GHCFail:
.018374	38		sec				sec
.018375					_TIM_GHCExit:
.018375	60		rts				rts
.018376					TIM_BreakVector:
.018376	da		phx				phx									; save X/A on stack
.018377	48		pha				pha
.018378	ba		tsx				tsx 								; X points to S
.018379	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.01837c	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.01837e	d0 03		bne $018383			bne 	_TIMBreak					; if set, it's BRK
.018380	68		pla				pla 								; abandon routine.
.018381	fa		plx				plx
.018382	40		rti				rti
.018383					_TIMBreak:
.018383	68		pla				pla 								; save A X Y and maybe Z
.018384	8d c9 03	sta $03c9			sta 	TIM_A
.018387	fa		plx				plx
.018388	8e ca 03	stx $03ca			stx 	TIM_X
.01838b	8c cb 03	sty $03cb			sty 	TIM_Y
.01838e	68		pla				pla 								; get Status Register
.01838f	8d c8 03	sta $03c8			sta 	TIM_SR
.018392	68		pla				pla
.018393	8d c5 03	sta $03c5			sta 	TIM_PC+1 					; save calling address
.018396	68		pla				pla
.018397	8d c4 03	sta $03c4			sta 	TIM_PC 						; high byte
.01839a	ad c5 03	lda $03c5			lda 	TIM_PC+1 					; dec PC to point right.
.01839d	d0 03		bne $0183a2			bne 	_TIMDecrement 				; brk bumps it.
.01839f	ce c4 03	dec $03c4			dec 	TIM_PC
.0183a2					_TIMDecrement:
.0183a2	ce c5 03	dec $03c5			dec 	TIM_PC+1
.0183a5	ba		tsx				tsx 								; and copy SP
.0183a6	8e cd 03	stx $03cd			stx 	TIM_SP
.0183a9	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.0183ab	9a		txs				txs
.0183ac	4c 8b 82	jmp $01828b			jmp 	TIM_Start 					; and start up TIM monitor.
.0183af					TIM_UpdateRegisters:
.0183af	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; PC
.0183b2	b0 28		bcs $0183dc			bcs 	_TIMURFail
.0183b4	a5 14		lda $14				lda 	zTemp3
.0183b6	8d c5 03	sta $03c5			sta 	Tim_PC+1
.0183b9	a5 15		lda $15				lda 	zTemp3+1
.0183bb	8d c4 03	sta $03c4			sta 	Tim_PC
.0183be	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; ignore IRQ
.0183c1	b0 19		bcs $0183dc			bcs 	_TIMURFail
.0183c3	a2 00		ldx #$00			ldx 	#0
.0183c5					_TIM_URLoop:
.0183c5	e0 04		cpx #$04			cpx 	#Tim_Z-Tim_SR
.0183c7	d0 01		bne $0183ca			bne 	_TIM_1
.0183c9	e8		inx				inx
.0183ca					_TIM_1:
.0183ca	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; registers
.0183cd	b0 0d		bcs $0183dc			bcs 	_TIMURFail
.0183cf	a5 14		lda $14				lda 	zTemp3
.0183d1	9d c8 03	sta $03c8,x			sta 	Tim_SR,x
.0183d4	e8		inx				inx
.0183d5	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.0183d7	d0 ec		bne $0183c5			bne 	_TIM_URLoop
.0183d9	4c fe 81	jmp $0181fe			jmp 	TIM_NewCommand
.0183dc					_TIMURFail:
.0183dc	4c f7 81	jmp $0181f7			jmp 	TIM_Error
.0183df					TIM_LoadMemory:
.0183df	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; target address => zTemp2
.0183e2	a5 14		lda $14				lda 	zTemp3
.0183e4	85 12		sta $12				sta 	zTemp2
.0183e6	a5 15		lda $15				lda 	zTemp3+1
.0183e8	85 13		sta $13				sta 	zTemp2+1
.0183ea					_TIM_LMLoop:
.0183ea	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; next byte ?
.0183ed	b0 0e		bcs $0183fd			bcs 	_TIMLMDone 					; no more
.0183ef	a2 00		ldx #$00			ldx 	#0							; write out.
.0183f1	a5 14		lda $14				lda 	zTemp3
.0183f3	81 12		sta ($12,x)			sta 	(zTemp2,x)
.0183f5	e6 12		inc $12				inc 	zTemp2 						; bump address
.0183f7	d0 f1		bne $0183ea			bne 	_TIM_LMLoop
.0183f9	e6 13		inc $13				inc 	zTemp2+1
.0183fb	80 ed		bra $0183ea			bra 	_TIM_LMLoop
.0183fd					_TIMLMDone:
.0183fd	4c fe 81	jmp $0181fe			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/skip.asm

.018400					StructureSearchSingle:
.018400	a2 00		ldx #$00			ldx 	#0 							; we always search for XA. This disables X.
.018402					StructureSearchDouble:
.018402	85 10		sta $10				sta 	zTemp1 						; save the targets in zTemp1,zTemp1+1
.018404	86 11		stx $11				stx 	zTemp1+1
.018406	a9 00		lda #$00			lda 	#0 							; set the structure depth to zero (zTemp2)
.018408	85 12		sta $12				sta 	zTemp2
.01840a	80 18		bra $018424			bra 	_SSWLoop 					; jump in, start scanning from here.
.01840c					_SSWNextLine:
.01840c	a0 00		ldy #$00			ldy 	#0 							; point to offset
.01840e	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read it
.018410	18		clc				clc
.018411	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.018413	85 18		sta $18				sta 	zCodePtr
.018415	90 02		bcc $018419			bcc 	_SNLNoCarry
.018417	e6 19		inc $19				inc 	zCodePtr+1
.018419					_SNLNoCarry:
.018419	a0 00		ldy #$00			ldy 	#0
.01841b	b7 18		lda [$18],y			lda 	[zCodePtr],y
.01841d	c9 00		cmp #$00			cmp 	#0					 		; if zero, fail.
.01841f	f0 54		beq $018475			beq 	_SSWFail
.018421	c8		iny				iny
.018422	c8		iny				iny
.018423					_SSWNextSimple:
.018423	c8		iny				iny
.018424					_SSWLoop:
.018424	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018426	c9 00		cmp #$00			cmp 	#0 							; end of line ?
.018428	f0 e2		beq $01840c			beq 	_SSWNextLine 				; if so, then next line
.01842a	10 f7		bpl $018423			bpl 	_SSWNextSimple 				; needs to be a token, just skip char/number.
.01842c	a6 12		ldx $12				ldx 	zTemp2 						; check structure count
.01842e	d0 08		bne $018438			bne 	_SSWCheckUpDown 			; if it's non zero, then a match doesn't work.
.018430	c5 10		cmp $10				cmp 	zTemp1 						; found the right keyword, either choice.
.018432	f0 2d		beq $018461			beq 	_SSWFound 					; then exit.
.018434	c5 11		cmp $11				cmp 	zTemp1+1
.018436	f0 29		beq $018461			beq 	_SSWFound
.018438					_SSWCheckUpDown:
.018438	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus 			; if < keyword +
.01843a	90 10		bcc $01844c			bcc 	_SSWNext
.01843c	c9 93		cmp #$93			cmp 	#firstKeywordMinus 			; if < keyword - then as keyword +
.01843e	90 08		bcc $018448			bcc 	_SSWPlus
.018440	c9 98		cmp #$98			cmp 	#firstUnaryFunction			; if < first unary down as keyword -
.018442	b0 08		bcs $01844c			bcs 	_SSWNext
.018444	c6 12		dec $12				dec 	zTemp2 						; reduce structure count.
.018446	c6 12		dec $12				dec 	zTemp2
.018448					_SSWPlus:
.018448	e6 12		inc $12				inc 	zTemp2
.01844a	30 16		bmi $018462			bmi 	_SSWUnder					; error if driven -ve
.01844c					_SSWNext:
.01844c	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read element
.01844e	c8		iny				iny 								; skip
.01844f	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018451	90 0c		bcc $01845f			bcc 	_SEDone 					; so just skip over it.
.018453	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018455	90 07		bcc $01845e			bcc 	_SEDouble
.018457	98		tya				tya 								; this is Y + 1
.018458	18		clc				clc
.018459	77 18		adc [$18],y			adc 	[zCodePtr],y 				; add total length of element
.01845b	a8		tay				tay 								; back in Y.
.01845c	88		dey				dey 								; fix up, one for the +1, one for the iny
.01845d	88		dey				dey
.01845e					_SEDouble:
.01845e	c8		iny				iny
.01845f					_SEDone:
.01845f	80 c3		bra $018424			bra 	_SSWLoop
.018461					_SSWFound:
.018461	60		rts				rts
.018462					_SSWUnder:
.018462	20 86 85	jsr $018586			jsr ERR_Handler
>018465	53 74 72 75 63 74 75 72			.text "Structure order",0
>01846d	65 20 6f 72 64 65 72 00
.018475					_SSWFail:
.018475	20 86 85	jsr $018586			jsr ERR_Handler
>018478	43 61 6e 27 74 20 66 69			.text "Can't find structure",0
>018480	6e 64 20 73 74 72 75 63 74 75 72 65 00
.01848d					SkipEndOfCommand:
.01848d	b7 18		lda [$18],y			lda 	[zCodePtr],y
.01848f	c9 00		cmp #$00			cmp 	#0 							; if zero, end of line, so exit
.018491	f0 19		beq $0184ac			beq 	_SOCExit
.018493	c9 c0		cmp #$c0			cmp 	#token_Colon 				; if colon, end of command
.018495	f0 15		beq $0184ac			beq 	_SOCExit
.018497	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read element
.018499	c8		iny				iny 								; skip
.01849a	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.01849c	90 0c		bcc $0184aa			bcc 	_SEDone 					; so just skip over it.
.01849e	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.0184a0	90 07		bcc $0184a9			bcc 	_SEDouble
.0184a2	98		tya				tya 								; this is Y + 1
.0184a3	18		clc				clc
.0184a4	77 18		adc [$18],y			adc 	[zCodePtr],y 				; add total length of element
.0184a6	a8		tay				tay 								; back in Y.
.0184a7	88		dey				dey 								; fix up, one for the +1, one for the iny
.0184a8	88		dey				dey
.0184a9					_SEDouble:
.0184a9	c8		iny				iny
.0184aa					_SEDone:
.0184aa	80 e1		bra $01848d			bra 	SkipEndOfCommand
.0184ac					_SOCExit:
.0184ac	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stack.asm

.0184ad					StackReset:
.0184ad	48		pha				pha
.0184ae	5a		phy				phy
.0184af	a9 ca		lda #$ca			lda 	#(BasicStack & $FF) 		; reset pointer
.0184b1	85 28		sta $28				sta 	zBasicSP
.0184b3	a9 05		lda #$05			lda 	#(BasicStack >> 8)
.0184b5	85 29		sta $29				sta 	zBasicSP+1
.0184b7	a0 00		ldy #$00			ldy 	#0 							; reset stack top to $00 which cannot
.0184b9	98		tya				tya 								; be a legal token, so any attempt to
.0184ba	91 28		sta ($28),y			sta 	(zBasicSP),y 				; test it will cause an error.
.0184bc	7a		ply				ply
.0184bd	68		pla				pla
.0184be	60		rts				rts
.0184bf					StackPushFrame:
.0184bf	48		pha				pha
.0184c0	5a		phy				phy
.0184c1	1a		inc a				inc 	a 							; one extra byte in frame, for the marker.
.0184c2	48		pha				pha 								; save it the framing byte.
.0184c3	29 0f		and #$0f			and 	#$0F 						; lower 4 bits, which is the length.
.0184c5	18		clc				clc 								; add to Basic Stack Pointer
.0184c6	65 28		adc $28				adc 	zBasicSP
.0184c8	85 28		sta $28				sta 	zBasicSP
.0184ca	90 02		bcc $0184ce			bcc 	_SPFNoBump
.0184cc	e6 29		inc $29				inc 	zBasicSP+1
.0184ce					_SPFNoBump:
.0184ce	a0 00		ldy #$00			ldy 	#0
.0184d0	68		pla				pla
.0184d1	91 28		sta ($28),y			sta 	(zBasicSP),y
.0184d3	7a		ply				ply
.0184d4	68		pla				pla
.0184d5	60		rts				rts
.0184d6					StackPopFrame:
.0184d6	48		pha				pha
.0184d7	5a		phy				phy
.0184d8	a0 00		ldy #$00			ldy 	#0 							; compare with top of stack using EOR
.0184da	51 28		eor ($28),y			eor 	(zBasicSP),y
.0184dc	29 f0		and #$f0			and 	#$F0 						; matches if the top 4 bits zero
.0184de	d0 12		bne $0184f2			bne 	SPFError 					; mixed structures 	(helpful message ...)
.0184e0	b1 28		lda ($28),y			lda 	(zBasicSP),y 				; get size from byte
.0184e2	29 0f		and #$0f			and 	#$0F
.0184e4	49 ff		eor #$ff			eor 	#$FF						; 2's complement
.0184e6	38		sec				sec		 							; add to stack pointer.
.0184e7	65 28		adc $28				adc 	zBasicSP
.0184e9	85 28		sta $28				sta 	zBasicSP
.0184eb	b0 02		bcs $0184ef			bcs 	_SPFNoBump
.0184ed	c6 29		dec $29				dec 	zBasicSP+1
.0184ef					_SPFNoBump:
.0184ef	7a		ply				ply
.0184f0	68		pla				pla
.0184f1	60		rts				rts
.0184f2					SPFError:
.0184f2	20 86 85	jsr $018586			jsr ERR_Handler
>0184f5	4d 69 78 65 64 20 53 74			.text "Mixed Structures",0
>0184fd	72 75 63 74 75 72 65 73 00
.018506					StackSavePosition:
.018506	98		tya				tya
.018507	5a		phy				phy
.018508	a0 05		ldy #$05			ldy 	#5
.01850a	91 28		sta ($28),y			sta 	(zBasicSP),y 				; save offset
.01850c	a0 01		ldy #$01			ldy 	#1
.01850e	a5 18		lda $18				lda 	zCodePtr+0 					; 4 bytes, could reduce this for 65816/6502
.018510	91 28		sta ($28),y			sta 	(zBasicSP),y 				; this is the physical memory position.
.018512	c8		iny				iny
.018513	a5 19		lda $19				lda 	zCodePtr+1
.018515	91 28		sta ($28),y			sta 	(zBasicSP),y
.018517	c8		iny				iny
.018518	a5 1a		lda $1a				lda 	zCodePtr+2
.01851a	91 28		sta ($28),y			sta 	(zBasicSP),y
.01851c	c8		iny				iny
.01851d	a5 1b		lda $1b				lda 	zCodePtr+3
.01851f	91 28		sta ($28),y			sta 	(zBasicSP),y
.018521	7a		ply				ply
.018522	60		rts				rts
.018523					StackRestorePosition:
.018523	5a		phy				phy
.018524	a0 01		ldy #$01			ldy 	#1 							; copy 4 bytes that are the pointer
.018526	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018528	85 18		sta $18				sta 	zCodePtr+0
.01852a	c8		iny				iny
.01852b	b1 28		lda ($28),y			lda 	(zBasicSP),y
.01852d	85 19		sta $19				sta 	zCodePtr+1
.01852f	c8		iny				iny
.018530	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018532	85 1a		sta $1a				sta 	zCodePtr+2
.018534	c8		iny				iny
.018535	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018537	85 1b		sta $1b				sta 	zCodePtr+3
.018539	c8		iny				iny
.01853a	b1 28		lda ($28),y			lda 	(zBasicSP),y 				; restore offset
.01853c	7a		ply				ply 								; restore Y
.01853d	a8		tay				tay
.01853e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/vectors.asm

.01853f					VIOCharPrint:
.01853f	4c 35 80	jmp $018035			jmp 	IFT_PrintCharacter
.018542					VIOCharGet:
.018542	20 e6 81	jsr $0181e6			jsr 	IF_GetKey
.018545	c9 00		cmp #$00			cmp 	#0
.018547	f0 02		beq $01854b			beq 	_VCG0
.018549	38		sec				sec
.01854a	60		rts				rts
.01854b	18		clc		_VCG0:	clc
.01854c	60		rts				rts
.01854d					VIOCheckBreak:
.01854d	4c e1 81	jmp $0181e1			jmp 	IF_CheckBreak
.018550					VIOCharGetPosition:
.018550	ad 00 05	lda $0500			lda 	IFT_XCursor
.018553	60		rts				rts
.018554					VIOReadLine:
.018554	4c f7 80	jmp $0180f7			jmp 	IFT_ReadLine

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/errors.asm

.018557					SyntaxError:
.018557	20 86 85	jsr $018586			jsr 	ERR_Handler
>01855a	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>018562	72 72 6f 72 00
.018567					TypeError:
.018567	20 86 85	jsr $018586			jsr 	ERR_Handler
>01856a	57 72 6f 6e 67 20 74 79				.text 	"Wrong type",0
>018572	70 65 00
.018575					BadParamError:
.018575	20 86 85	jsr $018586			jsr 	ERR_Handler
>018578	42 61 64 20 50 61 72 61				.text 	"Bad Parameter",0
>018580	6d 65 74 65 72 00
.018586					ERR_Handler:
.018586	a0 00		ldy #$00			ldy 	#0
.018588	c8		iny				iny
.018589	b7 18		lda [$18],y			lda 	[zCodePtr],y
.01858b	85 80		sta $80				sta 	XS_Mantissa
.01858d	c8		iny				iny
.01858e	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018590	85 81		sta $81				sta 	XS_Mantissa+1
.018592	fa		plx				plx 								; address in XY
.018593	7a		ply				ply
.018594	e8		inx				inx 								; bump, because of RTS/JSR address -1
.018595	d0 01		bne $018598			bne 	_EHNoSkip
.018597	c8		iny				iny
.018598					_EHNoSkip:
.018598	20 bc 85	jsr $0185bc			jsr 	PrintROMMessage 			; print message from ROM.
.01859b	a5 80		lda $80				lda 	XS_Mantissa					; line number = 0
.01859d	05 81		ora $81				ora 	XS_Mantissa+1
.01859f	f0 0c		beq $0185ad			beq 	_EHNoLine
.0185a1	a2 b7		ldx #$b7			ldx 	#_EHAt & $FF 				; print " at "
.0185a3	a0 85		ldy #$85			ldy 	#(_EHAt >> 8) & $FF
.0185a5	20 bc 85	jsr $0185bc			jsr 	PrintROMMessage
.0185a8	a2 00		ldx #$00			ldx 	#0 							; Print line number
.0185aa	20 d1 85	jsr $0185d1			jsr 	Print16BitInteger
.0185ad					_EHNoLine:
.0185ad	80 fe		bra $0185ad			bra 	_EHNoLine
.0185af	a9 0d		lda #$0d			lda 	#13
.0185b1	20 3f 85	jsr $01853f			jsr 	VIOCharPrint
.0185b4	4c 59 88	jmp $018859			jmp 	ErrorStart 					; normally warm start, no message.
>0185b7	20 61 74 20 00			_EHAt:	.text 	" at ",0
.0185bc					PrintROMMessage:
.0185bc	86 1c		stx $1c				stx 	zLTemp1 					; save addres
.0185be	84 1d		sty $1d				sty 	zLTemp1+1
.0185c0	4b		phk				phk 								; get current code page
.0185c1	68		pla				pla
.0185c2	85 1e		sta $1e				sta 	ZLTemp1+2 					; put into the 3rd byte so we can use
.0185c4	a0 00		ldy #$00			ldy 	#0
.0185c6					_PRMLoop:
.0185c6	b7 1c		lda [$1c],y			lda 	[zLTemp1],y 				; 65816
.0185c8	f0 06		beq $0185d0			beq		_PRMExit 					; character $00 => exit
.0185ca	c8		iny				iny  								; bump Y and print it.
.0185cb	20 3f 85	jsr $01853f			jsr 	VIOCharPrint
.0185ce	80 f6		bra $0185c6			bra 	_PRMLoop
.0185d0					_PRMExit:
.0185d0	60		rts				rts
.0185d1					Print16BitInteger:
.0185d1	a9 00		lda #$00			lda 	#0 							; make 32 bit
.0185d3	85 82		sta $82				sta 	XS_Mantissa+2
.0185d5	85 83		sta $83				sta 	XS_Mantissa+3
.0185d7					Print32BitInteger:
.0185d7	a9 00		lda #$00			lda 	#0
.0185d9	8d 14 03	sta $0314			sta 	NumBufX 					; reset the conversion pointer
.0185dc	aa		tax				tax 								; convert bottom level.
.0185dd	20 e6 a1	jsr $01a1e6			jsr 	INTToString 				; make string from integer in Num_Buffer
.0185e0	a2 00		ldx #$00			ldx 	#0 							; print buffer contents
.0185e2	bd 15 03	lda $0315,x	_P1Loop:lda 	Num_Buffer,x
.0185e5	f0 06		beq $0185ed			beq 	_P1Exit
.0185e7	20 3f 85	jsr $01853f			jsr 	VIOCharPrint
.0185ea	e8		inx				inx
.0185eb	80 f5		bra $0185e2			bra 	_P1Loop
.0185ed	8a		txa		_P1Exit:txa 								; return chars printed.
.0185ee	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm


;******  Processing file: modules/basic/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b6					lastUnaryFunction = $b6
.0185ef					VectorTable:
>0185ef	0f 94					.word BinaryOp_And         & $FFFF ; $80 and
>0185f1	2b 94					.word BinaryOp_Or          & $FFFF ; $81 or
>0185f3	47 94					.word BinaryOp_Xor         & $FFFF ; $82 xor
>0185f5	47 94					.word BinaryOp_Eor         & $FFFF ; $83 eor
>0185f7	7e 94					.word Binary_Equal         & $FFFF ; $84 =
>0185f9	87 94					.word Binary_NotEqual      & $FFFF ; $85 <>
>0185fb	90 94					.word Binary_Less          & $FFFF ; $86 <
>0185fd	99 94					.word Binary_LessEqual     & $FFFF ; $87 <=
>0185ff	ab 94					.word Binary_Greater       & $FFFF ; $88 >
>018601	a2 94					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>018603	43 95					.word BinaryOp_Add         & $FFFF ; $8a +
>018605	5f 95					.word BinaryOp_Subtract    & $FFFF ; $8b -
>018607	70 95					.word BinaryOp_Multiply    & $FFFF ; $8c *
>018609	81 95					.word BinaryOp_Divide      & $FFFF ; $8d /
>01860b	ad 86					.word NotImplemented       & $FFFF ; $8e ^
>01860d	9d 8d					.word Command_IF           & $FFFF ; $8f if
>01860f	0b 92					.word Command_WHILE        & $FFFF ; $90 while
>018611	33 92					.word Command_REPEAT       & $FFFF ; $91 repeat
>018613	ef 89					.word Command_FOR          & $FFFF ; $92 for
>018615	ad 86					.word NotImplemented       & $FFFF ; $93 then
>018617	fa 8d					.word Command_ENDIF        & $FFFF ; $94 endif
>018619	28 92					.word Command_WEND         & $FFFF ; $95 wend
>01861b	3c 92					.word Command_UNTIL        & $FFFF ; $96 until
>01861d	6c 8a					.word Command_NEXT         & $FFFF ; $97 next
>01861f	ad 86					.word NotImplemented       & $FFFF ; $98 not
>018621	ad 86					.word NotImplemented       & $FFFF ; $99 fn(
>018623	7c 96					.word Unary_Abs            & $FFFF ; $9a abs(
>018625	d7 97					.word Unary_Asc            & $FFFF ; $9b asc(
>018627	04 a9					.word Unary_Int            & $FFFF ; $9c int(
>018629	96 96					.word Unary_Peek           & $FFFF ; $9d peek(
>01862b	85 a8					.word Unary_Rnd            & $FFFF ; $9e rnd(
>01862d	09 97					.word Unary_Usr            & $FFFF ; $9f usr(
>01862f	16 98					.word Unary_Left           & $FFFF ; $a0 left$(
>018631	2b 98					.word Unary_Right          & $FFFF ; $a1 right$(
>018633	fd 97					.word Unary_Mid            & $FFFF ; $a2 mid$(
>018635	76 99					.word Unary_Spc            & $FFFF ; $a3 spc(
>018637	a5 97					.word Unary_Str            & $FFFF ; $a4 str$(
>018639	2a 97					.word Unary_Val            & $FFFF ; $a5 val(
>01863b	ee 97					.word Unary_Len            & $FFFF ; $a6 len(
>01863d	a3 98					.word Unary_Hex            & $FFFF ; $a7 hex$(
>01863f	ad 86					.word NotImplemented       & $FFFF ; $a8 sin(
>018641	ad 86					.word NotImplemented       & $FFFF ; $a9 cos(
>018643	ad 86					.word NotImplemented       & $FFFF ; $aa tan(
>018645	ad 86					.word NotImplemented       & $FFFF ; $ab atn(
>018647	ad 86					.word NotImplemented       & $FFFF ; $ac exp(
>018649	ad 86					.word NotImplemented       & $FFFF ; $ad log(
>01864b	ad 86					.word NotImplemented       & $FFFF ; $ae sqr(
>01864d	f9 98					.word Unary_Dec            & $FFFF ; $af dec(
>01864f	9a 96					.word Unary_Deek           & $FFFF ; $b0 deek(
>018651	9e 96					.word Unary_Leek           & $FFFF ; $b1 leek(
>018653	d6 96					.word Unary_Mod            & $FFFF ; $b2 mod(
>018655	36 96					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>018657	58 99					.word Unary_Chr            & $FFFF ; $b4 chr$(
>018659	ca 96					.word Unary_Pos            & $FFFF ; $b5 pos(
>01865b	99 99					.word Unary_Tab            & $FFFF ; $b6 tab(
>01865d	ad 86					.word NotImplemented       & $FFFF ; $b7 $
>01865f	ad 86					.word NotImplemented       & $FFFF ; $b8 $(
>018661	ad 86					.word NotImplemented       & $FFFF ; $b9 #
>018663	ad 86					.word NotImplemented       & $FFFF ; $ba #(
>018665	ad 86					.word NotImplemented       & $FFFF ; $bb %
>018667	ad 86					.word NotImplemented       & $FFFF ; $bc %(
>018669	ad 86					.word NotImplemented       & $FFFF ; $bd (
>01866b	ad 86					.word NotImplemented       & $FFFF ; $be )
>01866d	ad 86					.word NotImplemented       & $FFFF ; $bf ,
>01866f	ee 89					.word Command_COLON        & $FFFF ; $c0 :
>018671	ad 86					.word NotImplemented       & $FFFF ; $c1 ;
>018673	ad 86					.word NotImplemented       & $FFFF ; $c2 def
>018675	ec 91					.word Command_CLR          & $FFFF ; $c3 clr
>018677	03 92					.word Command_STOP         & $FFFF ; $c4 stop
>018679	45 8b					.word Command_DATA         & $FFFF ; $c5 data
>01867b	1f 8b					.word Command_READ         & $FFFF ; $c6 read
>01867d	95 88					.word Command_DIM          & $FFFF ; $c7 dim
>01867f	ad 86					.word NotImplemented       & $FFFF ; $c8 to
>018681	ad 86					.word NotImplemented       & $FFFF ; $c9 step
>018683	32 91					.word Command_GOSUB        & $FFFF ; $ca gosub
>018685	42 91					.word Command_RETURN       & $FFFF ; $cb return
>018687	2a 91					.word Command_GOTO         & $FFFF ; $cc goto
>018689	99 8d					.word Command_END          & $FFFF ; $cd end
>01868b	68 8c					.word Command_INPUT        & $FFFF ; $ce input
>01868d	e3 8b					.word Command_LET          & $FFFF ; $cf let
>01868f	00 8e					.word Command_LIST         & $FFFF ; $d0 list
>018691	d4 90					.word Command_NEW          & $FFFF ; $d1 new
>018693	f0 90					.word Command_OLD          & $FFFF ; $d2 old
>018695	4b 91					.word Command_ON           & $FFFF ; $d3 on
>018697	48 8b					.word Command_RESTORE      & $FFFF ; $d4 restore
>018699	a3 90					.word Command_POKE         & $FFFF ; $d5 poke
>01869b	f4 8f					.word Command_PRINT        & $FFFF ; $d6 print
>01869d	60 89					.word Command_RUN          & $FFFF ; $d7 run
>01869f	20 89					.word Command_WAIT         & $FFFF ; $d8 wait
>0186a1	4e 8c					.word Command_SYS          & $FFFF ; $d9 sys
>0186a3	a7 90					.word Command_DOKE         & $FFFF ; $da doke
>0186a5	ab 90					.word Command_LOKE         & $FFFF ; $db loke
>0186a7	8b 90					.word Command_ASSERT       & $FFFF ; $dc assert
>0186a9	04 8c					.word Command_GET          & $FFFF ; $dd get
>0186ab	f4 8d					.word Command_ELSE         & $FFFF ; $de else
.0186ad					NotImplemented:
.0186ad	20 86 85	jsr $018586			jsr ERR_Handler
>0186b0	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>0186b8	65 6d 65 6e 74 65 64 00
.0186c0					BinaryPrecedence:
>0186c0	01					.byte 1    ; $80 and
>0186c1	01					.byte 1    ; $81 or
>0186c2	01					.byte 1    ; $82 xor
>0186c3	01					.byte 1    ; $83 eor
>0186c4	02					.byte 2    ; $84 =
>0186c5	02					.byte 2    ; $85 <>
>0186c6	02					.byte 2    ; $86 <
>0186c7	02					.byte 2    ; $87 <=
>0186c8	02					.byte 2    ; $88 >
>0186c9	02					.byte 2    ; $89 >=
>0186ca	03					.byte 3    ; $8a +
>0186cb	03					.byte 3    ; $8b -
>0186cc	04					.byte 4    ; $8c *
>0186cd	04					.byte 4    ; $8d /
>0186ce	05					.byte 5    ; $8e ^
.0186cf					KeywordText:
>0186cf	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>0186d2	4f d2					.byte $4f,$d2                          ; $81 or
>0186d4	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>0186d7	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>0186da	bd					.byte $bd                              ; $84 =
>0186db	3c be					.byte $3c,$be                          ; $85 <>
>0186dd	bc					.byte $bc                              ; $86 <
>0186de	3c bd					.byte $3c,$bd                          ; $87 <=
>0186e0	be					.byte $be                              ; $88 >
>0186e1	3e bd					.byte $3e,$bd                          ; $89 >=
>0186e3	ab					.byte $ab                              ; $8a +
>0186e4	ad					.byte $ad                              ; $8b -
>0186e5	aa					.byte $aa                              ; $8c *
>0186e6	af					.byte $af                              ; $8d /
>0186e7	de					.byte $de                              ; $8e ^
>0186e8	49 c6					.byte $49,$c6                          ; $8f if
>0186ea	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>0186ef	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>0186f5	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>0186f8	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>0186fc	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>018701	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>018705	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>01870a	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>01870e	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>018711	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>018714	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>018718	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>01871c	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>018720	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>018725	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>018729	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>01872d	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>018733	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>01873a	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>01873f	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>018743	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>018748	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>01874c	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>018750	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>018755	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>018759	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>01875d	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>018761	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>018765	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>018769	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>01876d	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>018771	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>018775	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>01877a	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>01877f	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>018783	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>018787	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>01878c	50 4f 53 a8				.byte $50,$4f,$53,$a8                  ; $b5 pos(
>018790	54 41 42 a8				.byte $54,$41,$42,$a8                  ; $b6 tab(
>018794	a4					.byte $a4                              ; $b7 $
>018795	24 a8					.byte $24,$a8                          ; $b8 $(
>018797	a3					.byte $a3                              ; $b9 #
>018798	23 a8					.byte $23,$a8                          ; $ba #(
>01879a	a5					.byte $a5                              ; $bb %
>01879b	25 a8					.byte $25,$a8                          ; $bc %(
>01879d	a8					.byte $a8                              ; $bd (
>01879e	a9					.byte $a9                              ; $be )
>01879f	ac					.byte $ac                              ; $bf ,
>0187a0	ba					.byte $ba                              ; $c0 :
>0187a1	bb					.byte $bb                              ; $c1 ;
>0187a2	44 45 c6				.byte $44,$45,$c6                      ; $c2 def
>0187a5	43 4c d2				.byte $43,$4c,$d2                      ; $c3 clr
>0187a8	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $c4 stop
>0187ac	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c5 data
>0187b0	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c6 read
>0187b4	44 49 cd				.byte $44,$49,$cd                      ; $c7 dim
>0187b7	54 cf					.byte $54,$cf                          ; $c8 to
>0187b9	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c9 step
>0187bd	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $ca gosub
>0187c2	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $cb return
>0187c8	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $cc goto
>0187cc	45 4e c4				.byte $45,$4e,$c4                      ; $cd end
>0187cf	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $ce input
>0187d4	4c 45 d4				.byte $4c,$45,$d4                      ; $cf let
>0187d7	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $d0 list
>0187db	4e 45 d7				.byte $4e,$45,$d7                      ; $d1 new
>0187de	4f 4c c4				.byte $4f,$4c,$c4                      ; $d2 old
>0187e1	4f ce					.byte $4f,$ce                          ; $d3 on
>0187e3	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d4 restore
>0187ea	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d5 poke
>0187ee	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d6 print
>0187f3	52 55 ce				.byte $52,$55,$ce                      ; $d7 run
>0187f6	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d8 wait
>0187fa	53 59 d3				.byte $53,$59,$d3                      ; $d9 sys
>0187fd	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $da doke
>018801	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $db loke
>018805	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $dc assert
>01880b	47 45 d4				.byte $47,$45,$d4                      ; $dd get
>01880e	45 4c 53 c5				.byte $45,$4c,$53,$c5                  ; $de else
>018812	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_pos = $b5
=$b6					token_tab = $b6
=$b7					token_dollar = $b7
=$b8					token_dollarlparen = $b8
=$b9					token_hash = $b9
=$ba					token_hashlparen = $ba
=$bb					token_percent = $bb
=$bc					token_percentlparen = $bc
=$bd					token_lparen = $bd
=$be					token_rparen = $be
=$bf					token_comma = $bf
=$c0					token_colon = $c0
=$c1					token_semicolon = $c1
=$c2					token_def = $c2
=$c3					token_clr = $c3
=$c4					token_stop = $c4
=$c5					token_data = $c5
=$c6					token_read = $c6
=$c7					token_dim = $c7
=$c8					token_to = $c8
=$c9					token_step = $c9
=$ca					token_gosub = $ca
=$cb					token_return = $cb
=$cc					token_goto = $cc
=$cd					token_end = $cd
=$ce					token_input = $ce
=$cf					token_let = $cf
=$d0					token_list = $d0
=$d1					token_new = $d1
=$d2					token_old = $d2
=$d3					token_on = $d3
=$d4					token_restore = $d4
=$d5					token_poke = $d5
=$d6					token_print = $d6
=$d7					token_run = $d7
=$d8					token_wait = $d8
=$d9					token_sys = $d9
=$da					token_doke = $da
=$db					token_loke = $db
=$dc					token_assert = $dc
=$dd					token_get = $dd
=$de					token_else = $de

;******  Return to file: modules/basic/core.asm

.018813					BASIC_Start:
.018813	c2 30		rep #$30			rep 	#$30
.018815	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.018818	1b		tcs				tcs
.018819	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.01881c	e2 30		sep #$30			sep 	#$30
.01881e	20 a8 81	jsr $0181a8			jsr 	IF_Reset 					; set up and clear screen.
.018821	20 00 80	jsr $018000			jsr 	IFT_ClearScreen
.018824	a9 5c		lda #$5c			lda 	#$5C 						; JMP Long opcode
.018826	8d 10 03	sta $0310			sta 	LocalVector
.018829	8d 0c 03	sta $030c			sta 	UserVector
.01882c	a9 18		lda #$18			lda 	#USRDefault & $FF 			; reset USR vector to a default
.01882e	8d 0d 03	sta $030d			sta 	UserVector+1 				; 24 / 16 bit address
.018831	a9 97		lda #$97			lda 	#(USRDefault >> 8) & $FF 	; e.g. it becomes JMP USRDefault
.018833	8d 0e 03	sta $030e			sta 	UserVector+2
.018836	a9 01		lda #$01			lda 	#(USRDefault >> 16) & $FF
.018838	8d 0f 03	sta $030f			sta 	UserVector+3
.01883b	20 e3 99	jsr $0199e3			jsr 	UpdateProgramEnd 			; update the program end.
.01883e	20 ec 91	jsr $0191ec			jsr 	ResetRunStatus 				; clear everything (CLR command)
.018841	c2 30		rep #$30			rep 	#$30
.018843	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.018846	1b		tcs				tcs
.018847	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.01884a	e2 30		sep #$30			sep 	#$30
.01884c	4c 52 88	jmp $018852			jmp 	WarmStart
.01884f	20 d4 90	jsr $0190d4			jsr 	Command_NEW 				; new command, will not return.
.018852					WarmStart:
.018852	a2 8a		ldx #$8a			ldx 	#ReadyMsg & $FF 			; Print READY.
.018854	a0 88		ldy #$88			ldy 	#(ReadyMsg >> 8) & $FF
.018856	20 bc 85	jsr $0185bc			jsr 	PrintROMMessage
.018859					ErrorStart:
.018859	c2 30		rep #$30			rep 	#$30
.01885b	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.01885e	1b		tcs				tcs
.01885f	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.018862	e2 30		sep #$30			sep 	#$30
.018864	20 f7 80	jsr $0180f7			jsr 	IFT_ReadLine 				; read line in.
.018867	a9 66		lda #$66			lda 	#IFT_LineBuffer & $FF 		; tokenise it.
.018869	a2 05		ldx #$05			ldx 	#IFT_LineBuffer >> 8
.01886b	20 7a 9b	jsr $019b7a			jsr 	TokeniseString
.01886e	ad 03 04	lda $0403			lda 	TokeniseBuffer+3 			; what is first.
.018871	29 c0		and #$c0			and 	#$C0 						; is it a number 4000-7FFF
.018873	c9 40		cmp #$40			cmp 	#$40
.018875	f0 1b		beq $018892			beq 	EditLine 					; if true, go to edit line (delete/insert)
.018877	a9 00		lda #$00			lda 	#(TokeniseBuffer) & $FF
.018879	85 18		sta $18				sta 	zCodePtr+0
.01887b	a9 04		lda #$04			lda 	#((TokeniseBuffer) >> 8) & $FF
.01887d	85 19		sta $19				sta 	zCodePtr+1
.01887f	a9 00		lda #$00			lda 	#(TokeniseBuffer) >> 16
.018881	85 1a		sta $1a				sta 	zCodePtr+2
.018883	85 1b		sta $1b				sta 	zCodePtr+3
.018885	a0 03		ldy #$03			ldy 	#3
.018887	4c 94 89	jmp $018994			jmp 	RUN_NextCommand
.01888a					ReadyMsg:
>01888a	52 65 61 64 79 2e 0d 00				.text 	"Ready.",13,0
.018892					EditLine:
.018892	4c e0 99	jmp $0199e0			jmp 	EditCode

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/dim.asm

.018895					Command_DIM:
.018895	98		tya				tya
.018896	48		pha				pha 								; push on stack.
.018897	20 6f 9d	jsr $019d6f			jsr 	VariableExtract 			; get the identifier
.01889a	ad 95 03	lda $0395			lda 	Var_Type 					; check it is an array
.01889d	29 01		and #$01			and 	#1
.01889f	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.0188a1	d0 6f		bne $018912			bne 	_CDIError
.0188a3	a9 00		lda #$00			lda 	#0 							; reset the DIM index. The dimensions are
.0188a5	8d b9 03	sta $03b9			sta 	UsrArrayIdx 				; built up here and copied in case we autodim
.0188a8					_CDIGetDimension:
.0188a8	ad b9 03	lda $03b9			lda 	UsrArrayIdx 				; done too many ?
.0188ab	c9 06		cmp #$06			cmp 	#ArrayMaxDim*2
.0188ad	f0 63		beq $018912			beq 	_CDIError
.0188af	20 f0 93	jsr $0193f0			jsr 	EvaluateInteger 			; evaluate an index size
.0188b2	a5 81		lda $81				lda 	XS_Mantissa+1 				; check in range 0-7FFF
.0188b4	29 80		and #$80			and 	#$80
.0188b6	05 82		ora $82				ora 	XS_Mantissa+2
.0188b8	05 83		ora $83				ora 	XS_Mantissa+3
.0188ba	d0 56		bne $018912			bne 	_CDIError
.0188bc	ae b9 03	ldx $03b9			ldx 	UsrArrayIdx 				; copy into the array table.
.0188bf	18		clc				clc 								; add 1 - max index => size.
.0188c0	a5 80		lda $80				lda 	XS_Mantissa+0
.0188c2	69 01		adc #$01			adc 	#1
.0188c4	9d b1 03	sta $03b1,x			sta 	UsrArrayDef+0,x
.0188c7	a5 81		lda $81				lda 	XS_Mantissa+1
.0188c9	69 00		adc #$00			adc 	#0
.0188cb	9d b2 03	sta $03b2,x			sta 	UsrArrayDef+1,x
.0188ce	30 42		bmi $018912			bmi 	_CDIError 					; could be dim a(32767)
.0188d0	e8		inx				inx 								; bump index.
.0188d1	e8		inx				inx
.0188d2	8e b9 03	stx $03b9			stx 	UsrArrayIdx
.0188d5	b7 18		lda [$18],y			lda 	[zCodePtr],y
.0188d7	c8		iny				iny
.0188d8	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another dimension
.0188da	f0 cc		beq $0188a8			beq 	_CDIGetDimension
.0188dc	88		dey				dey
.0188dd	20 3f 9a	jsr $019a3f			jsr 	CheckNextRParen 			; closing ) present ?
.0188e0	ae b9 03	ldx $03b9			ldx 	UsrArrayIdx 				; copy USR array to default
.0188e3	a9 ff		lda #$ff			lda 	#$FF 						; put end marker in ArrayDef
.0188e5	9d aa 03	sta $03aa,x			sta 	ArrayDef+1,x
.0188e8					_CDICopy:
.0188e8	bd b1 03	lda $03b1,x			lda 	UsrArrayDef,x
.0188eb	9d a9 03	sta $03a9,x			sta 	ArrayDef,x
.0188ee	ca		dex				dex
.0188ef	10 f7		bpl $0188e8			bpl 	_CDICopy
.0188f1	68		pla				pla									; position of array identifier
.0188f2	85 10		sta $10				sta 	zTemp1
.0188f4	98		tya				tya
.0188f5	48		pha				pha
.0188f6	a5 10		lda $10				lda 	zTemp1 						; point to identifier
.0188f8	a8		tay				tay
.0188f9	20 6f 9d	jsr $019d6f			jsr 	VariableExtract 			; get the identifier
.0188fc	20 08 a0	jsr $01a008			jsr 	VariableLocate 				; check if it exists already.
.0188ff	b0 11		bcs $018912			bcs 	_CDIError
.018901	20 fb 9d	jsr $019dfb			jsr 	VariableCreate 				; create it using the current ArrayDef
.018904	68		pla				pla 								; restore code position
.018905	a8		tay				tay
.018906	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018908	c8		iny				iny
.018909	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another DIM
.01890b	f0 88		beq $018895			beq 	Command_DIM
.01890d	88		dey				dey
.01890e	20 0a 9f	jsr $019f0a			jsr 	ArrayResetDefault 			; subsequent automatic DIMs will be (10)
.018911	60		rts				rts
.018912					_CDIError:
.018912	20 86 85	jsr $018586			jsr ERR_Handler
>018915	42 61 64 20 44 49 4d 00			.text "Bad DIM",0
.01891d					_CDISyntax:
.01891d	4c 57 85	jmp $018557			jmp 	SyntaxError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/wait.asm

.018920					Command_WAIT:
.018920	20 f0 93	jsr $0193f0			jsr		EvaluateInteger 			; get address to monitor
.018923	a2 06		ldx #$06			ldx 	#XS_Size 					; get and mask
.018925	20 47 9a	jsr $019a47			jsr 	CheckNextComma
.018928	20 f2 93	jsr $0193f2			jsr 	EvaluateIntegerX
.01892b	a9 00		lda #$00			lda 	#0							; set default xor value.
.01892d	85 8c		sta $8c				sta 	XS_Mantissa+XS_Size*2
.01892f	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018931	c9 bf		cmp #$bf			cmp 	#token_Comma 				; no use the default
.018933	d0 06		bne $01893b			bne 	_CWAXorDefault
.018935	c8		iny				iny
.018936	a2 0c		ldx #$0c			ldx 	#XS_Size*2					; and get the xor value
.018938	20 f2 93	jsr $0193f2			jsr 	EvaluateIntegerX
.01893b					_CWAXorDefault:
.01893b	a5 80		lda $80				lda 	XS_Mantissa 				; copy 24 bits of mantissa to ZLTemp1
.01893d	85 1c		sta $1c				sta 	zLTemp1
.01893f	a5 81		lda $81				lda 	XS_Mantissa+1
.018941	85 1d		sta $1d				sta 	zLTemp1+1
.018943	a5 82		lda $82				lda 	XS_Mantissa+2
.018945	85 1e		sta $1e				sta 	zLTemp1+2
.018947					_CWAWaitLoop:
.018947	20 4d 85	jsr $01854d			jsr 	VIOCheckBreak 				; exit on break.
.01894a	c9 00		cmp #$00			cmp 	#0
.01894c	d0 11		bne $01895f			bne 	_CWAWaitExit
.01894e	a9 01		lda #$01			lda 	#1							; read 1 byte to mantissa/0
.018950	a2 00		ldx #$00			ldx 	#0
.018952	5a		phy				phy 								; this is the same routine as PEEK.
.018953	20 be 99	jsr $0199be			jsr 	MemRead
.018956	7a		ply				ply
.018957	a5 80		lda $80				lda 	XS_Mantissa+0 				; get byte
.018959	25 86		and $86				and 	XS_Mantissa+XS_Size 		; and it
.01895b	45 8c		eor $8c				eor 	XS_Mantissa+XS_Size*2		; eor it.
.01895d	f0 e8		beq $018947			beq 	_CWAWaitLoop 				; and loop if zero.
.01895f					_CWAWaitExit:
.01895f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/run.asm

.018960					Command_RUN:
.018960	20 ec 91	jsr $0191ec			jsr 	ResetRunStatus 				; clear, reset stacks etc.
.018963	a9 00		lda #$00			lda 	#(BasicProgram) & $FF
.018965	85 18		sta $18				sta 	zCodePtr+0
.018967	a9 20		lda #$20			lda 	#((BasicProgram) >> 8) & $FF
.018969	85 19		sta $19				sta 	zCodePtr+1
.01896b	a9 01		lda #$01			lda 	#(BasicProgram) >> 16
.01896d	85 1a		sta $1a				sta 	zCodePtr+2
.01896f	85 1b		sta $1b				sta 	zCodePtr+3
.018971	a0 03		ldy #$03			ldy 	#3
.018973					RUN_NewLine:
.018973	a0 00		ldy #$00			ldy 	#0
.018975	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018977	c8		iny				iny
.018978	c8		iny				iny
.018979	c8		iny				iny
.01897a	c9 00		cmp #$00			cmp 	#0 							; if the offset is zero then END.
.01897c	d0 16		bne $018994			bne 	RUN_NextCommand
.01897e	4c 99 8d	jmp $018d99			jmp 	Command_END 				; go do the command code.
.018981					RUN_Skip:
.018981	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read element
.018983	c8		iny				iny 								; skip
.018984	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018986	90 0c		bcc $018994			bcc 	_SEDone 					; so just skip over it.
.018988	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.01898a	90 07		bcc $018993			bcc 	_SEDouble
.01898c	98		tya				tya 								; this is Y + 1
.01898d	18		clc				clc
.01898e	77 18		adc [$18],y			adc 	[zCodePtr],y 				; add total length of element
.018990	a8		tay				tay 								; back in Y.
.018991	88		dey				dey 								; fix up, one for the +1, one for the iny
.018992	88		dey				dey
.018993					_SEDouble:
.018993	c8		iny				iny
.018994					_SEDone:
.018994					RUN_NextCommand:
.018994	ad a8 03	lda $03a8			lda 	BreakCount 					; check the break counter
.018997	69 10		adc #$10			adc 	#16 						; one time in 16
.018999	8d a8 03	sta $03a8			sta 	BreakCount
.01899c	90 0a		bcc $0189a8			bcc 	RUN_NoCheckBreak
.01899e	20 4d 85	jsr $01854d			jsr 	VIOCheckBreak 				; check for break
.0189a1	c9 00		cmp #$00			cmp 	#0
.0189a3	f0 03		beq $0189a8			beq 	RUN_NoCheckBreak
.0189a5	4c 03 92	jmp $019203			jmp 	Command_STOP 				; stop on BREAK.
.0189a8					RUN_NoCheckBreak:
.0189a8	a9 00		lda #$00			lda 	#0 							; this resets temporary string allocation.
.0189aa	85 23		sta $23				sta 	zTempStr+1 					; (initialised when first called)
.0189ac	b7 18		lda [$18],y			lda 	[zCodePtr],y
.0189ae	c9 c0		cmp #$c0			cmp 	#token_Colon 				; skip over colons
.0189b0	f0 cf		beq $018981			beq 	RUN_Skip
.0189b2	c9 00		cmp #$00			cmp 	#0 							; if non-zero execute whatever
.0189b4	d0 0f		bne $0189c5			bne 	RUN_Execute		 			; zero => end of the current line.
.0189b6					RUN_NextLine:
.0189b6	a0 00		ldy #$00			ldy 	#0 							; point to offset
.0189b8	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read it
.0189ba	18		clc				clc
.0189bb	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.0189bd	85 18		sta $18				sta 	zCodePtr
.0189bf	90 02		bcc $0189c3			bcc 	_SNLNoCarry
.0189c1	e6 19		inc $19				inc 	zCodePtr+1
.0189c3					_SNLNoCarry:
.0189c3	80 ae		bra $018973			bra 	RUN_NewLine 				; go do the new line code
.0189c5					RUN_Execute:
.0189c5	c9 f8		cmp #$f8			cmp 	#$F8 						; handle shifts, REM etc.
.0189c7	b0 1e		bcs $0189e7			bcs 	RUN_Extension
.0189c9	c8		iny				iny
.0189ca	0a		asl a				asl 	a 							; double the character read.
.0189cb	90 14		bcc $0189e1			bcc 	RUN_Default 				; if carry clear was $00-$7F, so try LET.
.0189cd	aa		tax				tax 								; ready to look up.
.0189ce	bf ef 85 01	lda $0185ef,x			lda 	VectorTable,x 				; copy address into LocalVector
.0189d2	8d 11 03	sta $0311			sta 	LocalVector+1
.0189d5	bf f0 85 01	lda $0185f0,x			lda 	VectorTable+1,x
.0189d9	8d 12 03	sta $0312			sta 	LocalVector+2
.0189dc	20 3d 93	jsr $01933d			jsr 	EVCallLocalVector 			; execute the appropriate code.
.0189df	80 b3		bra $018994			bra 	RUN_NextCommand 			; do the next command.
.0189e1					RUN_Default:
.0189e1	88		dey				dey
.0189e2	20 e3 8b	jsr $018be3			jsr 	Command_LET 				; and try LET.
.0189e5	80 ad		bra $018994			bra 	RUN_NextCommand
.0189e7					RUN_Extension:
.0189e7	c9 ff		cmp #$ff			cmp 	#$FF 						; if $FF (REM)
.0189e9	f0 96		beq $018981			beq 	RUN_Skip 					; skip over it
.0189eb	4c 57 85	jmp $018557			jmp 	SyntaxError
.0189ee					Command_COLON:
.0189ee	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/for.asm

.0189ef					Command_FOR:
.0189ef	20 e3 8b	jsr $018be3			jsr 	Command_LET 				; do the A = 99 bit
.0189f2	a5 26		lda $26				lda 	zVarType 					; obviously has to be integer/real.
.0189f4	c9 b7		cmp #$b7			cmp 	#token_Dollar
.0189f6	f0 71		beq $018a69			beq 	_CFOError
.0189f8	48		pha				pha 								; save the variable type.
.0189f9	5a		phy				phy 								; save type/variable address.
.0189fa	a0 01		ldy #$01			ldy 	#1							; type at + 1
.0189fc	91 28		sta ($28),y			sta 	(zBasicSP),y
.0189fe	c8		iny				iny
.0189ff	a5 24		lda $24				lda 	zVarDataPtr 				; data low at +2
.018a01	91 28		sta ($28),y			sta 	(zBasicSP),y
.018a03	c8		iny				iny
.018a04	a5 25		lda $25				lda 	zVarDataPtr+1 				; data high at +3
.018a06	91 28		sta ($28),y			sta 	(zBasicSP),y
.018a08	7a		ply				ply
.018a09	a9 53		lda #$53			lda 	#(SMark_For << 4) + 3
.018a0b	20 bf 84	jsr $0184bf			jsr 	StackPushFrame 				; push on the stack with FOR marker.
.018a0e	a9 c8		lda #$c8			lda 	#token_TO
.018a10	20 28 9a	jsr $019a28			jsr 	CheckNextToken
.018a13	a2 00		ldx #$00			ldx 	#0 							; put in Mantissa, bottom
.018a15	20 5a 92	jsr $01925a			jsr 	EvaluateExpression
.018a18	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018a1a	a2 06		ldx #$06			ldx 	#XS_Size 					; X to second level
.018a1c	c9 c9		cmp #$c9			cmp 	#token_STEP
.018a1e	d0 06		bne $018a26			bne 	_CFOStep1
.018a20	c8		iny				iny
.018a21	20 5c 92	jsr $01925c			jsr 	EvaluateExpressionX 		; get STEP value.
.018a24	80 0e		bra $018a34			bra 	_CFOHaveStep
.018a26					_CFOStep1:
.018a26	a9 00		lda #$00			lda 	#0							; set step to integer 1.
.018a28	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018a2a	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.018a2c	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018a2e	a9 01		lda #$01			lda 	#1
.018a30	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018a32	95 85		sta $85,x			sta 	XS_Type,x
.018a34					_CFOHaveStep:
.018a34	68		pla				pla 								; restore variable type
.018a35	a2 00		ldx #$00			ldx 	#0
.018a37	c9 bb		cmp #$bb			cmp 	#token_Percent 				; do conversion to type
.018a39	f0 0a		beq $018a45			beq 	_CFOInteger
.018a3b	20 05 a6	jsr $01a605			jsr 	FPUToFloat
.018a3e	a2 06		ldx #$06			ldx 	#6
.018a40	20 05 a6	jsr $01a605			jsr 	FPUToFloat
.018a43	80 08		bra $018a4d			bra 	_CFOEndConv
.018a45					_CFOInteger:
.018a45	20 51 a6	jsr $01a651			jsr 	FPUToInteger
.018a48	a2 06		ldx #$06			ldx 	#6
.018a4a	20 51 a6	jsr $01a651			jsr 	FPUToInteger
.018a4d					_CFOEndConv:
.018a4d	20 06 85	jsr $018506			jsr 	StackSavePosition 			; save the loop position at 1-5
.018a50	a9 55		lda #$55			lda 	#(SMark_For << 4)+SourcePosSize
.018a52	20 bf 84	jsr $0184bf			jsr 	StackPushFrame 				; push the loop address frame.
.018a55	5a		phy				phy
.018a56	a0 00		ldy #$00			ldy 	#0
.018a58					_CFOCopy:
.018a58	b9 80 00	lda $0080,y			lda 	XS_Mantissa+0,y
.018a5b	c8		iny				iny
.018a5c	91 28		sta ($28),y			sta 	(zBasicSP),y
.018a5e	c0 0c		cpy #$0c			cpy 	#XS_Size*2
.018a60	d0 f6		bne $018a58			bne 	_CFOCopy
.018a62	7a		ply				ply
.018a63	a9 5c		lda #$5c			lda 	#(SMark_For << 4)+(XS_Size*2)
.018a65	20 bf 84	jsr $0184bf			jsr 	StackPushFrame
.018a68	60		rts				rts
.018a69					_CFOError:
.018a69	4c 67 85	jmp $018567			jmp 	TypeError 					; wrong type.
.018a6c					Command_NEXT:
.018a6c	a9 00		lda #$00			lda 	#0 							; set variable data pointer+1 to zero
.018a6e	85 25		sta $25				sta 	zVarDataPtr+1 				; this means we don't check
.018a70	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018a72	c9 00		cmp #$00			cmp 	#0 							; EOL
.018a74	f0 07		beq $018a7d			beq 	_CNextNoVariable
.018a76	c9 40		cmp #$40			cmp 	#$40
.018a78	b0 03		bcs $018a7d			bcs 	_CNextNoVariable
.018a7a	20 04 9d	jsr $019d04			jsr 	VariableFind
.018a7d					_CNextNoVariable:
.018a7d	a5 28		lda $28				lda 	zBasicSP 					; save on stack
.018a7f	48		pha				pha
.018a80	a5 29		lda $29				lda 	zBasicSP+1
.018a82	48		pha				pha
.018a83	a9 50		lda #$50			lda 	#(SMark_For << 4) 			; pop loop address frame
.018a85	20 d6 84	jsr $0184d6			jsr 	StackPopFrame
.018a88	a9 50		lda #$50			lda 	#(SMark_For << 4) 			; pop STEP/TARGET frame.
.018a8a	20 d6 84	jsr $0184d6			jsr 	StackPopFrame
.018a8d	a9 50		lda #$50			lda 	#(Smark_For << 4) 			; pop variable address frame.
.018a8f	20 d6 84	jsr $0184d6			jsr 	StackPopFrame
.018a92	a5 25		lda $25				lda 	zVarDataPtr+1 				; if zero, then no variable provided
.018a94	f0 11		beq $018aa7			beq 	_CNextGetTarget 			; e.g. just NEXT not NEXT x
.018a96	5a		phy				phy 								; check addresses match.
.018a97	a0 02		ldy #$02			ldy 	#2
.018a99	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018a9b	c5 24		cmp $24				cmp 	zVarDataPtr
.018a9d	d0 69		bne $018b08			bne 	_CNextWrong
.018a9f	c8		iny				iny
.018aa0	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018aa2	c5 25		cmp $25				cmp 	zVarDataPtr+1
.018aa4	d0 62		bne $018b08			bne 	_CNextWrong
.018aa6	7a		ply				ply
.018aa7					_CNextGetTarget:
.018aa7	5a		phy				phy
.018aa8	a0 01		ldy #$01			ldy 	#1 							; restore variable type and data.
.018aaa	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018aac	85 26		sta $26				sta 	zVarType
.018aae	c8		iny				iny
.018aaf	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018ab1	85 24		sta $24				sta 	zVarDataPtr
.018ab3	c8		iny				iny
.018ab4	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018ab6	85 25		sta $25				sta 	zVarDataPtr+1
.018ab8	a2 0c		ldx #$0c			ldx 	#12
.018aba	20 4c a0	jsr $01a04c			jsr 	VariableGet 				; get that variable value into expr[2]
.018abd	a2 00		ldx #$00			ldx 	#0 							; copy stacked Target/Step into expr[0] and [1]
.018abf	a0 0b		ldy #$0b			ldy 	#11
.018ac1					_CNXCopy:
.018ac1	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018ac3	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018ac5	e8		inx				inx
.018ac6	c8		iny				iny
.018ac7	e0 0c		cpx #$0c			cpx 	#XS_Size*2
.018ac9	d0 f6		bne $018ac1			bne 	_CNXCopy
.018acb	7a		ply				ply
.018acc	a2 06		ldx #$06			ldx 	#6 							; point at expr[1] s
.018ace	20 5a 96	jsr $01965a			jsr 	GetSignCurrent
.018ad1	8d a7 03	sta $03a7			sta 	SignNext 					; save in temporary.
.018ad4	a2 06		ldx #$06			ldx 	#6 							; add them, however
.018ad6	20 43 95	jsr $019543			jsr 	BinaryOp_Add
.018ad9	20 9d a0	jsr $01a09d			jsr 	VariableSet					; and write variable back.
.018adc	a2 00		ldx #$00			ldx 	#0
.018ade	20 c7 94	jsr $0194c7			jsr 	CompareValues
.018ae1	09 00		ora #$00			ora 	#0
.018ae3	f0 05		beq $018aea			beq 	_CNXAgain 					; if true, then do it again.
.018ae5	cd a7 03	cmp $03a7			cmp 	SignNext 					; if sign different, then loop has finished.
.018ae8	d0 0f		bne $018af9			bne 	_CNXLoopDone
.018aea					_CNXAgain:
.018aea	a9 53		lda #$53			lda 	#(SMark_For << 4) + 3		; re-stack variable address
.018aec	20 bf 84	jsr $0184bf			jsr 	StackPushFrame
.018aef	20 23 85	jsr $018523			jsr 	StackRestorePosition 		; get restore position back, e.g. loop round.
.018af2	68		pla				pla
.018af3	85 29		sta $29				sta 	zBasicSP+1
.018af5	68		pla				pla
.018af6	85 28		sta $28				sta 	zBasicSP
.018af8					_CNXExit:
.018af8	60		rts				rts
.018af9					_CNXLoopDone:
.018af9	68		pla				pla 								; throw away saved to Basic Stack Pointer
.018afa	68		pla				pla
.018afb	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018afd	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma ?
.018aff	d0 f7		bne $018af8			bne 	_CNXExit
.018b01	c8		iny				iny
.018b02	20 04 9d	jsr $019d04			jsr 	VariableFind 				; identify the variable
.018b05	4c 7d 8a	jmp $018a7d			jmp 	_CNextNoVariable 			; go back with variable pre-found
.018b08					_CNextWrong:
.018b08	20 86 85	jsr $018586			jsr ERR_Handler
>018b0b	57 72 6f 6e 67 20 4e 65			.text "Wrong Next Variable",0
>018b13	78 74 20 56 61 72 69 61 62 6c 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/read.asm

.018b1f					Command_READ:
.018b1f	20 04 9d	jsr $019d04			jsr 	VariableFind 				; get variable/value into zVarDataPtr,zVarType
.018b22	a5 24		lda $24				lda 	zVarDataPtr 				; save variable info on stack
.018b24	48		pha				pha
.018b25	a5 25		lda $25				lda 	zVarDataPtr+1
.018b27	48		pha				pha
.018b28	a5 26		lda $26				lda 	zVarType
.018b2a	48		pha				pha
.018b2b	20 71 8b	jsr $018b71			jsr 	READGetDataItem 			; get the next data item
.018b2e	68		pla				pla 								; restore target variable information.
.018b2f	85 26		sta $26				sta 	zVarType
.018b31	68		pla				pla
.018b32	85 25		sta $25				sta 	zVarDataPtr+1
.018b34	68		pla				pla
.018b35	85 24		sta $24				sta 	zVarDataPtr
.018b37	a2 00		ldx #$00			ldx 	#0
.018b39	20 9d a0	jsr $01a09d			jsr 	VariableSet 				; set the value out.
.018b3c	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018b3e	c8		iny				iny
.018b3f	c9 bf		cmp #$bf			cmp 	#token_Comma
.018b41	f0 dc		beq $018b1f			beq 	Command_READ 				; found, do another READ
.018b43	88		dey				dey
.018b44	60		rts				rts
.018b45					Command_DATA:
.018b45	4c 8d 84	jmp $01848d			jmp 	SkipEndOfCommand
.018b48					Command_RESTORE:
.018b48	48		pha				pha
.018b49	a9 00		lda #$00			lda 	#0 							; this being zero means 'initialise next read'
.018b4b	8d bd 03	sta $03bd			sta 	DataLPtr+0
.018b4e	8d be 03	sta $03be			sta 	DataLPtr+1
.018b51	68		pla				pla
.018b52	60		rts				rts
.018b53					READSwapPointers:
.018b53	98		tya				tya
.018b54	48		pha				pha 								; save it
.018b55	ad c1 03	lda $03c1			lda 	DataIndex 					; get data offset, and copy to offset
.018b58	a8		tay				tay
.018b59	68		pla				pla 								; get code offset and save in DataIndex
.018b5a	8d c1 03	sta $03c1			sta 	DataIndex
.018b5d	da		phx				phx
.018b5e	a2 03		ldx #$03			ldx 	#3 							; swap the Data Pointers (4 bytes) round.
.018b60					_RSWLoop:
.018b60	bd bd 03	lda $03bd,x			lda 	DataLPtr+0,x
.018b63	48		pha				pha
.018b64	b5 18		lda $18,x			lda 	zCodePtr+0,x
.018b66	9d bd 03	sta $03bd,x			sta 	DataLPtr+0,x
.018b69	68		pla				pla
.018b6a	95 18		sta $18,x			sta 	zCodePtr+0,x
.018b6c	ca		dex				dex
.018b6d	10 f1		bpl $018b60			bpl 	_RSWLoop
.018b6f	fa		plx				plx
.018b70	60		rts				rts
.018b71					READGetDataItem:
.018b71	20 53 8b	jsr $018b53			jsr 	ReadSwapPointers 			; swap code and data pointer.
.018b74	a5 18		lda $18				lda		zCodePtr+0 					; initialise ?
.018b76	05 19		ora $19				ora 	zCodePtr+1
.018b78	d0 12		bne $018b8c			bne 	_RGDIIsInitialised
.018b7a	a9 00		lda #$00			lda 	#(BasicProgram) & $FF
.018b7c	85 18		sta $18				sta 	zCodePtr+0
.018b7e	a9 20		lda #$20			lda 	#((BasicProgram) >> 8) & $FF
.018b80	85 19		sta $19				sta 	zCodePtr+1
.018b82	a9 01		lda #$01			lda 	#(BasicProgram) >> 16
.018b84	85 1a		sta $1a				sta 	zCodePtr+2
.018b86	85 1b		sta $1b				sta 	zCodePtr+3
.018b88	a0 03		ldy #$03			ldy 	#3
.018b8a	80 06		bra $018b92			bra 	_RGDIFindData 				; locate next data from start and read that.
.018b8c					_RGDIIsInitialised:
.018b8c	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018b8e	c9 bf		cmp #$bf			cmp 	#token_Comma
.018b90	f0 49		beq $018bdb			beq 	_RGDISkipEvaluateExit
.018b92					_RGDIFindData:
.018b92	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018b94	c9 00		cmp #$00			cmp 	#0 							; end of line
.018b96	f0 19		beq $018bb1			beq 	_RGDIFindNextLine
.018b98	c9 c5		cmp #$c5			cmp 	#token_DATA 				; found data token
.018b9a	f0 3f		beq $018bdb			beq 	_RGDISkipEvaluateExit 		; then skip it and evaluate
.018b9c	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read element
.018b9e	c8		iny				iny 								; skip
.018b9f	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018ba1	90 0c		bcc $018baf			bcc 	_SEDone 					; so just skip over it.
.018ba3	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018ba5	90 07		bcc $018bae			bcc 	_SEDouble
.018ba7	98		tya				tya 								; this is Y + 1
.018ba8	18		clc				clc
.018ba9	77 18		adc [$18],y			adc 	[zCodePtr],y 				; add total length of element
.018bab	a8		tay				tay 								; back in Y.
.018bac	88		dey				dey 								; fix up, one for the +1, one for the iny
.018bad	88		dey				dey
.018bae					_SEDouble:
.018bae	c8		iny				iny
.018baf					_SEDone:
.018baf	80 e1		bra $018b92			bra 	_RGDIFindData
.018bb1					_RGDIFindNextLine:
.018bb1	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018bb3	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read it
.018bb5	18		clc				clc
.018bb6	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.018bb8	85 18		sta $18				sta 	zCodePtr
.018bba	90 02		bcc $018bbe			bcc 	_SNLNoCarry
.018bbc	e6 19		inc $19				inc 	zCodePtr+1
.018bbe					_SNLNoCarry:
.018bbe	a0 00		ldy #$00			ldy 	#0
.018bc0	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018bc2	48		pha				pha
.018bc3	c8		iny				iny
.018bc4	c8		iny				iny
.018bc5	c8		iny				iny
.018bc6	68		pla				pla
.018bc7	d0 c9		bne $018b92			bne 	_RGDIFindData 				; back to scanning.
.018bc9	20 53 8b	jsr $018b53			jsr 	ReadSwapPointers 			; so we get error in line number of READ
.018bcc	20 86 85	jsr $018586			jsr ERR_Handler
>018bcf	4f 75 74 20 6f 66 20 44			.text "Out of Data",0
>018bd7	61 74 61 00
.018bdb					_RGDISkipEvaluateExit:
.018bdb	c8		iny				iny
.018bdc	20 5a 92	jsr $01925a			jsr 	EvaluateExpression 			; evaluate the expression
.018bdf	20 53 8b	jsr $018b53			jsr 	ReadSwapPointers 			; swap the pointers around.
.018be2	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/let.asm

.018be3					Command_LET:
.018be3	20 04 9d	jsr $019d04			jsr 	VariableFind 				; get reference to one variable.
.018be6	a9 84		lda #$84			lda 	#token_Equal  				; get equals
.018be8	20 28 9a	jsr $019a28			jsr 	CheckNextToken
.018beb	a5 24		lda $24				lda 	zVarDataPtr 				; save variable info on stack
.018bed	48		pha				pha
.018bee	a5 25		lda $25				lda 	zVarDataPtr+1
.018bf0	48		pha				pha
.018bf1	a5 26		lda $26				lda 	zVarType
.018bf3	48		pha				pha
.018bf4	20 5a 92	jsr $01925a			jsr 	EvaluateExpression 			; evaluate the RHS, set X to zero.
.018bf7	68		pla				pla 								; restore target variable information.
.018bf8	85 26		sta $26				sta 	zVarType
.018bfa	68		pla				pla
.018bfb	85 25		sta $25				sta 	zVarDataPtr+1
.018bfd	68		pla				pla
.018bfe	85 24		sta $24				sta 	zVarDataPtr
.018c00	20 9d a0	jsr $01a09d			jsr 	VariableSet 				; set the value out.
.018c03	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/get.asm

.018c04					Command_GET:
.018c04					_CGLoop:
.018c04	20 04 9d	jsr $019d04			jsr 	VariableFind 				; get a variable - that we'll GET into.
.018c07	20 42 85	jsr $018542			jsr 	VIOCharGet 					; get character
.018c0a	b0 02		bcs $018c0e			bcs 	_CGNoKey
.018c0c	a9 00		lda #$00			lda 	#0 							; if no character return zero
.018c0e					_CGNoKey:
.018c0e	48		pha				pha
.018c0f	a5 26		lda $26				lda 	zVarType 					; look at the data type.
.018c11	c9 b7		cmp #$b7			cmp 	#token_Dollar
.018c13	f0 1e		beq $018c33			beq 	_CGString
.018c15	68		pla				pla 								; put character in slot.
.018c16	85 80		sta $80				sta 	XS_Mantissa
.018c18	a9 00		lda #$00			lda 	#0 							; rest is zero.
.018c1a	85 81		sta $81				sta 	XS_Mantissa+1
.018c1c	85 82		sta $82				sta 	XS_Mantissa+2
.018c1e	85 83		sta $83				sta 	XS_Mantissa+3
.018c20	a9 01		lda #$01			lda 	#1 							; type integer
.018c22	85 85		sta $85				sta 	XS_Type
.018c24					_CGWriteSetNext:
.018c24	a2 00		ldx #$00			ldx 	#0 							; write number/WriteTempString out
.018c26	20 9d a0	jsr $01a09d			jsr 	VariableSet
.018c29	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018c2b	c9 bf		cmp #$bf			cmp 	#token_Comma 				; if not comma exit
.018c2d	d0 03		bne $018c32			bne 	_CGExit
.018c2f	c8		iny				iny
.018c30	80 d2		bra $018c04			bra 	_CGLoop 					; and get another.
.018c32					_CGExit:
.018c32	60		rts				rts
.018c33					_CGString:
.018c33	a9 02		lda #$02			lda 	#2 							; allocate temp string, space for 2 (char/size)
.018c35	20 8c 9a	jsr $019a8c			jsr 	AllocateTempString 			; initially empty.
.018c38	a5 22		lda $22				lda 	zTempStr 					; set up to be returned.
.018c3a	85 80		sta $80				sta 	XS_Mantissa
.018c3c	a5 23		lda $23				lda 	zTempStr+1
.018c3e	85 81		sta $81				sta 	XS_Mantissa+1
.018c40	a9 02		lda #$02			lda 	#2 							; as a string
.018c42	85 85		sta $85				sta 	XS_Type
.018c44	68		pla				pla 								; get A
.018c45	c9 00		cmp #$00			cmp 	#0 							; if nothing received, return null string.
.018c47	f0 db		beq $018c24			beq 	_CGWriteSetNext
.018c49	20 b7 9a	jsr $019ab7			jsr 	WriteTempString 			; write it into string and return it.
.018c4c	80 d6		bra $018c24			bra 	_CGWriteSetNext

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/sys.asm

.018c4e					Command_SYS:
.018c4e	20 f0 93	jsr $0193f0			jsr 	EvaluateInteger 			; address to call.
.018c51	a5 80		lda $80				lda 	XS_Mantissa+0				; copy to localvector
.018c53	8d 10 03	sta $0310			sta 	LocalVector+0 				; only three, can only do 24 bit calls
.018c56	a5 81		lda $81				lda 	XS_Mantissa+1 				; and that only on 65816
.018c58	8d 11 03	sta $0311			sta 	LocalVector+1
.018c5b	a5 82		lda $82				lda 	XS_Mantissa+2
.018c5d	8d 12 03	sta $0312			sta 	LocalVector+2
.018c60	22 65 8c 01	jsl $018c65			jsl 	_CSYLocalCall 				; jump depending on 24/16 bit code address
.018c64	60		rts				rts
.018c65					_CSYLocalCall:
.018c65	dc 10 03	jmp [$0310]			jmp 	[LocalVector]		 		; address

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/input.asm

.018c68					Command_INPUT:
.018c68	a9 00		lda #$00		lda 	#0 								; clear number of characters required.
.018c6a	8d c2 03	sta $03c2		sta 	InputAvailable 					; save character count
.018c6d	8d c3 03	sta $03c3		sta 	InputRetry
.018c70					_CILoop:
.018c70	a9 00		lda #$00		lda 	#0 								; this resets temporary string allocation.
.018c72	85 23		sta $23			sta 	zTempStr+1 						; (could get lots of long strings)
.018c74	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018c76	c9 fe		cmp #$fe		cmp 	#$FE 							; is it a prompt string
.018c78	d0 15		bne $018c8f		bne 	_CINoPrompt
.018c7a	c8		iny				iny
.018c7b	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018c7d	aa		tax			tax 									; into X
.018c7e	c8		iny				iny
.018c7f	ca		dex			dex 									; deduct marker/prompt length
.018c80	ca		dex			dex
.018c81	f0 ed		beq $018c70		beq 	_CILoop 						; nothing.
.018c83					_CIShowPrompt:
.018c83	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018c85	20 3f 85	jsr $01853f		jsr 	VIOCharPrint
.018c88	c8		iny				iny
.018c89	ca		dex			dex
.018c8a	d0 f7		bne $018c83		bne 	_CIShowPrompt
.018c8c	80 e2		bra $018c70		bra 	_CILoop
.018c8e					_CIAdvance:
.018c8e	c8		iny				iny
.018c8f					_CINoPrompt:
.018c8f	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018c91	c9 bf		cmp #$bf		cmp 	#token_Comma 					; skip , and ;
.018c93	f0 f9		beq $018c8e		beq 	_CIAdvance
.018c95	c9 c1		cmp #$c1		cmp 	#token_SemiColon
.018c97	f0 f5		beq $018c8e		beq 	_CIAdvance
.018c99	c9 00		cmp #$00		cmp 	#0 								; exit if 0 or :
.018c9b	f0 04		beq $018ca1		beq 	_CIExit
.018c9d	c9 c0		cmp #$c0		cmp 	#token_Colon
.018c9f	d0 01		bne $018ca2		bne 	_CIIsVariable  					; if not then there#s a variable or should be !
.018ca1					_CIExit:
.018ca1	60		rts			rts
.018ca2					_CIIsVariable:
.018ca2	20 04 9d	jsr $019d04		jsr 	VariableFind 					; set zVarType and zVarDataPtr accordingly.
.018ca5	a5 26		lda $26			lda 	zVarType
.018ca7	c9 b7		cmp #$b7		cmp 	#token_Dollar 					; is it a string ?
.018ca9	f0 40		beq $018ceb		beq 	_CIIsString
.018cab					_CINGetText:
.018cab	a9 00		lda #$00		lda 	#0
.018cad	8d 14 03	sta $0314		sta 	NumBufX
.018cb0					_CINSkip:
.018cb0	20 4a 8d	jsr $018d4a		jsr 	CIGetCharacter 					; get character skip spaces
.018cb3	c9 20		cmp #$20		cmp 	#" "
.018cb5	f0 f9		beq $018cb0		beq 	_CINSkip
.018cb7	c9 2c		cmp #$2c		cmp 	#","
.018cb9	f0 f5		beq $018cb0		beq 	_CINSkip
.018cbb					_CINLoop:
.018cbb	ae 14 03	ldx $0314		ldx 	NumBufX 						; output character
.018cbe	9d 15 03	sta $0315,x		sta 	Num_Buffer,x
.018cc1	a9 00		lda #$00		lda 	#0 								; add trailing NULL
.018cc3	9d 16 03	sta $0316,x		sta 	Num_Buffer+1,x
.018cc6	ee 14 03	inc $0314		inc 	NumBufX 						; bump ptr
.018cc9	20 4a 8d	jsr $018d4a		jsr 	CIGetCharacter 					; get next character
.018ccc	c9 3a		cmp #$3a		cmp 	#":" 							; stop on : ,
.018cce	f0 08		beq $018cd8		beq 	_CINCopied
.018cd0	c9 2c		cmp #$2c		cmp 	#","
.018cd2	f0 04		beq $018cd8		beq 	_CINCopied
.018cd4	c9 21		cmp #$21		cmp 	#" "+1
.018cd6	b0 e3		bcs $018cbb		bcs 	_CINLoop
.018cd8					_CINCopied:
.018cd8	a2 00		ldx #$00		ldx 	#0
.018cda	20 69 97	jsr $019769		jsr 	ConvertNumBuffer 				; convert number
.018cdd	b0 05		bcs $018ce4		bcs 	_CINFailed 						; didn't work.
.018cdf	20 9d a0	jsr $01a09d		jsr 	VariableSet 					; set variable.
.018ce2	80 8c		bra $018c70		bra 	_CILoop 						; go round again.
.018ce4					_CINFailed:
.018ce4	a9 00		lda #$00		lda 	#0 								; set to request input next time.
.018ce6	8d c2 03	sta $03c2		sta 	InputAvailable
.018ce9	80 c0		bra $018cab		bra 	_CINGetText 					; and try again
.018ceb					_CIIsString:
.018ceb	a9 82		lda #$82		lda 	#130 							; max of 128 characters
.018ced	20 8c 9a	jsr $019a8c		jsr 	AllocateTempString
.018cf0	a9 00		lda #$00		lda 	#0 								; this is the quote flag.
.018cf2	8d 14 03	sta $0314		sta 	NumBufX
.018cf5					_CISSkip:
.018cf5	20 4a 8d	jsr $018d4a		jsr 	CIGetCharacter 					; get character skip spaces
.018cf8	c9 20		cmp #$20		cmp 	#" "
.018cfa	f0 f9		beq $018cf5		beq 	_CISSkip
.018cfc	80 03		bra $018d01		bra 	_CISInputProcess 				; handle that as the first character
.018cfe					_CISInput:
.018cfe	20 4a 8d	jsr $018d4a		jsr 	CIGetCharacter
.018d01					_CISInputProcess:
.018d01	c9 0d		cmp #$0d		cmp 	#13 							; EOL ?
.018d03	f0 31		beq $018d36		beq 	_CISDone
.018d05	c9 3a		cmp #$3a		cmp 	#":"							; colon exits if not in quotes. who knows why?
.018d07	d0 05		bne $018d0e		bne 	_CISNotColon
.018d09	2c 14 03	bit $0314		bit 	NumBufX 						; check quote flag
.018d0c	10 28		bpl $018d36		bpl 	_CISDone 						; if quote flag zero, done
.018d0e					_CISNotColon:
.018d0e	c9 22		cmp #$22		cmp 	#'"'							; quoted string ?
.018d10	f0 1a		beq $018d2c		beq 	_CISIsQuote						; if so handle that code.
.018d12	20 b7 9a	jsr $019ab7		jsr 	WriteTempString 				; write to the temporary string
.018d15	ad 9f 03	lda $039f		lda 	TempStringWriteIndex 			; string too long ?
.018d18	10 e4		bpl $018cfe		bpl 	_CISInput
.018d1a	20 86 85	jsr $018586			jsr ERR_Handler
>018d1d	49 6e 70 75 74 20 74 6f			.text "Input too long",0
>018d25	6f 20 6c 6f 6e 67 00
.018d2c					_CISIsQuote:
.018d2c	ad 14 03	lda $0314		lda 	NumBufX 						; this is the 'in quote flag'
.018d2f	49 80		eor #$80		eor 	#$80 							; toggle bit 7
.018d31	8d 14 03	sta $0314		sta 	NumBufX
.018d34	d0 c8		bne $018cfe		bne 	_CISInput 						; if entered quote mode, get next character
.018d36					_CISDone:
.018d36	a5 22		lda $22			lda 	zTempStr 						; return the temporary string
.018d38	85 80		sta $80			sta 	XS_Mantissa+0
.018d3a	a5 23		lda $23			lda 	zTempStr+1
.018d3c	85 81		sta $81			sta 	XS_Mantissa+1
.018d3e	a9 02		lda #$02		lda 	#2
.018d40	85 85		sta $85			sta 	XS_Type
.018d42	a2 00		ldx #$00		ldx 	#0
.018d44	20 9d a0	jsr $01a09d		jsr 	VariableSet 					; set variable.
.018d47	4c 70 8c	jmp $018c70		jmp 	_CILoop 						; and try again
.018d4a					CIGetCharacter:
.018d4a	5a		phy			phy
.018d4b	ac c2 03	ldy $03c2		ldy		InputAvailable 					; anything available
.018d4e	f0 0c		beq $018d5c		beq 	_CIGCNewLine 					; no, needs a new line.
.018d50	b9 66 05	lda $0566,y		lda 	IFT_LineBuffer,y 				; read line buffer entry
.018d53	c9 0d		cmp #$0d		cmp 	#13 							; got 13 ?
.018d55	f0 03		beq $018d5a		beq 	_CIGCNoInc
.018d57	ee c2 03	inc $03c2		inc 	InputAvailable 					; if not, advance character pointer.
.018d5a					_CIGCNoInc:
.018d5a	7a		ply			ply
.018d5b	60		rts			rts
.018d5c					_CIGCNewLine:
.018d5c	ee c2 03	inc $03c2		inc 	InputAvailable 					; next pointer to 1 (first char this time)
.018d5f	a9 3f		lda #$3f		lda 	#"?"
.018d61	20 3f 85	jsr $01853f		jsr 	VIOCharPrint
.018d64	ac c3 03	ldy $03c3		ldy 	InputRetry 						; retry flag set
.018d67	f0 03		beq $018d6c		beq 	_CIGCPrompt 					; if so, then print ? again
.018d69	20 3f 85	jsr $01853f		jsr 	VIOCharPrint
.018d6c					_CIGCPrompt:
.018d6c	a0 01		ldy #$01		ldy 	#1
.018d6e	8c c3 03	sty $03c3		sty 	InputRetry 						; set the input retry flag to non-zero
.018d71					_CIGCBackOne:
.018d71	88		dey			dey
.018d72					_CIGCLoop:
.018d72	c0 50		cpy #$50		cpy 	#80 							; stop overflow.
.018d74	f0 fb		beq $018d71		beq 	_CIGCBackOne
.018d76	20 42 85	jsr $018542		jsr 	VIOCharGet 						; get a character
.018d79	f0 f7		beq $018d72		beq 	_CIGCLoop 						; wait until key pressed
.018d7b	c9 08		cmp #$08		cmp 	#8 								; backspace
.018d7d	f0 10		beq $018d8f		beq 	_CIGCBackSpace
.018d7f	20 3f 85	jsr $01853f		jsr 	VIOCharPrint 					; echo character
.018d82	99 66 05	sta $0566,y		sta		IFT_LineBuffer,y 				; write into buffer and bump
.018d85	c8		iny			iny
.018d86	c9 0d		cmp #$0d		cmp 	#13 							; until CR pressed.
.018d88	d0 e8		bne $018d72		bne 	_CIGCLoop
.018d8a	ad 66 05	lda $0566		lda 	IFT_LineBuffer 					; return first char in buffer
.018d8d	7a		ply			ply 									; restore Y
.018d8e	60		rts			rts
.018d8f					_CIGCBackSpace:
.018d8f	c0 00		cpy #$00		cpy 	#0 								; can only B/S if not first
.018d91	f0 df		beq $018d72		beq 	_CIGCLoop
.018d93	20 3f 85	jsr $01853f		jsr 	VIOCharPrint 					; echo BS
.018d96	88		dey			dey 									; go back one.
.018d97	80 d9		bra $018d72		bra 	_CIGCLoop

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/end.asm

.018d99					Command_END:
>018d99	02						.byte 	2
.018d9a	4c 52 88	jmp $018852			jmp 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/if.asm

.018d9d					Command_IF:
.018d9d	20 f0 93	jsr $0193f0			jsr 	EvaluateInteger 			; check success.
.018da0	a5 80		lda $80				lda 	XS_Mantissa+0				; check the result if zero
.018da2	05 81		ora $81				ora 	XS_Mantissa+1
.018da4	05 82		ora $82				ora 	XS_Mantissa+2
.018da6	05 83		ora $83				ora 	XS_Mantissa+3
.018da8	aa		tax				tax 								; put into X.
.018da9	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018dab	c9 93		cmp #$93			cmp 	#token_Then 				; then found.
.018dad	d0 2c		bne $018ddb			bne 	_FIFExtended
.018daf	c8		iny				iny
.018db0	e0 00		cpx #$00			cpx 	#0 							; was it successful.
.018db2	f0 0b		beq $018dbf			beq 	_FIFEndOfLine 				; if not, go to the end of the line.
.018db4	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018db6	29 c0		and #$c0			and 	#$C0 						; is it a number
.018db8	c9 40		cmp #$40			cmp 	#$40
.018dba	d0 1e		bne $018dda			bne 	_FIFContinue 				; if not, do what ever follows.
.018dbc	4c 2a 91	jmp $01912a			jmp		Command_GOTO 				; we have IF <expr> THEN <number> so we do GOTO code.
.018dbf					_FIFEndOfLine:
.018dbf	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018dc1	c9 00		cmp #$00			cmp 	#0 							; if zero, end of line, so exit
.018dc3	f0 15		beq $018dda			beq 	_FIFContinue
.018dc5	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read element
.018dc7	c8		iny				iny 								; skip
.018dc8	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018dca	90 0c		bcc $018dd8			bcc 	_SEDone 					; so just skip over it.
.018dcc	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018dce	90 07		bcc $018dd7			bcc 	_SEDouble
.018dd0	98		tya				tya 								; this is Y + 1
.018dd1	18		clc				clc
.018dd2	77 18		adc [$18],y			adc 	[zCodePtr],y 				; add total length of element
.018dd4	a8		tay				tay 								; back in Y.
.018dd5	88		dey				dey 								; fix up, one for the +1, one for the iny
.018dd6	88		dey				dey
.018dd7					_SEDouble:
.018dd7	c8		iny				iny
.018dd8					_SEDone:
.018dd8	80 e5		bra $018dbf			bra 	_FIFEndOfLine
.018dda					_FIFContinue:
.018dda	60		rts				rts
.018ddb					_FIFExtended:
.018ddb	da		phx				phx 								; save result
.018ddc	a9 40		lda #$40			lda 	#(SMark_If << 4) 			; push marker on the stack, nothing else.
.018dde	20 bf 84	jsr $0184bf			jsr 	StackPushFrame
.018de1	68		pla				pla 								; restore result
.018de2	f0 01		beq $018de5			beq 	_FIXSkip 					; if zero then it has failed.
.018de4	60		rts				rts 								; test passed, so continue executing
.018de5					_FIXSkip:
.018de5	a9 94		lda #$94			lda 	#token_endif 				; scan forward till found either ELSE or ENDIF
.018de7	a2 de		ldx #$de			ldx 	#token_else 				; at the same level.
.018de9	20 02 84	jsr $018402			jsr 	StructureSearchDouble
.018dec	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018dee	c8		iny				iny
.018def	c9 94		cmp #$94			cmp 	#token_endif 				; if endif, handle endif code.
.018df1	f0 07		beq $018dfa			beq 	Command_ENDIF
.018df3	60		rts				rts
.018df4					Command_ELSE:
.018df4	a9 94		lda #$94			lda 	#token_endif 				; scan forward till found ENDIF
.018df6	20 00 84	jsr $018400			jsr 	StructureSearchSingle 		; then do the ENDIF pop.
.018df9	c8		iny				iny
.018dfa					Command_ENDIF:
.018dfa	a9 40		lda #$40			lda 	#(SMark_If << 4)
.018dfc	20 d6 84	jsr $0184d6			jsr 	StackPopFrame
.018dff	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/list.asm

.018e00					Command_LIST:
.018e00	20 8d 8f	jsr $018f8d			jsr 	ListGetRange				; get any parameters
.018e03	a9 00		lda #$00			lda 	#(BasicProgram) & $FF
.018e05	85 18		sta $18				sta 	zCodePtr+0
.018e07	a9 20		lda #$20			lda 	#((BasicProgram) >> 8) & $FF
.018e09	85 19		sta $19				sta 	zCodePtr+1
.018e0b	a9 01		lda #$01			lda 	#(BasicProgram) >> 16
.018e0d	85 1a		sta $1a				sta 	zCodePtr+2
.018e0f	85 1b		sta $1b				sta 	zCodePtr+3
.018e11	a0 03		ldy #$03			ldy 	#3
.018e13	a9 00		lda #$00			lda 	#0 							; reset the indent & last indent
.018e15	8d bc 03	sta $03bc			sta 	LastListIndent
.018e18	8d bb 03	sta $03bb			sta 	ListIndent
.018e1b					_CILLoop:
.018e1b	a0 00		ldy #$00			ldy 	#0
.018e1d	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018e1f	c9 00		cmp #$00			cmp 	#0 							; if zero, end of program
.018e21	f0 23		beq $018e46			beq 	_CILExit
.018e23	20 4d 85	jsr $01854d			jsr 	VIOCheckBreak 				; check break
.018e26	c9 00		cmp #$00			cmp 	#0
.018e28	d0 1c		bne $018e46			bne 	_CILExit
.018e2a	20 d4 8f	jsr $018fd4			jsr 	ListCheckRange 				; check current line in range.
.018e2d	b0 08		bcs $018e37			bcs		_CILNext
.018e2f	a0 00		ldy #$00			ldy 	#0
.018e31	c8		iny				iny
.018e32	c8		iny				iny
.018e33	c8		iny				iny
.018e34	20 49 8e	jsr $018e49			jsr 	ListLine 					; list one line.
.018e37					_CILNext:
.018e37	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018e39	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read it
.018e3b	18		clc				clc
.018e3c	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.018e3e	85 18		sta $18				sta 	zCodePtr
.018e40	90 02		bcc $018e44			bcc 	_SNLNoCarry
.018e42	e6 19		inc $19				inc 	zCodePtr+1
.018e44					_SNLNoCarry:
.018e44	80 d5		bra $018e1b			bra 	_CILLoop
.018e46					_CILExit:
.018e46	4c 52 88	jmp $018852			jmp 	WarmStart
.018e49					ListLine:
.018e49	ad bb 03	lda $03bb			lda 	ListIndent 					; copy current list indent -> last
.018e4c	8d bc 03	sta $03bc			sta 	LastListIndent
.018e4f					_LICountIndent:
.018e4f	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018e51	c9 00		cmp #$00			cmp 	#0
.018e53	f0 2f		beq $018e84			beq 	_LIDoneIndent
.018e55	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus
.018e57	90 16		bcc $018e6f			bcc 	_LICINext
.018e59	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.018e5b	b0 12		bcs $018e6f			bcs 	_LICINext
.018e5d	ee bb 03	inc $03bb			inc 	ListIndent
.018e60	c9 93		cmp #$93			cmp 	#firstKeywordMinus
.018e62	90 0b		bcc $018e6f			bcc 	_LICINext
.018e64	ce bb 03	dec $03bb			dec 	ListIndent
.018e67	ce bb 03	dec $03bb			dec 	ListIndent
.018e6a	10 03		bpl $018e6f			bpl 	_LICINext
.018e6c	ee bb 03	inc $03bb			inc 	ListIndent
.018e6f					_LICINext:
.018e6f	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read element
.018e71	c8		iny				iny 								; skip
.018e72	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018e74	90 0c		bcc $018e82			bcc 	_SEDone 					; so just skip over it.
.018e76	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018e78	90 07		bcc $018e81			bcc 	_SEDouble
.018e7a	98		tya				tya 								; this is Y + 1
.018e7b	18		clc				clc
.018e7c	77 18		adc [$18],y			adc 	[zCodePtr],y 				; add total length of element
.018e7e	a8		tay				tay 								; back in Y.
.018e7f	88		dey				dey 								; fix up, one for the +1, one for the iny
.018e80	88		dey				dey
.018e81					_SEDouble:
.018e81	c8		iny				iny
.018e82					_SEDone:
.018e82	80 cb		bra $018e4f			bra 	_LICountIndent
.018e84					_LIDoneIndent:
.018e84	a0 00		ldy #$00			ldy 	#0
.018e86	c8		iny				iny
.018e87	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018e89	85 80		sta $80				sta 	XS_Mantissa
.018e8b	c8		iny				iny
.018e8c	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018e8e	85 81		sta $81				sta 	XS_Mantissa+1
.018e90	20 d1 85	jsr $0185d1			jsr 	Print16BitInteger 			; print integer.
.018e93	85 10		sta $10				sta 	zTemp1 						; save spaces printed.
.018e95	ad bb 03	lda $03bb			lda 	ListIndent 					; smaller of current/prev indent
.018e98	cd bc 03	cmp $03bc			cmp 	LastListIndent
.018e9b	90 03		bcc $018ea0			bcc 	_LISmaller
.018e9d	ad bc 03	lda $03bc			lda 	LastListIndent
.018ea0					_LISmaller:
.018ea0	0a		asl a				asl 	a 							; double indent
.018ea1	49 ff		eor #$ff			eor 	#$FF 						; 2's complement arithmetic
.018ea3	38		sec				sec
.018ea4	65 10		adc $10				adc 	zTemp1 						; "subtract" indent e.g. print more.
.018ea6	aa		tax				tax 								; print spaces to column 6
.018ea7					_LISpace:
.018ea7	a9 20		lda #$20			lda 	#" "
.018ea9	20 7d 8f	jsr $018f7d			jsr 	ListPrintLC
.018eac	e8		inx				inx
.018ead	e0 06		cpx #$06			cpx 	#6
.018eaf	d0 f6		bne $018ea7			bne 	_LISpace
.018eb1					_LIDecode:
.018eb1	c8		iny				iny
.018eb2	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018eb4	c9 00		cmp #$00			cmp 	#0 							; zero, exit.
.018eb6	f0 0f		beq $018ec7			beq 	_LIExit
.018eb8	30 12		bmi $018ecc			bmi 	_LIToken
.018eba	c9 40		cmp #$40			cmp 	#$40 						; 01-$3F, character.
.018ebc	b0 50		bcs $018f0e			bcs 	_LIInteger
.018ebe	49 20		eor #$20			eor 	#$20 						; make 7 bit
.018ec0	69 20		adc #$20			adc 	#$20
.018ec2	20 7d 8f	jsr $018f7d			jsr 	ListPrintLC 				; print in LC
.018ec5	80 ea		bra $018eb1			bra 	_LIDecode
.018ec7					_LIExit:
.018ec7	a9 0d		lda #$0d			lda 	#13 						; print new line.
.018ec9	4c 7d 8f	jmp $018f7d			jmp 	ListPrintLC
.018ecc					_LIToken:
.018ecc	c9 fc		cmp #$fc			cmp 	#$FC 						; $FC-$FF ?
.018ece	90 49		bcc $018f19			bcc		_LICommandToken
.018ed0	48		pha				pha 								; save in case end
.018ed1	a2 22		ldx #$22			ldx 	#'"'						; print if $FE quoted string
.018ed3	c9 fe		cmp #$fe			cmp 	#$FE
.018ed5	f0 17		beq $018eee			beq 	_LIPrint
.018ed7	a2 2e		ldx #$2e			ldx 	#'.'						; print if $FD decimals
.018ed9	c9 fd		cmp #$fd			cmp 	#$FD
.018edb	f0 11		beq $018eee			beq 	_LIPrint
.018edd	a9 52		lda #$52			lda 	#'R'						; must be REM
.018edf	20 7d 8f	jsr $018f7d			jsr 	ListPrintLC
.018ee2	a9 45		lda #$45			lda 	#'E'
.018ee4	20 7d 8f	jsr $018f7d			jsr 	ListPrintLC
.018ee7	a9 4d		lda #$4d			lda 	#'M'
.018ee9	20 7d 8f	jsr $018f7d			jsr 	ListPrintLC
.018eec	a2 20		ldx #$20			ldx 	#' '
.018eee					_LIPrint:
.018eee	8a		txa				txa
.018eef	20 7d 8f	jsr $018f7d			jsr 	ListPrintLC
.018ef2	c8		iny				iny
.018ef3	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018ef5	aa		tax				tax 								; put in X
.018ef6	ca		dex				dex
.018ef7					_LILoop:
.018ef7	ca		dex				dex 								; exit when count reached zero.
.018ef8	f0 08		beq $018f02			beq 	_LIEnd
.018efa	c8		iny				iny
.018efb	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018efd	20 7d 8f	jsr $018f7d			jsr 	ListPrintLC
.018f00	80 f5		bra $018ef7			bra 	_LILoop
.018f02	68		pla		_LIEnd:	pla 								; get A back
.018f03	c9 fe		cmp #$fe			cmp 	#$FE 						; if '"' need closing quotes
.018f05	d0 aa		bne $018eb1			bne 	_LIDecode
.018f07	a9 22		lda #$22			lda 	#'"'
.018f09	20 7d 8f	jsr $018f7d			jsr 	ListPrintLC
.018f0c	80 a3		bra $018eb1			bra 	_LIDecode
.018f0e					_LIInteger:
.018f0e	a2 00		ldx #$00			ldx 	#0
.018f10	20 62 93	jsr $019362			jsr 	EvaluateGetInteger 			; get an atom
.018f13	88		dey				dey
.018f14	20 d7 85	jsr $0185d7			jsr 	Print32BitInteger 			; print integer.
.018f17	80 98		bra $018eb1			bra 	_LIDecode
.018f19					_LICommandToken:
.018f19	5a		phy				phy 								; save Y
.018f1a	48		pha				pha 								; save token
.018f1b	a2 cf		ldx #$cf			ldx  	#KeywordText & $FF 			; address of keyword text table.
.018f1d	a9 86		lda #$86			lda 	(#KeywordText >> 8) & $FF
.018f1f	86 1c		stx $1c				stx 	zLTemp1
.018f21	85 1d		sta $1d				sta 	zLTemp1+1
.018f23	a9 01		lda #$01			lda 	(#KeywordText >> 16) & $FF 	; this is for 65816 (it's a table in code
.018f25	85 1e		sta $1e				sta 	zLTemp1+2 					; space) and won't affect a 6502 at all.
.018f27	68		pla				pla 								; get token
.018f28	29 7f		and #$7f			and 	#127 						; chuck bit 7.
.018f2a	f0 16		beq $018f42			beq 	_LIFoundToken
.018f2c	aa		tax				tax
.018f2d					_LITokenLoop:
.018f2d	a0 00		ldy #$00			ldy 	#0 							; last character not a token.
.018f2f					_LIFindEnd:
.018f2f	b7 1c		lda [$1c],y			lda 	[zLTemp1],y
.018f31	c8		iny				iny
.018f32	0a		asl a				asl 	a
.018f33	90 fa		bcc $018f2f			bcc 	_LIFindEnd
.018f35	98		tya				tya 								; that is step to the next
.018f36	18		clc				clc 								; we don't bother bumping the 3rd byte
.018f37	65 1c		adc $1c				adc 	zLTemp1 					; here.
.018f39	85 1c		sta $1c				sta 	zLTemp1
.018f3b	90 02		bcc $018f3f			bcc 	_LINoBump
.018f3d	e6 1d		inc $1d				inc 	zLTemp1+1
.018f3f					_LINoBump:
.018f3f	ca		dex				dex 								; no go round again.
.018f40	d0 eb		bne $018f2d			bne 	_LITokenLoop
.018f42					_LIFoundToken:
.018f42	a0 00		ldy #$00			ldy 	#0
.018f44					_LIPrintToken:
.018f44	b7 1c		lda [$1c],y			lda 	[zLTemp1],y
.018f46	c0 00		cpy #$00			cpy 	#0 							; see if needs prefix space
.018f48	d0 16		bne $018f60			bne 	_LINoPrefixSpace
.018f4a	c9 41		cmp #$41			cmp 	#"A" 						; e.g. alphabetic token.
.018f4c	90 12		bcc $018f60			bcc 	_LINoPrefixSpace
.018f4e	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018f50	b0 0e		bcs $018f60			bcs 	_LINoPrefixSpace
.018f52	ae ba 03	ldx $03ba			ldx 	LastPrinted 				; if last was space not required
.018f55	e0 20		cpx #$20			cpx 	#" "
.018f57	f0 07		beq $018f60			beq 	_LINoPrefixSpace
.018f59	48		pha				pha
.018f5a	a9 20		lda #$20			lda 	#" "
.018f5c	20 7d 8f	jsr $018f7d			jsr 	ListPrintLC
.018f5f	68		pla				pla
.018f60					_LINoPrefixSpace:
.018f60	c8		iny				iny
.018f61	48		pha				pha 								; save it
.018f62	29 7f		and #$7f			and 	#$7F
.018f64	20 7d 8f	jsr $018f7d			jsr 	ListPrintLC
.018f67	68		pla				pla
.018f68	10 da		bpl $018f44			bpl 	_LIPrintToken 				; go back if not end
.018f6a	7a		ply				ply 								; restore Y
.018f6b	29 7f		and #$7f			and 	#$7F 						; if last char is a letter
.018f6d	c9 41		cmp #$41			cmp 	#"A"
.018f6f	90 09		bcc $018f7a			bcc 	_LINotLetter2
.018f71	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018f73	b0 05		bcs $018f7a			bcs 	_LINotLetter2
.018f75	a9 20		lda #$20			lda 	#" " 						; add spacing
.018f77	20 7d 8f	jsr $018f7d			jsr 	ListPrintLC
.018f7a					_LINotLetter2:
.018f7a	4c b1 8e	jmp $018eb1			jmp 	_LIDecode
.018f7d					ListPrintLC:
.018f7d	8d ba 03	sta $03ba			sta 	LastPrinted
.018f80	c9 41		cmp #$41			cmp 	#"A"
.018f82	90 06		bcc $018f8a			bcc 	_LPLC0
.018f84	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018f86	b0 02		bcs $018f8a			bcs 	_LPLC0
.018f88	69 20		adc #$20			adc 	#$20
.018f8a	4c 3f 85	jmp $01853f	_LPLC0:	jmp 	VIOCharPrint
.018f8d					ListGetRange:
.018f8d	a2 0b		ldx #$0b			ldx 	#XS_Size*2-1 				; clear first 2 slots back to defaults.
.018f8f					_LGRClear:
.018f8f	a9 00		lda #$00			lda 	#0
.018f91	95 80		sta $80,x			sta 	XS_Mantissa,x
.018f93	ca		dex				dex
.018f94	10 f9		bpl $018f8f			bpl 	_LGRClear
.018f96	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018f98	c9 00		cmp #$00			cmp 	#0 							; nothing
.018f9a	f0 21		beq $018fbd			beq 	_LGRBlank
.018f9c	c9 c0		cmp #$c0			cmp 	#token_Colon 				; or colon
.018f9e	f0 1d		beq $018fbd			beq 	_LGRBlank
.018fa0	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma
.018fa2	f0 18		beq $018fbc			beq 	_LGREnd 					; then it's LIST ,x
.018fa4	20 f0 93	jsr $0193f0			jsr 	EvaluateInteger 			; get the first number into bottom
.018fa7	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018fa9	c9 bf		cmp #$bf			cmp 	#token_Comma
.018fab	f0 0f		beq $018fbc			beq 	_LGREnd 					; then it is LIST a,b
.018fad	a5 80		lda $80				lda 	XS_Mantissa+0 				; copy first to second LIST n is n,n
.018faf	85 86		sta $86				sta 	XS_Mantissa+XS_Size+0
.018fb1	a5 81		lda $81				lda 	XS_Mantissa+1
.018fb3	85 87		sta $87				sta 	XS_Mantissa+XS_Size+1
.018fb5					_LGRBumpExit:
.018fb5	e6 86		inc $86				inc 	XS_Mantissa+XS_Size 		; bump it so we can use cc.
.018fb7	d0 02		bne $018fbb			bne 	_LGRBump2
.018fb9	e6 87		inc $87				inc 	XS_Mantissa+XS_Size+1
.018fbb					_LGRBump2:
.018fbb	60		rts				rts
.018fbc					_LGREnd:
.018fbc	c8		iny				iny
.018fbd					_LGRBlank:
.018fbd	a9 ff		lda #$ff			lda 	#$FF 						; default to the end.
.018fbf	85 86		sta $86				sta 	XS_Mantissa+XS_Size
.018fc1	85 87		sta $87				sta 	XS_Mantissa+XS_Size+1
.018fc3	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018fc5	c9 00		cmp #$00			cmp 	#0
.018fc7	f0 f2		beq $018fbb			beq 	_LGRBump2
.018fc9	0a		asl a				asl 	a 							; if not a number, then exit (to end)
.018fca	b0 ef		bcs $018fbb			bcs 	_LGRBump2
.018fcc	a2 06		ldx #$06			ldx 	#XS_Size 					; get to range
.018fce	20 f2 93	jsr $0193f2			jsr 	EvaluateIntegerX
.018fd1	80 e2		bra $018fb5			bra 	_LGRBumpExit
.018fd3	60		rts				rts
.018fd4					ListCheckRange:
.018fd4	c8		iny				iny
.018fd5	a2 00		ldx #$00			ldx 	#0 							; test low
.018fd7	20 e4 8f	jsr $018fe4			jsr 	_LCRCompare
.018fda	90 06		bcc $018fe2			bcc 	_LCRFail
.018fdc	a2 06		ldx #$06			ldx 	#XS_Size 					; test high
.018fde	20 e4 8f	jsr $018fe4			jsr 	_LCRCompare
.018fe1	60		rts				rts
.018fe2					_LCRFail:
.018fe2	38		sec				sec
.018fe3	60		rts				rts
.018fe4					_LCRCompare:
.018fe4	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018fe6	38		sec				sec
.018fe7	f5 80		sbc $80,x			sbc	 	XS_Mantissa+0,x
.018fe9	08		php				php
.018fea	c8		iny				iny
.018feb	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018fed	28		plp				plp
.018fee	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.018ff0	08		php				php
.018ff1	88		dey				dey
.018ff2	28		plp				plp
.018ff3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/print.asm

.018ff4					Command_PRINT:
.018ff4					_CPR_Loop:
.018ff4	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018ff6	c9 00		cmp #$00			cmp 	#0 							; end
.018ff8	f0 25		beq $01901f			beq 	_CPR_GoNewLine
.018ffa	c9 c0		cmp #$c0			cmp 	#token_Colon
.018ffc	f0 21		beq $01901f			beq 	_CPR_GoNewLine
.018ffe	c9 c1		cmp #$c1			cmp 	#token_SemiColon
.019000	f0 75		beq $019077			beq 	_CPR_Skip
.019002	c9 bf		cmp #$bf			cmp 	#token_Comma
.019004	f0 58		beq $01905e			beq 	_CPR_Tab
.019006	20 5a 92	jsr $01925a			jsr 	EvaluateExpression 			; get expression.
.019009	a5 85		lda $85				lda 	XS_Type 					; get type.
.01900b	29 02		and #$02			and 	#2
.01900d	d0 28		bne $019037			bne 	_CPR_String 				; if type = 2 output as string.
.01900f					_CPR_Number:
.01900f	a9 00		lda #$00			lda 	#0 							; reset buffer index
.019011	8d 14 03	sta $0314			sta 	NumBufX
.019014	aa		tax				tax
.019015	a5 85		lda $85				lda 	XS_Type 					; get type
.019017	4a		lsr a				lsr 	a
.019018	b0 08		bcs $019022			bcs 	_CPRInt 					; if msb set do as integer
.01901a	20 50 a7	jsr $01a750			jsr 	FPToString 					; do the floa
.01901d	80 06		bra $019025			bra 	_CPRNPrint
.01901f					_CPR_GoNewLine:
.01901f	4c 85 90	jmp $019085			jmp 	_CPR_NewLine
.019022					_CPRInt:
.019022	20 e6 a1	jsr $01a1e6			jsr 	IntToString
.019025					_CPRNPrint:
.019025	ad 15 03	lda $0315			lda 	Num_Buffer 					; is first character -
.019028	c9 2d		cmp #$2d			cmp 	#"-"
.01902a	f0 05		beq $019031			beq 	_CPRNoSpace
.01902c	a9 20		lda #$20			lda 	#" "						; print the leading space
.01902e	20 3f 85	jsr $01853f			jsr 	VIOCharPrint 				; so beloved of MS Basics.
.019031					_CPRNoSpace:
.019031	a2 14		ldx #$14			ldx 	#(Num_Buffer-1) & $FF
.019033	a9 03		lda #$03			lda 	#(Num_Buffer-1) >> 8
.019035	80 04		bra $01903b			bra 	_CPRPrint
.019037					_CPR_String:
.019037	a6 80		ldx $80				ldx 	XS_Mantissa
.019039	a5 81		lda $81				lda 	XS_Mantissa+1
.01903b					_CPRPrint:
.01903b	86 20		stx $20				stx 	zGenPtr
.01903d	85 21		sta $21				sta 	zGenPtr+1
.01903f	5a		phy				phy
.019040	a0 00		ldy #$00			ldy 	#0							; get length into X
.019042	b1 20		lda ($20),y			lda 	(zGenPtr),y
.019044	aa		tax				tax
.019045	f0 09		beq $019050			beq 	_CPREndPrint 				; nothing to print
.019047					_CPRLoop:
.019047	c8		iny				iny
.019048	b1 20		lda ($20),y			lda 	(zGenPtr),y
.01904a	20 3f 85	jsr $01853f			jsr 	VIOCharPrint
.01904d	ca		dex				dex
.01904e	d0 f7		bne $019047			bne 	_CPRLoop
.019050					_CPREndPrint:
.019050	a5 85		lda $85				lda 	XS_Type 					; if numeric add trailing space
.019052	29 02		and #$02			and 	#2
.019054	d0 05		bne $01905b			bne 	_CPRNoTrail
.019056	a9 20		lda #$20			lda 	#" "
.019058	20 3f 85	jsr $01853f			jsr 	VIOCharPrint
.01905b					_CPRNoTrail:
.01905b	7a		ply				ply
.01905c	80 96		bra $018ff4			bra 	_CPR_Loop
.01905e					_CPR_Tab:
.01905e	20 50 85	jsr $018550			jsr 	VIOCharGetPosition 			; print until position % 8 = 0
.019061					_CPR_CalcSpaces:
.019061	38		sec				sec 								; calculate position mod 10.
.019062	e9 0a		sbc #$0a			sbc 	#10
.019064	b0 fb		bcs $019061			bcs 	_CPR_CalcSpaces
.019066	69 0a		adc #$0a			adc 	#10
.019068	f0 0d		beq $019077			beq 	_CPR_Skip 					; nothing to print
.01906a	aa		tax				tax 								; print out spaces to mod 10
.01906b					_CPRTabSpaces:
.01906b	a9 20		lda #$20			lda 	#" "
.01906d	20 3f 85	jsr $01853f			jsr 	VIOCharPrint
.019070	e8		inx				inx
.019071	e0 0a		cpx #$0a			cpx 	#10
.019073	d0 f6		bne $01906b			bne 	_CPRTabSpaces
.019075	80 e7		bra $01905e			bra 	_CPR_Tab
.019077					_CPR_Skip:
.019077	c8		iny				iny
.019078	b7 18		lda [$18],y			lda 	[zCodePtr],y
.01907a	c9 c0		cmp #$c0			cmp 	#token_Colon 				; colon or $00, exit
.01907c	f0 0c		beq $01908a			beq 	_CPR_Exit
.01907e	c9 00		cmp #$00			cmp 	#0
.019080	f0 08		beq $01908a			beq 	_CPR_Exit 					; if not go round again.
.019082	4c f4 8f	jmp $018ff4			jmp 	_CPR_Loop
.019085					_CPR_NewLine:
.019085	a9 0d		lda #$0d			lda 	#13
.019087	20 3f 85	jsr $01853f			jsr 	VIOCharPrint
.01908a					_CPR_Exit:
.01908a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/assert.asm

.01908b					Command_ASSERT:
.01908b	20 f0 93	jsr $0193f0			jsr 	EvaluateInteger 			; calculate thing being asserted, 0=>X
.01908e	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; check if true (non-zero)
.019090	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019092	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019094	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019096	f0 01		beq $019099			beq 	_ASFail
.019098	60		rts				rts
.019099					_ASFail:
.019099	20 86 85	jsr $018586			jsr ERR_Handler
>01909c	41 73 73 65 72 74 00			.text "Assert",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/poke.asm

.0190a3					Command_POKE:
.0190a3	a9 01		lda #$01			lda 	#1 							; 1 byte
.0190a5	80 06		bra $0190ad			bra 	CmdPoke_Main
.0190a7					Command_DOKE:
.0190a7	a9 02		lda #$02			lda 	#2 							; 2 bytes
.0190a9	80 02		bra $0190ad			bra 	CmdPoke_Main
.0190ab					Command_LOKE:
.0190ab	a9 04		lda #$04			lda 	#4							; 4 bytes
.0190ad					CmdPoke_Main:
.0190ad	48		pha				pha
.0190ae	20 f0 93	jsr $0193f0			jsr 	EvaluateInteger 			; get two parameters. First is address
.0190b1	e8		inx				inx
.0190b2	e8		inx				inx
.0190b3	e8		inx				inx
.0190b4	e8		inx				inx
.0190b5	e8		inx				inx
.0190b6	e8		inx				inx
.0190b7	20 47 9a	jsr $019a47			jsr 	CheckNextComma
.0190ba	20 f2 93	jsr $0193f2			jsr 	EvaluateIntegerX 			; second is the data.
.0190bd	a5 80		lda $80				lda 	XS_Mantissa+0 				; copy the mantissa into ZLTemp1 (address)
.0190bf	85 1c		sta $1c				sta 	zLTemp1
.0190c1	a5 81		lda $81				lda 	XS_Mantissa+1
.0190c3	85 1d		sta $1d				sta 	zLTemp1+1
.0190c5	a5 82		lda $82				lda 	XS_Mantissa+2
.0190c7	85 1e		sta $1e				sta 	zLTemp1+2
.0190c9	a5 83		lda $83				lda 	XS_Mantissa+3
.0190cb	85 1f		sta $1f				sta 	zLTemp1+3
.0190cd	68		pla				pla 								; get count
.0190ce	5a		phy				phy 								; save Y
.0190cf	20 cf 99	jsr $0199cf			jsr 	MemWrite 					; write it out
.0190d2	7a		ply				ply 								; restore Y and done.
.0190d3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/newold.asm

.0190d4					Command_NEW:
.0190d4	a9 00		lda #$00			lda 	#(BasicProgram) & $FF
.0190d6	85 18		sta $18				sta 	zCodePtr+0
.0190d8	a9 20		lda #$20			lda 	#((BasicProgram) >> 8) & $FF
.0190da	85 19		sta $19				sta 	zCodePtr+1
.0190dc	a9 01		lda #$01			lda 	#(BasicProgram) >> 16
.0190de	85 1a		sta $1a				sta 	zCodePtr+2
.0190e0	85 1b		sta $1b				sta 	zCodePtr+3
.0190e2	a0 03		ldy #$03			ldy 	#3
.0190e4	a0 00		ldy #$00			ldy 	#0
.0190e6	a9 00		lda #$00			lda 	#0 							; write a 0 there, null first offset
.0190e8	97 18		sta [$18],y			sta 	[zCodePtr],y
.0190ea	20 e3 99	jsr $0199e3			jsr 	UpdateProgramEnd 			; update program end.
.0190ed	4c 52 88	jmp $018852			jmp 	WarmStart 					; and always warmstart, can't be running program.
.0190f0					Command_OLD:
.0190f0	a9 00		lda #$00			lda 	#(BasicProgram) & $FF
.0190f2	85 18		sta $18				sta 	zCodePtr+0
.0190f4	a9 20		lda #$20			lda 	#((BasicProgram) >> 8) & $FF
.0190f6	85 19		sta $19				sta 	zCodePtr+1
.0190f8	a9 01		lda #$01			lda 	#(BasicProgram) >> 16
.0190fa	85 1a		sta $1a				sta 	zCodePtr+2
.0190fc	85 1b		sta $1b				sta 	zCodePtr+3
.0190fe	a0 03		ldy #$03			ldy 	#3
.019100					_COL_Find:
.019100	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019102	c8		iny				iny
.019103	c9 00		cmp #$00			cmp 	#0 							; if zero, then the position Y/Z is new offset
.019105	f0 18		beq $01911f			beq 	_COL_Found
.019107	98		tya				tya
.019108	c9 00		cmp #$00			cmp 	#0 							; e.g. there is no program line end.
.01910a	d0 f4		bne $019100			bne 	_COL_Find 					; can't find old EOL, give up.
.01910c	20 86 85	jsr $018586			jsr ERR_Handler
>01910f	50 72 6f 67 72 61 6d 20			.text "Program Corrupt",0
>019117	43 6f 72 72 75 70 74 00
.01911f					_COL_Found:
.01911f	98		tya				tya
.019120	48		pha				pha
.019121	a0 00		ldy #$00			ldy 	#0
.019123	68		pla				pla
.019124	97 18		sta [$18],y			sta 	[zCodePtr],y
.019126	20 e3 99	jsr $0199e3			jsr 	UpdateProgramEnd 			; reset variable pointer
.019129	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/branch.asm

.01912a					Command_GOTO:
.01912a	20 7f 91	jsr $01917f			jsr 	GotoGetLineNumber 			; get line number
.01912d					CmdGOTO:
.01912d	a2 00		ldx #$00			ldx 	#0 							; go to that line number
.01912f	4c 9c 91	jmp $01919c			jmp 	GotoChangeToLineNumberX
.019132					Command_GOSUB:
.019132	20 7f 91	jsr $01917f			jsr 	GotoGetLineNumber 			; get line number
.019135					CmdGOSUB:
.019135	20 06 85	jsr $018506			jsr 	StackSavePosition 			; save position on stack and push frame
.019138	a9 15		lda #$15			lda 	#(SMark_Gosub << 4)+SourcePosSize
.01913a	20 bf 84	jsr $0184bf			jsr 	StackPushFrame
.01913d	a2 00		ldx #$00			ldx		#0 							; go to that line number
.01913f	4c 9c 91	jmp $01919c			jmp 	GotoChangeToLineNumberX
.019142					Command_RETURN:
.019142	a9 10		lda #$10			lda 	#(SMark_Gosub << 4) 		; pop frame
.019144	20 d6 84	jsr $0184d6			jsr 	StackPopFrame
.019147	20 23 85	jsr $018523			jsr 	StackRestorePosition 		; restore position.
.01914a	60		rts				rts
.01914b					Command_ON:
.01914b	a2 00		ldx #$00			ldx 	#0 							; get the ON value into mantissa.0
.01914d	20 92 98	jsr $019892			jsr 	SLIByteParameter
.019150	a5 80		lda $80				lda 	XS_Mantissa+0 				; get the count
.019152	f0 28		beq $01917c			beq 	_CONFail 					; can't be zero, error if it is.
.019154	aa		tax				tax 								; save in X.
.019155	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019157	c8		iny				iny
.019158	48		pha				pha 								; so we can check what we're doing later.
.019159	c9 cc		cmp #$cc			cmp 	#token_GOTO 				; must be GOTO or GOSUB
.01915b	f0 07		beq $019164			beq 	_CONOkayToken
.01915d	c9 ca		cmp #$ca			cmp 	#token_GOSUB
.01915f	f0 03		beq $019164			beq 	_CONOkayToken
.019161	4c 57 85	jmp $018557			jmp 	SyntaxError
.019164					_CONOkayToken:
.019164	da		phx				phx 								; count on top, GOTO/GOSUB token 2nd.
.019165					_CONFindNumber:
.019165	20 7f 91	jsr $01917f			jsr 	GotoGetLineNumber 			; get a line number.
.019168	fa		plx				plx 								; restore count
.019169	ca		dex				dex  								; decrement, exit if zero.
.01916a	f0 06		beq $019172			beq 	_CONFound
.01916c	da		phx				phx 								; push back
.01916d	20 47 9a	jsr $019a47			jsr 	CheckNextComma				; check for comma
.019170	80 f3		bra $019165			bra 	_CONFindNumber 				; go round again.
.019172					_CONFound:
.019172	68		pla				pla 								; get token to decide what to do
.019173	c9 cc		cmp #$cc			cmp 	#token_GOTO 				; if GOTO
.019175	f0 b6		beq $01912d			beq		CmdGOTO 					; then just branch.
.019177	20 8d 84	jsr $01848d			jsr 	SkipEndOfCommand 			; go to end of command
.01917a	80 b9		bra $019135			bra 	CmdGOSUB 					; and do a GOSUB.
.01917c					_CONFail:
.01917c	4c 75 85	jmp $018575			jmp 	BadParamError
.01917f					GotoGetLineNumber:
.01917f	20 f0 93	jsr $0193f0			jsr 	EvaluateInteger 			; get integer into mantissa.0
.019182	a5 82		lda $82				lda 	XS_Mantissa+2 				; check range
.019184	05 83		ora $83				ora 	XS_Mantissa+3 				; check it is 0-32767
.019186	d0 01		bne $019189			bne 	_GLINError
.019188	60		rts				rts
.019189					_GLINError:
.019189	20 86 85	jsr $018586			jsr ERR_Handler
>01918c	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>019194	20 4e 75 6d 62 65 72 00
.01919c					GotoChangeToLineNumberX:
.01919c	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check line number not zero
.01919e	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.0191a0	f0 37		beq $0191d9			beq 	_GCTLFail 					; if so, no can do.
.0191a2	a9 00		lda #$00			lda 	#(BasicProgram) & $FF
.0191a4	85 18		sta $18				sta 	zCodePtr+0
.0191a6	a9 20		lda #$20			lda 	#((BasicProgram) >> 8) & $FF
.0191a8	85 19		sta $19				sta 	zCodePtr+1
.0191aa	a9 01		lda #$01			lda 	#(BasicProgram) >> 16
.0191ac	85 1a		sta $1a				sta 	zCodePtr+2
.0191ae	85 1b		sta $1b				sta 	zCodePtr+3
.0191b0	a0 03		ldy #$03			ldy 	#3
.0191b2					_GCTLLoop:
.0191b2	a0 00		ldy #$00			ldy 	#0
.0191b4	b7 18		lda [$18],y			lda 	[zCodePtr],y
.0191b6	c9 00		cmp #$00			cmp 	#0
.0191b8	f0 1f		beq $0191d9			beq 	_GCTLFail
.0191ba	c8		iny				iny
.0191bb	b7 18		lda [$18],y			lda 	[zCodePtr],y
.0191bd	d5 80		cmp $80,x			cmp 	XS_Mantissa+0,x
.0191bf	d0 07		bne $0191c8			bne 	_GCTLNext
.0191c1	c8		iny				iny
.0191c2	b7 18		lda [$18],y			lda 	[zCodePtr],y
.0191c4	d5 81		cmp $81,x			cmp 	XS_Mantissa+1,x
.0191c6	f0 0f		beq $0191d7			beq 	_GCTLExit
.0191c8					_GCTLNext:
.0191c8	a0 00		ldy #$00			ldy 	#0 							; point to offset
.0191ca	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read it
.0191cc	18		clc				clc
.0191cd	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.0191cf	85 18		sta $18				sta 	zCodePtr
.0191d1	90 02		bcc $0191d5			bcc 	_SNLNoCarry
.0191d3	e6 19		inc $19				inc 	zCodePtr+1
.0191d5					_SNLNoCarry:
.0191d5	80 db		bra $0191b2			bra 	_GCTLLoop 					; try next line.
.0191d7					_GCTLExit:
.0191d7	c8		iny				iny
.0191d8	60		rts				rts
.0191d9					_GCTLFail:
.0191d9	20 86 85	jsr $018586			jsr ERR_Handler
>0191dc	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>0191e4	20 4e 75 6d 62 65 72 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.0191ec					Command_CLR:
.0191ec					ResetRunStatus:
.0191ec	20 40 9d	jsr $019d40			jsr 	VariableClear
.0191ef	20 ad 84	jsr $0184ad			jsr 	StackReset
.0191f2	a9 00		lda #$00			lda 	#HighMemory & $FF
.0191f4	8d 00 03	sta $0300			sta 	StringPtr
.0191f7	a9 7f		lda #$7f			lda 	#HighMemory >> 8
.0191f9	8d 01 03	sta $0301			sta 	StringPtr+1
.0191fc	20 0a 9f	jsr $019f0a			jsr 	ArrayResetDefault
.0191ff	20 48 8b	jsr $018b48			jsr 	Command_RESTORE
.019202	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/stop.asm

.019203					Command_STOP:
.019203	20 86 85	jsr $018586			jsr ERR_Handler
>019206	53 74 6f 70 00				.text "Stop",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/while.asm

.01920b					Command_WHILE:
.01920b	20 06 85	jsr $018506			jsr 	StackSavePosition			; save position into stack, but don't yet push.
.01920e	20 f0 93	jsr $0193f0			jsr 	EvaluateInteger 			; calculate the while loop value.
.019211	a5 80		lda $80				lda 	XS_Mantissa+0				; check the result if zero
.019213	05 81		ora $81				ora 	XS_Mantissa+1
.019215	05 82		ora $82				ora 	XS_Mantissa+2
.019217	05 83		ora $83				ora 	XS_Mantissa+3
.019219	f0 06		beq $019221			beq 	_CWHSkip 					; if it is zero, then skip to WEND.
.01921b	a9 35		lda #$35			lda 	#(SMark_While << 4)+SourcePosSize
.01921d	20 bf 84	jsr $0184bf			jsr 	StackPushFrame 				; push on stack
.019220	60		rts				rts
.019221					_CWHSkip:
.019221	a9 95		lda #$95			lda 	#token_Wend 				; look for the WEND token.
.019223	20 00 84	jsr $018400			jsr 	StructureSearchSingle
.019226	c8		iny				iny
.019227	60		rts				rts
.019228					Command_WEND:
.019228	a9 30		lda #$30			lda 	#(SMark_While << 4)			; remove the frame
.01922a	20 d6 84	jsr $0184d6			jsr 	StackPopFrame
.01922d	20 23 85	jsr $018523			jsr 	StackRestorePosition
.019230	80 d9		bra $01920b			bra 	Command_WHILE 				; and do the while again.
.019232	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/repeat.asm

.019233					Command_REPEAT:
.019233	20 06 85	jsr $018506			jsr 	StackSavePosition			; save position into stack
.019236	a9 25		lda #$25			lda 	#(SMark_Repeat << 4)+SourcePosSize
.019238	20 bf 84	jsr $0184bf			jsr 	StackPushFrame 				; push on stack
.01923b	60		rts				rts
.01923c					Command_UNTIL:
.01923c	a9 20		lda #$20			lda 	#(SMark_Repeat << 4)		; remove the frame, checking it.
.01923e	20 d6 84	jsr $0184d6			jsr 	StackPopFrame
.019241	20 f0 93	jsr $0193f0			jsr 	EvaluateInteger				; work out the UNTIL expression.
.019244	a5 80		lda $80				lda 	XS_Mantissa+0 				; check if zero.
.019246	05 81		ora $81				ora 	XS_Mantissa+1
.019248	05 82		ora $82				ora 	XS_Mantissa+2
.01924a	05 83		ora $83				ora 	XS_Mantissa+3
.01924c	d0 08		bne $019256			bne 	_CUTExit 					; if not, just exit
.01924e	20 23 85	jsr $018523			jsr 	StackRestorePosition 		; otherwise loop round again.
.019251	a9 25		lda #$25			lda 	#(SMark_Repeat << 4)+SourcePosSize
.019253	20 bf 84	jsr $0184bf			jsr 	StackPushFrame 				; fix the stack back so we can pop it again.
.019256					_CUTExit:
.019256	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.019257					EVESyntax:
.019257	4c 57 85	jmp $018557			jmp 	SyntaxError
.01925a					EvaluateExpression:
.01925a	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.01925c					EvaluateExpressionX:
.01925c	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.01925e					EvaluateExpressionXA:
.01925e	48		pha				pha 								; save precedence on stack.
.01925f	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019261	f0 f4		beq $019257			beq 	EVESyntax 					; end of line, syntax error.
.019263	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.019265	b0 03		bcs $01926a			bcs 	_EVNotVariable
.019267	4c 34 93	jmp $019334			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.01926a					_EVNotVariable:
.01926a	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.01926c	90 e9		bcc $019257			bcc 	EVESyntax
.01926e	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.019270	b0 58		bcs $0192ca			bcs 	_EVNotInteger
.019272	20 62 93	jsr $019362			jsr 	EvaluateGetInteger
.019275					_EVCheckDecimal:
.019275	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019277	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.019279	d0 05		bne $019280			bne 	_EVGotAtom 					; no, get atom.
.01927b					_EVIsDecimal:
.01927b	20 88 93	jsr $019388			jsr 	EVGetDecimal 				; extend to the decimal part.
.01927e	80 00		bra $019280			bra 	_EVGotAtom 					; and continue to got atom.
.019280					_EVGotAtom:
.019280	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019282	10 44		bpl $0192c8			bpl 	_EVExitDrop 				; must be a token.
.019284	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.019286	b0 40		bcs $0192c8			bcs 	_EVExitDrop
.019288	68		pla				pla 								; get current precedence
.019289	85 20		sta $20				sta 	zGenPtr 					; save in zGenPtr as temp.
.01928b	da		phx				phx 								; save X
.01928c	b7 18		lda [$18],y			lda 	[zCodePtr],y
.01928e	aa		tax				tax 								; put in X
.01928f	bf 40 86 01	lda $018640,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.019293	85 21		sta $21				sta 	zGenPtr+1 					; save it.
.019295	fa		plx				plx 								; restore X
.019296	c5 20		cmp $20				cmp 	zGenPtr 					; compared against the current precedence
.019298	90 2f		bcc $0192c9			bcc 	_EVExit 					; exit if too low.
.01929a	f0 2d		beq $0192c9			beq 	_EVExit 					; exit if equals
.01929c	a5 20		lda $20				lda 	zGenPtr 					; push precedence
.01929e	48		pha				pha
.01929f	b7 18		lda [$18],y			lda 	[zCodePtr],y
.0192a1	48		pha				pha
.0192a2	c8		iny				iny
.0192a3	da		phx				phx 								; save current position
.0192a4	e8		inx				inx
.0192a5	e8		inx				inx
.0192a6	e8		inx				inx
.0192a7	e8		inx				inx
.0192a8	e8		inx				inx
.0192a9	e8		inx				inx
.0192aa	a5 21		lda $21				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.0192ac	20 5e 92	jsr $01925e			jsr 	EvaluateExpressionXA 		; do the RHS.
.0192af	fa		plx				plx 								; restore X
.0192b0	68		pla				pla 								; get the binary operator in A.
.0192b1					_EVCallA:
.0192b1	da		phx				phx 								; save X again
.0192b2	0a		asl a				asl 	a 							; double, lose the MSB.
.0192b3	aa		tax				tax									; put in X
.0192b4	bf ef 85 01	lda $0185ef,x			lda 	VectorTable,x 				; copy address into zGenPtr
.0192b8	8d 11 03	sta $0311			sta 	LocalVector+1
.0192bb	bf f0 85 01	lda $0185f0,x			lda 	VectorTable+1,x
.0192bf	8d 12 03	sta $0312			sta 	LocalVector+2
.0192c2	fa		plx				plx 								; restore X
.0192c3	20 3d 93	jsr $01933d			jsr 	EVCallLocalVector
.0192c6	80 b8		bra $019280			bra 	_EVGotAtom 					; and loop back.
.0192c8					_EVExitDrop:
.0192c8	68		pla				pla
.0192c9					_EVExit:
.0192c9	60		rts				rts
.0192ca					_EVNotInteger:
.0192ca	c8		iny				iny
.0192cb	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.0192cd	d0 16		bne $0192e5			bne 	_EVNotMinus
.0192cf	20 d1 93	jsr $0193d1			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.0192d2	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.0192d4	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.0192d6	f0 05		beq $0192dd			beq 	_EVMinusFloat
.0192d8	20 c9 a1	jsr $01a1c9			jsr 	IntegerNegateAlways 		; negation
.0192db	80 a3		bra $019280			bra 	_EVGotAtom 					; and go back.
.0192dd					_EVMinusFloat:
.0192dd	b5 85		lda $85,x			lda 	XS_Type,x 					; invert the sign bit.
.0192df	49 80		eor #$80			eor 	#$80
.0192e1	95 85		sta $85,x			sta 	XS_Type,x
.0192e3	80 9b		bra $019280			bra 	_EVGotAtom
.0192e5					_EVNotMinus:
.0192e5	c9 bd		cmp #$bd			cmp 	#token_lparen 				; is it left parenthesis
.0192e7	d0 17		bne $019300			bne 	_EVNotParenthesis
.0192e9	20 5c 92	jsr $01925c			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.0192ec	b7 18		lda [$18],y			lda 	[zCodePtr],y
.0192ee	c8		iny				iny
.0192ef	c9 be		cmp #$be			cmp 	#token_rparen 				; okay if right bracket.
.0192f1	f0 8d		beq $019280			beq 	_EVGotAtom
.0192f3	20 86 85	jsr $018586			jsr ERR_Handler
>0192f6	4d 69 73 73 69 6e 67 20			.text "Missing )",0
>0192fe	29 00
.019300					_EVNotParenthesis:
.019300	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.019302	d0 0c		bne $019310			bne 	_EVNotNot
.019304	20 d1 93	jsr $0193d1			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.019307	20 51 a6	jsr $01a651			jsr 	FPUToInteger 				; make it an integer - if possible.
.01930a	20 b6 93	jsr $0193b6			jsr 	NotInteger 					; do the not calculation
.01930d	4c 80 92	jmp $019280			jmp 	_EVGotAtom
.019310					_EVNotNot:
.019310	c9 fe		cmp #$fe			cmp 	#$FE
.019312	d0 12		bne $019326			bne 	_EVNotString
.019314	20 c7 9a	jsr $019ac7			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.019317	a5 22		lda $22				lda 	zTempStr 					; copy address of string into mantissa
.019319	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01931b	a5 23		lda $23				lda 	zTempStr+1
.01931d	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01931f	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.019321	95 85		sta $85,x			sta 	XS_Type,x
.019323	4c 80 92	jmp $019280			jmp 	_EVGotAtom
.019326					_EVNotString:
.019326	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.019328	90 04		bcc $01932e			bcc 	_EVBadElement
.01932a	c9 b7		cmp #$b7			cmp 	#lastUnaryFunction+1
.01932c	90 03		bcc $019331			bcc 	_EVUnaryFunction
.01932e					_EVBadElement:
.01932e	4c 57 85	jmp $018557			jmp 	SyntaxError
.019331					_EVUnaryFunction:
.019331	4c b1 92	jmp $0192b1			jmp 	_EVCallA
.019334					_EVVariableHandler:
.019334	20 04 9d	jsr $019d04			jsr 	VariableFind 				; locate a variable
.019337	20 4c a0	jsr $01a04c			jsr 	VariableGet 				; copy into memory.
.01933a	4c 80 92	jmp $019280			jmp 	_EVGotAtom 					; and go round.
.01933d					EVCallLocalVector:
.01933d	6c 11 03	jmp ($0311)			jmp 	(LocalVector+1)
.019340					EVShiftMantissaLeft6:
.019340	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.019342	95 84		sta $84,x			sta 	XS_Exponent,x
.019344	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019346	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019348	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01934a	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01934c	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01934e	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019350	a9 00		lda #$00			lda 	#0
.019352	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019354	20 57 93	jsr $019357			jsr 	_EVSMLShift 					; call it here to do it twice
.019357					_EVSMLShift:
.019357	56 84		lsr $84,x			lsr 	XS_Exponent,x
.019359	76 83		ror $83,x			ror 	XS_Mantissa+3,x
.01935b	76 82		ror $82,x			ror 	XS_Mantissa+2,x
.01935d	76 81		ror $81,x			ror 	XS_Mantissa+1,x
.01935f	76 80		ror $80,x			ror 	XS_Mantissa+0,x
.019361	60		rts				rts
.019362					EvaluateGetInteger:
.019362	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019364	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.019366	95 80		sta $80,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.019368	a9 00		lda #$00			lda 	#0
.01936a	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01936c	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01936e	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019370	1a		inc a				inc 	a 							; set to type 1 (integer)
.019371	95 85		sta $85,x			sta 	XS_Type,x
.019373					_EVCheckNextInteger:
.019373	c8		iny				iny
.019374	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019376	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.019378	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.01937a	b0 0b		bcs $019387			bcs 	_EVEndInteger
.01937c	48		pha				pha 								; save it.
.01937d	20 40 93	jsr $019340			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.019380	68		pla				pla
.019381	15 80		ora $80,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.019383	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019385	80 ec		bra $019373			bra 	_EVCheckNextInteger
.019387					_EVEndInteger:
.019387	60		rts				rts
.019388					EVGetDecimal:
.019388	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.01938a	8d 15 03	sta $0315			sta 	Num_Buffer
.01938d	da		phx				phx
.01938e	c8		iny				iny
.01938f	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019391	c8		iny				iny
.019392	3a		dec a				dec 	a								; convert to a string length.
.019393	3a		dec a				dec 	a
.019394	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.019396					_EVGDCopy:
.019396	48		pha				pha 									; save count
.019397	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019399	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.01939c	e8		inx				inx 									; forward ....
.01939d	c8		iny				iny
.01939e	68		pla				pla 									; get count
.01939f	3a		dec a				dec 	a 								; until zero
.0193a0	d0 f4		bne $019396			bne 	_EVGDCopy
.0193a2	9d 15 03	sta $0315,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.0193a5	fa		plx				plx 									; restore X
.0193a6	a9 15		lda #$15			lda 	#Num_Buffer & $FF 				; set zGenPtr
.0193a8	85 20		sta $20				sta 	zGenPtr
.0193aa	a9 03		lda #$03			lda 	#Num_Buffer >> 8
.0193ac	85 21		sta $21				sta 	zGenPtr+1
.0193ae	5a		phy				phy 									; save Y
.0193af	a0 00		ldy #$00			ldy 	#0 								; start position
.0193b1	20 0b a8	jsr $01a80b			jsr 	FPFromString 					; convert current
.0193b4	7a		ply				ply 									; restore Y
.0193b5	60		rts				rts
.0193b6					NotInteger:
.0193b6	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0193b8	49 ff		eor #$ff			eor 	#$FF
.0193ba	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0193bc	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0193be	49 ff		eor #$ff			eor 	#$FF
.0193c0	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0193c2	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0193c4	49 ff		eor #$ff			eor 	#$FF
.0193c6	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0193c8	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.0193ca	49 ff		eor #$ff			eor 	#$FF
.0193cc	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0193ce	60		rts				rts
.0193cf					EvaluateGetAtom:
.0193cf	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.0193d1					EvaluateGetAtomX:
.0193d1	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.0193d3	20 5e 92	jsr $01925e			jsr 	EvaluateExpressionXA
.0193d6	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.0193d8	29 0f		and #$0f			and 	#15
.0193da	c9 02		cmp #$02			cmp 	#2
.0193dc	b0 01		bcs $0193df			bcs 	EvaluateType
.0193de	60		rts				rts
.0193df					EvaluateType:
.0193df	4c 67 85	jmp $018567			jmp 	TypeError
.0193e2					EvaluateNumber:
.0193e2	a2 00		ldx #$00			ldx 	#0
.0193e4					EvaluateNumberX:
.0193e4	20 5c 92	jsr $01925c			jsr 	EvaluateExpressionX
.0193e7	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0/1
.0193e9	29 0f		and #$0f			and 	#15
.0193eb	c9 02		cmp #$02			cmp 	#2
.0193ed	b0 f0		bcs $0193df			bcs 	EvaluateType
.0193ef	60		rts				rts
.0193f0					EvaluateInteger:
.0193f0	a2 00		ldx #$00			ldx 	#0
.0193f2					EvaluateIntegerX:
.0193f2	20 e4 93	jsr $0193e4			jsr 	EvaluateNumberX
.0193f5	20 51 a6	jsr $01a651			jsr 	FPUToInteger
.0193f8	60		rts				rts
.0193f9					EvaluateString:
.0193f9	a2 00		ldx #$00			ldx 	#0
.0193fb					EvaluateStringX:
.0193fb	20 5c 92	jsr $01925c			jsr 	EvaluateExpressionX
.0193fe	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 2
.019400	29 0f		and #$0f			and 	#15
.019402	c9 02		cmp #$02			cmp 	#2
.019404	d0 d9		bne $0193df			bne 	EvaluateType
.019406	b5 80		lda $80,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.019408	85 20		sta $20				sta 	zGenPtr
.01940a	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01940c	85 21		sta $21				sta 	zGenPtr+1
.01940e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.01940f					BinaryOp_And:
.01940f	20 63 94	jsr $019463			jsr 	BinaryMakeBothInteger
.019412	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.019414	35 86		and $86,x			and 	XS2_Mantissa+0,x
.019416	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019418	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.01941a	35 87		and $87,x			and 	XS2_Mantissa+1,x
.01941c	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01941e	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.019420	35 88		and $88,x			and 	XS2_Mantissa+2,x
.019422	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019424	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.019426	35 89		and $89,x			and 	XS2_Mantissa+3,x
.019428	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01942a	60		rts				rts
.01942b					BinaryOp_Or:
.01942b	20 63 94	jsr $019463			jsr 	BinaryMakeBothInteger
.01942e	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.019430	15 86		ora $86,x			ora 	XS2_Mantissa+0,x
.019432	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019434	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.019436	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.019438	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01943a	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.01943c	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.01943e	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019440	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.019442	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.019444	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019446	60		rts				rts
.019447					BinaryOp_Eor:
.019447					BinaryOp_Xor:
.019447	20 63 94	jsr $019463			jsr 	BinaryMakeBothInteger
.01944a	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.01944c	55 86		eor $86,x			eor 	XS2_Mantissa+0,x
.01944e	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019450	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.019452	55 87		eor $87,x			eor 	XS2_Mantissa+1,x
.019454	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019456	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.019458	55 88		eor $88,x			eor 	XS2_Mantissa+2,x
.01945a	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01945c	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.01945e	55 89		eor $89,x			eor 	XS2_Mantissa+3,x
.019460	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019462	60		rts				rts
.019463					BinaryMakeBothInteger:
.019463	da		phx				phx 								; save X
.019464	e8		inx				inx
.019465	e8		inx				inx
.019466	e8		inx				inx
.019467	e8		inx				inx
.019468	e8		inx				inx
.019469	e8		inx				inx
.01946a	20 6e 94	jsr $01946e			jsr 	BinaryMakeInteger 			; convert to integer.
.01946d	fa		plx				plx 								; restore X and fall through.
.01946e					BinaryMakeInteger:
.01946e	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.019470	29 0f		and #$0f			and 	#15 						; check type zero
.019472	f0 04		beq $019478			beq 	_BMIConvert 				; if float convert to integer.
.019474	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.019475	90 04		bcc $01947b			bcc 	_BMIError
.019477	60		rts				rts
.019478					_BMIConvert:
.019478	4c 51 a6	jmp $01a651			jmp 	FPUToInteger 				; convert to integer
.01947b					_BMIError:
.01947b	4c 67 85	jmp $018567			jmp 	TypeError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.01947e					Binary_Equal:
.01947e	20 c7 94	jsr $0194c7			jsr 	CompareValues 				; compare the values
.019481	09 00		ora #$00			ora 	#0 							; true if 0
.019483	f0 33		beq $0194b8			beq 	CCTrue
.019485	80 2d		bra $0194b4			bra 	CCFalse
.019487					Binary_NotEqual:
.019487	20 c7 94	jsr $0194c7			jsr 	CompareValues
.01948a	09 00		ora #$00			ora 	#0 							; true if -1 or 1
.01948c	f0 26		beq $0194b4			beq 	CCFalse
.01948e	80 28		bra $0194b8			bra 	CCTrue
.019490					Binary_Less:
.019490	20 c7 94	jsr $0194c7			jsr 	CompareValues
.019493	09 00		ora #$00			ora 	#0 							; true if -1
.019495	30 21		bmi $0194b8			bmi 	CCTrue
.019497	80 1b		bra $0194b4			bra 	CCFalse
.019499					Binary_LessEqual:
.019499	20 c7 94	jsr $0194c7			jsr 	CompareValues
.01949c	c9 01		cmp #$01			cmp 	#1 							; true if 0 or -1
.01949e	d0 18		bne $0194b8			bne 	CCTrue
.0194a0	80 12		bra $0194b4			bra 	CCFalse
.0194a2					Binary_GreaterEqual:
.0194a2	20 c7 94	jsr $0194c7			jsr 	CompareValues
.0194a5	09 00		ora #$00			ora 	#0 							; true if 0 or 1
.0194a7	10 0f		bpl $0194b8			bpl 	CCTrue
.0194a9	80 09		bra $0194b4			bra 	CCFalse
.0194ab					Binary_Greater:
.0194ab	20 c7 94	jsr $0194c7			jsr 	CompareValues 				; true if 1
.0194ae	c9 01		cmp #$01			cmp 	#1
.0194b0	f0 06		beq $0194b8			beq 	CCTrue
.0194b2	80 00		bra $0194b4			bra 	CCFalse
.0194b4	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.0194b6	80 02		bra $0194ba			bra 	CCWrite
.0194b8	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.0194ba	95 80		sta $80,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.0194bc	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0194be	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0194c0	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0194c2	a9 01		lda #$01			lda 	#1
.0194c4	95 85		sta $85,x			sta 	XS_Type,x 					; set type to integer whatever.
.0194c6	60		rts				rts
.0194c7					CompareValues:
.0194c7	b5 85		lda $85,x			lda 	XS_Type,x 					; and the types together
.0194c9	35 8b		and $8b,x			and 	XS2_Type,x
.0194cb	c9 02		cmp #$02			cmp 	#2 							; is it a string, then do the string
.0194cd	f0 11		beq $0194e0			beq 	_CVString					; comparison routine.
.0194cf	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.0194d1	35 8b		and $8b,x			and 	XS2_Type,x
.0194d3	4a		lsr a				lsr 	a 							; shift bit 0 into C
.0194d4	90 03		bcc $0194d9			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.0194d6	4c 22 95	jmp $019522			jmp 	CompareInteger32 							; so execute code at \1
.0194d9					_BCFloat:
.0194d9	20 bc 95	jsr $0195bc			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.0194dc	4c 4a a5	jmp $01a54a			jmp 	FPCompare 							; and execute code at \2
.0194df	60		rts				rts
.0194e0					_CVString:
.0194e0	da		phx				phx 								; save XY
.0194e1	5a		phy				phy
.0194e2	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.0194e4	85 1c		sta $1c				sta		zLTemp1+0
.0194e6	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0194e8	85 1d		sta $1d				sta 	zLTemp1+1
.0194ea	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.0194ec	85 1e		sta $1e				sta 	zLTemp1+2
.0194ee	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.0194f0	85 1f		sta $1f				sta 	zLTemp1+3
.0194f2	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.0194f4	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.0194f6	d1 1e		cmp ($1e),y			cmp 	(zLTemp1+2),y
.0194f8	90 02		bcc $0194fc			bcc 	_CVCommon
.0194fa	b1 1e		lda ($1e),y			lda 	(zLTemp1+2),y
.0194fc					_CVCommon:
.0194fc	aa		tax				tax 								; put shorter string length in zero.
.0194fd	f0 0c		beq $01950b			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.0194ff					_CVCompare:
.0194ff	c8		iny				iny 								; next character
.019500	b1 1c		lda ($1c),y			lda 	(zLTemp1),y 				; compare characters
.019502	d1 1e		cmp ($1e),y			cmp 	(zLTemp1+2),y 				; handle different values, < or >
.019504	90 13		bcc $019519			bcc 	_CVReturnLess 				; <
.019506	d0 15		bne $01951d			bne 	_CVReturnGreater 			; >
.019508	ca		dex				dex 								; until common length matched.
.019509	d0 f4		bne $0194ff			bne 	_CVCompare
.01950b					_CVMatch:
.01950b	a0 00		ldy #$00			ldy 	#0
.01950d	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.01950f	d1 1e		cmp ($1e),y			cmp 	(zLTemp1+2),y
.019511	90 06		bcc $019519			bcc 	_CVReturnLess 				; <
.019513	d0 08		bne $01951d			bne 	_CVReturnGreater 			; >
.019515	a9 00		lda #$00			lda 	#0
.019517	80 06		bra $01951f			bra 	_CVExit
.019519					_CVReturnLess:
.019519	a9 ff		lda #$ff			lda 	#$FF
.01951b	80 02		bra $01951f			bra 	_CVExit
.01951d					_CVReturnGreater:
.01951d	a9 01		lda #$01			lda 	#$01
.01951f					_CVExit:
.01951f	7a		ply				ply
.019520	fa		plx				plx
.019521	60		rts				rts
.019522					CompareInteger32:
.019522	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.019524	49 80		eor #$80			eor 	#$80
.019526	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019528	b5 89		lda $89,x			lda 	XS2_Mantissa+3,x
.01952a	49 80		eor #$80			eor 	#$80
.01952c	95 89		sta $89,x			sta 	XS2_Mantissa+3,x
.01952e	20 a2 95	jsr $0195a2			jsr 	SubInteger32 				; subtraction
.019531	90 0d		bcc $019540			bcc 	_CI32Less 					; cc return -1
.019533	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check if zero
.019535	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019537	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019539	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01953b	f0 02		beq $01953f			beq 	_CI32Exit
.01953d	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.01953f					_CI32Exit:
.01953f	60		rts				rts
.019540					_CI32Less:
.019540	a9 ff		lda #$ff			lda 	#$FF
.019542	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.019543					BinaryOp_Add:
.019543	b5 85		lda $85,x			lda 	XS_Type,x  					; and types together
.019545	35 8b		and $8b,x			and 	XS2_Type,x
.019547	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.019549	d0 11		bne $01955c			bne 	_BOAString 					; so go do the string code.
.01954b	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.01954d	35 8b		and $8b,x			and 	XS2_Type,x
.01954f	4a		lsr a				lsr 	a 							; shift bit 0 into C
.019550	90 03		bcc $019555			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.019552	4c 88 95	jmp $019588			jmp 	AddInteger32 							; so execute code at \1
.019555					_BCFloat:
.019555	20 bc 95	jsr $0195bc			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.019558	4c 35 a3	jmp $01a335			jmp 	FPAdd 							; and execute code at \2
.01955b	60		rts				rts
.01955c					_BOAString:
.01955c	4c d6 95	jmp $0195d6			jmp 	ConcatenateString 			; concatenate two strings.
.01955f					BinaryOp_Subtract:
.01955f	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.019561	35 8b		and $8b,x			and 	XS2_Type,x
.019563	4a		lsr a				lsr 	a 							; shift bit 0 into C
.019564	90 03		bcc $019569			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.019566	4c a2 95	jmp $0195a2			jmp 	SubInteger32 							; so execute code at \1
.019569					_BCFloat:
.019569	20 bc 95	jsr $0195bc			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.01956c	4c 2d a3	jmp $01a32d			jmp 	FPSubtract 							; and execute code at \2
.01956f	60		rts				rts
.019570					BinaryOp_Multiply:
.019570	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.019572	35 8b		and $8b,x			and 	XS2_Type,x
.019574	4a		lsr a				lsr 	a 							; shift bit 0 into C
.019575	90 03		bcc $01957a			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.019577	4c 04 a1	jmp $01a104			jmp 	MulInteger32 							; so execute code at \1
.01957a					_BCFloat:
.01957a	20 bc 95	jsr $0195bc			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.01957d	4c 4c a4	jmp $01a44c			jmp 	FPMultiply 							; and execute code at \2
.019580	60		rts				rts
.019581					BinaryOp_Divide:
.019581	20 bc 95	jsr $0195bc			jsr 	BinaryMakeBothFloat
.019584	20 d9 a3	jsr $01a3d9			jsr 	FPDivide
.019587	60		rts				rts
.019588					AddInteger32:
.019588	18		clc				clc
.019589	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01958b	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.01958d	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01958f	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019591	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.019593	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019595	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019597	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.019599	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01959b	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01959d	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.01959f	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0195a1	60		rts				rts
.0195a2					SubInteger32:
.0195a2	38		sec				sec
.0195a3	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0195a5	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.0195a7	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0195a9	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0195ab	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.0195ad	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0195af	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0195b1	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.0195b3	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0195b5	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.0195b7	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.0195b9	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0195bb	60		rts				rts
.0195bc					BinaryMakeBothFloat:
.0195bc	da		phx				phx 								; save X
.0195bd	e8		inx				inx
.0195be	e8		inx				inx
.0195bf	e8		inx				inx
.0195c0	e8		inx				inx
.0195c1	e8		inx				inx
.0195c2	e8		inx				inx
.0195c3	20 c7 95	jsr $0195c7			jsr 	BinaryMakeFloat 			; convert to float.
.0195c6	fa		plx				plx 								; restore X and fall through.
.0195c7					BinaryMakeFloat:
.0195c7	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.0195c9	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.0195ca	b0 04		bcs $0195d0			bcs 	_BMFConvert
.0195cc	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.0195cd	b0 04		bcs $0195d3			bcs 	_BMFError
.0195cf	60		rts				rts
.0195d0					_BMFConvert:
.0195d0	4c 05 a6	jmp $01a605			jmp 	FPUToFloat 					; convert to float, only float builds of course
.0195d3					_BMFError:
.0195d3	4c 67 85	jmp $018567			jmp 	TypeError
.0195d6					ConcatenateString:
.0195d6	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.0195d8	85 1c		sta $1c				sta		zLTemp1+0
.0195da	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0195dc	85 1d		sta $1d				sta 	zLTemp1+1
.0195de	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.0195e0	85 1e		sta $1e				sta 	zLTemp1+2
.0195e2	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.0195e4	85 1f		sta $1f				sta 	zLTemp1+3
.0195e6	5a		phy				phy
.0195e7	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.0195e9	b1 1c		lda ($1c),y			lda 	(zlTemp1),y
.0195eb	71 1e		adc ($1e),y			adc 	(zlTemp1+2),y
.0195ed	7a		ply				ply
.0195ee	b0 33		bcs $019623			bcs 	_CSError					; check in range.
.0195f0	c9 fe		cmp #$fe			cmp 	#maxString+1
.0195f2	b0 2f		bcs $019623			bcs 	_CSError
.0195f4	20 8c 9a	jsr $019a8c			jsr 	AllocateTempString 			; store the result
.0195f7	20 0e 96	jsr $01960e			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.0195fa	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.0195fc	85 1c		sta $1c				sta 	zLTemp1
.0195fe	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.019600	85 1d		sta $1d				sta 	zLTemp1+1
.019602	20 0e 96	jsr $01960e			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.019605	a5 22		lda $22				lda 	zTempStr 					; point current to new string
.019607	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019609	a5 23		lda $23				lda 	zTempStr+1
.01960b	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01960d	60		rts				rts
.01960e					_CSCopyString:
.01960e	da		phx				phx
.01960f	5a		phy				phy
.019610	a0 00		ldy #$00			ldy 	#0 							; get length
.019612	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.019614	f0 0a		beq $019620			beq 	_CSCSExit 					; if zero, exit immediately
.019616	aa		tax				tax 								; put in X which is the counter.
.019617					_CSCSLoop:
.019617	c8		iny				iny 								; get next char
.019618	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.01961a	20 b7 9a	jsr $019ab7			jsr		WriteTempString 			; copy out to new string
.01961d	ca		dex				dex 								; do whole string
.01961e	d0 f7		bne $019617			bne 	_CSCSLoop
.019620					_CSCSExit:
.019620	7a		ply				ply
.019621	fa		plx				plx
.019622	60		rts				rts
.019623					_CSError:
.019623	20 86 85	jsr $018586			jsr ERR_Handler
>019626	53 74 72 69 6e 67 20 74			.text "String too long",0
>01962e	6f 6f 20 6c 6f 6e 67 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.019636					Unary_Sgn:
.019636	20 e4 93	jsr $0193e4			jsr 	EvaluateNumberX 			; get value
.019639	20 3f 9a	jsr $019a3f			jsr 	CheckNextRParen 			; check right bracket.
.01963c	20 5a 96	jsr $01965a			jsr 	GetSignCurrent 				; get sign.
.01963f	09 00		ora #$00			ora 	#0
.019641	10 08		bpl $01964b			bpl		UnarySetAInteger			; if 0,1 return that.
.019643	80 00		bra $019645			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.019645					UnarySetAMinus1:
.019645	a9 ff		lda #$ff			lda 	#$FF 						; put -1 in all four slots.
.019647	95 80		sta $80,x			sta 	XS_Mantissa,x
.019649	80 04		bra $01964f			bra 	UnarySetAFill
.01964b					UnarySetAInteger:
.01964b	95 80		sta $80,x			sta 	XS_Mantissa,x
.01964d	a9 00		lda #$00			lda 	#0
.01964f					UnarySetAFill:
.01964f	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019651	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019653	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019655	a9 01		lda #$01			lda 	#1 							; set type to integer.
.019657	95 85		sta $85,x			sta 	XS_Type,x
.019659	60		rts				rts
.01965a					GetSignCurrent:
.01965a	b5 85		lda $85,x			lda 	XS_Type,x 					; identify type.
.01965c	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.01965d	90 15		bcc $019674			bcc 	_GSCFloat 					; if clear do the float code.
.01965f	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; if msb of integer set, it's negative
.019661	30 0e		bmi $019671			bmi 	_GSCMinus1
.019663	15 80		ora $80,x			ora 	XS_Mantissa+0,x
.019665	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019667	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019669	d0 03		bne $01966e			bne 	_GSCPlus1 					; check if zero by oring all together.
.01966b					_GSCZero:
.01966b	a9 00		lda #$00			lda 	#0
.01966d	60		rts				rts
.01966e					_GSCPlus1:
.01966e	a9 01		lda #$01			lda 	#$01
.019670	60		rts				rts
.019671					_GSCMinus1:
.019671	a9 ff		lda #$ff			lda 	#$FF
.019673	60		rts				rts
.019674					_GSCFloat:
.019674	34 85		bit $85,x			bit 	XS_Type,x 					; check bits
.019676	70 f3		bvs $01966b			bvs 	_GSCZero 					; if zero flag set return zero
.019678	30 f7		bmi $019671			bmi 	_GSCMinus1 					; if sign set return -1
.01967a	80 f2		bra $01966e			bra 	_GSCPlus1		 			; else return +1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.01967c					Unary_Abs:
.01967c	20 e4 93	jsr $0193e4			jsr 	EvaluateNumberX 			; get value
.01967f	20 3f 9a	jsr $019a3f			jsr 	CheckNextRParen 			; check right bracket.
.019682	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.019684	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.019686	f0 07		beq $01968f			beq 	_UAMinusFloat
.019688	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; check MSB of upper byte to see if negative
.01968a	10 09		bpl $019695			bpl 	_UAExit
.01968c	4c c9 a1	jmp $01a1c9			jmp 	IntegerNegateAlways 		; if so negate it.
.01968f					_UAMinusFloat:
.01968f	b5 85		lda $85,x			lda 	XS_Type,x 					; clear the sign bit.
.019691	29 7f		and #$7f			and		#$7F
.019693	95 85		sta $85,x			sta 	XS_Type,x
.019695					_UAExit:
.019695	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.019696					Unary_Peek:
.019696	a9 01		lda #$01			lda 	#1 							; 1 byte
.019698	80 06		bra $0196a0			bra 	UPMain
.01969a					Unary_Deek:
.01969a	a9 02		lda #$02			lda 	#2 							; 2 bytes
.01969c	80 02		bra $0196a0			bra 	UPMain
.01969e					Unary_Leek:
.01969e	a9 04		lda #$04			lda 	#4 							; 4 bytes
.0196a0					UPMain:
.0196a0	48		pha				pha 								; save bytes to copy.
.0196a1	20 f2 93	jsr $0193f2			jsr 	EvaluateIntegerX 			; numeric parameter, the address to xEEK
.0196a4	20 3f 9a	jsr $019a3f			jsr 	CheckNextRParen 			; right bracket.
.0196a7	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.0196a9	85 1c		sta $1c				sta 	zLTemp1
.0196ab	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0196ad	85 1d		sta $1d				sta 	zLTemp1+1
.0196af	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0196b1	85 1e		sta $1e				sta 	zLTemp1+2
.0196b3	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.0196b5	85 1f		sta $1f				sta 	zLTemp1+3
.0196b7	a9 00		lda #$00			lda 	#0 							; clear target area, which might get
.0196b9	95 80		sta $80,x			sta 	XS_Mantissa+0,x 			; 1,2 or 4 bytes.
.0196bb	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0196bd	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0196bf	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0196c1	68		pla				pla 								; restore bytes to copy
.0196c2	da		phx				phx 								; save XY
.0196c3	5a		phy				phy
.0196c4	20 be 99	jsr $0199be			jsr 	MemRead 					; read the bytes in, processor dependent routine.
.0196c7	7a		ply				ply 								; restore and exit
.0196c8	fa		plx				plx
.0196c9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/pos.asm

.0196ca					Unary_Pos:
.0196ca	20 e4 93	jsr $0193e4			jsr 	EvaluateNumberX 			; get value, which is a dummy.
.0196cd	20 3f 9a	jsr $019a3f			jsr 	CheckNextRParen 			; check right bracket.
.0196d0	20 50 85	jsr $018550			jsr 	VIOCharGetPosition 			; get the position
.0196d3	4c 4b 96	jmp $01964b			jmp		UnarySetAInteger			; and return that.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.0196d6					Unary_Mod:
.0196d6	20 fe 96	jsr $0196fe			jsr 	_UMParameter 				; first parameter, get |param|
.0196d9	20 47 9a	jsr $019a47			jsr 	CheckNextComma
.0196dc	da		phx				phx 								; second parameter, get |param|
.0196dd	e8		inx				inx
.0196de	e8		inx				inx
.0196df	e8		inx				inx
.0196e0	e8		inx				inx
.0196e1	e8		inx				inx
.0196e2	e8		inx				inx
.0196e3	20 fe 96	jsr $0196fe			jsr 	_UMParameter
.0196e6	fa		plx				plx
.0196e7	20 3f 9a	jsr $019a3f			jsr 	CheckNextRParen
.0196ea	20 42 a1	jsr $01a142			jsr 	DivInteger32 				; divide, which handily leaves ....
.0196ed	a5 1c		lda $1c				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.0196ef	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0196f1	a5 1d		lda $1d				lda 	zLTemp1+1
.0196f3	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0196f5	a5 1e		lda $1e				lda 	zLTemp1+2
.0196f7	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0196f9	a5 1f		lda $1f				lda 	zLTemp1+3
.0196fb	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0196fd	60		rts				rts
.0196fe					_UMParameter:
.0196fe	20 f2 93	jsr $0193f2			jsr 	EvaluateIntegerX 			; get value
.019701	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; absolute value
.019703	10 03		bpl $019708			bpl 	_UMNotSigned
.019705	20 c9 a1	jsr $01a1c9			jsr 	IntegerNegateAlways
.019708					_UMNotSigned:
.019708	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.019709					Unary_Usr:
.019709	20 e4 93	jsr $0193e4			jsr 	EvaluateNumberX 			; numeric parameter
.01970c	20 3f 9a	jsr $019a3f			jsr 	CheckNextRParen 			; right bracket.
.01970f	da		phx				phx 								; save XY
.019710	5a		phy				phy
.019711	22 0c 03 00	jsl $00030c			jsl 	UserVector 					; with the parameter in the base mantissa
.019715	7a		ply				ply 								; restore YX and exit with whatever the
.019716	fa		plx				plx 								; routine called has chosen to do with it.
.019717	60		rts				rts
.019718					USRDefault:
.019718	20 86 85	jsr $018586			jsr ERR_Handler
>01971b	4e 6f 20 55 53 52 20 76			.text "No USR vector.",0
>019723	65 63 74 6f 72 2e 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.01972a					Unary_Val:
.01972a	20 fb 93	jsr $0193fb			jsr 	EvaluateStringX 			; get string
.01972d	20 3f 9a	jsr $019a3f			jsr 	CheckNextRParen 			; check right bracket.
.019730	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.019732	85 20		sta $20				sta 	zGenPtr
.019734	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019736	85 21		sta $21				sta 	zGenPtr+1
.019738	da		phx				phx
.019739	5a		phy				phy
.01973a	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.01973c	b1 20		lda ($20),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.01973e	f0 1b		beq $01975b			beq 	UVBadNumber
.019740	aa		tax				tax
.019741					_UVCopy1:
.019741	c8		iny				iny
.019742	c0 18		cpy #$18			cpy 	#24 						; too long
.019744	f0 15		beq $01975b			beq 	UVBadNumber
.019746	b1 20		lda ($20),y			lda 	(zGenPtr),y					; copy character
.019748	99 14 03	sta $0314,y			sta 	Num_Buffer-1,y
.01974b	a9 00		lda #$00			lda 	#0 							; make string ASCIIZ.
.01974d	99 15 03	sta $0315,y			sta 	Num_Buffer,y
.019750	ca		dex				dex
.019751	d0 ee		bne $019741			bne 	_UVCopy1
.019753	7a		ply				ply
.019754	fa		plx				plx
.019755	20 69 97	jsr $019769			jsr 	ConvertNumBuffer 			; convert string in NumBuffer to mantissa,x
.019758	b0 01		bcs $01975b			bcs 	UVBadNumber
.01975a	60		rts				rts
.01975b					UVBadNumber:
.01975b	20 86 85	jsr $018586			jsr ERR_Handler
>01975e	42 61 64 20 4e 75 6d 62			.text "Bad Number",0
>019766	65 72 00
.019769					ConvertNumBuffer:
.019769	5a		phy				phy
.01976a	a9 15		lda #$15			lda 	#Num_Buffer & $FF 			; set zGenPtr to point to buffer.
.01976c	85 20		sta $20				sta 	zGenPtr
.01976e	a9 03		lda #$03			lda 	#Num_Buffer >> 8
.019770	85 21		sta $21				sta 	zGenPtr+1
.019772	ad 15 03	lda $0315			lda 	Num_Buffer 					; first character is - ?
.019775	c9 2d		cmp #$2d			cmp 	#"-"
.019777	d0 02		bne $01977b			bne 	_UVNotMinus1
.019779	e6 20		inc $20				inc 	zGenPtr 					; this time just fix the pointer.
.01977b					_UVNotMinus1:
.01977b	20 9b a2	jsr $01a29b			jsr 	IntFromString 				; get integer
.01977e	b0 22		bcs $0197a2			bcs 	_UVFail
.019780	20 0b a8	jsr $01a80b			jsr 	FPFromString 				; possibly float it.
.019783	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; done the whole string
.019785	d0 1b		bne $0197a2			bne 	_UVFail 					; no, exit.
.019787	ad 15 03	lda $0315			lda 	Num_Buffer 					; look at numbuffer
.01978a	c9 2d		cmp #$2d			cmp 	#"-"
.01978c	d0 11		bne $01979f			bne 	_UVNotMinus2
.01978e	b5 85		lda $85,x			lda 	XS_Type,x 					; type is float ?
.019790	29 0f		and #$0f			and 	#$0F
.019792	f0 05		beq $019799			beq 	_UVNegateFloat
.019794	20 c9 a1	jsr $01a1c9			jsr 	IntegerNegateAlways
.019797	80 06		bra $01979f			bra 	_UVNotMinus2
.019799					_UVNegateFloat:
.019799	b5 85		lda $85,x			lda 	XS_Type,x 					; set the sign bit.
.01979b	09 80		ora #$80			ora 	#$80
.01979d	95 85		sta $85,x			sta 	XS_Type,x
.01979f					_UVNotMinus2:
.01979f	7a		ply				ply
.0197a0	18		clc				clc
.0197a1	60		rts				rts
.0197a2	7a		ply		_UVFail:ply
.0197a3	38		sec				sec
.0197a4	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.0197a5					Unary_Str:
.0197a5	20 e4 93	jsr $0193e4			jsr 	EvaluateNumberX 			; numeric parameter
.0197a8	20 3f 9a	jsr $019a3f			jsr 	CheckNextRParen 			; right bracket.
.0197ab	a9 00		lda #$00			lda 	#0 							; reset buffer index
.0197ad	8d 14 03	sta $0314			sta 	NumBufX
.0197b0	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.0197b2	4a		lsr a				lsr 	a 							; bit 0 identifies an integer.
.0197b3	b0 05		bcs $0197ba			bcs 	_USInt 						; if msb set do as integer
.0197b5	20 50 a7	jsr $01a750			jsr 	FPToString 					; call fp to str otherwise
.0197b8	80 03		bra $0197bd			bra 	_USDuplicate
.0197ba	20 e6 a1	jsr $01a1e6	_USInt:	jsr 	IntToString					; call int to str.
.0197bd					_USDuplicate:
.0197bd	ad 14 03	lda $0314			lda 	NumBufX 					; chars in buffer
.0197c0	1a		inc a				inc 	a 							; one more for length
.0197c1	20 8c 9a	jsr $019a8c			jsr 	AllocateTempString 			; allocate space for it.
.0197c4	5a		phy				phy 								; save Y
.0197c5	a0 00		ldy #$00			ldy 	#0 							; start copying
.0197c7	b9 15 03	lda $0315,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.0197ca	20 b7 9a	jsr $019ab7			jsr 	WriteTempString
.0197cd	c8		iny				iny
.0197ce	cc 14 03	cpy $0314			cpy 	NumBufX 					; done the lot
.0197d1	d0 f4		bne $0197c7			bne 	_USCopy
.0197d3	7a		ply				ply 								; restore Y
.0197d4	4c b1 99	jmp $0199b1			jmp 	UnaryReturnTempStr 			; return newly created temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.0197d7					Unary_Asc:
.0197d7	20 fb 93	jsr $0193fb			jsr 	EvaluateStringX 			; string parameter
.0197da	20 3f 9a	jsr $019a3f			jsr 	CheckNextRParen 			; right bracket.
.0197dd	5a		phy				phy 								; get the string length
.0197de	a0 00		ldy #$00			ldy 	#0
.0197e0	b1 20		lda ($20),y			lda 	(zGenPtr),y
.0197e2	f0 07		beq $0197eb			beq 	_UAIllegal 					; must be at least one character, 0 => error
.0197e4	c8		iny				iny
.0197e5	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; read the first character
.0197e7	7a		ply				ply
.0197e8	4c 4b 96	jmp $01964b			jmp 	UnarySetAInteger 			; return that as an integer 0-255.
.0197eb					_UAIllegal:
.0197eb	4c 75 85	jmp $018575			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.0197ee					Unary_Len:
.0197ee	20 fb 93	jsr $0193fb			jsr 	EvaluateStringX 			; string parameter
.0197f1	20 3f 9a	jsr $019a3f			jsr 	CheckNextRParen 			; right bracket.
.0197f4	5a		phy				phy 								; get the string length
.0197f5	a0 00		ldy #$00			ldy 	#0
.0197f7	b1 20		lda ($20),y			lda 	(zGenPtr),y
.0197f9	7a		ply				ply
.0197fa	4c 4b 96	jmp $01964b			jmp 	UnarySetAInteger 			; return as an integer.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.0197fd					Unary_Mid:
.0197fd	20 fb 93	jsr $0193fb			jsr 	EvaluateStringX 				; get string.
.019800	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.019802	48		pha				pha
.019803	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019805	48		pha				pha
.019806	20 47 9a	jsr $019a47			jsr 	CheckNextComma 					; skip comma
.019809	20 92 98	jsr $019892			jsr 	SLIByteParameter 				; get a byte parameter (start)
.01980c	48		pha				pha 									; and push it.
.01980d	20 47 9a	jsr $019a47			jsr 	CheckNextComma 					; skip comma
.019810	20 92 98	jsr $019892			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.019813	48		pha				pha 									; and push it.
.019814	80 41		bra $019857			bra 	SLIProcess
.019816					Unary_Left:
.019816	20 fb 93	jsr $0193fb			jsr 	EvaluateStringX 				; get string.
.019819	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.01981b	48		pha				pha
.01981c	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01981e	48		pha				pha
.01981f	a9 01		lda #$01			lda 	#1 								; push start position (1)
.019821	48		pha				pha
.019822	20 47 9a	jsr $019a47			jsr 	CheckNextComma 					; skip comma
.019825	20 92 98	jsr $019892			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.019828	48		pha				pha 									; and push it.
.019829	80 2c		bra $019857			bra 	SLIProcess
.01982b					Unary_Right:
.01982b	20 fb 93	jsr $0193fb			jsr 	EvaluateStringX 				; get string.
.01982e	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.019830	48		pha				pha
.019831	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019833	48		pha				pha
.019834	da		phx				phx 									; get the string length and push on stack.
.019835	a2 00		ldx #$00			ldx 	#0
.019837	a1 20		lda ($20,x)			lda		(zGenPtr,x)
.019839	fa		plx				plx
.01983a	48		pha				pha
.01983b	20 47 9a	jsr $019a47			jsr 	CheckNextComma 					; skip comma
.01983e	20 92 98	jsr $019892			jsr 	SLIByteParameter 				; get a byte parameter.
.019841	8d 9e 03	sta $039e			sta 	SignCount 						; save in temporary.
.019844	68		pla				pla 									; restore string length.
.019845	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.019846	38		sec				sec
.019847	ed 9e 03	sbc $039e			sbc 	SignCount 						; subtract characters needed, gives start position.
.01984a	f0 02		beq $01984e			beq 	_URStart 						; if <= 0 start from 1.
.01984c	10 02		bpl $019850			bpl 	_UROkay
.01984e					_URStart:
.01984e	a9 01		lda #$01			lda 	#1
.019850					_UROkay:
.019850	48		pha				pha 									; push start
.019851	ad 9e 03	lda $039e			lda 	SignCount 						; push count of characters
.019854	48		pha				pha
.019855	80 00		bra $019857			bra 	SLIProcess
.019857					SLIProcess:
.019857	20 3f 9a	jsr $019a3f			jsr 	CheckNextRParen 				; closing right bracket.
.01985a	68		pla				pla
.01985b	8d a2 03	sta $03a2			sta 	SliceCount 						; count in signcount
.01985e	1a		inc a				inc 	a 								; allocate +1 for it.
.01985f	20 8c 9a	jsr $019a8c			jsr 	AllocateTempString
.019862	68		pla				pla 									; pop start number off stack.
.019863	f0 3b		beq $0198a0			beq 	SLIError 						; exit if start = 0
.019865	8d a1 03	sta $03a1			sta 	SliceStart
.019868	68		pla				pla  									; pop string address.
.019869	85 21		sta $21				sta 	zGenPtr+1
.01986b	68		pla				pla
.01986c	85 20		sta $20				sta 	zGenPtr
.01986e	da		phx				phx
.01986f	5a		phy				phy
.019870	a2 00		ldx #$00			ldx 	#0 								; point to string length.
.019872	ac a1 03	ldy $03a1			ldy 	SliceStart 						; start of the string (+1 for count)
.019875					_SLICopy:
.019875	ad a2 03	lda $03a2			lda 	SliceCount 						; done count characters
.019878	f0 12		beq $01988c			beq 	_SLIExit
.01987a	ce a2 03	dec $03a2			dec 	SliceCount
.01987d	98		tya				tya 									; index of character
.01987e	c1 20		cmp ($20,x)			cmp 	(zGenPtr,x)						; compare against length
.019880	f0 02		beq $019884			beq 	_SLIOk 							; if equal, okay.
.019882	b0 08		bcs $01988c			bcs 	_SLIExit 						; if past end, then exit.
.019884	b1 20		lda ($20),y	_SLIOk:	lda 	(zGenPtr),y 					; copy one character
.019886	c8		iny				iny
.019887	20 b7 9a	jsr $019ab7			jsr 	WriteTempString
.01988a	80 e9		bra $019875			bra 	_SLICopy 						; go round till copied characters
.01988c					_SLIExit:
.01988c	7a		ply				ply 									; restore YX
.01988d	fa		plx				plx
.01988e	4c b1 99	jmp $0199b1			jmp 	UnaryReturnTempStr 				; return new temporary string.
.019891	ea		nop				nop
.019892					SLIByteParameter:
.019892	20 f2 93	jsr $0193f2			jsr 	EvaluateIntegerX 				; get integer
.019895	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.019897	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019899	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01989b	d0 03		bne $0198a0			bne 	SLIError
.01989d	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01989f	60		rts				rts
.0198a0					SLIError:
.0198a0	4c 75 85	jmp $018575			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.0198a3					Unary_Hex:
.0198a3	20 f2 93	jsr $0193f2			jsr 	EvaluateIntegerX 			; numeric parameter
.0198a6	20 3f 9a	jsr $019a3f			jsr 	CheckNextRParen 			; right bracket.
.0198a9	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.0198ab	20 8c 9a	jsr $019a8c			jsr 	AllocateTempString			; allocate string space
.0198ae	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.0198b0	20 d4 98	jsr $0198d4			jsr 	_UHConvert
.0198b3	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0198b5	20 d4 98	jsr $0198d4			jsr 	_UHConvert
.0198b8	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0198ba	20 d4 98	jsr $0198d4			jsr 	_UHConvert
.0198bd	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0198bf	20 d4 98	jsr $0198d4			jsr 	_UHConvert
.0198c2	5a		phy				phy 								; get length of new string
.0198c3	a0 00		ldy #$00			ldy 	#0
.0198c5	b1 22		lda ($22),y			lda 	(zTempStr),y
.0198c7	7a		ply				ply
.0198c8	c9 00		cmp #$00			cmp 	#0 							; if it was non zero okay
.0198ca	d0 05		bne $0198d1			bne 	_UHExit 					; otherwise suppressed all leading zeros !
.0198cc	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.0198ce	20 b7 9a	jsr $019ab7			jsr 	WriteTempString
.0198d1					_UHExit:
.0198d1	4c b1 99	jmp $0199b1			jmp 	UnaryReturnTempStr 			; return new temporary string.
.0198d4					_UHConvert:
.0198d4	48		pha				pha
.0198d5	4a		lsr a				lsr 	a 							; do MSB
.0198d6	4a		lsr a				lsr 	a
.0198d7	4a		lsr a				lsr 	a
.0198d8	4a		lsr a				lsr 	a
.0198d9	20 dd 98	jsr $0198dd			jsr 	_UHNibble
.0198dc	68		pla				pla 								; do LSB
.0198dd					_UHNibble:
.0198dd	29 0f		and #$0f			and 	#15 						; get nibble
.0198df	d0 0c		bne $0198ed			bne 	_UHNonZero 					; if not zero, write it out anyway.
.0198e1	5a		phy				phy									; get the length
.0198e2	a0 00		ldy #$00			ldy 	#0
.0198e4	b1 22		lda ($22),y			lda 	(zTempStr),y
.0198e6	7a		ply				ply
.0198e7	c9 00		cmp #$00			cmp 	#0 							; length = 0 => suppress leading zeros.
.0198e9	f0 0d		beq $0198f8			beq 	_UHExit2
.0198eb	a9 00		lda #$00			lda 	#0 							; length > 0, so can't suppress any more.
.0198ed					_UHNonZero:
.0198ed	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.0198ef	90 02		bcc $0198f3			bcc 	_UHDigit
.0198f1	69 06		adc #$06			adc 	#7-1
.0198f3					_UHDigit:
.0198f3	69 30		adc #$30			adc 	#48
.0198f5	20 b7 9a	jsr $019ab7			jsr 	WriteTempString				; output to temp string.
.0198f8					_UHExit2:
.0198f8	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.0198f9					Unary_Dec:
.0198f9	20 fb 93	jsr $0193fb			jsr 	EvaluateStringX 			; string parameter
.0198fc	20 3f 9a	jsr $019a3f			jsr 	CheckNextRParen 			; right bracket.
.0198ff	5a		phy				phy
.019900	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.019902	b1 20		lda ($20),y			lda 	(zGenPtr),y
.019904	f0 43		beq $019949			beq 	_UDFail 					; must fail if zero.
.019906	8d 9e 03	sta $039e			sta 	SignCount 					; use SignCount as a counter of chars to process.
.019909	a9 00		lda #$00			lda 	#0 							; set result to zero
.01990b	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01990d	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01990f	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019911	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019913	a9 01		lda #$01			lda 	#1 							; set type to integer.
.019915	95 85		sta $85,x			sta 	XS_Type,x
.019917					_UDConvertLoop:
.019917	5a		phy				phy 								; shift mantissa left 4
.019918	a0 04		ldy #$04			ldy 	#4
.01991a					_UDShift:
.01991a	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.01991c	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.01991e	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.019920	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.019922	88		dey				dey
.019923	d0 f5		bne $01991a			bne 	_UDShift
.019925	7a		ply				ply
.019926	c8		iny				iny 								; next character
.019927	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; fetch it.
.019929	20 4c 99	jsr $01994c			jsr 	ConvertUpper 				; convert to U/C
.01992c	c9 30		cmp #$30			cmp 	#"0" 						; range 0-9
.01992e	90 19		bcc $019949			bcc 	_UDFail
.019930	c9 3a		cmp #$3a			cmp 	#"9"+1
.019932	90 08		bcc $01993c			bcc 	_UDOkay
.019934	e9 37		sbc #$37			sbc 	#7+"0" 						; A-F fudge
.019936	90 11		bcc $019949			bcc 	_UDFail 					; fails if between 9 and @
.019938	c9 10		cmp #$10			cmp 	#16 						; must be < 16 as hexadecimal.
.01993a	b0 0d		bcs $019949			bcs 	_UDFail
.01993c					_UDOkay:
.01993c	29 0f		and #$0f			and 	#15 						; nibble only
.01993e	15 80		ora $80,x			ora 	XS_Mantissa+0,x 			; OR into the bottom byte.
.019940	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019942	ce 9e 03	dec $039e			dec 	SignCount 					; do it for each character in the string.
.019945	d0 d0		bne $019917			bne 	_UDConvertLoop
.019947	7a		ply				ply
.019948	60		rts				rts
.019949					_UDFail:
.019949	4c 75 85	jmp $018575			jmp 	BadParamError
.01994c					ConvertUpper:
.01994c	c9 61		cmp #$61			cmp 	#"a"
.01994e	90 07		bcc $019957			bcc 	_CUExit
.019950	c9 7b		cmp #$7b			cmp 	#"z"+1
.019952	b0 03		bcs $019957			bcs 	_CUExit
.019954	38		sec				sec
.019955	e9 20		sbc #$20			sbc 	#32
.019957	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.019958					Unary_Chr:
.019958	20 f2 93	jsr $0193f2			jsr 	EvaluateIntegerX			; numeric parameter which is the character we want
.01995b	20 3f 9a	jsr $019a3f			jsr 	CheckNextRParen 			; right bracket.
.01995e	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.019960	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019962	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019964	d0 0d		bne $019973			bne 	_UCChar
.019966	a9 02		lda #$02			lda 	#1+1 						; one character string. 2 bytes - size+char
.019968	20 8c 9a	jsr $019a8c			jsr 	AllocateTempString			; allocate it.
.01996b	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.01996d	20 b7 9a	jsr $019ab7			jsr 	WriteTempString
.019970	4c b1 99	jmp $0199b1			jmp 	UnaryReturnTempStr 			; and return that string.
.019973					_UCChar:
.019973	4c 75 85	jmp $018575			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.019976					Unary_Spc:
.019976	20 92 98	jsr $019892			jsr 	SLIByteParameter 			; get number of spaces
.019979	20 3f 9a	jsr $019a3f			jsr 	CheckNextRParen 			; skip )
.01997c	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; count of spaces
.01997e					UnarySpcCreate:
.01997e	c9 fe		cmp #$fe			cmp 	#maxString+1				; validate
.019980	b0 14		bcs $019996			bcs 	_USSize
.019982	48		pha				pha 								; save length
.019983	1a		inc a				inc 	a 							; allocate one more.
.019984	20 8c 9a	jsr $019a8c			jsr 	AllocateTempString
.019987	68		pla				pla 								; get length
.019988	f0 27		beq $0199b1			beq 	UnaryReturnTempStr 			; if zero (spc(0)) return the current temp string
.01998a					_USLoop:
.01998a	48		pha				pha
.01998b	a9 20		lda #$20			lda 	#" "
.01998d	20 b7 9a	jsr $019ab7			jsr 	WriteTempString
.019990	68		pla				pla
.019991	3a		dec a				dec 	a
.019992	d0 f6		bne $01998a			bne 	_USLoop
.019994	80 1b		bra $0199b1			bra 	UnaryReturnTempStr 			; and return the temporary space.
.019996					_USSize:
.019996	4c 75 85	jmp $018575			jmp 	BadParamError
.019999					Unary_Tab:
.019999	a2 00		ldx #$00			ldx 	#0 							; required TAB position.
.01999b	20 92 98	jsr $019892			jsr 	SLIByteParameter
.01999e	20 3f 9a	jsr $019a3f			jsr 	CheckNextRParen
.0199a1	20 50 85	jsr $018550			jsr 	VIOCharGetPosition 			; were are we ?
.0199a4	85 10		sta $10				sta 	zTemp1 						; calculate required-current
.0199a6	38		sec				sec
.0199a7	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; return chars required.
.0199a9	e5 10		sbc $10				sbc 	zTemp1
.0199ab	b0 d1		bcs $01997e			bcs 	UnarySpcCreate 				; if not there, use SPC() code to generate string
.0199ad	a9 00		lda #$00			lda 	#0 							; if there or better, no characters required.
.0199af	80 cd		bra $01997e			bra 	UnarySpcCreate
.0199b1					UnaryReturnTempStr:
.0199b1	a5 22		lda $22				lda 	zTempStr 					; copy temp string addr -> mantissa
.0199b3	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0199b5	a5 23		lda $23				lda 	zTempStr+1
.0199b7	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0199b9	a9 02		lda #$02			lda 	#2 							; set type to string
.0199bb	95 85		sta $85,x			sta 	XS_Type,x
.0199bd	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/65816.asm

.0199be					MemRead:
.0199be	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.0199c1	a0 00		ldy #$00			ldy 	#0 							; start from here
.0199c3	b7 1c		lda [$1c],y	_MLoop1:lda 	[zlTemp1],y 				; read the long address
.0199c5	95 80		sta $80,x			sta 	XS_Mantissa,x 				; copy into mantissa
.0199c7	c8		iny				iny 								; next to copy
.0199c8	e8		inx				inx
.0199c9	cc 9e 03	cpy $039e			cpy 	SignCount 					; do required # of bytes.
.0199cc	d0 f5		bne $0199c3			bne 	_MLoop1
.0199ce	60		rts				rts
.0199cf					MemWrite:
.0199cf	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.0199d2	a0 00		ldy #$00			ldy 	#0 							; start from here
.0199d4	b5 80		lda $80,x	_MLoop1:lda 	XS_Mantissa,x 				; read mantisssa
.0199d6	97 1c		sta [$1c],y			sta 	[zlTemp1],y 				; write it out
.0199d8	c8		iny				iny 								; next to copy
.0199d9	e8		inx				inx
.0199da	cc 9e 03	cpy $039e			cpy 	SignCount 					; do required # of bytes.
.0199dd	d0 f5		bne $0199d4			bne 	_MLoop1
.0199df	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/program/editor.asm

.0199e0					EditCode:
.0199e0	ea		nop				nop
.0199e1	80 fd		bra $0199e0			bra 	EditCode

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/programend.asm

.0199e3					UpdateProgramEnd:
.0199e3	a9 00		lda #$00			lda 	#(BasicProgram) & $FF
.0199e5	85 18		sta $18				sta 	zCodePtr+0
.0199e7	a9 20		lda #$20			lda 	#((BasicProgram) >> 8) & $FF
.0199e9	85 19		sta $19				sta 	zCodePtr+1
.0199eb	a9 01		lda #$01			lda 	#(BasicProgram) >> 16
.0199ed	85 1a		sta $1a				sta 	zCodePtr+2
.0199ef	85 1b		sta $1b				sta 	zCodePtr+3
.0199f1	a0 03		ldy #$03			ldy 	#3
.0199f3					_UPDLoop:
.0199f3	a0 00		ldy #$00			ldy 	#0
.0199f5	b7 18		lda [$18],y			lda 	[zCodePtr],y
.0199f7	c9 00		cmp #$00			cmp 	#0 							; end if offset is zero.
.0199f9	f0 0f		beq $019a0a			beq 	_UPDFoundEnd
.0199fb	a0 00		ldy #$00			ldy 	#0 							; point to offset
.0199fd	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read it
.0199ff	18		clc				clc
.019a00	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.019a02	85 18		sta $18				sta 	zCodePtr
.019a04	90 02		bcc $019a08			bcc 	_SNLNoCarry
.019a06	e6 19		inc $19				inc 	zCodePtr+1
.019a08					_SNLNoCarry:
.019a08	80 e9		bra $0199f3			bra 	_UPDLoop
.019a0a					_UPDFoundEnd:
.019a0a	18		clc				clc 								; end of program 2 on.
.019a0b	a5 18		lda $18				lda 	zCodePtr
.019a0d	69 02		adc #$02			adc 	#2
.019a0f	8d 04 03	sta $0304			sta 	endOfProgram
.019a12	a5 19		lda $19				lda 	zCodePtr+1
.019a14	69 00		adc #$00			adc 	#0
.019a16	8d 05 03	sta $0305			sta 	endOfProgram+1
.019a19	a5 1a		lda $1a				lda 	zCodePtr+2
.019a1b	69 00		adc #$00			adc		#0
.019a1d	8d 06 03	sta $0306			sta 	endOfProgram+2
.019a20	a5 1b		lda $1b				lda 	zCodePtr+3
.019a22	69 00		adc #$00			adc 	#0
.019a24	8d 07 03	sta $0307			sta 	endOfProgram+3
.019a27	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.019a28					CheckNextToken:
.019a28	d7 18		cmp [$18],y			cmp 	[zCodePtr],y
.019a2a	d0 02		bne $019a2e			bne 	CTFail 						; no, then fail
.019a2c	c8		iny				iny
.019a2d	60		rts				rts
.019a2e					CTFail:
.019a2e	20 86 85	jsr $018586			jsr ERR_Handler
>019a31	4d 69 73 73 69 6e 67 20			.text "Missing token",0
>019a39	74 6f 6b 65 6e 00
.019a3f					CheckNextRParen:
.019a3f	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019a41	c9 be		cmp #$be			cmp 	#token_rparen 						; does it match
.019a43	d0 e9		bne $019a2e			bne 	CTFail 						; fail if not
.019a45	c8		iny				iny
.019a46	60		rts				rts
.019a47					CheckNextComma:
.019a47	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019a49	c9 bf		cmp #$bf			cmp 	#token_comma 						; does it match
.019a4b	d0 e1		bne $019a2e			bne 	CTFail 						; fail if not
.019a4d	c8		iny				iny
.019a4e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/concrete.asm

.019a4f					StringConcrete:
.019a4f	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; save source string to zTemp1
.019a51	85 10		sta $10				sta 	zTemp1
.019a53	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019a55	85 11		sta $11				sta 	zTemp1+1
.019a57	a0 00		ldy #$00			ldy 	#0 							; empty string, return default empty
.019a59	b1 10		lda ($10),y			lda 	(zTemp1),y
.019a5b	f0 26		beq $019a83			beq		_SCEmpty 					; concreting it wastes memory.
.019a5d	18		clc				clc 								; from the string pointer
.019a5e	ad 00 03	lda $0300			lda 	StringPtr 					; and put in zTemp2 as well
.019a61	f1 10		sbc ($10),y			sbc 	(zTemp1),y
.019a63	8d 00 03	sta $0300			sta 	StringPtr
.019a66	85 12		sta $12				sta 	zTemp2
.019a68	ad 01 03	lda $0301			lda 	StringPtr+1
.019a6b	e9 00		sbc #$00			sbc 	#0
.019a6d	8d 01 03	sta $0301			sta 	StringPtr+1
.019a70	85 13		sta $13				sta 	zTemp2+1
.019a72	b1 10		lda ($10),y			lda 	(zTemp1),y 					; length add one for count
.019a74	1a		inc a				inc 	a
.019a75	aa		tax				tax
.019a76	b1 10		lda ($10),y	_SCCopy:lda 	(zTemp1),y 					; copy whole thing including length
.019a78	91 12		sta ($12),y			sta 	(zTemp2),y
.019a7a	c8		iny				iny
.019a7b	ca		dex				dex
.019a7c	d0 f8		bne $019a76			bne 	_SCCopy
.019a7e	a5 13		lda $13				lda 	zTemp2+1 					; return concrete string in AX
.019a80	a6 12		ldx $12				ldx 	zTemp2
.019a82	60		rts				rts
.019a83					_SCEmpty:
.019a83	a9 00		lda #$00			lda 	#0
.019a85	85 27		sta $27				sta 	zNullString
.019a87	a9 00		lda #$00			lda 	#zNullString >> 8
.019a89	a2 27		ldx #$27			ldx 	#zNulLString & $FF
.019a8b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.019a8c					AllocateTempString:
.019a8c	48		pha				pha 								; save required count.
.019a8d	a5 23		lda $23				lda 	zTempStr+1 					; check if initialised yet ?
.019a8f	d0 0b		bne $019a9c			bne 	_ATSInitialised
.019a91	ad 00 03	lda $0300			lda 	StringPtr 					; set temporary string ptr 1 page below available
.019a94	85 22		sta $22				sta 	zTempStr					; space, this is for strings to be concreted.
.019a96	ad 01 03	lda $0301			lda 	StringPtr+1
.019a99	3a		dec a				dec 	a 							; allow the page.
.019a9a	85 23		sta $23				sta 	zTempStr+1
.019a9c					_ATSInitialised:
.019a9c	68		pla				pla 								; get required count back.
.019a9d	49 ff		eor #$ff			eor 	#$FF 						; negate and add 2's complement.
.019a9f	1a		inc a				inc 	a
.019aa0	18		clc				clc
.019aa1	65 22		adc $22				adc 	zTempStr 					; "add" to the temp string pointer
.019aa3	85 22		sta $22				sta 	zTempStr					; which means the tsp is also the current.
.019aa5	a9 ff		lda #$ff			lda 	#$FF
.019aa7	65 23		adc $23				adc 	zTempStr+1
.019aa9	85 23		sta $23				sta 	zTempStr+1
.019aab	a9 00		lda #$00			lda 	#0 							; clear temp string by zeroing length.
.019aad	5a		phy				phy
.019aae	a8		tay				tay
.019aaf	91 22		sta ($22),y			sta 	(zTempStr),y
.019ab1	7a		ply				ply
.019ab2	1a		inc a				inc 	a 							; reset the write index to 1 (first character)
.019ab3	8d 9f 03	sta $039f			sta 	TempStringWriteIndex
.019ab6	60		rts				rts
.019ab7					WriteTempString:
.019ab7	5a		phy				phy 								; save Y
.019ab8	ac 9f 03	ldy $039f			ldy 	TempStringWriteIndex	 	; write position.
.019abb	91 22		sta ($22),y			sta 	(zTempStr),y 				; write character out.
.019abd	ee 9f 03	inc $039f			inc 	TempStringWriteIndex 		; increment the write position.
.019ac0	98		tya				tya 								; unchanged Y is now length
.019ac1	a0 00		ldy #$00			ldy 	#0
.019ac3	91 22		sta ($22),y			sta 	(zTempStr),y
.019ac5	7a		ply				ply 								; restore Y and exit
.019ac6	60		rts				rts
.019ac7					CreateTempStringCopy:
.019ac7	da		phx				phx 								; save X
.019ac8	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019aca	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.019acb	20 8c 9a	jsr $019a8c			jsr 	AllocateTempString 			; allocate memory for temporary string.
.019ace	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019ad0	c8		iny				iny
.019ad1	3a		dec a				dec 	a 							; make the actual length in characters, allowing
.019ad2	3a		dec a				dec 	a 							; for the marker and the length.
.019ad3	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.019ad5	81 22		sta ($22,x)			sta 	(zTempStr,x)
.019ad7	85 1c		sta $1c				sta 	zLTemp1 					; that's used as a count.
.019ad9	09 00		ora #$00			ora 	#0 							; if zero already, exit
.019adb	f0 0e		beq $019aeb			beq 	_CTSCExit
.019add					_CTSCLoop:
.019add	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019adf	c8		iny				iny
.019ae0	5a		phy				phy 								; save Y
.019ae1	e8		inx				inx 								; bump index
.019ae2	da		phx				phx 								; save that
.019ae3	7a		ply				ply 								; index into Y
.019ae4	91 22		sta ($22),y			sta 	(zTempStr),y 				; save at index position
.019ae6	7a		ply				ply 								; restore Y
.019ae7	c6 1c		dec $1c				dec 	zLTemp1 					; do for each character, this is the counter.
.019ae9	d0 f2		bne $019add			bne 	_CTSCLoop
.019aeb					_CTSCExit:
.019aeb	fa		plx				plx 								; restore X
.019aec	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/basic/tokenise/tokkeyword.asm

.019aed					TokeniseKeyword:
.019aed	98		tya				tya 								; fix up genptr so Y = 0 access the current one.
.019aee	18		clc				clc
.019aef	65 20		adc $20				adc 	zGenPtr
.019af1	85 20		sta $20				sta 	zGenPtr
.019af3	90 02		bcc $019af7			bcc 	_TKWNoBump
.019af5	e6 21		inc $21				inc 	zGenPtr+1
.019af7					_TKWNoBump:
.019af7	a0 00		ldy #$00			ldy 	#0 							; this adds Y to genPtr, so it will still scan
.019af9	da		phx				phx
.019afa	a9 cf		lda #$cf			lda 	#KeyWordText & $FF 			; scan this table.
.019afc	a2 86		ldx #$86			ldx 	#(KeyWordText >> 8) & $FF
.019afe	20 09 9b	jsr $019b09			jsr 	TKWScanTokenTable
.019b01	fa		plx				plx
.019b02	90 04		bcc $019b08			bcc 	_TKWNoWrite
.019b04	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x 			; write the token out.
.019b07	e8		inx				inx
.019b08					_TKWNoWrite:
.019b08	60		rts				rts
.019b09					TKWScanTokenTable:
.019b09	86 1d		stx $1d				stx 	zLTemp1+1
.019b0b	85 1c		sta $1c				sta 	zLTemp1+0 						; store at zLTemp1
.019b0d	a9 01		lda #$01			lda 	#KeywordText >> 16 				; 24 bit addresses in the 65816
.019b0f	85 1e		sta $1e				sta 	zLTemp1+2 						; lovely.
.019b11	a0 00		ldy #$00			ldy 	#0 								; read and capitalise the first character
.019b13	84 12		sty $12				sty 	zTemp2 							; zero the longest length match.
.019b15	b1 20		lda ($20),y			lda 	(zGenPtr),y
.019b17	20 24 9c	jsr $019c24			jsr 	TOKCapitalise 					; save this in zTemp3
.019b1a	85 14		sta $14				sta 	zTemp3
.019b1c	a9 80		lda #$80			lda 	#$80 							; current token in zTemp3+1
.019b1e	85 15		sta $15				sta 	zTemp3+1
.019b20					_TKWScanLoop:
.019b20	b7 1c		lda [$1c],y			lda 	[zLTemp1],y
.019b22	29 7f		and #$7f			and 	#$7F 							; drop bit 7, it might be 1 character long.
.019b24	c5 14		cmp $14				cmp 	zTemp3 							; compare against got character.
.019b26	d0 26		bne $019b4e			bne		_TKWNext 						; if it doesn't match, go to next.
.019b28	20 6d 9b	jsr $019b6d			jsr 	_TKWClearY 						; make it so (zTemp1),y now points to zTemp1
.019b2b	a0 00		ldy #$00			ldy 	#0 								; compare the tokens directly
.019b2d					_TKWCompareFull:
.019b2d	b7 1c		lda [$1c],y			lda 	[zLTemp1],y
.019b2f	29 7f		and #$7f			and 	#$7F 							; drop bit 7
.019b31	85 16		sta $16				sta 	zTemp4
.019b33	b1 20		lda ($20),y			lda 	(zGenPtr),y 					; compare against keyword in text.
.019b35	20 24 9c	jsr $019c24			jsr 	TOKCapitalise 					; make it U/C
.019b38	c5 16		cmp $16				cmp 	zTemp4 							; compare against table char w/o bit 7.
.019b3a	d0 12		bne $019b4e			bne 	_TKWNext 						; failed, go to next slot.
.019b3c	b7 1c		lda [$1c],y			lda 	[zLTemp1],y
.019b3e	c8		iny				iny 									; bump pointer
.019b3f	0a		asl a				asl 	a 								; shift bit 7 into C
.019b40	90 eb		bcc $019b2d			bcc 	_TKWCompareFull					; keep going till that bit is 7 e.g. token matches
.019b42	c4 12		cpy $12				cpy 	zTemp2 							; compare against longest match
.019b44	90 08		bcc $019b4e			bcc 	_TKWNext 						; if shorter, the original was better
.019b46	84 12		sty $12				sty 	zTemp2							; update longest match.
.019b48	a5 15		lda $15				lda 	zTemp3+1 						; copy current token
.019b4a	85 13		sta $13				sta 	zTemp2+1 						; into matched token slot.
.019b4c	a0 00		ldy #$00			ldy 	#0 								; reset to start of matched token for forward
.019b4e					_TKWNext:
.019b4e	b7 1c		lda [$1c],y			lda 	[zLTemp1],y
.019b50	c8		iny				iny 									; next one.
.019b51	0a		asl a				asl 	a 								; if bit 7 clear loop back.
.019b52	90 fa		bcc $019b4e			bcc 	_TKWNext
.019b54	e6 15		inc $15				inc 	zTemp3+1 						; increment current token.
.019b56	98		tya				tya 									; has Y gone negative.
.019b57	10 03		bpl $019b5c			bpl 	_TKWNoYZero
.019b59	20 6d 9b	jsr $019b6d			jsr 	_TKWClearY 						; make it so (zTemp1),y now points to zTemp1
.019b5c					_TKWNoYZero:
.019b5c	b7 1c		lda [$1c],y			lda 	[zLTemp1],y
.019b5e	d0 c0		bne $019b20			bne 	_TKWScanLoop 					; if not, try the next one.
.019b60	a5 12		lda $12				lda 	zTemp2 							; length of longest match
.019b62	f0 05		beq $019b69			beq 	_TKWFail 						; if zero, none found.
.019b64	a8		tay				tay 									; return the token in zTemp2, length => y
.019b65	a5 13		lda $13				lda 	zTemp2+1 						; so the offset is right.
.019b67	38		sec				sec
.019b68	60		rts				rts
.019b69					_TKWFail:
.019b69	a0 00		ldy #$00			ldy 	#0 								; return with Y = 0 and carry clear.
.019b6b	18		clc				clc
.019b6c	60		rts				rts
.019b6d					_TKWClearY:
.019b6d	98		tya				tya
.019b6e	18		clc				clc
.019b6f	65 1c		adc $1c				adc 	zLTemp1
.019b71	85 1c		sta $1c				sta 	zLTemp1
.019b73	90 02		bcc $019b77			bcc 	_TKWCNoBump
.019b75	e6 1d		inc $1d				inc 	zLTemp1+1
.019b77					_TKWCNoBump:
.019b77	a0 00		ldy #$00			ldy 	#0
.019b79	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/tokenise/tokenise.asm

.019b7a					TokeniseString:
.019b7a	85 20		sta $20				sta 	zGenPtr 					; save source
.019b7c	86 21		stx $21				stx 	zGenPtr+1
.019b7e	a0 00		ldy #$00			ldy 	#0 							; source
.019b80	a2 03		ldx #$03			ldx 	#3 							; target
.019b82	8c 00 04	sty $0400			sty 	TokeniseBuffer+0 			; write three NULLs. So it looks like
.019b85	8c 01 04	sty $0401			sty 	TokeniseBuffer+1 			; there's a line number zero.
.019b88	8c 02 04	sty $0402			sty 	TokeniseBuffer+2
.019b8b					_TSMainLoop:
.019b8b					_TSSkipSpaces:
.019b8b	b1 20		lda ($20),y			lda 	(zGenPtr),y					; skip over spaces.
.019b8d	c8		iny				iny
.019b8e	c9 20		cmp #$20			cmp 	#" "
.019b90	f0 f9		beq $019b8b			beq 	_TSSkipSpaces
.019b92	c9 30		cmp #$30			cmp 	#"0" 						; is it a constant
.019b94	90 0a		bcc $019ba0			bcc 	_TSNotConstant
.019b96	c9 3a		cmp #$3a			cmp 	#"9"+1
.019b98	b0 06		bcs $019ba0			bcs 	_TSNotConstant
.019b9a	88		dey				dey 								; point back to start
.019b9b	20 bf 9c	jsr $019cbf			jsr 	TokeniseConstant 			; tokenise a constant
.019b9e	80 eb		bra $019b8b			bra 	_TSMainLoop			 		; and loop back.
.019ba0					_TSNotConstant:
.019ba0	c9 20		cmp #$20			cmp 	#32 						; end of line.
.019ba2	90 52		bcc $019bf6			bcc 	_TSExit
.019ba4	c9 22		cmp #$22			cmp		#'"'						; quoted string
.019ba6	f0 55		beq $019bfd			beq 	_TSQuotedString
.019ba8	c9 2e		cmp #$2e			cmp 	#'.' 						; decimal.
.019baa	f0 56		beq $019c02			beq 	_TSDecimal
.019bac	20 24 9c	jsr $019c24			jsr 	TOKCapitalise 				; make U/C
.019baf	c9 52		cmp #$52			cmp 	#"R" 						; is it R, if so check for REM ?
.019bb1	d0 05		bne $019bb8			bne 	_TSNoRemCheck
.019bb3	20 07 9c	jsr $019c07			jsr 	TOKCheckREM
.019bb6	b0 d3		bcs $019b8b			bcs 	_TSMainLoop 				; and if REM okay, go back.
.019bb8					_TSNoRemCheck:
.019bb8	88		dey				dey 								; point to character
.019bb9	20 ed 9a	jsr $019aed			jsr 	TokeniseKeyword 			; try to tokenise a keyword.
.019bbc	b0 cd		bcs $019b8b			bcs 	_TSMainLoop					; true if tokenised okay.
.019bbe	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; get character
.019bc0	20 24 9c	jsr $019c24			jsr 	TOKCapitalise
.019bc3	c9 41		cmp #$41			cmp 	#"A"						; is it A-Z, if so it's an alphanumeric sequence.
.019bc5	90 04		bcc $019bcb			bcc 	_TSSingle
.019bc7	c9 5b		cmp #$5b			cmp 	#"Z"+1
.019bc9	90 0d		bcc $019bd8			bcc 	_TSAlphaNumeric
.019bcb					_TSSingle:
.019bcb	c8		iny				iny 								; skip over output
.019bcc	29 3f		and #$3f			and 	#63 						; make 6 bit ASCII
.019bce	09 80		ora #$80			ora 	#128
.019bd0	f0 b9		beq $019b8b			beq 	_TSMainLoop 				; ignore @, which doesn't tokenise.
.019bd2	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.019bd5	e8		inx				inx
.019bd6	80 b3		bra $019b8b			bra 	_TSMainLoop
.019bd8					_TSAlphaNumeric:
.019bd8	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; get
.019bda	20 24 9c	jsr $019c24			jsr 	TOKCapitalise
.019bdd	c9 30		cmp #$30			cmp 	#"0" 	 					; check 0-9
.019bdf	90 aa		bcc $019b8b			bcc 	_TSMainLoop
.019be1	c9 3a		cmp #$3a			cmp 	#"9"+1
.019be3	90 0a		bcc $019bef			bcc 	_TSANOkay
.019be5	c9 41		cmp #$41			cmp 	#"A"						; check A-Z
.019be7	90 a2		bcc $019b8b			bcc 	_TSMainLoop
.019be9	c9 5b		cmp #$5b			cmp 	#"Z"+1
.019beb	b0 9e		bcs $019b8b			bcs 	_TSMainLoop
.019bed	29 3f		and #$3f			and 	#63 						; write it out
.019bef					_TSANOkay:
.019bef	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.019bf2	e8		inx				inx
.019bf3	c8		iny				iny
.019bf4	80 e2		bra $019bd8			bra 	_TSAlphaNumeric
.019bf6	a9 00		lda #$00	_TSExit:lda 	#0 							; mark end of line.
.019bf8	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.019bfb	8a		txa				txa 								; return length of tokenised line in bytes.
.019bfc	60		rts				rts
.019bfd					_TSQuotedString:
.019bfd	20 5d 9c	jsr $019c5d			jsr 	TokeniseQuotedString
.019c00	80 89		bra $019b8b			bra 	_TSMainLoop
.019c02					_TSDecimal:
.019c02	20 83 9c	jsr $019c83			jsr 	TokeniseDecimalString
.019c05	80 84		bra $019b8b			bra 	_TSMainLoop
.019c07					TOKCheckREM:
.019c07	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; check E
.019c09	20 24 9c	jsr $019c24			jsr 	TOKCapitalise
.019c0c	c9 45		cmp #$45			cmp 	#"E"
.019c0e	d0 12		bne $019c22			bne 	_TCRFail
.019c10	c8		iny				iny
.019c11	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; check M
.019c13	88		dey				dey
.019c14	20 24 9c	jsr $019c24			jsr 	TOKCapitalise
.019c17	c9 4d		cmp #$4d			cmp 	#"M"
.019c19	d0 07		bne $019c22			bne 	_TCRFail
.019c1b	c8		iny				iny									; point to first character
.019c1c	c8		iny				iny
.019c1d	20 2f 9c	jsr $019c2f			jsr 	TokeniseREMString 			; tokenise REM
.019c20	38		sec				sec
.019c21	60		rts				rts
.019c22					_TCRFail:
.019c22	18		clc				clc
.019c23	60		rts				rts
.019c24					TOKCapitalise:
.019c24	c9 61		cmp #$61			cmp 	#"a"
.019c26	90 06		bcc $019c2e			bcc 	_TOKCExit
.019c28	c9 7b		cmp #$7b			cmp 	#"z"+1
.019c2a	b0 02		bcs $019c2e			bcs 	_TOKCExit
.019c2c	49 20		eor #$20			eor 	#$20
.019c2e					_TOKCExit:
.019c2e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/tokenise/tokseq.asm

.019c2f					TokeniseREMString:
.019c2f	86 10		stx $10				stx 	zTemp1 						; save position
.019c31	a9 ff		lda #$ff			lda 	#$FF 						; write marker
.019c33	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.019c36	9d 01 04	sta $0401,x			sta 	TokeniseBuffer+1,x 			; stops space removal.
.019c39	e8		inx				inx 								; bump, and one space for the count.
.019c3a	e8		inx				inx
.019c3b					_TSRSkip:
.019c3b	b1 20		lda ($20),y			lda 	(zGenPtr),y
.019c3d	c8		iny				iny
.019c3e	c9 20		cmp #$20			cmp 	#" "
.019c40	f0 f9		beq $019c3b			beq 	_TSRSkip
.019c42	c9 3a		cmp #$3a			cmp 	#":"						; first char is a colon
.019c44	f0 31		beq $019c77			beq 	SequenceExit 				; ... that's it.
.019c46					_TSRCopy:
.019c46	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x 			; write out
.019c49	e8		inx				inx
.019c4a	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; get next
.019c4c	f0 05		beq $019c53			beq 	_TSRExit 					; zero is exit
.019c4e	c8		iny				iny 								; bump pointer
.019c4f	c9 3a		cmp #$3a			cmp 	#":"						; loop back if not colon.
.019c51	d0 f3		bne $019c46			bne 	_TSRCopy
.019c53					_TSRExit:
.019c53	bd ff 03	lda $03ff,x			lda 	TokeniseBuffer-1,x 			; previous char space ?
.019c56	c9 20		cmp #$20			cmp 	#" "
.019c58	d0 1d		bne $019c77			bne 	SequenceExit
.019c5a	ca		dex				dex 								; go back - will bump into $FF eventually.
.019c5b	80 f6		bra $019c53			bra 	_TSRExit
.019c5d					TokeniseQuotedString:
.019c5d	86 10		stx $10				stx 	zTemp1 						; save position
.019c5f	a9 fe		lda #$fe			lda 	#$FE 						; write marker
.019c61	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.019c64	e8		inx				inx 								; bump, and one space for the count.
.019c65	e8		inx				inx
.019c66					_TSQCopy:
.019c66	b1 20		lda ($20),y			lda 	(zGenPtr),y
.019c68	c9 20		cmp #$20			cmp 	#" "
.019c6a	90 0b		bcc $019c77			bcc 	SequenceExit 				; if < ' ' then exit, didn't find end.
.019c6c	c8		iny				iny
.019c6d	c9 22		cmp #$22			cmp 	#'"'						; if = quote, consume it and exit.
.019c6f	f0 06		beq $019c77			beq 	SequenceExit
.019c71	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x 			; write out and loop
.019c74	e8		inx				inx
.019c75	80 ef		bra $019c66			bra 	_TSQCopy
.019c77					SequenceExit:
.019c77	8a		txa				txa 								; current position
.019c78	38		sec				sec 								; subtract start.
.019c79	e5 10		sbc $10				sbc 	zTemp1
.019c7b	da		phx				phx 								; copy that in
.019c7c	a6 10		ldx $10				ldx 	zTemp1
.019c7e	9d 01 04	sta $0401,x			sta 	TokeniseBuffer+1,x
.019c81	fa		plx				plx
.019c82	60		rts				rts
.019c83					TokeniseDecimalString:
.019c83	86 10		stx $10				stx 	zTemp1 						; save position
.019c85	a9 fd		lda #$fd			lda 	#$FD 						; write marker
.019c87	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.019c8a	e8		inx				inx 								; bump, and one space for the count.
.019c8b	e8		inx				inx
.019c8c	20 ad 9c	jsr $019cad			jsr 	_TDSCopyNumber 				; copy a number.
.019c8f	b1 20		lda ($20),y			lda 	(zGenPtr),y	 				; next letter.
.019c91	20 24 9c	jsr $019c24			jsr 	TOKCapitalise
.019c94	c9 45		cmp #$45			cmp 	#"E" 						; if not an exponent.
.019c96	d0 df		bne $019c77			bne 	SequenceExit 				; exit now.
.019c98	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x 			; write E out
.019c9b	e8		inx				inx
.019c9c	c8		iny				iny
.019c9d	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; followed by a minus ?
.019c9f	c9 2d		cmp #$2d			cmp 	#"-"
.019ca1	d0 05		bne $019ca8			bne 	_TDSNoMinusExponent
.019ca3	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x 			; write - out
.019ca6	e8		inx				inx
.019ca7	c8		iny				iny
.019ca8					_TDSNoMinusExponent:
.019ca8	20 ad 9c	jsr $019cad			jsr 	_TDSCopyNumber 				; do the exponent
.019cab	80 ca		bra $019c77			bra 	SequenceExit
.019cad					_TDSCopyNumber:
.019cad	b1 20		lda ($20),y			lda 	(zGenPtr),y
.019caf	c9 30		cmp #$30			cmp 	#"0"
.019cb1	90 0b		bcc $019cbe			bcc 	_TDSCNExit
.019cb3	c9 3a		cmp #$3a			cmp 	#"9"+1
.019cb5	b0 07		bcs $019cbe			bcs 	_TDSCNExit
.019cb7	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.019cba	e8		inx				inx
.019cbb	c8		iny				iny
.019cbc	80 ef		bra $019cad			bra 	_TDSCopyNumber
.019cbe					_TDSCNExit:
.019cbe	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/tokenise/tokconst.asm

.019cbf					TokeniseConstant:
.019cbf	da		phx				phx 								; save X
.019cc0	a2 00		ldx #$00			ldx 	#0
.019cc2	20 9d a2	jsr $01a29d			jsr 	IntFromStringY 				; get the integer out.
.019cc5	b0 37		bcs $019cfe			bcs 	_TCQ 						; should not happen.
.019cc7	fa		plx				plx 								; restore X.
.019cc8	a9 00		lda #$00			lda 	#0 							; zero count of restores.
.019cca	85 10		sta $10				sta 	zTemp1
.019ccc					_TCRotate:
.019ccc	a5 80		lda $80				lda 	XS_Mantissa+0 				; check bits 6/7 of 0
.019cce	29 c0		and #$c0			and 	#$C0
.019cd0	05 81		ora $81				ora 	XS_Mantissa+1	 			; and 1/2/3 all zero
.019cd2	05 82		ora $82				ora 	XS_Mantissa+2
.019cd4	05 83		ora $83				ora 	XS_Mantissa+3
.019cd6	f0 16		beq $019cee			beq 	_TCDone						; if so, at the bottom.
.019cd8	a5 80		lda $80				lda 	XS_Mantissa+0 				; push lower 6 bits of 0
.019cda	29 3f		and #$3f			and 	#$3F
.019cdc	48		pha				pha
.019cdd	e6 10		inc $10				inc 	zTemp1 						; increment the pop count.
.019cdf	a9 06		lda #$06			lda 	#6 							; shift right 6 times
.019ce1					_TCShiftRight:
.019ce1	46 83		lsr $83				lsr 	XS_Mantissa+3
.019ce3	66 82		ror $82				ror 	XS_Mantissa+2
.019ce5	66 81		ror $81				ror 	XS_Mantissa+1
.019ce7	66 80		ror $80				ror 	XS_Mantissa+0
.019ce9	3a		dec a				dec 	a
.019cea	d0 f5		bne $019ce1			bne 	_TCShiftRight
.019cec	80 de		bra $019ccc			bra 	_TCRotate 					; and go round again.
.019cee	a5 80		lda $80		_TCDone:lda 	XS_Mantissa+0
.019cf0					_TCWrite:
.019cf0	09 40		ora #$40			ora 	#$40						; write it out as inttoken
.019cf2	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.019cf5	e8		inx				inx
.019cf6	c6 10		dec $10				dec 	zTemp1 						; done all of them
.019cf8	30 03		bmi $019cfd			bmi 	_TCExit 					; no , more to pop
.019cfa	68		pla				pla
.019cfb	80 f3		bra $019cf0			bra 	_TCWrite 					; until everything's off.
.019cfd					_TCExit:
.019cfd	60		rts				rts
.019cfe					_TCQ:
.019cfe	20 86 85	jsr $018586			jsr ERR_Handler
>019d01	54 4b 00				.text "TK",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/variables.asm

.019d04					VariableFind:
.019d04	20 6f 9d	jsr $019d6f			jsr 	VariableExtract 		; find out all about it ....
.019d07	20 08 a0	jsr $01a008			jsr 	VariableLocate 			; does it already exist ?
.019d0a	b0 03		bcs $019d0f			bcs 	_VFExists 				; if so, use that.
.019d0c	20 fb 9d	jsr $019dfb			jsr 	VariableCreate 			; otherwise create it.
.019d0f					_VFExists:
.019d0f	a5 26		lda $26				lda 	zVarType 				; is it still an array ?
.019d11	29 01		and #$01			and 	#1
.019d13	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.019d15	d0 28		bne $019d3f			bne 	_VFSingleElement
.019d17					_VFNextIndex:
.019d17	a5 24		lda $24				lda 	zVarDataPtr 			; push the data ptr and type on the stack.
.019d19	48		pha				pha
.019d1a	a5 25		lda $25				lda 	zVarDataPtr+1
.019d1c	48		pha				pha
.019d1d	a5 26		lda $26				lda 	zVarType
.019d1f	48		pha				pha
.019d20	20 f0 93	jsr $0193f0			jsr 	EvaluateInteger 		; calculate the index.
.019d23	68		pla				pla 							; restore and index.
.019d24	85 26		sta $26				sta 	zVarType
.019d26	68		pla				pla
.019d27	85 25		sta $25				sta 	zVarDataPtr+1
.019d29	68		pla				pla
.019d2a	85 24		sta $24				sta 	zVarDataPtr
.019d2c	20 86 9e	jsr $019e86			jsr 	ArrayIndexFollow 		; do the index.
.019d2f	a5 26		lda $26				lda 	zVarType 				; is it still an array ??
.019d31	29 01		and #$01			and 	#1
.019d33	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.019d35	d0 05		bne $019d3c			bne 	_VFArrayDone 			; if so then exit.
.019d37	20 47 9a	jsr $019a47			jsr 	CheckNextComma 			; comma should follow
.019d3a	80 db		bra $019d17			bra 	_VFNextIndex
.019d3c					_VFArrayDone:
.019d3c	20 3f 9a	jsr $019a3f			jsr 	CheckNextRParen 		; check closing right bracket.
.019d3f					_VFSingleElement:
.019d3f	60		rts				rts
.019d40					VariableClear:
.019d40	48		pha				pha 							; save registers
.019d41	da		phx				phx
.019d42	a2 00		ldx #$00			ldx 	#0 						; clear out the hash table.
.019d44	8a		txa				txa
.019d45	9d 35 03	sta $0335,x	_VCLoop:sta 	HashTableBase,x
.019d48	e8		inx				inx
.019d49	e0 60		cpx #$60			cpx 	#HashTableEnd-HashTableBase
.019d4b	d0 f8		bne $019d45			bne 	_VCLoop
.019d4d	a9 00		lda #$00			lda 	#VariableMemory & $FF
.019d4f	8d 02 03	sta $0302			sta 	VarMemPtr
.019d52	a9 20		lda #$20			lda 	#VariableMemory >> 8
.019d54	8d 03 03	sta $0303			sta 	VarMemPtr+1
.019d57	fa		plx				plx 							; restore registers
.019d58	68		pla				pla
.019d59	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/extract.asm

.019d5a					VariableNameError:
.019d5a	20 86 85	jsr $018586			jsr ERR_Handler
>019d5d	42 61 64 20 56 61 72 69			.text "Bad Variable Name",0
>019d65	61 62 6c 65 20 4e 61 6d 65 00
.019d6f					VariableExtract:
.019d6f	da		phx				phx 							; save X.
.019d70	a9 ba		lda #$ba			lda 	#token_hashlParen  		; set the type to #( e.g. real array.
.019d72	8d 95 03	sta $0395			sta 	Var_Type
.019d75	8d 96 03	sta $0396			sta 	Var_Hash 				; we initialise the hash with this. It doesn't matter
.019d78	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019d7a	c9 00		cmp #$00			cmp 	#0 						; first one must be A-Z
.019d7c	f0 dc		beq $019d5a			beq 	VariableNameError
.019d7e	c9 1b		cmp #$1b			cmp 	#26+1
.019d80	b0 d8		bcs $019d5a			bcs 	VariableNameError
.019d82	a2 ff		ldx #$ff			ldx 	#255 					; now copy it into the variable buffer.
.019d84					_VECopyBuffer:
.019d84	e8		inx				inx
.019d85	e0 1f		cpx #$1f			cpx 	#31 					; too long
.019d87	f0 d1		beq $019d5a			beq 	VariableNameError
.019d89	9d 15 03	sta $0315,x			sta 	Var_Buffer,x 			; save character
.019d8c	18		clc				clc  							; update the hash value for it.
.019d8d	6d 96 03	adc $0396			adc 	Var_Hash
.019d90	8d 96 03	sta $0396			sta 	Var_Hash
.019d93	c8		iny				iny
.019d94	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019d96	c9 00		cmp #$00			cmp 	#0 						; zero or token, end of variable
.019d98	f0 0e		beq $019da8			beq 	_VECopyEnd
.019d9a	30 0c		bmi $019da8			bmi 	_VECopyEnd
.019d9c	c9 1b		cmp #$1b			cmp 	#26+1 					; A-Z continue copying
.019d9e	90 e4		bcc $019d84			bcc 	_VECopyBuffer
.019da0	c9 30		cmp #$30			cmp 	#"0" 					; 0-9 copy as well.
.019da2	90 04		bcc $019da8			bcc 	_VECopyEnd
.019da4	c9 3a		cmp #$3a			cmp 	#"9"+1
.019da6	90 dc		bcc $019d84			bcc 	_VECopyBuffer
.019da8					_VECopyEnd:
.019da8	c8		iny				iny
.019da9	c9 b7		cmp #$b7			cmp 	#token_Dollar 			; first type token.
.019dab	90 04		bcc $019db1			bcc 	_VEDefaultRequired
.019dad	c9 bd		cmp #$bd			cmp 	#token_PercentLParen+1	; last type token.
.019daf	90 0b		bcc $019dbc			bcc 	_VEHaveType
.019db1					_VEDefaultRequired:
.019db1	c9 bd		cmp #$bd			cmp 	#token_LParen 			; if it ends in ( then use the real array
.019db3	f0 04		beq $019db9			beq 	_VESetType 				; default set above.
.019db5	ce 95 03	dec $0395			dec 	Var_Type 				; this changes that default to the variable default
.019db8	88		dey				dey
.019db9					_VESetType:
.019db9	ad 95 03	lda $0395			lda 	Var_Type 				; get type ....
.019dbc					_VEHaveType:
.019dbc	8d 95 03	sta $0395			sta 	Var_Type 				; save as type.
.019dbf	bd 15 03	lda $0315,x			lda 	Var_Buffer,x 			; set bit 7 of name, marks the end.
.019dc2	09 80		ora #$80			ora 	#$80
.019dc4	9d 15 03	sta $0315,x			sta 	Var_Buffer,x
.019dc7	e8		inx				inx 							; offset 3 => length 4.
.019dc8	8e 97 03	stx $0397			stx 	Var_Length 				; save length of variable name.
.019dcb	ad 95 03	lda $0395			lda 	Var_Type 				; get offset of var type from first type token
.019dce	38		sec				sec
.019dcf	e9 b7		sbc #$b7			sbc 	#token_Dollar
.019dd1	0a		asl a				asl 	a 						; multiply by 16. This requires HashTableSize
.019dd2	0a		asl a				asl 	a 						; in data.asm to be 8 (8 sets of links,2 bytes each)
.019dd3	0a		asl a				asl 	a
.019dd4	0a		asl a				asl 	a
.019dd5	8d 98 03	sta $0398			sta 	Var_HashAddress
.019dd8	ad 96 03	lda $0396			lda 	Var_Hash 				; get the hash
.019ddb	29 07		and #$07			and 	#(HashTableSize-1) 		; force into range 0-tableSize-1
.019ddd	0a		asl a				asl 	a 						; double it (2 bytes per entry) & clears carry
.019dde	6d 98 03	adc $0398			adc 	Var_HashAddress 		; add table offset.
.019de1	69 35		adc #$35			adc 	#HashTableBase & $FF 	; now the low byte of the actual table address
.019de3	8d 98 03	sta $0398			sta 	Var_HashAddress
.019de6	a2 05		ldx #$05			ldx 	#5 						; hash is 5 bytes (real)
.019de8	ad 95 03	lda $0395			lda 	Var_Type
.019deb	c9 b9		cmp #$b9			cmp 	#token_Hash
.019ded	f0 07		beq $019df6			beq 	_VEHaveSize
.019def	ca		dex				dex
.019df0	c9 bb		cmp #$bb			cmp 	#token_Percent 			; percent is 4 bytes (integer)
.019df2	f0 02		beq $019df6			beq 	_VEHaveSize
.019df4	a2 02		ldx #$02			ldx 	#2 						; everything else is two.
.019df6					_VEHaveSize:
.019df6	8e 99 03	stx $0399			stx 	Var_DataSize
.019df9	fa		plx				plx
.019dfa	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varcreate.asm

.019dfb					VariableCreate:
.019dfb	da		phx				phx
.019dfc	5a		phy				phy
.019dfd	ad 02 03	lda $0302			lda 	VarMemPtr 					; get address of next free into zTemp1
.019e00	85 10		sta $10				sta 	zTemp1
.019e02	ad 03 03	lda $0303			lda 	VarMemPtr+1
.019e05	85 11		sta $11				sta 	zTemp1+1
.019e07	ad 99 03	lda $0399			lda 	Var_DataSize 				; bytes for the data bit
.019e0a	18		clc				clc
.019e0b	6d 97 03	adc $0397			adc 	Var_Length 					; add the length of the name
.019e0e	69 03		adc #$03			adc 	#3 							; 3 for the link and the hash.
.019e10	6d 02 03	adc $0302			adc 	VarMemPtr 					; add to variable memory pointer
.019e13	8d 02 03	sta $0302			sta 	VarMemPtr
.019e16	90 03		bcc $019e1b			bcc 	_VCNoCarry
.019e18	ee 03 03	inc $0303			inc 	VarMemPtr+1
.019e1b					_VCNoCarry:
.019e1b	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.019e1e	85 12		sta $12				sta 	zTemp2
.019e20	a9 03		lda #$03			lda 	#HashTableBase >> 8
.019e22	85 13		sta $13				sta 	zTemp2+1
.019e24	a0 00		ldy #$00			ldy 	#0 							; put current hash link in position.
.019e26	b1 12		lda ($12),y			lda 	(zTemp2),y
.019e28	91 10		sta ($10),y			sta 	(zTemp1),y
.019e2a	c8		iny				iny
.019e2b	b1 12		lda ($12),y			lda 	(zTemp2),y
.019e2d	91 10		sta ($10),y			sta 	(zTemp1),y
.019e2f	c8		iny				iny
.019e30	ad 96 03	lda $0396			lda 	Var_Hash 					; write the hash out.
.019e33	91 10		sta ($10),y			sta 	(zTemp1),y
.019e35	c8		iny				iny
.019e36	a2 00		ldx #$00			ldx 	#0 							; copy the name out.
.019e38					_VCCopyName:
.019e38	bd 15 03	lda $0315,x			lda 	Var_Buffer,x
.019e3b	91 10		sta ($10),y			sta 	(zTemp1),y
.019e3d	e8		inx				inx
.019e3e	c8		iny				iny
.019e3f	ec 97 03	cpx $0397			cpx 	Var_Length
.019e42	d0 f4		bne $019e38			bne 	_VCCopyName
.019e44	5a		phy				phy 								; save the data offset.
.019e45	ae 99 03	ldx $0399			ldx 	Var_DataSize 				; and write the data out.
.019e48	a9 00		lda #$00			lda 	#0 							; which is all zeroes.
.019e4a					_VCClearData:
.019e4a	91 10		sta ($10),y			sta 	(zTemp1),y
.019e4c	c8		iny				iny
.019e4d	ca		dex				dex
.019e4e	d0 fa		bne $019e4a			bne 	_VCClearData
.019e50	68		pla				pla 								; offset to the data
.019e51	18		clc				clc
.019e52	65 10		adc $10				adc 	zTemp1 						; add to start and save as data pointer.
.019e54	85 24		sta $24				sta 	zVarDataPtr
.019e56	a5 11		lda $11				lda 	zTemp1+1
.019e58	69 00		adc #$00			adc 	#0
.019e5a	85 25		sta $25				sta 	zVarDataPtr+1
.019e5c	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.019e5f	85 26		sta $26				sta 	zVarType
.019e61	a5 10		lda $10				lda 	zTemp1 						; fix hash link to point to new record
.019e63	a0 00		ldy #$00			ldy 	#0
.019e65	91 12		sta ($12),y			sta 	(zTemp2),y
.019e67	c8		iny				iny
.019e68	a5 11		lda $11				lda 	zTemp1+1
.019e6a	91 12		sta ($12),y			sta 	(zTemp2),y
.019e6c	ad 95 03	lda $0395			lda 	Var_Type 					; array ? if so create the empty one.
.019e6f	29 01		and #$01			and 	#1
.019e71	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.019e73	d0 0e		bne $019e83			bne 	_VCNotArray
.019e75	a2 00		ldx #$00			ldx 	#0 							; call recursive array creator
.019e77	20 1d 9f	jsr $019f1d			jsr 	ArrayCreate
.019e7a	5a		phy				phy 								; save YA at zVarDataPtr
.019e7b	a0 00		ldy #$00			ldy 	#0
.019e7d	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.019e7f	c8		iny				iny
.019e80	68		pla				pla
.019e81	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.019e83					_VCNotArray:
.019e83	7a		ply				ply
.019e84	fa		plx				plx
.019e85	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arrayidx.asm

.019e86					ArrayIndexFollow:
.019e86	5a		phy				phy
.019e87	a0 00		ldy #$00			ldy 	#0 							; make zVarDataPtr point to the array.
.019e89	b1 24		lda ($24),y			lda 	(zVarDataPtr),y 			; e.g. it points to itself.
.019e8b	48		pha				pha
.019e8c	c8		iny				iny
.019e8d	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.019e8f	85 25		sta $25				sta 	zVarDataPtr+1
.019e91	68		pla				pla
.019e92	85 24		sta $24				sta 	zVarDataPtr
.019e94	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; MSB of 16 bit integer and bytes 2&3
.019e96	29 80		and #$80			and 	#$80 						; must be zero.
.019e98	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019e9a	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019e9c	d0 59		bne $019ef7			bne 	_AIFError
.019e9e	a0 00		ldy #$00			ldy 	#0 							; calculate size - current - 1
.019ea0	18		clc				clc
.019ea1	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.019ea3	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.019ea5	c8		iny				iny
.019ea6	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.019ea8	08		php				php 								; clear bit 7 retaining borrow.
.019ea9	29 7f		and #$7f			and 	#$7F
.019eab	28		plp				plp
.019eac	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.019eae	90 47		bcc $019ef7			bcc 	_AIFError 					; eror if size-current < 0
.019eb0	b5 80		lda $80,x			lda  	XS_Mantissa+0,x 			; copy and double the index
.019eb2	0a		asl a				asl 	a 							; (e.g. index * 2)
.019eb3	85 10		sta $10				sta 	zTemp1
.019eb5	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019eb7	2a		rol a				rol 	a
.019eb8	85 11		sta $11				sta 	zTemp1+1
.019eba	a0 01		ldy #$01			ldy 	#1 							; is this a data entry.
.019ebc	b1 24		lda ($24),y			lda 	(zVarDataPtr),y 			; if so, then type is unchanged, offset set
.019ebe	30 1d		bmi $019edd			bmi 	_AIFCalculate
.019ec0	c6 26		dec $26				dec 	zVarType 					; converts from an array to a type.
.019ec2	a5 26		lda $26				lda 	zVarType 					; check that type
.019ec4	c9 b7		cmp #$b7			cmp 	#token_Dollar 				; if string, use x 2
.019ec6	f0 15		beq $019edd			beq 	_AIFCalculate
.019ec8	06 10		asl $10				asl 	zTemp1			 			; double the index
.019eca	26 11		rol $11				rol 	zTemp1+1					; (e.g. index * 4)
.019ecc	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if integer, use x 4
.019ece	f0 0d		beq $019edd			beq 	_AIFCalculate
.019ed0	18		clc				clc 								; add the original mantissa in again
.019ed1	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; which makes it x5, for float.
.019ed3	65 10		adc $10				adc 	zTemp1
.019ed5	85 10		sta $10				sta 	zTemp1
.019ed7	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019ed9	65 11		adc $11				adc 	zTemp1+1
.019edb	85 11		sta $11				sta 	zTemp1+1
.019edd					_AIFCalculate:
.019edd	18		clc				clc 								; add index x 2,4 or 5 to base
.019ede	a5 24		lda $24				lda 	zVarDataPtr
.019ee0	65 10		adc $10				adc 	zTemp1
.019ee2	85 24		sta $24				sta 	zVarDataPtr
.019ee4	a5 25		lda $25				lda 	zVarDataPtr+1
.019ee6	65 11		adc $11				adc 	zTemp1+1
.019ee8	85 25		sta $25				sta 	zVarDataPtr+1
.019eea	18		clc				clc 								; add 2 more for the length prefix.
.019eeb	a5 24		lda $24				lda 	zVarDataPtr
.019eed	69 02		adc #$02			adc 	#2
.019eef	85 24		sta $24				sta 	zVarDataPtr
.019ef1	90 02		bcc $019ef5			bcc 	_AIFNoBump
.019ef3	e6 25		inc $25				inc 	zVarDataPtr+1
.019ef5					_AIFNoBump:
.019ef5	7a		ply				ply
.019ef6	60		rts				rts
.019ef7					_AIFError:
.019ef7	20 86 85	jsr $018586			jsr ERR_Handler
>019efa	42 61 64 20 61 72 72 61			.text "Bad array index",0
>019f02	79 20 69 6e 64 65 78 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arraydef.asm

.019f0a					ArrayResetDefault:
.019f0a	a9 0b		lda #$0b			lda 	#11 						; 0..10 one array
.019f0c	8d a9 03	sta $03a9			sta 	ArrayDef+0
.019f0f	a9 00		lda #$00			lda 	#0
.019f11	8d aa 03	sta $03aa			sta 	ArrayDef+1
.019f14	a9 ff		lda #$ff			lda 	#$FF
.019f16	8d ab 03	sta $03ab			sta 	ArrayDef+2 					; $FFFF implies no second element.
.019f19	8d ac 03	sta $03ac			sta 	ArrayDef+3					; (test bit 7 of 2nd byte)
.019f1c	60		rts				rts
.019f1d					ArrayCreate:
.019f1d	bd a9 03	lda $03a9,x			lda 	ArrayDef+0,x 				; put size x 2 in zTemp1
.019f20	0a		asl a				asl 	a
.019f21	85 10		sta $10				sta 	zTemp1
.019f23	bd aa 03	lda $03aa,x			lda 	ArrayDef+1,x
.019f26	2a		rol a				rol 	a
.019f27	85 11		sta $11				sta 	zTemp1+1
.019f29	bd ac 03	lda $03ac,x			lda 	ArrayDef+3,x 				; if this is the last element it's array of ptrs.
.019f2c	10 22		bpl $019f50			bpl 	_ACSized 					; if not multiply size x 2 (str) 4 (int) 5 (real)
.019f2e	ad 95 03	lda $0395			lda 	Var_Type 					; check the type
.019f31	c9 b8		cmp #$b8			cmp 	#token_DollarLParen 		; also if it is an array of strings $(
.019f33	f0 1b		beq $019f50			beq 	_ACSized
.019f35	06 10		asl $10				asl 	zTemp1 						; double again
.019f37	26 11		rol $11				rol 	zTemp1+1
.019f39	b0 6f		bcs $019faa			bcs 	ArrayIndexError 			; too large.
.019f3b	c9 bc		cmp #$bc			cmp 	#token_PercentLParen 		; if %( four bytes/entry is enough.
.019f3d	f0 11		beq $019f50			beq 	_ACSized
.019f3f	18		clc				clc 								; add original value x 5 for reals.
.019f40	a5 10		lda $10				lda 	zTemp1
.019f42	7d a9 03	adc $03a9,x			adc 	ArrayDef+0,x
.019f45	85 10		sta $10				sta 	zTemp1
.019f47	a5 11		lda $11				lda 	zTemp1+1
.019f49	7d aa 03	adc $03aa,x			adc 	ArrayDef+1,x
.019f4c	85 11		sta $11				sta 	zTemp1+1
.019f4e	b0 5a		bcs $019faa			bcs 	ArrayIndexError
.019f50					_ACSized:
.019f50	18		clc				clc
.019f51	a5 10		lda $10				lda 	zTemp1
.019f53	69 02		adc #$02			adc 	#2
.019f55	85 10		sta $10				sta 	zTemp1
.019f57	90 04		bcc $019f5d			bcc 	_ACNoBump
.019f59	e6 10		inc $10				inc 	zTemp1
.019f5b	f0 4d		beq $019faa			beq 	ArrayIndexError
.019f5d					_ACNoBump:
.019f5d	18		clc				clc
.019f5e	ad 02 03	lda $0302			lda 	VarMemPtr 					; add this allocated count to VarMemPtr
.019f61	85 12		sta $12				sta 	zTemp2						; save start in zTemp2/zTemp3
.019f63	85 14		sta $14				sta 	zTemp3
.019f65	65 10		adc $10				adc 	zTemp1
.019f67	8d 02 03	sta $0302			sta 	VarMemPtr
.019f6a	ad 03 03	lda $0303			lda 	VarMemPtr+1
.019f6d	85 13		sta $13				sta 	zTemp2+1
.019f6f	85 15		sta $15				sta 	zTemp3+1
.019f71	65 11		adc $11				adc 	zTemp1+1
.019f73	8d 03 03	sta $0303			sta 	VarMemPtr+1
.019f76	85 11		sta $11				sta 	zTemp1+1
.019f78	b0 30		bcs $019faa			bcs 	ArrayIndexError
.019f7a	a0 00		ldy #$00			ldy 	#0							; write $00 out.
.019f7c					_ACClear:
.019f7c	98		tya				tya
.019f7d	91 12		sta ($12),y			sta 	(zTemp2),y
.019f7f	e6 12		inc $12				inc 	zTemp2
.019f81	d0 02		bne $019f85			bne 	_ACCBump
.019f83	e6 13		inc $13				inc 	zTemp2+1
.019f85					_ACCBump:
.019f85	a5 12		lda $12				lda 	zTemp2
.019f87	cd 02 03	cmp $0302			cmp 	VarMemPtr
.019f8a	d0 f0		bne $019f7c			bne 	_ACClear
.019f8c	a5 13		lda $13				lda 	zTemp2+1
.019f8e	cd 03 03	cmp $0303			cmp 	VarMemPtr+1
.019f91	d0 e9		bne $019f7c			bne 	_ACClear
.019f93	a0 00		ldy #$00			ldy 	#0
.019f95	bd a9 03	lda $03a9,x			lda 	ArrayDef+0,x 				; copy the size into the start
.019f98	91 14		sta ($14),y			sta 	(zTemp3),y
.019f9a	c8		iny				iny
.019f9b	bd aa 03	lda $03aa,x			lda 	ArrayDef+1,x
.019f9e	91 14		sta ($14),y			sta 	(zTemp3),y
.019fa0	bd ac 03	lda $03ac,x			lda 	ArrayDef+3,x 				; have we reached the end
.019fa3	10 18		bpl $019fbd			bpl 	ACCFillRecursive
.019fa5	a4 15		ldy $15				ldy 	zTemp3+1 					; return address
.019fa7	a5 14		lda $14				lda 	zTemp3
.019fa9	60		rts				rts
.019faa					ArrayIndexError:
.019faa	20 86 85	jsr $018586			jsr ERR_Handler
>019fad	42 61 64 20 61 72 72 61			.text "Bad array index",0
>019fb5	79 20 69 6e 64 65 78 00
.019fbd					ACCFillRecursive:
.019fbd	a9 ff		lda #$ff			lda 	#$FF 						; we mark the end, this is free space.
.019fbf	a0 00		ldy #$00			ldy 	#0 							; this is overwritten by size of next allocated
.019fc1	91 12		sta ($12),y			sta 	(zTemp2),y 					; array, but we might change that.
.019fc3	c8		iny				iny
.019fc4	b1 14		lda ($14),y			lda 	(zTemp3),y 					; set bit 15 of the max index indicating
.019fc6	09 80		ora #$80			ora 	#$80 						; an array of pointers
.019fc8	91 14		sta ($14),y			sta 	(zTemp3),y
.019fca	a5 14		lda $14				lda 	zTemp3 						; push the start on the stack
.019fcc	48		pha				pha
.019fcd	a5 15		lda $15				lda 	zTemp3+1
.019fcf	48		pha				pha
.019fd0					_ACCFillLoop:
.019fd0	18		clc				clc
.019fd1	a5 14		lda $14				lda 	zTemp3 						; and work forwards.
.019fd3	69 02		adc #$02			adc 	#2
.019fd5	85 14		sta $14				sta 	zTemp3
.019fd7	90 02		bcc $019fdb			bcc 	_ACCSkip2
.019fd9	e6 15		inc $15				inc 	zTemp3+1
.019fdb					_ACCSkip2:
.019fdb	a0 00		ldy #$00			ldy 	#0 							; reached the end ?
.019fdd	b1 14		lda ($14),y			lda 	(zTemp3),y					; (looking for FF marker, everything else 00)
.019fdf	c8		iny				iny
.019fe0	11 14		ora ($14),y			ora 	(zTemp3),y
.019fe2	d0 21		bne $01a005			bne 	_ACCExit
.019fe4	a5 14		lda $14				lda 	zTemp3 						; push zTemp3
.019fe6	48		pha				pha
.019fe7	a5 15		lda $15				lda 	zTemp3+1
.019fe9	48		pha				pha
.019fea	e8		inx				inx
.019feb	e8		inx				inx
.019fec	20 1d 9f	jsr $019f1d			jsr 	ArrayCreate 				; create array recursively.
.019fef	ca		dex				dex
.019ff0	ca		dex				dex
.019ff1	85 12		sta $12				sta 	zTemp2 						; save A
.019ff3	68		pla				pla
.019ff4	85 15		sta $15				sta 	zTemp3+1 					; restore zTemp3
.019ff6	68		pla				pla
.019ff7	85 14		sta $14				sta 	zTemp3
.019ff9	98		tya				tya 								; write high bye from Y
.019ffa	a0 01		ldy #$01			ldy 	#1
.019ffc	91 14		sta ($14),y			sta 	(zTemp3),y
.019ffe	88		dey				dey 								; write low byte out.
.019fff	a5 12		lda $12				lda 	zTemp2
.01a001	91 14		sta ($14),y			sta 	(zTemp3),y
.01a003	80 cb		bra $019fd0			bra 	_ACCFillLoop 				; and try again.
.01a005					_ACCExit:
.01a005	7a		ply				ply 								; restore the original address
.01a006	68		pla				pla
.01a007	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varfind.asm

.01a008					VariableLocate:
.01a008	da		phx				phx
.01a009	5a		phy				phy
.01a00a	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.01a00d	85 12		sta $12				sta 	zTemp2 						; points to first address.
.01a00f	a9 03		lda #$03			lda 	#HashTableBase >> 8
.01a011	85 13		sta $13				sta 	zTemp2+1
.01a013	a0 00		ldy #$00	_VLNext:ldy 	#0 							; get next link into AX
.01a015	b1 12		lda ($12),y			lda 	(zTemp2),y
.01a017	aa		tax				tax
.01a018	c8		iny				iny
.01a019	b1 12		lda ($12),y			lda 	(zTemp2),y
.01a01b	85 13		sta $13				sta 	zTemp2+1 					; save in zTemp
.01a01d	86 12		stx $12				stx 	zTemp2
.01a01f	05 12		ora $12				ora 	zTemp2 						; got zero
.01a021	18		clc				clc
.01a022	f0 25		beq $01a049			beq 	_VLExit 					; if so, then fail as end of chain.
.01a024	c8		iny				iny 								; point to hash (offset + 2)
.01a025	b1 12		lda ($12),y			lda 	(zTemp2),y
.01a027	cd 96 03	cmp $0396			cmp 	Var_Hash
.01a02a	d0 e7		bne $01a013			bne 	_VLNext 					; try next if different.
.01a02c					_VLCompare:
.01a02c	c8		iny				iny 								; next character
.01a02d	b1 12		lda ($12),y			lda 	(zTemp2),y 					; compare variable field against buffer.
.01a02f	d9 12 03	cmp $0312,y			cmp 	Var_Buffer-3,y 				; the -3 is because name starts at 3.
.01a032	d0 df		bne $01a013			bne 	_VLNext 					; fail if different, try next.
.01a034	0a		asl a				asl 	a 							; until end character (bit 7 set) matched
.01a035	90 f5		bcc $01a02c			bcc 	_VLCompare
.01a037	98		tya				tya
.01a038	38		sec				sec 								; add 1 as Y points to last character
.01a039	65 12		adc $12				adc 	zTemp2 						; add to the current address
.01a03b	85 24		sta $24				sta 	zVarDataPtr
.01a03d	a5 13		lda $13				lda 	zTemp2+1
.01a03f	69 00		adc #$00			adc 	#0
.01a041	85 25		sta $25				sta 	zVarDataPtr+1
.01a043	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.01a046	85 26		sta $26				sta 	zVarType
.01a048	38		sec				sec 								; return CS
.01a049	7a		ply		_VLExit:ply
.01a04a	fa		plx				plx
.01a04b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/vargetset.asm

.01a04c					VariableGet:
.01a04c	5a		phy				phy
.01a04d	a0 00		ldy #$00			ldy 	#0 							; copy first two bytes
.01a04f	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.01a051	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a053	c8		iny				iny
.01a054	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.01a056	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a058	c8		iny				iny
.01a059	a5 26		lda $26				lda 	zVarType 					; if it is a string, set up for that.
.01a05b	c9 b7		cmp #$b7			cmp 	#token_Dollar
.01a05d	f0 2c		beq $01a08b			beq 	_VGString
.01a05f	b1 24		lda ($24),y			lda 	(zVarDataPtr),y 			; copy the next two bytes.
.01a061	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a063	c8		iny				iny
.01a064	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.01a066	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a068	c8		iny				iny
.01a069	a9 01		lda #$01			lda 	#1 							; set type to 1.
.01a06b	95 85		sta $85,x			sta 	XS_Type,x
.01a06d	a5 26		lda $26				lda 	zVarType
.01a06f	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if it is a %, then exit with default integer.
.01a071	f0 28		beq $01a09b			beq 	_VGExit
.01a073	a9 40		lda #$40			lda 	#$40 						; set type byte to zero
.01a075	95 85		sta $85,x			sta 	XS_Type,x 					; which is the code for zero/float.
.01a077	b1 24		lda ($24),y			lda 	(zVarDataPtr),y 			; the last value to copy is the exponent.
.01a079	95 84		sta $84,x			sta 	XS_Exponent,x
.01a07b	f0 1e		beq $01a09b			beq 	_VGExit 					; if exponent is zero ... it's zero.
.01a07d	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; the sign bit is the top mantissa bit.
.01a07f	48		pha				pha
.01a080	29 80		and #$80			and 	#$80
.01a082	95 85		sta $85,x			sta 	XS_Type,x 					; this is the type byte.
.01a084	68		pla				pla
.01a085	09 80		ora #$80			ora 	#$80 						; set the MSB as you would expect.
.01a087	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; so it's a normalised float.
.01a089	80 10		bra $01a09b			bra 	_VGExit
.01a08b					_VGString:
.01a08b	a9 02		lda #$02			lda 	#2 							; set type to 2, a string
.01a08d	95 85		sta $85,x			sta 	XS_Type,x
.01a08f	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; is the value there $0000
.01a091	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.01a093	d0 06		bne $01a09b			bne 	_VGExit 					; if not, exit.
.01a095	85 27		sta $27				sta 	zNullString 				; make zNullString a 00 string.
.01a097	a9 27		lda #$27			lda 	#zNullString
.01a099	95 80		sta $80,x			sta 	XS_Mantissa,x 				; make it point to it.
.01a09b					_VGExit:
.01a09b	7a		ply				ply
.01a09c	60		rts				rts
.01a09d					VariableSet:
.01a09d	b5 85		lda $85,x			lda 	XS_Type,x 					; is the result a string
.01a09f	29 02		and #$02			and 	#2 							; if so, it has to be
.01a0a1	d0 4b		bne $01a0ee			bne 	_VSString
.01a0a3	a5 26		lda $26				lda 	zVarType 					; if type is $ there's an error.
.01a0a5	c9 b7		cmp #$b7			cmp 	#token_Dollar
.01a0a7	f0 42		beq $01a0eb			beq 	_VSBadType
.01a0a9	c9 bb		cmp #$bb			cmp 	#token_Percent 				; type convert to float/int
.01a0ab	f0 05		beq $01a0b2			beq 	_VSMakeInt
.01a0ad	20 05 a6	jsr $01a605			jsr 	FPUToFloat
.01a0b0	80 03		bra $01a0b5			bra 	_VSCopy
.01a0b2					_VSMakeInt:
.01a0b2	20 51 a6	jsr $01a651			jsr 	FPUToInteger
.01a0b5					_VSCopy:
.01a0b5	5a		phy				phy
.01a0b6	a0 00		ldy #$00			ldy 	#0 							; copy mantissa to target.
.01a0b8	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01a0ba	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a0bc	c8		iny				iny
.01a0bd	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a0bf	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a0c1	c8		iny				iny
.01a0c2	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a0c4	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a0c6	c8		iny				iny
.01a0c7	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a0c9	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a0cb	a5 26		lda $26				lda 	zVarType 					; if target is integer, alrady done.
.01a0cd	c9 bb		cmp #$bb			cmp 	#token_Percent
.01a0cf	f0 18		beq $01a0e9			beq 	_VSExit
.01a0d1	b5 85		lda $85,x			lda 	XS_Type,x 					; get the sign bit into carry flag.
.01a0d3	0a		asl a				asl 	a
.01a0d4	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; shift the sign into the mantissa high.
.01a0d6	08		php				php
.01a0d7	0a		asl a				asl 	a
.01a0d8	28		plp				plp
.01a0d9	6a		ror a				ror 	a
.01a0da	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a0dc	c8		iny				iny
.01a0dd	b5 84		lda $84,x			lda 	XS_Exponent,x 				; copy the exponent in
.01a0df	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a0e1	34 85		bit $85,x			bit 	XS_Type,x 					; if the result is non zero
.01a0e3	50 04		bvc $01a0e9			bvc 	_VSExit
.01a0e5	a9 00		lda #$00			lda 	#0 							; zero exponent indicating 0.
.01a0e7	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a0e9					_VSExit:
.01a0e9	7a		ply				ply
.01a0ea	60		rts				rts
.01a0eb					_VSBadType:
.01a0eb	4c 67 85	jmp $018567			jmp 	TypeError
.01a0ee					_VSString:
.01a0ee	a5 26		lda $26				lda 	zVarType 					; type must be $
.01a0f0	c9 b7		cmp #$b7			cmp 	#token_Dollar
.01a0f2	d0 f7		bne $01a0eb			bne 	_VSBadType
.01a0f4	da		phx				phx
.01a0f5	5a		phy				phy
.01a0f6	20 4f 9a	jsr $019a4f			jsr 	StringConcrete 				; concrete the string in the mantissa -> AX
.01a0f9	a0 01		ldy #$01			ldy 	#1 							; save high byte
.01a0fb	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a0fd	88		dey				dey 								; save low byte
.01a0fe	8a		txa				txa
.01a0ff	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a101	7a		ply				ply 								; and exit.
.01a102	fa		plx				plx
.01a103	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.01a104					MulInteger32:
.01a104	b5 80		lda $80,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.01a106	95 8c		sta $8c,x			sta 	XS3_Mantissa,x
.01a108	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a10a	95 8d		sta $8d,x			sta 	XS3_Mantissa+1,x
.01a10c	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a10e	95 8e		sta $8e,x			sta 	XS3_Mantissa+2,x
.01a110	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a112	95 8f		sta $8f,x			sta 	XS3_Mantissa+3,x
.01a114	a9 00		lda #$00			lda 	#0
.01a116	95 80		sta $80,x			sta 	XS_Mantissa+0,x 				; zero +0, where the result goes.
.01a118	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a11a	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a11c	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a11e					_BFMMultiply:
.01a11e	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.01a120	29 01		and #$01			and 	#1
.01a122	f0 03		beq $01a127			beq 	_BFMNoAdd
.01a124	20 88 95	jsr $019588			jsr 	AddInteger32 					; co-opt this code
.01a127					_BFMNoAdd:
.01a127	16 86		asl $86,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.01a129	36 87		rol $87,x			rol 	XS2_Mantissa+1,x
.01a12b	36 88		rol $88,x			rol 	XS2_Mantissa+2,x
.01a12d	36 89		rol $89,x			rol 	XS2_Mantissa+3,x
.01a12f	56 8f		lsr $8f,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.01a131	76 8e		ror $8e,x			ror 	XS3_Mantissa+2,x
.01a133	76 8d		ror $8d,x			ror 	XS3_Mantissa+1,x
.01a135	76 8c		ror $8c,x			ror 	XS3_Mantissa,x
.01a137	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.01a139	15 8d		ora $8d,x			ora 	XS3_Mantissa+1,x
.01a13b	15 8e		ora $8e,x			ora 	XS3_Mantissa+2,x
.01a13d	15 8f		ora $8f,x			ora 	XS3_Mantissa+3,x
.01a13f	d0 dd		bne $01a11e			bne 	_BFMMultiply
.01a141	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.01a142					DivInteger32:
.01a142	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; check for division by zero.
.01a144	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.01a146	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.01a148	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.01a14a	d0 14		bne $01a160			bne 	_BFDOkay
.01a14c	20 86 85	jsr $018586			jsr ERR_Handler
>01a14f	44 69 76 69 73 69 6f 6e			.text "Division by Zero",0
>01a157	20 62 79 20 5a 65 72 6f 00
.01a160					_BFDOkay:
.01a160	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.01a162	85 1c		sta $1c				sta 	zLTemp1 					; Q/Dividend/Left in +0
.01a164	85 1d		sta $1d				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.01a166	85 1e		sta $1e				sta 	zLTemp1+2
.01a168	85 1f		sta $1f				sta 	zLTemp1+3
.01a16a	8d 9e 03	sta $039e			sta 	SignCount 					; Count of signs.
.01a16d	20 c4 a1	jsr $01a1c4			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.01a170	da		phx				phx
.01a171	e8		inx				inx
.01a172	e8		inx				inx
.01a173	e8		inx				inx
.01a174	e8		inx				inx
.01a175	e8		inx				inx
.01a176	e8		inx				inx
.01a177	20 c4 a1	jsr $01a1c4			jsr 	CheckIntegerNegate
.01a17a	fa		plx				plx
.01a17b	5a		phy				phy 								; Y is the counter
.01a17c	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.01a17e					_BFDLoop:
.01a17e	16 80		asl $80,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.01a180	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.01a182	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.01a184	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.01a186	26 1c		rol $1c				rol 	zLTemp1
.01a188	26 1d		rol $1d				rol 	zLTemp1+1
.01a18a	26 1e		rol $1e				rol 	zLTemp1+2
.01a18c	26 1f		rol $1f				rol 	zLTemp1+3
.01a18e	38		sec				sec
.01a18f	a5 1c		lda $1c				lda 	zLTemp1+0 					; Calculate A-M on stack.
.01a191	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.01a193	48		pha				pha
.01a194	a5 1d		lda $1d				lda 	zLTemp1+1
.01a196	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.01a198	48		pha				pha
.01a199	a5 1e		lda $1e				lda 	zLTemp1+2
.01a19b	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.01a19d	48		pha				pha
.01a19e	a5 1f		lda $1f				lda 	zLTemp1+3
.01a1a0	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.01a1a2	90 13		bcc $01a1b7			bcc 	_BFDNoAdd
.01a1a4	85 1f		sta $1f				sta 	zLTemp1+3 					; update A
.01a1a6	68		pla				pla
.01a1a7	85 1e		sta $1e				sta 	zLTemp1+2
.01a1a9	68		pla				pla
.01a1aa	85 1d		sta $1d				sta 	zLTemp1+1
.01a1ac	68		pla				pla
.01a1ad	85 1c		sta $1c				sta 	zLTemp1+0
.01a1af	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.01a1b1	09 01		ora #$01			ora 	#1
.01a1b3	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a1b5	80 03		bra $01a1ba			bra 	_BFDNext
.01a1b7					_BFDNoAdd:
.01a1b7	68		pla				pla 								; Throw away the intermediate calculations
.01a1b8	68		pla				pla
.01a1b9	68		pla				pla
.01a1ba					_BFDNext:
.01a1ba	88		dey				dey
.01a1bb	d0 c1		bne $01a17e			bne 	_BFDLoop
.01a1bd	7a		ply				ply 								; restore Y
.01a1be	4e 9e 03	lsr $039e			lsr 	SignCount 					; if sign count odd,
.01a1c1	b0 06		bcs $01a1c9			bcs		IntegerNegateAlways 		; negate the result
.01a1c3	60		rts				rts
.01a1c4					CheckIntegerNegate:
.01a1c4	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; is it -ve = MSB set ?
.01a1c6	30 01		bmi $01a1c9			bmi 	IntegerNegateAlways 		; if so negate it
.01a1c8	60		rts				rts
.01a1c9					IntegerNegateAlways:
.01a1c9	ee 9e 03	inc $039e			inc 	SignCount 					; bump the count of signs
.01a1cc	38		sec				sec 								; 0-mantissa,x -> mantissa,x
.01a1cd	a9 00		lda #$00			lda 	#0
.01a1cf	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.01a1d1	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a1d3	a9 00		lda #$00			lda 	#0
.01a1d5	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.01a1d7	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a1d9	a9 00		lda #$00			lda 	#0
.01a1db	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.01a1dd	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a1df	a9 00		lda #$00			lda 	#0
.01a1e1	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.01a1e3	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a1e5	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.01a1e6					INTToString:
.01a1e6	48		pha				pha
.01a1e7	5a		phy				phy
.01a1e8	b5 83		lda $83,x			lda 		XS_Mantissa+3,x 		; check -ve
.01a1ea	10 08		bpl $01a1f4			bpl 		_ITSNotMinus
.01a1ec	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.01a1ee	20 88 a2	jsr $01a288			jsr 		ITSOutputCharacter 		; .... if it is minus.
.01a1f1	20 c9 a1	jsr $01a1c9			jsr 		IntegerNegateAlways 	; negate the number.
.01a1f4					_ITSNotMinus:
.01a1f4	a9 00		lda #$00			lda 		#0
.01a1f6	8d 9a 03	sta $039a			sta 		NumSuppress 			; clear the suppression flag.
.01a1f9	8a		txa				txa 								; use Y for the mantissa index.
.01a1fa	a8		tay				tay
.01a1fb	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.01a1fd					_ITSNextSubtractor:
.01a1fd	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.01a1ff	8d 9b 03	sta $039b			sta 		NumConvCount
.01a202					_ITSSubtract:
.01a202	38		sec				sec
.01a203	b9 80 00	lda $0080,y			lda 		XS_Mantissa,y 			; subtract number and push on stack
.01a206	ff 64 a2 01	sbc $01a264,x			sbc 		_ITSSubtractors+0,x 	; only update if actually can subtract it.
.01a20a	48		pha				pha
.01a20b	b9 81 00	lda $0081,y			lda 		XS_Mantissa+1,y
.01a20e	ff 65 a2 01	sbc $01a265,x			sbc 		_ITSSubtractors+1,x
.01a212	48		pha				pha
.01a213	b9 82 00	lda $0082,y			lda 		XS_Mantissa+2,y
.01a216	ff 66 a2 01	sbc $01a266,x			sbc 		_ITSSubtractors+2,x
.01a21a	48		pha				pha
.01a21b	b9 83 00	lda $0083,y			lda 		XS_Mantissa+3,y
.01a21e	ff 67 a2 01	sbc $01a267,x			sbc 		_ITSSubtractors+3,x
.01a222	90 14		bcc $01a238			bcc 		_ITSCantSubtract 		; if CC, then gone too far, can't subtract
.01a224	99 83 00	sta $0083,y			sta 		XS_Mantissa+3,y 		; save subtract off stack as it's okay
.01a227	68		pla				pla
.01a228	99 82 00	sta $0082,y			sta 		XS_Mantissa+2,y
.01a22b	68		pla				pla
.01a22c	99 81 00	sta $0081,y			sta 		XS_Mantissa+1,y
.01a22f	68		pla				pla
.01a230	99 80 00	sta $0080,y			sta 		XS_Mantissa+0,y
.01a233	ee 9b 03	inc $039b			inc 		NumConvCount 			; bump count.
.01a236	80 ca		bra $01a202			bra 		_ITSSubtract 			; go round again.
.01a238					_ITSCantSubtract:
.01a238	68		pla				pla 								; throw away interim answers
.01a239	68		pla				pla 								; (the subtraction that failed)
.01a23a	68		pla				pla
.01a23b	ad 9b 03	lda $039b			lda 		NumConvCount 			; if not zero then no suppression check
.01a23e	c9 30		cmp #$30			cmp 		#"0"
.01a240	d0 05		bne $01a247			bne 		_ITSOutputDigit
.01a242	ad 9a 03	lda $039a			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.01a245	10 09		bpl $01a250			bpl	 		_ITSGoNextSubtractor
.01a247					_ITSOutputDigit:
.01a247	ce 9a 03	dec $039a			dec 		NumSuppress 			; suppression check will be non-zero from now on.
.01a24a	ad 9b 03	lda $039b			lda 		NumConvCount 			; count of subtractions
.01a24d	20 88 a2	jsr $01a288			jsr 		ITSOutputCharacter 		; output it.
.01a250					_ITSGoNextSubtractor:
.01a250	e8		inx				inx 								; next dword in subtractor table.
.01a251	e8		inx				inx
.01a252	e8		inx				inx
.01a253	e8		inx				inx
.01a254	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.01a256	d0 a5		bne $01a1fd			bne 		_ITSNextSubtractor 		; do all the subtractors.
.01a258	98		tya				tya 								; X is back as the mantissa index
.01a259	aa		tax				tax
.01a25a	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.01a25c	09 30		ora #$30			ora 		#"0"
.01a25e	20 88 a2	jsr $01a288			jsr 		ITSOutputCharacter
.01a261	7a		ply				ply 								; and exit
.01a262	68		pla				pla
.01a263	60		rts				rts
.01a264					_ITSSubtractors:
>01a264	00 ca 9a 3b					.dword 		1000000000
>01a268	00 e1 f5 05					.dword 		100000000
>01a26c	80 96 98 00					.dword 		10000000
>01a270	40 42 0f 00					.dword 		1000000
>01a274	a0 86 01 00					.dword 		100000
>01a278	10 27 00 00					.dword 		10000
>01a27c	e8 03 00 00					.dword 		1000
>01a280	64 00 00 00					.dword 		100
>01a284	0a 00 00 00					.dword 		10
.01a288					_ITSSubtractorsEnd:
.01a288					ITSOutputCharacter:
.01a288	48		pha				pha
.01a289	da		phx				phx
.01a28a	ae 14 03	ldx $0314			ldx 	NumBufX 					; save digit
.01a28d	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.01a290	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.01a292	9d 16 03	sta $0316,x			sta 	Num_Buffer+1,x
.01a295	ee 14 03	inc $0314			inc 	NumBufX						; bump pointer.
.01a298	fa		plx				plx
.01a299	68		pla				pla
.01a29a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.01a29b					IntFromString:
.01a29b	a0 00		ldy #$00			ldy 	#0 							; from (zGenPtr)
.01a29d					IntFromStringY:
.01a29d	a9 00		lda #$00			lda 	#0
.01a29f	8d 9c 03	sta $039c			sta 	ExpTemp 					; this is the converted digit count.
.01a2a2	48		pha				pha
.01a2a3	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.01a2a5	95 80		sta $80,x			sta 	XS_Mantissa,x 				; (the number converted goes here)
.01a2a7	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a2a9	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a2ab	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a2ad	a9 01		lda #$01			lda 	#1 							; sete type to integer
.01a2af	95 85		sta $85,x			sta 	XS_Type,x
.01a2b1					_IFSLoop:
.01a2b1	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; get next
.01a2b3	c9 30		cmp #$30			cmp 	#"0"						; validate it as range 0-9
.01a2b5	90 4e		bcc $01a305			bcc 	_IFSExit
.01a2b7	c9 3a		cmp #$3a			cmp 	#"9"+1
.01a2b9	b0 4a		bcs $01a305			bcs 	_IFSExit
.01a2bb	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.01a2bd	c9 0c		cmp #$0c			cmp 	#12 						; (approximately)
.01a2bf	b0 4e		bcs $01a30f			bcs 	_IFSOverflow
.01a2c1	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.01a2c3	48		pha				pha
.01a2c4	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a2c6	48		pha				pha
.01a2c7	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a2c9	48		pha				pha
.01a2ca	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01a2cc	48		pha				pha
.01a2cd	20 24 a3	jsr $01a324			jsr 	IFSX1ShiftLeft 				; double
.01a2d0	20 24 a3	jsr $01a324			jsr 	IFSX1ShiftLeft 				; x 4
.01a2d3	18		clc				clc 								; add saved value x 5
.01a2d4	68		pla				pla
.01a2d5	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.01a2d7	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a2d9	68		pla				pla
.01a2da	75 81		adc $81,x			adc 	XS_Mantissa+1,x
.01a2dc	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a2de	68		pla				pla
.01a2df	75 82		adc $82,x			adc 	XS_Mantissa+2,x
.01a2e1	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a2e3	68		pla				pla
.01a2e4	75 83		adc $83,x			adc 	XS_Mantissa+3,x
.01a2e6	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a2e8	20 24 a3	jsr $01a324			jsr 	IFSX1ShiftLeft 				; x 10
.01a2eb	ee 9c 03	inc $039c			inc 	ExpTemp 					; bump count of digits processed.
.01a2ee	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; add digit
.01a2f0	29 0f		and #$0f			and 	#15
.01a2f2	c8		iny				iny
.01a2f3	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.01a2f5	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a2f7	90 b8		bcc $01a2b1			bcc 	_IFSLoop
.01a2f9	f6 81		inc $81,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.01a2fb	d0 b4		bne $01a2b1			bne 	_IFSLoop
.01a2fd	f6 82		inc $82,x			inc 	XS_Mantissa+2,x
.01a2ff	d0 b0		bne $01a2b1			bne 	_IFSLoop
.01a301	f6 83		inc $83,x			inc 	XS_Mantissa+3,x
.01a303	80 ac		bra $01a2b1			bra 	_IFSLoop
.01a305					_IFSExit:
.01a305	98		tya				tya 								; get offset
.01a306					_IFSOkay:
.01a306	38		sec				sec
.01a307	ad 9c 03	lda $039c			lda 	ExpTemp 					; if no digits processed, no integer here.
.01a30a	f0 01		beq $01a30d			beq 	_IFSSkipFail
.01a30c	18		clc				clc
.01a30d					_IFSSkipFail:
.01a30d	68		pla				pla 								; and exit.
.01a30e	60		rts				rts
.01a30f					_IFSOverflow:
.01a30f	20 86 85	jsr $018586			jsr 	ERR_Handler
>01a312	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>01a31a	20 6f 76 65 72 66 6c 6f 77 00
.01a324					IFSX1ShiftLeft:
.01a324	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.01a326	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.01a328	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.01a32a	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.01a32c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.01a32d					FPSubtract:
.01a32d	48		pha				pha
.01a32e	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.01a330	49 80		eor #$80			eor 	#$80
.01a332	95 8b		sta $8b,x			sta 	XS2_Type,x
.01a334	68		pla				pla 								; --- and fall through ---
.01a335					FPAdd:
.01a335	48		pha				pha
.01a336	b5 85		lda $85,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.01a338	d0 05		bne $01a33f			bne 	_FPA_NegativeLHS
.01a33a	20 56 a3	jsr $01a356			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.01a33d	68		pla				pla
.01a33e	60		rts				rts
.01a33f					_FPA_NegativeLHS:
.01a33f	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.01a341	49 80		eor #$80			eor 	#$80
.01a343	95 85		sta $85,x			sta 	XS_Type,x
.01a345	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of B and add
.01a347	49 80		eor #$80			eor 	#$80
.01a349	95 8b		sta $8b,x			sta 	XS2_Type,x
.01a34b	20 56 a3	jsr $01a356			jsr 	FPAdd_Worker 				; do the add calculation.
.01a34e	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 back
.01a350	49 80		eor #$80			eor 	#$80
.01a352	95 85		sta $85,x			sta 	XS_Type,x
.01a354	68		pla				pla
.01a355	60		rts				rts
.01a356					FPAdd_Worker:
.01a356	34 8b		bit $8b,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.01a358	70 07		bvs $01a361			bvs 	_FPAWExit 					; no change.
.01a35a	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.01a35c	50 07		bvc $01a365			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.01a35e	20 c3 a5	jsr $01a5c3			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.01a361					_FPAWExit:
.01a361	20 32 a6	jsr $01a632			jsr 	FPUNormalise 				; normalise the result.
.01a364	60		rts				rts
.01a365					_FPAWMakeSame:
.01a365	b5 84		lda $84,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.01a367	38		sec				sec
.01a368	f5 8a		sbc $8a,x			sbc	 	XS2_Exponent,x 				; using subtraction
.01a36a	f0 16		beq $01a382			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.01a36c	da		phx				phx 								; save X
.01a36d	90 06		bcc $01a375			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.01a36f	e8		inx				inx
.01a370	e8		inx				inx
.01a371	e8		inx				inx
.01a372	e8		inx				inx
.01a373	e8		inx				inx
.01a374	e8		inx				inx
.01a375					_FPAWShiftA:
.01a375	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.01a377	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.01a379	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a37b	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a37d	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a37f	fa		plx				plx 								; restore original X
.01a380	80 e3		bra $01a365			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.01a382					_FPAW_DoArithmetic:
.01a382	34 8b		bit $8b,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.01a384	30 20		bmi $01a3a6			bmi 	_FPAW_BNegative
.01a386	c2 30		rep #$30			rep 	#$30
.01a388	18		clc				clc
.01a389	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01a38b	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.01a38d	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a38f	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a391	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.01a393	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a395	e2 30		sep #$30			sep 	#$30
.01a397	90 c8		bcc $01a361			bcc 	_FPAWExit 					; no carry.
.01a399	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.01a39b	38		sec				sec
.01a39c	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.01a39e	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a3a0	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a3a2	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a3a4	80 bb		bra $01a361			bra 	_FPAWExit
.01a3a6					_FPAW_BNegative:
.01a3a6	c2 30		rep #$30			rep 	#$30
.01a3a8	38		sec				sec
.01a3a9	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01a3ab	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.01a3ad	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a3af	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a3b1	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.01a3b3	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a3b5	e2 30		sep #$30			sep 	#$30
.01a3b7	b0 09		bcs $01a3c2			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.01a3b9	20 e9 a5	jsr $01a5e9			jsr 	FPUNegateInteger			; negate the mantissa
.01a3bc	b5 85		lda $85,x			lda 	XS_Type,x 					; flip result sign
.01a3be	49 80		eor #$80			eor 	#$80
.01a3c0	95 85		sta $85,x			sta 	XS_Type,x
.01a3c2					_FPAWGoExit:
.01a3c2	4c 61 a3	jmp $01a361			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.01a3c5					FPD_IsDivZero:
.01a3c5	20 86 85	jsr $018586			jsr ERR_Handler
>01a3c8	44 69 76 69 73 69 6f 6e			.text "Division by zero",0
>01a3d0	20 62 79 20 7a 65 72 6f 00
.01a3d9					FPDivide:
.01a3d9	48		pha				pha
.01a3da	5a		phy				phy
.01a3db	34 8b		bit $8b,x			bit 	XS2_Type,x 					; check if division by zero
.01a3dd	70 e6		bvs $01a3c5			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.01a3df	34 85		bit $85,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.01a3e1	f0 03		beq $01a3e6			beq 	_FPDCalculateExp
.01a3e3					_FPD_Exit:
.01a3e3	7a		ply				ply
.01a3e4	68		pla				pla
.01a3e5	60		rts				rts
.01a3e6					_FPDCalculateExp:
.01a3e6	b5 8a		lda $8a,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.01a3e8	49 ff		eor #$ff			eor 	#$FF
.01a3ea	1a		inc a				inc 	a
.01a3eb	95 8a		sta $8a,x			sta 	XS2_Exponent,x
.01a3ed	20 bd a4	jsr $01a4bd			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.01a3f0	18		clc				clc 	 							; add 1 to the resulting exponent
.01a3f1	69 01		adc #$01			adc 	#1
.01a3f3	b0 54		bcs $01a449			bcs 	_FPD_Overflow 				; which can overflow.
.01a3f5	95 84		sta $84,x			sta 	XS_Exponent,x
.01a3f7	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.01a3f9	85 1c		sta $1c				sta 	zLTemp1+0
.01a3fb	85 1d		sta $1d				sta 	zLTemp1+1
.01a3fd	85 1e		sta $1e				sta 	zLTemp1+2
.01a3ff	85 1f		sta $1f				sta 	zLTemp1+3
.01a401	a0 20		ldy #$20			ldy 	#32 						; times round.
.01a403					_FPD_Loop:
.01a403	38		sec				sec 								; calculate X1-X2 stacking result because we might
.01a404	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; not save it.
.01a406	f5 86		sbc $86,x			sbc 	XS2_Mantissa,x
.01a408	48		pha				pha
.01a409	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a40b	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.01a40d	48		pha				pha
.01a40e	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a410	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.01a412	48		pha				pha
.01a413	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a415	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.01a417	90 13		bcc $01a42c			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.01a419	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; save results out to A
.01a41b	68		pla				pla
.01a41c	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a41e	68		pla				pla
.01a41f	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a421	68		pla				pla
.01a422	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a424	a5 1f		lda $1f				lda 	zLTemp1+3 					; set high bit of result
.01a426	09 80		ora #$80			ora 	#$80
.01a428	85 1f		sta $1f				sta 	zLTemp1+3
.01a42a	80 03		bra $01a42f			bra 	_FPD_Rotates
.01a42c					_FPD_NoSubtract:
.01a42c	68		pla				pla 								; throw away unwanted results
.01a42d	68		pla				pla
.01a42e	68		pla				pla
.01a42f					_FPD_Rotates:
.01a42f	56 89		lsr $89,x			lsr 	3+XS2_Mantissa,x
.01a431	76 88		ror $88,x			ror 	2+XS2_Mantissa,x
.01a433	76 87		ror $87,x			ror 	1+XS2_Mantissa,x
.01a435	76 86		ror $86,x			ror 	0+XS2_Mantissa,x
.01a437	06 1c		asl $1c				asl 	0+zLTemp1
.01a439	26 1d		rol $1d				rol 	1+zLTemp1
.01a43b	26 1e		rol $1e				rol 	2+zLTemp1
.01a43d	26 1f		rol $1f				rol 	3+zLTemp1
.01a43f	90 02		bcc $01a443			bcc 	_FPD_NoCarry
.01a441	e6 1c		inc $1c				inc 	zLTemp1 					; if rotated out, set LSB.
.01a443					_FPD_NoCarry:
.01a443	88		dey				dey 								; do 32 times
.01a444	d0 bd		bne $01a403			bne 	_FPD_Loop
.01a446	4c a1 a4	jmp $01a4a1			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.01a449					_FPD_Overflow:
.01a449	4c 8f a6	jmp $01a68f			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.01a44c					FPMultiply:
.01a44c	48		pha				pha
.01a44d	5a		phy				phy
.01a44e	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.01a450	70 07		bvs $01a459			bvs 	_FPM_Exit
.01a452	34 8b		bit $8b,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.01a454	50 06		bvc $01a45c			bvc 	_FPM_CalcExponent
.01a456	20 c3 a5	jsr $01a5c3			jsr 	FPUCopyX2ToX1
.01a459					_FPM_Exit:
.01a459	7a		ply				ply
.01a45a	68		pla				pla
.01a45b	60		rts				rts
.01a45c					_FPM_CalcExponent:
.01a45c	18		clc				clc
.01a45d	20 bd a4	jsr $01a4bd			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.01a460	95 84		sta $84,x			sta 	XS_Exponent,x 				; save the result.
.01a462	a9 00		lda #$00			lda 	#0
.01a464	85 1c		sta $1c				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.01a466	85 1d		sta $1d				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.01a468	85 1e		sta $1e				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.01a46a	85 1f		sta $1f				sta 	zLTemp1+3
.01a46c	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.01a46e					_FPM_Loop:
.01a46e	b5 80		lda $80,x			lda 	XS_Mantissa,x				; check LSB of long product
.01a470	29 01		and #$01			and 	#1
.01a472	18		clc				clc 								; clear carry for the long rotate.
.01a473	f0 19		beq $01a48e			beq 	_FPM_NoAddition
.01a475	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.01a476	a5 1c		lda $1c				lda 	zLTemp1+0
.01a478	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.01a47a	85 1c		sta $1c				sta 	zLTemp1+0
.01a47c	a5 1d		lda $1d				lda 	zLTemp1+1
.01a47e	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.01a480	85 1d		sta $1d				sta 	zLTemp1+1
.01a482	a5 1e		lda $1e				lda 	zLTemp1+2
.01a484	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.01a486	85 1e		sta $1e				sta 	zLTemp1+2
.01a488	a5 1f		lda $1f				lda 	zLTemp1+3
.01a48a	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.01a48c	85 1f		sta $1f				sta 	zLTemp1+3
.01a48e					_FPM_NoAddition:
.01a48e	66 1f		ror $1f				ror 	3+zLTemp1
.01a490	66 1e		ror $1e				ror 	2+zLTemp1
.01a492	66 1d		ror $1d				ror 	1+zLTemp1
.01a494	66 1c		ror $1c				ror 	0+zLTemp1
.01a496	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.01a498	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a49a	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a49c	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a49e	88		dey				dey
.01a49f	d0 cd		bne $01a46e			bne 	_FPM_Loop 					; do this 32 times.
.01a4a1					FPM_CopySignNormalize:
.01a4a1	a5 1c		lda $1c				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.01a4a3	95 80		sta $80,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.01a4a5	a5 1d		lda $1d				lda 	zLTemp1+1
.01a4a7	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a4a9	a5 1e		lda $1e				lda 	zLTemp1+2
.01a4ab	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a4ad	a5 1f		lda $1f				lda 	zLTemp1+3
.01a4af	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a4b1	b5 85		lda $85,x			lda 	XS_Type,x 					; sign is xor of signs
.01a4b3	55 8b		eor $8b,x			eor 	XS2_Type,x
.01a4b5	95 85		sta $85,x			sta 	XS_Type,x
.01a4b7	20 32 a6	jsr $01a632			jsr 	FPUNormalise 				; normalise and exit.
.01a4ba	7a		ply				ply
.01a4bb	68		pla				pla
.01a4bc	60		rts				rts
.01a4bd					FPCalculateExponent:
.01a4bd	18		clc				clc
.01a4be	b5 84		lda $84,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.01a4c0	75 8a		adc $8a,x			adc 	XS2_Exponent,x
.01a4c2	b0 08		bcs $01a4cc			bcs 	_FPCECarry 					; carry out ?
.01a4c4	10 03		bpl $01a4c9			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.01a4c6	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.01a4c8	60		rts				rts
.01a4c9					_FPCEExpZero:
.01a4c9	a9 00		lda #$00			lda 	#0
.01a4cb	60		rts				rts
.01a4cc					_FPCECarry:
.01a4cc	30 03		bmi $01a4d1			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.01a4ce	09 80		ora #$80			ora 	#$80 						; put in right range
.01a4d0	60		rts				rts
.01a4d1					_FPCEOverflow:
.01a4d1	4c 8f a6	jmp $01a68f			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.01a4d4					FPFractionalPart:
.01a4d4	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.01a4d6	38		sec				sec 								; this flag tells us to keep the fractional part
.01a4d7	30 0d		bmi $01a4e6			bmi 	FPGetPart
.01a4d9	60		rts				rts
.01a4da					FPIntegerPart:
.01a4da	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.01a4dc	18		clc				clc 								; this flag says keep the integer part.
.01a4dd	30 07		bmi $01a4e6			bmi 	FPGetPart 					; -ve exponents are 0..127
.01a4df	48		pha				pha
.01a4e0	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.01a4e2	95 85		sta $85,x			sta 	XS_Type,x
.01a4e4	68		pla				pla
.01a4e5	60		rts				rts
.01a4e6					FPGetPart:
.01a4e6	48		pha				pha
.01a4e7	5a		phy				phy 								; save Y
.01a4e8	08		php				php 								; save action
.01a4e9	34 85		bit $85,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.01a4eb	70 59		bvs $01a546			bvs 	_FPGP_Exit 					; then do nothing.
.01a4ed	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.01a4ef	85 1c		sta $1c				sta 	zLTemp1+0 					; this mask is applied to chop out the
.01a4f1	85 1d		sta $1d				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.01a4f3	85 1e		sta $1e				sta 	zLTemp1+2
.01a4f5	85 1f		sta $1f				sta 	zLTemp1+3
.01a4f7	b5 84		lda $84,x			lda 	XS_Exponent,x				; the number of shifts.
.01a4f9	38		sec				sec
.01a4fa	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.01a4fc	f0 12		beq $01a510			beq 	_FPGP_NoShift 				; ... if any
.01a4fe	c9 20		cmp #$20			cmp 	#32
.01a500	90 02		bcc $01a504			bcc 	_FPGP_NotMax
.01a502	a9 20		lda #$20			lda 	#32 						; max of 32.
.01a504					_FPGP_NotMax:
.01a504	a8		tay				tay 								; Y is the mask shift count.
.01a505					_FPGP_ShiftMask:
.01a505	46 1f		lsr $1f				lsr 	3+zLTemp1
.01a507	66 1e		ror $1e				ror 	2+zLTemp1
.01a509	66 1d		ror $1d				ror 	1+zLTemp1
.01a50b	66 1c		ror $1c				ror 	0+zLTemp1
.01a50d	88		dey				dey
.01a50e	d0 f5		bne $01a505			bne 	_FPGP_ShiftMask
.01a510					_FPGP_NoShift:
.01a510	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.01a512	8e 9c 03	stx $039c			stx 	ExpTemp						; save X
.01a515					_FPGP_MaskLoop:
.01a515	b9 1c 00	lda $001c,y			lda 	zlTemp1,y 					; get mask byte
.01a518	28		plp				plp 								; if CC we keep the top part, so we
.01a519	08		php				php		 							; flip the mask.
.01a51a	b0 02		bcs $01a51e			bcs		_FPGP_NoFlip
.01a51c	49 ff		eor #$ff			eor 	#$FF
.01a51e					_FPGP_NoFlip:
.01a51e	35 80		and $80,x			and 	XS_Mantissa,x 				; and into the mantissa.
.01a520	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a522	e8		inx				inx
.01a523	c8		iny				iny
.01a524	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.01a526	d0 ed		bne $01a515			bne 	_FPGP_MaskLoop
.01a528	ae 9c 03	ldx $039c			ldx 	ExpTemp						; restore X
.01a52b	28		plp				plp
.01a52c	08		php				php 								; get action flag on the stack
.01a52d	90 04		bcc $01a533			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.01a52f	a9 00		lda #$00			lda 	#0
.01a531	95 85		sta $85,x			sta 	XS_Type,x
.01a533					_FPGP_NotFractional:
.01a533	b5 80		lda $80,x			lda 	XS_Mantissa,x 						; check if \1 zero
.01a535	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.01a537	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01a539	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01a53b	f0 05		beq $01a542			beq 	_FPGP_Zero 					; if zero, return zero
.01a53d	20 32 a6	jsr $01a632			jsr 	FPUNormalise
.01a540	80 04		bra $01a546			bra 	_FPGP_Exit 					; and exit
.01a542					_FPGP_Zero:
.01a542	a9 40		lda #$40			lda 	#$40 						; set zero flag
.01a544	95 85		sta $85,x			sta 	XS_Type,x
.01a546					_FPGP_Exit:
.01a546	68		pla				pla 								; throw saved action flag.
.01a547	7a		ply				ply
.01a548	68		pla				pla
.01a549	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.01a54a					FPCompare:
.01a54a	20 8b a5	jsr $01a58b			jsr 	FPFastCompare 				; fast compare try first
.01a54d	b0 3b		bcs $01a58a			bcs 	_FPCExit 					; that worked.
.01a54f	b5 84		lda $84,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.01a551	48		pha				pha
.01a552	b5 8a		lda $8a,x			lda 	XS2_Exponent,x
.01a554	48		pha				pha
.01a555	20 2d a3	jsr $01a32d			jsr 	FPSubtract 					; calculate X1-X2
.01a558	34 85		bit $85,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.01a55a	70 2a		bvs $01a586			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exponents
.01a55c	68		pla				pla
.01a55d	8d 9c 03	sta $039c			sta 	ExpTemp						; save first exponent in temporary reg.
.01a560	68		pla				pla
.01a561	38		sec				sec
.01a562	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; calculate AX-BX
.01a565	70 14		bvs $01a57b			bvs 	_FPCNotEqual				; overflow, can't be equal.
.01a567	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.01a568	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.01a56a	b0 0f		bcs $01a57b			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.01a56c	38		sec				sec
.01a56d	ad 9c 03	lda $039c			lda 	ExpTemp 					; get one of the exponents back.
.01a570	e9 12		sbc #$12			sbc 	#18 						; allow for 2^18 error, relatively.
.01a572	b0 02		bcs $01a576			bcs 	_FPCNotRange 				; keep in range.
.01a574	a9 01		lda #$01			lda 	#1
.01a576					_FPCNotRange:
.01a576	38		sec				sec
.01a577	f5 84		sbc $84,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.01a579	b0 0d		bcs $01a588			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.01a57b					_FPCNotEqual:
.01a57b	b5 85		lda $85,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.01a57d	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.01a57f	f0 02		beq $01a583			beq 	_FPCNE2
.01a581	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.01a583	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.01a584	80 04		bra $01a58a			bra 	_FPCExit
.01a586					_FPCPullZero:
.01a586	68		pla				pla 								; throw saved exponents
.01a587	68		pla				pla
.01a588					_FPCZero:
.01a588	a9 00		lda #$00			lda 	#0 							; and return zero
.01a58a					_FPCExit:
.01a58a	60		rts				rts
.01a58b					FPFastCompare:
.01a58b	34 85		bit $85,x			bit 	XS_Type,x 					; n1 is zero.
.01a58d	70 23		bvs $01a5b2			bvs 	_FPFLeftZero 				; return invert sign of n2 (0-n2)
.01a58f	34 8b		bit $8b,x			bit 	XS2_Type,x 					; n2 is zero ?
.01a591	b5 85		lda $85,x			lda 	XS_Type,x 					; if so, return sign bit of n1 (n1-0)
.01a593	70 25		bvs $01a5ba			bvs 	_FPFSignBit
.01a595	55 8b		eor $8b,x			eor 	XS2_Type,x 					; eor 2 type bits. now know both non-zero
.01a597	0a		asl a				asl 	a 							; put in CS if different.
.01a598	b5 85		lda $85,x			lda 	XS_Type,x 					; if signs different return sign of first
.01a59a	b0 1e		bcs $01a5ba			bcs 	_FPFSignBit
.01a59c	38		sec				sec 								; same sign and not-zero. compare exponents
.01a59d	b5 84		lda $84,x			lda 	XS_Exponent,x 				; compare exponents. if the same, then fail.
.01a59f	f5 8a		sbc $8a,x			sbc 	XS2_Exponent,x 				; e.g. we have to do it via subtraction.
.01a5a1	f0 09		beq $01a5ac			beq 	_FPNoFastCompare
.01a5a3	6a		ror a				ror 	a 							; put carry into bit 7.
.01a5a4	34 85		bit $85,x			bit 	XS_Type,X 					; if it is +x then flip it.
.01a5a6	30 02		bmi $01a5aa			bmi		_FPFCNotMinus
.01a5a8	49 80		eor #$80			eor 	#$80
.01a5aa					_FPFCNotMinus:
.01a5aa	80 0e		bra $01a5ba			bra		_FPFSignBit
.01a5ac					_FPNoFastCompare:
.01a5ac	18		clc				clc
.01a5ad	60		rts				rts
.01a5ae					_FPFZero:
.01a5ae	a9 00		lda #$00			lda 	#0
.01a5b0					_FPFExitSet:
.01a5b0	38		sec				sec
.01a5b1	60		rts				rts
.01a5b2					_FPFLeftZero:
.01a5b2	34 8b		bit $8b,x			bit 	XS2_Type,x 					; if right is zero, return zero.
.01a5b4	70 f8		bvs $01a5ae			bvs 	_FPFZero
.01a5b6	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip sign bit
.01a5b8	49 80		eor #$80			eor 	#$80						; return that as a sign.
.01a5ba					_FPFSignBit:
.01a5ba	0a		asl a				asl 	a
.01a5bb	a9 01		lda #$01			lda 	#1
.01a5bd	90 f1		bcc $01a5b0			bcc		_FPFExitSet
.01a5bf	a9 ff		lda #$ff			lda 	#$FF
.01a5c1	38		sec				sec
.01a5c2	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.01a5c3					FPUCopyX2ToX1:
.01a5c3	48		pha				pha									; save AXY
.01a5c4	da		phx				phx
.01a5c5	5a		phy				phy
.01a5c6	a0 08		ldy #$08			ldy 	#8 							; copy the whole mantissa
.01a5c8	b5 86		lda $86,x	_FPUC21:lda 	XS2_Mantissa,x
.01a5ca	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a5cc	e8		inx				inx
.01a5cd	88		dey				dey
.01a5ce	10 f8		bpl $01a5c8			bpl 	_FPUC21
.01a5d0	7a		ply				ply 								; restore and exit
.01a5d1	fa		plx				plx
.01a5d2	68		pla				pla
.01a5d3	60		rts				rts
.01a5d4					FPUSetInteger:
.01a5d4	48		pha				pha
.01a5d5	95 80		sta $80,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.01a5d7	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.01a5d9	10 02		bpl $01a5dd			bpl 	_FPUSIExtend 				; so sign extend it into the mantissa
.01a5db	a9 ff		lda #$ff			lda 	#$FF
.01a5dd					_FPUSIExtend:
.01a5dd	95 81		sta $81,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.01a5df	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a5e1	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a5e3	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.01a5e5	95 85		sta $85,x			sta 	XS_Type,x
.01a5e7	68		pla				pla
.01a5e8	60		rts				rts
.01a5e9					FPUNegateInteger:
.01a5e9	48		pha				pha
.01a5ea	38		sec				sec
.01a5eb	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.01a5ed	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.01a5ef	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a5f1	a9 00		lda #$00			lda 	#0
.01a5f3	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.01a5f5	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a5f7	a9 00		lda #$00			lda 	#0
.01a5f9	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.01a5fb	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a5fd	a9 00		lda #$00			lda 	#0
.01a5ff	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.01a601	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a603	68		pla				pla
.01a604	60		rts				rts
.01a605					FPUToFloat:
.01a605	48		pha				pha
.01a606	b5 85		lda $85,x			lda 	XS_Type,x					; exit if already float.
.01a608	29 0f		and #$0f			and 	#$0F 						; (e.g. type is zero)
.01a60a	f0 24		beq $01a630			beq 	_FPUFExit
.01a60c	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.01a60e	95 85		sta $85,x			sta 	XS_Type,x
.01a610	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.01a612	95 84		sta $84,x			sta 	XS_Exponent,x 				; x mantissa.
.01a614	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.01a616	10 07		bpl $01a61f			bpl		_FPUFPositive
.01a618	20 e9 a5	jsr $01a5e9			jsr 	FPUNegateInteger 			; negate the mantissa
.01a61b	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.01a61d	95 85		sta $85,x			sta 	XS_Type,x
.01a61f					_FPUFPositive:
.01a61f	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.01a621	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.01a623	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01a625	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01a627	d0 04		bne $01a62d			bne 	_FPUFNonZero
.01a629	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.01a62b	95 85		sta $85,x			sta 	XS_Type,x
.01a62d					_FPUFNonZero:
.01a62d	20 32 a6	jsr $01a632			jsr 	FPUNormalise 				; normalise the floating point.
.01a630					_FPUFExit:
.01a630	68		pla				pla
.01a631	60		rts				rts
.01a632					FPUNormalise:
.01a632	48		pha				pha
.01a633	34 85		bit $85,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.01a635	70 18		bvs $01a64f			bvs 	_FPUNExit
.01a637	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.01a639	f0 10		beq $01a64b			beq 	_FPUNSetZero 				; (e.g. the float value zero)
.01a63b					_FPUNLoop:
.01a63b	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.01a63d	30 10		bmi $01a64f			bmi 	_FPUNExit 					; if so, we are normalised.
.01a63f	16 80		asl $80,x			asl 	0+XS_Mantissa+0,x
.01a641	36 81		rol $81,x			rol 	1+XS_Mantissa+0,x
.01a643	36 82		rol $82,x			rol 	2+XS_Mantissa+0,x
.01a645	36 83		rol $83,x			rol 	3+XS_Mantissa+0,x
.01a647	d6 84		dec $84,x			dec 	XS_Exponent,x 				; decrement exponent
.01a649	d0 f0		bne $01a63b			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.01a64b					_FPUNSetZero:
.01a64b	a9 40		lda #$40			lda 	#$40
.01a64d	95 85		sta $85,x			sta 	XS_Type,x 					; the result is now zero.
.01a64f					_FPUNExit:
.01a64f	68		pla				pla
.01a650	60		rts				rts
.01a651					FPUToInteger:
.01a651	48		pha				pha
.01a652	b5 85		lda $85,x			lda 	XS_Type,x 					; if already integer, exit
.01a654	29 01		and #$01			and 	#1
.01a656	d0 31		bne $01a689			bne 	_FPUTOI_Exit
.01a658	34 85		bit $85,x			bit 	XS_Type,x					; if zero, return zero.
.01a65a	70 23		bvs $01a67f			bvs 	_FPUTOI_Zero
.01a65c	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.01a65e	10 1f		bpl $01a67f			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.01a660	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.01a662	b0 2b		bcs $01a68f			bcs 	FP_Overflow 				; can't cope with that as an integer.
.01a664					_FPUToIToInteger:
.01a664	b5 84		lda $84,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.01a666	c9 a0		cmp #$a0			cmp 	#128+32
.01a668	f0 0c		beq $01a676			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.01a66a	f6 84		inc $84,x			inc 	XS_Exponent,X 				; increment Exponent
.01a66c	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.01a66e	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a670	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a672	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a674	80 ee		bra $01a664			bra 	_FPUToIToInteger 			; keep going.
.01a676					_FPUToICheckSign:
.01a676	b5 85		lda $85,x			lda 	XS_Type,x 					; check sign
.01a678	10 0f		bpl $01a689			bpl 	_FPUToI_Exit 				; exit if unsigned.
.01a67a	20 e9 a5	jsr $01a5e9			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.01a67d	80 0a		bra $01a689			bra 	_FPUTOI_Exit
.01a67f					_FPUTOI_Zero:
.01a67f	a9 00		lda #$00			lda 	#0 							; return zero integer.
.01a681	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a683	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a685	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a687	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a689					_FPUToI_Exit:
.01a689	a9 01		lda #$01			lda 	#1 							; set type to integer
.01a68b	95 85		sta $85,x			sta 	XS_Type,x
.01a68d	68		pla				pla
.01a68e	60		rts				rts
.01a68f					FP_Overflow:
.01a68f	20 86 85	jsr $018586			jsr ERR_Handler
>01a692	46 6c 6f 61 74 69 6e 67			.text "Floating Point overflow",0
>01a69a	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.01a6aa					FPUTimes10:
.01a6aa	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.01a6ac	85 1c		sta $1c				sta 	ZLTemp1+0
.01a6ae	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a6b0	85 1d		sta $1d				sta 	ZLTemp1+1
.01a6b2	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a6b4	85 1e		sta $1e				sta 	ZLTemp1+2
.01a6b6	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a6b8	85 1f		sta $1f				sta 	ZLTemp1+3
.01a6ba	20 ef a6	jsr $01a6ef			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.01a6bd	20 ef a6	jsr $01a6ef			jsr 	_FPUT_LSR_ZLTemp1
.01a6c0	18		clc				clc
.01a6c1	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.01a6c3	65 1c		adc $1c				adc 	ZLTemp1+0
.01a6c5	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a6c7	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a6c9	65 1d		adc $1d				adc 	ZLTemp1+1
.01a6cb	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a6cd	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a6cf	65 1e		adc $1e				adc 	ZLTemp1+2
.01a6d1	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a6d3	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a6d5	65 1f		adc $1f				adc 	ZLTemp1+3
.01a6d7	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a6d9	90 0a		bcc $01a6e5			bcc 	_FPUTimes10
.01a6db	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.01a6dd	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a6df	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a6e1	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a6e3	f6 84		inc $84,x			inc 	XS_Exponent,x				; fix exponent
.01a6e5					_FPUTimes10:
.01a6e5	b5 84		lda $84,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.01a6e7	18		clc				clc
.01a6e8	69 03		adc #$03			adc 	#3
.01a6ea	95 84		sta $84,x			sta 	XS_Exponent,x
.01a6ec	b0 a1		bcs $01a68f			bcs 	FP_Overflow 				; error
.01a6ee	60		rts				rts
.01a6ef					_FPUT_LSR_ZLTemp1:
.01a6ef	46 1f		lsr $1f				lsr 	ZLTemp1+3
.01a6f1	66 1e		ror $1e				ror 	ZLTemp1+2
.01a6f3	66 1d		ror $1d				ror 	ZLTemp1+1
.01a6f5	66 1c		ror $1c				ror 	ZLTemp1+0
.01a6f7	60		rts				rts
.01a6f8					FPUScale10A:
.01a6f8	5a		phy				phy
.01a6f9	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.01a6fb	f0 37		beq $01a734			beq 	_FPUScaleExit
.01a6fd	da		phx				phx 								; save X
.01a6fe	e8		inx				inx
.01a6ff	e8		inx				inx
.01a700	e8		inx				inx
.01a701	e8		inx				inx
.01a702	e8		inx				inx
.01a703	e8		inx				inx
.01a704	a8		tay				tay 								; save power scalar in Y.
.01a705	a9 00		lda #$00			lda 	#0
.01a707	95 80		sta $80,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0 in float.
.01a709	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a70b	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a70d	95 85		sta $85,x			sta 	XS_Type,x
.01a70f	a9 80		lda #$80			lda 	#$80
.01a711	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a713	a9 81		lda #$81			lda 	#$81
.01a715	95 84		sta $84,x			sta 	XS_Exponent,x
.01a717	5a		phy				phy 								; save 10^n (e.g. the scalar) on stack.
.01a718	c0 00		cpy #$00			cpy 	#0
.01a71a	10 05		bpl $01a721			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.01a71c	98		tya				tya
.01a71d	49 ff		eor #$ff			eor 	#$FF
.01a71f	1a		inc a				inc 	a
.01a720	a8		tay				tay
.01a721					_FPUSAbs:
.01a721	20 aa a6	jsr $01a6aa			jsr 	FPUTimes10
.01a724	88		dey				dey
.01a725	d0 fa		bne $01a721			bne 	_FPUSAbs 					; tos is now 10^|AC|
.01a727	68		pla				pla 								; restore count in A
.01a728	fa		plx				plx 								; restore X pointing to number to scale.
.01a729	0a		asl a				asl 	a
.01a72a	b0 05		bcs $01a731			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.01a72c	20 4c a4	jsr $01a44c			jsr 	FPMultiply 					; if clear multiply.
.01a72f	80 03		bra $01a734			bra		_FPUScaleExit
.01a731					_FPUSDivide:
.01a731	20 d9 a3	jsr $01a3d9			jsr 	FPDivide
.01a734					_FPUScaleExit:
.01a734	7a		ply				ply
.01a735	60		rts				rts
.01a736					FPUCopyToNext:
.01a736	a0 06		ldy #$06			ldy 		#6
.01a738	da		phx				phx
.01a739					_FPUCopy1:
.01a739	b5 80		lda $80,x			lda 	XS_Mantissa,x
.01a73b	95 86		sta $86,x			sta 	XS2_Mantissa,x
.01a73d	e8		inx				inx
.01a73e	88		dey				dey
.01a73f	d0 f8		bne $01a739			bne 	_FPUCopy1
.01a741	fa		plx				plx
.01a742	60		rts				rts
.01a743					FPUCopyFromNext:
.01a743	a0 06		ldy #$06			ldy 		#6
.01a745	da		phx				phx
.01a746					_FPUCopy1:
.01a746	b5 86		lda $86,x			lda 	XS2_Mantissa,x
.01a748	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a74a	e8		inx				inx
.01a74b	88		dey				dey
.01a74c	d0 f8		bne $01a746			bne 	_FPUCopy1
.01a74e	fa		plx				plx
.01a74f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.01a750					FPToString:
.01a750	48		pha				pha
.01a751	5a		phy				phy
.01a752	34 85		bit $85,x			bit 		XS_Type,x 				; check zero flag
.01a754	50 0a		bvc $01a760			bvc 		_FPTSIsFloat 			; if zero,
.01a756					_FPTSZero:
.01a756	a9 30		lda #$30			lda 		#"0"
.01a758	20 88 a2	jsr $01a288			jsr 		ITSOutputCharacter
.01a75b					_FPTSExit:
.01a75b	7a		ply				ply
.01a75c	68		pla				pla
.01a75d	60		rts				rts
.01a75e	80 fb		bra $01a75b			bra 		_FPTSExit
.01a760					_FPTSIsFloat:
.01a760	b5 85		lda $85,x			lda 		XS_Type,x 				; is it signed ?
.01a762	10 09		bpl $01a76d			bpl 		_FPTSNotSigned
.01a764	a9 00		lda #$00			lda 		#0 						; clear sign flag
.01a766	95 85		sta $85,x			sta 		XS_Type,x
.01a768	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.01a76a	20 88 a2	jsr $01a288			jsr 		ITSOutputCharacter
.01a76d					_FPTSNotSigned:
.01a76d	b5 84		lda $84,x			lda 		XS_Exponent,x
.01a76f	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.01a771	b0 09		bcs $01a77c			bcs 		_FPTSExponent
.01a773	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.01a775	90 05		bcc $01a77c			bcc 		_FPTSExponent 			;
.01a777					_FPTSStandard:
.01a777	20 bb a7	jsr $01a7bb			jsr 		FPTOutputBody 			; output the body.
.01a77a	80 df		bra $01a75b			bra 		_FPTSExit
.01a77c					_FPTSExponent:
.01a77c	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.01a77e	8d 9d 03	sta $039d			sta 		ExpCount
.01a781					_FPTSExponentLoop:
.01a781	b5 84		lda $84,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.01a783	10 0e		bpl $01a793			bpl 		_FPTSTimes
.01a785	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.01a787	90 14		bcc $01a79d			bcc 		_FPTSScaledToExp
.01a789	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.01a78b	20 f8 a6	jsr $01a6f8			jsr 		FPUScale10A
.01a78e	ee 9d 03	inc $039d			inc 		ExpCount
.01a791	80 ee		bra $01a781			bra 		_FPTSExponentLoop
.01a793					_FPTSTimes:
.01a793	a9 01		lda #$01			lda 		#1
.01a795	20 f8 a6	jsr $01a6f8			jsr 		FPUScale10A
.01a798	ce 9d 03	dec $039d			dec 		ExpCount
.01a79b	80 e4		bra $01a781			bra 		_FPTSExponentLoop
.01a79d					_FPTSScaledToExp:
.01a79d	20 bb a7	jsr $01a7bb			jsr 		FPTOutputBody 			; output the body.
.01a7a0	a9 65		lda #$65			lda 		#"e"					; output E
.01a7a2	20 88 a2	jsr $01a288			jsr 		ITSOutputCharacter
.01a7a5	ad 9d 03	lda $039d			lda 		ExpCount 				; get the exponent
.01a7a8	95 80		sta $80,x			sta 		XS_Mantissa,x
.01a7aa	29 80		and #$80			and 		#$80 					; sign extend it
.01a7ac	f0 02		beq $01a7b0			beq 		_FPTSSExt
.01a7ae	a9 ff		lda #$ff			lda 		#$FF
.01a7b0					_FPTSSExt:
.01a7b0	95 81		sta $81,x			sta 		XS_Mantissa+1,x
.01a7b2	95 82		sta $82,x			sta 		XS_Mantissa+2,x
.01a7b4	95 83		sta $83,x			sta 		XS_Mantissa+3,x
.01a7b6	20 e6 a1	jsr $01a1e6			jsr 		INTToString 			; output the exponent.
.01a7b9	80 a0		bra $01a75b			bra			_FPTSExit 				; and exit.
.01a7bb					FPTOutputBody:
.01a7bb	20 36 a7	jsr $01a736			jsr 		FPUCopyToNext 			; copy to next slot.
.01a7be	20 51 a6	jsr $01a651			jsr 		FPUToInteger 			; convert to an integer
.01a7c1	20 e6 a1	jsr $01a1e6			jsr 		INTToString 			; output the main integer part.
.01a7c4	20 43 a7	jsr $01a743			jsr 		FPUCopyFromNext 		; get the fractional part back.
.01a7c7	20 d4 a4	jsr $01a4d4			jsr 		FPFractionalPart 		; get the decimal part.
.01a7ca	34 85		bit $85,x			bit 		XS_Type,x 				; any fractional part.
.01a7cc	70 3c		bvs $01a80a			bvs 		_FPTOExit 				; if not, exit now.
.01a7ce	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.01a7d0	20 88 a2	jsr $01a288			jsr 		ITSOutputCharacter
.01a7d3					_FPOutLoop:
.01a7d3	34 85		bit $85,x			bit 		XS_Type,x 				; finally reached zero.
.01a7d5	70 1d		bvs $01a7f4			bvs 		_FPStripZeros 			; strip trailing zeros
.01a7d7	20 aa a6	jsr $01a6aa			jsr 		FPUTimes10 				; multiply by 10
.01a7da	20 36 a7	jsr $01a736			jsr 		FPUCopyToNext			; copy to next slot.
.01a7dd	20 51 a6	jsr $01a651			jsr 		FPUToInteger 			; convert to integer
.01a7e0	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; print digit.
.01a7e2	09 30		ora #$30			ora 		#"0"
.01a7e4	20 88 a2	jsr $01a288			jsr 		ITSOutputCharacter
.01a7e7	20 43 a7	jsr $01a743			jsr 		FPUCopyFromNext 		; get it back
.01a7ea	20 d4 a4	jsr $01a4d4			jsr 		FPFractionalPart 		; get fractional part
.01a7ed	ad 14 03	lda $0314			lda 		NumBufX 				; done 11 characters yet ?
.01a7f0	c9 0b		cmp #$0b			cmp 	 	#11
.01a7f2	90 df		bcc $01a7d3			bcc 		_FPOutLoop 				; if so, keep going till zero.
.01a7f4					_FPStripZeros:
.01a7f4	ac 14 03	ldy $0314			ldy 		NumBufX 				; strip trailing zeros.
.01a7f7					_FPStripLoop:
.01a7f7	88		dey				dey 								; back one, if at start then no strip
.01a7f8	f0 10		beq $01a80a			beq 		_FPToExit
.01a7fa	b9 15 03	lda $0315,y			lda 		Num_Buffer,y 			; keep going if "0"
.01a7fd	c9 30		cmp #$30			cmp 		#"0"
.01a7ff	f0 f6		beq $01a7f7			beq 		_FPStripLoop
.01a801	c8		iny				iny
.01a802	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.01a804	99 15 03	sta $0315,y			sta 		Num_Buffer,y
.01a807	8c 14 03	sty $0314			sty 		NumBufX 				; update position.
.01a80a					_FPTOExit:
.01a80a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.01a80b					FPFromString:
.01a80b	48		pha				pha 								; push A
.01a80c	b1 20		lda ($20),y			lda		(zGenPtr),y					; is it followed by a DP ?
.01a80e	c9 2e		cmp #$2e			cmp 	#"."
.01a810	f0 03		beq $01a815			beq	 	_FPFIsDecimal
.01a812	4c 71 a8	jmp $01a871			jmp 	_FPFNotDecimal
.01a815					_FPFIsDecimal:
.01a815	c8		iny				iny 								; consume the decimal.
.01a816	20 05 a6	jsr $01a605			jsr 	FPUToFloat 					; convert the integer to float.
.01a819	da		phx				phx 								; save X.
.01a81a	5a		phy				phy 								; save decimal start position
.01a81b	e8		inx				inx
.01a81c	e8		inx				inx
.01a81d	e8		inx				inx
.01a81e	e8		inx				inx
.01a81f	e8		inx				inx
.01a820	e8		inx				inx
.01a821	20 9d a2	jsr $01a29d			jsr 	INTFromStringY 				; get the part after the DP.
.01a824	20 05 a6	jsr $01a605			jsr 	FPUToFloat 					; convert that to a float.
.01a827	68		pla				pla 								; calculate - chars consumed.
.01a828	8c 9c 03	sty $039c			sty 	ExpTemp
.01a82b	38		sec				sec
.01a82c	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; this is the shift amount
.01a82f	20 f8 a6	jsr $01a6f8			jsr 	FPUScale10A 				; scale it by 10^AC
.01a832	fa		plx				plx 								; restore original X
.01a833	20 35 a3	jsr $01a335			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.01a836	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; exponent ?
.01a838	c9 45		cmp #$45			cmp 	#"E"
.01a83a	f0 04		beq $01a840			beq 	_FPFExponent
.01a83c	c9 65		cmp #$65			cmp 	#"e"
.01a83e	d0 31		bne $01a871			bne 	_FPFNotDecimal 				; no, then exit normally.
.01a840					_FPFExponent:
.01a840	c8		iny				iny 								; skip over E symbol.
.01a841	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; look at next
.01a843	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.01a845	d0 01		bne $01a848			bne 	_FPFGotSign
.01a847	c8		iny				iny 								; if it was - skip over it.
.01a848					_FPFGotSign:
.01a848	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.01a849	da		phx				phx
.01a84a	e8		inx				inx
.01a84b	e8		inx				inx
.01a84c	e8		inx				inx
.01a84d	e8		inx				inx
.01a84e	e8		inx				inx
.01a84f	e8		inx				inx
.01a850	20 9d a2	jsr $01a29d			jsr 	INTFromStringY 				; get the exponent
.01a853	fa		plx				plx 								; restore X.
.01a854	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.01a856	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.01a858	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.01a85a	d0 17		bne $01a873			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.01a85c	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.01a85e	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.01a860	b0 11		bcs $01a873			bcs 	_FPFXOverflow
.01a862	68		pla				pla 								; get direction
.01a863	d0 07		bne $01a86c			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.01a865	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.01a867	49 ff		eor #$ff			eor 	#$FF
.01a869	1a		inc a				inc 	a
.01a86a	95 86		sta $86,x			sta 	XS2_Mantissa+0,x
.01a86c					_FPFXScale:
.01a86c	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.01a86e	20 f8 a6	jsr $01a6f8			jsr 	FPUScale10A 				; scale by the exponent.
.01a871					_FPFNotDecimal:
.01a871	68		pla				pla
.01a872	60		rts				rts
.01a873					_FPFXOverflow:
.01a873	20 86 85	jsr $018586			jsr 	ERR_Handler
>01a876	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>01a87e	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.01a885					Unary_Rnd:
.01a885	20 e4 93	jsr $0193e4			jsr 	EvaluateNumberX 			; get value
.01a888	20 3f 9a	jsr $019a3f			jsr 	CheckNextRParen 			; check right bracket.
.01a88b	20 5a 96	jsr $01965a			jsr 	GetSignCurrent 				; get sign -1,0,1.
.01a88e	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.01a890	30 10		bmi $01a8a2			bmi 	_URSetSeed
.01a892	f0 28		beq $01a8bc			beq 	_URMakeRandom 				; if zero return same number, don't advance sequence
.01a894	da		phx				phx
.01a895	a2 00		ldx #$00			ldx 	#0 							; run 16 bit RNG procession on upper/lower
.01a897	20 f3 a8	jsr $01a8f3			jsr 	Random16
.01a89a	a2 02		ldx #$02			ldx 	#2
.01a89c	20 f3 a8	jsr $01a8f3			jsr 	Random16
.01a89f	fa		plx				plx
.01a8a0	80 1a		bra $01a8bc			bra 	_URMakeRandom
.01a8a2					_URSetSeed:
.01a8a2	20 05 a6	jsr $01a605			jsr 	FPUToFloat 					; make it a float to twiddle it.
.01a8a5	b5 80		lda $80,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.01a8a7	8d a3 03	sta $03a3			sta 	RandomSeed+0
.01a8aa	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.01a8ac	8d a4 03	sta $03a4			sta 	RandomSeed+1
.01a8af	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.01a8b1	8d a5 03	sta $03a5			sta 	RandomSeed+2
.01a8b4	b5 83		lda $83,x			lda		XS_Mantissa+3,x 			; this is to make the seed bear not much
.01a8b6	0a		asl a				asl 	a 							; resemblance to the seed value.
.01a8b7	49 db		eor #$db			eor 	#$DB
.01a8b9	8d a6 03	sta $03a6			sta 	RandomSeed+3
.01a8bc					_URMakeRandom:
.01a8bc	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; check if seed is zero.
.01a8bf	0d a4 03	ora $03a4			ora 	RandomSeed+1
.01a8c2	0d a5 03	ora $03a5			ora 	RandomSeed+2
.01a8c5	0d a6 03	ora $03a6			ora 	RandomSeed+3
.01a8c8	d0 0a		bne $01a8d4			bne 	_URNotZero
.01a8ca	a9 47		lda #$47			lda 	#$47						; if it is, make it non zero.
.01a8cc	8d a4 03	sta $03a4			sta 	RandomSeed+1				; in both parts.
.01a8cf	a9 3d		lda #$3d			lda 	#$3D
.01a8d1	8d a6 03	sta $03a6			sta 	RandomSeed+3
.01a8d4					_URNotZero:
.01a8d4	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; copy seed into mantissa.
.01a8d7	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a8d9	ad a4 03	lda $03a4			lda 	RandomSeed+1
.01a8dc	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a8de	ad a5 03	lda $03a5			lda 	RandomSeed+2
.01a8e1	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a8e3	ad a6 03	lda $03a6			lda 	RandomSeed+3
.01a8e6	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a8e8	a9 00		lda #$00			lda 	#$00 						; set type to float.
.01a8ea	95 85		sta $85,x			sta 	XS_Type,x
.01a8ec	a9 80		lda #$80			lda 	#$80
.01a8ee	95 84		sta $84,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.01a8f0	4c 32 a6	jmp $01a632			jmp 	FPUNormalise 				; and normalise.
.01a8f3					Random16:
.01a8f3	5e a4 03	lsr $03a4,x			lsr 	RandomSeed+1,x				; shift seed right
.01a8f6	7e a3 03	ror $03a3,x			ror 	RandomSeed,x
.01a8f9	90 08		bcc $01a903			bcc 	_R16_NoXor
.01a8fb	bd a4 03	lda $03a4,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.01a8fe	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.01a900	9d a4 03	sta $03a4,x			sta 	RandomSeed+1,x
.01a903					_R16_NoXor:
.01a903	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.01a904					Unary_Int:
.01a904	20 e4 93	jsr $0193e4			jsr 	EvaluateNumberX 			; get value
.01a907	20 3f 9a	jsr $019a3f			jsr 	CheckNextRParen 			; check right bracket.
.01a90a	4c 51 a6	jmp $01a651			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Return to file: basic.asm

>01a90d	02						.byte 	2
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 c0						.word 	StartROM 					; Reset vector
>fffe	19 c0					.word TIM_BreakHandler

;******  End of listing
