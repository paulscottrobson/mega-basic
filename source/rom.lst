
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Wed Aug 28 15:11:57 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="65816"				cpu = "65816"
="em65816"				hardware = "em65816"
=1					exitonend = 1
=1					autorun = 1
=2					loadtest = 2
=1					hasfloat = 1
=1					hasinteger = 1
=253					maxstring = 253

;******  Processing file: modules/float/fpmacros.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/em65816/src_em65816.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0020					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0022					zVarDataPtr: .word ? 						; position of variable data.
>0024					zVarType: 	.byte ? 						; type of data (token)
>0025					zNullString:.byte ? 						; represents a NULL string.
>0080					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>0084					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>0085					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=134					XS2_Mantissa = XS_Mantissa+XS_Size
=138					XS2_Exponent = XS_Exponent+XS_Size
=139					XS2_Type = XS_Type+XS_Size
=140					XS3_Mantissa = XS_Mantissa+XS_Size*2
=144					XS3_Exponent = XS_Exponent+XS_Size*2
=145					XS3_Type = XS_Type+XS_Size*2
>0300					StringPtr:	.word ? 						; Top of free memory (for string allocation)
>0302					VarMemPtr: 	.word ?							; Bottom of free memory (for variables)
>0304					endOfProgram: .word ? 						; End of Program Memory.
>0306					UserVector .fill 4 							; USR(x) calls this.
>030a					LocalVector .fill 4 						; Indirect calls call this.
>030e					NumBufX 	.byte 	?						; buffer index position
>030f					Num_Buffer	.fill 	32 						; buffer for numeric conversions
=6					HashTableCount = 6 							; there are 6 hash tables, in token order.
=8					HashTableSize = 8 							; each hash table as 8 links.
.032f					HashTableBase:
>032f								.fill	HashTableCount * HashTableSize * 2
.038f					HashTableEnd:
=$30f					Var_Buffer 	= Num_Buffer 					; buffer for variable name (same space)
>038f					Var_Type    .byte ? 						; type of variable (as a type token)
>0390					Var_Hash 	.byte ? 						; hash of identifier name.
>0391					Var_Length 	.byte ? 						; length of variable name
>0392					Var_HashAddress .byte ?						; low byte of hash table entry.
>0393					Var_DataSize .byte ?						; size of one element.
>0394					NumSuppress	.byte 	?						; leading zero suppression flag
>0395					NumConvCount .byte 	? 						; count for conversions.
>0396					ExpTemp:	.byte ?							; Working temp for exponents.
>0397					ExpCount:	.byte ? 						; Count of decimal exponents.
>0398					SignCount:	.byte ?							; Integer Divide Sign Counts.
>0399					TempStringWriteIndex: .byte ? 				; Write offset.
>039a					ValSign: 	.byte ? 						; sign flag for val()
>039b					SliceStart:	.byte ? 						; string slice parts
>039c					SliceCount:	.byte ?
>039d					RandomSeed:	.dword ? 						; Random seed.
=3					ArrayMaxDim = 3 							; number of dimensions.
>03a1					ArrayDef:	.fill (ArrayMaxDim+1)*2 		; dimensions for auto-creation
>03a9					UsrArrayDef:.fill (ArrayMaxDim+1)*2 		; dimensions created in DIM
>03b1					UsrArrayIdx:.byte ? 						; index into UsrArrayDef
>03b2					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>03b4					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>03b6					Tim_SR:		.byte ? 						; Processor Status
>03b7					Tim_A:		.byte ? 						; Processor Registers
>03b8					Tim_X:		.byte ?
>03b9					Tim_Y:		.byte ?
>03ba					Tim_Z:		.byte ?
>03bb					Tim_SP:		.word ?							; Stack Pointer (just in cases)
>03bd					IFT_XCursor:.byte ?							; current logical position on screen
>03be					IFT_YCursor:.byte ?
>03bf					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0423					IFT_LineBuffer: .fill 100 					; line input buffer.

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/em65816.asm

=$8000					HighMemory = $8000
=0					VariableMemory = 0							; i.e. put it after BASIC code.
.1000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testassign.src

>1000	0b 02 00 c7 0c bd 41 bf			.byte	$0b,$02,$00,$c7,$0c,$bd,$41,$bf
>1008	41 be 00 0b 03 00 c7 01			.byte	$41,$be,$00,$0b,$03,$00,$c7,$01
>1010	b8 41 bf 42 be 00 0d 04			.byte	$b8,$41,$bf,$42,$be,$00,$0d,$04
>1018	00 c7 0e 30 10 06 08 bc			.byte	$00,$c7,$0e,$30,$10,$06,$08,$bc
>1020	41 be 00 0b 05 00 c7 14			.byte	$41,$be,$00,$0b,$05,$00,$c7,$14
>1028	38 0d bc 41 be 00 0d 06			.byte	$38,$0d,$bc,$41,$be,$00,$0d,$06
>1030	00 c7 19 38 06 b8 42 bf			.byte	$00,$c7,$19,$38,$06,$b8,$42,$bf
>1038	41 be 00 0c 07 00 c7 19			.byte	$41,$be,$00,$0c,$07,$00,$c7,$19
>1040	33 03 13 bc 41 be 00 0b			.byte	$33,$03,$13,$bc,$41,$be,$00,$0b
>1048	08 00 c7 17 34 11 bd 41			.byte	$08,$00,$c7,$17,$34,$11,$bd,$41
>1050	be 00 0b 09 00 c7 12 36			.byte	$be,$00,$0b,$09,$00,$c7,$12,$36
>1058	0a bc 42 be 00 0f 0a 00			.byte	$0a,$bc,$42,$be,$00,$0f,$0a,$00
>1060	c7 18 37 15 09 0b bc 42			.byte	$c7,$18,$37,$15,$09,$0b,$bc,$42
>1068	bf 41 be 00 0e 0b 00 c7			.byte	$bf,$41,$be,$00,$0e,$0b,$00,$c7
>1070	0e 39 15 17 b8 42 bf 42			.byte	$0e,$39,$15,$17,$b8,$42,$bf,$42
>1078	be 00 0d 0c 00 c7 03 33			.byte	$be,$00,$0d,$0c,$00,$c7,$03,$33
>1080	0d 02 07 bc 41 be 00 0d			.byte	$0d,$02,$07,$bc,$41,$be,$00,$0d
>1088	0d 00 c7 1a 34 07 0c 0d			.byte	$0d,$00,$c7,$1a,$34,$07,$0c,$0d
>1090	ba 42 be 00 13 0e 00 cf			.byte	$ba,$42,$be,$00,$13,$0e,$00,$cf
>1098	0d 32 0c 05 b9 84 44 51			.byte	$0d,$32,$0c,$05,$b9,$84,$44,$51
>10a0	fd 06 39 33 37 35 00 11			.byte	$fd,$06,$39,$33,$37,$35,$00,$11
>10a8	0f 00 cf 14 39 17 84 44			.byte	$0f,$00,$cf,$14,$39,$17,$84,$44
>10b0	7f fd 06 33 31 32 35 00			.byte	$7f,$fd,$06,$33,$31,$32,$35,$00
>10b8	0c 10 00 cf 10 39 05 bb			.byte	$0c,$10,$00,$cf,$10,$39,$05,$bb
>10c0	84 42 40 00 0b 11 00 cf			.byte	$84,$42,$40,$00,$0b,$11,$00,$cf
>10c8	03 bb 84 8b 4b 67 00 0c			.byte	$03,$bb,$84,$8b,$4b,$67,$00,$0c
>10d0	12 00 cf 0b 37 16 bb 84			.byte	$12,$00,$cf,$0b,$37,$16,$bb,$84
>10d8	44 6d 00 0e 13 00 cf 19			.byte	$44,$6d,$00,$0e,$13,$00,$cf,$19
>10e0	33 03 13 bc 41 be 84 73			.byte	$33,$03,$13,$bc,$41,$be,$84,$73
>10e8	00 0c 14 00 cf 0a 35 18			.byte	$00,$0c,$14,$00,$cf,$0a,$35,$18
>10f0	b7 84 fe 02 00 13 15 00			.byte	$b7,$84,$fe,$02,$00,$13,$15,$00
>10f8	cf 1a 33 11 0a 19 84 48			.byte	$cf,$1a,$33,$11,$0a,$19,$84,$48
>1100	64 fd 06 33 31 32 35 00			.byte	$64,$fd,$06,$33,$31,$32,$35,$00
>1108	13 16 00 cf 17 34 11 bd			.byte	$13,$16,$00,$cf,$17,$34,$11,$bd
>1110	41 be 84 8b 43 54 fd 04			.byte	$41,$be,$84,$8b,$43,$54,$fd,$04
>1118	32 35 00 12 17 00 cf 17			.byte	$32,$35,$00,$12,$17,$00,$cf,$17
>1120	32 19 09 84 47 78 fd 06			.byte	$32,$19,$09,$84,$47,$78,$fd,$06
>1128	31 38 37 35 00 0e 18 00			.byte	$31,$38,$37,$35,$00,$0e,$18,$00
>1130	cf 12 36 0a bc 42 be 84			.byte	$cf,$12,$36,$0a,$bc,$42,$be,$84
>1138	4f 44 00 13 19 00 cf 0f			.byte	$4f,$44,$00,$13,$19,$00,$cf,$0f
>1140	35 0e 13 b9 84 8b 47 63			.byte	$35,$0e,$13,$b9,$84,$8b,$47,$63
>1148	fd 05 36 32 35 00 11 1a			.byte	$fd,$05,$36,$32,$35,$00,$11,$1a
>1150	00 cf 05 33 06 84 41 6a			.byte	$00,$cf,$05,$33,$06,$84,$41,$6a
>1158	fd 06 33 31 32 35 00 10			.byte	$fd,$06,$33,$31,$32,$35,$00,$10
>1160	1b 00 cf 17 b9 84 44 70			.byte	$1b,$00,$cf,$17,$b9,$84,$44,$70
>1168	fd 06 38 31 32 35 00 10			.byte	$fd,$06,$38,$31,$32,$35,$00,$10
>1170	1c 00 cf 19 34 1a b7 84			.byte	$1c,$00,$cf,$19,$34,$1a,$b7,$84
>1178	fe 06 47 38 45 53 00 10			.byte	$fe,$06,$47,$38,$45,$53,$00,$10
>1180	1d 00 cf 01 36 01 03 b7			.byte	$1d,$00,$cf,$01,$36,$01,$03,$b7
>1188	84 fe 05 42 30 57 00 11			.byte	$84,$fe,$05,$42,$30,$57,$00,$11
>1190	1e 00 cf 1a 37 02 84 8b			.byte	$1e,$00,$cf,$1a,$37,$02,$84,$8b
>1198	43 77 fd 05 36 32 35 00			.byte	$43,$77,$fd,$05,$36,$32,$35,$00
>11a0	0f 1f 00 cf 05 84 44 5e			.byte	$0f,$1f,$00,$cf,$05,$84,$44,$5e
>11a8	fd 06 36 38 37 35 00 0e			.byte	$fd,$06,$36,$38,$37,$35,$00,$0e
>11b0	20 00 cf 0f 84 59 fd 06			.byte	$20,$00,$cf,$0f,$84,$59,$fd,$06
>11b8	31 38 37 35 00 14 21 00			.byte	$31,$38,$37,$35,$00,$14,$21,$00
>11c0	cf 0e 37 1a 03 0f b9 84			.byte	$cf,$0e,$37,$1a,$03,$0f,$b9,$84
>11c8	42 7e fd 06 33 31 32 35			.byte	$42,$7e,$fd,$06,$33,$31,$32,$35
>11d0	00 10 22 00 cf 08 35 02			.byte	$00,$10,$22,$00,$cf,$08,$35,$02
>11d8	84 46 42 fd 05 38 37 35			.byte	$84,$46,$42,$fd,$05,$38,$37,$35
>11e0	00 12 23 00 cf 16 32 1a			.byte	$00,$12,$23,$00,$cf,$16,$32,$1a
>11e8	0a 0e 84 6f fd 06 34 33			.byte	$0a,$0e,$84,$6f,$fd,$06,$34,$33
>11f0	37 35 00 0d 24 00 cf 13			.byte	$37,$35,$00,$0d,$24,$00,$cf,$13
>11f8	84 8b 44 7d fd 03 30 00			.byte	$84,$8b,$44,$7d,$fd,$03,$30,$00
>1200	0f 25 00 cf 13 84 46 40			.byte	$0f,$25,$00,$cf,$13,$84,$46,$40
>1208	fd 06 39 33 37 35 00 0e			.byte	$fd,$06,$39,$33,$37,$35,$00,$0e
>1210	26 00 cf 05 32 11 0c 12			.byte	$26,$00,$cf,$05,$32,$11,$0c,$12
>1218	bb 84 41 76 00 12 27 00			.byte	$bb,$84,$41,$76,$00,$12,$27,$00
>1220	cf 12 32 05 08 03 b7 84			.byte	$cf,$12,$32,$05,$08,$03,$b7,$84
>1228	fe 06 4c 31 55 58 00 12			.byte	$fe,$06,$4c,$31,$55,$58,$00,$12
>1230	28 00 cf 07 36 07 0a 84			.byte	$28,$00,$cf,$07,$36,$07,$0a,$84
>1238	41 64 fd 06 36 38 37 35			.byte	$41,$64,$fd,$06,$36,$38,$37,$35
>1240	00 0e 29 00 cf 12 36 0a			.byte	$00,$0e,$29,$00,$cf,$12,$36,$0a
>1248	bc 41 be 84 45 46 00 12			.byte	$bc,$41,$be,$84,$45,$46,$00,$12
>1250	2a 00 cf 01 36 01 03 b7			.byte	$2a,$00,$cf,$01,$36,$01,$03,$b7
>1258	84 fe 07 45 33 42 51 54			.byte	$84,$fe,$07,$45,$33,$42,$51,$54
>1260	00 13 2b 00 cf 12 32 05			.byte	$00,$13,$2b,$00,$cf,$12,$32,$05
>1268	08 03 b7 84 fe 07 4e 37			.byte	$08,$03,$b7,$84,$fe,$07,$4e,$37
>1270	43 47 4f 00 0e 2c 00 cf			.byte	$43,$47,$4f,$00,$0e,$2c,$00,$cf
>1278	1a 36 0a 08 13 bb 84 42			.byte	$1a,$36,$0a,$08,$13,$bb,$84,$42
>1280	5a 00 12 2d 00 cf 0e 38			.byte	$5a,$00,$12,$2d,$00,$cf,$0e,$38
>1288	04 05 06 b9 84 44 5f fd			.byte	$04,$05,$06,$b9,$84,$44,$5f,$fd
>1290	04 37 35 00 11 2e 00 cf			.byte	$04,$37,$35,$00,$11,$2e,$00,$cf
>1298	1a 37 18 1a b9 84 48 7e			.byte	$1a,$37,$18,$1a,$b9,$84,$48,$7e
>12a0	fd 04 32 35 00 0d 2f 00			.byte	$fd,$04,$32,$35,$00,$0d,$2f,$00
>12a8	cf 02 34 16 0f bb 84 4c			.byte	$cf,$02,$34,$16,$0f,$bb,$84,$4c
>12b0	73 00 0c 30 00 cf 19 34			.byte	$73,$00,$0c,$30,$00,$cf,$19,$34
>12b8	1a b7 84 fe 02 00 15 31			.byte	$1a,$b7,$84,$fe,$02,$00,$15,$31
>12c0	00 cf 0b 35 0f 14 04 b9			.byte	$00,$cf,$0b,$35,$0f,$14,$04,$b9
>12c8	84 8b 46 7b fd 06 36 38			.byte	$84,$8b,$46,$7b,$fd,$06,$36,$38
>12d0	37 35 00 0e 32 00 cf 03			.byte	$37,$35,$00,$0e,$32,$00,$cf,$03
>12d8	32 0f b7 84 fe 04 49 38			.byte	$32,$0f,$b7,$84,$fe,$04,$49,$38
>12e0	00 12 33 00 cf 16 32 1a			.byte	$00,$12,$33,$00,$cf,$16,$32,$1a
>12e8	0a 0e 84 47 44 fd 05 31			.byte	$0a,$0e,$84,$47,$44,$fd,$05,$31
>12f0	32 35 00 10 34 00 cf 14			.byte	$32,$35,$00,$10,$34,$00,$cf,$14
>12f8	31 02 04 15 84 42 55 fd			.byte	$31,$02,$04,$15,$84,$42,$55,$fd
>1300	03 35 00 12 35 00 cf 03			.byte	$03,$35,$00,$12,$35,$00,$cf,$03
>1308	32 19 11 b9 84 49 68 fd			.byte	$32,$19,$11,$b9,$84,$49,$68,$fd
>1310	05 33 37 35 00 11 36 00			.byte	$05,$33,$37,$35,$00,$11,$36,$00
>1318	cf 09 34 03 b9 84 47 68			.byte	$cf,$09,$34,$03,$b9,$84,$47,$68
>1320	fd 05 33 37 35 00 0e 37			.byte	$fd,$05,$33,$37,$35,$00,$0e,$37
>1328	00 cf 0f 84 8b 45 42 fd			.byte	$00,$cf,$0f,$84,$8b,$45,$42,$fd
>1330	04 37 35 00 13 38 00 cf			.byte	$04,$37,$35,$00,$13,$38,$00,$cf
>1338	01 38 19 13 0d 84 46 57			.byte	$01,$38,$19,$13,$0d,$84,$46,$57
>1340	fd 06 34 33 37 35 00 10			.byte	$fd,$06,$34,$33,$37,$35,$00,$10
>1348	39 00 cf 0d b9 84 8b 45			.byte	$39,$00,$cf,$0d,$b9,$84,$8b,$45
>1350	73 fd 05 31 32 35 00 12			.byte	$73,$fd,$05,$31,$32,$35,$00,$12
>1358	3a 00 cf 0d 30 0d 09 b7			.byte	$3a,$00,$cf,$0d,$30,$0d,$09,$b7
>1360	84 fe 07 50 37 53 41 59			.byte	$84,$fe,$07,$50,$37,$53,$41,$59
>1368	00 11 3b 00 cf 14 39 17			.byte	$00,$11,$3b,$00,$cf,$14,$39,$17
>1370	84 8b 47 7b fd 05 31 32			.byte	$84,$8b,$47,$7b,$fd,$05,$31,$32
>1378	35 00 0c 3c 00 cf 0b 37			.byte	$35,$00,$0c,$3c,$00,$cf,$0b,$37
>1380	16 bb 84 47 53 00 12 3d			.byte	$16,$bb,$84,$47,$53,$00,$12,$3d
>1388	00 cf 07 36 07 0a 84 45			.byte	$00,$cf,$07,$36,$07,$0a,$84,$45
>1390	4e fd 06 34 33 37 35 00			.byte	$4e,$fd,$06,$34,$33,$37,$35,$00
>1398	15 3e 00 cf 0c bd 41 bf			.byte	$15,$3e,$00,$cf,$0c,$bd,$41,$bf
>13a0	41 be 84 8b 44 4b fd 06			.byte	$41,$be,$84,$8b,$44,$4b,$fd,$06
>13a8	38 31 32 35 00 0f 3f 00			.byte	$38,$31,$32,$35,$00,$0f,$3f,$00
>13b0	cf 07 36 07 0a 84 48 66			.byte	$cf,$07,$36,$07,$0a,$84,$48,$66
>13b8	fd 03 30 00 0e 40 00 cf			.byte	$fd,$03,$30,$00,$0e,$40,$00,$cf
>13c0	0b 84 51 fd 06 35 36 32			.byte	$0b,$84,$51,$fd,$06,$35,$36,$32
>13c8	35 00 12 41 00 cf 12 33			.byte	$35,$00,$12,$41,$00,$cf,$12,$33
>13d0	06 09 12 b9 84 8b 45 4e			.byte	$06,$09,$12,$b9,$84,$8b,$45,$4e
>13d8	fd 03 30 00 11 42 00 cf			.byte	$fd,$03,$30,$00,$11,$42,$00,$cf
>13e0	16 32 1a 0a 0e 84 8b 46			.byte	$16,$32,$1a,$0a,$0e,$84,$8b,$46
>13e8	49 fd 03 35 00 11 43 00			.byte	$49,$fd,$03,$35,$00,$11,$43,$00
>13f0	cf 0d 37 06 11 15 b7 84			.byte	$cf,$0d,$37,$06,$11,$15,$b7,$84
>13f8	fe 05 51 31 55 00 11 44			.byte	$fe,$05,$51,$31,$55,$00,$11,$44
>1400	00 cf 19 38 06 b8 40 bf			.byte	$00,$cf,$19,$38,$06,$b8,$40,$bf
>1408	40 be 84 fe 03 49 00 12			.byte	$40,$be,$84,$fe,$03,$49,$00,$12
>1410	45 00 cf 01 33 16 84 8b			.byte	$45,$00,$cf,$01,$33,$16,$84,$8b
>1418	47 55 fd 06 30 36 32 35			.byte	$47,$55,$fd,$06,$30,$36,$32,$35
>1420	00 0e 46 00 cf 08 36 0d			.byte	$00,$0e,$46,$00,$cf,$08,$36,$0d
>1428	11 12 bb 84 4b 5e 00 0f			.byte	$11,$12,$bb,$84,$4b,$5e,$00,$0f
>1430	47 00 cf 0b 84 45 69 fd			.byte	$47,$00,$cf,$0b,$84,$45,$69,$fd
>1438	06 36 38 37 35 00 10 48			.byte	$06,$36,$38,$37,$35,$00,$10,$48
>1440	00 cf 02 31 03 0f 84 47			.byte	$00,$cf,$02,$31,$03,$0f,$84,$47
>1448	77 fd 04 37 35 00 11 49			.byte	$77,$fd,$04,$37,$35,$00,$11,$49
>1450	00 cf 19 34 07 b9 84 41			.byte	$00,$cf,$19,$34,$07,$b9,$84,$41
>1458	7b fd 05 38 37 35 00 0d			.byte	$7b,$fd,$05,$38,$37,$35,$00,$0d
>1460	4a 00 cf 14 39 0a 0d bb			.byte	$4a,$00,$cf,$14,$39,$0a,$0d,$bb
>1468	84 49 53 00 0d 4b 00 cf			.byte	$84,$49,$53,$00,$0d,$4b,$00,$cf
>1470	1a b7 84 fe 05 52 35 4f			.byte	$1a,$b7,$84,$fe,$05,$52,$35,$4f
>1478	00 13 4c 00 cf 0b 35 0f			.byte	$00,$13,$4c,$00,$cf,$0b,$35,$0f
>1480	14 04 b9 84 42 67 fd 05			.byte	$14,$04,$b9,$84,$42,$67,$fd,$05
>1488	38 37 35 00 0f 4d 00 cf			.byte	$38,$37,$35,$00,$0f,$4d,$00,$cf
>1490	0e b7 84 fe 07 55 34 53			.byte	$0e,$b7,$84,$fe,$07,$55,$34,$53
>1498	58 49 00 12 4e 00 cf 09			.byte	$58,$49,$00,$12,$4e,$00,$cf,$09
>14a0	34 03 b9 84 46 7d fd 06			.byte	$34,$03,$b9,$84,$46,$7d,$fd,$06
>14a8	36 38 37 35 00 0e 4f 00			.byte	$36,$38,$37,$35,$00,$0e,$4f,$00
>14b0	cf 14 38 0d bc 40 be 84			.byte	$cf,$14,$38,$0d,$bc,$40,$be,$84
>14b8	4c 69 00 0d 50 00 cf 1a			.byte	$4c,$69,$00,$0d,$50,$00,$cf,$1a
>14c0	38 0d b7 84 fe 03 43 00			.byte	$38,$0d,$b7,$84,$fe,$03,$43,$00
>14c8	11 51 00 cf 01 36 01 03			.byte	$11,$51,$00,$cf,$01,$36,$01,$03
>14d0	b7 84 fe 06 49 39 59 59			.byte	$b7,$84,$fe,$06,$49,$39,$59,$59
>14d8	00 14 52 00 cf 17 34 11			.byte	$00,$14,$52,$00,$cf,$17,$34,$11
>14e0	bd 41 be 84 47 78 fd 06			.byte	$bd,$41,$be,$84,$47,$78,$fd,$06
>14e8	39 33 37 35 00 0d 53 00			.byte	$39,$33,$37,$35,$00,$0d,$53,$00
>14f0	cf 03 32 0f b7 84 fe 03			.byte	$cf,$03,$32,$0f,$b7,$84,$fe,$03
>14f8	42 00 11 54 00 cf 0d 30			.byte	$42,$00,$11,$54,$00,$cf,$0d,$30
>1500	0d 09 b7 84 fe 06 44 38			.byte	$0d,$09,$b7,$84,$fe,$06,$44,$38
>1508	45 54 00 0d 55 00 cf 09			.byte	$45,$54,$00,$0d,$55,$00,$cf,$09
>1510	32 04 b7 84 fe 03 54 00			.byte	$32,$04,$b7,$84,$fe,$03,$54,$00
>1518	0f 56 00 cf 13 34 0f 01			.byte	$0f,$56,$00,$cf,$13,$34,$0f,$01
>1520	04 bb 84 8b 4e 44 00 13			.byte	$04,$bb,$84,$8b,$4e,$44,$00,$13
>1528	57 00 cf 0d 37 06 11 15			.byte	$57,$00,$cf,$0d,$37,$06,$11,$15
>1530	b7 84 fe 07 56 30 46 56			.byte	$b7,$84,$fe,$07,$56,$30,$46,$56
>1538	4d 00 11 58 00 cf 19 34			.byte	$4d,$00,$11,$58,$00,$cf,$19,$34
>1540	1a b7 84 fe 07 59 33 59			.byte	$1a,$b7,$84,$fe,$07,$59,$33,$59
>1548	42 41 00 12 59 00 cf 17			.byte	$42,$41,$00,$12,$59,$00,$cf,$17
>1550	37 03 0b b7 84 fe 07 57			.byte	$37,$03,$0b,$b7,$84,$fe,$07,$57
>1558	30 54 56 41 00 0e 5a 00			.byte	$30,$54,$56,$41,$00,$0e,$5a,$00
>1560	cf 01 36 01 03 b7 84 fe			.byte	$cf,$01,$36,$01,$03,$b7,$84,$fe
>1568	03 56 00 14 5b 00 cf 17			.byte	$03,$56,$00,$14,$5b,$00,$cf,$17
>1570	35 04 02 14 b9 84 8b 68			.byte	$35,$04,$02,$14,$b9,$84,$8b,$68
>1578	fd 06 30 36 32 35 00 10			.byte	$fd,$06,$30,$36,$32,$35,$00,$10
>1580	5c 00 cf 17 b9 84 43 6b			.byte	$5c,$00,$cf,$17,$b9,$84,$43,$6b
>1588	fd 06 30 36 32 35 00 14			.byte	$fd,$06,$30,$36,$32,$35,$00,$14
>1590	5d 00 cf 1a 37 18 1a b9			.byte	$5d,$00,$cf,$1a,$37,$18,$1a,$b9
>1598	84 8b 45 49 fd 06 35 36			.byte	$84,$8b,$45,$49,$fd,$06,$35,$36
>15a0	32 35 00 11 5e 00 cf 0e			.byte	$32,$35,$00,$11,$5e,$00,$cf,$0e
>15a8	37 1a 03 0f b9 84 43 71			.byte	$37,$1a,$03,$0f,$b9,$84,$43,$71
>15b0	fd 03 30 00 0c 5f 00 cf			.byte	$fd,$03,$30,$00,$0c,$5f,$00,$cf
>15b8	10 39 05 bb 84 42 63 00			.byte	$10,$39,$05,$bb,$84,$42,$63,$00
>15c0	12 60 00 cf 06 34 17 12			.byte	$12,$60,$00,$cf,$06,$34,$17,$12
>15c8	84 8b 41 6e fd 05 31 32			.byte	$84,$8b,$41,$6e,$fd,$05,$31,$32
>15d0	35 00 0e 61 00 cf 02 34			.byte	$35,$00,$0e,$61,$00,$cf,$02,$34
>15d8	16 0f bb 84 8b 47 6a 00			.byte	$16,$0f,$bb,$84,$8b,$47,$6a,$00
>15e0	15 62 00 cf 0b 35 0f 14			.byte	$15,$62,$00,$cf,$0b,$35,$0f,$14
>15e8	04 b9 84 8b 45 6e fd 06			.byte	$04,$b9,$84,$8b,$45,$6e,$fd,$06
>15f0	35 36 32 35 00 13 63 00			.byte	$35,$36,$32,$35,$00,$13,$63,$00
>15f8	cf 01 38 19 13 0d 84 8b			.byte	$cf,$01,$38,$19,$13,$0d,$84,$8b
>1600	48 7a fd 05 36 32 35 00			.byte	$48,$7a,$fd,$05,$36,$32,$35,$00
>1608	12 64 00 cf 0e 39 15 17			.byte	$12,$64,$00,$cf,$0e,$39,$15,$17
>1610	b8 42 bf 40 be 84 fe 03			.byte	$b8,$42,$bf,$40,$be,$84,$fe,$03
>1618	4e 00 0e 65 00 cf 14 38			.byte	$4e,$00,$0e,$65,$00,$cf,$14,$38
>1620	0d bc 41 be 84 42 6b 00			.byte	$0d,$bc,$41,$be,$84,$42,$6b,$00
>1628	13 66 00 cf 0f 35 0e 13			.byte	$13,$66,$00,$cf,$0f,$35,$0e,$13
>1630	b9 84 48 50 fd 06 31 38			.byte	$b9,$84,$48,$50,$fd,$06,$31,$38
>1638	37 35 00 0f 67 00 cf 09			.byte	$37,$35,$00,$0f,$67,$00,$cf,$09
>1640	34 03 b9 84 70 fd 04 37			.byte	$34,$03,$b9,$84,$70,$fd,$04,$37
>1648	35 00 12 68 00 cf 01 34			.byte	$35,$00,$12,$68,$00,$cf,$01,$34
>1650	0b 0b b7 84 fe 07 58 30			.byte	$0b,$0b,$b7,$84,$fe,$07,$58,$30
>1658	42 59 46 00 10 69 00 cf			.byte	$42,$59,$46,$00,$10,$69,$00,$cf
>1660	0d 30 0d 09 b7 84 fe 05			.byte	$0d,$30,$0d,$09,$b7,$84,$fe,$05
>1668	53 37 45 00 0e 6a 00 cf			.byte	$53,$37,$45,$00,$0e,$6a,$00,$cf
>1670	01 36 01 03 b7 84 fe 03			.byte	$01,$36,$01,$03,$b7,$84,$fe,$03
>1678	49 00 12 6b 00 cf 0e 38			.byte	$49,$00,$12,$6b,$00,$cf,$0e,$38
>1680	04 05 06 b9 84 42 43 fd			.byte	$04,$05,$06,$b9,$84,$42,$43,$fd
>1688	04 32 35 00 13 6c 00 cf			.byte	$04,$32,$35,$00,$13,$6c,$00,$cf
>1690	12 32 05 08 03 b7 84 fe			.byte	$12,$32,$05,$08,$03,$b7,$84,$fe
>1698	07 56 38 41 41 59 00 15			.byte	$07,$56,$38,$41,$41,$59,$00,$15
>16a0	6d 00 cf 17 34 11 bd 41			.byte	$6d,$00,$cf,$17,$34,$11,$bd,$41
>16a8	be 84 8b 49 42 fd 06 30			.byte	$be,$84,$8b,$49,$42,$fd,$06,$30
>16b0	36 32 35 00 11 6e 00 cf			.byte	$36,$32,$35,$00,$11,$6e,$00,$cf
>16b8	14 39 17 84 41 4d fd 06			.byte	$14,$39,$17,$84,$41,$4d,$fd,$06
>16c0	35 36 32 35 00 0e 6f 00			.byte	$35,$36,$32,$35,$00,$0e,$6f,$00
>16c8	cf 1a 36 0a 08 13 bb 84			.byte	$cf,$1a,$36,$0a,$08,$13,$bb,$84
>16d0	41 48 00 15 70 00 cf 0e			.byte	$41,$48,$00,$15,$70,$00,$cf,$0e
>16d8	38 04 05 06 b9 84 8b 46			.byte	$38,$04,$05,$06,$b9,$84,$8b,$46
>16e0	4e fd 06 35 36 32 35 00			.byte	$4e,$fd,$06,$35,$36,$32,$35,$00
>16e8	0e 71 00 cf 08 36 0d 11			.byte	$0e,$71,$00,$cf,$08,$36,$0d,$11
>16f0	12 bb 84 44 69 00 0b 72			.byte	$12,$bb,$84,$44,$69,$00,$0b,$72
>16f8	00 cf 03 bb 84 8b 46 4e			.byte	$00,$cf,$03,$bb,$84,$8b,$46,$4e
>1700	00 0f 73 00 cf 0b 84 8b			.byte	$00,$0f,$73,$00,$cf,$0b,$84,$8b
>1708	48 7a fd 05 31 32 35 00			.byte	$48,$7a,$fd,$05,$31,$32,$35,$00
>1710	0d 74 00 cf 09 32 04 b7			.byte	$0d,$74,$00,$cf,$09,$32,$04,$b7
>1718	84 fe 03 41 00 10 75 00			.byte	$84,$fe,$03,$41,$00,$10,$75,$00
>1720	cf 19 33 03 13 bc 40 be			.byte	$cf,$19,$33,$03,$13,$bc,$40,$be
>1728	84 8b 48 73 00 10 76 00			.byte	$84,$8b,$48,$73,$00,$10,$76,$00
>1730	cf 03 32 0f b7 84 fe 06			.byte	$cf,$03,$32,$0f,$b7,$84,$fe,$06
>1738	59 33 45 4a 00 10 77 00			.byte	$59,$33,$45,$4a,$00,$10,$77,$00
>1740	cf 0f 84 8b 43 69 fd 06			.byte	$cf,$0f,$84,$8b,$43,$69,$fd,$06
>1748	38 31 32 35 00 0d 78 00			.byte	$38,$31,$32,$35,$00,$0d,$78,$00
>1750	cf 0f 84 8b 46 6e fd 03			.byte	$cf,$0f,$84,$8b,$46,$6e,$fd,$03
>1758	30 00 0c 79 00 cf 09 31			.byte	$30,$00,$0c,$79,$00,$cf,$09,$31
>1760	07 bb 84 4a 7b 00 11 7a			.byte	$07,$bb,$84,$4a,$7b,$00,$11,$7a
>1768	00 cf 01 35 14 84 8b 46			.byte	$00,$cf,$01,$35,$14,$84,$8b,$46
>1770	6c fd 05 31 32 35 00 14			.byte	$6c,$fd,$05,$31,$32,$35,$00,$14
>1778	7b 00 cf 16 32 1a 0a 0e			.byte	$7b,$00,$cf,$16,$32,$1a,$0a,$0e
>1780	84 8b 43 76 fd 06 35 36			.byte	$84,$8b,$43,$76,$fd,$06,$35,$36
>1788	32 35 00 10 7c 00 cf 04			.byte	$32,$35,$00,$10,$7c,$00,$cf,$04
>1790	36 10 84 8b 45 6a fd 04			.byte	$36,$10,$84,$8b,$45,$6a,$fd,$04
>1798	32 35 00 10 7d 00 cf 17			.byte	$32,$35,$00,$10,$7d,$00,$cf,$17
>17a0	b9 84 43 64 fd 06 39 33			.byte	$b9,$84,$43,$64,$fd,$06,$39,$33
>17a8	37 35 00 0e 7e 00 cf 02			.byte	$37,$35,$00,$0e,$7e,$00,$cf,$02
>17b0	34 16 0f bb 84 8b 47 45			.byte	$34,$16,$0f,$bb,$84,$8b,$47,$45
>17b8	00 11 7f 00 cf 09 34 03			.byte	$00,$11,$7f,$00,$cf,$09,$34,$03
>17c0	b9 84 46 59 fd 05 36 32			.byte	$b9,$84,$46,$59,$fd,$05,$36,$32
>17c8	35 00 0d 80 00 cf 06 31			.byte	$35,$00,$0d,$80,$00,$cf,$06,$31
>17d0	0e 0c bb 84 49 62 00 13			.byte	$0e,$0c,$bb,$84,$49,$62,$00,$13
>17d8	81 00 cf 0f 35 0e 13 b9			.byte	$81,$00,$cf,$0f,$35,$0e,$13,$b9
>17e0	84 47 41 fd 06 39 33 37			.byte	$84,$47,$41,$fd,$06,$39,$33,$37
>17e8	35 00 0f 82 00 cf 10 38			.byte	$35,$00,$0f,$82,$00,$cf,$10,$38
>17f0	0a 84 48 77 fd 04 37 35			.byte	$0a,$84,$48,$77,$fd,$04,$37,$35
>17f8	00 0d 83 00 cf 19 33 15			.byte	$00,$0d,$83,$00,$cf,$19,$33,$15
>1800	bb 84 8b 41 76 00 0e 84			.byte	$bb,$84,$8b,$41,$76,$00,$0e,$84
>1808	00 cf 01 34 0b 0b b7 84			.byte	$00,$cf,$01,$34,$0b,$0b,$b7,$84
>1810	fe 03 53 00 0d 85 00 cf			.byte	$fe,$03,$53,$00,$0d,$85,$00,$cf
>1818	18 35 12 bb 84 8b 49 6a			.byte	$18,$35,$12,$bb,$84,$8b,$49,$6a
>1820	00 13 86 00 cf 0b 35 0f			.byte	$00,$13,$86,$00,$cf,$0b,$35,$0f
>1828	14 04 b9 84 71 fd 06 31			.byte	$14,$04,$b9,$84,$71,$fd,$06,$31
>1830	38 37 35 00 0f 87 00 cf			.byte	$38,$37,$35,$00,$0f,$87,$00,$cf
>1838	03 32 0f b7 84 fe 05 4a			.byte	$03,$32,$0f,$b7,$84,$fe,$05,$4a
>1840	37 43 00 13 88 00 cf 11			.byte	$37,$43,$00,$13,$88,$00,$cf,$11
>1848	31 12 b9 84 8b 48 5e fd			.byte	$31,$12,$b9,$84,$8b,$48,$5e,$fd
>1850	06 39 33 37 35 00 15 89			.byte	$06,$39,$33,$37,$35,$00,$15,$89
>1858	00 cf 12 33 06 09 12 b9			.byte	$00,$cf,$12,$33,$06,$09,$12,$b9
>1860	84 8b 46 69 fd 06 33 31			.byte	$84,$8b,$46,$69,$fd,$06,$33,$31
>1868	32 35 00 13 8a 00 cf 0c			.byte	$32,$35,$00,$13,$8a,$00,$cf,$0c
>1870	bd 41 bf 41 be 84 41 44			.byte	$bd,$41,$bf,$41,$be,$84,$41,$44
>1878	fd 05 33 37 35 00 10 8b			.byte	$fd,$05,$33,$37,$35,$00,$10,$8b
>1880	00 cf 03 32 0f b7 84 fe			.byte	$00,$cf,$03,$32,$0f,$b7,$84,$fe
>1888	06 43 32 48 41 00 0f 8c			.byte	$06,$43,$32,$48,$41,$00,$0f,$8c
>1890	00 cf 14 39 17 84 41 65			.byte	$00,$cf,$14,$39,$17,$84,$41,$65
>1898	fd 04 37 35 00 13 8d 00			.byte	$fd,$04,$37,$35,$00,$13,$8d,$00
>18a0	cf 02 31 03 0f 84 8b 46			.byte	$cf,$02,$31,$03,$0f,$84,$8b,$46
>18a8	43 fd 06 35 36 32 35 00			.byte	$43,$fd,$06,$35,$36,$32,$35,$00
>18b0	13 8e 00 cf 07 36 07 0a			.byte	$13,$8e,$00,$cf,$07,$36,$07,$0a
>18b8	84 8b 44 5a fd 06 39 33			.byte	$84,$8b,$44,$5a,$fd,$06,$39,$33
>18c0	37 35 00 14 8f 00 cf 04			.byte	$37,$35,$00,$14,$8f,$00,$cf,$04
>18c8	39 13 02 17 b9 84 46 67			.byte	$39,$13,$02,$17,$b9,$84,$46,$67
>18d0	fd 06 36 38 37 35 00 10			.byte	$fd,$06,$36,$38,$37,$35,$00,$10
>18d8	90 00 cf 05 33 06 84 8b			.byte	$90,$00,$cf,$05,$33,$06,$84,$8b
>18e0	45 6c fd 04 37 35 00 0d			.byte	$45,$6c,$fd,$04,$37,$35,$00,$0d
>18e8	91 00 cf 12 b7 84 fe 05			.byte	$91,$00,$cf,$12,$b7,$84,$fe,$05
>18f0	4f 37 54 00 0f 92 00 cf			.byte	$4f,$37,$54,$00,$0f,$92,$00,$cf
>18f8	13 84 44 4b fd 06 39 33			.byte	$13,$84,$44,$4b,$fd,$06,$39,$33
>1900	37 35 00 0f 93 00 cf 14			.byte	$37,$35,$00,$0f,$93,$00,$cf,$14
>1908	32 06 08 19 bb 84 8b 49			.byte	$32,$06,$08,$19,$bb,$84,$8b,$49
>1910	54 00 0d 94 00 cf 0d 38			.byte	$54,$00,$0d,$94,$00,$cf,$0d,$38
>1918	13 07 bb 84 44 7f 00 12			.byte	$13,$07,$bb,$84,$44,$7f,$00,$12
>1920	95 00 cf 0f 35 0e 13 b9			.byte	$95,$00,$cf,$0f,$35,$0e,$13,$b9
>1928	84 8b 46 69 fd 04 32 35			.byte	$84,$8b,$46,$69,$fd,$04,$32,$35
>1930	00 11 96 00 cf 01 38 19			.byte	$00,$11,$96,$00,$cf,$01,$38,$19
>1938	13 0d 84 41 7c fd 04 37			.byte	$13,$0d,$84,$41,$7c,$fd,$04,$37
>1940	35 00 0d 97 00 cf 0a 30			.byte	$35,$00,$0d,$97,$00,$cf,$0a,$30
>1948	05 bb 84 8b 46 5f 00 13			.byte	$05,$bb,$84,$8b,$46,$5f,$00,$13
>1950	98 00 cf 16 38 0f 06 84			.byte	$98,$00,$cf,$16,$38,$0f,$06,$84
>1958	8b 47 76 fd 06 35 36 32			.byte	$8b,$47,$76,$fd,$06,$35,$36,$32
>1960	35 00 11 99 00 cf 19 30			.byte	$35,$00,$11,$99,$00,$cf,$19,$30
>1968	05 18 11 b9 84 41 71 fd			.byte	$05,$18,$11,$b9,$84,$41,$71,$fd
>1970	03 30 00 0f 9a 00 cf 09			.byte	$03,$30,$00,$0f,$9a,$00,$cf,$09
>1978	32 04 b7 84 fe 05 4e 31			.byte	$32,$04,$b7,$84,$fe,$05,$4e,$31
>1980	4c 00 10 9b 00 cf 17 37			.byte	$4c,$00,$10,$9b,$00,$cf,$17,$37
>1988	03 0b b7 84 fe 05 45 38			.byte	$03,$0b,$b7,$84,$fe,$05,$45,$38
>1990	58 00 11 9c 00 cf 0a 35			.byte	$58,$00,$11,$9c,$00,$cf,$0a,$35
>1998	18 b7 84 fe 07 45 30 58			.byte	$18,$b7,$84,$fe,$07,$45,$30,$58
>19a0	42 57 00 11 9d 00 cf 17			.byte	$42,$57,$00,$11,$9d,$00,$cf,$17
>19a8	32 19 09 84 58 fd 06 35			.byte	$32,$19,$09,$84,$58,$fd,$06,$35
>19b0	36 32 35 00 12 9e 00 cf			.byte	$36,$32,$35,$00,$12,$9e,$00,$cf
>19b8	1a 33 11 0a 19 84 43 5d			.byte	$1a,$33,$11,$0a,$19,$84,$43,$5d
>19c0	fd 05 33 37 35 00 11 9f			.byte	$fd,$05,$33,$37,$35,$00,$11,$9f
>19c8	00 cf 04 31 0d 12 07 b9			.byte	$00,$cf,$04,$31,$0d,$12,$07,$b9
>19d0	84 41 5a fd 03 30 00 0f			.byte	$84,$41,$5a,$fd,$03,$30,$00,$0f
>19d8	a0 00 cf 08 36 0d 11 12			.byte	$a0,$00,$cf,$08,$36,$0d,$11,$12
>19e0	bb 84 8b 47 6c 00 0e a1			.byte	$bb,$84,$8b,$47,$6c,$00,$0e,$a1
>19e8	00 cf 02 b7 84 fe 06 4d			.byte	$00,$cf,$02,$b7,$84,$fe,$06,$4d
>19f0	38 49 46 00 0f a2 00 cf			.byte	$38,$49,$46,$00,$0f,$a2,$00,$cf
>19f8	10 84 44 5a fd 06 33 31			.byte	$10,$84,$44,$5a,$fd,$06,$33,$31
>1a00	32 35 00 0a a3 00 cf 09			.byte	$32,$35,$00,$0a,$a3,$00,$cf,$09
>1a08	bb 84 4a 68 00 11 a4 00			.byte	$bb,$84,$4a,$68,$00,$11,$a4,$00
>1a10	cf 09 34 03 b9 84 47 66			.byte	$cf,$09,$34,$03,$b9,$84,$47,$66
>1a18	fd 05 31 32 35 00 0f a5			.byte	$fd,$05,$31,$32,$35,$00,$0f,$a5
>1a20	00 cf 0f 84 8b 71 fd 06			.byte	$00,$cf,$0f,$84,$8b,$71,$fd,$06
>1a28	34 33 37 35 00 0f a6 00			.byte	$34,$33,$37,$35,$00,$0f,$a6,$00
>1a30	cf 14 38 0d bc 41 be 84			.byte	$cf,$14,$38,$0d,$bc,$41,$be,$84
>1a38	8b 42 5b 00 0e a7 00 cf			.byte	$8b,$42,$5b,$00,$0e,$a7,$00,$cf
>1a40	02 37 15 84 44 6e fd 03			.byte	$02,$37,$15,$84,$44,$6e,$fd,$03
>1a48	35 00 10 a8 00 cf 03 33			.byte	$35,$00,$10,$a8,$00,$cf,$03,$33
>1a50	0d 02 07 bc 41 be 84 4a			.byte	$0d,$02,$07,$bc,$41,$be,$84,$4a
>1a58	7a 00 12 a9 00 cf 09 34			.byte	$7a,$00,$12,$a9,$00,$cf,$09,$34
>1a60	03 b9 84 45 4a fd 06 34			.byte	$03,$b9,$84,$45,$4a,$fd,$06,$34
>1a68	33 37 35 00 0f aa 00 cf			.byte	$33,$37,$35,$00,$0f,$aa,$00,$cf
>1a70	14 34 13 13 14 bb 84 8b			.byte	$14,$34,$13,$13,$14,$bb,$84,$8b
>1a78	4d 68 00 10 ab 00 cf 19			.byte	$4d,$68,$00,$10,$ab,$00,$cf,$19
>1a80	34 1a b7 84 fe 06 42 35			.byte	$34,$1a,$b7,$84,$fe,$06,$42,$35
>1a88	43 4e 00 0e ac 00 cf 13			.byte	$43,$4e,$00,$0e,$ac,$00,$cf,$13
>1a90	34 0f 01 04 bb 84 4d 43			.byte	$34,$0f,$01,$04,$bb,$84,$4d,$43
>1a98	00 0f ad 00 cf 0b 84 8b			.byte	$00,$0f,$ad,$00,$cf,$0b,$84,$8b
>1aa0	42 4f fd 05 36 32 35 00			.byte	$42,$4f,$fd,$05,$36,$32,$35,$00
>1aa8	0b ae 00 cf 11 bb 84 8b			.byte	$0b,$ae,$00,$cf,$11,$bb,$84,$8b
>1ab0	4b 5f 00 0d af 00 cf 15			.byte	$4b,$5f,$00,$0d,$af,$00,$cf,$15
>1ab8	31 0f bb 84 8b 46 60 00			.byte	$31,$0f,$bb,$84,$8b,$46,$60,$00
>1ac0	0f b0 00 cf 19 34 1a b7			.byte	$0f,$b0,$00,$cf,$19,$34,$1a,$b7
>1ac8	84 fe 05 43 35 43 00 0a			.byte	$84,$fe,$05,$43,$35,$43,$00,$0a
>1ad0	b1 00 cf 03 bb 84 45 66			.byte	$b1,$00,$cf,$03,$bb,$84,$45,$66
>1ad8	00 11 b2 00 cf 06 34 17			.byte	$00,$11,$b2,$00,$cf,$06,$34,$17
>1ae0	12 84 45 77 fd 05 31 32			.byte	$12,$84,$45,$77,$fd,$05,$31,$32
>1ae8	35 00 12 b3 00 cf 02 31			.byte	$35,$00,$12,$b3,$00,$cf,$02,$31
>1af0	03 0f 84 8b 42 67 fd 05			.byte	$03,$0f,$84,$8b,$42,$67,$fd,$05
>1af8	31 32 35 00 13 b4 00 cf			.byte	$31,$32,$35,$00,$13,$b4,$00,$cf
>1b00	05 39 11 b9 84 8b 43 62			.byte	$05,$39,$11,$b9,$84,$8b,$43,$62
>1b08	fd 06 34 33 37 35 00 0f			.byte	$fd,$06,$34,$33,$37,$35,$00,$0f
>1b10	b5 00 cf 0d b9 84 8b 42			.byte	$b5,$00,$cf,$0d,$b9,$84,$8b,$42
>1b18	7c fd 04 37 35 00 13 b6			.byte	$7c,$fd,$04,$37,$35,$00,$13,$b6
>1b20	00 cf 06 34 17 12 84 8b			.byte	$00,$cf,$06,$34,$17,$12,$84,$8b
>1b28	43 4a fd 06 30 36 32 35			.byte	$43,$4a,$fd,$06,$30,$36,$32,$35
>1b30	00 0e b7 00 cf 03 32 0f			.byte	$00,$0e,$b7,$00,$cf,$03,$32,$0f
>1b38	b7 84 fe 04 4f 32 00 13			.byte	$b7,$84,$fe,$04,$4f,$32,$00,$13
>1b40	b8 00 cf 05 39 17 01 04			.byte	$b8,$00,$cf,$05,$39,$17,$01,$04
>1b48	84 8b 44 4e fd 05 33 37			.byte	$84,$8b,$44,$4e,$fd,$05,$33,$37
>1b50	35 00 11 b9 00 cf 01 38			.byte	$35,$00,$11,$b9,$00,$cf,$01,$38
>1b58	19 13 0d 84 72 fd 05 33			.byte	$19,$13,$0d,$84,$72,$fd,$05,$33
>1b60	37 35 00 14 ba 00 cf 14			.byte	$37,$35,$00,$14,$ba,$00,$cf,$14
>1b68	31 02 04 15 84 8b 48 51			.byte	$31,$02,$04,$15,$84,$8b,$48,$51
>1b70	fd 06 38 31 32 35 00 11			.byte	$fd,$06,$38,$31,$32,$35,$00,$11
>1b78	bb 00 cf 04 36 10 84 8b			.byte	$bb,$00,$cf,$04,$36,$10,$84,$8b
>1b80	43 48 fd 05 33 37 35 00			.byte	$43,$48,$fd,$05,$33,$37,$35,$00
>1b88	0c bc 00 cf 0b 37 16 bb			.byte	$0c,$bc,$00,$cf,$0b,$37,$16,$bb
>1b90	84 4d 49 00 11 bd 00 cf			.byte	$84,$4d,$49,$00,$11,$bd,$00,$cf
>1b98	07 36 07 0a 84 41 75 fd			.byte	$07,$36,$07,$0a,$84,$41,$75,$fd
>1ba0	05 36 32 35 00 0c be 00			.byte	$05,$36,$32,$35,$00,$0c,$be,$00
>1ba8	cf 01 33 19 bb 84 49 6e			.byte	$cf,$01,$33,$19,$bb,$84,$49,$6e
>1bb0	00 13 bf 00 cf 17 34 11			.byte	$00,$13,$bf,$00,$cf,$17,$34,$11
>1bb8	bd 41 be 84 42 50 fd 05			.byte	$bd,$41,$be,$84,$42,$50,$fd,$05
>1bc0	36 32 35 00 0c c0 00 cf			.byte	$36,$32,$35,$00,$0c,$c0,$00,$cf
>1bc8	1a 38 17 bb 84 4e 58 00			.byte	$1a,$38,$17,$bb,$84,$4e,$58,$00
>1bd0	0d c1 00 cf 0c 35 19 0a			.byte	$0d,$c1,$00,$cf,$0c,$35,$19,$0a
>1bd8	b7 84 fe 02 00 0a c2 00			.byte	$b7,$84,$fe,$02,$00,$0a,$c2,$00
>1be0	cf 0a bb 84 42 4b 00 11			.byte	$cf,$0a,$bb,$84,$42,$4b,$00,$11
>1be8	c3 00 cf 01 35 14 84 41			.byte	$c3,$00,$cf,$01,$35,$14,$84,$41
>1bf0	54 fd 06 31 38 37 35 00			.byte	$54,$fd,$06,$31,$38,$37,$35,$00
>1bf8	0a c4 00 cf 09 bb 84 44			.byte	$0a,$c4,$00,$cf,$09,$bb,$84,$44
>1c00	7c 00 11 c5 00 cf 18 37			.byte	$7c,$00,$11,$c5,$00,$cf,$18,$37
>1c08	15 09 0b bc 42 bf 41 be			.byte	$15,$09,$0b,$bc,$42,$bf,$41,$be
>1c10	84 7b 00 12 c6 00 cf 14			.byte	$84,$7b,$00,$12,$c6,$00,$cf,$14
>1c18	39 17 84 8b 44 69 fd 06			.byte	$39,$17,$84,$8b,$44,$69,$fd,$06
>1c20	31 38 37 35 00 14 c7 00			.byte	$31,$38,$37,$35,$00,$14,$c7,$00
>1c28	cf 04 33 03 1a 11 84 8b			.byte	$cf,$04,$33,$03,$1a,$11,$84,$8b
>1c30	46 45 fd 06 36 38 37 35			.byte	$46,$45,$fd,$06,$36,$38,$37,$35
>1c38	00 0e c8 00 cf 14 39 0a			.byte	$00,$0e,$c8,$00,$cf,$14,$39,$0a
>1c40	0d bb 84 8b 42 4f 00 0d			.byte	$0d,$bb,$84,$8b,$42,$4f,$00,$0d
>1c48	c9 00 cf 06 31 0e 0c bb			.byte	$c9,$00,$cf,$06,$31,$0e,$0c,$bb
>1c50	84 41 5c 00 12 ca 00 cf			.byte	$84,$41,$5c,$00,$12,$ca,$00,$cf
>1c58	08 35 02 84 8b 46 6c fd			.byte	$08,$35,$02,$84,$8b,$46,$6c,$fd
>1c60	06 30 36 32 35 00 14 cb			.byte	$06,$30,$36,$32,$35,$00,$14,$cb
>1c68	00 cf 04 31 0d 12 07 b9			.byte	$00,$cf,$04,$31,$0d,$12,$07,$b9
>1c70	84 8b 42 6b fd 05 38 37			.byte	$84,$8b,$42,$6b,$fd,$05,$38,$37
>1c78	35 00 0b cc 00 cf 12 b7			.byte	$35,$00,$0b,$cc,$00,$cf,$12,$b7
>1c80	84 fe 03 46 00 13 cd 00			.byte	$84,$fe,$03,$46,$00,$13,$cd,$00
>1c88	cf 0f 35 0e 13 b9 84 47			.byte	$cf,$0f,$35,$0e,$13,$b9,$84,$47
>1c90	51 fd 06 33 31 32 35 00			.byte	$51,$fd,$06,$33,$31,$32,$35,$00
>1c98	0b ce 00 cf 09 31 07 bb			.byte	$0b,$ce,$00,$cf,$09,$31,$07,$bb
>1ca0	84 67 00 10 cf 00 cf 05			.byte	$84,$67,$00,$10,$cf,$00,$cf,$05
>1ca8	33 06 84 45 5b fd 05 31			.byte	$33,$06,$84,$45,$5b,$fd,$05,$31
>1cb0	32 35 00 14 d0 00 cf 01			.byte	$32,$35,$00,$14,$d0,$00,$cf,$01
>1cb8	32 10 07 0c 84 8b 49 54			.byte	$32,$10,$07,$0c,$84,$8b,$49,$54
>1cc0	fd 06 39 33 37 35 00 15			.byte	$fd,$06,$39,$33,$37,$35,$00,$15
>1cc8	d1 00 cf 0e 38 04 05 06			.byte	$d1,$00,$cf,$0e,$38,$04,$05,$06
>1cd0	b9 84 8b 47 6b fd 06 33			.byte	$b9,$84,$8b,$47,$6b,$fd,$06,$33
>1cd8	31 32 35 00 0e d2 00 cf			.byte	$31,$32,$35,$00,$0e,$d2,$00,$cf
>1ce0	0b 84 7a fd 06 38 31 32			.byte	$0b,$84,$7a,$fd,$06,$38,$31,$32
>1ce8	35 00 11 d3 00 cf 11 31			.byte	$35,$00,$11,$d3,$00,$cf,$11,$31
>1cf0	12 b9 84 8b 41 4b fd 04			.byte	$12,$b9,$84,$8b,$41,$4b,$fd,$04
>1cf8	37 35 00 0b d4 00 cf 16			.byte	$37,$35,$00,$0b,$d4,$00,$cf,$16
>1d00	bb 84 8b 4e 48 00 0e d5			.byte	$bb,$84,$8b,$4e,$48,$00,$0e,$d5
>1d08	00 cf 0f 84 8b 45 6b fd			.byte	$00,$cf,$0f,$84,$8b,$45,$6b,$fd
>1d10	04 37 35 00 0d d6 00 dc			.byte	$04,$37,$35,$00,$0d,$d6,$00,$dc
>1d18	1a b7 84 fe 05 52 35 4f			.byte	$1a,$b7,$84,$fe,$05,$52,$35,$4f
>1d20	00 0e d7 00 dc 03 32 0f			.byte	$00,$0e,$d7,$00,$dc,$03,$32,$0f
>1d28	b7 84 fe 04 4f 32 00 0b			.byte	$b7,$84,$fe,$04,$4f,$32,$00,$0b
>1d30	d8 00 dc 09 31 07 bb 84			.byte	$d8,$00,$dc,$09,$31,$07,$bb,$84
>1d38	67 00 14 d9 00 dc 17 35			.byte	$67,$00,$14,$d9,$00,$dc,$17,$35
>1d40	04 02 14 b9 84 8b 68 fd			.byte	$04,$02,$14,$b9,$84,$8b,$68,$fd
>1d48	06 30 36 32 35 00 0f da			.byte	$06,$30,$36,$32,$35,$00,$0f,$da
>1d50	00 dc 19 34 1a b7 84 fe			.byte	$00,$dc,$19,$34,$1a,$b7,$84,$fe
>1d58	05 43 35 43 00 13 db 00			.byte	$05,$43,$35,$43,$00,$13,$db,$00
>1d60	dc 06 34 17 12 84 8b 43			.byte	$dc,$06,$34,$17,$12,$84,$8b,$43
>1d68	4a fd 06 30 36 32 35 00			.byte	$4a,$fd,$06,$30,$36,$32,$35,$00
>1d70	09 dc 00 dc 04 bb 84 40			.byte	$09,$dc,$00,$dc,$04,$bb,$84,$40
>1d78	00 13 dd 00 dc 0d 32 0c			.byte	$00,$13,$dd,$00,$dc,$0d,$32,$0c
>1d80	05 b9 84 44 51 fd 06 39			.byte	$05,$b9,$84,$44,$51,$fd,$06,$39
>1d88	33 37 35 00 11 de 00 dc			.byte	$33,$37,$35,$00,$11,$de,$00,$dc
>1d90	0a 35 18 b7 84 fe 07 45			.byte	$0a,$35,$18,$b7,$84,$fe,$07,$45
>1d98	30 58 42 57 00 0e df 00			.byte	$30,$58,$42,$57,$00,$0e,$df,$00
>1da0	dc 05 32 11 0c 12 bb 84			.byte	$dc,$05,$32,$11,$0c,$12,$bb,$84
>1da8	41 76 00 0f e0 00 dc 10			.byte	$41,$76,$00,$0f,$e0,$00,$dc,$10
>1db0	38 0a 84 48 77 fd 04 37			.byte	$38,$0a,$84,$48,$77,$fd,$04,$37
>1db8	35 00 0c e1 00 dc 10 39			.byte	$35,$00,$0c,$e1,$00,$dc,$10,$39
>1dc0	05 bb 84 42 63 00 0d e2			.byte	$05,$bb,$84,$42,$63,$00,$0d,$e2
>1dc8	00 dc 1a 38 0d b7 84 fe			.byte	$00,$dc,$1a,$38,$0d,$b7,$84,$fe
>1dd0	03 43 00 0f e3 00 dc 14			.byte	$03,$43,$00,$0f,$e3,$00,$dc,$14
>1dd8	32 06 08 19 bb 84 8b 49			.byte	$32,$06,$08,$19,$bb,$84,$8b,$49
>1de0	54 00 12 e4 00 dc 02 31			.byte	$54,$00,$12,$e4,$00,$dc,$02,$31
>1de8	03 0f 84 8b 42 67 fd 05			.byte	$03,$0f,$84,$8b,$42,$67,$fd,$05
>1df0	31 32 35 00 11 e5 00 dc			.byte	$31,$32,$35,$00,$11,$e5,$00,$dc
>1df8	11 31 12 b9 84 8b 41 4b			.byte	$11,$31,$12,$b9,$84,$8b,$41,$4b
>1e00	fd 04 37 35 00 0d e6 00			.byte	$fd,$04,$37,$35,$00,$0d,$e6,$00
>1e08	dc 18 35 12 bb 84 8b 49			.byte	$dc,$18,$35,$12,$bb,$84,$8b,$49
>1e10	6a 00 14 e7 00 dc 1a 37			.byte	$6a,$00,$14,$e7,$00,$dc,$1a,$37
>1e18	18 1a b9 84 8b 45 49 fd			.byte	$18,$1a,$b9,$84,$8b,$45,$49,$fd
>1e20	06 35 36 32 35 00 0c e8			.byte	$06,$35,$36,$32,$35,$00,$0c,$e8
>1e28	00 dc 05 37 10 03 0f 84			.byte	$00,$dc,$05,$37,$10,$03,$0f,$84
>1e30	40 00 10 e9 00 dc 0d 30			.byte	$40,$00,$10,$e9,$00,$dc,$0d,$30
>1e38	0d 09 b7 84 fe 05 53 37			.byte	$0d,$09,$b7,$84,$fe,$05,$53,$37
>1e40	45 00 0f ea 00 dc 0e b7			.byte	$45,$00,$0f,$ea,$00,$dc,$0e,$b7
>1e48	84 fe 07 55 34 53 58 49			.byte	$84,$fe,$07,$55,$34,$53,$58,$49
>1e50	00 0d eb 00 dc 03 30 19			.byte	$00,$0d,$eb,$00,$dc,$03,$30,$19
>1e58	03 b7 84 fe 02 00 0e ec			.byte	$03,$b7,$84,$fe,$02,$00,$0e,$ec
>1e60	00 dc 0f 84 8b 45 6b fd			.byte	$00,$dc,$0f,$84,$8b,$45,$6b,$fd
>1e68	04 37 35 00 09 ed 00 dc			.byte	$04,$37,$35,$00,$09,$ed,$00,$dc
>1e70	06 bb 84 40 00 0a ee 00			.byte	$06,$bb,$84,$40,$00,$0a,$ee,$00
>1e78	dc 0a bb 84 42 4b 00 12			.byte	$dc,$0a,$bb,$84,$42,$4b,$00,$12
>1e80	ef 00 dc 03 32 19 11 b9			.byte	$ef,$00,$dc,$03,$32,$19,$11,$b9
>1e88	84 49 68 fd 05 33 37 35			.byte	$84,$49,$68,$fd,$05,$33,$37,$35
>1e90	00 10 f0 00 dc 17 b9 84			.byte	$00,$10,$f0,$00,$dc,$17,$b9,$84
>1e98	43 64 fd 06 39 33 37 35			.byte	$43,$64,$fd,$06,$39,$33,$37,$35
>1ea0	00 13 f1 00 dc 05 39 11			.byte	$00,$13,$f1,$00,$dc,$05,$39,$11
>1ea8	b9 84 8b 43 62 fd 06 34			.byte	$b9,$84,$8b,$43,$62,$fd,$06,$34
>1eb0	33 37 35 00 11 f2 00 dc			.byte	$33,$37,$35,$00,$11,$f2,$00,$dc
>1eb8	01 35 14 84 41 54 fd 06			.byte	$01,$35,$14,$84,$41,$54,$fd,$06
>1ec0	31 38 37 35 00 0f f3 00			.byte	$31,$38,$37,$35,$00,$0f,$f3,$00
>1ec8	dc 0d b9 84 8b 42 7c fd			.byte	$dc,$0d,$b9,$84,$8b,$42,$7c,$fd
>1ed0	04 37 35 00 0b f4 00 dc			.byte	$04,$37,$35,$00,$0b,$f4,$00,$dc
>1ed8	19 34 15 bb 84 40 00 11			.byte	$19,$34,$15,$bb,$84,$40,$00,$11
>1ee0	f5 00 dc 19 30 05 18 11			.byte	$f5,$00,$dc,$19,$30,$05,$18,$11
>1ee8	b9 84 41 71 fd 03 30 00			.byte	$b9,$84,$41,$71,$fd,$03,$30,$00
>1ef0	0e f6 00 dc 0b 84 7a fd			.byte	$0e,$f6,$00,$dc,$0b,$84,$7a,$fd
>1ef8	06 38 31 32 35 00 0a f7			.byte	$06,$38,$31,$32,$35,$00,$0a,$f7
>1f00	00 dc 03 bb 84 45 66 00			.byte	$00,$dc,$03,$bb,$84,$45,$66,$00
>1f08	0e f8 00 dc 02 b7 84 fe			.byte	$0e,$f8,$00,$dc,$02,$b7,$84,$fe
>1f10	06 4d 38 49 46 00 14 f9			.byte	$06,$4d,$38,$49,$46,$00,$14,$f9
>1f18	00 dc 14 31 02 04 15 84			.byte	$00,$dc,$14,$31,$02,$04,$15,$84
>1f20	8b 48 51 fd 06 38 31 32			.byte	$8b,$48,$51,$fd,$06,$38,$31,$32
>1f28	35 00 0f fa 00 dc 05 84			.byte	$35,$00,$0f,$fa,$00,$dc,$05,$84
>1f30	44 5e fd 06 36 38 37 35			.byte	$44,$5e,$fd,$06,$36,$38,$37,$35
>1f38	00 0e fb 00 dc 13 34 0f			.byte	$00,$0e,$fb,$00,$dc,$13,$34,$0f
>1f40	01 04 bb 84 4d 43 00 0d			.byte	$01,$04,$bb,$84,$4d,$43,$00,$0d
>1f48	fc 00 dc 0d 38 13 07 bb			.byte	$fc,$00,$dc,$0d,$38,$13,$07,$bb
>1f50	84 44 7f 00 0c fd 00 dc			.byte	$84,$44,$7f,$00,$0c,$fd,$00,$dc
>1f58	0b 33 0f 14 bb 84 40 00			.byte	$0b,$33,$0f,$14,$bb,$84,$40,$00
>1f60	0e fe 00 dc 14 39 0a 0d			.byte	$0e,$fe,$00,$dc,$14,$39,$0a,$0d
>1f68	bb 84 8b 42 4f 00 0f ff			.byte	$bb,$84,$8b,$42,$4f,$00,$0f,$ff
>1f70	00 dc 09 32 04 b7 84 fe			.byte	$00,$dc,$09,$32,$04,$b7,$84,$fe
>1f78	05 4e 31 4c 00 0b 00 01			.byte	$05,$4e,$31,$4c,$00,$0b,$00,$01
>1f80	dc 0a 31 0b b9 84 40 00			.byte	$dc,$0a,$31,$0b,$b9,$84,$40,$00
>1f88	11 01 01 dc 17 32 19 09			.byte	$11,$01,$01,$dc,$17,$32,$19,$09
>1f90	84 58 fd 06 35 36 32 35			.byte	$84,$58,$fd,$06,$35,$36,$32,$35
>1f98	00 13 02 01 dc 0b 35 0f			.byte	$00,$13,$02,$01,$dc,$0b,$35,$0f
>1fa0	14 04 b9 84 71 fd 06 31			.byte	$14,$04,$b9,$84,$71,$fd,$06,$31
>1fa8	38 37 35 00 0f 03 01 dc			.byte	$38,$37,$35,$00,$0f,$03,$01,$dc
>1fb0	13 84 44 4b fd 06 39 33			.byte	$13,$84,$44,$4b,$fd,$06,$39,$33
>1fb8	37 35 00 12 04 01 dc 14			.byte	$37,$35,$00,$12,$04,$01,$dc,$14
>1fc0	39 17 84 8b 44 69 fd 06			.byte	$39,$17,$84,$8b,$44,$69,$fd,$06
>1fc8	31 38 37 35 00 11 05 01			.byte	$31,$38,$37,$35,$00,$11,$05,$01
>1fd0	dc 19 34 07 b9 84 41 7b			.byte	$dc,$19,$34,$07,$b9,$84,$41,$7b
>1fd8	fd 05 38 37 35 00 0b 06			.byte	$fd,$05,$38,$37,$35,$00,$0b,$06
>1fe0	01 dc 16 bb 84 8b 4e 48			.byte	$01,$dc,$16,$bb,$84,$8b,$4e,$48
>1fe8	00 0d 07 01 dc 19 33 15			.byte	$00,$0d,$07,$01,$dc,$19,$33,$15
>1ff0	bb 84 8b 41 76 00 12 08			.byte	$bb,$84,$8b,$41,$76,$00,$12,$08
>1ff8	01 dc 1a 33 11 0a 19 84			.byte	$01,$dc,$1a,$33,$11,$0a,$19,$84
>2000	43 5d fd 05 33 37 35 00			.byte	$43,$5d,$fd,$05,$33,$37,$35,$00
>2008	0e 09 01 dc 01 36 01 03			.byte	$0e,$09,$01,$dc,$01,$36,$01,$03
>2010	b7 84 fe 03 49 00 0b 0a			.byte	$b7,$84,$fe,$03,$49,$00,$0b,$0a
>2018	01 dc 06 36 01 0d 84 40			.byte	$01,$dc,$06,$36,$01,$0d,$84,$40
>2020	00 0b 0b 01 dc 11 bb 84			.byte	$00,$0b,$0b,$01,$dc,$11,$bb,$84
>2028	8b 4b 5f 00 14 0c 01 dc			.byte	$8b,$4b,$5f,$00,$14,$0c,$01,$dc
>2030	04 33 03 1a 11 84 8b 46			.byte	$04,$33,$03,$1a,$11,$84,$8b,$46
>2038	45 fd 06 36 38 37 35 00			.byte	$45,$fd,$06,$36,$38,$37,$35,$00
>2040	13 0d 01 dc 0f 35 0e 13			.byte	$13,$0d,$01,$dc,$0f,$35,$0e,$13
>2048	b9 84 47 51 fd 06 33 31			.byte	$b9,$84,$47,$51,$fd,$06,$33,$31
>2050	32 35 00 15 0e 01 dc 12			.byte	$32,$35,$00,$15,$0e,$01,$dc,$12
>2058	33 06 09 12 b9 84 8b 46			.byte	$33,$06,$09,$12,$b9,$84,$8b,$46
>2060	69 fd 06 33 31 32 35 00			.byte	$69,$fd,$06,$33,$31,$32,$35,$00
>2068	0e 0f 01 dc 01 34 0b 0b			.byte	$0e,$0f,$01,$dc,$01,$34,$0b,$0b
>2070	b7 84 fe 03 53 00 14 10			.byte	$b7,$84,$fe,$03,$53,$00,$14,$10
>2078	01 dc 01 32 10 07 0c 84			.byte	$01,$dc,$01,$32,$10,$07,$0c,$84
>2080	8b 49 54 fd 06 39 33 37			.byte	$8b,$49,$54,$fd,$06,$39,$33,$37
>2088	35 00 0b 11 01 dc 12 b7			.byte	$35,$00,$0b,$11,$01,$dc,$12,$b7
>2090	84 fe 03 46 00 0c 12 01			.byte	$84,$fe,$03,$46,$00,$0c,$12,$01
>2098	dc 0b 34 11 b7 84 fe 02			.byte	$dc,$0b,$34,$11,$b7,$84,$fe,$02
>20a0	00 0f 13 01 dc 08 36 0d			.byte	$00,$0f,$13,$01,$dc,$08,$36,$0d
>20a8	11 12 bb 84 8b 47 6c 00			.byte	$11,$12,$bb,$84,$8b,$47,$6c,$00
>20b0	11 14 01 dc 01 38 19 13			.byte	$11,$14,$01,$dc,$01,$38,$19,$13
>20b8	0d 84 72 fd 05 33 37 35			.byte	$0d,$84,$72,$fd,$05,$33,$37,$35
>20c0	00 10 15 01 dc 05 33 06			.byte	$00,$10,$15,$01,$dc,$05,$33,$06
>20c8	84 45 5b fd 05 31 32 35			.byte	$84,$45,$5b,$fd,$05,$31,$32,$35
>20d0	00 0e 16 01 dc 1a 36 0a			.byte	$00,$0e,$16,$01,$dc,$1a,$36,$0a
>20d8	08 13 bb 84 41 48 00 14			.byte	$08,$13,$bb,$84,$41,$48,$00,$14
>20e0	17 01 dc 04 31 0d 12 07			.byte	$17,$01,$dc,$04,$31,$0d,$12,$07
>20e8	b9 84 8b 42 6b fd 05 38			.byte	$b9,$84,$8b,$42,$6b,$fd,$05,$38
>20f0	37 35 00 0e 18 01 dc 02			.byte	$37,$35,$00,$0e,$18,$01,$dc,$02
>20f8	34 16 0f bb 84 8b 47 45			.byte	$34,$16,$0f,$bb,$84,$8b,$47,$45
>2100	00 0d 19 01 dc 15 31 0f			.byte	$00,$0d,$19,$01,$dc,$15,$31,$0f
>2108	bb 84 8b 46 60 00 0d 1a			.byte	$bb,$84,$8b,$46,$60,$00,$0d,$1a
>2110	01 dc 0a 30 05 bb 84 8b			.byte	$01,$dc,$0a,$30,$05,$bb,$84,$8b
>2118	46 5f 00 0b 1b 01 dc 16			.byte	$46,$5f,$00,$0b,$1b,$01,$dc,$16
>2120	36 04 0d 84 40 00 12 1c			.byte	$36,$04,$0d,$84,$40,$00,$12,$1c
>2128	01 dc 01 33 16 84 8b 47			.byte	$01,$dc,$01,$33,$16,$84,$8b,$47
>2130	55 fd 06 30 36 32 35 00			.byte	$55,$fd,$06,$30,$36,$32,$35,$00
>2138	0c 1d 01 dc 01 33 19 bb			.byte	$0c,$1d,$01,$dc,$01,$33,$19,$bb
>2140	84 49 6e 00 0a 1e 01 dc			.byte	$84,$49,$6e,$00,$0a,$1e,$01,$dc
>2148	09 bb 84 44 7c 00 0c 1f			.byte	$09,$bb,$84,$44,$7c,$00,$0c,$1f
>2150	01 dc 1a 38 17 bb 84 4e			.byte	$01,$dc,$1a,$38,$17,$bb,$84,$4e
>2158	58 00 10 20 01 dc 17 37			.byte	$58,$00,$10,$20,$01,$dc,$17,$37
>2160	03 0b b7 84 fe 05 45 38			.byte	$03,$0b,$b7,$84,$fe,$05,$45,$38
>2168	58 00 0d 21 01 dc 06 31			.byte	$58,$00,$0d,$21,$01,$dc,$06,$31
>2170	0e 0c bb 84 41 5c 00 12			.byte	$0e,$0c,$bb,$84,$41,$5c,$00,$12
>2178	22 01 dc 09 34 03 b9 84			.byte	$22,$01,$dc,$09,$34,$03,$b9,$84
>2180	45 4a fd 06 34 33 37 35			.byte	$45,$4a,$fd,$06,$34,$33,$37,$35
>2188	00 13 23 01 dc 05 39 17			.byte	$00,$13,$23,$01,$dc,$05,$39,$17
>2190	01 04 84 8b 44 4e fd 05			.byte	$01,$04,$84,$8b,$44,$4e,$fd,$05
>2198	33 37 35 00 14 24 01 dc			.byte	$33,$37,$35,$00,$14,$24,$01,$dc
>21a0	04 39 13 02 17 b9 84 46			.byte	$04,$39,$13,$02,$17,$b9,$84,$46
>21a8	67 fd 06 36 38 37 35 00			.byte	$67,$fd,$06,$36,$38,$37,$35,$00
>21b0	11 25 01 dc 1a 37 02 84			.byte	$11,$25,$01,$dc,$1a,$37,$02,$84
>21b8	8b 43 77 fd 05 36 32 35			.byte	$8b,$43,$77,$fd,$05,$36,$32,$35
>21c0	00 0f 26 01 dc 10 84 44			.byte	$00,$0f,$26,$01,$dc,$10,$84,$44
>21c8	5a fd 06 33 31 32 35 00			.byte	$5a,$fd,$06,$33,$31,$32,$35,$00
>21d0	0c 27 01 dc 14 36 13 0a			.byte	$0c,$27,$01,$dc,$14,$36,$13,$0a
>21d8	bb 84 40 00 13 28 01 dc			.byte	$bb,$84,$40,$00,$13,$28,$01,$dc
>21e0	16 38 0f 06 84 8b 47 76			.byte	$16,$38,$0f,$06,$84,$8b,$47,$76
>21e8	fd 06 35 36 32 35 00 11			.byte	$fd,$06,$35,$36,$32,$35,$00,$11
>21f0	29 01 dc 07 36 07 0a 84			.byte	$29,$01,$dc,$07,$36,$07,$0a,$84
>21f8	41 75 fd 05 36 32 35 00			.byte	$41,$75,$fd,$05,$36,$32,$35,$00
>2200	0c 2a 01 dc 01 39 11 02			.byte	$0c,$2a,$01,$dc,$01,$39,$11,$02
>2208	b9 84 40 00 11 2b 01 dc			.byte	$b9,$84,$40,$00,$11,$2b,$01,$dc
>2210	0e 37 1a 03 0f b9 84 43			.byte	$0e,$37,$1a,$03,$0f,$b9,$84,$43
>2218	71 fd 03 30 00 0b 2c 01			.byte	$71,$fd,$03,$30,$00,$0b,$2c,$01
>2220	dc 0f 37 0a b9 84 40 00			.byte	$dc,$0f,$37,$0a,$b9,$84,$40,$00
>2228	13 2d 01 dc 0d 37 06 11			.byte	$13,$2d,$01,$dc,$0d,$37,$06,$11
>2230	15 b7 84 fe 07 56 30 46			.byte	$15,$b7,$84,$fe,$07,$56,$30,$46
>2238	56 4d 00 15 2e 01 dc 0e			.byte	$56,$4d,$00,$15,$2e,$01,$dc,$0e
>2240	38 04 05 06 b9 84 8b 47			.byte	$38,$04,$05,$06,$b9,$84,$8b,$47
>2248	6b fd 06 33 31 32 35 00			.byte	$6b,$fd,$06,$33,$31,$32,$35,$00
>2250	0c 2f 01 dc 0b 37 16 bb			.byte	$0c,$2f,$01,$dc,$0b,$37,$16,$bb
>2258	84 4d 49 00 0b 30 01 dc			.byte	$84,$4d,$49,$00,$0b,$30,$01,$dc
>2260	04 36 17 04 84 40 00 14			.byte	$04,$36,$17,$04,$84,$40,$00,$14
>2268	31 01 dc 16 32 1a 0a 0e			.byte	$31,$01,$dc,$16,$32,$1a,$0a,$0e
>2270	84 8b 43 76 fd 06 35 36			.byte	$84,$8b,$43,$76,$fd,$06,$35,$36
>2278	32 35 00 0c 32 01 dc 0d			.byte	$32,$35,$00,$0c,$32,$01,$dc,$0d
>2280	30 14 b7 84 fe 02 00 0f			.byte	$30,$14,$b7,$84,$fe,$02,$00,$0f
>2288	33 01 dc 14 34 13 13 14			.byte	$33,$01,$dc,$14,$34,$13,$13,$14
>2290	bb 84 8b 4d 68 00 08 34			.byte	$bb,$84,$8b,$4d,$68,$00,$08,$34
>2298	01 dc 19 84 40 00 0d 35			.byte	$01,$dc,$19,$84,$40,$00,$0d,$35
>22a0	01 dc 0c 35 19 0a b7 84			.byte	$01,$dc,$0c,$35,$19,$0a,$b7,$84
>22a8	fe 02 00 11 36 01 dc 04			.byte	$fe,$02,$00,$11,$36,$01,$dc,$04
>22b0	36 10 84 8b 43 48 fd 05			.byte	$36,$10,$84,$8b,$43,$48,$fd,$05
>22b8	33 37 35 00 13 37 01 dc			.byte	$33,$37,$35,$00,$13,$37,$01,$dc
>22c0	12 32 05 08 03 b7 84 fe			.byte	$12,$32,$05,$08,$03,$b7,$84,$fe
>22c8	07 56 38 41 41 59 00 12			.byte	$07,$56,$38,$41,$41,$59,$00,$12
>22d0	38 01 dc 08 35 02 84 8b			.byte	$38,$01,$dc,$08,$35,$02,$84,$8b
>22d8	46 6c fd 06 30 36 32 35			.byte	$46,$6c,$fd,$06,$30,$36,$32,$35
>22e0	00 0e 39 01 dc 02 37 15			.byte	$00,$0e,$39,$01,$dc,$02,$37,$15
>22e8	84 44 6e fd 03 35 00 31			.byte	$84,$44,$6e,$fd,$03,$35,$00,$31
>22f0	3a 01 dc 0c bd 40 bf 40			.byte	$3a,$01,$dc,$0c,$bd,$40,$bf,$40
>22f8	be 84 40 c0 dc 0c bd 40			.byte	$be,$84,$40,$c0,$dc,$0c,$bd,$40
>2300	bf 41 be 84 40 c0 dc 0c			.byte	$bf,$41,$be,$84,$40,$c0,$dc,$0c
>2308	bd 41 bf 40 be 84 40 c0			.byte	$bd,$41,$bf,$40,$be,$84,$40,$c0
>2310	dc 0c bd 41 bf 41 be 84			.byte	$dc,$0c,$bd,$41,$bf,$41,$be,$84
>2318	41 44 fd 05 33 37 35 00			.byte	$41,$44,$fd,$05,$33,$37,$35,$00
>2320	45 3b 01 dc 01 b8 40 bf			.byte	$45,$3b,$01,$dc,$01,$b8,$40,$bf
>2328	40 be 84 fe 02 c0 dc 01			.byte	$40,$be,$84,$fe,$02,$c0,$dc,$01
>2330	b8 40 bf 41 be 84 fe 02			.byte	$b8,$40,$bf,$41,$be,$84,$fe,$02
>2338	c0 dc 01 b8 40 bf 42 be			.byte	$c0,$dc,$01,$b8,$40,$bf,$42,$be
>2340	84 fe 02 c0 dc 01 b8 41			.byte	$84,$fe,$02,$c0,$dc,$01,$b8,$41
>2348	bf 40 be 84 fe 02 c0 dc			.byte	$bf,$40,$be,$84,$fe,$02,$c0,$dc
>2350	01 b8 41 bf 41 be 84 fe			.byte	$01,$b8,$41,$bf,$41,$be,$84,$fe
>2358	02 c0 dc 01 b8 41 bf 42			.byte	$02,$c0,$dc,$01,$b8,$41,$bf,$42
>2360	be 84 fe 02 00 1b 3c 01			.byte	$be,$84,$fe,$02,$00,$1b,$3c,$01
>2368	dc 0e 30 10 06 08 bc 40			.byte	$dc,$0e,$30,$10,$06,$08,$bc,$40
>2370	be 84 40 c0 dc 0e 30 10			.byte	$be,$84,$40,$c0,$dc,$0e,$30,$10
>2378	06 08 bc 41 be 84 40 00			.byte	$06,$08,$bc,$41,$be,$84,$40,$00
>2380	1a 3d 01 dc 14 38 0d bc			.byte	$1a,$3d,$01,$dc,$14,$38,$0d,$bc
>2388	40 be 84 4c 69 c0 dc 14			.byte	$40,$be,$84,$4c,$69,$c0,$dc,$14
>2390	38 0d bc 41 be 84 8b 42			.byte	$38,$0d,$bc,$41,$be,$84,$8b,$42
>2398	5b 00 52 3e 01 dc 19 38			.byte	$5b,$00,$52,$3e,$01,$dc,$19,$38
>23a0	06 b8 40 bf 40 be 84 fe			.byte	$06,$b8,$40,$bf,$40,$be,$84,$fe
>23a8	03 49 c0 dc 19 38 06 b8			.byte	$03,$49,$c0,$dc,$19,$38,$06,$b8
>23b0	40 bf 41 be 84 fe 02 c0			.byte	$40,$bf,$41,$be,$84,$fe,$02,$c0
>23b8	dc 19 38 06 b8 41 bf 40			.byte	$dc,$19,$38,$06,$b8,$41,$bf,$40
>23c0	be 84 fe 02 c0 dc 19 38			.byte	$be,$84,$fe,$02,$c0,$dc,$19,$38
>23c8	06 b8 41 bf 41 be 84 fe			.byte	$06,$b8,$41,$bf,$41,$be,$84,$fe
>23d0	02 c0 dc 19 38 06 b8 42			.byte	$02,$c0,$dc,$19,$38,$06,$b8,$42
>23d8	bf 40 be 84 fe 02 c0 dc			.byte	$bf,$40,$be,$84,$fe,$02,$c0,$dc
>23e0	19 38 06 b8 42 bf 41 be			.byte	$19,$38,$06,$b8,$42,$bf,$41,$be
>23e8	84 fe 02 00 1b 3f 01 dc			.byte	$84,$fe,$02,$00,$1b,$3f,$01,$dc
>23f0	19 33 03 13 bc 40 be 84			.byte	$19,$33,$03,$13,$bc,$40,$be,$84
>23f8	8b 48 73 c0 dc 19 33 03			.byte	$8b,$48,$73,$c0,$dc,$19,$33,$03
>2400	13 bc 41 be 84 73 00 1d			.byte	$13,$bc,$41,$be,$84,$73,$00,$1d
>2408	40 01 dc 17 34 11 bd 40			.byte	$40,$01,$dc,$17,$34,$11,$bd,$40
>2410	be 84 40 c0 dc 17 34 11			.byte	$be,$84,$40,$c0,$dc,$17,$34,$11
>2418	bd 41 be 84 42 50 fd 05			.byte	$bd,$41,$be,$84,$42,$50,$fd,$05
>2420	36 32 35 00 23 41 01 dc			.byte	$36,$32,$35,$00,$23,$41,$01,$dc
>2428	12 36 0a bc 40 be 84 40			.byte	$12,$36,$0a,$bc,$40,$be,$84,$40
>2430	c0 dc 12 36 0a bc 41 be			.byte	$c0,$dc,$12,$36,$0a,$bc,$41,$be
>2438	84 45 46 c0 dc 12 36 0a			.byte	$84,$45,$46,$c0,$dc,$12,$36,$0a
>2440	bc 42 be 84 4f 44 00 57			.byte	$bc,$42,$be,$84,$4f,$44,$00,$57
>2448	42 01 dc 18 37 15 09 0b			.byte	$42,$01,$dc,$18,$37,$15,$09,$0b
>2450	bc 40 bf 40 be 84 40 c0			.byte	$bc,$40,$bf,$40,$be,$84,$40,$c0
>2458	dc 18 37 15 09 0b bc 40			.byte	$dc,$18,$37,$15,$09,$0b,$bc,$40
>2460	bf 41 be 84 40 c0 dc 18			.byte	$bf,$41,$be,$84,$40,$c0,$dc,$18
>2468	37 15 09 0b bc 41 bf 40			.byte	$37,$15,$09,$0b,$bc,$41,$bf,$40
>2470	be 84 40 c0 dc 18 37 15			.byte	$be,$84,$40,$c0,$dc,$18,$37,$15
>2478	09 0b bc 41 bf 41 be 84			.byte	$09,$0b,$bc,$41,$bf,$41,$be,$84
>2480	40 c0 dc 18 37 15 09 0b			.byte	$40,$c0,$dc,$18,$37,$15,$09,$0b
>2488	bc 42 bf 40 be 84 40 c0			.byte	$bc,$42,$bf,$40,$be,$84,$40,$c0
>2490	dc 18 37 15 09 0b bc 42			.byte	$dc,$18,$37,$15,$09,$0b,$bc,$42
>2498	bf 41 be 84 7b 00 82 43			.byte	$bf,$41,$be,$84,$7b,$00,$82,$43
>24a0	01 dc 0e 39 15 17 b8 40			.byte	$01,$dc,$0e,$39,$15,$17,$b8,$40
>24a8	bf 40 be 84 fe 02 c0 dc			.byte	$bf,$40,$be,$84,$fe,$02,$c0,$dc
>24b0	0e 39 15 17 b8 40 bf 41			.byte	$0e,$39,$15,$17,$b8,$40,$bf,$41
>24b8	be 84 fe 02 c0 dc 0e 39			.byte	$be,$84,$fe,$02,$c0,$dc,$0e,$39
>24c0	15 17 b8 40 bf 42 be 84			.byte	$15,$17,$b8,$40,$bf,$42,$be,$84
>24c8	fe 02 c0 dc 0e 39 15 17			.byte	$fe,$02,$c0,$dc,$0e,$39,$15,$17
>24d0	b8 41 bf 40 be 84 fe 02			.byte	$b8,$41,$bf,$40,$be,$84,$fe,$02
>24d8	c0 dc 0e 39 15 17 b8 41			.byte	$c0,$dc,$0e,$39,$15,$17,$b8,$41
>24e0	bf 41 be 84 fe 02 c0 dc			.byte	$bf,$41,$be,$84,$fe,$02,$c0,$dc
>24e8	0e 39 15 17 b8 41 bf 42			.byte	$0e,$39,$15,$17,$b8,$41,$bf,$42
>24f0	be 84 fe 02 c0 dc 0e 39			.byte	$be,$84,$fe,$02,$c0,$dc,$0e,$39
>24f8	15 17 b8 42 bf 40 be 84			.byte	$15,$17,$b8,$42,$bf,$40,$be,$84
>2500	fe 03 4e c0 dc 0e 39 15			.byte	$fe,$03,$4e,$c0,$dc,$0e,$39,$15
>2508	17 b8 42 bf 41 be 84 fe			.byte	$17,$b8,$42,$bf,$41,$be,$84,$fe
>2510	02 c0 dc 0e 39 15 17 b8			.byte	$02,$c0,$dc,$0e,$39,$15,$17,$b8
>2518	42 bf 42 be 84 fe 02 00			.byte	$42,$bf,$42,$be,$84,$fe,$02,$00
>2520	1c 44 01 dc 03 33 0d 02			.byte	$1c,$44,$01,$dc,$03,$33,$0d,$02
>2528	07 bc 40 be 84 40 c0 dc			.byte	$07,$bc,$40,$be,$84,$40,$c0,$dc
>2530	03 33 0d 02 07 bc 41 be			.byte	$03,$33,$0d,$02,$07,$bc,$41,$be
>2538	84 4a 7a 00 27 45 01 dc			.byte	$84,$4a,$7a,$00,$27,$45,$01,$dc
>2540	1a 34 07 0c 0d ba 40 be			.byte	$1a,$34,$07,$0c,$0d,$ba,$40,$be
>2548	84 40 c0 dc 1a 34 07 0c			.byte	$84,$40,$c0,$dc,$1a,$34,$07,$0c
>2550	0d ba 41 be 84 40 c0 dc			.byte	$0d,$ba,$41,$be,$84,$40,$c0,$dc
>2558	1a 34 07 0c 0d ba 42 be			.byte	$1a,$34,$07,$0c,$0d,$ba,$42,$be
>2560	84 40 00 1b 46 01 d6 fe			.byte	$84,$40,$00,$1b,$46,$01,$d6,$fe
>2568	14 50 61 73 73 65 64 20			.byte	$14,$50,$61,$73,$73,$65,$64,$20
>2570	41 73 73 69 67 6e 6d 65			.byte	$41,$73,$73,$69,$67,$6e,$6d,$65
>2578	6e 74 2e c0 c4 00 00			.byte	$6e,$74,$2e,$c0,$c4,$00,$00

;******  Return to file: modules/hardware/em65816.asm

.c000					StartROM:
.c000	18		clc				clc
.c001	fb		xce				xce
.c002	c2 30		rep #$30			rep 	#$30
.c004	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.c007	1b		tcs				tcs
.c008	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.c00b	e2 30		sep #$30			sep 	#$30
.c00d	c2 30		rep #$30			rep 	#$30						; clear AXY in 16 bit.
.c00f	a9 00		lda #$00			lda 	#$0000
.c011	aa		tax				tax
.c012	a8		tay				tay
.c013	e2 30		sep #$30			sep 	#$30
.c015	5c ae 86 01	jmp $0186ae		jmp BASIC_Start
.c019					TIM_BreakHandler:
.c019	5c 76 83 01	jmp $018376			jmp 	TIM_BreakVector

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.018000					IFT_ClearScreen:
.018000	48		pha				pha
.018001	da		phx				phx
.018002	5a		phy				phy
.018003	20 a9 81	jsr $0181a9			jsr 	IF_Home 					; home cursor
.018006	a2 20		ldx #$20			ldx 	#IF_Height 					; this many lines.
.018008					_IFT_CS0:
.018008	a0 40		ldy #$40			ldy 	#IF_Width 					; this many chars/line
.01800a					_IFT_CS1:
.01800a	a9 20		lda #$20			lda 	#' '						; clear line.
.01800c	20 d5 81	jsr $0181d5			jsr 	IF_Write
.01800f	88		dey				dey
.018010	d0 f8		bne $01800a			bne 	_IFT_CS1
.018012	20 bc 81	jsr $0181bc			jsr 	IF_NewLine 					; next line down
.018015	ca		dex				dex
.018016	d0 f0		bne $018008			bne 	_IFT_CS0
.018018	7a		ply				ply
.018019	fa		plx				plx
.01801a	68		pla				pla
.01801b					IFT_HomeCursor:
.01801b	48		pha				pha
.01801c	20 a9 81	jsr $0181a9			jsr 	IF_Home
.01801f	a9 00		lda #$00			lda 	#0
.018021	8d bd 03	sta $03bd			sta 	IFT_XCursor
.018024	8d be 03	sta $03be			sta 	IFT_YCursor
.018027	68		pla				pla
.018028	60		rts				rts
.018029					IFT_UpLine:
.018029	48		pha				pha
.01802a	ad be 03	lda $03be			lda  	IFT_YCursor 				; get Y
.01802d	3a		dec a				dec 	a 							; line above
.01802e	30 03		bmi $018033			bmi 	_IFTULExit 					; too far, abort
.018030	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos					; set to that line.
.018033					_IFTULExit:
.018033	68		pla				pla
.018034	60		rts				rts
.018035					IFT_PrintCharacter:
.018035	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.018037	f0 23		beq $01805c			beq 	IFT_NewLine
.018039	48		pha				pha
.01803a	20 74 80	jsr $018074			jsr 	IFT_UpperCase 				; make upper case
.01803d	20 d5 81	jsr $0181d5			jsr 	IF_Write 					; write out.
.018040	ee bd 03	inc $03bd			inc 	IFT_XCursor 				; bump x cursor
.018043	ad bd 03	lda $03bd			lda 	IFT_XCursor 				; reached RHS ?
.018046	c9 40		cmp #$40			cmp 	#IF_Width
.018048	d0 03		bne $01804d			bne 	_IFT_PCNotEOL
.01804a	20 5c 80	jsr $01805c			jsr 	IFT_NewLine 				; if so do new line.
.01804d					_IFT_PCNotEOL:
.01804d	68		pla				pla
.01804e	60		rts				rts
.01804f					IFT_Tab:
.01804f	a9 20		lda #$20			lda 	#" " 						; space
.018051	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018054	ad bd 03	lda $03bd			lda 	IFT_XCursor 				; until x % 8 == 0
.018057	29 07		and #$07			and 	#7
.018059	d0 f4		bne $01804f			bne 	IFT_Tab
.01805b	60		rts				rts
.01805c					IFT_NewLine:
.01805c	48		pha				pha
.01805d	20 bc 81	jsr $0181bc			jsr 	IF_NewLine 					; new line on actual screen.
.018060	a9 00		lda #$00			lda 	#0 							; reset x position
.018062	8d bd 03	sta $03bd			sta 	IFT_XCursor
.018065	ee be 03	inc $03be			inc 	IFT_YCursor 				; move down.
.018068	ad be 03	lda $03be			lda 	IFT_YCursor
.01806b	c9 20		cmp #$20			cmp 	#IF_Height 					; reached bottom.
.01806d	d0 03		bne $018072			bne 	_IFT_NL_NotEOS
.01806f	20 7f 80	jsr $01807f			jsr 	IFT_Scroll 					; scroll screen up.
.018072					_IFT_NL_NotEOS:
.018072	68		pla				pla
.018073	60		rts				rts
.018074					IFT_UpperCase:
.018074	c9 61		cmp #$61			cmp 	#"a"
.018076	90 06		bcc $01807e			bcc 	_IFT_UCExit
.018078	c9 7b		cmp #$7b			cmp 	#"z"+1
.01807a	b0 02		bcs $01807e			bcs 	_IFT_UCExit
.01807c	49 20		eor #$20			eor 	#$20
.01807e					_IFT_UCExit:
.01807e	60		rts				rts
.01807f					IFT_Scroll:
.01807f	48		pha				pha 								; save AXY
.018080	da		phx				phx
.018081	5a		phy				phy
.018082	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.018084					_IFT_SLoop:
.018084	20 a4 80	jsr $0180a4			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.018087	e8		inx				inx
.018088	e0 1f		cpx #$1f			cpx 	#IF_Height-1				; do whole screen
.01808a	d0 f8		bne $018084			bne 	_IFT_SLoop
.01808c	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.01808e	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.018091	a2 40		ldx #$40			ldx 	#IF_Width 					; blank line
.018093					_IFT_SBlank:
.018093	a9 20		lda #$20			lda 	#32
.018095	20 d5 81	jsr $0181d5			jsr 	IF_Write
.018098	ca		dex				dex
.018099	d0 f8		bne $018093			bne 	_IFT_SBlank
.01809b	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.01809d	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.0180a0	7a		ply				ply
.0180a1	fa		plx				plx
.0180a2	68		pla				pla
.0180a3	60		rts				rts
.0180a4					_IFT_ScrollLine:
.0180a4	da		phx				phx
.0180a5	da		phx				phx
.0180a6	8a		txa				txa 								; copy line into buffer.
.0180a7	1a		inc a				inc 	a 							; next line down.
.0180a8	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.0180ab	a2 00		ldx #$00			ldx 	#0
.0180ad					_IFTScrollCopy1:
.0180ad	20 cc 81	jsr $0181cc			jsr 	IF_Read
.0180b0	9d bf 03	sta $03bf,x			sta 	IFT_Buffer,x
.0180b3	e8		inx				inx
.0180b4	e0 40		cpx #$40			cpx 	#IF_Width
.0180b6	d0 f5		bne $0180ad			bne 	_IFTScrollCopy1
.0180b8	68		pla				pla
.0180b9	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.0180bc	a2 00		ldx #$00			ldx 	#0
.0180be					_IFTScrollCopy2:
.0180be	bd bf 03	lda $03bf,x			lda 	IFT_Buffer,x
.0180c1	20 d5 81	jsr $0181d5			jsr 	IF_Write
.0180c4	e8		inx				inx
.0180c5	e0 40		cpx #$40			cpx 	#IF_Width
.0180c7	d0 f5		bne $0180be			bne 	_IFTScrollCopy2
.0180c9	fa		plx				plx
.0180ca	60		rts				rts
.0180cb					IFT_SetYPos:
.0180cb	48		pha				pha
.0180cc	da		phx				phx
.0180cd	aa		tax				tax
.0180ce	20 1b 80	jsr $01801b			jsr 	IFT_HomeCursor
.0180d1	e0 00		cpx #$00			cpx 	#0
.0180d3	f0 09		beq $0180de			beq 	_IFT_MOAExit
.0180d5					_IFT_MOALoop:
.0180d5	20 bc 81	jsr $0181bc			jsr 	IF_NewLine
.0180d8	ee be 03	inc $03be			inc 	IFT_YCursor
.0180db	ca		dex				dex
.0180dc	d0 f7		bne $0180d5			bne		_IFT_MOALoop
.0180de					_IFT_MOAExit:
.0180de	fa		plx				plx
.0180df	68		pla				pla
.0180e0	60		rts				rts
.0180e1					IFT_GetKeyCursor:
.0180e1	20 e9 80	jsr $0180e9			jsr 	_IFT_FlipCursor 			; reverse current
.0180e4					_IFT_GKCWait:
.0180e4	20 e6 81	jsr $0181e6			jsr 	IF_GetKey 					; get key
.0180e7	f0 fb		beq $0180e4			beq 	_IFT_GKCWait
.0180e9					_IFT_FlipCursor:
.0180e9	48		pha				pha 								; save
.0180ea	20 cc 81	jsr $0181cc			jsr 	IF_Read 					; read
.0180ed	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.0180f0	49 80		eor #$80			eor 	#$80 						; reverse
.0180f2	20 d5 81	jsr $0181d5			jsr 	IF_Write 					; write
.0180f5	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.0180f8	68		pla				pla
.0180f9	60		rts				rts
.0180fa					IFT_ReadLine:
.0180fa	48		pha				pha
.0180fb					_IFT_RLLoop:
.0180fb	20 e1 80	jsr $0180e1			jsr 	IFT_GetKeyCursor 			; get keystroke
.0180fe	c9 0d		cmp #$0d			cmp 	#13							; return
.018100	f0 7d		beq $01817f			beq 	_IFT_RLExit
.018102	c9 20		cmp #$20			cmp 	#32 						; control character
.018104	90 05		bcc $01810b			bcc 	_IFT_Control
.018106	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018109	80 f0		bra $0180fb			bra 	_IFT_RLLoop
.01810b					_IFT_Control:
.01810b	c9 01		cmp #$01			cmp 	#"A"-64
.01810d	f0 26		beq $018135			beq 	_IFT_Left
.01810f	c9 04		cmp #$04			cmp 	#"D"-64
.018111	f0 2e		beq $018141			beq 	_IFT_Right
.018113	c9 17		cmp #$17			cmp 	#"W"-64
.018115	f0 36		beq $01814d			beq 	_IFT_Up
.018117	c9 13		cmp #$13			cmp 	#"S"-64
.018119	f0 3e		beq $018159			beq 	_IFT_Down
.01811b	c9 08		cmp #$08			cmp 	#"H"-64
.01811d	f0 09		beq $018128			beq 	_IFT_Backspace
.01811f	c9 1a		cmp #$1a			cmp 	#"Z"-64
.018121	d0 d8		bne $0180fb			bne 	_IFT_RLLoop
.018123	20 00 80	jsr $018000			jsr 	IFT_ClearScreen				; clear CTL-Z
.018126	80 d3		bra $0180fb			bra 	_IFT_RLLoop
.018128					_IFT_Backspace:
.018128	ad bd 03	lda $03bd			lda 	IFT_XCursor 				; check not start of line.
.01812b	f0 ce		beq $0180fb			beq 	_IFT_RLLoop
.01812d	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.018130	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.018132	20 d5 81	jsr $0181d5			jsr 	IF_Write
.018135					_IFT_Left:
.018135	ce bd 03	dec $03bd			dec 	IFT_XCursor 				; left CTL-W
.018138	10 29		bpl $018163			bpl 	_IFT_Reposition
.01813a	a9 3f		lda #$3f			lda 	#IF_Width-1
.01813c					_IFT_SetX:
.01813c	8d bd 03	sta $03bd			sta 	IFT_XCursor
.01813f	80 22		bra $018163			bra 	_IFT_Reposition
.018141					_IFT_Right:
.018141	ee bd 03	inc $03bd			inc 	IFT_XCursor
.018144	ad bd 03	lda $03bd			lda 	IFT_XCursor
.018147	49 40		eor #$40			eor 	#IF_Width
.018149	f0 f1		beq $01813c			beq 	_IFT_SetX
.01814b	80 16		bra $018163			bra 	_IFT_Reposition
.01814d					_IFT_Up:
.01814d	ce be 03	dec $03be			dec 	IFT_YCursor
.018150	10 11		bpl $018163			bpl 	_IFT_Reposition
.018152	a9 1f		lda #$1f			lda 	#IF_Height-1
.018154					_IFT_SetY:
.018154	8d be 03	sta $03be			sta 	IFT_YCursor
.018157	80 0a		bra $018163			bra 	_IFT_Reposition
.018159					_IFT_Down:
.018159	ee be 03	inc $03be			inc 	IFT_YCursor
.01815c	ad be 03	lda $03be			lda 	IFT_YCursor
.01815f	49 20		eor #$20			eor 	#IF_Height
.018161	f0 f1		beq $018154			beq 	_IFT_SetY
.018163					_IFT_Reposition:
.018163	ad bd 03	lda $03bd			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.018166	48		pha				pha
.018167	ad be 03	lda $03be			lda 	IFT_YCursor
.01816a	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.01816d	68		pla				pla
.01816e	aa		tax				tax
.01816f	e0 00		cpx #$00			cpx 	#0
.018171	f0 88		beq $0180fb			beq 	_IFT_RLLoop
.018173					_IFT_MoveRight:
.018173	20 cc 81	jsr $0181cc			jsr 	IF_Read
.018176	ee bd 03	inc $03bd			inc 	IFT_XCursor
.018179	ca		dex				dex
.01817a	d0 f7		bne $018173			bne 	_IFT_MoveRight
.01817c	4c fb 80	jmp $0180fb			jmp 	_IFT_RLLoop
.01817f					_IFT_RLExit:
.01817f	ad be 03	lda $03be			lda 	IFT_YCursor 				; go to start of line.
.018182	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.018185	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.018187					_IFT_RLRead:
.018187	20 cc 81	jsr $0181cc			jsr 	IF_Read
.01818a	9d 23 04	sta $0423,x			sta 	IFT_LineBuffer,x
.01818d	e8		inx				inx
.01818e	e0 40		cpx #$40			cpx 	#IF_Width
.018190	d0 f5		bne $018187			bne 	_IFT_RLRead
.018192					_IFT_RL_Trim:
.018192	ca		dex				dex 	 							; previous char
.018193	30 07		bmi $01819c			bmi 	_IFT_Found 					; gone too far
.018195	bd 23 04	lda $0423,x			lda 	IFT_LineBuffer,x			; go back if space
.018198	c9 20		cmp #$20			cmp 	#" "
.01819a	f0 f6		beq $018192			beq 	_IFT_RL_Trim
.01819c					_IFT_Found:
.01819c	e8		inx				inx 								; forward to non-space
.01819d	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.01819f	9d 23 04	sta $0423,x			sta 	IFT_LineBuffer,x
.0181a2	68		pla				pla
.0181a3	a2 23		ldx #$23			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.0181a5	a0 04		ldy #$04			ldy 	#IFT_LineBuffer >> 8
.0181a7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_em65816.asm

=64					IF_Width 	= 64 							; characters across
=32					IF_Height 	= 32 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line.
=8					IF_XPos 	= 8 							; current position, horizontal.
=$f0000					IF_Screen = $F0000							; 2k screen RAM here
=$f8010					IF_PKeyboard = $F8010						; Keyboard port.
=$f8000					IF_PBreak = $F8000 							; Break key.
.0181a8					IF_Reset:
.0181a8	60		rts				rts
.0181a9					IF_Home:
.0181a9	48		pha				pha
.0181aa	64 08		stz $08				stz 	IF_XPos 					; zero X position
.0181ac	a9 00		lda #$00			lda 	#IF_Screen & $FF 			; set r/w pos.
.0181ae	85 04		sta $04				sta 	IF_Pos
.0181b0	a9 00		lda #$00			lda 	#(IF_Screen >> 8) & $FF
.0181b2	85 05		sta $05				sta 	IF_Pos+1
.0181b4	a9 0f		lda #$0f			lda 	#IF_Screen >> 16
.0181b6	85 06		sta $06				sta 	IF_Pos+2
.0181b8	64 07		stz $07				stz 	IF_Pos+3
.0181ba	68		pla				pla
.0181bb	60		rts				rts
.0181bc					IF_NewLine:
.0181bc	48		pha				pha
.0181bd	64 08		stz $08				stz 	IF_XPos						; back to start of line
.0181bf	18		clc				clc 								; down one line
.0181c0	a5 04		lda $04				lda 	IF_Pos
.0181c2	69 40		adc #$40			adc 	#64
.0181c4	85 04		sta $04				sta 	IF_Pos
.0181c6	90 02		bcc $0181ca			bcc 	_IF_NoCarry 				; carry through.
.0181c8	e6 05		inc $05				inc 	IF_Pos+1
.0181ca					_IF_NoCarry:
.0181ca	68		pla				pla
.0181cb	60		rts				rts
.0181cc					IF_Read:
.0181cc	5a		phy				phy 								; save current Y
.0181cd	a4 08		ldy $08				ldy 	IF_XPos 					; read character at current position
.0181cf	b7 04		lda [$04],y			lda 	[IF_Pos],y
.0181d1	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181d3	7a		ply				ply									; restore Y
.0181d4	60		rts				rts
.0181d5					IF_Write:
.0181d5	5a		phy				phy 								; save current Y
.0181d6	a4 08		ldy $08				ldy 	IF_XPos 					; write character at current position
.0181d8	97 04		sta [$04],y			sta 	[IF_Pos],y
.0181da	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181dc	7a		ply				ply									; restore Y
.0181dd	60		rts				rts
.0181de					IF_LeftOne:
.0181de	c6 08		dec $08				dec 	IF_XPos
.0181e0	60		rts				rts
.0181e1					IF_CheckBreak:
.0181e1	af 00 80 0f	lda $0f8000			lda 	IF_PBreak					; non-zero if Ctrl+C pressed.
.0181e5	60		rts				rts
.0181e6					IF_GetKey:
.0181e6	af 10 80 0f	lda $0f8010			lda 	IF_PKeyboard				; read keyboard
.0181ea	f0 08		beq $0181f4			beq		_IFGK_NoKey 				; skip if zero,no key pressed
.0181ec	48		pha				pha 								; key pressed, clear queue.
.0181ed	a9 00		lda #$00			lda 	#0
.0181ef	8f 10 80 0f	sta $0f8010			sta 	IF_PKeyboard
.0181f3	68		pla				pla
.0181f4					_IFGK_NoKey:
.0181f4	09 00		ora #$00			ora 	#0							; set Z flag appropriately.
.0181f6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.0181f7					TIM_Error:
.0181f7	20 29 80	jsr $018029			jsr 	IFT_UpLine 					; go up one line.
.0181fa	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.0181fc	80 02		bra $018200			bra 	TIM_ShowPrompt
.0181fe					TIM_NewCommand:
.0181fe	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.018200					TIM_ShowPrompt:
.018200	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.018203	20 fa 80	jsr $0180fa			jsr 	IFT_ReadLine	 			; get character, go to next line
.018206	20 5c 80	jsr $01805c			jsr 	IFT_NewLine					; go to next line.
.018209	86 10		stx $10				stx 	zTemp1 						; save line read address
.01820b	84 11		sty $11				sty 	zTemp1+1
.01820d	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.01820f	b1 10		lda ($10),y			lda 	(zTemp1),y
.018211	c9 3f		cmp #$3f			cmp 	#"?"
.018213	f0 04		beq $018219			beq 	TIM_SkipFirst
.018215	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.018217	d0 01		bne $01821a			bne 	TIM_NotDot
.018219					TIM_SkipFirst:
.018219	c8		iny				iny
.01821a					TIM_NotDot:
.01821a	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.01821c	c9 52		cmp #$52			cmp 	#"R"						; show registers
.01821e	f0 6b		beq $01828b			beq 	TIM_ShowRegisters
.018220	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.018222	f0 12		beq $018236			beq 	TIM_ShowMemory
.018224	c9 47		cmp #$47			cmp 	#"G"						; execute
.018226	f0 49		beq $018271			beq 	TIM_Execute
.018228	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.01822a	f0 07		beq $018233			beq 	TIM_GoLoadMemory
.01822c	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.01822e	d0 c7		bne $0181f7			bne 	TIM_Error
.018230	4c af 83	jmp $0183af			jmp 	TIM_UpdateRegisters
.018233					TIM_GoLoadMemory:
.018233	4c df 83	jmp $0183df			jmp 	TIM_LoadMemory
.018236					TIM_ShowMemory:
.018236	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.018239	b0 bc		bcs $0181f7			bcs 	TIM_Error
.01823b	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.01823d	85 12		sta $12				sta 	zTemp2
.01823f	a5 15		lda $15				lda 	zTemp3+1
.018241	85 13		sta $13				sta 	zTemp2+1
.018243	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.018246	90 08		bcc $018250			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.018248	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.01824a	85 14		sta $14				sta 	zTemp3
.01824c	a5 13		lda $13				lda 	zTemp2+1
.01824e	85 15		sta $15				sta 	zTemp3+1
.018250					_TIMSM_Start:
.018250	20 03 83	jsr $018303			jsr 	TIM_WriteLine 				; write one line of hex out
.018253	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.018255	18		clc				clc
.018256	69 10		adc #$10			adc 	#16
.018258	85 12		sta $12				sta 	zTemp2
.01825a	90 02		bcc $01825e			bcc 	_TIMSM_NoCarry
.01825c	e6 13		inc $13				inc 	zTemp2+1
.01825e					_TIMSM_NoCarry:
.01825e	20 e1 81	jsr $0181e1			jsr 	IF_CheckBreak 				; check CTL+C
.018261	d0 0b		bne $01826e			bne 	_TIMSM_Ends 				; if pressed break out.
.018263	38		sec				sec 								; check past the end address in zTemp3
.018264	a5 14		lda $14				lda 	zTemp3
.018266	e5 12		sbc $12				sbc 	zTemp2
.018268	a5 15		lda $15				lda 	zTemp3+1
.01826a	e5 13		sbc $13				sbc 	zTemp2+1
.01826c	10 e2		bpl $018250			bpl 	_TIMSM_Start
.01826e					_TIMSM_Ends:
.01826e	4c fe 81	jmp $0181fe			jmp 	TIM_NewCommand
.018271					TIM_Execute:
.018271	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; get the execute address
.018274	b0 81		bcs $0181f7			bcs 	TIM_Error 					; not legitimate
.018276	ae bb 03	ldx $03bb			ldx 	TIM_SP 						; set up SP
.018279	9a		txs				txs
.01827a	ad b6 03	lda $03b6			lda 	TIM_SR 						; Status for PLP
.01827d	48		pha				pha
.01827e	ad b7 03	lda $03b7			lda 	TIM_A 						; restore AXYZ
.018281	ae b8 03	ldx $03b8			ldx 	TIM_X
.018284	ac b9 03	ldy $03b9			ldy 	TIM_Y
.018287	28		plp				plp 								; and PS Byte.
.018288	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.01828b					TIM_Start:
.01828b					TIM_ShowRegisters:
.01828b	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.01828e	8d b5 03	sta $03b5			sta 	TIM_IRQ+1
.018291	ad ff ff	lda $ffff			lda 	$FFFF
.018294	8d b4 03	sta $03b4			sta 	TIM_IRQ
.018297	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.018299					_TIMSR_Text:
.018299	bf ca 82 01	lda $0182ca,x			lda 	_TIMSR_Label,x
.01829d	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182a0	e8		inx				inx
.0182a1	e0 20		cpx #$20			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.0182a3	d0 f4		bne $018299			bne 	_TIMSR_Text
.0182a5	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.0182a7					_TIMSR_Skip:
.0182a7	e8		inx				inx
.0182a8					_TIMSR_LoopSpace:
.0182a8	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.0182aa	b0 04		bcs $0182b0			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.0182ac	8a		txa				txa
.0182ad	4a		lsr a				lsr 	a
.0182ae	b0 05		bcs $0182b5			bcs 	_TIMSR_NoSpace
.0182b0					_TIMSR_Space:
.0182b0	a9 20		lda #$20			lda 	#" "
.0182b2	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182b5					_TIMSR_NoSpace:
.0182b5	bd b2 03	lda $03b2,x			lda 	TIM_PC,x 					; output hex value.
.0182b8	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.0182bb	e8		inx				inx
.0182bc	e0 08		cpx #$08			cpx 	#TIM_Z-TIM_PC
.0182be	f0 e7		beq $0182a7			beq 	_TIMSR_Skip
.0182c0	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.0182c2	d0 e4		bne $0182a8			bne 	_TimSR_LoopSpace
.0182c4	20 5c 80	jsr $01805c			jsr 	IFT_NewLine 				; new line
.0182c7	4c fe 81	jmp $0181fe			jmp	 	TIM_NewCommand 				; new command.
.0182ca					_TIMSR_Label:
>0182ca	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>0182d2	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>0182e2	52
>0182e3	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.0182ea					_TIMSR_LabelEnd:
.0182ea					TIM_WriteHex:
.0182ea	48		pha				pha 								; save A
.0182eb	4a		lsr a				lsr 	a 							; shift MSB->LSB
.0182ec	4a		lsr a				lsr 	a
.0182ed	4a		lsr a				lsr 	a
.0182ee	4a		lsr a				lsr 	a
.0182ef	20 f3 82	jsr $0182f3			jsr 	_TIMWH_Nibble 				; print MSB
.0182f2	68		pla				pla 								; restore and print LSB
.0182f3					_TIMWH_Nibble:
.0182f3	48		pha				pha
.0182f4	29 0f		and #$0f			and 	#15 						; mask out
.0182f6	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.0182f8	90 02		bcc $0182fc			bcc 	_TIMWHNoLetter
.0182fa	69 06		adc #$06			adc 	#6
.0182fc					_TIMWHNoLetter:
.0182fc	69 30		adc #$30			adc 	#48
.0182fe	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter 			; print it out.
.018301	68		pla				pla
.018302	60		rts				rts
.018303					TIM_WriteLine:
.018303	a9 2e		lda #$2e			lda 	#"." 						; prompt
.018305	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018308	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.01830a	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01830d	a5 13		lda $13				lda 	zTemp2+1 					; write address
.01830f	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.018312	a5 12		lda $12				lda 	zTemp2
.018314	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.018317	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.018319					_TIMWL_Loop:
.018319	a9 20		lda #$20			lda 	#" "
.01831b	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01831e	b1 12		lda ($12),y			lda 	(zTemp2),y
.018320	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.018323	c8		iny				iny
.018324	c0 10		cpy #$10			cpy 	#16
.018326	d0 f1		bne $018319			bne 	_TIMWL_Loop
.018328	4c 5c 80	jmp $01805c			jmp 	IFT_NewLine 				; new line and exit
.01832b					TIM_GetHex:
.01832b	c8		iny				iny
.01832c	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.01832e	c9 20		cmp #$20			cmp 	#32
.018330	f0 f9		beq $01832b			beq 	TIM_GetHex
.018332	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.018334	f0 f5		beq $01832b			beq 	TIM_GetHex
.018336	20 5f 83	jsr $01835f			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.018339	b0 23		bcs $01835e			bcs 	_TIMGH_Exit					; if first bad then exit now.
.01833b	a9 00		lda #$00			lda 	#0 							; zero result
.01833d	85 14		sta $14				sta 	zTemp3
.01833f	85 15		sta $15				sta 	zTemp3+1
.018341					_TIM_GHLoop:
.018341	20 5f 83	jsr $01835f			jsr 	TIM_GetHexCharacter 		; get next character
.018344	b0 17		bcs $01835d			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.018346	c8		iny				iny 								; skip over it.
.018347	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.018349	26 15		rol $15				rol 	zTemp3+1
.01834b	06 14		asl $14				asl 	zTemp3 						; now x 2
.01834d	26 15		rol $15				rol 	zTemp3+1
.01834f	06 14		asl $14				asl 	zTemp3						; now x 4
.018351	26 15		rol $15				rol 	zTemp3+1
.018353	06 14		asl $14				asl 	zTemp3 						; now x 8
.018355	26 15		rol $15				rol 	zTemp3+1
.018357	05 14		ora $14				ora 	zTemp3 						; OR result in
.018359	85 14		sta $14				sta 	zTemp3
.01835b	80 e4		bra $018341			bra 	_TIM_GHLoop 				; loop round again.
.01835d					_TIMGH_Okay:
.01835d	18		clc				clc
.01835e					_TIMGH_Exit:
.01835e	60		rts				rts
.01835f					TIM_GetHexCharacter:
.01835f	b1 10		lda ($10),y			lda 	(zTemp1),y
.018361	38		sec				sec
.018362	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.018364	90 0e		bcc $018374			bcc 	_TIM_GHCFail
.018366	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.018368	90 0b		bcc $018375			bcc 	_TIM_GHCExit
.01836a	c9 11		cmp #$11			cmp 	#65-48						; < A
.01836c	90 06		bcc $018374			bcc		_TIM_GHCFail
.01836e	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.018370	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.018372	90 01		bcc $018375			bcc		_TIM_GHCExit
.018374					_TIM_GHCFail:
.018374	38		sec				sec
.018375					_TIM_GHCExit:
.018375	60		rts				rts
.018376					TIM_BreakVector:
.018376	da		phx				phx									; save X/A on stack
.018377	48		pha				pha
.018378	ba		tsx				tsx 								; X points to S
.018379	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.01837c	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.01837e	d0 03		bne $018383			bne 	_TIMBreak					; if set, it's BRK
.018380	68		pla				pla 								; abandon routine.
.018381	fa		plx				plx
.018382	40		rti				rti
.018383					_TIMBreak:
.018383	68		pla				pla 								; save A X Y and maybe Z
.018384	8d b7 03	sta $03b7			sta 	TIM_A
.018387	fa		plx				plx
.018388	8e b8 03	stx $03b8			stx 	TIM_X
.01838b	8c b9 03	sty $03b9			sty 	TIM_Y
.01838e	68		pla				pla 								; get Status Register
.01838f	8d b6 03	sta $03b6			sta 	TIM_SR
.018392	68		pla				pla
.018393	8d b3 03	sta $03b3			sta 	TIM_PC+1 					; save calling address
.018396	68		pla				pla
.018397	8d b2 03	sta $03b2			sta 	TIM_PC 						; high byte
.01839a	ad b3 03	lda $03b3			lda 	TIM_PC+1 					; dec PC to point right.
.01839d	d0 03		bne $0183a2			bne 	_TIMDecrement 				; brk bumps it.
.01839f	ce b2 03	dec $03b2			dec 	TIM_PC
.0183a2					_TIMDecrement:
.0183a2	ce b3 03	dec $03b3			dec 	TIM_PC+1
.0183a5	ba		tsx				tsx 								; and copy SP
.0183a6	8e bb 03	stx $03bb			stx 	TIM_SP
.0183a9	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.0183ab	9a		txs				txs
.0183ac	4c 8b 82	jmp $01828b			jmp 	TIM_Start 					; and start up TIM monitor.
.0183af					TIM_UpdateRegisters:
.0183af	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; PC
.0183b2	b0 28		bcs $0183dc			bcs 	_TIMURFail
.0183b4	a5 14		lda $14				lda 	zTemp3
.0183b6	8d b3 03	sta $03b3			sta 	Tim_PC+1
.0183b9	a5 15		lda $15				lda 	zTemp3+1
.0183bb	8d b2 03	sta $03b2			sta 	Tim_PC
.0183be	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; ignore IRQ
.0183c1	b0 19		bcs $0183dc			bcs 	_TIMURFail
.0183c3	a2 00		ldx #$00			ldx 	#0
.0183c5					_TIM_URLoop:
.0183c5	e0 04		cpx #$04			cpx 	#Tim_Z-Tim_SR
.0183c7	d0 01		bne $0183ca			bne 	_TIM_1
.0183c9	e8		inx				inx
.0183ca					_TIM_1:
.0183ca	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; registers
.0183cd	b0 0d		bcs $0183dc			bcs 	_TIMURFail
.0183cf	a5 14		lda $14				lda 	zTemp3
.0183d1	9d b6 03	sta $03b6,x			sta 	Tim_SR,x
.0183d4	e8		inx				inx
.0183d5	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.0183d7	d0 ec		bne $0183c5			bne 	_TIM_URLoop
.0183d9	4c fe 81	jmp $0181fe			jmp 	TIM_NewCommand
.0183dc					_TIMURFail:
.0183dc	4c f7 81	jmp $0181f7			jmp 	TIM_Error
.0183df					TIM_LoadMemory:
.0183df	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; target address => zTemp2
.0183e2	a5 14		lda $14				lda 	zTemp3
.0183e4	85 12		sta $12				sta 	zTemp2
.0183e6	a5 15		lda $15				lda 	zTemp3+1
.0183e8	85 13		sta $13				sta 	zTemp2+1
.0183ea					_TIM_LMLoop:
.0183ea	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; next byte ?
.0183ed	b0 0e		bcs $0183fd			bcs 	_TIMLMDone 					; no more
.0183ef	a2 00		ldx #$00			ldx 	#0							; write out.
.0183f1	a5 14		lda $14				lda 	zTemp3
.0183f3	81 12		sta ($12,x)			sta 	(zTemp2,x)
.0183f5	e6 12		inc $12				inc 	zTemp2 						; bump address
.0183f7	d0 f1		bne $0183ea			bne 	_TIM_LMLoop
.0183f9	e6 13		inc $13				inc 	zTemp2+1
.0183fb	80 ed		bra $0183ea			bra 	_TIM_LMLoop
.0183fd					_TIMLMDone:
.0183fd	4c fe 81	jmp $0181fe			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/errors.asm

.018400					SyntaxError:
.018400	20 2f 84	jsr $01842f			jsr 	ERR_Handler
>018403	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>01840b	72 72 6f 72 00
.018410					TypeError:
.018410	20 2f 84	jsr $01842f			jsr 	ERR_Handler
>018413	57 72 6f 6e 67 20 74 79				.text 	"Wrong type",0
>01841b	70 65 00
.01841e					BadParamError:
.01841e	20 2f 84	jsr $01842f			jsr 	ERR_Handler
>018421	42 61 64 20 50 61 72 61				.text 	"Bad Parameter",0
>018429	6d 65 74 65 72 00
.01842f					ERR_Handler:
.01842f	a0 00		ldy #$00			ldy 	#0
.018431	c8		iny				iny
.018432	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018434	85 80		sta $80				sta 	XS_Mantissa
.018436	c8		iny				iny
.018437	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018439	85 81		sta $81				sta 	XS_Mantissa+1
.01843b	fa		plx				plx 								; address in XY
.01843c	7a		ply				ply
.01843d	e8		inx				inx 								; bump, because of RTS/JSR address -1
.01843e	d0 01		bne $018441			bne 	_EHNoSkip
.018440	c8		iny				iny
.018441					_EHNoSkip:
.018441	20 60 84	jsr $018460			jsr 	PrintROMMessage 			; print message from ROM.
.018444	a5 80		lda $80				lda 	XS_Mantissa					; line number = 0
.018446	05 81		ora $81				ora 	XS_Mantissa+1
.018448	f0 0c		beq $018456			beq 	_EHNoLine
.01844a	a2 5b		ldx #$5b			ldx 	#_EHAt & $FF 				; print " at "
.01844c	a0 84		ldy #$84			ldy 	#(_EHAt >> 8) & $FF
.01844e	20 60 84	jsr $018460			jsr 	PrintROMMessage
.018451	a2 00		ldx #$00			ldx 	#0 							; Print line number
.018453	20 75 84	jsr $018475			jsr 	Print16BitInteger
.018456					_EHNoLine:
.018456	80 fe		bra $018456			bra 	_EHNoLine
.018458	4c d1 86	jmp $0186d1			jmp 	WarmStart
>01845b	20 61 74 20 00			_EHAt:	.text 	" at ",0
.018460					PrintROMMessage:
.018460	86 1a		stx $1a				stx 	zLTemp1 					; save addres
.018462	84 1b		sty $1b				sty 	zLTemp1+1
.018464	4b		phk				phk
.018465	68		pla				pla
.018466	85 1c		sta $1c				sta 	ZLTemp1+2
.018468	a0 00		ldy #$00			ldy 	#0
.01846a					_PRMLoop:
.01846a	b7 1a		lda [$1a],y			lda 	[zLTemp1],y
.01846c	f0 06		beq $018474			beq		_PRMExit
.01846e	c8		iny				iny
.01846f	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018472	80 f6		bra $01846a			bra 	_PRMLoop
.018474					_PRMExit:
.018474	60		rts				rts
.018475					Print16BitInteger:
.018475	a9 00		lda #$00			lda 	#0 							; make 32 bit
.018477	85 82		sta $82				sta 	XS_Mantissa+2
.018479	85 83		sta $83				sta 	XS_Mantissa+3
.01847b	8d 0e 03	sta $030e			sta 	NumBufX 					; reset the conversion pointer
.01847e	aa		tax				tax 								; convert bottom level.
.01847f	20 3b 96	jsr $01963b			jsr 	INTToString 				; make string
.018482	a2 00		ldx #$00			ldx 	#0 							; print buffer
.018484	bd 0f 03	lda $030f,x	_P1Loop:lda 	Num_Buffer,x
.018487	f0 06		beq $01848f			beq 	_P1Exit
.018489	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01848c	e8		inx				inx
.01848d	80 f5		bra $018484			bra 	_P1Loop
.01848f	60		rts		_P1Exit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm


;******  Processing file: modules/basic/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b6					lastUnaryFunction = $b6
.018490					VectorTable:
>018490	cc 8a					.word BinaryOp_And         & $FFFF ; $80 and
>018492	e8 8a					.word BinaryOp_Or          & $FFFF ; $81 or
>018494	04 8b					.word BinaryOp_Xor         & $FFFF ; $82 xor
>018496	04 8b					.word BinaryOp_Eor         & $FFFF ; $83 eor
>018498	3b 8b					.word Binary_Equal         & $FFFF ; $84 =
>01849a	55 8b					.word Binary_NotEqual      & $FFFF ; $85 <>
>01849c	5e 8b					.word Binary_Less          & $FFFF ; $86 <
>01849e	67 8b					.word Binary_LessEqual     & $FFFF ; $87 <=
>0184a0	79 8b					.word Binary_Greater       & $FFFF ; $88 >
>0184a2	70 8b					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>0184a4	fe 8b					.word BinaryOp_Add         & $FFFF ; $8a +
>0184a6	1a 8c					.word BinaryOp_Subtract    & $FFFF ; $8b -
>0184a8	2b 8c					.word BinaryOp_Multiply    & $FFFF ; $8c *
>0184aa	3c 8c					.word BinaryOp_Divide      & $FFFF ; $8d /
>0184ac	4c 85					.word NotImplemented       & $FFFF ; $8e ^
>0184ae	4c 85					.word NotImplemented       & $FFFF ; $8f if
>0184b0	4c 85					.word NotImplemented       & $FFFF ; $90 while
>0184b2	4c 85					.word NotImplemented       & $FFFF ; $91 repeat
>0184b4	4c 85					.word NotImplemented       & $FFFF ; $92 for
>0184b6	4c 85					.word NotImplemented       & $FFFF ; $93 then
>0184b8	4c 85					.word NotImplemented       & $FFFF ; $94 endif
>0184ba	4c 85					.word NotImplemented       & $FFFF ; $95 wend
>0184bc	4c 85					.word NotImplemented       & $FFFF ; $96 until
>0184be	4c 85					.word NotImplemented       & $FFFF ; $97 next
>0184c0	4c 85					.word NotImplemented       & $FFFF ; $98 not
>0184c2	4c 85					.word NotImplemented       & $FFFF ; $99 fn(
>0184c4	41 8d					.word Unary_Abs            & $FFFF ; $9a abs(
>0184c6	82 8e					.word Unary_Asc            & $FFFF ; $9b asc(
>0184c8	2a 9d					.word Unary_Int            & $FFFF ; $9c int(
>0184ca	5b 8d					.word Unary_Peek           & $FFFF ; $9d peek(
>0184cc	ab 9c					.word Unary_Rnd            & $FFFF ; $9e rnd(
>0184ce	c2 8d					.word Unary_Usr            & $FFFF ; $9f usr(
>0184d0	c1 8e					.word Unary_Left           & $FFFF ; $a0 left$(
>0184d2	d6 8e					.word Unary_Right          & $FFFF ; $a1 right$(
>0184d4	a8 8e					.word Unary_Mid            & $FFFF ; $a2 mid$(
>0184d6	1f 90					.word Unary_Spc            & $FFFF ; $a3 spc(
>0184d8	50 8e					.word Unary_Str            & $FFFF ; $a4 str$(
>0184da	e4 8d					.word Unary_Val            & $FFFF ; $a5 val(
>0184dc	99 8e					.word Unary_Len            & $FFFF ; $a6 len(
>0184de	4e 8f					.word Unary_Hex            & $FFFF ; $a7 hex$(
>0184e0	4c 85					.word NotImplemented       & $FFFF ; $a8 sin(
>0184e2	4c 85					.word NotImplemented       & $FFFF ; $a9 cos(
>0184e4	4c 85					.word NotImplemented       & $FFFF ; $aa tan(
>0184e6	4c 85					.word NotImplemented       & $FFFF ; $ab atn(
>0184e8	4c 85					.word NotImplemented       & $FFFF ; $ac exp(
>0184ea	4c 85					.word NotImplemented       & $FFFF ; $ad log(
>0184ec	4c 85					.word NotImplemented       & $FFFF ; $ae sqr(
>0184ee	a4 8f					.word Unary_Dec            & $FFFF ; $af dec(
>0184f0	5f 8d					.word Unary_Deek           & $FFFF ; $b0 deek(
>0184f2	63 8d					.word Unary_Leek           & $FFFF ; $b1 leek(
>0184f4	8f 8d					.word Unary_Mod            & $FFFF ; $b2 mod(
>0184f6	fb 8c					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>0184f8	01 90					.word Unary_Chr            & $FFFF ; $b4 chr$(
>0184fa	4c 85					.word NotImplemented       & $FFFF ; $b5 pos(
>0184fc	4c 85					.word NotImplemented       & $FFFF ; $b6 tab(
>0184fe	4c 85					.word NotImplemented       & $FFFF ; $b7 $
>018500	4c 85					.word NotImplemented       & $FFFF ; $b8 $(
>018502	4c 85					.word NotImplemented       & $FFFF ; $b9 #
>018504	4c 85					.word NotImplemented       & $FFFF ; $ba #(
>018506	4c 85					.word NotImplemented       & $FFFF ; $bb %
>018508	4c 85					.word NotImplemented       & $FFFF ; $bc %(
>01850a	4c 85					.word NotImplemented       & $FFFF ; $bd (
>01850c	4c 85					.word NotImplemented       & $FFFF ; $be )
>01850e	4c 85					.word NotImplemented       & $FFFF ; $bf ,
>018510	e1 87					.word Command_COLON        & $FFFF ; $c0 :
>018512	4c 85					.word NotImplemented       & $FFFF ; $c1 ;
>018514	4c 85					.word NotImplemented       & $FFFF ; $c2 def
>018516	01 89					.word Command_CLR          & $FFFF ; $c3 clr
>018518	12 89					.word Command_STOP         & $FFFF ; $c4 stop
>01851a	4c 85					.word NotImplemented       & $FFFF ; $c5 data
>01851c	4c 85					.word NotImplemented       & $FFFF ; $c6 read
>01851e	df 86					.word Command_DIM          & $FFFF ; $c7 dim
>018520	4c 85					.word NotImplemented       & $FFFF ; $c8 to
>018522	4c 85					.word NotImplemented       & $FFFF ; $c9 step
>018524	4c 85					.word NotImplemented       & $FFFF ; $ca gosub
>018526	4c 85					.word NotImplemented       & $FFFF ; $cb return
>018528	8e 88					.word Command_GOTO         & $FFFF ; $cc goto
>01852a	03 88					.word Command_END          & $FFFF ; $cd end
>01852c	4c 85					.word NotImplemented       & $FFFF ; $ce input
>01852e	e2 87					.word Command_LET          & $FFFF ; $cf let
>018530	4c 85					.word NotImplemented       & $FFFF ; $d0 list
>018532	4c 85					.word NotImplemented       & $FFFF ; $d1 new
>018534	4c 85					.word NotImplemented       & $FFFF ; $d2 old
>018536	4c 85					.word NotImplemented       & $FFFF ; $d3 on
>018538	4c 85					.word NotImplemented       & $FFFF ; $d4 restore
>01853a	4c 85					.word NotImplemented       & $FFFF ; $d5 poke
>01853c	07 88					.word Command_PRINT        & $FFFF ; $d6 print
>01853e	67 87					.word Command_RUN          & $FFFF ; $d7 run
>018540	4c 85					.word NotImplemented       & $FFFF ; $d8 wait
>018542	4c 85					.word NotImplemented       & $FFFF ; $d9 sys
>018544	4c 85					.word NotImplemented       & $FFFF ; $da doke
>018546	4c 85					.word NotImplemented       & $FFFF ; $db loke
>018548	76 88					.word Command_ASSERT       & $FFFF ; $dc assert
>01854a	4c 85					.word NotImplemented       & $FFFF ; $dd get
.01854c					NotImplemented:
.01854c	20 2f 84	jsr $01842f			jsr ERR_Handler
>01854f	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>018557	65 6d 65 6e 74 65 64 00
.01855f					BinaryPrecedence:
>01855f	01					.byte 1    ; $80 and
>018560	01					.byte 1    ; $81 or
>018561	01					.byte 1    ; $82 xor
>018562	01					.byte 1    ; $83 eor
>018563	02					.byte 2    ; $84 =
>018564	02					.byte 2    ; $85 <>
>018565	02					.byte 2    ; $86 <
>018566	02					.byte 2    ; $87 <=
>018567	02					.byte 2    ; $88 >
>018568	02					.byte 2    ; $89 >=
>018569	03					.byte 3    ; $8a +
>01856a	03					.byte 3    ; $8b -
>01856b	04					.byte 4    ; $8c *
>01856c	04					.byte 4    ; $8d /
>01856d	05					.byte 5    ; $8e ^
.01856e					KeywordText:
>01856e	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>018571	4f d2					.byte $4f,$d2                          ; $81 or
>018573	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>018576	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>018579	bd					.byte $bd                              ; $84 =
>01857a	3c be					.byte $3c,$be                          ; $85 <>
>01857c	bc					.byte $bc                              ; $86 <
>01857d	3c bd					.byte $3c,$bd                          ; $87 <=
>01857f	be					.byte $be                              ; $88 >
>018580	3e bd					.byte $3e,$bd                          ; $89 >=
>018582	ab					.byte $ab                              ; $8a +
>018583	ad					.byte $ad                              ; $8b -
>018584	aa					.byte $aa                              ; $8c *
>018585	af					.byte $af                              ; $8d /
>018586	de					.byte $de                              ; $8e ^
>018587	49 c6					.byte $49,$c6                          ; $8f if
>018589	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>01858e	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>018594	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>018597	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>01859b	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>0185a0	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>0185a4	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>0185a9	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>0185ad	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>0185b0	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>0185b3	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>0185b7	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>0185bb	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>0185bf	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>0185c4	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>0185c8	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>0185cc	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>0185d2	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>0185d9	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>0185de	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>0185e2	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>0185e7	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>0185eb	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>0185ef	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>0185f4	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>0185f8	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>0185fc	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>018600	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>018604	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>018608	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>01860c	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>018610	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>018614	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>018619	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>01861e	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>018622	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>018626	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>01862b	50 4f 53 a8				.byte $50,$4f,$53,$a8                  ; $b5 pos(
>01862f	54 41 42 a8				.byte $54,$41,$42,$a8                  ; $b6 tab(
>018633	a4					.byte $a4                              ; $b7 $
>018634	24 a8					.byte $24,$a8                          ; $b8 $(
>018636	a3					.byte $a3                              ; $b9 #
>018637	23 a8					.byte $23,$a8                          ; $ba #(
>018639	a5					.byte $a5                              ; $bb %
>01863a	25 a8					.byte $25,$a8                          ; $bc %(
>01863c	a8					.byte $a8                              ; $bd (
>01863d	a9					.byte $a9                              ; $be )
>01863e	ac					.byte $ac                              ; $bf ,
>01863f	ba					.byte $ba                              ; $c0 :
>018640	bb					.byte $bb                              ; $c1 ;
>018641	44 45 c6				.byte $44,$45,$c6                      ; $c2 def
>018644	43 4c d2				.byte $43,$4c,$d2                      ; $c3 clr
>018647	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $c4 stop
>01864b	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c5 data
>01864f	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c6 read
>018653	44 49 cd				.byte $44,$49,$cd                      ; $c7 dim
>018656	54 cf					.byte $54,$cf                          ; $c8 to
>018658	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c9 step
>01865c	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $ca gosub
>018661	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $cb return
>018667	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $cc goto
>01866b	45 4e c4				.byte $45,$4e,$c4                      ; $cd end
>01866e	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $ce input
>018673	4c 45 d4				.byte $4c,$45,$d4                      ; $cf let
>018676	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $d0 list
>01867a	4e 45 d7				.byte $4e,$45,$d7                      ; $d1 new
>01867d	4f 4c c4				.byte $4f,$4c,$c4                      ; $d2 old
>018680	4f ce					.byte $4f,$ce                          ; $d3 on
>018682	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d4 restore
>018689	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d5 poke
>01868d	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d6 print
>018692	52 55 ce				.byte $52,$55,$ce                      ; $d7 run
>018695	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d8 wait
>018699	53 59 d3				.byte $53,$59,$d3                      ; $d9 sys
>01869c	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $da doke
>0186a0	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $db loke
>0186a4	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $dc assert
>0186aa	47 45 d4				.byte $47,$45,$d4                      ; $dd get
>0186ad	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_pos = $b5
=$b6					token_tab = $b6
=$b7					token_dollar = $b7
=$b8					token_dollarlparen = $b8
=$b9					token_hash = $b9
=$ba					token_hashlparen = $ba
=$bb					token_percent = $bb
=$bc					token_percentlparen = $bc
=$bd					token_lparen = $bd
=$be					token_rparen = $be
=$bf					token_comma = $bf
=$c0					token_colon = $c0
=$c1					token_semicolon = $c1
=$c2					token_def = $c2
=$c3					token_clr = $c3
=$c4					token_stop = $c4
=$c5					token_data = $c5
=$c6					token_read = $c6
=$c7					token_dim = $c7
=$c8					token_to = $c8
=$c9					token_step = $c9
=$ca					token_gosub = $ca
=$cb					token_return = $cb
=$cc					token_goto = $cc
=$cd					token_end = $cd
=$ce					token_input = $ce
=$cf					token_let = $cf
=$d0					token_list = $d0
=$d1					token_new = $d1
=$d2					token_old = $d2
=$d3					token_on = $d3
=$d4					token_restore = $d4
=$d5					token_poke = $d5
=$d6					token_print = $d6
=$d7					token_run = $d7
=$d8					token_wait = $d8
=$d9					token_sys = $d9
=$da					token_doke = $da
=$db					token_loke = $db
=$dc					token_assert = $dc
=$dd					token_get = $dd

;******  Return to file: modules/basic/core.asm

.0186ae					BASIC_Start:
.0186ae	20 a8 81	jsr $0181a8			jsr 	IF_Reset 					; set up and clear screen.
.0186b1	20 00 80	jsr $018000			jsr 	IFT_ClearScreen
.0186b4	a9 5c		lda #$5c			lda 	#$5C 						; JMP Long opcode
.0186b6	8d 0a 03	sta $030a			sta 	LocalVector
.0186b9	8d 06 03	sta $0306			sta 	UserVector
.0186bc	a9 d2		lda #$d2			lda 	#USRDefault & $FF 			; reset USR vector
.0186be	8d 07 03	sta $0307			sta 	UserVector+1
.0186c1	a9 8d		lda #$8d			lda 	#(USRDefault >> 8) & $FF
.0186c3	8d 08 03	sta $0308			sta 	UserVector+2
.0186c6	a9 01		lda #$01			lda 	#(USRDefault >> 16) & $FF
.0186c8	8d 09 03	sta $0309			sta 	UserVector+3
.0186cb	20 68 90	jsr $019068			jsr 	UpdateProgramEnd 			; update the program end.
.0186ce	20 01 89	jsr $018901			jsr 	ResetRunStatus 				; clear everything (CLR command)
.0186d1					WarmStart:
.0186d1	c2 30		rep #$30			rep 	#$30
.0186d3	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.0186d6	1b		tcs				tcs
.0186d7	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.0186da	e2 30		sep #$30			sep 	#$30
.0186dc	4c 67 87	jmp $018767			jmp 	COMMAND_Run

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/dim.asm

.0186df					Command_DIM:
.0186df	98		tya				tya
.0186e0	48		pha				pha 								; push on stack.
.0186e1	20 c4 91	jsr $0191c4			jsr 	VariableExtract 			; get the identifier
.0186e4	ad 8f 03	lda $038f			lda 	Var_Type 					; check it is an array
.0186e7	29 01		and #$01			and 	#1
.0186e9	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.0186eb	d0 6c		bne $018759			bne 	_CDIError
.0186ed	a9 00		lda #$00			lda 	#0 							; reset the DIM index. The dimensions are
.0186ef	8d b1 03	sta $03b1			sta 	UsrArrayIdx 				; built up here and copied in case we autodim
.0186f2					_CDIGetDimension:
.0186f2	ad b1 03	lda $03b1			lda 	UsrArrayIdx 				; done too many ?
.0186f5	c9 06		cmp #$06			cmp 	#ArrayMaxDim*2
.0186f7	f0 60		beq $018759			beq 	_CDIError
.0186f9	20 ad 8a	jsr $018aad			jsr 	EvaluateInteger 			; evaluate an index size
.0186fc	a5 81		lda $81				lda 	XS_Mantissa+1 				; check in range 0-7FFF
.0186fe	29 80		and #$80			and 	#$80
.018700	05 82		ora $82				ora 	XS_Mantissa+2
.018702	05 83		ora $83				ora 	XS_Mantissa+3
.018704	d0 53		bne $018759			bne 	_CDIError
.018706	ae b1 03	ldx $03b1			ldx 	UsrArrayIdx 				; copy into the array table.
.018709	18		clc				clc 								; add 1 - max index => size.
.01870a	a5 80		lda $80				lda 	XS_Mantissa+0
.01870c	69 01		adc #$01			adc 	#1
.01870e	9d a9 03	sta $03a9,x			sta 	UsrArrayDef+0,x
.018711	a5 81		lda $81				lda 	XS_Mantissa+1
.018713	69 00		adc #$00			adc 	#0
.018715	9d aa 03	sta $03aa,x			sta 	UsrArrayDef+1,x
.018718	30 3f		bmi $018759			bmi 	_CDIError 					; could be dim a(32767)
.01871a	e8		inx				inx 								; bump index.
.01871b	e8		inx				inx
.01871c	8e b1 03	stx $03b1			stx 	UsrArrayIdx
.01871f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018721	c8		iny				iny
.018722	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another dimension
.018724	f0 cc		beq $0186f2			beq 	_CDIGetDimension
.018726	88		dey				dey
.018727	20 b6 90	jsr $0190b6			jsr 	CheckNextRParen 			; closing ) present ?
.01872a	ae b1 03	ldx $03b1			ldx 	UsrArrayIdx 				; copy USR array to default
.01872d	a9 ff		lda #$ff			lda 	#$FF 						; put end marker in ArrayDef
.01872f	9d a2 03	sta $03a2,x			sta 	ArrayDef+1,x
.018732					_CDICopy:
.018732	bd a9 03	lda $03a9,x			lda 	UsrArrayDef,x
.018735	9d a1 03	sta $03a1,x			sta 	ArrayDef,x
.018738	ca		dex				dex
.018739	10 f7		bpl $018732			bpl 	_CDICopy
.01873b	68		pla				pla									; position of array identifier
.01873c	85 10		sta $10				sta 	zTemp1
.01873e	98		tya				tya
.01873f	48		pha				pha
.018740	a5 10		lda $10				lda 	zTemp1 						; point to identifier
.018742	a8		tay				tay
.018743	20 c4 91	jsr $0191c4			jsr 	VariableExtract 			; get the identifier
.018746	20 5d 94	jsr $01945d			jsr 	VariableLocate 				; check if it exists already.
.018749	b0 0e		bcs $018759			bcs 	_CDIError
.01874b	20 50 92	jsr $019250			jsr 	VariableCreate 				; create it using the current ArrayDef
.01874e	68		pla				pla 								; restore code position
.01874f	a8		tay				tay
.018750	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018752	c8		iny				iny
.018753	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another DIM
.018755	f0 88		beq $0186df			beq 	Command_DIM
.018757	88		dey				dey
.018758	60		rts				rts
.018759					_CDIError:
.018759	20 2f 84	jsr $01842f			jsr ERR_Handler
>01875c	42 61 64 20 44 49 4d 00			.text "Bad DIM",0
.018764					_CDISyntax:
.018764	4c 00 84	jmp $018400			jmp 	SyntaxError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/run.asm

.018767					Command_RUN:
.018767	20 01 89	jsr $018901			jsr 	ResetRunStatus 				; clear, reset stacks etc.
.01876a	a9 00		lda #$00			lda 	#BasicProgram & $FF
.01876c	85 16		sta $16				sta 	zCodePtr+0
.01876e	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018770	85 17		sta $17				sta 	zCodePtr+1
.018772	a9 00		lda #$00			lda 	#0
.018774	85 18		sta $18				sta 	zCodePtr+2
.018776	85 19		sta $19				sta 	zCodePtr+3
.018778	a0 03		ldy #$03			ldy 	#3
.01877a					RUN_NewLine:
.01877a	a0 00		ldy #$00			ldy 	#0
.01877c	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01877e	c8		iny				iny
.01877f	c8		iny				iny
.018780	c8		iny				iny
.018781	c9 00		cmp #$00			cmp 	#0 							; if the offset is zero then END.
.018783	d0 16		bne $01879b			bne 	RUN_NextCommand
.018785	4c 12 89	jmp $018912			jmp 	Command_STOP 				; go do the command code.
.018788					RUN_Skip:
.018788	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.01878a	c8		iny				iny 								; skip
.01878b	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.01878d	90 0c		bcc $01879b			bcc 	_SEDone 					; so just skip over it.
.01878f	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018791	90 07		bcc $01879a			bcc 	_SEDouble
.018793	98		tya				tya 								; this is Y + 1
.018794	18		clc				clc
.018795	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018797	a8		tay				tay 								; back in Y.
.018798	88		dey				dey 								; fix up, one for the +1, one for the iny
.018799	88		dey				dey
.01879a					_SEDouble:
.01879a	c8		iny				iny
.01879b					_SEDone:
.01879b					RUN_NextCommand:
.01879b	a9 00		lda #$00			lda 	#0 							; this resets temporary string allocation.
.01879d	85 21		sta $21				sta 	zTempStr+1 					; (initialised when first called)
.01879f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0187a1	c9 c0		cmp #$c0			cmp 	#token_Colon 				; skip over colons
.0187a3	f0 e3		beq $018788			beq 	RUN_Skip
.0187a5	c9 00		cmp #$00			cmp 	#0 							; if non-zero execute whatever
.0187a7	d0 0f		bne $0187b8			bne 	RUN_Execute
.0187a9					RUN_NextLine:
.0187a9	a0 00		ldy #$00			ldy 	#0 							; point to offset
.0187ab	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.0187ad	18		clc				clc
.0187ae	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.0187b0	85 16		sta $16				sta 	zCodePtr
.0187b2	90 02		bcc $0187b6			bcc 	_SNLNoCarry
.0187b4	e6 17		inc $17				inc 	zCodePtr+1
.0187b6					_SNLNoCarry:
.0187b6	80 c2		bra $01877a			bra 	RUN_NewLine 				; go do the new line code
.0187b8					RUN_Execute:
.0187b8	c9 f8		cmp #$f8			cmp 	#$F8 						; handle shifts, REM etc.
.0187ba	b0 1e		bcs $0187da			bcs 	RUN_Extension
.0187bc	c8		iny				iny
.0187bd	0a		asl a				asl 	a 							; double the character read.
.0187be	90 14		bcc $0187d4			bcc 	RUN_Default 				; if carry clear was $00-$7F, so try LET.
.0187c0	aa		tax				tax 								; ready to look up.
.0187c1	bf 90 84 01	lda $018490,x			lda 	VectorTable,x 				; copy address into LocalVector
.0187c5	8d 0b 03	sta $030b			sta 	LocalVector+1
.0187c8	bf 91 84 01	lda $018491,x			lda 	VectorTable+1,x
.0187cc	8d 0c 03	sta $030c			sta 	LocalVector+2
.0187cf	20 20 8a	jsr $018a20			jsr 	EVCallLocalVector 			; execute the appropriate code.
.0187d2	80 c7		bra $01879b			bra 	RUN_NextCommand 			; do the next command.
.0187d4					RUN_Default:
.0187d4	88		dey				dey
.0187d5	20 e2 87	jsr $0187e2			jsr 	Command_LET 				; and try LET.
.0187d8	80 c1		bra $01879b			bra 	RUN_NextCommand
.0187da					RUN_Extension:
.0187da	c9 ff		cmp #$ff			cmp 	#$FF 						; if $FF (REM)
.0187dc	f0 aa		beq $018788			beq 	RUN_Skip 					; skip over it.
.0187de	4c 00 84	jmp $018400			jmp 	SyntaxError
.0187e1					Command_COLON:
.0187e1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/let.asm

.0187e2					Command_LET:
.0187e2	20 57 91	jsr $019157			jsr 	VariableFind 				; get reference to one variable.
.0187e5	a9 84		lda #$84			lda 	#token_Equal  				; get equals
.0187e7	20 9f 90	jsr $01909f			jsr 	CheckNextToken
.0187ea	a5 22		lda $22				lda 	zVarDataPtr 				; save variable info on stack
.0187ec	48		pha				pha
.0187ed	a5 23		lda $23				lda 	zVarDataPtr+1
.0187ef	48		pha				pha
.0187f0	a5 24		lda $24				lda 	zVarType
.0187f2	48		pha				pha
.0187f3	20 1d 89	jsr $01891d			jsr 	EvaluateExpression 			; evaluate the RHS.
.0187f6	68		pla				pla 								; restore target variable information.
.0187f7	85 24		sta $24				sta 	zVarType
.0187f9	68		pla				pla
.0187fa	85 23		sta $23				sta 	zVarDataPtr+1
.0187fc	68		pla				pla
.0187fd	85 22		sta $22				sta 	zVarDataPtr
.0187ff	20 f2 94	jsr $0194f2			jsr 	VariableSet 				; set the value out.
.018802	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/end.asm

.018803					Command_END:
>018803	02						.byte 	2
.018804	4c d1 86	jmp $0186d1			jmp 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/print.asm

.018807					Command_PRINT:
.018807	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018809	c9 00		cmp #$00			cmp 	#0 							; end
.01880b	f0 65		beq $018872			beq 	_CPR_NewLine
.01880d	c9 c0		cmp #$c0			cmp 	#token_Colon
.01880f	f0 61		beq $018872			beq 	_CPR_NewLine
.018811	c9 c1		cmp #$c1			cmp 	#token_SemiColon
.018813	f0 50		beq $018865			beq 	_CPR_Skip
.018815	c9 bf		cmp #$bf			cmp 	#token_Comma
.018817	f0 49		beq $018862			beq 	_CPR_Tab
.018819	20 1d 89	jsr $01891d			jsr 	EvaluateExpression 			; get expression.
.01881c	a5 85		lda $85				lda 	XS_Type 					; get type.
.01881e	29 02		and #$02			and 	#2
.018820	d0 24		bne $018846			bne 	_CPR_String 				; if type = 2 output as string.
.018822					_CPR_Number:
.018822	a9 00		lda #$00			lda 	#0 							; reset buffer index
.018824	8d 0e 03	sta $030e			sta 	NumBufX
.018827	a5 85		lda $85				lda 	XS_Type 					; get type
.018829	4a		lsr a				lsr 	a
.01882a	b0 05		bcs $018831			bcs 	_CPRInt 					; if msb set do as integer
.01882c	20 76 9b	jsr $019b76			jsr 	FPToString 					; call fp to str otherwise
.01882f	80 03		bra $018834			bra 	_CPRNPrint
.018831	20 3b 96	jsr $01963b	_CPRInt:jsr 	IntToString
.018834					_CPRNPrint:
.018834	ad 0f 03	lda $030f			lda 	Num_Buffer 					; is first character -
.018837	c9 2d		cmp #$2d			cmp 	#"-"
.018839	f0 05		beq $018840			beq 	_CPRNoSpace
.01883b	a9 20		lda #$20			lda 	#" "						; print the leading space
.01883d	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter 			; so beloved of MS Basics.
.018840					_CPRNoSpace:
.018840	a2 0e		ldx #$0e			ldx 	#(Num_Buffer-1) & $FF
.018842	a9 03		lda #$03			lda 	#(Num_Buffer-1) >> 8
.018844	80 04		bra $01884a			bra 	_CPRPrint
.018846					_CPR_String:
.018846	a6 80		ldx $80				ldx 	XS_Mantissa
.018848	a5 81		lda $81				lda 	XS_Mantissa+1
.01884a					_CPRPrint:
.01884a	86 1e		stx $1e				stx 	zGenPtr
.01884c	85 1f		sta $1f				sta 	zGenPtr+1
.01884e	5a		phy				phy
.01884f	a0 00		ldy #$00			ldy 	#0							; get length into X
.018851	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018853	aa		tax				tax
.018854	f0 09		beq $01885f			beq 	_CPREndPrint 				; nothing to print
.018856					_CPRLoop:
.018856	c8		iny				iny
.018857	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018859	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01885c	ca		dex				dex
.01885d	d0 f7		bne $018856			bne 	_CPRLoop
.01885f					_CPREndPrint:
.01885f	7a		ply				ply
.018860	80 a5		bra $018807			bra 	Command_Print
.018862					_CPR_Tab:
.018862	20 4f 80	jsr $01804f			jsr 	IFT_Tab
.018865					_CPR_Skip:
.018865	c8		iny				iny
.018866	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018868	c9 c0		cmp #$c0			cmp 	#token_Colon 				; colon or $00, exit
.01886a	f0 09		beq $018875			beq 	_CPR_Exit
.01886c	c9 00		cmp #$00			cmp 	#0
.01886e	d0 97		bne $018807			bne 	Command_PRINT 				; if not go round again.
.018870	80 03		bra $018875			bra 	_CPR_Exit
.018872					_CPR_NewLine:
.018872	20 5c 80	jsr $01805c			jsr 	IFT_NewLine
.018875					_CPR_Exit:
.018875	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/assert.asm

.018876					Command_ASSERT:
.018876	20 9f 8a	jsr $018a9f			jsr 	EvaluateNumber 				; calculate thing being asserted
.018879	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; check if true (non-zero)
.01887b	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.01887d	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01887f	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.018881	f0 01		beq $018884			beq 	_ASFail
.018883	60		rts				rts
.018884					_ASFail:
.018884	20 2f 84	jsr $01842f			jsr ERR_Handler
>018887	41 73 73 65 72 74 00			.text "Assert",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/branch.asm

.01888e					Command_GOTO:
.01888e	20 94 88	jsr $018894			jsr 	GotoGetLineNumber
.018891	4c b1 88	jmp $0188b1			jmp 	GotoChangeToLineNumber
.018894					GotoGetLineNumber:
.018894	20 ad 8a	jsr $018aad			jsr 	EvaluateInteger
.018897	a5 82		lda $82				lda 	XS_Mantissa+2 				; check range
.018899	05 83		ora $83				ora 	XS_Mantissa+3
.01889b	d0 01		bne $01889e			bne 	_GLINError
.01889d	60		rts				rts
.01889e					_GLINError:
.01889e	20 2f 84	jsr $01842f			jsr ERR_Handler
>0188a1	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>0188a9	20 4e 75 6d 62 65 72 00
.0188b1					GotoChangeToLineNumber:
.0188b1	a5 80		lda $80				lda 	XS_Mantissa+0 				; check line number not zero
.0188b3	05 81		ora $81				ora 	XS_Mantissa+1
.0188b5	f0 37		beq $0188ee			beq 	_GCTLFail
.0188b7	a9 00		lda #$00			lda 	#BasicProgram & $FF
.0188b9	85 16		sta $16				sta 	zCodePtr+0
.0188bb	a9 10		lda #$10			lda 	#BasicProgram >> 8
.0188bd	85 17		sta $17				sta 	zCodePtr+1
.0188bf	a9 00		lda #$00			lda 	#0
.0188c1	85 18		sta $18				sta 	zCodePtr+2
.0188c3	85 19		sta $19				sta 	zCodePtr+3
.0188c5	a0 03		ldy #$03			ldy 	#3
.0188c7					_GCTLLoop:
.0188c7	a0 00		ldy #$00			ldy 	#0
.0188c9	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0188cb	c9 00		cmp #$00			cmp 	#0
.0188cd	f0 1f		beq $0188ee			beq 	_GCTLFail
.0188cf	c8		iny				iny
.0188d0	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0188d2	c5 80		cmp $80				cmp 	XS_Mantissa+0
.0188d4	d0 07		bne $0188dd			bne 	_GCTLNext
.0188d6	c8		iny				iny
.0188d7	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0188d9	c5 81		cmp $81				cmp 	XS_Mantissa+1
.0188db	f0 0f		beq $0188ec			beq 	_GCTLExit
.0188dd					_GCTLNext:
.0188dd	a0 00		ldy #$00			ldy 	#0 							; point to offset
.0188df	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.0188e1	18		clc				clc
.0188e2	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.0188e4	85 16		sta $16				sta 	zCodePtr
.0188e6	90 02		bcc $0188ea			bcc 	_SNLNoCarry
.0188e8	e6 17		inc $17				inc 	zCodePtr+1
.0188ea					_SNLNoCarry:
.0188ea	80 db		bra $0188c7			bra 	_GCTLLoop 					; try next line.
.0188ec					_GCTLExit:
.0188ec	c8		iny				iny
.0188ed	60		rts				rts
.0188ee					_GCTLFail:
.0188ee	20 2f 84	jsr $01842f			jsr ERR_Handler
>0188f1	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>0188f9	20 4e 75 6d 62 65 72 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.018901					Command_CLR:
.018901					ResetRunStatus:
.018901	20 93 91	jsr $019193			jsr 	VariableClear
.018904	a9 00		lda #$00			lda 	#HighMemory & $FF
.018906	8d 00 03	sta $0300			sta 	StringPtr
.018909	a9 80		lda #$80			lda 	#HighMemory >> 8
.01890b	8d 01 03	sta $0301			sta 	StringPtr+1
.01890e	20 5f 93	jsr $01935f			jsr 	ArrayResetDefault
.018911	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/stop.asm

.018912					Command_STOP:
.018912	20 2f 84	jsr $01842f			jsr ERR_Handler
>018915	53 74 6f 70 00				.text "Stop",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.01891a					EVESyntax:
.01891a	4c 00 84	jmp $018400			jmp 	SyntaxError
.01891d					EvaluateExpression:
.01891d	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.01891f					EvaluateExpressionX:
.01891f	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.018921					EvaluateExpressionXA:
.018921	48		pha				pha 								; save precedence on stack.
.018922	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018924	f0 f4		beq $01891a			beq 	EVESyntax 					; end of line, syntax error.
.018926	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.018928	b0 03		bcs $01892d			bcs 	_EVNotVariable
.01892a	4c 17 8a	jmp $018a17			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.01892d					_EVNotVariable:
.01892d	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.01892f	90 e9		bcc $01891a			bcc 	EVESyntax
.018931	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.018933	b0 78		bcs $0189ad			bcs 	_EVNotInteger
.018935	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.018937	95 80		sta $80,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.018939	a9 00		lda #$00			lda 	#0
.01893b	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01893d	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01893f	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018941	1a		inc a				inc 	a 							; set to type 1 (integer)
.018942	95 85		sta $85,x			sta 	XS_Type,x
.018944					_EVCheckNextInteger:
.018944	c8		iny				iny
.018945	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018947	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.018949	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.01894b	b0 0b		bcs $018958			bcs 	_EVCheckDecimal
.01894d	48		pha				pha 								; save it.
.01894e	20 23 8a	jsr $018a23			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.018951	68		pla				pla
.018952	15 80		ora $80,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.018954	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018956	80 ec		bra $018944			bra 	_EVCheckNextInteger
.018958					_EVCheckDecimal:
.018958	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01895a	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.01895c	d0 05		bne $018963			bne 	_EVGotAtom 					; no, get atom.
.01895e					_EVIsDecimal:
.01895e	20 45 8a	jsr $018a45			jsr 	EVGetDecimal 				; extend to the decimal part.
.018961	80 00		bra $018963			bra 	_EVGotAtom 					; and continue to got atom.
.018963					_EVGotAtom:
.018963	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018965	10 44		bpl $0189ab			bpl 	_EVExitDrop 				; must be a token.
.018967	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.018969	b0 40		bcs $0189ab			bcs 	_EVExitDrop
.01896b	68		pla				pla 								; get current precedence
.01896c	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.01896e	da		phx				phx 								; save X
.01896f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018971	aa		tax				tax 								; put in X
.018972	bf df 84 01	lda $0184df,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.018976	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.018978	fa		plx				plx 								; restore X
.018979	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.01897b	90 2f		bcc $0189ac			bcc 	_EVExit 					; exit if too low.
.01897d	f0 2d		beq $0189ac			beq 	_EVExit 					; exit if equals
.01897f	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.018981	48		pha				pha
.018982	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018984	48		pha				pha
.018985	c8		iny				iny
.018986	da		phx				phx 								; save current position
.018987	e8		inx				inx
.018988	e8		inx				inx
.018989	e8		inx				inx
.01898a	e8		inx				inx
.01898b	e8		inx				inx
.01898c	e8		inx				inx
.01898d	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.01898f	20 21 89	jsr $018921			jsr 	EvaluateExpressionXA 		; do the RHS.
.018992	fa		plx				plx 								; restore X
.018993	68		pla				pla 								; get the binary operator in A.
.018994					_EVCallA:
.018994	da		phx				phx 								; save X again
.018995	0a		asl a				asl 	a 							; double, lose the MSB.
.018996	aa		tax				tax									; put in X
.018997	bf 90 84 01	lda $018490,x			lda 	VectorTable,x 				; copy address into zGenPtr
.01899b	8d 0b 03	sta $030b			sta 	LocalVector+1
.01899e	bf 91 84 01	lda $018491,x			lda 	VectorTable+1,x
.0189a2	8d 0c 03	sta $030c			sta 	LocalVector+2
.0189a5	fa		plx				plx 								; restore X
.0189a6	20 20 8a	jsr $018a20			jsr 	EVCallLocalVector
.0189a9	80 b8		bra $018963			bra 	_EVGotAtom 					; and loop back.
.0189ab					_EVExitDrop:
.0189ab	68		pla				pla
.0189ac					_EVExit:
.0189ac	60		rts				rts
.0189ad					_EVNotInteger:
.0189ad	c8		iny				iny
.0189ae	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.0189b0	d0 16		bne $0189c8			bne 	_EVNotMinus
.0189b2	20 8e 8a	jsr $018a8e			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.0189b5	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.0189b7	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.0189b9	f0 05		beq $0189c0			beq 	_EVMinusFloat
.0189bb	20 1e 96	jsr $01961e			jsr 	IntegerNegateAlways 		; negation
.0189be	80 a3		bra $018963			bra 	_EVGotAtom 					; and go back.
.0189c0					_EVMinusFloat:
.0189c0	b5 85		lda $85,x			lda 	XS_Type,x 					; invert the sign bit.
.0189c2	49 80		eor #$80			eor 	#$80
.0189c4	95 85		sta $85,x			sta 	XS_Type,x
.0189c6	80 9b		bra $018963			bra 	_EVGotAtom
.0189c8					_EVNotMinus:
.0189c8	c9 bd		cmp #$bd			cmp 	#token_lparen 				; is it left parenthesis
.0189ca	d0 17		bne $0189e3			bne 	_EVNotParenthesis
.0189cc	20 1f 89	jsr $01891f			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.0189cf	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0189d1	c8		iny				iny
.0189d2	c9 be		cmp #$be			cmp 	#token_rparen 				; okay if right bracket.
.0189d4	f0 8d		beq $018963			beq 	_EVGotAtom
.0189d6	20 2f 84	jsr $01842f			jsr ERR_Handler
>0189d9	4d 69 73 73 69 6e 67 20			.text "Missing )",0
>0189e1	29 00
.0189e3					_EVNotParenthesis:
.0189e3	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.0189e5	d0 0c		bne $0189f3			bne 	_EVNotNot
.0189e7	20 8e 8a	jsr $018a8e			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.0189ea	20 77 9a	jsr $019a77			jsr 	FPUToInteger 				; make it an integer - if possible.
.0189ed	20 73 8a	jsr $018a73			jsr 	NotInteger 					; do the not calculation
.0189f0	4c 63 89	jmp $018963			jmp 	_EVGotAtom
.0189f3					_EVNotNot:
.0189f3	c9 fe		cmp #$fe			cmp 	#$FE
.0189f5	d0 12		bne $018a09			bne 	_EVNotString
.0189f7	20 31 91	jsr $019131			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.0189fa	a5 20		lda $20				lda 	zTempStr 					; copy address of string into mantissa
.0189fc	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0189fe	a5 21		lda $21				lda 	zTempStr+1
.018a00	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018a02	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.018a04	95 85		sta $85,x			sta 	XS_Type,x
.018a06	4c 63 89	jmp $018963			jmp 	_EVGotAtom
.018a09					_EVNotString:
.018a09	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.018a0b	90 04		bcc $018a11			bcc 	_EVBadElement
.018a0d	c9 b7		cmp #$b7			cmp 	#lastUnaryFunction+1
.018a0f	90 03		bcc $018a14			bcc 	_EVUnaryFunction
.018a11					_EVBadElement:
.018a11	4c 00 84	jmp $018400			jmp 	SyntaxError
.018a14					_EVUnaryFunction:
.018a14	4c 94 89	jmp $018994			jmp 	_EVCallA
.018a17					_EVVariableHandler:
.018a17	20 57 91	jsr $019157			jsr 	VariableFind 				; locate a variable
.018a1a	20 a1 94	jsr $0194a1			jsr 	VariableGet 				; copy into memory.
.018a1d	4c 63 89	jmp $018963			jmp 	_EVGotAtom 					; and go round.
.018a20					EVCallLocalVector:
.018a20	6c 0b 03	jmp ($030b)			jmp 	(LocalVector+1)
.018a23					EVShiftMantissaLeft6:
.018a23	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.018a25	95 84		sta $84,x			sta 	XS_Exponent,x
.018a27	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.018a29	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018a2b	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.018a2d	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.018a2f	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.018a31	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018a33	a9 00		lda #$00			lda 	#0
.018a35	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018a37	20 3a 8a	jsr $018a3a			jsr 	_EVSMLShift 					; call it here to do it twice
.018a3a					_EVSMLShift:
.018a3a	56 84		lsr $84,x			lsr 	XS_Exponent,x
.018a3c	76 83		ror $83,x			ror 	XS_Mantissa+3,x
.018a3e	76 82		ror $82,x			ror 	XS_Mantissa+2,x
.018a40	76 81		ror $81,x			ror 	XS_Mantissa+1,x
.018a42	76 80		ror $80,x			ror 	XS_Mantissa+0,x
.018a44	60		rts				rts
.018a45					EVGetDecimal:
.018a45	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.018a47	8d 0f 03	sta $030f			sta 	Num_Buffer
.018a4a	da		phx				phx
.018a4b	c8		iny				iny
.018a4c	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018a4e	c8		iny				iny
.018a4f	3a		dec a				dec 	a								; convert to a string length.
.018a50	3a		dec a				dec 	a
.018a51	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.018a53					_EVGDCopy:
.018a53	48		pha				pha 									; save count
.018a54	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018a56	9d 0f 03	sta $030f,x			sta 	Num_Buffer,x
.018a59	e8		inx				inx 									; forward ....
.018a5a	c8		iny				iny
.018a5b	68		pla				pla 									; get count
.018a5c	3a		dec a				dec 	a 								; until zero
.018a5d	d0 f4		bne $018a53			bne 	_EVGDCopy
.018a5f	9d 0f 03	sta $030f,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.018a62	fa		plx				plx 									; restore X
.018a63	a9 0f		lda #$0f			lda 	#Num_Buffer & $FF 				; set zGenPtr
.018a65	85 1e		sta $1e				sta 	zGenPtr
.018a67	a9 03		lda #$03			lda 	#Num_Buffer >> 8
.018a69	85 1f		sta $1f				sta 	zGenPtr+1
.018a6b	5a		phy				phy 									; save Y
.018a6c	a0 00		ldy #$00			ldy 	#0 								; start position
.018a6e	20 31 9c	jsr $019c31			jsr 	FPFromString 					; convert current
.018a71	7a		ply				ply 									; restore Y
.018a72	60		rts				rts
.018a73					NotInteger:
.018a73	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.018a75	49 ff		eor #$ff			eor 	#$FF
.018a77	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018a79	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.018a7b	49 ff		eor #$ff			eor 	#$FF
.018a7d	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018a7f	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.018a81	49 ff		eor #$ff			eor 	#$FF
.018a83	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.018a85	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.018a87	49 ff		eor #$ff			eor 	#$FF
.018a89	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018a8b	60		rts				rts
.018a8c					EvaluateGetAtom:
.018a8c	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.018a8e					EvaluateGetAtomX:
.018a8e	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.018a90	20 21 89	jsr $018921			jsr 	EvaluateExpressionXA
.018a93	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.018a95	29 0f		and #$0f			and 	#15
.018a97	c9 02		cmp #$02			cmp 	#2
.018a99	b0 01		bcs $018a9c			bcs 	EvaluateType
.018a9b	60		rts				rts
.018a9c					EvaluateType:
.018a9c	4c 10 84	jmp $018410			jmp 	TypeError
.018a9f					EvaluateNumber:
.018a9f	a2 00		ldx #$00			ldx 	#0
.018aa1					EvaluateNumberX:
.018aa1	20 1f 89	jsr $01891f			jsr 	EvaluateExpressionX
.018aa4	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0/1
.018aa6	29 0f		and #$0f			and 	#15
.018aa8	c9 02		cmp #$02			cmp 	#2
.018aaa	b0 f0		bcs $018a9c			bcs 	EvaluateType
.018aac	60		rts				rts
.018aad					EvaluateInteger:
.018aad	a2 00		ldx #$00			ldx 	#0
.018aaf					EvaluateIntegerX:
.018aaf	20 a1 8a	jsr $018aa1			jsr 	EvaluateNumberX
.018ab2	20 77 9a	jsr $019a77			jsr 	FPUToInteger
.018ab5	60		rts				rts
.018ab6					EvaluateString:
.018ab6	a2 00		ldx #$00			ldx 	#0
.018ab8					EvaluateStringX:
.018ab8	20 1f 89	jsr $01891f			jsr 	EvaluateExpressionX
.018abb	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 2
.018abd	29 0f		and #$0f			and 	#15
.018abf	c9 02		cmp #$02			cmp 	#2
.018ac1	d0 d9		bne $018a9c			bne 	EvaluateType
.018ac3	b5 80		lda $80,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.018ac5	85 1e		sta $1e				sta 	zGenPtr
.018ac7	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.018ac9	85 1f		sta $1f				sta 	zGenPtr+1
.018acb	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.018acc					BinaryOp_And:
.018acc	20 20 8b	jsr $018b20			jsr 	BinaryMakeBothInteger
.018acf	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.018ad1	35 86		and $86,x			and 	XS2_Mantissa+0,x
.018ad3	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018ad5	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.018ad7	35 87		and $87,x			and 	XS2_Mantissa+1,x
.018ad9	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018adb	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.018add	35 88		and $88,x			and 	XS2_Mantissa+2,x
.018adf	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.018ae1	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.018ae3	35 89		and $89,x			and 	XS2_Mantissa+3,x
.018ae5	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018ae7	60		rts				rts
.018ae8					BinaryOp_Or:
.018ae8	20 20 8b	jsr $018b20			jsr 	BinaryMakeBothInteger
.018aeb	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.018aed	15 86		ora $86,x			ora 	XS2_Mantissa+0,x
.018aef	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018af1	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.018af3	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.018af5	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018af7	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.018af9	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.018afb	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.018afd	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.018aff	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.018b01	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018b03	60		rts				rts
.018b04					BinaryOp_Eor:
.018b04					BinaryOp_Xor:
.018b04	20 20 8b	jsr $018b20			jsr 	BinaryMakeBothInteger
.018b07	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.018b09	55 86		eor $86,x			eor 	XS2_Mantissa+0,x
.018b0b	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018b0d	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.018b0f	55 87		eor $87,x			eor 	XS2_Mantissa+1,x
.018b11	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018b13	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.018b15	55 88		eor $88,x			eor 	XS2_Mantissa+2,x
.018b17	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.018b19	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.018b1b	55 89		eor $89,x			eor 	XS2_Mantissa+3,x
.018b1d	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018b1f	60		rts				rts
.018b20					BinaryMakeBothInteger:
.018b20	da		phx				phx 								; save X
.018b21	e8		inx				inx
.018b22	e8		inx				inx
.018b23	e8		inx				inx
.018b24	e8		inx				inx
.018b25	e8		inx				inx
.018b26	e8		inx				inx
.018b27	20 2b 8b	jsr $018b2b			jsr 	BinaryMakeInteger 			; convert to integer.
.018b2a	fa		plx				plx 								; restore X and fall through.
.018b2b					BinaryMakeInteger:
.018b2b	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.018b2d	29 0f		and #$0f			and 	#15 						; check type zero
.018b2f	f0 04		beq $018b35			beq 	_BMIConvert 				; if float convert to integer.
.018b31	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.018b32	90 04		bcc $018b38			bcc 	_BMIError
.018b34	60		rts				rts
.018b35					_BMIConvert:
.018b35	4c 77 9a	jmp $019a77			jmp 	FPUToInteger 				; convert to integer
.018b38					_BMIError:
.018b38	4c 10 84	jmp $018410			jmp 	TypeError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.018b3b					Binary_Equal:
.018b3b	20 82 8b	jsr $018b82			jsr 	CompareValues
.018b3e	09 00		ora #$00			ora 	#0
.018b40	f0 04		beq $018b46			beq 	CCTrue
.018b42	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.018b44	80 02		bra $018b48			bra 	CCWrite
.018b46	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.018b48	95 80		sta $80,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.018b4a	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018b4c	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.018b4e	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018b50	a9 01		lda #$01			lda 	#1
.018b52	95 85		sta $85,x			sta 	XS_Type,x 					; set type to integer whatever.
.018b54	60		rts				rts
.018b55					Binary_NotEqual:
.018b55	20 82 8b	jsr $018b82			jsr 	CompareValues
.018b58	09 00		ora #$00			ora 	#0
.018b5a	f0 e6		beq $018b42			beq 	CCFalse
.018b5c	80 e8		bra $018b46			bra 	CCTrue
.018b5e					Binary_Less:
.018b5e	20 82 8b	jsr $018b82			jsr 	CompareValues
.018b61	09 00		ora #$00			ora 	#0
.018b63	30 e1		bmi $018b46			bmi 	CCTrue
.018b65	80 db		bra $018b42			bra 	CCFalse
.018b67					Binary_LessEqual:
.018b67	20 82 8b	jsr $018b82			jsr 	CompareValues
.018b6a	c9 01		cmp #$01			cmp 	#1
.018b6c	d0 d8		bne $018b46			bne 	CCTrue
.018b6e	80 d2		bra $018b42			bra 	CCFalse
.018b70					Binary_GreaterEqual:
.018b70	20 82 8b	jsr $018b82			jsr 	CompareValues
.018b73	09 00		ora #$00			ora 	#0
.018b75	10 cf		bpl $018b46			bpl 	CCTrue
.018b77	80 c9		bra $018b42			bra 	CCFalse
.018b79					Binary_Greater:
.018b79	20 82 8b	jsr $018b82			jsr 	CompareValues
.018b7c	c9 01		cmp #$01			cmp 	#1
.018b7e	f0 c6		beq $018b46			beq 	CCTrue
.018b80	80 c0		bra $018b42			bra 	CCFalse
.018b82					CompareValues:
.018b82	b5 85		lda $85,x			lda 	XS_Type,x 					; and the types together
.018b84	35 8b		and $8b,x			and 	XS2_Type,x
.018b86	c9 02		cmp #$02			cmp 	#2
.018b88	f0 11		beq $018b9b			beq 	_CVString
.018b8a	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018b8c	35 8b		and $8b,x			and 	XS2_Type,x
.018b8e	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018b8f	90 03		bcc $018b94			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018b91	4c dd 8b	jmp $018bdd			jmp 	CompareInteger32 							; so execute code at \1
.018b94					_BCFloat:
.018b94	20 81 8c	jsr $018c81			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018b97	4c ad 99	jmp $0199ad			jmp 	FPCompare 							; and execute code at \2
.018b9a	60		rts				rts
.018b9b					_CVString:
.018b9b	da		phx				phx 								; save XY
.018b9c	5a		phy				phy
.018b9d	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.018b9f	85 1a		sta $1a				sta		zLTemp1+0
.018ba1	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.018ba3	85 1b		sta $1b				sta 	zLTemp1+1
.018ba5	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.018ba7	85 1c		sta $1c				sta 	zLTemp1+2
.018ba9	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.018bab	85 1d		sta $1d				sta 	zLTemp1+3
.018bad	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.018baf	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.018bb1	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.018bb3	90 02		bcc $018bb7			bcc 	_CVCommon
.018bb5	b1 1c		lda ($1c),y			lda 	(zLTemp1+2),y
.018bb7					_CVCommon:
.018bb7	aa		tax				tax 								; put shorter string length in zero.
.018bb8	f0 0c		beq $018bc6			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.018bba					_CVCompare:
.018bba	c8		iny				iny 								; next character
.018bbb	b1 1a		lda ($1a),y			lda 	(zLTemp1),y 				; compare characters
.018bbd	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.018bbf	90 13		bcc $018bd4			bcc 	_CVReturnLess 				; <
.018bc1	d0 15		bne $018bd8			bne 	_CVReturnGreater 			; >
.018bc3	ca		dex				dex 								; until common length matched.
.018bc4	d0 f4		bne $018bba			bne 	_CVCompare
.018bc6					_CVMatch:
.018bc6	a0 00		ldy #$00			ldy 	#0
.018bc8	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.018bca	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.018bcc	90 06		bcc $018bd4			bcc 	_CVReturnLess 				; <
.018bce	d0 08		bne $018bd8			bne 	_CVReturnGreater 			; >
.018bd0	a9 00		lda #$00			lda 	#0
.018bd2	80 06		bra $018bda			bra 	_CVExit 					; same common, same length, same string
.018bd4					_CVReturnLess:
.018bd4	a9 ff		lda #$ff			lda 	#$FF
.018bd6	80 02		bra $018bda			bra 	_CVExit
.018bd8					_CVReturnGreater:
.018bd8	a9 01		lda #$01			lda 	#$01
.018bda					_CVExit:
.018bda	7a		ply				ply
.018bdb	fa		plx				plx
.018bdc	60		rts				rts
.018bdd					CompareInteger32:
.018bdd	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.018bdf	49 80		eor #$80			eor 	#$80
.018be1	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018be3	b5 89		lda $89,x			lda 	XS2_Mantissa+3,x
.018be5	49 80		eor #$80			eor 	#$80
.018be7	95 89		sta $89,x			sta 	XS2_Mantissa+3,x
.018be9	20 67 8c	jsr $018c67			jsr 	SubInteger32 				; subtraction
.018bec	90 0d		bcc $018bfb			bcc 	_CI32Less 					; cc return -1
.018bee	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check if zero
.018bf0	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.018bf2	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.018bf4	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.018bf6	f0 02		beq $018bfa			beq 	_CI32Exit
.018bf8	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.018bfa					_CI32Exit:
.018bfa	60		rts				rts
.018bfb					_CI32Less:
.018bfb	a9 ff		lda #$ff			lda 	#$FF
.018bfd	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.018bfe					BinaryOp_Add:
.018bfe	b5 85		lda $85,x			lda 	XS_Type,x  					; and types together
.018c00	35 8b		and $8b,x			and 	XS2_Type,x
.018c02	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.018c04	d0 11		bne $018c17			bne 	_BOAString
.018c06	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018c08	35 8b		and $8b,x			and 	XS2_Type,x
.018c0a	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018c0b	90 03		bcc $018c10			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018c0d	4c 4d 8c	jmp $018c4d			jmp 	AddInteger32 							; so execute code at \1
.018c10					_BCFloat:
.018c10	20 81 8c	jsr $018c81			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018c13	4c 88 97	jmp $019788			jmp 	FPAdd 							; and execute code at \2
.018c16	60		rts				rts
.018c17					_BOAString:
.018c17	4c 9b 8c	jmp $018c9b			jmp 	ConcatenateString 			; concatenate two strings.
.018c1a					BinaryOp_Subtract:
.018c1a	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018c1c	35 8b		and $8b,x			and 	XS2_Type,x
.018c1e	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018c1f	90 03		bcc $018c24			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018c21	4c 67 8c	jmp $018c67			jmp 	SubInteger32 							; so execute code at \1
.018c24					_BCFloat:
.018c24	20 81 8c	jsr $018c81			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018c27	4c 80 97	jmp $019780			jmp 	FPSubtract 							; and execute code at \2
.018c2a	60		rts				rts
.018c2b					BinaryOp_Multiply:
.018c2b	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018c2d	35 8b		and $8b,x			and 	XS2_Type,x
.018c2f	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018c30	90 03		bcc $018c35			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018c32	4c 59 95	jmp $019559			jmp 	MulInteger32 							; so execute code at \1
.018c35					_BCFloat:
.018c35	20 81 8c	jsr $018c81			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018c38	4c af 98	jmp $0198af			jmp 	FPMultiply 							; and execute code at \2
.018c3b	60		rts				rts
.018c3c					BinaryOp_Divide:
.018c3c	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018c3e	35 8b		and $8b,x			and 	XS2_Type,x
.018c40	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018c41	90 03		bcc $018c46			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018c43	4c 97 95	jmp $019597			jmp 	DivInteger32 							; so execute code at \1
.018c46					_BCFloat:
.018c46	20 81 8c	jsr $018c81			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018c49	4c 3c 98	jmp $01983c			jmp 	FPDivide 							; and execute code at \2
.018c4c	60		rts				rts
.018c4d					AddInteger32:
.018c4d	18		clc				clc
.018c4e	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.018c50	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.018c52	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018c54	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.018c56	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.018c58	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018c5a	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.018c5c	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.018c5e	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.018c60	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.018c62	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.018c64	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018c66	60		rts				rts
.018c67					SubInteger32:
.018c67	38		sec				sec
.018c68	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.018c6a	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.018c6c	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018c6e	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.018c70	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.018c72	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018c74	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.018c76	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.018c78	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.018c7a	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.018c7c	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.018c7e	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018c80	60		rts				rts
.018c81					BinaryMakeBothFloat:
.018c81	da		phx				phx 								; save X
.018c82	e8		inx				inx
.018c83	e8		inx				inx
.018c84	e8		inx				inx
.018c85	e8		inx				inx
.018c86	e8		inx				inx
.018c87	e8		inx				inx
.018c88	20 8c 8c	jsr $018c8c			jsr 	BinaryMakeFloat 			; convert to float.
.018c8b	fa		plx				plx 								; restore X and fall through.
.018c8c					BinaryMakeFloat:
.018c8c	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.018c8e	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.018c8f	b0 04		bcs $018c95			bcs 	_BMFConvert
.018c91	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.018c92	b0 04		bcs $018c98			bcs 	_BMFError
.018c94	60		rts				rts
.018c95					_BMFConvert:
.018c95	4c 2b 9a	jmp $019a2b			jmp 	FPUToFloat 					; convert to float
.018c98					_BMFError:
.018c98	4c 10 84	jmp $018410			jmp 	TypeError
.018c9b					ConcatenateString:
.018c9b	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.018c9d	85 1a		sta $1a				sta		zLTemp1+0
.018c9f	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.018ca1	85 1b		sta $1b				sta 	zLTemp1+1
.018ca3	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.018ca5	85 1c		sta $1c				sta 	zLTemp1+2
.018ca7	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.018ca9	85 1d		sta $1d				sta 	zLTemp1+3
.018cab	5a		phy				phy
.018cac	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.018cae	b1 1a		lda ($1a),y			lda 	(zlTemp1),y
.018cb0	71 1c		adc ($1c),y			adc 	(zlTemp1+2),y
.018cb2	7a		ply				ply
.018cb3	b0 33		bcs $018ce8			bcs 	_CSError					; check in range.
.018cb5	c9 fe		cmp #$fe			cmp 	#maxString+1
.018cb7	b0 2f		bcs $018ce8			bcs 	_CSError
.018cb9	20 f6 90	jsr $0190f6			jsr 	AllocateTempString 			; store the result
.018cbc	20 d3 8c	jsr $018cd3			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.018cbf	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.018cc1	85 1a		sta $1a				sta 	zLTemp1
.018cc3	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.018cc5	85 1b		sta $1b				sta 	zLTemp1+1
.018cc7	20 d3 8c	jsr $018cd3			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.018cca	a5 20		lda $20				lda 	zTempStr 					; point current to new string
.018ccc	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018cce	a5 21		lda $21				lda 	zTempStr+1
.018cd0	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018cd2	60		rts				rts
.018cd3					_CSCopyString:
.018cd3	da		phx				phx
.018cd4	5a		phy				phy
.018cd5	a0 00		ldy #$00			ldy 	#0 							; get length
.018cd7	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.018cd9	f0 0a		beq $018ce5			beq 	_CSCSExit 					; if zero, exit
.018cdb	aa		tax				tax 								; put in X
.018cdc					_CSCSLoop:
.018cdc	c8		iny				iny 								; get next char
.018cdd	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.018cdf	20 21 91	jsr $019121			jsr		WriteTempString 			; copy out
.018ce2	ca		dex				dex 								; do whole string
.018ce3	d0 f7		bne $018cdc			bne 	_CSCSLoop
.018ce5					_CSCSExit:
.018ce5	7a		ply				ply
.018ce6	fa		plx				plx
.018ce7	60		rts				rts
.018ce8					_CSError:
.018ce8	20 2f 84	jsr $01842f			jsr ERR_Handler
>018ceb	53 74 72 69 6e 67 20 74			.text "String too long",0
>018cf3	6f 6f 20 6c 6f 6e 67 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.018cfb					Unary_Sgn:
.018cfb	20 a1 8a	jsr $018aa1			jsr 	EvaluateNumberX 			; get value
.018cfe	20 b6 90	jsr $0190b6			jsr 	CheckNextRParen 			; check right bracket.
.018d01	20 1f 8d	jsr $018d1f			jsr 	GetSignCurrent 				; get sign.
.018d04	09 00		ora #$00			ora 	#0
.018d06	10 08		bpl $018d10			bpl		UnarySetAInteger			; if 0,1 return that.
.018d08	80 00		bra $018d0a			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.018d0a					UnarySetAMinus1:
.018d0a	a9 ff		lda #$ff			lda 	#$FF
.018d0c	95 80		sta $80,x			sta 	XS_Mantissa,x
.018d0e	80 04		bra $018d14			bra 	UnarySetAFill
.018d10					UnarySetAInteger:
.018d10	95 80		sta $80,x			sta 	XS_Mantissa,x
.018d12	a9 00		lda #$00			lda 	#0
.018d14					UnarySetAFill:
.018d14	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018d16	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.018d18	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018d1a	a9 01		lda #$01			lda 	#1
.018d1c	95 85		sta $85,x			sta 	XS_Type,x
.018d1e	60		rts				rts
.018d1f					GetSignCurrent:
.018d1f	b5 85		lda $85,x			lda 	XS_Type,x 					; identify type.
.018d21	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.018d22	90 15		bcc $018d39			bcc 	_GSCFloat
.018d24	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.018d26	30 0e		bmi $018d36			bmi 	_GSCMinus1
.018d28	15 80		ora $80,x			ora 	XS_Mantissa+0,x
.018d2a	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.018d2c	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.018d2e	d0 03		bne $018d33			bne 	_GSCPlus1
.018d30					_GSCZero:
.018d30	a9 00		lda #$00			lda 	#0
.018d32	60		rts				rts
.018d33					_GSCPlus1:
.018d33	a9 01		lda #$01			lda 	#$01
.018d35	60		rts				rts
.018d36					_GSCMinus1:
.018d36	a9 ff		lda #$ff			lda 	#$FF
.018d38	60		rts				rts
.018d39					_GSCFloat:
.018d39	34 85		bit $85,x			bit 	XS_Type,x
.018d3b	70 f3		bvs $018d30			bvs 	_GSCZero
.018d3d	30 f7		bmi $018d36			bmi 	_GSCMinus1
.018d3f	80 f2		bra $018d33			bra 	_GSCPlus1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.018d41					Unary_Abs:
.018d41	20 a1 8a	jsr $018aa1			jsr 	EvaluateNumberX 			; get value
.018d44	20 b6 90	jsr $0190b6			jsr 	CheckNextRParen 			; check right bracket.
.018d47	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.018d49	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.018d4b	f0 07		beq $018d54			beq 	_UAMinusFloat
.018d4d	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; check MSB
.018d4f	10 09		bpl $018d5a			bpl 	_UAExit
.018d51	4c 1e 96	jmp $01961e			jmp 	IntegerNegateAlways 		; negation
.018d54					_UAMinusFloat:
.018d54	b5 85		lda $85,x			lda 	XS_Type,x 					; clear the sign bit.
.018d56	29 7f		and #$7f			and		#$7F
.018d58	95 85		sta $85,x			sta 	XS_Type,x
.018d5a					_UAExit:
.018d5a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.018d5b					Unary_Peek:
.018d5b	a9 01		lda #$01			lda 	#1
.018d5d	80 06		bra $018d65			bra 	UPMain
.018d5f					Unary_Deek:
.018d5f	a9 02		lda #$02			lda 	#2
.018d61	80 02		bra $018d65			bra 	UPMain
.018d63					Unary_Leek:
.018d63	a9 04		lda #$04			lda 	#4
.018d65					UPMain:
.018d65	48		pha				pha 								; set bytes to copy.
.018d66	20 af 8a	jsr $018aaf			jsr 	EvaluateIntegerX 			; numeric parameter
.018d69	20 b6 90	jsr $0190b6			jsr 	CheckNextRParen 			; right bracket.
.018d6c	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.018d6e	85 1a		sta $1a				sta 	zLTemp1
.018d70	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.018d72	85 1b		sta $1b				sta 	zLTemp1+1
.018d74	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.018d76	85 1c		sta $1c				sta 	zLTemp1+2
.018d78	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.018d7a	85 1d		sta $1d				sta 	zLTemp1+3
.018d7c	a9 00		lda #$00			lda 	#0 							; clear target area
.018d7e	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018d80	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018d82	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.018d84	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018d86	68		pla				pla 								; restore bytes to copy
.018d87	da		phx				phx 								; save XY
.018d88	5a		phy				phy
.018d89	20 57 90	jsr $019057			jsr 	MemRead 					; read the bytes in
.018d8c	7a		ply				ply 								; restore and exit
.018d8d	fa		plx				plx
.018d8e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.018d8f					Unary_Mod:
.018d8f	20 b7 8d	jsr $018db7			jsr 	_UMParameter 				; first parameter
.018d92	20 be 90	jsr $0190be			jsr 	CheckNextComma
.018d95	da		phx				phx 								; second parameter
.018d96	e8		inx				inx
.018d97	e8		inx				inx
.018d98	e8		inx				inx
.018d99	e8		inx				inx
.018d9a	e8		inx				inx
.018d9b	e8		inx				inx
.018d9c	20 b7 8d	jsr $018db7			jsr 	_UMParameter
.018d9f	fa		plx				plx
.018da0	20 b6 90	jsr $0190b6			jsr 	CheckNextRParen
.018da3	20 97 95	jsr $019597			jsr 	DivInteger32 				; divide
.018da6	a5 1a		lda $1a				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.018da8	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018daa	a5 1b		lda $1b				lda 	zLTemp1+1
.018dac	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018dae	a5 1c		lda $1c				lda 	zLTemp1+2
.018db0	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.018db2	a5 1d		lda $1d				lda 	zLTemp1+3
.018db4	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018db6	60		rts				rts
.018db7					_UMParameter:
.018db7	20 af 8a	jsr $018aaf			jsr 	EvaluateIntegerX 			; get value
.018dba	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; absolute value
.018dbc	10 03		bpl $018dc1			bpl 	_UMNotSigned
.018dbe	20 1e 96	jsr $01961e			jsr 	IntegerNegateAlways
.018dc1					_UMNotSigned:
.018dc1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.018dc2					Unary_Usr:
.018dc2	20 a1 8a	jsr $018aa1			jsr 	EvaluateNumberX 			; numeric parameter
.018dc5	20 b6 90	jsr $0190b6			jsr 	CheckNextRParen 			; right bracket.
.018dc8	da		phx				phx 								; save XY
.018dc9	5a		phy				phy
.018dca	ea		nop				nop
.018dcb	22 06 03 00	jsl $000306			jsl 	UserVector
.018dcf	7a		ply				ply 								; and exit
.018dd0	fa		plx				plx
.018dd1	60		rts				rts
.018dd2					USRDefault:
.018dd2	20 2f 84	jsr $01842f			jsr ERR_Handler
>018dd5	4e 6f 20 55 53 52 20 76			.text "No USR vector.",0
>018ddd	65 63 74 6f 72 2e 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.018de4					Unary_Val:
.018de4	20 b8 8a	jsr $018ab8			jsr 	EvaluateStringX 			; get string
.018de7	20 b6 90	jsr $0190b6			jsr 	CheckNextRParen 			; check right bracket.
.018dea	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.018dec	85 1e		sta $1e				sta 	zGenPtr
.018dee	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.018df0	85 1f		sta $1f				sta 	zGenPtr+1
.018df2	5a		phy				phy
.018df3	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.018df5	b1 1e		lda ($1e),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.018df7	f0 54		beq $018e4d			beq 	_UVBadNumber
.018df9	48		pha				pha 								; save length.
.018dfa	1a		inc a				inc 	a 							; one for the length, one for the terminator
.018dfb	1a		inc a				inc 	a
.018dfc	20 f6 90	jsr $0190f6			jsr 	AllocateTempString
.018dff	c8		iny				iny 								; move to the next.
.018e00	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get character
.018e02	49 2d		eor #$2d			eor 	#"-"						; zero if minus sign
.018e04	8d 9a 03	sta $039a			sta 	ValSign
.018e07	d0 04		bne $018e0d			bne 	_UVNotMinus
.018e09	c8		iny				iny 								; skip over it.
.018e0a	68		pla				pla 								; decrement character count.
.018e0b	3a		dec a				dec 	a
.018e0c	48		pha				pha
.018e0d					_UVNotMinus:
.018e0d	68		pla				pla 								; this is the count.
.018e0e	48		pha		_UVCopy:pha									; copy into new temp string which is ASCIIZ
.018e0f	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018e11	c8		iny				iny
.018e12	20 21 91	jsr $019121			jsr 	WriteTempString
.018e15	68		pla				pla
.018e16	3a		dec a				dec 	a
.018e17	d0 f5		bne $018e0e			bne 	_UVCopy
.018e19	20 21 91	jsr $019121			jsr 	WriteTempString 			; make it ASCIIZ
.018e1c	18		clc				clc
.018e1d	a5 20		lda $20				lda 	zTempStr 					; tempstring +1 => genptr
.018e1f	69 01		adc #$01			adc 	#1
.018e21	85 1e		sta $1e				sta 	zGenPtr
.018e23	a5 21		lda $21				lda 	zTempStr+1
.018e25	69 00		adc #$00			adc 	#0
.018e27	85 1f		sta $1f				sta 	zGenPtr+1
.018e29	18		clc				clc
.018e2a	20 f0 96	jsr $0196f0			jsr 	IntFromString 				; first bit.
.018e2d	b0 1e		bcs $018e4d			bcs 	_UVBadNumber
.018e2f	20 31 9c	jsr $019c31			jsr 	FPFromString				; try for a float part.
.018e32	ad 9a 03	lda $039a			lda 	ValSign 					; was it negative
.018e35	d0 10		bne $018e47			bne 	_UVNotNegative
.018e37	b5 85		lda $85,x			lda 	XS_Type,x 					; check if integer
.018e39	4a		lsr a				lsr 	a
.018e3a	b0 08		bcs $018e44			bcs 	_UVInteger
.018e3c	b5 85		lda $85,x			lda 	XS_Type,x 					; set sign bit
.018e3e	09 80		ora #$80			ora 	#$80
.018e40	95 85		sta $85,x			sta 	XS_Type,x
.018e42	80 03		bra $018e47			bra 	_UVNotNegative
.018e44					_UVInteger:
.018e44	20 1e 96	jsr $01961e			jsr 	IntegerNegateAlways 		; sign it.
.018e47					_UVNotNegative:
.018e47	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; used everything
.018e49	d0 02		bne $018e4d			bne 	_UVBadNumber
.018e4b	7a		ply				ply
.018e4c	60		rts				rts
.018e4d					_UVBadNumber:
.018e4d	4c 1e 84	jmp $01841e			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.018e50					Unary_Str:
.018e50	20 a1 8a	jsr $018aa1			jsr 	EvaluateNumberX 			; numeric parameter
.018e53	20 b6 90	jsr $0190b6			jsr 	CheckNextRParen 			; right bracket.
.018e56	a9 00		lda #$00			lda 	#0 							; reset buffer index
.018e58	8d 0e 03	sta $030e			sta 	NumBufX
.018e5b	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.018e5d	4a		lsr a				lsr 	a
.018e5e	b0 05		bcs $018e65			bcs 	_USInt 						; if msb set do as integer
.018e60	20 76 9b	jsr $019b76			jsr 	FPToString 					; call fp to str otherwise
.018e63	80 03		bra $018e68			bra 	_USDuplicate
.018e65	20 3b 96	jsr $01963b	_USInt:	jsr 	IntToString
.018e68					_USDuplicate:
.018e68	ad 0e 03	lda $030e			lda 	NumBufX 					; chars in buffer
.018e6b	1a		inc a				inc 	a 							; one more for length
.018e6c	20 f6 90	jsr $0190f6			jsr 	AllocateTempString 			; allocate space for it.
.018e6f	5a		phy				phy 								; save Y
.018e70	a0 00		ldy #$00			ldy 	#0 							; start copying
.018e72	b9 0f 03	lda $030f,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.018e75	20 21 91	jsr $019121			jsr 	WriteTempString
.018e78	c8		iny				iny
.018e79	cc 0e 03	cpy $030e			cpy 	NumBufX 					; done the lot
.018e7c	d0 f4		bne $018e72			bne 	_USCopy
.018e7e	7a		ply				ply 								; restore Y
.018e7f	4c 4a 90	jmp $01904a			jmp 	UnaryReturnTempStr 			; return new temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.018e82					Unary_Asc:
.018e82	20 b8 8a	jsr $018ab8			jsr 	EvaluateStringX 			; string parameter
.018e85	20 b6 90	jsr $0190b6			jsr 	CheckNextRParen 			; right bracket.
.018e88	5a		phy				phy 								; get the string length
.018e89	a0 00		ldy #$00			ldy 	#0
.018e8b	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018e8d	f0 07		beq $018e96			beq 	_UAIllegal 					; must be at least one character
.018e8f	c8		iny				iny
.018e90	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; read it.
.018e92	7a		ply				ply
.018e93	4c 10 8d	jmp $018d10			jmp 	UnarySetAInteger
.018e96					_UAIllegal:
.018e96	4c 1e 84	jmp $01841e			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.018e99					Unary_Len:
.018e99	20 b8 8a	jsr $018ab8			jsr 	EvaluateStringX 			; string parameter
.018e9c	20 b6 90	jsr $0190b6			jsr 	CheckNextRParen 			; right bracket.
.018e9f	5a		phy				phy 								; get the string length
.018ea0	a0 00		ldy #$00			ldy 	#0
.018ea2	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018ea4	7a		ply				ply
.018ea5	4c 10 8d	jmp $018d10			jmp 	UnarySetAInteger

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.018ea8					Unary_Mid:
.018ea8	20 b8 8a	jsr $018ab8			jsr 	EvaluateStringX 				; get string.
.018eab	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.018ead	48		pha				pha
.018eae	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.018eb0	48		pha				pha
.018eb1	20 be 90	jsr $0190be			jsr 	CheckNextComma 					; skip comma
.018eb4	20 3d 8f	jsr $018f3d			jsr 	SLIByteParameter 				; get a byte parameter (start)
.018eb7	48		pha				pha 									; and push it.
.018eb8	20 be 90	jsr $0190be			jsr 	CheckNextComma 					; skip comma
.018ebb	20 3d 8f	jsr $018f3d			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.018ebe	48		pha				pha 									; and push it.
.018ebf	80 41		bra $018f02			bra 	SLIProcess
.018ec1					Unary_Left:
.018ec1	20 b8 8a	jsr $018ab8			jsr 	EvaluateStringX 				; get string.
.018ec4	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.018ec6	48		pha				pha
.018ec7	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.018ec9	48		pha				pha
.018eca	a9 01		lda #$01			lda 	#1 								; push start position (1)
.018ecc	48		pha				pha
.018ecd	20 be 90	jsr $0190be			jsr 	CheckNextComma 					; skip comma
.018ed0	20 3d 8f	jsr $018f3d			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.018ed3	48		pha				pha 									; and push it.
.018ed4	80 2c		bra $018f02			bra 	SLIProcess
.018ed6					Unary_Right:
.018ed6	20 b8 8a	jsr $018ab8			jsr 	EvaluateStringX 				; get string.
.018ed9	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.018edb	48		pha				pha
.018edc	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.018ede	48		pha				pha
.018edf	da		phx				phx 									; get the string length and push on stack.
.018ee0	a2 00		ldx #$00			ldx 	#0
.018ee2	a1 1e		lda ($1e,x)			lda		(zGenPtr,x)
.018ee4	fa		plx				plx
.018ee5	48		pha				pha
.018ee6	20 be 90	jsr $0190be			jsr 	CheckNextComma 					; skip comma
.018ee9	20 3d 8f	jsr $018f3d			jsr 	SLIByteParameter 				; get a byte parameter.
.018eec	8d 98 03	sta $0398			sta 	SignCount 						; save in temporary.
.018eef	68		pla				pla 									; restore string length.
.018ef0	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.018ef1	38		sec				sec
.018ef2	ed 98 03	sbc $0398			sbc 	SignCount 						; subtract characters needed, gives start position.
.018ef5	f0 02		beq $018ef9			beq 	_URStart 						; if <= 0 start from 1.
.018ef7	10 02		bpl $018efb			bpl 	_UROkay
.018ef9					_URStart:
.018ef9	a9 01		lda #$01			lda 	#1
.018efb					_UROkay:
.018efb	48		pha				pha 									; push start
.018efc	ad 98 03	lda $0398			lda 	SignCount 						; push count of characters
.018eff	48		pha				pha
.018f00	80 00		bra $018f02			bra 	SLIProcess
.018f02					SLIProcess:
.018f02	20 b6 90	jsr $0190b6			jsr 	CheckNextRParen 				; closing right bracket.
.018f05	68		pla				pla
.018f06	8d 9c 03	sta $039c			sta 	SliceCount 						; count in signcount
.018f09	1a		inc a				inc 	a 								; allocate +1 for it.
.018f0a	20 f6 90	jsr $0190f6			jsr 	AllocateTempString
.018f0d	68		pla				pla 									; pop start number off stack.
.018f0e	f0 3b		beq $018f4b			beq 	SLIError 						; exit if start = 0
.018f10	8d 9b 03	sta $039b			sta 	SliceStart
.018f13	68		pla				pla  									; pop string address.
.018f14	85 1f		sta $1f				sta 	zGenPtr+1
.018f16	68		pla				pla
.018f17	85 1e		sta $1e				sta 	zGenPtr
.018f19	da		phx				phx
.018f1a	5a		phy				phy
.018f1b	a2 00		ldx #$00			ldx 	#0 								; point to string length.
.018f1d	ac 9b 03	ldy $039b			ldy 	SliceStart 						; start of the string (+1 for count)
.018f20					_SLICopy:
.018f20	ad 9c 03	lda $039c			lda 	SliceCount 						; done count characters
.018f23	f0 12		beq $018f37			beq 	_SLIExit
.018f25	ce 9c 03	dec $039c			dec 	SliceCount
.018f28	98		tya				tya 									; index of character
.018f29	c1 1e		cmp ($1e,x)			cmp 	(zGenPtr,x)						; compare against length
.018f2b	f0 02		beq $018f2f			beq 	_SLIOk 							; if equal, okay.
.018f2d	b0 08		bcs $018f37			bcs 	_SLIExit 						; if past end, then exit.
.018f2f	b1 1e		lda ($1e),y	_SLIOk:	lda 	(zGenPtr),y 					; copy one character
.018f31	c8		iny				iny
.018f32	20 21 91	jsr $019121			jsr 	WriteTempString
.018f35	80 e9		bra $018f20			bra 	_SLICopy 						; go round till copied characters
.018f37					_SLIExit:
.018f37	7a		ply				ply 									; restore YX
.018f38	fa		plx				plx
.018f39	4c 4a 90	jmp $01904a			jmp 	UnaryReturnTempStr 				; return new temporary string.
.018f3c	ea		nop				nop
.018f3d					SLIByteParameter:
.018f3d	20 af 8a	jsr $018aaf			jsr 	EvaluateIntegerX 				; get integer
.018f40	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.018f42	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.018f44	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.018f46	d0 03		bne $018f4b			bne 	SLIError
.018f48	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.018f4a	60		rts				rts
.018f4b					SLIError:
.018f4b	4c 1e 84	jmp $01841e			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.018f4e					Unary_Hex:
.018f4e	20 af 8a	jsr $018aaf			jsr 	EvaluateIntegerX 			; numeric parameter
.018f51	20 b6 90	jsr $0190b6			jsr 	CheckNextRParen 			; right bracket.
.018f54	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.018f56	20 f6 90	jsr $0190f6			jsr 	AllocateTempString			; allocate string space
.018f59	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.018f5b	20 7f 8f	jsr $018f7f			jsr 	_UHConvert
.018f5e	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.018f60	20 7f 8f	jsr $018f7f			jsr 	_UHConvert
.018f63	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.018f65	20 7f 8f	jsr $018f7f			jsr 	_UHConvert
.018f68	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.018f6a	20 7f 8f	jsr $018f7f			jsr 	_UHConvert
.018f6d	5a		phy				phy 								; get length of new string
.018f6e	a0 00		ldy #$00			ldy 	#0
.018f70	b1 20		lda ($20),y			lda 	(zTempStr),y
.018f72	7a		ply				ply
.018f73	c9 00		cmp #$00			cmp 	#0
.018f75	d0 05		bne $018f7c			bne 	_UHExit 					; if it was non zero okay
.018f77	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.018f79	20 21 91	jsr $019121			jsr 	WriteTempString
.018f7c					_UHExit:
.018f7c	4c 4a 90	jmp $01904a			jmp 	UnaryReturnTempStr 			; return new temporary string.
.018f7f					_UHConvert:
.018f7f	48		pha				pha
.018f80	4a		lsr a				lsr 	a 							; do MSB
.018f81	4a		lsr a				lsr 	a
.018f82	4a		lsr a				lsr 	a
.018f83	4a		lsr a				lsr 	a
.018f84	20 88 8f	jsr $018f88			jsr 	_UHNibble
.018f87	68		pla				pla 								; do LSB
.018f88					_UHNibble:
.018f88	29 0f		and #$0f			and 	#15 						; get nibble
.018f8a	d0 0c		bne $018f98			bne 	_UHNonZero
.018f8c	5a		phy				phy									; get the length
.018f8d	a0 00		ldy #$00			ldy 	#0
.018f8f	b1 20		lda ($20),y			lda 	(zTempStr),y
.018f91	7a		ply				ply
.018f92	c9 00		cmp #$00			cmp 	#0 							; suppress leading zeros.
.018f94	f0 0d		beq $018fa3			beq 	_UHExit2
.018f96	a9 00		lda #$00			lda 	#0
.018f98					_UHNonZero:
.018f98	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.018f9a	90 02		bcc $018f9e			bcc 	_UHDigit
.018f9c	69 06		adc #$06			adc 	#7-1
.018f9e					_UHDigit:
.018f9e	69 30		adc #$30			adc 	#48
.018fa0	20 21 91	jsr $019121			jsr 	WriteTempString				; output.
.018fa3					_UHExit2:
.018fa3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.018fa4					Unary_Dec:
.018fa4	20 b8 8a	jsr $018ab8			jsr 	EvaluateStringX 			; string parameter
.018fa7	20 b6 90	jsr $0190b6			jsr 	CheckNextRParen 			; right bracket.
.018faa	5a		phy				phy
.018fab	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.018fad	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018faf	f0 41		beq $018ff2			beq 	_UDFail 					; must fail if zero.
.018fb1	8d 98 03	sta $0398			sta 	SignCount 					; use SignCount as a counter
.018fb4	a9 00		lda #$00			lda 	#0 							; set result to zero integer.
.018fb6	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018fb8	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018fba	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.018fbc	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018fbe	a9 01		lda #$01			lda 	#1
.018fc0	95 85		sta $85,x			sta 	XS_Type,x
.018fc2					_UDConvertLoop:
.018fc2	5a		phy				phy 								; shift mantissa left 4
.018fc3	a0 04		ldy #$04			ldy 	#4
.018fc5					_UDShift:
.018fc5	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.018fc7	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.018fc9	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.018fcb	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.018fcd	88		dey				dey
.018fce	d0 f5		bne $018fc5			bne 	_UDShift
.018fd0	7a		ply				ply
.018fd1	c8		iny				iny 								; next character
.018fd2	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; fetch it.
.018fd4	20 f5 8f	jsr $018ff5			jsr 	ConvertUpper 				; convert to U/C
.018fd7	c9 30		cmp #$30			cmp 	#"0"
.018fd9	90 17		bcc $018ff2			bcc 	_UDFail
.018fdb	c9 3a		cmp #$3a			cmp 	#"9"+1
.018fdd	90 06		bcc $018fe5			bcc 	_UDOkay
.018fdf	e9 37		sbc #$37			sbc 	#7+"0" 						; alpha fudge
.018fe1	c9 10		cmp #$10			cmp 	#16
.018fe3	b0 0d		bcs $018ff2			bcs 	_UDFail
.018fe5					_UDOkay:
.018fe5	29 0f		and #$0f			and 	#15 						; nibble only
.018fe7	15 80		ora $80,x			ora 	XS_Mantissa+0,x
.018fe9	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018feb	ce 98 03	dec $0398			dec 	SignCount 					; do it for each character
.018fee	d0 d2		bne $018fc2			bne 	_UDConvertLoop
.018ff0	7a		ply				ply
.018ff1	60		rts				rts
.018ff2					_UDFail:
.018ff2	4c 1e 84	jmp $01841e			jmp 	BadParamError
.018ff5					ConvertUpper:
.018ff5	c9 61		cmp #$61			cmp 	#"a"
.018ff7	90 07		bcc $019000			bcc 	_CUExit
.018ff9	c9 7b		cmp #$7b			cmp 	#"z"+1
.018ffb	b0 03		bcs $019000			bcs 	_CUExit
.018ffd	38		sec				sec
.018ffe	e9 20		sbc #$20			sbc 	#32
.019000	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.019001					Unary_Chr:
.019001	20 af 8a	jsr $018aaf			jsr 	EvaluateIntegerX			; numeric parameter
.019004	20 b6 90	jsr $0190b6			jsr 	CheckNextRParen 			; right bracket.
.019007	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.019009	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01900b	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01900d	d0 0d		bne $01901c			bne 	_UCChar
.01900f	a9 01		lda #$01			lda 	#1 							; one character string
.019011	20 f6 90	jsr $0190f6			jsr 	AllocateTempString
.019014	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.019016	20 21 91	jsr $019121			jsr 	WriteTempString
.019019	4c 4a 90	jmp $01904a			jmp 	UnaryReturnTempStr
.01901c					_UCChar:
.01901c	4c 1e 84	jmp $01841e			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.01901f					Unary_Spc:
.01901f	20 af 8a	jsr $018aaf			jsr 	EvaluateIntegerX 			; numeric parameter
.019022	20 b6 90	jsr $0190b6			jsr 	CheckNextRParen 			; right bracket.
.019025	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.019027	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019029	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01902b	d0 1a		bne $019047			bne 	_USSize
.01902d	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01902f	c9 fe		cmp #$fe			cmp 	#maxString+1
.019031	b0 14		bcs $019047			bcs 	_USSize
.019033	48		pha				pha 								; save length
.019034	1a		inc a				inc 	a 							; allocate one more.
.019035	20 f6 90	jsr $0190f6			jsr 	AllocateTempString
.019038	68		pla				pla 								; get length
.019039	f0 0f		beq $01904a			beq 	UnaryReturnTempStr 			; return the current temp string
.01903b					_USLoop:
.01903b	48		pha				pha
.01903c	a9 20		lda #$20			lda 	#" "
.01903e	20 21 91	jsr $019121			jsr 	WriteTempString
.019041	68		pla				pla
.019042	3a		dec a				dec 	a
.019043	d0 f6		bne $01903b			bne 	_USLoop
.019045	80 03		bra $01904a			bra 	UnaryReturnTempStr
.019047					_USSize:
.019047	4c 1e 84	jmp $01841e			jmp 	BadParamError
.01904a					UnaryReturnTempStr:
.01904a	a5 20		lda $20				lda 	zTempStr 					; copy temp string addr -> mantissa
.01904c	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01904e	a5 21		lda $21				lda 	zTempStr+1
.019050	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019052	a9 02		lda #$02			lda 	#2 							; set type to string
.019054	95 85		sta $85,x			sta 	XS_Type,x
.019056	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/65816.asm

.019057					MemRead:
.019057	8d 98 03	sta $0398			sta 	SignCount 					; save count
.01905a	a0 00		ldy #$00			ldy 	#0 							; start from here
.01905c	b7 1a		lda [$1a],y	_MLoop1:lda 	[zlTemp1],y 				; read the long address
.01905e	95 80		sta $80,x			sta 	XS_Mantissa,x 				; copy into mantissa
.019060	c8		iny				iny 								; next to copy
.019061	e8		inx				inx
.019062	cc 98 03	cpy $0398			cpy 	SignCount 					; do required # of bytes.
.019065	d0 f5		bne $01905c			bne 	_MLoop1
.019067	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/programend.asm

.019068					UpdateProgramEnd:
.019068	a9 00		lda #$00			lda 	#BasicProgram & $FF
.01906a	85 16		sta $16				sta 	zCodePtr+0
.01906c	a9 10		lda #$10			lda 	#BasicProgram >> 8
.01906e	85 17		sta $17				sta 	zCodePtr+1
.019070	a9 00		lda #$00			lda 	#0
.019072	85 18		sta $18				sta 	zCodePtr+2
.019074	85 19		sta $19				sta 	zCodePtr+3
.019076	a0 03		ldy #$03			ldy 	#3
.019078					_UPDLoop:
.019078	a0 00		ldy #$00			ldy 	#0
.01907a	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01907c	c9 00		cmp #$00			cmp 	#0 							; end if offset is zero.
.01907e	f0 0f		beq $01908f			beq 	_UPDFoundEnd
.019080	a0 00		ldy #$00			ldy 	#0 							; point to offset
.019082	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.019084	18		clc				clc
.019085	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.019087	85 16		sta $16				sta 	zCodePtr
.019089	90 02		bcc $01908d			bcc 	_SNLNoCarry
.01908b	e6 17		inc $17				inc 	zCodePtr+1
.01908d					_SNLNoCarry:
.01908d	80 e9		bra $019078			bra 	_UPDLoop
.01908f					_UPDFoundEnd:
.01908f	18		clc				clc 								; end of program 2 on.
.019090	a5 16		lda $16				lda 	zCodePtr
.019092	69 02		adc #$02			adc 	#2
.019094	8d 04 03	sta $0304			sta 	endOfProgram
.019097	a5 17		lda $17				lda 	zCodePtr+1
.019099	69 00		adc #$00			adc 	#0
.01909b	8d 05 03	sta $0305			sta 	endOfProgram+1
.01909e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.01909f					CheckNextToken:
.01909f	d7 16		cmp [$16],y			cmp 	[zCodePtr],y
.0190a1	d0 02		bne $0190a5			bne 	CTFail 						; no, then fail
.0190a3	c8		iny				iny
.0190a4	60		rts				rts
.0190a5					CTFail:
.0190a5	20 2f 84	jsr $01842f			jsr ERR_Handler
>0190a8	4d 69 73 73 69 6e 67 20			.text "Missing token",0
>0190b0	74 6f 6b 65 6e 00
.0190b6					CheckNextRParen:
.0190b6	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0190b8	c9 be		cmp #$be			cmp 	#token_rparen
.0190ba	d0 e9		bne $0190a5			bne 	CTFail
.0190bc	c8		iny				iny
.0190bd	60		rts				rts
.0190be					CheckNextComma:
.0190be	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0190c0	c9 bf		cmp #$bf			cmp 	#token_comma
.0190c2	d0 e1		bne $0190a5			bne 	CTFail
.0190c4	c8		iny				iny
.0190c5	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/concrete.asm

.0190c6					StringConcrete:
.0190c6	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; save source to zTemp1
.0190c8	85 10		sta $10				sta 	zTemp1
.0190ca	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0190cc	85 11		sta $11				sta 	zTemp1+1
.0190ce	a0 00		ldy #$00			ldy 	#0 							; subtract the length+1 (clc) of the string.
.0190d0	18		clc				clc 								; from the string pointer
.0190d1	ad 00 03	lda $0300			lda 	StringPtr 					; and put in zTemp2 as well
.0190d4	f1 10		sbc ($10),y			sbc 	(zTemp1),y
.0190d6	8d 00 03	sta $0300			sta 	StringPtr
.0190d9	85 12		sta $12				sta 	zTemp2
.0190db	ad 01 03	lda $0301			lda 	StringPtr+1
.0190de	e9 00		sbc #$00			sbc 	#0
.0190e0	8d 01 03	sta $0301			sta 	StringPtr+1
.0190e3	85 13		sta $13				sta 	zTemp2+1
.0190e5	b1 10		lda ($10),y			lda 	(zTemp1),y 					; length add one for count
.0190e7	1a		inc a				inc 	a
.0190e8	aa		tax				tax
.0190e9	b1 10		lda ($10),y	_SCCopy:lda 	(zTemp1),y 					; copy whole thing including length
.0190eb	91 12		sta ($12),y			sta 	(zTemp2),y
.0190ed	c8		iny				iny
.0190ee	ca		dex				dex
.0190ef	d0 f8		bne $0190e9			bne 	_SCCopy
.0190f1	a5 13		lda $13				lda 	zTemp2+1 					; return concrete string in AX
.0190f3	a6 12		ldx $12				ldx 	zTemp2
.0190f5	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.0190f6					AllocateTempString:
.0190f6	48		pha				pha 								; save required count.
.0190f7	a5 21		lda $21				lda 	zTempStr+1 					; check if initialised yet ?
.0190f9	d0 0b		bne $019106			bne 	_ATSInitialised
.0190fb	ad 00 03	lda $0300			lda 	StringPtr 					; set temporary string ptr 1 page below available
.0190fe	85 20		sta $20				sta 	zTempStr					; space, this is for strings to be concreted.
.019100	ad 01 03	lda $0301			lda 	StringPtr+1
.019103	3a		dec a				dec 	a
.019104	85 21		sta $21				sta 	zTempStr+1
.019106					_ATSInitialised:
.019106	68		pla				pla 								; get required count back.
.019107	49 ff		eor #$ff			eor 	#$FF 						; negate 2's complement.
.019109	1a		inc a				inc 	a
.01910a	18		clc				clc
.01910b	65 20		adc $20				adc 	zTempStr 					; "add" to the temp string pointer
.01910d	85 20		sta $20				sta 	zTempStr
.01910f	a9 ff		lda #$ff			lda 	#$FF
.019111	65 21		adc $21				adc 	zTempStr+1
.019113	85 21		sta $21				sta 	zTempStr+1
.019115	a9 00		lda #$00			lda 	#0 							; clear temp string.
.019117	5a		phy				phy
.019118	a8		tay				tay
.019119	91 20		sta ($20),y			sta 	(zTempStr),y
.01911b	7a		ply				ply
.01911c	1a		inc a				inc 	a 							; reset the write index.
.01911d	8d 99 03	sta $0399			sta 	TempStringWriteIndex
.019120	60		rts				rts
.019121					WriteTempString:
.019121	5a		phy				phy 								; save Y
.019122	ac 99 03	ldy $0399			ldy 	TempStringWriteIndex	 	; write position.
.019125	91 20		sta ($20),y			sta 	(zTempStr),y 				; write character out.
.019127	ee 99 03	inc $0399			inc 	TempStringWriteIndex 		; increment the write position.
.01912a	98		tya				tya 								; unchanged Y is now length
.01912b	a0 00		ldy #$00			ldy 	#0
.01912d	91 20		sta ($20),y			sta 	(zTempStr),y
.01912f	7a		ply				ply 								; restore Y and exit
.019130	60		rts				rts
.019131					CreateTempStringCopy:
.019131	da		phx				phx 								; save X
.019132	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019134	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.019135	20 f6 90	jsr $0190f6			jsr 	AllocateTempString 			; allocate memory for temporary string.
.019138	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01913a	c8		iny				iny
.01913b	3a		dec a				dec 	a 							; make the actual length in charactes
.01913c	3a		dec a				dec 	a
.01913d	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.01913f	81 20		sta ($20,x)			sta 	(zTempStr,x)
.019141	85 1a		sta $1a				sta 	zLTemp1 					; that's used as a count.
.019143	09 00		ora #$00			ora 	#0 							; if zero already, exit
.019145	f0 0e		beq $019155			beq 	_CTSCExit
.019147					_CTSCLoop:
.019147	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019149	c8		iny				iny
.01914a	5a		phy				phy 								; save in Y
.01914b	e8		inx				inx 								; bump index
.01914c	da		phx				phx 								; index into Y
.01914d	7a		ply				ply
.01914e	91 20		sta ($20),y			sta 	(zTempStr),y 				; save at index
.019150	7a		ply				ply 								; restore Y
.019151	c6 1a		dec $1a				dec 	zLTemp1 					; do for each character
.019153	d0 f2		bne $019147			bne 	_CTSCLoop
.019155					_CTSCExit:
.019155	fa		plx				plx 								; restore X
.019156	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/variables.asm

.019157					VariableFind:
.019157	20 c4 91	jsr $0191c4			jsr 	VariableExtract 		; find out all about it ....
.01915a	20 5d 94	jsr $01945d			jsr 	VariableLocate 			; does it already exist ?
.01915d	b0 03		bcs $019162			bcs 	_VFExists 				; if so, use that.
.01915f	20 50 92	jsr $019250			jsr 	VariableCreate 			; otherwise create it.
.019162					_VFExists:
.019162	a5 24		lda $24				lda 	zVarType 				; is it still an array ?
.019164	29 01		and #$01			and 	#1
.019166	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.019168	d0 28		bne $019192			bne 	_VFSingleElement
.01916a					_VFNextIndex:
.01916a	a5 22		lda $22				lda 	zVarDataPtr 			; push the data ptr and type on the stack.
.01916c	48		pha				pha
.01916d	a5 23		lda $23				lda 	zVarDataPtr+1
.01916f	48		pha				pha
.019170	a5 24		lda $24				lda 	zVarType
.019172	48		pha				pha
.019173	20 af 8a	jsr $018aaf			jsr 	EvaluateIntegerX 		; calculate the index.
.019176	68		pla				pla 							; restore and index.
.019177	85 24		sta $24				sta 	zVarType
.019179	68		pla				pla
.01917a	85 23		sta $23				sta 	zVarDataPtr+1
.01917c	68		pla				pla
.01917d	85 22		sta $22				sta 	zVarDataPtr
.01917f	20 db 92	jsr $0192db			jsr 	ArrayIndexFollow 		; do the index.
.019182	a5 24		lda $24				lda 	zVarType 				; is it still an array ??
.019184	29 01		and #$01			and 	#1
.019186	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.019188	d0 05		bne $01918f			bne 	_VFArrayDone 			; if so then exit.
.01918a	20 be 90	jsr $0190be			jsr 	CheckNextComma 			; comma should follow
.01918d	80 db		bra $01916a			bra 	_VFNextIndex
.01918f					_VFArrayDone:
.01918f	20 b6 90	jsr $0190b6			jsr 	CheckNextRParen 		; check closing right bracket.
.019192					_VFSingleElement:
.019192	60		rts				rts
.019193					VariableClear:
.019193	48		pha				pha 							; save registers
.019194	da		phx				phx
.019195	a2 00		ldx #$00			ldx 	#0 						; clear out the hash table.
.019197	8a		txa				txa
.019198	9d 2f 03	sta $032f,x	_VCLoop:sta 	HashTableBase,x
.01919b	e8		inx				inx
.01919c	e0 60		cpx #$60			cpx 	#HashTableEnd-HashTableBase
.01919e	d0 f8		bne $019198			bne 	_VCLoop
.0191a0	ad 04 03	lda $0304			lda 	endOfProgram
.0191a3	8d 02 03	sta $0302			sta 	VarMemPtr
.0191a6	ad 05 03	lda $0305			lda 	endOfProgram+1
.0191a9	8d 03 03	sta $0303			sta 	VarMemPtr+1
.0191ac	fa		plx				plx 							; restore registers
.0191ad	68		pla				pla
.0191ae	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/extract.asm

.0191af					VariableNameError:
.0191af	20 2f 84	jsr $01842f			jsr ERR_Handler
>0191b2	42 61 64 20 56 61 72 69			.text "Bad Variable Name",0
>0191ba	61 62 6c 65 20 4e 61 6d 65 00
.0191c4					VariableExtract:
.0191c4	da		phx				phx 							; save X.
.0191c5	a9 ba		lda #$ba			lda 	#token_hashlParen  		; set the type to #( e.g. real array.
.0191c7	8d 8f 03	sta $038f			sta 	Var_Type
.0191ca	8d 90 03	sta $0390			sta 	Var_Hash 				; we initialise the hash with this. It doesn't matter
.0191cd	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0191cf	c9 00		cmp #$00			cmp 	#0 						; first one must be A-Z
.0191d1	f0 dc		beq $0191af			beq 	VariableNameError
.0191d3	c9 1b		cmp #$1b			cmp 	#26+1
.0191d5	b0 d8		bcs $0191af			bcs 	VariableNameError
.0191d7	a2 ff		ldx #$ff			ldx 	#255 					; now copy it into the variable buffer.
.0191d9					_VECopyBuffer:
.0191d9	e8		inx				inx
.0191da	e0 1f		cpx #$1f			cpx 	#31 					; too long
.0191dc	f0 d1		beq $0191af			beq 	VariableNameError
.0191de	9d 0f 03	sta $030f,x			sta 	Var_Buffer,x 			; save character
.0191e1	18		clc				clc  							; update the hash value for it.
.0191e2	6d 90 03	adc $0390			adc 	Var_Hash
.0191e5	8d 90 03	sta $0390			sta 	Var_Hash
.0191e8	c8		iny				iny
.0191e9	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0191eb	c9 00		cmp #$00			cmp 	#0 						; zero or token, end of variable
.0191ed	f0 0e		beq $0191fd			beq 	_VECopyEnd
.0191ef	30 0c		bmi $0191fd			bmi 	_VECopyEnd
.0191f1	c9 1b		cmp #$1b			cmp 	#26+1 					; A-Z continue copying
.0191f3	90 e4		bcc $0191d9			bcc 	_VECopyBuffer
.0191f5	c9 30		cmp #$30			cmp 	#"0" 					; 0-9 copy as well.
.0191f7	90 04		bcc $0191fd			bcc 	_VECopyEnd
.0191f9	c9 3a		cmp #$3a			cmp 	#"9"+1
.0191fb	90 dc		bcc $0191d9			bcc 	_VECopyBuffer
.0191fd					_VECopyEnd:
.0191fd	c8		iny				iny
.0191fe	c9 b7		cmp #$b7			cmp 	#token_Dollar 			; first type token.
.019200	90 04		bcc $019206			bcc 	_VEDefaultRequired
.019202	c9 bd		cmp #$bd			cmp 	#token_PercentLParen+1	; last type token.
.019204	90 0b		bcc $019211			bcc 	_VEHaveType
.019206					_VEDefaultRequired:
.019206	c9 bd		cmp #$bd			cmp 	#token_LParen 			; if it ends in ( then use the real array
.019208	f0 04		beq $01920e			beq 	_VESetType 				; default set above.
.01920a	ce 8f 03	dec $038f			dec 	Var_Type 				; this changes that default to the variable default
.01920d	88		dey				dey
.01920e					_VESetType:
.01920e	ad 8f 03	lda $038f			lda 	Var_Type 				; get type ....
.019211					_VEHaveType:
.019211	8d 8f 03	sta $038f			sta 	Var_Type 				; save as type.
.019214	bd 0f 03	lda $030f,x			lda 	Var_Buffer,x 			; set bit 7 of name, marks the end.
.019217	09 80		ora #$80			ora 	#$80
.019219	9d 0f 03	sta $030f,x			sta 	Var_Buffer,x
.01921c	e8		inx				inx 							; offset 3 => length 4.
.01921d	8e 91 03	stx $0391			stx 	Var_Length 				; save length of variable name.
.019220	ad 8f 03	lda $038f			lda 	Var_Type 				; get offset of var type from first type token
.019223	38		sec				sec
.019224	e9 b7		sbc #$b7			sbc 	#token_Dollar
.019226	0a		asl a				asl 	a 						; multiply by 16. This requires HashTableSize
.019227	0a		asl a				asl 	a 						; in data.asm to be 8 (8 sets of links,2 bytes each)
.019228	0a		asl a				asl 	a
.019229	0a		asl a				asl 	a
.01922a	8d 92 03	sta $0392			sta 	Var_HashAddress
.01922d	ad 90 03	lda $0390			lda 	Var_Hash 				; get the hash
.019230	29 07		and #$07			and 	#(HashTableSize-1) 		; force into range 0-tableSize-1
.019232	0a		asl a				asl 	a 						; double it (2 bytes per entry) & clears carry
.019233	6d 92 03	adc $0392			adc 	Var_HashAddress 		; add table offset.
.019236	69 2f		adc #$2f			adc 	#HashTableBase & $FF 	; now the low byte of the actual table address
.019238	8d 92 03	sta $0392			sta 	Var_HashAddress
.01923b	a2 05		ldx #$05			ldx 	#5 						; hash is 5 bytes (real)
.01923d	ad 8f 03	lda $038f			lda 	Var_Type
.019240	c9 b9		cmp #$b9			cmp 	#token_Hash
.019242	f0 07		beq $01924b			beq 	_VEHaveSize
.019244	ca		dex				dex
.019245	c9 bb		cmp #$bb			cmp 	#token_Percent 			; percent is 4 bytes (integer)
.019247	f0 02		beq $01924b			beq 	_VEHaveSize
.019249	a2 02		ldx #$02			ldx 	#2 						; everything else is two.
.01924b					_VEHaveSize:
.01924b	8e 93 03	stx $0393			stx 	Var_DataSize
.01924e	fa		plx				plx
.01924f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varcreate.asm

.019250					VariableCreate:
.019250	da		phx				phx
.019251	5a		phy				phy
.019252	ad 02 03	lda $0302			lda 	VarMemPtr 					; get address of next free into zTemp1
.019255	85 10		sta $10				sta 	zTemp1
.019257	ad 03 03	lda $0303			lda 	VarMemPtr+1
.01925a	85 11		sta $11				sta 	zTemp1+1
.01925c	ad 93 03	lda $0393			lda 	Var_DataSize 				; bytes for the data bit
.01925f	18		clc				clc
.019260	6d 91 03	adc $0391			adc 	Var_Length 					; add the length of the name
.019263	69 03		adc #$03			adc 	#3 							; 3 for the link and the hash.
.019265	6d 02 03	adc $0302			adc 	VarMemPtr 					; add to variable memory pointer
.019268	8d 02 03	sta $0302			sta 	VarMemPtr
.01926b	90 03		bcc $019270			bcc 	_VCNoCarry
.01926d	ee 03 03	inc $0303			inc 	VarMemPtr+1
.019270					_VCNoCarry:
.019270	ad 92 03	lda $0392			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.019273	85 12		sta $12				sta 	zTemp2
.019275	a9 03		lda #$03			lda 	#HashTableBase >> 8
.019277	85 13		sta $13				sta 	zTemp2+1
.019279	a0 00		ldy #$00			ldy 	#0 							; put current hash link in position.
.01927b	b1 12		lda ($12),y			lda 	(zTemp2),y
.01927d	91 10		sta ($10),y			sta 	(zTemp1),y
.01927f	c8		iny				iny
.019280	b1 12		lda ($12),y			lda 	(zTemp2),y
.019282	91 10		sta ($10),y			sta 	(zTemp1),y
.019284	c8		iny				iny
.019285	ad 90 03	lda $0390			lda 	Var_Hash 					; write the hash out.
.019288	91 10		sta ($10),y			sta 	(zTemp1),y
.01928a	c8		iny				iny
.01928b	a2 00		ldx #$00			ldx 	#0 							; copy the name out.
.01928d					_VCCopyName:
.01928d	bd 0f 03	lda $030f,x			lda 	Var_Buffer,x
.019290	91 10		sta ($10),y			sta 	(zTemp1),y
.019292	e8		inx				inx
.019293	c8		iny				iny
.019294	ec 91 03	cpx $0391			cpx 	Var_Length
.019297	d0 f4		bne $01928d			bne 	_VCCopyName
.019299	5a		phy				phy 								; save the data offset.
.01929a	ae 93 03	ldx $0393			ldx 	Var_DataSize 				; and write the data out.
.01929d	a9 00		lda #$00			lda 	#0 							; which is all zeroes.
.01929f					_VCClearData:
.01929f	91 10		sta ($10),y			sta 	(zTemp1),y
.0192a1	c8		iny				iny
.0192a2	ca		dex				dex
.0192a3	d0 fa		bne $01929f			bne 	_VCClearData
.0192a5	68		pla				pla 								; offset to the data
.0192a6	18		clc				clc
.0192a7	65 10		adc $10				adc 	zTemp1 						; add to start and save as data pointer.
.0192a9	85 22		sta $22				sta 	zVarDataPtr
.0192ab	a5 11		lda $11				lda 	zTemp1+1
.0192ad	69 00		adc #$00			adc 	#0
.0192af	85 23		sta $23				sta 	zVarDataPtr+1
.0192b1	ad 8f 03	lda $038f			lda 	Var_Type 					; and set the type.
.0192b4	85 24		sta $24				sta 	zVarType
.0192b6	a5 10		lda $10				lda 	zTemp1 						; fix hash link to point to new record
.0192b8	a0 00		ldy #$00			ldy 	#0
.0192ba	91 12		sta ($12),y			sta 	(zTemp2),y
.0192bc	c8		iny				iny
.0192bd	a5 11		lda $11				lda 	zTemp1+1
.0192bf	91 12		sta ($12),y			sta 	(zTemp2),y
.0192c1	ad 8f 03	lda $038f			lda 	Var_Type 					; array ? if so create the empty one.
.0192c4	29 01		and #$01			and 	#1
.0192c6	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.0192c8	d0 0e		bne $0192d8			bne 	_VCNotArray
.0192ca	a2 00		ldx #$00			ldx 	#0 							; call recursive array creator
.0192cc	20 72 93	jsr $019372			jsr 	ArrayCreate
.0192cf	5a		phy				phy 								; save YA at zVarDataPtr
.0192d0	a0 00		ldy #$00			ldy 	#0
.0192d2	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0192d4	c8		iny				iny
.0192d5	68		pla				pla
.0192d6	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0192d8					_VCNotArray:
.0192d8	7a		ply				ply
.0192d9	fa		plx				plx
.0192da	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arrayidx.asm

.0192db					ArrayIndexFollow:
.0192db	5a		phy				phy
.0192dc	a0 00		ldy #$00			ldy 	#0 							; make zVarDataPtr point to the array.
.0192de	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; e.g. it points to itself.
.0192e0	48		pha				pha
.0192e1	c8		iny				iny
.0192e2	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.0192e4	85 23		sta $23				sta 	zVarDataPtr+1
.0192e6	68		pla				pla
.0192e7	85 22		sta $22				sta 	zVarDataPtr
.0192e9	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; MSB of 16 bit integer and bytes 2&3
.0192eb	29 80		and #$80			and 	#$80 						; must be zero.
.0192ed	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.0192ef	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.0192f1	d0 59		bne $01934c			bne 	_AIFError
.0192f3	a0 00		ldy #$00			ldy 	#0 							; calculate size - current - 1
.0192f5	18		clc				clc
.0192f6	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.0192f8	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.0192fa	c8		iny				iny
.0192fb	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.0192fd	08		php				php 								; clear bit 7 retaining borrow.
.0192fe	29 7f		and #$7f			and 	#$7F
.019300	28		plp				plp
.019301	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.019303	90 47		bcc $01934c			bcc 	_AIFError 					; eror if size-current < 0
.019305	b5 80		lda $80,x			lda  	XS_Mantissa+0,x 			; copy and double the index
.019307	0a		asl a				asl 	a 							; (e.g. index * 2)
.019308	85 10		sta $10				sta 	zTemp1
.01930a	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01930c	2a		rol a				rol 	a
.01930d	85 11		sta $11				sta 	zTemp1+1
.01930f	a0 01		ldy #$01			ldy 	#1 							; is this a data entry.
.019311	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; if so, then type is unchanged, offset set
.019313	30 1d		bmi $019332			bmi 	_AIFCalculate
.019315	c6 24		dec $24				dec 	zVarType 					; converts from an array to a type.
.019317	a5 24		lda $24				lda 	zVarType 					; check that type
.019319	c9 b7		cmp #$b7			cmp 	#token_Dollar 				; if string, use x 2
.01931b	f0 15		beq $019332			beq 	_AIFCalculate
.01931d	06 10		asl $10				asl 	zTemp1			 			; double the index
.01931f	26 11		rol $11				rol 	zTemp1+1					; (e.g. index * 4)
.019321	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if integer, use x 4
.019323	f0 0d		beq $019332			beq 	_AIFCalculate
.019325	18		clc				clc 								; add the original mantissa in again
.019326	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; which makes it x5, for float.
.019328	65 10		adc $10				adc 	zTemp1
.01932a	85 10		sta $10				sta 	zTemp1
.01932c	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01932e	65 11		adc $11				adc 	zTemp1+1
.019330	85 11		sta $11				sta 	zTemp1+1
.019332					_AIFCalculate:
.019332	18		clc				clc 								; add index x 2,4 or 5 to base
.019333	a5 22		lda $22				lda 	zVarDataPtr
.019335	65 10		adc $10				adc 	zTemp1
.019337	85 22		sta $22				sta 	zVarDataPtr
.019339	a5 23		lda $23				lda 	zVarDataPtr+1
.01933b	65 11		adc $11				adc 	zTemp1+1
.01933d	85 23		sta $23				sta 	zVarDataPtr+1
.01933f	18		clc				clc 								; add 2 more for the length prefix.
.019340	a5 22		lda $22				lda 	zVarDataPtr
.019342	69 02		adc #$02			adc 	#2
.019344	85 22		sta $22				sta 	zVarDataPtr
.019346	90 02		bcc $01934a			bcc 	_AIFNoBump
.019348	e6 23		inc $23				inc 	zVarDataPtr+1
.01934a					_AIFNoBump:
.01934a	7a		ply				ply
.01934b	60		rts				rts
.01934c					_AIFError:
.01934c	20 2f 84	jsr $01842f			jsr ERR_Handler
>01934f	42 61 64 20 61 72 72 61			.text "Bad array index",0
>019357	79 20 69 6e 64 65 78 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arraydef.asm

.01935f					ArrayResetDefault:
.01935f	a9 0b		lda #$0b			lda 	#11 						; 0..10 one array
.019361	8d a1 03	sta $03a1			sta 	ArrayDef+0
.019364	a9 00		lda #$00			lda 	#0
.019366	8d a2 03	sta $03a2			sta 	ArrayDef+1
.019369	a9 ff		lda #$ff			lda 	#$FF
.01936b	8d a3 03	sta $03a3			sta 	ArrayDef+2 					; $FFFF implies no second element.
.01936e	8d a4 03	sta $03a4			sta 	ArrayDef+3					; (test bit 7 of 2nd byte)
.019371	60		rts				rts
.019372					ArrayCreate:
.019372	bd a1 03	lda $03a1,x			lda 	ArrayDef+0,x 				; put size x 2 in zTemp1
.019375	0a		asl a				asl 	a
.019376	85 10		sta $10				sta 	zTemp1
.019378	bd a2 03	lda $03a2,x			lda 	ArrayDef+1,x
.01937b	2a		rol a				rol 	a
.01937c	85 11		sta $11				sta 	zTemp1+1
.01937e	bd a4 03	lda $03a4,x			lda 	ArrayDef+3,x 				; if this is the last element it's array of ptrs.
.019381	10 22		bpl $0193a5			bpl 	_ACSized 					; if not multiply size x 2 (str) 4 (int) 5 (real)
.019383	ad 8f 03	lda $038f			lda 	Var_Type 					; check the type
.019386	c9 b8		cmp #$b8			cmp 	#token_DollarLParen 		; also if it is an array of strings $(
.019388	f0 1b		beq $0193a5			beq 	_ACSized
.01938a	06 10		asl $10				asl 	zTemp1 						; double again
.01938c	26 11		rol $11				rol 	zTemp1+1
.01938e	b0 6f		bcs $0193ff			bcs 	ArrayIndexError 			; too large.
.019390	c9 bc		cmp #$bc			cmp 	#token_PercentLParen 		; if %( four bytes/entry is enough.
.019392	f0 11		beq $0193a5			beq 	_ACSized
.019394	18		clc				clc 								; add original value x 5 for reals.
.019395	a5 10		lda $10				lda 	zTemp1
.019397	7d a1 03	adc $03a1,x			adc 	ArrayDef+0,x
.01939a	85 10		sta $10				sta 	zTemp1
.01939c	a5 11		lda $11				lda 	zTemp1+1
.01939e	7d a2 03	adc $03a2,x			adc 	ArrayDef+1,x
.0193a1	85 11		sta $11				sta 	zTemp1+1
.0193a3	b0 5a		bcs $0193ff			bcs 	ArrayIndexError
.0193a5					_ACSized:
.0193a5	18		clc				clc
.0193a6	a5 10		lda $10				lda 	zTemp1
.0193a8	69 02		adc #$02			adc 	#2
.0193aa	85 10		sta $10				sta 	zTemp1
.0193ac	90 04		bcc $0193b2			bcc 	_ACNoBump
.0193ae	e6 10		inc $10				inc 	zTemp1
.0193b0	f0 4d		beq $0193ff			beq 	ArrayIndexError
.0193b2					_ACNoBump:
.0193b2	18		clc				clc
.0193b3	ad 02 03	lda $0302			lda 	VarMemPtr 					; add this allocated count to VarMemPtr
.0193b6	85 12		sta $12				sta 	zTemp2						; save start in zTemp2/zTemp3
.0193b8	85 14		sta $14				sta 	zTemp3
.0193ba	65 10		adc $10				adc 	zTemp1
.0193bc	8d 02 03	sta $0302			sta 	VarMemPtr
.0193bf	ad 03 03	lda $0303			lda 	VarMemPtr+1
.0193c2	85 13		sta $13				sta 	zTemp2+1
.0193c4	85 15		sta $15				sta 	zTemp3+1
.0193c6	65 11		adc $11				adc 	zTemp1+1
.0193c8	8d 03 03	sta $0303			sta 	VarMemPtr+1
.0193cb	85 11		sta $11				sta 	zTemp1+1
.0193cd	b0 30		bcs $0193ff			bcs 	ArrayIndexError
.0193cf	a0 00		ldy #$00			ldy 	#0							; write $00 out.
.0193d1					_ACClear:
.0193d1	98		tya				tya
.0193d2	91 12		sta ($12),y			sta 	(zTemp2),y
.0193d4	e6 12		inc $12				inc 	zTemp2
.0193d6	d0 02		bne $0193da			bne 	_ACCBump
.0193d8	e6 13		inc $13				inc 	zTemp2+1
.0193da					_ACCBump:
.0193da	a5 12		lda $12				lda 	zTemp2
.0193dc	cd 02 03	cmp $0302			cmp 	VarMemPtr
.0193df	d0 f0		bne $0193d1			bne 	_ACClear
.0193e1	a5 13		lda $13				lda 	zTemp2+1
.0193e3	cd 03 03	cmp $0303			cmp 	VarMemPtr+1
.0193e6	d0 e9		bne $0193d1			bne 	_ACClear
.0193e8	a0 00		ldy #$00			ldy 	#0
.0193ea	bd a1 03	lda $03a1,x			lda 	ArrayDef+0,x 				; copy the size into the start
.0193ed	91 14		sta ($14),y			sta 	(zTemp3),y
.0193ef	c8		iny				iny
.0193f0	bd a2 03	lda $03a2,x			lda 	ArrayDef+1,x
.0193f3	91 14		sta ($14),y			sta 	(zTemp3),y
.0193f5	bd a4 03	lda $03a4,x			lda 	ArrayDef+3,x 				; have we reached the end
.0193f8	10 18		bpl $019412			bpl 	ACCFillRecursive
.0193fa	a4 15		ldy $15				ldy 	zTemp3+1 					; return address
.0193fc	a5 14		lda $14				lda 	zTemp3
.0193fe	60		rts				rts
.0193ff					ArrayIndexError:
.0193ff	20 2f 84	jsr $01842f			jsr ERR_Handler
>019402	42 61 64 20 61 72 72 61			.text "Bad array index",0
>01940a	79 20 69 6e 64 65 78 00
.019412					ACCFillRecursive:
.019412	a9 ff		lda #$ff			lda 	#$FF 						; we mark the end, this is free space.
.019414	a0 00		ldy #$00			ldy 	#0 							; this is overwritten by size of next allocated
.019416	91 12		sta ($12),y			sta 	(zTemp2),y 					; array, but we might change that.
.019418	c8		iny				iny
.019419	b1 14		lda ($14),y			lda 	(zTemp3),y 					; set bit 15 of the max index indicating
.01941b	09 80		ora #$80			ora 	#$80 						; an array of pointers
.01941d	91 14		sta ($14),y			sta 	(zTemp3),y
.01941f	a5 14		lda $14				lda 	zTemp3 						; push the start on the stack
.019421	48		pha				pha
.019422	a5 15		lda $15				lda 	zTemp3+1
.019424	48		pha				pha
.019425					_ACCFillLoop:
.019425	18		clc				clc
.019426	a5 14		lda $14				lda 	zTemp3 						; and work forwards.
.019428	69 02		adc #$02			adc 	#2
.01942a	85 14		sta $14				sta 	zTemp3
.01942c	90 02		bcc $019430			bcc 	_ACCSkip2
.01942e	e6 14		inc $14				inc 	zTemp3
.019430					_ACCSkip2:
.019430	a0 00		ldy #$00			ldy 	#0 							; reached the end ?
.019432	b1 14		lda ($14),y			lda 	(zTemp3),y					; (looking for FF marker, everything else 00)
.019434	c8		iny				iny
.019435	11 14		ora ($14),y			ora 	(zTemp3),y
.019437	d0 21		bne $01945a			bne 	_ACCExit
.019439	a5 14		lda $14				lda 	zTemp3 						; push zTemp3
.01943b	48		pha				pha
.01943c	a5 15		lda $15				lda 	zTemp3+1
.01943e	48		pha				pha
.01943f	e8		inx				inx
.019440	e8		inx				inx
.019441	20 72 93	jsr $019372			jsr 	ArrayCreate 				; create array recursively.
.019444	ca		dex				dex
.019445	ca		dex				dex
.019446	85 12		sta $12				sta 	zTemp2 						; save A
.019448	68		pla				pla
.019449	85 15		sta $15				sta 	zTemp3+1 					; restore zTemp3
.01944b	68		pla				pla
.01944c	85 14		sta $14				sta 	zTemp3
.01944e	98		tya				tya 								; write high bye from Y
.01944f	a0 01		ldy #$01			ldy 	#1
.019451	91 14		sta ($14),y			sta 	(zTemp3),y
.019453	88		dey				dey 								; write low byte out.
.019454	a5 12		lda $12				lda 	zTemp2
.019456	91 14		sta ($14),y			sta 	(zTemp3),y
.019458	80 cb		bra $019425			bra 	_ACCFillLoop 				; and try again.
.01945a					_ACCExit:
.01945a	7a		ply				ply 								; restore the original address
.01945b	68		pla				pla
.01945c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varfind.asm

.01945d					VariableLocate:
.01945d	da		phx				phx
.01945e	5a		phy				phy
.01945f	ad 92 03	lda $0392			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.019462	85 12		sta $12				sta 	zTemp2 						; points to first address.
.019464	a9 03		lda #$03			lda 	#HashTableBase >> 8
.019466	85 13		sta $13				sta 	zTemp2+1
.019468	a0 00		ldy #$00	_VLNext:ldy 	#0 							; get next link into AX
.01946a	b1 12		lda ($12),y			lda 	(zTemp2),y
.01946c	aa		tax				tax
.01946d	c8		iny				iny
.01946e	b1 12		lda ($12),y			lda 	(zTemp2),y
.019470	85 13		sta $13				sta 	zTemp2+1 					; save in zTemp
.019472	86 12		stx $12				stx 	zTemp2
.019474	05 12		ora $12				ora 	zTemp2 						; got zero
.019476	18		clc				clc
.019477	f0 25		beq $01949e			beq 	_VLExit 					; if so, then fail as end of chain.
.019479	c8		iny				iny 								; point to hash (offset + 2)
.01947a	b1 12		lda ($12),y			lda 	(zTemp2),y
.01947c	cd 90 03	cmp $0390			cmp 	Var_Hash
.01947f	d0 e7		bne $019468			bne 	_VLNext 					; try next if different.
.019481					_VLCompare:
.019481	c8		iny				iny 								; next character
.019482	b1 12		lda ($12),y			lda 	(zTemp2),y 					; compare variable field against buffer.
.019484	d9 0c 03	cmp $030c,y			cmp 	Var_Buffer-3,y 				; the -3 is because name starts at 3.
.019487	d0 df		bne $019468			bne 	_VLNext 					; fail if different, try next.
.019489	0a		asl a				asl 	a 							; until end character (bit 7 set) matched
.01948a	90 f5		bcc $019481			bcc 	_VLCompare
.01948c	98		tya				tya
.01948d	38		sec				sec 								; add 1 as Y points to last character
.01948e	65 12		adc $12				adc 	zTemp2 						; add to the current address
.019490	85 22		sta $22				sta 	zVarDataPtr
.019492	a5 13		lda $13				lda 	zTemp2+1
.019494	69 00		adc #$00			adc 	#0
.019496	85 23		sta $23				sta 	zVarDataPtr+1
.019498	ad 8f 03	lda $038f			lda 	Var_Type 					; and set the type.
.01949b	85 24		sta $24				sta 	zVarType
.01949d	38		sec				sec 								; return CS
.01949e	7a		ply		_VLExit:ply
.01949f	fa		plx				plx
.0194a0	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/vargetset.asm

.0194a1					VariableGet:
.0194a1	5a		phy				phy
.0194a2	a0 00		ldy #$00			ldy 	#0 							; copy first two bytes
.0194a4	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.0194a6	95 80		sta $80,x			sta 	XS_Mantissa,x
.0194a8	c8		iny				iny
.0194a9	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.0194ab	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0194ad	c8		iny				iny
.0194ae	a5 24		lda $24				lda 	zVarType 					; if it is a string, set up for that.
.0194b0	c9 b7		cmp #$b7			cmp 	#token_Dollar
.0194b2	f0 2c		beq $0194e0			beq 	_VGString
.0194b4	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; copy the next two bytes.
.0194b6	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0194b8	c8		iny				iny
.0194b9	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.0194bb	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0194bd	c8		iny				iny
.0194be	a9 01		lda #$01			lda 	#1 							; set type to 1.
.0194c0	95 85		sta $85,x			sta 	XS_Type,x
.0194c2	a5 24		lda $24				lda 	zVarType
.0194c4	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if it is a %, then exit with default integer.
.0194c6	f0 28		beq $0194f0			beq 	_VGExit
.0194c8	a9 40		lda #$40			lda 	#$40 						; set type byte to zero
.0194ca	95 85		sta $85,x			sta 	XS_Type,x 					; which is the code for zero/float.
.0194cc	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; the last value to copy is the exponent.
.0194ce	95 84		sta $84,x			sta 	XS_Exponent,x
.0194d0	f0 1e		beq $0194f0			beq 	_VGExit 					; if exponent is zero ... it's zero.
.0194d2	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; the sign bit is the top mantissa bit.
.0194d4	48		pha				pha
.0194d5	29 80		and #$80			and 	#$80
.0194d7	95 85		sta $85,x			sta 	XS_Type,x 					; this is the type byte.
.0194d9	68		pla				pla
.0194da	09 80		ora #$80			ora 	#$80 						; set the MSB as you would expect.
.0194dc	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; so it's a normalised float.
.0194de	80 10		bra $0194f0			bra 	_VGExit
.0194e0					_VGString:
.0194e0	a9 02		lda #$02			lda 	#2 							; set type to 2, a string
.0194e2	95 85		sta $85,x			sta 	XS_Type,x
.0194e4	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; is the value there $0000
.0194e6	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.0194e8	d0 06		bne $0194f0			bne 	_VGExit 					; if not, exit.
.0194ea	85 25		sta $25				sta 	zNullString 				; make zNullString a 00 string.
.0194ec	a9 25		lda #$25			lda 	#zNullString
.0194ee	95 80		sta $80,x			sta 	XS_Mantissa,x 				; make it point to it.
.0194f0					_VGExit:
.0194f0	7a		ply				ply
.0194f1	60		rts				rts
.0194f2					VariableSet:
.0194f2	b5 85		lda $85,x			lda 	XS_Type,x 					; is the result a string
.0194f4	29 02		and #$02			and 	#2 							; if so, it has to be
.0194f6	d0 4b		bne $019543			bne 	_VSString
.0194f8	a5 24		lda $24				lda 	zVarType 					; if type is $ there's an error.
.0194fa	c9 b7		cmp #$b7			cmp 	#token_Dollar
.0194fc	f0 42		beq $019540			beq 	_VSBadType
.0194fe	c9 bb		cmp #$bb			cmp 	#token_Percent 				; type convert to float/int
.019500	f0 05		beq $019507			beq 	_VSMakeInt
.019502	20 2b 9a	jsr $019a2b			jsr 	FPUToFloat
.019505	80 03		bra $01950a			bra 	_VSCopy
.019507					_VSMakeInt:
.019507	20 77 9a	jsr $019a77			jsr 	FPUToInteger
.01950a					_VSCopy:
.01950a	5a		phy				phy
.01950b	a0 00		ldy #$00			ldy 	#0 							; copy mantissa to target.
.01950d	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01950f	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019511	c8		iny				iny
.019512	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019514	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019516	c8		iny				iny
.019517	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019519	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.01951b	c8		iny				iny
.01951c	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01951e	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019520	a5 24		lda $24				lda 	zVarType 					; if target is integer, alrady done.
.019522	c9 bb		cmp #$bb			cmp 	#token_Percent
.019524	f0 18		beq $01953e			beq 	_VSExit
.019526	b5 85		lda $85,x			lda 	XS_Type,x 					; get the sign bit into carry flag.
.019528	0a		asl a				asl 	a
.019529	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; shift the sign into the mantissa high.
.01952b	08		php				php
.01952c	0a		asl a				asl 	a
.01952d	28		plp				plp
.01952e	6a		ror a				ror 	a
.01952f	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019531	c8		iny				iny
.019532	b5 84		lda $84,x			lda 	XS_Exponent,x 				; copy the exponent in
.019534	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019536	34 85		bit $85,x			bit 	XS_Type,x 					; if the result is non zero
.019538	50 04		bvc $01953e			bvc 	_VSExit
.01953a	a9 00		lda #$00			lda 	#00 						; zero exponent indicating 0.
.01953c	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.01953e					_VSExit:
.01953e	7a		ply				ply
.01953f	60		rts				rts
.019540					_VSBadType:
.019540	4c 10 84	jmp $018410			jmp 	TypeError
.019543					_VSString:
.019543	a5 24		lda $24				lda 	zVarType 					; type must be $
.019545	c9 b7		cmp #$b7			cmp 	#token_Dollar
.019547	d0 f7		bne $019540			bne 	_VSBadType
.019549	da		phx				phx
.01954a	5a		phy				phy
.01954b	20 c6 90	jsr $0190c6			jsr 	StringConcrete 				; concrete the string in the mantissa -> AX
.01954e	a0 01		ldy #$01			ldy 	#1 							; save high byte
.019550	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019552	88		dey				dey 								; save low byte
.019553	8a		txa				txa
.019554	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019556	7a		ply				ply 								; and exit.
.019557	fa		plx				plx
.019558	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.019559					MulInteger32:
.019559	b5 80		lda $80,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.01955b	95 8c		sta $8c,x			sta 	XS3_Mantissa,x
.01955d	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01955f	95 8d		sta $8d,x			sta 	XS3_Mantissa+1,x
.019561	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019563	95 8e		sta $8e,x			sta 	XS3_Mantissa+2,x
.019565	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019567	95 8f		sta $8f,x			sta 	XS3_Mantissa+3,x
.019569	a9 00		lda #$00			lda 	#0
.01956b	95 80		sta $80,x			sta 	XS_Mantissa+0,x 				; zero +0
.01956d	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01956f	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019571	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019573					_BFMMultiply:
.019573	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.019575	29 01		and #$01			and 	#1
.019577	f0 03		beq $01957c			beq 	_BFMNoAdd
.019579	20 4d 8c	jsr $018c4d			jsr 	AddInteger32
.01957c					_BFMNoAdd:
.01957c	16 86		asl $86,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.01957e	36 87		rol $87,x			rol 	XS2_Mantissa+1,x
.019580	36 88		rol $88,x			rol 	XS2_Mantissa+2,x
.019582	36 89		rol $89,x			rol 	XS2_Mantissa+3,x
.019584	56 8f		lsr $8f,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.019586	76 8e		ror $8e,x			ror 	XS3_Mantissa+2,x
.019588	76 8d		ror $8d,x			ror 	XS3_Mantissa+1,x
.01958a	76 8c		ror $8c,x			ror 	XS3_Mantissa,x
.01958c	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.01958e	15 8d		ora $8d,x			ora 	XS3_Mantissa+1,x
.019590	15 8e		ora $8e,x			ora 	XS3_Mantissa+2,x
.019592	15 8f		ora $8f,x			ora 	XS3_Mantissa+3,x
.019594	d0 dd		bne $019573			bne 	_BFMMultiply
.019596	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.019597					DivInteger32:
.019597	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; check for /0
.019599	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.01959b	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.01959d	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.01959f	d0 14		bne $0195b5			bne 	_BFDOkay
.0195a1	20 2f 84	jsr $01842f			jsr ERR_Handler
>0195a4	44 69 76 69 73 69 6f 6e			.text "Division by Zero",0
>0195ac	20 62 79 20 5a 65 72 6f 00
.0195b5					_BFDOkay:
.0195b5	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.0195b7	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.0195b9	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.0195bb	85 1c		sta $1c				sta 	zLTemp1+2
.0195bd	85 1d		sta $1d				sta 	zLTemp1+3
.0195bf	8d 98 03	sta $0398			sta 	SignCount 					; Count of signs.
.0195c2	20 19 96	jsr $019619			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.0195c5	da		phx				phx
.0195c6	e8		inx				inx
.0195c7	e8		inx				inx
.0195c8	e8		inx				inx
.0195c9	e8		inx				inx
.0195ca	e8		inx				inx
.0195cb	e8		inx				inx
.0195cc	20 19 96	jsr $019619			jsr 	CheckIntegerNegate
.0195cf	fa		plx				plx
.0195d0	5a		phy				phy 								; Y is the counter
.0195d1	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.0195d3					_BFDLoop:
.0195d3	16 80		asl $80,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.0195d5	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.0195d7	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.0195d9	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.0195db	26 1a		rol $1a				rol 	zLTemp1
.0195dd	26 1b		rol $1b				rol 	zLTemp1+1
.0195df	26 1c		rol $1c				rol 	zLTemp1+2
.0195e1	26 1d		rol $1d				rol 	zLTemp1+3
.0195e3	38		sec				sec
.0195e4	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.0195e6	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.0195e8	48		pha				pha
.0195e9	a5 1b		lda $1b				lda 	zLTemp1+1
.0195eb	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.0195ed	48		pha				pha
.0195ee	a5 1c		lda $1c				lda 	zLTemp1+2
.0195f0	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.0195f2	48		pha				pha
.0195f3	a5 1d		lda $1d				lda 	zLTemp1+3
.0195f5	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.0195f7	90 13		bcc $01960c			bcc 	_BFDNoAdd
.0195f9	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.0195fb	68		pla				pla
.0195fc	85 1c		sta $1c				sta 	zLTemp1+2
.0195fe	68		pla				pla
.0195ff	85 1b		sta $1b				sta 	zLTemp1+1
.019601	68		pla				pla
.019602	85 1a		sta $1a				sta 	zLTemp1+0
.019604	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.019606	09 01		ora #$01			ora 	#1
.019608	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01960a	80 03		bra $01960f			bra 	_BFDNext
.01960c					_BFDNoAdd:
.01960c	68		pla				pla 								; Throw away the intermediate calculations
.01960d	68		pla				pla
.01960e	68		pla				pla
.01960f					_BFDNext:
.01960f	88		dey				dey
.019610	d0 c1		bne $0195d3			bne 	_BFDLoop
.019612	7a		ply				ply 								; restore Y and exit
.019613	4e 98 03	lsr $0398			lsr 	SignCount 					; if sign count odd,
.019616	b0 06		bcs $01961e			bcs		IntegerNegateAlways 			; negate the result
.019618	60		rts				rts
.019619					CheckIntegerNegate:
.019619	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01961b	30 01		bmi $01961e			bmi 	IntegerNegateAlways
.01961d	60		rts				rts
.01961e					IntegerNegateAlways:
.01961e	ee 98 03	inc $0398			inc 	SignCount
.019621	38		sec				sec
.019622	a9 00		lda #$00			lda 	#0
.019624	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.019626	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019628	a9 00		lda #$00			lda 	#0
.01962a	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.01962c	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01962e	a9 00		lda #$00			lda 	#0
.019630	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.019632	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019634	a9 00		lda #$00			lda 	#0
.019636	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.019638	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01963a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.01963b					INTToString:
.01963b	48		pha				pha
.01963c	5a		phy				phy
.01963d	b5 83		lda $83,x			lda 		XS_Mantissa+3,x 		; check -ve
.01963f	10 08		bpl $019649			bpl 		_ITSNotMinus
.019641	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.019643	20 dd 96	jsr $0196dd			jsr 		ITSOutputCharacter
.019646	20 1e 96	jsr $01961e			jsr 		IntegerNegateAlways 	; negate the number.
.019649					_ITSNotMinus:
.019649	a9 00		lda #$00			lda 		#0
.01964b	8d 94 03	sta $0394			sta 		NumSuppress 			; clear the suppression flag.
.01964e	8a		txa				txa 								; use Y for the mantissa index.
.01964f	a8		tay				tay
.019650	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.019652					_ITSNextSubtractor:
.019652	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.019654	8d 95 03	sta $0395			sta 		NumConvCount
.019657					_ITSSubtract:
.019657	38		sec				sec
.019658	b9 80 00	lda $0080,y			lda 		XS_Mantissa,y 			; subtract number and push on stack
.01965b	ff b9 96 01	sbc $0196b9,x			sbc 		_ITSSubtractors+0,x
.01965f	48		pha				pha
.019660	b9 81 00	lda $0081,y			lda 		XS_Mantissa+1,y
.019663	ff ba 96 01	sbc $0196ba,x			sbc 		_ITSSubtractors+1,x
.019667	48		pha				pha
.019668	b9 82 00	lda $0082,y			lda 		XS_Mantissa+2,y
.01966b	ff bb 96 01	sbc $0196bb,x			sbc 		_ITSSubtractors+2,x
.01966f	48		pha				pha
.019670	b9 83 00	lda $0083,y			lda 		XS_Mantissa+3,y
.019673	ff bc 96 01	sbc $0196bc,x			sbc 		_ITSSubtractors+3,x
.019677	90 14		bcc $01968d			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.019679	99 83 00	sta $0083,y			sta 		XS_Mantissa+3,y 		; save subtract off stack
.01967c	68		pla				pla
.01967d	99 82 00	sta $0082,y			sta 		XS_Mantissa+2,y
.019680	68		pla				pla
.019681	99 81 00	sta $0081,y			sta 		XS_Mantissa+1,y
.019684	68		pla				pla
.019685	99 80 00	sta $0080,y			sta 		XS_Mantissa+0,y
.019688	ee 95 03	inc $0395			inc 		NumConvCount 			; bump count.
.01968b	80 ca		bra $019657			bra 		_ITSSubtract 			; go round again.
.01968d					_ITSCantSubtract:
.01968d	68		pla				pla 								; throw away interim answers
.01968e	68		pla				pla
.01968f	68		pla				pla
.019690	ad 95 03	lda $0395			lda 		NumConvCount 			; if not zero then no suppression check
.019693	c9 30		cmp #$30			cmp 		#"0"
.019695	d0 05		bne $01969c			bne 		_ITSOutputDigit
.019697	ad 94 03	lda $0394			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.01969a	10 09		bpl $0196a5			bpl	 		_ITSGoNextSubtractor
.01969c					_ITSOutputDigit:
.01969c	ce 94 03	dec $0394			dec 		NumSuppress 			; suppression check will be non-zero.
.01969f	ad 95 03	lda $0395			lda 		NumConvCount 			; count of subtractions
.0196a2	20 dd 96	jsr $0196dd			jsr 		ITSOutputCharacter 		; output it.
.0196a5					_ITSGoNextSubtractor:
.0196a5	e8		inx				inx 								; next dword
.0196a6	e8		inx				inx
.0196a7	e8		inx				inx
.0196a8	e8		inx				inx
.0196a9	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.0196ab	d0 a5		bne $019652			bne 		_ITSNextSubtractor 		; do all the subtractors.
.0196ad	98		tya				tya 								; X is back as the mantissa index
.0196ae	aa		tax				tax
.0196af	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.0196b1	09 30		ora #$30			ora 		#"0"
.0196b3	20 dd 96	jsr $0196dd			jsr 		ITSOutputCharacter
.0196b6	7a		ply				ply 								; and exit
.0196b7	68		pla				pla
.0196b8	60		rts				rts
.0196b9					_ITSSubtractors:
>0196b9	00 ca 9a 3b					.dword 		1000000000
>0196bd	00 e1 f5 05					.dword 		100000000
>0196c1	80 96 98 00					.dword 		10000000
>0196c5	40 42 0f 00					.dword 		1000000
>0196c9	a0 86 01 00					.dword 		100000
>0196cd	10 27 00 00					.dword 		10000
>0196d1	e8 03 00 00					.dword 		1000
>0196d5	64 00 00 00					.dword 		100
>0196d9	0a 00 00 00					.dword 		10
.0196dd					_ITSSubtractorsEnd:
.0196dd					ITSOutputCharacter:
.0196dd	48		pha				pha
.0196de	da		phx				phx
.0196df	ae 0e 03	ldx $030e			ldx 	NumBufX 					; save digit
.0196e2	9d 0f 03	sta $030f,x			sta 	Num_Buffer,x
.0196e5	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.0196e7	9d 10 03	sta $0310,x			sta 	Num_Buffer+1,x
.0196ea	ee 0e 03	inc $030e			inc 	NumBufX						; bump pointer.
.0196ed	fa		plx				plx
.0196ee	68		pla				pla
.0196ef	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.0196f0					IntFromString:
.0196f0	a0 00		ldy #$00			ldy 	#0
.0196f2	8c 96 03	sty $0396			sty 	ExpTemp 					; this is the converted digit count.
.0196f5					IntFromStringY:
.0196f5	48		pha				pha
.0196f6	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.0196f8	95 80		sta $80,x			sta 	XS_Mantissa,x
.0196fa	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0196fc	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0196fe	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019700	a9 01		lda #$01			lda 	#1
.019702	95 85		sta $85,x			sta 	XS_Type,x
.019704					_IFSLoop:
.019704	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.019706	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.019708	90 4e		bcc $019758			bcc 	_IFSExit
.01970a	c9 3a		cmp #$3a			cmp 	#"9"+1
.01970c	b0 4a		bcs $019758			bcs 	_IFSExit
.01970e	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.019710	c9 0c		cmp #$0c			cmp 	#12
.019712	b0 4e		bcs $019762			bcs 	_IFSOverflow
.019714	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.019716	48		pha				pha
.019717	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019719	48		pha				pha
.01971a	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01971c	48		pha				pha
.01971d	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01971f	48		pha				pha
.019720	20 77 97	jsr $019777			jsr 	IFSX1ShiftLeft 				; double
.019723	20 77 97	jsr $019777			jsr 	IFSX1ShiftLeft 				; x 4
.019726	18		clc				clc 								; add saved value x 5
.019727	68		pla				pla
.019728	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.01972a	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01972c	68		pla				pla
.01972d	75 81		adc $81,x			adc 	XS_Mantissa+1,x
.01972f	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019731	68		pla				pla
.019732	75 82		adc $82,x			adc 	XS_Mantissa+2,x
.019734	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019736	68		pla				pla
.019737	75 83		adc $83,x			adc 	XS_Mantissa+3,x
.019739	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01973b	20 77 97	jsr $019777			jsr 	IFSX1ShiftLeft 				; x 10
.01973e	ee 96 03	inc $0396			inc 	ExpTemp 					; bump count of digits processed.
.019741	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.019743	29 0f		and #$0f			and 	#15
.019745	c8		iny				iny
.019746	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.019748	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01974a	90 b8		bcc $019704			bcc 	_IFSLoop
.01974c	f6 81		inc $81,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.01974e	d0 b4		bne $019704			bne 	_IFSLoop
.019750	f6 82		inc $82,x			inc 	XS_Mantissa+2,x
.019752	d0 b0		bne $019704			bne 	_IFSLoop
.019754	f6 83		inc $83,x			inc 	XS_Mantissa+3,x
.019756	80 ac		bra $019704			bra 	_IFSLoop
.019758					_IFSExit:
.019758	98		tya				tya 								; get offset
.019759					_IFSOkay:
.019759	38		sec				sec
.01975a	ad 96 03	lda $0396			lda 	ExpTemp
.01975d	f0 01		beq $019760			beq 	_IFSSkipFail
.01975f	18		clc				clc
.019760					_IFSSkipFail:
.019760	68		pla				pla 								; and exit.
.019761	60		rts				rts
.019762					_IFSOverflow:
.019762	20 2f 84	jsr $01842f			jsr 	ERR_Handler
>019765	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>01976d	20 6f 76 65 72 66 6c 6f 77 00
.019777					IFSX1ShiftLeft:
.019777	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.019779	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.01977b	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.01977d	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.01977f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.019780					FPSubtract:
.019780	48		pha				pha
.019781	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.019783	49 80		eor #$80			eor 	#$80
.019785	95 8b		sta $8b,x			sta 	XS2_Type,x
.019787	68		pla				pla 								; --- and fall through ---
.019788					FPAdd:
.019788	48		pha				pha
.019789	b5 85		lda $85,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.01978b	d0 05		bne $019792			bne 	_FPA_NegativeLHS
.01978d	20 a9 97	jsr $0197a9			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.019790	68		pla				pla
.019791	60		rts				rts
.019792					_FPA_NegativeLHS:
.019792	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.019794	49 80		eor #$80			eor 	#$80
.019796	95 85		sta $85,x			sta 	XS_Type,x
.019798	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of B and add
.01979a	49 80		eor #$80			eor 	#$80
.01979c	95 8b		sta $8b,x			sta 	XS2_Type,x
.01979e	20 a9 97	jsr $0197a9			jsr 	FPAdd_Worker 				; do the add calculation.
.0197a1	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 back
.0197a3	49 80		eor #$80			eor 	#$80
.0197a5	95 85		sta $85,x			sta 	XS_Type,x
.0197a7	68		pla				pla
.0197a8	60		rts				rts
.0197a9					FPAdd_Worker:
.0197a9	34 8b		bit $8b,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.0197ab	70 07		bvs $0197b4			bvs 	_FPAWExit 					; no change.
.0197ad	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.0197af	50 07		bvc $0197b8			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.0197b1	20 e9 99	jsr $0199e9			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.0197b4					_FPAWExit:
.0197b4	20 58 9a	jsr $019a58			jsr 	FPUNormalise 				; normalise the result.
.0197b7	60		rts				rts
.0197b8					_FPAWMakeSame:
.0197b8	b5 84		lda $84,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.0197ba	38		sec				sec
.0197bb	f5 8a		sbc $8a,x			sbc	 	XS2_Exponent,x 				; using subtraction
.0197bd	f0 16		beq $0197d5			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.0197bf	da		phx				phx 								; save X
.0197c0	90 06		bcc $0197c8			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.0197c2	e8		inx				inx
.0197c3	e8		inx				inx
.0197c4	e8		inx				inx
.0197c5	e8		inx				inx
.0197c6	e8		inx				inx
.0197c7	e8		inx				inx
.0197c8					_FPAWShiftA:
.0197c8	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.0197ca	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.0197cc	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.0197ce	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.0197d0	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.0197d2	fa		plx				plx 								; restore original X
.0197d3	80 e3		bra $0197b8			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.0197d5					_FPAW_DoArithmetic:
.0197d5	34 8b		bit $8b,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.0197d7	30 28		bmi $019801			bmi 	_FPAW_BNegative
.0197d9	18		clc				clc
.0197da	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0197dc	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.0197de	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0197e0	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0197e2	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.0197e4	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0197e6	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0197e8	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.0197ea	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0197ec	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.0197ee	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.0197f0	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0197f2	90 c0		bcc $0197b4			bcc 	_FPAWExit 					; no carry.
.0197f4	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.0197f6	38		sec				sec
.0197f7	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.0197f9	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.0197fb	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.0197fd	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.0197ff	80 b3		bra $0197b4			bra 	_FPAWExit
.019801					_FPAW_BNegative:
.019801	38		sec				sec
.019802	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019804	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.019806	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019808	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01980a	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.01980c	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01980e	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019810	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.019812	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019814	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019816	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.019818	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01981a	b0 09		bcs $019825			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.01981c	20 0f 9a	jsr $019a0f			jsr 	FPUNegateInteger			; negate the mantissa
.01981f	b5 85		lda $85,x			lda 	XS_Type,x 					; flip result sign
.019821	49 80		eor #$80			eor 	#$80
.019823	95 85		sta $85,x			sta 	XS_Type,x
.019825					_FPAWGoExit:
.019825	4c b4 97	jmp $0197b4			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.019828					FPD_IsDivZero:
.019828	20 2f 84	jsr $01842f			jsr ERR_Handler
>01982b	44 69 76 69 73 69 6f 6e			.text "Division by zero",0
>019833	20 62 79 20 7a 65 72 6f 00
.01983c					FPDivide:
.01983c	48		pha				pha
.01983d	5a		phy				phy
.01983e	34 8b		bit $8b,x			bit 	XS2_Type,x 					; check if division by zero
.019840	70 e6		bvs $019828			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.019842	34 85		bit $85,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.019844	f0 03		beq $019849			beq 	_FPDCalculateExp
.019846					_FPD_Exit:
.019846	7a		ply				ply
.019847	68		pla				pla
.019848	60		rts				rts
.019849					_FPDCalculateExp:
.019849	b5 8a		lda $8a,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.01984b	49 ff		eor #$ff			eor 	#$FF
.01984d	1a		inc a				inc 	a
.01984e	95 8a		sta $8a,x			sta 	XS2_Exponent,x
.019850	20 20 99	jsr $019920			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.019853	18		clc				clc 	 							; add 1 to the resulting exponent
.019854	69 01		adc #$01			adc 	#1
.019856	b0 54		bcs $0198ac			bcs 	_FPD_Overflow 				; which can overflow.
.019858	95 84		sta $84,x			sta 	XS_Exponent,x
.01985a	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.01985c	85 1a		sta $1a				sta 	zLTemp1+0
.01985e	85 1b		sta $1b				sta 	zLTemp1+1
.019860	85 1c		sta $1c				sta 	zLTemp1+2
.019862	85 1d		sta $1d				sta 	zLTemp1+3
.019864	a0 20		ldy #$20			ldy 	#32 						; times round.
.019866					_FPD_Loop:
.019866	38		sec				sec 								; calculate X1-X2 stacking result because we might
.019867	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; not save it.
.019869	f5 86		sbc $86,x			sbc 	XS2_Mantissa,x
.01986b	48		pha				pha
.01986c	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01986e	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.019870	48		pha				pha
.019871	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019873	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.019875	48		pha				pha
.019876	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019878	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.01987a	90 13		bcc $01988f			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.01987c	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; save results out to A
.01987e	68		pla				pla
.01987f	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019881	68		pla				pla
.019882	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019884	68		pla				pla
.019885	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019887	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.019889	09 80		ora #$80			ora 	#$80
.01988b	85 1d		sta $1d				sta 	zLTemp1+3
.01988d	80 03		bra $019892			bra 	_FPD_Rotates
.01988f					_FPD_NoSubtract:
.01988f	68		pla				pla 								; throw away unwanted results
.019890	68		pla				pla
.019891	68		pla				pla
.019892					_FPD_Rotates:
.019892	56 89		lsr $89,x			lsr 	3+XS2_Mantissa,x
.019894	76 88		ror $88,x			ror 	2+XS2_Mantissa,x
.019896	76 87		ror $87,x			ror 	1+XS2_Mantissa,x
.019898	76 86		ror $86,x			ror 	0+XS2_Mantissa,x
.01989a	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.01989c	26 1b		rol $1b				rol 	zLTemp1+1
.01989e	26 1c		rol $1c				rol 	zLTemp1+2
.0198a0	26 1d		rol $1d				rol 	zLTemp1+3
.0198a2	90 02		bcc $0198a6			bcc 	_FPD_NoCarry
.0198a4	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.0198a6					_FPD_NoCarry:
.0198a6	88		dey				dey 								; do 32 times
.0198a7	d0 bd		bne $019866			bne 	_FPD_Loop
.0198a9	4c 04 99	jmp $019904			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.0198ac					_FPD_Overflow:
.0198ac	4c b5 9a	jmp $019ab5			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.0198af					FPMultiply:
.0198af	48		pha				pha
.0198b0	5a		phy				phy
.0198b1	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.0198b3	70 07		bvs $0198bc			bvs 	_FPM_Exit
.0198b5	34 8b		bit $8b,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.0198b7	50 06		bvc $0198bf			bvc 	_FPM_CalcExponent
.0198b9	20 e9 99	jsr $0199e9			jsr 	FPUCopyX2ToX1
.0198bc					_FPM_Exit:
.0198bc	7a		ply				ply
.0198bd	68		pla				pla
.0198be	60		rts				rts
.0198bf					_FPM_CalcExponent:
.0198bf	18		clc				clc
.0198c0	20 20 99	jsr $019920			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.0198c3	95 84		sta $84,x			sta 	XS_Exponent,x 				; save the result.
.0198c5	a9 00		lda #$00			lda 	#0
.0198c7	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.0198c9	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.0198cb	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.0198cd	85 1d		sta $1d				sta 	zLTemp1+3
.0198cf	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.0198d1					_FPM_Loop:
.0198d1	b5 80		lda $80,x			lda 	XS_Mantissa,x				; check LSB of long product
.0198d3	29 01		and #$01			and 	#1
.0198d5	18		clc				clc 								; clear carry for the long rotate.
.0198d6	f0 19		beq $0198f1			beq 	_FPM_NoAddition
.0198d8	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.0198d9	a5 1a		lda $1a				lda 	zLTemp1+0
.0198db	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.0198dd	85 1a		sta $1a				sta 	zLTemp1+0
.0198df	a5 1b		lda $1b				lda 	zLTemp1+1
.0198e1	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.0198e3	85 1b		sta $1b				sta 	zLTemp1+1
.0198e5	a5 1c		lda $1c				lda 	zLTemp1+2
.0198e7	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.0198e9	85 1c		sta $1c				sta 	zLTemp1+2
.0198eb	a5 1d		lda $1d				lda 	zLTemp1+3
.0198ed	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.0198ef	85 1d		sta $1d				sta 	zLTemp1+3
.0198f1					_FPM_NoAddition:
.0198f1	66 1d		ror $1d				ror 	3+zLTemp1
.0198f3	66 1c		ror $1c				ror 	2+zLTemp1
.0198f5	66 1b		ror $1b				ror 	1+zLTemp1
.0198f7	66 1a		ror $1a				ror 	0+zLTemp1
.0198f9	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.0198fb	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.0198fd	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.0198ff	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.019901	88		dey				dey
.019902	d0 cd		bne $0198d1			bne 	_FPM_Loop 					; do this 32 times.
.019904					FPM_CopySignNormalize:
.019904	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.019906	95 80		sta $80,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.019908	a5 1b		lda $1b				lda 	zLTemp1+1
.01990a	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01990c	a5 1c		lda $1c				lda 	zLTemp1+2
.01990e	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019910	a5 1d		lda $1d				lda 	zLTemp1+3
.019912	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019914	b5 85		lda $85,x			lda 	XS_Type,x 					; sign is xor of signs
.019916	55 8b		eor $8b,x			eor 	XS2_Type,x
.019918	95 85		sta $85,x			sta 	XS_Type,x
.01991a	20 58 9a	jsr $019a58			jsr 	FPUNormalise 				; normalise and exit.
.01991d	7a		ply				ply
.01991e	68		pla				pla
.01991f	60		rts				rts
.019920					FPCalculateExponent:
.019920	18		clc				clc
.019921	b5 84		lda $84,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.019923	75 8a		adc $8a,x			adc 	XS2_Exponent,x
.019925	b0 08		bcs $01992f			bcs 	_FPCECarry 					; carry out ?
.019927	10 03		bpl $01992c			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.019929	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.01992b	60		rts				rts
.01992c					_FPCEExpZero:
.01992c	a9 00		lda #$00			lda 	#0
.01992e	60		rts				rts
.01992f					_FPCECarry:
.01992f	30 03		bmi $019934			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.019931	09 80		ora #$80			ora 	#$80 						; put in right range
.019933	60		rts				rts
.019934					_FPCEOverflow:
.019934	4c b5 9a	jmp $019ab5			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.019937					FPFractionalPart:
.019937	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.019939	38		sec				sec 								; this flag tells us to keep the fractional part
.01993a	30 0d		bmi $019949			bmi 	FPGetPart
.01993c	60		rts				rts
.01993d					FPIntegerPart:
.01993d	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.01993f	18		clc				clc 								; this flag says keep the integer part.
.019940	30 07		bmi $019949			bmi 	FPGetPart 					; -ve exponents are 0..127
.019942	48		pha				pha
.019943	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.019945	95 85		sta $85,x			sta 	XS_Type,x
.019947	68		pla				pla
.019948	60		rts				rts
.019949					FPGetPart:
.019949	48		pha				pha
.01994a	5a		phy				phy 								; save Y
.01994b	08		php				php 								; save action
.01994c	34 85		bit $85,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.01994e	70 59		bvs $0199a9			bvs 	_FPGP_Exit 					; then do nothing.
.019950	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.019952	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.019954	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.019956	85 1c		sta $1c				sta 	zLTemp1+2
.019958	85 1d		sta $1d				sta 	zLTemp1+3
.01995a	b5 84		lda $84,x			lda 	XS_Exponent,x				; the number of shifts.
.01995c	38		sec				sec
.01995d	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.01995f	f0 12		beq $019973			beq 	_FPGP_NoShift 				; ... if any
.019961	c9 20		cmp #$20			cmp 	#32
.019963	90 02		bcc $019967			bcc 	_FPGP_NotMax
.019965	a9 20		lda #$20			lda 	#32 						; max of 32.
.019967					_FPGP_NotMax:
.019967	a8		tay				tay 								; Y is the mask shift count.
.019968					_FPGP_ShiftMask:
.019968	46 1d		lsr $1d				lsr 	3+zLTemp1
.01996a	66 1c		ror $1c				ror 	2+zLTemp1
.01996c	66 1b		ror $1b				ror 	1+zLTemp1
.01996e	66 1a		ror $1a				ror 	0+zLTemp1
.019970	88		dey				dey
.019971	d0 f5		bne $019968			bne 	_FPGP_ShiftMask
.019973					_FPGP_NoShift:
.019973	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.019975	8e 96 03	stx $0396			stx 	ExpTemp						; save X
.019978					_FPGP_MaskLoop:
.019978	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.01997b	28		plp				plp 								; if CC we keep the top part, so we
.01997c	08		php				php		 							; flip the mask.
.01997d	b0 02		bcs $019981			bcs		_FPGP_NoFlip
.01997f	49 ff		eor #$ff			eor 	#$FF
.019981					_FPGP_NoFlip:
.019981	35 80		and $80,x			and 	XS_Mantissa,x 				; and into the mantissa.
.019983	95 80		sta $80,x			sta 	XS_Mantissa,x
.019985	e8		inx				inx
.019986	c8		iny				iny
.019987	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.019989	d0 ed		bne $019978			bne 	_FPGP_MaskLoop
.01998b	ae 96 03	ldx $0396			ldx 	ExpTemp						; restore X
.01998e	28		plp				plp
.01998f	08		php				php 								; get action flag on the stack
.019990	90 04		bcc $019996			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.019992	a9 00		lda #$00			lda 	#0
.019994	95 85		sta $85,x			sta 	XS_Type,x
.019996					_FPGP_NotFractional:
.019996	b5 80		lda $80,x			lda 	XS_Mantissa,x 						; check if \1 zero
.019998	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.01999a	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01999c	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01999e	f0 05		beq $0199a5			beq 	_FPGP_Zero 					; if zero, return zero
.0199a0	20 58 9a	jsr $019a58			jsr 	FPUNormalise
.0199a3	80 04		bra $0199a9			bra 	_FPGP_Exit 					; and exit
.0199a5					_FPGP_Zero:
.0199a5	a9 40		lda #$40			lda 	#$40 						; set zero flag
.0199a7	95 85		sta $85,x			sta 	XS_Type,x
.0199a9					_FPGP_Exit:
.0199a9	68		pla				pla 								; throw saved action flag.
.0199aa	7a		ply				ply
.0199ab	68		pla				pla
.0199ac	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.0199ad					FPCompare:
.0199ad	b5 84		lda $84,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.0199af	48		pha				pha
.0199b0	b5 8a		lda $8a,x			lda 	XS2_Exponent,x
.0199b2	48		pha				pha
.0199b3	20 80 97	jsr $019780			jsr 	FPSubtract 					; calculate X1-X2
.0199b6	34 85		bit $85,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.0199b8	70 2a		bvs $0199e4			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.0199ba	68		pla				pla
.0199bb	8d 96 03	sta $0396			sta 	ExpTemp						; save first exponent in temporary reg.
.0199be	68		pla				pla
.0199bf	38		sec				sec
.0199c0	ed 96 03	sbc $0396			sbc 	ExpTemp 					; calculate AX-BX
.0199c3	70 14		bvs $0199d9			bvs 	_FPCNotEqual				; overflow, can't be equal.
.0199c5	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.0199c6	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.0199c8	b0 0f		bcs $0199d9			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.0199ca	38		sec				sec
.0199cb	ad 96 03	lda $0396			lda 	ExpTemp 					; get one of the exponents back.
.0199ce	e9 12		sbc #$12			sbc 	#18 						; allow for 2^18 error, relatively.
.0199d0	b0 02		bcs $0199d4			bcs 	_FPCNotRange 				; keep in range.
.0199d2	a9 01		lda #$01			lda 	#1
.0199d4					_FPCNotRange:
.0199d4	38		sec				sec
.0199d5	f5 84		sbc $84,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.0199d7	b0 0d		bcs $0199e6			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.0199d9					_FPCNotEqual:
.0199d9	b5 85		lda $85,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.0199db	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.0199dd	f0 02		beq $0199e1			beq 	_FPCNE2
.0199df	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.0199e1	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.0199e2	80 04		bra $0199e8			bra 	_FPCExit
.0199e4					_FPCPullZero:
.0199e4	68		pla				pla 								; throw saved exponents
.0199e5	68		pla				pla
.0199e6					_FPCZero:
.0199e6	a9 00		lda #$00			lda 	#0 							; and return zero
.0199e8					_FPCExit:
.0199e8	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.0199e9					FPUCopyX2ToX1:
.0199e9	48		pha				pha
.0199ea	da		phx				phx
.0199eb	5a		phy				phy
.0199ec	a0 08		ldy #$08			ldy 	#8
.0199ee	b5 86		lda $86,x	_FPUC21:lda 	XS2_Mantissa,x
.0199f0	95 80		sta $80,x			sta 	XS_Mantissa,x
.0199f2	e8		inx				inx
.0199f3	88		dey				dey
.0199f4	10 f8		bpl $0199ee			bpl 	_FPUC21
.0199f6	7a		ply				ply
.0199f7	fa		plx				plx
.0199f8	68		pla				pla
.0199f9	60		rts				rts
.0199fa					FPUSetInteger:
.0199fa	48		pha				pha
.0199fb	95 80		sta $80,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.0199fd	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.0199ff	10 02		bpl $019a03			bpl 	_FPUSIExtend
.019a01	a9 ff		lda #$ff			lda 	#$FF
.019a03					_FPUSIExtend:
.019a03	95 81		sta $81,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.019a05	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019a07	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019a09	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.019a0b	95 85		sta $85,x			sta 	XS_Type,x
.019a0d	68		pla				pla
.019a0e	60		rts				rts
.019a0f					FPUNegateInteger:
.019a0f	48		pha				pha
.019a10	38		sec				sec
.019a11	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.019a13	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.019a15	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019a17	a9 00		lda #$00			lda 	#0
.019a19	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.019a1b	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019a1d	a9 00		lda #$00			lda 	#0
.019a1f	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.019a21	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019a23	a9 00		lda #$00			lda 	#0
.019a25	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.019a27	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019a29	68		pla				pla
.019a2a	60		rts				rts
.019a2b					FPUToFloat:
.019a2b	48		pha				pha
.019a2c	b5 85		lda $85,x			lda 	XS_Type,x					; exit if already float.
.019a2e	29 0f		and #$0f			and 	#$0F
.019a30	f0 24		beq $019a56			beq 	_FPUFExit
.019a32	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.019a34	95 85		sta $85,x			sta 	XS_Type,x
.019a36	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.019a38	95 84		sta $84,x			sta 	XS_Exponent,x 				; x mantissa.
.019a3a	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.019a3c	10 07		bpl $019a45			bpl		_FPUFPositive
.019a3e	20 0f 9a	jsr $019a0f			jsr 	FPUNegateInteger 			; negate the mantissa
.019a41	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.019a43	95 85		sta $85,x			sta 	XS_Type,x
.019a45					_FPUFPositive:
.019a45	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.019a47	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019a49	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019a4b	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019a4d	d0 04		bne $019a53			bne 	_FPUFNonZero
.019a4f	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.019a51	95 85		sta $85,x			sta 	XS_Type,x
.019a53					_FPUFNonZero:
.019a53	20 58 9a	jsr $019a58			jsr 	FPUNormalise 				; normalise the floating point.
.019a56					_FPUFExit:
.019a56	68		pla				pla
.019a57	60		rts				rts
.019a58					FPUNormalise:
.019a58	48		pha				pha
.019a59	34 85		bit $85,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.019a5b	70 18		bvs $019a75			bvs 	_FPUNExit
.019a5d	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.019a5f	f0 10		beq $019a71			beq 	_FPUNSetZero
.019a61					_FPUNLoop:
.019a61	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.019a63	30 10		bmi $019a75			bmi 	_FPUNExit 					; if so, we are normalised.
.019a65	16 80		asl $80,x			asl 	0+XS_Mantissa+0,x
.019a67	36 81		rol $81,x			rol 	1+XS_Mantissa+0,x
.019a69	36 82		rol $82,x			rol 	2+XS_Mantissa+0,x
.019a6b	36 83		rol $83,x			rol 	3+XS_Mantissa+0,x
.019a6d	d6 84		dec $84,x			dec 	XS_Exponent,x 				; decrement exponent
.019a6f	d0 f0		bne $019a61			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.019a71					_FPUNSetZero:
.019a71	a9 40		lda #$40			lda 	#$40
.019a73	95 85		sta $85,x			sta 	XS_Type,x 					; the result is now zero.
.019a75					_FPUNExit:
.019a75	68		pla				pla
.019a76	60		rts				rts
.019a77					FPUToInteger:
.019a77	48		pha				pha
.019a78	b5 85		lda $85,x			lda 	XS_Type,x 					; if already integer, exit
.019a7a	29 01		and #$01			and 	#1
.019a7c	d0 31		bne $019aaf			bne 	_FPUTOI_Exit
.019a7e	34 85		bit $85,x			bit 	XS_Type,x					; if zero, return zero.
.019a80	70 23		bvs $019aa5			bvs 	_FPUTOI_Zero
.019a82	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.019a84	10 1f		bpl $019aa5			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.019a86	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.019a88	b0 2b		bcs $019ab5			bcs 	FP_Overflow
.019a8a					_FPUToIToInteger:
.019a8a	b5 84		lda $84,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.019a8c	c9 a0		cmp #$a0			cmp 	#128+32
.019a8e	f0 0c		beq $019a9c			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.019a90	f6 84		inc $84,x			inc 	XS_Exponent,X 				; increment Exponent
.019a92	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.019a94	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.019a96	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.019a98	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.019a9a	80 ee		bra $019a8a			bra 	_FPUToIToInteger 			; keep going.
.019a9c					_FPUToICheckSign:
.019a9c	b5 85		lda $85,x			lda 	XS_Type,x 					; check sign
.019a9e	10 0f		bpl $019aaf			bpl 	_FPUToI_Exit 				; exit if unsigned.
.019aa0	20 0f 9a	jsr $019a0f			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.019aa3	80 0a		bra $019aaf			bra 	_FPUTOI_Exit
.019aa5					_FPUTOI_Zero:
.019aa5	a9 00		lda #$00			lda 	#0 							; return zero integer.
.019aa7	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019aa9	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019aab	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019aad	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019aaf					_FPUToI_Exit:
.019aaf	a9 01		lda #$01			lda 	#1 							; set type to integer
.019ab1	95 85		sta $85,x			sta 	XS_Type,x
.019ab3	68		pla				pla
.019ab4	60		rts				rts
.019ab5					FP_Overflow:
.019ab5	20 2f 84	jsr $01842f			jsr ERR_Handler
>019ab8	46 6c 6f 61 74 69 6e 67			.text "Floating Point overflow",0
>019ac0	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.019ad0					FPUTimes10:
.019ad0	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.019ad2	85 1a		sta $1a				sta 	ZLTemp1+0
.019ad4	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019ad6	85 1b		sta $1b				sta 	ZLTemp1+1
.019ad8	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019ada	85 1c		sta $1c				sta 	ZLTemp1+2
.019adc	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019ade	85 1d		sta $1d				sta 	ZLTemp1+3
.019ae0	20 15 9b	jsr $019b15			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.019ae3	20 15 9b	jsr $019b15			jsr 	_FPUT_LSR_ZLTemp1
.019ae6	18		clc				clc
.019ae7	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.019ae9	65 1a		adc $1a				adc 	ZLTemp1+0
.019aeb	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019aed	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019aef	65 1b		adc $1b				adc 	ZLTemp1+1
.019af1	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019af3	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019af5	65 1c		adc $1c				adc 	ZLTemp1+2
.019af7	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019af9	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019afb	65 1d		adc $1d				adc 	ZLTemp1+3
.019afd	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019aff	90 0a		bcc $019b0b			bcc 	_FPUTimes10
.019b01	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.019b03	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.019b05	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.019b07	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.019b09	f6 84		inc $84,x			inc 	XS_Exponent,x				; fix exponent
.019b0b					_FPUTimes10:
.019b0b	b5 84		lda $84,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.019b0d	18		clc				clc
.019b0e	69 03		adc #$03			adc 	#3
.019b10	95 84		sta $84,x			sta 	XS_Exponent,x
.019b12	b0 a1		bcs $019ab5			bcs 	FP_Overflow 				; error
.019b14	60		rts				rts
.019b15					_FPUT_LSR_ZLTemp1:
.019b15	46 1d		lsr $1d				lsr 	ZLTemp1+3
.019b17	66 1c		ror $1c				ror 	ZLTemp1+2
.019b19	66 1b		ror $1b				ror 	ZLTemp1+1
.019b1b	66 1a		ror $1a				ror 	ZLTemp1+0
.019b1d	60		rts				rts
.019b1e					FPUScale10A:
.019b1e	5a		phy				phy
.019b1f	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.019b21	f0 37		beq $019b5a			beq 	_FPUScaleExit
.019b23	da		phx				phx 								; save X
.019b24	e8		inx				inx
.019b25	e8		inx				inx
.019b26	e8		inx				inx
.019b27	e8		inx				inx
.019b28	e8		inx				inx
.019b29	e8		inx				inx
.019b2a	a8		tay				tay 								; save power scalar in Y.
.019b2b	a9 00		lda #$00			lda 	#0
.019b2d	95 80		sta $80,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.019b2f	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019b31	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019b33	95 85		sta $85,x			sta 	XS_Type,x
.019b35	a9 80		lda #$80			lda 	#$80
.019b37	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019b39	a9 81		lda #$81			lda 	#$81
.019b3b	95 84		sta $84,x			sta 	XS_Exponent,x
.019b3d	5a		phy				phy 								; save 10^n on stack.
.019b3e	c0 00		cpy #$00			cpy 	#0
.019b40	10 05		bpl $019b47			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.019b42	98		tya				tya
.019b43	49 ff		eor #$ff			eor 	#$FF
.019b45	1a		inc a				inc 	a
.019b46	a8		tay				tay
.019b47					_FPUSAbs:
.019b47	20 d0 9a	jsr $019ad0			jsr 	FPUTimes10
.019b4a	88		dey				dey
.019b4b	d0 fa		bne $019b47			bne 	_FPUSAbs 					; tos is now 10^|AC|
.019b4d	68		pla				pla 								; restore count in A
.019b4e	fa		plx				plx 								; restore X pointing to number to scale.
.019b4f	0a		asl a				asl 	a
.019b50	b0 05		bcs $019b57			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.019b52	20 af 98	jsr $0198af			jsr 	FPMultiply 					; if clear multiply.
.019b55	80 03		bra $019b5a			bra		_FPUScaleExit
.019b57					_FPUSDivide:
.019b57	20 3c 98	jsr $01983c			jsr 	FPDivide
.019b5a					_FPUScaleExit:
.019b5a	7a		ply				ply
.019b5b	60		rts				rts
.019b5c					FPUCopyToNext:
.019b5c	a0 06		ldy #$06			ldy 		#6
.019b5e	da		phx				phx
.019b5f					_FPUCopy1:
.019b5f	b5 80		lda $80,x			lda 	XS_Mantissa,x
.019b61	95 86		sta $86,x			sta 	XS2_Mantissa,x
.019b63	e8		inx				inx
.019b64	88		dey				dey
.019b65	d0 f8		bne $019b5f			bne 	_FPUCopy1
.019b67	fa		plx				plx
.019b68	60		rts				rts
.019b69					FPUCopyFromNext:
.019b69	a0 06		ldy #$06			ldy 		#6
.019b6b	da		phx				phx
.019b6c					_FPUCopy1:
.019b6c	b5 86		lda $86,x			lda 	XS2_Mantissa,x
.019b6e	95 80		sta $80,x			sta 	XS_Mantissa,x
.019b70	e8		inx				inx
.019b71	88		dey				dey
.019b72	d0 f8		bne $019b6c			bne 	_FPUCopy1
.019b74	fa		plx				plx
.019b75	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.019b76					FPToString:
.019b76	48		pha				pha
.019b77	5a		phy				phy
.019b78	34 85		bit $85,x			bit 		XS_Type,x 				; check zero flag
.019b7a	50 0a		bvc $019b86			bvc 		_FPTSIsFloat 			; if zero,
.019b7c					_FPTSZero:
.019b7c	a9 30		lda #$30			lda 		#"0"
.019b7e	20 dd 96	jsr $0196dd			jsr 		ITSOutputCharacter
.019b81					_FPTSExit:
.019b81	7a		ply				ply
.019b82	68		pla				pla
.019b83	60		rts				rts
.019b84	80 fb		bra $019b81			bra 		_FPTSExit
.019b86					_FPTSIsFloat:
.019b86	b5 85		lda $85,x			lda 		XS_Type,x 				; is it signed ?
.019b88	10 09		bpl $019b93			bpl 		_FPTSNotSigned
.019b8a	a9 00		lda #$00			lda 		#0 						; clear sign flag
.019b8c	95 85		sta $85,x			sta 		XS_Type,x
.019b8e	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.019b90	20 dd 96	jsr $0196dd			jsr 		ITSOutputCharacter
.019b93					_FPTSNotSigned:
.019b93	b5 84		lda $84,x			lda 		XS_Exponent,x
.019b95	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.019b97	b0 09		bcs $019ba2			bcs 		_FPTSExponent
.019b99	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.019b9b	90 05		bcc $019ba2			bcc 		_FPTSExponent 			;
.019b9d					_FPTSStandard:
.019b9d	20 e1 9b	jsr $019be1			jsr 		FPTOutputBody 			; output the body.
.019ba0	80 df		bra $019b81			bra 		_FPTSExit
.019ba2					_FPTSExponent:
.019ba2	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.019ba4	8d 97 03	sta $0397			sta 		ExpCount
.019ba7					_FPTSExponentLoop:
.019ba7	b5 84		lda $84,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.019ba9	10 0e		bpl $019bb9			bpl 		_FPTSTimes
.019bab	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.019bad	90 14		bcc $019bc3			bcc 		_FPTSScaledToExp
.019baf	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.019bb1	20 1e 9b	jsr $019b1e			jsr 		FPUScale10A
.019bb4	ee 97 03	inc $0397			inc 		ExpCount
.019bb7	80 ee		bra $019ba7			bra 		_FPTSExponentLoop
.019bb9					_FPTSTimes:
.019bb9	a9 01		lda #$01			lda 		#1
.019bbb	20 1e 9b	jsr $019b1e			jsr 		FPUScale10A
.019bbe	ce 97 03	dec $0397			dec 		ExpCount
.019bc1	80 e4		bra $019ba7			bra 		_FPTSExponentLoop
.019bc3					_FPTSScaledToExp:
.019bc3	20 e1 9b	jsr $019be1			jsr 		FPTOutputBody 			; output the body.
.019bc6	a9 65		lda #$65			lda 		#"e"					; output E
.019bc8	20 dd 96	jsr $0196dd			jsr 		ITSOutputCharacter
.019bcb	ad 97 03	lda $0397			lda 		ExpCount 				; get the exponent
.019bce	95 80		sta $80,x			sta 		XS_Mantissa,x
.019bd0	29 80		and #$80			and 		#$80 					; sign extend it
.019bd2	f0 02		beq $019bd6			beq 		_FPTSSExt
.019bd4	a9 ff		lda #$ff			lda 		#$FF
.019bd6					_FPTSSExt:
.019bd6	95 81		sta $81,x			sta 		XS_Mantissa+1,x
.019bd8	95 82		sta $82,x			sta 		XS_Mantissa+2,x
.019bda	95 83		sta $83,x			sta 		XS_Mantissa+3,x
.019bdc	20 3b 96	jsr $01963b			jsr 		INTToString 			; output the exponent.
.019bdf	80 a0		bra $019b81			bra			_FPTSExit 				; and exit.
.019be1					FPTOutputBody:
.019be1	20 5c 9b	jsr $019b5c			jsr 		FPUCopyToNext 			; copy to next slot.
.019be4	20 77 9a	jsr $019a77			jsr 		FPUToInteger 			; convert to an integer
.019be7	20 3b 96	jsr $01963b			jsr 		INTToString 			; output the main integer part.
.019bea	20 69 9b	jsr $019b69			jsr 		FPUCopyFromNext 		; get the fractional part back.
.019bed	20 37 99	jsr $019937			jsr 		FPFractionalPart 		; get the decimal part.
.019bf0	34 85		bit $85,x			bit 		XS_Type,x 				; any fractional part.
.019bf2	70 3c		bvs $019c30			bvs 		_FPTOExit 				; if not, exit now.
.019bf4	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.019bf6	20 dd 96	jsr $0196dd			jsr 		ITSOutputCharacter
.019bf9					_FPOutLoop:
.019bf9	34 85		bit $85,x			bit 		XS_Type,x 				; finally reached zero.
.019bfb	70 1d		bvs $019c1a			bvs 		_FPStripZeros 			; strip trailing zeros
.019bfd	20 d0 9a	jsr $019ad0			jsr 		FPUTimes10 				; multiply by 10
.019c00	20 5c 9b	jsr $019b5c			jsr 		FPUCopyToNext			; copy to next slot.
.019c03	20 77 9a	jsr $019a77			jsr 		FPUToInteger 			; convert to integer
.019c06	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; print digit.
.019c08	09 30		ora #$30			ora 		#"0"
.019c0a	20 dd 96	jsr $0196dd			jsr 		ITSOutputCharacter
.019c0d	20 69 9b	jsr $019b69			jsr 		FPUCopyFromNext 		; get it back
.019c10	20 37 99	jsr $019937			jsr 		FPFractionalPart 		; get fractional part
.019c13	ad 0e 03	lda $030e			lda 		NumBufX 				; done 11 characters yet ?
.019c16	c9 0b		cmp #$0b			cmp 	 	#11
.019c18	90 df		bcc $019bf9			bcc 		_FPOutLoop 				; if so, keep going till zero.
.019c1a					_FPStripZeros:
.019c1a	ac 0e 03	ldy $030e			ldy 		NumBufX 				; strip trailing zeros.
.019c1d					_FPStripLoop:
.019c1d	88		dey				dey 								; back one, if at start then no strip
.019c1e	f0 10		beq $019c30			beq 		_FPToExit
.019c20	b9 0f 03	lda $030f,y			lda 		Num_Buffer,y 			; keep going if "0"
.019c23	c9 30		cmp #$30			cmp 		#"0"
.019c25	f0 f6		beq $019c1d			beq 		_FPStripLoop
.019c27	c8		iny				iny
.019c28	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.019c2a	99 0f 03	sta $030f,y			sta 		Num_Buffer,y
.019c2d	8c 0e 03	sty $030e			sty 		NumBufX 				; update position.
.019c30					_FPTOExit:
.019c30	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.019c31					FPFromString:
.019c31	48		pha				pha 								; push A
.019c32	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.019c34	c9 2e		cmp #$2e			cmp 	#"."
.019c36	f0 03		beq $019c3b			beq	 	_FPFIsDecimal
.019c38	4c 97 9c	jmp $019c97			jmp 	_FPFNotDecimal
.019c3b					_FPFIsDecimal:
.019c3b	c8		iny				iny 								; consume the decimal.
.019c3c	20 2b 9a	jsr $019a2b			jsr 	FPUToFloat 					; convert the integer to float.
.019c3f	da		phx				phx 								; save X.
.019c40	5a		phy				phy 								; save decimal start position
.019c41	e8		inx				inx
.019c42	e8		inx				inx
.019c43	e8		inx				inx
.019c44	e8		inx				inx
.019c45	e8		inx				inx
.019c46	e8		inx				inx
.019c47	20 f5 96	jsr $0196f5			jsr 	INTFromStringY 				; get the part after the DP.
.019c4a	20 2b 9a	jsr $019a2b			jsr 	FPUToFloat 					; convert that to a float.
.019c4d	68		pla				pla 								; calculate - chars consumed.
.019c4e	8c 96 03	sty $0396			sty 	ExpTemp
.019c51	38		sec				sec
.019c52	ed 96 03	sbc $0396			sbc 	ExpTemp 					; this is the shift amount
.019c55	20 1e 9b	jsr $019b1e			jsr 	FPUScale10A 				; scale it by 10^AC
.019c58	fa		plx				plx 								; restore original X
.019c59	20 88 97	jsr $019788			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.019c5c	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.019c5e	c9 45		cmp #$45			cmp 	#"E"
.019c60	f0 04		beq $019c66			beq 	_FPFExponent
.019c62	c9 65		cmp #$65			cmp 	#"e"
.019c64	d0 31		bne $019c97			bne 	_FPFNotDecimal 				; no, then exit normally.
.019c66					_FPFExponent:
.019c66	c8		iny				iny 								; skip over E symbol.
.019c67	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.019c69	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.019c6b	d0 01		bne $019c6e			bne 	_FPFGotSign
.019c6d	c8		iny				iny 								; if it was - skip over it.
.019c6e					_FPFGotSign:
.019c6e	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.019c6f	da		phx				phx
.019c70	e8		inx				inx
.019c71	e8		inx				inx
.019c72	e8		inx				inx
.019c73	e8		inx				inx
.019c74	e8		inx				inx
.019c75	e8		inx				inx
.019c76	20 f5 96	jsr $0196f5			jsr 	INTFromStringY 				; get the exponent
.019c79	fa		plx				plx 								; restore X.
.019c7a	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.019c7c	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.019c7e	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.019c80	d0 17		bne $019c99			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.019c82	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.019c84	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.019c86	b0 11		bcs $019c99			bcs 	_FPFXOverflow
.019c88	68		pla				pla 								; get direction
.019c89	d0 07		bne $019c92			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.019c8b	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.019c8d	49 ff		eor #$ff			eor 	#$FF
.019c8f	1a		inc a				inc 	a
.019c90	95 86		sta $86,x			sta 	XS2_Mantissa+0,x
.019c92					_FPFXScale:
.019c92	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.019c94	20 1e 9b	jsr $019b1e			jsr 	FPUScale10A 				; scale by the exponent.
.019c97					_FPFNotDecimal:
.019c97	68		pla				pla
.019c98	60		rts				rts
.019c99					_FPFXOverflow:
.019c99	20 2f 84	jsr $01842f			jsr 	ERR_Handler
>019c9c	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>019ca4	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.019cab					Unary_Rnd:
.019cab	20 a1 8a	jsr $018aa1			jsr 	EvaluateNumberX 			; get value
.019cae	20 b6 90	jsr $0190b6			jsr 	CheckNextRParen 			; check right bracket.
.019cb1	20 1f 8d	jsr $018d1f			jsr 	GetSignCurrent 				; get sign -1,0,1.
.019cb4	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.019cb6	30 10		bmi $019cc8			bmi 	_URSetSeed
.019cb8	f0 28		beq $019ce2			beq 	_URMakeRandom 				; if zero return same number.
.019cba	da		phx				phx
.019cbb	a2 00		ldx #$00			ldx 	#0
.019cbd	20 19 9d	jsr $019d19			jsr 	Random16
.019cc0	a2 02		ldx #$02			ldx 	#2
.019cc2	20 19 9d	jsr $019d19			jsr 	Random16
.019cc5	fa		plx				plx
.019cc6	80 1a		bra $019ce2			bra 	_URMakeRandom
.019cc8					_URSetSeed:
.019cc8	20 2b 9a	jsr $019a2b			jsr 	FPUToFloat 					; make it a float to twiddle it.
.019ccb	b5 80		lda $80,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.019ccd	8d 9d 03	sta $039d			sta 	RandomSeed+0
.019cd0	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.019cd2	8d 9e 03	sta $039e			sta 	RandomSeed+1
.019cd5	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.019cd7	8d 9f 03	sta $039f			sta 	RandomSeed+2
.019cda	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.019cdc	0a		asl a				asl 	a
.019cdd	49 db		eor #$db			eor 	#$DB
.019cdf	8d a0 03	sta $03a0			sta 	RandomSeed+3
.019ce2					_URMakeRandom:
.019ce2	ad 9d 03	lda $039d			lda 	RandomSeed+0 				; check if seed is zero.
.019ce5	0d 9e 03	ora $039e			ora 	RandomSeed+1
.019ce8	0d 9f 03	ora $039f			ora 	RandomSeed+2
.019ceb	0d a0 03	ora $03a0			ora 	RandomSeed+3
.019cee	d0 0a		bne $019cfa			bne 	_URNotZero
.019cf0	a9 47		lda #$47			lda 	#$47
.019cf2	8d 9e 03	sta $039e			sta 	RandomSeed+1				; if it is, make it non zero.
.019cf5	a9 3d		lda #$3d			lda 	#$3D
.019cf7	8d a0 03	sta $03a0			sta 	RandomSeed+3
.019cfa					_URNotZero:
.019cfa	ad 9d 03	lda $039d			lda 	RandomSeed+0 				; copy seed into mantissa.
.019cfd	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019cff	ad 9e 03	lda $039e			lda 	RandomSeed+1
.019d02	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019d04	ad 9f 03	lda $039f			lda 	RandomSeed+2
.019d07	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019d09	ad a0 03	lda $03a0			lda 	RandomSeed+3
.019d0c	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019d0e	a9 00		lda #$00			lda 	#$00 						; set type to float.
.019d10	95 85		sta $85,x			sta 	XS_Type,x
.019d12	a9 80		lda #$80			lda 	#$80
.019d14	95 84		sta $84,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.019d16	4c 58 9a	jmp $019a58			jmp 	FPUNormalise
.019d19					Random16:
.019d19	5e 9e 03	lsr $039e,x			lsr 	RandomSeed+1,x				; shift seed right
.019d1c	7e 9d 03	ror $039d,x			ror 	RandomSeed,x
.019d1f	90 08		bcc $019d29			bcc 	_R16_NoXor
.019d21	bd 9e 03	lda $039e,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.019d24	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.019d26	9d 9e 03	sta $039e,x			sta 	RandomSeed+1,x
.019d29					_R16_NoXor:
.019d29	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.019d2a					Unary_Int:
.019d2a	20 a1 8a	jsr $018aa1			jsr 	EvaluateNumberX 			; get value
.019d2d	20 b6 90	jsr $0190b6			jsr 	CheckNextRParen 			; check right bracket.
.019d30	4c 77 9a	jmp $019a77			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Return to file: basic.asm

>019d33	02						.byte 	2
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 c0						.word 	StartROM
>fffe	19 c0					.word TIM_BreakHandler

;******  End of listing
