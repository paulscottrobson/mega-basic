
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Fri Aug 23 08:13:47 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="65816"				cpu = "65816"
="em65816"				hardware = "em65816"
=1					hasFloat = 1
=1					hasInteger = 1
=253					maxString = 253

;******  Processing file: modules/float/fpmacros.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/em65816/src_em65816.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0020					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0200					IFT_XCursor:.byte ?							; current logical position on screen
>0201					IFT_YCursor:.byte ?
>0202					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0266					IFT_LineBuffer: .fill 100 					; line input buffer.
>0300					UserVector .fill 4 							; USR(x) calls this.
>0304					LocalVector .fill 4 						; Indirect calls call this.
>0308					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>030c					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>030d					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=782					XS2_Mantissa = XS_Mantissa+XS_Size
=786					XS2_Exponent = XS_Exponent+XS_Size
=787					XS2_Type = XS_Type+XS_Size
=788					XS3_Mantissa = XS_Mantissa+XS_Size*2
=792					XS3_Exponent = XS_Exponent+XS_Size*2
=793					XS3_Type = XS_Type+XS_Size*2
>0400					Num_Buffer	.fill 	32 						; buffer for numeric conversions
>0420					NumBufX 	.byte 	?						; buffer index position
>0421					NumSuppress	.byte 	?						; leading zero suppression flag
>0422					NumConvCount .byte 	? 						; count for conversions.
>0423					ExpTemp:	.byte ?							; Working temp for exponents.
>0424					ExpCount:	.byte ? 						; Count of decimal exponents.
>0425					SignCount:	.byte ?							; Integer Divide Sign Counts.
>0426					StringPtr:	.byte ? 						; Top of free memory (for string allocation)
>0427					TempStringWriteIndex: .byte ? 				; Write offset.
>0428					ValSign: 	.byte ? 						; sign flag for val()
>0429					RandomSeed:	.dword ? 						; Random seed.
>042d					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>042f					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>0431					Tim_SR:		.byte ? 						; Processor Status
>0432					Tim_A:		.byte ? 						; Processor Registers
>0433					Tim_X:		.byte ?
>0434					Tim_Y:		.byte ?
>0435					Tim_Z:		.byte ?
>0436					Tim_SP:		.byte ?							; Stack Pointer

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/em65816.asm

=$8000					HighMemory = $8000
.1000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testcode.src

>1000	13 0a 00 d9 fe 07 61 62			.byte	$13,$0a,$00,$d9,$fe,$07,$61,$62
>1008	63 64 65 be ff 06 68 69			.byte	$63,$64,$65,$be,$ff,$06,$68,$69
>1010	20 21 00 00				.byte	$20,$21,$00,$00

;******  Return to file: modules/hardware/em65816.asm

.c000					StartROM:
.c000	18		clc				clc
.c001	fb		xce				xce
.c002	c2 30		rep #$30			rep 	#$30
.c004	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.c007	1b		tcs				tcs
.c008	e2 30		sep #$30			sep 	#$30 						; clear AXY in 16 bit.
.c00a	c2 30		rep #$30			rep 	#$30
.c00c	a9 00 00	lda #$0000			lda 	#$0000
.c00f	aa		tax				tax
.c010	a8		tay				tay
.c011	e2 30		sep #$30			sep 	#$30
.c013	4c f2 c3	jmp $c3f2		jmp BASIC_Start

;******  Processing file: modules/hardware/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b4					lastUnaryFunction = $b4
.c016					VectorTable:
>c016	fd c5					.word BinaryOp_And         & $FFFF ; $80 and
>c018	25 c6					.word BinaryOp_Or          & $FFFF ; $81 or
>c01a	4d c6					.word BinaryOp_Xor         & $FFFF ; $82 xor
>c01c	4d c6					.word BinaryOp_Eor         & $FFFF ; $83 eor
>c01e	90 c6					.word Binary_Equal         & $FFFF ; $84 =
>c020	af c6					.word Binary_NotEqual      & $FFFF ; $85 <>
>c022	b8 c6					.word Binary_Less          & $FFFF ; $86 <
>c024	c1 c6					.word Binary_LessEqual     & $FFFF ; $87 <=
>c026	d3 c6					.word Binary_Greater       & $FFFF ; $88 >
>c028	ca c6					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>c02a	68 c7					.word BinaryOp_Add         & $FFFF ; $8a +
>c02c	88 c7					.word BinaryOp_Subtract    & $FFFF ; $8b -
>c02e	9b c7					.word BinaryOp_Multiply    & $FFFF ; $8c *
>c030	ae c7					.word BinaryOp_Divide      & $FFFF ; $8d /
>c032	c8 c0					.word NotImplemented       & $FFFF ; $8e ^
>c034	c8 c0					.word NotImplemented       & $FFFF ; $8f if
>c036	c8 c0					.word NotImplemented       & $FFFF ; $90 while
>c038	c8 c0					.word NotImplemented       & $FFFF ; $91 repeat
>c03a	c8 c0					.word NotImplemented       & $FFFF ; $92 for
>c03c	c8 c0					.word NotImplemented       & $FFFF ; $93 then
>c03e	c8 c0					.word NotImplemented       & $FFFF ; $94 endif
>c040	c8 c0					.word NotImplemented       & $FFFF ; $95 wend
>c042	c8 c0					.word NotImplemented       & $FFFF ; $96 until
>c044	c8 c0					.word NotImplemented       & $FFFF ; $97 next
>c046	c8 c0					.word NotImplemented       & $FFFF ; $98 not
>c048	c8 c0					.word NotImplemented       & $FFFF ; $99 fn(
>c04a	d0 c8					.word Unary_Abs            & $FFFF ; $9a abs(
>c04c	14 ca					.word Unary_Asc            & $FFFF ; $9b asc(
>c04e	0e d5					.word Unary_Int            & $FFFF ; $9c int(
>c050	ee c8					.word Unary_Peek           & $FFFF ; $9d peek(
>c052	85 d4					.word Unary_Rnd            & $FFFF ; $9e rnd(
>c054	62 c9					.word Unary_Usr            & $FFFF ; $9f usr(
>c056	54 ca					.word Unary_Left           & $FFFF ; $a0 left$(
>c058	6b ca					.word Unary_Right          & $FFFF ; $a1 right$(
>c05a	39 ca					.word Unary_Mid            & $FFFF ; $a2 mid$(
>c05c	94 cb					.word Unary_Spc            & $FFFF ; $a3 spc(
>c05e	e1 c9					.word Unary_Str            & $FFFF ; $a4 str$(
>c060	74 c9					.word Unary_Val            & $FFFF ; $a5 val(
>c062	2a ca					.word Unary_Len            & $FFFF ; $a6 len(
>c064	b2 ca					.word Unary_Hex            & $FFFF ; $a7 hex$(
>c066	c8 c0					.word NotImplemented       & $FFFF ; $a8 sin(
>c068	c8 c0					.word NotImplemented       & $FFFF ; $a9 cos(
>c06a	c8 c0					.word NotImplemented       & $FFFF ; $aa tan(
>c06c	c8 c0					.word NotImplemented       & $FFFF ; $ab atn(
>c06e	c8 c0					.word NotImplemented       & $FFFF ; $ac exp(
>c070	c8 c0					.word NotImplemented       & $FFFF ; $ad log(
>c072	c8 c0					.word NotImplemented       & $FFFF ; $ae sqr(
>c074	0c cb					.word Unary_Dec            & $FFFF ; $af dec(
>c076	f2 c8					.word Unary_Deek           & $FFFF ; $b0 deek(
>c078	f6 c8					.word Unary_Leek           & $FFFF ; $b1 leek(
>c07a	2a c9					.word Unary_Mod            & $FFFF ; $b2 mod(
>c07c	7e c8					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>c07e	73 cb					.word Unary_Chr            & $FFFF ; $b4 chr$(
>c080	c8 c0					.word NotImplemented       & $FFFF ; $b5 $(
>c082	c8 c0					.word NotImplemented       & $FFFF ; $b6 $
>c084	c8 c0					.word NotImplemented       & $FFFF ; $b7 #(
>c086	c8 c0					.word NotImplemented       & $FFFF ; $b8 #
>c088	c8 c0					.word NotImplemented       & $FFFF ; $b9 %(
>c08a	c8 c0					.word NotImplemented       & $FFFF ; $ba %
>c08c	c8 c0					.word NotImplemented       & $FFFF ; $bb (
>c08e	c8 c0					.word NotImplemented       & $FFFF ; $bc )
>c090	c8 c0					.word NotImplemented       & $FFFF ; $bd ,
>c092	c8 c0					.word NotImplemented       & $FFFF ; $be :
>c094	c8 c0					.word NotImplemented       & $FFFF ; $bf ;
>c096	c8 c0					.word NotImplemented       & $FFFF ; $c0 def
>c098	2f c4					.word CLR_Command          & $FFFF ; $c1 clr
>c09a	c8 c0					.word NotImplemented       & $FFFF ; $c3 data
>c09c	c8 c0					.word NotImplemented       & $FFFF ; $c4 read
>c09e	c8 c0					.word NotImplemented       & $FFFF ; $c5 dim
>c0a0	c8 c0					.word NotImplemented       & $FFFF ; $c6 to
>c0a2	c8 c0					.word NotImplemented       & $FFFF ; $c7 step
>c0a4	c8 c0					.word NotImplemented       & $FFFF ; $c8 gosub
>c0a6	c8 c0					.word NotImplemented       & $FFFF ; $c9 return
>c0a8	c8 c0					.word NotImplemented       & $FFFF ; $ca goto
>c0aa	c8 c0					.word NotImplemented       & $FFFF ; $cb input
>c0ac	c8 c0					.word NotImplemented       & $FFFF ; $cc let
>c0ae	c8 c0					.word NotImplemented       & $FFFF ; $cd list
>c0b0	c8 c0					.word NotImplemented       & $FFFF ; $ce new
>c0b2	c8 c0					.word NotImplemented       & $FFFF ; $cf old
>c0b4	c8 c0					.word NotImplemented       & $FFFF ; $d0 on
>c0b6	c8 c0					.word NotImplemented       & $FFFF ; $d1 restore
>c0b8	c8 c0					.word NotImplemented       & $FFFF ; $d2 poke
>c0ba	c8 c0					.word NotImplemented       & $FFFF ; $d3 print
>c0bc	c8 c0					.word NotImplemented       & $FFFF ; $d4 run
>c0be	c8 c0					.word NotImplemented       & $FFFF ; $d5 stop
>c0c0	c8 c0					.word NotImplemented       & $FFFF ; $d6 wait
>c0c2	c8 c0					.word NotImplemented       & $FFFF ; $d7 doke
>c0c4	c8 c0					.word NotImplemented       & $FFFF ; $d8 loke
>c0c6	c8 c0					.word NotImplemented       & $FFFF ; $d9 assert
.c0c8					NotImplemented:
.c0c8	80 fe		bra $c0c8		_error: bra _error
.c0ca					BinaryPrecedence:
>c0ca	01					.byte 1    ; $80 and
>c0cb	01					.byte 1    ; $81 or
>c0cc	01					.byte 1    ; $82 xor
>c0cd	01					.byte 1    ; $83 eor
>c0ce	02					.byte 2    ; $84 =
>c0cf	02					.byte 2    ; $85 <>
>c0d0	02					.byte 2    ; $86 <
>c0d1	02					.byte 2    ; $87 <=
>c0d2	02					.byte 2    ; $88 >
>c0d3	02					.byte 2    ; $89 >=
>c0d4	03					.byte 3    ; $8a +
>c0d5	03					.byte 3    ; $8b -
>c0d6	04					.byte 4    ; $8c *
>c0d7	04					.byte 4    ; $8d /
>c0d8	05					.byte 5    ; $8e ^
.c0d9					KeywordText:
>c0d9	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>c0dc	4f d2					.byte $4f,$d2                          ; $81 or
>c0de	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>c0e1	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>c0e4	bd					.byte $bd                              ; $84 =
>c0e5	3c be					.byte $3c,$be                          ; $85 <>
>c0e7	bc					.byte $bc                              ; $86 <
>c0e8	3c bd					.byte $3c,$bd                          ; $87 <=
>c0ea	be					.byte $be                              ; $88 >
>c0eb	3e bd					.byte $3e,$bd                          ; $89 >=
>c0ed	ab					.byte $ab                              ; $8a +
>c0ee	ad					.byte $ad                              ; $8b -
>c0ef	aa					.byte $aa                              ; $8c *
>c0f0	af					.byte $af                              ; $8d /
>c0f1	de					.byte $de                              ; $8e ^
>c0f2	49 c6					.byte $49,$c6                          ; $8f if
>c0f4	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>c0f9	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>c0ff	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>c102	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>c106	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>c10b	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>c10f	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>c114	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>c118	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>c11b	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>c11e	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>c122	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>c126	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>c12a	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>c12f	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>c133	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>c137	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>c13d	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>c144	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>c149	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>c14d	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>c152	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>c156	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>c15a	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>c15f	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>c163	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>c167	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>c16b	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>c16f	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>c173	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>c177	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>c17b	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>c17f	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>c184	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>c189	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>c18d	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>c191	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>c196	24 a8					.byte $24,$a8                          ; $b5 $(
>c198	a4					.byte $a4                              ; $b6 $
>c199	23 a8					.byte $23,$a8                          ; $b7 #(
>c19b	a3					.byte $a3                              ; $b8 #
>c19c	25 a8					.byte $25,$a8                          ; $b9 %(
>c19e	a5					.byte $a5                              ; $ba %
>c19f	a8					.byte $a8                              ; $bb (
>c1a0	a9					.byte $a9                              ; $bc )
>c1a1	ac					.byte $ac                              ; $bd ,
>c1a2	ba					.byte $ba                              ; $be :
>c1a3	bb					.byte $bb                              ; $bf ;
>c1a4	44 45 c6				.byte $44,$45,$c6                      ; $c0 def
>c1a7	43 4c d2				.byte $43,$4c,$d2                      ; $c1 clr
>c1aa	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c3 data
>c1ae	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c4 read
>c1b2	44 49 cd				.byte $44,$49,$cd                      ; $c5 dim
>c1b5	54 cf					.byte $54,$cf                          ; $c6 to
>c1b7	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c7 step
>c1bb	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $c8 gosub
>c1c0	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $c9 return
>c1c6	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $ca goto
>c1ca	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $cb input
>c1cf	4c 45 d4				.byte $4c,$45,$d4                      ; $cc let
>c1d2	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $cd list
>c1d6	4e 45 d7				.byte $4e,$45,$d7                      ; $ce new
>c1d9	4f 4c c4				.byte $4f,$4c,$c4                      ; $cf old
>c1dc	4f ce					.byte $4f,$ce                          ; $d0 on
>c1de	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d1 restore
>c1e5	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d2 poke
>c1e9	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d3 print
>c1ee	52 55 ce				.byte $52,$55,$ce                      ; $d4 run
>c1f1	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $d5 stop
>c1f5	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d6 wait
>c1f9	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $d7 doke
>c1fd	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $d8 loke
>c201	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $d9 assert
>c207	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_dollarlparen = $b5
=$b6					token_dollar = $b6
=$b7					token_hashlparen = $b7
=$b8					token_hash = $b8
=$b9					token_percentlparen = $b9
=$ba					token_percent = $ba
=$bb					token_lparen = $bb
=$bc					token_rparen = $bc
=$bd					token_comma = $bd
=$be					token_colon = $be
=$bf					token_semicolon = $bf
=$c0					token_def = $c0
=$c1					token_clr = $c1
=$c3					token_data = $c3
=$c4					token_read = $c4
=$c5					token_dim = $c5
=$c6					token_to = $c6
=$c7					token_step = $c7
=$c8					token_gosub = $c8
=$c9					token_return = $c9
=$ca					token_goto = $ca
=$cb					token_input = $cb
=$cc					token_let = $cc
=$cd					token_list = $cd
=$ce					token_new = $ce
=$cf					token_old = $cf
=$d0					token_on = $d0
=$d1					token_restore = $d1
=$d2					token_poke = $d2
=$d3					token_print = $d3
=$d4					token_run = $d4
=$d5					token_stop = $d5
=$d6					token_wait = $d6
=$d7					token_doke = $d7
=$d8					token_loke = $d8
=$d9					token_assert = $d9

;******  Return to file: modules/hardware/em65816.asm


;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.c208					IFT_ClearScreen:
.c208	48		pha				pha
.c209	da		phx				phx
.c20a	5a		phy				phy
.c20b	20 a4 c3	jsr $c3a4			jsr 	IF_Home 					; home cursor
.c20e	a2 20		ldx #$20			ldx 	#IF_Height 					; this many lines.
.c210					_IFT_CS0:
.c210	a0 40		ldy #$40			ldy 	#IF_Width 					; this many chars/line
.c212					_IFT_CS1:
.c212	a9 20		lda #$20			lda 	#' '						; clear line.
.c214	20 d0 c3	jsr $c3d0			jsr 	IF_Write
.c217	88		dey				dey
.c218	d0 f8		bne $c212			bne 	_IFT_CS1
.c21a	20 b7 c3	jsr $c3b7			jsr 	IF_NewLine 					; next line down
.c21d	ca		dex				dex
.c21e	d0 f0		bne $c210			bne 	_IFT_CS0
.c220	7a		ply				ply
.c221	fa		plx				plx
.c222	68		pla				pla
.c223					IFT_HomeCursor:
.c223	48		pha				pha
.c224	20 a4 c3	jsr $c3a4			jsr 	IF_Home
.c227	a9 00		lda #$00			lda 	#0
.c229	8d 00 02	sta $0200			sta 	IFT_XCursor
.c22c	8d 01 02	sta $0201			sta 	IFT_YCursor
.c22f	68		pla				pla
.c230	60		rts				rts
.c231					IFT_UpLine:
.c231	48		pha				pha
.c232	ad 01 02	lda $0201			lda  	IFT_YCursor 				; get Y
.c235	3a		dec a				dec 	a 							; line above
.c236	30 03		bmi $c23b			bmi 	_IFTULExit 					; too far, abort
.c238	20 c6 c2	jsr $c2c6			jsr 	IFT_SetYPos					; set to that line.
.c23b					_IFTULExit:
.c23b	68		pla				pla
.c23c	60		rts				rts
.c23d					IFT_PrintCharacter:
.c23d	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.c23f	f0 16		beq $c257			beq 	IFT_NewLine
.c241	48		pha				pha
.c242	20 6f c2	jsr $c26f			jsr 	IFT_UpperCase 				; make upper case
.c245	20 d0 c3	jsr $c3d0			jsr 	IF_Write 					; write out.
.c248	ee 00 02	inc $0200			inc 	IFT_XCursor 				; bump x cursor
.c24b	ad 00 02	lda $0200			lda 	IFT_XCursor 				; reached RHS ?
.c24e	c9 40		cmp #$40			cmp 	#IF_Width
.c250	d0 03		bne $c255			bne 	_IFT_PCNotEOL
.c252	20 57 c2	jsr $c257			jsr 	IFT_NewLine 				; if so do new line.
.c255					_IFT_PCNotEOL:
.c255	68		pla				pla
.c256	60		rts				rts
.c257					IFT_NewLine:
.c257	48		pha				pha
.c258	20 b7 c3	jsr $c3b7			jsr 	IF_NewLine 					; new line on actual screen.
.c25b	a9 00		lda #$00			lda 	#0 							; reset x position
.c25d	8d 00 02	sta $0200			sta 	IFT_XCursor
.c260	ee 01 02	inc $0201			inc 	IFT_YCursor 				; move down.
.c263	ad 01 02	lda $0201			lda 	IFT_YCursor
.c266	c9 20		cmp #$20			cmp 	#IF_Height 					; reached bottom.
.c268	d0 03		bne $c26d			bne 	_IFT_NL_NotEOS
.c26a	20 7a c2	jsr $c27a			jsr 	IFT_Scroll 					; scroll screen up.
.c26d					_IFT_NL_NotEOS:
.c26d	68		pla				pla
.c26e	60		rts				rts
.c26f					IFT_UpperCase:
.c26f	c9 61		cmp #$61			cmp 	#"a"
.c271	90 06		bcc $c279			bcc 	_IFT_UCExit
.c273	c9 7b		cmp #$7b			cmp 	#"z"+1
.c275	b0 02		bcs $c279			bcs 	_IFT_UCExit
.c277	49 20		eor #$20			eor 	#$20
.c279					_IFT_UCExit:
.c279	60		rts				rts
.c27a					IFT_Scroll:
.c27a	48		pha				pha 								; save AXY
.c27b	da		phx				phx
.c27c	5a		phy				phy
.c27d	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.c27f					_IFT_SLoop:
.c27f	20 9f c2	jsr $c29f			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.c282	e8		inx				inx
.c283	e0 1f		cpx #$1f			cpx 	#IF_Height-1				; do whole screen
.c285	d0 f8		bne $c27f			bne 	_IFT_SLoop
.c287	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.c289	20 c6 c2	jsr $c2c6			jsr 	IFT_SetYPos
.c28c	a2 40		ldx #$40			ldx 	#IF_Width 					; blank line
.c28e					_IFT_SBlank:
.c28e	a9 20		lda #$20			lda 	#32
.c290	20 d0 c3	jsr $c3d0			jsr 	IF_Write
.c293	ca		dex				dex
.c294	d0 f8		bne $c28e			bne 	_IFT_SBlank
.c296	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.c298	20 c6 c2	jsr $c2c6			jsr 	IFT_SetYPos
.c29b	7a		ply				ply
.c29c	fa		plx				plx
.c29d	68		pla				pla
.c29e	60		rts				rts
.c29f					_IFT_ScrollLine:
.c29f	da		phx				phx
.c2a0	da		phx				phx
.c2a1	8a		txa				txa 								; copy line into buffer.
.c2a2	1a		inc a				inc 	a 							; next line down.
.c2a3	20 c6 c2	jsr $c2c6			jsr 	IFT_SetYPos
.c2a6	a2 00		ldx #$00			ldx 	#0
.c2a8					_IFTScrollCopy1:
.c2a8	20 c7 c3	jsr $c3c7			jsr 	IF_Read
.c2ab	9d 02 02	sta $0202,x			sta 	IFT_Buffer,x
.c2ae	e8		inx				inx
.c2af	e0 40		cpx #$40			cpx 	#IF_Width
.c2b1	d0 f5		bne $c2a8			bne 	_IFTScrollCopy1
.c2b3	68		pla				pla
.c2b4	20 c6 c2	jsr $c2c6			jsr 	IFT_SetYPos
.c2b7	a2 00		ldx #$00			ldx 	#0
.c2b9					_IFTScrollCopy2:
.c2b9	bd 02 02	lda $0202,x			lda 	IFT_Buffer,x
.c2bc	20 d0 c3	jsr $c3d0			jsr 	IF_Write
.c2bf	e8		inx				inx
.c2c0	e0 40		cpx #$40			cpx 	#IF_Width
.c2c2	d0 f5		bne $c2b9			bne 	_IFTScrollCopy2
.c2c4	fa		plx				plx
.c2c5	60		rts				rts
.c2c6					IFT_SetYPos:
.c2c6	48		pha				pha
.c2c7	da		phx				phx
.c2c8	aa		tax				tax
.c2c9	20 23 c2	jsr $c223			jsr 	IFT_HomeCursor
.c2cc	e0 00		cpx #$00			cpx 	#0
.c2ce	f0 09		beq $c2d9			beq 	_IFT_MOAExit
.c2d0					_IFT_MOALoop:
.c2d0	20 b7 c3	jsr $c3b7			jsr 	IF_NewLine
.c2d3	ee 01 02	inc $0201			inc 	IFT_YCursor
.c2d6	ca		dex				dex
.c2d7	d0 f7		bne $c2d0			bne		_IFT_MOALoop
.c2d9					_IFT_MOAExit:
.c2d9	fa		plx				plx
.c2da	68		pla				pla
.c2db	60		rts				rts
.c2dc					IFT_GetKeyCursor:
.c2dc	20 e4 c2	jsr $c2e4			jsr 	_IFT_FlipCursor 			; reverse current
.c2df					_IFT_GKCWait:
.c2df	20 e1 c3	jsr $c3e1			jsr 	IF_GetKey 					; get key
.c2e2	f0 fb		beq $c2df			beq 	_IFT_GKCWait
.c2e4					_IFT_FlipCursor:
.c2e4	48		pha				pha 								; save
.c2e5	20 c7 c3	jsr $c3c7			jsr 	IF_Read 					; read
.c2e8	20 d9 c3	jsr $c3d9			jsr 	IF_LeftOne
.c2eb	49 80		eor #$80			eor 	#$80 						; reverse
.c2ed	20 d0 c3	jsr $c3d0			jsr 	IF_Write 					; write
.c2f0	20 d9 c3	jsr $c3d9			jsr 	IF_LeftOne
.c2f3	68		pla				pla
.c2f4	60		rts				rts
.c2f5					IFT_ReadLine:
.c2f5	48		pha				pha
.c2f6					_IFT_RLLoop:
.c2f6	20 dc c2	jsr $c2dc			jsr 	IFT_GetKeyCursor 			; get keystroke
.c2f9	c9 0d		cmp #$0d			cmp 	#13							; return
.c2fb	f0 7d		beq $c37a			beq 	_IFT_RLExit
.c2fd	c9 20		cmp #$20			cmp 	#32 						; control character
.c2ff	90 05		bcc $c306			bcc 	_IFT_Control
.c301	20 3d c2	jsr $c23d			jsr 	IFT_PrintCharacter
.c304	80 f0		bra $c2f6			bra 	_IFT_RLLoop
.c306					_IFT_Control:
.c306	c9 01		cmp #$01			cmp 	#"A"-64
.c308	f0 26		beq $c330			beq 	_IFT_Left
.c30a	c9 04		cmp #$04			cmp 	#"D"-64
.c30c	f0 2e		beq $c33c			beq 	_IFT_Right
.c30e	c9 17		cmp #$17			cmp 	#"W"-64
.c310	f0 36		beq $c348			beq 	_IFT_Up
.c312	c9 13		cmp #$13			cmp 	#"S"-64
.c314	f0 3e		beq $c354			beq 	_IFT_Down
.c316	c9 08		cmp #$08			cmp 	#"H"-64
.c318	f0 09		beq $c323			beq 	_IFT_Backspace
.c31a	c9 1a		cmp #$1a			cmp 	#"Z"-64
.c31c	d0 d8		bne $c2f6			bne 	_IFT_RLLoop
.c31e	20 08 c2	jsr $c208			jsr 	IFT_ClearScreen				; clear CTL-Z
.c321	80 d3		bra $c2f6			bra 	_IFT_RLLoop
.c323					_IFT_Backspace:
.c323	ad 00 02	lda $0200			lda 	IFT_XCursor 				; check not start of line.
.c326	f0 ce		beq $c2f6			beq 	_IFT_RLLoop
.c328	20 d9 c3	jsr $c3d9			jsr 	IF_LeftOne
.c32b	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.c32d	20 d0 c3	jsr $c3d0			jsr 	IF_Write
.c330					_IFT_Left:
.c330	ce 00 02	dec $0200			dec 	IFT_XCursor 				; left CTL-W
.c333	10 29		bpl $c35e			bpl 	_IFT_Reposition
.c335	a9 3f		lda #$3f			lda 	#IF_Width-1
.c337					_IFT_SetX:
.c337	8d 00 02	sta $0200			sta 	IFT_XCursor
.c33a	80 22		bra $c35e			bra 	_IFT_Reposition
.c33c					_IFT_Right:
.c33c	ee 00 02	inc $0200			inc 	IFT_XCursor
.c33f	ad 00 02	lda $0200			lda 	IFT_XCursor
.c342	49 40		eor #$40			eor 	#IF_Width
.c344	f0 f1		beq $c337			beq 	_IFT_SetX
.c346	80 16		bra $c35e			bra 	_IFT_Reposition
.c348					_IFT_Up:
.c348	ce 01 02	dec $0201			dec 	IFT_YCursor
.c34b	10 11		bpl $c35e			bpl 	_IFT_Reposition
.c34d	a9 1f		lda #$1f			lda 	#IF_Height-1
.c34f					_IFT_SetY:
.c34f	8d 01 02	sta $0201			sta 	IFT_YCursor
.c352	80 0a		bra $c35e			bra 	_IFT_Reposition
.c354					_IFT_Down:
.c354	ee 01 02	inc $0201			inc 	IFT_YCursor
.c357	ad 01 02	lda $0201			lda 	IFT_YCursor
.c35a	49 20		eor #$20			eor 	#IF_Height
.c35c	f0 f1		beq $c34f			beq 	_IFT_SetY
.c35e					_IFT_Reposition:
.c35e	ad 00 02	lda $0200			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.c361	48		pha				pha
.c362	ad 01 02	lda $0201			lda 	IFT_YCursor
.c365	20 c6 c2	jsr $c2c6			jsr 	IFT_SetYPos
.c368	68		pla				pla
.c369	aa		tax				tax
.c36a	e0 00		cpx #$00			cpx 	#0
.c36c	f0 88		beq $c2f6			beq 	_IFT_RLLoop
.c36e					_IFT_MoveRight:
.c36e	20 c7 c3	jsr $c3c7			jsr 	IF_Read
.c371	ee 00 02	inc $0200			inc 	IFT_XCursor
.c374	ca		dex				dex
.c375	d0 f7		bne $c36e			bne 	_IFT_MoveRight
.c377	4c f6 c2	jmp $c2f6			jmp 	_IFT_RLLoop
.c37a					_IFT_RLExit:
.c37a	ad 01 02	lda $0201			lda 	IFT_YCursor 				; go to start of line.
.c37d	20 c6 c2	jsr $c2c6			jsr 	IFT_SetYPos
.c380	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.c382					_IFT_RLRead:
.c382	20 c7 c3	jsr $c3c7			jsr 	IF_Read
.c385	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.c388	e8		inx				inx
.c389	e0 40		cpx #$40			cpx 	#IF_Width
.c38b	d0 f5		bne $c382			bne 	_IFT_RLRead
.c38d					_IFT_RL_Trim:
.c38d	ca		dex				dex 	 							; previous char
.c38e	30 07		bmi $c397			bmi 	_IFT_Found 					; gone too far
.c390	bd 66 02	lda $0266,x			lda 	IFT_LineBuffer,x			; go back if space
.c393	c9 20		cmp #$20			cmp 	#" "
.c395	f0 f6		beq $c38d			beq 	_IFT_RL_Trim
.c397					_IFT_Found:
.c397	e8		inx				inx 								; forward to non-space
.c398	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.c39a	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.c39d	68		pla				pla
.c39e	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.c3a0	a0 02		ldy #$02			ldy 	#IFT_LineBuffer >> 8
.c3a2	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_em65816.asm

=64					IF_Width 	= 64 							; characters across
=32					IF_Height 	= 32 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line.
=8					IF_XPos 	= 8 							; current position, horizontal.
=$f0000					IF_Screen = $F0000							; 2k screen RAM here
=$f8010					IF_PKeyboard = $F8010						; Keyboard port.
=$f8000					IF_PBreak = $F8000 							; Break key.
.c3a3					IF_Reset:
.c3a3	60		rts				rts
.c3a4					IF_Home:
.c3a4	48		pha				pha
.c3a5	64 08		stz $08				stz 	IF_XPos 					; zero X position
.c3a7	a9 00		lda #$00			lda 	#IF_Screen & $FF 			; set r/w pos.
.c3a9	85 04		sta $04				sta 	IF_Pos
.c3ab	a9 00		lda #$00			lda 	#(IF_Screen >> 8) & $FF
.c3ad	85 05		sta $05				sta 	IF_Pos+1
.c3af	a9 0f		lda #$0f			lda 	#IF_Screen >> 16
.c3b1	85 06		sta $06				sta 	IF_Pos+2
.c3b3	64 07		stz $07				stz 	IF_Pos+3
.c3b5	68		pla				pla
.c3b6	60		rts				rts
.c3b7					IF_NewLine:
.c3b7	48		pha				pha
.c3b8	64 08		stz $08				stz 	IF_XPos						; back to start of line
.c3ba	18		clc				clc 								; down one line
.c3bb	a5 04		lda $04				lda 	IF_Pos
.c3bd	69 40		adc #$40			adc 	#64
.c3bf	85 04		sta $04				sta 	IF_Pos
.c3c1	90 02		bcc $c3c5			bcc 	_IF_NoCarry 				; carry through.
.c3c3	e6 05		inc $05				inc 	IF_Pos+1
.c3c5					_IF_NoCarry:
.c3c5	68		pla				pla
.c3c6	60		rts				rts
.c3c7					IF_Read:
.c3c7	5a		phy				phy 								; save current Y
.c3c8	a4 08		ldy $08				ldy 	IF_XPos 					; read character at current position
.c3ca	b7 04		lda [$04],y			lda 	[IF_Pos],y
.c3cc	e6 08		inc $08				inc 	IF_XPos 					; step right.
.c3ce	7a		ply				ply									; restore Y
.c3cf	60		rts				rts
.c3d0					IF_Write:
.c3d0	5a		phy				phy 								; save current Y
.c3d1	a4 08		ldy $08				ldy 	IF_XPos 					; write character at current position
.c3d3	97 04		sta [$04],y			sta 	[IF_Pos],y
.c3d5	e6 08		inc $08				inc 	IF_XPos 					; step right.
.c3d7	7a		ply				ply									; restore Y
.c3d8	60		rts				rts
.c3d9					IF_LeftOne:
.c3d9	c6 08		dec $08				dec 	IF_XPos
.c3db	60		rts				rts
.c3dc					IF_CheckBreak:
.c3dc	af 00 80 0f	lda $0f8000			lda 	IF_PBreak					; non-zero if Ctrl+C pressed.
.c3e0	60		rts				rts
.c3e1					IF_GetKey:
.c3e1	af 10 80 0f	lda $0f8010			lda 	IF_PKeyboard				; read keyboard
.c3e5	f0 08		beq $c3ef			beq		_IFGK_NoKey 				; skip if zero,no key pressed
.c3e7	48		pha				pha 								; key pressed, clear queue.
.c3e8	a9 00		lda #$00			lda 	#0
.c3ea	8f 10 80 0f	sta $0f8010			sta 	IF_PKeyboard
.c3ee	68		pla				pla
.c3ef					_IFGK_NoKey:
.c3ef	09 00		ora #$00			ora 	#0							; set Z flag appropriately.
.c3f1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm

.c3f2					BASIC_Start:
.c3f2	20 a3 c3	jsr $c3a3			jsr 	IF_Reset 					; set up and clear screen.
.c3f5	20 08 c2	jsr $c208			jsr 	IFT_ClearScreen
.c3f8	a9 5c		lda #$5c			lda 	#$5C 						; JMP Long opcode
.c3fa	8d 04 03	sta $0304			sta 	LocalVector
.c3fd	8d 00 03	sta $0300			sta 	UserVector
.c400	a9 72		lda #$72			lda 	#USRDefault & $FF 			; reset USR vector
.c402	8d 01 03	sta $0301			sta 	UserVector+1
.c405	a9 c9		lda #$c9			lda 	#(USRDefault >> 8) & $FF
.c407	8d 02 03	sta $0302			sta 	UserVector+2
.c40a	a9 00		lda #$00			lda 	#(USRDefault >> 16) & $FF
.c40c	8d 03 03	sta $0303			sta 	UserVector+3
.c40f	20 2f c4	jsr $c42f			jsr 	ResetRunStatus 				; clear everything (CLR command)
.c412	a9 00		lda #$00			lda 	#0 							; mark temp string pointer uninitialised.
.c414	85 21		sta $21				sta 	zTempStr+1 					; (done before every base level evaluation/or command)
.c416	a9 00		lda #$00			lda 	#BasicProgram & $FF
.c418	85 16		sta $16				sta 	zCodePtr+0
.c41a	a9 10		lda #$10			lda 	#BasicProgram >> 8
.c41c	85 17		sta $17				sta 	zCodePtr+1
.c41e	a9 00		lda #$00			lda 	#0
.c420	85 18		sta $18				sta 	zCodePtr+2
.c422	85 19		sta $19				sta 	zCodePtr+3
.c424	a0 03		ldy #$03			ldy 	#3
.c426	c8		iny				iny
.c427	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c429	20 3d c4	jsr $c43d			jsr 	EvaluateExpression
>c42c	02						.byte 	2
.c42d					SyntaxError:
.c42d					ERR_Handler:
.c42d	80 fe		bra $c42d			bra 	ERR_Handler

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.c42f					CLR_Command:
.c42f					ResetRunStatus:
.c42f	a9 00		lda #$00			lda 	#HighMemory & $FF
.c431	8d 26 04	sta $0426			sta 	StringPtr
.c434	a9 80		lda #$80			lda 	#HighMemory >> 8
.c436	8d 27 04	sta $0427			sta 	StringPtr+1
.c439	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.c43a					EVESyntax:
.c43a	4c 2d c4	jmp $c42d			jmp 	SyntaxError
.c43d					EvaluateExpression:
.c43d	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.c43f					EvaluateExpressionX:
.c43f	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.c441					EvaluateExpressionXA:
.c441	48		pha				pha 								; save precedence on stack.
.c442	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c444	f0 f4		beq $c43a			beq 	EVESyntax 					; end of line, syntax error.
.c446	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.c448	b0 03		bcs $c44d			bcs 	_EVNotVariable
.c44a	4c 39 c5	jmp $c539			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.c44d					_EVNotVariable:
.c44d	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.c44f	90 e9		bcc $c43a			bcc 	EVESyntax
.c451	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.c453	b0 7c		bcs $c4d1			bcs 	_EVNotInteger
.c455	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.c457	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.c45a	a9 00		lda #$00			lda 	#0
.c45c	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.c45f	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.c462	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.c465	1a		inc a				inc 	a 							; set to type 1 (integer)
.c466	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.c469					_EVCheckNextInteger:
.c469	c8		iny				iny
.c46a	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c46c	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.c46e	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.c470	b0 0d		bcs $c47f			bcs 	_EVCheckDecimal
.c472	48		pha				pha 								; save it.
.c473	20 3a c5	jsr $c53a			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.c476	68		pla				pla
.c477	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.c47a	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.c47d	80 ea		bra $c469			bra 	_EVCheckNextInteger
.c47f					_EVCheckDecimal:
.c47f	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c481	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.c483	d0 05		bne $c48a			bne 	_EVGotAtom 					; no, get atom.
.c485					_EVIsDecimal:
.c485	20 6a c5	jsr $c56a			jsr 	EVGetDecimal 				; extend to the decimal part.
.c488	80 00		bra $c48a			bra 	_EVGotAtom 					; and continue to got atom.
.c48a					_EVGotAtom:
.c48a	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c48c	10 41		bpl $c4cf			bpl 	_EVExitDrop 				; must be a token.
.c48e	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.c490	b0 3d		bcs $c4cf			bcs 	_EVExitDrop
.c492	68		pla				pla 								; get current precedence
.c493	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.c495	da		phx				phx 								; save X
.c496	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c498	aa		tax				tax 								; put in X
.c499	bd 4a c0	lda $c04a,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.c49c	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.c49e	fa		plx				plx 								; restore X
.c49f	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.c4a1	90 2d		bcc $c4d0			bcc 	_EVExit 					; exit if too low.
.c4a3	f0 2b		beq $c4d0			beq 	_EVExit 					; exit if equals
.c4a5	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.c4a7	48		pha				pha
.c4a8	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c4aa	48		pha				pha
.c4ab	c8		iny				iny
.c4ac	da		phx				phx 								; save current position
.c4ad	e8		inx				inx
.c4ae	e8		inx				inx
.c4af	e8		inx				inx
.c4b0	e8		inx				inx
.c4b1	e8		inx				inx
.c4b2	e8		inx				inx
.c4b3	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.c4b5	20 41 c4	jsr $c441			jsr 	EvaluateExpressionXA 		; do the RHS.
.c4b8	fa		plx				plx 								; restore X
.c4b9	68		pla				pla 								; get the binary operator in A.
.c4ba					_EVCallA:
.c4ba	da		phx				phx 								; save X again
.c4bb	0a		asl a				asl 	a 							; double, lose the MSB.
.c4bc	aa		tax				tax									; put in X
.c4bd	bd 16 c0	lda $c016,x			lda 	VectorTable,x 				; copy address into zGenPtr
.c4c0	8d 05 03	sta $0305			sta 	LocalVector+1
.c4c3	bd 17 c0	lda $c017,x			lda 	VectorTable+1,x
.c4c6	8d 06 03	sta $0306			sta 	LocalVector+2
.c4c9	fa		plx				plx 								; restore X
.c4ca	20 36 c5	jsr $c536			jsr 	_EVCallLocalVector
.c4cd	80 bb		bra $c48a			bra 	_EVGotAtom 					; and loop back.
.c4cf					_EVExitDrop:
.c4cf	68		pla				pla
.c4d0					_EVExit:
.c4d0	60		rts				rts
.c4d1					_EVNotInteger:
.c4d1	c8		iny				iny
.c4d2	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.c4d4	d0 19		bne $c4ef			bne 	_EVNotMinus
.c4d6	20 bb c5	jsr $c5bb			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.c4d9	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.c4dc	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.c4de	f0 05		beq $c4e5			beq 	_EVMinusFloat
.c4e0	20 37 cd	jsr $cd37			jsr 	IntegerNegateAlways 		; negation
.c4e3	80 a5		bra $c48a			bra 	_EVGotAtom 					; and go back.
.c4e5					_EVMinusFloat:
.c4e5	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; invert the sign bit.
.c4e8	49 80		eor #$80			eor 	#$80
.c4ea	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.c4ed	80 9b		bra $c48a			bra 	_EVGotAtom
.c4ef					_EVNotMinus:
.c4ef	c9 bb		cmp #$bb			cmp 	#token_lparen 				; is it left parenthesis
.c4f1	d0 0c		bne $c4ff			bne 	_EVNotParenthesis
.c4f3	20 3f c4	jsr $c43f			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.c4f6	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c4f8	c8		iny				iny
.c4f9	c9 bc		cmp #$bc			cmp 	#token_rparen 				; okay if right bracket.
.c4fb	f0 8d		beq $c48a			beq 	_EVGotAtom
.c4fd	80 fe		bra $c4fd		_error: bra _error
.c4ff					_EVNotParenthesis:
.c4ff	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.c501	d0 0c		bne $c50f			bne 	_EVNotNot
.c503	20 bb c5	jsr $c5bb			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.c506	20 2b d2	jsr $d22b			jsr 	FPUToInteger 				; make it an integer - if possible.
.c509	20 98 c5	jsr $c598			jsr 	NotInteger 					; do the not calculation
.c50c	4c 8a c4	jmp $c48a			jmp 	_EVGotAtom
.c50f					_EVNotNot:
.c50f	c9 fe		cmp #$fe			cmp 	#$FE
.c511	d0 15		bne $c528			bne 	_EVNotString
.c513	20 37 cc	jsr $cc37			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.c516	a5 20		lda $20				lda 	zTempStr 					; copy address of string into mantissa
.c518	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.c51b	a5 21		lda $21				lda 	zTempStr+1
.c51d	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.c520	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.c522	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.c525	4c 8a c4	jmp $c48a			jmp 	_EVGotAtom
.c528					_EVNotString:
.c528	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.c52a	90 04		bcc $c530			bcc 	_EVBadElement
.c52c	c9 b5		cmp #$b5			cmp 	#lastUnaryFunction+1
.c52e	90 03		bcc $c533			bcc 	_EVUnaryFunction
.c530					_EVBadElement:
.c530	4c 2d c4	jmp $c42d			jmp 	SyntaxError
.c533					_EVUnaryFunction:
.c533	4c ba c4	jmp $c4ba			jmp 	_EVCallA
.c536					_EVCallLocalVector:
.c536	6c 05 03	jmp ($0305)			jmp 	(LocalVector+1)
.c539					_EVVariableHandler:
.c539	ea		nop				nop
.c53a					EVShiftMantissaLeft6:
.c53a	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.c53d	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.c540	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.c543	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.c546	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.c549	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.c54c	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.c54f	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.c552	a9 00		lda #$00			lda 	#0
.c554	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.c557	20 5a c5	jsr $c55a			jsr 	_EVSMLShift 					; call it here to do it twice
.c55a					_EVSMLShift:
.c55a	5e 0c 03	lsr $030c,x			lsr 	XS_Exponent,x
.c55d	7e 0b 03	ror $030b,x			ror 	XS_Mantissa+3,x
.c560	7e 0a 03	ror $030a,x			ror 	XS_Mantissa+2,x
.c563	7e 09 03	ror $0309,x			ror 	XS_Mantissa+1,x
.c566	7e 08 03	ror $0308,x			ror 	XS_Mantissa+0,x
.c569	60		rts				rts
.c56a					EVGetDecimal:
.c56a	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.c56c	8d 00 04	sta $0400			sta 	Num_Buffer
.c56f	da		phx				phx
.c570	c8		iny				iny
.c571	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c573	c8		iny				iny
.c574	3a		dec a				dec 	a								; convert to a string length.
.c575	3a		dec a				dec 	a
.c576	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.c578					_EVGDCopy:
.c578	48		pha				pha 									; save count
.c579	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c57b	9d 00 04	sta $0400,x			sta 	Num_Buffer,x
.c57e	e8		inx				inx 									; forward ....
.c57f	c8		iny				iny
.c580	68		pla				pla 									; get count
.c581	3a		dec a				dec 	a 								; until zero
.c582	d0 f4		bne $c578			bne 	_EVGDCopy
.c584	9d 00 04	sta $0400,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.c587	fa		plx				plx 									; restore X
.c588	a9 00		lda #$00			lda 	#Num_Buffer & $FF 				; set zGenPtr
.c58a	85 1e		sta $1e				sta 	zGenPtr
.c58c	a9 04		lda #$04			lda 	#Num_Buffer >> 8
.c58e	85 1f		sta $1f				sta 	zGenPtr+1
.c590	5a		phy				phy 									; save Y
.c591	a0 00		ldy #$00			ldy 	#0 								; start position
.c593	20 04 d4	jsr $d404			jsr 	FPFromString 					; convert current
.c596	7a		ply				ply 									; restore Y
.c597	60		rts				rts
.c598					NotInteger:
.c598	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.c59b	49 ff		eor #$ff			eor 	#$FF
.c59d	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.c5a0	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.c5a3	49 ff		eor #$ff			eor 	#$FF
.c5a5	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.c5a8	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.c5ab	49 ff		eor #$ff			eor 	#$FF
.c5ad	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.c5b0	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.c5b3	49 ff		eor #$ff			eor 	#$FF
.c5b5	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.c5b8	60		rts				rts
.c5b9					EvaluateGetAtom:
.c5b9	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.c5bb					EvaluateGetAtomX:
.c5bb	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.c5bd	20 41 c4	jsr $c441			jsr 	EvaluateExpressionXA
.c5c0	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.c5c3	29 0f		and #$0f			and 	#15
.c5c5	c9 02		cmp #$02			cmp 	#2
.c5c7	b0 01		bcs $c5ca			bcs 	EvaluateType
.c5c9	60		rts				rts
.c5ca					EvaluateType:
.c5ca	80 fe		bra $c5ca		_error: bra _error
.c5cc					EvaluateNumber:
.c5cc	a2 00		ldx #$00			ldx 	#0
.c5ce					EvaluateNumberX:
.c5ce	20 3f c4	jsr $c43f			jsr 	EvaluateExpressionX
.c5d1	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 0/1
.c5d4	29 0f		and #$0f			and 	#15
.c5d6	c9 02		cmp #$02			cmp 	#2
.c5d8	b0 f0		bcs $c5ca			bcs 	EvaluateType
.c5da	60		rts				rts
.c5db					EvaluateInteger:
.c5db	a2 00		ldx #$00			ldx 	#0
.c5dd					EvaluateIntegerX:
.c5dd	20 ce c5	jsr $c5ce			jsr 	EvaluateNumberX
.c5e0	20 2b d2	jsr $d22b			jsr 	FPUToInteger
.c5e3	60		rts				rts
.c5e4					EvaluateString:
.c5e4	a2 00		ldx #$00			ldx 	#0
.c5e6					EvaluateStringX:
.c5e6	20 3f c4	jsr $c43f			jsr 	EvaluateExpressionX
.c5e9	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 2
.c5ec	29 0f		and #$0f			and 	#15
.c5ee	c9 02		cmp #$02			cmp 	#2
.c5f0	d0 d8		bne $c5ca			bne 	EvaluateType
.c5f2	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.c5f5	85 1e		sta $1e				sta 	zGenPtr
.c5f7	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.c5fa	85 1f		sta $1f				sta 	zGenPtr+1
.c5fc	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.c5fd					BinaryOp_And:
.c5fd	20 75 c6	jsr $c675			jsr 	BinaryMakeBothInteger
.c600	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.c603	3d 0e 03	and $030e,x			and 	XS2_Mantissa+0,x
.c606	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.c609	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.c60c	3d 0f 03	and $030f,x			and 	XS2_Mantissa+1,x
.c60f	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.c612	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.c615	3d 10 03	and $0310,x			and 	XS2_Mantissa+2,x
.c618	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.c61b	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.c61e	3d 11 03	and $0311,x			and 	XS2_Mantissa+3,x
.c621	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.c624	60		rts				rts
.c625					BinaryOp_Or:
.c625	20 75 c6	jsr $c675			jsr 	BinaryMakeBothInteger
.c628	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.c62b	1d 0e 03	ora $030e,x			ora 	XS2_Mantissa+0,x
.c62e	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.c631	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.c634	1d 0f 03	ora $030f,x			ora 	XS2_Mantissa+1,x
.c637	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.c63a	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.c63d	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.c640	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.c643	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.c646	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.c649	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.c64c	60		rts				rts
.c64d					BinaryOp_Eor:
.c64d					BinaryOp_Xor:
.c64d	20 75 c6	jsr $c675			jsr 	BinaryMakeBothInteger
.c650	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.c653	5d 0e 03	eor $030e,x			eor 	XS2_Mantissa+0,x
.c656	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.c659	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.c65c	5d 0f 03	eor $030f,x			eor 	XS2_Mantissa+1,x
.c65f	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.c662	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.c665	5d 10 03	eor $0310,x			eor 	XS2_Mantissa+2,x
.c668	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.c66b	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.c66e	5d 11 03	eor $0311,x			eor 	XS2_Mantissa+3,x
.c671	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.c674	60		rts				rts
.c675					BinaryMakeBothInteger:
.c675	da		phx				phx 								; save X
.c676	e8		inx				inx
.c677	e8		inx				inx
.c678	e8		inx				inx
.c679	e8		inx				inx
.c67a	e8		inx				inx
.c67b	e8		inx				inx
.c67c	20 80 c6	jsr $c680			jsr 	BinaryMakeInteger 			; convert to integer.
.c67f	fa		plx				plx 								; restore X and fall through.
.c680					BinaryMakeInteger:
.c680	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type byte.
.c683	29 0f		and #$0f			and 	#15 						; check type zero
.c685	f0 04		beq $c68b			beq 	_BMIConvert 				; if float convert to integer.
.c687	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.c688	90 04		bcc $c68e			bcc 	_BMIError
.c68a	60		rts				rts
.c68b					_BMIConvert:
.c68b	4c 2b d2	jmp $d22b			jmp 	FPUToInteger 				; convert to integer
.c68e					_BMIError:
.c68e	80 fe		bra $c68e		_error: bra _error

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.c690					Binary_Equal:
.c690	20 dc c6	jsr $c6dc			jsr 	CompareValues
.c693	09 00		ora #$00			ora 	#0
.c695	f0 04		beq $c69b			beq 	CCTrue
.c697	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.c699	80 02		bra $c69d			bra 	CCWrite
.c69b	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.c69d	9d 08 03	sta $0308,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.c6a0	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.c6a3	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.c6a6	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.c6a9	a9 01		lda #$01			lda 	#1
.c6ab	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; set type to integer whatever.
.c6ae	60		rts				rts
.c6af					Binary_NotEqual:
.c6af	20 dc c6	jsr $c6dc			jsr 	CompareValues
.c6b2	09 00		ora #$00			ora 	#0
.c6b4	d0 e1		bne $c697			bne 	CCFalse
.c6b6	80 e3		bra $c69b			bra 	CCTrue
.c6b8					Binary_Less:
.c6b8	20 dc c6	jsr $c6dc			jsr 	CompareValues
.c6bb	09 00		ora #$00			ora 	#0
.c6bd	30 dc		bmi $c69b			bmi 	CCTrue
.c6bf	80 d6		bra $c697			bra 	CCFalse
.c6c1					Binary_LessEqual:
.c6c1	20 dc c6	jsr $c6dc			jsr 	CompareValues
.c6c4	c9 01		cmp #$01			cmp 	#1
.c6c6	d0 d3		bne $c69b			bne 	CCTrue
.c6c8	80 cd		bra $c697			bra 	CCFalse
.c6ca					Binary_GreaterEqual:
.c6ca	20 dc c6	jsr $c6dc			jsr 	CompareValues
.c6cd	09 00		ora #$00			ora 	#0
.c6cf	10 ca		bpl $c69b			bpl 	CCTrue
.c6d1	80 c4		bra $c697			bra 	CCFalse
.c6d3					Binary_Greater:
.c6d3	20 dc c6	jsr $c6dc			jsr 	CompareValues
.c6d6	c9 01		cmp #$01			cmp 	#1
.c6d8	d0 c1		bne $c69b			bne 	CCTrue
.c6da	80 bb		bra $c697			bra 	CCFalse
.c6dc					CompareValues:
.c6dc	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and the types together
.c6df	3d 13 03	and $0313,x			and 	XS2_Type,x
.c6e2	c9 02		cmp #$02			cmp 	#2
.c6e4	f0 13		beq $c6f9			beq 	_CVString
.c6e6	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.c6e9	3d 13 03	and $0313,x			and 	XS2_Type,x
.c6ec	4a		lsr a				lsr 	a 							; shift bit 0 into C
.c6ed	90 03		bcc $c6f2			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.c6ef	4c 3f c7	jmp $c73f			jmp 	CompareInteger32 							; so execute code at \1
.c6f2					_BCFloat:
.c6f2	20 0d c8	jsr $c80d			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.c6f5	4c 3a d1	jmp $d13a			jmp 	FPCompare 							; and execute code at \2
.c6f8	60		rts				rts
.c6f9					_CVString:
.c6f9	da		phx				phx 								; save XY
.c6fa	5a		phy				phy
.c6fb	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.c6fe	85 1a		sta $1a				sta		zLTemp1+0
.c700	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.c703	85 1b		sta $1b				sta 	zLTemp1+1
.c705	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x
.c708	85 1c		sta $1c				sta 	zLTemp1+2
.c70a	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.c70d	85 1d		sta $1d				sta 	zLTemp1+3
.c70f	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.c711	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.c713	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.c715	90 02		bcc $c719			bcc 	_CVCommon
.c717	b1 1c		lda ($1c),y			lda 	(zLTemp1+2),y
.c719					_CVCommon:
.c719	aa		tax				tax 								; put shorter string length in zero.
.c71a	f0 0c		beq $c728			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.c71c					_CVCompare:
.c71c	c8		iny				iny 								; next character
.c71d	b1 1a		lda ($1a),y			lda 	(zLTemp1),y 				; compare characters
.c71f	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.c721	90 13		bcc $c736			bcc 	_CVReturnLess 				; <
.c723	d0 15		bne $c73a			bne 	_CVReturnGreater 			; >
.c725	ca		dex				dex 								; until common length matched.
.c726	d0 f4		bne $c71c			bne 	_CVCompare
.c728					_CVMatch:
.c728	a0 00		ldy #$00			ldy 	#0
.c72a	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.c72c	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.c72e	90 06		bcc $c736			bcc 	_CVReturnLess 				; <
.c730	d0 08		bne $c73a			bne 	_CVReturnGreater 			; >
.c732	a9 00		lda #$00			lda 	#0
.c734	80 06		bra $c73c			bra 	_CVExit 					; same common, same length, same string
.c736					_CVReturnLess:
.c736	a9 ff		lda #$ff			lda 	#$FF
.c738	80 02		bra $c73c			bra 	_CVExit
.c73a					_CVReturnGreater:
.c73a	a9 01		lda #$01			lda 	#$01
.c73c					_CVExit:
.c73c	7a		ply				ply
.c73d	fa		plx				plx
.c73e	60		rts				rts
.c73f					CompareInteger32:
.c73f	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.c742	49 80		eor #$80			eor 	#$80
.c744	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.c747	bd 11 03	lda $0311,x			lda 	XS2_Mantissa+3,x
.c74a	49 80		eor #$80			eor 	#$80
.c74c	9d 11 03	sta $0311,x			sta 	XS2_Mantissa+3,x
.c74f	20 e7 c7	jsr $c7e7			jsr 	SubInteger32 				; subtraction
.c752	90 11		bcc $c765			bcc 	_CI32Less 					; cc return -1
.c754	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; check if zero
.c757	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.c75a	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.c75d	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.c760	f0 02		beq $c764			beq 	_CI32Exit
.c762	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.c764					_CI32Exit:
.c764	60		rts				rts
.c765					_CI32Less:
.c765	a9 ff		lda #$ff			lda 	#$FF
.c767	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.c768					BinaryOp_Add:
.c768	bd 0d 03	lda $030d,x			lda 	XS_Type,x  					; and types together
.c76b	3d 13 03	and $0313,x			and 	XS2_Type,x
.c76e	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.c770	d0 13		bne $c785			bne 	_BOAString
.c772	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.c775	3d 13 03	and $0313,x			and 	XS2_Type,x
.c778	4a		lsr a				lsr 	a 							; shift bit 0 into C
.c779	90 03		bcc $c77e			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.c77b	4c c1 c7	jmp $c7c1			jmp 	AddInteger32 							; so execute code at \1
.c77e					_BCFloat:
.c77e	20 0d c8	jsr $c80d			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.c781	4c c0 ce	jmp $cec0			jmp 	FPAdd 							; and execute code at \2
.c784	60		rts				rts
.c785					_BOAString:
.c785	4c 27 c8	jmp $c827			jmp 	ConcatenateString 			; concatenate two strings.
.c788					BinaryOp_Subtract:
.c788	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.c78b	3d 13 03	and $0313,x			and 	XS2_Type,x
.c78e	4a		lsr a				lsr 	a 							; shift bit 0 into C
.c78f	90 03		bcc $c794			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.c791	4c e7 c7	jmp $c7e7			jmp 	SubInteger32 							; so execute code at \1
.c794					_BCFloat:
.c794	20 0d c8	jsr $c80d			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.c797	4c b6 ce	jmp $ceb6			jmp 	FPSubtract 							; and execute code at \2
.c79a	60		rts				rts
.c79b					BinaryOp_Multiply:
.c79b	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.c79e	3d 13 03	and $0313,x			and 	XS2_Type,x
.c7a1	4a		lsr a				lsr 	a 							; shift bit 0 into C
.c7a2	90 03		bcc $c7a7			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.c7a4	4c 5c cc	jmp $cc5c			jmp 	MulInteger32 							; so execute code at \1
.c7a7					_BCFloat:
.c7a7	20 0d c8	jsr $c80d			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.c7aa	4c 1a d0	jmp $d01a			jmp 	FPMultiply 							; and execute code at \2
.c7ad	60		rts				rts
.c7ae					BinaryOp_Divide:
.c7ae	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.c7b1	3d 13 03	and $0313,x			and 	XS2_Type,x
.c7b4	4a		lsr a				lsr 	a 							; shift bit 0 into C
.c7b5	90 03		bcc $c7ba			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.c7b7	4c b3 cc	jmp $ccb3			jmp 	DivInteger32 							; so execute code at \1
.c7ba					_BCFloat:
.c7ba	20 0d c8	jsr $c80d			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.c7bd	4c 92 cf	jmp $cf92			jmp 	FPDivide 							; and execute code at \2
.c7c0	60		rts				rts
.c7c1					AddInteger32:
.c7c1	18		clc				clc
.c7c2	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.c7c5	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.c7c8	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.c7cb	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.c7ce	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.c7d1	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.c7d4	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.c7d7	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.c7da	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.c7dd	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.c7e0	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.c7e3	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.c7e6	60		rts				rts
.c7e7					SubInteger32:
.c7e7	38		sec				sec
.c7e8	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.c7eb	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.c7ee	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.c7f1	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.c7f4	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.c7f7	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.c7fa	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.c7fd	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.c800	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.c803	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.c806	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.c809	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.c80c	60		rts				rts
.c80d					BinaryMakeBothFloat:
.c80d	da		phx				phx 								; save X
.c80e	e8		inx				inx
.c80f	e8		inx				inx
.c810	e8		inx				inx
.c811	e8		inx				inx
.c812	e8		inx				inx
.c813	e8		inx				inx
.c814	20 18 c8	jsr $c818			jsr 	BinaryMakeFloat 			; convert to float.
.c817	fa		plx				plx 								; restore X and fall through.
.c818					BinaryMakeFloat:
.c818	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type byte.
.c81b	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.c81c	b0 04		bcs $c822			bcs 	_BMFConvert
.c81e	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.c81f	b0 04		bcs $c825			bcs 	_BMFError
.c821	60		rts				rts
.c822					_BMFConvert:
.c822	4c cc d1	jmp $d1cc			jmp 	FPUToFloat 					; convert to float
.c825					_BMFError:
.c825	80 fe		bra $c825		_error: bra _error
.c827					ConcatenateString:
.c827	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.c82a	85 1a		sta $1a				sta		zLTemp1+0
.c82c	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.c82f	85 1b		sta $1b				sta 	zLTemp1+1
.c831	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x
.c834	85 1c		sta $1c				sta 	zLTemp1+2
.c836	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.c839	85 1d		sta $1d				sta 	zLTemp1+3
.c83b	5a		phy				phy
.c83c	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.c83e	b1 1a		lda ($1a),y			lda 	(zlTemp1),y
.c840	71 1c		adc ($1c),y			adc 	(zlTemp1+2),y
.c842	7a		ply				ply
.c843	b0 37		bcs $c87c			bcs 	_CSError					; check in range.
.c845	c9 fe		cmp #$fe			cmp 	#maxString+1
.c847	b0 33		bcs $c87c			bcs 	_CSError
.c849	20 fc cb	jsr $cbfc			jsr 	AllocateTempString 			; store the result
.c84c	20 67 c8	jsr $c867			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.c84f	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.c852	85 1a		sta $1a				sta 	zLTemp1
.c854	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.c857	85 1b		sta $1b				sta 	zLTemp1+1
.c859	20 67 c8	jsr $c867			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.c85c	a5 20		lda $20				lda 	zTempStr 					; point current to new string
.c85e	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.c861	a5 21		lda $21				lda 	zTempStr+1
.c863	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.c866	60		rts				rts
.c867					_CSCopyString:
.c867	da		phx				phx
.c868	5a		phy				phy
.c869	a0 00		ldy #$00			ldy 	#0 							; get length
.c86b	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.c86d	f0 0a		beq $c879			beq 	_CSCSExit 					; if zero, exit
.c86f	aa		tax				tax 								; put in X
.c870					_CSCSLoop:
.c870	c8		iny				iny 								; get next char
.c871	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.c873	20 27 cc	jsr $cc27			jsr		WriteTempString 			; copy out
.c876	ca		dex				dex 								; do whole string
.c877	d0 f7		bne $c870			bne 	_CSCSLoop
.c879					_CSCSExit:
.c879	7a		ply				ply
.c87a	fa		plx				plx
.c87b	60		rts				rts
.c87c					_CSError:
.c87c	80 fe		bra $c87c		_error: bra _error

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.c87e					Unary_Sgn:
.c87e	20 ce c5	jsr $c5ce			jsr 	EvaluateNumberX 			; get value
.c881	20 ec cb	jsr $cbec			jsr 	CheckNextRParen 			; check right bracket.
.c884	20 a8 c8	jsr $c8a8			jsr 	GetSignCurrent 				; get sign.
.c887	09 00		ora #$00			ora 	#0
.c889	10 09		bpl $c894			bpl		UnarySetAInteger			; if 0,1 return that.
.c88b	80 00		bra $c88d			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.c88d					UnarySetAMinus1:
.c88d	a9 ff		lda #$ff			lda 	#$FF
.c88f	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.c892	80 05		bra $c899			bra 	UnarySetAFill
.c894					UnarySetAInteger:
.c894	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.c897	a9 00		lda #$00			lda 	#0
.c899					UnarySetAFill:
.c899	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.c89c	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.c89f	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.c8a2	a9 01		lda #$01			lda 	#1
.c8a4	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.c8a7	60		rts				rts
.c8a8					GetSignCurrent:
.c8a8	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; identify type.
.c8ab	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.c8ac	90 19		bcc $c8c7			bcc 	_GSCFloat
.c8ae	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.c8b1	30 11		bmi $c8c4			bmi 	_GSCMinus1
.c8b3	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x
.c8b6	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.c8b9	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.c8bc	d0 03		bne $c8c1			bne 	_GSCPlus1
.c8be					_GSCZero:
.c8be	a9 00		lda #$00			lda 	#0
.c8c0	60		rts				rts
.c8c1					_GSCPlus1:
.c8c1	a9 01		lda #$01			lda 	#$01
.c8c3	60		rts				rts
.c8c4					_GSCMinus1:
.c8c4	a9 ff		lda #$ff			lda 	#$FF
.c8c6	60		rts				rts
.c8c7					_GSCFloat:
.c8c7	3c 0d 03	bit $030d,x			bit 	XS_Type,x
.c8ca	70 f2		bvs $c8be			bvs 	_GSCZero
.c8cc	30 f6		bmi $c8c4			bmi 	_GSCMinus1
.c8ce	80 f1		bra $c8c1			bra 	_GSCPlus1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.c8d0					Unary_Abs:
.c8d0	20 ce c5	jsr $c5ce			jsr 	EvaluateNumberX 			; get value
.c8d3	20 ec cb	jsr $cbec			jsr 	CheckNextRParen 			; check right bracket.
.c8d6	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.c8d9	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.c8db	f0 08		beq $c8e5			beq 	_UAMinusFloat
.c8dd	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; check MSB
.c8e0	10 0b		bpl $c8ed			bpl 	_UAExit
.c8e2	4c 37 cd	jmp $cd37			jmp 	IntegerNegateAlways 		; negation
.c8e5					_UAMinusFloat:
.c8e5	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; clear the sign bit.
.c8e8	29 7f		and #$7f			and		#$7F
.c8ea	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.c8ed					_UAExit:
.c8ed	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.c8ee					Unary_Peek:
.c8ee	a9 01		lda #$01			lda 	#1
.c8f0	80 06		bra $c8f8			bra 	UPMain
.c8f2					Unary_Deek:
.c8f2	a9 02		lda #$02			lda 	#2
.c8f4	80 02		bra $c8f8			bra 	UPMain
.c8f6					Unary_Leek:
.c8f6	a9 04		lda #$04			lda 	#4
.c8f8					UPMain:
.c8f8	48		pha				pha 								; set bytes to copy.
.c8f9	20 dd c5	jsr $c5dd			jsr 	EvaluateIntegerX 			; numeric parameter
.c8fc	20 ec cb	jsr $cbec			jsr 	CheckNextRParen 			; right bracket.
.c8ff	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.c902	85 1a		sta $1a				sta 	zLTemp1
.c904	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.c907	85 1b		sta $1b				sta 	zLTemp1+1
.c909	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.c90c	85 1c		sta $1c				sta 	zLTemp1+2
.c90e	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.c911	85 1d		sta $1d				sta 	zLTemp1+3
.c913	a9 00		lda #$00			lda 	#0 							; clear target area
.c915	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.c918	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.c91b	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.c91e	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.c921	68		pla				pla 								; restore bytes to copy
.c922	da		phx				phx 								; save XY
.c923	5a		phy				phy
.c924	20 d2 cb	jsr $cbd2			jsr 	MemRead 					; read the bytes in
.c927	7a		ply				ply 								; restore and exit
.c928	fa		plx				plx
.c929	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.c92a					Unary_Mod:
.c92a	20 56 c9	jsr $c956			jsr 	_UMParameter 				; first parameter
.c92d	20 f4 cb	jsr $cbf4			jsr 	CheckNextComma
.c930	da		phx				phx 								; second parameter
.c931	e8		inx				inx
.c932	e8		inx				inx
.c933	e8		inx				inx
.c934	e8		inx				inx
.c935	e8		inx				inx
.c936	e8		inx				inx
.c937	20 56 c9	jsr $c956			jsr 	_UMParameter
.c93a	fa		plx				plx
.c93b	20 ec cb	jsr $cbec			jsr 	CheckNextRParen
.c93e	20 b3 cc	jsr $ccb3			jsr 	DivInteger32 				; divide
.c941	a5 1a		lda $1a				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.c943	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.c946	a5 1b		lda $1b				lda 	zLTemp1+1
.c948	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.c94b	a5 1c		lda $1c				lda 	zLTemp1+2
.c94d	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.c950	a5 1d		lda $1d				lda 	zLTemp1+3
.c952	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.c955	60		rts				rts
.c956					_UMParameter:
.c956	20 dd c5	jsr $c5dd			jsr 	EvaluateIntegerX 			; get value
.c959	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; absolute value
.c95c	10 03		bpl $c961			bpl 	_UMNotSigned
.c95e	20 37 cd	jsr $cd37			jsr 	IntegerNegateAlways
.c961					_UMNotSigned:
.c961	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.c962					Unary_Usr:
.c962	20 ce c5	jsr $c5ce			jsr 	EvaluateNumberX 			; numeric parameter
.c965	20 ec cb	jsr $cbec			jsr 	CheckNextRParen 			; right bracket.
.c968	da		phx				phx 								; save XY
.c969	5a		phy				phy
.c96a	ea		nop				nop
.c96b	22 00 03 00	jsl $000300			jsl 	UserVector
.c96f	7a		ply				ply 								; and exit
.c970	fa		plx				plx
.c971	60		rts				rts
.c972					USRDefault:
.c972	80 fe		bra $c972		_error: bra _error

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.c974					Unary_Val:
.c974	20 e6 c5	jsr $c5e6			jsr 	EvaluateStringX 			; get string
.c977	20 ec cb	jsr $cbec			jsr 	CheckNextRParen 			; check right bracket.
.c97a	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.c97d	85 1e		sta $1e				sta 	zGenPtr
.c97f	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.c982	85 1f		sta $1f				sta 	zGenPtr+1
.c984	5a		phy				phy
.c985	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.c987	b1 1e		lda ($1e),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.c989	f0 54		beq $c9df			beq 	_UVBadNumber
.c98b	48		pha				pha 								; save length.
.c98c	1a		inc a				inc 	a 							; one for the length, one for the terminator
.c98d	1a		inc a				inc 	a
.c98e	20 fc cb	jsr $cbfc			jsr 	AllocateTempString
.c991	c8		iny				iny 								; move to the next.
.c992	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get character
.c994	49 2d		eor #$2d			eor 	#"-"						; zero if minus sign
.c996	8d 28 04	sta $0428			sta 	ValSign
.c999	d0 01		bne $c99c			bne 	_UVNotMinus
.c99b	c8		iny				iny 								; skip over it.
.c99c					_UVNotMinus:
.c99c	68		pla				pla 								; this is the count.
.c99d	48		pha		_UVCopy:pha									; copy into new temp string which is ASCIIZ
.c99e	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.c9a0	c8		iny				iny
.c9a1	20 27 cc	jsr $cc27			jsr 	WriteTempString
.c9a4	68		pla				pla
.c9a5	3a		dec a				dec 	a
.c9a6	d0 f5		bne $c99d			bne 	_UVCopy
.c9a8	20 27 cc	jsr $cc27			jsr 	WriteTempString 			; make it ASCIIZ
.c9ab	18		clc				clc
.c9ac	a5 20		lda $20				lda 	zTempStr 					; tempstring +1 => genptr
.c9ae	69 01		adc #$01			adc 	#1
.c9b0	85 1e		sta $1e				sta 	zGenPtr
.c9b2	a5 21		lda $21				lda 	zTempStr+1
.c9b4	69 00		adc #$00			adc 	#0
.c9b6	85 1f		sta $1f				sta 	zGenPtr+1
.c9b8	18		clc				clc
.c9b9	20 0b ce	jsr $ce0b			jsr 	IntFromString 				; first bit.
.c9bc	b0 21		bcs $c9df			bcs 	_UVBadNumber
.c9be	20 04 d4	jsr $d404			jsr 	FPFromString				; try for a float part.
.c9c1	ad 28 04	lda $0428			lda 	ValSign 					; was it negative
.c9c4	d0 13		bne $c9d9			bne 	_UVNotNegative
.c9c6	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; check if integer
.c9c9	4a		lsr a				lsr 	a
.c9ca	b0 0a		bcs $c9d6			bcs 	_UVInteger
.c9cc	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; set sign bit
.c9cf	09 80		ora #$80			ora 	#$80
.c9d1	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.c9d4	80 03		bra $c9d9			bra 	_UVNotNegative
.c9d6					_UVInteger:
.c9d6	20 37 cd	jsr $cd37			jsr 	IntegerNegateAlways 		; sign it.
.c9d9					_UVNotNegative:
.c9d9	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; used everything
.c9db	d0 02		bne $c9df			bne 	_UVBadNumber
.c9dd	7a		ply				ply
.c9de	60		rts				rts
.c9df					_UVBadNumber:
.c9df	80 fe		bra $c9df		_error: bra _error

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.c9e1					Unary_Str:
.c9e1	20 ce c5	jsr $c5ce			jsr 	EvaluateNumberX 			; numeric parameter
.c9e4	20 ec cb	jsr $cbec			jsr 	CheckNextRParen 			; right bracket.
.c9e7	a9 00		lda #$00			lda 	#0 							; reset buffer index
.c9e9	8d 20 04	sta $0420			sta 	NumBufX
.c9ec	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.c9ef	4a		lsr a				lsr 	a
.c9f0	b0 05		bcs $c9f7			bcs 	_USInt 						; if msb set do as integer
.c9f2	20 3d d3	jsr $d33d			jsr 	FPToString 					; call fp to str otherwise
.c9f5	80 03		bra $c9fa			bra 	_USDuplicate
.c9f7	20 5c cd	jsr $cd5c	_USInt:	jsr 	IntToString
.c9fa					_USDuplicate:
.c9fa	ad 20 04	lda $0420			lda 	NumBufX 					; chars in buffer
.c9fd	1a		inc a				inc 	a 							; one more for length
.c9fe	20 fc cb	jsr $cbfc			jsr 	AllocateTempString 			; allocate space for it.
.ca01	5a		phy				phy 								; save Y
.ca02	a0 00		ldy #$00			ldy 	#0 							; start copying
.ca04	b9 00 04	lda $0400,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.ca07	20 27 cc	jsr $cc27			jsr 	WriteTempString
.ca0a	c8		iny				iny
.ca0b	cc 20 04	cpy $0420			cpy 	NumBufX 					; done the lot
.ca0e	d0 f4		bne $ca04			bne 	_USCopy
.ca10	7a		ply				ply 								; restore Y
.ca11	4c c2 cb	jmp $cbc2			jmp 	UnaryReturnTempStr 			; return new temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.ca14					Unary_Asc:
.ca14	20 e6 c5	jsr $c5e6			jsr 	EvaluateStringX 			; string parameter
.ca17	20 ec cb	jsr $cbec			jsr 	CheckNextRParen 			; right bracket.
.ca1a	5a		phy				phy 								; get the string length
.ca1b	a0 00		ldy #$00			ldy 	#0
.ca1d	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.ca1f	f0 07		beq $ca28			beq 	_UAIllegal 					; must be at least one character
.ca21	c8		iny				iny
.ca22	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; read it.
.ca24	7a		ply				ply
.ca25	4c 94 c8	jmp $c894			jmp 	UnarySetAInteger
.ca28					_UAIllegal:
.ca28	80 fe		bra $ca28		_error: bra _error

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.ca2a					Unary_Len:
.ca2a	20 e6 c5	jsr $c5e6			jsr 	EvaluateStringX 			; string parameter
.ca2d	20 ec cb	jsr $cbec			jsr 	CheckNextRParen 			; right bracket.
.ca30	5a		phy				phy 								; get the string length
.ca31	a0 00		ldy #$00			ldy 	#0
.ca33	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.ca35	7a		ply				ply
.ca36	4c 94 c8	jmp $c894			jmp 	UnarySetAInteger

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.ca39					Unary_Mid:
.ca39	20 e6 c5	jsr $c5e6			jsr 	EvaluateStringX 				; get string.
.ca3c	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.ca3f	48		pha				pha
.ca40	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.ca43	48		pha				pha
.ca44	20 f4 cb	jsr $cbf4			jsr 	CheckNextComma 					; skip comma
.ca47	20 9e ca	jsr $ca9e			jsr 	SLIByteParameter 				; get a byte parameter (start)
.ca4a	48		pha				pha 									; and push it.
.ca4b	20 f4 cb	jsr $cbf4			jsr 	CheckNextComma 					; skip comma
.ca4e	20 9e ca	jsr $ca9e			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.ca51	48		pha				pha 									; and push it.
.ca52	80 46		bra $ca9a			bra 	SLIProcess
.ca54					Unary_Left:
.ca54	20 e6 c5	jsr $c5e6			jsr 	EvaluateStringX 				; get string.
.ca57	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.ca5a	48		pha				pha
.ca5b	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.ca5e	48		pha				pha
.ca5f	a9 01		lda #$01			lda 	#1 								; push start position (1)
.ca61	48		pha				pha
.ca62	20 f4 cb	jsr $cbf4			jsr 	CheckNextComma 					; skip comma
.ca65	20 9e ca	jsr $ca9e			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.ca68	48		pha				pha 									; and push it.
.ca69	80 2f		bra $ca9a			bra 	SLIProcess
.ca6b					Unary_Right:
.ca6b	20 e6 c5	jsr $c5e6			jsr 	EvaluateStringX 				; get string.
.ca6e	ea		nop				nop
.ca6f	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.ca72	48		pha				pha
.ca73	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.ca76	48		pha				pha
.ca77	da		phx				phx 									; get the string length and push on stack.
.ca78	a2 00		ldx #$00			ldx 	#0
.ca7a	a1 1e		lda ($1e,x)			lda		(zGenPtr,x)
.ca7c	fa		plx				plx
.ca7d	48		pha				pha
.ca7e	20 f4 cb	jsr $cbf4			jsr 	CheckNextComma 					; skip comma
.ca81	20 9e ca	jsr $ca9e			jsr 	SLIByteParameter 				; get a byte parameter.
.ca84	8d 25 04	sta $0425			sta 	SignCount 						; save in temporary.
.ca87	68		pla				pla 									; restore string length.
.ca88	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.ca89	38		sec				sec
.ca8a	ed 25 04	sbc $0425			sbc 	SignCount 						; subtract characters needed, gives start position.
.ca8d	f0 02		beq $ca91			beq 	_URStart 						; if <= 0 start from 1.
.ca8f	10 02		bpl $ca93			bpl 	_UROkay
.ca91					_URStart:
.ca91	a9 01		lda #$01			lda 	#1
.ca93					_UROkay:
.ca93	48		pha				pha 									; push start
.ca94	ad 25 04	lda $0425			lda 	SignCount 						; push count of characters
.ca97	48		pha				pha
.ca98	80 00		bra $ca9a			bra 	SLIProcess
.ca9a					SLIProcess:
.ca9a	20 ec cb	jsr $cbec			jsr 	CheckNextRParen 				; closing right bracket.
.ca9d	ea		nop				nop
.ca9e					SLIByteParameter:
.ca9e	20 dd c5	jsr $c5dd			jsr 	EvaluateIntegerX 				; get integer
.caa1	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.caa4	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.caa7	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.caaa	d0 04		bne $cab0			bne 	_SLIBPError
.caac	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.caaf	60		rts				rts
.cab0					_SLIBPError:
.cab0	80 fe		bra $cab0		_error: bra _error

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.cab2					Unary_Hex:
.cab2	20 dd c5	jsr $c5dd			jsr 	EvaluateIntegerX 			; numeric parameter
.cab5	20 ec cb	jsr $cbec			jsr 	CheckNextRParen 			; right bracket.
.cab8	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.caba	20 fc cb	jsr $cbfc			jsr 	AllocateTempString			; allocate string space
.cabd	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.cac0	20 e7 ca	jsr $cae7			jsr 	_UHConvert
.cac3	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.cac6	20 e7 ca	jsr $cae7			jsr 	_UHConvert
.cac9	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.cacc	20 e7 ca	jsr $cae7			jsr 	_UHConvert
.cacf	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.cad2	20 e7 ca	jsr $cae7			jsr 	_UHConvert
.cad5	5a		phy				phy 								; get length of new string
.cad6	a0 00		ldy #$00			ldy 	#0
.cad8	b1 20		lda ($20),y			lda 	(zTempStr),y
.cada	7a		ply				ply
.cadb	c9 00		cmp #$00			cmp 	#0
.cadd	d0 05		bne $cae4			bne 	_UHExit 					; if it was non zero okay
.cadf	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.cae1	20 27 cc	jsr $cc27			jsr 	WriteTempString
.cae4					_UHExit:
.cae4	4c c2 cb	jmp $cbc2			jmp 	UnaryReturnTempStr 			; return new temporary string.
.cae7					_UHConvert:
.cae7	48		pha				pha
.cae8	4a		lsr a				lsr 	a 							; do MSB
.cae9	4a		lsr a				lsr 	a
.caea	4a		lsr a				lsr 	a
.caeb	4a		lsr a				lsr 	a
.caec	20 f0 ca	jsr $caf0			jsr 	_UHNibble
.caef	68		pla				pla 								; do LSB
.caf0					_UHNibble:
.caf0	29 0f		and #$0f			and 	#15 						; get nibble
.caf2	d0 0c		bne $cb00			bne 	_UHNonZero
.caf4	5a		phy				phy									; get the length
.caf5	a0 00		ldy #$00			ldy 	#0
.caf7	b1 20		lda ($20),y			lda 	(zTempStr),y
.caf9	7a		ply				ply
.cafa	c9 00		cmp #$00			cmp 	#0 							; suppress leading zeros.
.cafc	f0 0d		beq $cb0b			beq 	_UHExit2
.cafe	a9 00		lda #$00			lda 	#0
.cb00					_UHNonZero:
.cb00	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.cb02	90 02		bcc $cb06			bcc 	_UHDigit
.cb04	69 06		adc #$06			adc 	#7-1
.cb06					_UHDigit:
.cb06	69 30		adc #$30			adc 	#48
.cb08	20 27 cc	jsr $cc27			jsr 	WriteTempString				; output.
.cb0b					_UHExit2:
.cb0b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.cb0c					Unary_Dec:
.cb0c	20 e6 c5	jsr $c5e6			jsr 	EvaluateStringX 			; string parameter
.cb0f	20 ec cb	jsr $cbec			jsr 	CheckNextRParen 			; right bracket.
.cb12	5a		phy				phy
.cb13	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.cb15	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.cb17	f0 4c		beq $cb65			beq 	_UDFail 					; must fail if zero.
.cb19	8d 25 04	sta $0425			sta 	SignCount 					; use SignCount as a counter
.cb1c	a9 00		lda #$00			lda 	#0 							; set result to zero integer.
.cb1e	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.cb21	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.cb24	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.cb27	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.cb2a	a9 01		lda #$01			lda 	#1
.cb2c	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.cb2f					_UDConvertLoop:
.cb2f	5a		phy				phy 								; shift mantissa left 4
.cb30	a0 04		ldy #$04			ldy 	#4
.cb32					_UDShift:
.cb32	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x
.cb35	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.cb38	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.cb3b	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.cb3e	88		dey				dey
.cb3f	d0 f1		bne $cb32			bne 	_UDShift
.cb41	7a		ply				ply
.cb42	c8		iny				iny 								; next character
.cb43	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; fetch it.
.cb45	20 67 cb	jsr $cb67			jsr 	ConvertUpper 				; convert to U/C
.cb48	c9 30		cmp #$30			cmp 	#"0"
.cb4a	90 19		bcc $cb65			bcc 	_UDFail
.cb4c	c9 3a		cmp #$3a			cmp 	#"9"+1
.cb4e	90 06		bcc $cb56			bcc 	_UDOkay
.cb50	e9 37		sbc #$37			sbc 	#7+"0" 						; alpha fudge
.cb52	c9 10		cmp #$10			cmp 	#16
.cb54	b0 0f		bcs $cb65			bcs 	_UDFail
.cb56					_UDOkay:
.cb56	29 0f		and #$0f			and 	#15 						; nibble only
.cb58	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x
.cb5b	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.cb5e	ce 25 04	dec $0425			dec 	SignCount 					; do it for each character
.cb61	d0 cc		bne $cb2f			bne 	_UDConvertLoop
.cb63	7a		ply				ply
.cb64	60		rts				rts
.cb65					_UDFail:
.cb65	80 fe		bra $cb65		_error: bra _error
.cb67					ConvertUpper:
.cb67	c9 61		cmp #$61			cmp 	#"a"
.cb69	90 07		bcc $cb72			bcc 	_CUExit
.cb6b	c9 7b		cmp #$7b			cmp 	#"z"+1
.cb6d	b0 03		bcs $cb72			bcs 	_CUExit
.cb6f	38		sec				sec
.cb70	e9 20		sbc #$20			sbc 	#32
.cb72	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.cb73					Unary_Chr:
.cb73	20 dd c5	jsr $c5dd			jsr 	EvaluateIntegerX			; numeric parameter
.cb76	20 ec cb	jsr $cbec			jsr 	CheckNextRParen 			; right bracket.
.cb79	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.cb7c	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.cb7f	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.cb82	d0 0e		bne $cb92			bne 	_UCChar
.cb84	a9 01		lda #$01			lda 	#1 							; one character string
.cb86	20 fc cb	jsr $cbfc			jsr 	AllocateTempString
.cb89	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.cb8c	20 27 cc	jsr $cc27			jsr 	WriteTempString
.cb8f	4c c2 cb	jmp $cbc2			jmp 	UnaryReturnTempStr
.cb92					_UCChar:
.cb92	80 fe		bra $cb92		_error: bra _error

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.cb94					Unary_Spc:
.cb94	20 dd c5	jsr $c5dd			jsr 	EvaluateIntegerX 			; numeric parameter
.cb97	20 ec cb	jsr $cbec			jsr 	CheckNextRParen 			; right bracket.
.cb9a	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.cb9d	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.cba0	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.cba3	d0 1b		bne $cbc0			bne 	_USSize
.cba5	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.cba8	c9 fe		cmp #$fe			cmp 	#maxString+1
.cbaa	b0 14		bcs $cbc0			bcs 	_USSize
.cbac	48		pha				pha 								; save length
.cbad	1a		inc a				inc 	a 							; allocate one more.
.cbae	20 fc cb	jsr $cbfc			jsr 	AllocateTempString
.cbb1	68		pla				pla 								; get length
.cbb2	f0 0e		beq $cbc2			beq 	UnaryReturnTempStr 			; return the current temp string
.cbb4					_USLoop:
.cbb4	48		pha				pha
.cbb5	a9 20		lda #$20			lda 	#" "
.cbb7	20 27 cc	jsr $cc27			jsr 	WriteTempString
.cbba	68		pla				pla
.cbbb	3a		dec a				dec 	a
.cbbc	d0 f6		bne $cbb4			bne 	_USLoop
.cbbe	80 02		bra $cbc2			bra 	UnaryReturnTempStr
.cbc0					_USSize:
.cbc0	80 fe		bra $cbc0		_error: bra _error
.cbc2					UnaryReturnTempStr:
.cbc2	a5 20		lda $20				lda 	zTempStr 					; copy temp string addr -> mantissa
.cbc4	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.cbc7	a5 21		lda $21				lda 	zTempStr+1
.cbc9	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.cbcc	a9 02		lda #$02			lda 	#2 							; set type to string
.cbce	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.cbd1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/65816.asm

.cbd2					MemRead:
.cbd2	8d 25 04	sta $0425			sta 	SignCount 					; save count
.cbd5	a0 00		ldy #$00			ldy 	#0 							; start from here
.cbd7	b7 1a		lda [$1a],y	_MLoop1:lda 	[zlTemp1],y 				; read the long address
.cbd9	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; copy into mantissa
.cbdc	c8		iny				iny 								; next to copy
.cbdd	e8		inx				inx
.cbde	cc 25 04	cpy $0425			cpy 	SignCount 					; do required # of bytes.
.cbe1	d0 f4		bne $cbd7			bne 	_MLoop1
.cbe3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.cbe4					CheckNextToken:
.cbe4	d1 16		cmp ($16),y			cmp 	(zCodePtr),y
.cbe6	d0 02		bne $cbea			bne 	CTFail 						; no, then fail
.cbe8	c8		iny				iny
.cbe9	60		rts				rts
.cbea					CTFail:
.cbea	80 fe		bra $cbea		_error: bra _error
.cbec					CheckNextRParen:
.cbec	b1 16		lda ($16),y			lda 	(zCodePtr),y
.cbee	c9 bc		cmp #$bc			cmp 	#token_rparen
.cbf0	d0 f8		bne $cbea			bne 	CTFail
.cbf2	c8		iny				iny
.cbf3	60		rts				rts
.cbf4					CheckNextComma:
.cbf4	b1 16		lda ($16),y			lda 	(zCodePtr),y
.cbf6	c9 bd		cmp #$bd			cmp 	#token_comma
.cbf8	d0 f0		bne $cbea			bne 	CTFail
.cbfa	c8		iny				iny
.cbfb	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.cbfc					AllocateTempString:
.cbfc	48		pha				pha 								; save required count.
.cbfd	a5 21		lda $21				lda 	zTempStr+1 					; check if initialised yet ?
.cbff	d0 0b		bne $cc0c			bne 	_ATSInitialised
.cc01	ad 26 04	lda $0426			lda 	StringPtr 					; set temporary string ptr 1 page below available
.cc04	85 20		sta $20				sta 	zTempStr					; space, this is for strings to be concreted.
.cc06	ad 27 04	lda $0427			lda 	StringPtr+1
.cc09	3a		dec a				dec 	a
.cc0a	85 21		sta $21				sta 	zTempStr+1
.cc0c					_ATSInitialised:
.cc0c	68		pla				pla 								; get required count back.
.cc0d	49 ff		eor #$ff			eor 	#$FF 						; negate 2's complement.
.cc0f	1a		inc a				inc 	a
.cc10	18		clc				clc
.cc11	65 20		adc $20				adc 	zTempStr 					; "add" to the temp string pointer
.cc13	85 20		sta $20				sta 	zTempStr
.cc15	a9 ff		lda #$ff			lda 	#$FF
.cc17	65 21		adc $21				adc 	zTempStr+1
.cc19	85 21		sta $21				sta 	zTempStr+1
.cc1b	a9 00		lda #$00			lda 	#0 							; clear temp string.
.cc1d	5a		phy				phy
.cc1e	a8		tay				tay
.cc1f	91 20		sta ($20),y			sta 	(zTempStr),y
.cc21	7a		ply				ply
.cc22	1a		inc a				inc 	a 							; reset the write index.
.cc23	8d 27 04	sta $0427			sta 	TempStringWriteIndex
.cc26	60		rts				rts
.cc27					WriteTempString:
.cc27	5a		phy				phy 								; save Y
.cc28	ac 27 04	ldy $0427			ldy 	TempStringWriteIndex	 	; write position.
.cc2b	91 20		sta ($20),y			sta 	(zTempStr),y 				; write character out.
.cc2d	ee 27 04	inc $0427			inc 	TempStringWriteIndex 		; increment the write position.
.cc30	98		tya				tya 								; unchanged Y is now length
.cc31	a0 00		ldy #$00			ldy 	#0
.cc33	91 20		sta ($20),y			sta 	(zTempStr),y
.cc35	7a		ply				ply 								; restore Y and exit
.cc36	60		rts				rts
.cc37					CreateTempStringCopy:
.cc37	da		phx				phx 								; save X
.cc38	b1 16		lda ($16),y			lda 	(zCodePtr),y
.cc3a	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.cc3b	20 fc cb	jsr $cbfc			jsr 	AllocateTempString 			; allocate memory for temporary string.
.cc3e	b1 16		lda ($16),y			lda 	(zCodePtr),y
.cc40	c8		iny				iny
.cc41	3a		dec a				dec 	a 							; make the actual length in charactes
.cc42	3a		dec a				dec 	a
.cc43	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.cc45	81 20		sta ($20,x)			sta 	(zTempStr,x)
.cc47	85 1a		sta $1a				sta 	zLTemp1 					; that's used as a count.
.cc49	09 00		ora #$00			ora 	#0 							; if zero already, exit
.cc4b	f0 0d		beq $cc5a			beq 	_CTSCExit
.cc4d					_CTSCLoop:
.cc4d	b1 16		lda ($16),y			lda 	(zCodePtr),y
.cc4f	c8		iny				iny
.cc50	5a		phy				phy 								; save in Y
.cc51	e8		inx				inx 								; bump index
.cc52	9b		txy				txy 								; index into Y
.cc53	91 20		sta ($20),y			sta 	(zTempStr),y 				; save at index
.cc55	7a		ply				ply 								; restore Y
.cc56	c6 1a		dec $1a				dec 	zLTemp1 					; do for each character
.cc58	d0 f3		bne $cc4d			bne 	_CTSCLoop
.cc5a					_CTSCExit:
.cc5a	fa		plx				plx 								; restore X
.cc5b	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.cc5c					MulInteger32:
.cc5c	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.cc5f	9d 14 03	sta $0314,x			sta 	XS3_Mantissa,x
.cc62	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.cc65	9d 15 03	sta $0315,x			sta 	XS3_Mantissa+1,x
.cc68	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.cc6b	9d 16 03	sta $0316,x			sta 	XS3_Mantissa+2,x
.cc6e	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.cc71	9d 17 03	sta $0317,x			sta 	XS3_Mantissa+3,x
.cc74	a9 00		lda #$00			lda 	#0
.cc76	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x 				; zero +0
.cc79	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.cc7c	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.cc7f	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.cc82					_BFMMultiply:
.cc82	bd 14 03	lda $0314,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.cc85	29 01		and #$01			and 	#1
.cc87	f0 03		beq $cc8c			beq 	_BFMNoAdd
.cc89	20 c1 c7	jsr $c7c1			jsr 	AddInteger32
.cc8c					_BFMNoAdd:
.cc8c	1e 0e 03	asl $030e,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.cc8f	3e 0f 03	rol $030f,x			rol 	XS2_Mantissa+1,x
.cc92	3e 10 03	rol $0310,x			rol 	XS2_Mantissa+2,x
.cc95	3e 11 03	rol $0311,x			rol 	XS2_Mantissa+3,x
.cc98	5e 17 03	lsr $0317,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.cc9b	7e 16 03	ror $0316,x			ror 	XS3_Mantissa+2,x
.cc9e	7e 15 03	ror $0315,x			ror 	XS3_Mantissa+1,x
.cca1	7e 14 03	ror $0314,x			ror 	XS3_Mantissa,x
.cca4	bd 14 03	lda $0314,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.cca7	1d 15 03	ora $0315,x			ora 	XS3_Mantissa+1,x
.ccaa	1d 16 03	ora $0316,x			ora 	XS3_Mantissa+2,x
.ccad	1d 17 03	ora $0317,x			ora 	XS3_Mantissa+3,x
.ccb0	d0 d0		bne $cc82			bne 	_BFMMultiply
.ccb2	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.ccb3					DivInteger32:
.ccb3	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; check for /0
.ccb6	1d 0f 03	ora $030f,x			ora 	XS2_Mantissa+1,x
.ccb9	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.ccbc	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.ccbf	d0 02		bne $ccc3			bne 	_BFDOkay
.ccc1	80 fe		bra $ccc1		_error: bra _error
.ccc3					_BFDOkay:
.ccc3	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.ccc5	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.ccc7	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.ccc9	85 1c		sta $1c				sta 	zLTemp1+2
.cccb	85 1d		sta $1d				sta 	zLTemp1+3
.cccd	8d 25 04	sta $0425			sta 	SignCount 					; Count of signs.
.ccd0	20 31 cd	jsr $cd31			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.ccd3	da		phx				phx
.ccd4	e8		inx				inx
.ccd5	e8		inx				inx
.ccd6	e8		inx				inx
.ccd7	e8		inx				inx
.ccd8	e8		inx				inx
.ccd9	e8		inx				inx
.ccda	20 31 cd	jsr $cd31			jsr 	CheckIntegerNegate
.ccdd	fa		plx				plx
.ccde	5a		phy				phy 								; Y is the counter
.ccdf	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.cce1					_BFDLoop:
.cce1	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.cce4	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.cce7	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.ccea	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.cced	26 1a		rol $1a				rol 	zLTemp1
.ccef	26 1b		rol $1b				rol 	zLTemp1+1
.ccf1	26 1c		rol $1c				rol 	zLTemp1+2
.ccf3	26 1d		rol $1d				rol 	zLTemp1+3
.ccf5	38		sec				sec
.ccf6	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.ccf8	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.ccfb	48		pha				pha
.ccfc	a5 1b		lda $1b				lda 	zLTemp1+1
.ccfe	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.cd01	48		pha				pha
.cd02	a5 1c		lda $1c				lda 	zLTemp1+2
.cd04	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.cd07	48		pha				pha
.cd08	a5 1d		lda $1d				lda 	zLTemp1+3
.cd0a	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.cd0d	90 15		bcc $cd24			bcc 	_BFDNoAdd
.cd0f	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.cd11	68		pla				pla
.cd12	85 1c		sta $1c				sta 	zLTemp1+2
.cd14	68		pla				pla
.cd15	85 1b		sta $1b				sta 	zLTemp1+1
.cd17	68		pla				pla
.cd18	85 1a		sta $1a				sta 	zLTemp1+0
.cd1a	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.cd1d	09 01		ora #$01			ora 	#1
.cd1f	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.cd22	80 03		bra $cd27			bra 	_BFDNext
.cd24					_BFDNoAdd:
.cd24	68		pla				pla 								; Throw away the intermediate calculations
.cd25	68		pla				pla
.cd26	68		pla				pla
.cd27					_BFDNext:
.cd27	88		dey				dey
.cd28	d0 b7		bne $cce1			bne 	_BFDLoop
.cd2a	7a		ply				ply 								; restore Y and exit
.cd2b	4e 25 04	lsr $0425			lsr 	SignCount 					; if sign count odd,
.cd2e	b0 07		bcs $cd37			bcs		IntegerNegateAlways 			; negate the result
.cd30	60		rts				rts
.cd31					CheckIntegerNegate:
.cd31	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.cd34	30 01		bmi $cd37			bmi 	IntegerNegateAlways
.cd36	60		rts				rts
.cd37					IntegerNegateAlways:
.cd37	ee 25 04	inc $0425			inc 	SignCount
.cd3a	38		sec				sec
.cd3b	a9 00		lda #$00			lda 	#0
.cd3d	fd 08 03	sbc $0308,x			sbc 	XS_Mantissa+0,x
.cd40	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.cd43	a9 00		lda #$00			lda 	#0
.cd45	fd 09 03	sbc $0309,x			sbc 	XS_Mantissa+1,x
.cd48	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.cd4b	a9 00		lda #$00			lda 	#0
.cd4d	fd 0a 03	sbc $030a,x			sbc 	XS_Mantissa+2,x
.cd50	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.cd53	a9 00		lda #$00			lda 	#0
.cd55	fd 0b 03	sbc $030b,x			sbc 	XS_Mantissa+3,x
.cd58	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.cd5b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.cd5c					INTToString:
.cd5c	48		pha				pha
.cd5d	5a		phy				phy
.cd5e	bd 0b 03	lda $030b,x			lda 		XS_Mantissa+3,x 		; check -ve
.cd61	10 08		bpl $cd6b			bpl 		_ITSNotMinus
.cd63	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.cd65	20 f8 cd	jsr $cdf8			jsr 		ITSOutputCharacter
.cd68	20 37 cd	jsr $cd37			jsr 		IntegerNegateAlways 	; negate the number.
.cd6b					_ITSNotMinus:
.cd6b	a9 00		lda #$00			lda 		#0 						; X is offset in table.
.cd6d	8d 21 04	sta $0421			sta 		NumSuppress 			; clear the suppression flag.
.cd70	a0 00		ldy #$00			ldy 		#0 						; Y is index into dword subtraction table.
.cd72					_ITSNextSubtractor:
.cd72	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.cd74	8d 22 04	sta $0422			sta 		NumConvCount
.cd77					_ITSSubtract:
.cd77	38		sec				sec
.cd78	bd 08 03	lda $0308,x			lda 		XS_Mantissa,x 			; subtract number and push on stack
.cd7b	f9 d4 cd	sbc $cdd4,y			sbc 		_ITSSubtractors+0,y
.cd7e	48		pha				pha
.cd7f	bd 09 03	lda $0309,x			lda 		XS_Mantissa+1,x
.cd82	f9 d5 cd	sbc $cdd5,y			sbc 		_ITSSubtractors+1,y
.cd85	48		pha				pha
.cd86	bd 0a 03	lda $030a,x			lda 		XS_Mantissa+2,x
.cd89	f9 d6 cd	sbc $cdd6,y			sbc 		_ITSSubtractors+2,y
.cd8c	48		pha				pha
.cd8d	bd 0b 03	lda $030b,x			lda 		XS_Mantissa+3,x
.cd90	f9 d7 cd	sbc $cdd7,y			sbc 		_ITSSubtractors+3,y
.cd93	90 14		bcc $cda9			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.cd95	9d 0b 03	sta $030b,x			sta 		XS_Mantissa+3,x 		; save subtract off stack
.cd98	68		pla				pla
.cd99	9d 0a 03	sta $030a,x			sta 		XS_Mantissa+2,x
.cd9c	68		pla				pla
.cd9d	9d 09 03	sta $0309,x			sta 		XS_Mantissa+1,x
.cda0	68		pla				pla
.cda1	9d 08 03	sta $0308,x			sta 		XS_Mantissa+0,x
.cda4	ee 22 04	inc $0422			inc 		NumConvCount 			; bump count.
.cda7	80 ce		bra $cd77			bra 		_ITSSubtract 			; go round again.
.cda9					_ITSCantSubtract:
.cda9	68		pla				pla 								; throw away interim answers
.cdaa	68		pla				pla
.cdab	68		pla				pla
.cdac	ad 22 04	lda $0422			lda 		NumConvCount 			; if not zero then no suppression check
.cdaf	c9 30		cmp #$30			cmp 		#"0"
.cdb1	d0 05		bne $cdb8			bne 		_ITSOutputDigit
.cdb3	ad 21 04	lda $0421			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.cdb6	10 09		bpl $cdc1			bpl 		_ITSGoNextSubtractor
.cdb8					_ITSOutputDigit:
.cdb8	ce 21 04	dec $0421			dec 		NumSuppress 			; suppression check will be non-zero.
.cdbb	ad 22 04	lda $0422			lda 		NumConvCount 			; count of subtractions
.cdbe	20 f8 cd	jsr $cdf8			jsr 		ITSOutputCharacter 		; output it.
.cdc1					_ITSGoNextSubtractor:
.cdc1	c8		iny				iny 								; next dword
.cdc2	c8		iny				iny
.cdc3	c8		iny				iny
.cdc4	c8		iny				iny
.cdc5	c0 24		cpy #$24			cpy 		#_ITSSubtractorsEnd-_ITSSubtractors
.cdc7	d0 a9		bne $cd72			bne 		_ITSNextSubtractor 		; do all the subtractors.
.cdc9	bd 08 03	lda $0308,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.cdcc	09 30		ora #$30			ora 		#"0"
.cdce	20 f8 cd	jsr $cdf8			jsr 		ITSOutputCharacter
.cdd1	7a		ply				ply 								; and exit
.cdd2	68		pla				pla
.cdd3	60		rts				rts
.cdd4					_ITSSubtractors:
>cdd4	00 ca 9a 3b					.dword 		1000000000
>cdd8	00 e1 f5 05					.dword 		100000000
>cddc	80 96 98 00					.dword 		10000000
>cde0	40 42 0f 00					.dword 		1000000
>cde4	a0 86 01 00					.dword 		100000
>cde8	10 27 00 00					.dword 		10000
>cdec	e8 03 00 00					.dword 		1000
>cdf0	64 00 00 00					.dword 		100
>cdf4	0a 00 00 00					.dword 		10
.cdf8					_ITSSubtractorsEnd:
.cdf8					ITSOutputCharacter:
.cdf8	48		pha				pha
.cdf9	da		phx				phx
.cdfa	ae 20 04	ldx $0420			ldx 	NumBufX 					; save digit
.cdfd	9d 00 04	sta $0400,x			sta 	Num_Buffer,x
.ce00	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.ce02	9d 01 04	sta $0401,x			sta 	Num_Buffer+1,x
.ce05	ee 20 04	inc $0420			inc 	NumBufX						; bump pointer.
.ce08	fa		plx				plx
.ce09	68		pla				pla
.ce0a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.ce0b					IntFromString:
.ce0b	a0 00		ldy #$00			ldy 	#0
.ce0d	8c 23 04	sty $0423			sty 	ExpTemp 					; this is the converted digit count.
.ce10					IntFromStringY:
.ce10	48		pha				pha
.ce11	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.ce13	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.ce16	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.ce19	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.ce1c	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.ce1f	a9 01		lda #$01			lda 	#1
.ce21	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.ce24					_IFSLoop:
.ce24	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.ce26	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.ce28	90 60		bcc $ce8a			bcc 	_IFSExit
.ce2a	c9 3a		cmp #$3a			cmp 	#"9"+1
.ce2c	b0 5c		bcs $ce8a			bcs 	_IFSExit
.ce2e	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.ce31	c9 0c		cmp #$0c			cmp 	#12
.ce33	b0 5f		bcs $ce94			bcs 	_IFSOverflow
.ce35	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.ce38	48		pha				pha
.ce39	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.ce3c	48		pha				pha
.ce3d	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.ce40	48		pha				pha
.ce41	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.ce44	48		pha				pha
.ce45	20 a9 ce	jsr $cea9			jsr 	IFSX1ShiftLeft 				; double
.ce48	20 a9 ce	jsr $cea9			jsr 	IFSX1ShiftLeft 				; x 4
.ce4b	18		clc				clc 								; add saved value x 5
.ce4c	68		pla				pla
.ce4d	7d 08 03	adc $0308,x			adc 	XS_Mantissa+0,x
.ce50	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.ce53	68		pla				pla
.ce54	7d 09 03	adc $0309,x			adc 	XS_Mantissa+1,x
.ce57	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.ce5a	68		pla				pla
.ce5b	7d 0a 03	adc $030a,x			adc 	XS_Mantissa+2,x
.ce5e	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.ce61	68		pla				pla
.ce62	7d 0b 03	adc $030b,x			adc 	XS_Mantissa+3,x
.ce65	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.ce68	20 a9 ce	jsr $cea9			jsr 	IFSX1ShiftLeft 				; x 10
.ce6b	ee 23 04	inc $0423			inc 	ExpTemp 					; bump count of digits processed.
.ce6e	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.ce70	29 0f		and #$0f			and 	#15
.ce72	c8		iny				iny
.ce73	7d 08 03	adc $0308,x			adc 	XS_Mantissa+0,x
.ce76	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.ce79	90 a9		bcc $ce24			bcc 	_IFSLoop
.ce7b	fe 09 03	inc $0309,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.ce7e	d0 a4		bne $ce24			bne 	_IFSLoop
.ce80	fe 0a 03	inc $030a,x			inc 	XS_Mantissa+2,x
.ce83	d0 9f		bne $ce24			bne 	_IFSLoop
.ce85	fe 0b 03	inc $030b,x			inc 	XS_Mantissa+3,x
.ce88	80 9a		bra $ce24			bra 	_IFSLoop
.ce8a					_IFSExit:
.ce8a	98		tya				tya 								; get offset
.ce8b					_IFSOkay:
.ce8b	38		sec				sec
.ce8c	ad 23 04	lda $0423			lda 	ExpTemp
.ce8f	f0 01		beq $ce92			beq 	_IFSSkipFail
.ce91	18		clc				clc
.ce92					_IFSSkipFail:
.ce92	68		pla				pla 								; and exit.
.ce93	60		rts				rts
.ce94					_IFSOverflow:
.ce94	20 2d c4	jsr $c42d			jsr 	ERR_Handler
>ce97	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>ce9f	20 6f 76 65 72 66 6c 6f 77 00
.cea9					IFSX1ShiftLeft:
.cea9	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x
.ceac	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.ceaf	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.ceb2	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.ceb5	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.ceb6					FPSubtract:
.ceb6	48		pha				pha
.ceb7	bd 13 03	lda $0313,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.ceba	49 80		eor #$80			eor 	#$80
.cebc	9d 13 03	sta $0313,x			sta 	XS2_Type,x
.cebf	68		pla				pla 								; --- and fall through ---
.cec0					FPAdd:
.cec0	48		pha				pha
.cec1	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.cec4	d0 05		bne $cecb			bne 	_FPA_NegativeLHS
.cec6	20 e8 ce	jsr $cee8			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.cec9	68		pla				pla
.ceca	60		rts				rts
.cecb					_FPA_NegativeLHS:
.cecb	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.cece	49 80		eor #$80			eor 	#$80
.ced0	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.ced3	bd 13 03	lda $0313,x			lda 	XS2_Type,x 					; flip the sign of B and add
.ced6	49 80		eor #$80			eor 	#$80
.ced8	9d 13 03	sta $0313,x			sta 	XS2_Type,x
.cedb	20 e8 ce	jsr $cee8			jsr 	FPAdd_Worker 				; do the add calculation.
.cede	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip sign of X1 back
.cee1	49 80		eor #$80			eor 	#$80
.cee3	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.cee6	68		pla				pla
.cee7	60		rts				rts
.cee8					FPAdd_Worker:
.cee8	3c 13 03	bit $0313,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.ceeb	70 08		bvs $cef5			bvs 	_FPAWExit 					; no change.
.ceed	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.cef0	50 07		bvc $cef9			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.cef2	20 7b d1	jsr $d17b			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.cef5					_FPAWExit:
.cef5	20 03 d2	jsr $d203			jsr 	FPUNormalise 				; normalise the result.
.cef8	60		rts				rts
.cef9					_FPAWMakeSame:
.cef9	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.cefc	38		sec				sec
.cefd	fd 12 03	sbc $0312,x			sbc	 	XS2_Exponent,x 				; using subtraction
.cf00	f0 1b		beq $cf1d			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.cf02	da		phx				phx 								; save X
.cf03	90 06		bcc $cf0b			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.cf05	e8		inx				inx
.cf06	e8		inx				inx
.cf07	e8		inx				inx
.cf08	e8		inx				inx
.cf09	e8		inx				inx
.cf0a	e8		inx				inx
.cf0b					_FPAWShiftA:
.cf0b	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x 				; so shift exponent up.
.cf0e	5e 0b 03	lsr $030b,x			lsr 	3+XS_Mantissa,x
.cf11	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.cf14	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.cf17	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.cf1a	fa		plx				plx 								; restore original X
.cf1b	80 dc		bra $cef9			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.cf1d					_FPAW_DoArithmetic:
.cf1d	3c 13 03	bit $0313,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.cf20	30 39		bmi $cf5b			bmi 	_FPAW_BNegative
.cf22	18		clc				clc
.cf23	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.cf26	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.cf29	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.cf2c	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.cf2f	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.cf32	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.cf35	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.cf38	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.cf3b	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.cf3e	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.cf41	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.cf44	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.cf47	90 ac		bcc $cef5			bcc 	_FPAWExit 					; no carry.
.cf49	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x 				; so shift exponent up.
.cf4c	38		sec				sec
.cf4d	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.cf50	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.cf53	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.cf56	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.cf59	80 9a		bra $cef5			bra 	_FPAWExit
.cf5b					_FPAW_BNegative:
.cf5b	38		sec				sec
.cf5c	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.cf5f	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.cf62	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.cf65	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.cf68	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.cf6b	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.cf6e	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.cf71	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.cf74	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.cf77	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.cf7a	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.cf7d	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.cf80	b0 0b		bcs $cf8d			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.cf82	20 a8 d1	jsr $d1a8			jsr 	FPUNegateInteger			; negate the mantissa
.cf85	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip result sign
.cf88	49 80		eor #$80			eor 	#$80
.cf8a	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.cf8d					_FPAWGoExit:
.cf8d	4c f5 ce	jmp $cef5			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.cf90					FPD_IsDivZero:
.cf90	80 fe		bra $cf90		_error: bra _error
.cf92					FPDivide:
.cf92	48		pha				pha
.cf93	5a		phy				phy
.cf94	3c 13 03	bit $0313,x			bit 	XS2_Type,x 					; check if division by zero
.cf97	70 f7		bvs $cf90			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.cf99	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.cf9c	f0 03		beq $cfa1			beq 	_FPDCalculateExp
.cf9e					_FPD_Exit:
.cf9e	7a		ply				ply
.cf9f	68		pla				pla
.cfa0	60		rts				rts
.cfa1					_FPDCalculateExp:
.cfa1	bd 12 03	lda $0312,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.cfa4	49 ff		eor #$ff			eor 	#$FF
.cfa6	1a		inc a				inc 	a
.cfa7	9d 12 03	sta $0312,x			sta 	XS2_Exponent,x
.cfaa	20 9e d0	jsr $d09e			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.cfad	18		clc				clc 	 							; add 1 to the resulting exponent
.cfae	69 01		adc #$01			adc 	#1
.cfb0	b0 65		bcs $d017			bcs 	_FPD_Overflow 				; which can overflow.
.cfb2	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.cfb5	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.cfb7	85 1a		sta $1a				sta 	zLTemp1+0
.cfb9	85 1b		sta $1b				sta 	zLTemp1+1
.cfbb	85 1c		sta $1c				sta 	zLTemp1+2
.cfbd	85 1d		sta $1d				sta 	zLTemp1+3
.cfbf	a0 20		ldy #$20			ldy 	#32 						; times round.
.cfc1					_FPD_Loop:
.cfc1	38		sec				sec 								; calculate X1-X2 stacking result because we might
.cfc2	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; not save it.
.cfc5	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa,x
.cfc8	48		pha				pha
.cfc9	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.cfcc	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.cfcf	48		pha				pha
.cfd0	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.cfd3	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.cfd6	48		pha				pha
.cfd7	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.cfda	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.cfdd	90 17		bcc $cff6			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.cfdf	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x 			; save results out to A
.cfe2	68		pla				pla
.cfe3	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.cfe6	68		pla				pla
.cfe7	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.cfea	68		pla				pla
.cfeb	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.cfee	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.cff0	09 80		ora #$80			ora 	#$80
.cff2	85 1d		sta $1d				sta 	zLTemp1+3
.cff4	80 03		bra $cff9			bra 	_FPD_Rotates
.cff6					_FPD_NoSubtract:
.cff6	68		pla				pla 								; throw away unwanted results
.cff7	68		pla				pla
.cff8	68		pla				pla
.cff9					_FPD_Rotates:
.cff9	5e 11 03	lsr $0311,x			lsr 	3+XS2_Mantissa,x
.cffc	7e 10 03	ror $0310,x			ror 	2+XS2_Mantissa,x
.cfff	7e 0f 03	ror $030f,x			ror 	1+XS2_Mantissa,x
.d002	7e 0e 03	ror $030e,x			ror 	0+XS2_Mantissa,x
.d005	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.d007	26 1b		rol $1b				rol 	zLTemp1+1
.d009	26 1c		rol $1c				rol 	zLTemp1+2
.d00b	26 1d		rol $1d				rol 	zLTemp1+3
.d00d	90 02		bcc $d011			bcc 	_FPD_NoCarry
.d00f	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.d011					_FPD_NoCarry:
.d011	88		dey				dey 								; do 32 times
.d012	d0 ad		bne $cfc1			bne 	_FPD_Loop
.d014	4c 7b d0	jmp $d07b			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.d017					_FPD_Overflow:
.d017	4c 78 d2	jmp $d278			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.d01a					FPMultiply:
.d01a	48		pha				pha
.d01b	5a		phy				phy
.d01c	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.d01f	70 08		bvs $d029			bvs 	_FPM_Exit
.d021	3c 13 03	bit $0313,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.d024	50 06		bvc $d02c			bvc 	_FPM_CalcExponent
.d026	20 7b d1	jsr $d17b			jsr 	FPUCopyX2ToX1
.d029					_FPM_Exit:
.d029	7a		ply				ply
.d02a	68		pla				pla
.d02b	60		rts				rts
.d02c					_FPM_CalcExponent:
.d02c	18		clc				clc
.d02d	20 9e d0	jsr $d09e			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.d030	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x 				; save the result.
.d033	a9 00		lda #$00			lda 	#0
.d035	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.d037	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.d039	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.d03b	85 1d		sta $1d				sta 	zLTemp1+3
.d03d	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.d03f					_FPM_Loop:
.d03f	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x				; check LSB of long product
.d042	29 01		and #$01			and 	#1
.d044	18		clc				clc 								; clear carry for the long rotate.
.d045	f0 1d		beq $d064			beq 	_FPM_NoAddition
.d047	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.d048	a5 1a		lda $1a				lda 	zLTemp1+0
.d04a	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.d04d	85 1a		sta $1a				sta 	zLTemp1+0
.d04f	a5 1b		lda $1b				lda 	zLTemp1+1
.d051	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.d054	85 1b		sta $1b				sta 	zLTemp1+1
.d056	a5 1c		lda $1c				lda 	zLTemp1+2
.d058	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.d05b	85 1c		sta $1c				sta 	zLTemp1+2
.d05d	a5 1d		lda $1d				lda 	zLTemp1+3
.d05f	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.d062	85 1d		sta $1d				sta 	zLTemp1+3
.d064					_FPM_NoAddition:
.d064	66 1d		ror $1d				ror 	3+zLTemp1
.d066	66 1c		ror $1c				ror 	2+zLTemp1
.d068	66 1b		ror $1b				ror 	1+zLTemp1
.d06a	66 1a		ror $1a				ror 	0+zLTemp1
.d06c	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.d06f	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.d072	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.d075	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.d078	88		dey				dey
.d079	d0 c4		bne $d03f			bne 	_FPM_Loop 					; do this 32 times.
.d07b					FPM_CopySignNormalize:
.d07b	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.d07d	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.d080	a5 1b		lda $1b				lda 	zLTemp1+1
.d082	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.d085	a5 1c		lda $1c				lda 	zLTemp1+2
.d087	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.d08a	a5 1d		lda $1d				lda 	zLTemp1+3
.d08c	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.d08f	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; sign is xor of signs
.d092	5d 13 03	eor $0313,x			eor 	XS2_Type,x
.d095	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.d098	20 03 d2	jsr $d203			jsr 	FPUNormalise 				; normalise and exit.
.d09b	7a		ply				ply
.d09c	68		pla				pla
.d09d	60		rts				rts
.d09e					FPCalculateExponent:
.d09e	18		clc				clc
.d09f	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.d0a2	7d 12 03	adc $0312,x			adc 	XS2_Exponent,x
.d0a5	b0 08		bcs $d0af			bcs 	_FPCECarry 					; carry out ?
.d0a7	10 03		bpl $d0ac			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.d0a9	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.d0ab	60		rts				rts
.d0ac					_FPCEExpZero:
.d0ac	a9 00		lda #$00			lda 	#0
.d0ae	60		rts				rts
.d0af					_FPCECarry:
.d0af	30 03		bmi $d0b4			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.d0b1	09 80		ora #$80			ora 	#$80 						; put in right range
.d0b3	60		rts				rts
.d0b4					_FPCEOverflow:
.d0b4	4c 78 d2	jmp $d278			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.d0b7					FPFractionalPart:
.d0b7	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.d0ba	38		sec				sec 								; this flag tells us to keep the fractional part
.d0bb	30 0f		bmi $d0cc			bmi 	FPGetPart
.d0bd	60		rts				rts
.d0be					FPIntegerPart:
.d0be	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.d0c1	18		clc				clc 								; this flag says keep the integer part.
.d0c2	30 08		bmi $d0cc			bmi 	FPGetPart 					; -ve exponents are 0..127
.d0c4	48		pha				pha
.d0c5	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.d0c7	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.d0ca	68		pla				pla
.d0cb	60		rts				rts
.d0cc					FPGetPart:
.d0cc	48		pha				pha
.d0cd	5a		phy				phy 								; save Y
.d0ce	08		php				php 								; save action
.d0cf	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.d0d2	70 62		bvs $d136			bvs 	_FPGP_Exit 					; then do nothing.
.d0d4	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.d0d6	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.d0d8	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.d0da	85 1c		sta $1c				sta 	zLTemp1+2
.d0dc	85 1d		sta $1d				sta 	zLTemp1+3
.d0de	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x				; the number of shifts.
.d0e1	38		sec				sec
.d0e2	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.d0e4	f0 12		beq $d0f8			beq 	_FPGP_NoShift 				; ... if any
.d0e6	c9 20		cmp #$20			cmp 	#32
.d0e8	90 02		bcc $d0ec			bcc 	_FPGP_NotMax
.d0ea	a9 20		lda #$20			lda 	#32 						; max of 32.
.d0ec					_FPGP_NotMax:
.d0ec	a8		tay				tay 								; Y is the mask shift count.
.d0ed					_FPGP_ShiftMask:
.d0ed	46 1d		lsr $1d				lsr 	3+zLTemp1
.d0ef	66 1c		ror $1c				ror 	2+zLTemp1
.d0f1	66 1b		ror $1b				ror 	1+zLTemp1
.d0f3	66 1a		ror $1a				ror 	0+zLTemp1
.d0f5	88		dey				dey
.d0f6	d0 f5		bne $d0ed			bne 	_FPGP_ShiftMask
.d0f8					_FPGP_NoShift:
.d0f8	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.d0fa	8e 23 04	stx $0423			stx 	ExpTemp						; save X
.d0fd					_FPGP_MaskLoop:
.d0fd	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.d100	28		plp				plp 								; if CC we keep the top part, so we
.d101	08		php				php		 							; flip the mask.
.d102	b0 02		bcs $d106			bcs		_FPGP_NoFlip
.d104	49 ff		eor #$ff			eor 	#$FF
.d106					_FPGP_NoFlip:
.d106	3d 08 03	and $0308,x			and 	XS_Mantissa,x 				; and into the mantissa.
.d109	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.d10c	e8		inx				inx
.d10d	c8		iny				iny
.d10e	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.d110	d0 eb		bne $d0fd			bne 	_FPGP_MaskLoop
.d112	ae 23 04	ldx $0423			ldx 	ExpTemp						; restore X
.d115	28		plp				plp
.d116	08		php				php 								; get action flag on the stack
.d117	90 05		bcc $d11e			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.d119	a9 00		lda #$00			lda 	#0
.d11b	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.d11e					_FPGP_NotFractional:
.d11e	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 						; check if \1 zero
.d121	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.d124	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.d127	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.d12a	f0 05		beq $d131			beq 	_FPGP_Zero 					; if zero, return zero
.d12c	20 03 d2	jsr $d203			jsr 	FPUNormalise
.d12f	80 05		bra $d136			bra 	_FPGP_Exit 					; and exit
.d131					_FPGP_Zero:
.d131	a9 40		lda #$40			lda 	#$40 						; set zero flag
.d133	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.d136					_FPGP_Exit:
.d136	68		pla				pla 								; throw saved action flag.
.d137	7a		ply				ply
.d138	68		pla				pla
.d139	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.d13a					FPCompare:
.d13a	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.d13d	48		pha				pha
.d13e	bd 12 03	lda $0312,x			lda 	XS2_Exponent,x
.d141	48		pha				pha
.d142	20 b6 ce	jsr $ceb6			jsr 	FPSubtract 					; calculate X1-X2
.d145	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.d148	70 2c		bvs $d176			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.d14a	68		pla				pla
.d14b	8d 23 04	sta $0423			sta 	ExpTemp						; save first exponent in temporary reg.
.d14e	68		pla				pla
.d14f	38		sec				sec
.d150	ed 23 04	sbc $0423			sbc 	ExpTemp 					; calculate AX-BX
.d153	70 15		bvs $d16a			bvs 	_FPCNotEqual				; overflow, can't be equal.
.d155	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.d156	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.d158	b0 10		bcs $d16a			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.d15a	38		sec				sec
.d15b	ad 23 04	lda $0423			lda 	ExpTemp 					; get one of the exponents back.
.d15e	e9 18		sbc #$18			sbc 	#24 						; allow for 2^24 error, relatively.
.d160	b0 02		bcs $d164			bcs 	_FPCNotRange 				; keep in range.
.d162	a9 01		lda #$01			lda 	#1
.d164					_FPCNotRange:
.d164	38		sec				sec
.d165	fd 0c 03	sbc $030c,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.d168	b0 0e		bcs $d178			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.d16a					_FPCNotEqual:
.d16a	bd 0d 03	lda $030d,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.d16d	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.d16f	f0 02		beq $d173			beq 	_FPCNE2
.d171	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.d173	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.d174	80 04		bra $d17a			bra 	_FPCExit
.d176					_FPCPullZero:
.d176	68		pla				pla 								; throw saved exponents
.d177	68		pla				pla
.d178					_FPCZero:
.d178	a9 00		lda #$00			lda 	#0 							; and return zero
.d17a					_FPCExit:
.d17a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.d17b					FPUCopyX2ToX1:
.d17b	48		pha				pha
.d17c	da		phx				phx
.d17d	5a		phy				phy
.d17e	a0 08		ldy #$08			ldy 	#8
.d180	bd 0e 03	lda $030e,x	_FPUC21:lda 	XS2_Mantissa,x
.d183	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.d186	e8		inx				inx
.d187	88		dey				dey
.d188	10 f6		bpl $d180			bpl 	_FPUC21
.d18a	7a		ply				ply
.d18b	fa		plx				plx
.d18c	68		pla				pla
.d18d	60		rts				rts
.d18e					FPUSetInteger:
.d18e	48		pha				pha
.d18f	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.d192	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.d194	10 02		bpl $d198			bpl 	_FPUSIExtend
.d196	a9 ff		lda #$ff			lda 	#$FF
.d198					_FPUSIExtend:
.d198	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.d19b	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.d19e	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.d1a1	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.d1a3	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.d1a6	68		pla				pla
.d1a7	60		rts				rts
.d1a8					FPUNegateInteger:
.d1a8	48		pha				pha
.d1a9	38		sec				sec
.d1aa	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.d1ac	fd 08 03	sbc $0308,x			sbc 	XS_Mantissa+0,x
.d1af	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.d1b2	a9 00		lda #$00			lda 	#0
.d1b4	fd 09 03	sbc $0309,x			sbc 	XS_Mantissa+1,x
.d1b7	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.d1ba	a9 00		lda #$00			lda 	#0
.d1bc	fd 0a 03	sbc $030a,x			sbc 	XS_Mantissa+2,x
.d1bf	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.d1c2	a9 00		lda #$00			lda 	#0
.d1c4	fd 0b 03	sbc $030b,x			sbc 	XS_Mantissa+3,x
.d1c7	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.d1ca	68		pla				pla
.d1cb	60		rts				rts
.d1cc					FPUToFloat:
.d1cc	48		pha				pha
.d1cd	bd 0d 03	lda $030d,x			lda 	XS_Type,x					; exit if already float.
.d1d0	29 0f		and #$0f			and 	#$0F
.d1d2	f0 2d		beq $d201			beq 	_FPUFExit
.d1d4	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.d1d6	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.d1d9	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.d1db	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x 				; x mantissa.
.d1de	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.d1e1	10 08		bpl $d1eb			bpl		_FPUFPositive
.d1e3	20 a8 d1	jsr $d1a8			jsr 	FPUNegateInteger 			; negate the mantissa
.d1e6	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.d1e8	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.d1eb					_FPUFPositive:
.d1eb	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.d1ee	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.d1f1	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.d1f4	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.d1f7	d0 05		bne $d1fe			bne 	_FPUFNonZero
.d1f9	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.d1fb	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.d1fe					_FPUFNonZero:
.d1fe	20 03 d2	jsr $d203			jsr 	FPUNormalise 				; normalise the floating point.
.d201					_FPUFExit:
.d201	68		pla				pla
.d202	60		rts				rts
.d203					FPUNormalise:
.d203	48		pha				pha
.d204	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.d207	70 20		bvs $d229			bvs 	_FPUNExit
.d209	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.d20c	f0 16		beq $d224			beq 	_FPUNSetZero
.d20e					_FPUNLoop:
.d20e	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.d211	30 16		bmi $d229			bmi 	_FPUNExit 					; if so, we are normalised.
.d213	1e 08 03	asl $0308,x			asl 	0+XS_Mantissa+0,x
.d216	3e 09 03	rol $0309,x			rol 	1+XS_Mantissa+0,x
.d219	3e 0a 03	rol $030a,x			rol 	2+XS_Mantissa+0,x
.d21c	3e 0b 03	rol $030b,x			rol 	3+XS_Mantissa+0,x
.d21f	de 0c 03	dec $030c,x			dec 	XS_Exponent,x 				; decrement exponent
.d222	d0 ea		bne $d20e			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.d224					_FPUNSetZero:
.d224	a9 40		lda #$40			lda 	#$40
.d226	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; the result is now zero.
.d229					_FPUNExit:
.d229	68		pla				pla
.d22a	60		rts				rts
.d22b					FPUToInteger:
.d22b	48		pha				pha
.d22c	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; if already integer, exit
.d22f	29 01		and #$01			and 	#1
.d231	d0 3e		bne $d271			bne 	_FPUTOI_Exit
.d233	3c 0d 03	bit $030d,x			bit 	XS_Type,x					; if zero, return zero.
.d236	70 2b		bvs $d263			bvs 	_FPUTOI_Zero
.d238	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.d23b	10 26		bpl $d263			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.d23d	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.d23f	b0 37		bcs $d278			bcs 	FP_Overflow
.d241					_FPUToIToInteger:
.d241	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.d244	c9 a0		cmp #$a0			cmp 	#128+32
.d246	f0 11		beq $d259			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.d248	fe 0c 03	inc $030c,x			inc 	XS_Exponent,X 				; increment Exponent
.d24b	5e 0b 03	lsr $030b,x			lsr 	3+XS_Mantissa,x
.d24e	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.d251	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.d254	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.d257	80 e8		bra $d241			bra 	_FPUToIToInteger 			; keep going.
.d259					_FPUToICheckSign:
.d259	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; check sign
.d25c	10 13		bpl $d271			bpl 	_FPUToI_Exit 				; exit if unsigned.
.d25e	20 a8 d1	jsr $d1a8			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.d261	80 0e		bra $d271			bra 	_FPUTOI_Exit
.d263					_FPUTOI_Zero:
.d263	a9 00		lda #$00			lda 	#0 							; return zero integer.
.d265	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.d268	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.d26b	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.d26e	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.d271					_FPUToI_Exit:
.d271	a9 01		lda #$01			lda 	#1 							; set type to integer
.d273	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.d276	68		pla				pla
.d277	60		rts				rts
.d278					FP_Overflow:
.d278	80 fe		bra $d278		_error: bra _error
.d27a					FPUTimes10:
.d27a	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.d27d	85 1a		sta $1a				sta 	ZLTemp1+0
.d27f	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.d282	85 1b		sta $1b				sta 	ZLTemp1+1
.d284	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.d287	85 1c		sta $1c				sta 	ZLTemp1+2
.d289	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.d28c	85 1d		sta $1d				sta 	ZLTemp1+3
.d28e	20 d2 d2	jsr $d2d2			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.d291	20 d2 d2	jsr $d2d2			jsr 	_FPUT_LSR_ZLTemp1
.d294	18		clc				clc
.d295	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.d298	65 1a		adc $1a				adc 	ZLTemp1+0
.d29a	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.d29d	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.d2a0	65 1b		adc $1b				adc 	ZLTemp1+1
.d2a2	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.d2a5	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.d2a8	65 1c		adc $1c				adc 	ZLTemp1+2
.d2aa	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.d2ad	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.d2b0	65 1d		adc $1d				adc 	ZLTemp1+3
.d2b2	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.d2b5	90 0f		bcc $d2c6			bcc 	_FPUTimes10
.d2b7	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.d2ba	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.d2bd	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.d2c0	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.d2c3	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x				; fix exponent
.d2c6					_FPUTimes10:
.d2c6	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.d2c9	18		clc				clc
.d2ca	69 03		adc #$03			adc 	#3
.d2cc	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.d2cf	b0 a7		bcs $d278			bcs 	FP_Overflow 				; error
.d2d1	60		rts				rts
.d2d2					_FPUT_LSR_ZLTemp1:
.d2d2	46 1d		lsr $1d				lsr 	ZLTemp1+3
.d2d4	66 1c		ror $1c				ror 	ZLTemp1+2
.d2d6	66 1b		ror $1b				ror 	ZLTemp1+1
.d2d8	66 1a		ror $1a				ror 	ZLTemp1+0
.d2da	60		rts				rts
.d2db					FPUScale10A:
.d2db	5a		phy				phy
.d2dc	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.d2de	f0 3d		beq $d31d			beq 	_FPUScaleExit
.d2e0	da		phx				phx 								; save X
.d2e1	e8		inx				inx
.d2e2	e8		inx				inx
.d2e3	e8		inx				inx
.d2e4	e8		inx				inx
.d2e5	e8		inx				inx
.d2e6	e8		inx				inx
.d2e7	a8		tay				tay 								; save power scalar in Y.
.d2e8	a9 00		lda #$00			lda 	#0
.d2ea	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.d2ed	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.d2f0	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.d2f3	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.d2f6	a9 80		lda #$80			lda 	#$80
.d2f8	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.d2fb	a9 81		lda #$81			lda 	#$81
.d2fd	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.d300	5a		phy				phy 								; save 10^n on stack.
.d301	c0 00		cpy #$00			cpy 	#0
.d303	10 05		bpl $d30a			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.d305	98		tya				tya
.d306	49 ff		eor #$ff			eor 	#$FF
.d308	1a		inc a				inc 	a
.d309	a8		tay				tay
.d30a					_FPUSAbs:
.d30a	20 7a d2	jsr $d27a			jsr 	FPUTimes10
.d30d	88		dey				dey
.d30e	d0 fa		bne $d30a			bne 	_FPUSAbs 					; tos is now 10^|AC|
.d310	68		pla				pla 								; restore count in A
.d311	fa		plx				plx 								; restore X pointing to number to scale.
.d312	0a		asl a				asl 	a
.d313	b0 05		bcs $d31a			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.d315	20 1a d0	jsr $d01a			jsr 	FPMultiply 					; if clear multiply.
.d318	80 03		bra $d31d			bra		_FPUScaleExit
.d31a					_FPUSDivide:
.d31a	20 92 cf	jsr $cf92			jsr 	FPDivide
.d31d					_FPUScaleExit:
.d31d	7a		ply				ply
.d31e	60		rts				rts
.d31f					FPUCopyToNext:
.d31f	a0 06		ldy #$06			ldy 		#6
.d321	da		phx				phx
.d322					_FPUCopy1:
.d322	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x
.d325	9d 0e 03	sta $030e,x			sta 	XS2_Mantissa,x
.d328	e8		inx				inx
.d329	88		dey				dey
.d32a	d0 f6		bne $d322			bne 	_FPUCopy1
.d32c	fa		plx				plx
.d32d	60		rts				rts
.d32e					FPUCopyFromNext:
.d32e	a0 06		ldy #$06			ldy 		#6
.d330	da		phx				phx
.d331					_FPUCopy1:
.d331	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa,x
.d334	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.d337	e8		inx				inx
.d338	88		dey				dey
.d339	d0 f6		bne $d331			bne 	_FPUCopy1
.d33b	fa		plx				plx
.d33c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.d33d					FPToString:
.d33d	48		pha				pha
.d33e	5a		phy				phy
.d33f	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; check zero flag
.d342	50 0a		bvc $d34e			bvc 		_FPTSIsFloat 			; if zero,
.d344					_FPTSZero:
.d344	a9 30		lda #$30			lda 		#"0"
.d346	20 f8 cd	jsr $cdf8			jsr 		ITSOutputCharacter
.d349					_FPTSExit:
.d349	7a		ply				ply
.d34a	68		pla				pla
.d34b	60		rts				rts
.d34c	80 fb		bra $d349			bra 		_FPTSExit
.d34e					_FPTSIsFloat:
.d34e	bd 0d 03	lda $030d,x			lda 		XS_Type,x 				; is it signed ?
.d351	10 0a		bpl $d35d			bpl 		_FPTSNotSigned
.d353	a9 00		lda #$00			lda 		#0 						; clear sign flag
.d355	9d 0d 03	sta $030d,x			sta 		XS_Type,x
.d358	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.d35a	20 f8 cd	jsr $cdf8			jsr 		ITSOutputCharacter
.d35d					_FPTSNotSigned:
.d35d	bd 0c 03	lda $030c,x			lda 		XS_Exponent,x
.d360	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.d362	b0 09		bcs $d36d			bcs 		_FPTSExponent
.d364	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.d366	90 05		bcc $d36d			bcc 		_FPTSExponent 			;
.d368					_FPTSStandard:
.d368	20 b1 d3	jsr $d3b1			jsr 		FPTOutputBody 			; output the body.
.d36b	80 dc		bra $d349			bra 		_FPTSExit
.d36d					_FPTSExponent:
.d36d	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.d36f	8d 24 04	sta $0424			sta 		ExpCount
.d372					_FPTSExponentLoop:
.d372	bd 0c 03	lda $030c,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.d375	10 0e		bpl $d385			bpl 		_FPTSTimes
.d377	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.d379	90 14		bcc $d38f			bcc 		_FPTSScaledToExp
.d37b	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.d37d	20 db d2	jsr $d2db			jsr 		FPUScale10A
.d380	ee 24 04	inc $0424			inc 		ExpCount
.d383	80 ed		bra $d372			bra 		_FPTSExponentLoop
.d385					_FPTSTimes:
.d385	a9 01		lda #$01			lda 		#1
.d387	20 db d2	jsr $d2db			jsr 		FPUScale10A
.d38a	ce 24 04	dec $0424			dec 		ExpCount
.d38d	80 e3		bra $d372			bra 		_FPTSExponentLoop
.d38f					_FPTSScaledToExp:
.d38f	20 b1 d3	jsr $d3b1			jsr 		FPTOutputBody 			; output the body.
.d392	a9 65		lda #$65			lda 		#"e"					; output E
.d394	20 f8 cd	jsr $cdf8			jsr 		ITSOutputCharacter
.d397	ad 24 04	lda $0424			lda 		ExpCount 				; get the exponent
.d39a	9d 08 03	sta $0308,x			sta 		XS_Mantissa,x
.d39d	29 80		and #$80			and 		#$80 					; sign extend it
.d39f	f0 02		beq $d3a3			beq 		_FPTSSExt
.d3a1	a9 ff		lda #$ff			lda 		#$FF
.d3a3					_FPTSSExt:
.d3a3	9d 09 03	sta $0309,x			sta 		XS_Mantissa+1,x
.d3a6	9d 0a 03	sta $030a,x			sta 		XS_Mantissa+2,x
.d3a9	9d 0b 03	sta $030b,x			sta 		XS_Mantissa+3,x
.d3ac	20 5c cd	jsr $cd5c			jsr 		INTToString 			; output the exponent.
.d3af	80 98		bra $d349			bra			_FPTSExit 				; and exit.
.d3b1					FPTOutputBody:
.d3b1	20 1f d3	jsr $d31f			jsr 		FPUCopyToNext 			; copy to next slot.
.d3b4	20 2b d2	jsr $d22b			jsr 		FPUToInteger 			; convert to an integer
.d3b7	20 5c cd	jsr $cd5c			jsr 		INTToString 			; output the main integer part.
.d3ba	20 2e d3	jsr $d32e			jsr 		FPUCopyFromNext 		; get the fractional part back.
.d3bd	20 b7 d0	jsr $d0b7			jsr 		FPFractionalPart 		; get the decimal part.
.d3c0	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; any fractional part.
.d3c3	70 3e		bvs $d403			bvs 		_FPTOExit 				; if not, exit now.
.d3c5	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.d3c7	20 f8 cd	jsr $cdf8			jsr 		ITSOutputCharacter
.d3ca					_FPOutLoop:
.d3ca	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; finally reached zero.
.d3cd	70 1e		bvs $d3ed			bvs 		_FPStripZeros 			; strip trailing zeros
.d3cf	20 7a d2	jsr $d27a			jsr 		FPUTimes10 				; multiply by 10
.d3d2	20 1f d3	jsr $d31f			jsr 		FPUCopyToNext			; copy to next slot.
.d3d5	20 2b d2	jsr $d22b			jsr 		FPUToInteger 			; convert to integer
.d3d8	bd 08 03	lda $0308,x			lda 		XS_Mantissa+0,x 		; print digit.
.d3db	09 30		ora #$30			ora 		#"0"
.d3dd	20 f8 cd	jsr $cdf8			jsr 		ITSOutputCharacter
.d3e0	20 2e d3	jsr $d32e			jsr 		FPUCopyFromNext 		; get it back
.d3e3	20 b7 d0	jsr $d0b7			jsr 		FPFractionalPart 		; get fractional part
.d3e6	ad 20 04	lda $0420			lda 		NumBufX 				; done 11 characters yet ?
.d3e9	c9 0b		cmp #$0b			cmp 	 	#11
.d3eb	90 dd		bcc $d3ca			bcc 		_FPOutLoop 				; if so, keep going till zero.
.d3ed					_FPStripZeros:
.d3ed	ac 20 04	ldy $0420			ldy 		NumBufX 				; strip trailing zeros.
.d3f0					_FPStripLoop:
.d3f0	88		dey				dey 								; back one, if at start then no strip
.d3f1	f0 10		beq $d403			beq 		_FPToExit
.d3f3	b9 00 04	lda $0400,y			lda 		Num_Buffer,y 			; keep going if "0"
.d3f6	c9 30		cmp #$30			cmp 		#"0"
.d3f8	f0 f6		beq $d3f0			beq 		_FPStripLoop
.d3fa	c8		iny				iny
.d3fb	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.d3fd	99 00 04	sta $0400,y			sta 		Num_Buffer,y
.d400	8c 20 04	sty $0420			sty 		NumBufX 				; update position.
.d403					_FPTOExit:
.d403	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.d404					FPFromString:
.d404	48		pha				pha 								; push A
.d405	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.d407	c9 2e		cmp #$2e			cmp 	#"."
.d409	f0 03		beq $d40e			beq	 	_FPFIsDecimal
.d40b	4c 71 d4	jmp $d471			jmp 	_FPFNotDecimal
.d40e					_FPFIsDecimal:
.d40e	c8		iny				iny 								; consume the decimal.
.d40f	20 cc d1	jsr $d1cc			jsr 	FPUToFloat 					; convert the integer to float.
.d412	da		phx				phx 								; save X.
.d413	5a		phy				phy 								; save decimal start position
.d414	e8		inx				inx
.d415	e8		inx				inx
.d416	e8		inx				inx
.d417	e8		inx				inx
.d418	e8		inx				inx
.d419	e8		inx				inx
.d41a	20 10 ce	jsr $ce10			jsr 	INTFromStringY 				; get the part after the DP.
.d41d	20 cc d1	jsr $d1cc			jsr 	FPUToFloat 					; convert that to a float.
.d420	68		pla				pla 								; calculate - chars consumed.
.d421	8c 23 04	sty $0423			sty 	ExpTemp
.d424	38		sec				sec
.d425	ed 23 04	sbc $0423			sbc 	ExpTemp 					; this is the shift amount
.d428	20 db d2	jsr $d2db			jsr 	FPUScale10A 				; scale it by 10^AC
.d42b	fa		plx				plx 								; restore original X
.d42c	20 c0 ce	jsr $cec0			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.d42f	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.d431	c9 45		cmp #$45			cmp 	#"E"
.d433	f0 04		beq $d439			beq 	_FPFExponent
.d435	c9 65		cmp #$65			cmp 	#"e"
.d437	d0 38		bne $d471			bne 	_FPFNotDecimal 				; no, then exit normally.
.d439					_FPFExponent:
.d439	c8		iny				iny 								; skip over E symbol.
.d43a	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.d43c	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.d43e	d0 01		bne $d441			bne 	_FPFGotSign
.d440	c8		iny				iny 								; if it was - skip over it.
.d441					_FPFGotSign:
.d441	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.d442	da		phx				phx
.d443	e8		inx				inx
.d444	e8		inx				inx
.d445	e8		inx				inx
.d446	e8		inx				inx
.d447	e8		inx				inx
.d448	e8		inx				inx
.d449	20 10 ce	jsr $ce10			jsr 	INTFromStringY 				; get the exponent
.d44c	fa		plx				plx 								; restore X.
.d44d	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.d450	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.d453	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.d456	d0 1b		bne $d473			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.d458	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.d45b	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.d45d	b0 14		bcs $d473			bcs 	_FPFXOverflow
.d45f	68		pla				pla 								; get direction
.d460	d0 09		bne $d46b			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.d462	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.d465	49 ff		eor #$ff			eor 	#$FF
.d467	1a		inc a				inc 	a
.d468	9d 0e 03	sta $030e,x			sta 	XS2_Mantissa+0,x
.d46b					_FPFXScale:
.d46b	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.d46e	20 db d2	jsr $d2db			jsr 	FPUScale10A 				; scale by the exponent.
.d471					_FPFNotDecimal:
.d471	68		pla				pla
.d472	60		rts				rts
.d473					_FPFXOverflow:
.d473	20 2d c4	jsr $c42d			jsr 	ERR_Handler
>d476	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>d47e	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.d485					Unary_Rnd:
.d485	20 ce c5	jsr $c5ce			jsr 	EvaluateNumberX 			; get value
.d488	20 ec cb	jsr $cbec			jsr 	CheckNextRParen 			; check right bracket.
.d48b	20 a8 c8	jsr $c8a8			jsr 	GetSignCurrent 				; get sign -1,0,1.
.d48e	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.d490	30 10		bmi $d4a2			bmi 	_URSetSeed
.d492	f0 2c		beq $d4c0			beq 	_URMakeRandom 				; if zero return same number.
.d494	da		phx				phx
.d495	a2 00		ldx #$00			ldx 	#0
.d497	20 fd d4	jsr $d4fd			jsr 	Random16
.d49a	a2 02		ldx #$02			ldx 	#2
.d49c	20 fd d4	jsr $d4fd			jsr 	Random16
.d49f	fa		plx				plx
.d4a0	80 1e		bra $d4c0			bra 	_URMakeRandom
.d4a2					_URSetSeed:
.d4a2	20 cc d1	jsr $d1cc			jsr 	FPUToFloat 					; make it a float to twiddle it.
.d4a5	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.d4a8	8d 29 04	sta $0429			sta 	RandomSeed+0
.d4ab	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.d4ae	8d 2a 04	sta $042a			sta 	RandomSeed+1
.d4b1	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.d4b4	8d 2b 04	sta $042b			sta 	RandomSeed+2
.d4b7	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.d4ba	0a		asl a				asl 	a
.d4bb	49 db		eor #$db			eor 	#$DB
.d4bd	8d 2c 04	sta $042c			sta 	RandomSeed+3
.d4c0					_URMakeRandom:
.d4c0	ad 29 04	lda $0429			lda 	RandomSeed+0 				; check if seed is zero.
.d4c3	0d 2a 04	ora $042a			ora 	RandomSeed+1
.d4c6	0d 2b 04	ora $042b			ora 	RandomSeed+2
.d4c9	0d 2c 04	ora $042c			ora 	RandomSeed+3
.d4cc	d0 0a		bne $d4d8			bne 	_URNotZero
.d4ce	a9 47		lda #$47			lda 	#$47
.d4d0	8d 2a 04	sta $042a			sta 	RandomSeed+1				; if it is, make it non zero.
.d4d3	a9 3d		lda #$3d			lda 	#$3D
.d4d5	8d 2c 04	sta $042c			sta 	RandomSeed+3
.d4d8					_URNotZero:
.d4d8	ad 29 04	lda $0429			lda 	RandomSeed+0 				; copy seed into mantissa.
.d4db	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.d4de	ad 2a 04	lda $042a			lda 	RandomSeed+1
.d4e1	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.d4e4	ad 2b 04	lda $042b			lda 	RandomSeed+2
.d4e7	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.d4ea	ad 2c 04	lda $042c			lda 	RandomSeed+3
.d4ed	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.d4f0	a9 00		lda #$00			lda 	#$00 						; set type to float.
.d4f2	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.d4f5	a9 80		lda #$80			lda 	#$80
.d4f7	9d 0c 03	sta $030c,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.d4fa	4c 03 d2	jmp $d203			jmp 	FPUNormalise
.d4fd					Random16:
.d4fd	5e 2a 04	lsr $042a,x			lsr 	RandomSeed+1,x				; shift seed right
.d500	7e 29 04	ror $0429,x			ror 	RandomSeed,x
.d503	90 08		bcc $d50d			bcc 	_R16_NoXor
.d505	bd 2a 04	lda $042a,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.d508	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.d50a	9d 2a 04	sta $042a,x			sta 	RandomSeed+1,x
.d50d					_R16_NoXor:
.d50d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.d50e					Unary_Int:
.d50e	20 ce c5	jsr $c5ce			jsr 	EvaluateNumberX 			; get value
.d511	20 ec cb	jsr $cbec			jsr 	CheckNextRParen 			; check right bracket.
.d514	4c 2b d2	jmp $d22b			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Return to file: basic.asm

>d517	02						.byte 	2
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 c0						.word 	StartROM
>fffe	f8 ff						.word DefaultInterrupt

;******  End of listing
