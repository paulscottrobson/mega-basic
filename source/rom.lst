
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Thu Aug 22 19:11:36 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="65816"				cpu = "65816"
="em65816"				hardware = "em65816"
=1					hasFloat = 1
=1					hasInteger = 1
=253					maxString = 253

;******  Processing file: modules/float/fpmacros.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/em65816/src_em65816.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0020					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0200					IFT_XCursor:.byte ?							; current logical position on screen
>0201					IFT_YCursor:.byte ?
>0202					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0266					IFT_LineBuffer: .fill 100 					; line input buffer.
>0300					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>0304					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>0305					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=774					XS2_Mantissa = XS_Mantissa+XS_Size
=778					XS2_Exponent = XS_Exponent+XS_Size
=779					XS2_Type = XS_Type+XS_Size
=780					XS3_Mantissa = XS_Mantissa+XS_Size*2
=784					XS3_Exponent = XS_Exponent+XS_Size*2
=785					XS3_Type = XS_Type+XS_Size*2
>0400					Num_Buffer	.fill 	32 						; buffer for numeric conversions
>0420					NumBufX 	.byte 	?						; buffer index position
>0421					NumSuppress	.byte 	?						; leading zero suppression flag
>0422					NumConvCount .byte 	? 						; count for conversions.
>0423					ExpTemp:	.byte ?							; Working temp for exponents.
>0424					ExpCount:	.byte ? 						; Count of decimal exponents.
>0425					SignCount:	.byte ?							; Integer Divide Sign Counts.
>0426					StringPtr:	.byte ? 						; Top of free memory (for string allocation)
>0427					TempStringWriteIndex: .byte ? 				; Write offset.
>0428					ValSign: 	.byte ? 						; sign flag for val()
>0429					RandomSeed:	.dword ? 						; Random seed.
>042d					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>042f					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>0431					Tim_SR:		.byte ? 						; Processor Status
>0432					Tim_A:		.byte ? 						; Processor Registers
>0433					Tim_X:		.byte ?
>0434					Tim_Y:		.byte ?
>0435					Tim_Z:		.byte ?
>0436					Tim_SP:		.byte ?							; Stack Pointer

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/em65816.asm

=$8000					HighMemory = $8000
.1000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testcode.src

>1000	18 0a 00 d9 a5 fe 0a 2d			.byte	$18,$0a,$00,$d9,$a5,$fe,$0a,$2d
>1008	37 36 35 34 33 32 31 bc			.byte	$37,$36,$35,$34,$33,$32,$31,$bc
>1010	be ff 06 68 69 20 21 00			.byte	$be,$ff,$06,$68,$69,$20,$21,$00
>1018	00					.byte	$00

;******  Return to file: modules/hardware/em65816.asm


;******  Processing file: modules/hardware/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b4					lastUnaryFunction = $b4
.c000					VectorTable:
>c000	dc c5					.word BinaryOp_And         ; $80 and
>c002	04 c6					.word BinaryOp_Or          ; $81 or
>c004	2c c6					.word BinaryOp_Xor         ; $82 xor
>c006	2c c6					.word BinaryOp_Eor         ; $83 eor
>c008	6f c6					.word Binary_Equal         ; $84 =
>c00a	8e c6					.word Binary_NotEqual      ; $85 <>
>c00c	97 c6					.word Binary_Less          ; $86 <
>c00e	a0 c6					.word Binary_LessEqual     ; $87 <=
>c010	b2 c6					.word Binary_Greater       ; $88 >
>c012	a9 c6					.word Binary_GreaterEqual  ; $89 >=
>c014	47 c7					.word BinaryOp_Add         ; $8a +
>c016	67 c7					.word BinaryOp_Subtract    ; $8b -
>c018	7a c7					.word BinaryOp_Multiply    ; $8c *
>c01a	8d c7					.word BinaryOp_Divide      ; $8d /
>c01c	b2 c0					.word NotImplemented       ; $8e ^
>c01e	b2 c0					.word NotImplemented       ; $8f if
>c020	b2 c0					.word NotImplemented       ; $90 while
>c022	b2 c0					.word NotImplemented       ; $91 repeat
>c024	b2 c0					.word NotImplemented       ; $92 for
>c026	b2 c0					.word NotImplemented       ; $93 then
>c028	b2 c0					.word NotImplemented       ; $94 endif
>c02a	b2 c0					.word NotImplemented       ; $95 wend
>c02c	b2 c0					.word NotImplemented       ; $96 until
>c02e	b2 c0					.word NotImplemented       ; $97 next
>c030	b2 c0					.word NotImplemented       ; $98 not
>c032	b2 c0					.word NotImplemented       ; $99 fn(
>c034	af c8					.word Unary_Abs            ; $9a abs(
>c036	3a c9					.word Unary_Asc            ; $9b asc(
>c038	ee d2					.word Unary_Int            ; $9c int(
>c03a	b2 c0					.word NotImplemented       ; $9d peek(
>c03c	65 d2					.word Unary_Rnd            ; $9e rnd(
>c03e	b2 c0					.word NotImplemented       ; $9f usr(
>c040	b2 c0					.word NotImplemented       ; $a0 left$(
>c042	b2 c0					.word NotImplemented       ; $a1 right$(
>c044	b2 c0					.word NotImplemented       ; $a2 mid$(
>c046	83 c9					.word Unary_Spc            ; $a3 spc(
>c048	b2 c0					.word NotImplemented       ; $a4 str$(
>c04a	cd c8					.word Unary_Val            ; $a5 val(
>c04c	50 c9					.word Unary_Len            ; $a6 len(
>c04e	b2 c0					.word NotImplemented       ; $a7 hex$(
>c050	b2 c0					.word NotImplemented       ; $a8 sin(
>c052	b2 c0					.word NotImplemented       ; $a9 cos(
>c054	b2 c0					.word NotImplemented       ; $aa tan(
>c056	b2 c0					.word NotImplemented       ; $ab atn(
>c058	b2 c0					.word NotImplemented       ; $ac exp(
>c05a	b2 c0					.word NotImplemented       ; $ad log(
>c05c	b2 c0					.word NotImplemented       ; $ae sqr(
>c05e	b2 c0					.word NotImplemented       ; $af dec(
>c060	b2 c0					.word NotImplemented       ; $b0 deek(
>c062	b2 c0					.word NotImplemented       ; $b1 leek(
>c064	b2 c0					.word NotImplemented       ; $b2 mod(
>c066	5d c8					.word Unary_Sgn            ; $b3 sgn(
>c068	5f c9					.word Unary_Chr            ; $b4 chr$(
>c06a	b2 c0					.word NotImplemented       ; $b5 $(
>c06c	b2 c0					.word NotImplemented       ; $b6 $
>c06e	b2 c0					.word NotImplemented       ; $b7 #(
>c070	b2 c0					.word NotImplemented       ; $b8 #
>c072	b2 c0					.word NotImplemented       ; $b9 %(
>c074	b2 c0					.word NotImplemented       ; $ba %
>c076	b2 c0					.word NotImplemented       ; $bb (
>c078	b2 c0					.word NotImplemented       ; $bc )
>c07a	b2 c0					.word NotImplemented       ; $bd ,
>c07c	b2 c0					.word NotImplemented       ; $be :
>c07e	b2 c0					.word NotImplemented       ; $bf ;
>c080	b2 c0					.word NotImplemented       ; $c0 def
>c082	18 c4					.word CLR_Command          ; $c1 clr
>c084	b2 c0					.word NotImplemented       ; $c3 data
>c086	b2 c0					.word NotImplemented       ; $c4 read
>c088	b2 c0					.word NotImplemented       ; $c5 dim
>c08a	b2 c0					.word NotImplemented       ; $c6 to
>c08c	b2 c0					.word NotImplemented       ; $c7 step
>c08e	b2 c0					.word NotImplemented       ; $c8 gosub
>c090	b2 c0					.word NotImplemented       ; $c9 return
>c092	b2 c0					.word NotImplemented       ; $ca goto
>c094	b2 c0					.word NotImplemented       ; $cb input
>c096	b2 c0					.word NotImplemented       ; $cc let
>c098	b2 c0					.word NotImplemented       ; $cd list
>c09a	b2 c0					.word NotImplemented       ; $ce new
>c09c	b2 c0					.word NotImplemented       ; $cf old
>c09e	b2 c0					.word NotImplemented       ; $d0 on
>c0a0	b2 c0					.word NotImplemented       ; $d1 restore
>c0a2	b2 c0					.word NotImplemented       ; $d2 poke
>c0a4	b2 c0					.word NotImplemented       ; $d3 print
>c0a6	b2 c0					.word NotImplemented       ; $d4 run
>c0a8	b2 c0					.word NotImplemented       ; $d5 stop
>c0aa	b2 c0					.word NotImplemented       ; $d6 wait
>c0ac	b2 c0					.word NotImplemented       ; $d7 doke
>c0ae	b2 c0					.word NotImplemented       ; $d8 loke
>c0b0	b2 c0					.word NotImplemented       ; $d9 assert
.c0b2					NotImplemented:
.c0b2	80 fe		bra $c0b2		_error: bra _error
.c0b4					BinaryPrecedence:
>c0b4	01					.byte 1    ; $80 and
>c0b5	01					.byte 1    ; $81 or
>c0b6	01					.byte 1    ; $82 xor
>c0b7	01					.byte 1    ; $83 eor
>c0b8	02					.byte 2    ; $84 =
>c0b9	02					.byte 2    ; $85 <>
>c0ba	02					.byte 2    ; $86 <
>c0bb	02					.byte 2    ; $87 <=
>c0bc	02					.byte 2    ; $88 >
>c0bd	02					.byte 2    ; $89 >=
>c0be	03					.byte 3    ; $8a +
>c0bf	03					.byte 3    ; $8b -
>c0c0	04					.byte 4    ; $8c *
>c0c1	04					.byte 4    ; $8d /
>c0c2	05					.byte 5    ; $8e ^
.c0c3					KeywordText:
>c0c3	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>c0c6	4f d2					.byte $4f,$d2                          ; $81 or
>c0c8	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>c0cb	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>c0ce	bd					.byte $bd                              ; $84 =
>c0cf	3c be					.byte $3c,$be                          ; $85 <>
>c0d1	bc					.byte $bc                              ; $86 <
>c0d2	3c bd					.byte $3c,$bd                          ; $87 <=
>c0d4	be					.byte $be                              ; $88 >
>c0d5	3e bd					.byte $3e,$bd                          ; $89 >=
>c0d7	ab					.byte $ab                              ; $8a +
>c0d8	ad					.byte $ad                              ; $8b -
>c0d9	aa					.byte $aa                              ; $8c *
>c0da	af					.byte $af                              ; $8d /
>c0db	de					.byte $de                              ; $8e ^
>c0dc	49 c6					.byte $49,$c6                          ; $8f if
>c0de	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>c0e3	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>c0e9	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>c0ec	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>c0f0	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>c0f5	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>c0f9	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>c0fe	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>c102	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>c105	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>c108	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>c10c	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>c110	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>c114	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>c119	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>c11d	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>c121	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>c127	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>c12e	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>c133	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>c137	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>c13c	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>c140	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>c144	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>c149	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>c14d	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>c151	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>c155	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>c159	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>c15d	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>c161	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>c165	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>c169	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>c16e	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>c173	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>c177	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>c17b	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>c180	24 a8					.byte $24,$a8                          ; $b5 $(
>c182	a4					.byte $a4                              ; $b6 $
>c183	23 a8					.byte $23,$a8                          ; $b7 #(
>c185	a3					.byte $a3                              ; $b8 #
>c186	25 a8					.byte $25,$a8                          ; $b9 %(
>c188	a5					.byte $a5                              ; $ba %
>c189	a8					.byte $a8                              ; $bb (
>c18a	a9					.byte $a9                              ; $bc )
>c18b	ac					.byte $ac                              ; $bd ,
>c18c	ba					.byte $ba                              ; $be :
>c18d	bb					.byte $bb                              ; $bf ;
>c18e	44 45 c6				.byte $44,$45,$c6                      ; $c0 def
>c191	43 4c d2				.byte $43,$4c,$d2                      ; $c1 clr
>c194	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c3 data
>c198	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c4 read
>c19c	44 49 cd				.byte $44,$49,$cd                      ; $c5 dim
>c19f	54 cf					.byte $54,$cf                          ; $c6 to
>c1a1	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c7 step
>c1a5	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $c8 gosub
>c1aa	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $c9 return
>c1b0	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $ca goto
>c1b4	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $cb input
>c1b9	4c 45 d4				.byte $4c,$45,$d4                      ; $cc let
>c1bc	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $cd list
>c1c0	4e 45 d7				.byte $4e,$45,$d7                      ; $ce new
>c1c3	4f 4c c4				.byte $4f,$4c,$c4                      ; $cf old
>c1c6	4f ce					.byte $4f,$ce                          ; $d0 on
>c1c8	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d1 restore
>c1cf	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d2 poke
>c1d3	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d3 print
>c1d8	52 55 ce				.byte $52,$55,$ce                      ; $d4 run
>c1db	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $d5 stop
>c1df	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d6 wait
>c1e3	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $d7 doke
>c1e7	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $d8 loke
>c1eb	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $d9 assert
>c1f1	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_dollarlparen = $b5
=$b6					token_dollar = $b6
=$b7					token_hashlparen = $b7
=$b8					token_hash = $b8
=$b9					token_percentlparen = $b9
=$ba					token_percent = $ba
=$bb					token_lparen = $bb
=$bc					token_rparen = $bc
=$bd					token_comma = $bd
=$be					token_colon = $be
=$bf					token_semicolon = $bf
=$c0					token_def = $c0
=$c1					token_clr = $c1
=$c3					token_data = $c3
=$c4					token_read = $c4
=$c5					token_dim = $c5
=$c6					token_to = $c6
=$c7					token_step = $c7
=$c8					token_gosub = $c8
=$c9					token_return = $c9
=$ca					token_goto = $ca
=$cb					token_input = $cb
=$cc					token_let = $cc
=$cd					token_list = $cd
=$ce					token_new = $ce
=$cf					token_old = $cf
=$d0					token_on = $d0
=$d1					token_restore = $d1
=$d2					token_poke = $d2
=$d3					token_print = $d3
=$d4					token_run = $d4
=$d5					token_stop = $d5
=$d6					token_wait = $d6
=$d7					token_doke = $d7
=$d8					token_loke = $d8
=$d9					token_assert = $d9

;******  Return to file: modules/hardware/em65816.asm

.c1f2					StartROM:
.c1f2	18		clc				clc
.c1f3	fb		xce				xce
.c1f4	c2 30		rep #$30			rep 	#$30
.c1f6	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.c1f9	1b		tcs				tcs
.c1fa	e2 30		sep #$30			sep 	#$30 						; clear AXY in 16 bit.
.c1fc	c2 30		rep #$30			rep 	#$30
.c1fe	a9 00 00	lda #$0000			lda 	#$0000
.c201	aa		tax				tax
.c202	a8		tay				tay
.c203	e2 30		sep #$30			sep 	#$30
.c205	20 a9 c3	jsr $c3a9			jsr 	IF_Reset 					; reset external interface
.c208	20 0e c2	jsr $c20e			jsr 	IFT_ClearScreen
.c20b	4c f8 c3	jmp $c3f8		jmp BASIC_Start

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.c20e					IFT_ClearScreen:
.c20e	48		pha				pha
.c20f	da		phx				phx
.c210	5a		phy				phy
.c211	20 aa c3	jsr $c3aa			jsr 	IF_Home 					; home cursor
.c214	a2 20		ldx #$20			ldx 	#IF_Height 					; this many lines.
.c216					_IFT_CS0:
.c216	a0 40		ldy #$40			ldy 	#IF_Width 					; this many chars/line
.c218					_IFT_CS1:
.c218	a9 20		lda #$20			lda 	#' '						; clear line.
.c21a	20 d6 c3	jsr $c3d6			jsr 	IF_Write
.c21d	88		dey				dey
.c21e	d0 f8		bne $c218			bne 	_IFT_CS1
.c220	20 bd c3	jsr $c3bd			jsr 	IF_NewLine 					; next line down
.c223	ca		dex				dex
.c224	d0 f0		bne $c216			bne 	_IFT_CS0
.c226	7a		ply				ply
.c227	fa		plx				plx
.c228	68		pla				pla
.c229					IFT_HomeCursor:
.c229	48		pha				pha
.c22a	20 aa c3	jsr $c3aa			jsr 	IF_Home
.c22d	a9 00		lda #$00			lda 	#0
.c22f	8d 00 02	sta $0200			sta 	IFT_XCursor
.c232	8d 01 02	sta $0201			sta 	IFT_YCursor
.c235	68		pla				pla
.c236	60		rts				rts
.c237					IFT_UpLine:
.c237	48		pha				pha
.c238	ad 01 02	lda $0201			lda  	IFT_YCursor 				; get Y
.c23b	3a		dec a				dec 	a 							; line above
.c23c	30 03		bmi $c241			bmi 	_IFTULExit 					; too far, abort
.c23e	20 cc c2	jsr $c2cc			jsr 	IFT_SetYPos					; set to that line.
.c241					_IFTULExit:
.c241	68		pla				pla
.c242	60		rts				rts
.c243					IFT_PrintCharacter:
.c243	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.c245	f0 16		beq $c25d			beq 	IFT_NewLine
.c247	48		pha				pha
.c248	20 75 c2	jsr $c275			jsr 	IFT_UpperCase 				; make upper case
.c24b	20 d6 c3	jsr $c3d6			jsr 	IF_Write 					; write out.
.c24e	ee 00 02	inc $0200			inc 	IFT_XCursor 				; bump x cursor
.c251	ad 00 02	lda $0200			lda 	IFT_XCursor 				; reached RHS ?
.c254	c9 40		cmp #$40			cmp 	#IF_Width
.c256	d0 03		bne $c25b			bne 	_IFT_PCNotEOL
.c258	20 5d c2	jsr $c25d			jsr 	IFT_NewLine 				; if so do new line.
.c25b					_IFT_PCNotEOL:
.c25b	68		pla				pla
.c25c	60		rts				rts
.c25d					IFT_NewLine:
.c25d	48		pha				pha
.c25e	20 bd c3	jsr $c3bd			jsr 	IF_NewLine 					; new line on actual screen.
.c261	a9 00		lda #$00			lda 	#0 							; reset x position
.c263	8d 00 02	sta $0200			sta 	IFT_XCursor
.c266	ee 01 02	inc $0201			inc 	IFT_YCursor 				; move down.
.c269	ad 01 02	lda $0201			lda 	IFT_YCursor
.c26c	c9 20		cmp #$20			cmp 	#IF_Height 					; reached bottom.
.c26e	d0 03		bne $c273			bne 	_IFT_NL_NotEOS
.c270	20 80 c2	jsr $c280			jsr 	IFT_Scroll 					; scroll screen up.
.c273					_IFT_NL_NotEOS:
.c273	68		pla				pla
.c274	60		rts				rts
.c275					IFT_UpperCase:
.c275	c9 61		cmp #$61			cmp 	#"a"
.c277	90 06		bcc $c27f			bcc 	_IFT_UCExit
.c279	c9 7b		cmp #$7b			cmp 	#"z"+1
.c27b	b0 02		bcs $c27f			bcs 	_IFT_UCExit
.c27d	49 20		eor #$20			eor 	#$20
.c27f					_IFT_UCExit:
.c27f	60		rts				rts
.c280					IFT_Scroll:
.c280	48		pha				pha 								; save AXY
.c281	da		phx				phx
.c282	5a		phy				phy
.c283	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.c285					_IFT_SLoop:
.c285	20 a5 c2	jsr $c2a5			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.c288	e8		inx				inx
.c289	e0 1f		cpx #$1f			cpx 	#IF_Height-1				; do whole screen
.c28b	d0 f8		bne $c285			bne 	_IFT_SLoop
.c28d	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.c28f	20 cc c2	jsr $c2cc			jsr 	IFT_SetYPos
.c292	a2 40		ldx #$40			ldx 	#IF_Width 					; blank line
.c294					_IFT_SBlank:
.c294	a9 20		lda #$20			lda 	#32
.c296	20 d6 c3	jsr $c3d6			jsr 	IF_Write
.c299	ca		dex				dex
.c29a	d0 f8		bne $c294			bne 	_IFT_SBlank
.c29c	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.c29e	20 cc c2	jsr $c2cc			jsr 	IFT_SetYPos
.c2a1	7a		ply				ply
.c2a2	fa		plx				plx
.c2a3	68		pla				pla
.c2a4	60		rts				rts
.c2a5					_IFT_ScrollLine:
.c2a5	da		phx				phx
.c2a6	da		phx				phx
.c2a7	8a		txa				txa 								; copy line into buffer.
.c2a8	1a		inc a				inc 	a 							; next line down.
.c2a9	20 cc c2	jsr $c2cc			jsr 	IFT_SetYPos
.c2ac	a2 00		ldx #$00			ldx 	#0
.c2ae					_IFTScrollCopy1:
.c2ae	20 cd c3	jsr $c3cd			jsr 	IF_Read
.c2b1	9d 02 02	sta $0202,x			sta 	IFT_Buffer,x
.c2b4	e8		inx				inx
.c2b5	e0 40		cpx #$40			cpx 	#IF_Width
.c2b7	d0 f5		bne $c2ae			bne 	_IFTScrollCopy1
.c2b9	68		pla				pla
.c2ba	20 cc c2	jsr $c2cc			jsr 	IFT_SetYPos
.c2bd	a2 00		ldx #$00			ldx 	#0
.c2bf					_IFTScrollCopy2:
.c2bf	bd 02 02	lda $0202,x			lda 	IFT_Buffer,x
.c2c2	20 d6 c3	jsr $c3d6			jsr 	IF_Write
.c2c5	e8		inx				inx
.c2c6	e0 40		cpx #$40			cpx 	#IF_Width
.c2c8	d0 f5		bne $c2bf			bne 	_IFTScrollCopy2
.c2ca	fa		plx				plx
.c2cb	60		rts				rts
.c2cc					IFT_SetYPos:
.c2cc	48		pha				pha
.c2cd	da		phx				phx
.c2ce	aa		tax				tax
.c2cf	20 29 c2	jsr $c229			jsr 	IFT_HomeCursor
.c2d2	e0 00		cpx #$00			cpx 	#0
.c2d4	f0 09		beq $c2df			beq 	_IFT_MOAExit
.c2d6					_IFT_MOALoop:
.c2d6	20 bd c3	jsr $c3bd			jsr 	IF_NewLine
.c2d9	ee 01 02	inc $0201			inc 	IFT_YCursor
.c2dc	ca		dex				dex
.c2dd	d0 f7		bne $c2d6			bne		_IFT_MOALoop
.c2df					_IFT_MOAExit:
.c2df	fa		plx				plx
.c2e0	68		pla				pla
.c2e1	60		rts				rts
.c2e2					IFT_GetKeyCursor:
.c2e2	20 ea c2	jsr $c2ea			jsr 	_IFT_FlipCursor 			; reverse current
.c2e5					_IFT_GKCWait:
.c2e5	20 e7 c3	jsr $c3e7			jsr 	IF_GetKey 					; get key
.c2e8	f0 fb		beq $c2e5			beq 	_IFT_GKCWait
.c2ea					_IFT_FlipCursor:
.c2ea	48		pha				pha 								; save
.c2eb	20 cd c3	jsr $c3cd			jsr 	IF_Read 					; read
.c2ee	20 df c3	jsr $c3df			jsr 	IF_LeftOne
.c2f1	49 80		eor #$80			eor 	#$80 						; reverse
.c2f3	20 d6 c3	jsr $c3d6			jsr 	IF_Write 					; write
.c2f6	20 df c3	jsr $c3df			jsr 	IF_LeftOne
.c2f9	68		pla				pla
.c2fa	60		rts				rts
.c2fb					IFT_ReadLine:
.c2fb	48		pha				pha
.c2fc					_IFT_RLLoop:
.c2fc	20 e2 c2	jsr $c2e2			jsr 	IFT_GetKeyCursor 			; get keystroke
.c2ff	c9 0d		cmp #$0d			cmp 	#13							; return
.c301	f0 7d		beq $c380			beq 	_IFT_RLExit
.c303	c9 20		cmp #$20			cmp 	#32 						; control character
.c305	90 05		bcc $c30c			bcc 	_IFT_Control
.c307	20 43 c2	jsr $c243			jsr 	IFT_PrintCharacter
.c30a	80 f0		bra $c2fc			bra 	_IFT_RLLoop
.c30c					_IFT_Control:
.c30c	c9 01		cmp #$01			cmp 	#"A"-64
.c30e	f0 26		beq $c336			beq 	_IFT_Left
.c310	c9 04		cmp #$04			cmp 	#"D"-64
.c312	f0 2e		beq $c342			beq 	_IFT_Right
.c314	c9 17		cmp #$17			cmp 	#"W"-64
.c316	f0 36		beq $c34e			beq 	_IFT_Up
.c318	c9 13		cmp #$13			cmp 	#"S"-64
.c31a	f0 3e		beq $c35a			beq 	_IFT_Down
.c31c	c9 08		cmp #$08			cmp 	#"H"-64
.c31e	f0 09		beq $c329			beq 	_IFT_Backspace
.c320	c9 1a		cmp #$1a			cmp 	#"Z"-64
.c322	d0 d8		bne $c2fc			bne 	_IFT_RLLoop
.c324	20 0e c2	jsr $c20e			jsr 	IFT_ClearScreen				; clear CTL-Z
.c327	80 d3		bra $c2fc			bra 	_IFT_RLLoop
.c329					_IFT_Backspace:
.c329	ad 00 02	lda $0200			lda 	IFT_XCursor 				; check not start of line.
.c32c	f0 ce		beq $c2fc			beq 	_IFT_RLLoop
.c32e	20 df c3	jsr $c3df			jsr 	IF_LeftOne
.c331	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.c333	20 d6 c3	jsr $c3d6			jsr 	IF_Write
.c336					_IFT_Left:
.c336	ce 00 02	dec $0200			dec 	IFT_XCursor 				; left CTL-W
.c339	10 29		bpl $c364			bpl 	_IFT_Reposition
.c33b	a9 3f		lda #$3f			lda 	#IF_Width-1
.c33d					_IFT_SetX:
.c33d	8d 00 02	sta $0200			sta 	IFT_XCursor
.c340	80 22		bra $c364			bra 	_IFT_Reposition
.c342					_IFT_Right:
.c342	ee 00 02	inc $0200			inc 	IFT_XCursor
.c345	ad 00 02	lda $0200			lda 	IFT_XCursor
.c348	49 40		eor #$40			eor 	#IF_Width
.c34a	f0 f1		beq $c33d			beq 	_IFT_SetX
.c34c	80 16		bra $c364			bra 	_IFT_Reposition
.c34e					_IFT_Up:
.c34e	ce 01 02	dec $0201			dec 	IFT_YCursor
.c351	10 11		bpl $c364			bpl 	_IFT_Reposition
.c353	a9 1f		lda #$1f			lda 	#IF_Height-1
.c355					_IFT_SetY:
.c355	8d 01 02	sta $0201			sta 	IFT_YCursor
.c358	80 0a		bra $c364			bra 	_IFT_Reposition
.c35a					_IFT_Down:
.c35a	ee 01 02	inc $0201			inc 	IFT_YCursor
.c35d	ad 01 02	lda $0201			lda 	IFT_YCursor
.c360	49 20		eor #$20			eor 	#IF_Height
.c362	f0 f1		beq $c355			beq 	_IFT_SetY
.c364					_IFT_Reposition:
.c364	ad 00 02	lda $0200			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.c367	48		pha				pha
.c368	ad 01 02	lda $0201			lda 	IFT_YCursor
.c36b	20 cc c2	jsr $c2cc			jsr 	IFT_SetYPos
.c36e	68		pla				pla
.c36f	aa		tax				tax
.c370	e0 00		cpx #$00			cpx 	#0
.c372	f0 88		beq $c2fc			beq 	_IFT_RLLoop
.c374					_IFT_MoveRight:
.c374	20 cd c3	jsr $c3cd			jsr 	IF_Read
.c377	ee 00 02	inc $0200			inc 	IFT_XCursor
.c37a	ca		dex				dex
.c37b	d0 f7		bne $c374			bne 	_IFT_MoveRight
.c37d	4c fc c2	jmp $c2fc			jmp 	_IFT_RLLoop
.c380					_IFT_RLExit:
.c380	ad 01 02	lda $0201			lda 	IFT_YCursor 				; go to start of line.
.c383	20 cc c2	jsr $c2cc			jsr 	IFT_SetYPos
.c386	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.c388					_IFT_RLRead:
.c388	20 cd c3	jsr $c3cd			jsr 	IF_Read
.c38b	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.c38e	e8		inx				inx
.c38f	e0 40		cpx #$40			cpx 	#IF_Width
.c391	d0 f5		bne $c388			bne 	_IFT_RLRead
.c393					_IFT_RL_Trim:
.c393	ca		dex				dex 	 							; previous char
.c394	30 07		bmi $c39d			bmi 	_IFT_Found 					; gone too far
.c396	bd 66 02	lda $0266,x			lda 	IFT_LineBuffer,x			; go back if space
.c399	c9 20		cmp #$20			cmp 	#" "
.c39b	f0 f6		beq $c393			beq 	_IFT_RL_Trim
.c39d					_IFT_Found:
.c39d	e8		inx				inx 								; forward to non-space
.c39e	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.c3a0	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.c3a3	68		pla				pla
.c3a4	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.c3a6	a0 02		ldy #$02			ldy 	#IFT_LineBuffer >> 8
.c3a8	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_em65816.asm

=64					IF_Width 	= 64 							; characters across
=32					IF_Height 	= 32 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line.
=8					IF_XPos 	= 8 							; current position, horizontal.
=$f0000					IF_Screen = $F0000							; 2k screen RAM here
=$f8010					IF_PKeyboard = $F8010						; Keyboard port.
=$f8000					IF_PBreak = $F8000 							; Break key.
.c3a9					IF_Reset:
.c3a9	60		rts				rts
.c3aa					IF_Home:
.c3aa	48		pha				pha
.c3ab	64 08		stz $08				stz 	IF_XPos 					; zero X position
.c3ad	a9 00		lda #$00			lda 	#IF_Screen & $FF 			; set r/w pos.
.c3af	85 04		sta $04				sta 	IF_Pos
.c3b1	a9 00		lda #$00			lda 	#(IF_Screen >> 8) & $FF
.c3b3	85 05		sta $05				sta 	IF_Pos+1
.c3b5	a9 0f		lda #$0f			lda 	#IF_Screen >> 16
.c3b7	85 06		sta $06				sta 	IF_Pos+2
.c3b9	64 07		stz $07				stz 	IF_Pos+3
.c3bb	68		pla				pla
.c3bc	60		rts				rts
.c3bd					IF_NewLine:
.c3bd	48		pha				pha
.c3be	64 08		stz $08				stz 	IF_XPos						; back to start of line
.c3c0	18		clc				clc 								; down one line
.c3c1	a5 04		lda $04				lda 	IF_Pos
.c3c3	69 40		adc #$40			adc 	#64
.c3c5	85 04		sta $04				sta 	IF_Pos
.c3c7	90 02		bcc $c3cb			bcc 	_IF_NoCarry 				; carry through.
.c3c9	e6 05		inc $05				inc 	IF_Pos+1
.c3cb					_IF_NoCarry:
.c3cb	68		pla				pla
.c3cc	60		rts				rts
.c3cd					IF_Read:
.c3cd	5a		phy				phy 								; save current Y
.c3ce	a4 08		ldy $08				ldy 	IF_XPos 					; read character at current position
.c3d0	b7 04		lda [$04],y			lda 	[IF_Pos],y
.c3d2	e6 08		inc $08				inc 	IF_XPos 					; step right.
.c3d4	7a		ply				ply									; restore Y
.c3d5	60		rts				rts
.c3d6					IF_Write:
.c3d6	5a		phy				phy 								; save current Y
.c3d7	a4 08		ldy $08				ldy 	IF_XPos 					; write character at current position
.c3d9	97 04		sta [$04],y			sta 	[IF_Pos],y
.c3db	e6 08		inc $08				inc 	IF_XPos 					; step right.
.c3dd	7a		ply				ply									; restore Y
.c3de	60		rts				rts
.c3df					IF_LeftOne:
.c3df	c6 08		dec $08				dec 	IF_XPos
.c3e1	60		rts				rts
.c3e2					IF_CheckBreak:
.c3e2	af 00 80 0f	lda $0f8000			lda 	IF_PBreak					; non-zero if Ctrl+C pressed.
.c3e6	60		rts				rts
.c3e7					IF_GetKey:
.c3e7	af 10 80 0f	lda $0f8010			lda 	IF_PKeyboard				; read keyboard
.c3eb	f0 08		beq $c3f5			beq		_IFGK_NoKey 				; skip if zero,no key pressed
.c3ed	48		pha				pha 								; key pressed, clear queue.
.c3ee	a9 00		lda #$00			lda 	#0
.c3f0	8f 10 80 0f	sta $0f8010			sta 	IF_PKeyboard
.c3f4	68		pla				pla
.c3f5					_IFGK_NoKey:
.c3f5	09 00		ora #$00			ora 	#0							; set Z flag appropriately.
.c3f7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm

.c3f8					BASIC_Start:
.c3f8	20 18 c4	jsr $c418			jsr 	ResetRunStatus 				; clear everything (CLR command)
.c3fb	a9 00		lda #$00			lda 	#0 							; mark temp string pointer uninitialised.
.c3fd	85 21		sta $21				sta 	zTempStr+1 					; (done before every base level evaluation/or command)
.c3ff	a9 00		lda #$00			lda 	#BasicProgram & $FF
.c401	85 16		sta $16				sta 	zCodePtr+0
.c403	a9 10		lda #$10			lda 	#BasicProgram >> 8
.c405	85 17		sta $17				sta 	zCodePtr+1
.c407	a9 00		lda #$00			lda 	#0
.c409	85 18		sta $18				sta 	zCodePtr+2
.c40b	85 19		sta $19				sta 	zCodePtr+3
.c40d	a0 03		ldy #$03			ldy 	#3
.c40f	c8		iny				iny
.c410	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c412	20 26 c4	jsr $c426			jsr 	EvaluateExpression
>c415	02						.byte 	2
.c416					SyntaxError:
.c416					ERR_Handler:
.c416	80 fe		bra $c416			bra 	ERR_Handler

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.c418					CLR_Command:
.c418					ResetRunStatus:
.c418	a9 00		lda #$00			lda 	#HighMemory & $FF
.c41a	8d 26 04	sta $0426			sta 	StringPtr
.c41d	a9 80		lda #$80			lda 	#HighMemory >> 8
.c41f	8d 27 04	sta $0427			sta 	StringPtr+1
.c422	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.c423					EVESyntax:
.c423	4c 16 c4	jmp $c416			jmp 	SyntaxError
.c426					EvaluateExpression:
.c426	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.c428					EvaluateExpressionX:
.c428	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.c42a					EvaluateExpressionXA:
.c42a	48		pha				pha 								; save precedence on stack.
.c42b	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c42d	f0 f4		beq $c423			beq 	EVESyntax 					; end of line, syntax error.
.c42f	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.c431	b0 03		bcs $c436			bcs 	_EVNotVariable
.c433	4c 1e c5	jmp $c51e			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.c436					_EVNotVariable:
.c436	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.c438	90 e9		bcc $c423			bcc 	EVESyntax
.c43a	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.c43c	b0 7b		bcs $c4b9			bcs 	_EVNotInteger
.c43e	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.c440	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.c443	a9 00		lda #$00			lda 	#0
.c445	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c448	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c44b	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c44e	a9 01		lda #$01			lda 	#1 							; set to type 1 (integer)
.c450	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c453					_EVCheckNextInteger:
.c453	c8		iny				iny
.c454	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c456	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.c458	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.c45a	b0 0d		bcs $c469			bcs 	_EVCheckDecimal
.c45c	48		pha				pha 								; save it.
.c45d	20 22 c5	jsr $c522			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.c460	68		pla				pla
.c461	1d 00 03	ora $0300,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.c464	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c467	80 ea		bra $c453			bra 	_EVCheckNextInteger
.c469					_EVCheckDecimal:
.c469	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c46b	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.c46d	d0 05		bne $c474			bne 	_EVGotAtom 					; no, get atom.
.c46f					_EVIsDecimal:
.c46f	20 52 c5	jsr $c552			jsr 	EVGetDecimal 				; extend to the decimal part.
.c472	80 00		bra $c474			bra 	_EVGotAtom 					; and continue to got atom.
.c474					_EVGotAtom:
.c474	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c476	10 3f		bpl $c4b7			bpl 	_EVExitDrop 				; must be a token.
.c478	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.c47a	b0 3b		bcs $c4b7			bcs 	_EVExitDrop
.c47c	68		pla				pla 								; get current precedence
.c47d	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.c47f	da		phx				phx 								; save X
.c480	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c482	aa		tax				tax 								; put in X
.c483	bd 34 c0	lda $c034,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.c486	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.c488	fa		plx				plx 								; restore X
.c489	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.c48b	90 2b		bcc $c4b8			bcc 	_EVExit 					; exit if too low.
.c48d	f0 29		beq $c4b8			beq 	_EVExit 					; exit if equals
.c48f	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.c491	48		pha				pha
.c492	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c494	48		pha				pha
.c495	c8		iny				iny
.c496	da		phx				phx 								; save current position
.c497	e8		inx				inx
.c498	e8		inx				inx
.c499	e8		inx				inx
.c49a	e8		inx				inx
.c49b	e8		inx				inx
.c49c	e8		inx				inx
.c49d	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.c49f	20 2a c4	jsr $c42a			jsr 	EvaluateExpressionXA 		; do the RHS.
.c4a2	fa		plx				plx 								; restore X
.c4a3	68		pla				pla 								; get the binary operator in A.
.c4a4					_EVCallA:
.c4a4	da		phx				phx 								; save X again
.c4a5	0a		asl a				asl 	a 							; double, lose the MSB.
.c4a6	aa		tax				tax									; put in X
.c4a7	bd 00 c0	lda $c000,x			lda 	VectorTable,x 				; copy address into zGenPtr
.c4aa	85 1e		sta $1e				sta 	zGenPtr
.c4ac	bd 01 c0	lda $c001,x			lda 	VectorTable+1,x
.c4af	85 1f		sta $1f				sta 	zGenPtr+1
.c4b1	fa		plx				plx 								; restore X
.c4b2	20 1f c5	jsr $c51f			jsr 	EVGoZGenPtr 				; execute that function/operator
.c4b5	80 bd		bra $c474			bra 	_EVGotAtom 					; and loop back.
.c4b7					_EVExitDrop:
.c4b7	68		pla				pla
.c4b8					_EVExit:
.c4b8	60		rts				rts
.c4b9					_EVNotInteger:
.c4b9	c8		iny				iny
.c4ba	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.c4bc	d0 19		bne $c4d7			bne 	_EVNotMinus
.c4be	20 a3 c5	jsr $c5a3			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.c4c1	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; get type
.c4c4	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.c4c6	f0 05		beq $c4cd			beq 	_EVMinusFloat
.c4c8	20 17 cb	jsr $cb17			jsr 	IntegerNegateAlways 		; negation
.c4cb	80 a7		bra $c474			bra 	_EVGotAtom 					; and go back.
.c4cd					_EVMinusFloat:
.c4cd	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; invert the sign bit.
.c4d0	49 80		eor #$80			eor 	#$80
.c4d2	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c4d5	80 9d		bra $c474			bra 	_EVGotAtom
.c4d7					_EVNotMinus:
.c4d7	c9 bb		cmp #$bb			cmp 	#token_lparen 				; is it left parenthesis
.c4d9	d0 0c		bne $c4e7			bne 	_EVNotParenthesis
.c4db	20 28 c4	jsr $c428			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.c4de	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c4e0	c8		iny				iny
.c4e1	c9 bc		cmp #$bc			cmp 	#token_rparen 				; okay if right bracket.
.c4e3	f0 8f		beq $c474			beq 	_EVGotAtom
.c4e5	80 fe		bra $c4e5		_error: bra _error
.c4e7					_EVNotParenthesis:
.c4e7	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.c4e9	d0 0c		bne $c4f7			bne 	_EVNotNot
.c4eb	20 a3 c5	jsr $c5a3			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.c4ee	20 0b d0	jsr $d00b			jsr 	FPUToInteger 				; make it an integer - if possible.
.c4f1	20 80 c5	jsr $c580			jsr 	NotInteger 					; do the not calculation
.c4f4	4c 74 c4	jmp $c474			jmp 	_EVGotAtom
.c4f7					_EVNotNot:
.c4f7	c9 fe		cmp #$fe			cmp 	#$FE
.c4f9	d0 15		bne $c510			bne 	_EVNotString
.c4fb	20 17 ca	jsr $ca17			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.c4fe	a5 20		lda $20				lda 	zTempStr 					; copy address of string into mantissa
.c500	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c503	a5 21		lda $21				lda 	zTempStr+1
.c505	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c508	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.c50a	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c50d	4c 74 c4	jmp $c474			jmp 	_EVGotAtom
.c510					_EVNotString:
.c510	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.c512	90 04		bcc $c518			bcc 	_EVBadElement
.c514	c9 b5		cmp #$b5			cmp 	#lastUnaryFunction+1
.c516	90 03		bcc $c51b			bcc 	_EVUnaryFunction
.c518					_EVBadElement:
.c518	4c 16 c4	jmp $c416			jmp 	SyntaxError
.c51b					_EVUnaryFunction:
.c51b	4c a4 c4	jmp $c4a4			jmp 	_EVCallA
.c51e					_EVVariableHandler:
.c51e	ea		nop				nop
.c51f					EVGoZGenPtr:
.c51f	6c 1e 00	jmp ($001e)			jmp 	 (zGenPtr)
.c522					EVShiftMantissaLeft6:
.c522	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.c525	9d 04 03	sta $0304,x			sta 	XS_Exponent,x
.c528	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c52b	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c52e	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c531	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c534	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.c537	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c53a	a9 00		lda #$00			lda 	#0
.c53c	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c53f	20 42 c5	jsr $c542			jsr 	_EVSMLShift 					; call it here to do it twice
.c542					_EVSMLShift:
.c542	5e 04 03	lsr $0304,x			lsr 	XS_Exponent,x
.c545	7e 03 03	ror $0303,x			ror 	XS_Mantissa+3,x
.c548	7e 02 03	ror $0302,x			ror 	XS_Mantissa+2,x
.c54b	7e 01 03	ror $0301,x			ror 	XS_Mantissa+1,x
.c54e	7e 00 03	ror $0300,x			ror 	XS_Mantissa+0,x
.c551	60		rts				rts
.c552					EVGetDecimal:
.c552	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.c554	8d 00 04	sta $0400			sta 	Num_Buffer
.c557	da		phx				phx
.c558	c8		iny				iny
.c559	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c55b	c8		iny				iny
.c55c	3a		dec a				dec 	a								; convert to a string length.
.c55d	3a		dec a				dec 	a
.c55e	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.c560					_EVGDCopy:
.c560	48		pha				pha 									; save count
.c561	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c563	9d 00 04	sta $0400,x			sta 	Num_Buffer,x
.c566	e8		inx				inx 									; forward ....
.c567	c8		iny				iny
.c568	68		pla				pla 									; get count
.c569	3a		dec a				dec 	a 								; until zero
.c56a	d0 f4		bne $c560			bne 	_EVGDCopy
.c56c	9d 00 04	sta $0400,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.c56f	fa		plx				plx 									; restore X
.c570	a9 00		lda #$00			lda 	#Num_Buffer & $FF 				; set zGenPtr
.c572	85 1e		sta $1e				sta 	zGenPtr
.c574	a9 04		lda #$04			lda 	#Num_Buffer >> 8
.c576	85 1f		sta $1f				sta 	zGenPtr+1
.c578	5a		phy				phy 									; save Y
.c579	a0 00		ldy #$00			ldy 	#0 								; start position
.c57b	20 e4 d1	jsr $d1e4			jsr 	FPFromString 					; convert current
.c57e	7a		ply				ply 									; restore Y
.c57f	60		rts				rts
.c580					NotInteger:
.c580	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.c583	49 ff		eor #$ff			eor 	#$FF
.c585	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c588	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c58b	49 ff		eor #$ff			eor 	#$FF
.c58d	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c590	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c593	49 ff		eor #$ff			eor 	#$FF
.c595	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c598	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c59b	49 ff		eor #$ff			eor 	#$FF
.c59d	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c5a0	60		rts				rts
.c5a1					EvaluateGetAtom:
.c5a1	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.c5a3					EvaluateGetAtomX:
.c5a3	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.c5a5	20 2a c4	jsr $c42a			jsr 	EvaluateExpressionXA
.c5a8	bd 05 03	lda $0305,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.c5ab	29 0f		and #$0f			and 	#15
.c5ad	c9 02		cmp #$02			cmp 	#2
.c5af	b0 01		bcs $c5b2			bcs 	EvaluateType
.c5b1	60		rts				rts
.c5b2					EvaluateType:
.c5b2	80 fe		bra $c5b2		_error: bra _error
.c5b4					EvaluateNumber:
.c5b4	a2 00		ldx #$00			ldx 	#0
.c5b6					EvaluateNumberX:
.c5b6	20 28 c4	jsr $c428			jsr 	EvaluateExpressionX
.c5b9	bd 05 03	lda $0305,x			lda 	XS_Type,x 						; check type is 0/1
.c5bc	29 0f		and #$0f			and 	#15
.c5be	c9 02		cmp #$02			cmp 	#2
.c5c0	b0 f0		bcs $c5b2			bcs 	EvaluateType
.c5c2	60		rts				rts
.c5c3					EvaluateString:
.c5c3	a2 00		ldx #$00			ldx 	#0
.c5c5					EvaluateStringX:
.c5c5	20 28 c4	jsr $c428			jsr 	EvaluateExpressionX
.c5c8	bd 05 03	lda $0305,x			lda 	XS_Type,x 						; check type is 2
.c5cb	29 0f		and #$0f			and 	#15
.c5cd	c9 02		cmp #$02			cmp 	#2
.c5cf	d0 e1		bne $c5b2			bne 	EvaluateType
.c5d1	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.c5d4	85 1e		sta $1e				sta 	zGenPtr
.c5d6	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c5d9	85 1f		sta $1f				sta 	zGenPtr+1
.c5db	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.c5dc					BinaryOp_And:
.c5dc	20 54 c6	jsr $c654			jsr 	BinaryMakeBothInteger
.c5df	bd 00 03	lda $0300,x			lda		XS_Mantissa+0,x
.c5e2	3d 06 03	and $0306,x			and 	XS2_Mantissa+0,x
.c5e5	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c5e8	bd 01 03	lda $0301,x			lda		XS_Mantissa+1,x
.c5eb	3d 07 03	and $0307,x			and 	XS2_Mantissa+1,x
.c5ee	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c5f1	bd 02 03	lda $0302,x			lda		XS_Mantissa+2,x
.c5f4	3d 08 03	and $0308,x			and 	XS2_Mantissa+2,x
.c5f7	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c5fa	bd 03 03	lda $0303,x			lda		XS_Mantissa+3,x
.c5fd	3d 09 03	and $0309,x			and 	XS2_Mantissa+3,x
.c600	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c603	60		rts				rts
.c604					BinaryOp_Or:
.c604	20 54 c6	jsr $c654			jsr 	BinaryMakeBothInteger
.c607	bd 00 03	lda $0300,x			lda		XS_Mantissa+0,x
.c60a	1d 06 03	ora $0306,x			ora 	XS2_Mantissa+0,x
.c60d	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c610	bd 01 03	lda $0301,x			lda		XS_Mantissa+1,x
.c613	1d 07 03	ora $0307,x			ora 	XS2_Mantissa+1,x
.c616	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c619	bd 02 03	lda $0302,x			lda		XS_Mantissa+2,x
.c61c	1d 08 03	ora $0308,x			ora 	XS2_Mantissa+2,x
.c61f	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c622	bd 03 03	lda $0303,x			lda		XS_Mantissa+3,x
.c625	1d 09 03	ora $0309,x			ora 	XS2_Mantissa+3,x
.c628	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c62b	60		rts				rts
.c62c					BinaryOp_Eor:
.c62c					BinaryOp_Xor:
.c62c	20 54 c6	jsr $c654			jsr 	BinaryMakeBothInteger
.c62f	bd 00 03	lda $0300,x			lda		XS_Mantissa+0,x
.c632	5d 06 03	eor $0306,x			eor 	XS2_Mantissa+0,x
.c635	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c638	bd 01 03	lda $0301,x			lda		XS_Mantissa+1,x
.c63b	5d 07 03	eor $0307,x			eor 	XS2_Mantissa+1,x
.c63e	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c641	bd 02 03	lda $0302,x			lda		XS_Mantissa+2,x
.c644	5d 08 03	eor $0308,x			eor 	XS2_Mantissa+2,x
.c647	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c64a	bd 03 03	lda $0303,x			lda		XS_Mantissa+3,x
.c64d	5d 09 03	eor $0309,x			eor 	XS2_Mantissa+3,x
.c650	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c653	60		rts				rts
.c654					BinaryMakeBothInteger:
.c654	da		phx				phx 								; save X
.c655	e8		inx				inx
.c656	e8		inx				inx
.c657	e8		inx				inx
.c658	e8		inx				inx
.c659	e8		inx				inx
.c65a	e8		inx				inx
.c65b	20 5f c6	jsr $c65f			jsr 	BinaryMakeInteger 			; convert to integer.
.c65e	fa		plx				plx 								; restore X and fall through.
.c65f					BinaryMakeInteger:
.c65f	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; get type byte.
.c662	29 0f		and #$0f			and 	#15 						; check type zero
.c664	f0 04		beq $c66a			beq 	_BMIConvert 				; if float convert to integer.
.c666	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.c667	90 04		bcc $c66d			bcc 	_BMIError
.c669	60		rts				rts
.c66a					_BMIConvert:
.c66a	4c 0b d0	jmp $d00b			jmp 	FPUToInteger 				; convert to integer
.c66d					_BMIError:
.c66d	80 fe		bra $c66d		_error: bra _error

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.c66f					Binary_Equal:
.c66f	20 bb c6	jsr $c6bb			jsr 	CompareValues
.c672	09 00		ora #$00			ora 	#0
.c674	f0 04		beq $c67a			beq 	CCTrue
.c676	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.c678	80 02		bra $c67c			bra 	CCWrite
.c67a	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.c67c	9d 00 03	sta $0300,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.c67f	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c682	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c685	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c688	a9 01		lda #$01			lda 	#1
.c68a	9d 05 03	sta $0305,x			sta 	XS_Type,x 					; set type to integer whatever.
.c68d	60		rts				rts
.c68e					Binary_NotEqual:
.c68e	20 bb c6	jsr $c6bb			jsr 	CompareValues
.c691	09 00		ora #$00			ora 	#0
.c693	d0 e1		bne $c676			bne 	CCFalse
.c695	80 e3		bra $c67a			bra 	CCTrue
.c697					Binary_Less:
.c697	20 bb c6	jsr $c6bb			jsr 	CompareValues
.c69a	09 00		ora #$00			ora 	#0
.c69c	30 dc		bmi $c67a			bmi 	CCTrue
.c69e	80 d6		bra $c676			bra 	CCFalse
.c6a0					Binary_LessEqual:
.c6a0	20 bb c6	jsr $c6bb			jsr 	CompareValues
.c6a3	c9 01		cmp #$01			cmp 	#1
.c6a5	d0 d3		bne $c67a			bne 	CCTrue
.c6a7	80 cd		bra $c676			bra 	CCFalse
.c6a9					Binary_GreaterEqual:
.c6a9	20 bb c6	jsr $c6bb			jsr 	CompareValues
.c6ac	09 00		ora #$00			ora 	#0
.c6ae	10 ca		bpl $c67a			bpl 	CCTrue
.c6b0	80 c4		bra $c676			bra 	CCFalse
.c6b2					Binary_Greater:
.c6b2	20 bb c6	jsr $c6bb			jsr 	CompareValues
.c6b5	c9 01		cmp #$01			cmp 	#1
.c6b7	d0 c1		bne $c67a			bne 	CCTrue
.c6b9	80 bb		bra $c676			bra 	CCFalse
.c6bb					CompareValues:
.c6bb	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; and the types together
.c6be	3d 0b 03	and $030b,x			and 	XS2_Type,x
.c6c1	c9 02		cmp #$02			cmp 	#2
.c6c3	f0 13		beq $c6d8			beq 	_CVString
.c6c5	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; and 2 type bytes together.
.c6c8	3d 0b 03	and $030b,x			and 	XS2_Type,x
.c6cb	4a		lsr a				lsr 	a 							; shift bit 0 into C
.c6cc	90 03		bcc $c6d1			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.c6ce	4c 1e c7	jmp $c71e			jmp 	CompareInteger32 							; so execute code at \1
.c6d1					_BCFloat:
.c6d1	20 ec c7	jsr $c7ec			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.c6d4	4c 1a cf	jmp $cf1a			jmp 	FPCompare 							; and execute code at \2
.c6d7	60		rts				rts
.c6d8					_CVString:
.c6d8	da		phx				phx 								; save XY
.c6d9	5a		phy				phy
.c6da	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.c6dd	85 1a		sta $1a				sta		zLTemp1+0
.c6df	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c6e2	85 1b		sta $1b				sta 	zLTemp1+1
.c6e4	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x
.c6e7	85 1c		sta $1c				sta 	zLTemp1+2
.c6e9	bd 07 03	lda $0307,x			lda 	XS2_Mantissa+1,x
.c6ec	85 1d		sta $1d				sta 	zLTemp1+3
.c6ee	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.c6f0	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.c6f2	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.c6f4	90 02		bcc $c6f8			bcc 	_CVCommon
.c6f6	b1 1c		lda ($1c),y			lda 	(zLTemp1+2),y
.c6f8					_CVCommon:
.c6f8	aa		tax				tax 								; put shorter string length in zero.
.c6f9	f0 0c		beq $c707			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.c6fb					_CVCompare:
.c6fb	c8		iny				iny 								; next character
.c6fc	b1 1a		lda ($1a),y			lda 	(zLTemp1),y 				; compare characters
.c6fe	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.c700	90 13		bcc $c715			bcc 	_CVReturnLess 				; <
.c702	d0 15		bne $c719			bne 	_CVReturnGreater 			; >
.c704	ca		dex				dex 								; until common length matched.
.c705	d0 f4		bne $c6fb			bne 	_CVCompare
.c707					_CVMatch:
.c707	a0 00		ldy #$00			ldy 	#0
.c709	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.c70b	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.c70d	90 06		bcc $c715			bcc 	_CVReturnLess 				; <
.c70f	d0 08		bne $c719			bne 	_CVReturnGreater 			; >
.c711	a9 00		lda #$00			lda 	#0
.c713	80 06		bra $c71b			bra 	_CVExit 					; same common, same length, same string
.c715					_CVReturnLess:
.c715	a9 ff		lda #$ff			lda 	#$FF
.c717	80 02		bra $c71b			bra 	_CVExit
.c719					_CVReturnGreater:
.c719	a9 01		lda #$01			lda 	#$01
.c71b					_CVExit:
.c71b	7a		ply				ply
.c71c	fa		plx				plx
.c71d	60		rts				rts
.c71e					CompareInteger32:
.c71e	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.c721	49 80		eor #$80			eor 	#$80
.c723	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c726	bd 09 03	lda $0309,x			lda 	XS2_Mantissa+3,x
.c729	49 80		eor #$80			eor 	#$80
.c72b	9d 09 03	sta $0309,x			sta 	XS2_Mantissa+3,x
.c72e	20 c6 c7	jsr $c7c6			jsr 	SubInteger32 				; subtraction
.c731	90 11		bcc $c744			bcc 	_CI32Less 					; cc return -1
.c733	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x 			; check if zero
.c736	1d 01 03	ora $0301,x			ora 	XS_Mantissa+1,x
.c739	1d 02 03	ora $0302,x			ora 	XS_Mantissa+2,x
.c73c	1d 03 03	ora $0303,x			ora 	XS_Mantissa+3,x
.c73f	f0 02		beq $c743			beq 	_CI32Exit
.c741	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.c743					_CI32Exit:
.c743	60		rts				rts
.c744					_CI32Less:
.c744	a9 ff		lda #$ff			lda 	#$FF
.c746	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.c747					BinaryOp_Add:
.c747	bd 05 03	lda $0305,x			lda 	XS_Type,x  					; and types together
.c74a	3d 0b 03	and $030b,x			and 	XS2_Type,x
.c74d	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.c74f	d0 13		bne $c764			bne 	_BOAString
.c751	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; and 2 type bytes together.
.c754	3d 0b 03	and $030b,x			and 	XS2_Type,x
.c757	4a		lsr a				lsr 	a 							; shift bit 0 into C
.c758	90 03		bcc $c75d			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.c75a	4c a0 c7	jmp $c7a0			jmp 	AddInteger32 							; so execute code at \1
.c75d					_BCFloat:
.c75d	20 ec c7	jsr $c7ec			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.c760	4c a0 cc	jmp $cca0			jmp 	FPAdd 							; and execute code at \2
.c763	60		rts				rts
.c764					_BOAString:
.c764	4c 06 c8	jmp $c806			jmp 	ConcatenateString 			; concatenate two strings.
.c767					BinaryOp_Subtract:
.c767	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; and 2 type bytes together.
.c76a	3d 0b 03	and $030b,x			and 	XS2_Type,x
.c76d	4a		lsr a				lsr 	a 							; shift bit 0 into C
.c76e	90 03		bcc $c773			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.c770	4c c6 c7	jmp $c7c6			jmp 	SubInteger32 							; so execute code at \1
.c773					_BCFloat:
.c773	20 ec c7	jsr $c7ec			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.c776	4c 96 cc	jmp $cc96			jmp 	FPSubtract 							; and execute code at \2
.c779	60		rts				rts
.c77a					BinaryOp_Multiply:
.c77a	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; and 2 type bytes together.
.c77d	3d 0b 03	and $030b,x			and 	XS2_Type,x
.c780	4a		lsr a				lsr 	a 							; shift bit 0 into C
.c781	90 03		bcc $c786			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.c783	4c 3c ca	jmp $ca3c			jmp 	MulInteger32 							; so execute code at \1
.c786					_BCFloat:
.c786	20 ec c7	jsr $c7ec			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.c789	4c fa cd	jmp $cdfa			jmp 	FPMultiply 							; and execute code at \2
.c78c	60		rts				rts
.c78d					BinaryOp_Divide:
.c78d	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; and 2 type bytes together.
.c790	3d 0b 03	and $030b,x			and 	XS2_Type,x
.c793	4a		lsr a				lsr 	a 							; shift bit 0 into C
.c794	90 03		bcc $c799			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.c796	4c 93 ca	jmp $ca93			jmp 	DivInteger32 							; so execute code at \1
.c799					_BCFloat:
.c799	20 ec c7	jsr $c7ec			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.c79c	4c 72 cd	jmp $cd72			jmp 	FPDivide 							; and execute code at \2
.c79f	60		rts				rts
.c7a0					AddInteger32:
.c7a0	18		clc				clc
.c7a1	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.c7a4	7d 06 03	adc $0306,x			adc 	XS2_Mantissa+0,x
.c7a7	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c7aa	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c7ad	7d 07 03	adc $0307,x			adc 	XS2_Mantissa+1,x
.c7b0	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c7b3	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c7b6	7d 08 03	adc $0308,x			adc 	XS2_Mantissa+2,x
.c7b9	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c7bc	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c7bf	7d 09 03	adc $0309,x			adc 	XS2_Mantissa+3,x
.c7c2	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c7c5	60		rts				rts
.c7c6					SubInteger32:
.c7c6	38		sec				sec
.c7c7	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.c7ca	fd 06 03	sbc $0306,x			sbc 	XS2_Mantissa+0,x
.c7cd	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c7d0	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c7d3	fd 07 03	sbc $0307,x			sbc 	XS2_Mantissa+1,x
.c7d6	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c7d9	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c7dc	fd 08 03	sbc $0308,x			sbc 	XS2_Mantissa+2,x
.c7df	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c7e2	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c7e5	fd 09 03	sbc $0309,x			sbc 	XS2_Mantissa+3,x
.c7e8	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c7eb	60		rts				rts
.c7ec					BinaryMakeBothFloat:
.c7ec	da		phx				phx 								; save X
.c7ed	e8		inx				inx
.c7ee	e8		inx				inx
.c7ef	e8		inx				inx
.c7f0	e8		inx				inx
.c7f1	e8		inx				inx
.c7f2	e8		inx				inx
.c7f3	20 f7 c7	jsr $c7f7			jsr 	BinaryMakeFloat 			; convert to float.
.c7f6	fa		plx				plx 								; restore X and fall through.
.c7f7					BinaryMakeFloat:
.c7f7	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; get type byte.
.c7fa	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.c7fb	b0 04		bcs $c801			bcs 	_BMFConvert
.c7fd	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.c7fe	b0 04		bcs $c804			bcs 	_BMFError
.c800	60		rts				rts
.c801					_BMFConvert:
.c801	4c ac cf	jmp $cfac			jmp 	FPUToFloat 					; convert to float
.c804					_BMFError:
.c804	80 fe		bra $c804		_error: bra _error
.c806					ConcatenateString:
.c806	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.c809	85 1a		sta $1a				sta		zLTemp1+0
.c80b	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c80e	85 1b		sta $1b				sta 	zLTemp1+1
.c810	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x
.c813	85 1c		sta $1c				sta 	zLTemp1+2
.c815	bd 07 03	lda $0307,x			lda 	XS2_Mantissa+1,x
.c818	85 1d		sta $1d				sta 	zLTemp1+3
.c81a	5a		phy				phy
.c81b	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.c81d	b1 1a		lda ($1a),y			lda 	(zlTemp1),y
.c81f	71 1c		adc ($1c),y			adc 	(zlTemp1+2),y
.c821	7a		ply				ply
.c822	b0 37		bcs $c85b			bcs 	_CSError					; check in range.
.c824	c9 fe		cmp #$fe			cmp 	#maxString+1
.c826	b0 33		bcs $c85b			bcs 	_CSError
.c828	20 dc c9	jsr $c9dc			jsr 	AllocateTempString 			; store the result
.c82b	20 46 c8	jsr $c846			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.c82e	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.c831	85 1a		sta $1a				sta 	zLTemp1
.c833	bd 07 03	lda $0307,x			lda 	XS2_Mantissa+1,x
.c836	85 1b		sta $1b				sta 	zLTemp1+1
.c838	20 46 c8	jsr $c846			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.c83b	a5 20		lda $20				lda 	zTempStr 					; point current to new string
.c83d	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c840	a5 21		lda $21				lda 	zTempStr+1
.c842	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c845	60		rts				rts
.c846					_CSCopyString:
.c846	da		phx				phx
.c847	5a		phy				phy
.c848	a0 00		ldy #$00			ldy 	#0 							; get length
.c84a	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.c84c	f0 0a		beq $c858			beq 	_CSCSExit 					; if zero, exit
.c84e	aa		tax				tax 								; put in X
.c84f					_CSCSLoop:
.c84f	c8		iny				iny 								; get next char
.c850	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.c852	20 07 ca	jsr $ca07			jsr		WriteTempString 			; copy out
.c855	ca		dex				dex 								; do whole string
.c856	d0 f7		bne $c84f			bne 	_CSCSLoop
.c858					_CSCSExit:
.c858	7a		ply				ply
.c859	fa		plx				plx
.c85a	60		rts				rts
.c85b					_CSError:
.c85b	80 fe		bra $c85b		_error: bra _error

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.c85d					Unary_Sgn:
.c85d	20 b6 c5	jsr $c5b6			jsr 	EvaluateNumberX 			; get value
.c860	20 cc c9	jsr $c9cc			jsr 	CheckNextRParen 			; check right bracket.
.c863	20 87 c8	jsr $c887			jsr 	GetSignCurrent 				; get sign.
.c866	09 00		ora #$00			ora 	#0
.c868	10 09		bpl $c873			bpl		UnarySetAInteger			; if 0,1 return that.
.c86a	80 00		bra $c86c			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.c86c					UnarySetAMinus1:
.c86c	a9 ff		lda #$ff			lda 	#$FF
.c86e	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.c871	80 05		bra $c878			bra 	UnarySetAFill
.c873					UnarySetAInteger:
.c873	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.c876	a9 00		lda #$00			lda 	#0
.c878					UnarySetAFill:
.c878	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c87b	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c87e	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c881	a9 01		lda #$01			lda 	#1
.c883	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c886	60		rts				rts
.c887					GetSignCurrent:
.c887	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; identify type.
.c88a	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.c88b	90 19		bcc $c8a6			bcc 	_GSCFloat
.c88d	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c890	30 11		bmi $c8a3			bmi 	_GSCMinus1
.c892	1d 00 03	ora $0300,x			ora 	XS_Mantissa+0,x
.c895	1d 01 03	ora $0301,x			ora 	XS_Mantissa+1,x
.c898	1d 02 03	ora $0302,x			ora 	XS_Mantissa+2,x
.c89b	d0 03		bne $c8a0			bne 	_GSCPlus1
.c89d					_GSCZero:
.c89d	a9 00		lda #$00			lda 	#0
.c89f	60		rts				rts
.c8a0					_GSCPlus1:
.c8a0	a9 01		lda #$01			lda 	#$01
.c8a2	60		rts				rts
.c8a3					_GSCMinus1:
.c8a3	a9 ff		lda #$ff			lda 	#$FF
.c8a5	60		rts				rts
.c8a6					_GSCFloat:
.c8a6	3c 05 03	bit $0305,x			bit 	XS_Type,x
.c8a9	70 f2		bvs $c89d			bvs 	_GSCZero
.c8ab	30 f6		bmi $c8a3			bmi 	_GSCMinus1
.c8ad	80 f1		bra $c8a0			bra 	_GSCPlus1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.c8af					Unary_Abs:
.c8af	20 b6 c5	jsr $c5b6			jsr 	EvaluateNumberX 			; get value
.c8b2	20 cc c9	jsr $c9cc			jsr 	CheckNextRParen 			; check right bracket.
.c8b5	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; get type
.c8b8	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.c8ba	f0 08		beq $c8c4			beq 	_UAMinusFloat
.c8bc	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; check MSB
.c8bf	10 0b		bpl $c8cc			bpl 	_UAExit
.c8c1	4c 17 cb	jmp $cb17			jmp 	IntegerNegateAlways 		; negation
.c8c4					_UAMinusFloat:
.c8c4	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; clear the sign bit.
.c8c7	29 7f		and #$7f			and		#$7F
.c8c9	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c8cc					_UAExit:
.c8cc	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.c8cd					Unary_Val:
.c8cd	20 c5 c5	jsr $c5c5			jsr 	EvaluateStringX 			; get string
.c8d0	20 cc c9	jsr $c9cc			jsr 	CheckNextRParen 			; check right bracket.
.c8d3	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.c8d6	85 1e		sta $1e				sta 	zGenPtr
.c8d8	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c8db	85 1f		sta $1f				sta 	zGenPtr+1
.c8dd	5a		phy				phy
.c8de	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.c8e0	b1 1e		lda ($1e),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.c8e2	f0 54		beq $c938			beq 	_UVBadNumber
.c8e4	48		pha				pha 								; save length.
.c8e5	1a		inc a				inc 	a 							; one for the length, one for the terminator
.c8e6	1a		inc a				inc 	a
.c8e7	20 dc c9	jsr $c9dc			jsr 	AllocateTempString
.c8ea	c8		iny				iny 								; move to the next.
.c8eb	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get character
.c8ed	49 2d		eor #$2d			eor 	#"-"						; zero if minus sign
.c8ef	8d 28 04	sta $0428			sta 	ValSign
.c8f2	d0 01		bne $c8f5			bne 	_UVNotMinus
.c8f4	c8		iny				iny 								; skip over it.
.c8f5					_UVNotMinus:
.c8f5	68		pla				pla 								; this is the count.
.c8f6	48		pha		_UVCopy:pha									; copy into new temp string which is ASCIIZ
.c8f7	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.c8f9	c8		iny				iny
.c8fa	20 07 ca	jsr $ca07			jsr 	WriteTempString
.c8fd	68		pla				pla
.c8fe	3a		dec a				dec 	a
.c8ff	d0 f5		bne $c8f6			bne 	_UVCopy
.c901	20 07 ca	jsr $ca07			jsr 	WriteTempString 			; make it ASCIIZ
.c904	18		clc				clc
.c905	a5 20		lda $20				lda 	zTempStr 					; tempstring +1 => genptr
.c907	69 01		adc #$01			adc 	#1
.c909	85 1e		sta $1e				sta 	zGenPtr
.c90b	a5 21		lda $21				lda 	zTempStr+1
.c90d	69 00		adc #$00			adc 	#0
.c90f	85 1f		sta $1f				sta 	zGenPtr+1
.c911	18		clc				clc
.c912	20 eb cb	jsr $cbeb			jsr 	IntFromString 				; first bit.
.c915	b0 21		bcs $c938			bcs 	_UVBadNumber
.c917	20 e4 d1	jsr $d1e4			jsr 	FPFromString				; try for a float part.
.c91a	ad 28 04	lda $0428			lda 	ValSign 					; was it negative
.c91d	d0 13		bne $c932			bne 	_UVNotNegative
.c91f	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; check if integer
.c922	4a		lsr a				lsr 	a
.c923	b0 0a		bcs $c92f			bcs 	_UVInteger
.c925	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; set sign bit
.c928	09 80		ora #$80			ora 	#$80
.c92a	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c92d	80 03		bra $c932			bra 	_UVNotNegative
.c92f					_UVInteger:
.c92f	20 17 cb	jsr $cb17			jsr 	IntegerNegateAlways 		; sign it.
.c932					_UVNotNegative:
.c932	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; used everything
.c934	d0 02		bne $c938			bne 	_UVBadNumber
.c936	7a		ply				ply
.c937	60		rts				rts
.c938					_UVBadNumber:
.c938	80 fe		bra $c938		_error: bra _error

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.c93a					Unary_Asc:
.c93a	20 c5 c5	jsr $c5c5			jsr 	EvaluateStringX 			; string parameter
.c93d	20 cc c9	jsr $c9cc			jsr 	CheckNextRParen 			; right bracket.
.c940	5a		phy				phy 								; get the string length
.c941	a0 00		ldy #$00			ldy 	#0
.c943	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.c945	f0 07		beq $c94e			beq 	_UAIllegal 					; must be at least one character
.c947	c8		iny				iny
.c948	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; read it.
.c94a	7a		ply				ply
.c94b	4c 73 c8	jmp $c873			jmp 	UnarySetAInteger
.c94e					_UAIllegal:
.c94e	80 fe		bra $c94e		_error: bra _error

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.c950					Unary_Len:
.c950	20 c5 c5	jsr $c5c5			jsr 	EvaluateStringX 			; string parameter
.c953	20 cc c9	jsr $c9cc			jsr 	CheckNextRParen 			; right bracket.
.c956	5a		phy				phy 								; get the string length
.c957	a0 00		ldy #$00			ldy 	#0
.c959	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.c95b	7a		ply				ply
.c95c	4c 73 c8	jmp $c873			jmp 	UnarySetAInteger

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.c95f					Unary_Chr:
.c95f	20 b6 c5	jsr $c5b6			jsr 	EvaluateNumberX 			; numeric parameter
.c962	20 cc c9	jsr $c9cc			jsr 	CheckNextRParen 			; right bracket.
.c965	20 0b d0	jsr $d00b			jsr 	FPUToInteger 				; make integer.
.c968	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.c96b	1d 02 03	ora $0302,x			ora 	XS_Mantissa+2,x
.c96e	1d 03 03	ora $0303,x			ora 	XS_Mantissa+3,x
.c971	d0 0e		bne $c981			bne 	_UCChar
.c973	a9 01		lda #$01			lda 	#1 							; one character string
.c975	20 dc c9	jsr $c9dc			jsr 	AllocateTempString
.c978	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.c97b	20 07 ca	jsr $ca07			jsr 	WriteTempString
.c97e	4c b4 c9	jmp $c9b4			jmp 	UnaryReturnTempStr
.c981					_UCChar:
.c981	80 fe		bra $c981		_error: bra _error

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.c983					Unary_Spc:
.c983	20 b6 c5	jsr $c5b6			jsr 	EvaluateNumberX 			; numeric parameter
.c986	20 cc c9	jsr $c9cc			jsr 	CheckNextRParen 			; right bracket.
.c989	20 0b d0	jsr $d00b			jsr 	FPUToInteger 				; make integer.
.c98c	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.c98f	1d 02 03	ora $0302,x			ora 	XS_Mantissa+2,x
.c992	1d 03 03	ora $0303,x			ora 	XS_Mantissa+3,x
.c995	d0 1b		bne $c9b2			bne 	_USSize
.c997	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.c99a	c9 fe		cmp #$fe			cmp 	#maxString+1
.c99c	b0 14		bcs $c9b2			bcs 	_USSize
.c99e	48		pha				pha 								; save length
.c99f	1a		inc a				inc 	a 							; allocate one more.
.c9a0	20 dc c9	jsr $c9dc			jsr 	AllocateTempString
.c9a3	68		pla				pla 								; get length
.c9a4	f0 0e		beq $c9b4			beq 	UnaryReturnTempStr 			; return the current temp string
.c9a6					_USLoop:
.c9a6	48		pha				pha
.c9a7	a9 20		lda #$20			lda 	#" "
.c9a9	20 07 ca	jsr $ca07			jsr 	WriteTempString
.c9ac	68		pla				pla
.c9ad	3a		dec a				dec 	a
.c9ae	d0 f6		bne $c9a6			bne 	_USLoop
.c9b0	80 02		bra $c9b4			bra 	UnaryReturnTempStr
.c9b2					_USSize:
.c9b2	80 fe		bra $c9b2		_error: bra _error
.c9b4					UnaryReturnTempStr:
.c9b4	a5 20		lda $20				lda 	zTempStr 					; copy temp string addr -> mantissa
.c9b6	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c9b9	a5 21		lda $21				lda 	zTempStr+1
.c9bb	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c9be	a9 02		lda #$02			lda 	#2 							; set type to string
.c9c0	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c9c3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.c9c4					CheckNextToken:
.c9c4	d1 16		cmp ($16),y			cmp 	(zCodePtr),y
.c9c6	d0 02		bne $c9ca			bne 	CTFail 						; no, then fail
.c9c8	c8		iny				iny
.c9c9	60		rts				rts
.c9ca					CTFail:
.c9ca	80 fe		bra $c9ca		_error: bra _error
.c9cc					CheckNextRParen:
.c9cc	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c9ce	c9 bc		cmp #$bc			cmp 	#token_rparen
.c9d0	d0 f8		bne $c9ca			bne 	CTFail
.c9d2	c8		iny				iny
.c9d3	60		rts				rts
.c9d4					CheckNextComma:
.c9d4	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c9d6	c9 bd		cmp #$bd			cmp 	#token_comma
.c9d8	d0 f0		bne $c9ca			bne 	CTFail
.c9da	c8		iny				iny
.c9db	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.c9dc					AllocateTempString:
.c9dc	48		pha				pha 								; save required count.
.c9dd	a5 21		lda $21				lda 	zTempStr+1 					; check if initialised yet ?
.c9df	d0 0b		bne $c9ec			bne 	_ATSInitialised
.c9e1	ad 26 04	lda $0426			lda 	StringPtr 					; set temporary string ptr 1 page below available
.c9e4	85 20		sta $20				sta 	zTempStr					; space, this is for strings to be concreted.
.c9e6	ad 27 04	lda $0427			lda 	StringPtr+1
.c9e9	3a		dec a				dec 	a
.c9ea	85 21		sta $21				sta 	zTempStr+1
.c9ec					_ATSInitialised:
.c9ec	68		pla				pla 								; get required count back.
.c9ed	49 ff		eor #$ff			eor 	#$FF 						; negate 2's complement.
.c9ef	1a		inc a				inc 	a
.c9f0	18		clc				clc
.c9f1	65 20		adc $20				adc 	zTempStr 					; "add" to the temp string pointer
.c9f3	85 20		sta $20				sta 	zTempStr
.c9f5	a9 ff		lda #$ff			lda 	#$FF
.c9f7	65 21		adc $21				adc 	zTempStr+1
.c9f9	85 21		sta $21				sta 	zTempStr+1
.c9fb	a9 00		lda #$00			lda 	#0 							; clear temp string.
.c9fd	5a		phy				phy
.c9fe	a8		tay				tay
.c9ff	91 20		sta ($20),y			sta 	(zTempStr),y
.ca01	7a		ply				ply
.ca02	1a		inc a				inc 	a 							; reset the write index.
.ca03	8d 27 04	sta $0427			sta 	TempStringWriteIndex
.ca06	60		rts				rts
.ca07					WriteTempString:
.ca07	5a		phy				phy 								; save Y
.ca08	ac 27 04	ldy $0427			ldy 	TempStringWriteIndex	 	; write position.
.ca0b	91 20		sta ($20),y			sta 	(zTempStr),y 				; write character out.
.ca0d	ee 27 04	inc $0427			inc 	TempStringWriteIndex 		; increment the write position.
.ca10	98		tya				tya 								; unchanged Y is now length
.ca11	a0 00		ldy #$00			ldy 	#0
.ca13	91 20		sta ($20),y			sta 	(zTempStr),y
.ca15	7a		ply				ply 								; restore Y and exit
.ca16	60		rts				rts
.ca17					CreateTempStringCopy:
.ca17	da		phx				phx 								; save X
.ca18	b1 16		lda ($16),y			lda 	(zCodePtr),y
.ca1a	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.ca1b	20 dc c9	jsr $c9dc			jsr 	AllocateTempString 			; allocate memory for temporary string.
.ca1e	b1 16		lda ($16),y			lda 	(zCodePtr),y
.ca20	c8		iny				iny
.ca21	3a		dec a				dec 	a 							; make the actual length in charactes
.ca22	3a		dec a				dec 	a
.ca23	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.ca25	81 20		sta ($20,x)			sta 	(zTempStr,x)
.ca27	85 1a		sta $1a				sta 	zLTemp1 					; that's used as a count.
.ca29	09 00		ora #$00			ora 	#0 							; if zero already, exit
.ca2b	f0 0d		beq $ca3a			beq 	_CTSCExit
.ca2d					_CTSCLoop:
.ca2d	b1 16		lda ($16),y			lda 	(zCodePtr),y
.ca2f	c8		iny				iny
.ca30	5a		phy				phy 								; save in Y
.ca31	e8		inx				inx 								; bump index
.ca32	9b		txy				txy 								; index into Y
.ca33	91 20		sta ($20),y			sta 	(zTempStr),y 				; save at index
.ca35	7a		ply				ply 								; restore Y
.ca36	c6 1a		dec $1a				dec 	zLTemp1 					; do for each character
.ca38	d0 f3		bne $ca2d			bne 	_CTSCLoop
.ca3a					_CTSCExit:
.ca3a	fa		plx				plx 								; restore X
.ca3b	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.ca3c					MulInteger32:
.ca3c	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.ca3f	9d 0c 03	sta $030c,x			sta 	XS3_Mantissa,x
.ca42	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.ca45	9d 0d 03	sta $030d,x			sta 	XS3_Mantissa+1,x
.ca48	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.ca4b	9d 0e 03	sta $030e,x			sta 	XS3_Mantissa+2,x
.ca4e	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.ca51	9d 0f 03	sta $030f,x			sta 	XS3_Mantissa+3,x
.ca54	a9 00		lda #$00			lda 	#0
.ca56	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x 				; zero +0
.ca59	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.ca5c	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.ca5f	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.ca62					_BFMMultiply:
.ca62	bd 0c 03	lda $030c,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.ca65	29 01		and #$01			and 	#1
.ca67	f0 03		beq $ca6c			beq 	_BFMNoAdd
.ca69	20 a0 c7	jsr $c7a0			jsr 	AddInteger32
.ca6c					_BFMNoAdd:
.ca6c	1e 06 03	asl $0306,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.ca6f	3e 07 03	rol $0307,x			rol 	XS2_Mantissa+1,x
.ca72	3e 08 03	rol $0308,x			rol 	XS2_Mantissa+2,x
.ca75	3e 09 03	rol $0309,x			rol 	XS2_Mantissa+3,x
.ca78	5e 0f 03	lsr $030f,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.ca7b	7e 0e 03	ror $030e,x			ror 	XS3_Mantissa+2,x
.ca7e	7e 0d 03	ror $030d,x			ror 	XS3_Mantissa+1,x
.ca81	7e 0c 03	ror $030c,x			ror 	XS3_Mantissa,x
.ca84	bd 0c 03	lda $030c,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.ca87	1d 0d 03	ora $030d,x			ora 	XS3_Mantissa+1,x
.ca8a	1d 0e 03	ora $030e,x			ora 	XS3_Mantissa+2,x
.ca8d	1d 0f 03	ora $030f,x			ora 	XS3_Mantissa+3,x
.ca90	d0 d0		bne $ca62			bne 	_BFMMultiply
.ca92	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.ca93					DivInteger32:
.ca93	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x 			; check for /0
.ca96	1d 07 03	ora $0307,x			ora 	XS2_Mantissa+1,x
.ca99	1d 08 03	ora $0308,x			ora 	XS2_Mantissa+2,x
.ca9c	1d 09 03	ora $0309,x			ora 	XS2_Mantissa+3,x
.ca9f	d0 02		bne $caa3			bne 	_BFDOkay
.caa1	80 fe		bra $caa1		_error: bra _error
.caa3					_BFDOkay:
.caa3	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.caa5	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.caa7	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.caa9	85 1c		sta $1c				sta 	zLTemp1+2
.caab	85 1d		sta $1d				sta 	zLTemp1+3
.caad	8d 25 04	sta $0425			sta 	SignCount 					; Count of signs.
.cab0	20 11 cb	jsr $cb11			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.cab3	da		phx				phx
.cab4	e8		inx				inx
.cab5	e8		inx				inx
.cab6	e8		inx				inx
.cab7	e8		inx				inx
.cab8	e8		inx				inx
.cab9	e8		inx				inx
.caba	20 11 cb	jsr $cb11			jsr 	CheckIntegerNegate
.cabd	fa		plx				plx
.cabe	5a		phy				phy 								; Y is the counter
.cabf	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.cac1					_BFDLoop:
.cac1	1e 00 03	asl $0300,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.cac4	3e 01 03	rol $0301,x			rol 	XS_Mantissa+1,x
.cac7	3e 02 03	rol $0302,x			rol 	XS_Mantissa+2,x
.caca	3e 03 03	rol $0303,x			rol 	XS_Mantissa+3,x
.cacd	26 1a		rol $1a				rol 	zLTemp1
.cacf	26 1b		rol $1b				rol 	zLTemp1+1
.cad1	26 1c		rol $1c				rol 	zLTemp1+2
.cad3	26 1d		rol $1d				rol 	zLTemp1+3
.cad5	38		sec				sec
.cad6	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.cad8	fd 06 03	sbc $0306,x			sbc 	XS2_Mantissa+0,x
.cadb	48		pha				pha
.cadc	a5 1b		lda $1b				lda 	zLTemp1+1
.cade	fd 07 03	sbc $0307,x			sbc 	XS2_Mantissa+1,x
.cae1	48		pha				pha
.cae2	a5 1c		lda $1c				lda 	zLTemp1+2
.cae4	fd 08 03	sbc $0308,x			sbc 	XS2_Mantissa+2,x
.cae7	48		pha				pha
.cae8	a5 1d		lda $1d				lda 	zLTemp1+3
.caea	fd 09 03	sbc $0309,x			sbc 	XS2_Mantissa+3,x
.caed	90 15		bcc $cb04			bcc 	_BFDNoAdd
.caef	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.caf1	68		pla				pla
.caf2	85 1c		sta $1c				sta 	zLTemp1+2
.caf4	68		pla				pla
.caf5	85 1b		sta $1b				sta 	zLTemp1+1
.caf7	68		pla				pla
.caf8	85 1a		sta $1a				sta 	zLTemp1+0
.cafa	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.cafd	09 01		ora #$01			ora 	#1
.caff	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.cb02	80 03		bra $cb07			bra 	_BFDNext
.cb04					_BFDNoAdd:
.cb04	68		pla				pla 								; Throw away the intermediate calculations
.cb05	68		pla				pla
.cb06	68		pla				pla
.cb07					_BFDNext:
.cb07	88		dey				dey
.cb08	d0 b7		bne $cac1			bne 	_BFDLoop
.cb0a	7a		ply				ply 								; restore Y and exit
.cb0b	4e 25 04	lsr $0425			lsr 	SignCount 					; if sign count odd,
.cb0e	b0 07		bcs $cb17			bcs		IntegerNegateAlways 			; negate the result
.cb10	60		rts				rts
.cb11					CheckIntegerNegate:
.cb11	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.cb14	30 01		bmi $cb17			bmi 	IntegerNegateAlways
.cb16	60		rts				rts
.cb17					IntegerNegateAlways:
.cb17	ee 25 04	inc $0425			inc 	SignCount
.cb1a	38		sec				sec
.cb1b	a9 00		lda #$00			lda 	#0
.cb1d	fd 00 03	sbc $0300,x			sbc 	XS_Mantissa+0,x
.cb20	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.cb23	a9 00		lda #$00			lda 	#0
.cb25	fd 01 03	sbc $0301,x			sbc 	XS_Mantissa+1,x
.cb28	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.cb2b	a9 00		lda #$00			lda 	#0
.cb2d	fd 02 03	sbc $0302,x			sbc 	XS_Mantissa+2,x
.cb30	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cb33	a9 00		lda #$00			lda 	#0
.cb35	fd 03 03	sbc $0303,x			sbc 	XS_Mantissa+3,x
.cb38	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.cb3b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.cb3c					INTToString:
.cb3c	48		pha				pha
.cb3d	5a		phy				phy
.cb3e	bd 03 03	lda $0303,x			lda 		XS_Mantissa+3,x 		; check -ve
.cb41	10 08		bpl $cb4b			bpl 		_ITSNotMinus
.cb43	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.cb45	20 d8 cb	jsr $cbd8			jsr 		ITSOutputCharacter
.cb48	20 17 cb	jsr $cb17			jsr 		IntegerNegateAlways 	; negate the number.
.cb4b					_ITSNotMinus:
.cb4b	a9 00		lda #$00			lda 		#0 						; X is offset in table.
.cb4d	8d 21 04	sta $0421			sta 		NumSuppress 			; clear the suppression flag.
.cb50	a0 00		ldy #$00			ldy 		#0 						; Y is index into dword subtraction table.
.cb52					_ITSNextSubtractor:
.cb52	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.cb54	8d 22 04	sta $0422			sta 		NumConvCount
.cb57					_ITSSubtract:
.cb57	38		sec				sec
.cb58	bd 00 03	lda $0300,x			lda 		XS_Mantissa,x 			; subtract number and push on stack
.cb5b	f9 b4 cb	sbc $cbb4,y			sbc 		_ITSSubtractors+0,y
.cb5e	48		pha				pha
.cb5f	bd 01 03	lda $0301,x			lda 		XS_Mantissa+1,x
.cb62	f9 b5 cb	sbc $cbb5,y			sbc 		_ITSSubtractors+1,y
.cb65	48		pha				pha
.cb66	bd 02 03	lda $0302,x			lda 		XS_Mantissa+2,x
.cb69	f9 b6 cb	sbc $cbb6,y			sbc 		_ITSSubtractors+2,y
.cb6c	48		pha				pha
.cb6d	bd 03 03	lda $0303,x			lda 		XS_Mantissa+3,x
.cb70	f9 b7 cb	sbc $cbb7,y			sbc 		_ITSSubtractors+3,y
.cb73	90 14		bcc $cb89			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.cb75	9d 03 03	sta $0303,x			sta 		XS_Mantissa+3,x 		; save subtract off stack
.cb78	68		pla				pla
.cb79	9d 02 03	sta $0302,x			sta 		XS_Mantissa+2,x
.cb7c	68		pla				pla
.cb7d	9d 01 03	sta $0301,x			sta 		XS_Mantissa+1,x
.cb80	68		pla				pla
.cb81	9d 00 03	sta $0300,x			sta 		XS_Mantissa+0,x
.cb84	ee 22 04	inc $0422			inc 		NumConvCount 			; bump count.
.cb87	80 ce		bra $cb57			bra 		_ITSSubtract 			; go round again.
.cb89					_ITSCantSubtract:
.cb89	68		pla				pla 								; throw away interim answers
.cb8a	68		pla				pla
.cb8b	68		pla				pla
.cb8c	ad 22 04	lda $0422			lda 		NumConvCount 			; if not zero then no suppression check
.cb8f	c9 30		cmp #$30			cmp 		#"0"
.cb91	d0 05		bne $cb98			bne 		_ITSOutputDigit
.cb93	ad 21 04	lda $0421			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.cb96	10 09		bpl $cba1			bpl 		_ITSGoNextSubtractor
.cb98					_ITSOutputDigit:
.cb98	ce 21 04	dec $0421			dec 		NumSuppress 			; suppression check will be non-zero.
.cb9b	ad 22 04	lda $0422			lda 		NumConvCount 			; count of subtractions
.cb9e	20 d8 cb	jsr $cbd8			jsr 		ITSOutputCharacter 		; output it.
.cba1					_ITSGoNextSubtractor:
.cba1	c8		iny				iny 								; next dword
.cba2	c8		iny				iny
.cba3	c8		iny				iny
.cba4	c8		iny				iny
.cba5	c0 24		cpy #$24			cpy 		#_ITSSubtractorsEnd-_ITSSubtractors
.cba7	d0 a9		bne $cb52			bne 		_ITSNextSubtractor 		; do all the subtractors.
.cba9	bd 00 03	lda $0300,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.cbac	09 30		ora #$30			ora 		#"0"
.cbae	20 d8 cb	jsr $cbd8			jsr 		ITSOutputCharacter
.cbb1	7a		ply				ply 								; and exit
.cbb2	68		pla				pla
.cbb3	60		rts				rts
.cbb4					_ITSSubtractors:
>cbb4	00 ca 9a 3b					.dword 		1000000000
>cbb8	00 e1 f5 05					.dword 		100000000
>cbbc	80 96 98 00					.dword 		10000000
>cbc0	40 42 0f 00					.dword 		1000000
>cbc4	a0 86 01 00					.dword 		100000
>cbc8	10 27 00 00					.dword 		10000
>cbcc	e8 03 00 00					.dword 		1000
>cbd0	64 00 00 00					.dword 		100
>cbd4	0a 00 00 00					.dword 		10
.cbd8					_ITSSubtractorsEnd:
.cbd8					ITSOutputCharacter:
.cbd8	48		pha				pha
.cbd9	da		phx				phx
.cbda	ae 20 04	ldx $0420			ldx 	NumBufX 					; save digit
.cbdd	9d 00 04	sta $0400,x			sta 	Num_Buffer,x
.cbe0	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.cbe2	9d 01 04	sta $0401,x			sta 	Num_Buffer+1,x
.cbe5	ee 20 04	inc $0420			inc 	NumBufX						; bump pointer.
.cbe8	fa		plx				plx
.cbe9	68		pla				pla
.cbea	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.cbeb					IntFromString:
.cbeb	a0 00		ldy #$00			ldy 	#0
.cbed	8c 23 04	sty $0423			sty 	ExpTemp 					; this is the converted digit count.
.cbf0					IntFromStringY:
.cbf0	48		pha				pha
.cbf1	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.cbf3	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.cbf6	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.cbf9	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cbfc	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.cbff	a9 01		lda #$01			lda 	#1
.cc01	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cc04					_IFSLoop:
.cc04	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.cc06	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.cc08	90 60		bcc $cc6a			bcc 	_IFSExit
.cc0a	c9 3a		cmp #$3a			cmp 	#"9"+1
.cc0c	b0 5c		bcs $cc6a			bcs 	_IFSExit
.cc0e	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.cc11	c9 0c		cmp #$0c			cmp 	#12
.cc13	b0 5f		bcs $cc74			bcs 	_IFSOverflow
.cc15	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.cc18	48		pha				pha
.cc19	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.cc1c	48		pha				pha
.cc1d	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.cc20	48		pha				pha
.cc21	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.cc24	48		pha				pha
.cc25	20 89 cc	jsr $cc89			jsr 	IFSX1ShiftLeft 				; double
.cc28	20 89 cc	jsr $cc89			jsr 	IFSX1ShiftLeft 				; x 4
.cc2b	18		clc				clc 								; add saved value x 5
.cc2c	68		pla				pla
.cc2d	7d 00 03	adc $0300,x			adc 	XS_Mantissa+0,x
.cc30	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.cc33	68		pla				pla
.cc34	7d 01 03	adc $0301,x			adc 	XS_Mantissa+1,x
.cc37	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.cc3a	68		pla				pla
.cc3b	7d 02 03	adc $0302,x			adc 	XS_Mantissa+2,x
.cc3e	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cc41	68		pla				pla
.cc42	7d 03 03	adc $0303,x			adc 	XS_Mantissa+3,x
.cc45	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.cc48	20 89 cc	jsr $cc89			jsr 	IFSX1ShiftLeft 				; x 10
.cc4b	ee 23 04	inc $0423			inc 	ExpTemp 					; bump count of digits processed.
.cc4e	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.cc50	29 0f		and #$0f			and 	#15
.cc52	c8		iny				iny
.cc53	7d 00 03	adc $0300,x			adc 	XS_Mantissa+0,x
.cc56	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.cc59	90 a9		bcc $cc04			bcc 	_IFSLoop
.cc5b	fe 01 03	inc $0301,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.cc5e	d0 a4		bne $cc04			bne 	_IFSLoop
.cc60	fe 02 03	inc $0302,x			inc 	XS_Mantissa+2,x
.cc63	d0 9f		bne $cc04			bne 	_IFSLoop
.cc65	fe 03 03	inc $0303,x			inc 	XS_Mantissa+3,x
.cc68	80 9a		bra $cc04			bra 	_IFSLoop
.cc6a					_IFSExit:
.cc6a	98		tya				tya 								; get offset
.cc6b					_IFSOkay:
.cc6b	38		sec				sec
.cc6c	ad 23 04	lda $0423			lda 	ExpTemp
.cc6f	f0 01		beq $cc72			beq 	_IFSSkipFail
.cc71	18		clc				clc
.cc72					_IFSSkipFail:
.cc72	68		pla				pla 								; and exit.
.cc73	60		rts				rts
.cc74					_IFSOverflow:
.cc74	20 16 c4	jsr $c416			jsr 	ERR_Handler
>cc77	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>cc7f	20 6f 76 65 72 66 6c 6f 77 00
.cc89					IFSX1ShiftLeft:
.cc89	1e 00 03	asl $0300,x			asl 	XS_Mantissa+0,x
.cc8c	3e 01 03	rol $0301,x			rol 	XS_Mantissa+1,x
.cc8f	3e 02 03	rol $0302,x			rol 	XS_Mantissa+2,x
.cc92	3e 03 03	rol $0303,x			rol 	XS_Mantissa+3,x
.cc95	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.cc96					FPSubtract:
.cc96	48		pha				pha
.cc97	bd 0b 03	lda $030b,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.cc9a	49 80		eor #$80			eor 	#$80
.cc9c	9d 0b 03	sta $030b,x			sta 	XS2_Type,x
.cc9f	68		pla				pla 								; --- and fall through ---
.cca0					FPAdd:
.cca0	48		pha				pha
.cca1	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.cca4	d0 05		bne $ccab			bne 	_FPA_NegativeLHS
.cca6	20 c8 cc	jsr $ccc8			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.cca9	68		pla				pla
.ccaa	60		rts				rts
.ccab					_FPA_NegativeLHS:
.ccab	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.ccae	49 80		eor #$80			eor 	#$80
.ccb0	9d 05 03	sta $0305,x			sta 	XS_Type,x
.ccb3	bd 0b 03	lda $030b,x			lda 	XS2_Type,x 					; flip the sign of B and add
.ccb6	49 80		eor #$80			eor 	#$80
.ccb8	9d 0b 03	sta $030b,x			sta 	XS2_Type,x
.ccbb	20 c8 cc	jsr $ccc8			jsr 	FPAdd_Worker 				; do the add calculation.
.ccbe	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; flip sign of X1 back
.ccc1	49 80		eor #$80			eor 	#$80
.ccc3	9d 05 03	sta $0305,x			sta 	XS_Type,x
.ccc6	68		pla				pla
.ccc7	60		rts				rts
.ccc8					FPAdd_Worker:
.ccc8	3c 0b 03	bit $030b,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.cccb	70 08		bvs $ccd5			bvs 	_FPAWExit 					; no change.
.cccd	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.ccd0	50 07		bvc $ccd9			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.ccd2	20 5b cf	jsr $cf5b			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.ccd5					_FPAWExit:
.ccd5	20 e3 cf	jsr $cfe3			jsr 	FPUNormalise 				; normalise the result.
.ccd8	60		rts				rts
.ccd9					_FPAWMakeSame:
.ccd9	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.ccdc	38		sec				sec
.ccdd	fd 0a 03	sbc $030a,x			sbc	 	XS2_Exponent,x 				; using subtraction
.cce0	f0 1b		beq $ccfd			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.cce2	da		phx				phx 								; save X
.cce3	90 06		bcc $cceb			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.cce5	e8		inx				inx
.cce6	e8		inx				inx
.cce7	e8		inx				inx
.cce8	e8		inx				inx
.cce9	e8		inx				inx
.ccea	e8		inx				inx
.cceb					_FPAWShiftA:
.cceb	fe 04 03	inc $0304,x			inc 	XS_Exponent,x 				; so shift exponent up.
.ccee	5e 03 03	lsr $0303,x			lsr 	3+XS_Mantissa,x
.ccf1	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.ccf4	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.ccf7	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.ccfa	fa		plx				plx 								; restore original X
.ccfb	80 dc		bra $ccd9			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.ccfd					_FPAW_DoArithmetic:
.ccfd	3c 0b 03	bit $030b,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.cd00	30 39		bmi $cd3b			bmi 	_FPAW_BNegative
.cd02	18		clc				clc
.cd03	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.cd06	7d 06 03	adc $0306,x			adc 	XS2_Mantissa+0,x
.cd09	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.cd0c	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.cd0f	7d 07 03	adc $0307,x			adc 	XS2_Mantissa+1,x
.cd12	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.cd15	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.cd18	7d 08 03	adc $0308,x			adc 	XS2_Mantissa+2,x
.cd1b	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cd1e	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.cd21	7d 09 03	adc $0309,x			adc 	XS2_Mantissa+3,x
.cd24	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.cd27	90 ac		bcc $ccd5			bcc 	_FPAWExit 					; no carry.
.cd29	fe 04 03	inc $0304,x			inc 	XS_Exponent,x 				; so shift exponent up.
.cd2c	38		sec				sec
.cd2d	7e 03 03	ror $0303,x			ror 	3+XS_Mantissa,x
.cd30	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.cd33	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.cd36	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.cd39	80 9a		bra $ccd5			bra 	_FPAWExit
.cd3b					_FPAW_BNegative:
.cd3b	38		sec				sec
.cd3c	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.cd3f	fd 06 03	sbc $0306,x			sbc 	XS2_Mantissa+0,x
.cd42	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.cd45	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.cd48	fd 07 03	sbc $0307,x			sbc 	XS2_Mantissa+1,x
.cd4b	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.cd4e	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.cd51	fd 08 03	sbc $0308,x			sbc 	XS2_Mantissa+2,x
.cd54	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cd57	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.cd5a	fd 09 03	sbc $0309,x			sbc 	XS2_Mantissa+3,x
.cd5d	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.cd60	b0 0b		bcs $cd6d			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.cd62	20 88 cf	jsr $cf88			jsr 	FPUNegateInteger			; negate the mantissa
.cd65	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; flip result sign
.cd68	49 80		eor #$80			eor 	#$80
.cd6a	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cd6d					_FPAWGoExit:
.cd6d	4c d5 cc	jmp $ccd5			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.cd70					FPD_IsDivZero:
.cd70	80 fe		bra $cd70		_error: bra _error
.cd72					FPDivide:
.cd72	48		pha				pha
.cd73	5a		phy				phy
.cd74	3c 0b 03	bit $030b,x			bit 	XS2_Type,x 					; check if division by zero
.cd77	70 f7		bvs $cd70			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.cd79	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.cd7c	f0 03		beq $cd81			beq 	_FPDCalculateExp
.cd7e					_FPD_Exit:
.cd7e	7a		ply				ply
.cd7f	68		pla				pla
.cd80	60		rts				rts
.cd81					_FPDCalculateExp:
.cd81	bd 0a 03	lda $030a,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.cd84	49 ff		eor #$ff			eor 	#$FF
.cd86	1a		inc a				inc 	a
.cd87	9d 0a 03	sta $030a,x			sta 	XS2_Exponent,x
.cd8a	20 7e ce	jsr $ce7e			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.cd8d	18		clc				clc 	 							; add 1 to the resulting exponent
.cd8e	69 01		adc #$01			adc 	#1
.cd90	b0 65		bcs $cdf7			bcs 	_FPD_Overflow 				; which can overflow.
.cd92	9d 04 03	sta $0304,x			sta 	XS_Exponent,x
.cd95	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.cd97	85 1a		sta $1a				sta 	zLTemp1+0
.cd99	85 1b		sta $1b				sta 	zLTemp1+1
.cd9b	85 1c		sta $1c				sta 	zLTemp1+2
.cd9d	85 1d		sta $1d				sta 	zLTemp1+3
.cd9f	a0 20		ldy #$20			ldy 	#32 						; times round.
.cda1					_FPD_Loop:
.cda1	38		sec				sec 								; calculate X1-X2 stacking result because we might
.cda2	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x 				; not save it.
.cda5	fd 06 03	sbc $0306,x			sbc 	XS2_Mantissa,x
.cda8	48		pha				pha
.cda9	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.cdac	fd 07 03	sbc $0307,x			sbc 	XS2_Mantissa+1,x
.cdaf	48		pha				pha
.cdb0	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.cdb3	fd 08 03	sbc $0308,x			sbc 	XS2_Mantissa+2,x
.cdb6	48		pha				pha
.cdb7	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.cdba	fd 09 03	sbc $0309,x			sbc 	XS2_Mantissa+3,x
.cdbd	90 17		bcc $cdd6			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.cdbf	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x 			; save results out to A
.cdc2	68		pla				pla
.cdc3	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cdc6	68		pla				pla
.cdc7	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.cdca	68		pla				pla
.cdcb	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.cdce	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.cdd0	09 80		ora #$80			ora 	#$80
.cdd2	85 1d		sta $1d				sta 	zLTemp1+3
.cdd4	80 03		bra $cdd9			bra 	_FPD_Rotates
.cdd6					_FPD_NoSubtract:
.cdd6	68		pla				pla 								; throw away unwanted results
.cdd7	68		pla				pla
.cdd8	68		pla				pla
.cdd9					_FPD_Rotates:
.cdd9	5e 09 03	lsr $0309,x			lsr 	3+XS2_Mantissa,x
.cddc	7e 08 03	ror $0308,x			ror 	2+XS2_Mantissa,x
.cddf	7e 07 03	ror $0307,x			ror 	1+XS2_Mantissa,x
.cde2	7e 06 03	ror $0306,x			ror 	0+XS2_Mantissa,x
.cde5	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.cde7	26 1b		rol $1b				rol 	zLTemp1+1
.cde9	26 1c		rol $1c				rol 	zLTemp1+2
.cdeb	26 1d		rol $1d				rol 	zLTemp1+3
.cded	90 02		bcc $cdf1			bcc 	_FPD_NoCarry
.cdef	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.cdf1					_FPD_NoCarry:
.cdf1	88		dey				dey 								; do 32 times
.cdf2	d0 ad		bne $cda1			bne 	_FPD_Loop
.cdf4	4c 5b ce	jmp $ce5b			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.cdf7					_FPD_Overflow:
.cdf7	4c 58 d0	jmp $d058			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.cdfa					FPMultiply:
.cdfa	48		pha				pha
.cdfb	5a		phy				phy
.cdfc	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.cdff	70 08		bvs $ce09			bvs 	_FPM_Exit
.ce01	3c 0b 03	bit $030b,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.ce04	50 06		bvc $ce0c			bvc 	_FPM_CalcExponent
.ce06	20 5b cf	jsr $cf5b			jsr 	FPUCopyX2ToX1
.ce09					_FPM_Exit:
.ce09	7a		ply				ply
.ce0a	68		pla				pla
.ce0b	60		rts				rts
.ce0c					_FPM_CalcExponent:
.ce0c	18		clc				clc
.ce0d	20 7e ce	jsr $ce7e			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.ce10	9d 04 03	sta $0304,x			sta 	XS_Exponent,x 				; save the result.
.ce13	a9 00		lda #$00			lda 	#0
.ce15	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.ce17	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.ce19	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.ce1b	85 1d		sta $1d				sta 	zLTemp1+3
.ce1d	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.ce1f					_FPM_Loop:
.ce1f	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x				; check LSB of long product
.ce22	29 01		and #$01			and 	#1
.ce24	18		clc				clc 								; clear carry for the long rotate.
.ce25	f0 1d		beq $ce44			beq 	_FPM_NoAddition
.ce27	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.ce28	a5 1a		lda $1a				lda 	zLTemp1+0
.ce2a	7d 06 03	adc $0306,x			adc 	XS2_Mantissa+0,x
.ce2d	85 1a		sta $1a				sta 	zLTemp1+0
.ce2f	a5 1b		lda $1b				lda 	zLTemp1+1
.ce31	7d 07 03	adc $0307,x			adc 	XS2_Mantissa+1,x
.ce34	85 1b		sta $1b				sta 	zLTemp1+1
.ce36	a5 1c		lda $1c				lda 	zLTemp1+2
.ce38	7d 08 03	adc $0308,x			adc 	XS2_Mantissa+2,x
.ce3b	85 1c		sta $1c				sta 	zLTemp1+2
.ce3d	a5 1d		lda $1d				lda 	zLTemp1+3
.ce3f	7d 09 03	adc $0309,x			adc 	XS2_Mantissa+3,x
.ce42	85 1d		sta $1d				sta 	zLTemp1+3
.ce44					_FPM_NoAddition:
.ce44	66 1d		ror $1d				ror 	3+zLTemp1
.ce46	66 1c		ror $1c				ror 	2+zLTemp1
.ce48	66 1b		ror $1b				ror 	1+zLTemp1
.ce4a	66 1a		ror $1a				ror 	0+zLTemp1
.ce4c	7e 03 03	ror $0303,x			ror 	3+XS_Mantissa,x
.ce4f	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.ce52	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.ce55	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.ce58	88		dey				dey
.ce59	d0 c4		bne $ce1f			bne 	_FPM_Loop 					; do this 32 times.
.ce5b					FPM_CopySignNormalize:
.ce5b	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.ce5d	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.ce60	a5 1b		lda $1b				lda 	zLTemp1+1
.ce62	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.ce65	a5 1c		lda $1c				lda 	zLTemp1+2
.ce67	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.ce6a	a5 1d		lda $1d				lda 	zLTemp1+3
.ce6c	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.ce6f	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; sign is xor of signs
.ce72	5d 0b 03	eor $030b,x			eor 	XS2_Type,x
.ce75	9d 05 03	sta $0305,x			sta 	XS_Type,x
.ce78	20 e3 cf	jsr $cfe3			jsr 	FPUNormalise 				; normalise and exit.
.ce7b	7a		ply				ply
.ce7c	68		pla				pla
.ce7d	60		rts				rts
.ce7e					FPCalculateExponent:
.ce7e	18		clc				clc
.ce7f	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.ce82	7d 0a 03	adc $030a,x			adc 	XS2_Exponent,x
.ce85	b0 08		bcs $ce8f			bcs 	_FPCECarry 					; carry out ?
.ce87	10 03		bpl $ce8c			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.ce89	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.ce8b	60		rts				rts
.ce8c					_FPCEExpZero:
.ce8c	a9 00		lda #$00			lda 	#0
.ce8e	60		rts				rts
.ce8f					_FPCECarry:
.ce8f	30 03		bmi $ce94			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.ce91	09 80		ora #$80			ora 	#$80 						; put in right range
.ce93	60		rts				rts
.ce94					_FPCEOverflow:
.ce94	4c 58 d0	jmp $d058			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.ce97					FPFractionalPart:
.ce97	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.ce9a	38		sec				sec 								; this flag tells us to keep the fractional part
.ce9b	30 0f		bmi $ceac			bmi 	FPGetPart
.ce9d	60		rts				rts
.ce9e					FPIntegerPart:
.ce9e	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.cea1	18		clc				clc 								; this flag says keep the integer part.
.cea2	30 08		bmi $ceac			bmi 	FPGetPart 					; -ve exponents are 0..127
.cea4	48		pha				pha
.cea5	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.cea7	9d 05 03	sta $0305,x			sta 	XS_Type,x
.ceaa	68		pla				pla
.ceab	60		rts				rts
.ceac					FPGetPart:
.ceac	48		pha				pha
.cead	5a		phy				phy 								; save Y
.ceae	08		php				php 								; save action
.ceaf	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.ceb2	70 62		bvs $cf16			bvs 	_FPGP_Exit 					; then do nothing.
.ceb4	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.ceb6	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.ceb8	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.ceba	85 1c		sta $1c				sta 	zLTemp1+2
.cebc	85 1d		sta $1d				sta 	zLTemp1+3
.cebe	bd 04 03	lda $0304,x			lda 	XS_Exponent,x				; the number of shifts.
.cec1	38		sec				sec
.cec2	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.cec4	f0 12		beq $ced8			beq 	_FPGP_NoShift 				; ... if any
.cec6	c9 20		cmp #$20			cmp 	#32
.cec8	90 02		bcc $cecc			bcc 	_FPGP_NotMax
.ceca	a9 20		lda #$20			lda 	#32 						; max of 32.
.cecc					_FPGP_NotMax:
.cecc	a8		tay				tay 								; Y is the mask shift count.
.cecd					_FPGP_ShiftMask:
.cecd	46 1d		lsr $1d				lsr 	3+zLTemp1
.cecf	66 1c		ror $1c				ror 	2+zLTemp1
.ced1	66 1b		ror $1b				ror 	1+zLTemp1
.ced3	66 1a		ror $1a				ror 	0+zLTemp1
.ced5	88		dey				dey
.ced6	d0 f5		bne $cecd			bne 	_FPGP_ShiftMask
.ced8					_FPGP_NoShift:
.ced8	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.ceda	8e 23 04	stx $0423			stx 	ExpTemp						; save X
.cedd					_FPGP_MaskLoop:
.cedd	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.cee0	28		plp				plp 								; if CC we keep the top part, so we
.cee1	08		php				php		 							; flip the mask.
.cee2	b0 02		bcs $cee6			bcs		_FPGP_NoFlip
.cee4	49 ff		eor #$ff			eor 	#$FF
.cee6					_FPGP_NoFlip:
.cee6	3d 00 03	and $0300,x			and 	XS_Mantissa,x 				; and into the mantissa.
.cee9	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.ceec	e8		inx				inx
.ceed	c8		iny				iny
.ceee	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.cef0	d0 eb		bne $cedd			bne 	_FPGP_MaskLoop
.cef2	ae 23 04	ldx $0423			ldx 	ExpTemp						; restore X
.cef5	28		plp				plp
.cef6	08		php				php 								; get action flag on the stack
.cef7	90 05		bcc $cefe			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.cef9	a9 00		lda #$00			lda 	#0
.cefb	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cefe					_FPGP_NotFractional:
.cefe	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x 						; check if \1 zero
.cf01	1d 01 03	ora $0301,x			ora 	XS_Mantissa+1,x
.cf04	1d 02 03	ora $0302,x			ora 	XS_Mantissa+2,x
.cf07	1d 03 03	ora $0303,x			ora 	XS_Mantissa+3,x
.cf0a	f0 05		beq $cf11			beq 	_FPGP_Zero 					; if zero, return zero
.cf0c	20 e3 cf	jsr $cfe3			jsr 	FPUNormalise
.cf0f	80 05		bra $cf16			bra 	_FPGP_Exit 					; and exit
.cf11					_FPGP_Zero:
.cf11	a9 40		lda #$40			lda 	#$40 						; set zero flag
.cf13	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cf16					_FPGP_Exit:
.cf16	68		pla				pla 								; throw saved action flag.
.cf17	7a		ply				ply
.cf18	68		pla				pla
.cf19	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.cf1a					FPCompare:
.cf1a	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.cf1d	48		pha				pha
.cf1e	bd 0a 03	lda $030a,x			lda 	XS2_Exponent,x
.cf21	48		pha				pha
.cf22	20 96 cc	jsr $cc96			jsr 	FPSubtract 					; calculate X1-X2
.cf25	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.cf28	70 2c		bvs $cf56			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.cf2a	68		pla				pla
.cf2b	8d 23 04	sta $0423			sta 	ExpTemp						; save first exponent in temporary reg.
.cf2e	68		pla				pla
.cf2f	38		sec				sec
.cf30	ed 23 04	sbc $0423			sbc 	ExpTemp 					; calculate AX-BX
.cf33	70 15		bvs $cf4a			bvs 	_FPCNotEqual				; overflow, can't be equal.
.cf35	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.cf36	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.cf38	b0 10		bcs $cf4a			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.cf3a	38		sec				sec
.cf3b	ad 23 04	lda $0423			lda 	ExpTemp 					; get one of the exponents back.
.cf3e	e9 18		sbc #$18			sbc 	#24 						; allow for 2^24 error, relatively.
.cf40	b0 02		bcs $cf44			bcs 	_FPCNotRange 				; keep in range.
.cf42	a9 01		lda #$01			lda 	#1
.cf44					_FPCNotRange:
.cf44	38		sec				sec
.cf45	fd 04 03	sbc $0304,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.cf48	b0 0e		bcs $cf58			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.cf4a					_FPCNotEqual:
.cf4a	bd 05 03	lda $0305,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.cf4d	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.cf4f	f0 02		beq $cf53			beq 	_FPCNE2
.cf51	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.cf53	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.cf54	80 04		bra $cf5a			bra 	_FPCExit
.cf56					_FPCPullZero:
.cf56	68		pla				pla 								; throw saved exponents
.cf57	68		pla				pla
.cf58					_FPCZero:
.cf58	a9 00		lda #$00			lda 	#0 							; and return zero
.cf5a					_FPCExit:
.cf5a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.cf5b					FPUCopyX2ToX1:
.cf5b	48		pha				pha
.cf5c	da		phx				phx
.cf5d	5a		phy				phy
.cf5e	a0 08		ldy #$08			ldy 	#8
.cf60	bd 06 03	lda $0306,x	_FPUC21:lda 	XS2_Mantissa,x
.cf63	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.cf66	e8		inx				inx
.cf67	88		dey				dey
.cf68	10 f6		bpl $cf60			bpl 	_FPUC21
.cf6a	7a		ply				ply
.cf6b	fa		plx				plx
.cf6c	68		pla				pla
.cf6d	60		rts				rts
.cf6e					FPUSetInteger:
.cf6e	48		pha				pha
.cf6f	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.cf72	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.cf74	10 02		bpl $cf78			bpl 	_FPUSIExtend
.cf76	a9 ff		lda #$ff			lda 	#$FF
.cf78					_FPUSIExtend:
.cf78	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.cf7b	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cf7e	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.cf81	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.cf83	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cf86	68		pla				pla
.cf87	60		rts				rts
.cf88					FPUNegateInteger:
.cf88	48		pha				pha
.cf89	38		sec				sec
.cf8a	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.cf8c	fd 00 03	sbc $0300,x			sbc 	XS_Mantissa+0,x
.cf8f	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.cf92	a9 00		lda #$00			lda 	#0
.cf94	fd 01 03	sbc $0301,x			sbc 	XS_Mantissa+1,x
.cf97	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.cf9a	a9 00		lda #$00			lda 	#0
.cf9c	fd 02 03	sbc $0302,x			sbc 	XS_Mantissa+2,x
.cf9f	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cfa2	a9 00		lda #$00			lda 	#0
.cfa4	fd 03 03	sbc $0303,x			sbc 	XS_Mantissa+3,x
.cfa7	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.cfaa	68		pla				pla
.cfab	60		rts				rts
.cfac					FPUToFloat:
.cfac	48		pha				pha
.cfad	bd 05 03	lda $0305,x			lda 	XS_Type,x					; exit if already float.
.cfb0	29 0f		and #$0f			and 	#$0F
.cfb2	f0 2d		beq $cfe1			beq 	_FPUFExit
.cfb4	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.cfb6	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cfb9	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.cfbb	9d 04 03	sta $0304,x			sta 	XS_Exponent,x 				; x mantissa.
.cfbe	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.cfc1	10 08		bpl $cfcb			bpl		_FPUFPositive
.cfc3	20 88 cf	jsr $cf88			jsr 	FPUNegateInteger 			; negate the mantissa
.cfc6	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.cfc8	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cfcb					_FPUFPositive:
.cfcb	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.cfce	1d 01 03	ora $0301,x			ora 	XS_Mantissa+1,x
.cfd1	1d 02 03	ora $0302,x			ora 	XS_Mantissa+2,x
.cfd4	1d 03 03	ora $0303,x			ora 	XS_Mantissa+3,x
.cfd7	d0 05		bne $cfde			bne 	_FPUFNonZero
.cfd9	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.cfdb	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cfde					_FPUFNonZero:
.cfde	20 e3 cf	jsr $cfe3			jsr 	FPUNormalise 				; normalise the floating point.
.cfe1					_FPUFExit:
.cfe1	68		pla				pla
.cfe2	60		rts				rts
.cfe3					FPUNormalise:
.cfe3	48		pha				pha
.cfe4	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.cfe7	70 20		bvs $d009			bvs 	_FPUNExit
.cfe9	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.cfec	f0 16		beq $d004			beq 	_FPUNSetZero
.cfee					_FPUNLoop:
.cfee	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.cff1	30 16		bmi $d009			bmi 	_FPUNExit 					; if so, we are normalised.
.cff3	1e 00 03	asl $0300,x			asl 	0+XS_Mantissa+0,x
.cff6	3e 01 03	rol $0301,x			rol 	1+XS_Mantissa+0,x
.cff9	3e 02 03	rol $0302,x			rol 	2+XS_Mantissa+0,x
.cffc	3e 03 03	rol $0303,x			rol 	3+XS_Mantissa+0,x
.cfff	de 04 03	dec $0304,x			dec 	XS_Exponent,x 				; decrement exponent
.d002	d0 ea		bne $cfee			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.d004					_FPUNSetZero:
.d004	a9 40		lda #$40			lda 	#$40
.d006	9d 05 03	sta $0305,x			sta 	XS_Type,x 					; the result is now zero.
.d009					_FPUNExit:
.d009	68		pla				pla
.d00a	60		rts				rts
.d00b					FPUToInteger:
.d00b	48		pha				pha
.d00c	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; if already integer, exit
.d00f	29 01		and #$01			and 	#1
.d011	d0 3e		bne $d051			bne 	_FPUTOI_Exit
.d013	3c 05 03	bit $0305,x			bit 	XS_Type,x					; if zero, return zero.
.d016	70 2b		bvs $d043			bvs 	_FPUTOI_Zero
.d018	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.d01b	10 26		bpl $d043			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.d01d	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.d01f	b0 37		bcs $d058			bcs 	FP_Overflow
.d021					_FPUToIToInteger:
.d021	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.d024	c9 a0		cmp #$a0			cmp 	#128+32
.d026	f0 11		beq $d039			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.d028	fe 04 03	inc $0304,x			inc 	XS_Exponent,X 				; increment Exponent
.d02b	5e 03 03	lsr $0303,x			lsr 	3+XS_Mantissa,x
.d02e	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.d031	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.d034	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.d037	80 e8		bra $d021			bra 	_FPUToIToInteger 			; keep going.
.d039					_FPUToICheckSign:
.d039	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; check sign
.d03c	10 13		bpl $d051			bpl 	_FPUToI_Exit 				; exit if unsigned.
.d03e	20 88 cf	jsr $cf88			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.d041	80 0e		bra $d051			bra 	_FPUTOI_Exit
.d043					_FPUTOI_Zero:
.d043	a9 00		lda #$00			lda 	#0 							; return zero integer.
.d045	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.d048	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.d04b	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.d04e	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.d051					_FPUToI_Exit:
.d051	a9 01		lda #$01			lda 	#1 							; set type to integer
.d053	9d 05 03	sta $0305,x			sta 	XS_Type,x
.d056	68		pla				pla
.d057	60		rts				rts
.d058					FP_Overflow:
.d058	80 fe		bra $d058		_error: bra _error
.d05a					FPUTimes10:
.d05a	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.d05d	85 1a		sta $1a				sta 	ZLTemp1+0
.d05f	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.d062	85 1b		sta $1b				sta 	ZLTemp1+1
.d064	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.d067	85 1c		sta $1c				sta 	ZLTemp1+2
.d069	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.d06c	85 1d		sta $1d				sta 	ZLTemp1+3
.d06e	20 b2 d0	jsr $d0b2			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.d071	20 b2 d0	jsr $d0b2			jsr 	_FPUT_LSR_ZLTemp1
.d074	18		clc				clc
.d075	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.d078	65 1a		adc $1a				adc 	ZLTemp1+0
.d07a	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.d07d	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.d080	65 1b		adc $1b				adc 	ZLTemp1+1
.d082	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.d085	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.d088	65 1c		adc $1c				adc 	ZLTemp1+2
.d08a	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.d08d	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.d090	65 1d		adc $1d				adc 	ZLTemp1+3
.d092	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.d095	90 0f		bcc $d0a6			bcc 	_FPUTimes10
.d097	7e 03 03	ror $0303,x			ror 	3+XS_Mantissa,x
.d09a	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.d09d	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.d0a0	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.d0a3	fe 04 03	inc $0304,x			inc 	XS_Exponent,x				; fix exponent
.d0a6					_FPUTimes10:
.d0a6	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.d0a9	18		clc				clc
.d0aa	69 03		adc #$03			adc 	#3
.d0ac	9d 04 03	sta $0304,x			sta 	XS_Exponent,x
.d0af	b0 a7		bcs $d058			bcs 	FP_Overflow 				; error
.d0b1	60		rts				rts
.d0b2					_FPUT_LSR_ZLTemp1:
.d0b2	46 1d		lsr $1d				lsr 	ZLTemp1+3
.d0b4	66 1c		ror $1c				ror 	ZLTemp1+2
.d0b6	66 1b		ror $1b				ror 	ZLTemp1+1
.d0b8	66 1a		ror $1a				ror 	ZLTemp1+0
.d0ba	60		rts				rts
.d0bb					FPUScale10A:
.d0bb	5a		phy				phy
.d0bc	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.d0be	f0 3d		beq $d0fd			beq 	_FPUScaleExit
.d0c0	da		phx				phx 								; save X
.d0c1	e8		inx				inx
.d0c2	e8		inx				inx
.d0c3	e8		inx				inx
.d0c4	e8		inx				inx
.d0c5	e8		inx				inx
.d0c6	e8		inx				inx
.d0c7	a8		tay				tay 								; save power scalar in Y.
.d0c8	a9 00		lda #$00			lda 	#0
.d0ca	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.d0cd	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.d0d0	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.d0d3	9d 05 03	sta $0305,x			sta 	XS_Type,x
.d0d6	a9 80		lda #$80			lda 	#$80
.d0d8	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.d0db	a9 81		lda #$81			lda 	#$81
.d0dd	9d 04 03	sta $0304,x			sta 	XS_Exponent,x
.d0e0	5a		phy				phy 								; save 10^n on stack.
.d0e1	c0 00		cpy #$00			cpy 	#0
.d0e3	10 05		bpl $d0ea			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.d0e5	98		tya				tya
.d0e6	49 ff		eor #$ff			eor 	#$FF
.d0e8	1a		inc a				inc 	a
.d0e9	a8		tay				tay
.d0ea					_FPUSAbs:
.d0ea	20 5a d0	jsr $d05a			jsr 	FPUTimes10
.d0ed	88		dey				dey
.d0ee	d0 fa		bne $d0ea			bne 	_FPUSAbs 					; tos is now 10^|AC|
.d0f0	68		pla				pla 								; restore count in A
.d0f1	fa		plx				plx 								; restore X pointing to number to scale.
.d0f2	0a		asl a				asl 	a
.d0f3	b0 05		bcs $d0fa			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.d0f5	20 fa cd	jsr $cdfa			jsr 	FPMultiply 					; if clear multiply.
.d0f8	80 03		bra $d0fd			bra		_FPUScaleExit
.d0fa					_FPUSDivide:
.d0fa	20 72 cd	jsr $cd72			jsr 	FPDivide
.d0fd					_FPUScaleExit:
.d0fd	7a		ply				ply
.d0fe	60		rts				rts
.d0ff					FPUCopyToNext:
.d0ff	a0 06		ldy #$06			ldy 		#6
.d101	da		phx				phx
.d102					_FPUCopy1:
.d102	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x
.d105	9d 06 03	sta $0306,x			sta 	XS2_Mantissa,x
.d108	e8		inx				inx
.d109	88		dey				dey
.d10a	d0 f6		bne $d102			bne 	_FPUCopy1
.d10c	fa		plx				plx
.d10d	60		rts				rts
.d10e					FPUCopyFromNext:
.d10e	a0 06		ldy #$06			ldy 		#6
.d110	da		phx				phx
.d111					_FPUCopy1:
.d111	bd 06 03	lda $0306,x			lda 	XS2_Mantissa,x
.d114	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.d117	e8		inx				inx
.d118	88		dey				dey
.d119	d0 f6		bne $d111			bne 	_FPUCopy1
.d11b	fa		plx				plx
.d11c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.d11d					FPToString:
.d11d	48		pha				pha
.d11e	5a		phy				phy
.d11f	3c 05 03	bit $0305,x			bit 		XS_Type,x 				; check zero flag
.d122	50 0a		bvc $d12e			bvc 		_FPTSIsFloat 			; if zero,
.d124					_FPTSZero:
.d124	a9 30		lda #$30			lda 		#"0"
.d126	20 d8 cb	jsr $cbd8			jsr 		ITSOutputCharacter
.d129					_FPTSExit:
.d129	7a		ply				ply
.d12a	68		pla				pla
.d12b	60		rts				rts
.d12c	80 fb		bra $d129			bra 		_FPTSExit
.d12e					_FPTSIsFloat:
.d12e	bd 05 03	lda $0305,x			lda 		XS_Type,x 				; is it signed ?
.d131	10 0a		bpl $d13d			bpl 		_FPTSNotSigned
.d133	a9 00		lda #$00			lda 		#0 						; clear sign flag
.d135	9d 05 03	sta $0305,x			sta 		XS_Type,x
.d138	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.d13a	20 d8 cb	jsr $cbd8			jsr 		ITSOutputCharacter
.d13d					_FPTSNotSigned:
.d13d	bd 04 03	lda $0304,x			lda 		XS_Exponent,x
.d140	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.d142	b0 09		bcs $d14d			bcs 		_FPTSExponent
.d144	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.d146	90 05		bcc $d14d			bcc 		_FPTSExponent 			;
.d148					_FPTSStandard:
.d148	20 91 d1	jsr $d191			jsr 		FPTOutputBody 			; output the body.
.d14b	80 dc		bra $d129			bra 		_FPTSExit
.d14d					_FPTSExponent:
.d14d	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.d14f	8d 24 04	sta $0424			sta 		ExpCount
.d152					_FPTSExponentLoop:
.d152	bd 04 03	lda $0304,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.d155	10 0e		bpl $d165			bpl 		_FPTSTimes
.d157	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.d159	90 14		bcc $d16f			bcc 		_FPTSScaledToExp
.d15b	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.d15d	20 bb d0	jsr $d0bb			jsr 		FPUScale10A
.d160	ee 24 04	inc $0424			inc 		ExpCount
.d163	80 ed		bra $d152			bra 		_FPTSExponentLoop
.d165					_FPTSTimes:
.d165	a9 01		lda #$01			lda 		#1
.d167	20 bb d0	jsr $d0bb			jsr 		FPUScale10A
.d16a	ce 24 04	dec $0424			dec 		ExpCount
.d16d	80 e3		bra $d152			bra 		_FPTSExponentLoop
.d16f					_FPTSScaledToExp:
.d16f	20 91 d1	jsr $d191			jsr 		FPTOutputBody 			; output the body.
.d172	a9 65		lda #$65			lda 		#"e"					; output E
.d174	20 d8 cb	jsr $cbd8			jsr 		ITSOutputCharacter
.d177	ad 24 04	lda $0424			lda 		ExpCount 				; get the exponent
.d17a	9d 00 03	sta $0300,x			sta 		XS_Mantissa,x
.d17d	29 80		and #$80			and 		#$80 					; sign extend it
.d17f	f0 02		beq $d183			beq 		_FPTSSExt
.d181	a9 ff		lda #$ff			lda 		#$FF
.d183					_FPTSSExt:
.d183	9d 01 03	sta $0301,x			sta 		XS_Mantissa+1,x
.d186	9d 02 03	sta $0302,x			sta 		XS_Mantissa+2,x
.d189	9d 03 03	sta $0303,x			sta 		XS_Mantissa+3,x
.d18c	20 3c cb	jsr $cb3c			jsr 		INTToString 			; output the exponent.
.d18f	80 98		bra $d129			bra			_FPTSExit 				; and exit.
.d191					FPTOutputBody:
.d191	20 ff d0	jsr $d0ff			jsr 		FPUCopyToNext 			; copy to next slot.
.d194	20 0b d0	jsr $d00b			jsr 		FPUToInteger 			; convert to an integer
.d197	20 3c cb	jsr $cb3c			jsr 		INTToString 			; output the main integer part.
.d19a	20 0e d1	jsr $d10e			jsr 		FPUCopyFromNext 		; get the fractional part back.
.d19d	20 97 ce	jsr $ce97			jsr 		FPFractionalPart 		; get the decimal part.
.d1a0	3c 05 03	bit $0305,x			bit 		XS_Type,x 				; any fractional part.
.d1a3	70 3e		bvs $d1e3			bvs 		_FPTOExit 				; if not, exit now.
.d1a5	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.d1a7	20 d8 cb	jsr $cbd8			jsr 		ITSOutputCharacter
.d1aa					_FPOutLoop:
.d1aa	3c 05 03	bit $0305,x			bit 		XS_Type,x 				; finally reached zero.
.d1ad	70 1e		bvs $d1cd			bvs 		_FPStripZeros 			; strip trailing zeros
.d1af	20 5a d0	jsr $d05a			jsr 		FPUTimes10 				; multiply by 10
.d1b2	20 ff d0	jsr $d0ff			jsr 		FPUCopyToNext			; copy to next slot.
.d1b5	20 0b d0	jsr $d00b			jsr 		FPUToInteger 			; convert to integer
.d1b8	bd 00 03	lda $0300,x			lda 		XS_Mantissa+0,x 		; print digit.
.d1bb	09 30		ora #$30			ora 		#"0"
.d1bd	20 d8 cb	jsr $cbd8			jsr 		ITSOutputCharacter
.d1c0	20 0e d1	jsr $d10e			jsr 		FPUCopyFromNext 		; get it back
.d1c3	20 97 ce	jsr $ce97			jsr 		FPFractionalPart 		; get fractional part
.d1c6	ad 20 04	lda $0420			lda 		NumBufX 				; done 11 characters yet ?
.d1c9	c9 0b		cmp #$0b			cmp 	 	#11
.d1cb	90 dd		bcc $d1aa			bcc 		_FPOutLoop 				; if so, keep going till zero.
.d1cd					_FPStripZeros:
.d1cd	ac 20 04	ldy $0420			ldy 		NumBufX 				; strip trailing zeros.
.d1d0					_FPStripLoop:
.d1d0	88		dey				dey 								; back one, if at start then no strip
.d1d1	f0 10		beq $d1e3			beq 		_FPToExit
.d1d3	b9 00 04	lda $0400,y			lda 		Num_Buffer,y 			; keep going if "0"
.d1d6	c9 30		cmp #$30			cmp 		#"0"
.d1d8	f0 f6		beq $d1d0			beq 		_FPStripLoop
.d1da	c8		iny				iny
.d1db	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.d1dd	99 00 04	sta $0400,y			sta 		Num_Buffer,y
.d1e0	8c 20 04	sty $0420			sty 		NumBufX 				; update position.
.d1e3					_FPTOExit:
.d1e3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.d1e4					FPFromString:
.d1e4	48		pha				pha 								; push A
.d1e5	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.d1e7	c9 2e		cmp #$2e			cmp 	#"."
.d1e9	f0 03		beq $d1ee			beq	 	_FPFIsDecimal
.d1eb	4c 51 d2	jmp $d251			jmp 	_FPFNotDecimal
.d1ee					_FPFIsDecimal:
.d1ee	c8		iny				iny 								; consume the decimal.
.d1ef	20 ac cf	jsr $cfac			jsr 	FPUToFloat 					; convert the integer to float.
.d1f2	da		phx				phx 								; save X.
.d1f3	5a		phy				phy 								; save decimal start position
.d1f4	e8		inx				inx
.d1f5	e8		inx				inx
.d1f6	e8		inx				inx
.d1f7	e8		inx				inx
.d1f8	e8		inx				inx
.d1f9	e8		inx				inx
.d1fa	20 f0 cb	jsr $cbf0			jsr 	INTFromStringY 				; get the part after the DP.
.d1fd	20 ac cf	jsr $cfac			jsr 	FPUToFloat 					; convert that to a float.
.d200	68		pla				pla 								; calculate - chars consumed.
.d201	8c 23 04	sty $0423			sty 	ExpTemp
.d204	38		sec				sec
.d205	ed 23 04	sbc $0423			sbc 	ExpTemp 					; this is the shift amount
.d208	20 bb d0	jsr $d0bb			jsr 	FPUScale10A 				; scale it by 10^AC
.d20b	fa		plx				plx 								; restore original X
.d20c	20 a0 cc	jsr $cca0			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.d20f	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.d211	c9 45		cmp #$45			cmp 	#"E"
.d213	f0 04		beq $d219			beq 	_FPFExponent
.d215	c9 65		cmp #$65			cmp 	#"e"
.d217	d0 38		bne $d251			bne 	_FPFNotDecimal 				; no, then exit normally.
.d219					_FPFExponent:
.d219	c8		iny				iny 								; skip over E symbol.
.d21a	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.d21c	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.d21e	d0 01		bne $d221			bne 	_FPFGotSign
.d220	c8		iny				iny 								; if it was - skip over it.
.d221					_FPFGotSign:
.d221	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.d222	da		phx				phx
.d223	e8		inx				inx
.d224	e8		inx				inx
.d225	e8		inx				inx
.d226	e8		inx				inx
.d227	e8		inx				inx
.d228	e8		inx				inx
.d229	20 f0 cb	jsr $cbf0			jsr 	INTFromStringY 				; get the exponent
.d22c	fa		plx				plx 								; restore X.
.d22d	bd 07 03	lda $0307,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.d230	1d 09 03	ora $0309,x			ora 	XS2_Mantissa+3,x
.d233	1d 08 03	ora $0308,x			ora 	XS2_Mantissa+2,x
.d236	d0 1b		bne $d253			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.d238	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.d23b	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.d23d	b0 14		bcs $d253			bcs 	_FPFXOverflow
.d23f	68		pla				pla 								; get direction
.d240	d0 09		bne $d24b			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.d242	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.d245	49 ff		eor #$ff			eor 	#$FF
.d247	1a		inc a				inc 	a
.d248	9d 06 03	sta $0306,x			sta 	XS2_Mantissa+0,x
.d24b					_FPFXScale:
.d24b	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.d24e	20 bb d0	jsr $d0bb			jsr 	FPUScale10A 				; scale by the exponent.
.d251					_FPFNotDecimal:
.d251	68		pla				pla
.d252	60		rts				rts
.d253					_FPFXOverflow:
.d253	20 16 c4	jsr $c416			jsr 	ERR_Handler
>d256	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>d25e	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.d265					Unary_Rnd:
.d265	20 b6 c5	jsr $c5b6			jsr 	EvaluateNumberX 			; get value
.d268	20 cc c9	jsr $c9cc			jsr 	CheckNextRParen 			; check right bracket.
.d26b	20 87 c8	jsr $c887			jsr 	GetSignCurrent 				; get sign -1,0,1.
.d26e	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.d270	30 10		bmi $d282			bmi 	_URSetSeed
.d272	f0 2c		beq $d2a0			beq 	_URMakeRandom 				; if zero return same number.
.d274	da		phx				phx
.d275	a2 00		ldx #$00			ldx 	#0
.d277	20 dd d2	jsr $d2dd			jsr 	Random16
.d27a	a2 02		ldx #$02			ldx 	#2
.d27c	20 dd d2	jsr $d2dd			jsr 	Random16
.d27f	fa		plx				plx
.d280	80 1e		bra $d2a0			bra 	_URMakeRandom
.d282					_URSetSeed:
.d282	20 ac cf	jsr $cfac			jsr 	FPUToFloat 					; make it a float to twiddle it.
.d285	bd 00 03	lda $0300,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.d288	8d 29 04	sta $0429			sta 	RandomSeed+0
.d28b	bd 01 03	lda $0301,x			lda		XS_Mantissa+1,x
.d28e	8d 2a 04	sta $042a			sta 	RandomSeed+1
.d291	bd 02 03	lda $0302,x			lda		XS_Mantissa+2,x
.d294	8d 2b 04	sta $042b			sta 	RandomSeed+2
.d297	bd 03 03	lda $0303,x			lda		XS_Mantissa+3,x
.d29a	0a		asl a				asl 	a
.d29b	49 db		eor #$db			eor 	#$DB
.d29d	8d 2c 04	sta $042c			sta 	RandomSeed+3
.d2a0					_URMakeRandom:
.d2a0	ad 29 04	lda $0429			lda 	RandomSeed+0 				; check if seed is zero.
.d2a3	0d 2a 04	ora $042a			ora 	RandomSeed+1
.d2a6	0d 2b 04	ora $042b			ora 	RandomSeed+2
.d2a9	0d 2c 04	ora $042c			ora 	RandomSeed+3
.d2ac	d0 0a		bne $d2b8			bne 	_URNotZero
.d2ae	a9 47		lda #$47			lda 	#$47
.d2b0	8d 2a 04	sta $042a			sta 	RandomSeed+1				; if it is, make it non zero.
.d2b3	a9 3d		lda #$3d			lda 	#$3D
.d2b5	8d 2c 04	sta $042c			sta 	RandomSeed+3
.d2b8					_URNotZero:
.d2b8	ad 29 04	lda $0429			lda 	RandomSeed+0 				; copy seed into mantissa.
.d2bb	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.d2be	ad 2a 04	lda $042a			lda 	RandomSeed+1
.d2c1	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.d2c4	ad 2b 04	lda $042b			lda 	RandomSeed+2
.d2c7	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.d2ca	ad 2c 04	lda $042c			lda 	RandomSeed+3
.d2cd	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.d2d0	a9 00		lda #$00			lda 	#$00 						; set type to float.
.d2d2	9d 05 03	sta $0305,x			sta 	XS_Type,x
.d2d5	a9 80		lda #$80			lda 	#$80
.d2d7	9d 04 03	sta $0304,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.d2da	4c e3 cf	jmp $cfe3			jmp 	FPUNormalise
.d2dd					Random16:
.d2dd	5e 2a 04	lsr $042a,x			lsr 	RandomSeed+1,x				; shift seed right
.d2e0	7e 29 04	ror $0429,x			ror 	RandomSeed,x
.d2e3	90 08		bcc $d2ed			bcc 	_R16_NoXor
.d2e5	bd 2a 04	lda $042a,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.d2e8	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.d2ea	9d 2a 04	sta $042a,x			sta 	RandomSeed+1,x
.d2ed					_R16_NoXor:
.d2ed	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.d2ee					Unary_Int:
.d2ee	20 b6 c5	jsr $c5b6			jsr 	EvaluateNumberX 			; get value
.d2f1	20 cc c9	jsr $c9cc			jsr 	CheckNextRParen 			; check right bracket.
.d2f4	4c 0b d0	jmp $d00b			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.d2f7					TIM_Error:
.d2f7	20 37 c2	jsr $c237			jsr 	IFT_UpLine 					; go up one line.
.d2fa	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.d2fc	80 02		bra $d300			bra 	TIM_ShowPrompt
.d2fe					TIM_NewCommand:
.d2fe	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.d300					TIM_ShowPrompt:
.d300	20 43 c2	jsr $c243			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.d303	20 fb c2	jsr $c2fb			jsr 	IFT_ReadLine	 			; get character, go to next line
.d306	20 5d c2	jsr $c25d			jsr 	IFT_NewLine					; go to next line.
.d309	86 10		stx $10				stx 	zTemp1 						; save line read address
.d30b	84 11		sty $11				sty 	zTemp1+1
.d30d	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.d30f	b1 10		lda ($10),y			lda 	(zTemp1),y
.d311	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.d313	d0 01		bne $d316			bne 	TIM_NotDot
.d315	c8		iny				iny
.d316					TIM_NotDot:
.d316	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.d318	c9 52		cmp #$52			cmp 	#"R"						; show registers
.d31a	f0 6b		beq $d387			beq 	TIM_ShowRegisters
.d31c	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.d31e	f0 12		beq $d332			beq 	TIM_ShowMemory
.d320	c9 47		cmp #$47			cmp 	#"G"						; execute
.d322	f0 49		beq $d36d			beq 	TIM_Execute
.d324	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.d326	f0 07		beq $d32f			beq 	TIM_GoLoadMemory
.d328	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.d32a	d0 cb		bne $d2f7			bne 	TIM_Error
.d32c	4c aa d4	jmp $d4aa			jmp 	TIM_UpdateRegisters
.d32f					TIM_GoLoadMemory:
.d32f	4c da d4	jmp $d4da			jmp 	TIM_LoadMemory
.d332					TIM_ShowMemory:
.d332	20 26 d4	jsr $d426			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.d335	b0 c0		bcs $d2f7			bcs 	TIM_Error
.d337	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.d339	85 12		sta $12				sta 	zTemp2
.d33b	a5 15		lda $15				lda 	zTemp3+1
.d33d	85 13		sta $13				sta 	zTemp2+1
.d33f	20 26 d4	jsr $d426			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.d342	90 08		bcc $d34c			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.d344	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.d346	85 14		sta $14				sta 	zTemp3
.d348	a5 13		lda $13				lda 	zTemp2+1
.d34a	85 15		sta $15				sta 	zTemp3+1
.d34c					_TIMSM_Start:
.d34c	20 fe d3	jsr $d3fe			jsr 	TIM_WriteLine 				; write one line of hex out
.d34f	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.d351	18		clc				clc
.d352	69 10		adc #$10			adc 	#16
.d354	85 12		sta $12				sta 	zTemp2
.d356	90 02		bcc $d35a			bcc 	_TIMSM_NoCarry
.d358	e6 13		inc $13				inc 	zTemp2+1
.d35a					_TIMSM_NoCarry:
.d35a	20 e2 c3	jsr $c3e2			jsr 	IF_CheckBreak 				; check CTL+C
.d35d	d0 0b		bne $d36a			bne 	_TIMSM_Ends 				; if pressed break out.
.d35f	38		sec				sec 								; check past the end address in zTemp3
.d360	a5 14		lda $14				lda 	zTemp3
.d362	e5 12		sbc $12				sbc 	zTemp2
.d364	a5 15		lda $15				lda 	zTemp3+1
.d366	e5 13		sbc $13				sbc 	zTemp2+1
.d368	10 e2		bpl $d34c			bpl 	_TIMSM_Start
.d36a					_TIMSM_Ends:
.d36a	4c fe d2	jmp $d2fe			jmp 	TIM_NewCommand
.d36d					TIM_Execute:
.d36d	20 26 d4	jsr $d426			jsr 	TIM_GetHex 					; get the execute address
.d370	b0 85		bcs $d2f7			bcs 	TIM_Error 					; not legitimate
.d372	ae 36 04	ldx $0436			ldx 	TIM_SP 						; set up SP
.d375	9a		txs				txs
.d376	ad 31 04	lda $0431			lda 	TIM_SR 						; Status for PLP
.d379	48		pha				pha
.d37a	ad 32 04	lda $0432			lda 	TIM_A 						; restore AXYZ
.d37d	ae 33 04	ldx $0433			ldx 	TIM_X
.d380	ac 34 04	ldy $0434			ldy 	TIM_Y
.d383	28		plp				plp 								; and PS Byte.
.d384	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.d387					TIM_Start:
.d387					TIM_ShowRegisters:
.d387	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.d38a	8d 30 04	sta $0430			sta 	TIM_IRQ+1
.d38d	ad ff ff	lda $ffff			lda 	$FFFF
.d390	8d 2f 04	sta $042f			sta 	TIM_IRQ
.d393	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.d395					_TIMSR_Text:
.d395	bd c5 d3	lda $d3c5,x			lda 	_TIMSR_Label,x
.d398	20 43 c2	jsr $c243			jsr 	IFT_PrintCharacter
.d39b	e8		inx				inx
.d39c	e0 20		cpx #$20			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.d39e	d0 f5		bne $d395			bne 	_TIMSR_Text
.d3a0	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.d3a2					_TIMSR_Skip:
.d3a2	e8		inx				inx
.d3a3					_TIMSR_LoopSpace:
.d3a3	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.d3a5	b0 04		bcs $d3ab			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.d3a7	8a		txa				txa
.d3a8	4a		lsr a				lsr 	a
.d3a9	b0 05		bcs $d3b0			bcs 	_TIMSR_NoSpace
.d3ab					_TIMSR_Space:
.d3ab	a9 20		lda #$20			lda 	#" "
.d3ad	20 43 c2	jsr $c243			jsr 	IFT_PrintCharacter
.d3b0					_TIMSR_NoSpace:
.d3b0	bd 2d 04	lda $042d,x			lda 	TIM_PC,x 					; output hex value.
.d3b3	20 e5 d3	jsr $d3e5			jsr 	TIM_WriteHex
.d3b6	e8		inx				inx
.d3b7	e0 08		cpx #$08			cpx 	#TIM_Z-TIM_PC
.d3b9	f0 e7		beq $d3a2			beq 	_TIMSR_Skip
.d3bb	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.d3bd	d0 e4		bne $d3a3			bne 	_TimSR_LoopSpace
.d3bf	20 5d c2	jsr $c25d			jsr 	IFT_NewLine 				; new line
.d3c2	4c fe d2	jmp $d2fe			jmp	 	TIM_NewCommand 				; new command.
.d3c5					_TIMSR_Label:
>d3c5	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>d3cd	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>d3dd	52
>d3de	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.d3e5					_TIMSR_LabelEnd:
.d3e5					TIM_WriteHex:
.d3e5	48		pha				pha 								; save A
.d3e6	4a		lsr a				lsr 	a 							; shift MSB->LSB
.d3e7	4a		lsr a				lsr 	a
.d3e8	4a		lsr a				lsr 	a
.d3e9	4a		lsr a				lsr 	a
.d3ea	20 ee d3	jsr $d3ee			jsr 	_TIMWH_Nibble 				; print MSB
.d3ed	68		pla				pla 								; restore and print LSB
.d3ee					_TIMWH_Nibble:
.d3ee	48		pha				pha
.d3ef	29 0f		and #$0f			and 	#15 						; mask out
.d3f1	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.d3f3	90 02		bcc $d3f7			bcc 	_TIMWHNoLetter
.d3f5	69 06		adc #$06			adc 	#6
.d3f7					_TIMWHNoLetter:
.d3f7	69 30		adc #$30			adc 	#48
.d3f9	20 43 c2	jsr $c243			jsr 	IFT_PrintCharacter 			; print it out.
.d3fc	68		pla				pla
.d3fd	60		rts				rts
.d3fe					TIM_WriteLine:
.d3fe	a9 2e		lda #$2e			lda 	#"." 						; prompt
.d400	20 43 c2	jsr $c243			jsr 	IFT_PrintCharacter
.d403	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.d405	20 43 c2	jsr $c243			jsr 	IFT_PrintCharacter
.d408	a5 13		lda $13				lda 	zTemp2+1 					; write address
.d40a	20 e5 d3	jsr $d3e5			jsr 	TIM_WriteHex
.d40d	a5 12		lda $12				lda 	zTemp2
.d40f	20 e5 d3	jsr $d3e5			jsr 	TIM_WriteHex
.d412	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.d414					_TIMWL_Loop:
.d414	a9 20		lda #$20			lda 	#" "
.d416	20 43 c2	jsr $c243			jsr 	IFT_PrintCharacter
.d419	b1 12		lda ($12),y			lda 	(zTemp2),y
.d41b	20 e5 d3	jsr $d3e5			jsr 	TIM_WriteHex
.d41e	c8		iny				iny
.d41f	c0 10		cpy #$10			cpy 	#16
.d421	d0 f1		bne $d414			bne 	_TIMWL_Loop
.d423	4c 5d c2	jmp $c25d			jmp 	IFT_NewLine 				; new line and exit
.d426					TIM_GetHex:
.d426	c8		iny				iny
.d427	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.d429	c9 20		cmp #$20			cmp 	#32
.d42b	f0 f9		beq $d426			beq 	TIM_GetHex
.d42d	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.d42f	f0 f5		beq $d426			beq 	TIM_GetHex
.d431	20 5a d4	jsr $d45a			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.d434	b0 23		bcs $d459			bcs 	_TIMGH_Exit					; if first bad then exit now.
.d436	a9 00		lda #$00			lda 	#0 							; zero result
.d438	85 14		sta $14				sta 	zTemp3
.d43a	85 15		sta $15				sta 	zTemp3+1
.d43c					_TIM_GHLoop:
.d43c	20 5a d4	jsr $d45a			jsr 	TIM_GetHexCharacter 		; get next character
.d43f	b0 17		bcs $d458			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.d441	c8		iny				iny 								; skip over it.
.d442	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.d444	26 15		rol $15				rol 	zTemp3+1
.d446	06 14		asl $14				asl 	zTemp3 						; now x 2
.d448	26 15		rol $15				rol 	zTemp3+1
.d44a	06 14		asl $14				asl 	zTemp3						; now x 4
.d44c	26 15		rol $15				rol 	zTemp3+1
.d44e	06 14		asl $14				asl 	zTemp3 						; now x 8
.d450	26 15		rol $15				rol 	zTemp3+1
.d452	05 14		ora $14				ora 	zTemp3 						; OR result in
.d454	85 14		sta $14				sta 	zTemp3
.d456	80 e4		bra $d43c			bra 	_TIM_GHLoop 				; loop round again.
.d458					_TIMGH_Okay:
.d458	18		clc				clc
.d459					_TIMGH_Exit:
.d459	60		rts				rts
.d45a					TIM_GetHexCharacter:
.d45a	b1 10		lda ($10),y			lda 	(zTemp1),y
.d45c	38		sec				sec
.d45d	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.d45f	90 0e		bcc $d46f			bcc 	_TIM_GHCFail
.d461	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.d463	90 0b		bcc $d470			bcc 	_TIM_GHCExit
.d465	c9 11		cmp #$11			cmp 	#65-48						; < A
.d467	90 06		bcc $d46f			bcc		_TIM_GHCFail
.d469	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.d46b	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.d46d	90 01		bcc $d470			bcc		_TIM_GHCExit
.d46f					_TIM_GHCFail:
.d46f	38		sec				sec
.d470					_TIM_GHCExit:
.d470	60		rts				rts
.d471					TIM_BreakVector:
.d471	da		phx				phx									; save X/A on stack
.d472	48		pha				pha
.d473	ba		tsx				tsx 								; X points to S
.d474	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.d477	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.d479	d0 03		bne $d47e			bne 	_TIMBreak					; if set, it's BRK
.d47b	68		pla				pla 								; abandon routine.
.d47c	fa		plx				plx
.d47d	40		rti				rti
.d47e					_TIMBreak:
.d47e	68		pla				pla 								; save A X Y and maybe Z
.d47f	8d 32 04	sta $0432			sta 	TIM_A
.d482	fa		plx				plx
.d483	8e 33 04	stx $0433			stx 	TIM_X
.d486	8c 34 04	sty $0434			sty 	TIM_Y
.d489	68		pla				pla 								; get Status Register
.d48a	8d 31 04	sta $0431			sta 	TIM_SR
.d48d	68		pla				pla
.d48e	8d 2e 04	sta $042e			sta 	TIM_PC+1 					; save calling address
.d491	68		pla				pla
.d492	8d 2d 04	sta $042d			sta 	TIM_PC 						; high byte
.d495	ad 2e 04	lda $042e			lda 	TIM_PC+1 					; dec PC to point right.
.d498	d0 03		bne $d49d			bne 	_TIMDecrement 				; brk bumps it.
.d49a	ce 2d 04	dec $042d			dec 	TIM_PC
.d49d					_TIMDecrement:
.d49d	ce 2e 04	dec $042e			dec 	TIM_PC+1
.d4a0	ba		tsx				tsx 								; and copy SP
.d4a1	8e 36 04	stx $0436			stx 	TIM_SP
.d4a4	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.d4a6	9a		txs				txs
.d4a7	4c 87 d3	jmp $d387			jmp 	TIM_Start 					; and start up TIM monitor.
.d4aa					TIM_UpdateRegisters:
.d4aa	20 26 d4	jsr $d426			jsr 	TIM_GetHex 					; PC
.d4ad	b0 28		bcs $d4d7			bcs 	_TIMURFail
.d4af	a5 14		lda $14				lda 	zTemp3
.d4b1	8d 2e 04	sta $042e			sta 	Tim_PC+1
.d4b4	a5 15		lda $15				lda 	zTemp3+1
.d4b6	8d 2d 04	sta $042d			sta 	Tim_PC
.d4b9	20 26 d4	jsr $d426			jsr 	TIM_GetHex 					; ignore IRQ
.d4bc	b0 19		bcs $d4d7			bcs 	_TIMURFail
.d4be	a2 00		ldx #$00			ldx 	#0
.d4c0					_TIM_URLoop:
.d4c0	e0 04		cpx #$04			cpx 	#Tim_Z-Tim_SR
.d4c2	d0 01		bne $d4c5			bne 	_TIM_1
.d4c4	e8		inx				inx
.d4c5					_TIM_1:
.d4c5	20 26 d4	jsr $d426			jsr 	TIM_GetHex 					; registers
.d4c8	b0 0d		bcs $d4d7			bcs 	_TIMURFail
.d4ca	a5 14		lda $14				lda 	zTemp3
.d4cc	9d 31 04	sta $0431,x			sta 	Tim_SR,x
.d4cf	e8		inx				inx
.d4d0	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.d4d2	d0 ec		bne $d4c0			bne 	_TIM_URLoop
.d4d4	4c fe d2	jmp $d2fe			jmp 	TIM_NewCommand
.d4d7					_TIMURFail:
.d4d7	4c f7 d2	jmp $d2f7			jmp 	TIM_Error
.d4da					TIM_LoadMemory:
.d4da	20 26 d4	jsr $d426			jsr 	TIM_GetHex 					; target address => zTemp2
.d4dd	a5 14		lda $14				lda 	zTemp3
.d4df	85 12		sta $12				sta 	zTemp2
.d4e1	a5 15		lda $15				lda 	zTemp3+1
.d4e3	85 13		sta $13				sta 	zTemp2+1
.d4e5					_TIM_LMLoop:
.d4e5	20 26 d4	jsr $d426			jsr 	TIM_GetHex 					; next byte ?
.d4e8	b0 0e		bcs $d4f8			bcs 	_TIMLMDone 					; no more
.d4ea	a2 00		ldx #$00			ldx 	#0							; write out.
.d4ec	a5 14		lda $14				lda 	zTemp3
.d4ee	81 12		sta ($12,x)			sta 	(zTemp2,x)
.d4f0	e6 12		inc $12				inc 	zTemp2 						; bump address
.d4f2	d0 f1		bne $d4e5			bne 	_TIM_LMLoop
.d4f4	e6 13		inc $13				inc 	zTemp2+1
.d4f6	80 ed		bra $d4e5			bra 	_TIM_LMLoop
.d4f8					_TIMLMDone:
.d4f8	4c fe d2	jmp $d2fe			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Return to file: basic.asm

>d4fb	02						.byte 	2
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	f2 c1						.word 	StartROM
>fffe	71 d4					.word TIM_BreakVector

;******  End of listing
