
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Sat Aug 24 16:35:03 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="65816"				cpu = "65816"
="em65816"				hardware = "em65816"
=1					exitonend = 1
=1					autorun = 1
=1					loadtest = 1
=1					hasfloat = 1
=1					hasinteger = 1
=253					maxstring = 253

;******  Processing file: modules/float/fpmacros.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/em65816/src_em65816.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0020					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0200					IFT_XCursor:.byte ?							; current logical position on screen
>0201					IFT_YCursor:.byte ?
>0202					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0266					IFT_LineBuffer: .fill 100 					; line input buffer.
>0300					UserVector .fill 4 							; USR(x) calls this.
>0304					LocalVector .fill 4 						; Indirect calls call this.
>0308					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>030c					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>030d					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=782					XS2_Mantissa = XS_Mantissa+XS_Size
=786					XS2_Exponent = XS_Exponent+XS_Size
=787					XS2_Type = XS_Type+XS_Size
=788					XS3_Mantissa = XS_Mantissa+XS_Size*2
=792					XS3_Exponent = XS_Exponent+XS_Size*2
=793					XS3_Type = XS_Type+XS_Size*2
>0400					NumBufX 	.byte 	?						; buffer index position
>0401					Num_Buffer	.fill 	32 						; buffer for numeric conversions
>0421					NumSuppress	.byte 	?						; leading zero suppression flag
>0422					NumConvCount .byte 	? 						; count for conversions.
>0423					ExpTemp:	.byte ?							; Working temp for exponents.
>0424					ExpCount:	.byte ? 						; Count of decimal exponents.
>0425					SignCount:	.byte ?							; Integer Divide Sign Counts.
>0426					StringPtr:	.word ? 						; Top of free memory (for string allocation)
>0428					TempStringWriteIndex: .byte ? 				; Write offset.
>0429					ValSign: 	.byte ? 						; sign flag for val()
>042a					SliceStart:	.byte ? 						; string slice parts
>042b					SliceCount:	.byte ?
>042c					RandomSeed:	.dword ? 						; Random seed.
>0430					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>0432					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>0434					Tim_SR:		.byte ? 						; Processor Status
>0435					Tim_A:		.byte ? 						; Processor Registers
>0436					Tim_X:		.byte ?
>0437					Tim_Y:		.byte ?
>0438					Tim_Z:		.byte ?
>0439					Tim_SP:		.byte ?							; Stack Pointer

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/em65816.asm

=$8000					HighMemory = $8000
.1000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testing.src

>1000	1b 02 00 d9 bb 41 5f 77			.byte	$1b,$02,$00,$d9,$bb,$41,$5f,$77
>1008	76 fd 04 30 38 89 41 5f			.byte	$76,$fd,$04,$30,$38,$89,$41,$5f
>1010	77 76 fd 04 30 38 bc 84			.byte	$77,$76,$fd,$04,$30,$38,$bc,$84
>1018	8b 41 00 13 03 00 d9 bb			.byte	$8b,$41,$00,$13,$03,$00,$d9,$bb
>1020	8b 59 4e 4f 87 8b 59 4e			.byte	$8b,$59,$4e,$4f,$87,$8b,$59,$4e
>1028	4f bc 84 8b 41 00 16 04			.byte	$4f,$bc,$84,$8b,$41,$00,$16,$04
>1030	00 d9 bb 42 64 46 42 82			.byte	$00,$d9,$bb,$42,$64,$46,$42,$82
>1038	8b 42 4c 76 77 bc 84 8b			.byte	$8b,$42,$4c,$76,$77,$bc,$84,$8b
>1040	68 70 75 00 10 05 00 d9			.byte	$68,$70,$75,$00,$10,$05,$00,$d9
>1048	9a 43 4d 59 75 bc 84 43			.byte	$9a,$43,$4d,$59,$75,$bc,$84,$43
>1050	4d 59 75 00 1a 06 00 d9			.byte	$4d,$59,$75,$00,$1a,$06,$00,$d9
>1058	a0 fe 08 72 6b 76 76 79			.byte	$a0,$fe,$08,$72,$6b,$76,$76,$79
>1060	61 bd 46 bc 84 fe 08 72			.byte	$61,$bd,$46,$bc,$84,$fe,$08,$72
>1068	6b 76 76 79 61 00 23 07			.byte	$6b,$76,$76,$79,$61,$00,$23,$07
>1070	00 d9 bb 8b 43 52 6f 73			.byte	$00,$d9,$bb,$8b,$43,$52,$6f,$73
>1078	fd 04 31 37 8a 8b 43 52			.byte	$fd,$04,$31,$37,$8a,$8b,$43,$52
>1080	6f 73 fd 04 31 37 bc 84			.byte	$6f,$73,$fd,$04,$31,$37,$bc,$84
>1088	8b 46 65 5f 66 fd 03 33			.byte	$8b,$46,$65,$5f,$66,$fd,$03,$33
>1090	00 14 08 00 d9 bb 8b 41			.byte	$00,$14,$08,$00,$d9,$bb,$8b,$41
>1098	71 5a 62 85 8b 41 71 5a			.byte	$71,$5a,$62,$85,$8b,$41,$71,$5a
>10a0	62 bc 84 40 00 15 09 00			.byte	$62,$bc,$84,$40,$00,$15,$09,$00
>10a8	d9 bb 8b 43 56 5c 6d 80			.byte	$d9,$bb,$8b,$43,$56,$5c,$6d,$80
>10b0	43 72 49 6a bc 84 60 41			.byte	$43,$72,$49,$6a,$bc,$84,$60,$41
>10b8	42 00 0f 0a 00 d9 b3 8b			.byte	$42,$00,$0f,$0a,$00,$d9,$b3,$8b
>10c0	43 5c 5d 74 bc 84 8b 41			.byte	$43,$5c,$5d,$74,$bc,$84,$8b,$41
>10c8	00 0e 0b 00 d9 a1 fe 02			.byte	$00,$0e,$0b,$00,$d9,$a1,$fe,$02
>10d0	bd 46 bc 84 fe 02 00 1c			.byte	$bd,$46,$bc,$84,$fe,$02,$00,$1c
>10d8	0c 00 d9 bb 8b 42 50 4d			.byte	$0c,$00,$d9,$bb,$8b,$42,$50,$4d
>10e0	63 fd 04 31 36 85 8b 42			.byte	$63,$fd,$04,$31,$36,$85,$8b,$42
>10e8	50 4d 63 fd 04 31 36 bc			.byte	$50,$4d,$63,$fd,$04,$31,$36,$bc
>10f0	84 40 00 14 0d 00 d9 bb			.byte	$84,$40,$00,$14,$0d,$00,$d9,$bb
>10f8	8b 41 6e 43 46 85 8b 41			.byte	$8b,$41,$6e,$43,$46,$85,$8b,$41
>1100	6e 43 46 bc 84 40 00 16			.byte	$6e,$43,$46,$bc,$84,$40,$00,$16
>1108	0e 00 d9 bb 8b 42 5d 40			.byte	$0e,$00,$d9,$bb,$8b,$42,$5d,$40
>1110	6a 80 43 50 4e 64 bc 84			.byte	$6a,$80,$43,$50,$4e,$64,$bc,$84
>1118	41 40 4e 44 00 13 0f 00			.byte	$41,$40,$4e,$44,$00,$13,$0f,$00
>1120	d9 b2 8b 78 50 75 bd 7d			.byte	$d9,$b2,$8b,$78,$50,$75,$bd,$7d
>1128	61 79 bc 84 78 50 75 00			.byte	$61,$79,$bc,$84,$78,$50,$75,$00
>1130	17 10 00 d9 a2 fe 09 70			.byte	$17,$10,$00,$d9,$a2,$fe,$09,$70
>1138	67 64 77 74 69 69 bd 4a			.byte	$67,$64,$77,$74,$69,$69,$bd,$4a
>1140	bd 45 bc 84 fe 02 00 24			.byte	$bd,$45,$bc,$84,$fe,$02,$00,$24
>1148	11 00 d9 bb 8b 41 75 5d			.byte	$11,$00,$d9,$bb,$8b,$41,$75,$5d
>1150	66 fd 04 36 38 8a 8b 41			.byte	$66,$fd,$04,$36,$38,$8a,$8b,$41
>1158	75 5d 66 fd 04 36 38 bc			.byte	$75,$5d,$66,$fd,$04,$36,$38,$bc
>1160	84 8b 43 6a 7b 4d fd 04			.byte	$84,$8b,$43,$6a,$7b,$4d,$fd,$04
>1168	33 36 00 15 12 00 d9 bb			.byte	$33,$36,$00,$15,$12,$00,$d9,$bb
>1170	8b 42 7a 4a 5c 87 8b 42			.byte	$8b,$42,$7a,$4a,$5c,$87,$8b,$42
>1178	7a 4a 5c bc 84 8b 41 00			.byte	$7a,$4a,$5c,$bc,$84,$8b,$41,$00
>1180	15 13 00 d9 bb 43 46 48			.byte	$15,$13,$00,$d9,$bb,$43,$46,$48
>1188	5c 80 8b 43 5d 4c 4e bc			.byte	$5c,$80,$8b,$43,$5d,$4c,$4e,$bc
>1190	84 42 40 50 00 0a 14 00			.byte	$84,$42,$40,$50,$00,$0a,$14,$00
>1198	d9 98 40 84 8b 41 00 13			.byte	$d9,$98,$40,$84,$8b,$41,$00,$13
>11a0	15 00 d9 a6 fe 0a 71 78			.byte	$15,$00,$d9,$a6,$fe,$0a,$71,$78
>11a8	73 66 71 66 6e 71 bc 84			.byte	$73,$66,$71,$66,$6e,$71,$bc,$84
>11b0	48 00 1d 16 00 d9 bb 8b			.byte	$48,$00,$1d,$16,$00,$d9,$bb,$8b
>11b8	43 48 7a 68 fd 04 31 38			.byte	$43,$48,$7a,$68,$fd,$04,$31,$38
>11c0	84 8b 43 48 7a 68 fd 04			.byte	$84,$8b,$43,$48,$7a,$68,$fd,$04
>11c8	31 38 bc 84 8b 41 00 15			.byte	$31,$38,$bc,$84,$8b,$41,$00,$15
>11d0	17 00 d9 bb 8b 42 68 6e			.byte	$17,$00,$d9,$bb,$8b,$42,$68,$6e
>11d8	52 89 8b 42 68 6e 52 bc			.byte	$52,$89,$8b,$42,$68,$6e,$52,$bc
>11e0	84 8b 41 00 18 18 00 d9			.byte	$84,$8b,$41,$00,$18,$18,$00,$d9
>11e8	bb 8b 42 7b 78 72 80 8b			.byte	$bb,$8b,$42,$7b,$78,$72,$80,$8b
>11f0	42 74 50 59 bc 84 8b 42			.byte	$42,$74,$50,$59,$bc,$84,$8b,$42
>11f8	7f 78 7a 00 14 19 00 d9			.byte	$7f,$78,$7a,$00,$14,$19,$00,$d9
>1200	a5 a4 8b 41 51 44 7c bc			.byte	$a5,$a4,$8b,$41,$51,$44,$7c,$bc
>1208	bc 84 8b 41 51 44 7c 00			.byte	$bc,$84,$8b,$41,$51,$44,$7c,$00
>1210	16 1a 00 d9 9b fe 0c 66			.byte	$16,$1a,$00,$d9,$9b,$fe,$0c,$66
>1218	67 75 65 76 70 68 71 79			.byte	$67,$75,$65,$76,$70,$68,$71,$79
>1220	62 bc 84 41 66 00 1d 1b			.byte	$62,$bc,$84,$41,$66,$00,$1d,$1b
>1228	00 d9 bb 8b 42 53 45 60			.byte	$00,$d9,$bb,$8b,$42,$53,$45,$60
>1230	fd 04 30 31 84 8b 42 53			.byte	$fd,$04,$30,$31,$84,$8b,$42,$53
>1238	45 60 fd 04 30 31 bc 84			.byte	$45,$60,$fd,$04,$30,$31,$bc,$84
>1240	8b 41 00 10 1c 00 d9 bb			.byte	$8b,$41,$00,$10,$1c,$00,$d9,$bb
>1248	76 75 7f 88 76 75 7f bc			.byte	$76,$75,$7f,$88,$76,$75,$7f,$bc
>1250	84 40 00 12 1d 00 d9 bb			.byte	$84,$40,$00,$12,$1d,$00,$d9,$bb
>1258	43 54 5d 66 82 40 bc 84			.byte	$43,$54,$5d,$66,$82,$40,$bc,$84
>1260	43 54 5d 66 00 11 1e 00			.byte	$43,$54,$5d,$66,$00,$11,$1e,$00
>1268	d9 9a 8b 42 76 5b 45 bc			.byte	$d9,$9a,$8b,$42,$76,$5b,$45,$bc
>1270	84 42 76 5b 45 00 0c 1f			.byte	$84,$42,$76,$5b,$45,$00,$0c,$1f
>1278	00 d9 b4 72 bc 84 fe 03			.byte	$00,$d9,$b4,$72,$bc,$84,$fe,$03
>1280	32 00 1c 20 00 d9 bb 8b			.byte	$32,$00,$1c,$20,$00,$d9,$bb,$8b
>1288	41 46 54 7f fd 04 30 37			.byte	$41,$46,$54,$7f,$fd,$04,$30,$37
>1290	88 8b 41 46 54 7f fd 04			.byte	$88,$8b,$41,$46,$54,$7f,$fd,$04
>1298	30 37 bc 84 40 00 10 21			.byte	$30,$37,$bc,$84,$40,$00,$10,$21
>12a0	00 d9 bb 61 4f 78 8b 61			.byte	$00,$d9,$bb,$61,$4f,$78,$8b,$61
>12a8	4f 78 bc 84 40 00 16 22			.byte	$4f,$78,$bc,$84,$40,$00,$16,$22
>12b0	00 d9 bb 43 73 74 57 80			.byte	$00,$d9,$bb,$43,$73,$74,$57,$80
>12b8	8b 42 5e 6f 57 bc 84 41			.byte	$8b,$42,$5e,$6f,$57,$bc,$84,$41
>12c0	61 50 41 00 0d 23 00 d9			.byte	$61,$50,$41,$00,$0d,$23,$00,$d9
>12c8	b3 42 7a 7e 7f bc 84 41			.byte	$b3,$42,$7a,$7e,$7f,$bc,$84,$41
>12d0	00 14 24 00 d9 a3 49 bc			.byte	$00,$14,$24,$00,$d9,$a3,$49,$bc
>12d8	84 fe 0b 20 20 20 20 20			.byte	$84,$fe,$0b,$20,$20,$20,$20,$20
>12e0	20 20 20 20 00 1d 25 00			.byte	$20,$20,$20,$20,$00,$1d,$25,$00
>12e8	d9 bb 8b 41 65 5f 61 fd			.byte	$d9,$bb,$8b,$41,$65,$5f,$61,$fd
>12f0	04 37 36 84 8b 41 65 5f			.byte	$04,$37,$36,$84,$8b,$41,$65,$5f
>12f8	61 fd 04 37 36 bc 84 8b			.byte	$61,$fd,$04,$37,$36,$bc,$84,$8b
>1300	41 00 12 26 00 d9 bb 41			.byte	$41,$00,$12,$26,$00,$d9,$bb,$41
>1308	5f 69 5e 85 41 5f 69 5e			.byte	$5f,$69,$5e,$85,$41,$5f,$69,$5e
>1310	bc 84 40 00 0e 27 00 d9			.byte	$bc,$84,$40,$00,$0e,$27,$00,$d9
>1318	bb 4d 4f 76 80 40 bc 84			.byte	$bb,$4d,$4f,$76,$80,$40,$bc,$84
>1320	40 00 14 28 00 d9 b2 8b			.byte	$40,$00,$14,$28,$00,$d9,$b2,$8b
>1328	41 6f 7e 65 bd 49 4b 72			.byte	$41,$6f,$7e,$65,$bd,$49,$4b,$72
>1330	bc 84 41 71 4d 00 12 29			.byte	$bc,$84,$41,$71,$4d,$00,$12,$29
>1338	00 d9 a7 68 41 7f bc 84			.byte	$00,$d9,$a7,$68,$41,$7f,$bc,$84
>1340	fe 07 32 38 30 37 46 00			.byte	$fe,$07,$32,$38,$30,$37,$46,$00
>1348	1c 2a 00 d9 bb 8b 42 7d			.byte	$1c,$2a,$00,$d9,$bb,$8b,$42,$7d
>1350	52 69 fd 04 39 38 88 8b			.byte	$52,$69,$fd,$04,$39,$38,$88,$8b
>1358	42 7d 52 69 fd 04 39 38			.byte	$42,$7d,$52,$69,$fd,$04,$39,$38
>1360	bc 84 40 00 12 2b 00 d9			.byte	$bc,$84,$40,$00,$12,$2b,$00,$d9
>1368	bb 41 51 75 59 88 41 51			.byte	$bb,$41,$51,$75,$59,$88,$41,$51
>1370	75 59 bc 84 40 00 16 2c			.byte	$75,$59,$bc,$84,$40,$00,$16,$2c
>1378	00 d9 bb 8b 41 7e 77 41			.byte	$00,$d9,$bb,$8b,$41,$7e,$77,$41
>1380	82 8b 72 6c 47 bc 84 41			.byte	$82,$8b,$72,$6c,$47,$bc,$84,$41
>1388	4c 5b 46 00 0e 2d 00 d9			.byte	$4c,$5b,$46,$00,$0e,$2d,$00,$d9
>1390	98 46 76 61 84 8b 46 76			.byte	$98,$46,$76,$61,$84,$8b,$46,$76
>1398	62 00 0f 2e 00 d9 af fe			.byte	$62,$00,$0f,$2e,$00,$d9,$af,$fe
>13a0	05 46 32 43 bc 84 7c 6c			.byte	$05,$46,$32,$43,$bc,$84,$7c,$6c
>13a8	00 27 2f 00 d9 bb 42 76			.byte	$00,$27,$2f,$00,$d9,$bb,$42,$76
>13b0	46 5b fd 04 32 32 8c 42			.byte	$46,$5b,$fd,$04,$32,$32,$8c,$42
>13b8	76 46 5b fd 04 32 32 bc			.byte	$76,$46,$5b,$fd,$04,$32,$32,$bc
>13c0	84 45 fd 0d 35 36 33 34			.byte	$84,$45,$fd,$0d,$35,$36,$33,$34
>13c8	31 37 37 32 65 31 31 00			.byte	$31,$37,$37,$32,$65,$31,$31,$00
>13d0	11 30 00 d9 bb 51 71 4c			.byte	$11,$30,$00,$d9,$bb,$51,$71,$4c
>13d8	84 51 71 4c bc 84 8b 41			.byte	$84,$51,$71,$4c,$bc,$84,$8b,$41
>13e0	00 16 31 00 d9 bb 8b 43			.byte	$00,$16,$31,$00,$d9,$bb,$8b,$43
>13e8	70 7b 47 81 8b 6c 49 7e			.byte	$70,$7b,$47,$81,$8b,$6c,$49,$7e
>13f0	bc 84 8b 60 49 45 00 1a			.byte	$bc,$84,$8b,$60,$49,$45,$00,$1a
>13f8	32 00 d9 a5 a4 43 63 6b			.byte	$32,$00,$d9,$a5,$a4,$43,$63,$6b
>1400	6b fd 04 31 37 bc bc 84			.byte	$6b,$fd,$04,$31,$37,$bc,$bc,$84
>1408	43 63 6b 6b fd 04 31 37			.byte	$43,$63,$6b,$6b,$fd,$04,$31,$37
>1410	00 18 33 00 d9 a0 fe 09			.byte	$00,$18,$33,$00,$d9,$a0,$fe,$09
>1418	6a 72 6b 72 74 73 75 bd			.byte	$6a,$72,$6b,$72,$74,$73,$75,$bd
>1420	43 bc 84 fe 05 6a 72 6b			.byte	$43,$bc,$84,$fe,$05,$6a,$72,$6b
>1428	00 1c 34 00 d9 bb 8b 42			.byte	$00,$1c,$34,$00,$d9,$bb,$8b,$42
>1430	5e 4a 68 fd 04 36 32 88			.byte	$5e,$4a,$68,$fd,$04,$36,$32,$88
>1438	8b 42 5e 4a 68 fd 04 36			.byte	$8b,$42,$5e,$4a,$68,$fd,$04,$36
>1440	32 bc 84 40 00 15 35 00			.byte	$32,$bc,$84,$40,$00,$15,$35,$00
>1448	d9 bb 8b 41 7f 41 6a 87			.byte	$d9,$bb,$8b,$41,$7f,$41,$6a,$87
>1450	8b 41 7f 41 6a bc 84 8b			.byte	$8b,$41,$7f,$41,$6a,$bc,$84,$8b
>1458	41 00 14 36 00 d9 bb 61			.byte	$41,$00,$14,$36,$00,$d9,$bb,$61
>1460	52 7a 82 42 75 53 62 bc			.byte	$52,$7a,$82,$42,$75,$53,$62,$bc
>1468	84 42 54 41 58 00 0f 37			.byte	$84,$42,$54,$41,$58,$00,$0f,$37
>1470	00 d9 9a 8b 79 66 5e bc			.byte	$00,$d9,$9a,$8b,$79,$66,$5e,$bc
>1478	84 79 66 5e 00 10 38 00			.byte	$84,$79,$66,$5e,$00,$10,$38,$00
>1480	d9 a1 fe 03 6e bd 44 bc			.byte	$d9,$a1,$fe,$03,$6e,$bd,$44,$bc
>1488	84 fe 03 6e 00 1b 39 00			.byte	$84,$fe,$03,$6e,$00,$1b,$39,$00
>1490	d9 bb 47 67 74 fd 05 31			.byte	$d9,$bb,$47,$67,$74,$fd,$05,$31
>1498	37 39 84 47 67 74 fd 05			.byte	$37,$39,$84,$47,$67,$74,$fd,$05
>14a0	31 37 39 bc 84 8b 41 00			.byte	$31,$37,$39,$bc,$84,$8b,$41,$00
>14a8	13 3a 00 d9 bb 41 73 4d			.byte	$13,$3a,$00,$d9,$bb,$41,$73,$4d
>14b0	42 87 41 73 4d 42 bc 84			.byte	$42,$87,$41,$73,$4d,$42,$bc,$84
>14b8	8b 41 00 16 3b 00 d9 bb			.byte	$8b,$41,$00,$16,$3b,$00,$d9,$bb
>14c0	8b 5d 51 77 82 42 46 45			.byte	$8b,$5d,$51,$77,$82,$42,$46,$45
>14c8	51 bc 84 8b 42 5b 54 68			.byte	$51,$bc,$84,$8b,$42,$5b,$54,$68
>14d0	00 0f 3c 00 d9 b3 8b 43			.byte	$00,$0f,$3c,$00,$d9,$b3,$8b,$43
>14d8	44 51 64 bc 84 8b 41 00			.byte	$44,$51,$64,$bc,$84,$8b,$41,$00
>14e0	10 3d 00 d9 a2 fe 02 bd			.byte	$10,$3d,$00,$d9,$a2,$fe,$02,$bd
>14e8	43 bd 40 bc 84 fe 02 00			.byte	$43,$bd,$40,$bc,$84,$fe,$02,$00
>14f0	1d 3e 00 d9 bb 8b 41 6e			.byte	$1d,$3e,$00,$d9,$bb,$8b,$41,$6e
>14f8	72 62 fd 04 31 37 84 8b			.byte	$72,$62,$fd,$04,$31,$37,$84,$8b
>1500	41 6e 72 62 fd 04 31 37			.byte	$41,$6e,$72,$62,$fd,$04,$31,$37
>1508	bc 84 8b 41 00 10 3f 00			.byte	$bc,$84,$8b,$41,$00,$10,$3f,$00
>1510	d9 bb 7c 73 56 85 7c 73			.byte	$d9,$bb,$7c,$73,$56,$85,$7c,$73
>1518	56 bc 84 40 00 18 40 00			.byte	$56,$bc,$84,$40,$00,$18,$40,$00
>1520	d9 bb 8b 41 51 78 60 80			.byte	$d9,$bb,$8b,$41,$51,$78,$60,$80
>1528	8b 41 5c 6f 41 bc 84 8b			.byte	$8b,$41,$5c,$6f,$41,$bc,$84,$8b
>1530	41 5d 7f 60 00 16 41 00			.byte	$41,$5d,$7f,$60,$00,$16,$41,$00
>1538	d9 b2 41 7f 73 6c bd 8b			.byte	$d9,$b2,$41,$7f,$73,$6c,$bd,$8b
>1540	42 7c 71 5e bc 84 41 7f			.byte	$42,$7c,$71,$5e,$bc,$84,$41,$7f
>1548	73 6c 00 0c 42 00 d9 a6			.byte	$73,$6c,$00,$0c,$42,$00,$d9,$a6
>1550	fe 03 73 bc 84 41 00 1c			.byte	$fe,$03,$73,$bc,$84,$41,$00,$1c
>1558	43 00 d9 bb 8b 42 6d 4d			.byte	$43,$00,$d9,$bb,$8b,$42,$6d,$4d
>1560	46 fd 04 30 32 86 8b 42			.byte	$46,$fd,$04,$30,$32,$86,$8b,$42
>1568	6d 4d 46 fd 04 30 32 bc			.byte	$6d,$4d,$46,$fd,$04,$30,$32,$bc
>1570	84 40 00 11 44 00 d9 bb			.byte	$84,$40,$00,$11,$44,$00,$d9,$bb
>1578	49 74 60 87 49 74 60 bc			.byte	$49,$74,$60,$87,$49,$74,$60,$bc
>1580	84 8b 41 00 17 45 00 d9			.byte	$84,$8b,$41,$00,$17,$45,$00,$d9
>1588	bb 8b 41 48 76 41 82 43			.byte	$bb,$8b,$41,$48,$76,$41,$82,$43
>1590	4e 7e 74 bc 84 8b 42 46			.byte	$4e,$7e,$74,$bc,$84,$8b,$42,$46
>1598	48 75 00 10 46 00 d9 98			.byte	$48,$75,$00,$10,$46,$00,$d9,$98
>15a0	8b 41 44 62 77 84 41 44			.byte	$8b,$41,$44,$62,$77,$84,$41,$44
>15a8	62 76 00 16 47 00 d9 9b			.byte	$62,$76,$00,$16,$47,$00,$d9,$9b
>15b0	fe 0c 72 71 79 78 72 69			.byte	$fe,$0c,$72,$71,$79,$78,$72,$69
>15b8	65 72 68 6f bc 84 41 72			.byte	$65,$72,$68,$6f,$bc,$84,$41,$72
>15c0	00 1f 48 00 d9 bb 8b 42			.byte	$00,$1f,$48,$00,$d9,$bb,$8b,$42
>15c8	47 6d 40 fd 04 37 36 8b			.byte	$47,$6d,$40,$fd,$04,$37,$36,$8b
>15d0	8b 42 47 6d 40 fd 04 37			.byte	$8b,$42,$47,$6d,$40,$fd,$04,$37
>15d8	36 bc 84 40 fd 03 30 00			.byte	$36,$bc,$84,$40,$fd,$03,$30,$00
>15e0	11 49 00 d9 bb 8b 41 45			.byte	$11,$49,$00,$d9,$bb,$8b,$41,$45
>15e8	56 75 85 40 bc 84 8b 41			.byte	$56,$75,$85,$40,$bc,$84,$8b,$41
>15f0	00 16 4a 00 d9 bb 42 49			.byte	$00,$16,$4a,$00,$d9,$bb,$42,$49
>15f8	51 49 82 8b 63 76 54 bc			.byte	$51,$49,$82,$8b,$63,$76,$54,$bc
>1600	84 8b 42 6a 67 5b 00 14			.byte	$84,$8b,$42,$6a,$67,$5b,$00,$14
>1608	4b 00 d9 a5 a4 8b 42 45			.byte	$4b,$00,$d9,$a5,$a4,$8b,$42,$45
>1610	54 69 bc bc 84 8b 42 45			.byte	$54,$69,$bc,$bc,$84,$8b,$42,$45
>1618	54 69 00 0c 4c 00 d9 b4			.byte	$54,$69,$00,$0c,$4c,$00,$d9,$b4
>1620	7b bc 84 fe 03 3b 00 1d			.byte	$7b,$bc,$84,$fe,$03,$3b,$00,$1d
>1628	4d 00 d9 bb 8b 42 51 52			.byte	$4d,$00,$d9,$bb,$8b,$42,$51,$52
>1630	5c fd 04 34 31 87 8b 42			.byte	$5c,$fd,$04,$34,$31,$87,$8b,$42
>1638	51 52 5c fd 04 34 31 bc			.byte	$51,$52,$5c,$fd,$04,$34,$31,$bc
>1640	84 8b 41 00 14 4e 00 d9			.byte	$84,$8b,$41,$00,$14,$4e,$00,$d9
>1648	bb 8b 42 55 48 6d 8b 8b			.byte	$bb,$8b,$42,$55,$48,$6d,$8b,$8b
>1650	42 55 48 6d bc 84 40 00			.byte	$42,$55,$48,$6d,$bc,$84,$40,$00
>1658	15 4f 00 d9 bb 8b 41 40			.byte	$15,$4f,$00,$d9,$bb,$8b,$41,$40
>1660	79 4c 80 41 4e 58 63 bc			.byte	$79,$4c,$80,$41,$4e,$58,$63,$bc
>1668	84 4e 40 60 00 11 50 00			.byte	$84,$4e,$40,$60,$00,$11,$50,$00
>1670	d9 9a 8b 42 6c 63 4f bc			.byte	$d9,$9a,$8b,$42,$6c,$63,$4f,$bc
>1678	84 42 6c 63 4f 00 0e 51			.byte	$84,$42,$6c,$63,$4f,$00,$0e,$51
>1680	00 d9 a3 43 bc 84 fe 05			.byte	$00,$d9,$a3,$43,$bc,$84,$fe,$05
>1688	20 20 20 00 1a 52 00 d9			.byte	$20,$20,$20,$00,$1a,$52,$00,$d9
>1690	bb 43 4c 5a 47 fd 04 30			.byte	$bb,$43,$4c,$5a,$47,$fd,$04,$30
>1698	37 88 43 4c 5a 47 fd 04			.byte	$37,$88,$43,$4c,$5a,$47,$fd,$04
>16a0	30 37 bc 84 40 00 12 53			.byte	$30,$37,$bc,$84,$40,$00,$12,$53
>16a8	00 d9 bb 8b 4f 7e 4e 85			.byte	$00,$d9,$bb,$8b,$4f,$7e,$4e,$85
>16b0	8b 4f 7e 4e bc 84 40 00			.byte	$8b,$4f,$7e,$4e,$bc,$84,$40,$00
>16b8	18 54 00 d9 bb 8b 41 6e			.byte	$18,$54,$00,$d9,$bb,$8b,$41,$6e
>16c0	7a 57 80 8b 42 6e 77 63			.byte	$7a,$57,$80,$8b,$42,$6e,$77,$63
>16c8	bc 84 8b 43 6e 7f 77 00			.byte	$bc,$84,$8b,$43,$6e,$7f,$77,$00
>16d0	0d 55 00 d9 b3 41 56 5f			.byte	$0d,$55,$00,$d9,$b3,$41,$56,$5f
>16d8	5e bc 84 41 00 13 56 00			.byte	$5e,$bc,$84,$41,$00,$13,$56,$00
>16e0	d9 a7 43 63 6b 6d bc 84			.byte	$d9,$a7,$43,$63,$6b,$6d,$bc,$84
>16e8	fe 07 45 33 41 45 44 00			.byte	$fe,$07,$45,$33,$41,$45,$44,$00
>16f0	1b 57 00 d9 bb 42 42 70			.byte	$1b,$57,$00,$d9,$bb,$42,$42,$70
>16f8	4a fd 04 34 34 84 42 42			.byte	$4a,$fd,$04,$34,$34,$84,$42,$42
>1700	70 4a fd 04 34 34 bc 84			.byte	$70,$4a,$fd,$04,$34,$34,$bc,$84
>1708	8b 41 00 13 58 00 d9 bb			.byte	$8b,$41,$00,$13,$58,$00,$d9,$bb
>1710	42 61 75 65 85 41 56 45			.byte	$42,$61,$75,$65,$85,$41,$56,$45
>1718	75 bc 84 8b 41 00 16 59			.byte	$75,$bc,$84,$8b,$41,$00,$16,$59
>1720	00 d9 bb 8b 43 66 62 59			.byte	$00,$d9,$bb,$8b,$43,$66,$62,$59
>1728	81 5b 49 6c bc 84 8b 43			.byte	$81,$5b,$49,$6c,$bc,$84,$8b,$43
>1730	64 62 51 00 13 5a 00 d9			.byte	$64,$62,$51,$00,$13,$5a,$00,$d9
>1738	af fe 07 41 34 32 39 45			.byte	$af,$fe,$07,$41,$34,$32,$39,$45
>1740	bc 84 42 64 4a 5e 00 1a			.byte	$bc,$84,$42,$64,$4a,$5e,$00,$1a
>1748	5b 00 d9 bb 8b 61 55 7f			.byte	$5b,$00,$d9,$bb,$8b,$61,$55,$7f
>1750	fd 04 38 39 88 8b 61 55			.byte	$fd,$04,$38,$39,$88,$8b,$61,$55
>1758	7f fd 04 38 39 bc 84 40			.byte	$7f,$fd,$04,$38,$39,$bc,$84,$40
>1760	00 11 5c 00 d9 bb 8b 79			.byte	$00,$11,$5c,$00,$d9,$bb,$8b,$79
>1768	7a 84 8b 79 7a bc 84 8b			.byte	$7a,$84,$8b,$79,$7a,$bc,$84,$8b
>1770	41 00 17 5d 00 d9 bb 43			.byte	$41,$00,$17,$5d,$00,$d9,$bb,$43
>1778	55 57 4c 82 8b 41 5e 56			.byte	$55,$57,$4c,$82,$8b,$41,$5e,$56
>1780	60 bc 84 8b 42 4b 41 54			.byte	$60,$bc,$84,$8b,$42,$4b,$41,$54
>1788	00 10 5e 00 d9 98 41 62			.byte	$00,$10,$5e,$00,$d9,$98,$41,$62
>1790	77 4e 84 8b 41 62 77 4f			.byte	$77,$4e,$84,$8b,$41,$62,$77,$4f
>1798	00 0e 5f 00 d9 a0 fe 02			.byte	$00,$0e,$5f,$00,$d9,$a0,$fe,$02
>17a0	bd 43 bc 84 fe 02 00 18			.byte	$bd,$43,$bc,$84,$fe,$02,$00,$18
>17a8	60 00 d9 bb 77 74 66 fd			.byte	$60,$00,$d9,$bb,$77,$74,$66,$fd
>17b0	04 31 34 85 77 74 66 fd			.byte	$04,$31,$34,$85,$77,$74,$66,$fd
>17b8	04 31 34 bc 84 40 00 16			.byte	$04,$31,$34,$bc,$84,$40,$00,$16
>17c0	61 00 d9 bb 8b 41 6b 51			.byte	$61,$00,$d9,$bb,$8b,$41,$6b,$51
>17c8	8c 8b 41 6b 51 bc 84 42			.byte	$8c,$8b,$41,$6b,$51,$bc,$84,$42
>17d0	73 71 7a 61 00 17 62 00			.byte	$73,$71,$7a,$61,$00,$17,$62,$00
>17d8	d9 bb 8b 43 5a 4d 69 82			.byte	$d9,$bb,$8b,$43,$5a,$4d,$69,$82
>17e0	8b 42 40 49 58 bc 84 41			.byte	$8b,$42,$40,$49,$58,$bc,$84,$41
>17e8	5a 44 7f 00 1a 63 00 d9			.byte	$5a,$44,$7f,$00,$1a,$63,$00,$d9
>17f0	a5 a4 41 7d 5f 45 fd 04			.byte	$a5,$a4,$41,$7d,$5f,$45,$fd,$04
>17f8	34 38 bc bc 84 41 7d 5f			.byte	$34,$38,$bc,$bc,$84,$41,$7d,$5f
>1800	45 fd 04 34 38 00 15 64			.byte	$45,$fd,$04,$34,$38,$00,$15,$64
>1808	00 d9 a1 fe 09 75 66 64			.byte	$00,$d9,$a1,$fe,$09,$75,$66,$64
>1810	6c 62 67 6f bd 40 bc 84			.byte	$6c,$62,$67,$6f,$bd,$40,$bc,$84
>1818	fe 02 00 1c 65 00 d9 bb			.byte	$fe,$02,$00,$1c,$65,$00,$d9,$bb
>1820	8b 41 62 66 6d fd 04 39			.byte	$8b,$41,$62,$66,$6d,$fd,$04,$39
>1828	31 88 8b 41 62 66 6d fd			.byte	$31,$88,$8b,$41,$62,$66,$6d,$fd
>1830	04 39 31 bc 84 40 00 12			.byte	$04,$39,$31,$bc,$84,$40,$00,$12
>1838	66 00 d9 bb 41 62 54 71			.byte	$66,$00,$d9,$bb,$41,$62,$54,$71
>1840	8b 41 62 54 71 bc 84 40			.byte	$8b,$41,$62,$54,$71,$bc,$84,$40
>1848	00 16 67 00 d9 bb 47 57			.byte	$00,$16,$67,$00,$d9,$bb,$47,$57
>1850	74 82 8b 41 6e 57 4d bc			.byte	$74,$82,$8b,$41,$6e,$57,$4d,$bc
>1858	84 8b 41 69 40 79 00 11			.byte	$84,$8b,$41,$69,$40,$79,$00,$11
>1860	68 00 d9 9a 8b 42 5c 57			.byte	$68,$00,$d9,$9a,$8b,$42,$5c,$57
>1868	59 bc 84 42 5c 57 59 00			.byte	$59,$bc,$84,$42,$5c,$57,$59,$00
>1870	15 69 00 d9 a2 fe 06 73			.byte	$15,$69,$00,$d9,$a2,$fe,$06,$73
>1878	63 73 6e bd 44 bd 46 bc			.byte	$63,$73,$6e,$bd,$44,$bd,$46,$bc
>1880	84 fe 03 6e 00 1c 6a 00			.byte	$84,$fe,$03,$6e,$00,$1c,$6a,$00
>1888	d9 bb 8b 42 5b 53 67 fd			.byte	$d9,$bb,$8b,$42,$5b,$53,$67,$fd
>1890	04 33 33 85 8b 42 5b 53			.byte	$04,$33,$33,$85,$8b,$42,$5b,$53
>1898	67 fd 04 33 33 bc 84 40			.byte	$67,$fd,$04,$33,$33,$bc,$84,$40
>18a0	00 12 6b 00 d9 bb 43 51			.byte	$00,$12,$6b,$00,$d9,$bb,$43,$51
>18a8	78 53 86 43 51 78 53 bc			.byte	$78,$53,$86,$43,$51,$78,$53,$bc
>18b0	84 40 00 17 6c 00 d9 bb			.byte	$84,$40,$00,$17,$6c,$00,$d9,$bb
>18b8	8b 43 4e 60 75 82 8b 42			.byte	$8b,$43,$4e,$60,$75,$82,$8b,$42
>18c0	4a 6c 55 bc 84 41 44 4c			.byte	$4a,$6c,$55,$bc,$84,$41,$44,$4c
>18c8	60 00 0d 6d 00 d9 b3 43			.byte	$60,$00,$0d,$6d,$00,$d9,$b3,$43
>18d0	6e 5c 74 bc 84 41 00 0d			.byte	$6e,$5c,$74,$bc,$84,$41,$00,$0d
>18d8	6e 00 d9 a6 fe 04 6a 64			.byte	$6e,$00,$d9,$a6,$fe,$04,$6a,$64
>18e0	bc 84 42 00 23 6f 00 d9			.byte	$bc,$84,$42,$00,$23,$6f,$00,$d9
>18e8	bb 8b 43 43 45 4a fd 04			.byte	$bb,$8b,$43,$43,$45,$4a,$fd,$04
>18f0	35 35 8a 8b 43 43 45 4a			.byte	$35,$35,$8a,$8b,$43,$43,$45,$4a
>18f8	fd 04 35 35 bc 84 8b 46			.byte	$fd,$04,$35,$35,$bc,$84,$8b,$46
>1900	46 4a 55 fd 03 31 00 12			.byte	$46,$4a,$55,$fd,$03,$31,$00,$12
>1908	70 00 d9 bb 43 56 66 4a			.byte	$70,$00,$d9,$bb,$43,$56,$66,$4a
>1910	86 43 56 66 4a bc 84 40			.byte	$86,$43,$56,$66,$4a,$bc,$84,$40
>1918	00 17 71 00 d9 bb 8b 42			.byte	$00,$17,$71,$00,$d9,$bb,$8b,$42
>1920	7c 77 58 80 8b 4e 64 44			.byte	$7c,$77,$58,$80,$8b,$4e,$64,$44
>1928	bc 84 8b 42 7e 77 58 00			.byte	$bc,$84,$8b,$42,$7e,$77,$58,$00
>1930	13 72 00 d9 9b fe 09 70			.byte	$13,$72,$00,$d9,$9b,$fe,$09,$70
>1938	62 78 6d 6b 67 6e bc 84			.byte	$62,$78,$6d,$6b,$67,$6e,$bc,$84
>1940	41 70 00 1d 73 00 d9 bb			.byte	$41,$70,$00,$1d,$73,$00,$d9,$bb
>1948	8b 41 61 54 6c fd 04 39			.byte	$8b,$41,$61,$54,$6c,$fd,$04,$39
>1950	38 84 8b 41 61 54 6c fd			.byte	$38,$84,$8b,$41,$61,$54,$6c,$fd
>1958	04 39 38 bc 84 8b 41 00			.byte	$04,$39,$38,$bc,$84,$8b,$41,$00
>1960	10 74 00 d9 bb 60 4a 5a			.byte	$10,$74,$00,$d9,$bb,$60,$4a,$5a
>1968	88 60 4a 5a bc 84 40 00			.byte	$88,$60,$4a,$5a,$bc,$84,$40,$00
>1970	0f 75 00 d9 bb 40 80 8b			.byte	$0f,$75,$00,$d9,$bb,$40,$80,$8b
>1978	65 65 4f bc 84 40 00 10			.byte	$65,$65,$4f,$bc,$84,$40,$00,$10
>1980	76 00 d9 98 43 48 5a 4d			.byte	$76,$00,$d9,$98,$43,$48,$5a,$4d
>1988	84 8b 43 48 5a 4e 00 0d			.byte	$84,$8b,$43,$48,$5a,$4e,$00,$0d
>1990	77 00 d9 b4 41 71 bc 84			.byte	$77,$00,$d9,$b4,$41,$71,$bc,$84
>1998	fe 03 71 00 1b 78 00 d9			.byte	$fe,$03,$71,$00,$1b,$78,$00,$d9
>19a0	bb 73 48 fd 05 38 38 35			.byte	$bb,$73,$48,$fd,$05,$38,$38,$35
>19a8	8b 73 48 fd 05 38 38 35			.byte	$8b,$73,$48,$fd,$05,$38,$38,$35
>19b0	bc 84 40 fd 03 30 00 13			.byte	$bc,$84,$40,$fd,$03,$30,$00,$13
>19b8	79 00 d9 bb 43 4a 72 5e			.byte	$79,$00,$d9,$bb,$43,$4a,$72,$5e
>19c0	89 43 4a 72 5e bc 84 8b			.byte	$89,$43,$4a,$72,$5e,$bc,$84,$8b
>19c8	41 00 16 7a 00 d9 bb 8b			.byte	$41,$00,$16,$7a,$00,$d9,$bb,$8b
>19d0	41 76 41 52 82 41 79 50			.byte	$41,$76,$41,$52,$82,$41,$79,$50
>19d8	4b bc 84 8b 4f 51 5b 00			.byte	$4b,$bc,$84,$8b,$4f,$51,$5b,$00
>19e0	1a 7b 00 d9 a5 a4 43 46			.byte	$1a,$7b,$00,$d9,$a5,$a4,$43,$46
>19e8	5b 7a fd 04 32 38 bc bc			.byte	$5b,$7a,$fd,$04,$32,$38,$bc,$bc
>19f0	84 43 46 5b 7a fd 04 32			.byte	$84,$43,$46,$5b,$7a,$fd,$04,$32
>19f8	38 00 0c 7c 00 d9 a3 41			.byte	$38,$00,$0c,$7c,$00,$d9,$a3,$41
>1a00	bc 84 fe 03 20 00 1a 7d			.byte	$bc,$84,$fe,$03,$20,$00,$1a,$7d
>1a08	00 d9 bb 8b 77 41 6e fd			.byte	$00,$d9,$bb,$8b,$77,$41,$6e,$fd
>1a10	04 31 36 85 8b 77 41 6e			.byte	$04,$31,$36,$85,$8b,$77,$41,$6e
>1a18	fd 04 31 36 bc 84 40 00			.byte	$fd,$04,$31,$36,$bc,$84,$40,$00
>1a20	10 7e 00 d9 bb 7d 7e 7d			.byte	$10,$7e,$00,$d9,$bb,$7d,$7e,$7d
>1a28	85 7d 7e 7d bc 84 40 00			.byte	$85,$7d,$7e,$7d,$bc,$84,$40,$00
>1a30	10 7f 00 d9 bb 8b 43 5e			.byte	$10,$7f,$00,$d9,$bb,$8b,$43,$5e
>1a38	59 5d 80 40 bc 84 40 00			.byte	$59,$5d,$80,$40,$bc,$84,$40,$00
>1a40	0e 80 00 d9 9a 78 4f 61			.byte	$0e,$80,$00,$d9,$9a,$78,$4f,$61
>1a48	bc 84 78 4f 61 00 13 81			.byte	$bc,$84,$78,$4f,$61,$00,$13,$81
>1a50	00 d9 a7 43 48 7d 4d bc			.byte	$00,$d9,$a7,$43,$48,$7d,$4d,$bc
>1a58	84 fe 07 43 38 46 34 44			.byte	$84,$fe,$07,$43,$38,$46,$34,$44
>1a60	00 20 82 00 d9 bb 50 54			.byte	$00,$20,$82,$00,$d9,$bb,$50,$54
>1a68	6b fd 05 31 38 37 8a 50			.byte	$6b,$fd,$05,$31,$38,$37,$8a,$50
>1a70	54 6b fd 05 31 38 37 bc			.byte	$54,$6b,$fd,$05,$31,$38,$37,$bc
>1a78	84 60 69 56 fd 04 33 37			.byte	$84,$60,$69,$56,$fd,$04,$33,$37
>1a80	00 12 83 00 d9 bb 8b 56			.byte	$00,$12,$83,$00,$d9,$bb,$8b,$56
>1a88	4e 64 86 8b 56 4e 64 bc			.byte	$4e,$64,$86,$8b,$56,$4e,$64,$bc
>1a90	84 40 00 18 84 00 d9 bb			.byte	$84,$40,$00,$18,$84,$00,$d9,$bb
>1a98	8b 41 54 5c 4e 81 8b 43			.byte	$8b,$41,$54,$5c,$4e,$81,$8b,$43
>1aa0	5a 53 65 bc 84 8b 41 50			.byte	$5a,$53,$65,$bc,$84,$8b,$41,$50
>1aa8	50 45 00 0d 85 00 d9 b3			.byte	$50,$45,$00,$0d,$85,$00,$d9,$b3
>1ab0	41 6b 62 52 bc 84 41 00			.byte	$41,$6b,$62,$52,$bc,$84,$41,$00
>1ab8	12 86 00 d9 af fe 07 33			.byte	$12,$86,$00,$d9,$af,$fe,$07,$33
>1ac0	43 33 39 36 bc 84 7c 4e			.byte	$43,$33,$39,$36,$bc,$84,$7c,$4e
>1ac8	56 00 1d 87 00 d9 bb 8b			.byte	$56,$00,$1d,$87,$00,$d9,$bb,$8b
>1ad0	43 5a 58 74 fd 04 35 36			.byte	$43,$5a,$58,$74,$fd,$04,$35,$36
>1ad8	89 8b 43 5a 58 74 fd 04			.byte	$89,$8b,$43,$5a,$58,$74,$fd,$04
>1ae0	35 36 bc 84 8b 41 00 12			.byte	$35,$36,$bc,$84,$8b,$41,$00,$12
>1ae8	88 00 d9 bb 43 6f 59 5e			.byte	$88,$00,$d9,$bb,$43,$6f,$59,$5e
>1af0	85 43 6f 59 5e bc 84 40			.byte	$85,$43,$6f,$59,$5e,$bc,$84,$40
>1af8	00 17 89 00 d9 bb 43 73			.byte	$00,$17,$89,$00,$d9,$bb,$43,$73
>1b00	42 68 82 8b 41 48 56 67			.byte	$42,$68,$82,$8b,$41,$48,$56,$67
>1b08	bc 84 8b 42 7b 54 4f 00			.byte	$bc,$84,$8b,$42,$7b,$54,$4f,$00
>1b10	16 8a 00 d9 b2 8b 41 5a			.byte	$16,$8a,$00,$d9,$b2,$8b,$41,$5a
>1b18	71 7b bd 42 65 7d 7e bc			.byte	$71,$7b,$bd,$42,$65,$7d,$7e,$bc
>1b20	84 41 5a 71 7b 00 17 8b			.byte	$84,$41,$5a,$71,$7b,$00,$17,$8b
>1b28	00 d9 a0 fe 0a 61 6d 6c			.byte	$00,$d9,$a0,$fe,$0a,$61,$6d,$6c
>1b30	74 6a 6f 75 78 bd 41 bc			.byte	$74,$6a,$6f,$75,$78,$bd,$41,$bc
>1b38	84 fe 03 61 00 1c 8c 00			.byte	$84,$fe,$03,$61,$00,$1c,$8c,$00
>1b40	d9 bb 8b 41 5b 5d 6f fd			.byte	$d9,$bb,$8b,$41,$5b,$5d,$6f,$fd
>1b48	04 37 32 85 8b 41 5b 5d			.byte	$04,$37,$32,$85,$8b,$41,$5b,$5d
>1b50	6f fd 04 37 32 bc 84 40			.byte	$6f,$fd,$04,$37,$32,$bc,$84,$40
>1b58	00 0c 8d 00 d9 bb 40 88			.byte	$00,$0c,$8d,$00,$d9,$bb,$40,$88
>1b60	40 bc 84 40 00 14 8e 00			.byte	$40,$bc,$84,$40,$00,$14,$8e,$00
>1b68	d9 bb 70 56 66 81 41 6a			.byte	$d9,$bb,$70,$56,$66,$81,$41,$6a
>1b70	65 73 bc 84 41 7a 77 77			.byte	$65,$73,$bc,$84,$41,$7a,$77,$77
>1b78	00 10 8f 00 d9 98 8b 41			.byte	$00,$10,$8f,$00,$d9,$98,$8b,$41
>1b80	69 47 68 84 41 69 47 67			.byte	$69,$47,$68,$84,$41,$69,$47,$67
>1b88	00 11 90 00 d9 a1 fe 04			.byte	$00,$11,$90,$00,$d9,$a1,$fe,$04
>1b90	6b 7a bd 41 bc 84 fe 03			.byte	$6b,$7a,$bd,$41,$bc,$84,$fe,$03
>1b98	7a 00 1c 91 00 d9 bb 8b			.byte	$7a,$00,$1c,$91,$00,$d9,$bb,$8b
>1ba0	43 63 67 78 fd 04 36 31			.byte	$43,$63,$67,$78,$fd,$04,$36,$31
>1ba8	85 8b 43 63 67 78 fd 04			.byte	$85,$8b,$43,$63,$67,$78,$fd,$04
>1bb0	36 31 bc 84 40 00 0c 92			.byte	$36,$31,$bc,$84,$40,$00,$0c,$92
>1bb8	00 d9 bb 40 8b 40 bc 84			.byte	$00,$d9,$bb,$40,$8b,$40,$bc,$84
>1bc0	40 00 12 93 00 d9 bb 40			.byte	$40,$00,$12,$93,$00,$d9,$bb,$40
>1bc8	81 43 4a 79 53 bc 84 43			.byte	$81,$43,$4a,$79,$53,$bc,$84,$43
>1bd0	4a 79 53 00 14 94 00 d9			.byte	$4a,$79,$53,$00,$14,$94,$00,$d9
>1bd8	a5 a4 8b 42 55 77 5c bc			.byte	$a5,$a4,$8b,$42,$55,$77,$5c,$bc
>1be0	bc 84 8b 42 55 77 5c 00			.byte	$bc,$84,$8b,$42,$55,$77,$5c,$00
>1be8	10 95 00 d9 a2 fe 02 bd			.byte	$10,$95,$00,$d9,$a2,$fe,$02,$bd
>1bf0	49 bd 4a bc 84 fe 02 00			.byte	$49,$bd,$4a,$bc,$84,$fe,$02,$00
>1bf8	18 96 00 d9 bb 43 71 6a			.byte	$18,$96,$00,$d9,$bb,$43,$71,$6a
>1c00	74 fd 03 37 85 43 71 6a			.byte	$74,$fd,$03,$37,$85,$43,$71,$6a
>1c08	74 fd 03 37 bc 84 40 00			.byte	$74,$fd,$03,$37,$bc,$84,$40,$00
>1c10	14 97 00 d9 bb 8b 41 63			.byte	$14,$97,$00,$d9,$bb,$8b,$41,$63
>1c18	4f 4b 88 8b 41 63 4f 4b			.byte	$4f,$4b,$88,$8b,$41,$63,$4f,$4b
>1c20	bc 84 40 00 16 98 00 d9			.byte	$bc,$84,$40,$00,$16,$98,$00,$d9
>1c28	bb 43 73 66 7c 82 8b 72			.byte	$bb,$43,$73,$66,$7c,$82,$8b,$72
>1c30	58 52 bc 84 8b 43 41 7e			.byte	$58,$52,$bc,$84,$8b,$43,$41,$7e
>1c38	6e 00 11 99 00 d9 9a 8b			.byte	$6e,$00,$11,$99,$00,$d9,$9a,$8b
>1c40	43 5b 51 62 bc 84 43 5b			.byte	$43,$5b,$51,$62,$bc,$84,$43,$5b
>1c48	51 62 00 10 9a 00 d9 a6			.byte	$51,$62,$00,$10,$9a,$00,$d9,$a6
>1c50	fe 07 78 65 6e 6a 6b bc			.byte	$fe,$07,$78,$65,$6e,$6a,$6b,$bc
>1c58	84 45 00 1d 9b 00 d9 bb			.byte	$84,$45,$00,$1d,$9b,$00,$d9,$bb
>1c60	8b 43 70 7d 70 fd 04 35			.byte	$8b,$43,$70,$7d,$70,$fd,$04,$35
>1c68	38 89 8b 43 70 7d 70 fd			.byte	$38,$89,$8b,$43,$70,$7d,$70,$fd
>1c70	04 35 38 bc 84 8b 41 00			.byte	$04,$35,$38,$bc,$84,$8b,$41,$00
>1c78	12 9c 00 d9 bb 8b 43 78			.byte	$12,$9c,$00,$d9,$bb,$8b,$43,$78
>1c80	48 8b 8b 43 78 48 bc 84			.byte	$48,$8b,$8b,$43,$78,$48,$bc,$84
>1c88	40 00 16 9d 00 d9 bb 41			.byte	$40,$00,$16,$9d,$00,$d9,$bb,$41
>1c90	53 68 5a 82 8b 45 50 71			.byte	$53,$68,$5a,$82,$8b,$45,$50,$71
>1c98	bc 84 8b 41 56 78 6b 00			.byte	$bc,$84,$8b,$41,$56,$78,$6b,$00
>1ca0	0f 9e 00 d9 b3 8b 41 5f			.byte	$0f,$9e,$00,$d9,$b3,$8b,$41,$5f
>1ca8	7e 67 bc 84 8b 41 00 0d			.byte	$7e,$67,$bc,$84,$8b,$41,$00,$0d
>1cb0	9f 00 d9 9b fe 03 7a bc			.byte	$9f,$00,$d9,$9b,$fe,$03,$7a,$bc
>1cb8	84 41 7a 00 1c a0 00 d9			.byte	$84,$41,$7a,$00,$1c,$a0,$00,$d9
>1cc0	bb 8b 41 56 4b 5d fd 04			.byte	$bb,$8b,$41,$56,$4b,$5d,$fd,$04
>1cc8	37 33 88 8b 41 56 4b 5d			.byte	$37,$33,$88,$8b,$41,$56,$4b,$5d
>1cd0	fd 04 37 33 bc 84 40 00			.byte	$fd,$04,$37,$33,$bc,$84,$40,$00
>1cd8	15 a1 00 d9 bb 8b 41 7b			.byte	$15,$a1,$00,$d9,$bb,$8b,$41,$7b
>1ce0	65 54 87 8b 41 7b 65 54			.byte	$65,$54,$87,$8b,$41,$7b,$65,$54
>1ce8	bc 84 8b 41 00 10 a2 00			.byte	$bc,$84,$8b,$41,$00,$10,$a2,$00
>1cf0	d9 bb 40 80 8b 42 73 4e			.byte	$d9,$bb,$40,$80,$8b,$42,$73,$4e
>1cf8	61 bc 84 40 00 13 a3 00			.byte	$61,$bc,$84,$40,$00,$13,$a3,$00
>1d00	d9 b2 41 5f 61 5c bd 4b			.byte	$d9,$b2,$41,$5f,$61,$5c,$bd,$4b
>1d08	69 71 bc 84 42 53 54 00			.byte	$69,$71,$bc,$84,$42,$53,$54,$00
>1d10	0d a4 00 d9 b4 41 4a bc			.byte	$0d,$a4,$00,$d9,$b4,$41,$4a,$bc
>1d18	84 fe 03 4a 00 19 a5 00			.byte	$84,$fe,$03,$4a,$00,$19,$a5,$00
>1d20	d9 bb 48 69 79 fd 04 33			.byte	$d9,$bb,$48,$69,$79,$fd,$04,$33
>1d28	39 87 48 69 79 fd 04 33			.byte	$39,$87,$48,$69,$79,$fd,$04,$33
>1d30	39 bc 84 8b 41 00 15 a6			.byte	$39,$bc,$84,$8b,$41,$00,$15,$a6
>1d38	00 d9 bb 8b 43 52 4c 43			.byte	$00,$d9,$bb,$8b,$43,$52,$4c,$43
>1d40	87 8b 43 52 4c 43 bc 84			.byte	$87,$8b,$43,$52,$4c,$43,$bc,$84
>1d48	8b 41 00 15 a7 00 d9 bb			.byte	$8b,$41,$00,$15,$a7,$00,$d9,$bb
>1d50	8b 41 79 7c 65 80 41 63			.byte	$8b,$41,$79,$7c,$65,$80,$41,$63
>1d58	42 5c bc 84 42 42 58 00			.byte	$42,$5c,$bc,$84,$42,$42,$58,$00
>1d60	10 a8 00 d9 98 8b 41 5c			.byte	$10,$a8,$00,$d9,$98,$8b,$41,$5c
>1d68	4d 7a 84 41 5c 4d 79 00			.byte	$4d,$7a,$84,$41,$5c,$4d,$79,$00
>1d70	17 a9 00 d9 a3 4c bc 84			.byte	$17,$a9,$00,$d9,$a3,$4c,$bc,$84
>1d78	fe 0e 20 20 20 20 20 20			.byte	$fe,$0e,$20,$20,$20,$20,$20,$20
>1d80	20 20 20 20 20 20 00 1d			.byte	$20,$20,$20,$20,$20,$20,$00,$1d
>1d88	aa 00 d9 bb 41 68 63 4f			.byte	$aa,$00,$d9,$bb,$41,$68,$63,$4f
>1d90	fd 04 32 31 8d 41 68 63			.byte	$fd,$04,$32,$31,$8d,$41,$68,$63
>1d98	4f fd 04 32 31 bc 84 41			.byte	$4f,$fd,$04,$32,$31,$bc,$84,$41
>1da0	fd 03 30 00 14 ab 00 d9			.byte	$fd,$03,$30,$00,$14,$ab,$00,$d9
>1da8	bb 8b 43 42 5c 56 85 8b			.byte	$bb,$8b,$43,$42,$5c,$56,$85,$8b
>1db0	43 42 5c 56 bc 84 40 00			.byte	$43,$42,$5c,$56,$bc,$84,$40,$00
>1db8	18 ac 00 d9 bb 8b 41 46			.byte	$18,$ac,$00,$d9,$bb,$8b,$41,$46
>1dc0	45 4b 81 8b 41 4f 47 75			.byte	$45,$4b,$81,$8b,$41,$4f,$47,$75
>1dc8	bc 84 8b 41 46 45 41 00			.byte	$bc,$84,$8b,$41,$46,$45,$41,$00
>1dd0	12 ad 00 d9 a5 a4 8b 4e			.byte	$12,$ad,$00,$d9,$a5,$a4,$8b,$4e
>1dd8	49 57 bc bc 84 8b 4e 49			.byte	$49,$57,$bc,$bc,$84,$8b,$4e,$49
>1de0	57 00 13 ae 00 d9 a7 43			.byte	$57,$00,$13,$ae,$00,$d9,$a7,$43
>1de8	73 57 5e bc 84 fe 07 46			.byte	$73,$57,$5e,$bc,$84,$fe,$07,$46
>1df0	33 35 44 45 00 1f af 00			.byte	$33,$35,$44,$45,$00,$1f,$af,$00
>1df8	d9 bb 8b 42 4c 58 6e fd			.byte	$d9,$bb,$8b,$42,$4c,$58,$6e,$fd
>1e00	04 36 37 8d 8b 42 4c 58			.byte	$04,$36,$37,$8d,$8b,$42,$4c,$58
>1e08	6e fd 04 36 37 bc 84 41			.byte	$6e,$fd,$04,$36,$37,$bc,$84,$41
>1e10	fd 03 30 00 12 b0 00 d9			.byte	$fd,$03,$30,$00,$12,$b0,$00,$d9
>1e18	bb 46 49 77 8a 46 49 77			.byte	$bb,$46,$49,$77,$8a,$46,$49,$77
>1e20	bc 84 4c 53 6e 00 16 b1			.byte	$bc,$84,$4c,$53,$6e,$00,$16,$b1
>1e28	00 d9 bb 42 58 4e 58 81			.byte	$00,$d9,$bb,$42,$58,$4e,$58,$81
>1e30	8b 42 4a 4a 4d bc 84 8b			.byte	$8b,$42,$4a,$4a,$4d,$bc,$84,$8b
>1e38	42 40 45 00 10 b2 00 d9			.byte	$42,$40,$45,$00,$10,$b2,$00,$d9
>1e40	9a 42 49 4a 57 bc 84 42			.byte	$9a,$42,$49,$4a,$57,$bc,$84,$42
>1e48	49 4a 57 00 13 b3 00 d9			.byte	$49,$4a,$57,$00,$13,$b3,$00,$d9
>1e50	af fe 07 44 41 35 36 41			.byte	$af,$fe,$07,$44,$41,$35,$36,$41
>1e58	bc 84 43 5a 55 6a 00 1a			.byte	$bc,$84,$43,$5a,$55,$6a,$00,$1a
>1e60	b4 00 d9 bb 41 4a 58 74			.byte	$b4,$00,$d9,$bb,$41,$4a,$58,$74
>1e68	fd 04 39 36 88 41 4a 58			.byte	$fd,$04,$39,$36,$88,$41,$4a,$58
>1e70	74 fd 04 39 36 bc 84 40			.byte	$74,$fd,$04,$39,$36,$bc,$84,$40
>1e78	00 14 b5 00 d9 bb 8b 43			.byte	$00,$14,$b5,$00,$d9,$bb,$8b,$43
>1e80	5e 49 79 88 8b 43 5e 49			.byte	$5e,$49,$79,$88,$8b,$43,$5e,$49
>1e88	79 bc 84 40 00 13 b6 00			.byte	$79,$bc,$84,$40,$00,$13,$b6,$00
>1e90	d9 bb 7e 6b 7c 80 41 5f			.byte	$d9,$bb,$7e,$6b,$7c,$80,$41,$5f
>1e98	5e 70 bc 84 5e 4a 70 00			.byte	$5e,$70,$bc,$84,$5e,$4a,$70,$00
>1ea0	0f b7 00 d9 b3 8b 43 50			.byte	$0f,$b7,$00,$d9,$b3,$8b,$43,$50
>1ea8	53 73 bc 84 8b 41 00 10			.byte	$53,$73,$bc,$84,$8b,$41,$00,$10
>1eb0	b8 00 d9 a0 fe 03 6c bd			.byte	$b8,$00,$d9,$a0,$fe,$03,$6c,$bd
>1eb8	45 bc 84 fe 03 6c 00 29			.byte	$45,$bc,$84,$fe,$03,$6c,$00,$29
>1ec0	b9 00 d9 bb 8b 42 45 47			.byte	$b9,$00,$d9,$bb,$8b,$42,$45,$47
>1ec8	54 fd 04 30 32 8c 8b 42			.byte	$54,$fd,$04,$30,$32,$8c,$8b,$42
>1ed0	45 47 54 fd 04 30 32 bc			.byte	$45,$47,$54,$fd,$04,$30,$32,$bc
>1ed8	84 42 fd 0d 39 37 32 38			.byte	$84,$42,$fd,$0d,$39,$37,$32,$38
>1ee0	32 33 31 36 65 31 31 00			.byte	$32,$33,$31,$36,$65,$31,$31,$00
>1ee8	18 ba 00 d9 bb 8b 41 75			.byte	$18,$ba,$00,$d9,$bb,$8b,$41,$75
>1ef0	58 66 8a 8b 41 75 58 66			.byte	$58,$66,$8a,$8b,$41,$75,$58,$66
>1ef8	bc 84 8b 43 6a 71 4c 00			.byte	$bc,$84,$8b,$43,$6a,$71,$4c,$00
>1f00	14 bb 00 d9 bb 8b 6b 76			.byte	$14,$bb,$00,$d9,$bb,$8b,$6b,$76
>1f08	65 82 69 7e 4e bc 84 8b			.byte	$65,$82,$69,$7e,$4e,$bc,$84,$8b
>1f10	42 48 6b 00 15 bc 00 d9			.byte	$42,$48,$6b,$00,$15,$bc,$00,$d9
>1f18	b2 8b 41 59 4c 45 bd 41			.byte	$b2,$8b,$41,$59,$4c,$45,$bd,$41
>1f20	55 6f 62 bc 84 43 5c 63			.byte	$55,$6f,$62,$bc,$84,$43,$5c,$63
>1f28	00 18 bd 00 d9 a1 fe 07			.byte	$00,$18,$bd,$00,$d9,$a1,$fe,$07
>1f30	66 69 6c 6c 71 bd 45 bc			.byte	$66,$69,$6c,$6c,$71,$bd,$45,$bc
>1f38	84 fe 07 66 69 6c 6c 71			.byte	$84,$fe,$07,$66,$69,$6c,$6c,$71
>1f40	00 20 be 00 d9 bb 43 50			.byte	$00,$20,$be,$00,$d9,$bb,$43,$50
>1f48	6f 41 fd 04 36 31 8a 43			.byte	$6f,$41,$fd,$04,$36,$31,$8a,$43
>1f50	50 6f 41 fd 04 36 31 bc			.byte	$50,$6f,$41,$fd,$04,$36,$31,$bc
>1f58	84 46 61 5e 43 fd 03 32			.byte	$84,$46,$61,$5e,$43,$fd,$03,$32
>1f60	00 18 bf 00 d9 bb 8b 42			.byte	$00,$18,$bf,$00,$d9,$bb,$8b,$42
>1f68	41 64 57 8a 8b 42 41 64			.byte	$41,$64,$57,$8a,$8b,$42,$41,$64
>1f70	57 bc 84 8b 44 43 48 6e			.byte	$57,$bc,$84,$8b,$44,$43,$48,$6e
>1f78	00 15 c0 00 d9 bb 42 52			.byte	$00,$15,$c0,$00,$d9,$bb,$42,$52
>1f80	64 6a 81 43 4e 5e 7c bc			.byte	$64,$6a,$81,$43,$4e,$5e,$7c,$bc
>1f88	84 43 5e 7e 7e 00 10 c1			.byte	$84,$43,$5e,$7e,$7e,$00,$10,$c1
>1f90	00 d9 98 41 50 62 4b 84			.byte	$00,$d9,$98,$41,$50,$62,$4b,$84
>1f98	8b 41 50 62 4c 00 20 c2			.byte	$8b,$41,$50,$62,$4c,$00,$20,$c2
>1fa0	00 d9 a2 fe 0b 73 68 69			.byte	$00,$d9,$a2,$fe,$0b,$73,$68,$69
>1fa8	68 70 66 6f 6d 6b bd 43			.byte	$68,$70,$66,$6f,$6d,$6b,$bd,$43
>1fb0	bd 47 bc 84 fe 09 69 68			.byte	$bd,$47,$bc,$84,$fe,$09,$69,$68
>1fb8	70 66 6f 6d 6b 00 18 c3			.byte	$70,$66,$6f,$6d,$6b,$00,$18,$c3
>1fc0	00 d9 bb 43 64 44 7d fd			.byte	$00,$d9,$bb,$43,$64,$44,$7d,$fd
>1fc8	03 31 85 43 64 44 7d fd			.byte	$03,$31,$85,$43,$64,$44,$7d,$fd
>1fd0	03 31 bc 84 40 00 10 c4			.byte	$03,$31,$bc,$84,$40,$00,$10,$c4
>1fd8	00 d9 bb 72 7a 75 88 72			.byte	$00,$d9,$bb,$72,$7a,$75,$88,$72
>1fe0	7a 75 bc 84 40 00 13 c5			.byte	$7a,$75,$bc,$84,$40,$00,$13,$c5
>1fe8	00 d9 bb 8b 41 5e 50 40			.byte	$00,$d9,$bb,$8b,$41,$5e,$50,$40
>1ff0	80 5a 7d 70 bc 84 70 40			.byte	$80,$5a,$7d,$70,$bc,$84,$70,$40
>1ff8	00 1c c6 00 d9 a5 a4 8b			.byte	$00,$1c,$c6,$00,$d9,$a5,$a4,$8b
>2000	42 79 69 49 fd 04 32 38			.byte	$42,$79,$69,$49,$fd,$04,$32,$38
>2008	bc bc 84 8b 42 79 69 49			.byte	$bc,$bc,$84,$8b,$42,$79,$69,$49
>2010	fd 04 32 38 00 0c c7 00			.byte	$fd,$04,$32,$38,$00,$0c,$c7,$00
>2018	d9 a6 fe 03 71 bc 84 41			.byte	$d9,$a6,$fe,$03,$71,$bc,$84,$41
>2020	00 21 c8 00 d9 bb 41 72			.byte	$00,$21,$c8,$00,$d9,$bb,$41,$72
>2028	65 59 fd 04 39 33 8a 41			.byte	$65,$59,$fd,$04,$39,$33,$8a,$41
>2030	72 65 59 fd 04 39 33 bc			.byte	$72,$65,$59,$fd,$04,$39,$33,$bc
>2038	84 43 65 4a 73 fd 04 38			.byte	$84,$43,$65,$4a,$73,$fd,$04,$38
>2040	35 00 18 c9 00 d9 bb 8b			.byte	$35,$00,$18,$c9,$00,$d9,$bb,$8b
>2048	43 5d 57 5c 8a 8b 43 5d			.byte	$43,$5d,$57,$5c,$8a,$8b,$43,$5d
>2050	57 5c bc 84 8b 46 7a 6e			.byte	$57,$5c,$bc,$84,$8b,$46,$7a,$6e
>2058	78 00 14 ca 00 d9 bb 42			.byte	$78,$00,$14,$ca,$00,$d9,$bb,$42
>2060	6a 78 78 82 78 7d 67 bc			.byte	$6a,$78,$78,$82,$78,$7d,$67,$bc
>2068	84 42 52 45 5f 00 0f cb			.byte	$84,$42,$52,$45,$5f,$00,$0f,$cb
>2070	00 d9 9a 8b 59 71 61 bc			.byte	$00,$d9,$9a,$8b,$59,$71,$61,$bc
>2078	84 59 71 61 00 12 cc 00			.byte	$84,$59,$71,$61,$00,$12,$cc,$00
>2080	d9 9b fe 08 67 69 62 72			.byte	$d9,$9b,$fe,$08,$67,$69,$62,$72
>2088	6b 6a bc 84 41 67 00 28			.byte	$6b,$6a,$bc,$84,$41,$67,$00,$28
>2090	cd 00 d9 bb 8b 43 41 42			.byte	$cd,$00,$d9,$bb,$8b,$43,$41,$42
>2098	4d fd 03 30 8c 8b 4d 73			.byte	$4d,$fd,$03,$30,$8c,$8b,$4d,$73
>20a0	7e fd 05 31 31 32 bc 84			.byte	$7e,$fd,$05,$31,$31,$32,$bc,$84
>20a8	44 fd 0d 34 37 33 31 33			.byte	$44,$fd,$0d,$34,$37,$33,$31,$33
>20b0	39 36 37 65 31 30 00 0c			.byte	$39,$36,$37,$65,$31,$30,$00,$0c
>20b8	ce 00 d9 bb 40 88 40 bc			.byte	$ce,$00,$d9,$bb,$40,$88,$40,$bc
>20c0	84 40 00 17 cf 00 d9 bb			.byte	$84,$40,$00,$17,$cf,$00,$d9,$bb
>20c8	8b 43 48 6e 5f 80 8b 49			.byte	$8b,$43,$48,$6e,$5f,$80,$8b,$49
>20d0	49 44 bc 84 8b 43 49 6f			.byte	$49,$44,$bc,$84,$8b,$43,$49,$6f
>20d8	60 00 0f d0 00 d9 b3 8b			.byte	$60,$00,$0f,$d0,$00,$d9,$b3,$8b
>20e0	41 4b 5d 47 bc 84 8b 41			.byte	$41,$4b,$5d,$47,$bc,$84,$8b,$41
>20e8	00 0d d1 00 d9 b4 41 52			.byte	$00,$0d,$d1,$00,$d9,$b4,$41,$52
>20f0	bc 84 fe 03 52 00 1d d2			.byte	$bc,$84,$fe,$03,$52,$00,$1d,$d2
>20f8	00 d9 bb 41 78 62 7b fd			.byte	$00,$d9,$bb,$41,$78,$62,$7b,$fd
>2100	04 38 34 8d 41 78 62 7b			.byte	$04,$38,$34,$8d,$41,$78,$62,$7b
>2108	fd 04 38 34 bc 84 41 fd			.byte	$fd,$04,$38,$34,$bc,$84,$41,$fd
>2110	03 30 00 13 d3 00 d9 bb			.byte	$03,$30,$00,$13,$d3,$00,$d9,$bb
>2118	41 4a 79 6f 84 41 4a 79			.byte	$41,$4a,$79,$6f,$84,$41,$4a,$79
>2120	6f bc 84 8b 41 00 17 d4			.byte	$6f,$bc,$84,$8b,$41,$00,$17,$d4
>2128	00 d9 bb 8b 41 50 6e 76			.byte	$00,$d9,$bb,$8b,$41,$50,$6e,$76
>2130	82 8b 42 58 54 59 bc 84			.byte	$82,$8b,$42,$58,$54,$59,$bc,$84
>2138	43 48 7a 6d 00 15 d5 00			.byte	$43,$48,$7a,$6d,$00,$15,$d5,$00
>2140	d9 b2 41 55 52 58 bd 41			.byte	$d9,$b2,$41,$55,$52,$58,$bd,$41
>2148	61 7d 62 bc 84 41 55 52			.byte	$61,$7d,$62,$bc,$84,$41,$55,$52
>2150	58 00 1b d6 00 d9 a3 50			.byte	$58,$00,$1b,$d6,$00,$d9,$a3,$50
>2158	bc 84 fe 12 20 20 20 20			.byte	$bc,$84,$fe,$12,$20,$20,$20,$20
>2160	20 20 20 20 20 20 20 20			.byte	$20,$20,$20,$20,$20,$20,$20,$20
>2168	20 20 20 20 00 1a d7 00			.byte	$20,$20,$20,$20,$00,$1a,$d7,$00
>2170	d9 bb 41 5e 66 5d fd 04			.byte	$d9,$bb,$41,$5e,$66,$5d,$fd,$04
>2178	31 31 88 41 5e 66 5d fd			.byte	$31,$31,$88,$41,$5e,$66,$5d,$fd
>2180	04 31 31 bc 84 40 00 11			.byte	$04,$31,$31,$bc,$84,$40,$00,$11
>2188	d8 00 d9 bb 6e 71 4f 87			.byte	$d8,$00,$d9,$bb,$6e,$71,$4f,$87
>2190	6e 71 4f bc 84 8b 41 00			.byte	$6e,$71,$4f,$bc,$84,$8b,$41,$00
>2198	16 d9 00 d9 bb 42 60 48			.byte	$16,$d9,$00,$d9,$bb,$42,$60,$48
>21a0	4f 82 8b 55 74 77 bc 84			.byte	$4f,$82,$8b,$55,$74,$77,$bc,$84
>21a8	8b 42 75 7c 7a 00 10 da			.byte	$8b,$42,$75,$7c,$7a,$00,$10,$da
>21b0	00 d9 98 8b 43 57 74 4d			.byte	$00,$d9,$98,$8b,$43,$57,$74,$4d
>21b8	84 43 57 74 4c 00 13 db			.byte	$84,$43,$57,$74,$4c,$00,$13,$db
>21c0	00 d9 a7 41 73 51 5f bc			.byte	$00,$d9,$a7,$41,$73,$51,$5f,$bc
>21c8	84 fe 07 37 33 34 35 46			.byte	$84,$fe,$07,$37,$33,$34,$35,$46
>21d0	00 18 dc 00 d9 bb 7b 76			.byte	$00,$18,$dc,$00,$d9,$bb,$7b,$76
>21d8	5a fd 04 38 38 86 7b 76			.byte	$5a,$fd,$04,$38,$38,$86,$7b,$76
>21e0	5a fd 04 38 38 bc 84 40			.byte	$5a,$fd,$04,$38,$38,$bc,$84,$40
>21e8	00 16 dd 00 d9 bb 8b 66			.byte	$00,$16,$dd,$00,$d9,$bb,$8b,$66
>21f0	45 7a 8a 8b 66 45 7a bc			.byte	$45,$7a,$8a,$8b,$66,$45,$7a,$bc
>21f8	84 8b 41 4c 4b 74 00 16			.byte	$84,$8b,$41,$4c,$4b,$74,$00,$16
>2200	de 00 d9 bb 8b 41 6f 53			.byte	$de,$00,$d9,$bb,$8b,$41,$6f,$53
>2208	77 81 41 71 59 5a bc 84			.byte	$77,$81,$41,$71,$59,$5a,$bc,$84
>2210	8b 4e 42 65 00 1a df 00			.byte	$8b,$4e,$42,$65,$00,$1a,$df,$00
>2218	d9 a5 a4 43 49 5e 6f fd			.byte	$d9,$a5,$a4,$43,$49,$5e,$6f,$fd
>2220	04 38 31 bc bc 84 43 49			.byte	$04,$38,$31,$bc,$bc,$84,$43,$49
>2228	5e 6f fd 04 38 31 00 13			.byte	$5e,$6f,$fd,$04,$38,$31,$00,$13
>2230	e0 00 d9 af fe 07 44 34			.byte	$e0,$00,$d9,$af,$fe,$07,$44,$34
>2238	31 43 30 bc 84 43 54 47			.byte	$31,$43,$30,$bc,$84,$43,$54,$47
>2240	40 00 1d e1 00 d9 bb 41			.byte	$40,$00,$1d,$e1,$00,$d9,$bb,$41
>2248	76 61 62 fd 04 39 34 8d			.byte	$76,$61,$62,$fd,$04,$39,$34,$8d
>2250	41 76 61 62 fd 04 39 34			.byte	$41,$76,$61,$62,$fd,$04,$39,$34
>2258	bc 84 41 fd 03 30 00 15			.byte	$bc,$84,$41,$fd,$03,$30,$00,$15
>2260	e2 00 d9 bb 43 4f 45 7a			.byte	$e2,$00,$d9,$bb,$43,$4f,$45,$7a
>2268	8a 43 4f 45 7a bc 84 46			.byte	$8a,$43,$4f,$45,$7a,$bc,$84,$46
>2270	5e 4b 74 00 14 e3 00 d9			.byte	$5e,$4b,$74,$00,$14,$e3,$00,$d9
>2278	bb 57 78 6c 82 42 47 4f			.byte	$bb,$57,$78,$6c,$82,$42,$47,$4f
>2280	71 bc 84 42 50 77 5d 00			.byte	$71,$bc,$84,$42,$50,$77,$5d,$00
>2288	0f e4 00 d9 9a 8b 58 74			.byte	$0f,$e4,$00,$d9,$9a,$8b,$58,$74
>2290	75 bc 84 58 74 75 00 15			.byte	$75,$bc,$84,$58,$74,$75,$00,$15
>2298	e5 00 d9 a0 fe 07 6c 74			.byte	$e5,$00,$d9,$a0,$fe,$07,$6c,$74
>22a0	70 74 62 bd 42 bc 84 fe			.byte	$70,$74,$62,$bd,$42,$bc,$84,$fe
>22a8	04 6c 74 00 1d e6 00 d9			.byte	$04,$6c,$74,$00,$1d,$e6,$00,$d9
>22b0	bb 8b 42 47 6b 6d fd 04			.byte	$bb,$8b,$42,$47,$6b,$6d,$fd,$04
>22b8	33 38 84 8b 42 47 6b 6d			.byte	$33,$38,$84,$8b,$42,$47,$6b,$6d
>22c0	fd 04 33 38 bc 84 8b 41			.byte	$fd,$04,$33,$38,$bc,$84,$8b,$41
>22c8	00 13 e7 00 d9 bb 43 50			.byte	$00,$13,$e7,$00,$d9,$bb,$43,$50
>22d0	4a 64 85 41 6e 68 4f bc			.byte	$4a,$64,$85,$41,$6e,$68,$4f,$bc
>22d8	84 8b 41 00 13 e8 00 d9			.byte	$84,$8b,$41,$00,$13,$e8,$00,$d9
>22e0	bb 75 60 4a 80 41 53 69			.byte	$bb,$75,$60,$4a,$80,$41,$53,$69
>22e8	74 bc 84 51 60 40 00 0b			.byte	$74,$bc,$84,$51,$60,$40,$00,$0b
>22f0	e9 00 d9 b3 7b 7e bc 84			.byte	$e9,$00,$d9,$b3,$7b,$7e,$bc,$84
>22f8	41 00 18 ea 00 d9 a1 fe			.byte	$41,$00,$18,$ea,$00,$d9,$a1,$fe
>2300	08 6e 70 67 73 68 78 bd			.byte	$08,$6e,$70,$67,$73,$68,$78,$bd
>2308	44 bc 84 fe 06 67 73 68			.byte	$44,$bc,$84,$fe,$06,$67,$73,$68
>2310	78 00 18 eb 00 d9 bb 7a			.byte	$78,$00,$18,$eb,$00,$d9,$bb,$7a
>2318	49 40 fd 04 34 32 85 7a			.byte	$49,$40,$fd,$04,$34,$32,$85,$7a
>2320	49 40 fd 04 34 32 bc 84			.byte	$49,$40,$fd,$04,$34,$32,$bc,$84
>2328	40 00 15 ec 00 d9 bb 8b			.byte	$40,$00,$15,$ec,$00,$d9,$bb,$8b
>2330	42 49 64 59 87 8b 42 49			.byte	$42,$49,$64,$59,$87,$8b,$42,$49
>2338	64 59 bc 84 8b 41 00 10			.byte	$64,$59,$bc,$84,$8b,$41,$00,$10
>2340	ed 00 d9 bb 40 80 8b 42			.byte	$ed,$00,$d9,$bb,$40,$80,$8b,$42
>2348	45 45 62 bc 84 40 00 13			.byte	$45,$45,$62,$bc,$84,$40,$00,$13
>2350	ee 00 d9 b2 52 7a 6c bd			.byte	$ee,$00,$d9,$b2,$52,$7a,$6c,$bd
>2358	42 62 7b 77 bc 84 52 7a			.byte	$42,$62,$7b,$77,$bc,$84,$52,$7a
>2360	6c 00 14 ef 00 d9 a2 fe			.byte	$6c,$00,$14,$ef,$00,$d9,$a2,$fe
>2368	05 63 78 78 bd 43 bd 47			.byte	$05,$63,$78,$78,$bd,$43,$bd,$47
>2370	bc 84 fe 03 78 00 1b f0			.byte	$bc,$84,$fe,$03,$78,$00,$1b,$f0
>2378	00 d9 bb 41 4e 51 6f fd			.byte	$00,$d9,$bb,$41,$4e,$51,$6f,$fd
>2380	04 32 35 84 41 4e 51 6f			.byte	$04,$32,$35,$84,$41,$4e,$51,$6f
>2388	fd 04 32 35 bc 84 8b 41			.byte	$fd,$04,$32,$35,$bc,$84,$8b,$41
>2390	00 15 f1 00 d9 bb 8b 42			.byte	$00,$15,$f1,$00,$d9,$bb,$8b,$42
>2398	4d 74 44 84 8b 42 4d 74			.byte	$4d,$74,$44,$84,$8b,$42,$4d,$74
>23a0	44 bc 84 8b 41 00 15 f2			.byte	$44,$bc,$84,$8b,$41,$00,$15,$f2
>23a8	00 d9 bb 41 65 54 6d 81			.byte	$00,$d9,$bb,$41,$65,$54,$6d,$81
>23b0	43 4c 6e 74 bc 84 43 6d			.byte	$43,$4c,$6e,$74,$bc,$84,$43,$6d
>23b8	7e 7d 00 10 f3 00 d9 98			.byte	$7e,$7d,$00,$10,$f3,$00,$d9,$98
>23c0	42 58 77 79 84 8b 42 58			.byte	$42,$58,$77,$79,$84,$8b,$42,$58
>23c8	77 7a 00 11 f4 00 d9 a6			.byte	$77,$7a,$00,$11,$f4,$00,$d9,$a6
>23d0	fe 08 6d 7a 68 70 77 69			.byte	$fe,$08,$6d,$7a,$68,$70,$77,$69
>23d8	bc 84 46 00 1c f5 00 d9			.byte	$bc,$84,$46,$00,$1c,$f5,$00,$d9
>23e0	bb 8b 41 6c 68 4f fd 04			.byte	$bb,$8b,$41,$6c,$68,$4f,$fd,$04
>23e8	37 34 88 8b 41 6c 68 4f			.byte	$37,$34,$88,$8b,$41,$6c,$68,$4f
>23f0	fd 04 37 34 bc 84 40 00			.byte	$fd,$04,$37,$34,$bc,$84,$40,$00
>23f8	15 f6 00 d9 bb 8b 43 4e			.byte	$15,$f6,$00,$d9,$bb,$8b,$43,$4e
>2400	6e 4a 84 8b 43 4e 6e 4a			.byte	$6e,$4a,$84,$8b,$43,$4e,$6e,$4a
>2408	bc 84 8b 41 00 16 f7 00			.byte	$bc,$84,$8b,$41,$00,$16,$f7,$00
>2410	d9 bb 8b 42 55 6f 43 80			.byte	$d9,$bb,$8b,$42,$55,$6f,$43,$80
>2418	43 71 5e 40 bc 84 41 60			.byte	$43,$71,$5e,$40,$bc,$84,$41,$60
>2420	50 40 00 12 f8 00 d9 a5			.byte	$50,$40,$00,$12,$f8,$00,$d9,$a5
>2428	a4 41 7c 7c 58 bc bc 84			.byte	$a4,$41,$7c,$7c,$58,$bc,$bc,$84
>2430	41 7c 7c 58 00 14 f9 00			.byte	$41,$7c,$7c,$58,$00,$14,$f9,$00
>2438	d9 9b fe 0a 68 72 6d 6d			.byte	$d9,$9b,$fe,$0a,$68,$72,$6d,$6d
>2440	6f 69 67 6b bc 84 41 68			.byte	$6f,$69,$67,$6b,$bc,$84,$41,$68
>2448	00 1d fa 00 d9 bb 8b 42			.byte	$00,$1d,$fa,$00,$d9,$bb,$8b,$42
>2450	71 4d 64 fd 04 31 32 84			.byte	$71,$4d,$64,$fd,$04,$31,$32,$84
>2458	8b 42 71 4d 64 fd 04 31			.byte	$8b,$42,$71,$4d,$64,$fd,$04,$31
>2460	32 bc 84 8b 41 00 13 fb			.byte	$32,$bc,$84,$8b,$41,$00,$13,$fb
>2468	00 d9 bb 43 45 75 4c 87			.byte	$00,$d9,$bb,$43,$45,$75,$4c,$87
>2470	43 45 75 4c bc 84 8b 41			.byte	$43,$45,$75,$4c,$bc,$84,$8b,$41
>2478	00 10 fc 00 d9 bb 47 78			.byte	$00,$10,$fc,$00,$d9,$bb,$47,$78
>2480	5e 82 40 bc 84 47 78 5e			.byte	$5e,$82,$40,$bc,$84,$47,$78,$5e
>2488	00 11 fd 00 d9 9a 8b 41			.byte	$00,$11,$fd,$00,$d9,$9a,$8b,$41
>2490	5a 41 6a bc 84 41 5a 41			.byte	$5a,$41,$6a,$bc,$84,$41,$5a,$41
>2498	6a 00 0d fe 00 d9 b4 41			.byte	$6a,$00,$0d,$fe,$00,$d9,$b4,$41
>24a0	57 bc 84 fe 03 57 00 1b			.byte	$57,$bc,$84,$fe,$03,$57,$00,$1b
>24a8	ff 00 d9 bb 5f 67 70 fd			.byte	$ff,$00,$d9,$bb,$5f,$67,$70,$fd
>24b0	04 30 35 8b 5f 67 70 fd			.byte	$04,$30,$35,$8b,$5f,$67,$70,$fd
>24b8	04 30 35 bc 84 40 fd 03			.byte	$04,$30,$35,$bc,$84,$40,$fd,$03
>24c0	30 00 0d 00 01 d9 bb 40			.byte	$30,$00,$0d,$00,$01,$d9,$bb,$40
>24c8	84 40 bc 84 8b 41 00 17			.byte	$84,$40,$bc,$84,$8b,$41,$00,$17
>24d0	01 01 d9 bb 8b 41 5f 4b			.byte	$01,$01,$d9,$bb,$8b,$41,$5f,$4b
>24d8	52 82 8b 42 4b 62 60 bc			.byte	$52,$82,$8b,$42,$4b,$62,$60,$bc
>24e0	84 43 54 69 4e 00 0d 02			.byte	$84,$43,$54,$69,$4e,$00,$0d,$02
>24e8	01 d9 b3 42 4b 41 7b bc			.byte	$01,$d9,$b3,$42,$4b,$41,$7b,$bc
>24f0	84 41 00 0e 03 01 d9 a3			.byte	$84,$41,$00,$0e,$03,$01,$d9,$a3
>24f8	43 bc 84 fe 05 20 20 20			.byte	$43,$bc,$84,$fe,$05,$20,$20,$20
>2500	00 1a 04 01 d9 bb 8b 41			.byte	$00,$1a,$04,$01,$d9,$bb,$8b,$41
>2508	41 5f 7d fd 03 33 86 8b			.byte	$41,$5f,$7d,$fd,$03,$33,$86,$8b
>2510	41 41 5f 7d fd 03 33 bc			.byte	$41,$41,$5f,$7d,$fd,$03,$33,$bc
>2518	84 40 00 15 05 01 d9 bb			.byte	$84,$40,$00,$15,$05,$01,$d9,$bb
>2520	8b 41 48 69 42 84 8b 41			.byte	$8b,$41,$48,$69,$42,$84,$8b,$41
>2528	48 69 42 bc 84 8b 41 00			.byte	$48,$69,$42,$bc,$84,$8b,$41,$00
>2530	15 06 01 d9 bb 43 5f 71			.byte	$15,$06,$01,$d9,$bb,$43,$5f,$71
>2538	4c 81 42 63 54 7a bc 84			.byte	$4c,$81,$42,$63,$54,$7a,$bc,$84
>2540	43 7f 75 7e 00 14 07 01			.byte	$43,$7f,$75,$7e,$00,$14,$07,$01
>2548	d9 b2 8b 5e 52 6f bd 8b			.byte	$d9,$b2,$8b,$5e,$52,$6f,$bd,$8b
>2550	54 5f 72 bc 84 49 72 7d			.byte	$54,$5f,$72,$bc,$84,$49,$72,$7d
>2558	00 13 08 01 d9 a7 42 60			.byte	$00,$13,$08,$01,$d9,$a7,$42,$60
>2560	77 43 bc 84 fe 07 41 30			.byte	$77,$43,$bc,$84,$fe,$07,$41,$30
>2568	44 43 33 00 29 09 01 d9			.byte	$44,$43,$33,$00,$29,$09,$01,$d9
>2570	bb 8b 43 4f 4f 70 fd 04			.byte	$bb,$8b,$43,$4f,$4f,$70,$fd,$04
>2578	37 34 8c 8b 43 4f 4f 70			.byte	$37,$34,$8c,$8b,$43,$4f,$4f,$70
>2580	fd 04 37 34 bc 84 47 fd			.byte	$fd,$04,$37,$34,$bc,$84,$47,$fd
>2588	0d 32 30 35 39 38 35 31			.byte	$0d,$32,$30,$35,$39,$38,$35,$31
>2590	32 65 31 31 00 15 0a 01			.byte	$32,$65,$31,$31,$00,$15,$0a,$01
>2598	d9 bb 8b 41 73 5a 55 89			.byte	$d9,$bb,$8b,$41,$73,$5a,$55,$89
>25a0	8b 41 73 5a 55 bc 84 8b			.byte	$8b,$41,$73,$5a,$55,$bc,$84,$8b
>25a8	41 00 18 0b 01 d9 bb 8b			.byte	$41,$00,$18,$0b,$01,$d9,$bb,$8b
>25b0	41 79 44 75 80 8b 43 54			.byte	$41,$79,$44,$75,$80,$8b,$43,$54
>25b8	7a 62 bc 84 8b 43 7d 7e			.byte	$7a,$62,$bc,$84,$8b,$43,$7d,$7e
>25c0	76 00 10 0c 01 d9 98 8b			.byte	$76,$00,$10,$0c,$01,$d9,$98,$8b
>25c8	41 78 41 78 84 41 78 41			.byte	$41,$78,$41,$78,$84,$41,$78,$41
>25d0	77 00 12 0d 01 d9 af fe			.byte	$77,$00,$12,$0d,$01,$d9,$af,$fe
>25d8	07 31 42 41 37 36 bc 84			.byte	$07,$31,$42,$41,$37,$36,$bc,$84
>25e0	5b 69 76 00 1d 0e 01 d9			.byte	$5b,$69,$76,$00,$1d,$0e,$01,$d9
>25e8	bb 42 4c 63 73 fd 04 38			.byte	$bb,$42,$4c,$63,$73,$fd,$04,$38
>25f0	36 8b 42 4c 63 73 fd 04			.byte	$36,$8b,$42,$4c,$63,$73,$fd,$04
>25f8	38 36 bc 84 40 fd 03 30			.byte	$38,$36,$bc,$84,$40,$fd,$03,$30
>2600	00 12 0f 01 d9 bb 42 7f			.byte	$00,$12,$0f,$01,$d9,$bb,$42,$7f
>2608	78 5a 85 42 7f 78 5a bc			.byte	$78,$5a,$85,$42,$7f,$78,$5a,$bc
>2610	84 40 00 17 10 01 d9 bb			.byte	$84,$40,$00,$17,$10,$01,$d9,$bb
>2618	8b 43 4c 70 66 80 8b 50			.byte	$8b,$43,$4c,$70,$66,$80,$8b,$50
>2620	7b 7f bc 84 8b 43 5c 7c			.byte	$7b,$7f,$bc,$84,$8b,$43,$5c,$7c
>2628	40 00 12 11 01 d9 a5 a4			.byte	$40,$00,$12,$11,$01,$d9,$a5,$a4
>2630	41 64 64 47 bc bc 84 41			.byte	$41,$64,$64,$47,$bc,$bc,$84,$41
>2638	64 64 47 00 20 12 01 d9			.byte	$64,$64,$47,$00,$20,$12,$01,$d9
>2640	a0 fe 0b 61 72 66 7a 62			.byte	$a0,$fe,$0b,$61,$72,$66,$7a,$62
>2648	6a 6f 6c 74 bd 4a bc 84			.byte	$6a,$6f,$6c,$74,$bd,$4a,$bc,$84
>2650	fe 0b 61 72 66 7a 62 6a			.byte	$fe,$0b,$61,$72,$66,$7a,$62,$6a
>2658	6f 6c 74 00 1a 13 01 d9			.byte	$6f,$6c,$74,$00,$1a,$13,$01,$d9
>2660	bb 43 49 66 51 fd 04 30			.byte	$bb,$43,$49,$66,$51,$fd,$04,$30
>2668	38 88 43 49 66 51 fd 04			.byte	$38,$88,$43,$49,$66,$51,$fd,$04
>2670	30 38 bc 84 40 00 15 14			.byte	$30,$38,$bc,$84,$40,$00,$15,$14
>2678	01 d9 bb 41 60 58 61 8a			.byte	$01,$d9,$bb,$41,$60,$58,$61,$8a
>2680	41 60 58 61 bc 84 43 40			.byte	$41,$60,$58,$61,$bc,$84,$43,$40
>2688	71 42 00 16 15 01 d9 bb			.byte	$71,$42,$00,$16,$15,$01,$d9,$bb
>2690	8b 41 57 6f 5f 80 42 60			.byte	$8b,$41,$57,$6f,$5f,$80,$42,$60
>2698	4b 50 bc 84 42 60 40 40			.byte	$4b,$50,$bc,$84,$42,$60,$40,$40
>26a0	00 11 16 01 d9 9a 8b 42			.byte	$00,$11,$16,$01,$d9,$9a,$8b,$42
>26a8	68 75 42 bc 84 42 68 75			.byte	$68,$75,$42,$bc,$84,$42,$68,$75
>26b0	42 00 14 17 01 d9 a1 fe			.byte	$42,$00,$14,$17,$01,$d9,$a1,$fe
>26b8	05 67 68 69 bd 48 bc 84			.byte	$05,$67,$68,$69,$bd,$48,$bc,$84
>26c0	fe 05 67 68 69 00 1c 18			.byte	$fe,$05,$67,$68,$69,$00,$1c,$18
>26c8	01 d9 bb 8b 41 6a 75 67			.byte	$01,$d9,$bb,$8b,$41,$6a,$75,$67
>26d0	fd 04 30 32 88 8b 41 6a			.byte	$fd,$04,$30,$32,$88,$8b,$41,$6a
>26d8	75 67 fd 04 30 32 bc 84			.byte	$75,$67,$fd,$04,$30,$32,$bc,$84
>26e0	40 00 14 19 01 d9 bb 8b			.byte	$40,$00,$14,$19,$01,$d9,$bb,$8b
>26e8	41 54 64 44 8b 8b 41 54			.byte	$41,$54,$64,$44,$8b,$8b,$41,$54
>26f0	64 44 bc 84 40 00 14 1a			.byte	$64,$44,$bc,$84,$40,$00,$14,$1a
>26f8	01 d9 bb 8b 43 43 4b 69			.byte	$01,$d9,$bb,$8b,$43,$43,$4b,$69
>2700	80 71 5d 7a bc 84 70 54			.byte	$80,$71,$5d,$7a,$bc,$84,$70,$54
>2708	52 00 0f 1b 01 d9 b3 8b			.byte	$52,$00,$0f,$1b,$01,$d9,$b3,$8b
>2710	41 6f 49 51 bc 84 8b 41			.byte	$41,$6f,$49,$51,$bc,$84,$8b,$41
>2718	00 15 1c 01 d9 a2 fe 07			.byte	$00,$15,$1c,$01,$d9,$a2,$fe,$07
>2720	69 76 6b 7a 76 bd 4a bd			.byte	$69,$76,$6b,$7a,$76,$bd,$4a,$bd
>2728	45 bc 84 fe 02 00 1c 1d			.byte	$45,$bc,$84,$fe,$02,$00,$1c,$1d
>2730	01 d9 bb 8b 41 4a 41 4f			.byte	$01,$d9,$bb,$8b,$41,$4a,$41,$4f
>2738	fd 04 30 36 86 8b 41 4a			.byte	$fd,$04,$30,$36,$86,$8b,$41,$4a
>2740	41 4f fd 04 30 36 bc 84			.byte	$41,$4f,$fd,$04,$30,$36,$bc,$84
>2748	40 00 10 1e 01 d9 bb 45			.byte	$40,$00,$10,$1e,$01,$d9,$bb,$45
>2750	53 6b 88 45 53 6b bc 84			.byte	$53,$6b,$88,$45,$53,$6b,$bc,$84
>2758	40 00 16 1f 01 d9 bb 43			.byte	$40,$00,$16,$1f,$01,$d9,$bb,$43
>2760	58 56 4b 82 8b 43 61 6a			.byte	$58,$56,$4b,$82,$8b,$43,$61,$6a
>2768	4e bc 84 8b 79 7c 47 00			.byte	$4e,$bc,$84,$8b,$79,$7c,$47,$00
>2770	14 20 01 d9 b2 41 4f 77			.byte	$14,$20,$01,$d9,$b2,$41,$4f,$77
>2778	42 bd 8b 42 70 65 bc 84			.byte	$42,$bd,$8b,$42,$70,$65,$bc,$84
>2780	42 66 76 00 0d 21 01 d9			.byte	$42,$66,$76,$00,$0d,$21,$01,$d9
>2788	a6 fe 04 74 6c bc 84 42			.byte	$a6,$fe,$04,$74,$6c,$bc,$84,$42
>2790	00 1c 22 01 d9 bb 8b 43			.byte	$00,$1c,$22,$01,$d9,$bb,$8b,$43
>2798	44 43 6d fd 04 30 36 88			.byte	$44,$43,$6d,$fd,$04,$30,$36,$88
>27a0	8b 43 44 43 6d fd 04 30			.byte	$8b,$43,$44,$43,$6d,$fd,$04,$30
>27a8	36 bc 84 40 00 12 23 01			.byte	$36,$bc,$84,$40,$00,$12,$23,$01
>27b0	d9 bb 41 5b 47 61 8b 41			.byte	$d9,$bb,$41,$5b,$47,$61,$8b,$41
>27b8	5b 47 61 bc 84 40 00 15			.byte	$5b,$47,$61,$bc,$84,$40,$00,$15
>27c0	24 01 d9 bb 43 50 7a 6e			.byte	$24,$01,$d9,$bb,$43,$50,$7a,$6e
>27c8	81 42 5f 45 65 bc 84 43			.byte	$81,$42,$5f,$45,$65,$bc,$84,$43
>27d0	5f 7f 6f 00 0e 25 01 d9			.byte	$5f,$7f,$6f,$00,$0e,$25,$01,$d9
>27d8	98 8b 53 72 7e 84 53 72			.byte	$98,$8b,$53,$72,$7e,$84,$53,$72
>27e0	7d 00 0d 26 01 d9 9b fe			.byte	$7d,$00,$0d,$26,$01,$d9,$9b,$fe
>27e8	03 70 bc 84 41 70 00 1d			.byte	$03,$70,$bc,$84,$41,$70,$00,$1d
>27f0	27 01 d9 bb 41 57 5e fd			.byte	$27,$01,$d9,$bb,$41,$57,$5e,$fd
>27f8	05 36 30 39 8b 41 57 5e			.byte	$05,$36,$30,$39,$8b,$41,$57,$5e
>2800	fd 05 36 30 39 bc 84 40			.byte	$fd,$05,$36,$30,$39,$bc,$84,$40
>2808	fd 03 30 00 13 28 01 d9			.byte	$fd,$03,$30,$00,$13,$28,$01,$d9
>2810	bb 8b 7f 5e 79 84 8b 7f			.byte	$bb,$8b,$7f,$5e,$79,$84,$8b,$7f
>2818	5e 79 bc 84 8b 41 00 17			.byte	$5e,$79,$bc,$84,$8b,$41,$00,$17
>2820	29 01 d9 bb 8b 43 58 6e			.byte	$29,$01,$d9,$bb,$8b,$43,$58,$6e
>2828	6f 82 42 62 78 72 bc 84			.byte	$6f,$82,$42,$62,$78,$72,$bc,$84
>2830	8b 41 7a 56 5d 00 1a 2a			.byte	$8b,$41,$7a,$56,$5d,$00,$1a,$2a
>2838	01 d9 a5 a4 41 59 4e 61			.byte	$01,$d9,$a5,$a4,$41,$59,$4e,$61
>2840	fd 04 35 31 bc bc 84 41			.byte	$fd,$04,$35,$31,$bc,$bc,$84,$41
>2848	59 4e 61 fd 04 35 31 00			.byte	$59,$4e,$61,$fd,$04,$35,$31,$00
>2850	0c 2b 01 d9 b4 7c bc 84			.byte	$0c,$2b,$01,$d9,$b4,$7c,$bc,$84
>2858	fe 03 3c 00 1d 2c 01 d9			.byte	$fe,$03,$3c,$00,$1d,$2c,$01,$d9
>2860	bb 8b 41 6c 7e 66 fd 04			.byte	$bb,$8b,$41,$6c,$7e,$66,$fd,$04
>2868	31 33 87 8b 41 6c 7e 66			.byte	$31,$33,$87,$8b,$41,$6c,$7e,$66
>2870	fd 04 31 33 bc 84 8b 41			.byte	$fd,$04,$31,$33,$bc,$84,$8b,$41
>2878	00 12 2d 01 d9 bb 8b 6d			.byte	$00,$12,$2d,$01,$d9,$bb,$8b,$6d
>2880	52 5f 8b 8b 6d 52 5f bc			.byte	$52,$5f,$8b,$8b,$6d,$52,$5f,$bc
>2888	84 40 00 0f 2e 01 d9 bb			.byte	$84,$40,$00,$0f,$2e,$01,$d9,$bb
>2890	42 7f 4b 6e 80 40 bc 84			.byte	$42,$7f,$4b,$6e,$80,$40,$bc,$84
>2898	40 00 0e 2f 01 d9 9a 5a			.byte	$40,$00,$0e,$2f,$01,$d9,$9a,$5a
>28a0	68 42 bc 84 5a 68 42 00			.byte	$68,$42,$bc,$84,$5a,$68,$42,$00
>28a8	1a 30 01 d9 a3 4f bc 84			.byte	$1a,$30,$01,$d9,$a3,$4f,$bc,$84
>28b0	fe 11 20 20 20 20 20 20			.byte	$fe,$11,$20,$20,$20,$20,$20,$20
>28b8	20 20 20 20 20 20 20 20			.byte	$20,$20,$20,$20,$20,$20,$20,$20
>28c0	20 00 1a 31 01 d9 bb 8b			.byte	$20,$00,$1a,$31,$01,$d9,$bb,$8b
>28c8	7f 7e 5d fd 04 39 33 85			.byte	$7f,$7e,$5d,$fd,$04,$39,$33,$85
>28d0	8b 7f 7e 5d fd 04 39 33			.byte	$8b,$7f,$7e,$5d,$fd,$04,$39,$33
>28d8	bc 84 40 00 18 32 01 d9			.byte	$bc,$84,$40,$00,$18,$32,$01,$d9
>28e0	bb 8b 42 59 40 7a 8a 8b			.byte	$bb,$8b,$42,$59,$40,$7a,$8a,$8b
>28e8	42 59 40 7a bc 84 8b 44			.byte	$42,$59,$40,$7a,$bc,$84,$8b,$44
>28f0	72 41 74 00 17 33 01 d9			.byte	$72,$41,$74,$00,$17,$33,$01,$d9
>28f8	bb 41 78 4b 54 81 8b 42			.byte	$bb,$41,$78,$4b,$54,$81,$8b,$42
>2900	71 6e 71 bc 84 8b 42 41			.byte	$71,$6e,$71,$bc,$84,$8b,$42,$41
>2908	64 61 00 0f 34 01 d9 b3			.byte	$64,$61,$00,$0f,$34,$01,$d9,$b3
>2910	8b 43 68 62 4b bc 84 8b			.byte	$8b,$43,$68,$62,$4b,$bc,$84,$8b
>2918	41 00 13 35 01 d9 a7 42			.byte	$41,$00,$13,$35,$01,$d9,$a7,$42
>2920	40 40 7e bc 84 fe 07 38			.byte	$40,$40,$7e,$bc,$84,$fe,$07,$38
>2928	30 30 33 45 00 23 36 01			.byte	$30,$30,$33,$45,$00,$23,$36,$01
>2930	d9 bb 8b 42 58 4e 5d fd			.byte	$d9,$bb,$8b,$42,$58,$4e,$5d,$fd
>2938	04 37 35 8a 8b 42 58 4e			.byte	$04,$37,$35,$8a,$8b,$42,$58,$4e
>2940	5d fd 04 37 35 bc 84 8b			.byte	$5d,$fd,$04,$37,$35,$bc,$84,$8b
>2948	44 70 5c 7b fd 03 35 00			.byte	$44,$70,$5c,$7b,$fd,$03,$35,$00
>2950	10 37 01 d9 bb 55 77 4c			.byte	$10,$37,$01,$d9,$bb,$55,$77,$4c
>2958	8d 55 77 4c bc 84 41 00			.byte	$8d,$55,$77,$4c,$bc,$84,$41,$00
>2960	12 38 01 d9 bb 43 56 60			.byte	$12,$38,$01,$d9,$bb,$43,$56,$60
>2968	49 81 40 bc 84 43 56 60			.byte	$49,$81,$40,$bc,$84,$43,$56,$60
>2970	49 00 14 39 01 d9 b2 8b			.byte	$49,$00,$14,$39,$01,$d9,$b2,$8b
>2978	59 73 5b bd 43 6e 71 62			.byte	$59,$73,$5b,$bd,$43,$6e,$71,$62
>2980	bc 84 59 73 5b 00 0c 3a			.byte	$bc,$84,$59,$73,$5b,$00,$0c,$3a
>2988	01 d9 af fe 03 30 bc 84			.byte	$01,$d9,$af,$fe,$03,$30,$bc,$84
>2990	40 00 1b 3b 01 d9 bb 5d			.byte	$40,$00,$1b,$3b,$01,$d9,$bb,$5d
>2998	51 55 fd 04 32 34 8d 5d			.byte	$51,$55,$fd,$04,$32,$34,$8d,$5d
>29a0	51 55 fd 04 32 34 bc 84			.byte	$51,$55,$fd,$04,$32,$34,$bc,$84
>29a8	41 fd 03 30 00 0d 3c 01			.byte	$41,$fd,$03,$30,$00,$0d,$3c,$01
>29b0	d9 bb 40 89 40 bc 84 8b			.byte	$d9,$bb,$40,$89,$40,$bc,$84,$8b
>29b8	41 00 16 3d 01 d9 bb 44			.byte	$41,$00,$16,$3d,$01,$d9,$bb,$44
>29c0	66 43 81 8b 43 56 41 79			.byte	$66,$43,$81,$8b,$43,$56,$41,$79
>29c8	bc 84 8b 43 52 41 79 00			.byte	$bc,$84,$8b,$43,$52,$41,$79,$00
>29d0	10 3e 01 d9 98 8b 42 52			.byte	$10,$3e,$01,$d9,$98,$8b,$42,$52
>29d8	69 6a 84 42 52 69 69 00			.byte	$69,$6a,$84,$42,$52,$69,$69,$00
>29e0	12 3f 01 d9 a0 fe 04 69			.byte	$12,$3f,$01,$d9,$a0,$fe,$04,$69
>29e8	61 bd 43 bc 84 fe 04 69			.byte	$61,$bd,$43,$bc,$84,$fe,$04,$69
>29f0	61 00 1c 40 01 d9 bb 8b			.byte	$61,$00,$1c,$40,$01,$d9,$bb,$8b
>29f8	43 4e 43 7c fd 04 31 34			.byte	$43,$4e,$43,$7c,$fd,$04,$31,$34
>2a00	85 8b 43 4e 43 7c fd 04			.byte	$85,$8b,$43,$4e,$43,$7c,$fd,$04
>2a08	31 34 bc 84 40 00 12 41			.byte	$31,$34,$bc,$84,$40,$00,$12,$41
>2a10	01 d9 bb 8b 63 7e 6e 8d			.byte	$01,$d9,$bb,$8b,$63,$7e,$6e,$8d
>2a18	8b 63 7e 6e bc 84 41 00			.byte	$8b,$63,$7e,$6e,$bc,$84,$41,$00
>2a20	15 42 01 d9 bb 43 4e 68			.byte	$15,$42,$01,$d9,$bb,$43,$4e,$68
>2a28	7b 82 42 5e 61 41 bc 84			.byte	$7b,$82,$42,$5e,$61,$41,$bc,$84
>2a30	41 50 49 7a 00 14 43 01			.byte	$41,$50,$49,$7a,$00,$14,$43,$01
>2a38	d9 a5 a4 8b 43 47 74 42			.byte	$d9,$a5,$a4,$8b,$43,$47,$74,$42
>2a40	bc bc 84 8b 43 47 74 42			.byte	$bc,$bc,$84,$8b,$43,$47,$74,$42
>2a48	00 12 44 01 d9 a1 fe 04			.byte	$00,$12,$44,$01,$d9,$a1,$fe,$04
>2a50	7a 6c bd 45 bc 84 fe 04			.byte	$7a,$6c,$bd,$45,$bc,$84,$fe,$04
>2a58	7a 6c 00 1a 45 01 d9 bb			.byte	$7a,$6c,$00,$1a,$45,$01,$d9,$bb
>2a60	41 4d 73 54 fd 04 39 37			.byte	$41,$4d,$73,$54,$fd,$04,$39,$37
>2a68	88 41 4d 73 54 fd 04 39			.byte	$88,$41,$4d,$73,$54,$fd,$04,$39
>2a70	37 bc 84 40 00 12 46 01			.byte	$37,$bc,$84,$40,$00,$12,$46,$01
>2a78	d9 bb 43 65 40 72 8d 43			.byte	$d9,$bb,$43,$65,$40,$72,$8d,$43
>2a80	65 40 72 bc 84 41 00 17			.byte	$65,$40,$72,$bc,$84,$41,$00,$17
>2a88	47 01 d9 bb 41 7e 76 7f			.byte	$47,$01,$d9,$bb,$41,$7e,$76,$7f
>2a90	82 8b 42 55 5b 6e bc 84			.byte	$82,$8b,$42,$55,$5b,$6e,$bc,$84
>2a98	8b 43 6b 6d 53 00 0a 48			.byte	$8b,$43,$6b,$6d,$53,$00,$0a,$48
>2aa0	01 d9 9a 40 bc 84 40 00			.byte	$01,$d9,$9a,$40,$bc,$84,$40,$00
>2aa8	1b 49 01 d9 a2 fe 0c 71			.byte	$1b,$49,$01,$d9,$a2,$fe,$0c,$71
>2ab0	61 6b 69 6d 6e 78 6d 78			.byte	$61,$6b,$69,$6d,$6e,$78,$6d,$78
>2ab8	7a bd 4a bd 44 bc 84 fe			.byte	$7a,$bd,$4a,$bd,$44,$bc,$84,$fe
>2ac0	03 7a 00 1d 4a 01 d9 bb			.byte	$03,$7a,$00,$1d,$4a,$01,$d9,$bb
>2ac8	8b 43 49 67 45 fd 04 30			.byte	$8b,$43,$49,$67,$45,$fd,$04,$30
>2ad0	39 84 8b 43 49 67 45 fd			.byte	$39,$84,$8b,$43,$49,$67,$45,$fd
>2ad8	04 30 39 bc 84 8b 41 00			.byte	$04,$30,$39,$bc,$84,$8b,$41,$00
>2ae0	10 4b 01 d9 bb 4b 45 7f			.byte	$10,$4b,$01,$d9,$bb,$4b,$45,$7f
>2ae8	8b 4b 45 7f bc 84 40 00			.byte	$8b,$4b,$45,$7f,$bc,$84,$40,$00
>2af0	13 4c 01 d9 bb 8b 6a 6f			.byte	$13,$4c,$01,$d9,$bb,$8b,$6a,$6f
>2af8	51 80 63 4d 50 bc 84 41			.byte	$51,$80,$63,$4d,$50,$bc,$84,$41
>2b00	40 40 00 0f 4d 01 d9 b3			.byte	$40,$40,$00,$0f,$4d,$01,$d9,$b3
>2b08	8b 43 40 50 70 bc 84 8b			.byte	$8b,$43,$40,$50,$70,$bc,$84,$8b
>2b10	41 00 0d 4e 01 d9 a6 fe			.byte	$41,$00,$0d,$4e,$01,$d9,$a6,$fe
>2b18	04 62 71 bc 84 42 00 1d			.byte	$04,$62,$71,$bc,$84,$42,$00,$1d
>2b20	4f 01 d9 bb 8b 42 47 7e			.byte	$4f,$01,$d9,$bb,$8b,$42,$47,$7e
>2b28	4d fd 04 38 32 89 8b 42			.byte	$4d,$fd,$04,$38,$32,$89,$8b,$42
>2b30	47 7e 4d fd 04 38 32 bc			.byte	$47,$7e,$4d,$fd,$04,$38,$32,$bc
>2b38	84 8b 41 00 13 50 01 d9			.byte	$84,$8b,$41,$00,$13,$50,$01,$d9
>2b40	bb 41 58 6d 4f 87 41 58			.byte	$bb,$41,$58,$6d,$4f,$87,$41,$58
>2b48	6d 4f bc 84 8b 41 00 14			.byte	$6d,$4f,$bc,$84,$8b,$41,$00,$14
>2b50	51 01 d9 bb 8b 41 77 72			.byte	$51,$01,$d9,$bb,$8b,$41,$77,$72
>2b58	59 80 59 43 74 bc 84 48			.byte	$59,$80,$59,$43,$74,$bc,$84,$48
>2b60	41 64 00 15 52 01 d9 b2			.byte	$41,$64,$00,$15,$52,$01,$d9,$b2
>2b68	8b 43 73 62 6f bd 41 5d			.byte	$8b,$43,$73,$62,$6f,$bd,$41,$5d
>2b70	51 40 bc 84 79 40 6f 00			.byte	$51,$40,$bc,$84,$79,$40,$6f,$00
>2b78	0e 53 01 d9 9b fe 04 62			.byte	$0e,$53,$01,$d9,$9b,$fe,$04,$62
>2b80	64 bc 84 41 62 00 16 54			.byte	$64,$bc,$84,$41,$62,$00,$16,$54
>2b88	01 d9 bb 66 6c 7b fd 03			.byte	$01,$d9,$bb,$66,$6c,$7b,$fd,$03
>2b90	34 86 66 6c 7b fd 03 34			.byte	$34,$86,$66,$6c,$7b,$fd,$03,$34
>2b98	bc 84 40 00 13 55 01 d9			.byte	$bc,$84,$40,$00,$13,$55,$01,$d9
>2ba0	bb 41 7c 79 51 89 41 7c			.byte	$bb,$41,$7c,$79,$51,$89,$41,$7c
>2ba8	79 51 bc 84 8b 41 00 14			.byte	$79,$51,$bc,$84,$8b,$41,$00,$14
>2bb0	56 01 d9 bb 8b 41 5f 5a			.byte	$56,$01,$d9,$bb,$8b,$41,$5f,$5a
>2bb8	45 81 40 bc 84 8b 41 5f			.byte	$45,$81,$40,$bc,$84,$8b,$41,$5f
>2bc0	5a 45 00 0e 57 01 d9 98			.byte	$5a,$45,$00,$0e,$57,$01,$d9,$98
>2bc8	63 76 42 84 8b 63 76 43			.byte	$63,$76,$42,$84,$8b,$63,$76,$43
>2bd0	00 0d 58 01 d9 b4 41 53			.byte	$00,$0d,$58,$01,$d9,$b4,$41,$53
>2bd8	bc 84 fe 03 53 00 1a 59			.byte	$bc,$84,$fe,$03,$53,$00,$1a,$59
>2be0	01 d9 bb 42 7b 76 68 fd			.byte	$01,$d9,$bb,$42,$7b,$76,$68,$fd
>2be8	04 31 35 88 42 7b 76 68			.byte	$04,$31,$35,$88,$42,$7b,$76,$68
>2bf0	fd 04 31 35 bc 84 40 00			.byte	$fd,$04,$31,$35,$bc,$84,$40,$00
>2bf8	14 5a 01 d9 bb 8b 41 5f			.byte	$14,$5a,$01,$d9,$bb,$8b,$41,$5f
>2c00	5d 43 86 8b 41 5f 5d 43			.byte	$5d,$43,$86,$8b,$41,$5f,$5d,$43
>2c08	bc 84 40 00 18 5b 01 d9			.byte	$bc,$84,$40,$00,$18,$5b,$01,$d9
>2c10	bb 8b 41 5d 46 58 80 8b			.byte	$bb,$8b,$41,$5d,$46,$58,$80,$8b
>2c18	42 60 55 75 bc 84 8b 43			.byte	$42,$60,$55,$75,$bc,$84,$8b,$43
>2c20	7d 57 78 00 1c 5c 01 d9			.byte	$7d,$57,$78,$00,$1c,$5c,$01,$d9
>2c28	a5 a4 8b 41 40 65 4f fd			.byte	$a5,$a4,$8b,$41,$40,$65,$4f,$fd
>2c30	04 37 31 bc bc 84 8b 41			.byte	$04,$37,$31,$bc,$bc,$84,$8b,$41
>2c38	40 65 4f fd 04 37 31 00			.byte	$40,$65,$4f,$fd,$04,$37,$31,$00
>2c40	1c 5d 01 d9 a3 51 bc 84			.byte	$1c,$5d,$01,$d9,$a3,$51,$bc,$84
>2c48	fe 13 20 20 20 20 20 20			.byte	$fe,$13,$20,$20,$20,$20,$20,$20
>2c50	20 20 20 20 20 20 20 20			.byte	$20,$20,$20,$20,$20,$20,$20,$20
>2c58	20 20 20 00 10 5e 01 d4			.byte	$20,$20,$20,$00,$10,$5e,$01,$d4
>2c60	fe 09 50 61 73 73 65 64			.byte	$fe,$09,$50,$61,$73,$73,$65,$64
>2c68	2e be c2 00 00				.byte	$2e,$be,$c2,$00,$00

;******  Return to file: modules/hardware/em65816.asm

.c000					StartROM:
.c000	18		clc				clc
.c001	fb		xce				xce
.c002	c2 30		rep #$30			rep 	#$30
.c004	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.c007	1b		tcs				tcs
.c008	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.c00b	e2 30		sep #$30			sep 	#$30
.c00d	c2 30		rep #$30			rep 	#$30						; clear AXY in 16 bit.
.c00f	a9 00		lda #$00			lda 	#$0000
.c011	aa		tax				tax
.c012	a8		tay				tay
.c013	e2 30		sep #$30			sep 	#$30
.c015	5c 95 84 01	jmp $018495		jmp BASIC_Start
.c019					TIM_BreakHandler:
.c019	5c 02 99 01	jmp $019902			jmp 	TIM_BreakVector

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.018000					IFT_ClearScreen:
.018000	48		pha				pha
.018001	da		phx				phx
.018002	5a		phy				phy
.018003	20 a9 81	jsr $0181a9			jsr 	IF_Home 					; home cursor
.018006	a2 20		ldx #$20			ldx 	#IF_Height 					; this many lines.
.018008					_IFT_CS0:
.018008	a0 40		ldy #$40			ldy 	#IF_Width 					; this many chars/line
.01800a					_IFT_CS1:
.01800a	a9 20		lda #$20			lda 	#' '						; clear line.
.01800c	20 d5 81	jsr $0181d5			jsr 	IF_Write
.01800f	88		dey				dey
.018010	d0 f8		bne $01800a			bne 	_IFT_CS1
.018012	20 bc 81	jsr $0181bc			jsr 	IF_NewLine 					; next line down
.018015	ca		dex				dex
.018016	d0 f0		bne $018008			bne 	_IFT_CS0
.018018	7a		ply				ply
.018019	fa		plx				plx
.01801a	68		pla				pla
.01801b					IFT_HomeCursor:
.01801b	48		pha				pha
.01801c	20 a9 81	jsr $0181a9			jsr 	IF_Home
.01801f	a9 00		lda #$00			lda 	#0
.018021	8d 00 02	sta $0200			sta 	IFT_XCursor
.018024	8d 01 02	sta $0201			sta 	IFT_YCursor
.018027	68		pla				pla
.018028	60		rts				rts
.018029					IFT_UpLine:
.018029	48		pha				pha
.01802a	ad 01 02	lda $0201			lda  	IFT_YCursor 				; get Y
.01802d	3a		dec a				dec 	a 							; line above
.01802e	30 03		bmi $018033			bmi 	_IFTULExit 					; too far, abort
.018030	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos					; set to that line.
.018033					_IFTULExit:
.018033	68		pla				pla
.018034	60		rts				rts
.018035					IFT_PrintCharacter:
.018035	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.018037	f0 23		beq $01805c			beq 	IFT_NewLine
.018039	48		pha				pha
.01803a	20 74 80	jsr $018074			jsr 	IFT_UpperCase 				; make upper case
.01803d	20 d5 81	jsr $0181d5			jsr 	IF_Write 					; write out.
.018040	ee 00 02	inc $0200			inc 	IFT_XCursor 				; bump x cursor
.018043	ad 00 02	lda $0200			lda 	IFT_XCursor 				; reached RHS ?
.018046	c9 40		cmp #$40			cmp 	#IF_Width
.018048	d0 03		bne $01804d			bne 	_IFT_PCNotEOL
.01804a	20 5c 80	jsr $01805c			jsr 	IFT_NewLine 				; if so do new line.
.01804d					_IFT_PCNotEOL:
.01804d	68		pla				pla
.01804e	60		rts				rts
.01804f					IFT_Tab:
.01804f	a9 20		lda #$20			lda 	#" " 						; space
.018051	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018054	ad 00 02	lda $0200			lda 	IFT_XCursor 				; until x % 8 == 0
.018057	29 07		and #$07			and 	#7
.018059	d0 f4		bne $01804f			bne 	IFT_Tab
.01805b	60		rts				rts
.01805c					IFT_NewLine:
.01805c	48		pha				pha
.01805d	20 bc 81	jsr $0181bc			jsr 	IF_NewLine 					; new line on actual screen.
.018060	a9 00		lda #$00			lda 	#0 							; reset x position
.018062	8d 00 02	sta $0200			sta 	IFT_XCursor
.018065	ee 01 02	inc $0201			inc 	IFT_YCursor 				; move down.
.018068	ad 01 02	lda $0201			lda 	IFT_YCursor
.01806b	c9 20		cmp #$20			cmp 	#IF_Height 					; reached bottom.
.01806d	d0 03		bne $018072			bne 	_IFT_NL_NotEOS
.01806f	20 7f 80	jsr $01807f			jsr 	IFT_Scroll 					; scroll screen up.
.018072					_IFT_NL_NotEOS:
.018072	68		pla				pla
.018073	60		rts				rts
.018074					IFT_UpperCase:
.018074	c9 61		cmp #$61			cmp 	#"a"
.018076	90 06		bcc $01807e			bcc 	_IFT_UCExit
.018078	c9 7b		cmp #$7b			cmp 	#"z"+1
.01807a	b0 02		bcs $01807e			bcs 	_IFT_UCExit
.01807c	49 20		eor #$20			eor 	#$20
.01807e					_IFT_UCExit:
.01807e	60		rts				rts
.01807f					IFT_Scroll:
.01807f	48		pha				pha 								; save AXY
.018080	da		phx				phx
.018081	5a		phy				phy
.018082	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.018084					_IFT_SLoop:
.018084	20 a4 80	jsr $0180a4			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.018087	e8		inx				inx
.018088	e0 1f		cpx #$1f			cpx 	#IF_Height-1				; do whole screen
.01808a	d0 f8		bne $018084			bne 	_IFT_SLoop
.01808c	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.01808e	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.018091	a2 40		ldx #$40			ldx 	#IF_Width 					; blank line
.018093					_IFT_SBlank:
.018093	a9 20		lda #$20			lda 	#32
.018095	20 d5 81	jsr $0181d5			jsr 	IF_Write
.018098	ca		dex				dex
.018099	d0 f8		bne $018093			bne 	_IFT_SBlank
.01809b	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.01809d	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.0180a0	7a		ply				ply
.0180a1	fa		plx				plx
.0180a2	68		pla				pla
.0180a3	60		rts				rts
.0180a4					_IFT_ScrollLine:
.0180a4	da		phx				phx
.0180a5	da		phx				phx
.0180a6	8a		txa				txa 								; copy line into buffer.
.0180a7	1a		inc a				inc 	a 							; next line down.
.0180a8	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.0180ab	a2 00		ldx #$00			ldx 	#0
.0180ad					_IFTScrollCopy1:
.0180ad	20 cc 81	jsr $0181cc			jsr 	IF_Read
.0180b0	9d 02 02	sta $0202,x			sta 	IFT_Buffer,x
.0180b3	e8		inx				inx
.0180b4	e0 40		cpx #$40			cpx 	#IF_Width
.0180b6	d0 f5		bne $0180ad			bne 	_IFTScrollCopy1
.0180b8	68		pla				pla
.0180b9	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.0180bc	a2 00		ldx #$00			ldx 	#0
.0180be					_IFTScrollCopy2:
.0180be	bd 02 02	lda $0202,x			lda 	IFT_Buffer,x
.0180c1	20 d5 81	jsr $0181d5			jsr 	IF_Write
.0180c4	e8		inx				inx
.0180c5	e0 40		cpx #$40			cpx 	#IF_Width
.0180c7	d0 f5		bne $0180be			bne 	_IFTScrollCopy2
.0180c9	fa		plx				plx
.0180ca	60		rts				rts
.0180cb					IFT_SetYPos:
.0180cb	48		pha				pha
.0180cc	da		phx				phx
.0180cd	aa		tax				tax
.0180ce	20 1b 80	jsr $01801b			jsr 	IFT_HomeCursor
.0180d1	e0 00		cpx #$00			cpx 	#0
.0180d3	f0 09		beq $0180de			beq 	_IFT_MOAExit
.0180d5					_IFT_MOALoop:
.0180d5	20 bc 81	jsr $0181bc			jsr 	IF_NewLine
.0180d8	ee 01 02	inc $0201			inc 	IFT_YCursor
.0180db	ca		dex				dex
.0180dc	d0 f7		bne $0180d5			bne		_IFT_MOALoop
.0180de					_IFT_MOAExit:
.0180de	fa		plx				plx
.0180df	68		pla				pla
.0180e0	60		rts				rts
.0180e1					IFT_GetKeyCursor:
.0180e1	20 e9 80	jsr $0180e9			jsr 	_IFT_FlipCursor 			; reverse current
.0180e4					_IFT_GKCWait:
.0180e4	20 e6 81	jsr $0181e6			jsr 	IF_GetKey 					; get key
.0180e7	f0 fb		beq $0180e4			beq 	_IFT_GKCWait
.0180e9					_IFT_FlipCursor:
.0180e9	48		pha				pha 								; save
.0180ea	20 cc 81	jsr $0181cc			jsr 	IF_Read 					; read
.0180ed	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.0180f0	49 80		eor #$80			eor 	#$80 						; reverse
.0180f2	20 d5 81	jsr $0181d5			jsr 	IF_Write 					; write
.0180f5	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.0180f8	68		pla				pla
.0180f9	60		rts				rts
.0180fa					IFT_ReadLine:
.0180fa	48		pha				pha
.0180fb					_IFT_RLLoop:
.0180fb	20 e1 80	jsr $0180e1			jsr 	IFT_GetKeyCursor 			; get keystroke
.0180fe	c9 0d		cmp #$0d			cmp 	#13							; return
.018100	f0 7d		beq $01817f			beq 	_IFT_RLExit
.018102	c9 20		cmp #$20			cmp 	#32 						; control character
.018104	90 05		bcc $01810b			bcc 	_IFT_Control
.018106	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018109	80 f0		bra $0180fb			bra 	_IFT_RLLoop
.01810b					_IFT_Control:
.01810b	c9 01		cmp #$01			cmp 	#"A"-64
.01810d	f0 26		beq $018135			beq 	_IFT_Left
.01810f	c9 04		cmp #$04			cmp 	#"D"-64
.018111	f0 2e		beq $018141			beq 	_IFT_Right
.018113	c9 17		cmp #$17			cmp 	#"W"-64
.018115	f0 36		beq $01814d			beq 	_IFT_Up
.018117	c9 13		cmp #$13			cmp 	#"S"-64
.018119	f0 3e		beq $018159			beq 	_IFT_Down
.01811b	c9 08		cmp #$08			cmp 	#"H"-64
.01811d	f0 09		beq $018128			beq 	_IFT_Backspace
.01811f	c9 1a		cmp #$1a			cmp 	#"Z"-64
.018121	d0 d8		bne $0180fb			bne 	_IFT_RLLoop
.018123	20 00 80	jsr $018000			jsr 	IFT_ClearScreen				; clear CTL-Z
.018126	80 d3		bra $0180fb			bra 	_IFT_RLLoop
.018128					_IFT_Backspace:
.018128	ad 00 02	lda $0200			lda 	IFT_XCursor 				; check not start of line.
.01812b	f0 ce		beq $0180fb			beq 	_IFT_RLLoop
.01812d	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.018130	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.018132	20 d5 81	jsr $0181d5			jsr 	IF_Write
.018135					_IFT_Left:
.018135	ce 00 02	dec $0200			dec 	IFT_XCursor 				; left CTL-W
.018138	10 29		bpl $018163			bpl 	_IFT_Reposition
.01813a	a9 3f		lda #$3f			lda 	#IF_Width-1
.01813c					_IFT_SetX:
.01813c	8d 00 02	sta $0200			sta 	IFT_XCursor
.01813f	80 22		bra $018163			bra 	_IFT_Reposition
.018141					_IFT_Right:
.018141	ee 00 02	inc $0200			inc 	IFT_XCursor
.018144	ad 00 02	lda $0200			lda 	IFT_XCursor
.018147	49 40		eor #$40			eor 	#IF_Width
.018149	f0 f1		beq $01813c			beq 	_IFT_SetX
.01814b	80 16		bra $018163			bra 	_IFT_Reposition
.01814d					_IFT_Up:
.01814d	ce 01 02	dec $0201			dec 	IFT_YCursor
.018150	10 11		bpl $018163			bpl 	_IFT_Reposition
.018152	a9 1f		lda #$1f			lda 	#IF_Height-1
.018154					_IFT_SetY:
.018154	8d 01 02	sta $0201			sta 	IFT_YCursor
.018157	80 0a		bra $018163			bra 	_IFT_Reposition
.018159					_IFT_Down:
.018159	ee 01 02	inc $0201			inc 	IFT_YCursor
.01815c	ad 01 02	lda $0201			lda 	IFT_YCursor
.01815f	49 20		eor #$20			eor 	#IF_Height
.018161	f0 f1		beq $018154			beq 	_IFT_SetY
.018163					_IFT_Reposition:
.018163	ad 00 02	lda $0200			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.018166	48		pha				pha
.018167	ad 01 02	lda $0201			lda 	IFT_YCursor
.01816a	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.01816d	68		pla				pla
.01816e	aa		tax				tax
.01816f	e0 00		cpx #$00			cpx 	#0
.018171	f0 88		beq $0180fb			beq 	_IFT_RLLoop
.018173					_IFT_MoveRight:
.018173	20 cc 81	jsr $0181cc			jsr 	IF_Read
.018176	ee 00 02	inc $0200			inc 	IFT_XCursor
.018179	ca		dex				dex
.01817a	d0 f7		bne $018173			bne 	_IFT_MoveRight
.01817c	4c fb 80	jmp $0180fb			jmp 	_IFT_RLLoop
.01817f					_IFT_RLExit:
.01817f	ad 01 02	lda $0201			lda 	IFT_YCursor 				; go to start of line.
.018182	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.018185	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.018187					_IFT_RLRead:
.018187	20 cc 81	jsr $0181cc			jsr 	IF_Read
.01818a	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.01818d	e8		inx				inx
.01818e	e0 40		cpx #$40			cpx 	#IF_Width
.018190	d0 f5		bne $018187			bne 	_IFT_RLRead
.018192					_IFT_RL_Trim:
.018192	ca		dex				dex 	 							; previous char
.018193	30 07		bmi $01819c			bmi 	_IFT_Found 					; gone too far
.018195	bd 66 02	lda $0266,x			lda 	IFT_LineBuffer,x			; go back if space
.018198	c9 20		cmp #$20			cmp 	#" "
.01819a	f0 f6		beq $018192			beq 	_IFT_RL_Trim
.01819c					_IFT_Found:
.01819c	e8		inx				inx 								; forward to non-space
.01819d	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.01819f	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.0181a2	68		pla				pla
.0181a3	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.0181a5	a0 02		ldy #$02			ldy 	#IFT_LineBuffer >> 8
.0181a7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_em65816.asm

=64					IF_Width 	= 64 							; characters across
=32					IF_Height 	= 32 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line.
=8					IF_XPos 	= 8 							; current position, horizontal.
=$f0000					IF_Screen = $F0000							; 2k screen RAM here
=$f8010					IF_PKeyboard = $F8010						; Keyboard port.
=$f8000					IF_PBreak = $F8000 							; Break key.
.0181a8					IF_Reset:
.0181a8	60		rts				rts
.0181a9					IF_Home:
.0181a9	48		pha				pha
.0181aa	64 08		stz $08				stz 	IF_XPos 					; zero X position
.0181ac	a9 00		lda #$00			lda 	#IF_Screen & $FF 			; set r/w pos.
.0181ae	85 04		sta $04				sta 	IF_Pos
.0181b0	a9 00		lda #$00			lda 	#(IF_Screen >> 8) & $FF
.0181b2	85 05		sta $05				sta 	IF_Pos+1
.0181b4	a9 0f		lda #$0f			lda 	#IF_Screen >> 16
.0181b6	85 06		sta $06				sta 	IF_Pos+2
.0181b8	64 07		stz $07				stz 	IF_Pos+3
.0181ba	68		pla				pla
.0181bb	60		rts				rts
.0181bc					IF_NewLine:
.0181bc	48		pha				pha
.0181bd	64 08		stz $08				stz 	IF_XPos						; back to start of line
.0181bf	18		clc				clc 								; down one line
.0181c0	a5 04		lda $04				lda 	IF_Pos
.0181c2	69 40		adc #$40			adc 	#64
.0181c4	85 04		sta $04				sta 	IF_Pos
.0181c6	90 02		bcc $0181ca			bcc 	_IF_NoCarry 				; carry through.
.0181c8	e6 05		inc $05				inc 	IF_Pos+1
.0181ca					_IF_NoCarry:
.0181ca	68		pla				pla
.0181cb	60		rts				rts
.0181cc					IF_Read:
.0181cc	5a		phy				phy 								; save current Y
.0181cd	a4 08		ldy $08				ldy 	IF_XPos 					; read character at current position
.0181cf	b7 04		lda [$04],y			lda 	[IF_Pos],y
.0181d1	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181d3	7a		ply				ply									; restore Y
.0181d4	60		rts				rts
.0181d5					IF_Write:
.0181d5	5a		phy				phy 								; save current Y
.0181d6	a4 08		ldy $08				ldy 	IF_XPos 					; write character at current position
.0181d8	97 04		sta [$04],y			sta 	[IF_Pos],y
.0181da	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181dc	7a		ply				ply									; restore Y
.0181dd	60		rts				rts
.0181de					IF_LeftOne:
.0181de	c6 08		dec $08				dec 	IF_XPos
.0181e0	60		rts				rts
.0181e1					IF_CheckBreak:
.0181e1	af 00 80 0f	lda $0f8000			lda 	IF_PBreak					; non-zero if Ctrl+C pressed.
.0181e5	60		rts				rts
.0181e6					IF_GetKey:
.0181e6	af 10 80 0f	lda $0f8010			lda 	IF_PKeyboard				; read keyboard
.0181ea	f0 08		beq $0181f4			beq		_IFGK_NoKey 				; skip if zero,no key pressed
.0181ec	48		pha				pha 								; key pressed, clear queue.
.0181ed	a9 00		lda #$00			lda 	#0
.0181ef	8f 10 80 0f	sta $0f8010			sta 	IF_PKeyboard
.0181f3	68		pla				pla
.0181f4					_IFGK_NoKey:
.0181f4	09 00		ora #$00			ora 	#0							; set Z flag appropriately.
.0181f6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/errors.asm

.0181f7					SyntaxError:
.0181f7	20 26 82	jsr $018226			jsr 	ERR_Handler
>0181fa	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>018202	72 72 6f 72 00
.018207					TypeError:
.018207	20 26 82	jsr $018226			jsr 	ERR_Handler
>01820a	57 72 6f 6e 67 20 74 79				.text 	"Wrong type",0
>018212	70 65 00
.018215					BadParamError:
.018215	20 26 82	jsr $018226			jsr 	ERR_Handler
>018218	42 61 64 20 50 61 72 61				.text 	"Bad Parameter",0
>018220	6d 65 74 65 72 00
.018226					ERR_Handler:
.018226	a0 00		ldy #$00			ldy 	#0
.018228	c8		iny				iny
.018229	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01822b	8d 08 03	sta $0308			sta 	XS_Mantissa
.01822e	c8		iny				iny
.01822f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018231	8d 09 03	sta $0309			sta 	XS_Mantissa+1
.018234	fa		plx				plx 								; address in XY
.018235	7a		ply				ply
.018236	e8		inx				inx 								; bump, because of RTS/JSR address -1
.018237	d0 01		bne $01823a			bne 	_EHNoSkip
.018239	c8		iny				iny
.01823a					_EHNoSkip:
.01823a	20 5b 82	jsr $01825b			jsr 	PrintROMMessage 			; print message from ROM.
.01823d	ad 08 03	lda $0308			lda 	XS_Mantissa					; line number = 0
.018240	0d 09 03	ora $0309			ora 	XS_Mantissa+1
.018243	f0 0c		beq $018251			beq 	_EHNoLine
.018245	a2 56		ldx #$56			ldx 	#_EHAt & $FF 				; print " at "
.018247	a0 82		ldy #$82			ldy 	#(_EHAt >> 8) & $FF
.018249	20 5b 82	jsr $01825b			jsr 	PrintROMMessage
.01824c	a2 00		ldx #$00			ldx 	#0 							; Print line number
.01824e	20 70 82	jsr $018270			jsr 	Print16BitInteger
.018251					_EHNoLine:
.018251	80 fe		bra $018251			bra 	_EHNoLine
.018253	4c b5 84	jmp $0184b5			jmp 	WarmStart
>018256	20 61 74 20 00			_EHAt:	.text 	" at ",0
.01825b					PrintROMMessage:
.01825b	86 1a		stx $1a				stx 	zLTemp1 					; save addres
.01825d	84 1b		sty $1b				sty 	zLTemp1+1
.01825f	4b		phk				phk
.018260	68		pla				pla
.018261	85 1c		sta $1c				sta 	ZLTemp1+2
.018263	a0 00		ldy #$00			ldy 	#0
.018265					_PRMLoop:
.018265	b7 1a		lda [$1a],y			lda 	[zLTemp1],y
.018267	f0 06		beq $01826f			beq		_PRMExit
.018269	c8		iny				iny
.01826a	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01826d	80 f6		bra $018265			bra 	_PRMLoop
.01826f					_PRMExit:
.01826f	60		rts				rts
.018270					Print16BitInteger:
.018270	a9 00		lda #$00			lda 	#0 							; make 32 bit
.018272	8d 0a 03	sta $030a			sta 	XS_Mantissa+2
.018275	8d 0b 03	sta $030b			sta 	XS_Mantissa+3
.018278	8d 00 04	sta $0400			sta 	NumBufX 					; reset the conversion pointer
.01827b	aa		tax				tax 								; convert bottom level.
.01827c	20 95 8f	jsr $018f95			jsr 	INTToString 				; make string
.01827f	a2 00		ldx #$00			ldx 	#0 							; print buffer
.018281	bd 01 04	lda $0401,x	_P1Loop:lda 	Num_Buffer,x
.018284	f0 06		beq $01828c			beq 	_P1Exit
.018286	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018289	e8		inx				inx
.01828a	80 f5		bra $018281			bra 	_P1Loop
.01828c	60		rts		_P1Exit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm


;******  Processing file: modules/basic/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b4					lastUnaryFunction = $b4
.01828d					VectorTable:
>01828d	b2 87					.word BinaryOp_And         & $FFFF ; $80 and
>01828f	da 87					.word BinaryOp_Or          & $FFFF ; $81 or
>018291	02 88					.word BinaryOp_Xor         & $FFFF ; $82 xor
>018293	02 88					.word BinaryOp_Eor         & $FFFF ; $83 eor
>018295	46 88					.word Binary_Equal         & $FFFF ; $84 =
>018297	65 88					.word Binary_NotEqual      & $FFFF ; $85 <>
>018299	6e 88					.word Binary_Less          & $FFFF ; $86 <
>01829b	77 88					.word Binary_LessEqual     & $FFFF ; $87 <=
>01829d	89 88					.word Binary_Greater       & $FFFF ; $88 >
>01829f	80 88					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>0182a1	1e 89					.word BinaryOp_Add         & $FFFF ; $8a +
>0182a3	3e 89					.word BinaryOp_Subtract    & $FFFF ; $8b -
>0182a5	51 89					.word BinaryOp_Multiply    & $FFFF ; $8c *
>0182a7	64 89					.word BinaryOp_Divide      & $FFFF ; $8d /
>0182a9	41 83					.word NotImplemented       & $FFFF ; $8e ^
>0182ab	41 83					.word NotImplemented       & $FFFF ; $8f if
>0182ad	41 83					.word NotImplemented       & $FFFF ; $90 while
>0182af	41 83					.word NotImplemented       & $FFFF ; $91 repeat
>0182b1	41 83					.word NotImplemented       & $FFFF ; $92 for
>0182b3	41 83					.word NotImplemented       & $FFFF ; $93 then
>0182b5	41 83					.word NotImplemented       & $FFFF ; $94 endif
>0182b7	41 83					.word NotImplemented       & $FFFF ; $95 wend
>0182b9	41 83					.word NotImplemented       & $FFFF ; $96 until
>0182bb	41 83					.word NotImplemented       & $FFFF ; $97 next
>0182bd	41 83					.word NotImplemented       & $FFFF ; $98 not
>0182bf	41 83					.word NotImplemented       & $FFFF ; $99 fn(
>0182c1	98 8a					.word Unary_Abs            & $FFFF ; $9a abs(
>0182c3	f0 8b					.word Unary_Asc            & $FFFF ; $9b asc(
>0182c5	7a 97					.word Unary_Int            & $FFFF ; $9c int(
>0182c7	b6 8a					.word Unary_Peek           & $FFFF ; $9d peek(
>0182c9	f1 96					.word Unary_Rnd            & $FFFF ; $9e rnd(
>0182cb	2a 8b					.word Unary_Usr            & $FFFF ; $9f usr(
>0182cd	31 8c					.word Unary_Left           & $FFFF ; $a0 left$(
>0182cf	48 8c					.word Unary_Right          & $FFFF ; $a1 right$(
>0182d1	16 8c					.word Unary_Mid            & $FFFF ; $a2 mid$(
>0182d3	aa 8d					.word Unary_Spc            & $FFFF ; $a3 spc(
>0182d5	bd 8b					.word Unary_Str            & $FFFF ; $a4 str$(
>0182d7	4c 8b					.word Unary_Val            & $FFFF ; $a5 val(
>0182d9	07 8c					.word Unary_Len            & $FFFF ; $a6 len(
>0182db	c6 8c					.word Unary_Hex            & $FFFF ; $a7 hex$(
>0182dd	41 83					.word NotImplemented       & $FFFF ; $a8 sin(
>0182df	41 83					.word NotImplemented       & $FFFF ; $a9 cos(
>0182e1	41 83					.word NotImplemented       & $FFFF ; $aa tan(
>0182e3	41 83					.word NotImplemented       & $FFFF ; $ab atn(
>0182e5	41 83					.word NotImplemented       & $FFFF ; $ac exp(
>0182e7	41 83					.word NotImplemented       & $FFFF ; $ad log(
>0182e9	41 83					.word NotImplemented       & $FFFF ; $ae sqr(
>0182eb	20 8d					.word Unary_Dec            & $FFFF ; $af dec(
>0182ed	ba 8a					.word Unary_Deek           & $FFFF ; $b0 deek(
>0182ef	be 8a					.word Unary_Leek           & $FFFF ; $b1 leek(
>0182f1	f2 8a					.word Unary_Mod            & $FFFF ; $b2 mod(
>0182f3	46 8a					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>0182f5	88 8d					.word Unary_Chr            & $FFFF ; $b4 chr$(
>0182f7	41 83					.word NotImplemented       & $FFFF ; $b5 $(
>0182f9	41 83					.word NotImplemented       & $FFFF ; $b6 $
>0182fb	41 83					.word NotImplemented       & $FFFF ; $b7 #(
>0182fd	41 83					.word NotImplemented       & $FFFF ; $b8 #
>0182ff	41 83					.word NotImplemented       & $FFFF ; $b9 %(
>018301	41 83					.word NotImplemented       & $FFFF ; $ba %
>018303	41 83					.word NotImplemented       & $FFFF ; $bb (
>018305	41 83					.word NotImplemented       & $FFFF ; $bc )
>018307	41 83					.word NotImplemented       & $FFFF ; $bd ,
>018309	39 85					.word Command_COLON        & $FFFF ; $be :
>01830b	41 83					.word NotImplemented       & $FFFF ; $bf ;
>01830d	41 83					.word NotImplemented       & $FFFF ; $c0 def
>01830f	cd 85					.word Command_CLR          & $FFFF ; $c1 clr
>018311	d8 85					.word Command_STOP         & $FFFF ; $c2 stop
>018313	41 83					.word NotImplemented       & $FFFF ; $c3 data
>018315	41 83					.word NotImplemented       & $FFFF ; $c4 read
>018317	41 83					.word NotImplemented       & $FFFF ; $c5 dim
>018319	41 83					.word NotImplemented       & $FFFF ; $c6 to
>01831b	41 83					.word NotImplemented       & $FFFF ; $c7 step
>01831d	41 83					.word NotImplemented       & $FFFF ; $c8 gosub
>01831f	41 83					.word NotImplemented       & $FFFF ; $c9 return
>018321	41 83					.word NotImplemented       & $FFFF ; $ca goto
>018323	3a 85					.word Command_END          & $FFFF ; $cb end
>018325	41 83					.word NotImplemented       & $FFFF ; $cc input
>018327	41 83					.word NotImplemented       & $FFFF ; $cd let
>018329	41 83					.word NotImplemented       & $FFFF ; $ce list
>01832b	41 83					.word NotImplemented       & $FFFF ; $cf new
>01832d	41 83					.word NotImplemented       & $FFFF ; $d0 old
>01832f	41 83					.word NotImplemented       & $FFFF ; $d1 on
>018331	41 83					.word NotImplemented       & $FFFF ; $d2 restore
>018333	41 83					.word NotImplemented       & $FFFF ; $d3 poke
>018335	3e 85					.word Command_PRINT        & $FFFF ; $d4 print
>018337	c3 84					.word Command_RUN          & $FFFF ; $d5 run
>018339	41 83					.word NotImplemented       & $FFFF ; $d6 wait
>01833b	41 83					.word NotImplemented       & $FFFF ; $d7 doke
>01833d	41 83					.word NotImplemented       & $FFFF ; $d8 loke
>01833f	b1 85					.word Command_ASSERT       & $FFFF ; $d9 assert
.018341					NotImplemented:
.018341	20 26 82	jsr $018226			jsr ERR_Handler
>018344	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>01834c	65 6d 65 6e 74 65 64 00
.018354					BinaryPrecedence:
>018354	01					.byte 1    ; $80 and
>018355	01					.byte 1    ; $81 or
>018356	01					.byte 1    ; $82 xor
>018357	01					.byte 1    ; $83 eor
>018358	02					.byte 2    ; $84 =
>018359	02					.byte 2    ; $85 <>
>01835a	02					.byte 2    ; $86 <
>01835b	02					.byte 2    ; $87 <=
>01835c	02					.byte 2    ; $88 >
>01835d	02					.byte 2    ; $89 >=
>01835e	03					.byte 3    ; $8a +
>01835f	03					.byte 3    ; $8b -
>018360	04					.byte 4    ; $8c *
>018361	04					.byte 4    ; $8d /
>018362	05					.byte 5    ; $8e ^
.018363					KeywordText:
>018363	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>018366	4f d2					.byte $4f,$d2                          ; $81 or
>018368	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>01836b	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>01836e	bd					.byte $bd                              ; $84 =
>01836f	3c be					.byte $3c,$be                          ; $85 <>
>018371	bc					.byte $bc                              ; $86 <
>018372	3c bd					.byte $3c,$bd                          ; $87 <=
>018374	be					.byte $be                              ; $88 >
>018375	3e bd					.byte $3e,$bd                          ; $89 >=
>018377	ab					.byte $ab                              ; $8a +
>018378	ad					.byte $ad                              ; $8b -
>018379	aa					.byte $aa                              ; $8c *
>01837a	af					.byte $af                              ; $8d /
>01837b	de					.byte $de                              ; $8e ^
>01837c	49 c6					.byte $49,$c6                          ; $8f if
>01837e	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>018383	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>018389	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>01838c	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>018390	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>018395	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>018399	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>01839e	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>0183a2	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>0183a5	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>0183a8	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>0183ac	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>0183b0	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>0183b4	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>0183b9	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>0183bd	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>0183c1	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>0183c7	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>0183ce	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>0183d3	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>0183d7	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>0183dc	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>0183e0	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>0183e4	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>0183e9	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>0183ed	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>0183f1	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>0183f5	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>0183f9	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>0183fd	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>018401	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>018405	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>018409	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>01840e	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>018413	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>018417	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>01841b	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>018420	24 a8					.byte $24,$a8                          ; $b5 $(
>018422	a4					.byte $a4                              ; $b6 $
>018423	23 a8					.byte $23,$a8                          ; $b7 #(
>018425	a3					.byte $a3                              ; $b8 #
>018426	25 a8					.byte $25,$a8                          ; $b9 %(
>018428	a5					.byte $a5                              ; $ba %
>018429	a8					.byte $a8                              ; $bb (
>01842a	a9					.byte $a9                              ; $bc )
>01842b	ac					.byte $ac                              ; $bd ,
>01842c	ba					.byte $ba                              ; $be :
>01842d	bb					.byte $bb                              ; $bf ;
>01842e	44 45 c6				.byte $44,$45,$c6                      ; $c0 def
>018431	43 4c d2				.byte $43,$4c,$d2                      ; $c1 clr
>018434	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $c2 stop
>018438	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c3 data
>01843c	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c4 read
>018440	44 49 cd				.byte $44,$49,$cd                      ; $c5 dim
>018443	54 cf					.byte $54,$cf                          ; $c6 to
>018445	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c7 step
>018449	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $c8 gosub
>01844e	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $c9 return
>018454	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $ca goto
>018458	45 4e c4				.byte $45,$4e,$c4                      ; $cb end
>01845b	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $cc input
>018460	4c 45 d4				.byte $4c,$45,$d4                      ; $cd let
>018463	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $ce list
>018467	4e 45 d7				.byte $4e,$45,$d7                      ; $cf new
>01846a	4f 4c c4				.byte $4f,$4c,$c4                      ; $d0 old
>01846d	4f ce					.byte $4f,$ce                          ; $d1 on
>01846f	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d2 restore
>018476	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d3 poke
>01847a	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d4 print
>01847f	52 55 ce				.byte $52,$55,$ce                      ; $d5 run
>018482	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d6 wait
>018486	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $d7 doke
>01848a	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $d8 loke
>01848e	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $d9 assert
>018494	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_dollarlparen = $b5
=$b6					token_dollar = $b6
=$b7					token_hashlparen = $b7
=$b8					token_hash = $b8
=$b9					token_percentlparen = $b9
=$ba					token_percent = $ba
=$bb					token_lparen = $bb
=$bc					token_rparen = $bc
=$bd					token_comma = $bd
=$be					token_colon = $be
=$bf					token_semicolon = $bf
=$c0					token_def = $c0
=$c1					token_clr = $c1
=$c2					token_stop = $c2
=$c3					token_data = $c3
=$c4					token_read = $c4
=$c5					token_dim = $c5
=$c6					token_to = $c6
=$c7					token_step = $c7
=$c8					token_gosub = $c8
=$c9					token_return = $c9
=$ca					token_goto = $ca
=$cb					token_end = $cb
=$cc					token_input = $cc
=$cd					token_let = $cd
=$ce					token_list = $ce
=$cf					token_new = $cf
=$d0					token_old = $d0
=$d1					token_on = $d1
=$d2					token_restore = $d2
=$d3					token_poke = $d3
=$d4					token_print = $d4
=$d5					token_run = $d5
=$d6					token_wait = $d6
=$d7					token_doke = $d7
=$d8					token_loke = $d8
=$d9					token_assert = $d9

;******  Return to file: modules/basic/core.asm

.018495					BASIC_Start:
.018495	20 a8 81	jsr $0181a8			jsr 	IF_Reset 					; set up and clear screen.
.018498	20 00 80	jsr $018000			jsr 	IFT_ClearScreen
.01849b	a9 5c		lda #$5c			lda 	#$5C 						; JMP Long opcode
.01849d	8d 04 03	sta $0304			sta 	LocalVector
.0184a0	8d 00 03	sta $0300			sta 	UserVector
.0184a3	a9 3a		lda #$3a			lda 	#USRDefault & $FF 			; reset USR vector
.0184a5	8d 01 03	sta $0301			sta 	UserVector+1
.0184a8	a9 8b		lda #$8b			lda 	#(USRDefault >> 8) & $FF
.0184aa	8d 02 03	sta $0302			sta 	UserVector+2
.0184ad	a9 01		lda #$01			lda 	#(USRDefault >> 16) & $FF
.0184af	8d 03 03	sta $0303			sta 	UserVector+3
.0184b2	20 cd 85	jsr $0185cd			jsr 	ResetRunStatus 				; clear everything (CLR command)
.0184b5					WarmStart:
.0184b5	c2 30		rep #$30			rep 	#$30
.0184b7	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.0184ba	1b		tcs				tcs
.0184bb	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.0184be	e2 30		sep #$30			sep 	#$30
.0184c0	4c c3 84	jmp $0184c3			jmp 	COMMAND_Run

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/run.asm

.0184c3					Command_RUN:
.0184c3	20 cd 85	jsr $0185cd			jsr 	ResetRunStatus 				; clear, reset stacks etc.
.0184c6	a9 00		lda #$00			lda 	#BasicProgram & $FF
.0184c8	85 16		sta $16				sta 	zCodePtr+0
.0184ca	a9 10		lda #$10			lda 	#BasicProgram >> 8
.0184cc	85 17		sta $17				sta 	zCodePtr+1
.0184ce	a9 00		lda #$00			lda 	#0
.0184d0	85 18		sta $18				sta 	zCodePtr+2
.0184d2	85 19		sta $19				sta 	zCodePtr+3
.0184d4	a0 03		ldy #$03			ldy 	#3
.0184d6					RUN_NewLine:
.0184d6	a0 00		ldy #$00			ldy 	#0
.0184d8	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0184da	c8		iny				iny
.0184db	c8		iny				iny
.0184dc	c8		iny				iny
.0184dd	c9 00		cmp #$00			cmp 	#0 							; if the offset is zero then END.
.0184df	d0 16		bne $0184f7			bne 	RUN_NextCommand
.0184e1	4c d8 85	jmp $0185d8			jmp 	Command_STOP 				; go do the command code.
.0184e4					RUN_Skip:
.0184e4	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.0184e6	c8		iny				iny 								; skip
.0184e7	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.0184e9	90 0c		bcc $0184f7			bcc 	_SEDone 					; so just skip over it.
.0184eb	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.0184ed	90 07		bcc $0184f6			bcc 	_SEDouble
.0184ef	98		tya				tya 								; this is Y + 1
.0184f0	18		clc				clc
.0184f1	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.0184f3	a8		tay				tay 								; back in Y.
.0184f4	88		dey				dey 								; fix up, one for the +1, one for the iny
.0184f5	88		dey				dey
.0184f6					_SEDouble:
.0184f6	c8		iny				iny
.0184f7					_SEDone:
.0184f7					RUN_NextCommand:
.0184f7	a9 00		lda #$00			lda 	#0 							; this resets temporary string allocation.
.0184f9	85 21		sta $21				sta 	zTempStr+1 					; (initialised when first called)
.0184fb	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0184fd	c9 be		cmp #$be			cmp 	#token_Colon 				; skip over colons
.0184ff	f0 e3		beq $0184e4			beq 	RUN_Skip
.018501	c9 00		cmp #$00			cmp 	#0 							; if non-zero execute whatever
.018503	d0 0f		bne $018514			bne 	RUN_Execute
.018505					RUN_NextLine:
.018505	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018507	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.018509	18		clc				clc
.01850a	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.01850c	85 16		sta $16				sta 	zCodePtr
.01850e	90 02		bcc $018512			bcc 	_SNLNoCarry
.018510	e6 17		inc $17				inc 	zCodePtr+1
.018512					_SNLNoCarry:
.018512	80 c2		bra $0184d6			bra 	RUN_NewLine 				; go do the new line code
.018514					RUN_Execute:
.018514	c9 f8		cmp #$f8			cmp 	#$F8 						; handle shifts, REM etc.
.018516	b0 1a		bcs $018532			bcs 	RUN_Extension
.018518	c8		iny				iny
.018519	0a		asl a				asl 	a 							; double the character read.
.01851a	90 14		bcc $018530			bcc 	RUN_Default 				; if carry clear was $00-$7F, so try LET.
.01851c	aa		tax				tax 								; ready to look up.
.01851d	bf 8d 82 01	lda $01828d,x			lda 	VectorTable,x 				; copy address into LocalVector
.018521	8d 05 03	sta $0305			sta 	LocalVector+1
.018524	bf 8e 82 01	lda $01828e,x			lda 	VectorTable+1,x
.018528	8d 06 03	sta $0306			sta 	LocalVector+2
.01852b	20 eb 86	jsr $0186eb			jsr 	EVCallLocalVector 			; execute the appropriate code.
.01852e	80 c7		bra $0184f7			bra 	RUN_NextCommand 			; do the next command.
.018530					RUN_Default:
.018530	80 fe		bra $018530			bra 	RUN_Default
.018532					RUN_Extension:
.018532	c9 ff		cmp #$ff			cmp 	#$FF 						; if $FF (REM)
.018534	f0 ae		beq $0184e4			beq 	RUN_Skip 					; skip over it.
.018536	4c f7 81	jmp $0181f7			jmp 	SyntaxError
.018539					Command_COLON:
.018539	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/end.asm

.01853a					Command_END:
>01853a	02						.byte 	2
.01853b	4c b5 84	jmp $0184b5			jmp 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/print.asm

.01853e					Command_PRINT:
.01853e	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018540	c9 00		cmp #$00			cmp 	#0 							; end
.018542	f0 69		beq $0185ad			beq 	_CPR_NewLine
.018544	c9 be		cmp #$be			cmp 	#token_Colon
.018546	f0 65		beq $0185ad			beq 	_CPR_NewLine
.018548	c9 bf		cmp #$bf			cmp 	#token_SemiColon
.01854a	f0 54		beq $0185a0			beq 	_CPR_Skip
.01854c	c9 bd		cmp #$bd			cmp 	#token_Comma
.01854e	f0 4d		beq $01859d			beq 	_CPR_Tab
.018550	20 e3 85	jsr $0185e3			jsr 	EvaluateExpression 			; get expression.
.018553	ad 0d 03	lda $030d			lda 	XS_Type 					; get type.
.018556	29 02		and #$02			and 	#2
.018558	d0 25		bne $01857f			bne 	_CPR_String 				; if type = 2 output as string.
.01855a					_CPR_Number:
.01855a	a9 00		lda #$00			lda 	#0 							; reset buffer index
.01855c	8d 00 04	sta $0400			sta 	NumBufX
.01855f	ad 0d 03	lda $030d			lda 	XS_Type 					; get type
.018562	4a		lsr a				lsr 	a
.018563	b0 05		bcs $01856a			bcs 	_CPRInt 					; if msb set do as integer
.018565	20 a9 95	jsr $0195a9			jsr 	FPToString 					; call fp to str otherwise
.018568	80 03		bra $01856d			bra 	_CPRNPrint
.01856a	20 95 8f	jsr $018f95	_CPRInt:jsr 	IntToString
.01856d					_CPRNPrint:
.01856d	ad 01 04	lda $0401			lda 	Num_Buffer 					; is first character -
.018570	c9 2d		cmp #$2d			cmp 	#"-"
.018572	f0 05		beq $018579			beq 	_CPRNoSpace
.018574	a9 20		lda #$20			lda 	#" "						; print the leading space
.018576	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter 			; so beloved of MS Basics.
.018579					_CPRNoSpace:
.018579	a2 00		ldx #$00			ldx 	#(Num_Buffer-1) & $FF
.01857b	a9 04		lda #$04			lda 	#(Num_Buffer-1) >> 8
.01857d	80 06		bra $018585			bra 	_CPRPrint
.01857f					_CPR_String:
.01857f	ae 08 03	ldx $0308			ldx 	XS_Mantissa
.018582	ad 09 03	lda $0309			lda 	XS_Mantissa+1
.018585					_CPRPrint:
.018585	86 1e		stx $1e				stx 	zGenPtr
.018587	85 1f		sta $1f				sta 	zGenPtr+1
.018589	5a		phy				phy
.01858a	a0 00		ldy #$00			ldy 	#0							; get length into X
.01858c	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.01858e	aa		tax				tax
.01858f	f0 09		beq $01859a			beq 	_CPREndPrint 				; nothing to print
.018591					_CPRLoop:
.018591	c8		iny				iny
.018592	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018594	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018597	ca		dex				dex
.018598	d0 f7		bne $018591			bne 	_CPRLoop
.01859a					_CPREndPrint:
.01859a	7a		ply				ply
.01859b	80 a1		bra $01853e			bra 	Command_Print
.01859d					_CPR_Tab:
.01859d	20 4f 80	jsr $01804f			jsr 	IFT_Tab
.0185a0					_CPR_Skip:
.0185a0	c8		iny				iny
.0185a1	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0185a3	c9 be		cmp #$be			cmp 	#token_Colon 				; colon or $00, exit
.0185a5	f0 09		beq $0185b0			beq 	_CPR_Exit
.0185a7	c9 00		cmp #$00			cmp 	#0
.0185a9	d0 93		bne $01853e			bne 	Command_PRINT 				; if not go round again.
.0185ab	80 03		bra $0185b0			bra 	_CPR_Exit
.0185ad					_CPR_NewLine:
.0185ad	20 5c 80	jsr $01805c			jsr 	IFT_NewLine
.0185b0					_CPR_Exit:
.0185b0	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/assert.asm

.0185b1					Command_ASSERT:
.0185b1	20 81 87	jsr $018781			jsr 	EvaluateNumber 				; calculate thing being asserted
.0185b4	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; check if true (non-zero)
.0185b7	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.0185ba	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.0185bd	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.0185c0	f0 01		beq $0185c3			beq 	_ASFail
.0185c2	60		rts				rts
.0185c3					_ASFail:
.0185c3	20 26 82	jsr $018226			jsr ERR_Handler
>0185c6	41 73 73 65 72 74 00			.text "Assert",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.0185cd					Command_CLR:
.0185cd					ResetRunStatus:
.0185cd	a9 00		lda #$00			lda 	#HighMemory & $FF
.0185cf	8d 26 04	sta $0426			sta 	StringPtr
.0185d2	a9 80		lda #$80			lda 	#HighMemory >> 8
.0185d4	8d 27 04	sta $0427			sta 	StringPtr+1
.0185d7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/stop.asm

.0185d8					Command_STOP:
.0185d8	20 26 82	jsr $018226			jsr ERR_Handler
>0185db	53 74 6f 70 00				.text "Stop",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.0185e0					EVESyntax:
.0185e0	4c f7 81	jmp $0181f7			jmp 	SyntaxError
.0185e3					EvaluateExpression:
.0185e3	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.0185e5					EvaluateExpressionX:
.0185e5	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.0185e7					EvaluateExpressionXA:
.0185e7	48		pha				pha 								; save precedence on stack.
.0185e8	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0185ea	f0 f4		beq $0185e0			beq 	EVESyntax 					; end of line, syntax error.
.0185ec	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.0185ee	b0 03		bcs $0185f3			bcs 	_EVNotVariable
.0185f0	4c ea 86	jmp $0186ea			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.0185f3					_EVNotVariable:
.0185f3	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.0185f5	90 e9		bcc $0185e0			bcc 	EVESyntax
.0185f7	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.0185f9	b0 7f		bcs $01867a			bcs 	_EVNotInteger
.0185fb	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.0185fd	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.018600	a9 00		lda #$00			lda 	#0
.018602	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018605	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018608	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.01860b	1a		inc a				inc 	a 							; set to type 1 (integer)
.01860c	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.01860f					_EVCheckNextInteger:
.01860f	c8		iny				iny
.018610	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018612	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.018614	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.018616	b0 0d		bcs $018625			bcs 	_EVCheckDecimal
.018618	48		pha				pha 								; save it.
.018619	20 ee 86	jsr $0186ee			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.01861c	68		pla				pla
.01861d	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.018620	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018623	80 ea		bra $01860f			bra 	_EVCheckNextInteger
.018625					_EVCheckDecimal:
.018625	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018627	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.018629	d0 05		bne $018630			bne 	_EVGotAtom 					; no, get atom.
.01862b					_EVIsDecimal:
.01862b	20 1e 87	jsr $01871e			jsr 	EVGetDecimal 				; extend to the decimal part.
.01862e	80 00		bra $018630			bra 	_EVGotAtom 					; and continue to got atom.
.018630					_EVGotAtom:
.018630	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018632	10 44		bpl $018678			bpl 	_EVExitDrop 				; must be a token.
.018634	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.018636	b0 40		bcs $018678			bcs 	_EVExitDrop
.018638	68		pla				pla 								; get current precedence
.018639	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.01863b	da		phx				phx 								; save X
.01863c	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01863e	aa		tax				tax 								; put in X
.01863f	bf d4 82 01	lda $0182d4,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.018643	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.018645	fa		plx				plx 								; restore X
.018646	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.018648	90 2f		bcc $018679			bcc 	_EVExit 					; exit if too low.
.01864a	f0 2d		beq $018679			beq 	_EVExit 					; exit if equals
.01864c	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.01864e	48		pha				pha
.01864f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018651	48		pha				pha
.018652	c8		iny				iny
.018653	da		phx				phx 								; save current position
.018654	e8		inx				inx
.018655	e8		inx				inx
.018656	e8		inx				inx
.018657	e8		inx				inx
.018658	e8		inx				inx
.018659	e8		inx				inx
.01865a	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.01865c	20 e7 85	jsr $0185e7			jsr 	EvaluateExpressionXA 		; do the RHS.
.01865f	fa		plx				plx 								; restore X
.018660	68		pla				pla 								; get the binary operator in A.
.018661					_EVCallA:
.018661	da		phx				phx 								; save X again
.018662	0a		asl a				asl 	a 							; double, lose the MSB.
.018663	aa		tax				tax									; put in X
.018664	bf 8d 82 01	lda $01828d,x			lda 	VectorTable,x 				; copy address into zGenPtr
.018668	8d 05 03	sta $0305			sta 	LocalVector+1
.01866b	bf 8e 82 01	lda $01828e,x			lda 	VectorTable+1,x
.01866f	8d 06 03	sta $0306			sta 	LocalVector+2
.018672	fa		plx				plx 								; restore X
.018673	20 eb 86	jsr $0186eb			jsr 	EVCallLocalVector
.018676	80 b8		bra $018630			bra 	_EVGotAtom 					; and loop back.
.018678					_EVExitDrop:
.018678	68		pla				pla
.018679					_EVExit:
.018679	60		rts				rts
.01867a					_EVNotInteger:
.01867a	c8		iny				iny
.01867b	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.01867d	d0 19		bne $018698			bne 	_EVNotMinus
.01867f	20 6f 87	jsr $01876f			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.018682	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.018685	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.018687	f0 05		beq $01868e			beq 	_EVMinusFloat
.018689	20 70 8f	jsr $018f70			jsr 	IntegerNegateAlways 		; negation
.01868c	80 a2		bra $018630			bra 	_EVGotAtom 					; and go back.
.01868e					_EVMinusFloat:
.01868e	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; invert the sign bit.
.018691	49 80		eor #$80			eor 	#$80
.018693	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018696	80 98		bra $018630			bra 	_EVGotAtom
.018698					_EVNotMinus:
.018698	c9 bb		cmp #$bb			cmp 	#token_lparen 				; is it left parenthesis
.01869a	d0 17		bne $0186b3			bne 	_EVNotParenthesis
.01869c	20 e5 85	jsr $0185e5			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.01869f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0186a1	c8		iny				iny
.0186a2	c9 bc		cmp #$bc			cmp 	#token_rparen 				; okay if right bracket.
.0186a4	f0 8a		beq $018630			beq 	_EVGotAtom
.0186a6	20 26 82	jsr $018226			jsr ERR_Handler
>0186a9	4d 69 73 73 69 6e 67 20			.text "Missing )",0
>0186b1	29 00
.0186b3					_EVNotParenthesis:
.0186b3	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.0186b5	d0 0c		bne $0186c3			bne 	_EVNotNot
.0186b7	20 6f 87	jsr $01876f			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.0186ba	20 7e 94	jsr $01947e			jsr 	FPUToInteger 				; make it an integer - if possible.
.0186bd	20 4c 87	jsr $01874c			jsr 	NotInteger 					; do the not calculation
.0186c0	4c 30 86	jmp $018630			jmp 	_EVGotAtom
.0186c3					_EVNotNot:
.0186c3	c9 fe		cmp #$fe			cmp 	#$FE
.0186c5	d0 15		bne $0186dc			bne 	_EVNotString
.0186c7	20 5d 8e	jsr $018e5d			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.0186ca	a5 20		lda $20				lda 	zTempStr 					; copy address of string into mantissa
.0186cc	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0186cf	a5 21		lda $21				lda 	zTempStr+1
.0186d1	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0186d4	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.0186d6	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0186d9	4c 30 86	jmp $018630			jmp 	_EVGotAtom
.0186dc					_EVNotString:
.0186dc	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.0186de	90 04		bcc $0186e4			bcc 	_EVBadElement
.0186e0	c9 b5		cmp #$b5			cmp 	#lastUnaryFunction+1
.0186e2	90 03		bcc $0186e7			bcc 	_EVUnaryFunction
.0186e4					_EVBadElement:
.0186e4	4c f7 81	jmp $0181f7			jmp 	SyntaxError
.0186e7					_EVUnaryFunction:
.0186e7	4c 61 86	jmp $018661			jmp 	_EVCallA
.0186ea					_EVVariableHandler:
.0186ea	ea		nop				nop
.0186eb					EVCallLocalVector:
.0186eb	6c 05 03	jmp ($0305)			jmp 	(LocalVector+1)
.0186ee					EVShiftMantissaLeft6:
.0186ee	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.0186f1	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.0186f4	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.0186f7	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0186fa	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0186fd	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018700	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018703	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018706	a9 00		lda #$00			lda 	#0
.018708	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.01870b	20 0e 87	jsr $01870e			jsr 	_EVSMLShift 					; call it here to do it twice
.01870e					_EVSMLShift:
.01870e	5e 0c 03	lsr $030c,x			lsr 	XS_Exponent,x
.018711	7e 0b 03	ror $030b,x			ror 	XS_Mantissa+3,x
.018714	7e 0a 03	ror $030a,x			ror 	XS_Mantissa+2,x
.018717	7e 09 03	ror $0309,x			ror 	XS_Mantissa+1,x
.01871a	7e 08 03	ror $0308,x			ror 	XS_Mantissa+0,x
.01871d	60		rts				rts
.01871e					EVGetDecimal:
.01871e	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.018720	8d 01 04	sta $0401			sta 	Num_Buffer
.018723	da		phx				phx
.018724	c8		iny				iny
.018725	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018727	c8		iny				iny
.018728	3a		dec a				dec 	a								; convert to a string length.
.018729	3a		dec a				dec 	a
.01872a	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.01872c					_EVGDCopy:
.01872c	48		pha				pha 									; save count
.01872d	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01872f	9d 01 04	sta $0401,x			sta 	Num_Buffer,x
.018732	e8		inx				inx 									; forward ....
.018733	c8		iny				iny
.018734	68		pla				pla 									; get count
.018735	3a		dec a				dec 	a 								; until zero
.018736	d0 f4		bne $01872c			bne 	_EVGDCopy
.018738	9d 01 04	sta $0401,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.01873b	fa		plx				plx 									; restore X
.01873c	a9 01		lda #$01			lda 	#Num_Buffer & $FF 				; set zGenPtr
.01873e	85 1e		sta $1e				sta 	zGenPtr
.018740	a9 04		lda #$04			lda 	#Num_Buffer >> 8
.018742	85 1f		sta $1f				sta 	zGenPtr+1
.018744	5a		phy				phy 									; save Y
.018745	a0 00		ldy #$00			ldy 	#0 								; start position
.018747	20 70 96	jsr $019670			jsr 	FPFromString 					; convert current
.01874a	7a		ply				ply 									; restore Y
.01874b	60		rts				rts
.01874c					NotInteger:
.01874c	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.01874f	49 ff		eor #$ff			eor 	#$FF
.018751	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018754	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018757	49 ff		eor #$ff			eor 	#$FF
.018759	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.01875c	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.01875f	49 ff		eor #$ff			eor 	#$FF
.018761	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018764	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.018767	49 ff		eor #$ff			eor 	#$FF
.018769	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.01876c	60		rts				rts
.01876d					EvaluateGetAtom:
.01876d	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.01876f					EvaluateGetAtomX:
.01876f	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.018771	20 e7 85	jsr $0185e7			jsr 	EvaluateExpressionXA
.018774	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.018777	29 0f		and #$0f			and 	#15
.018779	c9 02		cmp #$02			cmp 	#2
.01877b	b0 01		bcs $01877e			bcs 	EvaluateType
.01877d	60		rts				rts
.01877e					EvaluateType:
.01877e	4c 07 82	jmp $018207			jmp 	TypeError
.018781					EvaluateNumber:
.018781	a2 00		ldx #$00			ldx 	#0
.018783					EvaluateNumberX:
.018783	20 e5 85	jsr $0185e5			jsr 	EvaluateExpressionX
.018786	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 0/1
.018789	29 0f		and #$0f			and 	#15
.01878b	c9 02		cmp #$02			cmp 	#2
.01878d	b0 ef		bcs $01877e			bcs 	EvaluateType
.01878f	60		rts				rts
.018790					EvaluateInteger:
.018790	a2 00		ldx #$00			ldx 	#0
.018792					EvaluateIntegerX:
.018792	20 83 87	jsr $018783			jsr 	EvaluateNumberX
.018795	20 7e 94	jsr $01947e			jsr 	FPUToInteger
.018798	60		rts				rts
.018799					EvaluateString:
.018799	a2 00		ldx #$00			ldx 	#0
.01879b					EvaluateStringX:
.01879b	20 e5 85	jsr $0185e5			jsr 	EvaluateExpressionX
.01879e	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 2
.0187a1	29 0f		and #$0f			and 	#15
.0187a3	c9 02		cmp #$02			cmp 	#2
.0187a5	d0 d7		bne $01877e			bne 	EvaluateType
.0187a7	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.0187aa	85 1e		sta $1e				sta 	zGenPtr
.0187ac	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0187af	85 1f		sta $1f				sta 	zGenPtr+1
.0187b1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.0187b2					BinaryOp_And:
.0187b2	20 2a 88	jsr $01882a			jsr 	BinaryMakeBothInteger
.0187b5	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.0187b8	3d 0e 03	and $030e,x			and 	XS2_Mantissa+0,x
.0187bb	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0187be	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.0187c1	3d 0f 03	and $030f,x			and 	XS2_Mantissa+1,x
.0187c4	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0187c7	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.0187ca	3d 10 03	and $0310,x			and 	XS2_Mantissa+2,x
.0187cd	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0187d0	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.0187d3	3d 11 03	and $0311,x			and 	XS2_Mantissa+3,x
.0187d6	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0187d9	60		rts				rts
.0187da					BinaryOp_Or:
.0187da	20 2a 88	jsr $01882a			jsr 	BinaryMakeBothInteger
.0187dd	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.0187e0	1d 0e 03	ora $030e,x			ora 	XS2_Mantissa+0,x
.0187e3	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0187e6	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.0187e9	1d 0f 03	ora $030f,x			ora 	XS2_Mantissa+1,x
.0187ec	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0187ef	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.0187f2	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.0187f5	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0187f8	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.0187fb	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.0187fe	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018801	60		rts				rts
.018802					BinaryOp_Eor:
.018802					BinaryOp_Xor:
.018802	20 2a 88	jsr $01882a			jsr 	BinaryMakeBothInteger
.018805	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.018808	5d 0e 03	eor $030e,x			eor 	XS2_Mantissa+0,x
.01880b	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.01880e	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.018811	5d 0f 03	eor $030f,x			eor 	XS2_Mantissa+1,x
.018814	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018817	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.01881a	5d 10 03	eor $0310,x			eor 	XS2_Mantissa+2,x
.01881d	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018820	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.018823	5d 11 03	eor $0311,x			eor 	XS2_Mantissa+3,x
.018826	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018829	60		rts				rts
.01882a					BinaryMakeBothInteger:
.01882a	da		phx				phx 								; save X
.01882b	e8		inx				inx
.01882c	e8		inx				inx
.01882d	e8		inx				inx
.01882e	e8		inx				inx
.01882f	e8		inx				inx
.018830	e8		inx				inx
.018831	20 35 88	jsr $018835			jsr 	BinaryMakeInteger 			; convert to integer.
.018834	fa		plx				plx 								; restore X and fall through.
.018835					BinaryMakeInteger:
.018835	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type byte.
.018838	29 0f		and #$0f			and 	#15 						; check type zero
.01883a	f0 04		beq $018840			beq 	_BMIConvert 				; if float convert to integer.
.01883c	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.01883d	90 04		bcc $018843			bcc 	_BMIError
.01883f	60		rts				rts
.018840					_BMIConvert:
.018840	4c 7e 94	jmp $01947e			jmp 	FPUToInteger 				; convert to integer
.018843					_BMIError:
.018843	4c 07 82	jmp $018207			jmp 	TypeError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.018846					Binary_Equal:
.018846	20 92 88	jsr $018892			jsr 	CompareValues
.018849	09 00		ora #$00			ora 	#0
.01884b	f0 04		beq $018851			beq 	CCTrue
.01884d	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.01884f	80 02		bra $018853			bra 	CCWrite
.018851	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.018853	9d 08 03	sta $0308,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.018856	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018859	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01885c	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.01885f	a9 01		lda #$01			lda 	#1
.018861	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; set type to integer whatever.
.018864	60		rts				rts
.018865					Binary_NotEqual:
.018865	20 92 88	jsr $018892			jsr 	CompareValues
.018868	09 00		ora #$00			ora 	#0
.01886a	f0 e1		beq $01884d			beq 	CCFalse
.01886c	80 e3		bra $018851			bra 	CCTrue
.01886e					Binary_Less:
.01886e	20 92 88	jsr $018892			jsr 	CompareValues
.018871	09 00		ora #$00			ora 	#0
.018873	30 dc		bmi $018851			bmi 	CCTrue
.018875	80 d6		bra $01884d			bra 	CCFalse
.018877					Binary_LessEqual:
.018877	20 92 88	jsr $018892			jsr 	CompareValues
.01887a	c9 01		cmp #$01			cmp 	#1
.01887c	d0 d3		bne $018851			bne 	CCTrue
.01887e	80 cd		bra $01884d			bra 	CCFalse
.018880					Binary_GreaterEqual:
.018880	20 92 88	jsr $018892			jsr 	CompareValues
.018883	09 00		ora #$00			ora 	#0
.018885	10 ca		bpl $018851			bpl 	CCTrue
.018887	80 c4		bra $01884d			bra 	CCFalse
.018889					Binary_Greater:
.018889	20 92 88	jsr $018892			jsr 	CompareValues
.01888c	c9 01		cmp #$01			cmp 	#1
.01888e	f0 c1		beq $018851			beq 	CCTrue
.018890	80 bb		bra $01884d			bra 	CCFalse
.018892					CompareValues:
.018892	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and the types together
.018895	3d 13 03	and $0313,x			and 	XS2_Type,x
.018898	c9 02		cmp #$02			cmp 	#2
.01889a	f0 13		beq $0188af			beq 	_CVString
.01889c	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.01889f	3d 13 03	and $0313,x			and 	XS2_Type,x
.0188a2	4a		lsr a				lsr 	a 							; shift bit 0 into C
.0188a3	90 03		bcc $0188a8			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.0188a5	4c f5 88	jmp $0188f5			jmp 	CompareInteger32 							; so execute code at \1
.0188a8					_BCFloat:
.0188a8	20 c3 89	jsr $0189c3			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.0188ab	4c 8d 93	jmp $01938d			jmp 	FPCompare 							; and execute code at \2
.0188ae	60		rts				rts
.0188af					_CVString:
.0188af	da		phx				phx 								; save XY
.0188b0	5a		phy				phy
.0188b1	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.0188b4	85 1a		sta $1a				sta		zLTemp1+0
.0188b6	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0188b9	85 1b		sta $1b				sta 	zLTemp1+1
.0188bb	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x
.0188be	85 1c		sta $1c				sta 	zLTemp1+2
.0188c0	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.0188c3	85 1d		sta $1d				sta 	zLTemp1+3
.0188c5	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.0188c7	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.0188c9	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.0188cb	90 02		bcc $0188cf			bcc 	_CVCommon
.0188cd	b1 1c		lda ($1c),y			lda 	(zLTemp1+2),y
.0188cf					_CVCommon:
.0188cf	aa		tax				tax 								; put shorter string length in zero.
.0188d0	f0 0c		beq $0188de			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.0188d2					_CVCompare:
.0188d2	c8		iny				iny 								; next character
.0188d3	b1 1a		lda ($1a),y			lda 	(zLTemp1),y 				; compare characters
.0188d5	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.0188d7	90 13		bcc $0188ec			bcc 	_CVReturnLess 				; <
.0188d9	d0 15		bne $0188f0			bne 	_CVReturnGreater 			; >
.0188db	ca		dex				dex 								; until common length matched.
.0188dc	d0 f4		bne $0188d2			bne 	_CVCompare
.0188de					_CVMatch:
.0188de	a0 00		ldy #$00			ldy 	#0
.0188e0	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.0188e2	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.0188e4	90 06		bcc $0188ec			bcc 	_CVReturnLess 				; <
.0188e6	d0 08		bne $0188f0			bne 	_CVReturnGreater 			; >
.0188e8	a9 00		lda #$00			lda 	#0
.0188ea	80 06		bra $0188f2			bra 	_CVExit 					; same common, same length, same string
.0188ec					_CVReturnLess:
.0188ec	a9 ff		lda #$ff			lda 	#$FF
.0188ee	80 02		bra $0188f2			bra 	_CVExit
.0188f0					_CVReturnGreater:
.0188f0	a9 01		lda #$01			lda 	#$01
.0188f2					_CVExit:
.0188f2	7a		ply				ply
.0188f3	fa		plx				plx
.0188f4	60		rts				rts
.0188f5					CompareInteger32:
.0188f5	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.0188f8	49 80		eor #$80			eor 	#$80
.0188fa	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0188fd	bd 11 03	lda $0311,x			lda 	XS2_Mantissa+3,x
.018900	49 80		eor #$80			eor 	#$80
.018902	9d 11 03	sta $0311,x			sta 	XS2_Mantissa+3,x
.018905	20 9d 89	jsr $01899d			jsr 	SubInteger32 				; subtraction
.018908	90 11		bcc $01891b			bcc 	_CI32Less 					; cc return -1
.01890a	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; check if zero
.01890d	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.018910	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.018913	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.018916	f0 02		beq $01891a			beq 	_CI32Exit
.018918	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.01891a					_CI32Exit:
.01891a	60		rts				rts
.01891b					_CI32Less:
.01891b	a9 ff		lda #$ff			lda 	#$FF
.01891d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.01891e					BinaryOp_Add:
.01891e	bd 0d 03	lda $030d,x			lda 	XS_Type,x  					; and types together
.018921	3d 13 03	and $0313,x			and 	XS2_Type,x
.018924	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.018926	d0 13		bne $01893b			bne 	_BOAString
.018928	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.01892b	3d 13 03	and $0313,x			and 	XS2_Type,x
.01892e	4a		lsr a				lsr 	a 							; shift bit 0 into C
.01892f	90 03		bcc $018934			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018931	4c 77 89	jmp $018977			jmp 	AddInteger32 							; so execute code at \1
.018934					_BCFloat:
.018934	20 c3 89	jsr $0189c3			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018937	4c 01 91	jmp $019101			jmp 	FPAdd 							; and execute code at \2
.01893a	60		rts				rts
.01893b					_BOAString:
.01893b	4c de 89	jmp $0189de			jmp 	ConcatenateString 			; concatenate two strings.
.01893e					BinaryOp_Subtract:
.01893e	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018941	3d 13 03	and $0313,x			and 	XS2_Type,x
.018944	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018945	90 03		bcc $01894a			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018947	4c 9d 89	jmp $01899d			jmp 	SubInteger32 							; so execute code at \1
.01894a					_BCFloat:
.01894a	20 c3 89	jsr $0189c3			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.01894d	4c f7 90	jmp $0190f7			jmp 	FPSubtract 							; and execute code at \2
.018950	60		rts				rts
.018951					BinaryOp_Multiply:
.018951	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018954	3d 13 03	and $0313,x			and 	XS2_Type,x
.018957	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018958	90 03		bcc $01895d			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.01895a	4c 83 8e	jmp $018e83			jmp 	MulInteger32 							; so execute code at \1
.01895d					_BCFloat:
.01895d	20 c3 89	jsr $0189c3			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018960	4c 6d 92	jmp $01926d			jmp 	FPMultiply 							; and execute code at \2
.018963	60		rts				rts
.018964					BinaryOp_Divide:
.018964	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018967	3d 13 03	and $0313,x			and 	XS2_Type,x
.01896a	4a		lsr a				lsr 	a 							; shift bit 0 into C
.01896b	90 03		bcc $018970			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.01896d	4c da 8e	jmp $018eda			jmp 	DivInteger32 							; so execute code at \1
.018970					_BCFloat:
.018970	20 c3 89	jsr $0189c3			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018973	4c e5 91	jmp $0191e5			jmp 	FPDivide 							; and execute code at \2
.018976	60		rts				rts
.018977					AddInteger32:
.018977	18		clc				clc
.018978	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.01897b	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.01897e	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018981	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018984	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.018987	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.01898a	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.01898d	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.018990	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018993	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.018996	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.018999	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.01899c	60		rts				rts
.01899d					SubInteger32:
.01899d	38		sec				sec
.01899e	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.0189a1	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.0189a4	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0189a7	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0189aa	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.0189ad	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0189b0	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.0189b3	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.0189b6	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0189b9	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.0189bc	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.0189bf	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0189c2	60		rts				rts
.0189c3					BinaryMakeBothFloat:
.0189c3	da		phx				phx 								; save X
.0189c4	e8		inx				inx
.0189c5	e8		inx				inx
.0189c6	e8		inx				inx
.0189c7	e8		inx				inx
.0189c8	e8		inx				inx
.0189c9	e8		inx				inx
.0189ca	20 ce 89	jsr $0189ce			jsr 	BinaryMakeFloat 			; convert to float.
.0189cd	fa		plx				plx 								; restore X and fall through.
.0189ce					BinaryMakeFloat:
.0189ce	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type byte.
.0189d1	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.0189d2	b0 04		bcs $0189d8			bcs 	_BMFConvert
.0189d4	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.0189d5	b0 04		bcs $0189db			bcs 	_BMFError
.0189d7	60		rts				rts
.0189d8					_BMFConvert:
.0189d8	4c 1f 94	jmp $01941f			jmp 	FPUToFloat 					; convert to float
.0189db					_BMFError:
.0189db	4c 07 82	jmp $018207			jmp 	TypeError
.0189de					ConcatenateString:
.0189de	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.0189e1	85 1a		sta $1a				sta		zLTemp1+0
.0189e3	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0189e6	85 1b		sta $1b				sta 	zLTemp1+1
.0189e8	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x
.0189eb	85 1c		sta $1c				sta 	zLTemp1+2
.0189ed	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.0189f0	85 1d		sta $1d				sta 	zLTemp1+3
.0189f2	5a		phy				phy
.0189f3	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.0189f5	b1 1a		lda ($1a),y			lda 	(zlTemp1),y
.0189f7	71 1c		adc ($1c),y			adc 	(zlTemp1+2),y
.0189f9	7a		ply				ply
.0189fa	b0 37		bcs $018a33			bcs 	_CSError					; check in range.
.0189fc	c9 fe		cmp #$fe			cmp 	#maxString+1
.0189fe	b0 33		bcs $018a33			bcs 	_CSError
.018a00	20 22 8e	jsr $018e22			jsr 	AllocateTempString 			; store the result
.018a03	20 1e 8a	jsr $018a1e			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.018a06	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.018a09	85 1a		sta $1a				sta 	zLTemp1
.018a0b	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.018a0e	85 1b		sta $1b				sta 	zLTemp1+1
.018a10	20 1e 8a	jsr $018a1e			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.018a13	a5 20		lda $20				lda 	zTempStr 					; point current to new string
.018a15	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018a18	a5 21		lda $21				lda 	zTempStr+1
.018a1a	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018a1d	60		rts				rts
.018a1e					_CSCopyString:
.018a1e	da		phx				phx
.018a1f	5a		phy				phy
.018a20	a0 00		ldy #$00			ldy 	#0 							; get length
.018a22	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.018a24	f0 0a		beq $018a30			beq 	_CSCSExit 					; if zero, exit
.018a26	aa		tax				tax 								; put in X
.018a27					_CSCSLoop:
.018a27	c8		iny				iny 								; get next char
.018a28	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.018a2a	20 4d 8e	jsr $018e4d			jsr		WriteTempString 			; copy out
.018a2d	ca		dex				dex 								; do whole string
.018a2e	d0 f7		bne $018a27			bne 	_CSCSLoop
.018a30					_CSCSExit:
.018a30	7a		ply				ply
.018a31	fa		plx				plx
.018a32	60		rts				rts
.018a33					_CSError:
.018a33	20 26 82	jsr $018226			jsr ERR_Handler
>018a36	53 74 72 69 6e 67 20 74			.text "String too long",0
>018a3e	6f 6f 20 6c 6f 6e 67 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.018a46					Unary_Sgn:
.018a46	20 83 87	jsr $018783			jsr 	EvaluateNumberX 			; get value
.018a49	20 12 8e	jsr $018e12			jsr 	CheckNextRParen 			; check right bracket.
.018a4c	20 70 8a	jsr $018a70			jsr 	GetSignCurrent 				; get sign.
.018a4f	09 00		ora #$00			ora 	#0
.018a51	10 09		bpl $018a5c			bpl		UnarySetAInteger			; if 0,1 return that.
.018a53	80 00		bra $018a55			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.018a55					UnarySetAMinus1:
.018a55	a9 ff		lda #$ff			lda 	#$FF
.018a57	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.018a5a	80 05		bra $018a61			bra 	UnarySetAFill
.018a5c					UnarySetAInteger:
.018a5c	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.018a5f	a9 00		lda #$00			lda 	#0
.018a61					UnarySetAFill:
.018a61	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018a64	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018a67	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018a6a	a9 01		lda #$01			lda 	#1
.018a6c	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018a6f	60		rts				rts
.018a70					GetSignCurrent:
.018a70	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; identify type.
.018a73	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.018a74	90 19		bcc $018a8f			bcc 	_GSCFloat
.018a76	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.018a79	30 11		bmi $018a8c			bmi 	_GSCMinus1
.018a7b	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x
.018a7e	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.018a81	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.018a84	d0 03		bne $018a89			bne 	_GSCPlus1
.018a86					_GSCZero:
.018a86	a9 00		lda #$00			lda 	#0
.018a88	60		rts				rts
.018a89					_GSCPlus1:
.018a89	a9 01		lda #$01			lda 	#$01
.018a8b	60		rts				rts
.018a8c					_GSCMinus1:
.018a8c	a9 ff		lda #$ff			lda 	#$FF
.018a8e	60		rts				rts
.018a8f					_GSCFloat:
.018a8f	3c 0d 03	bit $030d,x			bit 	XS_Type,x
.018a92	70 f2		bvs $018a86			bvs 	_GSCZero
.018a94	30 f6		bmi $018a8c			bmi 	_GSCMinus1
.018a96	80 f1		bra $018a89			bra 	_GSCPlus1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.018a98					Unary_Abs:
.018a98	20 83 87	jsr $018783			jsr 	EvaluateNumberX 			; get value
.018a9b	20 12 8e	jsr $018e12			jsr 	CheckNextRParen 			; check right bracket.
.018a9e	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.018aa1	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.018aa3	f0 08		beq $018aad			beq 	_UAMinusFloat
.018aa5	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; check MSB
.018aa8	10 0b		bpl $018ab5			bpl 	_UAExit
.018aaa	4c 70 8f	jmp $018f70			jmp 	IntegerNegateAlways 		; negation
.018aad					_UAMinusFloat:
.018aad	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; clear the sign bit.
.018ab0	29 7f		and #$7f			and		#$7F
.018ab2	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018ab5					_UAExit:
.018ab5	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.018ab6					Unary_Peek:
.018ab6	a9 01		lda #$01			lda 	#1
.018ab8	80 06		bra $018ac0			bra 	UPMain
.018aba					Unary_Deek:
.018aba	a9 02		lda #$02			lda 	#2
.018abc	80 02		bra $018ac0			bra 	UPMain
.018abe					Unary_Leek:
.018abe	a9 04		lda #$04			lda 	#4
.018ac0					UPMain:
.018ac0	48		pha				pha 								; set bytes to copy.
.018ac1	20 92 87	jsr $018792			jsr 	EvaluateIntegerX 			; numeric parameter
.018ac4	20 12 8e	jsr $018e12			jsr 	CheckNextRParen 			; right bracket.
.018ac7	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.018aca	85 1a		sta $1a				sta 	zLTemp1
.018acc	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018acf	85 1b		sta $1b				sta 	zLTemp1+1
.018ad1	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018ad4	85 1c		sta $1c				sta 	zLTemp1+2
.018ad6	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.018ad9	85 1d		sta $1d				sta 	zLTemp1+3
.018adb	a9 00		lda #$00			lda 	#0 							; clear target area
.018add	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018ae0	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018ae3	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018ae6	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018ae9	68		pla				pla 								; restore bytes to copy
.018aea	da		phx				phx 								; save XY
.018aeb	5a		phy				phy
.018aec	20 e9 8d	jsr $018de9			jsr 	MemRead 					; read the bytes in
.018aef	7a		ply				ply 								; restore and exit
.018af0	fa		plx				plx
.018af1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.018af2					Unary_Mod:
.018af2	20 1e 8b	jsr $018b1e			jsr 	_UMParameter 				; first parameter
.018af5	20 1a 8e	jsr $018e1a			jsr 	CheckNextComma
.018af8	da		phx				phx 								; second parameter
.018af9	e8		inx				inx
.018afa	e8		inx				inx
.018afb	e8		inx				inx
.018afc	e8		inx				inx
.018afd	e8		inx				inx
.018afe	e8		inx				inx
.018aff	20 1e 8b	jsr $018b1e			jsr 	_UMParameter
.018b02	fa		plx				plx
.018b03	20 12 8e	jsr $018e12			jsr 	CheckNextRParen
.018b06	20 da 8e	jsr $018eda			jsr 	DivInteger32 				; divide
.018b09	a5 1a		lda $1a				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.018b0b	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018b0e	a5 1b		lda $1b				lda 	zLTemp1+1
.018b10	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018b13	a5 1c		lda $1c				lda 	zLTemp1+2
.018b15	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018b18	a5 1d		lda $1d				lda 	zLTemp1+3
.018b1a	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018b1d	60		rts				rts
.018b1e					_UMParameter:
.018b1e	20 92 87	jsr $018792			jsr 	EvaluateIntegerX 			; get value
.018b21	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; absolute value
.018b24	10 03		bpl $018b29			bpl 	_UMNotSigned
.018b26	20 70 8f	jsr $018f70			jsr 	IntegerNegateAlways
.018b29					_UMNotSigned:
.018b29	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.018b2a					Unary_Usr:
.018b2a	20 83 87	jsr $018783			jsr 	EvaluateNumberX 			; numeric parameter
.018b2d	20 12 8e	jsr $018e12			jsr 	CheckNextRParen 			; right bracket.
.018b30	da		phx				phx 								; save XY
.018b31	5a		phy				phy
.018b32	ea		nop				nop
.018b33	22 00 03 00	jsl $000300			jsl 	UserVector
.018b37	7a		ply				ply 								; and exit
.018b38	fa		plx				plx
.018b39	60		rts				rts
.018b3a					USRDefault:
.018b3a	20 26 82	jsr $018226			jsr ERR_Handler
>018b3d	4e 6f 20 55 53 52 20 76			.text "No USR vector.",0
>018b45	65 63 74 6f 72 2e 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.018b4c					Unary_Val:
.018b4c	20 9b 87	jsr $01879b			jsr 	EvaluateStringX 			; get string
.018b4f	20 12 8e	jsr $018e12			jsr 	CheckNextRParen 			; check right bracket.
.018b52	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.018b55	85 1e		sta $1e				sta 	zGenPtr
.018b57	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018b5a	85 1f		sta $1f				sta 	zGenPtr+1
.018b5c	5a		phy				phy
.018b5d	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.018b5f	b1 1e		lda ($1e),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.018b61	f0 57		beq $018bba			beq 	_UVBadNumber
.018b63	48		pha				pha 								; save length.
.018b64	1a		inc a				inc 	a 							; one for the length, one for the terminator
.018b65	1a		inc a				inc 	a
.018b66	20 22 8e	jsr $018e22			jsr 	AllocateTempString
.018b69	c8		iny				iny 								; move to the next.
.018b6a	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get character
.018b6c	49 2d		eor #$2d			eor 	#"-"						; zero if minus sign
.018b6e	8d 29 04	sta $0429			sta 	ValSign
.018b71	d0 04		bne $018b77			bne 	_UVNotMinus
.018b73	c8		iny				iny 								; skip over it.
.018b74	68		pla				pla 								; decrement character count.
.018b75	3a		dec a				dec 	a
.018b76	48		pha				pha
.018b77					_UVNotMinus:
.018b77	68		pla				pla 								; this is the count.
.018b78	48		pha		_UVCopy:pha									; copy into new temp string which is ASCIIZ
.018b79	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018b7b	c8		iny				iny
.018b7c	20 4d 8e	jsr $018e4d			jsr 	WriteTempString
.018b7f	68		pla				pla
.018b80	3a		dec a				dec 	a
.018b81	d0 f5		bne $018b78			bne 	_UVCopy
.018b83	20 4d 8e	jsr $018e4d			jsr 	WriteTempString 			; make it ASCIIZ
.018b86	18		clc				clc
.018b87	a5 20		lda $20				lda 	zTempStr 					; tempstring +1 => genptr
.018b89	69 01		adc #$01			adc 	#1
.018b8b	85 1e		sta $1e				sta 	zGenPtr
.018b8d	a5 21		lda $21				lda 	zTempStr+1
.018b8f	69 00		adc #$00			adc 	#0
.018b91	85 1f		sta $1f				sta 	zGenPtr+1
.018b93	18		clc				clc
.018b94	20 4c 90	jsr $01904c			jsr 	IntFromString 				; first bit.
.018b97	b0 21		bcs $018bba			bcs 	_UVBadNumber
.018b99	20 70 96	jsr $019670			jsr 	FPFromString				; try for a float part.
.018b9c	ad 29 04	lda $0429			lda 	ValSign 					; was it negative
.018b9f	d0 13		bne $018bb4			bne 	_UVNotNegative
.018ba1	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; check if integer
.018ba4	4a		lsr a				lsr 	a
.018ba5	b0 0a		bcs $018bb1			bcs 	_UVInteger
.018ba7	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; set sign bit
.018baa	09 80		ora #$80			ora 	#$80
.018bac	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018baf	80 03		bra $018bb4			bra 	_UVNotNegative
.018bb1					_UVInteger:
.018bb1	20 70 8f	jsr $018f70			jsr 	IntegerNegateAlways 		; sign it.
.018bb4					_UVNotNegative:
.018bb4	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; used everything
.018bb6	d0 02		bne $018bba			bne 	_UVBadNumber
.018bb8	7a		ply				ply
.018bb9	60		rts				rts
.018bba					_UVBadNumber:
.018bba	4c 15 82	jmp $018215			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.018bbd					Unary_Str:
.018bbd	20 83 87	jsr $018783			jsr 	EvaluateNumberX 			; numeric parameter
.018bc0	20 12 8e	jsr $018e12			jsr 	CheckNextRParen 			; right bracket.
.018bc3	a9 00		lda #$00			lda 	#0 							; reset buffer index
.018bc5	8d 00 04	sta $0400			sta 	NumBufX
.018bc8	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.018bcb	4a		lsr a				lsr 	a
.018bcc	b0 05		bcs $018bd3			bcs 	_USInt 						; if msb set do as integer
.018bce	20 a9 95	jsr $0195a9			jsr 	FPToString 					; call fp to str otherwise
.018bd1	80 03		bra $018bd6			bra 	_USDuplicate
.018bd3	20 95 8f	jsr $018f95	_USInt:	jsr 	IntToString
.018bd6					_USDuplicate:
.018bd6	ad 00 04	lda $0400			lda 	NumBufX 					; chars in buffer
.018bd9	1a		inc a				inc 	a 							; one more for length
.018bda	20 22 8e	jsr $018e22			jsr 	AllocateTempString 			; allocate space for it.
.018bdd	5a		phy				phy 								; save Y
.018bde	a0 00		ldy #$00			ldy 	#0 							; start copying
.018be0	b9 01 04	lda $0401,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.018be3	20 4d 8e	jsr $018e4d			jsr 	WriteTempString
.018be6	c8		iny				iny
.018be7	cc 00 04	cpy $0400			cpy 	NumBufX 					; done the lot
.018bea	d0 f4		bne $018be0			bne 	_USCopy
.018bec	7a		ply				ply 								; restore Y
.018bed	4c d9 8d	jmp $018dd9			jmp 	UnaryReturnTempStr 			; return new temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.018bf0					Unary_Asc:
.018bf0	20 9b 87	jsr $01879b			jsr 	EvaluateStringX 			; string parameter
.018bf3	20 12 8e	jsr $018e12			jsr 	CheckNextRParen 			; right bracket.
.018bf6	5a		phy				phy 								; get the string length
.018bf7	a0 00		ldy #$00			ldy 	#0
.018bf9	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018bfb	f0 07		beq $018c04			beq 	_UAIllegal 					; must be at least one character
.018bfd	c8		iny				iny
.018bfe	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; read it.
.018c00	7a		ply				ply
.018c01	4c 5c 8a	jmp $018a5c			jmp 	UnarySetAInteger
.018c04					_UAIllegal:
.018c04	4c 15 82	jmp $018215			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.018c07					Unary_Len:
.018c07	20 9b 87	jsr $01879b			jsr 	EvaluateStringX 			; string parameter
.018c0a	20 12 8e	jsr $018e12			jsr 	CheckNextRParen 			; right bracket.
.018c0d	5a		phy				phy 								; get the string length
.018c0e	a0 00		ldy #$00			ldy 	#0
.018c10	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018c12	7a		ply				ply
.018c13	4c 5c 8a	jmp $018a5c			jmp 	UnarySetAInteger

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.018c16					Unary_Mid:
.018c16	20 9b 87	jsr $01879b			jsr 	EvaluateStringX 				; get string.
.018c19	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.018c1c	48		pha				pha
.018c1d	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018c20	48		pha				pha
.018c21	20 1a 8e	jsr $018e1a			jsr 	CheckNextComma 					; skip comma
.018c24	20 b1 8c	jsr $018cb1			jsr 	SLIByteParameter 				; get a byte parameter (start)
.018c27	48		pha				pha 									; and push it.
.018c28	20 1a 8e	jsr $018e1a			jsr 	CheckNextComma 					; skip comma
.018c2b	20 b1 8c	jsr $018cb1			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.018c2e	48		pha				pha 									; and push it.
.018c2f	80 45		bra $018c76			bra 	SLIProcess
.018c31					Unary_Left:
.018c31	20 9b 87	jsr $01879b			jsr 	EvaluateStringX 				; get string.
.018c34	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.018c37	48		pha				pha
.018c38	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018c3b	48		pha				pha
.018c3c	a9 01		lda #$01			lda 	#1 								; push start position (1)
.018c3e	48		pha				pha
.018c3f	20 1a 8e	jsr $018e1a			jsr 	CheckNextComma 					; skip comma
.018c42	20 b1 8c	jsr $018cb1			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.018c45	48		pha				pha 									; and push it.
.018c46	80 2e		bra $018c76			bra 	SLIProcess
.018c48					Unary_Right:
.018c48	20 9b 87	jsr $01879b			jsr 	EvaluateStringX 				; get string.
.018c4b	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.018c4e	48		pha				pha
.018c4f	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018c52	48		pha				pha
.018c53	da		phx				phx 									; get the string length and push on stack.
.018c54	a2 00		ldx #$00			ldx 	#0
.018c56	a1 1e		lda ($1e,x)			lda		(zGenPtr,x)
.018c58	fa		plx				plx
.018c59	48		pha				pha
.018c5a	20 1a 8e	jsr $018e1a			jsr 	CheckNextComma 					; skip comma
.018c5d	20 b1 8c	jsr $018cb1			jsr 	SLIByteParameter 				; get a byte parameter.
.018c60	8d 25 04	sta $0425			sta 	SignCount 						; save in temporary.
.018c63	68		pla				pla 									; restore string length.
.018c64	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.018c65	38		sec				sec
.018c66	ed 25 04	sbc $0425			sbc 	SignCount 						; subtract characters needed, gives start position.
.018c69	f0 02		beq $018c6d			beq 	_URStart 						; if <= 0 start from 1.
.018c6b	10 02		bpl $018c6f			bpl 	_UROkay
.018c6d					_URStart:
.018c6d	a9 01		lda #$01			lda 	#1
.018c6f					_UROkay:
.018c6f	48		pha				pha 									; push start
.018c70	ad 25 04	lda $0425			lda 	SignCount 						; push count of characters
.018c73	48		pha				pha
.018c74	80 00		bra $018c76			bra 	SLIProcess
.018c76					SLIProcess:
.018c76	20 12 8e	jsr $018e12			jsr 	CheckNextRParen 				; closing right bracket.
.018c79	68		pla				pla
.018c7a	8d 2b 04	sta $042b			sta 	SliceCount 						; count in signcount
.018c7d	1a		inc a				inc 	a 								; allocate +1 for it.
.018c7e	20 22 8e	jsr $018e22			jsr 	AllocateTempString
.018c81	68		pla				pla 									; pop start number off stack.
.018c82	f0 3f		beq $018cc3			beq 	SLIError 						; exit if start = 0
.018c84	8d 2a 04	sta $042a			sta 	SliceStart
.018c87	68		pla				pla  									; pop string address.
.018c88	85 1f		sta $1f				sta 	zGenPtr+1
.018c8a	68		pla				pla
.018c8b	85 1e		sta $1e				sta 	zGenPtr
.018c8d	da		phx				phx
.018c8e	5a		phy				phy
.018c8f	a2 00		ldx #$00			ldx 	#0 								; point to string length.
.018c91	ac 2a 04	ldy $042a			ldy 	SliceStart 						; start of the string (+1 for count)
.018c94					_SLICopy:
.018c94	ad 2b 04	lda $042b			lda 	SliceCount 						; done count characters
.018c97	f0 12		beq $018cab			beq 	_SLIExit
.018c99	ce 2b 04	dec $042b			dec 	SliceCount
.018c9c	98		tya				tya 									; index of character
.018c9d	c1 1e		cmp ($1e,x)			cmp 	(zGenPtr,x)						; compare against length
.018c9f	f0 02		beq $018ca3			beq 	_SLIOk 							; if equal, okay.
.018ca1	b0 08		bcs $018cab			bcs 	_SLIExit 						; if past end, then exit.
.018ca3	b1 1e		lda ($1e),y	_SLIOk:	lda 	(zGenPtr),y 					; copy one character
.018ca5	c8		iny				iny
.018ca6	20 4d 8e	jsr $018e4d			jsr 	WriteTempString
.018ca9	80 e9		bra $018c94			bra 	_SLICopy 						; go round till copied characters
.018cab					_SLIExit:
.018cab	7a		ply				ply 									; restore YX
.018cac	fa		plx				plx
.018cad	4c d9 8d	jmp $018dd9			jmp 	UnaryReturnTempStr 				; return new temporary string.
.018cb0	ea		nop				nop
.018cb1					SLIByteParameter:
.018cb1	20 92 87	jsr $018792			jsr 	EvaluateIntegerX 				; get integer
.018cb4	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.018cb7	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.018cba	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.018cbd	d0 04		bne $018cc3			bne 	SLIError
.018cbf	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018cc2	60		rts				rts
.018cc3					SLIError:
.018cc3	4c 15 82	jmp $018215			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.018cc6					Unary_Hex:
.018cc6	20 92 87	jsr $018792			jsr 	EvaluateIntegerX 			; numeric parameter
.018cc9	20 12 8e	jsr $018e12			jsr 	CheckNextRParen 			; right bracket.
.018ccc	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.018cce	20 22 8e	jsr $018e22			jsr 	AllocateTempString			; allocate string space
.018cd1	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.018cd4	20 fb 8c	jsr $018cfb			jsr 	_UHConvert
.018cd7	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018cda	20 fb 8c	jsr $018cfb			jsr 	_UHConvert
.018cdd	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018ce0	20 fb 8c	jsr $018cfb			jsr 	_UHConvert
.018ce3	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018ce6	20 fb 8c	jsr $018cfb			jsr 	_UHConvert
.018ce9	5a		phy				phy 								; get length of new string
.018cea	a0 00		ldy #$00			ldy 	#0
.018cec	b1 20		lda ($20),y			lda 	(zTempStr),y
.018cee	7a		ply				ply
.018cef	c9 00		cmp #$00			cmp 	#0
.018cf1	d0 05		bne $018cf8			bne 	_UHExit 					; if it was non zero okay
.018cf3	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.018cf5	20 4d 8e	jsr $018e4d			jsr 	WriteTempString
.018cf8					_UHExit:
.018cf8	4c d9 8d	jmp $018dd9			jmp 	UnaryReturnTempStr 			; return new temporary string.
.018cfb					_UHConvert:
.018cfb	48		pha				pha
.018cfc	4a		lsr a				lsr 	a 							; do MSB
.018cfd	4a		lsr a				lsr 	a
.018cfe	4a		lsr a				lsr 	a
.018cff	4a		lsr a				lsr 	a
.018d00	20 04 8d	jsr $018d04			jsr 	_UHNibble
.018d03	68		pla				pla 								; do LSB
.018d04					_UHNibble:
.018d04	29 0f		and #$0f			and 	#15 						; get nibble
.018d06	d0 0c		bne $018d14			bne 	_UHNonZero
.018d08	5a		phy				phy									; get the length
.018d09	a0 00		ldy #$00			ldy 	#0
.018d0b	b1 20		lda ($20),y			lda 	(zTempStr),y
.018d0d	7a		ply				ply
.018d0e	c9 00		cmp #$00			cmp 	#0 							; suppress leading zeros.
.018d10	f0 0d		beq $018d1f			beq 	_UHExit2
.018d12	a9 00		lda #$00			lda 	#0
.018d14					_UHNonZero:
.018d14	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.018d16	90 02		bcc $018d1a			bcc 	_UHDigit
.018d18	69 06		adc #$06			adc 	#7-1
.018d1a					_UHDigit:
.018d1a	69 30		adc #$30			adc 	#48
.018d1c	20 4d 8e	jsr $018e4d			jsr 	WriteTempString				; output.
.018d1f					_UHExit2:
.018d1f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.018d20					Unary_Dec:
.018d20	20 9b 87	jsr $01879b			jsr 	EvaluateStringX 			; string parameter
.018d23	20 12 8e	jsr $018e12			jsr 	CheckNextRParen 			; right bracket.
.018d26	5a		phy				phy
.018d27	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.018d29	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018d2b	f0 4c		beq $018d79			beq 	_UDFail 					; must fail if zero.
.018d2d	8d 25 04	sta $0425			sta 	SignCount 					; use SignCount as a counter
.018d30	a9 00		lda #$00			lda 	#0 							; set result to zero integer.
.018d32	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018d35	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018d38	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018d3b	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018d3e	a9 01		lda #$01			lda 	#1
.018d40	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018d43					_UDConvertLoop:
.018d43	5a		phy				phy 								; shift mantissa left 4
.018d44	a0 04		ldy #$04			ldy 	#4
.018d46					_UDShift:
.018d46	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x
.018d49	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.018d4c	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.018d4f	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.018d52	88		dey				dey
.018d53	d0 f1		bne $018d46			bne 	_UDShift
.018d55	7a		ply				ply
.018d56	c8		iny				iny 								; next character
.018d57	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; fetch it.
.018d59	20 7c 8d	jsr $018d7c			jsr 	ConvertUpper 				; convert to U/C
.018d5c	c9 30		cmp #$30			cmp 	#"0"
.018d5e	90 19		bcc $018d79			bcc 	_UDFail
.018d60	c9 3a		cmp #$3a			cmp 	#"9"+1
.018d62	90 06		bcc $018d6a			bcc 	_UDOkay
.018d64	e9 37		sbc #$37			sbc 	#7+"0" 						; alpha fudge
.018d66	c9 10		cmp #$10			cmp 	#16
.018d68	b0 0f		bcs $018d79			bcs 	_UDFail
.018d6a					_UDOkay:
.018d6a	29 0f		and #$0f			and 	#15 						; nibble only
.018d6c	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x
.018d6f	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018d72	ce 25 04	dec $0425			dec 	SignCount 					; do it for each character
.018d75	d0 cc		bne $018d43			bne 	_UDConvertLoop
.018d77	7a		ply				ply
.018d78	60		rts				rts
.018d79					_UDFail:
.018d79	4c 15 82	jmp $018215			jmp 	BadParamError
.018d7c					ConvertUpper:
.018d7c	c9 61		cmp #$61			cmp 	#"a"
.018d7e	90 07		bcc $018d87			bcc 	_CUExit
.018d80	c9 7b		cmp #$7b			cmp 	#"z"+1
.018d82	b0 03		bcs $018d87			bcs 	_CUExit
.018d84	38		sec				sec
.018d85	e9 20		sbc #$20			sbc 	#32
.018d87	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.018d88					Unary_Chr:
.018d88	20 92 87	jsr $018792			jsr 	EvaluateIntegerX			; numeric parameter
.018d8b	20 12 8e	jsr $018e12			jsr 	CheckNextRParen 			; right bracket.
.018d8e	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.018d91	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.018d94	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.018d97	d0 0e		bne $018da7			bne 	_UCChar
.018d99	a9 01		lda #$01			lda 	#1 							; one character string
.018d9b	20 22 8e	jsr $018e22			jsr 	AllocateTempString
.018d9e	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.018da1	20 4d 8e	jsr $018e4d			jsr 	WriteTempString
.018da4	4c d9 8d	jmp $018dd9			jmp 	UnaryReturnTempStr
.018da7					_UCChar:
.018da7	4c 15 82	jmp $018215			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.018daa					Unary_Spc:
.018daa	20 92 87	jsr $018792			jsr 	EvaluateIntegerX 			; numeric parameter
.018dad	20 12 8e	jsr $018e12			jsr 	CheckNextRParen 			; right bracket.
.018db0	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.018db3	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.018db6	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.018db9	d0 1b		bne $018dd6			bne 	_USSize
.018dbb	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018dbe	c9 fe		cmp #$fe			cmp 	#maxString+1
.018dc0	b0 14		bcs $018dd6			bcs 	_USSize
.018dc2	48		pha				pha 								; save length
.018dc3	1a		inc a				inc 	a 							; allocate one more.
.018dc4	20 22 8e	jsr $018e22			jsr 	AllocateTempString
.018dc7	68		pla				pla 								; get length
.018dc8	f0 0f		beq $018dd9			beq 	UnaryReturnTempStr 			; return the current temp string
.018dca					_USLoop:
.018dca	48		pha				pha
.018dcb	a9 20		lda #$20			lda 	#" "
.018dcd	20 4d 8e	jsr $018e4d			jsr 	WriteTempString
.018dd0	68		pla				pla
.018dd1	3a		dec a				dec 	a
.018dd2	d0 f6		bne $018dca			bne 	_USLoop
.018dd4	80 03		bra $018dd9			bra 	UnaryReturnTempStr
.018dd6					_USSize:
.018dd6	4c 15 82	jmp $018215			jmp 	BadParamError
.018dd9					UnaryReturnTempStr:
.018dd9	a5 20		lda $20				lda 	zTempStr 					; copy temp string addr -> mantissa
.018ddb	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018dde	a5 21		lda $21				lda 	zTempStr+1
.018de0	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018de3	a9 02		lda #$02			lda 	#2 							; set type to string
.018de5	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018de8	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/65816.asm

.018de9					MemRead:
.018de9	8d 25 04	sta $0425			sta 	SignCount 					; save count
.018dec	a0 00		ldy #$00			ldy 	#0 							; start from here
.018dee	b7 1a		lda [$1a],y	_MLoop1:lda 	[zlTemp1],y 				; read the long address
.018df0	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; copy into mantissa
.018df3	c8		iny				iny 								; next to copy
.018df4	e8		inx				inx
.018df5	cc 25 04	cpy $0425			cpy 	SignCount 					; do required # of bytes.
.018df8	d0 f4		bne $018dee			bne 	_MLoop1
.018dfa	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.018dfb					CheckNextToken:
.018dfb	d7 16		cmp [$16],y			cmp 	[zCodePtr],y
.018dfd	d0 02		bne $018e01			bne 	CTFail 						; no, then fail
.018dff	c8		iny				iny
.018e00	60		rts				rts
.018e01					CTFail:
.018e01	20 26 82	jsr $018226			jsr ERR_Handler
>018e04	4d 69 73 73 69 6e 67 20			.text "Missing token",0
>018e0c	74 6f 6b 65 6e 00
.018e12					CheckNextRParen:
.018e12	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e14	c9 bc		cmp #$bc			cmp 	#token_rparen
.018e16	d0 e9		bne $018e01			bne 	CTFail
.018e18	c8		iny				iny
.018e19	60		rts				rts
.018e1a					CheckNextComma:
.018e1a	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e1c	c9 bd		cmp #$bd			cmp 	#token_comma
.018e1e	d0 e1		bne $018e01			bne 	CTFail
.018e20	c8		iny				iny
.018e21	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.018e22					AllocateTempString:
.018e22	48		pha				pha 								; save required count.
.018e23	a5 21		lda $21				lda 	zTempStr+1 					; check if initialised yet ?
.018e25	d0 0b		bne $018e32			bne 	_ATSInitialised
.018e27	ad 26 04	lda $0426			lda 	StringPtr 					; set temporary string ptr 1 page below available
.018e2a	85 20		sta $20				sta 	zTempStr					; space, this is for strings to be concreted.
.018e2c	ad 27 04	lda $0427			lda 	StringPtr+1
.018e2f	3a		dec a				dec 	a
.018e30	85 21		sta $21				sta 	zTempStr+1
.018e32					_ATSInitialised:
.018e32	68		pla				pla 								; get required count back.
.018e33	49 ff		eor #$ff			eor 	#$FF 						; negate 2's complement.
.018e35	1a		inc a				inc 	a
.018e36	18		clc				clc
.018e37	65 20		adc $20				adc 	zTempStr 					; "add" to the temp string pointer
.018e39	85 20		sta $20				sta 	zTempStr
.018e3b	a9 ff		lda #$ff			lda 	#$FF
.018e3d	65 21		adc $21				adc 	zTempStr+1
.018e3f	85 21		sta $21				sta 	zTempStr+1
.018e41	a9 00		lda #$00			lda 	#0 							; clear temp string.
.018e43	5a		phy				phy
.018e44	a8		tay				tay
.018e45	91 20		sta ($20),y			sta 	(zTempStr),y
.018e47	7a		ply				ply
.018e48	1a		inc a				inc 	a 							; reset the write index.
.018e49	8d 28 04	sta $0428			sta 	TempStringWriteIndex
.018e4c	60		rts				rts
.018e4d					WriteTempString:
.018e4d	5a		phy				phy 								; save Y
.018e4e	ac 28 04	ldy $0428			ldy 	TempStringWriteIndex	 	; write position.
.018e51	91 20		sta ($20),y			sta 	(zTempStr),y 				; write character out.
.018e53	ee 28 04	inc $0428			inc 	TempStringWriteIndex 		; increment the write position.
.018e56	98		tya				tya 								; unchanged Y is now length
.018e57	a0 00		ldy #$00			ldy 	#0
.018e59	91 20		sta ($20),y			sta 	(zTempStr),y
.018e5b	7a		ply				ply 								; restore Y and exit
.018e5c	60		rts				rts
.018e5d					CreateTempStringCopy:
.018e5d	da		phx				phx 								; save X
.018e5e	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e60	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.018e61	20 22 8e	jsr $018e22			jsr 	AllocateTempString 			; allocate memory for temporary string.
.018e64	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e66	c8		iny				iny
.018e67	3a		dec a				dec 	a 							; make the actual length in charactes
.018e68	3a		dec a				dec 	a
.018e69	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.018e6b	81 20		sta ($20,x)			sta 	(zTempStr,x)
.018e6d	85 1a		sta $1a				sta 	zLTemp1 					; that's used as a count.
.018e6f	09 00		ora #$00			ora 	#0 							; if zero already, exit
.018e71	f0 0e		beq $018e81			beq 	_CTSCExit
.018e73					_CTSCLoop:
.018e73	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e75	c8		iny				iny
.018e76	5a		phy				phy 								; save in Y
.018e77	e8		inx				inx 								; bump index
.018e78	da		phx				phx 								; index into Y
.018e79	7a		ply				ply
.018e7a	91 20		sta ($20),y			sta 	(zTempStr),y 				; save at index
.018e7c	7a		ply				ply 								; restore Y
.018e7d	c6 1a		dec $1a				dec 	zLTemp1 					; do for each character
.018e7f	d0 f2		bne $018e73			bne 	_CTSCLoop
.018e81					_CTSCExit:
.018e81	fa		plx				plx 								; restore X
.018e82	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.018e83					MulInteger32:
.018e83	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.018e86	9d 14 03	sta $0314,x			sta 	XS3_Mantissa,x
.018e89	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018e8c	9d 15 03	sta $0315,x			sta 	XS3_Mantissa+1,x
.018e8f	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018e92	9d 16 03	sta $0316,x			sta 	XS3_Mantissa+2,x
.018e95	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.018e98	9d 17 03	sta $0317,x			sta 	XS3_Mantissa+3,x
.018e9b	a9 00		lda #$00			lda 	#0
.018e9d	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x 				; zero +0
.018ea0	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018ea3	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018ea6	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018ea9					_BFMMultiply:
.018ea9	bd 14 03	lda $0314,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.018eac	29 01		and #$01			and 	#1
.018eae	f0 03		beq $018eb3			beq 	_BFMNoAdd
.018eb0	20 77 89	jsr $018977			jsr 	AddInteger32
.018eb3					_BFMNoAdd:
.018eb3	1e 0e 03	asl $030e,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.018eb6	3e 0f 03	rol $030f,x			rol 	XS2_Mantissa+1,x
.018eb9	3e 10 03	rol $0310,x			rol 	XS2_Mantissa+2,x
.018ebc	3e 11 03	rol $0311,x			rol 	XS2_Mantissa+3,x
.018ebf	5e 17 03	lsr $0317,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.018ec2	7e 16 03	ror $0316,x			ror 	XS3_Mantissa+2,x
.018ec5	7e 15 03	ror $0315,x			ror 	XS3_Mantissa+1,x
.018ec8	7e 14 03	ror $0314,x			ror 	XS3_Mantissa,x
.018ecb	bd 14 03	lda $0314,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.018ece	1d 15 03	ora $0315,x			ora 	XS3_Mantissa+1,x
.018ed1	1d 16 03	ora $0316,x			ora 	XS3_Mantissa+2,x
.018ed4	1d 17 03	ora $0317,x			ora 	XS3_Mantissa+3,x
.018ed7	d0 d0		bne $018ea9			bne 	_BFMMultiply
.018ed9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.018eda					DivInteger32:
.018eda	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; check for /0
.018edd	1d 0f 03	ora $030f,x			ora 	XS2_Mantissa+1,x
.018ee0	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.018ee3	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.018ee6	d0 14		bne $018efc			bne 	_BFDOkay
.018ee8	20 26 82	jsr $018226			jsr ERR_Handler
>018eeb	44 69 76 69 73 69 6f 6e			.text "Division by Zero",0
>018ef3	20 62 79 20 5a 65 72 6f 00
.018efc					_BFDOkay:
.018efc	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.018efe	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.018f00	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.018f02	85 1c		sta $1c				sta 	zLTemp1+2
.018f04	85 1d		sta $1d				sta 	zLTemp1+3
.018f06	8d 25 04	sta $0425			sta 	SignCount 					; Count of signs.
.018f09	20 6a 8f	jsr $018f6a			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.018f0c	da		phx				phx
.018f0d	e8		inx				inx
.018f0e	e8		inx				inx
.018f0f	e8		inx				inx
.018f10	e8		inx				inx
.018f11	e8		inx				inx
.018f12	e8		inx				inx
.018f13	20 6a 8f	jsr $018f6a			jsr 	CheckIntegerNegate
.018f16	fa		plx				plx
.018f17	5a		phy				phy 								; Y is the counter
.018f18	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.018f1a					_BFDLoop:
.018f1a	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.018f1d	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.018f20	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.018f23	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.018f26	26 1a		rol $1a				rol 	zLTemp1
.018f28	26 1b		rol $1b				rol 	zLTemp1+1
.018f2a	26 1c		rol $1c				rol 	zLTemp1+2
.018f2c	26 1d		rol $1d				rol 	zLTemp1+3
.018f2e	38		sec				sec
.018f2f	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.018f31	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.018f34	48		pha				pha
.018f35	a5 1b		lda $1b				lda 	zLTemp1+1
.018f37	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.018f3a	48		pha				pha
.018f3b	a5 1c		lda $1c				lda 	zLTemp1+2
.018f3d	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.018f40	48		pha				pha
.018f41	a5 1d		lda $1d				lda 	zLTemp1+3
.018f43	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.018f46	90 15		bcc $018f5d			bcc 	_BFDNoAdd
.018f48	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.018f4a	68		pla				pla
.018f4b	85 1c		sta $1c				sta 	zLTemp1+2
.018f4d	68		pla				pla
.018f4e	85 1b		sta $1b				sta 	zLTemp1+1
.018f50	68		pla				pla
.018f51	85 1a		sta $1a				sta 	zLTemp1+0
.018f53	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.018f56	09 01		ora #$01			ora 	#1
.018f58	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018f5b	80 03		bra $018f60			bra 	_BFDNext
.018f5d					_BFDNoAdd:
.018f5d	68		pla				pla 								; Throw away the intermediate calculations
.018f5e	68		pla				pla
.018f5f	68		pla				pla
.018f60					_BFDNext:
.018f60	88		dey				dey
.018f61	d0 b7		bne $018f1a			bne 	_BFDLoop
.018f63	7a		ply				ply 								; restore Y and exit
.018f64	4e 25 04	lsr $0425			lsr 	SignCount 					; if sign count odd,
.018f67	b0 07		bcs $018f70			bcs		IntegerNegateAlways 			; negate the result
.018f69	60		rts				rts
.018f6a					CheckIntegerNegate:
.018f6a	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.018f6d	30 01		bmi $018f70			bmi 	IntegerNegateAlways
.018f6f	60		rts				rts
.018f70					IntegerNegateAlways:
.018f70	ee 25 04	inc $0425			inc 	SignCount
.018f73	38		sec				sec
.018f74	a9 00		lda #$00			lda 	#0
.018f76	fd 08 03	sbc $0308,x			sbc 	XS_Mantissa+0,x
.018f79	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018f7c	a9 00		lda #$00			lda 	#0
.018f7e	fd 09 03	sbc $0309,x			sbc 	XS_Mantissa+1,x
.018f81	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018f84	a9 00		lda #$00			lda 	#0
.018f86	fd 0a 03	sbc $030a,x			sbc 	XS_Mantissa+2,x
.018f89	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018f8c	a9 00		lda #$00			lda 	#0
.018f8e	fd 0b 03	sbc $030b,x			sbc 	XS_Mantissa+3,x
.018f91	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018f94	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.018f95					INTToString:
.018f95	48		pha				pha
.018f96	5a		phy				phy
.018f97	bd 0b 03	lda $030b,x			lda 		XS_Mantissa+3,x 		; check -ve
.018f9a	10 08		bpl $018fa4			bpl 		_ITSNotMinus
.018f9c	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.018f9e	20 39 90	jsr $019039			jsr 		ITSOutputCharacter
.018fa1	20 70 8f	jsr $018f70			jsr 		IntegerNegateAlways 	; negate the number.
.018fa4					_ITSNotMinus:
.018fa4	a9 00		lda #$00			lda 		#0
.018fa6	8d 21 04	sta $0421			sta 		NumSuppress 			; clear the suppression flag.
.018fa9	8a		txa				txa 								; use Y for the mantissa index.
.018faa	a8		tay				tay
.018fab	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.018fad					_ITSNextSubtractor:
.018fad	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.018faf	8d 22 04	sta $0422			sta 		NumConvCount
.018fb2					_ITSSubtract:
.018fb2	38		sec				sec
.018fb3	b9 08 03	lda $0308,y			lda 		XS_Mantissa,y 			; subtract number and push on stack
.018fb6	ff 15 90 01	sbc $019015,x			sbc 		_ITSSubtractors+0,x
.018fba	48		pha				pha
.018fbb	b9 09 03	lda $0309,y			lda 		XS_Mantissa+1,y
.018fbe	ff 16 90 01	sbc $019016,x			sbc 		_ITSSubtractors+1,x
.018fc2	48		pha				pha
.018fc3	b9 0a 03	lda $030a,y			lda 		XS_Mantissa+2,y
.018fc6	ff 17 90 01	sbc $019017,x			sbc 		_ITSSubtractors+2,x
.018fca	48		pha				pha
.018fcb	b9 0b 03	lda $030b,y			lda 		XS_Mantissa+3,y
.018fce	ff 18 90 01	sbc $019018,x			sbc 		_ITSSubtractors+3,x
.018fd2	90 14		bcc $018fe8			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.018fd4	99 0b 03	sta $030b,y			sta 		XS_Mantissa+3,y 		; save subtract off stack
.018fd7	68		pla				pla
.018fd8	99 0a 03	sta $030a,y			sta 		XS_Mantissa+2,y
.018fdb	68		pla				pla
.018fdc	99 09 03	sta $0309,y			sta 		XS_Mantissa+1,y
.018fdf	68		pla				pla
.018fe0	99 08 03	sta $0308,y			sta 		XS_Mantissa+0,y
.018fe3	ee 22 04	inc $0422			inc 		NumConvCount 			; bump count.
.018fe6	80 ca		bra $018fb2			bra 		_ITSSubtract 			; go round again.
.018fe8					_ITSCantSubtract:
.018fe8	68		pla				pla 								; throw away interim answers
.018fe9	68		pla				pla
.018fea	68		pla				pla
.018feb	ad 22 04	lda $0422			lda 		NumConvCount 			; if not zero then no suppression check
.018fee	c9 30		cmp #$30			cmp 		#"0"
.018ff0	d0 05		bne $018ff7			bne 		_ITSOutputDigit
.018ff2	ad 21 04	lda $0421			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.018ff5	10 09		bpl $019000			bpl	 		_ITSGoNextSubtractor
.018ff7					_ITSOutputDigit:
.018ff7	ce 21 04	dec $0421			dec 		NumSuppress 			; suppression check will be non-zero.
.018ffa	ad 22 04	lda $0422			lda 		NumConvCount 			; count of subtractions
.018ffd	20 39 90	jsr $019039			jsr 		ITSOutputCharacter 		; output it.
.019000					_ITSGoNextSubtractor:
.019000	e8		inx				inx 								; next dword
.019001	e8		inx				inx
.019002	e8		inx				inx
.019003	e8		inx				inx
.019004	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.019006	d0 a5		bne $018fad			bne 		_ITSNextSubtractor 		; do all the subtractors.
.019008	98		tya				tya 								; X is back as the mantissa index
.019009	aa		tax				tax
.01900a	bd 08 03	lda $0308,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.01900d	09 30		ora #$30			ora 		#"0"
.01900f	20 39 90	jsr $019039			jsr 		ITSOutputCharacter
.019012	7a		ply				ply 								; and exit
.019013	68		pla				pla
.019014	60		rts				rts
.019015					_ITSSubtractors:
>019015	00 ca 9a 3b					.dword 		1000000000
>019019	00 e1 f5 05					.dword 		100000000
>01901d	80 96 98 00					.dword 		10000000
>019021	40 42 0f 00					.dword 		1000000
>019025	a0 86 01 00					.dword 		100000
>019029	10 27 00 00					.dword 		10000
>01902d	e8 03 00 00					.dword 		1000
>019031	64 00 00 00					.dword 		100
>019035	0a 00 00 00					.dword 		10
.019039					_ITSSubtractorsEnd:
.019039					ITSOutputCharacter:
.019039	48		pha				pha
.01903a	da		phx				phx
.01903b	ae 00 04	ldx $0400			ldx 	NumBufX 					; save digit
.01903e	9d 01 04	sta $0401,x			sta 	Num_Buffer,x
.019041	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.019043	9d 02 04	sta $0402,x			sta 	Num_Buffer+1,x
.019046	ee 00 04	inc $0400			inc 	NumBufX						; bump pointer.
.019049	fa		plx				plx
.01904a	68		pla				pla
.01904b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.01904c					IntFromString:
.01904c	a0 00		ldy #$00			ldy 	#0
.01904e	8c 23 04	sty $0423			sty 	ExpTemp 					; this is the converted digit count.
.019051					IntFromStringY:
.019051	48		pha				pha
.019052	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.019054	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.019057	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.01905a	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01905d	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019060	a9 01		lda #$01			lda 	#1
.019062	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019065					_IFSLoop:
.019065	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.019067	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.019069	90 60		bcc $0190cb			bcc 	_IFSExit
.01906b	c9 3a		cmp #$3a			cmp 	#"9"+1
.01906d	b0 5c		bcs $0190cb			bcs 	_IFSExit
.01906f	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.019072	c9 0c		cmp #$0c			cmp 	#12
.019074	b0 5f		bcs $0190d5			bcs 	_IFSOverflow
.019076	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.019079	48		pha				pha
.01907a	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.01907d	48		pha				pha
.01907e	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.019081	48		pha				pha
.019082	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.019085	48		pha				pha
.019086	20 ea 90	jsr $0190ea			jsr 	IFSX1ShiftLeft 				; double
.019089	20 ea 90	jsr $0190ea			jsr 	IFSX1ShiftLeft 				; x 4
.01908c	18		clc				clc 								; add saved value x 5
.01908d	68		pla				pla
.01908e	7d 08 03	adc $0308,x			adc 	XS_Mantissa+0,x
.019091	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019094	68		pla				pla
.019095	7d 09 03	adc $0309,x			adc 	XS_Mantissa+1,x
.019098	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.01909b	68		pla				pla
.01909c	7d 0a 03	adc $030a,x			adc 	XS_Mantissa+2,x
.01909f	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0190a2	68		pla				pla
.0190a3	7d 0b 03	adc $030b,x			adc 	XS_Mantissa+3,x
.0190a6	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0190a9	20 ea 90	jsr $0190ea			jsr 	IFSX1ShiftLeft 				; x 10
.0190ac	ee 23 04	inc $0423			inc 	ExpTemp 					; bump count of digits processed.
.0190af	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.0190b1	29 0f		and #$0f			and 	#15
.0190b3	c8		iny				iny
.0190b4	7d 08 03	adc $0308,x			adc 	XS_Mantissa+0,x
.0190b7	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0190ba	90 a9		bcc $019065			bcc 	_IFSLoop
.0190bc	fe 09 03	inc $0309,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.0190bf	d0 a4		bne $019065			bne 	_IFSLoop
.0190c1	fe 0a 03	inc $030a,x			inc 	XS_Mantissa+2,x
.0190c4	d0 9f		bne $019065			bne 	_IFSLoop
.0190c6	fe 0b 03	inc $030b,x			inc 	XS_Mantissa+3,x
.0190c9	80 9a		bra $019065			bra 	_IFSLoop
.0190cb					_IFSExit:
.0190cb	98		tya				tya 								; get offset
.0190cc					_IFSOkay:
.0190cc	38		sec				sec
.0190cd	ad 23 04	lda $0423			lda 	ExpTemp
.0190d0	f0 01		beq $0190d3			beq 	_IFSSkipFail
.0190d2	18		clc				clc
.0190d3					_IFSSkipFail:
.0190d3	68		pla				pla 								; and exit.
.0190d4	60		rts				rts
.0190d5					_IFSOverflow:
.0190d5	20 26 82	jsr $018226			jsr 	ERR_Handler
>0190d8	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>0190e0	20 6f 76 65 72 66 6c 6f 77 00
.0190ea					IFSX1ShiftLeft:
.0190ea	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x
.0190ed	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.0190f0	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.0190f3	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.0190f6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.0190f7					FPSubtract:
.0190f7	48		pha				pha
.0190f8	bd 13 03	lda $0313,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.0190fb	49 80		eor #$80			eor 	#$80
.0190fd	9d 13 03	sta $0313,x			sta 	XS2_Type,x
.019100	68		pla				pla 								; --- and fall through ---
.019101					FPAdd:
.019101	48		pha				pha
.019102	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.019105	d0 05		bne $01910c			bne 	_FPA_NegativeLHS
.019107	20 29 91	jsr $019129			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.01910a	68		pla				pla
.01910b	60		rts				rts
.01910c					_FPA_NegativeLHS:
.01910c	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.01910f	49 80		eor #$80			eor 	#$80
.019111	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019114	bd 13 03	lda $0313,x			lda 	XS2_Type,x 					; flip the sign of B and add
.019117	49 80		eor #$80			eor 	#$80
.019119	9d 13 03	sta $0313,x			sta 	XS2_Type,x
.01911c	20 29 91	jsr $019129			jsr 	FPAdd_Worker 				; do the add calculation.
.01911f	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip sign of X1 back
.019122	49 80		eor #$80			eor 	#$80
.019124	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019127	68		pla				pla
.019128	60		rts				rts
.019129					FPAdd_Worker:
.019129	3c 13 03	bit $0313,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.01912c	70 08		bvs $019136			bvs 	_FPAWExit 					; no change.
.01912e	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.019131	50 07		bvc $01913a			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.019133	20 ce 93	jsr $0193ce			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.019136					_FPAWExit:
.019136	20 56 94	jsr $019456			jsr 	FPUNormalise 				; normalise the result.
.019139	60		rts				rts
.01913a					_FPAWMakeSame:
.01913a	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.01913d	38		sec				sec
.01913e	fd 12 03	sbc $0312,x			sbc	 	XS2_Exponent,x 				; using subtraction
.019141	f0 1b		beq $01915e			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.019143	da		phx				phx 								; save X
.019144	90 06		bcc $01914c			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.019146	e8		inx				inx
.019147	e8		inx				inx
.019148	e8		inx				inx
.019149	e8		inx				inx
.01914a	e8		inx				inx
.01914b	e8		inx				inx
.01914c					_FPAWShiftA:
.01914c	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x 				; so shift exponent up.
.01914f	5e 0b 03	lsr $030b,x			lsr 	3+XS_Mantissa,x
.019152	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.019155	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.019158	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.01915b	fa		plx				plx 								; restore original X
.01915c	80 dc		bra $01913a			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.01915e					_FPAW_DoArithmetic:
.01915e	3c 13 03	bit $0313,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.019161	30 39		bmi $01919c			bmi 	_FPAW_BNegative
.019163	18		clc				clc
.019164	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.019167	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.01916a	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.01916d	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.019170	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.019173	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019176	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.019179	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.01917c	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01917f	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.019182	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.019185	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019188	90 ac		bcc $019136			bcc 	_FPAWExit 					; no carry.
.01918a	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x 				; so shift exponent up.
.01918d	38		sec				sec
.01918e	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.019191	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.019194	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.019197	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.01919a	80 9a		bra $019136			bra 	_FPAWExit
.01919c					_FPAW_BNegative:
.01919c	38		sec				sec
.01919d	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.0191a0	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.0191a3	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0191a6	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0191a9	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.0191ac	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0191af	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.0191b2	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.0191b5	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0191b8	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.0191bb	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.0191be	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0191c1	b0 0b		bcs $0191ce			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.0191c3	20 fb 93	jsr $0193fb			jsr 	FPUNegateInteger			; negate the mantissa
.0191c6	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip result sign
.0191c9	49 80		eor #$80			eor 	#$80
.0191cb	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0191ce					_FPAWGoExit:
.0191ce	4c 36 91	jmp $019136			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.0191d1					FPD_IsDivZero:
.0191d1	20 26 82	jsr $018226			jsr ERR_Handler
>0191d4	44 69 76 69 73 69 6f 6e			.text "Division by zero",0
>0191dc	20 62 79 20 7a 65 72 6f 00
.0191e5					FPDivide:
.0191e5	48		pha				pha
.0191e6	5a		phy				phy
.0191e7	3c 13 03	bit $0313,x			bit 	XS2_Type,x 					; check if division by zero
.0191ea	70 e5		bvs $0191d1			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.0191ec	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.0191ef	f0 03		beq $0191f4			beq 	_FPDCalculateExp
.0191f1					_FPD_Exit:
.0191f1	7a		ply				ply
.0191f2	68		pla				pla
.0191f3	60		rts				rts
.0191f4					_FPDCalculateExp:
.0191f4	bd 12 03	lda $0312,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.0191f7	49 ff		eor #$ff			eor 	#$FF
.0191f9	1a		inc a				inc 	a
.0191fa	9d 12 03	sta $0312,x			sta 	XS2_Exponent,x
.0191fd	20 f1 92	jsr $0192f1			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.019200	18		clc				clc 	 							; add 1 to the resulting exponent
.019201	69 01		adc #$01			adc 	#1
.019203	b0 65		bcs $01926a			bcs 	_FPD_Overflow 				; which can overflow.
.019205	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.019208	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.01920a	85 1a		sta $1a				sta 	zLTemp1+0
.01920c	85 1b		sta $1b				sta 	zLTemp1+1
.01920e	85 1c		sta $1c				sta 	zLTemp1+2
.019210	85 1d		sta $1d				sta 	zLTemp1+3
.019212	a0 20		ldy #$20			ldy 	#32 						; times round.
.019214					_FPD_Loop:
.019214	38		sec				sec 								; calculate X1-X2 stacking result because we might
.019215	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; not save it.
.019218	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa,x
.01921b	48		pha				pha
.01921c	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.01921f	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.019222	48		pha				pha
.019223	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.019226	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.019229	48		pha				pha
.01922a	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.01922d	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.019230	90 17		bcc $019249			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.019232	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x 			; save results out to A
.019235	68		pla				pla
.019236	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019239	68		pla				pla
.01923a	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.01923d	68		pla				pla
.01923e	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019241	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.019243	09 80		ora #$80			ora 	#$80
.019245	85 1d		sta $1d				sta 	zLTemp1+3
.019247	80 03		bra $01924c			bra 	_FPD_Rotates
.019249					_FPD_NoSubtract:
.019249	68		pla				pla 								; throw away unwanted results
.01924a	68		pla				pla
.01924b	68		pla				pla
.01924c					_FPD_Rotates:
.01924c	5e 11 03	lsr $0311,x			lsr 	3+XS2_Mantissa,x
.01924f	7e 10 03	ror $0310,x			ror 	2+XS2_Mantissa,x
.019252	7e 0f 03	ror $030f,x			ror 	1+XS2_Mantissa,x
.019255	7e 0e 03	ror $030e,x			ror 	0+XS2_Mantissa,x
.019258	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.01925a	26 1b		rol $1b				rol 	zLTemp1+1
.01925c	26 1c		rol $1c				rol 	zLTemp1+2
.01925e	26 1d		rol $1d				rol 	zLTemp1+3
.019260	90 02		bcc $019264			bcc 	_FPD_NoCarry
.019262	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.019264					_FPD_NoCarry:
.019264	88		dey				dey 								; do 32 times
.019265	d0 ad		bne $019214			bne 	_FPD_Loop
.019267	4c ce 92	jmp $0192ce			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.01926a					_FPD_Overflow:
.01926a	4c cb 94	jmp $0194cb			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.01926d					FPMultiply:
.01926d	48		pha				pha
.01926e	5a		phy				phy
.01926f	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.019272	70 08		bvs $01927c			bvs 	_FPM_Exit
.019274	3c 13 03	bit $0313,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.019277	50 06		bvc $01927f			bvc 	_FPM_CalcExponent
.019279	20 ce 93	jsr $0193ce			jsr 	FPUCopyX2ToX1
.01927c					_FPM_Exit:
.01927c	7a		ply				ply
.01927d	68		pla				pla
.01927e	60		rts				rts
.01927f					_FPM_CalcExponent:
.01927f	18		clc				clc
.019280	20 f1 92	jsr $0192f1			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.019283	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x 				; save the result.
.019286	a9 00		lda #$00			lda 	#0
.019288	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.01928a	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.01928c	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.01928e	85 1d		sta $1d				sta 	zLTemp1+3
.019290	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.019292					_FPM_Loop:
.019292	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x				; check LSB of long product
.019295	29 01		and #$01			and 	#1
.019297	18		clc				clc 								; clear carry for the long rotate.
.019298	f0 1d		beq $0192b7			beq 	_FPM_NoAddition
.01929a	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.01929b	a5 1a		lda $1a				lda 	zLTemp1+0
.01929d	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.0192a0	85 1a		sta $1a				sta 	zLTemp1+0
.0192a2	a5 1b		lda $1b				lda 	zLTemp1+1
.0192a4	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.0192a7	85 1b		sta $1b				sta 	zLTemp1+1
.0192a9	a5 1c		lda $1c				lda 	zLTemp1+2
.0192ab	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.0192ae	85 1c		sta $1c				sta 	zLTemp1+2
.0192b0	a5 1d		lda $1d				lda 	zLTemp1+3
.0192b2	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.0192b5	85 1d		sta $1d				sta 	zLTemp1+3
.0192b7					_FPM_NoAddition:
.0192b7	66 1d		ror $1d				ror 	3+zLTemp1
.0192b9	66 1c		ror $1c				ror 	2+zLTemp1
.0192bb	66 1b		ror $1b				ror 	1+zLTemp1
.0192bd	66 1a		ror $1a				ror 	0+zLTemp1
.0192bf	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.0192c2	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.0192c5	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.0192c8	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.0192cb	88		dey				dey
.0192cc	d0 c4		bne $019292			bne 	_FPM_Loop 					; do this 32 times.
.0192ce					FPM_CopySignNormalize:
.0192ce	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.0192d0	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.0192d3	a5 1b		lda $1b				lda 	zLTemp1+1
.0192d5	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0192d8	a5 1c		lda $1c				lda 	zLTemp1+2
.0192da	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0192dd	a5 1d		lda $1d				lda 	zLTemp1+3
.0192df	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0192e2	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; sign is xor of signs
.0192e5	5d 13 03	eor $0313,x			eor 	XS2_Type,x
.0192e8	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0192eb	20 56 94	jsr $019456			jsr 	FPUNormalise 				; normalise and exit.
.0192ee	7a		ply				ply
.0192ef	68		pla				pla
.0192f0	60		rts				rts
.0192f1					FPCalculateExponent:
.0192f1	18		clc				clc
.0192f2	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.0192f5	7d 12 03	adc $0312,x			adc 	XS2_Exponent,x
.0192f8	b0 08		bcs $019302			bcs 	_FPCECarry 					; carry out ?
.0192fa	10 03		bpl $0192ff			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.0192fc	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.0192fe	60		rts				rts
.0192ff					_FPCEExpZero:
.0192ff	a9 00		lda #$00			lda 	#0
.019301	60		rts				rts
.019302					_FPCECarry:
.019302	30 03		bmi $019307			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.019304	09 80		ora #$80			ora 	#$80 						; put in right range
.019306	60		rts				rts
.019307					_FPCEOverflow:
.019307	4c cb 94	jmp $0194cb			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.01930a					FPFractionalPart:
.01930a	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.01930d	38		sec				sec 								; this flag tells us to keep the fractional part
.01930e	30 0f		bmi $01931f			bmi 	FPGetPart
.019310	60		rts				rts
.019311					FPIntegerPart:
.019311	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.019314	18		clc				clc 								; this flag says keep the integer part.
.019315	30 08		bmi $01931f			bmi 	FPGetPart 					; -ve exponents are 0..127
.019317	48		pha				pha
.019318	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.01931a	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.01931d	68		pla				pla
.01931e	60		rts				rts
.01931f					FPGetPart:
.01931f	48		pha				pha
.019320	5a		phy				phy 								; save Y
.019321	08		php				php 								; save action
.019322	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.019325	70 62		bvs $019389			bvs 	_FPGP_Exit 					; then do nothing.
.019327	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.019329	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.01932b	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.01932d	85 1c		sta $1c				sta 	zLTemp1+2
.01932f	85 1d		sta $1d				sta 	zLTemp1+3
.019331	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x				; the number of shifts.
.019334	38		sec				sec
.019335	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.019337	f0 12		beq $01934b			beq 	_FPGP_NoShift 				; ... if any
.019339	c9 20		cmp #$20			cmp 	#32
.01933b	90 02		bcc $01933f			bcc 	_FPGP_NotMax
.01933d	a9 20		lda #$20			lda 	#32 						; max of 32.
.01933f					_FPGP_NotMax:
.01933f	a8		tay				tay 								; Y is the mask shift count.
.019340					_FPGP_ShiftMask:
.019340	46 1d		lsr $1d				lsr 	3+zLTemp1
.019342	66 1c		ror $1c				ror 	2+zLTemp1
.019344	66 1b		ror $1b				ror 	1+zLTemp1
.019346	66 1a		ror $1a				ror 	0+zLTemp1
.019348	88		dey				dey
.019349	d0 f5		bne $019340			bne 	_FPGP_ShiftMask
.01934b					_FPGP_NoShift:
.01934b	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.01934d	8e 23 04	stx $0423			stx 	ExpTemp						; save X
.019350					_FPGP_MaskLoop:
.019350	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.019353	28		plp				plp 								; if CC we keep the top part, so we
.019354	08		php				php		 							; flip the mask.
.019355	b0 02		bcs $019359			bcs		_FPGP_NoFlip
.019357	49 ff		eor #$ff			eor 	#$FF
.019359					_FPGP_NoFlip:
.019359	3d 08 03	and $0308,x			and 	XS_Mantissa,x 				; and into the mantissa.
.01935c	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.01935f	e8		inx				inx
.019360	c8		iny				iny
.019361	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.019363	d0 eb		bne $019350			bne 	_FPGP_MaskLoop
.019365	ae 23 04	ldx $0423			ldx 	ExpTemp						; restore X
.019368	28		plp				plp
.019369	08		php				php 								; get action flag on the stack
.01936a	90 05		bcc $019371			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.01936c	a9 00		lda #$00			lda 	#0
.01936e	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019371					_FPGP_NotFractional:
.019371	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 						; check if \1 zero
.019374	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.019377	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.01937a	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.01937d	f0 05		beq $019384			beq 	_FPGP_Zero 					; if zero, return zero
.01937f	20 56 94	jsr $019456			jsr 	FPUNormalise
.019382	80 05		bra $019389			bra 	_FPGP_Exit 					; and exit
.019384					_FPGP_Zero:
.019384	a9 40		lda #$40			lda 	#$40 						; set zero flag
.019386	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019389					_FPGP_Exit:
.019389	68		pla				pla 								; throw saved action flag.
.01938a	7a		ply				ply
.01938b	68		pla				pla
.01938c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.01938d					FPCompare:
.01938d	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.019390	48		pha				pha
.019391	bd 12 03	lda $0312,x			lda 	XS2_Exponent,x
.019394	48		pha				pha
.019395	20 f7 90	jsr $0190f7			jsr 	FPSubtract 					; calculate X1-X2
.019398	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.01939b	70 2c		bvs $0193c9			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.01939d	68		pla				pla
.01939e	8d 23 04	sta $0423			sta 	ExpTemp						; save first exponent in temporary reg.
.0193a1	68		pla				pla
.0193a2	38		sec				sec
.0193a3	ed 23 04	sbc $0423			sbc 	ExpTemp 					; calculate AX-BX
.0193a6	70 15		bvs $0193bd			bvs 	_FPCNotEqual				; overflow, can't be equal.
.0193a8	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.0193a9	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.0193ab	b0 10		bcs $0193bd			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.0193ad	38		sec				sec
.0193ae	ad 23 04	lda $0423			lda 	ExpTemp 					; get one of the exponents back.
.0193b1	e9 12		sbc #$12			sbc 	#18 						; allow for 2^18 error, relatively.
.0193b3	b0 02		bcs $0193b7			bcs 	_FPCNotRange 				; keep in range.
.0193b5	a9 01		lda #$01			lda 	#1
.0193b7					_FPCNotRange:
.0193b7	38		sec				sec
.0193b8	fd 0c 03	sbc $030c,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.0193bb	b0 0e		bcs $0193cb			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.0193bd					_FPCNotEqual:
.0193bd	bd 0d 03	lda $030d,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.0193c0	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.0193c2	f0 02		beq $0193c6			beq 	_FPCNE2
.0193c4	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.0193c6	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.0193c7	80 04		bra $0193cd			bra 	_FPCExit
.0193c9					_FPCPullZero:
.0193c9	68		pla				pla 								; throw saved exponents
.0193ca	68		pla				pla
.0193cb					_FPCZero:
.0193cb	a9 00		lda #$00			lda 	#0 							; and return zero
.0193cd					_FPCExit:
.0193cd	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.0193ce					FPUCopyX2ToX1:
.0193ce	48		pha				pha
.0193cf	da		phx				phx
.0193d0	5a		phy				phy
.0193d1	a0 08		ldy #$08			ldy 	#8
.0193d3	bd 0e 03	lda $030e,x	_FPUC21:lda 	XS2_Mantissa,x
.0193d6	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.0193d9	e8		inx				inx
.0193da	88		dey				dey
.0193db	10 f6		bpl $0193d3			bpl 	_FPUC21
.0193dd	7a		ply				ply
.0193de	fa		plx				plx
.0193df	68		pla				pla
.0193e0	60		rts				rts
.0193e1					FPUSetInteger:
.0193e1	48		pha				pha
.0193e2	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.0193e5	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.0193e7	10 02		bpl $0193eb			bpl 	_FPUSIExtend
.0193e9	a9 ff		lda #$ff			lda 	#$FF
.0193eb					_FPUSIExtend:
.0193eb	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.0193ee	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0193f1	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0193f4	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.0193f6	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0193f9	68		pla				pla
.0193fa	60		rts				rts
.0193fb					FPUNegateInteger:
.0193fb	48		pha				pha
.0193fc	38		sec				sec
.0193fd	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.0193ff	fd 08 03	sbc $0308,x			sbc 	XS_Mantissa+0,x
.019402	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019405	a9 00		lda #$00			lda 	#0
.019407	fd 09 03	sbc $0309,x			sbc 	XS_Mantissa+1,x
.01940a	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.01940d	a9 00		lda #$00			lda 	#0
.01940f	fd 0a 03	sbc $030a,x			sbc 	XS_Mantissa+2,x
.019412	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019415	a9 00		lda #$00			lda 	#0
.019417	fd 0b 03	sbc $030b,x			sbc 	XS_Mantissa+3,x
.01941a	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.01941d	68		pla				pla
.01941e	60		rts				rts
.01941f					FPUToFloat:
.01941f	48		pha				pha
.019420	bd 0d 03	lda $030d,x			lda 	XS_Type,x					; exit if already float.
.019423	29 0f		and #$0f			and 	#$0F
.019425	f0 2d		beq $019454			beq 	_FPUFExit
.019427	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.019429	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.01942c	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.01942e	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x 				; x mantissa.
.019431	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.019434	10 08		bpl $01943e			bpl		_FPUFPositive
.019436	20 fb 93	jsr $0193fb			jsr 	FPUNegateInteger 			; negate the mantissa
.019439	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.01943b	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.01943e					_FPUFPositive:
.01943e	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.019441	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.019444	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.019447	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.01944a	d0 05		bne $019451			bne 	_FPUFNonZero
.01944c	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.01944e	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019451					_FPUFNonZero:
.019451	20 56 94	jsr $019456			jsr 	FPUNormalise 				; normalise the floating point.
.019454					_FPUFExit:
.019454	68		pla				pla
.019455	60		rts				rts
.019456					FPUNormalise:
.019456	48		pha				pha
.019457	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.01945a	70 20		bvs $01947c			bvs 	_FPUNExit
.01945c	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.01945f	f0 16		beq $019477			beq 	_FPUNSetZero
.019461					_FPUNLoop:
.019461	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.019464	30 16		bmi $01947c			bmi 	_FPUNExit 					; if so, we are normalised.
.019466	1e 08 03	asl $0308,x			asl 	0+XS_Mantissa+0,x
.019469	3e 09 03	rol $0309,x			rol 	1+XS_Mantissa+0,x
.01946c	3e 0a 03	rol $030a,x			rol 	2+XS_Mantissa+0,x
.01946f	3e 0b 03	rol $030b,x			rol 	3+XS_Mantissa+0,x
.019472	de 0c 03	dec $030c,x			dec 	XS_Exponent,x 				; decrement exponent
.019475	d0 ea		bne $019461			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.019477					_FPUNSetZero:
.019477	a9 40		lda #$40			lda 	#$40
.019479	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; the result is now zero.
.01947c					_FPUNExit:
.01947c	68		pla				pla
.01947d	60		rts				rts
.01947e					FPUToInteger:
.01947e	48		pha				pha
.01947f	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; if already integer, exit
.019482	29 01		and #$01			and 	#1
.019484	d0 3e		bne $0194c4			bne 	_FPUTOI_Exit
.019486	3c 0d 03	bit $030d,x			bit 	XS_Type,x					; if zero, return zero.
.019489	70 2b		bvs $0194b6			bvs 	_FPUTOI_Zero
.01948b	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.01948e	10 26		bpl $0194b6			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.019490	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.019492	b0 37		bcs $0194cb			bcs 	FP_Overflow
.019494					_FPUToIToInteger:
.019494	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.019497	c9 a0		cmp #$a0			cmp 	#128+32
.019499	f0 11		beq $0194ac			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.01949b	fe 0c 03	inc $030c,x			inc 	XS_Exponent,X 				; increment Exponent
.01949e	5e 0b 03	lsr $030b,x			lsr 	3+XS_Mantissa,x
.0194a1	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.0194a4	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.0194a7	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.0194aa	80 e8		bra $019494			bra 	_FPUToIToInteger 			; keep going.
.0194ac					_FPUToICheckSign:
.0194ac	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; check sign
.0194af	10 13		bpl $0194c4			bpl 	_FPUToI_Exit 				; exit if unsigned.
.0194b1	20 fb 93	jsr $0193fb			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.0194b4	80 0e		bra $0194c4			bra 	_FPUTOI_Exit
.0194b6					_FPUTOI_Zero:
.0194b6	a9 00		lda #$00			lda 	#0 							; return zero integer.
.0194b8	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0194bb	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0194be	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0194c1	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0194c4					_FPUToI_Exit:
.0194c4	a9 01		lda #$01			lda 	#1 							; set type to integer
.0194c6	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0194c9	68		pla				pla
.0194ca	60		rts				rts
.0194cb					FP_Overflow:
.0194cb	20 26 82	jsr $018226			jsr ERR_Handler
>0194ce	46 6c 6f 61 74 69 6e 67			.text "Floating Point overflow",0
>0194d6	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.0194e6					FPUTimes10:
.0194e6	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.0194e9	85 1a		sta $1a				sta 	ZLTemp1+0
.0194eb	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0194ee	85 1b		sta $1b				sta 	ZLTemp1+1
.0194f0	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.0194f3	85 1c		sta $1c				sta 	ZLTemp1+2
.0194f5	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.0194f8	85 1d		sta $1d				sta 	ZLTemp1+3
.0194fa	20 3e 95	jsr $01953e			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.0194fd	20 3e 95	jsr $01953e			jsr 	_FPUT_LSR_ZLTemp1
.019500	18		clc				clc
.019501	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.019504	65 1a		adc $1a				adc 	ZLTemp1+0
.019506	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019509	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.01950c	65 1b		adc $1b				adc 	ZLTemp1+1
.01950e	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019511	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.019514	65 1c		adc $1c				adc 	ZLTemp1+2
.019516	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019519	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.01951c	65 1d		adc $1d				adc 	ZLTemp1+3
.01951e	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019521	90 0f		bcc $019532			bcc 	_FPUTimes10
.019523	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.019526	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.019529	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.01952c	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.01952f	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x				; fix exponent
.019532					_FPUTimes10:
.019532	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.019535	18		clc				clc
.019536	69 03		adc #$03			adc 	#3
.019538	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.01953b	b0 8e		bcs $0194cb			bcs 	FP_Overflow 				; error
.01953d	60		rts				rts
.01953e					_FPUT_LSR_ZLTemp1:
.01953e	46 1d		lsr $1d				lsr 	ZLTemp1+3
.019540	66 1c		ror $1c				ror 	ZLTemp1+2
.019542	66 1b		ror $1b				ror 	ZLTemp1+1
.019544	66 1a		ror $1a				ror 	ZLTemp1+0
.019546	60		rts				rts
.019547					FPUScale10A:
.019547	5a		phy				phy
.019548	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.01954a	f0 3d		beq $019589			beq 	_FPUScaleExit
.01954c	da		phx				phx 								; save X
.01954d	e8		inx				inx
.01954e	e8		inx				inx
.01954f	e8		inx				inx
.019550	e8		inx				inx
.019551	e8		inx				inx
.019552	e8		inx				inx
.019553	a8		tay				tay 								; save power scalar in Y.
.019554	a9 00		lda #$00			lda 	#0
.019556	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.019559	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.01955c	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01955f	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019562	a9 80		lda #$80			lda 	#$80
.019564	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019567	a9 81		lda #$81			lda 	#$81
.019569	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.01956c	5a		phy				phy 								; save 10^n on stack.
.01956d	c0 00		cpy #$00			cpy 	#0
.01956f	10 05		bpl $019576			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.019571	98		tya				tya
.019572	49 ff		eor #$ff			eor 	#$FF
.019574	1a		inc a				inc 	a
.019575	a8		tay				tay
.019576					_FPUSAbs:
.019576	20 e6 94	jsr $0194e6			jsr 	FPUTimes10
.019579	88		dey				dey
.01957a	d0 fa		bne $019576			bne 	_FPUSAbs 					; tos is now 10^|AC|
.01957c	68		pla				pla 								; restore count in A
.01957d	fa		plx				plx 								; restore X pointing to number to scale.
.01957e	0a		asl a				asl 	a
.01957f	b0 05		bcs $019586			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.019581	20 6d 92	jsr $01926d			jsr 	FPMultiply 					; if clear multiply.
.019584	80 03		bra $019589			bra		_FPUScaleExit
.019586					_FPUSDivide:
.019586	20 e5 91	jsr $0191e5			jsr 	FPDivide
.019589					_FPUScaleExit:
.019589	7a		ply				ply
.01958a	60		rts				rts
.01958b					FPUCopyToNext:
.01958b	a0 06		ldy #$06			ldy 		#6
.01958d	da		phx				phx
.01958e					_FPUCopy1:
.01958e	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x
.019591	9d 0e 03	sta $030e,x			sta 	XS2_Mantissa,x
.019594	e8		inx				inx
.019595	88		dey				dey
.019596	d0 f6		bne $01958e			bne 	_FPUCopy1
.019598	fa		plx				plx
.019599	60		rts				rts
.01959a					FPUCopyFromNext:
.01959a	a0 06		ldy #$06			ldy 		#6
.01959c	da		phx				phx
.01959d					_FPUCopy1:
.01959d	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa,x
.0195a0	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.0195a3	e8		inx				inx
.0195a4	88		dey				dey
.0195a5	d0 f6		bne $01959d			bne 	_FPUCopy1
.0195a7	fa		plx				plx
.0195a8	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.0195a9					FPToString:
.0195a9	48		pha				pha
.0195aa	5a		phy				phy
.0195ab	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; check zero flag
.0195ae	50 0a		bvc $0195ba			bvc 		_FPTSIsFloat 			; if zero,
.0195b0					_FPTSZero:
.0195b0	a9 30		lda #$30			lda 		#"0"
.0195b2	20 39 90	jsr $019039			jsr 		ITSOutputCharacter
.0195b5					_FPTSExit:
.0195b5	7a		ply				ply
.0195b6	68		pla				pla
.0195b7	60		rts				rts
.0195b8	80 fb		bra $0195b5			bra 		_FPTSExit
.0195ba					_FPTSIsFloat:
.0195ba	bd 0d 03	lda $030d,x			lda 		XS_Type,x 				; is it signed ?
.0195bd	10 0a		bpl $0195c9			bpl 		_FPTSNotSigned
.0195bf	a9 00		lda #$00			lda 		#0 						; clear sign flag
.0195c1	9d 0d 03	sta $030d,x			sta 		XS_Type,x
.0195c4	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.0195c6	20 39 90	jsr $019039			jsr 		ITSOutputCharacter
.0195c9					_FPTSNotSigned:
.0195c9	bd 0c 03	lda $030c,x			lda 		XS_Exponent,x
.0195cc	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.0195ce	b0 09		bcs $0195d9			bcs 		_FPTSExponent
.0195d0	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.0195d2	90 05		bcc $0195d9			bcc 		_FPTSExponent 			;
.0195d4					_FPTSStandard:
.0195d4	20 1d 96	jsr $01961d			jsr 		FPTOutputBody 			; output the body.
.0195d7	80 dc		bra $0195b5			bra 		_FPTSExit
.0195d9					_FPTSExponent:
.0195d9	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.0195db	8d 24 04	sta $0424			sta 		ExpCount
.0195de					_FPTSExponentLoop:
.0195de	bd 0c 03	lda $030c,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.0195e1	10 0e		bpl $0195f1			bpl 		_FPTSTimes
.0195e3	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.0195e5	90 14		bcc $0195fb			bcc 		_FPTSScaledToExp
.0195e7	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.0195e9	20 47 95	jsr $019547			jsr 		FPUScale10A
.0195ec	ee 24 04	inc $0424			inc 		ExpCount
.0195ef	80 ed		bra $0195de			bra 		_FPTSExponentLoop
.0195f1					_FPTSTimes:
.0195f1	a9 01		lda #$01			lda 		#1
.0195f3	20 47 95	jsr $019547			jsr 		FPUScale10A
.0195f6	ce 24 04	dec $0424			dec 		ExpCount
.0195f9	80 e3		bra $0195de			bra 		_FPTSExponentLoop
.0195fb					_FPTSScaledToExp:
.0195fb	20 1d 96	jsr $01961d			jsr 		FPTOutputBody 			; output the body.
.0195fe	a9 65		lda #$65			lda 		#"e"					; output E
.019600	20 39 90	jsr $019039			jsr 		ITSOutputCharacter
.019603	ad 24 04	lda $0424			lda 		ExpCount 				; get the exponent
.019606	9d 08 03	sta $0308,x			sta 		XS_Mantissa,x
.019609	29 80		and #$80			and 		#$80 					; sign extend it
.01960b	f0 02		beq $01960f			beq 		_FPTSSExt
.01960d	a9 ff		lda #$ff			lda 		#$FF
.01960f					_FPTSSExt:
.01960f	9d 09 03	sta $0309,x			sta 		XS_Mantissa+1,x
.019612	9d 0a 03	sta $030a,x			sta 		XS_Mantissa+2,x
.019615	9d 0b 03	sta $030b,x			sta 		XS_Mantissa+3,x
.019618	20 95 8f	jsr $018f95			jsr 		INTToString 			; output the exponent.
.01961b	80 98		bra $0195b5			bra			_FPTSExit 				; and exit.
.01961d					FPTOutputBody:
.01961d	20 8b 95	jsr $01958b			jsr 		FPUCopyToNext 			; copy to next slot.
.019620	20 7e 94	jsr $01947e			jsr 		FPUToInteger 			; convert to an integer
.019623	20 95 8f	jsr $018f95			jsr 		INTToString 			; output the main integer part.
.019626	20 9a 95	jsr $01959a			jsr 		FPUCopyFromNext 		; get the fractional part back.
.019629	20 0a 93	jsr $01930a			jsr 		FPFractionalPart 		; get the decimal part.
.01962c	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; any fractional part.
.01962f	70 3e		bvs $01966f			bvs 		_FPTOExit 				; if not, exit now.
.019631	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.019633	20 39 90	jsr $019039			jsr 		ITSOutputCharacter
.019636					_FPOutLoop:
.019636	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; finally reached zero.
.019639	70 1e		bvs $019659			bvs 		_FPStripZeros 			; strip trailing zeros
.01963b	20 e6 94	jsr $0194e6			jsr 		FPUTimes10 				; multiply by 10
.01963e	20 8b 95	jsr $01958b			jsr 		FPUCopyToNext			; copy to next slot.
.019641	20 7e 94	jsr $01947e			jsr 		FPUToInteger 			; convert to integer
.019644	bd 08 03	lda $0308,x			lda 		XS_Mantissa+0,x 		; print digit.
.019647	09 30		ora #$30			ora 		#"0"
.019649	20 39 90	jsr $019039			jsr 		ITSOutputCharacter
.01964c	20 9a 95	jsr $01959a			jsr 		FPUCopyFromNext 		; get it back
.01964f	20 0a 93	jsr $01930a			jsr 		FPFractionalPart 		; get fractional part
.019652	ad 00 04	lda $0400			lda 		NumBufX 				; done 11 characters yet ?
.019655	c9 0b		cmp #$0b			cmp 	 	#11
.019657	90 dd		bcc $019636			bcc 		_FPOutLoop 				; if so, keep going till zero.
.019659					_FPStripZeros:
.019659	ac 00 04	ldy $0400			ldy 		NumBufX 				; strip trailing zeros.
.01965c					_FPStripLoop:
.01965c	88		dey				dey 								; back one, if at start then no strip
.01965d	f0 10		beq $01966f			beq 		_FPToExit
.01965f	b9 01 04	lda $0401,y			lda 		Num_Buffer,y 			; keep going if "0"
.019662	c9 30		cmp #$30			cmp 		#"0"
.019664	f0 f6		beq $01965c			beq 		_FPStripLoop
.019666	c8		iny				iny
.019667	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.019669	99 01 04	sta $0401,y			sta 		Num_Buffer,y
.01966c	8c 00 04	sty $0400			sty 		NumBufX 				; update position.
.01966f					_FPTOExit:
.01966f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.019670					FPFromString:
.019670	48		pha				pha 								; push A
.019671	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.019673	c9 2e		cmp #$2e			cmp 	#"."
.019675	f0 03		beq $01967a			beq	 	_FPFIsDecimal
.019677	4c dd 96	jmp $0196dd			jmp 	_FPFNotDecimal
.01967a					_FPFIsDecimal:
.01967a	c8		iny				iny 								; consume the decimal.
.01967b	20 1f 94	jsr $01941f			jsr 	FPUToFloat 					; convert the integer to float.
.01967e	da		phx				phx 								; save X.
.01967f	5a		phy				phy 								; save decimal start position
.019680	e8		inx				inx
.019681	e8		inx				inx
.019682	e8		inx				inx
.019683	e8		inx				inx
.019684	e8		inx				inx
.019685	e8		inx				inx
.019686	20 51 90	jsr $019051			jsr 	INTFromStringY 				; get the part after the DP.
.019689	20 1f 94	jsr $01941f			jsr 	FPUToFloat 					; convert that to a float.
.01968c	68		pla				pla 								; calculate - chars consumed.
.01968d	8c 23 04	sty $0423			sty 	ExpTemp
.019690	38		sec				sec
.019691	ed 23 04	sbc $0423			sbc 	ExpTemp 					; this is the shift amount
.019694	20 47 95	jsr $019547			jsr 	FPUScale10A 				; scale it by 10^AC
.019697	fa		plx				plx 								; restore original X
.019698	20 01 91	jsr $019101			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.01969b	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.01969d	c9 45		cmp #$45			cmp 	#"E"
.01969f	f0 04		beq $0196a5			beq 	_FPFExponent
.0196a1	c9 65		cmp #$65			cmp 	#"e"
.0196a3	d0 38		bne $0196dd			bne 	_FPFNotDecimal 				; no, then exit normally.
.0196a5					_FPFExponent:
.0196a5	c8		iny				iny 								; skip over E symbol.
.0196a6	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.0196a8	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.0196aa	d0 01		bne $0196ad			bne 	_FPFGotSign
.0196ac	c8		iny				iny 								; if it was - skip over it.
.0196ad					_FPFGotSign:
.0196ad	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.0196ae	da		phx				phx
.0196af	e8		inx				inx
.0196b0	e8		inx				inx
.0196b1	e8		inx				inx
.0196b2	e8		inx				inx
.0196b3	e8		inx				inx
.0196b4	e8		inx				inx
.0196b5	20 51 90	jsr $019051			jsr 	INTFromStringY 				; get the exponent
.0196b8	fa		plx				plx 								; restore X.
.0196b9	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.0196bc	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.0196bf	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.0196c2	d0 1b		bne $0196df			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.0196c4	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.0196c7	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.0196c9	b0 14		bcs $0196df			bcs 	_FPFXOverflow
.0196cb	68		pla				pla 								; get direction
.0196cc	d0 09		bne $0196d7			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.0196ce	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.0196d1	49 ff		eor #$ff			eor 	#$FF
.0196d3	1a		inc a				inc 	a
.0196d4	9d 0e 03	sta $030e,x			sta 	XS2_Mantissa+0,x
.0196d7					_FPFXScale:
.0196d7	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.0196da	20 47 95	jsr $019547			jsr 	FPUScale10A 				; scale by the exponent.
.0196dd					_FPFNotDecimal:
.0196dd	68		pla				pla
.0196de	60		rts				rts
.0196df					_FPFXOverflow:
.0196df	20 26 82	jsr $018226			jsr 	ERR_Handler
>0196e2	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>0196ea	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.0196f1					Unary_Rnd:
.0196f1	20 83 87	jsr $018783			jsr 	EvaluateNumberX 			; get value
.0196f4	20 12 8e	jsr $018e12			jsr 	CheckNextRParen 			; check right bracket.
.0196f7	20 70 8a	jsr $018a70			jsr 	GetSignCurrent 				; get sign -1,0,1.
.0196fa	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.0196fc	30 10		bmi $01970e			bmi 	_URSetSeed
.0196fe	f0 2c		beq $01972c			beq 	_URMakeRandom 				; if zero return same number.
.019700	da		phx				phx
.019701	a2 00		ldx #$00			ldx 	#0
.019703	20 69 97	jsr $019769			jsr 	Random16
.019706	a2 02		ldx #$02			ldx 	#2
.019708	20 69 97	jsr $019769			jsr 	Random16
.01970b	fa		plx				plx
.01970c	80 1e		bra $01972c			bra 	_URMakeRandom
.01970e					_URSetSeed:
.01970e	20 1f 94	jsr $01941f			jsr 	FPUToFloat 					; make it a float to twiddle it.
.019711	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.019714	8d 2c 04	sta $042c			sta 	RandomSeed+0
.019717	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.01971a	8d 2d 04	sta $042d			sta 	RandomSeed+1
.01971d	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.019720	8d 2e 04	sta $042e			sta 	RandomSeed+2
.019723	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.019726	0a		asl a				asl 	a
.019727	49 db		eor #$db			eor 	#$DB
.019729	8d 2f 04	sta $042f			sta 	RandomSeed+3
.01972c					_URMakeRandom:
.01972c	ad 2c 04	lda $042c			lda 	RandomSeed+0 				; check if seed is zero.
.01972f	0d 2d 04	ora $042d			ora 	RandomSeed+1
.019732	0d 2e 04	ora $042e			ora 	RandomSeed+2
.019735	0d 2f 04	ora $042f			ora 	RandomSeed+3
.019738	d0 0a		bne $019744			bne 	_URNotZero
.01973a	a9 47		lda #$47			lda 	#$47
.01973c	8d 2d 04	sta $042d			sta 	RandomSeed+1				; if it is, make it non zero.
.01973f	a9 3d		lda #$3d			lda 	#$3D
.019741	8d 2f 04	sta $042f			sta 	RandomSeed+3
.019744					_URNotZero:
.019744	ad 2c 04	lda $042c			lda 	RandomSeed+0 				; copy seed into mantissa.
.019747	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.01974a	ad 2d 04	lda $042d			lda 	RandomSeed+1
.01974d	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019750	ad 2e 04	lda $042e			lda 	RandomSeed+2
.019753	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019756	ad 2f 04	lda $042f			lda 	RandomSeed+3
.019759	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.01975c	a9 00		lda #$00			lda 	#$00 						; set type to float.
.01975e	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019761	a9 80		lda #$80			lda 	#$80
.019763	9d 0c 03	sta $030c,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.019766	4c 56 94	jmp $019456			jmp 	FPUNormalise
.019769					Random16:
.019769	5e 2d 04	lsr $042d,x			lsr 	RandomSeed+1,x				; shift seed right
.01976c	7e 2c 04	ror $042c,x			ror 	RandomSeed,x
.01976f	90 08		bcc $019779			bcc 	_R16_NoXor
.019771	bd 2d 04	lda $042d,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.019774	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.019776	9d 2d 04	sta $042d,x			sta 	RandomSeed+1,x
.019779					_R16_NoXor:
.019779	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.01977a					Unary_Int:
.01977a	20 83 87	jsr $018783			jsr 	EvaluateNumberX 			; get value
.01977d	20 12 8e	jsr $018e12			jsr 	CheckNextRParen 			; check right bracket.
.019780	4c 7e 94	jmp $01947e			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.019783					TIM_Error:
.019783	20 29 80	jsr $018029			jsr 	IFT_UpLine 					; go up one line.
.019786	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.019788	80 02		bra $01978c			bra 	TIM_ShowPrompt
.01978a					TIM_NewCommand:
.01978a	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.01978c					TIM_ShowPrompt:
.01978c	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.01978f	20 fa 80	jsr $0180fa			jsr 	IFT_ReadLine	 			; get character, go to next line
.019792	20 5c 80	jsr $01805c			jsr 	IFT_NewLine					; go to next line.
.019795	86 10		stx $10				stx 	zTemp1 						; save line read address
.019797	84 11		sty $11				sty 	zTemp1+1
.019799	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.01979b	b1 10		lda ($10),y			lda 	(zTemp1),y
.01979d	c9 3f		cmp #$3f			cmp 	#"?"
.01979f	f0 04		beq $0197a5			beq 	TIM_SkipFirst
.0197a1	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.0197a3	d0 01		bne $0197a6			bne 	TIM_NotDot
.0197a5					TIM_SkipFirst:
.0197a5	c8		iny				iny
.0197a6					TIM_NotDot:
.0197a6	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.0197a8	c9 52		cmp #$52			cmp 	#"R"						; show registers
.0197aa	f0 6b		beq $019817			beq 	TIM_ShowRegisters
.0197ac	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.0197ae	f0 12		beq $0197c2			beq 	TIM_ShowMemory
.0197b0	c9 47		cmp #$47			cmp 	#"G"						; execute
.0197b2	f0 49		beq $0197fd			beq 	TIM_Execute
.0197b4	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.0197b6	f0 07		beq $0197bf			beq 	TIM_GoLoadMemory
.0197b8	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.0197ba	d0 c7		bne $019783			bne 	TIM_Error
.0197bc	4c 3b 99	jmp $01993b			jmp 	TIM_UpdateRegisters
.0197bf					TIM_GoLoadMemory:
.0197bf	4c 6b 99	jmp $01996b			jmp 	TIM_LoadMemory
.0197c2					TIM_ShowMemory:
.0197c2	20 b7 98	jsr $0198b7			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.0197c5	b0 bc		bcs $019783			bcs 	TIM_Error
.0197c7	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.0197c9	85 12		sta $12				sta 	zTemp2
.0197cb	a5 15		lda $15				lda 	zTemp3+1
.0197cd	85 13		sta $13				sta 	zTemp2+1
.0197cf	20 b7 98	jsr $0198b7			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.0197d2	90 08		bcc $0197dc			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.0197d4	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.0197d6	85 14		sta $14				sta 	zTemp3
.0197d8	a5 13		lda $13				lda 	zTemp2+1
.0197da	85 15		sta $15				sta 	zTemp3+1
.0197dc					_TIMSM_Start:
.0197dc	20 8f 98	jsr $01988f			jsr 	TIM_WriteLine 				; write one line of hex out
.0197df	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.0197e1	18		clc				clc
.0197e2	69 10		adc #$10			adc 	#16
.0197e4	85 12		sta $12				sta 	zTemp2
.0197e6	90 02		bcc $0197ea			bcc 	_TIMSM_NoCarry
.0197e8	e6 13		inc $13				inc 	zTemp2+1
.0197ea					_TIMSM_NoCarry:
.0197ea	20 e1 81	jsr $0181e1			jsr 	IF_CheckBreak 				; check CTL+C
.0197ed	d0 0b		bne $0197fa			bne 	_TIMSM_Ends 				; if pressed break out.
.0197ef	38		sec				sec 								; check past the end address in zTemp3
.0197f0	a5 14		lda $14				lda 	zTemp3
.0197f2	e5 12		sbc $12				sbc 	zTemp2
.0197f4	a5 15		lda $15				lda 	zTemp3+1
.0197f6	e5 13		sbc $13				sbc 	zTemp2+1
.0197f8	10 e2		bpl $0197dc			bpl 	_TIMSM_Start
.0197fa					_TIMSM_Ends:
.0197fa	4c 8a 97	jmp $01978a			jmp 	TIM_NewCommand
.0197fd					TIM_Execute:
.0197fd	20 b7 98	jsr $0198b7			jsr 	TIM_GetHex 					; get the execute address
.019800	b0 81		bcs $019783			bcs 	TIM_Error 					; not legitimate
.019802	ae 39 04	ldx $0439			ldx 	TIM_SP 						; set up SP
.019805	9a		txs				txs
.019806	ad 34 04	lda $0434			lda 	TIM_SR 						; Status for PLP
.019809	48		pha				pha
.01980a	ad 35 04	lda $0435			lda 	TIM_A 						; restore AXYZ
.01980d	ae 36 04	ldx $0436			ldx 	TIM_X
.019810	ac 37 04	ldy $0437			ldy 	TIM_Y
.019813	28		plp				plp 								; and PS Byte.
.019814	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.019817					TIM_Start:
.019817					TIM_ShowRegisters:
.019817	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.01981a	8d 33 04	sta $0433			sta 	TIM_IRQ+1
.01981d	ad ff ff	lda $ffff			lda 	$FFFF
.019820	8d 32 04	sta $0432			sta 	TIM_IRQ
.019823	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.019825					_TIMSR_Text:
.019825	bf 56 98 01	lda $019856,x			lda 	_TIMSR_Label,x
.019829	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01982c	e8		inx				inx
.01982d	e0 20		cpx #$20			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.01982f	d0 f4		bne $019825			bne 	_TIMSR_Text
.019831	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.019833					_TIMSR_Skip:
.019833	e8		inx				inx
.019834					_TIMSR_LoopSpace:
.019834	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.019836	b0 04		bcs $01983c			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.019838	8a		txa				txa
.019839	4a		lsr a				lsr 	a
.01983a	b0 05		bcs $019841			bcs 	_TIMSR_NoSpace
.01983c					_TIMSR_Space:
.01983c	a9 20		lda #$20			lda 	#" "
.01983e	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.019841					_TIMSR_NoSpace:
.019841	bd 30 04	lda $0430,x			lda 	TIM_PC,x 					; output hex value.
.019844	20 76 98	jsr $019876			jsr 	TIM_WriteHex
.019847	e8		inx				inx
.019848	e0 08		cpx #$08			cpx 	#TIM_Z-TIM_PC
.01984a	f0 e7		beq $019833			beq 	_TIMSR_Skip
.01984c	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.01984e	d0 e4		bne $019834			bne 	_TimSR_LoopSpace
.019850	20 5c 80	jsr $01805c			jsr 	IFT_NewLine 				; new line
.019853	4c 8a 97	jmp $01978a			jmp	 	TIM_NewCommand 				; new command.
.019856					_TIMSR_Label:
>019856	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>01985e	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>01986e	52
>01986f	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.019876					_TIMSR_LabelEnd:
.019876					TIM_WriteHex:
.019876	48		pha				pha 								; save A
.019877	4a		lsr a				lsr 	a 							; shift MSB->LSB
.019878	4a		lsr a				lsr 	a
.019879	4a		lsr a				lsr 	a
.01987a	4a		lsr a				lsr 	a
.01987b	20 7f 98	jsr $01987f			jsr 	_TIMWH_Nibble 				; print MSB
.01987e	68		pla				pla 								; restore and print LSB
.01987f					_TIMWH_Nibble:
.01987f	48		pha				pha
.019880	29 0f		and #$0f			and 	#15 						; mask out
.019882	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.019884	90 02		bcc $019888			bcc 	_TIMWHNoLetter
.019886	69 06		adc #$06			adc 	#6
.019888					_TIMWHNoLetter:
.019888	69 30		adc #$30			adc 	#48
.01988a	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter 			; print it out.
.01988d	68		pla				pla
.01988e	60		rts				rts
.01988f					TIM_WriteLine:
.01988f	a9 2e		lda #$2e			lda 	#"." 						; prompt
.019891	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.019894	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.019896	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.019899	a5 13		lda $13				lda 	zTemp2+1 					; write address
.01989b	20 76 98	jsr $019876			jsr 	TIM_WriteHex
.01989e	a5 12		lda $12				lda 	zTemp2
.0198a0	20 76 98	jsr $019876			jsr 	TIM_WriteHex
.0198a3	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.0198a5					_TIMWL_Loop:
.0198a5	a9 20		lda #$20			lda 	#" "
.0198a7	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0198aa	b1 12		lda ($12),y			lda 	(zTemp2),y
.0198ac	20 76 98	jsr $019876			jsr 	TIM_WriteHex
.0198af	c8		iny				iny
.0198b0	c0 10		cpy #$10			cpy 	#16
.0198b2	d0 f1		bne $0198a5			bne 	_TIMWL_Loop
.0198b4	4c 5c 80	jmp $01805c			jmp 	IFT_NewLine 				; new line and exit
.0198b7					TIM_GetHex:
.0198b7	c8		iny				iny
.0198b8	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.0198ba	c9 20		cmp #$20			cmp 	#32
.0198bc	f0 f9		beq $0198b7			beq 	TIM_GetHex
.0198be	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.0198c0	f0 f5		beq $0198b7			beq 	TIM_GetHex
.0198c2	20 eb 98	jsr $0198eb			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.0198c5	b0 23		bcs $0198ea			bcs 	_TIMGH_Exit					; if first bad then exit now.
.0198c7	a9 00		lda #$00			lda 	#0 							; zero result
.0198c9	85 14		sta $14				sta 	zTemp3
.0198cb	85 15		sta $15				sta 	zTemp3+1
.0198cd					_TIM_GHLoop:
.0198cd	20 eb 98	jsr $0198eb			jsr 	TIM_GetHexCharacter 		; get next character
.0198d0	b0 17		bcs $0198e9			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.0198d2	c8		iny				iny 								; skip over it.
.0198d3	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.0198d5	26 15		rol $15				rol 	zTemp3+1
.0198d7	06 14		asl $14				asl 	zTemp3 						; now x 2
.0198d9	26 15		rol $15				rol 	zTemp3+1
.0198db	06 14		asl $14				asl 	zTemp3						; now x 4
.0198dd	26 15		rol $15				rol 	zTemp3+1
.0198df	06 14		asl $14				asl 	zTemp3 						; now x 8
.0198e1	26 15		rol $15				rol 	zTemp3+1
.0198e3	05 14		ora $14				ora 	zTemp3 						; OR result in
.0198e5	85 14		sta $14				sta 	zTemp3
.0198e7	80 e4		bra $0198cd			bra 	_TIM_GHLoop 				; loop round again.
.0198e9					_TIMGH_Okay:
.0198e9	18		clc				clc
.0198ea					_TIMGH_Exit:
.0198ea	60		rts				rts
.0198eb					TIM_GetHexCharacter:
.0198eb	b1 10		lda ($10),y			lda 	(zTemp1),y
.0198ed	38		sec				sec
.0198ee	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.0198f0	90 0e		bcc $019900			bcc 	_TIM_GHCFail
.0198f2	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.0198f4	90 0b		bcc $019901			bcc 	_TIM_GHCExit
.0198f6	c9 11		cmp #$11			cmp 	#65-48						; < A
.0198f8	90 06		bcc $019900			bcc		_TIM_GHCFail
.0198fa	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.0198fc	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.0198fe	90 01		bcc $019901			bcc		_TIM_GHCExit
.019900					_TIM_GHCFail:
.019900	38		sec				sec
.019901					_TIM_GHCExit:
.019901	60		rts				rts
.019902					TIM_BreakVector:
.019902	da		phx				phx									; save X/A on stack
.019903	48		pha				pha
.019904	ba		tsx				tsx 								; X points to S
.019905	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.019908	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.01990a	d0 03		bne $01990f			bne 	_TIMBreak					; if set, it's BRK
.01990c	68		pla				pla 								; abandon routine.
.01990d	fa		plx				plx
.01990e	40		rti				rti
.01990f					_TIMBreak:
.01990f	68		pla				pla 								; save A X Y and maybe Z
.019910	8d 35 04	sta $0435			sta 	TIM_A
.019913	fa		plx				plx
.019914	8e 36 04	stx $0436			stx 	TIM_X
.019917	8c 37 04	sty $0437			sty 	TIM_Y
.01991a	68		pla				pla 								; get Status Register
.01991b	8d 34 04	sta $0434			sta 	TIM_SR
.01991e	68		pla				pla
.01991f	8d 31 04	sta $0431			sta 	TIM_PC+1 					; save calling address
.019922	68		pla				pla
.019923	8d 30 04	sta $0430			sta 	TIM_PC 						; high byte
.019926	ad 31 04	lda $0431			lda 	TIM_PC+1 					; dec PC to point right.
.019929	d0 03		bne $01992e			bne 	_TIMDecrement 				; brk bumps it.
.01992b	ce 30 04	dec $0430			dec 	TIM_PC
.01992e					_TIMDecrement:
.01992e	ce 31 04	dec $0431			dec 	TIM_PC+1
.019931	ba		tsx				tsx 								; and copy SP
.019932	8e 39 04	stx $0439			stx 	TIM_SP
.019935	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.019937	9a		txs				txs
.019938	4c 17 98	jmp $019817			jmp 	TIM_Start 					; and start up TIM monitor.
.01993b					TIM_UpdateRegisters:
.01993b	20 b7 98	jsr $0198b7			jsr 	TIM_GetHex 					; PC
.01993e	b0 28		bcs $019968			bcs 	_TIMURFail
.019940	a5 14		lda $14				lda 	zTemp3
.019942	8d 31 04	sta $0431			sta 	Tim_PC+1
.019945	a5 15		lda $15				lda 	zTemp3+1
.019947	8d 30 04	sta $0430			sta 	Tim_PC
.01994a	20 b7 98	jsr $0198b7			jsr 	TIM_GetHex 					; ignore IRQ
.01994d	b0 19		bcs $019968			bcs 	_TIMURFail
.01994f	a2 00		ldx #$00			ldx 	#0
.019951					_TIM_URLoop:
.019951	e0 04		cpx #$04			cpx 	#Tim_Z-Tim_SR
.019953	d0 01		bne $019956			bne 	_TIM_1
.019955	e8		inx				inx
.019956					_TIM_1:
.019956	20 b7 98	jsr $0198b7			jsr 	TIM_GetHex 					; registers
.019959	b0 0d		bcs $019968			bcs 	_TIMURFail
.01995b	a5 14		lda $14				lda 	zTemp3
.01995d	9d 34 04	sta $0434,x			sta 	Tim_SR,x
.019960	e8		inx				inx
.019961	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.019963	d0 ec		bne $019951			bne 	_TIM_URLoop
.019965	4c 8a 97	jmp $01978a			jmp 	TIM_NewCommand
.019968					_TIMURFail:
.019968	4c 83 97	jmp $019783			jmp 	TIM_Error
.01996b					TIM_LoadMemory:
.01996b	20 b7 98	jsr $0198b7			jsr 	TIM_GetHex 					; target address => zTemp2
.01996e	a5 14		lda $14				lda 	zTemp3
.019970	85 12		sta $12				sta 	zTemp2
.019972	a5 15		lda $15				lda 	zTemp3+1
.019974	85 13		sta $13				sta 	zTemp2+1
.019976					_TIM_LMLoop:
.019976	20 b7 98	jsr $0198b7			jsr 	TIM_GetHex 					; next byte ?
.019979	b0 0e		bcs $019989			bcs 	_TIMLMDone 					; no more
.01997b	a2 00		ldx #$00			ldx 	#0							; write out.
.01997d	a5 14		lda $14				lda 	zTemp3
.01997f	81 12		sta ($12,x)			sta 	(zTemp2,x)
.019981	e6 12		inc $12				inc 	zTemp2 						; bump address
.019983	d0 f1		bne $019976			bne 	_TIM_LMLoop
.019985	e6 13		inc $13				inc 	zTemp2+1
.019987	80 ed		bra $019976			bra 	_TIM_LMLoop
.019989					_TIMLMDone:
.019989	4c 8a 97	jmp $01978a			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Return to file: basic.asm

>01998c	02						.byte 	2
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 c0						.word 	StartROM
>fffe	19 c0					.word TIM_BreakHandler

;******  End of listing
