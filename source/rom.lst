
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Sat Aug 31 19:52:06 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="65816"				cpu = "65816"
="em65816"				hardware = "em65816"
=1					exitonend = 1
=0					autorun = 0
=1					loadtest = 1
=1					hasfloat = 1
=1					hasinteger = 1
=253					maxstring = 253

;******  Processing file: modules/basic/pointer/em65816/src_em65816.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stackmarkers.inc

=5					SourcePosSize   =   5 							; Source position stack space needed.
=1					SMark_Gosub 	= 	1 							; 0 is GOSUB/RETURN.
=2					SMark_Repeat 	= 	2 							; 1 is REPEAT/UNTIL.
=3					SMark_While 	= 	3 							; 2 is WHILE/WEND.
=4					SMark_If 		= 	4 							; 3 is IF/ENDIF
=5					SMark_For 		= 	5 							; 4 is FOR/NEXT

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/hardware/common/macros32.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0020					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0022					zVarDataPtr: .word ? 						; position of variable data.
>0024					zVarType: 	.byte ? 						; type of data (token)
>0025					zNullString:.byte ? 						; represents a NULL string.
>0026					zBasicSP:	.word ? 						; stack pointer
>0080					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>0084					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>0085					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=134					XS2_Mantissa = XS_Mantissa+XS_Size
=138					XS2_Exponent = XS_Exponent+XS_Size
=139					XS2_Type = XS_Type+XS_Size
=140					XS3_Mantissa = XS_Mantissa+XS_Size*2
=144					XS3_Exponent = XS_Exponent+XS_Size*2
=145					XS3_Type = XS_Type+XS_Size*2
>0300					StringPtr:	.word ? 						; Top of free memory (for string allocation)
>0302					VarMemPtr: 	.word ?							; Bottom of free memory (for variables)
>0304					endOfProgram: .dword ? 						; End of Program Memory (long)
>0308					vecPrintCharacter .word ?
>030a					vecInputCharacter .word ?
>030c					UserVector .fill 4 							; USR(x) calls this.
>0310					LocalVector .fill 4 						; Indirect calls call this.
>0314					NumBufX 	.byte 	?						; buffer index position
>0315					Num_Buffer	.fill 	32 						; buffer for numeric conversions
=6					HashTableCount = 6 							; there are 6 hash tables, in token order.
=8					HashTableSize = 8 							; each hash table as 8 links.
.0335					HashTableBase:
>0335								.fill	HashTableCount * HashTableSize * 2
.0395					HashTableEnd:
=$315					Var_Buffer 	= Num_Buffer 					; buffer for variable name (same space)
>0395					Var_Type    .byte ? 						; type of variable (as a type token)
>0396					Var_Hash 	.byte ? 						; hash of identifier name.
>0397					Var_Length 	.byte ? 						; length of variable name
>0398					Var_HashAddress .byte ?						; low byte of hash table entry.
>0399					Var_DataSize .byte ?						; size of one element.
>039a					NumSuppress	.byte 	?						; leading zero suppression flag
>039b					NumConvCount .byte 	? 						; count for conversions.
>039c					ExpTemp:	.byte ?							; Working temp for exponents.
>039d					ExpCount:	.byte ? 						; Count of decimal exponents.
>039e					SignCount:	.byte ?							; Integer Divide Sign Counts.
>039f					TempStringWriteIndex: .byte ? 				; Write offset.
>03a0					ValSign: 	.byte ? 						; sign flag for val()
>03a1					SliceStart:	.byte ? 						; string slice parts
>03a2					SliceCount:	.byte ?
>03a3					RandomSeed:	.dword ? 						; Random seed.
>03a7					SignNext:	.byte ? 						; Used for keeping sign of STEP in FOR/NEXT
>03a8					BreakCount:	.byte ? 						; Counter, avoid checking break every command.
=3					ArrayMaxDim = 3 							; number of dimensions.
>03a9					ArrayDef:	.fill (ArrayMaxDim+1)*2 		; dimensions for auto-creation
>03b1					UsrArrayDef:.fill (ArrayMaxDim+1)*2 		; dimensions created in DIM
>03b9					UsrArrayIdx:.byte ? 						; index into UsrArrayDef
>03ba					LastPrinted:.byte ? 						; last printed char ?
>03bb					ListIndent: .byte ? 						; list indent level
>03bc					LastListIndent:.byte ? 						; previous one.
>03bd					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>03bf					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>03c1					Tim_SR:		.byte ? 						; Processor Status
>03c2					Tim_A:		.byte ? 						; Processor Registers
>03c3					Tim_X:		.byte ?
>03c4					Tim_Y:		.byte ?
>03c5					Tim_Z:		.byte ?
>03c6					Tim_SP:		.word ?							; Stack Pointer (just in cases)
>0400					BasicStack:	.fill 	256 					; and occupy whole pages.
.0500					EndBasicStack:
>0500					IFT_XCursor:.byte ?							; current logical position on screen
>0501					IFT_YCursor:.byte ?
>0502					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0566					IFT_LineBuffer: .fill 100 					; line input buffer.

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/em65816.asm

=$7f00					HighMemory = $7F00
=$3000					VariableMemory = $3000
.1000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testcode.src

>1000	0a 64 00 92 09 84 41 c8			.byte	$0a,$64,$00,$92,$09,$84,$41,$c8
>1008	45 00 12 6e 00 d3 09 ca			.byte	$45,$00,$12,$6e,$00,$d3,$09,$ca
>1010	43 48 bf 44 6c bf 46 50			.byte	$43,$48,$bf,$44,$6c,$bf,$46,$50
>1018	bf 47 74 00 06 78 00 97			.byte	$bf,$47,$74,$00,$06,$78,$00,$97
>1020	09 00 05 82 00 c4 00 0e			.byte	$09,$00,$05,$82,$00,$c4,$00,$0e
>1028	c8 00 d6 09 bf fe 05 32			.byte	$c8,$00,$d6,$09,$bf,$fe,$05,$32
>1030	30 30 c0 cb 00 0e 2c 01			.byte	$30,$30,$c0,$cb,$00,$0e,$2c,$01
>1038	d6 09 bf fe 05 33 30 30			.byte	$d6,$09,$bf,$fe,$05,$33,$30,$30
>1040	c0 cb 00 0e 90 01 d6 09			.byte	$c0,$cb,$00,$0e,$90,$01,$d6,$09
>1048	bf fe 05 34 30 30 c0 cb			.byte	$bf,$fe,$05,$34,$30,$30,$c0,$cb
>1050	00 0e f4 01 d6 09 bf fe			.byte	$00,$0e,$f4,$01,$d6,$09,$bf,$fe
>1058	05 35 30 30 c0 cb 00 00			.byte	$05,$35,$30,$30,$c0,$cb,$00,$00

;******  Return to file: modules/hardware/em65816.asm

.c000					StartROM:
.c000	18		clc				clc
.c001	fb		xce				xce
.c002	c2 30		rep #$30			rep 	#$30
.c004	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.c007	1b		tcs				tcs
.c008	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.c00b	e2 30		sep #$30			sep 	#$30
.c00d	c2 30		rep #$30			rep 	#$30						; clear AXY in 16 bit.
.c00f	a9 00		lda #$00			lda 	#$0000
.c011	aa		tax				tax
.c012	a8		tay				tay
.c013	e2 30		sep #$30			sep 	#$30
.c015	5c df 87 01	jmp $0187df		jmp BASIC_Start
.c019					TIM_BreakHandler:
.c019	5c 76 83 01	jmp $018376			jmp 	TIM_BreakVector

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.018000					IFT_ClearScreen:
.018000	48		pha				pha
.018001	da		phx				phx
.018002	5a		phy				phy
.018003	20 a9 81	jsr $0181a9			jsr 	IF_Home 					; home cursor
.018006	a2 20		ldx #$20			ldx 	#IF_Height 					; this many lines.
.018008					_IFT_CS0:
.018008	a0 40		ldy #$40			ldy 	#IF_Width 					; this many chars/line
.01800a					_IFT_CS1:
.01800a	a9 20		lda #$20			lda 	#' '						; clear line.
.01800c	20 d5 81	jsr $0181d5			jsr 	IF_Write
.01800f	88		dey				dey
.018010	d0 f8		bne $01800a			bne 	_IFT_CS1
.018012	20 bc 81	jsr $0181bc			jsr 	IF_NewLine 					; next line down
.018015	ca		dex				dex
.018016	d0 f0		bne $018008			bne 	_IFT_CS0
.018018	7a		ply				ply
.018019	fa		plx				plx
.01801a	68		pla				pla
.01801b					IFT_HomeCursor:
.01801b	48		pha				pha
.01801c	20 a9 81	jsr $0181a9			jsr 	IF_Home
.01801f	a9 00		lda #$00			lda 	#0
.018021	8d 00 05	sta $0500			sta 	IFT_XCursor
.018024	8d 01 05	sta $0501			sta 	IFT_YCursor
.018027	68		pla				pla
.018028	60		rts				rts
.018029					IFT_UpLine:
.018029	48		pha				pha
.01802a	ad 01 05	lda $0501			lda  	IFT_YCursor 				; get Y
.01802d	3a		dec a				dec 	a 							; line above
.01802e	30 03		bmi $018033			bmi 	_IFTULExit 					; too far, abort
.018030	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos					; set to that line.
.018033					_IFTULExit:
.018033	68		pla				pla
.018034	60		rts				rts
.018035					IFT_PrintCharacter:
.018035	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.018037	f0 23		beq $01805c			beq 	IFT_NewLine
.018039	48		pha				pha
.01803a	20 74 80	jsr $018074			jsr 	IFT_UpperCase 				; make upper case
.01803d	20 d5 81	jsr $0181d5			jsr 	IF_Write 					; write out.
.018040	ee 00 05	inc $0500			inc 	IFT_XCursor 				; bump x cursor
.018043	ad 00 05	lda $0500			lda 	IFT_XCursor 				; reached RHS ?
.018046	c9 40		cmp #$40			cmp 	#IF_Width
.018048	d0 03		bne $01804d			bne 	_IFT_PCNotEOL
.01804a	20 5c 80	jsr $01805c			jsr 	IFT_NewLine 				; if so do new line.
.01804d					_IFT_PCNotEOL:
.01804d	68		pla				pla
.01804e	60		rts				rts
.01804f					IFT_Tab:
.01804f	a9 20		lda #$20			lda 	#" " 						; space
.018051	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018054	ad 00 05	lda $0500			lda 	IFT_XCursor 				; until x % 8 == 0
.018057	29 07		and #$07			and 	#7
.018059	d0 f4		bne $01804f			bne 	IFT_Tab
.01805b	60		rts				rts
.01805c					IFT_NewLine:
.01805c	48		pha				pha
.01805d	20 bc 81	jsr $0181bc			jsr 	IF_NewLine 					; new line on actual screen.
.018060	a9 00		lda #$00			lda 	#0 							; reset x position
.018062	8d 00 05	sta $0500			sta 	IFT_XCursor
.018065	ee 01 05	inc $0501			inc 	IFT_YCursor 				; move down.
.018068	ad 01 05	lda $0501			lda 	IFT_YCursor
.01806b	c9 20		cmp #$20			cmp 	#IF_Height 					; reached bottom.
.01806d	d0 03		bne $018072			bne 	_IFT_NL_NotEOS
.01806f	20 7f 80	jsr $01807f			jsr 	IFT_Scroll 					; scroll screen up.
.018072					_IFT_NL_NotEOS:
.018072	68		pla				pla
.018073	60		rts				rts
.018074					IFT_UpperCase:
.018074	c9 61		cmp #$61			cmp 	#"a"
.018076	90 06		bcc $01807e			bcc 	_IFT_UCExit
.018078	c9 7b		cmp #$7b			cmp 	#"z"+1
.01807a	b0 02		bcs $01807e			bcs 	_IFT_UCExit
.01807c	49 20		eor #$20			eor 	#$20
.01807e					_IFT_UCExit:
.01807e	60		rts				rts
.01807f					IFT_Scroll:
.01807f	48		pha				pha 								; save AXY
.018080	da		phx				phx
.018081	5a		phy				phy
.018082	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.018084					_IFT_SLoop:
.018084	20 a4 80	jsr $0180a4			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.018087	e8		inx				inx
.018088	e0 1f		cpx #$1f			cpx 	#IF_Height-1				; do whole screen
.01808a	d0 f8		bne $018084			bne 	_IFT_SLoop
.01808c	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.01808e	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.018091	a2 40		ldx #$40			ldx 	#IF_Width 					; blank line
.018093					_IFT_SBlank:
.018093	a9 20		lda #$20			lda 	#32
.018095	20 d5 81	jsr $0181d5			jsr 	IF_Write
.018098	ca		dex				dex
.018099	d0 f8		bne $018093			bne 	_IFT_SBlank
.01809b	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.01809d	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.0180a0	7a		ply				ply
.0180a1	fa		plx				plx
.0180a2	68		pla				pla
.0180a3	60		rts				rts
.0180a4					_IFT_ScrollLine:
.0180a4	da		phx				phx
.0180a5	da		phx				phx
.0180a6	8a		txa				txa 								; copy line into buffer.
.0180a7	1a		inc a				inc 	a 							; next line down.
.0180a8	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.0180ab	a2 00		ldx #$00			ldx 	#0
.0180ad					_IFTScrollCopy1:
.0180ad	20 cc 81	jsr $0181cc			jsr 	IF_Read
.0180b0	9d 02 05	sta $0502,x			sta 	IFT_Buffer,x
.0180b3	e8		inx				inx
.0180b4	e0 40		cpx #$40			cpx 	#IF_Width
.0180b6	d0 f5		bne $0180ad			bne 	_IFTScrollCopy1
.0180b8	68		pla				pla
.0180b9	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.0180bc	a2 00		ldx #$00			ldx 	#0
.0180be					_IFTScrollCopy2:
.0180be	bd 02 05	lda $0502,x			lda 	IFT_Buffer,x
.0180c1	20 d5 81	jsr $0181d5			jsr 	IF_Write
.0180c4	e8		inx				inx
.0180c5	e0 40		cpx #$40			cpx 	#IF_Width
.0180c7	d0 f5		bne $0180be			bne 	_IFTScrollCopy2
.0180c9	fa		plx				plx
.0180ca	60		rts				rts
.0180cb					IFT_SetYPos:
.0180cb	48		pha				pha
.0180cc	da		phx				phx
.0180cd	aa		tax				tax
.0180ce	20 1b 80	jsr $01801b			jsr 	IFT_HomeCursor
.0180d1	e0 00		cpx #$00			cpx 	#0
.0180d3	f0 09		beq $0180de			beq 	_IFT_MOAExit
.0180d5					_IFT_MOALoop:
.0180d5	20 bc 81	jsr $0181bc			jsr 	IF_NewLine
.0180d8	ee 01 05	inc $0501			inc 	IFT_YCursor
.0180db	ca		dex				dex
.0180dc	d0 f7		bne $0180d5			bne		_IFT_MOALoop
.0180de					_IFT_MOAExit:
.0180de	fa		plx				plx
.0180df	68		pla				pla
.0180e0	60		rts				rts
.0180e1					IFT_GetKeyCursor:
.0180e1	20 e9 80	jsr $0180e9			jsr 	_IFT_FlipCursor 			; reverse current
.0180e4					_IFT_GKCWait:
.0180e4	20 e6 81	jsr $0181e6			jsr 	IF_GetKey 					; get key
.0180e7	f0 fb		beq $0180e4			beq 	_IFT_GKCWait
.0180e9					_IFT_FlipCursor:
.0180e9	48		pha				pha 								; save
.0180ea	20 cc 81	jsr $0181cc			jsr 	IF_Read 					; read
.0180ed	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.0180f0	49 80		eor #$80			eor 	#$80 						; reverse
.0180f2	20 d5 81	jsr $0181d5			jsr 	IF_Write 					; write
.0180f5	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.0180f8	68		pla				pla
.0180f9	60		rts				rts
.0180fa					IFT_ReadLine:
.0180fa	48		pha				pha
.0180fb					_IFT_RLLoop:
.0180fb	20 e1 80	jsr $0180e1			jsr 	IFT_GetKeyCursor 			; get keystroke
.0180fe	c9 0d		cmp #$0d			cmp 	#13							; return
.018100	f0 7d		beq $01817f			beq 	_IFT_RLExit
.018102	c9 20		cmp #$20			cmp 	#32 						; control character
.018104	90 05		bcc $01810b			bcc 	_IFT_Control
.018106	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018109	80 f0		bra $0180fb			bra 	_IFT_RLLoop
.01810b					_IFT_Control:
.01810b	c9 01		cmp #$01			cmp 	#"A"-64
.01810d	f0 26		beq $018135			beq 	_IFT_Left
.01810f	c9 04		cmp #$04			cmp 	#"D"-64
.018111	f0 2e		beq $018141			beq 	_IFT_Right
.018113	c9 17		cmp #$17			cmp 	#"W"-64
.018115	f0 36		beq $01814d			beq 	_IFT_Up
.018117	c9 13		cmp #$13			cmp 	#"S"-64
.018119	f0 3e		beq $018159			beq 	_IFT_Down
.01811b	c9 08		cmp #$08			cmp 	#"H"-64
.01811d	f0 09		beq $018128			beq 	_IFT_Backspace
.01811f	c9 1a		cmp #$1a			cmp 	#"Z"-64
.018121	d0 d8		bne $0180fb			bne 	_IFT_RLLoop
.018123	20 00 80	jsr $018000			jsr 	IFT_ClearScreen				; clear CTL-Z
.018126	80 d3		bra $0180fb			bra 	_IFT_RLLoop
.018128					_IFT_Backspace:
.018128	ad 00 05	lda $0500			lda 	IFT_XCursor 				; check not start of line.
.01812b	f0 ce		beq $0180fb			beq 	_IFT_RLLoop
.01812d	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.018130	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.018132	20 d5 81	jsr $0181d5			jsr 	IF_Write
.018135					_IFT_Left:
.018135	ce 00 05	dec $0500			dec 	IFT_XCursor 				; left CTL-W
.018138	10 29		bpl $018163			bpl 	_IFT_Reposition
.01813a	a9 3f		lda #$3f			lda 	#IF_Width-1
.01813c					_IFT_SetX:
.01813c	8d 00 05	sta $0500			sta 	IFT_XCursor
.01813f	80 22		bra $018163			bra 	_IFT_Reposition
.018141					_IFT_Right:
.018141	ee 00 05	inc $0500			inc 	IFT_XCursor
.018144	ad 00 05	lda $0500			lda 	IFT_XCursor
.018147	49 40		eor #$40			eor 	#IF_Width
.018149	f0 f1		beq $01813c			beq 	_IFT_SetX
.01814b	80 16		bra $018163			bra 	_IFT_Reposition
.01814d					_IFT_Up:
.01814d	ce 01 05	dec $0501			dec 	IFT_YCursor
.018150	10 11		bpl $018163			bpl 	_IFT_Reposition
.018152	a9 1f		lda #$1f			lda 	#IF_Height-1
.018154					_IFT_SetY:
.018154	8d 01 05	sta $0501			sta 	IFT_YCursor
.018157	80 0a		bra $018163			bra 	_IFT_Reposition
.018159					_IFT_Down:
.018159	ee 01 05	inc $0501			inc 	IFT_YCursor
.01815c	ad 01 05	lda $0501			lda 	IFT_YCursor
.01815f	49 20		eor #$20			eor 	#IF_Height
.018161	f0 f1		beq $018154			beq 	_IFT_SetY
.018163					_IFT_Reposition:
.018163	ad 00 05	lda $0500			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.018166	48		pha				pha
.018167	ad 01 05	lda $0501			lda 	IFT_YCursor
.01816a	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.01816d	68		pla				pla
.01816e	aa		tax				tax
.01816f	e0 00		cpx #$00			cpx 	#0
.018171	f0 88		beq $0180fb			beq 	_IFT_RLLoop
.018173					_IFT_MoveRight:
.018173	20 cc 81	jsr $0181cc			jsr 	IF_Read
.018176	ee 00 05	inc $0500			inc 	IFT_XCursor
.018179	ca		dex				dex
.01817a	d0 f7		bne $018173			bne 	_IFT_MoveRight
.01817c	4c fb 80	jmp $0180fb			jmp 	_IFT_RLLoop
.01817f					_IFT_RLExit:
.01817f	ad 01 05	lda $0501			lda 	IFT_YCursor 				; go to start of line.
.018182	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.018185	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.018187					_IFT_RLRead:
.018187	20 cc 81	jsr $0181cc			jsr 	IF_Read
.01818a	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.01818d	e8		inx				inx
.01818e	e0 40		cpx #$40			cpx 	#IF_Width
.018190	d0 f5		bne $018187			bne 	_IFT_RLRead
.018192					_IFT_RL_Trim:
.018192	ca		dex				dex 	 							; previous char
.018193	30 07		bmi $01819c			bmi 	_IFT_Found 					; gone too far
.018195	bd 66 05	lda $0566,x			lda 	IFT_LineBuffer,x			; go back if space
.018198	c9 20		cmp #$20			cmp 	#" "
.01819a	f0 f6		beq $018192			beq 	_IFT_RL_Trim
.01819c					_IFT_Found:
.01819c	e8		inx				inx 								; forward to non-space
.01819d	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.01819f	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.0181a2	68		pla				pla
.0181a3	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.0181a5	a0 05		ldy #$05			ldy 	#IFT_LineBuffer >> 8
.0181a7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_em65816.asm

=64					IF_Width 	= 64 							; characters across
=32					IF_Height 	= 32 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line.
=8					IF_XPos 	= 8 							; current position, horizontal.
=$f0000					IF_Screen = $F0000							; 2k screen RAM here
=$f8010					IF_PKeyboard = $F8010						; Keyboard port.
=$f8000					IF_PBreak = $F8000 							; Break key.
.0181a8					IF_Reset:
.0181a8	60		rts				rts
.0181a9					IF_Home:
.0181a9	48		pha				pha
.0181aa	64 08		stz $08				stz 	IF_XPos 					; zero X position
.0181ac	a9 00		lda #$00			lda 	#IF_Screen & $FF 			; set r/w pos.
.0181ae	85 04		sta $04				sta 	IF_Pos
.0181b0	a9 00		lda #$00			lda 	#(IF_Screen >> 8) & $FF
.0181b2	85 05		sta $05				sta 	IF_Pos+1
.0181b4	a9 0f		lda #$0f			lda 	#IF_Screen >> 16
.0181b6	85 06		sta $06				sta 	IF_Pos+2
.0181b8	64 07		stz $07				stz 	IF_Pos+3
.0181ba	68		pla				pla
.0181bb	60		rts				rts
.0181bc					IF_NewLine:
.0181bc	48		pha				pha
.0181bd	64 08		stz $08				stz 	IF_XPos						; back to start of line
.0181bf	18		clc				clc 								; down one line
.0181c0	a5 04		lda $04				lda 	IF_Pos
.0181c2	69 40		adc #$40			adc 	#64
.0181c4	85 04		sta $04				sta 	IF_Pos
.0181c6	90 02		bcc $0181ca			bcc 	_IF_NoCarry 				; carry through.
.0181c8	e6 05		inc $05				inc 	IF_Pos+1
.0181ca					_IF_NoCarry:
.0181ca	68		pla				pla
.0181cb	60		rts				rts
.0181cc					IF_Read:
.0181cc	5a		phy				phy 								; save current Y
.0181cd	a4 08		ldy $08				ldy 	IF_XPos 					; read character at current position
.0181cf	b7 04		lda [$04],y			lda 	[IF_Pos],y
.0181d1	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181d3	7a		ply				ply									; restore Y
.0181d4	60		rts				rts
.0181d5					IF_Write:
.0181d5	5a		phy				phy 								; save current Y
.0181d6	a4 08		ldy $08				ldy 	IF_XPos 					; write character at current position
.0181d8	97 04		sta [$04],y			sta 	[IF_Pos],y
.0181da	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181dc	7a		ply				ply									; restore Y
.0181dd	60		rts				rts
.0181de					IF_LeftOne:
.0181de	c6 08		dec $08				dec 	IF_XPos
.0181e0	60		rts				rts
.0181e1					IF_CheckBreak:
.0181e1	af 00 80 0f	lda $0f8000			lda 	IF_PBreak					; non-zero if Ctrl+C pressed.
.0181e5	60		rts				rts
.0181e6					IF_GetKey:
.0181e6	af 10 80 0f	lda $0f8010			lda 	IF_PKeyboard				; read keyboard
.0181ea	f0 08		beq $0181f4			beq		_IFGK_NoKey 				; skip if zero,no key pressed
.0181ec	48		pha				pha 								; key pressed, clear queue.
.0181ed	a9 00		lda #$00			lda 	#0
.0181ef	8f 10 80 0f	sta $0f8010			sta 	IF_PKeyboard
.0181f3	68		pla				pla
.0181f4					_IFGK_NoKey:
.0181f4	09 00		ora #$00			ora 	#0							; set Z flag appropriately.
.0181f6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.0181f7					TIM_Error:
.0181f7	20 29 80	jsr $018029			jsr 	IFT_UpLine 					; go up one line.
.0181fa	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.0181fc	80 02		bra $018200			bra 	TIM_ShowPrompt
.0181fe					TIM_NewCommand:
.0181fe	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.018200					TIM_ShowPrompt:
.018200	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.018203	20 fa 80	jsr $0180fa			jsr 	IFT_ReadLine	 			; get character, go to next line
.018206	20 5c 80	jsr $01805c			jsr 	IFT_NewLine					; go to next line.
.018209	86 10		stx $10				stx 	zTemp1 						; save line read address
.01820b	84 11		sty $11				sty 	zTemp1+1
.01820d	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.01820f	b1 10		lda ($10),y			lda 	(zTemp1),y
.018211	c9 3f		cmp #$3f			cmp 	#"?"
.018213	f0 04		beq $018219			beq 	TIM_SkipFirst
.018215	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.018217	d0 01		bne $01821a			bne 	TIM_NotDot
.018219					TIM_SkipFirst:
.018219	c8		iny				iny
.01821a					TIM_NotDot:
.01821a	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.01821c	c9 52		cmp #$52			cmp 	#"R"						; show registers
.01821e	f0 6b		beq $01828b			beq 	TIM_ShowRegisters
.018220	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.018222	f0 12		beq $018236			beq 	TIM_ShowMemory
.018224	c9 47		cmp #$47			cmp 	#"G"						; execute
.018226	f0 49		beq $018271			beq 	TIM_Execute
.018228	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.01822a	f0 07		beq $018233			beq 	TIM_GoLoadMemory
.01822c	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.01822e	d0 c7		bne $0181f7			bne 	TIM_Error
.018230	4c af 83	jmp $0183af			jmp 	TIM_UpdateRegisters
.018233					TIM_GoLoadMemory:
.018233	4c df 83	jmp $0183df			jmp 	TIM_LoadMemory
.018236					TIM_ShowMemory:
.018236	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.018239	b0 bc		bcs $0181f7			bcs 	TIM_Error
.01823b	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.01823d	85 12		sta $12				sta 	zTemp2
.01823f	a5 15		lda $15				lda 	zTemp3+1
.018241	85 13		sta $13				sta 	zTemp2+1
.018243	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.018246	90 08		bcc $018250			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.018248	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.01824a	85 14		sta $14				sta 	zTemp3
.01824c	a5 13		lda $13				lda 	zTemp2+1
.01824e	85 15		sta $15				sta 	zTemp3+1
.018250					_TIMSM_Start:
.018250	20 03 83	jsr $018303			jsr 	TIM_WriteLine 				; write one line of hex out
.018253	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.018255	18		clc				clc
.018256	69 10		adc #$10			adc 	#16
.018258	85 12		sta $12				sta 	zTemp2
.01825a	90 02		bcc $01825e			bcc 	_TIMSM_NoCarry
.01825c	e6 13		inc $13				inc 	zTemp2+1
.01825e					_TIMSM_NoCarry:
.01825e	20 e1 81	jsr $0181e1			jsr 	IF_CheckBreak 				; check CTL+C
.018261	d0 0b		bne $01826e			bne 	_TIMSM_Ends 				; if pressed break out.
.018263	38		sec				sec 								; check past the end address in zTemp3
.018264	a5 14		lda $14				lda 	zTemp3
.018266	e5 12		sbc $12				sbc 	zTemp2
.018268	a5 15		lda $15				lda 	zTemp3+1
.01826a	e5 13		sbc $13				sbc 	zTemp2+1
.01826c	10 e2		bpl $018250			bpl 	_TIMSM_Start
.01826e					_TIMSM_Ends:
.01826e	4c fe 81	jmp $0181fe			jmp 	TIM_NewCommand
.018271					TIM_Execute:
.018271	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; get the execute address
.018274	b0 81		bcs $0181f7			bcs 	TIM_Error 					; not legitimate
.018276	ae c6 03	ldx $03c6			ldx 	TIM_SP 						; set up SP
.018279	9a		txs				txs
.01827a	ad c1 03	lda $03c1			lda 	TIM_SR 						; Status for PLP
.01827d	48		pha				pha
.01827e	ad c2 03	lda $03c2			lda 	TIM_A 						; restore AXYZ
.018281	ae c3 03	ldx $03c3			ldx 	TIM_X
.018284	ac c4 03	ldy $03c4			ldy 	TIM_Y
.018287	28		plp				plp 								; and PS Byte.
.018288	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.01828b					TIM_Start:
.01828b					TIM_ShowRegisters:
.01828b	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.01828e	8d c0 03	sta $03c0			sta 	TIM_IRQ+1
.018291	ad ff ff	lda $ffff			lda 	$FFFF
.018294	8d bf 03	sta $03bf			sta 	TIM_IRQ
.018297	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.018299					_TIMSR_Text:
.018299	bf ca 82 01	lda $0182ca,x			lda 	_TIMSR_Label,x
.01829d	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182a0	e8		inx				inx
.0182a1	e0 20		cpx #$20			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.0182a3	d0 f4		bne $018299			bne 	_TIMSR_Text
.0182a5	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.0182a7					_TIMSR_Skip:
.0182a7	e8		inx				inx
.0182a8					_TIMSR_LoopSpace:
.0182a8	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.0182aa	b0 04		bcs $0182b0			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.0182ac	8a		txa				txa
.0182ad	4a		lsr a				lsr 	a
.0182ae	b0 05		bcs $0182b5			bcs 	_TIMSR_NoSpace
.0182b0					_TIMSR_Space:
.0182b0	a9 20		lda #$20			lda 	#" "
.0182b2	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182b5					_TIMSR_NoSpace:
.0182b5	bd bd 03	lda $03bd,x			lda 	TIM_PC,x 					; output hex value.
.0182b8	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.0182bb	e8		inx				inx
.0182bc	e0 08		cpx #$08			cpx 	#TIM_Z-TIM_PC
.0182be	f0 e7		beq $0182a7			beq 	_TIMSR_Skip
.0182c0	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.0182c2	d0 e4		bne $0182a8			bne 	_TimSR_LoopSpace
.0182c4	20 5c 80	jsr $01805c			jsr 	IFT_NewLine 				; new line
.0182c7	4c fe 81	jmp $0181fe			jmp	 	TIM_NewCommand 				; new command.
.0182ca					_TIMSR_Label:
>0182ca	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>0182d2	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>0182e2	52
>0182e3	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.0182ea					_TIMSR_LabelEnd:
.0182ea					TIM_WriteHex:
.0182ea	48		pha				pha 								; save A
.0182eb	4a		lsr a				lsr 	a 							; shift MSB->LSB
.0182ec	4a		lsr a				lsr 	a
.0182ed	4a		lsr a				lsr 	a
.0182ee	4a		lsr a				lsr 	a
.0182ef	20 f3 82	jsr $0182f3			jsr 	_TIMWH_Nibble 				; print MSB
.0182f2	68		pla				pla 								; restore and print LSB
.0182f3					_TIMWH_Nibble:
.0182f3	48		pha				pha
.0182f4	29 0f		and #$0f			and 	#15 						; mask out
.0182f6	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.0182f8	90 02		bcc $0182fc			bcc 	_TIMWHNoLetter
.0182fa	69 06		adc #$06			adc 	#6
.0182fc					_TIMWHNoLetter:
.0182fc	69 30		adc #$30			adc 	#48
.0182fe	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter 			; print it out.
.018301	68		pla				pla
.018302	60		rts				rts
.018303					TIM_WriteLine:
.018303	a9 2e		lda #$2e			lda 	#"." 						; prompt
.018305	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018308	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.01830a	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01830d	a5 13		lda $13				lda 	zTemp2+1 					; write address
.01830f	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.018312	a5 12		lda $12				lda 	zTemp2
.018314	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.018317	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.018319					_TIMWL_Loop:
.018319	a9 20		lda #$20			lda 	#" "
.01831b	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01831e	b1 12		lda ($12),y			lda 	(zTemp2),y
.018320	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.018323	c8		iny				iny
.018324	c0 10		cpy #$10			cpy 	#16
.018326	d0 f1		bne $018319			bne 	_TIMWL_Loop
.018328	4c 5c 80	jmp $01805c			jmp 	IFT_NewLine 				; new line and exit
.01832b					TIM_GetHex:
.01832b	c8		iny				iny
.01832c	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.01832e	c9 20		cmp #$20			cmp 	#32
.018330	f0 f9		beq $01832b			beq 	TIM_GetHex
.018332	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.018334	f0 f5		beq $01832b			beq 	TIM_GetHex
.018336	20 5f 83	jsr $01835f			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.018339	b0 23		bcs $01835e			bcs 	_TIMGH_Exit					; if first bad then exit now.
.01833b	a9 00		lda #$00			lda 	#0 							; zero result
.01833d	85 14		sta $14				sta 	zTemp3
.01833f	85 15		sta $15				sta 	zTemp3+1
.018341					_TIM_GHLoop:
.018341	20 5f 83	jsr $01835f			jsr 	TIM_GetHexCharacter 		; get next character
.018344	b0 17		bcs $01835d			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.018346	c8		iny				iny 								; skip over it.
.018347	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.018349	26 15		rol $15				rol 	zTemp3+1
.01834b	06 14		asl $14				asl 	zTemp3 						; now x 2
.01834d	26 15		rol $15				rol 	zTemp3+1
.01834f	06 14		asl $14				asl 	zTemp3						; now x 4
.018351	26 15		rol $15				rol 	zTemp3+1
.018353	06 14		asl $14				asl 	zTemp3 						; now x 8
.018355	26 15		rol $15				rol 	zTemp3+1
.018357	05 14		ora $14				ora 	zTemp3 						; OR result in
.018359	85 14		sta $14				sta 	zTemp3
.01835b	80 e4		bra $018341			bra 	_TIM_GHLoop 				; loop round again.
.01835d					_TIMGH_Okay:
.01835d	18		clc				clc
.01835e					_TIMGH_Exit:
.01835e	60		rts				rts
.01835f					TIM_GetHexCharacter:
.01835f	b1 10		lda ($10),y			lda 	(zTemp1),y
.018361	38		sec				sec
.018362	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.018364	90 0e		bcc $018374			bcc 	_TIM_GHCFail
.018366	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.018368	90 0b		bcc $018375			bcc 	_TIM_GHCExit
.01836a	c9 11		cmp #$11			cmp 	#65-48						; < A
.01836c	90 06		bcc $018374			bcc		_TIM_GHCFail
.01836e	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.018370	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.018372	90 01		bcc $018375			bcc		_TIM_GHCExit
.018374					_TIM_GHCFail:
.018374	38		sec				sec
.018375					_TIM_GHCExit:
.018375	60		rts				rts
.018376					TIM_BreakVector:
.018376	da		phx				phx									; save X/A on stack
.018377	48		pha				pha
.018378	ba		tsx				tsx 								; X points to S
.018379	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.01837c	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.01837e	d0 03		bne $018383			bne 	_TIMBreak					; if set, it's BRK
.018380	68		pla				pla 								; abandon routine.
.018381	fa		plx				plx
.018382	40		rti				rti
.018383					_TIMBreak:
.018383	68		pla				pla 								; save A X Y and maybe Z
.018384	8d c2 03	sta $03c2			sta 	TIM_A
.018387	fa		plx				plx
.018388	8e c3 03	stx $03c3			stx 	TIM_X
.01838b	8c c4 03	sty $03c4			sty 	TIM_Y
.01838e	68		pla				pla 								; get Status Register
.01838f	8d c1 03	sta $03c1			sta 	TIM_SR
.018392	68		pla				pla
.018393	8d be 03	sta $03be			sta 	TIM_PC+1 					; save calling address
.018396	68		pla				pla
.018397	8d bd 03	sta $03bd			sta 	TIM_PC 						; high byte
.01839a	ad be 03	lda $03be			lda 	TIM_PC+1 					; dec PC to point right.
.01839d	d0 03		bne $0183a2			bne 	_TIMDecrement 				; brk bumps it.
.01839f	ce bd 03	dec $03bd			dec 	TIM_PC
.0183a2					_TIMDecrement:
.0183a2	ce be 03	dec $03be			dec 	TIM_PC+1
.0183a5	ba		tsx				tsx 								; and copy SP
.0183a6	8e c6 03	stx $03c6			stx 	TIM_SP
.0183a9	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.0183ab	9a		txs				txs
.0183ac	4c 8b 82	jmp $01828b			jmp 	TIM_Start 					; and start up TIM monitor.
.0183af					TIM_UpdateRegisters:
.0183af	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; PC
.0183b2	b0 28		bcs $0183dc			bcs 	_TIMURFail
.0183b4	a5 14		lda $14				lda 	zTemp3
.0183b6	8d be 03	sta $03be			sta 	Tim_PC+1
.0183b9	a5 15		lda $15				lda 	zTemp3+1
.0183bb	8d bd 03	sta $03bd			sta 	Tim_PC
.0183be	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; ignore IRQ
.0183c1	b0 19		bcs $0183dc			bcs 	_TIMURFail
.0183c3	a2 00		ldx #$00			ldx 	#0
.0183c5					_TIM_URLoop:
.0183c5	e0 04		cpx #$04			cpx 	#Tim_Z-Tim_SR
.0183c7	d0 01		bne $0183ca			bne 	_TIM_1
.0183c9	e8		inx				inx
.0183ca					_TIM_1:
.0183ca	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; registers
.0183cd	b0 0d		bcs $0183dc			bcs 	_TIMURFail
.0183cf	a5 14		lda $14				lda 	zTemp3
.0183d1	9d c1 03	sta $03c1,x			sta 	Tim_SR,x
.0183d4	e8		inx				inx
.0183d5	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.0183d7	d0 ec		bne $0183c5			bne 	_TIM_URLoop
.0183d9	4c fe 81	jmp $0181fe			jmp 	TIM_NewCommand
.0183dc					_TIMURFail:
.0183dc	4c f7 81	jmp $0181f7			jmp 	TIM_Error
.0183df					TIM_LoadMemory:
.0183df	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; target address => zTemp2
.0183e2	a5 14		lda $14				lda 	zTemp3
.0183e4	85 12		sta $12				sta 	zTemp2
.0183e6	a5 15		lda $15				lda 	zTemp3+1
.0183e8	85 13		sta $13				sta 	zTemp2+1
.0183ea					_TIM_LMLoop:
.0183ea	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; next byte ?
.0183ed	b0 0e		bcs $0183fd			bcs 	_TIMLMDone 					; no more
.0183ef	a2 00		ldx #$00			ldx 	#0							; write out.
.0183f1	a5 14		lda $14				lda 	zTemp3
.0183f3	81 12		sta ($12,x)			sta 	(zTemp2,x)
.0183f5	e6 12		inc $12				inc 	zTemp2 						; bump address
.0183f7	d0 f1		bne $0183ea			bne 	_TIM_LMLoop
.0183f9	e6 13		inc $13				inc 	zTemp2+1
.0183fb	80 ed		bra $0183ea			bra 	_TIM_LMLoop
.0183fd					_TIMLMDone:
.0183fd	4c fe 81	jmp $0181fe			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/skip.asm

.018400					StructureSearchSingle:
.018400	a2 00		ldx #$00			ldx 	#0
.018402					StructureSearchDouble:
.018402	85 10		sta $10				sta 	zTemp1 						; save the target on zTemp1,zTemp1+1
.018404	86 11		stx $11				stx 	zTemp1+1
.018406	a9 00		lda #$00			lda 	#0 							; set the structure depth to zero (zTemp2)
.018408	85 12		sta $12				sta 	zTemp2
.01840a	80 18		bra $018424			bra 	_SSWLoop 					; jump in, start scanning from here.
.01840c					_SSWNextLine:
.01840c	a0 00		ldy #$00			ldy 	#0 							; point to offset
.01840e	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.018410	18		clc				clc
.018411	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018413	85 16		sta $16				sta 	zCodePtr
.018415	90 02		bcc $018419			bcc 	_SNLNoCarry
.018417	e6 17		inc $17				inc 	zCodePtr+1
.018419					_SNLNoCarry:
.018419	a0 00		ldy #$00			ldy 	#0
.01841b	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01841d	c9 00		cmp #$00			cmp 	#0					 		; if zero, fail.
.01841f	f0 54		beq $018475			beq 	_SSWFail
.018421	c8		iny				iny
.018422	c8		iny				iny
.018423					_SSWNextSimple:
.018423	c8		iny				iny
.018424					_SSWLoop:
.018424	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018426	c9 00		cmp #$00			cmp 	#0 							; end of line ?
.018428	f0 e2		beq $01840c			beq 	_SSWNextLine 				; if so, then next line
.01842a	10 f7		bpl $018423			bpl 	_SSWNextSimple 				; needs to be a token, just skip char/number.
.01842c	a6 12		ldx $12				ldx 	zTemp2 						; check structure count
.01842e	d0 08		bne $018438			bne 	_SSWCheckUpDown 			; if it's non zero, then a match doesn't work.
.018430	c5 10		cmp $10				cmp 	zTemp1 						; found the right keyword, either choice.
.018432	f0 2d		beq $018461			beq 	_SSWFound 					; so exit.
.018434	c5 11		cmp $11				cmp 	zTemp1+1
.018436	f0 29		beq $018461			beq 	_SSWFound
.018438					_SSWCheckUpDown:
.018438	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus 			; if < keyword +
.01843a	90 10		bcc $01844c			bcc 	_SSWNext
.01843c	c9 93		cmp #$93			cmp 	#firstKeywordMinus 			; if < keyword - then as keyword +
.01843e	90 08		bcc $018448			bcc 	_SSWPlus
.018440	c9 98		cmp #$98			cmp 	#firstUnaryFunction			; if < first unary down as keyword -
.018442	b0 08		bcs $01844c			bcs 	_SSWNext
.018444	c6 12		dec $12				dec 	zTemp2 						; reduce structure count.
.018446	c6 12		dec $12				dec 	zTemp2
.018448					_SSWPlus:
.018448	e6 12		inc $12				inc 	zTemp2
.01844a	30 16		bmi $018462			bmi 	_SSWUnder					; error if driven -ve
.01844c					_SSWNext:
.01844c	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.01844e	c8		iny				iny 								; skip
.01844f	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018451	90 0c		bcc $01845f			bcc 	_SEDone 					; so just skip over it.
.018453	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018455	90 07		bcc $01845e			bcc 	_SEDouble
.018457	98		tya				tya 								; this is Y + 1
.018458	18		clc				clc
.018459	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.01845b	a8		tay				tay 								; back in Y.
.01845c	88		dey				dey 								; fix up, one for the +1, one for the iny
.01845d	88		dey				dey
.01845e					_SEDouble:
.01845e	c8		iny				iny
.01845f					_SEDone:
.01845f	80 c3		bra $018424			bra 	_SSWLoop
.018461					_SSWFound:
.018461	60		rts				rts
.018462					_SSWUnder:
.018462	20 57 85	jsr $018557			jsr ERR_Handler
>018465	53 74 72 75 63 74 75 72			.text "Structure order",0
>01846d	65 20 6f 72 64 65 72 00
.018475					_SSWFail:
.018475	20 57 85	jsr $018557			jsr ERR_Handler
>018478	43 61 6e 27 74 20 66 69			.text "Can't find structure",0
>018480	6e 64 20 73 74 72 75 63 74 75 72 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stack.asm

.01848d					StackReset:
.01848d	48		pha				pha
.01848e	5a		phy				phy
.01848f	a9 00		lda #$00			lda 	#(BasicStack & $FF) 		; reset pointer
.018491	85 26		sta $26				sta 	zBasicSP
.018493	a9 04		lda #$04			lda 	#(BasicStack >> 8)
.018495	85 27		sta $27				sta 	zBasicSP+1
.018497	a0 00		ldy #$00			ldy 	#0 							; reset stack top to $00 which cannot
.018499	98		tya				tya 								; be a legal token.
.01849a	91 26		sta ($26),y			sta 	(zBasicSP),y
.01849c	7a		ply				ply
.01849d	68		pla				pla
.01849e	60		rts				rts
.01849f					StackPushFrame:
.01849f	48		pha				pha
.0184a0	5a		phy				phy
.0184a1	1a		inc a				inc 	a 							; one extra byte in frame, for the marker.
.0184a2	48		pha				pha 								; save it.
.0184a3	29 0f		and #$0f			and 	#$0F 						; lower 4 bits
.0184a5	18		clc				clc 								; add to Basic Stack
.0184a6	65 26		adc $26				adc 	zBasicSP
.0184a8	85 26		sta $26				sta 	zBasicSP
.0184aa	90 02		bcc $0184ae			bcc 	_SPFNoBump
.0184ac	e6 27		inc $27				inc 	zBasicSP+1
.0184ae					_SPFNoBump:
.0184ae	a0 00		ldy #$00			ldy 	#0
.0184b0	68		pla				pla
.0184b1	91 26		sta ($26),y			sta 	(zBasicSP),y
.0184b3	7a		ply				ply
.0184b4	68		pla				pla
.0184b5	60		rts				rts
.0184b6					StackPopFrame:
.0184b6	48		pha				pha
.0184b7	5a		phy				phy
.0184b8	a0 00		ldy #$00			ldy 	#0 							; compare with top of stack using EOR
.0184ba	51 26		eor ($26),y			eor 	(zBasicSP),y
.0184bc	29 f0		and #$f0			and 	#$F0 						; top 4 bits zero, match
.0184be	d0 12		bne $0184d2			bne 	SPFError 					; mixed structures
.0184c0	b1 26		lda ($26),y			lda 	(zBasicSP),y 				; get size from byte
.0184c2	29 0f		and #$0f			and 	#$0F
.0184c4	49 ff		eor #$ff			eor 	#$FF						; 2's complement
.0184c6	38		sec				sec
.0184c7	65 26		adc $26				adc 	zBasicSP
.0184c9	85 26		sta $26				sta 	zBasicSP
.0184cb	b0 02		bcs $0184cf			bcs 	_SPFNoBump
.0184cd	c6 27		dec $27				dec 	zBasicSP+1
.0184cf					_SPFNoBump:
.0184cf	7a		ply				ply
.0184d0	68		pla				pla
.0184d1	60		rts				rts
.0184d2					SPFError:
.0184d2	20 57 85	jsr $018557			jsr ERR_Handler
>0184d5	4d 69 78 65 64 20 53 74			.text "Mixed Structures",0
>0184dd	72 75 63 74 75 72 65 73 00
.0184e6					StackSavePosition:
.0184e6	98		tya				tya
.0184e7	5a		phy				phy
.0184e8	a0 05		ldy #$05			ldy 	#5
.0184ea	91 26		sta ($26),y			sta 	(zBasicSP),y
.0184ec	a0 01		ldy #$01			ldy 	#1
.0184ee	a5 16		lda $16				lda 	zCodePtr+0 					; 4 bytes, could reduce this for 65816/6502
.0184f0	91 26		sta ($26),y			sta 	(zBasicSP),y
.0184f2	c8		iny				iny
.0184f3	a5 17		lda $17				lda 	zCodePtr+1
.0184f5	91 26		sta ($26),y			sta 	(zBasicSP),y
.0184f7	c8		iny				iny
.0184f8	a5 18		lda $18				lda 	zCodePtr+2
.0184fa	91 26		sta ($26),y			sta 	(zBasicSP),y
.0184fc	c8		iny				iny
.0184fd	a5 19		lda $19				lda 	zCodePtr+3
.0184ff	91 26		sta ($26),y			sta 	(zBasicSP),y
.018501	7a		ply				ply
.018502	60		rts				rts
.018503					StackRestorePosition:
.018503	5a		phy				phy
.018504	a0 01		ldy #$01			ldy 	#1 							; copy 4 bytes that are the pointer
.018506	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018508	85 16		sta $16				sta 	zCodePtr+0
.01850a	c8		iny				iny
.01850b	b1 26		lda ($26),y			lda 	(zBasicSP),y
.01850d	85 17		sta $17				sta 	zCodePtr+1
.01850f	c8		iny				iny
.018510	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018512	85 18		sta $18				sta 	zCodePtr+2
.018514	c8		iny				iny
.018515	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018517	85 19		sta $19				sta 	zCodePtr+3
.018519	c8		iny				iny
.01851a	b1 26		lda ($26),y			lda 	(zBasicSP),y 				; offset
.01851c	7a		ply				ply 								; restore Y
.01851d	a8		tay				tay
.01851e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/vectors.asm

.01851f					CharPrint:
.01851f	4c 35 80	jmp $018035			jmp 	IFT_PrintCharacter
.018522					CharGet:
.018522	4c e6 81	jmp $0181e6			jmp 	IF_GetKey
.018525					CheckBreak:
.018525	4c e1 81	jmp $0181e1			jmp 	IF_CheckBreak

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/errors.asm

.018528					SyntaxError:
.018528	20 57 85	jsr $018557			jsr 	ERR_Handler
>01852b	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>018533	72 72 6f 72 00
.018538					TypeError:
.018538	20 57 85	jsr $018557			jsr 	ERR_Handler
>01853b	57 72 6f 6e 67 20 74 79				.text 	"Wrong type",0
>018543	70 65 00
.018546					BadParamError:
.018546	20 57 85	jsr $018557			jsr 	ERR_Handler
>018549	42 61 64 20 50 61 72 61				.text 	"Bad Parameter",0
>018551	6d 65 74 65 72 00
.018557					ERR_Handler:
.018557	a0 00		ldy #$00			ldy 	#0
.018559	c8		iny				iny
.01855a	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01855c	85 80		sta $80				sta 	XS_Mantissa
.01855e	c8		iny				iny
.01855f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018561	85 81		sta $81				sta 	XS_Mantissa+1
.018563	fa		plx				plx 								; address in XY
.018564	7a		ply				ply
.018565	e8		inx				inx 								; bump, because of RTS/JSR address -1
.018566	d0 01		bne $018569			bne 	_EHNoSkip
.018568	c8		iny				iny
.018569					_EHNoSkip:
.018569	20 88 85	jsr $018588			jsr 	PrintROMMessage 			; print message from ROM.
.01856c	a5 80		lda $80				lda 	XS_Mantissa					; line number = 0
.01856e	05 81		ora $81				ora 	XS_Mantissa+1
.018570	f0 0c		beq $01857e			beq 	_EHNoLine
.018572	a2 83		ldx #$83			ldx 	#_EHAt & $FF 				; print " at "
.018574	a0 85		ldy #$85			ldy 	#(_EHAt >> 8) & $FF
.018576	20 88 85	jsr $018588			jsr 	PrintROMMessage
.018579	a2 00		ldx #$00			ldx 	#0 							; Print line number
.01857b	20 9d 85	jsr $01859d			jsr 	Print16BitInteger
.01857e					_EHNoLine:
.01857e	80 fe		bra $01857e			bra 	_EHNoLine
.018580	4c 10 88	jmp $018810			jmp 	WarmStart
>018583	20 61 74 20 00			_EHAt:	.text 	" at ",0
.018588					PrintROMMessage:
.018588	86 1a		stx $1a				stx 	zLTemp1 					; save addres
.01858a	84 1b		sty $1b				sty 	zLTemp1+1
.01858c	4b		phk				phk
.01858d	68		pla				pla
.01858e	85 1c		sta $1c				sta 	ZLTemp1+2
.018590	a0 00		ldy #$00			ldy 	#0
.018592					_PRMLoop:
.018592	b7 1a		lda [$1a],y			lda 	[zLTemp1],y
.018594	f0 06		beq $01859c			beq		_PRMExit
.018596	c8		iny				iny
.018597	20 1f 85	jsr $01851f			jsr 	CharPrint
.01859a	80 f6		bra $018592			bra 	_PRMLoop
.01859c					_PRMExit:
.01859c	60		rts				rts
.01859d					Print16BitInteger:
.01859d	a9 00		lda #$00			lda 	#0 							; make 32 bit
.01859f	85 82		sta $82				sta 	XS_Mantissa+2
.0185a1	85 83		sta $83				sta 	XS_Mantissa+3
.0185a3					Print32BitInteger:
.0185a3	a9 00		lda #$00			lda 	#0
.0185a5	8d 14 03	sta $0314			sta 	NumBufX 					; reset the conversion pointer
.0185a8	aa		tax				tax 								; convert bottom level.
.0185a9	20 cf 9c	jsr $019ccf			jsr 	INTToString 				; make string
.0185ac	a2 00		ldx #$00			ldx 	#0 							; print buffer
.0185ae	bd 15 03	lda $0315,x	_P1Loop:lda 	Num_Buffer,x
.0185b1	f0 06		beq $0185b9			beq 	_P1Exit
.0185b3	20 1f 85	jsr $01851f			jsr 	CharPrint
.0185b6	e8		inx				inx
.0185b7	80 f5		bra $0185ae			bra 	_P1Loop
.0185b9	8a		txa		_P1Exit:txa 								; return chars printed.
.0185ba	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm


;******  Processing file: modules/basic/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b6					lastUnaryFunction = $b6
.0185bb					VectorTable:
>0185bb	43 91					.word BinaryOp_And         & $FFFF ; $80 and
>0185bd	5f 91					.word BinaryOp_Or          & $FFFF ; $81 or
>0185bf	7b 91					.word BinaryOp_Xor         & $FFFF ; $82 xor
>0185c1	7b 91					.word BinaryOp_Eor         & $FFFF ; $83 eor
>0185c3	b2 91					.word Binary_Equal         & $FFFF ; $84 =
>0185c5	cc 91					.word Binary_NotEqual      & $FFFF ; $85 <>
>0185c7	d5 91					.word Binary_Less          & $FFFF ; $86 <
>0185c9	de 91					.word Binary_LessEqual     & $FFFF ; $87 <=
>0185cb	f0 91					.word Binary_Greater       & $FFFF ; $88 >
>0185cd	e7 91					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>0185cf	75 92					.word BinaryOp_Add         & $FFFF ; $8a +
>0185d1	91 92					.word BinaryOp_Subtract    & $FFFF ; $8b -
>0185d3	a2 92					.word BinaryOp_Multiply    & $FFFF ; $8c *
>0185d5	b3 92					.word BinaryOp_Divide      & $FFFF ; $8d /
>0185d7	79 86					.word NotImplemented       & $FFFF ; $8e ^
>0185d9	e1 8a					.word Command_IF           & $FFFF ; $8f if
>0185db	3f 8f					.word Command_WHILE        & $FFFF ; $90 while
>0185dd	67 8f					.word Command_REPEAT       & $FFFF ; $91 repeat
>0185df	72 89					.word Command_FOR          & $FFFF ; $92 for
>0185e1	79 86					.word NotImplemented       & $FFFF ; $93 then
>0185e3	3e 8b					.word Command_ENDIF        & $FFFF ; $94 endif
>0185e5	5c 8f					.word Command_WEND         & $FFFF ; $95 wend
>0185e7	70 8f					.word Command_UNTIL        & $FFFF ; $96 until
>0185e9	ef 89					.word Command_NEXT         & $FFFF ; $97 next
>0185eb	79 86					.word NotImplemented       & $FFFF ; $98 not
>0185ed	79 86					.word NotImplemented       & $FFFF ; $99 fn(
>0185ef	b8 93					.word Unary_Abs            & $FFFF ; $9a abs(
>0185f1	f9 94					.word Unary_Asc            & $FFFF ; $9b asc(
>0185f3	fb a3					.word Unary_Int            & $FFFF ; $9c int(
>0185f5	d2 93					.word Unary_Peek           & $FFFF ; $9d peek(
>0185f7	7c a3					.word Unary_Rnd            & $FFFF ; $9e rnd(
>0185f9	39 94					.word Unary_Usr            & $FFFF ; $9f usr(
>0185fb	38 95					.word Unary_Left           & $FFFF ; $a0 left$(
>0185fd	4d 95					.word Unary_Right          & $FFFF ; $a1 right$(
>0185ff	1f 95					.word Unary_Mid            & $FFFF ; $a2 mid$(
>018601	96 96					.word Unary_Spc            & $FFFF ; $a3 spc(
>018603	c7 94					.word Unary_Str            & $FFFF ; $a4 str$(
>018605	5b 94					.word Unary_Val            & $FFFF ; $a5 val(
>018607	10 95					.word Unary_Len            & $FFFF ; $a6 len(
>018609	c5 95					.word Unary_Hex            & $FFFF ; $a7 hex$(
>01860b	79 86					.word NotImplemented       & $FFFF ; $a8 sin(
>01860d	79 86					.word NotImplemented       & $FFFF ; $a9 cos(
>01860f	79 86					.word NotImplemented       & $FFFF ; $aa tan(
>018611	79 86					.word NotImplemented       & $FFFF ; $ab atn(
>018613	79 86					.word NotImplemented       & $FFFF ; $ac exp(
>018615	79 86					.word NotImplemented       & $FFFF ; $ad log(
>018617	79 86					.word NotImplemented       & $FFFF ; $ae sqr(
>018619	1b 96					.word Unary_Dec            & $FFFF ; $af dec(
>01861b	d6 93					.word Unary_Deek           & $FFFF ; $b0 deek(
>01861d	da 93					.word Unary_Leek           & $FFFF ; $b1 leek(
>01861f	06 94					.word Unary_Mod            & $FFFF ; $b2 mod(
>018621	72 93					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>018623	78 96					.word Unary_Chr            & $FFFF ; $b4 chr$(
>018625	79 86					.word NotImplemented       & $FFFF ; $b5 pos(
>018627	79 86					.word NotImplemented       & $FFFF ; $b6 tab(
>018629	79 86					.word NotImplemented       & $FFFF ; $b7 $
>01862b	79 86					.word NotImplemented       & $FFFF ; $b8 $(
>01862d	79 86					.word NotImplemented       & $FFFF ; $b9 #
>01862f	79 86					.word NotImplemented       & $FFFF ; $ba #(
>018631	79 86					.word NotImplemented       & $FFFF ; $bb %
>018633	79 86					.word NotImplemented       & $FFFF ; $bc %(
>018635	79 86					.word NotImplemented       & $FFFF ; $bd (
>018637	79 86					.word NotImplemented       & $FFFF ; $be )
>018639	79 86					.word NotImplemented       & $FFFF ; $bf ,
>01863b	71 89					.word Command_COLON        & $FFFF ; $c0 :
>01863d	79 86					.word NotImplemented       & $FFFF ; $c1 ;
>01863f	79 86					.word NotImplemented       & $FFFF ; $c2 def
>018641	23 8f					.word Command_CLR          & $FFFF ; $c3 clr
>018643	37 8f					.word Command_STOP         & $FFFF ; $c4 stop
>018645	79 86					.word NotImplemented       & $FFFF ; $c5 data
>018647	79 86					.word NotImplemented       & $FFFF ; $c6 read
>018649	1d 88					.word Command_DIM          & $FFFF ; $c7 dim
>01864b	79 86					.word NotImplemented       & $FFFF ; $c8 to
>01864d	79 86					.word NotImplemented       & $FFFF ; $c9 step
>01864f	4f 8e					.word Command_GOSUB        & $FFFF ; $ca gosub
>018651	5f 8e					.word Command_RETURN       & $FFFF ; $cb return
>018653	47 8e					.word Command_GOTO         & $FFFF ; $cc goto
>018655	dd 8a					.word Command_END          & $FFFF ; $cd end
>018657	79 86					.word NotImplemented       & $FFFF ; $ce input
>018659	a2 8a					.word Command_LET          & $FFFF ; $cf let
>01865b	44 8b					.word Command_LIST         & $FFFF ; $d0 list
>01865d	f0 8d					.word Command_NEW          & $FFFF ; $d1 new
>01865f	0c 8e					.word Command_OLD          & $FFFF ; $d2 old
>018661	68 8e					.word Command_ON           & $FFFF ; $d3 on
>018663	79 86					.word NotImplemented       & $FFFF ; $d4 restore
>018665	bf 8d					.word Command_POKE         & $FFFF ; $d5 poke
>018667	38 8d					.word Command_PRINT        & $FFFF ; $d6 print
>018669	e3 88					.word Command_RUN          & $FFFF ; $d7 run
>01866b	a5 88					.word Command_WAIT         & $FFFF ; $d8 wait
>01866d	c3 8a					.word Command_SYS          & $FFFF ; $d9 sys
>01866f	c3 8d					.word Command_DOKE         & $FFFF ; $da doke
>018671	c7 8d					.word Command_LOKE         & $FFFF ; $db loke
>018673	a7 8d					.word Command_ASSERT       & $FFFF ; $dc assert
>018675	79 86					.word NotImplemented       & $FFFF ; $dd get
>018677	38 8b					.word Command_ELSE         & $FFFF ; $de else
.018679					NotImplemented:
.018679	20 57 85	jsr $018557			jsr ERR_Handler
>01867c	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>018684	65 6d 65 6e 74 65 64 00
.01868c					BinaryPrecedence:
>01868c	01					.byte 1    ; $80 and
>01868d	01					.byte 1    ; $81 or
>01868e	01					.byte 1    ; $82 xor
>01868f	01					.byte 1    ; $83 eor
>018690	02					.byte 2    ; $84 =
>018691	02					.byte 2    ; $85 <>
>018692	02					.byte 2    ; $86 <
>018693	02					.byte 2    ; $87 <=
>018694	02					.byte 2    ; $88 >
>018695	02					.byte 2    ; $89 >=
>018696	03					.byte 3    ; $8a +
>018697	03					.byte 3    ; $8b -
>018698	04					.byte 4    ; $8c *
>018699	04					.byte 4    ; $8d /
>01869a	05					.byte 5    ; $8e ^
.01869b					KeywordText:
>01869b	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>01869e	4f d2					.byte $4f,$d2                          ; $81 or
>0186a0	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>0186a3	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>0186a6	bd					.byte $bd                              ; $84 =
>0186a7	3c be					.byte $3c,$be                          ; $85 <>
>0186a9	bc					.byte $bc                              ; $86 <
>0186aa	3c bd					.byte $3c,$bd                          ; $87 <=
>0186ac	be					.byte $be                              ; $88 >
>0186ad	3e bd					.byte $3e,$bd                          ; $89 >=
>0186af	ab					.byte $ab                              ; $8a +
>0186b0	ad					.byte $ad                              ; $8b -
>0186b1	aa					.byte $aa                              ; $8c *
>0186b2	af					.byte $af                              ; $8d /
>0186b3	de					.byte $de                              ; $8e ^
>0186b4	49 c6					.byte $49,$c6                          ; $8f if
>0186b6	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>0186bb	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>0186c1	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>0186c4	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>0186c8	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>0186cd	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>0186d1	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>0186d6	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>0186da	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>0186dd	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>0186e0	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>0186e4	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>0186e8	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>0186ec	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>0186f1	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>0186f5	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>0186f9	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>0186ff	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>018706	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>01870b	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>01870f	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>018714	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>018718	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>01871c	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>018721	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>018725	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>018729	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>01872d	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>018731	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>018735	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>018739	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>01873d	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>018741	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>018746	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>01874b	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>01874f	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>018753	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>018758	50 4f 53 a8				.byte $50,$4f,$53,$a8                  ; $b5 pos(
>01875c	54 41 42 a8				.byte $54,$41,$42,$a8                  ; $b6 tab(
>018760	a4					.byte $a4                              ; $b7 $
>018761	24 a8					.byte $24,$a8                          ; $b8 $(
>018763	a3					.byte $a3                              ; $b9 #
>018764	23 a8					.byte $23,$a8                          ; $ba #(
>018766	a5					.byte $a5                              ; $bb %
>018767	25 a8					.byte $25,$a8                          ; $bc %(
>018769	a8					.byte $a8                              ; $bd (
>01876a	a9					.byte $a9                              ; $be )
>01876b	ac					.byte $ac                              ; $bf ,
>01876c	ba					.byte $ba                              ; $c0 :
>01876d	bb					.byte $bb                              ; $c1 ;
>01876e	44 45 c6				.byte $44,$45,$c6                      ; $c2 def
>018771	43 4c d2				.byte $43,$4c,$d2                      ; $c3 clr
>018774	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $c4 stop
>018778	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c5 data
>01877c	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c6 read
>018780	44 49 cd				.byte $44,$49,$cd                      ; $c7 dim
>018783	54 cf					.byte $54,$cf                          ; $c8 to
>018785	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c9 step
>018789	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $ca gosub
>01878e	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $cb return
>018794	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $cc goto
>018798	45 4e c4				.byte $45,$4e,$c4                      ; $cd end
>01879b	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $ce input
>0187a0	4c 45 d4				.byte $4c,$45,$d4                      ; $cf let
>0187a3	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $d0 list
>0187a7	4e 45 d7				.byte $4e,$45,$d7                      ; $d1 new
>0187aa	4f 4c c4				.byte $4f,$4c,$c4                      ; $d2 old
>0187ad	4f ce					.byte $4f,$ce                          ; $d3 on
>0187af	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d4 restore
>0187b6	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d5 poke
>0187ba	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d6 print
>0187bf	52 55 ce				.byte $52,$55,$ce                      ; $d7 run
>0187c2	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d8 wait
>0187c6	53 59 d3				.byte $53,$59,$d3                      ; $d9 sys
>0187c9	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $da doke
>0187cd	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $db loke
>0187d1	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $dc assert
>0187d7	47 45 d4				.byte $47,$45,$d4                      ; $dd get
>0187da	45 4c 53 c5				.byte $45,$4c,$53,$c5                  ; $de else
>0187de	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_pos = $b5
=$b6					token_tab = $b6
=$b7					token_dollar = $b7
=$b8					token_dollarlparen = $b8
=$b9					token_hash = $b9
=$ba					token_hashlparen = $ba
=$bb					token_percent = $bb
=$bc					token_percentlparen = $bc
=$bd					token_lparen = $bd
=$be					token_rparen = $be
=$bf					token_comma = $bf
=$c0					token_colon = $c0
=$c1					token_semicolon = $c1
=$c2					token_def = $c2
=$c3					token_clr = $c3
=$c4					token_stop = $c4
=$c5					token_data = $c5
=$c6					token_read = $c6
=$c7					token_dim = $c7
=$c8					token_to = $c8
=$c9					token_step = $c9
=$ca					token_gosub = $ca
=$cb					token_return = $cb
=$cc					token_goto = $cc
=$cd					token_end = $cd
=$ce					token_input = $ce
=$cf					token_let = $cf
=$d0					token_list = $d0
=$d1					token_new = $d1
=$d2					token_old = $d2
=$d3					token_on = $d3
=$d4					token_restore = $d4
=$d5					token_poke = $d5
=$d6					token_print = $d6
=$d7					token_run = $d7
=$d8					token_wait = $d8
=$d9					token_sys = $d9
=$da					token_doke = $da
=$db					token_loke = $db
=$dc					token_assert = $dc
=$dd					token_get = $dd
=$de					token_else = $de

;******  Return to file: modules/basic/core.asm

.0187df					BASIC_Start:
.0187df	20 a8 81	jsr $0181a8			jsr 	IF_Reset 					; set up and clear screen.
.0187e2	20 00 80	jsr $018000			jsr 	IFT_ClearScreen
.0187e5	a9 5c		lda #$5c			lda 	#$5C 						; JMP Long opcode
.0187e7	8d 10 03	sta $0310			sta 	LocalVector
.0187ea	8d 0c 03	sta $030c			sta 	UserVector
.0187ed	a9 49		lda #$49			lda 	#USRDefault & $FF 			; reset USR vector
.0187ef	8d 0d 03	sta $030d			sta 	UserVector+1
.0187f2	a9 94		lda #$94			lda 	#(USRDefault >> 8) & $FF
.0187f4	8d 0e 03	sta $030e			sta 	UserVector+2
.0187f7	a9 01		lda #$01			lda 	#(USRDefault >> 16) & $FF
.0187f9	8d 0f 03	sta $030f			sta 	UserVector+3
.0187fc	20 f0 96	jsr $0196f0			jsr 	UpdateProgramEnd 			; update the program end.
.0187ff	20 23 8f	jsr $018f23			jsr 	ResetRunStatus 				; clear everything (CLR command)
.018802	c2 30		rep #$30			rep 	#$30
.018804	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.018807	1b		tcs				tcs
.018808	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.01880b	e2 30		sep #$30			sep 	#$30
.01880d	4c e3 88	jmp $0188e3			jmp 	COMMAND_Run
.018810					WarmStart:
.018810	c2 30		rep #$30			rep 	#$30
.018812	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.018815	1b		tcs				tcs
.018816	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.018819	e2 30		sep #$30			sep 	#$30
.01881b	80 f3		bra $018810			bra 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/dim.asm

.01881d					Command_DIM:
.01881d	98		tya				tya
.01881e	48		pha				pha 								; push on stack.
.01881f	20 58 98	jsr $019858			jsr 	VariableExtract 			; get the identifier
.018822	ad 95 03	lda $0395			lda 	Var_Type 					; check it is an array
.018825	29 01		and #$01			and 	#1
.018827	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.018829	d0 6c		bne $018897			bne 	_CDIError
.01882b	a9 00		lda #$00			lda 	#0 							; reset the DIM index. The dimensions are
.01882d	8d b9 03	sta $03b9			sta 	UsrArrayIdx 				; built up here and copied in case we autodim
.018830					_CDIGetDimension:
.018830	ad b9 03	lda $03b9			lda 	UsrArrayIdx 				; done too many ?
.018833	c9 06		cmp #$06			cmp 	#ArrayMaxDim*2
.018835	f0 60		beq $018897			beq 	_CDIError
.018837	20 24 91	jsr $019124			jsr 	EvaluateInteger 			; evaluate an index size
.01883a	a5 81		lda $81				lda 	XS_Mantissa+1 				; check in range 0-7FFF
.01883c	29 80		and #$80			and 	#$80
.01883e	05 82		ora $82				ora 	XS_Mantissa+2
.018840	05 83		ora $83				ora 	XS_Mantissa+3
.018842	d0 53		bne $018897			bne 	_CDIError
.018844	ae b9 03	ldx $03b9			ldx 	UsrArrayIdx 				; copy into the array table.
.018847	18		clc				clc 								; add 1 - max index => size.
.018848	a5 80		lda $80				lda 	XS_Mantissa+0
.01884a	69 01		adc #$01			adc 	#1
.01884c	9d b1 03	sta $03b1,x			sta 	UsrArrayDef+0,x
.01884f	a5 81		lda $81				lda 	XS_Mantissa+1
.018851	69 00		adc #$00			adc 	#0
.018853	9d b2 03	sta $03b2,x			sta 	UsrArrayDef+1,x
.018856	30 3f		bmi $018897			bmi 	_CDIError 					; could be dim a(32767)
.018858	e8		inx				inx 								; bump index.
.018859	e8		inx				inx
.01885a	8e b9 03	stx $03b9			stx 	UsrArrayIdx
.01885d	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01885f	c8		iny				iny
.018860	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another dimension
.018862	f0 cc		beq $018830			beq 	_CDIGetDimension
.018864	88		dey				dey
.018865	20 4c 97	jsr $01974c			jsr 	CheckNextRParen 			; closing ) present ?
.018868	ae b9 03	ldx $03b9			ldx 	UsrArrayIdx 				; copy USR array to default
.01886b	a9 ff		lda #$ff			lda 	#$FF 						; put end marker in ArrayDef
.01886d	9d aa 03	sta $03aa,x			sta 	ArrayDef+1,x
.018870					_CDICopy:
.018870	bd b1 03	lda $03b1,x			lda 	UsrArrayDef,x
.018873	9d a9 03	sta $03a9,x			sta 	ArrayDef,x
.018876	ca		dex				dex
.018877	10 f7		bpl $018870			bpl 	_CDICopy
.018879	68		pla				pla									; position of array identifier
.01887a	85 10		sta $10				sta 	zTemp1
.01887c	98		tya				tya
.01887d	48		pha				pha
.01887e	a5 10		lda $10				lda 	zTemp1 						; point to identifier
.018880	a8		tay				tay
.018881	20 58 98	jsr $019858			jsr 	VariableExtract 			; get the identifier
.018884	20 f1 9a	jsr $019af1			jsr 	VariableLocate 				; check if it exists already.
.018887	b0 0e		bcs $018897			bcs 	_CDIError
.018889	20 e4 98	jsr $0198e4			jsr 	VariableCreate 				; create it using the current ArrayDef
.01888c	68		pla				pla 								; restore code position
.01888d	a8		tay				tay
.01888e	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018890	c8		iny				iny
.018891	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another DIM
.018893	f0 88		beq $01881d			beq 	Command_DIM
.018895	88		dey				dey
.018896	60		rts				rts
.018897					_CDIError:
.018897	20 57 85	jsr $018557			jsr ERR_Handler
>01889a	42 61 64 20 44 49 4d 00			.text "Bad DIM",0
.0188a2					_CDISyntax:
.0188a2	4c 28 85	jmp $018528			jmp 	SyntaxError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/wait.asm

.0188a5					Command_WAIT:
.0188a5	20 24 91	jsr $019124			jsr		EvaluateInteger 			; address
.0188a8	a2 06		ldx #$06			ldx 	#XS_Size 					; and mask.
.0188aa	20 54 97	jsr $019754			jsr 	CheckNextComma
.0188ad	20 26 91	jsr $019126			jsr 	EvaluateIntegerX
.0188b0	a9 00		lda #$00			lda 	#0							; set default xor.
.0188b2	85 8c		sta $8c				sta 	XS_Mantissa+XS_Size*2
.0188b4	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0188b6	c9 bf		cmp #$bf			cmp 	#token_Comma 				; no use the default
.0188b8	d0 06		bne $0188c0			bne 	_CWAXorDefault
.0188ba	c8		iny				iny
.0188bb	a2 0c		ldx #$0c			ldx 	#XS_Size*2
.0188bd	20 26 91	jsr $019126			jsr 	EvaluateIntegerX
.0188c0					_CWAXorDefault:
.0188c0	a5 80		lda $80				lda 	XS_Mantissa 				; copy 24 bits of mantissa to ZLTemp1
.0188c2	85 1a		sta $1a				sta 	zLTemp1
.0188c4	a5 81		lda $81				lda 	XS_Mantissa+1
.0188c6	85 1b		sta $1b				sta 	zLTemp1+1
.0188c8	a5 82		lda $82				lda 	XS_Mantissa+2
.0188ca	85 1c		sta $1c				sta 	zLTemp1+2
.0188cc					_CWAWaitLoop:
.0188cc	20 25 85	jsr $018525			jsr 	CheckBreak 					; exit on break.
.0188cf	c9 00		cmp #$00			cmp 	#0
.0188d1	d0 0f		bne $0188e2			bne 	_CWAWaitExit
.0188d3	a9 01		lda #$01			lda 	#1							; read 1 byte to mantissa/0
.0188d5	a2 00		ldx #$00			ldx 	#0
.0188d7	5a		phy				phy 								; this is the same routine as PEEK.
.0188d8	20 ce 96	jsr $0196ce			jsr 	MemRead
.0188db	7a		ply				ply
.0188dc	25 86		and $86				and 	XS_Mantissa+XS_Size 		; process it
.0188de	45 8c		eor $8c				eor 	XS_Mantissa+XS_Size*2
.0188e0	f0 ea		beq $0188cc			beq 	_CWAWaitLoop
.0188e2					_CWAWaitExit:
.0188e2	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/run.asm

.0188e3					Command_RUN:
.0188e3	20 23 8f	jsr $018f23			jsr 	ResetRunStatus 				; clear, reset stacks etc.
.0188e6	a9 00		lda #$00			lda 	#BasicProgram & $FF
.0188e8	85 16		sta $16				sta 	zCodePtr+0
.0188ea	a9 10		lda #$10			lda 	#BasicProgram >> 8
.0188ec	85 17		sta $17				sta 	zCodePtr+1
.0188ee	a9 00		lda #$00			lda 	#0
.0188f0	85 18		sta $18				sta 	zCodePtr+2
.0188f2	85 19		sta $19				sta 	zCodePtr+3
.0188f4	a0 03		ldy #$03			ldy 	#3
.0188f6					RUN_NewLine:
.0188f6	a0 00		ldy #$00			ldy 	#0
.0188f8	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0188fa	c8		iny				iny
.0188fb	c8		iny				iny
.0188fc	c8		iny				iny
.0188fd	c9 00		cmp #$00			cmp 	#0 							; if the offset is zero then END.
.0188ff	d0 16		bne $018917			bne 	RUN_NextCommand
.018901	4c dd 8a	jmp $018add			jmp 	Command_END 				; go do the command code.
.018904					RUN_Skip:
.018904	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018906	c8		iny				iny 								; skip
.018907	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018909	90 0c		bcc $018917			bcc 	_SEDone 					; so just skip over it.
.01890b	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.01890d	90 07		bcc $018916			bcc 	_SEDouble
.01890f	98		tya				tya 								; this is Y + 1
.018910	18		clc				clc
.018911	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018913	a8		tay				tay 								; back in Y.
.018914	88		dey				dey 								; fix up, one for the +1, one for the iny
.018915	88		dey				dey
.018916					_SEDouble:
.018916	c8		iny				iny
.018917					_SEDone:
.018917					RUN_NextCommand:
.018917	ad a8 03	lda $03a8			lda 	BreakCount 					; break counter
.01891a	69 10		adc #$10			adc 	#16 						; one time in 16
.01891c	8d a8 03	sta $03a8			sta 	BreakCount
.01891f	90 0a		bcc $01892b			bcc 	RUN_NoCheckBreak
.018921	20 25 85	jsr $018525			jsr 	CheckBreak 					; check for break
.018924	c9 00		cmp #$00			cmp 	#0
.018926	f0 03		beq $01892b			beq 	RUN_NoCheckBreak
.018928	4c 37 8f	jmp $018f37			jmp 	Command_STOP 				; stop on BREAK.
.01892b					RUN_NoCheckBreak:
.01892b	a9 00		lda #$00			lda 	#0 							; this resets temporary string allocation.
.01892d	85 21		sta $21				sta 	zTempStr+1 					; (initialised when first called)
.01892f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018931	c9 c0		cmp #$c0			cmp 	#token_Colon 				; skip over colons
.018933	f0 cf		beq $018904			beq 	RUN_Skip
.018935	c9 00		cmp #$00			cmp 	#0 							; if non-zero execute whatever
.018937	d0 0f		bne $018948			bne 	RUN_Execute
.018939					RUN_NextLine:
.018939	a0 00		ldy #$00			ldy 	#0 							; point to offset
.01893b	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.01893d	18		clc				clc
.01893e	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018940	85 16		sta $16				sta 	zCodePtr
.018942	90 02		bcc $018946			bcc 	_SNLNoCarry
.018944	e6 17		inc $17				inc 	zCodePtr+1
.018946					_SNLNoCarry:
.018946	80 ae		bra $0188f6			bra 	RUN_NewLine 				; go do the new line code
.018948					RUN_Execute:
.018948	c9 f8		cmp #$f8			cmp 	#$F8 						; handle shifts, REM etc.
.01894a	b0 1e		bcs $01896a			bcs 	RUN_Extension
.01894c	c8		iny				iny
.01894d	0a		asl a				asl 	a 							; double the character read.
.01894e	90 14		bcc $018964			bcc 	RUN_Default 				; if carry clear was $00-$7F, so try LET.
.018950	aa		tax				tax 								; ready to look up.
.018951	bf bb 85 01	lda $0185bb,x			lda 	VectorTable,x 				; copy address into LocalVector
.018955	8d 11 03	sta $0311			sta 	LocalVector+1
.018958	bf bc 85 01	lda $0185bc,x			lda 	VectorTable+1,x
.01895c	8d 12 03	sta $0312			sta 	LocalVector+2
.01895f	20 71 90	jsr $019071			jsr 	EVCallLocalVector 			; execute the appropriate code.
.018962	80 b3		bra $018917			bra 	RUN_NextCommand 			; do the next command.
.018964					RUN_Default:
.018964	88		dey				dey
.018965	20 a2 8a	jsr $018aa2			jsr 	Command_LET 				; and try LET.
.018968	80 ad		bra $018917			bra 	RUN_NextCommand
.01896a					RUN_Extension:
.01896a	c9 ff		cmp #$ff			cmp 	#$FF 						; if $FF (REM)
.01896c	f0 96		beq $018904			beq 	RUN_Skip 					; skip over it.
.01896e	4c 28 85	jmp $018528			jmp 	SyntaxError
.018971					Command_COLON:
.018971	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/for.asm

.018972					Command_FOR:
.018972	20 a2 8a	jsr $018aa2			jsr 	Command_LET 				; do the A = 99 bit
.018975	a5 24		lda $24				lda 	zVarType 					; obviously has to be integer/real.
.018977	c9 b7		cmp #$b7			cmp 	#token_Dollar
.018979	f0 71		beq $0189ec			beq 	_CFOError
.01897b	48		pha				pha 								; save the variable type.
.01897c	5a		phy				phy 								; save type/variable address.
.01897d	a0 01		ldy #$01			ldy 	#1							; type at + 1
.01897f	91 26		sta ($26),y			sta 	(zBasicSP),y
.018981	c8		iny				iny
.018982	a5 22		lda $22				lda 	zVarDataPtr 				; data low at +2
.018984	91 26		sta ($26),y			sta 	(zBasicSP),y
.018986	c8		iny				iny
.018987	a5 23		lda $23				lda 	zVarDataPtr+1 				; data high at +3
.018989	91 26		sta ($26),y			sta 	(zBasicSP),y
.01898b	7a		ply				ply
.01898c	a9 53		lda #$53			lda 	#(SMark_For << 4) + 3
.01898e	20 9f 84	jsr $01849f			jsr 	StackPushFrame 				; push on the stack with FOR marker.
.018991	a9 c8		lda #$c8			lda 	#token_TO
.018993	20 35 97	jsr $019735			jsr 	CheckNextToken
.018996	a2 00		ldx #$00			ldx 	#0 							; put in Mantissa, bottom
.018998	20 8e 8f	jsr $018f8e			jsr 	EvaluateExpression
.01899b	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01899d	a2 06		ldx #$06			ldx 	#XS_Size 					; X to second level
.01899f	c9 c9		cmp #$c9			cmp 	#token_STEP
.0189a1	d0 06		bne $0189a9			bne 	_CFOStep1
.0189a3	c8		iny				iny
.0189a4	20 90 8f	jsr $018f90			jsr 	EvaluateExpressionX 		; get STEP value.
.0189a7	80 0e		bra $0189b7			bra 	_CFOHaveStep
.0189a9					_CFOStep1:
.0189a9	a9 00		lda #$00			lda 	#0							; set step to integer 1.
.0189ab	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0189ad	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0189af	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0189b1	a9 01		lda #$01			lda 	#1
.0189b3	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0189b5	95 85		sta $85,x			sta 	XS_Type,x
.0189b7					_CFOHaveStep:
.0189b7	68		pla				pla 								; restore variable type
.0189b8	a2 00		ldx #$00			ldx 	#0
.0189ba	c9 bb		cmp #$bb			cmp 	#token_Percent 				; do conversion to type
.0189bc	f0 0a		beq $0189c8			beq 	_CFOInteger
.0189be	20 fc a0	jsr $01a0fc			jsr 	FPUToFloat
.0189c1	a2 06		ldx #$06			ldx 	#6
.0189c3	20 fc a0	jsr $01a0fc			jsr 	FPUToFloat
.0189c6	80 08		bra $0189d0			bra 	_CFOEndConv
.0189c8					_CFOInteger:
.0189c8	20 48 a1	jsr $01a148			jsr 	FPUToInteger
.0189cb	a2 06		ldx #$06			ldx 	#6
.0189cd	20 48 a1	jsr $01a148			jsr 	FPUToInteger
.0189d0					_CFOEndConv:
.0189d0	20 e6 84	jsr $0184e6			jsr 	StackSavePosition 			; save the loop position at 1-5
.0189d3	a9 55		lda #$55			lda 	#(SMark_For << 4)+SourcePosSize
.0189d5	20 9f 84	jsr $01849f			jsr 	StackPushFrame 				; push the loop address frame.
.0189d8	5a		phy				phy
.0189d9	a0 00		ldy #$00			ldy 	#0
.0189db					_CFOCopy:
.0189db	b9 80 00	lda $0080,y			lda 	XS_Mantissa+0,y
.0189de	c8		iny				iny
.0189df	91 26		sta ($26),y			sta 	(zBasicSP),y
.0189e1	c0 0c		cpy #$0c			cpy 	#XS_Size*2
.0189e3	d0 f6		bne $0189db			bne 	_CFOCopy
.0189e5	7a		ply				ply
.0189e6	a9 5c		lda #$5c			lda 	#(SMark_For << 4)+(XS_Size*2)
.0189e8	20 9f 84	jsr $01849f			jsr 	StackPushFrame
.0189eb	60		rts				rts
.0189ec					_CFOError:
.0189ec	4c 38 85	jmp $018538			jmp 	TypeError 					; wrong type.
.0189ef					Command_NEXT:
.0189ef	a9 00		lda #$00			lda 	#0 							; set variable data pointer+1 to zero
.0189f1	85 23		sta $23				sta 	zVarDataPtr+1 				; this means we don't check
.0189f3	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0189f5	c9 00		cmp #$00			cmp 	#0 							; EOL
.0189f7	f0 07		beq $018a00			beq 	_CNextNoVariable
.0189f9	c9 40		cmp #$40			cmp 	#$40
.0189fb	b0 03		bcs $018a00			bcs 	_CNextNoVariable
.0189fd	20 ed 97	jsr $0197ed			jsr 	VariableFind
.018a00					_CNextNoVariable:
.018a00	a5 26		lda $26				lda 	zBasicSP 					; save on stack
.018a02	48		pha				pha
.018a03	a5 27		lda $27				lda 	zBasicSP+1
.018a05	48		pha				pha
.018a06	a9 50		lda #$50			lda 	#(SMark_For << 4) 			; pop loop address frame
.018a08	20 b6 84	jsr $0184b6			jsr 	StackPopFrame
.018a0b	a9 50		lda #$50			lda 	#(SMark_For << 4) 			; pop STEP/TARGET frame.
.018a0d	20 b6 84	jsr $0184b6			jsr 	StackPopFrame
.018a10	a9 50		lda #$50			lda 	#(Smark_For << 4) 			; pop variable address frame.
.018a12	20 b6 84	jsr $0184b6			jsr 	StackPopFrame
.018a15	a5 23		lda $23				lda 	zVarDataPtr+1 				; if zero, then no variable provided
.018a17	f0 11		beq $018a2a			beq 	_CNextGetTarget 			; e.g. just NEXT not NEXT x
.018a19	5a		phy				phy 								; check addresses match.
.018a1a	a0 02		ldy #$02			ldy 	#2
.018a1c	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a1e	c5 22		cmp $22				cmp 	zVarDataPtr
.018a20	d0 69		bne $018a8b			bne 	_CNextWrong
.018a22	c8		iny				iny
.018a23	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a25	c5 23		cmp $23				cmp 	zVarDataPtr+1
.018a27	d0 62		bne $018a8b			bne 	_CNextWrong
.018a29	7a		ply				ply
.018a2a					_CNextGetTarget:
.018a2a	5a		phy				phy
.018a2b	a0 01		ldy #$01			ldy 	#1 							; restore variable type and data.
.018a2d	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a2f	85 24		sta $24				sta 	zVarType
.018a31	c8		iny				iny
.018a32	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a34	85 22		sta $22				sta 	zVarDataPtr
.018a36	c8		iny				iny
.018a37	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a39	85 23		sta $23				sta 	zVarDataPtr+1
.018a3b	a2 0c		ldx #$0c			ldx 	#12
.018a3d	20 35 9b	jsr $019b35			jsr 	VariableGet 				; get that variable value into expr[2]
.018a40	a2 00		ldx #$00			ldx 	#0 							; copy stacked Target/Step into expr[0] and [1]
.018a42	a0 0b		ldy #$0b			ldy 	#11
.018a44					_CNXCopy:
.018a44	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a46	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018a48	e8		inx				inx
.018a49	c8		iny				iny
.018a4a	e0 0c		cpx #$0c			cpx 	#XS_Size*2
.018a4c	d0 f6		bne $018a44			bne 	_CNXCopy
.018a4e	7a		ply				ply
.018a4f	a2 06		ldx #$06			ldx 	#6 							; point at expr[1] s
.018a51	20 96 93	jsr $019396			jsr 	GetSignCurrent
.018a54	8d a7 03	sta $03a7			sta 	SignNext 					; save in temporary.
.018a57	a2 06		ldx #$06			ldx 	#6 							; add them, however
.018a59	20 75 92	jsr $019275			jsr 	BinaryOp_Add
.018a5c	20 86 9b	jsr $019b86			jsr 	VariableSet					; and write variable back.
.018a5f	a2 00		ldx #$00			ldx 	#0
.018a61	20 f9 91	jsr $0191f9			jsr 	CompareValues
.018a64	09 00		ora #$00			ora 	#0
.018a66	f0 05		beq $018a6d			beq 	_CNXAgain 					; if true, then do it again.
.018a68	cd a7 03	cmp $03a7			cmp 	SignNext 					; if sign different, then loop has finished.
.018a6b	d0 0f		bne $018a7c			bne 	_CNXLoopDone
.018a6d					_CNXAgain:
.018a6d	a9 53		lda #$53			lda 	#(SMark_For << 4) + 3		; re-stack variable address
.018a6f	20 9f 84	jsr $01849f			jsr 	StackPushFrame
.018a72	20 03 85	jsr $018503			jsr 	StackRestorePosition 		; get restore position back, e.g. loop round.
.018a75	68		pla				pla
.018a76	85 27		sta $27				sta 	zBasicSP+1
.018a78	68		pla				pla
.018a79	85 26		sta $26				sta 	zBasicSP
.018a7b					_CNXExit:
.018a7b	60		rts				rts
.018a7c					_CNXLoopDone:
.018a7c	68		pla				pla
.018a7d	68		pla				pla
.018a7e	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018a80	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma ?
.018a82	d0 f7		bne $018a7b			bne 	_CNXExit
.018a84	c8		iny				iny
.018a85	20 ed 97	jsr $0197ed			jsr 	VariableFind 				; identify the variable
.018a88	4c 00 8a	jmp $018a00			jmp 	_CNextNoVariable 			; go back with variable pre-found
.018a8b					_CNextWrong:
.018a8b	20 57 85	jsr $018557			jsr ERR_Handler
>018a8e	57 72 6f 6e 67 20 4e 65			.text "Wrong Next Variable",0
>018a96	78 74 20 56 61 72 69 61 62 6c 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/let.asm

.018aa2					Command_LET:
.018aa2	20 ed 97	jsr $0197ed			jsr 	VariableFind 				; get reference to one variable.
.018aa5	a9 84		lda #$84			lda 	#token_Equal  				; get equals
.018aa7	20 35 97	jsr $019735			jsr 	CheckNextToken
.018aaa	a5 22		lda $22				lda 	zVarDataPtr 				; save variable info on stack
.018aac	48		pha				pha
.018aad	a5 23		lda $23				lda 	zVarDataPtr+1
.018aaf	48		pha				pha
.018ab0	a5 24		lda $24				lda 	zVarType
.018ab2	48		pha				pha
.018ab3	20 8e 8f	jsr $018f8e			jsr 	EvaluateExpression 			; evaluate the RHS.
.018ab6	68		pla				pla 								; restore target variable information.
.018ab7	85 24		sta $24				sta 	zVarType
.018ab9	68		pla				pla
.018aba	85 23		sta $23				sta 	zVarDataPtr+1
.018abc	68		pla				pla
.018abd	85 22		sta $22				sta 	zVarDataPtr
.018abf	20 86 9b	jsr $019b86			jsr 	VariableSet 				; set the value out.
.018ac2	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/sys.asm

.018ac3					Command_SYS:
.018ac3	20 24 91	jsr $019124			jsr 	EvaluateInteger 			; address
.018ac6	a5 80		lda $80				lda 	XS_Mantissa+0				; copy to localvector
.018ac8	8d 10 03	sta $0310			sta 	LocalVector+0 				; only three, can only do 24 bit calls
.018acb	a5 81		lda $81				lda 	XS_Mantissa+1 				; and that only on 65816
.018acd	8d 11 03	sta $0311			sta 	LocalVector+1
.018ad0	a5 82		lda $82				lda 	XS_Mantissa+2
.018ad2	8d 12 03	sta $0312			sta 	LocalVector+2
.018ad5	22 da 8a 01	jsl $018ada			jsl 	_CSYLocalCall
.018ad9	60		rts				rts
.018ada					_CSYLocalCall:
.018ada	dc 10 03	jmp [$0310]			jmp 	[LocalVector]

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/end.asm

.018add					Command_END:
>018add	02						.byte 	2
.018ade	4c 10 88	jmp $018810			jmp 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/if.asm

.018ae1					Command_IF:
.018ae1	20 24 91	jsr $019124			jsr 	EvaluateInteger 			; check success.
.018ae4	a5 80		lda $80				lda 	XS_Mantissa+0				; check the result if zero
.018ae6	05 81		ora $81				ora 	XS_Mantissa+1
.018ae8	05 82		ora $82				ora 	XS_Mantissa+2
.018aea	05 83		ora $83				ora 	XS_Mantissa+3
.018aec	aa		tax				tax 								; put into X.
.018aed	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018aef	c9 93		cmp #$93			cmp 	#token_Then 				; then found.
.018af1	d0 2c		bne $018b1f			bne 	_FIFExtended
.018af3	c8		iny				iny
.018af4	e0 00		cpx #$00			cpx 	#0 							; was it successful.
.018af6	f0 0b		beq $018b03			beq 	_FIFEndOfLine 				; if not, go to the end of the line.
.018af8	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018afa	29 c0		and #$c0			and 	#$C0 						; is it a number
.018afc	c9 40		cmp #$40			cmp 	#$40
.018afe	d0 1e		bne $018b1e			bne 	_FIFContinue 				; if not, do what ever follows.
.018b00	4c 47 8e	jmp $018e47			jmp		Command_GOTO 				; we have IF <expr> THEN <number> so we do GOTO code.
.018b03					_FIFEndOfLine:
.018b03	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018b05	c9 00		cmp #$00			cmp 	#0 							; if zero, end of line, so exit
.018b07	f0 15		beq $018b1e			beq 	_FIFContinue
.018b09	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018b0b	c8		iny				iny 								; skip
.018b0c	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018b0e	90 0c		bcc $018b1c			bcc 	_SEDone 					; so just skip over it.
.018b10	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018b12	90 07		bcc $018b1b			bcc 	_SEDouble
.018b14	98		tya				tya 								; this is Y + 1
.018b15	18		clc				clc
.018b16	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018b18	a8		tay				tay 								; back in Y.
.018b19	88		dey				dey 								; fix up, one for the +1, one for the iny
.018b1a	88		dey				dey
.018b1b					_SEDouble:
.018b1b	c8		iny				iny
.018b1c					_SEDone:
.018b1c	80 e5		bra $018b03			bra 	_FIFEndOfLine
.018b1e					_FIFContinue:
.018b1e	60		rts				rts
.018b1f					_FIFExtended:
.018b1f	da		phx				phx 								; save result
.018b20	a9 40		lda #$40			lda 	#(SMark_If << 4) 			; push marker on the stack, nothing else.
.018b22	20 9f 84	jsr $01849f			jsr 	StackPushFrame
.018b25	68		pla				pla 								; restore result
.018b26	f0 01		beq $018b29			beq 	_FIXSkip 					; if zero then it has failed.
.018b28	60		rts				rts 								; test passed, so continue executing
.018b29					_FIXSkip:
.018b29	a9 94		lda #$94			lda 	#token_endif 				; scan forward till found either ELSE or ENDIF
.018b2b	a2 de		ldx #$de			ldx 	#token_else 				; at the same level.
.018b2d	20 02 84	jsr $018402			jsr 	StructureSearchDouble
.018b30	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018b32	c8		iny				iny
.018b33	c9 94		cmp #$94			cmp 	#token_endif 				; if endif, handle endif code.
.018b35	f0 07		beq $018b3e			beq 	Command_ENDIF
.018b37	60		rts				rts
.018b38					Command_ELSE:
.018b38	a9 94		lda #$94			lda 	#token_endif 				; scan forward till found ENDIF
.018b3a	20 00 84	jsr $018400			jsr 	StructureSearchSingle 		; then do the ENDIF pop.
.018b3d	c8		iny				iny
.018b3e					Command_ENDIF:
.018b3e	a9 40		lda #$40			lda 	#(SMark_If << 4)
.018b40	20 b6 84	jsr $0184b6			jsr 	StackPopFrame
.018b43	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/list.asm

.018b44					Command_LIST:
.018b44	20 d1 8c	jsr $018cd1			jsr 	ListGetRange				; get any parameters
.018b47	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018b49	85 16		sta $16				sta 	zCodePtr+0
.018b4b	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018b4d	85 17		sta $17				sta 	zCodePtr+1
.018b4f	a9 00		lda #$00			lda 	#0
.018b51	85 18		sta $18				sta 	zCodePtr+2
.018b53	85 19		sta $19				sta 	zCodePtr+3
.018b55	a0 03		ldy #$03			ldy 	#3
.018b57	a9 00		lda #$00			lda 	#0 							; reset the indent & last indent
.018b59	8d bc 03	sta $03bc			sta 	LastListIndent
.018b5c	8d bb 03	sta $03bb			sta 	ListIndent
.018b5f					_CILLoop:
.018b5f	a0 00		ldy #$00			ldy 	#0
.018b61	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018b63	c9 00		cmp #$00			cmp 	#0 							; if zero, end of program
.018b65	f0 23		beq $018b8a			beq 	_CILExit
.018b67	20 25 85	jsr $018525			jsr 	CheckBreak 					; check break
.018b6a	c9 00		cmp #$00			cmp 	#0
.018b6c	d0 1c		bne $018b8a			bne 	_CILExit
.018b6e	20 18 8d	jsr $018d18			jsr 	ListCheckRange 				; check current line in range.
.018b71	b0 08		bcs $018b7b			bcs		_CILNext
.018b73	a0 00		ldy #$00			ldy 	#0
.018b75	c8		iny				iny
.018b76	c8		iny				iny
.018b77	c8		iny				iny
.018b78	20 8d 8b	jsr $018b8d			jsr 	ListLine 					; list one line.
.018b7b					_CILNext:
.018b7b	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018b7d	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.018b7f	18		clc				clc
.018b80	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018b82	85 16		sta $16				sta 	zCodePtr
.018b84	90 02		bcc $018b88			bcc 	_SNLNoCarry
.018b86	e6 17		inc $17				inc 	zCodePtr+1
.018b88					_SNLNoCarry:
.018b88	80 d5		bra $018b5f			bra 	_CILLoop
.018b8a					_CILExit:
.018b8a	4c 10 88	jmp $018810			jmp 	WarmStart
.018b8d					ListLine:
.018b8d	ad bb 03	lda $03bb			lda 	ListIndent 					; copy current list indent -> last
.018b90	8d bc 03	sta $03bc			sta 	LastListIndent
.018b93					_LICountIndent:
.018b93	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018b95	c9 00		cmp #$00			cmp 	#0
.018b97	f0 2f		beq $018bc8			beq 	_LIDoneIndent
.018b99	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus
.018b9b	90 16		bcc $018bb3			bcc 	_LICINext
.018b9d	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.018b9f	b0 12		bcs $018bb3			bcs 	_LICINext
.018ba1	ee bb 03	inc $03bb			inc 	ListIndent
.018ba4	c9 93		cmp #$93			cmp 	#firstKeywordMinus
.018ba6	90 0b		bcc $018bb3			bcc 	_LICINext
.018ba8	ce bb 03	dec $03bb			dec 	ListIndent
.018bab	ce bb 03	dec $03bb			dec 	ListIndent
.018bae	10 03		bpl $018bb3			bpl 	_LICINext
.018bb0	ee bb 03	inc $03bb			inc 	ListIndent
.018bb3					_LICINext:
.018bb3	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018bb5	c8		iny				iny 								; skip
.018bb6	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018bb8	90 0c		bcc $018bc6			bcc 	_SEDone 					; so just skip over it.
.018bba	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018bbc	90 07		bcc $018bc5			bcc 	_SEDouble
.018bbe	98		tya				tya 								; this is Y + 1
.018bbf	18		clc				clc
.018bc0	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018bc2	a8		tay				tay 								; back in Y.
.018bc3	88		dey				dey 								; fix up, one for the +1, one for the iny
.018bc4	88		dey				dey
.018bc5					_SEDouble:
.018bc5	c8		iny				iny
.018bc6					_SEDone:
.018bc6	80 cb		bra $018b93			bra 	_LICountIndent
.018bc8					_LIDoneIndent:
.018bc8	a0 00		ldy #$00			ldy 	#0
.018bca	c8		iny				iny
.018bcb	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018bcd	85 80		sta $80				sta 	XS_Mantissa
.018bcf	c8		iny				iny
.018bd0	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018bd2	85 81		sta $81				sta 	XS_Mantissa+1
.018bd4	20 9d 85	jsr $01859d			jsr 	Print16BitInteger 			; print integer.
.018bd7	85 10		sta $10				sta 	zTemp1 						; save spaces printed.
.018bd9	ad bb 03	lda $03bb			lda 	ListIndent 					; smaller of current/prev indent
.018bdc	cd bc 03	cmp $03bc			cmp 	LastListIndent
.018bdf	90 03		bcc $018be4			bcc 	_LISmaller
.018be1	ad bc 03	lda $03bc			lda 	LastListIndent
.018be4					_LISmaller:
.018be4	0a		asl a				asl 	a 							; double indent
.018be5	49 ff		eor #$ff			eor 	#$FF 						; 2's complement arithmetic
.018be7	38		sec				sec
.018be8	65 10		adc $10				adc 	zTemp1 						; "subtract" indent e.g. print more.
.018bea	aa		tax				tax 								; print spaces to column 6
.018beb					_LISpace:
.018beb	a9 20		lda #$20			lda 	#" "
.018bed	20 c1 8c	jsr $018cc1			jsr 	ListPrintLC
.018bf0	e8		inx				inx
.018bf1	e0 06		cpx #$06			cpx 	#6
.018bf3	d0 f6		bne $018beb			bne 	_LISpace
.018bf5					_LIDecode:
.018bf5	c8		iny				iny
.018bf6	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018bf8	c9 00		cmp #$00			cmp 	#0 							; zero, exit.
.018bfa	f0 0f		beq $018c0b			beq 	_LIExit
.018bfc	30 12		bmi $018c10			bmi 	_LIToken
.018bfe	c9 40		cmp #$40			cmp 	#$40 						; 01-$3F, character.
.018c00	b0 50		bcs $018c52			bcs 	_LIInteger
.018c02	49 20		eor #$20			eor 	#$20 						; make 7 bit
.018c04	69 20		adc #$20			adc 	#$20
.018c06	20 c1 8c	jsr $018cc1			jsr 	ListPrintLC 				; print in LC
.018c09	80 ea		bra $018bf5			bra 	_LIDecode
.018c0b					_LIExit:
.018c0b	a9 0d		lda #$0d			lda 	#13 						; print new line.
.018c0d	4c c1 8c	jmp $018cc1			jmp 	ListPrintLC
.018c10					_LIToken:
.018c10	c9 fc		cmp #$fc			cmp 	#$FC 						; $FC-$FF ?
.018c12	90 49		bcc $018c5d			bcc		_LICommandToken
.018c14	48		pha				pha 								; save in case end
.018c15	a2 22		ldx #$22			ldx 	#'"'						; print if $FE quoted string
.018c17	c9 fe		cmp #$fe			cmp 	#$FE
.018c19	f0 17		beq $018c32			beq 	_LIPrint
.018c1b	a2 2e		ldx #$2e			ldx 	#'.'						; print if $FD decimals
.018c1d	c9 fd		cmp #$fd			cmp 	#$FD
.018c1f	f0 11		beq $018c32			beq 	_LIPrint
.018c21	a9 52		lda #$52			lda 	#'R'						; must be REM
.018c23	20 c1 8c	jsr $018cc1			jsr 	ListPrintLC
.018c26	a9 45		lda #$45			lda 	#'E'
.018c28	20 c1 8c	jsr $018cc1			jsr 	ListPrintLC
.018c2b	a9 4d		lda #$4d			lda 	#'M'
.018c2d	20 c1 8c	jsr $018cc1			jsr 	ListPrintLC
.018c30	a2 20		ldx #$20			ldx 	#' '
.018c32					_LIPrint:
.018c32	8a		txa				txa
.018c33	20 c1 8c	jsr $018cc1			jsr 	ListPrintLC
.018c36	c8		iny				iny
.018c37	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c39	aa		tax				tax 								; put in X
.018c3a	ca		dex				dex
.018c3b					_LILoop:
.018c3b	ca		dex				dex 								; exit when count reached zero.
.018c3c	f0 08		beq $018c46			beq 	_LIEnd
.018c3e	c8		iny				iny
.018c3f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c41	20 c1 8c	jsr $018cc1			jsr 	ListPrintLC
.018c44	80 f5		bra $018c3b			bra 	_LILoop
.018c46	68		pla		_LIEnd:	pla 								; get A back
.018c47	c9 fe		cmp #$fe			cmp 	#$FE 						; if '"' need closing quotes
.018c49	d0 aa		bne $018bf5			bne 	_LIDecode
.018c4b	a9 22		lda #$22			lda 	#'"'
.018c4d	20 c1 8c	jsr $018cc1			jsr 	ListPrintLC
.018c50	80 a3		bra $018bf5			bra 	_LIDecode
.018c52					_LIInteger:
.018c52	a2 00		ldx #$00			ldx 	#0
.018c54	20 96 90	jsr $019096			jsr 	EvaluateGetInteger 			; get an atom
.018c57	88		dey				dey
.018c58	20 a3 85	jsr $0185a3			jsr 	Print32BitInteger 			; print integer.
.018c5b	80 98		bra $018bf5			bra 	_LIDecode
.018c5d					_LICommandToken:
.018c5d	5a		phy				phy 								; save Y
.018c5e	48		pha				pha 								; save token
.018c5f	a2 9b		ldx #$9b			ldx  	#KeywordText & $FF 			; address of keyword text table.
.018c61	a9 86		lda #$86			lda 	(#KeywordText >> 8) & $FF
.018c63	86 1a		stx $1a				stx 	zLTemp1
.018c65	85 1b		sta $1b				sta 	zLTemp1+1
.018c67	a9 01		lda #$01			lda 	(#KeywordText >> 16) & $FF 	; this is for 65816 (it's a table in code
.018c69	85 1c		sta $1c				sta 	zLTemp1+2 					; space) and won't affect a 6502 at all.
.018c6b	68		pla				pla 								; get token
.018c6c	29 7f		and #$7f			and 	#127 						; chuck bit 7.
.018c6e	f0 16		beq $018c86			beq 	_LIFoundToken
.018c70	aa		tax				tax
.018c71					_LITokenLoop:
.018c71	a0 00		ldy #$00			ldy 	#0 							; last character not a token.
.018c73					_LIFindEnd:
.018c73	b7 1a		lda [$1a],y			lda 	[zLTemp1],y
.018c75	c8		iny				iny
.018c76	0a		asl a				asl 	a
.018c77	90 fa		bcc $018c73			bcc 	_LIFindEnd
.018c79	98		tya				tya 								; that is step to the next
.018c7a	18		clc				clc 								; we don't bother bumping the 3rd byte
.018c7b	65 1a		adc $1a				adc 	zLTemp1 					; here.
.018c7d	85 1a		sta $1a				sta 	zLTemp1
.018c7f	90 02		bcc $018c83			bcc 	_LINoBump
.018c81	e6 1b		inc $1b				inc 	zLTemp1+1
.018c83					_LINoBump:
.018c83	ca		dex				dex 								; no go round again.
.018c84	d0 eb		bne $018c71			bne 	_LITokenLoop
.018c86					_LIFoundToken:
.018c86	a0 00		ldy #$00			ldy 	#0
.018c88					_LIPrintToken:
.018c88	b7 1a		lda [$1a],y			lda 	[zLTemp1],y
.018c8a	c0 00		cpy #$00			cpy 	#0 							; see if needs prefix space
.018c8c	d0 16		bne $018ca4			bne 	_LINoPrefixSpace
.018c8e	c9 41		cmp #$41			cmp 	#"A" 						; e.g. alphabetic token.
.018c90	90 12		bcc $018ca4			bcc 	_LINoPrefixSpace
.018c92	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018c94	b0 0e		bcs $018ca4			bcs 	_LINoPrefixSpace
.018c96	ae ba 03	ldx $03ba			ldx 	LastPrinted 				; if last was space not required
.018c99	e0 20		cpx #$20			cpx 	#" "
.018c9b	f0 07		beq $018ca4			beq 	_LINoPrefixSpace
.018c9d	48		pha				pha
.018c9e	a9 20		lda #$20			lda 	#" "
.018ca0	20 c1 8c	jsr $018cc1			jsr 	ListPrintLC
.018ca3	68		pla				pla
.018ca4					_LINoPrefixSpace:
.018ca4	c8		iny				iny
.018ca5	48		pha				pha 								; save it
.018ca6	29 7f		and #$7f			and 	#$7F
.018ca8	20 c1 8c	jsr $018cc1			jsr 	ListPrintLC
.018cab	68		pla				pla
.018cac	10 da		bpl $018c88			bpl 	_LIPrintToken 				; go back if not end
.018cae	7a		ply				ply 								; restore Y
.018caf	29 7f		and #$7f			and 	#$7F 						; if last char is a letter
.018cb1	c9 41		cmp #$41			cmp 	#"A"
.018cb3	90 09		bcc $018cbe			bcc 	_LINotLetter2
.018cb5	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018cb7	b0 05		bcs $018cbe			bcs 	_LINotLetter2
.018cb9	a9 20		lda #$20			lda 	#" " 						; add spacing
.018cbb	20 c1 8c	jsr $018cc1			jsr 	ListPrintLC
.018cbe					_LINotLetter2:
.018cbe	4c f5 8b	jmp $018bf5			jmp 	_LIDecode
.018cc1					ListPrintLC:
.018cc1	8d ba 03	sta $03ba			sta 	LastPrinted
.018cc4	c9 41		cmp #$41			cmp 	#"A"
.018cc6	90 06		bcc $018cce			bcc 	_LPLC0
.018cc8	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018cca	b0 02		bcs $018cce			bcs 	_LPLC0
.018ccc	69 20		adc #$20			adc 	#$20
.018cce	4c 1f 85	jmp $01851f	_LPLC0:	jmp 	CharPrint
.018cd1					ListGetRange:
.018cd1	a2 0b		ldx #$0b			ldx 	#XS_Size*2-1 				; clear first 2 slots back to defaults.
.018cd3					_LGRClear:
.018cd3	a9 00		lda #$00			lda 	#0
.018cd5	95 80		sta $80,x			sta 	XS_Mantissa,x
.018cd7	ca		dex				dex
.018cd8	10 f9		bpl $018cd3			bpl 	_LGRClear
.018cda	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018cdc	c9 00		cmp #$00			cmp 	#0 							; nothing
.018cde	f0 21		beq $018d01			beq 	_LGRBlank
.018ce0	c9 c0		cmp #$c0			cmp 	#token_Colon 				; or colon
.018ce2	f0 1d		beq $018d01			beq 	_LGRBlank
.018ce4	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma
.018ce6	f0 18		beq $018d00			beq 	_LGREnd 					; then it's LIST ,x
.018ce8	20 24 91	jsr $019124			jsr 	EvaluateInteger 			; get the first number into bottom
.018ceb	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018ced	c9 bf		cmp #$bf			cmp 	#token_Comma
.018cef	f0 0f		beq $018d00			beq 	_LGREnd 					; then it is LIST a,b
.018cf1	a5 80		lda $80				lda 	XS_Mantissa+0 				; copy first to second LIST n is n,n
.018cf3	85 86		sta $86				sta 	XS_Mantissa+XS_Size+0
.018cf5	a5 81		lda $81				lda 	XS_Mantissa+1
.018cf7	85 87		sta $87				sta 	XS_Mantissa+XS_Size+1
.018cf9					_LGRBumpExit:
.018cf9	e6 86		inc $86				inc 	XS_Mantissa+XS_Size 		; bump it so we can use cc.
.018cfb	d0 02		bne $018cff			bne 	_LGRBump2
.018cfd	e6 87		inc $87				inc 	XS_Mantissa+XS_Size+1
.018cff					_LGRBump2:
.018cff	60		rts				rts
.018d00					_LGREnd:
.018d00	c8		iny				iny
.018d01					_LGRBlank:
.018d01	a9 ff		lda #$ff			lda 	#$FF 						; default to the end.
.018d03	85 86		sta $86				sta 	XS_Mantissa+XS_Size
.018d05	85 87		sta $87				sta 	XS_Mantissa+XS_Size+1
.018d07	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018d09	c9 00		cmp #$00			cmp 	#0
.018d0b	f0 f2		beq $018cff			beq 	_LGRBump2
.018d0d	0a		asl a				asl 	a 							; if not a number, then exit (to end)
.018d0e	b0 ef		bcs $018cff			bcs 	_LGRBump2
.018d10	a2 06		ldx #$06			ldx 	#XS_Size 					; get to range
.018d12	20 26 91	jsr $019126			jsr 	EvaluateIntegerX
.018d15	80 e2		bra $018cf9			bra 	_LGRBumpExit
.018d17	60		rts				rts
.018d18					ListCheckRange:
.018d18	c8		iny				iny
.018d19	a2 00		ldx #$00			ldx 	#0 							; test low
.018d1b	20 28 8d	jsr $018d28			jsr 	_LCRCompare
.018d1e	90 06		bcc $018d26			bcc 	_LCRFail
.018d20	a2 06		ldx #$06			ldx 	#XS_Size 					; test high
.018d22	20 28 8d	jsr $018d28			jsr 	_LCRCompare
.018d25	60		rts				rts
.018d26					_LCRFail:
.018d26	38		sec				sec
.018d27	60		rts				rts
.018d28					_LCRCompare:
.018d28	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018d2a	38		sec				sec
.018d2b	f5 80		sbc $80,x			sbc	 	XS_Mantissa+0,x
.018d2d	08		php				php
.018d2e	c8		iny				iny
.018d2f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018d31	28		plp				plp
.018d32	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.018d34	08		php				php
.018d35	88		dey				dey
.018d36	28		plp				plp
.018d37	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/print.asm

.018d38					Command_PRINT:
.018d38	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018d3a	c9 00		cmp #$00			cmp 	#0 							; end
.018d3c	f0 65		beq $018da3			beq 	_CPR_NewLine
.018d3e	c9 c0		cmp #$c0			cmp 	#token_Colon
.018d40	f0 61		beq $018da3			beq 	_CPR_NewLine
.018d42	c9 c1		cmp #$c1			cmp 	#token_SemiColon
.018d44	f0 50		beq $018d96			beq 	_CPR_Skip
.018d46	c9 bf		cmp #$bf			cmp 	#token_Comma
.018d48	f0 49		beq $018d93			beq 	_CPR_Tab
.018d4a	20 8e 8f	jsr $018f8e			jsr 	EvaluateExpression 			; get expression.
.018d4d	a5 85		lda $85				lda 	XS_Type 					; get type.
.018d4f	29 02		and #$02			and 	#2
.018d51	d0 24		bne $018d77			bne 	_CPR_String 				; if type = 2 output as string.
.018d53					_CPR_Number:
.018d53	a9 00		lda #$00			lda 	#0 							; reset buffer index
.018d55	8d 14 03	sta $0314			sta 	NumBufX
.018d58	a5 85		lda $85				lda 	XS_Type 					; get type
.018d5a	4a		lsr a				lsr 	a
.018d5b	b0 05		bcs $018d62			bcs 	_CPRInt 					; if msb set do as integer
.018d5d	20 47 a2	jsr $01a247			jsr 	FPToString 					; call fp to str otherwise
.018d60	80 03		bra $018d65			bra 	_CPRNPrint
.018d62	20 cf 9c	jsr $019ccf	_CPRInt:jsr 	IntToString
.018d65					_CPRNPrint:
.018d65	ad 15 03	lda $0315			lda 	Num_Buffer 					; is first character -
.018d68	c9 2d		cmp #$2d			cmp 	#"-"
.018d6a	f0 05		beq $018d71			beq 	_CPRNoSpace
.018d6c	a9 20		lda #$20			lda 	#" "						; print the leading space
.018d6e	20 1f 85	jsr $01851f			jsr 	CharPrint 					; so beloved of MS Basics.
.018d71					_CPRNoSpace:
.018d71	a2 14		ldx #$14			ldx 	#(Num_Buffer-1) & $FF
.018d73	a9 03		lda #$03			lda 	#(Num_Buffer-1) >> 8
.018d75	80 04		bra $018d7b			bra 	_CPRPrint
.018d77					_CPR_String:
.018d77	a6 80		ldx $80				ldx 	XS_Mantissa
.018d79	a5 81		lda $81				lda 	XS_Mantissa+1
.018d7b					_CPRPrint:
.018d7b	86 1e		stx $1e				stx 	zGenPtr
.018d7d	85 1f		sta $1f				sta 	zGenPtr+1
.018d7f	5a		phy				phy
.018d80	a0 00		ldy #$00			ldy 	#0							; get length into X
.018d82	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018d84	aa		tax				tax
.018d85	f0 09		beq $018d90			beq 	_CPREndPrint 				; nothing to print
.018d87					_CPRLoop:
.018d87	c8		iny				iny
.018d88	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018d8a	20 1f 85	jsr $01851f			jsr 	CharPrint
.018d8d	ca		dex				dex
.018d8e	d0 f7		bne $018d87			bne 	_CPRLoop
.018d90					_CPREndPrint:
.018d90	7a		ply				ply
.018d91	80 a5		bra $018d38			bra 	Command_Print
.018d93					_CPR_Tab:
.018d93	20 4f 80	jsr $01804f			jsr 	IFT_Tab
.018d96					_CPR_Skip:
.018d96	c8		iny				iny
.018d97	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018d99	c9 c0		cmp #$c0			cmp 	#token_Colon 				; colon or $00, exit
.018d9b	f0 09		beq $018da6			beq 	_CPR_Exit
.018d9d	c9 00		cmp #$00			cmp 	#0
.018d9f	d0 97		bne $018d38			bne 	Command_PRINT 				; if not go round again.
.018da1	80 03		bra $018da6			bra 	_CPR_Exit
.018da3					_CPR_NewLine:
.018da3	20 5c 80	jsr $01805c			jsr 	IFT_NewLine
.018da6					_CPR_Exit:
.018da6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/assert.asm

.018da7					Command_ASSERT:
.018da7	20 24 91	jsr $019124			jsr 	EvaluateInteger 			; calculate thing being asserted
.018daa	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; check if true (non-zero)
.018dac	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.018dae	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.018db0	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.018db2	f0 01		beq $018db5			beq 	_ASFail
.018db4	60		rts				rts
.018db5					_ASFail:
.018db5	20 57 85	jsr $018557			jsr ERR_Handler
>018db8	41 73 73 65 72 74 00			.text "Assert",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/poke.asm

.018dbf					Command_POKE:
.018dbf	a9 01		lda #$01			lda 	#1
.018dc1	80 06		bra $018dc9			bra 	CmdPoke_Main
.018dc3					Command_DOKE:
.018dc3	a9 02		lda #$02			lda 	#2
.018dc5	80 02		bra $018dc9			bra 	CmdPoke_Main
.018dc7					Command_LOKE:
.018dc7	a9 04		lda #$04			lda 	#4
.018dc9					CmdPoke_Main:
.018dc9	48		pha				pha
.018dca	20 24 91	jsr $019124			jsr 	EvaluateInteger 			; get two parameters.
.018dcd	e8		inx				inx
.018dce	e8		inx				inx
.018dcf	e8		inx				inx
.018dd0	e8		inx				inx
.018dd1	e8		inx				inx
.018dd2	e8		inx				inx
.018dd3	20 54 97	jsr $019754			jsr 	CheckNextComma
.018dd6	20 26 91	jsr $019126			jsr 	EvaluateIntegerX
.018dd9	a5 80		lda $80				lda 	XS_Mantissa+0 			; copy the mantissa into ZLTemp1 (address)
.018ddb	85 1a		sta $1a				sta 	zLTemp1
.018ddd	a5 81		lda $81				lda 	XS_Mantissa+1
.018ddf	85 1b		sta $1b				sta 	zLTemp1+1
.018de1	a5 82		lda $82				lda 	XS_Mantissa+2
.018de3	85 1c		sta $1c				sta 	zLTemp1+2
.018de5	a5 83		lda $83				lda 	XS_Mantissa+3
.018de7	85 1d		sta $1d				sta 	zLTemp1+3
.018de9	68		pla				pla 								; get count
.018dea	5a		phy				phy 								; save Y
.018deb	20 df 96	jsr $0196df			jsr 	MemWrite 					; write it out
.018dee	7a		ply				ply 								; restore Y and done.
.018def	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/newold.asm

.018df0					Command_NEW:
.018df0	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018df2	85 16		sta $16				sta 	zCodePtr+0
.018df4	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018df6	85 17		sta $17				sta 	zCodePtr+1
.018df8	a9 00		lda #$00			lda 	#0
.018dfa	85 18		sta $18				sta 	zCodePtr+2
.018dfc	85 19		sta $19				sta 	zCodePtr+3
.018dfe	a0 03		ldy #$03			ldy 	#3
.018e00	a0 00		ldy #$00			ldy 	#0
.018e02	a9 00		lda #$00			lda 	#0 							; write a 0 there.
.018e04	97 16		sta [$16],y			sta 	[zCodePtr],y
.018e06	20 f0 96	jsr $0196f0			jsr 	UpdateProgramEnd 			; update program end.
.018e09	4c 10 88	jmp $018810			jmp 	WarmStart
.018e0c					Command_OLD:
.018e0c	ea		nop				nop
.018e0d	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018e0f	85 16		sta $16				sta 	zCodePtr+0
.018e11	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018e13	85 17		sta $17				sta 	zCodePtr+1
.018e15	a9 00		lda #$00			lda 	#0
.018e17	85 18		sta $18				sta 	zCodePtr+2
.018e19	85 19		sta $19				sta 	zCodePtr+3
.018e1b	a0 03		ldy #$03			ldy 	#3
.018e1d					_COL_Find:
.018e1d	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e1f	c8		iny				iny
.018e20	c9 00		cmp #$00			cmp 	#0 							; if zero, then the position Y/Z is new offset
.018e22	f0 18		beq $018e3c			beq 	_COL_Found
.018e24	98		tya				tya
.018e25	c9 00		cmp #$00			cmp 	#0
.018e27	d0 f4		bne $018e1d			bne 	_COL_Find 					; can't find old EOL, give up.
.018e29	20 57 85	jsr $018557			jsr ERR_Handler
>018e2c	50 72 6f 67 72 61 6d 20			.text "Program Corrupt",0
>018e34	43 6f 72 72 75 70 74 00
.018e3c					_COL_Found:
.018e3c	98		tya				tya
.018e3d	48		pha				pha
.018e3e	a0 00		ldy #$00			ldy 	#0
.018e40	68		pla				pla
.018e41	97 16		sta [$16],y			sta 	[zCodePtr],y
.018e43	20 f0 96	jsr $0196f0			jsr 	UpdateProgramEnd 			; reset variable pointer
.018e46	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/branch.asm

.018e47					Command_GOTO:
.018e47	20 b6 8e	jsr $018eb6			jsr 	GotoGetLineNumber
.018e4a					CmdGOTO:
.018e4a	a2 00		ldx #$00			ldx 	#0
.018e4c	4c d3 8e	jmp $018ed3			jmp 	GotoChangeToLineNumberX
.018e4f					Command_GOSUB:
.018e4f	20 b6 8e	jsr $018eb6			jsr 	GotoGetLineNumber
.018e52					CmdGOSUB:
.018e52	20 e6 84	jsr $0184e6			jsr 	StackSavePosition
.018e55	a9 15		lda #$15			lda 	#(SMark_Gosub << 4)+SourcePosSize
.018e57	20 9f 84	jsr $01849f			jsr 	StackPushFrame
.018e5a	a2 00		ldx #$00			ldx		#0
.018e5c	4c d3 8e	jmp $018ed3			jmp 	GotoChangeToLineNumberX
.018e5f					Command_RETURN:
.018e5f	a9 10		lda #$10			lda 	#(SMark_Gosub << 4)
.018e61	20 b6 84	jsr $0184b6			jsr 	StackPopFrame
.018e64	20 03 85	jsr $018503			jsr 	StackRestorePosition
.018e67	60		rts				rts
.018e68					Command_ON:
.018e68	a2 00		ldx #$00			ldx 	#0 							; get the ON.
.018e6a	20 b4 95	jsr $0195b4			jsr 	SLIByteParameter
.018e6d	a5 80		lda $80				lda 	XS_Mantissa+0 				; get the count
.018e6f	f0 42		beq $018eb3			beq 	_CONFail 					; can't be zero.
.018e71	aa		tax				tax 								; save in X.
.018e72	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e74	c8		iny				iny
.018e75	48		pha				pha
.018e76	c9 cc		cmp #$cc			cmp 	#token_GOTO 				; must be GOTO or GOSUB
.018e78	f0 07		beq $018e81			beq 	_CONOkayToken
.018e7a	c9 ca		cmp #$ca			cmp 	#token_GOSUB
.018e7c	f0 03		beq $018e81			beq 	_CONOkayToken
.018e7e	4c 28 85	jmp $018528			jmp 	SyntaxError
.018e81					_CONOkayToken:
.018e81	da		phx				phx 								; count on top, GOTO/GOSUB token 2nd.
.018e82					_CONFindNumber:
.018e82	20 b6 8e	jsr $018eb6			jsr 	GotoGetLineNumber 			; get a line number.
.018e85	fa		plx				plx 								; restore count
.018e86	ca		dex				dex  								; decrement, exit if zero.
.018e87	f0 06		beq $018e8f			beq 	_CONFound
.018e89	da		phx				phx 								; push back
.018e8a	20 54 97	jsr $019754			jsr 	CheckNextComma				; check for comma
.018e8d	80 f3		bra $018e82			bra 	_CONFindNumber
.018e8f					_CONFound:
.018e8f	68		pla				pla 								; get token
.018e90	c9 cc		cmp #$cc			cmp 	#token_GOTO 				; if GOTO
.018e92	f0 b6		beq $018e4a			beq		CmdGOTO 					; then just branch.
.018e94					_CONEndOfCmd:
.018e94	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e96	c9 00		cmp #$00			cmp 	#0 							; if zero, end of line, so exit
.018e98	f0 b8		beq $018e52			beq 	CMDGosub
.018e9a	c9 c0		cmp #$c0			cmp 	#token_Colon 				; if colon, end of command
.018e9c	f0 b4		beq $018e52			beq 	CMDGosub
.018e9e	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018ea0	c8		iny				iny 								; skip
.018ea1	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018ea3	90 0c		bcc $018eb1			bcc 	_SEDone 					; so just skip over it.
.018ea5	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018ea7	90 07		bcc $018eb0			bcc 	_SEDouble
.018ea9	98		tya				tya 								; this is Y + 1
.018eaa	18		clc				clc
.018eab	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018ead	a8		tay				tay 								; back in Y.
.018eae	88		dey				dey 								; fix up, one for the +1, one for the iny
.018eaf	88		dey				dey
.018eb0					_SEDouble:
.018eb0	c8		iny				iny
.018eb1					_SEDone:
.018eb1	80 e1		bra $018e94			bra 	_CONEndOfCmd
.018eb3					_CONFail:
.018eb3	4c 46 85	jmp $018546			jmp 	BadParamError
.018eb6					GotoGetLineNumber:
.018eb6	20 24 91	jsr $019124			jsr 	EvaluateInteger
.018eb9	a5 82		lda $82				lda 	XS_Mantissa+2 				; check range
.018ebb	05 83		ora $83				ora 	XS_Mantissa+3
.018ebd	d0 01		bne $018ec0			bne 	_GLINError
.018ebf	60		rts				rts
.018ec0					_GLINError:
.018ec0	20 57 85	jsr $018557			jsr ERR_Handler
>018ec3	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>018ecb	20 4e 75 6d 62 65 72 00
.018ed3					GotoChangeToLineNumberX:
.018ed3	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check line number not zero
.018ed5	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.018ed7	f0 37		beq $018f10			beq 	_GCTLFail
.018ed9	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018edb	85 16		sta $16				sta 	zCodePtr+0
.018edd	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018edf	85 17		sta $17				sta 	zCodePtr+1
.018ee1	a9 00		lda #$00			lda 	#0
.018ee3	85 18		sta $18				sta 	zCodePtr+2
.018ee5	85 19		sta $19				sta 	zCodePtr+3
.018ee7	a0 03		ldy #$03			ldy 	#3
.018ee9					_GCTLLoop:
.018ee9	a0 00		ldy #$00			ldy 	#0
.018eeb	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018eed	c9 00		cmp #$00			cmp 	#0
.018eef	f0 1f		beq $018f10			beq 	_GCTLFail
.018ef1	c8		iny				iny
.018ef2	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018ef4	d5 80		cmp $80,x			cmp 	XS_Mantissa+0,x
.018ef6	d0 07		bne $018eff			bne 	_GCTLNext
.018ef8	c8		iny				iny
.018ef9	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018efb	d5 81		cmp $81,x			cmp 	XS_Mantissa+1,x
.018efd	f0 0f		beq $018f0e			beq 	_GCTLExit
.018eff					_GCTLNext:
.018eff	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018f01	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.018f03	18		clc				clc
.018f04	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018f06	85 16		sta $16				sta 	zCodePtr
.018f08	90 02		bcc $018f0c			bcc 	_SNLNoCarry
.018f0a	e6 17		inc $17				inc 	zCodePtr+1
.018f0c					_SNLNoCarry:
.018f0c	80 db		bra $018ee9			bra 	_GCTLLoop 					; try next line.
.018f0e					_GCTLExit:
.018f0e	c8		iny				iny
.018f0f	60		rts				rts
.018f10					_GCTLFail:
.018f10	20 57 85	jsr $018557			jsr ERR_Handler
>018f13	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>018f1b	20 4e 75 6d 62 65 72 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.018f23					Command_CLR:
.018f23					ResetRunStatus:
.018f23	20 29 98	jsr $019829			jsr 	VariableClear
.018f26	20 8d 84	jsr $01848d			jsr 	StackReset
.018f29	a9 00		lda #$00			lda 	#HighMemory & $FF
.018f2b	8d 00 03	sta $0300			sta 	StringPtr
.018f2e	a9 7f		lda #$7f			lda 	#HighMemory >> 8
.018f30	8d 01 03	sta $0301			sta 	StringPtr+1
.018f33	20 f3 99	jsr $0199f3			jsr 	ArrayResetDefault
.018f36	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/stop.asm

.018f37					Command_STOP:
.018f37	20 57 85	jsr $018557			jsr ERR_Handler
>018f3a	53 74 6f 70 00				.text "Stop",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/while.asm

.018f3f					Command_WHILE:
.018f3f	20 e6 84	jsr $0184e6			jsr 	StackSavePosition			; save position into stack, but don't yet push.
.018f42	20 24 91	jsr $019124			jsr 	EvaluateInteger 			; calculate the while loop value.
.018f45	a5 80		lda $80				lda 	XS_Mantissa+0				; check the result if zero
.018f47	05 81		ora $81				ora 	XS_Mantissa+1
.018f49	05 82		ora $82				ora 	XS_Mantissa+2
.018f4b	05 83		ora $83				ora 	XS_Mantissa+3
.018f4d	f0 06		beq $018f55			beq 	_CWHSkip 					; if it is zero, then skip to WEND.
.018f4f	a9 35		lda #$35			lda 	#(SMark_While << 4)+SourcePosSize
.018f51	20 9f 84	jsr $01849f			jsr 	StackPushFrame 				; push on stack
.018f54	60		rts				rts
.018f55					_CWHSkip:
.018f55	a9 95		lda #$95			lda 	#token_Wend 				; look for the WEND token.
.018f57	20 00 84	jsr $018400			jsr 	StructureSearchSingle
.018f5a	c8		iny				iny
.018f5b	60		rts				rts
.018f5c					Command_WEND:
.018f5c	a9 30		lda #$30			lda 	#(SMark_While << 4)			; remove the frame
.018f5e	20 b6 84	jsr $0184b6			jsr 	StackPopFrame
.018f61	20 03 85	jsr $018503			jsr 	StackRestorePosition
.018f64	80 d9		bra $018f3f			bra 	Command_WHILE 				; and do the while again.
.018f66	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/repeat.asm

.018f67					Command_REPEAT:
.018f67	20 e6 84	jsr $0184e6			jsr 	StackSavePosition			; save position into stack
.018f6a	a9 25		lda #$25			lda 	#(SMark_Repeat << 4)+SourcePosSize
.018f6c	20 9f 84	jsr $01849f			jsr 	StackPushFrame 				; push on stack
.018f6f	60		rts				rts
.018f70					Command_UNTIL:
.018f70	a9 20		lda #$20			lda 	#(SMark_Repeat << 4)		; remove the frame
.018f72	20 b6 84	jsr $0184b6			jsr 	StackPopFrame
.018f75	20 24 91	jsr $019124			jsr 	EvaluateInteger				; work out UNTIL
.018f78	a5 80		lda $80				lda 	XS_Mantissa+0 				; check if zero.
.018f7a	05 81		ora $81				ora 	XS_Mantissa+1
.018f7c	05 82		ora $82				ora 	XS_Mantissa+2
.018f7e	05 83		ora $83				ora 	XS_Mantissa+3
.018f80	d0 08		bne $018f8a			bne 	_CUTExit 					; if not, just exit
.018f82	20 03 85	jsr $018503			jsr 	StackRestorePosition 		; otherwise loop round again.
.018f85	a9 25		lda #$25			lda 	#(SMark_Repeat << 4)+SourcePosSize
.018f87	20 9f 84	jsr $01849f			jsr 	StackPushFrame 				; fix the stack back.
.018f8a					_CUTExit:
.018f8a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.018f8b					EVESyntax:
.018f8b	4c 28 85	jmp $018528			jmp 	SyntaxError
.018f8e					EvaluateExpression:
.018f8e	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.018f90					EvaluateExpressionX:
.018f90	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.018f92					EvaluateExpressionXA:
.018f92	48		pha				pha 								; save precedence on stack.
.018f93	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018f95	f0 f4		beq $018f8b			beq 	EVESyntax 					; end of line, syntax error.
.018f97	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.018f99	b0 03		bcs $018f9e			bcs 	_EVNotVariable
.018f9b	4c 68 90	jmp $019068			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.018f9e					_EVNotVariable:
.018f9e	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.018fa0	90 e9		bcc $018f8b			bcc 	EVESyntax
.018fa2	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.018fa4	b0 58		bcs $018ffe			bcs 	_EVNotInteger
.018fa6	20 96 90	jsr $019096			jsr 	EvaluateGetInteger
.018fa9					_EVCheckDecimal:
.018fa9	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018fab	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.018fad	d0 05		bne $018fb4			bne 	_EVGotAtom 					; no, get atom.
.018faf					_EVIsDecimal:
.018faf	20 bc 90	jsr $0190bc			jsr 	EVGetDecimal 				; extend to the decimal part.
.018fb2	80 00		bra $018fb4			bra 	_EVGotAtom 					; and continue to got atom.
.018fb4					_EVGotAtom:
.018fb4	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018fb6	10 44		bpl $018ffc			bpl 	_EVExitDrop 				; must be a token.
.018fb8	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.018fba	b0 40		bcs $018ffc			bcs 	_EVExitDrop
.018fbc	68		pla				pla 								; get current precedence
.018fbd	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.018fbf	da		phx				phx 								; save X
.018fc0	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018fc2	aa		tax				tax 								; put in X
.018fc3	bf 0c 86 01	lda $01860c,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.018fc7	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.018fc9	fa		plx				plx 								; restore X
.018fca	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.018fcc	90 2f		bcc $018ffd			bcc 	_EVExit 					; exit if too low.
.018fce	f0 2d		beq $018ffd			beq 	_EVExit 					; exit if equals
.018fd0	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.018fd2	48		pha				pha
.018fd3	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018fd5	48		pha				pha
.018fd6	c8		iny				iny
.018fd7	da		phx				phx 								; save current position
.018fd8	e8		inx				inx
.018fd9	e8		inx				inx
.018fda	e8		inx				inx
.018fdb	e8		inx				inx
.018fdc	e8		inx				inx
.018fdd	e8		inx				inx
.018fde	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.018fe0	20 92 8f	jsr $018f92			jsr 	EvaluateExpressionXA 		; do the RHS.
.018fe3	fa		plx				plx 								; restore X
.018fe4	68		pla				pla 								; get the binary operator in A.
.018fe5					_EVCallA:
.018fe5	da		phx				phx 								; save X again
.018fe6	0a		asl a				asl 	a 							; double, lose the MSB.
.018fe7	aa		tax				tax									; put in X
.018fe8	bf bb 85 01	lda $0185bb,x			lda 	VectorTable,x 				; copy address into zGenPtr
.018fec	8d 11 03	sta $0311			sta 	LocalVector+1
.018fef	bf bc 85 01	lda $0185bc,x			lda 	VectorTable+1,x
.018ff3	8d 12 03	sta $0312			sta 	LocalVector+2
.018ff6	fa		plx				plx 								; restore X
.018ff7	20 71 90	jsr $019071			jsr 	EVCallLocalVector
.018ffa	80 b8		bra $018fb4			bra 	_EVGotAtom 					; and loop back.
.018ffc					_EVExitDrop:
.018ffc	68		pla				pla
.018ffd					_EVExit:
.018ffd	60		rts				rts
.018ffe					_EVNotInteger:
.018ffe	c8		iny				iny
.018fff	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.019001	d0 16		bne $019019			bne 	_EVNotMinus
.019003	20 05 91	jsr $019105			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.019006	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.019008	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.01900a	f0 05		beq $019011			beq 	_EVMinusFloat
.01900c	20 b2 9c	jsr $019cb2			jsr 	IntegerNegateAlways 		; negation
.01900f	80 a3		bra $018fb4			bra 	_EVGotAtom 					; and go back.
.019011					_EVMinusFloat:
.019011	b5 85		lda $85,x			lda 	XS_Type,x 					; invert the sign bit.
.019013	49 80		eor #$80			eor 	#$80
.019015	95 85		sta $85,x			sta 	XS_Type,x
.019017	80 9b		bra $018fb4			bra 	_EVGotAtom
.019019					_EVNotMinus:
.019019	c9 bd		cmp #$bd			cmp 	#token_lparen 				; is it left parenthesis
.01901b	d0 17		bne $019034			bne 	_EVNotParenthesis
.01901d	20 90 8f	jsr $018f90			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.019020	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019022	c8		iny				iny
.019023	c9 be		cmp #$be			cmp 	#token_rparen 				; okay if right bracket.
.019025	f0 8d		beq $018fb4			beq 	_EVGotAtom
.019027	20 57 85	jsr $018557			jsr ERR_Handler
>01902a	4d 69 73 73 69 6e 67 20			.text "Missing )",0
>019032	29 00
.019034					_EVNotParenthesis:
.019034	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.019036	d0 0c		bne $019044			bne 	_EVNotNot
.019038	20 05 91	jsr $019105			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.01903b	20 48 a1	jsr $01a148			jsr 	FPUToInteger 				; make it an integer - if possible.
.01903e	20 ea 90	jsr $0190ea			jsr 	NotInteger 					; do the not calculation
.019041	4c b4 8f	jmp $018fb4			jmp 	_EVGotAtom
.019044					_EVNotNot:
.019044	c9 fe		cmp #$fe			cmp 	#$FE
.019046	d0 12		bne $01905a			bne 	_EVNotString
.019048	20 c7 97	jsr $0197c7			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.01904b	a5 20		lda $20				lda 	zTempStr 					; copy address of string into mantissa
.01904d	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01904f	a5 21		lda $21				lda 	zTempStr+1
.019051	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019053	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.019055	95 85		sta $85,x			sta 	XS_Type,x
.019057	4c b4 8f	jmp $018fb4			jmp 	_EVGotAtom
.01905a					_EVNotString:
.01905a	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.01905c	90 04		bcc $019062			bcc 	_EVBadElement
.01905e	c9 b7		cmp #$b7			cmp 	#lastUnaryFunction+1
.019060	90 03		bcc $019065			bcc 	_EVUnaryFunction
.019062					_EVBadElement:
.019062	4c 28 85	jmp $018528			jmp 	SyntaxError
.019065					_EVUnaryFunction:
.019065	4c e5 8f	jmp $018fe5			jmp 	_EVCallA
.019068					_EVVariableHandler:
.019068	20 ed 97	jsr $0197ed			jsr 	VariableFind 				; locate a variable
.01906b	20 35 9b	jsr $019b35			jsr 	VariableGet 				; copy into memory.
.01906e	4c b4 8f	jmp $018fb4			jmp 	_EVGotAtom 					; and go round.
.019071					EVCallLocalVector:
.019071	6c 11 03	jmp ($0311)			jmp 	(LocalVector+1)
.019074					EVShiftMantissaLeft6:
.019074	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.019076	95 84		sta $84,x			sta 	XS_Exponent,x
.019078	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01907a	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01907c	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01907e	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019080	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019082	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019084	a9 00		lda #$00			lda 	#0
.019086	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019088	20 8b 90	jsr $01908b			jsr 	_EVSMLShift 					; call it here to do it twice
.01908b					_EVSMLShift:
.01908b	56 84		lsr $84,x			lsr 	XS_Exponent,x
.01908d	76 83		ror $83,x			ror 	XS_Mantissa+3,x
.01908f	76 82		ror $82,x			ror 	XS_Mantissa+2,x
.019091	76 81		ror $81,x			ror 	XS_Mantissa+1,x
.019093	76 80		ror $80,x			ror 	XS_Mantissa+0,x
.019095	60		rts				rts
.019096					EvaluateGetInteger:
.019096	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019098	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.01909a	95 80		sta $80,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.01909c	a9 00		lda #$00			lda 	#0
.01909e	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0190a0	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0190a2	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0190a4	1a		inc a				inc 	a 							; set to type 1 (integer)
.0190a5	95 85		sta $85,x			sta 	XS_Type,x
.0190a7					_EVCheckNextInteger:
.0190a7	c8		iny				iny
.0190a8	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0190aa	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.0190ac	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.0190ae	b0 0b		bcs $0190bb			bcs 	_EVEndInteger
.0190b0	48		pha				pha 								; save it.
.0190b1	20 74 90	jsr $019074			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.0190b4	68		pla				pla
.0190b5	15 80		ora $80,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.0190b7	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0190b9	80 ec		bra $0190a7			bra 	_EVCheckNextInteger
.0190bb					_EVEndInteger:
.0190bb	60		rts				rts
.0190bc					EVGetDecimal:
.0190bc	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.0190be	8d 15 03	sta $0315			sta 	Num_Buffer
.0190c1	da		phx				phx
.0190c2	c8		iny				iny
.0190c3	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0190c5	c8		iny				iny
.0190c6	3a		dec a				dec 	a								; convert to a string length.
.0190c7	3a		dec a				dec 	a
.0190c8	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.0190ca					_EVGDCopy:
.0190ca	48		pha				pha 									; save count
.0190cb	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0190cd	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.0190d0	e8		inx				inx 									; forward ....
.0190d1	c8		iny				iny
.0190d2	68		pla				pla 									; get count
.0190d3	3a		dec a				dec 	a 								; until zero
.0190d4	d0 f4		bne $0190ca			bne 	_EVGDCopy
.0190d6	9d 15 03	sta $0315,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.0190d9	fa		plx				plx 									; restore X
.0190da	a9 15		lda #$15			lda 	#Num_Buffer & $FF 				; set zGenPtr
.0190dc	85 1e		sta $1e				sta 	zGenPtr
.0190de	a9 03		lda #$03			lda 	#Num_Buffer >> 8
.0190e0	85 1f		sta $1f				sta 	zGenPtr+1
.0190e2	5a		phy				phy 									; save Y
.0190e3	a0 00		ldy #$00			ldy 	#0 								; start position
.0190e5	20 02 a3	jsr $01a302			jsr 	FPFromString 					; convert current
.0190e8	7a		ply				ply 									; restore Y
.0190e9	60		rts				rts
.0190ea					NotInteger:
.0190ea	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0190ec	49 ff		eor #$ff			eor 	#$FF
.0190ee	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0190f0	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0190f2	49 ff		eor #$ff			eor 	#$FF
.0190f4	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0190f6	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0190f8	49 ff		eor #$ff			eor 	#$FF
.0190fa	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0190fc	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.0190fe	49 ff		eor #$ff			eor 	#$FF
.019100	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019102	60		rts				rts
.019103					EvaluateGetAtom:
.019103	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.019105					EvaluateGetAtomX:
.019105	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.019107	20 92 8f	jsr $018f92			jsr 	EvaluateExpressionXA
.01910a	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.01910c	29 0f		and #$0f			and 	#15
.01910e	c9 02		cmp #$02			cmp 	#2
.019110	b0 01		bcs $019113			bcs 	EvaluateType
.019112	60		rts				rts
.019113					EvaluateType:
.019113	4c 38 85	jmp $018538			jmp 	TypeError
.019116					EvaluateNumber:
.019116	a2 00		ldx #$00			ldx 	#0
.019118					EvaluateNumberX:
.019118	20 90 8f	jsr $018f90			jsr 	EvaluateExpressionX
.01911b	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0/1
.01911d	29 0f		and #$0f			and 	#15
.01911f	c9 02		cmp #$02			cmp 	#2
.019121	b0 f0		bcs $019113			bcs 	EvaluateType
.019123	60		rts				rts
.019124					EvaluateInteger:
.019124	a2 00		ldx #$00			ldx 	#0
.019126					EvaluateIntegerX:
.019126	20 18 91	jsr $019118			jsr 	EvaluateNumberX
.019129	20 48 a1	jsr $01a148			jsr 	FPUToInteger
.01912c	60		rts				rts
.01912d					EvaluateString:
.01912d	a2 00		ldx #$00			ldx 	#0
.01912f					EvaluateStringX:
.01912f	20 90 8f	jsr $018f90			jsr 	EvaluateExpressionX
.019132	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 2
.019134	29 0f		and #$0f			and 	#15
.019136	c9 02		cmp #$02			cmp 	#2
.019138	d0 d9		bne $019113			bne 	EvaluateType
.01913a	b5 80		lda $80,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.01913c	85 1e		sta $1e				sta 	zGenPtr
.01913e	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019140	85 1f		sta $1f				sta 	zGenPtr+1
.019142	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.019143					BinaryOp_And:
.019143	20 97 91	jsr $019197			jsr 	BinaryMakeBothInteger
.019146	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.019148	35 86		and $86,x			and 	XS2_Mantissa+0,x
.01914a	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01914c	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.01914e	35 87		and $87,x			and 	XS2_Mantissa+1,x
.019150	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019152	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.019154	35 88		and $88,x			and 	XS2_Mantissa+2,x
.019156	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019158	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.01915a	35 89		and $89,x			and 	XS2_Mantissa+3,x
.01915c	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01915e	60		rts				rts
.01915f					BinaryOp_Or:
.01915f	20 97 91	jsr $019197			jsr 	BinaryMakeBothInteger
.019162	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.019164	15 86		ora $86,x			ora 	XS2_Mantissa+0,x
.019166	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019168	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.01916a	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.01916c	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01916e	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.019170	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.019172	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019174	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.019176	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.019178	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01917a	60		rts				rts
.01917b					BinaryOp_Eor:
.01917b					BinaryOp_Xor:
.01917b	20 97 91	jsr $019197			jsr 	BinaryMakeBothInteger
.01917e	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.019180	55 86		eor $86,x			eor 	XS2_Mantissa+0,x
.019182	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019184	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.019186	55 87		eor $87,x			eor 	XS2_Mantissa+1,x
.019188	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01918a	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.01918c	55 88		eor $88,x			eor 	XS2_Mantissa+2,x
.01918e	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019190	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.019192	55 89		eor $89,x			eor 	XS2_Mantissa+3,x
.019194	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019196	60		rts				rts
.019197					BinaryMakeBothInteger:
.019197	da		phx				phx 								; save X
.019198	e8		inx				inx
.019199	e8		inx				inx
.01919a	e8		inx				inx
.01919b	e8		inx				inx
.01919c	e8		inx				inx
.01919d	e8		inx				inx
.01919e	20 a2 91	jsr $0191a2			jsr 	BinaryMakeInteger 			; convert to integer.
.0191a1	fa		plx				plx 								; restore X and fall through.
.0191a2					BinaryMakeInteger:
.0191a2	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.0191a4	29 0f		and #$0f			and 	#15 						; check type zero
.0191a6	f0 04		beq $0191ac			beq 	_BMIConvert 				; if float convert to integer.
.0191a8	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.0191a9	90 04		bcc $0191af			bcc 	_BMIError
.0191ab	60		rts				rts
.0191ac					_BMIConvert:
.0191ac	4c 48 a1	jmp $01a148			jmp 	FPUToInteger 				; convert to integer
.0191af					_BMIError:
.0191af	4c 38 85	jmp $018538			jmp 	TypeError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.0191b2					Binary_Equal:
.0191b2	20 f9 91	jsr $0191f9			jsr 	CompareValues
.0191b5	09 00		ora #$00			ora 	#0
.0191b7	f0 04		beq $0191bd			beq 	CCTrue
.0191b9	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.0191bb	80 02		bra $0191bf			bra 	CCWrite
.0191bd	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.0191bf	95 80		sta $80,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.0191c1	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0191c3	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0191c5	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0191c7	a9 01		lda #$01			lda 	#1
.0191c9	95 85		sta $85,x			sta 	XS_Type,x 					; set type to integer whatever.
.0191cb	60		rts				rts
.0191cc					Binary_NotEqual:
.0191cc	20 f9 91	jsr $0191f9			jsr 	CompareValues
.0191cf	09 00		ora #$00			ora 	#0
.0191d1	f0 e6		beq $0191b9			beq 	CCFalse
.0191d3	80 e8		bra $0191bd			bra 	CCTrue
.0191d5					Binary_Less:
.0191d5	20 f9 91	jsr $0191f9			jsr 	CompareValues
.0191d8	09 00		ora #$00			ora 	#0
.0191da	30 e1		bmi $0191bd			bmi 	CCTrue
.0191dc	80 db		bra $0191b9			bra 	CCFalse
.0191de					Binary_LessEqual:
.0191de	20 f9 91	jsr $0191f9			jsr 	CompareValues
.0191e1	c9 01		cmp #$01			cmp 	#1
.0191e3	d0 d8		bne $0191bd			bne 	CCTrue
.0191e5	80 d2		bra $0191b9			bra 	CCFalse
.0191e7					Binary_GreaterEqual:
.0191e7	20 f9 91	jsr $0191f9			jsr 	CompareValues
.0191ea	09 00		ora #$00			ora 	#0
.0191ec	10 cf		bpl $0191bd			bpl 	CCTrue
.0191ee	80 c9		bra $0191b9			bra 	CCFalse
.0191f0					Binary_Greater:
.0191f0	20 f9 91	jsr $0191f9			jsr 	CompareValues
.0191f3	c9 01		cmp #$01			cmp 	#1
.0191f5	f0 c6		beq $0191bd			beq 	CCTrue
.0191f7	80 c0		bra $0191b9			bra 	CCFalse
.0191f9					CompareValues:
.0191f9	b5 85		lda $85,x			lda 	XS_Type,x 					; and the types together
.0191fb	35 8b		and $8b,x			and 	XS2_Type,x
.0191fd	c9 02		cmp #$02			cmp 	#2
.0191ff	f0 11		beq $019212			beq 	_CVString
.019201	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.019203	35 8b		and $8b,x			and 	XS2_Type,x
.019205	4a		lsr a				lsr 	a 							; shift bit 0 into C
.019206	90 03		bcc $01920b			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.019208	4c 54 92	jmp $019254			jmp 	CompareInteger32 							; so execute code at \1
.01920b					_BCFloat:
.01920b	20 f8 92	jsr $0192f8			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.01920e	4c 41 a0	jmp $01a041			jmp 	FPCompare 							; and execute code at \2
.019211	60		rts				rts
.019212					_CVString:
.019212	da		phx				phx 								; save XY
.019213	5a		phy				phy
.019214	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.019216	85 1a		sta $1a				sta		zLTemp1+0
.019218	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01921a	85 1b		sta $1b				sta 	zLTemp1+1
.01921c	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.01921e	85 1c		sta $1c				sta 	zLTemp1+2
.019220	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.019222	85 1d		sta $1d				sta 	zLTemp1+3
.019224	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.019226	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.019228	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.01922a	90 02		bcc $01922e			bcc 	_CVCommon
.01922c	b1 1c		lda ($1c),y			lda 	(zLTemp1+2),y
.01922e					_CVCommon:
.01922e	aa		tax				tax 								; put shorter string length in zero.
.01922f	f0 0c		beq $01923d			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.019231					_CVCompare:
.019231	c8		iny				iny 								; next character
.019232	b1 1a		lda ($1a),y			lda 	(zLTemp1),y 				; compare characters
.019234	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.019236	90 13		bcc $01924b			bcc 	_CVReturnLess 				; <
.019238	d0 15		bne $01924f			bne 	_CVReturnGreater 			; >
.01923a	ca		dex				dex 								; until common length matched.
.01923b	d0 f4		bne $019231			bne 	_CVCompare
.01923d					_CVMatch:
.01923d	a0 00		ldy #$00			ldy 	#0
.01923f	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.019241	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.019243	90 06		bcc $01924b			bcc 	_CVReturnLess 				; <
.019245	d0 08		bne $01924f			bne 	_CVReturnGreater 			; >
.019247	a9 00		lda #$00			lda 	#0
.019249	80 06		bra $019251			bra 	_CVExit 					; same common, same length, same string
.01924b					_CVReturnLess:
.01924b	a9 ff		lda #$ff			lda 	#$FF
.01924d	80 02		bra $019251			bra 	_CVExit
.01924f					_CVReturnGreater:
.01924f	a9 01		lda #$01			lda 	#$01
.019251					_CVExit:
.019251	7a		ply				ply
.019252	fa		plx				plx
.019253	60		rts				rts
.019254					CompareInteger32:
.019254	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.019256	49 80		eor #$80			eor 	#$80
.019258	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01925a	b5 89		lda $89,x			lda 	XS2_Mantissa+3,x
.01925c	49 80		eor #$80			eor 	#$80
.01925e	95 89		sta $89,x			sta 	XS2_Mantissa+3,x
.019260	20 de 92	jsr $0192de			jsr 	SubInteger32 				; subtraction
.019263	90 0d		bcc $019272			bcc 	_CI32Less 					; cc return -1
.019265	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check if zero
.019267	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019269	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01926b	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01926d	f0 02		beq $019271			beq 	_CI32Exit
.01926f	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.019271					_CI32Exit:
.019271	60		rts				rts
.019272					_CI32Less:
.019272	a9 ff		lda #$ff			lda 	#$FF
.019274	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.019275					BinaryOp_Add:
.019275	b5 85		lda $85,x			lda 	XS_Type,x  					; and types together
.019277	35 8b		and $8b,x			and 	XS2_Type,x
.019279	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.01927b	d0 11		bne $01928e			bne 	_BOAString
.01927d	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.01927f	35 8b		and $8b,x			and 	XS2_Type,x
.019281	4a		lsr a				lsr 	a 							; shift bit 0 into C
.019282	90 03		bcc $019287			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.019284	4c c4 92	jmp $0192c4			jmp 	AddInteger32 							; so execute code at \1
.019287					_BCFloat:
.019287	20 f8 92	jsr $0192f8			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.01928a	4c 1c 9e	jmp $019e1c			jmp 	FPAdd 							; and execute code at \2
.01928d	60		rts				rts
.01928e					_BOAString:
.01928e	4c 12 93	jmp $019312			jmp 	ConcatenateString 			; concatenate two strings.
.019291					BinaryOp_Subtract:
.019291	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.019293	35 8b		and $8b,x			and 	XS2_Type,x
.019295	4a		lsr a				lsr 	a 							; shift bit 0 into C
.019296	90 03		bcc $01929b			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.019298	4c de 92	jmp $0192de			jmp 	SubInteger32 							; so execute code at \1
.01929b					_BCFloat:
.01929b	20 f8 92	jsr $0192f8			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.01929e	4c 14 9e	jmp $019e14			jmp 	FPSubtract 							; and execute code at \2
.0192a1	60		rts				rts
.0192a2					BinaryOp_Multiply:
.0192a2	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.0192a4	35 8b		and $8b,x			and 	XS2_Type,x
.0192a6	4a		lsr a				lsr 	a 							; shift bit 0 into C
.0192a7	90 03		bcc $0192ac			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.0192a9	4c ed 9b	jmp $019bed			jmp 	MulInteger32 							; so execute code at \1
.0192ac					_BCFloat:
.0192ac	20 f8 92	jsr $0192f8			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.0192af	4c 43 9f	jmp $019f43			jmp 	FPMultiply 							; and execute code at \2
.0192b2	60		rts				rts
.0192b3					BinaryOp_Divide:
.0192b3	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.0192b5	35 8b		and $8b,x			and 	XS2_Type,x
.0192b7	4a		lsr a				lsr 	a 							; shift bit 0 into C
.0192b8	90 03		bcc $0192bd			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.0192ba	4c 2b 9c	jmp $019c2b			jmp 	DivInteger32 							; so execute code at \1
.0192bd					_BCFloat:
.0192bd	20 f8 92	jsr $0192f8			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.0192c0	4c d0 9e	jmp $019ed0			jmp 	FPDivide 							; and execute code at \2
.0192c3	60		rts				rts
.0192c4					AddInteger32:
.0192c4	18		clc				clc
.0192c5	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0192c7	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.0192c9	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0192cb	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0192cd	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.0192cf	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0192d1	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0192d3	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.0192d5	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0192d7	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.0192d9	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.0192db	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0192dd	60		rts				rts
.0192de					SubInteger32:
.0192de	38		sec				sec
.0192df	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0192e1	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.0192e3	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0192e5	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0192e7	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.0192e9	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0192eb	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0192ed	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.0192ef	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0192f1	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.0192f3	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.0192f5	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0192f7	60		rts				rts
.0192f8					BinaryMakeBothFloat:
.0192f8	da		phx				phx 								; save X
.0192f9	e8		inx				inx
.0192fa	e8		inx				inx
.0192fb	e8		inx				inx
.0192fc	e8		inx				inx
.0192fd	e8		inx				inx
.0192fe	e8		inx				inx
.0192ff	20 03 93	jsr $019303			jsr 	BinaryMakeFloat 			; convert to float.
.019302	fa		plx				plx 								; restore X and fall through.
.019303					BinaryMakeFloat:
.019303	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.019305	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.019306	b0 04		bcs $01930c			bcs 	_BMFConvert
.019308	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.019309	b0 04		bcs $01930f			bcs 	_BMFError
.01930b	60		rts				rts
.01930c					_BMFConvert:
.01930c	4c fc a0	jmp $01a0fc			jmp 	FPUToFloat 					; convert to float
.01930f					_BMFError:
.01930f	4c 38 85	jmp $018538			jmp 	TypeError
.019312					ConcatenateString:
.019312	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.019314	85 1a		sta $1a				sta		zLTemp1+0
.019316	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019318	85 1b		sta $1b				sta 	zLTemp1+1
.01931a	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.01931c	85 1c		sta $1c				sta 	zLTemp1+2
.01931e	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.019320	85 1d		sta $1d				sta 	zLTemp1+3
.019322	5a		phy				phy
.019323	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.019325	b1 1a		lda ($1a),y			lda 	(zlTemp1),y
.019327	71 1c		adc ($1c),y			adc 	(zlTemp1+2),y
.019329	7a		ply				ply
.01932a	b0 33		bcs $01935f			bcs 	_CSError					; check in range.
.01932c	c9 fe		cmp #$fe			cmp 	#maxString+1
.01932e	b0 2f		bcs $01935f			bcs 	_CSError
.019330	20 8c 97	jsr $01978c			jsr 	AllocateTempString 			; store the result
.019333	20 4a 93	jsr $01934a			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.019336	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.019338	85 1a		sta $1a				sta 	zLTemp1
.01933a	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.01933c	85 1b		sta $1b				sta 	zLTemp1+1
.01933e	20 4a 93	jsr $01934a			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.019341	a5 20		lda $20				lda 	zTempStr 					; point current to new string
.019343	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019345	a5 21		lda $21				lda 	zTempStr+1
.019347	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019349	60		rts				rts
.01934a					_CSCopyString:
.01934a	da		phx				phx
.01934b	5a		phy				phy
.01934c	a0 00		ldy #$00			ldy 	#0 							; get length
.01934e	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.019350	f0 0a		beq $01935c			beq 	_CSCSExit 					; if zero, exit
.019352	aa		tax				tax 								; put in X
.019353					_CSCSLoop:
.019353	c8		iny				iny 								; get next char
.019354	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.019356	20 b7 97	jsr $0197b7			jsr		WriteTempString 			; copy out
.019359	ca		dex				dex 								; do whole string
.01935a	d0 f7		bne $019353			bne 	_CSCSLoop
.01935c					_CSCSExit:
.01935c	7a		ply				ply
.01935d	fa		plx				plx
.01935e	60		rts				rts
.01935f					_CSError:
.01935f	20 57 85	jsr $018557			jsr ERR_Handler
>019362	53 74 72 69 6e 67 20 74			.text "String too long",0
>01936a	6f 6f 20 6c 6f 6e 67 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.019372					Unary_Sgn:
.019372	20 18 91	jsr $019118			jsr 	EvaluateNumberX 			; get value
.019375	20 4c 97	jsr $01974c			jsr 	CheckNextRParen 			; check right bracket.
.019378	20 96 93	jsr $019396			jsr 	GetSignCurrent 				; get sign.
.01937b	09 00		ora #$00			ora 	#0
.01937d	10 08		bpl $019387			bpl		UnarySetAInteger			; if 0,1 return that.
.01937f	80 00		bra $019381			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.019381					UnarySetAMinus1:
.019381	a9 ff		lda #$ff			lda 	#$FF
.019383	95 80		sta $80,x			sta 	XS_Mantissa,x
.019385	80 04		bra $01938b			bra 	UnarySetAFill
.019387					UnarySetAInteger:
.019387	95 80		sta $80,x			sta 	XS_Mantissa,x
.019389	a9 00		lda #$00			lda 	#0
.01938b					UnarySetAFill:
.01938b	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01938d	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01938f	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019391	a9 01		lda #$01			lda 	#1
.019393	95 85		sta $85,x			sta 	XS_Type,x
.019395	60		rts				rts
.019396					GetSignCurrent:
.019396	b5 85		lda $85,x			lda 	XS_Type,x 					; identify type.
.019398	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.019399	90 15		bcc $0193b0			bcc 	_GSCFloat
.01939b	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01939d	30 0e		bmi $0193ad			bmi 	_GSCMinus1
.01939f	15 80		ora $80,x			ora 	XS_Mantissa+0,x
.0193a1	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.0193a3	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.0193a5	d0 03		bne $0193aa			bne 	_GSCPlus1
.0193a7					_GSCZero:
.0193a7	a9 00		lda #$00			lda 	#0
.0193a9	60		rts				rts
.0193aa					_GSCPlus1:
.0193aa	a9 01		lda #$01			lda 	#$01
.0193ac	60		rts				rts
.0193ad					_GSCMinus1:
.0193ad	a9 ff		lda #$ff			lda 	#$FF
.0193af	60		rts				rts
.0193b0					_GSCFloat:
.0193b0	34 85		bit $85,x			bit 	XS_Type,x
.0193b2	70 f3		bvs $0193a7			bvs 	_GSCZero
.0193b4	30 f7		bmi $0193ad			bmi 	_GSCMinus1
.0193b6	80 f2		bra $0193aa			bra 	_GSCPlus1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.0193b8					Unary_Abs:
.0193b8	20 18 91	jsr $019118			jsr 	EvaluateNumberX 			; get value
.0193bb	20 4c 97	jsr $01974c			jsr 	CheckNextRParen 			; check right bracket.
.0193be	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.0193c0	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.0193c2	f0 07		beq $0193cb			beq 	_UAMinusFloat
.0193c4	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; check MSB
.0193c6	10 09		bpl $0193d1			bpl 	_UAExit
.0193c8	4c b2 9c	jmp $019cb2			jmp 	IntegerNegateAlways 		; negation
.0193cb					_UAMinusFloat:
.0193cb	b5 85		lda $85,x			lda 	XS_Type,x 					; clear the sign bit.
.0193cd	29 7f		and #$7f			and		#$7F
.0193cf	95 85		sta $85,x			sta 	XS_Type,x
.0193d1					_UAExit:
.0193d1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.0193d2					Unary_Peek:
.0193d2	a9 01		lda #$01			lda 	#1
.0193d4	80 06		bra $0193dc			bra 	UPMain
.0193d6					Unary_Deek:
.0193d6	a9 02		lda #$02			lda 	#2
.0193d8	80 02		bra $0193dc			bra 	UPMain
.0193da					Unary_Leek:
.0193da	a9 04		lda #$04			lda 	#4
.0193dc					UPMain:
.0193dc	48		pha				pha 								; set bytes to copy.
.0193dd	20 26 91	jsr $019126			jsr 	EvaluateIntegerX 			; numeric parameter
.0193e0	20 4c 97	jsr $01974c			jsr 	CheckNextRParen 			; right bracket.
.0193e3	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.0193e5	85 1a		sta $1a				sta 	zLTemp1
.0193e7	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0193e9	85 1b		sta $1b				sta 	zLTemp1+1
.0193eb	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0193ed	85 1c		sta $1c				sta 	zLTemp1+2
.0193ef	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.0193f1	85 1d		sta $1d				sta 	zLTemp1+3
.0193f3	a9 00		lda #$00			lda 	#0 							; clear target area
.0193f5	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0193f7	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0193f9	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0193fb	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0193fd	68		pla				pla 								; restore bytes to copy
.0193fe	da		phx				phx 								; save XY
.0193ff	5a		phy				phy
.019400	20 ce 96	jsr $0196ce			jsr 	MemRead 					; read the bytes in
.019403	7a		ply				ply 								; restore and exit
.019404	fa		plx				plx
.019405	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.019406					Unary_Mod:
.019406	20 2e 94	jsr $01942e			jsr 	_UMParameter 				; first parameter
.019409	20 54 97	jsr $019754			jsr 	CheckNextComma
.01940c	da		phx				phx 								; second parameter
.01940d	e8		inx				inx
.01940e	e8		inx				inx
.01940f	e8		inx				inx
.019410	e8		inx				inx
.019411	e8		inx				inx
.019412	e8		inx				inx
.019413	20 2e 94	jsr $01942e			jsr 	_UMParameter
.019416	fa		plx				plx
.019417	20 4c 97	jsr $01974c			jsr 	CheckNextRParen
.01941a	20 2b 9c	jsr $019c2b			jsr 	DivInteger32 				; divide
.01941d	a5 1a		lda $1a				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.01941f	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019421	a5 1b		lda $1b				lda 	zLTemp1+1
.019423	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019425	a5 1c		lda $1c				lda 	zLTemp1+2
.019427	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019429	a5 1d		lda $1d				lda 	zLTemp1+3
.01942b	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01942d	60		rts				rts
.01942e					_UMParameter:
.01942e	20 26 91	jsr $019126			jsr 	EvaluateIntegerX 			; get value
.019431	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; absolute value
.019433	10 03		bpl $019438			bpl 	_UMNotSigned
.019435	20 b2 9c	jsr $019cb2			jsr 	IntegerNegateAlways
.019438					_UMNotSigned:
.019438	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.019439					Unary_Usr:
.019439	20 18 91	jsr $019118			jsr 	EvaluateNumberX 			; numeric parameter
.01943c	20 4c 97	jsr $01974c			jsr 	CheckNextRParen 			; right bracket.
.01943f	da		phx				phx 								; save XY
.019440	5a		phy				phy
.019441	ea		nop				nop
.019442	22 0c 03 00	jsl $00030c			jsl 	UserVector
.019446	7a		ply				ply 								; and exit
.019447	fa		plx				plx
.019448	60		rts				rts
.019449					USRDefault:
.019449	20 57 85	jsr $018557			jsr ERR_Handler
>01944c	4e 6f 20 55 53 52 20 76			.text "No USR vector.",0
>019454	65 63 74 6f 72 2e 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.01945b					Unary_Val:
.01945b	20 2f 91	jsr $01912f			jsr 	EvaluateStringX 			; get string
.01945e	20 4c 97	jsr $01974c			jsr 	CheckNextRParen 			; check right bracket.
.019461	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.019463	85 1e		sta $1e				sta 	zGenPtr
.019465	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019467	85 1f		sta $1f				sta 	zGenPtr+1
.019469	5a		phy				phy
.01946a	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.01946c	b1 1e		lda ($1e),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.01946e	f0 54		beq $0194c4			beq 	_UVBadNumber
.019470	48		pha				pha 								; save length.
.019471	1a		inc a				inc 	a 							; one for the length, one for the terminator
.019472	1a		inc a				inc 	a
.019473	20 8c 97	jsr $01978c			jsr 	AllocateTempString
.019476	c8		iny				iny 								; move to the next.
.019477	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get character
.019479	49 2d		eor #$2d			eor 	#"-"						; zero if minus sign
.01947b	8d a0 03	sta $03a0			sta 	ValSign
.01947e	d0 04		bne $019484			bne 	_UVNotMinus
.019480	c8		iny				iny 								; skip over it.
.019481	68		pla				pla 								; decrement character count.
.019482	3a		dec a				dec 	a
.019483	48		pha				pha
.019484					_UVNotMinus:
.019484	68		pla				pla 								; this is the count.
.019485	48		pha		_UVCopy:pha									; copy into new temp string which is ASCIIZ
.019486	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.019488	c8		iny				iny
.019489	20 b7 97	jsr $0197b7			jsr 	WriteTempString
.01948c	68		pla				pla
.01948d	3a		dec a				dec 	a
.01948e	d0 f5		bne $019485			bne 	_UVCopy
.019490	20 b7 97	jsr $0197b7			jsr 	WriteTempString 			; make it ASCIIZ
.019493	18		clc				clc
.019494	a5 20		lda $20				lda 	zTempStr 					; tempstring +1 => genptr
.019496	69 01		adc #$01			adc 	#1
.019498	85 1e		sta $1e				sta 	zGenPtr
.01949a	a5 21		lda $21				lda 	zTempStr+1
.01949c	69 00		adc #$00			adc 	#0
.01949e	85 1f		sta $1f				sta 	zGenPtr+1
.0194a0	18		clc				clc
.0194a1	20 84 9d	jsr $019d84			jsr 	IntFromString 				; first bit.
.0194a4	b0 1e		bcs $0194c4			bcs 	_UVBadNumber
.0194a6	20 02 a3	jsr $01a302			jsr 	FPFromString				; try for a float part.
.0194a9	ad a0 03	lda $03a0			lda 	ValSign 					; was it negative
.0194ac	d0 10		bne $0194be			bne 	_UVNotNegative
.0194ae	b5 85		lda $85,x			lda 	XS_Type,x 					; check if integer
.0194b0	4a		lsr a				lsr 	a
.0194b1	b0 08		bcs $0194bb			bcs 	_UVInteger
.0194b3	b5 85		lda $85,x			lda 	XS_Type,x 					; set sign bit
.0194b5	09 80		ora #$80			ora 	#$80
.0194b7	95 85		sta $85,x			sta 	XS_Type,x
.0194b9	80 03		bra $0194be			bra 	_UVNotNegative
.0194bb					_UVInteger:
.0194bb	20 b2 9c	jsr $019cb2			jsr 	IntegerNegateAlways 		; sign it.
.0194be					_UVNotNegative:
.0194be	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; used everything
.0194c0	d0 02		bne $0194c4			bne 	_UVBadNumber
.0194c2	7a		ply				ply
.0194c3	60		rts				rts
.0194c4					_UVBadNumber:
.0194c4	4c 46 85	jmp $018546			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.0194c7					Unary_Str:
.0194c7	20 18 91	jsr $019118			jsr 	EvaluateNumberX 			; numeric parameter
.0194ca	20 4c 97	jsr $01974c			jsr 	CheckNextRParen 			; right bracket.
.0194cd	a9 00		lda #$00			lda 	#0 							; reset buffer index
.0194cf	8d 14 03	sta $0314			sta 	NumBufX
.0194d2	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.0194d4	4a		lsr a				lsr 	a
.0194d5	b0 05		bcs $0194dc			bcs 	_USInt 						; if msb set do as integer
.0194d7	20 47 a2	jsr $01a247			jsr 	FPToString 					; call fp to str otherwise
.0194da	80 03		bra $0194df			bra 	_USDuplicate
.0194dc	20 cf 9c	jsr $019ccf	_USInt:	jsr 	IntToString
.0194df					_USDuplicate:
.0194df	ad 14 03	lda $0314			lda 	NumBufX 					; chars in buffer
.0194e2	1a		inc a				inc 	a 							; one more for length
.0194e3	20 8c 97	jsr $01978c			jsr 	AllocateTempString 			; allocate space for it.
.0194e6	5a		phy				phy 								; save Y
.0194e7	a0 00		ldy #$00			ldy 	#0 							; start copying
.0194e9	b9 15 03	lda $0315,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.0194ec	20 b7 97	jsr $0197b7			jsr 	WriteTempString
.0194ef	c8		iny				iny
.0194f0	cc 14 03	cpy $0314			cpy 	NumBufX 					; done the lot
.0194f3	d0 f4		bne $0194e9			bne 	_USCopy
.0194f5	7a		ply				ply 								; restore Y
.0194f6	4c c1 96	jmp $0196c1			jmp 	UnaryReturnTempStr 			; return new temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.0194f9					Unary_Asc:
.0194f9	20 2f 91	jsr $01912f			jsr 	EvaluateStringX 			; string parameter
.0194fc	20 4c 97	jsr $01974c			jsr 	CheckNextRParen 			; right bracket.
.0194ff	5a		phy				phy 								; get the string length
.019500	a0 00		ldy #$00			ldy 	#0
.019502	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.019504	f0 07		beq $01950d			beq 	_UAIllegal 					; must be at least one character
.019506	c8		iny				iny
.019507	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; read it.
.019509	7a		ply				ply
.01950a	4c 87 93	jmp $019387			jmp 	UnarySetAInteger
.01950d					_UAIllegal:
.01950d	4c 46 85	jmp $018546			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.019510					Unary_Len:
.019510	20 2f 91	jsr $01912f			jsr 	EvaluateStringX 			; string parameter
.019513	20 4c 97	jsr $01974c			jsr 	CheckNextRParen 			; right bracket.
.019516	5a		phy				phy 								; get the string length
.019517	a0 00		ldy #$00			ldy 	#0
.019519	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.01951b	7a		ply				ply
.01951c	4c 87 93	jmp $019387			jmp 	UnarySetAInteger

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.01951f					Unary_Mid:
.01951f	20 2f 91	jsr $01912f			jsr 	EvaluateStringX 				; get string.
.019522	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.019524	48		pha				pha
.019525	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019527	48		pha				pha
.019528	20 54 97	jsr $019754			jsr 	CheckNextComma 					; skip comma
.01952b	20 b4 95	jsr $0195b4			jsr 	SLIByteParameter 				; get a byte parameter (start)
.01952e	48		pha				pha 									; and push it.
.01952f	20 54 97	jsr $019754			jsr 	CheckNextComma 					; skip comma
.019532	20 b4 95	jsr $0195b4			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.019535	48		pha				pha 									; and push it.
.019536	80 41		bra $019579			bra 	SLIProcess
.019538					Unary_Left:
.019538	20 2f 91	jsr $01912f			jsr 	EvaluateStringX 				; get string.
.01953b	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.01953d	48		pha				pha
.01953e	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019540	48		pha				pha
.019541	a9 01		lda #$01			lda 	#1 								; push start position (1)
.019543	48		pha				pha
.019544	20 54 97	jsr $019754			jsr 	CheckNextComma 					; skip comma
.019547	20 b4 95	jsr $0195b4			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.01954a	48		pha				pha 									; and push it.
.01954b	80 2c		bra $019579			bra 	SLIProcess
.01954d					Unary_Right:
.01954d	20 2f 91	jsr $01912f			jsr 	EvaluateStringX 				; get string.
.019550	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.019552	48		pha				pha
.019553	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019555	48		pha				pha
.019556	da		phx				phx 									; get the string length and push on stack.
.019557	a2 00		ldx #$00			ldx 	#0
.019559	a1 1e		lda ($1e,x)			lda		(zGenPtr,x)
.01955b	fa		plx				plx
.01955c	48		pha				pha
.01955d	20 54 97	jsr $019754			jsr 	CheckNextComma 					; skip comma
.019560	20 b4 95	jsr $0195b4			jsr 	SLIByteParameter 				; get a byte parameter.
.019563	8d 9e 03	sta $039e			sta 	SignCount 						; save in temporary.
.019566	68		pla				pla 									; restore string length.
.019567	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.019568	38		sec				sec
.019569	ed 9e 03	sbc $039e			sbc 	SignCount 						; subtract characters needed, gives start position.
.01956c	f0 02		beq $019570			beq 	_URStart 						; if <= 0 start from 1.
.01956e	10 02		bpl $019572			bpl 	_UROkay
.019570					_URStart:
.019570	a9 01		lda #$01			lda 	#1
.019572					_UROkay:
.019572	48		pha				pha 									; push start
.019573	ad 9e 03	lda $039e			lda 	SignCount 						; push count of characters
.019576	48		pha				pha
.019577	80 00		bra $019579			bra 	SLIProcess
.019579					SLIProcess:
.019579	20 4c 97	jsr $01974c			jsr 	CheckNextRParen 				; closing right bracket.
.01957c	68		pla				pla
.01957d	8d a2 03	sta $03a2			sta 	SliceCount 						; count in signcount
.019580	1a		inc a				inc 	a 								; allocate +1 for it.
.019581	20 8c 97	jsr $01978c			jsr 	AllocateTempString
.019584	68		pla				pla 									; pop start number off stack.
.019585	f0 3b		beq $0195c2			beq 	SLIError 						; exit if start = 0
.019587	8d a1 03	sta $03a1			sta 	SliceStart
.01958a	68		pla				pla  									; pop string address.
.01958b	85 1f		sta $1f				sta 	zGenPtr+1
.01958d	68		pla				pla
.01958e	85 1e		sta $1e				sta 	zGenPtr
.019590	da		phx				phx
.019591	5a		phy				phy
.019592	a2 00		ldx #$00			ldx 	#0 								; point to string length.
.019594	ac a1 03	ldy $03a1			ldy 	SliceStart 						; start of the string (+1 for count)
.019597					_SLICopy:
.019597	ad a2 03	lda $03a2			lda 	SliceCount 						; done count characters
.01959a	f0 12		beq $0195ae			beq 	_SLIExit
.01959c	ce a2 03	dec $03a2			dec 	SliceCount
.01959f	98		tya				tya 									; index of character
.0195a0	c1 1e		cmp ($1e,x)			cmp 	(zGenPtr,x)						; compare against length
.0195a2	f0 02		beq $0195a6			beq 	_SLIOk 							; if equal, okay.
.0195a4	b0 08		bcs $0195ae			bcs 	_SLIExit 						; if past end, then exit.
.0195a6	b1 1e		lda ($1e),y	_SLIOk:	lda 	(zGenPtr),y 					; copy one character
.0195a8	c8		iny				iny
.0195a9	20 b7 97	jsr $0197b7			jsr 	WriteTempString
.0195ac	80 e9		bra $019597			bra 	_SLICopy 						; go round till copied characters
.0195ae					_SLIExit:
.0195ae	7a		ply				ply 									; restore YX
.0195af	fa		plx				plx
.0195b0	4c c1 96	jmp $0196c1			jmp 	UnaryReturnTempStr 				; return new temporary string.
.0195b3	ea		nop				nop
.0195b4					SLIByteParameter:
.0195b4	20 26 91	jsr $019126			jsr 	EvaluateIntegerX 				; get integer
.0195b7	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.0195b9	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.0195bb	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.0195bd	d0 03		bne $0195c2			bne 	SLIError
.0195bf	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0195c1	60		rts				rts
.0195c2					SLIError:
.0195c2	4c 46 85	jmp $018546			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.0195c5					Unary_Hex:
.0195c5	20 26 91	jsr $019126			jsr 	EvaluateIntegerX 			; numeric parameter
.0195c8	20 4c 97	jsr $01974c			jsr 	CheckNextRParen 			; right bracket.
.0195cb	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.0195cd	20 8c 97	jsr $01978c			jsr 	AllocateTempString			; allocate string space
.0195d0	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.0195d2	20 f6 95	jsr $0195f6			jsr 	_UHConvert
.0195d5	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0195d7	20 f6 95	jsr $0195f6			jsr 	_UHConvert
.0195da	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0195dc	20 f6 95	jsr $0195f6			jsr 	_UHConvert
.0195df	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0195e1	20 f6 95	jsr $0195f6			jsr 	_UHConvert
.0195e4	5a		phy				phy 								; get length of new string
.0195e5	a0 00		ldy #$00			ldy 	#0
.0195e7	b1 20		lda ($20),y			lda 	(zTempStr),y
.0195e9	7a		ply				ply
.0195ea	c9 00		cmp #$00			cmp 	#0
.0195ec	d0 05		bne $0195f3			bne 	_UHExit 					; if it was non zero okay
.0195ee	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.0195f0	20 b7 97	jsr $0197b7			jsr 	WriteTempString
.0195f3					_UHExit:
.0195f3	4c c1 96	jmp $0196c1			jmp 	UnaryReturnTempStr 			; return new temporary string.
.0195f6					_UHConvert:
.0195f6	48		pha				pha
.0195f7	4a		lsr a				lsr 	a 							; do MSB
.0195f8	4a		lsr a				lsr 	a
.0195f9	4a		lsr a				lsr 	a
.0195fa	4a		lsr a				lsr 	a
.0195fb	20 ff 95	jsr $0195ff			jsr 	_UHNibble
.0195fe	68		pla				pla 								; do LSB
.0195ff					_UHNibble:
.0195ff	29 0f		and #$0f			and 	#15 						; get nibble
.019601	d0 0c		bne $01960f			bne 	_UHNonZero
.019603	5a		phy				phy									; get the length
.019604	a0 00		ldy #$00			ldy 	#0
.019606	b1 20		lda ($20),y			lda 	(zTempStr),y
.019608	7a		ply				ply
.019609	c9 00		cmp #$00			cmp 	#0 							; suppress leading zeros.
.01960b	f0 0d		beq $01961a			beq 	_UHExit2
.01960d	a9 00		lda #$00			lda 	#0
.01960f					_UHNonZero:
.01960f	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.019611	90 02		bcc $019615			bcc 	_UHDigit
.019613	69 06		adc #$06			adc 	#7-1
.019615					_UHDigit:
.019615	69 30		adc #$30			adc 	#48
.019617	20 b7 97	jsr $0197b7			jsr 	WriteTempString				; output.
.01961a					_UHExit2:
.01961a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.01961b					Unary_Dec:
.01961b	20 2f 91	jsr $01912f			jsr 	EvaluateStringX 			; string parameter
.01961e	20 4c 97	jsr $01974c			jsr 	CheckNextRParen 			; right bracket.
.019621	5a		phy				phy
.019622	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.019624	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.019626	f0 41		beq $019669			beq 	_UDFail 					; must fail if zero.
.019628	8d 9e 03	sta $039e			sta 	SignCount 					; use SignCount as a counter
.01962b	a9 00		lda #$00			lda 	#0 							; set result to zero integer.
.01962d	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01962f	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019631	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019633	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019635	a9 01		lda #$01			lda 	#1
.019637	95 85		sta $85,x			sta 	XS_Type,x
.019639					_UDConvertLoop:
.019639	5a		phy				phy 								; shift mantissa left 4
.01963a	a0 04		ldy #$04			ldy 	#4
.01963c					_UDShift:
.01963c	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.01963e	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.019640	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.019642	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.019644	88		dey				dey
.019645	d0 f5		bne $01963c			bne 	_UDShift
.019647	7a		ply				ply
.019648	c8		iny				iny 								; next character
.019649	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; fetch it.
.01964b	20 6c 96	jsr $01966c			jsr 	ConvertUpper 				; convert to U/C
.01964e	c9 30		cmp #$30			cmp 	#"0"
.019650	90 17		bcc $019669			bcc 	_UDFail
.019652	c9 3a		cmp #$3a			cmp 	#"9"+1
.019654	90 06		bcc $01965c			bcc 	_UDOkay
.019656	e9 37		sbc #$37			sbc 	#7+"0" 						; alpha fudge
.019658	c9 10		cmp #$10			cmp 	#16
.01965a	b0 0d		bcs $019669			bcs 	_UDFail
.01965c					_UDOkay:
.01965c	29 0f		and #$0f			and 	#15 						; nibble only
.01965e	15 80		ora $80,x			ora 	XS_Mantissa+0,x
.019660	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019662	ce 9e 03	dec $039e			dec 	SignCount 					; do it for each character
.019665	d0 d2		bne $019639			bne 	_UDConvertLoop
.019667	7a		ply				ply
.019668	60		rts				rts
.019669					_UDFail:
.019669	4c 46 85	jmp $018546			jmp 	BadParamError
.01966c					ConvertUpper:
.01966c	c9 61		cmp #$61			cmp 	#"a"
.01966e	90 07		bcc $019677			bcc 	_CUExit
.019670	c9 7b		cmp #$7b			cmp 	#"z"+1
.019672	b0 03		bcs $019677			bcs 	_CUExit
.019674	38		sec				sec
.019675	e9 20		sbc #$20			sbc 	#32
.019677	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.019678					Unary_Chr:
.019678	20 26 91	jsr $019126			jsr 	EvaluateIntegerX			; numeric parameter
.01967b	20 4c 97	jsr $01974c			jsr 	CheckNextRParen 			; right bracket.
.01967e	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.019680	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019682	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019684	d0 0d		bne $019693			bne 	_UCChar
.019686	a9 01		lda #$01			lda 	#1 							; one character string
.019688	20 8c 97	jsr $01978c			jsr 	AllocateTempString
.01968b	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.01968d	20 b7 97	jsr $0197b7			jsr 	WriteTempString
.019690	4c c1 96	jmp $0196c1			jmp 	UnaryReturnTempStr
.019693					_UCChar:
.019693	4c 46 85	jmp $018546			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.019696					Unary_Spc:
.019696	20 26 91	jsr $019126			jsr 	EvaluateIntegerX 			; numeric parameter
.019699	20 4c 97	jsr $01974c			jsr 	CheckNextRParen 			; right bracket.
.01969c	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.01969e	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.0196a0	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.0196a2	d0 1a		bne $0196be			bne 	_USSize
.0196a4	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0196a6	c9 fe		cmp #$fe			cmp 	#maxString+1
.0196a8	b0 14		bcs $0196be			bcs 	_USSize
.0196aa	48		pha				pha 								; save length
.0196ab	1a		inc a				inc 	a 							; allocate one more.
.0196ac	20 8c 97	jsr $01978c			jsr 	AllocateTempString
.0196af	68		pla				pla 								; get length
.0196b0	f0 0f		beq $0196c1			beq 	UnaryReturnTempStr 			; return the current temp string
.0196b2					_USLoop:
.0196b2	48		pha				pha
.0196b3	a9 20		lda #$20			lda 	#" "
.0196b5	20 b7 97	jsr $0197b7			jsr 	WriteTempString
.0196b8	68		pla				pla
.0196b9	3a		dec a				dec 	a
.0196ba	d0 f6		bne $0196b2			bne 	_USLoop
.0196bc	80 03		bra $0196c1			bra 	UnaryReturnTempStr
.0196be					_USSize:
.0196be	4c 46 85	jmp $018546			jmp 	BadParamError
.0196c1					UnaryReturnTempStr:
.0196c1	a5 20		lda $20				lda 	zTempStr 					; copy temp string addr -> mantissa
.0196c3	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0196c5	a5 21		lda $21				lda 	zTempStr+1
.0196c7	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0196c9	a9 02		lda #$02			lda 	#2 							; set type to string
.0196cb	95 85		sta $85,x			sta 	XS_Type,x
.0196cd	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/65816.asm

.0196ce					MemRead:
.0196ce	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.0196d1	a0 00		ldy #$00			ldy 	#0 							; start from here
.0196d3	b7 1a		lda [$1a],y	_MLoop1:lda 	[zlTemp1],y 				; read the long address
.0196d5	95 80		sta $80,x			sta 	XS_Mantissa,x 				; copy into mantissa
.0196d7	c8		iny				iny 								; next to copy
.0196d8	e8		inx				inx
.0196d9	cc 9e 03	cpy $039e			cpy 	SignCount 					; do required # of bytes.
.0196dc	d0 f5		bne $0196d3			bne 	_MLoop1
.0196de	60		rts				rts
.0196df					MemWrite:
.0196df	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.0196e2	a0 00		ldy #$00			ldy 	#0 							; start from here
.0196e4	b5 80		lda $80,x	_MLoop1:lda 	XS_Mantissa,x 				; read mantisssa
.0196e6	97 1a		sta [$1a],y			sta 	[zlTemp1],y 				; write it out
.0196e8	c8		iny				iny 								; next to copy
.0196e9	e8		inx				inx
.0196ea	cc 9e 03	cpy $039e			cpy 	SignCount 					; do required # of bytes.
.0196ed	d0 f5		bne $0196e4			bne 	_MLoop1
.0196ef	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/programend.asm

.0196f0					UpdateProgramEnd:
.0196f0	a9 00		lda #$00			lda 	#BasicProgram & $FF
.0196f2	85 16		sta $16				sta 	zCodePtr+0
.0196f4	a9 10		lda #$10			lda 	#BasicProgram >> 8
.0196f6	85 17		sta $17				sta 	zCodePtr+1
.0196f8	a9 00		lda #$00			lda 	#0
.0196fa	85 18		sta $18				sta 	zCodePtr+2
.0196fc	85 19		sta $19				sta 	zCodePtr+3
.0196fe	a0 03		ldy #$03			ldy 	#3
.019700					_UPDLoop:
.019700	a0 00		ldy #$00			ldy 	#0
.019702	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019704	c9 00		cmp #$00			cmp 	#0 							; end if offset is zero.
.019706	f0 0f		beq $019717			beq 	_UPDFoundEnd
.019708	a0 00		ldy #$00			ldy 	#0 							; point to offset
.01970a	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.01970c	18		clc				clc
.01970d	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.01970f	85 16		sta $16				sta 	zCodePtr
.019711	90 02		bcc $019715			bcc 	_SNLNoCarry
.019713	e6 17		inc $17				inc 	zCodePtr+1
.019715					_SNLNoCarry:
.019715	80 e9		bra $019700			bra 	_UPDLoop
.019717					_UPDFoundEnd:
.019717	18		clc				clc 								; end of program 2 on.
.019718	a5 16		lda $16				lda 	zCodePtr
.01971a	69 02		adc #$02			adc 	#2
.01971c	8d 04 03	sta $0304			sta 	endOfProgram
.01971f	a5 17		lda $17				lda 	zCodePtr+1
.019721	69 00		adc #$00			adc 	#0
.019723	8d 05 03	sta $0305			sta 	endOfProgram+1
.019726	a5 18		lda $18				lda 	zCodePtr+2
.019728	69 00		adc #$00			adc		#0
.01972a	8d 06 03	sta $0306			sta 	endOfProgram+2
.01972d	a5 19		lda $19				lda 	zCodePtr+3
.01972f	69 00		adc #$00			adc 	#0
.019731	8d 07 03	sta $0307			sta 	endOfProgram+3
.019734	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.019735					CheckNextToken:
.019735	d7 16		cmp [$16],y			cmp 	[zCodePtr],y
.019737	d0 02		bne $01973b			bne 	CTFail 						; no, then fail
.019739	c8		iny				iny
.01973a	60		rts				rts
.01973b					CTFail:
.01973b	20 57 85	jsr $018557			jsr ERR_Handler
>01973e	4d 69 73 73 69 6e 67 20			.text "Missing token",0
>019746	74 6f 6b 65 6e 00
.01974c					CheckNextRParen:
.01974c	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01974e	c9 be		cmp #$be			cmp 	#token_rparen
.019750	d0 e9		bne $01973b			bne 	CTFail
.019752	c8		iny				iny
.019753	60		rts				rts
.019754					CheckNextComma:
.019754	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019756	c9 bf		cmp #$bf			cmp 	#token_comma
.019758	d0 e1		bne $01973b			bne 	CTFail
.01975a	c8		iny				iny
.01975b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/concrete.asm

.01975c					StringConcrete:
.01975c	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; save source to zTemp1
.01975e	85 10		sta $10				sta 	zTemp1
.019760	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019762	85 11		sta $11				sta 	zTemp1+1
.019764	a0 00		ldy #$00			ldy 	#0 							; subtract the length+1 (clc) of the string.
.019766	18		clc				clc 								; from the string pointer
.019767	ad 00 03	lda $0300			lda 	StringPtr 					; and put in zTemp2 as well
.01976a	f1 10		sbc ($10),y			sbc 	(zTemp1),y
.01976c	8d 00 03	sta $0300			sta 	StringPtr
.01976f	85 12		sta $12				sta 	zTemp2
.019771	ad 01 03	lda $0301			lda 	StringPtr+1
.019774	e9 00		sbc #$00			sbc 	#0
.019776	8d 01 03	sta $0301			sta 	StringPtr+1
.019779	85 13		sta $13				sta 	zTemp2+1
.01977b	b1 10		lda ($10),y			lda 	(zTemp1),y 					; length add one for count
.01977d	1a		inc a				inc 	a
.01977e	aa		tax				tax
.01977f	b1 10		lda ($10),y	_SCCopy:lda 	(zTemp1),y 					; copy whole thing including length
.019781	91 12		sta ($12),y			sta 	(zTemp2),y
.019783	c8		iny				iny
.019784	ca		dex				dex
.019785	d0 f8		bne $01977f			bne 	_SCCopy
.019787	a5 13		lda $13				lda 	zTemp2+1 					; return concrete string in AX
.019789	a6 12		ldx $12				ldx 	zTemp2
.01978b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.01978c					AllocateTempString:
.01978c	48		pha				pha 								; save required count.
.01978d	a5 21		lda $21				lda 	zTempStr+1 					; check if initialised yet ?
.01978f	d0 0b		bne $01979c			bne 	_ATSInitialised
.019791	ad 00 03	lda $0300			lda 	StringPtr 					; set temporary string ptr 1 page below available
.019794	85 20		sta $20				sta 	zTempStr					; space, this is for strings to be concreted.
.019796	ad 01 03	lda $0301			lda 	StringPtr+1
.019799	3a		dec a				dec 	a
.01979a	85 21		sta $21				sta 	zTempStr+1
.01979c					_ATSInitialised:
.01979c	68		pla				pla 								; get required count back.
.01979d	49 ff		eor #$ff			eor 	#$FF 						; negate 2's complement.
.01979f	1a		inc a				inc 	a
.0197a0	18		clc				clc
.0197a1	65 20		adc $20				adc 	zTempStr 					; "add" to the temp string pointer
.0197a3	85 20		sta $20				sta 	zTempStr
.0197a5	a9 ff		lda #$ff			lda 	#$FF
.0197a7	65 21		adc $21				adc 	zTempStr+1
.0197a9	85 21		sta $21				sta 	zTempStr+1
.0197ab	a9 00		lda #$00			lda 	#0 							; clear temp string.
.0197ad	5a		phy				phy
.0197ae	a8		tay				tay
.0197af	91 20		sta ($20),y			sta 	(zTempStr),y
.0197b1	7a		ply				ply
.0197b2	1a		inc a				inc 	a 							; reset the write index.
.0197b3	8d 9f 03	sta $039f			sta 	TempStringWriteIndex
.0197b6	60		rts				rts
.0197b7					WriteTempString:
.0197b7	5a		phy				phy 								; save Y
.0197b8	ac 9f 03	ldy $039f			ldy 	TempStringWriteIndex	 	; write position.
.0197bb	91 20		sta ($20),y			sta 	(zTempStr),y 				; write character out.
.0197bd	ee 9f 03	inc $039f			inc 	TempStringWriteIndex 		; increment the write position.
.0197c0	98		tya				tya 								; unchanged Y is now length
.0197c1	a0 00		ldy #$00			ldy 	#0
.0197c3	91 20		sta ($20),y			sta 	(zTempStr),y
.0197c5	7a		ply				ply 								; restore Y and exit
.0197c6	60		rts				rts
.0197c7					CreateTempStringCopy:
.0197c7	da		phx				phx 								; save X
.0197c8	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0197ca	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.0197cb	20 8c 97	jsr $01978c			jsr 	AllocateTempString 			; allocate memory for temporary string.
.0197ce	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0197d0	c8		iny				iny
.0197d1	3a		dec a				dec 	a 							; make the actual length in charactes
.0197d2	3a		dec a				dec 	a
.0197d3	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.0197d5	81 20		sta ($20,x)			sta 	(zTempStr,x)
.0197d7	85 1a		sta $1a				sta 	zLTemp1 					; that's used as a count.
.0197d9	09 00		ora #$00			ora 	#0 							; if zero already, exit
.0197db	f0 0e		beq $0197eb			beq 	_CTSCExit
.0197dd					_CTSCLoop:
.0197dd	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0197df	c8		iny				iny
.0197e0	5a		phy				phy 								; save in Y
.0197e1	e8		inx				inx 								; bump index
.0197e2	da		phx				phx 								; index into Y
.0197e3	7a		ply				ply
.0197e4	91 20		sta ($20),y			sta 	(zTempStr),y 				; save at index
.0197e6	7a		ply				ply 								; restore Y
.0197e7	c6 1a		dec $1a				dec 	zLTemp1 					; do for each character
.0197e9	d0 f2		bne $0197dd			bne 	_CTSCLoop
.0197eb					_CTSCExit:
.0197eb	fa		plx				plx 								; restore X
.0197ec	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/variables.asm

.0197ed					VariableFind:
.0197ed	20 58 98	jsr $019858			jsr 	VariableExtract 		; find out all about it ....
.0197f0	20 f1 9a	jsr $019af1			jsr 	VariableLocate 			; does it already exist ?
.0197f3	b0 03		bcs $0197f8			bcs 	_VFExists 				; if so, use that.
.0197f5	20 e4 98	jsr $0198e4			jsr 	VariableCreate 			; otherwise create it.
.0197f8					_VFExists:
.0197f8	a5 24		lda $24				lda 	zVarType 				; is it still an array ?
.0197fa	29 01		and #$01			and 	#1
.0197fc	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.0197fe	d0 28		bne $019828			bne 	_VFSingleElement
.019800					_VFNextIndex:
.019800	a5 22		lda $22				lda 	zVarDataPtr 			; push the data ptr and type on the stack.
.019802	48		pha				pha
.019803	a5 23		lda $23				lda 	zVarDataPtr+1
.019805	48		pha				pha
.019806	a5 24		lda $24				lda 	zVarType
.019808	48		pha				pha
.019809	20 26 91	jsr $019126			jsr 	EvaluateIntegerX 		; calculate the index.
.01980c	68		pla				pla 							; restore and index.
.01980d	85 24		sta $24				sta 	zVarType
.01980f	68		pla				pla
.019810	85 23		sta $23				sta 	zVarDataPtr+1
.019812	68		pla				pla
.019813	85 22		sta $22				sta 	zVarDataPtr
.019815	20 6f 99	jsr $01996f			jsr 	ArrayIndexFollow 		; do the index.
.019818	a5 24		lda $24				lda 	zVarType 				; is it still an array ??
.01981a	29 01		and #$01			and 	#1
.01981c	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.01981e	d0 05		bne $019825			bne 	_VFArrayDone 			; if so then exit.
.019820	20 54 97	jsr $019754			jsr 	CheckNextComma 			; comma should follow
.019823	80 db		bra $019800			bra 	_VFNextIndex
.019825					_VFArrayDone:
.019825	20 4c 97	jsr $01974c			jsr 	CheckNextRParen 		; check closing right bracket.
.019828					_VFSingleElement:
.019828	60		rts				rts
.019829					VariableClear:
.019829	48		pha				pha 							; save registers
.01982a	da		phx				phx
.01982b	a2 00		ldx #$00			ldx 	#0 						; clear out the hash table.
.01982d	8a		txa				txa
.01982e	9d 35 03	sta $0335,x	_VCLoop:sta 	HashTableBase,x
.019831	e8		inx				inx
.019832	e0 60		cpx #$60			cpx 	#HashTableEnd-HashTableBase
.019834	d0 f8		bne $01982e			bne 	_VCLoop
.019836	a9 00		lda #$00			lda 	#VariableMemory & $FF
.019838	8d 02 03	sta $0302			sta 	VarMemPtr
.01983b	a9 30		lda #$30			lda 	#VariableMemory >> 8
.01983d	8d 03 03	sta $0303			sta 	VarMemPtr+1
.019840	fa		plx				plx 							; restore registers
.019841	68		pla				pla
.019842	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/extract.asm

.019843					VariableNameError:
.019843	20 57 85	jsr $018557			jsr ERR_Handler
>019846	42 61 64 20 56 61 72 69			.text "Bad Variable Name",0
>01984e	61 62 6c 65 20 4e 61 6d 65 00
.019858					VariableExtract:
.019858	da		phx				phx 							; save X.
.019859	a9 ba		lda #$ba			lda 	#token_hashlParen  		; set the type to #( e.g. real array.
.01985b	8d 95 03	sta $0395			sta 	Var_Type
.01985e	8d 96 03	sta $0396			sta 	Var_Hash 				; we initialise the hash with this. It doesn't matter
.019861	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019863	c9 00		cmp #$00			cmp 	#0 						; first one must be A-Z
.019865	f0 dc		beq $019843			beq 	VariableNameError
.019867	c9 1b		cmp #$1b			cmp 	#26+1
.019869	b0 d8		bcs $019843			bcs 	VariableNameError
.01986b	a2 ff		ldx #$ff			ldx 	#255 					; now copy it into the variable buffer.
.01986d					_VECopyBuffer:
.01986d	e8		inx				inx
.01986e	e0 1f		cpx #$1f			cpx 	#31 					; too long
.019870	f0 d1		beq $019843			beq 	VariableNameError
.019872	9d 15 03	sta $0315,x			sta 	Var_Buffer,x 			; save character
.019875	18		clc				clc  							; update the hash value for it.
.019876	6d 96 03	adc $0396			adc 	Var_Hash
.019879	8d 96 03	sta $0396			sta 	Var_Hash
.01987c	c8		iny				iny
.01987d	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01987f	c9 00		cmp #$00			cmp 	#0 						; zero or token, end of variable
.019881	f0 0e		beq $019891			beq 	_VECopyEnd
.019883	30 0c		bmi $019891			bmi 	_VECopyEnd
.019885	c9 1b		cmp #$1b			cmp 	#26+1 					; A-Z continue copying
.019887	90 e4		bcc $01986d			bcc 	_VECopyBuffer
.019889	c9 30		cmp #$30			cmp 	#"0" 					; 0-9 copy as well.
.01988b	90 04		bcc $019891			bcc 	_VECopyEnd
.01988d	c9 3a		cmp #$3a			cmp 	#"9"+1
.01988f	90 dc		bcc $01986d			bcc 	_VECopyBuffer
.019891					_VECopyEnd:
.019891	c8		iny				iny
.019892	c9 b7		cmp #$b7			cmp 	#token_Dollar 			; first type token.
.019894	90 04		bcc $01989a			bcc 	_VEDefaultRequired
.019896	c9 bd		cmp #$bd			cmp 	#token_PercentLParen+1	; last type token.
.019898	90 0b		bcc $0198a5			bcc 	_VEHaveType
.01989a					_VEDefaultRequired:
.01989a	c9 bd		cmp #$bd			cmp 	#token_LParen 			; if it ends in ( then use the real array
.01989c	f0 04		beq $0198a2			beq 	_VESetType 				; default set above.
.01989e	ce 95 03	dec $0395			dec 	Var_Type 				; this changes that default to the variable default
.0198a1	88		dey				dey
.0198a2					_VESetType:
.0198a2	ad 95 03	lda $0395			lda 	Var_Type 				; get type ....
.0198a5					_VEHaveType:
.0198a5	8d 95 03	sta $0395			sta 	Var_Type 				; save as type.
.0198a8	bd 15 03	lda $0315,x			lda 	Var_Buffer,x 			; set bit 7 of name, marks the end.
.0198ab	09 80		ora #$80			ora 	#$80
.0198ad	9d 15 03	sta $0315,x			sta 	Var_Buffer,x
.0198b0	e8		inx				inx 							; offset 3 => length 4.
.0198b1	8e 97 03	stx $0397			stx 	Var_Length 				; save length of variable name.
.0198b4	ad 95 03	lda $0395			lda 	Var_Type 				; get offset of var type from first type token
.0198b7	38		sec				sec
.0198b8	e9 b7		sbc #$b7			sbc 	#token_Dollar
.0198ba	0a		asl a				asl 	a 						; multiply by 16. This requires HashTableSize
.0198bb	0a		asl a				asl 	a 						; in data.asm to be 8 (8 sets of links,2 bytes each)
.0198bc	0a		asl a				asl 	a
.0198bd	0a		asl a				asl 	a
.0198be	8d 98 03	sta $0398			sta 	Var_HashAddress
.0198c1	ad 96 03	lda $0396			lda 	Var_Hash 				; get the hash
.0198c4	29 07		and #$07			and 	#(HashTableSize-1) 		; force into range 0-tableSize-1
.0198c6	0a		asl a				asl 	a 						; double it (2 bytes per entry) & clears carry
.0198c7	6d 98 03	adc $0398			adc 	Var_HashAddress 		; add table offset.
.0198ca	69 35		adc #$35			adc 	#HashTableBase & $FF 	; now the low byte of the actual table address
.0198cc	8d 98 03	sta $0398			sta 	Var_HashAddress
.0198cf	a2 05		ldx #$05			ldx 	#5 						; hash is 5 bytes (real)
.0198d1	ad 95 03	lda $0395			lda 	Var_Type
.0198d4	c9 b9		cmp #$b9			cmp 	#token_Hash
.0198d6	f0 07		beq $0198df			beq 	_VEHaveSize
.0198d8	ca		dex				dex
.0198d9	c9 bb		cmp #$bb			cmp 	#token_Percent 			; percent is 4 bytes (integer)
.0198db	f0 02		beq $0198df			beq 	_VEHaveSize
.0198dd	a2 02		ldx #$02			ldx 	#2 						; everything else is two.
.0198df					_VEHaveSize:
.0198df	8e 99 03	stx $0399			stx 	Var_DataSize
.0198e2	fa		plx				plx
.0198e3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varcreate.asm

.0198e4					VariableCreate:
.0198e4	da		phx				phx
.0198e5	5a		phy				phy
.0198e6	ad 02 03	lda $0302			lda 	VarMemPtr 					; get address of next free into zTemp1
.0198e9	85 10		sta $10				sta 	zTemp1
.0198eb	ad 03 03	lda $0303			lda 	VarMemPtr+1
.0198ee	85 11		sta $11				sta 	zTemp1+1
.0198f0	ad 99 03	lda $0399			lda 	Var_DataSize 				; bytes for the data bit
.0198f3	18		clc				clc
.0198f4	6d 97 03	adc $0397			adc 	Var_Length 					; add the length of the name
.0198f7	69 03		adc #$03			adc 	#3 							; 3 for the link and the hash.
.0198f9	6d 02 03	adc $0302			adc 	VarMemPtr 					; add to variable memory pointer
.0198fc	8d 02 03	sta $0302			sta 	VarMemPtr
.0198ff	90 03		bcc $019904			bcc 	_VCNoCarry
.019901	ee 03 03	inc $0303			inc 	VarMemPtr+1
.019904					_VCNoCarry:
.019904	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.019907	85 12		sta $12				sta 	zTemp2
.019909	a9 03		lda #$03			lda 	#HashTableBase >> 8
.01990b	85 13		sta $13				sta 	zTemp2+1
.01990d	a0 00		ldy #$00			ldy 	#0 							; put current hash link in position.
.01990f	b1 12		lda ($12),y			lda 	(zTemp2),y
.019911	91 10		sta ($10),y			sta 	(zTemp1),y
.019913	c8		iny				iny
.019914	b1 12		lda ($12),y			lda 	(zTemp2),y
.019916	91 10		sta ($10),y			sta 	(zTemp1),y
.019918	c8		iny				iny
.019919	ad 96 03	lda $0396			lda 	Var_Hash 					; write the hash out.
.01991c	91 10		sta ($10),y			sta 	(zTemp1),y
.01991e	c8		iny				iny
.01991f	a2 00		ldx #$00			ldx 	#0 							; copy the name out.
.019921					_VCCopyName:
.019921	bd 15 03	lda $0315,x			lda 	Var_Buffer,x
.019924	91 10		sta ($10),y			sta 	(zTemp1),y
.019926	e8		inx				inx
.019927	c8		iny				iny
.019928	ec 97 03	cpx $0397			cpx 	Var_Length
.01992b	d0 f4		bne $019921			bne 	_VCCopyName
.01992d	5a		phy				phy 								; save the data offset.
.01992e	ae 99 03	ldx $0399			ldx 	Var_DataSize 				; and write the data out.
.019931	a9 00		lda #$00			lda 	#0 							; which is all zeroes.
.019933					_VCClearData:
.019933	91 10		sta ($10),y			sta 	(zTemp1),y
.019935	c8		iny				iny
.019936	ca		dex				dex
.019937	d0 fa		bne $019933			bne 	_VCClearData
.019939	68		pla				pla 								; offset to the data
.01993a	18		clc				clc
.01993b	65 10		adc $10				adc 	zTemp1 						; add to start and save as data pointer.
.01993d	85 22		sta $22				sta 	zVarDataPtr
.01993f	a5 11		lda $11				lda 	zTemp1+1
.019941	69 00		adc #$00			adc 	#0
.019943	85 23		sta $23				sta 	zVarDataPtr+1
.019945	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.019948	85 24		sta $24				sta 	zVarType
.01994a	a5 10		lda $10				lda 	zTemp1 						; fix hash link to point to new record
.01994c	a0 00		ldy #$00			ldy 	#0
.01994e	91 12		sta ($12),y			sta 	(zTemp2),y
.019950	c8		iny				iny
.019951	a5 11		lda $11				lda 	zTemp1+1
.019953	91 12		sta ($12),y			sta 	(zTemp2),y
.019955	ad 95 03	lda $0395			lda 	Var_Type 					; array ? if so create the empty one.
.019958	29 01		and #$01			and 	#1
.01995a	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.01995c	d0 0e		bne $01996c			bne 	_VCNotArray
.01995e	a2 00		ldx #$00			ldx 	#0 							; call recursive array creator
.019960	20 06 9a	jsr $019a06			jsr 	ArrayCreate
.019963	5a		phy				phy 								; save YA at zVarDataPtr
.019964	a0 00		ldy #$00			ldy 	#0
.019966	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019968	c8		iny				iny
.019969	68		pla				pla
.01996a	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.01996c					_VCNotArray:
.01996c	7a		ply				ply
.01996d	fa		plx				plx
.01996e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arrayidx.asm

.01996f					ArrayIndexFollow:
.01996f	5a		phy				phy
.019970	a0 00		ldy #$00			ldy 	#0 							; make zVarDataPtr point to the array.
.019972	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; e.g. it points to itself.
.019974	48		pha				pha
.019975	c8		iny				iny
.019976	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019978	85 23		sta $23				sta 	zVarDataPtr+1
.01997a	68		pla				pla
.01997b	85 22		sta $22				sta 	zVarDataPtr
.01997d	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; MSB of 16 bit integer and bytes 2&3
.01997f	29 80		and #$80			and 	#$80 						; must be zero.
.019981	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019983	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019985	d0 59		bne $0199e0			bne 	_AIFError
.019987	a0 00		ldy #$00			ldy 	#0 							; calculate size - current - 1
.019989	18		clc				clc
.01998a	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.01998c	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.01998e	c8		iny				iny
.01998f	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019991	08		php				php 								; clear bit 7 retaining borrow.
.019992	29 7f		and #$7f			and 	#$7F
.019994	28		plp				plp
.019995	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.019997	90 47		bcc $0199e0			bcc 	_AIFError 					; eror if size-current < 0
.019999	b5 80		lda $80,x			lda  	XS_Mantissa+0,x 			; copy and double the index
.01999b	0a		asl a				asl 	a 							; (e.g. index * 2)
.01999c	85 10		sta $10				sta 	zTemp1
.01999e	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0199a0	2a		rol a				rol 	a
.0199a1	85 11		sta $11				sta 	zTemp1+1
.0199a3	a0 01		ldy #$01			ldy 	#1 							; is this a data entry.
.0199a5	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; if so, then type is unchanged, offset set
.0199a7	30 1d		bmi $0199c6			bmi 	_AIFCalculate
.0199a9	c6 24		dec $24				dec 	zVarType 					; converts from an array to a type.
.0199ab	a5 24		lda $24				lda 	zVarType 					; check that type
.0199ad	c9 b7		cmp #$b7			cmp 	#token_Dollar 				; if string, use x 2
.0199af	f0 15		beq $0199c6			beq 	_AIFCalculate
.0199b1	06 10		asl $10				asl 	zTemp1			 			; double the index
.0199b3	26 11		rol $11				rol 	zTemp1+1					; (e.g. index * 4)
.0199b5	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if integer, use x 4
.0199b7	f0 0d		beq $0199c6			beq 	_AIFCalculate
.0199b9	18		clc				clc 								; add the original mantissa in again
.0199ba	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; which makes it x5, for float.
.0199bc	65 10		adc $10				adc 	zTemp1
.0199be	85 10		sta $10				sta 	zTemp1
.0199c0	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0199c2	65 11		adc $11				adc 	zTemp1+1
.0199c4	85 11		sta $11				sta 	zTemp1+1
.0199c6					_AIFCalculate:
.0199c6	18		clc				clc 								; add index x 2,4 or 5 to base
.0199c7	a5 22		lda $22				lda 	zVarDataPtr
.0199c9	65 10		adc $10				adc 	zTemp1
.0199cb	85 22		sta $22				sta 	zVarDataPtr
.0199cd	a5 23		lda $23				lda 	zVarDataPtr+1
.0199cf	65 11		adc $11				adc 	zTemp1+1
.0199d1	85 23		sta $23				sta 	zVarDataPtr+1
.0199d3	18		clc				clc 								; add 2 more for the length prefix.
.0199d4	a5 22		lda $22				lda 	zVarDataPtr
.0199d6	69 02		adc #$02			adc 	#2
.0199d8	85 22		sta $22				sta 	zVarDataPtr
.0199da	90 02		bcc $0199de			bcc 	_AIFNoBump
.0199dc	e6 23		inc $23				inc 	zVarDataPtr+1
.0199de					_AIFNoBump:
.0199de	7a		ply				ply
.0199df	60		rts				rts
.0199e0					_AIFError:
.0199e0	20 57 85	jsr $018557			jsr ERR_Handler
>0199e3	42 61 64 20 61 72 72 61			.text "Bad array index",0
>0199eb	79 20 69 6e 64 65 78 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arraydef.asm

.0199f3					ArrayResetDefault:
.0199f3	a9 0b		lda #$0b			lda 	#11 						; 0..10 one array
.0199f5	8d a9 03	sta $03a9			sta 	ArrayDef+0
.0199f8	a9 00		lda #$00			lda 	#0
.0199fa	8d aa 03	sta $03aa			sta 	ArrayDef+1
.0199fd	a9 ff		lda #$ff			lda 	#$FF
.0199ff	8d ab 03	sta $03ab			sta 	ArrayDef+2 					; $FFFF implies no second element.
.019a02	8d ac 03	sta $03ac			sta 	ArrayDef+3					; (test bit 7 of 2nd byte)
.019a05	60		rts				rts
.019a06					ArrayCreate:
.019a06	bd a9 03	lda $03a9,x			lda 	ArrayDef+0,x 				; put size x 2 in zTemp1
.019a09	0a		asl a				asl 	a
.019a0a	85 10		sta $10				sta 	zTemp1
.019a0c	bd aa 03	lda $03aa,x			lda 	ArrayDef+1,x
.019a0f	2a		rol a				rol 	a
.019a10	85 11		sta $11				sta 	zTemp1+1
.019a12	bd ac 03	lda $03ac,x			lda 	ArrayDef+3,x 				; if this is the last element it's array of ptrs.
.019a15	10 22		bpl $019a39			bpl 	_ACSized 					; if not multiply size x 2 (str) 4 (int) 5 (real)
.019a17	ad 95 03	lda $0395			lda 	Var_Type 					; check the type
.019a1a	c9 b8		cmp #$b8			cmp 	#token_DollarLParen 		; also if it is an array of strings $(
.019a1c	f0 1b		beq $019a39			beq 	_ACSized
.019a1e	06 10		asl $10				asl 	zTemp1 						; double again
.019a20	26 11		rol $11				rol 	zTemp1+1
.019a22	b0 6f		bcs $019a93			bcs 	ArrayIndexError 			; too large.
.019a24	c9 bc		cmp #$bc			cmp 	#token_PercentLParen 		; if %( four bytes/entry is enough.
.019a26	f0 11		beq $019a39			beq 	_ACSized
.019a28	18		clc				clc 								; add original value x 5 for reals.
.019a29	a5 10		lda $10				lda 	zTemp1
.019a2b	7d a9 03	adc $03a9,x			adc 	ArrayDef+0,x
.019a2e	85 10		sta $10				sta 	zTemp1
.019a30	a5 11		lda $11				lda 	zTemp1+1
.019a32	7d aa 03	adc $03aa,x			adc 	ArrayDef+1,x
.019a35	85 11		sta $11				sta 	zTemp1+1
.019a37	b0 5a		bcs $019a93			bcs 	ArrayIndexError
.019a39					_ACSized:
.019a39	18		clc				clc
.019a3a	a5 10		lda $10				lda 	zTemp1
.019a3c	69 02		adc #$02			adc 	#2
.019a3e	85 10		sta $10				sta 	zTemp1
.019a40	90 04		bcc $019a46			bcc 	_ACNoBump
.019a42	e6 10		inc $10				inc 	zTemp1
.019a44	f0 4d		beq $019a93			beq 	ArrayIndexError
.019a46					_ACNoBump:
.019a46	18		clc				clc
.019a47	ad 02 03	lda $0302			lda 	VarMemPtr 					; add this allocated count to VarMemPtr
.019a4a	85 12		sta $12				sta 	zTemp2						; save start in zTemp2/zTemp3
.019a4c	85 14		sta $14				sta 	zTemp3
.019a4e	65 10		adc $10				adc 	zTemp1
.019a50	8d 02 03	sta $0302			sta 	VarMemPtr
.019a53	ad 03 03	lda $0303			lda 	VarMemPtr+1
.019a56	85 13		sta $13				sta 	zTemp2+1
.019a58	85 15		sta $15				sta 	zTemp3+1
.019a5a	65 11		adc $11				adc 	zTemp1+1
.019a5c	8d 03 03	sta $0303			sta 	VarMemPtr+1
.019a5f	85 11		sta $11				sta 	zTemp1+1
.019a61	b0 30		bcs $019a93			bcs 	ArrayIndexError
.019a63	a0 00		ldy #$00			ldy 	#0							; write $00 out.
.019a65					_ACClear:
.019a65	98		tya				tya
.019a66	91 12		sta ($12),y			sta 	(zTemp2),y
.019a68	e6 12		inc $12				inc 	zTemp2
.019a6a	d0 02		bne $019a6e			bne 	_ACCBump
.019a6c	e6 13		inc $13				inc 	zTemp2+1
.019a6e					_ACCBump:
.019a6e	a5 12		lda $12				lda 	zTemp2
.019a70	cd 02 03	cmp $0302			cmp 	VarMemPtr
.019a73	d0 f0		bne $019a65			bne 	_ACClear
.019a75	a5 13		lda $13				lda 	zTemp2+1
.019a77	cd 03 03	cmp $0303			cmp 	VarMemPtr+1
.019a7a	d0 e9		bne $019a65			bne 	_ACClear
.019a7c	a0 00		ldy #$00			ldy 	#0
.019a7e	bd a9 03	lda $03a9,x			lda 	ArrayDef+0,x 				; copy the size into the start
.019a81	91 14		sta ($14),y			sta 	(zTemp3),y
.019a83	c8		iny				iny
.019a84	bd aa 03	lda $03aa,x			lda 	ArrayDef+1,x
.019a87	91 14		sta ($14),y			sta 	(zTemp3),y
.019a89	bd ac 03	lda $03ac,x			lda 	ArrayDef+3,x 				; have we reached the end
.019a8c	10 18		bpl $019aa6			bpl 	ACCFillRecursive
.019a8e	a4 15		ldy $15				ldy 	zTemp3+1 					; return address
.019a90	a5 14		lda $14				lda 	zTemp3
.019a92	60		rts				rts
.019a93					ArrayIndexError:
.019a93	20 57 85	jsr $018557			jsr ERR_Handler
>019a96	42 61 64 20 61 72 72 61			.text "Bad array index",0
>019a9e	79 20 69 6e 64 65 78 00
.019aa6					ACCFillRecursive:
.019aa6	a9 ff		lda #$ff			lda 	#$FF 						; we mark the end, this is free space.
.019aa8	a0 00		ldy #$00			ldy 	#0 							; this is overwritten by size of next allocated
.019aaa	91 12		sta ($12),y			sta 	(zTemp2),y 					; array, but we might change that.
.019aac	c8		iny				iny
.019aad	b1 14		lda ($14),y			lda 	(zTemp3),y 					; set bit 15 of the max index indicating
.019aaf	09 80		ora #$80			ora 	#$80 						; an array of pointers
.019ab1	91 14		sta ($14),y			sta 	(zTemp3),y
.019ab3	a5 14		lda $14				lda 	zTemp3 						; push the start on the stack
.019ab5	48		pha				pha
.019ab6	a5 15		lda $15				lda 	zTemp3+1
.019ab8	48		pha				pha
.019ab9					_ACCFillLoop:
.019ab9	18		clc				clc
.019aba	a5 14		lda $14				lda 	zTemp3 						; and work forwards.
.019abc	69 02		adc #$02			adc 	#2
.019abe	85 14		sta $14				sta 	zTemp3
.019ac0	90 02		bcc $019ac4			bcc 	_ACCSkip2
.019ac2	e6 15		inc $15				inc 	zTemp3+1
.019ac4					_ACCSkip2:
.019ac4	a0 00		ldy #$00			ldy 	#0 							; reached the end ?
.019ac6	b1 14		lda ($14),y			lda 	(zTemp3),y					; (looking for FF marker, everything else 00)
.019ac8	c8		iny				iny
.019ac9	11 14		ora ($14),y			ora 	(zTemp3),y
.019acb	d0 21		bne $019aee			bne 	_ACCExit
.019acd	a5 14		lda $14				lda 	zTemp3 						; push zTemp3
.019acf	48		pha				pha
.019ad0	a5 15		lda $15				lda 	zTemp3+1
.019ad2	48		pha				pha
.019ad3	e8		inx				inx
.019ad4	e8		inx				inx
.019ad5	20 06 9a	jsr $019a06			jsr 	ArrayCreate 				; create array recursively.
.019ad8	ca		dex				dex
.019ad9	ca		dex				dex
.019ada	85 12		sta $12				sta 	zTemp2 						; save A
.019adc	68		pla				pla
.019add	85 15		sta $15				sta 	zTemp3+1 					; restore zTemp3
.019adf	68		pla				pla
.019ae0	85 14		sta $14				sta 	zTemp3
.019ae2	98		tya				tya 								; write high bye from Y
.019ae3	a0 01		ldy #$01			ldy 	#1
.019ae5	91 14		sta ($14),y			sta 	(zTemp3),y
.019ae7	88		dey				dey 								; write low byte out.
.019ae8	a5 12		lda $12				lda 	zTemp2
.019aea	91 14		sta ($14),y			sta 	(zTemp3),y
.019aec	80 cb		bra $019ab9			bra 	_ACCFillLoop 				; and try again.
.019aee					_ACCExit:
.019aee	7a		ply				ply 								; restore the original address
.019aef	68		pla				pla
.019af0	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varfind.asm

.019af1					VariableLocate:
.019af1	da		phx				phx
.019af2	5a		phy				phy
.019af3	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.019af6	85 12		sta $12				sta 	zTemp2 						; points to first address.
.019af8	a9 03		lda #$03			lda 	#HashTableBase >> 8
.019afa	85 13		sta $13				sta 	zTemp2+1
.019afc	a0 00		ldy #$00	_VLNext:ldy 	#0 							; get next link into AX
.019afe	b1 12		lda ($12),y			lda 	(zTemp2),y
.019b00	aa		tax				tax
.019b01	c8		iny				iny
.019b02	b1 12		lda ($12),y			lda 	(zTemp2),y
.019b04	85 13		sta $13				sta 	zTemp2+1 					; save in zTemp
.019b06	86 12		stx $12				stx 	zTemp2
.019b08	05 12		ora $12				ora 	zTemp2 						; got zero
.019b0a	18		clc				clc
.019b0b	f0 25		beq $019b32			beq 	_VLExit 					; if so, then fail as end of chain.
.019b0d	c8		iny				iny 								; point to hash (offset + 2)
.019b0e	b1 12		lda ($12),y			lda 	(zTemp2),y
.019b10	cd 96 03	cmp $0396			cmp 	Var_Hash
.019b13	d0 e7		bne $019afc			bne 	_VLNext 					; try next if different.
.019b15					_VLCompare:
.019b15	c8		iny				iny 								; next character
.019b16	b1 12		lda ($12),y			lda 	(zTemp2),y 					; compare variable field against buffer.
.019b18	d9 12 03	cmp $0312,y			cmp 	Var_Buffer-3,y 				; the -3 is because name starts at 3.
.019b1b	d0 df		bne $019afc			bne 	_VLNext 					; fail if different, try next.
.019b1d	0a		asl a				asl 	a 							; until end character (bit 7 set) matched
.019b1e	90 f5		bcc $019b15			bcc 	_VLCompare
.019b20	98		tya				tya
.019b21	38		sec				sec 								; add 1 as Y points to last character
.019b22	65 12		adc $12				adc 	zTemp2 						; add to the current address
.019b24	85 22		sta $22				sta 	zVarDataPtr
.019b26	a5 13		lda $13				lda 	zTemp2+1
.019b28	69 00		adc #$00			adc 	#0
.019b2a	85 23		sta $23				sta 	zVarDataPtr+1
.019b2c	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.019b2f	85 24		sta $24				sta 	zVarType
.019b31	38		sec				sec 								; return CS
.019b32	7a		ply		_VLExit:ply
.019b33	fa		plx				plx
.019b34	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/vargetset.asm

.019b35					VariableGet:
.019b35	5a		phy				phy
.019b36	a0 00		ldy #$00			ldy 	#0 							; copy first two bytes
.019b38	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019b3a	95 80		sta $80,x			sta 	XS_Mantissa,x
.019b3c	c8		iny				iny
.019b3d	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019b3f	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019b41	c8		iny				iny
.019b42	a5 24		lda $24				lda 	zVarType 					; if it is a string, set up for that.
.019b44	c9 b7		cmp #$b7			cmp 	#token_Dollar
.019b46	f0 2c		beq $019b74			beq 	_VGString
.019b48	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; copy the next two bytes.
.019b4a	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019b4c	c8		iny				iny
.019b4d	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019b4f	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019b51	c8		iny				iny
.019b52	a9 01		lda #$01			lda 	#1 							; set type to 1.
.019b54	95 85		sta $85,x			sta 	XS_Type,x
.019b56	a5 24		lda $24				lda 	zVarType
.019b58	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if it is a %, then exit with default integer.
.019b5a	f0 28		beq $019b84			beq 	_VGExit
.019b5c	a9 40		lda #$40			lda 	#$40 						; set type byte to zero
.019b5e	95 85		sta $85,x			sta 	XS_Type,x 					; which is the code for zero/float.
.019b60	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; the last value to copy is the exponent.
.019b62	95 84		sta $84,x			sta 	XS_Exponent,x
.019b64	f0 1e		beq $019b84			beq 	_VGExit 					; if exponent is zero ... it's zero.
.019b66	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; the sign bit is the top mantissa bit.
.019b68	48		pha				pha
.019b69	29 80		and #$80			and 	#$80
.019b6b	95 85		sta $85,x			sta 	XS_Type,x 					; this is the type byte.
.019b6d	68		pla				pla
.019b6e	09 80		ora #$80			ora 	#$80 						; set the MSB as you would expect.
.019b70	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; so it's a normalised float.
.019b72	80 10		bra $019b84			bra 	_VGExit
.019b74					_VGString:
.019b74	a9 02		lda #$02			lda 	#2 							; set type to 2, a string
.019b76	95 85		sta $85,x			sta 	XS_Type,x
.019b78	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; is the value there $0000
.019b7a	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019b7c	d0 06		bne $019b84			bne 	_VGExit 					; if not, exit.
.019b7e	85 25		sta $25				sta 	zNullString 				; make zNullString a 00 string.
.019b80	a9 25		lda #$25			lda 	#zNullString
.019b82	95 80		sta $80,x			sta 	XS_Mantissa,x 				; make it point to it.
.019b84					_VGExit:
.019b84	7a		ply				ply
.019b85	60		rts				rts
.019b86					VariableSet:
.019b86	b5 85		lda $85,x			lda 	XS_Type,x 					; is the result a string
.019b88	29 02		and #$02			and 	#2 							; if so, it has to be
.019b8a	d0 4b		bne $019bd7			bne 	_VSString
.019b8c	a5 24		lda $24				lda 	zVarType 					; if type is $ there's an error.
.019b8e	c9 b7		cmp #$b7			cmp 	#token_Dollar
.019b90	f0 42		beq $019bd4			beq 	_VSBadType
.019b92	c9 bb		cmp #$bb			cmp 	#token_Percent 				; type convert to float/int
.019b94	f0 05		beq $019b9b			beq 	_VSMakeInt
.019b96	20 fc a0	jsr $01a0fc			jsr 	FPUToFloat
.019b99	80 03		bra $019b9e			bra 	_VSCopy
.019b9b					_VSMakeInt:
.019b9b	20 48 a1	jsr $01a148			jsr 	FPUToInteger
.019b9e					_VSCopy:
.019b9e	5a		phy				phy
.019b9f	a0 00		ldy #$00			ldy 	#0 							; copy mantissa to target.
.019ba1	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019ba3	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019ba5	c8		iny				iny
.019ba6	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019ba8	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019baa	c8		iny				iny
.019bab	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019bad	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019baf	c8		iny				iny
.019bb0	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019bb2	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019bb4	a5 24		lda $24				lda 	zVarType 					; if target is integer, alrady done.
.019bb6	c9 bb		cmp #$bb			cmp 	#token_Percent
.019bb8	f0 18		beq $019bd2			beq 	_VSExit
.019bba	b5 85		lda $85,x			lda 	XS_Type,x 					; get the sign bit into carry flag.
.019bbc	0a		asl a				asl 	a
.019bbd	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; shift the sign into the mantissa high.
.019bbf	08		php				php
.019bc0	0a		asl a				asl 	a
.019bc1	28		plp				plp
.019bc2	6a		ror a				ror 	a
.019bc3	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019bc5	c8		iny				iny
.019bc6	b5 84		lda $84,x			lda 	XS_Exponent,x 				; copy the exponent in
.019bc8	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019bca	34 85		bit $85,x			bit 	XS_Type,x 					; if the result is non zero
.019bcc	50 04		bvc $019bd2			bvc 	_VSExit
.019bce	a9 00		lda #$00			lda 	#00 						; zero exponent indicating 0.
.019bd0	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019bd2					_VSExit:
.019bd2	7a		ply				ply
.019bd3	60		rts				rts
.019bd4					_VSBadType:
.019bd4	4c 38 85	jmp $018538			jmp 	TypeError
.019bd7					_VSString:
.019bd7	a5 24		lda $24				lda 	zVarType 					; type must be $
.019bd9	c9 b7		cmp #$b7			cmp 	#token_Dollar
.019bdb	d0 f7		bne $019bd4			bne 	_VSBadType
.019bdd	da		phx				phx
.019bde	5a		phy				phy
.019bdf	20 5c 97	jsr $01975c			jsr 	StringConcrete 				; concrete the string in the mantissa -> AX
.019be2	a0 01		ldy #$01			ldy 	#1 							; save high byte
.019be4	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019be6	88		dey				dey 								; save low byte
.019be7	8a		txa				txa
.019be8	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019bea	7a		ply				ply 								; and exit.
.019beb	fa		plx				plx
.019bec	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.019bed					MulInteger32:
.019bed	b5 80		lda $80,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.019bef	95 8c		sta $8c,x			sta 	XS3_Mantissa,x
.019bf1	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019bf3	95 8d		sta $8d,x			sta 	XS3_Mantissa+1,x
.019bf5	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019bf7	95 8e		sta $8e,x			sta 	XS3_Mantissa+2,x
.019bf9	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019bfb	95 8f		sta $8f,x			sta 	XS3_Mantissa+3,x
.019bfd	a9 00		lda #$00			lda 	#0
.019bff	95 80		sta $80,x			sta 	XS_Mantissa+0,x 				; zero +0
.019c01	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019c03	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019c05	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019c07					_BFMMultiply:
.019c07	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.019c09	29 01		and #$01			and 	#1
.019c0b	f0 03		beq $019c10			beq 	_BFMNoAdd
.019c0d	20 c4 92	jsr $0192c4			jsr 	AddInteger32
.019c10					_BFMNoAdd:
.019c10	16 86		asl $86,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.019c12	36 87		rol $87,x			rol 	XS2_Mantissa+1,x
.019c14	36 88		rol $88,x			rol 	XS2_Mantissa+2,x
.019c16	36 89		rol $89,x			rol 	XS2_Mantissa+3,x
.019c18	56 8f		lsr $8f,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.019c1a	76 8e		ror $8e,x			ror 	XS3_Mantissa+2,x
.019c1c	76 8d		ror $8d,x			ror 	XS3_Mantissa+1,x
.019c1e	76 8c		ror $8c,x			ror 	XS3_Mantissa,x
.019c20	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.019c22	15 8d		ora $8d,x			ora 	XS3_Mantissa+1,x
.019c24	15 8e		ora $8e,x			ora 	XS3_Mantissa+2,x
.019c26	15 8f		ora $8f,x			ora 	XS3_Mantissa+3,x
.019c28	d0 dd		bne $019c07			bne 	_BFMMultiply
.019c2a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.019c2b					DivInteger32:
.019c2b	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; check for /0
.019c2d	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.019c2f	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.019c31	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.019c33	d0 14		bne $019c49			bne 	_BFDOkay
.019c35	20 57 85	jsr $018557			jsr ERR_Handler
>019c38	44 69 76 69 73 69 6f 6e			.text "Division by Zero",0
>019c40	20 62 79 20 5a 65 72 6f 00
.019c49					_BFDOkay:
.019c49	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.019c4b	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.019c4d	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.019c4f	85 1c		sta $1c				sta 	zLTemp1+2
.019c51	85 1d		sta $1d				sta 	zLTemp1+3
.019c53	8d 9e 03	sta $039e			sta 	SignCount 					; Count of signs.
.019c56	20 ad 9c	jsr $019cad			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.019c59	da		phx				phx
.019c5a	e8		inx				inx
.019c5b	e8		inx				inx
.019c5c	e8		inx				inx
.019c5d	e8		inx				inx
.019c5e	e8		inx				inx
.019c5f	e8		inx				inx
.019c60	20 ad 9c	jsr $019cad			jsr 	CheckIntegerNegate
.019c63	fa		plx				plx
.019c64	5a		phy				phy 								; Y is the counter
.019c65	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.019c67					_BFDLoop:
.019c67	16 80		asl $80,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.019c69	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.019c6b	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.019c6d	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.019c6f	26 1a		rol $1a				rol 	zLTemp1
.019c71	26 1b		rol $1b				rol 	zLTemp1+1
.019c73	26 1c		rol $1c				rol 	zLTemp1+2
.019c75	26 1d		rol $1d				rol 	zLTemp1+3
.019c77	38		sec				sec
.019c78	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.019c7a	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.019c7c	48		pha				pha
.019c7d	a5 1b		lda $1b				lda 	zLTemp1+1
.019c7f	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.019c81	48		pha				pha
.019c82	a5 1c		lda $1c				lda 	zLTemp1+2
.019c84	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.019c86	48		pha				pha
.019c87	a5 1d		lda $1d				lda 	zLTemp1+3
.019c89	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.019c8b	90 13		bcc $019ca0			bcc 	_BFDNoAdd
.019c8d	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.019c8f	68		pla				pla
.019c90	85 1c		sta $1c				sta 	zLTemp1+2
.019c92	68		pla				pla
.019c93	85 1b		sta $1b				sta 	zLTemp1+1
.019c95	68		pla				pla
.019c96	85 1a		sta $1a				sta 	zLTemp1+0
.019c98	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.019c9a	09 01		ora #$01			ora 	#1
.019c9c	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019c9e	80 03		bra $019ca3			bra 	_BFDNext
.019ca0					_BFDNoAdd:
.019ca0	68		pla				pla 								; Throw away the intermediate calculations
.019ca1	68		pla				pla
.019ca2	68		pla				pla
.019ca3					_BFDNext:
.019ca3	88		dey				dey
.019ca4	d0 c1		bne $019c67			bne 	_BFDLoop
.019ca6	7a		ply				ply 								; restore Y and exit
.019ca7	4e 9e 03	lsr $039e			lsr 	SignCount 					; if sign count odd,
.019caa	b0 06		bcs $019cb2			bcs		IntegerNegateAlways 			; negate the result
.019cac	60		rts				rts
.019cad					CheckIntegerNegate:
.019cad	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019caf	30 01		bmi $019cb2			bmi 	IntegerNegateAlways
.019cb1	60		rts				rts
.019cb2					IntegerNegateAlways:
.019cb2	ee 9e 03	inc $039e			inc 	SignCount
.019cb5	38		sec				sec
.019cb6	a9 00		lda #$00			lda 	#0
.019cb8	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.019cba	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019cbc	a9 00		lda #$00			lda 	#0
.019cbe	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.019cc0	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019cc2	a9 00		lda #$00			lda 	#0
.019cc4	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.019cc6	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019cc8	a9 00		lda #$00			lda 	#0
.019cca	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.019ccc	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019cce	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.019ccf					INTToString:
.019ccf	48		pha				pha
.019cd0	5a		phy				phy
.019cd1	b5 83		lda $83,x			lda 		XS_Mantissa+3,x 		; check -ve
.019cd3	10 08		bpl $019cdd			bpl 		_ITSNotMinus
.019cd5	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.019cd7	20 71 9d	jsr $019d71			jsr 		ITSOutputCharacter
.019cda	20 b2 9c	jsr $019cb2			jsr 		IntegerNegateAlways 	; negate the number.
.019cdd					_ITSNotMinus:
.019cdd	a9 00		lda #$00			lda 		#0
.019cdf	8d 9a 03	sta $039a			sta 		NumSuppress 			; clear the suppression flag.
.019ce2	8a		txa				txa 								; use Y for the mantissa index.
.019ce3	a8		tay				tay
.019ce4	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.019ce6					_ITSNextSubtractor:
.019ce6	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.019ce8	8d 9b 03	sta $039b			sta 		NumConvCount
.019ceb					_ITSSubtract:
.019ceb	38		sec				sec
.019cec	b9 80 00	lda $0080,y			lda 		XS_Mantissa,y 			; subtract number and push on stack
.019cef	ff 4d 9d 01	sbc $019d4d,x			sbc 		_ITSSubtractors+0,x
.019cf3	48		pha				pha
.019cf4	b9 81 00	lda $0081,y			lda 		XS_Mantissa+1,y
.019cf7	ff 4e 9d 01	sbc $019d4e,x			sbc 		_ITSSubtractors+1,x
.019cfb	48		pha				pha
.019cfc	b9 82 00	lda $0082,y			lda 		XS_Mantissa+2,y
.019cff	ff 4f 9d 01	sbc $019d4f,x			sbc 		_ITSSubtractors+2,x
.019d03	48		pha				pha
.019d04	b9 83 00	lda $0083,y			lda 		XS_Mantissa+3,y
.019d07	ff 50 9d 01	sbc $019d50,x			sbc 		_ITSSubtractors+3,x
.019d0b	90 14		bcc $019d21			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.019d0d	99 83 00	sta $0083,y			sta 		XS_Mantissa+3,y 		; save subtract off stack
.019d10	68		pla				pla
.019d11	99 82 00	sta $0082,y			sta 		XS_Mantissa+2,y
.019d14	68		pla				pla
.019d15	99 81 00	sta $0081,y			sta 		XS_Mantissa+1,y
.019d18	68		pla				pla
.019d19	99 80 00	sta $0080,y			sta 		XS_Mantissa+0,y
.019d1c	ee 9b 03	inc $039b			inc 		NumConvCount 			; bump count.
.019d1f	80 ca		bra $019ceb			bra 		_ITSSubtract 			; go round again.
.019d21					_ITSCantSubtract:
.019d21	68		pla				pla 								; throw away interim answers
.019d22	68		pla				pla
.019d23	68		pla				pla
.019d24	ad 9b 03	lda $039b			lda 		NumConvCount 			; if not zero then no suppression check
.019d27	c9 30		cmp #$30			cmp 		#"0"
.019d29	d0 05		bne $019d30			bne 		_ITSOutputDigit
.019d2b	ad 9a 03	lda $039a			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.019d2e	10 09		bpl $019d39			bpl	 		_ITSGoNextSubtractor
.019d30					_ITSOutputDigit:
.019d30	ce 9a 03	dec $039a			dec 		NumSuppress 			; suppression check will be non-zero.
.019d33	ad 9b 03	lda $039b			lda 		NumConvCount 			; count of subtractions
.019d36	20 71 9d	jsr $019d71			jsr 		ITSOutputCharacter 		; output it.
.019d39					_ITSGoNextSubtractor:
.019d39	e8		inx				inx 								; next dword
.019d3a	e8		inx				inx
.019d3b	e8		inx				inx
.019d3c	e8		inx				inx
.019d3d	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.019d3f	d0 a5		bne $019ce6			bne 		_ITSNextSubtractor 		; do all the subtractors.
.019d41	98		tya				tya 								; X is back as the mantissa index
.019d42	aa		tax				tax
.019d43	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.019d45	09 30		ora #$30			ora 		#"0"
.019d47	20 71 9d	jsr $019d71			jsr 		ITSOutputCharacter
.019d4a	7a		ply				ply 								; and exit
.019d4b	68		pla				pla
.019d4c	60		rts				rts
.019d4d					_ITSSubtractors:
>019d4d	00 ca 9a 3b					.dword 		1000000000
>019d51	00 e1 f5 05					.dword 		100000000
>019d55	80 96 98 00					.dword 		10000000
>019d59	40 42 0f 00					.dword 		1000000
>019d5d	a0 86 01 00					.dword 		100000
>019d61	10 27 00 00					.dword 		10000
>019d65	e8 03 00 00					.dword 		1000
>019d69	64 00 00 00					.dword 		100
>019d6d	0a 00 00 00					.dword 		10
.019d71					_ITSSubtractorsEnd:
.019d71					ITSOutputCharacter:
.019d71	48		pha				pha
.019d72	da		phx				phx
.019d73	ae 14 03	ldx $0314			ldx 	NumBufX 					; save digit
.019d76	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.019d79	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.019d7b	9d 16 03	sta $0316,x			sta 	Num_Buffer+1,x
.019d7e	ee 14 03	inc $0314			inc 	NumBufX						; bump pointer.
.019d81	fa		plx				plx
.019d82	68		pla				pla
.019d83	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.019d84					IntFromString:
.019d84	a0 00		ldy #$00			ldy 	#0
.019d86	8c 9c 03	sty $039c			sty 	ExpTemp 					; this is the converted digit count.
.019d89					IntFromStringY:
.019d89	48		pha				pha
.019d8a	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.019d8c	95 80		sta $80,x			sta 	XS_Mantissa,x
.019d8e	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019d90	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019d92	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019d94	a9 01		lda #$01			lda 	#1
.019d96	95 85		sta $85,x			sta 	XS_Type,x
.019d98					_IFSLoop:
.019d98	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.019d9a	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.019d9c	90 4e		bcc $019dec			bcc 	_IFSExit
.019d9e	c9 3a		cmp #$3a			cmp 	#"9"+1
.019da0	b0 4a		bcs $019dec			bcs 	_IFSExit
.019da2	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.019da4	c9 0c		cmp #$0c			cmp 	#12
.019da6	b0 4e		bcs $019df6			bcs 	_IFSOverflow
.019da8	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.019daa	48		pha				pha
.019dab	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019dad	48		pha				pha
.019dae	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019db0	48		pha				pha
.019db1	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019db3	48		pha				pha
.019db4	20 0b 9e	jsr $019e0b			jsr 	IFSX1ShiftLeft 				; double
.019db7	20 0b 9e	jsr $019e0b			jsr 	IFSX1ShiftLeft 				; x 4
.019dba	18		clc				clc 								; add saved value x 5
.019dbb	68		pla				pla
.019dbc	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.019dbe	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019dc0	68		pla				pla
.019dc1	75 81		adc $81,x			adc 	XS_Mantissa+1,x
.019dc3	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019dc5	68		pla				pla
.019dc6	75 82		adc $82,x			adc 	XS_Mantissa+2,x
.019dc8	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019dca	68		pla				pla
.019dcb	75 83		adc $83,x			adc 	XS_Mantissa+3,x
.019dcd	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019dcf	20 0b 9e	jsr $019e0b			jsr 	IFSX1ShiftLeft 				; x 10
.019dd2	ee 9c 03	inc $039c			inc 	ExpTemp 					; bump count of digits processed.
.019dd5	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.019dd7	29 0f		and #$0f			and 	#15
.019dd9	c8		iny				iny
.019dda	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.019ddc	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019dde	90 b8		bcc $019d98			bcc 	_IFSLoop
.019de0	f6 81		inc $81,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.019de2	d0 b4		bne $019d98			bne 	_IFSLoop
.019de4	f6 82		inc $82,x			inc 	XS_Mantissa+2,x
.019de6	d0 b0		bne $019d98			bne 	_IFSLoop
.019de8	f6 83		inc $83,x			inc 	XS_Mantissa+3,x
.019dea	80 ac		bra $019d98			bra 	_IFSLoop
.019dec					_IFSExit:
.019dec	98		tya				tya 								; get offset
.019ded					_IFSOkay:
.019ded	38		sec				sec
.019dee	ad 9c 03	lda $039c			lda 	ExpTemp
.019df1	f0 01		beq $019df4			beq 	_IFSSkipFail
.019df3	18		clc				clc
.019df4					_IFSSkipFail:
.019df4	68		pla				pla 								; and exit.
.019df5	60		rts				rts
.019df6					_IFSOverflow:
.019df6	20 57 85	jsr $018557			jsr 	ERR_Handler
>019df9	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>019e01	20 6f 76 65 72 66 6c 6f 77 00
.019e0b					IFSX1ShiftLeft:
.019e0b	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.019e0d	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.019e0f	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.019e11	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.019e13	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.019e14					FPSubtract:
.019e14	48		pha				pha
.019e15	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.019e17	49 80		eor #$80			eor 	#$80
.019e19	95 8b		sta $8b,x			sta 	XS2_Type,x
.019e1b	68		pla				pla 								; --- and fall through ---
.019e1c					FPAdd:
.019e1c	48		pha				pha
.019e1d	b5 85		lda $85,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.019e1f	d0 05		bne $019e26			bne 	_FPA_NegativeLHS
.019e21	20 3d 9e	jsr $019e3d			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.019e24	68		pla				pla
.019e25	60		rts				rts
.019e26					_FPA_NegativeLHS:
.019e26	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.019e28	49 80		eor #$80			eor 	#$80
.019e2a	95 85		sta $85,x			sta 	XS_Type,x
.019e2c	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of B and add
.019e2e	49 80		eor #$80			eor 	#$80
.019e30	95 8b		sta $8b,x			sta 	XS2_Type,x
.019e32	20 3d 9e	jsr $019e3d			jsr 	FPAdd_Worker 				; do the add calculation.
.019e35	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 back
.019e37	49 80		eor #$80			eor 	#$80
.019e39	95 85		sta $85,x			sta 	XS_Type,x
.019e3b	68		pla				pla
.019e3c	60		rts				rts
.019e3d					FPAdd_Worker:
.019e3d	34 8b		bit $8b,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.019e3f	70 07		bvs $019e48			bvs 	_FPAWExit 					; no change.
.019e41	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.019e43	50 07		bvc $019e4c			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.019e45	20 ba a0	jsr $01a0ba			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.019e48					_FPAWExit:
.019e48	20 29 a1	jsr $01a129			jsr 	FPUNormalise 				; normalise the result.
.019e4b	60		rts				rts
.019e4c					_FPAWMakeSame:
.019e4c	b5 84		lda $84,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.019e4e	38		sec				sec
.019e4f	f5 8a		sbc $8a,x			sbc	 	XS2_Exponent,x 				; using subtraction
.019e51	f0 16		beq $019e69			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.019e53	da		phx				phx 								; save X
.019e54	90 06		bcc $019e5c			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.019e56	e8		inx				inx
.019e57	e8		inx				inx
.019e58	e8		inx				inx
.019e59	e8		inx				inx
.019e5a	e8		inx				inx
.019e5b	e8		inx				inx
.019e5c					_FPAWShiftA:
.019e5c	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.019e5e	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.019e60	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.019e62	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.019e64	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.019e66	fa		plx				plx 								; restore original X
.019e67	80 e3		bra $019e4c			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.019e69					_FPAW_DoArithmetic:
.019e69	34 8b		bit $8b,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.019e6b	30 28		bmi $019e95			bmi 	_FPAW_BNegative
.019e6d	18		clc				clc
.019e6e	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019e70	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.019e72	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019e74	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019e76	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.019e78	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019e7a	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019e7c	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.019e7e	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019e80	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019e82	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.019e84	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019e86	90 c0		bcc $019e48			bcc 	_FPAWExit 					; no carry.
.019e88	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.019e8a	38		sec				sec
.019e8b	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.019e8d	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.019e8f	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.019e91	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.019e93	80 b3		bra $019e48			bra 	_FPAWExit
.019e95					_FPAW_BNegative:
.019e95	38		sec				sec
.019e96	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019e98	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.019e9a	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019e9c	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019e9e	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.019ea0	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019ea2	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019ea4	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.019ea6	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019ea8	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019eaa	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.019eac	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019eae	b0 09		bcs $019eb9			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.019eb0	20 e0 a0	jsr $01a0e0			jsr 	FPUNegateInteger			; negate the mantissa
.019eb3	b5 85		lda $85,x			lda 	XS_Type,x 					; flip result sign
.019eb5	49 80		eor #$80			eor 	#$80
.019eb7	95 85		sta $85,x			sta 	XS_Type,x
.019eb9					_FPAWGoExit:
.019eb9	4c 48 9e	jmp $019e48			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.019ebc					FPD_IsDivZero:
.019ebc	20 57 85	jsr $018557			jsr ERR_Handler
>019ebf	44 69 76 69 73 69 6f 6e			.text "Division by zero",0
>019ec7	20 62 79 20 7a 65 72 6f 00
.019ed0					FPDivide:
.019ed0	48		pha				pha
.019ed1	5a		phy				phy
.019ed2	34 8b		bit $8b,x			bit 	XS2_Type,x 					; check if division by zero
.019ed4	70 e6		bvs $019ebc			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.019ed6	34 85		bit $85,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.019ed8	f0 03		beq $019edd			beq 	_FPDCalculateExp
.019eda					_FPD_Exit:
.019eda	7a		ply				ply
.019edb	68		pla				pla
.019edc	60		rts				rts
.019edd					_FPDCalculateExp:
.019edd	b5 8a		lda $8a,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.019edf	49 ff		eor #$ff			eor 	#$FF
.019ee1	1a		inc a				inc 	a
.019ee2	95 8a		sta $8a,x			sta 	XS2_Exponent,x
.019ee4	20 b4 9f	jsr $019fb4			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.019ee7	18		clc				clc 	 							; add 1 to the resulting exponent
.019ee8	69 01		adc #$01			adc 	#1
.019eea	b0 54		bcs $019f40			bcs 	_FPD_Overflow 				; which can overflow.
.019eec	95 84		sta $84,x			sta 	XS_Exponent,x
.019eee	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.019ef0	85 1a		sta $1a				sta 	zLTemp1+0
.019ef2	85 1b		sta $1b				sta 	zLTemp1+1
.019ef4	85 1c		sta $1c				sta 	zLTemp1+2
.019ef6	85 1d		sta $1d				sta 	zLTemp1+3
.019ef8	a0 20		ldy #$20			ldy 	#32 						; times round.
.019efa					_FPD_Loop:
.019efa	38		sec				sec 								; calculate X1-X2 stacking result because we might
.019efb	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; not save it.
.019efd	f5 86		sbc $86,x			sbc 	XS2_Mantissa,x
.019eff	48		pha				pha
.019f00	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019f02	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.019f04	48		pha				pha
.019f05	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019f07	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.019f09	48		pha				pha
.019f0a	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019f0c	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.019f0e	90 13		bcc $019f23			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.019f10	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; save results out to A
.019f12	68		pla				pla
.019f13	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019f15	68		pla				pla
.019f16	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019f18	68		pla				pla
.019f19	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019f1b	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.019f1d	09 80		ora #$80			ora 	#$80
.019f1f	85 1d		sta $1d				sta 	zLTemp1+3
.019f21	80 03		bra $019f26			bra 	_FPD_Rotates
.019f23					_FPD_NoSubtract:
.019f23	68		pla				pla 								; throw away unwanted results
.019f24	68		pla				pla
.019f25	68		pla				pla
.019f26					_FPD_Rotates:
.019f26	56 89		lsr $89,x			lsr 	3+XS2_Mantissa,x
.019f28	76 88		ror $88,x			ror 	2+XS2_Mantissa,x
.019f2a	76 87		ror $87,x			ror 	1+XS2_Mantissa,x
.019f2c	76 86		ror $86,x			ror 	0+XS2_Mantissa,x
.019f2e	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.019f30	26 1b		rol $1b				rol 	zLTemp1+1
.019f32	26 1c		rol $1c				rol 	zLTemp1+2
.019f34	26 1d		rol $1d				rol 	zLTemp1+3
.019f36	90 02		bcc $019f3a			bcc 	_FPD_NoCarry
.019f38	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.019f3a					_FPD_NoCarry:
.019f3a	88		dey				dey 								; do 32 times
.019f3b	d0 bd		bne $019efa			bne 	_FPD_Loop
.019f3d	4c 98 9f	jmp $019f98			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.019f40					_FPD_Overflow:
.019f40	4c 86 a1	jmp $01a186			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.019f43					FPMultiply:
.019f43	48		pha				pha
.019f44	5a		phy				phy
.019f45	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.019f47	70 07		bvs $019f50			bvs 	_FPM_Exit
.019f49	34 8b		bit $8b,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.019f4b	50 06		bvc $019f53			bvc 	_FPM_CalcExponent
.019f4d	20 ba a0	jsr $01a0ba			jsr 	FPUCopyX2ToX1
.019f50					_FPM_Exit:
.019f50	7a		ply				ply
.019f51	68		pla				pla
.019f52	60		rts				rts
.019f53					_FPM_CalcExponent:
.019f53	18		clc				clc
.019f54	20 b4 9f	jsr $019fb4			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.019f57	95 84		sta $84,x			sta 	XS_Exponent,x 				; save the result.
.019f59	a9 00		lda #$00			lda 	#0
.019f5b	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.019f5d	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.019f5f	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.019f61	85 1d		sta $1d				sta 	zLTemp1+3
.019f63	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.019f65					_FPM_Loop:
.019f65	b5 80		lda $80,x			lda 	XS_Mantissa,x				; check LSB of long product
.019f67	29 01		and #$01			and 	#1
.019f69	18		clc				clc 								; clear carry for the long rotate.
.019f6a	f0 19		beq $019f85			beq 	_FPM_NoAddition
.019f6c	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.019f6d	a5 1a		lda $1a				lda 	zLTemp1+0
.019f6f	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.019f71	85 1a		sta $1a				sta 	zLTemp1+0
.019f73	a5 1b		lda $1b				lda 	zLTemp1+1
.019f75	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.019f77	85 1b		sta $1b				sta 	zLTemp1+1
.019f79	a5 1c		lda $1c				lda 	zLTemp1+2
.019f7b	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.019f7d	85 1c		sta $1c				sta 	zLTemp1+2
.019f7f	a5 1d		lda $1d				lda 	zLTemp1+3
.019f81	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.019f83	85 1d		sta $1d				sta 	zLTemp1+3
.019f85					_FPM_NoAddition:
.019f85	66 1d		ror $1d				ror 	3+zLTemp1
.019f87	66 1c		ror $1c				ror 	2+zLTemp1
.019f89	66 1b		ror $1b				ror 	1+zLTemp1
.019f8b	66 1a		ror $1a				ror 	0+zLTemp1
.019f8d	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.019f8f	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.019f91	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.019f93	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.019f95	88		dey				dey
.019f96	d0 cd		bne $019f65			bne 	_FPM_Loop 					; do this 32 times.
.019f98					FPM_CopySignNormalize:
.019f98	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.019f9a	95 80		sta $80,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.019f9c	a5 1b		lda $1b				lda 	zLTemp1+1
.019f9e	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019fa0	a5 1c		lda $1c				lda 	zLTemp1+2
.019fa2	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019fa4	a5 1d		lda $1d				lda 	zLTemp1+3
.019fa6	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019fa8	b5 85		lda $85,x			lda 	XS_Type,x 					; sign is xor of signs
.019faa	55 8b		eor $8b,x			eor 	XS2_Type,x
.019fac	95 85		sta $85,x			sta 	XS_Type,x
.019fae	20 29 a1	jsr $01a129			jsr 	FPUNormalise 				; normalise and exit.
.019fb1	7a		ply				ply
.019fb2	68		pla				pla
.019fb3	60		rts				rts
.019fb4					FPCalculateExponent:
.019fb4	18		clc				clc
.019fb5	b5 84		lda $84,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.019fb7	75 8a		adc $8a,x			adc 	XS2_Exponent,x
.019fb9	b0 08		bcs $019fc3			bcs 	_FPCECarry 					; carry out ?
.019fbb	10 03		bpl $019fc0			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.019fbd	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.019fbf	60		rts				rts
.019fc0					_FPCEExpZero:
.019fc0	a9 00		lda #$00			lda 	#0
.019fc2	60		rts				rts
.019fc3					_FPCECarry:
.019fc3	30 03		bmi $019fc8			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.019fc5	09 80		ora #$80			ora 	#$80 						; put in right range
.019fc7	60		rts				rts
.019fc8					_FPCEOverflow:
.019fc8	4c 86 a1	jmp $01a186			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.019fcb					FPFractionalPart:
.019fcb	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.019fcd	38		sec				sec 								; this flag tells us to keep the fractional part
.019fce	30 0d		bmi $019fdd			bmi 	FPGetPart
.019fd0	60		rts				rts
.019fd1					FPIntegerPart:
.019fd1	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.019fd3	18		clc				clc 								; this flag says keep the integer part.
.019fd4	30 07		bmi $019fdd			bmi 	FPGetPart 					; -ve exponents are 0..127
.019fd6	48		pha				pha
.019fd7	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.019fd9	95 85		sta $85,x			sta 	XS_Type,x
.019fdb	68		pla				pla
.019fdc	60		rts				rts
.019fdd					FPGetPart:
.019fdd	48		pha				pha
.019fde	5a		phy				phy 								; save Y
.019fdf	08		php				php 								; save action
.019fe0	34 85		bit $85,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.019fe2	70 59		bvs $01a03d			bvs 	_FPGP_Exit 					; then do nothing.
.019fe4	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.019fe6	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.019fe8	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.019fea	85 1c		sta $1c				sta 	zLTemp1+2
.019fec	85 1d		sta $1d				sta 	zLTemp1+3
.019fee	b5 84		lda $84,x			lda 	XS_Exponent,x				; the number of shifts.
.019ff0	38		sec				sec
.019ff1	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.019ff3	f0 12		beq $01a007			beq 	_FPGP_NoShift 				; ... if any
.019ff5	c9 20		cmp #$20			cmp 	#32
.019ff7	90 02		bcc $019ffb			bcc 	_FPGP_NotMax
.019ff9	a9 20		lda #$20			lda 	#32 						; max of 32.
.019ffb					_FPGP_NotMax:
.019ffb	a8		tay				tay 								; Y is the mask shift count.
.019ffc					_FPGP_ShiftMask:
.019ffc	46 1d		lsr $1d				lsr 	3+zLTemp1
.019ffe	66 1c		ror $1c				ror 	2+zLTemp1
.01a000	66 1b		ror $1b				ror 	1+zLTemp1
.01a002	66 1a		ror $1a				ror 	0+zLTemp1
.01a004	88		dey				dey
.01a005	d0 f5		bne $019ffc			bne 	_FPGP_ShiftMask
.01a007					_FPGP_NoShift:
.01a007	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.01a009	8e 9c 03	stx $039c			stx 	ExpTemp						; save X
.01a00c					_FPGP_MaskLoop:
.01a00c	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.01a00f	28		plp				plp 								; if CC we keep the top part, so we
.01a010	08		php				php		 							; flip the mask.
.01a011	b0 02		bcs $01a015			bcs		_FPGP_NoFlip
.01a013	49 ff		eor #$ff			eor 	#$FF
.01a015					_FPGP_NoFlip:
.01a015	35 80		and $80,x			and 	XS_Mantissa,x 				; and into the mantissa.
.01a017	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a019	e8		inx				inx
.01a01a	c8		iny				iny
.01a01b	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.01a01d	d0 ed		bne $01a00c			bne 	_FPGP_MaskLoop
.01a01f	ae 9c 03	ldx $039c			ldx 	ExpTemp						; restore X
.01a022	28		plp				plp
.01a023	08		php				php 								; get action flag on the stack
.01a024	90 04		bcc $01a02a			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.01a026	a9 00		lda #$00			lda 	#0
.01a028	95 85		sta $85,x			sta 	XS_Type,x
.01a02a					_FPGP_NotFractional:
.01a02a	b5 80		lda $80,x			lda 	XS_Mantissa,x 						; check if \1 zero
.01a02c	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.01a02e	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01a030	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01a032	f0 05		beq $01a039			beq 	_FPGP_Zero 					; if zero, return zero
.01a034	20 29 a1	jsr $01a129			jsr 	FPUNormalise
.01a037	80 04		bra $01a03d			bra 	_FPGP_Exit 					; and exit
.01a039					_FPGP_Zero:
.01a039	a9 40		lda #$40			lda 	#$40 						; set zero flag
.01a03b	95 85		sta $85,x			sta 	XS_Type,x
.01a03d					_FPGP_Exit:
.01a03d	68		pla				pla 								; throw saved action flag.
.01a03e	7a		ply				ply
.01a03f	68		pla				pla
.01a040	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.01a041					FPCompare:
.01a041	20 82 a0	jsr $01a082			jsr 	FPFastCompare 				; fast compare try first
.01a044	b0 3b		bcs $01a081			bcs 	_FPCExit 					; that worked.
.01a046	b5 84		lda $84,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.01a048	48		pha				pha
.01a049	b5 8a		lda $8a,x			lda 	XS2_Exponent,x
.01a04b	48		pha				pha
.01a04c	20 14 9e	jsr $019e14			jsr 	FPSubtract 					; calculate X1-X2
.01a04f	34 85		bit $85,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.01a051	70 2a		bvs $01a07d			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.01a053	68		pla				pla
.01a054	8d 9c 03	sta $039c			sta 	ExpTemp						; save first exponent in temporary reg.
.01a057	68		pla				pla
.01a058	38		sec				sec
.01a059	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; calculate AX-BX
.01a05c	70 14		bvs $01a072			bvs 	_FPCNotEqual				; overflow, can't be equal.
.01a05e	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.01a05f	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.01a061	b0 0f		bcs $01a072			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.01a063	38		sec				sec
.01a064	ad 9c 03	lda $039c			lda 	ExpTemp 					; get one of the exponents back.
.01a067	e9 12		sbc #$12			sbc 	#18 						; allow for 2^18 error, relatively.
.01a069	b0 02		bcs $01a06d			bcs 	_FPCNotRange 				; keep in range.
.01a06b	a9 01		lda #$01			lda 	#1
.01a06d					_FPCNotRange:
.01a06d	38		sec				sec
.01a06e	f5 84		sbc $84,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.01a070	b0 0d		bcs $01a07f			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.01a072					_FPCNotEqual:
.01a072	b5 85		lda $85,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.01a074	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.01a076	f0 02		beq $01a07a			beq 	_FPCNE2
.01a078	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.01a07a	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.01a07b	80 04		bra $01a081			bra 	_FPCExit
.01a07d					_FPCPullZero:
.01a07d	68		pla				pla 								; throw saved exponents
.01a07e	68		pla				pla
.01a07f					_FPCZero:
.01a07f	a9 00		lda #$00			lda 	#0 							; and return zero
.01a081					_FPCExit:
.01a081	60		rts				rts
.01a082					FPFastCompare:
.01a082	34 85		bit $85,x			bit 	XS_Type,x 					; n1 is zero.
.01a084	70 23		bvs $01a0a9			bvs 	_FPFLeftZero
.01a086	34 8b		bit $8b,x			bit 	XS2_Type,x 					; n2 is zero
.01a088	b5 85		lda $85,x			lda 	XS_Type,x 					; if so, return sign bit of 1 (n-0)
.01a08a	70 25		bvs $01a0b1			bvs 	_FPFSignBit
.01a08c	55 8b		eor $8b,x			eor 	XS2_Type,x 					; eor 2 type bits. now know both non-zero
.01a08e	0a		asl a				asl 	a 							; put in CS if different.
.01a08f	b5 85		lda $85,x			lda 	XS_Type,x 					; if signs different return sign of first
.01a091	b0 1e		bcs $01a0b1			bcs 	_FPFSignBit
.01a093	38		sec				sec 								; same sign and not-zero. compare exponents
.01a094	b5 84		lda $84,x			lda 	XS_Exponent,x 				; compare exponents. if the same, then fail.
.01a096	f5 8a		sbc $8a,x			sbc 	XS2_Exponent,x 				; e.g. we have to do it via subtraction.
.01a098	f0 09		beq $01a0a3			beq 	_FPNoFastCompare
.01a09a	6a		ror a				ror 	a 							; put carry into bit 7.
.01a09b	34 85		bit $85,x			bit 	XS_Type,X 					; if it is +x then flip it.
.01a09d	30 02		bmi $01a0a1			bmi		_FPFCNotMinus
.01a09f	49 80		eor #$80			eor 	#$80
.01a0a1					_FPFCNotMinus:
.01a0a1	80 0e		bra $01a0b1			bra		_FPFSignBit
.01a0a3					_FPNoFastCompare:
.01a0a3	18		clc				clc
.01a0a4	60		rts				rts
.01a0a5					_FPFZero:
.01a0a5	a9 00		lda #$00			lda 	#0
.01a0a7					_FPFExitSet:
.01a0a7	38		sec				sec
.01a0a8	60		rts				rts
.01a0a9					_FPFLeftZero:
.01a0a9	34 8b		bit $8b,x			bit 	XS2_Type,x 					; if right is zero, return zero.
.01a0ab	70 f8		bvs $01a0a5			bvs 	_FPFZero
.01a0ad	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip sign bit
.01a0af	49 80		eor #$80			eor 	#$80						; return that as a sign.
.01a0b1					_FPFSignBit:
.01a0b1	0a		asl a				asl 	a
.01a0b2	a9 01		lda #$01			lda 	#1
.01a0b4	90 f1		bcc $01a0a7			bcc		_FPFExitSet
.01a0b6	a9 ff		lda #$ff			lda 	#$FF
.01a0b8	38		sec				sec
.01a0b9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.01a0ba					FPUCopyX2ToX1:
.01a0ba	48		pha				pha
.01a0bb	da		phx				phx
.01a0bc	5a		phy				phy
.01a0bd	a0 08		ldy #$08			ldy 	#8
.01a0bf	b5 86		lda $86,x	_FPUC21:lda 	XS2_Mantissa,x
.01a0c1	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a0c3	e8		inx				inx
.01a0c4	88		dey				dey
.01a0c5	10 f8		bpl $01a0bf			bpl 	_FPUC21
.01a0c7	7a		ply				ply
.01a0c8	fa		plx				plx
.01a0c9	68		pla				pla
.01a0ca	60		rts				rts
.01a0cb					FPUSetInteger:
.01a0cb	48		pha				pha
.01a0cc	95 80		sta $80,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.01a0ce	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.01a0d0	10 02		bpl $01a0d4			bpl 	_FPUSIExtend
.01a0d2	a9 ff		lda #$ff			lda 	#$FF
.01a0d4					_FPUSIExtend:
.01a0d4	95 81		sta $81,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.01a0d6	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a0d8	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a0da	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.01a0dc	95 85		sta $85,x			sta 	XS_Type,x
.01a0de	68		pla				pla
.01a0df	60		rts				rts
.01a0e0					FPUNegateInteger:
.01a0e0	48		pha				pha
.01a0e1	38		sec				sec
.01a0e2	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.01a0e4	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.01a0e6	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a0e8	a9 00		lda #$00			lda 	#0
.01a0ea	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.01a0ec	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a0ee	a9 00		lda #$00			lda 	#0
.01a0f0	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.01a0f2	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a0f4	a9 00		lda #$00			lda 	#0
.01a0f6	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.01a0f8	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a0fa	68		pla				pla
.01a0fb	60		rts				rts
.01a0fc					FPUToFloat:
.01a0fc	48		pha				pha
.01a0fd	b5 85		lda $85,x			lda 	XS_Type,x					; exit if already float.
.01a0ff	29 0f		and #$0f			and 	#$0F
.01a101	f0 24		beq $01a127			beq 	_FPUFExit
.01a103	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.01a105	95 85		sta $85,x			sta 	XS_Type,x
.01a107	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.01a109	95 84		sta $84,x			sta 	XS_Exponent,x 				; x mantissa.
.01a10b	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.01a10d	10 07		bpl $01a116			bpl		_FPUFPositive
.01a10f	20 e0 a0	jsr $01a0e0			jsr 	FPUNegateInteger 			; negate the mantissa
.01a112	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.01a114	95 85		sta $85,x			sta 	XS_Type,x
.01a116					_FPUFPositive:
.01a116	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.01a118	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.01a11a	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01a11c	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01a11e	d0 04		bne $01a124			bne 	_FPUFNonZero
.01a120	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.01a122	95 85		sta $85,x			sta 	XS_Type,x
.01a124					_FPUFNonZero:
.01a124	20 29 a1	jsr $01a129			jsr 	FPUNormalise 				; normalise the floating point.
.01a127					_FPUFExit:
.01a127	68		pla				pla
.01a128	60		rts				rts
.01a129					FPUNormalise:
.01a129	48		pha				pha
.01a12a	34 85		bit $85,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.01a12c	70 18		bvs $01a146			bvs 	_FPUNExit
.01a12e	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.01a130	f0 10		beq $01a142			beq 	_FPUNSetZero
.01a132					_FPUNLoop:
.01a132	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.01a134	30 10		bmi $01a146			bmi 	_FPUNExit 					; if so, we are normalised.
.01a136	16 80		asl $80,x			asl 	0+XS_Mantissa+0,x
.01a138	36 81		rol $81,x			rol 	1+XS_Mantissa+0,x
.01a13a	36 82		rol $82,x			rol 	2+XS_Mantissa+0,x
.01a13c	36 83		rol $83,x			rol 	3+XS_Mantissa+0,x
.01a13e	d6 84		dec $84,x			dec 	XS_Exponent,x 				; decrement exponent
.01a140	d0 f0		bne $01a132			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.01a142					_FPUNSetZero:
.01a142	a9 40		lda #$40			lda 	#$40
.01a144	95 85		sta $85,x			sta 	XS_Type,x 					; the result is now zero.
.01a146					_FPUNExit:
.01a146	68		pla				pla
.01a147	60		rts				rts
.01a148					FPUToInteger:
.01a148	48		pha				pha
.01a149	b5 85		lda $85,x			lda 	XS_Type,x 					; if already integer, exit
.01a14b	29 01		and #$01			and 	#1
.01a14d	d0 31		bne $01a180			bne 	_FPUTOI_Exit
.01a14f	34 85		bit $85,x			bit 	XS_Type,x					; if zero, return zero.
.01a151	70 23		bvs $01a176			bvs 	_FPUTOI_Zero
.01a153	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.01a155	10 1f		bpl $01a176			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.01a157	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.01a159	b0 2b		bcs $01a186			bcs 	FP_Overflow
.01a15b					_FPUToIToInteger:
.01a15b	b5 84		lda $84,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.01a15d	c9 a0		cmp #$a0			cmp 	#128+32
.01a15f	f0 0c		beq $01a16d			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.01a161	f6 84		inc $84,x			inc 	XS_Exponent,X 				; increment Exponent
.01a163	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.01a165	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a167	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a169	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a16b	80 ee		bra $01a15b			bra 	_FPUToIToInteger 			; keep going.
.01a16d					_FPUToICheckSign:
.01a16d	b5 85		lda $85,x			lda 	XS_Type,x 					; check sign
.01a16f	10 0f		bpl $01a180			bpl 	_FPUToI_Exit 				; exit if unsigned.
.01a171	20 e0 a0	jsr $01a0e0			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.01a174	80 0a		bra $01a180			bra 	_FPUTOI_Exit
.01a176					_FPUTOI_Zero:
.01a176	a9 00		lda #$00			lda 	#0 							; return zero integer.
.01a178	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a17a	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a17c	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a17e	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a180					_FPUToI_Exit:
.01a180	a9 01		lda #$01			lda 	#1 							; set type to integer
.01a182	95 85		sta $85,x			sta 	XS_Type,x
.01a184	68		pla				pla
.01a185	60		rts				rts
.01a186					FP_Overflow:
.01a186	20 57 85	jsr $018557			jsr ERR_Handler
>01a189	46 6c 6f 61 74 69 6e 67			.text "Floating Point overflow",0
>01a191	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.01a1a1					FPUTimes10:
.01a1a1	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.01a1a3	85 1a		sta $1a				sta 	ZLTemp1+0
.01a1a5	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a1a7	85 1b		sta $1b				sta 	ZLTemp1+1
.01a1a9	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a1ab	85 1c		sta $1c				sta 	ZLTemp1+2
.01a1ad	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a1af	85 1d		sta $1d				sta 	ZLTemp1+3
.01a1b1	20 e6 a1	jsr $01a1e6			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.01a1b4	20 e6 a1	jsr $01a1e6			jsr 	_FPUT_LSR_ZLTemp1
.01a1b7	18		clc				clc
.01a1b8	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.01a1ba	65 1a		adc $1a				adc 	ZLTemp1+0
.01a1bc	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a1be	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a1c0	65 1b		adc $1b				adc 	ZLTemp1+1
.01a1c2	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a1c4	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a1c6	65 1c		adc $1c				adc 	ZLTemp1+2
.01a1c8	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a1ca	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a1cc	65 1d		adc $1d				adc 	ZLTemp1+3
.01a1ce	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a1d0	90 0a		bcc $01a1dc			bcc 	_FPUTimes10
.01a1d2	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.01a1d4	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a1d6	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a1d8	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a1da	f6 84		inc $84,x			inc 	XS_Exponent,x				; fix exponent
.01a1dc					_FPUTimes10:
.01a1dc	b5 84		lda $84,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.01a1de	18		clc				clc
.01a1df	69 03		adc #$03			adc 	#3
.01a1e1	95 84		sta $84,x			sta 	XS_Exponent,x
.01a1e3	b0 a1		bcs $01a186			bcs 	FP_Overflow 				; error
.01a1e5	60		rts				rts
.01a1e6					_FPUT_LSR_ZLTemp1:
.01a1e6	46 1d		lsr $1d				lsr 	ZLTemp1+3
.01a1e8	66 1c		ror $1c				ror 	ZLTemp1+2
.01a1ea	66 1b		ror $1b				ror 	ZLTemp1+1
.01a1ec	66 1a		ror $1a				ror 	ZLTemp1+0
.01a1ee	60		rts				rts
.01a1ef					FPUScale10A:
.01a1ef	5a		phy				phy
.01a1f0	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.01a1f2	f0 37		beq $01a22b			beq 	_FPUScaleExit
.01a1f4	da		phx				phx 								; save X
.01a1f5	e8		inx				inx
.01a1f6	e8		inx				inx
.01a1f7	e8		inx				inx
.01a1f8	e8		inx				inx
.01a1f9	e8		inx				inx
.01a1fa	e8		inx				inx
.01a1fb	a8		tay				tay 								; save power scalar in Y.
.01a1fc	a9 00		lda #$00			lda 	#0
.01a1fe	95 80		sta $80,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.01a200	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a202	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a204	95 85		sta $85,x			sta 	XS_Type,x
.01a206	a9 80		lda #$80			lda 	#$80
.01a208	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a20a	a9 81		lda #$81			lda 	#$81
.01a20c	95 84		sta $84,x			sta 	XS_Exponent,x
.01a20e	5a		phy				phy 								; save 10^n on stack.
.01a20f	c0 00		cpy #$00			cpy 	#0
.01a211	10 05		bpl $01a218			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.01a213	98		tya				tya
.01a214	49 ff		eor #$ff			eor 	#$FF
.01a216	1a		inc a				inc 	a
.01a217	a8		tay				tay
.01a218					_FPUSAbs:
.01a218	20 a1 a1	jsr $01a1a1			jsr 	FPUTimes10
.01a21b	88		dey				dey
.01a21c	d0 fa		bne $01a218			bne 	_FPUSAbs 					; tos is now 10^|AC|
.01a21e	68		pla				pla 								; restore count in A
.01a21f	fa		plx				plx 								; restore X pointing to number to scale.
.01a220	0a		asl a				asl 	a
.01a221	b0 05		bcs $01a228			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.01a223	20 43 9f	jsr $019f43			jsr 	FPMultiply 					; if clear multiply.
.01a226	80 03		bra $01a22b			bra		_FPUScaleExit
.01a228					_FPUSDivide:
.01a228	20 d0 9e	jsr $019ed0			jsr 	FPDivide
.01a22b					_FPUScaleExit:
.01a22b	7a		ply				ply
.01a22c	60		rts				rts
.01a22d					FPUCopyToNext:
.01a22d	a0 06		ldy #$06			ldy 		#6
.01a22f	da		phx				phx
.01a230					_FPUCopy1:
.01a230	b5 80		lda $80,x			lda 	XS_Mantissa,x
.01a232	95 86		sta $86,x			sta 	XS2_Mantissa,x
.01a234	e8		inx				inx
.01a235	88		dey				dey
.01a236	d0 f8		bne $01a230			bne 	_FPUCopy1
.01a238	fa		plx				plx
.01a239	60		rts				rts
.01a23a					FPUCopyFromNext:
.01a23a	a0 06		ldy #$06			ldy 		#6
.01a23c	da		phx				phx
.01a23d					_FPUCopy1:
.01a23d	b5 86		lda $86,x			lda 	XS2_Mantissa,x
.01a23f	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a241	e8		inx				inx
.01a242	88		dey				dey
.01a243	d0 f8		bne $01a23d			bne 	_FPUCopy1
.01a245	fa		plx				plx
.01a246	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.01a247					FPToString:
.01a247	48		pha				pha
.01a248	5a		phy				phy
.01a249	34 85		bit $85,x			bit 		XS_Type,x 				; check zero flag
.01a24b	50 0a		bvc $01a257			bvc 		_FPTSIsFloat 			; if zero,
.01a24d					_FPTSZero:
.01a24d	a9 30		lda #$30			lda 		#"0"
.01a24f	20 71 9d	jsr $019d71			jsr 		ITSOutputCharacter
.01a252					_FPTSExit:
.01a252	7a		ply				ply
.01a253	68		pla				pla
.01a254	60		rts				rts
.01a255	80 fb		bra $01a252			bra 		_FPTSExit
.01a257					_FPTSIsFloat:
.01a257	b5 85		lda $85,x			lda 		XS_Type,x 				; is it signed ?
.01a259	10 09		bpl $01a264			bpl 		_FPTSNotSigned
.01a25b	a9 00		lda #$00			lda 		#0 						; clear sign flag
.01a25d	95 85		sta $85,x			sta 		XS_Type,x
.01a25f	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.01a261	20 71 9d	jsr $019d71			jsr 		ITSOutputCharacter
.01a264					_FPTSNotSigned:
.01a264	b5 84		lda $84,x			lda 		XS_Exponent,x
.01a266	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.01a268	b0 09		bcs $01a273			bcs 		_FPTSExponent
.01a26a	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.01a26c	90 05		bcc $01a273			bcc 		_FPTSExponent 			;
.01a26e					_FPTSStandard:
.01a26e	20 b2 a2	jsr $01a2b2			jsr 		FPTOutputBody 			; output the body.
.01a271	80 df		bra $01a252			bra 		_FPTSExit
.01a273					_FPTSExponent:
.01a273	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.01a275	8d 9d 03	sta $039d			sta 		ExpCount
.01a278					_FPTSExponentLoop:
.01a278	b5 84		lda $84,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.01a27a	10 0e		bpl $01a28a			bpl 		_FPTSTimes
.01a27c	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.01a27e	90 14		bcc $01a294			bcc 		_FPTSScaledToExp
.01a280	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.01a282	20 ef a1	jsr $01a1ef			jsr 		FPUScale10A
.01a285	ee 9d 03	inc $039d			inc 		ExpCount
.01a288	80 ee		bra $01a278			bra 		_FPTSExponentLoop
.01a28a					_FPTSTimes:
.01a28a	a9 01		lda #$01			lda 		#1
.01a28c	20 ef a1	jsr $01a1ef			jsr 		FPUScale10A
.01a28f	ce 9d 03	dec $039d			dec 		ExpCount
.01a292	80 e4		bra $01a278			bra 		_FPTSExponentLoop
.01a294					_FPTSScaledToExp:
.01a294	20 b2 a2	jsr $01a2b2			jsr 		FPTOutputBody 			; output the body.
.01a297	a9 65		lda #$65			lda 		#"e"					; output E
.01a299	20 71 9d	jsr $019d71			jsr 		ITSOutputCharacter
.01a29c	ad 9d 03	lda $039d			lda 		ExpCount 				; get the exponent
.01a29f	95 80		sta $80,x			sta 		XS_Mantissa,x
.01a2a1	29 80		and #$80			and 		#$80 					; sign extend it
.01a2a3	f0 02		beq $01a2a7			beq 		_FPTSSExt
.01a2a5	a9 ff		lda #$ff			lda 		#$FF
.01a2a7					_FPTSSExt:
.01a2a7	95 81		sta $81,x			sta 		XS_Mantissa+1,x
.01a2a9	95 82		sta $82,x			sta 		XS_Mantissa+2,x
.01a2ab	95 83		sta $83,x			sta 		XS_Mantissa+3,x
.01a2ad	20 cf 9c	jsr $019ccf			jsr 		INTToString 			; output the exponent.
.01a2b0	80 a0		bra $01a252			bra			_FPTSExit 				; and exit.
.01a2b2					FPTOutputBody:
.01a2b2	20 2d a2	jsr $01a22d			jsr 		FPUCopyToNext 			; copy to next slot.
.01a2b5	20 48 a1	jsr $01a148			jsr 		FPUToInteger 			; convert to an integer
.01a2b8	20 cf 9c	jsr $019ccf			jsr 		INTToString 			; output the main integer part.
.01a2bb	20 3a a2	jsr $01a23a			jsr 		FPUCopyFromNext 		; get the fractional part back.
.01a2be	20 cb 9f	jsr $019fcb			jsr 		FPFractionalPart 		; get the decimal part.
.01a2c1	34 85		bit $85,x			bit 		XS_Type,x 				; any fractional part.
.01a2c3	70 3c		bvs $01a301			bvs 		_FPTOExit 				; if not, exit now.
.01a2c5	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.01a2c7	20 71 9d	jsr $019d71			jsr 		ITSOutputCharacter
.01a2ca					_FPOutLoop:
.01a2ca	34 85		bit $85,x			bit 		XS_Type,x 				; finally reached zero.
.01a2cc	70 1d		bvs $01a2eb			bvs 		_FPStripZeros 			; strip trailing zeros
.01a2ce	20 a1 a1	jsr $01a1a1			jsr 		FPUTimes10 				; multiply by 10
.01a2d1	20 2d a2	jsr $01a22d			jsr 		FPUCopyToNext			; copy to next slot.
.01a2d4	20 48 a1	jsr $01a148			jsr 		FPUToInteger 			; convert to integer
.01a2d7	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; print digit.
.01a2d9	09 30		ora #$30			ora 		#"0"
.01a2db	20 71 9d	jsr $019d71			jsr 		ITSOutputCharacter
.01a2de	20 3a a2	jsr $01a23a			jsr 		FPUCopyFromNext 		; get it back
.01a2e1	20 cb 9f	jsr $019fcb			jsr 		FPFractionalPart 		; get fractional part
.01a2e4	ad 14 03	lda $0314			lda 		NumBufX 				; done 11 characters yet ?
.01a2e7	c9 0b		cmp #$0b			cmp 	 	#11
.01a2e9	90 df		bcc $01a2ca			bcc 		_FPOutLoop 				; if so, keep going till zero.
.01a2eb					_FPStripZeros:
.01a2eb	ac 14 03	ldy $0314			ldy 		NumBufX 				; strip trailing zeros.
.01a2ee					_FPStripLoop:
.01a2ee	88		dey				dey 								; back one, if at start then no strip
.01a2ef	f0 10		beq $01a301			beq 		_FPToExit
.01a2f1	b9 15 03	lda $0315,y			lda 		Num_Buffer,y 			; keep going if "0"
.01a2f4	c9 30		cmp #$30			cmp 		#"0"
.01a2f6	f0 f6		beq $01a2ee			beq 		_FPStripLoop
.01a2f8	c8		iny				iny
.01a2f9	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.01a2fb	99 15 03	sta $0315,y			sta 		Num_Buffer,y
.01a2fe	8c 14 03	sty $0314			sty 		NumBufX 				; update position.
.01a301					_FPTOExit:
.01a301	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.01a302					FPFromString:
.01a302	48		pha				pha 								; push A
.01a303	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.01a305	c9 2e		cmp #$2e			cmp 	#"."
.01a307	f0 03		beq $01a30c			beq	 	_FPFIsDecimal
.01a309	4c 68 a3	jmp $01a368			jmp 	_FPFNotDecimal
.01a30c					_FPFIsDecimal:
.01a30c	c8		iny				iny 								; consume the decimal.
.01a30d	20 fc a0	jsr $01a0fc			jsr 	FPUToFloat 					; convert the integer to float.
.01a310	da		phx				phx 								; save X.
.01a311	5a		phy				phy 								; save decimal start position
.01a312	e8		inx				inx
.01a313	e8		inx				inx
.01a314	e8		inx				inx
.01a315	e8		inx				inx
.01a316	e8		inx				inx
.01a317	e8		inx				inx
.01a318	20 89 9d	jsr $019d89			jsr 	INTFromStringY 				; get the part after the DP.
.01a31b	20 fc a0	jsr $01a0fc			jsr 	FPUToFloat 					; convert that to a float.
.01a31e	68		pla				pla 								; calculate - chars consumed.
.01a31f	8c 9c 03	sty $039c			sty 	ExpTemp
.01a322	38		sec				sec
.01a323	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; this is the shift amount
.01a326	20 ef a1	jsr $01a1ef			jsr 	FPUScale10A 				; scale it by 10^AC
.01a329	fa		plx				plx 								; restore original X
.01a32a	20 1c 9e	jsr $019e1c			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.01a32d	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.01a32f	c9 45		cmp #$45			cmp 	#"E"
.01a331	f0 04		beq $01a337			beq 	_FPFExponent
.01a333	c9 65		cmp #$65			cmp 	#"e"
.01a335	d0 31		bne $01a368			bne 	_FPFNotDecimal 				; no, then exit normally.
.01a337					_FPFExponent:
.01a337	c8		iny				iny 								; skip over E symbol.
.01a338	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.01a33a	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.01a33c	d0 01		bne $01a33f			bne 	_FPFGotSign
.01a33e	c8		iny				iny 								; if it was - skip over it.
.01a33f					_FPFGotSign:
.01a33f	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.01a340	da		phx				phx
.01a341	e8		inx				inx
.01a342	e8		inx				inx
.01a343	e8		inx				inx
.01a344	e8		inx				inx
.01a345	e8		inx				inx
.01a346	e8		inx				inx
.01a347	20 89 9d	jsr $019d89			jsr 	INTFromStringY 				; get the exponent
.01a34a	fa		plx				plx 								; restore X.
.01a34b	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.01a34d	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.01a34f	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.01a351	d0 17		bne $01a36a			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.01a353	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.01a355	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.01a357	b0 11		bcs $01a36a			bcs 	_FPFXOverflow
.01a359	68		pla				pla 								; get direction
.01a35a	d0 07		bne $01a363			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.01a35c	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.01a35e	49 ff		eor #$ff			eor 	#$FF
.01a360	1a		inc a				inc 	a
.01a361	95 86		sta $86,x			sta 	XS2_Mantissa+0,x
.01a363					_FPFXScale:
.01a363	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.01a365	20 ef a1	jsr $01a1ef			jsr 	FPUScale10A 				; scale by the exponent.
.01a368					_FPFNotDecimal:
.01a368	68		pla				pla
.01a369	60		rts				rts
.01a36a					_FPFXOverflow:
.01a36a	20 57 85	jsr $018557			jsr 	ERR_Handler
>01a36d	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>01a375	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.01a37c					Unary_Rnd:
.01a37c	20 18 91	jsr $019118			jsr 	EvaluateNumberX 			; get value
.01a37f	20 4c 97	jsr $01974c			jsr 	CheckNextRParen 			; check right bracket.
.01a382	20 96 93	jsr $019396			jsr 	GetSignCurrent 				; get sign -1,0,1.
.01a385	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.01a387	30 10		bmi $01a399			bmi 	_URSetSeed
.01a389	f0 28		beq $01a3b3			beq 	_URMakeRandom 				; if zero return same number.
.01a38b	da		phx				phx
.01a38c	a2 00		ldx #$00			ldx 	#0
.01a38e	20 ea a3	jsr $01a3ea			jsr 	Random16
.01a391	a2 02		ldx #$02			ldx 	#2
.01a393	20 ea a3	jsr $01a3ea			jsr 	Random16
.01a396	fa		plx				plx
.01a397	80 1a		bra $01a3b3			bra 	_URMakeRandom
.01a399					_URSetSeed:
.01a399	20 fc a0	jsr $01a0fc			jsr 	FPUToFloat 					; make it a float to twiddle it.
.01a39c	b5 80		lda $80,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.01a39e	8d a3 03	sta $03a3			sta 	RandomSeed+0
.01a3a1	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.01a3a3	8d a4 03	sta $03a4			sta 	RandomSeed+1
.01a3a6	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.01a3a8	8d a5 03	sta $03a5			sta 	RandomSeed+2
.01a3ab	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.01a3ad	0a		asl a				asl 	a
.01a3ae	49 db		eor #$db			eor 	#$DB
.01a3b0	8d a6 03	sta $03a6			sta 	RandomSeed+3
.01a3b3					_URMakeRandom:
.01a3b3	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; check if seed is zero.
.01a3b6	0d a4 03	ora $03a4			ora 	RandomSeed+1
.01a3b9	0d a5 03	ora $03a5			ora 	RandomSeed+2
.01a3bc	0d a6 03	ora $03a6			ora 	RandomSeed+3
.01a3bf	d0 0a		bne $01a3cb			bne 	_URNotZero
.01a3c1	a9 47		lda #$47			lda 	#$47
.01a3c3	8d a4 03	sta $03a4			sta 	RandomSeed+1				; if it is, make it non zero.
.01a3c6	a9 3d		lda #$3d			lda 	#$3D
.01a3c8	8d a6 03	sta $03a6			sta 	RandomSeed+3
.01a3cb					_URNotZero:
.01a3cb	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; copy seed into mantissa.
.01a3ce	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a3d0	ad a4 03	lda $03a4			lda 	RandomSeed+1
.01a3d3	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a3d5	ad a5 03	lda $03a5			lda 	RandomSeed+2
.01a3d8	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a3da	ad a6 03	lda $03a6			lda 	RandomSeed+3
.01a3dd	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a3df	a9 00		lda #$00			lda 	#$00 						; set type to float.
.01a3e1	95 85		sta $85,x			sta 	XS_Type,x
.01a3e3	a9 80		lda #$80			lda 	#$80
.01a3e5	95 84		sta $84,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.01a3e7	4c 29 a1	jmp $01a129			jmp 	FPUNormalise
.01a3ea					Random16:
.01a3ea	5e a4 03	lsr $03a4,x			lsr 	RandomSeed+1,x				; shift seed right
.01a3ed	7e a3 03	ror $03a3,x			ror 	RandomSeed,x
.01a3f0	90 08		bcc $01a3fa			bcc 	_R16_NoXor
.01a3f2	bd a4 03	lda $03a4,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.01a3f5	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.01a3f7	9d a4 03	sta $03a4,x			sta 	RandomSeed+1,x
.01a3fa					_R16_NoXor:
.01a3fa	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.01a3fb					Unary_Int:
.01a3fb	20 18 91	jsr $019118			jsr 	EvaluateNumberX 			; get value
.01a3fe	20 4c 97	jsr $01974c			jsr 	CheckNextRParen 			; check right bracket.
.01a401	4c 48 a1	jmp $01a148			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Return to file: basic.asm

>01a404	02						.byte 	2
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 c0						.word 	StartROM
>fffe	19 c0					.word TIM_BreakHandler

;******  End of listing
