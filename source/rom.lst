
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Wed Aug 28 20:39:46 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="65816"				cpu = "65816"
="em65816"				hardware = "em65816"
=1					exitonend = 1
=0					autorun = 0
=0					loadtest = 0
=1					hasfloat = 1
=1					hasinteger = 1
=253					maxstring = 253

;******  Processing file: modules/float/fpmacros.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/em65816/src_em65816.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stackmarkers.inc

=5					SourcePosSize   =   5 							; Source position stack space needed.
=0					SMark_Gosub 	= 	0 							; 0 is GOSUB/RETURN
=1					SMark_Repeat 	= 	1 							; 1 is REPEAT/UNTIL.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0020					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0022					zVarDataPtr: .word ? 						; position of variable data.
>0024					zVarType: 	.byte ? 						; type of data (token)
>0025					zNullString:.byte ? 						; represents a NULL string.
>0026					zBasicSP:	.word ? 						; stack pointer
>0080					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>0084					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>0085					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=134					XS2_Mantissa = XS_Mantissa+XS_Size
=138					XS2_Exponent = XS_Exponent+XS_Size
=139					XS2_Type = XS_Type+XS_Size
=140					XS3_Mantissa = XS_Mantissa+XS_Size*2
=144					XS3_Exponent = XS_Exponent+XS_Size*2
=145					XS3_Type = XS_Type+XS_Size*2
>0300					StringPtr:	.word ? 						; Top of free memory (for string allocation)
>0302					VarMemPtr: 	.word ?							; Bottom of free memory (for variables)
>0304					endOfProgram: .word ? 						; End of Program Memory.
>0306					UserVector .fill 4 							; USR(x) calls this.
>030a					LocalVector .fill 4 						; Indirect calls call this.
>030e					NumBufX 	.byte 	?						; buffer index position
>030f					Num_Buffer	.fill 	32 						; buffer for numeric conversions
=6					HashTableCount = 6 							; there are 6 hash tables, in token order.
=8					HashTableSize = 8 							; each hash table as 8 links.
.032f					HashTableBase:
>032f								.fill	HashTableCount * HashTableSize * 2
.038f					HashTableEnd:
=$30f					Var_Buffer 	= Num_Buffer 					; buffer for variable name (same space)
>038f					Var_Type    .byte ? 						; type of variable (as a type token)
>0390					Var_Hash 	.byte ? 						; hash of identifier name.
>0391					Var_Length 	.byte ? 						; length of variable name
>0392					Var_HashAddress .byte ?						; low byte of hash table entry.
>0393					Var_DataSize .byte ?						; size of one element.
>0394					NumSuppress	.byte 	?						; leading zero suppression flag
>0395					NumConvCount .byte 	? 						; count for conversions.
>0396					ExpTemp:	.byte ?							; Working temp for exponents.
>0397					ExpCount:	.byte ? 						; Count of decimal exponents.
>0398					SignCount:	.byte ?							; Integer Divide Sign Counts.
>0399					TempStringWriteIndex: .byte ? 				; Write offset.
>039a					ValSign: 	.byte ? 						; sign flag for val()
>039b					SliceStart:	.byte ? 						; string slice parts
>039c					SliceCount:	.byte ?
>039d					RandomSeed:	.dword ? 						; Random seed.
=3					ArrayMaxDim = 3 							; number of dimensions.
>03a1					ArrayDef:	.fill (ArrayMaxDim+1)*2 		; dimensions for auto-creation
>03a9					UsrArrayDef:.fill (ArrayMaxDim+1)*2 		; dimensions created in DIM
>03b1					UsrArrayIdx:.byte ? 						; index into UsrArrayDef
>03b2					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>03b4					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>03b6					Tim_SR:		.byte ? 						; Processor Status
>03b7					Tim_A:		.byte ? 						; Processor Registers
>03b8					Tim_X:		.byte ?
>03b9					Tim_Y:		.byte ?
>03ba					Tim_Z:		.byte ?
>03bb					Tim_SP:		.word ?							; Stack Pointer (just in cases)
>0400					BasicStack:	.fill 	256 					; and occupy whole pages.
.0500					EndBasicStack:
>0500					IFT_XCursor:.byte ?							; current logical position on screen
>0501					IFT_YCursor:.byte ?
>0502					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0566					IFT_LineBuffer: .fill 100 					; line input buffer.

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/em65816.asm

=$7f00					HighMemory = $7F00
=$2000					VariableMemory = $2000
.1000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testcode.src

>1000	12 02 00 18 bb 84 40 c0			.byte	$12,$02,$00,$18,$bb,$84,$40,$c0
>1008	d6 fe 08 53 74 61 72 74			.byte	$d6,$fe,$08,$53,$74,$61,$72,$74
>1010	2e 00 0a 03 00 91 c0 19			.byte	$2e,$00,$0a,$03,$00,$91,$c0,$19
>1018	bb 84 40 00 1b 04 00 91			.byte	$bb,$84,$40,$00,$1b,$04,$00,$91
>1020	c0 19 bb 84 19 bb 8a 41			.byte	$c0,$19,$bb,$84,$19,$bb,$8a,$41
>1028	c0 d6 18 bb c1 19 bb c1			.byte	$c0,$d6,$18,$bb,$c1,$19,$bb,$c1
>1030	c0 96 19 bb 84 43 00 14			.byte	$c0,$96,$19,$bb,$84,$43,$00,$14
>1038	05 00 d6 c0 18 bb 84 18			.byte	$05,$00,$d6,$c0,$18,$bb,$84,$18
>1040	bb 8a 41 c0 96 18 bb 84			.byte	$bb,$8a,$41,$c0,$96,$18,$bb,$84
>1048	4f 68 00 0b 06 00 d6 fe			.byte	$4f,$68,$00,$0b,$06,$00,$d6,$fe
>1050	06 45 6e 64 2e 00 05 07			.byte	$06,$45,$6e,$64,$2e,$00,$05,$07
>1058	00 c4 00 00				.byte	$00,$c4,$00,$00

;******  Return to file: modules/hardware/em65816.asm

.c000					StartROM:
.c000	18		clc				clc
.c001	fb		xce				xce
.c002	c2 30		rep #$30			rep 	#$30
.c004	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.c007	1b		tcs				tcs
.c008	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.c00b	e2 30		sep #$30			sep 	#$30
.c00d	c2 30		rep #$30			rep 	#$30						; clear AXY in 16 bit.
.c00f	a9 00		lda #$00			lda 	#$0000
.c011	aa		tax				tax
.c012	a8		tay				tay
.c013	e2 30		sep #$30			sep 	#$30
.c015	5c 40 87 01	jmp $018740		jmp BASIC_Start
.c019					TIM_BreakHandler:
.c019	5c 76 83 01	jmp $018376			jmp 	TIM_BreakVector

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.018000					IFT_ClearScreen:
.018000	48		pha				pha
.018001	da		phx				phx
.018002	5a		phy				phy
.018003	20 a9 81	jsr $0181a9			jsr 	IF_Home 					; home cursor
.018006	a2 20		ldx #$20			ldx 	#IF_Height 					; this many lines.
.018008					_IFT_CS0:
.018008	a0 40		ldy #$40			ldy 	#IF_Width 					; this many chars/line
.01800a					_IFT_CS1:
.01800a	a9 20		lda #$20			lda 	#' '						; clear line.
.01800c	20 d5 81	jsr $0181d5			jsr 	IF_Write
.01800f	88		dey				dey
.018010	d0 f8		bne $01800a			bne 	_IFT_CS1
.018012	20 bc 81	jsr $0181bc			jsr 	IF_NewLine 					; next line down
.018015	ca		dex				dex
.018016	d0 f0		bne $018008			bne 	_IFT_CS0
.018018	7a		ply				ply
.018019	fa		plx				plx
.01801a	68		pla				pla
.01801b					IFT_HomeCursor:
.01801b	48		pha				pha
.01801c	20 a9 81	jsr $0181a9			jsr 	IF_Home
.01801f	a9 00		lda #$00			lda 	#0
.018021	8d 00 05	sta $0500			sta 	IFT_XCursor
.018024	8d 01 05	sta $0501			sta 	IFT_YCursor
.018027	68		pla				pla
.018028	60		rts				rts
.018029					IFT_UpLine:
.018029	48		pha				pha
.01802a	ad 01 05	lda $0501			lda  	IFT_YCursor 				; get Y
.01802d	3a		dec a				dec 	a 							; line above
.01802e	30 03		bmi $018033			bmi 	_IFTULExit 					; too far, abort
.018030	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos					; set to that line.
.018033					_IFTULExit:
.018033	68		pla				pla
.018034	60		rts				rts
.018035					IFT_PrintCharacter:
.018035	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.018037	f0 23		beq $01805c			beq 	IFT_NewLine
.018039	48		pha				pha
.01803a	20 74 80	jsr $018074			jsr 	IFT_UpperCase 				; make upper case
.01803d	20 d5 81	jsr $0181d5			jsr 	IF_Write 					; write out.
.018040	ee 00 05	inc $0500			inc 	IFT_XCursor 				; bump x cursor
.018043	ad 00 05	lda $0500			lda 	IFT_XCursor 				; reached RHS ?
.018046	c9 40		cmp #$40			cmp 	#IF_Width
.018048	d0 03		bne $01804d			bne 	_IFT_PCNotEOL
.01804a	20 5c 80	jsr $01805c			jsr 	IFT_NewLine 				; if so do new line.
.01804d					_IFT_PCNotEOL:
.01804d	68		pla				pla
.01804e	60		rts				rts
.01804f					IFT_Tab:
.01804f	a9 20		lda #$20			lda 	#" " 						; space
.018051	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018054	ad 00 05	lda $0500			lda 	IFT_XCursor 				; until x % 8 == 0
.018057	29 07		and #$07			and 	#7
.018059	d0 f4		bne $01804f			bne 	IFT_Tab
.01805b	60		rts				rts
.01805c					IFT_NewLine:
.01805c	48		pha				pha
.01805d	20 bc 81	jsr $0181bc			jsr 	IF_NewLine 					; new line on actual screen.
.018060	a9 00		lda #$00			lda 	#0 							; reset x position
.018062	8d 00 05	sta $0500			sta 	IFT_XCursor
.018065	ee 01 05	inc $0501			inc 	IFT_YCursor 				; move down.
.018068	ad 01 05	lda $0501			lda 	IFT_YCursor
.01806b	c9 20		cmp #$20			cmp 	#IF_Height 					; reached bottom.
.01806d	d0 03		bne $018072			bne 	_IFT_NL_NotEOS
.01806f	20 7f 80	jsr $01807f			jsr 	IFT_Scroll 					; scroll screen up.
.018072					_IFT_NL_NotEOS:
.018072	68		pla				pla
.018073	60		rts				rts
.018074					IFT_UpperCase:
.018074	c9 61		cmp #$61			cmp 	#"a"
.018076	90 06		bcc $01807e			bcc 	_IFT_UCExit
.018078	c9 7b		cmp #$7b			cmp 	#"z"+1
.01807a	b0 02		bcs $01807e			bcs 	_IFT_UCExit
.01807c	49 20		eor #$20			eor 	#$20
.01807e					_IFT_UCExit:
.01807e	60		rts				rts
.01807f					IFT_Scroll:
.01807f	48		pha				pha 								; save AXY
.018080	da		phx				phx
.018081	5a		phy				phy
.018082	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.018084					_IFT_SLoop:
.018084	20 a4 80	jsr $0180a4			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.018087	e8		inx				inx
.018088	e0 1f		cpx #$1f			cpx 	#IF_Height-1				; do whole screen
.01808a	d0 f8		bne $018084			bne 	_IFT_SLoop
.01808c	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.01808e	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.018091	a2 40		ldx #$40			ldx 	#IF_Width 					; blank line
.018093					_IFT_SBlank:
.018093	a9 20		lda #$20			lda 	#32
.018095	20 d5 81	jsr $0181d5			jsr 	IF_Write
.018098	ca		dex				dex
.018099	d0 f8		bne $018093			bne 	_IFT_SBlank
.01809b	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.01809d	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.0180a0	7a		ply				ply
.0180a1	fa		plx				plx
.0180a2	68		pla				pla
.0180a3	60		rts				rts
.0180a4					_IFT_ScrollLine:
.0180a4	da		phx				phx
.0180a5	da		phx				phx
.0180a6	8a		txa				txa 								; copy line into buffer.
.0180a7	1a		inc a				inc 	a 							; next line down.
.0180a8	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.0180ab	a2 00		ldx #$00			ldx 	#0
.0180ad					_IFTScrollCopy1:
.0180ad	20 cc 81	jsr $0181cc			jsr 	IF_Read
.0180b0	9d 02 05	sta $0502,x			sta 	IFT_Buffer,x
.0180b3	e8		inx				inx
.0180b4	e0 40		cpx #$40			cpx 	#IF_Width
.0180b6	d0 f5		bne $0180ad			bne 	_IFTScrollCopy1
.0180b8	68		pla				pla
.0180b9	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.0180bc	a2 00		ldx #$00			ldx 	#0
.0180be					_IFTScrollCopy2:
.0180be	bd 02 05	lda $0502,x			lda 	IFT_Buffer,x
.0180c1	20 d5 81	jsr $0181d5			jsr 	IF_Write
.0180c4	e8		inx				inx
.0180c5	e0 40		cpx #$40			cpx 	#IF_Width
.0180c7	d0 f5		bne $0180be			bne 	_IFTScrollCopy2
.0180c9	fa		plx				plx
.0180ca	60		rts				rts
.0180cb					IFT_SetYPos:
.0180cb	48		pha				pha
.0180cc	da		phx				phx
.0180cd	aa		tax				tax
.0180ce	20 1b 80	jsr $01801b			jsr 	IFT_HomeCursor
.0180d1	e0 00		cpx #$00			cpx 	#0
.0180d3	f0 09		beq $0180de			beq 	_IFT_MOAExit
.0180d5					_IFT_MOALoop:
.0180d5	20 bc 81	jsr $0181bc			jsr 	IF_NewLine
.0180d8	ee 01 05	inc $0501			inc 	IFT_YCursor
.0180db	ca		dex				dex
.0180dc	d0 f7		bne $0180d5			bne		_IFT_MOALoop
.0180de					_IFT_MOAExit:
.0180de	fa		plx				plx
.0180df	68		pla				pla
.0180e0	60		rts				rts
.0180e1					IFT_GetKeyCursor:
.0180e1	20 e9 80	jsr $0180e9			jsr 	_IFT_FlipCursor 			; reverse current
.0180e4					_IFT_GKCWait:
.0180e4	20 e6 81	jsr $0181e6			jsr 	IF_GetKey 					; get key
.0180e7	f0 fb		beq $0180e4			beq 	_IFT_GKCWait
.0180e9					_IFT_FlipCursor:
.0180e9	48		pha				pha 								; save
.0180ea	20 cc 81	jsr $0181cc			jsr 	IF_Read 					; read
.0180ed	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.0180f0	49 80		eor #$80			eor 	#$80 						; reverse
.0180f2	20 d5 81	jsr $0181d5			jsr 	IF_Write 					; write
.0180f5	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.0180f8	68		pla				pla
.0180f9	60		rts				rts
.0180fa					IFT_ReadLine:
.0180fa	48		pha				pha
.0180fb					_IFT_RLLoop:
.0180fb	20 e1 80	jsr $0180e1			jsr 	IFT_GetKeyCursor 			; get keystroke
.0180fe	c9 0d		cmp #$0d			cmp 	#13							; return
.018100	f0 7d		beq $01817f			beq 	_IFT_RLExit
.018102	c9 20		cmp #$20			cmp 	#32 						; control character
.018104	90 05		bcc $01810b			bcc 	_IFT_Control
.018106	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018109	80 f0		bra $0180fb			bra 	_IFT_RLLoop
.01810b					_IFT_Control:
.01810b	c9 01		cmp #$01			cmp 	#"A"-64
.01810d	f0 26		beq $018135			beq 	_IFT_Left
.01810f	c9 04		cmp #$04			cmp 	#"D"-64
.018111	f0 2e		beq $018141			beq 	_IFT_Right
.018113	c9 17		cmp #$17			cmp 	#"W"-64
.018115	f0 36		beq $01814d			beq 	_IFT_Up
.018117	c9 13		cmp #$13			cmp 	#"S"-64
.018119	f0 3e		beq $018159			beq 	_IFT_Down
.01811b	c9 08		cmp #$08			cmp 	#"H"-64
.01811d	f0 09		beq $018128			beq 	_IFT_Backspace
.01811f	c9 1a		cmp #$1a			cmp 	#"Z"-64
.018121	d0 d8		bne $0180fb			bne 	_IFT_RLLoop
.018123	20 00 80	jsr $018000			jsr 	IFT_ClearScreen				; clear CTL-Z
.018126	80 d3		bra $0180fb			bra 	_IFT_RLLoop
.018128					_IFT_Backspace:
.018128	ad 00 05	lda $0500			lda 	IFT_XCursor 				; check not start of line.
.01812b	f0 ce		beq $0180fb			beq 	_IFT_RLLoop
.01812d	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.018130	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.018132	20 d5 81	jsr $0181d5			jsr 	IF_Write
.018135					_IFT_Left:
.018135	ce 00 05	dec $0500			dec 	IFT_XCursor 				; left CTL-W
.018138	10 29		bpl $018163			bpl 	_IFT_Reposition
.01813a	a9 3f		lda #$3f			lda 	#IF_Width-1
.01813c					_IFT_SetX:
.01813c	8d 00 05	sta $0500			sta 	IFT_XCursor
.01813f	80 22		bra $018163			bra 	_IFT_Reposition
.018141					_IFT_Right:
.018141	ee 00 05	inc $0500			inc 	IFT_XCursor
.018144	ad 00 05	lda $0500			lda 	IFT_XCursor
.018147	49 40		eor #$40			eor 	#IF_Width
.018149	f0 f1		beq $01813c			beq 	_IFT_SetX
.01814b	80 16		bra $018163			bra 	_IFT_Reposition
.01814d					_IFT_Up:
.01814d	ce 01 05	dec $0501			dec 	IFT_YCursor
.018150	10 11		bpl $018163			bpl 	_IFT_Reposition
.018152	a9 1f		lda #$1f			lda 	#IF_Height-1
.018154					_IFT_SetY:
.018154	8d 01 05	sta $0501			sta 	IFT_YCursor
.018157	80 0a		bra $018163			bra 	_IFT_Reposition
.018159					_IFT_Down:
.018159	ee 01 05	inc $0501			inc 	IFT_YCursor
.01815c	ad 01 05	lda $0501			lda 	IFT_YCursor
.01815f	49 20		eor #$20			eor 	#IF_Height
.018161	f0 f1		beq $018154			beq 	_IFT_SetY
.018163					_IFT_Reposition:
.018163	ad 00 05	lda $0500			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.018166	48		pha				pha
.018167	ad 01 05	lda $0501			lda 	IFT_YCursor
.01816a	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.01816d	68		pla				pla
.01816e	aa		tax				tax
.01816f	e0 00		cpx #$00			cpx 	#0
.018171	f0 88		beq $0180fb			beq 	_IFT_RLLoop
.018173					_IFT_MoveRight:
.018173	20 cc 81	jsr $0181cc			jsr 	IF_Read
.018176	ee 00 05	inc $0500			inc 	IFT_XCursor
.018179	ca		dex				dex
.01817a	d0 f7		bne $018173			bne 	_IFT_MoveRight
.01817c	4c fb 80	jmp $0180fb			jmp 	_IFT_RLLoop
.01817f					_IFT_RLExit:
.01817f	ad 01 05	lda $0501			lda 	IFT_YCursor 				; go to start of line.
.018182	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.018185	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.018187					_IFT_RLRead:
.018187	20 cc 81	jsr $0181cc			jsr 	IF_Read
.01818a	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.01818d	e8		inx				inx
.01818e	e0 40		cpx #$40			cpx 	#IF_Width
.018190	d0 f5		bne $018187			bne 	_IFT_RLRead
.018192					_IFT_RL_Trim:
.018192	ca		dex				dex 	 							; previous char
.018193	30 07		bmi $01819c			bmi 	_IFT_Found 					; gone too far
.018195	bd 66 05	lda $0566,x			lda 	IFT_LineBuffer,x			; go back if space
.018198	c9 20		cmp #$20			cmp 	#" "
.01819a	f0 f6		beq $018192			beq 	_IFT_RL_Trim
.01819c					_IFT_Found:
.01819c	e8		inx				inx 								; forward to non-space
.01819d	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.01819f	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.0181a2	68		pla				pla
.0181a3	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.0181a5	a0 05		ldy #$05			ldy 	#IFT_LineBuffer >> 8
.0181a7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_em65816.asm

=64					IF_Width 	= 64 							; characters across
=32					IF_Height 	= 32 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line.
=8					IF_XPos 	= 8 							; current position, horizontal.
=$f0000					IF_Screen = $F0000							; 2k screen RAM here
=$f8010					IF_PKeyboard = $F8010						; Keyboard port.
=$f8000					IF_PBreak = $F8000 							; Break key.
.0181a8					IF_Reset:
.0181a8	60		rts				rts
.0181a9					IF_Home:
.0181a9	48		pha				pha
.0181aa	64 08		stz $08				stz 	IF_XPos 					; zero X position
.0181ac	a9 00		lda #$00			lda 	#IF_Screen & $FF 			; set r/w pos.
.0181ae	85 04		sta $04				sta 	IF_Pos
.0181b0	a9 00		lda #$00			lda 	#(IF_Screen >> 8) & $FF
.0181b2	85 05		sta $05				sta 	IF_Pos+1
.0181b4	a9 0f		lda #$0f			lda 	#IF_Screen >> 16
.0181b6	85 06		sta $06				sta 	IF_Pos+2
.0181b8	64 07		stz $07				stz 	IF_Pos+3
.0181ba	68		pla				pla
.0181bb	60		rts				rts
.0181bc					IF_NewLine:
.0181bc	48		pha				pha
.0181bd	64 08		stz $08				stz 	IF_XPos						; back to start of line
.0181bf	18		clc				clc 								; down one line
.0181c0	a5 04		lda $04				lda 	IF_Pos
.0181c2	69 40		adc #$40			adc 	#64
.0181c4	85 04		sta $04				sta 	IF_Pos
.0181c6	90 02		bcc $0181ca			bcc 	_IF_NoCarry 				; carry through.
.0181c8	e6 05		inc $05				inc 	IF_Pos+1
.0181ca					_IF_NoCarry:
.0181ca	68		pla				pla
.0181cb	60		rts				rts
.0181cc					IF_Read:
.0181cc	5a		phy				phy 								; save current Y
.0181cd	a4 08		ldy $08				ldy 	IF_XPos 					; read character at current position
.0181cf	b7 04		lda [$04],y			lda 	[IF_Pos],y
.0181d1	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181d3	7a		ply				ply									; restore Y
.0181d4	60		rts				rts
.0181d5					IF_Write:
.0181d5	5a		phy				phy 								; save current Y
.0181d6	a4 08		ldy $08				ldy 	IF_XPos 					; write character at current position
.0181d8	97 04		sta [$04],y			sta 	[IF_Pos],y
.0181da	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181dc	7a		ply				ply									; restore Y
.0181dd	60		rts				rts
.0181de					IF_LeftOne:
.0181de	c6 08		dec $08				dec 	IF_XPos
.0181e0	60		rts				rts
.0181e1					IF_CheckBreak:
.0181e1	af 00 80 0f	lda $0f8000			lda 	IF_PBreak					; non-zero if Ctrl+C pressed.
.0181e5	60		rts				rts
.0181e6					IF_GetKey:
.0181e6	af 10 80 0f	lda $0f8010			lda 	IF_PKeyboard				; read keyboard
.0181ea	f0 08		beq $0181f4			beq		_IFGK_NoKey 				; skip if zero,no key pressed
.0181ec	48		pha				pha 								; key pressed, clear queue.
.0181ed	a9 00		lda #$00			lda 	#0
.0181ef	8f 10 80 0f	sta $0f8010			sta 	IF_PKeyboard
.0181f3	68		pla				pla
.0181f4					_IFGK_NoKey:
.0181f4	09 00		ora #$00			ora 	#0							; set Z flag appropriately.
.0181f6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.0181f7					TIM_Error:
.0181f7	20 29 80	jsr $018029			jsr 	IFT_UpLine 					; go up one line.
.0181fa	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.0181fc	80 02		bra $018200			bra 	TIM_ShowPrompt
.0181fe					TIM_NewCommand:
.0181fe	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.018200					TIM_ShowPrompt:
.018200	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.018203	20 fa 80	jsr $0180fa			jsr 	IFT_ReadLine	 			; get character, go to next line
.018206	20 5c 80	jsr $01805c			jsr 	IFT_NewLine					; go to next line.
.018209	86 10		stx $10				stx 	zTemp1 						; save line read address
.01820b	84 11		sty $11				sty 	zTemp1+1
.01820d	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.01820f	b1 10		lda ($10),y			lda 	(zTemp1),y
.018211	c9 3f		cmp #$3f			cmp 	#"?"
.018213	f0 04		beq $018219			beq 	TIM_SkipFirst
.018215	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.018217	d0 01		bne $01821a			bne 	TIM_NotDot
.018219					TIM_SkipFirst:
.018219	c8		iny				iny
.01821a					TIM_NotDot:
.01821a	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.01821c	c9 52		cmp #$52			cmp 	#"R"						; show registers
.01821e	f0 6b		beq $01828b			beq 	TIM_ShowRegisters
.018220	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.018222	f0 12		beq $018236			beq 	TIM_ShowMemory
.018224	c9 47		cmp #$47			cmp 	#"G"						; execute
.018226	f0 49		beq $018271			beq 	TIM_Execute
.018228	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.01822a	f0 07		beq $018233			beq 	TIM_GoLoadMemory
.01822c	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.01822e	d0 c7		bne $0181f7			bne 	TIM_Error
.018230	4c af 83	jmp $0183af			jmp 	TIM_UpdateRegisters
.018233					TIM_GoLoadMemory:
.018233	4c df 83	jmp $0183df			jmp 	TIM_LoadMemory
.018236					TIM_ShowMemory:
.018236	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.018239	b0 bc		bcs $0181f7			bcs 	TIM_Error
.01823b	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.01823d	85 12		sta $12				sta 	zTemp2
.01823f	a5 15		lda $15				lda 	zTemp3+1
.018241	85 13		sta $13				sta 	zTemp2+1
.018243	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.018246	90 08		bcc $018250			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.018248	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.01824a	85 14		sta $14				sta 	zTemp3
.01824c	a5 13		lda $13				lda 	zTemp2+1
.01824e	85 15		sta $15				sta 	zTemp3+1
.018250					_TIMSM_Start:
.018250	20 03 83	jsr $018303			jsr 	TIM_WriteLine 				; write one line of hex out
.018253	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.018255	18		clc				clc
.018256	69 10		adc #$10			adc 	#16
.018258	85 12		sta $12				sta 	zTemp2
.01825a	90 02		bcc $01825e			bcc 	_TIMSM_NoCarry
.01825c	e6 13		inc $13				inc 	zTemp2+1
.01825e					_TIMSM_NoCarry:
.01825e	20 e1 81	jsr $0181e1			jsr 	IF_CheckBreak 				; check CTL+C
.018261	d0 0b		bne $01826e			bne 	_TIMSM_Ends 				; if pressed break out.
.018263	38		sec				sec 								; check past the end address in zTemp3
.018264	a5 14		lda $14				lda 	zTemp3
.018266	e5 12		sbc $12				sbc 	zTemp2
.018268	a5 15		lda $15				lda 	zTemp3+1
.01826a	e5 13		sbc $13				sbc 	zTemp2+1
.01826c	10 e2		bpl $018250			bpl 	_TIMSM_Start
.01826e					_TIMSM_Ends:
.01826e	4c fe 81	jmp $0181fe			jmp 	TIM_NewCommand
.018271					TIM_Execute:
.018271	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; get the execute address
.018274	b0 81		bcs $0181f7			bcs 	TIM_Error 					; not legitimate
.018276	ae bb 03	ldx $03bb			ldx 	TIM_SP 						; set up SP
.018279	9a		txs				txs
.01827a	ad b6 03	lda $03b6			lda 	TIM_SR 						; Status for PLP
.01827d	48		pha				pha
.01827e	ad b7 03	lda $03b7			lda 	TIM_A 						; restore AXYZ
.018281	ae b8 03	ldx $03b8			ldx 	TIM_X
.018284	ac b9 03	ldy $03b9			ldy 	TIM_Y
.018287	28		plp				plp 								; and PS Byte.
.018288	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.01828b					TIM_Start:
.01828b					TIM_ShowRegisters:
.01828b	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.01828e	8d b5 03	sta $03b5			sta 	TIM_IRQ+1
.018291	ad ff ff	lda $ffff			lda 	$FFFF
.018294	8d b4 03	sta $03b4			sta 	TIM_IRQ
.018297	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.018299					_TIMSR_Text:
.018299	bf ca 82 01	lda $0182ca,x			lda 	_TIMSR_Label,x
.01829d	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182a0	e8		inx				inx
.0182a1	e0 20		cpx #$20			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.0182a3	d0 f4		bne $018299			bne 	_TIMSR_Text
.0182a5	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.0182a7					_TIMSR_Skip:
.0182a7	e8		inx				inx
.0182a8					_TIMSR_LoopSpace:
.0182a8	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.0182aa	b0 04		bcs $0182b0			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.0182ac	8a		txa				txa
.0182ad	4a		lsr a				lsr 	a
.0182ae	b0 05		bcs $0182b5			bcs 	_TIMSR_NoSpace
.0182b0					_TIMSR_Space:
.0182b0	a9 20		lda #$20			lda 	#" "
.0182b2	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182b5					_TIMSR_NoSpace:
.0182b5	bd b2 03	lda $03b2,x			lda 	TIM_PC,x 					; output hex value.
.0182b8	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.0182bb	e8		inx				inx
.0182bc	e0 08		cpx #$08			cpx 	#TIM_Z-TIM_PC
.0182be	f0 e7		beq $0182a7			beq 	_TIMSR_Skip
.0182c0	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.0182c2	d0 e4		bne $0182a8			bne 	_TimSR_LoopSpace
.0182c4	20 5c 80	jsr $01805c			jsr 	IFT_NewLine 				; new line
.0182c7	4c fe 81	jmp $0181fe			jmp	 	TIM_NewCommand 				; new command.
.0182ca					_TIMSR_Label:
>0182ca	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>0182d2	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>0182e2	52
>0182e3	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.0182ea					_TIMSR_LabelEnd:
.0182ea					TIM_WriteHex:
.0182ea	48		pha				pha 								; save A
.0182eb	4a		lsr a				lsr 	a 							; shift MSB->LSB
.0182ec	4a		lsr a				lsr 	a
.0182ed	4a		lsr a				lsr 	a
.0182ee	4a		lsr a				lsr 	a
.0182ef	20 f3 82	jsr $0182f3			jsr 	_TIMWH_Nibble 				; print MSB
.0182f2	68		pla				pla 								; restore and print LSB
.0182f3					_TIMWH_Nibble:
.0182f3	48		pha				pha
.0182f4	29 0f		and #$0f			and 	#15 						; mask out
.0182f6	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.0182f8	90 02		bcc $0182fc			bcc 	_TIMWHNoLetter
.0182fa	69 06		adc #$06			adc 	#6
.0182fc					_TIMWHNoLetter:
.0182fc	69 30		adc #$30			adc 	#48
.0182fe	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter 			; print it out.
.018301	68		pla				pla
.018302	60		rts				rts
.018303					TIM_WriteLine:
.018303	a9 2e		lda #$2e			lda 	#"." 						; prompt
.018305	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018308	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.01830a	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01830d	a5 13		lda $13				lda 	zTemp2+1 					; write address
.01830f	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.018312	a5 12		lda $12				lda 	zTemp2
.018314	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.018317	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.018319					_TIMWL_Loop:
.018319	a9 20		lda #$20			lda 	#" "
.01831b	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01831e	b1 12		lda ($12),y			lda 	(zTemp2),y
.018320	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.018323	c8		iny				iny
.018324	c0 10		cpy #$10			cpy 	#16
.018326	d0 f1		bne $018319			bne 	_TIMWL_Loop
.018328	4c 5c 80	jmp $01805c			jmp 	IFT_NewLine 				; new line and exit
.01832b					TIM_GetHex:
.01832b	c8		iny				iny
.01832c	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.01832e	c9 20		cmp #$20			cmp 	#32
.018330	f0 f9		beq $01832b			beq 	TIM_GetHex
.018332	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.018334	f0 f5		beq $01832b			beq 	TIM_GetHex
.018336	20 5f 83	jsr $01835f			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.018339	b0 23		bcs $01835e			bcs 	_TIMGH_Exit					; if first bad then exit now.
.01833b	a9 00		lda #$00			lda 	#0 							; zero result
.01833d	85 14		sta $14				sta 	zTemp3
.01833f	85 15		sta $15				sta 	zTemp3+1
.018341					_TIM_GHLoop:
.018341	20 5f 83	jsr $01835f			jsr 	TIM_GetHexCharacter 		; get next character
.018344	b0 17		bcs $01835d			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.018346	c8		iny				iny 								; skip over it.
.018347	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.018349	26 15		rol $15				rol 	zTemp3+1
.01834b	06 14		asl $14				asl 	zTemp3 						; now x 2
.01834d	26 15		rol $15				rol 	zTemp3+1
.01834f	06 14		asl $14				asl 	zTemp3						; now x 4
.018351	26 15		rol $15				rol 	zTemp3+1
.018353	06 14		asl $14				asl 	zTemp3 						; now x 8
.018355	26 15		rol $15				rol 	zTemp3+1
.018357	05 14		ora $14				ora 	zTemp3 						; OR result in
.018359	85 14		sta $14				sta 	zTemp3
.01835b	80 e4		bra $018341			bra 	_TIM_GHLoop 				; loop round again.
.01835d					_TIMGH_Okay:
.01835d	18		clc				clc
.01835e					_TIMGH_Exit:
.01835e	60		rts				rts
.01835f					TIM_GetHexCharacter:
.01835f	b1 10		lda ($10),y			lda 	(zTemp1),y
.018361	38		sec				sec
.018362	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.018364	90 0e		bcc $018374			bcc 	_TIM_GHCFail
.018366	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.018368	90 0b		bcc $018375			bcc 	_TIM_GHCExit
.01836a	c9 11		cmp #$11			cmp 	#65-48						; < A
.01836c	90 06		bcc $018374			bcc		_TIM_GHCFail
.01836e	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.018370	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.018372	90 01		bcc $018375			bcc		_TIM_GHCExit
.018374					_TIM_GHCFail:
.018374	38		sec				sec
.018375					_TIM_GHCExit:
.018375	60		rts				rts
.018376					TIM_BreakVector:
.018376	da		phx				phx									; save X/A on stack
.018377	48		pha				pha
.018378	ba		tsx				tsx 								; X points to S
.018379	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.01837c	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.01837e	d0 03		bne $018383			bne 	_TIMBreak					; if set, it's BRK
.018380	68		pla				pla 								; abandon routine.
.018381	fa		plx				plx
.018382	40		rti				rti
.018383					_TIMBreak:
.018383	68		pla				pla 								; save A X Y and maybe Z
.018384	8d b7 03	sta $03b7			sta 	TIM_A
.018387	fa		plx				plx
.018388	8e b8 03	stx $03b8			stx 	TIM_X
.01838b	8c b9 03	sty $03b9			sty 	TIM_Y
.01838e	68		pla				pla 								; get Status Register
.01838f	8d b6 03	sta $03b6			sta 	TIM_SR
.018392	68		pla				pla
.018393	8d b3 03	sta $03b3			sta 	TIM_PC+1 					; save calling address
.018396	68		pla				pla
.018397	8d b2 03	sta $03b2			sta 	TIM_PC 						; high byte
.01839a	ad b3 03	lda $03b3			lda 	TIM_PC+1 					; dec PC to point right.
.01839d	d0 03		bne $0183a2			bne 	_TIMDecrement 				; brk bumps it.
.01839f	ce b2 03	dec $03b2			dec 	TIM_PC
.0183a2					_TIMDecrement:
.0183a2	ce b3 03	dec $03b3			dec 	TIM_PC+1
.0183a5	ba		tsx				tsx 								; and copy SP
.0183a6	8e bb 03	stx $03bb			stx 	TIM_SP
.0183a9	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.0183ab	9a		txs				txs
.0183ac	4c 8b 82	jmp $01828b			jmp 	TIM_Start 					; and start up TIM monitor.
.0183af					TIM_UpdateRegisters:
.0183af	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; PC
.0183b2	b0 28		bcs $0183dc			bcs 	_TIMURFail
.0183b4	a5 14		lda $14				lda 	zTemp3
.0183b6	8d b3 03	sta $03b3			sta 	Tim_PC+1
.0183b9	a5 15		lda $15				lda 	zTemp3+1
.0183bb	8d b2 03	sta $03b2			sta 	Tim_PC
.0183be	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; ignore IRQ
.0183c1	b0 19		bcs $0183dc			bcs 	_TIMURFail
.0183c3	a2 00		ldx #$00			ldx 	#0
.0183c5					_TIM_URLoop:
.0183c5	e0 04		cpx #$04			cpx 	#Tim_Z-Tim_SR
.0183c7	d0 01		bne $0183ca			bne 	_TIM_1
.0183c9	e8		inx				inx
.0183ca					_TIM_1:
.0183ca	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; registers
.0183cd	b0 0d		bcs $0183dc			bcs 	_TIMURFail
.0183cf	a5 14		lda $14				lda 	zTemp3
.0183d1	9d b6 03	sta $03b6,x			sta 	Tim_SR,x
.0183d4	e8		inx				inx
.0183d5	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.0183d7	d0 ec		bne $0183c5			bne 	_TIM_URLoop
.0183d9	4c fe 81	jmp $0181fe			jmp 	TIM_NewCommand
.0183dc					_TIMURFail:
.0183dc	4c f7 81	jmp $0181f7			jmp 	TIM_Error
.0183df					TIM_LoadMemory:
.0183df	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; target address => zTemp2
.0183e2	a5 14		lda $14				lda 	zTemp3
.0183e4	85 12		sta $12				sta 	zTemp2
.0183e6	a5 15		lda $15				lda 	zTemp3+1
.0183e8	85 13		sta $13				sta 	zTemp2+1
.0183ea					_TIM_LMLoop:
.0183ea	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; next byte ?
.0183ed	b0 0e		bcs $0183fd			bcs 	_TIMLMDone 					; no more
.0183ef	a2 00		ldx #$00			ldx 	#0							; write out.
.0183f1	a5 14		lda $14				lda 	zTemp3
.0183f3	81 12		sta ($12,x)			sta 	(zTemp2,x)
.0183f5	e6 12		inc $12				inc 	zTemp2 						; bump address
.0183f7	d0 f1		bne $0183ea			bne 	_TIM_LMLoop
.0183f9	e6 13		inc $13				inc 	zTemp2+1
.0183fb	80 ed		bra $0183ea			bra 	_TIM_LMLoop
.0183fd					_TIMLMDone:
.0183fd	4c fe 81	jmp $0181fe			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stack.asm

.018400					StackReset:
.018400	48		pha				pha
.018401	5a		phy				phy
.018402	a9 00		lda #$00			lda 	#(BasicStack & $FF) 		; reset pointer
.018404	85 26		sta $26				sta 	zBasicSP
.018406	a9 04		lda #$04			lda 	#(BasicStack >> 8)
.018408	85 27		sta $27				sta 	zBasicSP+1
.01840a	a0 00		ldy #$00			ldy 	#0 							; reset stack top to $00 which cannot
.01840c	98		tya				tya 								; be a legal token.
.01840d	91 26		sta ($26),y			sta 	(zBasicSP),y
.01840f	7a		ply				ply
.018410	68		pla				pla
.018411	60		rts				rts
.018412					StackPushFrame:
.018412	48		pha				pha
.018413	5a		phy				phy
.018414	1a		inc a				inc 	a 							; one extra byte in frame, for the marker.
.018415	48		pha				pha 								; save it.
.018416	29 0f		and #$0f			and 	#$0F 						; lower 4 bits
.018418	18		clc				clc 								; add to Basic Stack
.018419	65 26		adc $26				adc 	zBasicSP
.01841b	85 26		sta $26				sta 	zBasicSP
.01841d	90 02		bcc $018421			bcc 	_SPFNoBump
.01841f	e6 27		inc $27				inc 	zBasicSP+1
.018421					_SPFNoBump:
.018421	a0 00		ldy #$00			ldy 	#0
.018423	68		pla				pla
.018424	91 26		sta ($26),y			sta 	(zBasicSP),y
.018426	7a		ply				ply
.018427	68		pla				pla
.018428	60		rts				rts
.018429					StackPopFrame:
.018429	48		pha				pha
.01842a	5a		phy				phy
.01842b	a0 00		ldy #$00			ldy 	#0 							; compare with top of stack using EOR
.01842d	51 26		eor ($26),y			eor 	(zBasicSP),y
.01842f	29 f0		and #$f0			and 	#$F0 						; top 4 bits zero, match
.018431	d0 12		bne $018445			bne 	_SPFError 					; mixed structures
.018433	b1 26		lda ($26),y			lda 	(zBasicSP),y 				; get size from byte
.018435	29 0f		and #$0f			and 	#$0F
.018437	49 ff		eor #$ff			eor 	#$FF						; 2's complement
.018439	38		sec				sec
.01843a	65 26		adc $26				adc 	zBasicSP
.01843c	85 26		sta $26				sta 	zBasicSP
.01843e	b0 02		bcs $018442			bcs 	_SPFNoBump
.018440	c6 27		dec $27				dec 	zBasicSP+1
.018442					_SPFNoBump:
.018442	7a		ply				ply
.018443	68		pla				pla
.018444	60		rts				rts
.018445					_SPFError:
.018445	20 c1 84	jsr $0184c1			jsr ERR_Handler
>018448	4d 69 78 65 64 20 53 74			.text "Mixed Structures",0
>018450	72 75 63 74 75 72 65 73 00
.018459					StackSavePosition:
.018459	98		tya				tya
.01845a	5a		phy				phy
.01845b	a0 05		ldy #$05			ldy 	#5
.01845d	91 26		sta ($26),y			sta 	(zBasicSP),y
.01845f	a0 01		ldy #$01			ldy 	#1
.018461	a5 16		lda $16				lda 	zCodePtr+0 					; 4 bytes, could reduce this for 65816/6502
.018463	91 26		sta ($26),y			sta 	(zBasicSP),y
.018465	c8		iny				iny
.018466	a5 17		lda $17				lda 	zCodePtr+1
.018468	91 26		sta ($26),y			sta 	(zBasicSP),y
.01846a	c8		iny				iny
.01846b	a5 18		lda $18				lda 	zCodePtr+2
.01846d	91 26		sta ($26),y			sta 	(zBasicSP),y
.01846f	c8		iny				iny
.018470	a5 19		lda $19				lda 	zCodePtr+3
.018472	91 26		sta ($26),y			sta 	(zBasicSP),y
.018474	7a		ply				ply
.018475	60		rts				rts
.018476					StackRestorePosition:
.018476	5a		phy				phy
.018477	a0 01		ldy #$01			ldy 	#1 							; copy 4 bytes that are the pointer
.018479	b1 26		lda ($26),y			lda 	(zBasicSP),y
.01847b	85 16		sta $16				sta 	zCodePtr+0
.01847d	c8		iny				iny
.01847e	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018480	85 17		sta $17				sta 	zCodePtr+1
.018482	c8		iny				iny
.018483	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018485	85 18		sta $18				sta 	zCodePtr+2
.018487	c8		iny				iny
.018488	b1 26		lda ($26),y			lda 	(zBasicSP),y
.01848a	85 19		sta $19				sta 	zCodePtr+3
.01848c	c8		iny				iny
.01848d	b1 26		lda ($26),y			lda 	(zBasicSP),y 				; offset
.01848f	7a		ply				ply 								; restore Y
.018490	a8		tay				tay
.018491	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/errors.asm

.018492					SyntaxError:
.018492	20 c1 84	jsr $0184c1			jsr 	ERR_Handler
>018495	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>01849d	72 72 6f 72 00
.0184a2					TypeError:
.0184a2	20 c1 84	jsr $0184c1			jsr 	ERR_Handler
>0184a5	57 72 6f 6e 67 20 74 79				.text 	"Wrong type",0
>0184ad	70 65 00
.0184b0					BadParamError:
.0184b0	20 c1 84	jsr $0184c1			jsr 	ERR_Handler
>0184b3	42 61 64 20 50 61 72 61				.text 	"Bad Parameter",0
>0184bb	6d 65 74 65 72 00
.0184c1					ERR_Handler:
.0184c1	a0 00		ldy #$00			ldy 	#0
.0184c3	c8		iny				iny
.0184c4	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0184c6	85 80		sta $80				sta 	XS_Mantissa
.0184c8	c8		iny				iny
.0184c9	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0184cb	85 81		sta $81				sta 	XS_Mantissa+1
.0184cd	fa		plx				plx 								; address in XY
.0184ce	7a		ply				ply
.0184cf	e8		inx				inx 								; bump, because of RTS/JSR address -1
.0184d0	d0 01		bne $0184d3			bne 	_EHNoSkip
.0184d2	c8		iny				iny
.0184d3					_EHNoSkip:
.0184d3	20 f2 84	jsr $0184f2			jsr 	PrintROMMessage 			; print message from ROM.
.0184d6	a5 80		lda $80				lda 	XS_Mantissa					; line number = 0
.0184d8	05 81		ora $81				ora 	XS_Mantissa+1
.0184da	f0 0c		beq $0184e8			beq 	_EHNoLine
.0184dc	a2 ed		ldx #$ed			ldx 	#_EHAt & $FF 				; print " at "
.0184de	a0 84		ldy #$84			ldy 	#(_EHAt >> 8) & $FF
.0184e0	20 f2 84	jsr $0184f2			jsr 	PrintROMMessage
.0184e3	a2 00		ldx #$00			ldx 	#0 							; Print line number
.0184e5	20 07 85	jsr $018507			jsr 	Print16BitInteger
.0184e8					_EHNoLine:
.0184e8	80 fe		bra $0184e8			bra 	_EHNoLine
.0184ea	4c 63 87	jmp $018763			jmp 	WarmStart
>0184ed	20 61 74 20 00			_EHAt:	.text 	" at ",0
.0184f2					PrintROMMessage:
.0184f2	86 1a		stx $1a				stx 	zLTemp1 					; save addres
.0184f4	84 1b		sty $1b				sty 	zLTemp1+1
.0184f6	4b		phk				phk
.0184f7	68		pla				pla
.0184f8	85 1c		sta $1c				sta 	ZLTemp1+2
.0184fa	a0 00		ldy #$00			ldy 	#0
.0184fc					_PRMLoop:
.0184fc	b7 1a		lda [$1a],y			lda 	[zLTemp1],y
.0184fe	f0 06		beq $018506			beq		_PRMExit
.018500	c8		iny				iny
.018501	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018504	80 f6		bra $0184fc			bra 	_PRMLoop
.018506					_PRMExit:
.018506	60		rts				rts
.018507					Print16BitInteger:
.018507	a9 00		lda #$00			lda 	#0 							; make 32 bit
.018509	85 82		sta $82				sta 	XS_Mantissa+2
.01850b	85 83		sta $83				sta 	XS_Mantissa+3
.01850d	8d 0e 03	sta $030e			sta 	NumBufX 					; reset the conversion pointer
.018510	aa		tax				tax 								; convert bottom level.
.018511	20 09 97	jsr $019709			jsr 	INTToString 				; make string
.018514	a2 00		ldx #$00			ldx 	#0 							; print buffer
.018516	bd 0f 03	lda $030f,x	_P1Loop:lda 	Num_Buffer,x
.018519	f0 06		beq $018521			beq 	_P1Exit
.01851b	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01851e	e8		inx				inx
.01851f	80 f5		bra $018516			bra 	_P1Loop
.018521	60		rts		_P1Exit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm


;******  Processing file: modules/basic/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b6					lastUnaryFunction = $b6
.018522					VectorTable:
>018522	9c 8b					.word BinaryOp_And         & $FFFF ; $80 and
>018524	b8 8b					.word BinaryOp_Or          & $FFFF ; $81 or
>018526	d4 8b					.word BinaryOp_Xor         & $FFFF ; $82 xor
>018528	d4 8b					.word BinaryOp_Eor         & $FFFF ; $83 eor
>01852a	0b 8c					.word Binary_Equal         & $FFFF ; $84 =
>01852c	25 8c					.word Binary_NotEqual      & $FFFF ; $85 <>
>01852e	2e 8c					.word Binary_Less          & $FFFF ; $86 <
>018530	37 8c					.word Binary_LessEqual     & $FFFF ; $87 <=
>018532	49 8c					.word Binary_Greater       & $FFFF ; $88 >
>018534	40 8c					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>018536	ce 8c					.word BinaryOp_Add         & $FFFF ; $8a +
>018538	ea 8c					.word BinaryOp_Subtract    & $FFFF ; $8b -
>01853a	fb 8c					.word BinaryOp_Multiply    & $FFFF ; $8c *
>01853c	0c 8d					.word BinaryOp_Divide      & $FFFF ; $8d /
>01853e	de 85					.word NotImplemented       & $FFFF ; $8e ^
>018540	de 85					.word NotImplemented       & $FFFF ; $8f if
>018542	de 85					.word NotImplemented       & $FFFF ; $90 while
>018544	c6 89					.word Command_REPEAT       & $FFFF ; $91 repeat
>018546	de 85					.word NotImplemented       & $FFFF ; $92 for
>018548	de 85					.word NotImplemented       & $FFFF ; $93 then
>01854a	de 85					.word NotImplemented       & $FFFF ; $94 endif
>01854c	de 85					.word NotImplemented       & $FFFF ; $95 wend
>01854e	cf 89					.word Command_UNTIL        & $FFFF ; $96 until
>018550	de 85					.word NotImplemented       & $FFFF ; $97 next
>018552	de 85					.word NotImplemented       & $FFFF ; $98 not
>018554	de 85					.word NotImplemented       & $FFFF ; $99 fn(
>018556	11 8e					.word Unary_Abs            & $FFFF ; $9a abs(
>018558	52 8f					.word Unary_Asc            & $FFFF ; $9b asc(
>01855a	f8 9d					.word Unary_Int            & $FFFF ; $9c int(
>01855c	2b 8e					.word Unary_Peek           & $FFFF ; $9d peek(
>01855e	79 9d					.word Unary_Rnd            & $FFFF ; $9e rnd(
>018560	92 8e					.word Unary_Usr            & $FFFF ; $9f usr(
>018562	91 8f					.word Unary_Left           & $FFFF ; $a0 left$(
>018564	a6 8f					.word Unary_Right          & $FFFF ; $a1 right$(
>018566	78 8f					.word Unary_Mid            & $FFFF ; $a2 mid$(
>018568	ef 90					.word Unary_Spc            & $FFFF ; $a3 spc(
>01856a	20 8f					.word Unary_Str            & $FFFF ; $a4 str$(
>01856c	b4 8e					.word Unary_Val            & $FFFF ; $a5 val(
>01856e	69 8f					.word Unary_Len            & $FFFF ; $a6 len(
>018570	1e 90					.word Unary_Hex            & $FFFF ; $a7 hex$(
>018572	de 85					.word NotImplemented       & $FFFF ; $a8 sin(
>018574	de 85					.word NotImplemented       & $FFFF ; $a9 cos(
>018576	de 85					.word NotImplemented       & $FFFF ; $aa tan(
>018578	de 85					.word NotImplemented       & $FFFF ; $ab atn(
>01857a	de 85					.word NotImplemented       & $FFFF ; $ac exp(
>01857c	de 85					.word NotImplemented       & $FFFF ; $ad log(
>01857e	de 85					.word NotImplemented       & $FFFF ; $ae sqr(
>018580	74 90					.word Unary_Dec            & $FFFF ; $af dec(
>018582	2f 8e					.word Unary_Deek           & $FFFF ; $b0 deek(
>018584	33 8e					.word Unary_Leek           & $FFFF ; $b1 leek(
>018586	5f 8e					.word Unary_Mod            & $FFFF ; $b2 mod(
>018588	cb 8d					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>01858a	d1 90					.word Unary_Chr            & $FFFF ; $b4 chr$(
>01858c	de 85					.word NotImplemented       & $FFFF ; $b5 pos(
>01858e	de 85					.word NotImplemented       & $FFFF ; $b6 tab(
>018590	de 85					.word NotImplemented       & $FFFF ; $b7 $
>018592	de 85					.word NotImplemented       & $FFFF ; $b8 $(
>018594	de 85					.word NotImplemented       & $FFFF ; $b9 #
>018596	de 85					.word NotImplemented       & $FFFF ; $ba #(
>018598	de 85					.word NotImplemented       & $FFFF ; $bb %
>01859a	de 85					.word NotImplemented       & $FFFF ; $bc %(
>01859c	de 85					.word NotImplemented       & $FFFF ; $bd (
>01859e	de 85					.word NotImplemented       & $FFFF ; $be )
>0185a0	de 85					.word NotImplemented       & $FFFF ; $bf ,
>0185a2	73 88					.word Command_COLON        & $FFFF ; $c0 :
>0185a4	de 85					.word NotImplemented       & $FFFF ; $c1 ;
>0185a6	de 85					.word NotImplemented       & $FFFF ; $c2 def
>0185a8	aa 89					.word Command_CLR          & $FFFF ; $c3 clr
>0185aa	be 89					.word Command_STOP         & $FFFF ; $c4 stop
>0185ac	de 85					.word NotImplemented       & $FFFF ; $c5 data
>0185ae	de 85					.word NotImplemented       & $FFFF ; $c6 read
>0185b0	71 87					.word Command_DIM          & $FFFF ; $c7 dim
>0185b2	de 85					.word NotImplemented       & $FFFF ; $c8 to
>0185b4	de 85					.word NotImplemented       & $FFFF ; $c9 step
>0185b6	26 89					.word Command_GOSUB        & $FFFF ; $ca gosub
>0185b8	34 89					.word Command_RETURN       & $FFFF ; $cb return
>0185ba	20 89					.word Command_GOTO         & $FFFF ; $cc goto
>0185bc	95 88					.word Command_END          & $FFFF ; $cd end
>0185be	de 85					.word NotImplemented       & $FFFF ; $ce input
>0185c0	74 88					.word Command_LET          & $FFFF ; $cf let
>0185c2	de 85					.word NotImplemented       & $FFFF ; $d0 list
>0185c4	de 85					.word NotImplemented       & $FFFF ; $d1 new
>0185c6	de 85					.word NotImplemented       & $FFFF ; $d2 old
>0185c8	de 85					.word NotImplemented       & $FFFF ; $d3 on
>0185ca	de 85					.word NotImplemented       & $FFFF ; $d4 restore
>0185cc	de 85					.word NotImplemented       & $FFFF ; $d5 poke
>0185ce	99 88					.word Command_PRINT        & $FFFF ; $d6 print
>0185d0	f9 87					.word Command_RUN          & $FFFF ; $d7 run
>0185d2	de 85					.word NotImplemented       & $FFFF ; $d8 wait
>0185d4	de 85					.word NotImplemented       & $FFFF ; $d9 sys
>0185d6	de 85					.word NotImplemented       & $FFFF ; $da doke
>0185d8	de 85					.word NotImplemented       & $FFFF ; $db loke
>0185da	08 89					.word Command_ASSERT       & $FFFF ; $dc assert
>0185dc	de 85					.word NotImplemented       & $FFFF ; $dd get
.0185de					NotImplemented:
.0185de	20 c1 84	jsr $0184c1			jsr ERR_Handler
>0185e1	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>0185e9	65 6d 65 6e 74 65 64 00
.0185f1					BinaryPrecedence:
>0185f1	01					.byte 1    ; $80 and
>0185f2	01					.byte 1    ; $81 or
>0185f3	01					.byte 1    ; $82 xor
>0185f4	01					.byte 1    ; $83 eor
>0185f5	02					.byte 2    ; $84 =
>0185f6	02					.byte 2    ; $85 <>
>0185f7	02					.byte 2    ; $86 <
>0185f8	02					.byte 2    ; $87 <=
>0185f9	02					.byte 2    ; $88 >
>0185fa	02					.byte 2    ; $89 >=
>0185fb	03					.byte 3    ; $8a +
>0185fc	03					.byte 3    ; $8b -
>0185fd	04					.byte 4    ; $8c *
>0185fe	04					.byte 4    ; $8d /
>0185ff	05					.byte 5    ; $8e ^
.018600					KeywordText:
>018600	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>018603	4f d2					.byte $4f,$d2                          ; $81 or
>018605	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>018608	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>01860b	bd					.byte $bd                              ; $84 =
>01860c	3c be					.byte $3c,$be                          ; $85 <>
>01860e	bc					.byte $bc                              ; $86 <
>01860f	3c bd					.byte $3c,$bd                          ; $87 <=
>018611	be					.byte $be                              ; $88 >
>018612	3e bd					.byte $3e,$bd                          ; $89 >=
>018614	ab					.byte $ab                              ; $8a +
>018615	ad					.byte $ad                              ; $8b -
>018616	aa					.byte $aa                              ; $8c *
>018617	af					.byte $af                              ; $8d /
>018618	de					.byte $de                              ; $8e ^
>018619	49 c6					.byte $49,$c6                          ; $8f if
>01861b	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>018620	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>018626	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>018629	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>01862d	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>018632	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>018636	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>01863b	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>01863f	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>018642	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>018645	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>018649	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>01864d	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>018651	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>018656	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>01865a	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>01865e	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>018664	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>01866b	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>018670	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>018674	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>018679	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>01867d	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>018681	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>018686	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>01868a	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>01868e	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>018692	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>018696	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>01869a	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>01869e	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>0186a2	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>0186a6	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>0186ab	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>0186b0	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>0186b4	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>0186b8	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>0186bd	50 4f 53 a8				.byte $50,$4f,$53,$a8                  ; $b5 pos(
>0186c1	54 41 42 a8				.byte $54,$41,$42,$a8                  ; $b6 tab(
>0186c5	a4					.byte $a4                              ; $b7 $
>0186c6	24 a8					.byte $24,$a8                          ; $b8 $(
>0186c8	a3					.byte $a3                              ; $b9 #
>0186c9	23 a8					.byte $23,$a8                          ; $ba #(
>0186cb	a5					.byte $a5                              ; $bb %
>0186cc	25 a8					.byte $25,$a8                          ; $bc %(
>0186ce	a8					.byte $a8                              ; $bd (
>0186cf	a9					.byte $a9                              ; $be )
>0186d0	ac					.byte $ac                              ; $bf ,
>0186d1	ba					.byte $ba                              ; $c0 :
>0186d2	bb					.byte $bb                              ; $c1 ;
>0186d3	44 45 c6				.byte $44,$45,$c6                      ; $c2 def
>0186d6	43 4c d2				.byte $43,$4c,$d2                      ; $c3 clr
>0186d9	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $c4 stop
>0186dd	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c5 data
>0186e1	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c6 read
>0186e5	44 49 cd				.byte $44,$49,$cd                      ; $c7 dim
>0186e8	54 cf					.byte $54,$cf                          ; $c8 to
>0186ea	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c9 step
>0186ee	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $ca gosub
>0186f3	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $cb return
>0186f9	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $cc goto
>0186fd	45 4e c4				.byte $45,$4e,$c4                      ; $cd end
>018700	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $ce input
>018705	4c 45 d4				.byte $4c,$45,$d4                      ; $cf let
>018708	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $d0 list
>01870c	4e 45 d7				.byte $4e,$45,$d7                      ; $d1 new
>01870f	4f 4c c4				.byte $4f,$4c,$c4                      ; $d2 old
>018712	4f ce					.byte $4f,$ce                          ; $d3 on
>018714	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d4 restore
>01871b	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d5 poke
>01871f	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d6 print
>018724	52 55 ce				.byte $52,$55,$ce                      ; $d7 run
>018727	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d8 wait
>01872b	53 59 d3				.byte $53,$59,$d3                      ; $d9 sys
>01872e	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $da doke
>018732	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $db loke
>018736	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $dc assert
>01873c	47 45 d4				.byte $47,$45,$d4                      ; $dd get
>01873f	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_pos = $b5
=$b6					token_tab = $b6
=$b7					token_dollar = $b7
=$b8					token_dollarlparen = $b8
=$b9					token_hash = $b9
=$ba					token_hashlparen = $ba
=$bb					token_percent = $bb
=$bc					token_percentlparen = $bc
=$bd					token_lparen = $bd
=$be					token_rparen = $be
=$bf					token_comma = $bf
=$c0					token_colon = $c0
=$c1					token_semicolon = $c1
=$c2					token_def = $c2
=$c3					token_clr = $c3
=$c4					token_stop = $c4
=$c5					token_data = $c5
=$c6					token_read = $c6
=$c7					token_dim = $c7
=$c8					token_to = $c8
=$c9					token_step = $c9
=$ca					token_gosub = $ca
=$cb					token_return = $cb
=$cc					token_goto = $cc
=$cd					token_end = $cd
=$ce					token_input = $ce
=$cf					token_let = $cf
=$d0					token_list = $d0
=$d1					token_new = $d1
=$d2					token_old = $d2
=$d3					token_on = $d3
=$d4					token_restore = $d4
=$d5					token_poke = $d5
=$d6					token_print = $d6
=$d7					token_run = $d7
=$d8					token_wait = $d8
=$d9					token_sys = $d9
=$da					token_doke = $da
=$db					token_loke = $db
=$dc					token_assert = $dc
=$dd					token_get = $dd

;******  Return to file: modules/basic/core.asm

.018740					BASIC_Start:
.018740	20 a8 81	jsr $0181a8			jsr 	IF_Reset 					; set up and clear screen.
.018743	20 00 80	jsr $018000			jsr 	IFT_ClearScreen
.018746	a9 5c		lda #$5c			lda 	#$5C 						; JMP Long opcode
.018748	8d 0a 03	sta $030a			sta 	LocalVector
.01874b	8d 06 03	sta $0306			sta 	UserVector
.01874e	a9 a2		lda #$a2			lda 	#USRDefault & $FF 			; reset USR vector
.018750	8d 07 03	sta $0307			sta 	UserVector+1
.018753	a9 8e		lda #$8e			lda 	#(USRDefault >> 8) & $FF
.018755	8d 08 03	sta $0308			sta 	UserVector+2
.018758	a9 01		lda #$01			lda 	#(USRDefault >> 16) & $FF
.01875a	8d 09 03	sta $0309			sta 	UserVector+3
.01875d	20 38 91	jsr $019138			jsr 	UpdateProgramEnd 			; update the program end.
.018760	20 aa 89	jsr $0189aa			jsr 	ResetRunStatus 				; clear everything (CLR command)
.018763					WarmStart:
.018763	c2 30		rep #$30			rep 	#$30
.018765	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.018768	1b		tcs				tcs
.018769	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.01876c	e2 30		sep #$30			sep 	#$30
.01876e	4c f9 87	jmp $0187f9			jmp 	COMMAND_Run

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/dim.asm

.018771					Command_DIM:
.018771	98		tya				tya
.018772	48		pha				pha 								; push on stack.
.018773	20 92 92	jsr $019292			jsr 	VariableExtract 			; get the identifier
.018776	ad 8f 03	lda $038f			lda 	Var_Type 					; check it is an array
.018779	29 01		and #$01			and 	#1
.01877b	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.01877d	d0 6c		bne $0187eb			bne 	_CDIError
.01877f	a9 00		lda #$00			lda 	#0 							; reset the DIM index. The dimensions are
.018781	8d b1 03	sta $03b1			sta 	UsrArrayIdx 				; built up here and copied in case we autodim
.018784					_CDIGetDimension:
.018784	ad b1 03	lda $03b1			lda 	UsrArrayIdx 				; done too many ?
.018787	c9 06		cmp #$06			cmp 	#ArrayMaxDim*2
.018789	f0 60		beq $0187eb			beq 	_CDIError
.01878b	20 7d 8b	jsr $018b7d			jsr 	EvaluateInteger 			; evaluate an index size
.01878e	a5 81		lda $81				lda 	XS_Mantissa+1 				; check in range 0-7FFF
.018790	29 80		and #$80			and 	#$80
.018792	05 82		ora $82				ora 	XS_Mantissa+2
.018794	05 83		ora $83				ora 	XS_Mantissa+3
.018796	d0 53		bne $0187eb			bne 	_CDIError
.018798	ae b1 03	ldx $03b1			ldx 	UsrArrayIdx 				; copy into the array table.
.01879b	18		clc				clc 								; add 1 - max index => size.
.01879c	a5 80		lda $80				lda 	XS_Mantissa+0
.01879e	69 01		adc #$01			adc 	#1
.0187a0	9d a9 03	sta $03a9,x			sta 	UsrArrayDef+0,x
.0187a3	a5 81		lda $81				lda 	XS_Mantissa+1
.0187a5	69 00		adc #$00			adc 	#0
.0187a7	9d aa 03	sta $03aa,x			sta 	UsrArrayDef+1,x
.0187aa	30 3f		bmi $0187eb			bmi 	_CDIError 					; could be dim a(32767)
.0187ac	e8		inx				inx 								; bump index.
.0187ad	e8		inx				inx
.0187ae	8e b1 03	stx $03b1			stx 	UsrArrayIdx
.0187b1	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0187b3	c8		iny				iny
.0187b4	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another dimension
.0187b6	f0 cc		beq $018784			beq 	_CDIGetDimension
.0187b8	88		dey				dey
.0187b9	20 86 91	jsr $019186			jsr 	CheckNextRParen 			; closing ) present ?
.0187bc	ae b1 03	ldx $03b1			ldx 	UsrArrayIdx 				; copy USR array to default
.0187bf	a9 ff		lda #$ff			lda 	#$FF 						; put end marker in ArrayDef
.0187c1	9d a2 03	sta $03a2,x			sta 	ArrayDef+1,x
.0187c4					_CDICopy:
.0187c4	bd a9 03	lda $03a9,x			lda 	UsrArrayDef,x
.0187c7	9d a1 03	sta $03a1,x			sta 	ArrayDef,x
.0187ca	ca		dex				dex
.0187cb	10 f7		bpl $0187c4			bpl 	_CDICopy
.0187cd	68		pla				pla									; position of array identifier
.0187ce	85 10		sta $10				sta 	zTemp1
.0187d0	98		tya				tya
.0187d1	48		pha				pha
.0187d2	a5 10		lda $10				lda 	zTemp1 						; point to identifier
.0187d4	a8		tay				tay
.0187d5	20 92 92	jsr $019292			jsr 	VariableExtract 			; get the identifier
.0187d8	20 2b 95	jsr $01952b			jsr 	VariableLocate 				; check if it exists already.
.0187db	b0 0e		bcs $0187eb			bcs 	_CDIError
.0187dd	20 1e 93	jsr $01931e			jsr 	VariableCreate 				; create it using the current ArrayDef
.0187e0	68		pla				pla 								; restore code position
.0187e1	a8		tay				tay
.0187e2	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0187e4	c8		iny				iny
.0187e5	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another DIM
.0187e7	f0 88		beq $018771			beq 	Command_DIM
.0187e9	88		dey				dey
.0187ea	60		rts				rts
.0187eb					_CDIError:
.0187eb	20 c1 84	jsr $0184c1			jsr ERR_Handler
>0187ee	42 61 64 20 44 49 4d 00			.text "Bad DIM",0
.0187f6					_CDISyntax:
.0187f6	4c 92 84	jmp $018492			jmp 	SyntaxError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/run.asm

.0187f9					Command_RUN:
.0187f9	20 aa 89	jsr $0189aa			jsr 	ResetRunStatus 				; clear, reset stacks etc.
.0187fc	a9 00		lda #$00			lda 	#BasicProgram & $FF
.0187fe	85 16		sta $16				sta 	zCodePtr+0
.018800	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018802	85 17		sta $17				sta 	zCodePtr+1
.018804	a9 00		lda #$00			lda 	#0
.018806	85 18		sta $18				sta 	zCodePtr+2
.018808	85 19		sta $19				sta 	zCodePtr+3
.01880a	a0 03		ldy #$03			ldy 	#3
.01880c					RUN_NewLine:
.01880c	a0 00		ldy #$00			ldy 	#0
.01880e	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018810	c8		iny				iny
.018811	c8		iny				iny
.018812	c8		iny				iny
.018813	c9 00		cmp #$00			cmp 	#0 							; if the offset is zero then END.
.018815	d0 16		bne $01882d			bne 	RUN_NextCommand
.018817	4c be 89	jmp $0189be			jmp 	Command_STOP 				; go do the command code.
.01881a					RUN_Skip:
.01881a	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.01881c	c8		iny				iny 								; skip
.01881d	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.01881f	90 0c		bcc $01882d			bcc 	_SEDone 					; so just skip over it.
.018821	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018823	90 07		bcc $01882c			bcc 	_SEDouble
.018825	98		tya				tya 								; this is Y + 1
.018826	18		clc				clc
.018827	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018829	a8		tay				tay 								; back in Y.
.01882a	88		dey				dey 								; fix up, one for the +1, one for the iny
.01882b	88		dey				dey
.01882c					_SEDouble:
.01882c	c8		iny				iny
.01882d					_SEDone:
.01882d					RUN_NextCommand:
.01882d	a9 00		lda #$00			lda 	#0 							; this resets temporary string allocation.
.01882f	85 21		sta $21				sta 	zTempStr+1 					; (initialised when first called)
.018831	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018833	c9 c0		cmp #$c0			cmp 	#token_Colon 				; skip over colons
.018835	f0 e3		beq $01881a			beq 	RUN_Skip
.018837	c9 00		cmp #$00			cmp 	#0 							; if non-zero execute whatever
.018839	d0 0f		bne $01884a			bne 	RUN_Execute
.01883b					RUN_NextLine:
.01883b	a0 00		ldy #$00			ldy 	#0 							; point to offset
.01883d	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.01883f	18		clc				clc
.018840	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018842	85 16		sta $16				sta 	zCodePtr
.018844	90 02		bcc $018848			bcc 	_SNLNoCarry
.018846	e6 17		inc $17				inc 	zCodePtr+1
.018848					_SNLNoCarry:
.018848	80 c2		bra $01880c			bra 	RUN_NewLine 				; go do the new line code
.01884a					RUN_Execute:
.01884a	c9 f8		cmp #$f8			cmp 	#$F8 						; handle shifts, REM etc.
.01884c	b0 1e		bcs $01886c			bcs 	RUN_Extension
.01884e	c8		iny				iny
.01884f	0a		asl a				asl 	a 							; double the character read.
.018850	90 14		bcc $018866			bcc 	RUN_Default 				; if carry clear was $00-$7F, so try LET.
.018852	aa		tax				tax 								; ready to look up.
.018853	bf 22 85 01	lda $018522,x			lda 	VectorTable,x 				; copy address into LocalVector
.018857	8d 0b 03	sta $030b			sta 	LocalVector+1
.01885a	bf 23 85 01	lda $018523,x			lda 	VectorTable+1,x
.01885e	8d 0c 03	sta $030c			sta 	LocalVector+2
.018861	20 f0 8a	jsr $018af0			jsr 	EVCallLocalVector 			; execute the appropriate code.
.018864	80 c7		bra $01882d			bra 	RUN_NextCommand 			; do the next command.
.018866					RUN_Default:
.018866	88		dey				dey
.018867	20 74 88	jsr $018874			jsr 	Command_LET 				; and try LET.
.01886a	80 c1		bra $01882d			bra 	RUN_NextCommand
.01886c					RUN_Extension:
.01886c	c9 ff		cmp #$ff			cmp 	#$FF 						; if $FF (REM)
.01886e	f0 aa		beq $01881a			beq 	RUN_Skip 					; skip over it.
.018870	4c 92 84	jmp $018492			jmp 	SyntaxError
.018873					Command_COLON:
.018873	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/let.asm

.018874					Command_LET:
.018874	20 27 92	jsr $019227			jsr 	VariableFind 				; get reference to one variable.
.018877	a9 84		lda #$84			lda 	#token_Equal  				; get equals
.018879	20 6f 91	jsr $01916f			jsr 	CheckNextToken
.01887c	a5 22		lda $22				lda 	zVarDataPtr 				; save variable info on stack
.01887e	48		pha				pha
.01887f	a5 23		lda $23				lda 	zVarDataPtr+1
.018881	48		pha				pha
.018882	a5 24		lda $24				lda 	zVarType
.018884	48		pha				pha
.018885	20 ed 89	jsr $0189ed			jsr 	EvaluateExpression 			; evaluate the RHS.
.018888	68		pla				pla 								; restore target variable information.
.018889	85 24		sta $24				sta 	zVarType
.01888b	68		pla				pla
.01888c	85 23		sta $23				sta 	zVarDataPtr+1
.01888e	68		pla				pla
.01888f	85 22		sta $22				sta 	zVarDataPtr
.018891	20 c0 95	jsr $0195c0			jsr 	VariableSet 				; set the value out.
.018894	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/end.asm

.018895					Command_END:
>018895	02						.byte 	2
.018896	4c 63 87	jmp $018763			jmp 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/print.asm

.018899					Command_PRINT:
.018899	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01889b	c9 00		cmp #$00			cmp 	#0 							; end
.01889d	f0 65		beq $018904			beq 	_CPR_NewLine
.01889f	c9 c0		cmp #$c0			cmp 	#token_Colon
.0188a1	f0 61		beq $018904			beq 	_CPR_NewLine
.0188a3	c9 c1		cmp #$c1			cmp 	#token_SemiColon
.0188a5	f0 50		beq $0188f7			beq 	_CPR_Skip
.0188a7	c9 bf		cmp #$bf			cmp 	#token_Comma
.0188a9	f0 49		beq $0188f4			beq 	_CPR_Tab
.0188ab	20 ed 89	jsr $0189ed			jsr 	EvaluateExpression 			; get expression.
.0188ae	a5 85		lda $85				lda 	XS_Type 					; get type.
.0188b0	29 02		and #$02			and 	#2
.0188b2	d0 24		bne $0188d8			bne 	_CPR_String 				; if type = 2 output as string.
.0188b4					_CPR_Number:
.0188b4	a9 00		lda #$00			lda 	#0 							; reset buffer index
.0188b6	8d 0e 03	sta $030e			sta 	NumBufX
.0188b9	a5 85		lda $85				lda 	XS_Type 					; get type
.0188bb	4a		lsr a				lsr 	a
.0188bc	b0 05		bcs $0188c3			bcs 	_CPRInt 					; if msb set do as integer
.0188be	20 44 9c	jsr $019c44			jsr 	FPToString 					; call fp to str otherwise
.0188c1	80 03		bra $0188c6			bra 	_CPRNPrint
.0188c3	20 09 97	jsr $019709	_CPRInt:jsr 	IntToString
.0188c6					_CPRNPrint:
.0188c6	ad 0f 03	lda $030f			lda 	Num_Buffer 					; is first character -
.0188c9	c9 2d		cmp #$2d			cmp 	#"-"
.0188cb	f0 05		beq $0188d2			beq 	_CPRNoSpace
.0188cd	a9 20		lda #$20			lda 	#" "						; print the leading space
.0188cf	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter 			; so beloved of MS Basics.
.0188d2					_CPRNoSpace:
.0188d2	a2 0e		ldx #$0e			ldx 	#(Num_Buffer-1) & $FF
.0188d4	a9 03		lda #$03			lda 	#(Num_Buffer-1) >> 8
.0188d6	80 04		bra $0188dc			bra 	_CPRPrint
.0188d8					_CPR_String:
.0188d8	a6 80		ldx $80				ldx 	XS_Mantissa
.0188da	a5 81		lda $81				lda 	XS_Mantissa+1
.0188dc					_CPRPrint:
.0188dc	86 1e		stx $1e				stx 	zGenPtr
.0188de	85 1f		sta $1f				sta 	zGenPtr+1
.0188e0	5a		phy				phy
.0188e1	a0 00		ldy #$00			ldy 	#0							; get length into X
.0188e3	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.0188e5	aa		tax				tax
.0188e6	f0 09		beq $0188f1			beq 	_CPREndPrint 				; nothing to print
.0188e8					_CPRLoop:
.0188e8	c8		iny				iny
.0188e9	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.0188eb	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0188ee	ca		dex				dex
.0188ef	d0 f7		bne $0188e8			bne 	_CPRLoop
.0188f1					_CPREndPrint:
.0188f1	7a		ply				ply
.0188f2	80 a5		bra $018899			bra 	Command_Print
.0188f4					_CPR_Tab:
.0188f4	20 4f 80	jsr $01804f			jsr 	IFT_Tab
.0188f7					_CPR_Skip:
.0188f7	c8		iny				iny
.0188f8	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0188fa	c9 c0		cmp #$c0			cmp 	#token_Colon 				; colon or $00, exit
.0188fc	f0 09		beq $018907			beq 	_CPR_Exit
.0188fe	c9 00		cmp #$00			cmp 	#0
.018900	d0 97		bne $018899			bne 	Command_PRINT 				; if not go round again.
.018902	80 03		bra $018907			bra 	_CPR_Exit
.018904					_CPR_NewLine:
.018904	20 5c 80	jsr $01805c			jsr 	IFT_NewLine
.018907					_CPR_Exit:
.018907	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/assert.asm

.018908					Command_ASSERT:
.018908	20 7d 8b	jsr $018b7d			jsr 	EvaluateInteger 			; calculate thing being asserted
.01890b	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; check if true (non-zero)
.01890d	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.01890f	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.018911	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.018913	f0 01		beq $018916			beq 	_ASFail
.018915	60		rts				rts
.018916					_ASFail:
.018916	20 c1 84	jsr $0184c1			jsr ERR_Handler
>018919	41 73 73 65 72 74 00			.text "Assert",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/branch.asm

.018920					Command_GOTO:
.018920	20 3d 89	jsr $01893d			jsr 	GotoGetLineNumber
.018923	4c 5a 89	jmp $01895a			jmp 	GotoChangeToLineNumber
.018926					Command_GOSUB:
.018926	20 3d 89	jsr $01893d			jsr 	GotoGetLineNumber
.018929	20 59 84	jsr $018459			jsr 	StackSavePosition
.01892c	a9 05		lda #$05			lda 	#(SMark_Gosub << 4)+SourcePosSize
.01892e	20 12 84	jsr $018412			jsr 	StackPushFrame
.018931	4c 5a 89	jmp $01895a			jmp 	GotoChangeToLineNumber
.018934					Command_RETURN:
.018934	a9 00		lda #$00			lda 	#(SMark_Gosub << 4)
.018936	20 29 84	jsr $018429			jsr 	StackPopFrame
.018939	20 76 84	jsr $018476			jsr 	StackRestorePosition
.01893c	60		rts				rts
.01893d					GotoGetLineNumber:
.01893d	20 7d 8b	jsr $018b7d			jsr 	EvaluateInteger
.018940	a5 82		lda $82				lda 	XS_Mantissa+2 				; check range
.018942	05 83		ora $83				ora 	XS_Mantissa+3
.018944	d0 01		bne $018947			bne 	_GLINError
.018946	60		rts				rts
.018947					_GLINError:
.018947	20 c1 84	jsr $0184c1			jsr ERR_Handler
>01894a	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>018952	20 4e 75 6d 62 65 72 00
.01895a					GotoChangeToLineNumber:
.01895a	a5 80		lda $80				lda 	XS_Mantissa+0 				; check line number not zero
.01895c	05 81		ora $81				ora 	XS_Mantissa+1
.01895e	f0 37		beq $018997			beq 	_GCTLFail
.018960	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018962	85 16		sta $16				sta 	zCodePtr+0
.018964	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018966	85 17		sta $17				sta 	zCodePtr+1
.018968	a9 00		lda #$00			lda 	#0
.01896a	85 18		sta $18				sta 	zCodePtr+2
.01896c	85 19		sta $19				sta 	zCodePtr+3
.01896e	a0 03		ldy #$03			ldy 	#3
.018970					_GCTLLoop:
.018970	a0 00		ldy #$00			ldy 	#0
.018972	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018974	c9 00		cmp #$00			cmp 	#0
.018976	f0 1f		beq $018997			beq 	_GCTLFail
.018978	c8		iny				iny
.018979	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01897b	c5 80		cmp $80				cmp 	XS_Mantissa+0
.01897d	d0 07		bne $018986			bne 	_GCTLNext
.01897f	c8		iny				iny
.018980	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018982	c5 81		cmp $81				cmp 	XS_Mantissa+1
.018984	f0 0f		beq $018995			beq 	_GCTLExit
.018986					_GCTLNext:
.018986	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018988	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.01898a	18		clc				clc
.01898b	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.01898d	85 16		sta $16				sta 	zCodePtr
.01898f	90 02		bcc $018993			bcc 	_SNLNoCarry
.018991	e6 17		inc $17				inc 	zCodePtr+1
.018993					_SNLNoCarry:
.018993	80 db		bra $018970			bra 	_GCTLLoop 					; try next line.
.018995					_GCTLExit:
.018995	c8		iny				iny
.018996	60		rts				rts
.018997					_GCTLFail:
.018997	20 c1 84	jsr $0184c1			jsr ERR_Handler
>01899a	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>0189a2	20 4e 75 6d 62 65 72 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.0189aa					Command_CLR:
.0189aa					ResetRunStatus:
.0189aa	20 63 92	jsr $019263			jsr 	VariableClear
.0189ad	20 00 84	jsr $018400			jsr 	StackReset
.0189b0	a9 00		lda #$00			lda 	#HighMemory & $FF
.0189b2	8d 00 03	sta $0300			sta 	StringPtr
.0189b5	a9 7f		lda #$7f			lda 	#HighMemory >> 8
.0189b7	8d 01 03	sta $0301			sta 	StringPtr+1
.0189ba	20 2d 94	jsr $01942d			jsr 	ArrayResetDefault
.0189bd	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/stop.asm

.0189be					Command_STOP:
.0189be	20 c1 84	jsr $0184c1			jsr ERR_Handler
>0189c1	53 74 6f 70 00				.text "Stop",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/repeat.asm

.0189c6					Command_REPEAT:
.0189c6	20 59 84	jsr $018459			jsr 	StackSavePosition			; save position into stack
.0189c9	a9 15		lda #$15			lda 	#(SMark_Repeat << 4)+SourcePosSize
.0189cb	20 12 84	jsr $018412			jsr 	StackPushFrame 				; push on stack
.0189ce	60		rts				rts
.0189cf					Command_UNTIL:
.0189cf	a9 10		lda #$10			lda 	#(SMark_Repeat << 4)		; remove the frame
.0189d1	20 29 84	jsr $018429			jsr 	StackPopFrame
.0189d4	20 7d 8b	jsr $018b7d			jsr 	EvaluateInteger				; work out UNTIL
.0189d7	a5 80		lda $80				lda 	XS_Mantissa+0 				; check if zero.
.0189d9	05 81		ora $81				ora 	XS_Mantissa+1
.0189db	05 82		ora $82				ora 	XS_Mantissa+2
.0189dd	05 83		ora $83				ora 	XS_Mantissa+3
.0189df	d0 08		bne $0189e9			bne 	_CUTExit 					; if not, just exit
.0189e1	20 76 84	jsr $018476			jsr 	StackRestorePosition 		; otherwise loop round again.
.0189e4	a9 15		lda #$15			lda 	#(SMark_Repeat << 4)+SourcePosSize
.0189e6	20 12 84	jsr $018412			jsr 	StackPushFrame 				; fix the stack back.
.0189e9					_CUTExit:
.0189e9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.0189ea					EVESyntax:
.0189ea	4c 92 84	jmp $018492			jmp 	SyntaxError
.0189ed					EvaluateExpression:
.0189ed	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.0189ef					EvaluateExpressionX:
.0189ef	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.0189f1					EvaluateExpressionXA:
.0189f1	48		pha				pha 								; save precedence on stack.
.0189f2	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0189f4	f0 f4		beq $0189ea			beq 	EVESyntax 					; end of line, syntax error.
.0189f6	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.0189f8	b0 03		bcs $0189fd			bcs 	_EVNotVariable
.0189fa	4c e7 8a	jmp $018ae7			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.0189fd					_EVNotVariable:
.0189fd	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.0189ff	90 e9		bcc $0189ea			bcc 	EVESyntax
.018a01	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.018a03	b0 78		bcs $018a7d			bcs 	_EVNotInteger
.018a05	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.018a07	95 80		sta $80,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.018a09	a9 00		lda #$00			lda 	#0
.018a0b	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018a0d	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.018a0f	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018a11	1a		inc a				inc 	a 							; set to type 1 (integer)
.018a12	95 85		sta $85,x			sta 	XS_Type,x
.018a14					_EVCheckNextInteger:
.018a14	c8		iny				iny
.018a15	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018a17	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.018a19	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.018a1b	b0 0b		bcs $018a28			bcs 	_EVCheckDecimal
.018a1d	48		pha				pha 								; save it.
.018a1e	20 f3 8a	jsr $018af3			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.018a21	68		pla				pla
.018a22	15 80		ora $80,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.018a24	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018a26	80 ec		bra $018a14			bra 	_EVCheckNextInteger
.018a28					_EVCheckDecimal:
.018a28	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018a2a	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.018a2c	d0 05		bne $018a33			bne 	_EVGotAtom 					; no, get atom.
.018a2e					_EVIsDecimal:
.018a2e	20 15 8b	jsr $018b15			jsr 	EVGetDecimal 				; extend to the decimal part.
.018a31	80 00		bra $018a33			bra 	_EVGotAtom 					; and continue to got atom.
.018a33					_EVGotAtom:
.018a33	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018a35	10 44		bpl $018a7b			bpl 	_EVExitDrop 				; must be a token.
.018a37	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.018a39	b0 40		bcs $018a7b			bcs 	_EVExitDrop
.018a3b	68		pla				pla 								; get current precedence
.018a3c	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.018a3e	da		phx				phx 								; save X
.018a3f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018a41	aa		tax				tax 								; put in X
.018a42	bf 71 85 01	lda $018571,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.018a46	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.018a48	fa		plx				plx 								; restore X
.018a49	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.018a4b	90 2f		bcc $018a7c			bcc 	_EVExit 					; exit if too low.
.018a4d	f0 2d		beq $018a7c			beq 	_EVExit 					; exit if equals
.018a4f	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.018a51	48		pha				pha
.018a52	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018a54	48		pha				pha
.018a55	c8		iny				iny
.018a56	da		phx				phx 								; save current position
.018a57	e8		inx				inx
.018a58	e8		inx				inx
.018a59	e8		inx				inx
.018a5a	e8		inx				inx
.018a5b	e8		inx				inx
.018a5c	e8		inx				inx
.018a5d	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.018a5f	20 f1 89	jsr $0189f1			jsr 	EvaluateExpressionXA 		; do the RHS.
.018a62	fa		plx				plx 								; restore X
.018a63	68		pla				pla 								; get the binary operator in A.
.018a64					_EVCallA:
.018a64	da		phx				phx 								; save X again
.018a65	0a		asl a				asl 	a 							; double, lose the MSB.
.018a66	aa		tax				tax									; put in X
.018a67	bf 22 85 01	lda $018522,x			lda 	VectorTable,x 				; copy address into zGenPtr
.018a6b	8d 0b 03	sta $030b			sta 	LocalVector+1
.018a6e	bf 23 85 01	lda $018523,x			lda 	VectorTable+1,x
.018a72	8d 0c 03	sta $030c			sta 	LocalVector+2
.018a75	fa		plx				plx 								; restore X
.018a76	20 f0 8a	jsr $018af0			jsr 	EVCallLocalVector
.018a79	80 b8		bra $018a33			bra 	_EVGotAtom 					; and loop back.
.018a7b					_EVExitDrop:
.018a7b	68		pla				pla
.018a7c					_EVExit:
.018a7c	60		rts				rts
.018a7d					_EVNotInteger:
.018a7d	c8		iny				iny
.018a7e	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.018a80	d0 16		bne $018a98			bne 	_EVNotMinus
.018a82	20 5e 8b	jsr $018b5e			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.018a85	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.018a87	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.018a89	f0 05		beq $018a90			beq 	_EVMinusFloat
.018a8b	20 ec 96	jsr $0196ec			jsr 	IntegerNegateAlways 		; negation
.018a8e	80 a3		bra $018a33			bra 	_EVGotAtom 					; and go back.
.018a90					_EVMinusFloat:
.018a90	b5 85		lda $85,x			lda 	XS_Type,x 					; invert the sign bit.
.018a92	49 80		eor #$80			eor 	#$80
.018a94	95 85		sta $85,x			sta 	XS_Type,x
.018a96	80 9b		bra $018a33			bra 	_EVGotAtom
.018a98					_EVNotMinus:
.018a98	c9 bd		cmp #$bd			cmp 	#token_lparen 				; is it left parenthesis
.018a9a	d0 17		bne $018ab3			bne 	_EVNotParenthesis
.018a9c	20 ef 89	jsr $0189ef			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.018a9f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018aa1	c8		iny				iny
.018aa2	c9 be		cmp #$be			cmp 	#token_rparen 				; okay if right bracket.
.018aa4	f0 8d		beq $018a33			beq 	_EVGotAtom
.018aa6	20 c1 84	jsr $0184c1			jsr ERR_Handler
>018aa9	4d 69 73 73 69 6e 67 20			.text "Missing )",0
>018ab1	29 00
.018ab3					_EVNotParenthesis:
.018ab3	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.018ab5	d0 0c		bne $018ac3			bne 	_EVNotNot
.018ab7	20 5e 8b	jsr $018b5e			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.018aba	20 45 9b	jsr $019b45			jsr 	FPUToInteger 				; make it an integer - if possible.
.018abd	20 43 8b	jsr $018b43			jsr 	NotInteger 					; do the not calculation
.018ac0	4c 33 8a	jmp $018a33			jmp 	_EVGotAtom
.018ac3					_EVNotNot:
.018ac3	c9 fe		cmp #$fe			cmp 	#$FE
.018ac5	d0 12		bne $018ad9			bne 	_EVNotString
.018ac7	20 01 92	jsr $019201			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.018aca	a5 20		lda $20				lda 	zTempStr 					; copy address of string into mantissa
.018acc	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018ace	a5 21		lda $21				lda 	zTempStr+1
.018ad0	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018ad2	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.018ad4	95 85		sta $85,x			sta 	XS_Type,x
.018ad6	4c 33 8a	jmp $018a33			jmp 	_EVGotAtom
.018ad9					_EVNotString:
.018ad9	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.018adb	90 04		bcc $018ae1			bcc 	_EVBadElement
.018add	c9 b7		cmp #$b7			cmp 	#lastUnaryFunction+1
.018adf	90 03		bcc $018ae4			bcc 	_EVUnaryFunction
.018ae1					_EVBadElement:
.018ae1	4c 92 84	jmp $018492			jmp 	SyntaxError
.018ae4					_EVUnaryFunction:
.018ae4	4c 64 8a	jmp $018a64			jmp 	_EVCallA
.018ae7					_EVVariableHandler:
.018ae7	20 27 92	jsr $019227			jsr 	VariableFind 				; locate a variable
.018aea	20 6f 95	jsr $01956f			jsr 	VariableGet 				; copy into memory.
.018aed	4c 33 8a	jmp $018a33			jmp 	_EVGotAtom 					; and go round.
.018af0					EVCallLocalVector:
.018af0	6c 0b 03	jmp ($030b)			jmp 	(LocalVector+1)
.018af3					EVShiftMantissaLeft6:
.018af3	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.018af5	95 84		sta $84,x			sta 	XS_Exponent,x
.018af7	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.018af9	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018afb	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.018afd	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.018aff	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.018b01	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018b03	a9 00		lda #$00			lda 	#0
.018b05	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018b07	20 0a 8b	jsr $018b0a			jsr 	_EVSMLShift 					; call it here to do it twice
.018b0a					_EVSMLShift:
.018b0a	56 84		lsr $84,x			lsr 	XS_Exponent,x
.018b0c	76 83		ror $83,x			ror 	XS_Mantissa+3,x
.018b0e	76 82		ror $82,x			ror 	XS_Mantissa+2,x
.018b10	76 81		ror $81,x			ror 	XS_Mantissa+1,x
.018b12	76 80		ror $80,x			ror 	XS_Mantissa+0,x
.018b14	60		rts				rts
.018b15					EVGetDecimal:
.018b15	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.018b17	8d 0f 03	sta $030f			sta 	Num_Buffer
.018b1a	da		phx				phx
.018b1b	c8		iny				iny
.018b1c	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018b1e	c8		iny				iny
.018b1f	3a		dec a				dec 	a								; convert to a string length.
.018b20	3a		dec a				dec 	a
.018b21	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.018b23					_EVGDCopy:
.018b23	48		pha				pha 									; save count
.018b24	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018b26	9d 0f 03	sta $030f,x			sta 	Num_Buffer,x
.018b29	e8		inx				inx 									; forward ....
.018b2a	c8		iny				iny
.018b2b	68		pla				pla 									; get count
.018b2c	3a		dec a				dec 	a 								; until zero
.018b2d	d0 f4		bne $018b23			bne 	_EVGDCopy
.018b2f	9d 0f 03	sta $030f,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.018b32	fa		plx				plx 									; restore X
.018b33	a9 0f		lda #$0f			lda 	#Num_Buffer & $FF 				; set zGenPtr
.018b35	85 1e		sta $1e				sta 	zGenPtr
.018b37	a9 03		lda #$03			lda 	#Num_Buffer >> 8
.018b39	85 1f		sta $1f				sta 	zGenPtr+1
.018b3b	5a		phy				phy 									; save Y
.018b3c	a0 00		ldy #$00			ldy 	#0 								; start position
.018b3e	20 ff 9c	jsr $019cff			jsr 	FPFromString 					; convert current
.018b41	7a		ply				ply 									; restore Y
.018b42	60		rts				rts
.018b43					NotInteger:
.018b43	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.018b45	49 ff		eor #$ff			eor 	#$FF
.018b47	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018b49	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.018b4b	49 ff		eor #$ff			eor 	#$FF
.018b4d	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018b4f	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.018b51	49 ff		eor #$ff			eor 	#$FF
.018b53	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.018b55	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.018b57	49 ff		eor #$ff			eor 	#$FF
.018b59	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018b5b	60		rts				rts
.018b5c					EvaluateGetAtom:
.018b5c	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.018b5e					EvaluateGetAtomX:
.018b5e	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.018b60	20 f1 89	jsr $0189f1			jsr 	EvaluateExpressionXA
.018b63	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.018b65	29 0f		and #$0f			and 	#15
.018b67	c9 02		cmp #$02			cmp 	#2
.018b69	b0 01		bcs $018b6c			bcs 	EvaluateType
.018b6b	60		rts				rts
.018b6c					EvaluateType:
.018b6c	4c a2 84	jmp $0184a2			jmp 	TypeError
.018b6f					EvaluateNumber:
.018b6f	a2 00		ldx #$00			ldx 	#0
.018b71					EvaluateNumberX:
.018b71	20 ef 89	jsr $0189ef			jsr 	EvaluateExpressionX
.018b74	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0/1
.018b76	29 0f		and #$0f			and 	#15
.018b78	c9 02		cmp #$02			cmp 	#2
.018b7a	b0 f0		bcs $018b6c			bcs 	EvaluateType
.018b7c	60		rts				rts
.018b7d					EvaluateInteger:
.018b7d	a2 00		ldx #$00			ldx 	#0
.018b7f					EvaluateIntegerX:
.018b7f	20 71 8b	jsr $018b71			jsr 	EvaluateNumberX
.018b82	20 45 9b	jsr $019b45			jsr 	FPUToInteger
.018b85	60		rts				rts
.018b86					EvaluateString:
.018b86	a2 00		ldx #$00			ldx 	#0
.018b88					EvaluateStringX:
.018b88	20 ef 89	jsr $0189ef			jsr 	EvaluateExpressionX
.018b8b	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 2
.018b8d	29 0f		and #$0f			and 	#15
.018b8f	c9 02		cmp #$02			cmp 	#2
.018b91	d0 d9		bne $018b6c			bne 	EvaluateType
.018b93	b5 80		lda $80,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.018b95	85 1e		sta $1e				sta 	zGenPtr
.018b97	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.018b99	85 1f		sta $1f				sta 	zGenPtr+1
.018b9b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.018b9c					BinaryOp_And:
.018b9c	20 f0 8b	jsr $018bf0			jsr 	BinaryMakeBothInteger
.018b9f	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.018ba1	35 86		and $86,x			and 	XS2_Mantissa+0,x
.018ba3	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018ba5	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.018ba7	35 87		and $87,x			and 	XS2_Mantissa+1,x
.018ba9	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018bab	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.018bad	35 88		and $88,x			and 	XS2_Mantissa+2,x
.018baf	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.018bb1	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.018bb3	35 89		and $89,x			and 	XS2_Mantissa+3,x
.018bb5	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018bb7	60		rts				rts
.018bb8					BinaryOp_Or:
.018bb8	20 f0 8b	jsr $018bf0			jsr 	BinaryMakeBothInteger
.018bbb	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.018bbd	15 86		ora $86,x			ora 	XS2_Mantissa+0,x
.018bbf	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018bc1	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.018bc3	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.018bc5	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018bc7	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.018bc9	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.018bcb	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.018bcd	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.018bcf	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.018bd1	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018bd3	60		rts				rts
.018bd4					BinaryOp_Eor:
.018bd4					BinaryOp_Xor:
.018bd4	20 f0 8b	jsr $018bf0			jsr 	BinaryMakeBothInteger
.018bd7	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.018bd9	55 86		eor $86,x			eor 	XS2_Mantissa+0,x
.018bdb	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018bdd	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.018bdf	55 87		eor $87,x			eor 	XS2_Mantissa+1,x
.018be1	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018be3	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.018be5	55 88		eor $88,x			eor 	XS2_Mantissa+2,x
.018be7	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.018be9	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.018beb	55 89		eor $89,x			eor 	XS2_Mantissa+3,x
.018bed	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018bef	60		rts				rts
.018bf0					BinaryMakeBothInteger:
.018bf0	da		phx				phx 								; save X
.018bf1	e8		inx				inx
.018bf2	e8		inx				inx
.018bf3	e8		inx				inx
.018bf4	e8		inx				inx
.018bf5	e8		inx				inx
.018bf6	e8		inx				inx
.018bf7	20 fb 8b	jsr $018bfb			jsr 	BinaryMakeInteger 			; convert to integer.
.018bfa	fa		plx				plx 								; restore X and fall through.
.018bfb					BinaryMakeInteger:
.018bfb	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.018bfd	29 0f		and #$0f			and 	#15 						; check type zero
.018bff	f0 04		beq $018c05			beq 	_BMIConvert 				; if float convert to integer.
.018c01	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.018c02	90 04		bcc $018c08			bcc 	_BMIError
.018c04	60		rts				rts
.018c05					_BMIConvert:
.018c05	4c 45 9b	jmp $019b45			jmp 	FPUToInteger 				; convert to integer
.018c08					_BMIError:
.018c08	4c a2 84	jmp $0184a2			jmp 	TypeError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.018c0b					Binary_Equal:
.018c0b	20 52 8c	jsr $018c52			jsr 	CompareValues
.018c0e	09 00		ora #$00			ora 	#0
.018c10	f0 04		beq $018c16			beq 	CCTrue
.018c12	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.018c14	80 02		bra $018c18			bra 	CCWrite
.018c16	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.018c18	95 80		sta $80,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.018c1a	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018c1c	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.018c1e	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018c20	a9 01		lda #$01			lda 	#1
.018c22	95 85		sta $85,x			sta 	XS_Type,x 					; set type to integer whatever.
.018c24	60		rts				rts
.018c25					Binary_NotEqual:
.018c25	20 52 8c	jsr $018c52			jsr 	CompareValues
.018c28	09 00		ora #$00			ora 	#0
.018c2a	f0 e6		beq $018c12			beq 	CCFalse
.018c2c	80 e8		bra $018c16			bra 	CCTrue
.018c2e					Binary_Less:
.018c2e	20 52 8c	jsr $018c52			jsr 	CompareValues
.018c31	09 00		ora #$00			ora 	#0
.018c33	30 e1		bmi $018c16			bmi 	CCTrue
.018c35	80 db		bra $018c12			bra 	CCFalse
.018c37					Binary_LessEqual:
.018c37	20 52 8c	jsr $018c52			jsr 	CompareValues
.018c3a	c9 01		cmp #$01			cmp 	#1
.018c3c	d0 d8		bne $018c16			bne 	CCTrue
.018c3e	80 d2		bra $018c12			bra 	CCFalse
.018c40					Binary_GreaterEqual:
.018c40	20 52 8c	jsr $018c52			jsr 	CompareValues
.018c43	09 00		ora #$00			ora 	#0
.018c45	10 cf		bpl $018c16			bpl 	CCTrue
.018c47	80 c9		bra $018c12			bra 	CCFalse
.018c49					Binary_Greater:
.018c49	20 52 8c	jsr $018c52			jsr 	CompareValues
.018c4c	c9 01		cmp #$01			cmp 	#1
.018c4e	f0 c6		beq $018c16			beq 	CCTrue
.018c50	80 c0		bra $018c12			bra 	CCFalse
.018c52					CompareValues:
.018c52	b5 85		lda $85,x			lda 	XS_Type,x 					; and the types together
.018c54	35 8b		and $8b,x			and 	XS2_Type,x
.018c56	c9 02		cmp #$02			cmp 	#2
.018c58	f0 11		beq $018c6b			beq 	_CVString
.018c5a	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018c5c	35 8b		and $8b,x			and 	XS2_Type,x
.018c5e	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018c5f	90 03		bcc $018c64			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018c61	4c ad 8c	jmp $018cad			jmp 	CompareInteger32 							; so execute code at \1
.018c64					_BCFloat:
.018c64	20 51 8d	jsr $018d51			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018c67	4c 7b 9a	jmp $019a7b			jmp 	FPCompare 							; and execute code at \2
.018c6a	60		rts				rts
.018c6b					_CVString:
.018c6b	da		phx				phx 								; save XY
.018c6c	5a		phy				phy
.018c6d	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.018c6f	85 1a		sta $1a				sta		zLTemp1+0
.018c71	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.018c73	85 1b		sta $1b				sta 	zLTemp1+1
.018c75	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.018c77	85 1c		sta $1c				sta 	zLTemp1+2
.018c79	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.018c7b	85 1d		sta $1d				sta 	zLTemp1+3
.018c7d	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.018c7f	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.018c81	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.018c83	90 02		bcc $018c87			bcc 	_CVCommon
.018c85	b1 1c		lda ($1c),y			lda 	(zLTemp1+2),y
.018c87					_CVCommon:
.018c87	aa		tax				tax 								; put shorter string length in zero.
.018c88	f0 0c		beq $018c96			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.018c8a					_CVCompare:
.018c8a	c8		iny				iny 								; next character
.018c8b	b1 1a		lda ($1a),y			lda 	(zLTemp1),y 				; compare characters
.018c8d	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.018c8f	90 13		bcc $018ca4			bcc 	_CVReturnLess 				; <
.018c91	d0 15		bne $018ca8			bne 	_CVReturnGreater 			; >
.018c93	ca		dex				dex 								; until common length matched.
.018c94	d0 f4		bne $018c8a			bne 	_CVCompare
.018c96					_CVMatch:
.018c96	a0 00		ldy #$00			ldy 	#0
.018c98	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.018c9a	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.018c9c	90 06		bcc $018ca4			bcc 	_CVReturnLess 				; <
.018c9e	d0 08		bne $018ca8			bne 	_CVReturnGreater 			; >
.018ca0	a9 00		lda #$00			lda 	#0
.018ca2	80 06		bra $018caa			bra 	_CVExit 					; same common, same length, same string
.018ca4					_CVReturnLess:
.018ca4	a9 ff		lda #$ff			lda 	#$FF
.018ca6	80 02		bra $018caa			bra 	_CVExit
.018ca8					_CVReturnGreater:
.018ca8	a9 01		lda #$01			lda 	#$01
.018caa					_CVExit:
.018caa	7a		ply				ply
.018cab	fa		plx				plx
.018cac	60		rts				rts
.018cad					CompareInteger32:
.018cad	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.018caf	49 80		eor #$80			eor 	#$80
.018cb1	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018cb3	b5 89		lda $89,x			lda 	XS2_Mantissa+3,x
.018cb5	49 80		eor #$80			eor 	#$80
.018cb7	95 89		sta $89,x			sta 	XS2_Mantissa+3,x
.018cb9	20 37 8d	jsr $018d37			jsr 	SubInteger32 				; subtraction
.018cbc	90 0d		bcc $018ccb			bcc 	_CI32Less 					; cc return -1
.018cbe	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check if zero
.018cc0	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.018cc2	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.018cc4	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.018cc6	f0 02		beq $018cca			beq 	_CI32Exit
.018cc8	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.018cca					_CI32Exit:
.018cca	60		rts				rts
.018ccb					_CI32Less:
.018ccb	a9 ff		lda #$ff			lda 	#$FF
.018ccd	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.018cce					BinaryOp_Add:
.018cce	b5 85		lda $85,x			lda 	XS_Type,x  					; and types together
.018cd0	35 8b		and $8b,x			and 	XS2_Type,x
.018cd2	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.018cd4	d0 11		bne $018ce7			bne 	_BOAString
.018cd6	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018cd8	35 8b		and $8b,x			and 	XS2_Type,x
.018cda	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018cdb	90 03		bcc $018ce0			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018cdd	4c 1d 8d	jmp $018d1d			jmp 	AddInteger32 							; so execute code at \1
.018ce0					_BCFloat:
.018ce0	20 51 8d	jsr $018d51			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018ce3	4c 56 98	jmp $019856			jmp 	FPAdd 							; and execute code at \2
.018ce6	60		rts				rts
.018ce7					_BOAString:
.018ce7	4c 6b 8d	jmp $018d6b			jmp 	ConcatenateString 			; concatenate two strings.
.018cea					BinaryOp_Subtract:
.018cea	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018cec	35 8b		and $8b,x			and 	XS2_Type,x
.018cee	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018cef	90 03		bcc $018cf4			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018cf1	4c 37 8d	jmp $018d37			jmp 	SubInteger32 							; so execute code at \1
.018cf4					_BCFloat:
.018cf4	20 51 8d	jsr $018d51			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018cf7	4c 4e 98	jmp $01984e			jmp 	FPSubtract 							; and execute code at \2
.018cfa	60		rts				rts
.018cfb					BinaryOp_Multiply:
.018cfb	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018cfd	35 8b		and $8b,x			and 	XS2_Type,x
.018cff	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018d00	90 03		bcc $018d05			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018d02	4c 27 96	jmp $019627			jmp 	MulInteger32 							; so execute code at \1
.018d05					_BCFloat:
.018d05	20 51 8d	jsr $018d51			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018d08	4c 7d 99	jmp $01997d			jmp 	FPMultiply 							; and execute code at \2
.018d0b	60		rts				rts
.018d0c					BinaryOp_Divide:
.018d0c	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018d0e	35 8b		and $8b,x			and 	XS2_Type,x
.018d10	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018d11	90 03		bcc $018d16			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018d13	4c 65 96	jmp $019665			jmp 	DivInteger32 							; so execute code at \1
.018d16					_BCFloat:
.018d16	20 51 8d	jsr $018d51			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018d19	4c 0a 99	jmp $01990a			jmp 	FPDivide 							; and execute code at \2
.018d1c	60		rts				rts
.018d1d					AddInteger32:
.018d1d	18		clc				clc
.018d1e	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.018d20	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.018d22	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018d24	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.018d26	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.018d28	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018d2a	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.018d2c	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.018d2e	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.018d30	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.018d32	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.018d34	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018d36	60		rts				rts
.018d37					SubInteger32:
.018d37	38		sec				sec
.018d38	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.018d3a	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.018d3c	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018d3e	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.018d40	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.018d42	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018d44	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.018d46	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.018d48	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.018d4a	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.018d4c	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.018d4e	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018d50	60		rts				rts
.018d51					BinaryMakeBothFloat:
.018d51	da		phx				phx 								; save X
.018d52	e8		inx				inx
.018d53	e8		inx				inx
.018d54	e8		inx				inx
.018d55	e8		inx				inx
.018d56	e8		inx				inx
.018d57	e8		inx				inx
.018d58	20 5c 8d	jsr $018d5c			jsr 	BinaryMakeFloat 			; convert to float.
.018d5b	fa		plx				plx 								; restore X and fall through.
.018d5c					BinaryMakeFloat:
.018d5c	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.018d5e	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.018d5f	b0 04		bcs $018d65			bcs 	_BMFConvert
.018d61	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.018d62	b0 04		bcs $018d68			bcs 	_BMFError
.018d64	60		rts				rts
.018d65					_BMFConvert:
.018d65	4c f9 9a	jmp $019af9			jmp 	FPUToFloat 					; convert to float
.018d68					_BMFError:
.018d68	4c a2 84	jmp $0184a2			jmp 	TypeError
.018d6b					ConcatenateString:
.018d6b	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.018d6d	85 1a		sta $1a				sta		zLTemp1+0
.018d6f	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.018d71	85 1b		sta $1b				sta 	zLTemp1+1
.018d73	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.018d75	85 1c		sta $1c				sta 	zLTemp1+2
.018d77	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.018d79	85 1d		sta $1d				sta 	zLTemp1+3
.018d7b	5a		phy				phy
.018d7c	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.018d7e	b1 1a		lda ($1a),y			lda 	(zlTemp1),y
.018d80	71 1c		adc ($1c),y			adc 	(zlTemp1+2),y
.018d82	7a		ply				ply
.018d83	b0 33		bcs $018db8			bcs 	_CSError					; check in range.
.018d85	c9 fe		cmp #$fe			cmp 	#maxString+1
.018d87	b0 2f		bcs $018db8			bcs 	_CSError
.018d89	20 c6 91	jsr $0191c6			jsr 	AllocateTempString 			; store the result
.018d8c	20 a3 8d	jsr $018da3			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.018d8f	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.018d91	85 1a		sta $1a				sta 	zLTemp1
.018d93	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.018d95	85 1b		sta $1b				sta 	zLTemp1+1
.018d97	20 a3 8d	jsr $018da3			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.018d9a	a5 20		lda $20				lda 	zTempStr 					; point current to new string
.018d9c	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018d9e	a5 21		lda $21				lda 	zTempStr+1
.018da0	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018da2	60		rts				rts
.018da3					_CSCopyString:
.018da3	da		phx				phx
.018da4	5a		phy				phy
.018da5	a0 00		ldy #$00			ldy 	#0 							; get length
.018da7	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.018da9	f0 0a		beq $018db5			beq 	_CSCSExit 					; if zero, exit
.018dab	aa		tax				tax 								; put in X
.018dac					_CSCSLoop:
.018dac	c8		iny				iny 								; get next char
.018dad	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.018daf	20 f1 91	jsr $0191f1			jsr		WriteTempString 			; copy out
.018db2	ca		dex				dex 								; do whole string
.018db3	d0 f7		bne $018dac			bne 	_CSCSLoop
.018db5					_CSCSExit:
.018db5	7a		ply				ply
.018db6	fa		plx				plx
.018db7	60		rts				rts
.018db8					_CSError:
.018db8	20 c1 84	jsr $0184c1			jsr ERR_Handler
>018dbb	53 74 72 69 6e 67 20 74			.text "String too long",0
>018dc3	6f 6f 20 6c 6f 6e 67 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.018dcb					Unary_Sgn:
.018dcb	20 71 8b	jsr $018b71			jsr 	EvaluateNumberX 			; get value
.018dce	20 86 91	jsr $019186			jsr 	CheckNextRParen 			; check right bracket.
.018dd1	20 ef 8d	jsr $018def			jsr 	GetSignCurrent 				; get sign.
.018dd4	09 00		ora #$00			ora 	#0
.018dd6	10 08		bpl $018de0			bpl		UnarySetAInteger			; if 0,1 return that.
.018dd8	80 00		bra $018dda			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.018dda					UnarySetAMinus1:
.018dda	a9 ff		lda #$ff			lda 	#$FF
.018ddc	95 80		sta $80,x			sta 	XS_Mantissa,x
.018dde	80 04		bra $018de4			bra 	UnarySetAFill
.018de0					UnarySetAInteger:
.018de0	95 80		sta $80,x			sta 	XS_Mantissa,x
.018de2	a9 00		lda #$00			lda 	#0
.018de4					UnarySetAFill:
.018de4	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018de6	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.018de8	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018dea	a9 01		lda #$01			lda 	#1
.018dec	95 85		sta $85,x			sta 	XS_Type,x
.018dee	60		rts				rts
.018def					GetSignCurrent:
.018def	b5 85		lda $85,x			lda 	XS_Type,x 					; identify type.
.018df1	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.018df2	90 15		bcc $018e09			bcc 	_GSCFloat
.018df4	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.018df6	30 0e		bmi $018e06			bmi 	_GSCMinus1
.018df8	15 80		ora $80,x			ora 	XS_Mantissa+0,x
.018dfa	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.018dfc	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.018dfe	d0 03		bne $018e03			bne 	_GSCPlus1
.018e00					_GSCZero:
.018e00	a9 00		lda #$00			lda 	#0
.018e02	60		rts				rts
.018e03					_GSCPlus1:
.018e03	a9 01		lda #$01			lda 	#$01
.018e05	60		rts				rts
.018e06					_GSCMinus1:
.018e06	a9 ff		lda #$ff			lda 	#$FF
.018e08	60		rts				rts
.018e09					_GSCFloat:
.018e09	34 85		bit $85,x			bit 	XS_Type,x
.018e0b	70 f3		bvs $018e00			bvs 	_GSCZero
.018e0d	30 f7		bmi $018e06			bmi 	_GSCMinus1
.018e0f	80 f2		bra $018e03			bra 	_GSCPlus1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.018e11					Unary_Abs:
.018e11	20 71 8b	jsr $018b71			jsr 	EvaluateNumberX 			; get value
.018e14	20 86 91	jsr $019186			jsr 	CheckNextRParen 			; check right bracket.
.018e17	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.018e19	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.018e1b	f0 07		beq $018e24			beq 	_UAMinusFloat
.018e1d	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; check MSB
.018e1f	10 09		bpl $018e2a			bpl 	_UAExit
.018e21	4c ec 96	jmp $0196ec			jmp 	IntegerNegateAlways 		; negation
.018e24					_UAMinusFloat:
.018e24	b5 85		lda $85,x			lda 	XS_Type,x 					; clear the sign bit.
.018e26	29 7f		and #$7f			and		#$7F
.018e28	95 85		sta $85,x			sta 	XS_Type,x
.018e2a					_UAExit:
.018e2a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.018e2b					Unary_Peek:
.018e2b	a9 01		lda #$01			lda 	#1
.018e2d	80 06		bra $018e35			bra 	UPMain
.018e2f					Unary_Deek:
.018e2f	a9 02		lda #$02			lda 	#2
.018e31	80 02		bra $018e35			bra 	UPMain
.018e33					Unary_Leek:
.018e33	a9 04		lda #$04			lda 	#4
.018e35					UPMain:
.018e35	48		pha				pha 								; set bytes to copy.
.018e36	20 7f 8b	jsr $018b7f			jsr 	EvaluateIntegerX 			; numeric parameter
.018e39	20 86 91	jsr $019186			jsr 	CheckNextRParen 			; right bracket.
.018e3c	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.018e3e	85 1a		sta $1a				sta 	zLTemp1
.018e40	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.018e42	85 1b		sta $1b				sta 	zLTemp1+1
.018e44	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.018e46	85 1c		sta $1c				sta 	zLTemp1+2
.018e48	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.018e4a	85 1d		sta $1d				sta 	zLTemp1+3
.018e4c	a9 00		lda #$00			lda 	#0 							; clear target area
.018e4e	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018e50	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018e52	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.018e54	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018e56	68		pla				pla 								; restore bytes to copy
.018e57	da		phx				phx 								; save XY
.018e58	5a		phy				phy
.018e59	20 27 91	jsr $019127			jsr 	MemRead 					; read the bytes in
.018e5c	7a		ply				ply 								; restore and exit
.018e5d	fa		plx				plx
.018e5e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.018e5f					Unary_Mod:
.018e5f	20 87 8e	jsr $018e87			jsr 	_UMParameter 				; first parameter
.018e62	20 8e 91	jsr $01918e			jsr 	CheckNextComma
.018e65	da		phx				phx 								; second parameter
.018e66	e8		inx				inx
.018e67	e8		inx				inx
.018e68	e8		inx				inx
.018e69	e8		inx				inx
.018e6a	e8		inx				inx
.018e6b	e8		inx				inx
.018e6c	20 87 8e	jsr $018e87			jsr 	_UMParameter
.018e6f	fa		plx				plx
.018e70	20 86 91	jsr $019186			jsr 	CheckNextRParen
.018e73	20 65 96	jsr $019665			jsr 	DivInteger32 				; divide
.018e76	a5 1a		lda $1a				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.018e78	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018e7a	a5 1b		lda $1b				lda 	zLTemp1+1
.018e7c	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018e7e	a5 1c		lda $1c				lda 	zLTemp1+2
.018e80	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.018e82	a5 1d		lda $1d				lda 	zLTemp1+3
.018e84	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018e86	60		rts				rts
.018e87					_UMParameter:
.018e87	20 7f 8b	jsr $018b7f			jsr 	EvaluateIntegerX 			; get value
.018e8a	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; absolute value
.018e8c	10 03		bpl $018e91			bpl 	_UMNotSigned
.018e8e	20 ec 96	jsr $0196ec			jsr 	IntegerNegateAlways
.018e91					_UMNotSigned:
.018e91	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.018e92					Unary_Usr:
.018e92	20 71 8b	jsr $018b71			jsr 	EvaluateNumberX 			; numeric parameter
.018e95	20 86 91	jsr $019186			jsr 	CheckNextRParen 			; right bracket.
.018e98	da		phx				phx 								; save XY
.018e99	5a		phy				phy
.018e9a	ea		nop				nop
.018e9b	22 06 03 00	jsl $000306			jsl 	UserVector
.018e9f	7a		ply				ply 								; and exit
.018ea0	fa		plx				plx
.018ea1	60		rts				rts
.018ea2					USRDefault:
.018ea2	20 c1 84	jsr $0184c1			jsr ERR_Handler
>018ea5	4e 6f 20 55 53 52 20 76			.text "No USR vector.",0
>018ead	65 63 74 6f 72 2e 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.018eb4					Unary_Val:
.018eb4	20 88 8b	jsr $018b88			jsr 	EvaluateStringX 			; get string
.018eb7	20 86 91	jsr $019186			jsr 	CheckNextRParen 			; check right bracket.
.018eba	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.018ebc	85 1e		sta $1e				sta 	zGenPtr
.018ebe	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.018ec0	85 1f		sta $1f				sta 	zGenPtr+1
.018ec2	5a		phy				phy
.018ec3	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.018ec5	b1 1e		lda ($1e),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.018ec7	f0 54		beq $018f1d			beq 	_UVBadNumber
.018ec9	48		pha				pha 								; save length.
.018eca	1a		inc a				inc 	a 							; one for the length, one for the terminator
.018ecb	1a		inc a				inc 	a
.018ecc	20 c6 91	jsr $0191c6			jsr 	AllocateTempString
.018ecf	c8		iny				iny 								; move to the next.
.018ed0	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get character
.018ed2	49 2d		eor #$2d			eor 	#"-"						; zero if minus sign
.018ed4	8d 9a 03	sta $039a			sta 	ValSign
.018ed7	d0 04		bne $018edd			bne 	_UVNotMinus
.018ed9	c8		iny				iny 								; skip over it.
.018eda	68		pla				pla 								; decrement character count.
.018edb	3a		dec a				dec 	a
.018edc	48		pha				pha
.018edd					_UVNotMinus:
.018edd	68		pla				pla 								; this is the count.
.018ede	48		pha		_UVCopy:pha									; copy into new temp string which is ASCIIZ
.018edf	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018ee1	c8		iny				iny
.018ee2	20 f1 91	jsr $0191f1			jsr 	WriteTempString
.018ee5	68		pla				pla
.018ee6	3a		dec a				dec 	a
.018ee7	d0 f5		bne $018ede			bne 	_UVCopy
.018ee9	20 f1 91	jsr $0191f1			jsr 	WriteTempString 			; make it ASCIIZ
.018eec	18		clc				clc
.018eed	a5 20		lda $20				lda 	zTempStr 					; tempstring +1 => genptr
.018eef	69 01		adc #$01			adc 	#1
.018ef1	85 1e		sta $1e				sta 	zGenPtr
.018ef3	a5 21		lda $21				lda 	zTempStr+1
.018ef5	69 00		adc #$00			adc 	#0
.018ef7	85 1f		sta $1f				sta 	zGenPtr+1
.018ef9	18		clc				clc
.018efa	20 be 97	jsr $0197be			jsr 	IntFromString 				; first bit.
.018efd	b0 1e		bcs $018f1d			bcs 	_UVBadNumber
.018eff	20 ff 9c	jsr $019cff			jsr 	FPFromString				; try for a float part.
.018f02	ad 9a 03	lda $039a			lda 	ValSign 					; was it negative
.018f05	d0 10		bne $018f17			bne 	_UVNotNegative
.018f07	b5 85		lda $85,x			lda 	XS_Type,x 					; check if integer
.018f09	4a		lsr a				lsr 	a
.018f0a	b0 08		bcs $018f14			bcs 	_UVInteger
.018f0c	b5 85		lda $85,x			lda 	XS_Type,x 					; set sign bit
.018f0e	09 80		ora #$80			ora 	#$80
.018f10	95 85		sta $85,x			sta 	XS_Type,x
.018f12	80 03		bra $018f17			bra 	_UVNotNegative
.018f14					_UVInteger:
.018f14	20 ec 96	jsr $0196ec			jsr 	IntegerNegateAlways 		; sign it.
.018f17					_UVNotNegative:
.018f17	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; used everything
.018f19	d0 02		bne $018f1d			bne 	_UVBadNumber
.018f1b	7a		ply				ply
.018f1c	60		rts				rts
.018f1d					_UVBadNumber:
.018f1d	4c b0 84	jmp $0184b0			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.018f20					Unary_Str:
.018f20	20 71 8b	jsr $018b71			jsr 	EvaluateNumberX 			; numeric parameter
.018f23	20 86 91	jsr $019186			jsr 	CheckNextRParen 			; right bracket.
.018f26	a9 00		lda #$00			lda 	#0 							; reset buffer index
.018f28	8d 0e 03	sta $030e			sta 	NumBufX
.018f2b	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.018f2d	4a		lsr a				lsr 	a
.018f2e	b0 05		bcs $018f35			bcs 	_USInt 						; if msb set do as integer
.018f30	20 44 9c	jsr $019c44			jsr 	FPToString 					; call fp to str otherwise
.018f33	80 03		bra $018f38			bra 	_USDuplicate
.018f35	20 09 97	jsr $019709	_USInt:	jsr 	IntToString
.018f38					_USDuplicate:
.018f38	ad 0e 03	lda $030e			lda 	NumBufX 					; chars in buffer
.018f3b	1a		inc a				inc 	a 							; one more for length
.018f3c	20 c6 91	jsr $0191c6			jsr 	AllocateTempString 			; allocate space for it.
.018f3f	5a		phy				phy 								; save Y
.018f40	a0 00		ldy #$00			ldy 	#0 							; start copying
.018f42	b9 0f 03	lda $030f,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.018f45	20 f1 91	jsr $0191f1			jsr 	WriteTempString
.018f48	c8		iny				iny
.018f49	cc 0e 03	cpy $030e			cpy 	NumBufX 					; done the lot
.018f4c	d0 f4		bne $018f42			bne 	_USCopy
.018f4e	7a		ply				ply 								; restore Y
.018f4f	4c 1a 91	jmp $01911a			jmp 	UnaryReturnTempStr 			; return new temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.018f52					Unary_Asc:
.018f52	20 88 8b	jsr $018b88			jsr 	EvaluateStringX 			; string parameter
.018f55	20 86 91	jsr $019186			jsr 	CheckNextRParen 			; right bracket.
.018f58	5a		phy				phy 								; get the string length
.018f59	a0 00		ldy #$00			ldy 	#0
.018f5b	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018f5d	f0 07		beq $018f66			beq 	_UAIllegal 					; must be at least one character
.018f5f	c8		iny				iny
.018f60	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; read it.
.018f62	7a		ply				ply
.018f63	4c e0 8d	jmp $018de0			jmp 	UnarySetAInteger
.018f66					_UAIllegal:
.018f66	4c b0 84	jmp $0184b0			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.018f69					Unary_Len:
.018f69	20 88 8b	jsr $018b88			jsr 	EvaluateStringX 			; string parameter
.018f6c	20 86 91	jsr $019186			jsr 	CheckNextRParen 			; right bracket.
.018f6f	5a		phy				phy 								; get the string length
.018f70	a0 00		ldy #$00			ldy 	#0
.018f72	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018f74	7a		ply				ply
.018f75	4c e0 8d	jmp $018de0			jmp 	UnarySetAInteger

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.018f78					Unary_Mid:
.018f78	20 88 8b	jsr $018b88			jsr 	EvaluateStringX 				; get string.
.018f7b	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.018f7d	48		pha				pha
.018f7e	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.018f80	48		pha				pha
.018f81	20 8e 91	jsr $01918e			jsr 	CheckNextComma 					; skip comma
.018f84	20 0d 90	jsr $01900d			jsr 	SLIByteParameter 				; get a byte parameter (start)
.018f87	48		pha				pha 									; and push it.
.018f88	20 8e 91	jsr $01918e			jsr 	CheckNextComma 					; skip comma
.018f8b	20 0d 90	jsr $01900d			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.018f8e	48		pha				pha 									; and push it.
.018f8f	80 41		bra $018fd2			bra 	SLIProcess
.018f91					Unary_Left:
.018f91	20 88 8b	jsr $018b88			jsr 	EvaluateStringX 				; get string.
.018f94	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.018f96	48		pha				pha
.018f97	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.018f99	48		pha				pha
.018f9a	a9 01		lda #$01			lda 	#1 								; push start position (1)
.018f9c	48		pha				pha
.018f9d	20 8e 91	jsr $01918e			jsr 	CheckNextComma 					; skip comma
.018fa0	20 0d 90	jsr $01900d			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.018fa3	48		pha				pha 									; and push it.
.018fa4	80 2c		bra $018fd2			bra 	SLIProcess
.018fa6					Unary_Right:
.018fa6	20 88 8b	jsr $018b88			jsr 	EvaluateStringX 				; get string.
.018fa9	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.018fab	48		pha				pha
.018fac	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.018fae	48		pha				pha
.018faf	da		phx				phx 									; get the string length and push on stack.
.018fb0	a2 00		ldx #$00			ldx 	#0
.018fb2	a1 1e		lda ($1e,x)			lda		(zGenPtr,x)
.018fb4	fa		plx				plx
.018fb5	48		pha				pha
.018fb6	20 8e 91	jsr $01918e			jsr 	CheckNextComma 					; skip comma
.018fb9	20 0d 90	jsr $01900d			jsr 	SLIByteParameter 				; get a byte parameter.
.018fbc	8d 98 03	sta $0398			sta 	SignCount 						; save in temporary.
.018fbf	68		pla				pla 									; restore string length.
.018fc0	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.018fc1	38		sec				sec
.018fc2	ed 98 03	sbc $0398			sbc 	SignCount 						; subtract characters needed, gives start position.
.018fc5	f0 02		beq $018fc9			beq 	_URStart 						; if <= 0 start from 1.
.018fc7	10 02		bpl $018fcb			bpl 	_UROkay
.018fc9					_URStart:
.018fc9	a9 01		lda #$01			lda 	#1
.018fcb					_UROkay:
.018fcb	48		pha				pha 									; push start
.018fcc	ad 98 03	lda $0398			lda 	SignCount 						; push count of characters
.018fcf	48		pha				pha
.018fd0	80 00		bra $018fd2			bra 	SLIProcess
.018fd2					SLIProcess:
.018fd2	20 86 91	jsr $019186			jsr 	CheckNextRParen 				; closing right bracket.
.018fd5	68		pla				pla
.018fd6	8d 9c 03	sta $039c			sta 	SliceCount 						; count in signcount
.018fd9	1a		inc a				inc 	a 								; allocate +1 for it.
.018fda	20 c6 91	jsr $0191c6			jsr 	AllocateTempString
.018fdd	68		pla				pla 									; pop start number off stack.
.018fde	f0 3b		beq $01901b			beq 	SLIError 						; exit if start = 0
.018fe0	8d 9b 03	sta $039b			sta 	SliceStart
.018fe3	68		pla				pla  									; pop string address.
.018fe4	85 1f		sta $1f				sta 	zGenPtr+1
.018fe6	68		pla				pla
.018fe7	85 1e		sta $1e				sta 	zGenPtr
.018fe9	da		phx				phx
.018fea	5a		phy				phy
.018feb	a2 00		ldx #$00			ldx 	#0 								; point to string length.
.018fed	ac 9b 03	ldy $039b			ldy 	SliceStart 						; start of the string (+1 for count)
.018ff0					_SLICopy:
.018ff0	ad 9c 03	lda $039c			lda 	SliceCount 						; done count characters
.018ff3	f0 12		beq $019007			beq 	_SLIExit
.018ff5	ce 9c 03	dec $039c			dec 	SliceCount
.018ff8	98		tya				tya 									; index of character
.018ff9	c1 1e		cmp ($1e,x)			cmp 	(zGenPtr,x)						; compare against length
.018ffb	f0 02		beq $018fff			beq 	_SLIOk 							; if equal, okay.
.018ffd	b0 08		bcs $019007			bcs 	_SLIExit 						; if past end, then exit.
.018fff	b1 1e		lda ($1e),y	_SLIOk:	lda 	(zGenPtr),y 					; copy one character
.019001	c8		iny				iny
.019002	20 f1 91	jsr $0191f1			jsr 	WriteTempString
.019005	80 e9		bra $018ff0			bra 	_SLICopy 						; go round till copied characters
.019007					_SLIExit:
.019007	7a		ply				ply 									; restore YX
.019008	fa		plx				plx
.019009	4c 1a 91	jmp $01911a			jmp 	UnaryReturnTempStr 				; return new temporary string.
.01900c	ea		nop				nop
.01900d					SLIByteParameter:
.01900d	20 7f 8b	jsr $018b7f			jsr 	EvaluateIntegerX 				; get integer
.019010	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.019012	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019014	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019016	d0 03		bne $01901b			bne 	SLIError
.019018	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01901a	60		rts				rts
.01901b					SLIError:
.01901b	4c b0 84	jmp $0184b0			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.01901e					Unary_Hex:
.01901e	20 7f 8b	jsr $018b7f			jsr 	EvaluateIntegerX 			; numeric parameter
.019021	20 86 91	jsr $019186			jsr 	CheckNextRParen 			; right bracket.
.019024	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.019026	20 c6 91	jsr $0191c6			jsr 	AllocateTempString			; allocate string space
.019029	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.01902b	20 4f 90	jsr $01904f			jsr 	_UHConvert
.01902e	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019030	20 4f 90	jsr $01904f			jsr 	_UHConvert
.019033	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019035	20 4f 90	jsr $01904f			jsr 	_UHConvert
.019038	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01903a	20 4f 90	jsr $01904f			jsr 	_UHConvert
.01903d	5a		phy				phy 								; get length of new string
.01903e	a0 00		ldy #$00			ldy 	#0
.019040	b1 20		lda ($20),y			lda 	(zTempStr),y
.019042	7a		ply				ply
.019043	c9 00		cmp #$00			cmp 	#0
.019045	d0 05		bne $01904c			bne 	_UHExit 					; if it was non zero okay
.019047	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.019049	20 f1 91	jsr $0191f1			jsr 	WriteTempString
.01904c					_UHExit:
.01904c	4c 1a 91	jmp $01911a			jmp 	UnaryReturnTempStr 			; return new temporary string.
.01904f					_UHConvert:
.01904f	48		pha				pha
.019050	4a		lsr a				lsr 	a 							; do MSB
.019051	4a		lsr a				lsr 	a
.019052	4a		lsr a				lsr 	a
.019053	4a		lsr a				lsr 	a
.019054	20 58 90	jsr $019058			jsr 	_UHNibble
.019057	68		pla				pla 								; do LSB
.019058					_UHNibble:
.019058	29 0f		and #$0f			and 	#15 						; get nibble
.01905a	d0 0c		bne $019068			bne 	_UHNonZero
.01905c	5a		phy				phy									; get the length
.01905d	a0 00		ldy #$00			ldy 	#0
.01905f	b1 20		lda ($20),y			lda 	(zTempStr),y
.019061	7a		ply				ply
.019062	c9 00		cmp #$00			cmp 	#0 							; suppress leading zeros.
.019064	f0 0d		beq $019073			beq 	_UHExit2
.019066	a9 00		lda #$00			lda 	#0
.019068					_UHNonZero:
.019068	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.01906a	90 02		bcc $01906e			bcc 	_UHDigit
.01906c	69 06		adc #$06			adc 	#7-1
.01906e					_UHDigit:
.01906e	69 30		adc #$30			adc 	#48
.019070	20 f1 91	jsr $0191f1			jsr 	WriteTempString				; output.
.019073					_UHExit2:
.019073	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.019074					Unary_Dec:
.019074	20 88 8b	jsr $018b88			jsr 	EvaluateStringX 			; string parameter
.019077	20 86 91	jsr $019186			jsr 	CheckNextRParen 			; right bracket.
.01907a	5a		phy				phy
.01907b	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.01907d	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.01907f	f0 41		beq $0190c2			beq 	_UDFail 					; must fail if zero.
.019081	8d 98 03	sta $0398			sta 	SignCount 					; use SignCount as a counter
.019084	a9 00		lda #$00			lda 	#0 							; set result to zero integer.
.019086	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019088	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01908a	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01908c	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01908e	a9 01		lda #$01			lda 	#1
.019090	95 85		sta $85,x			sta 	XS_Type,x
.019092					_UDConvertLoop:
.019092	5a		phy				phy 								; shift mantissa left 4
.019093	a0 04		ldy #$04			ldy 	#4
.019095					_UDShift:
.019095	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.019097	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.019099	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.01909b	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.01909d	88		dey				dey
.01909e	d0 f5		bne $019095			bne 	_UDShift
.0190a0	7a		ply				ply
.0190a1	c8		iny				iny 								; next character
.0190a2	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; fetch it.
.0190a4	20 c5 90	jsr $0190c5			jsr 	ConvertUpper 				; convert to U/C
.0190a7	c9 30		cmp #$30			cmp 	#"0"
.0190a9	90 17		bcc $0190c2			bcc 	_UDFail
.0190ab	c9 3a		cmp #$3a			cmp 	#"9"+1
.0190ad	90 06		bcc $0190b5			bcc 	_UDOkay
.0190af	e9 37		sbc #$37			sbc 	#7+"0" 						; alpha fudge
.0190b1	c9 10		cmp #$10			cmp 	#16
.0190b3	b0 0d		bcs $0190c2			bcs 	_UDFail
.0190b5					_UDOkay:
.0190b5	29 0f		and #$0f			and 	#15 						; nibble only
.0190b7	15 80		ora $80,x			ora 	XS_Mantissa+0,x
.0190b9	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0190bb	ce 98 03	dec $0398			dec 	SignCount 					; do it for each character
.0190be	d0 d2		bne $019092			bne 	_UDConvertLoop
.0190c0	7a		ply				ply
.0190c1	60		rts				rts
.0190c2					_UDFail:
.0190c2	4c b0 84	jmp $0184b0			jmp 	BadParamError
.0190c5					ConvertUpper:
.0190c5	c9 61		cmp #$61			cmp 	#"a"
.0190c7	90 07		bcc $0190d0			bcc 	_CUExit
.0190c9	c9 7b		cmp #$7b			cmp 	#"z"+1
.0190cb	b0 03		bcs $0190d0			bcs 	_CUExit
.0190cd	38		sec				sec
.0190ce	e9 20		sbc #$20			sbc 	#32
.0190d0	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.0190d1					Unary_Chr:
.0190d1	20 7f 8b	jsr $018b7f			jsr 	EvaluateIntegerX			; numeric parameter
.0190d4	20 86 91	jsr $019186			jsr 	CheckNextRParen 			; right bracket.
.0190d7	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.0190d9	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.0190db	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.0190dd	d0 0d		bne $0190ec			bne 	_UCChar
.0190df	a9 01		lda #$01			lda 	#1 							; one character string
.0190e1	20 c6 91	jsr $0191c6			jsr 	AllocateTempString
.0190e4	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.0190e6	20 f1 91	jsr $0191f1			jsr 	WriteTempString
.0190e9	4c 1a 91	jmp $01911a			jmp 	UnaryReturnTempStr
.0190ec					_UCChar:
.0190ec	4c b0 84	jmp $0184b0			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.0190ef					Unary_Spc:
.0190ef	20 7f 8b	jsr $018b7f			jsr 	EvaluateIntegerX 			; numeric parameter
.0190f2	20 86 91	jsr $019186			jsr 	CheckNextRParen 			; right bracket.
.0190f5	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.0190f7	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.0190f9	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.0190fb	d0 1a		bne $019117			bne 	_USSize
.0190fd	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0190ff	c9 fe		cmp #$fe			cmp 	#maxString+1
.019101	b0 14		bcs $019117			bcs 	_USSize
.019103	48		pha				pha 								; save length
.019104	1a		inc a				inc 	a 							; allocate one more.
.019105	20 c6 91	jsr $0191c6			jsr 	AllocateTempString
.019108	68		pla				pla 								; get length
.019109	f0 0f		beq $01911a			beq 	UnaryReturnTempStr 			; return the current temp string
.01910b					_USLoop:
.01910b	48		pha				pha
.01910c	a9 20		lda #$20			lda 	#" "
.01910e	20 f1 91	jsr $0191f1			jsr 	WriteTempString
.019111	68		pla				pla
.019112	3a		dec a				dec 	a
.019113	d0 f6		bne $01910b			bne 	_USLoop
.019115	80 03		bra $01911a			bra 	UnaryReturnTempStr
.019117					_USSize:
.019117	4c b0 84	jmp $0184b0			jmp 	BadParamError
.01911a					UnaryReturnTempStr:
.01911a	a5 20		lda $20				lda 	zTempStr 					; copy temp string addr -> mantissa
.01911c	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01911e	a5 21		lda $21				lda 	zTempStr+1
.019120	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019122	a9 02		lda #$02			lda 	#2 							; set type to string
.019124	95 85		sta $85,x			sta 	XS_Type,x
.019126	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/65816.asm

.019127					MemRead:
.019127	8d 98 03	sta $0398			sta 	SignCount 					; save count
.01912a	a0 00		ldy #$00			ldy 	#0 							; start from here
.01912c	b7 1a		lda [$1a],y	_MLoop1:lda 	[zlTemp1],y 				; read the long address
.01912e	95 80		sta $80,x			sta 	XS_Mantissa,x 				; copy into mantissa
.019130	c8		iny				iny 								; next to copy
.019131	e8		inx				inx
.019132	cc 98 03	cpy $0398			cpy 	SignCount 					; do required # of bytes.
.019135	d0 f5		bne $01912c			bne 	_MLoop1
.019137	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/programend.asm

.019138					UpdateProgramEnd:
.019138	a9 00		lda #$00			lda 	#BasicProgram & $FF
.01913a	85 16		sta $16				sta 	zCodePtr+0
.01913c	a9 10		lda #$10			lda 	#BasicProgram >> 8
.01913e	85 17		sta $17				sta 	zCodePtr+1
.019140	a9 00		lda #$00			lda 	#0
.019142	85 18		sta $18				sta 	zCodePtr+2
.019144	85 19		sta $19				sta 	zCodePtr+3
.019146	a0 03		ldy #$03			ldy 	#3
.019148					_UPDLoop:
.019148	a0 00		ldy #$00			ldy 	#0
.01914a	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01914c	c9 00		cmp #$00			cmp 	#0 							; end if offset is zero.
.01914e	f0 0f		beq $01915f			beq 	_UPDFoundEnd
.019150	a0 00		ldy #$00			ldy 	#0 							; point to offset
.019152	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.019154	18		clc				clc
.019155	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.019157	85 16		sta $16				sta 	zCodePtr
.019159	90 02		bcc $01915d			bcc 	_SNLNoCarry
.01915b	e6 17		inc $17				inc 	zCodePtr+1
.01915d					_SNLNoCarry:
.01915d	80 e9		bra $019148			bra 	_UPDLoop
.01915f					_UPDFoundEnd:
.01915f	18		clc				clc 								; end of program 2 on.
.019160	a5 16		lda $16				lda 	zCodePtr
.019162	69 02		adc #$02			adc 	#2
.019164	8d 04 03	sta $0304			sta 	endOfProgram
.019167	a5 17		lda $17				lda 	zCodePtr+1
.019169	69 00		adc #$00			adc 	#0
.01916b	8d 05 03	sta $0305			sta 	endOfProgram+1
.01916e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.01916f					CheckNextToken:
.01916f	d7 16		cmp [$16],y			cmp 	[zCodePtr],y
.019171	d0 02		bne $019175			bne 	CTFail 						; no, then fail
.019173	c8		iny				iny
.019174	60		rts				rts
.019175					CTFail:
.019175	20 c1 84	jsr $0184c1			jsr ERR_Handler
>019178	4d 69 73 73 69 6e 67 20			.text "Missing token",0
>019180	74 6f 6b 65 6e 00
.019186					CheckNextRParen:
.019186	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019188	c9 be		cmp #$be			cmp 	#token_rparen
.01918a	d0 e9		bne $019175			bne 	CTFail
.01918c	c8		iny				iny
.01918d	60		rts				rts
.01918e					CheckNextComma:
.01918e	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019190	c9 bf		cmp #$bf			cmp 	#token_comma
.019192	d0 e1		bne $019175			bne 	CTFail
.019194	c8		iny				iny
.019195	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/concrete.asm

.019196					StringConcrete:
.019196	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; save source to zTemp1
.019198	85 10		sta $10				sta 	zTemp1
.01919a	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01919c	85 11		sta $11				sta 	zTemp1+1
.01919e	a0 00		ldy #$00			ldy 	#0 							; subtract the length+1 (clc) of the string.
.0191a0	18		clc				clc 								; from the string pointer
.0191a1	ad 00 03	lda $0300			lda 	StringPtr 					; and put in zTemp2 as well
.0191a4	f1 10		sbc ($10),y			sbc 	(zTemp1),y
.0191a6	8d 00 03	sta $0300			sta 	StringPtr
.0191a9	85 12		sta $12				sta 	zTemp2
.0191ab	ad 01 03	lda $0301			lda 	StringPtr+1
.0191ae	e9 00		sbc #$00			sbc 	#0
.0191b0	8d 01 03	sta $0301			sta 	StringPtr+1
.0191b3	85 13		sta $13				sta 	zTemp2+1
.0191b5	b1 10		lda ($10),y			lda 	(zTemp1),y 					; length add one for count
.0191b7	1a		inc a				inc 	a
.0191b8	aa		tax				tax
.0191b9	b1 10		lda ($10),y	_SCCopy:lda 	(zTemp1),y 					; copy whole thing including length
.0191bb	91 12		sta ($12),y			sta 	(zTemp2),y
.0191bd	c8		iny				iny
.0191be	ca		dex				dex
.0191bf	d0 f8		bne $0191b9			bne 	_SCCopy
.0191c1	a5 13		lda $13				lda 	zTemp2+1 					; return concrete string in AX
.0191c3	a6 12		ldx $12				ldx 	zTemp2
.0191c5	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.0191c6					AllocateTempString:
.0191c6	48		pha				pha 								; save required count.
.0191c7	a5 21		lda $21				lda 	zTempStr+1 					; check if initialised yet ?
.0191c9	d0 0b		bne $0191d6			bne 	_ATSInitialised
.0191cb	ad 00 03	lda $0300			lda 	StringPtr 					; set temporary string ptr 1 page below available
.0191ce	85 20		sta $20				sta 	zTempStr					; space, this is for strings to be concreted.
.0191d0	ad 01 03	lda $0301			lda 	StringPtr+1
.0191d3	3a		dec a				dec 	a
.0191d4	85 21		sta $21				sta 	zTempStr+1
.0191d6					_ATSInitialised:
.0191d6	68		pla				pla 								; get required count back.
.0191d7	49 ff		eor #$ff			eor 	#$FF 						; negate 2's complement.
.0191d9	1a		inc a				inc 	a
.0191da	18		clc				clc
.0191db	65 20		adc $20				adc 	zTempStr 					; "add" to the temp string pointer
.0191dd	85 20		sta $20				sta 	zTempStr
.0191df	a9 ff		lda #$ff			lda 	#$FF
.0191e1	65 21		adc $21				adc 	zTempStr+1
.0191e3	85 21		sta $21				sta 	zTempStr+1
.0191e5	a9 00		lda #$00			lda 	#0 							; clear temp string.
.0191e7	5a		phy				phy
.0191e8	a8		tay				tay
.0191e9	91 20		sta ($20),y			sta 	(zTempStr),y
.0191eb	7a		ply				ply
.0191ec	1a		inc a				inc 	a 							; reset the write index.
.0191ed	8d 99 03	sta $0399			sta 	TempStringWriteIndex
.0191f0	60		rts				rts
.0191f1					WriteTempString:
.0191f1	5a		phy				phy 								; save Y
.0191f2	ac 99 03	ldy $0399			ldy 	TempStringWriteIndex	 	; write position.
.0191f5	91 20		sta ($20),y			sta 	(zTempStr),y 				; write character out.
.0191f7	ee 99 03	inc $0399			inc 	TempStringWriteIndex 		; increment the write position.
.0191fa	98		tya				tya 								; unchanged Y is now length
.0191fb	a0 00		ldy #$00			ldy 	#0
.0191fd	91 20		sta ($20),y			sta 	(zTempStr),y
.0191ff	7a		ply				ply 								; restore Y and exit
.019200	60		rts				rts
.019201					CreateTempStringCopy:
.019201	da		phx				phx 								; save X
.019202	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019204	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.019205	20 c6 91	jsr $0191c6			jsr 	AllocateTempString 			; allocate memory for temporary string.
.019208	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01920a	c8		iny				iny
.01920b	3a		dec a				dec 	a 							; make the actual length in charactes
.01920c	3a		dec a				dec 	a
.01920d	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.01920f	81 20		sta ($20,x)			sta 	(zTempStr,x)
.019211	85 1a		sta $1a				sta 	zLTemp1 					; that's used as a count.
.019213	09 00		ora #$00			ora 	#0 							; if zero already, exit
.019215	f0 0e		beq $019225			beq 	_CTSCExit
.019217					_CTSCLoop:
.019217	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019219	c8		iny				iny
.01921a	5a		phy				phy 								; save in Y
.01921b	e8		inx				inx 								; bump index
.01921c	da		phx				phx 								; index into Y
.01921d	7a		ply				ply
.01921e	91 20		sta ($20),y			sta 	(zTempStr),y 				; save at index
.019220	7a		ply				ply 								; restore Y
.019221	c6 1a		dec $1a				dec 	zLTemp1 					; do for each character
.019223	d0 f2		bne $019217			bne 	_CTSCLoop
.019225					_CTSCExit:
.019225	fa		plx				plx 								; restore X
.019226	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/variables.asm

.019227					VariableFind:
.019227	20 92 92	jsr $019292			jsr 	VariableExtract 		; find out all about it ....
.01922a	20 2b 95	jsr $01952b			jsr 	VariableLocate 			; does it already exist ?
.01922d	b0 03		bcs $019232			bcs 	_VFExists 				; if so, use that.
.01922f	20 1e 93	jsr $01931e			jsr 	VariableCreate 			; otherwise create it.
.019232					_VFExists:
.019232	a5 24		lda $24				lda 	zVarType 				; is it still an array ?
.019234	29 01		and #$01			and 	#1
.019236	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.019238	d0 28		bne $019262			bne 	_VFSingleElement
.01923a					_VFNextIndex:
.01923a	a5 22		lda $22				lda 	zVarDataPtr 			; push the data ptr and type on the stack.
.01923c	48		pha				pha
.01923d	a5 23		lda $23				lda 	zVarDataPtr+1
.01923f	48		pha				pha
.019240	a5 24		lda $24				lda 	zVarType
.019242	48		pha				pha
.019243	20 7f 8b	jsr $018b7f			jsr 	EvaluateIntegerX 		; calculate the index.
.019246	68		pla				pla 							; restore and index.
.019247	85 24		sta $24				sta 	zVarType
.019249	68		pla				pla
.01924a	85 23		sta $23				sta 	zVarDataPtr+1
.01924c	68		pla				pla
.01924d	85 22		sta $22				sta 	zVarDataPtr
.01924f	20 a9 93	jsr $0193a9			jsr 	ArrayIndexFollow 		; do the index.
.019252	a5 24		lda $24				lda 	zVarType 				; is it still an array ??
.019254	29 01		and #$01			and 	#1
.019256	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.019258	d0 05		bne $01925f			bne 	_VFArrayDone 			; if so then exit.
.01925a	20 8e 91	jsr $01918e			jsr 	CheckNextComma 			; comma should follow
.01925d	80 db		bra $01923a			bra 	_VFNextIndex
.01925f					_VFArrayDone:
.01925f	20 86 91	jsr $019186			jsr 	CheckNextRParen 		; check closing right bracket.
.019262					_VFSingleElement:
.019262	60		rts				rts
.019263					VariableClear:
.019263	48		pha				pha 							; save registers
.019264	da		phx				phx
.019265	a2 00		ldx #$00			ldx 	#0 						; clear out the hash table.
.019267	8a		txa				txa
.019268	9d 2f 03	sta $032f,x	_VCLoop:sta 	HashTableBase,x
.01926b	e8		inx				inx
.01926c	e0 60		cpx #$60			cpx 	#HashTableEnd-HashTableBase
.01926e	d0 f8		bne $019268			bne 	_VCLoop
.019270	a9 00		lda #$00			lda 	#VariableMemory & $FF
.019272	8d 02 03	sta $0302			sta 	VarMemPtr
.019275	a9 20		lda #$20			lda 	#VariableMemory >> 8
.019277	8d 03 03	sta $0303			sta 	VarMemPtr+1
.01927a	fa		plx				plx 							; restore registers
.01927b	68		pla				pla
.01927c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/extract.asm

.01927d					VariableNameError:
.01927d	20 c1 84	jsr $0184c1			jsr ERR_Handler
>019280	42 61 64 20 56 61 72 69			.text "Bad Variable Name",0
>019288	61 62 6c 65 20 4e 61 6d 65 00
.019292					VariableExtract:
.019292	da		phx				phx 							; save X.
.019293	a9 ba		lda #$ba			lda 	#token_hashlParen  		; set the type to #( e.g. real array.
.019295	8d 8f 03	sta $038f			sta 	Var_Type
.019298	8d 90 03	sta $0390			sta 	Var_Hash 				; we initialise the hash with this. It doesn't matter
.01929b	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01929d	c9 00		cmp #$00			cmp 	#0 						; first one must be A-Z
.01929f	f0 dc		beq $01927d			beq 	VariableNameError
.0192a1	c9 1b		cmp #$1b			cmp 	#26+1
.0192a3	b0 d8		bcs $01927d			bcs 	VariableNameError
.0192a5	a2 ff		ldx #$ff			ldx 	#255 					; now copy it into the variable buffer.
.0192a7					_VECopyBuffer:
.0192a7	e8		inx				inx
.0192a8	e0 1f		cpx #$1f			cpx 	#31 					; too long
.0192aa	f0 d1		beq $01927d			beq 	VariableNameError
.0192ac	9d 0f 03	sta $030f,x			sta 	Var_Buffer,x 			; save character
.0192af	18		clc				clc  							; update the hash value for it.
.0192b0	6d 90 03	adc $0390			adc 	Var_Hash
.0192b3	8d 90 03	sta $0390			sta 	Var_Hash
.0192b6	c8		iny				iny
.0192b7	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0192b9	c9 00		cmp #$00			cmp 	#0 						; zero or token, end of variable
.0192bb	f0 0e		beq $0192cb			beq 	_VECopyEnd
.0192bd	30 0c		bmi $0192cb			bmi 	_VECopyEnd
.0192bf	c9 1b		cmp #$1b			cmp 	#26+1 					; A-Z continue copying
.0192c1	90 e4		bcc $0192a7			bcc 	_VECopyBuffer
.0192c3	c9 30		cmp #$30			cmp 	#"0" 					; 0-9 copy as well.
.0192c5	90 04		bcc $0192cb			bcc 	_VECopyEnd
.0192c7	c9 3a		cmp #$3a			cmp 	#"9"+1
.0192c9	90 dc		bcc $0192a7			bcc 	_VECopyBuffer
.0192cb					_VECopyEnd:
.0192cb	c8		iny				iny
.0192cc	c9 b7		cmp #$b7			cmp 	#token_Dollar 			; first type token.
.0192ce	90 04		bcc $0192d4			bcc 	_VEDefaultRequired
.0192d0	c9 bd		cmp #$bd			cmp 	#token_PercentLParen+1	; last type token.
.0192d2	90 0b		bcc $0192df			bcc 	_VEHaveType
.0192d4					_VEDefaultRequired:
.0192d4	c9 bd		cmp #$bd			cmp 	#token_LParen 			; if it ends in ( then use the real array
.0192d6	f0 04		beq $0192dc			beq 	_VESetType 				; default set above.
.0192d8	ce 8f 03	dec $038f			dec 	Var_Type 				; this changes that default to the variable default
.0192db	88		dey				dey
.0192dc					_VESetType:
.0192dc	ad 8f 03	lda $038f			lda 	Var_Type 				; get type ....
.0192df					_VEHaveType:
.0192df	8d 8f 03	sta $038f			sta 	Var_Type 				; save as type.
.0192e2	bd 0f 03	lda $030f,x			lda 	Var_Buffer,x 			; set bit 7 of name, marks the end.
.0192e5	09 80		ora #$80			ora 	#$80
.0192e7	9d 0f 03	sta $030f,x			sta 	Var_Buffer,x
.0192ea	e8		inx				inx 							; offset 3 => length 4.
.0192eb	8e 91 03	stx $0391			stx 	Var_Length 				; save length of variable name.
.0192ee	ad 8f 03	lda $038f			lda 	Var_Type 				; get offset of var type from first type token
.0192f1	38		sec				sec
.0192f2	e9 b7		sbc #$b7			sbc 	#token_Dollar
.0192f4	0a		asl a				asl 	a 						; multiply by 16. This requires HashTableSize
.0192f5	0a		asl a				asl 	a 						; in data.asm to be 8 (8 sets of links,2 bytes each)
.0192f6	0a		asl a				asl 	a
.0192f7	0a		asl a				asl 	a
.0192f8	8d 92 03	sta $0392			sta 	Var_HashAddress
.0192fb	ad 90 03	lda $0390			lda 	Var_Hash 				; get the hash
.0192fe	29 07		and #$07			and 	#(HashTableSize-1) 		; force into range 0-tableSize-1
.019300	0a		asl a				asl 	a 						; double it (2 bytes per entry) & clears carry
.019301	6d 92 03	adc $0392			adc 	Var_HashAddress 		; add table offset.
.019304	69 2f		adc #$2f			adc 	#HashTableBase & $FF 	; now the low byte of the actual table address
.019306	8d 92 03	sta $0392			sta 	Var_HashAddress
.019309	a2 05		ldx #$05			ldx 	#5 						; hash is 5 bytes (real)
.01930b	ad 8f 03	lda $038f			lda 	Var_Type
.01930e	c9 b9		cmp #$b9			cmp 	#token_Hash
.019310	f0 07		beq $019319			beq 	_VEHaveSize
.019312	ca		dex				dex
.019313	c9 bb		cmp #$bb			cmp 	#token_Percent 			; percent is 4 bytes (integer)
.019315	f0 02		beq $019319			beq 	_VEHaveSize
.019317	a2 02		ldx #$02			ldx 	#2 						; everything else is two.
.019319					_VEHaveSize:
.019319	8e 93 03	stx $0393			stx 	Var_DataSize
.01931c	fa		plx				plx
.01931d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varcreate.asm

.01931e					VariableCreate:
.01931e	da		phx				phx
.01931f	5a		phy				phy
.019320	ad 02 03	lda $0302			lda 	VarMemPtr 					; get address of next free into zTemp1
.019323	85 10		sta $10				sta 	zTemp1
.019325	ad 03 03	lda $0303			lda 	VarMemPtr+1
.019328	85 11		sta $11				sta 	zTemp1+1
.01932a	ad 93 03	lda $0393			lda 	Var_DataSize 				; bytes for the data bit
.01932d	18		clc				clc
.01932e	6d 91 03	adc $0391			adc 	Var_Length 					; add the length of the name
.019331	69 03		adc #$03			adc 	#3 							; 3 for the link and the hash.
.019333	6d 02 03	adc $0302			adc 	VarMemPtr 					; add to variable memory pointer
.019336	8d 02 03	sta $0302			sta 	VarMemPtr
.019339	90 03		bcc $01933e			bcc 	_VCNoCarry
.01933b	ee 03 03	inc $0303			inc 	VarMemPtr+1
.01933e					_VCNoCarry:
.01933e	ad 92 03	lda $0392			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.019341	85 12		sta $12				sta 	zTemp2
.019343	a9 03		lda #$03			lda 	#HashTableBase >> 8
.019345	85 13		sta $13				sta 	zTemp2+1
.019347	a0 00		ldy #$00			ldy 	#0 							; put current hash link in position.
.019349	b1 12		lda ($12),y			lda 	(zTemp2),y
.01934b	91 10		sta ($10),y			sta 	(zTemp1),y
.01934d	c8		iny				iny
.01934e	b1 12		lda ($12),y			lda 	(zTemp2),y
.019350	91 10		sta ($10),y			sta 	(zTemp1),y
.019352	c8		iny				iny
.019353	ad 90 03	lda $0390			lda 	Var_Hash 					; write the hash out.
.019356	91 10		sta ($10),y			sta 	(zTemp1),y
.019358	c8		iny				iny
.019359	a2 00		ldx #$00			ldx 	#0 							; copy the name out.
.01935b					_VCCopyName:
.01935b	bd 0f 03	lda $030f,x			lda 	Var_Buffer,x
.01935e	91 10		sta ($10),y			sta 	(zTemp1),y
.019360	e8		inx				inx
.019361	c8		iny				iny
.019362	ec 91 03	cpx $0391			cpx 	Var_Length
.019365	d0 f4		bne $01935b			bne 	_VCCopyName
.019367	5a		phy				phy 								; save the data offset.
.019368	ae 93 03	ldx $0393			ldx 	Var_DataSize 				; and write the data out.
.01936b	a9 00		lda #$00			lda 	#0 							; which is all zeroes.
.01936d					_VCClearData:
.01936d	91 10		sta ($10),y			sta 	(zTemp1),y
.01936f	c8		iny				iny
.019370	ca		dex				dex
.019371	d0 fa		bne $01936d			bne 	_VCClearData
.019373	68		pla				pla 								; offset to the data
.019374	18		clc				clc
.019375	65 10		adc $10				adc 	zTemp1 						; add to start and save as data pointer.
.019377	85 22		sta $22				sta 	zVarDataPtr
.019379	a5 11		lda $11				lda 	zTemp1+1
.01937b	69 00		adc #$00			adc 	#0
.01937d	85 23		sta $23				sta 	zVarDataPtr+1
.01937f	ad 8f 03	lda $038f			lda 	Var_Type 					; and set the type.
.019382	85 24		sta $24				sta 	zVarType
.019384	a5 10		lda $10				lda 	zTemp1 						; fix hash link to point to new record
.019386	a0 00		ldy #$00			ldy 	#0
.019388	91 12		sta ($12),y			sta 	(zTemp2),y
.01938a	c8		iny				iny
.01938b	a5 11		lda $11				lda 	zTemp1+1
.01938d	91 12		sta ($12),y			sta 	(zTemp2),y
.01938f	ad 8f 03	lda $038f			lda 	Var_Type 					; array ? if so create the empty one.
.019392	29 01		and #$01			and 	#1
.019394	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.019396	d0 0e		bne $0193a6			bne 	_VCNotArray
.019398	a2 00		ldx #$00			ldx 	#0 							; call recursive array creator
.01939a	20 40 94	jsr $019440			jsr 	ArrayCreate
.01939d	5a		phy				phy 								; save YA at zVarDataPtr
.01939e	a0 00		ldy #$00			ldy 	#0
.0193a0	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0193a2	c8		iny				iny
.0193a3	68		pla				pla
.0193a4	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0193a6					_VCNotArray:
.0193a6	7a		ply				ply
.0193a7	fa		plx				plx
.0193a8	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arrayidx.asm

.0193a9					ArrayIndexFollow:
.0193a9	5a		phy				phy
.0193aa	a0 00		ldy #$00			ldy 	#0 							; make zVarDataPtr point to the array.
.0193ac	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; e.g. it points to itself.
.0193ae	48		pha				pha
.0193af	c8		iny				iny
.0193b0	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.0193b2	85 23		sta $23				sta 	zVarDataPtr+1
.0193b4	68		pla				pla
.0193b5	85 22		sta $22				sta 	zVarDataPtr
.0193b7	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; MSB of 16 bit integer and bytes 2&3
.0193b9	29 80		and #$80			and 	#$80 						; must be zero.
.0193bb	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.0193bd	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.0193bf	d0 59		bne $01941a			bne 	_AIFError
.0193c1	a0 00		ldy #$00			ldy 	#0 							; calculate size - current - 1
.0193c3	18		clc				clc
.0193c4	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.0193c6	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.0193c8	c8		iny				iny
.0193c9	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.0193cb	08		php				php 								; clear bit 7 retaining borrow.
.0193cc	29 7f		and #$7f			and 	#$7F
.0193ce	28		plp				plp
.0193cf	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.0193d1	90 47		bcc $01941a			bcc 	_AIFError 					; eror if size-current < 0
.0193d3	b5 80		lda $80,x			lda  	XS_Mantissa+0,x 			; copy and double the index
.0193d5	0a		asl a				asl 	a 							; (e.g. index * 2)
.0193d6	85 10		sta $10				sta 	zTemp1
.0193d8	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0193da	2a		rol a				rol 	a
.0193db	85 11		sta $11				sta 	zTemp1+1
.0193dd	a0 01		ldy #$01			ldy 	#1 							; is this a data entry.
.0193df	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; if so, then type is unchanged, offset set
.0193e1	30 1d		bmi $019400			bmi 	_AIFCalculate
.0193e3	c6 24		dec $24				dec 	zVarType 					; converts from an array to a type.
.0193e5	a5 24		lda $24				lda 	zVarType 					; check that type
.0193e7	c9 b7		cmp #$b7			cmp 	#token_Dollar 				; if string, use x 2
.0193e9	f0 15		beq $019400			beq 	_AIFCalculate
.0193eb	06 10		asl $10				asl 	zTemp1			 			; double the index
.0193ed	26 11		rol $11				rol 	zTemp1+1					; (e.g. index * 4)
.0193ef	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if integer, use x 4
.0193f1	f0 0d		beq $019400			beq 	_AIFCalculate
.0193f3	18		clc				clc 								; add the original mantissa in again
.0193f4	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; which makes it x5, for float.
.0193f6	65 10		adc $10				adc 	zTemp1
.0193f8	85 10		sta $10				sta 	zTemp1
.0193fa	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0193fc	65 11		adc $11				adc 	zTemp1+1
.0193fe	85 11		sta $11				sta 	zTemp1+1
.019400					_AIFCalculate:
.019400	18		clc				clc 								; add index x 2,4 or 5 to base
.019401	a5 22		lda $22				lda 	zVarDataPtr
.019403	65 10		adc $10				adc 	zTemp1
.019405	85 22		sta $22				sta 	zVarDataPtr
.019407	a5 23		lda $23				lda 	zVarDataPtr+1
.019409	65 11		adc $11				adc 	zTemp1+1
.01940b	85 23		sta $23				sta 	zVarDataPtr+1
.01940d	18		clc				clc 								; add 2 more for the length prefix.
.01940e	a5 22		lda $22				lda 	zVarDataPtr
.019410	69 02		adc #$02			adc 	#2
.019412	85 22		sta $22				sta 	zVarDataPtr
.019414	90 02		bcc $019418			bcc 	_AIFNoBump
.019416	e6 23		inc $23				inc 	zVarDataPtr+1
.019418					_AIFNoBump:
.019418	7a		ply				ply
.019419	60		rts				rts
.01941a					_AIFError:
.01941a	20 c1 84	jsr $0184c1			jsr ERR_Handler
>01941d	42 61 64 20 61 72 72 61			.text "Bad array index",0
>019425	79 20 69 6e 64 65 78 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arraydef.asm

.01942d					ArrayResetDefault:
.01942d	a9 0b		lda #$0b			lda 	#11 						; 0..10 one array
.01942f	8d a1 03	sta $03a1			sta 	ArrayDef+0
.019432	a9 00		lda #$00			lda 	#0
.019434	8d a2 03	sta $03a2			sta 	ArrayDef+1
.019437	a9 ff		lda #$ff			lda 	#$FF
.019439	8d a3 03	sta $03a3			sta 	ArrayDef+2 					; $FFFF implies no second element.
.01943c	8d a4 03	sta $03a4			sta 	ArrayDef+3					; (test bit 7 of 2nd byte)
.01943f	60		rts				rts
.019440					ArrayCreate:
.019440	bd a1 03	lda $03a1,x			lda 	ArrayDef+0,x 				; put size x 2 in zTemp1
.019443	0a		asl a				asl 	a
.019444	85 10		sta $10				sta 	zTemp1
.019446	bd a2 03	lda $03a2,x			lda 	ArrayDef+1,x
.019449	2a		rol a				rol 	a
.01944a	85 11		sta $11				sta 	zTemp1+1
.01944c	bd a4 03	lda $03a4,x			lda 	ArrayDef+3,x 				; if this is the last element it's array of ptrs.
.01944f	10 22		bpl $019473			bpl 	_ACSized 					; if not multiply size x 2 (str) 4 (int) 5 (real)
.019451	ad 8f 03	lda $038f			lda 	Var_Type 					; check the type
.019454	c9 b8		cmp #$b8			cmp 	#token_DollarLParen 		; also if it is an array of strings $(
.019456	f0 1b		beq $019473			beq 	_ACSized
.019458	06 10		asl $10				asl 	zTemp1 						; double again
.01945a	26 11		rol $11				rol 	zTemp1+1
.01945c	b0 6f		bcs $0194cd			bcs 	ArrayIndexError 			; too large.
.01945e	c9 bc		cmp #$bc			cmp 	#token_PercentLParen 		; if %( four bytes/entry is enough.
.019460	f0 11		beq $019473			beq 	_ACSized
.019462	18		clc				clc 								; add original value x 5 for reals.
.019463	a5 10		lda $10				lda 	zTemp1
.019465	7d a1 03	adc $03a1,x			adc 	ArrayDef+0,x
.019468	85 10		sta $10				sta 	zTemp1
.01946a	a5 11		lda $11				lda 	zTemp1+1
.01946c	7d a2 03	adc $03a2,x			adc 	ArrayDef+1,x
.01946f	85 11		sta $11				sta 	zTemp1+1
.019471	b0 5a		bcs $0194cd			bcs 	ArrayIndexError
.019473					_ACSized:
.019473	18		clc				clc
.019474	a5 10		lda $10				lda 	zTemp1
.019476	69 02		adc #$02			adc 	#2
.019478	85 10		sta $10				sta 	zTemp1
.01947a	90 04		bcc $019480			bcc 	_ACNoBump
.01947c	e6 10		inc $10				inc 	zTemp1
.01947e	f0 4d		beq $0194cd			beq 	ArrayIndexError
.019480					_ACNoBump:
.019480	18		clc				clc
.019481	ad 02 03	lda $0302			lda 	VarMemPtr 					; add this allocated count to VarMemPtr
.019484	85 12		sta $12				sta 	zTemp2						; save start in zTemp2/zTemp3
.019486	85 14		sta $14				sta 	zTemp3
.019488	65 10		adc $10				adc 	zTemp1
.01948a	8d 02 03	sta $0302			sta 	VarMemPtr
.01948d	ad 03 03	lda $0303			lda 	VarMemPtr+1
.019490	85 13		sta $13				sta 	zTemp2+1
.019492	85 15		sta $15				sta 	zTemp3+1
.019494	65 11		adc $11				adc 	zTemp1+1
.019496	8d 03 03	sta $0303			sta 	VarMemPtr+1
.019499	85 11		sta $11				sta 	zTemp1+1
.01949b	b0 30		bcs $0194cd			bcs 	ArrayIndexError
.01949d	a0 00		ldy #$00			ldy 	#0							; write $00 out.
.01949f					_ACClear:
.01949f	98		tya				tya
.0194a0	91 12		sta ($12),y			sta 	(zTemp2),y
.0194a2	e6 12		inc $12				inc 	zTemp2
.0194a4	d0 02		bne $0194a8			bne 	_ACCBump
.0194a6	e6 13		inc $13				inc 	zTemp2+1
.0194a8					_ACCBump:
.0194a8	a5 12		lda $12				lda 	zTemp2
.0194aa	cd 02 03	cmp $0302			cmp 	VarMemPtr
.0194ad	d0 f0		bne $01949f			bne 	_ACClear
.0194af	a5 13		lda $13				lda 	zTemp2+1
.0194b1	cd 03 03	cmp $0303			cmp 	VarMemPtr+1
.0194b4	d0 e9		bne $01949f			bne 	_ACClear
.0194b6	a0 00		ldy #$00			ldy 	#0
.0194b8	bd a1 03	lda $03a1,x			lda 	ArrayDef+0,x 				; copy the size into the start
.0194bb	91 14		sta ($14),y			sta 	(zTemp3),y
.0194bd	c8		iny				iny
.0194be	bd a2 03	lda $03a2,x			lda 	ArrayDef+1,x
.0194c1	91 14		sta ($14),y			sta 	(zTemp3),y
.0194c3	bd a4 03	lda $03a4,x			lda 	ArrayDef+3,x 				; have we reached the end
.0194c6	10 18		bpl $0194e0			bpl 	ACCFillRecursive
.0194c8	a4 15		ldy $15				ldy 	zTemp3+1 					; return address
.0194ca	a5 14		lda $14				lda 	zTemp3
.0194cc	60		rts				rts
.0194cd					ArrayIndexError:
.0194cd	20 c1 84	jsr $0184c1			jsr ERR_Handler
>0194d0	42 61 64 20 61 72 72 61			.text "Bad array index",0
>0194d8	79 20 69 6e 64 65 78 00
.0194e0					ACCFillRecursive:
.0194e0	a9 ff		lda #$ff			lda 	#$FF 						; we mark the end, this is free space.
.0194e2	a0 00		ldy #$00			ldy 	#0 							; this is overwritten by size of next allocated
.0194e4	91 12		sta ($12),y			sta 	(zTemp2),y 					; array, but we might change that.
.0194e6	c8		iny				iny
.0194e7	b1 14		lda ($14),y			lda 	(zTemp3),y 					; set bit 15 of the max index indicating
.0194e9	09 80		ora #$80			ora 	#$80 						; an array of pointers
.0194eb	91 14		sta ($14),y			sta 	(zTemp3),y
.0194ed	a5 14		lda $14				lda 	zTemp3 						; push the start on the stack
.0194ef	48		pha				pha
.0194f0	a5 15		lda $15				lda 	zTemp3+1
.0194f2	48		pha				pha
.0194f3					_ACCFillLoop:
.0194f3	18		clc				clc
.0194f4	a5 14		lda $14				lda 	zTemp3 						; and work forwards.
.0194f6	69 02		adc #$02			adc 	#2
.0194f8	85 14		sta $14				sta 	zTemp3
.0194fa	90 02		bcc $0194fe			bcc 	_ACCSkip2
.0194fc	e6 15		inc $15				inc 	zTemp3+1
.0194fe					_ACCSkip2:
.0194fe	a0 00		ldy #$00			ldy 	#0 							; reached the end ?
.019500	b1 14		lda ($14),y			lda 	(zTemp3),y					; (looking for FF marker, everything else 00)
.019502	c8		iny				iny
.019503	11 14		ora ($14),y			ora 	(zTemp3),y
.019505	d0 21		bne $019528			bne 	_ACCExit
.019507	a5 14		lda $14				lda 	zTemp3 						; push zTemp3
.019509	48		pha				pha
.01950a	a5 15		lda $15				lda 	zTemp3+1
.01950c	48		pha				pha
.01950d	e8		inx				inx
.01950e	e8		inx				inx
.01950f	20 40 94	jsr $019440			jsr 	ArrayCreate 				; create array recursively.
.019512	ca		dex				dex
.019513	ca		dex				dex
.019514	85 12		sta $12				sta 	zTemp2 						; save A
.019516	68		pla				pla
.019517	85 15		sta $15				sta 	zTemp3+1 					; restore zTemp3
.019519	68		pla				pla
.01951a	85 14		sta $14				sta 	zTemp3
.01951c	98		tya				tya 								; write high bye from Y
.01951d	a0 01		ldy #$01			ldy 	#1
.01951f	91 14		sta ($14),y			sta 	(zTemp3),y
.019521	88		dey				dey 								; write low byte out.
.019522	a5 12		lda $12				lda 	zTemp2
.019524	91 14		sta ($14),y			sta 	(zTemp3),y
.019526	80 cb		bra $0194f3			bra 	_ACCFillLoop 				; and try again.
.019528					_ACCExit:
.019528	7a		ply				ply 								; restore the original address
.019529	68		pla				pla
.01952a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varfind.asm

.01952b					VariableLocate:
.01952b	da		phx				phx
.01952c	5a		phy				phy
.01952d	ad 92 03	lda $0392			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.019530	85 12		sta $12				sta 	zTemp2 						; points to first address.
.019532	a9 03		lda #$03			lda 	#HashTableBase >> 8
.019534	85 13		sta $13				sta 	zTemp2+1
.019536	a0 00		ldy #$00	_VLNext:ldy 	#0 							; get next link into AX
.019538	b1 12		lda ($12),y			lda 	(zTemp2),y
.01953a	aa		tax				tax
.01953b	c8		iny				iny
.01953c	b1 12		lda ($12),y			lda 	(zTemp2),y
.01953e	85 13		sta $13				sta 	zTemp2+1 					; save in zTemp
.019540	86 12		stx $12				stx 	zTemp2
.019542	05 12		ora $12				ora 	zTemp2 						; got zero
.019544	18		clc				clc
.019545	f0 25		beq $01956c			beq 	_VLExit 					; if so, then fail as end of chain.
.019547	c8		iny				iny 								; point to hash (offset + 2)
.019548	b1 12		lda ($12),y			lda 	(zTemp2),y
.01954a	cd 90 03	cmp $0390			cmp 	Var_Hash
.01954d	d0 e7		bne $019536			bne 	_VLNext 					; try next if different.
.01954f					_VLCompare:
.01954f	c8		iny				iny 								; next character
.019550	b1 12		lda ($12),y			lda 	(zTemp2),y 					; compare variable field against buffer.
.019552	d9 0c 03	cmp $030c,y			cmp 	Var_Buffer-3,y 				; the -3 is because name starts at 3.
.019555	d0 df		bne $019536			bne 	_VLNext 					; fail if different, try next.
.019557	0a		asl a				asl 	a 							; until end character (bit 7 set) matched
.019558	90 f5		bcc $01954f			bcc 	_VLCompare
.01955a	98		tya				tya
.01955b	38		sec				sec 								; add 1 as Y points to last character
.01955c	65 12		adc $12				adc 	zTemp2 						; add to the current address
.01955e	85 22		sta $22				sta 	zVarDataPtr
.019560	a5 13		lda $13				lda 	zTemp2+1
.019562	69 00		adc #$00			adc 	#0
.019564	85 23		sta $23				sta 	zVarDataPtr+1
.019566	ad 8f 03	lda $038f			lda 	Var_Type 					; and set the type.
.019569	85 24		sta $24				sta 	zVarType
.01956b	38		sec				sec 								; return CS
.01956c	7a		ply		_VLExit:ply
.01956d	fa		plx				plx
.01956e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/vargetset.asm

.01956f					VariableGet:
.01956f	5a		phy				phy
.019570	a0 00		ldy #$00			ldy 	#0 							; copy first two bytes
.019572	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019574	95 80		sta $80,x			sta 	XS_Mantissa,x
.019576	c8		iny				iny
.019577	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019579	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01957b	c8		iny				iny
.01957c	a5 24		lda $24				lda 	zVarType 					; if it is a string, set up for that.
.01957e	c9 b7		cmp #$b7			cmp 	#token_Dollar
.019580	f0 2c		beq $0195ae			beq 	_VGString
.019582	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; copy the next two bytes.
.019584	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019586	c8		iny				iny
.019587	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019589	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01958b	c8		iny				iny
.01958c	a9 01		lda #$01			lda 	#1 							; set type to 1.
.01958e	95 85		sta $85,x			sta 	XS_Type,x
.019590	a5 24		lda $24				lda 	zVarType
.019592	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if it is a %, then exit with default integer.
.019594	f0 28		beq $0195be			beq 	_VGExit
.019596	a9 40		lda #$40			lda 	#$40 						; set type byte to zero
.019598	95 85		sta $85,x			sta 	XS_Type,x 					; which is the code for zero/float.
.01959a	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; the last value to copy is the exponent.
.01959c	95 84		sta $84,x			sta 	XS_Exponent,x
.01959e	f0 1e		beq $0195be			beq 	_VGExit 					; if exponent is zero ... it's zero.
.0195a0	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; the sign bit is the top mantissa bit.
.0195a2	48		pha				pha
.0195a3	29 80		and #$80			and 	#$80
.0195a5	95 85		sta $85,x			sta 	XS_Type,x 					; this is the type byte.
.0195a7	68		pla				pla
.0195a8	09 80		ora #$80			ora 	#$80 						; set the MSB as you would expect.
.0195aa	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; so it's a normalised float.
.0195ac	80 10		bra $0195be			bra 	_VGExit
.0195ae					_VGString:
.0195ae	a9 02		lda #$02			lda 	#2 							; set type to 2, a string
.0195b0	95 85		sta $85,x			sta 	XS_Type,x
.0195b2	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; is the value there $0000
.0195b4	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.0195b6	d0 06		bne $0195be			bne 	_VGExit 					; if not, exit.
.0195b8	85 25		sta $25				sta 	zNullString 				; make zNullString a 00 string.
.0195ba	a9 25		lda #$25			lda 	#zNullString
.0195bc	95 80		sta $80,x			sta 	XS_Mantissa,x 				; make it point to it.
.0195be					_VGExit:
.0195be	7a		ply				ply
.0195bf	60		rts				rts
.0195c0					VariableSet:
.0195c0	b5 85		lda $85,x			lda 	XS_Type,x 					; is the result a string
.0195c2	29 02		and #$02			and 	#2 							; if so, it has to be
.0195c4	d0 4b		bne $019611			bne 	_VSString
.0195c6	a5 24		lda $24				lda 	zVarType 					; if type is $ there's an error.
.0195c8	c9 b7		cmp #$b7			cmp 	#token_Dollar
.0195ca	f0 42		beq $01960e			beq 	_VSBadType
.0195cc	c9 bb		cmp #$bb			cmp 	#token_Percent 				; type convert to float/int
.0195ce	f0 05		beq $0195d5			beq 	_VSMakeInt
.0195d0	20 f9 9a	jsr $019af9			jsr 	FPUToFloat
.0195d3	80 03		bra $0195d8			bra 	_VSCopy
.0195d5					_VSMakeInt:
.0195d5	20 45 9b	jsr $019b45			jsr 	FPUToInteger
.0195d8					_VSCopy:
.0195d8	5a		phy				phy
.0195d9	a0 00		ldy #$00			ldy 	#0 							; copy mantissa to target.
.0195db	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0195dd	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0195df	c8		iny				iny
.0195e0	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0195e2	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0195e4	c8		iny				iny
.0195e5	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0195e7	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0195e9	c8		iny				iny
.0195ea	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.0195ec	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0195ee	a5 24		lda $24				lda 	zVarType 					; if target is integer, alrady done.
.0195f0	c9 bb		cmp #$bb			cmp 	#token_Percent
.0195f2	f0 18		beq $01960c			beq 	_VSExit
.0195f4	b5 85		lda $85,x			lda 	XS_Type,x 					; get the sign bit into carry flag.
.0195f6	0a		asl a				asl 	a
.0195f7	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; shift the sign into the mantissa high.
.0195f9	08		php				php
.0195fa	0a		asl a				asl 	a
.0195fb	28		plp				plp
.0195fc	6a		ror a				ror 	a
.0195fd	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0195ff	c8		iny				iny
.019600	b5 84		lda $84,x			lda 	XS_Exponent,x 				; copy the exponent in
.019602	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019604	34 85		bit $85,x			bit 	XS_Type,x 					; if the result is non zero
.019606	50 04		bvc $01960c			bvc 	_VSExit
.019608	a9 00		lda #$00			lda 	#00 						; zero exponent indicating 0.
.01960a	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.01960c					_VSExit:
.01960c	7a		ply				ply
.01960d	60		rts				rts
.01960e					_VSBadType:
.01960e	4c a2 84	jmp $0184a2			jmp 	TypeError
.019611					_VSString:
.019611	a5 24		lda $24				lda 	zVarType 					; type must be $
.019613	c9 b7		cmp #$b7			cmp 	#token_Dollar
.019615	d0 f7		bne $01960e			bne 	_VSBadType
.019617	da		phx				phx
.019618	5a		phy				phy
.019619	20 96 91	jsr $019196			jsr 	StringConcrete 				; concrete the string in the mantissa -> AX
.01961c	a0 01		ldy #$01			ldy 	#1 							; save high byte
.01961e	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019620	88		dey				dey 								; save low byte
.019621	8a		txa				txa
.019622	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019624	7a		ply				ply 								; and exit.
.019625	fa		plx				plx
.019626	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.019627					MulInteger32:
.019627	b5 80		lda $80,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.019629	95 8c		sta $8c,x			sta 	XS3_Mantissa,x
.01962b	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01962d	95 8d		sta $8d,x			sta 	XS3_Mantissa+1,x
.01962f	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019631	95 8e		sta $8e,x			sta 	XS3_Mantissa+2,x
.019633	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019635	95 8f		sta $8f,x			sta 	XS3_Mantissa+3,x
.019637	a9 00		lda #$00			lda 	#0
.019639	95 80		sta $80,x			sta 	XS_Mantissa+0,x 				; zero +0
.01963b	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01963d	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01963f	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019641					_BFMMultiply:
.019641	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.019643	29 01		and #$01			and 	#1
.019645	f0 03		beq $01964a			beq 	_BFMNoAdd
.019647	20 1d 8d	jsr $018d1d			jsr 	AddInteger32
.01964a					_BFMNoAdd:
.01964a	16 86		asl $86,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.01964c	36 87		rol $87,x			rol 	XS2_Mantissa+1,x
.01964e	36 88		rol $88,x			rol 	XS2_Mantissa+2,x
.019650	36 89		rol $89,x			rol 	XS2_Mantissa+3,x
.019652	56 8f		lsr $8f,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.019654	76 8e		ror $8e,x			ror 	XS3_Mantissa+2,x
.019656	76 8d		ror $8d,x			ror 	XS3_Mantissa+1,x
.019658	76 8c		ror $8c,x			ror 	XS3_Mantissa,x
.01965a	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.01965c	15 8d		ora $8d,x			ora 	XS3_Mantissa+1,x
.01965e	15 8e		ora $8e,x			ora 	XS3_Mantissa+2,x
.019660	15 8f		ora $8f,x			ora 	XS3_Mantissa+3,x
.019662	d0 dd		bne $019641			bne 	_BFMMultiply
.019664	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.019665					DivInteger32:
.019665	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; check for /0
.019667	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.019669	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.01966b	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.01966d	d0 14		bne $019683			bne 	_BFDOkay
.01966f	20 c1 84	jsr $0184c1			jsr ERR_Handler
>019672	44 69 76 69 73 69 6f 6e			.text "Division by Zero",0
>01967a	20 62 79 20 5a 65 72 6f 00
.019683					_BFDOkay:
.019683	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.019685	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.019687	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.019689	85 1c		sta $1c				sta 	zLTemp1+2
.01968b	85 1d		sta $1d				sta 	zLTemp1+3
.01968d	8d 98 03	sta $0398			sta 	SignCount 					; Count of signs.
.019690	20 e7 96	jsr $0196e7			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.019693	da		phx				phx
.019694	e8		inx				inx
.019695	e8		inx				inx
.019696	e8		inx				inx
.019697	e8		inx				inx
.019698	e8		inx				inx
.019699	e8		inx				inx
.01969a	20 e7 96	jsr $0196e7			jsr 	CheckIntegerNegate
.01969d	fa		plx				plx
.01969e	5a		phy				phy 								; Y is the counter
.01969f	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.0196a1					_BFDLoop:
.0196a1	16 80		asl $80,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.0196a3	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.0196a5	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.0196a7	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.0196a9	26 1a		rol $1a				rol 	zLTemp1
.0196ab	26 1b		rol $1b				rol 	zLTemp1+1
.0196ad	26 1c		rol $1c				rol 	zLTemp1+2
.0196af	26 1d		rol $1d				rol 	zLTemp1+3
.0196b1	38		sec				sec
.0196b2	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.0196b4	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.0196b6	48		pha				pha
.0196b7	a5 1b		lda $1b				lda 	zLTemp1+1
.0196b9	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.0196bb	48		pha				pha
.0196bc	a5 1c		lda $1c				lda 	zLTemp1+2
.0196be	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.0196c0	48		pha				pha
.0196c1	a5 1d		lda $1d				lda 	zLTemp1+3
.0196c3	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.0196c5	90 13		bcc $0196da			bcc 	_BFDNoAdd
.0196c7	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.0196c9	68		pla				pla
.0196ca	85 1c		sta $1c				sta 	zLTemp1+2
.0196cc	68		pla				pla
.0196cd	85 1b		sta $1b				sta 	zLTemp1+1
.0196cf	68		pla				pla
.0196d0	85 1a		sta $1a				sta 	zLTemp1+0
.0196d2	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.0196d4	09 01		ora #$01			ora 	#1
.0196d6	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0196d8	80 03		bra $0196dd			bra 	_BFDNext
.0196da					_BFDNoAdd:
.0196da	68		pla				pla 								; Throw away the intermediate calculations
.0196db	68		pla				pla
.0196dc	68		pla				pla
.0196dd					_BFDNext:
.0196dd	88		dey				dey
.0196de	d0 c1		bne $0196a1			bne 	_BFDLoop
.0196e0	7a		ply				ply 								; restore Y and exit
.0196e1	4e 98 03	lsr $0398			lsr 	SignCount 					; if sign count odd,
.0196e4	b0 06		bcs $0196ec			bcs		IntegerNegateAlways 			; negate the result
.0196e6	60		rts				rts
.0196e7					CheckIntegerNegate:
.0196e7	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.0196e9	30 01		bmi $0196ec			bmi 	IntegerNegateAlways
.0196eb	60		rts				rts
.0196ec					IntegerNegateAlways:
.0196ec	ee 98 03	inc $0398			inc 	SignCount
.0196ef	38		sec				sec
.0196f0	a9 00		lda #$00			lda 	#0
.0196f2	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.0196f4	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0196f6	a9 00		lda #$00			lda 	#0
.0196f8	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.0196fa	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0196fc	a9 00		lda #$00			lda 	#0
.0196fe	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.019700	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019702	a9 00		lda #$00			lda 	#0
.019704	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.019706	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019708	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.019709					INTToString:
.019709	48		pha				pha
.01970a	5a		phy				phy
.01970b	b5 83		lda $83,x			lda 		XS_Mantissa+3,x 		; check -ve
.01970d	10 08		bpl $019717			bpl 		_ITSNotMinus
.01970f	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.019711	20 ab 97	jsr $0197ab			jsr 		ITSOutputCharacter
.019714	20 ec 96	jsr $0196ec			jsr 		IntegerNegateAlways 	; negate the number.
.019717					_ITSNotMinus:
.019717	a9 00		lda #$00			lda 		#0
.019719	8d 94 03	sta $0394			sta 		NumSuppress 			; clear the suppression flag.
.01971c	8a		txa				txa 								; use Y for the mantissa index.
.01971d	a8		tay				tay
.01971e	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.019720					_ITSNextSubtractor:
.019720	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.019722	8d 95 03	sta $0395			sta 		NumConvCount
.019725					_ITSSubtract:
.019725	38		sec				sec
.019726	b9 80 00	lda $0080,y			lda 		XS_Mantissa,y 			; subtract number and push on stack
.019729	ff 87 97 01	sbc $019787,x			sbc 		_ITSSubtractors+0,x
.01972d	48		pha				pha
.01972e	b9 81 00	lda $0081,y			lda 		XS_Mantissa+1,y
.019731	ff 88 97 01	sbc $019788,x			sbc 		_ITSSubtractors+1,x
.019735	48		pha				pha
.019736	b9 82 00	lda $0082,y			lda 		XS_Mantissa+2,y
.019739	ff 89 97 01	sbc $019789,x			sbc 		_ITSSubtractors+2,x
.01973d	48		pha				pha
.01973e	b9 83 00	lda $0083,y			lda 		XS_Mantissa+3,y
.019741	ff 8a 97 01	sbc $01978a,x			sbc 		_ITSSubtractors+3,x
.019745	90 14		bcc $01975b			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.019747	99 83 00	sta $0083,y			sta 		XS_Mantissa+3,y 		; save subtract off stack
.01974a	68		pla				pla
.01974b	99 82 00	sta $0082,y			sta 		XS_Mantissa+2,y
.01974e	68		pla				pla
.01974f	99 81 00	sta $0081,y			sta 		XS_Mantissa+1,y
.019752	68		pla				pla
.019753	99 80 00	sta $0080,y			sta 		XS_Mantissa+0,y
.019756	ee 95 03	inc $0395			inc 		NumConvCount 			; bump count.
.019759	80 ca		bra $019725			bra 		_ITSSubtract 			; go round again.
.01975b					_ITSCantSubtract:
.01975b	68		pla				pla 								; throw away interim answers
.01975c	68		pla				pla
.01975d	68		pla				pla
.01975e	ad 95 03	lda $0395			lda 		NumConvCount 			; if not zero then no suppression check
.019761	c9 30		cmp #$30			cmp 		#"0"
.019763	d0 05		bne $01976a			bne 		_ITSOutputDigit
.019765	ad 94 03	lda $0394			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.019768	10 09		bpl $019773			bpl	 		_ITSGoNextSubtractor
.01976a					_ITSOutputDigit:
.01976a	ce 94 03	dec $0394			dec 		NumSuppress 			; suppression check will be non-zero.
.01976d	ad 95 03	lda $0395			lda 		NumConvCount 			; count of subtractions
.019770	20 ab 97	jsr $0197ab			jsr 		ITSOutputCharacter 		; output it.
.019773					_ITSGoNextSubtractor:
.019773	e8		inx				inx 								; next dword
.019774	e8		inx				inx
.019775	e8		inx				inx
.019776	e8		inx				inx
.019777	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.019779	d0 a5		bne $019720			bne 		_ITSNextSubtractor 		; do all the subtractors.
.01977b	98		tya				tya 								; X is back as the mantissa index
.01977c	aa		tax				tax
.01977d	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.01977f	09 30		ora #$30			ora 		#"0"
.019781	20 ab 97	jsr $0197ab			jsr 		ITSOutputCharacter
.019784	7a		ply				ply 								; and exit
.019785	68		pla				pla
.019786	60		rts				rts
.019787					_ITSSubtractors:
>019787	00 ca 9a 3b					.dword 		1000000000
>01978b	00 e1 f5 05					.dword 		100000000
>01978f	80 96 98 00					.dword 		10000000
>019793	40 42 0f 00					.dword 		1000000
>019797	a0 86 01 00					.dword 		100000
>01979b	10 27 00 00					.dword 		10000
>01979f	e8 03 00 00					.dword 		1000
>0197a3	64 00 00 00					.dword 		100
>0197a7	0a 00 00 00					.dword 		10
.0197ab					_ITSSubtractorsEnd:
.0197ab					ITSOutputCharacter:
.0197ab	48		pha				pha
.0197ac	da		phx				phx
.0197ad	ae 0e 03	ldx $030e			ldx 	NumBufX 					; save digit
.0197b0	9d 0f 03	sta $030f,x			sta 	Num_Buffer,x
.0197b3	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.0197b5	9d 10 03	sta $0310,x			sta 	Num_Buffer+1,x
.0197b8	ee 0e 03	inc $030e			inc 	NumBufX						; bump pointer.
.0197bb	fa		plx				plx
.0197bc	68		pla				pla
.0197bd	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.0197be					IntFromString:
.0197be	a0 00		ldy #$00			ldy 	#0
.0197c0	8c 96 03	sty $0396			sty 	ExpTemp 					; this is the converted digit count.
.0197c3					IntFromStringY:
.0197c3	48		pha				pha
.0197c4	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.0197c6	95 80		sta $80,x			sta 	XS_Mantissa,x
.0197c8	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0197ca	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0197cc	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0197ce	a9 01		lda #$01			lda 	#1
.0197d0	95 85		sta $85,x			sta 	XS_Type,x
.0197d2					_IFSLoop:
.0197d2	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.0197d4	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.0197d6	90 4e		bcc $019826			bcc 	_IFSExit
.0197d8	c9 3a		cmp #$3a			cmp 	#"9"+1
.0197da	b0 4a		bcs $019826			bcs 	_IFSExit
.0197dc	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.0197de	c9 0c		cmp #$0c			cmp 	#12
.0197e0	b0 4e		bcs $019830			bcs 	_IFSOverflow
.0197e2	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.0197e4	48		pha				pha
.0197e5	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0197e7	48		pha				pha
.0197e8	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0197ea	48		pha				pha
.0197eb	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0197ed	48		pha				pha
.0197ee	20 45 98	jsr $019845			jsr 	IFSX1ShiftLeft 				; double
.0197f1	20 45 98	jsr $019845			jsr 	IFSX1ShiftLeft 				; x 4
.0197f4	18		clc				clc 								; add saved value x 5
.0197f5	68		pla				pla
.0197f6	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.0197f8	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0197fa	68		pla				pla
.0197fb	75 81		adc $81,x			adc 	XS_Mantissa+1,x
.0197fd	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0197ff	68		pla				pla
.019800	75 82		adc $82,x			adc 	XS_Mantissa+2,x
.019802	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019804	68		pla				pla
.019805	75 83		adc $83,x			adc 	XS_Mantissa+3,x
.019807	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019809	20 45 98	jsr $019845			jsr 	IFSX1ShiftLeft 				; x 10
.01980c	ee 96 03	inc $0396			inc 	ExpTemp 					; bump count of digits processed.
.01980f	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.019811	29 0f		and #$0f			and 	#15
.019813	c8		iny				iny
.019814	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.019816	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019818	90 b8		bcc $0197d2			bcc 	_IFSLoop
.01981a	f6 81		inc $81,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.01981c	d0 b4		bne $0197d2			bne 	_IFSLoop
.01981e	f6 82		inc $82,x			inc 	XS_Mantissa+2,x
.019820	d0 b0		bne $0197d2			bne 	_IFSLoop
.019822	f6 83		inc $83,x			inc 	XS_Mantissa+3,x
.019824	80 ac		bra $0197d2			bra 	_IFSLoop
.019826					_IFSExit:
.019826	98		tya				tya 								; get offset
.019827					_IFSOkay:
.019827	38		sec				sec
.019828	ad 96 03	lda $0396			lda 	ExpTemp
.01982b	f0 01		beq $01982e			beq 	_IFSSkipFail
.01982d	18		clc				clc
.01982e					_IFSSkipFail:
.01982e	68		pla				pla 								; and exit.
.01982f	60		rts				rts
.019830					_IFSOverflow:
.019830	20 c1 84	jsr $0184c1			jsr 	ERR_Handler
>019833	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>01983b	20 6f 76 65 72 66 6c 6f 77 00
.019845					IFSX1ShiftLeft:
.019845	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.019847	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.019849	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.01984b	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.01984d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.01984e					FPSubtract:
.01984e	48		pha				pha
.01984f	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.019851	49 80		eor #$80			eor 	#$80
.019853	95 8b		sta $8b,x			sta 	XS2_Type,x
.019855	68		pla				pla 								; --- and fall through ---
.019856					FPAdd:
.019856	48		pha				pha
.019857	b5 85		lda $85,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.019859	d0 05		bne $019860			bne 	_FPA_NegativeLHS
.01985b	20 77 98	jsr $019877			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.01985e	68		pla				pla
.01985f	60		rts				rts
.019860					_FPA_NegativeLHS:
.019860	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.019862	49 80		eor #$80			eor 	#$80
.019864	95 85		sta $85,x			sta 	XS_Type,x
.019866	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of B and add
.019868	49 80		eor #$80			eor 	#$80
.01986a	95 8b		sta $8b,x			sta 	XS2_Type,x
.01986c	20 77 98	jsr $019877			jsr 	FPAdd_Worker 				; do the add calculation.
.01986f	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 back
.019871	49 80		eor #$80			eor 	#$80
.019873	95 85		sta $85,x			sta 	XS_Type,x
.019875	68		pla				pla
.019876	60		rts				rts
.019877					FPAdd_Worker:
.019877	34 8b		bit $8b,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.019879	70 07		bvs $019882			bvs 	_FPAWExit 					; no change.
.01987b	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.01987d	50 07		bvc $019886			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.01987f	20 b7 9a	jsr $019ab7			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.019882					_FPAWExit:
.019882	20 26 9b	jsr $019b26			jsr 	FPUNormalise 				; normalise the result.
.019885	60		rts				rts
.019886					_FPAWMakeSame:
.019886	b5 84		lda $84,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.019888	38		sec				sec
.019889	f5 8a		sbc $8a,x			sbc	 	XS2_Exponent,x 				; using subtraction
.01988b	f0 16		beq $0198a3			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.01988d	da		phx				phx 								; save X
.01988e	90 06		bcc $019896			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.019890	e8		inx				inx
.019891	e8		inx				inx
.019892	e8		inx				inx
.019893	e8		inx				inx
.019894	e8		inx				inx
.019895	e8		inx				inx
.019896					_FPAWShiftA:
.019896	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.019898	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.01989a	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01989c	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01989e	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.0198a0	fa		plx				plx 								; restore original X
.0198a1	80 e3		bra $019886			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.0198a3					_FPAW_DoArithmetic:
.0198a3	34 8b		bit $8b,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.0198a5	30 28		bmi $0198cf			bmi 	_FPAW_BNegative
.0198a7	18		clc				clc
.0198a8	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0198aa	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.0198ac	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0198ae	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0198b0	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.0198b2	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0198b4	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0198b6	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.0198b8	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0198ba	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.0198bc	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.0198be	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0198c0	90 c0		bcc $019882			bcc 	_FPAWExit 					; no carry.
.0198c2	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.0198c4	38		sec				sec
.0198c5	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.0198c7	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.0198c9	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.0198cb	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.0198cd	80 b3		bra $019882			bra 	_FPAWExit
.0198cf					_FPAW_BNegative:
.0198cf	38		sec				sec
.0198d0	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0198d2	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.0198d4	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0198d6	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0198d8	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.0198da	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0198dc	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0198de	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.0198e0	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0198e2	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.0198e4	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.0198e6	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0198e8	b0 09		bcs $0198f3			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.0198ea	20 dd 9a	jsr $019add			jsr 	FPUNegateInteger			; negate the mantissa
.0198ed	b5 85		lda $85,x			lda 	XS_Type,x 					; flip result sign
.0198ef	49 80		eor #$80			eor 	#$80
.0198f1	95 85		sta $85,x			sta 	XS_Type,x
.0198f3					_FPAWGoExit:
.0198f3	4c 82 98	jmp $019882			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.0198f6					FPD_IsDivZero:
.0198f6	20 c1 84	jsr $0184c1			jsr ERR_Handler
>0198f9	44 69 76 69 73 69 6f 6e			.text "Division by zero",0
>019901	20 62 79 20 7a 65 72 6f 00
.01990a					FPDivide:
.01990a	48		pha				pha
.01990b	5a		phy				phy
.01990c	34 8b		bit $8b,x			bit 	XS2_Type,x 					; check if division by zero
.01990e	70 e6		bvs $0198f6			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.019910	34 85		bit $85,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.019912	f0 03		beq $019917			beq 	_FPDCalculateExp
.019914					_FPD_Exit:
.019914	7a		ply				ply
.019915	68		pla				pla
.019916	60		rts				rts
.019917					_FPDCalculateExp:
.019917	b5 8a		lda $8a,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.019919	49 ff		eor #$ff			eor 	#$FF
.01991b	1a		inc a				inc 	a
.01991c	95 8a		sta $8a,x			sta 	XS2_Exponent,x
.01991e	20 ee 99	jsr $0199ee			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.019921	18		clc				clc 	 							; add 1 to the resulting exponent
.019922	69 01		adc #$01			adc 	#1
.019924	b0 54		bcs $01997a			bcs 	_FPD_Overflow 				; which can overflow.
.019926	95 84		sta $84,x			sta 	XS_Exponent,x
.019928	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.01992a	85 1a		sta $1a				sta 	zLTemp1+0
.01992c	85 1b		sta $1b				sta 	zLTemp1+1
.01992e	85 1c		sta $1c				sta 	zLTemp1+2
.019930	85 1d		sta $1d				sta 	zLTemp1+3
.019932	a0 20		ldy #$20			ldy 	#32 						; times round.
.019934					_FPD_Loop:
.019934	38		sec				sec 								; calculate X1-X2 stacking result because we might
.019935	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; not save it.
.019937	f5 86		sbc $86,x			sbc 	XS2_Mantissa,x
.019939	48		pha				pha
.01993a	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01993c	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.01993e	48		pha				pha
.01993f	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019941	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.019943	48		pha				pha
.019944	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019946	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.019948	90 13		bcc $01995d			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.01994a	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; save results out to A
.01994c	68		pla				pla
.01994d	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01994f	68		pla				pla
.019950	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019952	68		pla				pla
.019953	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019955	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.019957	09 80		ora #$80			ora 	#$80
.019959	85 1d		sta $1d				sta 	zLTemp1+3
.01995b	80 03		bra $019960			bra 	_FPD_Rotates
.01995d					_FPD_NoSubtract:
.01995d	68		pla				pla 								; throw away unwanted results
.01995e	68		pla				pla
.01995f	68		pla				pla
.019960					_FPD_Rotates:
.019960	56 89		lsr $89,x			lsr 	3+XS2_Mantissa,x
.019962	76 88		ror $88,x			ror 	2+XS2_Mantissa,x
.019964	76 87		ror $87,x			ror 	1+XS2_Mantissa,x
.019966	76 86		ror $86,x			ror 	0+XS2_Mantissa,x
.019968	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.01996a	26 1b		rol $1b				rol 	zLTemp1+1
.01996c	26 1c		rol $1c				rol 	zLTemp1+2
.01996e	26 1d		rol $1d				rol 	zLTemp1+3
.019970	90 02		bcc $019974			bcc 	_FPD_NoCarry
.019972	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.019974					_FPD_NoCarry:
.019974	88		dey				dey 								; do 32 times
.019975	d0 bd		bne $019934			bne 	_FPD_Loop
.019977	4c d2 99	jmp $0199d2			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.01997a					_FPD_Overflow:
.01997a	4c 83 9b	jmp $019b83			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.01997d					FPMultiply:
.01997d	48		pha				pha
.01997e	5a		phy				phy
.01997f	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.019981	70 07		bvs $01998a			bvs 	_FPM_Exit
.019983	34 8b		bit $8b,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.019985	50 06		bvc $01998d			bvc 	_FPM_CalcExponent
.019987	20 b7 9a	jsr $019ab7			jsr 	FPUCopyX2ToX1
.01998a					_FPM_Exit:
.01998a	7a		ply				ply
.01998b	68		pla				pla
.01998c	60		rts				rts
.01998d					_FPM_CalcExponent:
.01998d	18		clc				clc
.01998e	20 ee 99	jsr $0199ee			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.019991	95 84		sta $84,x			sta 	XS_Exponent,x 				; save the result.
.019993	a9 00		lda #$00			lda 	#0
.019995	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.019997	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.019999	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.01999b	85 1d		sta $1d				sta 	zLTemp1+3
.01999d	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.01999f					_FPM_Loop:
.01999f	b5 80		lda $80,x			lda 	XS_Mantissa,x				; check LSB of long product
.0199a1	29 01		and #$01			and 	#1
.0199a3	18		clc				clc 								; clear carry for the long rotate.
.0199a4	f0 19		beq $0199bf			beq 	_FPM_NoAddition
.0199a6	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.0199a7	a5 1a		lda $1a				lda 	zLTemp1+0
.0199a9	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.0199ab	85 1a		sta $1a				sta 	zLTemp1+0
.0199ad	a5 1b		lda $1b				lda 	zLTemp1+1
.0199af	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.0199b1	85 1b		sta $1b				sta 	zLTemp1+1
.0199b3	a5 1c		lda $1c				lda 	zLTemp1+2
.0199b5	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.0199b7	85 1c		sta $1c				sta 	zLTemp1+2
.0199b9	a5 1d		lda $1d				lda 	zLTemp1+3
.0199bb	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.0199bd	85 1d		sta $1d				sta 	zLTemp1+3
.0199bf					_FPM_NoAddition:
.0199bf	66 1d		ror $1d				ror 	3+zLTemp1
.0199c1	66 1c		ror $1c				ror 	2+zLTemp1
.0199c3	66 1b		ror $1b				ror 	1+zLTemp1
.0199c5	66 1a		ror $1a				ror 	0+zLTemp1
.0199c7	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.0199c9	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.0199cb	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.0199cd	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.0199cf	88		dey				dey
.0199d0	d0 cd		bne $01999f			bne 	_FPM_Loop 					; do this 32 times.
.0199d2					FPM_CopySignNormalize:
.0199d2	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.0199d4	95 80		sta $80,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.0199d6	a5 1b		lda $1b				lda 	zLTemp1+1
.0199d8	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0199da	a5 1c		lda $1c				lda 	zLTemp1+2
.0199dc	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0199de	a5 1d		lda $1d				lda 	zLTemp1+3
.0199e0	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0199e2	b5 85		lda $85,x			lda 	XS_Type,x 					; sign is xor of signs
.0199e4	55 8b		eor $8b,x			eor 	XS2_Type,x
.0199e6	95 85		sta $85,x			sta 	XS_Type,x
.0199e8	20 26 9b	jsr $019b26			jsr 	FPUNormalise 				; normalise and exit.
.0199eb	7a		ply				ply
.0199ec	68		pla				pla
.0199ed	60		rts				rts
.0199ee					FPCalculateExponent:
.0199ee	18		clc				clc
.0199ef	b5 84		lda $84,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.0199f1	75 8a		adc $8a,x			adc 	XS2_Exponent,x
.0199f3	b0 08		bcs $0199fd			bcs 	_FPCECarry 					; carry out ?
.0199f5	10 03		bpl $0199fa			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.0199f7	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.0199f9	60		rts				rts
.0199fa					_FPCEExpZero:
.0199fa	a9 00		lda #$00			lda 	#0
.0199fc	60		rts				rts
.0199fd					_FPCECarry:
.0199fd	30 03		bmi $019a02			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.0199ff	09 80		ora #$80			ora 	#$80 						; put in right range
.019a01	60		rts				rts
.019a02					_FPCEOverflow:
.019a02	4c 83 9b	jmp $019b83			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.019a05					FPFractionalPart:
.019a05	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.019a07	38		sec				sec 								; this flag tells us to keep the fractional part
.019a08	30 0d		bmi $019a17			bmi 	FPGetPart
.019a0a	60		rts				rts
.019a0b					FPIntegerPart:
.019a0b	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.019a0d	18		clc				clc 								; this flag says keep the integer part.
.019a0e	30 07		bmi $019a17			bmi 	FPGetPart 					; -ve exponents are 0..127
.019a10	48		pha				pha
.019a11	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.019a13	95 85		sta $85,x			sta 	XS_Type,x
.019a15	68		pla				pla
.019a16	60		rts				rts
.019a17					FPGetPart:
.019a17	48		pha				pha
.019a18	5a		phy				phy 								; save Y
.019a19	08		php				php 								; save action
.019a1a	34 85		bit $85,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.019a1c	70 59		bvs $019a77			bvs 	_FPGP_Exit 					; then do nothing.
.019a1e	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.019a20	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.019a22	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.019a24	85 1c		sta $1c				sta 	zLTemp1+2
.019a26	85 1d		sta $1d				sta 	zLTemp1+3
.019a28	b5 84		lda $84,x			lda 	XS_Exponent,x				; the number of shifts.
.019a2a	38		sec				sec
.019a2b	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.019a2d	f0 12		beq $019a41			beq 	_FPGP_NoShift 				; ... if any
.019a2f	c9 20		cmp #$20			cmp 	#32
.019a31	90 02		bcc $019a35			bcc 	_FPGP_NotMax
.019a33	a9 20		lda #$20			lda 	#32 						; max of 32.
.019a35					_FPGP_NotMax:
.019a35	a8		tay				tay 								; Y is the mask shift count.
.019a36					_FPGP_ShiftMask:
.019a36	46 1d		lsr $1d				lsr 	3+zLTemp1
.019a38	66 1c		ror $1c				ror 	2+zLTemp1
.019a3a	66 1b		ror $1b				ror 	1+zLTemp1
.019a3c	66 1a		ror $1a				ror 	0+zLTemp1
.019a3e	88		dey				dey
.019a3f	d0 f5		bne $019a36			bne 	_FPGP_ShiftMask
.019a41					_FPGP_NoShift:
.019a41	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.019a43	8e 96 03	stx $0396			stx 	ExpTemp						; save X
.019a46					_FPGP_MaskLoop:
.019a46	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.019a49	28		plp				plp 								; if CC we keep the top part, so we
.019a4a	08		php				php		 							; flip the mask.
.019a4b	b0 02		bcs $019a4f			bcs		_FPGP_NoFlip
.019a4d	49 ff		eor #$ff			eor 	#$FF
.019a4f					_FPGP_NoFlip:
.019a4f	35 80		and $80,x			and 	XS_Mantissa,x 				; and into the mantissa.
.019a51	95 80		sta $80,x			sta 	XS_Mantissa,x
.019a53	e8		inx				inx
.019a54	c8		iny				iny
.019a55	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.019a57	d0 ed		bne $019a46			bne 	_FPGP_MaskLoop
.019a59	ae 96 03	ldx $0396			ldx 	ExpTemp						; restore X
.019a5c	28		plp				plp
.019a5d	08		php				php 								; get action flag on the stack
.019a5e	90 04		bcc $019a64			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.019a60	a9 00		lda #$00			lda 	#0
.019a62	95 85		sta $85,x			sta 	XS_Type,x
.019a64					_FPGP_NotFractional:
.019a64	b5 80		lda $80,x			lda 	XS_Mantissa,x 						; check if \1 zero
.019a66	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019a68	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019a6a	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019a6c	f0 05		beq $019a73			beq 	_FPGP_Zero 					; if zero, return zero
.019a6e	20 26 9b	jsr $019b26			jsr 	FPUNormalise
.019a71	80 04		bra $019a77			bra 	_FPGP_Exit 					; and exit
.019a73					_FPGP_Zero:
.019a73	a9 40		lda #$40			lda 	#$40 						; set zero flag
.019a75	95 85		sta $85,x			sta 	XS_Type,x
.019a77					_FPGP_Exit:
.019a77	68		pla				pla 								; throw saved action flag.
.019a78	7a		ply				ply
.019a79	68		pla				pla
.019a7a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.019a7b					FPCompare:
.019a7b	b5 84		lda $84,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.019a7d	48		pha				pha
.019a7e	b5 8a		lda $8a,x			lda 	XS2_Exponent,x
.019a80	48		pha				pha
.019a81	20 4e 98	jsr $01984e			jsr 	FPSubtract 					; calculate X1-X2
.019a84	34 85		bit $85,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.019a86	70 2a		bvs $019ab2			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.019a88	68		pla				pla
.019a89	8d 96 03	sta $0396			sta 	ExpTemp						; save first exponent in temporary reg.
.019a8c	68		pla				pla
.019a8d	38		sec				sec
.019a8e	ed 96 03	sbc $0396			sbc 	ExpTemp 					; calculate AX-BX
.019a91	70 14		bvs $019aa7			bvs 	_FPCNotEqual				; overflow, can't be equal.
.019a93	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.019a94	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.019a96	b0 0f		bcs $019aa7			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.019a98	38		sec				sec
.019a99	ad 96 03	lda $0396			lda 	ExpTemp 					; get one of the exponents back.
.019a9c	e9 12		sbc #$12			sbc 	#18 						; allow for 2^18 error, relatively.
.019a9e	b0 02		bcs $019aa2			bcs 	_FPCNotRange 				; keep in range.
.019aa0	a9 01		lda #$01			lda 	#1
.019aa2					_FPCNotRange:
.019aa2	38		sec				sec
.019aa3	f5 84		sbc $84,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.019aa5	b0 0d		bcs $019ab4			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.019aa7					_FPCNotEqual:
.019aa7	b5 85		lda $85,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.019aa9	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.019aab	f0 02		beq $019aaf			beq 	_FPCNE2
.019aad	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.019aaf	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.019ab0	80 04		bra $019ab6			bra 	_FPCExit
.019ab2					_FPCPullZero:
.019ab2	68		pla				pla 								; throw saved exponents
.019ab3	68		pla				pla
.019ab4					_FPCZero:
.019ab4	a9 00		lda #$00			lda 	#0 							; and return zero
.019ab6					_FPCExit:
.019ab6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.019ab7					FPUCopyX2ToX1:
.019ab7	48		pha				pha
.019ab8	da		phx				phx
.019ab9	5a		phy				phy
.019aba	a0 08		ldy #$08			ldy 	#8
.019abc	b5 86		lda $86,x	_FPUC21:lda 	XS2_Mantissa,x
.019abe	95 80		sta $80,x			sta 	XS_Mantissa,x
.019ac0	e8		inx				inx
.019ac1	88		dey				dey
.019ac2	10 f8		bpl $019abc			bpl 	_FPUC21
.019ac4	7a		ply				ply
.019ac5	fa		plx				plx
.019ac6	68		pla				pla
.019ac7	60		rts				rts
.019ac8					FPUSetInteger:
.019ac8	48		pha				pha
.019ac9	95 80		sta $80,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.019acb	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.019acd	10 02		bpl $019ad1			bpl 	_FPUSIExtend
.019acf	a9 ff		lda #$ff			lda 	#$FF
.019ad1					_FPUSIExtend:
.019ad1	95 81		sta $81,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.019ad3	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019ad5	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019ad7	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.019ad9	95 85		sta $85,x			sta 	XS_Type,x
.019adb	68		pla				pla
.019adc	60		rts				rts
.019add					FPUNegateInteger:
.019add	48		pha				pha
.019ade	38		sec				sec
.019adf	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.019ae1	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.019ae3	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019ae5	a9 00		lda #$00			lda 	#0
.019ae7	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.019ae9	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019aeb	a9 00		lda #$00			lda 	#0
.019aed	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.019aef	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019af1	a9 00		lda #$00			lda 	#0
.019af3	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.019af5	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019af7	68		pla				pla
.019af8	60		rts				rts
.019af9					FPUToFloat:
.019af9	48		pha				pha
.019afa	b5 85		lda $85,x			lda 	XS_Type,x					; exit if already float.
.019afc	29 0f		and #$0f			and 	#$0F
.019afe	f0 24		beq $019b24			beq 	_FPUFExit
.019b00	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.019b02	95 85		sta $85,x			sta 	XS_Type,x
.019b04	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.019b06	95 84		sta $84,x			sta 	XS_Exponent,x 				; x mantissa.
.019b08	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.019b0a	10 07		bpl $019b13			bpl		_FPUFPositive
.019b0c	20 dd 9a	jsr $019add			jsr 	FPUNegateInteger 			; negate the mantissa
.019b0f	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.019b11	95 85		sta $85,x			sta 	XS_Type,x
.019b13					_FPUFPositive:
.019b13	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.019b15	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019b17	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019b19	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019b1b	d0 04		bne $019b21			bne 	_FPUFNonZero
.019b1d	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.019b1f	95 85		sta $85,x			sta 	XS_Type,x
.019b21					_FPUFNonZero:
.019b21	20 26 9b	jsr $019b26			jsr 	FPUNormalise 				; normalise the floating point.
.019b24					_FPUFExit:
.019b24	68		pla				pla
.019b25	60		rts				rts
.019b26					FPUNormalise:
.019b26	48		pha				pha
.019b27	34 85		bit $85,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.019b29	70 18		bvs $019b43			bvs 	_FPUNExit
.019b2b	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.019b2d	f0 10		beq $019b3f			beq 	_FPUNSetZero
.019b2f					_FPUNLoop:
.019b2f	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.019b31	30 10		bmi $019b43			bmi 	_FPUNExit 					; if so, we are normalised.
.019b33	16 80		asl $80,x			asl 	0+XS_Mantissa+0,x
.019b35	36 81		rol $81,x			rol 	1+XS_Mantissa+0,x
.019b37	36 82		rol $82,x			rol 	2+XS_Mantissa+0,x
.019b39	36 83		rol $83,x			rol 	3+XS_Mantissa+0,x
.019b3b	d6 84		dec $84,x			dec 	XS_Exponent,x 				; decrement exponent
.019b3d	d0 f0		bne $019b2f			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.019b3f					_FPUNSetZero:
.019b3f	a9 40		lda #$40			lda 	#$40
.019b41	95 85		sta $85,x			sta 	XS_Type,x 					; the result is now zero.
.019b43					_FPUNExit:
.019b43	68		pla				pla
.019b44	60		rts				rts
.019b45					FPUToInteger:
.019b45	48		pha				pha
.019b46	b5 85		lda $85,x			lda 	XS_Type,x 					; if already integer, exit
.019b48	29 01		and #$01			and 	#1
.019b4a	d0 31		bne $019b7d			bne 	_FPUTOI_Exit
.019b4c	34 85		bit $85,x			bit 	XS_Type,x					; if zero, return zero.
.019b4e	70 23		bvs $019b73			bvs 	_FPUTOI_Zero
.019b50	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.019b52	10 1f		bpl $019b73			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.019b54	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.019b56	b0 2b		bcs $019b83			bcs 	FP_Overflow
.019b58					_FPUToIToInteger:
.019b58	b5 84		lda $84,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.019b5a	c9 a0		cmp #$a0			cmp 	#128+32
.019b5c	f0 0c		beq $019b6a			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.019b5e	f6 84		inc $84,x			inc 	XS_Exponent,X 				; increment Exponent
.019b60	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.019b62	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.019b64	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.019b66	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.019b68	80 ee		bra $019b58			bra 	_FPUToIToInteger 			; keep going.
.019b6a					_FPUToICheckSign:
.019b6a	b5 85		lda $85,x			lda 	XS_Type,x 					; check sign
.019b6c	10 0f		bpl $019b7d			bpl 	_FPUToI_Exit 				; exit if unsigned.
.019b6e	20 dd 9a	jsr $019add			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.019b71	80 0a		bra $019b7d			bra 	_FPUTOI_Exit
.019b73					_FPUTOI_Zero:
.019b73	a9 00		lda #$00			lda 	#0 							; return zero integer.
.019b75	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019b77	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019b79	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019b7b	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019b7d					_FPUToI_Exit:
.019b7d	a9 01		lda #$01			lda 	#1 							; set type to integer
.019b7f	95 85		sta $85,x			sta 	XS_Type,x
.019b81	68		pla				pla
.019b82	60		rts				rts
.019b83					FP_Overflow:
.019b83	20 c1 84	jsr $0184c1			jsr ERR_Handler
>019b86	46 6c 6f 61 74 69 6e 67			.text "Floating Point overflow",0
>019b8e	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.019b9e					FPUTimes10:
.019b9e	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.019ba0	85 1a		sta $1a				sta 	ZLTemp1+0
.019ba2	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019ba4	85 1b		sta $1b				sta 	ZLTemp1+1
.019ba6	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019ba8	85 1c		sta $1c				sta 	ZLTemp1+2
.019baa	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019bac	85 1d		sta $1d				sta 	ZLTemp1+3
.019bae	20 e3 9b	jsr $019be3			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.019bb1	20 e3 9b	jsr $019be3			jsr 	_FPUT_LSR_ZLTemp1
.019bb4	18		clc				clc
.019bb5	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.019bb7	65 1a		adc $1a				adc 	ZLTemp1+0
.019bb9	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019bbb	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019bbd	65 1b		adc $1b				adc 	ZLTemp1+1
.019bbf	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019bc1	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019bc3	65 1c		adc $1c				adc 	ZLTemp1+2
.019bc5	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019bc7	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019bc9	65 1d		adc $1d				adc 	ZLTemp1+3
.019bcb	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019bcd	90 0a		bcc $019bd9			bcc 	_FPUTimes10
.019bcf	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.019bd1	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.019bd3	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.019bd5	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.019bd7	f6 84		inc $84,x			inc 	XS_Exponent,x				; fix exponent
.019bd9					_FPUTimes10:
.019bd9	b5 84		lda $84,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.019bdb	18		clc				clc
.019bdc	69 03		adc #$03			adc 	#3
.019bde	95 84		sta $84,x			sta 	XS_Exponent,x
.019be0	b0 a1		bcs $019b83			bcs 	FP_Overflow 				; error
.019be2	60		rts				rts
.019be3					_FPUT_LSR_ZLTemp1:
.019be3	46 1d		lsr $1d				lsr 	ZLTemp1+3
.019be5	66 1c		ror $1c				ror 	ZLTemp1+2
.019be7	66 1b		ror $1b				ror 	ZLTemp1+1
.019be9	66 1a		ror $1a				ror 	ZLTemp1+0
.019beb	60		rts				rts
.019bec					FPUScale10A:
.019bec	5a		phy				phy
.019bed	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.019bef	f0 37		beq $019c28			beq 	_FPUScaleExit
.019bf1	da		phx				phx 								; save X
.019bf2	e8		inx				inx
.019bf3	e8		inx				inx
.019bf4	e8		inx				inx
.019bf5	e8		inx				inx
.019bf6	e8		inx				inx
.019bf7	e8		inx				inx
.019bf8	a8		tay				tay 								; save power scalar in Y.
.019bf9	a9 00		lda #$00			lda 	#0
.019bfb	95 80		sta $80,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.019bfd	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019bff	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019c01	95 85		sta $85,x			sta 	XS_Type,x
.019c03	a9 80		lda #$80			lda 	#$80
.019c05	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019c07	a9 81		lda #$81			lda 	#$81
.019c09	95 84		sta $84,x			sta 	XS_Exponent,x
.019c0b	5a		phy				phy 								; save 10^n on stack.
.019c0c	c0 00		cpy #$00			cpy 	#0
.019c0e	10 05		bpl $019c15			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.019c10	98		tya				tya
.019c11	49 ff		eor #$ff			eor 	#$FF
.019c13	1a		inc a				inc 	a
.019c14	a8		tay				tay
.019c15					_FPUSAbs:
.019c15	20 9e 9b	jsr $019b9e			jsr 	FPUTimes10
.019c18	88		dey				dey
.019c19	d0 fa		bne $019c15			bne 	_FPUSAbs 					; tos is now 10^|AC|
.019c1b	68		pla				pla 								; restore count in A
.019c1c	fa		plx				plx 								; restore X pointing to number to scale.
.019c1d	0a		asl a				asl 	a
.019c1e	b0 05		bcs $019c25			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.019c20	20 7d 99	jsr $01997d			jsr 	FPMultiply 					; if clear multiply.
.019c23	80 03		bra $019c28			bra		_FPUScaleExit
.019c25					_FPUSDivide:
.019c25	20 0a 99	jsr $01990a			jsr 	FPDivide
.019c28					_FPUScaleExit:
.019c28	7a		ply				ply
.019c29	60		rts				rts
.019c2a					FPUCopyToNext:
.019c2a	a0 06		ldy #$06			ldy 		#6
.019c2c	da		phx				phx
.019c2d					_FPUCopy1:
.019c2d	b5 80		lda $80,x			lda 	XS_Mantissa,x
.019c2f	95 86		sta $86,x			sta 	XS2_Mantissa,x
.019c31	e8		inx				inx
.019c32	88		dey				dey
.019c33	d0 f8		bne $019c2d			bne 	_FPUCopy1
.019c35	fa		plx				plx
.019c36	60		rts				rts
.019c37					FPUCopyFromNext:
.019c37	a0 06		ldy #$06			ldy 		#6
.019c39	da		phx				phx
.019c3a					_FPUCopy1:
.019c3a	b5 86		lda $86,x			lda 	XS2_Mantissa,x
.019c3c	95 80		sta $80,x			sta 	XS_Mantissa,x
.019c3e	e8		inx				inx
.019c3f	88		dey				dey
.019c40	d0 f8		bne $019c3a			bne 	_FPUCopy1
.019c42	fa		plx				plx
.019c43	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.019c44					FPToString:
.019c44	48		pha				pha
.019c45	5a		phy				phy
.019c46	34 85		bit $85,x			bit 		XS_Type,x 				; check zero flag
.019c48	50 0a		bvc $019c54			bvc 		_FPTSIsFloat 			; if zero,
.019c4a					_FPTSZero:
.019c4a	a9 30		lda #$30			lda 		#"0"
.019c4c	20 ab 97	jsr $0197ab			jsr 		ITSOutputCharacter
.019c4f					_FPTSExit:
.019c4f	7a		ply				ply
.019c50	68		pla				pla
.019c51	60		rts				rts
.019c52	80 fb		bra $019c4f			bra 		_FPTSExit
.019c54					_FPTSIsFloat:
.019c54	b5 85		lda $85,x			lda 		XS_Type,x 				; is it signed ?
.019c56	10 09		bpl $019c61			bpl 		_FPTSNotSigned
.019c58	a9 00		lda #$00			lda 		#0 						; clear sign flag
.019c5a	95 85		sta $85,x			sta 		XS_Type,x
.019c5c	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.019c5e	20 ab 97	jsr $0197ab			jsr 		ITSOutputCharacter
.019c61					_FPTSNotSigned:
.019c61	b5 84		lda $84,x			lda 		XS_Exponent,x
.019c63	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.019c65	b0 09		bcs $019c70			bcs 		_FPTSExponent
.019c67	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.019c69	90 05		bcc $019c70			bcc 		_FPTSExponent 			;
.019c6b					_FPTSStandard:
.019c6b	20 af 9c	jsr $019caf			jsr 		FPTOutputBody 			; output the body.
.019c6e	80 df		bra $019c4f			bra 		_FPTSExit
.019c70					_FPTSExponent:
.019c70	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.019c72	8d 97 03	sta $0397			sta 		ExpCount
.019c75					_FPTSExponentLoop:
.019c75	b5 84		lda $84,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.019c77	10 0e		bpl $019c87			bpl 		_FPTSTimes
.019c79	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.019c7b	90 14		bcc $019c91			bcc 		_FPTSScaledToExp
.019c7d	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.019c7f	20 ec 9b	jsr $019bec			jsr 		FPUScale10A
.019c82	ee 97 03	inc $0397			inc 		ExpCount
.019c85	80 ee		bra $019c75			bra 		_FPTSExponentLoop
.019c87					_FPTSTimes:
.019c87	a9 01		lda #$01			lda 		#1
.019c89	20 ec 9b	jsr $019bec			jsr 		FPUScale10A
.019c8c	ce 97 03	dec $0397			dec 		ExpCount
.019c8f	80 e4		bra $019c75			bra 		_FPTSExponentLoop
.019c91					_FPTSScaledToExp:
.019c91	20 af 9c	jsr $019caf			jsr 		FPTOutputBody 			; output the body.
.019c94	a9 65		lda #$65			lda 		#"e"					; output E
.019c96	20 ab 97	jsr $0197ab			jsr 		ITSOutputCharacter
.019c99	ad 97 03	lda $0397			lda 		ExpCount 				; get the exponent
.019c9c	95 80		sta $80,x			sta 		XS_Mantissa,x
.019c9e	29 80		and #$80			and 		#$80 					; sign extend it
.019ca0	f0 02		beq $019ca4			beq 		_FPTSSExt
.019ca2	a9 ff		lda #$ff			lda 		#$FF
.019ca4					_FPTSSExt:
.019ca4	95 81		sta $81,x			sta 		XS_Mantissa+1,x
.019ca6	95 82		sta $82,x			sta 		XS_Mantissa+2,x
.019ca8	95 83		sta $83,x			sta 		XS_Mantissa+3,x
.019caa	20 09 97	jsr $019709			jsr 		INTToString 			; output the exponent.
.019cad	80 a0		bra $019c4f			bra			_FPTSExit 				; and exit.
.019caf					FPTOutputBody:
.019caf	20 2a 9c	jsr $019c2a			jsr 		FPUCopyToNext 			; copy to next slot.
.019cb2	20 45 9b	jsr $019b45			jsr 		FPUToInteger 			; convert to an integer
.019cb5	20 09 97	jsr $019709			jsr 		INTToString 			; output the main integer part.
.019cb8	20 37 9c	jsr $019c37			jsr 		FPUCopyFromNext 		; get the fractional part back.
.019cbb	20 05 9a	jsr $019a05			jsr 		FPFractionalPart 		; get the decimal part.
.019cbe	34 85		bit $85,x			bit 		XS_Type,x 				; any fractional part.
.019cc0	70 3c		bvs $019cfe			bvs 		_FPTOExit 				; if not, exit now.
.019cc2	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.019cc4	20 ab 97	jsr $0197ab			jsr 		ITSOutputCharacter
.019cc7					_FPOutLoop:
.019cc7	34 85		bit $85,x			bit 		XS_Type,x 				; finally reached zero.
.019cc9	70 1d		bvs $019ce8			bvs 		_FPStripZeros 			; strip trailing zeros
.019ccb	20 9e 9b	jsr $019b9e			jsr 		FPUTimes10 				; multiply by 10
.019cce	20 2a 9c	jsr $019c2a			jsr 		FPUCopyToNext			; copy to next slot.
.019cd1	20 45 9b	jsr $019b45			jsr 		FPUToInteger 			; convert to integer
.019cd4	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; print digit.
.019cd6	09 30		ora #$30			ora 		#"0"
.019cd8	20 ab 97	jsr $0197ab			jsr 		ITSOutputCharacter
.019cdb	20 37 9c	jsr $019c37			jsr 		FPUCopyFromNext 		; get it back
.019cde	20 05 9a	jsr $019a05			jsr 		FPFractionalPart 		; get fractional part
.019ce1	ad 0e 03	lda $030e			lda 		NumBufX 				; done 11 characters yet ?
.019ce4	c9 0b		cmp #$0b			cmp 	 	#11
.019ce6	90 df		bcc $019cc7			bcc 		_FPOutLoop 				; if so, keep going till zero.
.019ce8					_FPStripZeros:
.019ce8	ac 0e 03	ldy $030e			ldy 		NumBufX 				; strip trailing zeros.
.019ceb					_FPStripLoop:
.019ceb	88		dey				dey 								; back one, if at start then no strip
.019cec	f0 10		beq $019cfe			beq 		_FPToExit
.019cee	b9 0f 03	lda $030f,y			lda 		Num_Buffer,y 			; keep going if "0"
.019cf1	c9 30		cmp #$30			cmp 		#"0"
.019cf3	f0 f6		beq $019ceb			beq 		_FPStripLoop
.019cf5	c8		iny				iny
.019cf6	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.019cf8	99 0f 03	sta $030f,y			sta 		Num_Buffer,y
.019cfb	8c 0e 03	sty $030e			sty 		NumBufX 				; update position.
.019cfe					_FPTOExit:
.019cfe	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.019cff					FPFromString:
.019cff	48		pha				pha 								; push A
.019d00	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.019d02	c9 2e		cmp #$2e			cmp 	#"."
.019d04	f0 03		beq $019d09			beq	 	_FPFIsDecimal
.019d06	4c 65 9d	jmp $019d65			jmp 	_FPFNotDecimal
.019d09					_FPFIsDecimal:
.019d09	c8		iny				iny 								; consume the decimal.
.019d0a	20 f9 9a	jsr $019af9			jsr 	FPUToFloat 					; convert the integer to float.
.019d0d	da		phx				phx 								; save X.
.019d0e	5a		phy				phy 								; save decimal start position
.019d0f	e8		inx				inx
.019d10	e8		inx				inx
.019d11	e8		inx				inx
.019d12	e8		inx				inx
.019d13	e8		inx				inx
.019d14	e8		inx				inx
.019d15	20 c3 97	jsr $0197c3			jsr 	INTFromStringY 				; get the part after the DP.
.019d18	20 f9 9a	jsr $019af9			jsr 	FPUToFloat 					; convert that to a float.
.019d1b	68		pla				pla 								; calculate - chars consumed.
.019d1c	8c 96 03	sty $0396			sty 	ExpTemp
.019d1f	38		sec				sec
.019d20	ed 96 03	sbc $0396			sbc 	ExpTemp 					; this is the shift amount
.019d23	20 ec 9b	jsr $019bec			jsr 	FPUScale10A 				; scale it by 10^AC
.019d26	fa		plx				plx 								; restore original X
.019d27	20 56 98	jsr $019856			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.019d2a	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.019d2c	c9 45		cmp #$45			cmp 	#"E"
.019d2e	f0 04		beq $019d34			beq 	_FPFExponent
.019d30	c9 65		cmp #$65			cmp 	#"e"
.019d32	d0 31		bne $019d65			bne 	_FPFNotDecimal 				; no, then exit normally.
.019d34					_FPFExponent:
.019d34	c8		iny				iny 								; skip over E symbol.
.019d35	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.019d37	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.019d39	d0 01		bne $019d3c			bne 	_FPFGotSign
.019d3b	c8		iny				iny 								; if it was - skip over it.
.019d3c					_FPFGotSign:
.019d3c	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.019d3d	da		phx				phx
.019d3e	e8		inx				inx
.019d3f	e8		inx				inx
.019d40	e8		inx				inx
.019d41	e8		inx				inx
.019d42	e8		inx				inx
.019d43	e8		inx				inx
.019d44	20 c3 97	jsr $0197c3			jsr 	INTFromStringY 				; get the exponent
.019d47	fa		plx				plx 								; restore X.
.019d48	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.019d4a	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.019d4c	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.019d4e	d0 17		bne $019d67			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.019d50	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.019d52	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.019d54	b0 11		bcs $019d67			bcs 	_FPFXOverflow
.019d56	68		pla				pla 								; get direction
.019d57	d0 07		bne $019d60			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.019d59	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.019d5b	49 ff		eor #$ff			eor 	#$FF
.019d5d	1a		inc a				inc 	a
.019d5e	95 86		sta $86,x			sta 	XS2_Mantissa+0,x
.019d60					_FPFXScale:
.019d60	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.019d62	20 ec 9b	jsr $019bec			jsr 	FPUScale10A 				; scale by the exponent.
.019d65					_FPFNotDecimal:
.019d65	68		pla				pla
.019d66	60		rts				rts
.019d67					_FPFXOverflow:
.019d67	20 c1 84	jsr $0184c1			jsr 	ERR_Handler
>019d6a	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>019d72	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.019d79					Unary_Rnd:
.019d79	20 71 8b	jsr $018b71			jsr 	EvaluateNumberX 			; get value
.019d7c	20 86 91	jsr $019186			jsr 	CheckNextRParen 			; check right bracket.
.019d7f	20 ef 8d	jsr $018def			jsr 	GetSignCurrent 				; get sign -1,0,1.
.019d82	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.019d84	30 10		bmi $019d96			bmi 	_URSetSeed
.019d86	f0 28		beq $019db0			beq 	_URMakeRandom 				; if zero return same number.
.019d88	da		phx				phx
.019d89	a2 00		ldx #$00			ldx 	#0
.019d8b	20 e7 9d	jsr $019de7			jsr 	Random16
.019d8e	a2 02		ldx #$02			ldx 	#2
.019d90	20 e7 9d	jsr $019de7			jsr 	Random16
.019d93	fa		plx				plx
.019d94	80 1a		bra $019db0			bra 	_URMakeRandom
.019d96					_URSetSeed:
.019d96	20 f9 9a	jsr $019af9			jsr 	FPUToFloat 					; make it a float to twiddle it.
.019d99	b5 80		lda $80,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.019d9b	8d 9d 03	sta $039d			sta 	RandomSeed+0
.019d9e	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.019da0	8d 9e 03	sta $039e			sta 	RandomSeed+1
.019da3	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.019da5	8d 9f 03	sta $039f			sta 	RandomSeed+2
.019da8	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.019daa	0a		asl a				asl 	a
.019dab	49 db		eor #$db			eor 	#$DB
.019dad	8d a0 03	sta $03a0			sta 	RandomSeed+3
.019db0					_URMakeRandom:
.019db0	ad 9d 03	lda $039d			lda 	RandomSeed+0 				; check if seed is zero.
.019db3	0d 9e 03	ora $039e			ora 	RandomSeed+1
.019db6	0d 9f 03	ora $039f			ora 	RandomSeed+2
.019db9	0d a0 03	ora $03a0			ora 	RandomSeed+3
.019dbc	d0 0a		bne $019dc8			bne 	_URNotZero
.019dbe	a9 47		lda #$47			lda 	#$47
.019dc0	8d 9e 03	sta $039e			sta 	RandomSeed+1				; if it is, make it non zero.
.019dc3	a9 3d		lda #$3d			lda 	#$3D
.019dc5	8d a0 03	sta $03a0			sta 	RandomSeed+3
.019dc8					_URNotZero:
.019dc8	ad 9d 03	lda $039d			lda 	RandomSeed+0 				; copy seed into mantissa.
.019dcb	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019dcd	ad 9e 03	lda $039e			lda 	RandomSeed+1
.019dd0	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019dd2	ad 9f 03	lda $039f			lda 	RandomSeed+2
.019dd5	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019dd7	ad a0 03	lda $03a0			lda 	RandomSeed+3
.019dda	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019ddc	a9 00		lda #$00			lda 	#$00 						; set type to float.
.019dde	95 85		sta $85,x			sta 	XS_Type,x
.019de0	a9 80		lda #$80			lda 	#$80
.019de2	95 84		sta $84,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.019de4	4c 26 9b	jmp $019b26			jmp 	FPUNormalise
.019de7					Random16:
.019de7	5e 9e 03	lsr $039e,x			lsr 	RandomSeed+1,x				; shift seed right
.019dea	7e 9d 03	ror $039d,x			ror 	RandomSeed,x
.019ded	90 08		bcc $019df7			bcc 	_R16_NoXor
.019def	bd 9e 03	lda $039e,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.019df2	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.019df4	9d 9e 03	sta $039e,x			sta 	RandomSeed+1,x
.019df7					_R16_NoXor:
.019df7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.019df8					Unary_Int:
.019df8	20 71 8b	jsr $018b71			jsr 	EvaluateNumberX 			; get value
.019dfb	20 86 91	jsr $019186			jsr 	CheckNextRParen 			; check right bracket.
.019dfe	4c 45 9b	jmp $019b45			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Return to file: basic.asm

>019e01	02						.byte 	2
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 c0						.word 	StartROM
>fffe	19 c0					.word TIM_BreakHandler

;******  End of listing
