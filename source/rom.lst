
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Sat Aug 24 15:21:48 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="4510"					cpu = "4510"
="mega65"				hardware = "mega65"
=1					exitonend = 1
=1					hasfloat = 1
=1					hasinteger = 1
=253					maxstring = 253

;******  Processing file: modules/float/fpmacros.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/mega65/src_mega65.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0020					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0200					IFT_XCursor:.byte ?							; current logical position on screen
>0201					IFT_YCursor:.byte ?
>0202					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0266					IFT_LineBuffer: .fill 100 					; line input buffer.
>0300					UserVector .fill 4 							; USR(x) calls this.
>0304					LocalVector .fill 4 						; Indirect calls call this.
>0308					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>030c					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>030d					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=782					XS2_Mantissa = XS_Mantissa+XS_Size
=786					XS2_Exponent = XS_Exponent+XS_Size
=787					XS2_Type = XS_Type+XS_Size
=788					XS3_Mantissa = XS_Mantissa+XS_Size*2
=792					XS3_Exponent = XS_Exponent+XS_Size*2
=793					XS3_Type = XS_Type+XS_Size*2
>0400					NumBufX 	.byte 	?						; buffer index position
>0401					Num_Buffer	.fill 	32 						; buffer for numeric conversions
>0421					NumSuppress	.byte 	?						; leading zero suppression flag
>0422					NumConvCount .byte 	? 						; count for conversions.
>0423					ExpTemp:	.byte ?							; Working temp for exponents.
>0424					ExpCount:	.byte ? 						; Count of decimal exponents.
>0425					SignCount:	.byte ?							; Integer Divide Sign Counts.
>0426					StringPtr:	.word ? 						; Top of free memory (for string allocation)
>0428					TempStringWriteIndex: .byte ? 				; Write offset.
>0429					ValSign: 	.byte ? 						; sign flag for val()
>042a					SliceStart:	.byte ? 						; string slice parts
>042b					SliceCount:	.byte ?
>042c					RandomSeed:	.dword ? 						; Random seed.
>0430					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>0432					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>0434					Tim_SR:		.byte ? 						; Processor Status
>0435					Tim_A:		.byte ? 						; Processor Registers
>0436					Tim_X:		.byte ?
>0437					Tim_Y:		.byte ?
>0438					Tim_Z:		.byte ?
>0439					Tim_SP:		.byte ?							; Stack Pointer

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/mega65.asm

=$7000					HighMemory = $7000
.8000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testcode.src

>8000	21 02 00 d9 bb 49 57 4b			.byte	$21,$02,$00,$d9,$bb,$49,$57,$4b
>8008	fd 05 36 35 33 8a 49 57			.byte	$fd,$05,$36,$35,$33,$8a,$49,$57
>8010	4b fd 05 36 35 33 bc 84			.byte	$4b,$fd,$05,$36,$35,$33,$bc,$84
>8018	52 6e 57 fd 05 33 30 36			.byte	$52,$6e,$57,$fd,$05,$33,$30,$36
>8020	00 13 03 00 d9 bb 43 51			.byte	$00,$13,$03,$00,$d9,$bb,$43,$51
>8028	45 66 89 43 51 45 66 bc			.byte	$45,$66,$89,$43,$51,$45,$66,$bc
>8030	84 8b 41 00 12 04 00 d9			.byte	$84,$8b,$41,$00,$12,$04,$00,$d9
>8038	bb 40 82 42 5c 5d 56 bc			.byte	$bb,$40,$82,$42,$5c,$5d,$56,$bc
>8040	84 42 5c 5d 56 00 0f 05			.byte	$84,$42,$5c,$5d,$56,$00,$0f,$05
>8048	00 d9 9a 8b 65 6c 5e bc			.byte	$00,$d9,$9a,$8b,$65,$6c,$5e,$bc
>8050	84 65 6c 5e 00 1c 06 00			.byte	$84,$65,$6c,$5e,$00,$1c,$06,$00
>8058	d9 a0 fe 09 64 77 79 6d			.byte	$d9,$a0,$fe,$09,$64,$77,$79,$6d
>8060	79 71 64 bd 4a bc 84 fe			.byte	$79,$71,$64,$bd,$4a,$bc,$84,$fe
>8068	09 64 77 79 6d 79 71 64			.byte	$09,$64,$77,$79,$6d,$79,$71,$64
>8070	00 1b 07 00 d9 bb 8b 5d			.byte	$00,$1b,$07,$00,$d9,$bb,$8b,$5d
>8078	56 5f fd 04 37 33 84 8b			.byte	$56,$5f,$fd,$04,$37,$33,$84,$8b
>8080	5d 56 5f fd 04 37 33 bc			.byte	$5d,$56,$5f,$fd,$04,$37,$33,$bc
>8088	84 8b 41 00 12 08 00 d9			.byte	$84,$8b,$41,$00,$12,$08,$00,$d9
>8090	bb 41 5e 76 72 8d 41 5e			.byte	$bb,$41,$5e,$76,$72,$8d,$41,$5e
>8098	76 72 bc 84 41 00 16 09			.byte	$76,$72,$bc,$84,$41,$00,$16,$09
>80a0	00 d9 bb 43 65 66 73 80			.byte	$00,$d9,$bb,$43,$65,$66,$73,$80
>80a8	8b 42 79 74 79 bc 84 41			.byte	$8b,$42,$79,$74,$79,$bc,$84,$41
>80b0	44 42 43 00 0d 0a 00 d9			.byte	$44,$42,$43,$00,$0d,$0a,$00,$d9
>80b8	b3 42 7b 6f 77 bc 84 41			.byte	$b3,$42,$7b,$6f,$77,$bc,$84,$41
>80c0	00 1a 0b 00 d9 a1 fe 08			.byte	$00,$1a,$0b,$00,$d9,$a1,$fe,$08
>80c8	69 76 73 6e 66 79 bd 46			.byte	$69,$76,$73,$6e,$66,$79,$bd,$46
>80d0	bc 84 fe 08 69 76 73 6e			.byte	$bc,$84,$fe,$08,$69,$76,$73,$6e
>80d8	66 79 00 1f 0c 00 d9 bb			.byte	$66,$79,$00,$1f,$0c,$00,$d9,$bb
>80e0	8b 42 7a 4e 6c fd 04 31			.byte	$8b,$42,$7a,$4e,$6c,$fd,$04,$31
>80e8	35 8d 8b 42 7a 4e 6c fd			.byte	$35,$8d,$8b,$42,$7a,$4e,$6c,$fd
>80f0	04 31 35 bc 84 41 fd 03			.byte	$04,$31,$35,$bc,$84,$41,$fd,$03
>80f8	30 00 10 0d 00 d9 bb 7d			.byte	$30,$00,$10,$0d,$00,$d9,$bb,$7d
>8100	73 73 8d 7d 73 73 bc 84			.byte	$73,$73,$8d,$7d,$73,$73,$bc,$84
>8108	41 00 16 0e 00 d9 bb 8b			.byte	$41,$00,$16,$0e,$00,$d9,$bb,$8b
>8110	41 55 40 79 80 42 59 6e			.byte	$41,$55,$40,$79,$80,$42,$59,$6e
>8118	67 bc 84 42 48 6e 47 00			.byte	$67,$bc,$84,$42,$48,$6e,$47,$00
>8120	15 0f 00 d9 b2 41 5d 4a			.byte	$15,$0f,$00,$d9,$b2,$41,$5d,$4a
>8128	72 bd 8b 41 5b 6a 66 bc			.byte	$72,$bd,$8b,$41,$5b,$6a,$66,$bc
>8130	84 41 60 4c 00 1d 10 00			.byte	$84,$41,$60,$4c,$00,$1d,$10,$00
>8138	d9 a2 fe 0a 73 61 74 69			.byte	$d9,$a2,$fe,$0a,$73,$61,$74,$69
>8140	6b 66 61 6e bd 44 bd 47			.byte	$6b,$66,$61,$6e,$bd,$44,$bd,$47
>8148	bc 84 fe 07 69 6b 66 61			.byte	$bc,$84,$fe,$07,$69,$6b,$66,$61
>8150	6e 00 1d 11 00 d9 bb 8b			.byte	$6e,$00,$1d,$11,$00,$d9,$bb,$8b
>8158	41 7e 60 69 fd 04 36 35			.byte	$41,$7e,$60,$69,$fd,$04,$36,$35
>8160	89 8b 41 7e 60 69 fd 04			.byte	$89,$8b,$41,$7e,$60,$69,$fd,$04
>8168	36 35 bc 84 8b 41 00 15			.byte	$36,$35,$bc,$84,$8b,$41,$00,$15
>8170	12 00 d9 bb 8b 41 4b 79			.byte	$12,$00,$d9,$bb,$8b,$41,$4b,$79
>8178	42 89 8b 41 4b 79 42 bc			.byte	$42,$89,$8b,$41,$4b,$79,$42,$bc
>8180	84 8b 41 00 16 13 00 d9			.byte	$84,$8b,$41,$00,$16,$13,$00,$d9
>8188	bb 8b 41 4e 58 69 80 42			.byte	$bb,$8b,$41,$4e,$58,$69,$80,$42
>8190	4e 65 5d bc 84 42 40 65			.byte	$4e,$65,$5d,$bc,$84,$42,$40,$65
>8198	55 00 10 14 00 d9 98 42			.byte	$55,$00,$10,$14,$00,$d9,$98,$42
>81a0	50 78 55 84 8b 42 50 78			.byte	$50,$78,$55,$84,$8b,$42,$50,$78
>81a8	56 00 13 15 00 d9 a6 fe			.byte	$56,$00,$13,$15,$00,$d9,$a6,$fe
>81b0	0a 71 68 67 66 6e 76 72			.byte	$0a,$71,$68,$67,$66,$6e,$76,$72
>81b8	63 bc 84 48 00 1d 16 00			.byte	$63,$bc,$84,$48,$00,$1d,$16,$00
>81c0	d9 bb 8b 44 6d 4f fd 05			.byte	$d9,$bb,$8b,$44,$6d,$4f,$fd,$05
>81c8	31 35 32 89 8b 43 50 7d			.byte	$31,$35,$32,$89,$8b,$43,$50,$7d
>81d0	53 fd 04 30 39 bc 84 8b			.byte	$53,$fd,$04,$30,$39,$bc,$84,$8b
>81d8	41 00 0d 17 00 d9 bb 40			.byte	$41,$00,$0d,$17,$00,$d9,$bb,$40
>81e0	87 40 bc 84 8b 41 00 16			.byte	$87,$40,$bc,$84,$8b,$41,$00,$16
>81e8	18 00 d9 bb 8b 66 6b 7d			.byte	$18,$00,$d9,$bb,$8b,$66,$6b,$7d
>81f0	82 43 58 5f 43 bc 84 8b			.byte	$82,$43,$58,$5f,$43,$bc,$84,$8b
>81f8	43 7e 75 40 00 12 19 00			.byte	$43,$7e,$75,$40,$00,$12,$19,$00
>8200	d9 a5 a4 42 58 5c 44 bc			.byte	$d9,$a5,$a4,$42,$58,$5c,$44,$bc
>8208	bc 84 42 58 5c 44 00 14			.byte	$bc,$84,$42,$58,$5c,$44,$00,$14
>8210	1a 00 d9 9b fe 0a 6b 6e			.byte	$1a,$00,$d9,$9b,$fe,$0a,$6b,$6e
>8218	6c 62 75 66 64 6a bc 84			.byte	$6c,$62,$75,$66,$64,$6a,$bc,$84
>8220	41 6b 00 1b 1b 00 d9 bb			.byte	$41,$6b,$00,$1b,$1b,$00,$d9,$bb
>8228	41 7d 64 63 fd 04 34 33			.byte	$41,$7d,$64,$63,$fd,$04,$34,$33
>8230	87 41 7d 64 63 fd 04 34			.byte	$87,$41,$7d,$64,$63,$fd,$04,$34
>8238	33 bc 84 8b 41 00 12 1c			.byte	$33,$bc,$84,$8b,$41,$00,$12,$1c
>8240	00 d9 bb 8b 51 66 5a 88			.byte	$00,$d9,$bb,$8b,$51,$66,$5a,$88
>8248	8b 51 66 5a bc 84 40 00			.byte	$8b,$51,$66,$5a,$bc,$84,$40,$00
>8250	16 1d 00 d9 bb 8b 42 59			.byte	$16,$1d,$00,$d9,$bb,$8b,$42,$59
>8258	7f 42 82 8b 42 4f 68 6e			.byte	$7f,$42,$82,$8b,$42,$4f,$68,$6e
>8260	bc 84 56 57 6c 00 10 1e			.byte	$bc,$84,$56,$57,$6c,$00,$10,$1e
>8268	00 d9 9a 42 59 51 6e bc			.byte	$00,$d9,$9a,$42,$59,$51,$6e,$bc
>8270	84 42 59 51 6e 00 0c 1f			.byte	$84,$42,$59,$51,$6e,$00,$0c,$1f
>8278	00 d9 b4 6c bc 84 fe 03			.byte	$00,$d9,$b4,$6c,$bc,$84,$fe,$03
>8280	2c 00 1d 20 00 d9 bb 8b			.byte	$2c,$00,$1d,$20,$00,$d9,$bb,$8b
>8288	41 79 61 56 fd 04 37 34			.byte	$41,$79,$61,$56,$fd,$04,$37,$34
>8290	87 8b 41 79 61 56 fd 04			.byte	$87,$8b,$41,$79,$61,$56,$fd,$04
>8298	37 34 bc 84 8b 41 00 18			.byte	$37,$34,$bc,$84,$8b,$41,$00,$18
>82a0	21 00 d9 bb 8b 41 68 45			.byte	$21,$00,$d9,$bb,$8b,$41,$68,$45
>82a8	4b 8a 8b 41 68 45 4b bc			.byte	$4b,$8a,$8b,$41,$68,$45,$4b,$bc
>82b0	84 8b 43 50 4a 56 00 17			.byte	$84,$8b,$43,$50,$4a,$56,$00,$17
>82b8	22 00 d9 bb 8b 42 43 77			.byte	$22,$00,$d9,$bb,$8b,$42,$43,$77
>82c0	53 81 8b 41 43 50 75 bc			.byte	$53,$81,$8b,$41,$43,$50,$75,$bc
>82c8	84 8b 43 50 51 00 0f 23			.byte	$84,$8b,$43,$50,$51,$00,$0f,$23
>82d0	00 d9 b3 8b 42 5d 41 50			.byte	$00,$d9,$b3,$8b,$42,$5d,$41,$50
>82d8	bc 84 8b 41 00 1b 24 00			.byte	$bc,$84,$8b,$41,$00,$1b,$24,$00
>82e0	d9 a3 50 bc 84 fe 12 20			.byte	$d9,$a3,$50,$bc,$84,$fe,$12,$20
>82e8	20 20 20 20 20 20 20 20			.byte	$20,$20,$20,$20,$20,$20,$20,$20
>82f0	20 20 20 20 20 20 20 00			.byte	$20,$20,$20,$20,$20,$20,$20,$00
>82f8	18 25 00 d9 bb 42 4b 4a			.byte	$18,$25,$00,$d9,$bb,$42,$4b,$4a
>8300	73 fd 03 39 86 42 4b 4a			.byte	$73,$fd,$03,$39,$86,$42,$4b,$4a
>8308	73 fd 03 39 bc 84 40 00			.byte	$73,$fd,$03,$39,$bc,$84,$40,$00
>8310	13 26 00 d9 bb 42 64 53			.byte	$13,$26,$00,$d9,$bb,$42,$64,$53
>8318	5c 87 42 64 53 5c bc 84			.byte	$5c,$87,$42,$64,$53,$5c,$bc,$84
>8320	8b 41 00 18 27 00 d9 bb			.byte	$8b,$41,$00,$18,$27,$00,$d9,$bb
>8328	8b 41 4d 54 43 81 8b 41			.byte	$8b,$41,$4d,$54,$43,$81,$8b,$41
>8330	54 46 4a bc 84 8b 41 44			.byte	$54,$46,$4a,$bc,$84,$8b,$41,$44
>8338	44 41 00 13 28 00 d9 b2			.byte	$44,$41,$00,$13,$28,$00,$d9,$b2
>8340	42 63 4d 56 bd 6b 53 5a			.byte	$42,$63,$4d,$56,$bd,$6b,$53,$5a
>8348	bc 84 61 53 48 00 13 29			.byte	$bc,$84,$61,$53,$48,$00,$13,$29
>8350	00 d9 a7 43 60 70 4b bc			.byte	$00,$d9,$a7,$43,$60,$70,$4b,$bc
>8358	84 fe 07 45 30 43 30 42			.byte	$84,$fe,$07,$45,$30,$43,$30,$42
>8360	00 23 2a 00 d9 bb 8b 42			.byte	$00,$23,$2a,$00,$d9,$bb,$8b,$42
>8368	65 7b fd 05 37 35 35 8a			.byte	$65,$7b,$fd,$05,$37,$35,$35,$8a
>8370	8b 42 65 7b fd 05 37 35			.byte	$8b,$42,$65,$7b,$fd,$05,$37,$35
>8378	35 bc 84 8b 45 4b 77 fd			.byte	$35,$bc,$84,$8b,$45,$4b,$77,$fd
>8380	04 35 31 00 14 2b 00 d9			.byte	$04,$35,$31,$00,$14,$2b,$00,$d9
>8388	bb 8b 42 61 45 6e 88 8b			.byte	$bb,$8b,$42,$61,$45,$6e,$88,$8b
>8390	42 61 45 6e bc 84 40 00			.byte	$42,$61,$45,$6e,$bc,$84,$40,$00
>8398	14 2c 00 d9 bb 43 6d 4c			.byte	$14,$2c,$00,$d9,$bb,$43,$6d,$4c
>83a0	4a 81 46 73 52 bc 84 43			.byte	$4a,$81,$46,$73,$52,$bc,$84,$43
>83a8	6f 7f 5a 00 10 2d 00 d9			.byte	$6f,$7f,$5a,$00,$10,$2d,$00,$d9
>83b0	98 42 7d 7c 5c 84 8b 42			.byte	$98,$42,$7d,$7c,$5c,$84,$8b,$42
>83b8	7d 7c 5d 00 0c 2e 00 d9			.byte	$7d,$7c,$5d,$00,$0c,$2e,$00,$d9
>83c0	af fe 03 30 bc 84 40 00			.byte	$af,$fe,$03,$30,$bc,$84,$40,$00
>83c8	1a 2f 00 d9 bb 41 65 5e			.byte	$1a,$2f,$00,$d9,$bb,$41,$65,$5e
>83d0	75 fd 04 38 37 88 41 65			.byte	$75,$fd,$04,$38,$37,$88,$41,$65
>83d8	5e 75 fd 04 38 37 bc 84			.byte	$5e,$75,$fd,$04,$38,$37,$bc,$84
>83e0	40 00 14 30 00 d9 bb 8b			.byte	$40,$00,$14,$30,$00,$d9,$bb,$8b
>83e8	43 48 46 47 8d 8b 43 48			.byte	$43,$48,$46,$47,$8d,$8b,$43,$48
>83f0	46 47 bc 84 41 00 14 31			.byte	$46,$47,$bc,$84,$41,$00,$14,$31
>83f8	00 d9 bb 8b 41 6b 42 61			.byte	$00,$d9,$bb,$8b,$41,$6b,$42,$61
>8400	80 57 71 40 bc 84 54 71			.byte	$80,$57,$71,$40,$bc,$84,$54,$71
>8408	40 00 12 32 00 d9 a5 a4			.byte	$40,$00,$12,$32,$00,$d9,$a5,$a4
>8410	41 6d 61 6e bc bc 84 41			.byte	$41,$6d,$61,$6e,$bc,$bc,$84,$41
>8418	6d 61 6e 00 1b 33 00 d9			.byte	$6d,$61,$6e,$00,$1b,$33,$00,$d9
>8420	a0 fe 0b 78 72 6c 70 6f			.byte	$a0,$fe,$0b,$78,$72,$6c,$70,$6f
>8428	6c 7a 61 72 bd 44 bc 84			.byte	$6c,$7a,$61,$72,$bd,$44,$bc,$84
>8430	fe 06 78 72 6c 70 00 21			.byte	$fe,$06,$78,$72,$6c,$70,$00,$21
>8438	34 00 d9 bb 8b 59 49 79			.byte	$34,$00,$d9,$bb,$8b,$59,$49,$79
>8440	fd 04 31 37 8a 8b 59 49			.byte	$fd,$04,$31,$37,$8a,$8b,$59,$49
>8448	79 fd 04 31 37 bc 84 8b			.byte	$79,$fd,$04,$31,$37,$bc,$84,$8b
>8450	72 53 72 fd 04 33 34 00			.byte	$72,$53,$72,$fd,$04,$33,$34,$00
>8458	0c 35 00 d9 bb 40 88 40			.byte	$0c,$35,$00,$d9,$bb,$40,$88,$40
>8460	bc 84 40 00 15 36 00 d9			.byte	$bc,$84,$40,$00,$15,$36,$00,$d9
>8468	bb 41 56 6f 5d 81 42 67			.byte	$bb,$41,$56,$6f,$5d,$81,$42,$67
>8470	6e 71 bc 84 43 77 6f 7d			.byte	$6e,$71,$bc,$84,$43,$77,$6f,$7d
>8478	00 0f 37 00 d9 9a 8b 62			.byte	$00,$0f,$37,$00,$d9,$9a,$8b,$62
>8480	69 5e bc 84 62 69 5e 00			.byte	$69,$5e,$bc,$84,$62,$69,$5e,$00
>8488	14 38 00 d9 a1 fe 05 62			.byte	$14,$38,$00,$d9,$a1,$fe,$05,$62
>8490	63 76 bd 48 bc 84 fe 05			.byte	$63,$76,$bd,$48,$bc,$84,$fe,$05
>8498	62 63 76 00 23 39 00 d9			.byte	$62,$63,$76,$00,$23,$39,$00,$d9
>84a0	bb 8b 53 5f 6a fd 05 37			.byte	$bb,$8b,$53,$5f,$6a,$fd,$05,$37
>84a8	31 39 8b 8b 41 5e 60 69			.byte	$31,$39,$8b,$8b,$41,$5e,$60,$69
>84b0	fd 04 30 35 bc 84 41 4b			.byte	$fd,$04,$30,$35,$bc,$84,$41,$4b
>84b8	40 7e fd 04 33 33 00 13			.byte	$40,$7e,$fd,$04,$33,$33,$00,$13
>84c0	3a 00 d9 bb 8b 7e 63 62			.byte	$3a,$00,$d9,$bb,$8b,$7e,$63,$62
>84c8	84 8b 7e 63 62 bc 84 8b			.byte	$84,$8b,$7e,$63,$62,$bc,$84,$8b
>84d0	41 00 15 3b 00 d9 bb 43			.byte	$41,$00,$15,$3b,$00,$d9,$bb,$43
>84d8	58 4e 43 82 41 4d 4d 53			.byte	$58,$4e,$43,$82,$41,$4d,$4d,$53
>84e0	bc 84 42 55 43 50 00 0f			.byte	$bc,$84,$42,$55,$43,$50,$00,$0f
>84e8	3c 00 d9 b3 8b 43 49 6e			.byte	$3c,$00,$d9,$b3,$8b,$43,$49,$6e
>84f0	6b bc 84 8b 41 00 19 3d			.byte	$6b,$bc,$84,$8b,$41,$00,$19,$3d
>84f8	00 d9 a2 fe 08 61 6d 70			.byte	$00,$d9,$a2,$fe,$08,$61,$6d,$70
>8500	61 79 7a bd 44 bd 4a bc			.byte	$61,$79,$7a,$bd,$44,$bd,$4a,$bc
>8508	84 fe 05 61 79 7a 00 1b			.byte	$84,$fe,$05,$61,$79,$7a,$00,$1b
>8510	3e 00 d9 bb 41 6c 78 49			.byte	$3e,$00,$d9,$bb,$41,$6c,$78,$49
>8518	fd 04 30 35 87 41 6c 78			.byte	$fd,$04,$30,$35,$87,$41,$6c,$78
>8520	49 fd 04 30 35 bc 84 8b			.byte	$49,$fd,$04,$30,$35,$bc,$84,$8b
>8528	41 00 15 3f 00 d9 bb 8b			.byte	$41,$00,$15,$3f,$00,$d9,$bb,$8b
>8530	43 4d 58 4a 84 8b 43 4d			.byte	$43,$4d,$58,$4a,$84,$8b,$43,$4d
>8538	58 4a bc 84 8b 41 00 12			.byte	$58,$4a,$bc,$84,$8b,$41,$00,$12
>8540	40 00 d9 bb 40 82 41 70			.byte	$40,$00,$d9,$bb,$40,$82,$41,$70
>8548	7f 7a bc 84 41 70 7f 7a			.byte	$7f,$7a,$bc,$84,$41,$70,$7f,$7a
>8550	00 15 41 00 d9 b2 8b 43			.byte	$00,$15,$41,$00,$d9,$b2,$8b,$43
>8558	76 64 bd 8b 41 75 7d 69			.byte	$76,$64,$bd,$8b,$41,$75,$7d,$69
>8560	bc 84 43 76 64 00 0f 42			.byte	$bc,$84,$43,$76,$64,$00,$0f,$42
>8568	00 d9 a6 fe 06 64 73 65			.byte	$00,$d9,$a6,$fe,$06,$64,$73,$65
>8570	75 bc 84 44 00 1b 43 00			.byte	$75,$bc,$84,$44,$00,$1b,$43,$00
>8578	d9 bb 8b 59 73 44 fd 04			.byte	$d9,$bb,$8b,$59,$73,$44,$fd,$04
>8580	33 34 89 8b 59 73 44 fd			.byte	$33,$34,$89,$8b,$59,$73,$44,$fd
>8588	04 33 34 bc 84 8b 41 00			.byte	$04,$33,$34,$bc,$84,$8b,$41,$00
>8590	11 44 00 d9 bb 60 78 7a			.byte	$11,$44,$00,$d9,$bb,$60,$78,$7a
>8598	89 60 78 7a bc 84 8b 41			.byte	$89,$60,$78,$7a,$bc,$84,$8b,$41
>85a0	00 14 45 00 d9 bb 8b 42			.byte	$00,$14,$45,$00,$d9,$bb,$8b,$42
>85a8	6e 43 72 82 40 bc 84 8b			.byte	$6e,$43,$72,$82,$40,$bc,$84,$8b
>85b0	42 6e 43 72 00 10 46 00			.byte	$42,$6e,$43,$72,$00,$10,$46,$00
>85b8	d9 98 8b 42 42 46 4f 84			.byte	$d9,$98,$8b,$42,$42,$46,$4f,$84
>85c0	42 42 46 4e 00 0d 47 00			.byte	$42,$42,$46,$4e,$00,$0d,$47,$00
>85c8	d9 9b fe 03 70 bc 84 41			.byte	$d9,$9b,$fe,$03,$70,$bc,$84,$41
>85d0	70 00 1b 48 00 d9 bb 8b			.byte	$70,$00,$1b,$48,$00,$d9,$bb,$8b
>85d8	5f 7b 78 fd 04 34 36 87			.byte	$5f,$7b,$78,$fd,$04,$34,$36,$87
>85e0	8b 5f 7b 78 fd 04 34 36			.byte	$8b,$5f,$7b,$78,$fd,$04,$34,$36
>85e8	bc 84 8b 41 00 15 49 00			.byte	$bc,$84,$8b,$41,$00,$15,$49,$00
>85f0	d9 bb 8b 5d 49 73 8a 8b			.byte	$d9,$bb,$8b,$5d,$49,$73,$8a,$8b
>85f8	5d 49 73 bc 84 8b 7a 53			.byte	$5d,$49,$73,$bc,$84,$8b,$7a,$53
>8600	66 00 16 4a 00 d9 bb 8b			.byte	$66,$00,$16,$4a,$00,$d9,$bb,$8b
>8608	41 52 6a 64 82 7f 56 7e			.byte	$41,$52,$6a,$64,$82,$7f,$56,$7e
>8610	bc 84 8b 41 6d 7c 5e 00			.byte	$bc,$84,$8b,$41,$6d,$7c,$5e,$00
>8618	12 4b 00 d9 a5 a4 8b 50			.byte	$12,$4b,$00,$d9,$a5,$a4,$8b,$50
>8620	7c 78 bc bc 84 8b 50 7c			.byte	$7c,$78,$bc,$bc,$84,$8b,$50,$7c
>8628	78 00 0c 4c 00 d9 b4 74			.byte	$78,$00,$0c,$4c,$00,$d9,$b4,$74
>8630	bc 84 fe 03 34 00 1c 4d			.byte	$bc,$84,$fe,$03,$34,$00,$1c,$4d
>8638	00 d9 bb 8b 43 52 52 4e			.byte	$00,$d9,$bb,$8b,$43,$52,$52,$4e
>8640	fd 04 31 34 85 8b 43 52			.byte	$fd,$04,$31,$34,$85,$8b,$43,$52
>8648	52 4e fd 04 31 34 bc 84			.byte	$52,$4e,$fd,$04,$31,$34,$bc,$84
>8650	40 00 10 4e 00 d9 bb 40			.byte	$40,$00,$10,$4e,$00,$d9,$bb,$40
>8658	85 43 5d 7b 69 bc 84 8b			.byte	$85,$43,$5d,$7b,$69,$bc,$84,$8b
>8660	41 00 16 4f 00 d9 bb 54			.byte	$41,$00,$16,$4f,$00,$d9,$bb,$54
>8668	5a 7a 82 8b 41 4c 42 59			.byte	$5a,$7a,$82,$8b,$41,$4c,$42,$59
>8670	bc 84 8b 41 58 58 63 00			.byte	$bc,$84,$8b,$41,$58,$58,$63,$00
>8678	11 50 00 d9 9a 8b 42 6c			.byte	$11,$50,$00,$d9,$9a,$8b,$42,$6c
>8680	58 52 bc 84 42 6c 58 52			.byte	$58,$52,$bc,$84,$42,$6c,$58,$52
>8688	00 0d 51 00 d9 a3 42 bc			.byte	$00,$0d,$51,$00,$d9,$a3,$42,$bc
>8690	84 fe 04 20 20 00 1d 52			.byte	$84,$fe,$04,$20,$20,$00,$1d,$52
>8698	00 d9 bb 41 67 52 4c fd			.byte	$00,$d9,$bb,$41,$67,$52,$4c,$fd
>86a0	04 31 36 8b 41 67 52 4c			.byte	$04,$31,$36,$8b,$41,$67,$52,$4c
>86a8	fd 04 31 36 bc 84 40 fd			.byte	$fd,$04,$31,$36,$bc,$84,$40,$fd
>86b0	03 30 00 12 53 00 d9 bb			.byte	$03,$30,$00,$12,$53,$00,$d9,$bb
>86b8	59 64 59 8a 59 64 59 bc			.byte	$59,$64,$59,$8a,$59,$64,$59,$bc
>86c0	84 73 48 72 00 14 54 00			.byte	$84,$73,$48,$72,$00,$14,$54,$00
>86c8	d9 bb 40 82 8b 43 71 63			.byte	$d9,$bb,$40,$82,$8b,$43,$71,$63
>86d0	6e bc 84 8b 43 71 63 6e			.byte	$6e,$bc,$84,$8b,$43,$71,$63,$6e
>86d8	00 0f 55 00 d9 b3 8b 41			.byte	$00,$0f,$55,$00,$d9,$b3,$8b,$41
>86e0	74 73 58 bc 84 8b 41 00			.byte	$74,$73,$58,$bc,$84,$8b,$41,$00
>86e8	13 56 00 d9 a7 43 63 44			.byte	$13,$56,$00,$d9,$a7,$43,$63,$44
>86f0	49 bc 84 fe 07 45 33 31			.byte	$49,$bc,$84,$fe,$07,$45,$33,$31
>86f8	30 39 00 17 57 00 d9 bb			.byte	$30,$39,$00,$17,$57,$00,$d9,$bb
>8700	79 44 58 fd 03 36 89 79			.byte	$79,$44,$58,$fd,$03,$36,$89,$79
>8708	44 58 fd 03 36 bc 84 8b			.byte	$44,$58,$fd,$03,$36,$bc,$84,$8b
>8710	41 00 12 58 00 d9 bb 42			.byte	$41,$00,$12,$58,$00,$d9,$bb,$42
>8718	58 45 41 85 42 58 45 41			.byte	$58,$45,$41,$85,$42,$58,$45,$41
>8720	bc 84 40 00 16 59 00 d9			.byte	$bc,$84,$40,$00,$16,$59,$00,$d9
>8728	bb 41 7d 5e 69 82 8b 7c			.byte	$bb,$41,$7d,$5e,$69,$82,$8b,$7c
>8730	6f 4c bc 84 8b 41 41 71			.byte	$6f,$4c,$bc,$84,$8b,$41,$41,$71
>8738	63 00 13 5a 00 d9 b2 8b			.byte	$63,$00,$13,$5a,$00,$d9,$b2,$8b
>8740	43 44 57 5c bd 51 70 6e			.byte	$43,$44,$57,$5c,$bd,$51,$70,$6e
>8748	bc 84 7f 62 00 13 5b 00			.byte	$bc,$84,$7f,$62,$00,$13,$5b,$00
>8750	d9 af fe 07 44 39 36 32			.byte	$d9,$af,$fe,$07,$44,$39,$36,$32
>8758	34 bc 84 43 59 58 64 00			.byte	$34,$bc,$84,$43,$59,$58,$64,$00
>8760	1c 5c 00 d9 bb 8b 41 4c			.byte	$1c,$5c,$00,$d9,$bb,$8b,$41,$4c
>8768	75 79 fd 04 36 36 85 8b			.byte	$75,$79,$fd,$04,$36,$36,$85,$8b
>8770	41 4c 75 79 fd 04 36 36			.byte	$41,$4c,$75,$79,$fd,$04,$36,$36
>8778	bc 84 40 00 15 5d 00 d9			.byte	$bc,$84,$40,$00,$15,$5d,$00,$d9
>8780	bb 8b 43 41 40 60 89 8b			.byte	$bb,$8b,$43,$41,$40,$60,$89,$8b
>8788	43 41 40 60 bc 84 8b 41			.byte	$43,$41,$40,$60,$bc,$84,$8b,$41
>8790	00 17 5e 00 d9 bb 8b 41			.byte	$00,$17,$5e,$00,$d9,$bb,$8b,$41
>8798	71 56 40 82 42 73 56 51			.byte	$71,$56,$40,$82,$42,$73,$56,$51
>87a0	bc 84 8b 43 42 43 6f 00			.byte	$bc,$84,$8b,$43,$42,$43,$6f,$00
>87a8	10 5f 00 d9 98 41 63 7c			.byte	$10,$5f,$00,$d9,$98,$41,$63,$7c
>87b0	75 84 8b 41 63 7c 76 00			.byte	$75,$84,$8b,$41,$63,$7c,$76,$00
>87b8	18 60 00 d9 a0 fe 07 6c			.byte	$18,$60,$00,$d9,$a0,$fe,$07,$6c
>87c0	75 69 73 61 bd 46 bc 84			.byte	$75,$69,$73,$61,$bd,$46,$bc,$84
>87c8	fe 07 6c 75 69 73 61 00			.byte	$fe,$07,$6c,$75,$69,$73,$61,$00
>87d0	1f 61 00 d9 bb 8b 43 4c			.byte	$1f,$61,$00,$d9,$bb,$8b,$43,$4c
>87d8	40 52 fd 04 38 33 8b 8b			.byte	$40,$52,$fd,$04,$38,$33,$8b,$8b
>87e0	43 4c 40 52 fd 04 38 33			.byte	$43,$4c,$40,$52,$fd,$04,$38,$33
>87e8	bc 84 40 fd 03 30 00 15			.byte	$bc,$84,$40,$fd,$03,$30,$00,$15
>87f0	62 00 d9 bb 8b 41 76 5e			.byte	$62,$00,$d9,$bb,$8b,$41,$76,$5e
>87f8	48 84 8b 41 76 5e 48 bc			.byte	$48,$84,$8b,$41,$76,$5e,$48,$bc
>8800	84 8b 41 00 16 63 00 d9			.byte	$84,$8b,$41,$00,$16,$63,$00,$d9
>8808	bb 8b 70 48 6a 81 8b 42			.byte	$bb,$8b,$70,$48,$6a,$81,$8b,$42
>8810	55 40 71 bc 84 8b 50 40			.byte	$55,$40,$71,$bc,$84,$8b,$50,$40
>8818	61 00 1a 64 00 d9 a5 a4			.byte	$61,$00,$1a,$64,$00,$d9,$a5,$a4
>8820	41 62 62 52 fd 04 34 39			.byte	$41,$62,$62,$52,$fd,$04,$34,$39
>8828	bc bc 84 41 62 62 52 fd			.byte	$bc,$bc,$84,$41,$62,$62,$52,$fd
>8830	04 34 39 00 14 65 00 d9			.byte	$04,$34,$39,$00,$14,$65,$00,$d9
>8838	a1 fe 05 6c 69 6f bd 44			.byte	$a1,$fe,$05,$6c,$69,$6f,$bd,$44
>8840	bc 84 fe 05 6c 69 6f 00			.byte	$bc,$84,$fe,$05,$6c,$69,$6f,$00
>8848	1d 66 00 d9 bb 8b 41 54			.byte	$1d,$66,$00,$d9,$bb,$8b,$41,$54
>8850	6b 73 fd 04 37 36 84 8b			.byte	$6b,$73,$fd,$04,$37,$36,$84,$8b
>8858	41 54 6b 73 fd 04 37 36			.byte	$41,$54,$6b,$73,$fd,$04,$37,$36
>8860	bc 84 8b 41 00 15 67 00			.byte	$bc,$84,$8b,$41,$00,$15,$67,$00
>8868	d9 bb 8b 43 68 45 69 87			.byte	$d9,$bb,$8b,$43,$68,$45,$69,$87
>8870	8b 43 68 45 69 bc 84 8b			.byte	$8b,$43,$68,$45,$69,$bc,$84,$8b
>8878	41 00 12 68 00 d9 bb 8b			.byte	$41,$00,$12,$68,$00,$d9,$bb,$8b
>8880	7c 53 7e 82 40 bc 84 8b			.byte	$7c,$53,$7e,$82,$40,$bc,$84,$8b
>8888	7c 53 7e 00 0e 69 00 d9			.byte	$7c,$53,$7e,$00,$0e,$69,$00,$d9
>8890	9a 47 47 40 bc 84 47 47			.byte	$9a,$47,$47,$40,$bc,$84,$47,$47
>8898	40 00 18 6a 00 d9 a2 fe			.byte	$40,$00,$18,$6a,$00,$d9,$a2,$fe
>88a0	0a 69 6f 78 6d 66 6d 64			.byte	$0a,$69,$6f,$78,$6d,$66,$6d,$64
>88a8	75 bd 4a bd 44 bc 84 fe			.byte	$75,$bd,$4a,$bd,$44,$bc,$84,$fe
>88b0	02 00 19 6b 00 d9 bb 6a			.byte	$02,$00,$19,$6b,$00,$d9,$bb,$6a
>88b8	72 4f fd 04 32 35 87 6a			.byte	$72,$4f,$fd,$04,$32,$35,$87,$6a
>88c0	72 4f fd 04 32 35 bc 84			.byte	$72,$4f,$fd,$04,$32,$35,$bc,$84
>88c8	8b 41 00 12 6c 00 d9 bb			.byte	$8b,$41,$00,$12,$6c,$00,$d9,$bb
>88d0	8b 67 7c 66 85 8b 67 7c			.byte	$8b,$67,$7c,$66,$85,$8b,$67,$7c
>88d8	66 bc 84 40 00 17 6d 00			.byte	$66,$bc,$84,$40,$00,$17,$6d,$00
>88e0	d9 bb 41 41 4b 7a 82 8b			.byte	$d9,$bb,$41,$41,$4b,$7a,$82,$8b
>88e8	43 65 7a 6d bc 84 8b 42			.byte	$43,$65,$7a,$6d,$bc,$84,$8b,$42
>88f0	64 71 57 00 0f 6e 00 d9			.byte	$64,$71,$57,$00,$0f,$6e,$00,$d9
>88f8	b3 8b 43 57 5c 64 bc 84			.byte	$b3,$8b,$43,$57,$5c,$64,$bc,$84
>8900	8b 41 00 0e 6f 00 d9 a6			.byte	$8b,$41,$00,$0e,$6f,$00,$d9,$a6
>8908	fe 05 70 65 76 bc 84 43			.byte	$fe,$05,$70,$65,$76,$bc,$84,$43
>8910	00 1a 70 00 d9 bb 42 71			.byte	$00,$1a,$70,$00,$d9,$bb,$42,$71
>8918	78 75 fd 04 30 32 88 42			.byte	$78,$75,$fd,$04,$30,$32,$88,$42
>8920	71 78 75 fd 04 30 32 bc			.byte	$71,$78,$75,$fd,$04,$30,$32,$bc
>8928	84 40 00 15 71 00 d9 bb			.byte	$84,$40,$00,$15,$71,$00,$d9,$bb
>8930	8b 41 40 48 46 84 8b 41			.byte	$8b,$41,$40,$48,$46,$84,$8b,$41
>8938	40 48 46 bc 84 8b 41 00			.byte	$40,$48,$46,$bc,$84,$8b,$41,$00
>8940	17 72 00 d9 bb 8b 43 6e			.byte	$17,$72,$00,$d9,$bb,$8b,$43,$6e
>8948	61 66 80 8b 66 40 70 bc			.byte	$61,$66,$80,$8b,$66,$40,$70,$bc
>8950	84 8b 43 6e 61 70 00 17			.byte	$84,$8b,$43,$6e,$61,$70,$00,$17
>8958	73 00 d9 b2 8b 41 4c 63			.byte	$73,$00,$d9,$b2,$8b,$41,$4c,$63
>8960	5f bd 8b 42 7b 6e 77 bc			.byte	$5f,$bd,$8b,$42,$7b,$6e,$77,$bc
>8968	84 41 4c 63 5f 00 15 74			.byte	$84,$41,$4c,$63,$5f,$00,$15,$74
>8970	00 d9 9b fe 0b 7a 72 78			.byte	$00,$d9,$9b,$fe,$0b,$7a,$72,$78
>8978	6e 6e 70 63 6b 7a bc 84			.byte	$6e,$6e,$70,$63,$6b,$7a,$bc,$84
>8980	41 7a 00 25 75 00 d9 bb			.byte	$41,$7a,$00,$25,$75,$00,$d9,$bb
>8988	5a 43 45 fd 04 31 32 8c			.byte	$5a,$43,$45,$fd,$04,$31,$32,$8c
>8990	5a 43 45 fd 04 31 32 bc			.byte	$5a,$43,$45,$fd,$04,$31,$32,$bc
>8998	84 41 fd 0d 31 33 38 33			.byte	$84,$41,$fd,$0d,$31,$33,$38,$33
>89a0	34 32 31 36 65 31 30 00			.byte	$34,$32,$31,$36,$65,$31,$30,$00
>89a8	0c 76 00 d9 bb 40 88 40			.byte	$0c,$76,$00,$d9,$bb,$40,$88,$40
>89b0	bc 84 40 00 15 77 00 d9			.byte	$bc,$84,$40,$00,$15,$77,$00,$d9
>89b8	bb 8b 41 58 46 7b 81 8b			.byte	$bb,$8b,$41,$58,$46,$7b,$81,$8b
>89c0	63 4a 71 bc 84 8b 42 71			.byte	$63,$4a,$71,$bc,$84,$8b,$42,$71
>89c8	00 10 78 00 d9 98 8b 42			.byte	$00,$10,$78,$00,$d9,$98,$8b,$42
>89d0	44 78 72 84 42 44 78 71			.byte	$44,$78,$72,$84,$42,$44,$78,$71
>89d8	00 0d 79 00 d9 b4 41 5c			.byte	$00,$0d,$79,$00,$d9,$b4,$41,$5c
>89e0	bc 84 fe 03 5c 00 1a 7a			.byte	$bc,$84,$fe,$03,$5c,$00,$1a,$7a
>89e8	00 d9 bb 8b 63 57 41 fd			.byte	$00,$d9,$bb,$8b,$63,$57,$41,$fd
>89f0	04 38 39 88 8b 63 57 41			.byte	$04,$38,$39,$88,$8b,$63,$57,$41
>89f8	fd 04 38 39 bc 84 40 00			.byte	$fd,$04,$38,$39,$bc,$84,$40,$00
>8a00	18 7b 00 d9 bb 8b 41 54			.byte	$18,$7b,$00,$d9,$bb,$8b,$41,$54
>8a08	6b 65 8a 8b 41 54 6b 65			.byte	$6b,$65,$8a,$8b,$41,$54,$6b,$65
>8a10	bc 84 8b 42 69 57 4a 00			.byte	$bc,$84,$8b,$42,$69,$57,$4a,$00
>8a18	18 7c 00 d9 bb 8b 41 4d			.byte	$18,$7c,$00,$d9,$bb,$8b,$41,$4d
>8a20	71 6d 80 8b 41 5c 4e 72			.byte	$71,$6d,$80,$8b,$41,$5c,$4e,$72
>8a28	bc 84 8b 41 5d 7f 7e 00			.byte	$bc,$84,$8b,$41,$5d,$7f,$7e,$00
>8a30	12 7d 00 d9 a5 a4 42 63			.byte	$12,$7d,$00,$d9,$a5,$a4,$42,$63
>8a38	43 78 bc bc 84 42 63 43			.byte	$43,$78,$bc,$bc,$84,$42,$63,$43
>8a40	78 00 14 7e 00 d9 a3 49			.byte	$78,$00,$14,$7e,$00,$d9,$a3,$49
>8a48	bc 84 fe 0b 20 20 20 20			.byte	$bc,$84,$fe,$0b,$20,$20,$20,$20
>8a50	20 20 20 20 20 00 1a 7f			.byte	$20,$20,$20,$20,$20,$00,$1a,$7f
>8a58	00 d9 bb 42 68 4e 46 fd			.byte	$00,$d9,$bb,$42,$68,$4e,$46,$fd
>8a60	04 35 35 88 42 68 4e 46			.byte	$04,$35,$35,$88,$42,$68,$4e,$46
>8a68	fd 04 35 35 bc 84 40 00			.byte	$fd,$04,$35,$35,$bc,$84,$40,$00
>8a70	0d 80 00 d9 bb 40 89 40			.byte	$0d,$80,$00,$d9,$bb,$40,$89,$40
>8a78	bc 84 8b 41 00 17 81 00			.byte	$bc,$84,$8b,$41,$00,$17,$81,$00
>8a80	d9 bb 43 6e 5f 57 82 8b			.byte	$d9,$bb,$43,$6e,$5f,$57,$82,$8b
>8a88	41 5d 54 72 bc 84 8b 42			.byte	$41,$5d,$54,$72,$bc,$84,$8b,$42
>8a90	73 4b 67 00 10 82 00 d9			.byte	$73,$4b,$67,$00,$10,$82,$00,$d9
>8a98	9a 43 47 6f 72 bc 84 43			.byte	$9a,$43,$47,$6f,$72,$bc,$84,$43
>8aa0	47 6f 72 00 13 83 00 d9			.byte	$47,$6f,$72,$00,$13,$83,$00,$d9
>8aa8	a7 41 6d 52 61 bc 84 fe			.byte	$a7,$41,$6d,$52,$61,$bc,$84,$fe
>8ab0	07 36 44 34 41 31 00 1a			.byte	$07,$36,$44,$34,$41,$31,$00,$1a
>8ab8	84 00 d9 bb 41 6c 76 5f			.byte	$84,$00,$d9,$bb,$41,$6c,$76,$5f
>8ac0	fd 04 36 31 86 41 6c 76			.byte	$fd,$04,$36,$31,$86,$41,$6c,$76
>8ac8	5f fd 04 36 31 bc 84 40			.byte	$5f,$fd,$04,$36,$31,$bc,$84,$40
>8ad0	00 13 85 00 d9 bb 41 64			.byte	$00,$13,$85,$00,$d9,$bb,$41,$64
>8ad8	56 43 84 41 64 56 43 bc			.byte	$56,$43,$84,$41,$64,$56,$43,$bc
>8ae0	84 8b 41 00 14 86 00 d9			.byte	$84,$8b,$41,$00,$14,$86,$00,$d9
>8ae8	bb 40 82 8b 41 51 51 4c			.byte	$bb,$40,$82,$8b,$41,$51,$51,$4c
>8af0	bc 84 8b 41 51 51 4c 00			.byte	$bc,$84,$8b,$41,$51,$51,$4c,$00
>8af8	0d 87 00 d9 b3 41 5b 7f			.byte	$0d,$87,$00,$d9,$b3,$41,$5b,$7f
>8b00	46 bc 84 41 00 13 88 00			.byte	$46,$bc,$84,$41,$00,$13,$88,$00
>8b08	d9 af fe 07 34 34 35 33			.byte	$d9,$af,$fe,$07,$34,$34,$35,$33
>8b10	43 bc 84 41 44 54 7c 00			.byte	$43,$bc,$84,$41,$44,$54,$7c,$00
>8b18	1b 89 00 d9 bb 43 46 7b			.byte	$1b,$89,$00,$d9,$bb,$43,$46,$7b
>8b20	58 fd 03 34 8b 43 46 7b			.byte	$58,$fd,$03,$34,$8b,$43,$46,$7b
>8b28	58 fd 03 34 bc 84 40 fd			.byte	$58,$fd,$03,$34,$bc,$84,$40,$fd
>8b30	03 30 00 14 8a 00 d9 bb			.byte	$03,$30,$00,$14,$8a,$00,$d9,$bb
>8b38	8b 41 6f 7a 42 86 8b 41			.byte	$8b,$41,$6f,$7a,$42,$86,$8b,$41
>8b40	6f 7a 42 bc 84 40 00 18			.byte	$6f,$7a,$42,$bc,$84,$40,$00,$18
>8b48	8b 00 d9 bb 8b 41 7e 66			.byte	$8b,$00,$d9,$bb,$8b,$41,$7e,$66
>8b50	75 81 8b 43 63 60 75 bc			.byte	$75,$81,$8b,$43,$63,$60,$75,$bc
>8b58	84 8b 41 62 60 75 00 15			.byte	$84,$8b,$41,$62,$60,$75,$00,$15
>8b60	8c 00 d9 b2 43 4b 60 59			.byte	$8c,$00,$d9,$b2,$43,$4b,$60,$59
>8b68	bd 43 73 56 44 bc 84 43			.byte	$bd,$43,$73,$56,$44,$bc,$84,$43
>8b70	4b 60 59 00 1c 8d 00 d9			.byte	$4b,$60,$59,$00,$1c,$8d,$00,$d9
>8b78	a0 fe 09 77 61 7a 64 6e			.byte	$a0,$fe,$09,$77,$61,$7a,$64,$6e
>8b80	73 6f bd 49 bc 84 fe 09			.byte	$73,$6f,$bd,$49,$bc,$84,$fe,$09
>8b88	77 61 7a 64 6e 73 6f 00			.byte	$77,$61,$7a,$64,$6e,$73,$6f,$00
>8b90	1a 8e 00 d9 bb 43 5f 4f			.byte	$1a,$8e,$00,$d9,$bb,$43,$5f,$4f
>8b98	43 fd 04 35 39 85 43 5f			.byte	$43,$fd,$04,$35,$39,$85,$43,$5f
>8ba0	4f 43 fd 04 35 39 bc 84			.byte	$4f,$43,$fd,$04,$35,$39,$bc,$84
>8ba8	40 00 0d 8f 00 d9 bb 40			.byte	$40,$00,$0d,$8f,$00,$d9,$bb,$40
>8bb0	87 40 bc 84 8b 41 00 15			.byte	$87,$40,$bc,$84,$8b,$41,$00,$15
>8bb8	90 00 d9 bb 8b 43 6c 68			.byte	$90,$00,$d9,$bb,$8b,$43,$6c,$68
>8bc0	71 80 42 4b 56 74 bc 84			.byte	$71,$80,$42,$4b,$56,$74,$bc,$84
>8bc8	43 56 44 00 10 91 00 d9			.byte	$43,$56,$44,$00,$10,$91,$00,$d9
>8bd0	98 8b 43 64 5e 60 84 43			.byte	$98,$8b,$43,$64,$5e,$60,$84,$43
>8bd8	64 5e 5f 00 1c 92 00 d9			.byte	$64,$5e,$5f,$00,$1c,$92,$00,$d9
>8be0	a1 fe 0a 6c 6b 73 63 78			.byte	$a1,$fe,$0a,$6c,$6b,$73,$63,$78
>8be8	6b 79 6b bd 46 bc 84 fe			.byte	$6b,$79,$6b,$bd,$46,$bc,$84,$fe
>8bf0	08 73 63 78 6b 79 6b 00			.byte	$08,$73,$63,$78,$6b,$79,$6b,$00
>8bf8	25 93 00 d9 bb 5d 75 7f			.byte	$25,$93,$00,$d9,$bb,$5d,$75,$7f
>8c00	fd 04 37 38 8c 5d 75 7f			.byte	$fd,$04,$37,$38,$8c,$5d,$75,$7f
>8c08	fd 04 37 38 bc 84 41 fd			.byte	$fd,$04,$37,$38,$bc,$84,$41,$fd
>8c10	0d 34 39 34 32 35 36 33			.byte	$0d,$34,$39,$34,$32,$35,$36,$33
>8c18	36 65 31 30 00 12 94 00			.byte	$36,$65,$31,$30,$00,$12,$94,$00
>8c20	d9 bb 41 7d 6c 45 8d 41			.byte	$d9,$bb,$41,$7d,$6c,$45,$8d,$41
>8c28	7d 6c 45 bc 84 41 00 12			.byte	$7d,$6c,$45,$bc,$84,$41,$00,$12
>8c30	95 00 d9 bb 43 6d 5f 44			.byte	$95,$00,$d9,$bb,$43,$6d,$5f,$44
>8c38	81 40 bc 84 43 6d 5f 44			.byte	$81,$40,$bc,$84,$43,$6d,$5f,$44
>8c40	00 14 96 00 d9 a5 a4 8b			.byte	$00,$14,$96,$00,$d9,$a5,$a4,$8b
>8c48	42 48 60 4b bc bc 84 8b			.byte	$42,$48,$60,$4b,$bc,$bc,$84,$8b
>8c50	42 48 60 4b 00 17 97 00			.byte	$42,$48,$60,$4b,$00,$17,$97,$00
>8c58	d9 a2 fe 09 63 61 73 7a			.byte	$d9,$a2,$fe,$09,$63,$61,$73,$7a
>8c60	65 69 71 bd 49 bd 43 bc			.byte	$65,$69,$71,$bd,$49,$bd,$43,$bc
>8c68	84 fe 02 00 1b 98 00 d9			.byte	$84,$fe,$02,$00,$1b,$98,$00,$d9
>8c70	bb 41 52 50 53 fd 04 31			.byte	$bb,$41,$52,$50,$53,$fd,$04,$31
>8c78	38 84 41 52 50 53 fd 04			.byte	$38,$84,$41,$52,$50,$53,$fd,$04
>8c80	31 38 bc 84 8b 41 00 15			.byte	$31,$38,$bc,$84,$8b,$41,$00,$15
>8c88	99 00 d9 bb 8b 43 54 4c			.byte	$99,$00,$d9,$bb,$8b,$43,$54,$4c
>8c90	68 87 8b 43 54 4c 68 bc			.byte	$68,$87,$8b,$43,$54,$4c,$68,$bc
>8c98	84 8b 41 00 14 9a 00 d9			.byte	$84,$8b,$41,$00,$14,$9a,$00,$d9
>8ca0	bb 41 50 52 42 81 7a 6a			.byte	$bb,$41,$50,$52,$42,$81,$7a,$6a
>8ca8	4a bc 84 41 7a 7a 4a 00			.byte	$4a,$bc,$84,$41,$7a,$7a,$4a,$00
>8cb0	11 9b 00 d9 9a 8b 42 40			.byte	$11,$9b,$00,$d9,$9a,$8b,$42,$40
>8cb8	72 78 bc 84 42 40 72 78			.byte	$72,$78,$bc,$84,$42,$40,$72,$78
>8cc0	00 11 9c 00 d9 a6 fe 08			.byte	$00,$11,$9c,$00,$d9,$a6,$fe,$08
>8cc8	65 71 6e 73 6b 73 bc 84			.byte	$65,$71,$6e,$73,$6b,$73,$bc,$84
>8cd0	46 00 1b 9d 00 d9 bb 41			.byte	$46,$00,$1b,$9d,$00,$d9,$bb,$41
>8cd8	7c 5f 48 fd 04 31 33 87			.byte	$7c,$5f,$48,$fd,$04,$31,$33,$87
>8ce0	41 7c 5f 48 fd 04 31 33			.byte	$41,$7c,$5f,$48,$fd,$04,$31,$33
>8ce8	bc 84 8b 41 00 14 9e 00			.byte	$bc,$84,$8b,$41,$00,$14,$9e,$00
>8cf0	d9 bb 8b 41 72 4c 65 86			.byte	$d9,$bb,$8b,$41,$72,$4c,$65,$86
>8cf8	8b 41 72 4c 65 bc 84 40			.byte	$8b,$41,$72,$4c,$65,$bc,$84,$40
>8d00	00 17 9f 00 d9 bb 8b 67			.byte	$00,$17,$9f,$00,$d9,$bb,$8b,$67
>8d08	63 4d 80 8b 41 5d 6f 4e			.byte	$63,$4d,$80,$8b,$41,$5d,$6f,$4e
>8d10	bc 84 8b 41 7f 6f 4e 00			.byte	$bc,$84,$8b,$41,$7f,$6f,$4e,$00
>8d18	0a a0 00 d9 b3 40 bc 84			.byte	$0a,$a0,$00,$d9,$b3,$40,$bc,$84
>8d20	40 00 0e a1 00 d9 9b fe			.byte	$40,$00,$0e,$a1,$00,$d9,$9b,$fe
>8d28	04 6a 73 bc 84 41 6a 00			.byte	$04,$6a,$73,$bc,$84,$41,$6a,$00
>8d30	18 a2 00 d9 bb 5d 69 65			.byte	$18,$a2,$00,$d9,$bb,$5d,$69,$65
>8d38	fd 04 33 39 88 5d 69 65			.byte	$fd,$04,$33,$39,$88,$5d,$69,$65
>8d40	fd 04 33 39 bc 84 40 00			.byte	$fd,$04,$33,$39,$bc,$84,$40,$00
>8d48	15 a3 00 d9 bb 8b 41 42			.byte	$15,$a3,$00,$d9,$bb,$8b,$41,$42
>8d50	74 63 84 8b 41 42 74 63			.byte	$74,$63,$84,$8b,$41,$42,$74,$63
>8d58	bc 84 8b 41 00 14 a4 00			.byte	$bc,$84,$8b,$41,$00,$14,$a4,$00
>8d60	d9 bb 6d 44 55 81 42 4a			.byte	$d9,$bb,$6d,$44,$55,$81,$42,$4a
>8d68	73 45 bc 84 42 6f 77 55			.byte	$73,$45,$bc,$84,$42,$6f,$77,$55
>8d70	00 14 a5 00 d9 b2 7c 6b			.byte	$00,$14,$a5,$00,$d9,$b2,$7c,$6b
>8d78	77 bd 8b 42 7f 4e 5c bc			.byte	$77,$bd,$8b,$42,$7f,$4e,$5c,$bc
>8d80	84 7c 6b 77 00 0d a6 00			.byte	$84,$7c,$6b,$77,$00,$0d,$a6,$00
>8d88	d9 b4 41 71 bc 84 fe 03			.byte	$d9,$b4,$41,$71,$bc,$84,$fe,$03
>8d90	71 00 1a a7 00 d9 bb 8b			.byte	$71,$00,$1a,$a7,$00,$d9,$bb,$8b
>8d98	59 65 64 fd 04 32 39 85			.byte	$59,$65,$64,$fd,$04,$32,$39,$85
>8da0	8b 59 65 64 fd 04 32 39			.byte	$8b,$59,$65,$64,$fd,$04,$32,$39
>8da8	bc 84 40 00 0c a8 00 d9			.byte	$bc,$84,$40,$00,$0c,$a8,$00,$d9
>8db0	bb 40 8c 40 bc 84 40 00			.byte	$bb,$40,$8c,$40,$bc,$84,$40,$00
>8db8	12 a9 00 d9 bb 7b 40 63			.byte	$12,$a9,$00,$d9,$bb,$7b,$40,$63
>8dc0	82 74 7d 52 bc 84 4f 7d			.byte	$82,$74,$7d,$52,$bc,$84,$4f,$7d
>8dc8	71 00 10 aa 00 d9 98 8b			.byte	$71,$00,$10,$aa,$00,$d9,$98,$8b
>8dd0	41 7b 76 4f 84 41 7b 76			.byte	$41,$7b,$76,$4f,$84,$41,$7b,$76
>8dd8	4e 00 1d ab 00 d9 a3 52			.byte	$4e,$00,$1d,$ab,$00,$d9,$a3,$52
>8de0	bc 84 fe 14 20 20 20 20			.byte	$bc,$84,$fe,$14,$20,$20,$20,$20
>8de8	20 20 20 20 20 20 20 20			.byte	$20,$20,$20,$20,$20,$20,$20,$20
>8df0	20 20 20 20 20 20 00 1f			.byte	$20,$20,$20,$20,$20,$20,$00,$1f
>8df8	ac 00 d9 bb 8b 43 6c 68			.byte	$ac,$00,$d9,$bb,$8b,$43,$6c,$68
>8e00	4a fd 04 30 34 8b 8b 43			.byte	$4a,$fd,$04,$30,$34,$8b,$8b,$43
>8e08	6c 68 4a fd 04 30 34 bc			.byte	$6c,$68,$4a,$fd,$04,$30,$34,$bc
>8e10	84 40 fd 03 30 00 14 ad			.byte	$84,$40,$fd,$03,$30,$00,$14,$ad
>8e18	00 d9 bb 8b 42 7a 5a 53			.byte	$00,$d9,$bb,$8b,$42,$7a,$5a,$53
>8e20	86 8b 42 7b 49 bc 84 8b			.byte	$86,$8b,$42,$7b,$49,$bc,$84,$8b
>8e28	41 00 16 ae 00 d9 bb 8b			.byte	$41,$00,$16,$ae,$00,$d9,$bb,$8b
>8e30	41 5d 7b 77 80 43 62 7a			.byte	$41,$5d,$7b,$77,$80,$43,$62,$7a
>8e38	45 bc 84 42 62 40 41 00			.byte	$45,$bc,$84,$42,$62,$40,$41,$00
>8e40	1a af 00 d9 a5 a4 57 77			.byte	$1a,$af,$00,$d9,$a5,$a4,$57,$77
>8e48	78 fd 05 35 33 37 bc bc			.byte	$78,$fd,$05,$35,$33,$37,$bc,$bc
>8e50	84 57 77 78 fd 05 35 33			.byte	$84,$57,$77,$78,$fd,$05,$35,$33
>8e58	37 00 13 b0 00 d9 a7 42			.byte	$37,$00,$13,$b0,$00,$d9,$a7,$42
>8e60	77 66 4d bc 84 fe 07 42			.byte	$77,$66,$4d,$bc,$84,$fe,$07,$42
>8e68	37 39 38 44 00 1c b1 00			.byte	$37,$39,$38,$44,$00,$1c,$b1,$00
>8e70	d9 bb 8b 43 4a 6b 57 fd			.byte	$d9,$bb,$8b,$43,$4a,$6b,$57,$fd
>8e78	04 38 36 85 8b 43 4a 6b			.byte	$04,$38,$36,$85,$8b,$43,$4a,$6b
>8e80	57 fd 04 38 36 bc 84 40			.byte	$57,$fd,$04,$38,$36,$bc,$84,$40
>8e88	00 14 b2 00 d9 bb 8b 43			.byte	$00,$14,$b2,$00,$d9,$bb,$8b,$43
>8e90	60 58 65 8d 8b 43 60 58			.byte	$60,$58,$65,$8d,$8b,$43,$60,$58
>8e98	65 bc 84 41 00 16 b3 00			.byte	$65,$bc,$84,$41,$00,$16,$b3,$00
>8ea0	d9 bb 8b 42 5e 62 69 81			.byte	$d9,$bb,$8b,$42,$5e,$62,$69,$81
>8ea8	8b 72 55 71 bc 84 8b 52			.byte	$8b,$72,$55,$71,$bc,$84,$8b,$52
>8eb0	40 61 00 0f b4 00 d9 9a			.byte	$40,$61,$00,$0f,$b4,$00,$d9,$9a
>8eb8	8b 75 63 42 bc 84 75 63			.byte	$8b,$75,$63,$42,$bc,$84,$75,$63
>8ec0	42 00 13 b5 00 d9 af fe			.byte	$42,$00,$13,$b5,$00,$d9,$af,$fe
>8ec8	07 39 30 41 41 30 bc 84			.byte	$07,$39,$30,$41,$41,$30,$bc,$84
>8ed0	42 50 6a 60 00 1f b6 00			.byte	$42,$50,$6a,$60,$00,$1f,$b6,$00
>8ed8	d9 bb 8b 43 5a 7a 45 fd			.byte	$d9,$bb,$8b,$43,$5a,$7a,$45,$fd
>8ee0	04 39 39 8b 8b 43 5a 7a			.byte	$04,$39,$39,$8b,$8b,$43,$5a,$7a
>8ee8	45 fd 04 39 39 bc 84 40			.byte	$45,$fd,$04,$39,$39,$bc,$84,$40
>8ef0	fd 03 30 00 14 b7 00 d9			.byte	$fd,$03,$30,$00,$14,$b7,$00,$d9
>8ef8	bb 8b 42 76 7e 54 86 8b			.byte	$bb,$8b,$42,$76,$7e,$54,$86,$8b
>8f00	42 76 7e 54 bc 84 40 00			.byte	$42,$76,$7e,$54,$bc,$84,$40,$00
>8f08	13 b8 00 d9 bb 66 7f 48			.byte	$13,$b8,$00,$d9,$bb,$66,$7f,$48
>8f10	80 8b 65 66 7a bc 84 42			.byte	$80,$8b,$65,$66,$7a,$bc,$84,$42
>8f18	59 40 00 0d b9 00 d9 b3			.byte	$59,$40,$00,$0d,$b9,$00,$d9,$b3
>8f20	42 68 5c 57 bc 84 41 00			.byte	$42,$68,$5c,$57,$bc,$84,$41,$00
>8f28	12 ba 00 d9 a0 fe 04 61			.byte	$12,$ba,$00,$d9,$a0,$fe,$04,$61
>8f30	61 bd 49 bc 84 fe 04 61			.byte	$61,$bd,$49,$bc,$84,$fe,$04,$61
>8f38	61 00 29 bb 00 d9 bb 8b			.byte	$61,$00,$29,$bb,$00,$d9,$bb,$8b
>8f40	41 55 55 7b fd 04 32 36			.byte	$41,$55,$55,$7b,$fd,$04,$32,$36
>8f48	8c 8b 41 55 55 7b fd 04			.byte	$8c,$8b,$41,$55,$55,$7b,$fd,$04
>8f50	32 36 bc 84 41 fd 0d 32			.byte	$32,$36,$bc,$84,$41,$fd,$0d,$32
>8f58	32 31 39 34 34 37 30 65			.byte	$32,$31,$39,$34,$34,$37,$30,$65
>8f60	31 31 00 15 bc 00 d9 bb			.byte	$31,$31,$00,$15,$bc,$00,$d9,$bb
>8f68	8b 43 74 43 66 87 8b 43			.byte	$8b,$43,$74,$43,$66,$87,$8b,$43
>8f70	74 43 66 bc 84 8b 41 00			.byte	$74,$43,$66,$bc,$84,$8b,$41,$00
>8f78	16 bd 00 d9 bb 8b 42 44			.byte	$16,$bd,$00,$d9,$bb,$8b,$42,$44
>8f80	59 6c 81 58 6f 46 bc 84			.byte	$59,$6c,$81,$58,$6f,$46,$bc,$84
>8f88	8b 42 44 50 6a 00 15 be			.byte	$8b,$42,$44,$50,$6a,$00,$15,$be
>8f90	00 d9 b2 8b 43 4d 57 67			.byte	$00,$d9,$b2,$8b,$43,$4d,$57,$67
>8f98	bd 8b 78 54 46 bc 84 64			.byte	$bd,$8b,$78,$54,$46,$bc,$84,$64
>8fa0	5b 55 00 1a bf 00 d9 a1			.byte	$5b,$55,$00,$1a,$bf,$00,$d9,$a1
>8fa8	fe 0c 6f 6f 74 71 78 75			.byte	$fe,$0c,$6f,$6f,$74,$71,$78,$75
>8fb0	6f 6d 6f 64 bd 42 bc 84			.byte	$6f,$6d,$6f,$64,$bd,$42,$bc,$84
>8fb8	fe 04 6f 64 00 1d c0 00			.byte	$fe,$04,$6f,$64,$00,$1d,$c0,$00
>8fc0	d9 bb 8b 41 4e 6d 71 fd			.byte	$d9,$bb,$8b,$41,$4e,$6d,$71,$fd
>8fc8	04 30 34 89 8b 41 4e 6d			.byte	$04,$30,$34,$89,$8b,$41,$4e,$6d
>8fd0	71 fd 04 30 34 bc 84 8b			.byte	$71,$fd,$04,$30,$34,$bc,$84,$8b
>8fd8	41 00 14 c1 00 d9 bb 47			.byte	$41,$00,$14,$c1,$00,$d9,$bb,$47
>8fe0	6c 52 8c 47 6c 52 bc 84			.byte	$6c,$52,$8c,$47,$6c,$52,$bc,$84
>8fe8	7b 4a 64 75 44 00 13 c2			.byte	$7b,$4a,$64,$75,$44,$00,$13,$c2
>8ff0	00 d9 bb 47 56 55 80 41			.byte	$00,$d9,$bb,$47,$56,$55,$80,$41
>8ff8	54 58 4c bc 84 44 50 44			.byte	$54,$58,$4c,$bc,$84,$44,$50,$44
>9000	00 10 c3 00 d9 98 8b 43			.byte	$00,$10,$c3,$00,$d9,$98,$8b,$43
>9008	5d 7f 7a 84 43 5d 7f 79			.byte	$5d,$7f,$7a,$84,$43,$5d,$7f,$79
>9010	00 12 c4 00 d9 a2 fe 03			.byte	$00,$12,$c4,$00,$d9,$a2,$fe,$03
>9018	73 bd 41 bd 48 bc 84 fe			.byte	$73,$bd,$41,$bd,$48,$bc,$84,$fe
>9020	03 73 00 19 c5 00 d9 bb			.byte	$03,$73,$00,$19,$c5,$00,$d9,$bb
>9028	4d 44 79 fd 04 34 36 89			.byte	$4d,$44,$79,$fd,$04,$34,$36,$89
>9030	4d 44 79 fd 04 34 36 bc			.byte	$4d,$44,$79,$fd,$04,$34,$36,$bc
>9038	84 8b 41 00 18 c6 00 d9			.byte	$84,$8b,$41,$00,$18,$c6,$00,$d9
>9040	bb 8b 42 67 60 43 8a 8b			.byte	$bb,$8b,$42,$67,$60,$43,$8a,$8b
>9048	42 67 60 43 bc 84 8b 45			.byte	$42,$67,$60,$43,$bc,$84,$8b,$45
>9050	4f 40 46 00 13 c7 00 d9			.byte	$4f,$40,$46,$00,$13,$c7,$00,$d9
>9058	bb 41 56 4e 47 80 5b 55			.byte	$bb,$41,$56,$4e,$47,$80,$5b,$55
>9060	51 bc 84 52 44 41 00 12			.byte	$51,$bc,$84,$52,$44,$41,$00,$12
>9068	c8 00 d9 a5 a4 42 55 52			.byte	$c8,$00,$d9,$a5,$a4,$42,$55,$52
>9070	73 bc bc 84 42 55 52 73			.byte	$73,$bc,$bc,$84,$42,$55,$52,$73
>9078	00 11 c9 00 d9 a6 fe 08			.byte	$00,$11,$c9,$00,$d9,$a6,$fe,$08
>9080	73 6f 6b 64 6d 79 bc 84			.byte	$73,$6f,$6b,$64,$6d,$79,$bc,$84
>9088	46 00 22 ca 00 d9 bb 41			.byte	$46,$00,$22,$ca,$00,$d9,$bb,$41
>9090	78 71 78 fd 04 30 34 8a			.byte	$78,$71,$78,$fd,$04,$30,$34,$8a
>9098	8b 43 41 47 6b fd 03 30			.byte	$8b,$43,$41,$47,$6b,$fd,$03,$30
>90a0	bc 84 8b 41 48 55 72 fd			.byte	$bc,$84,$8b,$41,$48,$55,$72,$fd
>90a8	04 39 36 00 14 cb 00 d9			.byte	$04,$39,$36,$00,$14,$cb,$00,$d9
>90b0	bb 8b 43 61 41 51 86 8b			.byte	$bb,$8b,$43,$61,$41,$51,$86,$8b
>90b8	43 61 41 51 bc 84 40 00			.byte	$43,$61,$41,$51,$bc,$84,$40,$00
>90c0	16 cc 00 d9 bb 43 40 5e			.byte	$16,$cc,$00,$d9,$bb,$43,$40,$5e
>90c8	66 81 8b 43 57 47 42 bc			.byte	$66,$81,$8b,$43,$57,$47,$42,$bc
>90d0	84 8b 57 41 42 00 11 cd			.byte	$84,$8b,$57,$41,$42,$00,$11,$cd
>90d8	00 d9 9a 8b 42 75 5a 59			.byte	$00,$d9,$9a,$8b,$42,$75,$5a,$59
>90e0	bc 84 42 75 5a 59 00 14			.byte	$bc,$84,$42,$75,$5a,$59,$00,$14
>90e8	ce 00 d9 9b fe 0a 7a 75			.byte	$ce,$00,$d9,$9b,$fe,$0a,$7a,$75
>90f0	63 78 71 61 73 6e bc 84			.byte	$63,$78,$71,$61,$73,$6e,$bc,$84
>90f8	41 7a 00 1b cf 00 d9 bb			.byte	$41,$7a,$00,$1b,$cf,$00,$d9,$bb
>9100	42 4d 7c 62 fd 04 32 37			.byte	$42,$4d,$7c,$62,$fd,$04,$32,$37
>9108	84 42 4d 7c 62 fd 04 32			.byte	$84,$42,$4d,$7c,$62,$fd,$04,$32
>9110	37 bc 84 8b 41 00 12 d0			.byte	$37,$bc,$84,$8b,$41,$00,$12,$d0
>9118	00 d9 bb 43 5f 57 49 86			.byte	$00,$d9,$bb,$43,$5f,$57,$49,$86
>9120	43 5f 57 49 bc 84 40 00			.byte	$43,$5f,$57,$49,$bc,$84,$40,$00
>9128	17 d1 00 d9 bb 8b 41 75			.byte	$17,$d1,$00,$d9,$bb,$8b,$41,$75
>9130	5a 75 82 42 60 5f 40 bc			.byte	$5a,$75,$82,$42,$60,$5f,$40,$bc
>9138	84 8b 43 55 45 75 00 0d			.byte	$84,$8b,$43,$55,$45,$75,$00,$0d
>9140	d2 00 d9 b3 42 75 4d 7c			.byte	$d2,$00,$d9,$b3,$42,$75,$4d,$7c
>9148	bc 84 41 00 0d d3 00 d9			.byte	$bc,$84,$41,$00,$0d,$d3,$00,$d9
>9150	b4 41 62 bc 84 fe 03 62			.byte	$b4,$41,$62,$bc,$84,$fe,$03,$62
>9158	00 1a d4 00 d9 bb 43 60			.byte	$00,$1a,$d4,$00,$d9,$bb,$43,$60
>9160	43 5f fd 04 34 35 86 43			.byte	$43,$5f,$fd,$04,$34,$35,$86,$43
>9168	60 43 5f fd 04 34 35 bc			.byte	$60,$43,$5f,$fd,$04,$34,$35,$bc
>9170	84 40 00 14 d5 00 d9 bb			.byte	$84,$40,$00,$14,$d5,$00,$d9,$bb
>9178	8b 41 6e 78 60 86 8b 41			.byte	$8b,$41,$6e,$78,$60,$86,$8b,$41
>9180	6e 78 60 bc 84 40 00 17			.byte	$6e,$78,$60,$bc,$84,$40,$00,$17
>9188	d6 00 d9 bb 8b 43 5b 40			.byte	$d6,$00,$d9,$bb,$8b,$43,$5b,$40
>9190	76 80 8b 41 41 58 bc 84			.byte	$76,$80,$8b,$41,$41,$58,$bc,$84
>9198	8b 43 5b 41 78 00 0f d7			.byte	$8b,$43,$5b,$41,$78,$00,$0f,$d7
>91a0	00 d9 b2 40 bd 42 6a 50			.byte	$00,$d9,$b2,$40,$bd,$42,$6a,$50
>91a8	69 bc 84 40 00 12 d8 00			.byte	$69,$bc,$84,$40,$00,$12,$d8,$00
>91b0	d9 a3 47 bc 84 fe 09 20			.byte	$d9,$a3,$47,$bc,$84,$fe,$09,$20
>91b8	20 20 20 20 20 20 00 1c			.byte	$20,$20,$20,$20,$20,$20,$00,$1c
>91c0	d9 00 d9 bb 8b 42 5c 7c			.byte	$d9,$00,$d9,$bb,$8b,$42,$5c,$7c
>91c8	56 fd 04 30 32 88 8b 42			.byte	$56,$fd,$04,$30,$32,$88,$8b,$42
>91d0	5c 7c 56 fd 04 30 32 bc			.byte	$5c,$7c,$56,$fd,$04,$30,$32,$bc
>91d8	84 40 00 12 da 00 d9 bb			.byte	$84,$40,$00,$12,$da,$00,$d9,$bb
>91e0	8b 45 53 52 86 8b 45 53			.byte	$8b,$45,$53,$52,$86,$8b,$45,$53
>91e8	52 bc 84 40 00 12 db 00			.byte	$52,$bc,$84,$40,$00,$12,$db,$00
>91f0	d9 bb 43 4f 6d 48 82 40			.byte	$d9,$bb,$43,$4f,$6d,$48,$82,$40
>91f8	bc 84 43 4f 6d 48 00 10			.byte	$bc,$84,$43,$4f,$6d,$48,$00,$10
>9200	dc 00 d9 98 43 49 6b 40			.byte	$dc,$00,$d9,$98,$43,$49,$6b,$40
>9208	84 8b 43 49 6b 41 00 0c			.byte	$84,$8b,$43,$49,$6b,$41,$00,$0c
>9210	dd 00 d9 a7 40 bc 84 fe			.byte	$dd,$00,$d9,$a7,$40,$bc,$84,$fe
>9218	03 30 00 1d de 00 d9 bb			.byte	$03,$30,$00,$1d,$de,$00,$d9,$bb
>9220	41 40 4e 7f fd 04 38 33			.byte	$41,$40,$4e,$7f,$fd,$04,$38,$33
>9228	8b 41 40 4e 7f fd 04 38			.byte	$8b,$41,$40,$4e,$7f,$fd,$04,$38
>9230	33 bc 84 40 fd 03 30 00			.byte	$33,$bc,$84,$40,$fd,$03,$30,$00
>9238	12 df 00 d9 bb 42 51 41			.byte	$12,$df,$00,$d9,$bb,$42,$51,$41
>9240	6d 8d 42 51 41 6d bc 84			.byte	$6d,$8d,$42,$51,$41,$6d,$bc,$84
>9248	41 00 13 e0 00 d9 bb 8b			.byte	$41,$00,$13,$e0,$00,$d9,$bb,$8b
>9250	78 5d 81 43 42 67 6e bc			.byte	$78,$5d,$81,$43,$42,$67,$6e,$bc
>9258	84 8b 58 51 00 12 e1 00			.byte	$84,$8b,$58,$51,$00,$12,$e1,$00
>9260	d9 a5 a4 42 7b 50 66 bc			.byte	$d9,$a5,$a4,$42,$7b,$50,$66,$bc
>9268	bc 84 42 7b 50 66 00 12			.byte	$bc,$84,$42,$7b,$50,$66,$00,$12
>9270	e2 00 d9 af fe 07 31 33			.byte	$e2,$00,$d9,$af,$fe,$07,$31,$33
>9278	38 31 30 bc 84 53 60 50			.byte	$38,$31,$30,$bc,$84,$53,$60,$50
>9280	00 1f e3 00 d9 bb 8b 41			.byte	$00,$1f,$e3,$00,$d9,$bb,$8b,$41
>9288	5f 54 4c fd 04 34 38 8d			.byte	$5f,$54,$4c,$fd,$04,$34,$38,$8d
>9290	8b 41 5f 54 4c fd 04 34			.byte	$8b,$41,$5f,$54,$4c,$fd,$04,$34
>9298	38 bc 84 41 fd 03 30 00			.byte	$38,$bc,$84,$41,$fd,$03,$30,$00
>92a0	12 e4 00 d9 bb 43 4f 46			.byte	$12,$e4,$00,$d9,$bb,$43,$4f,$46
>92a8	58 8d 43 4f 46 58 bc 84			.byte	$58,$8d,$43,$4f,$46,$58,$bc,$84
>92b0	41 00 14 e5 00 d9 bb 53			.byte	$41,$00,$14,$e5,$00,$d9,$bb,$53
>92b8	75 73 82 42 58 48 67 bc			.byte	$75,$73,$82,$42,$58,$48,$67,$bc
>92c0	84 42 4b 7d 54 00 0e e6			.byte	$84,$42,$4b,$7d,$54,$00,$0e,$e6
>92c8	00 d9 9a 5d 71 7f bc 84			.byte	$00,$d9,$9a,$5d,$71,$7f,$bc,$84
>92d0	5d 71 7f 00 17 e7 00 d9			.byte	$5d,$71,$7f,$00,$17,$e7,$00,$d9
>92d8	a0 fe 09 76 66 6b 75 74			.byte	$a0,$fe,$09,$76,$66,$6b,$75,$74
>92e0	69 64 bd 42 bc 84 fe 04			.byte	$69,$64,$bd,$42,$bc,$84,$fe,$04
>92e8	76 66 00 1c e8 00 d9 bb			.byte	$76,$66,$00,$1c,$e8,$00,$d9,$bb
>92f0	8b 42 4e 71 4a fd 04 39			.byte	$8b,$42,$4e,$71,$4a,$fd,$04,$39
>92f8	38 88 8b 42 4e 71 4a fd			.byte	$38,$88,$8b,$42,$4e,$71,$4a,$fd
>9300	04 39 38 bc 84 40 00 0c			.byte	$04,$39,$38,$bc,$84,$40,$00,$0c
>9308	e9 00 d9 bb 40 8b 40 bc			.byte	$e9,$00,$d9,$bb,$40,$8b,$40,$bc
>9310	84 40 00 13 ea 00 d9 bb			.byte	$84,$40,$00,$13,$ea,$00,$d9,$bb
>9318	8b 63 55 4f 80 48 64 42			.byte	$8b,$63,$55,$4f,$80,$48,$64,$42
>9320	bc 84 48 60 40 00 0f eb			.byte	$bc,$84,$48,$60,$40,$00,$0f,$eb
>9328	00 d9 b3 8b 42 4e 5b 5c			.byte	$00,$d9,$b3,$8b,$42,$4e,$5b,$5c
>9330	bc 84 8b 41 00 1a ec 00			.byte	$bc,$84,$8b,$41,$00,$1a,$ec,$00
>9338	d9 a1 fe 08 66 6f 76 6d			.byte	$d9,$a1,$fe,$08,$66,$6f,$76,$6d
>9340	71 72 bd 47 bc 84 fe 08			.byte	$71,$72,$bd,$47,$bc,$84,$fe,$08
>9348	66 6f 76 6d 71 72 00 1c			.byte	$66,$6f,$76,$6d,$71,$72,$00,$1c
>9350	ed 00 d9 bb 8b 43 5d 78			.byte	$ed,$00,$d9,$bb,$8b,$43,$5d,$78
>9358	5c fd 04 38 33 85 8b 43			.byte	$5c,$fd,$04,$38,$33,$85,$8b,$43
>9360	5d 78 5c fd 04 38 33 bc			.byte	$5d,$78,$5c,$fd,$04,$38,$33,$bc
>9368	84 40 00 10 ee 00 d9 bb			.byte	$84,$40,$00,$10,$ee,$00,$d9,$bb
>9370	5b 62 71 8b 5b 62 71 bc			.byte	$5b,$62,$71,$8b,$5b,$62,$71,$bc
>9378	84 40 00 16 ef 00 d9 bb			.byte	$84,$40,$00,$16,$ef,$00,$d9,$bb
>9380	8b 6c 67 55 82 8b 41 4a			.byte	$8b,$6c,$67,$55,$82,$8b,$41,$4a
>9388	73 7c bc 84 41 66 54 6f			.byte	$73,$7c,$bc,$84,$41,$66,$54,$6f
>9390	00 12 f0 00 d9 b2 53 53			.byte	$00,$12,$f0,$00,$d9,$b2,$53,$53
>9398	60 bd 51 7d 5d bc 84 41			.byte	$60,$bd,$51,$7d,$5d,$bc,$84,$41
>93a0	56 43 00 17 f1 00 d9 a2			.byte	$56,$43,$00,$17,$f1,$00,$d9,$a2
>93a8	fe 08 6f 66 62 63 78 6f			.byte	$fe,$08,$6f,$66,$62,$63,$78,$6f
>93b0	bd 46 bd 49 bc 84 fe 03			.byte	$bd,$46,$bd,$49,$bc,$84,$fe,$03
>93b8	6f 00 20 f2 00 d9 bb 41			.byte	$6f,$00,$20,$f2,$00,$d9,$bb,$41
>93c0	6b 7d 4c fd 04 31 35 8a			.byte	$6b,$7d,$4c,$fd,$04,$31,$35,$8a
>93c8	41 6b 7d 4c fd 04 31 35			.byte	$41,$6b,$7d,$4c,$fd,$04,$31,$35
>93d0	bc 84 43 57 7a 58 fd 03			.byte	$bc,$84,$43,$57,$7a,$58,$fd,$03
>93d8	33 00 11 f3 00 d9 bb 7d			.byte	$33,$00,$11,$f3,$00,$d9,$bb,$7d
>93e0	70 60 84 7d 70 60 bc 84			.byte	$70,$60,$84,$7d,$70,$60,$bc,$84
>93e8	8b 41 00 17 f4 00 d9 bb			.byte	$8b,$41,$00,$17,$f4,$00,$d9,$bb
>93f0	41 69 77 4e 82 8b 42 7e			.byte	$41,$69,$77,$4e,$82,$8b,$42,$7e
>93f8	54 78 bc 84 8b 43 57 63			.byte	$54,$78,$bc,$84,$8b,$43,$57,$63
>9400	7a 00 10 f5 00 d9 98 43			.byte	$7a,$00,$10,$f5,$00,$d9,$98,$43
>9408	6e 4e 6f 84 8b 43 6e 4e			.byte	$6e,$4e,$6f,$84,$8b,$43,$6e,$4e
>9410	70 00 0c f6 00 d9 a6 fe			.byte	$70,$00,$0c,$f6,$00,$d9,$a6,$fe
>9418	03 6c bc 84 41 00 1a f7			.byte	$03,$6c,$bc,$84,$41,$00,$1a,$f7
>9420	00 d9 bb 41 51 7c 64 fd			.byte	$00,$d9,$bb,$41,$51,$7c,$64,$fd
>9428	04 37 36 85 41 51 7c 64			.byte	$04,$37,$36,$85,$41,$51,$7c,$64
>9430	fd 04 37 36 bc 84 40 00			.byte	$fd,$04,$37,$36,$bc,$84,$40,$00
>9438	0c f8 00 d9 bb 40 8b 40			.byte	$0c,$f8,$00,$d9,$bb,$40,$8b,$40
>9440	bc 84 40 00 16 f9 00 d9			.byte	$bc,$84,$40,$00,$16,$f9,$00,$d9
>9448	bb 43 48 44 56 81 8b 41			.byte	$bb,$43,$48,$44,$56,$81,$8b,$41
>9450	4f 7e 77 bc 84 8b 47 7a			.byte	$4f,$7e,$77,$bc,$84,$8b,$47,$7a
>9458	61 00 1a fa 00 d9 a5 a4			.byte	$61,$00,$1a,$fa,$00,$d9,$a5,$a4
>9460	8b 41 43 5d 71 fd 03 30			.byte	$8b,$41,$43,$5d,$71,$fd,$03,$30
>9468	bc bc 84 8b 41 43 5d 71			.byte	$bc,$bc,$84,$8b,$41,$43,$5d,$71
>9470	fd 03 30 00 13 fb 00 d9			.byte	$fd,$03,$30,$00,$13,$fb,$00,$d9
>9478	9b fe 09 64 77 70 74 71			.byte	$9b,$fe,$09,$64,$77,$70,$74,$71
>9480	6a 65 bc 84 41 64 00 1d			.byte	$6a,$65,$bc,$84,$41,$64,$00,$1d
>9488	fc 00 d9 bb 8b 42 58 41			.byte	$fc,$00,$d9,$bb,$8b,$42,$58,$41
>9490	5f fd 04 37 35 84 8b 42			.byte	$5f,$fd,$04,$37,$35,$84,$8b,$42
>9498	58 41 5f fd 04 37 35 bc			.byte	$58,$41,$5f,$fd,$04,$37,$35,$bc
>94a0	84 8b 41 00 12 fd 00 d9			.byte	$84,$8b,$41,$00,$12,$fd,$00,$d9
>94a8	bb 41 5a 64 4a 86 41 5a			.byte	$bb,$41,$5a,$64,$4a,$86,$41,$5a
>94b0	64 4a bc 84 40 00 15 fe			.byte	$64,$4a,$bc,$84,$40,$00,$15,$fe
>94b8	00 d9 bb 8b 4f 5c 41 81			.byte	$00,$d9,$bb,$8b,$4f,$5c,$41,$81
>94c0	43 65 65 41 bc 84 8b 4a			.byte	$43,$65,$65,$41,$bc,$84,$8b,$4a
>94c8	58 41 00 0a ff 00 d9 9a			.byte	$58,$41,$00,$0a,$ff,$00,$d9,$9a
>94d0	40 bc 84 40 00 0d 00 01			.byte	$40,$bc,$84,$40,$00,$0d,$00,$01
>94d8	d9 b4 41 77 bc 84 fe 03			.byte	$d9,$b4,$41,$77,$bc,$84,$fe,$03
>94e0	77 00 1a 01 01 d9 bb 41			.byte	$77,$00,$1a,$01,$01,$d9,$bb,$41
>94e8	72 44 6a fd 04 34 34 85			.byte	$72,$44,$6a,$fd,$04,$34,$34,$85
>94f0	41 72 44 6a fd 04 34 34			.byte	$41,$72,$44,$6a,$fd,$04,$34,$34
>94f8	bc 84 40 00 14 02 01 d9			.byte	$bc,$84,$40,$00,$14,$02,$01,$d9
>9500	bb 8b 41 78 59 47 8d 8b			.byte	$bb,$8b,$41,$78,$59,$47,$8d,$8b
>9508	41 78 59 47 bc 84 41 00			.byte	$41,$78,$59,$47,$bc,$84,$41,$00
>9510	12 03 01 d9 bb 42 7f 6b			.byte	$12,$03,$01,$d9,$bb,$42,$7f,$6b
>9518	69 82 40 bc 84 42 7f 6b			.byte	$69,$82,$40,$bc,$84,$42,$7f,$6b
>9520	69 00 0a 04 01 d9 b3 40			.byte	$69,$00,$0a,$04,$01,$d9,$b3,$40
>9528	bc 84 40 00 15 05 01 d9			.byte	$bc,$84,$40,$00,$15,$05,$01,$d9
>9530	a3 4a bc 84 fe 0c 20 20			.byte	$a3,$4a,$bc,$84,$fe,$0c,$20,$20
>9538	20 20 20 20 20 20 20 20			.byte	$20,$20,$20,$20,$20,$20,$20,$20
>9540	00 27 06 01 d9 bb 8b 42			.byte	$00,$27,$06,$01,$d9,$bb,$8b,$42
>9548	7b 7c 5c fd 03 36 8c 8b			.byte	$7b,$7c,$5c,$fd,$03,$36,$8c,$8b
>9550	42 7b 7c 5c fd 03 36 bc			.byte	$42,$7b,$7c,$5c,$fd,$03,$36,$bc
>9558	84 45 fd 0d 39 32 36 32			.byte	$84,$45,$fd,$0d,$39,$32,$36,$32
>9560	33 37 35 30 65 31 31 00			.byte	$33,$37,$35,$30,$65,$31,$31,$00
>9568	12 07 01 d9 bb 43 71 79			.byte	$12,$07,$01,$d9,$bb,$43,$71,$79
>9570	45 8b 43 71 79 45 bc 84			.byte	$45,$8b,$43,$71,$79,$45,$bc,$84
>9578	40 00 10 08 01 d9 bb 40			.byte	$40,$00,$10,$08,$01,$d9,$bb,$40
>9580	80 8b 43 5e 6e 68 bc 84			.byte	$80,$8b,$43,$5e,$6e,$68,$bc,$84
>9588	40 00 15 09 01 d9 b2 43			.byte	$40,$00,$15,$09,$01,$d9,$b2,$43
>9590	5d 4e 60 bd 43 71 59 62			.byte	$5d,$4e,$60,$bd,$43,$71,$59,$62
>9598	bc 84 43 5d 4e 60 00 12			.byte	$bc,$84,$43,$5d,$4e,$60,$00,$12
>95a0	0a 01 d9 a7 60 79 41 bc			.byte	$0a,$01,$d9,$a7,$60,$79,$41,$bc
>95a8	84 fe 07 32 30 45 34 31			.byte	$84,$fe,$07,$32,$30,$45,$34,$31
>95b0	00 19 0b 01 d9 bb 6b 50			.byte	$00,$19,$0b,$01,$d9,$bb,$6b,$50
>95b8	42 fd 04 31 37 88 42 7b			.byte	$42,$fd,$04,$31,$37,$88,$42,$7b
>95c0	40 43 fd 04 31 36 bc 84			.byte	$40,$43,$fd,$04,$31,$36,$bc,$84
>95c8	40 00 14 0c 01 d9 bb 8b			.byte	$40,$00,$14,$0c,$01,$d9,$bb,$8b
>95d0	42 44 64 5e 85 8b 42 44			.byte	$42,$44,$64,$5e,$85,$8b,$42,$44
>95d8	64 5e bc 84 40 00 18 0d			.byte	$64,$5e,$bc,$84,$40,$00,$18,$0d
>95e0	01 d9 bb 8b 41 5a 7b 59			.byte	$01,$d9,$bb,$8b,$41,$5a,$7b,$59
>95e8	80 8b 43 60 63 77 bc 84			.byte	$80,$8b,$43,$60,$63,$77,$bc,$84
>95f0	8b 43 7a 7b 7f 00 10 0e			.byte	$8b,$43,$7a,$7b,$7f,$00,$10,$0e
>95f8	01 d9 98 8b 41 7d 5e 7b			.byte	$01,$d9,$98,$8b,$41,$7d,$5e,$7b
>9600	84 41 7d 5e 7a 00 12 0f			.byte	$84,$41,$7d,$5e,$7a,$00,$12,$0f
>9608	01 d9 af fe 07 33 38 38			.byte	$01,$d9,$af,$fe,$07,$33,$38,$38
>9610	41 30 bc 84 78 62 60 00			.byte	$41,$30,$bc,$84,$78,$62,$60,$00
>9618	1d 10 01 d9 bb 8b 41 51			.byte	$1d,$10,$01,$d9,$bb,$8b,$41,$51
>9620	4b 63 fd 04 38 38 87 8b			.byte	$4b,$63,$fd,$04,$38,$38,$87,$8b
>9628	41 51 4b 63 fd 04 38 38			.byte	$41,$51,$4b,$63,$fd,$04,$38,$38
>9630	bc 84 8b 41 00 14 11 01			.byte	$bc,$84,$8b,$41,$00,$14,$11,$01
>9638	d9 bb 8b 43 54 44 4e 8b			.byte	$d9,$bb,$8b,$43,$54,$44,$4e,$8b
>9640	8b 43 54 44 4e bc 84 40			.byte	$8b,$43,$54,$44,$4e,$bc,$84,$40
>9648	00 17 12 01 d9 bb 8b 5a			.byte	$00,$17,$12,$01,$d9,$bb,$8b,$5a
>9650	7a 52 80 8b 43 61 63 66			.byte	$7a,$52,$80,$8b,$43,$61,$63,$66
>9658	bc 84 8b 43 7b 7b 76 00			.byte	$bc,$84,$8b,$43,$7b,$7b,$76,$00
>9660	12 13 01 d9 a5 a4 42 58			.byte	$12,$13,$01,$d9,$a5,$a4,$42,$58
>9668	49 47 bc bc 84 42 58 49			.byte	$49,$47,$bc,$bc,$84,$42,$58,$49
>9670	47 00 1c 14 01 d9 a0 fe			.byte	$47,$00,$1c,$14,$01,$d9,$a0,$fe
>9678	09 7a 68 7a 75 73 64 78			.byte	$09,$7a,$68,$7a,$75,$73,$64,$78
>9680	bd 4a bc 84 fe 09 7a 68			.byte	$bd,$4a,$bc,$84,$fe,$09,$7a,$68
>9688	7a 75 73 64 78 00 1f 15			.byte	$7a,$75,$73,$64,$78,$00,$1f,$15
>9690	01 d9 bb 8b 41 61 6c 7a			.byte	$01,$d9,$bb,$8b,$41,$61,$6c,$7a
>9698	fd 04 30 33 8b 8b 41 61			.byte	$fd,$04,$30,$33,$8b,$8b,$41,$61
>96a0	6c 7a fd 04 30 33 bc 84			.byte	$6c,$7a,$fd,$04,$30,$33,$bc,$84
>96a8	40 fd 03 30 00 0d 16 01			.byte	$40,$fd,$03,$30,$00,$0d,$16,$01
>96b0	d9 bb 40 87 40 bc 84 8b			.byte	$d9,$bb,$40,$87,$40,$bc,$84,$8b
>96b8	41 00 16 17 01 d9 bb 8b			.byte	$41,$00,$16,$17,$01,$d9,$bb,$8b
>96c0	42 79 71 5f 80 43 64 75			.byte	$42,$79,$71,$5f,$80,$43,$64,$75
>96c8	6c bc 84 41 44 44 60 00			.byte	$6c,$bc,$84,$41,$44,$44,$60,$00
>96d0	10 18 01 d9 9a 43 4c 57			.byte	$10,$18,$01,$d9,$9a,$43,$4c,$57
>96d8	52 bc 84 43 4c 57 52 00			.byte	$52,$bc,$84,$43,$4c,$57,$52,$00
>96e0	0e 19 01 d9 a1 fe 02 bd			.byte	$0e,$19,$01,$d9,$a1,$fe,$02,$bd
>96e8	47 bc 84 fe 02 00 1b 1a			.byte	$47,$bc,$84,$fe,$02,$00,$1b,$1a
>96f0	01 d9 bb 41 64 66 62 fd			.byte	$01,$d9,$bb,$41,$64,$66,$62,$fd
>96f8	04 33 38 87 41 64 66 62			.byte	$04,$33,$38,$87,$41,$64,$66,$62
>9700	fd 04 33 38 bc 84 8b 41			.byte	$fd,$04,$33,$38,$bc,$84,$8b,$41
>9708	00 14 1b 01 d9 bb 8b 42			.byte	$00,$14,$1b,$01,$d9,$bb,$8b,$42
>9710	7e 46 54 86 8b 42 7e 46			.byte	$7e,$46,$54,$86,$8b,$42,$7e,$46
>9718	54 bc 84 40 00 15 1c 01			.byte	$54,$bc,$84,$40,$00,$15,$1c,$01
>9720	d9 bb 41 6e 68 65 82 42			.byte	$d9,$bb,$41,$6e,$68,$65,$82,$42
>9728	5b 40 74 bc 84 43 75 68			.byte	$5b,$40,$74,$bc,$84,$43,$75,$68
>9730	51 00 0e 1d 01 d9 b3 8b			.byte	$51,$00,$0e,$1d,$01,$d9,$b3,$8b
>9738	7e 46 77 bc 84 8b 41 00			.byte	$7e,$46,$77,$bc,$84,$8b,$41,$00
>9740	18 1e 01 d9 a2 fe 09 79			.byte	$18,$1e,$01,$d9,$a2,$fe,$09,$79
>9748	63 70 77 62 63 6f bd 44			.byte	$63,$70,$77,$62,$63,$6f,$bd,$44
>9750	bd 41 bc 84 fe 03 77 00			.byte	$bd,$41,$bc,$84,$fe,$03,$77,$00
>9758	29 1f 01 d9 bb 8b 43 5b			.byte	$29,$1f,$01,$d9,$bb,$8b,$43,$5b
>9760	4d 4d fd 04 37 32 8c 8b			.byte	$4d,$4d,$fd,$04,$37,$32,$8c,$8b
>9768	43 5b 4d 4d fd 04 37 32			.byte	$43,$5b,$4d,$4d,$fd,$04,$37,$32
>9770	bc 84 48 fd 0d 30 36 31			.byte	$bc,$84,$48,$fd,$0d,$30,$36,$31
>9778	37 30 30 32 39 65 31 31			.byte	$37,$30,$30,$32,$39,$65,$31,$31
>9780	00 11 20 01 d9 bb 57 77			.byte	$00,$11,$20,$01,$d9,$bb,$57,$77
>9788	74 89 57 77 74 bc 84 8b			.byte	$74,$89,$57,$77,$74,$bc,$84,$8b
>9790	41 00 17 21 01 d9 bb 8b			.byte	$41,$00,$17,$21,$01,$d9,$bb,$8b
>9798	41 52 65 54 80 8b 62 77			.byte	$41,$52,$65,$54,$80,$8b,$62,$77
>97a0	53 bc 84 8b 41 72 77 54			.byte	$53,$bc,$84,$8b,$41,$72,$77,$54
>97a8	00 15 22 01 d9 b2 43 57			.byte	$00,$15,$22,$01,$d9,$b2,$43,$57
>97b0	49 51 bd 8b 41 6a 50 56			.byte	$49,$51,$bd,$8b,$41,$6a,$50,$56
>97b8	bc 84 42 68 65 00 10 23			.byte	$bc,$84,$42,$68,$65,$00,$10,$23
>97c0	01 d9 a6 fe 07 62 72 7a			.byte	$01,$d9,$a6,$fe,$07,$62,$72,$7a
>97c8	7a 74 bc 84 45 00 1d 24			.byte	$7a,$74,$bc,$84,$45,$00,$1d,$24
>97d0	01 d9 bb 42 60 7e 5d fd			.byte	$01,$d9,$bb,$42,$60,$7e,$5d,$fd
>97d8	04 39 36 8d 42 60 7e 5d			.byte	$04,$39,$36,$8d,$42,$60,$7e,$5d
>97e0	fd 04 39 36 bc 84 41 fd			.byte	$fd,$04,$39,$36,$bc,$84,$41,$fd
>97e8	03 30 00 14 25 01 d9 bb			.byte	$03,$30,$00,$14,$25,$01,$d9,$bb
>97f0	8b 43 57 46 48 85 8b 43			.byte	$8b,$43,$57,$46,$48,$85,$8b,$43
>97f8	57 46 48 bc 84 40 00 15			.byte	$57,$46,$48,$bc,$84,$40,$00,$15
>9800	26 01 d9 bb 8b 42 43 59			.byte	$26,$01,$d9,$bb,$8b,$42,$43,$59
>9808	4e 82 7a 67 bc 84 8b 42			.byte	$4e,$82,$7a,$67,$bc,$84,$8b,$42
>9810	43 63 6b 00 0e 27 01 d9			.byte	$43,$63,$6b,$00,$0e,$27,$01,$d9
>9818	98 8b 60 48 73 84 60 48			.byte	$98,$8b,$60,$48,$73,$84,$60,$48
>9820	72 00 10 28 01 d9 9b fe			.byte	$72,$00,$10,$28,$01,$d9,$9b,$fe
>9828	06 72 6a 6f 73 bc 84 41			.byte	$06,$72,$6a,$6f,$73,$bc,$84,$41
>9830	72 00 29 29 01 d9 bb 8b			.byte	$72,$00,$29,$29,$01,$d9,$bb,$8b
>9838	42 60 7d 78 fd 04 35 39			.byte	$42,$60,$7d,$78,$fd,$04,$35,$39
>9840	8c 8b 42 60 7d 78 fd 04			.byte	$8c,$8b,$42,$60,$7d,$78,$fd,$04
>9848	35 39 bc 84 44 fd 0d 33			.byte	$35,$39,$bc,$84,$44,$fd,$0d,$33
>9850	34 37 30 33 36 33 39 65			.byte	$34,$37,$30,$33,$36,$33,$39,$65
>9858	31 31 00 12 2a 01 d9 bb			.byte	$31,$31,$00,$12,$2a,$01,$d9,$bb
>9860	41 6b 52 7a 85 41 6b 52			.byte	$41,$6b,$52,$7a,$85,$41,$6b,$52
>9868	7a bc 84 40 00 18 2b 01			.byte	$7a,$bc,$84,$40,$00,$18,$2b,$01
>9870	d9 bb 8b 42 5e 6a 45 80			.byte	$d9,$bb,$8b,$42,$5e,$6a,$45,$80
>9878	8b 43 57 4f 51 bc 84 8b			.byte	$8b,$43,$57,$4f,$51,$bc,$84,$8b
>9880	43 5f 6f 55 00 1a 2c 01			.byte	$43,$5f,$6f,$55,$00,$1a,$2c,$01
>9888	d9 a5 a4 42 55 55 50 fd			.byte	$d9,$a5,$a4,$42,$55,$55,$50,$fd
>9890	04 34 34 bc bc 84 42 55			.byte	$04,$34,$34,$bc,$bc,$84,$42,$55
>9898	55 50 fd 04 34 34 00 0d			.byte	$55,$50,$fd,$04,$34,$34,$00,$0d
>98a0	2d 01 d9 b4 41 5f bc 84			.byte	$2d,$01,$d9,$b4,$41,$5f,$bc,$84
>98a8	fe 03 5f 00 1d 2e 01 d9			.byte	$fe,$03,$5f,$00,$1d,$2e,$01,$d9
>98b0	bb 8b 41 59 68 75 fd 04			.byte	$bb,$8b,$41,$59,$68,$75,$fd,$04
>98b8	38 34 84 8b 41 59 68 75			.byte	$38,$34,$84,$8b,$41,$59,$68,$75
>98c0	fd 04 38 34 bc 84 8b 41			.byte	$fd,$04,$38,$34,$bc,$84,$8b,$41
>98c8	00 13 2f 01 d9 bb 8b 41			.byte	$00,$13,$2f,$01,$d9,$bb,$8b,$41
>98d0	4c 6c 64 8d 64 64 47 bc			.byte	$4c,$6c,$64,$8d,$64,$64,$47,$bc
>98d8	84 8b 42 00 0f 30 01 d9			.byte	$84,$8b,$42,$00,$0f,$30,$01,$d9
>98e0	bb 40 80 41 51 5a 67 bc			.byte	$bb,$40,$80,$41,$51,$5a,$67,$bc
>98e8	84 40 00 0f 31 01 d9 9a			.byte	$84,$40,$00,$0f,$31,$01,$d9,$9a
>98f0	8b 7c 50 63 bc 84 7c 50			.byte	$8b,$7c,$50,$63,$bc,$84,$7c,$50
>98f8	63 00 0b 32 01 d9 a3 40			.byte	$63,$00,$0b,$32,$01,$d9,$a3,$40
>9900	bc 84 fe 02 00 18 33 01			.byte	$bc,$84,$fe,$02,$00,$18,$33,$01
>9908	d9 bb 5b 66 62 fd 04 35			.byte	$d9,$bb,$5b,$66,$62,$fd,$04,$35
>9910	38 88 5b 66 62 fd 04 35			.byte	$38,$88,$5b,$66,$62,$fd,$04,$35
>9918	38 bc 84 40 00 14 34 01			.byte	$38,$bc,$84,$40,$00,$14,$34,$01
>9920	d9 bb 8b 41 52 57 42 8b			.byte	$d9,$bb,$8b,$41,$52,$57,$42,$8b
>9928	8b 41 52 57 42 bc 84 40			.byte	$8b,$41,$52,$57,$42,$bc,$84,$40
>9930	00 14 35 01 d9 bb 41 5d			.byte	$00,$14,$35,$01,$d9,$bb,$41,$5d
>9938	79 44 82 41 60 52 49 bc			.byte	$79,$44,$82,$41,$60,$52,$49,$bc
>9940	84 7d 6b 4d 00 0f 36 01			.byte	$84,$7d,$6b,$4d,$00,$0f,$36,$01
>9948	d9 b3 8b 42 4e 45 5b bc			.byte	$d9,$b3,$8b,$42,$4e,$45,$5b,$bc
>9950	84 8b 41 00 13 37 01 d9			.byte	$84,$8b,$41,$00,$13,$37,$01,$d9
>9958	a7 43 48 4f 7a bc 84 fe			.byte	$a7,$43,$48,$4f,$7a,$bc,$84,$fe
>9960	07 43 38 33 46 41 00 1c			.byte	$07,$43,$38,$33,$46,$41,$00,$1c
>9968	38 01 d9 bb 8b 41 52 78			.byte	$38,$01,$d9,$bb,$8b,$41,$52,$78
>9970	7f fd 04 31 31 85 8b 41			.byte	$7f,$fd,$04,$31,$31,$85,$8b,$41
>9978	52 78 7f fd 04 31 31 bc			.byte	$52,$78,$7f,$fd,$04,$31,$31,$bc
>9980	84 40 00 14 39 01 d9 bb			.byte	$84,$40,$00,$14,$39,$01,$d9,$bb
>9988	8b 41 4c 6d 49 86 8b 42			.byte	$8b,$41,$4c,$6d,$49,$86,$8b,$42
>9990	63 6d 6e bc 84 40 00 13			.byte	$63,$6d,$6e,$bc,$84,$40,$00,$13
>9998	3a 01 d9 bb 42 76 65 70			.byte	$3a,$01,$d9,$bb,$42,$76,$65,$70
>99a0	80 4b 5d 66 bc 84 42 45			.byte	$80,$4b,$5d,$66,$bc,$84,$42,$45
>99a8	60 00 15 3b 01 d9 b2 8b			.byte	$60,$00,$15,$3b,$01,$d9,$b2,$8b
>99b0	63 5e 5b bd 8b 42 54 6f			.byte	$63,$5e,$5b,$bd,$8b,$42,$54,$6f
>99b8	5b bc 84 63 5e 5b 00 13			.byte	$5b,$bc,$84,$63,$5e,$5b,$00,$13
>99c0	3c 01 d9 af fe 07 42 37			.byte	$3c,$01,$d9,$af,$fe,$07,$42,$37
>99c8	43 33 31 bc 84 42 77 70			.byte	$43,$33,$31,$bc,$84,$42,$77,$70
>99d0	71 00 1d 3d 01 d9 bb 8b			.byte	$71,$00,$1d,$3d,$01,$d9,$bb,$8b
>99d8	53 72 7f fd 05 33 38 37			.byte	$53,$72,$7f,$fd,$05,$33,$38,$37
>99e0	89 8b 53 72 7f fd 05 33			.byte	$89,$8b,$53,$72,$7f,$fd,$05,$33
>99e8	38 37 bc 84 8b 41 00 0d			.byte	$38,$37,$bc,$84,$8b,$41,$00,$0d
>99f0	3e 01 d9 bb 40 84 40 bc			.byte	$3e,$01,$d9,$bb,$40,$84,$40,$bc
>99f8	84 8b 41 00 14 3f 01 d9			.byte	$84,$8b,$41,$00,$14,$3f,$01,$d9
>9a00	bb 8b 60 45 54 82 45 48			.byte	$bb,$8b,$60,$45,$54,$82,$45,$48
>9a08	52 bc 84 8b 65 4d 42 00			.byte	$52,$bc,$84,$8b,$65,$4d,$42,$00
>9a10	10 40 01 d9 98 8b 43 61			.byte	$10,$40,$01,$d9,$98,$8b,$43,$61
>9a18	5e 7b 84 43 61 5e 7a 00			.byte	$5e,$7b,$84,$43,$61,$5e,$7a,$00
>9a20	10 41 01 d9 a0 fe 03 6c			.byte	$10,$41,$01,$d9,$a0,$fe,$03,$6c
>9a28	bd 4a bc 84 fe 03 6c 00			.byte	$bd,$4a,$bc,$84,$fe,$03,$6c,$00
>9a30	1d 42 01 d9 bb 8b 42 6b			.byte	$1d,$42,$01,$d9,$bb,$8b,$42,$6b
>9a38	7b 64 fd 04 38 33 84 8b			.byte	$7b,$64,$fd,$04,$38,$33,$84,$8b
>9a40	42 6b 7b 64 fd 04 38 33			.byte	$42,$6b,$7b,$64,$fd,$04,$38,$33
>9a48	bc 84 8b 41 00 13 43 01			.byte	$bc,$84,$8b,$41,$00,$13,$43,$01
>9a50	d9 bb 41 5f 53 71 89 41			.byte	$d9,$bb,$41,$5f,$53,$71,$89,$41
>9a58	5f 53 71 bc 84 8b 41 00			.byte	$5f,$53,$71,$bc,$84,$8b,$41,$00
>9a60	14 44 01 d9 bb 8b 41 4f			.byte	$14,$44,$01,$d9,$bb,$8b,$41,$4f
>9a68	53 5c 82 40 bc 84 8b 41			.byte	$53,$5c,$82,$40,$bc,$84,$8b,$41
>9a70	4f 53 5c 00 1a 45 01 d9			.byte	$4f,$53,$5c,$00,$1a,$45,$01,$d9
>9a78	a5 a4 42 7b 53 5a fd 04			.byte	$a5,$a4,$42,$7b,$53,$5a,$fd,$04
>9a80	34 33 bc bc 84 42 7b 53			.byte	$34,$33,$bc,$bc,$84,$42,$7b,$53
>9a88	5a fd 04 34 33 00 14 46			.byte	$5a,$fd,$04,$34,$33,$00,$14,$46
>9a90	01 d9 a1 fe 06 6c 79 6c			.byte	$01,$d9,$a1,$fe,$06,$6c,$79,$6c
>9a98	68 bd 42 bc 84 fe 04 6c			.byte	$68,$bd,$42,$bc,$84,$fe,$04,$6c
>9aa0	68 00 23 47 01 d9 bb 8b			.byte	$68,$00,$23,$47,$01,$d9,$bb,$8b
>9aa8	42 63 7a 63 fd 04 37 35			.byte	$42,$63,$7a,$63,$fd,$04,$37,$35
>9ab0	8a 8b 42 63 7a 63 fd 04			.byte	$8a,$8b,$42,$63,$7a,$63,$fd,$04
>9ab8	37 35 bc 84 8b 45 47 75			.byte	$37,$35,$bc,$84,$8b,$45,$47,$75
>9ac0	47 fd 03 35 00 14 48 01			.byte	$47,$fd,$03,$35,$00,$14,$48,$01
>9ac8	d9 bb 8b 43 4a 51 77 8b			.byte	$d9,$bb,$8b,$43,$4a,$51,$77,$8b
>9ad0	8b 43 4a 51 77 bc 84 40			.byte	$8b,$43,$4a,$51,$77,$bc,$84,$40
>9ad8	00 17 49 01 d9 bb 8b 42			.byte	$00,$17,$49,$01,$d9,$bb,$8b,$42
>9ae0	67 61 46 82 41 5d 78 69			.byte	$67,$61,$46,$82,$41,$5d,$78,$69
>9ae8	bc 84 8b 43 7a 59 6d 00			.byte	$bc,$84,$8b,$43,$7a,$59,$6d,$00
>9af0	11 4a 01 d9 9a 8b 41 68			.byte	$11,$4a,$01,$d9,$9a,$8b,$41,$68
>9af8	43 7e bc 84 41 68 43 7e			.byte	$43,$7e,$bc,$84,$41,$68,$43,$7e
>9b00	00 13 4b 01 d9 a2 fe 05			.byte	$00,$13,$4b,$01,$d9,$a2,$fe,$05
>9b08	6c 6c 75 bd 44 bd 4a bc			.byte	$6c,$6c,$75,$bd,$44,$bd,$4a,$bc
>9b10	84 fe 02 00 1d 4c 01 d9			.byte	$84,$fe,$02,$00,$1d,$4c,$01,$d9
>9b18	bb 42 7f 75 53 fd 04 30			.byte	$bb,$42,$7f,$75,$53,$fd,$04,$30
>9b20	37 8b 42 7f 75 53 fd 04			.byte	$37,$8b,$42,$7f,$75,$53,$fd,$04
>9b28	30 37 bc 84 40 fd 03 30			.byte	$30,$37,$bc,$84,$40,$fd,$03,$30
>9b30	00 13 4d 01 d9 bb 8b 74			.byte	$00,$13,$4d,$01,$d9,$bb,$8b,$74
>9b38	69 5a 89 8b 74 69 5a bc			.byte	$69,$5a,$89,$8b,$74,$69,$5a,$bc
>9b40	84 8b 41 00 18 4e 01 d9			.byte	$84,$8b,$41,$00,$18,$4e,$01,$d9
>9b48	bb 8b 41 58 54 68 80 8b			.byte	$bb,$8b,$41,$58,$54,$68,$80,$8b
>9b50	42 52 75 6a bc 84 8b 43			.byte	$42,$52,$75,$6a,$bc,$84,$8b,$43
>9b58	5a 75 70 00 0d 4f 01 d9			.byte	$5a,$75,$70,$00,$0d,$4f,$01,$d9
>9b60	b3 43 62 67 61 bc 84 41			.byte	$b3,$43,$62,$67,$61,$bc,$84,$41
>9b68	00 0f 50 01 d9 a6 fe 06			.byte	$00,$0f,$50,$01,$d9,$a6,$fe,$06
>9b70	6d 61 66 66 bc 84 44 00			.byte	$6d,$61,$66,$66,$bc,$84,$44,$00
>9b78	19 51 01 d9 bb 71 45 6d			.byte	$19,$51,$01,$d9,$bb,$71,$45,$6d
>9b80	fd 04 35 32 89 71 45 6d			.byte	$fd,$04,$35,$32,$89,$71,$45,$6d
>9b88	fd 04 35 32 bc 84 8b 41			.byte	$fd,$04,$35,$32,$bc,$84,$8b,$41
>9b90	00 15 52 01 d9 bb 8b 41			.byte	$00,$15,$52,$01,$d9,$bb,$8b,$41
>9b98	63 54 45 89 8b 41 63 54			.byte	$63,$54,$45,$89,$8b,$41,$63,$54
>9ba0	45 bc 84 8b 41 00 15 53			.byte	$45,$bc,$84,$8b,$41,$00,$15,$53
>9ba8	01 d9 bb 8b 42 6a 57 55			.byte	$01,$d9,$bb,$8b,$42,$6a,$57,$55
>9bb0	81 8b 55 56 44 bc 84 8b			.byte	$81,$8b,$55,$56,$44,$bc,$84,$8b
>9bb8	56 41 00 14 54 01 d9 b2			.byte	$56,$41,$00,$14,$54,$01,$d9,$b2
>9bc0	8b 43 6d 42 7c bd 51 65			.byte	$8b,$43,$6d,$42,$7c,$bd,$51,$65
>9bc8	44 bc 84 48 61 48 00 15			.byte	$44,$bc,$84,$48,$61,$48,$00,$15
>9bd0	55 01 d9 9b fe 0b 68 74			.byte	$55,$01,$d9,$9b,$fe,$0b,$68,$74
>9bd8	70 76 6a 68 67 70 6e bc			.byte	$70,$76,$6a,$68,$67,$70,$6e,$bc
>9be0	84 41 68 00 1b 56 01 d9			.byte	$84,$41,$68,$00,$1b,$56,$01,$d9
>9be8	bb 42 6d 69 47 fd 04 35			.byte	$bb,$42,$6d,$69,$47,$fd,$04,$35
>9bf0	35 89 42 6d 69 47 fd 04			.byte	$35,$89,$42,$6d,$69,$47,$fd,$04
>9bf8	35 35 bc 84 8b 41 00 0c			.byte	$35,$35,$bc,$84,$8b,$41,$00,$0c
>9c00	57 01 d9 bb 40 8b 40 bc			.byte	$57,$01,$d9,$bb,$40,$8b,$40,$bc
>9c08	84 40 00 14 58 01 d9 bb			.byte	$84,$40,$00,$14,$58,$01,$d9,$bb
>9c10	40 81 8b 41 46 49 65 bc			.byte	$40,$81,$8b,$41,$46,$49,$65,$bc
>9c18	84 8b 41 46 49 65 00 10			.byte	$84,$8b,$41,$46,$49,$65,$00,$10
>9c20	59 01 d9 98 41 64 66 69			.byte	$59,$01,$d9,$98,$41,$64,$66,$69
>9c28	84 8b 41 64 66 6a 00 0d			.byte	$84,$8b,$41,$64,$66,$6a,$00,$0d
>9c30	5a 01 d9 b4 41 4c bc 84			.byte	$5a,$01,$d9,$b4,$41,$4c,$bc,$84
>9c38	fe 03 4c 00 1f 5b 01 d9			.byte	$fe,$03,$4c,$00,$1f,$5b,$01,$d9
>9c40	bb 8b 4c 7e 48 fd 05 32			.byte	$bb,$8b,$4c,$7e,$48,$fd,$05,$32
>9c48	39 38 8d 8b 4c 7e 48 fd			.byte	$39,$38,$8d,$8b,$4c,$7e,$48,$fd
>9c50	05 32 39 38 bc 84 41 fd			.byte	$05,$32,$39,$38,$bc,$84,$41,$fd
>9c58	03 30 00 13 5c 01 d9 bb			.byte	$03,$30,$00,$13,$5c,$01,$d9,$bb
>9c60	41 44 4b 71 87 41 44 4b			.byte	$41,$44,$4b,$71,$87,$41,$44,$4b
>9c68	71 bc 84 8b 41 00 16 5d			.byte	$71,$bc,$84,$8b,$41,$00,$16,$5d
>9c70	01 d9 bb 8b 41 7b 53 65			.byte	$01,$d9,$bb,$8b,$41,$7b,$53,$65
>9c78	81 43 6f 66 7c bc 84 8b			.byte	$81,$43,$6f,$66,$7c,$bc,$84,$8b
>9c80	50 51 41 00 1c 5e 01 d9			.byte	$50,$51,$41,$00,$1c,$5e,$01,$d9
>9c88	a5 a4 8b 43 6d 7d 4b fd			.byte	$a5,$a4,$8b,$43,$6d,$7d,$4b,$fd
>9c90	04 35 36 bc bc 84 8b 43			.byte	$04,$35,$36,$bc,$bc,$84,$8b,$43
>9c98	6d 7d 4b fd 04 35 36 00			.byte	$6d,$7d,$4b,$fd,$04,$35,$36,$00
>9ca0	12 5f 01 d9 a3 47 bc 84			.byte	$12,$5f,$01,$d9,$a3,$47,$bc,$84
>9ca8	fe 09 20 20 20 20 20 20			.byte	$fe,$09,$20,$20,$20,$20,$20,$20
>9cb0	20 00 10 60 01 d4 fe 09			.byte	$20,$00,$10,$60,$01,$d4,$fe,$09
>9cb8	50 61 73 73 65 64 2e be			.byte	$50,$61,$73,$73,$65,$64,$2e,$be
>9cc0	c2 00 00				.byte	$c2,$00,$00

;******  Return to file: modules/hardware/mega65.asm

.a000					StartROM:
.a000	a2 ff		ldx #$ff			ldx 		#$FF 					; empty stack
.a002	9a		txs				txs
.a003	20 40 a2	jsr $a240			jsr 	IF_Reset 					; reset external interface
.a006	20 0c a0	jsr $a00c			jsr 	IFT_ClearScreen
.a009	4c a2 ad	jmp $ada2		jmp BASIC_Start

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.a00c					IFT_ClearScreen:
.a00c	48		pha				pha
.a00d	da		phx				phx
.a00e	5a		phy				phy
.a00f	20 a7 a1	jsr $a1a7			jsr 	IF_Home 					; home cursor
.a012	a2 19		ldx #$19			ldx 	#IF_Height 					; this many lines.
.a014					_IFT_CS0:
.a014	a0 50		ldy #$50			ldy 	#IF_Width 					; this many chars/line
.a016					_IFT_CS1:
.a016	a9 20		lda #$20			lda 	#' '						; clear line.
.a018	20 d6 a1	jsr $a1d6			jsr 	IF_Write
.a01b	88		dey				dey
.a01c	d0 f8		bne $a016			bne 	_IFT_CS1
.a01e	20 b6 a1	jsr $a1b6			jsr 	IF_NewLine 					; next line down
.a021	ca		dex				dex
.a022	d0 f0		bne $a014			bne 	_IFT_CS0
.a024	7a		ply				ply
.a025	fa		plx				plx
.a026	68		pla				pla
.a027					IFT_HomeCursor:
.a027	48		pha				pha
.a028	20 a7 a1	jsr $a1a7			jsr 	IF_Home
.a02b	a9 00		lda #$00			lda 	#0
.a02d	8d 00 02	sta $0200			sta 	IFT_XCursor
.a030	8d 01 02	sta $0201			sta 	IFT_YCursor
.a033	68		pla				pla
.a034	60		rts				rts
.a035					IFT_UpLine:
.a035	48		pha				pha
.a036	ad 01 02	lda $0201			lda  	IFT_YCursor 				; get Y
.a039	3a		dec a				dec 	a 							; line above
.a03a	30 03		bmi $a03f			bmi 	_IFTULExit 					; too far, abort
.a03c	20 ca a0	jsr $a0ca			jsr 	IFT_SetYPos					; set to that line.
.a03f					_IFTULExit:
.a03f	68		pla				pla
.a040	60		rts				rts
.a041					IFT_PrintCharacter:
.a041	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.a043	f0 16		beq $a05b			beq 	IFT_NewLine
.a045	48		pha				pha
.a046	20 73 a0	jsr $a073			jsr 	IFT_UpperCase 				; make upper case
.a049	20 d6 a1	jsr $a1d6			jsr 	IF_Write 					; write out.
.a04c	ee 00 02	inc $0200			inc 	IFT_XCursor 				; bump x cursor
.a04f	ad 00 02	lda $0200			lda 	IFT_XCursor 				; reached RHS ?
.a052	c9 50		cmp #$50			cmp 	#IF_Width
.a054	d0 03		bne $a059			bne 	_IFT_PCNotEOL
.a056	20 5b a0	jsr $a05b			jsr 	IFT_NewLine 				; if so do new line.
.a059					_IFT_PCNotEOL:
.a059	68		pla				pla
.a05a	60		rts				rts
.a05b					IFT_NewLine:
.a05b	48		pha				pha
.a05c	20 b6 a1	jsr $a1b6			jsr 	IF_NewLine 					; new line on actual screen.
.a05f	a9 00		lda #$00			lda 	#0 							; reset x position
.a061	8d 00 02	sta $0200			sta 	IFT_XCursor
.a064	ee 01 02	inc $0201			inc 	IFT_YCursor 				; move down.
.a067	ad 01 02	lda $0201			lda 	IFT_YCursor
.a06a	c9 19		cmp #$19			cmp 	#IF_Height 					; reached bottom.
.a06c	d0 03		bne $a071			bne 	_IFT_NL_NotEOS
.a06e	20 7e a0	jsr $a07e			jsr 	IFT_Scroll 					; scroll screen up.
.a071					_IFT_NL_NotEOS:
.a071	68		pla				pla
.a072	60		rts				rts
.a073					IFT_UpperCase:
.a073	c9 61		cmp #$61			cmp 	#"a"
.a075	90 06		bcc $a07d			bcc 	_IFT_UCExit
.a077	c9 7b		cmp #$7b			cmp 	#"z"+1
.a079	b0 02		bcs $a07d			bcs 	_IFT_UCExit
.a07b	49 20		eor #$20			eor 	#$20
.a07d					_IFT_UCExit:
.a07d	60		rts				rts
.a07e					IFT_Scroll:
.a07e	48		pha				pha 								; save AXY
.a07f	da		phx				phx
.a080	5a		phy				phy
.a081	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.a083					_IFT_SLoop:
.a083	20 a3 a0	jsr $a0a3			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.a086	e8		inx				inx
.a087	e0 18		cpx #$18			cpx 	#IF_Height-1				; do whole screen
.a089	d0 f8		bne $a083			bne 	_IFT_SLoop
.a08b	a9 18		lda #$18			lda 	#IF_Height-1 				; move to X = 0,Y = A
.a08d	20 ca a0	jsr $a0ca			jsr 	IFT_SetYPos
.a090	a2 50		ldx #$50			ldx 	#IF_Width 					; blank line
.a092					_IFT_SBlank:
.a092	a9 20		lda #$20			lda 	#32
.a094	20 d6 a1	jsr $a1d6			jsr 	IF_Write
.a097	ca		dex				dex
.a098	d0 f8		bne $a092			bne 	_IFT_SBlank
.a09a	a9 18		lda #$18			lda 	#IF_Height-1 				; move to X = 0,Y = A
.a09c	20 ca a0	jsr $a0ca			jsr 	IFT_SetYPos
.a09f	7a		ply				ply
.a0a0	fa		plx				plx
.a0a1	68		pla				pla
.a0a2	60		rts				rts
.a0a3					_IFT_ScrollLine:
.a0a3	da		phx				phx
.a0a4	da		phx				phx
.a0a5	8a		txa				txa 								; copy line into buffer.
.a0a6	1a		inc a				inc 	a 							; next line down.
.a0a7	20 ca a0	jsr $a0ca			jsr 	IFT_SetYPos
.a0aa	a2 00		ldx #$00			ldx 	#0
.a0ac					_IFTScrollCopy1:
.a0ac	20 c8 a1	jsr $a1c8			jsr 	IF_Read
.a0af	9d 02 02	sta $0202,x			sta 	IFT_Buffer,x
.a0b2	e8		inx				inx
.a0b3	e0 50		cpx #$50			cpx 	#IF_Width
.a0b5	d0 f5		bne $a0ac			bne 	_IFTScrollCopy1
.a0b7	68		pla				pla
.a0b8	20 ca a0	jsr $a0ca			jsr 	IFT_SetYPos
.a0bb	a2 00		ldx #$00			ldx 	#0
.a0bd					_IFTScrollCopy2:
.a0bd	bd 02 02	lda $0202,x			lda 	IFT_Buffer,x
.a0c0	20 d6 a1	jsr $a1d6			jsr 	IF_Write
.a0c3	e8		inx				inx
.a0c4	e0 50		cpx #$50			cpx 	#IF_Width
.a0c6	d0 f5		bne $a0bd			bne 	_IFTScrollCopy2
.a0c8	fa		plx				plx
.a0c9	60		rts				rts
.a0ca					IFT_SetYPos:
.a0ca	48		pha				pha
.a0cb	da		phx				phx
.a0cc	aa		tax				tax
.a0cd	20 27 a0	jsr $a027			jsr 	IFT_HomeCursor
.a0d0	e0 00		cpx #$00			cpx 	#0
.a0d2	f0 09		beq $a0dd			beq 	_IFT_MOAExit
.a0d4					_IFT_MOALoop:
.a0d4	20 b6 a1	jsr $a1b6			jsr 	IF_NewLine
.a0d7	ee 01 02	inc $0201			inc 	IFT_YCursor
.a0da	ca		dex				dex
.a0db	d0 f7		bne $a0d4			bne		_IFT_MOALoop
.a0dd					_IFT_MOAExit:
.a0dd	fa		plx				plx
.a0de	68		pla				pla
.a0df	60		rts				rts
.a0e0					IFT_GetKeyCursor:
.a0e0	20 e8 a0	jsr $a0e8			jsr 	_IFT_FlipCursor 			; reverse current
.a0e3					_IFT_GKCWait:
.a0e3	20 f9 a1	jsr $a1f9			jsr 	IF_GetKey 					; get key
.a0e6	f0 fb		beq $a0e3			beq 	_IFT_GKCWait
.a0e8					_IFT_FlipCursor:
.a0e8	48		pha				pha 								; save
.a0e9	20 c8 a1	jsr $a1c8			jsr 	IF_Read 					; read
.a0ec	20 e1 a1	jsr $a1e1			jsr 	IF_LeftOne
.a0ef	49 80		eor #$80			eor 	#$80 						; reverse
.a0f1	20 d6 a1	jsr $a1d6			jsr 	IF_Write 					; write
.a0f4	20 e1 a1	jsr $a1e1			jsr 	IF_LeftOne
.a0f7	68		pla				pla
.a0f8	60		rts				rts
.a0f9					IFT_ReadLine:
.a0f9	48		pha				pha
.a0fa					_IFT_RLLoop:
.a0fa	20 e0 a0	jsr $a0e0			jsr 	IFT_GetKeyCursor 			; get keystroke
.a0fd	c9 0d		cmp #$0d			cmp 	#13							; return
.a0ff	f0 7d		beq $a17e			beq 	_IFT_RLExit
.a101	c9 20		cmp #$20			cmp 	#32 						; control character
.a103	90 05		bcc $a10a			bcc 	_IFT_Control
.a105	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.a108	80 f0		bra $a0fa			bra 	_IFT_RLLoop
.a10a					_IFT_Control:
.a10a	c9 01		cmp #$01			cmp 	#"A"-64
.a10c	f0 26		beq $a134			beq 	_IFT_Left
.a10e	c9 04		cmp #$04			cmp 	#"D"-64
.a110	f0 2e		beq $a140			beq 	_IFT_Right
.a112	c9 17		cmp #$17			cmp 	#"W"-64
.a114	f0 36		beq $a14c			beq 	_IFT_Up
.a116	c9 13		cmp #$13			cmp 	#"S"-64
.a118	f0 3e		beq $a158			beq 	_IFT_Down
.a11a	c9 08		cmp #$08			cmp 	#"H"-64
.a11c	f0 09		beq $a127			beq 	_IFT_Backspace
.a11e	c9 1a		cmp #$1a			cmp 	#"Z"-64
.a120	d0 d8		bne $a0fa			bne 	_IFT_RLLoop
.a122	20 0c a0	jsr $a00c			jsr 	IFT_ClearScreen				; clear CTL-Z
.a125	80 d3		bra $a0fa			bra 	_IFT_RLLoop
.a127					_IFT_Backspace:
.a127	ad 00 02	lda $0200			lda 	IFT_XCursor 				; check not start of line.
.a12a	f0 ce		beq $a0fa			beq 	_IFT_RLLoop
.a12c	20 e1 a1	jsr $a1e1			jsr 	IF_LeftOne
.a12f	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.a131	20 d6 a1	jsr $a1d6			jsr 	IF_Write
.a134					_IFT_Left:
.a134	ce 00 02	dec $0200			dec 	IFT_XCursor 				; left CTL-W
.a137	10 29		bpl $a162			bpl 	_IFT_Reposition
.a139	a9 4f		lda #$4f			lda 	#IF_Width-1
.a13b					_IFT_SetX:
.a13b	8d 00 02	sta $0200			sta 	IFT_XCursor
.a13e	80 22		bra $a162			bra 	_IFT_Reposition
.a140					_IFT_Right:
.a140	ee 00 02	inc $0200			inc 	IFT_XCursor
.a143	ad 00 02	lda $0200			lda 	IFT_XCursor
.a146	49 50		eor #$50			eor 	#IF_Width
.a148	f0 f1		beq $a13b			beq 	_IFT_SetX
.a14a	80 16		bra $a162			bra 	_IFT_Reposition
.a14c					_IFT_Up:
.a14c	ce 01 02	dec $0201			dec 	IFT_YCursor
.a14f	10 11		bpl $a162			bpl 	_IFT_Reposition
.a151	a9 18		lda #$18			lda 	#IF_Height-1
.a153					_IFT_SetY:
.a153	8d 01 02	sta $0201			sta 	IFT_YCursor
.a156	80 0a		bra $a162			bra 	_IFT_Reposition
.a158					_IFT_Down:
.a158	ee 01 02	inc $0201			inc 	IFT_YCursor
.a15b	ad 01 02	lda $0201			lda 	IFT_YCursor
.a15e	49 19		eor #$19			eor 	#IF_Height
.a160	f0 f1		beq $a153			beq 	_IFT_SetY
.a162					_IFT_Reposition:
.a162	ad 00 02	lda $0200			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.a165	48		pha				pha
.a166	ad 01 02	lda $0201			lda 	IFT_YCursor
.a169	20 ca a0	jsr $a0ca			jsr 	IFT_SetYPos
.a16c	68		pla				pla
.a16d	aa		tax				tax
.a16e	e0 00		cpx #$00			cpx 	#0
.a170	f0 88		beq $a0fa			beq 	_IFT_RLLoop
.a172					_IFT_MoveRight:
.a172	20 c8 a1	jsr $a1c8			jsr 	IF_Read
.a175	ee 00 02	inc $0200			inc 	IFT_XCursor
.a178	ca		dex				dex
.a179	d0 f7		bne $a172			bne 	_IFT_MoveRight
.a17b	4c fa a0	jmp $a0fa			jmp 	_IFT_RLLoop
.a17e					_IFT_RLExit:
.a17e	ad 01 02	lda $0201			lda 	IFT_YCursor 				; go to start of line.
.a181	20 ca a0	jsr $a0ca			jsr 	IFT_SetYPos
.a184	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.a186					_IFT_RLRead:
.a186	20 c8 a1	jsr $a1c8			jsr 	IF_Read
.a189	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.a18c	e8		inx				inx
.a18d	e0 50		cpx #$50			cpx 	#IF_Width
.a18f	d0 f5		bne $a186			bne 	_IFT_RLRead
.a191					_IFT_RL_Trim:
.a191	ca		dex				dex 	 							; previous char
.a192	30 07		bmi $a19b			bmi 	_IFT_Found 					; gone too far
.a194	bd 66 02	lda $0266,x			lda 	IFT_LineBuffer,x			; go back if space
.a197	c9 20		cmp #$20			cmp 	#" "
.a199	f0 f6		beq $a191			beq 	_IFT_RL_Trim
.a19b					_IFT_Found:
.a19b	e8		inx				inx 								; forward to non-space
.a19c	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.a19e	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.a1a1	68		pla				pla
.a1a2	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.a1a4	a0 02		ldy #$02			ldy 	#IFT_LineBuffer >> 8
.a1a6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_mega65.asm

=80					IF_Width 	= 80 							; characters across
=25					IF_Height 	= 25 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line
=6					IF_XPos 	= 6 							; current position, horizontal.
=8					IF_FarPtr 	= 8 							; far pointer (4 bytes)
=$1000					IF_Screen = $1000							; 2k screen RAM here
=$800					IF_CharSet = $800							; 2k character set (0-7F) here
.a1a7					IF_Home:
.a1a7	48		pha				pha 								; reset cursor position
.a1a8	a9 00		lda #$00			lda 	#IF_Screen & $FF
.a1aa	85 04		sta $04				sta 	IF_Pos
.a1ac	a9 10		lda #$10			lda 	#IF_Screen >> 8
.a1ae	85 05		sta $05				sta 	IF_Pos+1
.a1b0	a9 00		lda #$00			lda 	#0
.a1b2	85 06		sta $06				sta 	IF_XPos
.a1b4	68		pla				pla
.a1b5	60		rts				rts
.a1b6					IF_NewLine:
.a1b6	48		pha				pha
.a1b7	a9 00		lda #$00			lda 	#0 							; back to start of line
.a1b9	85 06		sta $06				sta 	IF_XPos
.a1bb	18		clc				clc 								; down one line
.a1bc	a5 04		lda $04				lda 	IF_Pos
.a1be	69 50		adc #$50			adc 	#80
.a1c0	85 04		sta $04				sta 	IF_Pos
.a1c2	90 02		bcc $a1c6			bcc 	_IF_NoCarry 				; carry through.
.a1c4	e6 05		inc $05				inc 	IF_Pos+1
.a1c6					_IF_NoCarry:
.a1c6	68		pla				pla
.a1c7	60		rts				rts
.a1c8					IF_Read:
.a1c8	5a		phy				phy 								; save current Y
.a1c9	a4 06		ldy $06				ldy 	IF_XPos 					; read character at current position
.a1cb	b1 04		lda ($04),y			lda 	(IF_Pos),y
.a1cd	49 20		eor #$20			eor 	#$20
.a1cf	18		clc				clc
.a1d0	69 20		adc #$20			adc 	#$20
.a1d2	e6 06		inc $06				inc 	IF_XPos 					; step right.
.a1d4	7a		ply				ply									; restore Y
.a1d5	60		rts				rts
.a1d6					IF_Write:
.a1d6	5a		phy				phy 								; save current Y
.a1d7	a4 06		ldy $06				ldy 	IF_XPos 					; write character at current position
.a1d9	29 bf		and #$bf			and 	#63+128 					; PETSCII
.a1db	91 04		sta ($04),y			sta 	(IF_Pos),y
.a1dd	e6 06		inc $06				inc 	IF_XPos 					; step right.
.a1df	7a		ply				ply									; restore Y
.a1e0	60		rts				rts
.a1e1					IF_LeftOne:
.a1e1	c6 06		dec $06				dec 	IF_XPos
.a1e3	60		rts				rts
.a1e4					IF_CheckBreak:
.a1e4	db		phz				phz
.a1e5	20 2d a2	jsr $a22d			jsr 	IF_SetupKeyAddress 			; point to keyboard
.a1e8	e6 08		inc $08				inc 	IF_FarPtr 					; point to modifiers.
.a1ea	ea		nop				nop 								; read modifiers.
.a1eb	b2 08		lda ($08),z			lda 	(IF_FarPtr),z
.a1ed	fb		plz				plz 								; restore Z
.a1ee	29 05		and #$05			and 	#5							; break is LeftShift+Ctrl
.a1f0	c9 05		cmp #$05			cmp 	#5
.a1f2	f0 02		beq $a1f6			beq 	_IF_CBExit
.a1f4	a9 00		lda #$00			lda 	#0
.a1f6					_IF_CBExit:
.a1f6	c9 00		cmp #$00			cmp 	#0
.a1f8	60		rts				rts
.a1f9					IF_GetKey:
.a1f9	db		phz				phz
.a1fa	20 2d a2	jsr $a22d			jsr 	IF_SetupKeyAddress
.a1fd	ea		nop				nop 								; read keyboard
.a1fe	b2 08		lda ($08),z			lda 	(IF_FarPtr),z
.a200	c9 14		cmp #$14			cmp 	#20
.a202	d0 02		bne $a206			bne 	_KMNo
.a204	a9 08		lda #$08			lda 	#"H"-64
.a206					_KMNo:
.a206	c9 91		cmp #$91			cmp 	#145
.a208	d0 02		bne $a20c			bne 	_KMNo
.a20a	a9 17		lda #$17			lda 	#"W"-64
.a20c					_KMNo:
.a20c	c9 11		cmp #$11			cmp 	#17
.a20e	d0 02		bne $a212			bne 	_KMNo
.a210	a9 13		lda #$13			lda 	#"S"-64
.a212					_KMNo:
.a212	c9 9d		cmp #$9d			cmp 	#157
.a214	d0 02		bne $a218			bne 	_KMNo
.a216	a9 01		lda #$01			lda 	#"A"-64
.a218					_KMNo:
.a218	c9 1d		cmp #$1d			cmp 	#29
.a21a	d0 02		bne $a21e			bne 	_KMNo
.a21c	a9 04		lda #$04			lda 	#"D"-64
.a21e					_KMNo:
.a21e	c9 00		cmp #$00			cmp 	#0
.a220	f0 07		beq $a229			beq 	_IFGKEmpty
.a222	48		pha				pha
.a223	a9 00		lda #$00			lda 	#0
.a225	ea		nop				nop
.a226	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a228	68		pla				pla
.a229					_IFGKEmpty:
.a229	fb		plz				plz
.a22a	c9 00		cmp #$00			cmp 	#0 							; set Z
.a22c	60		rts				rts
.a22d					IF_SetupKeyAddress:
.a22d	a9 0f		lda #$0f			lda 	#$0F 						; set up to write to read keyboard.
.a22f	85 0b		sta $0b				sta 	IF_FarPtr+3
.a231	a9 fd		lda #$fd			lda 	#$FD
.a233	85 0a		sta $0a				sta 	IF_FarPtr+2
.a235	a9 36		lda #$36			lda 	#$36
.a237	85 09		sta $09				sta 	IF_FarPtr+1
.a239	a9 10		lda #$10			lda 	#$10
.a23b	85 08		sta $08				sta 	IF_FarPtr+0
.a23d	a3 00		ldz #$00			ldz 	#0
.a23f	60		rts				rts
.a240					IF_Reset:
.a240	48		pha				pha 								; save registers
.a241	da		phx				phx
.a242	5a		phy				phy
.a243	a9 0f		lda #$0f			lda 	#$0F 						; set up to write to video system.
.a245	85 0b		sta $0b				sta 	IF_FarPtr+3
.a247	a9 fd		lda #$fd			lda 	#$FD
.a249	85 0a		sta $0a				sta 	IF_FarPtr+2
.a24b	a9 30		lda #$30			lda 	#$30
.a24d	85 09		sta $09				sta 	IF_FarPtr+1
.a24f	a9 00		lda #$00			lda 	#$00
.a251	85 08		sta $08				sta 	IF_FarPtr+0
.a253	a3 2f		ldz #$2f			ldz 	#$2F 						; address already set up
.a255	a9 47		lda #$47			lda 	#$47
.a257	ea		nop				nop
.a258	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a25a	a3 2f		ldz #$2f			ldz 	#$2F 						; address already set up
.a25c	a9 53		lda #$53			lda 	#$53
.a25e	ea		nop				nop
.a25f	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a261	a3 30		ldz #$30			ldz 	#$30 						; address already set up
.a263	a9 40		lda #$40			lda 	#$40
.a265	ea		nop				nop
.a266	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a268	a3 31		ldz #$31			ldz 	#$31 						; address already set up
.a26a	a9 c0		lda #$c0			lda 	#$80+$40
.a26c	ea		nop				nop
.a26d	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a26f	a3 20		ldz #$20			ldz 	#$20 						; address already set up
.a271	a9 00		lda #$00			lda 	#0
.a273	ea		nop				nop
.a274	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a276	a3 21		ldz #$21			ldz 	#$21 						; address already set up
.a278	a9 00		lda #$00			lda 	#0
.a27a	ea		nop				nop
.a27b	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a27d	a3 54		ldz #$54			ldz 	#$54 						; address already set up
.a27f	a9 40		lda #$40			lda 	#$40
.a281	ea		nop				nop
.a282	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a284	a3 01		ldz #$01			ldz 	#$01 						; address already set up
.a286	a9 ff		lda #$ff			lda 	#$FF
.a288	ea		nop				nop
.a289	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a28b	a3 00		ldz #$00			ldz 	#$00 						; address already set up
.a28d	a9 ff		lda #$ff			lda 	#$FF
.a28f	ea		nop				nop
.a290	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a292	a3 16		ldz #$16			ldz 	#$16 						; address already set up
.a294	a9 cc		lda #$cc			lda 	#$CC
.a296	ea		nop				nop
.a297	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a299	a3 18		ldz #$18			ldz 	#$18 						; address already set up
.a29b	a9 42		lda #$42			lda 	#$42
.a29d	ea		nop				nop
.a29e	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2a0	a3 11		ldz #$11			ldz 	#$11 						; address already set up
.a2a2	a9 1b		lda #$1b			lda 	#$1B
.a2a4	ea		nop				nop
.a2a5	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2a7	a9 00		lda #$00			lda 	#$00						; colour RAM at $1F800-1FFFF (2kb)
.a2a9	85 0b		sta $0b				sta 	IF_FarPtr+3
.a2ab	a9 01		lda #$01			lda 	#$01
.a2ad	85 0a		sta $0a				sta 	IF_FarPtr+2
.a2af	a9 f8		lda #$f8			lda 	#$F8
.a2b1	85 09		sta $09				sta 	IF_FarPtr+1
.a2b3	a9 00		lda #$00			lda 	#$00
.a2b5	85 08		sta $08				sta 	IF_FarPtr+0
.a2b7	a3 00		ldz #$00			ldz 	#0
.a2b9					_EXTClearColorRam:
.a2b9	a9 05		lda #$05			lda 	#5							; fill that with this colour.
.a2bb	ea		nop				nop
.a2bc	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2be	3b		dez				dez
.a2bf	d0 f8		bne $a2b9			bne 	_EXTClearColorRam
.a2c1	e6 09		inc $09				inc 	IF_FarPtr+1
.a2c3	d0 f4		bne $a2b9			bne 	_EXTClearColorRam
.a2c5	a2 00		ldx #$00			ldx 	#0 							; copy PET Font into memory.
.a2c7					_EXTCopyCBMFont:
.a2c7	bd 08 a3	lda $a308,x			lda 	IF_CBMFont,x 				; +$800 uses the lower case c/set
.a2ca	9d 00 08	sta $0800,x			sta 	IF_CharSet,x
.a2cd	49 ff		eor #$ff			eor 	#$FF
.a2cf	9d 00 0c	sta $0c00,x			sta 	IF_CharSet+$400,x
.a2d2	bd 08 a4	lda $a408,x			lda 	IF_CBMFont+$100,x
.a2d5	9d 00 09	sta $0900,x			sta 	IF_CharSet+$100,x
.a2d8	49 ff		eor #$ff			eor 	#$FF
.a2da	9d 00 0d	sta $0d00,x			sta 	IF_CharSet+$500,x
.a2dd	bd 08 a5	lda $a508,x			lda 	IF_CBMFont+$200,x
.a2e0	9d 00 0a	sta $0a00,x			sta 	IF_CharSet+$200,x
.a2e3	49 ff		eor #$ff			eor 	#$FF
.a2e5	9d 00 0e	sta $0e00,x			sta 	IF_CharSet+$600,x
.a2e8	bd 08 a6	lda $a608,x			lda 	IF_CBMFont+$300,x
.a2eb	9d 00 0b	sta $0b00,x			sta 	IF_CharSet+$300,x
.a2ee	49 ff		eor #$ff			eor 	#$FF
.a2f0	9d 00 0f	sta $0f00,x			sta 	IF_CharSet+$700,x
.a2f3	ca		dex				dex
.a2f4	d0 d1		bne $a2c7			bne 	_EXTCopyCBMFont
.a2f6	a9 3b		lda #$3b			lda 	#$3F-4  					; puts ROM back in the map (the -4)
.a2f8	85 01		sta $01				sta 	$01
.a2fa	a9 00		lda #$00			lda 	#$00						; do not map bytes 0000-7FFF
.a2fc	a2 00		ldx #$00			ldx 	#$00						; (so we use the RAM physically at $0000-$7FFF)
.a2fe	a0 00		ldy #$00			ldy 	#$00 						; 8000-FFFF offset by $200. The lower 8 bits are $00
.a300	a3 f2		ldz #$f2			ldz 	#$F2 						; so this is an actual offset of $20000. So the space at
.a302	5c		map				map
.a303	ea		nop				eom
.a304	7a		ply				ply 								; restore and exit.
.a305	fa		plx				plx
.a306	68		pla				pla
.a307	60		rts				rts
.a308					IF_CBMFont:
>a308	1c 22 4a 56 4c 20 1e 00				.binary "pet-font.bin"
>a310	18 24 42 7e 42 42 42 00 7c 22 22 3c 22 22 7c 00
>a320	1c 22 40 40 40 22 1c 00 78 24 22 22 22 24 78 00
>a330	7e 40 40 78 40 40 7e 00 7e 40 40 78 40 40 40 00
>a340	1c 22 40 4e 42 22 1c 00 42 42 42 7e 42 42 42 00
>a350	1c 08 08 08 08 08 1c 00 0e 04 04 04 04 44 38 00
>a360	42 44 48 70 48 44 42 00 40 40 40 40 40 40 7e 00
>a370	42 66 5a 5a 42 42 42 00 42 62 52 4a 46 42 42 00
>a380	18 24 42 42 42 24 18 00 7c 42 42 7c 40 40 40 00
>a390	18 24 42 42 4a 24 1a 00 7c 42 42 7c 48 44 42 00
>a3a0	3c 42 40 3c 02 42 3c 00 3e 08 08 08 08 08 08 00
>a3b0	42 42 42 42 42 42 3c 00 42 42 42 24 24 18 18 00
>a3c0	42 42 42 5a 5a 66 42 00 42 42 24 18 24 42 42 00
>a3d0	22 22 22 1c 08 08 08 00 7e 02 04 18 20 40 7e 00
>a3e0	3c 20 20 20 20 20 3c 00 00 40 20 10 08 04 02 00
>a3f0	3c 04 04 04 04 04 3c 00 00 08 1c 2a 08 08 08 08
>a400	00 00 10 20 7f 20 10 00 00 00 00 00 00 00 00 00
>a410	08 08 08 08 00 00 08 00 24 24 24 00 00 00 00 00
>a420	24 24 7e 24 7e 24 24 00 08 1e 28 1c 0a 3c 08 00
>a430	00 62 64 08 10 26 46 00 30 48 48 30 4a 44 3a 00
>a440	04 08 10 00 00 00 00 00 04 08 10 10 10 08 04 00
>a450	20 10 08 08 08 10 20 00 08 2a 1c 3e 1c 2a 08 00
>a460	00 08 08 3e 08 08 00 00 00 00 00 00 00 08 08 10
>a470	00 00 00 7e 00 00 00 00 00 00 00 00 00 18 18 00
>a480	00 02 04 08 10 20 40 00 3c 42 46 5a 62 42 3c 00
>a490	08 18 28 08 08 08 3e 00 3c 42 02 0c 30 40 7e 00
>a4a0	3c 42 02 1c 02 42 3c 00 04 0c 14 24 7e 04 04 00
>a4b0	7e 40 78 04 02 44 38 00 1c 20 40 7c 42 42 3c 00
>a4c0	7e 42 04 08 10 10 10 00 3c 42 42 3c 42 42 3c 00
>a4d0	3c 42 42 3e 02 04 38 00 00 00 08 00 00 08 00 00
>a4e0	00 00 08 00 00 08 08 10 0e 18 30 60 30 18 0e 00
>a4f0	00 00 7e 00 7e 00 00 00 70 18 0c 06 0c 18 70 00
>a500	3c 42 02 0c 10 00 10 00 00 00 00 00 ff 00 00 00
>a510	08 1c 3e 7f 7f 1c 3e 00 10 10 10 10 10 10 10 10
>a520	00 00 00 ff 00 00 00 00 00 00 ff 00 00 00 00 00
>a530	00 ff 00 00 00 00 00 00 00 00 00 00 00 ff 00 00
>a540	20 20 20 20 20 20 20 20 04 04 04 04 04 04 04 04
>a550	00 00 00 00 e0 10 08 08 08 08 08 04 03 00 00 00
>a560	08 08 08 10 e0 00 00 00 80 80 80 80 80 80 80 ff
>a570	80 40 20 10 08 04 02 01 01 02 04 08 10 20 40 80
>a580	ff 80 80 80 80 80 80 80 ff 01 01 01 01 01 01 01
>a590	00 3c 7e 7e 7e 7e 3c 00 00 00 00 00 00 00 ff 00
>a5a0	36 7f 7f 7f 3e 1c 08 00 40 40 40 40 40 40 40 40
>a5b0	00 00 00 00 03 04 08 08 81 42 24 18 18 24 42 81
>a5c0	00 3c 42 42 42 42 3c 00 08 1c 2a 77 2a 08 08 00
>a5d0	02 02 02 02 02 02 02 02 08 1c 3e 7f 3e 1c 08 00
>a5e0	08 08 08 08 ff 08 08 08 a0 50 a0 50 a0 50 a0 50
>a5f0	08 08 08 08 08 08 08 08 00 00 01 3e 54 14 14 00
>a600	ff 7f 3f 1f 0f 07 03 01 00 00 00 00 00 00 00 00
>a610	f0 f0 f0 f0 f0 f0 f0 f0 00 00 00 00 ff ff ff ff
>a620	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff
>a630	80 80 80 80 80 80 80 80 aa 55 aa 55 aa 55 aa 55
>a640	01 01 01 01 01 01 01 01 00 00 00 00 aa 55 aa 55
>a650	ff fe fc f8 f0 e0 c0 80 03 03 03 03 03 03 03 03
>a660	08 08 08 08 0f 08 08 08 00 00 00 00 0f 0f 0f 0f
>a670	08 08 08 08 0f 00 00 00 00 00 00 00 f8 08 08 08
>a680	00 00 00 00 00 00 ff ff 00 00 00 00 0f 08 08 08
>a690	08 08 08 08 ff 00 00 00 00 00 00 00 ff 08 08 08
>a6a0	08 08 08 08 f8 08 08 08 c0 c0 c0 c0 c0 c0 c0 c0
>a6b0	e0 e0 e0 e0 e0 e0 e0 e0 07 07 07 07 07 07 07 07
>a6c0	ff ff 00 00 00 00 00 00 ff ff ff 00 00 00 00 00
>a6d0	00 00 00 00 00 ff ff ff 01 01 01 01 01 01 01 ff
>a6e0	00 00 00 00 f0 f0 f0 f0 0f 0f 0f 0f 00 00 00 00
>a6f0	08 08 08 08 f8 00 00 00 f0 f0 f0 f0 00 00 00 00
>a700	f0 f0 f0 f0 0f 0f 0f 0f 1c 22 4a 56 4c 20 1e 00
>a710	18 24 42 7e 42 42 42 00 7c 22 22 3c 22 22 7c 00
>a720	1c 22 40 40 40 22 1c 00 78 24 22 22 22 24 78 00
>a730	7e 40 40 78 40 40 7e 00 7e 40 40 78 40 40 40 00
>a740	1c 22 40 4e 42 22 1c 00 42 42 42 7e 42 42 42 00
>a750	1c 08 08 08 08 08 1c 00 0e 04 04 04 04 44 38 00
>a760	42 44 48 70 48 44 42 00 40 40 40 40 40 40 7e 00
>a770	42 66 5a 5a 42 42 42 00 42 62 52 4a 46 42 42 00
>a780	18 24 42 42 42 24 18 00 7c 42 42 7c 40 40 40 00
>a790	18 24 42 42 4a 24 1a 00 7c 42 42 7c 48 44 42 00
>a7a0	3c 42 40 3c 02 42 3c 00 3e 08 08 08 08 08 08 00
>a7b0	42 42 42 42 42 42 3c 00 42 42 42 24 24 18 18 00
>a7c0	42 42 42 5a 5a 66 42 00 42 42 24 18 24 42 42 00
>a7d0	22 22 22 1c 08 08 08 00 7e 02 04 18 20 40 7e 00
>a7e0	3c 20 20 20 20 20 3c 00 00 40 20 10 08 04 02 00
>a7f0	3c 04 04 04 04 04 3c 00 00 08 1c 2a 08 08 08 08
>a800	00 00 10 20 7f 20 10 00 00 00 00 00 00 00 00 00
>a810	08 08 08 08 00 00 08 00 24 24 24 00 00 00 00 00
>a820	24 24 7e 24 7e 24 24 00 08 1e 28 1c 0a 3c 08 00
>a830	00 62 64 08 10 26 46 00 30 48 48 30 4a 44 3a 00
>a840	04 08 10 00 00 00 00 00 04 08 10 10 10 08 04 00
>a850	20 10 08 08 08 10 20 00 08 2a 1c 3e 1c 2a 08 00
>a860	00 08 08 3e 08 08 00 00 00 00 00 00 00 08 08 10
>a870	00 00 00 7e 00 00 00 00 00 00 00 00 00 18 18 00
>a880	00 02 04 08 10 20 40 00 3c 42 46 5a 62 42 3c 00
>a890	08 18 28 08 08 08 3e 00 3c 42 02 0c 30 40 7e 00
>a8a0	3c 42 02 1c 02 42 3c 00 04 0c 14 24 7e 04 04 00
>a8b0	7e 40 78 04 02 44 38 00 1c 20 40 7c 42 42 3c 00
>a8c0	7e 42 04 08 10 10 10 00 3c 42 42 3c 42 42 3c 00
>a8d0	3c 42 42 3e 02 04 38 00 00 00 08 00 00 08 00 00
>a8e0	00 00 08 00 00 08 08 10 0e 18 30 60 30 18 0e 00
>a8f0	00 00 7e 00 7e 00 00 00 70 18 0c 06 0c 18 70 00
>a900	3c 42 02 0c 10 00 10 00 00 00 00 00 ff 00 00 00
>a910	00 00 38 04 3c 44 3a 00 40 40 5c 62 42 62 5c 00
>a920	00 00 3c 42 40 42 3c 00 02 02 3a 46 42 46 3a 00
>a930	00 00 3c 42 7e 40 3c 00 0c 12 10 7c 10 10 10 00
>a940	00 00 3a 46 46 3a 02 3c 40 40 5c 62 42 42 42 00
>a950	08 00 18 08 08 08 1c 00 04 00 0c 04 04 04 44 38
>a960	40 40 44 48 50 68 44 00 18 08 08 08 08 08 1c 00
>a970	00 00 76 49 49 49 49 00 00 00 5c 62 42 42 42 00
>a980	00 00 3c 42 42 42 3c 00 00 00 5c 62 62 5c 40 40
>a990	00 00 3a 46 46 3a 02 02 00 00 5c 62 40 40 40 00
>a9a0	00 00 3e 40 3c 02 7c 00 10 10 7c 10 10 12 0c 00
>a9b0	00 00 42 42 42 46 3a 00 00 00 42 42 42 24 18 00
>a9c0	00 00 41 49 49 49 36 00 00 00 42 24 18 24 42 00
>a9d0	00 00 42 42 46 3a 02 3c 00 00 7e 04 18 20 7e 00
>a9e0	08 08 08 08 ff 08 08 08 a0 50 a0 50 a0 50 a0 50
>a9f0	08 08 08 08 08 08 08 08 cc cc 33 33 cc cc 33 33
>aa00	cc 66 33 99 cc 66 33 99 00 00 00 00 00 00 00 00
>aa10	f0 f0 f0 f0 f0 f0 f0 f0 00 00 00 00 ff ff ff ff
>aa20	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff
>aa30	80 80 80 80 80 80 80 80 aa 55 aa 55 aa 55 aa 55
>aa40	01 01 01 01 01 01 01 01 00 00 00 00 aa 55 aa 55
>aa50	99 33 66 cc 99 33 66 cc 03 03 03 03 03 03 03 03
>aa60	08 08 08 08 0f 08 08 08 00 00 00 00 0f 0f 0f 0f
>aa70	08 08 08 08 0f 00 00 00 00 00 00 00 f8 08 08 08
>aa80	00 00 00 00 00 00 ff ff 00 00 00 00 0f 08 08 08
>aa90	08 08 08 08 ff 00 00 00 00 00 00 00 ff 08 08 08
>aaa0	08 08 08 08 f8 08 08 08 c0 c0 c0 c0 c0 c0 c0 c0
>aab0	e0 e0 e0 e0 e0 e0 e0 e0 07 07 07 07 07 07 07 07
>aac0	ff ff 00 00 00 00 00 00 ff ff ff 00 00 00 00 00
>aad0	00 00 00 00 00 ff ff ff 01 02 44 48 50 60 40 00
>aae0	00 00 00 00 f0 f0 f0 f0 0f 0f 0f 0f 00 00 00 00
>aaf0	08 08 08 08 f8 00 00 00 f0 f0 f0 f0 00 00 00 00
>ab00	f0 f0 f0 f0 0f 0f 0f 0f

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/errors.asm

.ab08					SyntaxError:
.ab08	20 37 ab	jsr $ab37			jsr 	ERR_Handler
>ab0b	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>ab13	72 72 6f 72 00
.ab18					TypeError:
.ab18	20 37 ab	jsr $ab37			jsr 	ERR_Handler
>ab1b	57 72 6f 6e 67 20 74 79				.text 	"Wrong type",0
>ab23	70 65 00
.ab26					BadParamError:
.ab26	20 37 ab	jsr $ab37			jsr 	ERR_Handler
>ab29	42 61 64 20 50 61 72 61				.text 	"Bad Parameter",0
>ab31	6d 65 74 65 72 00
.ab37					ERR_Handler:
.ab37	a0 00		ldy #$00			ldy 	#0
.ab39	c8		iny				iny
.ab3a	b1 16		lda ($16),y			lda 	(zCodePtr),y
.ab3c	8d 08 03	sta $0308			sta 	XS_Mantissa
.ab3f	c8		iny				iny
.ab40	b1 16		lda ($16),y			lda 	(zCodePtr),y
.ab42	8d 09 03	sta $0309			sta 	XS_Mantissa+1
.ab45	fa		plx				plx 								; address in XY
.ab46	7a		ply				ply
.ab47	e8		inx				inx 								; bump, because of RTS/JSR address -1
.ab48	d0 01		bne $ab4b			bne 	_EHNoSkip
.ab4a	c8		iny				iny
.ab4b					_EHNoSkip:
.ab4b	20 6c ab	jsr $ab6c			jsr 	PrintROMMessage 			; print message from ROM.
.ab4e	ad 08 03	lda $0308			lda 	XS_Mantissa					; line number = 0
.ab51	0d 09 03	ora $0309			ora 	XS_Mantissa+1
.ab54	f0 0c		beq $ab62			beq 	_EHNoLine
.ab56	a2 67		ldx #$67			ldx 	#_EHAt & $FF 				; print " at "
.ab58	a0 ab		ldy #$ab			ldy 	#(_EHAt >> 8) & $FF
.ab5a	20 6c ab	jsr $ab6c			jsr 	PrintROMMessage
.ab5d	a2 00		ldx #$00			ldx 	#0 							; Print line number
.ab5f	20 7d ab	jsr $ab7d			jsr 	Print16BitInteger
.ab62					_EHNoLine:
.ab62	80 fe		bra $ab62			bra 	_EHNoLine
.ab64	4c c2 ad	jmp $adc2			jmp 	WarmStart
>ab67	20 61 74 20 00			_EHAt:	.text 	" at ",0
.ab6c					PrintROMMessage:
.ab6c	86 1a		stx $1a				stx 	zLTemp1 					; save addres
.ab6e	84 1b		sty $1b				sty 	zLTemp1+1
.ab70	a0 00		ldy #$00			ldy 	#0
.ab72					_PRMLoop:
.ab72	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.ab74	f0 06		beq $ab7c			beq		_PRMExit
.ab76	c8		iny				iny
.ab77	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.ab7a	80 f6		bra $ab72			bra 	_PRMLoop
.ab7c					_PRMExit:
.ab7c	60		rts				rts
.ab7d					Print16BitInteger:
.ab7d	a9 00		lda #$00			lda 	#0 							; make 32 bit
.ab7f	8d 0a 03	sta $030a			sta 	XS_Mantissa+2
.ab82	8d 0b 03	sta $030b			sta 	XS_Mantissa+3
.ab85	8d 00 04	sta $0400			sta 	NumBufX 					; reset the conversion pointer
.ab88	aa		tax				tax 								; convert bottom level.
.ab89	20 92 b8	jsr $b892			jsr 	INTToString 				; make string
.ab8c	a2 00		ldx #$00			ldx 	#0 							; print buffer
.ab8e	bd 01 04	lda $0401,x	_P1Loop:lda 	Num_Buffer,x
.ab91	f0 06		beq $ab99			beq 	_P1Exit
.ab93	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.ab96	e8		inx				inx
.ab97	80 f5		bra $ab8e			bra 	_P1Loop
.ab99	60		rts		_P1Exit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm


;******  Processing file: modules/basic/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b4					lastUnaryFunction = $b4
.ab9a					VectorTable:
>ab9a	b0 b0					.word BinaryOp_And         & $FFFF ; $80 and
>ab9c	d8 b0					.word BinaryOp_Or          & $FFFF ; $81 or
>ab9e	00 b1					.word BinaryOp_Xor         & $FFFF ; $82 xor
>aba0	00 b1					.word BinaryOp_Eor         & $FFFF ; $83 eor
>aba2	44 b1					.word Binary_Equal         & $FFFF ; $84 =
>aba4	63 b1					.word Binary_NotEqual      & $FFFF ; $85 <>
>aba6	6c b1					.word Binary_Less          & $FFFF ; $86 <
>aba8	75 b1					.word Binary_LessEqual     & $FFFF ; $87 <=
>abaa	87 b1					.word Binary_Greater       & $FFFF ; $88 >
>abac	7e b1					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>abae	1c b2					.word BinaryOp_Add         & $FFFF ; $8a +
>abb0	3c b2					.word BinaryOp_Subtract    & $FFFF ; $8b -
>abb2	4f b2					.word BinaryOp_Multiply    & $FFFF ; $8c *
>abb4	62 b2					.word BinaryOp_Divide      & $FFFF ; $8d /
>abb6	4e ac					.word NotImplemented       & $FFFF ; $8e ^
>abb8	4e ac					.word NotImplemented       & $FFFF ; $8f if
>abba	4e ac					.word NotImplemented       & $FFFF ; $90 while
>abbc	4e ac					.word NotImplemented       & $FFFF ; $91 repeat
>abbe	4e ac					.word NotImplemented       & $FFFF ; $92 for
>abc0	4e ac					.word NotImplemented       & $FFFF ; $93 then
>abc2	4e ac					.word NotImplemented       & $FFFF ; $94 endif
>abc4	4e ac					.word NotImplemented       & $FFFF ; $95 wend
>abc6	4e ac					.word NotImplemented       & $FFFF ; $96 until
>abc8	4e ac					.word NotImplemented       & $FFFF ; $97 next
>abca	4e ac					.word NotImplemented       & $FFFF ; $98 not
>abcc	4e ac					.word NotImplemented       & $FFFF ; $99 fn(
>abce	96 b3					.word Unary_Abs            & $FFFF ; $9a abs(
>abd0	ed b4					.word Unary_Asc            & $FFFF ; $9b asc(
>abd2	73 c0					.word Unary_Int            & $FFFF ; $9c int(
>abd4	b4 b3					.word Unary_Peek           & $FFFF ; $9d peek(
>abd6	ea bf					.word Unary_Rnd            & $FFFF ; $9e rnd(
>abd8	28 b4					.word Unary_Usr            & $FFFF ; $9f usr(
>abda	2e b5					.word Unary_Left           & $FFFF ; $a0 left$(
>abdc	45 b5					.word Unary_Right          & $FFFF ; $a1 right$(
>abde	13 b5					.word Unary_Mid            & $FFFF ; $a2 mid$(
>abe0	a7 b6					.word Unary_Spc            & $FFFF ; $a3 spc(
>abe2	ba b4					.word Unary_Str            & $FFFF ; $a4 str$(
>abe4	49 b4					.word Unary_Val            & $FFFF ; $a5 val(
>abe6	04 b5					.word Unary_Len            & $FFFF ; $a6 len(
>abe8	c3 b5					.word Unary_Hex            & $FFFF ; $a7 hex$(
>abea	4e ac					.word NotImplemented       & $FFFF ; $a8 sin(
>abec	4e ac					.word NotImplemented       & $FFFF ; $a9 cos(
>abee	4e ac					.word NotImplemented       & $FFFF ; $aa tan(
>abf0	4e ac					.word NotImplemented       & $FFFF ; $ab atn(
>abf2	4e ac					.word NotImplemented       & $FFFF ; $ac exp(
>abf4	4e ac					.word NotImplemented       & $FFFF ; $ad log(
>abf6	4e ac					.word NotImplemented       & $FFFF ; $ae sqr(
>abf8	1d b6					.word Unary_Dec            & $FFFF ; $af dec(
>abfa	b8 b3					.word Unary_Deek           & $FFFF ; $b0 deek(
>abfc	bc b3					.word Unary_Leek           & $FFFF ; $b1 leek(
>abfe	f0 b3					.word Unary_Mod            & $FFFF ; $b2 mod(
>ac00	44 b3					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>ac02	85 b6					.word Unary_Chr            & $FFFF ; $b4 chr$(
>ac04	4e ac					.word NotImplemented       & $FFFF ; $b5 $(
>ac06	4e ac					.word NotImplemented       & $FFFF ; $b6 $
>ac08	4e ac					.word NotImplemented       & $FFFF ; $b7 #(
>ac0a	4e ac					.word NotImplemented       & $FFFF ; $b8 #
>ac0c	4e ac					.word NotImplemented       & $FFFF ; $b9 %(
>ac0e	4e ac					.word NotImplemented       & $FFFF ; $ba %
>ac10	4e ac					.word NotImplemented       & $FFFF ; $bb (
>ac12	4e ac					.word NotImplemented       & $FFFF ; $bc )
>ac14	4e ac					.word NotImplemented       & $FFFF ; $bd ,
>ac16	3c ae					.word Command_COLON        & $FFFF ; $be :
>ac18	4e ac					.word NotImplemented       & $FFFF ; $bf ;
>ac1a	4e ac					.word NotImplemented       & $FFFF ; $c0 def
>ac1c	ce ae					.word Command_CLR          & $FFFF ; $c1 clr
>ac1e	d9 ae					.word Command_STOP         & $FFFF ; $c2 stop
>ac20	4e ac					.word NotImplemented       & $FFFF ; $c3 data
>ac22	4e ac					.word NotImplemented       & $FFFF ; $c4 read
>ac24	4e ac					.word NotImplemented       & $FFFF ; $c5 dim
>ac26	4e ac					.word NotImplemented       & $FFFF ; $c6 to
>ac28	4e ac					.word NotImplemented       & $FFFF ; $c7 step
>ac2a	4e ac					.word NotImplemented       & $FFFF ; $c8 gosub
>ac2c	4e ac					.word NotImplemented       & $FFFF ; $c9 return
>ac2e	4e ac					.word NotImplemented       & $FFFF ; $ca goto
>ac30	3d ae					.word Command_END          & $FFFF ; $cb end
>ac32	4e ac					.word NotImplemented       & $FFFF ; $cc input
>ac34	4e ac					.word NotImplemented       & $FFFF ; $cd let
>ac36	4e ac					.word NotImplemented       & $FFFF ; $ce list
>ac38	4e ac					.word NotImplemented       & $FFFF ; $cf new
>ac3a	4e ac					.word NotImplemented       & $FFFF ; $d0 old
>ac3c	4e ac					.word NotImplemented       & $FFFF ; $d1 on
>ac3e	4e ac					.word NotImplemented       & $FFFF ; $d2 restore
>ac40	4e ac					.word NotImplemented       & $FFFF ; $d3 poke
>ac42	42 ae					.word Command_PRINT        & $FFFF ; $d4 print
>ac44	c8 ad					.word Command_RUN          & $FFFF ; $d5 run
>ac46	4e ac					.word NotImplemented       & $FFFF ; $d6 wait
>ac48	4e ac					.word NotImplemented       & $FFFF ; $d7 doke
>ac4a	4e ac					.word NotImplemented       & $FFFF ; $d8 loke
>ac4c	b2 ae					.word Command_ASSERT       & $FFFF ; $d9 assert
.ac4e					NotImplemented:
.ac4e	20 37 ab	jsr $ab37			jsr ERR_Handler
>ac51	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>ac59	65 6d 65 6e 74 65 64 00
.ac61					BinaryPrecedence:
>ac61	01					.byte 1    ; $80 and
>ac62	01					.byte 1    ; $81 or
>ac63	01					.byte 1    ; $82 xor
>ac64	01					.byte 1    ; $83 eor
>ac65	02					.byte 2    ; $84 =
>ac66	02					.byte 2    ; $85 <>
>ac67	02					.byte 2    ; $86 <
>ac68	02					.byte 2    ; $87 <=
>ac69	02					.byte 2    ; $88 >
>ac6a	02					.byte 2    ; $89 >=
>ac6b	03					.byte 3    ; $8a +
>ac6c	03					.byte 3    ; $8b -
>ac6d	04					.byte 4    ; $8c *
>ac6e	04					.byte 4    ; $8d /
>ac6f	05					.byte 5    ; $8e ^
.ac70					KeywordText:
>ac70	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>ac73	4f d2					.byte $4f,$d2                          ; $81 or
>ac75	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>ac78	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>ac7b	bd					.byte $bd                              ; $84 =
>ac7c	3c be					.byte $3c,$be                          ; $85 <>
>ac7e	bc					.byte $bc                              ; $86 <
>ac7f	3c bd					.byte $3c,$bd                          ; $87 <=
>ac81	be					.byte $be                              ; $88 >
>ac82	3e bd					.byte $3e,$bd                          ; $89 >=
>ac84	ab					.byte $ab                              ; $8a +
>ac85	ad					.byte $ad                              ; $8b -
>ac86	aa					.byte $aa                              ; $8c *
>ac87	af					.byte $af                              ; $8d /
>ac88	de					.byte $de                              ; $8e ^
>ac89	49 c6					.byte $49,$c6                          ; $8f if
>ac8b	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>ac90	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>ac96	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>ac99	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>ac9d	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>aca2	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>aca6	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>acab	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>acaf	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>acb2	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>acb5	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>acb9	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>acbd	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>acc1	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>acc6	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>acca	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>acce	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>acd4	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>acdb	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>ace0	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>ace4	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>ace9	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>aced	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>acf1	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>acf6	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>acfa	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>acfe	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>ad02	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>ad06	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>ad0a	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>ad0e	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>ad12	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>ad16	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>ad1b	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>ad20	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>ad24	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>ad28	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>ad2d	24 a8					.byte $24,$a8                          ; $b5 $(
>ad2f	a4					.byte $a4                              ; $b6 $
>ad30	23 a8					.byte $23,$a8                          ; $b7 #(
>ad32	a3					.byte $a3                              ; $b8 #
>ad33	25 a8					.byte $25,$a8                          ; $b9 %(
>ad35	a5					.byte $a5                              ; $ba %
>ad36	a8					.byte $a8                              ; $bb (
>ad37	a9					.byte $a9                              ; $bc )
>ad38	ac					.byte $ac                              ; $bd ,
>ad39	ba					.byte $ba                              ; $be :
>ad3a	bb					.byte $bb                              ; $bf ;
>ad3b	44 45 c6				.byte $44,$45,$c6                      ; $c0 def
>ad3e	43 4c d2				.byte $43,$4c,$d2                      ; $c1 clr
>ad41	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $c2 stop
>ad45	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c3 data
>ad49	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c4 read
>ad4d	44 49 cd				.byte $44,$49,$cd                      ; $c5 dim
>ad50	54 cf					.byte $54,$cf                          ; $c6 to
>ad52	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c7 step
>ad56	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $c8 gosub
>ad5b	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $c9 return
>ad61	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $ca goto
>ad65	45 4e c4				.byte $45,$4e,$c4                      ; $cb end
>ad68	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $cc input
>ad6d	4c 45 d4				.byte $4c,$45,$d4                      ; $cd let
>ad70	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $ce list
>ad74	4e 45 d7				.byte $4e,$45,$d7                      ; $cf new
>ad77	4f 4c c4				.byte $4f,$4c,$c4                      ; $d0 old
>ad7a	4f ce					.byte $4f,$ce                          ; $d1 on
>ad7c	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d2 restore
>ad83	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d3 poke
>ad87	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d4 print
>ad8c	52 55 ce				.byte $52,$55,$ce                      ; $d5 run
>ad8f	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d6 wait
>ad93	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $d7 doke
>ad97	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $d8 loke
>ad9b	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $d9 assert
>ada1	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_dollarlparen = $b5
=$b6					token_dollar = $b6
=$b7					token_hashlparen = $b7
=$b8					token_hash = $b8
=$b9					token_percentlparen = $b9
=$ba					token_percent = $ba
=$bb					token_lparen = $bb
=$bc					token_rparen = $bc
=$bd					token_comma = $bd
=$be					token_colon = $be
=$bf					token_semicolon = $bf
=$c0					token_def = $c0
=$c1					token_clr = $c1
=$c2					token_stop = $c2
=$c3					token_data = $c3
=$c4					token_read = $c4
=$c5					token_dim = $c5
=$c6					token_to = $c6
=$c7					token_step = $c7
=$c8					token_gosub = $c8
=$c9					token_return = $c9
=$ca					token_goto = $ca
=$cb					token_end = $cb
=$cc					token_input = $cc
=$cd					token_let = $cd
=$ce					token_list = $ce
=$cf					token_new = $cf
=$d0					token_old = $d0
=$d1					token_on = $d1
=$d2					token_restore = $d2
=$d3					token_poke = $d3
=$d4					token_print = $d4
=$d5					token_run = $d5
=$d6					token_wait = $d6
=$d7					token_doke = $d7
=$d8					token_loke = $d8
=$d9					token_assert = $d9

;******  Return to file: modules/basic/core.asm

.ada2					BASIC_Start:
.ada2	20 40 a2	jsr $a240			jsr 	IF_Reset 					; set up and clear screen.
.ada5	20 0c a0	jsr $a00c			jsr 	IFT_ClearScreen
.ada8	a9 4c		lda #$4c			lda 	#$4C 						; JMP opcode
.adaa	8d 04 03	sta $0304			sta 	LocalVector
.adad	8d 00 03	sta $0300			sta 	UserVector
.adb0	a9 37		lda #$37			lda 	#USRDefault & $FF 			; reset USR vector
.adb2	8d 01 03	sta $0301			sta 	UserVector+1
.adb5	a9 b4		lda #$b4			lda 	#(USRDefault >> 8) & $FF
.adb7	8d 02 03	sta $0302			sta 	UserVector+2
.adba	a9 00		lda #$00			lda 	#(USRDefault >> 16) & $FF
.adbc	8d 03 03	sta $0303			sta 	UserVector+3
.adbf	20 ce ae	jsr $aece			jsr 	ResetRunStatus 				; clear everything (CLR command)
.adc2					WarmStart:
.adc2	a2 ff		ldx #$ff			ldx 		#$FF 					; empty stack
.adc4	9a		txs				txs
.adc5	4c c8 ad	jmp $adc8			jmp 	COMMAND_Run

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/run.asm

.adc8					Command_RUN:
.adc8	20 ce ae	jsr $aece			jsr 	ResetRunStatus 				; clear, reset stacks etc.
.adcb	a9 00		lda #$00			lda 	#BasicProgram & $FF
.adcd	85 16		sta $16				sta 	zCodePtr+0
.adcf	a9 80		lda #$80			lda 	#BasicProgram >> 8
.add1	85 17		sta $17				sta 	zCodePtr+1
.add3	a9 00		lda #$00			lda 	#0
.add5	85 18		sta $18				sta 	zCodePtr+2
.add7	85 19		sta $19				sta 	zCodePtr+3
.add9	a0 03		ldy #$03			ldy 	#3
.addb					RUN_NewLine:
.addb	a0 00		ldy #$00			ldy 	#0
.addd	b1 16		lda ($16),y			lda 	(zCodePtr),y
.addf	c8		iny				iny
.ade0	c8		iny				iny
.ade1	c8		iny				iny
.ade2	c9 00		cmp #$00			cmp 	#0 							; if the offset is zero then END.
.ade4	d0 16		bne $adfc			bne 	RUN_NextCommand
.ade6	4c d9 ae	jmp $aed9			jmp 	Command_STOP 				; go do the command code.
.ade9					RUN_Skip:
.ade9	b1 16		lda ($16),y			lda 	(zCodePtr),y 				; read element
.adeb	c8		iny				iny 								; skip
.adec	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.adee	90 0c		bcc $adfc			bcc 	_SEDone 					; so just skip over it.
.adf0	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.adf2	90 07		bcc $adfb			bcc 	_SEDouble
.adf4	98		tya				tya 								; this is Y + 1
.adf5	18		clc				clc
.adf6	71 16		adc ($16),y			adc 	(zCodePtr),y 				; add total length of element
.adf8	a8		tay				tay 								; back in Y.
.adf9	88		dey				dey 								; fix up, one for the +1, one for the iny
.adfa	88		dey				dey
.adfb					_SEDouble:
.adfb	c8		iny				iny
.adfc					_SEDone:
.adfc					RUN_NextCommand:
.adfc	a9 00		lda #$00			lda 	#0 							; this resets temporary string allocation.
.adfe	85 21		sta $21				sta 	zTempStr+1 					; (initialised when first called)
.ae00	b1 16		lda ($16),y			lda 	(zCodePtr),y
.ae02	c9 be		cmp #$be			cmp 	#token_Colon 				; skip over colons
.ae04	f0 e3		beq $ade9			beq 	RUN_Skip
.ae06	c9 00		cmp #$00			cmp 	#0 							; if non-zero execute whatever
.ae08	d0 0f		bne $ae19			bne 	RUN_Execute
.ae0a					RUN_NextLine:
.ae0a	a0 00		ldy #$00			ldy 	#0 							; point to offset
.ae0c	b1 16		lda ($16),y			lda 	(zCodePtr),y 				; read it
.ae0e	18		clc				clc
.ae0f	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.ae11	85 16		sta $16				sta 	zCodePtr
.ae13	90 02		bcc $ae17			bcc 	_SNLNoCarry
.ae15	e6 17		inc $17				inc 	zCodePtr+1
.ae17					_SNLNoCarry:
.ae17	80 c2		bra $addb			bra 	RUN_NewLine 				; go do the new line code
.ae19					RUN_Execute:
.ae19	c9 f8		cmp #$f8			cmp 	#$F8 						; handle shifts, REM etc.
.ae1b	b0 18		bcs $ae35			bcs 	RUN_Extension
.ae1d	c8		iny				iny
.ae1e	0a		asl a				asl 	a 							; double the character read.
.ae1f	90 12		bcc $ae33			bcc 	RUN_Default 				; if carry clear was $00-$7F, so try LET.
.ae21	aa		tax				tax 								; ready to look up.
.ae22	bd 9a ab	lda $ab9a,x			lda 	VectorTable,x 				; copy address into LocalVector
.ae25	8d 05 03	sta $0305			sta 	LocalVector+1
.ae28	bd 9b ab	lda $ab9b,x			lda 	VectorTable+1,x
.ae2b	8d 06 03	sta $0306			sta 	LocalVector+2
.ae2e	20 e9 af	jsr $afe9			jsr 	EVCallLocalVector 			; execute the appropriate code.
.ae31	80 c9		bra $adfc			bra 	RUN_NextCommand 			; do the next command.
.ae33					RUN_Default:
.ae33	80 fe		bra $ae33			bra 	RUN_Default
.ae35					RUN_Extension:
.ae35	c9 ff		cmp #$ff			cmp 	#$FF 						; if $FF (REM)
.ae37	f0 b0		beq $ade9			beq 	RUN_Skip 					; skip over it.
.ae39	4c 08 ab	jmp $ab08			jmp 	SyntaxError
.ae3c					Command_COLON:
.ae3c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/end.asm

.ae3d					Command_END:
.ae3d	80 fe		bra $ae3d	_halt:	bra 		_halt
.ae3f	4c c2 ad	jmp $adc2			jmp 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/print.asm

.ae42					Command_PRINT:
.ae42	b1 16		lda ($16),y			lda 	(zCodePtr),y
.ae44	c9 00		cmp #$00			cmp 	#0 							; end
.ae46	f0 66		beq $aeae			beq 	_CPR_NewLine
.ae48	c9 be		cmp #$be			cmp 	#token_Colon
.ae4a	f0 62		beq $aeae			beq 	_CPR_NewLine
.ae4c	c9 bf		cmp #$bf			cmp 	#token_SemiColon
.ae4e	f0 51		beq $aea1			beq 	_CPR_Skip
.ae50	c9 bd		cmp #$bd			cmp 	#token_Comma
.ae52	f0 4d		beq $aea1			beq 	_CPR_Tab
.ae54	20 e4 ae	jsr $aee4			jsr 	EvaluateExpression 			; get expression.
.ae57	ad 0d 03	lda $030d			lda 	XS_Type 					; get type.
.ae5a	29 02		and #$02			and 	#2
.ae5c	d0 25		bne $ae83			bne 	_CPR_String 				; if type = 2 output as string.
.ae5e					_CPR_Number:
.ae5e	a9 00		lda #$00			lda 	#0 							; reset buffer index
.ae60	8d 00 04	sta $0400			sta 	NumBufX
.ae63	ad 0d 03	lda $030d			lda 	XS_Type 					; get type
.ae66	4a		lsr a				lsr 	a
.ae67	b0 05		bcs $ae6e			bcs 	_CPRInt 					; if msb set do as integer
.ae69	20 a2 be	jsr $bea2			jsr 	FPToString 					; call fp to str otherwise
.ae6c	80 03		bra $ae71			bra 	_CPRNPrint
.ae6e	20 92 b8	jsr $b892	_CPRInt:jsr 	IntToString
.ae71					_CPRNPrint:
.ae71	ad 01 04	lda $0401			lda 	Num_Buffer 					; is first character -
.ae74	c9 2d		cmp #$2d			cmp 	#"-"
.ae76	f0 05		beq $ae7d			beq 	_CPRNoSpace
.ae78	a9 20		lda #$20			lda 	#" "						; print the leading space
.ae7a	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter 			; so beloved of MS Basics.
.ae7d					_CPRNoSpace:
.ae7d	a2 00		ldx #$00			ldx 	#(Num_Buffer-1) & $FF
.ae7f	a9 04		lda #$04			lda 	#(Num_Buffer-1) >> 8
.ae81	80 06		bra $ae89			bra 	_CPRPrint
.ae83					_CPR_String:
.ae83	ae 08 03	ldx $0308			ldx 	XS_Mantissa
.ae86	ad 09 03	lda $0309			lda 	XS_Mantissa+1
.ae89					_CPRPrint:
.ae89	86 1e		stx $1e				stx 	zGenPtr
.ae8b	85 1f		sta $1f				sta 	zGenPtr+1
.ae8d	5a		phy				phy
.ae8e	a0 00		ldy #$00			ldy 	#0							; get length into X
.ae90	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.ae92	aa		tax				tax
.ae93	f0 09		beq $ae9e			beq 	_CPREndPrint 				; nothing to print
.ae95					_CPRLoop:
.ae95	c8		iny				iny
.ae96	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.ae98	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.ae9b	ca		dex				dex
.ae9c	d0 f7		bne $ae95			bne 	_CPRLoop
.ae9e					_CPREndPrint:
.ae9e	7a		ply				ply
.ae9f	80 a1		bra $ae42			bra 	Command_Print
.aea1					_CPR_Tab:
.aea1					_CPR_Skip:
.aea1	c8		iny				iny
.aea2	b1 16		lda ($16),y			lda 	(zCodePtr),y
.aea4	c9 be		cmp #$be			cmp 	#token_Colon 				; colon or $00, exit
.aea6	f0 09		beq $aeb1			beq 	_CPR_Exit
.aea8	c9 00		cmp #$00			cmp 	#0
.aeaa	d0 96		bne $ae42			bne 	Command_PRINT 				; if not go round again.
.aeac	80 03		bra $aeb1			bra 	_CPR_Exit
.aeae					_CPR_NewLine:
.aeae	20 5b a0	jsr $a05b			jsr 	IFT_NewLine
.aeb1					_CPR_Exit:
.aeb1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/assert.asm

.aeb2					Command_ASSERT:
.aeb2	20 7f b0	jsr $b07f			jsr 	EvaluateNumber 				; calculate thing being asserted
.aeb5	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; check if true (non-zero)
.aeb8	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.aebb	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.aebe	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.aec1	f0 01		beq $aec4			beq 	_ASFail
.aec3	60		rts				rts
.aec4					_ASFail:
.aec4	20 37 ab	jsr $ab37			jsr ERR_Handler
>aec7	41 73 73 65 72 74 00			.text "Assert",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.aece					Command_CLR:
.aece					ResetRunStatus:
.aece	a9 00		lda #$00			lda 	#HighMemory & $FF
.aed0	8d 26 04	sta $0426			sta 	StringPtr
.aed3	a9 70		lda #$70			lda 	#HighMemory >> 8
.aed5	8d 27 04	sta $0427			sta 	StringPtr+1
.aed8	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/stop.asm

.aed9					Command_STOP:
.aed9	20 37 ab	jsr $ab37			jsr ERR_Handler
>aedc	53 74 6f 70 00				.text "Stop",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.aee1					EVESyntax:
.aee1	4c 08 ab	jmp $ab08			jmp 	SyntaxError
.aee4					EvaluateExpression:
.aee4	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.aee6					EvaluateExpressionX:
.aee6	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.aee8					EvaluateExpressionXA:
.aee8	48		pha				pha 								; save precedence on stack.
.aee9	b1 16		lda ($16),y			lda 	(zCodePtr),y
.aeeb	f0 f4		beq $aee1			beq 	EVESyntax 					; end of line, syntax error.
.aeed	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.aeef	b0 03		bcs $aef4			bcs 	_EVNotVariable
.aef1	4c e8 af	jmp $afe8			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.aef4					_EVNotVariable:
.aef4	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.aef6	90 e9		bcc $aee1			bcc 	EVESyntax
.aef8	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.aefa	b0 7c		bcs $af78			bcs 	_EVNotInteger
.aefc	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.aefe	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.af01	a9 00		lda #$00			lda 	#0
.af03	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.af06	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.af09	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.af0c	1a		inc a				inc 	a 							; set to type 1 (integer)
.af0d	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.af10					_EVCheckNextInteger:
.af10	c8		iny				iny
.af11	b1 16		lda ($16),y			lda 	(zCodePtr),y
.af13	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.af15	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.af17	b0 0d		bcs $af26			bcs 	_EVCheckDecimal
.af19	48		pha				pha 								; save it.
.af1a	20 ec af	jsr $afec			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.af1d	68		pla				pla
.af1e	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.af21	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.af24	80 ea		bra $af10			bra 	_EVCheckNextInteger
.af26					_EVCheckDecimal:
.af26	b1 16		lda ($16),y			lda 	(zCodePtr),y
.af28	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.af2a	d0 05		bne $af31			bne 	_EVGotAtom 					; no, get atom.
.af2c					_EVIsDecimal:
.af2c	20 1c b0	jsr $b01c			jsr 	EVGetDecimal 				; extend to the decimal part.
.af2f	80 00		bra $af31			bra 	_EVGotAtom 					; and continue to got atom.
.af31					_EVGotAtom:
.af31	b1 16		lda ($16),y			lda 	(zCodePtr),y
.af33	10 41		bpl $af76			bpl 	_EVExitDrop 				; must be a token.
.af35	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.af37	b0 3d		bcs $af76			bcs 	_EVExitDrop
.af39	68		pla				pla 								; get current precedence
.af3a	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.af3c	da		phx				phx 								; save X
.af3d	b1 16		lda ($16),y			lda 	(zCodePtr),y
.af3f	aa		tax				tax 								; put in X
.af40	bd e1 ab	lda $abe1,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.af43	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.af45	fa		plx				plx 								; restore X
.af46	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.af48	90 2d		bcc $af77			bcc 	_EVExit 					; exit if too low.
.af4a	f0 2b		beq $af77			beq 	_EVExit 					; exit if equals
.af4c	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.af4e	48		pha				pha
.af4f	b1 16		lda ($16),y			lda 	(zCodePtr),y
.af51	48		pha				pha
.af52	c8		iny				iny
.af53	da		phx				phx 								; save current position
.af54	e8		inx				inx
.af55	e8		inx				inx
.af56	e8		inx				inx
.af57	e8		inx				inx
.af58	e8		inx				inx
.af59	e8		inx				inx
.af5a	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.af5c	20 e8 ae	jsr $aee8			jsr 	EvaluateExpressionXA 		; do the RHS.
.af5f	fa		plx				plx 								; restore X
.af60	68		pla				pla 								; get the binary operator in A.
.af61					_EVCallA:
.af61	da		phx				phx 								; save X again
.af62	0a		asl a				asl 	a 							; double, lose the MSB.
.af63	aa		tax				tax									; put in X
.af64	bd 9a ab	lda $ab9a,x			lda 	VectorTable,x 				; copy address into zGenPtr
.af67	8d 05 03	sta $0305			sta 	LocalVector+1
.af6a	bd 9b ab	lda $ab9b,x			lda 	VectorTable+1,x
.af6d	8d 06 03	sta $0306			sta 	LocalVector+2
.af70	fa		plx				plx 								; restore X
.af71	20 e9 af	jsr $afe9			jsr 	EVCallLocalVector
.af74	80 bb		bra $af31			bra 	_EVGotAtom 					; and loop back.
.af76					_EVExitDrop:
.af76	68		pla				pla
.af77					_EVExit:
.af77	60		rts				rts
.af78					_EVNotInteger:
.af78	c8		iny				iny
.af79	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.af7b	d0 19		bne $af96			bne 	_EVNotMinus
.af7d	20 6d b0	jsr $b06d			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.af80	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.af83	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.af85	f0 05		beq $af8c			beq 	_EVMinusFloat
.af87	20 6d b8	jsr $b86d			jsr 	IntegerNegateAlways 		; negation
.af8a	80 a5		bra $af31			bra 	_EVGotAtom 					; and go back.
.af8c					_EVMinusFloat:
.af8c	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; invert the sign bit.
.af8f	49 80		eor #$80			eor 	#$80
.af91	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.af94	80 9b		bra $af31			bra 	_EVGotAtom
.af96					_EVNotMinus:
.af96	c9 bb		cmp #$bb			cmp 	#token_lparen 				; is it left parenthesis
.af98	d0 17		bne $afb1			bne 	_EVNotParenthesis
.af9a	20 e6 ae	jsr $aee6			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.af9d	b1 16		lda ($16),y			lda 	(zCodePtr),y
.af9f	c8		iny				iny
.afa0	c9 bc		cmp #$bc			cmp 	#token_rparen 				; okay if right bracket.
.afa2	f0 8d		beq $af31			beq 	_EVGotAtom
.afa4	20 37 ab	jsr $ab37			jsr ERR_Handler
>afa7	4d 69 73 73 69 6e 67 20			.text "Missing )",0
>afaf	29 00
.afb1					_EVNotParenthesis:
.afb1	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.afb3	d0 0c		bne $afc1			bne 	_EVNotNot
.afb5	20 6d b0	jsr $b06d			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.afb8	20 77 bd	jsr $bd77			jsr 	FPUToInteger 				; make it an integer - if possible.
.afbb	20 4a b0	jsr $b04a			jsr 	NotInteger 					; do the not calculation
.afbe	4c 31 af	jmp $af31			jmp 	_EVGotAtom
.afc1					_EVNotNot:
.afc1	c9 fe		cmp #$fe			cmp 	#$FE
.afc3	d0 15		bne $afda			bne 	_EVNotString
.afc5	20 5a b7	jsr $b75a			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.afc8	a5 20		lda $20				lda 	zTempStr 					; copy address of string into mantissa
.afca	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.afcd	a5 21		lda $21				lda 	zTempStr+1
.afcf	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.afd2	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.afd4	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.afd7	4c 31 af	jmp $af31			jmp 	_EVGotAtom
.afda					_EVNotString:
.afda	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.afdc	90 04		bcc $afe2			bcc 	_EVBadElement
.afde	c9 b5		cmp #$b5			cmp 	#lastUnaryFunction+1
.afe0	90 03		bcc $afe5			bcc 	_EVUnaryFunction
.afe2					_EVBadElement:
.afe2	4c 08 ab	jmp $ab08			jmp 	SyntaxError
.afe5					_EVUnaryFunction:
.afe5	4c 61 af	jmp $af61			jmp 	_EVCallA
.afe8					_EVVariableHandler:
.afe8	ea		nop				nop
.afe9					EVCallLocalVector:
.afe9	6c 05 03	jmp ($0305)			jmp 	(LocalVector+1)
.afec					EVShiftMantissaLeft6:
.afec	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.afef	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.aff2	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.aff5	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.aff8	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.affb	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.affe	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b001	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b004	a9 00		lda #$00			lda 	#0
.b006	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b009	20 0c b0	jsr $b00c			jsr 	_EVSMLShift 					; call it here to do it twice
.b00c					_EVSMLShift:
.b00c	5e 0c 03	lsr $030c,x			lsr 	XS_Exponent,x
.b00f	7e 0b 03	ror $030b,x			ror 	XS_Mantissa+3,x
.b012	7e 0a 03	ror $030a,x			ror 	XS_Mantissa+2,x
.b015	7e 09 03	ror $0309,x			ror 	XS_Mantissa+1,x
.b018	7e 08 03	ror $0308,x			ror 	XS_Mantissa+0,x
.b01b	60		rts				rts
.b01c					EVGetDecimal:
.b01c	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.b01e	8d 01 04	sta $0401			sta 	Num_Buffer
.b021	da		phx				phx
.b022	c8		iny				iny
.b023	b1 16		lda ($16),y			lda 	(zCodePtr),y
.b025	c8		iny				iny
.b026	3a		dec a				dec 	a								; convert to a string length.
.b027	3a		dec a				dec 	a
.b028	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.b02a					_EVGDCopy:
.b02a	48		pha				pha 									; save count
.b02b	b1 16		lda ($16),y			lda 	(zCodePtr),y
.b02d	9d 01 04	sta $0401,x			sta 	Num_Buffer,x
.b030	e8		inx				inx 									; forward ....
.b031	c8		iny				iny
.b032	68		pla				pla 									; get count
.b033	3a		dec a				dec 	a 								; until zero
.b034	d0 f4		bne $b02a			bne 	_EVGDCopy
.b036	9d 01 04	sta $0401,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.b039	fa		plx				plx 									; restore X
.b03a	a9 01		lda #$01			lda 	#Num_Buffer & $FF 				; set zGenPtr
.b03c	85 1e		sta $1e				sta 	zGenPtr
.b03e	a9 04		lda #$04			lda 	#Num_Buffer >> 8
.b040	85 1f		sta $1f				sta 	zGenPtr+1
.b042	5a		phy				phy 									; save Y
.b043	a0 00		ldy #$00			ldy 	#0 								; start position
.b045	20 69 bf	jsr $bf69			jsr 	FPFromString 					; convert current
.b048	7a		ply				ply 									; restore Y
.b049	60		rts				rts
.b04a					NotInteger:
.b04a	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b04d	49 ff		eor #$ff			eor 	#$FF
.b04f	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b052	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b055	49 ff		eor #$ff			eor 	#$FF
.b057	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b05a	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.b05d	49 ff		eor #$ff			eor 	#$FF
.b05f	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b062	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.b065	49 ff		eor #$ff			eor 	#$FF
.b067	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b06a	60		rts				rts
.b06b					EvaluateGetAtom:
.b06b	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.b06d					EvaluateGetAtomX:
.b06d	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.b06f	20 e8 ae	jsr $aee8			jsr 	EvaluateExpressionXA
.b072	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.b075	29 0f		and #$0f			and 	#15
.b077	c9 02		cmp #$02			cmp 	#2
.b079	b0 01		bcs $b07c			bcs 	EvaluateType
.b07b	60		rts				rts
.b07c					EvaluateType:
.b07c	4c 18 ab	jmp $ab18			jmp 	TypeError
.b07f					EvaluateNumber:
.b07f	a2 00		ldx #$00			ldx 	#0
.b081					EvaluateNumberX:
.b081	20 e6 ae	jsr $aee6			jsr 	EvaluateExpressionX
.b084	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 0/1
.b087	29 0f		and #$0f			and 	#15
.b089	c9 02		cmp #$02			cmp 	#2
.b08b	b0 ef		bcs $b07c			bcs 	EvaluateType
.b08d	60		rts				rts
.b08e					EvaluateInteger:
.b08e	a2 00		ldx #$00			ldx 	#0
.b090					EvaluateIntegerX:
.b090	20 81 b0	jsr $b081			jsr 	EvaluateNumberX
.b093	20 77 bd	jsr $bd77			jsr 	FPUToInteger
.b096	60		rts				rts
.b097					EvaluateString:
.b097	a2 00		ldx #$00			ldx 	#0
.b099					EvaluateStringX:
.b099	20 e6 ae	jsr $aee6			jsr 	EvaluateExpressionX
.b09c	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 2
.b09f	29 0f		and #$0f			and 	#15
.b0a1	c9 02		cmp #$02			cmp 	#2
.b0a3	d0 d7		bne $b07c			bne 	EvaluateType
.b0a5	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.b0a8	85 1e		sta $1e				sta 	zGenPtr
.b0aa	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b0ad	85 1f		sta $1f				sta 	zGenPtr+1
.b0af	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.b0b0					BinaryOp_And:
.b0b0	20 28 b1	jsr $b128			jsr 	BinaryMakeBothInteger
.b0b3	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.b0b6	3d 0e 03	and $030e,x			and 	XS2_Mantissa+0,x
.b0b9	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b0bc	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.b0bf	3d 0f 03	and $030f,x			and 	XS2_Mantissa+1,x
.b0c2	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b0c5	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.b0c8	3d 10 03	and $0310,x			and 	XS2_Mantissa+2,x
.b0cb	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b0ce	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.b0d1	3d 11 03	and $0311,x			and 	XS2_Mantissa+3,x
.b0d4	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b0d7	60		rts				rts
.b0d8					BinaryOp_Or:
.b0d8	20 28 b1	jsr $b128			jsr 	BinaryMakeBothInteger
.b0db	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.b0de	1d 0e 03	ora $030e,x			ora 	XS2_Mantissa+0,x
.b0e1	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b0e4	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.b0e7	1d 0f 03	ora $030f,x			ora 	XS2_Mantissa+1,x
.b0ea	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b0ed	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.b0f0	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.b0f3	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b0f6	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.b0f9	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.b0fc	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b0ff	60		rts				rts
.b100					BinaryOp_Eor:
.b100					BinaryOp_Xor:
.b100	20 28 b1	jsr $b128			jsr 	BinaryMakeBothInteger
.b103	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.b106	5d 0e 03	eor $030e,x			eor 	XS2_Mantissa+0,x
.b109	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b10c	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.b10f	5d 0f 03	eor $030f,x			eor 	XS2_Mantissa+1,x
.b112	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b115	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.b118	5d 10 03	eor $0310,x			eor 	XS2_Mantissa+2,x
.b11b	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b11e	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.b121	5d 11 03	eor $0311,x			eor 	XS2_Mantissa+3,x
.b124	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b127	60		rts				rts
.b128					BinaryMakeBothInteger:
.b128	da		phx				phx 								; save X
.b129	e8		inx				inx
.b12a	e8		inx				inx
.b12b	e8		inx				inx
.b12c	e8		inx				inx
.b12d	e8		inx				inx
.b12e	e8		inx				inx
.b12f	20 33 b1	jsr $b133			jsr 	BinaryMakeInteger 			; convert to integer.
.b132	fa		plx				plx 								; restore X and fall through.
.b133					BinaryMakeInteger:
.b133	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type byte.
.b136	29 0f		and #$0f			and 	#15 						; check type zero
.b138	f0 04		beq $b13e			beq 	_BMIConvert 				; if float convert to integer.
.b13a	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.b13b	90 04		bcc $b141			bcc 	_BMIError
.b13d	60		rts				rts
.b13e					_BMIConvert:
.b13e	4c 77 bd	jmp $bd77			jmp 	FPUToInteger 				; convert to integer
.b141					_BMIError:
.b141	4c 18 ab	jmp $ab18			jmp 	TypeError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.b144					Binary_Equal:
.b144	20 90 b1	jsr $b190			jsr 	CompareValues
.b147	09 00		ora #$00			ora 	#0
.b149	f0 04		beq $b14f			beq 	CCTrue
.b14b	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.b14d	80 02		bra $b151			bra 	CCWrite
.b14f	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.b151	9d 08 03	sta $0308,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.b154	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b157	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b15a	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b15d	a9 01		lda #$01			lda 	#1
.b15f	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; set type to integer whatever.
.b162	60		rts				rts
.b163					Binary_NotEqual:
.b163	20 90 b1	jsr $b190			jsr 	CompareValues
.b166	09 00		ora #$00			ora 	#0
.b168	f0 e1		beq $b14b			beq 	CCFalse
.b16a	80 e3		bra $b14f			bra 	CCTrue
.b16c					Binary_Less:
.b16c	20 90 b1	jsr $b190			jsr 	CompareValues
.b16f	09 00		ora #$00			ora 	#0
.b171	30 dc		bmi $b14f			bmi 	CCTrue
.b173	80 d6		bra $b14b			bra 	CCFalse
.b175					Binary_LessEqual:
.b175	20 90 b1	jsr $b190			jsr 	CompareValues
.b178	c9 01		cmp #$01			cmp 	#1
.b17a	d0 d3		bne $b14f			bne 	CCTrue
.b17c	80 cd		bra $b14b			bra 	CCFalse
.b17e					Binary_GreaterEqual:
.b17e	20 90 b1	jsr $b190			jsr 	CompareValues
.b181	09 00		ora #$00			ora 	#0
.b183	10 ca		bpl $b14f			bpl 	CCTrue
.b185	80 c4		bra $b14b			bra 	CCFalse
.b187					Binary_Greater:
.b187	20 90 b1	jsr $b190			jsr 	CompareValues
.b18a	c9 01		cmp #$01			cmp 	#1
.b18c	f0 c1		beq $b14f			beq 	CCTrue
.b18e	80 bb		bra $b14b			bra 	CCFalse
.b190					CompareValues:
.b190	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and the types together
.b193	3d 13 03	and $0313,x			and 	XS2_Type,x
.b196	c9 02		cmp #$02			cmp 	#2
.b198	f0 13		beq $b1ad			beq 	_CVString
.b19a	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b19d	3d 13 03	and $0313,x			and 	XS2_Type,x
.b1a0	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b1a1	90 03		bcc $b1a6			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b1a3	4c f3 b1	jmp $b1f3			jmp 	CompareInteger32 							; so execute code at \1
.b1a6					_BCFloat:
.b1a6	20 c1 b2	jsr $b2c1			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b1a9	4c 86 bc	jmp $bc86			jmp 	FPCompare 							; and execute code at \2
.b1ac	60		rts				rts
.b1ad					_CVString:
.b1ad	da		phx				phx 								; save XY
.b1ae	5a		phy				phy
.b1af	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.b1b2	85 1a		sta $1a				sta		zLTemp1+0
.b1b4	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b1b7	85 1b		sta $1b				sta 	zLTemp1+1
.b1b9	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x
.b1bc	85 1c		sta $1c				sta 	zLTemp1+2
.b1be	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.b1c1	85 1d		sta $1d				sta 	zLTemp1+3
.b1c3	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.b1c5	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b1c7	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.b1c9	90 02		bcc $b1cd			bcc 	_CVCommon
.b1cb	b1 1c		lda ($1c),y			lda 	(zLTemp1+2),y
.b1cd					_CVCommon:
.b1cd	aa		tax				tax 								; put shorter string length in zero.
.b1ce	f0 0c		beq $b1dc			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.b1d0					_CVCompare:
.b1d0	c8		iny				iny 								; next character
.b1d1	b1 1a		lda ($1a),y			lda 	(zLTemp1),y 				; compare characters
.b1d3	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.b1d5	90 13		bcc $b1ea			bcc 	_CVReturnLess 				; <
.b1d7	d0 15		bne $b1ee			bne 	_CVReturnGreater 			; >
.b1d9	ca		dex				dex 								; until common length matched.
.b1da	d0 f4		bne $b1d0			bne 	_CVCompare
.b1dc					_CVMatch:
.b1dc	a0 00		ldy #$00			ldy 	#0
.b1de	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b1e0	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.b1e2	90 06		bcc $b1ea			bcc 	_CVReturnLess 				; <
.b1e4	d0 08		bne $b1ee			bne 	_CVReturnGreater 			; >
.b1e6	a9 00		lda #$00			lda 	#0
.b1e8	80 06		bra $b1f0			bra 	_CVExit 					; same common, same length, same string
.b1ea					_CVReturnLess:
.b1ea	a9 ff		lda #$ff			lda 	#$FF
.b1ec	80 02		bra $b1f0			bra 	_CVExit
.b1ee					_CVReturnGreater:
.b1ee	a9 01		lda #$01			lda 	#$01
.b1f0					_CVExit:
.b1f0	7a		ply				ply
.b1f1	fa		plx				plx
.b1f2	60		rts				rts
.b1f3					CompareInteger32:
.b1f3	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.b1f6	49 80		eor #$80			eor 	#$80
.b1f8	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b1fb	bd 11 03	lda $0311,x			lda 	XS2_Mantissa+3,x
.b1fe	49 80		eor #$80			eor 	#$80
.b200	9d 11 03	sta $0311,x			sta 	XS2_Mantissa+3,x
.b203	20 9b b2	jsr $b29b			jsr 	SubInteger32 				; subtraction
.b206	90 11		bcc $b219			bcc 	_CI32Less 					; cc return -1
.b208	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; check if zero
.b20b	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.b20e	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.b211	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.b214	f0 02		beq $b218			beq 	_CI32Exit
.b216	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.b218					_CI32Exit:
.b218	60		rts				rts
.b219					_CI32Less:
.b219	a9 ff		lda #$ff			lda 	#$FF
.b21b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.b21c					BinaryOp_Add:
.b21c	bd 0d 03	lda $030d,x			lda 	XS_Type,x  					; and types together
.b21f	3d 13 03	and $0313,x			and 	XS2_Type,x
.b222	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.b224	d0 13		bne $b239			bne 	_BOAString
.b226	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b229	3d 13 03	and $0313,x			and 	XS2_Type,x
.b22c	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b22d	90 03		bcc $b232			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b22f	4c 75 b2	jmp $b275			jmp 	AddInteger32 							; so execute code at \1
.b232					_BCFloat:
.b232	20 c1 b2	jsr $b2c1			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b235	4c fa b9	jmp $b9fa			jmp 	FPAdd 							; and execute code at \2
.b238	60		rts				rts
.b239					_BOAString:
.b239	4c dc b2	jmp $b2dc			jmp 	ConcatenateString 			; concatenate two strings.
.b23c					BinaryOp_Subtract:
.b23c	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b23f	3d 13 03	and $0313,x			and 	XS2_Type,x
.b242	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b243	90 03		bcc $b248			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b245	4c 9b b2	jmp $b29b			jmp 	SubInteger32 							; so execute code at \1
.b248					_BCFloat:
.b248	20 c1 b2	jsr $b2c1			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b24b	4c f0 b9	jmp $b9f0			jmp 	FPSubtract 							; and execute code at \2
.b24e	60		rts				rts
.b24f					BinaryOp_Multiply:
.b24f	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b252	3d 13 03	and $0313,x			and 	XS2_Type,x
.b255	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b256	90 03		bcc $b25b			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b258	4c 80 b7	jmp $b780			jmp 	MulInteger32 							; so execute code at \1
.b25b					_BCFloat:
.b25b	20 c1 b2	jsr $b2c1			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b25e	4c 66 bb	jmp $bb66			jmp 	FPMultiply 							; and execute code at \2
.b261	60		rts				rts
.b262					BinaryOp_Divide:
.b262	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b265	3d 13 03	and $0313,x			and 	XS2_Type,x
.b268	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b269	90 03		bcc $b26e			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b26b	4c d7 b7	jmp $b7d7			jmp 	DivInteger32 							; so execute code at \1
.b26e					_BCFloat:
.b26e	20 c1 b2	jsr $b2c1			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b271	4c de ba	jmp $bade			jmp 	FPDivide 							; and execute code at \2
.b274	60		rts				rts
.b275					AddInteger32:
.b275	18		clc				clc
.b276	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b279	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.b27c	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b27f	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b282	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.b285	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b288	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.b28b	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.b28e	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b291	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.b294	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.b297	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b29a	60		rts				rts
.b29b					SubInteger32:
.b29b	38		sec				sec
.b29c	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b29f	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.b2a2	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b2a5	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b2a8	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.b2ab	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b2ae	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.b2b1	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.b2b4	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b2b7	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.b2ba	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.b2bd	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b2c0	60		rts				rts
.b2c1					BinaryMakeBothFloat:
.b2c1	da		phx				phx 								; save X
.b2c2	e8		inx				inx
.b2c3	e8		inx				inx
.b2c4	e8		inx				inx
.b2c5	e8		inx				inx
.b2c6	e8		inx				inx
.b2c7	e8		inx				inx
.b2c8	20 cc b2	jsr $b2cc			jsr 	BinaryMakeFloat 			; convert to float.
.b2cb	fa		plx				plx 								; restore X and fall through.
.b2cc					BinaryMakeFloat:
.b2cc	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type byte.
.b2cf	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.b2d0	b0 04		bcs $b2d6			bcs 	_BMFConvert
.b2d2	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.b2d3	b0 04		bcs $b2d9			bcs 	_BMFError
.b2d5	60		rts				rts
.b2d6					_BMFConvert:
.b2d6	4c 18 bd	jmp $bd18			jmp 	FPUToFloat 					; convert to float
.b2d9					_BMFError:
.b2d9	4c 18 ab	jmp $ab18			jmp 	TypeError
.b2dc					ConcatenateString:
.b2dc	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.b2df	85 1a		sta $1a				sta		zLTemp1+0
.b2e1	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b2e4	85 1b		sta $1b				sta 	zLTemp1+1
.b2e6	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x
.b2e9	85 1c		sta $1c				sta 	zLTemp1+2
.b2eb	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.b2ee	85 1d		sta $1d				sta 	zLTemp1+3
.b2f0	5a		phy				phy
.b2f1	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.b2f3	b1 1a		lda ($1a),y			lda 	(zlTemp1),y
.b2f5	71 1c		adc ($1c),y			adc 	(zlTemp1+2),y
.b2f7	7a		ply				ply
.b2f8	b0 37		bcs $b331			bcs 	_CSError					; check in range.
.b2fa	c9 fe		cmp #$fe			cmp 	#maxString+1
.b2fc	b0 33		bcs $b331			bcs 	_CSError
.b2fe	20 1f b7	jsr $b71f			jsr 	AllocateTempString 			; store the result
.b301	20 1c b3	jsr $b31c			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.b304	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.b307	85 1a		sta $1a				sta 	zLTemp1
.b309	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.b30c	85 1b		sta $1b				sta 	zLTemp1+1
.b30e	20 1c b3	jsr $b31c			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.b311	a5 20		lda $20				lda 	zTempStr 					; point current to new string
.b313	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b316	a5 21		lda $21				lda 	zTempStr+1
.b318	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b31b	60		rts				rts
.b31c					_CSCopyString:
.b31c	da		phx				phx
.b31d	5a		phy				phy
.b31e	a0 00		ldy #$00			ldy 	#0 							; get length
.b320	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b322	f0 0a		beq $b32e			beq 	_CSCSExit 					; if zero, exit
.b324	aa		tax				tax 								; put in X
.b325					_CSCSLoop:
.b325	c8		iny				iny 								; get next char
.b326	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b328	20 4a b7	jsr $b74a			jsr		WriteTempString 			; copy out
.b32b	ca		dex				dex 								; do whole string
.b32c	d0 f7		bne $b325			bne 	_CSCSLoop
.b32e					_CSCSExit:
.b32e	7a		ply				ply
.b32f	fa		plx				plx
.b330	60		rts				rts
.b331					_CSError:
.b331	20 37 ab	jsr $ab37			jsr ERR_Handler
>b334	53 74 72 69 6e 67 20 74			.text "String too long",0
>b33c	6f 6f 20 6c 6f 6e 67 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.b344					Unary_Sgn:
.b344	20 81 b0	jsr $b081			jsr 	EvaluateNumberX 			; get value
.b347	20 0f b7	jsr $b70f			jsr 	CheckNextRParen 			; check right bracket.
.b34a	20 6e b3	jsr $b36e			jsr 	GetSignCurrent 				; get sign.
.b34d	09 00		ora #$00			ora 	#0
.b34f	10 09		bpl $b35a			bpl		UnarySetAInteger			; if 0,1 return that.
.b351	80 00		bra $b353			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.b353					UnarySetAMinus1:
.b353	a9 ff		lda #$ff			lda 	#$FF
.b355	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.b358	80 05		bra $b35f			bra 	UnarySetAFill
.b35a					UnarySetAInteger:
.b35a	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.b35d	a9 00		lda #$00			lda 	#0
.b35f					UnarySetAFill:
.b35f	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b362	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b365	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b368	a9 01		lda #$01			lda 	#1
.b36a	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.b36d	60		rts				rts
.b36e					GetSignCurrent:
.b36e	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; identify type.
.b371	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.b372	90 19		bcc $b38d			bcc 	_GSCFloat
.b374	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.b377	30 11		bmi $b38a			bmi 	_GSCMinus1
.b379	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x
.b37c	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.b37f	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.b382	d0 03		bne $b387			bne 	_GSCPlus1
.b384					_GSCZero:
.b384	a9 00		lda #$00			lda 	#0
.b386	60		rts				rts
.b387					_GSCPlus1:
.b387	a9 01		lda #$01			lda 	#$01
.b389	60		rts				rts
.b38a					_GSCMinus1:
.b38a	a9 ff		lda #$ff			lda 	#$FF
.b38c	60		rts				rts
.b38d					_GSCFloat:
.b38d	3c 0d 03	bit $030d,x			bit 	XS_Type,x
.b390	70 f2		bvs $b384			bvs 	_GSCZero
.b392	30 f6		bmi $b38a			bmi 	_GSCMinus1
.b394	80 f1		bra $b387			bra 	_GSCPlus1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.b396					Unary_Abs:
.b396	20 81 b0	jsr $b081			jsr 	EvaluateNumberX 			; get value
.b399	20 0f b7	jsr $b70f			jsr 	CheckNextRParen 			; check right bracket.
.b39c	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.b39f	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.b3a1	f0 08		beq $b3ab			beq 	_UAMinusFloat
.b3a3	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; check MSB
.b3a6	10 0b		bpl $b3b3			bpl 	_UAExit
.b3a8	4c 6d b8	jmp $b86d			jmp 	IntegerNegateAlways 		; negation
.b3ab					_UAMinusFloat:
.b3ab	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; clear the sign bit.
.b3ae	29 7f		and #$7f			and		#$7F
.b3b0	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.b3b3					_UAExit:
.b3b3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.b3b4					Unary_Peek:
.b3b4	a9 01		lda #$01			lda 	#1
.b3b6	80 06		bra $b3be			bra 	UPMain
.b3b8					Unary_Deek:
.b3b8	a9 02		lda #$02			lda 	#2
.b3ba	80 02		bra $b3be			bra 	UPMain
.b3bc					Unary_Leek:
.b3bc	a9 04		lda #$04			lda 	#4
.b3be					UPMain:
.b3be	48		pha				pha 								; set bytes to copy.
.b3bf	20 90 b0	jsr $b090			jsr 	EvaluateIntegerX 			; numeric parameter
.b3c2	20 0f b7	jsr $b70f			jsr 	CheckNextRParen 			; right bracket.
.b3c5	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.b3c8	85 1a		sta $1a				sta 	zLTemp1
.b3ca	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b3cd	85 1b		sta $1b				sta 	zLTemp1+1
.b3cf	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.b3d2	85 1c		sta $1c				sta 	zLTemp1+2
.b3d4	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.b3d7	85 1d		sta $1d				sta 	zLTemp1+3
.b3d9	a9 00		lda #$00			lda 	#0 							; clear target area
.b3db	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b3de	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b3e1	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b3e4	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b3e7	68		pla				pla 								; restore bytes to copy
.b3e8	da		phx				phx 								; save XY
.b3e9	5a		phy				phy
.b3ea	20 e6 b6	jsr $b6e6			jsr 	MemRead 					; read the bytes in
.b3ed	7a		ply				ply 								; restore and exit
.b3ee	fa		plx				plx
.b3ef	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.b3f0					Unary_Mod:
.b3f0	20 1c b4	jsr $b41c			jsr 	_UMParameter 				; first parameter
.b3f3	20 17 b7	jsr $b717			jsr 	CheckNextComma
.b3f6	da		phx				phx 								; second parameter
.b3f7	e8		inx				inx
.b3f8	e8		inx				inx
.b3f9	e8		inx				inx
.b3fa	e8		inx				inx
.b3fb	e8		inx				inx
.b3fc	e8		inx				inx
.b3fd	20 1c b4	jsr $b41c			jsr 	_UMParameter
.b400	fa		plx				plx
.b401	20 0f b7	jsr $b70f			jsr 	CheckNextRParen
.b404	20 d7 b7	jsr $b7d7			jsr 	DivInteger32 				; divide
.b407	a5 1a		lda $1a				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.b409	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b40c	a5 1b		lda $1b				lda 	zLTemp1+1
.b40e	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b411	a5 1c		lda $1c				lda 	zLTemp1+2
.b413	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b416	a5 1d		lda $1d				lda 	zLTemp1+3
.b418	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b41b	60		rts				rts
.b41c					_UMParameter:
.b41c	20 90 b0	jsr $b090			jsr 	EvaluateIntegerX 			; get value
.b41f	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; absolute value
.b422	10 03		bpl $b427			bpl 	_UMNotSigned
.b424	20 6d b8	jsr $b86d			jsr 	IntegerNegateAlways
.b427					_UMNotSigned:
.b427	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.b428					Unary_Usr:
.b428	20 81 b0	jsr $b081			jsr 	EvaluateNumberX 			; numeric parameter
.b42b	20 0f b7	jsr $b70f			jsr 	CheckNextRParen 			; right bracket.
.b42e	da		phx				phx 								; save XY
.b42f	5a		phy				phy
.b430	ea		nop				nop
.b431	20 00 03	jsr $0300			jsr 	UserVector 					; call the USR function.
.b434	7a		ply				ply 								; and exit
.b435	fa		plx				plx
.b436	60		rts				rts
.b437					USRDefault:
.b437	20 37 ab	jsr $ab37			jsr ERR_Handler
>b43a	4e 6f 20 55 53 52 20 76			.text "No USR vector.",0
>b442	65 63 74 6f 72 2e 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.b449					Unary_Val:
.b449	20 99 b0	jsr $b099			jsr 	EvaluateStringX 			; get string
.b44c	20 0f b7	jsr $b70f			jsr 	CheckNextRParen 			; check right bracket.
.b44f	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.b452	85 1e		sta $1e				sta 	zGenPtr
.b454	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b457	85 1f		sta $1f				sta 	zGenPtr+1
.b459	5a		phy				phy
.b45a	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.b45c	b1 1e		lda ($1e),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.b45e	f0 57		beq $b4b7			beq 	_UVBadNumber
.b460	48		pha				pha 								; save length.
.b461	1a		inc a				inc 	a 							; one for the length, one for the terminator
.b462	1a		inc a				inc 	a
.b463	20 1f b7	jsr $b71f			jsr 	AllocateTempString
.b466	c8		iny				iny 								; move to the next.
.b467	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get character
.b469	49 2d		eor #$2d			eor 	#"-"						; zero if minus sign
.b46b	8d 29 04	sta $0429			sta 	ValSign
.b46e	d0 04		bne $b474			bne 	_UVNotMinus
.b470	c8		iny				iny 								; skip over it.
.b471	68		pla				pla 								; decrement character count.
.b472	3a		dec a				dec 	a
.b473	48		pha				pha
.b474					_UVNotMinus:
.b474	68		pla				pla 								; this is the count.
.b475	48		pha		_UVCopy:pha									; copy into new temp string which is ASCIIZ
.b476	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b478	c8		iny				iny
.b479	20 4a b7	jsr $b74a			jsr 	WriteTempString
.b47c	68		pla				pla
.b47d	3a		dec a				dec 	a
.b47e	d0 f5		bne $b475			bne 	_UVCopy
.b480	20 4a b7	jsr $b74a			jsr 	WriteTempString 			; make it ASCIIZ
.b483	18		clc				clc
.b484	a5 20		lda $20				lda 	zTempStr 					; tempstring +1 => genptr
.b486	69 01		adc #$01			adc 	#1
.b488	85 1e		sta $1e				sta 	zGenPtr
.b48a	a5 21		lda $21				lda 	zTempStr+1
.b48c	69 00		adc #$00			adc 	#0
.b48e	85 1f		sta $1f				sta 	zGenPtr+1
.b490	18		clc				clc
.b491	20 45 b9	jsr $b945			jsr 	IntFromString 				; first bit.
.b494	b0 21		bcs $b4b7			bcs 	_UVBadNumber
.b496	20 69 bf	jsr $bf69			jsr 	FPFromString				; try for a float part.
.b499	ad 29 04	lda $0429			lda 	ValSign 					; was it negative
.b49c	d0 13		bne $b4b1			bne 	_UVNotNegative
.b49e	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; check if integer
.b4a1	4a		lsr a				lsr 	a
.b4a2	b0 0a		bcs $b4ae			bcs 	_UVInteger
.b4a4	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; set sign bit
.b4a7	09 80		ora #$80			ora 	#$80
.b4a9	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.b4ac	80 03		bra $b4b1			bra 	_UVNotNegative
.b4ae					_UVInteger:
.b4ae	20 6d b8	jsr $b86d			jsr 	IntegerNegateAlways 		; sign it.
.b4b1					_UVNotNegative:
.b4b1	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; used everything
.b4b3	d0 02		bne $b4b7			bne 	_UVBadNumber
.b4b5	7a		ply				ply
.b4b6	60		rts				rts
.b4b7					_UVBadNumber:
.b4b7	4c 26 ab	jmp $ab26			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.b4ba					Unary_Str:
.b4ba	20 81 b0	jsr $b081			jsr 	EvaluateNumberX 			; numeric parameter
.b4bd	20 0f b7	jsr $b70f			jsr 	CheckNextRParen 			; right bracket.
.b4c0	a9 00		lda #$00			lda 	#0 							; reset buffer index
.b4c2	8d 00 04	sta $0400			sta 	NumBufX
.b4c5	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.b4c8	4a		lsr a				lsr 	a
.b4c9	b0 05		bcs $b4d0			bcs 	_USInt 						; if msb set do as integer
.b4cb	20 a2 be	jsr $bea2			jsr 	FPToString 					; call fp to str otherwise
.b4ce	80 03		bra $b4d3			bra 	_USDuplicate
.b4d0	20 92 b8	jsr $b892	_USInt:	jsr 	IntToString
.b4d3					_USDuplicate:
.b4d3	ad 00 04	lda $0400			lda 	NumBufX 					; chars in buffer
.b4d6	1a		inc a				inc 	a 							; one more for length
.b4d7	20 1f b7	jsr $b71f			jsr 	AllocateTempString 			; allocate space for it.
.b4da	5a		phy				phy 								; save Y
.b4db	a0 00		ldy #$00			ldy 	#0 							; start copying
.b4dd	b9 01 04	lda $0401,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.b4e0	20 4a b7	jsr $b74a			jsr 	WriteTempString
.b4e3	c8		iny				iny
.b4e4	cc 00 04	cpy $0400			cpy 	NumBufX 					; done the lot
.b4e7	d0 f4		bne $b4dd			bne 	_USCopy
.b4e9	7a		ply				ply 								; restore Y
.b4ea	4c d6 b6	jmp $b6d6			jmp 	UnaryReturnTempStr 			; return new temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.b4ed					Unary_Asc:
.b4ed	20 99 b0	jsr $b099			jsr 	EvaluateStringX 			; string parameter
.b4f0	20 0f b7	jsr $b70f			jsr 	CheckNextRParen 			; right bracket.
.b4f3	5a		phy				phy 								; get the string length
.b4f4	a0 00		ldy #$00			ldy 	#0
.b4f6	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b4f8	f0 07		beq $b501			beq 	_UAIllegal 					; must be at least one character
.b4fa	c8		iny				iny
.b4fb	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; read it.
.b4fd	7a		ply				ply
.b4fe	4c 5a b3	jmp $b35a			jmp 	UnarySetAInteger
.b501					_UAIllegal:
.b501	4c 26 ab	jmp $ab26			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.b504					Unary_Len:
.b504	20 99 b0	jsr $b099			jsr 	EvaluateStringX 			; string parameter
.b507	20 0f b7	jsr $b70f			jsr 	CheckNextRParen 			; right bracket.
.b50a	5a		phy				phy 								; get the string length
.b50b	a0 00		ldy #$00			ldy 	#0
.b50d	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b50f	7a		ply				ply
.b510	4c 5a b3	jmp $b35a			jmp 	UnarySetAInteger

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.b513					Unary_Mid:
.b513	20 99 b0	jsr $b099			jsr 	EvaluateStringX 				; get string.
.b516	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.b519	48		pha				pha
.b51a	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b51d	48		pha				pha
.b51e	20 17 b7	jsr $b717			jsr 	CheckNextComma 					; skip comma
.b521	20 ae b5	jsr $b5ae			jsr 	SLIByteParameter 				; get a byte parameter (start)
.b524	48		pha				pha 									; and push it.
.b525	20 17 b7	jsr $b717			jsr 	CheckNextComma 					; skip comma
.b528	20 ae b5	jsr $b5ae			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.b52b	48		pha				pha 									; and push it.
.b52c	80 45		bra $b573			bra 	SLIProcess
.b52e					Unary_Left:
.b52e	20 99 b0	jsr $b099			jsr 	EvaluateStringX 				; get string.
.b531	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.b534	48		pha				pha
.b535	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b538	48		pha				pha
.b539	a9 01		lda #$01			lda 	#1 								; push start position (1)
.b53b	48		pha				pha
.b53c	20 17 b7	jsr $b717			jsr 	CheckNextComma 					; skip comma
.b53f	20 ae b5	jsr $b5ae			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.b542	48		pha				pha 									; and push it.
.b543	80 2e		bra $b573			bra 	SLIProcess
.b545					Unary_Right:
.b545	20 99 b0	jsr $b099			jsr 	EvaluateStringX 				; get string.
.b548	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.b54b	48		pha				pha
.b54c	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b54f	48		pha				pha
.b550	da		phx				phx 									; get the string length and push on stack.
.b551	a2 00		ldx #$00			ldx 	#0
.b553	a1 1e		lda ($1e,x)			lda		(zGenPtr,x)
.b555	fa		plx				plx
.b556	48		pha				pha
.b557	20 17 b7	jsr $b717			jsr 	CheckNextComma 					; skip comma
.b55a	20 ae b5	jsr $b5ae			jsr 	SLIByteParameter 				; get a byte parameter.
.b55d	8d 25 04	sta $0425			sta 	SignCount 						; save in temporary.
.b560	68		pla				pla 									; restore string length.
.b561	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.b562	38		sec				sec
.b563	ed 25 04	sbc $0425			sbc 	SignCount 						; subtract characters needed, gives start position.
.b566	f0 02		beq $b56a			beq 	_URStart 						; if <= 0 start from 1.
.b568	10 02		bpl $b56c			bpl 	_UROkay
.b56a					_URStart:
.b56a	a9 01		lda #$01			lda 	#1
.b56c					_UROkay:
.b56c	48		pha				pha 									; push start
.b56d	ad 25 04	lda $0425			lda 	SignCount 						; push count of characters
.b570	48		pha				pha
.b571	80 00		bra $b573			bra 	SLIProcess
.b573					SLIProcess:
.b573	20 0f b7	jsr $b70f			jsr 	CheckNextRParen 				; closing right bracket.
.b576	68		pla				pla
.b577	8d 2b 04	sta $042b			sta 	SliceCount 						; count in signcount
.b57a	1a		inc a				inc 	a 								; allocate +1 for it.
.b57b	20 1f b7	jsr $b71f			jsr 	AllocateTempString
.b57e	68		pla				pla 									; pop start number off stack.
.b57f	f0 3f		beq $b5c0			beq 	SLIError 						; exit if start = 0
.b581	8d 2a 04	sta $042a			sta 	SliceStart
.b584	68		pla				pla  									; pop string address.
.b585	85 1f		sta $1f				sta 	zGenPtr+1
.b587	68		pla				pla
.b588	85 1e		sta $1e				sta 	zGenPtr
.b58a	da		phx				phx
.b58b	5a		phy				phy
.b58c	a2 00		ldx #$00			ldx 	#0 								; point to string length.
.b58e	ac 2a 04	ldy $042a			ldy 	SliceStart 						; start of the string (+1 for count)
.b591					_SLICopy:
.b591	ad 2b 04	lda $042b			lda 	SliceCount 						; done count characters
.b594	f0 12		beq $b5a8			beq 	_SLIExit
.b596	ce 2b 04	dec $042b			dec 	SliceCount
.b599	98		tya				tya 									; index of character
.b59a	c1 1e		cmp ($1e,x)			cmp 	(zGenPtr,x)						; compare against length
.b59c	f0 02		beq $b5a0			beq 	_SLIOk 							; if equal, okay.
.b59e	b0 08		bcs $b5a8			bcs 	_SLIExit 						; if past end, then exit.
.b5a0	b1 1e		lda ($1e),y	_SLIOk:	lda 	(zGenPtr),y 					; copy one character
.b5a2	c8		iny				iny
.b5a3	20 4a b7	jsr $b74a			jsr 	WriteTempString
.b5a6	80 e9		bra $b591			bra 	_SLICopy 						; go round till copied characters
.b5a8					_SLIExit:
.b5a8	7a		ply				ply 									; restore YX
.b5a9	fa		plx				plx
.b5aa	4c d6 b6	jmp $b6d6			jmp 	UnaryReturnTempStr 				; return new temporary string.
.b5ad	ea		nop				nop
.b5ae					SLIByteParameter:
.b5ae	20 90 b0	jsr $b090			jsr 	EvaluateIntegerX 				; get integer
.b5b1	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.b5b4	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.b5b7	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.b5ba	d0 04		bne $b5c0			bne 	SLIError
.b5bc	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b5bf	60		rts				rts
.b5c0					SLIError:
.b5c0	4c 26 ab	jmp $ab26			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.b5c3					Unary_Hex:
.b5c3	20 90 b0	jsr $b090			jsr 	EvaluateIntegerX 			; numeric parameter
.b5c6	20 0f b7	jsr $b70f			jsr 	CheckNextRParen 			; right bracket.
.b5c9	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.b5cb	20 1f b7	jsr $b71f			jsr 	AllocateTempString			; allocate string space
.b5ce	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.b5d1	20 f8 b5	jsr $b5f8			jsr 	_UHConvert
.b5d4	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.b5d7	20 f8 b5	jsr $b5f8			jsr 	_UHConvert
.b5da	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b5dd	20 f8 b5	jsr $b5f8			jsr 	_UHConvert
.b5e0	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b5e3	20 f8 b5	jsr $b5f8			jsr 	_UHConvert
.b5e6	5a		phy				phy 								; get length of new string
.b5e7	a0 00		ldy #$00			ldy 	#0
.b5e9	b1 20		lda ($20),y			lda 	(zTempStr),y
.b5eb	7a		ply				ply
.b5ec	c9 00		cmp #$00			cmp 	#0
.b5ee	d0 05		bne $b5f5			bne 	_UHExit 					; if it was non zero okay
.b5f0	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.b5f2	20 4a b7	jsr $b74a			jsr 	WriteTempString
.b5f5					_UHExit:
.b5f5	4c d6 b6	jmp $b6d6			jmp 	UnaryReturnTempStr 			; return new temporary string.
.b5f8					_UHConvert:
.b5f8	48		pha				pha
.b5f9	4a		lsr a				lsr 	a 							; do MSB
.b5fa	4a		lsr a				lsr 	a
.b5fb	4a		lsr a				lsr 	a
.b5fc	4a		lsr a				lsr 	a
.b5fd	20 01 b6	jsr $b601			jsr 	_UHNibble
.b600	68		pla				pla 								; do LSB
.b601					_UHNibble:
.b601	29 0f		and #$0f			and 	#15 						; get nibble
.b603	d0 0c		bne $b611			bne 	_UHNonZero
.b605	5a		phy				phy									; get the length
.b606	a0 00		ldy #$00			ldy 	#0
.b608	b1 20		lda ($20),y			lda 	(zTempStr),y
.b60a	7a		ply				ply
.b60b	c9 00		cmp #$00			cmp 	#0 							; suppress leading zeros.
.b60d	f0 0d		beq $b61c			beq 	_UHExit2
.b60f	a9 00		lda #$00			lda 	#0
.b611					_UHNonZero:
.b611	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.b613	90 02		bcc $b617			bcc 	_UHDigit
.b615	69 06		adc #$06			adc 	#7-1
.b617					_UHDigit:
.b617	69 30		adc #$30			adc 	#48
.b619	20 4a b7	jsr $b74a			jsr 	WriteTempString				; output.
.b61c					_UHExit2:
.b61c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.b61d					Unary_Dec:
.b61d	20 99 b0	jsr $b099			jsr 	EvaluateStringX 			; string parameter
.b620	20 0f b7	jsr $b70f			jsr 	CheckNextRParen 			; right bracket.
.b623	5a		phy				phy
.b624	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.b626	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b628	f0 4c		beq $b676			beq 	_UDFail 					; must fail if zero.
.b62a	8d 25 04	sta $0425			sta 	SignCount 					; use SignCount as a counter
.b62d	a9 00		lda #$00			lda 	#0 							; set result to zero integer.
.b62f	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b632	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b635	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b638	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b63b	a9 01		lda #$01			lda 	#1
.b63d	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.b640					_UDConvertLoop:
.b640	5a		phy				phy 								; shift mantissa left 4
.b641	a0 04		ldy #$04			ldy 	#4
.b643					_UDShift:
.b643	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x
.b646	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.b649	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.b64c	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.b64f	88		dey				dey
.b650	d0 f1		bne $b643			bne 	_UDShift
.b652	7a		ply				ply
.b653	c8		iny				iny 								; next character
.b654	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; fetch it.
.b656	20 79 b6	jsr $b679			jsr 	ConvertUpper 				; convert to U/C
.b659	c9 30		cmp #$30			cmp 	#"0"
.b65b	90 19		bcc $b676			bcc 	_UDFail
.b65d	c9 3a		cmp #$3a			cmp 	#"9"+1
.b65f	90 06		bcc $b667			bcc 	_UDOkay
.b661	e9 37		sbc #$37			sbc 	#7+"0" 						; alpha fudge
.b663	c9 10		cmp #$10			cmp 	#16
.b665	b0 0f		bcs $b676			bcs 	_UDFail
.b667					_UDOkay:
.b667	29 0f		and #$0f			and 	#15 						; nibble only
.b669	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x
.b66c	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b66f	ce 25 04	dec $0425			dec 	SignCount 					; do it for each character
.b672	d0 cc		bne $b640			bne 	_UDConvertLoop
.b674	7a		ply				ply
.b675	60		rts				rts
.b676					_UDFail:
.b676	4c 26 ab	jmp $ab26			jmp 	BadParamError
.b679					ConvertUpper:
.b679	c9 61		cmp #$61			cmp 	#"a"
.b67b	90 07		bcc $b684			bcc 	_CUExit
.b67d	c9 7b		cmp #$7b			cmp 	#"z"+1
.b67f	b0 03		bcs $b684			bcs 	_CUExit
.b681	38		sec				sec
.b682	e9 20		sbc #$20			sbc 	#32
.b684	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.b685					Unary_Chr:
.b685	20 90 b0	jsr $b090			jsr 	EvaluateIntegerX			; numeric parameter
.b688	20 0f b7	jsr $b70f			jsr 	CheckNextRParen 			; right bracket.
.b68b	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.b68e	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.b691	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.b694	d0 0e		bne $b6a4			bne 	_UCChar
.b696	a9 01		lda #$01			lda 	#1 							; one character string
.b698	20 1f b7	jsr $b71f			jsr 	AllocateTempString
.b69b	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.b69e	20 4a b7	jsr $b74a			jsr 	WriteTempString
.b6a1	4c d6 b6	jmp $b6d6			jmp 	UnaryReturnTempStr
.b6a4					_UCChar:
.b6a4	4c 26 ab	jmp $ab26			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.b6a7					Unary_Spc:
.b6a7	20 90 b0	jsr $b090			jsr 	EvaluateIntegerX 			; numeric parameter
.b6aa	20 0f b7	jsr $b70f			jsr 	CheckNextRParen 			; right bracket.
.b6ad	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.b6b0	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.b6b3	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.b6b6	d0 1b		bne $b6d3			bne 	_USSize
.b6b8	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b6bb	c9 fe		cmp #$fe			cmp 	#maxString+1
.b6bd	b0 14		bcs $b6d3			bcs 	_USSize
.b6bf	48		pha				pha 								; save length
.b6c0	1a		inc a				inc 	a 							; allocate one more.
.b6c1	20 1f b7	jsr $b71f			jsr 	AllocateTempString
.b6c4	68		pla				pla 								; get length
.b6c5	f0 0f		beq $b6d6			beq 	UnaryReturnTempStr 			; return the current temp string
.b6c7					_USLoop:
.b6c7	48		pha				pha
.b6c8	a9 20		lda #$20			lda 	#" "
.b6ca	20 4a b7	jsr $b74a			jsr 	WriteTempString
.b6cd	68		pla				pla
.b6ce	3a		dec a				dec 	a
.b6cf	d0 f6		bne $b6c7			bne 	_USLoop
.b6d1	80 03		bra $b6d6			bra 	UnaryReturnTempStr
.b6d3					_USSize:
.b6d3	4c 26 ab	jmp $ab26			jmp 	BadParamError
.b6d6					UnaryReturnTempStr:
.b6d6	a5 20		lda $20				lda 	zTempStr 					; copy temp string addr -> mantissa
.b6d8	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b6db	a5 21		lda $21				lda 	zTempStr+1
.b6dd	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b6e0	a9 02		lda #$02			lda 	#2 							; set type to string
.b6e2	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.b6e5	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/4510.asm

.b6e6					MemRead:
.b6e6	8d 25 04	sta $0425			sta 	SignCount 					; save count
.b6e9	a0 00		ldy #$00			ldy 	#0 							; start from here
.b6eb	b1 1a		lda ($1a),y	_MLoop1:lda 	(zlTemp1),y 				; read the long address
.b6ed	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; copy into mantissa
.b6f0	c8		iny				iny 								; next to copy
.b6f1	e8		inx				inx
.b6f2	cc 25 04	cpy $0425			cpy 	SignCount 					; do required # of bytes.
.b6f5	d0 f4		bne $b6eb			bne 	_MLoop1
.b6f7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.b6f8					CheckNextToken:
.b6f8	d1 16		cmp ($16),y			cmp 	(zCodePtr),y
.b6fa	d0 02		bne $b6fe			bne 	CTFail 						; no, then fail
.b6fc	c8		iny				iny
.b6fd	60		rts				rts
.b6fe					CTFail:
.b6fe	20 37 ab	jsr $ab37			jsr ERR_Handler
>b701	4d 69 73 73 69 6e 67 20			.text "Missing token",0
>b709	74 6f 6b 65 6e 00
.b70f					CheckNextRParen:
.b70f	b1 16		lda ($16),y			lda 	(zCodePtr),y
.b711	c9 bc		cmp #$bc			cmp 	#token_rparen
.b713	d0 e9		bne $b6fe			bne 	CTFail
.b715	c8		iny				iny
.b716	60		rts				rts
.b717					CheckNextComma:
.b717	b1 16		lda ($16),y			lda 	(zCodePtr),y
.b719	c9 bd		cmp #$bd			cmp 	#token_comma
.b71b	d0 e1		bne $b6fe			bne 	CTFail
.b71d	c8		iny				iny
.b71e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.b71f					AllocateTempString:
.b71f	48		pha				pha 								; save required count.
.b720	a5 21		lda $21				lda 	zTempStr+1 					; check if initialised yet ?
.b722	d0 0b		bne $b72f			bne 	_ATSInitialised
.b724	ad 26 04	lda $0426			lda 	StringPtr 					; set temporary string ptr 1 page below available
.b727	85 20		sta $20				sta 	zTempStr					; space, this is for strings to be concreted.
.b729	ad 27 04	lda $0427			lda 	StringPtr+1
.b72c	3a		dec a				dec 	a
.b72d	85 21		sta $21				sta 	zTempStr+1
.b72f					_ATSInitialised:
.b72f	68		pla				pla 								; get required count back.
.b730	49 ff		eor #$ff			eor 	#$FF 						; negate 2's complement.
.b732	1a		inc a				inc 	a
.b733	18		clc				clc
.b734	65 20		adc $20				adc 	zTempStr 					; "add" to the temp string pointer
.b736	85 20		sta $20				sta 	zTempStr
.b738	a9 ff		lda #$ff			lda 	#$FF
.b73a	65 21		adc $21				adc 	zTempStr+1
.b73c	85 21		sta $21				sta 	zTempStr+1
.b73e	a9 00		lda #$00			lda 	#0 							; clear temp string.
.b740	5a		phy				phy
.b741	a8		tay				tay
.b742	91 20		sta ($20),y			sta 	(zTempStr),y
.b744	7a		ply				ply
.b745	1a		inc a				inc 	a 							; reset the write index.
.b746	8d 28 04	sta $0428			sta 	TempStringWriteIndex
.b749	60		rts				rts
.b74a					WriteTempString:
.b74a	5a		phy				phy 								; save Y
.b74b	ac 28 04	ldy $0428			ldy 	TempStringWriteIndex	 	; write position.
.b74e	91 20		sta ($20),y			sta 	(zTempStr),y 				; write character out.
.b750	ee 28 04	inc $0428			inc 	TempStringWriteIndex 		; increment the write position.
.b753	98		tya				tya 								; unchanged Y is now length
.b754	a0 00		ldy #$00			ldy 	#0
.b756	91 20		sta ($20),y			sta 	(zTempStr),y
.b758	7a		ply				ply 								; restore Y and exit
.b759	60		rts				rts
.b75a					CreateTempStringCopy:
.b75a	da		phx				phx 								; save X
.b75b	b1 16		lda ($16),y			lda 	(zCodePtr),y
.b75d	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.b75e	20 1f b7	jsr $b71f			jsr 	AllocateTempString 			; allocate memory for temporary string.
.b761	b1 16		lda ($16),y			lda 	(zCodePtr),y
.b763	c8		iny				iny
.b764	3a		dec a				dec 	a 							; make the actual length in charactes
.b765	3a		dec a				dec 	a
.b766	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.b768	81 20		sta ($20,x)			sta 	(zTempStr,x)
.b76a	85 1a		sta $1a				sta 	zLTemp1 					; that's used as a count.
.b76c	09 00		ora #$00			ora 	#0 							; if zero already, exit
.b76e	f0 0e		beq $b77e			beq 	_CTSCExit
.b770					_CTSCLoop:
.b770	b1 16		lda ($16),y			lda 	(zCodePtr),y
.b772	c8		iny				iny
.b773	5a		phy				phy 								; save in Y
.b774	e8		inx				inx 								; bump index
.b775	da		phx				phx 								; index into Y
.b776	7a		ply				ply
.b777	91 20		sta ($20),y			sta 	(zTempStr),y 				; save at index
.b779	7a		ply				ply 								; restore Y
.b77a	c6 1a		dec $1a				dec 	zLTemp1 					; do for each character
.b77c	d0 f2		bne $b770			bne 	_CTSCLoop
.b77e					_CTSCExit:
.b77e	fa		plx				plx 								; restore X
.b77f	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.b780					MulInteger32:
.b780	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.b783	9d 14 03	sta $0314,x			sta 	XS3_Mantissa,x
.b786	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b789	9d 15 03	sta $0315,x			sta 	XS3_Mantissa+1,x
.b78c	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.b78f	9d 16 03	sta $0316,x			sta 	XS3_Mantissa+2,x
.b792	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.b795	9d 17 03	sta $0317,x			sta 	XS3_Mantissa+3,x
.b798	a9 00		lda #$00			lda 	#0
.b79a	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x 				; zero +0
.b79d	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b7a0	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b7a3	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b7a6					_BFMMultiply:
.b7a6	bd 14 03	lda $0314,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.b7a9	29 01		and #$01			and 	#1
.b7ab	f0 03		beq $b7b0			beq 	_BFMNoAdd
.b7ad	20 75 b2	jsr $b275			jsr 	AddInteger32
.b7b0					_BFMNoAdd:
.b7b0	1e 0e 03	asl $030e,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.b7b3	3e 0f 03	rol $030f,x			rol 	XS2_Mantissa+1,x
.b7b6	3e 10 03	rol $0310,x			rol 	XS2_Mantissa+2,x
.b7b9	3e 11 03	rol $0311,x			rol 	XS2_Mantissa+3,x
.b7bc	5e 17 03	lsr $0317,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.b7bf	7e 16 03	ror $0316,x			ror 	XS3_Mantissa+2,x
.b7c2	7e 15 03	ror $0315,x			ror 	XS3_Mantissa+1,x
.b7c5	7e 14 03	ror $0314,x			ror 	XS3_Mantissa,x
.b7c8	bd 14 03	lda $0314,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.b7cb	1d 15 03	ora $0315,x			ora 	XS3_Mantissa+1,x
.b7ce	1d 16 03	ora $0316,x			ora 	XS3_Mantissa+2,x
.b7d1	1d 17 03	ora $0317,x			ora 	XS3_Mantissa+3,x
.b7d4	d0 d0		bne $b7a6			bne 	_BFMMultiply
.b7d6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.b7d7					DivInteger32:
.b7d7	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; check for /0
.b7da	1d 0f 03	ora $030f,x			ora 	XS2_Mantissa+1,x
.b7dd	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.b7e0	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.b7e3	d0 14		bne $b7f9			bne 	_BFDOkay
.b7e5	20 37 ab	jsr $ab37			jsr ERR_Handler
>b7e8	44 69 76 69 73 69 6f 6e			.text "Division by Zero",0
>b7f0	20 62 79 20 5a 65 72 6f 00
.b7f9					_BFDOkay:
.b7f9	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.b7fb	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.b7fd	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.b7ff	85 1c		sta $1c				sta 	zLTemp1+2
.b801	85 1d		sta $1d				sta 	zLTemp1+3
.b803	8d 25 04	sta $0425			sta 	SignCount 					; Count of signs.
.b806	20 67 b8	jsr $b867			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.b809	da		phx				phx
.b80a	e8		inx				inx
.b80b	e8		inx				inx
.b80c	e8		inx				inx
.b80d	e8		inx				inx
.b80e	e8		inx				inx
.b80f	e8		inx				inx
.b810	20 67 b8	jsr $b867			jsr 	CheckIntegerNegate
.b813	fa		plx				plx
.b814	5a		phy				phy 								; Y is the counter
.b815	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.b817					_BFDLoop:
.b817	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.b81a	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.b81d	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.b820	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.b823	26 1a		rol $1a				rol 	zLTemp1
.b825	26 1b		rol $1b				rol 	zLTemp1+1
.b827	26 1c		rol $1c				rol 	zLTemp1+2
.b829	26 1d		rol $1d				rol 	zLTemp1+3
.b82b	38		sec				sec
.b82c	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.b82e	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.b831	48		pha				pha
.b832	a5 1b		lda $1b				lda 	zLTemp1+1
.b834	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.b837	48		pha				pha
.b838	a5 1c		lda $1c				lda 	zLTemp1+2
.b83a	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.b83d	48		pha				pha
.b83e	a5 1d		lda $1d				lda 	zLTemp1+3
.b840	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.b843	90 15		bcc $b85a			bcc 	_BFDNoAdd
.b845	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.b847	68		pla				pla
.b848	85 1c		sta $1c				sta 	zLTemp1+2
.b84a	68		pla				pla
.b84b	85 1b		sta $1b				sta 	zLTemp1+1
.b84d	68		pla				pla
.b84e	85 1a		sta $1a				sta 	zLTemp1+0
.b850	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.b853	09 01		ora #$01			ora 	#1
.b855	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b858	80 03		bra $b85d			bra 	_BFDNext
.b85a					_BFDNoAdd:
.b85a	68		pla				pla 								; Throw away the intermediate calculations
.b85b	68		pla				pla
.b85c	68		pla				pla
.b85d					_BFDNext:
.b85d	88		dey				dey
.b85e	d0 b7		bne $b817			bne 	_BFDLoop
.b860	7a		ply				ply 								; restore Y and exit
.b861	4e 25 04	lsr $0425			lsr 	SignCount 					; if sign count odd,
.b864	b0 07		bcs $b86d			bcs		IntegerNegateAlways 			; negate the result
.b866	60		rts				rts
.b867					CheckIntegerNegate:
.b867	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.b86a	30 01		bmi $b86d			bmi 	IntegerNegateAlways
.b86c	60		rts				rts
.b86d					IntegerNegateAlways:
.b86d	ee 25 04	inc $0425			inc 	SignCount
.b870	38		sec				sec
.b871	a9 00		lda #$00			lda 	#0
.b873	fd 08 03	sbc $0308,x			sbc 	XS_Mantissa+0,x
.b876	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b879	a9 00		lda #$00			lda 	#0
.b87b	fd 09 03	sbc $0309,x			sbc 	XS_Mantissa+1,x
.b87e	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b881	a9 00		lda #$00			lda 	#0
.b883	fd 0a 03	sbc $030a,x			sbc 	XS_Mantissa+2,x
.b886	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b889	a9 00		lda #$00			lda 	#0
.b88b	fd 0b 03	sbc $030b,x			sbc 	XS_Mantissa+3,x
.b88e	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b891	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.b892					INTToString:
.b892	48		pha				pha
.b893	5a		phy				phy
.b894	bd 0b 03	lda $030b,x			lda 		XS_Mantissa+3,x 		; check -ve
.b897	10 08		bpl $b8a1			bpl 		_ITSNotMinus
.b899	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.b89b	20 32 b9	jsr $b932			jsr 		ITSOutputCharacter
.b89e	20 6d b8	jsr $b86d			jsr 		IntegerNegateAlways 	; negate the number.
.b8a1					_ITSNotMinus:
.b8a1	a9 00		lda #$00			lda 		#0
.b8a3	8d 21 04	sta $0421			sta 		NumSuppress 			; clear the suppression flag.
.b8a6	8a		txa				txa 								; use Y for the mantissa index.
.b8a7	a8		tay				tay
.b8a8	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.b8aa					_ITSNextSubtractor:
.b8aa	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.b8ac	8d 22 04	sta $0422			sta 		NumConvCount
.b8af					_ITSSubtract:
.b8af	38		sec				sec
.b8b0	b9 08 03	lda $0308,y			lda 		XS_Mantissa,y 			; subtract number and push on stack
.b8b3	fd 0e b9	sbc $b90e,x			sbc 		_ITSSubtractors+0,x
.b8b6	48		pha				pha
.b8b7	b9 09 03	lda $0309,y			lda 		XS_Mantissa+1,y
.b8ba	fd 0f b9	sbc $b90f,x			sbc 		_ITSSubtractors+1,x
.b8bd	48		pha				pha
.b8be	b9 0a 03	lda $030a,y			lda 		XS_Mantissa+2,y
.b8c1	fd 10 b9	sbc $b910,x			sbc 		_ITSSubtractors+2,x
.b8c4	48		pha				pha
.b8c5	b9 0b 03	lda $030b,y			lda 		XS_Mantissa+3,y
.b8c8	fd 11 b9	sbc $b911,x			sbc 		_ITSSubtractors+3,x
.b8cb	90 14		bcc $b8e1			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.b8cd	99 0b 03	sta $030b,y			sta 		XS_Mantissa+3,y 		; save subtract off stack
.b8d0	68		pla				pla
.b8d1	99 0a 03	sta $030a,y			sta 		XS_Mantissa+2,y
.b8d4	68		pla				pla
.b8d5	99 09 03	sta $0309,y			sta 		XS_Mantissa+1,y
.b8d8	68		pla				pla
.b8d9	99 08 03	sta $0308,y			sta 		XS_Mantissa+0,y
.b8dc	ee 22 04	inc $0422			inc 		NumConvCount 			; bump count.
.b8df	80 ce		bra $b8af			bra 		_ITSSubtract 			; go round again.
.b8e1					_ITSCantSubtract:
.b8e1	68		pla				pla 								; throw away interim answers
.b8e2	68		pla				pla
.b8e3	68		pla				pla
.b8e4	ad 22 04	lda $0422			lda 		NumConvCount 			; if not zero then no suppression check
.b8e7	c9 30		cmp #$30			cmp 		#"0"
.b8e9	d0 05		bne $b8f0			bne 		_ITSOutputDigit
.b8eb	ad 21 04	lda $0421			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.b8ee	10 09		bpl $b8f9			bpl	 		_ITSGoNextSubtractor
.b8f0					_ITSOutputDigit:
.b8f0	ce 21 04	dec $0421			dec 		NumSuppress 			; suppression check will be non-zero.
.b8f3	ad 22 04	lda $0422			lda 		NumConvCount 			; count of subtractions
.b8f6	20 32 b9	jsr $b932			jsr 		ITSOutputCharacter 		; output it.
.b8f9					_ITSGoNextSubtractor:
.b8f9	e8		inx				inx 								; next dword
.b8fa	e8		inx				inx
.b8fb	e8		inx				inx
.b8fc	e8		inx				inx
.b8fd	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.b8ff	d0 a9		bne $b8aa			bne 		_ITSNextSubtractor 		; do all the subtractors.
.b901	98		tya				tya 								; X is back as the mantissa index
.b902	aa		tax				tax
.b903	bd 08 03	lda $0308,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.b906	09 30		ora #$30			ora 		#"0"
.b908	20 32 b9	jsr $b932			jsr 		ITSOutputCharacter
.b90b	7a		ply				ply 								; and exit
.b90c	68		pla				pla
.b90d	60		rts				rts
.b90e					_ITSSubtractors:
>b90e	00 ca 9a 3b					.dword 		1000000000
>b912	00 e1 f5 05					.dword 		100000000
>b916	80 96 98 00					.dword 		10000000
>b91a	40 42 0f 00					.dword 		1000000
>b91e	a0 86 01 00					.dword 		100000
>b922	10 27 00 00					.dword 		10000
>b926	e8 03 00 00					.dword 		1000
>b92a	64 00 00 00					.dword 		100
>b92e	0a 00 00 00					.dword 		10
.b932					_ITSSubtractorsEnd:
.b932					ITSOutputCharacter:
.b932	48		pha				pha
.b933	da		phx				phx
.b934	ae 00 04	ldx $0400			ldx 	NumBufX 					; save digit
.b937	9d 01 04	sta $0401,x			sta 	Num_Buffer,x
.b93a	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.b93c	9d 02 04	sta $0402,x			sta 	Num_Buffer+1,x
.b93f	ee 00 04	inc $0400			inc 	NumBufX						; bump pointer.
.b942	fa		plx				plx
.b943	68		pla				pla
.b944	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.b945					IntFromString:
.b945	a0 00		ldy #$00			ldy 	#0
.b947	8c 23 04	sty $0423			sty 	ExpTemp 					; this is the converted digit count.
.b94a					IntFromStringY:
.b94a	48		pha				pha
.b94b	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.b94d	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.b950	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b953	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b956	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b959	a9 01		lda #$01			lda 	#1
.b95b	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.b95e					_IFSLoop:
.b95e	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.b960	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.b962	90 60		bcc $b9c4			bcc 	_IFSExit
.b964	c9 3a		cmp #$3a			cmp 	#"9"+1
.b966	b0 5c		bcs $b9c4			bcs 	_IFSExit
.b968	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.b96b	c9 0c		cmp #$0c			cmp 	#12
.b96d	b0 5f		bcs $b9ce			bcs 	_IFSOverflow
.b96f	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.b972	48		pha				pha
.b973	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.b976	48		pha				pha
.b977	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b97a	48		pha				pha
.b97b	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b97e	48		pha				pha
.b97f	20 e3 b9	jsr $b9e3			jsr 	IFSX1ShiftLeft 				; double
.b982	20 e3 b9	jsr $b9e3			jsr 	IFSX1ShiftLeft 				; x 4
.b985	18		clc				clc 								; add saved value x 5
.b986	68		pla				pla
.b987	7d 08 03	adc $0308,x			adc 	XS_Mantissa+0,x
.b98a	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b98d	68		pla				pla
.b98e	7d 09 03	adc $0309,x			adc 	XS_Mantissa+1,x
.b991	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b994	68		pla				pla
.b995	7d 0a 03	adc $030a,x			adc 	XS_Mantissa+2,x
.b998	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b99b	68		pla				pla
.b99c	7d 0b 03	adc $030b,x			adc 	XS_Mantissa+3,x
.b99f	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b9a2	20 e3 b9	jsr $b9e3			jsr 	IFSX1ShiftLeft 				; x 10
.b9a5	ee 23 04	inc $0423			inc 	ExpTemp 					; bump count of digits processed.
.b9a8	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.b9aa	29 0f		and #$0f			and 	#15
.b9ac	c8		iny				iny
.b9ad	7d 08 03	adc $0308,x			adc 	XS_Mantissa+0,x
.b9b0	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b9b3	90 a9		bcc $b95e			bcc 	_IFSLoop
.b9b5	fe 09 03	inc $0309,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.b9b8	d0 a4		bne $b95e			bne 	_IFSLoop
.b9ba	fe 0a 03	inc $030a,x			inc 	XS_Mantissa+2,x
.b9bd	d0 9f		bne $b95e			bne 	_IFSLoop
.b9bf	fe 0b 03	inc $030b,x			inc 	XS_Mantissa+3,x
.b9c2	80 9a		bra $b95e			bra 	_IFSLoop
.b9c4					_IFSExit:
.b9c4	98		tya				tya 								; get offset
.b9c5					_IFSOkay:
.b9c5	38		sec				sec
.b9c6	ad 23 04	lda $0423			lda 	ExpTemp
.b9c9	f0 01		beq $b9cc			beq 	_IFSSkipFail
.b9cb	18		clc				clc
.b9cc					_IFSSkipFail:
.b9cc	68		pla				pla 								; and exit.
.b9cd	60		rts				rts
.b9ce					_IFSOverflow:
.b9ce	20 37 ab	jsr $ab37			jsr 	ERR_Handler
>b9d1	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>b9d9	20 6f 76 65 72 66 6c 6f 77 00
.b9e3					IFSX1ShiftLeft:
.b9e3	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x
.b9e6	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.b9e9	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.b9ec	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.b9ef	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.b9f0					FPSubtract:
.b9f0	48		pha				pha
.b9f1	bd 13 03	lda $0313,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.b9f4	49 80		eor #$80			eor 	#$80
.b9f6	9d 13 03	sta $0313,x			sta 	XS2_Type,x
.b9f9	68		pla				pla 								; --- and fall through ---
.b9fa					FPAdd:
.b9fa	48		pha				pha
.b9fb	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.b9fe	d0 05		bne $ba05			bne 	_FPA_NegativeLHS
.ba00	20 22 ba	jsr $ba22			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.ba03	68		pla				pla
.ba04	60		rts				rts
.ba05					_FPA_NegativeLHS:
.ba05	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.ba08	49 80		eor #$80			eor 	#$80
.ba0a	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.ba0d	bd 13 03	lda $0313,x			lda 	XS2_Type,x 					; flip the sign of B and add
.ba10	49 80		eor #$80			eor 	#$80
.ba12	9d 13 03	sta $0313,x			sta 	XS2_Type,x
.ba15	20 22 ba	jsr $ba22			jsr 	FPAdd_Worker 				; do the add calculation.
.ba18	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip sign of X1 back
.ba1b	49 80		eor #$80			eor 	#$80
.ba1d	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.ba20	68		pla				pla
.ba21	60		rts				rts
.ba22					FPAdd_Worker:
.ba22	3c 13 03	bit $0313,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.ba25	70 08		bvs $ba2f			bvs 	_FPAWExit 					; no change.
.ba27	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.ba2a	50 07		bvc $ba33			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.ba2c	20 c7 bc	jsr $bcc7			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.ba2f					_FPAWExit:
.ba2f	20 4f bd	jsr $bd4f			jsr 	FPUNormalise 				; normalise the result.
.ba32	60		rts				rts
.ba33					_FPAWMakeSame:
.ba33	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.ba36	38		sec				sec
.ba37	fd 12 03	sbc $0312,x			sbc	 	XS2_Exponent,x 				; using subtraction
.ba3a	f0 1b		beq $ba57			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.ba3c	da		phx				phx 								; save X
.ba3d	90 06		bcc $ba45			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.ba3f	e8		inx				inx
.ba40	e8		inx				inx
.ba41	e8		inx				inx
.ba42	e8		inx				inx
.ba43	e8		inx				inx
.ba44	e8		inx				inx
.ba45					_FPAWShiftA:
.ba45	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x 				; so shift exponent up.
.ba48	5e 0b 03	lsr $030b,x			lsr 	3+XS_Mantissa,x
.ba4b	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.ba4e	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.ba51	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.ba54	fa		plx				plx 								; restore original X
.ba55	80 dc		bra $ba33			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.ba57					_FPAW_DoArithmetic:
.ba57	3c 13 03	bit $0313,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.ba5a	30 39		bmi $ba95			bmi 	_FPAW_BNegative
.ba5c	18		clc				clc
.ba5d	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.ba60	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.ba63	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.ba66	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.ba69	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.ba6c	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.ba6f	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.ba72	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.ba75	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.ba78	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.ba7b	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.ba7e	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.ba81	90 ac		bcc $ba2f			bcc 	_FPAWExit 					; no carry.
.ba83	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x 				; so shift exponent up.
.ba86	38		sec				sec
.ba87	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.ba8a	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.ba8d	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.ba90	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.ba93	80 9a		bra $ba2f			bra 	_FPAWExit
.ba95					_FPAW_BNegative:
.ba95	38		sec				sec
.ba96	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.ba99	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.ba9c	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.ba9f	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.baa2	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.baa5	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.baa8	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.baab	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.baae	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.bab1	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.bab4	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.bab7	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.baba	b0 0b		bcs $bac7			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.babc	20 f4 bc	jsr $bcf4			jsr 	FPUNegateInteger			; negate the mantissa
.babf	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip result sign
.bac2	49 80		eor #$80			eor 	#$80
.bac4	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bac7					_FPAWGoExit:
.bac7	4c 2f ba	jmp $ba2f			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.baca					FPD_IsDivZero:
.baca	20 37 ab	jsr $ab37			jsr ERR_Handler
>bacd	44 69 76 69 73 69 6f 6e			.text "Division by zero",0
>bad5	20 62 79 20 7a 65 72 6f 00
.bade					FPDivide:
.bade	48		pha				pha
.badf	5a		phy				phy
.bae0	3c 13 03	bit $0313,x			bit 	XS2_Type,x 					; check if division by zero
.bae3	70 e5		bvs $baca			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.bae5	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.bae8	f0 03		beq $baed			beq 	_FPDCalculateExp
.baea					_FPD_Exit:
.baea	7a		ply				ply
.baeb	68		pla				pla
.baec	60		rts				rts
.baed					_FPDCalculateExp:
.baed	bd 12 03	lda $0312,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.baf0	49 ff		eor #$ff			eor 	#$FF
.baf2	1a		inc a				inc 	a
.baf3	9d 12 03	sta $0312,x			sta 	XS2_Exponent,x
.baf6	20 ea bb	jsr $bbea			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.baf9	18		clc				clc 	 							; add 1 to the resulting exponent
.bafa	69 01		adc #$01			adc 	#1
.bafc	b0 65		bcs $bb63			bcs 	_FPD_Overflow 				; which can overflow.
.bafe	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.bb01	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.bb03	85 1a		sta $1a				sta 	zLTemp1+0
.bb05	85 1b		sta $1b				sta 	zLTemp1+1
.bb07	85 1c		sta $1c				sta 	zLTemp1+2
.bb09	85 1d		sta $1d				sta 	zLTemp1+3
.bb0b	a0 20		ldy #$20			ldy 	#32 						; times round.
.bb0d					_FPD_Loop:
.bb0d	38		sec				sec 								; calculate X1-X2 stacking result because we might
.bb0e	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; not save it.
.bb11	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa,x
.bb14	48		pha				pha
.bb15	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.bb18	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.bb1b	48		pha				pha
.bb1c	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.bb1f	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.bb22	48		pha				pha
.bb23	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.bb26	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.bb29	90 17		bcc $bb42			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.bb2b	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x 			; save results out to A
.bb2e	68		pla				pla
.bb2f	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.bb32	68		pla				pla
.bb33	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.bb36	68		pla				pla
.bb37	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.bb3a	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.bb3c	09 80		ora #$80			ora 	#$80
.bb3e	85 1d		sta $1d				sta 	zLTemp1+3
.bb40	80 03		bra $bb45			bra 	_FPD_Rotates
.bb42					_FPD_NoSubtract:
.bb42	68		pla				pla 								; throw away unwanted results
.bb43	68		pla				pla
.bb44	68		pla				pla
.bb45					_FPD_Rotates:
.bb45	5e 11 03	lsr $0311,x			lsr 	3+XS2_Mantissa,x
.bb48	7e 10 03	ror $0310,x			ror 	2+XS2_Mantissa,x
.bb4b	7e 0f 03	ror $030f,x			ror 	1+XS2_Mantissa,x
.bb4e	7e 0e 03	ror $030e,x			ror 	0+XS2_Mantissa,x
.bb51	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.bb53	26 1b		rol $1b				rol 	zLTemp1+1
.bb55	26 1c		rol $1c				rol 	zLTemp1+2
.bb57	26 1d		rol $1d				rol 	zLTemp1+3
.bb59	90 02		bcc $bb5d			bcc 	_FPD_NoCarry
.bb5b	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.bb5d					_FPD_NoCarry:
.bb5d	88		dey				dey 								; do 32 times
.bb5e	d0 ad		bne $bb0d			bne 	_FPD_Loop
.bb60	4c c7 bb	jmp $bbc7			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.bb63					_FPD_Overflow:
.bb63	4c c4 bd	jmp $bdc4			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.bb66					FPMultiply:
.bb66	48		pha				pha
.bb67	5a		phy				phy
.bb68	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.bb6b	70 08		bvs $bb75			bvs 	_FPM_Exit
.bb6d	3c 13 03	bit $0313,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.bb70	50 06		bvc $bb78			bvc 	_FPM_CalcExponent
.bb72	20 c7 bc	jsr $bcc7			jsr 	FPUCopyX2ToX1
.bb75					_FPM_Exit:
.bb75	7a		ply				ply
.bb76	68		pla				pla
.bb77	60		rts				rts
.bb78					_FPM_CalcExponent:
.bb78	18		clc				clc
.bb79	20 ea bb	jsr $bbea			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.bb7c	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x 				; save the result.
.bb7f	a9 00		lda #$00			lda 	#0
.bb81	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.bb83	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.bb85	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.bb87	85 1d		sta $1d				sta 	zLTemp1+3
.bb89	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.bb8b					_FPM_Loop:
.bb8b	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x				; check LSB of long product
.bb8e	29 01		and #$01			and 	#1
.bb90	18		clc				clc 								; clear carry for the long rotate.
.bb91	f0 1d		beq $bbb0			beq 	_FPM_NoAddition
.bb93	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.bb94	a5 1a		lda $1a				lda 	zLTemp1+0
.bb96	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.bb99	85 1a		sta $1a				sta 	zLTemp1+0
.bb9b	a5 1b		lda $1b				lda 	zLTemp1+1
.bb9d	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.bba0	85 1b		sta $1b				sta 	zLTemp1+1
.bba2	a5 1c		lda $1c				lda 	zLTemp1+2
.bba4	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.bba7	85 1c		sta $1c				sta 	zLTemp1+2
.bba9	a5 1d		lda $1d				lda 	zLTemp1+3
.bbab	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.bbae	85 1d		sta $1d				sta 	zLTemp1+3
.bbb0					_FPM_NoAddition:
.bbb0	66 1d		ror $1d				ror 	3+zLTemp1
.bbb2	66 1c		ror $1c				ror 	2+zLTemp1
.bbb4	66 1b		ror $1b				ror 	1+zLTemp1
.bbb6	66 1a		ror $1a				ror 	0+zLTemp1
.bbb8	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.bbbb	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.bbbe	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.bbc1	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.bbc4	88		dey				dey
.bbc5	d0 c4		bne $bb8b			bne 	_FPM_Loop 					; do this 32 times.
.bbc7					FPM_CopySignNormalize:
.bbc7	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.bbc9	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.bbcc	a5 1b		lda $1b				lda 	zLTemp1+1
.bbce	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.bbd1	a5 1c		lda $1c				lda 	zLTemp1+2
.bbd3	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.bbd6	a5 1d		lda $1d				lda 	zLTemp1+3
.bbd8	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.bbdb	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; sign is xor of signs
.bbde	5d 13 03	eor $0313,x			eor 	XS2_Type,x
.bbe1	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bbe4	20 4f bd	jsr $bd4f			jsr 	FPUNormalise 				; normalise and exit.
.bbe7	7a		ply				ply
.bbe8	68		pla				pla
.bbe9	60		rts				rts
.bbea					FPCalculateExponent:
.bbea	18		clc				clc
.bbeb	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.bbee	7d 12 03	adc $0312,x			adc 	XS2_Exponent,x
.bbf1	b0 08		bcs $bbfb			bcs 	_FPCECarry 					; carry out ?
.bbf3	10 03		bpl $bbf8			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.bbf5	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.bbf7	60		rts				rts
.bbf8					_FPCEExpZero:
.bbf8	a9 00		lda #$00			lda 	#0
.bbfa	60		rts				rts
.bbfb					_FPCECarry:
.bbfb	30 03		bmi $bc00			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.bbfd	09 80		ora #$80			ora 	#$80 						; put in right range
.bbff	60		rts				rts
.bc00					_FPCEOverflow:
.bc00	4c c4 bd	jmp $bdc4			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.bc03					FPFractionalPart:
.bc03	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.bc06	38		sec				sec 								; this flag tells us to keep the fractional part
.bc07	30 0f		bmi $bc18			bmi 	FPGetPart
.bc09	60		rts				rts
.bc0a					FPIntegerPart:
.bc0a	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.bc0d	18		clc				clc 								; this flag says keep the integer part.
.bc0e	30 08		bmi $bc18			bmi 	FPGetPart 					; -ve exponents are 0..127
.bc10	48		pha				pha
.bc11	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.bc13	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bc16	68		pla				pla
.bc17	60		rts				rts
.bc18					FPGetPart:
.bc18	48		pha				pha
.bc19	5a		phy				phy 								; save Y
.bc1a	08		php				php 								; save action
.bc1b	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.bc1e	70 62		bvs $bc82			bvs 	_FPGP_Exit 					; then do nothing.
.bc20	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.bc22	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.bc24	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.bc26	85 1c		sta $1c				sta 	zLTemp1+2
.bc28	85 1d		sta $1d				sta 	zLTemp1+3
.bc2a	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x				; the number of shifts.
.bc2d	38		sec				sec
.bc2e	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.bc30	f0 12		beq $bc44			beq 	_FPGP_NoShift 				; ... if any
.bc32	c9 20		cmp #$20			cmp 	#32
.bc34	90 02		bcc $bc38			bcc 	_FPGP_NotMax
.bc36	a9 20		lda #$20			lda 	#32 						; max of 32.
.bc38					_FPGP_NotMax:
.bc38	a8		tay				tay 								; Y is the mask shift count.
.bc39					_FPGP_ShiftMask:
.bc39	46 1d		lsr $1d				lsr 	3+zLTemp1
.bc3b	66 1c		ror $1c				ror 	2+zLTemp1
.bc3d	66 1b		ror $1b				ror 	1+zLTemp1
.bc3f	66 1a		ror $1a				ror 	0+zLTemp1
.bc41	88		dey				dey
.bc42	d0 f5		bne $bc39			bne 	_FPGP_ShiftMask
.bc44					_FPGP_NoShift:
.bc44	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.bc46	8e 23 04	stx $0423			stx 	ExpTemp						; save X
.bc49					_FPGP_MaskLoop:
.bc49	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.bc4c	28		plp				plp 								; if CC we keep the top part, so we
.bc4d	08		php				php		 							; flip the mask.
.bc4e	b0 02		bcs $bc52			bcs		_FPGP_NoFlip
.bc50	49 ff		eor #$ff			eor 	#$FF
.bc52					_FPGP_NoFlip:
.bc52	3d 08 03	and $0308,x			and 	XS_Mantissa,x 				; and into the mantissa.
.bc55	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.bc58	e8		inx				inx
.bc59	c8		iny				iny
.bc5a	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.bc5c	d0 eb		bne $bc49			bne 	_FPGP_MaskLoop
.bc5e	ae 23 04	ldx $0423			ldx 	ExpTemp						; restore X
.bc61	28		plp				plp
.bc62	08		php				php 								; get action flag on the stack
.bc63	90 05		bcc $bc6a			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.bc65	a9 00		lda #$00			lda 	#0
.bc67	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bc6a					_FPGP_NotFractional:
.bc6a	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 						; check if \1 zero
.bc6d	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.bc70	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.bc73	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.bc76	f0 05		beq $bc7d			beq 	_FPGP_Zero 					; if zero, return zero
.bc78	20 4f bd	jsr $bd4f			jsr 	FPUNormalise
.bc7b	80 05		bra $bc82			bra 	_FPGP_Exit 					; and exit
.bc7d					_FPGP_Zero:
.bc7d	a9 40		lda #$40			lda 	#$40 						; set zero flag
.bc7f	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bc82					_FPGP_Exit:
.bc82	68		pla				pla 								; throw saved action flag.
.bc83	7a		ply				ply
.bc84	68		pla				pla
.bc85	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.bc86					FPCompare:
.bc86	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.bc89	48		pha				pha
.bc8a	bd 12 03	lda $0312,x			lda 	XS2_Exponent,x
.bc8d	48		pha				pha
.bc8e	20 f0 b9	jsr $b9f0			jsr 	FPSubtract 					; calculate X1-X2
.bc91	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.bc94	70 2c		bvs $bcc2			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.bc96	68		pla				pla
.bc97	8d 23 04	sta $0423			sta 	ExpTemp						; save first exponent in temporary reg.
.bc9a	68		pla				pla
.bc9b	38		sec				sec
.bc9c	ed 23 04	sbc $0423			sbc 	ExpTemp 					; calculate AX-BX
.bc9f	70 15		bvs $bcb6			bvs 	_FPCNotEqual				; overflow, can't be equal.
.bca1	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.bca2	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.bca4	b0 10		bcs $bcb6			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.bca6	38		sec				sec
.bca7	ad 23 04	lda $0423			lda 	ExpTemp 					; get one of the exponents back.
.bcaa	e9 12		sbc #$12			sbc 	#18 						; allow for 2^18 error, relatively.
.bcac	b0 02		bcs $bcb0			bcs 	_FPCNotRange 				; keep in range.
.bcae	a9 01		lda #$01			lda 	#1
.bcb0					_FPCNotRange:
.bcb0	38		sec				sec
.bcb1	fd 0c 03	sbc $030c,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.bcb4	b0 0e		bcs $bcc4			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.bcb6					_FPCNotEqual:
.bcb6	bd 0d 03	lda $030d,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.bcb9	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.bcbb	f0 02		beq $bcbf			beq 	_FPCNE2
.bcbd	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.bcbf	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.bcc0	80 04		bra $bcc6			bra 	_FPCExit
.bcc2					_FPCPullZero:
.bcc2	68		pla				pla 								; throw saved exponents
.bcc3	68		pla				pla
.bcc4					_FPCZero:
.bcc4	a9 00		lda #$00			lda 	#0 							; and return zero
.bcc6					_FPCExit:
.bcc6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.bcc7					FPUCopyX2ToX1:
.bcc7	48		pha				pha
.bcc8	da		phx				phx
.bcc9	5a		phy				phy
.bcca	a0 08		ldy #$08			ldy 	#8
.bccc	bd 0e 03	lda $030e,x	_FPUC21:lda 	XS2_Mantissa,x
.bccf	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.bcd2	e8		inx				inx
.bcd3	88		dey				dey
.bcd4	10 f6		bpl $bccc			bpl 	_FPUC21
.bcd6	7a		ply				ply
.bcd7	fa		plx				plx
.bcd8	68		pla				pla
.bcd9	60		rts				rts
.bcda					FPUSetInteger:
.bcda	48		pha				pha
.bcdb	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.bcde	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.bce0	10 02		bpl $bce4			bpl 	_FPUSIExtend
.bce2	a9 ff		lda #$ff			lda 	#$FF
.bce4					_FPUSIExtend:
.bce4	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.bce7	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.bcea	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.bced	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.bcef	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bcf2	68		pla				pla
.bcf3	60		rts				rts
.bcf4					FPUNegateInteger:
.bcf4	48		pha				pha
.bcf5	38		sec				sec
.bcf6	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.bcf8	fd 08 03	sbc $0308,x			sbc 	XS_Mantissa+0,x
.bcfb	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.bcfe	a9 00		lda #$00			lda 	#0
.bd00	fd 09 03	sbc $0309,x			sbc 	XS_Mantissa+1,x
.bd03	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.bd06	a9 00		lda #$00			lda 	#0
.bd08	fd 0a 03	sbc $030a,x			sbc 	XS_Mantissa+2,x
.bd0b	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.bd0e	a9 00		lda #$00			lda 	#0
.bd10	fd 0b 03	sbc $030b,x			sbc 	XS_Mantissa+3,x
.bd13	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.bd16	68		pla				pla
.bd17	60		rts				rts
.bd18					FPUToFloat:
.bd18	48		pha				pha
.bd19	bd 0d 03	lda $030d,x			lda 	XS_Type,x					; exit if already float.
.bd1c	29 0f		and #$0f			and 	#$0F
.bd1e	f0 2d		beq $bd4d			beq 	_FPUFExit
.bd20	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.bd22	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bd25	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.bd27	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x 				; x mantissa.
.bd2a	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.bd2d	10 08		bpl $bd37			bpl		_FPUFPositive
.bd2f	20 f4 bc	jsr $bcf4			jsr 	FPUNegateInteger 			; negate the mantissa
.bd32	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.bd34	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bd37					_FPUFPositive:
.bd37	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.bd3a	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.bd3d	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.bd40	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.bd43	d0 05		bne $bd4a			bne 	_FPUFNonZero
.bd45	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.bd47	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bd4a					_FPUFNonZero:
.bd4a	20 4f bd	jsr $bd4f			jsr 	FPUNormalise 				; normalise the floating point.
.bd4d					_FPUFExit:
.bd4d	68		pla				pla
.bd4e	60		rts				rts
.bd4f					FPUNormalise:
.bd4f	48		pha				pha
.bd50	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.bd53	70 20		bvs $bd75			bvs 	_FPUNExit
.bd55	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.bd58	f0 16		beq $bd70			beq 	_FPUNSetZero
.bd5a					_FPUNLoop:
.bd5a	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.bd5d	30 16		bmi $bd75			bmi 	_FPUNExit 					; if so, we are normalised.
.bd5f	1e 08 03	asl $0308,x			asl 	0+XS_Mantissa+0,x
.bd62	3e 09 03	rol $0309,x			rol 	1+XS_Mantissa+0,x
.bd65	3e 0a 03	rol $030a,x			rol 	2+XS_Mantissa+0,x
.bd68	3e 0b 03	rol $030b,x			rol 	3+XS_Mantissa+0,x
.bd6b	de 0c 03	dec $030c,x			dec 	XS_Exponent,x 				; decrement exponent
.bd6e	d0 ea		bne $bd5a			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.bd70					_FPUNSetZero:
.bd70	a9 40		lda #$40			lda 	#$40
.bd72	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; the result is now zero.
.bd75					_FPUNExit:
.bd75	68		pla				pla
.bd76	60		rts				rts
.bd77					FPUToInteger:
.bd77	48		pha				pha
.bd78	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; if already integer, exit
.bd7b	29 01		and #$01			and 	#1
.bd7d	d0 3e		bne $bdbd			bne 	_FPUTOI_Exit
.bd7f	3c 0d 03	bit $030d,x			bit 	XS_Type,x					; if zero, return zero.
.bd82	70 2b		bvs $bdaf			bvs 	_FPUTOI_Zero
.bd84	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.bd87	10 26		bpl $bdaf			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.bd89	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.bd8b	b0 37		bcs $bdc4			bcs 	FP_Overflow
.bd8d					_FPUToIToInteger:
.bd8d	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.bd90	c9 a0		cmp #$a0			cmp 	#128+32
.bd92	f0 11		beq $bda5			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.bd94	fe 0c 03	inc $030c,x			inc 	XS_Exponent,X 				; increment Exponent
.bd97	5e 0b 03	lsr $030b,x			lsr 	3+XS_Mantissa,x
.bd9a	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.bd9d	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.bda0	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.bda3	80 e8		bra $bd8d			bra 	_FPUToIToInteger 			; keep going.
.bda5					_FPUToICheckSign:
.bda5	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; check sign
.bda8	10 13		bpl $bdbd			bpl 	_FPUToI_Exit 				; exit if unsigned.
.bdaa	20 f4 bc	jsr $bcf4			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.bdad	80 0e		bra $bdbd			bra 	_FPUTOI_Exit
.bdaf					_FPUTOI_Zero:
.bdaf	a9 00		lda #$00			lda 	#0 							; return zero integer.
.bdb1	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.bdb4	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.bdb7	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.bdba	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.bdbd					_FPUToI_Exit:
.bdbd	a9 01		lda #$01			lda 	#1 							; set type to integer
.bdbf	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bdc2	68		pla				pla
.bdc3	60		rts				rts
.bdc4					FP_Overflow:
.bdc4	20 37 ab	jsr $ab37			jsr ERR_Handler
>bdc7	46 6c 6f 61 74 69 6e 67			.text "Floating Point overflow",0
>bdcf	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.bddf					FPUTimes10:
.bddf	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.bde2	85 1a		sta $1a				sta 	ZLTemp1+0
.bde4	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.bde7	85 1b		sta $1b				sta 	ZLTemp1+1
.bde9	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.bdec	85 1c		sta $1c				sta 	ZLTemp1+2
.bdee	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.bdf1	85 1d		sta $1d				sta 	ZLTemp1+3
.bdf3	20 37 be	jsr $be37			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.bdf6	20 37 be	jsr $be37			jsr 	_FPUT_LSR_ZLTemp1
.bdf9	18		clc				clc
.bdfa	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.bdfd	65 1a		adc $1a				adc 	ZLTemp1+0
.bdff	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.be02	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.be05	65 1b		adc $1b				adc 	ZLTemp1+1
.be07	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.be0a	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.be0d	65 1c		adc $1c				adc 	ZLTemp1+2
.be0f	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.be12	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.be15	65 1d		adc $1d				adc 	ZLTemp1+3
.be17	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.be1a	90 0f		bcc $be2b			bcc 	_FPUTimes10
.be1c	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.be1f	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.be22	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.be25	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.be28	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x				; fix exponent
.be2b					_FPUTimes10:
.be2b	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.be2e	18		clc				clc
.be2f	69 03		adc #$03			adc 	#3
.be31	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.be34	b0 8e		bcs $bdc4			bcs 	FP_Overflow 				; error
.be36	60		rts				rts
.be37					_FPUT_LSR_ZLTemp1:
.be37	46 1d		lsr $1d				lsr 	ZLTemp1+3
.be39	66 1c		ror $1c				ror 	ZLTemp1+2
.be3b	66 1b		ror $1b				ror 	ZLTemp1+1
.be3d	66 1a		ror $1a				ror 	ZLTemp1+0
.be3f	60		rts				rts
.be40					FPUScale10A:
.be40	5a		phy				phy
.be41	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.be43	f0 3d		beq $be82			beq 	_FPUScaleExit
.be45	da		phx				phx 								; save X
.be46	e8		inx				inx
.be47	e8		inx				inx
.be48	e8		inx				inx
.be49	e8		inx				inx
.be4a	e8		inx				inx
.be4b	e8		inx				inx
.be4c	a8		tay				tay 								; save power scalar in Y.
.be4d	a9 00		lda #$00			lda 	#0
.be4f	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.be52	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.be55	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.be58	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.be5b	a9 80		lda #$80			lda 	#$80
.be5d	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.be60	a9 81		lda #$81			lda 	#$81
.be62	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.be65	5a		phy				phy 								; save 10^n on stack.
.be66	c0 00		cpy #$00			cpy 	#0
.be68	10 05		bpl $be6f			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.be6a	98		tya				tya
.be6b	49 ff		eor #$ff			eor 	#$FF
.be6d	1a		inc a				inc 	a
.be6e	a8		tay				tay
.be6f					_FPUSAbs:
.be6f	20 df bd	jsr $bddf			jsr 	FPUTimes10
.be72	88		dey				dey
.be73	d0 fa		bne $be6f			bne 	_FPUSAbs 					; tos is now 10^|AC|
.be75	68		pla				pla 								; restore count in A
.be76	fa		plx				plx 								; restore X pointing to number to scale.
.be77	0a		asl a				asl 	a
.be78	b0 05		bcs $be7f			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.be7a	20 66 bb	jsr $bb66			jsr 	FPMultiply 					; if clear multiply.
.be7d	80 03		bra $be82			bra		_FPUScaleExit
.be7f					_FPUSDivide:
.be7f	20 de ba	jsr $bade			jsr 	FPDivide
.be82					_FPUScaleExit:
.be82	7a		ply				ply
.be83	60		rts				rts
.be84					FPUCopyToNext:
.be84	a0 06		ldy #$06			ldy 		#6
.be86	da		phx				phx
.be87					_FPUCopy1:
.be87	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x
.be8a	9d 0e 03	sta $030e,x			sta 	XS2_Mantissa,x
.be8d	e8		inx				inx
.be8e	88		dey				dey
.be8f	d0 f6		bne $be87			bne 	_FPUCopy1
.be91	fa		plx				plx
.be92	60		rts				rts
.be93					FPUCopyFromNext:
.be93	a0 06		ldy #$06			ldy 		#6
.be95	da		phx				phx
.be96					_FPUCopy1:
.be96	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa,x
.be99	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.be9c	e8		inx				inx
.be9d	88		dey				dey
.be9e	d0 f6		bne $be96			bne 	_FPUCopy1
.bea0	fa		plx				plx
.bea1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.bea2					FPToString:
.bea2	48		pha				pha
.bea3	5a		phy				phy
.bea4	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; check zero flag
.bea7	50 0a		bvc $beb3			bvc 		_FPTSIsFloat 			; if zero,
.bea9					_FPTSZero:
.bea9	a9 30		lda #$30			lda 		#"0"
.beab	20 32 b9	jsr $b932			jsr 		ITSOutputCharacter
.beae					_FPTSExit:
.beae	7a		ply				ply
.beaf	68		pla				pla
.beb0	60		rts				rts
.beb1	80 fb		bra $beae			bra 		_FPTSExit
.beb3					_FPTSIsFloat:
.beb3	bd 0d 03	lda $030d,x			lda 		XS_Type,x 				; is it signed ?
.beb6	10 0a		bpl $bec2			bpl 		_FPTSNotSigned
.beb8	a9 00		lda #$00			lda 		#0 						; clear sign flag
.beba	9d 0d 03	sta $030d,x			sta 		XS_Type,x
.bebd	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.bebf	20 32 b9	jsr $b932			jsr 		ITSOutputCharacter
.bec2					_FPTSNotSigned:
.bec2	bd 0c 03	lda $030c,x			lda 		XS_Exponent,x
.bec5	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.bec7	b0 09		bcs $bed2			bcs 		_FPTSExponent
.bec9	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.becb	90 05		bcc $bed2			bcc 		_FPTSExponent 			;
.becd					_FPTSStandard:
.becd	20 16 bf	jsr $bf16			jsr 		FPTOutputBody 			; output the body.
.bed0	80 dc		bra $beae			bra 		_FPTSExit
.bed2					_FPTSExponent:
.bed2	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.bed4	8d 24 04	sta $0424			sta 		ExpCount
.bed7					_FPTSExponentLoop:
.bed7	bd 0c 03	lda $030c,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.beda	10 0e		bpl $beea			bpl 		_FPTSTimes
.bedc	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.bede	90 14		bcc $bef4			bcc 		_FPTSScaledToExp
.bee0	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.bee2	20 40 be	jsr $be40			jsr 		FPUScale10A
.bee5	ee 24 04	inc $0424			inc 		ExpCount
.bee8	80 ed		bra $bed7			bra 		_FPTSExponentLoop
.beea					_FPTSTimes:
.beea	a9 01		lda #$01			lda 		#1
.beec	20 40 be	jsr $be40			jsr 		FPUScale10A
.beef	ce 24 04	dec $0424			dec 		ExpCount
.bef2	80 e3		bra $bed7			bra 		_FPTSExponentLoop
.bef4					_FPTSScaledToExp:
.bef4	20 16 bf	jsr $bf16			jsr 		FPTOutputBody 			; output the body.
.bef7	a9 65		lda #$65			lda 		#"e"					; output E
.bef9	20 32 b9	jsr $b932			jsr 		ITSOutputCharacter
.befc	ad 24 04	lda $0424			lda 		ExpCount 				; get the exponent
.beff	9d 08 03	sta $0308,x			sta 		XS_Mantissa,x
.bf02	29 80		and #$80			and 		#$80 					; sign extend it
.bf04	f0 02		beq $bf08			beq 		_FPTSSExt
.bf06	a9 ff		lda #$ff			lda 		#$FF
.bf08					_FPTSSExt:
.bf08	9d 09 03	sta $0309,x			sta 		XS_Mantissa+1,x
.bf0b	9d 0a 03	sta $030a,x			sta 		XS_Mantissa+2,x
.bf0e	9d 0b 03	sta $030b,x			sta 		XS_Mantissa+3,x
.bf11	20 92 b8	jsr $b892			jsr 		INTToString 			; output the exponent.
.bf14	80 98		bra $beae			bra			_FPTSExit 				; and exit.
.bf16					FPTOutputBody:
.bf16	20 84 be	jsr $be84			jsr 		FPUCopyToNext 			; copy to next slot.
.bf19	20 77 bd	jsr $bd77			jsr 		FPUToInteger 			; convert to an integer
.bf1c	20 92 b8	jsr $b892			jsr 		INTToString 			; output the main integer part.
.bf1f	20 93 be	jsr $be93			jsr 		FPUCopyFromNext 		; get the fractional part back.
.bf22	20 03 bc	jsr $bc03			jsr 		FPFractionalPart 		; get the decimal part.
.bf25	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; any fractional part.
.bf28	70 3e		bvs $bf68			bvs 		_FPTOExit 				; if not, exit now.
.bf2a	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.bf2c	20 32 b9	jsr $b932			jsr 		ITSOutputCharacter
.bf2f					_FPOutLoop:
.bf2f	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; finally reached zero.
.bf32	70 1e		bvs $bf52			bvs 		_FPStripZeros 			; strip trailing zeros
.bf34	20 df bd	jsr $bddf			jsr 		FPUTimes10 				; multiply by 10
.bf37	20 84 be	jsr $be84			jsr 		FPUCopyToNext			; copy to next slot.
.bf3a	20 77 bd	jsr $bd77			jsr 		FPUToInteger 			; convert to integer
.bf3d	bd 08 03	lda $0308,x			lda 		XS_Mantissa+0,x 		; print digit.
.bf40	09 30		ora #$30			ora 		#"0"
.bf42	20 32 b9	jsr $b932			jsr 		ITSOutputCharacter
.bf45	20 93 be	jsr $be93			jsr 		FPUCopyFromNext 		; get it back
.bf48	20 03 bc	jsr $bc03			jsr 		FPFractionalPart 		; get fractional part
.bf4b	ad 00 04	lda $0400			lda 		NumBufX 				; done 11 characters yet ?
.bf4e	c9 0b		cmp #$0b			cmp 	 	#11
.bf50	90 dd		bcc $bf2f			bcc 		_FPOutLoop 				; if so, keep going till zero.
.bf52					_FPStripZeros:
.bf52	ac 00 04	ldy $0400			ldy 		NumBufX 				; strip trailing zeros.
.bf55					_FPStripLoop:
.bf55	88		dey				dey 								; back one, if at start then no strip
.bf56	f0 10		beq $bf68			beq 		_FPToExit
.bf58	b9 01 04	lda $0401,y			lda 		Num_Buffer,y 			; keep going if "0"
.bf5b	c9 30		cmp #$30			cmp 		#"0"
.bf5d	f0 f6		beq $bf55			beq 		_FPStripLoop
.bf5f	c8		iny				iny
.bf60	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.bf62	99 01 04	sta $0401,y			sta 		Num_Buffer,y
.bf65	8c 00 04	sty $0400			sty 		NumBufX 				; update position.
.bf68					_FPTOExit:
.bf68	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.bf69					FPFromString:
.bf69	48		pha				pha 								; push A
.bf6a	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.bf6c	c9 2e		cmp #$2e			cmp 	#"."
.bf6e	f0 03		beq $bf73			beq	 	_FPFIsDecimal
.bf70	4c d6 bf	jmp $bfd6			jmp 	_FPFNotDecimal
.bf73					_FPFIsDecimal:
.bf73	c8		iny				iny 								; consume the decimal.
.bf74	20 18 bd	jsr $bd18			jsr 	FPUToFloat 					; convert the integer to float.
.bf77	da		phx				phx 								; save X.
.bf78	5a		phy				phy 								; save decimal start position
.bf79	e8		inx				inx
.bf7a	e8		inx				inx
.bf7b	e8		inx				inx
.bf7c	e8		inx				inx
.bf7d	e8		inx				inx
.bf7e	e8		inx				inx
.bf7f	20 4a b9	jsr $b94a			jsr 	INTFromStringY 				; get the part after the DP.
.bf82	20 18 bd	jsr $bd18			jsr 	FPUToFloat 					; convert that to a float.
.bf85	68		pla				pla 								; calculate - chars consumed.
.bf86	8c 23 04	sty $0423			sty 	ExpTemp
.bf89	38		sec				sec
.bf8a	ed 23 04	sbc $0423			sbc 	ExpTemp 					; this is the shift amount
.bf8d	20 40 be	jsr $be40			jsr 	FPUScale10A 				; scale it by 10^AC
.bf90	fa		plx				plx 								; restore original X
.bf91	20 fa b9	jsr $b9fa			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.bf94	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.bf96	c9 45		cmp #$45			cmp 	#"E"
.bf98	f0 04		beq $bf9e			beq 	_FPFExponent
.bf9a	c9 65		cmp #$65			cmp 	#"e"
.bf9c	d0 38		bne $bfd6			bne 	_FPFNotDecimal 				; no, then exit normally.
.bf9e					_FPFExponent:
.bf9e	c8		iny				iny 								; skip over E symbol.
.bf9f	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.bfa1	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.bfa3	d0 01		bne $bfa6			bne 	_FPFGotSign
.bfa5	c8		iny				iny 								; if it was - skip over it.
.bfa6					_FPFGotSign:
.bfa6	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.bfa7	da		phx				phx
.bfa8	e8		inx				inx
.bfa9	e8		inx				inx
.bfaa	e8		inx				inx
.bfab	e8		inx				inx
.bfac	e8		inx				inx
.bfad	e8		inx				inx
.bfae	20 4a b9	jsr $b94a			jsr 	INTFromStringY 				; get the exponent
.bfb1	fa		plx				plx 								; restore X.
.bfb2	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.bfb5	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.bfb8	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.bfbb	d0 1b		bne $bfd8			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.bfbd	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.bfc0	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.bfc2	b0 14		bcs $bfd8			bcs 	_FPFXOverflow
.bfc4	68		pla				pla 								; get direction
.bfc5	d0 09		bne $bfd0			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.bfc7	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.bfca	49 ff		eor #$ff			eor 	#$FF
.bfcc	1a		inc a				inc 	a
.bfcd	9d 0e 03	sta $030e,x			sta 	XS2_Mantissa+0,x
.bfd0					_FPFXScale:
.bfd0	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.bfd3	20 40 be	jsr $be40			jsr 	FPUScale10A 				; scale by the exponent.
.bfd6					_FPFNotDecimal:
.bfd6	68		pla				pla
.bfd7	60		rts				rts
.bfd8					_FPFXOverflow:
.bfd8	20 37 ab	jsr $ab37			jsr 	ERR_Handler
>bfdb	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>bfe3	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.bfea					Unary_Rnd:
.bfea	20 81 b0	jsr $b081			jsr 	EvaluateNumberX 			; get value
.bfed	20 0f b7	jsr $b70f			jsr 	CheckNextRParen 			; check right bracket.
.bff0	20 6e b3	jsr $b36e			jsr 	GetSignCurrent 				; get sign -1,0,1.
.bff3	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.bff5	30 10		bmi $c007			bmi 	_URSetSeed
.bff7	f0 2c		beq $c025			beq 	_URMakeRandom 				; if zero return same number.
.bff9	da		phx				phx
.bffa	a2 00		ldx #$00			ldx 	#0
.bffc	20 62 c0	jsr $c062			jsr 	Random16
.bfff	a2 02		ldx #$02			ldx 	#2
.c001	20 62 c0	jsr $c062			jsr 	Random16
.c004	fa		plx				plx
.c005	80 1e		bra $c025			bra 	_URMakeRandom
.c007					_URSetSeed:
.c007	20 18 bd	jsr $bd18			jsr 	FPUToFloat 					; make it a float to twiddle it.
.c00a	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.c00d	8d 2c 04	sta $042c			sta 	RandomSeed+0
.c010	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.c013	8d 2d 04	sta $042d			sta 	RandomSeed+1
.c016	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.c019	8d 2e 04	sta $042e			sta 	RandomSeed+2
.c01c	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.c01f	0a		asl a				asl 	a
.c020	49 db		eor #$db			eor 	#$DB
.c022	8d 2f 04	sta $042f			sta 	RandomSeed+3
.c025					_URMakeRandom:
.c025	ad 2c 04	lda $042c			lda 	RandomSeed+0 				; check if seed is zero.
.c028	0d 2d 04	ora $042d			ora 	RandomSeed+1
.c02b	0d 2e 04	ora $042e			ora 	RandomSeed+2
.c02e	0d 2f 04	ora $042f			ora 	RandomSeed+3
.c031	d0 0a		bne $c03d			bne 	_URNotZero
.c033	a9 47		lda #$47			lda 	#$47
.c035	8d 2d 04	sta $042d			sta 	RandomSeed+1				; if it is, make it non zero.
.c038	a9 3d		lda #$3d			lda 	#$3D
.c03a	8d 2f 04	sta $042f			sta 	RandomSeed+3
.c03d					_URNotZero:
.c03d	ad 2c 04	lda $042c			lda 	RandomSeed+0 				; copy seed into mantissa.
.c040	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.c043	ad 2d 04	lda $042d			lda 	RandomSeed+1
.c046	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.c049	ad 2e 04	lda $042e			lda 	RandomSeed+2
.c04c	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.c04f	ad 2f 04	lda $042f			lda 	RandomSeed+3
.c052	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.c055	a9 00		lda #$00			lda 	#$00 						; set type to float.
.c057	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.c05a	a9 80		lda #$80			lda 	#$80
.c05c	9d 0c 03	sta $030c,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.c05f	4c 4f bd	jmp $bd4f			jmp 	FPUNormalise
.c062					Random16:
.c062	5e 2d 04	lsr $042d,x			lsr 	RandomSeed+1,x				; shift seed right
.c065	7e 2c 04	ror $042c,x			ror 	RandomSeed,x
.c068	90 08		bcc $c072			bcc 	_R16_NoXor
.c06a	bd 2d 04	lda $042d,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.c06d	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.c06f	9d 2d 04	sta $042d,x			sta 	RandomSeed+1,x
.c072					_R16_NoXor:
.c072	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.c073					Unary_Int:
.c073	20 81 b0	jsr $b081			jsr 	EvaluateNumberX 			; get value
.c076	20 0f b7	jsr $b70f			jsr 	CheckNextRParen 			; check right bracket.
.c079	4c 77 bd	jmp $bd77			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.c07c					TIM_Error:
.c07c	20 35 a0	jsr $a035			jsr 	IFT_UpLine 					; go up one line.
.c07f	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.c081	80 02		bra $c085			bra 	TIM_ShowPrompt
.c083					TIM_NewCommand:
.c083	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.c085					TIM_ShowPrompt:
.c085	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.c088	20 f9 a0	jsr $a0f9			jsr 	IFT_ReadLine	 			; get character, go to next line
.c08b	20 5b a0	jsr $a05b			jsr 	IFT_NewLine					; go to next line.
.c08e	86 10		stx $10				stx 	zTemp1 						; save line read address
.c090	84 11		sty $11				sty 	zTemp1+1
.c092	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.c094	b1 10		lda ($10),y			lda 	(zTemp1),y
.c096	c9 3f		cmp #$3f			cmp 	#"?"
.c098	f0 04		beq $c09e			beq 	TIM_SkipFirst
.c09a	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.c09c	d0 01		bne $c09f			bne 	TIM_NotDot
.c09e					TIM_SkipFirst:
.c09e	c8		iny				iny
.c09f					TIM_NotDot:
.c09f	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.c0a1	c9 52		cmp #$52			cmp 	#"R"						; show registers
.c0a3	f0 6e		beq $c113			beq 	TIM_ShowRegisters
.c0a5	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.c0a7	f0 12		beq $c0bb			beq 	TIM_ShowMemory
.c0a9	c9 47		cmp #$47			cmp 	#"G"						; execute
.c0ab	f0 49		beq $c0f6			beq 	TIM_Execute
.c0ad	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.c0af	f0 07		beq $c0b8			beq 	TIM_GoLoadMemory
.c0b1	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.c0b3	d0 c7		bne $c07c			bne 	TIM_Error
.c0b5	4c 38 c2	jmp $c238			jmp 	TIM_UpdateRegisters
.c0b8					TIM_GoLoadMemory:
.c0b8	4c 63 c2	jmp $c263			jmp 	TIM_LoadMemory
.c0bb					TIM_ShowMemory:
.c0bb	20 b1 c1	jsr $c1b1			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.c0be	b0 bc		bcs $c07c			bcs 	TIM_Error
.c0c0	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.c0c2	85 12		sta $12				sta 	zTemp2
.c0c4	a5 15		lda $15				lda 	zTemp3+1
.c0c6	85 13		sta $13				sta 	zTemp2+1
.c0c8	20 b1 c1	jsr $c1b1			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.c0cb	90 08		bcc $c0d5			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.c0cd	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.c0cf	85 14		sta $14				sta 	zTemp3
.c0d1	a5 13		lda $13				lda 	zTemp2+1
.c0d3	85 15		sta $15				sta 	zTemp3+1
.c0d5					_TIMSM_Start:
.c0d5	20 89 c1	jsr $c189			jsr 	TIM_WriteLine 				; write one line of hex out
.c0d8	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.c0da	18		clc				clc
.c0db	69 10		adc #$10			adc 	#16
.c0dd	85 12		sta $12				sta 	zTemp2
.c0df	90 02		bcc $c0e3			bcc 	_TIMSM_NoCarry
.c0e1	e6 13		inc $13				inc 	zTemp2+1
.c0e3					_TIMSM_NoCarry:
.c0e3	20 e4 a1	jsr $a1e4			jsr 	IF_CheckBreak 				; check CTL+C
.c0e6	d0 0b		bne $c0f3			bne 	_TIMSM_Ends 				; if pressed break out.
.c0e8	38		sec				sec 								; check past the end address in zTemp3
.c0e9	a5 14		lda $14				lda 	zTemp3
.c0eb	e5 12		sbc $12				sbc 	zTemp2
.c0ed	a5 15		lda $15				lda 	zTemp3+1
.c0ef	e5 13		sbc $13				sbc 	zTemp2+1
.c0f1	10 e2		bpl $c0d5			bpl 	_TIMSM_Start
.c0f3					_TIMSM_Ends:
.c0f3	4c 83 c0	jmp $c083			jmp 	TIM_NewCommand
.c0f6					TIM_Execute:
.c0f6	20 b1 c1	jsr $c1b1			jsr 	TIM_GetHex 					; get the execute address
.c0f9	b0 81		bcs $c07c			bcs 	TIM_Error 					; not legitimate
.c0fb	ae 39 04	ldx $0439			ldx 	TIM_SP 						; set up SP
.c0fe	9a		txs				txs
.c0ff	ad 34 04	lda $0434			lda 	TIM_SR 						; Status for PLP
.c102	48		pha				pha
.c103	ad 35 04	lda $0435			lda 	TIM_A 						; restore AXYZ
.c106	ae 36 04	ldx $0436			ldx 	TIM_X
.c109	ac 37 04	ldy $0437			ldy 	TIM_Y
.c10c	ab 38 04	ldz $0438			ldz 	TIM_Z
.c10f	28		plp				plp 								; and PS Byte.
.c110	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.c113					TIM_Start:
.c113					TIM_ShowRegisters:
.c113	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.c116	8d 33 04	sta $0433			sta 	TIM_IRQ+1
.c119	ad ff ff	lda $ffff			lda 	$FFFF
.c11c	8d 32 04	sta $0432			sta 	TIM_IRQ
.c11f	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.c121					_TIMSR_Text:
.c121	bd 4d c1	lda $c14d,x			lda 	_TIMSR_Label,x
.c124	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.c127	e8		inx				inx
.c128	e0 23		cpx #$23			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.c12a	d0 f5		bne $c121			bne 	_TIMSR_Text
.c12c	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.c12e					_TIMSR_Skip:
.c12e	e8		inx				inx
.c12f					_TIMSR_LoopSpace:
.c12f	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.c131	b0 04		bcs $c137			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.c133	8a		txa				txa
.c134	4a		lsr a				lsr 	a
.c135	b0 05		bcs $c13c			bcs 	_TIMSR_NoSpace
.c137					_TIMSR_Space:
.c137	a9 20		lda #$20			lda 	#" "
.c139	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.c13c					_TIMSR_NoSpace:
.c13c	bd 30 04	lda $0430,x			lda 	TIM_PC,x 					; output hex value.
.c13f	20 70 c1	jsr $c170			jsr 	TIM_WriteHex
.c142	e8		inx				inx
.c143	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.c145	d0 e8		bne $c12f			bne 	_TimSR_LoopSpace
.c147	20 5b a0	jsr $a05b			jsr 	IFT_NewLine 				; new line
.c14a	4c 83 c0	jmp $c083			jmp	 	TIM_NewCommand 				; new command.
.c14d					_TIMSR_Label:
>c14d	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>c155	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>c165	52
>c166	20 5a 52					.text 	" ZR"
>c169	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.c170					_TIMSR_LabelEnd:
.c170					TIM_WriteHex:
.c170	48		pha				pha 								; save A
.c171	4a		lsr a				lsr 	a 							; shift MSB->LSB
.c172	4a		lsr a				lsr 	a
.c173	4a		lsr a				lsr 	a
.c174	4a		lsr a				lsr 	a
.c175	20 79 c1	jsr $c179			jsr 	_TIMWH_Nibble 				; print MSB
.c178	68		pla				pla 								; restore and print LSB
.c179					_TIMWH_Nibble:
.c179	48		pha				pha
.c17a	29 0f		and #$0f			and 	#15 						; mask out
.c17c	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.c17e	90 02		bcc $c182			bcc 	_TIMWHNoLetter
.c180	69 06		adc #$06			adc 	#6
.c182					_TIMWHNoLetter:
.c182	69 30		adc #$30			adc 	#48
.c184	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter 			; print it out.
.c187	68		pla				pla
.c188	60		rts				rts
.c189					TIM_WriteLine:
.c189	a9 2e		lda #$2e			lda 	#"." 						; prompt
.c18b	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.c18e	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.c190	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.c193	a5 13		lda $13				lda 	zTemp2+1 					; write address
.c195	20 70 c1	jsr $c170			jsr 	TIM_WriteHex
.c198	a5 12		lda $12				lda 	zTemp2
.c19a	20 70 c1	jsr $c170			jsr 	TIM_WriteHex
.c19d	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.c19f					_TIMWL_Loop:
.c19f	a9 20		lda #$20			lda 	#" "
.c1a1	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.c1a4	b1 12		lda ($12),y			lda 	(zTemp2),y
.c1a6	20 70 c1	jsr $c170			jsr 	TIM_WriteHex
.c1a9	c8		iny				iny
.c1aa	c0 10		cpy #$10			cpy 	#16
.c1ac	d0 f1		bne $c19f			bne 	_TIMWL_Loop
.c1ae	4c 5b a0	jmp $a05b			jmp 	IFT_NewLine 				; new line and exit
.c1b1					TIM_GetHex:
.c1b1	c8		iny				iny
.c1b2	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.c1b4	c9 20		cmp #$20			cmp 	#32
.c1b6	f0 f9		beq $c1b1			beq 	TIM_GetHex
.c1b8	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.c1ba	f0 f5		beq $c1b1			beq 	TIM_GetHex
.c1bc	20 e5 c1	jsr $c1e5			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.c1bf	b0 23		bcs $c1e4			bcs 	_TIMGH_Exit					; if first bad then exit now.
.c1c1	a9 00		lda #$00			lda 	#0 							; zero result
.c1c3	85 14		sta $14				sta 	zTemp3
.c1c5	85 15		sta $15				sta 	zTemp3+1
.c1c7					_TIM_GHLoop:
.c1c7	20 e5 c1	jsr $c1e5			jsr 	TIM_GetHexCharacter 		; get next character
.c1ca	b0 17		bcs $c1e3			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.c1cc	c8		iny				iny 								; skip over it.
.c1cd	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.c1cf	26 15		rol $15				rol 	zTemp3+1
.c1d1	06 14		asl $14				asl 	zTemp3 						; now x 2
.c1d3	26 15		rol $15				rol 	zTemp3+1
.c1d5	06 14		asl $14				asl 	zTemp3						; now x 4
.c1d7	26 15		rol $15				rol 	zTemp3+1
.c1d9	06 14		asl $14				asl 	zTemp3 						; now x 8
.c1db	26 15		rol $15				rol 	zTemp3+1
.c1dd	05 14		ora $14				ora 	zTemp3 						; OR result in
.c1df	85 14		sta $14				sta 	zTemp3
.c1e1	80 e4		bra $c1c7			bra 	_TIM_GHLoop 				; loop round again.
.c1e3					_TIMGH_Okay:
.c1e3	18		clc				clc
.c1e4					_TIMGH_Exit:
.c1e4	60		rts				rts
.c1e5					TIM_GetHexCharacter:
.c1e5	b1 10		lda ($10),y			lda 	(zTemp1),y
.c1e7	38		sec				sec
.c1e8	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.c1ea	90 0e		bcc $c1fa			bcc 	_TIM_GHCFail
.c1ec	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.c1ee	90 0b		bcc $c1fb			bcc 	_TIM_GHCExit
.c1f0	c9 11		cmp #$11			cmp 	#65-48						; < A
.c1f2	90 06		bcc $c1fa			bcc		_TIM_GHCFail
.c1f4	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.c1f6	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.c1f8	90 01		bcc $c1fb			bcc		_TIM_GHCExit
.c1fa					_TIM_GHCFail:
.c1fa	38		sec				sec
.c1fb					_TIM_GHCExit:
.c1fb	60		rts				rts
.c1fc					TIM_BreakVector:
.c1fc	da		phx				phx									; save X/A on stack
.c1fd	48		pha				pha
.c1fe	ba		tsx				tsx 								; X points to S
.c1ff	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.c202	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.c204	d0 03		bne $c209			bne 	_TIMBreak					; if set, it's BRK
.c206	68		pla				pla 								; abandon routine.
.c207	fa		plx				plx
.c208	40		rti				rti
.c209					_TIMBreak:
.c209	68		pla				pla 								; save A X Y and maybe Z
.c20a	8d 35 04	sta $0435			sta 	TIM_A
.c20d	fa		plx				plx
.c20e	8e 36 04	stx $0436			stx 	TIM_X
.c211	8c 37 04	sty $0437			sty 	TIM_Y
.c214	9c 38 04	stz $0438			stz 	TIM_Z
.c217	68		pla				pla 								; get Status Register
.c218	8d 34 04	sta $0434			sta 	TIM_SR
.c21b	68		pla				pla
.c21c	8d 31 04	sta $0431			sta 	TIM_PC+1 					; save calling address
.c21f	68		pla				pla
.c220	8d 30 04	sta $0430			sta 	TIM_PC 						; high byte
.c223	ad 31 04	lda $0431			lda 	TIM_PC+1 					; dec PC to point right.
.c226	d0 03		bne $c22b			bne 	_TIMDecrement 				; brk bumps it.
.c228	ce 30 04	dec $0430			dec 	TIM_PC
.c22b					_TIMDecrement:
.c22b	ce 31 04	dec $0431			dec 	TIM_PC+1
.c22e	ba		tsx				tsx 								; and copy SP
.c22f	8e 39 04	stx $0439			stx 	TIM_SP
.c232	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.c234	9a		txs				txs
.c235	4c 13 c1	jmp $c113			jmp 	TIM_Start 					; and start up TIM monitor.
.c238					TIM_UpdateRegisters:
.c238	20 b1 c1	jsr $c1b1			jsr 	TIM_GetHex 					; PC
.c23b	b0 23		bcs $c260			bcs 	_TIMURFail
.c23d	a5 14		lda $14				lda 	zTemp3
.c23f	8d 31 04	sta $0431			sta 	Tim_PC+1
.c242	a5 15		lda $15				lda 	zTemp3+1
.c244	8d 30 04	sta $0430			sta 	Tim_PC
.c247	20 b1 c1	jsr $c1b1			jsr 	TIM_GetHex 					; ignore IRQ
.c24a	b0 14		bcs $c260			bcs 	_TIMURFail
.c24c	a2 00		ldx #$00			ldx 	#0
.c24e					_TIM_URLoop:
.c24e	20 b1 c1	jsr $c1b1			jsr 	TIM_GetHex 					; registers
.c251	b0 0d		bcs $c260			bcs 	_TIMURFail
.c253	a5 14		lda $14				lda 	zTemp3
.c255	9d 34 04	sta $0434,x			sta 	Tim_SR,x
.c258	e8		inx				inx
.c259	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.c25b	d0 f1		bne $c24e			bne 	_TIM_URLoop
.c25d	4c 83 c0	jmp $c083			jmp 	TIM_NewCommand
.c260					_TIMURFail:
.c260	4c 7c c0	jmp $c07c			jmp 	TIM_Error
.c263					TIM_LoadMemory:
.c263	20 b1 c1	jsr $c1b1			jsr 	TIM_GetHex 					; target address => zTemp2
.c266	a5 14		lda $14				lda 	zTemp3
.c268	85 12		sta $12				sta 	zTemp2
.c26a	a5 15		lda $15				lda 	zTemp3+1
.c26c	85 13		sta $13				sta 	zTemp2+1
.c26e					_TIM_LMLoop:
.c26e	20 b1 c1	jsr $c1b1			jsr 	TIM_GetHex 					; next byte ?
.c271	b0 0e		bcs $c281			bcs 	_TIMLMDone 					; no more
.c273	a2 00		ldx #$00			ldx 	#0							; write out.
.c275	a5 14		lda $14				lda 	zTemp3
.c277	81 12		sta ($12,x)			sta 	(zTemp2,x)
.c279	e6 12		inc $12				inc 	zTemp2 						; bump address
.c27b	d0 f1		bne $c26e			bne 	_TIM_LMLoop
.c27d	e6 13		inc $13				inc 	zTemp2+1
.c27f	80 ed		bra $c26e			bra 	_TIM_LMLoop
.c281					_TIMLMDone:
.c281	4c 83 c0	jmp $c083			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Return to file: basic.asm

.c284	80 fe		bra $c284	_halt:	bra 		_halt
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 a0						.word 	StartROM
>fffe	fc c1					.word TIM_BreakVector

;******  End of listing
