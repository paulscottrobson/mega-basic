
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Wed Aug 28 11:54:47 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="65816"				cpu = "65816"
="em65816"				hardware = "em65816"
=1					exitonend = 1
=1					autorun = 1
=2					loadtest = 2
=1					hasfloat = 1
=1					hasinteger = 1
=253					maxstring = 253

;******  Processing file: modules/float/fpmacros.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/em65816/src_em65816.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0020					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0022					zVarDataPtr: .word ? 						; position of variable data.
>0024					zVarType: 	.byte ? 						; type of data (token)
>0025					zNullString:.byte ? 						; represents a NULL string.
>0200					IFT_XCursor:.byte ?							; current logical position on screen
>0201					IFT_YCursor:.byte ?
>0202					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0266					IFT_LineBuffer: .fill 100 					; line input buffer.
>0300					UserVector .fill 4 							; USR(x) calls this.
>0304					LocalVector .fill 4 						; Indirect calls call this.
>0308					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>030c					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>030d					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=782					XS2_Mantissa = XS_Mantissa+XS_Size
=786					XS2_Exponent = XS_Exponent+XS_Size
=787					XS2_Type = XS_Type+XS_Size
=788					XS3_Mantissa = XS_Mantissa+XS_Size*2
=792					XS3_Exponent = XS_Exponent+XS_Size*2
=793					XS3_Type = XS_Type+XS_Size*2
>0400					StringPtr:	.word ? 						; Top of free memory (for string allocation)
>0402					VarMemPtr: 	.word ?							; Bottom of free memory (for variables)
>0404					endOfProgram: .word ? 						; End of Program Memory.
>0406					NumBufX 	.byte 	?						; buffer index position
>0407					Num_Buffer	.fill 	32 						; buffer for numeric conversions
=6					HashTableCount = 6 							; there are 6 hash tables, in token order.
=8					HashTableSize = 8 							; each hash table as 8 links.
.0427					HashTableBase:
>0427								.fill	HashTableCount * HashTableSize * 2
.0487					HashTableEnd:
=$407					Var_Buffer 	= Num_Buffer 					; buffer for variable name (same space)
>0487					Var_Type    .byte ? 						; type of variable (as a type token)
>0488					Var_Hash 	.byte ? 						; hash of identifier name.
>0489					Var_Length 	.byte ? 						; length of variable name
>048a					Var_HashAddress .byte ?						; low byte of hash table entry.
>048b					Var_DataSize .byte ?						; size of one element.
>048c					NumSuppress	.byte 	?						; leading zero suppression flag
>048d					NumConvCount .byte 	? 						; count for conversions.
>048e					ExpTemp:	.byte ?							; Working temp for exponents.
>048f					ExpCount:	.byte ? 						; Count of decimal exponents.
>0490					SignCount:	.byte ?							; Integer Divide Sign Counts.
>0491					TempStringWriteIndex: .byte ? 				; Write offset.
>0492					ValSign: 	.byte ? 						; sign flag for val()
>0493					SliceStart:	.byte ? 						; string slice parts
>0494					SliceCount:	.byte ?
>0495					RandomSeed:	.dword ? 						; Random seed.
=3					ArrayMaxDim = 3 							; number of dimensions.
>0499					ArrayDef:	.fill (ArrayMaxDim+1)*2 		; dimensions for auto-creation
>04a1					UsrArrayDef:.fill (ArrayMaxDim+1)*2 		; dimensions created in DIM
>04a9					UsrArrayIdx:.byte ? 						; index into UsrArrayDef
>04aa					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>04ac					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>04ae					Tim_SR:		.byte ? 						; Processor Status
>04af					Tim_A:		.byte ? 						; Processor Registers
>04b0					Tim_X:		.byte ?
>04b1					Tim_Y:		.byte ?
>04b2					Tim_Z:		.byte ?
>04b3					Tim_SP:		.word ?							; Stack Pointer (just in cases)

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/em65816.asm

=$8000					HighMemory = $8000
=0					VariableMemory = 0							; i.e. put it after BASIC code.
.1000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testassign.src

>1000	0d 02 00 c7 01 38 12 1a			.byte	$0d,$02,$00,$c7,$01,$38,$12,$1a
>1008	12 bc 42 be 00 0d 03 00			.byte	$12,$bc,$42,$be,$00,$0d,$03,$00
>1010	c7 19 38 08 08 12 bd 41			.byte	$c7,$19,$38,$08,$08,$12,$bd,$41
>1018	be 00 0c 04 00 c7 0b 31			.byte	$be,$00,$0c,$04,$00,$c7,$0b,$31
>1020	01 19 bd 41 be 00 0c 05			.byte	$01,$19,$bd,$41,$be,$00,$0c,$05
>1028	00 c7 0e 31 18 13 ba 41			.byte	$00,$c7,$0e,$31,$18,$13,$ba,$41
>1030	be 00 0c 06 00 c7 0b 32			.byte	$be,$00,$0c,$06,$00,$c7,$0b,$32
>1038	15 07 ba 41 be 00 09 07			.byte	$15,$07,$ba,$41,$be,$00,$09,$07
>1040	00 c7 10 bd 41 be 00 0c			.byte	$00,$c7,$10,$bd,$41,$be,$00,$0c
>1048	08 00 c7 0e 37 15 0e bd			.byte	$08,$00,$c7,$0e,$37,$15,$0e,$bd
>1050	42 be 00 0f 09 00 c7 0f			.byte	$42,$be,$00,$0f,$09,$00,$c7,$0f
>1058	36 05 05 03 bd 41 bf 42			.byte	$36,$05,$05,$03,$bd,$41,$bf,$42
>1060	be 00 0d 0a 00 c7 12 39			.byte	$be,$00,$0d,$0a,$00,$c7,$12,$39
>1068	12 b8 42 bf 42 be 00 0b			.byte	$12,$b8,$42,$bf,$42,$be,$00,$0b
>1070	0b 00 c7 19 31 07 bc 42			.byte	$0b,$00,$c7,$19,$31,$07,$bc,$42
>1078	be 00 0d 0c 00 c7 14 37			.byte	$be,$00,$0d,$0c,$00,$c7,$14,$37
>1080	01 19 11 ba 41 be 00 0d			.byte	$01,$19,$11,$ba,$41,$be,$00,$0d
>1088	0d 00 c7 0b 38 01 14 10			.byte	$0d,$00,$c7,$0b,$38,$01,$14,$10
>1090	ba 42 be 00 11 0e 00 cf			.byte	$ba,$42,$be,$00,$11,$0e,$00,$cf
>1098	19 37 04 b9 84 44 78 fd			.byte	$19,$37,$04,$b9,$84,$44,$78,$fd
>10a0	05 38 37 35 00 0d 0f 00			.byte	$05,$38,$37,$35,$00,$0d,$0f,$00
>10a8	cf 0b 36 09 13 bb 84 4f			.byte	$cf,$0b,$36,$09,$13,$bb,$84,$4f
>10b0	4f 00 0c 10 00 cf 14 35			.byte	$4f,$00,$0c,$10,$00,$cf,$14,$35
>10b8	0e bb 84 4b 54 00 0e 11			.byte	$0e,$bb,$84,$4b,$54,$00,$0e,$11
>10c0	00 cf 19 31 07 06 17 bb			.byte	$00,$cf,$19,$31,$07,$06,$17,$bb
>10c8	84 49 4c 00 11 12 00 cf			.byte	$84,$49,$4c,$00,$11,$12,$00,$cf
>10d0	08 34 0d b9 84 8b 48 7d			.byte	$08,$34,$0d,$b9,$84,$8b,$48,$7d
>10d8	fd 04 32 35 00 10 13 00			.byte	$fd,$04,$32,$35,$00,$10,$13,$00
>10e0	cf 18 b9 84 48 7a fd 06			.byte	$cf,$18,$b9,$84,$48,$7a,$fd,$06
>10e8	30 36 32 35 00 0c 14 00			.byte	$30,$36,$32,$35,$00,$0c,$14,$00
>10f0	cf 05 35 0c bb 84 4e 4e			.byte	$cf,$05,$35,$0c,$bb,$84,$4e,$4e
>10f8	00 0c 15 00 cf 04 32 06			.byte	$00,$0c,$15,$00,$cf,$04,$32,$06
>1100	bb 84 42 75 00 0d 16 00			.byte	$bb,$84,$42,$75,$00,$0d,$16,$00
>1108	cf 01 38 19 bb 84 8b 42			.byte	$cf,$01,$38,$19,$bb,$84,$8b,$42
>1110	77 00 0d 17 00 cf 08 30			.byte	$77,$00,$0d,$17,$00,$cf,$08,$30
>1118	04 bb 84 8b 4b 60 00 11			.byte	$04,$bb,$84,$8b,$4b,$60,$00,$11
>1120	18 00 cf 02 38 03 0e b7			.byte	$18,$00,$cf,$02,$38,$03,$0e,$b7
>1128	84 fe 06 45 33 51 49 00			.byte	$84,$fe,$06,$45,$33,$51,$49,$00
>1130	12 19 00 cf 07 37 13 84			.byte	$12,$19,$00,$cf,$07,$37,$13,$84
>1138	8b 42 4c fd 06 35 36 32			.byte	$8b,$42,$4c,$fd,$06,$35,$36,$32
>1140	35 00 12 1a 00 cf 19 37			.byte	$35,$00,$12,$1a,$00,$cf,$19,$37
>1148	04 b9 84 48 5d fd 06 36			.byte	$04,$b9,$84,$48,$5d,$fd,$06,$36
>1150	38 37 35 00 13 1b 00 cf			.byte	$38,$37,$35,$00,$13,$1b,$00,$cf
>1158	02 33 19 03 17 84 8b 49			.byte	$02,$33,$19,$03,$17,$84,$8b,$49
>1160	70 fd 05 31 32 35 00 0e			.byte	$70,$fd,$05,$31,$32,$35,$00,$0e
>1168	1c 00 cf 19 31 07 bc 42			.byte	$1c,$00,$cf,$19,$31,$07,$bc,$42
>1170	be 84 46 4b 00 0c 1d 00			.byte	$be,$84,$46,$4b,$00,$0c,$1d,$00
>1178	cf 18 33 10 0d bb 84 56			.byte	$cf,$18,$33,$10,$0d,$bb,$84,$56
>1180	00 11 1e 00 cf 13 31 14			.byte	$00,$11,$1e,$00,$cf,$13,$31,$14
>1188	07 17 b9 84 6f fd 04 32			.byte	$07,$17,$b9,$84,$6f,$fd,$04,$32
>1190	35 00 11 1f 00 cf 06 32			.byte	$35,$00,$11,$1f,$00,$cf,$06,$32
>1198	14 11 b7 84 fe 06 58 31			.byte	$14,$11,$b7,$84,$fe,$06,$58,$31
>11a0	45 4d 00 12 20 00 cf 08			.byte	$45,$4d,$00,$12,$20,$00,$cf,$08
>11a8	38 18 b9 84 46 48 fd 06			.byte	$38,$18,$b9,$84,$46,$48,$fd,$06
>11b0	39 33 37 35 00 12 21 00			.byte	$39,$33,$37,$35,$00,$12,$21,$00
>11b8	cf 13 35 01 16 b7 84 fe			.byte	$cf,$13,$35,$01,$16,$b7,$84,$fe
>11c0	07 45 38 4c 57 4a 00 0f			.byte	$07,$45,$38,$4c,$57,$4a,$00,$0f
>11c8	22 00 cf 08 31 09 84 8b			.byte	$22,$00,$cf,$08,$31,$09,$84,$8b
>11d0	48 4f fd 03 30 00 11 23			.byte	$48,$4f,$fd,$03,$30,$00,$11,$23
>11d8	00 cf 12 39 12 b8 41 bf			.byte	$00,$cf,$12,$39,$12,$b8,$41,$bf
>11e0	40 be 84 fe 03 4e 00 10			.byte	$40,$be,$84,$fe,$03,$4e,$00,$10
>11e8	24 00 cf 01 34 1a 13 05			.byte	$24,$00,$cf,$01,$34,$1a,$13,$05
>11f0	b7 84 fe 04 45 39 00 11			.byte	$b7,$84,$fe,$04,$45,$39,$00,$11
>11f8	25 00 cf 09 36 18 08 07			.byte	$25,$00,$cf,$09,$36,$18,$08,$07
>1200	b7 84 fe 05 57 39 4c 00			.byte	$b7,$84,$fe,$05,$57,$39,$4c,$00
>1208	13 26 00 cf 1a 37 10 0d			.byte	$13,$26,$00,$cf,$1a,$37,$10,$0d
>1210	84 8b 41 7b fd 06 38 31			.byte	$84,$8b,$41,$7b,$fd,$06,$38,$31
>1218	32 35 00 0f 27 00 cf 14			.byte	$32,$35,$00,$0f,$27,$00,$cf,$14
>1220	34 03 0b 11 bb 84 8b 4d			.byte	$34,$03,$0b,$11,$bb,$84,$8b,$4d
>1228	69 00 19 28 00 cf 0f 36			.byte	$69,$00,$19,$28,$00,$cf,$0f,$36
>1230	05 05 03 bd 41 bf 42 be			.byte	$05,$05,$03,$bd,$41,$bf,$42,$be
>1238	84 8b 43 58 fd 06 30 36			.byte	$84,$8b,$43,$58,$fd,$06,$30,$36
>1240	32 35 00 0e 29 00 cf 0b			.byte	$32,$35,$00,$0e,$29,$00,$cf,$0b
>1248	36 09 13 bb 84 8b 49 6e			.byte	$36,$09,$13,$bb,$84,$8b,$49,$6e
>1250	00 14 2a 00 cf 02 39 13			.byte	$00,$14,$2a,$00,$cf,$02,$39,$13
>1258	09 16 b9 84 42 6f fd 06			.byte	$09,$16,$b9,$84,$42,$6f,$fd,$06
>1260	33 31 32 35 00 0b 2b 00			.byte	$33,$31,$32,$35,$00,$0b,$2b,$00
>1268	cf 12 bb 84 8b 46 6a 00			.byte	$cf,$12,$bb,$84,$8b,$46,$6a,$00
>1270	0d 2c 00 cf 14 35 0e bb			.byte	$0d,$2c,$00,$cf,$14,$35,$0e,$bb
>1278	84 8b 47 51 00 0f 2d 00			.byte	$84,$8b,$47,$51,$00,$0f,$2d,$00
>1280	cf 01 34 0e 0e 84 42 70			.byte	$cf,$01,$34,$0e,$0e,$84,$42,$70
>1288	fd 03 30 00 10 2e 00 cf			.byte	$fd,$03,$30,$00,$10,$2e,$00,$cf
>1290	09 39 10 0b b7 84 fe 05			.byte	$09,$39,$10,$0b,$b7,$84,$fe,$05
>1298	57 31 5a 00 10 2f 00 cf			.byte	$57,$31,$5a,$00,$10,$2f,$00,$cf
>12a0	08 31 09 84 41 78 fd 05			.byte	$08,$31,$09,$84,$41,$78,$fd,$05
>12a8	33 37 35 00 0f 30 00 cf			.byte	$33,$37,$35,$00,$0f,$30,$00,$cf
>12b0	03 84 45 75 fd 06 34 33			.byte	$03,$84,$45,$75,$fd,$06,$34,$33
>12b8	37 35 00 14 31 00 cf 0b			.byte	$37,$35,$00,$14,$31,$00,$cf,$0b
>12c0	38 01 14 10 ba 41 be 84			.byte	$38,$01,$14,$10,$ba,$41,$be,$84
>12c8	46 59 fd 04 37 35 00 0f			.byte	$46,$59,$fd,$04,$37,$35,$00,$0f
>12d0	32 00 cf 09 39 0a 10 19			.byte	$32,$00,$cf,$09,$39,$0a,$10,$19
>12d8	bb 84 8b 42 66 00 10 33			.byte	$bb,$84,$8b,$42,$66,$00,$10,$33
>12e0	00 cf 0a 84 8b 47 4d fd			.byte	$00,$cf,$0a,$84,$8b,$47,$4d,$fd
>12e8	06 31 38 37 35 00 0e 34			.byte	$06,$31,$38,$37,$35,$00,$0e,$34
>12f0	00 cf 18 33 10 0d bb 84			.byte	$00,$cf,$18,$33,$10,$0d,$bb,$84
>12f8	8b 44 50 00 13 35 00 cf			.byte	$8b,$44,$50,$00,$13,$35,$00,$cf
>1300	19 36 09 10 0e 84 41 74			.byte	$19,$36,$09,$10,$0e,$84,$41,$74
>1308	fd 06 38 31 32 35 00 12			.byte	$fd,$06,$38,$31,$32,$35,$00,$12
>1310	36 00 cf 02 38 03 0e b7			.byte	$36,$00,$cf,$02,$38,$03,$0e,$b7
>1318	84 fe 07 55 36 56 53 59			.byte	$84,$fe,$07,$55,$36,$56,$53,$59
>1320	00 13 37 00 cf 01 34 1a			.byte	$00,$13,$37,$00,$cf,$01,$34,$1a
>1328	13 05 b7 84 fe 07 54 35			.byte	$13,$05,$b7,$84,$fe,$07,$54,$35
>1330	43 53 4e 00 0e 38 00 cf			.byte	$43,$53,$4e,$00,$0e,$38,$00,$cf
>1338	13 35 01 16 b7 84 fe 03			.byte	$13,$35,$01,$16,$b7,$84,$fe,$03
>1340	4f 00 0e 39 00 cf 0b 37			.byte	$4f,$00,$0e,$39,$00,$cf,$0b,$37
>1348	07 1a 17 bb 84 48 73 00			.byte	$07,$1a,$17,$bb,$84,$48,$73,$00
>1350	12 3a 00 cf 0c 32 0b 03			.byte	$12,$3a,$00,$cf,$0c,$32,$0b,$03
>1358	84 46 71 fd 06 39 33 37			.byte	$84,$46,$71,$fd,$06,$39,$33,$37
>1360	35 00 0d 3b 00 cf 07 38			.byte	$35,$00,$0d,$3b,$00,$cf,$07,$38
>1368	03 b7 84 fe 03 5a 00 10			.byte	$03,$b7,$84,$fe,$03,$5a,$00,$10
>1370	3c 00 cf 17 b9 84 43 52			.byte	$3c,$00,$cf,$17,$b9,$84,$43,$52
>1378	fd 06 31 38 37 35 00 11			.byte	$fd,$06,$31,$38,$37,$35,$00,$11
>1380	3d 00 cf 08 b9 84 8b 47			.byte	$3d,$00,$cf,$08,$b9,$84,$8b,$47
>1388	5a fd 06 30 36 32 35 00			.byte	$5a,$fd,$06,$30,$36,$32,$35,$00
>1390	13 3e 00 cf 02 33 19 03			.byte	$13,$3e,$00,$cf,$02,$33,$19,$03
>1398	17 84 43 7c fd 06 36 38			.byte	$17,$84,$43,$7c,$fd,$06,$36,$38
>13a0	37 35 00 11 3f 00 cf 01			.byte	$37,$35,$00,$11,$3f,$00,$cf,$01
>13a8	32 17 84 8b 49 6a fd 05			.byte	$32,$17,$84,$8b,$49,$6a,$fd,$05
>13b0	36 32 35 00 0d 40 00 cf			.byte	$36,$32,$35,$00,$0d,$40,$00,$cf
>13b8	0a 38 0a 06 bb 84 41 40			.byte	$0a,$38,$0a,$06,$bb,$84,$41,$40
>13c0	00 12 41 00 cf 18 35 0f			.byte	$00,$12,$41,$00,$cf,$18,$35,$0f
>13c8	0c 84 8b 49 6c fd 05 31			.byte	$0c,$84,$8b,$49,$6c,$fd,$05,$31
>13d0	32 35 00 0e 42 00 cf 03			.byte	$32,$35,$00,$0e,$42,$00,$cf,$03
>13d8	84 8b 48 42 fd 04 37 35			.byte	$84,$8b,$48,$42,$fd,$04,$37,$35
>13e0	00 11 43 00 cf 09 39 10			.byte	$00,$11,$43,$00,$cf,$09,$39,$10
>13e8	0b b7 84 fe 06 49 32 57			.byte	$0b,$b7,$84,$fe,$06,$49,$32,$57
>13f0	49 00 11 44 00 cf 08 b9			.byte	$49,$00,$11,$44,$00,$cf,$08,$b9
>13f8	84 8b 49 41 fd 06 31 38			.byte	$84,$8b,$49,$41,$fd,$06,$31,$38
>1400	37 35 00 11 45 00 cf 1a			.byte	$37,$35,$00,$11,$45,$00,$cf,$1a
>1408	37 10 0d 84 8b 46 4e fd			.byte	$37,$10,$0d,$84,$8b,$46,$4e,$fd
>1410	04 32 35 00 0b 46 00 cf			.byte	$04,$32,$35,$00,$0b,$46,$00,$cf
>1418	0e bb 84 8b 45 5b 00 10			.byte	$0e,$bb,$84,$8b,$45,$5b,$00,$10
>1420	47 00 cf 14 38 08 b7 84			.byte	$47,$00,$cf,$14,$38,$08,$b7,$84
>1428	fe 06 54 39 4b 4c 00 0b			.byte	$fe,$06,$54,$39,$4b,$4c,$00,$0b
>1430	48 00 cf 12 bb 84 8b 45			.byte	$48,$00,$cf,$12,$bb,$84,$8b,$45
>1438	4c 00 0e 49 00 cf 0b 30			.byte	$4c,$00,$0e,$49,$00,$cf,$0b,$30
>1440	0f 08 15 b7 84 fe 02 00			.byte	$0f,$08,$15,$b7,$84,$fe,$02,$00
>1448	13 4a 00 cf 18 35 0f 0c			.byte	$13,$4a,$00,$cf,$18,$35,$0f,$0c
>1450	84 8b 42 41 fd 06 34 33			.byte	$84,$8b,$42,$41,$fd,$06,$34,$33
>1458	37 35 00 0f 4b 00 cf 1a			.byte	$37,$35,$00,$0f,$4b,$00,$cf,$1a
>1460	38 11 14 14 b7 84 fe 03			.byte	$38,$11,$14,$14,$b7,$84,$fe,$03
>1468	43 00 12 4c 00 cf 19 36			.byte	$43,$00,$12,$4c,$00,$cf,$19,$36
>1470	0b 14 17 b7 84 fe 06 52			.byte	$0b,$14,$17,$b7,$84,$fe,$06,$52
>1478	36 54 45 00 0d 4d 00 cf			.byte	$36,$54,$45,$00,$0d,$4d,$00,$cf
>1480	14 35 0e bb 84 8b 48 4e			.byte	$14,$35,$0e,$bb,$84,$8b,$48,$4e
>1488	00 0e 4e 00 cf 09 36 18			.byte	$00,$0e,$4e,$00,$cf,$09,$36,$18
>1490	08 07 b7 84 fe 02 00 10			.byte	$08,$07,$b7,$84,$fe,$02,$00,$10
>1498	4f 00 cf 0d 37 05 b9 84			.byte	$4f,$00,$cf,$0d,$37,$05,$b9,$84
>14a0	8b 43 5b fd 03 35 00 12			.byte	$8b,$43,$5b,$fd,$03,$35,$00,$12
>14a8	50 00 cf 08 35 04 0a b7			.byte	$50,$00,$cf,$08,$35,$04,$0a,$b7
>14b0	84 fe 07 58 34 4b 58 53			.byte	$84,$fe,$07,$58,$34,$4b,$58,$53
>14b8	00 15 51 00 cf 04 32 0f			.byte	$00,$15,$51,$00,$cf,$04,$32,$0f
>14c0	08 0e b9 84 8b 42 70 fd			.byte	$08,$0e,$b9,$84,$8b,$42,$70,$fd
>14c8	06 33 31 32 35 00 12 52			.byte	$06,$33,$31,$32,$35,$00,$12,$52
>14d0	00 cf 04 32 0f 08 0e b9			.byte	$00,$cf,$04,$32,$0f,$08,$0e,$b9
>14d8	84 48 4f fd 04 32 35 00			.byte	$84,$48,$4f,$fd,$04,$32,$35,$00
>14e0	0f 53 00 cf 10 32 01 01			.byte	$0f,$53,$00,$cf,$10,$32,$01,$01
>14e8	03 bb 84 8b 45 6c 00 12			.byte	$03,$bb,$84,$8b,$45,$6c,$00,$12
>14f0	54 00 cf 19 37 04 b9 84			.byte	$54,$00,$cf,$19,$37,$04,$b9,$84
>14f8	46 4c fd 06 36 38 37 35			.byte	$46,$4c,$fd,$06,$36,$38,$37,$35
>1500	00 0e 55 00 cf 08 b9 84			.byte	$00,$0e,$55,$00,$cf,$08,$b9,$84
>1508	8b 45 62 fd 03 35 00 12			.byte	$8b,$45,$62,$fd,$03,$35,$00,$12
>1510	56 00 cf 08 34 0d b9 84			.byte	$56,$00,$cf,$08,$34,$0d,$b9,$84
>1518	46 5a fd 06 33 31 32 35			.byte	$46,$5a,$fd,$06,$33,$31,$32,$35
>1520	00 0e 57 00 cf 11 34 17			.byte	$00,$0e,$57,$00,$cf,$11,$34,$17
>1528	17 bb 84 8b 42 59 00 0f			.byte	$17,$bb,$84,$8b,$42,$59,$00,$0f
>1530	58 00 cf 09 36 18 08 07			.byte	$58,$00,$cf,$09,$36,$18,$08,$07
>1538	b7 84 fe 03 50 00 0f 59			.byte	$b7,$84,$fe,$03,$50,$00,$0f,$59
>1540	00 cf 10 35 13 b7 84 fe			.byte	$00,$cf,$10,$35,$13,$b7,$84,$fe
>1548	05 48 38 4b 00 10 5a 00			.byte	$05,$48,$38,$4b,$00,$10,$5a,$00
>1550	cf 17 32 05 13 19 84 48			.byte	$cf,$17,$32,$05,$13,$19,$84,$48
>1558	58 fd 03 35 00 16 5b 00			.byte	$58,$fd,$03,$35,$00,$16,$5b,$00
>1560	cf 0e 37 15 0e bd 42 be			.byte	$cf,$0e,$37,$15,$0e,$bd,$42,$be
>1568	84 8b 45 58 fd 06 33 31			.byte	$84,$8b,$45,$58,$fd,$06,$33,$31
>1570	32 35 00 14 5c 00 cf 0b			.byte	$32,$35,$00,$14,$5c,$00,$cf,$0b
>1578	32 15 07 ba 41 be 84 5e			.byte	$32,$15,$07,$ba,$41,$be,$84,$5e
>1580	fd 06 36 38 37 35 00 0d			.byte	$fd,$06,$36,$38,$37,$35,$00,$0d
>1588	5d 00 cf 18 33 1a bb 84			.byte	$5d,$00,$cf,$18,$33,$1a,$bb,$84
>1590	8b 4a 6c 00 0f 5e 00 cf			.byte	$8b,$4a,$6c,$00,$0f,$5e,$00,$cf
>1598	0b 37 07 1a 17 bb 84 8b			.byte	$0b,$37,$07,$1a,$17,$bb,$84,$8b
>15a0	4c 74 00 11 5f 00 cf 01			.byte	$4c,$74,$00,$11,$5f,$00,$cf,$01
>15a8	32 17 84 8b 59 fd 06 31			.byte	$32,$17,$84,$8b,$59,$fd,$06,$31
>15b0	38 37 35 00 13 60 00 cf			.byte	$38,$37,$35,$00,$13,$60,$00,$cf
>15b8	04 37 0c 12 b9 84 8b 48			.byte	$04,$37,$0c,$12,$b9,$84,$8b,$48
>15c0	5d fd 05 38 37 35 00 0e			.byte	$5d,$fd,$05,$38,$37,$35,$00,$0e
>15c8	61 00 cf 09 39 0a 10 19			.byte	$61,$00,$cf,$09,$39,$0a,$10,$19
>15d0	bb 84 4b 52 00 0a 62 00			.byte	$bb,$84,$4b,$52,$00,$0a,$62,$00
>15d8	cf 02 bb 84 4e 7c 00 0e			.byte	$cf,$02,$bb,$84,$4e,$7c,$00,$0e
>15e0	63 00 cf 08 b9 84 48 fd			.byte	$63,$00,$cf,$08,$b9,$84,$48,$fd
>15e8	05 33 37 35 00 0f 64 00			.byte	$05,$33,$37,$35,$00,$0f,$64,$00
>15f0	cf 09 39 0a 10 19 bb 84			.byte	$cf,$09,$39,$0a,$10,$19,$bb,$84
>15f8	8b 43 7a 00 0f 65 00 cf			.byte	$8b,$43,$7a,$00,$0f,$65,$00,$cf
>1600	13 b7 84 fe 07 55 30 58			.byte	$13,$b7,$84,$fe,$07,$55,$30,$58
>1608	4b 59 00 10 66 00 cf 17			.byte	$4b,$59,$00,$10,$66,$00,$cf,$17
>1610	b9 84 44 50 fd 06 36 38			.byte	$b9,$84,$44,$50,$fd,$06,$36,$38
>1618	37 35 00 0e 67 00 cf 13			.byte	$37,$35,$00,$0e,$67,$00,$cf,$13
>1620	31 01 b7 84 fe 04 5a 33			.byte	$31,$01,$b7,$84,$fe,$04,$5a,$33
>1628	00 0e 68 00 cf 11 30 05			.byte	$00,$0e,$68,$00,$cf,$11,$30,$05
>1630	18 bb 84 8b 4e 5f 00 13			.byte	$18,$bb,$84,$8b,$4e,$5f,$00,$13
>1638	69 00 cf 17 34 01 0b 06			.byte	$69,$00,$cf,$17,$34,$01,$0b,$06
>1640	b7 84 fe 07 47 36 49 4b			.byte	$b7,$84,$fe,$07,$47,$36,$49,$4b
>1648	54 00 12 6a 00 cf 07 36			.byte	$54,$00,$12,$6a,$00,$cf,$07,$36
>1650	02 10 1a b7 84 fe 06 4b			.byte	$02,$10,$1a,$b7,$84,$fe,$06,$4b
>1658	32 49 42 00 0e 6b 00 cf			.byte	$32,$49,$42,$00,$0e,$6b,$00,$cf
>1660	19 b7 84 fe 06 50 35 50			.byte	$19,$b7,$84,$fe,$06,$50,$35,$50
>1668	41 00 12 6c 00 cf 08 31			.byte	$41,$00,$12,$6c,$00,$cf,$08,$31
>1670	09 84 8b 46 5a fd 06 39			.byte	$09,$84,$8b,$46,$5a,$fd,$06,$39
>1678	33 37 35 00 0a 6d 00 cf			.byte	$33,$37,$35,$00,$0a,$6d,$00,$cf
>1680	02 bb 84 4e 5e 00 0e 6e			.byte	$02,$bb,$84,$4e,$5e,$00,$0e,$6e
>1688	00 cf 08 35 04 0a b7 84			.byte	$00,$cf,$08,$35,$04,$0a,$b7,$84
>1690	fe 03 43 00 0f 6f 00 cf			.byte	$fe,$03,$43,$00,$0f,$6f,$00,$cf
>1698	10 32 01 01 03 bb 84 8b			.byte	$10,$32,$01,$01,$03,$bb,$84,$8b
>16a0	41 56 00 15 70 00 cf 19			.byte	$41,$56,$00,$15,$70,$00,$cf,$19
>16a8	38 08 08 12 bd 41 be 84			.byte	$38,$08,$08,$12,$bd,$41,$be,$84
>16b0	8b 42 4b fd 04 32 35 00			.byte	$8b,$42,$4b,$fd,$04,$32,$35,$00
>16b8	10 71 00 cf 02 38 03 0e			.byte	$10,$71,$00,$cf,$02,$38,$03,$0e
>16c0	b7 84 fe 05 47 32 47 00			.byte	$b7,$84,$fe,$05,$47,$32,$47,$00
>16c8	10 72 00 cf 15 30 0a 0f			.byte	$10,$72,$00,$cf,$15,$30,$0a,$0f
>16d0	b9 84 46 7d fd 03 30 00			.byte	$b9,$84,$46,$7d,$fd,$03,$30,$00
>16d8	12 73 00 cf 19 37 04 b9			.byte	$12,$73,$00,$cf,$19,$37,$04,$b9
>16e0	84 8b 41 60 fd 05 33 37			.byte	$84,$8b,$41,$60,$fd,$05,$33,$37
>16e8	35 00 10 74 00 cf 18 b9			.byte	$35,$00,$10,$74,$00,$cf,$18,$b9
>16f0	84 8b 42 74 fd 05 36 32			.byte	$84,$8b,$42,$74,$fd,$05,$36,$32
>16f8	35 00 0f 75 00 cf 09 39			.byte	$35,$00,$0f,$75,$00,$cf,$09,$39
>1700	10 0b b7 84 fe 04 53 33			.byte	$10,$0b,$b7,$84,$fe,$04,$53,$33
>1708	00 13 76 00 cf 19 36 0b			.byte	$00,$13,$76,$00,$cf,$19,$36,$0b
>1710	14 17 b7 84 fe 07 41 34			.byte	$14,$17,$b7,$84,$fe,$07,$41,$34
>1718	52 4b 46 00 0d 77 00 cf			.byte	$52,$4b,$46,$00,$0d,$77,$00,$cf
>1720	19 31 07 bc 42 be 84 40			.byte	$19,$31,$07,$bc,$42,$be,$84,$40
>1728	00 0e 78 00 cf 14 34 03			.byte	$00,$0e,$78,$00,$cf,$14,$34,$03
>1730	0b 11 bb 84 4c 60 00 16			.byte	$0b,$11,$bb,$84,$4c,$60,$00,$16
>1738	79 00 cf 0e 37 15 0e bd			.byte	$79,$00,$cf,$0e,$37,$15,$0e,$bd
>1740	42 be 84 8b 46 62 fd 06			.byte	$42,$be,$84,$8b,$46,$62,$fd,$06
>1748	38 31 32 35 00 0d 7a 00			.byte	$38,$31,$32,$35,$00,$0d,$7a,$00
>1750	cf 0b 36 09 13 bb 84 43			.byte	$cf,$0b,$36,$09,$13,$bb,$84,$43
>1758	6a 00 11 7b 00 cf 06 32			.byte	$6a,$00,$11,$7b,$00,$cf,$06,$32
>1760	19 0f b7 84 fe 06 46 36			.byte	$19,$0f,$b7,$84,$fe,$06,$46,$36
>1768	4d 41 00 0c 7c 00 cf 10			.byte	$4d,$41,$00,$0c,$7c,$00,$cf,$10
>1770	35 13 b7 84 fe 02 00 0f			.byte	$35,$13,$b7,$84,$fe,$02,$00,$0f
>1778	7d 00 cf 0b 37 07 1a 17			.byte	$7d,$00,$cf,$0b,$37,$07,$1a,$17
>1780	bb 84 8b 4f 59 00 12 7e			.byte	$bb,$84,$8b,$4f,$59,$00,$12,$7e
>1788	00 cf 07 32 0a 14 b7 84			.byte	$00,$cf,$07,$32,$0a,$14,$b7,$84
>1790	fe 07 59 31 48 53 48 00			.byte	$fe,$07,$59,$31,$48,$53,$48,$00
>1798	0a 7f 00 cf 01 bb 84 49			.byte	$0a,$7f,$00,$cf,$01,$bb,$84,$49
>17a0	68 00 13 80 00 cf 1a 37			.byte	$68,$00,$13,$80,$00,$cf,$1a,$37
>17a8	10 0d 84 8b 49 66 fd 06			.byte	$10,$0d,$84,$8b,$49,$66,$fd,$06
>17b0	34 33 37 35 00 0e 81 00			.byte	$34,$33,$37,$35,$00,$0e,$81,$00
>17b8	cf 07 37 05 0e 12 bb 84			.byte	$cf,$07,$37,$05,$0e,$12,$bb,$84
>17c0	41 43 00 0c 82 00 cf 18			.byte	$41,$43,$00,$0c,$82,$00,$cf,$18
>17c8	33 1a bb 84 4a 77 00 11			.byte	$33,$1a,$bb,$84,$4a,$77,$00,$11
>17d0	83 00 cf 10 37 02 03 b7			.byte	$83,$00,$cf,$10,$37,$02,$03,$b7
>17d8	84 fe 06 50 35 4a 52 00			.byte	$84,$fe,$06,$50,$35,$4a,$52,$00
>17e0	12 84 00 cf 19 36 09 10			.byte	$12,$84,$00,$cf,$19,$36,$09,$10
>17e8	0e 84 8b 65 fd 05 36 32			.byte	$0e,$84,$8b,$65,$fd,$05,$36,$32
>17f0	35 00 0f 85 00 cf 14 34			.byte	$35,$00,$0f,$85,$00,$cf,$14,$34
>17f8	03 0b 11 bb 84 8b 44 74			.byte	$03,$0b,$11,$bb,$84,$8b,$44,$74
>1800	00 14 86 00 cf 0a 36 0b			.byte	$00,$14,$86,$00,$cf,$0a,$36,$0b
>1808	0f b9 84 8b 48 71 fd 06			.byte	$0f,$b9,$84,$8b,$48,$71,$fd,$06
>1810	38 31 32 35 00 13 87 00			.byte	$38,$31,$32,$35,$00,$13,$87,$00
>1818	cf 19 36 09 10 0e 84 8b			.byte	$cf,$19,$36,$09,$10,$0e,$84,$8b
>1820	45 4d fd 05 33 37 35 00			.byte	$45,$4d,$fd,$05,$33,$37,$35,$00
>1828	0e 88 00 cf 19 31 07 06			.byte	$0e,$88,$00,$cf,$19,$31,$07,$06
>1830	17 bb 84 42 55 00 12 89			.byte	$17,$bb,$84,$42,$55,$00,$12,$89
>1838	00 cf 07 33 16 0b 09 84			.byte	$00,$cf,$07,$33,$16,$0b,$09,$84
>1840	8b 43 6c fd 04 37 35 00			.byte	$8b,$43,$6c,$fd,$04,$37,$35,$00
>1848	15 8a 00 cf 0b 32 15 07			.byte	$15,$8a,$00,$cf,$0b,$32,$15,$07
>1850	ba 40 be 84 8b 43 5d fd			.byte	$ba,$40,$be,$84,$8b,$43,$5d,$fd
>1858	05 36 32 35 00 13 8b 00			.byte	$05,$36,$32,$35,$00,$13,$8b,$00
>1860	cf 07 33 16 0b 09 84 8b			.byte	$cf,$07,$33,$16,$0b,$09,$84,$8b
>1868	45 4c fd 05 36 32 35 00			.byte	$45,$4c,$fd,$05,$36,$32,$35,$00
>1870	11 8c 00 cf 02 38 03 0e			.byte	$11,$8c,$00,$cf,$02,$38,$03,$0e
>1878	b7 84 fe 06 54 31 46 4f			.byte	$b7,$84,$fe,$06,$54,$31,$46,$4f
>1880	00 0a 8d 00 cf 16 bb 84			.byte	$00,$0a,$8d,$00,$cf,$16,$bb,$84
>1888	47 7e 00 14 8e 00 cf 0b			.byte	$47,$7e,$00,$14,$8e,$00,$cf,$0b
>1890	38 01 14 10 ba 41 be 84			.byte	$38,$01,$14,$10,$ba,$41,$be,$84
>1898	43 43 fd 04 32 35 00 13			.byte	$43,$43,$fd,$04,$32,$35,$00,$13
>18a0	8f 00 cf 0a 36 0b 0f b9			.byte	$8f,$00,$cf,$0a,$36,$0b,$0f,$b9
>18a8	84 42 5f fd 06 33 31 32			.byte	$84,$42,$5f,$fd,$06,$33,$31,$32
>18b0	35 00 0e 90 00 cf 07 37			.byte	$35,$00,$0e,$90,$00,$cf,$07,$37
>18b8	05 0e 12 bb 84 4c 5d 00			.byte	$05,$0e,$12,$bb,$84,$4c,$5d,$00
>18c0	0e 91 00 cf 0e 34 0d 09			.byte	$0e,$91,$00,$cf,$0e,$34,$0d,$09
>18c8	bb 84 8b 41 44 00 0e 92			.byte	$bb,$84,$8b,$41,$44,$00,$0e,$92
>18d0	00 cf 18 b9 84 8b 42 7e			.byte	$00,$cf,$18,$b9,$84,$8b,$42,$7e
>18d8	fd 03 35 00 11 93 00 cf			.byte	$fd,$03,$35,$00,$11,$93,$00,$cf
>18e0	01 34 1a 13 05 b7 84 fe			.byte	$01,$34,$1a,$13,$05,$b7,$84,$fe
>18e8	05 53 30 45 00 0c 94 00			.byte	$05,$53,$30,$45,$00,$0c,$94,$00
>18f0	cf 19 b7 84 fe 04 4a 35			.byte	$cf,$19,$b7,$84,$fe,$04,$4a,$35
>18f8	00 12 95 00 cf 0e 30 02			.byte	$00,$12,$95,$00,$cf,$0e,$30,$02
>1900	16 84 47 54 fd 06 31 38			.byte	$16,$84,$47,$54,$fd,$06,$31,$38
>1908	37 35 00 0d 96 00 cf 18			.byte	$37,$35,$00,$0d,$96,$00,$cf,$18
>1910	33 10 0d bb 84 45 5c 00			.byte	$33,$10,$0d,$bb,$84,$45,$5c,$00
>1918	11 97 00 cf 13 31 01 b7			.byte	$11,$97,$00,$cf,$13,$31,$01,$b7
>1920	84 fe 07 52 35 45 49 41			.byte	$84,$fe,$07,$52,$35,$45,$49,$41
>1928	00 11 98 00 cf 0f 35 16			.byte	$00,$11,$98,$00,$cf,$0f,$35,$16
>1930	0c b7 84 fe 06 4d 32 42			.byte	$0c,$b7,$84,$fe,$06,$4d,$32,$42
>1938	52 00 0e 99 00 cf 13 31			.byte	$52,$00,$0e,$99,$00,$cf,$13,$31
>1940	01 b7 84 fe 04 53 38 00			.byte	$01,$b7,$84,$fe,$04,$53,$38,$00
>1948	11 9a 00 cf 18 35 0f 0c			.byte	$11,$9a,$00,$cf,$18,$35,$0f,$0c
>1950	84 7a fd 06 31 38 37 35			.byte	$84,$7a,$fd,$06,$31,$38,$37,$35
>1958	00 0a 9b 00 cf 01 bb 84			.byte	$00,$0a,$9b,$00,$cf,$01,$bb,$84
>1960	4c 50 00 13 9c 00 cf 02			.byte	$4c,$50,$00,$13,$9c,$00,$cf,$02
>1968	33 19 03 17 84 49 63 fd			.byte	$33,$19,$03,$17,$84,$49,$63,$fd
>1970	06 36 38 37 35 00 0e 9d			.byte	$06,$36,$38,$37,$35,$00,$0e,$9d
>1978	00 cf 0c 39 18 84 44 49			.byte	$00,$cf,$0c,$39,$18,$84,$44,$49
>1980	fd 03 30 00 0d 9e 00 cf			.byte	$fd,$03,$30,$00,$0d,$9e,$00,$cf
>1988	0b 36 09 13 bb 84 4d 7f			.byte	$0b,$36,$09,$13,$bb,$84,$4d,$7f
>1990	00 11 9f 00 cf 17 34 01			.byte	$00,$11,$9f,$00,$cf,$17,$34,$01
>1998	0b 06 b7 84 fe 05 4a 33			.byte	$0b,$06,$b7,$84,$fe,$05,$4a,$33
>19a0	55 00 0f a0 00 cf 12 38			.byte	$55,$00,$0f,$a0,$00,$cf,$12,$38
>19a8	18 13 0c bb 84 8b 4e 77			.byte	$18,$13,$0c,$bb,$84,$8b,$4e,$77
>19b0	00 13 a1 00 cf 15 30 0a			.byte	$00,$13,$a1,$00,$cf,$15,$30,$0a
>19b8	0f b9 84 43 45 fd 06 35			.byte	$0f,$b9,$84,$43,$45,$fd,$06,$35
>19c0	36 32 35 00 13 a2 00 cf			.byte	$36,$32,$35,$00,$13,$a2,$00,$cf
>19c8	01 34 1a 13 05 b7 84 fe			.byte	$01,$34,$1a,$13,$05,$b7,$84,$fe
>19d0	07 41 35 48 4d 47 00 16			.byte	$07,$41,$35,$48,$4d,$47,$00,$16
>19d8	a3 00 cf 0b 38 01 14 10			.byte	$a3,$00,$cf,$0b,$38,$01,$14,$10
>19e0	ba 42 be 84 49 67 fd 06			.byte	$ba,$42,$be,$84,$49,$67,$fd,$06
>19e8	30 36 32 35 00 10 a4 00			.byte	$30,$36,$32,$35,$00,$10,$a4,$00
>19f0	cf 03 84 8b 46 45 fd 06			.byte	$cf,$03,$84,$8b,$46,$45,$fd,$06
>19f8	36 38 37 35 00 11 a5 00			.byte	$36,$38,$37,$35,$00,$11,$a5,$00
>1a00	cf 02 39 13 09 16 b9 84			.byte	$cf,$02,$39,$13,$09,$16,$b9,$84
>1a08	45 44 fd 03 35 00 0f a6			.byte	$45,$44,$fd,$03,$35,$00,$0f,$a6
>1a10	00 cf 0b 30 0f 08 15 b7			.byte	$00,$cf,$0b,$30,$0f,$08,$15,$b7
>1a18	84 fe 03 4f 00 0f a7 00			.byte	$84,$fe,$03,$4f,$00,$0f,$a7,$00
>1a20	cf 19 31 07 06 17 bb 84			.byte	$cf,$19,$31,$07,$06,$17,$bb,$84
>1a28	8b 4f 4e 00 0e a8 00 cf			.byte	$8b,$4f,$4e,$00,$0e,$a8,$00,$cf
>1a30	18 33 10 0d bb 84 8b 46			.byte	$18,$33,$10,$0d,$bb,$84,$8b,$46
>1a38	61 00 10 a9 00 cf 18 37			.byte	$61,$00,$10,$a9,$00,$cf,$18,$37
>1a40	07 10 b7 84 fe 05 59 31			.byte	$07,$10,$b7,$84,$fe,$05,$59,$31
>1a48	48 00 17 aa 00 cf 0b 38			.byte	$48,$00,$17,$aa,$00,$cf,$0b,$38
>1a50	01 14 10 ba 40 be 84 8b			.byte	$01,$14,$10,$ba,$40,$be,$84,$8b
>1a58	45 64 fd 06 36 38 37 35			.byte	$45,$64,$fd,$06,$36,$38,$37,$35
>1a60	00 10 ab 00 cf 17 34 01			.byte	$00,$10,$ab,$00,$cf,$17,$34,$01
>1a68	0b 06 b7 84 fe 04 54 35			.byte	$0b,$06,$b7,$84,$fe,$04,$54,$35
>1a70	00 11 ac 00 cf 15 34 0e			.byte	$00,$11,$ac,$00,$cf,$15,$34,$0e
>1a78	b7 84 fe 07 59 35 4c 52			.byte	$b7,$84,$fe,$07,$59,$35,$4c,$52
>1a80	47 00 0f ad 00 cf 01 32			.byte	$47,$00,$0f,$ad,$00,$cf,$01,$32
>1a88	17 84 8b 43 fd 04 37 35			.byte	$17,$84,$8b,$43,$fd,$04,$37,$35
>1a90	00 12 ae 00 cf 08 35 04			.byte	$00,$12,$ae,$00,$cf,$08,$35,$04
>1a98	0a b7 84 fe 07 58 33 48			.byte	$0a,$b7,$84,$fe,$07,$58,$33,$48
>1aa0	56 44 00 11 af 00 cf 17			.byte	$56,$44,$00,$11,$af,$00,$cf,$17
>1aa8	35 03 19 17 b9 84 43 63			.byte	$35,$03,$19,$17,$b9,$84,$43,$63
>1ab0	fd 03 30 00 0f b0 00 cf			.byte	$fd,$03,$30,$00,$0f,$b0,$00,$cf
>1ab8	15 b7 84 fe 07 4e 37 4a			.byte	$15,$b7,$84,$fe,$07,$4e,$37,$4a
>1ac0	4d 42 00 11 b1 00 cf 17			.byte	$4d,$42,$00,$11,$b1,$00,$cf,$17
>1ac8	34 01 0b 06 b7 84 fe 05			.byte	$34,$01,$0b,$06,$b7,$84,$fe,$05
>1ad0	51 32 4a 00 0f b2 00 cf			.byte	$51,$32,$4a,$00,$0f,$b2,$00,$cf
>1ad8	07 37 05 0e 12 bb 84 8b			.byte	$07,$37,$05,$0e,$12,$bb,$84,$8b
>1ae0	47 40 00 11 b3 00 cf 17			.byte	$47,$40,$00,$11,$b3,$00,$cf,$17
>1ae8	b9 84 8b 41 5d fd 06 35			.byte	$b9,$84,$8b,$41,$5d,$fd,$06,$35
>1af0	36 32 35 00 14 b4 00 cf			.byte	$36,$32,$35,$00,$14,$b4,$00,$cf
>1af8	19 38 08 08 12 bd 41 be			.byte	$19,$38,$08,$08,$12,$bd,$41,$be
>1b00	84 8b 49 63 fd 03 35 00			.byte	$84,$8b,$49,$63,$fd,$03,$35,$00
>1b08	11 b5 00 cf 1a 35 10 0f			.byte	$11,$b5,$00,$cf,$1a,$35,$10,$0f
>1b10	84 4e fd 06 35 36 32 35			.byte	$84,$4e,$fd,$06,$35,$36,$32,$35
>1b18	00 0b b6 00 cf 12 bb 84			.byte	$00,$0b,$b6,$00,$cf,$12,$bb,$84
>1b20	8b 4f 57 00 10 b7 00 cf			.byte	$8b,$4f,$57,$00,$10,$b7,$00,$cf
>1b28	03 84 8b 41 71 fd 06 33			.byte	$03,$84,$8b,$41,$71,$fd,$06,$33
>1b30	31 32 35 00 12 b8 00 cf			.byte	$31,$32,$35,$00,$12,$b8,$00,$cf
>1b38	08 31 09 84 8b 46 45 fd			.byte	$08,$31,$09,$84,$8b,$46,$45,$fd
>1b40	06 30 36 32 35 00 12 b9			.byte	$06,$30,$36,$32,$35,$00,$12,$b9
>1b48	00 cf 13 31 14 07 17 b9			.byte	$00,$cf,$13,$31,$14,$07,$17,$b9
>1b50	84 47 65 fd 04 37 35 00			.byte	$84,$47,$65,$fd,$04,$37,$35,$00
>1b58	0c ba 00 cf 04 35 07 bb			.byte	$0c,$ba,$00,$cf,$04,$35,$07,$bb
>1b60	84 47 6d 00 11 bb 00 cf			.byte	$84,$47,$6d,$00,$11,$bb,$00,$cf
>1b68	08 31 09 84 46 78 fd 06			.byte	$08,$31,$09,$84,$46,$78,$fd,$06
>1b70	34 33 37 35 00 13 bc 00			.byte	$34,$33,$37,$35,$00,$13,$bc,$00
>1b78	cf 0e 30 02 16 84 8b 44			.byte	$cf,$0e,$30,$02,$16,$84,$8b,$44
>1b80	5b fd 06 31 38 37 35 00			.byte	$5b,$fd,$06,$31,$38,$37,$35,$00
>1b88	12 bd 00 cf 19 37 04 b9			.byte	$12,$bd,$00,$cf,$19,$37,$04,$b9
>1b90	84 8b 42 55 fd 05 36 32			.byte	$84,$8b,$42,$55,$fd,$05,$36,$32
>1b98	35 00 0c be 00 cf 14 35			.byte	$35,$00,$0c,$be,$00,$cf,$14,$35
>1ba0	0e bb 84 8b 74 00 0e bf			.byte	$0e,$bb,$84,$8b,$74,$00,$0e,$bf
>1ba8	00 cf 0b 36 09 13 bb 84			.byte	$00,$cf,$0b,$36,$09,$13,$bb,$84
>1bb0	8b 4a 44 00 0d c0 00 cf			.byte	$8b,$4a,$44,$00,$0d,$c0,$00,$cf
>1bb8	0e 34 0d 09 bb 84 4b 72			.byte	$0e,$34,$0d,$09,$bb,$84,$4b,$72
>1bc0	00 13 c1 00 cf 08 38 18			.byte	$00,$13,$c1,$00,$cf,$08,$38,$18
>1bc8	b9 84 8b 41 51 fd 06 38			.byte	$b9,$84,$8b,$41,$51,$fd,$06,$38
>1bd0	31 32 35 00 10 c2 00 cf			.byte	$31,$32,$35,$00,$10,$c2,$00,$cf
>1bd8	06 32 14 11 b7 84 fe 05			.byte	$06,$32,$14,$11,$b7,$84,$fe,$05
>1be0	52 38 59 00 12 c3 00 cf			.byte	$52,$38,$59,$00,$12,$c3,$00,$cf
>1be8	07 32 0a 14 b7 84 fe 07			.byte	$07,$32,$0a,$14,$b7,$84,$fe,$07
>1bf0	46 32 50 5a 59 00 13 c4			.byte	$46,$32,$50,$5a,$59,$00,$13,$c4
>1bf8	00 cf 12 36 15 07 b9 84			.byte	$00,$cf,$12,$36,$15,$07,$b9,$84
>1c00	41 58 fd 06 31 38 37 35			.byte	$41,$58,$fd,$06,$31,$38,$37,$35
>1c08	00 11 c5 00 cf 06 32 19			.byte	$00,$11,$c5,$00,$cf,$06,$32,$19
>1c10	0f b7 84 fe 06 47 30 48			.byte	$0f,$b7,$84,$fe,$06,$47,$30,$48
>1c18	42 00 16 c6 00 cf 14 37			.byte	$42,$00,$16,$c6,$00,$cf,$14,$37
>1c20	01 19 11 ba 40 be 84 42			.byte	$01,$19,$11,$ba,$40,$be,$84,$42
>1c28	56 fd 06 38 31 32 35 00			.byte	$56,$fd,$06,$38,$31,$32,$35,$00
>1c30	13 c7 00 cf 0e 37 15 0e			.byte	$13,$c7,$00,$cf,$0e,$37,$15,$0e
>1c38	bd 42 be 84 45 76 fd 04			.byte	$bd,$42,$be,$84,$45,$76,$fd,$04
>1c40	37 35 00 0c c8 00 cf 14			.byte	$37,$35,$00,$0c,$c8,$00,$cf,$14
>1c48	35 0e bb 84 41 52 00 0f			.byte	$35,$0e,$bb,$84,$41,$52,$00,$0f
>1c50	c9 00 cf 14 34 03 0b 11			.byte	$c9,$00,$cf,$14,$34,$03,$0b,$11
>1c58	bb 84 8b 4a 61 00 12 ca			.byte	$bb,$84,$8b,$4a,$61,$00,$12,$ca
>1c60	00 cf 0a 30 04 b9 84 48			.byte	$00,$cf,$0a,$30,$04,$b9,$84,$48
>1c68	63 fd 06 34 33 37 35 00			.byte	$63,$fd,$06,$34,$33,$37,$35,$00
>1c70	0e cb 00 cf 0b 36 09 13			.byte	$0e,$cb,$00,$cf,$0b,$36,$09,$13
>1c78	bb 84 8b 4d 7d 00 13 cc			.byte	$bb,$84,$8b,$4d,$7d,$00,$13,$cc
>1c80	00 cf 0a 36 0b 0f b9 84			.byte	$00,$cf,$0a,$36,$0b,$0f,$b9,$84
>1c88	46 4e fd 06 39 33 37 35			.byte	$46,$4e,$fd,$06,$39,$33,$37,$35
>1c90	00 12 cd 00 cf 0e 31 18			.byte	$00,$12,$cd,$00,$cf,$0e,$31,$18
>1c98	13 ba 41 be 84 43 40 fd			.byte	$13,$ba,$41,$be,$84,$43,$40,$fd
>1ca0	03 35 00 0d ce 00 cf 08			.byte	$03,$35,$00,$0d,$ce,$00,$cf,$08
>1ca8	30 04 bb 84 8b 4f 43 00			.byte	$30,$04,$bb,$84,$8b,$4f,$43,$00
>1cb0	10 cf 00 cf 06 32 14 11			.byte	$10,$cf,$00,$cf,$06,$32,$14,$11
>1cb8	b7 84 fe 05 4d 30 46 00			.byte	$b7,$84,$fe,$05,$4d,$30,$46,$00
>1cc0	15 d0 00 cf 17 35 03 19			.byte	$15,$d0,$00,$cf,$17,$35,$03,$19
>1cc8	17 b9 84 8b 47 7d fd 06			.byte	$17,$b9,$84,$8b,$47,$7d,$fd,$06
>1cd0	34 33 37 35 00 11 d1 00			.byte	$34,$33,$37,$35,$00,$11,$d1,$00
>1cd8	cf 0c 39 18 84 8b 49 67			.byte	$cf,$0c,$39,$18,$84,$8b,$49,$67
>1ce0	fd 05 33 37 35 00 10 d2			.byte	$fd,$05,$33,$37,$35,$00,$10,$d2
>1ce8	00 cf 06 35 04 08 0e 84			.byte	$00,$cf,$06,$35,$04,$08,$0e,$84
>1cf0	44 73 fd 03 35 00 11 d3			.byte	$44,$73,$fd,$03,$35,$00,$11,$d3
>1cf8	00 cf 0d 32 13 04 b7 84			.byte	$00,$cf,$0d,$32,$13,$04,$b7,$84
>1d00	fe 06 50 37 48 49 00 0f			.byte	$fe,$06,$50,$37,$48,$49,$00,$0f
>1d08	d4 00 cf 0d 84 8b 42 7b			.byte	$d4,$00,$cf,$0d,$84,$8b,$42,$7b
>1d10	fd 05 36 32 35 00 14 d5			.byte	$fd,$05,$36,$32,$35,$00,$14,$d5
>1d18	00 cf 19 36 09 10 0e 84			.byte	$00,$cf,$19,$36,$09,$10,$0e,$84
>1d20	8b 45 45 fd 06 39 33 37			.byte	$8b,$45,$45,$fd,$06,$39,$33,$37
>1d28	35 00 0d d6 00 dc 18 39			.byte	$35,$00,$0d,$d6,$00,$dc,$18,$39
>1d30	19 0e 13 bb 84 40 00 0f			.byte	$19,$0e,$13,$bb,$84,$40,$00,$0f
>1d38	d7 00 dc 0b 37 07 1a 17			.byte	$d7,$00,$dc,$0b,$37,$07,$1a,$17
>1d40	bb 84 8b 4f 59 00 10 d8			.byte	$bb,$84,$8b,$4f,$59,$00,$10,$d8
>1d48	00 dc 0d 37 05 b9 84 8b			.byte	$00,$dc,$0d,$37,$05,$b9,$84,$8b
>1d50	43 5b fd 03 35 00 08 d9			.byte	$43,$5b,$fd,$03,$35,$00,$08,$d9
>1d58	00 dc 0f 84 40 00 0a da			.byte	$00,$dc,$0f,$84,$40,$00,$0a,$da
>1d60	00 dc 16 bb 84 47 7e 00			.byte	$00,$dc,$16,$bb,$84,$47,$7e,$00
>1d68	0b db 00 dc 0e bb 84 8b			.byte	$0b,$db,$00,$dc,$0e,$bb,$84,$8b
>1d70	45 5b 00 0e dc 00 dc 0b			.byte	$45,$5b,$00,$0e,$dc,$00,$dc,$0b
>1d78	36 09 13 bb 84 8b 4d 7d			.byte	$36,$09,$13,$bb,$84,$8b,$4d,$7d
>1d80	00 0d dd 00 dc 07 39 0e			.byte	$00,$0d,$dd,$00,$dc,$07,$39,$0e
>1d88	05 04 b9 84 40 00 0f de			.byte	$05,$04,$b9,$84,$40,$00,$0f,$de
>1d90	00 dc 12 38 18 13 0c bb			.byte	$00,$dc,$12,$38,$18,$13,$0c,$bb
>1d98	84 8b 4e 77 00 0c df 00			.byte	$84,$8b,$4e,$77,$00,$0c,$df,$00
>1da0	dc 04 35 07 bb 84 47 6d			.byte	$dc,$04,$35,$07,$bb,$84,$47,$6d
>1da8	00 0c e0 00 dc 04 32 06			.byte	$00,$0c,$e0,$00,$dc,$04,$32,$06
>1db0	bb 84 42 75 00 0a e1 00			.byte	$bb,$84,$42,$75,$00,$0a,$e1,$00
>1db8	dc 06 37 07 84 40 00 09			.byte	$dc,$06,$37,$07,$84,$40,$00,$09
>1dc0	e2 00 dc 05 b9 84 40 00			.byte	$e2,$00,$dc,$05,$b9,$84,$40,$00
>1dc8	0f e3 00 dc 1a 38 11 14			.byte	$0f,$e3,$00,$dc,$1a,$38,$11,$14
>1dd0	14 b7 84 fe 03 43 00 13			.byte	$14,$b7,$84,$fe,$03,$43,$00,$13
>1dd8	e4 00 dc 01 34 1a 13 05			.byte	$e4,$00,$dc,$01,$34,$1a,$13,$05
>1de0	b7 84 fe 07 41 35 48 4d			.byte	$b7,$84,$fe,$07,$41,$35,$48,$4d
>1de8	47 00 11 e5 00 dc 17 34			.byte	$47,$00,$11,$e5,$00,$dc,$17,$34
>1df0	01 0b 06 b7 84 fe 05 51			.byte	$01,$0b,$06,$b7,$84,$fe,$05,$51
>1df8	32 4a 00 0f e6 00 dc 0d			.byte	$32,$4a,$00,$0f,$e6,$00,$dc,$0d
>1e00	84 8b 42 7b fd 05 36 32			.byte	$84,$8b,$42,$7b,$fd,$05,$36,$32
>1e08	35 00 0f e7 00 dc 0b 30			.byte	$35,$00,$0f,$e7,$00,$dc,$0b,$30
>1e10	0f 08 15 b7 84 fe 03 4f			.byte	$0f,$08,$15,$b7,$84,$fe,$03,$4f
>1e18	00 12 e8 00 dc 07 36 02			.byte	$00,$12,$e8,$00,$dc,$07,$36,$02
>1e20	10 1a b7 84 fe 06 4b 32			.byte	$10,$1a,$b7,$84,$fe,$06,$4b,$32
>1e28	49 42 00 0a e9 00 dc 02			.byte	$49,$42,$00,$0a,$e9,$00,$dc,$02
>1e30	bb 84 4e 5e 00 12 ea 00			.byte	$bb,$84,$4e,$5e,$00,$12,$ea,$00
>1e38	dc 08 35 04 0a b7 84 fe			.byte	$dc,$08,$35,$04,$0a,$b7,$84,$fe
>1e40	07 58 33 48 56 44 00 0e			.byte	$07,$58,$33,$48,$56,$44,$00,$0e
>1e48	eb 00 dc 13 35 01 16 b7			.byte	$eb,$00,$dc,$13,$35,$01,$16,$b7
>1e50	84 fe 03 4f 00 11 ec 00			.byte	$84,$fe,$03,$4f,$00,$11,$ec,$00
>1e58	dc 0d 32 13 04 b7 84 fe			.byte	$dc,$0d,$32,$13,$04,$b7,$84,$fe
>1e60	06 50 37 48 49 00 0f ed			.byte	$06,$50,$37,$48,$49,$00,$0f,$ed
>1e68	00 dc 01 34 0e 0e 84 42			.byte	$00,$dc,$01,$34,$0e,$0e,$84,$42
>1e70	70 fd 03 30 00 12 ee 00			.byte	$70,$fd,$03,$30,$00,$12,$ee,$00
>1e78	dc 0c 32 0b 03 84 46 71			.byte	$dc,$0c,$32,$0b,$03,$84,$46,$71
>1e80	fd 06 39 33 37 35 00 0f			.byte	$fd,$06,$39,$33,$37,$35,$00,$0f
>1e88	ef 00 dc 13 b7 84 fe 07			.byte	$ef,$00,$dc,$13,$b7,$84,$fe,$07
>1e90	55 30 58 4b 59 00 0f f0			.byte	$55,$30,$58,$4b,$59,$00,$0f,$f0
>1e98	00 dc 07 37 05 0e 12 bb			.byte	$00,$dc,$07,$37,$05,$0e,$12,$bb
>1ea0	84 8b 47 40 00 0c f1 00			.byte	$84,$8b,$47,$40,$00,$0c,$f1,$00
>1ea8	dc 18 33 1a bb 84 4a 77			.byte	$dc,$18,$33,$1a,$bb,$84,$4a,$77
>1eb0	00 0e f2 00 dc 18 33 10			.byte	$00,$0e,$f2,$00,$dc,$18,$33,$10
>1eb8	0d bb 84 8b 46 61 00 0f			.byte	$0d,$bb,$84,$8b,$46,$61,$00,$0f
>1ec0	f3 00 dc 15 b7 84 fe 07			.byte	$f3,$00,$dc,$15,$b7,$84,$fe,$07
>1ec8	4e 37 4a 4d 42 00 11 f4			.byte	$4e,$37,$4a,$4d,$42,$00,$11,$f4
>1ed0	00 dc 0f 35 16 0c b7 84			.byte	$00,$dc,$0f,$35,$16,$0c,$b7,$84
>1ed8	fe 06 4d 32 42 52 00 10			.byte	$fe,$06,$4d,$32,$42,$52,$00,$10
>1ee0	f5 00 dc 06 32 14 11 b7			.byte	$f5,$00,$dc,$06,$32,$14,$11,$b7
>1ee8	84 fe 05 4d 30 46 00 12			.byte	$84,$fe,$05,$4d,$30,$46,$00,$12
>1ef0	f6 00 dc 04 32 0f 08 0e			.byte	$f6,$00,$dc,$04,$32,$0f,$08,$0e
>1ef8	b9 84 48 4f fd 04 32 35			.byte	$b9,$84,$48,$4f,$fd,$04,$32,$35
>1f00	00 0f f7 00 dc 09 36 18			.byte	$00,$0f,$f7,$00,$dc,$09,$36,$18
>1f08	08 07 b7 84 fe 03 50 00			.byte	$08,$07,$b7,$84,$fe,$03,$50,$00
>1f10	0e f8 00 dc 02 39 18 14			.byte	$0e,$f8,$00,$dc,$02,$39,$18,$14
>1f18	12 b7 84 fe 02 00 15 f9			.byte	$12,$b7,$84,$fe,$02,$00,$15,$f9
>1f20	00 dc 17 35 03 19 17 b9			.byte	$00,$dc,$17,$35,$03,$19,$17,$b9
>1f28	84 8b 47 7d fd 06 34 33			.byte	$84,$8b,$47,$7d,$fd,$06,$34,$33
>1f30	37 35 00 0d fa 00 dc 0e			.byte	$37,$35,$00,$0d,$fa,$00,$dc,$0e
>1f38	34 0d 09 bb 84 4b 72 00			.byte	$34,$0d,$09,$bb,$84,$4b,$72,$00
>1f40	0f fb 00 dc 10 32 01 01			.byte	$0f,$fb,$00,$dc,$10,$32,$01,$01
>1f48	03 bb 84 8b 41 56 00 0e			.byte	$03,$bb,$84,$8b,$41,$56,$00,$0e
>1f50	fc 00 dc 13 31 01 b7 84			.byte	$fc,$00,$dc,$13,$31,$01,$b7,$84
>1f58	fe 04 53 38 00 0d fd 00			.byte	$fe,$04,$53,$38,$00,$0d,$fd,$00
>1f60	dc 01 38 19 bb 84 8b 42			.byte	$dc,$01,$38,$19,$bb,$84,$8b,$42
>1f68	77 00 13 fe 00 dc 0a 36			.byte	$77,$00,$13,$fe,$00,$dc,$0a,$36
>1f70	0b 0f b9 84 46 4e fd 06			.byte	$0b,$0f,$b9,$84,$46,$4e,$fd,$06
>1f78	39 33 37 35 00 0f ff 00			.byte	$39,$33,$37,$35,$00,$0f,$ff,$00
>1f80	dc 14 34 03 0b 11 bb 84			.byte	$dc,$14,$34,$03,$0b,$11,$bb,$84
>1f88	8b 4a 61 00 0c 00 01 dc			.byte	$8b,$4a,$61,$00,$0c,$00,$01,$dc
>1f90	12 37 17 14 05 84 40 00			.byte	$12,$37,$17,$14,$05,$84,$40,$00
>1f98	11 01 01 dc 17 b9 84 8b			.byte	$11,$01,$01,$dc,$17,$b9,$84,$8b
>1fa0	41 5d fd 06 35 36 32 35			.byte	$41,$5d,$fd,$06,$35,$36,$32,$35
>1fa8	00 13 02 01 dc 02 33 19			.byte	$00,$13,$02,$01,$dc,$02,$33,$19
>1fb0	03 17 84 49 63 fd 06 36			.byte	$03,$17,$84,$49,$63,$fd,$06,$36
>1fb8	38 37 35 00 13 03 01 dc			.byte	$38,$37,$35,$00,$13,$03,$01,$dc
>1fc0	0e 30 02 16 84 8b 44 5b			.byte	$0e,$30,$02,$16,$84,$8b,$44,$5b
>1fc8	fd 06 31 38 37 35 00 10			.byte	$fd,$06,$31,$38,$37,$35,$00,$10
>1fd0	04 01 dc 0a 84 8b 47 4d			.byte	$04,$01,$dc,$0a,$84,$8b,$47,$4d
>1fd8	fd 06 31 38 37 35 00 11			.byte	$fd,$06,$31,$38,$37,$35,$00,$11
>1fe0	05 01 dc 15 34 0e b7 84			.byte	$05,$01,$dc,$15,$34,$0e,$b7,$84
>1fe8	fe 07 59 35 4c 52 47 00			.byte	$fe,$07,$59,$35,$4c,$52,$47,$00
>1ff0	11 06 01 dc 02 39 13 09			.byte	$11,$06,$01,$dc,$02,$39,$13,$09
>1ff8	16 b9 84 45 44 fd 03 35			.byte	$16,$b9,$84,$45,$44,$fd,$03,$35
>2000	00 13 07 01 dc 04 37 0c			.byte	$00,$13,$07,$01,$dc,$04,$37,$0c
>2008	12 b9 84 8b 48 5d fd 05			.byte	$12,$b9,$84,$8b,$48,$5d,$fd,$05
>2010	38 37 35 00 0c 08 01 dc			.byte	$38,$37,$35,$00,$0c,$08,$01,$dc
>2018	0f 30 0a 09 b9 84 40 00			.byte	$0f,$30,$0a,$09,$b9,$84,$40,$00
>2020	13 09 01 dc 1a 37 10 0d			.byte	$13,$09,$01,$dc,$1a,$37,$10,$0d
>2028	84 8b 49 66 fd 06 34 33			.byte	$84,$8b,$49,$66,$fd,$06,$34,$33
>2030	37 35 00 13 0a 01 dc 19			.byte	$37,$35,$00,$13,$0a,$01,$dc,$19
>2038	36 0b 14 17 b7 84 fe 07			.byte	$36,$0b,$14,$17,$b7,$84,$fe,$07
>2040	41 34 52 4b 46 00 0d 0b			.byte	$41,$34,$52,$4b,$46,$00,$0d,$0b
>2048	01 dc 17 33 17 08 b7 84			.byte	$01,$dc,$17,$33,$17,$08,$b7,$84
>2050	fe 02 00 0d 0c 01 dc 07			.byte	$fe,$02,$00,$0d,$0c,$01,$dc,$07
>2058	36 15 0a b7 84 fe 02 00			.byte	$36,$15,$0a,$b7,$84,$fe,$02,$00
>2060	0c 0d 01 dc 14 37 08 0c			.byte	$0c,$0d,$01,$dc,$14,$37,$08,$0c
>2068	b9 84 40 00 12 0e 01 dc			.byte	$b9,$84,$40,$00,$12,$0e,$01,$dc
>2070	07 37 13 84 8b 42 4c fd			.byte	$07,$37,$13,$84,$8b,$42,$4c,$fd
>2078	06 35 36 32 35 00 0b 0f			.byte	$06,$35,$36,$32,$35,$00,$0b,$0f
>2080	01 dc 12 bb 84 8b 4f 57			.byte	$01,$dc,$12,$bb,$84,$8b,$4f,$57
>2088	00 12 10 01 dc 13 31 14			.byte	$00,$12,$10,$01,$dc,$13,$31,$14
>2090	07 17 b9 84 47 65 fd 04			.byte	$07,$17,$b9,$84,$47,$65,$fd,$04
>2098	37 35 00 0e 11 01 dc 11			.byte	$37,$35,$00,$0e,$11,$01,$dc,$11
>20a0	30 05 18 bb 84 8b 4e 5f			.byte	$30,$05,$18,$bb,$84,$8b,$4e,$5f
>20a8	00 10 12 01 dc 03 84 8b			.byte	$00,$10,$12,$01,$dc,$03,$84,$8b
>20b0	41 71 fd 06 33 31 32 35			.byte	$41,$71,$fd,$06,$33,$31,$32,$35
>20b8	00 11 13 01 dc 18 35 0f			.byte	$00,$11,$13,$01,$dc,$18,$35,$0f
>20c0	0c 84 7a fd 06 31 38 37			.byte	$0c,$84,$7a,$fd,$06,$31,$38,$37
>20c8	35 00 0e 14 01 dc 11 34			.byte	$35,$00,$0e,$14,$01,$dc,$11,$34
>20d0	17 17 bb 84 8b 42 59 00			.byte	$17,$17,$bb,$84,$8b,$42,$59,$00
>20d8	12 15 01 dc 07 32 0a 14			.byte	$12,$15,$01,$dc,$07,$32,$0a,$14
>20e0	b7 84 fe 07 46 32 50 5a			.byte	$b7,$84,$fe,$07,$46,$32,$50,$5a
>20e8	59 00 0c 16 01 dc 10 35			.byte	$59,$00,$0c,$16,$01,$dc,$10,$35
>20f0	13 b7 84 fe 02 00 0c 17			.byte	$13,$b7,$84,$fe,$02,$00,$0c,$17
>20f8	01 dc 05 35 0c bb 84 4e			.byte	$01,$dc,$05,$35,$0c,$bb,$84,$4e
>2100	4e 00 13 18 01 dc 08 38			.byte	$4e,$00,$13,$18,$01,$dc,$08,$38
>2108	18 b9 84 8b 41 51 fd 06			.byte	$18,$b9,$84,$8b,$41,$51,$fd,$06
>2110	38 31 32 35 00 11 19 01			.byte	$38,$31,$32,$35,$00,$11,$19,$01
>2118	dc 1a 35 10 0f 84 4e fd			.byte	$dc,$1a,$35,$10,$0f,$84,$4e,$fd
>2120	06 35 36 32 35 00 11 1a			.byte	$06,$35,$36,$32,$35,$00,$11,$1a
>2128	01 dc 06 32 19 0f b7 84			.byte	$01,$dc,$06,$32,$19,$0f,$b7,$84
>2130	fe 06 47 30 48 42 00 14			.byte	$fe,$06,$47,$30,$48,$42,$00,$14
>2138	1b 01 dc 19 36 09 10 0e			.byte	$1b,$01,$dc,$19,$36,$09,$10,$0e
>2140	84 8b 45 45 fd 06 39 33			.byte	$84,$8b,$45,$45,$fd,$06,$39,$33
>2148	37 35 00 0c 1c 01 dc 19			.byte	$37,$35,$00,$0c,$1c,$01,$dc,$19
>2150	b7 84 fe 04 4a 35 00 0a			.byte	$b7,$84,$fe,$04,$4a,$35,$00,$0a
>2158	1d 01 dc 01 bb 84 4c 50			.byte	$1d,$01,$dc,$01,$bb,$84,$4c,$50
>2160	00 0a 1e 01 dc 02 38 02			.byte	$00,$0a,$1e,$01,$dc,$02,$38,$02
>2168	84 40 00 0f 1f 01 dc 09			.byte	$84,$40,$00,$0f,$1f,$01,$dc,$09
>2170	39 0a 10 19 bb 84 8b 43			.byte	$39,$0a,$10,$19,$bb,$84,$8b,$43
>2178	7a 00 11 20 01 dc 02 38			.byte	$7a,$00,$11,$20,$01,$dc,$02,$38
>2180	03 0e b7 84 fe 06 54 31			.byte	$03,$0e,$b7,$84,$fe,$06,$54,$31
>2188	46 4f 00 10 21 01 dc 17			.byte	$46,$4f,$00,$10,$21,$01,$dc,$17
>2190	32 05 13 19 84 48 58 fd			.byte	$32,$05,$13,$19,$84,$48,$58,$fd
>2198	03 35 00 0e 22 01 dc 08			.byte	$03,$35,$00,$0e,$22,$01,$dc,$08
>21a0	b9 84 48 fd 05 33 37 35			.byte	$b9,$84,$48,$fd,$05,$33,$37,$35
>21a8	00 13 23 01 dc 15 30 0a			.byte	$00,$13,$23,$01,$dc,$15,$30,$0a
>21b0	0f b9 84 43 45 fd 06 35			.byte	$0f,$b9,$84,$43,$45,$fd,$06,$35
>21b8	36 32 35 00 0d 24 01 dc			.byte	$36,$32,$35,$00,$0d,$24,$01,$dc
>21c0	0f 34 09 03 b7 84 fe 02			.byte	$0f,$34,$09,$03,$b7,$84,$fe,$02
>21c8	00 0d 25 01 dc 07 31 19			.byte	$00,$0d,$25,$01,$dc,$07,$31,$19
>21d0	09 b7 84 fe 02 00 0f 26			.byte	$09,$b7,$84,$fe,$02,$00,$0f,$26
>21d8	01 dc 01 32 17 84 8b 43			.byte	$01,$dc,$01,$32,$17,$84,$8b,$43
>21e0	fd 04 37 35 00 10 27 01			.byte	$fd,$04,$37,$35,$00,$10,$27,$01
>21e8	dc 14 38 08 b7 84 fe 06			.byte	$dc,$14,$38,$08,$b7,$84,$fe,$06
>21f0	54 39 4b 4c 00 10 28 01			.byte	$54,$39,$4b,$4c,$00,$10,$28,$01
>21f8	dc 06 35 04 08 0e 84 44			.byte	$dc,$06,$35,$04,$08,$0e,$84,$44
>2200	73 fd 03 35 00 13 29 01			.byte	$73,$fd,$03,$35,$00,$13,$29,$01
>2208	dc 12 36 15 07 b9 84 41			.byte	$dc,$12,$36,$15,$07,$b9,$84,$41
>2210	58 fd 06 31 38 37 35 00			.byte	$58,$fd,$06,$31,$38,$37,$35,$00
>2218	0d 2a 01 dc 0a 38 0a 06			.byte	$0d,$2a,$01,$dc,$0a,$38,$0a,$06
>2220	bb 84 41 40 00 10 2b 01			.byte	$bb,$84,$41,$40,$00,$10,$2b,$01
>2228	dc 18 37 07 10 b7 84 fe			.byte	$dc,$18,$37,$07,$10,$b7,$84,$fe
>2230	05 59 31 48 00 0f 2c 01			.byte	$05,$59,$31,$48,$00,$0f,$2c,$01
>2238	dc 19 31 07 06 17 bb 84			.byte	$dc,$19,$31,$07,$06,$17,$bb,$84
>2240	8b 4f 4e 00 11 2d 01 dc			.byte	$8b,$4f,$4e,$00,$11,$2d,$01,$dc
>2248	10 37 02 03 b7 84 fe 06			.byte	$10,$37,$02,$03,$b7,$84,$fe,$06
>2250	50 35 4a 52 00 12 2e 01			.byte	$50,$35,$4a,$52,$00,$12,$2e,$01
>2258	dc 08 34 0d b9 84 46 5a			.byte	$dc,$08,$34,$0d,$b9,$84,$46,$5a
>2260	fd 06 33 31 32 35 00 12			.byte	$fd,$06,$33,$31,$32,$35,$00,$12
>2268	2f 01 dc 19 37 04 b9 84			.byte	$2f,$01,$dc,$19,$37,$04,$b9,$84
>2270	8b 42 55 fd 05 36 32 35			.byte	$8b,$42,$55,$fd,$05,$36,$32,$35
>2278	00 0f 30 01 dc 09 39 10			.byte	$00,$0f,$30,$01,$dc,$09,$39,$10
>2280	0b b7 84 fe 04 53 33 00			.byte	$0b,$b7,$84,$fe,$04,$53,$33,$00
>2288	12 31 01 dc 0a 30 04 b9			.byte	$12,$31,$01,$dc,$0a,$30,$04,$b9
>2290	84 48 63 fd 06 34 33 37			.byte	$84,$48,$63,$fd,$06,$34,$33,$37
>2298	35 00 0c 32 01 dc 14 35			.byte	$35,$00,$0c,$32,$01,$dc,$14,$35
>22a0	0e bb 84 41 52 00 11 33			.byte	$0e,$bb,$84,$41,$52,$00,$11,$33
>22a8	01 dc 08 31 09 84 46 78			.byte	$01,$dc,$08,$31,$09,$84,$46,$78
>22b0	fd 06 34 33 37 35 00 0b			.byte	$fd,$06,$34,$33,$37,$35,$00,$0b
>22b8	34 01 dc 19 31 15 b9 84			.byte	$34,$01,$dc,$19,$31,$15,$b9,$84
>22c0	40 00 11 35 01 dc 0c 39			.byte	$40,$00,$11,$35,$01,$dc,$0c,$39
>22c8	18 84 8b 49 67 fd 05 33			.byte	$18,$84,$8b,$49,$67,$fd,$05,$33
>22d0	37 35 00 13 36 01 dc 07			.byte	$37,$35,$00,$13,$36,$01,$dc,$07
>22d8	33 16 0b 09 84 8b 45 4c			.byte	$33,$16,$0b,$09,$84,$8b,$45,$4c
>22e0	fd 05 36 32 35 00 0e 37			.byte	$fd,$05,$36,$32,$35,$00,$0e,$37
>22e8	01 dc 18 b9 84 8b 42 7e			.byte	$01,$dc,$18,$b9,$84,$8b,$42,$7e
>22f0	fd 03 35 00 0d 38 01 dc			.byte	$fd,$03,$35,$00,$0d,$38,$01,$dc
>22f8	08 30 04 bb 84 8b 4f 43			.byte	$08,$30,$04,$bb,$84,$8b,$4f,$43
>2300	00 0d 39 01 dc 07 38 03			.byte	$00,$0d,$39,$01,$dc,$07,$38,$03
>2308	b7 84 fe 03 5a 00 27 3a			.byte	$b7,$84,$fe,$03,$5a,$00,$27,$3a
>2310	01 dc 01 38 12 1a 12 bc			.byte	$01,$dc,$01,$38,$12,$1a,$12,$bc
>2318	40 be 84 40 c0 dc 01 38			.byte	$40,$be,$84,$40,$c0,$dc,$01,$38
>2320	12 1a 12 bc 41 be 84 40			.byte	$12,$1a,$12,$bc,$41,$be,$84,$40
>2328	c0 dc 01 38 12 1a 12 bc			.byte	$c0,$dc,$01,$38,$12,$1a,$12,$bc
>2330	42 be 84 40 00 20 3b 01			.byte	$42,$be,$84,$40,$00,$20,$3b,$01
>2338	dc 19 38 08 08 12 bd 40			.byte	$dc,$19,$38,$08,$08,$12,$bd,$40
>2340	be 84 40 c0 dc 19 38 08			.byte	$be,$84,$40,$c0,$dc,$19,$38,$08
>2348	08 12 bd 41 be 84 8b 49			.byte	$08,$12,$bd,$41,$be,$84,$8b,$49
>2350	63 fd 03 35 00 19 3c 01			.byte	$63,$fd,$03,$35,$00,$19,$3c,$01
>2358	dc 0b 31 01 19 bd 40 be			.byte	$dc,$0b,$31,$01,$19,$bd,$40,$be
>2360	84 40 c0 dc 0b 31 01 19			.byte	$84,$40,$c0,$dc,$0b,$31,$01,$19
>2368	bd 41 be 84 40 00 1d 3d			.byte	$bd,$41,$be,$84,$40,$00,$1d,$3d
>2370	01 dc 0e 31 18 13 ba 40			.byte	$01,$dc,$0e,$31,$18,$13,$ba,$40
>2378	be 84 40 c0 dc 0e 31 18			.byte	$be,$84,$40,$c0,$dc,$0e,$31,$18
>2380	13 ba 41 be 84 43 40 fd			.byte	$13,$ba,$41,$be,$84,$43,$40,$fd
>2388	03 35 00 26 3e 01 dc 0b			.byte	$03,$35,$00,$26,$3e,$01,$dc,$0b
>2390	32 15 07 ba 40 be 84 8b			.byte	$32,$15,$07,$ba,$40,$be,$84,$8b
>2398	43 5d fd 05 36 32 35 c0			.byte	$43,$5d,$fd,$05,$36,$32,$35,$c0
>23a0	dc 0b 32 15 07 ba 41 be			.byte	$dc,$0b,$32,$15,$07,$ba,$41,$be
>23a8	84 5e fd 06 36 38 37 35			.byte	$84,$5e,$fd,$06,$36,$38,$37,$35
>23b0	00 13 3f 01 dc 10 bd 40			.byte	$00,$13,$3f,$01,$dc,$10,$bd,$40
>23b8	be 84 40 c0 dc 10 bd 41			.byte	$be,$84,$40,$c0,$dc,$10,$bd,$41
>23c0	be 84 40 00 29 40 01 dc			.byte	$be,$84,$40,$00,$29,$40,$01,$dc
>23c8	0e 37 15 0e bd 40 be 84			.byte	$0e,$37,$15,$0e,$bd,$40,$be,$84
>23d0	40 c0 dc 0e 37 15 0e bd			.byte	$40,$c0,$dc,$0e,$37,$15,$0e,$bd
>23d8	41 be 84 40 c0 dc 0e 37			.byte	$41,$be,$84,$40,$c0,$dc,$0e,$37
>23e0	15 0e bd 42 be 84 45 76			.byte	$15,$0e,$bd,$42,$be,$84,$45,$76
>23e8	fd 04 37 35 00 5f 41 01			.byte	$fd,$04,$37,$35,$00,$5f,$41,$01
>23f0	dc 0f 36 05 05 03 bd 40			.byte	$dc,$0f,$36,$05,$05,$03,$bd,$40
>23f8	bf 40 be 84 40 c0 dc 0f			.byte	$bf,$40,$be,$84,$40,$c0,$dc,$0f
>2400	36 05 05 03 bd 40 bf 41			.byte	$36,$05,$05,$03,$bd,$40,$bf,$41
>2408	be 84 40 c0 dc 0f 36 05			.byte	$be,$84,$40,$c0,$dc,$0f,$36,$05
>2410	05 03 bd 40 bf 42 be 84			.byte	$05,$03,$bd,$40,$bf,$42,$be,$84
>2418	40 c0 dc 0f 36 05 05 03			.byte	$40,$c0,$dc,$0f,$36,$05,$05,$03
>2420	bd 41 bf 40 be 84 40 c0			.byte	$bd,$41,$bf,$40,$be,$84,$40,$c0
>2428	dc 0f 36 05 05 03 bd 41			.byte	$dc,$0f,$36,$05,$05,$03,$bd,$41
>2430	bf 41 be 84 40 c0 dc 0f			.byte	$bf,$41,$be,$84,$40,$c0,$dc,$0f
>2438	36 05 05 03 bd 41 bf 42			.byte	$36,$05,$05,$03,$bd,$41,$bf,$42
>2440	be 84 8b 43 58 fd 06 30			.byte	$be,$84,$8b,$43,$58,$fd,$06,$30
>2448	36 32 35 00 79 42 01 dc			.byte	$36,$32,$35,$00,$79,$42,$01,$dc
>2450	12 39 12 b8 40 bf 40 be			.byte	$12,$39,$12,$b8,$40,$bf,$40,$be
>2458	84 fe 02 c0 dc 12 39 12			.byte	$84,$fe,$02,$c0,$dc,$12,$39,$12
>2460	b8 40 bf 41 be 84 fe 02			.byte	$b8,$40,$bf,$41,$be,$84,$fe,$02
>2468	c0 dc 12 39 12 b8 40 bf			.byte	$c0,$dc,$12,$39,$12,$b8,$40,$bf
>2470	42 be 84 fe 02 c0 dc 12			.byte	$42,$be,$84,$fe,$02,$c0,$dc,$12
>2478	39 12 b8 41 bf 40 be 84			.byte	$39,$12,$b8,$41,$bf,$40,$be,$84
>2480	fe 03 4e c0 dc 12 39 12			.byte	$fe,$03,$4e,$c0,$dc,$12,$39,$12
>2488	b8 41 bf 41 be 84 fe 02			.byte	$b8,$41,$bf,$41,$be,$84,$fe,$02
>2490	c0 dc 12 39 12 b8 41 bf			.byte	$c0,$dc,$12,$39,$12,$b8,$41,$bf
>2498	42 be 84 fe 02 c0 dc 12			.byte	$42,$be,$84,$fe,$02,$c0,$dc,$12
>24a0	39 12 b8 42 bf 40 be 84			.byte	$39,$12,$b8,$42,$bf,$40,$be,$84
>24a8	fe 02 c0 dc 12 39 12 b8			.byte	$fe,$02,$c0,$dc,$12,$39,$12,$b8
>24b0	42 bf 41 be 84 fe 02 c0			.byte	$42,$bf,$41,$be,$84,$fe,$02,$c0
>24b8	dc 12 39 12 b8 42 bf 42			.byte	$dc,$12,$39,$12,$b8,$42,$bf,$42
>24c0	be 84 fe 02 00 21 43 01			.byte	$be,$84,$fe,$02,$00,$21,$43,$01
>24c8	dc 19 31 07 bc 40 be 84			.byte	$dc,$19,$31,$07,$bc,$40,$be,$84
>24d0	40 c0 dc 19 31 07 bc 41			.byte	$40,$c0,$dc,$19,$31,$07,$bc,$41
>24d8	be 84 40 c0 dc 19 31 07			.byte	$be,$84,$40,$c0,$dc,$19,$31,$07
>24e0	bc 42 be 84 40 00 22 44			.byte	$bc,$42,$be,$84,$40,$00,$22,$44
>24e8	01 dc 14 37 01 19 11 ba			.byte	$01,$dc,$14,$37,$01,$19,$11,$ba
>24f0	40 be 84 42 56 fd 06 38			.byte	$40,$be,$84,$42,$56,$fd,$06,$38
>24f8	31 32 35 c0 dc 14 37 01			.byte	$31,$32,$35,$c0,$dc,$14,$37,$01
>2500	19 11 ba 41 be 84 40 00			.byte	$19,$11,$ba,$41,$be,$84,$40,$00
>2508	3b 45 01 dc 0b 38 01 14			.byte	$3b,$45,$01,$dc,$0b,$38,$01,$14
>2510	10 ba 40 be 84 8b 45 64			.byte	$10,$ba,$40,$be,$84,$8b,$45,$64
>2518	fd 06 36 38 37 35 c0 dc			.byte	$fd,$06,$36,$38,$37,$35,$c0,$dc
>2520	0b 38 01 14 10 ba 41 be			.byte	$0b,$38,$01,$14,$10,$ba,$41,$be
>2528	84 43 43 fd 04 32 35 c0			.byte	$84,$43,$43,$fd,$04,$32,$35,$c0
>2530	dc 0b 38 01 14 10 ba 42			.byte	$dc,$0b,$38,$01,$14,$10,$ba,$42
>2538	be 84 49 67 fd 06 30 36			.byte	$be,$84,$49,$67,$fd,$06,$30,$36
>2540	32 35 00 1b 46 01 d6 fe			.byte	$32,$35,$00,$1b,$46,$01,$d6,$fe
>2548	14 50 61 73 73 65 64 20			.byte	$14,$50,$61,$73,$73,$65,$64,$20
>2550	41 73 73 69 67 6e 6d 65			.byte	$41,$73,$73,$69,$67,$6e,$6d,$65
>2558	6e 74 2e c0 c4 00 00			.byte	$6e,$74,$2e,$c0,$c4,$00,$00

;******  Return to file: modules/hardware/em65816.asm

.c000					StartROM:
.c000	18		clc				clc
.c001	fb		xce				xce
.c002	c2 30		rep #$30			rep 	#$30
.c004	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.c007	1b		tcs				tcs
.c008	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.c00b	e2 30		sep #$30			sep 	#$30
.c00d	c2 30		rep #$30			rep 	#$30						; clear AXY in 16 bit.
.c00f	a9 00		lda #$00			lda 	#$0000
.c011	aa		tax				tax
.c012	a8		tay				tay
.c013	e2 30		sep #$30			sep 	#$30
.c015	5c b4 86 01	jmp $0186b4		jmp BASIC_Start
.c019					TIM_BreakHandler:
.c019	5c 76 83 01	jmp $018376			jmp 	TIM_BreakVector

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.018000					IFT_ClearScreen:
.018000	48		pha				pha
.018001	da		phx				phx
.018002	5a		phy				phy
.018003	20 a9 81	jsr $0181a9			jsr 	IF_Home 					; home cursor
.018006	a2 20		ldx #$20			ldx 	#IF_Height 					; this many lines.
.018008					_IFT_CS0:
.018008	a0 40		ldy #$40			ldy 	#IF_Width 					; this many chars/line
.01800a					_IFT_CS1:
.01800a	a9 20		lda #$20			lda 	#' '						; clear line.
.01800c	20 d5 81	jsr $0181d5			jsr 	IF_Write
.01800f	88		dey				dey
.018010	d0 f8		bne $01800a			bne 	_IFT_CS1
.018012	20 bc 81	jsr $0181bc			jsr 	IF_NewLine 					; next line down
.018015	ca		dex				dex
.018016	d0 f0		bne $018008			bne 	_IFT_CS0
.018018	7a		ply				ply
.018019	fa		plx				plx
.01801a	68		pla				pla
.01801b					IFT_HomeCursor:
.01801b	48		pha				pha
.01801c	20 a9 81	jsr $0181a9			jsr 	IF_Home
.01801f	a9 00		lda #$00			lda 	#0
.018021	8d 00 02	sta $0200			sta 	IFT_XCursor
.018024	8d 01 02	sta $0201			sta 	IFT_YCursor
.018027	68		pla				pla
.018028	60		rts				rts
.018029					IFT_UpLine:
.018029	48		pha				pha
.01802a	ad 01 02	lda $0201			lda  	IFT_YCursor 				; get Y
.01802d	3a		dec a				dec 	a 							; line above
.01802e	30 03		bmi $018033			bmi 	_IFTULExit 					; too far, abort
.018030	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos					; set to that line.
.018033					_IFTULExit:
.018033	68		pla				pla
.018034	60		rts				rts
.018035					IFT_PrintCharacter:
.018035	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.018037	f0 23		beq $01805c			beq 	IFT_NewLine
.018039	48		pha				pha
.01803a	20 74 80	jsr $018074			jsr 	IFT_UpperCase 				; make upper case
.01803d	20 d5 81	jsr $0181d5			jsr 	IF_Write 					; write out.
.018040	ee 00 02	inc $0200			inc 	IFT_XCursor 				; bump x cursor
.018043	ad 00 02	lda $0200			lda 	IFT_XCursor 				; reached RHS ?
.018046	c9 40		cmp #$40			cmp 	#IF_Width
.018048	d0 03		bne $01804d			bne 	_IFT_PCNotEOL
.01804a	20 5c 80	jsr $01805c			jsr 	IFT_NewLine 				; if so do new line.
.01804d					_IFT_PCNotEOL:
.01804d	68		pla				pla
.01804e	60		rts				rts
.01804f					IFT_Tab:
.01804f	a9 20		lda #$20			lda 	#" " 						; space
.018051	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018054	ad 00 02	lda $0200			lda 	IFT_XCursor 				; until x % 8 == 0
.018057	29 07		and #$07			and 	#7
.018059	d0 f4		bne $01804f			bne 	IFT_Tab
.01805b	60		rts				rts
.01805c					IFT_NewLine:
.01805c	48		pha				pha
.01805d	20 bc 81	jsr $0181bc			jsr 	IF_NewLine 					; new line on actual screen.
.018060	a9 00		lda #$00			lda 	#0 							; reset x position
.018062	8d 00 02	sta $0200			sta 	IFT_XCursor
.018065	ee 01 02	inc $0201			inc 	IFT_YCursor 				; move down.
.018068	ad 01 02	lda $0201			lda 	IFT_YCursor
.01806b	c9 20		cmp #$20			cmp 	#IF_Height 					; reached bottom.
.01806d	d0 03		bne $018072			bne 	_IFT_NL_NotEOS
.01806f	20 7f 80	jsr $01807f			jsr 	IFT_Scroll 					; scroll screen up.
.018072					_IFT_NL_NotEOS:
.018072	68		pla				pla
.018073	60		rts				rts
.018074					IFT_UpperCase:
.018074	c9 61		cmp #$61			cmp 	#"a"
.018076	90 06		bcc $01807e			bcc 	_IFT_UCExit
.018078	c9 7b		cmp #$7b			cmp 	#"z"+1
.01807a	b0 02		bcs $01807e			bcs 	_IFT_UCExit
.01807c	49 20		eor #$20			eor 	#$20
.01807e					_IFT_UCExit:
.01807e	60		rts				rts
.01807f					IFT_Scroll:
.01807f	48		pha				pha 								; save AXY
.018080	da		phx				phx
.018081	5a		phy				phy
.018082	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.018084					_IFT_SLoop:
.018084	20 a4 80	jsr $0180a4			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.018087	e8		inx				inx
.018088	e0 1f		cpx #$1f			cpx 	#IF_Height-1				; do whole screen
.01808a	d0 f8		bne $018084			bne 	_IFT_SLoop
.01808c	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.01808e	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.018091	a2 40		ldx #$40			ldx 	#IF_Width 					; blank line
.018093					_IFT_SBlank:
.018093	a9 20		lda #$20			lda 	#32
.018095	20 d5 81	jsr $0181d5			jsr 	IF_Write
.018098	ca		dex				dex
.018099	d0 f8		bne $018093			bne 	_IFT_SBlank
.01809b	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.01809d	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.0180a0	7a		ply				ply
.0180a1	fa		plx				plx
.0180a2	68		pla				pla
.0180a3	60		rts				rts
.0180a4					_IFT_ScrollLine:
.0180a4	da		phx				phx
.0180a5	da		phx				phx
.0180a6	8a		txa				txa 								; copy line into buffer.
.0180a7	1a		inc a				inc 	a 							; next line down.
.0180a8	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.0180ab	a2 00		ldx #$00			ldx 	#0
.0180ad					_IFTScrollCopy1:
.0180ad	20 cc 81	jsr $0181cc			jsr 	IF_Read
.0180b0	9d 02 02	sta $0202,x			sta 	IFT_Buffer,x
.0180b3	e8		inx				inx
.0180b4	e0 40		cpx #$40			cpx 	#IF_Width
.0180b6	d0 f5		bne $0180ad			bne 	_IFTScrollCopy1
.0180b8	68		pla				pla
.0180b9	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.0180bc	a2 00		ldx #$00			ldx 	#0
.0180be					_IFTScrollCopy2:
.0180be	bd 02 02	lda $0202,x			lda 	IFT_Buffer,x
.0180c1	20 d5 81	jsr $0181d5			jsr 	IF_Write
.0180c4	e8		inx				inx
.0180c5	e0 40		cpx #$40			cpx 	#IF_Width
.0180c7	d0 f5		bne $0180be			bne 	_IFTScrollCopy2
.0180c9	fa		plx				plx
.0180ca	60		rts				rts
.0180cb					IFT_SetYPos:
.0180cb	48		pha				pha
.0180cc	da		phx				phx
.0180cd	aa		tax				tax
.0180ce	20 1b 80	jsr $01801b			jsr 	IFT_HomeCursor
.0180d1	e0 00		cpx #$00			cpx 	#0
.0180d3	f0 09		beq $0180de			beq 	_IFT_MOAExit
.0180d5					_IFT_MOALoop:
.0180d5	20 bc 81	jsr $0181bc			jsr 	IF_NewLine
.0180d8	ee 01 02	inc $0201			inc 	IFT_YCursor
.0180db	ca		dex				dex
.0180dc	d0 f7		bne $0180d5			bne		_IFT_MOALoop
.0180de					_IFT_MOAExit:
.0180de	fa		plx				plx
.0180df	68		pla				pla
.0180e0	60		rts				rts
.0180e1					IFT_GetKeyCursor:
.0180e1	20 e9 80	jsr $0180e9			jsr 	_IFT_FlipCursor 			; reverse current
.0180e4					_IFT_GKCWait:
.0180e4	20 e6 81	jsr $0181e6			jsr 	IF_GetKey 					; get key
.0180e7	f0 fb		beq $0180e4			beq 	_IFT_GKCWait
.0180e9					_IFT_FlipCursor:
.0180e9	48		pha				pha 								; save
.0180ea	20 cc 81	jsr $0181cc			jsr 	IF_Read 					; read
.0180ed	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.0180f0	49 80		eor #$80			eor 	#$80 						; reverse
.0180f2	20 d5 81	jsr $0181d5			jsr 	IF_Write 					; write
.0180f5	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.0180f8	68		pla				pla
.0180f9	60		rts				rts
.0180fa					IFT_ReadLine:
.0180fa	48		pha				pha
.0180fb					_IFT_RLLoop:
.0180fb	20 e1 80	jsr $0180e1			jsr 	IFT_GetKeyCursor 			; get keystroke
.0180fe	c9 0d		cmp #$0d			cmp 	#13							; return
.018100	f0 7d		beq $01817f			beq 	_IFT_RLExit
.018102	c9 20		cmp #$20			cmp 	#32 						; control character
.018104	90 05		bcc $01810b			bcc 	_IFT_Control
.018106	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018109	80 f0		bra $0180fb			bra 	_IFT_RLLoop
.01810b					_IFT_Control:
.01810b	c9 01		cmp #$01			cmp 	#"A"-64
.01810d	f0 26		beq $018135			beq 	_IFT_Left
.01810f	c9 04		cmp #$04			cmp 	#"D"-64
.018111	f0 2e		beq $018141			beq 	_IFT_Right
.018113	c9 17		cmp #$17			cmp 	#"W"-64
.018115	f0 36		beq $01814d			beq 	_IFT_Up
.018117	c9 13		cmp #$13			cmp 	#"S"-64
.018119	f0 3e		beq $018159			beq 	_IFT_Down
.01811b	c9 08		cmp #$08			cmp 	#"H"-64
.01811d	f0 09		beq $018128			beq 	_IFT_Backspace
.01811f	c9 1a		cmp #$1a			cmp 	#"Z"-64
.018121	d0 d8		bne $0180fb			bne 	_IFT_RLLoop
.018123	20 00 80	jsr $018000			jsr 	IFT_ClearScreen				; clear CTL-Z
.018126	80 d3		bra $0180fb			bra 	_IFT_RLLoop
.018128					_IFT_Backspace:
.018128	ad 00 02	lda $0200			lda 	IFT_XCursor 				; check not start of line.
.01812b	f0 ce		beq $0180fb			beq 	_IFT_RLLoop
.01812d	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.018130	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.018132	20 d5 81	jsr $0181d5			jsr 	IF_Write
.018135					_IFT_Left:
.018135	ce 00 02	dec $0200			dec 	IFT_XCursor 				; left CTL-W
.018138	10 29		bpl $018163			bpl 	_IFT_Reposition
.01813a	a9 3f		lda #$3f			lda 	#IF_Width-1
.01813c					_IFT_SetX:
.01813c	8d 00 02	sta $0200			sta 	IFT_XCursor
.01813f	80 22		bra $018163			bra 	_IFT_Reposition
.018141					_IFT_Right:
.018141	ee 00 02	inc $0200			inc 	IFT_XCursor
.018144	ad 00 02	lda $0200			lda 	IFT_XCursor
.018147	49 40		eor #$40			eor 	#IF_Width
.018149	f0 f1		beq $01813c			beq 	_IFT_SetX
.01814b	80 16		bra $018163			bra 	_IFT_Reposition
.01814d					_IFT_Up:
.01814d	ce 01 02	dec $0201			dec 	IFT_YCursor
.018150	10 11		bpl $018163			bpl 	_IFT_Reposition
.018152	a9 1f		lda #$1f			lda 	#IF_Height-1
.018154					_IFT_SetY:
.018154	8d 01 02	sta $0201			sta 	IFT_YCursor
.018157	80 0a		bra $018163			bra 	_IFT_Reposition
.018159					_IFT_Down:
.018159	ee 01 02	inc $0201			inc 	IFT_YCursor
.01815c	ad 01 02	lda $0201			lda 	IFT_YCursor
.01815f	49 20		eor #$20			eor 	#IF_Height
.018161	f0 f1		beq $018154			beq 	_IFT_SetY
.018163					_IFT_Reposition:
.018163	ad 00 02	lda $0200			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.018166	48		pha				pha
.018167	ad 01 02	lda $0201			lda 	IFT_YCursor
.01816a	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.01816d	68		pla				pla
.01816e	aa		tax				tax
.01816f	e0 00		cpx #$00			cpx 	#0
.018171	f0 88		beq $0180fb			beq 	_IFT_RLLoop
.018173					_IFT_MoveRight:
.018173	20 cc 81	jsr $0181cc			jsr 	IF_Read
.018176	ee 00 02	inc $0200			inc 	IFT_XCursor
.018179	ca		dex				dex
.01817a	d0 f7		bne $018173			bne 	_IFT_MoveRight
.01817c	4c fb 80	jmp $0180fb			jmp 	_IFT_RLLoop
.01817f					_IFT_RLExit:
.01817f	ad 01 02	lda $0201			lda 	IFT_YCursor 				; go to start of line.
.018182	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.018185	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.018187					_IFT_RLRead:
.018187	20 cc 81	jsr $0181cc			jsr 	IF_Read
.01818a	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.01818d	e8		inx				inx
.01818e	e0 40		cpx #$40			cpx 	#IF_Width
.018190	d0 f5		bne $018187			bne 	_IFT_RLRead
.018192					_IFT_RL_Trim:
.018192	ca		dex				dex 	 							; previous char
.018193	30 07		bmi $01819c			bmi 	_IFT_Found 					; gone too far
.018195	bd 66 02	lda $0266,x			lda 	IFT_LineBuffer,x			; go back if space
.018198	c9 20		cmp #$20			cmp 	#" "
.01819a	f0 f6		beq $018192			beq 	_IFT_RL_Trim
.01819c					_IFT_Found:
.01819c	e8		inx				inx 								; forward to non-space
.01819d	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.01819f	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.0181a2	68		pla				pla
.0181a3	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.0181a5	a0 02		ldy #$02			ldy 	#IFT_LineBuffer >> 8
.0181a7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_em65816.asm

=64					IF_Width 	= 64 							; characters across
=32					IF_Height 	= 32 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line.
=8					IF_XPos 	= 8 							; current position, horizontal.
=$f0000					IF_Screen = $F0000							; 2k screen RAM here
=$f8010					IF_PKeyboard = $F8010						; Keyboard port.
=$f8000					IF_PBreak = $F8000 							; Break key.
.0181a8					IF_Reset:
.0181a8	60		rts				rts
.0181a9					IF_Home:
.0181a9	48		pha				pha
.0181aa	64 08		stz $08				stz 	IF_XPos 					; zero X position
.0181ac	a9 00		lda #$00			lda 	#IF_Screen & $FF 			; set r/w pos.
.0181ae	85 04		sta $04				sta 	IF_Pos
.0181b0	a9 00		lda #$00			lda 	#(IF_Screen >> 8) & $FF
.0181b2	85 05		sta $05				sta 	IF_Pos+1
.0181b4	a9 0f		lda #$0f			lda 	#IF_Screen >> 16
.0181b6	85 06		sta $06				sta 	IF_Pos+2
.0181b8	64 07		stz $07				stz 	IF_Pos+3
.0181ba	68		pla				pla
.0181bb	60		rts				rts
.0181bc					IF_NewLine:
.0181bc	48		pha				pha
.0181bd	64 08		stz $08				stz 	IF_XPos						; back to start of line
.0181bf	18		clc				clc 								; down one line
.0181c0	a5 04		lda $04				lda 	IF_Pos
.0181c2	69 40		adc #$40			adc 	#64
.0181c4	85 04		sta $04				sta 	IF_Pos
.0181c6	90 02		bcc $0181ca			bcc 	_IF_NoCarry 				; carry through.
.0181c8	e6 05		inc $05				inc 	IF_Pos+1
.0181ca					_IF_NoCarry:
.0181ca	68		pla				pla
.0181cb	60		rts				rts
.0181cc					IF_Read:
.0181cc	5a		phy				phy 								; save current Y
.0181cd	a4 08		ldy $08				ldy 	IF_XPos 					; read character at current position
.0181cf	b7 04		lda [$04],y			lda 	[IF_Pos],y
.0181d1	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181d3	7a		ply				ply									; restore Y
.0181d4	60		rts				rts
.0181d5					IF_Write:
.0181d5	5a		phy				phy 								; save current Y
.0181d6	a4 08		ldy $08				ldy 	IF_XPos 					; write character at current position
.0181d8	97 04		sta [$04],y			sta 	[IF_Pos],y
.0181da	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181dc	7a		ply				ply									; restore Y
.0181dd	60		rts				rts
.0181de					IF_LeftOne:
.0181de	c6 08		dec $08				dec 	IF_XPos
.0181e0	60		rts				rts
.0181e1					IF_CheckBreak:
.0181e1	af 00 80 0f	lda $0f8000			lda 	IF_PBreak					; non-zero if Ctrl+C pressed.
.0181e5	60		rts				rts
.0181e6					IF_GetKey:
.0181e6	af 10 80 0f	lda $0f8010			lda 	IF_PKeyboard				; read keyboard
.0181ea	f0 08		beq $0181f4			beq		_IFGK_NoKey 				; skip if zero,no key pressed
.0181ec	48		pha				pha 								; key pressed, clear queue.
.0181ed	a9 00		lda #$00			lda 	#0
.0181ef	8f 10 80 0f	sta $0f8010			sta 	IF_PKeyboard
.0181f3	68		pla				pla
.0181f4					_IFGK_NoKey:
.0181f4	09 00		ora #$00			ora 	#0							; set Z flag appropriately.
.0181f6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.0181f7					TIM_Error:
.0181f7	20 29 80	jsr $018029			jsr 	IFT_UpLine 					; go up one line.
.0181fa	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.0181fc	80 02		bra $018200			bra 	TIM_ShowPrompt
.0181fe					TIM_NewCommand:
.0181fe	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.018200					TIM_ShowPrompt:
.018200	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.018203	20 fa 80	jsr $0180fa			jsr 	IFT_ReadLine	 			; get character, go to next line
.018206	20 5c 80	jsr $01805c			jsr 	IFT_NewLine					; go to next line.
.018209	86 10		stx $10				stx 	zTemp1 						; save line read address
.01820b	84 11		sty $11				sty 	zTemp1+1
.01820d	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.01820f	b1 10		lda ($10),y			lda 	(zTemp1),y
.018211	c9 3f		cmp #$3f			cmp 	#"?"
.018213	f0 04		beq $018219			beq 	TIM_SkipFirst
.018215	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.018217	d0 01		bne $01821a			bne 	TIM_NotDot
.018219					TIM_SkipFirst:
.018219	c8		iny				iny
.01821a					TIM_NotDot:
.01821a	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.01821c	c9 52		cmp #$52			cmp 	#"R"						; show registers
.01821e	f0 6b		beq $01828b			beq 	TIM_ShowRegisters
.018220	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.018222	f0 12		beq $018236			beq 	TIM_ShowMemory
.018224	c9 47		cmp #$47			cmp 	#"G"						; execute
.018226	f0 49		beq $018271			beq 	TIM_Execute
.018228	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.01822a	f0 07		beq $018233			beq 	TIM_GoLoadMemory
.01822c	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.01822e	d0 c7		bne $0181f7			bne 	TIM_Error
.018230	4c af 83	jmp $0183af			jmp 	TIM_UpdateRegisters
.018233					TIM_GoLoadMemory:
.018233	4c df 83	jmp $0183df			jmp 	TIM_LoadMemory
.018236					TIM_ShowMemory:
.018236	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.018239	b0 bc		bcs $0181f7			bcs 	TIM_Error
.01823b	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.01823d	85 12		sta $12				sta 	zTemp2
.01823f	a5 15		lda $15				lda 	zTemp3+1
.018241	85 13		sta $13				sta 	zTemp2+1
.018243	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.018246	90 08		bcc $018250			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.018248	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.01824a	85 14		sta $14				sta 	zTemp3
.01824c	a5 13		lda $13				lda 	zTemp2+1
.01824e	85 15		sta $15				sta 	zTemp3+1
.018250					_TIMSM_Start:
.018250	20 03 83	jsr $018303			jsr 	TIM_WriteLine 				; write one line of hex out
.018253	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.018255	18		clc				clc
.018256	69 10		adc #$10			adc 	#16
.018258	85 12		sta $12				sta 	zTemp2
.01825a	90 02		bcc $01825e			bcc 	_TIMSM_NoCarry
.01825c	e6 13		inc $13				inc 	zTemp2+1
.01825e					_TIMSM_NoCarry:
.01825e	20 e1 81	jsr $0181e1			jsr 	IF_CheckBreak 				; check CTL+C
.018261	d0 0b		bne $01826e			bne 	_TIMSM_Ends 				; if pressed break out.
.018263	38		sec				sec 								; check past the end address in zTemp3
.018264	a5 14		lda $14				lda 	zTemp3
.018266	e5 12		sbc $12				sbc 	zTemp2
.018268	a5 15		lda $15				lda 	zTemp3+1
.01826a	e5 13		sbc $13				sbc 	zTemp2+1
.01826c	10 e2		bpl $018250			bpl 	_TIMSM_Start
.01826e					_TIMSM_Ends:
.01826e	4c fe 81	jmp $0181fe			jmp 	TIM_NewCommand
.018271					TIM_Execute:
.018271	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; get the execute address
.018274	b0 81		bcs $0181f7			bcs 	TIM_Error 					; not legitimate
.018276	ae b3 04	ldx $04b3			ldx 	TIM_SP 						; set up SP
.018279	9a		txs				txs
.01827a	ad ae 04	lda $04ae			lda 	TIM_SR 						; Status for PLP
.01827d	48		pha				pha
.01827e	ad af 04	lda $04af			lda 	TIM_A 						; restore AXYZ
.018281	ae b0 04	ldx $04b0			ldx 	TIM_X
.018284	ac b1 04	ldy $04b1			ldy 	TIM_Y
.018287	28		plp				plp 								; and PS Byte.
.018288	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.01828b					TIM_Start:
.01828b					TIM_ShowRegisters:
.01828b	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.01828e	8d ad 04	sta $04ad			sta 	TIM_IRQ+1
.018291	ad ff ff	lda $ffff			lda 	$FFFF
.018294	8d ac 04	sta $04ac			sta 	TIM_IRQ
.018297	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.018299					_TIMSR_Text:
.018299	bf ca 82 01	lda $0182ca,x			lda 	_TIMSR_Label,x
.01829d	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182a0	e8		inx				inx
.0182a1	e0 20		cpx #$20			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.0182a3	d0 f4		bne $018299			bne 	_TIMSR_Text
.0182a5	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.0182a7					_TIMSR_Skip:
.0182a7	e8		inx				inx
.0182a8					_TIMSR_LoopSpace:
.0182a8	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.0182aa	b0 04		bcs $0182b0			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.0182ac	8a		txa				txa
.0182ad	4a		lsr a				lsr 	a
.0182ae	b0 05		bcs $0182b5			bcs 	_TIMSR_NoSpace
.0182b0					_TIMSR_Space:
.0182b0	a9 20		lda #$20			lda 	#" "
.0182b2	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182b5					_TIMSR_NoSpace:
.0182b5	bd aa 04	lda $04aa,x			lda 	TIM_PC,x 					; output hex value.
.0182b8	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.0182bb	e8		inx				inx
.0182bc	e0 08		cpx #$08			cpx 	#TIM_Z-TIM_PC
.0182be	f0 e7		beq $0182a7			beq 	_TIMSR_Skip
.0182c0	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.0182c2	d0 e4		bne $0182a8			bne 	_TimSR_LoopSpace
.0182c4	20 5c 80	jsr $01805c			jsr 	IFT_NewLine 				; new line
.0182c7	4c fe 81	jmp $0181fe			jmp	 	TIM_NewCommand 				; new command.
.0182ca					_TIMSR_Label:
>0182ca	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>0182d2	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>0182e2	52
>0182e3	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.0182ea					_TIMSR_LabelEnd:
.0182ea					TIM_WriteHex:
.0182ea	48		pha				pha 								; save A
.0182eb	4a		lsr a				lsr 	a 							; shift MSB->LSB
.0182ec	4a		lsr a				lsr 	a
.0182ed	4a		lsr a				lsr 	a
.0182ee	4a		lsr a				lsr 	a
.0182ef	20 f3 82	jsr $0182f3			jsr 	_TIMWH_Nibble 				; print MSB
.0182f2	68		pla				pla 								; restore and print LSB
.0182f3					_TIMWH_Nibble:
.0182f3	48		pha				pha
.0182f4	29 0f		and #$0f			and 	#15 						; mask out
.0182f6	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.0182f8	90 02		bcc $0182fc			bcc 	_TIMWHNoLetter
.0182fa	69 06		adc #$06			adc 	#6
.0182fc					_TIMWHNoLetter:
.0182fc	69 30		adc #$30			adc 	#48
.0182fe	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter 			; print it out.
.018301	68		pla				pla
.018302	60		rts				rts
.018303					TIM_WriteLine:
.018303	a9 2e		lda #$2e			lda 	#"." 						; prompt
.018305	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018308	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.01830a	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01830d	a5 13		lda $13				lda 	zTemp2+1 					; write address
.01830f	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.018312	a5 12		lda $12				lda 	zTemp2
.018314	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.018317	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.018319					_TIMWL_Loop:
.018319	a9 20		lda #$20			lda 	#" "
.01831b	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01831e	b1 12		lda ($12),y			lda 	(zTemp2),y
.018320	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.018323	c8		iny				iny
.018324	c0 10		cpy #$10			cpy 	#16
.018326	d0 f1		bne $018319			bne 	_TIMWL_Loop
.018328	4c 5c 80	jmp $01805c			jmp 	IFT_NewLine 				; new line and exit
.01832b					TIM_GetHex:
.01832b	c8		iny				iny
.01832c	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.01832e	c9 20		cmp #$20			cmp 	#32
.018330	f0 f9		beq $01832b			beq 	TIM_GetHex
.018332	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.018334	f0 f5		beq $01832b			beq 	TIM_GetHex
.018336	20 5f 83	jsr $01835f			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.018339	b0 23		bcs $01835e			bcs 	_TIMGH_Exit					; if first bad then exit now.
.01833b	a9 00		lda #$00			lda 	#0 							; zero result
.01833d	85 14		sta $14				sta 	zTemp3
.01833f	85 15		sta $15				sta 	zTemp3+1
.018341					_TIM_GHLoop:
.018341	20 5f 83	jsr $01835f			jsr 	TIM_GetHexCharacter 		; get next character
.018344	b0 17		bcs $01835d			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.018346	c8		iny				iny 								; skip over it.
.018347	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.018349	26 15		rol $15				rol 	zTemp3+1
.01834b	06 14		asl $14				asl 	zTemp3 						; now x 2
.01834d	26 15		rol $15				rol 	zTemp3+1
.01834f	06 14		asl $14				asl 	zTemp3						; now x 4
.018351	26 15		rol $15				rol 	zTemp3+1
.018353	06 14		asl $14				asl 	zTemp3 						; now x 8
.018355	26 15		rol $15				rol 	zTemp3+1
.018357	05 14		ora $14				ora 	zTemp3 						; OR result in
.018359	85 14		sta $14				sta 	zTemp3
.01835b	80 e4		bra $018341			bra 	_TIM_GHLoop 				; loop round again.
.01835d					_TIMGH_Okay:
.01835d	18		clc				clc
.01835e					_TIMGH_Exit:
.01835e	60		rts				rts
.01835f					TIM_GetHexCharacter:
.01835f	b1 10		lda ($10),y			lda 	(zTemp1),y
.018361	38		sec				sec
.018362	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.018364	90 0e		bcc $018374			bcc 	_TIM_GHCFail
.018366	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.018368	90 0b		bcc $018375			bcc 	_TIM_GHCExit
.01836a	c9 11		cmp #$11			cmp 	#65-48						; < A
.01836c	90 06		bcc $018374			bcc		_TIM_GHCFail
.01836e	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.018370	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.018372	90 01		bcc $018375			bcc		_TIM_GHCExit
.018374					_TIM_GHCFail:
.018374	38		sec				sec
.018375					_TIM_GHCExit:
.018375	60		rts				rts
.018376					TIM_BreakVector:
.018376	da		phx				phx									; save X/A on stack
.018377	48		pha				pha
.018378	ba		tsx				tsx 								; X points to S
.018379	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.01837c	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.01837e	d0 03		bne $018383			bne 	_TIMBreak					; if set, it's BRK
.018380	68		pla				pla 								; abandon routine.
.018381	fa		plx				plx
.018382	40		rti				rti
.018383					_TIMBreak:
.018383	68		pla				pla 								; save A X Y and maybe Z
.018384	8d af 04	sta $04af			sta 	TIM_A
.018387	fa		plx				plx
.018388	8e b0 04	stx $04b0			stx 	TIM_X
.01838b	8c b1 04	sty $04b1			sty 	TIM_Y
.01838e	68		pla				pla 								; get Status Register
.01838f	8d ae 04	sta $04ae			sta 	TIM_SR
.018392	68		pla				pla
.018393	8d ab 04	sta $04ab			sta 	TIM_PC+1 					; save calling address
.018396	68		pla				pla
.018397	8d aa 04	sta $04aa			sta 	TIM_PC 						; high byte
.01839a	ad ab 04	lda $04ab			lda 	TIM_PC+1 					; dec PC to point right.
.01839d	d0 03		bne $0183a2			bne 	_TIMDecrement 				; brk bumps it.
.01839f	ce aa 04	dec $04aa			dec 	TIM_PC
.0183a2					_TIMDecrement:
.0183a2	ce ab 04	dec $04ab			dec 	TIM_PC+1
.0183a5	ba		tsx				tsx 								; and copy SP
.0183a6	8e b3 04	stx $04b3			stx 	TIM_SP
.0183a9	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.0183ab	9a		txs				txs
.0183ac	4c 8b 82	jmp $01828b			jmp 	TIM_Start 					; and start up TIM monitor.
.0183af					TIM_UpdateRegisters:
.0183af	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; PC
.0183b2	b0 28		bcs $0183dc			bcs 	_TIMURFail
.0183b4	a5 14		lda $14				lda 	zTemp3
.0183b6	8d ab 04	sta $04ab			sta 	Tim_PC+1
.0183b9	a5 15		lda $15				lda 	zTemp3+1
.0183bb	8d aa 04	sta $04aa			sta 	Tim_PC
.0183be	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; ignore IRQ
.0183c1	b0 19		bcs $0183dc			bcs 	_TIMURFail
.0183c3	a2 00		ldx #$00			ldx 	#0
.0183c5					_TIM_URLoop:
.0183c5	e0 04		cpx #$04			cpx 	#Tim_Z-Tim_SR
.0183c7	d0 01		bne $0183ca			bne 	_TIM_1
.0183c9	e8		inx				inx
.0183ca					_TIM_1:
.0183ca	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; registers
.0183cd	b0 0d		bcs $0183dc			bcs 	_TIMURFail
.0183cf	a5 14		lda $14				lda 	zTemp3
.0183d1	9d ae 04	sta $04ae,x			sta 	Tim_SR,x
.0183d4	e8		inx				inx
.0183d5	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.0183d7	d0 ec		bne $0183c5			bne 	_TIM_URLoop
.0183d9	4c fe 81	jmp $0181fe			jmp 	TIM_NewCommand
.0183dc					_TIMURFail:
.0183dc	4c f7 81	jmp $0181f7			jmp 	TIM_Error
.0183df					TIM_LoadMemory:
.0183df	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; target address => zTemp2
.0183e2	a5 14		lda $14				lda 	zTemp3
.0183e4	85 12		sta $12				sta 	zTemp2
.0183e6	a5 15		lda $15				lda 	zTemp3+1
.0183e8	85 13		sta $13				sta 	zTemp2+1
.0183ea					_TIM_LMLoop:
.0183ea	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; next byte ?
.0183ed	b0 0e		bcs $0183fd			bcs 	_TIMLMDone 					; no more
.0183ef	a2 00		ldx #$00			ldx 	#0							; write out.
.0183f1	a5 14		lda $14				lda 	zTemp3
.0183f3	81 12		sta ($12,x)			sta 	(zTemp2,x)
.0183f5	e6 12		inc $12				inc 	zTemp2 						; bump address
.0183f7	d0 f1		bne $0183ea			bne 	_TIM_LMLoop
.0183f9	e6 13		inc $13				inc 	zTemp2+1
.0183fb	80 ed		bra $0183ea			bra 	_TIM_LMLoop
.0183fd					_TIMLMDone:
.0183fd	4c fe 81	jmp $0181fe			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/errors.asm

.018400					SyntaxError:
.018400	20 2f 84	jsr $01842f			jsr 	ERR_Handler
>018403	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>01840b	72 72 6f 72 00
.018410					TypeError:
.018410	20 2f 84	jsr $01842f			jsr 	ERR_Handler
>018413	57 72 6f 6e 67 20 74 79				.text 	"Wrong type",0
>01841b	70 65 00
.01841e					BadParamError:
.01841e	20 2f 84	jsr $01842f			jsr 	ERR_Handler
>018421	42 61 64 20 50 61 72 61				.text 	"Bad Parameter",0
>018429	6d 65 74 65 72 00
.01842f					ERR_Handler:
.01842f	a0 00		ldy #$00			ldy 	#0
.018431	c8		iny				iny
.018432	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018434	8d 08 03	sta $0308			sta 	XS_Mantissa
.018437	c8		iny				iny
.018438	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01843a	8d 09 03	sta $0309			sta 	XS_Mantissa+1
.01843d	fa		plx				plx 								; address in XY
.01843e	7a		ply				ply
.01843f	e8		inx				inx 								; bump, because of RTS/JSR address -1
.018440	d0 01		bne $018443			bne 	_EHNoSkip
.018442	c8		iny				iny
.018443					_EHNoSkip:
.018443	20 64 84	jsr $018464			jsr 	PrintROMMessage 			; print message from ROM.
.018446	ad 08 03	lda $0308			lda 	XS_Mantissa					; line number = 0
.018449	0d 09 03	ora $0309			ora 	XS_Mantissa+1
.01844c	f0 0c		beq $01845a			beq 	_EHNoLine
.01844e	a2 5f		ldx #$5f			ldx 	#_EHAt & $FF 				; print " at "
.018450	a0 84		ldy #$84			ldy 	#(_EHAt >> 8) & $FF
.018452	20 64 84	jsr $018464			jsr 	PrintROMMessage
.018455	a2 00		ldx #$00			ldx 	#0 							; Print line number
.018457	20 79 84	jsr $018479			jsr 	Print16BitInteger
.01845a					_EHNoLine:
.01845a	80 fe		bra $01845a			bra 	_EHNoLine
.01845c	4c d7 86	jmp $0186d7			jmp 	WarmStart
>01845f	20 61 74 20 00			_EHAt:	.text 	" at ",0
.018464					PrintROMMessage:
.018464	86 1a		stx $1a				stx 	zLTemp1 					; save addres
.018466	84 1b		sty $1b				sty 	zLTemp1+1
.018468	4b		phk				phk
.018469	68		pla				pla
.01846a	85 1c		sta $1c				sta 	ZLTemp1+2
.01846c	a0 00		ldy #$00			ldy 	#0
.01846e					_PRMLoop:
.01846e	b7 1a		lda [$1a],y			lda 	[zLTemp1],y
.018470	f0 06		beq $018478			beq		_PRMExit
.018472	c8		iny				iny
.018473	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018476	80 f6		bra $01846e			bra 	_PRMLoop
.018478					_PRMExit:
.018478	60		rts				rts
.018479					Print16BitInteger:
.018479	a9 00		lda #$00			lda 	#0 							; make 32 bit
.01847b	8d 0a 03	sta $030a			sta 	XS_Mantissa+2
.01847e	8d 0b 03	sta $030b			sta 	XS_Mantissa+3
.018481	8d 06 04	sta $0406			sta 	NumBufX 					; reset the conversion pointer
.018484	aa		tax				tax 								; convert bottom level.
.018485	20 02 97	jsr $019702			jsr 	INTToString 				; make string
.018488	a2 00		ldx #$00			ldx 	#0 							; print buffer
.01848a	bd 07 04	lda $0407,x	_P1Loop:lda 	Num_Buffer,x
.01848d	f0 06		beq $018495			beq 	_P1Exit
.01848f	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018492	e8		inx				inx
.018493	80 f5		bra $01848a			bra 	_P1Loop
.018495	60		rts		_P1Exit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm


;******  Processing file: modules/basic/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b6					lastUnaryFunction = $b6
.018496					VectorTable:
>018496	94 8a					.word BinaryOp_And         & $FFFF ; $80 and
>018498	bc 8a					.word BinaryOp_Or          & $FFFF ; $81 or
>01849a	e4 8a					.word BinaryOp_Xor         & $FFFF ; $82 xor
>01849c	e4 8a					.word BinaryOp_Eor         & $FFFF ; $83 eor
>01849e	28 8b					.word Binary_Equal         & $FFFF ; $84 =
>0184a0	47 8b					.word Binary_NotEqual      & $FFFF ; $85 <>
>0184a2	50 8b					.word Binary_Less          & $FFFF ; $86 <
>0184a4	59 8b					.word Binary_LessEqual     & $FFFF ; $87 <=
>0184a6	6b 8b					.word Binary_Greater       & $FFFF ; $88 >
>0184a8	62 8b					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>0184aa	00 8c					.word BinaryOp_Add         & $FFFF ; $8a +
>0184ac	20 8c					.word BinaryOp_Subtract    & $FFFF ; $8b -
>0184ae	33 8c					.word BinaryOp_Multiply    & $FFFF ; $8c *
>0184b0	46 8c					.word BinaryOp_Divide      & $FFFF ; $8d /
>0184b2	52 85					.word NotImplemented       & $FFFF ; $8e ^
>0184b4	52 85					.word NotImplemented       & $FFFF ; $8f if
>0184b6	52 85					.word NotImplemented       & $FFFF ; $90 while
>0184b8	52 85					.word NotImplemented       & $FFFF ; $91 repeat
>0184ba	52 85					.word NotImplemented       & $FFFF ; $92 for
>0184bc	52 85					.word NotImplemented       & $FFFF ; $93 then
>0184be	52 85					.word NotImplemented       & $FFFF ; $94 endif
>0184c0	52 85					.word NotImplemented       & $FFFF ; $95 wend
>0184c2	52 85					.word NotImplemented       & $FFFF ; $96 until
>0184c4	52 85					.word NotImplemented       & $FFFF ; $97 next
>0184c6	52 85					.word NotImplemented       & $FFFF ; $98 not
>0184c8	52 85					.word NotImplemented       & $FFFF ; $99 fn(
>0184ca	7a 8d					.word Unary_Abs            & $FFFF ; $9a abs(
>0184cc	d2 8e					.word Unary_Asc            & $FFFF ; $9b asc(
>0184ce	e7 9e					.word Unary_Int            & $FFFF ; $9c int(
>0184d0	98 8d					.word Unary_Peek           & $FFFF ; $9d peek(
>0184d2	5e 9e					.word Unary_Rnd            & $FFFF ; $9e rnd(
>0184d4	0c 8e					.word Unary_Usr            & $FFFF ; $9f usr(
>0184d6	13 8f					.word Unary_Left           & $FFFF ; $a0 left$(
>0184d8	2a 8f					.word Unary_Right          & $FFFF ; $a1 right$(
>0184da	f8 8e					.word Unary_Mid            & $FFFF ; $a2 mid$(
>0184dc	8c 90					.word Unary_Spc            & $FFFF ; $a3 spc(
>0184de	9f 8e					.word Unary_Str            & $FFFF ; $a4 str$(
>0184e0	2e 8e					.word Unary_Val            & $FFFF ; $a5 val(
>0184e2	e9 8e					.word Unary_Len            & $FFFF ; $a6 len(
>0184e4	a8 8f					.word Unary_Hex            & $FFFF ; $a7 hex$(
>0184e6	52 85					.word NotImplemented       & $FFFF ; $a8 sin(
>0184e8	52 85					.word NotImplemented       & $FFFF ; $a9 cos(
>0184ea	52 85					.word NotImplemented       & $FFFF ; $aa tan(
>0184ec	52 85					.word NotImplemented       & $FFFF ; $ab atn(
>0184ee	52 85					.word NotImplemented       & $FFFF ; $ac exp(
>0184f0	52 85					.word NotImplemented       & $FFFF ; $ad log(
>0184f2	52 85					.word NotImplemented       & $FFFF ; $ae sqr(
>0184f4	02 90					.word Unary_Dec            & $FFFF ; $af dec(
>0184f6	9c 8d					.word Unary_Deek           & $FFFF ; $b0 deek(
>0184f8	a0 8d					.word Unary_Leek           & $FFFF ; $b1 leek(
>0184fa	d4 8d					.word Unary_Mod            & $FFFF ; $b2 mod(
>0184fc	28 8d					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>0184fe	6a 90					.word Unary_Chr            & $FFFF ; $b4 chr$(
>018500	52 85					.word NotImplemented       & $FFFF ; $b5 pos(
>018502	52 85					.word NotImplemented       & $FFFF ; $b6 tab(
>018504	52 85					.word NotImplemented       & $FFFF ; $b7 $
>018506	52 85					.word NotImplemented       & $FFFF ; $b8 $(
>018508	52 85					.word NotImplemented       & $FFFF ; $b9 #
>01850a	52 85					.word NotImplemented       & $FFFF ; $ba #(
>01850c	52 85					.word NotImplemented       & $FFFF ; $bb %
>01850e	52 85					.word NotImplemented       & $FFFF ; $bc %(
>018510	52 85					.word NotImplemented       & $FFFF ; $bd (
>018512	52 85					.word NotImplemented       & $FFFF ; $be )
>018514	52 85					.word NotImplemented       & $FFFF ; $bf ,
>018516	ec 87					.word Command_COLON        & $FFFF ; $c0 :
>018518	52 85					.word NotImplemented       & $FFFF ; $c1 ;
>01851a	52 85					.word NotImplemented       & $FFFF ; $c2 def
>01851c	a1 88					.word Command_CLR          & $FFFF ; $c3 clr
>01851e	b2 88					.word Command_STOP         & $FFFF ; $c4 stop
>018520	52 85					.word NotImplemented       & $FFFF ; $c5 data
>018522	52 85					.word NotImplemented       & $FFFF ; $c6 read
>018524	e5 86					.word Command_DIM          & $FFFF ; $c7 dim
>018526	52 85					.word NotImplemented       & $FFFF ; $c8 to
>018528	52 85					.word NotImplemented       & $FFFF ; $c9 step
>01852a	52 85					.word NotImplemented       & $FFFF ; $ca gosub
>01852c	52 85					.word NotImplemented       & $FFFF ; $cb return
>01852e	52 85					.word NotImplemented       & $FFFF ; $cc goto
>018530	0e 88					.word Command_END          & $FFFF ; $cd end
>018532	52 85					.word NotImplemented       & $FFFF ; $ce input
>018534	ed 87					.word Command_LET          & $FFFF ; $cf let
>018536	52 85					.word NotImplemented       & $FFFF ; $d0 list
>018538	52 85					.word NotImplemented       & $FFFF ; $d1 new
>01853a	52 85					.word NotImplemented       & $FFFF ; $d2 old
>01853c	52 85					.word NotImplemented       & $FFFF ; $d3 on
>01853e	52 85					.word NotImplemented       & $FFFF ; $d4 restore
>018540	52 85					.word NotImplemented       & $FFFF ; $d5 poke
>018542	12 88					.word Command_PRINT        & $FFFF ; $d6 print
>018544	72 87					.word Command_RUN          & $FFFF ; $d7 run
>018546	52 85					.word NotImplemented       & $FFFF ; $d8 wait
>018548	52 85					.word NotImplemented       & $FFFF ; $d9 sys
>01854a	52 85					.word NotImplemented       & $FFFF ; $da doke
>01854c	52 85					.word NotImplemented       & $FFFF ; $db loke
>01854e	85 88					.word Command_ASSERT       & $FFFF ; $dc assert
>018550	52 85					.word NotImplemented       & $FFFF ; $dd get
.018552					NotImplemented:
.018552	20 2f 84	jsr $01842f			jsr ERR_Handler
>018555	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>01855d	65 6d 65 6e 74 65 64 00
.018565					BinaryPrecedence:
>018565	01					.byte 1    ; $80 and
>018566	01					.byte 1    ; $81 or
>018567	01					.byte 1    ; $82 xor
>018568	01					.byte 1    ; $83 eor
>018569	02					.byte 2    ; $84 =
>01856a	02					.byte 2    ; $85 <>
>01856b	02					.byte 2    ; $86 <
>01856c	02					.byte 2    ; $87 <=
>01856d	02					.byte 2    ; $88 >
>01856e	02					.byte 2    ; $89 >=
>01856f	03					.byte 3    ; $8a +
>018570	03					.byte 3    ; $8b -
>018571	04					.byte 4    ; $8c *
>018572	04					.byte 4    ; $8d /
>018573	05					.byte 5    ; $8e ^
.018574					KeywordText:
>018574	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>018577	4f d2					.byte $4f,$d2                          ; $81 or
>018579	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>01857c	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>01857f	bd					.byte $bd                              ; $84 =
>018580	3c be					.byte $3c,$be                          ; $85 <>
>018582	bc					.byte $bc                              ; $86 <
>018583	3c bd					.byte $3c,$bd                          ; $87 <=
>018585	be					.byte $be                              ; $88 >
>018586	3e bd					.byte $3e,$bd                          ; $89 >=
>018588	ab					.byte $ab                              ; $8a +
>018589	ad					.byte $ad                              ; $8b -
>01858a	aa					.byte $aa                              ; $8c *
>01858b	af					.byte $af                              ; $8d /
>01858c	de					.byte $de                              ; $8e ^
>01858d	49 c6					.byte $49,$c6                          ; $8f if
>01858f	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>018594	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>01859a	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>01859d	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>0185a1	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>0185a6	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>0185aa	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>0185af	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>0185b3	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>0185b6	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>0185b9	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>0185bd	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>0185c1	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>0185c5	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>0185ca	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>0185ce	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>0185d2	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>0185d8	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>0185df	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>0185e4	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>0185e8	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>0185ed	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>0185f1	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>0185f5	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>0185fa	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>0185fe	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>018602	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>018606	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>01860a	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>01860e	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>018612	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>018616	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>01861a	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>01861f	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>018624	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>018628	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>01862c	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>018631	50 4f 53 a8				.byte $50,$4f,$53,$a8                  ; $b5 pos(
>018635	54 41 42 a8				.byte $54,$41,$42,$a8                  ; $b6 tab(
>018639	a4					.byte $a4                              ; $b7 $
>01863a	24 a8					.byte $24,$a8                          ; $b8 $(
>01863c	a3					.byte $a3                              ; $b9 #
>01863d	23 a8					.byte $23,$a8                          ; $ba #(
>01863f	a5					.byte $a5                              ; $bb %
>018640	25 a8					.byte $25,$a8                          ; $bc %(
>018642	a8					.byte $a8                              ; $bd (
>018643	a9					.byte $a9                              ; $be )
>018644	ac					.byte $ac                              ; $bf ,
>018645	ba					.byte $ba                              ; $c0 :
>018646	bb					.byte $bb                              ; $c1 ;
>018647	44 45 c6				.byte $44,$45,$c6                      ; $c2 def
>01864a	43 4c d2				.byte $43,$4c,$d2                      ; $c3 clr
>01864d	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $c4 stop
>018651	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c5 data
>018655	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c6 read
>018659	44 49 cd				.byte $44,$49,$cd                      ; $c7 dim
>01865c	54 cf					.byte $54,$cf                          ; $c8 to
>01865e	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c9 step
>018662	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $ca gosub
>018667	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $cb return
>01866d	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $cc goto
>018671	45 4e c4				.byte $45,$4e,$c4                      ; $cd end
>018674	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $ce input
>018679	4c 45 d4				.byte $4c,$45,$d4                      ; $cf let
>01867c	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $d0 list
>018680	4e 45 d7				.byte $4e,$45,$d7                      ; $d1 new
>018683	4f 4c c4				.byte $4f,$4c,$c4                      ; $d2 old
>018686	4f ce					.byte $4f,$ce                          ; $d3 on
>018688	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d4 restore
>01868f	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d5 poke
>018693	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d6 print
>018698	52 55 ce				.byte $52,$55,$ce                      ; $d7 run
>01869b	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d8 wait
>01869f	53 59 d3				.byte $53,$59,$d3                      ; $d9 sys
>0186a2	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $da doke
>0186a6	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $db loke
>0186aa	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $dc assert
>0186b0	47 45 d4				.byte $47,$45,$d4                      ; $dd get
>0186b3	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_pos = $b5
=$b6					token_tab = $b6
=$b7					token_dollar = $b7
=$b8					token_dollarlparen = $b8
=$b9					token_hash = $b9
=$ba					token_hashlparen = $ba
=$bb					token_percent = $bb
=$bc					token_percentlparen = $bc
=$bd					token_lparen = $bd
=$be					token_rparen = $be
=$bf					token_comma = $bf
=$c0					token_colon = $c0
=$c1					token_semicolon = $c1
=$c2					token_def = $c2
=$c3					token_clr = $c3
=$c4					token_stop = $c4
=$c5					token_data = $c5
=$c6					token_read = $c6
=$c7					token_dim = $c7
=$c8					token_to = $c8
=$c9					token_step = $c9
=$ca					token_gosub = $ca
=$cb					token_return = $cb
=$cc					token_goto = $cc
=$cd					token_end = $cd
=$ce					token_input = $ce
=$cf					token_let = $cf
=$d0					token_list = $d0
=$d1					token_new = $d1
=$d2					token_old = $d2
=$d3					token_on = $d3
=$d4					token_restore = $d4
=$d5					token_poke = $d5
=$d6					token_print = $d6
=$d7					token_run = $d7
=$d8					token_wait = $d8
=$d9					token_sys = $d9
=$da					token_doke = $da
=$db					token_loke = $db
=$dc					token_assert = $dc
=$dd					token_get = $dd

;******  Return to file: modules/basic/core.asm

.0186b4					BASIC_Start:
.0186b4	20 a8 81	jsr $0181a8			jsr 	IF_Reset 					; set up and clear screen.
.0186b7	20 00 80	jsr $018000			jsr 	IFT_ClearScreen
.0186ba	a9 5c		lda #$5c			lda 	#$5C 						; JMP Long opcode
.0186bc	8d 04 03	sta $0304			sta 	LocalVector
.0186bf	8d 00 03	sta $0300			sta 	UserVector
.0186c2	a9 1c		lda #$1c			lda 	#USRDefault & $FF 			; reset USR vector
.0186c4	8d 01 03	sta $0301			sta 	UserVector+1
.0186c7	a9 8e		lda #$8e			lda 	#(USRDefault >> 8) & $FF
.0186c9	8d 02 03	sta $0302			sta 	UserVector+2
.0186cc	a9 01		lda #$01			lda 	#(USRDefault >> 16) & $FF
.0186ce	8d 03 03	sta $0303			sta 	UserVector+3
.0186d1	20 dd 90	jsr $0190dd			jsr 	UpdateProgramEnd 			; update the program end.
.0186d4	20 a1 88	jsr $0188a1			jsr 	ResetRunStatus 				; clear everything (CLR command)
.0186d7					WarmStart:
.0186d7	c2 30		rep #$30			rep 	#$30
.0186d9	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.0186dc	1b		tcs				tcs
.0186dd	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.0186e0	e2 30		sep #$30			sep 	#$30
.0186e2	4c 72 87	jmp $018772			jmp 	COMMAND_Run

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/dim.asm

.0186e5					Command_DIM:
.0186e5	98		tya				tya
.0186e6	48		pha				pha 								; push on stack.
.0186e7	20 3b 92	jsr $01923b			jsr 	VariableExtract 			; get the identifier
.0186ea	ad 87 04	lda $0487			lda 	Var_Type 					; check it is an array
.0186ed	29 01		and #$01			and 	#1
.0186ef	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.0186f1	d0 71		bne $018764			bne 	_CDIError
.0186f3	a9 00		lda #$00			lda 	#0 							; reset the DIM index. The dimensions are
.0186f5	8d a9 04	sta $04a9			sta 	UsrArrayIdx 				; built up here and copied in case we autodim
.0186f8					_CDIGetDimension:
.0186f8	ad a9 04	lda $04a9			lda 	UsrArrayIdx 				; done too many ?
.0186fb	c9 06		cmp #$06			cmp 	#ArrayMaxDim*2
.0186fd	f0 65		beq $018764			beq 	_CDIError
.0186ff	20 bd 88	jsr $0188bd			jsr 	EvaluateExpression 			; evaluate an index size
.018702	ad 09 03	lda $0309			lda 	XS_Mantissa+1 				; check in range 0-7FFF
.018705	29 80		and #$80			and 	#$80
.018707	0d 0a 03	ora $030a			ora 	XS_Mantissa+2
.01870a	0d 0b 03	ora $030b			ora 	XS_Mantissa+3
.01870d	d0 55		bne $018764			bne 	_CDIError
.01870f	ae a9 04	ldx $04a9			ldx 	UsrArrayIdx 				; copy into the array table.
.018712	18		clc				clc 								; add 1 - max index => size.
.018713	ad 08 03	lda $0308			lda 	XS_Mantissa+0
.018716	69 01		adc #$01			adc 	#1
.018718	9d a1 04	sta $04a1,x			sta 	UsrArrayDef+0,x
.01871b	ad 09 03	lda $0309			lda 	XS_Mantissa+1
.01871e	69 00		adc #$00			adc 	#0
.018720	9d a2 04	sta $04a2,x			sta 	UsrArrayDef+1,x
.018723	30 3f		bmi $018764			bmi 	_CDIError 					; could be dim a(32767)
.018725	e8		inx				inx 								; bump index.
.018726	e8		inx				inx
.018727	8e a9 04	stx $04a9			stx 	UsrArrayIdx
.01872a	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01872c	c8		iny				iny
.01872d	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another dimension
.01872f	f0 c7		beq $0186f8			beq 	_CDIGetDimension
.018731	88		dey				dey
.018732	20 2b 91	jsr $01912b			jsr 	CheckNextRParen 			; closing ) present ?
.018735	ae a9 04	ldx $04a9			ldx 	UsrArrayIdx 				; copy USR array to default
.018738	a9 ff		lda #$ff			lda 	#$FF 						; put end marker in ArrayDef
.01873a	9d 9a 04	sta $049a,x			sta 	ArrayDef+1,x
.01873d					_CDICopy:
.01873d	bd a1 04	lda $04a1,x			lda 	UsrArrayDef,x
.018740	9d 99 04	sta $0499,x			sta 	ArrayDef,x
.018743	ca		dex				dex
.018744	10 f7		bpl $01873d			bpl 	_CDICopy
.018746	68		pla				pla									; position of array identifier
.018747	85 10		sta $10				sta 	zTemp1
.018749	98		tya				tya
.01874a	48		pha				pha
.01874b	a5 10		lda $10				lda 	zTemp1 						; point to identifier
.01874d	a8		tay				tay
.01874e	20 3b 92	jsr $01923b			jsr 	VariableExtract 			; get the identifier
.018751	20 dd 94	jsr $0194dd			jsr 	VariableLocate 				; check if it exists already.
.018754	b0 0e		bcs $018764			bcs 	_CDIError
.018756	20 c7 92	jsr $0192c7			jsr 	VariableCreate 				; create it using the current ArrayDef
.018759	68		pla				pla 								; restore code position
.01875a	a8		tay				tay
.01875b	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01875d	c8		iny				iny
.01875e	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another DIM
.018760	f0 83		beq $0186e5			beq 	Command_DIM
.018762	88		dey				dey
.018763	60		rts				rts
.018764					_CDIError:
.018764	20 2f 84	jsr $01842f			jsr ERR_Handler
>018767	42 61 64 20 44 49 4d 00			.text "Bad DIM",0
.01876f					_CDISyntax:
.01876f	4c 00 84	jmp $018400			jmp 	SyntaxError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/run.asm

.018772					Command_RUN:
.018772	20 a1 88	jsr $0188a1			jsr 	ResetRunStatus 				; clear, reset stacks etc.
.018775	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018777	85 16		sta $16				sta 	zCodePtr+0
.018779	a9 10		lda #$10			lda 	#BasicProgram >> 8
.01877b	85 17		sta $17				sta 	zCodePtr+1
.01877d	a9 00		lda #$00			lda 	#0
.01877f	85 18		sta $18				sta 	zCodePtr+2
.018781	85 19		sta $19				sta 	zCodePtr+3
.018783	a0 03		ldy #$03			ldy 	#3
.018785					RUN_NewLine:
.018785	a0 00		ldy #$00			ldy 	#0
.018787	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018789	c8		iny				iny
.01878a	c8		iny				iny
.01878b	c8		iny				iny
.01878c	c9 00		cmp #$00			cmp 	#0 							; if the offset is zero then END.
.01878e	d0 16		bne $0187a6			bne 	RUN_NextCommand
.018790	4c b2 88	jmp $0188b2			jmp 	Command_STOP 				; go do the command code.
.018793					RUN_Skip:
.018793	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018795	c8		iny				iny 								; skip
.018796	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018798	90 0c		bcc $0187a6			bcc 	_SEDone 					; so just skip over it.
.01879a	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.01879c	90 07		bcc $0187a5			bcc 	_SEDouble
.01879e	98		tya				tya 								; this is Y + 1
.01879f	18		clc				clc
.0187a0	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.0187a2	a8		tay				tay 								; back in Y.
.0187a3	88		dey				dey 								; fix up, one for the +1, one for the iny
.0187a4	88		dey				dey
.0187a5					_SEDouble:
.0187a5	c8		iny				iny
.0187a6					_SEDone:
.0187a6					RUN_NextCommand:
.0187a6	a9 00		lda #$00			lda 	#0 							; this resets temporary string allocation.
.0187a8	85 21		sta $21				sta 	zTempStr+1 					; (initialised when first called)
.0187aa	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0187ac	c9 c0		cmp #$c0			cmp 	#token_Colon 				; skip over colons
.0187ae	f0 e3		beq $018793			beq 	RUN_Skip
.0187b0	c9 00		cmp #$00			cmp 	#0 							; if non-zero execute whatever
.0187b2	d0 0f		bne $0187c3			bne 	RUN_Execute
.0187b4					RUN_NextLine:
.0187b4	a0 00		ldy #$00			ldy 	#0 							; point to offset
.0187b6	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.0187b8	18		clc				clc
.0187b9	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.0187bb	85 16		sta $16				sta 	zCodePtr
.0187bd	90 02		bcc $0187c1			bcc 	_SNLNoCarry
.0187bf	e6 17		inc $17				inc 	zCodePtr+1
.0187c1					_SNLNoCarry:
.0187c1	80 c2		bra $018785			bra 	RUN_NewLine 				; go do the new line code
.0187c3					RUN_Execute:
.0187c3	c9 f8		cmp #$f8			cmp 	#$F8 						; handle shifts, REM etc.
.0187c5	b0 1e		bcs $0187e5			bcs 	RUN_Extension
.0187c7	c8		iny				iny
.0187c8	0a		asl a				asl 	a 							; double the character read.
.0187c9	90 14		bcc $0187df			bcc 	RUN_Default 				; if carry clear was $00-$7F, so try LET.
.0187cb	aa		tax				tax 								; ready to look up.
.0187cc	bf 96 84 01	lda $018496,x			lda 	VectorTable,x 				; copy address into LocalVector
.0187d0	8d 05 03	sta $0305			sta 	LocalVector+1
.0187d3	bf 97 84 01	lda $018497,x			lda 	VectorTable+1,x
.0187d7	8d 06 03	sta $0306			sta 	LocalVector+2
.0187da	20 cd 89	jsr $0189cd			jsr 	EVCallLocalVector 			; execute the appropriate code.
.0187dd	80 c7		bra $0187a6			bra 	RUN_NextCommand 			; do the next command.
.0187df					RUN_Default:
.0187df	88		dey				dey
.0187e0	20 ed 87	jsr $0187ed			jsr 	Command_LET 				; and try LET.
.0187e3	80 c1		bra $0187a6			bra 	RUN_NextCommand
.0187e5					RUN_Extension:
.0187e5	c9 ff		cmp #$ff			cmp 	#$FF 						; if $FF (REM)
.0187e7	f0 aa		beq $018793			beq 	RUN_Skip 					; skip over it.
.0187e9	4c 00 84	jmp $018400			jmp 	SyntaxError
.0187ec					Command_COLON:
.0187ec	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/let.asm

.0187ed					Command_LET:
.0187ed	20 ce 91	jsr $0191ce			jsr 	VariableFind 				; get reference to one variable.
.0187f0	a9 84		lda #$84			lda 	#token_Equal  				; get equals
.0187f2	20 14 91	jsr $019114			jsr 	CheckNextToken
.0187f5	a5 22		lda $22				lda 	zVarDataPtr 				; save variable info on stack
.0187f7	48		pha				pha
.0187f8	a5 23		lda $23				lda 	zVarDataPtr+1
.0187fa	48		pha				pha
.0187fb	a5 24		lda $24				lda 	zVarType
.0187fd	48		pha				pha
.0187fe	20 bd 88	jsr $0188bd			jsr 	EvaluateExpression 			; evaluate the RHS.
.018801	68		pla				pla 								; restore target variable information.
.018802	85 24		sta $24				sta 	zVarType
.018804	68		pla				pla
.018805	85 23		sta $23				sta 	zVarDataPtr+1
.018807	68		pla				pla
.018808	85 22		sta $22				sta 	zVarDataPtr
.01880a	20 80 95	jsr $019580			jsr 	VariableSet 				; set the value out.
.01880d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/end.asm

.01880e					Command_END:
>01880e	02						.byte 	2
.01880f	4c d7 86	jmp $0186d7			jmp 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/print.asm

.018812					Command_PRINT:
.018812	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018814	c9 00		cmp #$00			cmp 	#0 							; end
.018816	f0 69		beq $018881			beq 	_CPR_NewLine
.018818	c9 c0		cmp #$c0			cmp 	#token_Colon
.01881a	f0 65		beq $018881			beq 	_CPR_NewLine
.01881c	c9 c1		cmp #$c1			cmp 	#token_SemiColon
.01881e	f0 54		beq $018874			beq 	_CPR_Skip
.018820	c9 bf		cmp #$bf			cmp 	#token_Comma
.018822	f0 4d		beq $018871			beq 	_CPR_Tab
.018824	20 bd 88	jsr $0188bd			jsr 	EvaluateExpression 			; get expression.
.018827	ad 0d 03	lda $030d			lda 	XS_Type 					; get type.
.01882a	29 02		and #$02			and 	#2
.01882c	d0 25		bne $018853			bne 	_CPR_String 				; if type = 2 output as string.
.01882e					_CPR_Number:
.01882e	a9 00		lda #$00			lda 	#0 							; reset buffer index
.018830	8d 06 04	sta $0406			sta 	NumBufX
.018833	ad 0d 03	lda $030d			lda 	XS_Type 					; get type
.018836	4a		lsr a				lsr 	a
.018837	b0 05		bcs $01883e			bcs 	_CPRInt 					; if msb set do as integer
.018839	20 16 9d	jsr $019d16			jsr 	FPToString 					; call fp to str otherwise
.01883c	80 03		bra $018841			bra 	_CPRNPrint
.01883e	20 02 97	jsr $019702	_CPRInt:jsr 	IntToString
.018841					_CPRNPrint:
.018841	ad 07 04	lda $0407			lda 	Num_Buffer 					; is first character -
.018844	c9 2d		cmp #$2d			cmp 	#"-"
.018846	f0 05		beq $01884d			beq 	_CPRNoSpace
.018848	a9 20		lda #$20			lda 	#" "						; print the leading space
.01884a	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter 			; so beloved of MS Basics.
.01884d					_CPRNoSpace:
.01884d	a2 06		ldx #$06			ldx 	#(Num_Buffer-1) & $FF
.01884f	a9 04		lda #$04			lda 	#(Num_Buffer-1) >> 8
.018851	80 06		bra $018859			bra 	_CPRPrint
.018853					_CPR_String:
.018853	ae 08 03	ldx $0308			ldx 	XS_Mantissa
.018856	ad 09 03	lda $0309			lda 	XS_Mantissa+1
.018859					_CPRPrint:
.018859	86 1e		stx $1e				stx 	zGenPtr
.01885b	85 1f		sta $1f				sta 	zGenPtr+1
.01885d	5a		phy				phy
.01885e	a0 00		ldy #$00			ldy 	#0							; get length into X
.018860	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018862	aa		tax				tax
.018863	f0 09		beq $01886e			beq 	_CPREndPrint 				; nothing to print
.018865					_CPRLoop:
.018865	c8		iny				iny
.018866	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018868	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01886b	ca		dex				dex
.01886c	d0 f7		bne $018865			bne 	_CPRLoop
.01886e					_CPREndPrint:
.01886e	7a		ply				ply
.01886f	80 a1		bra $018812			bra 	Command_Print
.018871					_CPR_Tab:
.018871	20 4f 80	jsr $01804f			jsr 	IFT_Tab
.018874					_CPR_Skip:
.018874	c8		iny				iny
.018875	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018877	c9 c0		cmp #$c0			cmp 	#token_Colon 				; colon or $00, exit
.018879	f0 09		beq $018884			beq 	_CPR_Exit
.01887b	c9 00		cmp #$00			cmp 	#0
.01887d	d0 93		bne $018812			bne 	Command_PRINT 				; if not go round again.
.01887f	80 03		bra $018884			bra 	_CPR_Exit
.018881					_CPR_NewLine:
.018881	20 5c 80	jsr $01805c			jsr 	IFT_NewLine
.018884					_CPR_Exit:
.018884	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/assert.asm

.018885					Command_ASSERT:
.018885	20 63 8a	jsr $018a63			jsr 	EvaluateNumber 				; calculate thing being asserted
.018888	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; check if true (non-zero)
.01888b	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.01888e	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.018891	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.018894	f0 01		beq $018897			beq 	_ASFail
.018896	60		rts				rts
.018897					_ASFail:
.018897	20 2f 84	jsr $01842f			jsr ERR_Handler
>01889a	41 73 73 65 72 74 00			.text "Assert",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.0188a1					Command_CLR:
.0188a1					ResetRunStatus:
.0188a1	20 0a 92	jsr $01920a			jsr 	VariableClear
.0188a4	a9 00		lda #$00			lda 	#HighMemory & $FF
.0188a6	8d 00 04	sta $0400			sta 	StringPtr
.0188a9	a9 80		lda #$80			lda 	#HighMemory >> 8
.0188ab	8d 01 04	sta $0401			sta 	StringPtr+1
.0188ae	20 df 93	jsr $0193df			jsr 	ArrayResetDefault
.0188b1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/stop.asm

.0188b2					Command_STOP:
.0188b2	20 2f 84	jsr $01842f			jsr ERR_Handler
>0188b5	53 74 6f 70 00				.text "Stop",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.0188ba					EVESyntax:
.0188ba	4c 00 84	jmp $018400			jmp 	SyntaxError
.0188bd					EvaluateExpression:
.0188bd	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.0188bf					EvaluateExpressionX:
.0188bf	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.0188c1					EvaluateExpressionXA:
.0188c1	48		pha				pha 								; save precedence on stack.
.0188c2	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0188c4	f0 f4		beq $0188ba			beq 	EVESyntax 					; end of line, syntax error.
.0188c6	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.0188c8	b0 03		bcs $0188cd			bcs 	_EVNotVariable
.0188ca	4c c4 89	jmp $0189c4			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.0188cd					_EVNotVariable:
.0188cd	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.0188cf	90 e9		bcc $0188ba			bcc 	EVESyntax
.0188d1	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.0188d3	b0 7f		bcs $018954			bcs 	_EVNotInteger
.0188d5	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.0188d7	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.0188da	a9 00		lda #$00			lda 	#0
.0188dc	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0188df	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0188e2	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0188e5	1a		inc a				inc 	a 							; set to type 1 (integer)
.0188e6	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0188e9					_EVCheckNextInteger:
.0188e9	c8		iny				iny
.0188ea	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0188ec	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.0188ee	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.0188f0	b0 0d		bcs $0188ff			bcs 	_EVCheckDecimal
.0188f2	48		pha				pha 								; save it.
.0188f3	20 d0 89	jsr $0189d0			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.0188f6	68		pla				pla
.0188f7	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.0188fa	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0188fd	80 ea		bra $0188e9			bra 	_EVCheckNextInteger
.0188ff					_EVCheckDecimal:
.0188ff	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018901	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.018903	d0 05		bne $01890a			bne 	_EVGotAtom 					; no, get atom.
.018905					_EVIsDecimal:
.018905	20 00 8a	jsr $018a00			jsr 	EVGetDecimal 				; extend to the decimal part.
.018908	80 00		bra $01890a			bra 	_EVGotAtom 					; and continue to got atom.
.01890a					_EVGotAtom:
.01890a	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01890c	10 44		bpl $018952			bpl 	_EVExitDrop 				; must be a token.
.01890e	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.018910	b0 40		bcs $018952			bcs 	_EVExitDrop
.018912	68		pla				pla 								; get current precedence
.018913	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.018915	da		phx				phx 								; save X
.018916	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018918	aa		tax				tax 								; put in X
.018919	bf e5 84 01	lda $0184e5,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.01891d	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.01891f	fa		plx				plx 								; restore X
.018920	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.018922	90 2f		bcc $018953			bcc 	_EVExit 					; exit if too low.
.018924	f0 2d		beq $018953			beq 	_EVExit 					; exit if equals
.018926	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.018928	48		pha				pha
.018929	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01892b	48		pha				pha
.01892c	c8		iny				iny
.01892d	da		phx				phx 								; save current position
.01892e	e8		inx				inx
.01892f	e8		inx				inx
.018930	e8		inx				inx
.018931	e8		inx				inx
.018932	e8		inx				inx
.018933	e8		inx				inx
.018934	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.018936	20 c1 88	jsr $0188c1			jsr 	EvaluateExpressionXA 		; do the RHS.
.018939	fa		plx				plx 								; restore X
.01893a	68		pla				pla 								; get the binary operator in A.
.01893b					_EVCallA:
.01893b	da		phx				phx 								; save X again
.01893c	0a		asl a				asl 	a 							; double, lose the MSB.
.01893d	aa		tax				tax									; put in X
.01893e	bf 96 84 01	lda $018496,x			lda 	VectorTable,x 				; copy address into zGenPtr
.018942	8d 05 03	sta $0305			sta 	LocalVector+1
.018945	bf 97 84 01	lda $018497,x			lda 	VectorTable+1,x
.018949	8d 06 03	sta $0306			sta 	LocalVector+2
.01894c	fa		plx				plx 								; restore X
.01894d	20 cd 89	jsr $0189cd			jsr 	EVCallLocalVector
.018950	80 b8		bra $01890a			bra 	_EVGotAtom 					; and loop back.
.018952					_EVExitDrop:
.018952	68		pla				pla
.018953					_EVExit:
.018953	60		rts				rts
.018954					_EVNotInteger:
.018954	c8		iny				iny
.018955	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.018957	d0 19		bne $018972			bne 	_EVNotMinus
.018959	20 51 8a	jsr $018a51			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.01895c	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.01895f	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.018961	f0 05		beq $018968			beq 	_EVMinusFloat
.018963	20 dd 96	jsr $0196dd			jsr 	IntegerNegateAlways 		; negation
.018966	80 a2		bra $01890a			bra 	_EVGotAtom 					; and go back.
.018968					_EVMinusFloat:
.018968	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; invert the sign bit.
.01896b	49 80		eor #$80			eor 	#$80
.01896d	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018970	80 98		bra $01890a			bra 	_EVGotAtom
.018972					_EVNotMinus:
.018972	c9 bd		cmp #$bd			cmp 	#token_lparen 				; is it left parenthesis
.018974	d0 17		bne $01898d			bne 	_EVNotParenthesis
.018976	20 bf 88	jsr $0188bf			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.018979	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01897b	c8		iny				iny
.01897c	c9 be		cmp #$be			cmp 	#token_rparen 				; okay if right bracket.
.01897e	f0 8a		beq $01890a			beq 	_EVGotAtom
.018980	20 2f 84	jsr $01842f			jsr ERR_Handler
>018983	4d 69 73 73 69 6e 67 20			.text "Missing )",0
>01898b	29 00
.01898d					_EVNotParenthesis:
.01898d	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.01898f	d0 0c		bne $01899d			bne 	_EVNotNot
.018991	20 51 8a	jsr $018a51			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.018994	20 eb 9b	jsr $019beb			jsr 	FPUToInteger 				; make it an integer - if possible.
.018997	20 2e 8a	jsr $018a2e			jsr 	NotInteger 					; do the not calculation
.01899a	4c 0a 89	jmp $01890a			jmp 	_EVGotAtom
.01899d					_EVNotNot:
.01899d	c9 fe		cmp #$fe			cmp 	#$FE
.01899f	d0 15		bne $0189b6			bne 	_EVNotString
.0189a1	20 a8 91	jsr $0191a8			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.0189a4	a5 20		lda $20				lda 	zTempStr 					; copy address of string into mantissa
.0189a6	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0189a9	a5 21		lda $21				lda 	zTempStr+1
.0189ab	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0189ae	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.0189b0	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0189b3	4c 0a 89	jmp $01890a			jmp 	_EVGotAtom
.0189b6					_EVNotString:
.0189b6	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.0189b8	90 04		bcc $0189be			bcc 	_EVBadElement
.0189ba	c9 b7		cmp #$b7			cmp 	#lastUnaryFunction+1
.0189bc	90 03		bcc $0189c1			bcc 	_EVUnaryFunction
.0189be					_EVBadElement:
.0189be	4c 00 84	jmp $018400			jmp 	SyntaxError
.0189c1					_EVUnaryFunction:
.0189c1	4c 3b 89	jmp $01893b			jmp 	_EVCallA
.0189c4					_EVVariableHandler:
.0189c4	20 ce 91	jsr $0191ce			jsr 	VariableFind 				; locate a variable
.0189c7	20 21 95	jsr $019521			jsr 	VariableGet 				; copy into memory.
.0189ca	4c 0a 89	jmp $01890a			jmp 	_EVGotAtom 					; and go round.
.0189cd					EVCallLocalVector:
.0189cd	6c 05 03	jmp ($0305)			jmp 	(LocalVector+1)
.0189d0					EVShiftMantissaLeft6:
.0189d0	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.0189d3	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.0189d6	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.0189d9	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0189dc	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0189df	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0189e2	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.0189e5	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0189e8	a9 00		lda #$00			lda 	#0
.0189ea	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0189ed	20 f0 89	jsr $0189f0			jsr 	_EVSMLShift 					; call it here to do it twice
.0189f0					_EVSMLShift:
.0189f0	5e 0c 03	lsr $030c,x			lsr 	XS_Exponent,x
.0189f3	7e 0b 03	ror $030b,x			ror 	XS_Mantissa+3,x
.0189f6	7e 0a 03	ror $030a,x			ror 	XS_Mantissa+2,x
.0189f9	7e 09 03	ror $0309,x			ror 	XS_Mantissa+1,x
.0189fc	7e 08 03	ror $0308,x			ror 	XS_Mantissa+0,x
.0189ff	60		rts				rts
.018a00					EVGetDecimal:
.018a00	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.018a02	8d 07 04	sta $0407			sta 	Num_Buffer
.018a05	da		phx				phx
.018a06	c8		iny				iny
.018a07	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018a09	c8		iny				iny
.018a0a	3a		dec a				dec 	a								; convert to a string length.
.018a0b	3a		dec a				dec 	a
.018a0c	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.018a0e					_EVGDCopy:
.018a0e	48		pha				pha 									; save count
.018a0f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018a11	9d 07 04	sta $0407,x			sta 	Num_Buffer,x
.018a14	e8		inx				inx 									; forward ....
.018a15	c8		iny				iny
.018a16	68		pla				pla 									; get count
.018a17	3a		dec a				dec 	a 								; until zero
.018a18	d0 f4		bne $018a0e			bne 	_EVGDCopy
.018a1a	9d 07 04	sta $0407,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.018a1d	fa		plx				plx 									; restore X
.018a1e	a9 07		lda #$07			lda 	#Num_Buffer & $FF 				; set zGenPtr
.018a20	85 1e		sta $1e				sta 	zGenPtr
.018a22	a9 04		lda #$04			lda 	#Num_Buffer >> 8
.018a24	85 1f		sta $1f				sta 	zGenPtr+1
.018a26	5a		phy				phy 									; save Y
.018a27	a0 00		ldy #$00			ldy 	#0 								; start position
.018a29	20 dd 9d	jsr $019ddd			jsr 	FPFromString 					; convert current
.018a2c	7a		ply				ply 									; restore Y
.018a2d	60		rts				rts
.018a2e					NotInteger:
.018a2e	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018a31	49 ff		eor #$ff			eor 	#$FF
.018a33	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018a36	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018a39	49 ff		eor #$ff			eor 	#$FF
.018a3b	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018a3e	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018a41	49 ff		eor #$ff			eor 	#$FF
.018a43	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018a46	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.018a49	49 ff		eor #$ff			eor 	#$FF
.018a4b	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018a4e	60		rts				rts
.018a4f					EvaluateGetAtom:
.018a4f	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.018a51					EvaluateGetAtomX:
.018a51	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.018a53	20 c1 88	jsr $0188c1			jsr 	EvaluateExpressionXA
.018a56	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.018a59	29 0f		and #$0f			and 	#15
.018a5b	c9 02		cmp #$02			cmp 	#2
.018a5d	b0 01		bcs $018a60			bcs 	EvaluateType
.018a5f	60		rts				rts
.018a60					EvaluateType:
.018a60	4c 10 84	jmp $018410			jmp 	TypeError
.018a63					EvaluateNumber:
.018a63	a2 00		ldx #$00			ldx 	#0
.018a65					EvaluateNumberX:
.018a65	20 bf 88	jsr $0188bf			jsr 	EvaluateExpressionX
.018a68	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 0/1
.018a6b	29 0f		and #$0f			and 	#15
.018a6d	c9 02		cmp #$02			cmp 	#2
.018a6f	b0 ef		bcs $018a60			bcs 	EvaluateType
.018a71	60		rts				rts
.018a72					EvaluateInteger:
.018a72	a2 00		ldx #$00			ldx 	#0
.018a74					EvaluateIntegerX:
.018a74	20 65 8a	jsr $018a65			jsr 	EvaluateNumberX
.018a77	20 eb 9b	jsr $019beb			jsr 	FPUToInteger
.018a7a	60		rts				rts
.018a7b					EvaluateString:
.018a7b	a2 00		ldx #$00			ldx 	#0
.018a7d					EvaluateStringX:
.018a7d	20 bf 88	jsr $0188bf			jsr 	EvaluateExpressionX
.018a80	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 2
.018a83	29 0f		and #$0f			and 	#15
.018a85	c9 02		cmp #$02			cmp 	#2
.018a87	d0 d7		bne $018a60			bne 	EvaluateType
.018a89	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.018a8c	85 1e		sta $1e				sta 	zGenPtr
.018a8e	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018a91	85 1f		sta $1f				sta 	zGenPtr+1
.018a93	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.018a94					BinaryOp_And:
.018a94	20 0c 8b	jsr $018b0c			jsr 	BinaryMakeBothInteger
.018a97	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.018a9a	3d 0e 03	and $030e,x			and 	XS2_Mantissa+0,x
.018a9d	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018aa0	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.018aa3	3d 0f 03	and $030f,x			and 	XS2_Mantissa+1,x
.018aa6	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018aa9	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.018aac	3d 10 03	and $0310,x			and 	XS2_Mantissa+2,x
.018aaf	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018ab2	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.018ab5	3d 11 03	and $0311,x			and 	XS2_Mantissa+3,x
.018ab8	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018abb	60		rts				rts
.018abc					BinaryOp_Or:
.018abc	20 0c 8b	jsr $018b0c			jsr 	BinaryMakeBothInteger
.018abf	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.018ac2	1d 0e 03	ora $030e,x			ora 	XS2_Mantissa+0,x
.018ac5	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018ac8	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.018acb	1d 0f 03	ora $030f,x			ora 	XS2_Mantissa+1,x
.018ace	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018ad1	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.018ad4	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.018ad7	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018ada	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.018add	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.018ae0	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018ae3	60		rts				rts
.018ae4					BinaryOp_Eor:
.018ae4					BinaryOp_Xor:
.018ae4	20 0c 8b	jsr $018b0c			jsr 	BinaryMakeBothInteger
.018ae7	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.018aea	5d 0e 03	eor $030e,x			eor 	XS2_Mantissa+0,x
.018aed	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018af0	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.018af3	5d 0f 03	eor $030f,x			eor 	XS2_Mantissa+1,x
.018af6	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018af9	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.018afc	5d 10 03	eor $0310,x			eor 	XS2_Mantissa+2,x
.018aff	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018b02	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.018b05	5d 11 03	eor $0311,x			eor 	XS2_Mantissa+3,x
.018b08	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018b0b	60		rts				rts
.018b0c					BinaryMakeBothInteger:
.018b0c	da		phx				phx 								; save X
.018b0d	e8		inx				inx
.018b0e	e8		inx				inx
.018b0f	e8		inx				inx
.018b10	e8		inx				inx
.018b11	e8		inx				inx
.018b12	e8		inx				inx
.018b13	20 17 8b	jsr $018b17			jsr 	BinaryMakeInteger 			; convert to integer.
.018b16	fa		plx				plx 								; restore X and fall through.
.018b17					BinaryMakeInteger:
.018b17	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type byte.
.018b1a	29 0f		and #$0f			and 	#15 						; check type zero
.018b1c	f0 04		beq $018b22			beq 	_BMIConvert 				; if float convert to integer.
.018b1e	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.018b1f	90 04		bcc $018b25			bcc 	_BMIError
.018b21	60		rts				rts
.018b22					_BMIConvert:
.018b22	4c eb 9b	jmp $019beb			jmp 	FPUToInteger 				; convert to integer
.018b25					_BMIError:
.018b25	4c 10 84	jmp $018410			jmp 	TypeError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.018b28					Binary_Equal:
.018b28	20 74 8b	jsr $018b74			jsr 	CompareValues
.018b2b	09 00		ora #$00			ora 	#0
.018b2d	f0 04		beq $018b33			beq 	CCTrue
.018b2f	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.018b31	80 02		bra $018b35			bra 	CCWrite
.018b33	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.018b35	9d 08 03	sta $0308,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.018b38	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018b3b	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018b3e	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018b41	a9 01		lda #$01			lda 	#1
.018b43	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; set type to integer whatever.
.018b46	60		rts				rts
.018b47					Binary_NotEqual:
.018b47	20 74 8b	jsr $018b74			jsr 	CompareValues
.018b4a	09 00		ora #$00			ora 	#0
.018b4c	f0 e1		beq $018b2f			beq 	CCFalse
.018b4e	80 e3		bra $018b33			bra 	CCTrue
.018b50					Binary_Less:
.018b50	20 74 8b	jsr $018b74			jsr 	CompareValues
.018b53	09 00		ora #$00			ora 	#0
.018b55	30 dc		bmi $018b33			bmi 	CCTrue
.018b57	80 d6		bra $018b2f			bra 	CCFalse
.018b59					Binary_LessEqual:
.018b59	20 74 8b	jsr $018b74			jsr 	CompareValues
.018b5c	c9 01		cmp #$01			cmp 	#1
.018b5e	d0 d3		bne $018b33			bne 	CCTrue
.018b60	80 cd		bra $018b2f			bra 	CCFalse
.018b62					Binary_GreaterEqual:
.018b62	20 74 8b	jsr $018b74			jsr 	CompareValues
.018b65	09 00		ora #$00			ora 	#0
.018b67	10 ca		bpl $018b33			bpl 	CCTrue
.018b69	80 c4		bra $018b2f			bra 	CCFalse
.018b6b					Binary_Greater:
.018b6b	20 74 8b	jsr $018b74			jsr 	CompareValues
.018b6e	c9 01		cmp #$01			cmp 	#1
.018b70	f0 c1		beq $018b33			beq 	CCTrue
.018b72	80 bb		bra $018b2f			bra 	CCFalse
.018b74					CompareValues:
.018b74	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and the types together
.018b77	3d 13 03	and $0313,x			and 	XS2_Type,x
.018b7a	c9 02		cmp #$02			cmp 	#2
.018b7c	f0 13		beq $018b91			beq 	_CVString
.018b7e	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018b81	3d 13 03	and $0313,x			and 	XS2_Type,x
.018b84	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018b85	90 03		bcc $018b8a			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018b87	4c d7 8b	jmp $018bd7			jmp 	CompareInteger32 							; so execute code at \1
.018b8a					_BCFloat:
.018b8a	20 a5 8c	jsr $018ca5			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018b8d	4c fa 9a	jmp $019afa			jmp 	FPCompare 							; and execute code at \2
.018b90	60		rts				rts
.018b91					_CVString:
.018b91	da		phx				phx 								; save XY
.018b92	5a		phy				phy
.018b93	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.018b96	85 1a		sta $1a				sta		zLTemp1+0
.018b98	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018b9b	85 1b		sta $1b				sta 	zLTemp1+1
.018b9d	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x
.018ba0	85 1c		sta $1c				sta 	zLTemp1+2
.018ba2	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.018ba5	85 1d		sta $1d				sta 	zLTemp1+3
.018ba7	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.018ba9	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.018bab	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.018bad	90 02		bcc $018bb1			bcc 	_CVCommon
.018baf	b1 1c		lda ($1c),y			lda 	(zLTemp1+2),y
.018bb1					_CVCommon:
.018bb1	aa		tax				tax 								; put shorter string length in zero.
.018bb2	f0 0c		beq $018bc0			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.018bb4					_CVCompare:
.018bb4	c8		iny				iny 								; next character
.018bb5	b1 1a		lda ($1a),y			lda 	(zLTemp1),y 				; compare characters
.018bb7	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.018bb9	90 13		bcc $018bce			bcc 	_CVReturnLess 				; <
.018bbb	d0 15		bne $018bd2			bne 	_CVReturnGreater 			; >
.018bbd	ca		dex				dex 								; until common length matched.
.018bbe	d0 f4		bne $018bb4			bne 	_CVCompare
.018bc0					_CVMatch:
.018bc0	a0 00		ldy #$00			ldy 	#0
.018bc2	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.018bc4	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.018bc6	90 06		bcc $018bce			bcc 	_CVReturnLess 				; <
.018bc8	d0 08		bne $018bd2			bne 	_CVReturnGreater 			; >
.018bca	a9 00		lda #$00			lda 	#0
.018bcc	80 06		bra $018bd4			bra 	_CVExit 					; same common, same length, same string
.018bce					_CVReturnLess:
.018bce	a9 ff		lda #$ff			lda 	#$FF
.018bd0	80 02		bra $018bd4			bra 	_CVExit
.018bd2					_CVReturnGreater:
.018bd2	a9 01		lda #$01			lda 	#$01
.018bd4					_CVExit:
.018bd4	7a		ply				ply
.018bd5	fa		plx				plx
.018bd6	60		rts				rts
.018bd7					CompareInteger32:
.018bd7	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.018bda	49 80		eor #$80			eor 	#$80
.018bdc	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018bdf	bd 11 03	lda $0311,x			lda 	XS2_Mantissa+3,x
.018be2	49 80		eor #$80			eor 	#$80
.018be4	9d 11 03	sta $0311,x			sta 	XS2_Mantissa+3,x
.018be7	20 7f 8c	jsr $018c7f			jsr 	SubInteger32 				; subtraction
.018bea	90 11		bcc $018bfd			bcc 	_CI32Less 					; cc return -1
.018bec	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; check if zero
.018bef	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.018bf2	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.018bf5	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.018bf8	f0 02		beq $018bfc			beq 	_CI32Exit
.018bfa	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.018bfc					_CI32Exit:
.018bfc	60		rts				rts
.018bfd					_CI32Less:
.018bfd	a9 ff		lda #$ff			lda 	#$FF
.018bff	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.018c00					BinaryOp_Add:
.018c00	bd 0d 03	lda $030d,x			lda 	XS_Type,x  					; and types together
.018c03	3d 13 03	and $0313,x			and 	XS2_Type,x
.018c06	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.018c08	d0 13		bne $018c1d			bne 	_BOAString
.018c0a	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018c0d	3d 13 03	and $0313,x			and 	XS2_Type,x
.018c10	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018c11	90 03		bcc $018c16			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018c13	4c 59 8c	jmp $018c59			jmp 	AddInteger32 							; so execute code at \1
.018c16					_BCFloat:
.018c16	20 a5 8c	jsr $018ca5			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018c19	4c 6e 98	jmp $01986e			jmp 	FPAdd 							; and execute code at \2
.018c1c	60		rts				rts
.018c1d					_BOAString:
.018c1d	4c c0 8c	jmp $018cc0			jmp 	ConcatenateString 			; concatenate two strings.
.018c20					BinaryOp_Subtract:
.018c20	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018c23	3d 13 03	and $0313,x			and 	XS2_Type,x
.018c26	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018c27	90 03		bcc $018c2c			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018c29	4c 7f 8c	jmp $018c7f			jmp 	SubInteger32 							; so execute code at \1
.018c2c					_BCFloat:
.018c2c	20 a5 8c	jsr $018ca5			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018c2f	4c 64 98	jmp $019864			jmp 	FPSubtract 							; and execute code at \2
.018c32	60		rts				rts
.018c33					BinaryOp_Multiply:
.018c33	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018c36	3d 13 03	and $0313,x			and 	XS2_Type,x
.018c39	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018c3a	90 03		bcc $018c3f			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018c3c	4c f0 95	jmp $0195f0			jmp 	MulInteger32 							; so execute code at \1
.018c3f					_BCFloat:
.018c3f	20 a5 8c	jsr $018ca5			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018c42	4c da 99	jmp $0199da			jmp 	FPMultiply 							; and execute code at \2
.018c45	60		rts				rts
.018c46					BinaryOp_Divide:
.018c46	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018c49	3d 13 03	and $0313,x			and 	XS2_Type,x
.018c4c	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018c4d	90 03		bcc $018c52			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018c4f	4c 47 96	jmp $019647			jmp 	DivInteger32 							; so execute code at \1
.018c52					_BCFloat:
.018c52	20 a5 8c	jsr $018ca5			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018c55	4c 52 99	jmp $019952			jmp 	FPDivide 							; and execute code at \2
.018c58	60		rts				rts
.018c59					AddInteger32:
.018c59	18		clc				clc
.018c5a	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018c5d	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.018c60	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018c63	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018c66	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.018c69	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018c6c	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018c6f	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.018c72	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018c75	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.018c78	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.018c7b	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018c7e	60		rts				rts
.018c7f					SubInteger32:
.018c7f	38		sec				sec
.018c80	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018c83	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.018c86	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018c89	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018c8c	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.018c8f	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018c92	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018c95	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.018c98	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018c9b	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.018c9e	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.018ca1	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018ca4	60		rts				rts
.018ca5					BinaryMakeBothFloat:
.018ca5	da		phx				phx 								; save X
.018ca6	e8		inx				inx
.018ca7	e8		inx				inx
.018ca8	e8		inx				inx
.018ca9	e8		inx				inx
.018caa	e8		inx				inx
.018cab	e8		inx				inx
.018cac	20 b0 8c	jsr $018cb0			jsr 	BinaryMakeFloat 			; convert to float.
.018caf	fa		plx				plx 								; restore X and fall through.
.018cb0					BinaryMakeFloat:
.018cb0	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type byte.
.018cb3	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.018cb4	b0 04		bcs $018cba			bcs 	_BMFConvert
.018cb6	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.018cb7	b0 04		bcs $018cbd			bcs 	_BMFError
.018cb9	60		rts				rts
.018cba					_BMFConvert:
.018cba	4c 8c 9b	jmp $019b8c			jmp 	FPUToFloat 					; convert to float
.018cbd					_BMFError:
.018cbd	4c 10 84	jmp $018410			jmp 	TypeError
.018cc0					ConcatenateString:
.018cc0	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.018cc3	85 1a		sta $1a				sta		zLTemp1+0
.018cc5	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018cc8	85 1b		sta $1b				sta 	zLTemp1+1
.018cca	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x
.018ccd	85 1c		sta $1c				sta 	zLTemp1+2
.018ccf	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.018cd2	85 1d		sta $1d				sta 	zLTemp1+3
.018cd4	5a		phy				phy
.018cd5	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.018cd7	b1 1a		lda ($1a),y			lda 	(zlTemp1),y
.018cd9	71 1c		adc ($1c),y			adc 	(zlTemp1+2),y
.018cdb	7a		ply				ply
.018cdc	b0 37		bcs $018d15			bcs 	_CSError					; check in range.
.018cde	c9 fe		cmp #$fe			cmp 	#maxString+1
.018ce0	b0 33		bcs $018d15			bcs 	_CSError
.018ce2	20 6d 91	jsr $01916d			jsr 	AllocateTempString 			; store the result
.018ce5	20 00 8d	jsr $018d00			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.018ce8	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.018ceb	85 1a		sta $1a				sta 	zLTemp1
.018ced	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.018cf0	85 1b		sta $1b				sta 	zLTemp1+1
.018cf2	20 00 8d	jsr $018d00			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.018cf5	a5 20		lda $20				lda 	zTempStr 					; point current to new string
.018cf7	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018cfa	a5 21		lda $21				lda 	zTempStr+1
.018cfc	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018cff	60		rts				rts
.018d00					_CSCopyString:
.018d00	da		phx				phx
.018d01	5a		phy				phy
.018d02	a0 00		ldy #$00			ldy 	#0 							; get length
.018d04	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.018d06	f0 0a		beq $018d12			beq 	_CSCSExit 					; if zero, exit
.018d08	aa		tax				tax 								; put in X
.018d09					_CSCSLoop:
.018d09	c8		iny				iny 								; get next char
.018d0a	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.018d0c	20 98 91	jsr $019198			jsr		WriteTempString 			; copy out
.018d0f	ca		dex				dex 								; do whole string
.018d10	d0 f7		bne $018d09			bne 	_CSCSLoop
.018d12					_CSCSExit:
.018d12	7a		ply				ply
.018d13	fa		plx				plx
.018d14	60		rts				rts
.018d15					_CSError:
.018d15	20 2f 84	jsr $01842f			jsr ERR_Handler
>018d18	53 74 72 69 6e 67 20 74			.text "String too long",0
>018d20	6f 6f 20 6c 6f 6e 67 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.018d28					Unary_Sgn:
.018d28	20 65 8a	jsr $018a65			jsr 	EvaluateNumberX 			; get value
.018d2b	20 2b 91	jsr $01912b			jsr 	CheckNextRParen 			; check right bracket.
.018d2e	20 52 8d	jsr $018d52			jsr 	GetSignCurrent 				; get sign.
.018d31	09 00		ora #$00			ora 	#0
.018d33	10 09		bpl $018d3e			bpl		UnarySetAInteger			; if 0,1 return that.
.018d35	80 00		bra $018d37			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.018d37					UnarySetAMinus1:
.018d37	a9 ff		lda #$ff			lda 	#$FF
.018d39	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.018d3c	80 05		bra $018d43			bra 	UnarySetAFill
.018d3e					UnarySetAInteger:
.018d3e	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.018d41	a9 00		lda #$00			lda 	#0
.018d43					UnarySetAFill:
.018d43	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018d46	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018d49	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018d4c	a9 01		lda #$01			lda 	#1
.018d4e	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018d51	60		rts				rts
.018d52					GetSignCurrent:
.018d52	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; identify type.
.018d55	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.018d56	90 19		bcc $018d71			bcc 	_GSCFloat
.018d58	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.018d5b	30 11		bmi $018d6e			bmi 	_GSCMinus1
.018d5d	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x
.018d60	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.018d63	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.018d66	d0 03		bne $018d6b			bne 	_GSCPlus1
.018d68					_GSCZero:
.018d68	a9 00		lda #$00			lda 	#0
.018d6a	60		rts				rts
.018d6b					_GSCPlus1:
.018d6b	a9 01		lda #$01			lda 	#$01
.018d6d	60		rts				rts
.018d6e					_GSCMinus1:
.018d6e	a9 ff		lda #$ff			lda 	#$FF
.018d70	60		rts				rts
.018d71					_GSCFloat:
.018d71	3c 0d 03	bit $030d,x			bit 	XS_Type,x
.018d74	70 f2		bvs $018d68			bvs 	_GSCZero
.018d76	30 f6		bmi $018d6e			bmi 	_GSCMinus1
.018d78	80 f1		bra $018d6b			bra 	_GSCPlus1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.018d7a					Unary_Abs:
.018d7a	20 65 8a	jsr $018a65			jsr 	EvaluateNumberX 			; get value
.018d7d	20 2b 91	jsr $01912b			jsr 	CheckNextRParen 			; check right bracket.
.018d80	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.018d83	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.018d85	f0 08		beq $018d8f			beq 	_UAMinusFloat
.018d87	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; check MSB
.018d8a	10 0b		bpl $018d97			bpl 	_UAExit
.018d8c	4c dd 96	jmp $0196dd			jmp 	IntegerNegateAlways 		; negation
.018d8f					_UAMinusFloat:
.018d8f	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; clear the sign bit.
.018d92	29 7f		and #$7f			and		#$7F
.018d94	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018d97					_UAExit:
.018d97	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.018d98					Unary_Peek:
.018d98	a9 01		lda #$01			lda 	#1
.018d9a	80 06		bra $018da2			bra 	UPMain
.018d9c					Unary_Deek:
.018d9c	a9 02		lda #$02			lda 	#2
.018d9e	80 02		bra $018da2			bra 	UPMain
.018da0					Unary_Leek:
.018da0	a9 04		lda #$04			lda 	#4
.018da2					UPMain:
.018da2	48		pha				pha 								; set bytes to copy.
.018da3	20 74 8a	jsr $018a74			jsr 	EvaluateIntegerX 			; numeric parameter
.018da6	20 2b 91	jsr $01912b			jsr 	CheckNextRParen 			; right bracket.
.018da9	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.018dac	85 1a		sta $1a				sta 	zLTemp1
.018dae	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018db1	85 1b		sta $1b				sta 	zLTemp1+1
.018db3	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018db6	85 1c		sta $1c				sta 	zLTemp1+2
.018db8	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.018dbb	85 1d		sta $1d				sta 	zLTemp1+3
.018dbd	a9 00		lda #$00			lda 	#0 							; clear target area
.018dbf	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018dc2	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018dc5	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018dc8	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018dcb	68		pla				pla 								; restore bytes to copy
.018dcc	da		phx				phx 								; save XY
.018dcd	5a		phy				phy
.018dce	20 cb 90	jsr $0190cb			jsr 	MemRead 					; read the bytes in
.018dd1	7a		ply				ply 								; restore and exit
.018dd2	fa		plx				plx
.018dd3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.018dd4					Unary_Mod:
.018dd4	20 00 8e	jsr $018e00			jsr 	_UMParameter 				; first parameter
.018dd7	20 33 91	jsr $019133			jsr 	CheckNextComma
.018dda	da		phx				phx 								; second parameter
.018ddb	e8		inx				inx
.018ddc	e8		inx				inx
.018ddd	e8		inx				inx
.018dde	e8		inx				inx
.018ddf	e8		inx				inx
.018de0	e8		inx				inx
.018de1	20 00 8e	jsr $018e00			jsr 	_UMParameter
.018de4	fa		plx				plx
.018de5	20 2b 91	jsr $01912b			jsr 	CheckNextRParen
.018de8	20 47 96	jsr $019647			jsr 	DivInteger32 				; divide
.018deb	a5 1a		lda $1a				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.018ded	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018df0	a5 1b		lda $1b				lda 	zLTemp1+1
.018df2	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018df5	a5 1c		lda $1c				lda 	zLTemp1+2
.018df7	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018dfa	a5 1d		lda $1d				lda 	zLTemp1+3
.018dfc	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018dff	60		rts				rts
.018e00					_UMParameter:
.018e00	20 74 8a	jsr $018a74			jsr 	EvaluateIntegerX 			; get value
.018e03	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; absolute value
.018e06	10 03		bpl $018e0b			bpl 	_UMNotSigned
.018e08	20 dd 96	jsr $0196dd			jsr 	IntegerNegateAlways
.018e0b					_UMNotSigned:
.018e0b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.018e0c					Unary_Usr:
.018e0c	20 65 8a	jsr $018a65			jsr 	EvaluateNumberX 			; numeric parameter
.018e0f	20 2b 91	jsr $01912b			jsr 	CheckNextRParen 			; right bracket.
.018e12	da		phx				phx 								; save XY
.018e13	5a		phy				phy
.018e14	ea		nop				nop
.018e15	22 00 03 00	jsl $000300			jsl 	UserVector
.018e19	7a		ply				ply 								; and exit
.018e1a	fa		plx				plx
.018e1b	60		rts				rts
.018e1c					USRDefault:
.018e1c	20 2f 84	jsr $01842f			jsr ERR_Handler
>018e1f	4e 6f 20 55 53 52 20 76			.text "No USR vector.",0
>018e27	65 63 74 6f 72 2e 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.018e2e					Unary_Val:
.018e2e	20 7d 8a	jsr $018a7d			jsr 	EvaluateStringX 			; get string
.018e31	20 2b 91	jsr $01912b			jsr 	CheckNextRParen 			; check right bracket.
.018e34	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.018e37	85 1e		sta $1e				sta 	zGenPtr
.018e39	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018e3c	85 1f		sta $1f				sta 	zGenPtr+1
.018e3e	5a		phy				phy
.018e3f	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.018e41	b1 1e		lda ($1e),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.018e43	f0 57		beq $018e9c			beq 	_UVBadNumber
.018e45	48		pha				pha 								; save length.
.018e46	1a		inc a				inc 	a 							; one for the length, one for the terminator
.018e47	1a		inc a				inc 	a
.018e48	20 6d 91	jsr $01916d			jsr 	AllocateTempString
.018e4b	c8		iny				iny 								; move to the next.
.018e4c	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get character
.018e4e	49 2d		eor #$2d			eor 	#"-"						; zero if minus sign
.018e50	8d 92 04	sta $0492			sta 	ValSign
.018e53	d0 04		bne $018e59			bne 	_UVNotMinus
.018e55	c8		iny				iny 								; skip over it.
.018e56	68		pla				pla 								; decrement character count.
.018e57	3a		dec a				dec 	a
.018e58	48		pha				pha
.018e59					_UVNotMinus:
.018e59	68		pla				pla 								; this is the count.
.018e5a	48		pha		_UVCopy:pha									; copy into new temp string which is ASCIIZ
.018e5b	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018e5d	c8		iny				iny
.018e5e	20 98 91	jsr $019198			jsr 	WriteTempString
.018e61	68		pla				pla
.018e62	3a		dec a				dec 	a
.018e63	d0 f5		bne $018e5a			bne 	_UVCopy
.018e65	20 98 91	jsr $019198			jsr 	WriteTempString 			; make it ASCIIZ
.018e68	18		clc				clc
.018e69	a5 20		lda $20				lda 	zTempStr 					; tempstring +1 => genptr
.018e6b	69 01		adc #$01			adc 	#1
.018e6d	85 1e		sta $1e				sta 	zGenPtr
.018e6f	a5 21		lda $21				lda 	zTempStr+1
.018e71	69 00		adc #$00			adc 	#0
.018e73	85 1f		sta $1f				sta 	zGenPtr+1
.018e75	18		clc				clc
.018e76	20 b9 97	jsr $0197b9			jsr 	IntFromString 				; first bit.
.018e79	b0 21		bcs $018e9c			bcs 	_UVBadNumber
.018e7b	20 dd 9d	jsr $019ddd			jsr 	FPFromString				; try for a float part.
.018e7e	ad 92 04	lda $0492			lda 	ValSign 					; was it negative
.018e81	d0 13		bne $018e96			bne 	_UVNotNegative
.018e83	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; check if integer
.018e86	4a		lsr a				lsr 	a
.018e87	b0 0a		bcs $018e93			bcs 	_UVInteger
.018e89	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; set sign bit
.018e8c	09 80		ora #$80			ora 	#$80
.018e8e	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018e91	80 03		bra $018e96			bra 	_UVNotNegative
.018e93					_UVInteger:
.018e93	20 dd 96	jsr $0196dd			jsr 	IntegerNegateAlways 		; sign it.
.018e96					_UVNotNegative:
.018e96	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; used everything
.018e98	d0 02		bne $018e9c			bne 	_UVBadNumber
.018e9a	7a		ply				ply
.018e9b	60		rts				rts
.018e9c					_UVBadNumber:
.018e9c	4c 1e 84	jmp $01841e			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.018e9f					Unary_Str:
.018e9f	20 65 8a	jsr $018a65			jsr 	EvaluateNumberX 			; numeric parameter
.018ea2	20 2b 91	jsr $01912b			jsr 	CheckNextRParen 			; right bracket.
.018ea5	a9 00		lda #$00			lda 	#0 							; reset buffer index
.018ea7	8d 06 04	sta $0406			sta 	NumBufX
.018eaa	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.018ead	4a		lsr a				lsr 	a
.018eae	b0 05		bcs $018eb5			bcs 	_USInt 						; if msb set do as integer
.018eb0	20 16 9d	jsr $019d16			jsr 	FPToString 					; call fp to str otherwise
.018eb3	80 03		bra $018eb8			bra 	_USDuplicate
.018eb5	20 02 97	jsr $019702	_USInt:	jsr 	IntToString
.018eb8					_USDuplicate:
.018eb8	ad 06 04	lda $0406			lda 	NumBufX 					; chars in buffer
.018ebb	1a		inc a				inc 	a 							; one more for length
.018ebc	20 6d 91	jsr $01916d			jsr 	AllocateTempString 			; allocate space for it.
.018ebf	5a		phy				phy 								; save Y
.018ec0	a0 00		ldy #$00			ldy 	#0 							; start copying
.018ec2	b9 07 04	lda $0407,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.018ec5	20 98 91	jsr $019198			jsr 	WriteTempString
.018ec8	c8		iny				iny
.018ec9	cc 06 04	cpy $0406			cpy 	NumBufX 					; done the lot
.018ecc	d0 f4		bne $018ec2			bne 	_USCopy
.018ece	7a		ply				ply 								; restore Y
.018ecf	4c bb 90	jmp $0190bb			jmp 	UnaryReturnTempStr 			; return new temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.018ed2					Unary_Asc:
.018ed2	20 7d 8a	jsr $018a7d			jsr 	EvaluateStringX 			; string parameter
.018ed5	20 2b 91	jsr $01912b			jsr 	CheckNextRParen 			; right bracket.
.018ed8	5a		phy				phy 								; get the string length
.018ed9	a0 00		ldy #$00			ldy 	#0
.018edb	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018edd	f0 07		beq $018ee6			beq 	_UAIllegal 					; must be at least one character
.018edf	c8		iny				iny
.018ee0	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; read it.
.018ee2	7a		ply				ply
.018ee3	4c 3e 8d	jmp $018d3e			jmp 	UnarySetAInteger
.018ee6					_UAIllegal:
.018ee6	4c 1e 84	jmp $01841e			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.018ee9					Unary_Len:
.018ee9	20 7d 8a	jsr $018a7d			jsr 	EvaluateStringX 			; string parameter
.018eec	20 2b 91	jsr $01912b			jsr 	CheckNextRParen 			; right bracket.
.018eef	5a		phy				phy 								; get the string length
.018ef0	a0 00		ldy #$00			ldy 	#0
.018ef2	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018ef4	7a		ply				ply
.018ef5	4c 3e 8d	jmp $018d3e			jmp 	UnarySetAInteger

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.018ef8					Unary_Mid:
.018ef8	20 7d 8a	jsr $018a7d			jsr 	EvaluateStringX 				; get string.
.018efb	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.018efe	48		pha				pha
.018eff	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018f02	48		pha				pha
.018f03	20 33 91	jsr $019133			jsr 	CheckNextComma 					; skip comma
.018f06	20 93 8f	jsr $018f93			jsr 	SLIByteParameter 				; get a byte parameter (start)
.018f09	48		pha				pha 									; and push it.
.018f0a	20 33 91	jsr $019133			jsr 	CheckNextComma 					; skip comma
.018f0d	20 93 8f	jsr $018f93			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.018f10	48		pha				pha 									; and push it.
.018f11	80 45		bra $018f58			bra 	SLIProcess
.018f13					Unary_Left:
.018f13	20 7d 8a	jsr $018a7d			jsr 	EvaluateStringX 				; get string.
.018f16	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.018f19	48		pha				pha
.018f1a	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018f1d	48		pha				pha
.018f1e	a9 01		lda #$01			lda 	#1 								; push start position (1)
.018f20	48		pha				pha
.018f21	20 33 91	jsr $019133			jsr 	CheckNextComma 					; skip comma
.018f24	20 93 8f	jsr $018f93			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.018f27	48		pha				pha 									; and push it.
.018f28	80 2e		bra $018f58			bra 	SLIProcess
.018f2a					Unary_Right:
.018f2a	20 7d 8a	jsr $018a7d			jsr 	EvaluateStringX 				; get string.
.018f2d	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.018f30	48		pha				pha
.018f31	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018f34	48		pha				pha
.018f35	da		phx				phx 									; get the string length and push on stack.
.018f36	a2 00		ldx #$00			ldx 	#0
.018f38	a1 1e		lda ($1e,x)			lda		(zGenPtr,x)
.018f3a	fa		plx				plx
.018f3b	48		pha				pha
.018f3c	20 33 91	jsr $019133			jsr 	CheckNextComma 					; skip comma
.018f3f	20 93 8f	jsr $018f93			jsr 	SLIByteParameter 				; get a byte parameter.
.018f42	8d 90 04	sta $0490			sta 	SignCount 						; save in temporary.
.018f45	68		pla				pla 									; restore string length.
.018f46	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.018f47	38		sec				sec
.018f48	ed 90 04	sbc $0490			sbc 	SignCount 						; subtract characters needed, gives start position.
.018f4b	f0 02		beq $018f4f			beq 	_URStart 						; if <= 0 start from 1.
.018f4d	10 02		bpl $018f51			bpl 	_UROkay
.018f4f					_URStart:
.018f4f	a9 01		lda #$01			lda 	#1
.018f51					_UROkay:
.018f51	48		pha				pha 									; push start
.018f52	ad 90 04	lda $0490			lda 	SignCount 						; push count of characters
.018f55	48		pha				pha
.018f56	80 00		bra $018f58			bra 	SLIProcess
.018f58					SLIProcess:
.018f58	20 2b 91	jsr $01912b			jsr 	CheckNextRParen 				; closing right bracket.
.018f5b	68		pla				pla
.018f5c	8d 94 04	sta $0494			sta 	SliceCount 						; count in signcount
.018f5f	1a		inc a				inc 	a 								; allocate +1 for it.
.018f60	20 6d 91	jsr $01916d			jsr 	AllocateTempString
.018f63	68		pla				pla 									; pop start number off stack.
.018f64	f0 3f		beq $018fa5			beq 	SLIError 						; exit if start = 0
.018f66	8d 93 04	sta $0493			sta 	SliceStart
.018f69	68		pla				pla  									; pop string address.
.018f6a	85 1f		sta $1f				sta 	zGenPtr+1
.018f6c	68		pla				pla
.018f6d	85 1e		sta $1e				sta 	zGenPtr
.018f6f	da		phx				phx
.018f70	5a		phy				phy
.018f71	a2 00		ldx #$00			ldx 	#0 								; point to string length.
.018f73	ac 93 04	ldy $0493			ldy 	SliceStart 						; start of the string (+1 for count)
.018f76					_SLICopy:
.018f76	ad 94 04	lda $0494			lda 	SliceCount 						; done count characters
.018f79	f0 12		beq $018f8d			beq 	_SLIExit
.018f7b	ce 94 04	dec $0494			dec 	SliceCount
.018f7e	98		tya				tya 									; index of character
.018f7f	c1 1e		cmp ($1e,x)			cmp 	(zGenPtr,x)						; compare against length
.018f81	f0 02		beq $018f85			beq 	_SLIOk 							; if equal, okay.
.018f83	b0 08		bcs $018f8d			bcs 	_SLIExit 						; if past end, then exit.
.018f85	b1 1e		lda ($1e),y	_SLIOk:	lda 	(zGenPtr),y 					; copy one character
.018f87	c8		iny				iny
.018f88	20 98 91	jsr $019198			jsr 	WriteTempString
.018f8b	80 e9		bra $018f76			bra 	_SLICopy 						; go round till copied characters
.018f8d					_SLIExit:
.018f8d	7a		ply				ply 									; restore YX
.018f8e	fa		plx				plx
.018f8f	4c bb 90	jmp $0190bb			jmp 	UnaryReturnTempStr 				; return new temporary string.
.018f92	ea		nop				nop
.018f93					SLIByteParameter:
.018f93	20 74 8a	jsr $018a74			jsr 	EvaluateIntegerX 				; get integer
.018f96	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.018f99	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.018f9c	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.018f9f	d0 04		bne $018fa5			bne 	SLIError
.018fa1	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018fa4	60		rts				rts
.018fa5					SLIError:
.018fa5	4c 1e 84	jmp $01841e			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.018fa8					Unary_Hex:
.018fa8	20 74 8a	jsr $018a74			jsr 	EvaluateIntegerX 			; numeric parameter
.018fab	20 2b 91	jsr $01912b			jsr 	CheckNextRParen 			; right bracket.
.018fae	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.018fb0	20 6d 91	jsr $01916d			jsr 	AllocateTempString			; allocate string space
.018fb3	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.018fb6	20 dd 8f	jsr $018fdd			jsr 	_UHConvert
.018fb9	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018fbc	20 dd 8f	jsr $018fdd			jsr 	_UHConvert
.018fbf	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018fc2	20 dd 8f	jsr $018fdd			jsr 	_UHConvert
.018fc5	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018fc8	20 dd 8f	jsr $018fdd			jsr 	_UHConvert
.018fcb	5a		phy				phy 								; get length of new string
.018fcc	a0 00		ldy #$00			ldy 	#0
.018fce	b1 20		lda ($20),y			lda 	(zTempStr),y
.018fd0	7a		ply				ply
.018fd1	c9 00		cmp #$00			cmp 	#0
.018fd3	d0 05		bne $018fda			bne 	_UHExit 					; if it was non zero okay
.018fd5	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.018fd7	20 98 91	jsr $019198			jsr 	WriteTempString
.018fda					_UHExit:
.018fda	4c bb 90	jmp $0190bb			jmp 	UnaryReturnTempStr 			; return new temporary string.
.018fdd					_UHConvert:
.018fdd	48		pha				pha
.018fde	4a		lsr a				lsr 	a 							; do MSB
.018fdf	4a		lsr a				lsr 	a
.018fe0	4a		lsr a				lsr 	a
.018fe1	4a		lsr a				lsr 	a
.018fe2	20 e6 8f	jsr $018fe6			jsr 	_UHNibble
.018fe5	68		pla				pla 								; do LSB
.018fe6					_UHNibble:
.018fe6	29 0f		and #$0f			and 	#15 						; get nibble
.018fe8	d0 0c		bne $018ff6			bne 	_UHNonZero
.018fea	5a		phy				phy									; get the length
.018feb	a0 00		ldy #$00			ldy 	#0
.018fed	b1 20		lda ($20),y			lda 	(zTempStr),y
.018fef	7a		ply				ply
.018ff0	c9 00		cmp #$00			cmp 	#0 							; suppress leading zeros.
.018ff2	f0 0d		beq $019001			beq 	_UHExit2
.018ff4	a9 00		lda #$00			lda 	#0
.018ff6					_UHNonZero:
.018ff6	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.018ff8	90 02		bcc $018ffc			bcc 	_UHDigit
.018ffa	69 06		adc #$06			adc 	#7-1
.018ffc					_UHDigit:
.018ffc	69 30		adc #$30			adc 	#48
.018ffe	20 98 91	jsr $019198			jsr 	WriteTempString				; output.
.019001					_UHExit2:
.019001	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.019002					Unary_Dec:
.019002	20 7d 8a	jsr $018a7d			jsr 	EvaluateStringX 			; string parameter
.019005	20 2b 91	jsr $01912b			jsr 	CheckNextRParen 			; right bracket.
.019008	5a		phy				phy
.019009	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.01900b	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.01900d	f0 4c		beq $01905b			beq 	_UDFail 					; must fail if zero.
.01900f	8d 90 04	sta $0490			sta 	SignCount 					; use SignCount as a counter
.019012	a9 00		lda #$00			lda 	#0 							; set result to zero integer.
.019014	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019017	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.01901a	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01901d	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019020	a9 01		lda #$01			lda 	#1
.019022	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019025					_UDConvertLoop:
.019025	5a		phy				phy 								; shift mantissa left 4
.019026	a0 04		ldy #$04			ldy 	#4
.019028					_UDShift:
.019028	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x
.01902b	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.01902e	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.019031	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.019034	88		dey				dey
.019035	d0 f1		bne $019028			bne 	_UDShift
.019037	7a		ply				ply
.019038	c8		iny				iny 								; next character
.019039	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; fetch it.
.01903b	20 5e 90	jsr $01905e			jsr 	ConvertUpper 				; convert to U/C
.01903e	c9 30		cmp #$30			cmp 	#"0"
.019040	90 19		bcc $01905b			bcc 	_UDFail
.019042	c9 3a		cmp #$3a			cmp 	#"9"+1
.019044	90 06		bcc $01904c			bcc 	_UDOkay
.019046	e9 37		sbc #$37			sbc 	#7+"0" 						; alpha fudge
.019048	c9 10		cmp #$10			cmp 	#16
.01904a	b0 0f		bcs $01905b			bcs 	_UDFail
.01904c					_UDOkay:
.01904c	29 0f		and #$0f			and 	#15 						; nibble only
.01904e	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x
.019051	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019054	ce 90 04	dec $0490			dec 	SignCount 					; do it for each character
.019057	d0 cc		bne $019025			bne 	_UDConvertLoop
.019059	7a		ply				ply
.01905a	60		rts				rts
.01905b					_UDFail:
.01905b	4c 1e 84	jmp $01841e			jmp 	BadParamError
.01905e					ConvertUpper:
.01905e	c9 61		cmp #$61			cmp 	#"a"
.019060	90 07		bcc $019069			bcc 	_CUExit
.019062	c9 7b		cmp #$7b			cmp 	#"z"+1
.019064	b0 03		bcs $019069			bcs 	_CUExit
.019066	38		sec				sec
.019067	e9 20		sbc #$20			sbc 	#32
.019069	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.01906a					Unary_Chr:
.01906a	20 74 8a	jsr $018a74			jsr 	EvaluateIntegerX			; numeric parameter
.01906d	20 2b 91	jsr $01912b			jsr 	CheckNextRParen 			; right bracket.
.019070	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.019073	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.019076	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.019079	d0 0e		bne $019089			bne 	_UCChar
.01907b	a9 01		lda #$01			lda 	#1 							; one character string
.01907d	20 6d 91	jsr $01916d			jsr 	AllocateTempString
.019080	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.019083	20 98 91	jsr $019198			jsr 	WriteTempString
.019086	4c bb 90	jmp $0190bb			jmp 	UnaryReturnTempStr
.019089					_UCChar:
.019089	4c 1e 84	jmp $01841e			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.01908c					Unary_Spc:
.01908c	20 74 8a	jsr $018a74			jsr 	EvaluateIntegerX 			; numeric parameter
.01908f	20 2b 91	jsr $01912b			jsr 	CheckNextRParen 			; right bracket.
.019092	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.019095	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.019098	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.01909b	d0 1b		bne $0190b8			bne 	_USSize
.01909d	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.0190a0	c9 fe		cmp #$fe			cmp 	#maxString+1
.0190a2	b0 14		bcs $0190b8			bcs 	_USSize
.0190a4	48		pha				pha 								; save length
.0190a5	1a		inc a				inc 	a 							; allocate one more.
.0190a6	20 6d 91	jsr $01916d			jsr 	AllocateTempString
.0190a9	68		pla				pla 								; get length
.0190aa	f0 0f		beq $0190bb			beq 	UnaryReturnTempStr 			; return the current temp string
.0190ac					_USLoop:
.0190ac	48		pha				pha
.0190ad	a9 20		lda #$20			lda 	#" "
.0190af	20 98 91	jsr $019198			jsr 	WriteTempString
.0190b2	68		pla				pla
.0190b3	3a		dec a				dec 	a
.0190b4	d0 f6		bne $0190ac			bne 	_USLoop
.0190b6	80 03		bra $0190bb			bra 	UnaryReturnTempStr
.0190b8					_USSize:
.0190b8	4c 1e 84	jmp $01841e			jmp 	BadParamError
.0190bb					UnaryReturnTempStr:
.0190bb	a5 20		lda $20				lda 	zTempStr 					; copy temp string addr -> mantissa
.0190bd	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0190c0	a5 21		lda $21				lda 	zTempStr+1
.0190c2	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0190c5	a9 02		lda #$02			lda 	#2 							; set type to string
.0190c7	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0190ca	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/65816.asm

.0190cb					MemRead:
.0190cb	8d 90 04	sta $0490			sta 	SignCount 					; save count
.0190ce	a0 00		ldy #$00			ldy 	#0 							; start from here
.0190d0	b7 1a		lda [$1a],y	_MLoop1:lda 	[zlTemp1],y 				; read the long address
.0190d2	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; copy into mantissa
.0190d5	c8		iny				iny 								; next to copy
.0190d6	e8		inx				inx
.0190d7	cc 90 04	cpy $0490			cpy 	SignCount 					; do required # of bytes.
.0190da	d0 f4		bne $0190d0			bne 	_MLoop1
.0190dc	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/programend.asm

.0190dd					UpdateProgramEnd:
.0190dd	a9 00		lda #$00			lda 	#BasicProgram & $FF
.0190df	85 16		sta $16				sta 	zCodePtr+0
.0190e1	a9 10		lda #$10			lda 	#BasicProgram >> 8
.0190e3	85 17		sta $17				sta 	zCodePtr+1
.0190e5	a9 00		lda #$00			lda 	#0
.0190e7	85 18		sta $18				sta 	zCodePtr+2
.0190e9	85 19		sta $19				sta 	zCodePtr+3
.0190eb	a0 03		ldy #$03			ldy 	#3
.0190ed					_UPDLoop:
.0190ed	a0 00		ldy #$00			ldy 	#0
.0190ef	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0190f1	c9 00		cmp #$00			cmp 	#0 							; end if offset is zero.
.0190f3	f0 0f		beq $019104			beq 	_UPDFoundEnd
.0190f5	a0 00		ldy #$00			ldy 	#0 							; point to offset
.0190f7	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.0190f9	18		clc				clc
.0190fa	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.0190fc	85 16		sta $16				sta 	zCodePtr
.0190fe	90 02		bcc $019102			bcc 	_SNLNoCarry
.019100	e6 17		inc $17				inc 	zCodePtr+1
.019102					_SNLNoCarry:
.019102	80 e9		bra $0190ed			bra 	_UPDLoop
.019104					_UPDFoundEnd:
.019104	18		clc				clc 								; end of program 2 on.
.019105	a5 16		lda $16				lda 	zCodePtr
.019107	69 02		adc #$02			adc 	#2
.019109	8d 04 04	sta $0404			sta 	endOfProgram
.01910c	a5 17		lda $17				lda 	zCodePtr+1
.01910e	69 00		adc #$00			adc 	#0
.019110	8d 05 04	sta $0405			sta 	endOfProgram+1
.019113	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.019114					CheckNextToken:
.019114	d7 16		cmp [$16],y			cmp 	[zCodePtr],y
.019116	d0 02		bne $01911a			bne 	CTFail 						; no, then fail
.019118	c8		iny				iny
.019119	60		rts				rts
.01911a					CTFail:
.01911a	20 2f 84	jsr $01842f			jsr ERR_Handler
>01911d	4d 69 73 73 69 6e 67 20			.text "Missing token",0
>019125	74 6f 6b 65 6e 00
.01912b					CheckNextRParen:
.01912b	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01912d	c9 be		cmp #$be			cmp 	#token_rparen
.01912f	d0 e9		bne $01911a			bne 	CTFail
.019131	c8		iny				iny
.019132	60		rts				rts
.019133					CheckNextComma:
.019133	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019135	c9 bf		cmp #$bf			cmp 	#token_comma
.019137	d0 e1		bne $01911a			bne 	CTFail
.019139	c8		iny				iny
.01913a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/concrete.asm

.01913b					StringConcrete:
.01913b	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; save source to zTemp1
.01913e	85 10		sta $10				sta 	zTemp1
.019140	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.019143	85 11		sta $11				sta 	zTemp1+1
.019145	a0 00		ldy #$00			ldy 	#0 							; subtract the length+1 (clc) of the string.
.019147	18		clc				clc 								; from the string pointer
.019148	ad 00 04	lda $0400			lda 	StringPtr 					; and put in zTemp2 as well
.01914b	f1 10		sbc ($10),y			sbc 	(zTemp1),y
.01914d	8d 00 04	sta $0400			sta 	StringPtr
.019150	85 12		sta $12				sta 	zTemp2
.019152	ad 01 04	lda $0401			lda 	StringPtr+1
.019155	e9 00		sbc #$00			sbc 	#0
.019157	8d 01 04	sta $0401			sta 	StringPtr+1
.01915a	85 13		sta $13				sta 	zTemp2+1
.01915c	b1 10		lda ($10),y			lda 	(zTemp1),y 					; length add one for count
.01915e	1a		inc a				inc 	a
.01915f	aa		tax				tax
.019160	b1 10		lda ($10),y	_SCCopy:lda 	(zTemp1),y 					; copy whole thing including length
.019162	91 12		sta ($12),y			sta 	(zTemp2),y
.019164	c8		iny				iny
.019165	ca		dex				dex
.019166	d0 f8		bne $019160			bne 	_SCCopy
.019168	a5 13		lda $13				lda 	zTemp2+1 					; return concrete string in AX
.01916a	a6 12		ldx $12				ldx 	zTemp2
.01916c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.01916d					AllocateTempString:
.01916d	48		pha				pha 								; save required count.
.01916e	a5 21		lda $21				lda 	zTempStr+1 					; check if initialised yet ?
.019170	d0 0b		bne $01917d			bne 	_ATSInitialised
.019172	ad 00 04	lda $0400			lda 	StringPtr 					; set temporary string ptr 1 page below available
.019175	85 20		sta $20				sta 	zTempStr					; space, this is for strings to be concreted.
.019177	ad 01 04	lda $0401			lda 	StringPtr+1
.01917a	3a		dec a				dec 	a
.01917b	85 21		sta $21				sta 	zTempStr+1
.01917d					_ATSInitialised:
.01917d	68		pla				pla 								; get required count back.
.01917e	49 ff		eor #$ff			eor 	#$FF 						; negate 2's complement.
.019180	1a		inc a				inc 	a
.019181	18		clc				clc
.019182	65 20		adc $20				adc 	zTempStr 					; "add" to the temp string pointer
.019184	85 20		sta $20				sta 	zTempStr
.019186	a9 ff		lda #$ff			lda 	#$FF
.019188	65 21		adc $21				adc 	zTempStr+1
.01918a	85 21		sta $21				sta 	zTempStr+1
.01918c	a9 00		lda #$00			lda 	#0 							; clear temp string.
.01918e	5a		phy				phy
.01918f	a8		tay				tay
.019190	91 20		sta ($20),y			sta 	(zTempStr),y
.019192	7a		ply				ply
.019193	1a		inc a				inc 	a 							; reset the write index.
.019194	8d 91 04	sta $0491			sta 	TempStringWriteIndex
.019197	60		rts				rts
.019198					WriteTempString:
.019198	5a		phy				phy 								; save Y
.019199	ac 91 04	ldy $0491			ldy 	TempStringWriteIndex	 	; write position.
.01919c	91 20		sta ($20),y			sta 	(zTempStr),y 				; write character out.
.01919e	ee 91 04	inc $0491			inc 	TempStringWriteIndex 		; increment the write position.
.0191a1	98		tya				tya 								; unchanged Y is now length
.0191a2	a0 00		ldy #$00			ldy 	#0
.0191a4	91 20		sta ($20),y			sta 	(zTempStr),y
.0191a6	7a		ply				ply 								; restore Y and exit
.0191a7	60		rts				rts
.0191a8					CreateTempStringCopy:
.0191a8	da		phx				phx 								; save X
.0191a9	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0191ab	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.0191ac	20 6d 91	jsr $01916d			jsr 	AllocateTempString 			; allocate memory for temporary string.
.0191af	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0191b1	c8		iny				iny
.0191b2	3a		dec a				dec 	a 							; make the actual length in charactes
.0191b3	3a		dec a				dec 	a
.0191b4	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.0191b6	81 20		sta ($20,x)			sta 	(zTempStr,x)
.0191b8	85 1a		sta $1a				sta 	zLTemp1 					; that's used as a count.
.0191ba	09 00		ora #$00			ora 	#0 							; if zero already, exit
.0191bc	f0 0e		beq $0191cc			beq 	_CTSCExit
.0191be					_CTSCLoop:
.0191be	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0191c0	c8		iny				iny
.0191c1	5a		phy				phy 								; save in Y
.0191c2	e8		inx				inx 								; bump index
.0191c3	da		phx				phx 								; index into Y
.0191c4	7a		ply				ply
.0191c5	91 20		sta ($20),y			sta 	(zTempStr),y 				; save at index
.0191c7	7a		ply				ply 								; restore Y
.0191c8	c6 1a		dec $1a				dec 	zLTemp1 					; do for each character
.0191ca	d0 f2		bne $0191be			bne 	_CTSCLoop
.0191cc					_CTSCExit:
.0191cc	fa		plx				plx 								; restore X
.0191cd	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/variables.asm

.0191ce					VariableFind:
.0191ce	20 3b 92	jsr $01923b			jsr 	VariableExtract 		; find out all about it ....
.0191d1	20 dd 94	jsr $0194dd			jsr 	VariableLocate 			; does it already exist ?
.0191d4	b0 03		bcs $0191d9			bcs 	_VFExists 				; if so, use that.
.0191d6	20 c7 92	jsr $0192c7			jsr 	VariableCreate 			; otherwise create it.
.0191d9					_VFExists:
.0191d9	a5 24		lda $24				lda 	zVarType 				; is it still an array ?
.0191db	29 01		and #$01			and 	#1
.0191dd	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.0191df	d0 28		bne $019209			bne 	_VFSingleElement
.0191e1					_VFNextIndex:
.0191e1	a5 22		lda $22				lda 	zVarDataPtr 			; push the data ptr and type on the stack.
.0191e3	48		pha				pha
.0191e4	a5 23		lda $23				lda 	zVarDataPtr+1
.0191e6	48		pha				pha
.0191e7	a5 24		lda $24				lda 	zVarType
.0191e9	48		pha				pha
.0191ea	20 74 8a	jsr $018a74			jsr 	EvaluateIntegerX 		; calculate the index.
.0191ed	68		pla				pla 							; restore and index.
.0191ee	85 24		sta $24				sta 	zVarType
.0191f0	68		pla				pla
.0191f1	85 23		sta $23				sta 	zVarDataPtr+1
.0191f3	68		pla				pla
.0191f4	85 22		sta $22				sta 	zVarDataPtr
.0191f6	20 52 93	jsr $019352			jsr 	ArrayIndexFollow 		; do the index.
.0191f9	a5 24		lda $24				lda 	zVarType 				; is it still an array ??
.0191fb	29 01		and #$01			and 	#1
.0191fd	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.0191ff	d0 05		bne $019206			bne 	_VFArrayDone 			; if so then exit.
.019201	20 33 91	jsr $019133			jsr 	CheckNextComma 			; comma should follow
.019204	80 db		bra $0191e1			bra 	_VFNextIndex
.019206					_VFArrayDone:
.019206	20 2b 91	jsr $01912b			jsr 	CheckNextRParen 		; check closing right bracket.
.019209					_VFSingleElement:
.019209	60		rts				rts
.01920a					VariableClear:
.01920a	48		pha				pha 							; save registers
.01920b	da		phx				phx
.01920c	a2 00		ldx #$00			ldx 	#0 						; clear out the hash table.
.01920e	8a		txa				txa
.01920f	9d 27 04	sta $0427,x	_VCLoop:sta 	HashTableBase,x
.019212	e8		inx				inx
.019213	e0 60		cpx #$60			cpx 	#HashTableEnd-HashTableBase
.019215	d0 f8		bne $01920f			bne 	_VCLoop
.019217	ad 04 04	lda $0404			lda 	endOfProgram
.01921a	8d 02 04	sta $0402			sta 	VarMemPtr
.01921d	ad 05 04	lda $0405			lda 	endOfProgram+1
.019220	8d 03 04	sta $0403			sta 	VarMemPtr+1
.019223	fa		plx				plx 							; restore registers
.019224	68		pla				pla
.019225	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/extract.asm

.019226					VariableNameError:
.019226	20 2f 84	jsr $01842f			jsr ERR_Handler
>019229	42 61 64 20 56 61 72 69			.text "Bad Variable Name",0
>019231	61 62 6c 65 20 4e 61 6d 65 00
.01923b					VariableExtract:
.01923b	da		phx				phx 							; save X.
.01923c	a9 ba		lda #$ba			lda 	#token_hashlParen  		; set the type to #( e.g. real array.
.01923e	8d 87 04	sta $0487			sta 	Var_Type
.019241	8d 88 04	sta $0488			sta 	Var_Hash 				; we initialise the hash with this. It doesn't matter
.019244	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019246	c9 00		cmp #$00			cmp 	#0 						; first one must be A-Z
.019248	f0 dc		beq $019226			beq 	VariableNameError
.01924a	c9 1b		cmp #$1b			cmp 	#26+1
.01924c	b0 d8		bcs $019226			bcs 	VariableNameError
.01924e	a2 ff		ldx #$ff			ldx 	#255 					; now copy it into the variable buffer.
.019250					_VECopyBuffer:
.019250	e8		inx				inx
.019251	e0 1f		cpx #$1f			cpx 	#31 					; too long
.019253	f0 d1		beq $019226			beq 	VariableNameError
.019255	9d 07 04	sta $0407,x			sta 	Var_Buffer,x 			; save character
.019258	18		clc				clc  							; update the hash value for it.
.019259	6d 88 04	adc $0488			adc 	Var_Hash
.01925c	8d 88 04	sta $0488			sta 	Var_Hash
.01925f	c8		iny				iny
.019260	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019262	c9 00		cmp #$00			cmp 	#0 						; zero or token, end of variable
.019264	f0 0e		beq $019274			beq 	_VECopyEnd
.019266	30 0c		bmi $019274			bmi 	_VECopyEnd
.019268	c9 1b		cmp #$1b			cmp 	#26+1 					; A-Z continue copying
.01926a	90 e4		bcc $019250			bcc 	_VECopyBuffer
.01926c	c9 30		cmp #$30			cmp 	#"0" 					; 0-9 copy as well.
.01926e	90 04		bcc $019274			bcc 	_VECopyEnd
.019270	c9 3a		cmp #$3a			cmp 	#"9"+1
.019272	90 dc		bcc $019250			bcc 	_VECopyBuffer
.019274					_VECopyEnd:
.019274	c8		iny				iny
.019275	c9 b7		cmp #$b7			cmp 	#token_Dollar 			; first type token.
.019277	90 04		bcc $01927d			bcc 	_VEDefaultRequired
.019279	c9 bd		cmp #$bd			cmp 	#token_PercentLParen+1	; last type token.
.01927b	90 0b		bcc $019288			bcc 	_VEHaveType
.01927d					_VEDefaultRequired:
.01927d	c9 bd		cmp #$bd			cmp 	#token_LParen 			; if it ends in ( then use the real array
.01927f	f0 04		beq $019285			beq 	_VESetType 				; default set above.
.019281	ce 87 04	dec $0487			dec 	Var_Type 				; this changes that default to the variable default
.019284	88		dey				dey
.019285					_VESetType:
.019285	ad 87 04	lda $0487			lda 	Var_Type 				; get type ....
.019288					_VEHaveType:
.019288	8d 87 04	sta $0487			sta 	Var_Type 				; save as type.
.01928b	bd 07 04	lda $0407,x			lda 	Var_Buffer,x 			; set bit 7 of name, marks the end.
.01928e	09 80		ora #$80			ora 	#$80
.019290	9d 07 04	sta $0407,x			sta 	Var_Buffer,x
.019293	e8		inx				inx 							; offset 3 => length 4.
.019294	8e 89 04	stx $0489			stx 	Var_Length 				; save length of variable name.
.019297	ad 87 04	lda $0487			lda 	Var_Type 				; get offset of var type from first type token
.01929a	38		sec				sec
.01929b	e9 b7		sbc #$b7			sbc 	#token_Dollar
.01929d	0a		asl a				asl 	a 						; multiply by 16. This requires HashTableSize
.01929e	0a		asl a				asl 	a 						; in data.asm to be 8 (8 sets of links,2 bytes each)
.01929f	0a		asl a				asl 	a
.0192a0	0a		asl a				asl 	a
.0192a1	8d 8a 04	sta $048a			sta 	Var_HashAddress
.0192a4	ad 88 04	lda $0488			lda 	Var_Hash 				; get the hash
.0192a7	29 07		and #$07			and 	#(HashTableSize-1) 		; force into range 0-tableSize-1
.0192a9	0a		asl a				asl 	a 						; double it (2 bytes per entry) & clears carry
.0192aa	6d 8a 04	adc $048a			adc 	Var_HashAddress 		; add table offset.
.0192ad	69 27		adc #$27			adc 	#HashTableBase & $FF 	; now the low byte of the actual table address
.0192af	8d 8a 04	sta $048a			sta 	Var_HashAddress
.0192b2	a2 05		ldx #$05			ldx 	#5 						; hash is 5 bytes (real)
.0192b4	ad 87 04	lda $0487			lda 	Var_Type
.0192b7	c9 b9		cmp #$b9			cmp 	#token_Hash
.0192b9	f0 07		beq $0192c2			beq 	_VEHaveSize
.0192bb	ca		dex				dex
.0192bc	c9 bb		cmp #$bb			cmp 	#token_Percent 			; percent is 4 bytes (integer)
.0192be	f0 02		beq $0192c2			beq 	_VEHaveSize
.0192c0	a2 02		ldx #$02			ldx 	#2 						; everything else is two.
.0192c2					_VEHaveSize:
.0192c2	8e 8b 04	stx $048b			stx 	Var_DataSize
.0192c5	fa		plx				plx
.0192c6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varcreate.asm

.0192c7					VariableCreate:
.0192c7	da		phx				phx
.0192c8	5a		phy				phy
.0192c9	ad 02 04	lda $0402			lda 	VarMemPtr 					; get address of next free into zTemp1
.0192cc	85 10		sta $10				sta 	zTemp1
.0192ce	ad 03 04	lda $0403			lda 	VarMemPtr+1
.0192d1	85 11		sta $11				sta 	zTemp1+1
.0192d3	ad 8b 04	lda $048b			lda 	Var_DataSize 				; bytes for the data bit
.0192d6	18		clc				clc
.0192d7	6d 89 04	adc $0489			adc 	Var_Length 					; add the length of the name
.0192da	69 03		adc #$03			adc 	#3 							; 3 for the link and the hash.
.0192dc	6d 02 04	adc $0402			adc 	VarMemPtr 					; add to variable memory pointer
.0192df	8d 02 04	sta $0402			sta 	VarMemPtr
.0192e2	90 03		bcc $0192e7			bcc 	_VCNoCarry
.0192e4	ee 03 04	inc $0403			inc 	VarMemPtr+1
.0192e7					_VCNoCarry:
.0192e7	ad 8a 04	lda $048a			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.0192ea	85 12		sta $12				sta 	zTemp2
.0192ec	a9 04		lda #$04			lda 	#HashTableBase >> 8
.0192ee	85 13		sta $13				sta 	zTemp2+1
.0192f0	a0 00		ldy #$00			ldy 	#0 							; put current hash link in position.
.0192f2	b1 12		lda ($12),y			lda 	(zTemp2),y
.0192f4	91 10		sta ($10),y			sta 	(zTemp1),y
.0192f6	c8		iny				iny
.0192f7	b1 12		lda ($12),y			lda 	(zTemp2),y
.0192f9	91 10		sta ($10),y			sta 	(zTemp1),y
.0192fb	c8		iny				iny
.0192fc	ad 88 04	lda $0488			lda 	Var_Hash 					; write the hash out.
.0192ff	91 10		sta ($10),y			sta 	(zTemp1),y
.019301	c8		iny				iny
.019302	a2 00		ldx #$00			ldx 	#0 							; copy the name out.
.019304					_VCCopyName:
.019304	bd 07 04	lda $0407,x			lda 	Var_Buffer,x
.019307	91 10		sta ($10),y			sta 	(zTemp1),y
.019309	e8		inx				inx
.01930a	c8		iny				iny
.01930b	ec 89 04	cpx $0489			cpx 	Var_Length
.01930e	d0 f4		bne $019304			bne 	_VCCopyName
.019310	5a		phy				phy 								; save the data offset.
.019311	ae 8b 04	ldx $048b			ldx 	Var_DataSize 				; and write the data out.
.019314	a9 00		lda #$00			lda 	#0 							; which is all zeroes.
.019316					_VCClearData:
.019316	91 10		sta ($10),y			sta 	(zTemp1),y
.019318	c8		iny				iny
.019319	ca		dex				dex
.01931a	d0 fa		bne $019316			bne 	_VCClearData
.01931c	68		pla				pla 								; offset to the data
.01931d	18		clc				clc
.01931e	65 10		adc $10				adc 	zTemp1 						; add to start and save as data pointer.
.019320	85 22		sta $22				sta 	zVarDataPtr
.019322	a5 11		lda $11				lda 	zTemp1+1
.019324	69 00		adc #$00			adc 	#0
.019326	85 23		sta $23				sta 	zVarDataPtr+1
.019328	ad 87 04	lda $0487			lda 	Var_Type 					; and set the type.
.01932b	85 24		sta $24				sta 	zVarType
.01932d	a5 10		lda $10				lda 	zTemp1 						; fix hash link to point to new record
.01932f	a0 00		ldy #$00			ldy 	#0
.019331	91 12		sta ($12),y			sta 	(zTemp2),y
.019333	c8		iny				iny
.019334	a5 11		lda $11				lda 	zTemp1+1
.019336	91 12		sta ($12),y			sta 	(zTemp2),y
.019338	ad 87 04	lda $0487			lda 	Var_Type 					; array ? if so create the empty one.
.01933b	29 01		and #$01			and 	#1
.01933d	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.01933f	d0 0e		bne $01934f			bne 	_VCNotArray
.019341	a2 00		ldx #$00			ldx 	#0 							; call recursive array creator
.019343	20 f2 93	jsr $0193f2			jsr 	ArrayCreate
.019346	5a		phy				phy 								; save YA at zVarDataPtr
.019347	a0 00		ldy #$00			ldy 	#0
.019349	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.01934b	c8		iny				iny
.01934c	68		pla				pla
.01934d	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.01934f					_VCNotArray:
.01934f	7a		ply				ply
.019350	fa		plx				plx
.019351	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arrayidx.asm

.019352					ArrayIndexFollow:
.019352	5a		phy				phy
.019353	a0 00		ldy #$00			ldy 	#0 							; make zVarDataPtr point to the array.
.019355	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; e.g. it points to itself.
.019357	48		pha				pha
.019358	c8		iny				iny
.019359	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.01935b	85 23		sta $23				sta 	zVarDataPtr+1
.01935d	68		pla				pla
.01935e	85 22		sta $22				sta 	zVarDataPtr
.019360	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 			; MSB of 16 bit integer and bytes 2&3
.019363	29 80		and #$80			and 	#$80 						; must be zero.
.019365	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.019368	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.01936b	d0 5f		bne $0193cc			bne 	_AIFError
.01936d	a0 00		ldy #$00			ldy 	#0 							; calculate size - current - 1
.01936f	18		clc				clc
.019370	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019372	fd 08 03	sbc $0308,x			sbc 	XS_Mantissa+0,x
.019375	c8		iny				iny
.019376	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019378	08		php				php 								; clear bit 7 retaining borrow.
.019379	29 7f		and #$7f			and 	#$7F
.01937b	28		plp				plp
.01937c	fd 09 03	sbc $0309,x			sbc 	XS_Mantissa+1,x
.01937f	90 4b		bcc $0193cc			bcc 	_AIFError 					; eror if size-current < 0
.019381	bd 08 03	lda $0308,x			lda  	XS_Mantissa+0,x 			; copy and double the index
.019384	0a		asl a				asl 	a 							; (e.g. index * 2)
.019385	85 10		sta $10				sta 	zTemp1
.019387	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.01938a	2a		rol a				rol 	a
.01938b	85 11		sta $11				sta 	zTemp1+1
.01938d	a0 01		ldy #$01			ldy 	#1 							; is this a data entry.
.01938f	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; if so, then type is unchanged, offset set
.019391	30 1f		bmi $0193b2			bmi 	_AIFCalculate
.019393	c6 24		dec $24				dec 	zVarType 					; converts from an array to a type.
.019395	a5 24		lda $24				lda 	zVarType 					; check that type
.019397	c9 b7		cmp #$b7			cmp 	#token_Dollar 				; if string, use x 2
.019399	f0 17		beq $0193b2			beq 	_AIFCalculate
.01939b	06 10		asl $10				asl 	zTemp1			 			; double the index
.01939d	26 11		rol $11				rol 	zTemp1+1					; (e.g. index * 4)
.01939f	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if integer, use x 4
.0193a1	f0 0f		beq $0193b2			beq 	_AIFCalculate
.0193a3	18		clc				clc 								; add the original mantissa in again
.0193a4	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; which makes it x5, for float.
.0193a7	65 10		adc $10				adc 	zTemp1
.0193a9	85 10		sta $10				sta 	zTemp1
.0193ab	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0193ae	65 11		adc $11				adc 	zTemp1+1
.0193b0	85 11		sta $11				sta 	zTemp1+1
.0193b2					_AIFCalculate:
.0193b2	18		clc				clc 								; add index x 2,4 or 5 to base
.0193b3	a5 22		lda $22				lda 	zVarDataPtr
.0193b5	65 10		adc $10				adc 	zTemp1
.0193b7	85 22		sta $22				sta 	zVarDataPtr
.0193b9	a5 23		lda $23				lda 	zVarDataPtr+1
.0193bb	65 11		adc $11				adc 	zTemp1+1
.0193bd	85 23		sta $23				sta 	zVarDataPtr+1
.0193bf	18		clc				clc 								; add 2 more for the length prefix.
.0193c0	a5 22		lda $22				lda 	zVarDataPtr
.0193c2	69 02		adc #$02			adc 	#2
.0193c4	85 22		sta $22				sta 	zVarDataPtr
.0193c6	90 02		bcc $0193ca			bcc 	_AIFNoBump
.0193c8	e6 23		inc $23				inc 	zVarDataPtr+1
.0193ca					_AIFNoBump:
.0193ca	7a		ply				ply
.0193cb	60		rts				rts
.0193cc					_AIFError:
.0193cc	20 2f 84	jsr $01842f			jsr ERR_Handler
>0193cf	42 61 64 20 61 72 72 61			.text "Bad array index",0
>0193d7	79 20 69 6e 64 65 78 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arraydef.asm

.0193df					ArrayResetDefault:
.0193df	a9 0b		lda #$0b			lda 	#11 						; 0..10 one array
.0193e1	8d 99 04	sta $0499			sta 	ArrayDef+0
.0193e4	a9 00		lda #$00			lda 	#0
.0193e6	8d 9a 04	sta $049a			sta 	ArrayDef+1
.0193e9	a9 ff		lda #$ff			lda 	#$FF
.0193eb	8d 9b 04	sta $049b			sta 	ArrayDef+2 					; $FFFF implies no second element.
.0193ee	8d 9c 04	sta $049c			sta 	ArrayDef+3					; (test bit 7 of 2nd byte)
.0193f1	60		rts				rts
.0193f2					ArrayCreate:
.0193f2	bd 99 04	lda $0499,x			lda 	ArrayDef+0,x 				; put size x 2 in zTemp1
.0193f5	0a		asl a				asl 	a
.0193f6	85 10		sta $10				sta 	zTemp1
.0193f8	bd 9a 04	lda $049a,x			lda 	ArrayDef+1,x
.0193fb	2a		rol a				rol 	a
.0193fc	85 11		sta $11				sta 	zTemp1+1
.0193fe	bd 9c 04	lda $049c,x			lda 	ArrayDef+3,x 				; if this is the last element it's array of ptrs.
.019401	10 22		bpl $019425			bpl 	_ACSized 					; if not multiply size x 2 (str) 4 (int) 5 (real)
.019403	ad 87 04	lda $0487			lda 	Var_Type 					; check the type
.019406	c9 b8		cmp #$b8			cmp 	#token_DollarLParen 		; also if it is an array of strings $(
.019408	f0 1b		beq $019425			beq 	_ACSized
.01940a	06 10		asl $10				asl 	zTemp1 						; double again
.01940c	26 11		rol $11				rol 	zTemp1+1
.01940e	b0 6f		bcs $01947f			bcs 	ArrayIndexError 			; too large.
.019410	c9 bc		cmp #$bc			cmp 	#token_PercentLParen 		; if %( four bytes/entry is enough.
.019412	f0 11		beq $019425			beq 	_ACSized
.019414	18		clc				clc 								; add original value x 5 for reals.
.019415	a5 10		lda $10				lda 	zTemp1
.019417	7d 99 04	adc $0499,x			adc 	ArrayDef+0,x
.01941a	85 10		sta $10				sta 	zTemp1
.01941c	a5 11		lda $11				lda 	zTemp1+1
.01941e	7d 9a 04	adc $049a,x			adc 	ArrayDef+1,x
.019421	85 11		sta $11				sta 	zTemp1+1
.019423	b0 5a		bcs $01947f			bcs 	ArrayIndexError
.019425					_ACSized:
.019425	18		clc				clc
.019426	a5 10		lda $10				lda 	zTemp1
.019428	69 02		adc #$02			adc 	#2
.01942a	85 10		sta $10				sta 	zTemp1
.01942c	90 04		bcc $019432			bcc 	_ACNoBump
.01942e	e6 10		inc $10				inc 	zTemp1
.019430	f0 4d		beq $01947f			beq 	ArrayIndexError
.019432					_ACNoBump:
.019432	18		clc				clc
.019433	ad 02 04	lda $0402			lda 	VarMemPtr 					; add this allocated count to VarMemPtr
.019436	85 12		sta $12				sta 	zTemp2						; save start in zTemp2/zTemp3
.019438	85 14		sta $14				sta 	zTemp3
.01943a	65 10		adc $10				adc 	zTemp1
.01943c	8d 02 04	sta $0402			sta 	VarMemPtr
.01943f	ad 03 04	lda $0403			lda 	VarMemPtr+1
.019442	85 13		sta $13				sta 	zTemp2+1
.019444	85 15		sta $15				sta 	zTemp3+1
.019446	65 11		adc $11				adc 	zTemp1+1
.019448	8d 03 04	sta $0403			sta 	VarMemPtr+1
.01944b	85 11		sta $11				sta 	zTemp1+1
.01944d	b0 30		bcs $01947f			bcs 	ArrayIndexError
.01944f	a0 00		ldy #$00			ldy 	#0							; write $00 out.
.019451					_ACClear:
.019451	98		tya				tya
.019452	91 12		sta ($12),y			sta 	(zTemp2),y
.019454	e6 12		inc $12				inc 	zTemp2
.019456	d0 02		bne $01945a			bne 	_ACCBump
.019458	e6 13		inc $13				inc 	zTemp2+1
.01945a					_ACCBump:
.01945a	a5 12		lda $12				lda 	zTemp2
.01945c	cd 02 04	cmp $0402			cmp 	VarMemPtr
.01945f	d0 f0		bne $019451			bne 	_ACClear
.019461	a5 13		lda $13				lda 	zTemp2+1
.019463	cd 03 04	cmp $0403			cmp 	VarMemPtr+1
.019466	d0 e9		bne $019451			bne 	_ACClear
.019468	a0 00		ldy #$00			ldy 	#0
.01946a	bd 99 04	lda $0499,x			lda 	ArrayDef+0,x 				; copy the size into the start
.01946d	91 14		sta ($14),y			sta 	(zTemp3),y
.01946f	c8		iny				iny
.019470	bd 9a 04	lda $049a,x			lda 	ArrayDef+1,x
.019473	91 14		sta ($14),y			sta 	(zTemp3),y
.019475	bd 9c 04	lda $049c,x			lda 	ArrayDef+3,x 				; have we reached the end
.019478	10 18		bpl $019492			bpl 	ACCFillRecursive
.01947a	a4 15		ldy $15				ldy 	zTemp3+1 					; return address
.01947c	a5 14		lda $14				lda 	zTemp3
.01947e	60		rts				rts
.01947f					ArrayIndexError:
.01947f	20 2f 84	jsr $01842f			jsr ERR_Handler
>019482	42 61 64 20 61 72 72 61			.text "Bad array index",0
>01948a	79 20 69 6e 64 65 78 00
.019492					ACCFillRecursive:
.019492	a9 ff		lda #$ff			lda 	#$FF 						; we mark the end, this is free space.
.019494	a0 00		ldy #$00			ldy 	#0 							; this is overwritten by size of next allocated
.019496	91 12		sta ($12),y			sta 	(zTemp2),y 					; array, but we might change that.
.019498	c8		iny				iny
.019499	b1 14		lda ($14),y			lda 	(zTemp3),y 					; set bit 15 of the max index indicating
.01949b	09 80		ora #$80			ora 	#$80 						; an array of pointers
.01949d	91 14		sta ($14),y			sta 	(zTemp3),y
.01949f	a5 14		lda $14				lda 	zTemp3 						; push the start on the stack
.0194a1	48		pha				pha
.0194a2	a5 15		lda $15				lda 	zTemp3+1
.0194a4	48		pha				pha
.0194a5					_ACCFillLoop:
.0194a5	18		clc				clc
.0194a6	a5 14		lda $14				lda 	zTemp3 						; and work forwards.
.0194a8	69 02		adc #$02			adc 	#2
.0194aa	85 14		sta $14				sta 	zTemp3
.0194ac	90 02		bcc $0194b0			bcc 	_ACCSkip2
.0194ae	e6 14		inc $14				inc 	zTemp3
.0194b0					_ACCSkip2:
.0194b0	a0 00		ldy #$00			ldy 	#0 							; reached the end ?
.0194b2	b1 14		lda ($14),y			lda 	(zTemp3),y					; (looking for FF marker, everything else 00)
.0194b4	c8		iny				iny
.0194b5	11 14		ora ($14),y			ora 	(zTemp3),y
.0194b7	d0 21		bne $0194da			bne 	_ACCExit
.0194b9	a5 14		lda $14				lda 	zTemp3 						; push zTemp3
.0194bb	48		pha				pha
.0194bc	a5 15		lda $15				lda 	zTemp3+1
.0194be	48		pha				pha
.0194bf	e8		inx				inx
.0194c0	e8		inx				inx
.0194c1	20 f2 93	jsr $0193f2			jsr 	ArrayCreate 				; create array recursively.
.0194c4	ca		dex				dex
.0194c5	ca		dex				dex
.0194c6	85 12		sta $12				sta 	zTemp2 						; save A
.0194c8	68		pla				pla
.0194c9	85 15		sta $15				sta 	zTemp3+1 					; restore zTemp3
.0194cb	68		pla				pla
.0194cc	85 14		sta $14				sta 	zTemp3
.0194ce	98		tya				tya 								; write high bye from Y
.0194cf	a0 01		ldy #$01			ldy 	#1
.0194d1	91 14		sta ($14),y			sta 	(zTemp3),y
.0194d3	88		dey				dey 								; write low byte out.
.0194d4	a5 12		lda $12				lda 	zTemp2
.0194d6	91 14		sta ($14),y			sta 	(zTemp3),y
.0194d8	80 cb		bra $0194a5			bra 	_ACCFillLoop 				; and try again.
.0194da					_ACCExit:
.0194da	7a		ply				ply 								; restore the original address
.0194db	68		pla				pla
.0194dc	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varfind.asm

.0194dd					VariableLocate:
.0194dd	da		phx				phx
.0194de	5a		phy				phy
.0194df	ad 8a 04	lda $048a			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.0194e2	85 12		sta $12				sta 	zTemp2 						; points to first address.
.0194e4	a9 04		lda #$04			lda 	#HashTableBase >> 8
.0194e6	85 13		sta $13				sta 	zTemp2+1
.0194e8	a0 00		ldy #$00	_VLNext:ldy 	#0 							; get next link into AX
.0194ea	b1 12		lda ($12),y			lda 	(zTemp2),y
.0194ec	aa		tax				tax
.0194ed	c8		iny				iny
.0194ee	b1 12		lda ($12),y			lda 	(zTemp2),y
.0194f0	85 13		sta $13				sta 	zTemp2+1 					; save in zTemp
.0194f2	86 12		stx $12				stx 	zTemp2
.0194f4	05 12		ora $12				ora 	zTemp2 						; got zero
.0194f6	18		clc				clc
.0194f7	f0 25		beq $01951e			beq 	_VLExit 					; if so, then fail as end of chain.
.0194f9	c8		iny				iny 								; point to hash (offset + 2)
.0194fa	b1 12		lda ($12),y			lda 	(zTemp2),y
.0194fc	cd 88 04	cmp $0488			cmp 	Var_Hash
.0194ff	d0 e7		bne $0194e8			bne 	_VLNext 					; try next if different.
.019501					_VLCompare:
.019501	c8		iny				iny 								; next character
.019502	b1 12		lda ($12),y			lda 	(zTemp2),y 					; compare variable field against buffer.
.019504	d9 04 04	cmp $0404,y			cmp 	Var_Buffer-3,y 				; the -3 is because name starts at 3.
.019507	d0 df		bne $0194e8			bne 	_VLNext 					; fail if different, try next.
.019509	0a		asl a				asl 	a 							; until end character (bit 7 set) matched
.01950a	90 f5		bcc $019501			bcc 	_VLCompare
.01950c	98		tya				tya
.01950d	38		sec				sec 								; add 1 as Y points to last character
.01950e	65 12		adc $12				adc 	zTemp2 						; add to the current address
.019510	85 22		sta $22				sta 	zVarDataPtr
.019512	a5 13		lda $13				lda 	zTemp2+1
.019514	69 00		adc #$00			adc 	#0
.019516	85 23		sta $23				sta 	zVarDataPtr+1
.019518	ad 87 04	lda $0487			lda 	Var_Type 					; and set the type.
.01951b	85 24		sta $24				sta 	zVarType
.01951d	38		sec				sec 								; return CS
.01951e	7a		ply		_VLExit:ply
.01951f	fa		plx				plx
.019520	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/vargetset.asm

.019521					VariableGet:
.019521	5a		phy				phy
.019522	a0 00		ldy #$00			ldy 	#0 							; copy first two bytes
.019524	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019526	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.019529	c8		iny				iny
.01952a	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.01952c	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.01952f	c8		iny				iny
.019530	a5 24		lda $24				lda 	zVarType 					; if it is a string, set up for that.
.019532	c9 b7		cmp #$b7			cmp 	#token_Dollar
.019534	f0 34		beq $01956a			beq 	_VGString
.019536	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; copy the next two bytes.
.019538	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01953b	c8		iny				iny
.01953c	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.01953e	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019541	c8		iny				iny
.019542	a9 01		lda #$01			lda 	#1 							; set type to 1.
.019544	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019547	a5 24		lda $24				lda 	zVarType
.019549	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if it is a %, then exit with default integer.
.01954b	f0 31		beq $01957e			beq 	_VGExit
.01954d	a9 40		lda #$40			lda 	#$40 						; set type byte to zero
.01954f	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; which is the code for zero/float.
.019552	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; the last value to copy is the exponent.
.019554	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.019557	f0 25		beq $01957e			beq 	_VGExit 					; if exponent is zero ... it's zero.
.019559	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; the sign bit is the top mantissa bit.
.01955c	48		pha				pha
.01955d	29 80		and #$80			and 	#$80
.01955f	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; this is the type byte.
.019562	68		pla				pla
.019563	09 80		ora #$80			ora 	#$80 						; set the MSB as you would expect.
.019565	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x 			; so it's a normalised float.
.019568	80 14		bra $01957e			bra 	_VGExit
.01956a					_VGString:
.01956a	a9 02		lda #$02			lda 	#2 							; set type to 2, a string
.01956c	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.01956f	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; is the value there $0000
.019572	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.019575	d0 07		bne $01957e			bne 	_VGExit 					; if not, exit.
.019577	85 25		sta $25				sta 	zNullString 				; make zNullString a 00 string.
.019579	a9 25		lda #$25			lda 	#zNullString
.01957b	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; make it point to it.
.01957e					_VGExit:
.01957e	7a		ply				ply
.01957f	60		rts				rts
.019580					VariableSet:
.019580	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; is the result a string
.019583	29 02		and #$02			and 	#2 							; if so, it has to be
.019585	d0 53		bne $0195da			bne 	_VSString
.019587	a5 24		lda $24				lda 	zVarType 					; if type is $ there's an error.
.019589	c9 b7		cmp #$b7			cmp 	#token_Dollar
.01958b	f0 4a		beq $0195d7			beq 	_VSBadType
.01958d	c9 bb		cmp #$bb			cmp 	#token_Percent 				; type convert to float/int
.01958f	f0 05		beq $019596			beq 	_VSMakeInt
.019591	20 8c 9b	jsr $019b8c			jsr 	FPUToFloat
.019594	80 03		bra $019599			bra 	_VSCopy
.019596					_VSMakeInt:
.019596	20 eb 9b	jsr $019beb			jsr 	FPUToInteger
.019599					_VSCopy:
.019599	5a		phy				phy
.01959a	a0 00		ldy #$00			ldy 	#0 							; copy mantissa to target.
.01959c	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.01959f	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0195a1	c8		iny				iny
.0195a2	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0195a5	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0195a7	c8		iny				iny
.0195a8	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.0195ab	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0195ad	c8		iny				iny
.0195ae	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.0195b1	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0195b3	a5 24		lda $24				lda 	zVarType 					; if target is integer, alrady done.
.0195b5	c9 bb		cmp #$bb			cmp 	#token_Percent
.0195b7	f0 1c		beq $0195d5			beq 	_VSExit
.0195b9	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get the sign bit into carry flag.
.0195bc	0a		asl a				asl 	a
.0195bd	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; shift the sign into the mantissa high.
.0195c0	08		php				php
.0195c1	0a		asl a				asl 	a
.0195c2	28		plp				plp
.0195c3	6a		ror a				ror 	a
.0195c4	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0195c6	c8		iny				iny
.0195c7	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; copy the exponent in
.0195ca	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0195cc	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if the result is non zero
.0195cf	50 04		bvc $0195d5			bvc 	_VSExit
.0195d1	a9 00		lda #$00			lda 	#00 						; zero exponent indicating 0.
.0195d3	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0195d5					_VSExit:
.0195d5	7a		ply				ply
.0195d6	60		rts				rts
.0195d7					_VSBadType:
.0195d7	4c 10 84	jmp $018410			jmp 	TypeError
.0195da					_VSString:
.0195da	a5 24		lda $24				lda 	zVarType 					; type must be $
.0195dc	c9 b7		cmp #$b7			cmp 	#token_Dollar
.0195de	d0 f7		bne $0195d7			bne 	_VSBadType
.0195e0	da		phx				phx
.0195e1	5a		phy				phy
.0195e2	20 3b 91	jsr $01913b			jsr 	StringConcrete 				; concrete the string in the mantissa -> AX
.0195e5	a0 01		ldy #$01			ldy 	#1 							; save high byte
.0195e7	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0195e9	88		dey				dey 								; save low byte
.0195ea	8a		txa				txa
.0195eb	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0195ed	7a		ply				ply 								; and exit.
.0195ee	fa		plx				plx
.0195ef	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.0195f0					MulInteger32:
.0195f0	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.0195f3	9d 14 03	sta $0314,x			sta 	XS3_Mantissa,x
.0195f6	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0195f9	9d 15 03	sta $0315,x			sta 	XS3_Mantissa+1,x
.0195fc	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.0195ff	9d 16 03	sta $0316,x			sta 	XS3_Mantissa+2,x
.019602	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.019605	9d 17 03	sta $0317,x			sta 	XS3_Mantissa+3,x
.019608	a9 00		lda #$00			lda 	#0
.01960a	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x 				; zero +0
.01960d	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019610	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019613	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019616					_BFMMultiply:
.019616	bd 14 03	lda $0314,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.019619	29 01		and #$01			and 	#1
.01961b	f0 03		beq $019620			beq 	_BFMNoAdd
.01961d	20 59 8c	jsr $018c59			jsr 	AddInteger32
.019620					_BFMNoAdd:
.019620	1e 0e 03	asl $030e,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.019623	3e 0f 03	rol $030f,x			rol 	XS2_Mantissa+1,x
.019626	3e 10 03	rol $0310,x			rol 	XS2_Mantissa+2,x
.019629	3e 11 03	rol $0311,x			rol 	XS2_Mantissa+3,x
.01962c	5e 17 03	lsr $0317,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.01962f	7e 16 03	ror $0316,x			ror 	XS3_Mantissa+2,x
.019632	7e 15 03	ror $0315,x			ror 	XS3_Mantissa+1,x
.019635	7e 14 03	ror $0314,x			ror 	XS3_Mantissa,x
.019638	bd 14 03	lda $0314,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.01963b	1d 15 03	ora $0315,x			ora 	XS3_Mantissa+1,x
.01963e	1d 16 03	ora $0316,x			ora 	XS3_Mantissa+2,x
.019641	1d 17 03	ora $0317,x			ora 	XS3_Mantissa+3,x
.019644	d0 d0		bne $019616			bne 	_BFMMultiply
.019646	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.019647					DivInteger32:
.019647	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; check for /0
.01964a	1d 0f 03	ora $030f,x			ora 	XS2_Mantissa+1,x
.01964d	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.019650	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.019653	d0 14		bne $019669			bne 	_BFDOkay
.019655	20 2f 84	jsr $01842f			jsr ERR_Handler
>019658	44 69 76 69 73 69 6f 6e			.text "Division by Zero",0
>019660	20 62 79 20 5a 65 72 6f 00
.019669					_BFDOkay:
.019669	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.01966b	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.01966d	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.01966f	85 1c		sta $1c				sta 	zLTemp1+2
.019671	85 1d		sta $1d				sta 	zLTemp1+3
.019673	8d 90 04	sta $0490			sta 	SignCount 					; Count of signs.
.019676	20 d7 96	jsr $0196d7			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.019679	da		phx				phx
.01967a	e8		inx				inx
.01967b	e8		inx				inx
.01967c	e8		inx				inx
.01967d	e8		inx				inx
.01967e	e8		inx				inx
.01967f	e8		inx				inx
.019680	20 d7 96	jsr $0196d7			jsr 	CheckIntegerNegate
.019683	fa		plx				plx
.019684	5a		phy				phy 								; Y is the counter
.019685	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.019687					_BFDLoop:
.019687	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.01968a	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.01968d	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.019690	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.019693	26 1a		rol $1a				rol 	zLTemp1
.019695	26 1b		rol $1b				rol 	zLTemp1+1
.019697	26 1c		rol $1c				rol 	zLTemp1+2
.019699	26 1d		rol $1d				rol 	zLTemp1+3
.01969b	38		sec				sec
.01969c	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.01969e	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.0196a1	48		pha				pha
.0196a2	a5 1b		lda $1b				lda 	zLTemp1+1
.0196a4	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.0196a7	48		pha				pha
.0196a8	a5 1c		lda $1c				lda 	zLTemp1+2
.0196aa	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.0196ad	48		pha				pha
.0196ae	a5 1d		lda $1d				lda 	zLTemp1+3
.0196b0	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.0196b3	90 15		bcc $0196ca			bcc 	_BFDNoAdd
.0196b5	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.0196b7	68		pla				pla
.0196b8	85 1c		sta $1c				sta 	zLTemp1+2
.0196ba	68		pla				pla
.0196bb	85 1b		sta $1b				sta 	zLTemp1+1
.0196bd	68		pla				pla
.0196be	85 1a		sta $1a				sta 	zLTemp1+0
.0196c0	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.0196c3	09 01		ora #$01			ora 	#1
.0196c5	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0196c8	80 03		bra $0196cd			bra 	_BFDNext
.0196ca					_BFDNoAdd:
.0196ca	68		pla				pla 								; Throw away the intermediate calculations
.0196cb	68		pla				pla
.0196cc	68		pla				pla
.0196cd					_BFDNext:
.0196cd	88		dey				dey
.0196ce	d0 b7		bne $019687			bne 	_BFDLoop
.0196d0	7a		ply				ply 								; restore Y and exit
.0196d1	4e 90 04	lsr $0490			lsr 	SignCount 					; if sign count odd,
.0196d4	b0 07		bcs $0196dd			bcs		IntegerNegateAlways 			; negate the result
.0196d6	60		rts				rts
.0196d7					CheckIntegerNegate:
.0196d7	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.0196da	30 01		bmi $0196dd			bmi 	IntegerNegateAlways
.0196dc	60		rts				rts
.0196dd					IntegerNegateAlways:
.0196dd	ee 90 04	inc $0490			inc 	SignCount
.0196e0	38		sec				sec
.0196e1	a9 00		lda #$00			lda 	#0
.0196e3	fd 08 03	sbc $0308,x			sbc 	XS_Mantissa+0,x
.0196e6	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0196e9	a9 00		lda #$00			lda 	#0
.0196eb	fd 09 03	sbc $0309,x			sbc 	XS_Mantissa+1,x
.0196ee	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0196f1	a9 00		lda #$00			lda 	#0
.0196f3	fd 0a 03	sbc $030a,x			sbc 	XS_Mantissa+2,x
.0196f6	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0196f9	a9 00		lda #$00			lda 	#0
.0196fb	fd 0b 03	sbc $030b,x			sbc 	XS_Mantissa+3,x
.0196fe	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019701	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.019702					INTToString:
.019702	48		pha				pha
.019703	5a		phy				phy
.019704	bd 0b 03	lda $030b,x			lda 		XS_Mantissa+3,x 		; check -ve
.019707	10 08		bpl $019711			bpl 		_ITSNotMinus
.019709	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.01970b	20 a6 97	jsr $0197a6			jsr 		ITSOutputCharacter
.01970e	20 dd 96	jsr $0196dd			jsr 		IntegerNegateAlways 	; negate the number.
.019711					_ITSNotMinus:
.019711	a9 00		lda #$00			lda 		#0
.019713	8d 8c 04	sta $048c			sta 		NumSuppress 			; clear the suppression flag.
.019716	8a		txa				txa 								; use Y for the mantissa index.
.019717	a8		tay				tay
.019718	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.01971a					_ITSNextSubtractor:
.01971a	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.01971c	8d 8d 04	sta $048d			sta 		NumConvCount
.01971f					_ITSSubtract:
.01971f	38		sec				sec
.019720	b9 08 03	lda $0308,y			lda 		XS_Mantissa,y 			; subtract number and push on stack
.019723	ff 82 97 01	sbc $019782,x			sbc 		_ITSSubtractors+0,x
.019727	48		pha				pha
.019728	b9 09 03	lda $0309,y			lda 		XS_Mantissa+1,y
.01972b	ff 83 97 01	sbc $019783,x			sbc 		_ITSSubtractors+1,x
.01972f	48		pha				pha
.019730	b9 0a 03	lda $030a,y			lda 		XS_Mantissa+2,y
.019733	ff 84 97 01	sbc $019784,x			sbc 		_ITSSubtractors+2,x
.019737	48		pha				pha
.019738	b9 0b 03	lda $030b,y			lda 		XS_Mantissa+3,y
.01973b	ff 85 97 01	sbc $019785,x			sbc 		_ITSSubtractors+3,x
.01973f	90 14		bcc $019755			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.019741	99 0b 03	sta $030b,y			sta 		XS_Mantissa+3,y 		; save subtract off stack
.019744	68		pla				pla
.019745	99 0a 03	sta $030a,y			sta 		XS_Mantissa+2,y
.019748	68		pla				pla
.019749	99 09 03	sta $0309,y			sta 		XS_Mantissa+1,y
.01974c	68		pla				pla
.01974d	99 08 03	sta $0308,y			sta 		XS_Mantissa+0,y
.019750	ee 8d 04	inc $048d			inc 		NumConvCount 			; bump count.
.019753	80 ca		bra $01971f			bra 		_ITSSubtract 			; go round again.
.019755					_ITSCantSubtract:
.019755	68		pla				pla 								; throw away interim answers
.019756	68		pla				pla
.019757	68		pla				pla
.019758	ad 8d 04	lda $048d			lda 		NumConvCount 			; if not zero then no suppression check
.01975b	c9 30		cmp #$30			cmp 		#"0"
.01975d	d0 05		bne $019764			bne 		_ITSOutputDigit
.01975f	ad 8c 04	lda $048c			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.019762	10 09		bpl $01976d			bpl	 		_ITSGoNextSubtractor
.019764					_ITSOutputDigit:
.019764	ce 8c 04	dec $048c			dec 		NumSuppress 			; suppression check will be non-zero.
.019767	ad 8d 04	lda $048d			lda 		NumConvCount 			; count of subtractions
.01976a	20 a6 97	jsr $0197a6			jsr 		ITSOutputCharacter 		; output it.
.01976d					_ITSGoNextSubtractor:
.01976d	e8		inx				inx 								; next dword
.01976e	e8		inx				inx
.01976f	e8		inx				inx
.019770	e8		inx				inx
.019771	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.019773	d0 a5		bne $01971a			bne 		_ITSNextSubtractor 		; do all the subtractors.
.019775	98		tya				tya 								; X is back as the mantissa index
.019776	aa		tax				tax
.019777	bd 08 03	lda $0308,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.01977a	09 30		ora #$30			ora 		#"0"
.01977c	20 a6 97	jsr $0197a6			jsr 		ITSOutputCharacter
.01977f	7a		ply				ply 								; and exit
.019780	68		pla				pla
.019781	60		rts				rts
.019782					_ITSSubtractors:
>019782	00 ca 9a 3b					.dword 		1000000000
>019786	00 e1 f5 05					.dword 		100000000
>01978a	80 96 98 00					.dword 		10000000
>01978e	40 42 0f 00					.dword 		1000000
>019792	a0 86 01 00					.dword 		100000
>019796	10 27 00 00					.dword 		10000
>01979a	e8 03 00 00					.dword 		1000
>01979e	64 00 00 00					.dword 		100
>0197a2	0a 00 00 00					.dword 		10
.0197a6					_ITSSubtractorsEnd:
.0197a6					ITSOutputCharacter:
.0197a6	48		pha				pha
.0197a7	da		phx				phx
.0197a8	ae 06 04	ldx $0406			ldx 	NumBufX 					; save digit
.0197ab	9d 07 04	sta $0407,x			sta 	Num_Buffer,x
.0197ae	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.0197b0	9d 08 04	sta $0408,x			sta 	Num_Buffer+1,x
.0197b3	ee 06 04	inc $0406			inc 	NumBufX						; bump pointer.
.0197b6	fa		plx				plx
.0197b7	68		pla				pla
.0197b8	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.0197b9					IntFromString:
.0197b9	a0 00		ldy #$00			ldy 	#0
.0197bb	8c 8e 04	sty $048e			sty 	ExpTemp 					; this is the converted digit count.
.0197be					IntFromStringY:
.0197be	48		pha				pha
.0197bf	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.0197c1	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.0197c4	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0197c7	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0197ca	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0197cd	a9 01		lda #$01			lda 	#1
.0197cf	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0197d2					_IFSLoop:
.0197d2	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.0197d4	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.0197d6	90 60		bcc $019838			bcc 	_IFSExit
.0197d8	c9 3a		cmp #$3a			cmp 	#"9"+1
.0197da	b0 5c		bcs $019838			bcs 	_IFSExit
.0197dc	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.0197df	c9 0c		cmp #$0c			cmp 	#12
.0197e1	b0 5f		bcs $019842			bcs 	_IFSOverflow
.0197e3	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.0197e6	48		pha				pha
.0197e7	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.0197ea	48		pha				pha
.0197eb	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0197ee	48		pha				pha
.0197ef	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.0197f2	48		pha				pha
.0197f3	20 57 98	jsr $019857			jsr 	IFSX1ShiftLeft 				; double
.0197f6	20 57 98	jsr $019857			jsr 	IFSX1ShiftLeft 				; x 4
.0197f9	18		clc				clc 								; add saved value x 5
.0197fa	68		pla				pla
.0197fb	7d 08 03	adc $0308,x			adc 	XS_Mantissa+0,x
.0197fe	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019801	68		pla				pla
.019802	7d 09 03	adc $0309,x			adc 	XS_Mantissa+1,x
.019805	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019808	68		pla				pla
.019809	7d 0a 03	adc $030a,x			adc 	XS_Mantissa+2,x
.01980c	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01980f	68		pla				pla
.019810	7d 0b 03	adc $030b,x			adc 	XS_Mantissa+3,x
.019813	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019816	20 57 98	jsr $019857			jsr 	IFSX1ShiftLeft 				; x 10
.019819	ee 8e 04	inc $048e			inc 	ExpTemp 					; bump count of digits processed.
.01981c	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.01981e	29 0f		and #$0f			and 	#15
.019820	c8		iny				iny
.019821	7d 08 03	adc $0308,x			adc 	XS_Mantissa+0,x
.019824	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019827	90 a9		bcc $0197d2			bcc 	_IFSLoop
.019829	fe 09 03	inc $0309,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.01982c	d0 a4		bne $0197d2			bne 	_IFSLoop
.01982e	fe 0a 03	inc $030a,x			inc 	XS_Mantissa+2,x
.019831	d0 9f		bne $0197d2			bne 	_IFSLoop
.019833	fe 0b 03	inc $030b,x			inc 	XS_Mantissa+3,x
.019836	80 9a		bra $0197d2			bra 	_IFSLoop
.019838					_IFSExit:
.019838	98		tya				tya 								; get offset
.019839					_IFSOkay:
.019839	38		sec				sec
.01983a	ad 8e 04	lda $048e			lda 	ExpTemp
.01983d	f0 01		beq $019840			beq 	_IFSSkipFail
.01983f	18		clc				clc
.019840					_IFSSkipFail:
.019840	68		pla				pla 								; and exit.
.019841	60		rts				rts
.019842					_IFSOverflow:
.019842	20 2f 84	jsr $01842f			jsr 	ERR_Handler
>019845	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>01984d	20 6f 76 65 72 66 6c 6f 77 00
.019857					IFSX1ShiftLeft:
.019857	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x
.01985a	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.01985d	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.019860	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.019863	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.019864					FPSubtract:
.019864	48		pha				pha
.019865	bd 13 03	lda $0313,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.019868	49 80		eor #$80			eor 	#$80
.01986a	9d 13 03	sta $0313,x			sta 	XS2_Type,x
.01986d	68		pla				pla 								; --- and fall through ---
.01986e					FPAdd:
.01986e	48		pha				pha
.01986f	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.019872	d0 05		bne $019879			bne 	_FPA_NegativeLHS
.019874	20 96 98	jsr $019896			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.019877	68		pla				pla
.019878	60		rts				rts
.019879					_FPA_NegativeLHS:
.019879	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.01987c	49 80		eor #$80			eor 	#$80
.01987e	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019881	bd 13 03	lda $0313,x			lda 	XS2_Type,x 					; flip the sign of B and add
.019884	49 80		eor #$80			eor 	#$80
.019886	9d 13 03	sta $0313,x			sta 	XS2_Type,x
.019889	20 96 98	jsr $019896			jsr 	FPAdd_Worker 				; do the add calculation.
.01988c	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip sign of X1 back
.01988f	49 80		eor #$80			eor 	#$80
.019891	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019894	68		pla				pla
.019895	60		rts				rts
.019896					FPAdd_Worker:
.019896	3c 13 03	bit $0313,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.019899	70 08		bvs $0198a3			bvs 	_FPAWExit 					; no change.
.01989b	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.01989e	50 07		bvc $0198a7			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.0198a0	20 3b 9b	jsr $019b3b			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.0198a3					_FPAWExit:
.0198a3	20 c3 9b	jsr $019bc3			jsr 	FPUNormalise 				; normalise the result.
.0198a6	60		rts				rts
.0198a7					_FPAWMakeSame:
.0198a7	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.0198aa	38		sec				sec
.0198ab	fd 12 03	sbc $0312,x			sbc	 	XS2_Exponent,x 				; using subtraction
.0198ae	f0 1b		beq $0198cb			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.0198b0	da		phx				phx 								; save X
.0198b1	90 06		bcc $0198b9			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.0198b3	e8		inx				inx
.0198b4	e8		inx				inx
.0198b5	e8		inx				inx
.0198b6	e8		inx				inx
.0198b7	e8		inx				inx
.0198b8	e8		inx				inx
.0198b9					_FPAWShiftA:
.0198b9	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x 				; so shift exponent up.
.0198bc	5e 0b 03	lsr $030b,x			lsr 	3+XS_Mantissa,x
.0198bf	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.0198c2	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.0198c5	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.0198c8	fa		plx				plx 								; restore original X
.0198c9	80 dc		bra $0198a7			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.0198cb					_FPAW_DoArithmetic:
.0198cb	3c 13 03	bit $0313,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.0198ce	30 39		bmi $019909			bmi 	_FPAW_BNegative
.0198d0	18		clc				clc
.0198d1	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.0198d4	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.0198d7	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0198da	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0198dd	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.0198e0	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0198e3	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.0198e6	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.0198e9	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0198ec	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.0198ef	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.0198f2	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0198f5	90 ac		bcc $0198a3			bcc 	_FPAWExit 					; no carry.
.0198f7	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x 				; so shift exponent up.
.0198fa	38		sec				sec
.0198fb	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.0198fe	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.019901	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.019904	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.019907	80 9a		bra $0198a3			bra 	_FPAWExit
.019909					_FPAW_BNegative:
.019909	38		sec				sec
.01990a	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.01990d	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.019910	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019913	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.019916	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.019919	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.01991c	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.01991f	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.019922	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019925	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.019928	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.01992b	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.01992e	b0 0b		bcs $01993b			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.019930	20 68 9b	jsr $019b68			jsr 	FPUNegateInteger			; negate the mantissa
.019933	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip result sign
.019936	49 80		eor #$80			eor 	#$80
.019938	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.01993b					_FPAWGoExit:
.01993b	4c a3 98	jmp $0198a3			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.01993e					FPD_IsDivZero:
.01993e	20 2f 84	jsr $01842f			jsr ERR_Handler
>019941	44 69 76 69 73 69 6f 6e			.text "Division by zero",0
>019949	20 62 79 20 7a 65 72 6f 00
.019952					FPDivide:
.019952	48		pha				pha
.019953	5a		phy				phy
.019954	3c 13 03	bit $0313,x			bit 	XS2_Type,x 					; check if division by zero
.019957	70 e5		bvs $01993e			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.019959	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.01995c	f0 03		beq $019961			beq 	_FPDCalculateExp
.01995e					_FPD_Exit:
.01995e	7a		ply				ply
.01995f	68		pla				pla
.019960	60		rts				rts
.019961					_FPDCalculateExp:
.019961	bd 12 03	lda $0312,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.019964	49 ff		eor #$ff			eor 	#$FF
.019966	1a		inc a				inc 	a
.019967	9d 12 03	sta $0312,x			sta 	XS2_Exponent,x
.01996a	20 5e 9a	jsr $019a5e			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.01996d	18		clc				clc 	 							; add 1 to the resulting exponent
.01996e	69 01		adc #$01			adc 	#1
.019970	b0 65		bcs $0199d7			bcs 	_FPD_Overflow 				; which can overflow.
.019972	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.019975	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.019977	85 1a		sta $1a				sta 	zLTemp1+0
.019979	85 1b		sta $1b				sta 	zLTemp1+1
.01997b	85 1c		sta $1c				sta 	zLTemp1+2
.01997d	85 1d		sta $1d				sta 	zLTemp1+3
.01997f	a0 20		ldy #$20			ldy 	#32 						; times round.
.019981					_FPD_Loop:
.019981	38		sec				sec 								; calculate X1-X2 stacking result because we might
.019982	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; not save it.
.019985	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa,x
.019988	48		pha				pha
.019989	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.01998c	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.01998f	48		pha				pha
.019990	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.019993	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.019996	48		pha				pha
.019997	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.01999a	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.01999d	90 17		bcc $0199b6			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.01999f	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x 			; save results out to A
.0199a2	68		pla				pla
.0199a3	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0199a6	68		pla				pla
.0199a7	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0199aa	68		pla				pla
.0199ab	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0199ae	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.0199b0	09 80		ora #$80			ora 	#$80
.0199b2	85 1d		sta $1d				sta 	zLTemp1+3
.0199b4	80 03		bra $0199b9			bra 	_FPD_Rotates
.0199b6					_FPD_NoSubtract:
.0199b6	68		pla				pla 								; throw away unwanted results
.0199b7	68		pla				pla
.0199b8	68		pla				pla
.0199b9					_FPD_Rotates:
.0199b9	5e 11 03	lsr $0311,x			lsr 	3+XS2_Mantissa,x
.0199bc	7e 10 03	ror $0310,x			ror 	2+XS2_Mantissa,x
.0199bf	7e 0f 03	ror $030f,x			ror 	1+XS2_Mantissa,x
.0199c2	7e 0e 03	ror $030e,x			ror 	0+XS2_Mantissa,x
.0199c5	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.0199c7	26 1b		rol $1b				rol 	zLTemp1+1
.0199c9	26 1c		rol $1c				rol 	zLTemp1+2
.0199cb	26 1d		rol $1d				rol 	zLTemp1+3
.0199cd	90 02		bcc $0199d1			bcc 	_FPD_NoCarry
.0199cf	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.0199d1					_FPD_NoCarry:
.0199d1	88		dey				dey 								; do 32 times
.0199d2	d0 ad		bne $019981			bne 	_FPD_Loop
.0199d4	4c 3b 9a	jmp $019a3b			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.0199d7					_FPD_Overflow:
.0199d7	4c 38 9c	jmp $019c38			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.0199da					FPMultiply:
.0199da	48		pha				pha
.0199db	5a		phy				phy
.0199dc	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.0199df	70 08		bvs $0199e9			bvs 	_FPM_Exit
.0199e1	3c 13 03	bit $0313,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.0199e4	50 06		bvc $0199ec			bvc 	_FPM_CalcExponent
.0199e6	20 3b 9b	jsr $019b3b			jsr 	FPUCopyX2ToX1
.0199e9					_FPM_Exit:
.0199e9	7a		ply				ply
.0199ea	68		pla				pla
.0199eb	60		rts				rts
.0199ec					_FPM_CalcExponent:
.0199ec	18		clc				clc
.0199ed	20 5e 9a	jsr $019a5e			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.0199f0	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x 				; save the result.
.0199f3	a9 00		lda #$00			lda 	#0
.0199f5	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.0199f7	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.0199f9	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.0199fb	85 1d		sta $1d				sta 	zLTemp1+3
.0199fd	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.0199ff					_FPM_Loop:
.0199ff	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x				; check LSB of long product
.019a02	29 01		and #$01			and 	#1
.019a04	18		clc				clc 								; clear carry for the long rotate.
.019a05	f0 1d		beq $019a24			beq 	_FPM_NoAddition
.019a07	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.019a08	a5 1a		lda $1a				lda 	zLTemp1+0
.019a0a	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.019a0d	85 1a		sta $1a				sta 	zLTemp1+0
.019a0f	a5 1b		lda $1b				lda 	zLTemp1+1
.019a11	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.019a14	85 1b		sta $1b				sta 	zLTemp1+1
.019a16	a5 1c		lda $1c				lda 	zLTemp1+2
.019a18	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.019a1b	85 1c		sta $1c				sta 	zLTemp1+2
.019a1d	a5 1d		lda $1d				lda 	zLTemp1+3
.019a1f	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.019a22	85 1d		sta $1d				sta 	zLTemp1+3
.019a24					_FPM_NoAddition:
.019a24	66 1d		ror $1d				ror 	3+zLTemp1
.019a26	66 1c		ror $1c				ror 	2+zLTemp1
.019a28	66 1b		ror $1b				ror 	1+zLTemp1
.019a2a	66 1a		ror $1a				ror 	0+zLTemp1
.019a2c	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.019a2f	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.019a32	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.019a35	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.019a38	88		dey				dey
.019a39	d0 c4		bne $0199ff			bne 	_FPM_Loop 					; do this 32 times.
.019a3b					FPM_CopySignNormalize:
.019a3b	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.019a3d	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.019a40	a5 1b		lda $1b				lda 	zLTemp1+1
.019a42	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019a45	a5 1c		lda $1c				lda 	zLTemp1+2
.019a47	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019a4a	a5 1d		lda $1d				lda 	zLTemp1+3
.019a4c	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019a4f	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; sign is xor of signs
.019a52	5d 13 03	eor $0313,x			eor 	XS2_Type,x
.019a55	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019a58	20 c3 9b	jsr $019bc3			jsr 	FPUNormalise 				; normalise and exit.
.019a5b	7a		ply				ply
.019a5c	68		pla				pla
.019a5d	60		rts				rts
.019a5e					FPCalculateExponent:
.019a5e	18		clc				clc
.019a5f	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.019a62	7d 12 03	adc $0312,x			adc 	XS2_Exponent,x
.019a65	b0 08		bcs $019a6f			bcs 	_FPCECarry 					; carry out ?
.019a67	10 03		bpl $019a6c			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.019a69	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.019a6b	60		rts				rts
.019a6c					_FPCEExpZero:
.019a6c	a9 00		lda #$00			lda 	#0
.019a6e	60		rts				rts
.019a6f					_FPCECarry:
.019a6f	30 03		bmi $019a74			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.019a71	09 80		ora #$80			ora 	#$80 						; put in right range
.019a73	60		rts				rts
.019a74					_FPCEOverflow:
.019a74	4c 38 9c	jmp $019c38			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.019a77					FPFractionalPart:
.019a77	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.019a7a	38		sec				sec 								; this flag tells us to keep the fractional part
.019a7b	30 0f		bmi $019a8c			bmi 	FPGetPart
.019a7d	60		rts				rts
.019a7e					FPIntegerPart:
.019a7e	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.019a81	18		clc				clc 								; this flag says keep the integer part.
.019a82	30 08		bmi $019a8c			bmi 	FPGetPart 					; -ve exponents are 0..127
.019a84	48		pha				pha
.019a85	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.019a87	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019a8a	68		pla				pla
.019a8b	60		rts				rts
.019a8c					FPGetPart:
.019a8c	48		pha				pha
.019a8d	5a		phy				phy 								; save Y
.019a8e	08		php				php 								; save action
.019a8f	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.019a92	70 62		bvs $019af6			bvs 	_FPGP_Exit 					; then do nothing.
.019a94	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.019a96	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.019a98	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.019a9a	85 1c		sta $1c				sta 	zLTemp1+2
.019a9c	85 1d		sta $1d				sta 	zLTemp1+3
.019a9e	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x				; the number of shifts.
.019aa1	38		sec				sec
.019aa2	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.019aa4	f0 12		beq $019ab8			beq 	_FPGP_NoShift 				; ... if any
.019aa6	c9 20		cmp #$20			cmp 	#32
.019aa8	90 02		bcc $019aac			bcc 	_FPGP_NotMax
.019aaa	a9 20		lda #$20			lda 	#32 						; max of 32.
.019aac					_FPGP_NotMax:
.019aac	a8		tay				tay 								; Y is the mask shift count.
.019aad					_FPGP_ShiftMask:
.019aad	46 1d		lsr $1d				lsr 	3+zLTemp1
.019aaf	66 1c		ror $1c				ror 	2+zLTemp1
.019ab1	66 1b		ror $1b				ror 	1+zLTemp1
.019ab3	66 1a		ror $1a				ror 	0+zLTemp1
.019ab5	88		dey				dey
.019ab6	d0 f5		bne $019aad			bne 	_FPGP_ShiftMask
.019ab8					_FPGP_NoShift:
.019ab8	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.019aba	8e 8e 04	stx $048e			stx 	ExpTemp						; save X
.019abd					_FPGP_MaskLoop:
.019abd	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.019ac0	28		plp				plp 								; if CC we keep the top part, so we
.019ac1	08		php				php		 							; flip the mask.
.019ac2	b0 02		bcs $019ac6			bcs		_FPGP_NoFlip
.019ac4	49 ff		eor #$ff			eor 	#$FF
.019ac6					_FPGP_NoFlip:
.019ac6	3d 08 03	and $0308,x			and 	XS_Mantissa,x 				; and into the mantissa.
.019ac9	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.019acc	e8		inx				inx
.019acd	c8		iny				iny
.019ace	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.019ad0	d0 eb		bne $019abd			bne 	_FPGP_MaskLoop
.019ad2	ae 8e 04	ldx $048e			ldx 	ExpTemp						; restore X
.019ad5	28		plp				plp
.019ad6	08		php				php 								; get action flag on the stack
.019ad7	90 05		bcc $019ade			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.019ad9	a9 00		lda #$00			lda 	#0
.019adb	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019ade					_FPGP_NotFractional:
.019ade	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 						; check if \1 zero
.019ae1	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.019ae4	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.019ae7	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.019aea	f0 05		beq $019af1			beq 	_FPGP_Zero 					; if zero, return zero
.019aec	20 c3 9b	jsr $019bc3			jsr 	FPUNormalise
.019aef	80 05		bra $019af6			bra 	_FPGP_Exit 					; and exit
.019af1					_FPGP_Zero:
.019af1	a9 40		lda #$40			lda 	#$40 						; set zero flag
.019af3	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019af6					_FPGP_Exit:
.019af6	68		pla				pla 								; throw saved action flag.
.019af7	7a		ply				ply
.019af8	68		pla				pla
.019af9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.019afa					FPCompare:
.019afa	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.019afd	48		pha				pha
.019afe	bd 12 03	lda $0312,x			lda 	XS2_Exponent,x
.019b01	48		pha				pha
.019b02	20 64 98	jsr $019864			jsr 	FPSubtract 					; calculate X1-X2
.019b05	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.019b08	70 2c		bvs $019b36			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.019b0a	68		pla				pla
.019b0b	8d 8e 04	sta $048e			sta 	ExpTemp						; save first exponent in temporary reg.
.019b0e	68		pla				pla
.019b0f	38		sec				sec
.019b10	ed 8e 04	sbc $048e			sbc 	ExpTemp 					; calculate AX-BX
.019b13	70 15		bvs $019b2a			bvs 	_FPCNotEqual				; overflow, can't be equal.
.019b15	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.019b16	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.019b18	b0 10		bcs $019b2a			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.019b1a	38		sec				sec
.019b1b	ad 8e 04	lda $048e			lda 	ExpTemp 					; get one of the exponents back.
.019b1e	e9 12		sbc #$12			sbc 	#18 						; allow for 2^18 error, relatively.
.019b20	b0 02		bcs $019b24			bcs 	_FPCNotRange 				; keep in range.
.019b22	a9 01		lda #$01			lda 	#1
.019b24					_FPCNotRange:
.019b24	38		sec				sec
.019b25	fd 0c 03	sbc $030c,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.019b28	b0 0e		bcs $019b38			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.019b2a					_FPCNotEqual:
.019b2a	bd 0d 03	lda $030d,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.019b2d	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.019b2f	f0 02		beq $019b33			beq 	_FPCNE2
.019b31	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.019b33	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.019b34	80 04		bra $019b3a			bra 	_FPCExit
.019b36					_FPCPullZero:
.019b36	68		pla				pla 								; throw saved exponents
.019b37	68		pla				pla
.019b38					_FPCZero:
.019b38	a9 00		lda #$00			lda 	#0 							; and return zero
.019b3a					_FPCExit:
.019b3a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.019b3b					FPUCopyX2ToX1:
.019b3b	48		pha				pha
.019b3c	da		phx				phx
.019b3d	5a		phy				phy
.019b3e	a0 08		ldy #$08			ldy 	#8
.019b40	bd 0e 03	lda $030e,x	_FPUC21:lda 	XS2_Mantissa,x
.019b43	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.019b46	e8		inx				inx
.019b47	88		dey				dey
.019b48	10 f6		bpl $019b40			bpl 	_FPUC21
.019b4a	7a		ply				ply
.019b4b	fa		plx				plx
.019b4c	68		pla				pla
.019b4d	60		rts				rts
.019b4e					FPUSetInteger:
.019b4e	48		pha				pha
.019b4f	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.019b52	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.019b54	10 02		bpl $019b58			bpl 	_FPUSIExtend
.019b56	a9 ff		lda #$ff			lda 	#$FF
.019b58					_FPUSIExtend:
.019b58	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.019b5b	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019b5e	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019b61	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.019b63	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019b66	68		pla				pla
.019b67	60		rts				rts
.019b68					FPUNegateInteger:
.019b68	48		pha				pha
.019b69	38		sec				sec
.019b6a	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.019b6c	fd 08 03	sbc $0308,x			sbc 	XS_Mantissa+0,x
.019b6f	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019b72	a9 00		lda #$00			lda 	#0
.019b74	fd 09 03	sbc $0309,x			sbc 	XS_Mantissa+1,x
.019b77	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019b7a	a9 00		lda #$00			lda 	#0
.019b7c	fd 0a 03	sbc $030a,x			sbc 	XS_Mantissa+2,x
.019b7f	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019b82	a9 00		lda #$00			lda 	#0
.019b84	fd 0b 03	sbc $030b,x			sbc 	XS_Mantissa+3,x
.019b87	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019b8a	68		pla				pla
.019b8b	60		rts				rts
.019b8c					FPUToFloat:
.019b8c	48		pha				pha
.019b8d	bd 0d 03	lda $030d,x			lda 	XS_Type,x					; exit if already float.
.019b90	29 0f		and #$0f			and 	#$0F
.019b92	f0 2d		beq $019bc1			beq 	_FPUFExit
.019b94	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.019b96	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019b99	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.019b9b	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x 				; x mantissa.
.019b9e	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.019ba1	10 08		bpl $019bab			bpl		_FPUFPositive
.019ba3	20 68 9b	jsr $019b68			jsr 	FPUNegateInteger 			; negate the mantissa
.019ba6	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.019ba8	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019bab					_FPUFPositive:
.019bab	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.019bae	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.019bb1	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.019bb4	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.019bb7	d0 05		bne $019bbe			bne 	_FPUFNonZero
.019bb9	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.019bbb	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019bbe					_FPUFNonZero:
.019bbe	20 c3 9b	jsr $019bc3			jsr 	FPUNormalise 				; normalise the floating point.
.019bc1					_FPUFExit:
.019bc1	68		pla				pla
.019bc2	60		rts				rts
.019bc3					FPUNormalise:
.019bc3	48		pha				pha
.019bc4	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.019bc7	70 20		bvs $019be9			bvs 	_FPUNExit
.019bc9	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.019bcc	f0 16		beq $019be4			beq 	_FPUNSetZero
.019bce					_FPUNLoop:
.019bce	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.019bd1	30 16		bmi $019be9			bmi 	_FPUNExit 					; if so, we are normalised.
.019bd3	1e 08 03	asl $0308,x			asl 	0+XS_Mantissa+0,x
.019bd6	3e 09 03	rol $0309,x			rol 	1+XS_Mantissa+0,x
.019bd9	3e 0a 03	rol $030a,x			rol 	2+XS_Mantissa+0,x
.019bdc	3e 0b 03	rol $030b,x			rol 	3+XS_Mantissa+0,x
.019bdf	de 0c 03	dec $030c,x			dec 	XS_Exponent,x 				; decrement exponent
.019be2	d0 ea		bne $019bce			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.019be4					_FPUNSetZero:
.019be4	a9 40		lda #$40			lda 	#$40
.019be6	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; the result is now zero.
.019be9					_FPUNExit:
.019be9	68		pla				pla
.019bea	60		rts				rts
.019beb					FPUToInteger:
.019beb	48		pha				pha
.019bec	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; if already integer, exit
.019bef	29 01		and #$01			and 	#1
.019bf1	d0 3e		bne $019c31			bne 	_FPUTOI_Exit
.019bf3	3c 0d 03	bit $030d,x			bit 	XS_Type,x					; if zero, return zero.
.019bf6	70 2b		bvs $019c23			bvs 	_FPUTOI_Zero
.019bf8	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.019bfb	10 26		bpl $019c23			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.019bfd	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.019bff	b0 37		bcs $019c38			bcs 	FP_Overflow
.019c01					_FPUToIToInteger:
.019c01	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.019c04	c9 a0		cmp #$a0			cmp 	#128+32
.019c06	f0 11		beq $019c19			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.019c08	fe 0c 03	inc $030c,x			inc 	XS_Exponent,X 				; increment Exponent
.019c0b	5e 0b 03	lsr $030b,x			lsr 	3+XS_Mantissa,x
.019c0e	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.019c11	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.019c14	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.019c17	80 e8		bra $019c01			bra 	_FPUToIToInteger 			; keep going.
.019c19					_FPUToICheckSign:
.019c19	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; check sign
.019c1c	10 13		bpl $019c31			bpl 	_FPUToI_Exit 				; exit if unsigned.
.019c1e	20 68 9b	jsr $019b68			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.019c21	80 0e		bra $019c31			bra 	_FPUTOI_Exit
.019c23					_FPUTOI_Zero:
.019c23	a9 00		lda #$00			lda 	#0 							; return zero integer.
.019c25	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019c28	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019c2b	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019c2e	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019c31					_FPUToI_Exit:
.019c31	a9 01		lda #$01			lda 	#1 							; set type to integer
.019c33	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019c36	68		pla				pla
.019c37	60		rts				rts
.019c38					FP_Overflow:
.019c38	20 2f 84	jsr $01842f			jsr ERR_Handler
>019c3b	46 6c 6f 61 74 69 6e 67			.text "Floating Point overflow",0
>019c43	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.019c53					FPUTimes10:
.019c53	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.019c56	85 1a		sta $1a				sta 	ZLTemp1+0
.019c58	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.019c5b	85 1b		sta $1b				sta 	ZLTemp1+1
.019c5d	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.019c60	85 1c		sta $1c				sta 	ZLTemp1+2
.019c62	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.019c65	85 1d		sta $1d				sta 	ZLTemp1+3
.019c67	20 ab 9c	jsr $019cab			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.019c6a	20 ab 9c	jsr $019cab			jsr 	_FPUT_LSR_ZLTemp1
.019c6d	18		clc				clc
.019c6e	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.019c71	65 1a		adc $1a				adc 	ZLTemp1+0
.019c73	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019c76	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.019c79	65 1b		adc $1b				adc 	ZLTemp1+1
.019c7b	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019c7e	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.019c81	65 1c		adc $1c				adc 	ZLTemp1+2
.019c83	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019c86	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.019c89	65 1d		adc $1d				adc 	ZLTemp1+3
.019c8b	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019c8e	90 0f		bcc $019c9f			bcc 	_FPUTimes10
.019c90	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.019c93	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.019c96	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.019c99	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.019c9c	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x				; fix exponent
.019c9f					_FPUTimes10:
.019c9f	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.019ca2	18		clc				clc
.019ca3	69 03		adc #$03			adc 	#3
.019ca5	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.019ca8	b0 8e		bcs $019c38			bcs 	FP_Overflow 				; error
.019caa	60		rts				rts
.019cab					_FPUT_LSR_ZLTemp1:
.019cab	46 1d		lsr $1d				lsr 	ZLTemp1+3
.019cad	66 1c		ror $1c				ror 	ZLTemp1+2
.019caf	66 1b		ror $1b				ror 	ZLTemp1+1
.019cb1	66 1a		ror $1a				ror 	ZLTemp1+0
.019cb3	60		rts				rts
.019cb4					FPUScale10A:
.019cb4	5a		phy				phy
.019cb5	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.019cb7	f0 3d		beq $019cf6			beq 	_FPUScaleExit
.019cb9	da		phx				phx 								; save X
.019cba	e8		inx				inx
.019cbb	e8		inx				inx
.019cbc	e8		inx				inx
.019cbd	e8		inx				inx
.019cbe	e8		inx				inx
.019cbf	e8		inx				inx
.019cc0	a8		tay				tay 								; save power scalar in Y.
.019cc1	a9 00		lda #$00			lda 	#0
.019cc3	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.019cc6	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019cc9	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019ccc	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019ccf	a9 80		lda #$80			lda 	#$80
.019cd1	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019cd4	a9 81		lda #$81			lda 	#$81
.019cd6	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.019cd9	5a		phy				phy 								; save 10^n on stack.
.019cda	c0 00		cpy #$00			cpy 	#0
.019cdc	10 05		bpl $019ce3			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.019cde	98		tya				tya
.019cdf	49 ff		eor #$ff			eor 	#$FF
.019ce1	1a		inc a				inc 	a
.019ce2	a8		tay				tay
.019ce3					_FPUSAbs:
.019ce3	20 53 9c	jsr $019c53			jsr 	FPUTimes10
.019ce6	88		dey				dey
.019ce7	d0 fa		bne $019ce3			bne 	_FPUSAbs 					; tos is now 10^|AC|
.019ce9	68		pla				pla 								; restore count in A
.019cea	fa		plx				plx 								; restore X pointing to number to scale.
.019ceb	0a		asl a				asl 	a
.019cec	b0 05		bcs $019cf3			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.019cee	20 da 99	jsr $0199da			jsr 	FPMultiply 					; if clear multiply.
.019cf1	80 03		bra $019cf6			bra		_FPUScaleExit
.019cf3					_FPUSDivide:
.019cf3	20 52 99	jsr $019952			jsr 	FPDivide
.019cf6					_FPUScaleExit:
.019cf6	7a		ply				ply
.019cf7	60		rts				rts
.019cf8					FPUCopyToNext:
.019cf8	a0 06		ldy #$06			ldy 		#6
.019cfa	da		phx				phx
.019cfb					_FPUCopy1:
.019cfb	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x
.019cfe	9d 0e 03	sta $030e,x			sta 	XS2_Mantissa,x
.019d01	e8		inx				inx
.019d02	88		dey				dey
.019d03	d0 f6		bne $019cfb			bne 	_FPUCopy1
.019d05	fa		plx				plx
.019d06	60		rts				rts
.019d07					FPUCopyFromNext:
.019d07	a0 06		ldy #$06			ldy 		#6
.019d09	da		phx				phx
.019d0a					_FPUCopy1:
.019d0a	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa,x
.019d0d	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.019d10	e8		inx				inx
.019d11	88		dey				dey
.019d12	d0 f6		bne $019d0a			bne 	_FPUCopy1
.019d14	fa		plx				plx
.019d15	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.019d16					FPToString:
.019d16	48		pha				pha
.019d17	5a		phy				phy
.019d18	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; check zero flag
.019d1b	50 0a		bvc $019d27			bvc 		_FPTSIsFloat 			; if zero,
.019d1d					_FPTSZero:
.019d1d	a9 30		lda #$30			lda 		#"0"
.019d1f	20 a6 97	jsr $0197a6			jsr 		ITSOutputCharacter
.019d22					_FPTSExit:
.019d22	7a		ply				ply
.019d23	68		pla				pla
.019d24	60		rts				rts
.019d25	80 fb		bra $019d22			bra 		_FPTSExit
.019d27					_FPTSIsFloat:
.019d27	bd 0d 03	lda $030d,x			lda 		XS_Type,x 				; is it signed ?
.019d2a	10 0a		bpl $019d36			bpl 		_FPTSNotSigned
.019d2c	a9 00		lda #$00			lda 		#0 						; clear sign flag
.019d2e	9d 0d 03	sta $030d,x			sta 		XS_Type,x
.019d31	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.019d33	20 a6 97	jsr $0197a6			jsr 		ITSOutputCharacter
.019d36					_FPTSNotSigned:
.019d36	bd 0c 03	lda $030c,x			lda 		XS_Exponent,x
.019d39	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.019d3b	b0 09		bcs $019d46			bcs 		_FPTSExponent
.019d3d	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.019d3f	90 05		bcc $019d46			bcc 		_FPTSExponent 			;
.019d41					_FPTSStandard:
.019d41	20 8a 9d	jsr $019d8a			jsr 		FPTOutputBody 			; output the body.
.019d44	80 dc		bra $019d22			bra 		_FPTSExit
.019d46					_FPTSExponent:
.019d46	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.019d48	8d 8f 04	sta $048f			sta 		ExpCount
.019d4b					_FPTSExponentLoop:
.019d4b	bd 0c 03	lda $030c,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.019d4e	10 0e		bpl $019d5e			bpl 		_FPTSTimes
.019d50	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.019d52	90 14		bcc $019d68			bcc 		_FPTSScaledToExp
.019d54	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.019d56	20 b4 9c	jsr $019cb4			jsr 		FPUScale10A
.019d59	ee 8f 04	inc $048f			inc 		ExpCount
.019d5c	80 ed		bra $019d4b			bra 		_FPTSExponentLoop
.019d5e					_FPTSTimes:
.019d5e	a9 01		lda #$01			lda 		#1
.019d60	20 b4 9c	jsr $019cb4			jsr 		FPUScale10A
.019d63	ce 8f 04	dec $048f			dec 		ExpCount
.019d66	80 e3		bra $019d4b			bra 		_FPTSExponentLoop
.019d68					_FPTSScaledToExp:
.019d68	20 8a 9d	jsr $019d8a			jsr 		FPTOutputBody 			; output the body.
.019d6b	a9 65		lda #$65			lda 		#"e"					; output E
.019d6d	20 a6 97	jsr $0197a6			jsr 		ITSOutputCharacter
.019d70	ad 8f 04	lda $048f			lda 		ExpCount 				; get the exponent
.019d73	9d 08 03	sta $0308,x			sta 		XS_Mantissa,x
.019d76	29 80		and #$80			and 		#$80 					; sign extend it
.019d78	f0 02		beq $019d7c			beq 		_FPTSSExt
.019d7a	a9 ff		lda #$ff			lda 		#$FF
.019d7c					_FPTSSExt:
.019d7c	9d 09 03	sta $0309,x			sta 		XS_Mantissa+1,x
.019d7f	9d 0a 03	sta $030a,x			sta 		XS_Mantissa+2,x
.019d82	9d 0b 03	sta $030b,x			sta 		XS_Mantissa+3,x
.019d85	20 02 97	jsr $019702			jsr 		INTToString 			; output the exponent.
.019d88	80 98		bra $019d22			bra			_FPTSExit 				; and exit.
.019d8a					FPTOutputBody:
.019d8a	20 f8 9c	jsr $019cf8			jsr 		FPUCopyToNext 			; copy to next slot.
.019d8d	20 eb 9b	jsr $019beb			jsr 		FPUToInteger 			; convert to an integer
.019d90	20 02 97	jsr $019702			jsr 		INTToString 			; output the main integer part.
.019d93	20 07 9d	jsr $019d07			jsr 		FPUCopyFromNext 		; get the fractional part back.
.019d96	20 77 9a	jsr $019a77			jsr 		FPFractionalPart 		; get the decimal part.
.019d99	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; any fractional part.
.019d9c	70 3e		bvs $019ddc			bvs 		_FPTOExit 				; if not, exit now.
.019d9e	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.019da0	20 a6 97	jsr $0197a6			jsr 		ITSOutputCharacter
.019da3					_FPOutLoop:
.019da3	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; finally reached zero.
.019da6	70 1e		bvs $019dc6			bvs 		_FPStripZeros 			; strip trailing zeros
.019da8	20 53 9c	jsr $019c53			jsr 		FPUTimes10 				; multiply by 10
.019dab	20 f8 9c	jsr $019cf8			jsr 		FPUCopyToNext			; copy to next slot.
.019dae	20 eb 9b	jsr $019beb			jsr 		FPUToInteger 			; convert to integer
.019db1	bd 08 03	lda $0308,x			lda 		XS_Mantissa+0,x 		; print digit.
.019db4	09 30		ora #$30			ora 		#"0"
.019db6	20 a6 97	jsr $0197a6			jsr 		ITSOutputCharacter
.019db9	20 07 9d	jsr $019d07			jsr 		FPUCopyFromNext 		; get it back
.019dbc	20 77 9a	jsr $019a77			jsr 		FPFractionalPart 		; get fractional part
.019dbf	ad 06 04	lda $0406			lda 		NumBufX 				; done 11 characters yet ?
.019dc2	c9 0b		cmp #$0b			cmp 	 	#11
.019dc4	90 dd		bcc $019da3			bcc 		_FPOutLoop 				; if so, keep going till zero.
.019dc6					_FPStripZeros:
.019dc6	ac 06 04	ldy $0406			ldy 		NumBufX 				; strip trailing zeros.
.019dc9					_FPStripLoop:
.019dc9	88		dey				dey 								; back one, if at start then no strip
.019dca	f0 10		beq $019ddc			beq 		_FPToExit
.019dcc	b9 07 04	lda $0407,y			lda 		Num_Buffer,y 			; keep going if "0"
.019dcf	c9 30		cmp #$30			cmp 		#"0"
.019dd1	f0 f6		beq $019dc9			beq 		_FPStripLoop
.019dd3	c8		iny				iny
.019dd4	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.019dd6	99 07 04	sta $0407,y			sta 		Num_Buffer,y
.019dd9	8c 06 04	sty $0406			sty 		NumBufX 				; update position.
.019ddc					_FPTOExit:
.019ddc	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.019ddd					FPFromString:
.019ddd	48		pha				pha 								; push A
.019dde	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.019de0	c9 2e		cmp #$2e			cmp 	#"."
.019de2	f0 03		beq $019de7			beq	 	_FPFIsDecimal
.019de4	4c 4a 9e	jmp $019e4a			jmp 	_FPFNotDecimal
.019de7					_FPFIsDecimal:
.019de7	c8		iny				iny 								; consume the decimal.
.019de8	20 8c 9b	jsr $019b8c			jsr 	FPUToFloat 					; convert the integer to float.
.019deb	da		phx				phx 								; save X.
.019dec	5a		phy				phy 								; save decimal start position
.019ded	e8		inx				inx
.019dee	e8		inx				inx
.019def	e8		inx				inx
.019df0	e8		inx				inx
.019df1	e8		inx				inx
.019df2	e8		inx				inx
.019df3	20 be 97	jsr $0197be			jsr 	INTFromStringY 				; get the part after the DP.
.019df6	20 8c 9b	jsr $019b8c			jsr 	FPUToFloat 					; convert that to a float.
.019df9	68		pla				pla 								; calculate - chars consumed.
.019dfa	8c 8e 04	sty $048e			sty 	ExpTemp
.019dfd	38		sec				sec
.019dfe	ed 8e 04	sbc $048e			sbc 	ExpTemp 					; this is the shift amount
.019e01	20 b4 9c	jsr $019cb4			jsr 	FPUScale10A 				; scale it by 10^AC
.019e04	fa		plx				plx 								; restore original X
.019e05	20 6e 98	jsr $01986e			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.019e08	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.019e0a	c9 45		cmp #$45			cmp 	#"E"
.019e0c	f0 04		beq $019e12			beq 	_FPFExponent
.019e0e	c9 65		cmp #$65			cmp 	#"e"
.019e10	d0 38		bne $019e4a			bne 	_FPFNotDecimal 				; no, then exit normally.
.019e12					_FPFExponent:
.019e12	c8		iny				iny 								; skip over E symbol.
.019e13	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.019e15	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.019e17	d0 01		bne $019e1a			bne 	_FPFGotSign
.019e19	c8		iny				iny 								; if it was - skip over it.
.019e1a					_FPFGotSign:
.019e1a	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.019e1b	da		phx				phx
.019e1c	e8		inx				inx
.019e1d	e8		inx				inx
.019e1e	e8		inx				inx
.019e1f	e8		inx				inx
.019e20	e8		inx				inx
.019e21	e8		inx				inx
.019e22	20 be 97	jsr $0197be			jsr 	INTFromStringY 				; get the exponent
.019e25	fa		plx				plx 								; restore X.
.019e26	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.019e29	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.019e2c	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.019e2f	d0 1b		bne $019e4c			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.019e31	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.019e34	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.019e36	b0 14		bcs $019e4c			bcs 	_FPFXOverflow
.019e38	68		pla				pla 								; get direction
.019e39	d0 09		bne $019e44			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.019e3b	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.019e3e	49 ff		eor #$ff			eor 	#$FF
.019e40	1a		inc a				inc 	a
.019e41	9d 0e 03	sta $030e,x			sta 	XS2_Mantissa+0,x
.019e44					_FPFXScale:
.019e44	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.019e47	20 b4 9c	jsr $019cb4			jsr 	FPUScale10A 				; scale by the exponent.
.019e4a					_FPFNotDecimal:
.019e4a	68		pla				pla
.019e4b	60		rts				rts
.019e4c					_FPFXOverflow:
.019e4c	20 2f 84	jsr $01842f			jsr 	ERR_Handler
>019e4f	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>019e57	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.019e5e					Unary_Rnd:
.019e5e	20 65 8a	jsr $018a65			jsr 	EvaluateNumberX 			; get value
.019e61	20 2b 91	jsr $01912b			jsr 	CheckNextRParen 			; check right bracket.
.019e64	20 52 8d	jsr $018d52			jsr 	GetSignCurrent 				; get sign -1,0,1.
.019e67	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.019e69	30 10		bmi $019e7b			bmi 	_URSetSeed
.019e6b	f0 2c		beq $019e99			beq 	_URMakeRandom 				; if zero return same number.
.019e6d	da		phx				phx
.019e6e	a2 00		ldx #$00			ldx 	#0
.019e70	20 d6 9e	jsr $019ed6			jsr 	Random16
.019e73	a2 02		ldx #$02			ldx 	#2
.019e75	20 d6 9e	jsr $019ed6			jsr 	Random16
.019e78	fa		plx				plx
.019e79	80 1e		bra $019e99			bra 	_URMakeRandom
.019e7b					_URSetSeed:
.019e7b	20 8c 9b	jsr $019b8c			jsr 	FPUToFloat 					; make it a float to twiddle it.
.019e7e	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.019e81	8d 95 04	sta $0495			sta 	RandomSeed+0
.019e84	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.019e87	8d 96 04	sta $0496			sta 	RandomSeed+1
.019e8a	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.019e8d	8d 97 04	sta $0497			sta 	RandomSeed+2
.019e90	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.019e93	0a		asl a				asl 	a
.019e94	49 db		eor #$db			eor 	#$DB
.019e96	8d 98 04	sta $0498			sta 	RandomSeed+3
.019e99					_URMakeRandom:
.019e99	ad 95 04	lda $0495			lda 	RandomSeed+0 				; check if seed is zero.
.019e9c	0d 96 04	ora $0496			ora 	RandomSeed+1
.019e9f	0d 97 04	ora $0497			ora 	RandomSeed+2
.019ea2	0d 98 04	ora $0498			ora 	RandomSeed+3
.019ea5	d0 0a		bne $019eb1			bne 	_URNotZero
.019ea7	a9 47		lda #$47			lda 	#$47
.019ea9	8d 96 04	sta $0496			sta 	RandomSeed+1				; if it is, make it non zero.
.019eac	a9 3d		lda #$3d			lda 	#$3D
.019eae	8d 98 04	sta $0498			sta 	RandomSeed+3
.019eb1					_URNotZero:
.019eb1	ad 95 04	lda $0495			lda 	RandomSeed+0 				; copy seed into mantissa.
.019eb4	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019eb7	ad 96 04	lda $0496			lda 	RandomSeed+1
.019eba	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019ebd	ad 97 04	lda $0497			lda 	RandomSeed+2
.019ec0	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019ec3	ad 98 04	lda $0498			lda 	RandomSeed+3
.019ec6	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019ec9	a9 00		lda #$00			lda 	#$00 						; set type to float.
.019ecb	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019ece	a9 80		lda #$80			lda 	#$80
.019ed0	9d 0c 03	sta $030c,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.019ed3	4c c3 9b	jmp $019bc3			jmp 	FPUNormalise
.019ed6					Random16:
.019ed6	5e 96 04	lsr $0496,x			lsr 	RandomSeed+1,x				; shift seed right
.019ed9	7e 95 04	ror $0495,x			ror 	RandomSeed,x
.019edc	90 08		bcc $019ee6			bcc 	_R16_NoXor
.019ede	bd 96 04	lda $0496,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.019ee1	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.019ee3	9d 96 04	sta $0496,x			sta 	RandomSeed+1,x
.019ee6					_R16_NoXor:
.019ee6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.019ee7					Unary_Int:
.019ee7	20 65 8a	jsr $018a65			jsr 	EvaluateNumberX 			; get value
.019eea	20 2b 91	jsr $01912b			jsr 	CheckNextRParen 			; check right bracket.
.019eed	4c eb 9b	jmp $019beb			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Return to file: basic.asm

>019ef0	02						.byte 	2
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 c0						.word 	StartROM
>fffe	19 c0					.word TIM_BreakHandler

;******  End of listing
