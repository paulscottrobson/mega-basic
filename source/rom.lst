
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Wed Aug 21 18:51:20 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="65816"				cpu = "65816"
="em65816"				hardware = "em65816"
=1					hasFloat = 1
=1					hasInteger = 1

;******  Processing file: modules/float/fpmacros.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/em65816/src_em65816.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/common/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0200					IFT_XCursor:.byte ?							; current logical position on screen
>0201					IFT_YCursor:.byte ?
>0202					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0266					IFT_LineBuffer: .fill 100 					; line input buffer.
>0300					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>0304					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>0305					XS_Type 	.byte ? 						; bit 7 sign (float only)
=774					XS2_Mantissa = XS_Mantissa+6
=778					XS2_Exponent = XS_Exponent+6
=779					XS2_Type = XS_Type+6
>0400					Num_Buffer	.fill 	32 						; buffer for numeric conversions
>0420					NumBufX 	.byte 	?						; buffer index position
>0421					NumSuppress	.byte 	?						; leading zero suppression flag
>0422					NumConvCount .byte 	? 						; count for conversions.
>0423					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>0425					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>0427					Tim_SR:		.byte ? 						; Processor Status
>0428					Tim_A:		.byte ? 						; Processor Registers
>0429					Tim_X:		.byte ?
>042a					Tim_Y:		.byte ?
>042b					Tim_Z:		.byte ?
>042c					Tim_SP:		.byte ?							; Stack Pointer
>042d					ExpTemp:	.byte ?							; Working temp for exponents.
>042e					ExpCount:	.byte ? 						; Count of decimal exponents.

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/em65816.asm

.1000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testcode.src

>1000	18 0a 00 d6 41 64 89 56			.byte	$18,$0a,$00,$d6,$41,$64,$89,$56
>1008	fd 03 30 8c 47 fd 03 30			.byte	$fd,$03,$30,$8c,$47,$fd,$03,$30
>1010	bb ff 06 68 69 20 21 00			.byte	$bb,$ff,$06,$68,$69,$20,$21,$00
>1018	00					.byte	$00

;******  Return to file: modules/hardware/em65816.asm


;******  Processing file: modules/hardware/../common/header/header.src

=$92					firstKeywordMinus = $92
=$8e					firstKeywordPlus = $8e
=$97					firstUnaryFunction = $97
=$b1					lastUnaryFunction = $b1
.c000					VectorTable:
>c000	ac c0					.word NotImplemented       ; $80 and
>c002	ac c0					.word NotImplemented       ; $81 or
>c004	ac c0					.word NotImplemented       ; $82 xor
>c006	ac c0					.word NotImplemented       ; $83 =
>c008	ac c0					.word NotImplemented       ; $84 <>
>c00a	ac c0					.word NotImplemented       ; $85 <
>c00c	ac c0					.word NotImplemented       ; $86 <=
>c00e	ac c0					.word NotImplemented       ; $87 >
>c010	ac c0					.word NotImplemented       ; $88 >=
>c012	07 c5					.word BinaryOp_Add         ; $89 +
>c014	1a c5					.word BinaryOp_Subtract    ; $8a -
>c016	2d c5					.word BinaryOp_Multiply    ; $8b *
>c018	40 c5					.word BinaryOp_Divide      ; $8c /
>c01a	ac c0					.word NotImplemented       ; $8d ^
>c01c	ac c0					.word NotImplemented       ; $8e if
>c01e	ac c0					.word NotImplemented       ; $8f while
>c020	ac c0					.word NotImplemented       ; $90 repeat
>c022	ac c0					.word NotImplemented       ; $91 for
>c024	ac c0					.word NotImplemented       ; $92 then
>c026	ac c0					.word NotImplemented       ; $93 endif
>c028	ac c0					.word NotImplemented       ; $94 wend
>c02a	ac c0					.word NotImplemented       ; $95 until
>c02c	ac c0					.word NotImplemented       ; $96 next
>c02e	ac c0					.word NotImplemented       ; $97 not
>c030	ac c0					.word NotImplemented       ; $98 fn(
>c032	ac c0					.word NotImplemented       ; $99 abs(
>c034	ac c0					.word NotImplemented       ; $9a asc(
>c036	ac c0					.word NotImplemented       ; $9b int(
>c038	ac c0					.word NotImplemented       ; $9c peek(
>c03a	ac c0					.word NotImplemented       ; $9d rnd(
>c03c	ac c0					.word NotImplemented       ; $9e usr(
>c03e	ac c0					.word NotImplemented       ; $9f left$(
>c040	ac c0					.word NotImplemented       ; $a0 right$(
>c042	ac c0					.word NotImplemented       ; $a1 mid$(
>c044	ac c0					.word NotImplemented       ; $a2 spc(
>c046	ac c0					.word NotImplemented       ; $a3 str$(
>c048	ac c0					.word NotImplemented       ; $a4 val(
>c04a	ac c0					.word NotImplemented       ; $a5 len(
>c04c	ac c0					.word NotImplemented       ; $a6 hex$(
>c04e	ac c0					.word NotImplemented       ; $a7 sin(
>c050	ac c0					.word NotImplemented       ; $a8 cos(
>c052	ac c0					.word NotImplemented       ; $a9 tan(
>c054	ac c0					.word NotImplemented       ; $aa atn(
>c056	ac c0					.word NotImplemented       ; $ab exp(
>c058	ac c0					.word NotImplemented       ; $ac log(
>c05a	ac c0					.word NotImplemented       ; $ad sqr(
>c05c	ac c0					.word NotImplemented       ; $ae dec(
>c05e	ac c0					.word NotImplemented       ; $af deek(
>c060	ac c0					.word NotImplemented       ; $b0 leek(
>c062	ac c0					.word NotImplemented       ; $b1 mod(
>c064	ac c0					.word NotImplemented       ; $b2 $(
>c066	ac c0					.word NotImplemented       ; $b3 $
>c068	ac c0					.word NotImplemented       ; $b4 #(
>c06a	ac c0					.word NotImplemented       ; $b5 #
>c06c	ac c0					.word NotImplemented       ; $b6 %(
>c06e	ac c0					.word NotImplemented       ; $b7 %
>c070	ac c0					.word NotImplemented       ; $b8 (
>c072	ac c0					.word NotImplemented       ; $b9 )
>c074	ac c0					.word NotImplemented       ; $ba ,
>c076	ac c0					.word NotImplemented       ; $bb :
>c078	ac c0					.word NotImplemented       ; $bc ;
>c07a	ac c0					.word NotImplemented       ; $bd def
>c07c	ac c0					.word NotImplemented       ; $be clr
>c07e	ac c0					.word NotImplemented       ; $c0 data
>c080	ac c0					.word NotImplemented       ; $c1 read
>c082	ac c0					.word NotImplemented       ; $c2 dim
>c084	ac c0					.word NotImplemented       ; $c3 to
>c086	ac c0					.word NotImplemented       ; $c4 step
>c088	ac c0					.word NotImplemented       ; $c5 gosub
>c08a	ac c0					.word NotImplemented       ; $c6 return
>c08c	ac c0					.word NotImplemented       ; $c7 goto
>c08e	ac c0					.word NotImplemented       ; $c8 input
>c090	ac c0					.word NotImplemented       ; $c9 let
>c092	ac c0					.word NotImplemented       ; $ca list
>c094	ac c0					.word NotImplemented       ; $cb new
>c096	ac c0					.word NotImplemented       ; $cc old
>c098	ac c0					.word NotImplemented       ; $cd on
>c09a	ac c0					.word NotImplemented       ; $ce restore
>c09c	ac c0					.word NotImplemented       ; $cf poke
>c09e	ac c0					.word NotImplemented       ; $d0 print
>c0a0	ac c0					.word NotImplemented       ; $d1 run
>c0a2	ac c0					.word NotImplemented       ; $d2 stop
>c0a4	ac c0					.word NotImplemented       ; $d3 wait
>c0a6	ac c0					.word NotImplemented       ; $d4 doke
>c0a8	ac c0					.word NotImplemented       ; $d5 loke
>c0aa	ac c0					.word NotImplemented       ; $d6 assert
.c0ac					NotImplemented:
.c0ac	80 fe		bra $c0ac		_error: bra _error
>c0ae	53 79 6e 74 61 78 20 45			.text "Syntax Error",0
>c0b6	72 72 6f 72 00
.c0bb					BinaryPrecedence:
>c0bb	01					.byte 1    ; $80 and
>c0bc	01					.byte 1    ; $81 or
>c0bd	01					.byte 1    ; $82 xor
>c0be	02					.byte 2    ; $83 =
>c0bf	02					.byte 2    ; $84 <>
>c0c0	02					.byte 2    ; $85 <
>c0c1	02					.byte 2    ; $86 <=
>c0c2	02					.byte 2    ; $87 >
>c0c3	02					.byte 2    ; $88 >=
>c0c4	03					.byte 3    ; $89 +
>c0c5	03					.byte 3    ; $8a -
>c0c6	04					.byte 4    ; $8b *
>c0c7	04					.byte 4    ; $8c /
>c0c8	05					.byte 5    ; $8d ^
.c0c9					KeywordText:
>c0c9	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>c0cc	4f d2					.byte $4f,$d2                          ; $81 or
>c0ce	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>c0d1	bd					.byte $bd                              ; $83 =
>c0d2	3c be					.byte $3c,$be                          ; $84 <>
>c0d4	bc					.byte $bc                              ; $85 <
>c0d5	3c bd					.byte $3c,$bd                          ; $86 <=
>c0d7	be					.byte $be                              ; $87 >
>c0d8	3e bd					.byte $3e,$bd                          ; $88 >=
>c0da	ab					.byte $ab                              ; $89 +
>c0db	ad					.byte $ad                              ; $8a -
>c0dc	aa					.byte $aa                              ; $8b *
>c0dd	af					.byte $af                              ; $8c /
>c0de	de					.byte $de                              ; $8d ^
>c0df	49 c6					.byte $49,$c6                          ; $8e if
>c0e1	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $8f while
>c0e6	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $90 repeat
>c0ec	46 4f d2				.byte $46,$4f,$d2                      ; $91 for
>c0ef	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $92 then
>c0f3	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $93 endif
>c0f8	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $94 wend
>c0fc	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $95 until
>c101	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $96 next
>c105	4e 4f d4				.byte $4e,$4f,$d4                      ; $97 not
>c108	46 4e a8				.byte $46,$4e,$a8                      ; $98 fn(
>c10b	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $99 abs(
>c10f	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9a asc(
>c113	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9b int(
>c117	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9c peek(
>c11c	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9d rnd(
>c120	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9e usr(
>c124	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $9f left$(
>c12a	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a0 right$(
>c131	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a1 mid$(
>c136	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a2 spc(
>c13a	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a3 str$(
>c13f	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a4 val(
>c143	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a5 len(
>c147	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a6 hex$(
>c14c	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a7 sin(
>c150	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a8 cos(
>c154	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $a9 tan(
>c158	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $aa atn(
>c15c	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ab exp(
>c160	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ac log(
>c164	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ad sqr(
>c168	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $ae dec(
>c16c	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $af deek(
>c171	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b0 leek(
>c176	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b1 mod(
>c17a	24 a8					.byte $24,$a8                          ; $b2 $(
>c17c	a4					.byte $a4                              ; $b3 $
>c17d	23 a8					.byte $23,$a8                          ; $b4 #(
>c17f	a3					.byte $a3                              ; $b5 #
>c180	25 a8					.byte $25,$a8                          ; $b6 %(
>c182	a5					.byte $a5                              ; $b7 %
>c183	a8					.byte $a8                              ; $b8 (
>c184	a9					.byte $a9                              ; $b9 )
>c185	ac					.byte $ac                              ; $ba ,
>c186	ba					.byte $ba                              ; $bb :
>c187	bb					.byte $bb                              ; $bc ;
>c188	44 45 c6				.byte $44,$45,$c6                      ; $bd def
>c18b	43 4c d2				.byte $43,$4c,$d2                      ; $be clr
>c18e	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c0 data
>c192	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c1 read
>c196	44 49 cd				.byte $44,$49,$cd                      ; $c2 dim
>c199	54 cf					.byte $54,$cf                          ; $c3 to
>c19b	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c4 step
>c19f	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $c5 gosub
>c1a4	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $c6 return
>c1aa	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $c7 goto
>c1ae	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $c8 input
>c1b3	4c 45 d4				.byte $4c,$45,$d4                      ; $c9 let
>c1b6	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $ca list
>c1ba	4e 45 d7				.byte $4e,$45,$d7                      ; $cb new
>c1bd	4f 4c c4				.byte $4f,$4c,$c4                      ; $cc old
>c1c0	4f ce					.byte $4f,$ce                          ; $cd on
>c1c2	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $ce restore
>c1c9	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $cf poke
>c1cd	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d0 print
>c1d2	52 55 ce				.byte $52,$55,$ce                      ; $d1 run
>c1d5	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $d2 stop
>c1d9	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d3 wait
>c1dd	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $d4 doke
>c1e1	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $d5 loke
>c1e5	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $d6 assert
>c1eb	00					.byte $00

;******  Return to file: modules/hardware/em65816.asm

.c1ec					StartROM:
.c1ec	18		clc				clc
.c1ed	fb		xce				xce
.c1ee	c2 30		rep #$30			rep 	#$30
.c1f0	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.c1f3	1b		tcs				tcs
.c1f4	e2 30		sep #$30			sep 	#$30 						; clear AXY in 16 bit.
.c1f6	c2 30		rep #$30			rep 	#$30
.c1f8	a9 00 00	lda #$0000			lda 	#$0000
.c1fb	aa		tax				tax
.c1fc	a8		tay				tay
.c1fd	e2 30		sep #$30			sep 	#$30
.c1ff	20 a3 c3	jsr $c3a3			jsr 	IF_Reset 					; reset external interface
.c202	20 08 c2	jsr $c208			jsr 	IFT_ClearScreen
.c205	4c f2 c3	jmp $c3f2		jmp BASIC_Start

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.c208					IFT_ClearScreen:
.c208	48		pha				pha
.c209	da		phx				phx
.c20a	5a		phy				phy
.c20b	20 a4 c3	jsr $c3a4			jsr 	IF_Home 					; home cursor
.c20e	a2 20		ldx #$20			ldx 	#IF_Height 					; this many lines.
.c210					_IFT_CS0:
.c210	a0 40		ldy #$40			ldy 	#IF_Width 					; this many chars/line
.c212					_IFT_CS1:
.c212	a9 20		lda #$20			lda 	#' '						; clear line.
.c214	20 d0 c3	jsr $c3d0			jsr 	IF_Write
.c217	88		dey				dey
.c218	d0 f8		bne $c212			bne 	_IFT_CS1
.c21a	20 b7 c3	jsr $c3b7			jsr 	IF_NewLine 					; next line down
.c21d	ca		dex				dex
.c21e	d0 f0		bne $c210			bne 	_IFT_CS0
.c220	7a		ply				ply
.c221	fa		plx				plx
.c222	68		pla				pla
.c223					IFT_HomeCursor:
.c223	48		pha				pha
.c224	20 a4 c3	jsr $c3a4			jsr 	IF_Home
.c227	a9 00		lda #$00			lda 	#0
.c229	8d 00 02	sta $0200			sta 	IFT_XCursor
.c22c	8d 01 02	sta $0201			sta 	IFT_YCursor
.c22f	68		pla				pla
.c230	60		rts				rts
.c231					IFT_UpLine:
.c231	48		pha				pha
.c232	ad 01 02	lda $0201			lda  	IFT_YCursor 				; get Y
.c235	3a		dec a				dec 	a 							; line above
.c236	30 03		bmi $c23b			bmi 	_IFTULExit 					; too far, abort
.c238	20 c6 c2	jsr $c2c6			jsr 	IFT_SetYPos					; set to that line.
.c23b					_IFTULExit:
.c23b	68		pla				pla
.c23c	60		rts				rts
.c23d					IFT_PrintCharacter:
.c23d	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.c23f	f0 16		beq $c257			beq 	IFT_NewLine
.c241	48		pha				pha
.c242	20 6f c2	jsr $c26f			jsr 	IFT_UpperCase 				; make upper case
.c245	20 d0 c3	jsr $c3d0			jsr 	IF_Write 					; write out.
.c248	ee 00 02	inc $0200			inc 	IFT_XCursor 				; bump x cursor
.c24b	ad 00 02	lda $0200			lda 	IFT_XCursor 				; reached RHS ?
.c24e	c9 40		cmp #$40			cmp 	#IF_Width
.c250	d0 03		bne $c255			bne 	_IFT_PCNotEOL
.c252	20 57 c2	jsr $c257			jsr 	IFT_NewLine 				; if so do new line.
.c255					_IFT_PCNotEOL:
.c255	68		pla				pla
.c256	60		rts				rts
.c257					IFT_NewLine:
.c257	48		pha				pha
.c258	20 b7 c3	jsr $c3b7			jsr 	IF_NewLine 					; new line on actual screen.
.c25b	a9 00		lda #$00			lda 	#0 							; reset x position
.c25d	8d 00 02	sta $0200			sta 	IFT_XCursor
.c260	ee 01 02	inc $0201			inc 	IFT_YCursor 				; move down.
.c263	ad 01 02	lda $0201			lda 	IFT_YCursor
.c266	c9 20		cmp #$20			cmp 	#IF_Height 					; reached bottom.
.c268	d0 03		bne $c26d			bne 	_IFT_NL_NotEOS
.c26a	20 7a c2	jsr $c27a			jsr 	IFT_Scroll 					; scroll screen up.
.c26d					_IFT_NL_NotEOS:
.c26d	68		pla				pla
.c26e	60		rts				rts
.c26f					IFT_UpperCase:
.c26f	c9 61		cmp #$61			cmp 	#"a"
.c271	90 06		bcc $c279			bcc 	_IFT_UCExit
.c273	c9 7b		cmp #$7b			cmp 	#"z"+1
.c275	b0 02		bcs $c279			bcs 	_IFT_UCExit
.c277	49 20		eor #$20			eor 	#$20
.c279					_IFT_UCExit:
.c279	60		rts				rts
.c27a					IFT_Scroll:
.c27a	48		pha				pha 								; save AXY
.c27b	da		phx				phx
.c27c	5a		phy				phy
.c27d	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.c27f					_IFT_SLoop:
.c27f	20 9f c2	jsr $c29f			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.c282	e8		inx				inx
.c283	e0 1f		cpx #$1f			cpx 	#IF_Height-1				; do whole screen
.c285	d0 f8		bne $c27f			bne 	_IFT_SLoop
.c287	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.c289	20 c6 c2	jsr $c2c6			jsr 	IFT_SetYPos
.c28c	a2 40		ldx #$40			ldx 	#IF_Width 					; blank line
.c28e					_IFT_SBlank:
.c28e	a9 20		lda #$20			lda 	#32
.c290	20 d0 c3	jsr $c3d0			jsr 	IF_Write
.c293	ca		dex				dex
.c294	d0 f8		bne $c28e			bne 	_IFT_SBlank
.c296	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.c298	20 c6 c2	jsr $c2c6			jsr 	IFT_SetYPos
.c29b	7a		ply				ply
.c29c	fa		plx				plx
.c29d	68		pla				pla
.c29e	60		rts				rts
.c29f					_IFT_ScrollLine:
.c29f	da		phx				phx
.c2a0	da		phx				phx
.c2a1	8a		txa				txa 								; copy line into buffer.
.c2a2	1a		inc a				inc 	a 							; next line down.
.c2a3	20 c6 c2	jsr $c2c6			jsr 	IFT_SetYPos
.c2a6	a2 00		ldx #$00			ldx 	#0
.c2a8					_IFTScrollCopy1:
.c2a8	20 c7 c3	jsr $c3c7			jsr 	IF_Read
.c2ab	9d 02 02	sta $0202,x			sta 	IFT_Buffer,x
.c2ae	e8		inx				inx
.c2af	e0 40		cpx #$40			cpx 	#IF_Width
.c2b1	d0 f5		bne $c2a8			bne 	_IFTScrollCopy1
.c2b3	68		pla				pla
.c2b4	20 c6 c2	jsr $c2c6			jsr 	IFT_SetYPos
.c2b7	a2 00		ldx #$00			ldx 	#0
.c2b9					_IFTScrollCopy2:
.c2b9	bd 02 02	lda $0202,x			lda 	IFT_Buffer,x
.c2bc	20 d0 c3	jsr $c3d0			jsr 	IF_Write
.c2bf	e8		inx				inx
.c2c0	e0 40		cpx #$40			cpx 	#IF_Width
.c2c2	d0 f5		bne $c2b9			bne 	_IFTScrollCopy2
.c2c4	fa		plx				plx
.c2c5	60		rts				rts
.c2c6					IFT_SetYPos:
.c2c6	48		pha				pha
.c2c7	da		phx				phx
.c2c8	aa		tax				tax
.c2c9	20 23 c2	jsr $c223			jsr 	IFT_HomeCursor
.c2cc	e0 00		cpx #$00			cpx 	#0
.c2ce	f0 09		beq $c2d9			beq 	_IFT_MOAExit
.c2d0					_IFT_MOALoop:
.c2d0	20 b7 c3	jsr $c3b7			jsr 	IF_NewLine
.c2d3	ee 01 02	inc $0201			inc 	IFT_YCursor
.c2d6	ca		dex				dex
.c2d7	d0 f7		bne $c2d0			bne		_IFT_MOALoop
.c2d9					_IFT_MOAExit:
.c2d9	fa		plx				plx
.c2da	68		pla				pla
.c2db	60		rts				rts
.c2dc					IFT_GetKeyCursor:
.c2dc	20 e4 c2	jsr $c2e4			jsr 	_IFT_FlipCursor 			; reverse current
.c2df					_IFT_GKCWait:
.c2df	20 e1 c3	jsr $c3e1			jsr 	IF_GetKey 					; get key
.c2e2	f0 fb		beq $c2df			beq 	_IFT_GKCWait
.c2e4					_IFT_FlipCursor:
.c2e4	48		pha				pha 								; save
.c2e5	20 c7 c3	jsr $c3c7			jsr 	IF_Read 					; read
.c2e8	20 d9 c3	jsr $c3d9			jsr 	IF_LeftOne
.c2eb	49 80		eor #$80			eor 	#$80 						; reverse
.c2ed	20 d0 c3	jsr $c3d0			jsr 	IF_Write 					; write
.c2f0	20 d9 c3	jsr $c3d9			jsr 	IF_LeftOne
.c2f3	68		pla				pla
.c2f4	60		rts				rts
.c2f5					IFT_ReadLine:
.c2f5	48		pha				pha
.c2f6					_IFT_RLLoop:
.c2f6	20 dc c2	jsr $c2dc			jsr 	IFT_GetKeyCursor 			; get keystroke
.c2f9	c9 0d		cmp #$0d			cmp 	#13							; return
.c2fb	f0 7d		beq $c37a			beq 	_IFT_RLExit
.c2fd	c9 20		cmp #$20			cmp 	#32 						; control character
.c2ff	90 05		bcc $c306			bcc 	_IFT_Control
.c301	20 3d c2	jsr $c23d			jsr 	IFT_PrintCharacter
.c304	80 f0		bra $c2f6			bra 	_IFT_RLLoop
.c306					_IFT_Control:
.c306	c9 01		cmp #$01			cmp 	#"A"-64
.c308	f0 26		beq $c330			beq 	_IFT_Left
.c30a	c9 04		cmp #$04			cmp 	#"D"-64
.c30c	f0 2e		beq $c33c			beq 	_IFT_Right
.c30e	c9 17		cmp #$17			cmp 	#"W"-64
.c310	f0 36		beq $c348			beq 	_IFT_Up
.c312	c9 13		cmp #$13			cmp 	#"S"-64
.c314	f0 3e		beq $c354			beq 	_IFT_Down
.c316	c9 08		cmp #$08			cmp 	#"H"-64
.c318	f0 09		beq $c323			beq 	_IFT_Backspace
.c31a	c9 1a		cmp #$1a			cmp 	#"Z"-64
.c31c	d0 d8		bne $c2f6			bne 	_IFT_RLLoop
.c31e	20 08 c2	jsr $c208			jsr 	IFT_ClearScreen				; clear CTL-Z
.c321	80 d3		bra $c2f6			bra 	_IFT_RLLoop
.c323					_IFT_Backspace:
.c323	ad 00 02	lda $0200			lda 	IFT_XCursor 				; check not start of line.
.c326	f0 ce		beq $c2f6			beq 	_IFT_RLLoop
.c328	20 d9 c3	jsr $c3d9			jsr 	IF_LeftOne
.c32b	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.c32d	20 d0 c3	jsr $c3d0			jsr 	IF_Write
.c330					_IFT_Left:
.c330	ce 00 02	dec $0200			dec 	IFT_XCursor 				; left CTL-W
.c333	10 29		bpl $c35e			bpl 	_IFT_Reposition
.c335	a9 3f		lda #$3f			lda 	#IF_Width-1
.c337					_IFT_SetX:
.c337	8d 00 02	sta $0200			sta 	IFT_XCursor
.c33a	80 22		bra $c35e			bra 	_IFT_Reposition
.c33c					_IFT_Right:
.c33c	ee 00 02	inc $0200			inc 	IFT_XCursor
.c33f	ad 00 02	lda $0200			lda 	IFT_XCursor
.c342	49 40		eor #$40			eor 	#IF_Width
.c344	f0 f1		beq $c337			beq 	_IFT_SetX
.c346	80 16		bra $c35e			bra 	_IFT_Reposition
.c348					_IFT_Up:
.c348	ce 01 02	dec $0201			dec 	IFT_YCursor
.c34b	10 11		bpl $c35e			bpl 	_IFT_Reposition
.c34d	a9 1f		lda #$1f			lda 	#IF_Height-1
.c34f					_IFT_SetY:
.c34f	8d 01 02	sta $0201			sta 	IFT_YCursor
.c352	80 0a		bra $c35e			bra 	_IFT_Reposition
.c354					_IFT_Down:
.c354	ee 01 02	inc $0201			inc 	IFT_YCursor
.c357	ad 01 02	lda $0201			lda 	IFT_YCursor
.c35a	49 20		eor #$20			eor 	#IF_Height
.c35c	f0 f1		beq $c34f			beq 	_IFT_SetY
.c35e					_IFT_Reposition:
.c35e	ad 00 02	lda $0200			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.c361	48		pha				pha
.c362	ad 01 02	lda $0201			lda 	IFT_YCursor
.c365	20 c6 c2	jsr $c2c6			jsr 	IFT_SetYPos
.c368	68		pla				pla
.c369	aa		tax				tax
.c36a	e0 00		cpx #$00			cpx 	#0
.c36c	f0 88		beq $c2f6			beq 	_IFT_RLLoop
.c36e					_IFT_MoveRight:
.c36e	20 c7 c3	jsr $c3c7			jsr 	IF_Read
.c371	ee 00 02	inc $0200			inc 	IFT_XCursor
.c374	ca		dex				dex
.c375	d0 f7		bne $c36e			bne 	_IFT_MoveRight
.c377	4c f6 c2	jmp $c2f6			jmp 	_IFT_RLLoop
.c37a					_IFT_RLExit:
.c37a	ad 01 02	lda $0201			lda 	IFT_YCursor 				; go to start of line.
.c37d	20 c6 c2	jsr $c2c6			jsr 	IFT_SetYPos
.c380	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.c382					_IFT_RLRead:
.c382	20 c7 c3	jsr $c3c7			jsr 	IF_Read
.c385	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.c388	e8		inx				inx
.c389	e0 40		cpx #$40			cpx 	#IF_Width
.c38b	d0 f5		bne $c382			bne 	_IFT_RLRead
.c38d					_IFT_RL_Trim:
.c38d	ca		dex				dex 	 							; previous char
.c38e	30 07		bmi $c397			bmi 	_IFT_Found 					; gone too far
.c390	bd 66 02	lda $0266,x			lda 	IFT_LineBuffer,x			; go back if space
.c393	c9 20		cmp #$20			cmp 	#" "
.c395	f0 f6		beq $c38d			beq 	_IFT_RL_Trim
.c397					_IFT_Found:
.c397	e8		inx				inx 								; forward to non-space
.c398	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.c39a	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.c39d	68		pla				pla
.c39e	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.c3a0	a0 02		ldy #$02			ldy 	#IFT_LineBuffer >> 8
.c3a2	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_em65816.asm

=64					IF_Width 	= 64 							; characters across
=32					IF_Height 	= 32 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line.
=8					IF_XPos 	= 8 							; current position, horizontal.
=$f0000					IF_Screen = $F0000							; 2k screen RAM here
=$f8010					IF_PKeyboard = $F8010						; Keyboard port.
=$f8000					IF_PBreak = $F8000 							; Break key.
.c3a3					IF_Reset:
.c3a3	60		rts				rts
.c3a4					IF_Home:
.c3a4	48		pha				pha
.c3a5	64 08		stz $08				stz 	IF_XPos 					; zero X position
.c3a7	a9 00		lda #$00			lda 	#IF_Screen & $FF 			; set r/w pos.
.c3a9	85 04		sta $04				sta 	IF_Pos
.c3ab	a9 00		lda #$00			lda 	#(IF_Screen >> 8) & $FF
.c3ad	85 05		sta $05				sta 	IF_Pos+1
.c3af	a9 0f		lda #$0f			lda 	#IF_Screen >> 16
.c3b1	85 06		sta $06				sta 	IF_Pos+2
.c3b3	64 07		stz $07				stz 	IF_Pos+3
.c3b5	68		pla				pla
.c3b6	60		rts				rts
.c3b7					IF_NewLine:
.c3b7	48		pha				pha
.c3b8	64 08		stz $08				stz 	IF_XPos						; back to start of line
.c3ba	18		clc				clc 								; down one line
.c3bb	a5 04		lda $04				lda 	IF_Pos
.c3bd	69 40		adc #$40			adc 	#64
.c3bf	85 04		sta $04				sta 	IF_Pos
.c3c1	90 02		bcc $c3c5			bcc 	_IF_NoCarry 				; carry through.
.c3c3	e6 05		inc $05				inc 	IF_Pos+1
.c3c5					_IF_NoCarry:
.c3c5	68		pla				pla
.c3c6	60		rts				rts
.c3c7					IF_Read:
.c3c7	5a		phy				phy 								; save current Y
.c3c8	a4 08		ldy $08				ldy 	IF_XPos 					; read character at current position
.c3ca	b7 04		lda [$04],y			lda 	[IF_Pos],y
.c3cc	e6 08		inc $08				inc 	IF_XPos 					; step right.
.c3ce	7a		ply				ply									; restore Y
.c3cf	60		rts				rts
.c3d0					IF_Write:
.c3d0	5a		phy				phy 								; save current Y
.c3d1	a4 08		ldy $08				ldy 	IF_XPos 					; write character at current position
.c3d3	97 04		sta [$04],y			sta 	[IF_Pos],y
.c3d5	e6 08		inc $08				inc 	IF_XPos 					; step right.
.c3d7	7a		ply				ply									; restore Y
.c3d8	60		rts				rts
.c3d9					IF_LeftOne:
.c3d9	c6 08		dec $08				dec 	IF_XPos
.c3db	60		rts				rts
.c3dc					IF_CheckBreak:
.c3dc	af 00 80 0f	lda $0f8000			lda 	IF_PBreak					; non-zero if Ctrl+C pressed.
.c3e0	60		rts				rts
.c3e1					IF_GetKey:
.c3e1	af 10 80 0f	lda $0f8010			lda 	IF_PKeyboard				; read keyboard
.c3e5	f0 08		beq $c3ef			beq		_IFGK_NoKey 				; skip if zero,no key pressed
.c3e7	48		pha				pha 								; key pressed, clear queue.
.c3e8	a9 00		lda #$00			lda 	#0
.c3ea	8f 10 80 0f	sta $0f8010			sta 	IF_PKeyboard
.c3ee	68		pla				pla
.c3ef					_IFGK_NoKey:
.c3ef	09 00		ora #$00			ora 	#0							; set Z flag appropriately.
.c3f1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm

.c3f2					BASIC_Start:
.c3f2	a9 00		lda #$00			lda 	#BasicProgram & $FF
.c3f4	85 16		sta $16				sta 	zCodePtr+0
.c3f6	a9 10		lda #$10			lda 	#BasicProgram >> 8
.c3f8	85 17		sta $17				sta 	zCodePtr+1
.c3fa	a9 00		lda #$00			lda 	#0
.c3fc	85 18		sta $18				sta 	zCodePtr+2
.c3fe	85 19		sta $19				sta 	zCodePtr+3
.c400	a0 03		ldy #$03			ldy 	#3
.c402	c8		iny				iny
.c403	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c405	20 0e c4	jsr $c40e			jsr 	EvaluateExpression
>c408	02						.byte 	2
.c409					SyntaxError:
.c409					ERR_Handler:
.c409	80 fe		bra $c409			bra 	ERR_Handler

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.c40b					EVESyntax:
.c40b	4c 09 c4	jmp $c409			jmp 	SyntaxError
.c40e					EvaluateExpression:
.c40e	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.c410					EvaluateExpressionX:
.c410	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.c412					EvaluateExpressionXA:
.c412	48		pha				pha 								; save precedence on stack.
.c413	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c415	f0 f4		beq $c40b			beq 	EVESyntax 					; end of line, syntax error.
.c417	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.c419	b0 03		bcs $c41e			bcs 	_EVNotVariable
.c41b	4c a3 c4	jmp $c4a3			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.c41e					_EVNotVariable:
.c41e	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.c420	90 e9		bcc $c40b			bcc 	EVESyntax
.c422	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.c424	b0 7b		bcs $c4a1			bcs 	_EVNotInteger
.c426	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.c428	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.c42b	a9 00		lda #$00			lda 	#0
.c42d	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c430	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c433	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c436	a9 01		lda #$01			lda 	#1 							; set to type 1 (integer)
.c438	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c43b					_EVCheckNextInteger:
.c43b	c8		iny				iny
.c43c	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c43e	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.c440	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.c442	b0 0d		bcs $c451			bcs 	_EVCheckDecimal
.c444	48		pha				pha 								; save it.
.c445	20 a7 c4	jsr $c4a7			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.c448	68		pla				pla
.c449	1d 00 03	ora $0300,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.c44c	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c44f	80 ea		bra $c43b			bra 	_EVCheckNextInteger
.c451					_EVCheckDecimal:
.c451	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c453	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.c455	d0 05		bne $c45c			bne 	_EVGotAtom 					; no, get atom.
.c457					_EVIsDecimal:
.c457	20 d7 c4	jsr $c4d7			jsr 	EVGetDecimal 				; extend to the decimal part.
.c45a	80 00		bra $c45c			bra 	_EVGotAtom 					; and continue to got atom.
.c45c					_EVGotAtom:
.c45c	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c45e	10 3f		bpl $c49f			bpl 	_EVExitDrop 				; must be a token.
.c460	c9 8e		cmp #$8e			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.c462	b0 3b		bcs $c49f			bcs 	_EVExitDrop
.c464	68		pla				pla 								; get current precedence
.c465	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.c467	da		phx				phx 								; save X
.c468	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c46a	aa		tax				tax 								; put in X
.c46b	bd 3b c0	lda $c03b,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.c46e	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.c470	fa		plx				plx 								; restore X
.c471	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.c473	90 2b		bcc $c4a0			bcc 	_EVExit 					; exit if too low.
.c475	f0 29		beq $c4a0			beq 	_EVExit 					; exit if equals
.c477	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.c479	48		pha				pha
.c47a	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c47c	48		pha				pha
.c47d	c8		iny				iny
.c47e	da		phx				phx 								; save current position
.c47f	e8		inx				inx
.c480	e8		inx				inx
.c481	e8		inx				inx
.c482	e8		inx				inx
.c483	e8		inx				inx
.c484	e8		inx				inx
.c485	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.c487	20 12 c4	jsr $c412			jsr 	EvaluateExpressionXA 		; do the RHS.
.c48a	fa		plx				plx 								; restore X
.c48b	68		pla				pla 								; get the binary operator in A.
.c48c	da		phx				phx 								; save X again
.c48d	0a		asl a				asl 	a 							; double, lose the MSB.
.c48e	aa		tax				tax									; put in X
.c48f	bd 00 c0	lda $c000,x			lda 	VectorTable,x 				; copy address into zGenPtr
.c492	85 1e		sta $1e				sta 	zGenPtr
.c494	bd 01 c0	lda $c001,x			lda 	VectorTable+1,x
.c497	85 1f		sta $1f				sta 	zGenPtr+1
.c499	fa		plx				plx 								; restore X
.c49a	20 a4 c4	jsr $c4a4			jsr 	EVGoZGenPtr 				; execute that function/operator
.c49d	80 bd		bra $c45c			bra 	_EVGotAtom 					; and loop back.
.c49f					_EVExitDrop:
.c49f	68		pla				pla
.c4a0					_EVExit:
.c4a0	60		rts				rts
.c4a1					_EVNotInteger:
.c4a1	80 fe		bra $c4a1			bra 	_EVNotInteger
.c4a3					_EVVariableHandler:
.c4a3	ea		nop				nop
.c4a4					EVGoZGenPtr:
.c4a4	6c 1e 00	jmp ($001e)			jmp 	 (zGenPtr)
.c4a7					EVShiftMantissaLeft6:
.c4a7	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.c4aa	9d 04 03	sta $0304,x			sta 	XS_Exponent,x
.c4ad	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c4b0	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c4b3	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c4b6	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c4b9	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.c4bc	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c4bf	a9 00		lda #$00			lda 	#0
.c4c1	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c4c4	20 c7 c4	jsr $c4c7			jsr 	_EVSMLShift 					; call it here to do it twice
.c4c7					_EVSMLShift:
.c4c7	5e 04 03	lsr $0304,x			lsr 	XS_Exponent,x
.c4ca	7e 03 03	ror $0303,x			ror 	XS_Mantissa+3,x
.c4cd	7e 02 03	ror $0302,x			ror 	XS_Mantissa+2,x
.c4d0	7e 01 03	ror $0301,x			ror 	XS_Mantissa+1,x
.c4d3	7e 00 03	ror $0300,x			ror 	XS_Mantissa+0,x
.c4d6	60		rts				rts
.c4d7					EVGetDecimal:
.c4d7	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.c4d9	8d 00 04	sta $0400			sta 	Num_Buffer
.c4dc	da		phx				phx
.c4dd	c8		iny				iny
.c4de	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c4e0	c8		iny				iny
.c4e1	3a		dec a				dec 	a								; convert to a string length.
.c4e2	3a		dec a				dec 	a
.c4e3	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.c4e5					_EVGDCopy:
.c4e5	48		pha				pha 									; save count
.c4e6	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c4e8	9d 00 04	sta $0400,x			sta 	Num_Buffer,x
.c4eb	e8		inx				inx 									; forward ....
.c4ec	c8		iny				iny
.c4ed	68		pla				pla 									; get count
.c4ee	3a		dec a				dec 	a 								; until zero
.c4ef	d0 f4		bne $c4e5			bne 	_EVGDCopy
.c4f1	9d 00 04	sta $0400,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.c4f4	fa		plx				plx 									; restore X
.c4f5	a9 00		lda #$00			lda 	#Num_Buffer & $FF 				; set zGenPtr
.c4f7	85 1e		sta $1e				sta 	zGenPtr
.c4f9	a9 04		lda #$04			lda 	#Num_Buffer >> 8
.c4fb	85 1f		sta $1f				sta 	zGenPtr+1
.c4fd	5a		phy				phy 									; save Y
.c4fe	a0 00		ldy #$00			ldy 	#0 								; start position
.c500	20 46 cb	jsr $cb46			jsr 	FPFromString 					; convert current
.c503	7a		ply				ply 									; restore Y
.c504	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/multiply.asm

.c505					MulInteger32:
.c505	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/divide.asm

.c506					DivInteger32:
.c506	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.c507					BinaryOp_Add:
.c507	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; and 2 type bytes together.
.c50a	3d 0b 03	and $030b,x			and 	XS2_Type,x
.c50d	4a		lsr a				lsr 	a 							; shift bit 0 into C
.c50e	90 03		bcc $c513			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.c510	4c 53 c5	jmp $c553			jmp 	AddInteger32 							; so execute code at \1
.c513					_BCFloat:
.c513	20 9f c5	jsr $c59f			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.c516	4c d9 c5	jmp $c5d9			jmp 	FPAdd 							; and execute code at \2
.c519	60		rts				rts
.c51a					BinaryOp_Subtract:
.c51a	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; and 2 type bytes together.
.c51d	3d 0b 03	and $030b,x			and 	XS2_Type,x
.c520	4a		lsr a				lsr 	a 							; shift bit 0 into C
.c521	90 03		bcc $c526			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.c523	4c 79 c5	jmp $c579			jmp 	SubInteger32 							; so execute code at \1
.c526					_BCFloat:
.c526	20 9f c5	jsr $c59f			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.c529	4c cf c5	jmp $c5cf			jmp 	FPSubtract 							; and execute code at \2
.c52c	60		rts				rts
.c52d					BinaryOp_Multiply:
.c52d	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; and 2 type bytes together.
.c530	3d 0b 03	and $030b,x			and 	XS2_Type,x
.c533	4a		lsr a				lsr 	a 							; shift bit 0 into C
.c534	90 03		bcc $c539			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.c536	4c 05 c5	jmp $c505			jmp 	MulInteger32 							; so execute code at \1
.c539					_BCFloat:
.c539	20 9f c5	jsr $c59f			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.c53c	4c 44 c7	jmp $c744			jmp 	FPMultiply 							; and execute code at \2
.c53f	60		rts				rts
.c540					BinaryOp_Divide:
.c540	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; and 2 type bytes together.
.c543	3d 0b 03	and $030b,x			and 	XS2_Type,x
.c546	4a		lsr a				lsr 	a 							; shift bit 0 into C
.c547	90 03		bcc $c54c			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.c549	4c 06 c5	jmp $c506			jmp 	DivInteger32 							; so execute code at \1
.c54c					_BCFloat:
.c54c	20 9f c5	jsr $c59f			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.c54f	4c bc c6	jmp $c6bc			jmp 	FPDivide 							; and execute code at \2
.c552	60		rts				rts
.c553					AddInteger32:
.c553	18		clc				clc
.c554	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.c557	7d 06 03	adc $0306,x			adc 	XS2_Mantissa+0,x
.c55a	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c55d	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c560	7d 07 03	adc $0307,x			adc 	XS2_Mantissa+1,x
.c563	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c566	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c569	7d 08 03	adc $0308,x			adc 	XS2_Mantissa+2,x
.c56c	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c56f	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c572	7d 09 03	adc $0309,x			adc 	XS2_Mantissa+3,x
.c575	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c578	60		rts				rts
.c579					SubInteger32:
.c579	38		sec				sec
.c57a	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.c57d	fd 06 03	sbc $0306,x			sbc 	XS2_Mantissa+0,x
.c580	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c583	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c586	fd 07 03	sbc $0307,x			sbc 	XS2_Mantissa+1,x
.c589	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c58c	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c58f	fd 08 03	sbc $0308,x			sbc 	XS2_Mantissa+2,x
.c592	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c595	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c598	fd 09 03	sbc $0309,x			sbc 	XS2_Mantissa+3,x
.c59b	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c59e	60		rts				rts
.c59f					BinaryMakeBothFloat:
.c59f	da		phx				phx 								; save X
.c5a0	e8		inx				inx
.c5a1	e8		inx				inx
.c5a2	e8		inx				inx
.c5a3	e8		inx				inx
.c5a4	e8		inx				inx
.c5a5	e8		inx				inx
.c5a6	20 aa c5	jsr $c5aa			jsr 	BinaryMakeFloat 			; convert to float.
.c5a9	fa		plx				plx 								; restore X and fall through.
.c5aa					BinaryMakeFloat:
.c5aa	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; get type byte.
.c5ad	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.c5ae	b0 04		bcs $c5b4			bcs 	_BMFConvert
.c5b0	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.c5b1	b0 04		bcs $c5b7			bcs 	_BMFError
.c5b3	60		rts				rts
.c5b4					_BMFConvert:
.c5b4	4c f6 c8	jmp $c8f6			jmp 	FPUToFloat 					; convert to float
.c5b7					_BMFError:
.c5b7	80 fe		bra $c5b7		_error: bra _error
>c5b9	4e 75 6d 65 72 69 63 20				.text 	"Numeric type required",0
>c5c1	74 79 70 65 20 72 65 71 75 69 72 65 64 00

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.c5cf					FPSubtract:
.c5cf	48		pha				pha
.c5d0	bd 0b 03	lda $030b,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.c5d3	49 80		eor #$80			eor 	#$80
.c5d5	9d 0b 03	sta $030b,x			sta 	XS2_Type,x
.c5d8	68		pla				pla 								; --- and fall through ---
.c5d9					FPAdd:
.c5d9	48		pha				pha
.c5da	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.c5dd	d0 05		bne $c5e4			bne 	_FPA_NegativeLHS
.c5df	20 01 c6	jsr $c601			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.c5e2	68		pla				pla
.c5e3	60		rts				rts
.c5e4					_FPA_NegativeLHS:
.c5e4	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.c5e7	49 80		eor #$80			eor 	#$80
.c5e9	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c5ec	bd 0b 03	lda $030b,x			lda 	XS2_Type,x 					; flip the sign of B and add
.c5ef	49 80		eor #$80			eor 	#$80
.c5f1	9d 0b 03	sta $030b,x			sta 	XS2_Type,x
.c5f4	20 01 c6	jsr $c601			jsr 	FPAdd_Worker 				; do the add calculation.
.c5f7	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; flip sign of X1 back
.c5fa	49 80		eor #$80			eor 	#$80
.c5fc	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c5ff	68		pla				pla
.c600	60		rts				rts
.c601					FPAdd_Worker:
.c601	3c 0b 03	bit $030b,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.c604	70 08		bvs $c60e			bvs 	_FPAWExit 					; no change.
.c606	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.c609	50 07		bvc $c612			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.c60b	20 a5 c8	jsr $c8a5			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.c60e					_FPAWExit:
.c60e	20 2d c9	jsr $c92d			jsr 	FPUNormalise 				; normalise the result.
.c611	60		rts				rts
.c612					_FPAWMakeSame:
.c612	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.c615	38		sec				sec
.c616	fd 0a 03	sbc $030a,x			sbc	 	XS2_Exponent,x 				; using subtraction
.c619	f0 1b		beq $c636			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.c61b	da		phx				phx 								; save X
.c61c	90 06		bcc $c624			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.c61e	e8		inx				inx
.c61f	e8		inx				inx
.c620	e8		inx				inx
.c621	e8		inx				inx
.c622	e8		inx				inx
.c623	e8		inx				inx
.c624					_FPAWShiftA:
.c624	fe 04 03	inc $0304,x			inc 	XS_Exponent,x 				; so shift exponent up.
.c627	5e 03 03	lsr $0303,x			lsr 	3+XS_Mantissa,x
.c62a	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.c62d	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.c630	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.c633	fa		plx				plx 								; restore original X
.c634	80 dc		bra $c612			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.c636					_FPAW_DoArithmetic:
.c636	3c 0b 03	bit $030b,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.c639	30 39		bmi $c674			bmi 	_FPAW_BNegative
.c63b	18		clc				clc
.c63c	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.c63f	7d 06 03	adc $0306,x			adc 	XS2_Mantissa+0,x
.c642	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c645	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c648	7d 07 03	adc $0307,x			adc 	XS2_Mantissa+1,x
.c64b	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c64e	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c651	7d 08 03	adc $0308,x			adc 	XS2_Mantissa+2,x
.c654	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c657	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c65a	7d 09 03	adc $0309,x			adc 	XS2_Mantissa+3,x
.c65d	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c660	90 ac		bcc $c60e			bcc 	_FPAWExit 					; no carry.
.c662	fe 04 03	inc $0304,x			inc 	XS_Exponent,x 				; so shift exponent up.
.c665	38		sec				sec
.c666	7e 03 03	ror $0303,x			ror 	3+XS_Mantissa,x
.c669	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.c66c	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.c66f	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.c672	80 9a		bra $c60e			bra 	_FPAWExit
.c674					_FPAW_BNegative:
.c674	38		sec				sec
.c675	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.c678	fd 06 03	sbc $0306,x			sbc 	XS2_Mantissa+0,x
.c67b	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c67e	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c681	fd 07 03	sbc $0307,x			sbc 	XS2_Mantissa+1,x
.c684	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c687	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c68a	fd 08 03	sbc $0308,x			sbc 	XS2_Mantissa+2,x
.c68d	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c690	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c693	fd 09 03	sbc $0309,x			sbc 	XS2_Mantissa+3,x
.c696	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c699	b0 0b		bcs $c6a6			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.c69b	20 d2 c8	jsr $c8d2			jsr 	FPUNegateInteger			; negate the mantissa
.c69e	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; flip result sign
.c6a1	49 80		eor #$80			eor 	#$80
.c6a3	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c6a6					_FPAWGoExit:
.c6a6	4c 0e c6	jmp $c60e			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.c6a9					FPD_IsDivZero:
.c6a9	80 fe		bra $c6a9		_error: bra _error
>c6ab	44 69 76 69 73 69 6f 6e				.text 		"Division by zero",0
>c6b3	20 62 79 20 7a 65 72 6f 00
.c6bc					FPDivide:
.c6bc	48		pha				pha
.c6bd	5a		phy				phy
.c6be	3c 0b 03	bit $030b,x			bit 	XS2_Type,x 					; check if division by zero
.c6c1	70 e6		bvs $c6a9			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.c6c3	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.c6c6	f0 03		beq $c6cb			beq 	_FPDCalculateExp
.c6c8					_FPD_Exit:
.c6c8	7a		ply				ply
.c6c9	68		pla				pla
.c6ca	60		rts				rts
.c6cb					_FPDCalculateExp:
.c6cb	bd 0a 03	lda $030a,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.c6ce	49 ff		eor #$ff			eor 	#$FF
.c6d0	1a		inc a				inc 	a
.c6d1	9d 0a 03	sta $030a,x			sta 	XS2_Exponent,x
.c6d4	20 c8 c7	jsr $c7c8			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.c6d7	18		clc				clc 	 							; add 1 to the resulting exponent
.c6d8	69 01		adc #$01			adc 	#1
.c6da	b0 65		bcs $c741			bcs 	_FPD_Overflow 				; which can overflow.
.c6dc	9d 04 03	sta $0304,x			sta 	XS_Exponent,x
.c6df	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.c6e1	85 1a		sta $1a				sta 	zLTemp1+0
.c6e3	85 1b		sta $1b				sta 	zLTemp1+1
.c6e5	85 1c		sta $1c				sta 	zLTemp1+2
.c6e7	85 1d		sta $1d				sta 	zLTemp1+3
.c6e9	a0 20		ldy #$20			ldy 	#32 						; times round.
.c6eb					_FPD_Loop:
.c6eb	38		sec				sec 								; calculate X1-X2 stacking result because we might
.c6ec	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x 				; not save it.
.c6ef	fd 06 03	sbc $0306,x			sbc 	XS2_Mantissa,x
.c6f2	48		pha				pha
.c6f3	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c6f6	fd 07 03	sbc $0307,x			sbc 	XS2_Mantissa+1,x
.c6f9	48		pha				pha
.c6fa	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c6fd	fd 08 03	sbc $0308,x			sbc 	XS2_Mantissa+2,x
.c700	48		pha				pha
.c701	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c704	fd 09 03	sbc $0309,x			sbc 	XS2_Mantissa+3,x
.c707	90 17		bcc $c720			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.c709	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x 			; save results out to A
.c70c	68		pla				pla
.c70d	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c710	68		pla				pla
.c711	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c714	68		pla				pla
.c715	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c718	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.c71a	09 80		ora #$80			ora 	#$80
.c71c	85 1d		sta $1d				sta 	zLTemp1+3
.c71e	80 03		bra $c723			bra 	_FPD_Rotates
.c720					_FPD_NoSubtract:
.c720	68		pla				pla 								; throw away unwanted results
.c721	68		pla				pla
.c722	68		pla				pla
.c723					_FPD_Rotates:
.c723	5e 09 03	lsr $0309,x			lsr 	3+XS2_Mantissa,x
.c726	7e 08 03	ror $0308,x			ror 	2+XS2_Mantissa,x
.c729	7e 07 03	ror $0307,x			ror 	1+XS2_Mantissa,x
.c72c	7e 06 03	ror $0306,x			ror 	0+XS2_Mantissa,x
.c72f	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.c731	26 1b		rol $1b				rol 	zLTemp1+1
.c733	26 1c		rol $1c				rol 	zLTemp1+2
.c735	26 1d		rol $1d				rol 	zLTemp1+3
.c737	90 02		bcc $c73b			bcc 	_FPD_NoCarry
.c739	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.c73b					_FPD_NoCarry:
.c73b	88		dey				dey 								; do 32 times
.c73c	d0 ad		bne $c6eb			bne 	_FPD_Loop
.c73e	4c a5 c7	jmp $c7a5			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.c741					_FPD_Overflow:
.c741	4c a2 c9	jmp $c9a2			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.c744					FPMultiply:
.c744	48		pha				pha
.c745	5a		phy				phy
.c746	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.c749	70 08		bvs $c753			bvs 	_FPM_Exit
.c74b	3c 0b 03	bit $030b,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.c74e	50 06		bvc $c756			bvc 	_FPM_CalcExponent
.c750	20 a5 c8	jsr $c8a5			jsr 	FPUCopyX2ToX1
.c753					_FPM_Exit:
.c753	7a		ply				ply
.c754	68		pla				pla
.c755	60		rts				rts
.c756					_FPM_CalcExponent:
.c756	18		clc				clc
.c757	20 c8 c7	jsr $c7c8			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.c75a	9d 04 03	sta $0304,x			sta 	XS_Exponent,x 				; save the result.
.c75d	a9 00		lda #$00			lda 	#0
.c75f	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.c761	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.c763	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.c765	85 1d		sta $1d				sta 	zLTemp1+3
.c767	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.c769					_FPM_Loop:
.c769	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x				; check LSB of long product
.c76c	29 01		and #$01			and 	#1
.c76e	18		clc				clc 								; clear carry for the long rotate.
.c76f	f0 1d		beq $c78e			beq 	_FPM_NoAddition
.c771	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.c772	a5 1a		lda $1a				lda 	zLTemp1+0
.c774	7d 06 03	adc $0306,x			adc 	XS2_Mantissa+0,x
.c777	85 1a		sta $1a				sta 	zLTemp1+0
.c779	a5 1b		lda $1b				lda 	zLTemp1+1
.c77b	7d 07 03	adc $0307,x			adc 	XS2_Mantissa+1,x
.c77e	85 1b		sta $1b				sta 	zLTemp1+1
.c780	a5 1c		lda $1c				lda 	zLTemp1+2
.c782	7d 08 03	adc $0308,x			adc 	XS2_Mantissa+2,x
.c785	85 1c		sta $1c				sta 	zLTemp1+2
.c787	a5 1d		lda $1d				lda 	zLTemp1+3
.c789	7d 09 03	adc $0309,x			adc 	XS2_Mantissa+3,x
.c78c	85 1d		sta $1d				sta 	zLTemp1+3
.c78e					_FPM_NoAddition:
.c78e	66 1d		ror $1d				ror 	3+zLTemp1
.c790	66 1c		ror $1c				ror 	2+zLTemp1
.c792	66 1b		ror $1b				ror 	1+zLTemp1
.c794	66 1a		ror $1a				ror 	0+zLTemp1
.c796	7e 03 03	ror $0303,x			ror 	3+XS_Mantissa,x
.c799	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.c79c	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.c79f	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.c7a2	88		dey				dey
.c7a3	d0 c4		bne $c769			bne 	_FPM_Loop 					; do this 32 times.
.c7a5					FPM_CopySignNormalize:
.c7a5	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.c7a7	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.c7aa	a5 1b		lda $1b				lda 	zLTemp1+1
.c7ac	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c7af	a5 1c		lda $1c				lda 	zLTemp1+2
.c7b1	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c7b4	a5 1d		lda $1d				lda 	zLTemp1+3
.c7b6	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c7b9	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; sign is xor of signs
.c7bc	5d 0b 03	eor $030b,x			eor 	XS2_Type,x
.c7bf	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c7c2	20 2d c9	jsr $c92d			jsr 	FPUNormalise 				; normalise and exit.
.c7c5	7a		ply				ply
.c7c6	68		pla				pla
.c7c7	60		rts				rts
.c7c8					FPCalculateExponent:
.c7c8	18		clc				clc
.c7c9	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.c7cc	7d 0a 03	adc $030a,x			adc 	XS2_Exponent,x
.c7cf	b0 08		bcs $c7d9			bcs 	_FPCECarry 					; carry out ?
.c7d1	10 03		bpl $c7d6			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.c7d3	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.c7d5	60		rts				rts
.c7d6					_FPCEExpZero:
.c7d6	a9 00		lda #$00			lda 	#0
.c7d8	60		rts				rts
.c7d9					_FPCECarry:
.c7d9	30 03		bmi $c7de			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.c7db	09 80		ora #$80			ora 	#$80 						; put in right range
.c7dd	60		rts				rts
.c7de					_FPCEOverflow:
.c7de	4c a2 c9	jmp $c9a2			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.c7e1					FPFractionalPart:
.c7e1	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.c7e4	38		sec				sec 								; this flag tells us to keep the fractional part
.c7e5	30 0f		bmi $c7f6			bmi 	FPGetPart
.c7e7	60		rts				rts
.c7e8					FPIntegerPart:
.c7e8	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.c7eb	18		clc				clc 								; this flag says keep the integer part.
.c7ec	30 08		bmi $c7f6			bmi 	FPGetPart 					; -ve exponents are 0..127
.c7ee	48		pha				pha
.c7ef	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.c7f1	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c7f4	68		pla				pla
.c7f5	60		rts				rts
.c7f6					FPGetPart:
.c7f6	48		pha				pha
.c7f7	5a		phy				phy 								; save Y
.c7f8	08		php				php 								; save action
.c7f9	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.c7fc	70 62		bvs $c860			bvs 	_FPGP_Exit 					; then do nothing.
.c7fe	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.c800	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.c802	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.c804	85 1c		sta $1c				sta 	zLTemp1+2
.c806	85 1d		sta $1d				sta 	zLTemp1+3
.c808	bd 04 03	lda $0304,x			lda 	XS_Exponent,x				; the number of shifts.
.c80b	38		sec				sec
.c80c	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.c80e	f0 12		beq $c822			beq 	_FPGP_NoShift 				; ... if any
.c810	c9 20		cmp #$20			cmp 	#32
.c812	90 02		bcc $c816			bcc 	_FPGP_NotMax
.c814	a9 20		lda #$20			lda 	#32 						; max of 32.
.c816					_FPGP_NotMax:
.c816	a8		tay				tay 								; Y is the mask shift count.
.c817					_FPGP_ShiftMask:
.c817	46 1d		lsr $1d				lsr 	3+zLTemp1
.c819	66 1c		ror $1c				ror 	2+zLTemp1
.c81b	66 1b		ror $1b				ror 	1+zLTemp1
.c81d	66 1a		ror $1a				ror 	0+zLTemp1
.c81f	88		dey				dey
.c820	d0 f5		bne $c817			bne 	_FPGP_ShiftMask
.c822					_FPGP_NoShift:
.c822	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.c824	8e 2d 04	stx $042d			stx 	ExpTemp						; save X
.c827					_FPGP_MaskLoop:
.c827	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.c82a	28		plp				plp 								; if CC we keep the top part, so we
.c82b	08		php				php		 							; flip the mask.
.c82c	b0 02		bcs $c830			bcs		_FPGP_NoFlip
.c82e	49 ff		eor #$ff			eor 	#$FF
.c830					_FPGP_NoFlip:
.c830	3d 00 03	and $0300,x			and 	XS_Mantissa,x 				; and into the mantissa.
.c833	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.c836	e8		inx				inx
.c837	c8		iny				iny
.c838	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.c83a	d0 eb		bne $c827			bne 	_FPGP_MaskLoop
.c83c	ae 2d 04	ldx $042d			ldx 	ExpTemp						; restore X
.c83f	28		plp				plp
.c840	08		php				php 								; get action flag on the stack
.c841	90 05		bcc $c848			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.c843	a9 00		lda #$00			lda 	#0
.c845	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c848					_FPGP_NotFractional:
.c848	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x 						; check if \1 zero
.c84b	1d 01 03	ora $0301,x			ora 	XS_Mantissa+1,x
.c84e	1d 02 03	ora $0302,x			ora 	XS_Mantissa+2,x
.c851	1d 03 03	ora $0303,x			ora 	XS_Mantissa+3,x
.c854	f0 05		beq $c85b			beq 	_FPGP_Zero 					; if zero, return zero
.c856	20 2d c9	jsr $c92d			jsr 	FPUNormalise
.c859	80 05		bra $c860			bra 	_FPGP_Exit 					; and exit
.c85b					_FPGP_Zero:
.c85b	a9 40		lda #$40			lda 	#$40 						; set zero flag
.c85d	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c860					_FPGP_Exit:
.c860	68		pla				pla 								; throw saved action flag.
.c861	7a		ply				ply
.c862	68		pla				pla
.c863	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.c864					FPCompare:
.c864	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.c867	48		pha				pha
.c868	bd 0a 03	lda $030a,x			lda 	XS2_Exponent,x
.c86b	48		pha				pha
.c86c	20 cf c5	jsr $c5cf			jsr 	FPSubtract 					; calculate X1-X2
.c86f	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.c872	70 2c		bvs $c8a0			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.c874	68		pla				pla
.c875	8d 2d 04	sta $042d			sta 	ExpTemp						; save first exponent in temporary reg.
.c878	68		pla				pla
.c879	38		sec				sec
.c87a	ed 2d 04	sbc $042d			sbc 	ExpTemp 					; calculate AX-BX
.c87d	70 15		bvs $c894			bvs 	_FPCNotEqual				; overflow, can't be equal.
.c87f	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.c880	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.c882	b0 10		bcs $c894			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.c884	38		sec				sec
.c885	ad 2d 04	lda $042d			lda 	ExpTemp 					; get one of the exponents back.
.c888	e9 18		sbc #$18			sbc 	#24 						; allow for 2^24 error, relatively.
.c88a	b0 02		bcs $c88e			bcs 	_FPCNotRange 				; keep in range.
.c88c	a9 01		lda #$01			lda 	#1
.c88e					_FPCNotRange:
.c88e	38		sec				sec
.c88f	fd 04 03	sbc $0304,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.c892	b0 0e		bcs $c8a2			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.c894					_FPCNotEqual:
.c894	bd 05 03	lda $0305,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.c897	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.c899	f0 02		beq $c89d			beq 	_FPCNE2
.c89b	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.c89d	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.c89e	80 04		bra $c8a4			bra 	_FPCExit
.c8a0					_FPCPullZero:
.c8a0	68		pla				pla 								; throw saved exponents
.c8a1	68		pla				pla
.c8a2					_FPCZero:
.c8a2	a9 00		lda #$00			lda 	#0 							; and return zero
.c8a4					_FPCExit:
.c8a4	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.c8a5					FPUCopyX2ToX1:
.c8a5	48		pha				pha
.c8a6	da		phx				phx
.c8a7	5a		phy				phy
.c8a8	a0 08		ldy #$08			ldy 	#8
.c8aa	bd 06 03	lda $0306,x	_FPUC21:lda 	XS2_Mantissa,x
.c8ad	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.c8b0	e8		inx				inx
.c8b1	88		dey				dey
.c8b2	10 f6		bpl $c8aa			bpl 	_FPUC21
.c8b4	7a		ply				ply
.c8b5	fa		plx				plx
.c8b6	68		pla				pla
.c8b7	60		rts				rts
.c8b8					FPUSetInteger:
.c8b8	48		pha				pha
.c8b9	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.c8bc	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.c8be	10 02		bpl $c8c2			bpl 	_FPUSIExtend
.c8c0	a9 ff		lda #$ff			lda 	#$FF
.c8c2					_FPUSIExtend:
.c8c2	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.c8c5	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c8c8	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c8cb	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.c8cd	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c8d0	68		pla				pla
.c8d1	60		rts				rts
.c8d2					FPUNegateInteger:
.c8d2	48		pha				pha
.c8d3	38		sec				sec
.c8d4	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.c8d6	fd 00 03	sbc $0300,x			sbc 	XS_Mantissa+0,x
.c8d9	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c8dc	a9 00		lda #$00			lda 	#0
.c8de	fd 01 03	sbc $0301,x			sbc 	XS_Mantissa+1,x
.c8e1	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c8e4	a9 00		lda #$00			lda 	#0
.c8e6	fd 02 03	sbc $0302,x			sbc 	XS_Mantissa+2,x
.c8e9	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c8ec	a9 00		lda #$00			lda 	#0
.c8ee	fd 03 03	sbc $0303,x			sbc 	XS_Mantissa+3,x
.c8f1	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c8f4	68		pla				pla
.c8f5	60		rts				rts
.c8f6					FPUToFloat:
.c8f6	48		pha				pha
.c8f7	bd 05 03	lda $0305,x			lda 	XS_Type,x					; exit if already float.
.c8fa	29 0f		and #$0f			and 	#$0F
.c8fc	f0 2d		beq $c92b			beq 	_FPUFExit
.c8fe	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.c900	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c903	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.c905	9d 04 03	sta $0304,x			sta 	XS_Exponent,x 				; x mantissa.
.c908	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.c90b	10 08		bpl $c915			bpl		_FPUFPositive
.c90d	20 d2 c8	jsr $c8d2			jsr 	FPUNegateInteger 			; negate the mantissa
.c910	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.c912	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c915					_FPUFPositive:
.c915	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.c918	1d 01 03	ora $0301,x			ora 	XS_Mantissa+1,x
.c91b	1d 02 03	ora $0302,x			ora 	XS_Mantissa+2,x
.c91e	1d 03 03	ora $0303,x			ora 	XS_Mantissa+3,x
.c921	d0 05		bne $c928			bne 	_FPUFNonZero
.c923	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.c925	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c928					_FPUFNonZero:
.c928	20 2d c9	jsr $c92d			jsr 	FPUNormalise 				; normalise the floating point.
.c92b					_FPUFExit:
.c92b	68		pla				pla
.c92c	60		rts				rts
.c92d					FPUNormalise:
.c92d	48		pha				pha
.c92e	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.c931	70 20		bvs $c953			bvs 	_FPUNExit
.c933	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.c936	f0 16		beq $c94e			beq 	_FPUNSetZero
.c938					_FPUNLoop:
.c938	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.c93b	30 16		bmi $c953			bmi 	_FPUNExit 					; if so, we are normalised.
.c93d	1e 00 03	asl $0300,x			asl 	0+XS_Mantissa+0,x
.c940	3e 01 03	rol $0301,x			rol 	1+XS_Mantissa+0,x
.c943	3e 02 03	rol $0302,x			rol 	2+XS_Mantissa+0,x
.c946	3e 03 03	rol $0303,x			rol 	3+XS_Mantissa+0,x
.c949	de 04 03	dec $0304,x			dec 	XS_Exponent,x 				; decrement exponent
.c94c	d0 ea		bne $c938			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.c94e					_FPUNSetZero:
.c94e	a9 40		lda #$40			lda 	#$40
.c950	9d 05 03	sta $0305,x			sta 	XS_Type,x 					; the result is now zero.
.c953					_FPUNExit:
.c953	68		pla				pla
.c954	60		rts				rts
.c955					FPUToInteger:
.c955	48		pha				pha
.c956	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; if already integer, exit
.c959	29 01		and #$01			and 	#1
.c95b	d0 3e		bne $c99b			bne 	_FPUTOI_Exit
.c95d	3c 05 03	bit $0305,x			bit 	XS_Type,x					; if zero, return zero.
.c960	70 2b		bvs $c98d			bvs 	_FPUTOI_Zero
.c962	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.c965	10 26		bpl $c98d			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.c967	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.c969	b0 37		bcs $c9a2			bcs 	FP_Overflow
.c96b					_FPUToIToInteger:
.c96b	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.c96e	c9 a0		cmp #$a0			cmp 	#128+32
.c970	f0 11		beq $c983			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.c972	fe 04 03	inc $0304,x			inc 	XS_Exponent,X 				; increment Exponent
.c975	5e 03 03	lsr $0303,x			lsr 	3+XS_Mantissa,x
.c978	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.c97b	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.c97e	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.c981	80 e8		bra $c96b			bra 	_FPUToIToInteger 			; keep going.
.c983					_FPUToICheckSign:
.c983	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; check sign
.c986	10 13		bpl $c99b			bpl 	_FPUToI_Exit 				; exit if unsigned.
.c988	20 d2 c8	jsr $c8d2			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.c98b	80 0e		bra $c99b			bra 	_FPUTOI_Exit
.c98d					_FPUTOI_Zero:
.c98d	a9 00		lda #$00			lda 	#0 							; return zero integer.
.c98f	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c992	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c995	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c998	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c99b					_FPUToI_Exit:
.c99b	a9 01		lda #$01			lda 	#1 							; set type to integer
.c99d	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c9a0	68		pla				pla
.c9a1	60		rts				rts
.c9a2					FP_Overflow:
.c9a2	80 fe		bra $c9a2		_error: bra _error
>c9a4	46 6c 6f 61 74 69 6e 67				.text 	"Floating Point overflow",0
>c9ac	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.c9bc					FPUTimes10:
.c9bc	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.c9bf	85 1a		sta $1a				sta 	ZLTemp1+0
.c9c1	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c9c4	85 1b		sta $1b				sta 	ZLTemp1+1
.c9c6	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c9c9	85 1c		sta $1c				sta 	ZLTemp1+2
.c9cb	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c9ce	85 1d		sta $1d				sta 	ZLTemp1+3
.c9d0	20 14 ca	jsr $ca14			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.c9d3	20 14 ca	jsr $ca14			jsr 	_FPUT_LSR_ZLTemp1
.c9d6	18		clc				clc
.c9d7	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.c9da	65 1a		adc $1a				adc 	ZLTemp1+0
.c9dc	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c9df	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c9e2	65 1b		adc $1b				adc 	ZLTemp1+1
.c9e4	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c9e7	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c9ea	65 1c		adc $1c				adc 	ZLTemp1+2
.c9ec	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c9ef	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c9f2	65 1d		adc $1d				adc 	ZLTemp1+3
.c9f4	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c9f7	90 0f		bcc $ca08			bcc 	_FPUTimes10
.c9f9	7e 03 03	ror $0303,x			ror 	3+XS_Mantissa,x
.c9fc	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.c9ff	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.ca02	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.ca05	fe 04 03	inc $0304,x			inc 	XS_Exponent,x				; fix exponent
.ca08					_FPUTimes10:
.ca08	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.ca0b	18		clc				clc
.ca0c	69 03		adc #$03			adc 	#3
.ca0e	9d 04 03	sta $0304,x			sta 	XS_Exponent,x
.ca11	b0 8f		bcs $c9a2			bcs 	FP_Overflow 				; error
.ca13	60		rts				rts
.ca14					_FPUT_LSR_ZLTemp1:
.ca14	46 1d		lsr $1d				lsr 	ZLTemp1+3
.ca16	66 1c		ror $1c				ror 	ZLTemp1+2
.ca18	66 1b		ror $1b				ror 	ZLTemp1+1
.ca1a	66 1a		ror $1a				ror 	ZLTemp1+0
.ca1c	60		rts				rts
.ca1d					FPUScale10A:
.ca1d	5a		phy				phy
.ca1e	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.ca20	f0 3d		beq $ca5f			beq 	_FPUScaleExit
.ca22	da		phx				phx 								; save X
.ca23	e8		inx				inx
.ca24	e8		inx				inx
.ca25	e8		inx				inx
.ca26	e8		inx				inx
.ca27	e8		inx				inx
.ca28	e8		inx				inx
.ca29	a8		tay				tay 								; save power scalar in Y.
.ca2a	a9 00		lda #$00			lda 	#0
.ca2c	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.ca2f	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.ca32	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.ca35	9d 05 03	sta $0305,x			sta 	XS_Type,x
.ca38	a9 80		lda #$80			lda 	#$80
.ca3a	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.ca3d	a9 81		lda #$81			lda 	#$81
.ca3f	9d 04 03	sta $0304,x			sta 	XS_Exponent,x
.ca42	5a		phy				phy 								; save 10^n on stack.
.ca43	c0 00		cpy #$00			cpy 	#0
.ca45	10 05		bpl $ca4c			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.ca47	98		tya				tya
.ca48	49 ff		eor #$ff			eor 	#$FF
.ca4a	1a		inc a				inc 	a
.ca4b	a8		tay				tay
.ca4c					_FPUSAbs:
.ca4c	20 bc c9	jsr $c9bc			jsr 	FPUTimes10
.ca4f	88		dey				dey
.ca50	d0 fa		bne $ca4c			bne 	_FPUSAbs 					; tos is now 10^|AC|
.ca52	68		pla				pla 								; restore count in A
.ca53	fa		plx				plx 								; restore X pointing to number to scale.
.ca54	0a		asl a				asl 	a
.ca55	b0 05		bcs $ca5c			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.ca57	20 44 c7	jsr $c744			jsr 	FPMultiply 					; if clear multiply.
.ca5a	80 03		bra $ca5f			bra		_FPUScaleExit
.ca5c					_FPUSDivide:
.ca5c	20 bc c6	jsr $c6bc			jsr 	FPDivide
.ca5f					_FPUScaleExit:
.ca5f	7a		ply				ply
.ca60	60		rts				rts
.ca61					FPUCopyToNext:
.ca61	a0 06		ldy #$06			ldy 		#6
.ca63	da		phx				phx
.ca64					_FPUCopy1:
.ca64	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x
.ca67	9d 06 03	sta $0306,x			sta 	XS2_Mantissa,x
.ca6a	e8		inx				inx
.ca6b	88		dey				dey
.ca6c	d0 f6		bne $ca64			bne 	_FPUCopy1
.ca6e	fa		plx				plx
.ca6f	60		rts				rts
.ca70					FPUCopyFromNext:
.ca70	a0 06		ldy #$06			ldy 		#6
.ca72	da		phx				phx
.ca73					_FPUCopy1:
.ca73	bd 06 03	lda $0306,x			lda 	XS2_Mantissa,x
.ca76	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.ca79	e8		inx				inx
.ca7a	88		dey				dey
.ca7b	d0 f6		bne $ca73			bne 	_FPUCopy1
.ca7d	fa		plx				plx
.ca7e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.ca7f					FPToString:
.ca7f	48		pha				pha
.ca80	5a		phy				phy
.ca81	3c 05 03	bit $0305,x			bit 		XS_Type,x 				; check zero flag
.ca84	50 0a		bvc $ca90			bvc 		_FPTSIsFloat 			; if zero,
.ca86					_FPTSZero:
.ca86	a9 30		lda #$30			lda 		#"0"
.ca88	20 63 cc	jsr $cc63			jsr 		ITSOutputCharacter
.ca8b					_FPTSExit:
.ca8b	7a		ply				ply
.ca8c	68		pla				pla
.ca8d	60		rts				rts
.ca8e	80 fb		bra $ca8b			bra 		_FPTSExit
.ca90					_FPTSIsFloat:
.ca90	bd 05 03	lda $0305,x			lda 		XS_Type,x 				; is it signed ?
.ca93	10 0a		bpl $ca9f			bpl 		_FPTSNotSigned
.ca95	a9 00		lda #$00			lda 		#0 						; clear sign flag
.ca97	9d 05 03	sta $0305,x			sta 		XS_Type,x
.ca9a	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.ca9c	20 63 cc	jsr $cc63			jsr 		ITSOutputCharacter
.ca9f					_FPTSNotSigned:
.ca9f	bd 04 03	lda $0304,x			lda 		XS_Exponent,x
.caa2	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.caa4	b0 09		bcs $caaf			bcs 		_FPTSExponent
.caa6	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.caa8	90 05		bcc $caaf			bcc 		_FPTSExponent 			;
.caaa					_FPTSStandard:
.caaa	20 f3 ca	jsr $caf3			jsr 		FPTOutputBody 			; output the body.
.caad	80 dc		bra $ca8b			bra 		_FPTSExit
.caaf					_FPTSExponent:
.caaf	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.cab1	8d 2e 04	sta $042e			sta 		ExpCount
.cab4					_FPTSExponentLoop:
.cab4	bd 04 03	lda $0304,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.cab7	10 0e		bpl $cac7			bpl 		_FPTSTimes
.cab9	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.cabb	90 14		bcc $cad1			bcc 		_FPTSScaledToExp
.cabd	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.cabf	20 1d ca	jsr $ca1d			jsr 		FPUScale10A
.cac2	ee 2e 04	inc $042e			inc 		ExpCount
.cac5	80 ed		bra $cab4			bra 		_FPTSExponentLoop
.cac7					_FPTSTimes:
.cac7	a9 01		lda #$01			lda 		#1
.cac9	20 1d ca	jsr $ca1d			jsr 		FPUScale10A
.cacc	ce 2e 04	dec $042e			dec 		ExpCount
.cacf	80 e3		bra $cab4			bra 		_FPTSExponentLoop
.cad1					_FPTSScaledToExp:
.cad1	20 f3 ca	jsr $caf3			jsr 		FPTOutputBody 			; output the body.
.cad4	a9 65		lda #$65			lda 		#"e"					; output E
.cad6	20 63 cc	jsr $cc63			jsr 		ITSOutputCharacter
.cad9	ad 2e 04	lda $042e			lda 		ExpCount 				; get the exponent
.cadc	9d 00 03	sta $0300,x			sta 		XS_Mantissa,x
.cadf	29 80		and #$80			and 		#$80 					; sign extend it
.cae1	f0 02		beq $cae5			beq 		_FPTSSExt
.cae3	a9 ff		lda #$ff			lda 		#$FF
.cae5					_FPTSSExt:
.cae5	9d 01 03	sta $0301,x			sta 		XS_Mantissa+1,x
.cae8	9d 02 03	sta $0302,x			sta 		XS_Mantissa+2,x
.caeb	9d 03 03	sta $0303,x			sta 		XS_Mantissa+3,x
.caee	20 c7 cb	jsr $cbc7			jsr 		INTToString 			; output the exponent.
.caf1	80 98		bra $ca8b			bra			_FPTSExit 				; and exit.
.caf3					FPTOutputBody:
.caf3	20 61 ca	jsr $ca61			jsr 		FPUCopyToNext 			; copy to next slot.
.caf6	20 55 c9	jsr $c955			jsr 		FPUToInteger 			; convert to an integer
.caf9	20 c7 cb	jsr $cbc7			jsr 		INTToString 			; output the main integer part.
.cafc	20 70 ca	jsr $ca70			jsr 		FPUCopyFromNext 		; get the fractional part back.
.caff	20 e1 c7	jsr $c7e1			jsr 		FPFractionalPart 		; get the decimal part.
.cb02	3c 05 03	bit $0305,x			bit 		XS_Type,x 				; any fractional part.
.cb05	70 3e		bvs $cb45			bvs 		_FPTOExit 				; if not, exit now.
.cb07	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.cb09	20 63 cc	jsr $cc63			jsr 		ITSOutputCharacter
.cb0c					_FPOutLoop:
.cb0c	3c 05 03	bit $0305,x			bit 		XS_Type,x 				; finally reached zero.
.cb0f	70 1e		bvs $cb2f			bvs 		_FPStripZeros 			; strip trailing zeros
.cb11	20 bc c9	jsr $c9bc			jsr 		FPUTimes10 				; multiply by 10
.cb14	20 61 ca	jsr $ca61			jsr 		FPUCopyToNext			; copy to next slot.
.cb17	20 55 c9	jsr $c955			jsr 		FPUToInteger 			; convert to integer
.cb1a	bd 00 03	lda $0300,x			lda 		XS_Mantissa+0,x 		; print digit.
.cb1d	09 30		ora #$30			ora 		#"0"
.cb1f	20 63 cc	jsr $cc63			jsr 		ITSOutputCharacter
.cb22	20 70 ca	jsr $ca70			jsr 		FPUCopyFromNext 		; get it back
.cb25	20 e1 c7	jsr $c7e1			jsr 		FPFractionalPart 		; get fractional part
.cb28	ad 20 04	lda $0420			lda 		NumBufX 				; done 11 characters yet ?
.cb2b	c9 0b		cmp #$0b			cmp 	 	#11
.cb2d	90 dd		bcc $cb0c			bcc 		_FPOutLoop 				; if so, keep going till zero.
.cb2f					_FPStripZeros:
.cb2f	ac 20 04	ldy $0420			ldy 		NumBufX 				; strip trailing zeros.
.cb32					_FPStripLoop:
.cb32	88		dey				dey 								; back one, if at start then no strip
.cb33	f0 10		beq $cb45			beq 		_FPToExit
.cb35	b9 00 04	lda $0400,y			lda 		Num_Buffer,y 			; keep going if "0"
.cb38	c9 30		cmp #$30			cmp 		#"0"
.cb3a	f0 f6		beq $cb32			beq 		_FPStripLoop
.cb3c	c8		iny				iny
.cb3d	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.cb3f	99 00 04	sta $0400,y			sta 		Num_Buffer,y
.cb42	8c 20 04	sty $0420			sty 		NumBufX 				; update position.
.cb45					_FPTOExit:
.cb45	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.cb46					FPFromString:
.cb46	48		pha				pha 								; push A
.cb47	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.cb49	c9 2e		cmp #$2e			cmp 	#"."
.cb4b	f0 03		beq $cb50			beq	 	_FPFIsDecimal
.cb4d	4c b3 cb	jmp $cbb3			jmp 	_FPFNotDecimal
.cb50					_FPFIsDecimal:
.cb50	c8		iny				iny 								; consume the decimal.
.cb51	20 f6 c8	jsr $c8f6			jsr 	FPUToFloat 					; convert the integer to float.
.cb54	da		phx				phx 								; save X.
.cb55	5a		phy				phy 								; save decimal start position
.cb56	e8		inx				inx
.cb57	e8		inx				inx
.cb58	e8		inx				inx
.cb59	e8		inx				inx
.cb5a	e8		inx				inx
.cb5b	e8		inx				inx
.cb5c	20 7b cc	jsr $cc7b			jsr 	INTFromStringY 				; get the part after the DP.
.cb5f	20 f6 c8	jsr $c8f6			jsr 	FPUToFloat 					; convert that to a float.
.cb62	68		pla				pla 								; calculate - chars consumed.
.cb63	8c 2d 04	sty $042d			sty 	ExpTemp
.cb66	38		sec				sec
.cb67	ed 2d 04	sbc $042d			sbc 	ExpTemp 					; this is the shift amount
.cb6a	20 1d ca	jsr $ca1d			jsr 	FPUScale10A 				; scale it by 10^AC
.cb6d	fa		plx				plx 								; restore original X
.cb6e	20 d9 c5	jsr $c5d9			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.cb71	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.cb73	c9 45		cmp #$45			cmp 	#"E"
.cb75	f0 04		beq $cb7b			beq 	_FPFExponent
.cb77	c9 65		cmp #$65			cmp 	#"e"
.cb79	d0 38		bne $cbb3			bne 	_FPFNotDecimal 				; no, then exit normally.
.cb7b					_FPFExponent:
.cb7b	c8		iny				iny 								; skip over E symbol.
.cb7c	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.cb7e	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.cb80	d0 01		bne $cb83			bne 	_FPFGotSign
.cb82	c8		iny				iny 								; if it was - skip over it.
.cb83					_FPFGotSign:
.cb83	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.cb84	da		phx				phx
.cb85	e8		inx				inx
.cb86	e8		inx				inx
.cb87	e8		inx				inx
.cb88	e8		inx				inx
.cb89	e8		inx				inx
.cb8a	e8		inx				inx
.cb8b	20 7b cc	jsr $cc7b			jsr 	INTFromStringY 				; get the exponent
.cb8e	fa		plx				plx 								; restore X.
.cb8f	bd 07 03	lda $0307,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.cb92	1d 09 03	ora $0309,x			ora 	XS2_Mantissa+3,x
.cb95	1d 08 03	ora $0308,x			ora 	XS2_Mantissa+2,x
.cb98	d0 1b		bne $cbb5			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.cb9a	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.cb9d	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.cb9f	b0 14		bcs $cbb5			bcs 	_FPFXOverflow
.cba1	68		pla				pla 								; get direction
.cba2	d0 09		bne $cbad			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.cba4	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.cba7	49 ff		eor #$ff			eor 	#$FF
.cba9	1a		inc a				inc 	a
.cbaa	9d 06 03	sta $0306,x			sta 	XS2_Mantissa+0,x
.cbad					_FPFXScale:
.cbad	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.cbb0	20 1d ca	jsr $ca1d			jsr 	FPUScale10A 				; scale by the exponent.
.cbb3					_FPFNotDecimal:
.cbb3	68		pla				pla
.cbb4	60		rts				rts
.cbb5					_FPFXOverflow:
.cbb5	20 09 c4	jsr $c409			jsr 	ERR_Handler
>cbb8	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>cbc0	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.cbc7					INTToString:
.cbc7	48		pha				pha
.cbc8	5a		phy				phy
.cbc9	bd 03 03	lda $0303,x			lda 		XS_Mantissa+3,x 		; check -ve
.cbcc	10 08		bpl $cbd6			bpl 		_ITSNotMinus
.cbce	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.cbd0	20 63 cc	jsr $cc63			jsr 		ITSOutputCharacter
.cbd3	20 d2 c8	jsr $c8d2			jsr 		FPUNegateInteger
.cbd6					_ITSNotMinus:
.cbd6	a9 00		lda #$00			lda 		#0 						; X is offset in table.
.cbd8	8d 21 04	sta $0421			sta 		NumSuppress 			; clear the suppression flag.
.cbdb	a0 00		ldy #$00			ldy 		#0 						; Y is index into dword subtraction table.
.cbdd					_ITSNextSubtractor:
.cbdd	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.cbdf	8d 22 04	sta $0422			sta 		NumConvCount
.cbe2					_ITSSubtract:
.cbe2	38		sec				sec
.cbe3	bd 00 03	lda $0300,x			lda 		XS_Mantissa,x 			; subtract number and push on stack
.cbe6	f9 3f cc	sbc $cc3f,y			sbc 		_ITSSubtractors+0,y
.cbe9	48		pha				pha
.cbea	bd 01 03	lda $0301,x			lda 		XS_Mantissa+1,x
.cbed	f9 40 cc	sbc $cc40,y			sbc 		_ITSSubtractors+1,y
.cbf0	48		pha				pha
.cbf1	bd 02 03	lda $0302,x			lda 		XS_Mantissa+2,x
.cbf4	f9 41 cc	sbc $cc41,y			sbc 		_ITSSubtractors+2,y
.cbf7	48		pha				pha
.cbf8	bd 03 03	lda $0303,x			lda 		XS_Mantissa+3,x
.cbfb	f9 42 cc	sbc $cc42,y			sbc 		_ITSSubtractors+3,y
.cbfe	90 14		bcc $cc14			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.cc00	9d 03 03	sta $0303,x			sta 		XS_Mantissa+3,x 		; save subtract off stack
.cc03	68		pla				pla
.cc04	9d 02 03	sta $0302,x			sta 		XS_Mantissa+2,x
.cc07	68		pla				pla
.cc08	9d 01 03	sta $0301,x			sta 		XS_Mantissa+1,x
.cc0b	68		pla				pla
.cc0c	9d 00 03	sta $0300,x			sta 		XS_Mantissa+0,x
.cc0f	ee 22 04	inc $0422			inc 		NumConvCount 			; bump count.
.cc12	80 ce		bra $cbe2			bra 		_ITSSubtract 			; go round again.
.cc14					_ITSCantSubtract:
.cc14	68		pla				pla 								; throw away interim answers
.cc15	68		pla				pla
.cc16	68		pla				pla
.cc17	ad 22 04	lda $0422			lda 		NumConvCount 			; if not zero then no suppression check
.cc1a	c9 30		cmp #$30			cmp 		#"0"
.cc1c	d0 05		bne $cc23			bne 		_ITSOutputDigit
.cc1e	ad 21 04	lda $0421			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.cc21	10 09		bpl $cc2c			bpl 		_ITSGoNextSubtractor
.cc23					_ITSOutputDigit:
.cc23	ce 21 04	dec $0421			dec 		NumSuppress 			; suppression check will be non-zero.
.cc26	ad 22 04	lda $0422			lda 		NumConvCount 			; count of subtractions
.cc29	20 63 cc	jsr $cc63			jsr 		ITSOutputCharacter 		; output it.
.cc2c					_ITSGoNextSubtractor:
.cc2c	c8		iny				iny 								; next dword
.cc2d	c8		iny				iny
.cc2e	c8		iny				iny
.cc2f	c8		iny				iny
.cc30	c0 24		cpy #$24			cpy 		#_ITSSubtractorsEnd-_ITSSubtractors
.cc32	d0 a9		bne $cbdd			bne 		_ITSNextSubtractor 		; do all the subtractors.
.cc34	bd 00 03	lda $0300,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.cc37	09 30		ora #$30			ora 		#"0"
.cc39	20 63 cc	jsr $cc63			jsr 		ITSOutputCharacter
.cc3c	7a		ply				ply 								; and exit
.cc3d	68		pla				pla
.cc3e	60		rts				rts
.cc3f					_ITSSubtractors:
>cc3f	00 ca 9a 3b					.dword 		1000000000
>cc43	00 e1 f5 05					.dword 		100000000
>cc47	80 96 98 00					.dword 		10000000
>cc4b	40 42 0f 00					.dword 		1000000
>cc4f	a0 86 01 00					.dword 		100000
>cc53	10 27 00 00					.dword 		10000
>cc57	e8 03 00 00					.dword 		1000
>cc5b	64 00 00 00					.dword 		100
>cc5f	0a 00 00 00					.dword 		10
.cc63					_ITSSubtractorsEnd:
.cc63					ITSOutputCharacter:
.cc63	48		pha				pha
.cc64	da		phx				phx
.cc65	ae 20 04	ldx $0420			ldx 	NumBufX 					; save digit
.cc68	9d 00 04	sta $0400,x			sta 	Num_Buffer,x
.cc6b	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.cc6d	9d 01 04	sta $0401,x			sta 	Num_Buffer+1,x
.cc70	ee 20 04	inc $0420			inc 	NumBufX						; bump pointer.
.cc73	fa		plx				plx
.cc74	68		pla				pla
.cc75	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.cc76					IntFromString:
.cc76	a0 00		ldy #$00			ldy 	#0
.cc78	8c 2d 04	sty $042d			sty 	ExpTemp 					; this is the converted digit count.
.cc7b					IntFromStringY:
.cc7b	48		pha				pha
.cc7c	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.cc7e	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.cc81	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.cc84	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cc87	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.cc8a	a9 01		lda #$01			lda 	#1
.cc8c	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cc8f					_IFSLoop:
.cc8f	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.cc91	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.cc93	90 60		bcc $ccf5			bcc 	_IFSExit
.cc95	c9 3a		cmp #$3a			cmp 	#"9"+1
.cc97	b0 5c		bcs $ccf5			bcs 	_IFSExit
.cc99	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.cc9c	c9 0c		cmp #$0c			cmp 	#12
.cc9e	b0 5f		bcs $ccff			bcs 	_IFSOverflow
.cca0	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.cca3	48		pha				pha
.cca4	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.cca7	48		pha				pha
.cca8	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.ccab	48		pha				pha
.ccac	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.ccaf	48		pha				pha
.ccb0	20 14 cd	jsr $cd14			jsr 	IFSX1ShiftLeft 				; double
.ccb3	20 14 cd	jsr $cd14			jsr 	IFSX1ShiftLeft 				; x 4
.ccb6	18		clc				clc 								; add saved value x 5
.ccb7	68		pla				pla
.ccb8	7d 00 03	adc $0300,x			adc 	XS_Mantissa+0,x
.ccbb	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.ccbe	68		pla				pla
.ccbf	7d 01 03	adc $0301,x			adc 	XS_Mantissa+1,x
.ccc2	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.ccc5	68		pla				pla
.ccc6	7d 02 03	adc $0302,x			adc 	XS_Mantissa+2,x
.ccc9	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cccc	68		pla				pla
.cccd	7d 03 03	adc $0303,x			adc 	XS_Mantissa+3,x
.ccd0	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.ccd3	20 14 cd	jsr $cd14			jsr 	IFSX1ShiftLeft 				; x 10
.ccd6	ee 2d 04	inc $042d			inc 	ExpTemp 					; bump count of digits processed.
.ccd9	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.ccdb	29 0f		and #$0f			and 	#15
.ccdd	c8		iny				iny
.ccde	7d 00 03	adc $0300,x			adc 	XS_Mantissa+0,x
.cce1	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.cce4	90 a9		bcc $cc8f			bcc 	_IFSLoop
.cce6	fe 01 03	inc $0301,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.cce9	d0 a4		bne $cc8f			bne 	_IFSLoop
.cceb	fe 02 03	inc $0302,x			inc 	XS_Mantissa+2,x
.ccee	d0 9f		bne $cc8f			bne 	_IFSLoop
.ccf0	fe 03 03	inc $0303,x			inc 	XS_Mantissa+3,x
.ccf3	80 9a		bra $cc8f			bra 	_IFSLoop
.ccf5					_IFSExit:
.ccf5	98		tya				tya 								; get offset
.ccf6					_IFSOkay:
.ccf6	38		sec				sec
.ccf7	ad 2d 04	lda $042d			lda 	ExpTemp
.ccfa	f0 01		beq $ccfd			beq 	_IFSSkipFail
.ccfc	18		clc				clc
.ccfd					_IFSSkipFail:
.ccfd	68		pla				pla 								; and exit.
.ccfe	60		rts				rts
.ccff					_IFSOverflow:
.ccff	20 09 c4	jsr $c409			jsr 	ERR_Handler
>cd02	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>cd0a	20 6f 76 65 72 66 6c 6f 77 00
.cd14					IFSX1ShiftLeft:
.cd14	1e 00 03	asl $0300,x			asl 	0+XS_Mantissa,x
.cd17	3e 01 03	rol $0301,x			rol 	1+XS_Mantissa,x
.cd1a	3e 02 03	rol $0302,x			rol 	2+XS_Mantissa,x
.cd1d	3e 03 03	rol $0303,x			rol 	3+XS_Mantissa,x
.cd20	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.cd21					TIM_Error:
.cd21	20 31 c2	jsr $c231			jsr 	IFT_UpLine 					; go up one line.
.cd24	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.cd26	80 02		bra $cd2a			bra 	TIM_ShowPrompt
.cd28					TIM_NewCommand:
.cd28	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.cd2a					TIM_ShowPrompt:
.cd2a	20 3d c2	jsr $c23d			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.cd2d	20 f5 c2	jsr $c2f5			jsr 	IFT_ReadLine	 			; get character, go to next line
.cd30	20 57 c2	jsr $c257			jsr 	IFT_NewLine					; go to next line.
.cd33	86 10		stx $10				stx 	zTemp1 						; save line read address
.cd35	84 11		sty $11				sty 	zTemp1+1
.cd37	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.cd39	b1 10		lda ($10),y			lda 	(zTemp1),y
.cd3b	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.cd3d	d0 01		bne $cd40			bne 	TIM_NotDot
.cd3f	c8		iny				iny
.cd40					TIM_NotDot:
.cd40	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.cd42	c9 52		cmp #$52			cmp 	#"R"						; show registers
.cd44	f0 6b		beq $cdb1			beq 	TIM_ShowRegisters
.cd46	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.cd48	f0 12		beq $cd5c			beq 	TIM_ShowMemory
.cd4a	c9 47		cmp #$47			cmp 	#"G"						; execute
.cd4c	f0 49		beq $cd97			beq 	TIM_Execute
.cd4e	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.cd50	f0 07		beq $cd59			beq 	TIM_GoLoadMemory
.cd52	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.cd54	d0 cb		bne $cd21			bne 	TIM_Error
.cd56	4c d4 ce	jmp $ced4			jmp 	TIM_UpdateRegisters
.cd59					TIM_GoLoadMemory:
.cd59	4c 04 cf	jmp $cf04			jmp 	TIM_LoadMemory
.cd5c					TIM_ShowMemory:
.cd5c	20 50 ce	jsr $ce50			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.cd5f	b0 c0		bcs $cd21			bcs 	TIM_Error
.cd61	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.cd63	85 12		sta $12				sta 	zTemp2
.cd65	a5 15		lda $15				lda 	zTemp3+1
.cd67	85 13		sta $13				sta 	zTemp2+1
.cd69	20 50 ce	jsr $ce50			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.cd6c	90 08		bcc $cd76			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.cd6e	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.cd70	85 14		sta $14				sta 	zTemp3
.cd72	a5 13		lda $13				lda 	zTemp2+1
.cd74	85 15		sta $15				sta 	zTemp3+1
.cd76					_TIMSM_Start:
.cd76	20 28 ce	jsr $ce28			jsr 	TIM_WriteLine 				; write one line of hex out
.cd79	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.cd7b	18		clc				clc
.cd7c	69 10		adc #$10			adc 	#16
.cd7e	85 12		sta $12				sta 	zTemp2
.cd80	90 02		bcc $cd84			bcc 	_TIMSM_NoCarry
.cd82	e6 13		inc $13				inc 	zTemp2+1
.cd84					_TIMSM_NoCarry:
.cd84	20 dc c3	jsr $c3dc			jsr 	IF_CheckBreak 				; check CTL+C
.cd87	d0 0b		bne $cd94			bne 	_TIMSM_Ends 				; if pressed break out.
.cd89	38		sec				sec 								; check past the end address in zTemp3
.cd8a	a5 14		lda $14				lda 	zTemp3
.cd8c	e5 12		sbc $12				sbc 	zTemp2
.cd8e	a5 15		lda $15				lda 	zTemp3+1
.cd90	e5 13		sbc $13				sbc 	zTemp2+1
.cd92	10 e2		bpl $cd76			bpl 	_TIMSM_Start
.cd94					_TIMSM_Ends:
.cd94	4c 28 cd	jmp $cd28			jmp 	TIM_NewCommand
.cd97					TIM_Execute:
.cd97	20 50 ce	jsr $ce50			jsr 	TIM_GetHex 					; get the execute address
.cd9a	b0 85		bcs $cd21			bcs 	TIM_Error 					; not legitimate
.cd9c	ae 2c 04	ldx $042c			ldx 	TIM_SP 						; set up SP
.cd9f	9a		txs				txs
.cda0	ad 27 04	lda $0427			lda 	TIM_SR 						; Status for PLP
.cda3	48		pha				pha
.cda4	ad 28 04	lda $0428			lda 	TIM_A 						; restore AXYZ
.cda7	ae 29 04	ldx $0429			ldx 	TIM_X
.cdaa	ac 2a 04	ldy $042a			ldy 	TIM_Y
.cdad	28		plp				plp 								; and PS Byte.
.cdae	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.cdb1					TIM_Start:
.cdb1					TIM_ShowRegisters:
.cdb1	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.cdb4	8d 26 04	sta $0426			sta 	TIM_IRQ+1
.cdb7	ad ff ff	lda $ffff			lda 	$FFFF
.cdba	8d 25 04	sta $0425			sta 	TIM_IRQ
.cdbd	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.cdbf					_TIMSR_Text:
.cdbf	bd ef cd	lda $cdef,x			lda 	_TIMSR_Label,x
.cdc2	20 3d c2	jsr $c23d			jsr 	IFT_PrintCharacter
.cdc5	e8		inx				inx
.cdc6	e0 20		cpx #$20			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.cdc8	d0 f5		bne $cdbf			bne 	_TIMSR_Text
.cdca	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.cdcc					_TIMSR_Skip:
.cdcc	e8		inx				inx
.cdcd					_TIMSR_LoopSpace:
.cdcd	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.cdcf	b0 04		bcs $cdd5			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.cdd1	8a		txa				txa
.cdd2	4a		lsr a				lsr 	a
.cdd3	b0 05		bcs $cdda			bcs 	_TIMSR_NoSpace
.cdd5					_TIMSR_Space:
.cdd5	a9 20		lda #$20			lda 	#" "
.cdd7	20 3d c2	jsr $c23d			jsr 	IFT_PrintCharacter
.cdda					_TIMSR_NoSpace:
.cdda	bd 23 04	lda $0423,x			lda 	TIM_PC,x 					; output hex value.
.cddd	20 0f ce	jsr $ce0f			jsr 	TIM_WriteHex
.cde0	e8		inx				inx
.cde1	e0 08		cpx #$08			cpx 	#TIM_Z-TIM_PC
.cde3	f0 e7		beq $cdcc			beq 	_TIMSR_Skip
.cde5	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.cde7	d0 e4		bne $cdcd			bne 	_TimSR_LoopSpace
.cde9	20 57 c2	jsr $c257			jsr 	IFT_NewLine 				; new line
.cdec	4c 28 cd	jmp $cd28			jmp	 	TIM_NewCommand 				; new command.
.cdef					_TIMSR_Label:
>cdef	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>cdf7	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>ce07	52
>ce08	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.ce0f					_TIMSR_LabelEnd:
.ce0f					TIM_WriteHex:
.ce0f	48		pha				pha 								; save A
.ce10	4a		lsr a				lsr 	a 							; shift MSB->LSB
.ce11	4a		lsr a				lsr 	a
.ce12	4a		lsr a				lsr 	a
.ce13	4a		lsr a				lsr 	a
.ce14	20 18 ce	jsr $ce18			jsr 	_TIMWH_Nibble 				; print MSB
.ce17	68		pla				pla 								; restore and print LSB
.ce18					_TIMWH_Nibble:
.ce18	48		pha				pha
.ce19	29 0f		and #$0f			and 	#15 						; mask out
.ce1b	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.ce1d	90 02		bcc $ce21			bcc 	_TIMWHNoLetter
.ce1f	69 06		adc #$06			adc 	#6
.ce21					_TIMWHNoLetter:
.ce21	69 30		adc #$30			adc 	#48
.ce23	20 3d c2	jsr $c23d			jsr 	IFT_PrintCharacter 			; print it out.
.ce26	68		pla				pla
.ce27	60		rts				rts
.ce28					TIM_WriteLine:
.ce28	a9 2e		lda #$2e			lda 	#"." 						; prompt
.ce2a	20 3d c2	jsr $c23d			jsr 	IFT_PrintCharacter
.ce2d	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.ce2f	20 3d c2	jsr $c23d			jsr 	IFT_PrintCharacter
.ce32	a5 13		lda $13				lda 	zTemp2+1 					; write address
.ce34	20 0f ce	jsr $ce0f			jsr 	TIM_WriteHex
.ce37	a5 12		lda $12				lda 	zTemp2
.ce39	20 0f ce	jsr $ce0f			jsr 	TIM_WriteHex
.ce3c	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.ce3e					_TIMWL_Loop:
.ce3e	a9 20		lda #$20			lda 	#" "
.ce40	20 3d c2	jsr $c23d			jsr 	IFT_PrintCharacter
.ce43	b1 12		lda ($12),y			lda 	(zTemp2),y
.ce45	20 0f ce	jsr $ce0f			jsr 	TIM_WriteHex
.ce48	c8		iny				iny
.ce49	c0 10		cpy #$10			cpy 	#16
.ce4b	d0 f1		bne $ce3e			bne 	_TIMWL_Loop
.ce4d	4c 57 c2	jmp $c257			jmp 	IFT_NewLine 				; new line and exit
.ce50					TIM_GetHex:
.ce50	c8		iny				iny
.ce51	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.ce53	c9 20		cmp #$20			cmp 	#32
.ce55	f0 f9		beq $ce50			beq 	TIM_GetHex
.ce57	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.ce59	f0 f5		beq $ce50			beq 	TIM_GetHex
.ce5b	20 84 ce	jsr $ce84			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.ce5e	b0 23		bcs $ce83			bcs 	_TIMGH_Exit					; if first bad then exit now.
.ce60	a9 00		lda #$00			lda 	#0 							; zero result
.ce62	85 14		sta $14				sta 	zTemp3
.ce64	85 15		sta $15				sta 	zTemp3+1
.ce66					_TIM_GHLoop:
.ce66	20 84 ce	jsr $ce84			jsr 	TIM_GetHexCharacter 		; get next character
.ce69	b0 17		bcs $ce82			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.ce6b	c8		iny				iny 								; skip over it.
.ce6c	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.ce6e	26 15		rol $15				rol 	zTemp3+1
.ce70	06 14		asl $14				asl 	zTemp3 						; now x 2
.ce72	26 15		rol $15				rol 	zTemp3+1
.ce74	06 14		asl $14				asl 	zTemp3						; now x 4
.ce76	26 15		rol $15				rol 	zTemp3+1
.ce78	06 14		asl $14				asl 	zTemp3 						; now x 8
.ce7a	26 15		rol $15				rol 	zTemp3+1
.ce7c	05 14		ora $14				ora 	zTemp3 						; OR result in
.ce7e	85 14		sta $14				sta 	zTemp3
.ce80	80 e4		bra $ce66			bra 	_TIM_GHLoop 				; loop round again.
.ce82					_TIMGH_Okay:
.ce82	18		clc				clc
.ce83					_TIMGH_Exit:
.ce83	60		rts				rts
.ce84					TIM_GetHexCharacter:
.ce84	b1 10		lda ($10),y			lda 	(zTemp1),y
.ce86	38		sec				sec
.ce87	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.ce89	90 0e		bcc $ce99			bcc 	_TIM_GHCFail
.ce8b	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.ce8d	90 0b		bcc $ce9a			bcc 	_TIM_GHCExit
.ce8f	c9 11		cmp #$11			cmp 	#65-48						; < A
.ce91	90 06		bcc $ce99			bcc		_TIM_GHCFail
.ce93	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.ce95	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.ce97	90 01		bcc $ce9a			bcc		_TIM_GHCExit
.ce99					_TIM_GHCFail:
.ce99	38		sec				sec
.ce9a					_TIM_GHCExit:
.ce9a	60		rts				rts
.ce9b					TIM_BreakVector:
.ce9b	da		phx				phx									; save X/A on stack
.ce9c	48		pha				pha
.ce9d	ba		tsx				tsx 								; X points to S
.ce9e	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.cea1	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.cea3	d0 03		bne $cea8			bne 	_TIMBreak					; if set, it's BRK
.cea5	68		pla				pla 								; abandon routine.
.cea6	fa		plx				plx
.cea7	40		rti				rti
.cea8					_TIMBreak:
.cea8	68		pla				pla 								; save A X Y and maybe Z
.cea9	8d 28 04	sta $0428			sta 	TIM_A
.ceac	fa		plx				plx
.cead	8e 29 04	stx $0429			stx 	TIM_X
.ceb0	8c 2a 04	sty $042a			sty 	TIM_Y
.ceb3	68		pla				pla 								; get Status Register
.ceb4	8d 27 04	sta $0427			sta 	TIM_SR
.ceb7	68		pla				pla
.ceb8	8d 24 04	sta $0424			sta 	TIM_PC+1 					; save calling address
.cebb	68		pla				pla
.cebc	8d 23 04	sta $0423			sta 	TIM_PC 						; high byte
.cebf	ad 24 04	lda $0424			lda 	TIM_PC+1 					; dec PC to point right.
.cec2	d0 03		bne $cec7			bne 	_TIMDecrement 				; brk bumps it.
.cec4	ce 23 04	dec $0423			dec 	TIM_PC
.cec7					_TIMDecrement:
.cec7	ce 24 04	dec $0424			dec 	TIM_PC+1
.ceca	ba		tsx				tsx 								; and copy SP
.cecb	8e 2c 04	stx $042c			stx 	TIM_SP
.cece	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.ced0	9a		txs				txs
.ced1	4c b1 cd	jmp $cdb1			jmp 	TIM_Start 					; and start up TIM monitor.
.ced4					TIM_UpdateRegisters:
.ced4	20 50 ce	jsr $ce50			jsr 	TIM_GetHex 					; PC
.ced7	b0 28		bcs $cf01			bcs 	_TIMURFail
.ced9	a5 14		lda $14				lda 	zTemp3
.cedb	8d 24 04	sta $0424			sta 	Tim_PC+1
.cede	a5 15		lda $15				lda 	zTemp3+1
.cee0	8d 23 04	sta $0423			sta 	Tim_PC
.cee3	20 50 ce	jsr $ce50			jsr 	TIM_GetHex 					; ignore IRQ
.cee6	b0 19		bcs $cf01			bcs 	_TIMURFail
.cee8	a2 00		ldx #$00			ldx 	#0
.ceea					_TIM_URLoop:
.ceea	e0 04		cpx #$04			cpx 	#Tim_Z-Tim_SR
.ceec	d0 01		bne $ceef			bne 	_TIM_1
.ceee	e8		inx				inx
.ceef					_TIM_1:
.ceef	20 50 ce	jsr $ce50			jsr 	TIM_GetHex 					; registers
.cef2	b0 0d		bcs $cf01			bcs 	_TIMURFail
.cef4	a5 14		lda $14				lda 	zTemp3
.cef6	9d 27 04	sta $0427,x			sta 	Tim_SR,x
.cef9	e8		inx				inx
.cefa	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.cefc	d0 ec		bne $ceea			bne 	_TIM_URLoop
.cefe	4c 28 cd	jmp $cd28			jmp 	TIM_NewCommand
.cf01					_TIMURFail:
.cf01	4c 21 cd	jmp $cd21			jmp 	TIM_Error
.cf04					TIM_LoadMemory:
.cf04	20 50 ce	jsr $ce50			jsr 	TIM_GetHex 					; target address => zTemp2
.cf07	a5 14		lda $14				lda 	zTemp3
.cf09	85 12		sta $12				sta 	zTemp2
.cf0b	a5 15		lda $15				lda 	zTemp3+1
.cf0d	85 13		sta $13				sta 	zTemp2+1
.cf0f					_TIM_LMLoop:
.cf0f	20 50 ce	jsr $ce50			jsr 	TIM_GetHex 					; next byte ?
.cf12	b0 0e		bcs $cf22			bcs 	_TIMLMDone 					; no more
.cf14	a2 00		ldx #$00			ldx 	#0							; write out.
.cf16	a5 14		lda $14				lda 	zTemp3
.cf18	81 12		sta ($12,x)			sta 	(zTemp2,x)
.cf1a	e6 12		inc $12				inc 	zTemp2 						; bump address
.cf1c	d0 f1		bne $cf0f			bne 	_TIM_LMLoop
.cf1e	e6 13		inc $13				inc 	zTemp2+1
.cf20	80 ed		bra $cf0f			bra 	_TIM_LMLoop
.cf22					_TIMLMDone:
.cf22	4c 28 cd	jmp $cd28			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Return to file: basic.asm

>cf25	02						.byte 	2
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	ec c1						.word 	StartROM
>fffe	9b ce					.word TIM_BreakVector

;******  End of listing
