
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Mon Aug 26 10:17:18 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="65816"				cpu = "65816"
="em65816"				hardware = "em65816"
=1					exitonend = 1
=0					autorun = 0
=0					loadtest = 0
=1					hasfloat = 1
=1					hasinteger = 1
=253					maxstring = 253

;******  Processing file: modules/float/fpmacros.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/em65816/src_em65816.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0020					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0022					zVarDataPtr: .word ? 						; position of variable data.
>0024					zVarType: 	.byte ? 						; type of data (token)
>0025					zNullString:.byte ? 						; represents a NULL string.
>0200					IFT_XCursor:.byte ?							; current logical position on screen
>0201					IFT_YCursor:.byte ?
>0202					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0266					IFT_LineBuffer: .fill 100 					; line input buffer.
>0300					UserVector .fill 4 							; USR(x) calls this.
>0304					LocalVector .fill 4 						; Indirect calls call this.
>0308					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>030c					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>030d					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=782					XS2_Mantissa = XS_Mantissa+XS_Size
=786					XS2_Exponent = XS_Exponent+XS_Size
=787					XS2_Type = XS_Type+XS_Size
=788					XS3_Mantissa = XS_Mantissa+XS_Size*2
=792					XS3_Exponent = XS_Exponent+XS_Size*2
=793					XS3_Type = XS_Type+XS_Size*2
>0400					StringPtr:	.word ? 						; Top of free memory (for string allocation)
>0402					VarMemPtr: 	.word ?							; Bottom of free memory (for variables)
>0404					NumBufX 	.byte 	?						; buffer index position
>0405					Num_Buffer	.fill 	32 						; buffer for numeric conversions
=6					HashTableCount = 6 							; there are 6 hash tables, in token order.
=8					HashTableSize = 8 							; each hash table as 8 links.
.0425					HashTableBase:
>0425								.fill	HashTableCount * HashTableSize * 2
.0485					HashTableEnd:
=$405					Var_Buffer 	= Num_Buffer 					; buffer for variable name (same space)
>0485					Var_Type    .byte ? 						; type of variable (as a type token)
>0486					Var_Hash 	.byte ? 						; hash of identifier name.
>0487					Var_Length 	.byte ? 						; length of variable name
>0488					Var_HashAddress .byte ?						; low byte of hash table entry.
>0489					Var_DataSize .byte ?						; size of one element.
>048a					NumSuppress	.byte 	?						; leading zero suppression flag
>048b					NumConvCount .byte 	? 						; count for conversions.
>048c					ExpTemp:	.byte ?							; Working temp for exponents.
>048d					ExpCount:	.byte ? 						; Count of decimal exponents.
>048e					SignCount:	.byte ?							; Integer Divide Sign Counts.
>048f					TempStringWriteIndex: .byte ? 				; Write offset.
>0490					ValSign: 	.byte ? 						; sign flag for val()
>0491					SliceStart:	.byte ? 						; string slice parts
>0492					SliceCount:	.byte ?
>0493					RandomSeed:	.dword ? 						; Random seed.
>0497					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>0499					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>049b					Tim_SR:		.byte ? 						; Processor Status
>049c					Tim_A:		.byte ? 						; Processor Registers
>049d					Tim_X:		.byte ?
>049e					Tim_Y:		.byte ?
>049f					Tim_Z:		.byte ?
>04a0					Tim_SP:		.word ?							; Stack Pointer (just in cases)

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/em65816.asm

=$8000					HighMemory = $8000
=$4000					VariableMemory = $4000
.1000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testcode.src

>1000	0b 64 00 cd 14 05 13 14			.byte	$0b,$64,$00,$cd,$14,$05,$13,$14
>1008	84 6a 00 1d 65 00 cd 01			.byte	$84,$6a,$00,$1d,$65,$00,$cd,$01
>1010	84 40 fd 03 30 be cd 14			.byte	$84,$40,$fd,$03,$30,$be,$cd,$14
>1018	05 13 14 31 84 41 fd 06			.byte	$05,$13,$14,$31,$84,$41,$fd,$06
>1020	32 65 32 34 8d 41 64 00			.byte	$32,$65,$32,$34,$8d,$41,$64,$00
>1028	12 66 00 14 05 13 14 84			.byte	$12,$66,$00,$14,$05,$13,$14,$84
>1030	14 05 13 14 8a 41 fd 03			.byte	$14,$05,$13,$14,$8a,$41,$fd,$03
>1038	30 00 2e 67 00 03 84 8b			.byte	$30,$00,$2e,$67,$00,$03,$84,$8b
>1040	14 05 13 14 be 03 84 03			.byte	$14,$05,$13,$14,$be,$03,$84,$03
>1048	8b 4f 68 be cd 0e 01 0d			.byte	$8b,$4f,$68,$be,$cd,$0e,$01,$0d
>1050	05 b5 84 fe 07 48 65 6c			.byte	$05,$b5,$84,$fe,$07,$48,$65,$6c
>1058	6c 6f be 03 b5 84 fe 09			.byte	$6c,$6f,$be,$03,$b5,$84,$fe,$09
>1060	2c 77 6f 72 6c 64 21 00			.byte	$2c,$77,$6f,$72,$6c,$64,$21,$00
>1068	17 68 00 07 12 05 05 14			.byte	$17,$68,$00,$07,$12,$05,$05,$14
>1070	09 0e 07 31 b5 84 0e 01			.byte	$09,$0e,$07,$31,$b5,$84,$0e,$01
>1078	0d 05 b5 8a 03 b5 00 14			.byte	$0d,$05,$b5,$8a,$03,$b5,$00,$14
>1080	69 00 0c 31 b9 84 a6 07			.byte	$69,$00,$0c,$31,$b9,$84,$a6,$07
>1088	12 05 05 14 09 0e 07 31			.byte	$12,$05,$05,$14,$09,$0e,$07,$31
>1090	b5 bc 00 05 6a 00 c2 00			.byte	$b5,$bc,$00,$05,$6a,$00,$c2,$00
>1098	00					.byte	$00

;******  Return to file: modules/hardware/em65816.asm

.c000					StartROM:
.c000	18		clc				clc
.c001	fb		xce				xce
.c002	c2 30		rep #$30			rep 	#$30
.c004	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.c007	1b		tcs				tcs
.c008	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.c00b	e2 30		sep #$30			sep 	#$30
.c00d	c2 30		rep #$30			rep 	#$30						; clear AXY in 16 bit.
.c00f	a9 00		lda #$00			lda 	#$0000
.c011	aa		tax				tax
.c012	a8		tay				tay
.c013	e2 30		sep #$30			sep 	#$30
.c015	5c 9e 86 01	jmp $01869e		jmp BASIC_Start
.c019					TIM_BreakHandler:
.c019	5c 76 83 01	jmp $018376			jmp 	TIM_BreakVector

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.018000					IFT_ClearScreen:
.018000	48		pha				pha
.018001	da		phx				phx
.018002	5a		phy				phy
.018003	20 a9 81	jsr $0181a9			jsr 	IF_Home 					; home cursor
.018006	a2 20		ldx #$20			ldx 	#IF_Height 					; this many lines.
.018008					_IFT_CS0:
.018008	a0 40		ldy #$40			ldy 	#IF_Width 					; this many chars/line
.01800a					_IFT_CS1:
.01800a	a9 20		lda #$20			lda 	#' '						; clear line.
.01800c	20 d5 81	jsr $0181d5			jsr 	IF_Write
.01800f	88		dey				dey
.018010	d0 f8		bne $01800a			bne 	_IFT_CS1
.018012	20 bc 81	jsr $0181bc			jsr 	IF_NewLine 					; next line down
.018015	ca		dex				dex
.018016	d0 f0		bne $018008			bne 	_IFT_CS0
.018018	7a		ply				ply
.018019	fa		plx				plx
.01801a	68		pla				pla
.01801b					IFT_HomeCursor:
.01801b	48		pha				pha
.01801c	20 a9 81	jsr $0181a9			jsr 	IF_Home
.01801f	a9 00		lda #$00			lda 	#0
.018021	8d 00 02	sta $0200			sta 	IFT_XCursor
.018024	8d 01 02	sta $0201			sta 	IFT_YCursor
.018027	68		pla				pla
.018028	60		rts				rts
.018029					IFT_UpLine:
.018029	48		pha				pha
.01802a	ad 01 02	lda $0201			lda  	IFT_YCursor 				; get Y
.01802d	3a		dec a				dec 	a 							; line above
.01802e	30 03		bmi $018033			bmi 	_IFTULExit 					; too far, abort
.018030	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos					; set to that line.
.018033					_IFTULExit:
.018033	68		pla				pla
.018034	60		rts				rts
.018035					IFT_PrintCharacter:
.018035	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.018037	f0 23		beq $01805c			beq 	IFT_NewLine
.018039	48		pha				pha
.01803a	20 74 80	jsr $018074			jsr 	IFT_UpperCase 				; make upper case
.01803d	20 d5 81	jsr $0181d5			jsr 	IF_Write 					; write out.
.018040	ee 00 02	inc $0200			inc 	IFT_XCursor 				; bump x cursor
.018043	ad 00 02	lda $0200			lda 	IFT_XCursor 				; reached RHS ?
.018046	c9 40		cmp #$40			cmp 	#IF_Width
.018048	d0 03		bne $01804d			bne 	_IFT_PCNotEOL
.01804a	20 5c 80	jsr $01805c			jsr 	IFT_NewLine 				; if so do new line.
.01804d					_IFT_PCNotEOL:
.01804d	68		pla				pla
.01804e	60		rts				rts
.01804f					IFT_Tab:
.01804f	a9 20		lda #$20			lda 	#" " 						; space
.018051	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018054	ad 00 02	lda $0200			lda 	IFT_XCursor 				; until x % 8 == 0
.018057	29 07		and #$07			and 	#7
.018059	d0 f4		bne $01804f			bne 	IFT_Tab
.01805b	60		rts				rts
.01805c					IFT_NewLine:
.01805c	48		pha				pha
.01805d	20 bc 81	jsr $0181bc			jsr 	IF_NewLine 					; new line on actual screen.
.018060	a9 00		lda #$00			lda 	#0 							; reset x position
.018062	8d 00 02	sta $0200			sta 	IFT_XCursor
.018065	ee 01 02	inc $0201			inc 	IFT_YCursor 				; move down.
.018068	ad 01 02	lda $0201			lda 	IFT_YCursor
.01806b	c9 20		cmp #$20			cmp 	#IF_Height 					; reached bottom.
.01806d	d0 03		bne $018072			bne 	_IFT_NL_NotEOS
.01806f	20 7f 80	jsr $01807f			jsr 	IFT_Scroll 					; scroll screen up.
.018072					_IFT_NL_NotEOS:
.018072	68		pla				pla
.018073	60		rts				rts
.018074					IFT_UpperCase:
.018074	c9 61		cmp #$61			cmp 	#"a"
.018076	90 06		bcc $01807e			bcc 	_IFT_UCExit
.018078	c9 7b		cmp #$7b			cmp 	#"z"+1
.01807a	b0 02		bcs $01807e			bcs 	_IFT_UCExit
.01807c	49 20		eor #$20			eor 	#$20
.01807e					_IFT_UCExit:
.01807e	60		rts				rts
.01807f					IFT_Scroll:
.01807f	48		pha				pha 								; save AXY
.018080	da		phx				phx
.018081	5a		phy				phy
.018082	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.018084					_IFT_SLoop:
.018084	20 a4 80	jsr $0180a4			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.018087	e8		inx				inx
.018088	e0 1f		cpx #$1f			cpx 	#IF_Height-1				; do whole screen
.01808a	d0 f8		bne $018084			bne 	_IFT_SLoop
.01808c	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.01808e	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.018091	a2 40		ldx #$40			ldx 	#IF_Width 					; blank line
.018093					_IFT_SBlank:
.018093	a9 20		lda #$20			lda 	#32
.018095	20 d5 81	jsr $0181d5			jsr 	IF_Write
.018098	ca		dex				dex
.018099	d0 f8		bne $018093			bne 	_IFT_SBlank
.01809b	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.01809d	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.0180a0	7a		ply				ply
.0180a1	fa		plx				plx
.0180a2	68		pla				pla
.0180a3	60		rts				rts
.0180a4					_IFT_ScrollLine:
.0180a4	da		phx				phx
.0180a5	da		phx				phx
.0180a6	8a		txa				txa 								; copy line into buffer.
.0180a7	1a		inc a				inc 	a 							; next line down.
.0180a8	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.0180ab	a2 00		ldx #$00			ldx 	#0
.0180ad					_IFTScrollCopy1:
.0180ad	20 cc 81	jsr $0181cc			jsr 	IF_Read
.0180b0	9d 02 02	sta $0202,x			sta 	IFT_Buffer,x
.0180b3	e8		inx				inx
.0180b4	e0 40		cpx #$40			cpx 	#IF_Width
.0180b6	d0 f5		bne $0180ad			bne 	_IFTScrollCopy1
.0180b8	68		pla				pla
.0180b9	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.0180bc	a2 00		ldx #$00			ldx 	#0
.0180be					_IFTScrollCopy2:
.0180be	bd 02 02	lda $0202,x			lda 	IFT_Buffer,x
.0180c1	20 d5 81	jsr $0181d5			jsr 	IF_Write
.0180c4	e8		inx				inx
.0180c5	e0 40		cpx #$40			cpx 	#IF_Width
.0180c7	d0 f5		bne $0180be			bne 	_IFTScrollCopy2
.0180c9	fa		plx				plx
.0180ca	60		rts				rts
.0180cb					IFT_SetYPos:
.0180cb	48		pha				pha
.0180cc	da		phx				phx
.0180cd	aa		tax				tax
.0180ce	20 1b 80	jsr $01801b			jsr 	IFT_HomeCursor
.0180d1	e0 00		cpx #$00			cpx 	#0
.0180d3	f0 09		beq $0180de			beq 	_IFT_MOAExit
.0180d5					_IFT_MOALoop:
.0180d5	20 bc 81	jsr $0181bc			jsr 	IF_NewLine
.0180d8	ee 01 02	inc $0201			inc 	IFT_YCursor
.0180db	ca		dex				dex
.0180dc	d0 f7		bne $0180d5			bne		_IFT_MOALoop
.0180de					_IFT_MOAExit:
.0180de	fa		plx				plx
.0180df	68		pla				pla
.0180e0	60		rts				rts
.0180e1					IFT_GetKeyCursor:
.0180e1	20 e9 80	jsr $0180e9			jsr 	_IFT_FlipCursor 			; reverse current
.0180e4					_IFT_GKCWait:
.0180e4	20 e6 81	jsr $0181e6			jsr 	IF_GetKey 					; get key
.0180e7	f0 fb		beq $0180e4			beq 	_IFT_GKCWait
.0180e9					_IFT_FlipCursor:
.0180e9	48		pha				pha 								; save
.0180ea	20 cc 81	jsr $0181cc			jsr 	IF_Read 					; read
.0180ed	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.0180f0	49 80		eor #$80			eor 	#$80 						; reverse
.0180f2	20 d5 81	jsr $0181d5			jsr 	IF_Write 					; write
.0180f5	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.0180f8	68		pla				pla
.0180f9	60		rts				rts
.0180fa					IFT_ReadLine:
.0180fa	48		pha				pha
.0180fb					_IFT_RLLoop:
.0180fb	20 e1 80	jsr $0180e1			jsr 	IFT_GetKeyCursor 			; get keystroke
.0180fe	c9 0d		cmp #$0d			cmp 	#13							; return
.018100	f0 7d		beq $01817f			beq 	_IFT_RLExit
.018102	c9 20		cmp #$20			cmp 	#32 						; control character
.018104	90 05		bcc $01810b			bcc 	_IFT_Control
.018106	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018109	80 f0		bra $0180fb			bra 	_IFT_RLLoop
.01810b					_IFT_Control:
.01810b	c9 01		cmp #$01			cmp 	#"A"-64
.01810d	f0 26		beq $018135			beq 	_IFT_Left
.01810f	c9 04		cmp #$04			cmp 	#"D"-64
.018111	f0 2e		beq $018141			beq 	_IFT_Right
.018113	c9 17		cmp #$17			cmp 	#"W"-64
.018115	f0 36		beq $01814d			beq 	_IFT_Up
.018117	c9 13		cmp #$13			cmp 	#"S"-64
.018119	f0 3e		beq $018159			beq 	_IFT_Down
.01811b	c9 08		cmp #$08			cmp 	#"H"-64
.01811d	f0 09		beq $018128			beq 	_IFT_Backspace
.01811f	c9 1a		cmp #$1a			cmp 	#"Z"-64
.018121	d0 d8		bne $0180fb			bne 	_IFT_RLLoop
.018123	20 00 80	jsr $018000			jsr 	IFT_ClearScreen				; clear CTL-Z
.018126	80 d3		bra $0180fb			bra 	_IFT_RLLoop
.018128					_IFT_Backspace:
.018128	ad 00 02	lda $0200			lda 	IFT_XCursor 				; check not start of line.
.01812b	f0 ce		beq $0180fb			beq 	_IFT_RLLoop
.01812d	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.018130	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.018132	20 d5 81	jsr $0181d5			jsr 	IF_Write
.018135					_IFT_Left:
.018135	ce 00 02	dec $0200			dec 	IFT_XCursor 				; left CTL-W
.018138	10 29		bpl $018163			bpl 	_IFT_Reposition
.01813a	a9 3f		lda #$3f			lda 	#IF_Width-1
.01813c					_IFT_SetX:
.01813c	8d 00 02	sta $0200			sta 	IFT_XCursor
.01813f	80 22		bra $018163			bra 	_IFT_Reposition
.018141					_IFT_Right:
.018141	ee 00 02	inc $0200			inc 	IFT_XCursor
.018144	ad 00 02	lda $0200			lda 	IFT_XCursor
.018147	49 40		eor #$40			eor 	#IF_Width
.018149	f0 f1		beq $01813c			beq 	_IFT_SetX
.01814b	80 16		bra $018163			bra 	_IFT_Reposition
.01814d					_IFT_Up:
.01814d	ce 01 02	dec $0201			dec 	IFT_YCursor
.018150	10 11		bpl $018163			bpl 	_IFT_Reposition
.018152	a9 1f		lda #$1f			lda 	#IF_Height-1
.018154					_IFT_SetY:
.018154	8d 01 02	sta $0201			sta 	IFT_YCursor
.018157	80 0a		bra $018163			bra 	_IFT_Reposition
.018159					_IFT_Down:
.018159	ee 01 02	inc $0201			inc 	IFT_YCursor
.01815c	ad 01 02	lda $0201			lda 	IFT_YCursor
.01815f	49 20		eor #$20			eor 	#IF_Height
.018161	f0 f1		beq $018154			beq 	_IFT_SetY
.018163					_IFT_Reposition:
.018163	ad 00 02	lda $0200			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.018166	48		pha				pha
.018167	ad 01 02	lda $0201			lda 	IFT_YCursor
.01816a	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.01816d	68		pla				pla
.01816e	aa		tax				tax
.01816f	e0 00		cpx #$00			cpx 	#0
.018171	f0 88		beq $0180fb			beq 	_IFT_RLLoop
.018173					_IFT_MoveRight:
.018173	20 cc 81	jsr $0181cc			jsr 	IF_Read
.018176	ee 00 02	inc $0200			inc 	IFT_XCursor
.018179	ca		dex				dex
.01817a	d0 f7		bne $018173			bne 	_IFT_MoveRight
.01817c	4c fb 80	jmp $0180fb			jmp 	_IFT_RLLoop
.01817f					_IFT_RLExit:
.01817f	ad 01 02	lda $0201			lda 	IFT_YCursor 				; go to start of line.
.018182	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.018185	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.018187					_IFT_RLRead:
.018187	20 cc 81	jsr $0181cc			jsr 	IF_Read
.01818a	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.01818d	e8		inx				inx
.01818e	e0 40		cpx #$40			cpx 	#IF_Width
.018190	d0 f5		bne $018187			bne 	_IFT_RLRead
.018192					_IFT_RL_Trim:
.018192	ca		dex				dex 	 							; previous char
.018193	30 07		bmi $01819c			bmi 	_IFT_Found 					; gone too far
.018195	bd 66 02	lda $0266,x			lda 	IFT_LineBuffer,x			; go back if space
.018198	c9 20		cmp #$20			cmp 	#" "
.01819a	f0 f6		beq $018192			beq 	_IFT_RL_Trim
.01819c					_IFT_Found:
.01819c	e8		inx				inx 								; forward to non-space
.01819d	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.01819f	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.0181a2	68		pla				pla
.0181a3	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.0181a5	a0 02		ldy #$02			ldy 	#IFT_LineBuffer >> 8
.0181a7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_em65816.asm

=64					IF_Width 	= 64 							; characters across
=32					IF_Height 	= 32 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line.
=8					IF_XPos 	= 8 							; current position, horizontal.
=$f0000					IF_Screen = $F0000							; 2k screen RAM here
=$f8010					IF_PKeyboard = $F8010						; Keyboard port.
=$f8000					IF_PBreak = $F8000 							; Break key.
.0181a8					IF_Reset:
.0181a8	60		rts				rts
.0181a9					IF_Home:
.0181a9	48		pha				pha
.0181aa	64 08		stz $08				stz 	IF_XPos 					; zero X position
.0181ac	a9 00		lda #$00			lda 	#IF_Screen & $FF 			; set r/w pos.
.0181ae	85 04		sta $04				sta 	IF_Pos
.0181b0	a9 00		lda #$00			lda 	#(IF_Screen >> 8) & $FF
.0181b2	85 05		sta $05				sta 	IF_Pos+1
.0181b4	a9 0f		lda #$0f			lda 	#IF_Screen >> 16
.0181b6	85 06		sta $06				sta 	IF_Pos+2
.0181b8	64 07		stz $07				stz 	IF_Pos+3
.0181ba	68		pla				pla
.0181bb	60		rts				rts
.0181bc					IF_NewLine:
.0181bc	48		pha				pha
.0181bd	64 08		stz $08				stz 	IF_XPos						; back to start of line
.0181bf	18		clc				clc 								; down one line
.0181c0	a5 04		lda $04				lda 	IF_Pos
.0181c2	69 40		adc #$40			adc 	#64
.0181c4	85 04		sta $04				sta 	IF_Pos
.0181c6	90 02		bcc $0181ca			bcc 	_IF_NoCarry 				; carry through.
.0181c8	e6 05		inc $05				inc 	IF_Pos+1
.0181ca					_IF_NoCarry:
.0181ca	68		pla				pla
.0181cb	60		rts				rts
.0181cc					IF_Read:
.0181cc	5a		phy				phy 								; save current Y
.0181cd	a4 08		ldy $08				ldy 	IF_XPos 					; read character at current position
.0181cf	b7 04		lda [$04],y			lda 	[IF_Pos],y
.0181d1	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181d3	7a		ply				ply									; restore Y
.0181d4	60		rts				rts
.0181d5					IF_Write:
.0181d5	5a		phy				phy 								; save current Y
.0181d6	a4 08		ldy $08				ldy 	IF_XPos 					; write character at current position
.0181d8	97 04		sta [$04],y			sta 	[IF_Pos],y
.0181da	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181dc	7a		ply				ply									; restore Y
.0181dd	60		rts				rts
.0181de					IF_LeftOne:
.0181de	c6 08		dec $08				dec 	IF_XPos
.0181e0	60		rts				rts
.0181e1					IF_CheckBreak:
.0181e1	af 00 80 0f	lda $0f8000			lda 	IF_PBreak					; non-zero if Ctrl+C pressed.
.0181e5	60		rts				rts
.0181e6					IF_GetKey:
.0181e6	af 10 80 0f	lda $0f8010			lda 	IF_PKeyboard				; read keyboard
.0181ea	f0 08		beq $0181f4			beq		_IFGK_NoKey 				; skip if zero,no key pressed
.0181ec	48		pha				pha 								; key pressed, clear queue.
.0181ed	a9 00		lda #$00			lda 	#0
.0181ef	8f 10 80 0f	sta $0f8010			sta 	IF_PKeyboard
.0181f3	68		pla				pla
.0181f4					_IFGK_NoKey:
.0181f4	09 00		ora #$00			ora 	#0							; set Z flag appropriately.
.0181f6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.0181f7					TIM_Error:
.0181f7	20 29 80	jsr $018029			jsr 	IFT_UpLine 					; go up one line.
.0181fa	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.0181fc	80 02		bra $018200			bra 	TIM_ShowPrompt
.0181fe					TIM_NewCommand:
.0181fe	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.018200					TIM_ShowPrompt:
.018200	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.018203	20 fa 80	jsr $0180fa			jsr 	IFT_ReadLine	 			; get character, go to next line
.018206	20 5c 80	jsr $01805c			jsr 	IFT_NewLine					; go to next line.
.018209	86 10		stx $10				stx 	zTemp1 						; save line read address
.01820b	84 11		sty $11				sty 	zTemp1+1
.01820d	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.01820f	b1 10		lda ($10),y			lda 	(zTemp1),y
.018211	c9 3f		cmp #$3f			cmp 	#"?"
.018213	f0 04		beq $018219			beq 	TIM_SkipFirst
.018215	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.018217	d0 01		bne $01821a			bne 	TIM_NotDot
.018219					TIM_SkipFirst:
.018219	c8		iny				iny
.01821a					TIM_NotDot:
.01821a	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.01821c	c9 52		cmp #$52			cmp 	#"R"						; show registers
.01821e	f0 6b		beq $01828b			beq 	TIM_ShowRegisters
.018220	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.018222	f0 12		beq $018236			beq 	TIM_ShowMemory
.018224	c9 47		cmp #$47			cmp 	#"G"						; execute
.018226	f0 49		beq $018271			beq 	TIM_Execute
.018228	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.01822a	f0 07		beq $018233			beq 	TIM_GoLoadMemory
.01822c	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.01822e	d0 c7		bne $0181f7			bne 	TIM_Error
.018230	4c af 83	jmp $0183af			jmp 	TIM_UpdateRegisters
.018233					TIM_GoLoadMemory:
.018233	4c df 83	jmp $0183df			jmp 	TIM_LoadMemory
.018236					TIM_ShowMemory:
.018236	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.018239	b0 bc		bcs $0181f7			bcs 	TIM_Error
.01823b	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.01823d	85 12		sta $12				sta 	zTemp2
.01823f	a5 15		lda $15				lda 	zTemp3+1
.018241	85 13		sta $13				sta 	zTemp2+1
.018243	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.018246	90 08		bcc $018250			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.018248	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.01824a	85 14		sta $14				sta 	zTemp3
.01824c	a5 13		lda $13				lda 	zTemp2+1
.01824e	85 15		sta $15				sta 	zTemp3+1
.018250					_TIMSM_Start:
.018250	20 03 83	jsr $018303			jsr 	TIM_WriteLine 				; write one line of hex out
.018253	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.018255	18		clc				clc
.018256	69 10		adc #$10			adc 	#16
.018258	85 12		sta $12				sta 	zTemp2
.01825a	90 02		bcc $01825e			bcc 	_TIMSM_NoCarry
.01825c	e6 13		inc $13				inc 	zTemp2+1
.01825e					_TIMSM_NoCarry:
.01825e	20 e1 81	jsr $0181e1			jsr 	IF_CheckBreak 				; check CTL+C
.018261	d0 0b		bne $01826e			bne 	_TIMSM_Ends 				; if pressed break out.
.018263	38		sec				sec 								; check past the end address in zTemp3
.018264	a5 14		lda $14				lda 	zTemp3
.018266	e5 12		sbc $12				sbc 	zTemp2
.018268	a5 15		lda $15				lda 	zTemp3+1
.01826a	e5 13		sbc $13				sbc 	zTemp2+1
.01826c	10 e2		bpl $018250			bpl 	_TIMSM_Start
.01826e					_TIMSM_Ends:
.01826e	4c fe 81	jmp $0181fe			jmp 	TIM_NewCommand
.018271					TIM_Execute:
.018271	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; get the execute address
.018274	b0 81		bcs $0181f7			bcs 	TIM_Error 					; not legitimate
.018276	ae a0 04	ldx $04a0			ldx 	TIM_SP 						; set up SP
.018279	9a		txs				txs
.01827a	ad 9b 04	lda $049b			lda 	TIM_SR 						; Status for PLP
.01827d	48		pha				pha
.01827e	ad 9c 04	lda $049c			lda 	TIM_A 						; restore AXYZ
.018281	ae 9d 04	ldx $049d			ldx 	TIM_X
.018284	ac 9e 04	ldy $049e			ldy 	TIM_Y
.018287	28		plp				plp 								; and PS Byte.
.018288	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.01828b					TIM_Start:
.01828b					TIM_ShowRegisters:
.01828b	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.01828e	8d 9a 04	sta $049a			sta 	TIM_IRQ+1
.018291	ad ff ff	lda $ffff			lda 	$FFFF
.018294	8d 99 04	sta $0499			sta 	TIM_IRQ
.018297	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.018299					_TIMSR_Text:
.018299	bf ca 82 01	lda $0182ca,x			lda 	_TIMSR_Label,x
.01829d	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182a0	e8		inx				inx
.0182a1	e0 20		cpx #$20			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.0182a3	d0 f4		bne $018299			bne 	_TIMSR_Text
.0182a5	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.0182a7					_TIMSR_Skip:
.0182a7	e8		inx				inx
.0182a8					_TIMSR_LoopSpace:
.0182a8	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.0182aa	b0 04		bcs $0182b0			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.0182ac	8a		txa				txa
.0182ad	4a		lsr a				lsr 	a
.0182ae	b0 05		bcs $0182b5			bcs 	_TIMSR_NoSpace
.0182b0					_TIMSR_Space:
.0182b0	a9 20		lda #$20			lda 	#" "
.0182b2	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182b5					_TIMSR_NoSpace:
.0182b5	bd 97 04	lda $0497,x			lda 	TIM_PC,x 					; output hex value.
.0182b8	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.0182bb	e8		inx				inx
.0182bc	e0 08		cpx #$08			cpx 	#TIM_Z-TIM_PC
.0182be	f0 e7		beq $0182a7			beq 	_TIMSR_Skip
.0182c0	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.0182c2	d0 e4		bne $0182a8			bne 	_TimSR_LoopSpace
.0182c4	20 5c 80	jsr $01805c			jsr 	IFT_NewLine 				; new line
.0182c7	4c fe 81	jmp $0181fe			jmp	 	TIM_NewCommand 				; new command.
.0182ca					_TIMSR_Label:
>0182ca	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>0182d2	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>0182e2	52
>0182e3	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.0182ea					_TIMSR_LabelEnd:
.0182ea					TIM_WriteHex:
.0182ea	48		pha				pha 								; save A
.0182eb	4a		lsr a				lsr 	a 							; shift MSB->LSB
.0182ec	4a		lsr a				lsr 	a
.0182ed	4a		lsr a				lsr 	a
.0182ee	4a		lsr a				lsr 	a
.0182ef	20 f3 82	jsr $0182f3			jsr 	_TIMWH_Nibble 				; print MSB
.0182f2	68		pla				pla 								; restore and print LSB
.0182f3					_TIMWH_Nibble:
.0182f3	48		pha				pha
.0182f4	29 0f		and #$0f			and 	#15 						; mask out
.0182f6	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.0182f8	90 02		bcc $0182fc			bcc 	_TIMWHNoLetter
.0182fa	69 06		adc #$06			adc 	#6
.0182fc					_TIMWHNoLetter:
.0182fc	69 30		adc #$30			adc 	#48
.0182fe	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter 			; print it out.
.018301	68		pla				pla
.018302	60		rts				rts
.018303					TIM_WriteLine:
.018303	a9 2e		lda #$2e			lda 	#"." 						; prompt
.018305	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018308	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.01830a	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01830d	a5 13		lda $13				lda 	zTemp2+1 					; write address
.01830f	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.018312	a5 12		lda $12				lda 	zTemp2
.018314	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.018317	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.018319					_TIMWL_Loop:
.018319	a9 20		lda #$20			lda 	#" "
.01831b	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01831e	b1 12		lda ($12),y			lda 	(zTemp2),y
.018320	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.018323	c8		iny				iny
.018324	c0 10		cpy #$10			cpy 	#16
.018326	d0 f1		bne $018319			bne 	_TIMWL_Loop
.018328	4c 5c 80	jmp $01805c			jmp 	IFT_NewLine 				; new line and exit
.01832b					TIM_GetHex:
.01832b	c8		iny				iny
.01832c	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.01832e	c9 20		cmp #$20			cmp 	#32
.018330	f0 f9		beq $01832b			beq 	TIM_GetHex
.018332	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.018334	f0 f5		beq $01832b			beq 	TIM_GetHex
.018336	20 5f 83	jsr $01835f			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.018339	b0 23		bcs $01835e			bcs 	_TIMGH_Exit					; if first bad then exit now.
.01833b	a9 00		lda #$00			lda 	#0 							; zero result
.01833d	85 14		sta $14				sta 	zTemp3
.01833f	85 15		sta $15				sta 	zTemp3+1
.018341					_TIM_GHLoop:
.018341	20 5f 83	jsr $01835f			jsr 	TIM_GetHexCharacter 		; get next character
.018344	b0 17		bcs $01835d			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.018346	c8		iny				iny 								; skip over it.
.018347	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.018349	26 15		rol $15				rol 	zTemp3+1
.01834b	06 14		asl $14				asl 	zTemp3 						; now x 2
.01834d	26 15		rol $15				rol 	zTemp3+1
.01834f	06 14		asl $14				asl 	zTemp3						; now x 4
.018351	26 15		rol $15				rol 	zTemp3+1
.018353	06 14		asl $14				asl 	zTemp3 						; now x 8
.018355	26 15		rol $15				rol 	zTemp3+1
.018357	05 14		ora $14				ora 	zTemp3 						; OR result in
.018359	85 14		sta $14				sta 	zTemp3
.01835b	80 e4		bra $018341			bra 	_TIM_GHLoop 				; loop round again.
.01835d					_TIMGH_Okay:
.01835d	18		clc				clc
.01835e					_TIMGH_Exit:
.01835e	60		rts				rts
.01835f					TIM_GetHexCharacter:
.01835f	b1 10		lda ($10),y			lda 	(zTemp1),y
.018361	38		sec				sec
.018362	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.018364	90 0e		bcc $018374			bcc 	_TIM_GHCFail
.018366	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.018368	90 0b		bcc $018375			bcc 	_TIM_GHCExit
.01836a	c9 11		cmp #$11			cmp 	#65-48						; < A
.01836c	90 06		bcc $018374			bcc		_TIM_GHCFail
.01836e	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.018370	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.018372	90 01		bcc $018375			bcc		_TIM_GHCExit
.018374					_TIM_GHCFail:
.018374	38		sec				sec
.018375					_TIM_GHCExit:
.018375	60		rts				rts
.018376					TIM_BreakVector:
.018376	da		phx				phx									; save X/A on stack
.018377	48		pha				pha
.018378	ba		tsx				tsx 								; X points to S
.018379	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.01837c	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.01837e	d0 03		bne $018383			bne 	_TIMBreak					; if set, it's BRK
.018380	68		pla				pla 								; abandon routine.
.018381	fa		plx				plx
.018382	40		rti				rti
.018383					_TIMBreak:
.018383	68		pla				pla 								; save A X Y and maybe Z
.018384	8d 9c 04	sta $049c			sta 	TIM_A
.018387	fa		plx				plx
.018388	8e 9d 04	stx $049d			stx 	TIM_X
.01838b	8c 9e 04	sty $049e			sty 	TIM_Y
.01838e	68		pla				pla 								; get Status Register
.01838f	8d 9b 04	sta $049b			sta 	TIM_SR
.018392	68		pla				pla
.018393	8d 98 04	sta $0498			sta 	TIM_PC+1 					; save calling address
.018396	68		pla				pla
.018397	8d 97 04	sta $0497			sta 	TIM_PC 						; high byte
.01839a	ad 98 04	lda $0498			lda 	TIM_PC+1 					; dec PC to point right.
.01839d	d0 03		bne $0183a2			bne 	_TIMDecrement 				; brk bumps it.
.01839f	ce 97 04	dec $0497			dec 	TIM_PC
.0183a2					_TIMDecrement:
.0183a2	ce 98 04	dec $0498			dec 	TIM_PC+1
.0183a5	ba		tsx				tsx 								; and copy SP
.0183a6	8e a0 04	stx $04a0			stx 	TIM_SP
.0183a9	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.0183ab	9a		txs				txs
.0183ac	4c 8b 82	jmp $01828b			jmp 	TIM_Start 					; and start up TIM monitor.
.0183af					TIM_UpdateRegisters:
.0183af	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; PC
.0183b2	b0 28		bcs $0183dc			bcs 	_TIMURFail
.0183b4	a5 14		lda $14				lda 	zTemp3
.0183b6	8d 98 04	sta $0498			sta 	Tim_PC+1
.0183b9	a5 15		lda $15				lda 	zTemp3+1
.0183bb	8d 97 04	sta $0497			sta 	Tim_PC
.0183be	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; ignore IRQ
.0183c1	b0 19		bcs $0183dc			bcs 	_TIMURFail
.0183c3	a2 00		ldx #$00			ldx 	#0
.0183c5					_TIM_URLoop:
.0183c5	e0 04		cpx #$04			cpx 	#Tim_Z-Tim_SR
.0183c7	d0 01		bne $0183ca			bne 	_TIM_1
.0183c9	e8		inx				inx
.0183ca					_TIM_1:
.0183ca	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; registers
.0183cd	b0 0d		bcs $0183dc			bcs 	_TIMURFail
.0183cf	a5 14		lda $14				lda 	zTemp3
.0183d1	9d 9b 04	sta $049b,x			sta 	Tim_SR,x
.0183d4	e8		inx				inx
.0183d5	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.0183d7	d0 ec		bne $0183c5			bne 	_TIM_URLoop
.0183d9	4c fe 81	jmp $0181fe			jmp 	TIM_NewCommand
.0183dc					_TIMURFail:
.0183dc	4c f7 81	jmp $0181f7			jmp 	TIM_Error
.0183df					TIM_LoadMemory:
.0183df	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; target address => zTemp2
.0183e2	a5 14		lda $14				lda 	zTemp3
.0183e4	85 12		sta $12				sta 	zTemp2
.0183e6	a5 15		lda $15				lda 	zTemp3+1
.0183e8	85 13		sta $13				sta 	zTemp2+1
.0183ea					_TIM_LMLoop:
.0183ea	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; next byte ?
.0183ed	b0 0e		bcs $0183fd			bcs 	_TIMLMDone 					; no more
.0183ef	a2 00		ldx #$00			ldx 	#0							; write out.
.0183f1	a5 14		lda $14				lda 	zTemp3
.0183f3	81 12		sta ($12,x)			sta 	(zTemp2,x)
.0183f5	e6 12		inc $12				inc 	zTemp2 						; bump address
.0183f7	d0 f1		bne $0183ea			bne 	_TIM_LMLoop
.0183f9	e6 13		inc $13				inc 	zTemp2+1
.0183fb	80 ed		bra $0183ea			bra 	_TIM_LMLoop
.0183fd					_TIMLMDone:
.0183fd	4c fe 81	jmp $0181fe			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/errors.asm

.018400					SyntaxError:
.018400	20 2f 84	jsr $01842f			jsr 	ERR_Handler
>018403	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>01840b	72 72 6f 72 00
.018410					TypeError:
.018410	20 2f 84	jsr $01842f			jsr 	ERR_Handler
>018413	57 72 6f 6e 67 20 74 79				.text 	"Wrong type",0
>01841b	70 65 00
.01841e					BadParamError:
.01841e	20 2f 84	jsr $01842f			jsr 	ERR_Handler
>018421	42 61 64 20 50 61 72 61				.text 	"Bad Parameter",0
>018429	6d 65 74 65 72 00
.01842f					ERR_Handler:
.01842f	a0 00		ldy #$00			ldy 	#0
.018431	c8		iny				iny
.018432	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018434	8d 08 03	sta $0308			sta 	XS_Mantissa
.018437	c8		iny				iny
.018438	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01843a	8d 09 03	sta $0309			sta 	XS_Mantissa+1
.01843d	fa		plx				plx 								; address in XY
.01843e	7a		ply				ply
.01843f	e8		inx				inx 								; bump, because of RTS/JSR address -1
.018440	d0 01		bne $018443			bne 	_EHNoSkip
.018442	c8		iny				iny
.018443					_EHNoSkip:
.018443	20 64 84	jsr $018464			jsr 	PrintROMMessage 			; print message from ROM.
.018446	ad 08 03	lda $0308			lda 	XS_Mantissa					; line number = 0
.018449	0d 09 03	ora $0309			ora 	XS_Mantissa+1
.01844c	f0 0c		beq $01845a			beq 	_EHNoLine
.01844e	a2 5f		ldx #$5f			ldx 	#_EHAt & $FF 				; print " at "
.018450	a0 84		ldy #$84			ldy 	#(_EHAt >> 8) & $FF
.018452	20 64 84	jsr $018464			jsr 	PrintROMMessage
.018455	a2 00		ldx #$00			ldx 	#0 							; Print line number
.018457	20 79 84	jsr $018479			jsr 	Print16BitInteger
.01845a					_EHNoLine:
.01845a	80 fe		bra $01845a			bra 	_EHNoLine
.01845c	4c be 86	jmp $0186be			jmp 	WarmStart
>01845f	20 61 74 20 00			_EHAt:	.text 	" at ",0
.018464					PrintROMMessage:
.018464	86 1a		stx $1a				stx 	zLTemp1 					; save addres
.018466	84 1b		sty $1b				sty 	zLTemp1+1
.018468	4b		phk				phk
.018469	68		pla				pla
.01846a	85 1c		sta $1c				sta 	ZLTemp1+2
.01846c	a0 00		ldy #$00			ldy 	#0
.01846e					_PRMLoop:
.01846e	b7 1a		lda [$1a],y			lda 	[zLTemp1],y
.018470	f0 06		beq $018478			beq		_PRMExit
.018472	c8		iny				iny
.018473	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018476	80 f6		bra $01846e			bra 	_PRMLoop
.018478					_PRMExit:
.018478	60		rts				rts
.018479					Print16BitInteger:
.018479	a9 00		lda #$00			lda 	#0 							; make 32 bit
.01847b	8d 0a 03	sta $030a			sta 	XS_Mantissa+2
.01847e	8d 0b 03	sta $030b			sta 	XS_Mantissa+3
.018481	8d 04 04	sta $0404			sta 	NumBufX 					; reset the conversion pointer
.018484	aa		tax				tax 								; convert bottom level.
.018485	20 50 94	jsr $019450			jsr 	INTToString 				; make string
.018488	a2 00		ldx #$00			ldx 	#0 							; print buffer
.01848a	bd 05 04	lda $0405,x	_P1Loop:lda 	Num_Buffer,x
.01848d	f0 06		beq $018495			beq 	_P1Exit
.01848f	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018492	e8		inx				inx
.018493	80 f5		bra $01848a			bra 	_P1Loop
.018495	60		rts		_P1Exit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm


;******  Processing file: modules/basic/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b4					lastUnaryFunction = $b4
.018496					VectorTable:
>018496	eb 89					.word BinaryOp_And         & $FFFF ; $80 and
>018498	13 8a					.word BinaryOp_Or          & $FFFF ; $81 or
>01849a	3b 8a					.word BinaryOp_Xor         & $FFFF ; $82 xor
>01849c	3b 8a					.word BinaryOp_Eor         & $FFFF ; $83 eor
>01849e	7f 8a					.word Binary_Equal         & $FFFF ; $84 =
>0184a0	9e 8a					.word Binary_NotEqual      & $FFFF ; $85 <>
>0184a2	a7 8a					.word Binary_Less          & $FFFF ; $86 <
>0184a4	b0 8a					.word Binary_LessEqual     & $FFFF ; $87 <=
>0184a6	c2 8a					.word Binary_Greater       & $FFFF ; $88 >
>0184a8	b9 8a					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>0184aa	57 8b					.word BinaryOp_Add         & $FFFF ; $8a +
>0184ac	77 8b					.word BinaryOp_Subtract    & $FFFF ; $8b -
>0184ae	8a 8b					.word BinaryOp_Multiply    & $FFFF ; $8c *
>0184b0	9d 8b					.word BinaryOp_Divide      & $FFFF ; $8d /
>0184b2	4a 85					.word NotImplemented       & $FFFF ; $8e ^
>0184b4	4a 85					.word NotImplemented       & $FFFF ; $8f if
>0184b6	4a 85					.word NotImplemented       & $FFFF ; $90 while
>0184b8	4a 85					.word NotImplemented       & $FFFF ; $91 repeat
>0184ba	4a 85					.word NotImplemented       & $FFFF ; $92 for
>0184bc	4a 85					.word NotImplemented       & $FFFF ; $93 then
>0184be	4a 85					.word NotImplemented       & $FFFF ; $94 endif
>0184c0	4a 85					.word NotImplemented       & $FFFF ; $95 wend
>0184c2	4a 85					.word NotImplemented       & $FFFF ; $96 until
>0184c4	4a 85					.word NotImplemented       & $FFFF ; $97 next
>0184c6	4a 85					.word NotImplemented       & $FFFF ; $98 not
>0184c8	4a 85					.word NotImplemented       & $FFFF ; $99 fn(
>0184ca	d1 8c					.word Unary_Abs            & $FFFF ; $9a abs(
>0184cc	29 8e					.word Unary_Asc            & $FFFF ; $9b asc(
>0184ce	35 9c					.word Unary_Int            & $FFFF ; $9c int(
>0184d0	ef 8c					.word Unary_Peek           & $FFFF ; $9d peek(
>0184d2	ac 9b					.word Unary_Rnd            & $FFFF ; $9e rnd(
>0184d4	63 8d					.word Unary_Usr            & $FFFF ; $9f usr(
>0184d6	6a 8e					.word Unary_Left           & $FFFF ; $a0 left$(
>0184d8	81 8e					.word Unary_Right          & $FFFF ; $a1 right$(
>0184da	4f 8e					.word Unary_Mid            & $FFFF ; $a2 mid$(
>0184dc	e3 8f					.word Unary_Spc            & $FFFF ; $a3 spc(
>0184de	f6 8d					.word Unary_Str            & $FFFF ; $a4 str$(
>0184e0	85 8d					.word Unary_Val            & $FFFF ; $a5 val(
>0184e2	40 8e					.word Unary_Len            & $FFFF ; $a6 len(
>0184e4	ff 8e					.word Unary_Hex            & $FFFF ; $a7 hex$(
>0184e6	4a 85					.word NotImplemented       & $FFFF ; $a8 sin(
>0184e8	4a 85					.word NotImplemented       & $FFFF ; $a9 cos(
>0184ea	4a 85					.word NotImplemented       & $FFFF ; $aa tan(
>0184ec	4a 85					.word NotImplemented       & $FFFF ; $ab atn(
>0184ee	4a 85					.word NotImplemented       & $FFFF ; $ac exp(
>0184f0	4a 85					.word NotImplemented       & $FFFF ; $ad log(
>0184f2	4a 85					.word NotImplemented       & $FFFF ; $ae sqr(
>0184f4	59 8f					.word Unary_Dec            & $FFFF ; $af dec(
>0184f6	f3 8c					.word Unary_Deek           & $FFFF ; $b0 deek(
>0184f8	f7 8c					.word Unary_Leek           & $FFFF ; $b1 leek(
>0184fa	2b 8d					.word Unary_Mod            & $FFFF ; $b2 mod(
>0184fc	7f 8c					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>0184fe	c1 8f					.word Unary_Chr            & $FFFF ; $b4 chr$(
>018500	4a 85					.word NotImplemented       & $FFFF ; $b5 $
>018502	4a 85					.word NotImplemented       & $FFFF ; $b6 $(
>018504	4a 85					.word NotImplemented       & $FFFF ; $b7 #
>018506	4a 85					.word NotImplemented       & $FFFF ; $b8 #(
>018508	4a 85					.word NotImplemented       & $FFFF ; $b9 %
>01850a	4a 85					.word NotImplemented       & $FFFF ; $ba %(
>01850c	4a 85					.word NotImplemented       & $FFFF ; $bb (
>01850e	4a 85					.word NotImplemented       & $FFFF ; $bc )
>018510	4a 85					.word NotImplemented       & $FFFF ; $bd ,
>018512	46 87					.word Command_COLON        & $FFFF ; $be :
>018514	4a 85					.word NotImplemented       & $FFFF ; $bf ;
>018516	4a 85					.word NotImplemented       & $FFFF ; $c0 def
>018518	fb 87					.word Command_CLR          & $FFFF ; $c1 clr
>01851a	09 88					.word Command_STOP         & $FFFF ; $c2 stop
>01851c	4a 85					.word NotImplemented       & $FFFF ; $c3 data
>01851e	4a 85					.word NotImplemented       & $FFFF ; $c4 read
>018520	4a 85					.word NotImplemented       & $FFFF ; $c5 dim
>018522	4a 85					.word NotImplemented       & $FFFF ; $c6 to
>018524	4a 85					.word NotImplemented       & $FFFF ; $c7 step
>018526	4a 85					.word NotImplemented       & $FFFF ; $c8 gosub
>018528	4a 85					.word NotImplemented       & $FFFF ; $c9 return
>01852a	4a 85					.word NotImplemented       & $FFFF ; $ca goto
>01852c	68 87					.word Command_END          & $FFFF ; $cb end
>01852e	4a 85					.word NotImplemented       & $FFFF ; $cc input
>018530	47 87					.word Command_LET          & $FFFF ; $cd let
>018532	4a 85					.word NotImplemented       & $FFFF ; $ce list
>018534	4a 85					.word NotImplemented       & $FFFF ; $cf new
>018536	4a 85					.word NotImplemented       & $FFFF ; $d0 old
>018538	4a 85					.word NotImplemented       & $FFFF ; $d1 on
>01853a	4a 85					.word NotImplemented       & $FFFF ; $d2 restore
>01853c	4a 85					.word NotImplemented       & $FFFF ; $d3 poke
>01853e	6c 87					.word Command_PRINT        & $FFFF ; $d4 print
>018540	cc 86					.word Command_RUN          & $FFFF ; $d5 run
>018542	4a 85					.word NotImplemented       & $FFFF ; $d6 wait
>018544	4a 85					.word NotImplemented       & $FFFF ; $d7 doke
>018546	4a 85					.word NotImplemented       & $FFFF ; $d8 loke
>018548	df 87					.word Command_ASSERT       & $FFFF ; $d9 assert
.01854a					NotImplemented:
.01854a	20 2f 84	jsr $01842f			jsr ERR_Handler
>01854d	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>018555	65 6d 65 6e 74 65 64 00
.01855d					BinaryPrecedence:
>01855d	01					.byte 1    ; $80 and
>01855e	01					.byte 1    ; $81 or
>01855f	01					.byte 1    ; $82 xor
>018560	01					.byte 1    ; $83 eor
>018561	02					.byte 2    ; $84 =
>018562	02					.byte 2    ; $85 <>
>018563	02					.byte 2    ; $86 <
>018564	02					.byte 2    ; $87 <=
>018565	02					.byte 2    ; $88 >
>018566	02					.byte 2    ; $89 >=
>018567	03					.byte 3    ; $8a +
>018568	03					.byte 3    ; $8b -
>018569	04					.byte 4    ; $8c *
>01856a	04					.byte 4    ; $8d /
>01856b	05					.byte 5    ; $8e ^
.01856c					KeywordText:
>01856c	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>01856f	4f d2					.byte $4f,$d2                          ; $81 or
>018571	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>018574	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>018577	bd					.byte $bd                              ; $84 =
>018578	3c be					.byte $3c,$be                          ; $85 <>
>01857a	bc					.byte $bc                              ; $86 <
>01857b	3c bd					.byte $3c,$bd                          ; $87 <=
>01857d	be					.byte $be                              ; $88 >
>01857e	3e bd					.byte $3e,$bd                          ; $89 >=
>018580	ab					.byte $ab                              ; $8a +
>018581	ad					.byte $ad                              ; $8b -
>018582	aa					.byte $aa                              ; $8c *
>018583	af					.byte $af                              ; $8d /
>018584	de					.byte $de                              ; $8e ^
>018585	49 c6					.byte $49,$c6                          ; $8f if
>018587	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>01858c	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>018592	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>018595	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>018599	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>01859e	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>0185a2	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>0185a7	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>0185ab	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>0185ae	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>0185b1	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>0185b5	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>0185b9	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>0185bd	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>0185c2	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>0185c6	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>0185ca	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>0185d0	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>0185d7	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>0185dc	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>0185e0	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>0185e5	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>0185e9	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>0185ed	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>0185f2	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>0185f6	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>0185fa	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>0185fe	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>018602	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>018606	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>01860a	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>01860e	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>018612	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>018617	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>01861c	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>018620	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>018624	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>018629	a4					.byte $a4                              ; $b5 $
>01862a	24 a8					.byte $24,$a8                          ; $b6 $(
>01862c	a3					.byte $a3                              ; $b7 #
>01862d	23 a8					.byte $23,$a8                          ; $b8 #(
>01862f	a5					.byte $a5                              ; $b9 %
>018630	25 a8					.byte $25,$a8                          ; $ba %(
>018632	a8					.byte $a8                              ; $bb (
>018633	a9					.byte $a9                              ; $bc )
>018634	ac					.byte $ac                              ; $bd ,
>018635	ba					.byte $ba                              ; $be :
>018636	bb					.byte $bb                              ; $bf ;
>018637	44 45 c6				.byte $44,$45,$c6                      ; $c0 def
>01863a	43 4c d2				.byte $43,$4c,$d2                      ; $c1 clr
>01863d	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $c2 stop
>018641	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c3 data
>018645	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c4 read
>018649	44 49 cd				.byte $44,$49,$cd                      ; $c5 dim
>01864c	54 cf					.byte $54,$cf                          ; $c6 to
>01864e	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c7 step
>018652	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $c8 gosub
>018657	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $c9 return
>01865d	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $ca goto
>018661	45 4e c4				.byte $45,$4e,$c4                      ; $cb end
>018664	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $cc input
>018669	4c 45 d4				.byte $4c,$45,$d4                      ; $cd let
>01866c	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $ce list
>018670	4e 45 d7				.byte $4e,$45,$d7                      ; $cf new
>018673	4f 4c c4				.byte $4f,$4c,$c4                      ; $d0 old
>018676	4f ce					.byte $4f,$ce                          ; $d1 on
>018678	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d2 restore
>01867f	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d3 poke
>018683	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d4 print
>018688	52 55 ce				.byte $52,$55,$ce                      ; $d5 run
>01868b	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d6 wait
>01868f	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $d7 doke
>018693	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $d8 loke
>018697	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $d9 assert
>01869d	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_dollar = $b5
=$b6					token_dollarlparen = $b6
=$b7					token_hash = $b7
=$b8					token_hashlparen = $b8
=$b9					token_percent = $b9
=$ba					token_percentlparen = $ba
=$bb					token_lparen = $bb
=$bc					token_rparen = $bc
=$bd					token_comma = $bd
=$be					token_colon = $be
=$bf					token_semicolon = $bf
=$c0					token_def = $c0
=$c1					token_clr = $c1
=$c2					token_stop = $c2
=$c3					token_data = $c3
=$c4					token_read = $c4
=$c5					token_dim = $c5
=$c6					token_to = $c6
=$c7					token_step = $c7
=$c8					token_gosub = $c8
=$c9					token_return = $c9
=$ca					token_goto = $ca
=$cb					token_end = $cb
=$cc					token_input = $cc
=$cd					token_let = $cd
=$ce					token_list = $ce
=$cf					token_new = $cf
=$d0					token_old = $d0
=$d1					token_on = $d1
=$d2					token_restore = $d2
=$d3					token_poke = $d3
=$d4					token_print = $d4
=$d5					token_run = $d5
=$d6					token_wait = $d6
=$d7					token_doke = $d7
=$d8					token_loke = $d8
=$d9					token_assert = $d9

;******  Return to file: modules/basic/core.asm

.01869e					BASIC_Start:
.01869e	20 a8 81	jsr $0181a8			jsr 	IF_Reset 					; set up and clear screen.
.0186a1	20 00 80	jsr $018000			jsr 	IFT_ClearScreen
.0186a4	a9 5c		lda #$5c			lda 	#$5C 						; JMP Long opcode
.0186a6	8d 04 03	sta $0304			sta 	LocalVector
.0186a9	8d 00 03	sta $0300			sta 	UserVector
.0186ac	a9 73		lda #$73			lda 	#USRDefault & $FF 			; reset USR vector
.0186ae	8d 01 03	sta $0301			sta 	UserVector+1
.0186b1	a9 8d		lda #$8d			lda 	#(USRDefault >> 8) & $FF
.0186b3	8d 02 03	sta $0302			sta 	UserVector+2
.0186b6	a9 01		lda #$01			lda 	#(USRDefault >> 16) & $FF
.0186b8	8d 03 03	sta $0303			sta 	UserVector+3
.0186bb	20 fb 87	jsr $0187fb			jsr 	ResetRunStatus 				; clear everything (CLR command)
.0186be					WarmStart:
.0186be	c2 30		rep #$30			rep 	#$30
.0186c0	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.0186c3	1b		tcs				tcs
.0186c4	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.0186c7	e2 30		sep #$30			sep 	#$30
.0186c9	4c cc 86	jmp $0186cc			jmp 	COMMAND_Run

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/run.asm

.0186cc					Command_RUN:
.0186cc	20 fb 87	jsr $0187fb			jsr 	ResetRunStatus 				; clear, reset stacks etc.
.0186cf	a9 00		lda #$00			lda 	#BasicProgram & $FF
.0186d1	85 16		sta $16				sta 	zCodePtr+0
.0186d3	a9 10		lda #$10			lda 	#BasicProgram >> 8
.0186d5	85 17		sta $17				sta 	zCodePtr+1
.0186d7	a9 00		lda #$00			lda 	#0
.0186d9	85 18		sta $18				sta 	zCodePtr+2
.0186db	85 19		sta $19				sta 	zCodePtr+3
.0186dd	a0 03		ldy #$03			ldy 	#3
.0186df					RUN_NewLine:
.0186df	a0 00		ldy #$00			ldy 	#0
.0186e1	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0186e3	c8		iny				iny
.0186e4	c8		iny				iny
.0186e5	c8		iny				iny
.0186e6	c9 00		cmp #$00			cmp 	#0 							; if the offset is zero then END.
.0186e8	d0 16		bne $018700			bne 	RUN_NextCommand
.0186ea	4c 09 88	jmp $018809			jmp 	Command_STOP 				; go do the command code.
.0186ed					RUN_Skip:
.0186ed	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.0186ef	c8		iny				iny 								; skip
.0186f0	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.0186f2	90 0c		bcc $018700			bcc 	_SEDone 					; so just skip over it.
.0186f4	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.0186f6	90 07		bcc $0186ff			bcc 	_SEDouble
.0186f8	98		tya				tya 								; this is Y + 1
.0186f9	18		clc				clc
.0186fa	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.0186fc	a8		tay				tay 								; back in Y.
.0186fd	88		dey				dey 								; fix up, one for the +1, one for the iny
.0186fe	88		dey				dey
.0186ff					_SEDouble:
.0186ff	c8		iny				iny
.018700					_SEDone:
.018700					RUN_NextCommand:
.018700	a9 00		lda #$00			lda 	#0 							; this resets temporary string allocation.
.018702	85 21		sta $21				sta 	zTempStr+1 					; (initialised when first called)
.018704	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018706	c9 be		cmp #$be			cmp 	#token_Colon 				; skip over colons
.018708	f0 e3		beq $0186ed			beq 	RUN_Skip
.01870a	c9 00		cmp #$00			cmp 	#0 							; if non-zero execute whatever
.01870c	d0 0f		bne $01871d			bne 	RUN_Execute
.01870e					RUN_NextLine:
.01870e	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018710	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.018712	18		clc				clc
.018713	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018715	85 16		sta $16				sta 	zCodePtr
.018717	90 02		bcc $01871b			bcc 	_SNLNoCarry
.018719	e6 17		inc $17				inc 	zCodePtr+1
.01871b					_SNLNoCarry:
.01871b	80 c2		bra $0186df			bra 	RUN_NewLine 				; go do the new line code
.01871d					RUN_Execute:
.01871d	c9 f8		cmp #$f8			cmp 	#$F8 						; handle shifts, REM etc.
.01871f	b0 1e		bcs $01873f			bcs 	RUN_Extension
.018721	c8		iny				iny
.018722	0a		asl a				asl 	a 							; double the character read.
.018723	90 14		bcc $018739			bcc 	RUN_Default 				; if carry clear was $00-$7F, so try LET.
.018725	aa		tax				tax 								; ready to look up.
.018726	bf 96 84 01	lda $018496,x			lda 	VectorTable,x 				; copy address into LocalVector
.01872a	8d 05 03	sta $0305			sta 	LocalVector+1
.01872d	bf 97 84 01	lda $018497,x			lda 	VectorTable+1,x
.018731	8d 06 03	sta $0306			sta 	LocalVector+2
.018734	20 24 89	jsr $018924			jsr 	EVCallLocalVector 			; execute the appropriate code.
.018737	80 c7		bra $018700			bra 	RUN_NextCommand 			; do the next command.
.018739					RUN_Default:
.018739	88		dey				dey
.01873a	20 47 87	jsr $018747			jsr 	Command_LET 				; and try LET.
.01873d	80 c1		bra $018700			bra 	RUN_NextCommand
.01873f					RUN_Extension:
.01873f	c9 ff		cmp #$ff			cmp 	#$FF 						; if $FF (REM)
.018741	f0 aa		beq $0186ed			beq 	RUN_Skip 					; skip over it.
.018743	4c 00 84	jmp $018400			jmp 	SyntaxError
.018746					Command_COLON:
.018746	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/let.asm

.018747					Command_LET:
.018747	20 ee 90	jsr $0190ee			jsr 	VariableFind 				; get reference to one variable.
.01874a	a9 84		lda #$84			lda 	#token_Equal  				; get equals
.01874c	20 34 90	jsr $019034			jsr 	CheckNextToken
.01874f	a5 22		lda $22				lda 	zVarDataPtr 				; save variable info on stack
.018751	48		pha				pha
.018752	a5 23		lda $23				lda 	zVarDataPtr+1
.018754	48		pha				pha
.018755	a5 24		lda $24				lda 	zVarType
.018757	48		pha				pha
.018758	20 14 88	jsr $018814			jsr 	EvaluateExpression 			; evaluate the RHS.
.01875b	68		pla				pla 								; restore target variable information.
.01875c	85 24		sta $24				sta 	zVarType
.01875e	68		pla				pla
.01875f	85 23		sta $23				sta 	zVarDataPtr+1
.018761	68		pla				pla
.018762	85 22		sta $22				sta 	zVarDataPtr
.018764	20 ce 92	jsr $0192ce			jsr 	VariableSet 				; set the value out.
.018767	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/end.asm

.018768					Command_END:
>018768	02						.byte 	2
.018769	4c be 86	jmp $0186be			jmp 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/print.asm

.01876c					Command_PRINT:
.01876c	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01876e	c9 00		cmp #$00			cmp 	#0 							; end
.018770	f0 69		beq $0187db			beq 	_CPR_NewLine
.018772	c9 be		cmp #$be			cmp 	#token_Colon
.018774	f0 65		beq $0187db			beq 	_CPR_NewLine
.018776	c9 bf		cmp #$bf			cmp 	#token_SemiColon
.018778	f0 54		beq $0187ce			beq 	_CPR_Skip
.01877a	c9 bd		cmp #$bd			cmp 	#token_Comma
.01877c	f0 4d		beq $0187cb			beq 	_CPR_Tab
.01877e	20 14 88	jsr $018814			jsr 	EvaluateExpression 			; get expression.
.018781	ad 0d 03	lda $030d			lda 	XS_Type 					; get type.
.018784	29 02		and #$02			and 	#2
.018786	d0 25		bne $0187ad			bne 	_CPR_String 				; if type = 2 output as string.
.018788					_CPR_Number:
.018788	a9 00		lda #$00			lda 	#0 							; reset buffer index
.01878a	8d 04 04	sta $0404			sta 	NumBufX
.01878d	ad 0d 03	lda $030d			lda 	XS_Type 					; get type
.018790	4a		lsr a				lsr 	a
.018791	b0 05		bcs $018798			bcs 	_CPRInt 					; if msb set do as integer
.018793	20 64 9a	jsr $019a64			jsr 	FPToString 					; call fp to str otherwise
.018796	80 03		bra $01879b			bra 	_CPRNPrint
.018798	20 50 94	jsr $019450	_CPRInt:jsr 	IntToString
.01879b					_CPRNPrint:
.01879b	ad 05 04	lda $0405			lda 	Num_Buffer 					; is first character -
.01879e	c9 2d		cmp #$2d			cmp 	#"-"
.0187a0	f0 05		beq $0187a7			beq 	_CPRNoSpace
.0187a2	a9 20		lda #$20			lda 	#" "						; print the leading space
.0187a4	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter 			; so beloved of MS Basics.
.0187a7					_CPRNoSpace:
.0187a7	a2 04		ldx #$04			ldx 	#(Num_Buffer-1) & $FF
.0187a9	a9 04		lda #$04			lda 	#(Num_Buffer-1) >> 8
.0187ab	80 06		bra $0187b3			bra 	_CPRPrint
.0187ad					_CPR_String:
.0187ad	ae 08 03	ldx $0308			ldx 	XS_Mantissa
.0187b0	ad 09 03	lda $0309			lda 	XS_Mantissa+1
.0187b3					_CPRPrint:
.0187b3	86 1e		stx $1e				stx 	zGenPtr
.0187b5	85 1f		sta $1f				sta 	zGenPtr+1
.0187b7	5a		phy				phy
.0187b8	a0 00		ldy #$00			ldy 	#0							; get length into X
.0187ba	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.0187bc	aa		tax				tax
.0187bd	f0 09		beq $0187c8			beq 	_CPREndPrint 				; nothing to print
.0187bf					_CPRLoop:
.0187bf	c8		iny				iny
.0187c0	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.0187c2	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0187c5	ca		dex				dex
.0187c6	d0 f7		bne $0187bf			bne 	_CPRLoop
.0187c8					_CPREndPrint:
.0187c8	7a		ply				ply
.0187c9	80 a1		bra $01876c			bra 	Command_Print
.0187cb					_CPR_Tab:
.0187cb	20 4f 80	jsr $01804f			jsr 	IFT_Tab
.0187ce					_CPR_Skip:
.0187ce	c8		iny				iny
.0187cf	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0187d1	c9 be		cmp #$be			cmp 	#token_Colon 				; colon or $00, exit
.0187d3	f0 09		beq $0187de			beq 	_CPR_Exit
.0187d5	c9 00		cmp #$00			cmp 	#0
.0187d7	d0 93		bne $01876c			bne 	Command_PRINT 				; if not go round again.
.0187d9	80 03		bra $0187de			bra 	_CPR_Exit
.0187db					_CPR_NewLine:
.0187db	20 5c 80	jsr $01805c			jsr 	IFT_NewLine
.0187de					_CPR_Exit:
.0187de	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/assert.asm

.0187df					Command_ASSERT:
.0187df	20 ba 89	jsr $0189ba			jsr 	EvaluateNumber 				; calculate thing being asserted
.0187e2	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; check if true (non-zero)
.0187e5	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.0187e8	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.0187eb	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.0187ee	f0 01		beq $0187f1			beq 	_ASFail
.0187f0	60		rts				rts
.0187f1					_ASFail:
.0187f1	20 2f 84	jsr $01842f			jsr ERR_Handler
>0187f4	41 73 73 65 72 74 00			.text "Assert",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.0187fb					Command_CLR:
.0187fb					ResetRunStatus:
.0187fb	20 fa 90	jsr $0190fa			jsr 	VariableClear
.0187fe	a9 00		lda #$00			lda 	#HighMemory & $FF
.018800	8d 00 04	sta $0400			sta 	StringPtr
.018803	a9 80		lda #$80			lda 	#HighMemory >> 8
.018805	8d 01 04	sta $0401			sta 	StringPtr+1
.018808	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/stop.asm

.018809					Command_STOP:
.018809	20 2f 84	jsr $01842f			jsr ERR_Handler
>01880c	53 74 6f 70 00				.text "Stop",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.018811					EVESyntax:
.018811	4c 00 84	jmp $018400			jmp 	SyntaxError
.018814					EvaluateExpression:
.018814	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.018816					EvaluateExpressionX:
.018816	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.018818					EvaluateExpressionXA:
.018818	48		pha				pha 								; save precedence on stack.
.018819	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01881b	f0 f4		beq $018811			beq 	EVESyntax 					; end of line, syntax error.
.01881d	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.01881f	b0 03		bcs $018824			bcs 	_EVNotVariable
.018821	4c 1b 89	jmp $01891b			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.018824					_EVNotVariable:
.018824	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.018826	90 e9		bcc $018811			bcc 	EVESyntax
.018828	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.01882a	b0 7f		bcs $0188ab			bcs 	_EVNotInteger
.01882c	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.01882e	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.018831	a9 00		lda #$00			lda 	#0
.018833	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018836	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018839	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.01883c	1a		inc a				inc 	a 							; set to type 1 (integer)
.01883d	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018840					_EVCheckNextInteger:
.018840	c8		iny				iny
.018841	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018843	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.018845	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.018847	b0 0d		bcs $018856			bcs 	_EVCheckDecimal
.018849	48		pha				pha 								; save it.
.01884a	20 27 89	jsr $018927			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.01884d	68		pla				pla
.01884e	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.018851	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018854	80 ea		bra $018840			bra 	_EVCheckNextInteger
.018856					_EVCheckDecimal:
.018856	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018858	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.01885a	d0 05		bne $018861			bne 	_EVGotAtom 					; no, get atom.
.01885c					_EVIsDecimal:
.01885c	20 57 89	jsr $018957			jsr 	EVGetDecimal 				; extend to the decimal part.
.01885f	80 00		bra $018861			bra 	_EVGotAtom 					; and continue to got atom.
.018861					_EVGotAtom:
.018861	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018863	10 44		bpl $0188a9			bpl 	_EVExitDrop 				; must be a token.
.018865	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.018867	b0 40		bcs $0188a9			bcs 	_EVExitDrop
.018869	68		pla				pla 								; get current precedence
.01886a	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.01886c	da		phx				phx 								; save X
.01886d	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01886f	aa		tax				tax 								; put in X
.018870	bf dd 84 01	lda $0184dd,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.018874	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.018876	fa		plx				plx 								; restore X
.018877	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.018879	90 2f		bcc $0188aa			bcc 	_EVExit 					; exit if too low.
.01887b	f0 2d		beq $0188aa			beq 	_EVExit 					; exit if equals
.01887d	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.01887f	48		pha				pha
.018880	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018882	48		pha				pha
.018883	c8		iny				iny
.018884	da		phx				phx 								; save current position
.018885	e8		inx				inx
.018886	e8		inx				inx
.018887	e8		inx				inx
.018888	e8		inx				inx
.018889	e8		inx				inx
.01888a	e8		inx				inx
.01888b	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.01888d	20 18 88	jsr $018818			jsr 	EvaluateExpressionXA 		; do the RHS.
.018890	fa		plx				plx 								; restore X
.018891	68		pla				pla 								; get the binary operator in A.
.018892					_EVCallA:
.018892	da		phx				phx 								; save X again
.018893	0a		asl a				asl 	a 							; double, lose the MSB.
.018894	aa		tax				tax									; put in X
.018895	bf 96 84 01	lda $018496,x			lda 	VectorTable,x 				; copy address into zGenPtr
.018899	8d 05 03	sta $0305			sta 	LocalVector+1
.01889c	bf 97 84 01	lda $018497,x			lda 	VectorTable+1,x
.0188a0	8d 06 03	sta $0306			sta 	LocalVector+2
.0188a3	fa		plx				plx 								; restore X
.0188a4	20 24 89	jsr $018924			jsr 	EVCallLocalVector
.0188a7	80 b8		bra $018861			bra 	_EVGotAtom 					; and loop back.
.0188a9					_EVExitDrop:
.0188a9	68		pla				pla
.0188aa					_EVExit:
.0188aa	60		rts				rts
.0188ab					_EVNotInteger:
.0188ab	c8		iny				iny
.0188ac	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.0188ae	d0 19		bne $0188c9			bne 	_EVNotMinus
.0188b0	20 a8 89	jsr $0189a8			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.0188b3	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.0188b6	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.0188b8	f0 05		beq $0188bf			beq 	_EVMinusFloat
.0188ba	20 2b 94	jsr $01942b			jsr 	IntegerNegateAlways 		; negation
.0188bd	80 a2		bra $018861			bra 	_EVGotAtom 					; and go back.
.0188bf					_EVMinusFloat:
.0188bf	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; invert the sign bit.
.0188c2	49 80		eor #$80			eor 	#$80
.0188c4	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0188c7	80 98		bra $018861			bra 	_EVGotAtom
.0188c9					_EVNotMinus:
.0188c9	c9 bb		cmp #$bb			cmp 	#token_lparen 				; is it left parenthesis
.0188cb	d0 17		bne $0188e4			bne 	_EVNotParenthesis
.0188cd	20 16 88	jsr $018816			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.0188d0	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0188d2	c8		iny				iny
.0188d3	c9 bc		cmp #$bc			cmp 	#token_rparen 				; okay if right bracket.
.0188d5	f0 8a		beq $018861			beq 	_EVGotAtom
.0188d7	20 2f 84	jsr $01842f			jsr ERR_Handler
>0188da	4d 69 73 73 69 6e 67 20			.text "Missing )",0
>0188e2	29 00
.0188e4					_EVNotParenthesis:
.0188e4	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.0188e6	d0 0c		bne $0188f4			bne 	_EVNotNot
.0188e8	20 a8 89	jsr $0189a8			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.0188eb	20 39 99	jsr $019939			jsr 	FPUToInteger 				; make it an integer - if possible.
.0188ee	20 85 89	jsr $018985			jsr 	NotInteger 					; do the not calculation
.0188f1	4c 61 88	jmp $018861			jmp 	_EVGotAtom
.0188f4					_EVNotNot:
.0188f4	c9 fe		cmp #$fe			cmp 	#$FE
.0188f6	d0 15		bne $01890d			bne 	_EVNotString
.0188f8	20 c8 90	jsr $0190c8			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.0188fb	a5 20		lda $20				lda 	zTempStr 					; copy address of string into mantissa
.0188fd	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018900	a5 21		lda $21				lda 	zTempStr+1
.018902	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018905	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.018907	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.01890a	4c 61 88	jmp $018861			jmp 	_EVGotAtom
.01890d					_EVNotString:
.01890d	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.01890f	90 04		bcc $018915			bcc 	_EVBadElement
.018911	c9 b5		cmp #$b5			cmp 	#lastUnaryFunction+1
.018913	90 03		bcc $018918			bcc 	_EVUnaryFunction
.018915					_EVBadElement:
.018915	4c 00 84	jmp $018400			jmp 	SyntaxError
.018918					_EVUnaryFunction:
.018918	4c 92 88	jmp $018892			jmp 	_EVCallA
.01891b					_EVVariableHandler:
.01891b	20 ee 90	jsr $0190ee			jsr 	VariableFind 				; locate a variable
.01891e	20 6d 92	jsr $01926d			jsr 	VariableGet 				; copy into memory.
.018921	4c 61 88	jmp $018861			jmp 	_EVGotAtom 					; and go round.
.018924					EVCallLocalVector:
.018924	6c 05 03	jmp ($0305)			jmp 	(LocalVector+1)
.018927					EVShiftMantissaLeft6:
.018927	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.01892a	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.01892d	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018930	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018933	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018936	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018939	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.01893c	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.01893f	a9 00		lda #$00			lda 	#0
.018941	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018944	20 47 89	jsr $018947			jsr 	_EVSMLShift 					; call it here to do it twice
.018947					_EVSMLShift:
.018947	5e 0c 03	lsr $030c,x			lsr 	XS_Exponent,x
.01894a	7e 0b 03	ror $030b,x			ror 	XS_Mantissa+3,x
.01894d	7e 0a 03	ror $030a,x			ror 	XS_Mantissa+2,x
.018950	7e 09 03	ror $0309,x			ror 	XS_Mantissa+1,x
.018953	7e 08 03	ror $0308,x			ror 	XS_Mantissa+0,x
.018956	60		rts				rts
.018957					EVGetDecimal:
.018957	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.018959	8d 05 04	sta $0405			sta 	Num_Buffer
.01895c	da		phx				phx
.01895d	c8		iny				iny
.01895e	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018960	c8		iny				iny
.018961	3a		dec a				dec 	a								; convert to a string length.
.018962	3a		dec a				dec 	a
.018963	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.018965					_EVGDCopy:
.018965	48		pha				pha 									; save count
.018966	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018968	9d 05 04	sta $0405,x			sta 	Num_Buffer,x
.01896b	e8		inx				inx 									; forward ....
.01896c	c8		iny				iny
.01896d	68		pla				pla 									; get count
.01896e	3a		dec a				dec 	a 								; until zero
.01896f	d0 f4		bne $018965			bne 	_EVGDCopy
.018971	9d 05 04	sta $0405,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.018974	fa		plx				plx 									; restore X
.018975	a9 05		lda #$05			lda 	#Num_Buffer & $FF 				; set zGenPtr
.018977	85 1e		sta $1e				sta 	zGenPtr
.018979	a9 04		lda #$04			lda 	#Num_Buffer >> 8
.01897b	85 1f		sta $1f				sta 	zGenPtr+1
.01897d	5a		phy				phy 									; save Y
.01897e	a0 00		ldy #$00			ldy 	#0 								; start position
.018980	20 2b 9b	jsr $019b2b			jsr 	FPFromString 					; convert current
.018983	7a		ply				ply 									; restore Y
.018984	60		rts				rts
.018985					NotInteger:
.018985	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018988	49 ff		eor #$ff			eor 	#$FF
.01898a	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.01898d	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018990	49 ff		eor #$ff			eor 	#$FF
.018992	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018995	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018998	49 ff		eor #$ff			eor 	#$FF
.01899a	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01899d	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.0189a0	49 ff		eor #$ff			eor 	#$FF
.0189a2	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0189a5	60		rts				rts
.0189a6					EvaluateGetAtom:
.0189a6	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.0189a8					EvaluateGetAtomX:
.0189a8	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.0189aa	20 18 88	jsr $018818			jsr 	EvaluateExpressionXA
.0189ad	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.0189b0	29 0f		and #$0f			and 	#15
.0189b2	c9 02		cmp #$02			cmp 	#2
.0189b4	b0 01		bcs $0189b7			bcs 	EvaluateType
.0189b6	60		rts				rts
.0189b7					EvaluateType:
.0189b7	4c 10 84	jmp $018410			jmp 	TypeError
.0189ba					EvaluateNumber:
.0189ba	a2 00		ldx #$00			ldx 	#0
.0189bc					EvaluateNumberX:
.0189bc	20 16 88	jsr $018816			jsr 	EvaluateExpressionX
.0189bf	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 0/1
.0189c2	29 0f		and #$0f			and 	#15
.0189c4	c9 02		cmp #$02			cmp 	#2
.0189c6	b0 ef		bcs $0189b7			bcs 	EvaluateType
.0189c8	60		rts				rts
.0189c9					EvaluateInteger:
.0189c9	a2 00		ldx #$00			ldx 	#0
.0189cb					EvaluateIntegerX:
.0189cb	20 bc 89	jsr $0189bc			jsr 	EvaluateNumberX
.0189ce	20 39 99	jsr $019939			jsr 	FPUToInteger
.0189d1	60		rts				rts
.0189d2					EvaluateString:
.0189d2	a2 00		ldx #$00			ldx 	#0
.0189d4					EvaluateStringX:
.0189d4	20 16 88	jsr $018816			jsr 	EvaluateExpressionX
.0189d7	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 2
.0189da	29 0f		and #$0f			and 	#15
.0189dc	c9 02		cmp #$02			cmp 	#2
.0189de	d0 d7		bne $0189b7			bne 	EvaluateType
.0189e0	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.0189e3	85 1e		sta $1e				sta 	zGenPtr
.0189e5	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0189e8	85 1f		sta $1f				sta 	zGenPtr+1
.0189ea	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.0189eb					BinaryOp_And:
.0189eb	20 63 8a	jsr $018a63			jsr 	BinaryMakeBothInteger
.0189ee	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.0189f1	3d 0e 03	and $030e,x			and 	XS2_Mantissa+0,x
.0189f4	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0189f7	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.0189fa	3d 0f 03	and $030f,x			and 	XS2_Mantissa+1,x
.0189fd	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018a00	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.018a03	3d 10 03	and $0310,x			and 	XS2_Mantissa+2,x
.018a06	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018a09	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.018a0c	3d 11 03	and $0311,x			and 	XS2_Mantissa+3,x
.018a0f	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018a12	60		rts				rts
.018a13					BinaryOp_Or:
.018a13	20 63 8a	jsr $018a63			jsr 	BinaryMakeBothInteger
.018a16	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.018a19	1d 0e 03	ora $030e,x			ora 	XS2_Mantissa+0,x
.018a1c	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018a1f	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.018a22	1d 0f 03	ora $030f,x			ora 	XS2_Mantissa+1,x
.018a25	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018a28	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.018a2b	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.018a2e	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018a31	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.018a34	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.018a37	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018a3a	60		rts				rts
.018a3b					BinaryOp_Eor:
.018a3b					BinaryOp_Xor:
.018a3b	20 63 8a	jsr $018a63			jsr 	BinaryMakeBothInteger
.018a3e	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.018a41	5d 0e 03	eor $030e,x			eor 	XS2_Mantissa+0,x
.018a44	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018a47	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.018a4a	5d 0f 03	eor $030f,x			eor 	XS2_Mantissa+1,x
.018a4d	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018a50	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.018a53	5d 10 03	eor $0310,x			eor 	XS2_Mantissa+2,x
.018a56	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018a59	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.018a5c	5d 11 03	eor $0311,x			eor 	XS2_Mantissa+3,x
.018a5f	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018a62	60		rts				rts
.018a63					BinaryMakeBothInteger:
.018a63	da		phx				phx 								; save X
.018a64	e8		inx				inx
.018a65	e8		inx				inx
.018a66	e8		inx				inx
.018a67	e8		inx				inx
.018a68	e8		inx				inx
.018a69	e8		inx				inx
.018a6a	20 6e 8a	jsr $018a6e			jsr 	BinaryMakeInteger 			; convert to integer.
.018a6d	fa		plx				plx 								; restore X and fall through.
.018a6e					BinaryMakeInteger:
.018a6e	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type byte.
.018a71	29 0f		and #$0f			and 	#15 						; check type zero
.018a73	f0 04		beq $018a79			beq 	_BMIConvert 				; if float convert to integer.
.018a75	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.018a76	90 04		bcc $018a7c			bcc 	_BMIError
.018a78	60		rts				rts
.018a79					_BMIConvert:
.018a79	4c 39 99	jmp $019939			jmp 	FPUToInteger 				; convert to integer
.018a7c					_BMIError:
.018a7c	4c 10 84	jmp $018410			jmp 	TypeError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.018a7f					Binary_Equal:
.018a7f	20 cb 8a	jsr $018acb			jsr 	CompareValues
.018a82	09 00		ora #$00			ora 	#0
.018a84	f0 04		beq $018a8a			beq 	CCTrue
.018a86	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.018a88	80 02		bra $018a8c			bra 	CCWrite
.018a8a	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.018a8c	9d 08 03	sta $0308,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.018a8f	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018a92	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018a95	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018a98	a9 01		lda #$01			lda 	#1
.018a9a	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; set type to integer whatever.
.018a9d	60		rts				rts
.018a9e					Binary_NotEqual:
.018a9e	20 cb 8a	jsr $018acb			jsr 	CompareValues
.018aa1	09 00		ora #$00			ora 	#0
.018aa3	f0 e1		beq $018a86			beq 	CCFalse
.018aa5	80 e3		bra $018a8a			bra 	CCTrue
.018aa7					Binary_Less:
.018aa7	20 cb 8a	jsr $018acb			jsr 	CompareValues
.018aaa	09 00		ora #$00			ora 	#0
.018aac	30 dc		bmi $018a8a			bmi 	CCTrue
.018aae	80 d6		bra $018a86			bra 	CCFalse
.018ab0					Binary_LessEqual:
.018ab0	20 cb 8a	jsr $018acb			jsr 	CompareValues
.018ab3	c9 01		cmp #$01			cmp 	#1
.018ab5	d0 d3		bne $018a8a			bne 	CCTrue
.018ab7	80 cd		bra $018a86			bra 	CCFalse
.018ab9					Binary_GreaterEqual:
.018ab9	20 cb 8a	jsr $018acb			jsr 	CompareValues
.018abc	09 00		ora #$00			ora 	#0
.018abe	10 ca		bpl $018a8a			bpl 	CCTrue
.018ac0	80 c4		bra $018a86			bra 	CCFalse
.018ac2					Binary_Greater:
.018ac2	20 cb 8a	jsr $018acb			jsr 	CompareValues
.018ac5	c9 01		cmp #$01			cmp 	#1
.018ac7	f0 c1		beq $018a8a			beq 	CCTrue
.018ac9	80 bb		bra $018a86			bra 	CCFalse
.018acb					CompareValues:
.018acb	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and the types together
.018ace	3d 13 03	and $0313,x			and 	XS2_Type,x
.018ad1	c9 02		cmp #$02			cmp 	#2
.018ad3	f0 13		beq $018ae8			beq 	_CVString
.018ad5	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018ad8	3d 13 03	and $0313,x			and 	XS2_Type,x
.018adb	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018adc	90 03		bcc $018ae1			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018ade	4c 2e 8b	jmp $018b2e			jmp 	CompareInteger32 							; so execute code at \1
.018ae1					_BCFloat:
.018ae1	20 fc 8b	jsr $018bfc			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018ae4	4c 48 98	jmp $019848			jmp 	FPCompare 							; and execute code at \2
.018ae7	60		rts				rts
.018ae8					_CVString:
.018ae8	da		phx				phx 								; save XY
.018ae9	5a		phy				phy
.018aea	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.018aed	85 1a		sta $1a				sta		zLTemp1+0
.018aef	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018af2	85 1b		sta $1b				sta 	zLTemp1+1
.018af4	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x
.018af7	85 1c		sta $1c				sta 	zLTemp1+2
.018af9	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.018afc	85 1d		sta $1d				sta 	zLTemp1+3
.018afe	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.018b00	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.018b02	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.018b04	90 02		bcc $018b08			bcc 	_CVCommon
.018b06	b1 1c		lda ($1c),y			lda 	(zLTemp1+2),y
.018b08					_CVCommon:
.018b08	aa		tax				tax 								; put shorter string length in zero.
.018b09	f0 0c		beq $018b17			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.018b0b					_CVCompare:
.018b0b	c8		iny				iny 								; next character
.018b0c	b1 1a		lda ($1a),y			lda 	(zLTemp1),y 				; compare characters
.018b0e	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.018b10	90 13		bcc $018b25			bcc 	_CVReturnLess 				; <
.018b12	d0 15		bne $018b29			bne 	_CVReturnGreater 			; >
.018b14	ca		dex				dex 								; until common length matched.
.018b15	d0 f4		bne $018b0b			bne 	_CVCompare
.018b17					_CVMatch:
.018b17	a0 00		ldy #$00			ldy 	#0
.018b19	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.018b1b	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.018b1d	90 06		bcc $018b25			bcc 	_CVReturnLess 				; <
.018b1f	d0 08		bne $018b29			bne 	_CVReturnGreater 			; >
.018b21	a9 00		lda #$00			lda 	#0
.018b23	80 06		bra $018b2b			bra 	_CVExit 					; same common, same length, same string
.018b25					_CVReturnLess:
.018b25	a9 ff		lda #$ff			lda 	#$FF
.018b27	80 02		bra $018b2b			bra 	_CVExit
.018b29					_CVReturnGreater:
.018b29	a9 01		lda #$01			lda 	#$01
.018b2b					_CVExit:
.018b2b	7a		ply				ply
.018b2c	fa		plx				plx
.018b2d	60		rts				rts
.018b2e					CompareInteger32:
.018b2e	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.018b31	49 80		eor #$80			eor 	#$80
.018b33	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018b36	bd 11 03	lda $0311,x			lda 	XS2_Mantissa+3,x
.018b39	49 80		eor #$80			eor 	#$80
.018b3b	9d 11 03	sta $0311,x			sta 	XS2_Mantissa+3,x
.018b3e	20 d6 8b	jsr $018bd6			jsr 	SubInteger32 				; subtraction
.018b41	90 11		bcc $018b54			bcc 	_CI32Less 					; cc return -1
.018b43	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; check if zero
.018b46	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.018b49	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.018b4c	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.018b4f	f0 02		beq $018b53			beq 	_CI32Exit
.018b51	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.018b53					_CI32Exit:
.018b53	60		rts				rts
.018b54					_CI32Less:
.018b54	a9 ff		lda #$ff			lda 	#$FF
.018b56	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.018b57					BinaryOp_Add:
.018b57	bd 0d 03	lda $030d,x			lda 	XS_Type,x  					; and types together
.018b5a	3d 13 03	and $0313,x			and 	XS2_Type,x
.018b5d	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.018b5f	d0 13		bne $018b74			bne 	_BOAString
.018b61	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018b64	3d 13 03	and $0313,x			and 	XS2_Type,x
.018b67	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018b68	90 03		bcc $018b6d			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018b6a	4c b0 8b	jmp $018bb0			jmp 	AddInteger32 							; so execute code at \1
.018b6d					_BCFloat:
.018b6d	20 fc 8b	jsr $018bfc			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018b70	4c bc 95	jmp $0195bc			jmp 	FPAdd 							; and execute code at \2
.018b73	60		rts				rts
.018b74					_BOAString:
.018b74	4c 17 8c	jmp $018c17			jmp 	ConcatenateString 			; concatenate two strings.
.018b77					BinaryOp_Subtract:
.018b77	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018b7a	3d 13 03	and $0313,x			and 	XS2_Type,x
.018b7d	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018b7e	90 03		bcc $018b83			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018b80	4c d6 8b	jmp $018bd6			jmp 	SubInteger32 							; so execute code at \1
.018b83					_BCFloat:
.018b83	20 fc 8b	jsr $018bfc			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018b86	4c b2 95	jmp $0195b2			jmp 	FPSubtract 							; and execute code at \2
.018b89	60		rts				rts
.018b8a					BinaryOp_Multiply:
.018b8a	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018b8d	3d 13 03	and $0313,x			and 	XS2_Type,x
.018b90	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018b91	90 03		bcc $018b96			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018b93	4c 3e 93	jmp $01933e			jmp 	MulInteger32 							; so execute code at \1
.018b96					_BCFloat:
.018b96	20 fc 8b	jsr $018bfc			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018b99	4c 28 97	jmp $019728			jmp 	FPMultiply 							; and execute code at \2
.018b9c	60		rts				rts
.018b9d					BinaryOp_Divide:
.018b9d	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018ba0	3d 13 03	and $0313,x			and 	XS2_Type,x
.018ba3	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018ba4	90 03		bcc $018ba9			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018ba6	4c 95 93	jmp $019395			jmp 	DivInteger32 							; so execute code at \1
.018ba9					_BCFloat:
.018ba9	20 fc 8b	jsr $018bfc			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018bac	4c a0 96	jmp $0196a0			jmp 	FPDivide 							; and execute code at \2
.018baf	60		rts				rts
.018bb0					AddInteger32:
.018bb0	18		clc				clc
.018bb1	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018bb4	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.018bb7	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018bba	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018bbd	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.018bc0	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018bc3	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018bc6	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.018bc9	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018bcc	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.018bcf	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.018bd2	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018bd5	60		rts				rts
.018bd6					SubInteger32:
.018bd6	38		sec				sec
.018bd7	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018bda	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.018bdd	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018be0	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018be3	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.018be6	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018be9	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018bec	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.018bef	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018bf2	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.018bf5	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.018bf8	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018bfb	60		rts				rts
.018bfc					BinaryMakeBothFloat:
.018bfc	da		phx				phx 								; save X
.018bfd	e8		inx				inx
.018bfe	e8		inx				inx
.018bff	e8		inx				inx
.018c00	e8		inx				inx
.018c01	e8		inx				inx
.018c02	e8		inx				inx
.018c03	20 07 8c	jsr $018c07			jsr 	BinaryMakeFloat 			; convert to float.
.018c06	fa		plx				plx 								; restore X and fall through.
.018c07					BinaryMakeFloat:
.018c07	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type byte.
.018c0a	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.018c0b	b0 04		bcs $018c11			bcs 	_BMFConvert
.018c0d	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.018c0e	b0 04		bcs $018c14			bcs 	_BMFError
.018c10	60		rts				rts
.018c11					_BMFConvert:
.018c11	4c da 98	jmp $0198da			jmp 	FPUToFloat 					; convert to float
.018c14					_BMFError:
.018c14	4c 10 84	jmp $018410			jmp 	TypeError
.018c17					ConcatenateString:
.018c17	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.018c1a	85 1a		sta $1a				sta		zLTemp1+0
.018c1c	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018c1f	85 1b		sta $1b				sta 	zLTemp1+1
.018c21	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x
.018c24	85 1c		sta $1c				sta 	zLTemp1+2
.018c26	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.018c29	85 1d		sta $1d				sta 	zLTemp1+3
.018c2b	5a		phy				phy
.018c2c	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.018c2e	b1 1a		lda ($1a),y			lda 	(zlTemp1),y
.018c30	71 1c		adc ($1c),y			adc 	(zlTemp1+2),y
.018c32	7a		ply				ply
.018c33	b0 37		bcs $018c6c			bcs 	_CSError					; check in range.
.018c35	c9 fe		cmp #$fe			cmp 	#maxString+1
.018c37	b0 33		bcs $018c6c			bcs 	_CSError
.018c39	20 8d 90	jsr $01908d			jsr 	AllocateTempString 			; store the result
.018c3c	20 57 8c	jsr $018c57			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.018c3f	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.018c42	85 1a		sta $1a				sta 	zLTemp1
.018c44	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.018c47	85 1b		sta $1b				sta 	zLTemp1+1
.018c49	20 57 8c	jsr $018c57			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.018c4c	a5 20		lda $20				lda 	zTempStr 					; point current to new string
.018c4e	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018c51	a5 21		lda $21				lda 	zTempStr+1
.018c53	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018c56	60		rts				rts
.018c57					_CSCopyString:
.018c57	da		phx				phx
.018c58	5a		phy				phy
.018c59	a0 00		ldy #$00			ldy 	#0 							; get length
.018c5b	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.018c5d	f0 0a		beq $018c69			beq 	_CSCSExit 					; if zero, exit
.018c5f	aa		tax				tax 								; put in X
.018c60					_CSCSLoop:
.018c60	c8		iny				iny 								; get next char
.018c61	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.018c63	20 b8 90	jsr $0190b8			jsr		WriteTempString 			; copy out
.018c66	ca		dex				dex 								; do whole string
.018c67	d0 f7		bne $018c60			bne 	_CSCSLoop
.018c69					_CSCSExit:
.018c69	7a		ply				ply
.018c6a	fa		plx				plx
.018c6b	60		rts				rts
.018c6c					_CSError:
.018c6c	20 2f 84	jsr $01842f			jsr ERR_Handler
>018c6f	53 74 72 69 6e 67 20 74			.text "String too long",0
>018c77	6f 6f 20 6c 6f 6e 67 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.018c7f					Unary_Sgn:
.018c7f	20 bc 89	jsr $0189bc			jsr 	EvaluateNumberX 			; get value
.018c82	20 4b 90	jsr $01904b			jsr 	CheckNextRParen 			; check right bracket.
.018c85	20 a9 8c	jsr $018ca9			jsr 	GetSignCurrent 				; get sign.
.018c88	09 00		ora #$00			ora 	#0
.018c8a	10 09		bpl $018c95			bpl		UnarySetAInteger			; if 0,1 return that.
.018c8c	80 00		bra $018c8e			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.018c8e					UnarySetAMinus1:
.018c8e	a9 ff		lda #$ff			lda 	#$FF
.018c90	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.018c93	80 05		bra $018c9a			bra 	UnarySetAFill
.018c95					UnarySetAInteger:
.018c95	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.018c98	a9 00		lda #$00			lda 	#0
.018c9a					UnarySetAFill:
.018c9a	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018c9d	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018ca0	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018ca3	a9 01		lda #$01			lda 	#1
.018ca5	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018ca8	60		rts				rts
.018ca9					GetSignCurrent:
.018ca9	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; identify type.
.018cac	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.018cad	90 19		bcc $018cc8			bcc 	_GSCFloat
.018caf	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.018cb2	30 11		bmi $018cc5			bmi 	_GSCMinus1
.018cb4	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x
.018cb7	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.018cba	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.018cbd	d0 03		bne $018cc2			bne 	_GSCPlus1
.018cbf					_GSCZero:
.018cbf	a9 00		lda #$00			lda 	#0
.018cc1	60		rts				rts
.018cc2					_GSCPlus1:
.018cc2	a9 01		lda #$01			lda 	#$01
.018cc4	60		rts				rts
.018cc5					_GSCMinus1:
.018cc5	a9 ff		lda #$ff			lda 	#$FF
.018cc7	60		rts				rts
.018cc8					_GSCFloat:
.018cc8	3c 0d 03	bit $030d,x			bit 	XS_Type,x
.018ccb	70 f2		bvs $018cbf			bvs 	_GSCZero
.018ccd	30 f6		bmi $018cc5			bmi 	_GSCMinus1
.018ccf	80 f1		bra $018cc2			bra 	_GSCPlus1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.018cd1					Unary_Abs:
.018cd1	20 bc 89	jsr $0189bc			jsr 	EvaluateNumberX 			; get value
.018cd4	20 4b 90	jsr $01904b			jsr 	CheckNextRParen 			; check right bracket.
.018cd7	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.018cda	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.018cdc	f0 08		beq $018ce6			beq 	_UAMinusFloat
.018cde	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; check MSB
.018ce1	10 0b		bpl $018cee			bpl 	_UAExit
.018ce3	4c 2b 94	jmp $01942b			jmp 	IntegerNegateAlways 		; negation
.018ce6					_UAMinusFloat:
.018ce6	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; clear the sign bit.
.018ce9	29 7f		and #$7f			and		#$7F
.018ceb	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018cee					_UAExit:
.018cee	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.018cef					Unary_Peek:
.018cef	a9 01		lda #$01			lda 	#1
.018cf1	80 06		bra $018cf9			bra 	UPMain
.018cf3					Unary_Deek:
.018cf3	a9 02		lda #$02			lda 	#2
.018cf5	80 02		bra $018cf9			bra 	UPMain
.018cf7					Unary_Leek:
.018cf7	a9 04		lda #$04			lda 	#4
.018cf9					UPMain:
.018cf9	48		pha				pha 								; set bytes to copy.
.018cfa	20 cb 89	jsr $0189cb			jsr 	EvaluateIntegerX 			; numeric parameter
.018cfd	20 4b 90	jsr $01904b			jsr 	CheckNextRParen 			; right bracket.
.018d00	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.018d03	85 1a		sta $1a				sta 	zLTemp1
.018d05	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018d08	85 1b		sta $1b				sta 	zLTemp1+1
.018d0a	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018d0d	85 1c		sta $1c				sta 	zLTemp1+2
.018d0f	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.018d12	85 1d		sta $1d				sta 	zLTemp1+3
.018d14	a9 00		lda #$00			lda 	#0 							; clear target area
.018d16	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018d19	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018d1c	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018d1f	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018d22	68		pla				pla 								; restore bytes to copy
.018d23	da		phx				phx 								; save XY
.018d24	5a		phy				phy
.018d25	20 22 90	jsr $019022			jsr 	MemRead 					; read the bytes in
.018d28	7a		ply				ply 								; restore and exit
.018d29	fa		plx				plx
.018d2a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.018d2b					Unary_Mod:
.018d2b	20 57 8d	jsr $018d57			jsr 	_UMParameter 				; first parameter
.018d2e	20 53 90	jsr $019053			jsr 	CheckNextComma
.018d31	da		phx				phx 								; second parameter
.018d32	e8		inx				inx
.018d33	e8		inx				inx
.018d34	e8		inx				inx
.018d35	e8		inx				inx
.018d36	e8		inx				inx
.018d37	e8		inx				inx
.018d38	20 57 8d	jsr $018d57			jsr 	_UMParameter
.018d3b	fa		plx				plx
.018d3c	20 4b 90	jsr $01904b			jsr 	CheckNextRParen
.018d3f	20 95 93	jsr $019395			jsr 	DivInteger32 				; divide
.018d42	a5 1a		lda $1a				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.018d44	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018d47	a5 1b		lda $1b				lda 	zLTemp1+1
.018d49	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018d4c	a5 1c		lda $1c				lda 	zLTemp1+2
.018d4e	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018d51	a5 1d		lda $1d				lda 	zLTemp1+3
.018d53	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018d56	60		rts				rts
.018d57					_UMParameter:
.018d57	20 cb 89	jsr $0189cb			jsr 	EvaluateIntegerX 			; get value
.018d5a	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; absolute value
.018d5d	10 03		bpl $018d62			bpl 	_UMNotSigned
.018d5f	20 2b 94	jsr $01942b			jsr 	IntegerNegateAlways
.018d62					_UMNotSigned:
.018d62	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.018d63					Unary_Usr:
.018d63	20 bc 89	jsr $0189bc			jsr 	EvaluateNumberX 			; numeric parameter
.018d66	20 4b 90	jsr $01904b			jsr 	CheckNextRParen 			; right bracket.
.018d69	da		phx				phx 								; save XY
.018d6a	5a		phy				phy
.018d6b	ea		nop				nop
.018d6c	22 00 03 00	jsl $000300			jsl 	UserVector
.018d70	7a		ply				ply 								; and exit
.018d71	fa		plx				plx
.018d72	60		rts				rts
.018d73					USRDefault:
.018d73	20 2f 84	jsr $01842f			jsr ERR_Handler
>018d76	4e 6f 20 55 53 52 20 76			.text "No USR vector.",0
>018d7e	65 63 74 6f 72 2e 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.018d85					Unary_Val:
.018d85	20 d4 89	jsr $0189d4			jsr 	EvaluateStringX 			; get string
.018d88	20 4b 90	jsr $01904b			jsr 	CheckNextRParen 			; check right bracket.
.018d8b	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.018d8e	85 1e		sta $1e				sta 	zGenPtr
.018d90	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018d93	85 1f		sta $1f				sta 	zGenPtr+1
.018d95	5a		phy				phy
.018d96	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.018d98	b1 1e		lda ($1e),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.018d9a	f0 57		beq $018df3			beq 	_UVBadNumber
.018d9c	48		pha				pha 								; save length.
.018d9d	1a		inc a				inc 	a 							; one for the length, one for the terminator
.018d9e	1a		inc a				inc 	a
.018d9f	20 8d 90	jsr $01908d			jsr 	AllocateTempString
.018da2	c8		iny				iny 								; move to the next.
.018da3	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get character
.018da5	49 2d		eor #$2d			eor 	#"-"						; zero if minus sign
.018da7	8d 90 04	sta $0490			sta 	ValSign
.018daa	d0 04		bne $018db0			bne 	_UVNotMinus
.018dac	c8		iny				iny 								; skip over it.
.018dad	68		pla				pla 								; decrement character count.
.018dae	3a		dec a				dec 	a
.018daf	48		pha				pha
.018db0					_UVNotMinus:
.018db0	68		pla				pla 								; this is the count.
.018db1	48		pha		_UVCopy:pha									; copy into new temp string which is ASCIIZ
.018db2	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018db4	c8		iny				iny
.018db5	20 b8 90	jsr $0190b8			jsr 	WriteTempString
.018db8	68		pla				pla
.018db9	3a		dec a				dec 	a
.018dba	d0 f5		bne $018db1			bne 	_UVCopy
.018dbc	20 b8 90	jsr $0190b8			jsr 	WriteTempString 			; make it ASCIIZ
.018dbf	18		clc				clc
.018dc0	a5 20		lda $20				lda 	zTempStr 					; tempstring +1 => genptr
.018dc2	69 01		adc #$01			adc 	#1
.018dc4	85 1e		sta $1e				sta 	zGenPtr
.018dc6	a5 21		lda $21				lda 	zTempStr+1
.018dc8	69 00		adc #$00			adc 	#0
.018dca	85 1f		sta $1f				sta 	zGenPtr+1
.018dcc	18		clc				clc
.018dcd	20 07 95	jsr $019507			jsr 	IntFromString 				; first bit.
.018dd0	b0 21		bcs $018df3			bcs 	_UVBadNumber
.018dd2	20 2b 9b	jsr $019b2b			jsr 	FPFromString				; try for a float part.
.018dd5	ad 90 04	lda $0490			lda 	ValSign 					; was it negative
.018dd8	d0 13		bne $018ded			bne 	_UVNotNegative
.018dda	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; check if integer
.018ddd	4a		lsr a				lsr 	a
.018dde	b0 0a		bcs $018dea			bcs 	_UVInteger
.018de0	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; set sign bit
.018de3	09 80		ora #$80			ora 	#$80
.018de5	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018de8	80 03		bra $018ded			bra 	_UVNotNegative
.018dea					_UVInteger:
.018dea	20 2b 94	jsr $01942b			jsr 	IntegerNegateAlways 		; sign it.
.018ded					_UVNotNegative:
.018ded	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; used everything
.018def	d0 02		bne $018df3			bne 	_UVBadNumber
.018df1	7a		ply				ply
.018df2	60		rts				rts
.018df3					_UVBadNumber:
.018df3	4c 1e 84	jmp $01841e			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.018df6					Unary_Str:
.018df6	20 bc 89	jsr $0189bc			jsr 	EvaluateNumberX 			; numeric parameter
.018df9	20 4b 90	jsr $01904b			jsr 	CheckNextRParen 			; right bracket.
.018dfc	a9 00		lda #$00			lda 	#0 							; reset buffer index
.018dfe	8d 04 04	sta $0404			sta 	NumBufX
.018e01	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.018e04	4a		lsr a				lsr 	a
.018e05	b0 05		bcs $018e0c			bcs 	_USInt 						; if msb set do as integer
.018e07	20 64 9a	jsr $019a64			jsr 	FPToString 					; call fp to str otherwise
.018e0a	80 03		bra $018e0f			bra 	_USDuplicate
.018e0c	20 50 94	jsr $019450	_USInt:	jsr 	IntToString
.018e0f					_USDuplicate:
.018e0f	ad 04 04	lda $0404			lda 	NumBufX 					; chars in buffer
.018e12	1a		inc a				inc 	a 							; one more for length
.018e13	20 8d 90	jsr $01908d			jsr 	AllocateTempString 			; allocate space for it.
.018e16	5a		phy				phy 								; save Y
.018e17	a0 00		ldy #$00			ldy 	#0 							; start copying
.018e19	b9 05 04	lda $0405,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.018e1c	20 b8 90	jsr $0190b8			jsr 	WriteTempString
.018e1f	c8		iny				iny
.018e20	cc 04 04	cpy $0404			cpy 	NumBufX 					; done the lot
.018e23	d0 f4		bne $018e19			bne 	_USCopy
.018e25	7a		ply				ply 								; restore Y
.018e26	4c 12 90	jmp $019012			jmp 	UnaryReturnTempStr 			; return new temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.018e29					Unary_Asc:
.018e29	20 d4 89	jsr $0189d4			jsr 	EvaluateStringX 			; string parameter
.018e2c	20 4b 90	jsr $01904b			jsr 	CheckNextRParen 			; right bracket.
.018e2f	5a		phy				phy 								; get the string length
.018e30	a0 00		ldy #$00			ldy 	#0
.018e32	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018e34	f0 07		beq $018e3d			beq 	_UAIllegal 					; must be at least one character
.018e36	c8		iny				iny
.018e37	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; read it.
.018e39	7a		ply				ply
.018e3a	4c 95 8c	jmp $018c95			jmp 	UnarySetAInteger
.018e3d					_UAIllegal:
.018e3d	4c 1e 84	jmp $01841e			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.018e40					Unary_Len:
.018e40	20 d4 89	jsr $0189d4			jsr 	EvaluateStringX 			; string parameter
.018e43	20 4b 90	jsr $01904b			jsr 	CheckNextRParen 			; right bracket.
.018e46	5a		phy				phy 								; get the string length
.018e47	a0 00		ldy #$00			ldy 	#0
.018e49	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018e4b	7a		ply				ply
.018e4c	4c 95 8c	jmp $018c95			jmp 	UnarySetAInteger

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.018e4f					Unary_Mid:
.018e4f	20 d4 89	jsr $0189d4			jsr 	EvaluateStringX 				; get string.
.018e52	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.018e55	48		pha				pha
.018e56	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018e59	48		pha				pha
.018e5a	20 53 90	jsr $019053			jsr 	CheckNextComma 					; skip comma
.018e5d	20 ea 8e	jsr $018eea			jsr 	SLIByteParameter 				; get a byte parameter (start)
.018e60	48		pha				pha 									; and push it.
.018e61	20 53 90	jsr $019053			jsr 	CheckNextComma 					; skip comma
.018e64	20 ea 8e	jsr $018eea			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.018e67	48		pha				pha 									; and push it.
.018e68	80 45		bra $018eaf			bra 	SLIProcess
.018e6a					Unary_Left:
.018e6a	20 d4 89	jsr $0189d4			jsr 	EvaluateStringX 				; get string.
.018e6d	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.018e70	48		pha				pha
.018e71	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018e74	48		pha				pha
.018e75	a9 01		lda #$01			lda 	#1 								; push start position (1)
.018e77	48		pha				pha
.018e78	20 53 90	jsr $019053			jsr 	CheckNextComma 					; skip comma
.018e7b	20 ea 8e	jsr $018eea			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.018e7e	48		pha				pha 									; and push it.
.018e7f	80 2e		bra $018eaf			bra 	SLIProcess
.018e81					Unary_Right:
.018e81	20 d4 89	jsr $0189d4			jsr 	EvaluateStringX 				; get string.
.018e84	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.018e87	48		pha				pha
.018e88	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018e8b	48		pha				pha
.018e8c	da		phx				phx 									; get the string length and push on stack.
.018e8d	a2 00		ldx #$00			ldx 	#0
.018e8f	a1 1e		lda ($1e,x)			lda		(zGenPtr,x)
.018e91	fa		plx				plx
.018e92	48		pha				pha
.018e93	20 53 90	jsr $019053			jsr 	CheckNextComma 					; skip comma
.018e96	20 ea 8e	jsr $018eea			jsr 	SLIByteParameter 				; get a byte parameter.
.018e99	8d 8e 04	sta $048e			sta 	SignCount 						; save in temporary.
.018e9c	68		pla				pla 									; restore string length.
.018e9d	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.018e9e	38		sec				sec
.018e9f	ed 8e 04	sbc $048e			sbc 	SignCount 						; subtract characters needed, gives start position.
.018ea2	f0 02		beq $018ea6			beq 	_URStart 						; if <= 0 start from 1.
.018ea4	10 02		bpl $018ea8			bpl 	_UROkay
.018ea6					_URStart:
.018ea6	a9 01		lda #$01			lda 	#1
.018ea8					_UROkay:
.018ea8	48		pha				pha 									; push start
.018ea9	ad 8e 04	lda $048e			lda 	SignCount 						; push count of characters
.018eac	48		pha				pha
.018ead	80 00		bra $018eaf			bra 	SLIProcess
.018eaf					SLIProcess:
.018eaf	20 4b 90	jsr $01904b			jsr 	CheckNextRParen 				; closing right bracket.
.018eb2	68		pla				pla
.018eb3	8d 92 04	sta $0492			sta 	SliceCount 						; count in signcount
.018eb6	1a		inc a				inc 	a 								; allocate +1 for it.
.018eb7	20 8d 90	jsr $01908d			jsr 	AllocateTempString
.018eba	68		pla				pla 									; pop start number off stack.
.018ebb	f0 3f		beq $018efc			beq 	SLIError 						; exit if start = 0
.018ebd	8d 91 04	sta $0491			sta 	SliceStart
.018ec0	68		pla				pla  									; pop string address.
.018ec1	85 1f		sta $1f				sta 	zGenPtr+1
.018ec3	68		pla				pla
.018ec4	85 1e		sta $1e				sta 	zGenPtr
.018ec6	da		phx				phx
.018ec7	5a		phy				phy
.018ec8	a2 00		ldx #$00			ldx 	#0 								; point to string length.
.018eca	ac 91 04	ldy $0491			ldy 	SliceStart 						; start of the string (+1 for count)
.018ecd					_SLICopy:
.018ecd	ad 92 04	lda $0492			lda 	SliceCount 						; done count characters
.018ed0	f0 12		beq $018ee4			beq 	_SLIExit
.018ed2	ce 92 04	dec $0492			dec 	SliceCount
.018ed5	98		tya				tya 									; index of character
.018ed6	c1 1e		cmp ($1e,x)			cmp 	(zGenPtr,x)						; compare against length
.018ed8	f0 02		beq $018edc			beq 	_SLIOk 							; if equal, okay.
.018eda	b0 08		bcs $018ee4			bcs 	_SLIExit 						; if past end, then exit.
.018edc	b1 1e		lda ($1e),y	_SLIOk:	lda 	(zGenPtr),y 					; copy one character
.018ede	c8		iny				iny
.018edf	20 b8 90	jsr $0190b8			jsr 	WriteTempString
.018ee2	80 e9		bra $018ecd			bra 	_SLICopy 						; go round till copied characters
.018ee4					_SLIExit:
.018ee4	7a		ply				ply 									; restore YX
.018ee5	fa		plx				plx
.018ee6	4c 12 90	jmp $019012			jmp 	UnaryReturnTempStr 				; return new temporary string.
.018ee9	ea		nop				nop
.018eea					SLIByteParameter:
.018eea	20 cb 89	jsr $0189cb			jsr 	EvaluateIntegerX 				; get integer
.018eed	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.018ef0	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.018ef3	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.018ef6	d0 04		bne $018efc			bne 	SLIError
.018ef8	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018efb	60		rts				rts
.018efc					SLIError:
.018efc	4c 1e 84	jmp $01841e			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.018eff					Unary_Hex:
.018eff	20 cb 89	jsr $0189cb			jsr 	EvaluateIntegerX 			; numeric parameter
.018f02	20 4b 90	jsr $01904b			jsr 	CheckNextRParen 			; right bracket.
.018f05	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.018f07	20 8d 90	jsr $01908d			jsr 	AllocateTempString			; allocate string space
.018f0a	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.018f0d	20 34 8f	jsr $018f34			jsr 	_UHConvert
.018f10	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018f13	20 34 8f	jsr $018f34			jsr 	_UHConvert
.018f16	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018f19	20 34 8f	jsr $018f34			jsr 	_UHConvert
.018f1c	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018f1f	20 34 8f	jsr $018f34			jsr 	_UHConvert
.018f22	5a		phy				phy 								; get length of new string
.018f23	a0 00		ldy #$00			ldy 	#0
.018f25	b1 20		lda ($20),y			lda 	(zTempStr),y
.018f27	7a		ply				ply
.018f28	c9 00		cmp #$00			cmp 	#0
.018f2a	d0 05		bne $018f31			bne 	_UHExit 					; if it was non zero okay
.018f2c	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.018f2e	20 b8 90	jsr $0190b8			jsr 	WriteTempString
.018f31					_UHExit:
.018f31	4c 12 90	jmp $019012			jmp 	UnaryReturnTempStr 			; return new temporary string.
.018f34					_UHConvert:
.018f34	48		pha				pha
.018f35	4a		lsr a				lsr 	a 							; do MSB
.018f36	4a		lsr a				lsr 	a
.018f37	4a		lsr a				lsr 	a
.018f38	4a		lsr a				lsr 	a
.018f39	20 3d 8f	jsr $018f3d			jsr 	_UHNibble
.018f3c	68		pla				pla 								; do LSB
.018f3d					_UHNibble:
.018f3d	29 0f		and #$0f			and 	#15 						; get nibble
.018f3f	d0 0c		bne $018f4d			bne 	_UHNonZero
.018f41	5a		phy				phy									; get the length
.018f42	a0 00		ldy #$00			ldy 	#0
.018f44	b1 20		lda ($20),y			lda 	(zTempStr),y
.018f46	7a		ply				ply
.018f47	c9 00		cmp #$00			cmp 	#0 							; suppress leading zeros.
.018f49	f0 0d		beq $018f58			beq 	_UHExit2
.018f4b	a9 00		lda #$00			lda 	#0
.018f4d					_UHNonZero:
.018f4d	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.018f4f	90 02		bcc $018f53			bcc 	_UHDigit
.018f51	69 06		adc #$06			adc 	#7-1
.018f53					_UHDigit:
.018f53	69 30		adc #$30			adc 	#48
.018f55	20 b8 90	jsr $0190b8			jsr 	WriteTempString				; output.
.018f58					_UHExit2:
.018f58	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.018f59					Unary_Dec:
.018f59	20 d4 89	jsr $0189d4			jsr 	EvaluateStringX 			; string parameter
.018f5c	20 4b 90	jsr $01904b			jsr 	CheckNextRParen 			; right bracket.
.018f5f	5a		phy				phy
.018f60	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.018f62	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018f64	f0 4c		beq $018fb2			beq 	_UDFail 					; must fail if zero.
.018f66	8d 8e 04	sta $048e			sta 	SignCount 					; use SignCount as a counter
.018f69	a9 00		lda #$00			lda 	#0 							; set result to zero integer.
.018f6b	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018f6e	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018f71	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018f74	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018f77	a9 01		lda #$01			lda 	#1
.018f79	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018f7c					_UDConvertLoop:
.018f7c	5a		phy				phy 								; shift mantissa left 4
.018f7d	a0 04		ldy #$04			ldy 	#4
.018f7f					_UDShift:
.018f7f	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x
.018f82	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.018f85	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.018f88	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.018f8b	88		dey				dey
.018f8c	d0 f1		bne $018f7f			bne 	_UDShift
.018f8e	7a		ply				ply
.018f8f	c8		iny				iny 								; next character
.018f90	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; fetch it.
.018f92	20 b5 8f	jsr $018fb5			jsr 	ConvertUpper 				; convert to U/C
.018f95	c9 30		cmp #$30			cmp 	#"0"
.018f97	90 19		bcc $018fb2			bcc 	_UDFail
.018f99	c9 3a		cmp #$3a			cmp 	#"9"+1
.018f9b	90 06		bcc $018fa3			bcc 	_UDOkay
.018f9d	e9 37		sbc #$37			sbc 	#7+"0" 						; alpha fudge
.018f9f	c9 10		cmp #$10			cmp 	#16
.018fa1	b0 0f		bcs $018fb2			bcs 	_UDFail
.018fa3					_UDOkay:
.018fa3	29 0f		and #$0f			and 	#15 						; nibble only
.018fa5	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x
.018fa8	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018fab	ce 8e 04	dec $048e			dec 	SignCount 					; do it for each character
.018fae	d0 cc		bne $018f7c			bne 	_UDConvertLoop
.018fb0	7a		ply				ply
.018fb1	60		rts				rts
.018fb2					_UDFail:
.018fb2	4c 1e 84	jmp $01841e			jmp 	BadParamError
.018fb5					ConvertUpper:
.018fb5	c9 61		cmp #$61			cmp 	#"a"
.018fb7	90 07		bcc $018fc0			bcc 	_CUExit
.018fb9	c9 7b		cmp #$7b			cmp 	#"z"+1
.018fbb	b0 03		bcs $018fc0			bcs 	_CUExit
.018fbd	38		sec				sec
.018fbe	e9 20		sbc #$20			sbc 	#32
.018fc0	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.018fc1					Unary_Chr:
.018fc1	20 cb 89	jsr $0189cb			jsr 	EvaluateIntegerX			; numeric parameter
.018fc4	20 4b 90	jsr $01904b			jsr 	CheckNextRParen 			; right bracket.
.018fc7	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.018fca	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.018fcd	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.018fd0	d0 0e		bne $018fe0			bne 	_UCChar
.018fd2	a9 01		lda #$01			lda 	#1 							; one character string
.018fd4	20 8d 90	jsr $01908d			jsr 	AllocateTempString
.018fd7	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.018fda	20 b8 90	jsr $0190b8			jsr 	WriteTempString
.018fdd	4c 12 90	jmp $019012			jmp 	UnaryReturnTempStr
.018fe0					_UCChar:
.018fe0	4c 1e 84	jmp $01841e			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.018fe3					Unary_Spc:
.018fe3	20 cb 89	jsr $0189cb			jsr 	EvaluateIntegerX 			; numeric parameter
.018fe6	20 4b 90	jsr $01904b			jsr 	CheckNextRParen 			; right bracket.
.018fe9	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.018fec	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.018fef	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.018ff2	d0 1b		bne $01900f			bne 	_USSize
.018ff4	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018ff7	c9 fe		cmp #$fe			cmp 	#maxString+1
.018ff9	b0 14		bcs $01900f			bcs 	_USSize
.018ffb	48		pha				pha 								; save length
.018ffc	1a		inc a				inc 	a 							; allocate one more.
.018ffd	20 8d 90	jsr $01908d			jsr 	AllocateTempString
.019000	68		pla				pla 								; get length
.019001	f0 0f		beq $019012			beq 	UnaryReturnTempStr 			; return the current temp string
.019003					_USLoop:
.019003	48		pha				pha
.019004	a9 20		lda #$20			lda 	#" "
.019006	20 b8 90	jsr $0190b8			jsr 	WriteTempString
.019009	68		pla				pla
.01900a	3a		dec a				dec 	a
.01900b	d0 f6		bne $019003			bne 	_USLoop
.01900d	80 03		bra $019012			bra 	UnaryReturnTempStr
.01900f					_USSize:
.01900f	4c 1e 84	jmp $01841e			jmp 	BadParamError
.019012					UnaryReturnTempStr:
.019012	a5 20		lda $20				lda 	zTempStr 					; copy temp string addr -> mantissa
.019014	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019017	a5 21		lda $21				lda 	zTempStr+1
.019019	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.01901c	a9 02		lda #$02			lda 	#2 							; set type to string
.01901e	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019021	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/65816.asm

.019022					MemRead:
.019022	8d 8e 04	sta $048e			sta 	SignCount 					; save count
.019025	a0 00		ldy #$00			ldy 	#0 							; start from here
.019027	b7 1a		lda [$1a],y	_MLoop1:lda 	[zlTemp1],y 				; read the long address
.019029	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; copy into mantissa
.01902c	c8		iny				iny 								; next to copy
.01902d	e8		inx				inx
.01902e	cc 8e 04	cpy $048e			cpy 	SignCount 					; do required # of bytes.
.019031	d0 f4		bne $019027			bne 	_MLoop1
.019033	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.019034					CheckNextToken:
.019034	d7 16		cmp [$16],y			cmp 	[zCodePtr],y
.019036	d0 02		bne $01903a			bne 	CTFail 						; no, then fail
.019038	c8		iny				iny
.019039	60		rts				rts
.01903a					CTFail:
.01903a	20 2f 84	jsr $01842f			jsr ERR_Handler
>01903d	4d 69 73 73 69 6e 67 20			.text "Missing token",0
>019045	74 6f 6b 65 6e 00
.01904b					CheckNextRParen:
.01904b	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01904d	c9 bc		cmp #$bc			cmp 	#token_rparen
.01904f	d0 e9		bne $01903a			bne 	CTFail
.019051	c8		iny				iny
.019052	60		rts				rts
.019053					CheckNextComma:
.019053	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019055	c9 bd		cmp #$bd			cmp 	#token_comma
.019057	d0 e1		bne $01903a			bne 	CTFail
.019059	c8		iny				iny
.01905a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/concrete.asm

.01905b					StringConcrete:
.01905b	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; save source to zTemp1
.01905e	85 10		sta $10				sta 	zTemp1
.019060	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.019063	85 11		sta $11				sta 	zTemp1+1
.019065	a0 00		ldy #$00			ldy 	#0 							; subtract the length+1 (clc) of the string.
.019067	18		clc				clc 								; from the string pointer
.019068	ad 00 04	lda $0400			lda 	StringPtr 					; and put in zTemp2 as well
.01906b	f1 10		sbc ($10),y			sbc 	(zTemp1),y
.01906d	8d 00 04	sta $0400			sta 	StringPtr
.019070	85 12		sta $12				sta 	zTemp2
.019072	ad 01 04	lda $0401			lda 	StringPtr+1
.019075	e9 00		sbc #$00			sbc 	#0
.019077	8d 01 04	sta $0401			sta 	StringPtr+1
.01907a	85 13		sta $13				sta 	zTemp2+1
.01907c	b1 10		lda ($10),y			lda 	(zTemp1),y 					; length add one for count
.01907e	1a		inc a				inc 	a
.01907f	aa		tax				tax
.019080	b1 10		lda ($10),y	_SCCopy:lda 	(zTemp1),y 					; copy whole thing including length
.019082	91 12		sta ($12),y			sta 	(zTemp2),y
.019084	c8		iny				iny
.019085	ca		dex				dex
.019086	d0 f8		bne $019080			bne 	_SCCopy
.019088	a5 13		lda $13				lda 	zTemp2+1 					; return concrete string in AX
.01908a	a6 12		ldx $12				ldx 	zTemp2
.01908c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.01908d					AllocateTempString:
.01908d	48		pha				pha 								; save required count.
.01908e	a5 21		lda $21				lda 	zTempStr+1 					; check if initialised yet ?
.019090	d0 0b		bne $01909d			bne 	_ATSInitialised
.019092	ad 00 04	lda $0400			lda 	StringPtr 					; set temporary string ptr 1 page below available
.019095	85 20		sta $20				sta 	zTempStr					; space, this is for strings to be concreted.
.019097	ad 01 04	lda $0401			lda 	StringPtr+1
.01909a	3a		dec a				dec 	a
.01909b	85 21		sta $21				sta 	zTempStr+1
.01909d					_ATSInitialised:
.01909d	68		pla				pla 								; get required count back.
.01909e	49 ff		eor #$ff			eor 	#$FF 						; negate 2's complement.
.0190a0	1a		inc a				inc 	a
.0190a1	18		clc				clc
.0190a2	65 20		adc $20				adc 	zTempStr 					; "add" to the temp string pointer
.0190a4	85 20		sta $20				sta 	zTempStr
.0190a6	a9 ff		lda #$ff			lda 	#$FF
.0190a8	65 21		adc $21				adc 	zTempStr+1
.0190aa	85 21		sta $21				sta 	zTempStr+1
.0190ac	a9 00		lda #$00			lda 	#0 							; clear temp string.
.0190ae	5a		phy				phy
.0190af	a8		tay				tay
.0190b0	91 20		sta ($20),y			sta 	(zTempStr),y
.0190b2	7a		ply				ply
.0190b3	1a		inc a				inc 	a 							; reset the write index.
.0190b4	8d 8f 04	sta $048f			sta 	TempStringWriteIndex
.0190b7	60		rts				rts
.0190b8					WriteTempString:
.0190b8	5a		phy				phy 								; save Y
.0190b9	ac 8f 04	ldy $048f			ldy 	TempStringWriteIndex	 	; write position.
.0190bc	91 20		sta ($20),y			sta 	(zTempStr),y 				; write character out.
.0190be	ee 8f 04	inc $048f			inc 	TempStringWriteIndex 		; increment the write position.
.0190c1	98		tya				tya 								; unchanged Y is now length
.0190c2	a0 00		ldy #$00			ldy 	#0
.0190c4	91 20		sta ($20),y			sta 	(zTempStr),y
.0190c6	7a		ply				ply 								; restore Y and exit
.0190c7	60		rts				rts
.0190c8					CreateTempStringCopy:
.0190c8	da		phx				phx 								; save X
.0190c9	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0190cb	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.0190cc	20 8d 90	jsr $01908d			jsr 	AllocateTempString 			; allocate memory for temporary string.
.0190cf	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0190d1	c8		iny				iny
.0190d2	3a		dec a				dec 	a 							; make the actual length in charactes
.0190d3	3a		dec a				dec 	a
.0190d4	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.0190d6	81 20		sta ($20,x)			sta 	(zTempStr,x)
.0190d8	85 1a		sta $1a				sta 	zLTemp1 					; that's used as a count.
.0190da	09 00		ora #$00			ora 	#0 							; if zero already, exit
.0190dc	f0 0e		beq $0190ec			beq 	_CTSCExit
.0190de					_CTSCLoop:
.0190de	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0190e0	c8		iny				iny
.0190e1	5a		phy				phy 								; save in Y
.0190e2	e8		inx				inx 								; bump index
.0190e3	da		phx				phx 								; index into Y
.0190e4	7a		ply				ply
.0190e5	91 20		sta ($20),y			sta 	(zTempStr),y 				; save at index
.0190e7	7a		ply				ply 								; restore Y
.0190e8	c6 1a		dec $1a				dec 	zLTemp1 					; do for each character
.0190ea	d0 f2		bne $0190de			bne 	_CTSCLoop
.0190ec					_CTSCExit:
.0190ec	fa		plx				plx 								; restore X
.0190ed	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/variables.asm

.0190ee					VariableFind:
.0190ee	20 29 91	jsr $019129			jsr 	VariableExtract 		; find out all about it ....
.0190f1	20 29 92	jsr $019229			jsr 	VariableLocate 			; does it already exist ?
.0190f4	b0 03		bcs $0190f9			bcs 	_VFExists 				; if so, use that.
.0190f6	20 b5 91	jsr $0191b5			jsr 	VariableCreate 			; otherwise create it.
.0190f9					_VFExists:
.0190f9	60		rts				rts
.0190fa					VariableClear:
.0190fa	48		pha				pha 							; save registers
.0190fb	da		phx				phx
.0190fc	a2 00		ldx #$00			ldx 	#0 						; clear out the hash table.
.0190fe	8a		txa				txa
.0190ff	9d 25 04	sta $0425,x	_VCLoop:sta 	HashTableBase,x
.019102	e8		inx				inx
.019103	e0 60		cpx #$60			cpx 	#HashTableEnd-HashTableBase
.019105	d0 f8		bne $0190ff			bne 	_VCLoop
.019107	a9 00		lda #$00			lda 	#VariableMemory & $FF	; reset the free variable memory pointer
.019109	8d 02 04	sta $0402			sta 	VarMemPtr
.01910c	a9 40		lda #$40			lda 	#VariableMemory >> 8
.01910e	8d 03 04	sta $0403			sta 	VarMemPtr+1
.019111	fa		plx				plx 							; restore registers
.019112	68		pla				pla
.019113	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/extract.asm

.019114					VariableNameError:
.019114	20 2f 84	jsr $01842f			jsr ERR_Handler
>019117	42 61 64 20 56 61 72 69			.text "Bad Variable Name",0
>01911f	61 62 6c 65 20 4e 61 6d 65 00
.019129					VariableExtract:
.019129	da		phx				phx 							; save X.
.01912a	a9 b8		lda #$b8			lda 	#token_hashlParen  		; set the type to #( e.g. real array.
.01912c	8d 85 04	sta $0485			sta 	Var_Type
.01912f	8d 86 04	sta $0486			sta 	Var_Hash 				; we initialise the hash with this. It doesn't matter
.019132	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019134	c9 00		cmp #$00			cmp 	#0 						; first one must be A-Z
.019136	f0 dc		beq $019114			beq 	VariableNameError
.019138	c9 1b		cmp #$1b			cmp 	#26+1
.01913a	b0 d8		bcs $019114			bcs 	VariableNameError
.01913c	a2 ff		ldx #$ff			ldx 	#255 					; now copy it into the variable buffer.
.01913e					_VECopyBuffer:
.01913e	e8		inx				inx
.01913f	e0 1f		cpx #$1f			cpx 	#31 					; too long
.019141	f0 d1		beq $019114			beq 	VariableNameError
.019143	9d 05 04	sta $0405,x			sta 	Var_Buffer,x 			; save character
.019146	18		clc				clc  							; update the hash value for it.
.019147	6d 86 04	adc $0486			adc 	Var_Hash
.01914a	8d 86 04	sta $0486			sta 	Var_Hash
.01914d	c8		iny				iny
.01914e	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019150	c9 00		cmp #$00			cmp 	#0 						; zero or token, end of variable
.019152	f0 0e		beq $019162			beq 	_VECopyEnd
.019154	30 0c		bmi $019162			bmi 	_VECopyEnd
.019156	c9 1b		cmp #$1b			cmp 	#26+1 					; A-Z continue copying
.019158	90 e4		bcc $01913e			bcc 	_VECopyBuffer
.01915a	c9 30		cmp #$30			cmp 	#"0" 					; 0-9 copy as well.
.01915c	90 04		bcc $019162			bcc 	_VECopyEnd
.01915e	c9 3a		cmp #$3a			cmp 	#"9"+1
.019160	90 dc		bcc $01913e			bcc 	_VECopyBuffer
.019162					_VECopyEnd:
.019162	c8		iny				iny
.019163	c9 b5		cmp #$b5			cmp 	#token_Dollar 			; first type token.
.019165	90 04		bcc $01916b			bcc 	_VEDefaultRequired
.019167	c9 bb		cmp #$bb			cmp 	#token_PercentLParen+1	; last type token.
.019169	90 0b		bcc $019176			bcc 	_VEHaveType
.01916b					_VEDefaultRequired:
.01916b	c9 bb		cmp #$bb			cmp 	#token_LParen 			; if it ends in ( then use the real array
.01916d	f0 04		beq $019173			beq 	_VESetType 				; default set above.
.01916f	ce 85 04	dec $0485			dec 	Var_Type 				; this changes that default to the variable default
.019172	88		dey				dey
.019173					_VESetType:
.019173	ad 85 04	lda $0485			lda 	Var_Type 				; get type ....
.019176					_VEHaveType:
.019176	8d 85 04	sta $0485			sta 	Var_Type 				; save as type.
.019179	bd 05 04	lda $0405,x			lda 	Var_Buffer,x 			; set bit 7 of name, marks the end.
.01917c	09 80		ora #$80			ora 	#$80
.01917e	9d 05 04	sta $0405,x			sta 	Var_Buffer,x
.019181	e8		inx				inx 							; offset 3 => length 4.
.019182	8e 87 04	stx $0487			stx 	Var_Length 				; save length of variable name.
.019185	ad 85 04	lda $0485			lda 	Var_Type 				; get offset of var type from first type token
.019188	38		sec				sec
.019189	e9 b5		sbc #$b5			sbc 	#token_Dollar
.01918b	0a		asl a				asl 	a 						; multiply by 16. This requires HashTableSize
.01918c	0a		asl a				asl 	a 						; in data.asm to be 8 (8 sets of links,2 bytes each)
.01918d	0a		asl a				asl 	a
.01918e	0a		asl a				asl 	a
.01918f	8d 88 04	sta $0488			sta 	Var_HashAddress
.019192	ad 86 04	lda $0486			lda 	Var_Hash 				; get the hash
.019195	29 07		and #$07			and 	#(HashTableSize-1) 		; force into range 0-tableSize-1
.019197	0a		asl a				asl 	a 						; double it (2 bytes per entry) & clears carry
.019198	6d 88 04	adc $0488			adc 	Var_HashAddress 		; add table offset.
.01919b	69 25		adc #$25			adc 	#HashTableBase & $FF 	; now the low byte of the actual table address
.01919d	8d 88 04	sta $0488			sta 	Var_HashAddress
.0191a0	a2 05		ldx #$05			ldx 	#5 						; hash is 5 bytes (real)
.0191a2	ad 85 04	lda $0485			lda 	Var_Type
.0191a5	c9 b7		cmp #$b7			cmp 	#token_Hash
.0191a7	f0 07		beq $0191b0			beq 	_VEHaveSize
.0191a9	ca		dex				dex
.0191aa	c9 b9		cmp #$b9			cmp 	#token_Percent 			; percent is 4 bytes (integer)
.0191ac	f0 02		beq $0191b0			beq 	_VEHaveSize
.0191ae	a2 02		ldx #$02			ldx 	#2 						; everything else is two.
.0191b0					_VEHaveSize:
.0191b0	8e 89 04	stx $0489			stx 	Var_DataSize
.0191b3	fa		plx				plx
.0191b4	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varcreate.asm

.0191b5					VariableCreate:
.0191b5	da		phx				phx
.0191b6	5a		phy				phy
.0191b7	ad 02 04	lda $0402			lda 	VarMemPtr 					; get address of next free into zTemp1
.0191ba	85 10		sta $10				sta 	zTemp1
.0191bc	ad 03 04	lda $0403			lda 	VarMemPtr+1
.0191bf	85 11		sta $11				sta 	zTemp1+1
.0191c1	ad 89 04	lda $0489			lda 	Var_DataSize 				; bytes for the data bit
.0191c4	18		clc				clc
.0191c5	6d 87 04	adc $0487			adc 	Var_Length 					; add the length of the name
.0191c8	69 03		adc #$03			adc 	#3 							; 3 for the link and the hash.
.0191ca	6d 02 04	adc $0402			adc 	VarMemPtr 					; add to variable memory pointer
.0191cd	8d 02 04	sta $0402			sta 	VarMemPtr
.0191d0	90 03		bcc $0191d5			bcc 	_VCNoCarry
.0191d2	ee 03 04	inc $0403			inc 	VarMemPtr+1
.0191d5					_VCNoCarry:
.0191d5	ad 88 04	lda $0488			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.0191d8	85 12		sta $12				sta 	zTemp2
.0191da	a9 04		lda #$04			lda 	#HashTableBase >> 8
.0191dc	85 13		sta $13				sta 	zTemp2+1
.0191de	a0 00		ldy #$00			ldy 	#0 							; put current hash link in position.
.0191e0	b1 12		lda ($12),y			lda 	(zTemp2),y
.0191e2	91 10		sta ($10),y			sta 	(zTemp1),y
.0191e4	c8		iny				iny
.0191e5	b1 12		lda ($12),y			lda 	(zTemp2),y
.0191e7	91 10		sta ($10),y			sta 	(zTemp1),y
.0191e9	c8		iny				iny
.0191ea	ad 86 04	lda $0486			lda 	Var_Hash 					; write the hash out.
.0191ed	91 10		sta ($10),y			sta 	(zTemp1),y
.0191ef	c8		iny				iny
.0191f0	a2 00		ldx #$00			ldx 	#0 							; copy the name out.
.0191f2					_VCCopyName:
.0191f2	bd 05 04	lda $0405,x			lda 	Var_Buffer,x
.0191f5	91 10		sta ($10),y			sta 	(zTemp1),y
.0191f7	e8		inx				inx
.0191f8	c8		iny				iny
.0191f9	ec 87 04	cpx $0487			cpx 	Var_Length
.0191fc	d0 f4		bne $0191f2			bne 	_VCCopyName
.0191fe	5a		phy				phy 								; save the data offset.
.0191ff	ae 89 04	ldx $0489			ldx 	Var_DataSize 				; and write the data out.
.019202	a9 00		lda #$00			lda 	#0 							; which is all zeroes.
.019204					_VCClearData:
.019204	91 10		sta ($10),y			sta 	(zTemp1),y
.019206	c8		iny				iny
.019207	ca		dex				dex
.019208	d0 fa		bne $019204			bne 	_VCClearData
.01920a	68		pla				pla 								; offset to the data
.01920b	18		clc				clc
.01920c	65 10		adc $10				adc 	zTemp1 						; add to start and save as data pointer.
.01920e	85 22		sta $22				sta 	zVarDataPtr
.019210	a5 11		lda $11				lda 	zTemp1+1
.019212	69 00		adc #$00			adc 	#0
.019214	85 23		sta $23				sta 	zVarDataPtr+1
.019216	ad 85 04	lda $0485			lda 	Var_Type 					; and set the type.
.019219	85 24		sta $24				sta 	zVarType
.01921b	a5 10		lda $10				lda 	zTemp1 						; fix hash link to point to new record
.01921d	a0 00		ldy #$00			ldy 	#0
.01921f	91 12		sta ($12),y			sta 	(zTemp2),y
.019221	c8		iny				iny
.019222	a5 11		lda $11				lda 	zTemp1+1
.019224	91 12		sta ($12),y			sta 	(zTemp2),y
.019226	7a		ply				ply
.019227	fa		plx				plx
.019228	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varfind.asm

.019229					VariableLocate:
.019229	da		phx				phx
.01922a	5a		phy				phy
.01922b	ad 88 04	lda $0488			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.01922e	85 12		sta $12				sta 	zTemp2 						; points to first address.
.019230	a9 04		lda #$04			lda 	#HashTableBase >> 8
.019232	85 13		sta $13				sta 	zTemp2+1
.019234	a0 00		ldy #$00	_VLNext:ldy 	#0 							; get next link into AX
.019236	b1 12		lda ($12),y			lda 	(zTemp2),y
.019238	aa		tax				tax
.019239	c8		iny				iny
.01923a	b1 12		lda ($12),y			lda 	(zTemp2),y
.01923c	85 13		sta $13				sta 	zTemp2+1 					; save in zTemp
.01923e	86 12		stx $12				stx 	zTemp2
.019240	05 12		ora $12				ora 	zTemp2 						; got zero
.019242	18		clc				clc
.019243	f0 25		beq $01926a			beq 	_VLExit 					; if so, then fail as end of chain.
.019245	c8		iny				iny 								; point to hash (offset + 2)
.019246	b1 12		lda ($12),y			lda 	(zTemp2),y
.019248	cd 86 04	cmp $0486			cmp 	Var_Hash
.01924b	d0 e7		bne $019234			bne 	_VLNext 					; try next if different.
.01924d					_VLCompare:
.01924d	c8		iny				iny 								; next character
.01924e	b1 12		lda ($12),y			lda 	(zTemp2),y 					; compare variable field against buffer.
.019250	d9 02 04	cmp $0402,y			cmp 	Var_Buffer-3,y 				; the -3 is because name starts at 3.
.019253	d0 df		bne $019234			bne 	_VLNext 					; fail if different, try next.
.019255	0a		asl a				asl 	a 							; until end character (bit 7 set) matched
.019256	90 f5		bcc $01924d			bcc 	_VLCompare
.019258	98		tya				tya
.019259	38		sec				sec 								; add 1 as Y points to last character
.01925a	65 12		adc $12				adc 	zTemp2 						; add to the current address
.01925c	85 22		sta $22				sta 	zVarDataPtr
.01925e	a5 13		lda $13				lda 	zTemp2+1
.019260	69 00		adc #$00			adc 	#0
.019262	85 23		sta $23				sta 	zVarDataPtr+1
.019264	ad 85 04	lda $0485			lda 	Var_Type 					; and set the type.
.019267	85 24		sta $24				sta 	zVarType
.019269	38		sec				sec 								; return CS
.01926a	7a		ply		_VLExit:ply
.01926b	fa		plx				plx
.01926c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/vargetset.asm

.01926d					VariableGet:
.01926d	5a		phy				phy
.01926e	a0 00		ldy #$00			ldy 	#0 							; copy first two bytes
.019270	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019272	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.019275	c8		iny				iny
.019276	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019278	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.01927b	c8		iny				iny
.01927c	ad 85 04	lda $0485			lda 	Var_Type 					; if it is a string, set up for that.
.01927f	c9 b5		cmp #$b5			cmp 	#token_Dollar
.019281	f0 35		beq $0192b8			beq 	_VGString
.019283	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; copy the next two bytes.
.019285	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019288	c8		iny				iny
.019289	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.01928b	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.01928e	c8		iny				iny
.01928f	a9 01		lda #$01			lda 	#1 							; set type to 1.
.019291	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019294	ad 85 04	lda $0485			lda 	Var_Type
.019297	c9 b9		cmp #$b9			cmp 	#token_Percent 				; if it is a %, then exit with default integer.
.019299	f0 31		beq $0192cc			beq 	_VGExit
.01929b	a9 40		lda #$40			lda 	#$40 						; set type byte to zero
.01929d	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; which is the code for zero/float.
.0192a0	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; the last value to copy is the exponent.
.0192a2	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.0192a5	f0 25		beq $0192cc			beq 	_VGExit 					; if exponent is zero ... it's zero.
.0192a7	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; the sign bit is the top mantissa bit.
.0192aa	48		pha				pha
.0192ab	29 80		and #$80			and 	#$80
.0192ad	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; this is the type byte.
.0192b0	68		pla				pla
.0192b1	09 80		ora #$80			ora 	#$80 						; set the MSB as you would expect.
.0192b3	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x 			; so it's a normalised float.
.0192b6	80 14		bra $0192cc			bra 	_VGExit
.0192b8					_VGString:
.0192b8	a9 02		lda #$02			lda 	#2 							; set type to 2, a string
.0192ba	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0192bd	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; is the value there $0000
.0192c0	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.0192c3	d0 07		bne $0192cc			bne 	_VGExit 					; if not, exit.
.0192c5	85 25		sta $25				sta 	zNullString 				; make zNullString a 00 string.
.0192c7	a9 25		lda #$25			lda 	#zNullString
.0192c9	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; make it point to it.
.0192cc					_VGExit:
.0192cc	7a		ply				ply
.0192cd	60		rts				rts
.0192ce					VariableSet:
.0192ce	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; is the result a string
.0192d1	29 02		and #$02			and 	#2 							; if so, it has to be
.0192d3	d0 53		bne $019328			bne 	_VSString
.0192d5	a5 24		lda $24				lda 	zVarType 					; if type is $ there's an error.
.0192d7	c9 b5		cmp #$b5			cmp 	#token_Dollar
.0192d9	f0 4a		beq $019325			beq 	_VSBadType
.0192db	c9 b9		cmp #$b9			cmp 	#token_Percent 				; type convert to float/int
.0192dd	f0 05		beq $0192e4			beq 	_VSMakeInt
.0192df	20 da 98	jsr $0198da			jsr 	FPUToFloat
.0192e2	80 03		bra $0192e7			bra 	_VSCopy
.0192e4					_VSMakeInt:
.0192e4	20 39 99	jsr $019939			jsr 	FPUToInteger
.0192e7					_VSCopy:
.0192e7	5a		phy				phy
.0192e8	a0 00		ldy #$00			ldy 	#0 							; copy mantissa to target.
.0192ea	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.0192ed	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0192ef	c8		iny				iny
.0192f0	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0192f3	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0192f5	c8		iny				iny
.0192f6	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.0192f9	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0192fb	c8		iny				iny
.0192fc	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.0192ff	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019301	a5 24		lda $24				lda 	zVarType 					; if target is integer, alrady done.
.019303	c9 b9		cmp #$b9			cmp 	#token_Percent
.019305	f0 1c		beq $019323			beq 	_VSExit
.019307	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get the sign bit into carry flag.
.01930a	0a		asl a				asl 	a
.01930b	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; shift the sign into the mantissa high.
.01930e	08		php				php
.01930f	0a		asl a				asl 	a
.019310	28		plp				plp
.019311	6a		ror a				ror 	a
.019312	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019314	c8		iny				iny
.019315	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; copy the exponent in
.019318	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.01931a	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if the result is non zero
.01931d	50 04		bvc $019323			bvc 	_VSExit
.01931f	a9 00		lda #$00			lda 	#00 						; zero exponent indicating 0.
.019321	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019323					_VSExit:
.019323	7a		ply				ply
.019324	60		rts				rts
.019325					_VSBadType:
.019325	4c 10 84	jmp $018410			jmp 	TypeError
.019328					_VSString:
.019328	a5 24		lda $24				lda 	zVarType 					; type must be $
.01932a	c9 b5		cmp #$b5			cmp 	#token_Dollar
.01932c	d0 f7		bne $019325			bne 	_VSBadType
.01932e	da		phx				phx
.01932f	5a		phy				phy
.019330	20 5b 90	jsr $01905b			jsr 	StringConcrete 				; concrete the string in the mantissa -> AX
.019333	a0 01		ldy #$01			ldy 	#1 							; save high byte
.019335	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019337	88		dey				dey 								; save low byte
.019338	8a		txa				txa
.019339	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.01933b	7a		ply				ply 								; and exit.
.01933c	fa		plx				plx
.01933d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.01933e					MulInteger32:
.01933e	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.019341	9d 14 03	sta $0314,x			sta 	XS3_Mantissa,x
.019344	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.019347	9d 15 03	sta $0315,x			sta 	XS3_Mantissa+1,x
.01934a	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.01934d	9d 16 03	sta $0316,x			sta 	XS3_Mantissa+2,x
.019350	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.019353	9d 17 03	sta $0317,x			sta 	XS3_Mantissa+3,x
.019356	a9 00		lda #$00			lda 	#0
.019358	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x 				; zero +0
.01935b	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.01935e	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019361	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019364					_BFMMultiply:
.019364	bd 14 03	lda $0314,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.019367	29 01		and #$01			and 	#1
.019369	f0 03		beq $01936e			beq 	_BFMNoAdd
.01936b	20 b0 8b	jsr $018bb0			jsr 	AddInteger32
.01936e					_BFMNoAdd:
.01936e	1e 0e 03	asl $030e,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.019371	3e 0f 03	rol $030f,x			rol 	XS2_Mantissa+1,x
.019374	3e 10 03	rol $0310,x			rol 	XS2_Mantissa+2,x
.019377	3e 11 03	rol $0311,x			rol 	XS2_Mantissa+3,x
.01937a	5e 17 03	lsr $0317,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.01937d	7e 16 03	ror $0316,x			ror 	XS3_Mantissa+2,x
.019380	7e 15 03	ror $0315,x			ror 	XS3_Mantissa+1,x
.019383	7e 14 03	ror $0314,x			ror 	XS3_Mantissa,x
.019386	bd 14 03	lda $0314,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.019389	1d 15 03	ora $0315,x			ora 	XS3_Mantissa+1,x
.01938c	1d 16 03	ora $0316,x			ora 	XS3_Mantissa+2,x
.01938f	1d 17 03	ora $0317,x			ora 	XS3_Mantissa+3,x
.019392	d0 d0		bne $019364			bne 	_BFMMultiply
.019394	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.019395					DivInteger32:
.019395	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; check for /0
.019398	1d 0f 03	ora $030f,x			ora 	XS2_Mantissa+1,x
.01939b	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.01939e	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.0193a1	d0 14		bne $0193b7			bne 	_BFDOkay
.0193a3	20 2f 84	jsr $01842f			jsr ERR_Handler
>0193a6	44 69 76 69 73 69 6f 6e			.text "Division by Zero",0
>0193ae	20 62 79 20 5a 65 72 6f 00
.0193b7					_BFDOkay:
.0193b7	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.0193b9	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.0193bb	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.0193bd	85 1c		sta $1c				sta 	zLTemp1+2
.0193bf	85 1d		sta $1d				sta 	zLTemp1+3
.0193c1	8d 8e 04	sta $048e			sta 	SignCount 					; Count of signs.
.0193c4	20 25 94	jsr $019425			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.0193c7	da		phx				phx
.0193c8	e8		inx				inx
.0193c9	e8		inx				inx
.0193ca	e8		inx				inx
.0193cb	e8		inx				inx
.0193cc	e8		inx				inx
.0193cd	e8		inx				inx
.0193ce	20 25 94	jsr $019425			jsr 	CheckIntegerNegate
.0193d1	fa		plx				plx
.0193d2	5a		phy				phy 								; Y is the counter
.0193d3	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.0193d5					_BFDLoop:
.0193d5	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.0193d8	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.0193db	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.0193de	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.0193e1	26 1a		rol $1a				rol 	zLTemp1
.0193e3	26 1b		rol $1b				rol 	zLTemp1+1
.0193e5	26 1c		rol $1c				rol 	zLTemp1+2
.0193e7	26 1d		rol $1d				rol 	zLTemp1+3
.0193e9	38		sec				sec
.0193ea	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.0193ec	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.0193ef	48		pha				pha
.0193f0	a5 1b		lda $1b				lda 	zLTemp1+1
.0193f2	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.0193f5	48		pha				pha
.0193f6	a5 1c		lda $1c				lda 	zLTemp1+2
.0193f8	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.0193fb	48		pha				pha
.0193fc	a5 1d		lda $1d				lda 	zLTemp1+3
.0193fe	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.019401	90 15		bcc $019418			bcc 	_BFDNoAdd
.019403	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.019405	68		pla				pla
.019406	85 1c		sta $1c				sta 	zLTemp1+2
.019408	68		pla				pla
.019409	85 1b		sta $1b				sta 	zLTemp1+1
.01940b	68		pla				pla
.01940c	85 1a		sta $1a				sta 	zLTemp1+0
.01940e	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.019411	09 01		ora #$01			ora 	#1
.019413	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019416	80 03		bra $01941b			bra 	_BFDNext
.019418					_BFDNoAdd:
.019418	68		pla				pla 								; Throw away the intermediate calculations
.019419	68		pla				pla
.01941a	68		pla				pla
.01941b					_BFDNext:
.01941b	88		dey				dey
.01941c	d0 b7		bne $0193d5			bne 	_BFDLoop
.01941e	7a		ply				ply 								; restore Y and exit
.01941f	4e 8e 04	lsr $048e			lsr 	SignCount 					; if sign count odd,
.019422	b0 07		bcs $01942b			bcs		IntegerNegateAlways 			; negate the result
.019424	60		rts				rts
.019425					CheckIntegerNegate:
.019425	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.019428	30 01		bmi $01942b			bmi 	IntegerNegateAlways
.01942a	60		rts				rts
.01942b					IntegerNegateAlways:
.01942b	ee 8e 04	inc $048e			inc 	SignCount
.01942e	38		sec				sec
.01942f	a9 00		lda #$00			lda 	#0
.019431	fd 08 03	sbc $0308,x			sbc 	XS_Mantissa+0,x
.019434	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019437	a9 00		lda #$00			lda 	#0
.019439	fd 09 03	sbc $0309,x			sbc 	XS_Mantissa+1,x
.01943c	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.01943f	a9 00		lda #$00			lda 	#0
.019441	fd 0a 03	sbc $030a,x			sbc 	XS_Mantissa+2,x
.019444	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019447	a9 00		lda #$00			lda 	#0
.019449	fd 0b 03	sbc $030b,x			sbc 	XS_Mantissa+3,x
.01944c	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.01944f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.019450					INTToString:
.019450	48		pha				pha
.019451	5a		phy				phy
.019452	bd 0b 03	lda $030b,x			lda 		XS_Mantissa+3,x 		; check -ve
.019455	10 08		bpl $01945f			bpl 		_ITSNotMinus
.019457	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.019459	20 f4 94	jsr $0194f4			jsr 		ITSOutputCharacter
.01945c	20 2b 94	jsr $01942b			jsr 		IntegerNegateAlways 	; negate the number.
.01945f					_ITSNotMinus:
.01945f	a9 00		lda #$00			lda 		#0
.019461	8d 8a 04	sta $048a			sta 		NumSuppress 			; clear the suppression flag.
.019464	8a		txa				txa 								; use Y for the mantissa index.
.019465	a8		tay				tay
.019466	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.019468					_ITSNextSubtractor:
.019468	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.01946a	8d 8b 04	sta $048b			sta 		NumConvCount
.01946d					_ITSSubtract:
.01946d	38		sec				sec
.01946e	b9 08 03	lda $0308,y			lda 		XS_Mantissa,y 			; subtract number and push on stack
.019471	ff d0 94 01	sbc $0194d0,x			sbc 		_ITSSubtractors+0,x
.019475	48		pha				pha
.019476	b9 09 03	lda $0309,y			lda 		XS_Mantissa+1,y
.019479	ff d1 94 01	sbc $0194d1,x			sbc 		_ITSSubtractors+1,x
.01947d	48		pha				pha
.01947e	b9 0a 03	lda $030a,y			lda 		XS_Mantissa+2,y
.019481	ff d2 94 01	sbc $0194d2,x			sbc 		_ITSSubtractors+2,x
.019485	48		pha				pha
.019486	b9 0b 03	lda $030b,y			lda 		XS_Mantissa+3,y
.019489	ff d3 94 01	sbc $0194d3,x			sbc 		_ITSSubtractors+3,x
.01948d	90 14		bcc $0194a3			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.01948f	99 0b 03	sta $030b,y			sta 		XS_Mantissa+3,y 		; save subtract off stack
.019492	68		pla				pla
.019493	99 0a 03	sta $030a,y			sta 		XS_Mantissa+2,y
.019496	68		pla				pla
.019497	99 09 03	sta $0309,y			sta 		XS_Mantissa+1,y
.01949a	68		pla				pla
.01949b	99 08 03	sta $0308,y			sta 		XS_Mantissa+0,y
.01949e	ee 8b 04	inc $048b			inc 		NumConvCount 			; bump count.
.0194a1	80 ca		bra $01946d			bra 		_ITSSubtract 			; go round again.
.0194a3					_ITSCantSubtract:
.0194a3	68		pla				pla 								; throw away interim answers
.0194a4	68		pla				pla
.0194a5	68		pla				pla
.0194a6	ad 8b 04	lda $048b			lda 		NumConvCount 			; if not zero then no suppression check
.0194a9	c9 30		cmp #$30			cmp 		#"0"
.0194ab	d0 05		bne $0194b2			bne 		_ITSOutputDigit
.0194ad	ad 8a 04	lda $048a			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.0194b0	10 09		bpl $0194bb			bpl	 		_ITSGoNextSubtractor
.0194b2					_ITSOutputDigit:
.0194b2	ce 8a 04	dec $048a			dec 		NumSuppress 			; suppression check will be non-zero.
.0194b5	ad 8b 04	lda $048b			lda 		NumConvCount 			; count of subtractions
.0194b8	20 f4 94	jsr $0194f4			jsr 		ITSOutputCharacter 		; output it.
.0194bb					_ITSGoNextSubtractor:
.0194bb	e8		inx				inx 								; next dword
.0194bc	e8		inx				inx
.0194bd	e8		inx				inx
.0194be	e8		inx				inx
.0194bf	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.0194c1	d0 a5		bne $019468			bne 		_ITSNextSubtractor 		; do all the subtractors.
.0194c3	98		tya				tya 								; X is back as the mantissa index
.0194c4	aa		tax				tax
.0194c5	bd 08 03	lda $0308,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.0194c8	09 30		ora #$30			ora 		#"0"
.0194ca	20 f4 94	jsr $0194f4			jsr 		ITSOutputCharacter
.0194cd	7a		ply				ply 								; and exit
.0194ce	68		pla				pla
.0194cf	60		rts				rts
.0194d0					_ITSSubtractors:
>0194d0	00 ca 9a 3b					.dword 		1000000000
>0194d4	00 e1 f5 05					.dword 		100000000
>0194d8	80 96 98 00					.dword 		10000000
>0194dc	40 42 0f 00					.dword 		1000000
>0194e0	a0 86 01 00					.dword 		100000
>0194e4	10 27 00 00					.dword 		10000
>0194e8	e8 03 00 00					.dword 		1000
>0194ec	64 00 00 00					.dword 		100
>0194f0	0a 00 00 00					.dword 		10
.0194f4					_ITSSubtractorsEnd:
.0194f4					ITSOutputCharacter:
.0194f4	48		pha				pha
.0194f5	da		phx				phx
.0194f6	ae 04 04	ldx $0404			ldx 	NumBufX 					; save digit
.0194f9	9d 05 04	sta $0405,x			sta 	Num_Buffer,x
.0194fc	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.0194fe	9d 06 04	sta $0406,x			sta 	Num_Buffer+1,x
.019501	ee 04 04	inc $0404			inc 	NumBufX						; bump pointer.
.019504	fa		plx				plx
.019505	68		pla				pla
.019506	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.019507					IntFromString:
.019507	a0 00		ldy #$00			ldy 	#0
.019509	8c 8c 04	sty $048c			sty 	ExpTemp 					; this is the converted digit count.
.01950c					IntFromStringY:
.01950c	48		pha				pha
.01950d	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.01950f	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.019512	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019515	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019518	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.01951b	a9 01		lda #$01			lda 	#1
.01951d	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019520					_IFSLoop:
.019520	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.019522	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.019524	90 60		bcc $019586			bcc 	_IFSExit
.019526	c9 3a		cmp #$3a			cmp 	#"9"+1
.019528	b0 5c		bcs $019586			bcs 	_IFSExit
.01952a	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.01952d	c9 0c		cmp #$0c			cmp 	#12
.01952f	b0 5f		bcs $019590			bcs 	_IFSOverflow
.019531	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.019534	48		pha				pha
.019535	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.019538	48		pha				pha
.019539	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.01953c	48		pha				pha
.01953d	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.019540	48		pha				pha
.019541	20 a5 95	jsr $0195a5			jsr 	IFSX1ShiftLeft 				; double
.019544	20 a5 95	jsr $0195a5			jsr 	IFSX1ShiftLeft 				; x 4
.019547	18		clc				clc 								; add saved value x 5
.019548	68		pla				pla
.019549	7d 08 03	adc $0308,x			adc 	XS_Mantissa+0,x
.01954c	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.01954f	68		pla				pla
.019550	7d 09 03	adc $0309,x			adc 	XS_Mantissa+1,x
.019553	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019556	68		pla				pla
.019557	7d 0a 03	adc $030a,x			adc 	XS_Mantissa+2,x
.01955a	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01955d	68		pla				pla
.01955e	7d 0b 03	adc $030b,x			adc 	XS_Mantissa+3,x
.019561	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019564	20 a5 95	jsr $0195a5			jsr 	IFSX1ShiftLeft 				; x 10
.019567	ee 8c 04	inc $048c			inc 	ExpTemp 					; bump count of digits processed.
.01956a	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.01956c	29 0f		and #$0f			and 	#15
.01956e	c8		iny				iny
.01956f	7d 08 03	adc $0308,x			adc 	XS_Mantissa+0,x
.019572	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019575	90 a9		bcc $019520			bcc 	_IFSLoop
.019577	fe 09 03	inc $0309,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.01957a	d0 a4		bne $019520			bne 	_IFSLoop
.01957c	fe 0a 03	inc $030a,x			inc 	XS_Mantissa+2,x
.01957f	d0 9f		bne $019520			bne 	_IFSLoop
.019581	fe 0b 03	inc $030b,x			inc 	XS_Mantissa+3,x
.019584	80 9a		bra $019520			bra 	_IFSLoop
.019586					_IFSExit:
.019586	98		tya				tya 								; get offset
.019587					_IFSOkay:
.019587	38		sec				sec
.019588	ad 8c 04	lda $048c			lda 	ExpTemp
.01958b	f0 01		beq $01958e			beq 	_IFSSkipFail
.01958d	18		clc				clc
.01958e					_IFSSkipFail:
.01958e	68		pla				pla 								; and exit.
.01958f	60		rts				rts
.019590					_IFSOverflow:
.019590	20 2f 84	jsr $01842f			jsr 	ERR_Handler
>019593	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>01959b	20 6f 76 65 72 66 6c 6f 77 00
.0195a5					IFSX1ShiftLeft:
.0195a5	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x
.0195a8	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.0195ab	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.0195ae	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.0195b1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.0195b2					FPSubtract:
.0195b2	48		pha				pha
.0195b3	bd 13 03	lda $0313,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.0195b6	49 80		eor #$80			eor 	#$80
.0195b8	9d 13 03	sta $0313,x			sta 	XS2_Type,x
.0195bb	68		pla				pla 								; --- and fall through ---
.0195bc					FPAdd:
.0195bc	48		pha				pha
.0195bd	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.0195c0	d0 05		bne $0195c7			bne 	_FPA_NegativeLHS
.0195c2	20 e4 95	jsr $0195e4			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.0195c5	68		pla				pla
.0195c6	60		rts				rts
.0195c7					_FPA_NegativeLHS:
.0195c7	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.0195ca	49 80		eor #$80			eor 	#$80
.0195cc	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0195cf	bd 13 03	lda $0313,x			lda 	XS2_Type,x 					; flip the sign of B and add
.0195d2	49 80		eor #$80			eor 	#$80
.0195d4	9d 13 03	sta $0313,x			sta 	XS2_Type,x
.0195d7	20 e4 95	jsr $0195e4			jsr 	FPAdd_Worker 				; do the add calculation.
.0195da	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip sign of X1 back
.0195dd	49 80		eor #$80			eor 	#$80
.0195df	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0195e2	68		pla				pla
.0195e3	60		rts				rts
.0195e4					FPAdd_Worker:
.0195e4	3c 13 03	bit $0313,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.0195e7	70 08		bvs $0195f1			bvs 	_FPAWExit 					; no change.
.0195e9	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.0195ec	50 07		bvc $0195f5			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.0195ee	20 89 98	jsr $019889			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.0195f1					_FPAWExit:
.0195f1	20 11 99	jsr $019911			jsr 	FPUNormalise 				; normalise the result.
.0195f4	60		rts				rts
.0195f5					_FPAWMakeSame:
.0195f5	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.0195f8	38		sec				sec
.0195f9	fd 12 03	sbc $0312,x			sbc	 	XS2_Exponent,x 				; using subtraction
.0195fc	f0 1b		beq $019619			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.0195fe	da		phx				phx 								; save X
.0195ff	90 06		bcc $019607			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.019601	e8		inx				inx
.019602	e8		inx				inx
.019603	e8		inx				inx
.019604	e8		inx				inx
.019605	e8		inx				inx
.019606	e8		inx				inx
.019607					_FPAWShiftA:
.019607	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x 				; so shift exponent up.
.01960a	5e 0b 03	lsr $030b,x			lsr 	3+XS_Mantissa,x
.01960d	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.019610	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.019613	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.019616	fa		plx				plx 								; restore original X
.019617	80 dc		bra $0195f5			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.019619					_FPAW_DoArithmetic:
.019619	3c 13 03	bit $0313,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.01961c	30 39		bmi $019657			bmi 	_FPAW_BNegative
.01961e	18		clc				clc
.01961f	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.019622	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.019625	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019628	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.01962b	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.01962e	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019631	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.019634	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.019637	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01963a	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.01963d	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.019640	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019643	90 ac		bcc $0195f1			bcc 	_FPAWExit 					; no carry.
.019645	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x 				; so shift exponent up.
.019648	38		sec				sec
.019649	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.01964c	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.01964f	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.019652	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.019655	80 9a		bra $0195f1			bra 	_FPAWExit
.019657					_FPAW_BNegative:
.019657	38		sec				sec
.019658	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.01965b	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.01965e	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019661	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.019664	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.019667	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.01966a	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.01966d	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.019670	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019673	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.019676	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.019679	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.01967c	b0 0b		bcs $019689			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.01967e	20 b6 98	jsr $0198b6			jsr 	FPUNegateInteger			; negate the mantissa
.019681	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip result sign
.019684	49 80		eor #$80			eor 	#$80
.019686	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019689					_FPAWGoExit:
.019689	4c f1 95	jmp $0195f1			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.01968c					FPD_IsDivZero:
.01968c	20 2f 84	jsr $01842f			jsr ERR_Handler
>01968f	44 69 76 69 73 69 6f 6e			.text "Division by zero",0
>019697	20 62 79 20 7a 65 72 6f 00
.0196a0					FPDivide:
.0196a0	48		pha				pha
.0196a1	5a		phy				phy
.0196a2	3c 13 03	bit $0313,x			bit 	XS2_Type,x 					; check if division by zero
.0196a5	70 e5		bvs $01968c			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.0196a7	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.0196aa	f0 03		beq $0196af			beq 	_FPDCalculateExp
.0196ac					_FPD_Exit:
.0196ac	7a		ply				ply
.0196ad	68		pla				pla
.0196ae	60		rts				rts
.0196af					_FPDCalculateExp:
.0196af	bd 12 03	lda $0312,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.0196b2	49 ff		eor #$ff			eor 	#$FF
.0196b4	1a		inc a				inc 	a
.0196b5	9d 12 03	sta $0312,x			sta 	XS2_Exponent,x
.0196b8	20 ac 97	jsr $0197ac			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.0196bb	18		clc				clc 	 							; add 1 to the resulting exponent
.0196bc	69 01		adc #$01			adc 	#1
.0196be	b0 65		bcs $019725			bcs 	_FPD_Overflow 				; which can overflow.
.0196c0	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.0196c3	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.0196c5	85 1a		sta $1a				sta 	zLTemp1+0
.0196c7	85 1b		sta $1b				sta 	zLTemp1+1
.0196c9	85 1c		sta $1c				sta 	zLTemp1+2
.0196cb	85 1d		sta $1d				sta 	zLTemp1+3
.0196cd	a0 20		ldy #$20			ldy 	#32 						; times round.
.0196cf					_FPD_Loop:
.0196cf	38		sec				sec 								; calculate X1-X2 stacking result because we might
.0196d0	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; not save it.
.0196d3	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa,x
.0196d6	48		pha				pha
.0196d7	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0196da	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.0196dd	48		pha				pha
.0196de	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.0196e1	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.0196e4	48		pha				pha
.0196e5	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.0196e8	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.0196eb	90 17		bcc $019704			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.0196ed	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x 			; save results out to A
.0196f0	68		pla				pla
.0196f1	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0196f4	68		pla				pla
.0196f5	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0196f8	68		pla				pla
.0196f9	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0196fc	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.0196fe	09 80		ora #$80			ora 	#$80
.019700	85 1d		sta $1d				sta 	zLTemp1+3
.019702	80 03		bra $019707			bra 	_FPD_Rotates
.019704					_FPD_NoSubtract:
.019704	68		pla				pla 								; throw away unwanted results
.019705	68		pla				pla
.019706	68		pla				pla
.019707					_FPD_Rotates:
.019707	5e 11 03	lsr $0311,x			lsr 	3+XS2_Mantissa,x
.01970a	7e 10 03	ror $0310,x			ror 	2+XS2_Mantissa,x
.01970d	7e 0f 03	ror $030f,x			ror 	1+XS2_Mantissa,x
.019710	7e 0e 03	ror $030e,x			ror 	0+XS2_Mantissa,x
.019713	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.019715	26 1b		rol $1b				rol 	zLTemp1+1
.019717	26 1c		rol $1c				rol 	zLTemp1+2
.019719	26 1d		rol $1d				rol 	zLTemp1+3
.01971b	90 02		bcc $01971f			bcc 	_FPD_NoCarry
.01971d	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.01971f					_FPD_NoCarry:
.01971f	88		dey				dey 								; do 32 times
.019720	d0 ad		bne $0196cf			bne 	_FPD_Loop
.019722	4c 89 97	jmp $019789			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.019725					_FPD_Overflow:
.019725	4c 86 99	jmp $019986			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.019728					FPMultiply:
.019728	48		pha				pha
.019729	5a		phy				phy
.01972a	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.01972d	70 08		bvs $019737			bvs 	_FPM_Exit
.01972f	3c 13 03	bit $0313,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.019732	50 06		bvc $01973a			bvc 	_FPM_CalcExponent
.019734	20 89 98	jsr $019889			jsr 	FPUCopyX2ToX1
.019737					_FPM_Exit:
.019737	7a		ply				ply
.019738	68		pla				pla
.019739	60		rts				rts
.01973a					_FPM_CalcExponent:
.01973a	18		clc				clc
.01973b	20 ac 97	jsr $0197ac			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.01973e	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x 				; save the result.
.019741	a9 00		lda #$00			lda 	#0
.019743	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.019745	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.019747	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.019749	85 1d		sta $1d				sta 	zLTemp1+3
.01974b	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.01974d					_FPM_Loop:
.01974d	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x				; check LSB of long product
.019750	29 01		and #$01			and 	#1
.019752	18		clc				clc 								; clear carry for the long rotate.
.019753	f0 1d		beq $019772			beq 	_FPM_NoAddition
.019755	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.019756	a5 1a		lda $1a				lda 	zLTemp1+0
.019758	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.01975b	85 1a		sta $1a				sta 	zLTemp1+0
.01975d	a5 1b		lda $1b				lda 	zLTemp1+1
.01975f	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.019762	85 1b		sta $1b				sta 	zLTemp1+1
.019764	a5 1c		lda $1c				lda 	zLTemp1+2
.019766	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.019769	85 1c		sta $1c				sta 	zLTemp1+2
.01976b	a5 1d		lda $1d				lda 	zLTemp1+3
.01976d	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.019770	85 1d		sta $1d				sta 	zLTemp1+3
.019772					_FPM_NoAddition:
.019772	66 1d		ror $1d				ror 	3+zLTemp1
.019774	66 1c		ror $1c				ror 	2+zLTemp1
.019776	66 1b		ror $1b				ror 	1+zLTemp1
.019778	66 1a		ror $1a				ror 	0+zLTemp1
.01977a	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.01977d	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.019780	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.019783	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.019786	88		dey				dey
.019787	d0 c4		bne $01974d			bne 	_FPM_Loop 					; do this 32 times.
.019789					FPM_CopySignNormalize:
.019789	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.01978b	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.01978e	a5 1b		lda $1b				lda 	zLTemp1+1
.019790	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019793	a5 1c		lda $1c				lda 	zLTemp1+2
.019795	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019798	a5 1d		lda $1d				lda 	zLTemp1+3
.01979a	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.01979d	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; sign is xor of signs
.0197a0	5d 13 03	eor $0313,x			eor 	XS2_Type,x
.0197a3	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0197a6	20 11 99	jsr $019911			jsr 	FPUNormalise 				; normalise and exit.
.0197a9	7a		ply				ply
.0197aa	68		pla				pla
.0197ab	60		rts				rts
.0197ac					FPCalculateExponent:
.0197ac	18		clc				clc
.0197ad	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.0197b0	7d 12 03	adc $0312,x			adc 	XS2_Exponent,x
.0197b3	b0 08		bcs $0197bd			bcs 	_FPCECarry 					; carry out ?
.0197b5	10 03		bpl $0197ba			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.0197b7	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.0197b9	60		rts				rts
.0197ba					_FPCEExpZero:
.0197ba	a9 00		lda #$00			lda 	#0
.0197bc	60		rts				rts
.0197bd					_FPCECarry:
.0197bd	30 03		bmi $0197c2			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.0197bf	09 80		ora #$80			ora 	#$80 						; put in right range
.0197c1	60		rts				rts
.0197c2					_FPCEOverflow:
.0197c2	4c 86 99	jmp $019986			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.0197c5					FPFractionalPart:
.0197c5	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.0197c8	38		sec				sec 								; this flag tells us to keep the fractional part
.0197c9	30 0f		bmi $0197da			bmi 	FPGetPart
.0197cb	60		rts				rts
.0197cc					FPIntegerPart:
.0197cc	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.0197cf	18		clc				clc 								; this flag says keep the integer part.
.0197d0	30 08		bmi $0197da			bmi 	FPGetPart 					; -ve exponents are 0..127
.0197d2	48		pha				pha
.0197d3	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.0197d5	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0197d8	68		pla				pla
.0197d9	60		rts				rts
.0197da					FPGetPart:
.0197da	48		pha				pha
.0197db	5a		phy				phy 								; save Y
.0197dc	08		php				php 								; save action
.0197dd	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.0197e0	70 62		bvs $019844			bvs 	_FPGP_Exit 					; then do nothing.
.0197e2	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.0197e4	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.0197e6	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.0197e8	85 1c		sta $1c				sta 	zLTemp1+2
.0197ea	85 1d		sta $1d				sta 	zLTemp1+3
.0197ec	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x				; the number of shifts.
.0197ef	38		sec				sec
.0197f0	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.0197f2	f0 12		beq $019806			beq 	_FPGP_NoShift 				; ... if any
.0197f4	c9 20		cmp #$20			cmp 	#32
.0197f6	90 02		bcc $0197fa			bcc 	_FPGP_NotMax
.0197f8	a9 20		lda #$20			lda 	#32 						; max of 32.
.0197fa					_FPGP_NotMax:
.0197fa	a8		tay				tay 								; Y is the mask shift count.
.0197fb					_FPGP_ShiftMask:
.0197fb	46 1d		lsr $1d				lsr 	3+zLTemp1
.0197fd	66 1c		ror $1c				ror 	2+zLTemp1
.0197ff	66 1b		ror $1b				ror 	1+zLTemp1
.019801	66 1a		ror $1a				ror 	0+zLTemp1
.019803	88		dey				dey
.019804	d0 f5		bne $0197fb			bne 	_FPGP_ShiftMask
.019806					_FPGP_NoShift:
.019806	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.019808	8e 8c 04	stx $048c			stx 	ExpTemp						; save X
.01980b					_FPGP_MaskLoop:
.01980b	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.01980e	28		plp				plp 								; if CC we keep the top part, so we
.01980f	08		php				php		 							; flip the mask.
.019810	b0 02		bcs $019814			bcs		_FPGP_NoFlip
.019812	49 ff		eor #$ff			eor 	#$FF
.019814					_FPGP_NoFlip:
.019814	3d 08 03	and $0308,x			and 	XS_Mantissa,x 				; and into the mantissa.
.019817	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.01981a	e8		inx				inx
.01981b	c8		iny				iny
.01981c	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.01981e	d0 eb		bne $01980b			bne 	_FPGP_MaskLoop
.019820	ae 8c 04	ldx $048c			ldx 	ExpTemp						; restore X
.019823	28		plp				plp
.019824	08		php				php 								; get action flag on the stack
.019825	90 05		bcc $01982c			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.019827	a9 00		lda #$00			lda 	#0
.019829	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.01982c					_FPGP_NotFractional:
.01982c	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 						; check if \1 zero
.01982f	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.019832	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.019835	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.019838	f0 05		beq $01983f			beq 	_FPGP_Zero 					; if zero, return zero
.01983a	20 11 99	jsr $019911			jsr 	FPUNormalise
.01983d	80 05		bra $019844			bra 	_FPGP_Exit 					; and exit
.01983f					_FPGP_Zero:
.01983f	a9 40		lda #$40			lda 	#$40 						; set zero flag
.019841	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019844					_FPGP_Exit:
.019844	68		pla				pla 								; throw saved action flag.
.019845	7a		ply				ply
.019846	68		pla				pla
.019847	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.019848					FPCompare:
.019848	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.01984b	48		pha				pha
.01984c	bd 12 03	lda $0312,x			lda 	XS2_Exponent,x
.01984f	48		pha				pha
.019850	20 b2 95	jsr $0195b2			jsr 	FPSubtract 					; calculate X1-X2
.019853	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.019856	70 2c		bvs $019884			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.019858	68		pla				pla
.019859	8d 8c 04	sta $048c			sta 	ExpTemp						; save first exponent in temporary reg.
.01985c	68		pla				pla
.01985d	38		sec				sec
.01985e	ed 8c 04	sbc $048c			sbc 	ExpTemp 					; calculate AX-BX
.019861	70 15		bvs $019878			bvs 	_FPCNotEqual				; overflow, can't be equal.
.019863	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.019864	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.019866	b0 10		bcs $019878			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.019868	38		sec				sec
.019869	ad 8c 04	lda $048c			lda 	ExpTemp 					; get one of the exponents back.
.01986c	e9 12		sbc #$12			sbc 	#18 						; allow for 2^18 error, relatively.
.01986e	b0 02		bcs $019872			bcs 	_FPCNotRange 				; keep in range.
.019870	a9 01		lda #$01			lda 	#1
.019872					_FPCNotRange:
.019872	38		sec				sec
.019873	fd 0c 03	sbc $030c,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.019876	b0 0e		bcs $019886			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.019878					_FPCNotEqual:
.019878	bd 0d 03	lda $030d,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.01987b	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.01987d	f0 02		beq $019881			beq 	_FPCNE2
.01987f	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.019881	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.019882	80 04		bra $019888			bra 	_FPCExit
.019884					_FPCPullZero:
.019884	68		pla				pla 								; throw saved exponents
.019885	68		pla				pla
.019886					_FPCZero:
.019886	a9 00		lda #$00			lda 	#0 							; and return zero
.019888					_FPCExit:
.019888	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.019889					FPUCopyX2ToX1:
.019889	48		pha				pha
.01988a	da		phx				phx
.01988b	5a		phy				phy
.01988c	a0 08		ldy #$08			ldy 	#8
.01988e	bd 0e 03	lda $030e,x	_FPUC21:lda 	XS2_Mantissa,x
.019891	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.019894	e8		inx				inx
.019895	88		dey				dey
.019896	10 f6		bpl $01988e			bpl 	_FPUC21
.019898	7a		ply				ply
.019899	fa		plx				plx
.01989a	68		pla				pla
.01989b	60		rts				rts
.01989c					FPUSetInteger:
.01989c	48		pha				pha
.01989d	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.0198a0	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.0198a2	10 02		bpl $0198a6			bpl 	_FPUSIExtend
.0198a4	a9 ff		lda #$ff			lda 	#$FF
.0198a6					_FPUSIExtend:
.0198a6	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.0198a9	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0198ac	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0198af	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.0198b1	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0198b4	68		pla				pla
.0198b5	60		rts				rts
.0198b6					FPUNegateInteger:
.0198b6	48		pha				pha
.0198b7	38		sec				sec
.0198b8	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.0198ba	fd 08 03	sbc $0308,x			sbc 	XS_Mantissa+0,x
.0198bd	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0198c0	a9 00		lda #$00			lda 	#0
.0198c2	fd 09 03	sbc $0309,x			sbc 	XS_Mantissa+1,x
.0198c5	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0198c8	a9 00		lda #$00			lda 	#0
.0198ca	fd 0a 03	sbc $030a,x			sbc 	XS_Mantissa+2,x
.0198cd	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0198d0	a9 00		lda #$00			lda 	#0
.0198d2	fd 0b 03	sbc $030b,x			sbc 	XS_Mantissa+3,x
.0198d5	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0198d8	68		pla				pla
.0198d9	60		rts				rts
.0198da					FPUToFloat:
.0198da	48		pha				pha
.0198db	bd 0d 03	lda $030d,x			lda 	XS_Type,x					; exit if already float.
.0198de	29 0f		and #$0f			and 	#$0F
.0198e0	f0 2d		beq $01990f			beq 	_FPUFExit
.0198e2	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.0198e4	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0198e7	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.0198e9	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x 				; x mantissa.
.0198ec	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.0198ef	10 08		bpl $0198f9			bpl		_FPUFPositive
.0198f1	20 b6 98	jsr $0198b6			jsr 	FPUNegateInteger 			; negate the mantissa
.0198f4	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.0198f6	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0198f9					_FPUFPositive:
.0198f9	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.0198fc	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.0198ff	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.019902	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.019905	d0 05		bne $01990c			bne 	_FPUFNonZero
.019907	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.019909	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.01990c					_FPUFNonZero:
.01990c	20 11 99	jsr $019911			jsr 	FPUNormalise 				; normalise the floating point.
.01990f					_FPUFExit:
.01990f	68		pla				pla
.019910	60		rts				rts
.019911					FPUNormalise:
.019911	48		pha				pha
.019912	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.019915	70 20		bvs $019937			bvs 	_FPUNExit
.019917	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.01991a	f0 16		beq $019932			beq 	_FPUNSetZero
.01991c					_FPUNLoop:
.01991c	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.01991f	30 16		bmi $019937			bmi 	_FPUNExit 					; if so, we are normalised.
.019921	1e 08 03	asl $0308,x			asl 	0+XS_Mantissa+0,x
.019924	3e 09 03	rol $0309,x			rol 	1+XS_Mantissa+0,x
.019927	3e 0a 03	rol $030a,x			rol 	2+XS_Mantissa+0,x
.01992a	3e 0b 03	rol $030b,x			rol 	3+XS_Mantissa+0,x
.01992d	de 0c 03	dec $030c,x			dec 	XS_Exponent,x 				; decrement exponent
.019930	d0 ea		bne $01991c			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.019932					_FPUNSetZero:
.019932	a9 40		lda #$40			lda 	#$40
.019934	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; the result is now zero.
.019937					_FPUNExit:
.019937	68		pla				pla
.019938	60		rts				rts
.019939					FPUToInteger:
.019939	48		pha				pha
.01993a	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; if already integer, exit
.01993d	29 01		and #$01			and 	#1
.01993f	d0 3e		bne $01997f			bne 	_FPUTOI_Exit
.019941	3c 0d 03	bit $030d,x			bit 	XS_Type,x					; if zero, return zero.
.019944	70 2b		bvs $019971			bvs 	_FPUTOI_Zero
.019946	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.019949	10 26		bpl $019971			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.01994b	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.01994d	b0 37		bcs $019986			bcs 	FP_Overflow
.01994f					_FPUToIToInteger:
.01994f	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.019952	c9 a0		cmp #$a0			cmp 	#128+32
.019954	f0 11		beq $019967			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.019956	fe 0c 03	inc $030c,x			inc 	XS_Exponent,X 				; increment Exponent
.019959	5e 0b 03	lsr $030b,x			lsr 	3+XS_Mantissa,x
.01995c	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.01995f	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.019962	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.019965	80 e8		bra $01994f			bra 	_FPUToIToInteger 			; keep going.
.019967					_FPUToICheckSign:
.019967	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; check sign
.01996a	10 13		bpl $01997f			bpl 	_FPUToI_Exit 				; exit if unsigned.
.01996c	20 b6 98	jsr $0198b6			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.01996f	80 0e		bra $01997f			bra 	_FPUTOI_Exit
.019971					_FPUTOI_Zero:
.019971	a9 00		lda #$00			lda 	#0 							; return zero integer.
.019973	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019976	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019979	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01997c	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.01997f					_FPUToI_Exit:
.01997f	a9 01		lda #$01			lda 	#1 							; set type to integer
.019981	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019984	68		pla				pla
.019985	60		rts				rts
.019986					FP_Overflow:
.019986	20 2f 84	jsr $01842f			jsr ERR_Handler
>019989	46 6c 6f 61 74 69 6e 67			.text "Floating Point overflow",0
>019991	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.0199a1					FPUTimes10:
.0199a1	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.0199a4	85 1a		sta $1a				sta 	ZLTemp1+0
.0199a6	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0199a9	85 1b		sta $1b				sta 	ZLTemp1+1
.0199ab	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.0199ae	85 1c		sta $1c				sta 	ZLTemp1+2
.0199b0	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.0199b3	85 1d		sta $1d				sta 	ZLTemp1+3
.0199b5	20 f9 99	jsr $0199f9			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.0199b8	20 f9 99	jsr $0199f9			jsr 	_FPUT_LSR_ZLTemp1
.0199bb	18		clc				clc
.0199bc	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.0199bf	65 1a		adc $1a				adc 	ZLTemp1+0
.0199c1	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0199c4	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0199c7	65 1b		adc $1b				adc 	ZLTemp1+1
.0199c9	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0199cc	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.0199cf	65 1c		adc $1c				adc 	ZLTemp1+2
.0199d1	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0199d4	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.0199d7	65 1d		adc $1d				adc 	ZLTemp1+3
.0199d9	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0199dc	90 0f		bcc $0199ed			bcc 	_FPUTimes10
.0199de	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.0199e1	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.0199e4	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.0199e7	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.0199ea	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x				; fix exponent
.0199ed					_FPUTimes10:
.0199ed	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.0199f0	18		clc				clc
.0199f1	69 03		adc #$03			adc 	#3
.0199f3	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.0199f6	b0 8e		bcs $019986			bcs 	FP_Overflow 				; error
.0199f8	60		rts				rts
.0199f9					_FPUT_LSR_ZLTemp1:
.0199f9	46 1d		lsr $1d				lsr 	ZLTemp1+3
.0199fb	66 1c		ror $1c				ror 	ZLTemp1+2
.0199fd	66 1b		ror $1b				ror 	ZLTemp1+1
.0199ff	66 1a		ror $1a				ror 	ZLTemp1+0
.019a01	60		rts				rts
.019a02					FPUScale10A:
.019a02	5a		phy				phy
.019a03	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.019a05	f0 3d		beq $019a44			beq 	_FPUScaleExit
.019a07	da		phx				phx 								; save X
.019a08	e8		inx				inx
.019a09	e8		inx				inx
.019a0a	e8		inx				inx
.019a0b	e8		inx				inx
.019a0c	e8		inx				inx
.019a0d	e8		inx				inx
.019a0e	a8		tay				tay 								; save power scalar in Y.
.019a0f	a9 00		lda #$00			lda 	#0
.019a11	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.019a14	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019a17	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019a1a	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019a1d	a9 80		lda #$80			lda 	#$80
.019a1f	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019a22	a9 81		lda #$81			lda 	#$81
.019a24	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.019a27	5a		phy				phy 								; save 10^n on stack.
.019a28	c0 00		cpy #$00			cpy 	#0
.019a2a	10 05		bpl $019a31			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.019a2c	98		tya				tya
.019a2d	49 ff		eor #$ff			eor 	#$FF
.019a2f	1a		inc a				inc 	a
.019a30	a8		tay				tay
.019a31					_FPUSAbs:
.019a31	20 a1 99	jsr $0199a1			jsr 	FPUTimes10
.019a34	88		dey				dey
.019a35	d0 fa		bne $019a31			bne 	_FPUSAbs 					; tos is now 10^|AC|
.019a37	68		pla				pla 								; restore count in A
.019a38	fa		plx				plx 								; restore X pointing to number to scale.
.019a39	0a		asl a				asl 	a
.019a3a	b0 05		bcs $019a41			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.019a3c	20 28 97	jsr $019728			jsr 	FPMultiply 					; if clear multiply.
.019a3f	80 03		bra $019a44			bra		_FPUScaleExit
.019a41					_FPUSDivide:
.019a41	20 a0 96	jsr $0196a0			jsr 	FPDivide
.019a44					_FPUScaleExit:
.019a44	7a		ply				ply
.019a45	60		rts				rts
.019a46					FPUCopyToNext:
.019a46	a0 06		ldy #$06			ldy 		#6
.019a48	da		phx				phx
.019a49					_FPUCopy1:
.019a49	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x
.019a4c	9d 0e 03	sta $030e,x			sta 	XS2_Mantissa,x
.019a4f	e8		inx				inx
.019a50	88		dey				dey
.019a51	d0 f6		bne $019a49			bne 	_FPUCopy1
.019a53	fa		plx				plx
.019a54	60		rts				rts
.019a55					FPUCopyFromNext:
.019a55	a0 06		ldy #$06			ldy 		#6
.019a57	da		phx				phx
.019a58					_FPUCopy1:
.019a58	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa,x
.019a5b	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.019a5e	e8		inx				inx
.019a5f	88		dey				dey
.019a60	d0 f6		bne $019a58			bne 	_FPUCopy1
.019a62	fa		plx				plx
.019a63	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.019a64					FPToString:
.019a64	48		pha				pha
.019a65	5a		phy				phy
.019a66	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; check zero flag
.019a69	50 0a		bvc $019a75			bvc 		_FPTSIsFloat 			; if zero,
.019a6b					_FPTSZero:
.019a6b	a9 30		lda #$30			lda 		#"0"
.019a6d	20 f4 94	jsr $0194f4			jsr 		ITSOutputCharacter
.019a70					_FPTSExit:
.019a70	7a		ply				ply
.019a71	68		pla				pla
.019a72	60		rts				rts
.019a73	80 fb		bra $019a70			bra 		_FPTSExit
.019a75					_FPTSIsFloat:
.019a75	bd 0d 03	lda $030d,x			lda 		XS_Type,x 				; is it signed ?
.019a78	10 0a		bpl $019a84			bpl 		_FPTSNotSigned
.019a7a	a9 00		lda #$00			lda 		#0 						; clear sign flag
.019a7c	9d 0d 03	sta $030d,x			sta 		XS_Type,x
.019a7f	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.019a81	20 f4 94	jsr $0194f4			jsr 		ITSOutputCharacter
.019a84					_FPTSNotSigned:
.019a84	bd 0c 03	lda $030c,x			lda 		XS_Exponent,x
.019a87	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.019a89	b0 09		bcs $019a94			bcs 		_FPTSExponent
.019a8b	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.019a8d	90 05		bcc $019a94			bcc 		_FPTSExponent 			;
.019a8f					_FPTSStandard:
.019a8f	20 d8 9a	jsr $019ad8			jsr 		FPTOutputBody 			; output the body.
.019a92	80 dc		bra $019a70			bra 		_FPTSExit
.019a94					_FPTSExponent:
.019a94	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.019a96	8d 8d 04	sta $048d			sta 		ExpCount
.019a99					_FPTSExponentLoop:
.019a99	bd 0c 03	lda $030c,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.019a9c	10 0e		bpl $019aac			bpl 		_FPTSTimes
.019a9e	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.019aa0	90 14		bcc $019ab6			bcc 		_FPTSScaledToExp
.019aa2	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.019aa4	20 02 9a	jsr $019a02			jsr 		FPUScale10A
.019aa7	ee 8d 04	inc $048d			inc 		ExpCount
.019aaa	80 ed		bra $019a99			bra 		_FPTSExponentLoop
.019aac					_FPTSTimes:
.019aac	a9 01		lda #$01			lda 		#1
.019aae	20 02 9a	jsr $019a02			jsr 		FPUScale10A
.019ab1	ce 8d 04	dec $048d			dec 		ExpCount
.019ab4	80 e3		bra $019a99			bra 		_FPTSExponentLoop
.019ab6					_FPTSScaledToExp:
.019ab6	20 d8 9a	jsr $019ad8			jsr 		FPTOutputBody 			; output the body.
.019ab9	a9 65		lda #$65			lda 		#"e"					; output E
.019abb	20 f4 94	jsr $0194f4			jsr 		ITSOutputCharacter
.019abe	ad 8d 04	lda $048d			lda 		ExpCount 				; get the exponent
.019ac1	9d 08 03	sta $0308,x			sta 		XS_Mantissa,x
.019ac4	29 80		and #$80			and 		#$80 					; sign extend it
.019ac6	f0 02		beq $019aca			beq 		_FPTSSExt
.019ac8	a9 ff		lda #$ff			lda 		#$FF
.019aca					_FPTSSExt:
.019aca	9d 09 03	sta $0309,x			sta 		XS_Mantissa+1,x
.019acd	9d 0a 03	sta $030a,x			sta 		XS_Mantissa+2,x
.019ad0	9d 0b 03	sta $030b,x			sta 		XS_Mantissa+3,x
.019ad3	20 50 94	jsr $019450			jsr 		INTToString 			; output the exponent.
.019ad6	80 98		bra $019a70			bra			_FPTSExit 				; and exit.
.019ad8					FPTOutputBody:
.019ad8	20 46 9a	jsr $019a46			jsr 		FPUCopyToNext 			; copy to next slot.
.019adb	20 39 99	jsr $019939			jsr 		FPUToInteger 			; convert to an integer
.019ade	20 50 94	jsr $019450			jsr 		INTToString 			; output the main integer part.
.019ae1	20 55 9a	jsr $019a55			jsr 		FPUCopyFromNext 		; get the fractional part back.
.019ae4	20 c5 97	jsr $0197c5			jsr 		FPFractionalPart 		; get the decimal part.
.019ae7	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; any fractional part.
.019aea	70 3e		bvs $019b2a			bvs 		_FPTOExit 				; if not, exit now.
.019aec	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.019aee	20 f4 94	jsr $0194f4			jsr 		ITSOutputCharacter
.019af1					_FPOutLoop:
.019af1	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; finally reached zero.
.019af4	70 1e		bvs $019b14			bvs 		_FPStripZeros 			; strip trailing zeros
.019af6	20 a1 99	jsr $0199a1			jsr 		FPUTimes10 				; multiply by 10
.019af9	20 46 9a	jsr $019a46			jsr 		FPUCopyToNext			; copy to next slot.
.019afc	20 39 99	jsr $019939			jsr 		FPUToInteger 			; convert to integer
.019aff	bd 08 03	lda $0308,x			lda 		XS_Mantissa+0,x 		; print digit.
.019b02	09 30		ora #$30			ora 		#"0"
.019b04	20 f4 94	jsr $0194f4			jsr 		ITSOutputCharacter
.019b07	20 55 9a	jsr $019a55			jsr 		FPUCopyFromNext 		; get it back
.019b0a	20 c5 97	jsr $0197c5			jsr 		FPFractionalPart 		; get fractional part
.019b0d	ad 04 04	lda $0404			lda 		NumBufX 				; done 11 characters yet ?
.019b10	c9 0b		cmp #$0b			cmp 	 	#11
.019b12	90 dd		bcc $019af1			bcc 		_FPOutLoop 				; if so, keep going till zero.
.019b14					_FPStripZeros:
.019b14	ac 04 04	ldy $0404			ldy 		NumBufX 				; strip trailing zeros.
.019b17					_FPStripLoop:
.019b17	88		dey				dey 								; back one, if at start then no strip
.019b18	f0 10		beq $019b2a			beq 		_FPToExit
.019b1a	b9 05 04	lda $0405,y			lda 		Num_Buffer,y 			; keep going if "0"
.019b1d	c9 30		cmp #$30			cmp 		#"0"
.019b1f	f0 f6		beq $019b17			beq 		_FPStripLoop
.019b21	c8		iny				iny
.019b22	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.019b24	99 05 04	sta $0405,y			sta 		Num_Buffer,y
.019b27	8c 04 04	sty $0404			sty 		NumBufX 				; update position.
.019b2a					_FPTOExit:
.019b2a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.019b2b					FPFromString:
.019b2b	48		pha				pha 								; push A
.019b2c	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.019b2e	c9 2e		cmp #$2e			cmp 	#"."
.019b30	f0 03		beq $019b35			beq	 	_FPFIsDecimal
.019b32	4c 98 9b	jmp $019b98			jmp 	_FPFNotDecimal
.019b35					_FPFIsDecimal:
.019b35	c8		iny				iny 								; consume the decimal.
.019b36	20 da 98	jsr $0198da			jsr 	FPUToFloat 					; convert the integer to float.
.019b39	da		phx				phx 								; save X.
.019b3a	5a		phy				phy 								; save decimal start position
.019b3b	e8		inx				inx
.019b3c	e8		inx				inx
.019b3d	e8		inx				inx
.019b3e	e8		inx				inx
.019b3f	e8		inx				inx
.019b40	e8		inx				inx
.019b41	20 0c 95	jsr $01950c			jsr 	INTFromStringY 				; get the part after the DP.
.019b44	20 da 98	jsr $0198da			jsr 	FPUToFloat 					; convert that to a float.
.019b47	68		pla				pla 								; calculate - chars consumed.
.019b48	8c 8c 04	sty $048c			sty 	ExpTemp
.019b4b	38		sec				sec
.019b4c	ed 8c 04	sbc $048c			sbc 	ExpTemp 					; this is the shift amount
.019b4f	20 02 9a	jsr $019a02			jsr 	FPUScale10A 				; scale it by 10^AC
.019b52	fa		plx				plx 								; restore original X
.019b53	20 bc 95	jsr $0195bc			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.019b56	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.019b58	c9 45		cmp #$45			cmp 	#"E"
.019b5a	f0 04		beq $019b60			beq 	_FPFExponent
.019b5c	c9 65		cmp #$65			cmp 	#"e"
.019b5e	d0 38		bne $019b98			bne 	_FPFNotDecimal 				; no, then exit normally.
.019b60					_FPFExponent:
.019b60	c8		iny				iny 								; skip over E symbol.
.019b61	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.019b63	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.019b65	d0 01		bne $019b68			bne 	_FPFGotSign
.019b67	c8		iny				iny 								; if it was - skip over it.
.019b68					_FPFGotSign:
.019b68	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.019b69	da		phx				phx
.019b6a	e8		inx				inx
.019b6b	e8		inx				inx
.019b6c	e8		inx				inx
.019b6d	e8		inx				inx
.019b6e	e8		inx				inx
.019b6f	e8		inx				inx
.019b70	20 0c 95	jsr $01950c			jsr 	INTFromStringY 				; get the exponent
.019b73	fa		plx				plx 								; restore X.
.019b74	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.019b77	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.019b7a	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.019b7d	d0 1b		bne $019b9a			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.019b7f	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.019b82	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.019b84	b0 14		bcs $019b9a			bcs 	_FPFXOverflow
.019b86	68		pla				pla 								; get direction
.019b87	d0 09		bne $019b92			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.019b89	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.019b8c	49 ff		eor #$ff			eor 	#$FF
.019b8e	1a		inc a				inc 	a
.019b8f	9d 0e 03	sta $030e,x			sta 	XS2_Mantissa+0,x
.019b92					_FPFXScale:
.019b92	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.019b95	20 02 9a	jsr $019a02			jsr 	FPUScale10A 				; scale by the exponent.
.019b98					_FPFNotDecimal:
.019b98	68		pla				pla
.019b99	60		rts				rts
.019b9a					_FPFXOverflow:
.019b9a	20 2f 84	jsr $01842f			jsr 	ERR_Handler
>019b9d	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>019ba5	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.019bac					Unary_Rnd:
.019bac	20 bc 89	jsr $0189bc			jsr 	EvaluateNumberX 			; get value
.019baf	20 4b 90	jsr $01904b			jsr 	CheckNextRParen 			; check right bracket.
.019bb2	20 a9 8c	jsr $018ca9			jsr 	GetSignCurrent 				; get sign -1,0,1.
.019bb5	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.019bb7	30 10		bmi $019bc9			bmi 	_URSetSeed
.019bb9	f0 2c		beq $019be7			beq 	_URMakeRandom 				; if zero return same number.
.019bbb	da		phx				phx
.019bbc	a2 00		ldx #$00			ldx 	#0
.019bbe	20 24 9c	jsr $019c24			jsr 	Random16
.019bc1	a2 02		ldx #$02			ldx 	#2
.019bc3	20 24 9c	jsr $019c24			jsr 	Random16
.019bc6	fa		plx				plx
.019bc7	80 1e		bra $019be7			bra 	_URMakeRandom
.019bc9					_URSetSeed:
.019bc9	20 da 98	jsr $0198da			jsr 	FPUToFloat 					; make it a float to twiddle it.
.019bcc	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.019bcf	8d 93 04	sta $0493			sta 	RandomSeed+0
.019bd2	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.019bd5	8d 94 04	sta $0494			sta 	RandomSeed+1
.019bd8	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.019bdb	8d 95 04	sta $0495			sta 	RandomSeed+2
.019bde	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.019be1	0a		asl a				asl 	a
.019be2	49 db		eor #$db			eor 	#$DB
.019be4	8d 96 04	sta $0496			sta 	RandomSeed+3
.019be7					_URMakeRandom:
.019be7	ad 93 04	lda $0493			lda 	RandomSeed+0 				; check if seed is zero.
.019bea	0d 94 04	ora $0494			ora 	RandomSeed+1
.019bed	0d 95 04	ora $0495			ora 	RandomSeed+2
.019bf0	0d 96 04	ora $0496			ora 	RandomSeed+3
.019bf3	d0 0a		bne $019bff			bne 	_URNotZero
.019bf5	a9 47		lda #$47			lda 	#$47
.019bf7	8d 94 04	sta $0494			sta 	RandomSeed+1				; if it is, make it non zero.
.019bfa	a9 3d		lda #$3d			lda 	#$3D
.019bfc	8d 96 04	sta $0496			sta 	RandomSeed+3
.019bff					_URNotZero:
.019bff	ad 93 04	lda $0493			lda 	RandomSeed+0 				; copy seed into mantissa.
.019c02	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019c05	ad 94 04	lda $0494			lda 	RandomSeed+1
.019c08	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019c0b	ad 95 04	lda $0495			lda 	RandomSeed+2
.019c0e	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019c11	ad 96 04	lda $0496			lda 	RandomSeed+3
.019c14	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019c17	a9 00		lda #$00			lda 	#$00 						; set type to float.
.019c19	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019c1c	a9 80		lda #$80			lda 	#$80
.019c1e	9d 0c 03	sta $030c,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.019c21	4c 11 99	jmp $019911			jmp 	FPUNormalise
.019c24					Random16:
.019c24	5e 94 04	lsr $0494,x			lsr 	RandomSeed+1,x				; shift seed right
.019c27	7e 93 04	ror $0493,x			ror 	RandomSeed,x
.019c2a	90 08		bcc $019c34			bcc 	_R16_NoXor
.019c2c	bd 94 04	lda $0494,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.019c2f	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.019c31	9d 94 04	sta $0494,x			sta 	RandomSeed+1,x
.019c34					_R16_NoXor:
.019c34	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.019c35					Unary_Int:
.019c35	20 bc 89	jsr $0189bc			jsr 	EvaluateNumberX 			; get value
.019c38	20 4b 90	jsr $01904b			jsr 	CheckNextRParen 			; check right bracket.
.019c3b	4c 39 99	jmp $019939			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Return to file: basic.asm

>019c3e	02						.byte 	2
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 c0						.word 	StartROM
>fffe	19 c0					.word TIM_BreakHandler

;******  End of listing
