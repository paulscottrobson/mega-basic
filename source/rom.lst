
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Thu Aug 22 10:51:03 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="65816"				cpu = "65816"
="em65816"				hardware = "em65816"
=1					hasFloat = 1
=1					hasInteger = 1
=253					maxString = 253

;******  Processing file: modules/float/fpmacros.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/em65816/src_em65816.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/common/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0020					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0200					IFT_XCursor:.byte ?							; current logical position on screen
>0201					IFT_YCursor:.byte ?
>0202					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0266					IFT_LineBuffer: .fill 100 					; line input buffer.
>0300					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>0304					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>0305					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=774					XS2_Mantissa = XS_Mantissa+XS_Size
=778					XS2_Exponent = XS_Exponent+XS_Size
=779					XS2_Type = XS_Type+XS_Size
=780					XS3_Mantissa = XS_Mantissa+XS_Size*2
=784					XS3_Exponent = XS_Exponent+XS_Size*2
=785					XS3_Type = XS_Type+XS_Size*2
>0400					Num_Buffer	.fill 	32 						; buffer for numeric conversions
>0420					NumBufX 	.byte 	?						; buffer index position
>0421					NumSuppress	.byte 	?						; leading zero suppression flag
>0422					NumConvCount .byte 	? 						; count for conversions.
>0423					ExpTemp:	.byte ?							; Working temp for exponents.
>0424					ExpCount:	.byte ? 						; Count of decimal exponents.
>0425					SignCount:	.byte ?							; Integer Divide Sign Counts.
>0426					StringPtr:	.byte ? 						; Top of free memory (for string allocation)
>0427					TempStringWriteIndex: .byte ? 				; Write offset.
>0428					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>042a					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>042c					Tim_SR:		.byte ? 						; Processor Status
>042d					Tim_A:		.byte ? 						; Processor Registers
>042e					Tim_X:		.byte ?
>042f					Tim_Y:		.byte ?
>0430					Tim_Z:		.byte ?
>0431					Tim_SP:		.byte ?							; Stack Pointer

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/em65816.asm

=$8000					HighMemory = $8000
.1000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testcode.src

>1000	19 0a 00 d7 4f 8a 40 fd			.byte	$19,$0a,$00,$d7,$4f,$8a,$40,$fd
>1008	03 31 8c 42 84 4f fd 03			.byte	$03,$31,$8c,$42,$84,$4f,$fd,$03
>1010	32 bc ff 06 68 69 20 21			.byte	$32,$bc,$ff,$06,$68,$69,$20,$21
>1018	00 00					.byte	$00,$00

;******  Return to file: modules/hardware/em65816.asm


;******  Processing file: modules/hardware/../common/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b2					lastUnaryFunction = $b2
.c000					VectorTable:
>c000	9b c5					.word BinaryOp_And         ; $80 and
>c002	c3 c5					.word BinaryOp_Or          ; $81 or
>c004	eb c5					.word BinaryOp_Xor         ; $82 xor
>c006	eb c5					.word BinaryOp_Eor         ; $83 eor
>c008	2e c6					.word Binary_Equal         ; $84 =
>c00a	4d c6					.word Binary_NotEqual      ; $85 <>
>c00c	56 c6					.word Binary_Less          ; $86 <
>c00e	5f c6					.word Binary_LessEqual     ; $87 <=
>c010	71 c6					.word Binary_Greater       ; $88 >
>c012	68 c6					.word Binary_GreaterEqual  ; $89 >=
>c014	99 c6					.word BinaryOp_Add         ; $8a +
>c016	b9 c6					.word BinaryOp_Subtract    ; $8b -
>c018	cc c6					.word BinaryOp_Multiply    ; $8c *
>c01a	df c6					.word BinaryOp_Divide      ; $8d /
>c01c	ae c0					.word NotImplemented       ; $8e ^
>c01e	ae c0					.word NotImplemented       ; $8f if
>c020	ae c0					.word NotImplemented       ; $90 while
>c022	ae c0					.word NotImplemented       ; $91 repeat
>c024	ae c0					.word NotImplemented       ; $92 for
>c026	ae c0					.word NotImplemented       ; $93 then
>c028	ae c0					.word NotImplemented       ; $94 endif
>c02a	ae c0					.word NotImplemented       ; $95 wend
>c02c	ae c0					.word NotImplemented       ; $96 until
>c02e	ae c0					.word NotImplemented       ; $97 next
>c030	ae c0					.word NotImplemented       ; $98 not
>c032	ae c0					.word NotImplemented       ; $99 fn(
>c034	ae c0					.word NotImplemented       ; $9a abs(
>c036	ae c0					.word NotImplemented       ; $9b asc(
>c038	ae c0					.word NotImplemented       ; $9c int(
>c03a	ae c0					.word NotImplemented       ; $9d peek(
>c03c	ae c0					.word NotImplemented       ; $9e rnd(
>c03e	ae c0					.word NotImplemented       ; $9f usr(
>c040	ae c0					.word NotImplemented       ; $a0 left$(
>c042	ae c0					.word NotImplemented       ; $a1 right$(
>c044	ae c0					.word NotImplemented       ; $a2 mid$(
>c046	ae c0					.word NotImplemented       ; $a3 spc(
>c048	ae c0					.word NotImplemented       ; $a4 str$(
>c04a	ae c0					.word NotImplemented       ; $a5 val(
>c04c	ae c0					.word NotImplemented       ; $a6 len(
>c04e	ae c0					.word NotImplemented       ; $a7 hex$(
>c050	ae c0					.word NotImplemented       ; $a8 sin(
>c052	ae c0					.word NotImplemented       ; $a9 cos(
>c054	ae c0					.word NotImplemented       ; $aa tan(
>c056	ae c0					.word NotImplemented       ; $ab atn(
>c058	ae c0					.word NotImplemented       ; $ac exp(
>c05a	ae c0					.word NotImplemented       ; $ad log(
>c05c	ae c0					.word NotImplemented       ; $ae sqr(
>c05e	ae c0					.word NotImplemented       ; $af dec(
>c060	ae c0					.word NotImplemented       ; $b0 deek(
>c062	ae c0					.word NotImplemented       ; $b1 leek(
>c064	ae c0					.word NotImplemented       ; $b2 mod(
>c066	ae c0					.word NotImplemented       ; $b3 $(
>c068	ae c0					.word NotImplemented       ; $b4 $
>c06a	ae c0					.word NotImplemented       ; $b5 #(
>c06c	ae c0					.word NotImplemented       ; $b6 #
>c06e	ae c0					.word NotImplemented       ; $b7 %(
>c070	ae c0					.word NotImplemented       ; $b8 %
>c072	ae c0					.word NotImplemented       ; $b9 (
>c074	ae c0					.word NotImplemented       ; $ba )
>c076	ae c0					.word NotImplemented       ; $bb ,
>c078	ae c0					.word NotImplemented       ; $bc :
>c07a	ae c0					.word NotImplemented       ; $bd ;
>c07c	ae c0					.word NotImplemented       ; $be def
>c07e	0b c4					.word CLR_Command          ; $bf clr
>c080	ae c0					.word NotImplemented       ; $c1 data
>c082	ae c0					.word NotImplemented       ; $c2 read
>c084	ae c0					.word NotImplemented       ; $c3 dim
>c086	ae c0					.word NotImplemented       ; $c4 to
>c088	ae c0					.word NotImplemented       ; $c5 step
>c08a	ae c0					.word NotImplemented       ; $c6 gosub
>c08c	ae c0					.word NotImplemented       ; $c7 return
>c08e	ae c0					.word NotImplemented       ; $c8 goto
>c090	ae c0					.word NotImplemented       ; $c9 input
>c092	ae c0					.word NotImplemented       ; $ca let
>c094	ae c0					.word NotImplemented       ; $cb list
>c096	ae c0					.word NotImplemented       ; $cc new
>c098	ae c0					.word NotImplemented       ; $cd old
>c09a	ae c0					.word NotImplemented       ; $ce on
>c09c	ae c0					.word NotImplemented       ; $cf restore
>c09e	ae c0					.word NotImplemented       ; $d0 poke
>c0a0	ae c0					.word NotImplemented       ; $d1 print
>c0a2	ae c0					.word NotImplemented       ; $d2 run
>c0a4	ae c0					.word NotImplemented       ; $d3 stop
>c0a6	ae c0					.word NotImplemented       ; $d4 wait
>c0a8	ae c0					.word NotImplemented       ; $d5 doke
>c0aa	ae c0					.word NotImplemented       ; $d6 loke
>c0ac	ae c0					.word NotImplemented       ; $d7 assert
.c0ae					NotImplemented:
.c0ae	80 fe		bra $c0ae		_error: bra _error
.c0b0					BinaryPrecedence:
>c0b0	01					.byte 1    ; $80 and
>c0b1	01					.byte 1    ; $81 or
>c0b2	01					.byte 1    ; $82 xor
>c0b3	01					.byte 1    ; $83 eor
>c0b4	02					.byte 2    ; $84 =
>c0b5	02					.byte 2    ; $85 <>
>c0b6	02					.byte 2    ; $86 <
>c0b7	02					.byte 2    ; $87 <=
>c0b8	02					.byte 2    ; $88 >
>c0b9	02					.byte 2    ; $89 >=
>c0ba	03					.byte 3    ; $8a +
>c0bb	03					.byte 3    ; $8b -
>c0bc	04					.byte 4    ; $8c *
>c0bd	04					.byte 4    ; $8d /
>c0be	05					.byte 5    ; $8e ^
.c0bf					KeywordText:
>c0bf	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>c0c2	4f d2					.byte $4f,$d2                          ; $81 or
>c0c4	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>c0c7	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>c0ca	bd					.byte $bd                              ; $84 =
>c0cb	3c be					.byte $3c,$be                          ; $85 <>
>c0cd	bc					.byte $bc                              ; $86 <
>c0ce	3c bd					.byte $3c,$bd                          ; $87 <=
>c0d0	be					.byte $be                              ; $88 >
>c0d1	3e bd					.byte $3e,$bd                          ; $89 >=
>c0d3	ab					.byte $ab                              ; $8a +
>c0d4	ad					.byte $ad                              ; $8b -
>c0d5	aa					.byte $aa                              ; $8c *
>c0d6	af					.byte $af                              ; $8d /
>c0d7	de					.byte $de                              ; $8e ^
>c0d8	49 c6					.byte $49,$c6                          ; $8f if
>c0da	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>c0df	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>c0e5	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>c0e8	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>c0ec	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>c0f1	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>c0f5	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>c0fa	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>c0fe	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>c101	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>c104	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>c108	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>c10c	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>c110	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>c115	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>c119	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>c11d	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>c123	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>c12a	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>c12f	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>c133	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>c138	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>c13c	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>c140	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>c145	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>c149	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>c14d	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>c151	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>c155	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>c159	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>c15d	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>c161	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>c165	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>c16a	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>c16f	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>c173	24 a8					.byte $24,$a8                          ; $b3 $(
>c175	a4					.byte $a4                              ; $b4 $
>c176	23 a8					.byte $23,$a8                          ; $b5 #(
>c178	a3					.byte $a3                              ; $b6 #
>c179	25 a8					.byte $25,$a8                          ; $b7 %(
>c17b	a5					.byte $a5                              ; $b8 %
>c17c	a8					.byte $a8                              ; $b9 (
>c17d	a9					.byte $a9                              ; $ba )
>c17e	ac					.byte $ac                              ; $bb ,
>c17f	ba					.byte $ba                              ; $bc :
>c180	bb					.byte $bb                              ; $bd ;
>c181	44 45 c6				.byte $44,$45,$c6                      ; $be def
>c184	43 4c d2				.byte $43,$4c,$d2                      ; $bf clr
>c187	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c1 data
>c18b	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c2 read
>c18f	44 49 cd				.byte $44,$49,$cd                      ; $c3 dim
>c192	54 cf					.byte $54,$cf                          ; $c4 to
>c194	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c5 step
>c198	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $c6 gosub
>c19d	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $c7 return
>c1a3	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $c8 goto
>c1a7	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $c9 input
>c1ac	4c 45 d4				.byte $4c,$45,$d4                      ; $ca let
>c1af	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $cb list
>c1b3	4e 45 d7				.byte $4e,$45,$d7                      ; $cc new
>c1b6	4f 4c c4				.byte $4f,$4c,$c4                      ; $cd old
>c1b9	4f ce					.byte $4f,$ce                          ; $ce on
>c1bb	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $cf restore
>c1c2	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d0 poke
>c1c6	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d1 print
>c1cb	52 55 ce				.byte $52,$55,$ce                      ; $d2 run
>c1ce	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $d3 stop
>c1d2	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d4 wait
>c1d6	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $d5 doke
>c1da	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $d6 loke
>c1de	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $d7 assert
>c1e4	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_dollarlparen = $b3
=$b4					token_dollar = $b4
=$b5					token_hashlparen = $b5
=$b6					token_hash = $b6
=$b7					token_percentlparen = $b7
=$b8					token_percent = $b8
=$b9					token_lparen = $b9
=$ba					token_rparen = $ba
=$bb					token_comma = $bb
=$bc					token_colon = $bc
=$bd					token_semicolon = $bd
=$be					token_def = $be
=$bf					token_clr = $bf
=$c1					token_data = $c1
=$c2					token_read = $c2
=$c3					token_dim = $c3
=$c4					token_to = $c4
=$c5					token_step = $c5
=$c6					token_gosub = $c6
=$c7					token_return = $c7
=$c8					token_goto = $c8
=$c9					token_input = $c9
=$ca					token_let = $ca
=$cb					token_list = $cb
=$cc					token_new = $cc
=$cd					token_old = $cd
=$ce					token_on = $ce
=$cf					token_restore = $cf
=$d0					token_poke = $d0
=$d1					token_print = $d1
=$d2					token_run = $d2
=$d3					token_stop = $d3
=$d4					token_wait = $d4
=$d5					token_doke = $d5
=$d6					token_loke = $d6
=$d7					token_assert = $d7

;******  Return to file: modules/hardware/em65816.asm

.c1e5					StartROM:
.c1e5	18		clc				clc
.c1e6	fb		xce				xce
.c1e7	c2 30		rep #$30			rep 	#$30
.c1e9	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.c1ec	1b		tcs				tcs
.c1ed	e2 30		sep #$30			sep 	#$30 						; clear AXY in 16 bit.
.c1ef	c2 30		rep #$30			rep 	#$30
.c1f1	a9 00 00	lda #$0000			lda 	#$0000
.c1f4	aa		tax				tax
.c1f5	a8		tay				tay
.c1f6	e2 30		sep #$30			sep 	#$30
.c1f8	20 9c c3	jsr $c39c			jsr 	IF_Reset 					; reset external interface
.c1fb	20 01 c2	jsr $c201			jsr 	IFT_ClearScreen
.c1fe	4c eb c3	jmp $c3eb		jmp BASIC_Start

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.c201					IFT_ClearScreen:
.c201	48		pha				pha
.c202	da		phx				phx
.c203	5a		phy				phy
.c204	20 9d c3	jsr $c39d			jsr 	IF_Home 					; home cursor
.c207	a2 20		ldx #$20			ldx 	#IF_Height 					; this many lines.
.c209					_IFT_CS0:
.c209	a0 40		ldy #$40			ldy 	#IF_Width 					; this many chars/line
.c20b					_IFT_CS1:
.c20b	a9 20		lda #$20			lda 	#' '						; clear line.
.c20d	20 c9 c3	jsr $c3c9			jsr 	IF_Write
.c210	88		dey				dey
.c211	d0 f8		bne $c20b			bne 	_IFT_CS1
.c213	20 b0 c3	jsr $c3b0			jsr 	IF_NewLine 					; next line down
.c216	ca		dex				dex
.c217	d0 f0		bne $c209			bne 	_IFT_CS0
.c219	7a		ply				ply
.c21a	fa		plx				plx
.c21b	68		pla				pla
.c21c					IFT_HomeCursor:
.c21c	48		pha				pha
.c21d	20 9d c3	jsr $c39d			jsr 	IF_Home
.c220	a9 00		lda #$00			lda 	#0
.c222	8d 00 02	sta $0200			sta 	IFT_XCursor
.c225	8d 01 02	sta $0201			sta 	IFT_YCursor
.c228	68		pla				pla
.c229	60		rts				rts
.c22a					IFT_UpLine:
.c22a	48		pha				pha
.c22b	ad 01 02	lda $0201			lda  	IFT_YCursor 				; get Y
.c22e	3a		dec a				dec 	a 							; line above
.c22f	30 03		bmi $c234			bmi 	_IFTULExit 					; too far, abort
.c231	20 bf c2	jsr $c2bf			jsr 	IFT_SetYPos					; set to that line.
.c234					_IFTULExit:
.c234	68		pla				pla
.c235	60		rts				rts
.c236					IFT_PrintCharacter:
.c236	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.c238	f0 16		beq $c250			beq 	IFT_NewLine
.c23a	48		pha				pha
.c23b	20 68 c2	jsr $c268			jsr 	IFT_UpperCase 				; make upper case
.c23e	20 c9 c3	jsr $c3c9			jsr 	IF_Write 					; write out.
.c241	ee 00 02	inc $0200			inc 	IFT_XCursor 				; bump x cursor
.c244	ad 00 02	lda $0200			lda 	IFT_XCursor 				; reached RHS ?
.c247	c9 40		cmp #$40			cmp 	#IF_Width
.c249	d0 03		bne $c24e			bne 	_IFT_PCNotEOL
.c24b	20 50 c2	jsr $c250			jsr 	IFT_NewLine 				; if so do new line.
.c24e					_IFT_PCNotEOL:
.c24e	68		pla				pla
.c24f	60		rts				rts
.c250					IFT_NewLine:
.c250	48		pha				pha
.c251	20 b0 c3	jsr $c3b0			jsr 	IF_NewLine 					; new line on actual screen.
.c254	a9 00		lda #$00			lda 	#0 							; reset x position
.c256	8d 00 02	sta $0200			sta 	IFT_XCursor
.c259	ee 01 02	inc $0201			inc 	IFT_YCursor 				; move down.
.c25c	ad 01 02	lda $0201			lda 	IFT_YCursor
.c25f	c9 20		cmp #$20			cmp 	#IF_Height 					; reached bottom.
.c261	d0 03		bne $c266			bne 	_IFT_NL_NotEOS
.c263	20 73 c2	jsr $c273			jsr 	IFT_Scroll 					; scroll screen up.
.c266					_IFT_NL_NotEOS:
.c266	68		pla				pla
.c267	60		rts				rts
.c268					IFT_UpperCase:
.c268	c9 61		cmp #$61			cmp 	#"a"
.c26a	90 06		bcc $c272			bcc 	_IFT_UCExit
.c26c	c9 7b		cmp #$7b			cmp 	#"z"+1
.c26e	b0 02		bcs $c272			bcs 	_IFT_UCExit
.c270	49 20		eor #$20			eor 	#$20
.c272					_IFT_UCExit:
.c272	60		rts				rts
.c273					IFT_Scroll:
.c273	48		pha				pha 								; save AXY
.c274	da		phx				phx
.c275	5a		phy				phy
.c276	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.c278					_IFT_SLoop:
.c278	20 98 c2	jsr $c298			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.c27b	e8		inx				inx
.c27c	e0 1f		cpx #$1f			cpx 	#IF_Height-1				; do whole screen
.c27e	d0 f8		bne $c278			bne 	_IFT_SLoop
.c280	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.c282	20 bf c2	jsr $c2bf			jsr 	IFT_SetYPos
.c285	a2 40		ldx #$40			ldx 	#IF_Width 					; blank line
.c287					_IFT_SBlank:
.c287	a9 20		lda #$20			lda 	#32
.c289	20 c9 c3	jsr $c3c9			jsr 	IF_Write
.c28c	ca		dex				dex
.c28d	d0 f8		bne $c287			bne 	_IFT_SBlank
.c28f	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.c291	20 bf c2	jsr $c2bf			jsr 	IFT_SetYPos
.c294	7a		ply				ply
.c295	fa		plx				plx
.c296	68		pla				pla
.c297	60		rts				rts
.c298					_IFT_ScrollLine:
.c298	da		phx				phx
.c299	da		phx				phx
.c29a	8a		txa				txa 								; copy line into buffer.
.c29b	1a		inc a				inc 	a 							; next line down.
.c29c	20 bf c2	jsr $c2bf			jsr 	IFT_SetYPos
.c29f	a2 00		ldx #$00			ldx 	#0
.c2a1					_IFTScrollCopy1:
.c2a1	20 c0 c3	jsr $c3c0			jsr 	IF_Read
.c2a4	9d 02 02	sta $0202,x			sta 	IFT_Buffer,x
.c2a7	e8		inx				inx
.c2a8	e0 40		cpx #$40			cpx 	#IF_Width
.c2aa	d0 f5		bne $c2a1			bne 	_IFTScrollCopy1
.c2ac	68		pla				pla
.c2ad	20 bf c2	jsr $c2bf			jsr 	IFT_SetYPos
.c2b0	a2 00		ldx #$00			ldx 	#0
.c2b2					_IFTScrollCopy2:
.c2b2	bd 02 02	lda $0202,x			lda 	IFT_Buffer,x
.c2b5	20 c9 c3	jsr $c3c9			jsr 	IF_Write
.c2b8	e8		inx				inx
.c2b9	e0 40		cpx #$40			cpx 	#IF_Width
.c2bb	d0 f5		bne $c2b2			bne 	_IFTScrollCopy2
.c2bd	fa		plx				plx
.c2be	60		rts				rts
.c2bf					IFT_SetYPos:
.c2bf	48		pha				pha
.c2c0	da		phx				phx
.c2c1	aa		tax				tax
.c2c2	20 1c c2	jsr $c21c			jsr 	IFT_HomeCursor
.c2c5	e0 00		cpx #$00			cpx 	#0
.c2c7	f0 09		beq $c2d2			beq 	_IFT_MOAExit
.c2c9					_IFT_MOALoop:
.c2c9	20 b0 c3	jsr $c3b0			jsr 	IF_NewLine
.c2cc	ee 01 02	inc $0201			inc 	IFT_YCursor
.c2cf	ca		dex				dex
.c2d0	d0 f7		bne $c2c9			bne		_IFT_MOALoop
.c2d2					_IFT_MOAExit:
.c2d2	fa		plx				plx
.c2d3	68		pla				pla
.c2d4	60		rts				rts
.c2d5					IFT_GetKeyCursor:
.c2d5	20 dd c2	jsr $c2dd			jsr 	_IFT_FlipCursor 			; reverse current
.c2d8					_IFT_GKCWait:
.c2d8	20 da c3	jsr $c3da			jsr 	IF_GetKey 					; get key
.c2db	f0 fb		beq $c2d8			beq 	_IFT_GKCWait
.c2dd					_IFT_FlipCursor:
.c2dd	48		pha				pha 								; save
.c2de	20 c0 c3	jsr $c3c0			jsr 	IF_Read 					; read
.c2e1	20 d2 c3	jsr $c3d2			jsr 	IF_LeftOne
.c2e4	49 80		eor #$80			eor 	#$80 						; reverse
.c2e6	20 c9 c3	jsr $c3c9			jsr 	IF_Write 					; write
.c2e9	20 d2 c3	jsr $c3d2			jsr 	IF_LeftOne
.c2ec	68		pla				pla
.c2ed	60		rts				rts
.c2ee					IFT_ReadLine:
.c2ee	48		pha				pha
.c2ef					_IFT_RLLoop:
.c2ef	20 d5 c2	jsr $c2d5			jsr 	IFT_GetKeyCursor 			; get keystroke
.c2f2	c9 0d		cmp #$0d			cmp 	#13							; return
.c2f4	f0 7d		beq $c373			beq 	_IFT_RLExit
.c2f6	c9 20		cmp #$20			cmp 	#32 						; control character
.c2f8	90 05		bcc $c2ff			bcc 	_IFT_Control
.c2fa	20 36 c2	jsr $c236			jsr 	IFT_PrintCharacter
.c2fd	80 f0		bra $c2ef			bra 	_IFT_RLLoop
.c2ff					_IFT_Control:
.c2ff	c9 01		cmp #$01			cmp 	#"A"-64
.c301	f0 26		beq $c329			beq 	_IFT_Left
.c303	c9 04		cmp #$04			cmp 	#"D"-64
.c305	f0 2e		beq $c335			beq 	_IFT_Right
.c307	c9 17		cmp #$17			cmp 	#"W"-64
.c309	f0 36		beq $c341			beq 	_IFT_Up
.c30b	c9 13		cmp #$13			cmp 	#"S"-64
.c30d	f0 3e		beq $c34d			beq 	_IFT_Down
.c30f	c9 08		cmp #$08			cmp 	#"H"-64
.c311	f0 09		beq $c31c			beq 	_IFT_Backspace
.c313	c9 1a		cmp #$1a			cmp 	#"Z"-64
.c315	d0 d8		bne $c2ef			bne 	_IFT_RLLoop
.c317	20 01 c2	jsr $c201			jsr 	IFT_ClearScreen				; clear CTL-Z
.c31a	80 d3		bra $c2ef			bra 	_IFT_RLLoop
.c31c					_IFT_Backspace:
.c31c	ad 00 02	lda $0200			lda 	IFT_XCursor 				; check not start of line.
.c31f	f0 ce		beq $c2ef			beq 	_IFT_RLLoop
.c321	20 d2 c3	jsr $c3d2			jsr 	IF_LeftOne
.c324	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.c326	20 c9 c3	jsr $c3c9			jsr 	IF_Write
.c329					_IFT_Left:
.c329	ce 00 02	dec $0200			dec 	IFT_XCursor 				; left CTL-W
.c32c	10 29		bpl $c357			bpl 	_IFT_Reposition
.c32e	a9 3f		lda #$3f			lda 	#IF_Width-1
.c330					_IFT_SetX:
.c330	8d 00 02	sta $0200			sta 	IFT_XCursor
.c333	80 22		bra $c357			bra 	_IFT_Reposition
.c335					_IFT_Right:
.c335	ee 00 02	inc $0200			inc 	IFT_XCursor
.c338	ad 00 02	lda $0200			lda 	IFT_XCursor
.c33b	49 40		eor #$40			eor 	#IF_Width
.c33d	f0 f1		beq $c330			beq 	_IFT_SetX
.c33f	80 16		bra $c357			bra 	_IFT_Reposition
.c341					_IFT_Up:
.c341	ce 01 02	dec $0201			dec 	IFT_YCursor
.c344	10 11		bpl $c357			bpl 	_IFT_Reposition
.c346	a9 1f		lda #$1f			lda 	#IF_Height-1
.c348					_IFT_SetY:
.c348	8d 01 02	sta $0201			sta 	IFT_YCursor
.c34b	80 0a		bra $c357			bra 	_IFT_Reposition
.c34d					_IFT_Down:
.c34d	ee 01 02	inc $0201			inc 	IFT_YCursor
.c350	ad 01 02	lda $0201			lda 	IFT_YCursor
.c353	49 20		eor #$20			eor 	#IF_Height
.c355	f0 f1		beq $c348			beq 	_IFT_SetY
.c357					_IFT_Reposition:
.c357	ad 00 02	lda $0200			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.c35a	48		pha				pha
.c35b	ad 01 02	lda $0201			lda 	IFT_YCursor
.c35e	20 bf c2	jsr $c2bf			jsr 	IFT_SetYPos
.c361	68		pla				pla
.c362	aa		tax				tax
.c363	e0 00		cpx #$00			cpx 	#0
.c365	f0 88		beq $c2ef			beq 	_IFT_RLLoop
.c367					_IFT_MoveRight:
.c367	20 c0 c3	jsr $c3c0			jsr 	IF_Read
.c36a	ee 00 02	inc $0200			inc 	IFT_XCursor
.c36d	ca		dex				dex
.c36e	d0 f7		bne $c367			bne 	_IFT_MoveRight
.c370	4c ef c2	jmp $c2ef			jmp 	_IFT_RLLoop
.c373					_IFT_RLExit:
.c373	ad 01 02	lda $0201			lda 	IFT_YCursor 				; go to start of line.
.c376	20 bf c2	jsr $c2bf			jsr 	IFT_SetYPos
.c379	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.c37b					_IFT_RLRead:
.c37b	20 c0 c3	jsr $c3c0			jsr 	IF_Read
.c37e	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.c381	e8		inx				inx
.c382	e0 40		cpx #$40			cpx 	#IF_Width
.c384	d0 f5		bne $c37b			bne 	_IFT_RLRead
.c386					_IFT_RL_Trim:
.c386	ca		dex				dex 	 							; previous char
.c387	30 07		bmi $c390			bmi 	_IFT_Found 					; gone too far
.c389	bd 66 02	lda $0266,x			lda 	IFT_LineBuffer,x			; go back if space
.c38c	c9 20		cmp #$20			cmp 	#" "
.c38e	f0 f6		beq $c386			beq 	_IFT_RL_Trim
.c390					_IFT_Found:
.c390	e8		inx				inx 								; forward to non-space
.c391	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.c393	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.c396	68		pla				pla
.c397	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.c399	a0 02		ldy #$02			ldy 	#IFT_LineBuffer >> 8
.c39b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_em65816.asm

=64					IF_Width 	= 64 							; characters across
=32					IF_Height 	= 32 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line.
=8					IF_XPos 	= 8 							; current position, horizontal.
=$f0000					IF_Screen = $F0000							; 2k screen RAM here
=$f8010					IF_PKeyboard = $F8010						; Keyboard port.
=$f8000					IF_PBreak = $F8000 							; Break key.
.c39c					IF_Reset:
.c39c	60		rts				rts
.c39d					IF_Home:
.c39d	48		pha				pha
.c39e	64 08		stz $08				stz 	IF_XPos 					; zero X position
.c3a0	a9 00		lda #$00			lda 	#IF_Screen & $FF 			; set r/w pos.
.c3a2	85 04		sta $04				sta 	IF_Pos
.c3a4	a9 00		lda #$00			lda 	#(IF_Screen >> 8) & $FF
.c3a6	85 05		sta $05				sta 	IF_Pos+1
.c3a8	a9 0f		lda #$0f			lda 	#IF_Screen >> 16
.c3aa	85 06		sta $06				sta 	IF_Pos+2
.c3ac	64 07		stz $07				stz 	IF_Pos+3
.c3ae	68		pla				pla
.c3af	60		rts				rts
.c3b0					IF_NewLine:
.c3b0	48		pha				pha
.c3b1	64 08		stz $08				stz 	IF_XPos						; back to start of line
.c3b3	18		clc				clc 								; down one line
.c3b4	a5 04		lda $04				lda 	IF_Pos
.c3b6	69 40		adc #$40			adc 	#64
.c3b8	85 04		sta $04				sta 	IF_Pos
.c3ba	90 02		bcc $c3be			bcc 	_IF_NoCarry 				; carry through.
.c3bc	e6 05		inc $05				inc 	IF_Pos+1
.c3be					_IF_NoCarry:
.c3be	68		pla				pla
.c3bf	60		rts				rts
.c3c0					IF_Read:
.c3c0	5a		phy				phy 								; save current Y
.c3c1	a4 08		ldy $08				ldy 	IF_XPos 					; read character at current position
.c3c3	b7 04		lda [$04],y			lda 	[IF_Pos],y
.c3c5	e6 08		inc $08				inc 	IF_XPos 					; step right.
.c3c7	7a		ply				ply									; restore Y
.c3c8	60		rts				rts
.c3c9					IF_Write:
.c3c9	5a		phy				phy 								; save current Y
.c3ca	a4 08		ldy $08				ldy 	IF_XPos 					; write character at current position
.c3cc	97 04		sta [$04],y			sta 	[IF_Pos],y
.c3ce	e6 08		inc $08				inc 	IF_XPos 					; step right.
.c3d0	7a		ply				ply									; restore Y
.c3d1	60		rts				rts
.c3d2					IF_LeftOne:
.c3d2	c6 08		dec $08				dec 	IF_XPos
.c3d4	60		rts				rts
.c3d5					IF_CheckBreak:
.c3d5	af 00 80 0f	lda $0f8000			lda 	IF_PBreak					; non-zero if Ctrl+C pressed.
.c3d9	60		rts				rts
.c3da					IF_GetKey:
.c3da	af 10 80 0f	lda $0f8010			lda 	IF_PKeyboard				; read keyboard
.c3de	f0 08		beq $c3e8			beq		_IFGK_NoKey 				; skip if zero,no key pressed
.c3e0	48		pha				pha 								; key pressed, clear queue.
.c3e1	a9 00		lda #$00			lda 	#0
.c3e3	8f 10 80 0f	sta $0f8010			sta 	IF_PKeyboard
.c3e7	68		pla				pla
.c3e8					_IFGK_NoKey:
.c3e8	09 00		ora #$00			ora 	#0							; set Z flag appropriately.
.c3ea	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm

.c3eb					BASIC_Start:
.c3eb	20 0b c4	jsr $c40b			jsr 	ResetRunStatus 				; clear everything (CLR command)
.c3ee	a9 00		lda #$00			lda 	#0 							; mark temp string pointer uninitialised.
.c3f0	85 21		sta $21				sta 	zTempStr+1 					; (done before every base level evaluation/or command)
.c3f2	a9 00		lda #$00			lda 	#BasicProgram & $FF
.c3f4	85 16		sta $16				sta 	zCodePtr+0
.c3f6	a9 10		lda #$10			lda 	#BasicProgram >> 8
.c3f8	85 17		sta $17				sta 	zCodePtr+1
.c3fa	a9 00		lda #$00			lda 	#0
.c3fc	85 18		sta $18				sta 	zCodePtr+2
.c3fe	85 19		sta $19				sta 	zCodePtr+3
.c400	a0 03		ldy #$03			ldy 	#3
.c402	c8		iny				iny
.c403	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c405	20 19 c4	jsr $c419			jsr 	EvaluateExpression
>c408	02						.byte 	2
.c409					SyntaxError:
.c409					ERR_Handler:
.c409	80 fe		bra $c409			bra 	ERR_Handler

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.c40b					CLR_Command:
.c40b					ResetRunStatus:
.c40b	a9 00		lda #$00			lda 	#HighMemory & $FF
.c40d	8d 26 04	sta $0426			sta 	StringPtr
.c410	a9 80		lda #$80			lda 	#HighMemory >> 8
.c412	8d 27 04	sta $0427			sta 	StringPtr+1
.c415	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.c416					EVESyntax:
.c416	4c 09 c4	jmp $c409			jmp 	SyntaxError
.c419					EvaluateExpression:
.c419	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.c41b					EvaluateExpressionX:
.c41b	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.c41d					EvaluateExpressionXA:
.c41d	48		pha				pha 								; save precedence on stack.
.c41e	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c420	f0 f4		beq $c416			beq 	EVESyntax 					; end of line, syntax error.
.c422	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.c424	b0 03		bcs $c429			bcs 	_EVNotVariable
.c426	4c 05 c5	jmp $c505			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.c429					_EVNotVariable:
.c429	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.c42b	90 e9		bcc $c416			bcc 	EVESyntax
.c42d	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.c42f	b0 7b		bcs $c4ac			bcs 	_EVNotInteger
.c431	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.c433	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.c436	a9 00		lda #$00			lda 	#0
.c438	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c43b	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c43e	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c441	a9 01		lda #$01			lda 	#1 							; set to type 1 (integer)
.c443	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c446					_EVCheckNextInteger:
.c446	c8		iny				iny
.c447	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c449	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.c44b	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.c44d	b0 0d		bcs $c45c			bcs 	_EVCheckDecimal
.c44f	48		pha				pha 								; save it.
.c450	20 09 c5	jsr $c509			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.c453	68		pla				pla
.c454	1d 00 03	ora $0300,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.c457	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c45a	80 ea		bra $c446			bra 	_EVCheckNextInteger
.c45c					_EVCheckDecimal:
.c45c	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c45e	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.c460	d0 05		bne $c467			bne 	_EVGotAtom 					; no, get atom.
.c462					_EVIsDecimal:
.c462	20 39 c5	jsr $c539			jsr 	EVGetDecimal 				; extend to the decimal part.
.c465	80 00		bra $c467			bra 	_EVGotAtom 					; and continue to got atom.
.c467					_EVGotAtom:
.c467	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c469	10 3f		bpl $c4aa			bpl 	_EVExitDrop 				; must be a token.
.c46b	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.c46d	b0 3b		bcs $c4aa			bcs 	_EVExitDrop
.c46f	68		pla				pla 								; get current precedence
.c470	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.c472	da		phx				phx 								; save X
.c473	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c475	aa		tax				tax 								; put in X
.c476	bd 30 c0	lda $c030,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.c479	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.c47b	fa		plx				plx 								; restore X
.c47c	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.c47e	90 2b		bcc $c4ab			bcc 	_EVExit 					; exit if too low.
.c480	f0 29		beq $c4ab			beq 	_EVExit 					; exit if equals
.c482	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.c484	48		pha				pha
.c485	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c487	48		pha				pha
.c488	c8		iny				iny
.c489	da		phx				phx 								; save current position
.c48a	e8		inx				inx
.c48b	e8		inx				inx
.c48c	e8		inx				inx
.c48d	e8		inx				inx
.c48e	e8		inx				inx
.c48f	e8		inx				inx
.c490	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.c492	20 1d c4	jsr $c41d			jsr 	EvaluateExpressionXA 		; do the RHS.
.c495	fa		plx				plx 								; restore X
.c496	68		pla				pla 								; get the binary operator in A.
.c497	da		phx				phx 								; save X again
.c498	0a		asl a				asl 	a 							; double, lose the MSB.
.c499	aa		tax				tax									; put in X
.c49a	bd 00 c0	lda $c000,x			lda 	VectorTable,x 				; copy address into zGenPtr
.c49d	85 1e		sta $1e				sta 	zGenPtr
.c49f	bd 01 c0	lda $c001,x			lda 	VectorTable+1,x
.c4a2	85 1f		sta $1f				sta 	zGenPtr+1
.c4a4	fa		plx				plx 								; restore X
.c4a5	20 06 c5	jsr $c506			jsr 	EVGoZGenPtr 				; execute that function/operator
.c4a8	80 bd		bra $c467			bra 	_EVGotAtom 					; and loop back.
.c4aa					_EVExitDrop:
.c4aa	68		pla				pla
.c4ab					_EVExit:
.c4ab	60		rts				rts
.c4ac					_EVNotInteger:
.c4ac	c8		iny				iny
.c4ad	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.c4af	d0 19		bne $c4ca			bne 	_EVNotMinus
.c4b1	20 8a c5	jsr $c58a			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.c4b4	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; get type
.c4b7	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.c4b9	f0 05		beq $c4c0			beq 	_EVMinusFloat
.c4bb	20 ea c8	jsr $c8ea			jsr 	IntegerNegateAlways 		; negation
.c4be	80 a7		bra $c467			bra 	_EVGotAtom 					; and go back.
.c4c0					_EVMinusFloat:
.c4c0	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; invert the sign bit.
.c4c3	49 80		eor #$80			eor 	#$80
.c4c5	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c4c8	80 9d		bra $c467			bra 	_EVGotAtom
.c4ca					_EVNotMinus:
.c4ca	c9 b9		cmp #$b9			cmp 	#token_lparen 				; is it left parenthesis
.c4cc	d0 0c		bne $c4da			bne 	_EVNotParenthesis
.c4ce	20 1b c4	jsr $c41b			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.c4d1	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c4d3	c8		iny				iny
.c4d4	c9 ba		cmp #$ba			cmp 	#token_rparen 				; okay if right bracket.
.c4d6	f0 8f		beq $c467			beq 	_EVGotAtom
.c4d8	80 fe		bra $c4d8		_error: bra _error
.c4da					_EVNotParenthesis:
.c4da	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.c4dc	d0 0c		bne $c4ea			bne 	_EVNotNot
.c4de	20 8a c5	jsr $c58a			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.c4e1	20 de cd	jsr $cdde			jsr 	FPUToInteger 				; make it an integer - if possible.
.c4e4	20 67 c5	jsr $c567			jsr 	NotInteger 					; do the not calculation
.c4e7	4c 67 c4	jmp $c467			jmp 	_EVGotAtom
.c4ea					_EVNotNot:
.c4ea	c9 fe		cmp #$fe			cmp 	#$FE
.c4ec	d0 15		bne $c503			bne 	_EVNotString
.c4ee	20 ea c7	jsr $c7ea			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.c4f1	a5 20		lda $20				lda 	zTempStr 					; copy address of string into mantissa
.c4f3	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c4f6	a5 21		lda $21				lda 	zTempStr+1
.c4f8	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c4fb	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.c4fd	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c500	4c 67 c4	jmp $c467			jmp 	_EVGotAtom
.c503					_EVNotString:
.c503	80 fe		bra $c503			bra 	_EVNotString
.c505					_EVVariableHandler:
.c505	ea		nop				nop
.c506					EVGoZGenPtr:
.c506	6c 1e 00	jmp ($001e)			jmp 	 (zGenPtr)
.c509					EVShiftMantissaLeft6:
.c509	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.c50c	9d 04 03	sta $0304,x			sta 	XS_Exponent,x
.c50f	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c512	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c515	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c518	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c51b	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.c51e	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c521	a9 00		lda #$00			lda 	#0
.c523	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c526	20 29 c5	jsr $c529			jsr 	_EVSMLShift 					; call it here to do it twice
.c529					_EVSMLShift:
.c529	5e 04 03	lsr $0304,x			lsr 	XS_Exponent,x
.c52c	7e 03 03	ror $0303,x			ror 	XS_Mantissa+3,x
.c52f	7e 02 03	ror $0302,x			ror 	XS_Mantissa+2,x
.c532	7e 01 03	ror $0301,x			ror 	XS_Mantissa+1,x
.c535	7e 00 03	ror $0300,x			ror 	XS_Mantissa+0,x
.c538	60		rts				rts
.c539					EVGetDecimal:
.c539	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.c53b	8d 00 04	sta $0400			sta 	Num_Buffer
.c53e	da		phx				phx
.c53f	c8		iny				iny
.c540	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c542	c8		iny				iny
.c543	3a		dec a				dec 	a								; convert to a string length.
.c544	3a		dec a				dec 	a
.c545	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.c547					_EVGDCopy:
.c547	48		pha				pha 									; save count
.c548	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c54a	9d 00 04	sta $0400,x			sta 	Num_Buffer,x
.c54d	e8		inx				inx 									; forward ....
.c54e	c8		iny				iny
.c54f	68		pla				pla 									; get count
.c550	3a		dec a				dec 	a 								; until zero
.c551	d0 f4		bne $c547			bne 	_EVGDCopy
.c553	9d 00 04	sta $0400,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.c556	fa		plx				plx 									; restore X
.c557	a9 00		lda #$00			lda 	#Num_Buffer & $FF 				; set zGenPtr
.c559	85 1e		sta $1e				sta 	zGenPtr
.c55b	a9 04		lda #$04			lda 	#Num_Buffer >> 8
.c55d	85 1f		sta $1f				sta 	zGenPtr+1
.c55f	5a		phy				phy 									; save Y
.c560	a0 00		ldy #$00			ldy 	#0 								; start position
.c562	20 b7 cf	jsr $cfb7			jsr 	FPFromString 					; convert current
.c565	7a		ply				ply 									; restore Y
.c566	60		rts				rts
.c567					NotInteger:
.c567	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.c56a	49 ff		eor #$ff			eor 	#$FF
.c56c	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c56f	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c572	49 ff		eor #$ff			eor 	#$FF
.c574	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c577	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c57a	49 ff		eor #$ff			eor 	#$FF
.c57c	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c57f	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c582	49 ff		eor #$ff			eor 	#$FF
.c584	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c587	60		rts				rts
.c588					EvaluateGetAtom:
.c588	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.c58a					EvaluateGetAtomX:
.c58a	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.c58c	20 1d c4	jsr $c41d			jsr 	EvaluateExpressionXA
.c58f	bd 05 03	lda $0305,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.c592	29 0f		and #$0f			and 	#15
.c594	c9 02		cmp #$02			cmp 	#2
.c596	b0 01		bcs $c599			bcs 	EvaluateType
.c598	60		rts				rts
.c599					EvaluateType:
.c599	80 fe		bra $c599		_error: bra _error

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.c59b					BinaryOp_And:
.c59b	20 13 c6	jsr $c613			jsr 	BinaryMakeBothInteger
.c59e	bd 00 03	lda $0300,x			lda		XS_Mantissa+0,x
.c5a1	3d 06 03	and $0306,x			and 	XS2_Mantissa+0,x
.c5a4	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c5a7	bd 01 03	lda $0301,x			lda		XS_Mantissa+1,x
.c5aa	3d 07 03	and $0307,x			and 	XS2_Mantissa+1,x
.c5ad	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c5b0	bd 02 03	lda $0302,x			lda		XS_Mantissa+2,x
.c5b3	3d 08 03	and $0308,x			and 	XS2_Mantissa+2,x
.c5b6	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c5b9	bd 03 03	lda $0303,x			lda		XS_Mantissa+3,x
.c5bc	3d 09 03	and $0309,x			and 	XS2_Mantissa+3,x
.c5bf	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c5c2	60		rts				rts
.c5c3					BinaryOp_Or:
.c5c3	20 13 c6	jsr $c613			jsr 	BinaryMakeBothInteger
.c5c6	bd 00 03	lda $0300,x			lda		XS_Mantissa+0,x
.c5c9	1d 06 03	ora $0306,x			ora 	XS2_Mantissa+0,x
.c5cc	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c5cf	bd 01 03	lda $0301,x			lda		XS_Mantissa+1,x
.c5d2	1d 07 03	ora $0307,x			ora 	XS2_Mantissa+1,x
.c5d5	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c5d8	bd 02 03	lda $0302,x			lda		XS_Mantissa+2,x
.c5db	1d 08 03	ora $0308,x			ora 	XS2_Mantissa+2,x
.c5de	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c5e1	bd 03 03	lda $0303,x			lda		XS_Mantissa+3,x
.c5e4	1d 09 03	ora $0309,x			ora 	XS2_Mantissa+3,x
.c5e7	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c5ea	60		rts				rts
.c5eb					BinaryOp_Eor:
.c5eb					BinaryOp_Xor:
.c5eb	20 13 c6	jsr $c613			jsr 	BinaryMakeBothInteger
.c5ee	bd 00 03	lda $0300,x			lda		XS_Mantissa+0,x
.c5f1	5d 06 03	eor $0306,x			eor 	XS2_Mantissa+0,x
.c5f4	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c5f7	bd 01 03	lda $0301,x			lda		XS_Mantissa+1,x
.c5fa	5d 07 03	eor $0307,x			eor 	XS2_Mantissa+1,x
.c5fd	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c600	bd 02 03	lda $0302,x			lda		XS_Mantissa+2,x
.c603	5d 08 03	eor $0308,x			eor 	XS2_Mantissa+2,x
.c606	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c609	bd 03 03	lda $0303,x			lda		XS_Mantissa+3,x
.c60c	5d 09 03	eor $0309,x			eor 	XS2_Mantissa+3,x
.c60f	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c612	60		rts				rts
.c613					BinaryMakeBothInteger:
.c613	da		phx				phx 								; save X
.c614	e8		inx				inx
.c615	e8		inx				inx
.c616	e8		inx				inx
.c617	e8		inx				inx
.c618	e8		inx				inx
.c619	e8		inx				inx
.c61a	20 1e c6	jsr $c61e			jsr 	BinaryMakeInteger 			; convert to integer.
.c61d	fa		plx				plx 								; restore X and fall through.
.c61e					BinaryMakeInteger:
.c61e	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; get type byte.
.c621	29 0f		and #$0f			and 	#15 						; check type zero
.c623	f0 04		beq $c629			beq 	_BMIConvert 				; if float convert to integer.
.c625	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.c626	90 04		bcc $c62c			bcc 	_BMIError
.c628	60		rts				rts
.c629					_BMIConvert:
.c629	4c de cd	jmp $cdde			jmp 	FPUToInteger 				; convert to integer
.c62c					_BMIError:
.c62c	80 fe		bra $c62c		_error: bra _error

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.c62e					Binary_Equal:
.c62e	20 7a c6	jsr $c67a			jsr 	CompareValues
.c631	09 00		ora #$00			ora 	#0
.c633	f0 04		beq $c639			beq 	CCTrue
.c635	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.c637	80 02		bra $c63b			bra 	CCWrite
.c639	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.c63b	9d 00 03	sta $0300,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.c63e	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c641	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c644	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c647	a9 01		lda #$01			lda 	#1
.c649	9d 05 03	sta $0305,x			sta 	XS_Type,x 					; set type to integer whatever.
.c64c	60		rts				rts
.c64d					Binary_NotEqual:
.c64d	20 7a c6	jsr $c67a			jsr 	CompareValues
.c650	09 00		ora #$00			ora 	#0
.c652	d0 e1		bne $c635			bne 	CCFalse
.c654	80 e3		bra $c639			bra 	CCTrue
.c656					Binary_Less:
.c656	20 7a c6	jsr $c67a			jsr 	CompareValues
.c659	09 00		ora #$00			ora 	#0
.c65b	30 dc		bmi $c639			bmi 	CCTrue
.c65d	80 d6		bra $c635			bra 	CCFalse
.c65f					Binary_LessEqual:
.c65f	20 7a c6	jsr $c67a			jsr 	CompareValues
.c662	c9 01		cmp #$01			cmp 	#1
.c664	d0 d3		bne $c639			bne 	CCTrue
.c666	80 cd		bra $c635			bra 	CCFalse
.c668					Binary_GreaterEqual:
.c668	20 7a c6	jsr $c67a			jsr 	CompareValues
.c66b	09 00		ora #$00			ora 	#0
.c66d	10 ca		bpl $c639			bpl 	CCTrue
.c66f	80 c4		bra $c635			bra 	CCFalse
.c671					Binary_Greater:
.c671	20 7a c6	jsr $c67a			jsr 	CompareValues
.c674	c9 01		cmp #$01			cmp 	#1
.c676	d0 c1		bne $c639			bne 	CCTrue
.c678	80 bb		bra $c635			bra 	CCFalse
.c67a					CompareValues:
.c67a	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; and the types together
.c67d	3d 0b 03	and $030b,x			and 	XS2_Type,x
.c680	c9 02		cmp #$02			cmp 	#2
.c682	f0 13		beq $c697			beq 	_CVString
.c684	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; and 2 type bytes together.
.c687	3d 0b 03	and $030b,x			and 	XS2_Type,x
.c68a	4a		lsr a				lsr 	a 							; shift bit 0 into C
.c68b	90 03		bcc $c690			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.c68d	4c 98 c6	jmp $c698			jmp 	CompareInteger32 							; so execute code at \1
.c690					_BCFloat:
.c690	20 3e c7	jsr $c73e			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.c693	4c ed cc	jmp $cced			jmp 	FPCompare 							; and execute code at \2
.c696	60		rts				rts
.c697					_CVString:
.c697	ea		nop				nop
.c698					CompareInteger32:
.c698	ea		nop				nop

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.c699					BinaryOp_Add:
.c699	bd 05 03	lda $0305,x			lda 	XS_Type,x  					; and types together
.c69c	3d 0b 03	and $030b,x			and 	XS2_Type,x
.c69f	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.c6a1	d0 13		bne $c6b6			bne 	_BOAString
.c6a3	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; and 2 type bytes together.
.c6a6	3d 0b 03	and $030b,x			and 	XS2_Type,x
.c6a9	4a		lsr a				lsr 	a 							; shift bit 0 into C
.c6aa	90 03		bcc $c6af			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.c6ac	4c f2 c6	jmp $c6f2			jmp 	AddInteger32 							; so execute code at \1
.c6af					_BCFloat:
.c6af	20 3e c7	jsr $c73e			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.c6b2	4c 73 ca	jmp $ca73			jmp 	FPAdd 							; and execute code at \2
.c6b5	60		rts				rts
.c6b6					_BOAString:
.c6b6	4c 58 c7	jmp $c758			jmp 	ConcatenateString 			; concatenate two strings.
.c6b9					BinaryOp_Subtract:
.c6b9	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; and 2 type bytes together.
.c6bc	3d 0b 03	and $030b,x			and 	XS2_Type,x
.c6bf	4a		lsr a				lsr 	a 							; shift bit 0 into C
.c6c0	90 03		bcc $c6c5			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.c6c2	4c 18 c7	jmp $c718			jmp 	SubInteger32 							; so execute code at \1
.c6c5					_BCFloat:
.c6c5	20 3e c7	jsr $c73e			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.c6c8	4c 69 ca	jmp $ca69			jmp 	FPSubtract 							; and execute code at \2
.c6cb	60		rts				rts
.c6cc					BinaryOp_Multiply:
.c6cc	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; and 2 type bytes together.
.c6cf	3d 0b 03	and $030b,x			and 	XS2_Type,x
.c6d2	4a		lsr a				lsr 	a 							; shift bit 0 into C
.c6d3	90 03		bcc $c6d8			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.c6d5	4c 0f c8	jmp $c80f			jmp 	MulInteger32 							; so execute code at \1
.c6d8					_BCFloat:
.c6d8	20 3e c7	jsr $c73e			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.c6db	4c cd cb	jmp $cbcd			jmp 	FPMultiply 							; and execute code at \2
.c6de	60		rts				rts
.c6df					BinaryOp_Divide:
.c6df	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; and 2 type bytes together.
.c6e2	3d 0b 03	and $030b,x			and 	XS2_Type,x
.c6e5	4a		lsr a				lsr 	a 							; shift bit 0 into C
.c6e6	90 03		bcc $c6eb			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.c6e8	4c 66 c8	jmp $c866			jmp 	DivInteger32 							; so execute code at \1
.c6eb					_BCFloat:
.c6eb	20 3e c7	jsr $c73e			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.c6ee	4c 45 cb	jmp $cb45			jmp 	FPDivide 							; and execute code at \2
.c6f1	60		rts				rts
.c6f2					AddInteger32:
.c6f2	18		clc				clc
.c6f3	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.c6f6	7d 06 03	adc $0306,x			adc 	XS2_Mantissa+0,x
.c6f9	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c6fc	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c6ff	7d 07 03	adc $0307,x			adc 	XS2_Mantissa+1,x
.c702	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c705	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c708	7d 08 03	adc $0308,x			adc 	XS2_Mantissa+2,x
.c70b	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c70e	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c711	7d 09 03	adc $0309,x			adc 	XS2_Mantissa+3,x
.c714	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c717	60		rts				rts
.c718					SubInteger32:
.c718	38		sec				sec
.c719	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.c71c	fd 06 03	sbc $0306,x			sbc 	XS2_Mantissa+0,x
.c71f	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c722	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c725	fd 07 03	sbc $0307,x			sbc 	XS2_Mantissa+1,x
.c728	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c72b	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c72e	fd 08 03	sbc $0308,x			sbc 	XS2_Mantissa+2,x
.c731	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c734	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c737	fd 09 03	sbc $0309,x			sbc 	XS2_Mantissa+3,x
.c73a	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c73d	60		rts				rts
.c73e					BinaryMakeBothFloat:
.c73e	da		phx				phx 								; save X
.c73f	e8		inx				inx
.c740	e8		inx				inx
.c741	e8		inx				inx
.c742	e8		inx				inx
.c743	e8		inx				inx
.c744	e8		inx				inx
.c745	20 49 c7	jsr $c749			jsr 	BinaryMakeFloat 			; convert to float.
.c748	fa		plx				plx 								; restore X and fall through.
.c749					BinaryMakeFloat:
.c749	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; get type byte.
.c74c	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.c74d	b0 04		bcs $c753			bcs 	_BMFConvert
.c74f	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.c750	b0 04		bcs $c756			bcs 	_BMFError
.c752	60		rts				rts
.c753					_BMFConvert:
.c753	4c 7f cd	jmp $cd7f			jmp 	FPUToFloat 					; convert to float
.c756					_BMFError:
.c756	80 fe		bra $c756		_error: bra _error
.c758					ConcatenateString:
.c758	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.c75b	85 1a		sta $1a				sta		zLTemp1+0
.c75d	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c760	85 1b		sta $1b				sta 	zLTemp1+1
.c762	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x
.c765	85 1c		sta $1c				sta 	zLTemp1+2
.c767	bd 07 03	lda $0307,x			lda 	XS2_Mantissa+1,x
.c76a	85 1d		sta $1d				sta 	zLTemp1+3
.c76c	5a		phy				phy
.c76d	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.c76f	b1 1a		lda ($1a),y			lda 	(zlTemp1),y
.c771	71 1c		adc ($1c),y			adc 	(zlTemp1+2),y
.c773	7a		ply				ply
.c774	b0 37		bcs $c7ad			bcs 	_CSError					; check in range.
.c776	c9 fe		cmp #$fe			cmp 	#maxString+1
.c778	b0 33		bcs $c7ad			bcs 	_CSError
.c77a	20 af c7	jsr $c7af			jsr 	AllocateTempString 			; store the result
.c77d	20 98 c7	jsr $c798			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.c780	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.c783	85 1a		sta $1a				sta 	zLTemp1
.c785	bd 07 03	lda $0307,x			lda 	XS2_Mantissa+1,x
.c788	85 1b		sta $1b				sta 	zLTemp1+1
.c78a	20 98 c7	jsr $c798			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.c78d	a5 20		lda $20				lda 	zTempStr 					; point current to new string
.c78f	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c792	a5 21		lda $21				lda 	zTempStr+1
.c794	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c797	60		rts				rts
.c798					_CSCopyString:
.c798	da		phx				phx
.c799	5a		phy				phy
.c79a	a0 00		ldy #$00			ldy 	#0 							; get length
.c79c	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.c79e	f0 0a		beq $c7aa			beq 	_CSCSExit 					; if zero, exit
.c7a0	aa		tax				tax 								; put in X
.c7a1					_CSCSLoop:
.c7a1	c8		iny				iny 								; get next char
.c7a2	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.c7a4	20 da c7	jsr $c7da			jsr		WriteTempString 			; copy out
.c7a7	ca		dex				dex 								; do whole string
.c7a8	d0 f7		bne $c7a1			bne 	_CSCSLoop
.c7aa					_CSCSExit:
.c7aa	7a		ply				ply
.c7ab	fa		plx				plx
.c7ac	60		rts				rts
.c7ad					_CSError:
.c7ad	80 fe		bra $c7ad		_error: bra _error

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.c7af					AllocateTempString:
.c7af	48		pha				pha 								; save required count.
.c7b0	a5 21		lda $21				lda 	zTempStr+1 					; check if initialised yet ?
.c7b2	d0 0b		bne $c7bf			bne 	_ATSInitialised
.c7b4	ad 26 04	lda $0426			lda 	StringPtr 					; set temporary string ptr 1 page below available
.c7b7	85 20		sta $20				sta 	zTempStr					; space, this is for strings to be concreted.
.c7b9	ad 27 04	lda $0427			lda 	StringPtr+1
.c7bc	3a		dec a				dec 	a
.c7bd	85 21		sta $21				sta 	zTempStr+1
.c7bf					_ATSInitialised:
.c7bf	68		pla				pla 								; get required count back.
.c7c0	49 ff		eor #$ff			eor 	#$FF 						; negate 2's complement.
.c7c2	1a		inc a				inc 	a
.c7c3	18		clc				clc
.c7c4	65 20		adc $20				adc 	zTempStr 					; "add" to the temp string pointer
.c7c6	85 20		sta $20				sta 	zTempStr
.c7c8	a9 ff		lda #$ff			lda 	#$FF
.c7ca	65 21		adc $21				adc 	zTempStr+1
.c7cc	85 21		sta $21				sta 	zTempStr+1
.c7ce	a9 00		lda #$00			lda 	#0 							; clear temp string.
.c7d0	5a		phy				phy
.c7d1	a8		tay				tay
.c7d2	91 20		sta ($20),y			sta 	(zTempStr),y
.c7d4	7a		ply				ply
.c7d5	1a		inc a				inc 	a 							; reset the write index.
.c7d6	8d 27 04	sta $0427			sta 	TempStringWriteIndex
.c7d9	60		rts				rts
.c7da					WriteTempString:
.c7da	5a		phy				phy 								; save Y
.c7db	ac 27 04	ldy $0427			ldy 	TempStringWriteIndex	 	; write position.
.c7de	91 20		sta ($20),y			sta 	(zTempStr),y 				; write character out.
.c7e0	ee 27 04	inc $0427			inc 	TempStringWriteIndex 		; increment the write position.
.c7e3	98		tya				tya 								; unchanged Y is now length
.c7e4	a0 00		ldy #$00			ldy 	#0
.c7e6	91 20		sta ($20),y			sta 	(zTempStr),y
.c7e8	7a		ply				ply 								; restore Y and exit
.c7e9	60		rts				rts
.c7ea					CreateTempStringCopy:
.c7ea	da		phx				phx 								; save X
.c7eb	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c7ed	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.c7ee	20 af c7	jsr $c7af			jsr 	AllocateTempString 			; allocate memory for temporary string.
.c7f1	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c7f3	c8		iny				iny
.c7f4	3a		dec a				dec 	a 							; make the actual length in charactes
.c7f5	3a		dec a				dec 	a
.c7f6	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.c7f8	81 20		sta ($20,x)			sta 	(zTempStr,x)
.c7fa	85 1a		sta $1a				sta 	zLTemp1 					; that's used as a count.
.c7fc	09 00		ora #$00			ora 	#0 							; if zero already, exit
.c7fe	f0 0d		beq $c80d			beq 	_CTSCExit
.c800					_CTSCLoop:
.c800	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c802	c8		iny				iny
.c803	5a		phy				phy 								; save in Y
.c804	e8		inx				inx 								; bump index
.c805	9b		txy				txy 								; index into Y
.c806	91 20		sta ($20),y			sta 	(zTempStr),y 				; save at index
.c808	7a		ply				ply 								; restore Y
.c809	c6 1a		dec $1a				dec 	zLTemp1 					; do for each character
.c80b	d0 f3		bne $c800			bne 	_CTSCLoop
.c80d					_CTSCExit:
.c80d	fa		plx				plx 								; restore X
.c80e	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.c80f					MulInteger32:
.c80f	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.c812	9d 0c 03	sta $030c,x			sta 	XS3_Mantissa,x
.c815	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c818	9d 0d 03	sta $030d,x			sta 	XS3_Mantissa+1,x
.c81b	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c81e	9d 0e 03	sta $030e,x			sta 	XS3_Mantissa+2,x
.c821	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c824	9d 0f 03	sta $030f,x			sta 	XS3_Mantissa+3,x
.c827	a9 00		lda #$00			lda 	#0
.c829	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x 				; zero +0
.c82c	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c82f	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c832	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c835					_BFMMultiply:
.c835	bd 0c 03	lda $030c,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.c838	29 01		and #$01			and 	#1
.c83a	f0 03		beq $c83f			beq 	_BFMNoAdd
.c83c	20 f2 c6	jsr $c6f2			jsr 	AddInteger32
.c83f					_BFMNoAdd:
.c83f	1e 06 03	asl $0306,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.c842	3e 07 03	rol $0307,x			rol 	XS2_Mantissa+1,x
.c845	3e 08 03	rol $0308,x			rol 	XS2_Mantissa+2,x
.c848	3e 09 03	rol $0309,x			rol 	XS2_Mantissa+3,x
.c84b	5e 0f 03	lsr $030f,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.c84e	7e 0e 03	ror $030e,x			ror 	XS3_Mantissa+2,x
.c851	7e 0d 03	ror $030d,x			ror 	XS3_Mantissa+1,x
.c854	7e 0c 03	ror $030c,x			ror 	XS3_Mantissa,x
.c857	bd 0c 03	lda $030c,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.c85a	1d 0d 03	ora $030d,x			ora 	XS3_Mantissa+1,x
.c85d	1d 0e 03	ora $030e,x			ora 	XS3_Mantissa+2,x
.c860	1d 0f 03	ora $030f,x			ora 	XS3_Mantissa+3,x
.c863	d0 d0		bne $c835			bne 	_BFMMultiply
.c865	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.c866					DivInteger32:
.c866	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x 			; check for /0
.c869	1d 07 03	ora $0307,x			ora 	XS2_Mantissa+1,x
.c86c	1d 08 03	ora $0308,x			ora 	XS2_Mantissa+2,x
.c86f	1d 09 03	ora $0309,x			ora 	XS2_Mantissa+3,x
.c872	d0 02		bne $c876			bne 	_BFDOkay
.c874	80 fe		bra $c874		_error: bra _error
.c876					_BFDOkay:
.c876	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.c878	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.c87a	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.c87c	85 1c		sta $1c				sta 	zLTemp1+2
.c87e	85 1d		sta $1d				sta 	zLTemp1+3
.c880	8d 25 04	sta $0425			sta 	SignCount 					; Count of signs.
.c883	20 e4 c8	jsr $c8e4			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.c886	da		phx				phx
.c887	e8		inx				inx
.c888	e8		inx				inx
.c889	e8		inx				inx
.c88a	e8		inx				inx
.c88b	e8		inx				inx
.c88c	e8		inx				inx
.c88d	20 e4 c8	jsr $c8e4			jsr 	CheckIntegerNegate
.c890	fa		plx				plx
.c891	5a		phy				phy 								; Y is the counter
.c892	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.c894					_BFDLoop:
.c894	1e 00 03	asl $0300,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.c897	3e 01 03	rol $0301,x			rol 	XS_Mantissa+1,x
.c89a	3e 02 03	rol $0302,x			rol 	XS_Mantissa+2,x
.c89d	3e 03 03	rol $0303,x			rol 	XS_Mantissa+3,x
.c8a0	26 1a		rol $1a				rol 	zLTemp1
.c8a2	26 1b		rol $1b				rol 	zLTemp1+1
.c8a4	26 1c		rol $1c				rol 	zLTemp1+2
.c8a6	26 1d		rol $1d				rol 	zLTemp1+3
.c8a8	38		sec				sec
.c8a9	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.c8ab	fd 06 03	sbc $0306,x			sbc 	XS2_Mantissa+0,x
.c8ae	48		pha				pha
.c8af	a5 1b		lda $1b				lda 	zLTemp1+1
.c8b1	fd 07 03	sbc $0307,x			sbc 	XS2_Mantissa+1,x
.c8b4	48		pha				pha
.c8b5	a5 1c		lda $1c				lda 	zLTemp1+2
.c8b7	fd 08 03	sbc $0308,x			sbc 	XS2_Mantissa+2,x
.c8ba	48		pha				pha
.c8bb	a5 1d		lda $1d				lda 	zLTemp1+3
.c8bd	fd 09 03	sbc $0309,x			sbc 	XS2_Mantissa+3,x
.c8c0	90 15		bcc $c8d7			bcc 	_BFDNoAdd
.c8c2	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.c8c4	68		pla				pla
.c8c5	85 1c		sta $1c				sta 	zLTemp1+2
.c8c7	68		pla				pla
.c8c8	85 1b		sta $1b				sta 	zLTemp1+1
.c8ca	68		pla				pla
.c8cb	85 1a		sta $1a				sta 	zLTemp1+0
.c8cd	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.c8d0	09 01		ora #$01			ora 	#1
.c8d2	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c8d5	80 03		bra $c8da			bra 	_BFDNext
.c8d7					_BFDNoAdd:
.c8d7	68		pla				pla 								; Throw away the intermediate calculations
.c8d8	68		pla				pla
.c8d9	68		pla				pla
.c8da					_BFDNext:
.c8da	88		dey				dey
.c8db	d0 b7		bne $c894			bne 	_BFDLoop
.c8dd	7a		ply				ply 								; restore Y and exit
.c8de	4e 25 04	lsr $0425			lsr 	SignCount 					; if sign count odd,
.c8e1	b0 07		bcs $c8ea			bcs		IntegerNegateAlways 			; negate the result
.c8e3	60		rts				rts
.c8e4					CheckIntegerNegate:
.c8e4	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c8e7	30 01		bmi $c8ea			bmi 	IntegerNegateAlways
.c8e9	60		rts				rts
.c8ea					IntegerNegateAlways:
.c8ea	ee 25 04	inc $0425			inc 	SignCount
.c8ed	38		sec				sec
.c8ee	a9 00		lda #$00			lda 	#0
.c8f0	fd 00 03	sbc $0300,x			sbc 	XS_Mantissa+0,x
.c8f3	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c8f6	a9 00		lda #$00			lda 	#0
.c8f8	fd 01 03	sbc $0301,x			sbc 	XS_Mantissa+1,x
.c8fb	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c8fe	a9 00		lda #$00			lda 	#0
.c900	fd 02 03	sbc $0302,x			sbc 	XS_Mantissa+2,x
.c903	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c906	a9 00		lda #$00			lda 	#0
.c908	fd 03 03	sbc $0303,x			sbc 	XS_Mantissa+3,x
.c90b	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c90e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.c90f					INTToString:
.c90f	48		pha				pha
.c910	5a		phy				phy
.c911	bd 03 03	lda $0303,x			lda 		XS_Mantissa+3,x 		; check -ve
.c914	10 08		bpl $c91e			bpl 		_ITSNotMinus
.c916	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.c918	20 ab c9	jsr $c9ab			jsr 		ITSOutputCharacter
.c91b	20 ea c8	jsr $c8ea			jsr 		IntegerNegateAlways 	; negate the number.
.c91e					_ITSNotMinus:
.c91e	a9 00		lda #$00			lda 		#0 						; X is offset in table.
.c920	8d 21 04	sta $0421			sta 		NumSuppress 			; clear the suppression flag.
.c923	a0 00		ldy #$00			ldy 		#0 						; Y is index into dword subtraction table.
.c925					_ITSNextSubtractor:
.c925	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.c927	8d 22 04	sta $0422			sta 		NumConvCount
.c92a					_ITSSubtract:
.c92a	38		sec				sec
.c92b	bd 00 03	lda $0300,x			lda 		XS_Mantissa,x 			; subtract number and push on stack
.c92e	f9 87 c9	sbc $c987,y			sbc 		_ITSSubtractors+0,y
.c931	48		pha				pha
.c932	bd 01 03	lda $0301,x			lda 		XS_Mantissa+1,x
.c935	f9 88 c9	sbc $c988,y			sbc 		_ITSSubtractors+1,y
.c938	48		pha				pha
.c939	bd 02 03	lda $0302,x			lda 		XS_Mantissa+2,x
.c93c	f9 89 c9	sbc $c989,y			sbc 		_ITSSubtractors+2,y
.c93f	48		pha				pha
.c940	bd 03 03	lda $0303,x			lda 		XS_Mantissa+3,x
.c943	f9 8a c9	sbc $c98a,y			sbc 		_ITSSubtractors+3,y
.c946	90 14		bcc $c95c			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.c948	9d 03 03	sta $0303,x			sta 		XS_Mantissa+3,x 		; save subtract off stack
.c94b	68		pla				pla
.c94c	9d 02 03	sta $0302,x			sta 		XS_Mantissa+2,x
.c94f	68		pla				pla
.c950	9d 01 03	sta $0301,x			sta 		XS_Mantissa+1,x
.c953	68		pla				pla
.c954	9d 00 03	sta $0300,x			sta 		XS_Mantissa+0,x
.c957	ee 22 04	inc $0422			inc 		NumConvCount 			; bump count.
.c95a	80 ce		bra $c92a			bra 		_ITSSubtract 			; go round again.
.c95c					_ITSCantSubtract:
.c95c	68		pla				pla 								; throw away interim answers
.c95d	68		pla				pla
.c95e	68		pla				pla
.c95f	ad 22 04	lda $0422			lda 		NumConvCount 			; if not zero then no suppression check
.c962	c9 30		cmp #$30			cmp 		#"0"
.c964	d0 05		bne $c96b			bne 		_ITSOutputDigit
.c966	ad 21 04	lda $0421			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.c969	10 09		bpl $c974			bpl 		_ITSGoNextSubtractor
.c96b					_ITSOutputDigit:
.c96b	ce 21 04	dec $0421			dec 		NumSuppress 			; suppression check will be non-zero.
.c96e	ad 22 04	lda $0422			lda 		NumConvCount 			; count of subtractions
.c971	20 ab c9	jsr $c9ab			jsr 		ITSOutputCharacter 		; output it.
.c974					_ITSGoNextSubtractor:
.c974	c8		iny				iny 								; next dword
.c975	c8		iny				iny
.c976	c8		iny				iny
.c977	c8		iny				iny
.c978	c0 24		cpy #$24			cpy 		#_ITSSubtractorsEnd-_ITSSubtractors
.c97a	d0 a9		bne $c925			bne 		_ITSNextSubtractor 		; do all the subtractors.
.c97c	bd 00 03	lda $0300,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.c97f	09 30		ora #$30			ora 		#"0"
.c981	20 ab c9	jsr $c9ab			jsr 		ITSOutputCharacter
.c984	7a		ply				ply 								; and exit
.c985	68		pla				pla
.c986	60		rts				rts
.c987					_ITSSubtractors:
>c987	00 ca 9a 3b					.dword 		1000000000
>c98b	00 e1 f5 05					.dword 		100000000
>c98f	80 96 98 00					.dword 		10000000
>c993	40 42 0f 00					.dword 		1000000
>c997	a0 86 01 00					.dword 		100000
>c99b	10 27 00 00					.dword 		10000
>c99f	e8 03 00 00					.dword 		1000
>c9a3	64 00 00 00					.dword 		100
>c9a7	0a 00 00 00					.dword 		10
.c9ab					_ITSSubtractorsEnd:
.c9ab					ITSOutputCharacter:
.c9ab	48		pha				pha
.c9ac	da		phx				phx
.c9ad	ae 20 04	ldx $0420			ldx 	NumBufX 					; save digit
.c9b0	9d 00 04	sta $0400,x			sta 	Num_Buffer,x
.c9b3	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.c9b5	9d 01 04	sta $0401,x			sta 	Num_Buffer+1,x
.c9b8	ee 20 04	inc $0420			inc 	NumBufX						; bump pointer.
.c9bb	fa		plx				plx
.c9bc	68		pla				pla
.c9bd	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.c9be					IntFromString:
.c9be	a0 00		ldy #$00			ldy 	#0
.c9c0	8c 23 04	sty $0423			sty 	ExpTemp 					; this is the converted digit count.
.c9c3					IntFromStringY:
.c9c3	48		pha				pha
.c9c4	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.c9c6	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.c9c9	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c9cc	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c9cf	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c9d2	a9 01		lda #$01			lda 	#1
.c9d4	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c9d7					_IFSLoop:
.c9d7	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.c9d9	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.c9db	90 60		bcc $ca3d			bcc 	_IFSExit
.c9dd	c9 3a		cmp #$3a			cmp 	#"9"+1
.c9df	b0 5c		bcs $ca3d			bcs 	_IFSExit
.c9e1	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.c9e4	c9 0c		cmp #$0c			cmp 	#12
.c9e6	b0 5f		bcs $ca47			bcs 	_IFSOverflow
.c9e8	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.c9eb	48		pha				pha
.c9ec	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c9ef	48		pha				pha
.c9f0	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c9f3	48		pha				pha
.c9f4	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.c9f7	48		pha				pha
.c9f8	20 5c ca	jsr $ca5c			jsr 	IFSX1ShiftLeft 				; double
.c9fb	20 5c ca	jsr $ca5c			jsr 	IFSX1ShiftLeft 				; x 4
.c9fe	18		clc				clc 								; add saved value x 5
.c9ff	68		pla				pla
.ca00	7d 00 03	adc $0300,x			adc 	XS_Mantissa+0,x
.ca03	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.ca06	68		pla				pla
.ca07	7d 01 03	adc $0301,x			adc 	XS_Mantissa+1,x
.ca0a	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.ca0d	68		pla				pla
.ca0e	7d 02 03	adc $0302,x			adc 	XS_Mantissa+2,x
.ca11	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.ca14	68		pla				pla
.ca15	7d 03 03	adc $0303,x			adc 	XS_Mantissa+3,x
.ca18	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.ca1b	20 5c ca	jsr $ca5c			jsr 	IFSX1ShiftLeft 				; x 10
.ca1e	ee 23 04	inc $0423			inc 	ExpTemp 					; bump count of digits processed.
.ca21	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.ca23	29 0f		and #$0f			and 	#15
.ca25	c8		iny				iny
.ca26	7d 00 03	adc $0300,x			adc 	XS_Mantissa+0,x
.ca29	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.ca2c	90 a9		bcc $c9d7			bcc 	_IFSLoop
.ca2e	fe 01 03	inc $0301,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.ca31	d0 a4		bne $c9d7			bne 	_IFSLoop
.ca33	fe 02 03	inc $0302,x			inc 	XS_Mantissa+2,x
.ca36	d0 9f		bne $c9d7			bne 	_IFSLoop
.ca38	fe 03 03	inc $0303,x			inc 	XS_Mantissa+3,x
.ca3b	80 9a		bra $c9d7			bra 	_IFSLoop
.ca3d					_IFSExit:
.ca3d	98		tya				tya 								; get offset
.ca3e					_IFSOkay:
.ca3e	38		sec				sec
.ca3f	ad 23 04	lda $0423			lda 	ExpTemp
.ca42	f0 01		beq $ca45			beq 	_IFSSkipFail
.ca44	18		clc				clc
.ca45					_IFSSkipFail:
.ca45	68		pla				pla 								; and exit.
.ca46	60		rts				rts
.ca47					_IFSOverflow:
.ca47	20 09 c4	jsr $c409			jsr 	ERR_Handler
>ca4a	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>ca52	20 6f 76 65 72 66 6c 6f 77 00
.ca5c					IFSX1ShiftLeft:
.ca5c	1e 00 03	asl $0300,x			asl 	XS_Mantissa+0,x
.ca5f	3e 01 03	rol $0301,x			rol 	XS_Mantissa+1,x
.ca62	3e 02 03	rol $0302,x			rol 	XS_Mantissa+2,x
.ca65	3e 03 03	rol $0303,x			rol 	XS_Mantissa+3,x
.ca68	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.ca69					FPSubtract:
.ca69	48		pha				pha
.ca6a	bd 0b 03	lda $030b,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.ca6d	49 80		eor #$80			eor 	#$80
.ca6f	9d 0b 03	sta $030b,x			sta 	XS2_Type,x
.ca72	68		pla				pla 								; --- and fall through ---
.ca73					FPAdd:
.ca73	48		pha				pha
.ca74	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.ca77	d0 05		bne $ca7e			bne 	_FPA_NegativeLHS
.ca79	20 9b ca	jsr $ca9b			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.ca7c	68		pla				pla
.ca7d	60		rts				rts
.ca7e					_FPA_NegativeLHS:
.ca7e	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.ca81	49 80		eor #$80			eor 	#$80
.ca83	9d 05 03	sta $0305,x			sta 	XS_Type,x
.ca86	bd 0b 03	lda $030b,x			lda 	XS2_Type,x 					; flip the sign of B and add
.ca89	49 80		eor #$80			eor 	#$80
.ca8b	9d 0b 03	sta $030b,x			sta 	XS2_Type,x
.ca8e	20 9b ca	jsr $ca9b			jsr 	FPAdd_Worker 				; do the add calculation.
.ca91	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; flip sign of X1 back
.ca94	49 80		eor #$80			eor 	#$80
.ca96	9d 05 03	sta $0305,x			sta 	XS_Type,x
.ca99	68		pla				pla
.ca9a	60		rts				rts
.ca9b					FPAdd_Worker:
.ca9b	3c 0b 03	bit $030b,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.ca9e	70 08		bvs $caa8			bvs 	_FPAWExit 					; no change.
.caa0	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.caa3	50 07		bvc $caac			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.caa5	20 2e cd	jsr $cd2e			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.caa8					_FPAWExit:
.caa8	20 b6 cd	jsr $cdb6			jsr 	FPUNormalise 				; normalise the result.
.caab	60		rts				rts
.caac					_FPAWMakeSame:
.caac	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.caaf	38		sec				sec
.cab0	fd 0a 03	sbc $030a,x			sbc	 	XS2_Exponent,x 				; using subtraction
.cab3	f0 1b		beq $cad0			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.cab5	da		phx				phx 								; save X
.cab6	90 06		bcc $cabe			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.cab8	e8		inx				inx
.cab9	e8		inx				inx
.caba	e8		inx				inx
.cabb	e8		inx				inx
.cabc	e8		inx				inx
.cabd	e8		inx				inx
.cabe					_FPAWShiftA:
.cabe	fe 04 03	inc $0304,x			inc 	XS_Exponent,x 				; so shift exponent up.
.cac1	5e 03 03	lsr $0303,x			lsr 	3+XS_Mantissa,x
.cac4	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.cac7	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.caca	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.cacd	fa		plx				plx 								; restore original X
.cace	80 dc		bra $caac			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.cad0					_FPAW_DoArithmetic:
.cad0	3c 0b 03	bit $030b,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.cad3	30 39		bmi $cb0e			bmi 	_FPAW_BNegative
.cad5	18		clc				clc
.cad6	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.cad9	7d 06 03	adc $0306,x			adc 	XS2_Mantissa+0,x
.cadc	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.cadf	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.cae2	7d 07 03	adc $0307,x			adc 	XS2_Mantissa+1,x
.cae5	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.cae8	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.caeb	7d 08 03	adc $0308,x			adc 	XS2_Mantissa+2,x
.caee	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.caf1	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.caf4	7d 09 03	adc $0309,x			adc 	XS2_Mantissa+3,x
.caf7	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.cafa	90 ac		bcc $caa8			bcc 	_FPAWExit 					; no carry.
.cafc	fe 04 03	inc $0304,x			inc 	XS_Exponent,x 				; so shift exponent up.
.caff	38		sec				sec
.cb00	7e 03 03	ror $0303,x			ror 	3+XS_Mantissa,x
.cb03	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.cb06	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.cb09	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.cb0c	80 9a		bra $caa8			bra 	_FPAWExit
.cb0e					_FPAW_BNegative:
.cb0e	38		sec				sec
.cb0f	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.cb12	fd 06 03	sbc $0306,x			sbc 	XS2_Mantissa+0,x
.cb15	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.cb18	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.cb1b	fd 07 03	sbc $0307,x			sbc 	XS2_Mantissa+1,x
.cb1e	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.cb21	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.cb24	fd 08 03	sbc $0308,x			sbc 	XS2_Mantissa+2,x
.cb27	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cb2a	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.cb2d	fd 09 03	sbc $0309,x			sbc 	XS2_Mantissa+3,x
.cb30	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.cb33	b0 0b		bcs $cb40			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.cb35	20 5b cd	jsr $cd5b			jsr 	FPUNegateInteger			; negate the mantissa
.cb38	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; flip result sign
.cb3b	49 80		eor #$80			eor 	#$80
.cb3d	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cb40					_FPAWGoExit:
.cb40	4c a8 ca	jmp $caa8			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.cb43					FPD_IsDivZero:
.cb43	80 fe		bra $cb43		_error: bra _error
.cb45					FPDivide:
.cb45	48		pha				pha
.cb46	5a		phy				phy
.cb47	3c 0b 03	bit $030b,x			bit 	XS2_Type,x 					; check if division by zero
.cb4a	70 f7		bvs $cb43			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.cb4c	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.cb4f	f0 03		beq $cb54			beq 	_FPDCalculateExp
.cb51					_FPD_Exit:
.cb51	7a		ply				ply
.cb52	68		pla				pla
.cb53	60		rts				rts
.cb54					_FPDCalculateExp:
.cb54	bd 0a 03	lda $030a,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.cb57	49 ff		eor #$ff			eor 	#$FF
.cb59	1a		inc a				inc 	a
.cb5a	9d 0a 03	sta $030a,x			sta 	XS2_Exponent,x
.cb5d	20 51 cc	jsr $cc51			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.cb60	18		clc				clc 	 							; add 1 to the resulting exponent
.cb61	69 01		adc #$01			adc 	#1
.cb63	b0 65		bcs $cbca			bcs 	_FPD_Overflow 				; which can overflow.
.cb65	9d 04 03	sta $0304,x			sta 	XS_Exponent,x
.cb68	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.cb6a	85 1a		sta $1a				sta 	zLTemp1+0
.cb6c	85 1b		sta $1b				sta 	zLTemp1+1
.cb6e	85 1c		sta $1c				sta 	zLTemp1+2
.cb70	85 1d		sta $1d				sta 	zLTemp1+3
.cb72	a0 20		ldy #$20			ldy 	#32 						; times round.
.cb74					_FPD_Loop:
.cb74	38		sec				sec 								; calculate X1-X2 stacking result because we might
.cb75	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x 				; not save it.
.cb78	fd 06 03	sbc $0306,x			sbc 	XS2_Mantissa,x
.cb7b	48		pha				pha
.cb7c	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.cb7f	fd 07 03	sbc $0307,x			sbc 	XS2_Mantissa+1,x
.cb82	48		pha				pha
.cb83	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.cb86	fd 08 03	sbc $0308,x			sbc 	XS2_Mantissa+2,x
.cb89	48		pha				pha
.cb8a	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.cb8d	fd 09 03	sbc $0309,x			sbc 	XS2_Mantissa+3,x
.cb90	90 17		bcc $cba9			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.cb92	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x 			; save results out to A
.cb95	68		pla				pla
.cb96	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cb99	68		pla				pla
.cb9a	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.cb9d	68		pla				pla
.cb9e	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.cba1	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.cba3	09 80		ora #$80			ora 	#$80
.cba5	85 1d		sta $1d				sta 	zLTemp1+3
.cba7	80 03		bra $cbac			bra 	_FPD_Rotates
.cba9					_FPD_NoSubtract:
.cba9	68		pla				pla 								; throw away unwanted results
.cbaa	68		pla				pla
.cbab	68		pla				pla
.cbac					_FPD_Rotates:
.cbac	5e 09 03	lsr $0309,x			lsr 	3+XS2_Mantissa,x
.cbaf	7e 08 03	ror $0308,x			ror 	2+XS2_Mantissa,x
.cbb2	7e 07 03	ror $0307,x			ror 	1+XS2_Mantissa,x
.cbb5	7e 06 03	ror $0306,x			ror 	0+XS2_Mantissa,x
.cbb8	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.cbba	26 1b		rol $1b				rol 	zLTemp1+1
.cbbc	26 1c		rol $1c				rol 	zLTemp1+2
.cbbe	26 1d		rol $1d				rol 	zLTemp1+3
.cbc0	90 02		bcc $cbc4			bcc 	_FPD_NoCarry
.cbc2	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.cbc4					_FPD_NoCarry:
.cbc4	88		dey				dey 								; do 32 times
.cbc5	d0 ad		bne $cb74			bne 	_FPD_Loop
.cbc7	4c 2e cc	jmp $cc2e			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.cbca					_FPD_Overflow:
.cbca	4c 2b ce	jmp $ce2b			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.cbcd					FPMultiply:
.cbcd	48		pha				pha
.cbce	5a		phy				phy
.cbcf	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.cbd2	70 08		bvs $cbdc			bvs 	_FPM_Exit
.cbd4	3c 0b 03	bit $030b,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.cbd7	50 06		bvc $cbdf			bvc 	_FPM_CalcExponent
.cbd9	20 2e cd	jsr $cd2e			jsr 	FPUCopyX2ToX1
.cbdc					_FPM_Exit:
.cbdc	7a		ply				ply
.cbdd	68		pla				pla
.cbde	60		rts				rts
.cbdf					_FPM_CalcExponent:
.cbdf	18		clc				clc
.cbe0	20 51 cc	jsr $cc51			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.cbe3	9d 04 03	sta $0304,x			sta 	XS_Exponent,x 				; save the result.
.cbe6	a9 00		lda #$00			lda 	#0
.cbe8	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.cbea	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.cbec	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.cbee	85 1d		sta $1d				sta 	zLTemp1+3
.cbf0	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.cbf2					_FPM_Loop:
.cbf2	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x				; check LSB of long product
.cbf5	29 01		and #$01			and 	#1
.cbf7	18		clc				clc 								; clear carry for the long rotate.
.cbf8	f0 1d		beq $cc17			beq 	_FPM_NoAddition
.cbfa	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.cbfb	a5 1a		lda $1a				lda 	zLTemp1+0
.cbfd	7d 06 03	adc $0306,x			adc 	XS2_Mantissa+0,x
.cc00	85 1a		sta $1a				sta 	zLTemp1+0
.cc02	a5 1b		lda $1b				lda 	zLTemp1+1
.cc04	7d 07 03	adc $0307,x			adc 	XS2_Mantissa+1,x
.cc07	85 1b		sta $1b				sta 	zLTemp1+1
.cc09	a5 1c		lda $1c				lda 	zLTemp1+2
.cc0b	7d 08 03	adc $0308,x			adc 	XS2_Mantissa+2,x
.cc0e	85 1c		sta $1c				sta 	zLTemp1+2
.cc10	a5 1d		lda $1d				lda 	zLTemp1+3
.cc12	7d 09 03	adc $0309,x			adc 	XS2_Mantissa+3,x
.cc15	85 1d		sta $1d				sta 	zLTemp1+3
.cc17					_FPM_NoAddition:
.cc17	66 1d		ror $1d				ror 	3+zLTemp1
.cc19	66 1c		ror $1c				ror 	2+zLTemp1
.cc1b	66 1b		ror $1b				ror 	1+zLTemp1
.cc1d	66 1a		ror $1a				ror 	0+zLTemp1
.cc1f	7e 03 03	ror $0303,x			ror 	3+XS_Mantissa,x
.cc22	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.cc25	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.cc28	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.cc2b	88		dey				dey
.cc2c	d0 c4		bne $cbf2			bne 	_FPM_Loop 					; do this 32 times.
.cc2e					FPM_CopySignNormalize:
.cc2e	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.cc30	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.cc33	a5 1b		lda $1b				lda 	zLTemp1+1
.cc35	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.cc38	a5 1c		lda $1c				lda 	zLTemp1+2
.cc3a	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cc3d	a5 1d		lda $1d				lda 	zLTemp1+3
.cc3f	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.cc42	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; sign is xor of signs
.cc45	5d 0b 03	eor $030b,x			eor 	XS2_Type,x
.cc48	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cc4b	20 b6 cd	jsr $cdb6			jsr 	FPUNormalise 				; normalise and exit.
.cc4e	7a		ply				ply
.cc4f	68		pla				pla
.cc50	60		rts				rts
.cc51					FPCalculateExponent:
.cc51	18		clc				clc
.cc52	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.cc55	7d 0a 03	adc $030a,x			adc 	XS2_Exponent,x
.cc58	b0 08		bcs $cc62			bcs 	_FPCECarry 					; carry out ?
.cc5a	10 03		bpl $cc5f			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.cc5c	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.cc5e	60		rts				rts
.cc5f					_FPCEExpZero:
.cc5f	a9 00		lda #$00			lda 	#0
.cc61	60		rts				rts
.cc62					_FPCECarry:
.cc62	30 03		bmi $cc67			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.cc64	09 80		ora #$80			ora 	#$80 						; put in right range
.cc66	60		rts				rts
.cc67					_FPCEOverflow:
.cc67	4c 2b ce	jmp $ce2b			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.cc6a					FPFractionalPart:
.cc6a	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.cc6d	38		sec				sec 								; this flag tells us to keep the fractional part
.cc6e	30 0f		bmi $cc7f			bmi 	FPGetPart
.cc70	60		rts				rts
.cc71					FPIntegerPart:
.cc71	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.cc74	18		clc				clc 								; this flag says keep the integer part.
.cc75	30 08		bmi $cc7f			bmi 	FPGetPart 					; -ve exponents are 0..127
.cc77	48		pha				pha
.cc78	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.cc7a	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cc7d	68		pla				pla
.cc7e	60		rts				rts
.cc7f					FPGetPart:
.cc7f	48		pha				pha
.cc80	5a		phy				phy 								; save Y
.cc81	08		php				php 								; save action
.cc82	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.cc85	70 62		bvs $cce9			bvs 	_FPGP_Exit 					; then do nothing.
.cc87	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.cc89	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.cc8b	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.cc8d	85 1c		sta $1c				sta 	zLTemp1+2
.cc8f	85 1d		sta $1d				sta 	zLTemp1+3
.cc91	bd 04 03	lda $0304,x			lda 	XS_Exponent,x				; the number of shifts.
.cc94	38		sec				sec
.cc95	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.cc97	f0 12		beq $ccab			beq 	_FPGP_NoShift 				; ... if any
.cc99	c9 20		cmp #$20			cmp 	#32
.cc9b	90 02		bcc $cc9f			bcc 	_FPGP_NotMax
.cc9d	a9 20		lda #$20			lda 	#32 						; max of 32.
.cc9f					_FPGP_NotMax:
.cc9f	a8		tay				tay 								; Y is the mask shift count.
.cca0					_FPGP_ShiftMask:
.cca0	46 1d		lsr $1d				lsr 	3+zLTemp1
.cca2	66 1c		ror $1c				ror 	2+zLTemp1
.cca4	66 1b		ror $1b				ror 	1+zLTemp1
.cca6	66 1a		ror $1a				ror 	0+zLTemp1
.cca8	88		dey				dey
.cca9	d0 f5		bne $cca0			bne 	_FPGP_ShiftMask
.ccab					_FPGP_NoShift:
.ccab	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.ccad	8e 23 04	stx $0423			stx 	ExpTemp						; save X
.ccb0					_FPGP_MaskLoop:
.ccb0	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.ccb3	28		plp				plp 								; if CC we keep the top part, so we
.ccb4	08		php				php		 							; flip the mask.
.ccb5	b0 02		bcs $ccb9			bcs		_FPGP_NoFlip
.ccb7	49 ff		eor #$ff			eor 	#$FF
.ccb9					_FPGP_NoFlip:
.ccb9	3d 00 03	and $0300,x			and 	XS_Mantissa,x 				; and into the mantissa.
.ccbc	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.ccbf	e8		inx				inx
.ccc0	c8		iny				iny
.ccc1	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.ccc3	d0 eb		bne $ccb0			bne 	_FPGP_MaskLoop
.ccc5	ae 23 04	ldx $0423			ldx 	ExpTemp						; restore X
.ccc8	28		plp				plp
.ccc9	08		php				php 								; get action flag on the stack
.ccca	90 05		bcc $ccd1			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.cccc	a9 00		lda #$00			lda 	#0
.ccce	9d 05 03	sta $0305,x			sta 	XS_Type,x
.ccd1					_FPGP_NotFractional:
.ccd1	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x 						; check if \1 zero
.ccd4	1d 01 03	ora $0301,x			ora 	XS_Mantissa+1,x
.ccd7	1d 02 03	ora $0302,x			ora 	XS_Mantissa+2,x
.ccda	1d 03 03	ora $0303,x			ora 	XS_Mantissa+3,x
.ccdd	f0 05		beq $cce4			beq 	_FPGP_Zero 					; if zero, return zero
.ccdf	20 b6 cd	jsr $cdb6			jsr 	FPUNormalise
.cce2	80 05		bra $cce9			bra 	_FPGP_Exit 					; and exit
.cce4					_FPGP_Zero:
.cce4	a9 40		lda #$40			lda 	#$40 						; set zero flag
.cce6	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cce9					_FPGP_Exit:
.cce9	68		pla				pla 								; throw saved action flag.
.ccea	7a		ply				ply
.cceb	68		pla				pla
.ccec	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.cced					FPCompare:
.cced	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.ccf0	48		pha				pha
.ccf1	bd 0a 03	lda $030a,x			lda 	XS2_Exponent,x
.ccf4	48		pha				pha
.ccf5	20 69 ca	jsr $ca69			jsr 	FPSubtract 					; calculate X1-X2
.ccf8	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.ccfb	70 2c		bvs $cd29			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.ccfd	68		pla				pla
.ccfe	8d 23 04	sta $0423			sta 	ExpTemp						; save first exponent in temporary reg.
.cd01	68		pla				pla
.cd02	38		sec				sec
.cd03	ed 23 04	sbc $0423			sbc 	ExpTemp 					; calculate AX-BX
.cd06	70 15		bvs $cd1d			bvs 	_FPCNotEqual				; overflow, can't be equal.
.cd08	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.cd09	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.cd0b	b0 10		bcs $cd1d			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.cd0d	38		sec				sec
.cd0e	ad 23 04	lda $0423			lda 	ExpTemp 					; get one of the exponents back.
.cd11	e9 18		sbc #$18			sbc 	#24 						; allow for 2^24 error, relatively.
.cd13	b0 02		bcs $cd17			bcs 	_FPCNotRange 				; keep in range.
.cd15	a9 01		lda #$01			lda 	#1
.cd17					_FPCNotRange:
.cd17	38		sec				sec
.cd18	fd 04 03	sbc $0304,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.cd1b	b0 0e		bcs $cd2b			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.cd1d					_FPCNotEqual:
.cd1d	bd 05 03	lda $0305,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.cd20	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.cd22	f0 02		beq $cd26			beq 	_FPCNE2
.cd24	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.cd26	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.cd27	80 04		bra $cd2d			bra 	_FPCExit
.cd29					_FPCPullZero:
.cd29	68		pla				pla 								; throw saved exponents
.cd2a	68		pla				pla
.cd2b					_FPCZero:
.cd2b	a9 00		lda #$00			lda 	#0 							; and return zero
.cd2d					_FPCExit:
.cd2d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.cd2e					FPUCopyX2ToX1:
.cd2e	48		pha				pha
.cd2f	da		phx				phx
.cd30	5a		phy				phy
.cd31	a0 08		ldy #$08			ldy 	#8
.cd33	bd 06 03	lda $0306,x	_FPUC21:lda 	XS2_Mantissa,x
.cd36	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.cd39	e8		inx				inx
.cd3a	88		dey				dey
.cd3b	10 f6		bpl $cd33			bpl 	_FPUC21
.cd3d	7a		ply				ply
.cd3e	fa		plx				plx
.cd3f	68		pla				pla
.cd40	60		rts				rts
.cd41					FPUSetInteger:
.cd41	48		pha				pha
.cd42	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.cd45	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.cd47	10 02		bpl $cd4b			bpl 	_FPUSIExtend
.cd49	a9 ff		lda #$ff			lda 	#$FF
.cd4b					_FPUSIExtend:
.cd4b	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.cd4e	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cd51	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.cd54	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.cd56	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cd59	68		pla				pla
.cd5a	60		rts				rts
.cd5b					FPUNegateInteger:
.cd5b	48		pha				pha
.cd5c	38		sec				sec
.cd5d	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.cd5f	fd 00 03	sbc $0300,x			sbc 	XS_Mantissa+0,x
.cd62	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.cd65	a9 00		lda #$00			lda 	#0
.cd67	fd 01 03	sbc $0301,x			sbc 	XS_Mantissa+1,x
.cd6a	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.cd6d	a9 00		lda #$00			lda 	#0
.cd6f	fd 02 03	sbc $0302,x			sbc 	XS_Mantissa+2,x
.cd72	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cd75	a9 00		lda #$00			lda 	#0
.cd77	fd 03 03	sbc $0303,x			sbc 	XS_Mantissa+3,x
.cd7a	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.cd7d	68		pla				pla
.cd7e	60		rts				rts
.cd7f					FPUToFloat:
.cd7f	48		pha				pha
.cd80	bd 05 03	lda $0305,x			lda 	XS_Type,x					; exit if already float.
.cd83	29 0f		and #$0f			and 	#$0F
.cd85	f0 2d		beq $cdb4			beq 	_FPUFExit
.cd87	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.cd89	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cd8c	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.cd8e	9d 04 03	sta $0304,x			sta 	XS_Exponent,x 				; x mantissa.
.cd91	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.cd94	10 08		bpl $cd9e			bpl		_FPUFPositive
.cd96	20 5b cd	jsr $cd5b			jsr 	FPUNegateInteger 			; negate the mantissa
.cd99	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.cd9b	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cd9e					_FPUFPositive:
.cd9e	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.cda1	1d 01 03	ora $0301,x			ora 	XS_Mantissa+1,x
.cda4	1d 02 03	ora $0302,x			ora 	XS_Mantissa+2,x
.cda7	1d 03 03	ora $0303,x			ora 	XS_Mantissa+3,x
.cdaa	d0 05		bne $cdb1			bne 	_FPUFNonZero
.cdac	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.cdae	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cdb1					_FPUFNonZero:
.cdb1	20 b6 cd	jsr $cdb6			jsr 	FPUNormalise 				; normalise the floating point.
.cdb4					_FPUFExit:
.cdb4	68		pla				pla
.cdb5	60		rts				rts
.cdb6					FPUNormalise:
.cdb6	48		pha				pha
.cdb7	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.cdba	70 20		bvs $cddc			bvs 	_FPUNExit
.cdbc	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.cdbf	f0 16		beq $cdd7			beq 	_FPUNSetZero
.cdc1					_FPUNLoop:
.cdc1	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.cdc4	30 16		bmi $cddc			bmi 	_FPUNExit 					; if so, we are normalised.
.cdc6	1e 00 03	asl $0300,x			asl 	0+XS_Mantissa+0,x
.cdc9	3e 01 03	rol $0301,x			rol 	1+XS_Mantissa+0,x
.cdcc	3e 02 03	rol $0302,x			rol 	2+XS_Mantissa+0,x
.cdcf	3e 03 03	rol $0303,x			rol 	3+XS_Mantissa+0,x
.cdd2	de 04 03	dec $0304,x			dec 	XS_Exponent,x 				; decrement exponent
.cdd5	d0 ea		bne $cdc1			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.cdd7					_FPUNSetZero:
.cdd7	a9 40		lda #$40			lda 	#$40
.cdd9	9d 05 03	sta $0305,x			sta 	XS_Type,x 					; the result is now zero.
.cddc					_FPUNExit:
.cddc	68		pla				pla
.cddd	60		rts				rts
.cdde					FPUToInteger:
.cdde	48		pha				pha
.cddf	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; if already integer, exit
.cde2	29 01		and #$01			and 	#1
.cde4	d0 3e		bne $ce24			bne 	_FPUTOI_Exit
.cde6	3c 05 03	bit $0305,x			bit 	XS_Type,x					; if zero, return zero.
.cde9	70 2b		bvs $ce16			bvs 	_FPUTOI_Zero
.cdeb	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.cdee	10 26		bpl $ce16			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.cdf0	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.cdf2	b0 37		bcs $ce2b			bcs 	FP_Overflow
.cdf4					_FPUToIToInteger:
.cdf4	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.cdf7	c9 a0		cmp #$a0			cmp 	#128+32
.cdf9	f0 11		beq $ce0c			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.cdfb	fe 04 03	inc $0304,x			inc 	XS_Exponent,X 				; increment Exponent
.cdfe	5e 03 03	lsr $0303,x			lsr 	3+XS_Mantissa,x
.ce01	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.ce04	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.ce07	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.ce0a	80 e8		bra $cdf4			bra 	_FPUToIToInteger 			; keep going.
.ce0c					_FPUToICheckSign:
.ce0c	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; check sign
.ce0f	10 13		bpl $ce24			bpl 	_FPUToI_Exit 				; exit if unsigned.
.ce11	20 5b cd	jsr $cd5b			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.ce14	80 0e		bra $ce24			bra 	_FPUTOI_Exit
.ce16					_FPUTOI_Zero:
.ce16	a9 00		lda #$00			lda 	#0 							; return zero integer.
.ce18	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.ce1b	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.ce1e	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.ce21	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.ce24					_FPUToI_Exit:
.ce24	a9 01		lda #$01			lda 	#1 							; set type to integer
.ce26	9d 05 03	sta $0305,x			sta 	XS_Type,x
.ce29	68		pla				pla
.ce2a	60		rts				rts
.ce2b					FP_Overflow:
.ce2b	80 fe		bra $ce2b		_error: bra _error
.ce2d					FPUTimes10:
.ce2d	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.ce30	85 1a		sta $1a				sta 	ZLTemp1+0
.ce32	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.ce35	85 1b		sta $1b				sta 	ZLTemp1+1
.ce37	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.ce3a	85 1c		sta $1c				sta 	ZLTemp1+2
.ce3c	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.ce3f	85 1d		sta $1d				sta 	ZLTemp1+3
.ce41	20 85 ce	jsr $ce85			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.ce44	20 85 ce	jsr $ce85			jsr 	_FPUT_LSR_ZLTemp1
.ce47	18		clc				clc
.ce48	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.ce4b	65 1a		adc $1a				adc 	ZLTemp1+0
.ce4d	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.ce50	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.ce53	65 1b		adc $1b				adc 	ZLTemp1+1
.ce55	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.ce58	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.ce5b	65 1c		adc $1c				adc 	ZLTemp1+2
.ce5d	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.ce60	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.ce63	65 1d		adc $1d				adc 	ZLTemp1+3
.ce65	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.ce68	90 0f		bcc $ce79			bcc 	_FPUTimes10
.ce6a	7e 03 03	ror $0303,x			ror 	3+XS_Mantissa,x
.ce6d	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.ce70	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.ce73	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.ce76	fe 04 03	inc $0304,x			inc 	XS_Exponent,x				; fix exponent
.ce79					_FPUTimes10:
.ce79	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.ce7c	18		clc				clc
.ce7d	69 03		adc #$03			adc 	#3
.ce7f	9d 04 03	sta $0304,x			sta 	XS_Exponent,x
.ce82	b0 a7		bcs $ce2b			bcs 	FP_Overflow 				; error
.ce84	60		rts				rts
.ce85					_FPUT_LSR_ZLTemp1:
.ce85	46 1d		lsr $1d				lsr 	ZLTemp1+3
.ce87	66 1c		ror $1c				ror 	ZLTemp1+2
.ce89	66 1b		ror $1b				ror 	ZLTemp1+1
.ce8b	66 1a		ror $1a				ror 	ZLTemp1+0
.ce8d	60		rts				rts
.ce8e					FPUScale10A:
.ce8e	5a		phy				phy
.ce8f	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.ce91	f0 3d		beq $ced0			beq 	_FPUScaleExit
.ce93	da		phx				phx 								; save X
.ce94	e8		inx				inx
.ce95	e8		inx				inx
.ce96	e8		inx				inx
.ce97	e8		inx				inx
.ce98	e8		inx				inx
.ce99	e8		inx				inx
.ce9a	a8		tay				tay 								; save power scalar in Y.
.ce9b	a9 00		lda #$00			lda 	#0
.ce9d	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.cea0	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.cea3	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cea6	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cea9	a9 80		lda #$80			lda 	#$80
.ceab	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.ceae	a9 81		lda #$81			lda 	#$81
.ceb0	9d 04 03	sta $0304,x			sta 	XS_Exponent,x
.ceb3	5a		phy				phy 								; save 10^n on stack.
.ceb4	c0 00		cpy #$00			cpy 	#0
.ceb6	10 05		bpl $cebd			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.ceb8	98		tya				tya
.ceb9	49 ff		eor #$ff			eor 	#$FF
.cebb	1a		inc a				inc 	a
.cebc	a8		tay				tay
.cebd					_FPUSAbs:
.cebd	20 2d ce	jsr $ce2d			jsr 	FPUTimes10
.cec0	88		dey				dey
.cec1	d0 fa		bne $cebd			bne 	_FPUSAbs 					; tos is now 10^|AC|
.cec3	68		pla				pla 								; restore count in A
.cec4	fa		plx				plx 								; restore X pointing to number to scale.
.cec5	0a		asl a				asl 	a
.cec6	b0 05		bcs $cecd			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.cec8	20 cd cb	jsr $cbcd			jsr 	FPMultiply 					; if clear multiply.
.cecb	80 03		bra $ced0			bra		_FPUScaleExit
.cecd					_FPUSDivide:
.cecd	20 45 cb	jsr $cb45			jsr 	FPDivide
.ced0					_FPUScaleExit:
.ced0	7a		ply				ply
.ced1	60		rts				rts
.ced2					FPUCopyToNext:
.ced2	a0 06		ldy #$06			ldy 		#6
.ced4	da		phx				phx
.ced5					_FPUCopy1:
.ced5	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x
.ced8	9d 06 03	sta $0306,x			sta 	XS2_Mantissa,x
.cedb	e8		inx				inx
.cedc	88		dey				dey
.cedd	d0 f6		bne $ced5			bne 	_FPUCopy1
.cedf	fa		plx				plx
.cee0	60		rts				rts
.cee1					FPUCopyFromNext:
.cee1	a0 06		ldy #$06			ldy 		#6
.cee3	da		phx				phx
.cee4					_FPUCopy1:
.cee4	bd 06 03	lda $0306,x			lda 	XS2_Mantissa,x
.cee7	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.ceea	e8		inx				inx
.ceeb	88		dey				dey
.ceec	d0 f6		bne $cee4			bne 	_FPUCopy1
.ceee	fa		plx				plx
.ceef	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.cef0					FPToString:
.cef0	48		pha				pha
.cef1	5a		phy				phy
.cef2	3c 05 03	bit $0305,x			bit 		XS_Type,x 				; check zero flag
.cef5	50 0a		bvc $cf01			bvc 		_FPTSIsFloat 			; if zero,
.cef7					_FPTSZero:
.cef7	a9 30		lda #$30			lda 		#"0"
.cef9	20 ab c9	jsr $c9ab			jsr 		ITSOutputCharacter
.cefc					_FPTSExit:
.cefc	7a		ply				ply
.cefd	68		pla				pla
.cefe	60		rts				rts
.ceff	80 fb		bra $cefc			bra 		_FPTSExit
.cf01					_FPTSIsFloat:
.cf01	bd 05 03	lda $0305,x			lda 		XS_Type,x 				; is it signed ?
.cf04	10 0a		bpl $cf10			bpl 		_FPTSNotSigned
.cf06	a9 00		lda #$00			lda 		#0 						; clear sign flag
.cf08	9d 05 03	sta $0305,x			sta 		XS_Type,x
.cf0b	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.cf0d	20 ab c9	jsr $c9ab			jsr 		ITSOutputCharacter
.cf10					_FPTSNotSigned:
.cf10	bd 04 03	lda $0304,x			lda 		XS_Exponent,x
.cf13	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.cf15	b0 09		bcs $cf20			bcs 		_FPTSExponent
.cf17	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.cf19	90 05		bcc $cf20			bcc 		_FPTSExponent 			;
.cf1b					_FPTSStandard:
.cf1b	20 64 cf	jsr $cf64			jsr 		FPTOutputBody 			; output the body.
.cf1e	80 dc		bra $cefc			bra 		_FPTSExit
.cf20					_FPTSExponent:
.cf20	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.cf22	8d 24 04	sta $0424			sta 		ExpCount
.cf25					_FPTSExponentLoop:
.cf25	bd 04 03	lda $0304,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.cf28	10 0e		bpl $cf38			bpl 		_FPTSTimes
.cf2a	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.cf2c	90 14		bcc $cf42			bcc 		_FPTSScaledToExp
.cf2e	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.cf30	20 8e ce	jsr $ce8e			jsr 		FPUScale10A
.cf33	ee 24 04	inc $0424			inc 		ExpCount
.cf36	80 ed		bra $cf25			bra 		_FPTSExponentLoop
.cf38					_FPTSTimes:
.cf38	a9 01		lda #$01			lda 		#1
.cf3a	20 8e ce	jsr $ce8e			jsr 		FPUScale10A
.cf3d	ce 24 04	dec $0424			dec 		ExpCount
.cf40	80 e3		bra $cf25			bra 		_FPTSExponentLoop
.cf42					_FPTSScaledToExp:
.cf42	20 64 cf	jsr $cf64			jsr 		FPTOutputBody 			; output the body.
.cf45	a9 65		lda #$65			lda 		#"e"					; output E
.cf47	20 ab c9	jsr $c9ab			jsr 		ITSOutputCharacter
.cf4a	ad 24 04	lda $0424			lda 		ExpCount 				; get the exponent
.cf4d	9d 00 03	sta $0300,x			sta 		XS_Mantissa,x
.cf50	29 80		and #$80			and 		#$80 					; sign extend it
.cf52	f0 02		beq $cf56			beq 		_FPTSSExt
.cf54	a9 ff		lda #$ff			lda 		#$FF
.cf56					_FPTSSExt:
.cf56	9d 01 03	sta $0301,x			sta 		XS_Mantissa+1,x
.cf59	9d 02 03	sta $0302,x			sta 		XS_Mantissa+2,x
.cf5c	9d 03 03	sta $0303,x			sta 		XS_Mantissa+3,x
.cf5f	20 0f c9	jsr $c90f			jsr 		INTToString 			; output the exponent.
.cf62	80 98		bra $cefc			bra			_FPTSExit 				; and exit.
.cf64					FPTOutputBody:
.cf64	20 d2 ce	jsr $ced2			jsr 		FPUCopyToNext 			; copy to next slot.
.cf67	20 de cd	jsr $cdde			jsr 		FPUToInteger 			; convert to an integer
.cf6a	20 0f c9	jsr $c90f			jsr 		INTToString 			; output the main integer part.
.cf6d	20 e1 ce	jsr $cee1			jsr 		FPUCopyFromNext 		; get the fractional part back.
.cf70	20 6a cc	jsr $cc6a			jsr 		FPFractionalPart 		; get the decimal part.
.cf73	3c 05 03	bit $0305,x			bit 		XS_Type,x 				; any fractional part.
.cf76	70 3e		bvs $cfb6			bvs 		_FPTOExit 				; if not, exit now.
.cf78	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.cf7a	20 ab c9	jsr $c9ab			jsr 		ITSOutputCharacter
.cf7d					_FPOutLoop:
.cf7d	3c 05 03	bit $0305,x			bit 		XS_Type,x 				; finally reached zero.
.cf80	70 1e		bvs $cfa0			bvs 		_FPStripZeros 			; strip trailing zeros
.cf82	20 2d ce	jsr $ce2d			jsr 		FPUTimes10 				; multiply by 10
.cf85	20 d2 ce	jsr $ced2			jsr 		FPUCopyToNext			; copy to next slot.
.cf88	20 de cd	jsr $cdde			jsr 		FPUToInteger 			; convert to integer
.cf8b	bd 00 03	lda $0300,x			lda 		XS_Mantissa+0,x 		; print digit.
.cf8e	09 30		ora #$30			ora 		#"0"
.cf90	20 ab c9	jsr $c9ab			jsr 		ITSOutputCharacter
.cf93	20 e1 ce	jsr $cee1			jsr 		FPUCopyFromNext 		; get it back
.cf96	20 6a cc	jsr $cc6a			jsr 		FPFractionalPart 		; get fractional part
.cf99	ad 20 04	lda $0420			lda 		NumBufX 				; done 11 characters yet ?
.cf9c	c9 0b		cmp #$0b			cmp 	 	#11
.cf9e	90 dd		bcc $cf7d			bcc 		_FPOutLoop 				; if so, keep going till zero.
.cfa0					_FPStripZeros:
.cfa0	ac 20 04	ldy $0420			ldy 		NumBufX 				; strip trailing zeros.
.cfa3					_FPStripLoop:
.cfa3	88		dey				dey 								; back one, if at start then no strip
.cfa4	f0 10		beq $cfb6			beq 		_FPToExit
.cfa6	b9 00 04	lda $0400,y			lda 		Num_Buffer,y 			; keep going if "0"
.cfa9	c9 30		cmp #$30			cmp 		#"0"
.cfab	f0 f6		beq $cfa3			beq 		_FPStripLoop
.cfad	c8		iny				iny
.cfae	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.cfb0	99 00 04	sta $0400,y			sta 		Num_Buffer,y
.cfb3	8c 20 04	sty $0420			sty 		NumBufX 				; update position.
.cfb6					_FPTOExit:
.cfb6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.cfb7					FPFromString:
.cfb7	48		pha				pha 								; push A
.cfb8	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.cfba	c9 2e		cmp #$2e			cmp 	#"."
.cfbc	f0 03		beq $cfc1			beq	 	_FPFIsDecimal
.cfbe	4c 24 d0	jmp $d024			jmp 	_FPFNotDecimal
.cfc1					_FPFIsDecimal:
.cfc1	c8		iny				iny 								; consume the decimal.
.cfc2	20 7f cd	jsr $cd7f			jsr 	FPUToFloat 					; convert the integer to float.
.cfc5	da		phx				phx 								; save X.
.cfc6	5a		phy				phy 								; save decimal start position
.cfc7	e8		inx				inx
.cfc8	e8		inx				inx
.cfc9	e8		inx				inx
.cfca	e8		inx				inx
.cfcb	e8		inx				inx
.cfcc	e8		inx				inx
.cfcd	20 c3 c9	jsr $c9c3			jsr 	INTFromStringY 				; get the part after the DP.
.cfd0	20 7f cd	jsr $cd7f			jsr 	FPUToFloat 					; convert that to a float.
.cfd3	68		pla				pla 								; calculate - chars consumed.
.cfd4	8c 23 04	sty $0423			sty 	ExpTemp
.cfd7	38		sec				sec
.cfd8	ed 23 04	sbc $0423			sbc 	ExpTemp 					; this is the shift amount
.cfdb	20 8e ce	jsr $ce8e			jsr 	FPUScale10A 				; scale it by 10^AC
.cfde	fa		plx				plx 								; restore original X
.cfdf	20 73 ca	jsr $ca73			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.cfe2	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.cfe4	c9 45		cmp #$45			cmp 	#"E"
.cfe6	f0 04		beq $cfec			beq 	_FPFExponent
.cfe8	c9 65		cmp #$65			cmp 	#"e"
.cfea	d0 38		bne $d024			bne 	_FPFNotDecimal 				; no, then exit normally.
.cfec					_FPFExponent:
.cfec	c8		iny				iny 								; skip over E symbol.
.cfed	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.cfef	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.cff1	d0 01		bne $cff4			bne 	_FPFGotSign
.cff3	c8		iny				iny 								; if it was - skip over it.
.cff4					_FPFGotSign:
.cff4	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.cff5	da		phx				phx
.cff6	e8		inx				inx
.cff7	e8		inx				inx
.cff8	e8		inx				inx
.cff9	e8		inx				inx
.cffa	e8		inx				inx
.cffb	e8		inx				inx
.cffc	20 c3 c9	jsr $c9c3			jsr 	INTFromStringY 				; get the exponent
.cfff	fa		plx				plx 								; restore X.
.d000	bd 07 03	lda $0307,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.d003	1d 09 03	ora $0309,x			ora 	XS2_Mantissa+3,x
.d006	1d 08 03	ora $0308,x			ora 	XS2_Mantissa+2,x
.d009	d0 1b		bne $d026			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.d00b	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.d00e	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.d010	b0 14		bcs $d026			bcs 	_FPFXOverflow
.d012	68		pla				pla 								; get direction
.d013	d0 09		bne $d01e			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.d015	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.d018	49 ff		eor #$ff			eor 	#$FF
.d01a	1a		inc a				inc 	a
.d01b	9d 06 03	sta $0306,x			sta 	XS2_Mantissa+0,x
.d01e					_FPFXScale:
.d01e	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.d021	20 8e ce	jsr $ce8e			jsr 	FPUScale10A 				; scale by the exponent.
.d024					_FPFNotDecimal:
.d024	68		pla				pla
.d025	60		rts				rts
.d026					_FPFXOverflow:
.d026	20 09 c4	jsr $c409			jsr 	ERR_Handler
>d029	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>d031	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.d038					TIM_Error:
.d038	20 2a c2	jsr $c22a			jsr 	IFT_UpLine 					; go up one line.
.d03b	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.d03d	80 02		bra $d041			bra 	TIM_ShowPrompt
.d03f					TIM_NewCommand:
.d03f	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.d041					TIM_ShowPrompt:
.d041	20 36 c2	jsr $c236			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.d044	20 ee c2	jsr $c2ee			jsr 	IFT_ReadLine	 			; get character, go to next line
.d047	20 50 c2	jsr $c250			jsr 	IFT_NewLine					; go to next line.
.d04a	86 10		stx $10				stx 	zTemp1 						; save line read address
.d04c	84 11		sty $11				sty 	zTemp1+1
.d04e	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.d050	b1 10		lda ($10),y			lda 	(zTemp1),y
.d052	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.d054	d0 01		bne $d057			bne 	TIM_NotDot
.d056	c8		iny				iny
.d057					TIM_NotDot:
.d057	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.d059	c9 52		cmp #$52			cmp 	#"R"						; show registers
.d05b	f0 6b		beq $d0c8			beq 	TIM_ShowRegisters
.d05d	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.d05f	f0 12		beq $d073			beq 	TIM_ShowMemory
.d061	c9 47		cmp #$47			cmp 	#"G"						; execute
.d063	f0 49		beq $d0ae			beq 	TIM_Execute
.d065	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.d067	f0 07		beq $d070			beq 	TIM_GoLoadMemory
.d069	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.d06b	d0 cb		bne $d038			bne 	TIM_Error
.d06d	4c eb d1	jmp $d1eb			jmp 	TIM_UpdateRegisters
.d070					TIM_GoLoadMemory:
.d070	4c 1b d2	jmp $d21b			jmp 	TIM_LoadMemory
.d073					TIM_ShowMemory:
.d073	20 67 d1	jsr $d167			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.d076	b0 c0		bcs $d038			bcs 	TIM_Error
.d078	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.d07a	85 12		sta $12				sta 	zTemp2
.d07c	a5 15		lda $15				lda 	zTemp3+1
.d07e	85 13		sta $13				sta 	zTemp2+1
.d080	20 67 d1	jsr $d167			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.d083	90 08		bcc $d08d			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.d085	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.d087	85 14		sta $14				sta 	zTemp3
.d089	a5 13		lda $13				lda 	zTemp2+1
.d08b	85 15		sta $15				sta 	zTemp3+1
.d08d					_TIMSM_Start:
.d08d	20 3f d1	jsr $d13f			jsr 	TIM_WriteLine 				; write one line of hex out
.d090	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.d092	18		clc				clc
.d093	69 10		adc #$10			adc 	#16
.d095	85 12		sta $12				sta 	zTemp2
.d097	90 02		bcc $d09b			bcc 	_TIMSM_NoCarry
.d099	e6 13		inc $13				inc 	zTemp2+1
.d09b					_TIMSM_NoCarry:
.d09b	20 d5 c3	jsr $c3d5			jsr 	IF_CheckBreak 				; check CTL+C
.d09e	d0 0b		bne $d0ab			bne 	_TIMSM_Ends 				; if pressed break out.
.d0a0	38		sec				sec 								; check past the end address in zTemp3
.d0a1	a5 14		lda $14				lda 	zTemp3
.d0a3	e5 12		sbc $12				sbc 	zTemp2
.d0a5	a5 15		lda $15				lda 	zTemp3+1
.d0a7	e5 13		sbc $13				sbc 	zTemp2+1
.d0a9	10 e2		bpl $d08d			bpl 	_TIMSM_Start
.d0ab					_TIMSM_Ends:
.d0ab	4c 3f d0	jmp $d03f			jmp 	TIM_NewCommand
.d0ae					TIM_Execute:
.d0ae	20 67 d1	jsr $d167			jsr 	TIM_GetHex 					; get the execute address
.d0b1	b0 85		bcs $d038			bcs 	TIM_Error 					; not legitimate
.d0b3	ae 31 04	ldx $0431			ldx 	TIM_SP 						; set up SP
.d0b6	9a		txs				txs
.d0b7	ad 2c 04	lda $042c			lda 	TIM_SR 						; Status for PLP
.d0ba	48		pha				pha
.d0bb	ad 2d 04	lda $042d			lda 	TIM_A 						; restore AXYZ
.d0be	ae 2e 04	ldx $042e			ldx 	TIM_X
.d0c1	ac 2f 04	ldy $042f			ldy 	TIM_Y
.d0c4	28		plp				plp 								; and PS Byte.
.d0c5	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.d0c8					TIM_Start:
.d0c8					TIM_ShowRegisters:
.d0c8	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.d0cb	8d 2b 04	sta $042b			sta 	TIM_IRQ+1
.d0ce	ad ff ff	lda $ffff			lda 	$FFFF
.d0d1	8d 2a 04	sta $042a			sta 	TIM_IRQ
.d0d4	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.d0d6					_TIMSR_Text:
.d0d6	bd 06 d1	lda $d106,x			lda 	_TIMSR_Label,x
.d0d9	20 36 c2	jsr $c236			jsr 	IFT_PrintCharacter
.d0dc	e8		inx				inx
.d0dd	e0 20		cpx #$20			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.d0df	d0 f5		bne $d0d6			bne 	_TIMSR_Text
.d0e1	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.d0e3					_TIMSR_Skip:
.d0e3	e8		inx				inx
.d0e4					_TIMSR_LoopSpace:
.d0e4	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.d0e6	b0 04		bcs $d0ec			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.d0e8	8a		txa				txa
.d0e9	4a		lsr a				lsr 	a
.d0ea	b0 05		bcs $d0f1			bcs 	_TIMSR_NoSpace
.d0ec					_TIMSR_Space:
.d0ec	a9 20		lda #$20			lda 	#" "
.d0ee	20 36 c2	jsr $c236			jsr 	IFT_PrintCharacter
.d0f1					_TIMSR_NoSpace:
.d0f1	bd 28 04	lda $0428,x			lda 	TIM_PC,x 					; output hex value.
.d0f4	20 26 d1	jsr $d126			jsr 	TIM_WriteHex
.d0f7	e8		inx				inx
.d0f8	e0 08		cpx #$08			cpx 	#TIM_Z-TIM_PC
.d0fa	f0 e7		beq $d0e3			beq 	_TIMSR_Skip
.d0fc	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.d0fe	d0 e4		bne $d0e4			bne 	_TimSR_LoopSpace
.d100	20 50 c2	jsr $c250			jsr 	IFT_NewLine 				; new line
.d103	4c 3f d0	jmp $d03f			jmp	 	TIM_NewCommand 				; new command.
.d106					_TIMSR_Label:
>d106	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>d10e	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>d11e	52
>d11f	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.d126					_TIMSR_LabelEnd:
.d126					TIM_WriteHex:
.d126	48		pha				pha 								; save A
.d127	4a		lsr a				lsr 	a 							; shift MSB->LSB
.d128	4a		lsr a				lsr 	a
.d129	4a		lsr a				lsr 	a
.d12a	4a		lsr a				lsr 	a
.d12b	20 2f d1	jsr $d12f			jsr 	_TIMWH_Nibble 				; print MSB
.d12e	68		pla				pla 								; restore and print LSB
.d12f					_TIMWH_Nibble:
.d12f	48		pha				pha
.d130	29 0f		and #$0f			and 	#15 						; mask out
.d132	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.d134	90 02		bcc $d138			bcc 	_TIMWHNoLetter
.d136	69 06		adc #$06			adc 	#6
.d138					_TIMWHNoLetter:
.d138	69 30		adc #$30			adc 	#48
.d13a	20 36 c2	jsr $c236			jsr 	IFT_PrintCharacter 			; print it out.
.d13d	68		pla				pla
.d13e	60		rts				rts
.d13f					TIM_WriteLine:
.d13f	a9 2e		lda #$2e			lda 	#"." 						; prompt
.d141	20 36 c2	jsr $c236			jsr 	IFT_PrintCharacter
.d144	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.d146	20 36 c2	jsr $c236			jsr 	IFT_PrintCharacter
.d149	a5 13		lda $13				lda 	zTemp2+1 					; write address
.d14b	20 26 d1	jsr $d126			jsr 	TIM_WriteHex
.d14e	a5 12		lda $12				lda 	zTemp2
.d150	20 26 d1	jsr $d126			jsr 	TIM_WriteHex
.d153	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.d155					_TIMWL_Loop:
.d155	a9 20		lda #$20			lda 	#" "
.d157	20 36 c2	jsr $c236			jsr 	IFT_PrintCharacter
.d15a	b1 12		lda ($12),y			lda 	(zTemp2),y
.d15c	20 26 d1	jsr $d126			jsr 	TIM_WriteHex
.d15f	c8		iny				iny
.d160	c0 10		cpy #$10			cpy 	#16
.d162	d0 f1		bne $d155			bne 	_TIMWL_Loop
.d164	4c 50 c2	jmp $c250			jmp 	IFT_NewLine 				; new line and exit
.d167					TIM_GetHex:
.d167	c8		iny				iny
.d168	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.d16a	c9 20		cmp #$20			cmp 	#32
.d16c	f0 f9		beq $d167			beq 	TIM_GetHex
.d16e	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.d170	f0 f5		beq $d167			beq 	TIM_GetHex
.d172	20 9b d1	jsr $d19b			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.d175	b0 23		bcs $d19a			bcs 	_TIMGH_Exit					; if first bad then exit now.
.d177	a9 00		lda #$00			lda 	#0 							; zero result
.d179	85 14		sta $14				sta 	zTemp3
.d17b	85 15		sta $15				sta 	zTemp3+1
.d17d					_TIM_GHLoop:
.d17d	20 9b d1	jsr $d19b			jsr 	TIM_GetHexCharacter 		; get next character
.d180	b0 17		bcs $d199			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.d182	c8		iny				iny 								; skip over it.
.d183	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.d185	26 15		rol $15				rol 	zTemp3+1
.d187	06 14		asl $14				asl 	zTemp3 						; now x 2
.d189	26 15		rol $15				rol 	zTemp3+1
.d18b	06 14		asl $14				asl 	zTemp3						; now x 4
.d18d	26 15		rol $15				rol 	zTemp3+1
.d18f	06 14		asl $14				asl 	zTemp3 						; now x 8
.d191	26 15		rol $15				rol 	zTemp3+1
.d193	05 14		ora $14				ora 	zTemp3 						; OR result in
.d195	85 14		sta $14				sta 	zTemp3
.d197	80 e4		bra $d17d			bra 	_TIM_GHLoop 				; loop round again.
.d199					_TIMGH_Okay:
.d199	18		clc				clc
.d19a					_TIMGH_Exit:
.d19a	60		rts				rts
.d19b					TIM_GetHexCharacter:
.d19b	b1 10		lda ($10),y			lda 	(zTemp1),y
.d19d	38		sec				sec
.d19e	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.d1a0	90 0e		bcc $d1b0			bcc 	_TIM_GHCFail
.d1a2	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.d1a4	90 0b		bcc $d1b1			bcc 	_TIM_GHCExit
.d1a6	c9 11		cmp #$11			cmp 	#65-48						; < A
.d1a8	90 06		bcc $d1b0			bcc		_TIM_GHCFail
.d1aa	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.d1ac	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.d1ae	90 01		bcc $d1b1			bcc		_TIM_GHCExit
.d1b0					_TIM_GHCFail:
.d1b0	38		sec				sec
.d1b1					_TIM_GHCExit:
.d1b1	60		rts				rts
.d1b2					TIM_BreakVector:
.d1b2	da		phx				phx									; save X/A on stack
.d1b3	48		pha				pha
.d1b4	ba		tsx				tsx 								; X points to S
.d1b5	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.d1b8	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.d1ba	d0 03		bne $d1bf			bne 	_TIMBreak					; if set, it's BRK
.d1bc	68		pla				pla 								; abandon routine.
.d1bd	fa		plx				plx
.d1be	40		rti				rti
.d1bf					_TIMBreak:
.d1bf	68		pla				pla 								; save A X Y and maybe Z
.d1c0	8d 2d 04	sta $042d			sta 	TIM_A
.d1c3	fa		plx				plx
.d1c4	8e 2e 04	stx $042e			stx 	TIM_X
.d1c7	8c 2f 04	sty $042f			sty 	TIM_Y
.d1ca	68		pla				pla 								; get Status Register
.d1cb	8d 2c 04	sta $042c			sta 	TIM_SR
.d1ce	68		pla				pla
.d1cf	8d 29 04	sta $0429			sta 	TIM_PC+1 					; save calling address
.d1d2	68		pla				pla
.d1d3	8d 28 04	sta $0428			sta 	TIM_PC 						; high byte
.d1d6	ad 29 04	lda $0429			lda 	TIM_PC+1 					; dec PC to point right.
.d1d9	d0 03		bne $d1de			bne 	_TIMDecrement 				; brk bumps it.
.d1db	ce 28 04	dec $0428			dec 	TIM_PC
.d1de					_TIMDecrement:
.d1de	ce 29 04	dec $0429			dec 	TIM_PC+1
.d1e1	ba		tsx				tsx 								; and copy SP
.d1e2	8e 31 04	stx $0431			stx 	TIM_SP
.d1e5	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.d1e7	9a		txs				txs
.d1e8	4c c8 d0	jmp $d0c8			jmp 	TIM_Start 					; and start up TIM monitor.
.d1eb					TIM_UpdateRegisters:
.d1eb	20 67 d1	jsr $d167			jsr 	TIM_GetHex 					; PC
.d1ee	b0 28		bcs $d218			bcs 	_TIMURFail
.d1f0	a5 14		lda $14				lda 	zTemp3
.d1f2	8d 29 04	sta $0429			sta 	Tim_PC+1
.d1f5	a5 15		lda $15				lda 	zTemp3+1
.d1f7	8d 28 04	sta $0428			sta 	Tim_PC
.d1fa	20 67 d1	jsr $d167			jsr 	TIM_GetHex 					; ignore IRQ
.d1fd	b0 19		bcs $d218			bcs 	_TIMURFail
.d1ff	a2 00		ldx #$00			ldx 	#0
.d201					_TIM_URLoop:
.d201	e0 04		cpx #$04			cpx 	#Tim_Z-Tim_SR
.d203	d0 01		bne $d206			bne 	_TIM_1
.d205	e8		inx				inx
.d206					_TIM_1:
.d206	20 67 d1	jsr $d167			jsr 	TIM_GetHex 					; registers
.d209	b0 0d		bcs $d218			bcs 	_TIMURFail
.d20b	a5 14		lda $14				lda 	zTemp3
.d20d	9d 2c 04	sta $042c,x			sta 	Tim_SR,x
.d210	e8		inx				inx
.d211	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.d213	d0 ec		bne $d201			bne 	_TIM_URLoop
.d215	4c 3f d0	jmp $d03f			jmp 	TIM_NewCommand
.d218					_TIMURFail:
.d218	4c 38 d0	jmp $d038			jmp 	TIM_Error
.d21b					TIM_LoadMemory:
.d21b	20 67 d1	jsr $d167			jsr 	TIM_GetHex 					; target address => zTemp2
.d21e	a5 14		lda $14				lda 	zTemp3
.d220	85 12		sta $12				sta 	zTemp2
.d222	a5 15		lda $15				lda 	zTemp3+1
.d224	85 13		sta $13				sta 	zTemp2+1
.d226					_TIM_LMLoop:
.d226	20 67 d1	jsr $d167			jsr 	TIM_GetHex 					; next byte ?
.d229	b0 0e		bcs $d239			bcs 	_TIMLMDone 					; no more
.d22b	a2 00		ldx #$00			ldx 	#0							; write out.
.d22d	a5 14		lda $14				lda 	zTemp3
.d22f	81 12		sta ($12,x)			sta 	(zTemp2,x)
.d231	e6 12		inc $12				inc 	zTemp2 						; bump address
.d233	d0 f1		bne $d226			bne 	_TIM_LMLoop
.d235	e6 13		inc $13				inc 	zTemp2+1
.d237	80 ed		bra $d226			bra 	_TIM_LMLoop
.d239					_TIMLMDone:
.d239	4c 3f d0	jmp $d03f			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Return to file: basic.asm

>d23c	02						.byte 	2
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	e5 c1						.word 	StartROM
>fffe	b2 d1					.word TIM_BreakVector

;******  End of listing
