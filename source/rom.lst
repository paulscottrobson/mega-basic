
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Wed Aug 28 15:43:05 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="4510"					cpu = "4510"
="mega65"				hardware = "mega65"
=1					exitonend = 1
=1					autorun = 1
=2					loadtest = 2
=1					hasfloat = 1
=1					hasinteger = 1
=253					maxstring = 253

;******  Processing file: modules/float/fpmacros.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/mega65/src_mega65.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0020					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0022					zVarDataPtr: .word ? 						; position of variable data.
>0024					zVarType: 	.byte ? 						; type of data (token)
>0025					zNullString:.byte ? 						; represents a NULL string.
>0080					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>0084					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>0085					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=134					XS2_Mantissa = XS_Mantissa+XS_Size
=138					XS2_Exponent = XS_Exponent+XS_Size
=139					XS2_Type = XS_Type+XS_Size
=140					XS3_Mantissa = XS_Mantissa+XS_Size*2
=144					XS3_Exponent = XS_Exponent+XS_Size*2
=145					XS3_Type = XS_Type+XS_Size*2
>0300					StringPtr:	.word ? 						; Top of free memory (for string allocation)
>0302					VarMemPtr: 	.word ?							; Bottom of free memory (for variables)
>0304					endOfProgram: .word ? 						; End of Program Memory.
>0306					UserVector .fill 4 							; USR(x) calls this.
>030a					LocalVector .fill 4 						; Indirect calls call this.
>030e					NumBufX 	.byte 	?						; buffer index position
>030f					Num_Buffer	.fill 	32 						; buffer for numeric conversions
=6					HashTableCount = 6 							; there are 6 hash tables, in token order.
=8					HashTableSize = 8 							; each hash table as 8 links.
.032f					HashTableBase:
>032f								.fill	HashTableCount * HashTableSize * 2
.038f					HashTableEnd:
=$30f					Var_Buffer 	= Num_Buffer 					; buffer for variable name (same space)
>038f					Var_Type    .byte ? 						; type of variable (as a type token)
>0390					Var_Hash 	.byte ? 						; hash of identifier name.
>0391					Var_Length 	.byte ? 						; length of variable name
>0392					Var_HashAddress .byte ?						; low byte of hash table entry.
>0393					Var_DataSize .byte ?						; size of one element.
>0394					NumSuppress	.byte 	?						; leading zero suppression flag
>0395					NumConvCount .byte 	? 						; count for conversions.
>0396					ExpTemp:	.byte ?							; Working temp for exponents.
>0397					ExpCount:	.byte ? 						; Count of decimal exponents.
>0398					SignCount:	.byte ?							; Integer Divide Sign Counts.
>0399					TempStringWriteIndex: .byte ? 				; Write offset.
>039a					ValSign: 	.byte ? 						; sign flag for val()
>039b					SliceStart:	.byte ? 						; string slice parts
>039c					SliceCount:	.byte ?
>039d					RandomSeed:	.dword ? 						; Random seed.
=3					ArrayMaxDim = 3 							; number of dimensions.
>03a1					ArrayDef:	.fill (ArrayMaxDim+1)*2 		; dimensions for auto-creation
>03a9					UsrArrayDef:.fill (ArrayMaxDim+1)*2 		; dimensions created in DIM
>03b1					UsrArrayIdx:.byte ? 						; index into UsrArrayDef
>03b2					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>03b4					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>03b6					Tim_SR:		.byte ? 						; Processor Status
>03b7					Tim_A:		.byte ? 						; Processor Registers
>03b8					Tim_X:		.byte ?
>03b9					Tim_Y:		.byte ?
>03ba					Tim_Z:		.byte ?
>03bb					Tim_SP:		.word ?							; Stack Pointer (just in cases)
>03bd					IFT_XCursor:.byte ?							; current logical position on screen
>03be					IFT_YCursor:.byte ?
>03bf					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0423					IFT_LineBuffer: .fill 100 					; line input buffer.

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/mega65.asm

=$7f00					HighMemory = $7F00
=$2000					VariableMemory = $2000
.8000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testassign.src

>8000	0b 02 00 c7 0c bd 41 bf			.byte	$0b,$02,$00,$c7,$0c,$bd,$41,$bf
>8008	41 be 00 0b 03 00 c7 01			.byte	$41,$be,$00,$0b,$03,$00,$c7,$01
>8010	b8 41 bf 42 be 00 0d 04			.byte	$b8,$41,$bf,$42,$be,$00,$0d,$04
>8018	00 c7 0e 30 10 06 08 bc			.byte	$00,$c7,$0e,$30,$10,$06,$08,$bc
>8020	41 be 00 0b 05 00 c7 14			.byte	$41,$be,$00,$0b,$05,$00,$c7,$14
>8028	38 0d bc 41 be 00 0d 06			.byte	$38,$0d,$bc,$41,$be,$00,$0d,$06
>8030	00 c7 19 38 06 b8 42 bf			.byte	$00,$c7,$19,$38,$06,$b8,$42,$bf
>8038	41 be 00 0c 07 00 c7 19			.byte	$41,$be,$00,$0c,$07,$00,$c7,$19
>8040	33 03 13 bc 41 be 00 0b			.byte	$33,$03,$13,$bc,$41,$be,$00,$0b
>8048	08 00 c7 17 34 11 bd 41			.byte	$08,$00,$c7,$17,$34,$11,$bd,$41
>8050	be 00 0b 09 00 c7 12 36			.byte	$be,$00,$0b,$09,$00,$c7,$12,$36
>8058	0a bc 42 be 00 0f 0a 00			.byte	$0a,$bc,$42,$be,$00,$0f,$0a,$00
>8060	c7 18 37 15 09 0b bc 42			.byte	$c7,$18,$37,$15,$09,$0b,$bc,$42
>8068	bf 41 be 00 0e 0b 00 c7			.byte	$bf,$41,$be,$00,$0e,$0b,$00,$c7
>8070	0e 39 15 17 b8 42 bf 42			.byte	$0e,$39,$15,$17,$b8,$42,$bf,$42
>8078	be 00 0d 0c 00 c7 03 33			.byte	$be,$00,$0d,$0c,$00,$c7,$03,$33
>8080	0d 02 07 bc 41 be 00 0d			.byte	$0d,$02,$07,$bc,$41,$be,$00,$0d
>8088	0d 00 c7 1a 34 07 0c 0d			.byte	$0d,$00,$c7,$1a,$34,$07,$0c,$0d
>8090	ba 42 be 00 13 0e 00 cf			.byte	$ba,$42,$be,$00,$13,$0e,$00,$cf
>8098	0d 32 0c 05 b9 84 44 51			.byte	$0d,$32,$0c,$05,$b9,$84,$44,$51
>80a0	fd 06 39 33 37 35 00 11			.byte	$fd,$06,$39,$33,$37,$35,$00,$11
>80a8	0f 00 cf 14 39 17 84 44			.byte	$0f,$00,$cf,$14,$39,$17,$84,$44
>80b0	7f fd 06 33 31 32 35 00			.byte	$7f,$fd,$06,$33,$31,$32,$35,$00
>80b8	0c 10 00 cf 10 39 05 bb			.byte	$0c,$10,$00,$cf,$10,$39,$05,$bb
>80c0	84 42 40 00 0b 11 00 cf			.byte	$84,$42,$40,$00,$0b,$11,$00,$cf
>80c8	03 bb 84 8b 4b 67 00 0c			.byte	$03,$bb,$84,$8b,$4b,$67,$00,$0c
>80d0	12 00 cf 0b 37 16 bb 84			.byte	$12,$00,$cf,$0b,$37,$16,$bb,$84
>80d8	44 6d 00 0e 13 00 cf 19			.byte	$44,$6d,$00,$0e,$13,$00,$cf,$19
>80e0	33 03 13 bc 41 be 84 73			.byte	$33,$03,$13,$bc,$41,$be,$84,$73
>80e8	00 0c 14 00 cf 0a 35 18			.byte	$00,$0c,$14,$00,$cf,$0a,$35,$18
>80f0	b7 84 fe 02 00 13 15 00			.byte	$b7,$84,$fe,$02,$00,$13,$15,$00
>80f8	cf 1a 33 11 0a 19 84 48			.byte	$cf,$1a,$33,$11,$0a,$19,$84,$48
>8100	64 fd 06 33 31 32 35 00			.byte	$64,$fd,$06,$33,$31,$32,$35,$00
>8108	13 16 00 cf 17 34 11 bd			.byte	$13,$16,$00,$cf,$17,$34,$11,$bd
>8110	41 be 84 8b 43 54 fd 04			.byte	$41,$be,$84,$8b,$43,$54,$fd,$04
>8118	32 35 00 12 17 00 cf 17			.byte	$32,$35,$00,$12,$17,$00,$cf,$17
>8120	32 19 09 84 47 78 fd 06			.byte	$32,$19,$09,$84,$47,$78,$fd,$06
>8128	31 38 37 35 00 0e 18 00			.byte	$31,$38,$37,$35,$00,$0e,$18,$00
>8130	cf 12 36 0a bc 42 be 84			.byte	$cf,$12,$36,$0a,$bc,$42,$be,$84
>8138	4f 44 00 13 19 00 cf 0f			.byte	$4f,$44,$00,$13,$19,$00,$cf,$0f
>8140	35 0e 13 b9 84 8b 47 63			.byte	$35,$0e,$13,$b9,$84,$8b,$47,$63
>8148	fd 05 36 32 35 00 11 1a			.byte	$fd,$05,$36,$32,$35,$00,$11,$1a
>8150	00 cf 05 33 06 84 41 6a			.byte	$00,$cf,$05,$33,$06,$84,$41,$6a
>8158	fd 06 33 31 32 35 00 10			.byte	$fd,$06,$33,$31,$32,$35,$00,$10
>8160	1b 00 cf 17 b9 84 44 70			.byte	$1b,$00,$cf,$17,$b9,$84,$44,$70
>8168	fd 06 38 31 32 35 00 10			.byte	$fd,$06,$38,$31,$32,$35,$00,$10
>8170	1c 00 cf 19 34 1a b7 84			.byte	$1c,$00,$cf,$19,$34,$1a,$b7,$84
>8178	fe 06 47 38 45 53 00 10			.byte	$fe,$06,$47,$38,$45,$53,$00,$10
>8180	1d 00 cf 01 36 01 03 b7			.byte	$1d,$00,$cf,$01,$36,$01,$03,$b7
>8188	84 fe 05 42 30 57 00 11			.byte	$84,$fe,$05,$42,$30,$57,$00,$11
>8190	1e 00 cf 1a 37 02 84 8b			.byte	$1e,$00,$cf,$1a,$37,$02,$84,$8b
>8198	43 77 fd 05 36 32 35 00			.byte	$43,$77,$fd,$05,$36,$32,$35,$00
>81a0	0f 1f 00 cf 05 84 44 5e			.byte	$0f,$1f,$00,$cf,$05,$84,$44,$5e
>81a8	fd 06 36 38 37 35 00 0e			.byte	$fd,$06,$36,$38,$37,$35,$00,$0e
>81b0	20 00 cf 0f 84 59 fd 06			.byte	$20,$00,$cf,$0f,$84,$59,$fd,$06
>81b8	31 38 37 35 00 14 21 00			.byte	$31,$38,$37,$35,$00,$14,$21,$00
>81c0	cf 0e 37 1a 03 0f b9 84			.byte	$cf,$0e,$37,$1a,$03,$0f,$b9,$84
>81c8	42 7e fd 06 33 31 32 35			.byte	$42,$7e,$fd,$06,$33,$31,$32,$35
>81d0	00 10 22 00 cf 08 35 02			.byte	$00,$10,$22,$00,$cf,$08,$35,$02
>81d8	84 46 42 fd 05 38 37 35			.byte	$84,$46,$42,$fd,$05,$38,$37,$35
>81e0	00 12 23 00 cf 16 32 1a			.byte	$00,$12,$23,$00,$cf,$16,$32,$1a
>81e8	0a 0e 84 6f fd 06 34 33			.byte	$0a,$0e,$84,$6f,$fd,$06,$34,$33
>81f0	37 35 00 0d 24 00 cf 13			.byte	$37,$35,$00,$0d,$24,$00,$cf,$13
>81f8	84 8b 44 7d fd 03 30 00			.byte	$84,$8b,$44,$7d,$fd,$03,$30,$00
>8200	0f 25 00 cf 13 84 46 40			.byte	$0f,$25,$00,$cf,$13,$84,$46,$40
>8208	fd 06 39 33 37 35 00 0e			.byte	$fd,$06,$39,$33,$37,$35,$00,$0e
>8210	26 00 cf 05 32 11 0c 12			.byte	$26,$00,$cf,$05,$32,$11,$0c,$12
>8218	bb 84 41 76 00 12 27 00			.byte	$bb,$84,$41,$76,$00,$12,$27,$00
>8220	cf 12 32 05 08 03 b7 84			.byte	$cf,$12,$32,$05,$08,$03,$b7,$84
>8228	fe 06 4c 31 55 58 00 12			.byte	$fe,$06,$4c,$31,$55,$58,$00,$12
>8230	28 00 cf 07 36 07 0a 84			.byte	$28,$00,$cf,$07,$36,$07,$0a,$84
>8238	41 64 fd 06 36 38 37 35			.byte	$41,$64,$fd,$06,$36,$38,$37,$35
>8240	00 0e 29 00 cf 12 36 0a			.byte	$00,$0e,$29,$00,$cf,$12,$36,$0a
>8248	bc 41 be 84 45 46 00 12			.byte	$bc,$41,$be,$84,$45,$46,$00,$12
>8250	2a 00 cf 01 36 01 03 b7			.byte	$2a,$00,$cf,$01,$36,$01,$03,$b7
>8258	84 fe 07 45 33 42 51 54			.byte	$84,$fe,$07,$45,$33,$42,$51,$54
>8260	00 13 2b 00 cf 12 32 05			.byte	$00,$13,$2b,$00,$cf,$12,$32,$05
>8268	08 03 b7 84 fe 07 4e 37			.byte	$08,$03,$b7,$84,$fe,$07,$4e,$37
>8270	43 47 4f 00 0e 2c 00 cf			.byte	$43,$47,$4f,$00,$0e,$2c,$00,$cf
>8278	1a 36 0a 08 13 bb 84 42			.byte	$1a,$36,$0a,$08,$13,$bb,$84,$42
>8280	5a 00 12 2d 00 cf 0e 38			.byte	$5a,$00,$12,$2d,$00,$cf,$0e,$38
>8288	04 05 06 b9 84 44 5f fd			.byte	$04,$05,$06,$b9,$84,$44,$5f,$fd
>8290	04 37 35 00 11 2e 00 cf			.byte	$04,$37,$35,$00,$11,$2e,$00,$cf
>8298	1a 37 18 1a b9 84 48 7e			.byte	$1a,$37,$18,$1a,$b9,$84,$48,$7e
>82a0	fd 04 32 35 00 0d 2f 00			.byte	$fd,$04,$32,$35,$00,$0d,$2f,$00
>82a8	cf 02 34 16 0f bb 84 4c			.byte	$cf,$02,$34,$16,$0f,$bb,$84,$4c
>82b0	73 00 0c 30 00 cf 19 34			.byte	$73,$00,$0c,$30,$00,$cf,$19,$34
>82b8	1a b7 84 fe 02 00 15 31			.byte	$1a,$b7,$84,$fe,$02,$00,$15,$31
>82c0	00 cf 0b 35 0f 14 04 b9			.byte	$00,$cf,$0b,$35,$0f,$14,$04,$b9
>82c8	84 8b 46 7b fd 06 36 38			.byte	$84,$8b,$46,$7b,$fd,$06,$36,$38
>82d0	37 35 00 0e 32 00 cf 03			.byte	$37,$35,$00,$0e,$32,$00,$cf,$03
>82d8	32 0f b7 84 fe 04 49 38			.byte	$32,$0f,$b7,$84,$fe,$04,$49,$38
>82e0	00 12 33 00 cf 16 32 1a			.byte	$00,$12,$33,$00,$cf,$16,$32,$1a
>82e8	0a 0e 84 47 44 fd 05 31			.byte	$0a,$0e,$84,$47,$44,$fd,$05,$31
>82f0	32 35 00 10 34 00 cf 14			.byte	$32,$35,$00,$10,$34,$00,$cf,$14
>82f8	31 02 04 15 84 42 55 fd			.byte	$31,$02,$04,$15,$84,$42,$55,$fd
>8300	03 35 00 12 35 00 cf 03			.byte	$03,$35,$00,$12,$35,$00,$cf,$03
>8308	32 19 11 b9 84 49 68 fd			.byte	$32,$19,$11,$b9,$84,$49,$68,$fd
>8310	05 33 37 35 00 11 36 00			.byte	$05,$33,$37,$35,$00,$11,$36,$00
>8318	cf 09 34 03 b9 84 47 68			.byte	$cf,$09,$34,$03,$b9,$84,$47,$68
>8320	fd 05 33 37 35 00 0e 37			.byte	$fd,$05,$33,$37,$35,$00,$0e,$37
>8328	00 cf 0f 84 8b 45 42 fd			.byte	$00,$cf,$0f,$84,$8b,$45,$42,$fd
>8330	04 37 35 00 13 38 00 cf			.byte	$04,$37,$35,$00,$13,$38,$00,$cf
>8338	01 38 19 13 0d 84 46 57			.byte	$01,$38,$19,$13,$0d,$84,$46,$57
>8340	fd 06 34 33 37 35 00 10			.byte	$fd,$06,$34,$33,$37,$35,$00,$10
>8348	39 00 cf 0d b9 84 8b 45			.byte	$39,$00,$cf,$0d,$b9,$84,$8b,$45
>8350	73 fd 05 31 32 35 00 12			.byte	$73,$fd,$05,$31,$32,$35,$00,$12
>8358	3a 00 cf 0d 30 0d 09 b7			.byte	$3a,$00,$cf,$0d,$30,$0d,$09,$b7
>8360	84 fe 07 50 37 53 41 59			.byte	$84,$fe,$07,$50,$37,$53,$41,$59
>8368	00 11 3b 00 cf 14 39 17			.byte	$00,$11,$3b,$00,$cf,$14,$39,$17
>8370	84 8b 47 7b fd 05 31 32			.byte	$84,$8b,$47,$7b,$fd,$05,$31,$32
>8378	35 00 0c 3c 00 cf 0b 37			.byte	$35,$00,$0c,$3c,$00,$cf,$0b,$37
>8380	16 bb 84 47 53 00 12 3d			.byte	$16,$bb,$84,$47,$53,$00,$12,$3d
>8388	00 cf 07 36 07 0a 84 45			.byte	$00,$cf,$07,$36,$07,$0a,$84,$45
>8390	4e fd 06 34 33 37 35 00			.byte	$4e,$fd,$06,$34,$33,$37,$35,$00
>8398	15 3e 00 cf 0c bd 41 bf			.byte	$15,$3e,$00,$cf,$0c,$bd,$41,$bf
>83a0	41 be 84 8b 44 4b fd 06			.byte	$41,$be,$84,$8b,$44,$4b,$fd,$06
>83a8	38 31 32 35 00 0f 3f 00			.byte	$38,$31,$32,$35,$00,$0f,$3f,$00
>83b0	cf 07 36 07 0a 84 48 66			.byte	$cf,$07,$36,$07,$0a,$84,$48,$66
>83b8	fd 03 30 00 0e 40 00 cf			.byte	$fd,$03,$30,$00,$0e,$40,$00,$cf
>83c0	0b 84 51 fd 06 35 36 32			.byte	$0b,$84,$51,$fd,$06,$35,$36,$32
>83c8	35 00 12 41 00 cf 12 33			.byte	$35,$00,$12,$41,$00,$cf,$12,$33
>83d0	06 09 12 b9 84 8b 45 4e			.byte	$06,$09,$12,$b9,$84,$8b,$45,$4e
>83d8	fd 03 30 00 11 42 00 cf			.byte	$fd,$03,$30,$00,$11,$42,$00,$cf
>83e0	16 32 1a 0a 0e 84 8b 46			.byte	$16,$32,$1a,$0a,$0e,$84,$8b,$46
>83e8	49 fd 03 35 00 11 43 00			.byte	$49,$fd,$03,$35,$00,$11,$43,$00
>83f0	cf 0d 37 06 11 15 b7 84			.byte	$cf,$0d,$37,$06,$11,$15,$b7,$84
>83f8	fe 05 51 31 55 00 11 44			.byte	$fe,$05,$51,$31,$55,$00,$11,$44
>8400	00 cf 19 38 06 b8 40 bf			.byte	$00,$cf,$19,$38,$06,$b8,$40,$bf
>8408	40 be 84 fe 03 49 00 12			.byte	$40,$be,$84,$fe,$03,$49,$00,$12
>8410	45 00 cf 01 33 16 84 8b			.byte	$45,$00,$cf,$01,$33,$16,$84,$8b
>8418	47 55 fd 06 30 36 32 35			.byte	$47,$55,$fd,$06,$30,$36,$32,$35
>8420	00 0e 46 00 cf 08 36 0d			.byte	$00,$0e,$46,$00,$cf,$08,$36,$0d
>8428	11 12 bb 84 4b 5e 00 0f			.byte	$11,$12,$bb,$84,$4b,$5e,$00,$0f
>8430	47 00 cf 0b 84 45 69 fd			.byte	$47,$00,$cf,$0b,$84,$45,$69,$fd
>8438	06 36 38 37 35 00 10 48			.byte	$06,$36,$38,$37,$35,$00,$10,$48
>8440	00 cf 02 31 03 0f 84 47			.byte	$00,$cf,$02,$31,$03,$0f,$84,$47
>8448	77 fd 04 37 35 00 11 49			.byte	$77,$fd,$04,$37,$35,$00,$11,$49
>8450	00 cf 19 34 07 b9 84 41			.byte	$00,$cf,$19,$34,$07,$b9,$84,$41
>8458	7b fd 05 38 37 35 00 0d			.byte	$7b,$fd,$05,$38,$37,$35,$00,$0d
>8460	4a 00 cf 14 39 0a 0d bb			.byte	$4a,$00,$cf,$14,$39,$0a,$0d,$bb
>8468	84 49 53 00 0d 4b 00 cf			.byte	$84,$49,$53,$00,$0d,$4b,$00,$cf
>8470	1a b7 84 fe 05 52 35 4f			.byte	$1a,$b7,$84,$fe,$05,$52,$35,$4f
>8478	00 13 4c 00 cf 0b 35 0f			.byte	$00,$13,$4c,$00,$cf,$0b,$35,$0f
>8480	14 04 b9 84 42 67 fd 05			.byte	$14,$04,$b9,$84,$42,$67,$fd,$05
>8488	38 37 35 00 0f 4d 00 cf			.byte	$38,$37,$35,$00,$0f,$4d,$00,$cf
>8490	0e b7 84 fe 07 55 34 53			.byte	$0e,$b7,$84,$fe,$07,$55,$34,$53
>8498	58 49 00 12 4e 00 cf 09			.byte	$58,$49,$00,$12,$4e,$00,$cf,$09
>84a0	34 03 b9 84 46 7d fd 06			.byte	$34,$03,$b9,$84,$46,$7d,$fd,$06
>84a8	36 38 37 35 00 0e 4f 00			.byte	$36,$38,$37,$35,$00,$0e,$4f,$00
>84b0	cf 14 38 0d bc 40 be 84			.byte	$cf,$14,$38,$0d,$bc,$40,$be,$84
>84b8	4c 69 00 0d 50 00 cf 1a			.byte	$4c,$69,$00,$0d,$50,$00,$cf,$1a
>84c0	38 0d b7 84 fe 03 43 00			.byte	$38,$0d,$b7,$84,$fe,$03,$43,$00
>84c8	11 51 00 cf 01 36 01 03			.byte	$11,$51,$00,$cf,$01,$36,$01,$03
>84d0	b7 84 fe 06 49 39 59 59			.byte	$b7,$84,$fe,$06,$49,$39,$59,$59
>84d8	00 14 52 00 cf 17 34 11			.byte	$00,$14,$52,$00,$cf,$17,$34,$11
>84e0	bd 41 be 84 47 78 fd 06			.byte	$bd,$41,$be,$84,$47,$78,$fd,$06
>84e8	39 33 37 35 00 0d 53 00			.byte	$39,$33,$37,$35,$00,$0d,$53,$00
>84f0	cf 03 32 0f b7 84 fe 03			.byte	$cf,$03,$32,$0f,$b7,$84,$fe,$03
>84f8	42 00 11 54 00 cf 0d 30			.byte	$42,$00,$11,$54,$00,$cf,$0d,$30
>8500	0d 09 b7 84 fe 06 44 38			.byte	$0d,$09,$b7,$84,$fe,$06,$44,$38
>8508	45 54 00 0d 55 00 cf 09			.byte	$45,$54,$00,$0d,$55,$00,$cf,$09
>8510	32 04 b7 84 fe 03 54 00			.byte	$32,$04,$b7,$84,$fe,$03,$54,$00
>8518	0f 56 00 cf 13 34 0f 01			.byte	$0f,$56,$00,$cf,$13,$34,$0f,$01
>8520	04 bb 84 8b 4e 44 00 13			.byte	$04,$bb,$84,$8b,$4e,$44,$00,$13
>8528	57 00 cf 0d 37 06 11 15			.byte	$57,$00,$cf,$0d,$37,$06,$11,$15
>8530	b7 84 fe 07 56 30 46 56			.byte	$b7,$84,$fe,$07,$56,$30,$46,$56
>8538	4d 00 11 58 00 cf 19 34			.byte	$4d,$00,$11,$58,$00,$cf,$19,$34
>8540	1a b7 84 fe 07 59 33 59			.byte	$1a,$b7,$84,$fe,$07,$59,$33,$59
>8548	42 41 00 12 59 00 cf 17			.byte	$42,$41,$00,$12,$59,$00,$cf,$17
>8550	37 03 0b b7 84 fe 07 57			.byte	$37,$03,$0b,$b7,$84,$fe,$07,$57
>8558	30 54 56 41 00 0e 5a 00			.byte	$30,$54,$56,$41,$00,$0e,$5a,$00
>8560	cf 01 36 01 03 b7 84 fe			.byte	$cf,$01,$36,$01,$03,$b7,$84,$fe
>8568	03 56 00 14 5b 00 cf 17			.byte	$03,$56,$00,$14,$5b,$00,$cf,$17
>8570	35 04 02 14 b9 84 8b 68			.byte	$35,$04,$02,$14,$b9,$84,$8b,$68
>8578	fd 06 30 36 32 35 00 10			.byte	$fd,$06,$30,$36,$32,$35,$00,$10
>8580	5c 00 cf 17 b9 84 43 6b			.byte	$5c,$00,$cf,$17,$b9,$84,$43,$6b
>8588	fd 06 30 36 32 35 00 14			.byte	$fd,$06,$30,$36,$32,$35,$00,$14
>8590	5d 00 cf 1a 37 18 1a b9			.byte	$5d,$00,$cf,$1a,$37,$18,$1a,$b9
>8598	84 8b 45 49 fd 06 35 36			.byte	$84,$8b,$45,$49,$fd,$06,$35,$36
>85a0	32 35 00 11 5e 00 cf 0e			.byte	$32,$35,$00,$11,$5e,$00,$cf,$0e
>85a8	37 1a 03 0f b9 84 43 71			.byte	$37,$1a,$03,$0f,$b9,$84,$43,$71
>85b0	fd 03 30 00 0c 5f 00 cf			.byte	$fd,$03,$30,$00,$0c,$5f,$00,$cf
>85b8	10 39 05 bb 84 42 63 00			.byte	$10,$39,$05,$bb,$84,$42,$63,$00
>85c0	12 60 00 cf 06 34 17 12			.byte	$12,$60,$00,$cf,$06,$34,$17,$12
>85c8	84 8b 41 6e fd 05 31 32			.byte	$84,$8b,$41,$6e,$fd,$05,$31,$32
>85d0	35 00 0e 61 00 cf 02 34			.byte	$35,$00,$0e,$61,$00,$cf,$02,$34
>85d8	16 0f bb 84 8b 47 6a 00			.byte	$16,$0f,$bb,$84,$8b,$47,$6a,$00
>85e0	15 62 00 cf 0b 35 0f 14			.byte	$15,$62,$00,$cf,$0b,$35,$0f,$14
>85e8	04 b9 84 8b 45 6e fd 06			.byte	$04,$b9,$84,$8b,$45,$6e,$fd,$06
>85f0	35 36 32 35 00 13 63 00			.byte	$35,$36,$32,$35,$00,$13,$63,$00
>85f8	cf 01 38 19 13 0d 84 8b			.byte	$cf,$01,$38,$19,$13,$0d,$84,$8b
>8600	48 7a fd 05 36 32 35 00			.byte	$48,$7a,$fd,$05,$36,$32,$35,$00
>8608	12 64 00 cf 0e 39 15 17			.byte	$12,$64,$00,$cf,$0e,$39,$15,$17
>8610	b8 42 bf 40 be 84 fe 03			.byte	$b8,$42,$bf,$40,$be,$84,$fe,$03
>8618	4e 00 0e 65 00 cf 14 38			.byte	$4e,$00,$0e,$65,$00,$cf,$14,$38
>8620	0d bc 41 be 84 42 6b 00			.byte	$0d,$bc,$41,$be,$84,$42,$6b,$00
>8628	13 66 00 cf 0f 35 0e 13			.byte	$13,$66,$00,$cf,$0f,$35,$0e,$13
>8630	b9 84 48 50 fd 06 31 38			.byte	$b9,$84,$48,$50,$fd,$06,$31,$38
>8638	37 35 00 0f 67 00 cf 09			.byte	$37,$35,$00,$0f,$67,$00,$cf,$09
>8640	34 03 b9 84 70 fd 04 37			.byte	$34,$03,$b9,$84,$70,$fd,$04,$37
>8648	35 00 12 68 00 cf 01 34			.byte	$35,$00,$12,$68,$00,$cf,$01,$34
>8650	0b 0b b7 84 fe 07 58 30			.byte	$0b,$0b,$b7,$84,$fe,$07,$58,$30
>8658	42 59 46 00 10 69 00 cf			.byte	$42,$59,$46,$00,$10,$69,$00,$cf
>8660	0d 30 0d 09 b7 84 fe 05			.byte	$0d,$30,$0d,$09,$b7,$84,$fe,$05
>8668	53 37 45 00 0e 6a 00 cf			.byte	$53,$37,$45,$00,$0e,$6a,$00,$cf
>8670	01 36 01 03 b7 84 fe 03			.byte	$01,$36,$01,$03,$b7,$84,$fe,$03
>8678	49 00 12 6b 00 cf 0e 38			.byte	$49,$00,$12,$6b,$00,$cf,$0e,$38
>8680	04 05 06 b9 84 42 43 fd			.byte	$04,$05,$06,$b9,$84,$42,$43,$fd
>8688	04 32 35 00 13 6c 00 cf			.byte	$04,$32,$35,$00,$13,$6c,$00,$cf
>8690	12 32 05 08 03 b7 84 fe			.byte	$12,$32,$05,$08,$03,$b7,$84,$fe
>8698	07 56 38 41 41 59 00 15			.byte	$07,$56,$38,$41,$41,$59,$00,$15
>86a0	6d 00 cf 17 34 11 bd 41			.byte	$6d,$00,$cf,$17,$34,$11,$bd,$41
>86a8	be 84 8b 49 42 fd 06 30			.byte	$be,$84,$8b,$49,$42,$fd,$06,$30
>86b0	36 32 35 00 11 6e 00 cf			.byte	$36,$32,$35,$00,$11,$6e,$00,$cf
>86b8	14 39 17 84 41 4d fd 06			.byte	$14,$39,$17,$84,$41,$4d,$fd,$06
>86c0	35 36 32 35 00 0e 6f 00			.byte	$35,$36,$32,$35,$00,$0e,$6f,$00
>86c8	cf 1a 36 0a 08 13 bb 84			.byte	$cf,$1a,$36,$0a,$08,$13,$bb,$84
>86d0	41 48 00 15 70 00 cf 0e			.byte	$41,$48,$00,$15,$70,$00,$cf,$0e
>86d8	38 04 05 06 b9 84 8b 46			.byte	$38,$04,$05,$06,$b9,$84,$8b,$46
>86e0	4e fd 06 35 36 32 35 00			.byte	$4e,$fd,$06,$35,$36,$32,$35,$00
>86e8	0e 71 00 cf 08 36 0d 11			.byte	$0e,$71,$00,$cf,$08,$36,$0d,$11
>86f0	12 bb 84 44 69 00 0b 72			.byte	$12,$bb,$84,$44,$69,$00,$0b,$72
>86f8	00 cf 03 bb 84 8b 46 4e			.byte	$00,$cf,$03,$bb,$84,$8b,$46,$4e
>8700	00 0f 73 00 cf 0b 84 8b			.byte	$00,$0f,$73,$00,$cf,$0b,$84,$8b
>8708	48 7a fd 05 31 32 35 00			.byte	$48,$7a,$fd,$05,$31,$32,$35,$00
>8710	0d 74 00 cf 09 32 04 b7			.byte	$0d,$74,$00,$cf,$09,$32,$04,$b7
>8718	84 fe 03 41 00 10 75 00			.byte	$84,$fe,$03,$41,$00,$10,$75,$00
>8720	cf 19 33 03 13 bc 40 be			.byte	$cf,$19,$33,$03,$13,$bc,$40,$be
>8728	84 8b 48 73 00 10 76 00			.byte	$84,$8b,$48,$73,$00,$10,$76,$00
>8730	cf 03 32 0f b7 84 fe 06			.byte	$cf,$03,$32,$0f,$b7,$84,$fe,$06
>8738	59 33 45 4a 00 10 77 00			.byte	$59,$33,$45,$4a,$00,$10,$77,$00
>8740	cf 0f 84 8b 43 69 fd 06			.byte	$cf,$0f,$84,$8b,$43,$69,$fd,$06
>8748	38 31 32 35 00 0d 78 00			.byte	$38,$31,$32,$35,$00,$0d,$78,$00
>8750	cf 0f 84 8b 46 6e fd 03			.byte	$cf,$0f,$84,$8b,$46,$6e,$fd,$03
>8758	30 00 0c 79 00 cf 09 31			.byte	$30,$00,$0c,$79,$00,$cf,$09,$31
>8760	07 bb 84 4a 7b 00 11 7a			.byte	$07,$bb,$84,$4a,$7b,$00,$11,$7a
>8768	00 cf 01 35 14 84 8b 46			.byte	$00,$cf,$01,$35,$14,$84,$8b,$46
>8770	6c fd 05 31 32 35 00 14			.byte	$6c,$fd,$05,$31,$32,$35,$00,$14
>8778	7b 00 cf 16 32 1a 0a 0e			.byte	$7b,$00,$cf,$16,$32,$1a,$0a,$0e
>8780	84 8b 43 76 fd 06 35 36			.byte	$84,$8b,$43,$76,$fd,$06,$35,$36
>8788	32 35 00 10 7c 00 cf 04			.byte	$32,$35,$00,$10,$7c,$00,$cf,$04
>8790	36 10 84 8b 45 6a fd 04			.byte	$36,$10,$84,$8b,$45,$6a,$fd,$04
>8798	32 35 00 10 7d 00 cf 17			.byte	$32,$35,$00,$10,$7d,$00,$cf,$17
>87a0	b9 84 43 64 fd 06 39 33			.byte	$b9,$84,$43,$64,$fd,$06,$39,$33
>87a8	37 35 00 0e 7e 00 cf 02			.byte	$37,$35,$00,$0e,$7e,$00,$cf,$02
>87b0	34 16 0f bb 84 8b 47 45			.byte	$34,$16,$0f,$bb,$84,$8b,$47,$45
>87b8	00 11 7f 00 cf 09 34 03			.byte	$00,$11,$7f,$00,$cf,$09,$34,$03
>87c0	b9 84 46 59 fd 05 36 32			.byte	$b9,$84,$46,$59,$fd,$05,$36,$32
>87c8	35 00 0d 80 00 cf 06 31			.byte	$35,$00,$0d,$80,$00,$cf,$06,$31
>87d0	0e 0c bb 84 49 62 00 13			.byte	$0e,$0c,$bb,$84,$49,$62,$00,$13
>87d8	81 00 cf 0f 35 0e 13 b9			.byte	$81,$00,$cf,$0f,$35,$0e,$13,$b9
>87e0	84 47 41 fd 06 39 33 37			.byte	$84,$47,$41,$fd,$06,$39,$33,$37
>87e8	35 00 0f 82 00 cf 10 38			.byte	$35,$00,$0f,$82,$00,$cf,$10,$38
>87f0	0a 84 48 77 fd 04 37 35			.byte	$0a,$84,$48,$77,$fd,$04,$37,$35
>87f8	00 0d 83 00 cf 19 33 15			.byte	$00,$0d,$83,$00,$cf,$19,$33,$15
>8800	bb 84 8b 41 76 00 0e 84			.byte	$bb,$84,$8b,$41,$76,$00,$0e,$84
>8808	00 cf 01 34 0b 0b b7 84			.byte	$00,$cf,$01,$34,$0b,$0b,$b7,$84
>8810	fe 03 53 00 0d 85 00 cf			.byte	$fe,$03,$53,$00,$0d,$85,$00,$cf
>8818	18 35 12 bb 84 8b 49 6a			.byte	$18,$35,$12,$bb,$84,$8b,$49,$6a
>8820	00 13 86 00 cf 0b 35 0f			.byte	$00,$13,$86,$00,$cf,$0b,$35,$0f
>8828	14 04 b9 84 71 fd 06 31			.byte	$14,$04,$b9,$84,$71,$fd,$06,$31
>8830	38 37 35 00 0f 87 00 cf			.byte	$38,$37,$35,$00,$0f,$87,$00,$cf
>8838	03 32 0f b7 84 fe 05 4a			.byte	$03,$32,$0f,$b7,$84,$fe,$05,$4a
>8840	37 43 00 13 88 00 cf 11			.byte	$37,$43,$00,$13,$88,$00,$cf,$11
>8848	31 12 b9 84 8b 48 5e fd			.byte	$31,$12,$b9,$84,$8b,$48,$5e,$fd
>8850	06 39 33 37 35 00 15 89			.byte	$06,$39,$33,$37,$35,$00,$15,$89
>8858	00 cf 12 33 06 09 12 b9			.byte	$00,$cf,$12,$33,$06,$09,$12,$b9
>8860	84 8b 46 69 fd 06 33 31			.byte	$84,$8b,$46,$69,$fd,$06,$33,$31
>8868	32 35 00 13 8a 00 cf 0c			.byte	$32,$35,$00,$13,$8a,$00,$cf,$0c
>8870	bd 41 bf 41 be 84 41 44			.byte	$bd,$41,$bf,$41,$be,$84,$41,$44
>8878	fd 05 33 37 35 00 10 8b			.byte	$fd,$05,$33,$37,$35,$00,$10,$8b
>8880	00 cf 03 32 0f b7 84 fe			.byte	$00,$cf,$03,$32,$0f,$b7,$84,$fe
>8888	06 43 32 48 41 00 0f 8c			.byte	$06,$43,$32,$48,$41,$00,$0f,$8c
>8890	00 cf 14 39 17 84 41 65			.byte	$00,$cf,$14,$39,$17,$84,$41,$65
>8898	fd 04 37 35 00 13 8d 00			.byte	$fd,$04,$37,$35,$00,$13,$8d,$00
>88a0	cf 02 31 03 0f 84 8b 46			.byte	$cf,$02,$31,$03,$0f,$84,$8b,$46
>88a8	43 fd 06 35 36 32 35 00			.byte	$43,$fd,$06,$35,$36,$32,$35,$00
>88b0	13 8e 00 cf 07 36 07 0a			.byte	$13,$8e,$00,$cf,$07,$36,$07,$0a
>88b8	84 8b 44 5a fd 06 39 33			.byte	$84,$8b,$44,$5a,$fd,$06,$39,$33
>88c0	37 35 00 14 8f 00 cf 04			.byte	$37,$35,$00,$14,$8f,$00,$cf,$04
>88c8	39 13 02 17 b9 84 46 67			.byte	$39,$13,$02,$17,$b9,$84,$46,$67
>88d0	fd 06 36 38 37 35 00 10			.byte	$fd,$06,$36,$38,$37,$35,$00,$10
>88d8	90 00 cf 05 33 06 84 8b			.byte	$90,$00,$cf,$05,$33,$06,$84,$8b
>88e0	45 6c fd 04 37 35 00 0d			.byte	$45,$6c,$fd,$04,$37,$35,$00,$0d
>88e8	91 00 cf 12 b7 84 fe 05			.byte	$91,$00,$cf,$12,$b7,$84,$fe,$05
>88f0	4f 37 54 00 0f 92 00 cf			.byte	$4f,$37,$54,$00,$0f,$92,$00,$cf
>88f8	13 84 44 4b fd 06 39 33			.byte	$13,$84,$44,$4b,$fd,$06,$39,$33
>8900	37 35 00 0f 93 00 cf 14			.byte	$37,$35,$00,$0f,$93,$00,$cf,$14
>8908	32 06 08 19 bb 84 8b 49			.byte	$32,$06,$08,$19,$bb,$84,$8b,$49
>8910	54 00 0d 94 00 cf 0d 38			.byte	$54,$00,$0d,$94,$00,$cf,$0d,$38
>8918	13 07 bb 84 44 7f 00 12			.byte	$13,$07,$bb,$84,$44,$7f,$00,$12
>8920	95 00 cf 0f 35 0e 13 b9			.byte	$95,$00,$cf,$0f,$35,$0e,$13,$b9
>8928	84 8b 46 69 fd 04 32 35			.byte	$84,$8b,$46,$69,$fd,$04,$32,$35
>8930	00 11 96 00 cf 01 38 19			.byte	$00,$11,$96,$00,$cf,$01,$38,$19
>8938	13 0d 84 41 7c fd 04 37			.byte	$13,$0d,$84,$41,$7c,$fd,$04,$37
>8940	35 00 0d 97 00 cf 0a 30			.byte	$35,$00,$0d,$97,$00,$cf,$0a,$30
>8948	05 bb 84 8b 46 5f 00 13			.byte	$05,$bb,$84,$8b,$46,$5f,$00,$13
>8950	98 00 cf 16 38 0f 06 84			.byte	$98,$00,$cf,$16,$38,$0f,$06,$84
>8958	8b 47 76 fd 06 35 36 32			.byte	$8b,$47,$76,$fd,$06,$35,$36,$32
>8960	35 00 11 99 00 cf 19 30			.byte	$35,$00,$11,$99,$00,$cf,$19,$30
>8968	05 18 11 b9 84 41 71 fd			.byte	$05,$18,$11,$b9,$84,$41,$71,$fd
>8970	03 30 00 0f 9a 00 cf 09			.byte	$03,$30,$00,$0f,$9a,$00,$cf,$09
>8978	32 04 b7 84 fe 05 4e 31			.byte	$32,$04,$b7,$84,$fe,$05,$4e,$31
>8980	4c 00 10 9b 00 cf 17 37			.byte	$4c,$00,$10,$9b,$00,$cf,$17,$37
>8988	03 0b b7 84 fe 05 45 38			.byte	$03,$0b,$b7,$84,$fe,$05,$45,$38
>8990	58 00 11 9c 00 cf 0a 35			.byte	$58,$00,$11,$9c,$00,$cf,$0a,$35
>8998	18 b7 84 fe 07 45 30 58			.byte	$18,$b7,$84,$fe,$07,$45,$30,$58
>89a0	42 57 00 11 9d 00 cf 17			.byte	$42,$57,$00,$11,$9d,$00,$cf,$17
>89a8	32 19 09 84 58 fd 06 35			.byte	$32,$19,$09,$84,$58,$fd,$06,$35
>89b0	36 32 35 00 12 9e 00 cf			.byte	$36,$32,$35,$00,$12,$9e,$00,$cf
>89b8	1a 33 11 0a 19 84 43 5d			.byte	$1a,$33,$11,$0a,$19,$84,$43,$5d
>89c0	fd 05 33 37 35 00 11 9f			.byte	$fd,$05,$33,$37,$35,$00,$11,$9f
>89c8	00 cf 04 31 0d 12 07 b9			.byte	$00,$cf,$04,$31,$0d,$12,$07,$b9
>89d0	84 41 5a fd 03 30 00 0f			.byte	$84,$41,$5a,$fd,$03,$30,$00,$0f
>89d8	a0 00 cf 08 36 0d 11 12			.byte	$a0,$00,$cf,$08,$36,$0d,$11,$12
>89e0	bb 84 8b 47 6c 00 0e a1			.byte	$bb,$84,$8b,$47,$6c,$00,$0e,$a1
>89e8	00 cf 02 b7 84 fe 06 4d			.byte	$00,$cf,$02,$b7,$84,$fe,$06,$4d
>89f0	38 49 46 00 0f a2 00 cf			.byte	$38,$49,$46,$00,$0f,$a2,$00,$cf
>89f8	10 84 44 5a fd 06 33 31			.byte	$10,$84,$44,$5a,$fd,$06,$33,$31
>8a00	32 35 00 0a a3 00 cf 09			.byte	$32,$35,$00,$0a,$a3,$00,$cf,$09
>8a08	bb 84 4a 68 00 11 a4 00			.byte	$bb,$84,$4a,$68,$00,$11,$a4,$00
>8a10	cf 09 34 03 b9 84 47 66			.byte	$cf,$09,$34,$03,$b9,$84,$47,$66
>8a18	fd 05 31 32 35 00 0f a5			.byte	$fd,$05,$31,$32,$35,$00,$0f,$a5
>8a20	00 cf 0f 84 8b 71 fd 06			.byte	$00,$cf,$0f,$84,$8b,$71,$fd,$06
>8a28	34 33 37 35 00 0f a6 00			.byte	$34,$33,$37,$35,$00,$0f,$a6,$00
>8a30	cf 14 38 0d bc 41 be 84			.byte	$cf,$14,$38,$0d,$bc,$41,$be,$84
>8a38	8b 42 5b 00 0e a7 00 cf			.byte	$8b,$42,$5b,$00,$0e,$a7,$00,$cf
>8a40	02 37 15 84 44 6e fd 03			.byte	$02,$37,$15,$84,$44,$6e,$fd,$03
>8a48	35 00 10 a8 00 cf 03 33			.byte	$35,$00,$10,$a8,$00,$cf,$03,$33
>8a50	0d 02 07 bc 41 be 84 4a			.byte	$0d,$02,$07,$bc,$41,$be,$84,$4a
>8a58	7a 00 12 a9 00 cf 09 34			.byte	$7a,$00,$12,$a9,$00,$cf,$09,$34
>8a60	03 b9 84 45 4a fd 06 34			.byte	$03,$b9,$84,$45,$4a,$fd,$06,$34
>8a68	33 37 35 00 0f aa 00 cf			.byte	$33,$37,$35,$00,$0f,$aa,$00,$cf
>8a70	14 34 13 13 14 bb 84 8b			.byte	$14,$34,$13,$13,$14,$bb,$84,$8b
>8a78	4d 68 00 10 ab 00 cf 19			.byte	$4d,$68,$00,$10,$ab,$00,$cf,$19
>8a80	34 1a b7 84 fe 06 42 35			.byte	$34,$1a,$b7,$84,$fe,$06,$42,$35
>8a88	43 4e 00 0e ac 00 cf 13			.byte	$43,$4e,$00,$0e,$ac,$00,$cf,$13
>8a90	34 0f 01 04 bb 84 4d 43			.byte	$34,$0f,$01,$04,$bb,$84,$4d,$43
>8a98	00 0f ad 00 cf 0b 84 8b			.byte	$00,$0f,$ad,$00,$cf,$0b,$84,$8b
>8aa0	42 4f fd 05 36 32 35 00			.byte	$42,$4f,$fd,$05,$36,$32,$35,$00
>8aa8	0b ae 00 cf 11 bb 84 8b			.byte	$0b,$ae,$00,$cf,$11,$bb,$84,$8b
>8ab0	4b 5f 00 0d af 00 cf 15			.byte	$4b,$5f,$00,$0d,$af,$00,$cf,$15
>8ab8	31 0f bb 84 8b 46 60 00			.byte	$31,$0f,$bb,$84,$8b,$46,$60,$00
>8ac0	0f b0 00 cf 19 34 1a b7			.byte	$0f,$b0,$00,$cf,$19,$34,$1a,$b7
>8ac8	84 fe 05 43 35 43 00 0a			.byte	$84,$fe,$05,$43,$35,$43,$00,$0a
>8ad0	b1 00 cf 03 bb 84 45 66			.byte	$b1,$00,$cf,$03,$bb,$84,$45,$66
>8ad8	00 11 b2 00 cf 06 34 17			.byte	$00,$11,$b2,$00,$cf,$06,$34,$17
>8ae0	12 84 45 77 fd 05 31 32			.byte	$12,$84,$45,$77,$fd,$05,$31,$32
>8ae8	35 00 12 b3 00 cf 02 31			.byte	$35,$00,$12,$b3,$00,$cf,$02,$31
>8af0	03 0f 84 8b 42 67 fd 05			.byte	$03,$0f,$84,$8b,$42,$67,$fd,$05
>8af8	31 32 35 00 13 b4 00 cf			.byte	$31,$32,$35,$00,$13,$b4,$00,$cf
>8b00	05 39 11 b9 84 8b 43 62			.byte	$05,$39,$11,$b9,$84,$8b,$43,$62
>8b08	fd 06 34 33 37 35 00 0f			.byte	$fd,$06,$34,$33,$37,$35,$00,$0f
>8b10	b5 00 cf 0d b9 84 8b 42			.byte	$b5,$00,$cf,$0d,$b9,$84,$8b,$42
>8b18	7c fd 04 37 35 00 13 b6			.byte	$7c,$fd,$04,$37,$35,$00,$13,$b6
>8b20	00 cf 06 34 17 12 84 8b			.byte	$00,$cf,$06,$34,$17,$12,$84,$8b
>8b28	43 4a fd 06 30 36 32 35			.byte	$43,$4a,$fd,$06,$30,$36,$32,$35
>8b30	00 0e b7 00 cf 03 32 0f			.byte	$00,$0e,$b7,$00,$cf,$03,$32,$0f
>8b38	b7 84 fe 04 4f 32 00 13			.byte	$b7,$84,$fe,$04,$4f,$32,$00,$13
>8b40	b8 00 cf 05 39 17 01 04			.byte	$b8,$00,$cf,$05,$39,$17,$01,$04
>8b48	84 8b 44 4e fd 05 33 37			.byte	$84,$8b,$44,$4e,$fd,$05,$33,$37
>8b50	35 00 11 b9 00 cf 01 38			.byte	$35,$00,$11,$b9,$00,$cf,$01,$38
>8b58	19 13 0d 84 72 fd 05 33			.byte	$19,$13,$0d,$84,$72,$fd,$05,$33
>8b60	37 35 00 14 ba 00 cf 14			.byte	$37,$35,$00,$14,$ba,$00,$cf,$14
>8b68	31 02 04 15 84 8b 48 51			.byte	$31,$02,$04,$15,$84,$8b,$48,$51
>8b70	fd 06 38 31 32 35 00 11			.byte	$fd,$06,$38,$31,$32,$35,$00,$11
>8b78	bb 00 cf 04 36 10 84 8b			.byte	$bb,$00,$cf,$04,$36,$10,$84,$8b
>8b80	43 48 fd 05 33 37 35 00			.byte	$43,$48,$fd,$05,$33,$37,$35,$00
>8b88	0c bc 00 cf 0b 37 16 bb			.byte	$0c,$bc,$00,$cf,$0b,$37,$16,$bb
>8b90	84 4d 49 00 11 bd 00 cf			.byte	$84,$4d,$49,$00,$11,$bd,$00,$cf
>8b98	07 36 07 0a 84 41 75 fd			.byte	$07,$36,$07,$0a,$84,$41,$75,$fd
>8ba0	05 36 32 35 00 0c be 00			.byte	$05,$36,$32,$35,$00,$0c,$be,$00
>8ba8	cf 01 33 19 bb 84 49 6e			.byte	$cf,$01,$33,$19,$bb,$84,$49,$6e
>8bb0	00 13 bf 00 cf 17 34 11			.byte	$00,$13,$bf,$00,$cf,$17,$34,$11
>8bb8	bd 41 be 84 42 50 fd 05			.byte	$bd,$41,$be,$84,$42,$50,$fd,$05
>8bc0	36 32 35 00 0c c0 00 cf			.byte	$36,$32,$35,$00,$0c,$c0,$00,$cf
>8bc8	1a 38 17 bb 84 4e 58 00			.byte	$1a,$38,$17,$bb,$84,$4e,$58,$00
>8bd0	0d c1 00 cf 0c 35 19 0a			.byte	$0d,$c1,$00,$cf,$0c,$35,$19,$0a
>8bd8	b7 84 fe 02 00 0a c2 00			.byte	$b7,$84,$fe,$02,$00,$0a,$c2,$00
>8be0	cf 0a bb 84 42 4b 00 11			.byte	$cf,$0a,$bb,$84,$42,$4b,$00,$11
>8be8	c3 00 cf 01 35 14 84 41			.byte	$c3,$00,$cf,$01,$35,$14,$84,$41
>8bf0	54 fd 06 31 38 37 35 00			.byte	$54,$fd,$06,$31,$38,$37,$35,$00
>8bf8	0a c4 00 cf 09 bb 84 44			.byte	$0a,$c4,$00,$cf,$09,$bb,$84,$44
>8c00	7c 00 11 c5 00 cf 18 37			.byte	$7c,$00,$11,$c5,$00,$cf,$18,$37
>8c08	15 09 0b bc 42 bf 41 be			.byte	$15,$09,$0b,$bc,$42,$bf,$41,$be
>8c10	84 7b 00 12 c6 00 cf 14			.byte	$84,$7b,$00,$12,$c6,$00,$cf,$14
>8c18	39 17 84 8b 44 69 fd 06			.byte	$39,$17,$84,$8b,$44,$69,$fd,$06
>8c20	31 38 37 35 00 14 c7 00			.byte	$31,$38,$37,$35,$00,$14,$c7,$00
>8c28	cf 04 33 03 1a 11 84 8b			.byte	$cf,$04,$33,$03,$1a,$11,$84,$8b
>8c30	46 45 fd 06 36 38 37 35			.byte	$46,$45,$fd,$06,$36,$38,$37,$35
>8c38	00 0e c8 00 cf 14 39 0a			.byte	$00,$0e,$c8,$00,$cf,$14,$39,$0a
>8c40	0d bb 84 8b 42 4f 00 0d			.byte	$0d,$bb,$84,$8b,$42,$4f,$00,$0d
>8c48	c9 00 cf 06 31 0e 0c bb			.byte	$c9,$00,$cf,$06,$31,$0e,$0c,$bb
>8c50	84 41 5c 00 12 ca 00 cf			.byte	$84,$41,$5c,$00,$12,$ca,$00,$cf
>8c58	08 35 02 84 8b 46 6c fd			.byte	$08,$35,$02,$84,$8b,$46,$6c,$fd
>8c60	06 30 36 32 35 00 14 cb			.byte	$06,$30,$36,$32,$35,$00,$14,$cb
>8c68	00 cf 04 31 0d 12 07 b9			.byte	$00,$cf,$04,$31,$0d,$12,$07,$b9
>8c70	84 8b 42 6b fd 05 38 37			.byte	$84,$8b,$42,$6b,$fd,$05,$38,$37
>8c78	35 00 0b cc 00 cf 12 b7			.byte	$35,$00,$0b,$cc,$00,$cf,$12,$b7
>8c80	84 fe 03 46 00 13 cd 00			.byte	$84,$fe,$03,$46,$00,$13,$cd,$00
>8c88	cf 0f 35 0e 13 b9 84 47			.byte	$cf,$0f,$35,$0e,$13,$b9,$84,$47
>8c90	51 fd 06 33 31 32 35 00			.byte	$51,$fd,$06,$33,$31,$32,$35,$00
>8c98	0b ce 00 cf 09 31 07 bb			.byte	$0b,$ce,$00,$cf,$09,$31,$07,$bb
>8ca0	84 67 00 10 cf 00 cf 05			.byte	$84,$67,$00,$10,$cf,$00,$cf,$05
>8ca8	33 06 84 45 5b fd 05 31			.byte	$33,$06,$84,$45,$5b,$fd,$05,$31
>8cb0	32 35 00 14 d0 00 cf 01			.byte	$32,$35,$00,$14,$d0,$00,$cf,$01
>8cb8	32 10 07 0c 84 8b 49 54			.byte	$32,$10,$07,$0c,$84,$8b,$49,$54
>8cc0	fd 06 39 33 37 35 00 15			.byte	$fd,$06,$39,$33,$37,$35,$00,$15
>8cc8	d1 00 cf 0e 38 04 05 06			.byte	$d1,$00,$cf,$0e,$38,$04,$05,$06
>8cd0	b9 84 8b 47 6b fd 06 33			.byte	$b9,$84,$8b,$47,$6b,$fd,$06,$33
>8cd8	31 32 35 00 0e d2 00 cf			.byte	$31,$32,$35,$00,$0e,$d2,$00,$cf
>8ce0	0b 84 7a fd 06 38 31 32			.byte	$0b,$84,$7a,$fd,$06,$38,$31,$32
>8ce8	35 00 11 d3 00 cf 11 31			.byte	$35,$00,$11,$d3,$00,$cf,$11,$31
>8cf0	12 b9 84 8b 41 4b fd 04			.byte	$12,$b9,$84,$8b,$41,$4b,$fd,$04
>8cf8	37 35 00 0b d4 00 cf 16			.byte	$37,$35,$00,$0b,$d4,$00,$cf,$16
>8d00	bb 84 8b 4e 48 00 0e d5			.byte	$bb,$84,$8b,$4e,$48,$00,$0e,$d5
>8d08	00 cf 0f 84 8b 45 6b fd			.byte	$00,$cf,$0f,$84,$8b,$45,$6b,$fd
>8d10	04 37 35 00 0d d6 00 dc			.byte	$04,$37,$35,$00,$0d,$d6,$00,$dc
>8d18	1a b7 84 fe 05 52 35 4f			.byte	$1a,$b7,$84,$fe,$05,$52,$35,$4f
>8d20	00 0e d7 00 dc 03 32 0f			.byte	$00,$0e,$d7,$00,$dc,$03,$32,$0f
>8d28	b7 84 fe 04 4f 32 00 0b			.byte	$b7,$84,$fe,$04,$4f,$32,$00,$0b
>8d30	d8 00 dc 09 31 07 bb 84			.byte	$d8,$00,$dc,$09,$31,$07,$bb,$84
>8d38	67 00 14 d9 00 dc 17 35			.byte	$67,$00,$14,$d9,$00,$dc,$17,$35
>8d40	04 02 14 b9 84 8b 68 fd			.byte	$04,$02,$14,$b9,$84,$8b,$68,$fd
>8d48	06 30 36 32 35 00 0f da			.byte	$06,$30,$36,$32,$35,$00,$0f,$da
>8d50	00 dc 19 34 1a b7 84 fe			.byte	$00,$dc,$19,$34,$1a,$b7,$84,$fe
>8d58	05 43 35 43 00 13 db 00			.byte	$05,$43,$35,$43,$00,$13,$db,$00
>8d60	dc 06 34 17 12 84 8b 43			.byte	$dc,$06,$34,$17,$12,$84,$8b,$43
>8d68	4a fd 06 30 36 32 35 00			.byte	$4a,$fd,$06,$30,$36,$32,$35,$00
>8d70	09 dc 00 dc 04 bb 84 40			.byte	$09,$dc,$00,$dc,$04,$bb,$84,$40
>8d78	00 13 dd 00 dc 0d 32 0c			.byte	$00,$13,$dd,$00,$dc,$0d,$32,$0c
>8d80	05 b9 84 44 51 fd 06 39			.byte	$05,$b9,$84,$44,$51,$fd,$06,$39
>8d88	33 37 35 00 11 de 00 dc			.byte	$33,$37,$35,$00,$11,$de,$00,$dc
>8d90	0a 35 18 b7 84 fe 07 45			.byte	$0a,$35,$18,$b7,$84,$fe,$07,$45
>8d98	30 58 42 57 00 0e df 00			.byte	$30,$58,$42,$57,$00,$0e,$df,$00
>8da0	dc 05 32 11 0c 12 bb 84			.byte	$dc,$05,$32,$11,$0c,$12,$bb,$84
>8da8	41 76 00 0f e0 00 dc 10			.byte	$41,$76,$00,$0f,$e0,$00,$dc,$10
>8db0	38 0a 84 48 77 fd 04 37			.byte	$38,$0a,$84,$48,$77,$fd,$04,$37
>8db8	35 00 0c e1 00 dc 10 39			.byte	$35,$00,$0c,$e1,$00,$dc,$10,$39
>8dc0	05 bb 84 42 63 00 0d e2			.byte	$05,$bb,$84,$42,$63,$00,$0d,$e2
>8dc8	00 dc 1a 38 0d b7 84 fe			.byte	$00,$dc,$1a,$38,$0d,$b7,$84,$fe
>8dd0	03 43 00 0f e3 00 dc 14			.byte	$03,$43,$00,$0f,$e3,$00,$dc,$14
>8dd8	32 06 08 19 bb 84 8b 49			.byte	$32,$06,$08,$19,$bb,$84,$8b,$49
>8de0	54 00 12 e4 00 dc 02 31			.byte	$54,$00,$12,$e4,$00,$dc,$02,$31
>8de8	03 0f 84 8b 42 67 fd 05			.byte	$03,$0f,$84,$8b,$42,$67,$fd,$05
>8df0	31 32 35 00 11 e5 00 dc			.byte	$31,$32,$35,$00,$11,$e5,$00,$dc
>8df8	11 31 12 b9 84 8b 41 4b			.byte	$11,$31,$12,$b9,$84,$8b,$41,$4b
>8e00	fd 04 37 35 00 0d e6 00			.byte	$fd,$04,$37,$35,$00,$0d,$e6,$00
>8e08	dc 18 35 12 bb 84 8b 49			.byte	$dc,$18,$35,$12,$bb,$84,$8b,$49
>8e10	6a 00 14 e7 00 dc 1a 37			.byte	$6a,$00,$14,$e7,$00,$dc,$1a,$37
>8e18	18 1a b9 84 8b 45 49 fd			.byte	$18,$1a,$b9,$84,$8b,$45,$49,$fd
>8e20	06 35 36 32 35 00 0c e8			.byte	$06,$35,$36,$32,$35,$00,$0c,$e8
>8e28	00 dc 05 37 10 03 0f 84			.byte	$00,$dc,$05,$37,$10,$03,$0f,$84
>8e30	40 00 10 e9 00 dc 0d 30			.byte	$40,$00,$10,$e9,$00,$dc,$0d,$30
>8e38	0d 09 b7 84 fe 05 53 37			.byte	$0d,$09,$b7,$84,$fe,$05,$53,$37
>8e40	45 00 0f ea 00 dc 0e b7			.byte	$45,$00,$0f,$ea,$00,$dc,$0e,$b7
>8e48	84 fe 07 55 34 53 58 49			.byte	$84,$fe,$07,$55,$34,$53,$58,$49
>8e50	00 0d eb 00 dc 03 30 19			.byte	$00,$0d,$eb,$00,$dc,$03,$30,$19
>8e58	03 b7 84 fe 02 00 0e ec			.byte	$03,$b7,$84,$fe,$02,$00,$0e,$ec
>8e60	00 dc 0f 84 8b 45 6b fd			.byte	$00,$dc,$0f,$84,$8b,$45,$6b,$fd
>8e68	04 37 35 00 09 ed 00 dc			.byte	$04,$37,$35,$00,$09,$ed,$00,$dc
>8e70	06 bb 84 40 00 0a ee 00			.byte	$06,$bb,$84,$40,$00,$0a,$ee,$00
>8e78	dc 0a bb 84 42 4b 00 12			.byte	$dc,$0a,$bb,$84,$42,$4b,$00,$12
>8e80	ef 00 dc 03 32 19 11 b9			.byte	$ef,$00,$dc,$03,$32,$19,$11,$b9
>8e88	84 49 68 fd 05 33 37 35			.byte	$84,$49,$68,$fd,$05,$33,$37,$35
>8e90	00 10 f0 00 dc 17 b9 84			.byte	$00,$10,$f0,$00,$dc,$17,$b9,$84
>8e98	43 64 fd 06 39 33 37 35			.byte	$43,$64,$fd,$06,$39,$33,$37,$35
>8ea0	00 13 f1 00 dc 05 39 11			.byte	$00,$13,$f1,$00,$dc,$05,$39,$11
>8ea8	b9 84 8b 43 62 fd 06 34			.byte	$b9,$84,$8b,$43,$62,$fd,$06,$34
>8eb0	33 37 35 00 11 f2 00 dc			.byte	$33,$37,$35,$00,$11,$f2,$00,$dc
>8eb8	01 35 14 84 41 54 fd 06			.byte	$01,$35,$14,$84,$41,$54,$fd,$06
>8ec0	31 38 37 35 00 0f f3 00			.byte	$31,$38,$37,$35,$00,$0f,$f3,$00
>8ec8	dc 0d b9 84 8b 42 7c fd			.byte	$dc,$0d,$b9,$84,$8b,$42,$7c,$fd
>8ed0	04 37 35 00 0b f4 00 dc			.byte	$04,$37,$35,$00,$0b,$f4,$00,$dc
>8ed8	19 34 15 bb 84 40 00 11			.byte	$19,$34,$15,$bb,$84,$40,$00,$11
>8ee0	f5 00 dc 19 30 05 18 11			.byte	$f5,$00,$dc,$19,$30,$05,$18,$11
>8ee8	b9 84 41 71 fd 03 30 00			.byte	$b9,$84,$41,$71,$fd,$03,$30,$00
>8ef0	0e f6 00 dc 0b 84 7a fd			.byte	$0e,$f6,$00,$dc,$0b,$84,$7a,$fd
>8ef8	06 38 31 32 35 00 0a f7			.byte	$06,$38,$31,$32,$35,$00,$0a,$f7
>8f00	00 dc 03 bb 84 45 66 00			.byte	$00,$dc,$03,$bb,$84,$45,$66,$00
>8f08	0e f8 00 dc 02 b7 84 fe			.byte	$0e,$f8,$00,$dc,$02,$b7,$84,$fe
>8f10	06 4d 38 49 46 00 14 f9			.byte	$06,$4d,$38,$49,$46,$00,$14,$f9
>8f18	00 dc 14 31 02 04 15 84			.byte	$00,$dc,$14,$31,$02,$04,$15,$84
>8f20	8b 48 51 fd 06 38 31 32			.byte	$8b,$48,$51,$fd,$06,$38,$31,$32
>8f28	35 00 0f fa 00 dc 05 84			.byte	$35,$00,$0f,$fa,$00,$dc,$05,$84
>8f30	44 5e fd 06 36 38 37 35			.byte	$44,$5e,$fd,$06,$36,$38,$37,$35
>8f38	00 0e fb 00 dc 13 34 0f			.byte	$00,$0e,$fb,$00,$dc,$13,$34,$0f
>8f40	01 04 bb 84 4d 43 00 0d			.byte	$01,$04,$bb,$84,$4d,$43,$00,$0d
>8f48	fc 00 dc 0d 38 13 07 bb			.byte	$fc,$00,$dc,$0d,$38,$13,$07,$bb
>8f50	84 44 7f 00 0c fd 00 dc			.byte	$84,$44,$7f,$00,$0c,$fd,$00,$dc
>8f58	0b 33 0f 14 bb 84 40 00			.byte	$0b,$33,$0f,$14,$bb,$84,$40,$00
>8f60	0e fe 00 dc 14 39 0a 0d			.byte	$0e,$fe,$00,$dc,$14,$39,$0a,$0d
>8f68	bb 84 8b 42 4f 00 0f ff			.byte	$bb,$84,$8b,$42,$4f,$00,$0f,$ff
>8f70	00 dc 09 32 04 b7 84 fe			.byte	$00,$dc,$09,$32,$04,$b7,$84,$fe
>8f78	05 4e 31 4c 00 0b 00 01			.byte	$05,$4e,$31,$4c,$00,$0b,$00,$01
>8f80	dc 0a 31 0b b9 84 40 00			.byte	$dc,$0a,$31,$0b,$b9,$84,$40,$00
>8f88	11 01 01 dc 17 32 19 09			.byte	$11,$01,$01,$dc,$17,$32,$19,$09
>8f90	84 58 fd 06 35 36 32 35			.byte	$84,$58,$fd,$06,$35,$36,$32,$35
>8f98	00 13 02 01 dc 0b 35 0f			.byte	$00,$13,$02,$01,$dc,$0b,$35,$0f
>8fa0	14 04 b9 84 71 fd 06 31			.byte	$14,$04,$b9,$84,$71,$fd,$06,$31
>8fa8	38 37 35 00 0f 03 01 dc			.byte	$38,$37,$35,$00,$0f,$03,$01,$dc
>8fb0	13 84 44 4b fd 06 39 33			.byte	$13,$84,$44,$4b,$fd,$06,$39,$33
>8fb8	37 35 00 12 04 01 dc 14			.byte	$37,$35,$00,$12,$04,$01,$dc,$14
>8fc0	39 17 84 8b 44 69 fd 06			.byte	$39,$17,$84,$8b,$44,$69,$fd,$06
>8fc8	31 38 37 35 00 11 05 01			.byte	$31,$38,$37,$35,$00,$11,$05,$01
>8fd0	dc 19 34 07 b9 84 41 7b			.byte	$dc,$19,$34,$07,$b9,$84,$41,$7b
>8fd8	fd 05 38 37 35 00 0b 06			.byte	$fd,$05,$38,$37,$35,$00,$0b,$06
>8fe0	01 dc 16 bb 84 8b 4e 48			.byte	$01,$dc,$16,$bb,$84,$8b,$4e,$48
>8fe8	00 0d 07 01 dc 19 33 15			.byte	$00,$0d,$07,$01,$dc,$19,$33,$15
>8ff0	bb 84 8b 41 76 00 12 08			.byte	$bb,$84,$8b,$41,$76,$00,$12,$08
>8ff8	01 dc 1a 33 11 0a 19 84			.byte	$01,$dc,$1a,$33,$11,$0a,$19,$84
>9000	43 5d fd 05 33 37 35 00			.byte	$43,$5d,$fd,$05,$33,$37,$35,$00
>9008	0e 09 01 dc 01 36 01 03			.byte	$0e,$09,$01,$dc,$01,$36,$01,$03
>9010	b7 84 fe 03 49 00 0b 0a			.byte	$b7,$84,$fe,$03,$49,$00,$0b,$0a
>9018	01 dc 06 36 01 0d 84 40			.byte	$01,$dc,$06,$36,$01,$0d,$84,$40
>9020	00 0b 0b 01 dc 11 bb 84			.byte	$00,$0b,$0b,$01,$dc,$11,$bb,$84
>9028	8b 4b 5f 00 14 0c 01 dc			.byte	$8b,$4b,$5f,$00,$14,$0c,$01,$dc
>9030	04 33 03 1a 11 84 8b 46			.byte	$04,$33,$03,$1a,$11,$84,$8b,$46
>9038	45 fd 06 36 38 37 35 00			.byte	$45,$fd,$06,$36,$38,$37,$35,$00
>9040	13 0d 01 dc 0f 35 0e 13			.byte	$13,$0d,$01,$dc,$0f,$35,$0e,$13
>9048	b9 84 47 51 fd 06 33 31			.byte	$b9,$84,$47,$51,$fd,$06,$33,$31
>9050	32 35 00 15 0e 01 dc 12			.byte	$32,$35,$00,$15,$0e,$01,$dc,$12
>9058	33 06 09 12 b9 84 8b 46			.byte	$33,$06,$09,$12,$b9,$84,$8b,$46
>9060	69 fd 06 33 31 32 35 00			.byte	$69,$fd,$06,$33,$31,$32,$35,$00
>9068	0e 0f 01 dc 01 34 0b 0b			.byte	$0e,$0f,$01,$dc,$01,$34,$0b,$0b
>9070	b7 84 fe 03 53 00 14 10			.byte	$b7,$84,$fe,$03,$53,$00,$14,$10
>9078	01 dc 01 32 10 07 0c 84			.byte	$01,$dc,$01,$32,$10,$07,$0c,$84
>9080	8b 49 54 fd 06 39 33 37			.byte	$8b,$49,$54,$fd,$06,$39,$33,$37
>9088	35 00 0b 11 01 dc 12 b7			.byte	$35,$00,$0b,$11,$01,$dc,$12,$b7
>9090	84 fe 03 46 00 0c 12 01			.byte	$84,$fe,$03,$46,$00,$0c,$12,$01
>9098	dc 0b 34 11 b7 84 fe 02			.byte	$dc,$0b,$34,$11,$b7,$84,$fe,$02
>90a0	00 0f 13 01 dc 08 36 0d			.byte	$00,$0f,$13,$01,$dc,$08,$36,$0d
>90a8	11 12 bb 84 8b 47 6c 00			.byte	$11,$12,$bb,$84,$8b,$47,$6c,$00
>90b0	11 14 01 dc 01 38 19 13			.byte	$11,$14,$01,$dc,$01,$38,$19,$13
>90b8	0d 84 72 fd 05 33 37 35			.byte	$0d,$84,$72,$fd,$05,$33,$37,$35
>90c0	00 10 15 01 dc 05 33 06			.byte	$00,$10,$15,$01,$dc,$05,$33,$06
>90c8	84 45 5b fd 05 31 32 35			.byte	$84,$45,$5b,$fd,$05,$31,$32,$35
>90d0	00 0e 16 01 dc 1a 36 0a			.byte	$00,$0e,$16,$01,$dc,$1a,$36,$0a
>90d8	08 13 bb 84 41 48 00 14			.byte	$08,$13,$bb,$84,$41,$48,$00,$14
>90e0	17 01 dc 04 31 0d 12 07			.byte	$17,$01,$dc,$04,$31,$0d,$12,$07
>90e8	b9 84 8b 42 6b fd 05 38			.byte	$b9,$84,$8b,$42,$6b,$fd,$05,$38
>90f0	37 35 00 0e 18 01 dc 02			.byte	$37,$35,$00,$0e,$18,$01,$dc,$02
>90f8	34 16 0f bb 84 8b 47 45			.byte	$34,$16,$0f,$bb,$84,$8b,$47,$45
>9100	00 0d 19 01 dc 15 31 0f			.byte	$00,$0d,$19,$01,$dc,$15,$31,$0f
>9108	bb 84 8b 46 60 00 0d 1a			.byte	$bb,$84,$8b,$46,$60,$00,$0d,$1a
>9110	01 dc 0a 30 05 bb 84 8b			.byte	$01,$dc,$0a,$30,$05,$bb,$84,$8b
>9118	46 5f 00 0b 1b 01 dc 16			.byte	$46,$5f,$00,$0b,$1b,$01,$dc,$16
>9120	36 04 0d 84 40 00 12 1c			.byte	$36,$04,$0d,$84,$40,$00,$12,$1c
>9128	01 dc 01 33 16 84 8b 47			.byte	$01,$dc,$01,$33,$16,$84,$8b,$47
>9130	55 fd 06 30 36 32 35 00			.byte	$55,$fd,$06,$30,$36,$32,$35,$00
>9138	0c 1d 01 dc 01 33 19 bb			.byte	$0c,$1d,$01,$dc,$01,$33,$19,$bb
>9140	84 49 6e 00 0a 1e 01 dc			.byte	$84,$49,$6e,$00,$0a,$1e,$01,$dc
>9148	09 bb 84 44 7c 00 0c 1f			.byte	$09,$bb,$84,$44,$7c,$00,$0c,$1f
>9150	01 dc 1a 38 17 bb 84 4e			.byte	$01,$dc,$1a,$38,$17,$bb,$84,$4e
>9158	58 00 10 20 01 dc 17 37			.byte	$58,$00,$10,$20,$01,$dc,$17,$37
>9160	03 0b b7 84 fe 05 45 38			.byte	$03,$0b,$b7,$84,$fe,$05,$45,$38
>9168	58 00 0d 21 01 dc 06 31			.byte	$58,$00,$0d,$21,$01,$dc,$06,$31
>9170	0e 0c bb 84 41 5c 00 12			.byte	$0e,$0c,$bb,$84,$41,$5c,$00,$12
>9178	22 01 dc 09 34 03 b9 84			.byte	$22,$01,$dc,$09,$34,$03,$b9,$84
>9180	45 4a fd 06 34 33 37 35			.byte	$45,$4a,$fd,$06,$34,$33,$37,$35
>9188	00 13 23 01 dc 05 39 17			.byte	$00,$13,$23,$01,$dc,$05,$39,$17
>9190	01 04 84 8b 44 4e fd 05			.byte	$01,$04,$84,$8b,$44,$4e,$fd,$05
>9198	33 37 35 00 14 24 01 dc			.byte	$33,$37,$35,$00,$14,$24,$01,$dc
>91a0	04 39 13 02 17 b9 84 46			.byte	$04,$39,$13,$02,$17,$b9,$84,$46
>91a8	67 fd 06 36 38 37 35 00			.byte	$67,$fd,$06,$36,$38,$37,$35,$00
>91b0	11 25 01 dc 1a 37 02 84			.byte	$11,$25,$01,$dc,$1a,$37,$02,$84
>91b8	8b 43 77 fd 05 36 32 35			.byte	$8b,$43,$77,$fd,$05,$36,$32,$35
>91c0	00 0f 26 01 dc 10 84 44			.byte	$00,$0f,$26,$01,$dc,$10,$84,$44
>91c8	5a fd 06 33 31 32 35 00			.byte	$5a,$fd,$06,$33,$31,$32,$35,$00
>91d0	0c 27 01 dc 14 36 13 0a			.byte	$0c,$27,$01,$dc,$14,$36,$13,$0a
>91d8	bb 84 40 00 13 28 01 dc			.byte	$bb,$84,$40,$00,$13,$28,$01,$dc
>91e0	16 38 0f 06 84 8b 47 76			.byte	$16,$38,$0f,$06,$84,$8b,$47,$76
>91e8	fd 06 35 36 32 35 00 11			.byte	$fd,$06,$35,$36,$32,$35,$00,$11
>91f0	29 01 dc 07 36 07 0a 84			.byte	$29,$01,$dc,$07,$36,$07,$0a,$84
>91f8	41 75 fd 05 36 32 35 00			.byte	$41,$75,$fd,$05,$36,$32,$35,$00
>9200	0c 2a 01 dc 01 39 11 02			.byte	$0c,$2a,$01,$dc,$01,$39,$11,$02
>9208	b9 84 40 00 11 2b 01 dc			.byte	$b9,$84,$40,$00,$11,$2b,$01,$dc
>9210	0e 37 1a 03 0f b9 84 43			.byte	$0e,$37,$1a,$03,$0f,$b9,$84,$43
>9218	71 fd 03 30 00 0b 2c 01			.byte	$71,$fd,$03,$30,$00,$0b,$2c,$01
>9220	dc 0f 37 0a b9 84 40 00			.byte	$dc,$0f,$37,$0a,$b9,$84,$40,$00
>9228	13 2d 01 dc 0d 37 06 11			.byte	$13,$2d,$01,$dc,$0d,$37,$06,$11
>9230	15 b7 84 fe 07 56 30 46			.byte	$15,$b7,$84,$fe,$07,$56,$30,$46
>9238	56 4d 00 15 2e 01 dc 0e			.byte	$56,$4d,$00,$15,$2e,$01,$dc,$0e
>9240	38 04 05 06 b9 84 8b 47			.byte	$38,$04,$05,$06,$b9,$84,$8b,$47
>9248	6b fd 06 33 31 32 35 00			.byte	$6b,$fd,$06,$33,$31,$32,$35,$00
>9250	0c 2f 01 dc 0b 37 16 bb			.byte	$0c,$2f,$01,$dc,$0b,$37,$16,$bb
>9258	84 4d 49 00 0b 30 01 dc			.byte	$84,$4d,$49,$00,$0b,$30,$01,$dc
>9260	04 36 17 04 84 40 00 14			.byte	$04,$36,$17,$04,$84,$40,$00,$14
>9268	31 01 dc 16 32 1a 0a 0e			.byte	$31,$01,$dc,$16,$32,$1a,$0a,$0e
>9270	84 8b 43 76 fd 06 35 36			.byte	$84,$8b,$43,$76,$fd,$06,$35,$36
>9278	32 35 00 0c 32 01 dc 0d			.byte	$32,$35,$00,$0c,$32,$01,$dc,$0d
>9280	30 14 b7 84 fe 02 00 0f			.byte	$30,$14,$b7,$84,$fe,$02,$00,$0f
>9288	33 01 dc 14 34 13 13 14			.byte	$33,$01,$dc,$14,$34,$13,$13,$14
>9290	bb 84 8b 4d 68 00 08 34			.byte	$bb,$84,$8b,$4d,$68,$00,$08,$34
>9298	01 dc 19 84 40 00 0d 35			.byte	$01,$dc,$19,$84,$40,$00,$0d,$35
>92a0	01 dc 0c 35 19 0a b7 84			.byte	$01,$dc,$0c,$35,$19,$0a,$b7,$84
>92a8	fe 02 00 11 36 01 dc 04			.byte	$fe,$02,$00,$11,$36,$01,$dc,$04
>92b0	36 10 84 8b 43 48 fd 05			.byte	$36,$10,$84,$8b,$43,$48,$fd,$05
>92b8	33 37 35 00 13 37 01 dc			.byte	$33,$37,$35,$00,$13,$37,$01,$dc
>92c0	12 32 05 08 03 b7 84 fe			.byte	$12,$32,$05,$08,$03,$b7,$84,$fe
>92c8	07 56 38 41 41 59 00 12			.byte	$07,$56,$38,$41,$41,$59,$00,$12
>92d0	38 01 dc 08 35 02 84 8b			.byte	$38,$01,$dc,$08,$35,$02,$84,$8b
>92d8	46 6c fd 06 30 36 32 35			.byte	$46,$6c,$fd,$06,$30,$36,$32,$35
>92e0	00 0e 39 01 dc 02 37 15			.byte	$00,$0e,$39,$01,$dc,$02,$37,$15
>92e8	84 44 6e fd 03 35 00 31			.byte	$84,$44,$6e,$fd,$03,$35,$00,$31
>92f0	3a 01 dc 0c bd 40 bf 40			.byte	$3a,$01,$dc,$0c,$bd,$40,$bf,$40
>92f8	be 84 40 c0 dc 0c bd 40			.byte	$be,$84,$40,$c0,$dc,$0c,$bd,$40
>9300	bf 41 be 84 40 c0 dc 0c			.byte	$bf,$41,$be,$84,$40,$c0,$dc,$0c
>9308	bd 41 bf 40 be 84 40 c0			.byte	$bd,$41,$bf,$40,$be,$84,$40,$c0
>9310	dc 0c bd 41 bf 41 be 84			.byte	$dc,$0c,$bd,$41,$bf,$41,$be,$84
>9318	41 44 fd 05 33 37 35 00			.byte	$41,$44,$fd,$05,$33,$37,$35,$00
>9320	45 3b 01 dc 01 b8 40 bf			.byte	$45,$3b,$01,$dc,$01,$b8,$40,$bf
>9328	40 be 84 fe 02 c0 dc 01			.byte	$40,$be,$84,$fe,$02,$c0,$dc,$01
>9330	b8 40 bf 41 be 84 fe 02			.byte	$b8,$40,$bf,$41,$be,$84,$fe,$02
>9338	c0 dc 01 b8 40 bf 42 be			.byte	$c0,$dc,$01,$b8,$40,$bf,$42,$be
>9340	84 fe 02 c0 dc 01 b8 41			.byte	$84,$fe,$02,$c0,$dc,$01,$b8,$41
>9348	bf 40 be 84 fe 02 c0 dc			.byte	$bf,$40,$be,$84,$fe,$02,$c0,$dc
>9350	01 b8 41 bf 41 be 84 fe			.byte	$01,$b8,$41,$bf,$41,$be,$84,$fe
>9358	02 c0 dc 01 b8 41 bf 42			.byte	$02,$c0,$dc,$01,$b8,$41,$bf,$42
>9360	be 84 fe 02 00 1b 3c 01			.byte	$be,$84,$fe,$02,$00,$1b,$3c,$01
>9368	dc 0e 30 10 06 08 bc 40			.byte	$dc,$0e,$30,$10,$06,$08,$bc,$40
>9370	be 84 40 c0 dc 0e 30 10			.byte	$be,$84,$40,$c0,$dc,$0e,$30,$10
>9378	06 08 bc 41 be 84 40 00			.byte	$06,$08,$bc,$41,$be,$84,$40,$00
>9380	1a 3d 01 dc 14 38 0d bc			.byte	$1a,$3d,$01,$dc,$14,$38,$0d,$bc
>9388	40 be 84 4c 69 c0 dc 14			.byte	$40,$be,$84,$4c,$69,$c0,$dc,$14
>9390	38 0d bc 41 be 84 8b 42			.byte	$38,$0d,$bc,$41,$be,$84,$8b,$42
>9398	5b 00 52 3e 01 dc 19 38			.byte	$5b,$00,$52,$3e,$01,$dc,$19,$38
>93a0	06 b8 40 bf 40 be 84 fe			.byte	$06,$b8,$40,$bf,$40,$be,$84,$fe
>93a8	03 49 c0 dc 19 38 06 b8			.byte	$03,$49,$c0,$dc,$19,$38,$06,$b8
>93b0	40 bf 41 be 84 fe 02 c0			.byte	$40,$bf,$41,$be,$84,$fe,$02,$c0
>93b8	dc 19 38 06 b8 41 bf 40			.byte	$dc,$19,$38,$06,$b8,$41,$bf,$40
>93c0	be 84 fe 02 c0 dc 19 38			.byte	$be,$84,$fe,$02,$c0,$dc,$19,$38
>93c8	06 b8 41 bf 41 be 84 fe			.byte	$06,$b8,$41,$bf,$41,$be,$84,$fe
>93d0	02 c0 dc 19 38 06 b8 42			.byte	$02,$c0,$dc,$19,$38,$06,$b8,$42
>93d8	bf 40 be 84 fe 02 c0 dc			.byte	$bf,$40,$be,$84,$fe,$02,$c0,$dc
>93e0	19 38 06 b8 42 bf 41 be			.byte	$19,$38,$06,$b8,$42,$bf,$41,$be
>93e8	84 fe 02 00 1b 3f 01 dc			.byte	$84,$fe,$02,$00,$1b,$3f,$01,$dc
>93f0	19 33 03 13 bc 40 be 84			.byte	$19,$33,$03,$13,$bc,$40,$be,$84
>93f8	8b 48 73 c0 dc 19 33 03			.byte	$8b,$48,$73,$c0,$dc,$19,$33,$03
>9400	13 bc 41 be 84 73 00 1d			.byte	$13,$bc,$41,$be,$84,$73,$00,$1d
>9408	40 01 dc 17 34 11 bd 40			.byte	$40,$01,$dc,$17,$34,$11,$bd,$40
>9410	be 84 40 c0 dc 17 34 11			.byte	$be,$84,$40,$c0,$dc,$17,$34,$11
>9418	bd 41 be 84 42 50 fd 05			.byte	$bd,$41,$be,$84,$42,$50,$fd,$05
>9420	36 32 35 00 23 41 01 dc			.byte	$36,$32,$35,$00,$23,$41,$01,$dc
>9428	12 36 0a bc 40 be 84 40			.byte	$12,$36,$0a,$bc,$40,$be,$84,$40
>9430	c0 dc 12 36 0a bc 41 be			.byte	$c0,$dc,$12,$36,$0a,$bc,$41,$be
>9438	84 45 46 c0 dc 12 36 0a			.byte	$84,$45,$46,$c0,$dc,$12,$36,$0a
>9440	bc 42 be 84 4f 44 00 57			.byte	$bc,$42,$be,$84,$4f,$44,$00,$57
>9448	42 01 dc 18 37 15 09 0b			.byte	$42,$01,$dc,$18,$37,$15,$09,$0b
>9450	bc 40 bf 40 be 84 40 c0			.byte	$bc,$40,$bf,$40,$be,$84,$40,$c0
>9458	dc 18 37 15 09 0b bc 40			.byte	$dc,$18,$37,$15,$09,$0b,$bc,$40
>9460	bf 41 be 84 40 c0 dc 18			.byte	$bf,$41,$be,$84,$40,$c0,$dc,$18
>9468	37 15 09 0b bc 41 bf 40			.byte	$37,$15,$09,$0b,$bc,$41,$bf,$40
>9470	be 84 40 c0 dc 18 37 15			.byte	$be,$84,$40,$c0,$dc,$18,$37,$15
>9478	09 0b bc 41 bf 41 be 84			.byte	$09,$0b,$bc,$41,$bf,$41,$be,$84
>9480	40 c0 dc 18 37 15 09 0b			.byte	$40,$c0,$dc,$18,$37,$15,$09,$0b
>9488	bc 42 bf 40 be 84 40 c0			.byte	$bc,$42,$bf,$40,$be,$84,$40,$c0
>9490	dc 18 37 15 09 0b bc 42			.byte	$dc,$18,$37,$15,$09,$0b,$bc,$42
>9498	bf 41 be 84 7b 00 82 43			.byte	$bf,$41,$be,$84,$7b,$00,$82,$43
>94a0	01 dc 0e 39 15 17 b8 40			.byte	$01,$dc,$0e,$39,$15,$17,$b8,$40
>94a8	bf 40 be 84 fe 02 c0 dc			.byte	$bf,$40,$be,$84,$fe,$02,$c0,$dc
>94b0	0e 39 15 17 b8 40 bf 41			.byte	$0e,$39,$15,$17,$b8,$40,$bf,$41
>94b8	be 84 fe 02 c0 dc 0e 39			.byte	$be,$84,$fe,$02,$c0,$dc,$0e,$39
>94c0	15 17 b8 40 bf 42 be 84			.byte	$15,$17,$b8,$40,$bf,$42,$be,$84
>94c8	fe 02 c0 dc 0e 39 15 17			.byte	$fe,$02,$c0,$dc,$0e,$39,$15,$17
>94d0	b8 41 bf 40 be 84 fe 02			.byte	$b8,$41,$bf,$40,$be,$84,$fe,$02
>94d8	c0 dc 0e 39 15 17 b8 41			.byte	$c0,$dc,$0e,$39,$15,$17,$b8,$41
>94e0	bf 41 be 84 fe 02 c0 dc			.byte	$bf,$41,$be,$84,$fe,$02,$c0,$dc
>94e8	0e 39 15 17 b8 41 bf 42			.byte	$0e,$39,$15,$17,$b8,$41,$bf,$42
>94f0	be 84 fe 02 c0 dc 0e 39			.byte	$be,$84,$fe,$02,$c0,$dc,$0e,$39
>94f8	15 17 b8 42 bf 40 be 84			.byte	$15,$17,$b8,$42,$bf,$40,$be,$84
>9500	fe 03 4e c0 dc 0e 39 15			.byte	$fe,$03,$4e,$c0,$dc,$0e,$39,$15
>9508	17 b8 42 bf 41 be 84 fe			.byte	$17,$b8,$42,$bf,$41,$be,$84,$fe
>9510	02 c0 dc 0e 39 15 17 b8			.byte	$02,$c0,$dc,$0e,$39,$15,$17,$b8
>9518	42 bf 42 be 84 fe 02 00			.byte	$42,$bf,$42,$be,$84,$fe,$02,$00
>9520	1c 44 01 dc 03 33 0d 02			.byte	$1c,$44,$01,$dc,$03,$33,$0d,$02
>9528	07 bc 40 be 84 40 c0 dc			.byte	$07,$bc,$40,$be,$84,$40,$c0,$dc
>9530	03 33 0d 02 07 bc 41 be			.byte	$03,$33,$0d,$02,$07,$bc,$41,$be
>9538	84 4a 7a 00 27 45 01 dc			.byte	$84,$4a,$7a,$00,$27,$45,$01,$dc
>9540	1a 34 07 0c 0d ba 40 be			.byte	$1a,$34,$07,$0c,$0d,$ba,$40,$be
>9548	84 40 c0 dc 1a 34 07 0c			.byte	$84,$40,$c0,$dc,$1a,$34,$07,$0c
>9550	0d ba 41 be 84 40 c0 dc			.byte	$0d,$ba,$41,$be,$84,$40,$c0,$dc
>9558	1a 34 07 0c 0d ba 42 be			.byte	$1a,$34,$07,$0c,$0d,$ba,$42,$be
>9560	84 40 00 1b 46 01 d6 fe			.byte	$84,$40,$00,$1b,$46,$01,$d6,$fe
>9568	14 50 61 73 73 65 64 20			.byte	$14,$50,$61,$73,$73,$65,$64,$20
>9570	41 73 73 69 67 6e 6d 65			.byte	$41,$73,$73,$69,$67,$6e,$6d,$65
>9578	6e 74 2e c0 c4 00 00			.byte	$6e,$74,$2e,$c0,$c4,$00,$00

;******  Return to file: modules/hardware/mega65.asm

.a000					StartROM:
.a000	a2 ff		ldx #$ff			ldx 		#$FF 					; empty stack
.a002	9a		txs				txs
.a003	20 4d a2	jsr $a24d			jsr 	IF_Reset 					; reset external interface
.a006	20 0c a0	jsr $a00c			jsr 	IFT_ClearScreen
.a009	4c c9 af	jmp $afc9		jmp BASIC_Start

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.a00c					IFT_ClearScreen:
.a00c	48		pha				pha
.a00d	da		phx				phx
.a00e	5a		phy				phy
.a00f	20 b4 a1	jsr $a1b4			jsr 	IF_Home 					; home cursor
.a012	a2 19		ldx #$19			ldx 	#IF_Height 					; this many lines.
.a014					_IFT_CS0:
.a014	a0 50		ldy #$50			ldy 	#IF_Width 					; this many chars/line
.a016					_IFT_CS1:
.a016	a9 20		lda #$20			lda 	#' '						; clear line.
.a018	20 e3 a1	jsr $a1e3			jsr 	IF_Write
.a01b	88		dey				dey
.a01c	d0 f8		bne $a016			bne 	_IFT_CS1
.a01e	20 c3 a1	jsr $a1c3			jsr 	IF_NewLine 					; next line down
.a021	ca		dex				dex
.a022	d0 f0		bne $a014			bne 	_IFT_CS0
.a024	7a		ply				ply
.a025	fa		plx				plx
.a026	68		pla				pla
.a027					IFT_HomeCursor:
.a027	48		pha				pha
.a028	20 b4 a1	jsr $a1b4			jsr 	IF_Home
.a02b	a9 00		lda #$00			lda 	#0
.a02d	8d bd 03	sta $03bd			sta 	IFT_XCursor
.a030	8d be 03	sta $03be			sta 	IFT_YCursor
.a033	68		pla				pla
.a034	60		rts				rts
.a035					IFT_UpLine:
.a035	48		pha				pha
.a036	ad be 03	lda $03be			lda  	IFT_YCursor 				; get Y
.a039	3a		dec a				dec 	a 							; line above
.a03a	30 03		bmi $a03f			bmi 	_IFTULExit 					; too far, abort
.a03c	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos					; set to that line.
.a03f					_IFTULExit:
.a03f	68		pla				pla
.a040	60		rts				rts
.a041					IFT_PrintCharacter:
.a041	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.a043	f0 23		beq $a068			beq 	IFT_NewLine
.a045	48		pha				pha
.a046	20 80 a0	jsr $a080			jsr 	IFT_UpperCase 				; make upper case
.a049	20 e3 a1	jsr $a1e3			jsr 	IF_Write 					; write out.
.a04c	ee bd 03	inc $03bd			inc 	IFT_XCursor 				; bump x cursor
.a04f	ad bd 03	lda $03bd			lda 	IFT_XCursor 				; reached RHS ?
.a052	c9 50		cmp #$50			cmp 	#IF_Width
.a054	d0 03		bne $a059			bne 	_IFT_PCNotEOL
.a056	20 68 a0	jsr $a068			jsr 	IFT_NewLine 				; if so do new line.
.a059					_IFT_PCNotEOL:
.a059	68		pla				pla
.a05a	60		rts				rts
.a05b					IFT_Tab:
.a05b	a9 20		lda #$20			lda 	#" " 						; space
.a05d	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.a060	ad bd 03	lda $03bd			lda 	IFT_XCursor 				; until x % 8 == 0
.a063	29 07		and #$07			and 	#7
.a065	d0 f4		bne $a05b			bne 	IFT_Tab
.a067	60		rts				rts
.a068					IFT_NewLine:
.a068	48		pha				pha
.a069	20 c3 a1	jsr $a1c3			jsr 	IF_NewLine 					; new line on actual screen.
.a06c	a9 00		lda #$00			lda 	#0 							; reset x position
.a06e	8d bd 03	sta $03bd			sta 	IFT_XCursor
.a071	ee be 03	inc $03be			inc 	IFT_YCursor 				; move down.
.a074	ad be 03	lda $03be			lda 	IFT_YCursor
.a077	c9 19		cmp #$19			cmp 	#IF_Height 					; reached bottom.
.a079	d0 03		bne $a07e			bne 	_IFT_NL_NotEOS
.a07b	20 8b a0	jsr $a08b			jsr 	IFT_Scroll 					; scroll screen up.
.a07e					_IFT_NL_NotEOS:
.a07e	68		pla				pla
.a07f	60		rts				rts
.a080					IFT_UpperCase:
.a080	c9 61		cmp #$61			cmp 	#"a"
.a082	90 06		bcc $a08a			bcc 	_IFT_UCExit
.a084	c9 7b		cmp #$7b			cmp 	#"z"+1
.a086	b0 02		bcs $a08a			bcs 	_IFT_UCExit
.a088	49 20		eor #$20			eor 	#$20
.a08a					_IFT_UCExit:
.a08a	60		rts				rts
.a08b					IFT_Scroll:
.a08b	48		pha				pha 								; save AXY
.a08c	da		phx				phx
.a08d	5a		phy				phy
.a08e	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.a090					_IFT_SLoop:
.a090	20 b0 a0	jsr $a0b0			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.a093	e8		inx				inx
.a094	e0 18		cpx #$18			cpx 	#IF_Height-1				; do whole screen
.a096	d0 f8		bne $a090			bne 	_IFT_SLoop
.a098	a9 18		lda #$18			lda 	#IF_Height-1 				; move to X = 0,Y = A
.a09a	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a09d	a2 50		ldx #$50			ldx 	#IF_Width 					; blank line
.a09f					_IFT_SBlank:
.a09f	a9 20		lda #$20			lda 	#32
.a0a1	20 e3 a1	jsr $a1e3			jsr 	IF_Write
.a0a4	ca		dex				dex
.a0a5	d0 f8		bne $a09f			bne 	_IFT_SBlank
.a0a7	a9 18		lda #$18			lda 	#IF_Height-1 				; move to X = 0,Y = A
.a0a9	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a0ac	7a		ply				ply
.a0ad	fa		plx				plx
.a0ae	68		pla				pla
.a0af	60		rts				rts
.a0b0					_IFT_ScrollLine:
.a0b0	da		phx				phx
.a0b1	da		phx				phx
.a0b2	8a		txa				txa 								; copy line into buffer.
.a0b3	1a		inc a				inc 	a 							; next line down.
.a0b4	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a0b7	a2 00		ldx #$00			ldx 	#0
.a0b9					_IFTScrollCopy1:
.a0b9	20 d5 a1	jsr $a1d5			jsr 	IF_Read
.a0bc	9d bf 03	sta $03bf,x			sta 	IFT_Buffer,x
.a0bf	e8		inx				inx
.a0c0	e0 50		cpx #$50			cpx 	#IF_Width
.a0c2	d0 f5		bne $a0b9			bne 	_IFTScrollCopy1
.a0c4	68		pla				pla
.a0c5	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a0c8	a2 00		ldx #$00			ldx 	#0
.a0ca					_IFTScrollCopy2:
.a0ca	bd bf 03	lda $03bf,x			lda 	IFT_Buffer,x
.a0cd	20 e3 a1	jsr $a1e3			jsr 	IF_Write
.a0d0	e8		inx				inx
.a0d1	e0 50		cpx #$50			cpx 	#IF_Width
.a0d3	d0 f5		bne $a0ca			bne 	_IFTScrollCopy2
.a0d5	fa		plx				plx
.a0d6	60		rts				rts
.a0d7					IFT_SetYPos:
.a0d7	48		pha				pha
.a0d8	da		phx				phx
.a0d9	aa		tax				tax
.a0da	20 27 a0	jsr $a027			jsr 	IFT_HomeCursor
.a0dd	e0 00		cpx #$00			cpx 	#0
.a0df	f0 09		beq $a0ea			beq 	_IFT_MOAExit
.a0e1					_IFT_MOALoop:
.a0e1	20 c3 a1	jsr $a1c3			jsr 	IF_NewLine
.a0e4	ee be 03	inc $03be			inc 	IFT_YCursor
.a0e7	ca		dex				dex
.a0e8	d0 f7		bne $a0e1			bne		_IFT_MOALoop
.a0ea					_IFT_MOAExit:
.a0ea	fa		plx				plx
.a0eb	68		pla				pla
.a0ec	60		rts				rts
.a0ed					IFT_GetKeyCursor:
.a0ed	20 f5 a0	jsr $a0f5			jsr 	_IFT_FlipCursor 			; reverse current
.a0f0					_IFT_GKCWait:
.a0f0	20 06 a2	jsr $a206			jsr 	IF_GetKey 					; get key
.a0f3	f0 fb		beq $a0f0			beq 	_IFT_GKCWait
.a0f5					_IFT_FlipCursor:
.a0f5	48		pha				pha 								; save
.a0f6	20 d5 a1	jsr $a1d5			jsr 	IF_Read 					; read
.a0f9	20 ee a1	jsr $a1ee			jsr 	IF_LeftOne
.a0fc	49 80		eor #$80			eor 	#$80 						; reverse
.a0fe	20 e3 a1	jsr $a1e3			jsr 	IF_Write 					; write
.a101	20 ee a1	jsr $a1ee			jsr 	IF_LeftOne
.a104	68		pla				pla
.a105	60		rts				rts
.a106					IFT_ReadLine:
.a106	48		pha				pha
.a107					_IFT_RLLoop:
.a107	20 ed a0	jsr $a0ed			jsr 	IFT_GetKeyCursor 			; get keystroke
.a10a	c9 0d		cmp #$0d			cmp 	#13							; return
.a10c	f0 7d		beq $a18b			beq 	_IFT_RLExit
.a10e	c9 20		cmp #$20			cmp 	#32 						; control character
.a110	90 05		bcc $a117			bcc 	_IFT_Control
.a112	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.a115	80 f0		bra $a107			bra 	_IFT_RLLoop
.a117					_IFT_Control:
.a117	c9 01		cmp #$01			cmp 	#"A"-64
.a119	f0 26		beq $a141			beq 	_IFT_Left
.a11b	c9 04		cmp #$04			cmp 	#"D"-64
.a11d	f0 2e		beq $a14d			beq 	_IFT_Right
.a11f	c9 17		cmp #$17			cmp 	#"W"-64
.a121	f0 36		beq $a159			beq 	_IFT_Up
.a123	c9 13		cmp #$13			cmp 	#"S"-64
.a125	f0 3e		beq $a165			beq 	_IFT_Down
.a127	c9 08		cmp #$08			cmp 	#"H"-64
.a129	f0 09		beq $a134			beq 	_IFT_Backspace
.a12b	c9 1a		cmp #$1a			cmp 	#"Z"-64
.a12d	d0 d8		bne $a107			bne 	_IFT_RLLoop
.a12f	20 0c a0	jsr $a00c			jsr 	IFT_ClearScreen				; clear CTL-Z
.a132	80 d3		bra $a107			bra 	_IFT_RLLoop
.a134					_IFT_Backspace:
.a134	ad bd 03	lda $03bd			lda 	IFT_XCursor 				; check not start of line.
.a137	f0 ce		beq $a107			beq 	_IFT_RLLoop
.a139	20 ee a1	jsr $a1ee			jsr 	IF_LeftOne
.a13c	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.a13e	20 e3 a1	jsr $a1e3			jsr 	IF_Write
.a141					_IFT_Left:
.a141	ce bd 03	dec $03bd			dec 	IFT_XCursor 				; left CTL-W
.a144	10 29		bpl $a16f			bpl 	_IFT_Reposition
.a146	a9 4f		lda #$4f			lda 	#IF_Width-1
.a148					_IFT_SetX:
.a148	8d bd 03	sta $03bd			sta 	IFT_XCursor
.a14b	80 22		bra $a16f			bra 	_IFT_Reposition
.a14d					_IFT_Right:
.a14d	ee bd 03	inc $03bd			inc 	IFT_XCursor
.a150	ad bd 03	lda $03bd			lda 	IFT_XCursor
.a153	49 50		eor #$50			eor 	#IF_Width
.a155	f0 f1		beq $a148			beq 	_IFT_SetX
.a157	80 16		bra $a16f			bra 	_IFT_Reposition
.a159					_IFT_Up:
.a159	ce be 03	dec $03be			dec 	IFT_YCursor
.a15c	10 11		bpl $a16f			bpl 	_IFT_Reposition
.a15e	a9 18		lda #$18			lda 	#IF_Height-1
.a160					_IFT_SetY:
.a160	8d be 03	sta $03be			sta 	IFT_YCursor
.a163	80 0a		bra $a16f			bra 	_IFT_Reposition
.a165					_IFT_Down:
.a165	ee be 03	inc $03be			inc 	IFT_YCursor
.a168	ad be 03	lda $03be			lda 	IFT_YCursor
.a16b	49 19		eor #$19			eor 	#IF_Height
.a16d	f0 f1		beq $a160			beq 	_IFT_SetY
.a16f					_IFT_Reposition:
.a16f	ad bd 03	lda $03bd			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.a172	48		pha				pha
.a173	ad be 03	lda $03be			lda 	IFT_YCursor
.a176	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a179	68		pla				pla
.a17a	aa		tax				tax
.a17b	e0 00		cpx #$00			cpx 	#0
.a17d	f0 88		beq $a107			beq 	_IFT_RLLoop
.a17f					_IFT_MoveRight:
.a17f	20 d5 a1	jsr $a1d5			jsr 	IF_Read
.a182	ee bd 03	inc $03bd			inc 	IFT_XCursor
.a185	ca		dex				dex
.a186	d0 f7		bne $a17f			bne 	_IFT_MoveRight
.a188	4c 07 a1	jmp $a107			jmp 	_IFT_RLLoop
.a18b					_IFT_RLExit:
.a18b	ad be 03	lda $03be			lda 	IFT_YCursor 				; go to start of line.
.a18e	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a191	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.a193					_IFT_RLRead:
.a193	20 d5 a1	jsr $a1d5			jsr 	IF_Read
.a196	9d 23 04	sta $0423,x			sta 	IFT_LineBuffer,x
.a199	e8		inx				inx
.a19a	e0 50		cpx #$50			cpx 	#IF_Width
.a19c	d0 f5		bne $a193			bne 	_IFT_RLRead
.a19e					_IFT_RL_Trim:
.a19e	ca		dex				dex 	 							; previous char
.a19f	30 07		bmi $a1a8			bmi 	_IFT_Found 					; gone too far
.a1a1	bd 23 04	lda $0423,x			lda 	IFT_LineBuffer,x			; go back if space
.a1a4	c9 20		cmp #$20			cmp 	#" "
.a1a6	f0 f6		beq $a19e			beq 	_IFT_RL_Trim
.a1a8					_IFT_Found:
.a1a8	e8		inx				inx 								; forward to non-space
.a1a9	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.a1ab	9d 23 04	sta $0423,x			sta 	IFT_LineBuffer,x
.a1ae	68		pla				pla
.a1af	a2 23		ldx #$23			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.a1b1	a0 04		ldy #$04			ldy 	#IFT_LineBuffer >> 8
.a1b3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_mega65.asm

=80					IF_Width 	= 80 							; characters across
=25					IF_Height 	= 25 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line
=6					IF_XPos 	= 6 							; current position, horizontal.
=8					IF_FarPtr 	= 8 							; far pointer (4 bytes)
=$1000					IF_Screen = $1000							; 2k screen RAM here
=$800					IF_CharSet = $800							; 2k character set (0-7F) here
.a1b4					IF_Home:
.a1b4	48		pha				pha 								; reset cursor position
.a1b5	a9 00		lda #$00			lda 	#IF_Screen & $FF
.a1b7	85 04		sta $04				sta 	IF_Pos
.a1b9	a9 10		lda #$10			lda 	#IF_Screen >> 8
.a1bb	85 05		sta $05				sta 	IF_Pos+1
.a1bd	a9 00		lda #$00			lda 	#0
.a1bf	85 06		sta $06				sta 	IF_XPos
.a1c1	68		pla				pla
.a1c2	60		rts				rts
.a1c3					IF_NewLine:
.a1c3	48		pha				pha
.a1c4	a9 00		lda #$00			lda 	#0 							; back to start of line
.a1c6	85 06		sta $06				sta 	IF_XPos
.a1c8	18		clc				clc 								; down one line
.a1c9	a5 04		lda $04				lda 	IF_Pos
.a1cb	69 50		adc #$50			adc 	#80
.a1cd	85 04		sta $04				sta 	IF_Pos
.a1cf	90 02		bcc $a1d3			bcc 	_IF_NoCarry 				; carry through.
.a1d1	e6 05		inc $05				inc 	IF_Pos+1
.a1d3					_IF_NoCarry:
.a1d3	68		pla				pla
.a1d4	60		rts				rts
.a1d5					IF_Read:
.a1d5	5a		phy				phy 								; save current Y
.a1d6	a4 06		ldy $06				ldy 	IF_XPos 					; read character at current position
.a1d8	b1 04		lda ($04),y			lda 	(IF_Pos),y
.a1da	49 20		eor #$20			eor 	#$20
.a1dc	18		clc				clc
.a1dd	69 20		adc #$20			adc 	#$20
.a1df	e6 06		inc $06				inc 	IF_XPos 					; step right.
.a1e1	7a		ply				ply									; restore Y
.a1e2	60		rts				rts
.a1e3					IF_Write:
.a1e3	5a		phy				phy 								; save current Y
.a1e4	a4 06		ldy $06				ldy 	IF_XPos 					; write character at current position
.a1e6	29 bf		and #$bf			and 	#63+128 					; PETSCII
.a1e8	91 04		sta ($04),y			sta 	(IF_Pos),y
.a1ea	e6 06		inc $06				inc 	IF_XPos 					; step right.
.a1ec	7a		ply				ply									; restore Y
.a1ed	60		rts				rts
.a1ee					IF_LeftOne:
.a1ee	c6 06		dec $06				dec 	IF_XPos
.a1f0	60		rts				rts
.a1f1					IF_CheckBreak:
.a1f1	db		phz				phz
.a1f2	20 3a a2	jsr $a23a			jsr 	IF_SetupKeyAddress 			; point to keyboard
.a1f5	e6 08		inc $08				inc 	IF_FarPtr 					; point to modifiers.
.a1f7	ea		nop				nop 								; read modifiers.
.a1f8	b2 08		lda ($08),z			lda 	(IF_FarPtr),z
.a1fa	fb		plz				plz 								; restore Z
.a1fb	29 05		and #$05			and 	#5							; break is LeftShift+Ctrl
.a1fd	c9 05		cmp #$05			cmp 	#5
.a1ff	f0 02		beq $a203			beq 	_IF_CBExit
.a201	a9 00		lda #$00			lda 	#0
.a203					_IF_CBExit:
.a203	c9 00		cmp #$00			cmp 	#0
.a205	60		rts				rts
.a206					IF_GetKey:
.a206	db		phz				phz
.a207	20 3a a2	jsr $a23a			jsr 	IF_SetupKeyAddress
.a20a	ea		nop				nop 								; read keyboard
.a20b	b2 08		lda ($08),z			lda 	(IF_FarPtr),z
.a20d	c9 14		cmp #$14			cmp 	#20
.a20f	d0 02		bne $a213			bne 	_KMNo
.a211	a9 08		lda #$08			lda 	#"H"-64
.a213					_KMNo:
.a213	c9 91		cmp #$91			cmp 	#145
.a215	d0 02		bne $a219			bne 	_KMNo
.a217	a9 17		lda #$17			lda 	#"W"-64
.a219					_KMNo:
.a219	c9 11		cmp #$11			cmp 	#17
.a21b	d0 02		bne $a21f			bne 	_KMNo
.a21d	a9 13		lda #$13			lda 	#"S"-64
.a21f					_KMNo:
.a21f	c9 9d		cmp #$9d			cmp 	#157
.a221	d0 02		bne $a225			bne 	_KMNo
.a223	a9 01		lda #$01			lda 	#"A"-64
.a225					_KMNo:
.a225	c9 1d		cmp #$1d			cmp 	#29
.a227	d0 02		bne $a22b			bne 	_KMNo
.a229	a9 04		lda #$04			lda 	#"D"-64
.a22b					_KMNo:
.a22b	c9 00		cmp #$00			cmp 	#0
.a22d	f0 07		beq $a236			beq 	_IFGKEmpty
.a22f	48		pha				pha
.a230	a9 00		lda #$00			lda 	#0
.a232	ea		nop				nop
.a233	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a235	68		pla				pla
.a236					_IFGKEmpty:
.a236	fb		plz				plz
.a237	c9 00		cmp #$00			cmp 	#0 							; set Z
.a239	60		rts				rts
.a23a					IF_SetupKeyAddress:
.a23a	a9 0f		lda #$0f			lda 	#$0F 						; set up to write to read keyboard.
.a23c	85 0b		sta $0b				sta 	IF_FarPtr+3
.a23e	a9 fd		lda #$fd			lda 	#$FD
.a240	85 0a		sta $0a				sta 	IF_FarPtr+2
.a242	a9 36		lda #$36			lda 	#$36
.a244	85 09		sta $09				sta 	IF_FarPtr+1
.a246	a9 10		lda #$10			lda 	#$10
.a248	85 08		sta $08				sta 	IF_FarPtr+0
.a24a	a3 00		ldz #$00			ldz 	#0
.a24c	60		rts				rts
.a24d					IF_Reset:
.a24d	48		pha				pha 								; save registers
.a24e	da		phx				phx
.a24f	5a		phy				phy
.a250	a9 0f		lda #$0f			lda 	#$0F 						; set up to write to video system.
.a252	85 0b		sta $0b				sta 	IF_FarPtr+3
.a254	a9 fd		lda #$fd			lda 	#$FD
.a256	85 0a		sta $0a				sta 	IF_FarPtr+2
.a258	a9 30		lda #$30			lda 	#$30
.a25a	85 09		sta $09				sta 	IF_FarPtr+1
.a25c	a9 00		lda #$00			lda 	#$00
.a25e	85 08		sta $08				sta 	IF_FarPtr+0
.a260	a3 2f		ldz #$2f			ldz 	#$2F 						; address already set up
.a262	a9 47		lda #$47			lda 	#$47
.a264	ea		nop				nop
.a265	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a267	a3 2f		ldz #$2f			ldz 	#$2F 						; address already set up
.a269	a9 53		lda #$53			lda 	#$53
.a26b	ea		nop				nop
.a26c	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a26e	a3 30		ldz #$30			ldz 	#$30 						; address already set up
.a270	a9 40		lda #$40			lda 	#$40
.a272	ea		nop				nop
.a273	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a275	a3 31		ldz #$31			ldz 	#$31 						; address already set up
.a277	a9 c0		lda #$c0			lda 	#$80+$40
.a279	ea		nop				nop
.a27a	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a27c	a3 20		ldz #$20			ldz 	#$20 						; address already set up
.a27e	a9 00		lda #$00			lda 	#0
.a280	ea		nop				nop
.a281	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a283	a3 21		ldz #$21			ldz 	#$21 						; address already set up
.a285	a9 00		lda #$00			lda 	#0
.a287	ea		nop				nop
.a288	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a28a	a3 54		ldz #$54			ldz 	#$54 						; address already set up
.a28c	a9 40		lda #$40			lda 	#$40
.a28e	ea		nop				nop
.a28f	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a291	a3 01		ldz #$01			ldz 	#$01 						; address already set up
.a293	a9 ff		lda #$ff			lda 	#$FF
.a295	ea		nop				nop
.a296	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a298	a3 00		ldz #$00			ldz 	#$00 						; address already set up
.a29a	a9 ff		lda #$ff			lda 	#$FF
.a29c	ea		nop				nop
.a29d	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a29f	a3 16		ldz #$16			ldz 	#$16 						; address already set up
.a2a1	a9 cc		lda #$cc			lda 	#$CC
.a2a3	ea		nop				nop
.a2a4	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2a6	a3 18		ldz #$18			ldz 	#$18 						; address already set up
.a2a8	a9 42		lda #$42			lda 	#$42
.a2aa	ea		nop				nop
.a2ab	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2ad	a3 11		ldz #$11			ldz 	#$11 						; address already set up
.a2af	a9 1b		lda #$1b			lda 	#$1B
.a2b1	ea		nop				nop
.a2b2	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2b4	a9 00		lda #$00			lda 	#$00						; colour RAM at $1F800-1FFFF (2kb)
.a2b6	85 0b		sta $0b				sta 	IF_FarPtr+3
.a2b8	a9 01		lda #$01			lda 	#$01
.a2ba	85 0a		sta $0a				sta 	IF_FarPtr+2
.a2bc	a9 f8		lda #$f8			lda 	#$F8
.a2be	85 09		sta $09				sta 	IF_FarPtr+1
.a2c0	a9 00		lda #$00			lda 	#$00
.a2c2	85 08		sta $08				sta 	IF_FarPtr+0
.a2c4	a3 00		ldz #$00			ldz 	#0
.a2c6					_EXTClearColorRam:
.a2c6	a9 05		lda #$05			lda 	#5							; fill that with this colour.
.a2c8	ea		nop				nop
.a2c9	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2cb	3b		dez				dez
.a2cc	d0 f8		bne $a2c6			bne 	_EXTClearColorRam
.a2ce	e6 09		inc $09				inc 	IF_FarPtr+1
.a2d0	d0 f4		bne $a2c6			bne 	_EXTClearColorRam
.a2d2	a2 00		ldx #$00			ldx 	#0 							; copy PET Font into memory.
.a2d4					_EXTCopyCBMFont:
.a2d4	bd 15 a3	lda $a315,x			lda 	IF_CBMFont,x 				; +$800 uses the lower case c/set
.a2d7	9d 00 08	sta $0800,x			sta 	IF_CharSet,x
.a2da	49 ff		eor #$ff			eor 	#$FF
.a2dc	9d 00 0c	sta $0c00,x			sta 	IF_CharSet+$400,x
.a2df	bd 15 a4	lda $a415,x			lda 	IF_CBMFont+$100,x
.a2e2	9d 00 09	sta $0900,x			sta 	IF_CharSet+$100,x
.a2e5	49 ff		eor #$ff			eor 	#$FF
.a2e7	9d 00 0d	sta $0d00,x			sta 	IF_CharSet+$500,x
.a2ea	bd 15 a5	lda $a515,x			lda 	IF_CBMFont+$200,x
.a2ed	9d 00 0a	sta $0a00,x			sta 	IF_CharSet+$200,x
.a2f0	49 ff		eor #$ff			eor 	#$FF
.a2f2	9d 00 0e	sta $0e00,x			sta 	IF_CharSet+$600,x
.a2f5	bd 15 a6	lda $a615,x			lda 	IF_CBMFont+$300,x
.a2f8	9d 00 0b	sta $0b00,x			sta 	IF_CharSet+$300,x
.a2fb	49 ff		eor #$ff			eor 	#$FF
.a2fd	9d 00 0f	sta $0f00,x			sta 	IF_CharSet+$700,x
.a300	ca		dex				dex
.a301	d0 d1		bne $a2d4			bne 	_EXTCopyCBMFont
.a303	a9 3b		lda #$3b			lda 	#$3F-4  					; puts ROM back in the map (the -4)
.a305	85 01		sta $01				sta 	$01
.a307	a9 00		lda #$00			lda 	#$00						; do not map bytes 0000-7FFF
.a309	a2 00		ldx #$00			ldx 	#$00						; (so we use the RAM physically at $0000-$7FFF)
.a30b	a0 00		ldy #$00			ldy 	#$00 						; 8000-FFFF offset by $200. The lower 8 bits are $00
.a30d	a3 f2		ldz #$f2			ldz 	#$F2 						; so this is an actual offset of $20000. So the space at
.a30f	5c		map				map
.a310	ea		nop				eom
.a311	7a		ply				ply 								; restore and exit.
.a312	fa		plx				plx
.a313	68		pla				pla
.a314	60		rts				rts
.a315					IF_CBMFont:
>a315	1c 22 4a 56 4c 20 1e 00				.binary "pet-font.bin"
>a31d	18 24 42 7e 42 42 42 00 7c 22 22 3c 22 22 7c 00
>a32d	1c 22 40 40 40 22 1c 00 78 24 22 22 22 24 78 00
>a33d	7e 40 40 78 40 40 7e 00 7e 40 40 78 40 40 40 00
>a34d	1c 22 40 4e 42 22 1c 00 42 42 42 7e 42 42 42 00
>a35d	1c 08 08 08 08 08 1c 00 0e 04 04 04 04 44 38 00
>a36d	42 44 48 70 48 44 42 00 40 40 40 40 40 40 7e 00
>a37d	42 66 5a 5a 42 42 42 00 42 62 52 4a 46 42 42 00
>a38d	18 24 42 42 42 24 18 00 7c 42 42 7c 40 40 40 00
>a39d	18 24 42 42 4a 24 1a 00 7c 42 42 7c 48 44 42 00
>a3ad	3c 42 40 3c 02 42 3c 00 3e 08 08 08 08 08 08 00
>a3bd	42 42 42 42 42 42 3c 00 42 42 42 24 24 18 18 00
>a3cd	42 42 42 5a 5a 66 42 00 42 42 24 18 24 42 42 00
>a3dd	22 22 22 1c 08 08 08 00 7e 02 04 18 20 40 7e 00
>a3ed	3c 20 20 20 20 20 3c 00 00 40 20 10 08 04 02 00
>a3fd	3c 04 04 04 04 04 3c 00 00 08 1c 2a 08 08 08 08
>a40d	00 00 10 20 7f 20 10 00 00 00 00 00 00 00 00 00
>a41d	08 08 08 08 00 00 08 00 24 24 24 00 00 00 00 00
>a42d	24 24 7e 24 7e 24 24 00 08 1e 28 1c 0a 3c 08 00
>a43d	00 62 64 08 10 26 46 00 30 48 48 30 4a 44 3a 00
>a44d	04 08 10 00 00 00 00 00 04 08 10 10 10 08 04 00
>a45d	20 10 08 08 08 10 20 00 08 2a 1c 3e 1c 2a 08 00
>a46d	00 08 08 3e 08 08 00 00 00 00 00 00 00 08 08 10
>a47d	00 00 00 7e 00 00 00 00 00 00 00 00 00 18 18 00
>a48d	00 02 04 08 10 20 40 00 3c 42 46 5a 62 42 3c 00
>a49d	08 18 28 08 08 08 3e 00 3c 42 02 0c 30 40 7e 00
>a4ad	3c 42 02 1c 02 42 3c 00 04 0c 14 24 7e 04 04 00
>a4bd	7e 40 78 04 02 44 38 00 1c 20 40 7c 42 42 3c 00
>a4cd	7e 42 04 08 10 10 10 00 3c 42 42 3c 42 42 3c 00
>a4dd	3c 42 42 3e 02 04 38 00 00 00 08 00 00 08 00 00
>a4ed	00 00 08 00 00 08 08 10 0e 18 30 60 30 18 0e 00
>a4fd	00 00 7e 00 7e 00 00 00 70 18 0c 06 0c 18 70 00
>a50d	3c 42 02 0c 10 00 10 00 00 00 00 00 ff 00 00 00
>a51d	08 1c 3e 7f 7f 1c 3e 00 10 10 10 10 10 10 10 10
>a52d	00 00 00 ff 00 00 00 00 00 00 ff 00 00 00 00 00
>a53d	00 ff 00 00 00 00 00 00 00 00 00 00 00 ff 00 00
>a54d	20 20 20 20 20 20 20 20 04 04 04 04 04 04 04 04
>a55d	00 00 00 00 e0 10 08 08 08 08 08 04 03 00 00 00
>a56d	08 08 08 10 e0 00 00 00 80 80 80 80 80 80 80 ff
>a57d	80 40 20 10 08 04 02 01 01 02 04 08 10 20 40 80
>a58d	ff 80 80 80 80 80 80 80 ff 01 01 01 01 01 01 01
>a59d	00 3c 7e 7e 7e 7e 3c 00 00 00 00 00 00 00 ff 00
>a5ad	36 7f 7f 7f 3e 1c 08 00 40 40 40 40 40 40 40 40
>a5bd	00 00 00 00 03 04 08 08 81 42 24 18 18 24 42 81
>a5cd	00 3c 42 42 42 42 3c 00 08 1c 2a 77 2a 08 08 00
>a5dd	02 02 02 02 02 02 02 02 08 1c 3e 7f 3e 1c 08 00
>a5ed	08 08 08 08 ff 08 08 08 a0 50 a0 50 a0 50 a0 50
>a5fd	08 08 08 08 08 08 08 08 00 00 01 3e 54 14 14 00
>a60d	ff 7f 3f 1f 0f 07 03 01 00 00 00 00 00 00 00 00
>a61d	f0 f0 f0 f0 f0 f0 f0 f0 00 00 00 00 ff ff ff ff
>a62d	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff
>a63d	80 80 80 80 80 80 80 80 aa 55 aa 55 aa 55 aa 55
>a64d	01 01 01 01 01 01 01 01 00 00 00 00 aa 55 aa 55
>a65d	ff fe fc f8 f0 e0 c0 80 03 03 03 03 03 03 03 03
>a66d	08 08 08 08 0f 08 08 08 00 00 00 00 0f 0f 0f 0f
>a67d	08 08 08 08 0f 00 00 00 00 00 00 00 f8 08 08 08
>a68d	00 00 00 00 00 00 ff ff 00 00 00 00 0f 08 08 08
>a69d	08 08 08 08 ff 00 00 00 00 00 00 00 ff 08 08 08
>a6ad	08 08 08 08 f8 08 08 08 c0 c0 c0 c0 c0 c0 c0 c0
>a6bd	e0 e0 e0 e0 e0 e0 e0 e0 07 07 07 07 07 07 07 07
>a6cd	ff ff 00 00 00 00 00 00 ff ff ff 00 00 00 00 00
>a6dd	00 00 00 00 00 ff ff ff 01 01 01 01 01 01 01 ff
>a6ed	00 00 00 00 f0 f0 f0 f0 0f 0f 0f 0f 00 00 00 00
>a6fd	08 08 08 08 f8 00 00 00 f0 f0 f0 f0 00 00 00 00
>a70d	f0 f0 f0 f0 0f 0f 0f 0f 1c 22 4a 56 4c 20 1e 00
>a71d	18 24 42 7e 42 42 42 00 7c 22 22 3c 22 22 7c 00
>a72d	1c 22 40 40 40 22 1c 00 78 24 22 22 22 24 78 00
>a73d	7e 40 40 78 40 40 7e 00 7e 40 40 78 40 40 40 00
>a74d	1c 22 40 4e 42 22 1c 00 42 42 42 7e 42 42 42 00
>a75d	1c 08 08 08 08 08 1c 00 0e 04 04 04 04 44 38 00
>a76d	42 44 48 70 48 44 42 00 40 40 40 40 40 40 7e 00
>a77d	42 66 5a 5a 42 42 42 00 42 62 52 4a 46 42 42 00
>a78d	18 24 42 42 42 24 18 00 7c 42 42 7c 40 40 40 00
>a79d	18 24 42 42 4a 24 1a 00 7c 42 42 7c 48 44 42 00
>a7ad	3c 42 40 3c 02 42 3c 00 3e 08 08 08 08 08 08 00
>a7bd	42 42 42 42 42 42 3c 00 42 42 42 24 24 18 18 00
>a7cd	42 42 42 5a 5a 66 42 00 42 42 24 18 24 42 42 00
>a7dd	22 22 22 1c 08 08 08 00 7e 02 04 18 20 40 7e 00
>a7ed	3c 20 20 20 20 20 3c 00 00 40 20 10 08 04 02 00
>a7fd	3c 04 04 04 04 04 3c 00 00 08 1c 2a 08 08 08 08
>a80d	00 00 10 20 7f 20 10 00 00 00 00 00 00 00 00 00
>a81d	08 08 08 08 00 00 08 00 24 24 24 00 00 00 00 00
>a82d	24 24 7e 24 7e 24 24 00 08 1e 28 1c 0a 3c 08 00
>a83d	00 62 64 08 10 26 46 00 30 48 48 30 4a 44 3a 00
>a84d	04 08 10 00 00 00 00 00 04 08 10 10 10 08 04 00
>a85d	20 10 08 08 08 10 20 00 08 2a 1c 3e 1c 2a 08 00
>a86d	00 08 08 3e 08 08 00 00 00 00 00 00 00 08 08 10
>a87d	00 00 00 7e 00 00 00 00 00 00 00 00 00 18 18 00
>a88d	00 02 04 08 10 20 40 00 3c 42 46 5a 62 42 3c 00
>a89d	08 18 28 08 08 08 3e 00 3c 42 02 0c 30 40 7e 00
>a8ad	3c 42 02 1c 02 42 3c 00 04 0c 14 24 7e 04 04 00
>a8bd	7e 40 78 04 02 44 38 00 1c 20 40 7c 42 42 3c 00
>a8cd	7e 42 04 08 10 10 10 00 3c 42 42 3c 42 42 3c 00
>a8dd	3c 42 42 3e 02 04 38 00 00 00 08 00 00 08 00 00
>a8ed	00 00 08 00 00 08 08 10 0e 18 30 60 30 18 0e 00
>a8fd	00 00 7e 00 7e 00 00 00 70 18 0c 06 0c 18 70 00
>a90d	3c 42 02 0c 10 00 10 00 00 00 00 00 ff 00 00 00
>a91d	00 00 38 04 3c 44 3a 00 40 40 5c 62 42 62 5c 00
>a92d	00 00 3c 42 40 42 3c 00 02 02 3a 46 42 46 3a 00
>a93d	00 00 3c 42 7e 40 3c 00 0c 12 10 7c 10 10 10 00
>a94d	00 00 3a 46 46 3a 02 3c 40 40 5c 62 42 42 42 00
>a95d	08 00 18 08 08 08 1c 00 04 00 0c 04 04 04 44 38
>a96d	40 40 44 48 50 68 44 00 18 08 08 08 08 08 1c 00
>a97d	00 00 76 49 49 49 49 00 00 00 5c 62 42 42 42 00
>a98d	00 00 3c 42 42 42 3c 00 00 00 5c 62 62 5c 40 40
>a99d	00 00 3a 46 46 3a 02 02 00 00 5c 62 40 40 40 00
>a9ad	00 00 3e 40 3c 02 7c 00 10 10 7c 10 10 12 0c 00
>a9bd	00 00 42 42 42 46 3a 00 00 00 42 42 42 24 18 00
>a9cd	00 00 41 49 49 49 36 00 00 00 42 24 18 24 42 00
>a9dd	00 00 42 42 46 3a 02 3c 00 00 7e 04 18 20 7e 00
>a9ed	08 08 08 08 ff 08 08 08 a0 50 a0 50 a0 50 a0 50
>a9fd	08 08 08 08 08 08 08 08 cc cc 33 33 cc cc 33 33
>aa0d	cc 66 33 99 cc 66 33 99 00 00 00 00 00 00 00 00
>aa1d	f0 f0 f0 f0 f0 f0 f0 f0 00 00 00 00 ff ff ff ff
>aa2d	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff
>aa3d	80 80 80 80 80 80 80 80 aa 55 aa 55 aa 55 aa 55
>aa4d	01 01 01 01 01 01 01 01 00 00 00 00 aa 55 aa 55
>aa5d	99 33 66 cc 99 33 66 cc 03 03 03 03 03 03 03 03
>aa6d	08 08 08 08 0f 08 08 08 00 00 00 00 0f 0f 0f 0f
>aa7d	08 08 08 08 0f 00 00 00 00 00 00 00 f8 08 08 08
>aa8d	00 00 00 00 00 00 ff ff 00 00 00 00 0f 08 08 08
>aa9d	08 08 08 08 ff 00 00 00 00 00 00 00 ff 08 08 08
>aaad	08 08 08 08 f8 08 08 08 c0 c0 c0 c0 c0 c0 c0 c0
>aabd	e0 e0 e0 e0 e0 e0 e0 e0 07 07 07 07 07 07 07 07
>aacd	ff ff 00 00 00 00 00 00 ff ff ff 00 00 00 00 00
>aadd	00 00 00 00 00 ff ff ff 01 02 44 48 50 60 40 00
>aaed	00 00 00 00 f0 f0 f0 f0 0f 0f 0f 0f 00 00 00 00
>aafd	08 08 08 08 f8 00 00 00 f0 f0 f0 f0 00 00 00 00
>ab0d	f0 f0 f0 f0 0f 0f 0f 0f

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.ab15					TIM_Error:
.ab15	20 35 a0	jsr $a035			jsr 	IFT_UpLine 					; go up one line.
.ab18	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.ab1a	80 02		bra $ab1e			bra 	TIM_ShowPrompt
.ab1c					TIM_NewCommand:
.ab1c	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.ab1e					TIM_ShowPrompt:
.ab1e	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.ab21	20 06 a1	jsr $a106			jsr 	IFT_ReadLine	 			; get character, go to next line
.ab24	20 68 a0	jsr $a068			jsr 	IFT_NewLine					; go to next line.
.ab27	86 10		stx $10				stx 	zTemp1 						; save line read address
.ab29	84 11		sty $11				sty 	zTemp1+1
.ab2b	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.ab2d	b1 10		lda ($10),y			lda 	(zTemp1),y
.ab2f	c9 3f		cmp #$3f			cmp 	#"?"
.ab31	f0 04		beq $ab37			beq 	TIM_SkipFirst
.ab33	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.ab35	d0 01		bne $ab38			bne 	TIM_NotDot
.ab37					TIM_SkipFirst:
.ab37	c8		iny				iny
.ab38					TIM_NotDot:
.ab38	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.ab3a	c9 52		cmp #$52			cmp 	#"R"						; show registers
.ab3c	f0 6e		beq $abac			beq 	TIM_ShowRegisters
.ab3e	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.ab40	f0 12		beq $ab54			beq 	TIM_ShowMemory
.ab42	c9 47		cmp #$47			cmp 	#"G"						; execute
.ab44	f0 49		beq $ab8f			beq 	TIM_Execute
.ab46	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.ab48	f0 07		beq $ab51			beq 	TIM_GoLoadMemory
.ab4a	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.ab4c	d0 c7		bne $ab15			bne 	TIM_Error
.ab4e	4c d1 ac	jmp $acd1			jmp 	TIM_UpdateRegisters
.ab51					TIM_GoLoadMemory:
.ab51	4c fc ac	jmp $acfc			jmp 	TIM_LoadMemory
.ab54					TIM_ShowMemory:
.ab54	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.ab57	b0 bc		bcs $ab15			bcs 	TIM_Error
.ab59	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.ab5b	85 12		sta $12				sta 	zTemp2
.ab5d	a5 15		lda $15				lda 	zTemp3+1
.ab5f	85 13		sta $13				sta 	zTemp2+1
.ab61	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.ab64	90 08		bcc $ab6e			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.ab66	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.ab68	85 14		sta $14				sta 	zTemp3
.ab6a	a5 13		lda $13				lda 	zTemp2+1
.ab6c	85 15		sta $15				sta 	zTemp3+1
.ab6e					_TIMSM_Start:
.ab6e	20 22 ac	jsr $ac22			jsr 	TIM_WriteLine 				; write one line of hex out
.ab71	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.ab73	18		clc				clc
.ab74	69 10		adc #$10			adc 	#16
.ab76	85 12		sta $12				sta 	zTemp2
.ab78	90 02		bcc $ab7c			bcc 	_TIMSM_NoCarry
.ab7a	e6 13		inc $13				inc 	zTemp2+1
.ab7c					_TIMSM_NoCarry:
.ab7c	20 f1 a1	jsr $a1f1			jsr 	IF_CheckBreak 				; check CTL+C
.ab7f	d0 0b		bne $ab8c			bne 	_TIMSM_Ends 				; if pressed break out.
.ab81	38		sec				sec 								; check past the end address in zTemp3
.ab82	a5 14		lda $14				lda 	zTemp3
.ab84	e5 12		sbc $12				sbc 	zTemp2
.ab86	a5 15		lda $15				lda 	zTemp3+1
.ab88	e5 13		sbc $13				sbc 	zTemp2+1
.ab8a	10 e2		bpl $ab6e			bpl 	_TIMSM_Start
.ab8c					_TIMSM_Ends:
.ab8c	4c 1c ab	jmp $ab1c			jmp 	TIM_NewCommand
.ab8f					TIM_Execute:
.ab8f	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; get the execute address
.ab92	b0 81		bcs $ab15			bcs 	TIM_Error 					; not legitimate
.ab94	ae bb 03	ldx $03bb			ldx 	TIM_SP 						; set up SP
.ab97	9a		txs				txs
.ab98	ad b6 03	lda $03b6			lda 	TIM_SR 						; Status for PLP
.ab9b	48		pha				pha
.ab9c	ad b7 03	lda $03b7			lda 	TIM_A 						; restore AXYZ
.ab9f	ae b8 03	ldx $03b8			ldx 	TIM_X
.aba2	ac b9 03	ldy $03b9			ldy 	TIM_Y
.aba5	ab ba 03	ldz $03ba			ldz 	TIM_Z
.aba8	28		plp				plp 								; and PS Byte.
.aba9	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.abac					TIM_Start:
.abac					TIM_ShowRegisters:
.abac	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.abaf	8d b5 03	sta $03b5			sta 	TIM_IRQ+1
.abb2	ad ff ff	lda $ffff			lda 	$FFFF
.abb5	8d b4 03	sta $03b4			sta 	TIM_IRQ
.abb8	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.abba					_TIMSR_Text:
.abba	bd e6 ab	lda $abe6,x			lda 	_TIMSR_Label,x
.abbd	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.abc0	e8		inx				inx
.abc1	e0 23		cpx #$23			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.abc3	d0 f5		bne $abba			bne 	_TIMSR_Text
.abc5	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.abc7					_TIMSR_Skip:
.abc7	e8		inx				inx
.abc8					_TIMSR_LoopSpace:
.abc8	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.abca	b0 04		bcs $abd0			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.abcc	8a		txa				txa
.abcd	4a		lsr a				lsr 	a
.abce	b0 05		bcs $abd5			bcs 	_TIMSR_NoSpace
.abd0					_TIMSR_Space:
.abd0	a9 20		lda #$20			lda 	#" "
.abd2	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.abd5					_TIMSR_NoSpace:
.abd5	bd b2 03	lda $03b2,x			lda 	TIM_PC,x 					; output hex value.
.abd8	20 09 ac	jsr $ac09			jsr 	TIM_WriteHex
.abdb	e8		inx				inx
.abdc	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.abde	d0 e8		bne $abc8			bne 	_TimSR_LoopSpace
.abe0	20 68 a0	jsr $a068			jsr 	IFT_NewLine 				; new line
.abe3	4c 1c ab	jmp $ab1c			jmp	 	TIM_NewCommand 				; new command.
.abe6					_TIMSR_Label:
>abe6	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>abee	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>abfe	52
>abff	20 5a 52					.text 	" ZR"
>ac02	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.ac09					_TIMSR_LabelEnd:
.ac09					TIM_WriteHex:
.ac09	48		pha				pha 								; save A
.ac0a	4a		lsr a				lsr 	a 							; shift MSB->LSB
.ac0b	4a		lsr a				lsr 	a
.ac0c	4a		lsr a				lsr 	a
.ac0d	4a		lsr a				lsr 	a
.ac0e	20 12 ac	jsr $ac12			jsr 	_TIMWH_Nibble 				; print MSB
.ac11	68		pla				pla 								; restore and print LSB
.ac12					_TIMWH_Nibble:
.ac12	48		pha				pha
.ac13	29 0f		and #$0f			and 	#15 						; mask out
.ac15	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.ac17	90 02		bcc $ac1b			bcc 	_TIMWHNoLetter
.ac19	69 06		adc #$06			adc 	#6
.ac1b					_TIMWHNoLetter:
.ac1b	69 30		adc #$30			adc 	#48
.ac1d	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter 			; print it out.
.ac20	68		pla				pla
.ac21	60		rts				rts
.ac22					TIM_WriteLine:
.ac22	a9 2e		lda #$2e			lda 	#"." 						; prompt
.ac24	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.ac27	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.ac29	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.ac2c	a5 13		lda $13				lda 	zTemp2+1 					; write address
.ac2e	20 09 ac	jsr $ac09			jsr 	TIM_WriteHex
.ac31	a5 12		lda $12				lda 	zTemp2
.ac33	20 09 ac	jsr $ac09			jsr 	TIM_WriteHex
.ac36	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.ac38					_TIMWL_Loop:
.ac38	a9 20		lda #$20			lda 	#" "
.ac3a	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.ac3d	b1 12		lda ($12),y			lda 	(zTemp2),y
.ac3f	20 09 ac	jsr $ac09			jsr 	TIM_WriteHex
.ac42	c8		iny				iny
.ac43	c0 10		cpy #$10			cpy 	#16
.ac45	d0 f1		bne $ac38			bne 	_TIMWL_Loop
.ac47	4c 68 a0	jmp $a068			jmp 	IFT_NewLine 				; new line and exit
.ac4a					TIM_GetHex:
.ac4a	c8		iny				iny
.ac4b	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.ac4d	c9 20		cmp #$20			cmp 	#32
.ac4f	f0 f9		beq $ac4a			beq 	TIM_GetHex
.ac51	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.ac53	f0 f5		beq $ac4a			beq 	TIM_GetHex
.ac55	20 7e ac	jsr $ac7e			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.ac58	b0 23		bcs $ac7d			bcs 	_TIMGH_Exit					; if first bad then exit now.
.ac5a	a9 00		lda #$00			lda 	#0 							; zero result
.ac5c	85 14		sta $14				sta 	zTemp3
.ac5e	85 15		sta $15				sta 	zTemp3+1
.ac60					_TIM_GHLoop:
.ac60	20 7e ac	jsr $ac7e			jsr 	TIM_GetHexCharacter 		; get next character
.ac63	b0 17		bcs $ac7c			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.ac65	c8		iny				iny 								; skip over it.
.ac66	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.ac68	26 15		rol $15				rol 	zTemp3+1
.ac6a	06 14		asl $14				asl 	zTemp3 						; now x 2
.ac6c	26 15		rol $15				rol 	zTemp3+1
.ac6e	06 14		asl $14				asl 	zTemp3						; now x 4
.ac70	26 15		rol $15				rol 	zTemp3+1
.ac72	06 14		asl $14				asl 	zTemp3 						; now x 8
.ac74	26 15		rol $15				rol 	zTemp3+1
.ac76	05 14		ora $14				ora 	zTemp3 						; OR result in
.ac78	85 14		sta $14				sta 	zTemp3
.ac7a	80 e4		bra $ac60			bra 	_TIM_GHLoop 				; loop round again.
.ac7c					_TIMGH_Okay:
.ac7c	18		clc				clc
.ac7d					_TIMGH_Exit:
.ac7d	60		rts				rts
.ac7e					TIM_GetHexCharacter:
.ac7e	b1 10		lda ($10),y			lda 	(zTemp1),y
.ac80	38		sec				sec
.ac81	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.ac83	90 0e		bcc $ac93			bcc 	_TIM_GHCFail
.ac85	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.ac87	90 0b		bcc $ac94			bcc 	_TIM_GHCExit
.ac89	c9 11		cmp #$11			cmp 	#65-48						; < A
.ac8b	90 06		bcc $ac93			bcc		_TIM_GHCFail
.ac8d	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.ac8f	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.ac91	90 01		bcc $ac94			bcc		_TIM_GHCExit
.ac93					_TIM_GHCFail:
.ac93	38		sec				sec
.ac94					_TIM_GHCExit:
.ac94	60		rts				rts
.ac95					TIM_BreakVector:
.ac95	da		phx				phx									; save X/A on stack
.ac96	48		pha				pha
.ac97	ba		tsx				tsx 								; X points to S
.ac98	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.ac9b	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.ac9d	d0 03		bne $aca2			bne 	_TIMBreak					; if set, it's BRK
.ac9f	68		pla				pla 								; abandon routine.
.aca0	fa		plx				plx
.aca1	40		rti				rti
.aca2					_TIMBreak:
.aca2	68		pla				pla 								; save A X Y and maybe Z
.aca3	8d b7 03	sta $03b7			sta 	TIM_A
.aca6	fa		plx				plx
.aca7	8e b8 03	stx $03b8			stx 	TIM_X
.acaa	8c b9 03	sty $03b9			sty 	TIM_Y
.acad	9c ba 03	stz $03ba			stz 	TIM_Z
.acb0	68		pla				pla 								; get Status Register
.acb1	8d b6 03	sta $03b6			sta 	TIM_SR
.acb4	68		pla				pla
.acb5	8d b3 03	sta $03b3			sta 	TIM_PC+1 					; save calling address
.acb8	68		pla				pla
.acb9	8d b2 03	sta $03b2			sta 	TIM_PC 						; high byte
.acbc	ad b3 03	lda $03b3			lda 	TIM_PC+1 					; dec PC to point right.
.acbf	d0 03		bne $acc4			bne 	_TIMDecrement 				; brk bumps it.
.acc1	ce b2 03	dec $03b2			dec 	TIM_PC
.acc4					_TIMDecrement:
.acc4	ce b3 03	dec $03b3			dec 	TIM_PC+1
.acc7	ba		tsx				tsx 								; and copy SP
.acc8	8e bb 03	stx $03bb			stx 	TIM_SP
.accb	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.accd	9a		txs				txs
.acce	4c ac ab	jmp $abac			jmp 	TIM_Start 					; and start up TIM monitor.
.acd1					TIM_UpdateRegisters:
.acd1	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; PC
.acd4	b0 23		bcs $acf9			bcs 	_TIMURFail
.acd6	a5 14		lda $14				lda 	zTemp3
.acd8	8d b3 03	sta $03b3			sta 	Tim_PC+1
.acdb	a5 15		lda $15				lda 	zTemp3+1
.acdd	8d b2 03	sta $03b2			sta 	Tim_PC
.ace0	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; ignore IRQ
.ace3	b0 14		bcs $acf9			bcs 	_TIMURFail
.ace5	a2 00		ldx #$00			ldx 	#0
.ace7					_TIM_URLoop:
.ace7	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; registers
.acea	b0 0d		bcs $acf9			bcs 	_TIMURFail
.acec	a5 14		lda $14				lda 	zTemp3
.acee	9d b6 03	sta $03b6,x			sta 	Tim_SR,x
.acf1	e8		inx				inx
.acf2	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.acf4	d0 f1		bne $ace7			bne 	_TIM_URLoop
.acf6	4c 1c ab	jmp $ab1c			jmp 	TIM_NewCommand
.acf9					_TIMURFail:
.acf9	4c 15 ab	jmp $ab15			jmp 	TIM_Error
.acfc					TIM_LoadMemory:
.acfc	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; target address => zTemp2
.acff	a5 14		lda $14				lda 	zTemp3
.ad01	85 12		sta $12				sta 	zTemp2
.ad03	a5 15		lda $15				lda 	zTemp3+1
.ad05	85 13		sta $13				sta 	zTemp2+1
.ad07					_TIM_LMLoop:
.ad07	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; next byte ?
.ad0a	b0 0e		bcs $ad1a			bcs 	_TIMLMDone 					; no more
.ad0c	a2 00		ldx #$00			ldx 	#0							; write out.
.ad0e	a5 14		lda $14				lda 	zTemp3
.ad10	81 12		sta ($12,x)			sta 	(zTemp2,x)
.ad12	e6 12		inc $12				inc 	zTemp2 						; bump address
.ad14	d0 f1		bne $ad07			bne 	_TIM_LMLoop
.ad16	e6 13		inc $13				inc 	zTemp2+1
.ad18	80 ed		bra $ad07			bra 	_TIM_LMLoop
.ad1a					_TIMLMDone:
.ad1a	4c 1c ab	jmp $ab1c			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/errors.asm

.ad1d					SyntaxError:
.ad1d	20 4c ad	jsr $ad4c			jsr 	ERR_Handler
>ad20	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>ad28	72 72 6f 72 00
.ad2d					TypeError:
.ad2d	20 4c ad	jsr $ad4c			jsr 	ERR_Handler
>ad30	57 72 6f 6e 67 20 74 79				.text 	"Wrong type",0
>ad38	70 65 00
.ad3b					BadParamError:
.ad3b	20 4c ad	jsr $ad4c			jsr 	ERR_Handler
>ad3e	42 61 64 20 50 61 72 61				.text 	"Bad Parameter",0
>ad46	6d 65 74 65 72 00
.ad4c					ERR_Handler:
.ad4c	a3 00		ldz #$00			ldz 	#0
.ad4e	1b		inz				inz
.ad4f	ea		nop				nop
.ad50	b2 16		lda ($16),z			lda 	(zCodePtr),z
.ad52	85 80		sta $80				sta 	XS_Mantissa
.ad54	1b		inz				inz
.ad55	ea		nop				nop
.ad56	b2 16		lda ($16),z			lda 	(zCodePtr),z
.ad58	85 81		sta $81				sta 	XS_Mantissa+1
.ad5a	fa		plx				plx 								; address in XY
.ad5b	7a		ply				ply
.ad5c	e8		inx				inx 								; bump, because of RTS/JSR address -1
.ad5d	d0 01		bne $ad60			bne 	_EHNoSkip
.ad5f	c8		iny				iny
.ad60					_EHNoSkip:
.ad60	20 7f ad	jsr $ad7f			jsr 	PrintROMMessage 			; print message from ROM.
.ad63	a5 80		lda $80				lda 	XS_Mantissa					; line number = 0
.ad65	05 81		ora $81				ora 	XS_Mantissa+1
.ad67	f0 0c		beq $ad75			beq 	_EHNoLine
.ad69	a2 7a		ldx #$7a			ldx 	#_EHAt & $FF 				; print " at "
.ad6b	a0 ad		ldy #$ad			ldy 	#(_EHAt >> 8) & $FF
.ad6d	20 7f ad	jsr $ad7f			jsr 	PrintROMMessage
.ad70	a2 00		ldx #$00			ldx 	#0 							; Print line number
.ad72	20 90 ad	jsr $ad90			jsr 	Print16BitInteger
.ad75					_EHNoLine:
.ad75	80 fe		bra $ad75			bra 	_EHNoLine
.ad77	4c ec af	jmp $afec			jmp 	WarmStart
>ad7a	20 61 74 20 00			_EHAt:	.text 	" at ",0
.ad7f					PrintROMMessage:
.ad7f	86 1a		stx $1a				stx 	zLTemp1 					; save addres
.ad81	84 1b		sty $1b				sty 	zLTemp1+1
.ad83	a0 00		ldy #$00			ldy 	#0
.ad85					_PRMLoop:
.ad85	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.ad87	f0 06		beq $ad8f			beq		_PRMExit
.ad89	c8		iny				iny
.ad8a	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.ad8d	80 f6		bra $ad85			bra 	_PRMLoop
.ad8f					_PRMExit:
.ad8f	60		rts				rts
.ad90					Print16BitInteger:
.ad90	a9 00		lda #$00			lda 	#0 							; make 32 bit
.ad92	85 82		sta $82				sta 	XS_Mantissa+2
.ad94	85 83		sta $83				sta 	XS_Mantissa+3
.ad96	8d 0e 03	sta $030e			sta 	NumBufX 					; reset the conversion pointer
.ad99	aa		tax				tax 								; convert bottom level.
.ad9a	20 70 bf	jsr $bf70			jsr 	INTToString 				; make string
.ad9d	a2 00		ldx #$00			ldx 	#0 							; print buffer
.ad9f	bd 0f 03	lda $030f,x	_P1Loop:lda 	Num_Buffer,x
.ada2	f0 06		beq $adaa			beq 	_P1Exit
.ada4	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.ada7	e8		inx				inx
.ada8	80 f5		bra $ad9f			bra 	_P1Loop
.adaa	60		rts		_P1Exit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm


;******  Processing file: modules/basic/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b6					lastUnaryFunction = $b6
.adab					VectorTable:
>adab	f5 b3					.word BinaryOp_And         & $FFFF ; $80 and
>adad	11 b4					.word BinaryOp_Or          & $FFFF ; $81 or
>adaf	2d b4					.word BinaryOp_Xor         & $FFFF ; $82 xor
>adb1	2d b4					.word BinaryOp_Eor         & $FFFF ; $83 eor
>adb3	64 b4					.word Binary_Equal         & $FFFF ; $84 =
>adb5	7e b4					.word Binary_NotEqual      & $FFFF ; $85 <>
>adb7	87 b4					.word Binary_Less          & $FFFF ; $86 <
>adb9	90 b4					.word Binary_LessEqual     & $FFFF ; $87 <=
>adbb	a2 b4					.word Binary_Greater       & $FFFF ; $88 >
>adbd	99 b4					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>adbf	27 b5					.word BinaryOp_Add         & $FFFF ; $8a +
>adc1	43 b5					.word BinaryOp_Subtract    & $FFFF ; $8b -
>adc3	54 b5					.word BinaryOp_Multiply    & $FFFF ; $8c *
>adc5	65 b5					.word BinaryOp_Divide      & $FFFF ; $8d /
>adc7	67 ae					.word NotImplemented       & $FFFF ; $8e ^
>adc9	67 ae					.word NotImplemented       & $FFFF ; $8f if
>adcb	67 ae					.word NotImplemented       & $FFFF ; $90 while
>adcd	67 ae					.word NotImplemented       & $FFFF ; $91 repeat
>adcf	67 ae					.word NotImplemented       & $FFFF ; $92 for
>add1	67 ae					.word NotImplemented       & $FFFF ; $93 then
>add3	67 ae					.word NotImplemented       & $FFFF ; $94 endif
>add5	67 ae					.word NotImplemented       & $FFFF ; $95 wend
>add7	67 ae					.word NotImplemented       & $FFFF ; $96 until
>add9	67 ae					.word NotImplemented       & $FFFF ; $97 next
>addb	67 ae					.word NotImplemented       & $FFFF ; $98 not
>addd	67 ae					.word NotImplemented       & $FFFF ; $99 fn(
>addf	6a b6					.word Unary_Abs            & $FFFF ; $9a abs(
>ade1	aa b7					.word Unary_Asc            & $FFFF ; $9b asc(
>ade3	5b c6					.word Unary_Int            & $FFFF ; $9c int(
>ade5	84 b6					.word Unary_Peek           & $FFFF ; $9d peek(
>ade7	dc c5					.word Unary_Rnd            & $FFFF ; $9e rnd(
>ade9	eb b6					.word Unary_Usr            & $FFFF ; $9f usr(
>adeb	e9 b7					.word Unary_Left           & $FFFF ; $a0 left$(
>aded	fe b7					.word Unary_Right          & $FFFF ; $a1 right$(
>adef	d0 b7					.word Unary_Mid            & $FFFF ; $a2 mid$(
>adf1	47 b9					.word Unary_Spc            & $FFFF ; $a3 spc(
>adf3	78 b7					.word Unary_Str            & $FFFF ; $a4 str$(
>adf5	0c b7					.word Unary_Val            & $FFFF ; $a5 val(
>adf7	c1 b7					.word Unary_Len            & $FFFF ; $a6 len(
>adf9	76 b8					.word Unary_Hex            & $FFFF ; $a7 hex$(
>adfb	67 ae					.word NotImplemented       & $FFFF ; $a8 sin(
>adfd	67 ae					.word NotImplemented       & $FFFF ; $a9 cos(
>adff	67 ae					.word NotImplemented       & $FFFF ; $aa tan(
>ae01	67 ae					.word NotImplemented       & $FFFF ; $ab atn(
>ae03	67 ae					.word NotImplemented       & $FFFF ; $ac exp(
>ae05	67 ae					.word NotImplemented       & $FFFF ; $ad log(
>ae07	67 ae					.word NotImplemented       & $FFFF ; $ae sqr(
>ae09	cc b8					.word Unary_Dec            & $FFFF ; $af dec(
>ae0b	88 b6					.word Unary_Deek           & $FFFF ; $b0 deek(
>ae0d	8c b6					.word Unary_Leek           & $FFFF ; $b1 leek(
>ae0f	b8 b6					.word Unary_Mod            & $FFFF ; $b2 mod(
>ae11	24 b6					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>ae13	29 b9					.word Unary_Chr            & $FFFF ; $b4 chr$(
>ae15	67 ae					.word NotImplemented       & $FFFF ; $b5 pos(
>ae17	67 ae					.word NotImplemented       & $FFFF ; $b6 tab(
>ae19	67 ae					.word NotImplemented       & $FFFF ; $b7 $
>ae1b	67 ae					.word NotImplemented       & $FFFF ; $b8 $(
>ae1d	67 ae					.word NotImplemented       & $FFFF ; $b9 #
>ae1f	67 ae					.word NotImplemented       & $FFFF ; $ba #(
>ae21	67 ae					.word NotImplemented       & $FFFF ; $bb %
>ae23	67 ae					.word NotImplemented       & $FFFF ; $bc %(
>ae25	67 ae					.word NotImplemented       & $FFFF ; $bd (
>ae27	67 ae					.word NotImplemented       & $FFFF ; $be )
>ae29	67 ae					.word NotImplemented       & $FFFF ; $bf ,
>ae2b	fb b0					.word Command_COLON        & $FFFF ; $c0 :
>ae2d	67 ae					.word NotImplemented       & $FFFF ; $c1 ;
>ae2f	67 ae					.word NotImplemented       & $FFFF ; $c2 def
>ae31	24 b2					.word Command_CLR          & $FFFF ; $c3 clr
>ae33	35 b2					.word Command_STOP         & $FFFF ; $c4 stop
>ae35	67 ae					.word NotImplemented       & $FFFF ; $c5 data
>ae37	67 ae					.word NotImplemented       & $FFFF ; $c6 read
>ae39	f2 af					.word Command_DIM          & $FFFF ; $c7 dim
>ae3b	67 ae					.word NotImplemented       & $FFFF ; $c8 to
>ae3d	67 ae					.word NotImplemented       & $FFFF ; $c9 step
>ae3f	67 ae					.word NotImplemented       & $FFFF ; $ca gosub
>ae41	67 ae					.word NotImplemented       & $FFFF ; $cb return
>ae43	ab b1					.word Command_GOTO         & $FFFF ; $cc goto
>ae45	1d b1					.word Command_END          & $FFFF ; $cd end
>ae47	67 ae					.word NotImplemented       & $FFFF ; $ce input
>ae49	fc b0					.word Command_LET          & $FFFF ; $cf let
>ae4b	67 ae					.word NotImplemented       & $FFFF ; $d0 list
>ae4d	67 ae					.word NotImplemented       & $FFFF ; $d1 new
>ae4f	67 ae					.word NotImplemented       & $FFFF ; $d2 old
>ae51	67 ae					.word NotImplemented       & $FFFF ; $d3 on
>ae53	67 ae					.word NotImplemented       & $FFFF ; $d4 restore
>ae55	67 ae					.word NotImplemented       & $FFFF ; $d5 poke
>ae57	22 b1					.word Command_PRINT        & $FFFF ; $d6 print
>ae59	7c b0					.word Command_RUN          & $FFFF ; $d7 run
>ae5b	67 ae					.word NotImplemented       & $FFFF ; $d8 wait
>ae5d	67 ae					.word NotImplemented       & $FFFF ; $d9 sys
>ae5f	67 ae					.word NotImplemented       & $FFFF ; $da doke
>ae61	67 ae					.word NotImplemented       & $FFFF ; $db loke
>ae63	93 b1					.word Command_ASSERT       & $FFFF ; $dc assert
>ae65	67 ae					.word NotImplemented       & $FFFF ; $dd get
.ae67					NotImplemented:
.ae67	20 4c ad	jsr $ad4c			jsr ERR_Handler
>ae6a	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>ae72	65 6d 65 6e 74 65 64 00
.ae7a					BinaryPrecedence:
>ae7a	01					.byte 1    ; $80 and
>ae7b	01					.byte 1    ; $81 or
>ae7c	01					.byte 1    ; $82 xor
>ae7d	01					.byte 1    ; $83 eor
>ae7e	02					.byte 2    ; $84 =
>ae7f	02					.byte 2    ; $85 <>
>ae80	02					.byte 2    ; $86 <
>ae81	02					.byte 2    ; $87 <=
>ae82	02					.byte 2    ; $88 >
>ae83	02					.byte 2    ; $89 >=
>ae84	03					.byte 3    ; $8a +
>ae85	03					.byte 3    ; $8b -
>ae86	04					.byte 4    ; $8c *
>ae87	04					.byte 4    ; $8d /
>ae88	05					.byte 5    ; $8e ^
.ae89					KeywordText:
>ae89	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>ae8c	4f d2					.byte $4f,$d2                          ; $81 or
>ae8e	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>ae91	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>ae94	bd					.byte $bd                              ; $84 =
>ae95	3c be					.byte $3c,$be                          ; $85 <>
>ae97	bc					.byte $bc                              ; $86 <
>ae98	3c bd					.byte $3c,$bd                          ; $87 <=
>ae9a	be					.byte $be                              ; $88 >
>ae9b	3e bd					.byte $3e,$bd                          ; $89 >=
>ae9d	ab					.byte $ab                              ; $8a +
>ae9e	ad					.byte $ad                              ; $8b -
>ae9f	aa					.byte $aa                              ; $8c *
>aea0	af					.byte $af                              ; $8d /
>aea1	de					.byte $de                              ; $8e ^
>aea2	49 c6					.byte $49,$c6                          ; $8f if
>aea4	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>aea9	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>aeaf	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>aeb2	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>aeb6	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>aebb	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>aebf	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>aec4	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>aec8	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>aecb	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>aece	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>aed2	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>aed6	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>aeda	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>aedf	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>aee3	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>aee7	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>aeed	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>aef4	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>aef9	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>aefd	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>af02	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>af06	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>af0a	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>af0f	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>af13	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>af17	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>af1b	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>af1f	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>af23	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>af27	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>af2b	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>af2f	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>af34	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>af39	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>af3d	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>af41	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>af46	50 4f 53 a8				.byte $50,$4f,$53,$a8                  ; $b5 pos(
>af4a	54 41 42 a8				.byte $54,$41,$42,$a8                  ; $b6 tab(
>af4e	a4					.byte $a4                              ; $b7 $
>af4f	24 a8					.byte $24,$a8                          ; $b8 $(
>af51	a3					.byte $a3                              ; $b9 #
>af52	23 a8					.byte $23,$a8                          ; $ba #(
>af54	a5					.byte $a5                              ; $bb %
>af55	25 a8					.byte $25,$a8                          ; $bc %(
>af57	a8					.byte $a8                              ; $bd (
>af58	a9					.byte $a9                              ; $be )
>af59	ac					.byte $ac                              ; $bf ,
>af5a	ba					.byte $ba                              ; $c0 :
>af5b	bb					.byte $bb                              ; $c1 ;
>af5c	44 45 c6				.byte $44,$45,$c6                      ; $c2 def
>af5f	43 4c d2				.byte $43,$4c,$d2                      ; $c3 clr
>af62	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $c4 stop
>af66	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c5 data
>af6a	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c6 read
>af6e	44 49 cd				.byte $44,$49,$cd                      ; $c7 dim
>af71	54 cf					.byte $54,$cf                          ; $c8 to
>af73	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c9 step
>af77	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $ca gosub
>af7c	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $cb return
>af82	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $cc goto
>af86	45 4e c4				.byte $45,$4e,$c4                      ; $cd end
>af89	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $ce input
>af8e	4c 45 d4				.byte $4c,$45,$d4                      ; $cf let
>af91	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $d0 list
>af95	4e 45 d7				.byte $4e,$45,$d7                      ; $d1 new
>af98	4f 4c c4				.byte $4f,$4c,$c4                      ; $d2 old
>af9b	4f ce					.byte $4f,$ce                          ; $d3 on
>af9d	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d4 restore
>afa4	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d5 poke
>afa8	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d6 print
>afad	52 55 ce				.byte $52,$55,$ce                      ; $d7 run
>afb0	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d8 wait
>afb4	53 59 d3				.byte $53,$59,$d3                      ; $d9 sys
>afb7	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $da doke
>afbb	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $db loke
>afbf	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $dc assert
>afc5	47 45 d4				.byte $47,$45,$d4                      ; $dd get
>afc8	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_pos = $b5
=$b6					token_tab = $b6
=$b7					token_dollar = $b7
=$b8					token_dollarlparen = $b8
=$b9					token_hash = $b9
=$ba					token_hashlparen = $ba
=$bb					token_percent = $bb
=$bc					token_percentlparen = $bc
=$bd					token_lparen = $bd
=$be					token_rparen = $be
=$bf					token_comma = $bf
=$c0					token_colon = $c0
=$c1					token_semicolon = $c1
=$c2					token_def = $c2
=$c3					token_clr = $c3
=$c4					token_stop = $c4
=$c5					token_data = $c5
=$c6					token_read = $c6
=$c7					token_dim = $c7
=$c8					token_to = $c8
=$c9					token_step = $c9
=$ca					token_gosub = $ca
=$cb					token_return = $cb
=$cc					token_goto = $cc
=$cd					token_end = $cd
=$ce					token_input = $ce
=$cf					token_let = $cf
=$d0					token_list = $d0
=$d1					token_new = $d1
=$d2					token_old = $d2
=$d3					token_on = $d3
=$d4					token_restore = $d4
=$d5					token_poke = $d5
=$d6					token_print = $d6
=$d7					token_run = $d7
=$d8					token_wait = $d8
=$d9					token_sys = $d9
=$da					token_doke = $da
=$db					token_loke = $db
=$dc					token_assert = $dc
=$dd					token_get = $dd

;******  Return to file: modules/basic/core.asm

.afc9					BASIC_Start:
.afc9	20 4d a2	jsr $a24d			jsr 	IF_Reset 					; set up and clear screen.
.afcc	20 0c a0	jsr $a00c			jsr 	IFT_ClearScreen
.afcf	a9 4c		lda #$4c			lda 	#$4C 						; JMP opcode
.afd1	8d 0a 03	sta $030a			sta 	LocalVector
.afd4	8d 06 03	sta $0306			sta 	UserVector
.afd7	a9 fa		lda #$fa			lda 	#USRDefault & $FF 			; reset USR vector
.afd9	8d 07 03	sta $0307			sta 	UserVector+1
.afdc	a9 b6		lda #$b6			lda 	#(USRDefault >> 8) & $FF
.afde	8d 08 03	sta $0308			sta 	UserVector+2
.afe1	a9 00		lda #$00			lda 	#(USRDefault >> 16) & $FF
.afe3	8d 09 03	sta $0309			sta 	UserVector+3
.afe6	20 93 b9	jsr $b993			jsr 	UpdateProgramEnd 			; update the program end.
.afe9	20 24 b2	jsr $b224			jsr 	ResetRunStatus 				; clear everything (CLR command)
.afec					WarmStart:
.afec	a2 ff		ldx #$ff			ldx 		#$FF 					; empty stack
.afee	9a		txs				txs
.afef	4c 7c b0	jmp $b07c			jmp 	COMMAND_Run

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/dim.asm

.aff2					Command_DIM:
.aff2	6b		tza				tza
.aff3	48		pha				pha 								; push on stack.
.aff4	20 f7 ba	jsr $baf7			jsr 	VariableExtract 			; get the identifier
.aff7	ad 8f 03	lda $038f			lda 	Var_Type 					; check it is an array
.affa	29 01		and #$01			and 	#1
.affc	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.affe	d0 6e		bne $b06e			bne 	_CDIError
.b000	a9 00		lda #$00			lda 	#0 							; reset the DIM index. The dimensions are
.b002	8d b1 03	sta $03b1			sta 	UsrArrayIdx 				; built up here and copied in case we autodim
.b005					_CDIGetDimension:
.b005	ad b1 03	lda $03b1			lda 	UsrArrayIdx 				; done too many ?
.b008	c9 06		cmp #$06			cmp 	#ArrayMaxDim*2
.b00a	f0 62		beq $b06e			beq 	_CDIError
.b00c	20 d6 b3	jsr $b3d6			jsr 	EvaluateInteger 			; evaluate an index size
.b00f	a5 81		lda $81				lda 	XS_Mantissa+1 				; check in range 0-7FFF
.b011	29 80		and #$80			and 	#$80
.b013	05 82		ora $82				ora 	XS_Mantissa+2
.b015	05 83		ora $83				ora 	XS_Mantissa+3
.b017	d0 55		bne $b06e			bne 	_CDIError
.b019	ae b1 03	ldx $03b1			ldx 	UsrArrayIdx 				; copy into the array table.
.b01c	18		clc				clc 								; add 1 - max index => size.
.b01d	a5 80		lda $80				lda 	XS_Mantissa+0
.b01f	69 01		adc #$01			adc 	#1
.b021	9d a9 03	sta $03a9,x			sta 	UsrArrayDef+0,x
.b024	a5 81		lda $81				lda 	XS_Mantissa+1
.b026	69 00		adc #$00			adc 	#0
.b028	9d aa 03	sta $03aa,x			sta 	UsrArrayDef+1,x
.b02b	30 41		bmi $b06e			bmi 	_CDIError 					; could be dim a(32767)
.b02d	e8		inx				inx 								; bump index.
.b02e	e8		inx				inx
.b02f	8e b1 03	stx $03b1			stx 	UsrArrayIdx
.b032	ea		nop				nop
.b033	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b035	1b		inz				inz
.b036	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another dimension
.b038	f0 cb		beq $b005			beq 	_CDIGetDimension
.b03a	3b		dez				dez
.b03b	20 e6 b9	jsr $b9e6			jsr 	CheckNextRParen 			; closing ) present ?
.b03e	ae b1 03	ldx $03b1			ldx 	UsrArrayIdx 				; copy USR array to default
.b041	a9 ff		lda #$ff			lda 	#$FF 						; put end marker in ArrayDef
.b043	9d a2 03	sta $03a2,x			sta 	ArrayDef+1,x
.b046					_CDICopy:
.b046	bd a9 03	lda $03a9,x			lda 	UsrArrayDef,x
.b049	9d a1 03	sta $03a1,x			sta 	ArrayDef,x
.b04c	ca		dex				dex
.b04d	10 f7		bpl $b046			bpl 	_CDICopy
.b04f	68		pla				pla									; position of array identifier
.b050	85 10		sta $10				sta 	zTemp1
.b052	6b		tza				tza
.b053	48		pha				pha
.b054	a5 10		lda $10				lda 	zTemp1 						; point to identifier
.b056	4b		taz				taz
.b057	20 f7 ba	jsr $baf7			jsr 	VariableExtract 			; get the identifier
.b05a	20 92 bd	jsr $bd92			jsr 	VariableLocate 				; check if it exists already.
.b05d	b0 0f		bcs $b06e			bcs 	_CDIError
.b05f	20 85 bb	jsr $bb85			jsr 	VariableCreate 				; create it using the current ArrayDef
.b062	68		pla				pla 								; restore code position
.b063	4b		taz				taz
.b064	ea		nop				nop
.b065	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b067	1b		inz				inz
.b068	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another DIM
.b06a	f0 86		beq $aff2			beq 	Command_DIM
.b06c	3b		dez				dez
.b06d	60		rts				rts
.b06e					_CDIError:
.b06e	20 4c ad	jsr $ad4c			jsr ERR_Handler
>b071	42 61 64 20 44 49 4d 00			.text "Bad DIM",0
.b079					_CDISyntax:
.b079	4c 1d ad	jmp $ad1d			jmp 	SyntaxError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/run.asm

.b07c					Command_RUN:
.b07c	20 24 b2	jsr $b224			jsr 	ResetRunStatus 				; clear, reset stacks etc.
.b07f	a9 00		lda #$00			lda 	#BasicProgram & $FF
.b081	85 16		sta $16				sta 	zCodePtr+0
.b083	a9 80		lda #$80			lda 	#BasicProgram >> 8
.b085	85 17		sta $17				sta 	zCodePtr+1
.b087	a9 02		lda #$02			lda 	#2
.b089	85 18		sta $18				sta 	zCodePtr+2
.b08b	a9 00		lda #$00			lda 	#0
.b08d	85 19		sta $19				sta 	zCodePtr+3
.b08f	a3 03		ldz #$03			ldz 	#3
.b091					RUN_NewLine:
.b091	a3 00		ldz #$00			ldz 	#0
.b093	ea		nop				nop
.b094	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b096	1b		inz				inz
.b097	1b		inz				inz
.b098	1b		inz				inz
.b099	c9 00		cmp #$00			cmp 	#0 							; if the offset is zero then END.
.b09b	d0 18		bne $b0b5			bne 	RUN_NextCommand
.b09d	4c 35 b2	jmp $b235			jmp 	Command_STOP 				; go do the command code.
.b0a0					RUN_Skip:
.b0a0	ea		nop				nop
.b0a1	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read element
.b0a3	1b		inz				inz 								; skip
.b0a4	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.b0a6	90 0d		bcc $b0b5			bcc 	_SEDone 					; so just skip over it.
.b0a8	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.b0aa	90 08		bcc $b0b4			bcc 	_SEDouble
.b0ac	6b		tza				tza 								; this is Y + 1
.b0ad	18		clc				clc
.b0ae	ea		nop				nop
.b0af	72 16		adc ($16),z			adc 	(zCodePtr),z 				; add total length of element
.b0b1	4b		taz				taz 								; back in Y.
.b0b2	3b		dez				dez 								; fix up, one for the +1, one for the iny
.b0b3	3b		dez				dez
.b0b4					_SEDouble:
.b0b4	1b		inz				inz
.b0b5					_SEDone:
.b0b5					RUN_NextCommand:
.b0b5	a9 00		lda #$00			lda 	#0 							; this resets temporary string allocation.
.b0b7	85 21		sta $21				sta 	zTempStr+1 					; (initialised when first called)
.b0b9	ea		nop				nop
.b0ba	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b0bc	c9 c0		cmp #$c0			cmp 	#token_Colon 				; skip over colons
.b0be	f0 e0		beq $b0a0			beq 	RUN_Skip
.b0c0	c9 00		cmp #$00			cmp 	#0 							; if non-zero execute whatever
.b0c2	d0 10		bne $b0d4			bne 	RUN_Execute
.b0c4					RUN_NextLine:
.b0c4	a3 00		ldz #$00			ldz 	#0 							; point to offset
.b0c6	ea		nop				nop
.b0c7	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read it
.b0c9	18		clc				clc
.b0ca	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.b0cc	85 16		sta $16				sta 	zCodePtr
.b0ce	90 02		bcc $b0d2			bcc 	_SNLNoCarry
.b0d0	e6 17		inc $17				inc 	zCodePtr+1
.b0d2					_SNLNoCarry:
.b0d2	80 bd		bra $b091			bra 	RUN_NewLine 				; go do the new line code
.b0d4					RUN_Execute:
.b0d4	c9 f8		cmp #$f8			cmp 	#$F8 						; handle shifts, REM etc.
.b0d6	b0 1c		bcs $b0f4			bcs 	RUN_Extension
.b0d8	1b		inz				inz
.b0d9	0a		asl a				asl 	a 							; double the character read.
.b0da	90 12		bcc $b0ee			bcc 	RUN_Default 				; if carry clear was $00-$7F, so try LET.
.b0dc	aa		tax				tax 								; ready to look up.
.b0dd	bd ab ad	lda $adab,x			lda 	VectorTable,x 				; copy address into LocalVector
.b0e0	8d 0b 03	sta $030b			sta 	LocalVector+1
.b0e3	bd ac ad	lda $adac,x			lda 	VectorTable+1,x
.b0e6	8d 0c 03	sta $030c			sta 	LocalVector+2
.b0e9	20 47 b3	jsr $b347			jsr 	EVCallLocalVector 			; execute the appropriate code.
.b0ec	80 c7		bra $b0b5			bra 	RUN_NextCommand 			; do the next command.
.b0ee					RUN_Default:
.b0ee	3b		dez				dez
.b0ef	20 fc b0	jsr $b0fc			jsr 	Command_LET 				; and try LET.
.b0f2	80 c1		bra $b0b5			bra 	RUN_NextCommand
.b0f4					RUN_Extension:
.b0f4	c9 ff		cmp #$ff			cmp 	#$FF 						; if $FF (REM)
.b0f6	f0 a8		beq $b0a0			beq 	RUN_Skip 					; skip over it.
.b0f8	4c 1d ad	jmp $ad1d			jmp 	SyntaxError
.b0fb					Command_COLON:
.b0fb	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/let.asm

.b0fc					Command_LET:
.b0fc	20 8c ba	jsr $ba8c			jsr 	VariableFind 				; get reference to one variable.
.b0ff	a9 84		lda #$84			lda 	#token_Equal  				; get equals
.b101	20 ce b9	jsr $b9ce			jsr 	CheckNextToken
.b104	a5 22		lda $22				lda 	zVarDataPtr 				; save variable info on stack
.b106	48		pha				pha
.b107	a5 23		lda $23				lda 	zVarDataPtr+1
.b109	48		pha				pha
.b10a	a5 24		lda $24				lda 	zVarType
.b10c	48		pha				pha
.b10d	20 40 b2	jsr $b240			jsr 	EvaluateExpression 			; evaluate the RHS.
.b110	68		pla				pla 								; restore target variable information.
.b111	85 24		sta $24				sta 	zVarType
.b113	68		pla				pla
.b114	85 23		sta $23				sta 	zVarDataPtr+1
.b116	68		pla				pla
.b117	85 22		sta $22				sta 	zVarDataPtr
.b119	20 27 be	jsr $be27			jsr 	VariableSet 				; set the value out.
.b11c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/end.asm

.b11d					Command_END:
.b11d	80 fe		bra $b11d	_halt:	bra 		_halt
.b11f	4c ec af	jmp $afec			jmp 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/print.asm

.b122					Command_PRINT:
.b122	ea		nop				nop
.b123	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b125	c9 00		cmp #$00			cmp 	#0 							; end
.b127	f0 66		beq $b18f			beq 	_CPR_NewLine
.b129	c9 c0		cmp #$c0			cmp 	#token_Colon
.b12b	f0 62		beq $b18f			beq 	_CPR_NewLine
.b12d	c9 c1		cmp #$c1			cmp 	#token_SemiColon
.b12f	f0 50		beq $b181			beq 	_CPR_Skip
.b131	c9 bf		cmp #$bf			cmp 	#token_Comma
.b133	f0 49		beq $b17e			beq 	_CPR_Tab
.b135	20 40 b2	jsr $b240			jsr 	EvaluateExpression 			; get expression.
.b138	a5 85		lda $85				lda 	XS_Type 					; get type.
.b13a	29 02		and #$02			and 	#2
.b13c	d0 24		bne $b162			bne 	_CPR_String 				; if type = 2 output as string.
.b13e					_CPR_Number:
.b13e	a9 00		lda #$00			lda 	#0 							; reset buffer index
.b140	8d 0e 03	sta $030e			sta 	NumBufX
.b143	a5 85		lda $85				lda 	XS_Type 					; get type
.b145	4a		lsr a				lsr 	a
.b146	b0 05		bcs $b14d			bcs 	_CPRInt 					; if msb set do as integer
.b148	20 a7 c4	jsr $c4a7			jsr 	FPToString 					; call fp to str otherwise
.b14b	80 03		bra $b150			bra 	_CPRNPrint
.b14d	20 70 bf	jsr $bf70	_CPRInt:jsr 	IntToString
.b150					_CPRNPrint:
.b150	ad 0f 03	lda $030f			lda 	Num_Buffer 					; is first character -
.b153	c9 2d		cmp #$2d			cmp 	#"-"
.b155	f0 05		beq $b15c			beq 	_CPRNoSpace
.b157	a9 20		lda #$20			lda 	#" "						; print the leading space
.b159	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter 			; so beloved of MS Basics.
.b15c					_CPRNoSpace:
.b15c	a2 0e		ldx #$0e			ldx 	#(Num_Buffer-1) & $FF
.b15e	a9 03		lda #$03			lda 	#(Num_Buffer-1) >> 8
.b160	80 04		bra $b166			bra 	_CPRPrint
.b162					_CPR_String:
.b162	a6 80		ldx $80				ldx 	XS_Mantissa
.b164	a5 81		lda $81				lda 	XS_Mantissa+1
.b166					_CPRPrint:
.b166	86 1e		stx $1e				stx 	zGenPtr
.b168	85 1f		sta $1f				sta 	zGenPtr+1
.b16a	5a		phy				phy
.b16b	a0 00		ldy #$00			ldy 	#0							; get length into X
.b16d	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b16f	aa		tax				tax
.b170	f0 09		beq $b17b			beq 	_CPREndPrint 				; nothing to print
.b172					_CPRLoop:
.b172	c8		iny				iny
.b173	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b175	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.b178	ca		dex				dex
.b179	d0 f7		bne $b172			bne 	_CPRLoop
.b17b					_CPREndPrint:
.b17b	7a		ply				ply
.b17c	80 a4		bra $b122			bra 	Command_Print
.b17e					_CPR_Tab:
.b17e	20 5b a0	jsr $a05b			jsr 	IFT_Tab
.b181					_CPR_Skip:
.b181	1b		inz				inz
.b182	ea		nop				nop
.b183	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b185	c9 c0		cmp #$c0			cmp 	#token_Colon 				; colon or $00, exit
.b187	f0 09		beq $b192			beq 	_CPR_Exit
.b189	c9 00		cmp #$00			cmp 	#0
.b18b	d0 95		bne $b122			bne 	Command_PRINT 				; if not go round again.
.b18d	80 03		bra $b192			bra 	_CPR_Exit
.b18f					_CPR_NewLine:
.b18f	20 68 a0	jsr $a068			jsr 	IFT_NewLine
.b192					_CPR_Exit:
.b192	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/assert.asm

.b193					Command_ASSERT:
.b193	20 d6 b3	jsr $b3d6			jsr 	EvaluateInteger 			; calculate thing being asserted
.b196	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; check if true (non-zero)
.b198	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.b19a	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.b19c	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.b19e	f0 01		beq $b1a1			beq 	_ASFail
.b1a0	60		rts				rts
.b1a1					_ASFail:
.b1a1	20 4c ad	jsr $ad4c			jsr ERR_Handler
>b1a4	41 73 73 65 72 74 00			.text "Assert",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/branch.asm

.b1ab					Command_GOTO:
.b1ab	20 b1 b1	jsr $b1b1			jsr 	GotoGetLineNumber
.b1ae	4c ce b1	jmp $b1ce			jmp 	GotoChangeToLineNumber
.b1b1					GotoGetLineNumber:
.b1b1	20 d6 b3	jsr $b3d6			jsr 	EvaluateInteger
.b1b4	a5 82		lda $82				lda 	XS_Mantissa+2 				; check range
.b1b6	05 83		ora $83				ora 	XS_Mantissa+3
.b1b8	d0 01		bne $b1bb			bne 	_GLINError
.b1ba	60		rts				rts
.b1bb					_GLINError:
.b1bb	20 4c ad	jsr $ad4c			jsr ERR_Handler
>b1be	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>b1c6	20 4e 75 6d 62 65 72 00
.b1ce					GotoChangeToLineNumber:
.b1ce	a5 80		lda $80				lda 	XS_Mantissa+0 				; check line number not zero
.b1d0	05 81		ora $81				ora 	XS_Mantissa+1
.b1d2	f0 3d		beq $b211			beq 	_GCTLFail
.b1d4	a9 00		lda #$00			lda 	#BasicProgram & $FF
.b1d6	85 16		sta $16				sta 	zCodePtr+0
.b1d8	a9 80		lda #$80			lda 	#BasicProgram >> 8
.b1da	85 17		sta $17				sta 	zCodePtr+1
.b1dc	a9 02		lda #$02			lda 	#2
.b1de	85 18		sta $18				sta 	zCodePtr+2
.b1e0	a9 00		lda #$00			lda 	#0
.b1e2	85 19		sta $19				sta 	zCodePtr+3
.b1e4	a3 03		ldz #$03			ldz 	#3
.b1e6					_GCTLLoop:
.b1e6	a3 00		ldz #$00			ldz 	#0
.b1e8	ea		nop				nop
.b1e9	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b1eb	c9 00		cmp #$00			cmp 	#0
.b1ed	f0 22		beq $b211			beq 	_GCTLFail
.b1ef	1b		inz				inz
.b1f0	ea		nop				nop
.b1f1	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b1f3	c5 80		cmp $80				cmp 	XS_Mantissa+0
.b1f5	d0 08		bne $b1ff			bne 	_GCTLNext
.b1f7	1b		inz				inz
.b1f8	ea		nop				nop
.b1f9	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b1fb	c5 81		cmp $81				cmp 	XS_Mantissa+1
.b1fd	f0 10		beq $b20f			beq 	_GCTLExit
.b1ff					_GCTLNext:
.b1ff	a3 00		ldz #$00			ldz 	#0 							; point to offset
.b201	ea		nop				nop
.b202	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read it
.b204	18		clc				clc
.b205	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.b207	85 16		sta $16				sta 	zCodePtr
.b209	90 02		bcc $b20d			bcc 	_SNLNoCarry
.b20b	e6 17		inc $17				inc 	zCodePtr+1
.b20d					_SNLNoCarry:
.b20d	80 d7		bra $b1e6			bra 	_GCTLLoop 					; try next line.
.b20f					_GCTLExit:
.b20f	1b		inz				inz
.b210	60		rts				rts
.b211					_GCTLFail:
.b211	20 4c ad	jsr $ad4c			jsr ERR_Handler
>b214	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>b21c	20 4e 75 6d 62 65 72 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.b224					Command_CLR:
.b224					ResetRunStatus:
.b224	20 c8 ba	jsr $bac8			jsr 	VariableClear
.b227	a9 00		lda #$00			lda 	#HighMemory & $FF
.b229	8d 00 03	sta $0300			sta 	StringPtr
.b22c	a9 7f		lda #$7f			lda 	#HighMemory >> 8
.b22e	8d 01 03	sta $0301			sta 	StringPtr+1
.b231	20 94 bc	jsr $bc94			jsr 	ArrayResetDefault
.b234	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/stop.asm

.b235					Command_STOP:
.b235	20 4c ad	jsr $ad4c			jsr ERR_Handler
>b238	53 74 6f 70 00				.text "Stop",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.b23d					EVESyntax:
.b23d	4c 1d ad	jmp $ad1d			jmp 	SyntaxError
.b240					EvaluateExpression:
.b240	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.b242					EvaluateExpressionX:
.b242	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.b244					EvaluateExpressionXA:
.b244	48		pha				pha 								; save precedence on stack.
.b245	ea		nop				nop
.b246	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b248	f0 f3		beq $b23d			beq 	EVESyntax 					; end of line, syntax error.
.b24a	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.b24c	b0 03		bcs $b251			bcs 	_EVNotVariable
.b24e	4c 3e b3	jmp $b33e			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.b251					_EVNotVariable:
.b251	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.b253	90 e8		bcc $b23d			bcc 	EVESyntax
.b255	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.b257	b0 7a		bcs $b2d3			bcs 	_EVNotInteger
.b259	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.b25b	95 80		sta $80,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.b25d	a9 00		lda #$00			lda 	#0
.b25f	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b261	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b263	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b265	1a		inc a				inc 	a 							; set to type 1 (integer)
.b266	95 85		sta $85,x			sta 	XS_Type,x
.b268					_EVCheckNextInteger:
.b268	1b		inz				inz
.b269	ea		nop				nop
.b26a	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b26c	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.b26e	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.b270	b0 0b		bcs $b27d			bcs 	_EVCheckDecimal
.b272	48		pha				pha 								; save it.
.b273	20 4a b3	jsr $b34a			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.b276	68		pla				pla
.b277	15 80		ora $80,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.b279	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b27b	80 eb		bra $b268			bra 	_EVCheckNextInteger
.b27d					_EVCheckDecimal:
.b27d	ea		nop				nop
.b27e	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b280	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.b282	d0 05		bne $b289			bne 	_EVGotAtom 					; no, get atom.
.b284					_EVIsDecimal:
.b284	20 6c b3	jsr $b36c			jsr 	EVGetDecimal 				; extend to the decimal part.
.b287	80 00		bra $b289			bra 	_EVGotAtom 					; and continue to got atom.
.b289					_EVGotAtom:
.b289	ea		nop				nop
.b28a	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b28c	10 43		bpl $b2d1			bpl 	_EVExitDrop 				; must be a token.
.b28e	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.b290	b0 3f		bcs $b2d1			bcs 	_EVExitDrop
.b292	68		pla				pla 								; get current precedence
.b293	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.b295	da		phx				phx 								; save X
.b296	ea		nop				nop
.b297	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b299	aa		tax				tax 								; put in X
.b29a	bd fa ad	lda $adfa,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.b29d	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.b29f	fa		plx				plx 								; restore X
.b2a0	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.b2a2	90 2e		bcc $b2d2			bcc 	_EVExit 					; exit if too low.
.b2a4	f0 2c		beq $b2d2			beq 	_EVExit 					; exit if equals
.b2a6	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.b2a8	48		pha				pha
.b2a9	ea		nop				nop
.b2aa	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b2ac	48		pha				pha
.b2ad	1b		inz				inz
.b2ae	da		phx				phx 								; save current position
.b2af	e8		inx				inx
.b2b0	e8		inx				inx
.b2b1	e8		inx				inx
.b2b2	e8		inx				inx
.b2b3	e8		inx				inx
.b2b4	e8		inx				inx
.b2b5	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.b2b7	20 44 b2	jsr $b244			jsr 	EvaluateExpressionXA 		; do the RHS.
.b2ba	fa		plx				plx 								; restore X
.b2bb	68		pla				pla 								; get the binary operator in A.
.b2bc					_EVCallA:
.b2bc	da		phx				phx 								; save X again
.b2bd	0a		asl a				asl 	a 							; double, lose the MSB.
.b2be	aa		tax				tax									; put in X
.b2bf	bd ab ad	lda $adab,x			lda 	VectorTable,x 				; copy address into zGenPtr
.b2c2	8d 0b 03	sta $030b			sta 	LocalVector+1
.b2c5	bd ac ad	lda $adac,x			lda 	VectorTable+1,x
.b2c8	8d 0c 03	sta $030c			sta 	LocalVector+2
.b2cb	fa		plx				plx 								; restore X
.b2cc	20 47 b3	jsr $b347			jsr 	EVCallLocalVector
.b2cf	80 b8		bra $b289			bra 	_EVGotAtom 					; and loop back.
.b2d1					_EVExitDrop:
.b2d1	68		pla				pla
.b2d2					_EVExit:
.b2d2	60		rts				rts
.b2d3					_EVNotInteger:
.b2d3	1b		inz				inz
.b2d4	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.b2d6	d0 16		bne $b2ee			bne 	_EVNotMinus
.b2d8	20 b7 b3	jsr $b3b7			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.b2db	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.b2dd	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.b2df	f0 05		beq $b2e6			beq 	_EVMinusFloat
.b2e1	20 53 bf	jsr $bf53			jsr 	IntegerNegateAlways 		; negation
.b2e4	80 a3		bra $b289			bra 	_EVGotAtom 					; and go back.
.b2e6					_EVMinusFloat:
.b2e6	b5 85		lda $85,x			lda 	XS_Type,x 					; invert the sign bit.
.b2e8	49 80		eor #$80			eor 	#$80
.b2ea	95 85		sta $85,x			sta 	XS_Type,x
.b2ec	80 9b		bra $b289			bra 	_EVGotAtom
.b2ee					_EVNotMinus:
.b2ee	c9 bd		cmp #$bd			cmp 	#token_lparen 				; is it left parenthesis
.b2f0	d0 18		bne $b30a			bne 	_EVNotParenthesis
.b2f2	20 42 b2	jsr $b242			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.b2f5	ea		nop				nop
.b2f6	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b2f8	1b		inz				inz
.b2f9	c9 be		cmp #$be			cmp 	#token_rparen 				; okay if right bracket.
.b2fb	f0 8c		beq $b289			beq 	_EVGotAtom
.b2fd	20 4c ad	jsr $ad4c			jsr ERR_Handler
>b300	4d 69 73 73 69 6e 67 20			.text "Missing )",0
>b308	29 00
.b30a					_EVNotParenthesis:
.b30a	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.b30c	d0 0c		bne $b31a			bne 	_EVNotNot
.b30e	20 b7 b3	jsr $b3b7			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.b311	20 a8 c3	jsr $c3a8			jsr 	FPUToInteger 				; make it an integer - if possible.
.b314	20 9c b3	jsr $b39c			jsr 	NotInteger 					; do the not calculation
.b317	4c 89 b2	jmp $b289			jmp 	_EVGotAtom
.b31a					_EVNotNot:
.b31a	c9 fe		cmp #$fe			cmp 	#$FE
.b31c	d0 12		bne $b330			bne 	_EVNotString
.b31e	20 63 ba	jsr $ba63			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.b321	a5 20		lda $20				lda 	zTempStr 					; copy address of string into mantissa
.b323	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b325	a5 21		lda $21				lda 	zTempStr+1
.b327	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b329	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.b32b	95 85		sta $85,x			sta 	XS_Type,x
.b32d	4c 89 b2	jmp $b289			jmp 	_EVGotAtom
.b330					_EVNotString:
.b330	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.b332	90 04		bcc $b338			bcc 	_EVBadElement
.b334	c9 b7		cmp #$b7			cmp 	#lastUnaryFunction+1
.b336	90 03		bcc $b33b			bcc 	_EVUnaryFunction
.b338					_EVBadElement:
.b338	4c 1d ad	jmp $ad1d			jmp 	SyntaxError
.b33b					_EVUnaryFunction:
.b33b	4c bc b2	jmp $b2bc			jmp 	_EVCallA
.b33e					_EVVariableHandler:
.b33e	20 8c ba	jsr $ba8c			jsr 	VariableFind 				; locate a variable
.b341	20 d6 bd	jsr $bdd6			jsr 	VariableGet 				; copy into memory.
.b344	4c 89 b2	jmp $b289			jmp 	_EVGotAtom 					; and go round.
.b347					EVCallLocalVector:
.b347	6c 0b 03	jmp ($030b)			jmp 	(LocalVector+1)
.b34a					EVShiftMantissaLeft6:
.b34a	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.b34c	95 84		sta $84,x			sta 	XS_Exponent,x
.b34e	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.b350	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b352	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b354	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b356	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.b358	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b35a	a9 00		lda #$00			lda 	#0
.b35c	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b35e	20 61 b3	jsr $b361			jsr 	_EVSMLShift 					; call it here to do it twice
.b361					_EVSMLShift:
.b361	56 84		lsr $84,x			lsr 	XS_Exponent,x
.b363	76 83		ror $83,x			ror 	XS_Mantissa+3,x
.b365	76 82		ror $82,x			ror 	XS_Mantissa+2,x
.b367	76 81		ror $81,x			ror 	XS_Mantissa+1,x
.b369	76 80		ror $80,x			ror 	XS_Mantissa+0,x
.b36b	60		rts				rts
.b36c					EVGetDecimal:
.b36c	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.b36e	8d 0f 03	sta $030f			sta 	Num_Buffer
.b371	da		phx				phx
.b372	1b		inz				inz
.b373	ea		nop				nop
.b374	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b376	1b		inz				inz
.b377	3a		dec a				dec 	a								; convert to a string length.
.b378	3a		dec a				dec 	a
.b379	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.b37b					_EVGDCopy:
.b37b	48		pha				pha 									; save count
.b37c	ea		nop				nop
.b37d	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b37f	9d 0f 03	sta $030f,x			sta 	Num_Buffer,x
.b382	e8		inx				inx 									; forward ....
.b383	1b		inz				inz
.b384	68		pla				pla 									; get count
.b385	3a		dec a				dec 	a 								; until zero
.b386	d0 f3		bne $b37b			bne 	_EVGDCopy
.b388	9d 0f 03	sta $030f,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.b38b	fa		plx				plx 									; restore X
.b38c	a9 0f		lda #$0f			lda 	#Num_Buffer & $FF 				; set zGenPtr
.b38e	85 1e		sta $1e				sta 	zGenPtr
.b390	a9 03		lda #$03			lda 	#Num_Buffer >> 8
.b392	85 1f		sta $1f				sta 	zGenPtr+1
.b394	5a		phy				phy 									; save Y
.b395	a0 00		ldy #$00			ldy 	#0 								; start position
.b397	20 62 c5	jsr $c562			jsr 	FPFromString 					; convert current
.b39a	7a		ply				ply 									; restore Y
.b39b	60		rts				rts
.b39c					NotInteger:
.b39c	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.b39e	49 ff		eor #$ff			eor 	#$FF
.b3a0	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b3a2	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b3a4	49 ff		eor #$ff			eor 	#$FF
.b3a6	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b3a8	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.b3aa	49 ff		eor #$ff			eor 	#$FF
.b3ac	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b3ae	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.b3b0	49 ff		eor #$ff			eor 	#$FF
.b3b2	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b3b4	60		rts				rts
.b3b5					EvaluateGetAtom:
.b3b5	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.b3b7					EvaluateGetAtomX:
.b3b7	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.b3b9	20 44 b2	jsr $b244			jsr 	EvaluateExpressionXA
.b3bc	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.b3be	29 0f		and #$0f			and 	#15
.b3c0	c9 02		cmp #$02			cmp 	#2
.b3c2	b0 01		bcs $b3c5			bcs 	EvaluateType
.b3c4	60		rts				rts
.b3c5					EvaluateType:
.b3c5	4c 2d ad	jmp $ad2d			jmp 	TypeError
.b3c8					EvaluateNumber:
.b3c8	a2 00		ldx #$00			ldx 	#0
.b3ca					EvaluateNumberX:
.b3ca	20 42 b2	jsr $b242			jsr 	EvaluateExpressionX
.b3cd	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0/1
.b3cf	29 0f		and #$0f			and 	#15
.b3d1	c9 02		cmp #$02			cmp 	#2
.b3d3	b0 f0		bcs $b3c5			bcs 	EvaluateType
.b3d5	60		rts				rts
.b3d6					EvaluateInteger:
.b3d6	a2 00		ldx #$00			ldx 	#0
.b3d8					EvaluateIntegerX:
.b3d8	20 ca b3	jsr $b3ca			jsr 	EvaluateNumberX
.b3db	20 a8 c3	jsr $c3a8			jsr 	FPUToInteger
.b3de	60		rts				rts
.b3df					EvaluateString:
.b3df	a2 00		ldx #$00			ldx 	#0
.b3e1					EvaluateStringX:
.b3e1	20 42 b2	jsr $b242			jsr 	EvaluateExpressionX
.b3e4	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 2
.b3e6	29 0f		and #$0f			and 	#15
.b3e8	c9 02		cmp #$02			cmp 	#2
.b3ea	d0 d9		bne $b3c5			bne 	EvaluateType
.b3ec	b5 80		lda $80,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.b3ee	85 1e		sta $1e				sta 	zGenPtr
.b3f0	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b3f2	85 1f		sta $1f				sta 	zGenPtr+1
.b3f4	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.b3f5					BinaryOp_And:
.b3f5	20 49 b4	jsr $b449			jsr 	BinaryMakeBothInteger
.b3f8	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.b3fa	35 86		and $86,x			and 	XS2_Mantissa+0,x
.b3fc	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b3fe	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.b400	35 87		and $87,x			and 	XS2_Mantissa+1,x
.b402	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b404	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.b406	35 88		and $88,x			and 	XS2_Mantissa+2,x
.b408	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b40a	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.b40c	35 89		and $89,x			and 	XS2_Mantissa+3,x
.b40e	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b410	60		rts				rts
.b411					BinaryOp_Or:
.b411	20 49 b4	jsr $b449			jsr 	BinaryMakeBothInteger
.b414	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.b416	15 86		ora $86,x			ora 	XS2_Mantissa+0,x
.b418	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b41a	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.b41c	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.b41e	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b420	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.b422	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.b424	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b426	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.b428	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.b42a	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b42c	60		rts				rts
.b42d					BinaryOp_Eor:
.b42d					BinaryOp_Xor:
.b42d	20 49 b4	jsr $b449			jsr 	BinaryMakeBothInteger
.b430	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.b432	55 86		eor $86,x			eor 	XS2_Mantissa+0,x
.b434	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b436	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.b438	55 87		eor $87,x			eor 	XS2_Mantissa+1,x
.b43a	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b43c	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.b43e	55 88		eor $88,x			eor 	XS2_Mantissa+2,x
.b440	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b442	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.b444	55 89		eor $89,x			eor 	XS2_Mantissa+3,x
.b446	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b448	60		rts				rts
.b449					BinaryMakeBothInteger:
.b449	da		phx				phx 								; save X
.b44a	e8		inx				inx
.b44b	e8		inx				inx
.b44c	e8		inx				inx
.b44d	e8		inx				inx
.b44e	e8		inx				inx
.b44f	e8		inx				inx
.b450	20 54 b4	jsr $b454			jsr 	BinaryMakeInteger 			; convert to integer.
.b453	fa		plx				plx 								; restore X and fall through.
.b454					BinaryMakeInteger:
.b454	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.b456	29 0f		and #$0f			and 	#15 						; check type zero
.b458	f0 04		beq $b45e			beq 	_BMIConvert 				; if float convert to integer.
.b45a	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.b45b	90 04		bcc $b461			bcc 	_BMIError
.b45d	60		rts				rts
.b45e					_BMIConvert:
.b45e	4c a8 c3	jmp $c3a8			jmp 	FPUToInteger 				; convert to integer
.b461					_BMIError:
.b461	4c 2d ad	jmp $ad2d			jmp 	TypeError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.b464					Binary_Equal:
.b464	20 ab b4	jsr $b4ab			jsr 	CompareValues
.b467	09 00		ora #$00			ora 	#0
.b469	f0 04		beq $b46f			beq 	CCTrue
.b46b	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.b46d	80 02		bra $b471			bra 	CCWrite
.b46f	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.b471	95 80		sta $80,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.b473	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b475	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b477	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b479	a9 01		lda #$01			lda 	#1
.b47b	95 85		sta $85,x			sta 	XS_Type,x 					; set type to integer whatever.
.b47d	60		rts				rts
.b47e					Binary_NotEqual:
.b47e	20 ab b4	jsr $b4ab			jsr 	CompareValues
.b481	09 00		ora #$00			ora 	#0
.b483	f0 e6		beq $b46b			beq 	CCFalse
.b485	80 e8		bra $b46f			bra 	CCTrue
.b487					Binary_Less:
.b487	20 ab b4	jsr $b4ab			jsr 	CompareValues
.b48a	09 00		ora #$00			ora 	#0
.b48c	30 e1		bmi $b46f			bmi 	CCTrue
.b48e	80 db		bra $b46b			bra 	CCFalse
.b490					Binary_LessEqual:
.b490	20 ab b4	jsr $b4ab			jsr 	CompareValues
.b493	c9 01		cmp #$01			cmp 	#1
.b495	d0 d8		bne $b46f			bne 	CCTrue
.b497	80 d2		bra $b46b			bra 	CCFalse
.b499					Binary_GreaterEqual:
.b499	20 ab b4	jsr $b4ab			jsr 	CompareValues
.b49c	09 00		ora #$00			ora 	#0
.b49e	10 cf		bpl $b46f			bpl 	CCTrue
.b4a0	80 c9		bra $b46b			bra 	CCFalse
.b4a2					Binary_Greater:
.b4a2	20 ab b4	jsr $b4ab			jsr 	CompareValues
.b4a5	c9 01		cmp #$01			cmp 	#1
.b4a7	f0 c6		beq $b46f			beq 	CCTrue
.b4a9	80 c0		bra $b46b			bra 	CCFalse
.b4ab					CompareValues:
.b4ab	b5 85		lda $85,x			lda 	XS_Type,x 					; and the types together
.b4ad	35 8b		and $8b,x			and 	XS2_Type,x
.b4af	c9 02		cmp #$02			cmp 	#2
.b4b1	f0 11		beq $b4c4			beq 	_CVString
.b4b3	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b4b5	35 8b		and $8b,x			and 	XS2_Type,x
.b4b7	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b4b8	90 03		bcc $b4bd			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b4ba	4c 06 b5	jmp $b506			jmp 	CompareInteger32 							; so execute code at \1
.b4bd					_BCFloat:
.b4bd	20 aa b5	jsr $b5aa			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b4c0	4c de c2	jmp $c2de			jmp 	FPCompare 							; and execute code at \2
.b4c3	60		rts				rts
.b4c4					_CVString:
.b4c4	da		phx				phx 								; save XY
.b4c5	5a		phy				phy
.b4c6	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.b4c8	85 1a		sta $1a				sta		zLTemp1+0
.b4ca	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b4cc	85 1b		sta $1b				sta 	zLTemp1+1
.b4ce	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.b4d0	85 1c		sta $1c				sta 	zLTemp1+2
.b4d2	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.b4d4	85 1d		sta $1d				sta 	zLTemp1+3
.b4d6	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.b4d8	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b4da	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.b4dc	90 02		bcc $b4e0			bcc 	_CVCommon
.b4de	b1 1c		lda ($1c),y			lda 	(zLTemp1+2),y
.b4e0					_CVCommon:
.b4e0	aa		tax				tax 								; put shorter string length in zero.
.b4e1	f0 0c		beq $b4ef			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.b4e3					_CVCompare:
.b4e3	c8		iny				iny 								; next character
.b4e4	b1 1a		lda ($1a),y			lda 	(zLTemp1),y 				; compare characters
.b4e6	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.b4e8	90 13		bcc $b4fd			bcc 	_CVReturnLess 				; <
.b4ea	d0 15		bne $b501			bne 	_CVReturnGreater 			; >
.b4ec	ca		dex				dex 								; until common length matched.
.b4ed	d0 f4		bne $b4e3			bne 	_CVCompare
.b4ef					_CVMatch:
.b4ef	a0 00		ldy #$00			ldy 	#0
.b4f1	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b4f3	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.b4f5	90 06		bcc $b4fd			bcc 	_CVReturnLess 				; <
.b4f7	d0 08		bne $b501			bne 	_CVReturnGreater 			; >
.b4f9	a9 00		lda #$00			lda 	#0
.b4fb	80 06		bra $b503			bra 	_CVExit 					; same common, same length, same string
.b4fd					_CVReturnLess:
.b4fd	a9 ff		lda #$ff			lda 	#$FF
.b4ff	80 02		bra $b503			bra 	_CVExit
.b501					_CVReturnGreater:
.b501	a9 01		lda #$01			lda 	#$01
.b503					_CVExit:
.b503	7a		ply				ply
.b504	fa		plx				plx
.b505	60		rts				rts
.b506					CompareInteger32:
.b506	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.b508	49 80		eor #$80			eor 	#$80
.b50a	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b50c	b5 89		lda $89,x			lda 	XS2_Mantissa+3,x
.b50e	49 80		eor #$80			eor 	#$80
.b510	95 89		sta $89,x			sta 	XS2_Mantissa+3,x
.b512	20 90 b5	jsr $b590			jsr 	SubInteger32 				; subtraction
.b515	90 0d		bcc $b524			bcc 	_CI32Less 					; cc return -1
.b517	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check if zero
.b519	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.b51b	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.b51d	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.b51f	f0 02		beq $b523			beq 	_CI32Exit
.b521	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.b523					_CI32Exit:
.b523	60		rts				rts
.b524					_CI32Less:
.b524	a9 ff		lda #$ff			lda 	#$FF
.b526	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.b527					BinaryOp_Add:
.b527	b5 85		lda $85,x			lda 	XS_Type,x  					; and types together
.b529	35 8b		and $8b,x			and 	XS2_Type,x
.b52b	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.b52d	d0 11		bne $b540			bne 	_BOAString
.b52f	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b531	35 8b		and $8b,x			and 	XS2_Type,x
.b533	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b534	90 03		bcc $b539			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b536	4c 76 b5	jmp $b576			jmp 	AddInteger32 							; so execute code at \1
.b539					_BCFloat:
.b539	20 aa b5	jsr $b5aa			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b53c	4c b9 c0	jmp $c0b9			jmp 	FPAdd 							; and execute code at \2
.b53f	60		rts				rts
.b540					_BOAString:
.b540	4c c4 b5	jmp $b5c4			jmp 	ConcatenateString 			; concatenate two strings.
.b543					BinaryOp_Subtract:
.b543	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b545	35 8b		and $8b,x			and 	XS2_Type,x
.b547	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b548	90 03		bcc $b54d			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b54a	4c 90 b5	jmp $b590			jmp 	SubInteger32 							; so execute code at \1
.b54d					_BCFloat:
.b54d	20 aa b5	jsr $b5aa			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b550	4c b1 c0	jmp $c0b1			jmp 	FPSubtract 							; and execute code at \2
.b553	60		rts				rts
.b554					BinaryOp_Multiply:
.b554	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b556	35 8b		and $8b,x			and 	XS2_Type,x
.b558	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b559	90 03		bcc $b55e			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b55b	4c 8e be	jmp $be8e			jmp 	MulInteger32 							; so execute code at \1
.b55e					_BCFloat:
.b55e	20 aa b5	jsr $b5aa			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b561	4c e0 c1	jmp $c1e0			jmp 	FPMultiply 							; and execute code at \2
.b564	60		rts				rts
.b565					BinaryOp_Divide:
.b565	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b567	35 8b		and $8b,x			and 	XS2_Type,x
.b569	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b56a	90 03		bcc $b56f			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b56c	4c cc be	jmp $becc			jmp 	DivInteger32 							; so execute code at \1
.b56f					_BCFloat:
.b56f	20 aa b5	jsr $b5aa			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b572	4c 6d c1	jmp $c16d			jmp 	FPDivide 							; and execute code at \2
.b575	60		rts				rts
.b576					AddInteger32:
.b576	18		clc				clc
.b577	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.b579	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.b57b	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b57d	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b57f	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.b581	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b583	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.b585	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.b587	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b589	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.b58b	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.b58d	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b58f	60		rts				rts
.b590					SubInteger32:
.b590	38		sec				sec
.b591	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.b593	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.b595	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b597	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b599	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.b59b	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b59d	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.b59f	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.b5a1	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b5a3	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.b5a5	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.b5a7	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b5a9	60		rts				rts
.b5aa					BinaryMakeBothFloat:
.b5aa	da		phx				phx 								; save X
.b5ab	e8		inx				inx
.b5ac	e8		inx				inx
.b5ad	e8		inx				inx
.b5ae	e8		inx				inx
.b5af	e8		inx				inx
.b5b0	e8		inx				inx
.b5b1	20 b5 b5	jsr $b5b5			jsr 	BinaryMakeFloat 			; convert to float.
.b5b4	fa		plx				plx 								; restore X and fall through.
.b5b5					BinaryMakeFloat:
.b5b5	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.b5b7	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.b5b8	b0 04		bcs $b5be			bcs 	_BMFConvert
.b5ba	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.b5bb	b0 04		bcs $b5c1			bcs 	_BMFError
.b5bd	60		rts				rts
.b5be					_BMFConvert:
.b5be	4c 5c c3	jmp $c35c			jmp 	FPUToFloat 					; convert to float
.b5c1					_BMFError:
.b5c1	4c 2d ad	jmp $ad2d			jmp 	TypeError
.b5c4					ConcatenateString:
.b5c4	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.b5c6	85 1a		sta $1a				sta		zLTemp1+0
.b5c8	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b5ca	85 1b		sta $1b				sta 	zLTemp1+1
.b5cc	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.b5ce	85 1c		sta $1c				sta 	zLTemp1+2
.b5d0	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.b5d2	85 1d		sta $1d				sta 	zLTemp1+3
.b5d4	5a		phy				phy
.b5d5	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.b5d7	b1 1a		lda ($1a),y			lda 	(zlTemp1),y
.b5d9	71 1c		adc ($1c),y			adc 	(zlTemp1+2),y
.b5db	7a		ply				ply
.b5dc	b0 33		bcs $b611			bcs 	_CSError					; check in range.
.b5de	c9 fe		cmp #$fe			cmp 	#maxString+1
.b5e0	b0 2f		bcs $b611			bcs 	_CSError
.b5e2	20 28 ba	jsr $ba28			jsr 	AllocateTempString 			; store the result
.b5e5	20 fc b5	jsr $b5fc			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.b5e8	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.b5ea	85 1a		sta $1a				sta 	zLTemp1
.b5ec	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.b5ee	85 1b		sta $1b				sta 	zLTemp1+1
.b5f0	20 fc b5	jsr $b5fc			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.b5f3	a5 20		lda $20				lda 	zTempStr 					; point current to new string
.b5f5	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b5f7	a5 21		lda $21				lda 	zTempStr+1
.b5f9	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b5fb	60		rts				rts
.b5fc					_CSCopyString:
.b5fc	da		phx				phx
.b5fd	5a		phy				phy
.b5fe	a0 00		ldy #$00			ldy 	#0 							; get length
.b600	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b602	f0 0a		beq $b60e			beq 	_CSCSExit 					; if zero, exit
.b604	aa		tax				tax 								; put in X
.b605					_CSCSLoop:
.b605	c8		iny				iny 								; get next char
.b606	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b608	20 53 ba	jsr $ba53			jsr		WriteTempString 			; copy out
.b60b	ca		dex				dex 								; do whole string
.b60c	d0 f7		bne $b605			bne 	_CSCSLoop
.b60e					_CSCSExit:
.b60e	7a		ply				ply
.b60f	fa		plx				plx
.b610	60		rts				rts
.b611					_CSError:
.b611	20 4c ad	jsr $ad4c			jsr ERR_Handler
>b614	53 74 72 69 6e 67 20 74			.text "String too long",0
>b61c	6f 6f 20 6c 6f 6e 67 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.b624					Unary_Sgn:
.b624	20 ca b3	jsr $b3ca			jsr 	EvaluateNumberX 			; get value
.b627	20 e6 b9	jsr $b9e6			jsr 	CheckNextRParen 			; check right bracket.
.b62a	20 48 b6	jsr $b648			jsr 	GetSignCurrent 				; get sign.
.b62d	09 00		ora #$00			ora 	#0
.b62f	10 08		bpl $b639			bpl		UnarySetAInteger			; if 0,1 return that.
.b631	80 00		bra $b633			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.b633					UnarySetAMinus1:
.b633	a9 ff		lda #$ff			lda 	#$FF
.b635	95 80		sta $80,x			sta 	XS_Mantissa,x
.b637	80 04		bra $b63d			bra 	UnarySetAFill
.b639					UnarySetAInteger:
.b639	95 80		sta $80,x			sta 	XS_Mantissa,x
.b63b	a9 00		lda #$00			lda 	#0
.b63d					UnarySetAFill:
.b63d	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b63f	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b641	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b643	a9 01		lda #$01			lda 	#1
.b645	95 85		sta $85,x			sta 	XS_Type,x
.b647	60		rts				rts
.b648					GetSignCurrent:
.b648	b5 85		lda $85,x			lda 	XS_Type,x 					; identify type.
.b64a	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.b64b	90 15		bcc $b662			bcc 	_GSCFloat
.b64d	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.b64f	30 0e		bmi $b65f			bmi 	_GSCMinus1
.b651	15 80		ora $80,x			ora 	XS_Mantissa+0,x
.b653	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.b655	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.b657	d0 03		bne $b65c			bne 	_GSCPlus1
.b659					_GSCZero:
.b659	a9 00		lda #$00			lda 	#0
.b65b	60		rts				rts
.b65c					_GSCPlus1:
.b65c	a9 01		lda #$01			lda 	#$01
.b65e	60		rts				rts
.b65f					_GSCMinus1:
.b65f	a9 ff		lda #$ff			lda 	#$FF
.b661	60		rts				rts
.b662					_GSCFloat:
.b662	34 85		bit $85,x			bit 	XS_Type,x
.b664	70 f3		bvs $b659			bvs 	_GSCZero
.b666	30 f7		bmi $b65f			bmi 	_GSCMinus1
.b668	80 f2		bra $b65c			bra 	_GSCPlus1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.b66a					Unary_Abs:
.b66a	20 ca b3	jsr $b3ca			jsr 	EvaluateNumberX 			; get value
.b66d	20 e6 b9	jsr $b9e6			jsr 	CheckNextRParen 			; check right bracket.
.b670	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.b672	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.b674	f0 07		beq $b67d			beq 	_UAMinusFloat
.b676	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; check MSB
.b678	10 09		bpl $b683			bpl 	_UAExit
.b67a	4c 53 bf	jmp $bf53			jmp 	IntegerNegateAlways 		; negation
.b67d					_UAMinusFloat:
.b67d	b5 85		lda $85,x			lda 	XS_Type,x 					; clear the sign bit.
.b67f	29 7f		and #$7f			and		#$7F
.b681	95 85		sta $85,x			sta 	XS_Type,x
.b683					_UAExit:
.b683	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.b684					Unary_Peek:
.b684	a9 01		lda #$01			lda 	#1
.b686	80 06		bra $b68e			bra 	UPMain
.b688					Unary_Deek:
.b688	a9 02		lda #$02			lda 	#2
.b68a	80 02		bra $b68e			bra 	UPMain
.b68c					Unary_Leek:
.b68c	a9 04		lda #$04			lda 	#4
.b68e					UPMain:
.b68e	48		pha				pha 								; set bytes to copy.
.b68f	20 d8 b3	jsr $b3d8			jsr 	EvaluateIntegerX 			; numeric parameter
.b692	20 e6 b9	jsr $b9e6			jsr 	CheckNextRParen 			; right bracket.
.b695	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.b697	85 1a		sta $1a				sta 	zLTemp1
.b699	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b69b	85 1b		sta $1b				sta 	zLTemp1+1
.b69d	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.b69f	85 1c		sta $1c				sta 	zLTemp1+2
.b6a1	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.b6a3	85 1d		sta $1d				sta 	zLTemp1+3
.b6a5	a9 00		lda #$00			lda 	#0 							; clear target area
.b6a7	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b6a9	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b6ab	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b6ad	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b6af	68		pla				pla 								; restore bytes to copy
.b6b0	da		phx				phx 								; save XY
.b6b1	5a		phy				phy
.b6b2	20 7f b9	jsr $b97f			jsr 	MemRead 					; read the bytes in
.b6b5	7a		ply				ply 								; restore and exit
.b6b6	fa		plx				plx
.b6b7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.b6b8					Unary_Mod:
.b6b8	20 e0 b6	jsr $b6e0			jsr 	_UMParameter 				; first parameter
.b6bb	20 ef b9	jsr $b9ef			jsr 	CheckNextComma
.b6be	da		phx				phx 								; second parameter
.b6bf	e8		inx				inx
.b6c0	e8		inx				inx
.b6c1	e8		inx				inx
.b6c2	e8		inx				inx
.b6c3	e8		inx				inx
.b6c4	e8		inx				inx
.b6c5	20 e0 b6	jsr $b6e0			jsr 	_UMParameter
.b6c8	fa		plx				plx
.b6c9	20 e6 b9	jsr $b9e6			jsr 	CheckNextRParen
.b6cc	20 cc be	jsr $becc			jsr 	DivInteger32 				; divide
.b6cf	a5 1a		lda $1a				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.b6d1	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b6d3	a5 1b		lda $1b				lda 	zLTemp1+1
.b6d5	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b6d7	a5 1c		lda $1c				lda 	zLTemp1+2
.b6d9	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b6db	a5 1d		lda $1d				lda 	zLTemp1+3
.b6dd	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b6df	60		rts				rts
.b6e0					_UMParameter:
.b6e0	20 d8 b3	jsr $b3d8			jsr 	EvaluateIntegerX 			; get value
.b6e3	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; absolute value
.b6e5	10 03		bpl $b6ea			bpl 	_UMNotSigned
.b6e7	20 53 bf	jsr $bf53			jsr 	IntegerNegateAlways
.b6ea					_UMNotSigned:
.b6ea	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.b6eb					Unary_Usr:
.b6eb	20 ca b3	jsr $b3ca			jsr 	EvaluateNumberX 			; numeric parameter
.b6ee	20 e6 b9	jsr $b9e6			jsr 	CheckNextRParen 			; right bracket.
.b6f1	da		phx				phx 								; save XY
.b6f2	5a		phy				phy
.b6f3	ea		nop				nop
.b6f4	20 06 03	jsr $0306			jsr 	UserVector 					; call the USR function.
.b6f7	7a		ply				ply 								; and exit
.b6f8	fa		plx				plx
.b6f9	60		rts				rts
.b6fa					USRDefault:
.b6fa	20 4c ad	jsr $ad4c			jsr ERR_Handler
>b6fd	4e 6f 20 55 53 52 20 76			.text "No USR vector.",0
>b705	65 63 74 6f 72 2e 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.b70c					Unary_Val:
.b70c	20 e1 b3	jsr $b3e1			jsr 	EvaluateStringX 			; get string
.b70f	20 e6 b9	jsr $b9e6			jsr 	CheckNextRParen 			; check right bracket.
.b712	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.b714	85 1e		sta $1e				sta 	zGenPtr
.b716	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b718	85 1f		sta $1f				sta 	zGenPtr+1
.b71a	5a		phy				phy
.b71b	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.b71d	b1 1e		lda ($1e),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.b71f	f0 54		beq $b775			beq 	_UVBadNumber
.b721	48		pha				pha 								; save length.
.b722	1a		inc a				inc 	a 							; one for the length, one for the terminator
.b723	1a		inc a				inc 	a
.b724	20 28 ba	jsr $ba28			jsr 	AllocateTempString
.b727	c8		iny				iny 								; move to the next.
.b728	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get character
.b72a	49 2d		eor #$2d			eor 	#"-"						; zero if minus sign
.b72c	8d 9a 03	sta $039a			sta 	ValSign
.b72f	d0 04		bne $b735			bne 	_UVNotMinus
.b731	c8		iny				iny 								; skip over it.
.b732	68		pla				pla 								; decrement character count.
.b733	3a		dec a				dec 	a
.b734	48		pha				pha
.b735					_UVNotMinus:
.b735	68		pla				pla 								; this is the count.
.b736	48		pha		_UVCopy:pha									; copy into new temp string which is ASCIIZ
.b737	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b739	c8		iny				iny
.b73a	20 53 ba	jsr $ba53			jsr 	WriteTempString
.b73d	68		pla				pla
.b73e	3a		dec a				dec 	a
.b73f	d0 f5		bne $b736			bne 	_UVCopy
.b741	20 53 ba	jsr $ba53			jsr 	WriteTempString 			; make it ASCIIZ
.b744	18		clc				clc
.b745	a5 20		lda $20				lda 	zTempStr 					; tempstring +1 => genptr
.b747	69 01		adc #$01			adc 	#1
.b749	85 1e		sta $1e				sta 	zGenPtr
.b74b	a5 21		lda $21				lda 	zTempStr+1
.b74d	69 00		adc #$00			adc 	#0
.b74f	85 1f		sta $1f				sta 	zGenPtr+1
.b751	18		clc				clc
.b752	20 21 c0	jsr $c021			jsr 	IntFromString 				; first bit.
.b755	b0 1e		bcs $b775			bcs 	_UVBadNumber
.b757	20 62 c5	jsr $c562			jsr 	FPFromString				; try for a float part.
.b75a	ad 9a 03	lda $039a			lda 	ValSign 					; was it negative
.b75d	d0 10		bne $b76f			bne 	_UVNotNegative
.b75f	b5 85		lda $85,x			lda 	XS_Type,x 					; check if integer
.b761	4a		lsr a				lsr 	a
.b762	b0 08		bcs $b76c			bcs 	_UVInteger
.b764	b5 85		lda $85,x			lda 	XS_Type,x 					; set sign bit
.b766	09 80		ora #$80			ora 	#$80
.b768	95 85		sta $85,x			sta 	XS_Type,x
.b76a	80 03		bra $b76f			bra 	_UVNotNegative
.b76c					_UVInteger:
.b76c	20 53 bf	jsr $bf53			jsr 	IntegerNegateAlways 		; sign it.
.b76f					_UVNotNegative:
.b76f	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; used everything
.b771	d0 02		bne $b775			bne 	_UVBadNumber
.b773	7a		ply				ply
.b774	60		rts				rts
.b775					_UVBadNumber:
.b775	4c 3b ad	jmp $ad3b			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.b778					Unary_Str:
.b778	20 ca b3	jsr $b3ca			jsr 	EvaluateNumberX 			; numeric parameter
.b77b	20 e6 b9	jsr $b9e6			jsr 	CheckNextRParen 			; right bracket.
.b77e	a9 00		lda #$00			lda 	#0 							; reset buffer index
.b780	8d 0e 03	sta $030e			sta 	NumBufX
.b783	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.b785	4a		lsr a				lsr 	a
.b786	b0 05		bcs $b78d			bcs 	_USInt 						; if msb set do as integer
.b788	20 a7 c4	jsr $c4a7			jsr 	FPToString 					; call fp to str otherwise
.b78b	80 03		bra $b790			bra 	_USDuplicate
.b78d	20 70 bf	jsr $bf70	_USInt:	jsr 	IntToString
.b790					_USDuplicate:
.b790	ad 0e 03	lda $030e			lda 	NumBufX 					; chars in buffer
.b793	1a		inc a				inc 	a 							; one more for length
.b794	20 28 ba	jsr $ba28			jsr 	AllocateTempString 			; allocate space for it.
.b797	5a		phy				phy 								; save Y
.b798	a0 00		ldy #$00			ldy 	#0 							; start copying
.b79a	b9 0f 03	lda $030f,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.b79d	20 53 ba	jsr $ba53			jsr 	WriteTempString
.b7a0	c8		iny				iny
.b7a1	cc 0e 03	cpy $030e			cpy 	NumBufX 					; done the lot
.b7a4	d0 f4		bne $b79a			bne 	_USCopy
.b7a6	7a		ply				ply 								; restore Y
.b7a7	4c 72 b9	jmp $b972			jmp 	UnaryReturnTempStr 			; return new temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.b7aa					Unary_Asc:
.b7aa	20 e1 b3	jsr $b3e1			jsr 	EvaluateStringX 			; string parameter
.b7ad	20 e6 b9	jsr $b9e6			jsr 	CheckNextRParen 			; right bracket.
.b7b0	5a		phy				phy 								; get the string length
.b7b1	a0 00		ldy #$00			ldy 	#0
.b7b3	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b7b5	f0 07		beq $b7be			beq 	_UAIllegal 					; must be at least one character
.b7b7	c8		iny				iny
.b7b8	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; read it.
.b7ba	7a		ply				ply
.b7bb	4c 39 b6	jmp $b639			jmp 	UnarySetAInteger
.b7be					_UAIllegal:
.b7be	4c 3b ad	jmp $ad3b			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.b7c1					Unary_Len:
.b7c1	20 e1 b3	jsr $b3e1			jsr 	EvaluateStringX 			; string parameter
.b7c4	20 e6 b9	jsr $b9e6			jsr 	CheckNextRParen 			; right bracket.
.b7c7	5a		phy				phy 								; get the string length
.b7c8	a0 00		ldy #$00			ldy 	#0
.b7ca	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b7cc	7a		ply				ply
.b7cd	4c 39 b6	jmp $b639			jmp 	UnarySetAInteger

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.b7d0					Unary_Mid:
.b7d0	20 e1 b3	jsr $b3e1			jsr 	EvaluateStringX 				; get string.
.b7d3	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.b7d5	48		pha				pha
.b7d6	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b7d8	48		pha				pha
.b7d9	20 ef b9	jsr $b9ef			jsr 	CheckNextComma 					; skip comma
.b7dc	20 65 b8	jsr $b865			jsr 	SLIByteParameter 				; get a byte parameter (start)
.b7df	48		pha				pha 									; and push it.
.b7e0	20 ef b9	jsr $b9ef			jsr 	CheckNextComma 					; skip comma
.b7e3	20 65 b8	jsr $b865			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.b7e6	48		pha				pha 									; and push it.
.b7e7	80 41		bra $b82a			bra 	SLIProcess
.b7e9					Unary_Left:
.b7e9	20 e1 b3	jsr $b3e1			jsr 	EvaluateStringX 				; get string.
.b7ec	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.b7ee	48		pha				pha
.b7ef	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b7f1	48		pha				pha
.b7f2	a9 01		lda #$01			lda 	#1 								; push start position (1)
.b7f4	48		pha				pha
.b7f5	20 ef b9	jsr $b9ef			jsr 	CheckNextComma 					; skip comma
.b7f8	20 65 b8	jsr $b865			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.b7fb	48		pha				pha 									; and push it.
.b7fc	80 2c		bra $b82a			bra 	SLIProcess
.b7fe					Unary_Right:
.b7fe	20 e1 b3	jsr $b3e1			jsr 	EvaluateStringX 				; get string.
.b801	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.b803	48		pha				pha
.b804	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b806	48		pha				pha
.b807	da		phx				phx 									; get the string length and push on stack.
.b808	a2 00		ldx #$00			ldx 	#0
.b80a	a1 1e		lda ($1e,x)			lda		(zGenPtr,x)
.b80c	fa		plx				plx
.b80d	48		pha				pha
.b80e	20 ef b9	jsr $b9ef			jsr 	CheckNextComma 					; skip comma
.b811	20 65 b8	jsr $b865			jsr 	SLIByteParameter 				; get a byte parameter.
.b814	8d 98 03	sta $0398			sta 	SignCount 						; save in temporary.
.b817	68		pla				pla 									; restore string length.
.b818	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.b819	38		sec				sec
.b81a	ed 98 03	sbc $0398			sbc 	SignCount 						; subtract characters needed, gives start position.
.b81d	f0 02		beq $b821			beq 	_URStart 						; if <= 0 start from 1.
.b81f	10 02		bpl $b823			bpl 	_UROkay
.b821					_URStart:
.b821	a9 01		lda #$01			lda 	#1
.b823					_UROkay:
.b823	48		pha				pha 									; push start
.b824	ad 98 03	lda $0398			lda 	SignCount 						; push count of characters
.b827	48		pha				pha
.b828	80 00		bra $b82a			bra 	SLIProcess
.b82a					SLIProcess:
.b82a	20 e6 b9	jsr $b9e6			jsr 	CheckNextRParen 				; closing right bracket.
.b82d	68		pla				pla
.b82e	8d 9c 03	sta $039c			sta 	SliceCount 						; count in signcount
.b831	1a		inc a				inc 	a 								; allocate +1 for it.
.b832	20 28 ba	jsr $ba28			jsr 	AllocateTempString
.b835	68		pla				pla 									; pop start number off stack.
.b836	f0 3b		beq $b873			beq 	SLIError 						; exit if start = 0
.b838	8d 9b 03	sta $039b			sta 	SliceStart
.b83b	68		pla				pla  									; pop string address.
.b83c	85 1f		sta $1f				sta 	zGenPtr+1
.b83e	68		pla				pla
.b83f	85 1e		sta $1e				sta 	zGenPtr
.b841	da		phx				phx
.b842	5a		phy				phy
.b843	a2 00		ldx #$00			ldx 	#0 								; point to string length.
.b845	ac 9b 03	ldy $039b			ldy 	SliceStart 						; start of the string (+1 for count)
.b848					_SLICopy:
.b848	ad 9c 03	lda $039c			lda 	SliceCount 						; done count characters
.b84b	f0 12		beq $b85f			beq 	_SLIExit
.b84d	ce 9c 03	dec $039c			dec 	SliceCount
.b850	98		tya				tya 									; index of character
.b851	c1 1e		cmp ($1e,x)			cmp 	(zGenPtr,x)						; compare against length
.b853	f0 02		beq $b857			beq 	_SLIOk 							; if equal, okay.
.b855	b0 08		bcs $b85f			bcs 	_SLIExit 						; if past end, then exit.
.b857	b1 1e		lda ($1e),y	_SLIOk:	lda 	(zGenPtr),y 					; copy one character
.b859	c8		iny				iny
.b85a	20 53 ba	jsr $ba53			jsr 	WriteTempString
.b85d	80 e9		bra $b848			bra 	_SLICopy 						; go round till copied characters
.b85f					_SLIExit:
.b85f	7a		ply				ply 									; restore YX
.b860	fa		plx				plx
.b861	4c 72 b9	jmp $b972			jmp 	UnaryReturnTempStr 				; return new temporary string.
.b864	ea		nop				nop
.b865					SLIByteParameter:
.b865	20 d8 b3	jsr $b3d8			jsr 	EvaluateIntegerX 				; get integer
.b868	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.b86a	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.b86c	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.b86e	d0 03		bne $b873			bne 	SLIError
.b870	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.b872	60		rts				rts
.b873					SLIError:
.b873	4c 3b ad	jmp $ad3b			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.b876					Unary_Hex:
.b876	20 d8 b3	jsr $b3d8			jsr 	EvaluateIntegerX 			; numeric parameter
.b879	20 e6 b9	jsr $b9e6			jsr 	CheckNextRParen 			; right bracket.
.b87c	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.b87e	20 28 ba	jsr $ba28			jsr 	AllocateTempString			; allocate string space
.b881	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.b883	20 a7 b8	jsr $b8a7			jsr 	_UHConvert
.b886	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.b888	20 a7 b8	jsr $b8a7			jsr 	_UHConvert
.b88b	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b88d	20 a7 b8	jsr $b8a7			jsr 	_UHConvert
.b890	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.b892	20 a7 b8	jsr $b8a7			jsr 	_UHConvert
.b895	5a		phy				phy 								; get length of new string
.b896	a0 00		ldy #$00			ldy 	#0
.b898	b1 20		lda ($20),y			lda 	(zTempStr),y
.b89a	7a		ply				ply
.b89b	c9 00		cmp #$00			cmp 	#0
.b89d	d0 05		bne $b8a4			bne 	_UHExit 					; if it was non zero okay
.b89f	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.b8a1	20 53 ba	jsr $ba53			jsr 	WriteTempString
.b8a4					_UHExit:
.b8a4	4c 72 b9	jmp $b972			jmp 	UnaryReturnTempStr 			; return new temporary string.
.b8a7					_UHConvert:
.b8a7	48		pha				pha
.b8a8	4a		lsr a				lsr 	a 							; do MSB
.b8a9	4a		lsr a				lsr 	a
.b8aa	4a		lsr a				lsr 	a
.b8ab	4a		lsr a				lsr 	a
.b8ac	20 b0 b8	jsr $b8b0			jsr 	_UHNibble
.b8af	68		pla				pla 								; do LSB
.b8b0					_UHNibble:
.b8b0	29 0f		and #$0f			and 	#15 						; get nibble
.b8b2	d0 0c		bne $b8c0			bne 	_UHNonZero
.b8b4	5a		phy				phy									; get the length
.b8b5	a0 00		ldy #$00			ldy 	#0
.b8b7	b1 20		lda ($20),y			lda 	(zTempStr),y
.b8b9	7a		ply				ply
.b8ba	c9 00		cmp #$00			cmp 	#0 							; suppress leading zeros.
.b8bc	f0 0d		beq $b8cb			beq 	_UHExit2
.b8be	a9 00		lda #$00			lda 	#0
.b8c0					_UHNonZero:
.b8c0	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.b8c2	90 02		bcc $b8c6			bcc 	_UHDigit
.b8c4	69 06		adc #$06			adc 	#7-1
.b8c6					_UHDigit:
.b8c6	69 30		adc #$30			adc 	#48
.b8c8	20 53 ba	jsr $ba53			jsr 	WriteTempString				; output.
.b8cb					_UHExit2:
.b8cb	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.b8cc					Unary_Dec:
.b8cc	20 e1 b3	jsr $b3e1			jsr 	EvaluateStringX 			; string parameter
.b8cf	20 e6 b9	jsr $b9e6			jsr 	CheckNextRParen 			; right bracket.
.b8d2	5a		phy				phy
.b8d3	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.b8d5	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b8d7	f0 41		beq $b91a			beq 	_UDFail 					; must fail if zero.
.b8d9	8d 98 03	sta $0398			sta 	SignCount 					; use SignCount as a counter
.b8dc	a9 00		lda #$00			lda 	#0 							; set result to zero integer.
.b8de	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b8e0	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b8e2	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b8e4	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b8e6	a9 01		lda #$01			lda 	#1
.b8e8	95 85		sta $85,x			sta 	XS_Type,x
.b8ea					_UDConvertLoop:
.b8ea	5a		phy				phy 								; shift mantissa left 4
.b8eb	a0 04		ldy #$04			ldy 	#4
.b8ed					_UDShift:
.b8ed	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.b8ef	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.b8f1	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.b8f3	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.b8f5	88		dey				dey
.b8f6	d0 f5		bne $b8ed			bne 	_UDShift
.b8f8	7a		ply				ply
.b8f9	c8		iny				iny 								; next character
.b8fa	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; fetch it.
.b8fc	20 1d b9	jsr $b91d			jsr 	ConvertUpper 				; convert to U/C
.b8ff	c9 30		cmp #$30			cmp 	#"0"
.b901	90 17		bcc $b91a			bcc 	_UDFail
.b903	c9 3a		cmp #$3a			cmp 	#"9"+1
.b905	90 06		bcc $b90d			bcc 	_UDOkay
.b907	e9 37		sbc #$37			sbc 	#7+"0" 						; alpha fudge
.b909	c9 10		cmp #$10			cmp 	#16
.b90b	b0 0d		bcs $b91a			bcs 	_UDFail
.b90d					_UDOkay:
.b90d	29 0f		and #$0f			and 	#15 						; nibble only
.b90f	15 80		ora $80,x			ora 	XS_Mantissa+0,x
.b911	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b913	ce 98 03	dec $0398			dec 	SignCount 					; do it for each character
.b916	d0 d2		bne $b8ea			bne 	_UDConvertLoop
.b918	7a		ply				ply
.b919	60		rts				rts
.b91a					_UDFail:
.b91a	4c 3b ad	jmp $ad3b			jmp 	BadParamError
.b91d					ConvertUpper:
.b91d	c9 61		cmp #$61			cmp 	#"a"
.b91f	90 07		bcc $b928			bcc 	_CUExit
.b921	c9 7b		cmp #$7b			cmp 	#"z"+1
.b923	b0 03		bcs $b928			bcs 	_CUExit
.b925	38		sec				sec
.b926	e9 20		sbc #$20			sbc 	#32
.b928	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.b929					Unary_Chr:
.b929	20 d8 b3	jsr $b3d8			jsr 	EvaluateIntegerX			; numeric parameter
.b92c	20 e6 b9	jsr $b9e6			jsr 	CheckNextRParen 			; right bracket.
.b92f	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.b931	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.b933	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.b935	d0 0d		bne $b944			bne 	_UCChar
.b937	a9 01		lda #$01			lda 	#1 							; one character string
.b939	20 28 ba	jsr $ba28			jsr 	AllocateTempString
.b93c	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.b93e	20 53 ba	jsr $ba53			jsr 	WriteTempString
.b941	4c 72 b9	jmp $b972			jmp 	UnaryReturnTempStr
.b944					_UCChar:
.b944	4c 3b ad	jmp $ad3b			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.b947					Unary_Spc:
.b947	20 d8 b3	jsr $b3d8			jsr 	EvaluateIntegerX 			; numeric parameter
.b94a	20 e6 b9	jsr $b9e6			jsr 	CheckNextRParen 			; right bracket.
.b94d	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.b94f	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.b951	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.b953	d0 1a		bne $b96f			bne 	_USSize
.b955	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.b957	c9 fe		cmp #$fe			cmp 	#maxString+1
.b959	b0 14		bcs $b96f			bcs 	_USSize
.b95b	48		pha				pha 								; save length
.b95c	1a		inc a				inc 	a 							; allocate one more.
.b95d	20 28 ba	jsr $ba28			jsr 	AllocateTempString
.b960	68		pla				pla 								; get length
.b961	f0 0f		beq $b972			beq 	UnaryReturnTempStr 			; return the current temp string
.b963					_USLoop:
.b963	48		pha				pha
.b964	a9 20		lda #$20			lda 	#" "
.b966	20 53 ba	jsr $ba53			jsr 	WriteTempString
.b969	68		pla				pla
.b96a	3a		dec a				dec 	a
.b96b	d0 f6		bne $b963			bne 	_USLoop
.b96d	80 03		bra $b972			bra 	UnaryReturnTempStr
.b96f					_USSize:
.b96f	4c 3b ad	jmp $ad3b			jmp 	BadParamError
.b972					UnaryReturnTempStr:
.b972	a5 20		lda $20				lda 	zTempStr 					; copy temp string addr -> mantissa
.b974	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b976	a5 21		lda $21				lda 	zTempStr+1
.b978	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b97a	a9 02		lda #$02			lda 	#2 							; set type to string
.b97c	95 85		sta $85,x			sta 	XS_Type,x
.b97e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/4510.asm

.b97f	db		phz		MemRead:phz
.b980	8d 98 03	sta $0398			sta 	SignCount 					; save count
.b983	a3 00		ldz #$00			ldz 	#0 							; start from here
.b985	ea		nop		_MLoop1:nop
.b986	b2 1a		lda ($1a),z			lda 	(zlTemp1),z 				; read the long address
.b988	95 80		sta $80,x			sta 	XS_Mantissa,x 				; copy into mantissa
.b98a	1b		inz				inz 								; next to copy
.b98b	e8		inx				inx
.b98c	dc 98 03	cpz $0398			cpz 	SignCount 					; do required # of bytes.
.b98f	d0 f4		bne $b985			bne 	_MLoop1
.b991	fb		plz				plz
.b992	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/programend.asm

.b993					UpdateProgramEnd:
.b993	a9 00		lda #$00			lda 	#BasicProgram & $FF
.b995	85 16		sta $16				sta 	zCodePtr+0
.b997	a9 80		lda #$80			lda 	#BasicProgram >> 8
.b999	85 17		sta $17				sta 	zCodePtr+1
.b99b	a9 02		lda #$02			lda 	#2
.b99d	85 18		sta $18				sta 	zCodePtr+2
.b99f	a9 00		lda #$00			lda 	#0
.b9a1	85 19		sta $19				sta 	zCodePtr+3
.b9a3	a3 03		ldz #$03			ldz 	#3
.b9a5					_UPDLoop:
.b9a5	a3 00		ldz #$00			ldz 	#0
.b9a7	ea		nop				nop
.b9a8	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b9aa	c9 00		cmp #$00			cmp 	#0 							; end if offset is zero.
.b9ac	f0 10		beq $b9be			beq 	_UPDFoundEnd
.b9ae	a3 00		ldz #$00			ldz 	#0 							; point to offset
.b9b0	ea		nop				nop
.b9b1	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read it
.b9b3	18		clc				clc
.b9b4	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.b9b6	85 16		sta $16				sta 	zCodePtr
.b9b8	90 02		bcc $b9bc			bcc 	_SNLNoCarry
.b9ba	e6 17		inc $17				inc 	zCodePtr+1
.b9bc					_SNLNoCarry:
.b9bc	80 e7		bra $b9a5			bra 	_UPDLoop
.b9be					_UPDFoundEnd:
.b9be	18		clc				clc 								; end of program 2 on.
.b9bf	a5 16		lda $16				lda 	zCodePtr
.b9c1	69 02		adc #$02			adc 	#2
.b9c3	8d 04 03	sta $0304			sta 	endOfProgram
.b9c6	a5 17		lda $17				lda 	zCodePtr+1
.b9c8	69 00		adc #$00			adc 	#0
.b9ca	8d 05 03	sta $0305			sta 	endOfProgram+1
.b9cd	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.b9ce					CheckNextToken:
.b9ce	ea		nop				nop
.b9cf	d2 16		cmp ($16),z			cmp 	(zCodePtr),z
.b9d1	d0 02		bne $b9d5			bne 	CTFail 						; no, then fail
.b9d3	1b		inz				inz
.b9d4	60		rts				rts
.b9d5					CTFail:
.b9d5	20 4c ad	jsr $ad4c			jsr ERR_Handler
>b9d8	4d 69 73 73 69 6e 67 20			.text "Missing token",0
>b9e0	74 6f 6b 65 6e 00
.b9e6					CheckNextRParen:
.b9e6	ea		nop				nop
.b9e7	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b9e9	c9 be		cmp #$be			cmp 	#token_rparen
.b9eb	d0 e8		bne $b9d5			bne 	CTFail
.b9ed	1b		inz				inz
.b9ee	60		rts				rts
.b9ef					CheckNextComma:
.b9ef	ea		nop				nop
.b9f0	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b9f2	c9 bf		cmp #$bf			cmp 	#token_comma
.b9f4	d0 df		bne $b9d5			bne 	CTFail
.b9f6	1b		inz				inz
.b9f7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/concrete.asm

.b9f8					StringConcrete:
.b9f8	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; save source to zTemp1
.b9fa	85 10		sta $10				sta 	zTemp1
.b9fc	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b9fe	85 11		sta $11				sta 	zTemp1+1
.ba00	a0 00		ldy #$00			ldy 	#0 							; subtract the length+1 (clc) of the string.
.ba02	18		clc				clc 								; from the string pointer
.ba03	ad 00 03	lda $0300			lda 	StringPtr 					; and put in zTemp2 as well
.ba06	f1 10		sbc ($10),y			sbc 	(zTemp1),y
.ba08	8d 00 03	sta $0300			sta 	StringPtr
.ba0b	85 12		sta $12				sta 	zTemp2
.ba0d	ad 01 03	lda $0301			lda 	StringPtr+1
.ba10	e9 00		sbc #$00			sbc 	#0
.ba12	8d 01 03	sta $0301			sta 	StringPtr+1
.ba15	85 13		sta $13				sta 	zTemp2+1
.ba17	b1 10		lda ($10),y			lda 	(zTemp1),y 					; length add one for count
.ba19	1a		inc a				inc 	a
.ba1a	aa		tax				tax
.ba1b	b1 10		lda ($10),y	_SCCopy:lda 	(zTemp1),y 					; copy whole thing including length
.ba1d	91 12		sta ($12),y			sta 	(zTemp2),y
.ba1f	c8		iny				iny
.ba20	ca		dex				dex
.ba21	d0 f8		bne $ba1b			bne 	_SCCopy
.ba23	a5 13		lda $13				lda 	zTemp2+1 					; return concrete string in AX
.ba25	a6 12		ldx $12				ldx 	zTemp2
.ba27	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.ba28					AllocateTempString:
.ba28	48		pha				pha 								; save required count.
.ba29	a5 21		lda $21				lda 	zTempStr+1 					; check if initialised yet ?
.ba2b	d0 0b		bne $ba38			bne 	_ATSInitialised
.ba2d	ad 00 03	lda $0300			lda 	StringPtr 					; set temporary string ptr 1 page below available
.ba30	85 20		sta $20				sta 	zTempStr					; space, this is for strings to be concreted.
.ba32	ad 01 03	lda $0301			lda 	StringPtr+1
.ba35	3a		dec a				dec 	a
.ba36	85 21		sta $21				sta 	zTempStr+1
.ba38					_ATSInitialised:
.ba38	68		pla				pla 								; get required count back.
.ba39	49 ff		eor #$ff			eor 	#$FF 						; negate 2's complement.
.ba3b	1a		inc a				inc 	a
.ba3c	18		clc				clc
.ba3d	65 20		adc $20				adc 	zTempStr 					; "add" to the temp string pointer
.ba3f	85 20		sta $20				sta 	zTempStr
.ba41	a9 ff		lda #$ff			lda 	#$FF
.ba43	65 21		adc $21				adc 	zTempStr+1
.ba45	85 21		sta $21				sta 	zTempStr+1
.ba47	a9 00		lda #$00			lda 	#0 							; clear temp string.
.ba49	5a		phy				phy
.ba4a	a8		tay				tay
.ba4b	91 20		sta ($20),y			sta 	(zTempStr),y
.ba4d	7a		ply				ply
.ba4e	1a		inc a				inc 	a 							; reset the write index.
.ba4f	8d 99 03	sta $0399			sta 	TempStringWriteIndex
.ba52	60		rts				rts
.ba53					WriteTempString:
.ba53	5a		phy				phy 								; save Y
.ba54	ac 99 03	ldy $0399			ldy 	TempStringWriteIndex	 	; write position.
.ba57	91 20		sta ($20),y			sta 	(zTempStr),y 				; write character out.
.ba59	ee 99 03	inc $0399			inc 	TempStringWriteIndex 		; increment the write position.
.ba5c	98		tya				tya 								; unchanged Y is now length
.ba5d	a0 00		ldy #$00			ldy 	#0
.ba5f	91 20		sta ($20),y			sta 	(zTempStr),y
.ba61	7a		ply				ply 								; restore Y and exit
.ba62	60		rts				rts
.ba63					CreateTempStringCopy:
.ba63	da		phx				phx 								; save X
.ba64	ea		nop				nop
.ba65	b2 16		lda ($16),z			lda 	(zCodePtr),z
.ba67	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.ba68	20 28 ba	jsr $ba28			jsr 	AllocateTempString 			; allocate memory for temporary string.
.ba6b	ea		nop				nop
.ba6c	b2 16		lda ($16),z			lda 	(zCodePtr),z
.ba6e	1b		inz				inz
.ba6f	3a		dec a				dec 	a 							; make the actual length in charactes
.ba70	3a		dec a				dec 	a
.ba71	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.ba73	81 20		sta ($20,x)			sta 	(zTempStr,x)
.ba75	85 1a		sta $1a				sta 	zLTemp1 					; that's used as a count.
.ba77	09 00		ora #$00			ora 	#0 							; if zero already, exit
.ba79	f0 0f		beq $ba8a			beq 	_CTSCExit
.ba7b					_CTSCLoop:
.ba7b	ea		nop				nop
.ba7c	b2 16		lda ($16),z			lda 	(zCodePtr),z
.ba7e	1b		inz				inz
.ba7f	5a		phy				phy 								; save in Y
.ba80	e8		inx				inx 								; bump index
.ba81	da		phx				phx 								; index into Y
.ba82	7a		ply				ply
.ba83	91 20		sta ($20),y			sta 	(zTempStr),y 				; save at index
.ba85	7a		ply				ply 								; restore Y
.ba86	c6 1a		dec $1a				dec 	zLTemp1 					; do for each character
.ba88	d0 f1		bne $ba7b			bne 	_CTSCLoop
.ba8a					_CTSCExit:
.ba8a	fa		plx				plx 								; restore X
.ba8b	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/variables.asm

.ba8c					VariableFind:
.ba8c	20 f7 ba	jsr $baf7			jsr 	VariableExtract 		; find out all about it ....
.ba8f	20 92 bd	jsr $bd92			jsr 	VariableLocate 			; does it already exist ?
.ba92	b0 03		bcs $ba97			bcs 	_VFExists 				; if so, use that.
.ba94	20 85 bb	jsr $bb85			jsr 	VariableCreate 			; otherwise create it.
.ba97					_VFExists:
.ba97	a5 24		lda $24				lda 	zVarType 				; is it still an array ?
.ba99	29 01		and #$01			and 	#1
.ba9b	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.ba9d	d0 28		bne $bac7			bne 	_VFSingleElement
.ba9f					_VFNextIndex:
.ba9f	a5 22		lda $22				lda 	zVarDataPtr 			; push the data ptr and type on the stack.
.baa1	48		pha				pha
.baa2	a5 23		lda $23				lda 	zVarDataPtr+1
.baa4	48		pha				pha
.baa5	a5 24		lda $24				lda 	zVarType
.baa7	48		pha				pha
.baa8	20 d8 b3	jsr $b3d8			jsr 	EvaluateIntegerX 		; calculate the index.
.baab	68		pla				pla 							; restore and index.
.baac	85 24		sta $24				sta 	zVarType
.baae	68		pla				pla
.baaf	85 23		sta $23				sta 	zVarDataPtr+1
.bab1	68		pla				pla
.bab2	85 22		sta $22				sta 	zVarDataPtr
.bab4	20 10 bc	jsr $bc10			jsr 	ArrayIndexFollow 		; do the index.
.bab7	a5 24		lda $24				lda 	zVarType 				; is it still an array ??
.bab9	29 01		and #$01			and 	#1
.babb	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.babd	d0 05		bne $bac4			bne 	_VFArrayDone 			; if so then exit.
.babf	20 ef b9	jsr $b9ef			jsr 	CheckNextComma 			; comma should follow
.bac2	80 db		bra $ba9f			bra 	_VFNextIndex
.bac4					_VFArrayDone:
.bac4	20 e6 b9	jsr $b9e6			jsr 	CheckNextRParen 		; check closing right bracket.
.bac7					_VFSingleElement:
.bac7	60		rts				rts
.bac8					VariableClear:
.bac8	48		pha				pha 							; save registers
.bac9	da		phx				phx
.baca	a2 00		ldx #$00			ldx 	#0 						; clear out the hash table.
.bacc	8a		txa				txa
.bacd	9d 2f 03	sta $032f,x	_VCLoop:sta 	HashTableBase,x
.bad0	e8		inx				inx
.bad1	e0 60		cpx #$60			cpx 	#HashTableEnd-HashTableBase
.bad3	d0 f8		bne $bacd			bne 	_VCLoop
.bad5	a9 00		lda #$00			lda 	#VariableMemory & $FF
.bad7	8d 02 03	sta $0302			sta 	VarMemPtr
.bada	a9 20		lda #$20			lda 	#VariableMemory >> 8
.badc	8d 03 03	sta $0303			sta 	VarMemPtr+1
.badf	fa		plx				plx 							; restore registers
.bae0	68		pla				pla
.bae1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/extract.asm

.bae2					VariableNameError:
.bae2	20 4c ad	jsr $ad4c			jsr ERR_Handler
>bae5	42 61 64 20 56 61 72 69			.text "Bad Variable Name",0
>baed	61 62 6c 65 20 4e 61 6d 65 00
.baf7					VariableExtract:
.baf7	da		phx				phx 							; save X.
.baf8	a9 ba		lda #$ba			lda 	#token_hashlParen  		; set the type to #( e.g. real array.
.bafa	8d 8f 03	sta $038f			sta 	Var_Type
.bafd	8d 90 03	sta $0390			sta 	Var_Hash 				; we initialise the hash with this. It doesn't matter
.bb00	ea		nop				nop
.bb01	b2 16		lda ($16),z			lda 	(zCodePtr),z
.bb03	c9 00		cmp #$00			cmp 	#0 						; first one must be A-Z
.bb05	f0 db		beq $bae2			beq 	VariableNameError
.bb07	c9 1b		cmp #$1b			cmp 	#26+1
.bb09	b0 d7		bcs $bae2			bcs 	VariableNameError
.bb0b	a2 ff		ldx #$ff			ldx 	#255 					; now copy it into the variable buffer.
.bb0d					_VECopyBuffer:
.bb0d	e8		inx				inx
.bb0e	e0 1f		cpx #$1f			cpx 	#31 					; too long
.bb10	f0 d0		beq $bae2			beq 	VariableNameError
.bb12	9d 0f 03	sta $030f,x			sta 	Var_Buffer,x 			; save character
.bb15	18		clc				clc  							; update the hash value for it.
.bb16	6d 90 03	adc $0390			adc 	Var_Hash
.bb19	8d 90 03	sta $0390			sta 	Var_Hash
.bb1c	1b		inz				inz
.bb1d	ea		nop				nop
.bb1e	b2 16		lda ($16),z			lda 	(zCodePtr),z
.bb20	c9 00		cmp #$00			cmp 	#0 						; zero or token, end of variable
.bb22	f0 0e		beq $bb32			beq 	_VECopyEnd
.bb24	30 0c		bmi $bb32			bmi 	_VECopyEnd
.bb26	c9 1b		cmp #$1b			cmp 	#26+1 					; A-Z continue copying
.bb28	90 e3		bcc $bb0d			bcc 	_VECopyBuffer
.bb2a	c9 30		cmp #$30			cmp 	#"0" 					; 0-9 copy as well.
.bb2c	90 04		bcc $bb32			bcc 	_VECopyEnd
.bb2e	c9 3a		cmp #$3a			cmp 	#"9"+1
.bb30	90 db		bcc $bb0d			bcc 	_VECopyBuffer
.bb32					_VECopyEnd:
.bb32	1b		inz				inz
.bb33	c9 b7		cmp #$b7			cmp 	#token_Dollar 			; first type token.
.bb35	90 04		bcc $bb3b			bcc 	_VEDefaultRequired
.bb37	c9 bd		cmp #$bd			cmp 	#token_PercentLParen+1	; last type token.
.bb39	90 0b		bcc $bb46			bcc 	_VEHaveType
.bb3b					_VEDefaultRequired:
.bb3b	c9 bd		cmp #$bd			cmp 	#token_LParen 			; if it ends in ( then use the real array
.bb3d	f0 04		beq $bb43			beq 	_VESetType 				; default set above.
.bb3f	ce 8f 03	dec $038f			dec 	Var_Type 				; this changes that default to the variable default
.bb42	3b		dez				dez
.bb43					_VESetType:
.bb43	ad 8f 03	lda $038f			lda 	Var_Type 				; get type ....
.bb46					_VEHaveType:
.bb46	8d 8f 03	sta $038f			sta 	Var_Type 				; save as type.
.bb49	bd 0f 03	lda $030f,x			lda 	Var_Buffer,x 			; set bit 7 of name, marks the end.
.bb4c	09 80		ora #$80			ora 	#$80
.bb4e	9d 0f 03	sta $030f,x			sta 	Var_Buffer,x
.bb51	e8		inx				inx 							; offset 3 => length 4.
.bb52	8e 91 03	stx $0391			stx 	Var_Length 				; save length of variable name.
.bb55	ad 8f 03	lda $038f			lda 	Var_Type 				; get offset of var type from first type token
.bb58	38		sec				sec
.bb59	e9 b7		sbc #$b7			sbc 	#token_Dollar
.bb5b	0a		asl a				asl 	a 						; multiply by 16. This requires HashTableSize
.bb5c	0a		asl a				asl 	a 						; in data.asm to be 8 (8 sets of links,2 bytes each)
.bb5d	0a		asl a				asl 	a
.bb5e	0a		asl a				asl 	a
.bb5f	8d 92 03	sta $0392			sta 	Var_HashAddress
.bb62	ad 90 03	lda $0390			lda 	Var_Hash 				; get the hash
.bb65	29 07		and #$07			and 	#(HashTableSize-1) 		; force into range 0-tableSize-1
.bb67	0a		asl a				asl 	a 						; double it (2 bytes per entry) & clears carry
.bb68	6d 92 03	adc $0392			adc 	Var_HashAddress 		; add table offset.
.bb6b	69 2f		adc #$2f			adc 	#HashTableBase & $FF 	; now the low byte of the actual table address
.bb6d	8d 92 03	sta $0392			sta 	Var_HashAddress
.bb70	a2 05		ldx #$05			ldx 	#5 						; hash is 5 bytes (real)
.bb72	ad 8f 03	lda $038f			lda 	Var_Type
.bb75	c9 b9		cmp #$b9			cmp 	#token_Hash
.bb77	f0 07		beq $bb80			beq 	_VEHaveSize
.bb79	ca		dex				dex
.bb7a	c9 bb		cmp #$bb			cmp 	#token_Percent 			; percent is 4 bytes (integer)
.bb7c	f0 02		beq $bb80			beq 	_VEHaveSize
.bb7e	a2 02		ldx #$02			ldx 	#2 						; everything else is two.
.bb80					_VEHaveSize:
.bb80	8e 93 03	stx $0393			stx 	Var_DataSize
.bb83	fa		plx				plx
.bb84	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varcreate.asm

.bb85					VariableCreate:
.bb85	da		phx				phx
.bb86	5a		phy				phy
.bb87	ad 02 03	lda $0302			lda 	VarMemPtr 					; get address of next free into zTemp1
.bb8a	85 10		sta $10				sta 	zTemp1
.bb8c	ad 03 03	lda $0303			lda 	VarMemPtr+1
.bb8f	85 11		sta $11				sta 	zTemp1+1
.bb91	ad 93 03	lda $0393			lda 	Var_DataSize 				; bytes for the data bit
.bb94	18		clc				clc
.bb95	6d 91 03	adc $0391			adc 	Var_Length 					; add the length of the name
.bb98	69 03		adc #$03			adc 	#3 							; 3 for the link and the hash.
.bb9a	6d 02 03	adc $0302			adc 	VarMemPtr 					; add to variable memory pointer
.bb9d	8d 02 03	sta $0302			sta 	VarMemPtr
.bba0	90 03		bcc $bba5			bcc 	_VCNoCarry
.bba2	ee 03 03	inc $0303			inc 	VarMemPtr+1
.bba5					_VCNoCarry:
.bba5	ad 92 03	lda $0392			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.bba8	85 12		sta $12				sta 	zTemp2
.bbaa	a9 03		lda #$03			lda 	#HashTableBase >> 8
.bbac	85 13		sta $13				sta 	zTemp2+1
.bbae	a0 00		ldy #$00			ldy 	#0 							; put current hash link in position.
.bbb0	b1 12		lda ($12),y			lda 	(zTemp2),y
.bbb2	91 10		sta ($10),y			sta 	(zTemp1),y
.bbb4	c8		iny				iny
.bbb5	b1 12		lda ($12),y			lda 	(zTemp2),y
.bbb7	91 10		sta ($10),y			sta 	(zTemp1),y
.bbb9	c8		iny				iny
.bbba	ad 90 03	lda $0390			lda 	Var_Hash 					; write the hash out.
.bbbd	91 10		sta ($10),y			sta 	(zTemp1),y
.bbbf	c8		iny				iny
.bbc0	a2 00		ldx #$00			ldx 	#0 							; copy the name out.
.bbc2					_VCCopyName:
.bbc2	bd 0f 03	lda $030f,x			lda 	Var_Buffer,x
.bbc5	91 10		sta ($10),y			sta 	(zTemp1),y
.bbc7	e8		inx				inx
.bbc8	c8		iny				iny
.bbc9	ec 91 03	cpx $0391			cpx 	Var_Length
.bbcc	d0 f4		bne $bbc2			bne 	_VCCopyName
.bbce	5a		phy				phy 								; save the data offset.
.bbcf	ae 93 03	ldx $0393			ldx 	Var_DataSize 				; and write the data out.
.bbd2	a9 00		lda #$00			lda 	#0 							; which is all zeroes.
.bbd4					_VCClearData:
.bbd4	91 10		sta ($10),y			sta 	(zTemp1),y
.bbd6	c8		iny				iny
.bbd7	ca		dex				dex
.bbd8	d0 fa		bne $bbd4			bne 	_VCClearData
.bbda	68		pla				pla 								; offset to the data
.bbdb	18		clc				clc
.bbdc	65 10		adc $10				adc 	zTemp1 						; add to start and save as data pointer.
.bbde	85 22		sta $22				sta 	zVarDataPtr
.bbe0	a5 11		lda $11				lda 	zTemp1+1
.bbe2	69 00		adc #$00			adc 	#0
.bbe4	85 23		sta $23				sta 	zVarDataPtr+1
.bbe6	ad 8f 03	lda $038f			lda 	Var_Type 					; and set the type.
.bbe9	85 24		sta $24				sta 	zVarType
.bbeb	a5 10		lda $10				lda 	zTemp1 						; fix hash link to point to new record
.bbed	a0 00		ldy #$00			ldy 	#0
.bbef	91 12		sta ($12),y			sta 	(zTemp2),y
.bbf1	c8		iny				iny
.bbf2	a5 11		lda $11				lda 	zTemp1+1
.bbf4	91 12		sta ($12),y			sta 	(zTemp2),y
.bbf6	ad 8f 03	lda $038f			lda 	Var_Type 					; array ? if so create the empty one.
.bbf9	29 01		and #$01			and 	#1
.bbfb	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.bbfd	d0 0e		bne $bc0d			bne 	_VCNotArray
.bbff	a2 00		ldx #$00			ldx 	#0 							; call recursive array creator
.bc01	20 a7 bc	jsr $bca7			jsr 	ArrayCreate
.bc04	5a		phy				phy 								; save YA at zVarDataPtr
.bc05	a0 00		ldy #$00			ldy 	#0
.bc07	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.bc09	c8		iny				iny
.bc0a	68		pla				pla
.bc0b	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.bc0d					_VCNotArray:
.bc0d	7a		ply				ply
.bc0e	fa		plx				plx
.bc0f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arrayidx.asm

.bc10					ArrayIndexFollow:
.bc10	5a		phy				phy
.bc11	a0 00		ldy #$00			ldy 	#0 							; make zVarDataPtr point to the array.
.bc13	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; e.g. it points to itself.
.bc15	48		pha				pha
.bc16	c8		iny				iny
.bc17	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.bc19	85 23		sta $23				sta 	zVarDataPtr+1
.bc1b	68		pla				pla
.bc1c	85 22		sta $22				sta 	zVarDataPtr
.bc1e	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; MSB of 16 bit integer and bytes 2&3
.bc20	29 80		and #$80			and 	#$80 						; must be zero.
.bc22	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.bc24	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.bc26	d0 59		bne $bc81			bne 	_AIFError
.bc28	a0 00		ldy #$00			ldy 	#0 							; calculate size - current - 1
.bc2a	18		clc				clc
.bc2b	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.bc2d	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.bc2f	c8		iny				iny
.bc30	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.bc32	08		php				php 								; clear bit 7 retaining borrow.
.bc33	29 7f		and #$7f			and 	#$7F
.bc35	28		plp				plp
.bc36	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.bc38	90 47		bcc $bc81			bcc 	_AIFError 					; eror if size-current < 0
.bc3a	b5 80		lda $80,x			lda  	XS_Mantissa+0,x 			; copy and double the index
.bc3c	0a		asl a				asl 	a 							; (e.g. index * 2)
.bc3d	85 10		sta $10				sta 	zTemp1
.bc3f	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bc41	2a		rol a				rol 	a
.bc42	85 11		sta $11				sta 	zTemp1+1
.bc44	a0 01		ldy #$01			ldy 	#1 							; is this a data entry.
.bc46	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; if so, then type is unchanged, offset set
.bc48	30 1d		bmi $bc67			bmi 	_AIFCalculate
.bc4a	c6 24		dec $24				dec 	zVarType 					; converts from an array to a type.
.bc4c	a5 24		lda $24				lda 	zVarType 					; check that type
.bc4e	c9 b7		cmp #$b7			cmp 	#token_Dollar 				; if string, use x 2
.bc50	f0 15		beq $bc67			beq 	_AIFCalculate
.bc52	06 10		asl $10				asl 	zTemp1			 			; double the index
.bc54	26 11		rol $11				rol 	zTemp1+1					; (e.g. index * 4)
.bc56	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if integer, use x 4
.bc58	f0 0d		beq $bc67			beq 	_AIFCalculate
.bc5a	18		clc				clc 								; add the original mantissa in again
.bc5b	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; which makes it x5, for float.
.bc5d	65 10		adc $10				adc 	zTemp1
.bc5f	85 10		sta $10				sta 	zTemp1
.bc61	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bc63	65 11		adc $11				adc 	zTemp1+1
.bc65	85 11		sta $11				sta 	zTemp1+1
.bc67					_AIFCalculate:
.bc67	18		clc				clc 								; add index x 2,4 or 5 to base
.bc68	a5 22		lda $22				lda 	zVarDataPtr
.bc6a	65 10		adc $10				adc 	zTemp1
.bc6c	85 22		sta $22				sta 	zVarDataPtr
.bc6e	a5 23		lda $23				lda 	zVarDataPtr+1
.bc70	65 11		adc $11				adc 	zTemp1+1
.bc72	85 23		sta $23				sta 	zVarDataPtr+1
.bc74	18		clc				clc 								; add 2 more for the length prefix.
.bc75	a5 22		lda $22				lda 	zVarDataPtr
.bc77	69 02		adc #$02			adc 	#2
.bc79	85 22		sta $22				sta 	zVarDataPtr
.bc7b	90 02		bcc $bc7f			bcc 	_AIFNoBump
.bc7d	e6 23		inc $23				inc 	zVarDataPtr+1
.bc7f					_AIFNoBump:
.bc7f	7a		ply				ply
.bc80	60		rts				rts
.bc81					_AIFError:
.bc81	20 4c ad	jsr $ad4c			jsr ERR_Handler
>bc84	42 61 64 20 61 72 72 61			.text "Bad array index",0
>bc8c	79 20 69 6e 64 65 78 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arraydef.asm

.bc94					ArrayResetDefault:
.bc94	a9 0b		lda #$0b			lda 	#11 						; 0..10 one array
.bc96	8d a1 03	sta $03a1			sta 	ArrayDef+0
.bc99	a9 00		lda #$00			lda 	#0
.bc9b	8d a2 03	sta $03a2			sta 	ArrayDef+1
.bc9e	a9 ff		lda #$ff			lda 	#$FF
.bca0	8d a3 03	sta $03a3			sta 	ArrayDef+2 					; $FFFF implies no second element.
.bca3	8d a4 03	sta $03a4			sta 	ArrayDef+3					; (test bit 7 of 2nd byte)
.bca6	60		rts				rts
.bca7					ArrayCreate:
.bca7	bd a1 03	lda $03a1,x			lda 	ArrayDef+0,x 				; put size x 2 in zTemp1
.bcaa	0a		asl a				asl 	a
.bcab	85 10		sta $10				sta 	zTemp1
.bcad	bd a2 03	lda $03a2,x			lda 	ArrayDef+1,x
.bcb0	2a		rol a				rol 	a
.bcb1	85 11		sta $11				sta 	zTemp1+1
.bcb3	bd a4 03	lda $03a4,x			lda 	ArrayDef+3,x 				; if this is the last element it's array of ptrs.
.bcb6	10 22		bpl $bcda			bpl 	_ACSized 					; if not multiply size x 2 (str) 4 (int) 5 (real)
.bcb8	ad 8f 03	lda $038f			lda 	Var_Type 					; check the type
.bcbb	c9 b8		cmp #$b8			cmp 	#token_DollarLParen 		; also if it is an array of strings $(
.bcbd	f0 1b		beq $bcda			beq 	_ACSized
.bcbf	06 10		asl $10				asl 	zTemp1 						; double again
.bcc1	26 11		rol $11				rol 	zTemp1+1
.bcc3	b0 6f		bcs $bd34			bcs 	ArrayIndexError 			; too large.
.bcc5	c9 bc		cmp #$bc			cmp 	#token_PercentLParen 		; if %( four bytes/entry is enough.
.bcc7	f0 11		beq $bcda			beq 	_ACSized
.bcc9	18		clc				clc 								; add original value x 5 for reals.
.bcca	a5 10		lda $10				lda 	zTemp1
.bccc	7d a1 03	adc $03a1,x			adc 	ArrayDef+0,x
.bccf	85 10		sta $10				sta 	zTemp1
.bcd1	a5 11		lda $11				lda 	zTemp1+1
.bcd3	7d a2 03	adc $03a2,x			adc 	ArrayDef+1,x
.bcd6	85 11		sta $11				sta 	zTemp1+1
.bcd8	b0 5a		bcs $bd34			bcs 	ArrayIndexError
.bcda					_ACSized:
.bcda	18		clc				clc
.bcdb	a5 10		lda $10				lda 	zTemp1
.bcdd	69 02		adc #$02			adc 	#2
.bcdf	85 10		sta $10				sta 	zTemp1
.bce1	90 04		bcc $bce7			bcc 	_ACNoBump
.bce3	e6 10		inc $10				inc 	zTemp1
.bce5	f0 4d		beq $bd34			beq 	ArrayIndexError
.bce7					_ACNoBump:
.bce7	18		clc				clc
.bce8	ad 02 03	lda $0302			lda 	VarMemPtr 					; add this allocated count to VarMemPtr
.bceb	85 12		sta $12				sta 	zTemp2						; save start in zTemp2/zTemp3
.bced	85 14		sta $14				sta 	zTemp3
.bcef	65 10		adc $10				adc 	zTemp1
.bcf1	8d 02 03	sta $0302			sta 	VarMemPtr
.bcf4	ad 03 03	lda $0303			lda 	VarMemPtr+1
.bcf7	85 13		sta $13				sta 	zTemp2+1
.bcf9	85 15		sta $15				sta 	zTemp3+1
.bcfb	65 11		adc $11				adc 	zTemp1+1
.bcfd	8d 03 03	sta $0303			sta 	VarMemPtr+1
.bd00	85 11		sta $11				sta 	zTemp1+1
.bd02	b0 30		bcs $bd34			bcs 	ArrayIndexError
.bd04	a0 00		ldy #$00			ldy 	#0							; write $00 out.
.bd06					_ACClear:
.bd06	98		tya				tya
.bd07	91 12		sta ($12),y			sta 	(zTemp2),y
.bd09	e6 12		inc $12				inc 	zTemp2
.bd0b	d0 02		bne $bd0f			bne 	_ACCBump
.bd0d	e6 13		inc $13				inc 	zTemp2+1
.bd0f					_ACCBump:
.bd0f	a5 12		lda $12				lda 	zTemp2
.bd11	cd 02 03	cmp $0302			cmp 	VarMemPtr
.bd14	d0 f0		bne $bd06			bne 	_ACClear
.bd16	a5 13		lda $13				lda 	zTemp2+1
.bd18	cd 03 03	cmp $0303			cmp 	VarMemPtr+1
.bd1b	d0 e9		bne $bd06			bne 	_ACClear
.bd1d	a0 00		ldy #$00			ldy 	#0
.bd1f	bd a1 03	lda $03a1,x			lda 	ArrayDef+0,x 				; copy the size into the start
.bd22	91 14		sta ($14),y			sta 	(zTemp3),y
.bd24	c8		iny				iny
.bd25	bd a2 03	lda $03a2,x			lda 	ArrayDef+1,x
.bd28	91 14		sta ($14),y			sta 	(zTemp3),y
.bd2a	bd a4 03	lda $03a4,x			lda 	ArrayDef+3,x 				; have we reached the end
.bd2d	10 18		bpl $bd47			bpl 	ACCFillRecursive
.bd2f	a4 15		ldy $15				ldy 	zTemp3+1 					; return address
.bd31	a5 14		lda $14				lda 	zTemp3
.bd33	60		rts				rts
.bd34					ArrayIndexError:
.bd34	20 4c ad	jsr $ad4c			jsr ERR_Handler
>bd37	42 61 64 20 61 72 72 61			.text "Bad array index",0
>bd3f	79 20 69 6e 64 65 78 00
.bd47					ACCFillRecursive:
.bd47	a9 ff		lda #$ff			lda 	#$FF 						; we mark the end, this is free space.
.bd49	a0 00		ldy #$00			ldy 	#0 							; this is overwritten by size of next allocated
.bd4b	91 12		sta ($12),y			sta 	(zTemp2),y 					; array, but we might change that.
.bd4d	c8		iny				iny
.bd4e	b1 14		lda ($14),y			lda 	(zTemp3),y 					; set bit 15 of the max index indicating
.bd50	09 80		ora #$80			ora 	#$80 						; an array of pointers
.bd52	91 14		sta ($14),y			sta 	(zTemp3),y
.bd54	a5 14		lda $14				lda 	zTemp3 						; push the start on the stack
.bd56	48		pha				pha
.bd57	a5 15		lda $15				lda 	zTemp3+1
.bd59	48		pha				pha
.bd5a					_ACCFillLoop:
.bd5a	18		clc				clc
.bd5b	a5 14		lda $14				lda 	zTemp3 						; and work forwards.
.bd5d	69 02		adc #$02			adc 	#2
.bd5f	85 14		sta $14				sta 	zTemp3
.bd61	90 02		bcc $bd65			bcc 	_ACCSkip2
.bd63	e6 15		inc $15				inc 	zTemp3+1
.bd65					_ACCSkip2:
.bd65	a0 00		ldy #$00			ldy 	#0 							; reached the end ?
.bd67	b1 14		lda ($14),y			lda 	(zTemp3),y					; (looking for FF marker, everything else 00)
.bd69	c8		iny				iny
.bd6a	11 14		ora ($14),y			ora 	(zTemp3),y
.bd6c	d0 21		bne $bd8f			bne 	_ACCExit
.bd6e	a5 14		lda $14				lda 	zTemp3 						; push zTemp3
.bd70	48		pha				pha
.bd71	a5 15		lda $15				lda 	zTemp3+1
.bd73	48		pha				pha
.bd74	e8		inx				inx
.bd75	e8		inx				inx
.bd76	20 a7 bc	jsr $bca7			jsr 	ArrayCreate 				; create array recursively.
.bd79	ca		dex				dex
.bd7a	ca		dex				dex
.bd7b	85 12		sta $12				sta 	zTemp2 						; save A
.bd7d	68		pla				pla
.bd7e	85 15		sta $15				sta 	zTemp3+1 					; restore zTemp3
.bd80	68		pla				pla
.bd81	85 14		sta $14				sta 	zTemp3
.bd83	98		tya				tya 								; write high bye from Y
.bd84	a0 01		ldy #$01			ldy 	#1
.bd86	91 14		sta ($14),y			sta 	(zTemp3),y
.bd88	88		dey				dey 								; write low byte out.
.bd89	a5 12		lda $12				lda 	zTemp2
.bd8b	91 14		sta ($14),y			sta 	(zTemp3),y
.bd8d	80 cb		bra $bd5a			bra 	_ACCFillLoop 				; and try again.
.bd8f					_ACCExit:
.bd8f	7a		ply				ply 								; restore the original address
.bd90	68		pla				pla
.bd91	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varfind.asm

.bd92					VariableLocate:
.bd92	da		phx				phx
.bd93	5a		phy				phy
.bd94	ad 92 03	lda $0392			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.bd97	85 12		sta $12				sta 	zTemp2 						; points to first address.
.bd99	a9 03		lda #$03			lda 	#HashTableBase >> 8
.bd9b	85 13		sta $13				sta 	zTemp2+1
.bd9d	a0 00		ldy #$00	_VLNext:ldy 	#0 							; get next link into AX
.bd9f	b1 12		lda ($12),y			lda 	(zTemp2),y
.bda1	aa		tax				tax
.bda2	c8		iny				iny
.bda3	b1 12		lda ($12),y			lda 	(zTemp2),y
.bda5	85 13		sta $13				sta 	zTemp2+1 					; save in zTemp
.bda7	86 12		stx $12				stx 	zTemp2
.bda9	05 12		ora $12				ora 	zTemp2 						; got zero
.bdab	18		clc				clc
.bdac	f0 25		beq $bdd3			beq 	_VLExit 					; if so, then fail as end of chain.
.bdae	c8		iny				iny 								; point to hash (offset + 2)
.bdaf	b1 12		lda ($12),y			lda 	(zTemp2),y
.bdb1	cd 90 03	cmp $0390			cmp 	Var_Hash
.bdb4	d0 e7		bne $bd9d			bne 	_VLNext 					; try next if different.
.bdb6					_VLCompare:
.bdb6	c8		iny				iny 								; next character
.bdb7	b1 12		lda ($12),y			lda 	(zTemp2),y 					; compare variable field against buffer.
.bdb9	d9 0c 03	cmp $030c,y			cmp 	Var_Buffer-3,y 				; the -3 is because name starts at 3.
.bdbc	d0 df		bne $bd9d			bne 	_VLNext 					; fail if different, try next.
.bdbe	0a		asl a				asl 	a 							; until end character (bit 7 set) matched
.bdbf	90 f5		bcc $bdb6			bcc 	_VLCompare
.bdc1	98		tya				tya
.bdc2	38		sec				sec 								; add 1 as Y points to last character
.bdc3	65 12		adc $12				adc 	zTemp2 						; add to the current address
.bdc5	85 22		sta $22				sta 	zVarDataPtr
.bdc7	a5 13		lda $13				lda 	zTemp2+1
.bdc9	69 00		adc #$00			adc 	#0
.bdcb	85 23		sta $23				sta 	zVarDataPtr+1
.bdcd	ad 8f 03	lda $038f			lda 	Var_Type 					; and set the type.
.bdd0	85 24		sta $24				sta 	zVarType
.bdd2	38		sec				sec 								; return CS
.bdd3	7a		ply		_VLExit:ply
.bdd4	fa		plx				plx
.bdd5	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/vargetset.asm

.bdd6					VariableGet:
.bdd6	5a		phy				phy
.bdd7	a0 00		ldy #$00			ldy 	#0 							; copy first two bytes
.bdd9	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.bddb	95 80		sta $80,x			sta 	XS_Mantissa,x
.bddd	c8		iny				iny
.bdde	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.bde0	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bde2	c8		iny				iny
.bde3	a5 24		lda $24				lda 	zVarType 					; if it is a string, set up for that.
.bde5	c9 b7		cmp #$b7			cmp 	#token_Dollar
.bde7	f0 2c		beq $be15			beq 	_VGString
.bde9	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; copy the next two bytes.
.bdeb	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.bded	c8		iny				iny
.bdee	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.bdf0	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.bdf2	c8		iny				iny
.bdf3	a9 01		lda #$01			lda 	#1 							; set type to 1.
.bdf5	95 85		sta $85,x			sta 	XS_Type,x
.bdf7	a5 24		lda $24				lda 	zVarType
.bdf9	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if it is a %, then exit with default integer.
.bdfb	f0 28		beq $be25			beq 	_VGExit
.bdfd	a9 40		lda #$40			lda 	#$40 						; set type byte to zero
.bdff	95 85		sta $85,x			sta 	XS_Type,x 					; which is the code for zero/float.
.be01	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; the last value to copy is the exponent.
.be03	95 84		sta $84,x			sta 	XS_Exponent,x
.be05	f0 1e		beq $be25			beq 	_VGExit 					; if exponent is zero ... it's zero.
.be07	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; the sign bit is the top mantissa bit.
.be09	48		pha				pha
.be0a	29 80		and #$80			and 	#$80
.be0c	95 85		sta $85,x			sta 	XS_Type,x 					; this is the type byte.
.be0e	68		pla				pla
.be0f	09 80		ora #$80			ora 	#$80 						; set the MSB as you would expect.
.be11	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; so it's a normalised float.
.be13	80 10		bra $be25			bra 	_VGExit
.be15					_VGString:
.be15	a9 02		lda #$02			lda 	#2 							; set type to 2, a string
.be17	95 85		sta $85,x			sta 	XS_Type,x
.be19	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; is the value there $0000
.be1b	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.be1d	d0 06		bne $be25			bne 	_VGExit 					; if not, exit.
.be1f	85 25		sta $25				sta 	zNullString 				; make zNullString a 00 string.
.be21	a9 25		lda #$25			lda 	#zNullString
.be23	95 80		sta $80,x			sta 	XS_Mantissa,x 				; make it point to it.
.be25					_VGExit:
.be25	7a		ply				ply
.be26	60		rts				rts
.be27					VariableSet:
.be27	b5 85		lda $85,x			lda 	XS_Type,x 					; is the result a string
.be29	29 02		and #$02			and 	#2 							; if so, it has to be
.be2b	d0 4b		bne $be78			bne 	_VSString
.be2d	a5 24		lda $24				lda 	zVarType 					; if type is $ there's an error.
.be2f	c9 b7		cmp #$b7			cmp 	#token_Dollar
.be31	f0 42		beq $be75			beq 	_VSBadType
.be33	c9 bb		cmp #$bb			cmp 	#token_Percent 				; type convert to float/int
.be35	f0 05		beq $be3c			beq 	_VSMakeInt
.be37	20 5c c3	jsr $c35c			jsr 	FPUToFloat
.be3a	80 03		bra $be3f			bra 	_VSCopy
.be3c					_VSMakeInt:
.be3c	20 a8 c3	jsr $c3a8			jsr 	FPUToInteger
.be3f					_VSCopy:
.be3f	5a		phy				phy
.be40	a0 00		ldy #$00			ldy 	#0 							; copy mantissa to target.
.be42	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.be44	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.be46	c8		iny				iny
.be47	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.be49	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.be4b	c8		iny				iny
.be4c	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.be4e	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.be50	c8		iny				iny
.be51	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.be53	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.be55	a5 24		lda $24				lda 	zVarType 					; if target is integer, alrady done.
.be57	c9 bb		cmp #$bb			cmp 	#token_Percent
.be59	f0 18		beq $be73			beq 	_VSExit
.be5b	b5 85		lda $85,x			lda 	XS_Type,x 					; get the sign bit into carry flag.
.be5d	0a		asl a				asl 	a
.be5e	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; shift the sign into the mantissa high.
.be60	08		php				php
.be61	0a		asl a				asl 	a
.be62	28		plp				plp
.be63	6a		ror a				ror 	a
.be64	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.be66	c8		iny				iny
.be67	b5 84		lda $84,x			lda 	XS_Exponent,x 				; copy the exponent in
.be69	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.be6b	34 85		bit $85,x			bit 	XS_Type,x 					; if the result is non zero
.be6d	50 04		bvc $be73			bvc 	_VSExit
.be6f	a9 00		lda #$00			lda 	#00 						; zero exponent indicating 0.
.be71	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.be73					_VSExit:
.be73	7a		ply				ply
.be74	60		rts				rts
.be75					_VSBadType:
.be75	4c 2d ad	jmp $ad2d			jmp 	TypeError
.be78					_VSString:
.be78	a5 24		lda $24				lda 	zVarType 					; type must be $
.be7a	c9 b7		cmp #$b7			cmp 	#token_Dollar
.be7c	d0 f7		bne $be75			bne 	_VSBadType
.be7e	da		phx				phx
.be7f	5a		phy				phy
.be80	20 f8 b9	jsr $b9f8			jsr 	StringConcrete 				; concrete the string in the mantissa -> AX
.be83	a0 01		ldy #$01			ldy 	#1 							; save high byte
.be85	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.be87	88		dey				dey 								; save low byte
.be88	8a		txa				txa
.be89	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.be8b	7a		ply				ply 								; and exit.
.be8c	fa		plx				plx
.be8d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.be8e					MulInteger32:
.be8e	b5 80		lda $80,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.be90	95 8c		sta $8c,x			sta 	XS3_Mantissa,x
.be92	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.be94	95 8d		sta $8d,x			sta 	XS3_Mantissa+1,x
.be96	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.be98	95 8e		sta $8e,x			sta 	XS3_Mantissa+2,x
.be9a	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.be9c	95 8f		sta $8f,x			sta 	XS3_Mantissa+3,x
.be9e	a9 00		lda #$00			lda 	#0
.bea0	95 80		sta $80,x			sta 	XS_Mantissa+0,x 				; zero +0
.bea2	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bea4	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.bea6	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.bea8					_BFMMultiply:
.bea8	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.beaa	29 01		and #$01			and 	#1
.beac	f0 03		beq $beb1			beq 	_BFMNoAdd
.beae	20 76 b5	jsr $b576			jsr 	AddInteger32
.beb1					_BFMNoAdd:
.beb1	16 86		asl $86,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.beb3	36 87		rol $87,x			rol 	XS2_Mantissa+1,x
.beb5	36 88		rol $88,x			rol 	XS2_Mantissa+2,x
.beb7	36 89		rol $89,x			rol 	XS2_Mantissa+3,x
.beb9	56 8f		lsr $8f,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.bebb	76 8e		ror $8e,x			ror 	XS3_Mantissa+2,x
.bebd	76 8d		ror $8d,x			ror 	XS3_Mantissa+1,x
.bebf	76 8c		ror $8c,x			ror 	XS3_Mantissa,x
.bec1	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.bec3	15 8d		ora $8d,x			ora 	XS3_Mantissa+1,x
.bec5	15 8e		ora $8e,x			ora 	XS3_Mantissa+2,x
.bec7	15 8f		ora $8f,x			ora 	XS3_Mantissa+3,x
.bec9	d0 dd		bne $bea8			bne 	_BFMMultiply
.becb	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.becc					DivInteger32:
.becc	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; check for /0
.bece	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.bed0	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.bed2	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.bed4	d0 14		bne $beea			bne 	_BFDOkay
.bed6	20 4c ad	jsr $ad4c			jsr ERR_Handler
>bed9	44 69 76 69 73 69 6f 6e			.text "Division by Zero",0
>bee1	20 62 79 20 5a 65 72 6f 00
.beea					_BFDOkay:
.beea	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.beec	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.beee	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.bef0	85 1c		sta $1c				sta 	zLTemp1+2
.bef2	85 1d		sta $1d				sta 	zLTemp1+3
.bef4	8d 98 03	sta $0398			sta 	SignCount 					; Count of signs.
.bef7	20 4e bf	jsr $bf4e			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.befa	da		phx				phx
.befb	e8		inx				inx
.befc	e8		inx				inx
.befd	e8		inx				inx
.befe	e8		inx				inx
.beff	e8		inx				inx
.bf00	e8		inx				inx
.bf01	20 4e bf	jsr $bf4e			jsr 	CheckIntegerNegate
.bf04	fa		plx				plx
.bf05	5a		phy				phy 								; Y is the counter
.bf06	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.bf08					_BFDLoop:
.bf08	16 80		asl $80,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.bf0a	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.bf0c	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.bf0e	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.bf10	26 1a		rol $1a				rol 	zLTemp1
.bf12	26 1b		rol $1b				rol 	zLTemp1+1
.bf14	26 1c		rol $1c				rol 	zLTemp1+2
.bf16	26 1d		rol $1d				rol 	zLTemp1+3
.bf18	38		sec				sec
.bf19	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.bf1b	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.bf1d	48		pha				pha
.bf1e	a5 1b		lda $1b				lda 	zLTemp1+1
.bf20	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.bf22	48		pha				pha
.bf23	a5 1c		lda $1c				lda 	zLTemp1+2
.bf25	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.bf27	48		pha				pha
.bf28	a5 1d		lda $1d				lda 	zLTemp1+3
.bf2a	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.bf2c	90 13		bcc $bf41			bcc 	_BFDNoAdd
.bf2e	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.bf30	68		pla				pla
.bf31	85 1c		sta $1c				sta 	zLTemp1+2
.bf33	68		pla				pla
.bf34	85 1b		sta $1b				sta 	zLTemp1+1
.bf36	68		pla				pla
.bf37	85 1a		sta $1a				sta 	zLTemp1+0
.bf39	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.bf3b	09 01		ora #$01			ora 	#1
.bf3d	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.bf3f	80 03		bra $bf44			bra 	_BFDNext
.bf41					_BFDNoAdd:
.bf41	68		pla				pla 								; Throw away the intermediate calculations
.bf42	68		pla				pla
.bf43	68		pla				pla
.bf44					_BFDNext:
.bf44	88		dey				dey
.bf45	d0 c1		bne $bf08			bne 	_BFDLoop
.bf47	7a		ply				ply 								; restore Y and exit
.bf48	4e 98 03	lsr $0398			lsr 	SignCount 					; if sign count odd,
.bf4b	b0 06		bcs $bf53			bcs		IntegerNegateAlways 			; negate the result
.bf4d	60		rts				rts
.bf4e					CheckIntegerNegate:
.bf4e	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.bf50	30 01		bmi $bf53			bmi 	IntegerNegateAlways
.bf52	60		rts				rts
.bf53					IntegerNegateAlways:
.bf53	ee 98 03	inc $0398			inc 	SignCount
.bf56	38		sec				sec
.bf57	a9 00		lda #$00			lda 	#0
.bf59	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.bf5b	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.bf5d	a9 00		lda #$00			lda 	#0
.bf5f	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.bf61	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bf63	a9 00		lda #$00			lda 	#0
.bf65	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.bf67	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.bf69	a9 00		lda #$00			lda 	#0
.bf6b	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.bf6d	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.bf6f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.bf70					INTToString:
.bf70	48		pha				pha
.bf71	5a		phy				phy
.bf72	b5 83		lda $83,x			lda 		XS_Mantissa+3,x 		; check -ve
.bf74	10 08		bpl $bf7e			bpl 		_ITSNotMinus
.bf76	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.bf78	20 0e c0	jsr $c00e			jsr 		ITSOutputCharacter
.bf7b	20 53 bf	jsr $bf53			jsr 		IntegerNegateAlways 	; negate the number.
.bf7e					_ITSNotMinus:
.bf7e	a9 00		lda #$00			lda 		#0
.bf80	8d 94 03	sta $0394			sta 		NumSuppress 			; clear the suppression flag.
.bf83	8a		txa				txa 								; use Y for the mantissa index.
.bf84	a8		tay				tay
.bf85	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.bf87					_ITSNextSubtractor:
.bf87	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.bf89	8d 95 03	sta $0395			sta 		NumConvCount
.bf8c					_ITSSubtract:
.bf8c	38		sec				sec
.bf8d	b9 80 00	lda $0080,y			lda 		XS_Mantissa,y 			; subtract number and push on stack
.bf90	fd ea bf	sbc $bfea,x			sbc 		_ITSSubtractors+0,x
.bf93	48		pha				pha
.bf94	b9 81 00	lda $0081,y			lda 		XS_Mantissa+1,y
.bf97	fd eb bf	sbc $bfeb,x			sbc 		_ITSSubtractors+1,x
.bf9a	48		pha				pha
.bf9b	b9 82 00	lda $0082,y			lda 		XS_Mantissa+2,y
.bf9e	fd ec bf	sbc $bfec,x			sbc 		_ITSSubtractors+2,x
.bfa1	48		pha				pha
.bfa2	b9 83 00	lda $0083,y			lda 		XS_Mantissa+3,y
.bfa5	fd ed bf	sbc $bfed,x			sbc 		_ITSSubtractors+3,x
.bfa8	90 14		bcc $bfbe			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.bfaa	99 83 00	sta $0083,y			sta 		XS_Mantissa+3,y 		; save subtract off stack
.bfad	68		pla				pla
.bfae	99 82 00	sta $0082,y			sta 		XS_Mantissa+2,y
.bfb1	68		pla				pla
.bfb2	99 81 00	sta $0081,y			sta 		XS_Mantissa+1,y
.bfb5	68		pla				pla
.bfb6	99 80 00	sta $0080,y			sta 		XS_Mantissa+0,y
.bfb9	ee 95 03	inc $0395			inc 		NumConvCount 			; bump count.
.bfbc	80 ce		bra $bf8c			bra 		_ITSSubtract 			; go round again.
.bfbe					_ITSCantSubtract:
.bfbe	68		pla				pla 								; throw away interim answers
.bfbf	68		pla				pla
.bfc0	68		pla				pla
.bfc1	ad 95 03	lda $0395			lda 		NumConvCount 			; if not zero then no suppression check
.bfc4	c9 30		cmp #$30			cmp 		#"0"
.bfc6	d0 05		bne $bfcd			bne 		_ITSOutputDigit
.bfc8	ad 94 03	lda $0394			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.bfcb	10 09		bpl $bfd6			bpl	 		_ITSGoNextSubtractor
.bfcd					_ITSOutputDigit:
.bfcd	ce 94 03	dec $0394			dec 		NumSuppress 			; suppression check will be non-zero.
.bfd0	ad 95 03	lda $0395			lda 		NumConvCount 			; count of subtractions
.bfd3	20 0e c0	jsr $c00e			jsr 		ITSOutputCharacter 		; output it.
.bfd6					_ITSGoNextSubtractor:
.bfd6	e8		inx				inx 								; next dword
.bfd7	e8		inx				inx
.bfd8	e8		inx				inx
.bfd9	e8		inx				inx
.bfda	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.bfdc	d0 a9		bne $bf87			bne 		_ITSNextSubtractor 		; do all the subtractors.
.bfde	98		tya				tya 								; X is back as the mantissa index
.bfdf	aa		tax				tax
.bfe0	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.bfe2	09 30		ora #$30			ora 		#"0"
.bfe4	20 0e c0	jsr $c00e			jsr 		ITSOutputCharacter
.bfe7	7a		ply				ply 								; and exit
.bfe8	68		pla				pla
.bfe9	60		rts				rts
.bfea					_ITSSubtractors:
>bfea	00 ca 9a 3b					.dword 		1000000000
>bfee	00 e1 f5 05					.dword 		100000000
>bff2	80 96 98 00					.dword 		10000000
>bff6	40 42 0f 00					.dword 		1000000
>bffa	a0 86 01 00					.dword 		100000
>bffe	10 27 00 00					.dword 		10000
>c002	e8 03 00 00					.dword 		1000
>c006	64 00 00 00					.dword 		100
>c00a	0a 00 00 00					.dword 		10
.c00e					_ITSSubtractorsEnd:
.c00e					ITSOutputCharacter:
.c00e	48		pha				pha
.c00f	da		phx				phx
.c010	ae 0e 03	ldx $030e			ldx 	NumBufX 					; save digit
.c013	9d 0f 03	sta $030f,x			sta 	Num_Buffer,x
.c016	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.c018	9d 10 03	sta $0310,x			sta 	Num_Buffer+1,x
.c01b	ee 0e 03	inc $030e			inc 	NumBufX						; bump pointer.
.c01e	fa		plx				plx
.c01f	68		pla				pla
.c020	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.c021					IntFromString:
.c021	a0 00		ldy #$00			ldy 	#0
.c023	8c 96 03	sty $0396			sty 	ExpTemp 					; this is the converted digit count.
.c026					IntFromStringY:
.c026	48		pha				pha
.c027	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.c029	95 80		sta $80,x			sta 	XS_Mantissa,x
.c02b	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c02d	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c02f	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c031	a9 01		lda #$01			lda 	#1
.c033	95 85		sta $85,x			sta 	XS_Type,x
.c035					_IFSLoop:
.c035	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.c037	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.c039	90 4e		bcc $c089			bcc 	_IFSExit
.c03b	c9 3a		cmp #$3a			cmp 	#"9"+1
.c03d	b0 4a		bcs $c089			bcs 	_IFSExit
.c03f	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.c041	c9 0c		cmp #$0c			cmp 	#12
.c043	b0 4e		bcs $c093			bcs 	_IFSOverflow
.c045	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.c047	48		pha				pha
.c048	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c04a	48		pha				pha
.c04b	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c04d	48		pha				pha
.c04e	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.c050	48		pha				pha
.c051	20 a8 c0	jsr $c0a8			jsr 	IFSX1ShiftLeft 				; double
.c054	20 a8 c0	jsr $c0a8			jsr 	IFSX1ShiftLeft 				; x 4
.c057	18		clc				clc 								; add saved value x 5
.c058	68		pla				pla
.c059	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.c05b	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c05d	68		pla				pla
.c05e	75 81		adc $81,x			adc 	XS_Mantissa+1,x
.c060	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c062	68		pla				pla
.c063	75 82		adc $82,x			adc 	XS_Mantissa+2,x
.c065	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c067	68		pla				pla
.c068	75 83		adc $83,x			adc 	XS_Mantissa+3,x
.c06a	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c06c	20 a8 c0	jsr $c0a8			jsr 	IFSX1ShiftLeft 				; x 10
.c06f	ee 96 03	inc $0396			inc 	ExpTemp 					; bump count of digits processed.
.c072	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.c074	29 0f		and #$0f			and 	#15
.c076	c8		iny				iny
.c077	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.c079	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c07b	90 b8		bcc $c035			bcc 	_IFSLoop
.c07d	f6 81		inc $81,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.c07f	d0 b4		bne $c035			bne 	_IFSLoop
.c081	f6 82		inc $82,x			inc 	XS_Mantissa+2,x
.c083	d0 b0		bne $c035			bne 	_IFSLoop
.c085	f6 83		inc $83,x			inc 	XS_Mantissa+3,x
.c087	80 ac		bra $c035			bra 	_IFSLoop
.c089					_IFSExit:
.c089	98		tya				tya 								; get offset
.c08a					_IFSOkay:
.c08a	38		sec				sec
.c08b	ad 96 03	lda $0396			lda 	ExpTemp
.c08e	f0 01		beq $c091			beq 	_IFSSkipFail
.c090	18		clc				clc
.c091					_IFSSkipFail:
.c091	68		pla				pla 								; and exit.
.c092	60		rts				rts
.c093					_IFSOverflow:
.c093	20 4c ad	jsr $ad4c			jsr 	ERR_Handler
>c096	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>c09e	20 6f 76 65 72 66 6c 6f 77 00
.c0a8					IFSX1ShiftLeft:
.c0a8	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.c0aa	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.c0ac	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.c0ae	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.c0b0	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.c0b1					FPSubtract:
.c0b1	48		pha				pha
.c0b2	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.c0b4	49 80		eor #$80			eor 	#$80
.c0b6	95 8b		sta $8b,x			sta 	XS2_Type,x
.c0b8	68		pla				pla 								; --- and fall through ---
.c0b9					FPAdd:
.c0b9	48		pha				pha
.c0ba	b5 85		lda $85,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.c0bc	d0 05		bne $c0c3			bne 	_FPA_NegativeLHS
.c0be	20 da c0	jsr $c0da			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.c0c1	68		pla				pla
.c0c2	60		rts				rts
.c0c3					_FPA_NegativeLHS:
.c0c3	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.c0c5	49 80		eor #$80			eor 	#$80
.c0c7	95 85		sta $85,x			sta 	XS_Type,x
.c0c9	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of B and add
.c0cb	49 80		eor #$80			eor 	#$80
.c0cd	95 8b		sta $8b,x			sta 	XS2_Type,x
.c0cf	20 da c0	jsr $c0da			jsr 	FPAdd_Worker 				; do the add calculation.
.c0d2	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 back
.c0d4	49 80		eor #$80			eor 	#$80
.c0d6	95 85		sta $85,x			sta 	XS_Type,x
.c0d8	68		pla				pla
.c0d9	60		rts				rts
.c0da					FPAdd_Worker:
.c0da	34 8b		bit $8b,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.c0dc	70 07		bvs $c0e5			bvs 	_FPAWExit 					; no change.
.c0de	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.c0e0	50 07		bvc $c0e9			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.c0e2	20 1a c3	jsr $c31a			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.c0e5					_FPAWExit:
.c0e5	20 89 c3	jsr $c389			jsr 	FPUNormalise 				; normalise the result.
.c0e8	60		rts				rts
.c0e9					_FPAWMakeSame:
.c0e9	b5 84		lda $84,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.c0eb	38		sec				sec
.c0ec	f5 8a		sbc $8a,x			sbc	 	XS2_Exponent,x 				; using subtraction
.c0ee	f0 16		beq $c106			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.c0f0	da		phx				phx 								; save X
.c0f1	90 06		bcc $c0f9			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.c0f3	e8		inx				inx
.c0f4	e8		inx				inx
.c0f5	e8		inx				inx
.c0f6	e8		inx				inx
.c0f7	e8		inx				inx
.c0f8	e8		inx				inx
.c0f9					_FPAWShiftA:
.c0f9	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.c0fb	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.c0fd	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.c0ff	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.c101	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.c103	fa		plx				plx 								; restore original X
.c104	80 e3		bra $c0e9			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.c106					_FPAW_DoArithmetic:
.c106	34 8b		bit $8b,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.c108	30 28		bmi $c132			bmi 	_FPAW_BNegative
.c10a	18		clc				clc
.c10b	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.c10d	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.c10f	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c111	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c113	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.c115	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c117	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c119	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.c11b	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c11d	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.c11f	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.c121	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c123	90 c0		bcc $c0e5			bcc 	_FPAWExit 					; no carry.
.c125	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.c127	38		sec				sec
.c128	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.c12a	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.c12c	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.c12e	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.c130	80 b3		bra $c0e5			bra 	_FPAWExit
.c132					_FPAW_BNegative:
.c132	38		sec				sec
.c133	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.c135	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.c137	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c139	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c13b	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.c13d	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c13f	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c141	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.c143	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c145	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.c147	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.c149	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c14b	b0 09		bcs $c156			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.c14d	20 40 c3	jsr $c340			jsr 	FPUNegateInteger			; negate the mantissa
.c150	b5 85		lda $85,x			lda 	XS_Type,x 					; flip result sign
.c152	49 80		eor #$80			eor 	#$80
.c154	95 85		sta $85,x			sta 	XS_Type,x
.c156					_FPAWGoExit:
.c156	4c e5 c0	jmp $c0e5			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.c159					FPD_IsDivZero:
.c159	20 4c ad	jsr $ad4c			jsr ERR_Handler
>c15c	44 69 76 69 73 69 6f 6e			.text "Division by zero",0
>c164	20 62 79 20 7a 65 72 6f 00
.c16d					FPDivide:
.c16d	48		pha				pha
.c16e	5a		phy				phy
.c16f	34 8b		bit $8b,x			bit 	XS2_Type,x 					; check if division by zero
.c171	70 e6		bvs $c159			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.c173	34 85		bit $85,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.c175	f0 03		beq $c17a			beq 	_FPDCalculateExp
.c177					_FPD_Exit:
.c177	7a		ply				ply
.c178	68		pla				pla
.c179	60		rts				rts
.c17a					_FPDCalculateExp:
.c17a	b5 8a		lda $8a,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.c17c	49 ff		eor #$ff			eor 	#$FF
.c17e	1a		inc a				inc 	a
.c17f	95 8a		sta $8a,x			sta 	XS2_Exponent,x
.c181	20 51 c2	jsr $c251			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.c184	18		clc				clc 	 							; add 1 to the resulting exponent
.c185	69 01		adc #$01			adc 	#1
.c187	b0 54		bcs $c1dd			bcs 	_FPD_Overflow 				; which can overflow.
.c189	95 84		sta $84,x			sta 	XS_Exponent,x
.c18b	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.c18d	85 1a		sta $1a				sta 	zLTemp1+0
.c18f	85 1b		sta $1b				sta 	zLTemp1+1
.c191	85 1c		sta $1c				sta 	zLTemp1+2
.c193	85 1d		sta $1d				sta 	zLTemp1+3
.c195	a0 20		ldy #$20			ldy 	#32 						; times round.
.c197					_FPD_Loop:
.c197	38		sec				sec 								; calculate X1-X2 stacking result because we might
.c198	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; not save it.
.c19a	f5 86		sbc $86,x			sbc 	XS2_Mantissa,x
.c19c	48		pha				pha
.c19d	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c19f	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.c1a1	48		pha				pha
.c1a2	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c1a4	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.c1a6	48		pha				pha
.c1a7	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.c1a9	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.c1ab	90 13		bcc $c1c0			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.c1ad	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; save results out to A
.c1af	68		pla				pla
.c1b0	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c1b2	68		pla				pla
.c1b3	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c1b5	68		pla				pla
.c1b6	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c1b8	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.c1ba	09 80		ora #$80			ora 	#$80
.c1bc	85 1d		sta $1d				sta 	zLTemp1+3
.c1be	80 03		bra $c1c3			bra 	_FPD_Rotates
.c1c0					_FPD_NoSubtract:
.c1c0	68		pla				pla 								; throw away unwanted results
.c1c1	68		pla				pla
.c1c2	68		pla				pla
.c1c3					_FPD_Rotates:
.c1c3	56 89		lsr $89,x			lsr 	3+XS2_Mantissa,x
.c1c5	76 88		ror $88,x			ror 	2+XS2_Mantissa,x
.c1c7	76 87		ror $87,x			ror 	1+XS2_Mantissa,x
.c1c9	76 86		ror $86,x			ror 	0+XS2_Mantissa,x
.c1cb	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.c1cd	26 1b		rol $1b				rol 	zLTemp1+1
.c1cf	26 1c		rol $1c				rol 	zLTemp1+2
.c1d1	26 1d		rol $1d				rol 	zLTemp1+3
.c1d3	90 02		bcc $c1d7			bcc 	_FPD_NoCarry
.c1d5	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.c1d7					_FPD_NoCarry:
.c1d7	88		dey				dey 								; do 32 times
.c1d8	d0 bd		bne $c197			bne 	_FPD_Loop
.c1da	4c 35 c2	jmp $c235			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.c1dd					_FPD_Overflow:
.c1dd	4c e6 c3	jmp $c3e6			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.c1e0					FPMultiply:
.c1e0	48		pha				pha
.c1e1	5a		phy				phy
.c1e2	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.c1e4	70 07		bvs $c1ed			bvs 	_FPM_Exit
.c1e6	34 8b		bit $8b,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.c1e8	50 06		bvc $c1f0			bvc 	_FPM_CalcExponent
.c1ea	20 1a c3	jsr $c31a			jsr 	FPUCopyX2ToX1
.c1ed					_FPM_Exit:
.c1ed	7a		ply				ply
.c1ee	68		pla				pla
.c1ef	60		rts				rts
.c1f0					_FPM_CalcExponent:
.c1f0	18		clc				clc
.c1f1	20 51 c2	jsr $c251			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.c1f4	95 84		sta $84,x			sta 	XS_Exponent,x 				; save the result.
.c1f6	a9 00		lda #$00			lda 	#0
.c1f8	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.c1fa	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.c1fc	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.c1fe	85 1d		sta $1d				sta 	zLTemp1+3
.c200	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.c202					_FPM_Loop:
.c202	b5 80		lda $80,x			lda 	XS_Mantissa,x				; check LSB of long product
.c204	29 01		and #$01			and 	#1
.c206	18		clc				clc 								; clear carry for the long rotate.
.c207	f0 19		beq $c222			beq 	_FPM_NoAddition
.c209	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.c20a	a5 1a		lda $1a				lda 	zLTemp1+0
.c20c	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.c20e	85 1a		sta $1a				sta 	zLTemp1+0
.c210	a5 1b		lda $1b				lda 	zLTemp1+1
.c212	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.c214	85 1b		sta $1b				sta 	zLTemp1+1
.c216	a5 1c		lda $1c				lda 	zLTemp1+2
.c218	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.c21a	85 1c		sta $1c				sta 	zLTemp1+2
.c21c	a5 1d		lda $1d				lda 	zLTemp1+3
.c21e	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.c220	85 1d		sta $1d				sta 	zLTemp1+3
.c222					_FPM_NoAddition:
.c222	66 1d		ror $1d				ror 	3+zLTemp1
.c224	66 1c		ror $1c				ror 	2+zLTemp1
.c226	66 1b		ror $1b				ror 	1+zLTemp1
.c228	66 1a		ror $1a				ror 	0+zLTemp1
.c22a	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.c22c	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.c22e	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.c230	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.c232	88		dey				dey
.c233	d0 cd		bne $c202			bne 	_FPM_Loop 					; do this 32 times.
.c235					FPM_CopySignNormalize:
.c235	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.c237	95 80		sta $80,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.c239	a5 1b		lda $1b				lda 	zLTemp1+1
.c23b	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c23d	a5 1c		lda $1c				lda 	zLTemp1+2
.c23f	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c241	a5 1d		lda $1d				lda 	zLTemp1+3
.c243	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c245	b5 85		lda $85,x			lda 	XS_Type,x 					; sign is xor of signs
.c247	55 8b		eor $8b,x			eor 	XS2_Type,x
.c249	95 85		sta $85,x			sta 	XS_Type,x
.c24b	20 89 c3	jsr $c389			jsr 	FPUNormalise 				; normalise and exit.
.c24e	7a		ply				ply
.c24f	68		pla				pla
.c250	60		rts				rts
.c251					FPCalculateExponent:
.c251	18		clc				clc
.c252	b5 84		lda $84,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.c254	75 8a		adc $8a,x			adc 	XS2_Exponent,x
.c256	b0 08		bcs $c260			bcs 	_FPCECarry 					; carry out ?
.c258	10 03		bpl $c25d			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.c25a	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.c25c	60		rts				rts
.c25d					_FPCEExpZero:
.c25d	a9 00		lda #$00			lda 	#0
.c25f	60		rts				rts
.c260					_FPCECarry:
.c260	30 03		bmi $c265			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.c262	09 80		ora #$80			ora 	#$80 						; put in right range
.c264	60		rts				rts
.c265					_FPCEOverflow:
.c265	4c e6 c3	jmp $c3e6			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.c268					FPFractionalPart:
.c268	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.c26a	38		sec				sec 								; this flag tells us to keep the fractional part
.c26b	30 0d		bmi $c27a			bmi 	FPGetPart
.c26d	60		rts				rts
.c26e					FPIntegerPart:
.c26e	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.c270	18		clc				clc 								; this flag says keep the integer part.
.c271	30 07		bmi $c27a			bmi 	FPGetPart 					; -ve exponents are 0..127
.c273	48		pha				pha
.c274	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.c276	95 85		sta $85,x			sta 	XS_Type,x
.c278	68		pla				pla
.c279	60		rts				rts
.c27a					FPGetPart:
.c27a	48		pha				pha
.c27b	5a		phy				phy 								; save Y
.c27c	08		php				php 								; save action
.c27d	34 85		bit $85,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.c27f	70 59		bvs $c2da			bvs 	_FPGP_Exit 					; then do nothing.
.c281	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.c283	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.c285	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.c287	85 1c		sta $1c				sta 	zLTemp1+2
.c289	85 1d		sta $1d				sta 	zLTemp1+3
.c28b	b5 84		lda $84,x			lda 	XS_Exponent,x				; the number of shifts.
.c28d	38		sec				sec
.c28e	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.c290	f0 12		beq $c2a4			beq 	_FPGP_NoShift 				; ... if any
.c292	c9 20		cmp #$20			cmp 	#32
.c294	90 02		bcc $c298			bcc 	_FPGP_NotMax
.c296	a9 20		lda #$20			lda 	#32 						; max of 32.
.c298					_FPGP_NotMax:
.c298	a8		tay				tay 								; Y is the mask shift count.
.c299					_FPGP_ShiftMask:
.c299	46 1d		lsr $1d				lsr 	3+zLTemp1
.c29b	66 1c		ror $1c				ror 	2+zLTemp1
.c29d	66 1b		ror $1b				ror 	1+zLTemp1
.c29f	66 1a		ror $1a				ror 	0+zLTemp1
.c2a1	88		dey				dey
.c2a2	d0 f5		bne $c299			bne 	_FPGP_ShiftMask
.c2a4					_FPGP_NoShift:
.c2a4	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.c2a6	8e 96 03	stx $0396			stx 	ExpTemp						; save X
.c2a9					_FPGP_MaskLoop:
.c2a9	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.c2ac	28		plp				plp 								; if CC we keep the top part, so we
.c2ad	08		php				php		 							; flip the mask.
.c2ae	b0 02		bcs $c2b2			bcs		_FPGP_NoFlip
.c2b0	49 ff		eor #$ff			eor 	#$FF
.c2b2					_FPGP_NoFlip:
.c2b2	35 80		and $80,x			and 	XS_Mantissa,x 				; and into the mantissa.
.c2b4	95 80		sta $80,x			sta 	XS_Mantissa,x
.c2b6	e8		inx				inx
.c2b7	c8		iny				iny
.c2b8	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.c2ba	d0 ed		bne $c2a9			bne 	_FPGP_MaskLoop
.c2bc	ae 96 03	ldx $0396			ldx 	ExpTemp						; restore X
.c2bf	28		plp				plp
.c2c0	08		php				php 								; get action flag on the stack
.c2c1	90 04		bcc $c2c7			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.c2c3	a9 00		lda #$00			lda 	#0
.c2c5	95 85		sta $85,x			sta 	XS_Type,x
.c2c7					_FPGP_NotFractional:
.c2c7	b5 80		lda $80,x			lda 	XS_Mantissa,x 						; check if \1 zero
.c2c9	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.c2cb	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.c2cd	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.c2cf	f0 05		beq $c2d6			beq 	_FPGP_Zero 					; if zero, return zero
.c2d1	20 89 c3	jsr $c389			jsr 	FPUNormalise
.c2d4	80 04		bra $c2da			bra 	_FPGP_Exit 					; and exit
.c2d6					_FPGP_Zero:
.c2d6	a9 40		lda #$40			lda 	#$40 						; set zero flag
.c2d8	95 85		sta $85,x			sta 	XS_Type,x
.c2da					_FPGP_Exit:
.c2da	68		pla				pla 								; throw saved action flag.
.c2db	7a		ply				ply
.c2dc	68		pla				pla
.c2dd	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.c2de					FPCompare:
.c2de	b5 84		lda $84,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.c2e0	48		pha				pha
.c2e1	b5 8a		lda $8a,x			lda 	XS2_Exponent,x
.c2e3	48		pha				pha
.c2e4	20 b1 c0	jsr $c0b1			jsr 	FPSubtract 					; calculate X1-X2
.c2e7	34 85		bit $85,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.c2e9	70 2a		bvs $c315			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.c2eb	68		pla				pla
.c2ec	8d 96 03	sta $0396			sta 	ExpTemp						; save first exponent in temporary reg.
.c2ef	68		pla				pla
.c2f0	38		sec				sec
.c2f1	ed 96 03	sbc $0396			sbc 	ExpTemp 					; calculate AX-BX
.c2f4	70 14		bvs $c30a			bvs 	_FPCNotEqual				; overflow, can't be equal.
.c2f6	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.c2f7	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.c2f9	b0 0f		bcs $c30a			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.c2fb	38		sec				sec
.c2fc	ad 96 03	lda $0396			lda 	ExpTemp 					; get one of the exponents back.
.c2ff	e9 12		sbc #$12			sbc 	#18 						; allow for 2^18 error, relatively.
.c301	b0 02		bcs $c305			bcs 	_FPCNotRange 				; keep in range.
.c303	a9 01		lda #$01			lda 	#1
.c305					_FPCNotRange:
.c305	38		sec				sec
.c306	f5 84		sbc $84,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.c308	b0 0d		bcs $c317			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.c30a					_FPCNotEqual:
.c30a	b5 85		lda $85,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.c30c	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.c30e	f0 02		beq $c312			beq 	_FPCNE2
.c310	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.c312	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.c313	80 04		bra $c319			bra 	_FPCExit
.c315					_FPCPullZero:
.c315	68		pla				pla 								; throw saved exponents
.c316	68		pla				pla
.c317					_FPCZero:
.c317	a9 00		lda #$00			lda 	#0 							; and return zero
.c319					_FPCExit:
.c319	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.c31a					FPUCopyX2ToX1:
.c31a	48		pha				pha
.c31b	da		phx				phx
.c31c	5a		phy				phy
.c31d	a0 08		ldy #$08			ldy 	#8
.c31f	b5 86		lda $86,x	_FPUC21:lda 	XS2_Mantissa,x
.c321	95 80		sta $80,x			sta 	XS_Mantissa,x
.c323	e8		inx				inx
.c324	88		dey				dey
.c325	10 f8		bpl $c31f			bpl 	_FPUC21
.c327	7a		ply				ply
.c328	fa		plx				plx
.c329	68		pla				pla
.c32a	60		rts				rts
.c32b					FPUSetInteger:
.c32b	48		pha				pha
.c32c	95 80		sta $80,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.c32e	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.c330	10 02		bpl $c334			bpl 	_FPUSIExtend
.c332	a9 ff		lda #$ff			lda 	#$FF
.c334					_FPUSIExtend:
.c334	95 81		sta $81,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.c336	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c338	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c33a	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.c33c	95 85		sta $85,x			sta 	XS_Type,x
.c33e	68		pla				pla
.c33f	60		rts				rts
.c340					FPUNegateInteger:
.c340	48		pha				pha
.c341	38		sec				sec
.c342	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.c344	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.c346	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c348	a9 00		lda #$00			lda 	#0
.c34a	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.c34c	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c34e	a9 00		lda #$00			lda 	#0
.c350	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.c352	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c354	a9 00		lda #$00			lda 	#0
.c356	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.c358	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c35a	68		pla				pla
.c35b	60		rts				rts
.c35c					FPUToFloat:
.c35c	48		pha				pha
.c35d	b5 85		lda $85,x			lda 	XS_Type,x					; exit if already float.
.c35f	29 0f		and #$0f			and 	#$0F
.c361	f0 24		beq $c387			beq 	_FPUFExit
.c363	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.c365	95 85		sta $85,x			sta 	XS_Type,x
.c367	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.c369	95 84		sta $84,x			sta 	XS_Exponent,x 				; x mantissa.
.c36b	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.c36d	10 07		bpl $c376			bpl		_FPUFPositive
.c36f	20 40 c3	jsr $c340			jsr 	FPUNegateInteger 			; negate the mantissa
.c372	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.c374	95 85		sta $85,x			sta 	XS_Type,x
.c376					_FPUFPositive:
.c376	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.c378	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.c37a	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.c37c	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.c37e	d0 04		bne $c384			bne 	_FPUFNonZero
.c380	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.c382	95 85		sta $85,x			sta 	XS_Type,x
.c384					_FPUFNonZero:
.c384	20 89 c3	jsr $c389			jsr 	FPUNormalise 				; normalise the floating point.
.c387					_FPUFExit:
.c387	68		pla				pla
.c388	60		rts				rts
.c389					FPUNormalise:
.c389	48		pha				pha
.c38a	34 85		bit $85,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.c38c	70 18		bvs $c3a6			bvs 	_FPUNExit
.c38e	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.c390	f0 10		beq $c3a2			beq 	_FPUNSetZero
.c392					_FPUNLoop:
.c392	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.c394	30 10		bmi $c3a6			bmi 	_FPUNExit 					; if so, we are normalised.
.c396	16 80		asl $80,x			asl 	0+XS_Mantissa+0,x
.c398	36 81		rol $81,x			rol 	1+XS_Mantissa+0,x
.c39a	36 82		rol $82,x			rol 	2+XS_Mantissa+0,x
.c39c	36 83		rol $83,x			rol 	3+XS_Mantissa+0,x
.c39e	d6 84		dec $84,x			dec 	XS_Exponent,x 				; decrement exponent
.c3a0	d0 f0		bne $c392			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.c3a2					_FPUNSetZero:
.c3a2	a9 40		lda #$40			lda 	#$40
.c3a4	95 85		sta $85,x			sta 	XS_Type,x 					; the result is now zero.
.c3a6					_FPUNExit:
.c3a6	68		pla				pla
.c3a7	60		rts				rts
.c3a8					FPUToInteger:
.c3a8	48		pha				pha
.c3a9	b5 85		lda $85,x			lda 	XS_Type,x 					; if already integer, exit
.c3ab	29 01		and #$01			and 	#1
.c3ad	d0 31		bne $c3e0			bne 	_FPUTOI_Exit
.c3af	34 85		bit $85,x			bit 	XS_Type,x					; if zero, return zero.
.c3b1	70 23		bvs $c3d6			bvs 	_FPUTOI_Zero
.c3b3	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.c3b5	10 1f		bpl $c3d6			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.c3b7	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.c3b9	b0 2b		bcs $c3e6			bcs 	FP_Overflow
.c3bb					_FPUToIToInteger:
.c3bb	b5 84		lda $84,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.c3bd	c9 a0		cmp #$a0			cmp 	#128+32
.c3bf	f0 0c		beq $c3cd			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.c3c1	f6 84		inc $84,x			inc 	XS_Exponent,X 				; increment Exponent
.c3c3	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.c3c5	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.c3c7	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.c3c9	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.c3cb	80 ee		bra $c3bb			bra 	_FPUToIToInteger 			; keep going.
.c3cd					_FPUToICheckSign:
.c3cd	b5 85		lda $85,x			lda 	XS_Type,x 					; check sign
.c3cf	10 0f		bpl $c3e0			bpl 	_FPUToI_Exit 				; exit if unsigned.
.c3d1	20 40 c3	jsr $c340			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.c3d4	80 0a		bra $c3e0			bra 	_FPUTOI_Exit
.c3d6					_FPUTOI_Zero:
.c3d6	a9 00		lda #$00			lda 	#0 							; return zero integer.
.c3d8	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c3da	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c3dc	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c3de	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c3e0					_FPUToI_Exit:
.c3e0	a9 01		lda #$01			lda 	#1 							; set type to integer
.c3e2	95 85		sta $85,x			sta 	XS_Type,x
.c3e4	68		pla				pla
.c3e5	60		rts				rts
.c3e6					FP_Overflow:
.c3e6	20 4c ad	jsr $ad4c			jsr ERR_Handler
>c3e9	46 6c 6f 61 74 69 6e 67			.text "Floating Point overflow",0
>c3f1	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.c401					FPUTimes10:
.c401	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.c403	85 1a		sta $1a				sta 	ZLTemp1+0
.c405	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c407	85 1b		sta $1b				sta 	ZLTemp1+1
.c409	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c40b	85 1c		sta $1c				sta 	ZLTemp1+2
.c40d	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.c40f	85 1d		sta $1d				sta 	ZLTemp1+3
.c411	20 46 c4	jsr $c446			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.c414	20 46 c4	jsr $c446			jsr 	_FPUT_LSR_ZLTemp1
.c417	18		clc				clc
.c418	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.c41a	65 1a		adc $1a				adc 	ZLTemp1+0
.c41c	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c41e	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c420	65 1b		adc $1b				adc 	ZLTemp1+1
.c422	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c424	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c426	65 1c		adc $1c				adc 	ZLTemp1+2
.c428	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c42a	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.c42c	65 1d		adc $1d				adc 	ZLTemp1+3
.c42e	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c430	90 0a		bcc $c43c			bcc 	_FPUTimes10
.c432	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.c434	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.c436	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.c438	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.c43a	f6 84		inc $84,x			inc 	XS_Exponent,x				; fix exponent
.c43c					_FPUTimes10:
.c43c	b5 84		lda $84,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.c43e	18		clc				clc
.c43f	69 03		adc #$03			adc 	#3
.c441	95 84		sta $84,x			sta 	XS_Exponent,x
.c443	b0 a1		bcs $c3e6			bcs 	FP_Overflow 				; error
.c445	60		rts				rts
.c446					_FPUT_LSR_ZLTemp1:
.c446	46 1d		lsr $1d				lsr 	ZLTemp1+3
.c448	66 1c		ror $1c				ror 	ZLTemp1+2
.c44a	66 1b		ror $1b				ror 	ZLTemp1+1
.c44c	66 1a		ror $1a				ror 	ZLTemp1+0
.c44e	60		rts				rts
.c44f					FPUScale10A:
.c44f	5a		phy				phy
.c450	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.c452	f0 37		beq $c48b			beq 	_FPUScaleExit
.c454	da		phx				phx 								; save X
.c455	e8		inx				inx
.c456	e8		inx				inx
.c457	e8		inx				inx
.c458	e8		inx				inx
.c459	e8		inx				inx
.c45a	e8		inx				inx
.c45b	a8		tay				tay 								; save power scalar in Y.
.c45c	a9 00		lda #$00			lda 	#0
.c45e	95 80		sta $80,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.c460	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c462	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c464	95 85		sta $85,x			sta 	XS_Type,x
.c466	a9 80		lda #$80			lda 	#$80
.c468	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c46a	a9 81		lda #$81			lda 	#$81
.c46c	95 84		sta $84,x			sta 	XS_Exponent,x
.c46e	5a		phy				phy 								; save 10^n on stack.
.c46f	c0 00		cpy #$00			cpy 	#0
.c471	10 05		bpl $c478			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.c473	98		tya				tya
.c474	49 ff		eor #$ff			eor 	#$FF
.c476	1a		inc a				inc 	a
.c477	a8		tay				tay
.c478					_FPUSAbs:
.c478	20 01 c4	jsr $c401			jsr 	FPUTimes10
.c47b	88		dey				dey
.c47c	d0 fa		bne $c478			bne 	_FPUSAbs 					; tos is now 10^|AC|
.c47e	68		pla				pla 								; restore count in A
.c47f	fa		plx				plx 								; restore X pointing to number to scale.
.c480	0a		asl a				asl 	a
.c481	b0 05		bcs $c488			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.c483	20 e0 c1	jsr $c1e0			jsr 	FPMultiply 					; if clear multiply.
.c486	80 03		bra $c48b			bra		_FPUScaleExit
.c488					_FPUSDivide:
.c488	20 6d c1	jsr $c16d			jsr 	FPDivide
.c48b					_FPUScaleExit:
.c48b	7a		ply				ply
.c48c	60		rts				rts
.c48d					FPUCopyToNext:
.c48d	a0 06		ldy #$06			ldy 		#6
.c48f	da		phx				phx
.c490					_FPUCopy1:
.c490	b5 80		lda $80,x			lda 	XS_Mantissa,x
.c492	95 86		sta $86,x			sta 	XS2_Mantissa,x
.c494	e8		inx				inx
.c495	88		dey				dey
.c496	d0 f8		bne $c490			bne 	_FPUCopy1
.c498	fa		plx				plx
.c499	60		rts				rts
.c49a					FPUCopyFromNext:
.c49a	a0 06		ldy #$06			ldy 		#6
.c49c	da		phx				phx
.c49d					_FPUCopy1:
.c49d	b5 86		lda $86,x			lda 	XS2_Mantissa,x
.c49f	95 80		sta $80,x			sta 	XS_Mantissa,x
.c4a1	e8		inx				inx
.c4a2	88		dey				dey
.c4a3	d0 f8		bne $c49d			bne 	_FPUCopy1
.c4a5	fa		plx				plx
.c4a6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.c4a7					FPToString:
.c4a7	48		pha				pha
.c4a8	5a		phy				phy
.c4a9	34 85		bit $85,x			bit 		XS_Type,x 				; check zero flag
.c4ab	50 0a		bvc $c4b7			bvc 		_FPTSIsFloat 			; if zero,
.c4ad					_FPTSZero:
.c4ad	a9 30		lda #$30			lda 		#"0"
.c4af	20 0e c0	jsr $c00e			jsr 		ITSOutputCharacter
.c4b2					_FPTSExit:
.c4b2	7a		ply				ply
.c4b3	68		pla				pla
.c4b4	60		rts				rts
.c4b5	80 fb		bra $c4b2			bra 		_FPTSExit
.c4b7					_FPTSIsFloat:
.c4b7	b5 85		lda $85,x			lda 		XS_Type,x 				; is it signed ?
.c4b9	10 09		bpl $c4c4			bpl 		_FPTSNotSigned
.c4bb	a9 00		lda #$00			lda 		#0 						; clear sign flag
.c4bd	95 85		sta $85,x			sta 		XS_Type,x
.c4bf	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.c4c1	20 0e c0	jsr $c00e			jsr 		ITSOutputCharacter
.c4c4					_FPTSNotSigned:
.c4c4	b5 84		lda $84,x			lda 		XS_Exponent,x
.c4c6	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.c4c8	b0 09		bcs $c4d3			bcs 		_FPTSExponent
.c4ca	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.c4cc	90 05		bcc $c4d3			bcc 		_FPTSExponent 			;
.c4ce					_FPTSStandard:
.c4ce	20 12 c5	jsr $c512			jsr 		FPTOutputBody 			; output the body.
.c4d1	80 df		bra $c4b2			bra 		_FPTSExit
.c4d3					_FPTSExponent:
.c4d3	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.c4d5	8d 97 03	sta $0397			sta 		ExpCount
.c4d8					_FPTSExponentLoop:
.c4d8	b5 84		lda $84,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.c4da	10 0e		bpl $c4ea			bpl 		_FPTSTimes
.c4dc	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.c4de	90 14		bcc $c4f4			bcc 		_FPTSScaledToExp
.c4e0	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.c4e2	20 4f c4	jsr $c44f			jsr 		FPUScale10A
.c4e5	ee 97 03	inc $0397			inc 		ExpCount
.c4e8	80 ee		bra $c4d8			bra 		_FPTSExponentLoop
.c4ea					_FPTSTimes:
.c4ea	a9 01		lda #$01			lda 		#1
.c4ec	20 4f c4	jsr $c44f			jsr 		FPUScale10A
.c4ef	ce 97 03	dec $0397			dec 		ExpCount
.c4f2	80 e4		bra $c4d8			bra 		_FPTSExponentLoop
.c4f4					_FPTSScaledToExp:
.c4f4	20 12 c5	jsr $c512			jsr 		FPTOutputBody 			; output the body.
.c4f7	a9 65		lda #$65			lda 		#"e"					; output E
.c4f9	20 0e c0	jsr $c00e			jsr 		ITSOutputCharacter
.c4fc	ad 97 03	lda $0397			lda 		ExpCount 				; get the exponent
.c4ff	95 80		sta $80,x			sta 		XS_Mantissa,x
.c501	29 80		and #$80			and 		#$80 					; sign extend it
.c503	f0 02		beq $c507			beq 		_FPTSSExt
.c505	a9 ff		lda #$ff			lda 		#$FF
.c507					_FPTSSExt:
.c507	95 81		sta $81,x			sta 		XS_Mantissa+1,x
.c509	95 82		sta $82,x			sta 		XS_Mantissa+2,x
.c50b	95 83		sta $83,x			sta 		XS_Mantissa+3,x
.c50d	20 70 bf	jsr $bf70			jsr 		INTToString 			; output the exponent.
.c510	80 a0		bra $c4b2			bra			_FPTSExit 				; and exit.
.c512					FPTOutputBody:
.c512	20 8d c4	jsr $c48d			jsr 		FPUCopyToNext 			; copy to next slot.
.c515	20 a8 c3	jsr $c3a8			jsr 		FPUToInteger 			; convert to an integer
.c518	20 70 bf	jsr $bf70			jsr 		INTToString 			; output the main integer part.
.c51b	20 9a c4	jsr $c49a			jsr 		FPUCopyFromNext 		; get the fractional part back.
.c51e	20 68 c2	jsr $c268			jsr 		FPFractionalPart 		; get the decimal part.
.c521	34 85		bit $85,x			bit 		XS_Type,x 				; any fractional part.
.c523	70 3c		bvs $c561			bvs 		_FPTOExit 				; if not, exit now.
.c525	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.c527	20 0e c0	jsr $c00e			jsr 		ITSOutputCharacter
.c52a					_FPOutLoop:
.c52a	34 85		bit $85,x			bit 		XS_Type,x 				; finally reached zero.
.c52c	70 1d		bvs $c54b			bvs 		_FPStripZeros 			; strip trailing zeros
.c52e	20 01 c4	jsr $c401			jsr 		FPUTimes10 				; multiply by 10
.c531	20 8d c4	jsr $c48d			jsr 		FPUCopyToNext			; copy to next slot.
.c534	20 a8 c3	jsr $c3a8			jsr 		FPUToInteger 			; convert to integer
.c537	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; print digit.
.c539	09 30		ora #$30			ora 		#"0"
.c53b	20 0e c0	jsr $c00e			jsr 		ITSOutputCharacter
.c53e	20 9a c4	jsr $c49a			jsr 		FPUCopyFromNext 		; get it back
.c541	20 68 c2	jsr $c268			jsr 		FPFractionalPart 		; get fractional part
.c544	ad 0e 03	lda $030e			lda 		NumBufX 				; done 11 characters yet ?
.c547	c9 0b		cmp #$0b			cmp 	 	#11
.c549	90 df		bcc $c52a			bcc 		_FPOutLoop 				; if so, keep going till zero.
.c54b					_FPStripZeros:
.c54b	ac 0e 03	ldy $030e			ldy 		NumBufX 				; strip trailing zeros.
.c54e					_FPStripLoop:
.c54e	88		dey				dey 								; back one, if at start then no strip
.c54f	f0 10		beq $c561			beq 		_FPToExit
.c551	b9 0f 03	lda $030f,y			lda 		Num_Buffer,y 			; keep going if "0"
.c554	c9 30		cmp #$30			cmp 		#"0"
.c556	f0 f6		beq $c54e			beq 		_FPStripLoop
.c558	c8		iny				iny
.c559	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.c55b	99 0f 03	sta $030f,y			sta 		Num_Buffer,y
.c55e	8c 0e 03	sty $030e			sty 		NumBufX 				; update position.
.c561					_FPTOExit:
.c561	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.c562					FPFromString:
.c562	48		pha				pha 								; push A
.c563	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.c565	c9 2e		cmp #$2e			cmp 	#"."
.c567	f0 03		beq $c56c			beq	 	_FPFIsDecimal
.c569	4c c8 c5	jmp $c5c8			jmp 	_FPFNotDecimal
.c56c					_FPFIsDecimal:
.c56c	c8		iny				iny 								; consume the decimal.
.c56d	20 5c c3	jsr $c35c			jsr 	FPUToFloat 					; convert the integer to float.
.c570	da		phx				phx 								; save X.
.c571	5a		phy				phy 								; save decimal start position
.c572	e8		inx				inx
.c573	e8		inx				inx
.c574	e8		inx				inx
.c575	e8		inx				inx
.c576	e8		inx				inx
.c577	e8		inx				inx
.c578	20 26 c0	jsr $c026			jsr 	INTFromStringY 				; get the part after the DP.
.c57b	20 5c c3	jsr $c35c			jsr 	FPUToFloat 					; convert that to a float.
.c57e	68		pla				pla 								; calculate - chars consumed.
.c57f	8c 96 03	sty $0396			sty 	ExpTemp
.c582	38		sec				sec
.c583	ed 96 03	sbc $0396			sbc 	ExpTemp 					; this is the shift amount
.c586	20 4f c4	jsr $c44f			jsr 	FPUScale10A 				; scale it by 10^AC
.c589	fa		plx				plx 								; restore original X
.c58a	20 b9 c0	jsr $c0b9			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.c58d	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.c58f	c9 45		cmp #$45			cmp 	#"E"
.c591	f0 04		beq $c597			beq 	_FPFExponent
.c593	c9 65		cmp #$65			cmp 	#"e"
.c595	d0 31		bne $c5c8			bne 	_FPFNotDecimal 				; no, then exit normally.
.c597					_FPFExponent:
.c597	c8		iny				iny 								; skip over E symbol.
.c598	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.c59a	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.c59c	d0 01		bne $c59f			bne 	_FPFGotSign
.c59e	c8		iny				iny 								; if it was - skip over it.
.c59f					_FPFGotSign:
.c59f	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.c5a0	da		phx				phx
.c5a1	e8		inx				inx
.c5a2	e8		inx				inx
.c5a3	e8		inx				inx
.c5a4	e8		inx				inx
.c5a5	e8		inx				inx
.c5a6	e8		inx				inx
.c5a7	20 26 c0	jsr $c026			jsr 	INTFromStringY 				; get the exponent
.c5aa	fa		plx				plx 								; restore X.
.c5ab	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.c5ad	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.c5af	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.c5b1	d0 17		bne $c5ca			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.c5b3	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.c5b5	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.c5b7	b0 11		bcs $c5ca			bcs 	_FPFXOverflow
.c5b9	68		pla				pla 								; get direction
.c5ba	d0 07		bne $c5c3			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.c5bc	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.c5be	49 ff		eor #$ff			eor 	#$FF
.c5c0	1a		inc a				inc 	a
.c5c1	95 86		sta $86,x			sta 	XS2_Mantissa+0,x
.c5c3					_FPFXScale:
.c5c3	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.c5c5	20 4f c4	jsr $c44f			jsr 	FPUScale10A 				; scale by the exponent.
.c5c8					_FPFNotDecimal:
.c5c8	68		pla				pla
.c5c9	60		rts				rts
.c5ca					_FPFXOverflow:
.c5ca	20 4c ad	jsr $ad4c			jsr 	ERR_Handler
>c5cd	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>c5d5	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.c5dc					Unary_Rnd:
.c5dc	20 ca b3	jsr $b3ca			jsr 	EvaluateNumberX 			; get value
.c5df	20 e6 b9	jsr $b9e6			jsr 	CheckNextRParen 			; check right bracket.
.c5e2	20 48 b6	jsr $b648			jsr 	GetSignCurrent 				; get sign -1,0,1.
.c5e5	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.c5e7	30 10		bmi $c5f9			bmi 	_URSetSeed
.c5e9	f0 28		beq $c613			beq 	_URMakeRandom 				; if zero return same number.
.c5eb	da		phx				phx
.c5ec	a2 00		ldx #$00			ldx 	#0
.c5ee	20 4a c6	jsr $c64a			jsr 	Random16
.c5f1	a2 02		ldx #$02			ldx 	#2
.c5f3	20 4a c6	jsr $c64a			jsr 	Random16
.c5f6	fa		plx				plx
.c5f7	80 1a		bra $c613			bra 	_URMakeRandom
.c5f9					_URSetSeed:
.c5f9	20 5c c3	jsr $c35c			jsr 	FPUToFloat 					; make it a float to twiddle it.
.c5fc	b5 80		lda $80,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.c5fe	8d 9d 03	sta $039d			sta 	RandomSeed+0
.c601	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.c603	8d 9e 03	sta $039e			sta 	RandomSeed+1
.c606	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.c608	8d 9f 03	sta $039f			sta 	RandomSeed+2
.c60b	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.c60d	0a		asl a				asl 	a
.c60e	49 db		eor #$db			eor 	#$DB
.c610	8d a0 03	sta $03a0			sta 	RandomSeed+3
.c613					_URMakeRandom:
.c613	ad 9d 03	lda $039d			lda 	RandomSeed+0 				; check if seed is zero.
.c616	0d 9e 03	ora $039e			ora 	RandomSeed+1
.c619	0d 9f 03	ora $039f			ora 	RandomSeed+2
.c61c	0d a0 03	ora $03a0			ora 	RandomSeed+3
.c61f	d0 0a		bne $c62b			bne 	_URNotZero
.c621	a9 47		lda #$47			lda 	#$47
.c623	8d 9e 03	sta $039e			sta 	RandomSeed+1				; if it is, make it non zero.
.c626	a9 3d		lda #$3d			lda 	#$3D
.c628	8d a0 03	sta $03a0			sta 	RandomSeed+3
.c62b					_URNotZero:
.c62b	ad 9d 03	lda $039d			lda 	RandomSeed+0 				; copy seed into mantissa.
.c62e	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c630	ad 9e 03	lda $039e			lda 	RandomSeed+1
.c633	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c635	ad 9f 03	lda $039f			lda 	RandomSeed+2
.c638	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c63a	ad a0 03	lda $03a0			lda 	RandomSeed+3
.c63d	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c63f	a9 00		lda #$00			lda 	#$00 						; set type to float.
.c641	95 85		sta $85,x			sta 	XS_Type,x
.c643	a9 80		lda #$80			lda 	#$80
.c645	95 84		sta $84,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.c647	4c 89 c3	jmp $c389			jmp 	FPUNormalise
.c64a					Random16:
.c64a	5e 9e 03	lsr $039e,x			lsr 	RandomSeed+1,x				; shift seed right
.c64d	7e 9d 03	ror $039d,x			ror 	RandomSeed,x
.c650	90 08		bcc $c65a			bcc 	_R16_NoXor
.c652	bd 9e 03	lda $039e,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.c655	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.c657	9d 9e 03	sta $039e,x			sta 	RandomSeed+1,x
.c65a					_R16_NoXor:
.c65a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.c65b					Unary_Int:
.c65b	20 ca b3	jsr $b3ca			jsr 	EvaluateNumberX 			; get value
.c65e	20 e6 b9	jsr $b9e6			jsr 	CheckNextRParen 			; check right bracket.
.c661	4c a8 c3	jmp $c3a8			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Return to file: basic.asm

.c664	80 fe		bra $c664	_halt:	bra 		_halt
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 a0						.word 	StartROM
>fffe	95 ac					.word TIM_BreakVector

;******  End of listing
