
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -Wall -b -q -L rom.lst -o rom.bin basic.asm
; Wed Sep  4 18:08:32 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="65816"				cpu = "65816"
="em65816"				hardware = "em65816"
=0					exitonend = 0
=0					autorun = 0
=0					loadtest = 0
=0					hasfloat = 0
=1					hasinteger = 1
=253					maxstring = 253

;******  Processing file: modules/basic/pointer/em65816/src_em65816.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stackmarkers.inc

=5					SourcePosSize   =   5 							; Source position stack space needed.
=1					SMark_Gosub 	= 	1 							; 0 is GOSUB/RETURN.
=2					SMark_Repeat 	= 	2 							; 1 is REPEAT/UNTIL.
=3					SMark_While 	= 	3 							; 2 is WHILE/WEND.
=4					SMark_If 		= 	4 							; 3 is IF/ENDIF
=5					SMark_For 		= 	5 							; 4 is FOR/NEXT

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/hardware/common/macros32.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zTemp4: 	.word ?
>0018					zCodePtr:	.dword ? 						; code pointer (long)
>001c					zLTemp1:	.dword ?						; long word (used in multiply)
>0020					zGenPtr:	.word ? 						; general pointer.
>0022					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0024					zVarDataPtr: .word ? 						; position of variable data.
>0026					zVarType: 	.byte ? 						; type of data (token)
>0027					zNullString:.byte ? 						; represents a NULL string.
>0028					zBasicSP:	.word ? 						; stack pointer
>0080					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>0084					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>0085					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=134					XS2_Mantissa = XS_Mantissa+XS_Size
=138					XS2_Exponent = XS_Exponent+XS_Size
=139					XS2_Type = XS_Type+XS_Size
=140					XS3_Mantissa = XS_Mantissa+XS_Size*2
=144					XS3_Exponent = XS_Exponent+XS_Size*2
=145					XS3_Type = XS_Type+XS_Size*2
>0300					StringPtr:	.word ? 						; Top of free memory (for string allocation)
>0302					VarMemPtr: 	.word ?							; Bottom of free memory (for variables)
>0304					endOfProgram: .dword ? 						; End of Program Memory (long)
>0308					vecPrintCharacter .word ?
>030a					vecInputCharacter .word ?
>030c					UserVector .fill 4 							; USR(x) calls this.
>0310					LocalVector .fill 4 						; Indirect calls call this.
>0314					NumBufX 	.byte 	?						; buffer index position
>0315					Num_Buffer	.fill 	32 						; buffer for numeric conversions
=6					HashTableCount = 6 							; there are 6 hash tables, in token order.
=8					HashTableSize = 8 							; each hash table as 8 links.
.0335					HashTableBase:
>0335								.fill	HashTableCount * HashTableSize * 2
.0395					HashTableEnd:
=$315					Var_Buffer 	= Num_Buffer 					; buffer for variable name (same space)
>0395					Var_Type    .byte ? 						; type of variable (as a type token)
>0396					Var_Hash 	.byte ? 						; hash of identifier name.
>0397					Var_Length 	.byte ? 						; length of variable name
>0398					Var_HashAddress .byte ?						; low byte of hash table entry.
>0399					Var_DataSize .byte ?						; size of one element.
>039a					NumSuppress	.byte 	?						; leading zero suppression flag
>039b					NumConvCount .byte 	? 						; count for conversions.
>039c					ExpTemp:	.byte ?							; Working temp for exponents.
>039d					ExpCount:	.byte ? 						; Count of decimal exponents.
>039e					SignCount:	.byte ?							; Integer Divide Sign Counts.
>039f					TempStringWriteIndex: .byte ? 				; Write offset.
>03a0					ValSign: 	.byte ? 						; sign flag for val()
>03a1					SliceStart:	.byte ? 						; string slice parts
>03a2					SliceCount:	.byte ?
>03a3					RandomSeed:	.dword ? 						; Random seed.
>03a7					SignNext:	.byte ? 						; Used for keeping sign of STEP in FOR/NEXT
>03a8					BreakCount:	.byte ? 						; Counter, avoid checking break every command.
=3					ArrayMaxDim = 3 							; number of dimensions.
>03a9					ArrayDef:	.fill (ArrayMaxDim+1)*2 		; dimensions for auto-creation
>03b1					UsrArrayDef:.fill (ArrayMaxDim+1)*2 		; dimensions created in DIM
>03b9					UsrArrayIdx:.byte ? 						; index into UsrArrayDef
>03ba					LastPrinted:.byte ? 						; last printed char ?
>03bb					ListIndent: .byte ? 						; list indent level
>03bc					LastListIndent:.byte ? 						; previous one.
>03bd					DataLPtr: 	.dword ?						; the data long ptr (swapped with zCodePtr)
>03c1					DataIndex:	.byte ?							; index position.
>03c2					InputAvailable: .byte ? 					; characters available in input buffer.
>03c3					InputRetry:	.byte ? 						; true if INPUT is retrying.
>03c4					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>03c6					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>03c8					Tim_SR:		.byte ? 						; Processor Status
>03c9					Tim_A:		.byte ? 						; Processor Registers
>03ca					Tim_X:		.byte ?
>03cb					Tim_Y:		.byte ?
>03cc					Tim_Z:		.byte ?
>03cd					Tim_SP:		.word ?							; Stack Pointer (just in cases)
.0400					TokeniseBuffer:
>0400								.fill 	256
>0500					IFT_XCursor:.byte ?							; current logical position on screen
>0501					IFT_YCursor:.byte ?
>0502					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0566					IFT_LineBuffer: .fill 100 					; line input buffer.
>05ca					BasicStack:	.fill 	256 					; and occupy whole pages.
.06ca					EndBasicStack:

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/em65816.asm

=$7f00					HighMemory = $7F00
=0					VariableMemory = 0
.1000					BasicProgram:
.c000					StartROM:
.c000	18		clc				clc
.c001	fb		xce				xce
.c002	c2 30		rep #$30			rep 	#$30
.c004	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.c007	1b		tcs				tcs
.c008	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.c00b	e2 30		sep #$30			sep 	#$30
.c00d	c2 30		rep #$30			rep 	#$30						; clear AXY in 16 bit.
.c00f	a9 00		lda #$00			lda 	#$0000
.c011	aa		tax				tax
.c012	a8		tay				tay
.c013	e2 30		sep #$30			sep 	#$30
.c015	5c 11 88 01	jmp $018811		jmp BASIC_Start
.c019					TIM_BreakHandler:
.c019	5c 76 83 01	jmp $018376			jmp 	TIM_BreakVector

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.018000					IFT_ClearScreen:
.018000	48		pha				pha
.018001	da		phx				phx
.018002	5a		phy				phy
.018003	20 a9 81	jsr $0181a9			jsr 	IF_Home 					; home cursor
.018006	a2 20		ldx #$20			ldx 	#IF_Height 					; this many lines.
.018008					_IFT_CS0:
.018008	a0 40		ldy #$40			ldy 	#IF_Width 					; this many chars/line
.01800a					_IFT_CS1:
.01800a	a9 20		lda #$20			lda 	#' '						; clear line.
.01800c	20 d5 81	jsr $0181d5			jsr 	IF_Write
.01800f	88		dey				dey
.018010	d0 f8		bne $01800a			bne 	_IFT_CS1
.018012	20 bc 81	jsr $0181bc			jsr 	IF_NewLine 					; next line down
.018015	ca		dex				dex
.018016	d0 f0		bne $018008			bne 	_IFT_CS0
.018018	7a		ply				ply
.018019	fa		plx				plx
.01801a	68		pla				pla
.01801b					IFT_HomeCursor:
.01801b	48		pha				pha
.01801c	20 a9 81	jsr $0181a9			jsr 	IF_Home
.01801f	a9 00		lda #$00			lda 	#0
.018021	8d 00 05	sta $0500			sta 	IFT_XCursor
.018024	8d 01 05	sta $0501			sta 	IFT_YCursor
.018027	68		pla				pla
.018028	60		rts				rts
.018029					IFT_UpLine:
.018029	48		pha				pha
.01802a	ad 01 05	lda $0501			lda  	IFT_YCursor 				; get Y
.01802d	3a		dec a				dec 	a 							; line above
.01802e	30 03		bmi $018033			bmi 	_IFTULExit 					; too far, abort
.018030	20 c8 80	jsr $0180c8			jsr 	IFT_SetYPos					; set to that line.
.018033					_IFTULExit:
.018033	68		pla				pla
.018034	60		rts				rts
.018035					IFT_PrintCharacter:
.018035	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.018037	f0 20		beq $018059			beq 	IFT_NewLine
.018039	c9 08		cmp #$08			cmp 	#8
.01803b	f0 16		beq $018053			beq 	_IFT_Left
.01803d	48		pha				pha
.01803e	20 71 80	jsr $018071			jsr 	IFT_UpperCase 				; make upper case
.018041	20 d5 81	jsr $0181d5			jsr 	IF_Write 					; write out.
.018044	ee 00 05	inc $0500			inc 	IFT_XCursor 				; bump x cursor
.018047	ad 00 05	lda $0500			lda 	IFT_XCursor 				; reached RHS ?
.01804a	c9 40		cmp #$40			cmp 	#IF_Width
.01804c	d0 03		bne $018051			bne 	_IFT_PCNotEOL
.01804e	20 59 80	jsr $018059			jsr 	IFT_NewLine 				; if so do new line.
.018051					_IFT_PCNotEOL:
.018051	68		pla				pla
.018052	60		rts				rts
.018053					_IFT_Left:
.018053	48		pha				pha
.018054	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.018057	68		pla				pla
.018058	60		rts				rts
.018059					IFT_NewLine:
.018059	48		pha				pha
.01805a	20 bc 81	jsr $0181bc			jsr 	IF_NewLine 					; new line on actual screen.
.01805d	a9 00		lda #$00			lda 	#0 							; reset x position
.01805f	8d 00 05	sta $0500			sta 	IFT_XCursor
.018062	ee 01 05	inc $0501			inc 	IFT_YCursor 				; move down.
.018065	ad 01 05	lda $0501			lda 	IFT_YCursor
.018068	c9 20		cmp #$20			cmp 	#IF_Height 					; reached bottom.
.01806a	d0 03		bne $01806f			bne 	_IFT_NL_NotEOS
.01806c	20 7c 80	jsr $01807c			jsr 	IFT_Scroll 					; scroll screen up.
.01806f					_IFT_NL_NotEOS:
.01806f	68		pla				pla
.018070	60		rts				rts
.018071					IFT_UpperCase:
.018071	c9 61		cmp #$61			cmp 	#"a"
.018073	90 06		bcc $01807b			bcc 	_IFT_UCExit
.018075	c9 7b		cmp #$7b			cmp 	#"z"+1
.018077	b0 02		bcs $01807b			bcs 	_IFT_UCExit
.018079	49 20		eor #$20			eor 	#$20
.01807b					_IFT_UCExit:
.01807b	60		rts				rts
.01807c					IFT_Scroll:
.01807c	48		pha				pha 								; save AXY
.01807d	da		phx				phx
.01807e	5a		phy				phy
.01807f	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.018081					_IFT_SLoop:
.018081	20 a1 80	jsr $0180a1			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.018084	e8		inx				inx
.018085	e0 1f		cpx #$1f			cpx 	#IF_Height-1				; do whole screen
.018087	d0 f8		bne $018081			bne 	_IFT_SLoop
.018089	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.01808b	20 c8 80	jsr $0180c8			jsr 	IFT_SetYPos
.01808e	a2 40		ldx #$40			ldx 	#IF_Width 					; blank line
.018090					_IFT_SBlank:
.018090	a9 20		lda #$20			lda 	#32
.018092	20 d5 81	jsr $0181d5			jsr 	IF_Write
.018095	ca		dex				dex
.018096	d0 f8		bne $018090			bne 	_IFT_SBlank
.018098	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.01809a	20 c8 80	jsr $0180c8			jsr 	IFT_SetYPos
.01809d	7a		ply				ply
.01809e	fa		plx				plx
.01809f	68		pla				pla
.0180a0	60		rts				rts
.0180a1					_IFT_ScrollLine:
.0180a1	da		phx				phx
.0180a2	da		phx				phx
.0180a3	8a		txa				txa 								; copy line into buffer.
.0180a4	1a		inc a				inc 	a 							; next line down.
.0180a5	20 c8 80	jsr $0180c8			jsr 	IFT_SetYPos
.0180a8	a2 00		ldx #$00			ldx 	#0
.0180aa					_IFTScrollCopy1:
.0180aa	20 cc 81	jsr $0181cc			jsr 	IF_Read
.0180ad	9d 02 05	sta $0502,x			sta 	IFT_Buffer,x
.0180b0	e8		inx				inx
.0180b1	e0 40		cpx #$40			cpx 	#IF_Width
.0180b3	d0 f5		bne $0180aa			bne 	_IFTScrollCopy1
.0180b5	68		pla				pla
.0180b6	20 c8 80	jsr $0180c8			jsr 	IFT_SetYPos
.0180b9	a2 00		ldx #$00			ldx 	#0
.0180bb					_IFTScrollCopy2:
.0180bb	bd 02 05	lda $0502,x			lda 	IFT_Buffer,x
.0180be	20 d5 81	jsr $0181d5			jsr 	IF_Write
.0180c1	e8		inx				inx
.0180c2	e0 40		cpx #$40			cpx 	#IF_Width
.0180c4	d0 f5		bne $0180bb			bne 	_IFTScrollCopy2
.0180c6	fa		plx				plx
.0180c7	60		rts				rts
.0180c8					IFT_SetYPos:
.0180c8	48		pha				pha
.0180c9	da		phx				phx
.0180ca	aa		tax				tax
.0180cb	20 1b 80	jsr $01801b			jsr 	IFT_HomeCursor
.0180ce	e0 00		cpx #$00			cpx 	#0
.0180d0	f0 09		beq $0180db			beq 	_IFT_MOAExit
.0180d2					_IFT_MOALoop:
.0180d2	20 bc 81	jsr $0181bc			jsr 	IF_NewLine
.0180d5	ee 01 05	inc $0501			inc 	IFT_YCursor
.0180d8	ca		dex				dex
.0180d9	d0 f7		bne $0180d2			bne		_IFT_MOALoop
.0180db					_IFT_MOAExit:
.0180db	fa		plx				plx
.0180dc	68		pla				pla
.0180dd	60		rts				rts
.0180de					IFT_GetKeyCursor:
.0180de	20 e6 80	jsr $0180e6			jsr 	_IFT_FlipCursor 			; reverse current
.0180e1					_IFT_GKCWait:
.0180e1	20 e6 81	jsr $0181e6			jsr 	IF_GetKey 					; get key
.0180e4	f0 fb		beq $0180e1			beq 	_IFT_GKCWait
.0180e6					_IFT_FlipCursor:
.0180e6	48		pha				pha 								; save
.0180e7	20 cc 81	jsr $0181cc			jsr 	IF_Read 					; read
.0180ea	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.0180ed	49 80		eor #$80			eor 	#$80 						; reverse
.0180ef	20 d5 81	jsr $0181d5			jsr 	IF_Write 					; write
.0180f2	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.0180f5	68		pla				pla
.0180f6	60		rts				rts
.0180f7					IFT_ReadLine:
.0180f7	48		pha				pha
.0180f8					_IFT_RLLoop:
.0180f8	20 de 80	jsr $0180de			jsr 	IFT_GetKeyCursor 			; get keystroke
.0180fb	c9 0d		cmp #$0d			cmp 	#13							; return
.0180fd	f0 7d		beq $01817c			beq 	_IFT_RLExit
.0180ff	c9 20		cmp #$20			cmp 	#32 						; control character
.018101	90 05		bcc $018108			bcc 	_IFT_Control
.018103	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018106	80 f0		bra $0180f8			bra 	_IFT_RLLoop
.018108					_IFT_Control:
.018108	c9 01		cmp #$01			cmp 	#"A"-64
.01810a	f0 26		beq $018132			beq 	_IFT_Left
.01810c	c9 04		cmp #$04			cmp 	#"D"-64
.01810e	f0 2e		beq $01813e			beq 	_IFT_Right
.018110	c9 17		cmp #$17			cmp 	#"W"-64
.018112	f0 36		beq $01814a			beq 	_IFT_Up
.018114	c9 13		cmp #$13			cmp 	#"S"-64
.018116	f0 3e		beq $018156			beq 	_IFT_Down
.018118	c9 08		cmp #$08			cmp 	#"H"-64
.01811a	f0 09		beq $018125			beq 	_IFT_Backspace
.01811c	c9 1a		cmp #$1a			cmp 	#"Z"-64
.01811e	d0 d8		bne $0180f8			bne 	_IFT_RLLoop
.018120	20 00 80	jsr $018000			jsr 	IFT_ClearScreen				; clear CTL-Z
.018123	80 d3		bra $0180f8			bra 	_IFT_RLLoop
.018125					_IFT_Backspace:
.018125	ad 00 05	lda $0500			lda 	IFT_XCursor 				; check not start of line.
.018128	f0 ce		beq $0180f8			beq 	_IFT_RLLoop
.01812a	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.01812d	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.01812f	20 d5 81	jsr $0181d5			jsr 	IF_Write
.018132					_IFT_Left:
.018132	ce 00 05	dec $0500			dec 	IFT_XCursor 				; left CTL-W
.018135	10 29		bpl $018160			bpl 	_IFT_Reposition
.018137	a9 3f		lda #$3f			lda 	#IF_Width-1
.018139					_IFT_SetX:
.018139	8d 00 05	sta $0500			sta 	IFT_XCursor
.01813c	80 22		bra $018160			bra 	_IFT_Reposition
.01813e					_IFT_Right:
.01813e	ee 00 05	inc $0500			inc 	IFT_XCursor
.018141	ad 00 05	lda $0500			lda 	IFT_XCursor
.018144	49 40		eor #$40			eor 	#IF_Width
.018146	f0 f1		beq $018139			beq 	_IFT_SetX
.018148	80 16		bra $018160			bra 	_IFT_Reposition
.01814a					_IFT_Up:
.01814a	ce 01 05	dec $0501			dec 	IFT_YCursor
.01814d	10 11		bpl $018160			bpl 	_IFT_Reposition
.01814f	a9 1f		lda #$1f			lda 	#IF_Height-1
.018151					_IFT_SetY:
.018151	8d 01 05	sta $0501			sta 	IFT_YCursor
.018154	80 0a		bra $018160			bra 	_IFT_Reposition
.018156					_IFT_Down:
.018156	ee 01 05	inc $0501			inc 	IFT_YCursor
.018159	ad 01 05	lda $0501			lda 	IFT_YCursor
.01815c	49 20		eor #$20			eor 	#IF_Height
.01815e	f0 f1		beq $018151			beq 	_IFT_SetY
.018160					_IFT_Reposition:
.018160	ad 00 05	lda $0500			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.018163	48		pha				pha
.018164	ad 01 05	lda $0501			lda 	IFT_YCursor
.018167	20 c8 80	jsr $0180c8			jsr 	IFT_SetYPos
.01816a	68		pla				pla
.01816b	aa		tax				tax
.01816c	e0 00		cpx #$00			cpx 	#0
.01816e	f0 88		beq $0180f8			beq 	_IFT_RLLoop
.018170					_IFT_MoveRight:
.018170	20 cc 81	jsr $0181cc			jsr 	IF_Read
.018173	ee 00 05	inc $0500			inc 	IFT_XCursor
.018176	ca		dex				dex
.018177	d0 f7		bne $018170			bne 	_IFT_MoveRight
.018179	4c f8 80	jmp $0180f8			jmp 	_IFT_RLLoop
.01817c					_IFT_RLExit:
.01817c	ad 01 05	lda $0501			lda 	IFT_YCursor 				; go to start of line.
.01817f	20 c8 80	jsr $0180c8			jsr 	IFT_SetYPos
.018182	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.018184					_IFT_RLRead:
.018184	20 cc 81	jsr $0181cc			jsr 	IF_Read
.018187	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.01818a	e8		inx				inx
.01818b	e0 40		cpx #$40			cpx 	#IF_Width
.01818d	d0 f5		bne $018184			bne 	_IFT_RLRead
.01818f					_IFT_RL_Trim:
.01818f	ca		dex				dex 	 							; previous char
.018190	30 07		bmi $018199			bmi 	_IFT_Found 					; gone too far
.018192	bd 66 05	lda $0566,x			lda 	IFT_LineBuffer,x			; go back if space
.018195	c9 20		cmp #$20			cmp 	#" "
.018197	f0 f6		beq $01818f			beq 	_IFT_RL_Trim
.018199					_IFT_Found:
.018199	e8		inx				inx 								; forward to non-space
.01819a	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.01819c	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.01819f	20 59 80	jsr $018059			jsr 	IFT_NewLine 				; go to next line.
.0181a2	68		pla				pla
.0181a3	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.0181a5	a0 05		ldy #$05			ldy 	#IFT_LineBuffer >> 8
.0181a7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_em65816.asm

=64					IF_Width 	= 64 							; characters across
=32					IF_Height 	= 32 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line.
=8					IF_XPos 	= 8 							; current position, horizontal.
=$f0000					IF_Screen = $F0000							; 2k screen RAM here
=$f8010					IF_PKeyboard = $F8010						; Keyboard port.
=$f8000					IF_PBreak = $F8000 							; Break key.
.0181a8					IF_Reset:
.0181a8	60		rts				rts
.0181a9					IF_Home:
.0181a9	48		pha				pha
.0181aa	64 08		stz $08				stz 	IF_XPos 					; zero X position
.0181ac	a9 00		lda #$00			lda 	#IF_Screen & $FF 			; set r/w pos.
.0181ae	85 04		sta $04				sta 	IF_Pos
.0181b0	a9 00		lda #$00			lda 	#(IF_Screen >> 8) & $FF
.0181b2	85 05		sta $05				sta 	IF_Pos+1
.0181b4	a9 0f		lda #$0f			lda 	#IF_Screen >> 16
.0181b6	85 06		sta $06				sta 	IF_Pos+2
.0181b8	64 07		stz $07				stz 	IF_Pos+3
.0181ba	68		pla				pla
.0181bb	60		rts				rts
.0181bc					IF_NewLine:
.0181bc	48		pha				pha
.0181bd	64 08		stz $08				stz 	IF_XPos						; back to start of line
.0181bf	18		clc				clc 								; down one line
.0181c0	a5 04		lda $04				lda 	IF_Pos
.0181c2	69 40		adc #$40			adc 	#64
.0181c4	85 04		sta $04				sta 	IF_Pos
.0181c6	90 02		bcc $0181ca			bcc 	_IF_NoCarry 				; carry through.
.0181c8	e6 05		inc $05				inc 	IF_Pos+1
.0181ca					_IF_NoCarry:
.0181ca	68		pla				pla
.0181cb	60		rts				rts
.0181cc					IF_Read:
.0181cc	5a		phy				phy 								; save current Y
.0181cd	a4 08		ldy $08				ldy 	IF_XPos 					; read character at current position
.0181cf	b7 04		lda [$04],y			lda 	[IF_Pos],y
.0181d1	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181d3	7a		ply				ply									; restore Y
.0181d4	60		rts				rts
.0181d5					IF_Write:
.0181d5	5a		phy				phy 								; save current Y
.0181d6	a4 08		ldy $08				ldy 	IF_XPos 					; write character at current position
.0181d8	97 04		sta [$04],y			sta 	[IF_Pos],y
.0181da	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181dc	7a		ply				ply									; restore Y
.0181dd	60		rts				rts
.0181de					IF_LeftOne:
.0181de	c6 08		dec $08				dec 	IF_XPos
.0181e0	60		rts				rts
.0181e1					IF_CheckBreak:
.0181e1	af 00 80 0f	lda $0f8000			lda 	IF_PBreak					; non-zero if Ctrl+C pressed.
.0181e5	60		rts				rts
.0181e6					IF_GetKey:
.0181e6	af 10 80 0f	lda $0f8010			lda 	IF_PKeyboard				; read keyboard
.0181ea	f0 08		beq $0181f4			beq		_IFGK_NoKey 				; skip if zero,no key pressed
.0181ec	48		pha				pha 								; key pressed, clear queue.
.0181ed	a9 00		lda #$00			lda 	#0
.0181ef	8f 10 80 0f	sta $0f8010			sta 	IF_PKeyboard
.0181f3	68		pla				pla
.0181f4					_IFGK_NoKey:
.0181f4	09 00		ora #$00			ora 	#0							; set Z flag appropriately.
.0181f6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.0181f7					TIM_Error:
.0181f7	20 29 80	jsr $018029			jsr 	IFT_UpLine 					; go up one line.
.0181fa	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.0181fc	80 02		bra $018200			bra 	TIM_ShowPrompt
.0181fe					TIM_NewCommand:
.0181fe	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.018200					TIM_ShowPrompt:
.018200	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.018203	20 f7 80	jsr $0180f7			jsr 	IFT_ReadLine	 			; get character, go to next line
.018206	20 59 80	jsr $018059			jsr 	IFT_NewLine					; go to next line.
.018209	86 10		stx $10				stx 	zTemp1 						; save line read address
.01820b	84 11		sty $11				sty 	zTemp1+1
.01820d	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.01820f	b1 10		lda ($10),y			lda 	(zTemp1),y
.018211	c9 3f		cmp #$3f			cmp 	#"?"
.018213	f0 04		beq $018219			beq 	TIM_SkipFirst
.018215	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.018217	d0 01		bne $01821a			bne 	TIM_NotDot
.018219					TIM_SkipFirst:
.018219	c8		iny				iny
.01821a					TIM_NotDot:
.01821a	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.01821c	c9 52		cmp #$52			cmp 	#"R"						; show registers
.01821e	f0 6b		beq $01828b			beq 	TIM_ShowRegisters
.018220	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.018222	f0 12		beq $018236			beq 	TIM_ShowMemory
.018224	c9 47		cmp #$47			cmp 	#"G"						; execute
.018226	f0 49		beq $018271			beq 	TIM_Execute
.018228	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.01822a	f0 07		beq $018233			beq 	TIM_GoLoadMemory
.01822c	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.01822e	d0 c7		bne $0181f7			bne 	TIM_Error
.018230	4c af 83	jmp $0183af			jmp 	TIM_UpdateRegisters
.018233					TIM_GoLoadMemory:
.018233	4c df 83	jmp $0183df			jmp 	TIM_LoadMemory
.018236					TIM_ShowMemory:
.018236	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.018239	b0 bc		bcs $0181f7			bcs 	TIM_Error
.01823b	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.01823d	85 12		sta $12				sta 	zTemp2
.01823f	a5 15		lda $15				lda 	zTemp3+1
.018241	85 13		sta $13				sta 	zTemp2+1
.018243	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.018246	90 08		bcc $018250			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.018248	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.01824a	85 14		sta $14				sta 	zTemp3
.01824c	a5 13		lda $13				lda 	zTemp2+1
.01824e	85 15		sta $15				sta 	zTemp3+1
.018250					_TIMSM_Start:
.018250	20 03 83	jsr $018303			jsr 	TIM_WriteLine 				; write one line of hex out
.018253	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.018255	18		clc				clc
.018256	69 10		adc #$10			adc 	#16
.018258	85 12		sta $12				sta 	zTemp2
.01825a	90 02		bcc $01825e			bcc 	_TIMSM_NoCarry
.01825c	e6 13		inc $13				inc 	zTemp2+1
.01825e					_TIMSM_NoCarry:
.01825e	20 e1 81	jsr $0181e1			jsr 	IF_CheckBreak 				; check CTL+C
.018261	d0 0b		bne $01826e			bne 	_TIMSM_Ends 				; if pressed break out.
.018263	38		sec				sec 								; check past the end address in zTemp3
.018264	a5 14		lda $14				lda 	zTemp3
.018266	e5 12		sbc $12				sbc 	zTemp2
.018268	a5 15		lda $15				lda 	zTemp3+1
.01826a	e5 13		sbc $13				sbc 	zTemp2+1
.01826c	10 e2		bpl $018250			bpl 	_TIMSM_Start
.01826e					_TIMSM_Ends:
.01826e	4c fe 81	jmp $0181fe			jmp 	TIM_NewCommand
.018271					TIM_Execute:
.018271	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; get the execute address
.018274	b0 81		bcs $0181f7			bcs 	TIM_Error 					; not legitimate
.018276	ae cd 03	ldx $03cd			ldx 	TIM_SP 						; set up SP
.018279	9a		txs				txs
.01827a	ad c8 03	lda $03c8			lda 	TIM_SR 						; Status for PLP
.01827d	48		pha				pha
.01827e	ad c9 03	lda $03c9			lda 	TIM_A 						; restore AXYZ
.018281	ae ca 03	ldx $03ca			ldx 	TIM_X
.018284	ac cb 03	ldy $03cb			ldy 	TIM_Y
.018287	28		plp				plp 								; and PS Byte.
.018288	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.01828b					TIM_Start:
.01828b					TIM_ShowRegisters:
.01828b	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.01828e	8d c7 03	sta $03c7			sta 	TIM_IRQ+1
.018291	ad ff ff	lda $ffff			lda 	$FFFF
.018294	8d c6 03	sta $03c6			sta 	TIM_IRQ
.018297	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.018299					_TIMSR_Text:
.018299	bf ca 82 01	lda $0182ca,x			lda 	_TIMSR_Label,x
.01829d	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182a0	e8		inx				inx
.0182a1	e0 20		cpx #$20			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.0182a3	d0 f4		bne $018299			bne 	_TIMSR_Text
.0182a5	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.0182a7					_TIMSR_Skip:
.0182a7	e8		inx				inx
.0182a8					_TIMSR_LoopSpace:
.0182a8	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.0182aa	b0 04		bcs $0182b0			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.0182ac	8a		txa				txa
.0182ad	4a		lsr a				lsr 	a
.0182ae	b0 05		bcs $0182b5			bcs 	_TIMSR_NoSpace
.0182b0					_TIMSR_Space:
.0182b0	a9 20		lda #$20			lda 	#" "
.0182b2	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182b5					_TIMSR_NoSpace:
.0182b5	bd c4 03	lda $03c4,x			lda 	TIM_PC,x 					; output hex value.
.0182b8	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.0182bb	e8		inx				inx
.0182bc	e0 08		cpx #$08			cpx 	#TIM_Z-TIM_PC
.0182be	f0 e7		beq $0182a7			beq 	_TIMSR_Skip
.0182c0	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.0182c2	d0 e4		bne $0182a8			bne 	_TimSR_LoopSpace
.0182c4	20 59 80	jsr $018059			jsr 	IFT_NewLine 				; new line
.0182c7	4c fe 81	jmp $0181fe			jmp	 	TIM_NewCommand 				; new command.
.0182ca					_TIMSR_Label:
>0182ca	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>0182d2	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>0182e2	52
>0182e3	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.0182ea					_TIMSR_LabelEnd:
.0182ea					TIM_WriteHex:
.0182ea	48		pha				pha 								; save A
.0182eb	4a		lsr a				lsr 	a 							; shift MSB->LSB
.0182ec	4a		lsr a				lsr 	a
.0182ed	4a		lsr a				lsr 	a
.0182ee	4a		lsr a				lsr 	a
.0182ef	20 f3 82	jsr $0182f3			jsr 	_TIMWH_Nibble 				; print MSB
.0182f2	68		pla				pla 								; restore and print LSB
.0182f3					_TIMWH_Nibble:
.0182f3	48		pha				pha
.0182f4	29 0f		and #$0f			and 	#15 						; mask out
.0182f6	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.0182f8	90 02		bcc $0182fc			bcc 	_TIMWHNoLetter
.0182fa	69 06		adc #$06			adc 	#6
.0182fc					_TIMWHNoLetter:
.0182fc	69 30		adc #$30			adc 	#48
.0182fe	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter 			; print it out.
.018301	68		pla				pla
.018302	60		rts				rts
.018303					TIM_WriteLine:
.018303	a9 2e		lda #$2e			lda 	#"." 						; prompt
.018305	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018308	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.01830a	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01830d	a5 13		lda $13				lda 	zTemp2+1 					; write address
.01830f	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.018312	a5 12		lda $12				lda 	zTemp2
.018314	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.018317	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.018319					_TIMWL_Loop:
.018319	a9 20		lda #$20			lda 	#" "
.01831b	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01831e	b1 12		lda ($12),y			lda 	(zTemp2),y
.018320	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.018323	c8		iny				iny
.018324	c0 10		cpy #$10			cpy 	#16
.018326	d0 f1		bne $018319			bne 	_TIMWL_Loop
.018328	4c 59 80	jmp $018059			jmp 	IFT_NewLine 				; new line and exit
.01832b					TIM_GetHex:
.01832b	c8		iny				iny
.01832c	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.01832e	c9 20		cmp #$20			cmp 	#32
.018330	f0 f9		beq $01832b			beq 	TIM_GetHex
.018332	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.018334	f0 f5		beq $01832b			beq 	TIM_GetHex
.018336	20 5f 83	jsr $01835f			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.018339	b0 23		bcs $01835e			bcs 	_TIMGH_Exit					; if first bad then exit now.
.01833b	a9 00		lda #$00			lda 	#0 							; zero result
.01833d	85 14		sta $14				sta 	zTemp3
.01833f	85 15		sta $15				sta 	zTemp3+1
.018341					_TIM_GHLoop:
.018341	20 5f 83	jsr $01835f			jsr 	TIM_GetHexCharacter 		; get next character
.018344	b0 17		bcs $01835d			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.018346	c8		iny				iny 								; skip over it.
.018347	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.018349	26 15		rol $15				rol 	zTemp3+1
.01834b	06 14		asl $14				asl 	zTemp3 						; now x 2
.01834d	26 15		rol $15				rol 	zTemp3+1
.01834f	06 14		asl $14				asl 	zTemp3						; now x 4
.018351	26 15		rol $15				rol 	zTemp3+1
.018353	06 14		asl $14				asl 	zTemp3 						; now x 8
.018355	26 15		rol $15				rol 	zTemp3+1
.018357	05 14		ora $14				ora 	zTemp3 						; OR result in
.018359	85 14		sta $14				sta 	zTemp3
.01835b	80 e4		bra $018341			bra 	_TIM_GHLoop 				; loop round again.
.01835d					_TIMGH_Okay:
.01835d	18		clc				clc
.01835e					_TIMGH_Exit:
.01835e	60		rts				rts
.01835f					TIM_GetHexCharacter:
.01835f	b1 10		lda ($10),y			lda 	(zTemp1),y
.018361	38		sec				sec
.018362	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.018364	90 0e		bcc $018374			bcc 	_TIM_GHCFail
.018366	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.018368	90 0b		bcc $018375			bcc 	_TIM_GHCExit
.01836a	c9 11		cmp #$11			cmp 	#65-48						; < A
.01836c	90 06		bcc $018374			bcc		_TIM_GHCFail
.01836e	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.018370	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.018372	90 01		bcc $018375			bcc		_TIM_GHCExit
.018374					_TIM_GHCFail:
.018374	38		sec				sec
.018375					_TIM_GHCExit:
.018375	60		rts				rts
.018376					TIM_BreakVector:
.018376	da		phx				phx									; save X/A on stack
.018377	48		pha				pha
.018378	ba		tsx				tsx 								; X points to S
.018379	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.01837c	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.01837e	d0 03		bne $018383			bne 	_TIMBreak					; if set, it's BRK
.018380	68		pla				pla 								; abandon routine.
.018381	fa		plx				plx
.018382	40		rti				rti
.018383					_TIMBreak:
.018383	68		pla				pla 								; save A X Y and maybe Z
.018384	8d c9 03	sta $03c9			sta 	TIM_A
.018387	fa		plx				plx
.018388	8e ca 03	stx $03ca			stx 	TIM_X
.01838b	8c cb 03	sty $03cb			sty 	TIM_Y
.01838e	68		pla				pla 								; get Status Register
.01838f	8d c8 03	sta $03c8			sta 	TIM_SR
.018392	68		pla				pla
.018393	8d c5 03	sta $03c5			sta 	TIM_PC+1 					; save calling address
.018396	68		pla				pla
.018397	8d c4 03	sta $03c4			sta 	TIM_PC 						; high byte
.01839a	ad c5 03	lda $03c5			lda 	TIM_PC+1 					; dec PC to point right.
.01839d	d0 03		bne $0183a2			bne 	_TIMDecrement 				; brk bumps it.
.01839f	ce c4 03	dec $03c4			dec 	TIM_PC
.0183a2					_TIMDecrement:
.0183a2	ce c5 03	dec $03c5			dec 	TIM_PC+1
.0183a5	ba		tsx				tsx 								; and copy SP
.0183a6	8e cd 03	stx $03cd			stx 	TIM_SP
.0183a9	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.0183ab	9a		txs				txs
.0183ac	4c 8b 82	jmp $01828b			jmp 	TIM_Start 					; and start up TIM monitor.
.0183af					TIM_UpdateRegisters:
.0183af	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; PC
.0183b2	b0 28		bcs $0183dc			bcs 	_TIMURFail
.0183b4	a5 14		lda $14				lda 	zTemp3
.0183b6	8d c5 03	sta $03c5			sta 	Tim_PC+1
.0183b9	a5 15		lda $15				lda 	zTemp3+1
.0183bb	8d c4 03	sta $03c4			sta 	Tim_PC
.0183be	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; ignore IRQ
.0183c1	b0 19		bcs $0183dc			bcs 	_TIMURFail
.0183c3	a2 00		ldx #$00			ldx 	#0
.0183c5					_TIM_URLoop:
.0183c5	e0 04		cpx #$04			cpx 	#Tim_Z-Tim_SR
.0183c7	d0 01		bne $0183ca			bne 	_TIM_1
.0183c9	e8		inx				inx
.0183ca					_TIM_1:
.0183ca	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; registers
.0183cd	b0 0d		bcs $0183dc			bcs 	_TIMURFail
.0183cf	a5 14		lda $14				lda 	zTemp3
.0183d1	9d c8 03	sta $03c8,x			sta 	Tim_SR,x
.0183d4	e8		inx				inx
.0183d5	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.0183d7	d0 ec		bne $0183c5			bne 	_TIM_URLoop
.0183d9	4c fe 81	jmp $0181fe			jmp 	TIM_NewCommand
.0183dc					_TIMURFail:
.0183dc	4c f7 81	jmp $0181f7			jmp 	TIM_Error
.0183df					TIM_LoadMemory:
.0183df	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; target address => zTemp2
.0183e2	a5 14		lda $14				lda 	zTemp3
.0183e4	85 12		sta $12				sta 	zTemp2
.0183e6	a5 15		lda $15				lda 	zTemp3+1
.0183e8	85 13		sta $13				sta 	zTemp2+1
.0183ea					_TIM_LMLoop:
.0183ea	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; next byte ?
.0183ed	b0 0e		bcs $0183fd			bcs 	_TIMLMDone 					; no more
.0183ef	a2 00		ldx #$00			ldx 	#0							; write out.
.0183f1	a5 14		lda $14				lda 	zTemp3
.0183f3	81 12		sta ($12,x)			sta 	(zTemp2,x)
.0183f5	e6 12		inc $12				inc 	zTemp2 						; bump address
.0183f7	d0 f1		bne $0183ea			bne 	_TIM_LMLoop
.0183f9	e6 13		inc $13				inc 	zTemp2+1
.0183fb	80 ed		bra $0183ea			bra 	_TIM_LMLoop
.0183fd					_TIMLMDone:
.0183fd	4c fe 81	jmp $0181fe			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/skip.asm

.018400					StructureSearchSingle:
.018400	a2 00		ldx #$00			ldx 	#0 							; we always search for XA. This disables X.
.018402					StructureSearchDouble:
.018402	85 10		sta $10				sta 	zTemp1 						; save the targets in zTemp1,zTemp1+1
.018404	86 11		stx $11				stx 	zTemp1+1
.018406	a9 00		lda #$00			lda 	#0 							; set the structure depth to zero (zTemp2)
.018408	85 12		sta $12				sta 	zTemp2
.01840a	80 18		bra $018424			bra 	_SSWLoop 					; jump in, start scanning from here.
.01840c					_SSWNextLine:
.01840c	a0 00		ldy #$00			ldy 	#0 							; point to offset
.01840e	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read it
.018410	18		clc				clc
.018411	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.018413	85 18		sta $18				sta 	zCodePtr
.018415	90 02		bcc $018419			bcc 	_SNLNoCarry
.018417	e6 19		inc $19				inc 	zCodePtr+1
.018419					_SNLNoCarry:
.018419	a0 00		ldy #$00			ldy 	#0
.01841b	b7 18		lda [$18],y			lda 	[zCodePtr],y
.01841d	c9 00		cmp #$00			cmp 	#0					 		; if zero, fail.
.01841f	f0 54		beq $018475			beq 	_SSWFail
.018421	c8		iny				iny
.018422	c8		iny				iny
.018423					_SSWNextSimple:
.018423	c8		iny				iny
.018424					_SSWLoop:
.018424	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018426	c9 00		cmp #$00			cmp 	#0 							; end of line ?
.018428	f0 e2		beq $01840c			beq 	_SSWNextLine 				; if so, then next line
.01842a	10 f7		bpl $018423			bpl 	_SSWNextSimple 				; needs to be a token, just skip char/number.
.01842c	a6 12		ldx $12				ldx 	zTemp2 						; check structure count
.01842e	d0 08		bne $018438			bne 	_SSWCheckUpDown 			; if it's non zero, then a match doesn't work.
.018430	c5 10		cmp $10				cmp 	zTemp1 						; found the right keyword, either choice.
.018432	f0 2d		beq $018461			beq 	_SSWFound 					; then exit.
.018434	c5 11		cmp $11				cmp 	zTemp1+1
.018436	f0 29		beq $018461			beq 	_SSWFound
.018438					_SSWCheckUpDown:
.018438	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus 			; if < keyword +
.01843a	90 10		bcc $01844c			bcc 	_SSWNext
.01843c	c9 93		cmp #$93			cmp 	#firstKeywordMinus 			; if < keyword - then as keyword +
.01843e	90 08		bcc $018448			bcc 	_SSWPlus
.018440	c9 98		cmp #$98			cmp 	#firstUnaryFunction			; if < first unary down as keyword -
.018442	b0 08		bcs $01844c			bcs 	_SSWNext
.018444	c6 12		dec $12				dec 	zTemp2 						; reduce structure count.
.018446	c6 12		dec $12				dec 	zTemp2
.018448					_SSWPlus:
.018448	e6 12		inc $12				inc 	zTemp2
.01844a	30 16		bmi $018462			bmi 	_SSWUnder					; error if driven -ve
.01844c					_SSWNext:
.01844c	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read element
.01844e	c8		iny				iny 								; skip
.01844f	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018451	90 0c		bcc $01845f			bcc 	_SEDone 					; so just skip over it.
.018453	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018455	90 07		bcc $01845e			bcc 	_SEDouble
.018457	98		tya				tya 								; this is Y + 1
.018458	18		clc				clc
.018459	77 18		adc [$18],y			adc 	[zCodePtr],y 				; add total length of element
.01845b	a8		tay				tay 								; back in Y.
.01845c	88		dey				dey 								; fix up, one for the +1, one for the iny
.01845d	88		dey				dey
.01845e					_SEDouble:
.01845e	c8		iny				iny
.01845f					_SEDone:
.01845f	80 c3		bra $018424			bra 	_SSWLoop
.018461					_SSWFound:
.018461	60		rts				rts
.018462					_SSWUnder:
.018462	20 86 85	jsr $018586			jsr ERR_Handler
>018465	53 74 72 75 63 74 75 72			.text "Structure order",0
>01846d	65 20 6f 72 64 65 72 00
.018475					_SSWFail:
.018475	20 86 85	jsr $018586			jsr ERR_Handler
>018478	43 61 6e 27 74 20 66 69			.text "Can't find structure",0
>018480	6e 64 20 73 74 72 75 63 74 75 72 65 00
.01848d					SkipEndOfCommand:
.01848d	b7 18		lda [$18],y			lda 	[zCodePtr],y
.01848f	c9 00		cmp #$00			cmp 	#0 							; if zero, end of line, so exit
.018491	f0 19		beq $0184ac			beq 	_SOCExit
.018493	c9 c0		cmp #$c0			cmp 	#token_Colon 				; if colon, end of command
.018495	f0 15		beq $0184ac			beq 	_SOCExit
.018497	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read element
.018499	c8		iny				iny 								; skip
.01849a	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.01849c	90 0c		bcc $0184aa			bcc 	_SEDone 					; so just skip over it.
.01849e	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.0184a0	90 07		bcc $0184a9			bcc 	_SEDouble
.0184a2	98		tya				tya 								; this is Y + 1
.0184a3	18		clc				clc
.0184a4	77 18		adc [$18],y			adc 	[zCodePtr],y 				; add total length of element
.0184a6	a8		tay				tay 								; back in Y.
.0184a7	88		dey				dey 								; fix up, one for the +1, one for the iny
.0184a8	88		dey				dey
.0184a9					_SEDouble:
.0184a9	c8		iny				iny
.0184aa					_SEDone:
.0184aa	80 e1		bra $01848d			bra 	SkipEndOfCommand
.0184ac					_SOCExit:
.0184ac	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stack.asm

.0184ad					StackReset:
.0184ad	48		pha				pha
.0184ae	5a		phy				phy
.0184af	a9 ca		lda #$ca			lda 	#(BasicStack & $FF) 		; reset pointer
.0184b1	85 28		sta $28				sta 	zBasicSP
.0184b3	a9 05		lda #$05			lda 	#(BasicStack >> 8)
.0184b5	85 29		sta $29				sta 	zBasicSP+1
.0184b7	a0 00		ldy #$00			ldy 	#0 							; reset stack top to $00 which cannot
.0184b9	98		tya				tya 								; be a legal token.
.0184ba	91 28		sta ($28),y			sta 	(zBasicSP),y
.0184bc	7a		ply				ply
.0184bd	68		pla				pla
.0184be	60		rts				rts
.0184bf					StackPushFrame:
.0184bf	48		pha				pha
.0184c0	5a		phy				phy
.0184c1	1a		inc a				inc 	a 							; one extra byte in frame, for the marker.
.0184c2	48		pha				pha 								; save it.
.0184c3	29 0f		and #$0f			and 	#$0F 						; lower 4 bits
.0184c5	18		clc				clc 								; add to Basic Stack
.0184c6	65 28		adc $28				adc 	zBasicSP
.0184c8	85 28		sta $28				sta 	zBasicSP
.0184ca	90 02		bcc $0184ce			bcc 	_SPFNoBump
.0184cc	e6 29		inc $29				inc 	zBasicSP+1
.0184ce					_SPFNoBump:
.0184ce	a0 00		ldy #$00			ldy 	#0
.0184d0	68		pla				pla
.0184d1	91 28		sta ($28),y			sta 	(zBasicSP),y
.0184d3	7a		ply				ply
.0184d4	68		pla				pla
.0184d5	60		rts				rts
.0184d6					StackPopFrame:
.0184d6	48		pha				pha
.0184d7	5a		phy				phy
.0184d8	a0 00		ldy #$00			ldy 	#0 							; compare with top of stack using EOR
.0184da	51 28		eor ($28),y			eor 	(zBasicSP),y
.0184dc	29 f0		and #$f0			and 	#$F0 						; top 4 bits zero, match
.0184de	d0 12		bne $0184f2			bne 	SPFError 					; mixed structures
.0184e0	b1 28		lda ($28),y			lda 	(zBasicSP),y 				; get size from byte
.0184e2	29 0f		and #$0f			and 	#$0F
.0184e4	49 ff		eor #$ff			eor 	#$FF						; 2's complement
.0184e6	38		sec				sec
.0184e7	65 28		adc $28				adc 	zBasicSP
.0184e9	85 28		sta $28				sta 	zBasicSP
.0184eb	b0 02		bcs $0184ef			bcs 	_SPFNoBump
.0184ed	c6 29		dec $29				dec 	zBasicSP+1
.0184ef					_SPFNoBump:
.0184ef	7a		ply				ply
.0184f0	68		pla				pla
.0184f1	60		rts				rts
.0184f2					SPFError:
.0184f2	20 86 85	jsr $018586			jsr ERR_Handler
>0184f5	4d 69 78 65 64 20 53 74			.text "Mixed Structures",0
>0184fd	72 75 63 74 75 72 65 73 00
.018506					StackSavePosition:
.018506	98		tya				tya
.018507	5a		phy				phy
.018508	a0 05		ldy #$05			ldy 	#5
.01850a	91 28		sta ($28),y			sta 	(zBasicSP),y
.01850c	a0 01		ldy #$01			ldy 	#1
.01850e	a5 18		lda $18				lda 	zCodePtr+0 					; 4 bytes, could reduce this for 65816/6502
.018510	91 28		sta ($28),y			sta 	(zBasicSP),y
.018512	c8		iny				iny
.018513	a5 19		lda $19				lda 	zCodePtr+1
.018515	91 28		sta ($28),y			sta 	(zBasicSP),y
.018517	c8		iny				iny
.018518	a5 1a		lda $1a				lda 	zCodePtr+2
.01851a	91 28		sta ($28),y			sta 	(zBasicSP),y
.01851c	c8		iny				iny
.01851d	a5 1b		lda $1b				lda 	zCodePtr+3
.01851f	91 28		sta ($28),y			sta 	(zBasicSP),y
.018521	7a		ply				ply
.018522	60		rts				rts
.018523					StackRestorePosition:
.018523	5a		phy				phy
.018524	a0 01		ldy #$01			ldy 	#1 							; copy 4 bytes that are the pointer
.018526	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018528	85 18		sta $18				sta 	zCodePtr+0
.01852a	c8		iny				iny
.01852b	b1 28		lda ($28),y			lda 	(zBasicSP),y
.01852d	85 19		sta $19				sta 	zCodePtr+1
.01852f	c8		iny				iny
.018530	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018532	85 1a		sta $1a				sta 	zCodePtr+2
.018534	c8		iny				iny
.018535	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018537	85 1b		sta $1b				sta 	zCodePtr+3
.018539	c8		iny				iny
.01853a	b1 28		lda ($28),y			lda 	(zBasicSP),y 				; offset
.01853c	7a		ply				ply 								; restore Y
.01853d	a8		tay				tay
.01853e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/vectors.asm

.01853f					VIOCharPrint:
.01853f	4c 35 80	jmp $018035			jmp 	IFT_PrintCharacter
.018542					VIOCharGet:
.018542	20 e6 81	jsr $0181e6			jsr 	IF_GetKey
.018545	c9 00		cmp #$00			cmp 	#0
.018547	f0 02		beq $01854b			beq 	_VCG0
.018549	38		sec				sec
.01854a	60		rts				rts
.01854b	18		clc		_VCG0:	clc
.01854c	60		rts				rts
.01854d					VIOCheckBreak:
.01854d	4c e1 81	jmp $0181e1			jmp 	IF_CheckBreak
.018550					VIOCharGetPosition:
.018550	ad 00 05	lda $0500			lda 	IFT_XCursor
.018553	60		rts				rts
.018554					VIOReadLine:
.018554	4c f7 80	jmp $0180f7			jmp 	IFT_ReadLine

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/errors.asm

.018557					SyntaxError:
.018557	20 86 85	jsr $018586			jsr 	ERR_Handler
>01855a	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>018562	72 72 6f 72 00
.018567					TypeError:
.018567	20 86 85	jsr $018586			jsr 	ERR_Handler
>01856a	57 72 6f 6e 67 20 74 79				.text 	"Wrong type",0
>018572	70 65 00
.018575					BadParamError:
.018575	20 86 85	jsr $018586			jsr 	ERR_Handler
>018578	42 61 64 20 50 61 72 61				.text 	"Bad Parameter",0
>018580	6d 65 74 65 72 00
.018586					ERR_Handler:
.018586	a0 00		ldy #$00			ldy 	#0
.018588	c8		iny				iny
.018589	b7 18		lda [$18],y			lda 	[zCodePtr],y
.01858b	85 80		sta $80				sta 	XS_Mantissa
.01858d	c8		iny				iny
.01858e	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018590	85 81		sta $81				sta 	XS_Mantissa+1
.018592	fa		plx				plx 								; address in XY
.018593	7a		ply				ply
.018594	e8		inx				inx 								; bump, because of RTS/JSR address -1
.018595	d0 01		bne $018598			bne 	_EHNoSkip
.018597	c8		iny				iny
.018598					_EHNoSkip:
.018598	20 ba 85	jsr $0185ba			jsr 	PrintROMMessage 			; print message from ROM.
.01859b	a5 80		lda $80				lda 	XS_Mantissa					; line number = 0
.01859d	05 81		ora $81				ora 	XS_Mantissa+1
.01859f	f0 0c		beq $0185ad			beq 	_EHNoLine
.0185a1	a2 b5		ldx #$b5			ldx 	#_EHAt & $FF 				; print " at "
.0185a3	a0 85		ldy #$85			ldy 	#(_EHAt >> 8) & $FF
.0185a5	20 ba 85	jsr $0185ba			jsr 	PrintROMMessage
.0185a8	a2 00		ldx #$00			ldx 	#0 							; Print line number
.0185aa	20 cf 85	jsr $0185cf			jsr 	Print16BitInteger
.0185ad					_EHNoLine:
.0185ad	a9 0d		lda #$0d			lda 	#13
.0185af	20 3f 85	jsr $01853f			jsr 	VIOCharPrint
.0185b2	4c 54 88	jmp $018854			jmp 	ErrorStart 					; normally warm start, no message.
>0185b5	20 61 74 20 00			_EHAt:	.text 	" at ",0
.0185ba					PrintROMMessage:
.0185ba	86 1c		stx $1c				stx 	zLTemp1 					; save addres
.0185bc	84 1d		sty $1d				sty 	zLTemp1+1
.0185be	4b		phk				phk 								; get current code page
.0185bf	68		pla				pla
.0185c0	85 1e		sta $1e				sta 	ZLTemp1+2 					; put into the 3rd byte so we can use
.0185c2	a0 00		ldy #$00			ldy 	#0
.0185c4					_PRMLoop:
.0185c4	b7 1c		lda [$1c],y			lda 	[zLTemp1],y 				; 65816
.0185c6	f0 06		beq $0185ce			beq		_PRMExit 					; character $00 => exit
.0185c8	c8		iny				iny  								; bump Y and print it.
.0185c9	20 3f 85	jsr $01853f			jsr 	VIOCharPrint
.0185cc	80 f6		bra $0185c4			bra 	_PRMLoop
.0185ce					_PRMExit:
.0185ce	60		rts				rts
.0185cf					Print16BitInteger:
.0185cf	a9 00		lda #$00			lda 	#0 							; make 32 bit
.0185d1	85 82		sta $82				sta 	XS_Mantissa+2
.0185d3	85 83		sta $83				sta 	XS_Mantissa+3
.0185d5					Print32BitInteger:
.0185d5	a9 00		lda #$00			lda 	#0
.0185d7	8d 14 03	sta $0314			sta 	NumBufX 					; reset the conversion pointer
.0185da	aa		tax				tax 								; convert bottom level.
.0185db	20 44 a1	jsr $01a144			jsr 	INTToString 				; make string from integer in Num_Buffer
.0185de	a2 00		ldx #$00			ldx 	#0 							; print buffer contents
.0185e0	bd 15 03	lda $0315,x	_P1Loop:lda 	Num_Buffer,x
.0185e3	f0 06		beq $0185eb			beq 	_P1Exit
.0185e5	20 3f 85	jsr $01853f			jsr 	VIOCharPrint
.0185e8	e8		inx				inx
.0185e9	80 f5		bra $0185e0			bra 	_P1Loop
.0185eb	8a		txa		_P1Exit:txa 								; return chars printed.
.0185ec	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm


;******  Processing file: modules/basic/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b6					lastUnaryFunction = $b6
.0185ed					VectorTable:
>0185ed	bd 93					.word BinaryOp_And         & $FFFF ; $80 and
>0185ef	d9 93					.word BinaryOp_Or          & $FFFF ; $81 or
>0185f1	f5 93					.word BinaryOp_Xor         & $FFFF ; $82 xor
>0185f3	f5 93					.word BinaryOp_Eor         & $FFFF ; $83 eor
>0185f5	29 94					.word Binary_Equal         & $FFFF ; $84 =
>0185f7	32 94					.word Binary_NotEqual      & $FFFF ; $85 <>
>0185f9	3b 94					.word Binary_Less          & $FFFF ; $86 <
>0185fb	44 94					.word Binary_LessEqual     & $FFFF ; $87 <=
>0185fd	56 94					.word Binary_Greater       & $FFFF ; $88 >
>0185ff	4d 94					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>018601	e1 94					.word BinaryOp_Add         & $FFFF ; $8a +
>018603	f0 94					.word BinaryOp_Subtract    & $FFFF ; $8b -
>018605	f4 94					.word BinaryOp_Multiply    & $FFFF ; $8c *
>018607	f8 94					.word BinaryOp_Divide      & $FFFF ; $8d /
>018609	ab 86					.word NotImplemented       & $FFFF ; $8e ^
>01860b	80 8d					.word Command_IF           & $FFFF ; $8f if
>01860d	ea 91					.word Command_WHILE        & $FFFF ; $90 while
>01860f	12 92					.word Command_REPEAT       & $FFFF ; $91 repeat
>018611	e9 89					.word Command_FOR          & $FFFF ; $92 for
>018613	ab 86					.word NotImplemented       & $FFFF ; $93 then
>018615	dd 8d					.word Command_ENDIF        & $FFFF ; $94 endif
>018617	07 92					.word Command_WEND         & $FFFF ; $95 wend
>018619	1b 92					.word Command_UNTIL        & $FFFF ; $96 until
>01861b	50 8a					.word Command_NEXT         & $FFFF ; $97 next
>01861d	ab 86					.word NotImplemented       & $FFFF ; $98 not
>01861f	ab 86					.word NotImplemented       & $FFFF ; $99 fn(
>018621	ed 95					.word Unary_Abs            & $FFFF ; $9a abs(
>018623	42 97					.word Unary_Asc            & $FFFF ; $9b asc(
>018625	ab 86					.word NotImplemented       & $FFFF ; $9c int(
>018627	07 96					.word Unary_Peek           & $FFFF ; $9d peek(
>018629	ab 86					.word NotImplemented       & $FFFF ; $9e rnd(
>01862b	7a 96					.word Unary_Usr            & $FFFF ; $9f usr(
>01862d	81 97					.word Unary_Left           & $FFFF ; $a0 left$(
>01862f	96 97					.word Unary_Right          & $FFFF ; $a1 right$(
>018631	68 97					.word Unary_Mid            & $FFFF ; $a2 mid$(
>018633	e1 98					.word Unary_Spc            & $FFFF ; $a3 spc(
>018635	13 97					.word Unary_Str            & $FFFF ; $a4 str$(
>018637	9b 96					.word Unary_Val            & $FFFF ; $a5 val(
>018639	59 97					.word Unary_Len            & $FFFF ; $a6 len(
>01863b	0e 98					.word Unary_Hex            & $FFFF ; $a7 hex$(
>01863d	ab 86					.word NotImplemented       & $FFFF ; $a8 sin(
>01863f	ab 86					.word NotImplemented       & $FFFF ; $a9 cos(
>018641	ab 86					.word NotImplemented       & $FFFF ; $aa tan(
>018643	ab 86					.word NotImplemented       & $FFFF ; $ab atn(
>018645	ab 86					.word NotImplemented       & $FFFF ; $ac exp(
>018647	ab 86					.word NotImplemented       & $FFFF ; $ad log(
>018649	ab 86					.word NotImplemented       & $FFFF ; $ae sqr(
>01864b	64 98					.word Unary_Dec            & $FFFF ; $af dec(
>01864d	0b 96					.word Unary_Deek           & $FFFF ; $b0 deek(
>01864f	0f 96					.word Unary_Leek           & $FFFF ; $b1 leek(
>018651	47 96					.word Unary_Mod            & $FFFF ; $b2 mod(
>018653	a7 95					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>018655	c3 98					.word Unary_Chr            & $FFFF ; $b4 chr$(
>018657	3b 96					.word Unary_Pos            & $FFFF ; $b5 pos(
>018659	04 99					.word Unary_Tab            & $FFFF ; $b6 tab(
>01865b	ab 86					.word NotImplemented       & $FFFF ; $b7 $
>01865d	ab 86					.word NotImplemented       & $FFFF ; $b8 $(
>01865f	ab 86					.word NotImplemented       & $FFFF ; $b9 #
>018661	ab 86					.word NotImplemented       & $FFFF ; $ba #(
>018663	ab 86					.word NotImplemented       & $FFFF ; $bb %
>018665	ab 86					.word NotImplemented       & $FFFF ; $bc %(
>018667	ab 86					.word NotImplemented       & $FFFF ; $bd (
>018669	ab 86					.word NotImplemented       & $FFFF ; $be )
>01866b	ab 86					.word NotImplemented       & $FFFF ; $bf ,
>01866d	e8 89					.word Command_COLON        & $FFFF ; $c0 :
>01866f	ab 86					.word NotImplemented       & $FFFF ; $c1 ;
>018671	ab 86					.word NotImplemented       & $FFFF ; $c2 def
>018673	cb 91					.word Command_CLR          & $FFFF ; $c3 clr
>018675	e2 91					.word Command_STOP         & $FFFF ; $c4 stop
>018677	29 8b					.word Command_DATA         & $FFFF ; $c5 data
>018679	03 8b					.word Command_READ         & $FFFF ; $c6 read
>01867b	8f 88					.word Command_DIM          & $FFFF ; $c7 dim
>01867d	ab 86					.word NotImplemented       & $FFFF ; $c8 to
>01867f	ab 86					.word NotImplemented       & $FFFF ; $c9 step
>018681	11 91					.word Command_GOSUB        & $FFFF ; $ca gosub
>018683	21 91					.word Command_RETURN       & $FFFF ; $cb return
>018685	09 91					.word Command_GOTO         & $FFFF ; $cc goto
>018687	7d 8d					.word Command_END          & $FFFF ; $cd end
>018689	4c 8c					.word Command_INPUT        & $FFFF ; $ce input
>01868b	c7 8b					.word Command_LET          & $FFFF ; $cf let
>01868d	e3 8d					.word Command_LIST         & $FFFF ; $d0 list
>01868f	b3 90					.word Command_NEW          & $FFFF ; $d1 new
>018691	cf 90					.word Command_OLD          & $FFFF ; $d2 old
>018693	2a 91					.word Command_ON           & $FFFF ; $d3 on
>018695	2c 8b					.word Command_RESTORE      & $FFFF ; $d4 restore
>018697	82 90					.word Command_POKE         & $FFFF ; $d5 poke
>018699	d7 8f					.word Command_PRINT        & $FFFF ; $d6 print
>01869b	5a 89					.word Command_RUN          & $FFFF ; $d7 run
>01869d	1a 89					.word Command_WAIT         & $FFFF ; $d8 wait
>01869f	32 8c					.word Command_SYS          & $FFFF ; $d9 sys
>0186a1	86 90					.word Command_DOKE         & $FFFF ; $da doke
>0186a3	8a 90					.word Command_LOKE         & $FFFF ; $db loke
>0186a5	6a 90					.word Command_ASSERT       & $FFFF ; $dc assert
>0186a7	e8 8b					.word Command_GET          & $FFFF ; $dd get
>0186a9	d7 8d					.word Command_ELSE         & $FFFF ; $de else
.0186ab					NotImplemented:
.0186ab	20 86 85	jsr $018586			jsr ERR_Handler
>0186ae	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>0186b6	65 6d 65 6e 74 65 64 00
.0186be					BinaryPrecedence:
>0186be	01					.byte 1    ; $80 and
>0186bf	01					.byte 1    ; $81 or
>0186c0	01					.byte 1    ; $82 xor
>0186c1	01					.byte 1    ; $83 eor
>0186c2	02					.byte 2    ; $84 =
>0186c3	02					.byte 2    ; $85 <>
>0186c4	02					.byte 2    ; $86 <
>0186c5	02					.byte 2    ; $87 <=
>0186c6	02					.byte 2    ; $88 >
>0186c7	02					.byte 2    ; $89 >=
>0186c8	03					.byte 3    ; $8a +
>0186c9	03					.byte 3    ; $8b -
>0186ca	04					.byte 4    ; $8c *
>0186cb	04					.byte 4    ; $8d /
>0186cc	05					.byte 5    ; $8e ^
.0186cd					KeywordText:
>0186cd	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>0186d0	4f d2					.byte $4f,$d2                          ; $81 or
>0186d2	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>0186d5	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>0186d8	bd					.byte $bd                              ; $84 =
>0186d9	3c be					.byte $3c,$be                          ; $85 <>
>0186db	bc					.byte $bc                              ; $86 <
>0186dc	3c bd					.byte $3c,$bd                          ; $87 <=
>0186de	be					.byte $be                              ; $88 >
>0186df	3e bd					.byte $3e,$bd                          ; $89 >=
>0186e1	ab					.byte $ab                              ; $8a +
>0186e2	ad					.byte $ad                              ; $8b -
>0186e3	aa					.byte $aa                              ; $8c *
>0186e4	af					.byte $af                              ; $8d /
>0186e5	de					.byte $de                              ; $8e ^
>0186e6	49 c6					.byte $49,$c6                          ; $8f if
>0186e8	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>0186ed	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>0186f3	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>0186f6	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>0186fa	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>0186ff	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>018703	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>018708	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>01870c	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>01870f	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>018712	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>018716	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>01871a	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>01871e	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>018723	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>018727	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>01872b	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>018731	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>018738	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>01873d	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>018741	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>018746	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>01874a	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>01874e	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>018753	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>018757	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>01875b	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>01875f	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>018763	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>018767	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>01876b	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>01876f	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>018773	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>018778	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>01877d	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>018781	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>018785	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>01878a	50 4f 53 a8				.byte $50,$4f,$53,$a8                  ; $b5 pos(
>01878e	54 41 42 a8				.byte $54,$41,$42,$a8                  ; $b6 tab(
>018792	a4					.byte $a4                              ; $b7 $
>018793	24 a8					.byte $24,$a8                          ; $b8 $(
>018795	a3					.byte $a3                              ; $b9 #
>018796	23 a8					.byte $23,$a8                          ; $ba #(
>018798	a5					.byte $a5                              ; $bb %
>018799	25 a8					.byte $25,$a8                          ; $bc %(
>01879b	a8					.byte $a8                              ; $bd (
>01879c	a9					.byte $a9                              ; $be )
>01879d	ac					.byte $ac                              ; $bf ,
>01879e	ba					.byte $ba                              ; $c0 :
>01879f	bb					.byte $bb                              ; $c1 ;
>0187a0	44 45 c6				.byte $44,$45,$c6                      ; $c2 def
>0187a3	43 4c d2				.byte $43,$4c,$d2                      ; $c3 clr
>0187a6	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $c4 stop
>0187aa	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c5 data
>0187ae	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c6 read
>0187b2	44 49 cd				.byte $44,$49,$cd                      ; $c7 dim
>0187b5	54 cf					.byte $54,$cf                          ; $c8 to
>0187b7	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c9 step
>0187bb	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $ca gosub
>0187c0	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $cb return
>0187c6	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $cc goto
>0187ca	45 4e c4				.byte $45,$4e,$c4                      ; $cd end
>0187cd	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $ce input
>0187d2	4c 45 d4				.byte $4c,$45,$d4                      ; $cf let
>0187d5	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $d0 list
>0187d9	4e 45 d7				.byte $4e,$45,$d7                      ; $d1 new
>0187dc	4f 4c c4				.byte $4f,$4c,$c4                      ; $d2 old
>0187df	4f ce					.byte $4f,$ce                          ; $d3 on
>0187e1	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d4 restore
>0187e8	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d5 poke
>0187ec	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d6 print
>0187f1	52 55 ce				.byte $52,$55,$ce                      ; $d7 run
>0187f4	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d8 wait
>0187f8	53 59 d3				.byte $53,$59,$d3                      ; $d9 sys
>0187fb	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $da doke
>0187ff	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $db loke
>018803	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $dc assert
>018809	47 45 d4				.byte $47,$45,$d4                      ; $dd get
>01880c	45 4c 53 c5				.byte $45,$4c,$53,$c5                  ; $de else
>018810	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_pos = $b5
=$b6					token_tab = $b6
=$b7					token_dollar = $b7
=$b8					token_dollarlparen = $b8
=$b9					token_hash = $b9
=$ba					token_hashlparen = $ba
=$bb					token_percent = $bb
=$bc					token_percentlparen = $bc
=$bd					token_lparen = $bd
=$be					token_rparen = $be
=$bf					token_comma = $bf
=$c0					token_colon = $c0
=$c1					token_semicolon = $c1
=$c2					token_def = $c2
=$c3					token_clr = $c3
=$c4					token_stop = $c4
=$c5					token_data = $c5
=$c6					token_read = $c6
=$c7					token_dim = $c7
=$c8					token_to = $c8
=$c9					token_step = $c9
=$ca					token_gosub = $ca
=$cb					token_return = $cb
=$cc					token_goto = $cc
=$cd					token_end = $cd
=$ce					token_input = $ce
=$cf					token_let = $cf
=$d0					token_list = $d0
=$d1					token_new = $d1
=$d2					token_old = $d2
=$d3					token_on = $d3
=$d4					token_restore = $d4
=$d5					token_poke = $d5
=$d6					token_print = $d6
=$d7					token_run = $d7
=$d8					token_wait = $d8
=$d9					token_sys = $d9
=$da					token_doke = $da
=$db					token_loke = $db
=$dc					token_assert = $dc
=$dd					token_get = $dd
=$de					token_else = $de

;******  Return to file: modules/basic/core.asm

.018811					BASIC_Start:
.018811	c2 30		rep #$30			rep 	#$30
.018813	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.018816	1b		tcs				tcs
.018817	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.01881a	e2 30		sep #$30			sep 	#$30
.01881c	20 a8 81	jsr $0181a8			jsr 	IF_Reset 					; set up and clear screen.
.01881f	20 00 80	jsr $018000			jsr 	IFT_ClearScreen
.018822	a9 5c		lda #$5c			lda 	#$5C 						; JMP Long opcode
.018824	8d 10 03	sta $0310			sta 	LocalVector
.018827	8d 0c 03	sta $030c			sta 	UserVector
.01882a	a9 89		lda #$89			lda 	#USRDefault & $FF 			; reset USR vector to a default
.01882c	8d 0d 03	sta $030d			sta 	UserVector+1 				; 24 / 16 bit address
.01882f	a9 96		lda #$96			lda 	#(USRDefault >> 8) & $FF 	; e.g. it becomes JMP USRDefault
.018831	8d 0e 03	sta $030e			sta 	UserVector+2
.018834	a9 01		lda #$01			lda 	#(USRDefault >> 16) & $FF
.018836	8d 0f 03	sta $030f			sta 	UserVector+3
.018839	20 4b 99	jsr $01994b			jsr 	UpdateProgramEnd 			; update the program end.
.01883c	20 cb 91	jsr $0191cb			jsr 	ResetRunStatus 				; clear everything (CLR command)
.01883f	c2 30		rep #$30			rep 	#$30
.018841	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.018844	1b		tcs				tcs
.018845	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.018848	e2 30		sep #$30			sep 	#$30
.01884a	20 b3 90	jsr $0190b3			jsr 	Command_NEW 				; new command, will not return.
.01884d					WarmStart:
.01884d	a2 85		ldx #$85			ldx 	#ReadyMsg & $FF 			; Print READY.
.01884f	a0 88		ldy #$88			ldy 	#(ReadyMsg >> 8) & $FF
.018851	20 ba 85	jsr $0185ba			jsr 	PrintROMMessage
.018854					ErrorStart:
.018854	c2 30		rep #$30			rep 	#$30
.018856	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.018859	1b		tcs				tcs
.01885a	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.01885d	e2 30		sep #$30			sep 	#$30
.01885f	20 f7 80	jsr $0180f7			jsr 	IFT_ReadLine 				; read line in.
.018862	a9 66		lda #$66			lda 	#IFT_LineBuffer & $FF 		; tokenise it.
.018864	a2 05		ldx #$05			ldx 	#IFT_LineBuffer >> 8
.018866	20 e2 9a	jsr $019ae2			jsr 	TokeniseString
.018869	ad 03 04	lda $0403			lda 	TokeniseBuffer+3 			; what is first.
.01886c	29 c0		and #$c0			and 	#$C0 						; is it a number 4000-7FFF
.01886e	c9 40		cmp #$40			cmp 	#$40
.018870	f0 1b		beq $01888d			beq 	EditLine 					; if true, go to edit line.
.018872	a9 00		lda #$00			lda 	#(TokeniseBuffer) & $FF
.018874	85 18		sta $18				sta 	zCodePtr+0
.018876	a9 04		lda #$04			lda 	#((TokeniseBuffer) >> 8)
.018878	85 19		sta $19				sta 	zCodePtr+1
.01887a	a9 00		lda #$00			lda 	#(TokeniseBuffer) >> 16
.01887c	85 1a		sta $1a				sta 	zCodePtr+2
.01887e	85 1b		sta $1b				sta 	zCodePtr+3
.018880	a0 03		ldy #$03			ldy 	#3
.018882	4c 8e 89	jmp $01898e			jmp 	RUN_NextCommand
.018885					ReadyMsg:
>018885	52 65 61 64 79 2e 0d 00				.text 	"Ready.",13,0
.01888d					EditLine:
.01888d	80 fe		bra $01888d			bra 	EditLine

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/dim.asm

.01888f					Command_DIM:
.01888f	98		tya				tya
.018890	48		pha				pha 								; push on stack.
.018891	20 d9 9c	jsr $019cd9			jsr 	VariableExtract 			; get the identifier
.018894	ad 95 03	lda $0395			lda 	Var_Type 					; check it is an array
.018897	29 01		and #$01			and 	#1
.018899	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.01889b	d0 6f		bne $01890c			bne 	_CDIError
.01889d	a9 00		lda #$00			lda 	#0 							; reset the DIM index. The dimensions are
.01889f	8d b9 03	sta $03b9			sta 	UsrArrayIdx 				; built up here and copied in case we autodim
.0188a2					_CDIGetDimension:
.0188a2	ad b9 03	lda $03b9			lda 	UsrArrayIdx 				; done too many ?
.0188a5	c9 06		cmp #$06			cmp 	#ArrayMaxDim*2
.0188a7	f0 63		beq $01890c			beq 	_CDIError
.0188a9	20 a1 93	jsr $0193a1			jsr 	EvaluateInteger 			; evaluate an index size
.0188ac	a5 81		lda $81				lda 	XS_Mantissa+1 				; check in range 0-7FFF
.0188ae	29 80		and #$80			and 	#$80
.0188b0	05 82		ora $82				ora 	XS_Mantissa+2
.0188b2	05 83		ora $83				ora 	XS_Mantissa+3
.0188b4	d0 56		bne $01890c			bne 	_CDIError
.0188b6	ae b9 03	ldx $03b9			ldx 	UsrArrayIdx 				; copy into the array table.
.0188b9	18		clc				clc 								; add 1 - max index => size.
.0188ba	a5 80		lda $80				lda 	XS_Mantissa+0
.0188bc	69 01		adc #$01			adc 	#1
.0188be	9d b1 03	sta $03b1,x			sta 	UsrArrayDef+0,x
.0188c1	a5 81		lda $81				lda 	XS_Mantissa+1
.0188c3	69 00		adc #$00			adc 	#0
.0188c5	9d b2 03	sta $03b2,x			sta 	UsrArrayDef+1,x
.0188c8	30 42		bmi $01890c			bmi 	_CDIError 					; could be dim a(32767)
.0188ca	e8		inx				inx 								; bump index.
.0188cb	e8		inx				inx
.0188cc	8e b9 03	stx $03b9			stx 	UsrArrayIdx
.0188cf	b7 18		lda [$18],y			lda 	[zCodePtr],y
.0188d1	c8		iny				iny
.0188d2	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another dimension
.0188d4	f0 cc		beq $0188a2			beq 	_CDIGetDimension
.0188d6	88		dey				dey
.0188d7	20 a7 99	jsr $0199a7			jsr 	CheckNextRParen 			; closing ) present ?
.0188da	ae b9 03	ldx $03b9			ldx 	UsrArrayIdx 				; copy USR array to default
.0188dd	a9 ff		lda #$ff			lda 	#$FF 						; put end marker in ArrayDef
.0188df	9d aa 03	sta $03aa,x			sta 	ArrayDef+1,x
.0188e2					_CDICopy:
.0188e2	bd b1 03	lda $03b1,x			lda 	UsrArrayDef,x
.0188e5	9d a9 03	sta $03a9,x			sta 	ArrayDef,x
.0188e8	ca		dex				dex
.0188e9	10 f7		bpl $0188e2			bpl 	_CDICopy
.0188eb	68		pla				pla									; position of array identifier
.0188ec	85 10		sta $10				sta 	zTemp1
.0188ee	98		tya				tya
.0188ef	48		pha				pha
.0188f0	a5 10		lda $10				lda 	zTemp1 						; point to identifier
.0188f2	a8		tay				tay
.0188f3	20 d9 9c	jsr $019cd9			jsr 	VariableExtract 			; get the identifier
.0188f6	20 72 9f	jsr $019f72			jsr 	VariableLocate 				; check if it exists already.
.0188f9	b0 11		bcs $01890c			bcs 	_CDIError
.0188fb	20 65 9d	jsr $019d65			jsr 	VariableCreate 				; create it using the current ArrayDef
.0188fe	68		pla				pla 								; restore code position
.0188ff	a8		tay				tay
.018900	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018902	c8		iny				iny
.018903	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another DIM
.018905	f0 88		beq $01888f			beq 	Command_DIM
.018907	88		dey				dey
.018908	20 74 9e	jsr $019e74			jsr 	ArrayResetDefault 			; subsequent automatic DIMs will be (10)
.01890b	60		rts				rts
.01890c					_CDIError:
.01890c	20 86 85	jsr $018586			jsr ERR_Handler
>01890f	42 61 64 20 44 49 4d 00			.text "Bad DIM",0
.018917					_CDISyntax:
.018917	4c 57 85	jmp $018557			jmp 	SyntaxError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/wait.asm

.01891a					Command_WAIT:
.01891a	20 a1 93	jsr $0193a1			jsr		EvaluateInteger 			; get address to monitor
.01891d	a2 06		ldx #$06			ldx 	#XS_Size 					; get and mask
.01891f	20 af 99	jsr $0199af			jsr 	CheckNextComma
.018922	20 a3 93	jsr $0193a3			jsr 	EvaluateIntegerX
.018925	a9 00		lda #$00			lda 	#0							; set default xor value.
.018927	85 8c		sta $8c				sta 	XS_Mantissa+XS_Size*2
.018929	b7 18		lda [$18],y			lda 	[zCodePtr],y
.01892b	c9 bf		cmp #$bf			cmp 	#token_Comma 				; no use the default
.01892d	d0 06		bne $018935			bne 	_CWAXorDefault
.01892f	c8		iny				iny
.018930	a2 0c		ldx #$0c			ldx 	#XS_Size*2					; and get the xor value
.018932	20 a3 93	jsr $0193a3			jsr 	EvaluateIntegerX
.018935					_CWAXorDefault:
.018935	a5 80		lda $80				lda 	XS_Mantissa 				; copy 24 bits of mantissa to ZLTemp1
.018937	85 1c		sta $1c				sta 	zLTemp1
.018939	a5 81		lda $81				lda 	XS_Mantissa+1
.01893b	85 1d		sta $1d				sta 	zLTemp1+1
.01893d	a5 82		lda $82				lda 	XS_Mantissa+2
.01893f	85 1e		sta $1e				sta 	zLTemp1+2
.018941					_CWAWaitLoop:
.018941	20 4d 85	jsr $01854d			jsr 	VIOCheckBreak 				; exit on break.
.018944	c9 00		cmp #$00			cmp 	#0
.018946	d0 11		bne $018959			bne 	_CWAWaitExit
.018948	a9 01		lda #$01			lda 	#1							; read 1 byte to mantissa/0
.01894a	a2 00		ldx #$00			ldx 	#0
.01894c	5a		phy				phy 								; this is the same routine as PEEK.
.01894d	20 29 99	jsr $019929			jsr 	MemRead
.018950	7a		ply				ply
.018951	a5 80		lda $80				lda 	XS_Mantissa+0 				; get byte
.018953	25 86		and $86				and 	XS_Mantissa+XS_Size 		; and it
.018955	45 8c		eor $8c				eor 	XS_Mantissa+XS_Size*2		; eor it.
.018957	f0 e8		beq $018941			beq 	_CWAWaitLoop 				; and loop if zero.
.018959					_CWAWaitExit:
.018959	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/run.asm

.01895a					Command_RUN:
.01895a	20 cb 91	jsr $0191cb			jsr 	ResetRunStatus 				; clear, reset stacks etc.
.01895d	a9 00		lda #$00			lda 	#(BasicProgram) & $FF
.01895f	85 18		sta $18				sta 	zCodePtr+0
.018961	a9 10		lda #$10			lda 	#((BasicProgram) >> 8)
.018963	85 19		sta $19				sta 	zCodePtr+1
.018965	a9 00		lda #$00			lda 	#(BasicProgram) >> 16
.018967	85 1a		sta $1a				sta 	zCodePtr+2
.018969	85 1b		sta $1b				sta 	zCodePtr+3
.01896b	a0 03		ldy #$03			ldy 	#3
.01896d					RUN_NewLine:
.01896d	a0 00		ldy #$00			ldy 	#0
.01896f	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018971	c8		iny				iny
.018972	c8		iny				iny
.018973	c8		iny				iny
.018974	c9 00		cmp #$00			cmp 	#0 							; if the offset is zero then END.
.018976	d0 16		bne $01898e			bne 	RUN_NextCommand
.018978	4c 7d 8d	jmp $018d7d			jmp 	Command_END 				; go do the command code.
.01897b					RUN_Skip:
.01897b	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read element
.01897d	c8		iny				iny 								; skip
.01897e	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018980	90 0c		bcc $01898e			bcc 	_SEDone 					; so just skip over it.
.018982	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018984	90 07		bcc $01898d			bcc 	_SEDouble
.018986	98		tya				tya 								; this is Y + 1
.018987	18		clc				clc
.018988	77 18		adc [$18],y			adc 	[zCodePtr],y 				; add total length of element
.01898a	a8		tay				tay 								; back in Y.
.01898b	88		dey				dey 								; fix up, one for the +1, one for the iny
.01898c	88		dey				dey
.01898d					_SEDouble:
.01898d	c8		iny				iny
.01898e					_SEDone:
.01898e					RUN_NextCommand:
.01898e	ad a8 03	lda $03a8			lda 	BreakCount 					; break counter
.018991	69 10		adc #$10			adc 	#16 						; one time in 16
.018993	8d a8 03	sta $03a8			sta 	BreakCount
.018996	90 0a		bcc $0189a2			bcc 	RUN_NoCheckBreak
.018998	20 4d 85	jsr $01854d			jsr 	VIOCheckBreak 				; check for break
.01899b	c9 00		cmp #$00			cmp 	#0
.01899d	f0 03		beq $0189a2			beq 	RUN_NoCheckBreak
.01899f	4c e2 91	jmp $0191e2			jmp 	Command_STOP 				; stop on BREAK.
.0189a2					RUN_NoCheckBreak:
.0189a2	a9 00		lda #$00			lda 	#0 							; this resets temporary string allocation.
.0189a4	85 23		sta $23				sta 	zTempStr+1 					; (initialised when first called)
.0189a6	b7 18		lda [$18],y			lda 	[zCodePtr],y
.0189a8	c9 c0		cmp #$c0			cmp 	#token_Colon 				; skip over colons
.0189aa	f0 cf		beq $01897b			beq 	RUN_Skip
.0189ac	c9 00		cmp #$00			cmp 	#0 							; if non-zero execute whatever
.0189ae	d0 0f		bne $0189bf			bne 	RUN_Execute
.0189b0					RUN_NextLine:
.0189b0	a0 00		ldy #$00			ldy 	#0 							; point to offset
.0189b2	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read it
.0189b4	18		clc				clc
.0189b5	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.0189b7	85 18		sta $18				sta 	zCodePtr
.0189b9	90 02		bcc $0189bd			bcc 	_SNLNoCarry
.0189bb	e6 19		inc $19				inc 	zCodePtr+1
.0189bd					_SNLNoCarry:
.0189bd	80 ae		bra $01896d			bra 	RUN_NewLine 				; go do the new line code
.0189bf					RUN_Execute:
.0189bf	c9 f8		cmp #$f8			cmp 	#$F8 						; handle shifts, REM etc.
.0189c1	b0 1e		bcs $0189e1			bcs 	RUN_Extension
.0189c3	c8		iny				iny
.0189c4	0a		asl a				asl 	a 							; double the character read.
.0189c5	90 14		bcc $0189db			bcc 	RUN_Default 				; if carry clear was $00-$7F, so try LET.
.0189c7	aa		tax				tax 								; ready to look up.
.0189c8	bf ed 85 01	lda $0185ed,x			lda 	VectorTable,x 				; copy address into LocalVector
.0189cc	8d 11 03	sta $0311			sta 	LocalVector+1
.0189cf	bf ee 85 01	lda $0185ee,x			lda 	VectorTable+1,x
.0189d3	8d 12 03	sta $0312			sta 	LocalVector+2
.0189d6	20 19 93	jsr $019319			jsr 	EVCallLocalVector 			; execute the appropriate code.
.0189d9	80 b3		bra $01898e			bra 	RUN_NextCommand 			; do the next command.
.0189db					RUN_Default:
.0189db	88		dey				dey
.0189dc	20 c7 8b	jsr $018bc7			jsr 	Command_LET 				; and try LET.
.0189df	80 ad		bra $01898e			bra 	RUN_NextCommand
.0189e1					RUN_Extension:
.0189e1	c9 ff		cmp #$ff			cmp 	#$FF 						; if $FF (REM)
.0189e3	f0 96		beq $01897b			beq 	RUN_Skip 					; skip over it.
.0189e5	4c 57 85	jmp $018557			jmp 	SyntaxError
.0189e8					Command_COLON:
.0189e8	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/for.asm

.0189e9					Command_FOR:
.0189e9	20 c7 8b	jsr $018bc7			jsr 	Command_LET 				; do the A = 99 bit
.0189ec	a5 26		lda $26				lda 	zVarType 					; obviously has to be integer/real.
.0189ee	c9 b7		cmp #$b7			cmp 	#token_Dollar
.0189f0	f0 5b		beq $018a4d			beq 	_CFOError
.0189f2	48		pha				pha 								; save the variable type.
.0189f3	5a		phy				phy 								; save type/variable address.
.0189f4	a0 01		ldy #$01			ldy 	#1							; type at + 1
.0189f6	91 28		sta ($28),y			sta 	(zBasicSP),y
.0189f8	c8		iny				iny
.0189f9	a5 24		lda $24				lda 	zVarDataPtr 				; data low at +2
.0189fb	91 28		sta ($28),y			sta 	(zBasicSP),y
.0189fd	c8		iny				iny
.0189fe	a5 25		lda $25				lda 	zVarDataPtr+1 				; data high at +3
.018a00	91 28		sta ($28),y			sta 	(zBasicSP),y
.018a02	7a		ply				ply
.018a03	a9 53		lda #$53			lda 	#(SMark_For << 4) + 3
.018a05	20 bf 84	jsr $0184bf			jsr 	StackPushFrame 				; push on the stack with FOR marker.
.018a08	a9 c8		lda #$c8			lda 	#token_TO
.018a0a	20 90 99	jsr $019990			jsr 	CheckNextToken
.018a0d	a2 00		ldx #$00			ldx 	#0 							; put in Mantissa, bottom
.018a0f	20 39 92	jsr $019239			jsr 	EvaluateExpression
.018a12	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018a14	a2 06		ldx #$06			ldx 	#XS_Size 					; X to second level
.018a16	c9 c9		cmp #$c9			cmp 	#token_STEP
.018a18	d0 06		bne $018a20			bne 	_CFOStep1
.018a1a	c8		iny				iny
.018a1b	20 3b 92	jsr $01923b			jsr 	EvaluateExpressionX 		; get STEP value.
.018a1e	80 0e		bra $018a2e			bra 	_CFOHaveStep
.018a20					_CFOStep1:
.018a20	a9 00		lda #$00			lda 	#0							; set step to integer 1.
.018a22	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018a24	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.018a26	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018a28	a9 01		lda #$01			lda 	#1
.018a2a	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018a2c	95 85		sta $85,x			sta 	XS_Type,x
.018a2e					_CFOHaveStep:
.018a2e	68		pla				pla 								; restore variable type
.018a2f	a2 00		ldx #$00			ldx 	#0
.018a31					_CFOEndConv:
.018a31	20 06 85	jsr $018506			jsr 	StackSavePosition 			; save the loop position at 1-5
.018a34	a9 55		lda #$55			lda 	#(SMark_For << 4)+SourcePosSize
.018a36	20 bf 84	jsr $0184bf			jsr 	StackPushFrame 				; push the loop address frame.
.018a39	5a		phy				phy
.018a3a	a0 00		ldy #$00			ldy 	#0
.018a3c					_CFOCopy:
.018a3c	b9 80 00	lda $0080,y			lda 	XS_Mantissa+0,y
.018a3f	c8		iny				iny
.018a40	91 28		sta ($28),y			sta 	(zBasicSP),y
.018a42	c0 0c		cpy #$0c			cpy 	#XS_Size*2
.018a44	d0 f6		bne $018a3c			bne 	_CFOCopy
.018a46	7a		ply				ply
.018a47	a9 5c		lda #$5c			lda 	#(SMark_For << 4)+(XS_Size*2)
.018a49	20 bf 84	jsr $0184bf			jsr 	StackPushFrame
.018a4c	60		rts				rts
.018a4d					_CFOError:
.018a4d	4c 67 85	jmp $018567			jmp 	TypeError 					; wrong type.
.018a50					Command_NEXT:
.018a50	a9 00		lda #$00			lda 	#0 							; set variable data pointer+1 to zero
.018a52	85 25		sta $25				sta 	zVarDataPtr+1 				; this means we don't check
.018a54	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018a56	c9 00		cmp #$00			cmp 	#0 							; EOL
.018a58	f0 07		beq $018a61			beq 	_CNextNoVariable
.018a5a	c9 40		cmp #$40			cmp 	#$40
.018a5c	b0 03		bcs $018a61			bcs 	_CNextNoVariable
.018a5e	20 6c 9c	jsr $019c6c			jsr 	VariableFind
.018a61					_CNextNoVariable:
.018a61	a5 28		lda $28				lda 	zBasicSP 					; save on stack
.018a63	48		pha				pha
.018a64	a5 29		lda $29				lda 	zBasicSP+1
.018a66	48		pha				pha
.018a67	a9 50		lda #$50			lda 	#(SMark_For << 4) 			; pop loop address frame
.018a69	20 d6 84	jsr $0184d6			jsr 	StackPopFrame
.018a6c	a9 50		lda #$50			lda 	#(SMark_For << 4) 			; pop STEP/TARGET frame.
.018a6e	20 d6 84	jsr $0184d6			jsr 	StackPopFrame
.018a71	a9 50		lda #$50			lda 	#(Smark_For << 4) 			; pop variable address frame.
.018a73	20 d6 84	jsr $0184d6			jsr 	StackPopFrame
.018a76	a5 25		lda $25				lda 	zVarDataPtr+1 				; if zero, then no variable provided
.018a78	f0 11		beq $018a8b			beq 	_CNextGetTarget 			; e.g. just NEXT not NEXT x
.018a7a	5a		phy				phy 								; check addresses match.
.018a7b	a0 02		ldy #$02			ldy 	#2
.018a7d	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018a7f	c5 24		cmp $24				cmp 	zVarDataPtr
.018a81	d0 69		bne $018aec			bne 	_CNextWrong
.018a83	c8		iny				iny
.018a84	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018a86	c5 25		cmp $25				cmp 	zVarDataPtr+1
.018a88	d0 62		bne $018aec			bne 	_CNextWrong
.018a8a	7a		ply				ply
.018a8b					_CNextGetTarget:
.018a8b	5a		phy				phy
.018a8c	a0 01		ldy #$01			ldy 	#1 							; restore variable type and data.
.018a8e	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018a90	85 26		sta $26				sta 	zVarType
.018a92	c8		iny				iny
.018a93	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018a95	85 24		sta $24				sta 	zVarDataPtr
.018a97	c8		iny				iny
.018a98	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018a9a	85 25		sta $25				sta 	zVarDataPtr+1
.018a9c	a2 0c		ldx #$0c			ldx 	#12
.018a9e	20 b6 9f	jsr $019fb6			jsr 	VariableGet 				; get that variable value into expr[2]
.018aa1	a2 00		ldx #$00			ldx 	#0 							; copy stacked Target/Step into expr[0] and [1]
.018aa3	a0 0b		ldy #$0b			ldy 	#11
.018aa5					_CNXCopy:
.018aa5	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018aa7	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018aa9	e8		inx				inx
.018aaa	c8		iny				iny
.018aab	e0 0c		cpx #$0c			cpx 	#XS_Size*2
.018aad	d0 f6		bne $018aa5			bne 	_CNXCopy
.018aaf	7a		ply				ply
.018ab0	a2 06		ldx #$06			ldx 	#6 							; point at expr[1] s
.018ab2	20 cb 95	jsr $0195cb			jsr 	GetSignCurrent
.018ab5	8d a7 03	sta $03a7			sta 	SignNext 					; save in temporary.
.018ab8	a2 06		ldx #$06			ldx 	#6 							; add them, however
.018aba	20 e1 94	jsr $0194e1			jsr 	BinaryOp_Add
.018abd	20 07 a0	jsr $01a007			jsr 	VariableSet					; and write variable back.
.018ac0	a2 00		ldx #$00			ldx 	#0
.018ac2	20 72 94	jsr $019472			jsr 	CompareValues
.018ac5	09 00		ora #$00			ora 	#0
.018ac7	f0 05		beq $018ace			beq 	_CNXAgain 					; if true, then do it again.
.018ac9	cd a7 03	cmp $03a7			cmp 	SignNext 					; if sign different, then loop has finished.
.018acc	d0 0f		bne $018add			bne 	_CNXLoopDone
.018ace					_CNXAgain:
.018ace	a9 53		lda #$53			lda 	#(SMark_For << 4) + 3		; re-stack variable address
.018ad0	20 bf 84	jsr $0184bf			jsr 	StackPushFrame
.018ad3	20 23 85	jsr $018523			jsr 	StackRestorePosition 		; get restore position back, e.g. loop round.
.018ad6	68		pla				pla
.018ad7	85 29		sta $29				sta 	zBasicSP+1
.018ad9	68		pla				pla
.018ada	85 28		sta $28				sta 	zBasicSP
.018adc					_CNXExit:
.018adc	60		rts				rts
.018add					_CNXLoopDone:
.018add	68		pla				pla 								; throw away saved to Basic Stack Pointer
.018ade	68		pla				pla
.018adf	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018ae1	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma ?
.018ae3	d0 f7		bne $018adc			bne 	_CNXExit
.018ae5	c8		iny				iny
.018ae6	20 6c 9c	jsr $019c6c			jsr 	VariableFind 				; identify the variable
.018ae9	4c 61 8a	jmp $018a61			jmp 	_CNextNoVariable 			; go back with variable pre-found
.018aec					_CNextWrong:
.018aec	20 86 85	jsr $018586			jsr ERR_Handler
>018aef	57 72 6f 6e 67 20 4e 65			.text "Wrong Next Variable",0
>018af7	78 74 20 56 61 72 69 61 62 6c 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/read.asm

.018b03					Command_READ:
.018b03	20 6c 9c	jsr $019c6c			jsr 	VariableFind 				; get variable/value into zVarDataPtr,zVarType
.018b06	a5 24		lda $24				lda 	zVarDataPtr 				; save variable info on stack
.018b08	48		pha				pha
.018b09	a5 25		lda $25				lda 	zVarDataPtr+1
.018b0b	48		pha				pha
.018b0c	a5 26		lda $26				lda 	zVarType
.018b0e	48		pha				pha
.018b0f	20 55 8b	jsr $018b55			jsr 	READGetDataItem 			; get the next data item
.018b12	68		pla				pla 								; restore target variable information.
.018b13	85 26		sta $26				sta 	zVarType
.018b15	68		pla				pla
.018b16	85 25		sta $25				sta 	zVarDataPtr+1
.018b18	68		pla				pla
.018b19	85 24		sta $24				sta 	zVarDataPtr
.018b1b	a2 00		ldx #$00			ldx 	#0
.018b1d	20 07 a0	jsr $01a007			jsr 	VariableSet 				; set the value out.
.018b20	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018b22	c8		iny				iny
.018b23	c9 bf		cmp #$bf			cmp 	#token_Comma
.018b25	f0 dc		beq $018b03			beq 	Command_READ 				; found, do another READ
.018b27	88		dey				dey
.018b28	60		rts				rts
.018b29					Command_DATA:
.018b29	4c 8d 84	jmp $01848d			jmp 	SkipEndOfCommand
.018b2c					Command_RESTORE:
.018b2c	48		pha				pha
.018b2d	a9 00		lda #$00			lda 	#0 							; this being zero means 'initialise next read'
.018b2f	8d bd 03	sta $03bd			sta 	DataLPtr+0
.018b32	8d be 03	sta $03be			sta 	DataLPtr+1
.018b35	68		pla				pla
.018b36	60		rts				rts
.018b37					READSwapPointers:
.018b37	98		tya				tya
.018b38	48		pha				pha 								; save it
.018b39	ad c1 03	lda $03c1			lda 	DataIndex 					; get data offset, and copy to offset
.018b3c	a8		tay				tay
.018b3d	68		pla				pla 								; get code offset and save in DataIndex
.018b3e	8d c1 03	sta $03c1			sta 	DataIndex
.018b41	da		phx				phx
.018b42	a2 03		ldx #$03			ldx 	#3 							; swap the Data Pointers (4 bytes) round.
.018b44					_RSWLoop:
.018b44	bd bd 03	lda $03bd,x			lda 	DataLPtr+0,x
.018b47	48		pha				pha
.018b48	b5 18		lda $18,x			lda 	zCodePtr+0,x
.018b4a	9d bd 03	sta $03bd,x			sta 	DataLPtr+0,x
.018b4d	68		pla				pla
.018b4e	95 18		sta $18,x			sta 	zCodePtr+0,x
.018b50	ca		dex				dex
.018b51	10 f1		bpl $018b44			bpl 	_RSWLoop
.018b53	fa		plx				plx
.018b54	60		rts				rts
.018b55					READGetDataItem:
.018b55	20 37 8b	jsr $018b37			jsr 	ReadSwapPointers 			; swap code and data pointer.
.018b58	a5 18		lda $18				lda		zCodePtr+0 					; initialise ?
.018b5a	05 19		ora $19				ora 	zCodePtr+1
.018b5c	d0 12		bne $018b70			bne 	_RGDIIsInitialised
.018b5e	a9 00		lda #$00			lda 	#(BasicProgram) & $FF
.018b60	85 18		sta $18				sta 	zCodePtr+0
.018b62	a9 10		lda #$10			lda 	#((BasicProgram) >> 8)
.018b64	85 19		sta $19				sta 	zCodePtr+1
.018b66	a9 00		lda #$00			lda 	#(BasicProgram) >> 16
.018b68	85 1a		sta $1a				sta 	zCodePtr+2
.018b6a	85 1b		sta $1b				sta 	zCodePtr+3
.018b6c	a0 03		ldy #$03			ldy 	#3
.018b6e	80 06		bra $018b76			bra 	_RGDIFindData 				; locate next data from start and read that.
.018b70					_RGDIIsInitialised:
.018b70	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018b72	c9 bf		cmp #$bf			cmp 	#token_Comma
.018b74	f0 49		beq $018bbf			beq 	_RGDISkipEvaluateExit
.018b76					_RGDIFindData:
.018b76	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018b78	c9 00		cmp #$00			cmp 	#0 							; end of line
.018b7a	f0 19		beq $018b95			beq 	_RGDIFindNextLine
.018b7c	c9 c5		cmp #$c5			cmp 	#token_DATA 				; found data token
.018b7e	f0 3f		beq $018bbf			beq 	_RGDISkipEvaluateExit 		; then skip it and evaluate
.018b80	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read element
.018b82	c8		iny				iny 								; skip
.018b83	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018b85	90 0c		bcc $018b93			bcc 	_SEDone 					; so just skip over it.
.018b87	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018b89	90 07		bcc $018b92			bcc 	_SEDouble
.018b8b	98		tya				tya 								; this is Y + 1
.018b8c	18		clc				clc
.018b8d	77 18		adc [$18],y			adc 	[zCodePtr],y 				; add total length of element
.018b8f	a8		tay				tay 								; back in Y.
.018b90	88		dey				dey 								; fix up, one for the +1, one for the iny
.018b91	88		dey				dey
.018b92					_SEDouble:
.018b92	c8		iny				iny
.018b93					_SEDone:
.018b93	80 e1		bra $018b76			bra 	_RGDIFindData
.018b95					_RGDIFindNextLine:
.018b95	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018b97	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read it
.018b99	18		clc				clc
.018b9a	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.018b9c	85 18		sta $18				sta 	zCodePtr
.018b9e	90 02		bcc $018ba2			bcc 	_SNLNoCarry
.018ba0	e6 19		inc $19				inc 	zCodePtr+1
.018ba2					_SNLNoCarry:
.018ba2	a0 00		ldy #$00			ldy 	#0
.018ba4	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018ba6	48		pha				pha
.018ba7	c8		iny				iny
.018ba8	c8		iny				iny
.018ba9	c8		iny				iny
.018baa	68		pla				pla
.018bab	d0 c9		bne $018b76			bne 	_RGDIFindData 				; back to scanning.
.018bad	20 37 8b	jsr $018b37			jsr 	ReadSwapPointers 			; so we get error in line number of READ
.018bb0	20 86 85	jsr $018586			jsr ERR_Handler
>018bb3	4f 75 74 20 6f 66 20 44			.text "Out of Data",0
>018bbb	61 74 61 00
.018bbf					_RGDISkipEvaluateExit:
.018bbf	c8		iny				iny
.018bc0	20 39 92	jsr $019239			jsr 	EvaluateExpression 			; evaluate the expression
.018bc3	20 37 8b	jsr $018b37			jsr 	ReadSwapPointers 			; swap the pointers around.
.018bc6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/let.asm

.018bc7					Command_LET:
.018bc7	20 6c 9c	jsr $019c6c			jsr 	VariableFind 				; get reference to one variable.
.018bca	a9 84		lda #$84			lda 	#token_Equal  				; get equals
.018bcc	20 90 99	jsr $019990			jsr 	CheckNextToken
.018bcf	a5 24		lda $24				lda 	zVarDataPtr 				; save variable info on stack
.018bd1	48		pha				pha
.018bd2	a5 25		lda $25				lda 	zVarDataPtr+1
.018bd4	48		pha				pha
.018bd5	a5 26		lda $26				lda 	zVarType
.018bd7	48		pha				pha
.018bd8	20 39 92	jsr $019239			jsr 	EvaluateExpression 			; evaluate the RHS, set X to zero.
.018bdb	68		pla				pla 								; restore target variable information.
.018bdc	85 26		sta $26				sta 	zVarType
.018bde	68		pla				pla
.018bdf	85 25		sta $25				sta 	zVarDataPtr+1
.018be1	68		pla				pla
.018be2	85 24		sta $24				sta 	zVarDataPtr
.018be4	20 07 a0	jsr $01a007			jsr 	VariableSet 				; set the value out.
.018be7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/get.asm

.018be8					Command_GET:
.018be8					_CGLoop:
.018be8	20 6c 9c	jsr $019c6c			jsr 	VariableFind 				; get a variable.
.018beb	20 42 85	jsr $018542			jsr 	VIOCharGet 					; get character
.018bee	b0 02		bcs $018bf2			bcs 	_CGNoKey
.018bf0	a9 00		lda #$00			lda 	#0 							; if no character return zero
.018bf2					_CGNoKey:
.018bf2	48		pha				pha
.018bf3	a5 26		lda $26				lda 	zVarType 					; look at the data type.
.018bf5	c9 b7		cmp #$b7			cmp 	#token_Dollar
.018bf7	f0 1e		beq $018c17			beq 	_CGString
.018bf9	68		pla				pla 								; put character in slot.
.018bfa	85 80		sta $80				sta 	XS_Mantissa
.018bfc	a9 00		lda #$00			lda 	#0
.018bfe	85 81		sta $81				sta 	XS_Mantissa+1
.018c00	85 82		sta $82				sta 	XS_Mantissa+2
.018c02	85 83		sta $83				sta 	XS_Mantissa+3
.018c04	a9 01		lda #$01			lda 	#1 							; type integer
.018c06	85 85		sta $85				sta 	XS_Type
.018c08					_CGWriteSetNext:
.018c08	a2 00		ldx #$00			ldx 	#0 							; write number/WriteTempString out
.018c0a	20 07 a0	jsr $01a007			jsr 	VariableSet
.018c0d	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018c0f	c9 bf		cmp #$bf			cmp 	#token_Comma 				; if not comma exit
.018c11	d0 03		bne $018c16			bne 	_CGExit
.018c13	c8		iny				iny
.018c14	80 d2		bra $018be8			bra 	_CGLoop 					; and get another.
.018c16					_CGExit:
.018c16	60		rts				rts
.018c17					_CGString:
.018c17	a9 02		lda #$02			lda 	#2 							; allocate temp string, space for 2.
.018c19	20 f4 99	jsr $0199f4			jsr 	AllocateTempString 			; initially empty.
.018c1c	a5 22		lda $22				lda 	zTempStr 					; set up to be returned.
.018c1e	85 80		sta $80				sta 	XS_Mantissa
.018c20	a5 23		lda $23				lda 	zTempStr+1
.018c22	85 81		sta $81				sta 	XS_Mantissa+1
.018c24	a9 02		lda #$02			lda 	#2
.018c26	85 85		sta $85				sta 	XS_Type
.018c28	68		pla				pla 								; get A
.018c29	c9 00		cmp #$00			cmp 	#0
.018c2b	f0 db		beq $018c08			beq 	_CGWriteSetNext
.018c2d	20 1f 9a	jsr $019a1f			jsr 	WriteTempString 			; write it into string
.018c30	80 d6		bra $018c08			bra 	_CGWriteSetNext

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/sys.asm

.018c32					Command_SYS:
.018c32	20 a1 93	jsr $0193a1			jsr 	EvaluateInteger 			; address to call.
.018c35	a5 80		lda $80				lda 	XS_Mantissa+0				; copy to localvector
.018c37	8d 10 03	sta $0310			sta 	LocalVector+0 				; only three, can only do 24 bit calls
.018c3a	a5 81		lda $81				lda 	XS_Mantissa+1 				; and that only on 65816
.018c3c	8d 11 03	sta $0311			sta 	LocalVector+1
.018c3f	a5 82		lda $82				lda 	XS_Mantissa+2
.018c41	8d 12 03	sta $0312			sta 	LocalVector+2
.018c44	22 49 8c 01	jsl $018c49			jsl 	_CSYLocalCall 				; jump depending on 24/16 bit code address
.018c48	60		rts				rts
.018c49					_CSYLocalCall:
.018c49	dc 10 03	jmp [$0310]			jmp 	[LocalVector]		 		; address

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/input.asm

.018c4c					Command_INPUT:
.018c4c	a9 00		lda #$00		lda 	#0 								; clear number of characters required.
.018c4e	8d c2 03	sta $03c2		sta 	InputAvailable 					; save character count
.018c51	8d c3 03	sta $03c3		sta 	InputRetry
.018c54					_CILoop:
.018c54	a9 00		lda #$00		lda 	#0 								; this resets temporary string allocation.
.018c56	85 23		sta $23			sta 	zTempStr+1 						; (could get lots of long strings)
.018c58	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018c5a	c9 fe		cmp #$fe		cmp 	#$FE 							; is it a prompt string
.018c5c	d0 15		bne $018c73		bne 	_CINoPrompt
.018c5e	c8		iny				iny
.018c5f	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018c61	aa		tax			tax 									; into X
.018c62	c8		iny				iny
.018c63	ca		dex			dex 									; deduct marker/prompt length
.018c64	ca		dex			dex
.018c65	f0 ed		beq $018c54		beq 	_CILoop 						; nothing.
.018c67					_CIShowPrompt:
.018c67	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018c69	20 3f 85	jsr $01853f		jsr 	VIOCharPrint
.018c6c	c8		iny				iny
.018c6d	ca		dex			dex
.018c6e	d0 f7		bne $018c67		bne 	_CIShowPrompt
.018c70	80 e2		bra $018c54		bra 	_CILoop
.018c72					_CIAdvance:
.018c72	c8		iny				iny
.018c73					_CINoPrompt:
.018c73	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018c75	c9 bf		cmp #$bf		cmp 	#token_Comma 					; skip , and ;
.018c77	f0 f9		beq $018c72		beq 	_CIAdvance
.018c79	c9 c1		cmp #$c1		cmp 	#token_SemiColon
.018c7b	f0 f5		beq $018c72		beq 	_CIAdvance
.018c7d	c9 00		cmp #$00		cmp 	#0 								; exit if 0 or :
.018c7f	f0 04		beq $018c85		beq 	_CIExit
.018c81	c9 c0		cmp #$c0		cmp 	#token_Colon
.018c83	d0 01		bne $018c86		bne 	_CIIsVariable  					; if not then there#s a variable or should be !
.018c85					_CIExit:
.018c85	60		rts			rts
.018c86					_CIIsVariable:
.018c86	20 6c 9c	jsr $019c6c		jsr 	VariableFind 					; set zVarType and zVarDataPtr accordingly.
.018c89	a5 26		lda $26			lda 	zVarType
.018c8b	c9 b7		cmp #$b7		cmp 	#token_Dollar 					; is it a string ?
.018c8d	f0 40		beq $018ccf		beq 	_CIIsString
.018c8f					_CINGetText:
.018c8f	a9 00		lda #$00		lda 	#0
.018c91	8d 14 03	sta $0314		sta 	NumBufX
.018c94					_CINSkip:
.018c94	20 2e 8d	jsr $018d2e		jsr 	CIGetCharacter 					; get character skip spaces
.018c97	c9 20		cmp #$20		cmp 	#" "
.018c99	f0 f9		beq $018c94		beq 	_CINSkip
.018c9b	c9 2c		cmp #$2c		cmp 	#","
.018c9d	f0 f5		beq $018c94		beq 	_CINSkip
.018c9f					_CINLoop:
.018c9f	ae 14 03	ldx $0314		ldx 	NumBufX 						; output character
.018ca2	9d 15 03	sta $0315,x		sta 	Num_Buffer,x
.018ca5	a9 00		lda #$00		lda 	#0 								; add trailing NULL
.018ca7	9d 16 03	sta $0316,x		sta 	Num_Buffer+1,x
.018caa	ee 14 03	inc $0314		inc 	NumBufX 						; bump ptr
.018cad	20 2e 8d	jsr $018d2e		jsr 	CIGetCharacter 					; get next character
.018cb0	c9 3a		cmp #$3a		cmp 	#":" 							; stop on : ,
.018cb2	f0 08		beq $018cbc		beq 	_CINCopied
.018cb4	c9 2c		cmp #$2c		cmp 	#","
.018cb6	f0 04		beq $018cbc		beq 	_CINCopied
.018cb8	c9 21		cmp #$21		cmp 	#" "+1
.018cba	b0 e3		bcs $018c9f		bcs 	_CINLoop
.018cbc					_CINCopied:
.018cbc	a2 00		ldx #$00		ldx 	#0
.018cbe	20 da 96	jsr $0196da		jsr 	ConvertNumBuffer 				; convert number
.018cc1	b0 05		bcs $018cc8		bcs 	_CINFailed 						; didn't work.
.018cc3	20 07 a0	jsr $01a007		jsr 	VariableSet 					; set variable.
.018cc6	80 8c		bra $018c54		bra 	_CILoop 						; go round again.
.018cc8					_CINFailed:
.018cc8	a9 00		lda #$00		lda 	#0 								; set to request input next time.
.018cca	8d c2 03	sta $03c2		sta 	InputAvailable
.018ccd	80 c0		bra $018c8f		bra 	_CINGetText 					; and try again
.018ccf					_CIIsString:
.018ccf	a9 82		lda #$82		lda 	#130 							; max of 128 characters
.018cd1	20 f4 99	jsr $0199f4		jsr 	AllocateTempString
.018cd4	a9 00		lda #$00		lda 	#0 								; this is the quote flag.
.018cd6	8d 14 03	sta $0314		sta 	NumBufX
.018cd9					_CISSkip:
.018cd9	20 2e 8d	jsr $018d2e		jsr 	CIGetCharacter 					; get character skip spaces
.018cdc	c9 20		cmp #$20		cmp 	#" "
.018cde	f0 f9		beq $018cd9		beq 	_CISSkip
.018ce0	80 03		bra $018ce5		bra 	_CISInputProcess 				; handle that as the first character
.018ce2					_CISInput:
.018ce2	20 2e 8d	jsr $018d2e		jsr 	CIGetCharacter
.018ce5					_CISInputProcess:
.018ce5	c9 0d		cmp #$0d		cmp 	#13 							; EOL ?
.018ce7	f0 31		beq $018d1a		beq 	_CISDone
.018ce9	c9 3a		cmp #$3a		cmp 	#":"							; colon exits if not in quotes. who knows why?
.018ceb	d0 05		bne $018cf2		bne 	_CISNotColon
.018ced	2c 14 03	bit $0314		bit 	NumBufX 						; check quote flag
.018cf0	10 28		bpl $018d1a		bpl 	_CISDone 						; if quote flag zero, done
.018cf2					_CISNotColon:
.018cf2	c9 22		cmp #$22		cmp 	#'"'							; quoted string ?
.018cf4	f0 1a		beq $018d10		beq 	_CISIsQuote						; if so handle that code.
.018cf6	20 1f 9a	jsr $019a1f		jsr 	WriteTempString 				; write to the temporary string
.018cf9	ad 9f 03	lda $039f		lda 	TempStringWriteIndex 			; string too long ?
.018cfc	10 e4		bpl $018ce2		bpl 	_CISInput
.018cfe	20 86 85	jsr $018586			jsr ERR_Handler
>018d01	49 6e 70 75 74 20 74 6f			.text "Input too long",0
>018d09	6f 20 6c 6f 6e 67 00
.018d10					_CISIsQuote:
.018d10	ad 14 03	lda $0314		lda 	NumBufX 						; this is the 'in quote flag'
.018d13	49 80		eor #$80		eor 	#$80 							; toggle bit 7
.018d15	8d 14 03	sta $0314		sta 	NumBufX
.018d18	d0 c8		bne $018ce2		bne 	_CISInput 						; if entered quote mode, get next character
.018d1a					_CISDone:
.018d1a	a5 22		lda $22			lda 	zTempStr 						; return the temporary string
.018d1c	85 80		sta $80			sta 	XS_Mantissa+0
.018d1e	a5 23		lda $23			lda 	zTempStr+1
.018d20	85 81		sta $81			sta 	XS_Mantissa+1
.018d22	a9 02		lda #$02		lda 	#2
.018d24	85 85		sta $85			sta 	XS_Type
.018d26	a2 00		ldx #$00		ldx 	#0
.018d28	20 07 a0	jsr $01a007		jsr 	VariableSet 					; set variable.
.018d2b	4c 54 8c	jmp $018c54		jmp 	_CILoop 						; and try again
.018d2e					CIGetCharacter:
.018d2e	5a		phy			phy
.018d2f	ac c2 03	ldy $03c2		ldy		InputAvailable 					; anything available
.018d32	f0 0c		beq $018d40		beq 	_CIGCNewLine 					; no, needs a new line.
.018d34	b9 66 05	lda $0566,y		lda 	IFT_LineBuffer,y 				; read line buffer entry
.018d37	c9 0d		cmp #$0d		cmp 	#13 							; got 13 ?
.018d39	f0 03		beq $018d3e		beq 	_CIGCNoInc
.018d3b	ee c2 03	inc $03c2		inc 	InputAvailable 					; if not, advance character pointer.
.018d3e					_CIGCNoInc:
.018d3e	7a		ply			ply
.018d3f	60		rts			rts
.018d40					_CIGCNewLine:
.018d40	ee c2 03	inc $03c2		inc 	InputAvailable 					; next pointer to 1 (first char this time)
.018d43	a9 3f		lda #$3f		lda 	#"?"
.018d45	20 3f 85	jsr $01853f		jsr 	VIOCharPrint
.018d48	ac c3 03	ldy $03c3		ldy 	InputRetry 						; retry flag set
.018d4b	f0 03		beq $018d50		beq 	_CIGCPrompt 					; if so, then print ? again
.018d4d	20 3f 85	jsr $01853f		jsr 	VIOCharPrint
.018d50					_CIGCPrompt:
.018d50	a0 01		ldy #$01		ldy 	#1
.018d52	8c c3 03	sty $03c3		sty 	InputRetry 						; set the input retry flag to non-zero
.018d55					_CIGCBackOne:
.018d55	88		dey			dey
.018d56					_CIGCLoop:
.018d56	c0 50		cpy #$50		cpy 	#80 							; stop overflow.
.018d58	f0 fb		beq $018d55		beq 	_CIGCBackOne
.018d5a	20 42 85	jsr $018542		jsr 	VIOCharGet 						; get a character
.018d5d	f0 f7		beq $018d56		beq 	_CIGCLoop 						; wait until key pressed
.018d5f	c9 08		cmp #$08		cmp 	#8 								; backspace
.018d61	f0 10		beq $018d73		beq 	_CIGCBackSpace
.018d63	20 3f 85	jsr $01853f		jsr 	VIOCharPrint 					; echo character
.018d66	99 66 05	sta $0566,y		sta		IFT_LineBuffer,y 				; write into buffer and bump
.018d69	c8		iny			iny
.018d6a	c9 0d		cmp #$0d		cmp 	#13 							; until CR pressed.
.018d6c	d0 e8		bne $018d56		bne 	_CIGCLoop
.018d6e	ad 66 05	lda $0566		lda 	IFT_LineBuffer 					; return first char in buffer
.018d71	7a		ply			ply 									; restore Y
.018d72	60		rts			rts
.018d73					_CIGCBackSpace:
.018d73	c0 00		cpy #$00		cpy 	#0 								; can only B/S if not first
.018d75	f0 df		beq $018d56		beq 	_CIGCLoop
.018d77	20 3f 85	jsr $01853f		jsr 	VIOCharPrint 					; echo BS
.018d7a	88		dey			dey 									; go back one.
.018d7b	80 d9		bra $018d56		bra 	_CIGCLoop

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/end.asm

.018d7d					Command_END:
.018d7d	4c 4d 88	jmp $01884d			jmp 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/if.asm

.018d80					Command_IF:
.018d80	20 a1 93	jsr $0193a1			jsr 	EvaluateInteger 			; check success.
.018d83	a5 80		lda $80				lda 	XS_Mantissa+0				; check the result if zero
.018d85	05 81		ora $81				ora 	XS_Mantissa+1
.018d87	05 82		ora $82				ora 	XS_Mantissa+2
.018d89	05 83		ora $83				ora 	XS_Mantissa+3
.018d8b	aa		tax				tax 								; put into X.
.018d8c	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018d8e	c9 93		cmp #$93			cmp 	#token_Then 				; then found.
.018d90	d0 2c		bne $018dbe			bne 	_FIFExtended
.018d92	c8		iny				iny
.018d93	e0 00		cpx #$00			cpx 	#0 							; was it successful.
.018d95	f0 0b		beq $018da2			beq 	_FIFEndOfLine 				; if not, go to the end of the line.
.018d97	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018d99	29 c0		and #$c0			and 	#$C0 						; is it a number
.018d9b	c9 40		cmp #$40			cmp 	#$40
.018d9d	d0 1e		bne $018dbd			bne 	_FIFContinue 				; if not, do what ever follows.
.018d9f	4c 09 91	jmp $019109			jmp		Command_GOTO 				; we have IF <expr> THEN <number> so we do GOTO code.
.018da2					_FIFEndOfLine:
.018da2	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018da4	c9 00		cmp #$00			cmp 	#0 							; if zero, end of line, so exit
.018da6	f0 15		beq $018dbd			beq 	_FIFContinue
.018da8	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read element
.018daa	c8		iny				iny 								; skip
.018dab	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018dad	90 0c		bcc $018dbb			bcc 	_SEDone 					; so just skip over it.
.018daf	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018db1	90 07		bcc $018dba			bcc 	_SEDouble
.018db3	98		tya				tya 								; this is Y + 1
.018db4	18		clc				clc
.018db5	77 18		adc [$18],y			adc 	[zCodePtr],y 				; add total length of element
.018db7	a8		tay				tay 								; back in Y.
.018db8	88		dey				dey 								; fix up, one for the +1, one for the iny
.018db9	88		dey				dey
.018dba					_SEDouble:
.018dba	c8		iny				iny
.018dbb					_SEDone:
.018dbb	80 e5		bra $018da2			bra 	_FIFEndOfLine
.018dbd					_FIFContinue:
.018dbd	60		rts				rts
.018dbe					_FIFExtended:
.018dbe	da		phx				phx 								; save result
.018dbf	a9 40		lda #$40			lda 	#(SMark_If << 4) 			; push marker on the stack, nothing else.
.018dc1	20 bf 84	jsr $0184bf			jsr 	StackPushFrame
.018dc4	68		pla				pla 								; restore result
.018dc5	f0 01		beq $018dc8			beq 	_FIXSkip 					; if zero then it has failed.
.018dc7	60		rts				rts 								; test passed, so continue executing
.018dc8					_FIXSkip:
.018dc8	a9 94		lda #$94			lda 	#token_endif 				; scan forward till found either ELSE or ENDIF
.018dca	a2 de		ldx #$de			ldx 	#token_else 				; at the same level.
.018dcc	20 02 84	jsr $018402			jsr 	StructureSearchDouble
.018dcf	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018dd1	c8		iny				iny
.018dd2	c9 94		cmp #$94			cmp 	#token_endif 				; if endif, handle endif code.
.018dd4	f0 07		beq $018ddd			beq 	Command_ENDIF
.018dd6	60		rts				rts
.018dd7					Command_ELSE:
.018dd7	a9 94		lda #$94			lda 	#token_endif 				; scan forward till found ENDIF
.018dd9	20 00 84	jsr $018400			jsr 	StructureSearchSingle 		; then do the ENDIF pop.
.018ddc	c8		iny				iny
.018ddd					Command_ENDIF:
.018ddd	a9 40		lda #$40			lda 	#(SMark_If << 4)
.018ddf	20 d6 84	jsr $0184d6			jsr 	StackPopFrame
.018de2	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/list.asm

.018de3					Command_LIST:
.018de3	20 70 8f	jsr $018f70			jsr 	ListGetRange				; get any parameters
.018de6	a9 00		lda #$00			lda 	#(BasicProgram) & $FF
.018de8	85 18		sta $18				sta 	zCodePtr+0
.018dea	a9 10		lda #$10			lda 	#((BasicProgram) >> 8)
.018dec	85 19		sta $19				sta 	zCodePtr+1
.018dee	a9 00		lda #$00			lda 	#(BasicProgram) >> 16
.018df0	85 1a		sta $1a				sta 	zCodePtr+2
.018df2	85 1b		sta $1b				sta 	zCodePtr+3
.018df4	a0 03		ldy #$03			ldy 	#3
.018df6	a9 00		lda #$00			lda 	#0 							; reset the indent & last indent
.018df8	8d bc 03	sta $03bc			sta 	LastListIndent
.018dfb	8d bb 03	sta $03bb			sta 	ListIndent
.018dfe					_CILLoop:
.018dfe	a0 00		ldy #$00			ldy 	#0
.018e00	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018e02	c9 00		cmp #$00			cmp 	#0 							; if zero, end of program
.018e04	f0 23		beq $018e29			beq 	_CILExit
.018e06	20 4d 85	jsr $01854d			jsr 	VIOCheckBreak 				; check break
.018e09	c9 00		cmp #$00			cmp 	#0
.018e0b	d0 1c		bne $018e29			bne 	_CILExit
.018e0d	20 b7 8f	jsr $018fb7			jsr 	ListCheckRange 				; check current line in range.
.018e10	b0 08		bcs $018e1a			bcs		_CILNext
.018e12	a0 00		ldy #$00			ldy 	#0
.018e14	c8		iny				iny
.018e15	c8		iny				iny
.018e16	c8		iny				iny
.018e17	20 2c 8e	jsr $018e2c			jsr 	ListLine 					; list one line.
.018e1a					_CILNext:
.018e1a	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018e1c	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read it
.018e1e	18		clc				clc
.018e1f	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.018e21	85 18		sta $18				sta 	zCodePtr
.018e23	90 02		bcc $018e27			bcc 	_SNLNoCarry
.018e25	e6 19		inc $19				inc 	zCodePtr+1
.018e27					_SNLNoCarry:
.018e27	80 d5		bra $018dfe			bra 	_CILLoop
.018e29					_CILExit:
.018e29	4c 4d 88	jmp $01884d			jmp 	WarmStart
.018e2c					ListLine:
.018e2c	ad bb 03	lda $03bb			lda 	ListIndent 					; copy current list indent -> last
.018e2f	8d bc 03	sta $03bc			sta 	LastListIndent
.018e32					_LICountIndent:
.018e32	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018e34	c9 00		cmp #$00			cmp 	#0
.018e36	f0 2f		beq $018e67			beq 	_LIDoneIndent
.018e38	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus
.018e3a	90 16		bcc $018e52			bcc 	_LICINext
.018e3c	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.018e3e	b0 12		bcs $018e52			bcs 	_LICINext
.018e40	ee bb 03	inc $03bb			inc 	ListIndent
.018e43	c9 93		cmp #$93			cmp 	#firstKeywordMinus
.018e45	90 0b		bcc $018e52			bcc 	_LICINext
.018e47	ce bb 03	dec $03bb			dec 	ListIndent
.018e4a	ce bb 03	dec $03bb			dec 	ListIndent
.018e4d	10 03		bpl $018e52			bpl 	_LICINext
.018e4f	ee bb 03	inc $03bb			inc 	ListIndent
.018e52					_LICINext:
.018e52	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read element
.018e54	c8		iny				iny 								; skip
.018e55	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018e57	90 0c		bcc $018e65			bcc 	_SEDone 					; so just skip over it.
.018e59	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018e5b	90 07		bcc $018e64			bcc 	_SEDouble
.018e5d	98		tya				tya 								; this is Y + 1
.018e5e	18		clc				clc
.018e5f	77 18		adc [$18],y			adc 	[zCodePtr],y 				; add total length of element
.018e61	a8		tay				tay 								; back in Y.
.018e62	88		dey				dey 								; fix up, one for the +1, one for the iny
.018e63	88		dey				dey
.018e64					_SEDouble:
.018e64	c8		iny				iny
.018e65					_SEDone:
.018e65	80 cb		bra $018e32			bra 	_LICountIndent
.018e67					_LIDoneIndent:
.018e67	a0 00		ldy #$00			ldy 	#0
.018e69	c8		iny				iny
.018e6a	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018e6c	85 80		sta $80				sta 	XS_Mantissa
.018e6e	c8		iny				iny
.018e6f	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018e71	85 81		sta $81				sta 	XS_Mantissa+1
.018e73	20 cf 85	jsr $0185cf			jsr 	Print16BitInteger 			; print integer.
.018e76	85 10		sta $10				sta 	zTemp1 						; save spaces printed.
.018e78	ad bb 03	lda $03bb			lda 	ListIndent 					; smaller of current/prev indent
.018e7b	cd bc 03	cmp $03bc			cmp 	LastListIndent
.018e7e	90 03		bcc $018e83			bcc 	_LISmaller
.018e80	ad bc 03	lda $03bc			lda 	LastListIndent
.018e83					_LISmaller:
.018e83	0a		asl a				asl 	a 							; double indent
.018e84	49 ff		eor #$ff			eor 	#$FF 						; 2's complement arithmetic
.018e86	38		sec				sec
.018e87	65 10		adc $10				adc 	zTemp1 						; "subtract" indent e.g. print more.
.018e89	aa		tax				tax 								; print spaces to column 6
.018e8a					_LISpace:
.018e8a	a9 20		lda #$20			lda 	#" "
.018e8c	20 60 8f	jsr $018f60			jsr 	ListPrintLC
.018e8f	e8		inx				inx
.018e90	e0 06		cpx #$06			cpx 	#6
.018e92	d0 f6		bne $018e8a			bne 	_LISpace
.018e94					_LIDecode:
.018e94	c8		iny				iny
.018e95	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018e97	c9 00		cmp #$00			cmp 	#0 							; zero, exit.
.018e99	f0 0f		beq $018eaa			beq 	_LIExit
.018e9b	30 12		bmi $018eaf			bmi 	_LIToken
.018e9d	c9 40		cmp #$40			cmp 	#$40 						; 01-$3F, character.
.018e9f	b0 50		bcs $018ef1			bcs 	_LIInteger
.018ea1	49 20		eor #$20			eor 	#$20 						; make 7 bit
.018ea3	69 20		adc #$20			adc 	#$20
.018ea5	20 60 8f	jsr $018f60			jsr 	ListPrintLC 				; print in LC
.018ea8	80 ea		bra $018e94			bra 	_LIDecode
.018eaa					_LIExit:
.018eaa	a9 0d		lda #$0d			lda 	#13 						; print new line.
.018eac	4c 60 8f	jmp $018f60			jmp 	ListPrintLC
.018eaf					_LIToken:
.018eaf	c9 fc		cmp #$fc			cmp 	#$FC 						; $FC-$FF ?
.018eb1	90 49		bcc $018efc			bcc		_LICommandToken
.018eb3	48		pha				pha 								; save in case end
.018eb4	a2 22		ldx #$22			ldx 	#'"'						; print if $FE quoted string
.018eb6	c9 fe		cmp #$fe			cmp 	#$FE
.018eb8	f0 17		beq $018ed1			beq 	_LIPrint
.018eba	a2 2e		ldx #$2e			ldx 	#'.'						; print if $FD decimals
.018ebc	c9 fd		cmp #$fd			cmp 	#$FD
.018ebe	f0 11		beq $018ed1			beq 	_LIPrint
.018ec0	a9 52		lda #$52			lda 	#'R'						; must be REM
.018ec2	20 60 8f	jsr $018f60			jsr 	ListPrintLC
.018ec5	a9 45		lda #$45			lda 	#'E'
.018ec7	20 60 8f	jsr $018f60			jsr 	ListPrintLC
.018eca	a9 4d		lda #$4d			lda 	#'M'
.018ecc	20 60 8f	jsr $018f60			jsr 	ListPrintLC
.018ecf	a2 20		ldx #$20			ldx 	#' '
.018ed1					_LIPrint:
.018ed1	8a		txa				txa
.018ed2	20 60 8f	jsr $018f60			jsr 	ListPrintLC
.018ed5	c8		iny				iny
.018ed6	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018ed8	aa		tax				tax 								; put in X
.018ed9	ca		dex				dex
.018eda					_LILoop:
.018eda	ca		dex				dex 								; exit when count reached zero.
.018edb	f0 08		beq $018ee5			beq 	_LIEnd
.018edd	c8		iny				iny
.018ede	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018ee0	20 60 8f	jsr $018f60			jsr 	ListPrintLC
.018ee3	80 f5		bra $018eda			bra 	_LILoop
.018ee5	68		pla		_LIEnd:	pla 								; get A back
.018ee6	c9 fe		cmp #$fe			cmp 	#$FE 						; if '"' need closing quotes
.018ee8	d0 aa		bne $018e94			bne 	_LIDecode
.018eea	a9 22		lda #$22			lda 	#'"'
.018eec	20 60 8f	jsr $018f60			jsr 	ListPrintLC
.018eef	80 a3		bra $018e94			bra 	_LIDecode
.018ef1					_LIInteger:
.018ef1	a2 00		ldx #$00			ldx 	#0
.018ef3	20 3e 93	jsr $01933e			jsr 	EvaluateGetInteger 			; get an atom
.018ef6	88		dey				dey
.018ef7	20 d5 85	jsr $0185d5			jsr 	Print32BitInteger 			; print integer.
.018efa	80 98		bra $018e94			bra 	_LIDecode
.018efc					_LICommandToken:
.018efc	5a		phy				phy 								; save Y
.018efd	48		pha				pha 								; save token
.018efe	a2 cd		ldx #$cd			ldx  	#KeywordText & $FF 			; address of keyword text table.
.018f00	a9 86		lda #$86			lda 	(#KeywordText >> 8) & $FF
.018f02	86 1c		stx $1c				stx 	zLTemp1
.018f04	85 1d		sta $1d				sta 	zLTemp1+1
.018f06	a9 01		lda #$01			lda 	(#KeywordText >> 16) & $FF 	; this is for 65816 (it's a table in code
.018f08	85 1e		sta $1e				sta 	zLTemp1+2 					; space) and won't affect a 6502 at all.
.018f0a	68		pla				pla 								; get token
.018f0b	29 7f		and #$7f			and 	#127 						; chuck bit 7.
.018f0d	f0 16		beq $018f25			beq 	_LIFoundToken
.018f0f	aa		tax				tax
.018f10					_LITokenLoop:
.018f10	a0 00		ldy #$00			ldy 	#0 							; last character not a token.
.018f12					_LIFindEnd:
.018f12	b7 1c		lda [$1c],y			lda 	[zLTemp1],y
.018f14	c8		iny				iny
.018f15	0a		asl a				asl 	a
.018f16	90 fa		bcc $018f12			bcc 	_LIFindEnd
.018f18	98		tya				tya 								; that is step to the next
.018f19	18		clc				clc 								; we don't bother bumping the 3rd byte
.018f1a	65 1c		adc $1c				adc 	zLTemp1 					; here.
.018f1c	85 1c		sta $1c				sta 	zLTemp1
.018f1e	90 02		bcc $018f22			bcc 	_LINoBump
.018f20	e6 1d		inc $1d				inc 	zLTemp1+1
.018f22					_LINoBump:
.018f22	ca		dex				dex 								; no go round again.
.018f23	d0 eb		bne $018f10			bne 	_LITokenLoop
.018f25					_LIFoundToken:
.018f25	a0 00		ldy #$00			ldy 	#0
.018f27					_LIPrintToken:
.018f27	b7 1c		lda [$1c],y			lda 	[zLTemp1],y
.018f29	c0 00		cpy #$00			cpy 	#0 							; see if needs prefix space
.018f2b	d0 16		bne $018f43			bne 	_LINoPrefixSpace
.018f2d	c9 41		cmp #$41			cmp 	#"A" 						; e.g. alphabetic token.
.018f2f	90 12		bcc $018f43			bcc 	_LINoPrefixSpace
.018f31	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018f33	b0 0e		bcs $018f43			bcs 	_LINoPrefixSpace
.018f35	ae ba 03	ldx $03ba			ldx 	LastPrinted 				; if last was space not required
.018f38	e0 20		cpx #$20			cpx 	#" "
.018f3a	f0 07		beq $018f43			beq 	_LINoPrefixSpace
.018f3c	48		pha				pha
.018f3d	a9 20		lda #$20			lda 	#" "
.018f3f	20 60 8f	jsr $018f60			jsr 	ListPrintLC
.018f42	68		pla				pla
.018f43					_LINoPrefixSpace:
.018f43	c8		iny				iny
.018f44	48		pha				pha 								; save it
.018f45	29 7f		and #$7f			and 	#$7F
.018f47	20 60 8f	jsr $018f60			jsr 	ListPrintLC
.018f4a	68		pla				pla
.018f4b	10 da		bpl $018f27			bpl 	_LIPrintToken 				; go back if not end
.018f4d	7a		ply				ply 								; restore Y
.018f4e	29 7f		and #$7f			and 	#$7F 						; if last char is a letter
.018f50	c9 41		cmp #$41			cmp 	#"A"
.018f52	90 09		bcc $018f5d			bcc 	_LINotLetter2
.018f54	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018f56	b0 05		bcs $018f5d			bcs 	_LINotLetter2
.018f58	a9 20		lda #$20			lda 	#" " 						; add spacing
.018f5a	20 60 8f	jsr $018f60			jsr 	ListPrintLC
.018f5d					_LINotLetter2:
.018f5d	4c 94 8e	jmp $018e94			jmp 	_LIDecode
.018f60					ListPrintLC:
.018f60	8d ba 03	sta $03ba			sta 	LastPrinted
.018f63	c9 41		cmp #$41			cmp 	#"A"
.018f65	90 06		bcc $018f6d			bcc 	_LPLC0
.018f67	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018f69	b0 02		bcs $018f6d			bcs 	_LPLC0
.018f6b	69 20		adc #$20			adc 	#$20
.018f6d	4c 3f 85	jmp $01853f	_LPLC0:	jmp 	VIOCharPrint
.018f70					ListGetRange:
.018f70	a2 0b		ldx #$0b			ldx 	#XS_Size*2-1 				; clear first 2 slots back to defaults.
.018f72					_LGRClear:
.018f72	a9 00		lda #$00			lda 	#0
.018f74	95 80		sta $80,x			sta 	XS_Mantissa,x
.018f76	ca		dex				dex
.018f77	10 f9		bpl $018f72			bpl 	_LGRClear
.018f79	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018f7b	c9 00		cmp #$00			cmp 	#0 							; nothing
.018f7d	f0 21		beq $018fa0			beq 	_LGRBlank
.018f7f	c9 c0		cmp #$c0			cmp 	#token_Colon 				; or colon
.018f81	f0 1d		beq $018fa0			beq 	_LGRBlank
.018f83	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma
.018f85	f0 18		beq $018f9f			beq 	_LGREnd 					; then it's LIST ,x
.018f87	20 a1 93	jsr $0193a1			jsr 	EvaluateInteger 			; get the first number into bottom
.018f8a	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018f8c	c9 bf		cmp #$bf			cmp 	#token_Comma
.018f8e	f0 0f		beq $018f9f			beq 	_LGREnd 					; then it is LIST a,b
.018f90	a5 80		lda $80				lda 	XS_Mantissa+0 				; copy first to second LIST n is n,n
.018f92	85 86		sta $86				sta 	XS_Mantissa+XS_Size+0
.018f94	a5 81		lda $81				lda 	XS_Mantissa+1
.018f96	85 87		sta $87				sta 	XS_Mantissa+XS_Size+1
.018f98					_LGRBumpExit:
.018f98	e6 86		inc $86				inc 	XS_Mantissa+XS_Size 		; bump it so we can use cc.
.018f9a	d0 02		bne $018f9e			bne 	_LGRBump2
.018f9c	e6 87		inc $87				inc 	XS_Mantissa+XS_Size+1
.018f9e					_LGRBump2:
.018f9e	60		rts				rts
.018f9f					_LGREnd:
.018f9f	c8		iny				iny
.018fa0					_LGRBlank:
.018fa0	a9 ff		lda #$ff			lda 	#$FF 						; default to the end.
.018fa2	85 86		sta $86				sta 	XS_Mantissa+XS_Size
.018fa4	85 87		sta $87				sta 	XS_Mantissa+XS_Size+1
.018fa6	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018fa8	c9 00		cmp #$00			cmp 	#0
.018faa	f0 f2		beq $018f9e			beq 	_LGRBump2
.018fac	0a		asl a				asl 	a 							; if not a number, then exit (to end)
.018fad	b0 ef		bcs $018f9e			bcs 	_LGRBump2
.018faf	a2 06		ldx #$06			ldx 	#XS_Size 					; get to range
.018fb1	20 a3 93	jsr $0193a3			jsr 	EvaluateIntegerX
.018fb4	80 e2		bra $018f98			bra 	_LGRBumpExit
.018fb6	60		rts				rts
.018fb7					ListCheckRange:
.018fb7	c8		iny				iny
.018fb8	a2 00		ldx #$00			ldx 	#0 							; test low
.018fba	20 c7 8f	jsr $018fc7			jsr 	_LCRCompare
.018fbd	90 06		bcc $018fc5			bcc 	_LCRFail
.018fbf	a2 06		ldx #$06			ldx 	#XS_Size 					; test high
.018fc1	20 c7 8f	jsr $018fc7			jsr 	_LCRCompare
.018fc4	60		rts				rts
.018fc5					_LCRFail:
.018fc5	38		sec				sec
.018fc6	60		rts				rts
.018fc7					_LCRCompare:
.018fc7	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018fc9	38		sec				sec
.018fca	f5 80		sbc $80,x			sbc	 	XS_Mantissa+0,x
.018fcc	08		php				php
.018fcd	c8		iny				iny
.018fce	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018fd0	28		plp				plp
.018fd1	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.018fd3	08		php				php
.018fd4	88		dey				dey
.018fd5	28		plp				plp
.018fd6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/print.asm

.018fd7					Command_PRINT:
.018fd7					_CPR_Loop:
.018fd7	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018fd9	c9 00		cmp #$00			cmp 	#0 							; end
.018fdb	f0 21		beq $018ffe			beq 	_CPR_GoNewLine
.018fdd	c9 c0		cmp #$c0			cmp 	#token_Colon
.018fdf	f0 1d		beq $018ffe			beq 	_CPR_GoNewLine
.018fe1	c9 c1		cmp #$c1			cmp 	#token_SemiColon
.018fe3	f0 71		beq $019056			beq 	_CPR_Skip
.018fe5	c9 bf		cmp #$bf			cmp 	#token_Comma
.018fe7	f0 54		beq $01903d			beq 	_CPR_Tab
.018fe9	20 39 92	jsr $019239			jsr 	EvaluateExpression 			; get expression.
.018fec	a5 85		lda $85				lda 	XS_Type 					; get type.
.018fee	29 02		and #$02			and 	#2
.018ff0	d0 24		bne $019016			bne 	_CPR_String 				; if type = 2 output as string.
.018ff2					_CPR_Number:
.018ff2	a9 00		lda #$00			lda 	#0 							; reset buffer index
.018ff4	8d 14 03	sta $0314			sta 	NumBufX
.018ff7	a5 85		lda $85				lda 	XS_Type 					; get type
.018ff9	4a		lsr a				lsr 	a
.018ffa	b0 05		bcs $019001			bcs 	_CPRInt 					; if msb set do as integer
.018ffc	80 06		bra $019004			bra 	_CPRNPrint
.018ffe					_CPR_GoNewLine:
.018ffe	4c 64 90	jmp $019064			jmp 	_CPR_NewLine
.019001	20 44 a1	jsr $01a144	_CPRInt:jsr 	IntToString
.019004					_CPRNPrint:
.019004	ad 15 03	lda $0315			lda 	Num_Buffer 					; is first character -
.019007	c9 2d		cmp #$2d			cmp 	#"-"
.019009	f0 05		beq $019010			beq 	_CPRNoSpace
.01900b	a9 20		lda #$20			lda 	#" "						; print the leading space
.01900d	20 3f 85	jsr $01853f			jsr 	VIOCharPrint 				; so beloved of MS Basics.
.019010					_CPRNoSpace:
.019010	a2 14		ldx #$14			ldx 	#(Num_Buffer-1) & $FF
.019012	a9 03		lda #$03			lda 	#(Num_Buffer-1) >> 8
.019014	80 04		bra $01901a			bra 	_CPRPrint
.019016					_CPR_String:
.019016	a6 80		ldx $80				ldx 	XS_Mantissa
.019018	a5 81		lda $81				lda 	XS_Mantissa+1
.01901a					_CPRPrint:
.01901a	86 20		stx $20				stx 	zGenPtr
.01901c	85 21		sta $21				sta 	zGenPtr+1
.01901e	5a		phy				phy
.01901f	a0 00		ldy #$00			ldy 	#0							; get length into X
.019021	b1 20		lda ($20),y			lda 	(zGenPtr),y
.019023	aa		tax				tax
.019024	f0 09		beq $01902f			beq 	_CPREndPrint 				; nothing to print
.019026					_CPRLoop:
.019026	c8		iny				iny
.019027	b1 20		lda ($20),y			lda 	(zGenPtr),y
.019029	20 3f 85	jsr $01853f			jsr 	VIOCharPrint
.01902c	ca		dex				dex
.01902d	d0 f7		bne $019026			bne 	_CPRLoop
.01902f					_CPREndPrint:
.01902f	a5 85		lda $85				lda 	XS_Type 					; if numeric add trailing space
.019031	29 02		and #$02			and 	#2
.019033	d0 05		bne $01903a			bne 	_CPRNoTrail
.019035	a9 20		lda #$20			lda 	#" "
.019037	20 3f 85	jsr $01853f			jsr 	VIOCharPrint
.01903a					_CPRNoTrail:
.01903a	7a		ply				ply
.01903b	80 9a		bra $018fd7			bra 	_CPR_Loop
.01903d					_CPR_Tab:
.01903d	20 50 85	jsr $018550			jsr 	VIOCharGetPosition 			; print until position % 8 = 0
.019040					_CPR_CalcSpaces:
.019040	38		sec				sec 								; calculate position mod 10.
.019041	e9 0a		sbc #$0a			sbc 	#10
.019043	b0 fb		bcs $019040			bcs 	_CPR_CalcSpaces
.019045	69 0a		adc #$0a			adc 	#10
.019047	f0 0d		beq $019056			beq 	_CPR_Skip 					; nothing to print
.019049	aa		tax				tax 								; print out spaces to mod 10
.01904a					_CPRTabSpaces:
.01904a	a9 20		lda #$20			lda 	#" "
.01904c	20 3f 85	jsr $01853f			jsr 	VIOCharPrint
.01904f	e8		inx				inx
.019050	e0 0a		cpx #$0a			cpx 	#10
.019052	d0 f6		bne $01904a			bne 	_CPRTabSpaces
.019054	80 e7		bra $01903d			bra 	_CPR_Tab
.019056					_CPR_Skip:
.019056	c8		iny				iny
.019057	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019059	c9 c0		cmp #$c0			cmp 	#token_Colon 				; colon or $00, exit
.01905b	f0 0c		beq $019069			beq 	_CPR_Exit
.01905d	c9 00		cmp #$00			cmp 	#0
.01905f	f0 08		beq $019069			beq 	_CPR_Exit 					; if not go round again.
.019061	4c d7 8f	jmp $018fd7			jmp 	_CPR_Loop
.019064					_CPR_NewLine:
.019064	a9 0d		lda #$0d			lda 	#13
.019066	20 3f 85	jsr $01853f			jsr 	VIOCharPrint
.019069					_CPR_Exit:
.019069	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/assert.asm

.01906a					Command_ASSERT:
.01906a	20 a1 93	jsr $0193a1			jsr 	EvaluateInteger 			; calculate thing being asserted, 0=>X
.01906d	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; check if true (non-zero)
.01906f	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019071	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019073	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019075	f0 01		beq $019078			beq 	_ASFail
.019077	60		rts				rts
.019078					_ASFail:
.019078	20 86 85	jsr $018586			jsr ERR_Handler
>01907b	41 73 73 65 72 74 00			.text "Assert",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/poke.asm

.019082					Command_POKE:
.019082	a9 01		lda #$01			lda 	#1 							; 1 byte
.019084	80 06		bra $01908c			bra 	CmdPoke_Main
.019086					Command_DOKE:
.019086	a9 02		lda #$02			lda 	#2 							; 2 bytes
.019088	80 02		bra $01908c			bra 	CmdPoke_Main
.01908a					Command_LOKE:
.01908a	a9 04		lda #$04			lda 	#4							; 4 bytes
.01908c					CmdPoke_Main:
.01908c	48		pha				pha
.01908d	20 a1 93	jsr $0193a1			jsr 	EvaluateInteger 			; get two parameters. First is address
.019090	e8		inx				inx
.019091	e8		inx				inx
.019092	e8		inx				inx
.019093	e8		inx				inx
.019094	e8		inx				inx
.019095	e8		inx				inx
.019096	20 af 99	jsr $0199af			jsr 	CheckNextComma
.019099	20 a3 93	jsr $0193a3			jsr 	EvaluateIntegerX 			; second is the data.
.01909c	a5 80		lda $80				lda 	XS_Mantissa+0 				; copy the mantissa into ZLTemp1 (address)
.01909e	85 1c		sta $1c				sta 	zLTemp1
.0190a0	a5 81		lda $81				lda 	XS_Mantissa+1
.0190a2	85 1d		sta $1d				sta 	zLTemp1+1
.0190a4	a5 82		lda $82				lda 	XS_Mantissa+2
.0190a6	85 1e		sta $1e				sta 	zLTemp1+2
.0190a8	a5 83		lda $83				lda 	XS_Mantissa+3
.0190aa	85 1f		sta $1f				sta 	zLTemp1+3
.0190ac	68		pla				pla 								; get count
.0190ad	5a		phy				phy 								; save Y
.0190ae	20 3a 99	jsr $01993a			jsr 	MemWrite 					; write it out
.0190b1	7a		ply				ply 								; restore Y and done.
.0190b2	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/newold.asm

.0190b3					Command_NEW:
.0190b3	a9 00		lda #$00			lda 	#(BasicProgram) & $FF
.0190b5	85 18		sta $18				sta 	zCodePtr+0
.0190b7	a9 10		lda #$10			lda 	#((BasicProgram) >> 8)
.0190b9	85 19		sta $19				sta 	zCodePtr+1
.0190bb	a9 00		lda #$00			lda 	#(BasicProgram) >> 16
.0190bd	85 1a		sta $1a				sta 	zCodePtr+2
.0190bf	85 1b		sta $1b				sta 	zCodePtr+3
.0190c1	a0 03		ldy #$03			ldy 	#3
.0190c3	a0 00		ldy #$00			ldy 	#0
.0190c5	a9 00		lda #$00			lda 	#0 							; write a 0 there, null first offset
.0190c7	97 18		sta [$18],y			sta 	[zCodePtr],y
.0190c9	20 4b 99	jsr $01994b			jsr 	UpdateProgramEnd 			; update program end.
.0190cc	4c 4d 88	jmp $01884d			jmp 	WarmStart 					; and always warmstart, can't be running program.
.0190cf					Command_OLD:
.0190cf	a9 00		lda #$00			lda 	#(BasicProgram) & $FF
.0190d1	85 18		sta $18				sta 	zCodePtr+0
.0190d3	a9 10		lda #$10			lda 	#((BasicProgram) >> 8)
.0190d5	85 19		sta $19				sta 	zCodePtr+1
.0190d7	a9 00		lda #$00			lda 	#(BasicProgram) >> 16
.0190d9	85 1a		sta $1a				sta 	zCodePtr+2
.0190db	85 1b		sta $1b				sta 	zCodePtr+3
.0190dd	a0 03		ldy #$03			ldy 	#3
.0190df					_COL_Find:
.0190df	b7 18		lda [$18],y			lda 	[zCodePtr],y
.0190e1	c8		iny				iny
.0190e2	c9 00		cmp #$00			cmp 	#0 							; if zero, then the position Y/Z is new offset
.0190e4	f0 18		beq $0190fe			beq 	_COL_Found
.0190e6	98		tya				tya
.0190e7	c9 00		cmp #$00			cmp 	#0 							; e.g. there is no program line end.
.0190e9	d0 f4		bne $0190df			bne 	_COL_Find 					; can't find old EOL, give up.
.0190eb	20 86 85	jsr $018586			jsr ERR_Handler
>0190ee	50 72 6f 67 72 61 6d 20			.text "Program Corrupt",0
>0190f6	43 6f 72 72 75 70 74 00
.0190fe					_COL_Found:
.0190fe	98		tya				tya
.0190ff	48		pha				pha
.019100	a0 00		ldy #$00			ldy 	#0
.019102	68		pla				pla
.019103	97 18		sta [$18],y			sta 	[zCodePtr],y
.019105	20 4b 99	jsr $01994b			jsr 	UpdateProgramEnd 			; reset variable pointer
.019108	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/branch.asm

.019109					Command_GOTO:
.019109	20 5e 91	jsr $01915e			jsr 	GotoGetLineNumber 			; get line number
.01910c					CmdGOTO:
.01910c	a2 00		ldx #$00			ldx 	#0 							; go to that line number
.01910e	4c 7b 91	jmp $01917b			jmp 	GotoChangeToLineNumberX
.019111					Command_GOSUB:
.019111	20 5e 91	jsr $01915e			jsr 	GotoGetLineNumber 			; get line number
.019114					CmdGOSUB:
.019114	20 06 85	jsr $018506			jsr 	StackSavePosition 			; save position on stack and push frame
.019117	a9 15		lda #$15			lda 	#(SMark_Gosub << 4)+SourcePosSize
.019119	20 bf 84	jsr $0184bf			jsr 	StackPushFrame
.01911c	a2 00		ldx #$00			ldx		#0 							; go to that line number
.01911e	4c 7b 91	jmp $01917b			jmp 	GotoChangeToLineNumberX
.019121					Command_RETURN:
.019121	a9 10		lda #$10			lda 	#(SMark_Gosub << 4) 		; pop frame
.019123	20 d6 84	jsr $0184d6			jsr 	StackPopFrame
.019126	20 23 85	jsr $018523			jsr 	StackRestorePosition 		; restore position.
.019129	60		rts				rts
.01912a					Command_ON:
.01912a	a2 00		ldx #$00			ldx 	#0 							; get the ON value into mantissa.0
.01912c	20 fd 97	jsr $0197fd			jsr 	SLIByteParameter
.01912f	a5 80		lda $80				lda 	XS_Mantissa+0 				; get the count
.019131	f0 28		beq $01915b			beq 	_CONFail 					; can't be zero, error if it is.
.019133	aa		tax				tax 								; save in X.
.019134	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019136	c8		iny				iny
.019137	48		pha				pha 								; so we can check what we're doing later.
.019138	c9 cc		cmp #$cc			cmp 	#token_GOTO 				; must be GOTO or GOSUB
.01913a	f0 07		beq $019143			beq 	_CONOkayToken
.01913c	c9 ca		cmp #$ca			cmp 	#token_GOSUB
.01913e	f0 03		beq $019143			beq 	_CONOkayToken
.019140	4c 57 85	jmp $018557			jmp 	SyntaxError
.019143					_CONOkayToken:
.019143	da		phx				phx 								; count on top, GOTO/GOSUB token 2nd.
.019144					_CONFindNumber:
.019144	20 5e 91	jsr $01915e			jsr 	GotoGetLineNumber 			; get a line number.
.019147	fa		plx				plx 								; restore count
.019148	ca		dex				dex  								; decrement, exit if zero.
.019149	f0 06		beq $019151			beq 	_CONFound
.01914b	da		phx				phx 								; push back
.01914c	20 af 99	jsr $0199af			jsr 	CheckNextComma				; check for comma
.01914f	80 f3		bra $019144			bra 	_CONFindNumber 				; go round again.
.019151					_CONFound:
.019151	68		pla				pla 								; get token to decide what to do
.019152	c9 cc		cmp #$cc			cmp 	#token_GOTO 				; if GOTO
.019154	f0 b6		beq $01910c			beq		CmdGOTO 					; then just branch.
.019156	20 8d 84	jsr $01848d			jsr 	SkipEndOfCommand 			; go to end of command
.019159	80 b9		bra $019114			bra 	CmdGOSUB 					; and do a GOSUB.
.01915b					_CONFail:
.01915b	4c 75 85	jmp $018575			jmp 	BadParamError
.01915e					GotoGetLineNumber:
.01915e	20 a1 93	jsr $0193a1			jsr 	EvaluateInteger 			; get integer into mantissa.0
.019161	a5 82		lda $82				lda 	XS_Mantissa+2 				; check range
.019163	05 83		ora $83				ora 	XS_Mantissa+3 				; check it is 0-32767
.019165	d0 01		bne $019168			bne 	_GLINError
.019167	60		rts				rts
.019168					_GLINError:
.019168	20 86 85	jsr $018586			jsr ERR_Handler
>01916b	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>019173	20 4e 75 6d 62 65 72 00
.01917b					GotoChangeToLineNumberX:
.01917b	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check line number not zero
.01917d	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.01917f	f0 37		beq $0191b8			beq 	_GCTLFail 					; if so, no can do.
.019181	a9 00		lda #$00			lda 	#(BasicProgram) & $FF
.019183	85 18		sta $18				sta 	zCodePtr+0
.019185	a9 10		lda #$10			lda 	#((BasicProgram) >> 8)
.019187	85 19		sta $19				sta 	zCodePtr+1
.019189	a9 00		lda #$00			lda 	#(BasicProgram) >> 16
.01918b	85 1a		sta $1a				sta 	zCodePtr+2
.01918d	85 1b		sta $1b				sta 	zCodePtr+3
.01918f	a0 03		ldy #$03			ldy 	#3
.019191					_GCTLLoop:
.019191	a0 00		ldy #$00			ldy 	#0
.019193	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019195	c9 00		cmp #$00			cmp 	#0
.019197	f0 1f		beq $0191b8			beq 	_GCTLFail
.019199	c8		iny				iny
.01919a	b7 18		lda [$18],y			lda 	[zCodePtr],y
.01919c	d5 80		cmp $80,x			cmp 	XS_Mantissa+0,x
.01919e	d0 07		bne $0191a7			bne 	_GCTLNext
.0191a0	c8		iny				iny
.0191a1	b7 18		lda [$18],y			lda 	[zCodePtr],y
.0191a3	d5 81		cmp $81,x			cmp 	XS_Mantissa+1,x
.0191a5	f0 0f		beq $0191b6			beq 	_GCTLExit
.0191a7					_GCTLNext:
.0191a7	a0 00		ldy #$00			ldy 	#0 							; point to offset
.0191a9	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read it
.0191ab	18		clc				clc
.0191ac	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.0191ae	85 18		sta $18				sta 	zCodePtr
.0191b0	90 02		bcc $0191b4			bcc 	_SNLNoCarry
.0191b2	e6 19		inc $19				inc 	zCodePtr+1
.0191b4					_SNLNoCarry:
.0191b4	80 db		bra $019191			bra 	_GCTLLoop 					; try next line.
.0191b6					_GCTLExit:
.0191b6	c8		iny				iny
.0191b7	60		rts				rts
.0191b8					_GCTLFail:
.0191b8	20 86 85	jsr $018586			jsr ERR_Handler
>0191bb	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>0191c3	20 4e 75 6d 62 65 72 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.0191cb					Command_CLR:
.0191cb					ResetRunStatus:
.0191cb	20 a8 9c	jsr $019ca8			jsr 	VariableClear
.0191ce	20 ad 84	jsr $0184ad			jsr 	StackReset
.0191d1	a9 00		lda #$00			lda 	#HighMemory & $FF
.0191d3	8d 00 03	sta $0300			sta 	StringPtr
.0191d6	a9 7f		lda #$7f			lda 	#HighMemory >> 8
.0191d8	8d 01 03	sta $0301			sta 	StringPtr+1
.0191db	20 74 9e	jsr $019e74			jsr 	ArrayResetDefault
.0191de	20 2c 8b	jsr $018b2c			jsr 	Command_RESTORE
.0191e1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/stop.asm

.0191e2					Command_STOP:
.0191e2	20 86 85	jsr $018586			jsr ERR_Handler
>0191e5	53 74 6f 70 00				.text "Stop",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/while.asm

.0191ea					Command_WHILE:
.0191ea	20 06 85	jsr $018506			jsr 	StackSavePosition			; save position into stack, but don't yet push.
.0191ed	20 a1 93	jsr $0193a1			jsr 	EvaluateInteger 			; calculate the while loop value.
.0191f0	a5 80		lda $80				lda 	XS_Mantissa+0				; check the result if zero
.0191f2	05 81		ora $81				ora 	XS_Mantissa+1
.0191f4	05 82		ora $82				ora 	XS_Mantissa+2
.0191f6	05 83		ora $83				ora 	XS_Mantissa+3
.0191f8	f0 06		beq $019200			beq 	_CWHSkip 					; if it is zero, then skip to WEND.
.0191fa	a9 35		lda #$35			lda 	#(SMark_While << 4)+SourcePosSize
.0191fc	20 bf 84	jsr $0184bf			jsr 	StackPushFrame 				; push on stack
.0191ff	60		rts				rts
.019200					_CWHSkip:
.019200	a9 95		lda #$95			lda 	#token_Wend 				; look for the WEND token.
.019202	20 00 84	jsr $018400			jsr 	StructureSearchSingle
.019205	c8		iny				iny
.019206	60		rts				rts
.019207					Command_WEND:
.019207	a9 30		lda #$30			lda 	#(SMark_While << 4)			; remove the frame
.019209	20 d6 84	jsr $0184d6			jsr 	StackPopFrame
.01920c	20 23 85	jsr $018523			jsr 	StackRestorePosition
.01920f	80 d9		bra $0191ea			bra 	Command_WHILE 				; and do the while again.
.019211	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/repeat.asm

.019212					Command_REPEAT:
.019212	20 06 85	jsr $018506			jsr 	StackSavePosition			; save position into stack
.019215	a9 25		lda #$25			lda 	#(SMark_Repeat << 4)+SourcePosSize
.019217	20 bf 84	jsr $0184bf			jsr 	StackPushFrame 				; push on stack
.01921a	60		rts				rts
.01921b					Command_UNTIL:
.01921b	a9 20		lda #$20			lda 	#(SMark_Repeat << 4)		; remove the frame, checking it.
.01921d	20 d6 84	jsr $0184d6			jsr 	StackPopFrame
.019220	20 a1 93	jsr $0193a1			jsr 	EvaluateInteger				; work out the UNTIL expression.
.019223	a5 80		lda $80				lda 	XS_Mantissa+0 				; check if zero.
.019225	05 81		ora $81				ora 	XS_Mantissa+1
.019227	05 82		ora $82				ora 	XS_Mantissa+2
.019229	05 83		ora $83				ora 	XS_Mantissa+3
.01922b	d0 08		bne $019235			bne 	_CUTExit 					; if not, just exit
.01922d	20 23 85	jsr $018523			jsr 	StackRestorePosition 		; otherwise loop round again.
.019230	a9 25		lda #$25			lda 	#(SMark_Repeat << 4)+SourcePosSize
.019232	20 bf 84	jsr $0184bf			jsr 	StackPushFrame 				; fix the stack back so we can pop it again.
.019235					_CUTExit:
.019235	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.019236					EVESyntax:
.019236	4c 57 85	jmp $018557			jmp 	SyntaxError
.019239					EvaluateExpression:
.019239	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.01923b					EvaluateExpressionX:
.01923b	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.01923d					EvaluateExpressionXA:
.01923d	48		pha				pha 								; save precedence on stack.
.01923e	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019240	f0 f4		beq $019236			beq 	EVESyntax 					; end of line, syntax error.
.019242	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.019244	b0 03		bcs $019249			bcs 	_EVNotVariable
.019246	4c 10 93	jmp $019310			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.019249					_EVNotVariable:
.019249	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.01924b	90 e9		bcc $019236			bcc 	EVESyntax
.01924d	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.01924f	b0 58		bcs $0192a9			bcs 	_EVNotInteger
.019251	20 3e 93	jsr $01933e			jsr 	EvaluateGetInteger
.019254					_EVCheckDecimal:
.019254	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019256	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.019258	d0 05		bne $01925f			bne 	_EVGotAtom 					; no, get atom.
.01925a					_EVIsDecimal:
.01925a	20 64 93	jsr $019364			jsr 	EVGetDecimal 				; extend to the decimal part.
.01925d	80 00		bra $01925f			bra 	_EVGotAtom 					; and continue to got atom.
.01925f					_EVGotAtom:
.01925f	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019261	10 44		bpl $0192a7			bpl 	_EVExitDrop 				; must be a token.
.019263	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.019265	b0 40		bcs $0192a7			bcs 	_EVExitDrop
.019267	68		pla				pla 								; get current precedence
.019268	85 20		sta $20				sta 	zGenPtr 					; save in zGenPtr as temp.
.01926a	da		phx				phx 								; save X
.01926b	b7 18		lda [$18],y			lda 	[zCodePtr],y
.01926d	aa		tax				tax 								; put in X
.01926e	bf 3e 86 01	lda $01863e,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.019272	85 21		sta $21				sta 	zGenPtr+1 					; save it.
.019274	fa		plx				plx 								; restore X
.019275	c5 20		cmp $20				cmp 	zGenPtr 					; compared against the current precedence
.019277	90 2f		bcc $0192a8			bcc 	_EVExit 					; exit if too low.
.019279	f0 2d		beq $0192a8			beq 	_EVExit 					; exit if equals
.01927b	a5 20		lda $20				lda 	zGenPtr 					; push precedence
.01927d	48		pha				pha
.01927e	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019280	48		pha				pha
.019281	c8		iny				iny
.019282	da		phx				phx 								; save current position
.019283	e8		inx				inx
.019284	e8		inx				inx
.019285	e8		inx				inx
.019286	e8		inx				inx
.019287	e8		inx				inx
.019288	e8		inx				inx
.019289	a5 21		lda $21				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.01928b	20 3d 92	jsr $01923d			jsr 	EvaluateExpressionXA 		; do the RHS.
.01928e	fa		plx				plx 								; restore X
.01928f	68		pla				pla 								; get the binary operator in A.
.019290					_EVCallA:
.019290	da		phx				phx 								; save X again
.019291	0a		asl a				asl 	a 							; double, lose the MSB.
.019292	aa		tax				tax									; put in X
.019293	bf ed 85 01	lda $0185ed,x			lda 	VectorTable,x 				; copy address into zGenPtr
.019297	8d 11 03	sta $0311			sta 	LocalVector+1
.01929a	bf ee 85 01	lda $0185ee,x			lda 	VectorTable+1,x
.01929e	8d 12 03	sta $0312			sta 	LocalVector+2
.0192a1	fa		plx				plx 								; restore X
.0192a2	20 19 93	jsr $019319			jsr 	EVCallLocalVector
.0192a5	80 b8		bra $01925f			bra 	_EVGotAtom 					; and loop back.
.0192a7					_EVExitDrop:
.0192a7	68		pla				pla
.0192a8					_EVExit:
.0192a8	60		rts				rts
.0192a9					_EVNotInteger:
.0192a9	c8		iny				iny
.0192aa	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.0192ac	d0 16		bne $0192c4			bne 	_EVNotMinus
.0192ae	20 82 93	jsr $019382			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.0192b1	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.0192b3	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.0192b5	f0 05		beq $0192bc			beq 	_EVMinusFloat
.0192b7	20 27 a1	jsr $01a127			jsr 	IntegerNegateAlways 		; negation
.0192ba	80 a3		bra $01925f			bra 	_EVGotAtom 					; and go back.
.0192bc					_EVMinusFloat:
.0192bc	b5 85		lda $85,x			lda 	XS_Type,x 					; invert the sign bit.
.0192be	49 80		eor #$80			eor 	#$80
.0192c0	95 85		sta $85,x			sta 	XS_Type,x
.0192c2	80 9b		bra $01925f			bra 	_EVGotAtom
.0192c4					_EVNotMinus:
.0192c4	c9 bd		cmp #$bd			cmp 	#token_lparen 				; is it left parenthesis
.0192c6	d0 17		bne $0192df			bne 	_EVNotParenthesis
.0192c8	20 3b 92	jsr $01923b			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.0192cb	b7 18		lda [$18],y			lda 	[zCodePtr],y
.0192cd	c8		iny				iny
.0192ce	c9 be		cmp #$be			cmp 	#token_rparen 				; okay if right bracket.
.0192d0	f0 8d		beq $01925f			beq 	_EVGotAtom
.0192d2	20 86 85	jsr $018586			jsr ERR_Handler
>0192d5	4d 69 73 73 69 6e 67 20			.text "Missing )",0
>0192dd	29 00
.0192df					_EVNotParenthesis:
.0192df	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.0192e1	d0 09		bne $0192ec			bne 	_EVNotNot
.0192e3	20 82 93	jsr $019382			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.0192e6	20 67 93	jsr $019367			jsr 	NotInteger 					; do the not calculation
.0192e9	4c 5f 92	jmp $01925f			jmp 	_EVGotAtom
.0192ec					_EVNotNot:
.0192ec	c9 fe		cmp #$fe			cmp 	#$FE
.0192ee	d0 12		bne $019302			bne 	_EVNotString
.0192f0	20 2f 9a	jsr $019a2f			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.0192f3	a5 22		lda $22				lda 	zTempStr 					; copy address of string into mantissa
.0192f5	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0192f7	a5 23		lda $23				lda 	zTempStr+1
.0192f9	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0192fb	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.0192fd	95 85		sta $85,x			sta 	XS_Type,x
.0192ff	4c 5f 92	jmp $01925f			jmp 	_EVGotAtom
.019302					_EVNotString:
.019302	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.019304	90 04		bcc $01930a			bcc 	_EVBadElement
.019306	c9 b7		cmp #$b7			cmp 	#lastUnaryFunction+1
.019308	90 03		bcc $01930d			bcc 	_EVUnaryFunction
.01930a					_EVBadElement:
.01930a	4c 57 85	jmp $018557			jmp 	SyntaxError
.01930d					_EVUnaryFunction:
.01930d	4c 90 92	jmp $019290			jmp 	_EVCallA
.019310					_EVVariableHandler:
.019310	20 6c 9c	jsr $019c6c			jsr 	VariableFind 				; locate a variable
.019313	20 b6 9f	jsr $019fb6			jsr 	VariableGet 				; copy into memory.
.019316	4c 5f 92	jmp $01925f			jmp 	_EVGotAtom 					; and go round.
.019319					EVCallLocalVector:
.019319	6c 11 03	jmp ($0311)			jmp 	(LocalVector+1)
.01931c					EVShiftMantissaLeft6:
.01931c	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.01931e	95 84		sta $84,x			sta 	XS_Exponent,x
.019320	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019322	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019324	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019326	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019328	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01932a	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01932c	a9 00		lda #$00			lda 	#0
.01932e	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019330	20 33 93	jsr $019333			jsr 	_EVSMLShift 					; call it here to do it twice
.019333					_EVSMLShift:
.019333	56 84		lsr $84,x			lsr 	XS_Exponent,x
.019335	76 83		ror $83,x			ror 	XS_Mantissa+3,x
.019337	76 82		ror $82,x			ror 	XS_Mantissa+2,x
.019339	76 81		ror $81,x			ror 	XS_Mantissa+1,x
.01933b	76 80		ror $80,x			ror 	XS_Mantissa+0,x
.01933d	60		rts				rts
.01933e					EvaluateGetInteger:
.01933e	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019340	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.019342	95 80		sta $80,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.019344	a9 00		lda #$00			lda 	#0
.019346	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019348	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01934a	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01934c	1a		inc a				inc 	a 							; set to type 1 (integer)
.01934d	95 85		sta $85,x			sta 	XS_Type,x
.01934f					_EVCheckNextInteger:
.01934f	c8		iny				iny
.019350	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019352	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.019354	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.019356	b0 0b		bcs $019363			bcs 	_EVEndInteger
.019358	48		pha				pha 								; save it.
.019359	20 1c 93	jsr $01931c			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.01935c	68		pla				pla
.01935d	15 80		ora $80,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.01935f	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019361	80 ec		bra $01934f			bra 	_EVCheckNextInteger
.019363					_EVEndInteger:
.019363	60		rts				rts
.019364					EVGetDecimal:
.019364	4c 57 85	jmp $018557			jmp 	SyntaxError
.019367					NotInteger:
.019367	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019369	49 ff		eor #$ff			eor 	#$FF
.01936b	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01936d	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01936f	49 ff		eor #$ff			eor 	#$FF
.019371	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019373	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019375	49 ff		eor #$ff			eor 	#$FF
.019377	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019379	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01937b	49 ff		eor #$ff			eor 	#$FF
.01937d	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01937f	60		rts				rts
.019380					EvaluateGetAtom:
.019380	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.019382					EvaluateGetAtomX:
.019382	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.019384	20 3d 92	jsr $01923d			jsr 	EvaluateExpressionXA
.019387	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.019389	29 0f		and #$0f			and 	#15
.01938b	c9 02		cmp #$02			cmp 	#2
.01938d	b0 01		bcs $019390			bcs 	EvaluateType
.01938f	60		rts				rts
.019390					EvaluateType:
.019390	4c 67 85	jmp $018567			jmp 	TypeError
.019393					EvaluateNumber:
.019393	a2 00		ldx #$00			ldx 	#0
.019395					EvaluateNumberX:
.019395	20 3b 92	jsr $01923b			jsr 	EvaluateExpressionX
.019398	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0/1
.01939a	29 0f		and #$0f			and 	#15
.01939c	c9 02		cmp #$02			cmp 	#2
.01939e	b0 f0		bcs $019390			bcs 	EvaluateType
.0193a0	60		rts				rts
.0193a1					EvaluateInteger:
.0193a1	a2 00		ldx #$00			ldx 	#0
.0193a3					EvaluateIntegerX:
.0193a3	20 95 93	jsr $019395			jsr 	EvaluateNumberX
.0193a6	60		rts				rts
.0193a7					EvaluateString:
.0193a7	a2 00		ldx #$00			ldx 	#0
.0193a9					EvaluateStringX:
.0193a9	20 3b 92	jsr $01923b			jsr 	EvaluateExpressionX
.0193ac	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 2
.0193ae	29 0f		and #$0f			and 	#15
.0193b0	c9 02		cmp #$02			cmp 	#2
.0193b2	d0 dc		bne $019390			bne 	EvaluateType
.0193b4	b5 80		lda $80,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.0193b6	85 20		sta $20				sta 	zGenPtr
.0193b8	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0193ba	85 21		sta $21				sta 	zGenPtr+1
.0193bc	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.0193bd					BinaryOp_And:
.0193bd	20 11 94	jsr $019411			jsr 	BinaryMakeBothInteger
.0193c0	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.0193c2	35 86		and $86,x			and 	XS2_Mantissa+0,x
.0193c4	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0193c6	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.0193c8	35 87		and $87,x			and 	XS2_Mantissa+1,x
.0193ca	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0193cc	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.0193ce	35 88		and $88,x			and 	XS2_Mantissa+2,x
.0193d0	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0193d2	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.0193d4	35 89		and $89,x			and 	XS2_Mantissa+3,x
.0193d6	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0193d8	60		rts				rts
.0193d9					BinaryOp_Or:
.0193d9	20 11 94	jsr $019411			jsr 	BinaryMakeBothInteger
.0193dc	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.0193de	15 86		ora $86,x			ora 	XS2_Mantissa+0,x
.0193e0	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0193e2	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.0193e4	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.0193e6	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0193e8	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.0193ea	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.0193ec	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0193ee	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.0193f0	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.0193f2	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0193f4	60		rts				rts
.0193f5					BinaryOp_Eor:
.0193f5					BinaryOp_Xor:
.0193f5	20 11 94	jsr $019411			jsr 	BinaryMakeBothInteger
.0193f8	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.0193fa	55 86		eor $86,x			eor 	XS2_Mantissa+0,x
.0193fc	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0193fe	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.019400	55 87		eor $87,x			eor 	XS2_Mantissa+1,x
.019402	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019404	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.019406	55 88		eor $88,x			eor 	XS2_Mantissa+2,x
.019408	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01940a	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.01940c	55 89		eor $89,x			eor 	XS2_Mantissa+3,x
.01940e	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019410	60		rts				rts
.019411					BinaryMakeBothInteger:
.019411	da		phx				phx 								; save X
.019412	e8		inx				inx
.019413	e8		inx				inx
.019414	e8		inx				inx
.019415	e8		inx				inx
.019416	e8		inx				inx
.019417	e8		inx				inx
.019418	20 1c 94	jsr $01941c			jsr 	BinaryMakeInteger 			; convert to integer.
.01941b	fa		plx				plx 								; restore X and fall through.
.01941c					BinaryMakeInteger:
.01941c	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.01941e	29 0f		and #$0f			and 	#15 						; check type zero
.019420	f0 04		beq $019426			beq 	_BMIConvert 				; if float convert to integer.
.019422	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.019423	90 01		bcc $019426			bcc 	_BMIError
.019425	60		rts				rts
.019426					_BMIConvert:
.019426					_BMIError:
.019426	4c 67 85	jmp $018567			jmp 	TypeError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.019429					Binary_Equal:
.019429	20 72 94	jsr $019472			jsr 	CompareValues 				; compare the values
.01942c	09 00		ora #$00			ora 	#0 							; true if 0
.01942e	f0 33		beq $019463			beq 	CCTrue
.019430	80 2d		bra $01945f			bra 	CCFalse
.019432					Binary_NotEqual:
.019432	20 72 94	jsr $019472			jsr 	CompareValues
.019435	09 00		ora #$00			ora 	#0 							; true if -1 or 1
.019437	f0 26		beq $01945f			beq 	CCFalse
.019439	80 28		bra $019463			bra 	CCTrue
.01943b					Binary_Less:
.01943b	20 72 94	jsr $019472			jsr 	CompareValues
.01943e	09 00		ora #$00			ora 	#0 							; true if -1
.019440	30 21		bmi $019463			bmi 	CCTrue
.019442	80 1b		bra $01945f			bra 	CCFalse
.019444					Binary_LessEqual:
.019444	20 72 94	jsr $019472			jsr 	CompareValues
.019447	c9 01		cmp #$01			cmp 	#1 							; true if 0 or -1
.019449	d0 18		bne $019463			bne 	CCTrue
.01944b	80 12		bra $01945f			bra 	CCFalse
.01944d					Binary_GreaterEqual:
.01944d	20 72 94	jsr $019472			jsr 	CompareValues
.019450	09 00		ora #$00			ora 	#0 							; true if 0 or 1
.019452	10 0f		bpl $019463			bpl 	CCTrue
.019454	80 09		bra $01945f			bra 	CCFalse
.019456					Binary_Greater:
.019456	20 72 94	jsr $019472			jsr 	CompareValues 				; true if 1
.019459	c9 01		cmp #$01			cmp 	#1
.01945b	f0 06		beq $019463			beq 	CCTrue
.01945d	80 00		bra $01945f			bra 	CCFalse
.01945f	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.019461	80 02		bra $019465			bra 	CCWrite
.019463	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.019465	95 80		sta $80,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.019467	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019469	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01946b	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01946d	a9 01		lda #$01			lda 	#1
.01946f	95 85		sta $85,x			sta 	XS_Type,x 					; set type to integer whatever.
.019471	60		rts				rts
.019472					CompareValues:
.019472	b5 85		lda $85,x			lda 	XS_Type,x 					; and the types together
.019474	35 8b		and $8b,x			and 	XS2_Type,x
.019476	c9 02		cmp #$02			cmp 	#2 							; is it a string, then do the string
.019478	f0 04		beq $01947e			beq 	_CVString					; comparison routine.
.01947a	4c c0 94	jmp $0194c0			jmp 	CompareInteger32 							; so execute code at \1
.01947d	60		rts				rts
.01947e					_CVString:
.01947e	da		phx				phx 								; save XY
.01947f	5a		phy				phy
.019480	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.019482	85 1c		sta $1c				sta		zLTemp1+0
.019484	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019486	85 1d		sta $1d				sta 	zLTemp1+1
.019488	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.01948a	85 1e		sta $1e				sta 	zLTemp1+2
.01948c	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.01948e	85 1f		sta $1f				sta 	zLTemp1+3
.019490	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.019492	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.019494	d1 1e		cmp ($1e),y			cmp 	(zLTemp1+2),y
.019496	90 02		bcc $01949a			bcc 	_CVCommon
.019498	b1 1e		lda ($1e),y			lda 	(zLTemp1+2),y
.01949a					_CVCommon:
.01949a	aa		tax				tax 								; put shorter string length in zero.
.01949b	f0 0c		beq $0194a9			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.01949d					_CVCompare:
.01949d	c8		iny				iny 								; next character
.01949e	b1 1c		lda ($1c),y			lda 	(zLTemp1),y 				; compare characters
.0194a0	d1 1e		cmp ($1e),y			cmp 	(zLTemp1+2),y 				; handle different values, < or >
.0194a2	90 13		bcc $0194b7			bcc 	_CVReturnLess 				; <
.0194a4	d0 15		bne $0194bb			bne 	_CVReturnGreater 			; >
.0194a6	ca		dex				dex 								; until common length matched.
.0194a7	d0 f4		bne $01949d			bne 	_CVCompare
.0194a9					_CVMatch:
.0194a9	a0 00		ldy #$00			ldy 	#0
.0194ab	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.0194ad	d1 1e		cmp ($1e),y			cmp 	(zLTemp1+2),y
.0194af	90 06		bcc $0194b7			bcc 	_CVReturnLess 				; <
.0194b1	d0 08		bne $0194bb			bne 	_CVReturnGreater 			; >
.0194b3	a9 00		lda #$00			lda 	#0
.0194b5	80 06		bra $0194bd			bra 	_CVExit
.0194b7					_CVReturnLess:
.0194b7	a9 ff		lda #$ff			lda 	#$FF
.0194b9	80 02		bra $0194bd			bra 	_CVExit
.0194bb					_CVReturnGreater:
.0194bb	a9 01		lda #$01			lda 	#$01
.0194bd					_CVExit:
.0194bd	7a		ply				ply
.0194be	fa		plx				plx
.0194bf	60		rts				rts
.0194c0					CompareInteger32:
.0194c0	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.0194c2	49 80		eor #$80			eor 	#$80
.0194c4	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0194c6	b5 89		lda $89,x			lda 	XS2_Mantissa+3,x
.0194c8	49 80		eor #$80			eor 	#$80
.0194ca	95 89		sta $89,x			sta 	XS2_Mantissa+3,x
.0194cc	20 16 95	jsr $019516			jsr 	SubInteger32 				; subtraction
.0194cf	90 0d		bcc $0194de			bcc 	_CI32Less 					; cc return -1
.0194d1	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check if zero
.0194d3	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.0194d5	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.0194d7	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.0194d9	f0 02		beq $0194dd			beq 	_CI32Exit
.0194db	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.0194dd					_CI32Exit:
.0194dd	60		rts				rts
.0194de					_CI32Less:
.0194de	a9 ff		lda #$ff			lda 	#$FF
.0194e0	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.0194e1					BinaryOp_Add:
.0194e1	b5 85		lda $85,x			lda 	XS_Type,x  					; and types together
.0194e3	35 8b		and $8b,x			and 	XS2_Type,x
.0194e5	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.0194e7	d0 04		bne $0194ed			bne 	_BOAString 					; so go do the string code.
.0194e9	4c fc 94	jmp $0194fc			jmp 	AddInteger32 							; so execute code at \1
.0194ec	60		rts				rts
.0194ed					_BOAString:
.0194ed	4c 47 95	jmp $019547			jmp 	ConcatenateString 			; concatenate two strings.
.0194f0					BinaryOp_Subtract:
.0194f0	4c 16 95	jmp $019516			jmp 	SubInteger32 							; so execute code at \1
.0194f3	60		rts				rts
.0194f4					BinaryOp_Multiply:
.0194f4	4c 62 a0	jmp $01a062			jmp 	MulInteger32 							; so execute code at \1
.0194f7	60		rts				rts
.0194f8					BinaryOp_Divide:
.0194f8	4c a0 a0	jmp $01a0a0			jmp 	DivInteger32 							; so execute code at \1
.0194fb	60		rts				rts
.0194fc					AddInteger32:
.0194fc	18		clc				clc
.0194fd	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0194ff	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.019501	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019503	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019505	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.019507	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019509	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01950b	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.01950d	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01950f	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019511	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.019513	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019515	60		rts				rts
.019516					SubInteger32:
.019516	38		sec				sec
.019517	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019519	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.01951b	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01951d	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01951f	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.019521	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019523	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019525	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.019527	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019529	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01952b	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.01952d	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01952f	60		rts				rts
.019530					BinaryMakeBothFloat:
.019530	da		phx				phx 								; save X
.019531	e8		inx				inx
.019532	e8		inx				inx
.019533	e8		inx				inx
.019534	e8		inx				inx
.019535	e8		inx				inx
.019536	e8		inx				inx
.019537	20 3b 95	jsr $01953b			jsr 	BinaryMakeFloat 			; convert to float.
.01953a	fa		plx				plx 								; restore X and fall through.
.01953b					BinaryMakeFloat:
.01953b	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.01953d	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.01953e	b0 04		bcs $019544			bcs 	_BMFConvert
.019540	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.019541	b0 01		bcs $019544			bcs 	_BMFError
.019543	60		rts				rts
.019544					_BMFConvert:
.019544					_BMFError:
.019544	4c 67 85	jmp $018567			jmp 	TypeError
.019547					ConcatenateString:
.019547	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.019549	85 1c		sta $1c				sta		zLTemp1+0
.01954b	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01954d	85 1d		sta $1d				sta 	zLTemp1+1
.01954f	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.019551	85 1e		sta $1e				sta 	zLTemp1+2
.019553	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.019555	85 1f		sta $1f				sta 	zLTemp1+3
.019557	5a		phy				phy
.019558	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.01955a	b1 1c		lda ($1c),y			lda 	(zlTemp1),y
.01955c	71 1e		adc ($1e),y			adc 	(zlTemp1+2),y
.01955e	7a		ply				ply
.01955f	b0 33		bcs $019594			bcs 	_CSError					; check in range.
.019561	c9 fe		cmp #$fe			cmp 	#maxString+1
.019563	b0 2f		bcs $019594			bcs 	_CSError
.019565	20 f4 99	jsr $0199f4			jsr 	AllocateTempString 			; store the result
.019568	20 7f 95	jsr $01957f			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.01956b	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.01956d	85 1c		sta $1c				sta 	zLTemp1
.01956f	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.019571	85 1d		sta $1d				sta 	zLTemp1+1
.019573	20 7f 95	jsr $01957f			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.019576	a5 22		lda $22				lda 	zTempStr 					; point current to new string
.019578	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01957a	a5 23		lda $23				lda 	zTempStr+1
.01957c	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01957e	60		rts				rts
.01957f					_CSCopyString:
.01957f	da		phx				phx
.019580	5a		phy				phy
.019581	a0 00		ldy #$00			ldy 	#0 							; get length
.019583	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.019585	f0 0a		beq $019591			beq 	_CSCSExit 					; if zero, exit immediately
.019587	aa		tax				tax 								; put in X which is the counter.
.019588					_CSCSLoop:
.019588	c8		iny				iny 								; get next char
.019589	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.01958b	20 1f 9a	jsr $019a1f			jsr		WriteTempString 			; copy out to new string
.01958e	ca		dex				dex 								; do whole string
.01958f	d0 f7		bne $019588			bne 	_CSCSLoop
.019591					_CSCSExit:
.019591	7a		ply				ply
.019592	fa		plx				plx
.019593	60		rts				rts
.019594					_CSError:
.019594	20 86 85	jsr $018586			jsr ERR_Handler
>019597	53 74 72 69 6e 67 20 74			.text "String too long",0
>01959f	6f 6f 20 6c 6f 6e 67 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.0195a7					Unary_Sgn:
.0195a7	20 95 93	jsr $019395			jsr 	EvaluateNumberX 			; get value
.0195aa	20 a7 99	jsr $0199a7			jsr 	CheckNextRParen 			; check right bracket.
.0195ad	20 cb 95	jsr $0195cb			jsr 	GetSignCurrent 				; get sign.
.0195b0	09 00		ora #$00			ora 	#0
.0195b2	10 08		bpl $0195bc			bpl		UnarySetAInteger			; if 0,1 return that.
.0195b4	80 00		bra $0195b6			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.0195b6					UnarySetAMinus1:
.0195b6	a9 ff		lda #$ff			lda 	#$FF 						; put -1 in all four slots.
.0195b8	95 80		sta $80,x			sta 	XS_Mantissa,x
.0195ba	80 04		bra $0195c0			bra 	UnarySetAFill
.0195bc					UnarySetAInteger:
.0195bc	95 80		sta $80,x			sta 	XS_Mantissa,x
.0195be	a9 00		lda #$00			lda 	#0
.0195c0					UnarySetAFill:
.0195c0	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0195c2	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0195c4	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0195c6	a9 01		lda #$01			lda 	#1 							; set type to integer.
.0195c8	95 85		sta $85,x			sta 	XS_Type,x
.0195ca	60		rts				rts
.0195cb					GetSignCurrent:
.0195cb	b5 85		lda $85,x			lda 	XS_Type,x 					; identify type.
.0195cd	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.0195ce	90 15		bcc $0195e5			bcc 	_GSCFloat 					; if clear do the float code.
.0195d0	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; if msb of integer set, it's negative
.0195d2	30 0e		bmi $0195e2			bmi 	_GSCMinus1
.0195d4	15 80		ora $80,x			ora 	XS_Mantissa+0,x
.0195d6	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.0195d8	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.0195da	d0 03		bne $0195df			bne 	_GSCPlus1 					; check if zero by oring all together.
.0195dc					_GSCZero:
.0195dc	a9 00		lda #$00			lda 	#0
.0195de	60		rts				rts
.0195df					_GSCPlus1:
.0195df	a9 01		lda #$01			lda 	#$01
.0195e1	60		rts				rts
.0195e2					_GSCMinus1:
.0195e2	a9 ff		lda #$ff			lda 	#$FF
.0195e4	60		rts				rts
.0195e5					_GSCFloat:
.0195e5	34 85		bit $85,x			bit 	XS_Type,x 					; check bits
.0195e7	70 f3		bvs $0195dc			bvs 	_GSCZero 					; if zero flag set return zero
.0195e9	30 f7		bmi $0195e2			bmi 	_GSCMinus1 					; if sign set return -1
.0195eb	80 f2		bra $0195df			bra 	_GSCPlus1		 			; else return +1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.0195ed					Unary_Abs:
.0195ed	20 95 93	jsr $019395			jsr 	EvaluateNumberX 			; get value
.0195f0	20 a7 99	jsr $0199a7			jsr 	CheckNextRParen 			; check right bracket.
.0195f3	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.0195f5	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.0195f7	f0 07		beq $019600			beq 	_UAMinusFloat
.0195f9	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; check MSB of upper byte to see if negative
.0195fb	10 09		bpl $019606			bpl 	_UAExit
.0195fd	4c 27 a1	jmp $01a127			jmp 	IntegerNegateAlways 		; if so negate it.
.019600					_UAMinusFloat:
.019600	b5 85		lda $85,x			lda 	XS_Type,x 					; clear the sign bit.
.019602	29 7f		and #$7f			and		#$7F
.019604	95 85		sta $85,x			sta 	XS_Type,x
.019606					_UAExit:
.019606	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.019607					Unary_Peek:
.019607	a9 01		lda #$01			lda 	#1 							; 1 byte
.019609	80 06		bra $019611			bra 	UPMain
.01960b					Unary_Deek:
.01960b	a9 02		lda #$02			lda 	#2 							; 2 bytes
.01960d	80 02		bra $019611			bra 	UPMain
.01960f					Unary_Leek:
.01960f	a9 04		lda #$04			lda 	#4 							; 4 bytes
.019611					UPMain:
.019611	48		pha				pha 								; save bytes to copy.
.019612	20 a3 93	jsr $0193a3			jsr 	EvaluateIntegerX 			; numeric parameter, the address to xEEK
.019615	20 a7 99	jsr $0199a7			jsr 	CheckNextRParen 			; right bracket.
.019618	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.01961a	85 1c		sta $1c				sta 	zLTemp1
.01961c	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01961e	85 1d		sta $1d				sta 	zLTemp1+1
.019620	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019622	85 1e		sta $1e				sta 	zLTemp1+2
.019624	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019626	85 1f		sta $1f				sta 	zLTemp1+3
.019628	a9 00		lda #$00			lda 	#0 							; clear target area, which might get
.01962a	95 80		sta $80,x			sta 	XS_Mantissa+0,x 			; 1,2 or 4 bytes.
.01962c	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01962e	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019630	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019632	68		pla				pla 								; restore bytes to copy
.019633	da		phx				phx 								; save XY
.019634	5a		phy				phy
.019635	20 29 99	jsr $019929			jsr 	MemRead 					; read the bytes in, processor dependent routine.
.019638	7a		ply				ply 								; restore and exit
.019639	fa		plx				plx
.01963a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/pos.asm

.01963b					Unary_Pos:
.01963b	20 95 93	jsr $019395			jsr 	EvaluateNumberX 			; get value, which is a dummy.
.01963e	20 a7 99	jsr $0199a7			jsr 	CheckNextRParen 			; check right bracket.
.019641	20 50 85	jsr $018550			jsr 	VIOCharGetPosition 			; get the position
.019644	4c bc 95	jmp $0195bc			jmp		UnarySetAInteger			; and return that.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.019647					Unary_Mod:
.019647	20 6f 96	jsr $01966f			jsr 	_UMParameter 				; first parameter, get |param|
.01964a	20 af 99	jsr $0199af			jsr 	CheckNextComma
.01964d	da		phx				phx 								; second parameter, get |param|
.01964e	e8		inx				inx
.01964f	e8		inx				inx
.019650	e8		inx				inx
.019651	e8		inx				inx
.019652	e8		inx				inx
.019653	e8		inx				inx
.019654	20 6f 96	jsr $01966f			jsr 	_UMParameter
.019657	fa		plx				plx
.019658	20 a7 99	jsr $0199a7			jsr 	CheckNextRParen
.01965b	20 a0 a0	jsr $01a0a0			jsr 	DivInteger32 				; divide, which handily leaves ....
.01965e	a5 1c		lda $1c				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.019660	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019662	a5 1d		lda $1d				lda 	zLTemp1+1
.019664	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019666	a5 1e		lda $1e				lda 	zLTemp1+2
.019668	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01966a	a5 1f		lda $1f				lda 	zLTemp1+3
.01966c	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01966e	60		rts				rts
.01966f					_UMParameter:
.01966f	20 a3 93	jsr $0193a3			jsr 	EvaluateIntegerX 			; get value
.019672	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; absolute value
.019674	10 03		bpl $019679			bpl 	_UMNotSigned
.019676	20 27 a1	jsr $01a127			jsr 	IntegerNegateAlways
.019679					_UMNotSigned:
.019679	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.01967a					Unary_Usr:
.01967a	20 95 93	jsr $019395			jsr 	EvaluateNumberX 			; numeric parameter
.01967d	20 a7 99	jsr $0199a7			jsr 	CheckNextRParen 			; right bracket.
.019680	da		phx				phx 								; save XY
.019681	5a		phy				phy
.019682	22 0c 03 00	jsl $00030c			jsl 	UserVector 					; with the parameter in the base mantissa
.019686	7a		ply				ply 								; restore YX and exit with whatever the
.019687	fa		plx				plx 								; routine called has chosen to do with it.
.019688	60		rts				rts
.019689					USRDefault:
.019689	20 86 85	jsr $018586			jsr ERR_Handler
>01968c	4e 6f 20 55 53 52 20 76			.text "No USR vector.",0
>019694	65 63 74 6f 72 2e 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.01969b					Unary_Val:
.01969b	20 a9 93	jsr $0193a9			jsr 	EvaluateStringX 			; get string
.01969e	20 a7 99	jsr $0199a7			jsr 	CheckNextRParen 			; check right bracket.
.0196a1	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.0196a3	85 20		sta $20				sta 	zGenPtr
.0196a5	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0196a7	85 21		sta $21				sta 	zGenPtr+1
.0196a9	da		phx				phx
.0196aa	5a		phy				phy
.0196ab	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.0196ad	b1 20		lda ($20),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.0196af	f0 1b		beq $0196cc			beq 	UVBadNumber
.0196b1	aa		tax				tax
.0196b2					_UVCopy1:
.0196b2	c8		iny				iny
.0196b3	c0 18		cpy #$18			cpy 	#24 						; too long
.0196b5	f0 15		beq $0196cc			beq 	UVBadNumber
.0196b7	b1 20		lda ($20),y			lda 	(zGenPtr),y					; copy character
.0196b9	99 14 03	sta $0314,y			sta 	Num_Buffer-1,y
.0196bc	a9 00		lda #$00			lda 	#0 							; make string ASCIIZ.
.0196be	99 15 03	sta $0315,y			sta 	Num_Buffer,y
.0196c1	ca		dex				dex
.0196c2	d0 ee		bne $0196b2			bne 	_UVCopy1
.0196c4	7a		ply				ply
.0196c5	fa		plx				plx
.0196c6	20 da 96	jsr $0196da			jsr 	ConvertNumBuffer 			; convert string in NumBuffer to mantissa,x
.0196c9	b0 01		bcs $0196cc			bcs 	UVBadNumber
.0196cb	60		rts				rts
.0196cc					UVBadNumber:
.0196cc	20 86 85	jsr $018586			jsr ERR_Handler
>0196cf	42 61 64 20 4e 75 6d 62			.text "Bad Number",0
>0196d7	65 72 00
.0196da					ConvertNumBuffer:
.0196da	5a		phy				phy
.0196db	a9 15		lda #$15			lda 	#Num_Buffer & $FF 			; set zGenPtr to point to buffer.
.0196dd	85 20		sta $20				sta 	zGenPtr
.0196df	a9 03		lda #$03			lda 	#Num_Buffer >> 8
.0196e1	85 21		sta $21				sta 	zGenPtr+1
.0196e3	ad 15 03	lda $0315			lda 	Num_Buffer 					; first character is - ?
.0196e6	c9 2d		cmp #$2d			cmp 	#"-"
.0196e8	d0 02		bne $0196ec			bne 	_UVNotMinus1
.0196ea	e6 20		inc $20				inc 	zGenPtr 					; this time just fix the pointer.
.0196ec					_UVNotMinus1:
.0196ec	20 f9 a1	jsr $01a1f9			jsr 	IntFromString 				; get integer
.0196ef	b0 1f		bcs $019710			bcs 	_UVFail
.0196f1	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; done the whole string
.0196f3	d0 1b		bne $019710			bne 	_UVFail 					; no, exit.
.0196f5	ad 15 03	lda $0315			lda 	Num_Buffer 					; look at numbuffer
.0196f8	c9 2d		cmp #$2d			cmp 	#"-"
.0196fa	d0 11		bne $01970d			bne 	_UVNotMinus2
.0196fc	b5 85		lda $85,x			lda 	XS_Type,x 					; type is float ?
.0196fe	29 0f		and #$0f			and 	#$0F
.019700	f0 05		beq $019707			beq 	_UVNegateFloat
.019702	20 27 a1	jsr $01a127			jsr 	IntegerNegateAlways
.019705	80 06		bra $01970d			bra 	_UVNotMinus2
.019707					_UVNegateFloat:
.019707	b5 85		lda $85,x			lda 	XS_Type,x 					; set the sign bit.
.019709	09 80		ora #$80			ora 	#$80
.01970b	95 85		sta $85,x			sta 	XS_Type,x
.01970d					_UVNotMinus2:
.01970d	7a		ply				ply
.01970e	18		clc				clc
.01970f	60		rts				rts
.019710	7a		ply		_UVFail:ply
.019711	38		sec				sec
.019712	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.019713					Unary_Str:
.019713	20 95 93	jsr $019395			jsr 	EvaluateNumberX 			; numeric parameter
.019716	20 a7 99	jsr $0199a7			jsr 	CheckNextRParen 			; right bracket.
.019719	a9 00		lda #$00			lda 	#0 							; reset buffer index
.01971b	8d 14 03	sta $0314			sta 	NumBufX
.01971e	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.019720	4a		lsr a				lsr 	a 							; bit 0 identifies an integer.
.019721	b0 02		bcs $019725			bcs 	_USInt 						; if msb set do as integer
.019723	80 03		bra $019728			bra 	_USDuplicate
.019725	20 44 a1	jsr $01a144	_USInt:	jsr 	IntToString					; call int to str.
.019728					_USDuplicate:
.019728	ad 14 03	lda $0314			lda 	NumBufX 					; chars in buffer
.01972b	1a		inc a				inc 	a 							; one more for length
.01972c	20 f4 99	jsr $0199f4			jsr 	AllocateTempString 			; allocate space for it.
.01972f	5a		phy				phy 								; save Y
.019730	a0 00		ldy #$00			ldy 	#0 							; start copying
.019732	b9 15 03	lda $0315,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.019735	20 1f 9a	jsr $019a1f			jsr 	WriteTempString
.019738	c8		iny				iny
.019739	cc 14 03	cpy $0314			cpy 	NumBufX 					; done the lot
.01973c	d0 f4		bne $019732			bne 	_USCopy
.01973e	7a		ply				ply 								; restore Y
.01973f	4c 1c 99	jmp $01991c			jmp 	UnaryReturnTempStr 			; return newly created temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.019742					Unary_Asc:
.019742	20 a9 93	jsr $0193a9			jsr 	EvaluateStringX 			; string parameter
.019745	20 a7 99	jsr $0199a7			jsr 	CheckNextRParen 			; right bracket.
.019748	5a		phy				phy 								; get the string length
.019749	a0 00		ldy #$00			ldy 	#0
.01974b	b1 20		lda ($20),y			lda 	(zGenPtr),y
.01974d	f0 07		beq $019756			beq 	_UAIllegal 					; must be at least one character, 0 => error
.01974f	c8		iny				iny
.019750	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; read the first character
.019752	7a		ply				ply
.019753	4c bc 95	jmp $0195bc			jmp 	UnarySetAInteger 			; return that as an integer 0-255.
.019756					_UAIllegal:
.019756	4c 75 85	jmp $018575			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.019759					Unary_Len:
.019759	20 a9 93	jsr $0193a9			jsr 	EvaluateStringX 			; string parameter
.01975c	20 a7 99	jsr $0199a7			jsr 	CheckNextRParen 			; right bracket.
.01975f	5a		phy				phy 								; get the string length
.019760	a0 00		ldy #$00			ldy 	#0
.019762	b1 20		lda ($20),y			lda 	(zGenPtr),y
.019764	7a		ply				ply
.019765	4c bc 95	jmp $0195bc			jmp 	UnarySetAInteger 			; return as an integer.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.019768					Unary_Mid:
.019768	20 a9 93	jsr $0193a9			jsr 	EvaluateStringX 				; get string.
.01976b	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.01976d	48		pha				pha
.01976e	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019770	48		pha				pha
.019771	20 af 99	jsr $0199af			jsr 	CheckNextComma 					; skip comma
.019774	20 fd 97	jsr $0197fd			jsr 	SLIByteParameter 				; get a byte parameter (start)
.019777	48		pha				pha 									; and push it.
.019778	20 af 99	jsr $0199af			jsr 	CheckNextComma 					; skip comma
.01977b	20 fd 97	jsr $0197fd			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.01977e	48		pha				pha 									; and push it.
.01977f	80 41		bra $0197c2			bra 	SLIProcess
.019781					Unary_Left:
.019781	20 a9 93	jsr $0193a9			jsr 	EvaluateStringX 				; get string.
.019784	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.019786	48		pha				pha
.019787	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019789	48		pha				pha
.01978a	a9 01		lda #$01			lda 	#1 								; push start position (1)
.01978c	48		pha				pha
.01978d	20 af 99	jsr $0199af			jsr 	CheckNextComma 					; skip comma
.019790	20 fd 97	jsr $0197fd			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.019793	48		pha				pha 									; and push it.
.019794	80 2c		bra $0197c2			bra 	SLIProcess
.019796					Unary_Right:
.019796	20 a9 93	jsr $0193a9			jsr 	EvaluateStringX 				; get string.
.019799	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.01979b	48		pha				pha
.01979c	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01979e	48		pha				pha
.01979f	da		phx				phx 									; get the string length and push on stack.
.0197a0	a2 00		ldx #$00			ldx 	#0
.0197a2	a1 20		lda ($20,x)			lda		(zGenPtr,x)
.0197a4	fa		plx				plx
.0197a5	48		pha				pha
.0197a6	20 af 99	jsr $0199af			jsr 	CheckNextComma 					; skip comma
.0197a9	20 fd 97	jsr $0197fd			jsr 	SLIByteParameter 				; get a byte parameter.
.0197ac	8d 9e 03	sta $039e			sta 	SignCount 						; save in temporary.
.0197af	68		pla				pla 									; restore string length.
.0197b0	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.0197b1	38		sec				sec
.0197b2	ed 9e 03	sbc $039e			sbc 	SignCount 						; subtract characters needed, gives start position.
.0197b5	f0 02		beq $0197b9			beq 	_URStart 						; if <= 0 start from 1.
.0197b7	10 02		bpl $0197bb			bpl 	_UROkay
.0197b9					_URStart:
.0197b9	a9 01		lda #$01			lda 	#1
.0197bb					_UROkay:
.0197bb	48		pha				pha 									; push start
.0197bc	ad 9e 03	lda $039e			lda 	SignCount 						; push count of characters
.0197bf	48		pha				pha
.0197c0	80 00		bra $0197c2			bra 	SLIProcess
.0197c2					SLIProcess:
.0197c2	20 a7 99	jsr $0199a7			jsr 	CheckNextRParen 				; closing right bracket.
.0197c5	68		pla				pla
.0197c6	8d a2 03	sta $03a2			sta 	SliceCount 						; count in signcount
.0197c9	1a		inc a				inc 	a 								; allocate +1 for it.
.0197ca	20 f4 99	jsr $0199f4			jsr 	AllocateTempString
.0197cd	68		pla				pla 									; pop start number off stack.
.0197ce	f0 3b		beq $01980b			beq 	SLIError 						; exit if start = 0
.0197d0	8d a1 03	sta $03a1			sta 	SliceStart
.0197d3	68		pla				pla  									; pop string address.
.0197d4	85 21		sta $21				sta 	zGenPtr+1
.0197d6	68		pla				pla
.0197d7	85 20		sta $20				sta 	zGenPtr
.0197d9	da		phx				phx
.0197da	5a		phy				phy
.0197db	a2 00		ldx #$00			ldx 	#0 								; point to string length.
.0197dd	ac a1 03	ldy $03a1			ldy 	SliceStart 						; start of the string (+1 for count)
.0197e0					_SLICopy:
.0197e0	ad a2 03	lda $03a2			lda 	SliceCount 						; done count characters
.0197e3	f0 12		beq $0197f7			beq 	_SLIExit
.0197e5	ce a2 03	dec $03a2			dec 	SliceCount
.0197e8	98		tya				tya 									; index of character
.0197e9	c1 20		cmp ($20,x)			cmp 	(zGenPtr,x)						; compare against length
.0197eb	f0 02		beq $0197ef			beq 	_SLIOk 							; if equal, okay.
.0197ed	b0 08		bcs $0197f7			bcs 	_SLIExit 						; if past end, then exit.
.0197ef	b1 20		lda ($20),y	_SLIOk:	lda 	(zGenPtr),y 					; copy one character
.0197f1	c8		iny				iny
.0197f2	20 1f 9a	jsr $019a1f			jsr 	WriteTempString
.0197f5	80 e9		bra $0197e0			bra 	_SLICopy 						; go round till copied characters
.0197f7					_SLIExit:
.0197f7	7a		ply				ply 									; restore YX
.0197f8	fa		plx				plx
.0197f9	4c 1c 99	jmp $01991c			jmp 	UnaryReturnTempStr 				; return new temporary string.
.0197fc	ea		nop				nop
.0197fd					SLIByteParameter:
.0197fd	20 a3 93	jsr $0193a3			jsr 	EvaluateIntegerX 				; get integer
.019800	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.019802	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019804	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019806	d0 03		bne $01980b			bne 	SLIError
.019808	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01980a	60		rts				rts
.01980b					SLIError:
.01980b	4c 75 85	jmp $018575			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.01980e					Unary_Hex:
.01980e	20 a3 93	jsr $0193a3			jsr 	EvaluateIntegerX 			; numeric parameter
.019811	20 a7 99	jsr $0199a7			jsr 	CheckNextRParen 			; right bracket.
.019814	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.019816	20 f4 99	jsr $0199f4			jsr 	AllocateTempString			; allocate string space
.019819	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.01981b	20 3f 98	jsr $01983f			jsr 	_UHConvert
.01981e	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019820	20 3f 98	jsr $01983f			jsr 	_UHConvert
.019823	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019825	20 3f 98	jsr $01983f			jsr 	_UHConvert
.019828	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01982a	20 3f 98	jsr $01983f			jsr 	_UHConvert
.01982d	5a		phy				phy 								; get length of new string
.01982e	a0 00		ldy #$00			ldy 	#0
.019830	b1 22		lda ($22),y			lda 	(zTempStr),y
.019832	7a		ply				ply
.019833	c9 00		cmp #$00			cmp 	#0 							; if it was non zero okay
.019835	d0 05		bne $01983c			bne 	_UHExit 					; otherwise suppressed all leading zeros !
.019837	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.019839	20 1f 9a	jsr $019a1f			jsr 	WriteTempString
.01983c					_UHExit:
.01983c	4c 1c 99	jmp $01991c			jmp 	UnaryReturnTempStr 			; return new temporary string.
.01983f					_UHConvert:
.01983f	48		pha				pha
.019840	4a		lsr a				lsr 	a 							; do MSB
.019841	4a		lsr a				lsr 	a
.019842	4a		lsr a				lsr 	a
.019843	4a		lsr a				lsr 	a
.019844	20 48 98	jsr $019848			jsr 	_UHNibble
.019847	68		pla				pla 								; do LSB
.019848					_UHNibble:
.019848	29 0f		and #$0f			and 	#15 						; get nibble
.01984a	d0 0c		bne $019858			bne 	_UHNonZero 					; if not zero, write it out anyway.
.01984c	5a		phy				phy									; get the length
.01984d	a0 00		ldy #$00			ldy 	#0
.01984f	b1 22		lda ($22),y			lda 	(zTempStr),y
.019851	7a		ply				ply
.019852	c9 00		cmp #$00			cmp 	#0 							; length = 0 => suppress leading zeros.
.019854	f0 0d		beq $019863			beq 	_UHExit2
.019856	a9 00		lda #$00			lda 	#0 							; length > 0, so can't suppress any more.
.019858					_UHNonZero:
.019858	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.01985a	90 02		bcc $01985e			bcc 	_UHDigit
.01985c	69 06		adc #$06			adc 	#7-1
.01985e					_UHDigit:
.01985e	69 30		adc #$30			adc 	#48
.019860	20 1f 9a	jsr $019a1f			jsr 	WriteTempString				; output to temp string.
.019863					_UHExit2:
.019863	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.019864					Unary_Dec:
.019864	20 a9 93	jsr $0193a9			jsr 	EvaluateStringX 			; string parameter
.019867	20 a7 99	jsr $0199a7			jsr 	CheckNextRParen 			; right bracket.
.01986a	5a		phy				phy
.01986b	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.01986d	b1 20		lda ($20),y			lda 	(zGenPtr),y
.01986f	f0 43		beq $0198b4			beq 	_UDFail 					; must fail if zero.
.019871	8d 9e 03	sta $039e			sta 	SignCount 					; use SignCount as a counter of chars to process.
.019874	a9 00		lda #$00			lda 	#0 							; set result to zero
.019876	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019878	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01987a	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01987c	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01987e	a9 01		lda #$01			lda 	#1 							; set type to integer.
.019880	95 85		sta $85,x			sta 	XS_Type,x
.019882					_UDConvertLoop:
.019882	5a		phy				phy 								; shift mantissa left 4
.019883	a0 04		ldy #$04			ldy 	#4
.019885					_UDShift:
.019885	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.019887	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.019889	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.01988b	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.01988d	88		dey				dey
.01988e	d0 f5		bne $019885			bne 	_UDShift
.019890	7a		ply				ply
.019891	c8		iny				iny 								; next character
.019892	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; fetch it.
.019894	20 b7 98	jsr $0198b7			jsr 	ConvertUpper 				; convert to U/C
.019897	c9 30		cmp #$30			cmp 	#"0" 						; range 0-9
.019899	90 19		bcc $0198b4			bcc 	_UDFail
.01989b	c9 3a		cmp #$3a			cmp 	#"9"+1
.01989d	90 08		bcc $0198a7			bcc 	_UDOkay
.01989f	e9 37		sbc #$37			sbc 	#7+"0" 						; A-F fudge
.0198a1	90 11		bcc $0198b4			bcc 	_UDFail 					; fails if between 9 and @
.0198a3	c9 10		cmp #$10			cmp 	#16 						; must be < 16 as hexadecimal.
.0198a5	b0 0d		bcs $0198b4			bcs 	_UDFail
.0198a7					_UDOkay:
.0198a7	29 0f		and #$0f			and 	#15 						; nibble only
.0198a9	15 80		ora $80,x			ora 	XS_Mantissa+0,x 			; OR into the bottom byte.
.0198ab	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0198ad	ce 9e 03	dec $039e			dec 	SignCount 					; do it for each character in the string.
.0198b0	d0 d0		bne $019882			bne 	_UDConvertLoop
.0198b2	7a		ply				ply
.0198b3	60		rts				rts
.0198b4					_UDFail:
.0198b4	4c 75 85	jmp $018575			jmp 	BadParamError
.0198b7					ConvertUpper:
.0198b7	c9 61		cmp #$61			cmp 	#"a"
.0198b9	90 07		bcc $0198c2			bcc 	_CUExit
.0198bb	c9 7b		cmp #$7b			cmp 	#"z"+1
.0198bd	b0 03		bcs $0198c2			bcs 	_CUExit
.0198bf	38		sec				sec
.0198c0	e9 20		sbc #$20			sbc 	#32
.0198c2	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.0198c3					Unary_Chr:
.0198c3	20 a3 93	jsr $0193a3			jsr 	EvaluateIntegerX			; numeric parameter which is the character we want
.0198c6	20 a7 99	jsr $0199a7			jsr 	CheckNextRParen 			; right bracket.
.0198c9	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.0198cb	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.0198cd	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.0198cf	d0 0d		bne $0198de			bne 	_UCChar
.0198d1	a9 02		lda #$02			lda 	#1+1 						; one character string. 2 bytes - size+char
.0198d3	20 f4 99	jsr $0199f4			jsr 	AllocateTempString			; allocate it.
.0198d6	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.0198d8	20 1f 9a	jsr $019a1f			jsr 	WriteTempString
.0198db	4c 1c 99	jmp $01991c			jmp 	UnaryReturnTempStr 			; and return that string.
.0198de					_UCChar:
.0198de	4c 75 85	jmp $018575			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.0198e1					Unary_Spc:
.0198e1	20 fd 97	jsr $0197fd			jsr 	SLIByteParameter 			; get number of spaces
.0198e4	20 a7 99	jsr $0199a7			jsr 	CheckNextRParen 			; skip )
.0198e7	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; count of spaces
.0198e9					UnarySpcCreate:
.0198e9	c9 fe		cmp #$fe			cmp 	#maxString+1				; validate
.0198eb	b0 14		bcs $019901			bcs 	_USSize
.0198ed	48		pha				pha 								; save length
.0198ee	1a		inc a				inc 	a 							; allocate one more.
.0198ef	20 f4 99	jsr $0199f4			jsr 	AllocateTempString
.0198f2	68		pla				pla 								; get length
.0198f3	f0 27		beq $01991c			beq 	UnaryReturnTempStr 			; if zero (spc(0)) return the current temp string
.0198f5					_USLoop:
.0198f5	48		pha				pha
.0198f6	a9 20		lda #$20			lda 	#" "
.0198f8	20 1f 9a	jsr $019a1f			jsr 	WriteTempString
.0198fb	68		pla				pla
.0198fc	3a		dec a				dec 	a
.0198fd	d0 f6		bne $0198f5			bne 	_USLoop
.0198ff	80 1b		bra $01991c			bra 	UnaryReturnTempStr 			; and return the temporary space.
.019901					_USSize:
.019901	4c 75 85	jmp $018575			jmp 	BadParamError
.019904					Unary_Tab:
.019904	a2 00		ldx #$00			ldx 	#0 							; required TAB position.
.019906	20 fd 97	jsr $0197fd			jsr 	SLIByteParameter
.019909	20 a7 99	jsr $0199a7			jsr 	CheckNextRParen
.01990c	20 50 85	jsr $018550			jsr 	VIOCharGetPosition 			; were are we ?
.01990f	85 10		sta $10				sta 	zTemp1 						; calculate required-current
.019911	38		sec				sec
.019912	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; return chars required.
.019914	e5 10		sbc $10				sbc 	zTemp1
.019916	b0 d1		bcs $0198e9			bcs 	UnarySpcCreate 				; if not there, use SPC() code to generate string
.019918	a9 00		lda #$00			lda 	#0 							; if there or better, no characters required.
.01991a	80 cd		bra $0198e9			bra 	UnarySpcCreate
.01991c					UnaryReturnTempStr:
.01991c	a5 22		lda $22				lda 	zTempStr 					; copy temp string addr -> mantissa
.01991e	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019920	a5 23		lda $23				lda 	zTempStr+1
.019922	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019924	a9 02		lda #$02			lda 	#2 							; set type to string
.019926	95 85		sta $85,x			sta 	XS_Type,x
.019928	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/65816.asm

.019929					MemRead:
.019929	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.01992c	a0 00		ldy #$00			ldy 	#0 							; start from here
.01992e	b7 1c		lda [$1c],y	_MLoop1:lda 	[zlTemp1],y 				; read the long address
.019930	95 80		sta $80,x			sta 	XS_Mantissa,x 				; copy into mantissa
.019932	c8		iny				iny 								; next to copy
.019933	e8		inx				inx
.019934	cc 9e 03	cpy $039e			cpy 	SignCount 					; do required # of bytes.
.019937	d0 f5		bne $01992e			bne 	_MLoop1
.019939	60		rts				rts
.01993a					MemWrite:
.01993a	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.01993d	a0 00		ldy #$00			ldy 	#0 							; start from here
.01993f	b5 80		lda $80,x	_MLoop1:lda 	XS_Mantissa,x 				; read mantisssa
.019941	97 1c		sta [$1c],y			sta 	[zlTemp1],y 				; write it out
.019943	c8		iny				iny 								; next to copy
.019944	e8		inx				inx
.019945	cc 9e 03	cpy $039e			cpy 	SignCount 					; do required # of bytes.
.019948	d0 f5		bne $01993f			bne 	_MLoop1
.01994a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/programend.asm

.01994b					UpdateProgramEnd:
.01994b	a9 00		lda #$00			lda 	#(BasicProgram) & $FF
.01994d	85 18		sta $18				sta 	zCodePtr+0
.01994f	a9 10		lda #$10			lda 	#((BasicProgram) >> 8)
.019951	85 19		sta $19				sta 	zCodePtr+1
.019953	a9 00		lda #$00			lda 	#(BasicProgram) >> 16
.019955	85 1a		sta $1a				sta 	zCodePtr+2
.019957	85 1b		sta $1b				sta 	zCodePtr+3
.019959	a0 03		ldy #$03			ldy 	#3
.01995b					_UPDLoop:
.01995b	a0 00		ldy #$00			ldy 	#0
.01995d	b7 18		lda [$18],y			lda 	[zCodePtr],y
.01995f	c9 00		cmp #$00			cmp 	#0 							; end if offset is zero.
.019961	f0 0f		beq $019972			beq 	_UPDFoundEnd
.019963	a0 00		ldy #$00			ldy 	#0 							; point to offset
.019965	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read it
.019967	18		clc				clc
.019968	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.01996a	85 18		sta $18				sta 	zCodePtr
.01996c	90 02		bcc $019970			bcc 	_SNLNoCarry
.01996e	e6 19		inc $19				inc 	zCodePtr+1
.019970					_SNLNoCarry:
.019970	80 e9		bra $01995b			bra 	_UPDLoop
.019972					_UPDFoundEnd:
.019972	18		clc				clc 								; end of program 2 on.
.019973	a5 18		lda $18				lda 	zCodePtr
.019975	69 02		adc #$02			adc 	#2
.019977	8d 04 03	sta $0304			sta 	endOfProgram
.01997a	a5 19		lda $19				lda 	zCodePtr+1
.01997c	69 00		adc #$00			adc 	#0
.01997e	8d 05 03	sta $0305			sta 	endOfProgram+1
.019981	a5 1a		lda $1a				lda 	zCodePtr+2
.019983	69 00		adc #$00			adc		#0
.019985	8d 06 03	sta $0306			sta 	endOfProgram+2
.019988	a5 1b		lda $1b				lda 	zCodePtr+3
.01998a	69 00		adc #$00			adc 	#0
.01998c	8d 07 03	sta $0307			sta 	endOfProgram+3
.01998f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.019990					CheckNextToken:
.019990	d7 18		cmp [$18],y			cmp 	[zCodePtr],y
.019992	d0 02		bne $019996			bne 	CTFail 						; no, then fail
.019994	c8		iny				iny
.019995	60		rts				rts
.019996					CTFail:
.019996	20 86 85	jsr $018586			jsr ERR_Handler
>019999	4d 69 73 73 69 6e 67 20			.text "Missing token",0
>0199a1	74 6f 6b 65 6e 00
.0199a7					CheckNextRParen:
.0199a7	b7 18		lda [$18],y			lda 	[zCodePtr],y
.0199a9	c9 be		cmp #$be			cmp 	#token_rparen 						; does it match
.0199ab	d0 e9		bne $019996			bne 	CTFail 						; fail if not
.0199ad	c8		iny				iny
.0199ae	60		rts				rts
.0199af					CheckNextComma:
.0199af	b7 18		lda [$18],y			lda 	[zCodePtr],y
.0199b1	c9 bf		cmp #$bf			cmp 	#token_comma 						; does it match
.0199b3	d0 e1		bne $019996			bne 	CTFail 						; fail if not
.0199b5	c8		iny				iny
.0199b6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/concrete.asm

.0199b7					StringConcrete:
.0199b7	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; save source string to zTemp1
.0199b9	85 10		sta $10				sta 	zTemp1
.0199bb	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0199bd	85 11		sta $11				sta 	zTemp1+1
.0199bf	a0 00		ldy #$00			ldy 	#0 							; empty string, return default empty
.0199c1	b1 10		lda ($10),y			lda 	(zTemp1),y
.0199c3	f0 26		beq $0199eb			beq		_SCEmpty 					; concreting it wastes memory.
.0199c5	18		clc				clc 								; from the string pointer
.0199c6	ad 00 03	lda $0300			lda 	StringPtr 					; and put in zTemp2 as well
.0199c9	f1 10		sbc ($10),y			sbc 	(zTemp1),y
.0199cb	8d 00 03	sta $0300			sta 	StringPtr
.0199ce	85 12		sta $12				sta 	zTemp2
.0199d0	ad 01 03	lda $0301			lda 	StringPtr+1
.0199d3	e9 00		sbc #$00			sbc 	#0
.0199d5	8d 01 03	sta $0301			sta 	StringPtr+1
.0199d8	85 13		sta $13				sta 	zTemp2+1
.0199da	b1 10		lda ($10),y			lda 	(zTemp1),y 					; length add one for count
.0199dc	1a		inc a				inc 	a
.0199dd	aa		tax				tax
.0199de	b1 10		lda ($10),y	_SCCopy:lda 	(zTemp1),y 					; copy whole thing including length
.0199e0	91 12		sta ($12),y			sta 	(zTemp2),y
.0199e2	c8		iny				iny
.0199e3	ca		dex				dex
.0199e4	d0 f8		bne $0199de			bne 	_SCCopy
.0199e6	a5 13		lda $13				lda 	zTemp2+1 					; return concrete string in AX
.0199e8	a6 12		ldx $12				ldx 	zTemp2
.0199ea	60		rts				rts
.0199eb					_SCEmpty:
.0199eb	a9 00		lda #$00			lda 	#0
.0199ed	85 27		sta $27				sta 	zNullString
.0199ef	a9 00		lda #$00			lda 	#zNullString >> 8
.0199f1	a2 27		ldx #$27			ldx 	#zNulLString & $FF
.0199f3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.0199f4					AllocateTempString:
.0199f4	48		pha				pha 								; save required count.
.0199f5	a5 23		lda $23				lda 	zTempStr+1 					; check if initialised yet ?
.0199f7	d0 0b		bne $019a04			bne 	_ATSInitialised
.0199f9	ad 00 03	lda $0300			lda 	StringPtr 					; set temporary string ptr 1 page below available
.0199fc	85 22		sta $22				sta 	zTempStr					; space, this is for strings to be concreted.
.0199fe	ad 01 03	lda $0301			lda 	StringPtr+1
.019a01	3a		dec a				dec 	a 							; allow the page.
.019a02	85 23		sta $23				sta 	zTempStr+1
.019a04					_ATSInitialised:
.019a04	68		pla				pla 								; get required count back.
.019a05	49 ff		eor #$ff			eor 	#$FF 						; negate and add 2's complement.
.019a07	1a		inc a				inc 	a
.019a08	18		clc				clc
.019a09	65 22		adc $22				adc 	zTempStr 					; "add" to the temp string pointer
.019a0b	85 22		sta $22				sta 	zTempStr					; which means the tsp is also the current.
.019a0d	a9 ff		lda #$ff			lda 	#$FF
.019a0f	65 23		adc $23				adc 	zTempStr+1
.019a11	85 23		sta $23				sta 	zTempStr+1
.019a13	a9 00		lda #$00			lda 	#0 							; clear temp string by zeroing length.
.019a15	5a		phy				phy
.019a16	a8		tay				tay
.019a17	91 22		sta ($22),y			sta 	(zTempStr),y
.019a19	7a		ply				ply
.019a1a	1a		inc a				inc 	a 							; reset the write index to 1 (first character)
.019a1b	8d 9f 03	sta $039f			sta 	TempStringWriteIndex
.019a1e	60		rts				rts
.019a1f					WriteTempString:
.019a1f	5a		phy				phy 								; save Y
.019a20	ac 9f 03	ldy $039f			ldy 	TempStringWriteIndex	 	; write position.
.019a23	91 22		sta ($22),y			sta 	(zTempStr),y 				; write character out.
.019a25	ee 9f 03	inc $039f			inc 	TempStringWriteIndex 		; increment the write position.
.019a28	98		tya				tya 								; unchanged Y is now length
.019a29	a0 00		ldy #$00			ldy 	#0
.019a2b	91 22		sta ($22),y			sta 	(zTempStr),y
.019a2d	7a		ply				ply 								; restore Y and exit
.019a2e	60		rts				rts
.019a2f					CreateTempStringCopy:
.019a2f	da		phx				phx 								; save X
.019a30	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019a32	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.019a33	20 f4 99	jsr $0199f4			jsr 	AllocateTempString 			; allocate memory for temporary string.
.019a36	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019a38	c8		iny				iny
.019a39	3a		dec a				dec 	a 							; make the actual length in characters, allowing
.019a3a	3a		dec a				dec 	a 							; for the marker and the length.
.019a3b	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.019a3d	81 22		sta ($22,x)			sta 	(zTempStr,x)
.019a3f	85 1c		sta $1c				sta 	zLTemp1 					; that's used as a count.
.019a41	09 00		ora #$00			ora 	#0 							; if zero already, exit
.019a43	f0 0e		beq $019a53			beq 	_CTSCExit
.019a45					_CTSCLoop:
.019a45	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019a47	c8		iny				iny
.019a48	5a		phy				phy 								; save Y
.019a49	e8		inx				inx 								; bump index
.019a4a	da		phx				phx 								; save that
.019a4b	7a		ply				ply 								; index into Y
.019a4c	91 22		sta ($22),y			sta 	(zTempStr),y 				; save at index position
.019a4e	7a		ply				ply 								; restore Y
.019a4f	c6 1c		dec $1c				dec 	zLTemp1 					; do for each character, this is the counter.
.019a51	d0 f2		bne $019a45			bne 	_CTSCLoop
.019a53					_CTSCExit:
.019a53	fa		plx				plx 								; restore X
.019a54	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/basic/tokenise/tokkeyword.asm

.019a55					TokeniseKeyword:
.019a55	98		tya				tya 								; fix up genptr so Y = 0 access the current one.
.019a56	18		clc				clc
.019a57	65 20		adc $20				adc 	zGenPtr
.019a59	85 20		sta $20				sta 	zGenPtr
.019a5b	90 02		bcc $019a5f			bcc 	_TKWNoBump
.019a5d	e6 21		inc $21				inc 	zGenPtr+1
.019a5f					_TKWNoBump:
.019a5f	a0 00		ldy #$00			ldy 	#0 							; this adds Y to genPtr, so it will still scan
.019a61	da		phx				phx
.019a62	a9 cd		lda #$cd			lda 	#KeyWordText & $FF 			; scan this table.
.019a64	a2 86		ldx #$86			ldx 	#(KeyWordText >> 8) & $FF
.019a66	20 71 9a	jsr $019a71			jsr 	TKWScanTokenTable
.019a69	fa		plx				plx
.019a6a	90 04		bcc $019a70			bcc 	_TKWNoWrite
.019a6c	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x 			; write the token out.
.019a6f	e8		inx				inx
.019a70					_TKWNoWrite:
.019a70	60		rts				rts
.019a71					TKWScanTokenTable:
.019a71	86 1d		stx $1d				stx 	zLTemp1+1
.019a73	85 1c		sta $1c				sta 	zLTemp1+0 						; store at zLTemp1
.019a75	a9 01		lda #$01			lda 	#KeywordText >> 16 				; 24 bit addresses in the 65816
.019a77	85 1e		sta $1e				sta 	zLTemp1+2 						; lovely.
.019a79	a0 00		ldy #$00			ldy 	#0 								; read and capitalise the first character
.019a7b	84 12		sty $12				sty 	zTemp2 							; zero the longest length match.
.019a7d	b1 20		lda ($20),y			lda 	(zGenPtr),y
.019a7f	20 8c 9b	jsr $019b8c			jsr 	TOKCapitalise 					; save this in zTemp3
.019a82	85 14		sta $14				sta 	zTemp3
.019a84	a9 80		lda #$80			lda 	#$80 							; current token in zTemp3+1
.019a86	85 15		sta $15				sta 	zTemp3+1
.019a88					_TKWScanLoop:
.019a88	b7 1c		lda [$1c],y			lda 	[zLTemp1],y
.019a8a	29 7f		and #$7f			and 	#$7F 							; drop bit 7, it might be 1 character long.
.019a8c	c5 14		cmp $14				cmp 	zTemp3 							; compare against got character.
.019a8e	d0 26		bne $019ab6			bne		_TKWNext 						; if it doesn't match, go to next.
.019a90	20 d5 9a	jsr $019ad5			jsr 	_TKWClearY 						; make it so (zTemp1),y now points to zTemp1
.019a93	a0 00		ldy #$00			ldy 	#0 								; compare the tokens directly
.019a95					_TKWCompareFull:
.019a95	b7 1c		lda [$1c],y			lda 	[zLTemp1],y
.019a97	29 7f		and #$7f			and 	#$7F 							; drop bit 7
.019a99	85 16		sta $16				sta 	zTemp4
.019a9b	b1 20		lda ($20),y			lda 	(zGenPtr),y 					; compare against keyword in text.
.019a9d	20 8c 9b	jsr $019b8c			jsr 	TOKCapitalise 					; make it U/C
.019aa0	c5 16		cmp $16				cmp 	zTemp4 							; compare against table char w/o bit 7.
.019aa2	d0 12		bne $019ab6			bne 	_TKWNext 						; failed, go to next slot.
.019aa4	b7 1c		lda [$1c],y			lda 	[zLTemp1],y
.019aa6	c8		iny				iny 									; bump pointer
.019aa7	0a		asl a				asl 	a 								; shift bit 7 into C
.019aa8	90 eb		bcc $019a95			bcc 	_TKWCompareFull					; keep going till that bit is 7 e.g. token matches
.019aaa	c4 12		cpy $12				cpy 	zTemp2 							; compare against longest match
.019aac	90 08		bcc $019ab6			bcc 	_TKWNext 						; if shorter, the original was better
.019aae	84 12		sty $12				sty 	zTemp2							; update longest match.
.019ab0	a5 15		lda $15				lda 	zTemp3+1 						; copy current token
.019ab2	85 13		sta $13				sta 	zTemp2+1 						; into matched token slot.
.019ab4	a0 00		ldy #$00			ldy 	#0 								; reset to start of matched token for forward
.019ab6					_TKWNext:
.019ab6	b7 1c		lda [$1c],y			lda 	[zLTemp1],y
.019ab8	c8		iny				iny 									; next one.
.019ab9	0a		asl a				asl 	a 								; if bit 7 clear loop back.
.019aba	90 fa		bcc $019ab6			bcc 	_TKWNext
.019abc	e6 15		inc $15				inc 	zTemp3+1 						; increment current token.
.019abe	98		tya				tya 									; has Y gone negative.
.019abf	10 03		bpl $019ac4			bpl 	_TKWNoYZero
.019ac1	20 d5 9a	jsr $019ad5			jsr 	_TKWClearY 						; make it so (zTemp1),y now points to zTemp1
.019ac4					_TKWNoYZero:
.019ac4	b7 1c		lda [$1c],y			lda 	[zLTemp1],y
.019ac6	d0 c0		bne $019a88			bne 	_TKWScanLoop 					; if not, try the next one.
.019ac8	a5 12		lda $12				lda 	zTemp2 							; length of longest match
.019aca	f0 05		beq $019ad1			beq 	_TKWFail 						; if zero, none found.
.019acc	a8		tay				tay 									; return the token in zTemp2, length => y
.019acd	a5 13		lda $13				lda 	zTemp2+1 						; so the offset is right.
.019acf	38		sec				sec
.019ad0	60		rts				rts
.019ad1					_TKWFail:
.019ad1	a0 00		ldy #$00			ldy 	#0 								; return with Y = 0 and carry clear.
.019ad3	18		clc				clc
.019ad4	60		rts				rts
.019ad5					_TKWClearY:
.019ad5	98		tya				tya
.019ad6	18		clc				clc
.019ad7	65 1c		adc $1c				adc 	zLTemp1
.019ad9	85 1c		sta $1c				sta 	zLTemp1
.019adb	90 02		bcc $019adf			bcc 	_TKWCNoBump
.019add	e6 1d		inc $1d				inc 	zLTemp1+1
.019adf					_TKWCNoBump:
.019adf	a0 00		ldy #$00			ldy 	#0
.019ae1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/tokenise/tokenise.asm

.019ae2					TokeniseString:
.019ae2	85 20		sta $20				sta 	zGenPtr 					; save source
.019ae4	86 21		stx $21				stx 	zGenPtr+1
.019ae6	a0 00		ldy #$00			ldy 	#0 							; source
.019ae8	a2 03		ldx #$03			ldx 	#3 							; target
.019aea	8c 00 04	sty $0400			sty 	TokeniseBuffer+0 			; write three NULLs. So it looks like
.019aed	8c 01 04	sty $0401			sty 	TokeniseBuffer+1 			; there's a line number zero.
.019af0	8c 02 04	sty $0402			sty 	TokeniseBuffer+2
.019af3					_TSMainLoop:
.019af3					_TSSkipSpaces:
.019af3	b1 20		lda ($20),y			lda 	(zGenPtr),y					; skip over spaces.
.019af5	c8		iny				iny
.019af6	c9 20		cmp #$20			cmp 	#" "
.019af8	f0 f9		beq $019af3			beq 	_TSSkipSpaces
.019afa	c9 30		cmp #$30			cmp 	#"0" 						; is it a constant
.019afc	90 0a		bcc $019b08			bcc 	_TSNotConstant
.019afe	c9 3a		cmp #$3a			cmp 	#"9"+1
.019b00	b0 06		bcs $019b08			bcs 	_TSNotConstant
.019b02	88		dey				dey 								; point back to start
.019b03	20 27 9c	jsr $019c27			jsr 	TokeniseConstant 			; tokenise a constant
.019b06	80 eb		bra $019af3			bra 	_TSMainLoop			 		; and loop back.
.019b08					_TSNotConstant:
.019b08	c9 20		cmp #$20			cmp 	#32 						; end of line.
.019b0a	90 52		bcc $019b5e			bcc 	_TSExit
.019b0c	c9 22		cmp #$22			cmp		#'"'						; quoted string
.019b0e	f0 55		beq $019b65			beq 	_TSQuotedString
.019b10	c9 2e		cmp #$2e			cmp 	#'.' 						; decimal.
.019b12	f0 56		beq $019b6a			beq 	_TSDecimal
.019b14	20 8c 9b	jsr $019b8c			jsr 	TOKCapitalise 				; make U/C
.019b17	c9 52		cmp #$52			cmp 	#"R" 						; is it R, if so check for REM ?
.019b19	d0 05		bne $019b20			bne 	_TSNoRemCheck
.019b1b	20 6f 9b	jsr $019b6f			jsr 	TOKCheckREM
.019b1e	b0 d3		bcs $019af3			bcs 	_TSMainLoop 				; and if REM okay, go back.
.019b20					_TSNoRemCheck:
.019b20	88		dey				dey 								; point to character
.019b21	20 55 9a	jsr $019a55			jsr 	TokeniseKeyword 			; try to tokenise a keyword.
.019b24	b0 cd		bcs $019af3			bcs 	_TSMainLoop					; true if tokenised okay.
.019b26	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; get character
.019b28	20 8c 9b	jsr $019b8c			jsr 	TOKCapitalise
.019b2b	c9 41		cmp #$41			cmp 	#"A"						; is it A-Z, if so it's an alphanumeric sequence.
.019b2d	90 04		bcc $019b33			bcc 	_TSSingle
.019b2f	c9 5b		cmp #$5b			cmp 	#"Z"+1
.019b31	90 0d		bcc $019b40			bcc 	_TSAlphaNumeric
.019b33					_TSSingle:
.019b33	c8		iny				iny 								; skip over output
.019b34	29 3f		and #$3f			and 	#63 						; make 6 bit ASCII
.019b36	09 80		ora #$80			ora 	#128
.019b38	f0 b9		beq $019af3			beq 	_TSMainLoop 				; ignore @, which doesn't tokenise.
.019b3a	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.019b3d	e8		inx				inx
.019b3e	80 b3		bra $019af3			bra 	_TSMainLoop
.019b40					_TSAlphaNumeric:
.019b40	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; get
.019b42	20 8c 9b	jsr $019b8c			jsr 	TOKCapitalise
.019b45	c9 30		cmp #$30			cmp 	#"0" 	 					; check 0-9
.019b47	90 aa		bcc $019af3			bcc 	_TSMainLoop
.019b49	c9 3a		cmp #$3a			cmp 	#"9"+1
.019b4b	90 0a		bcc $019b57			bcc 	_TSANOkay
.019b4d	c9 41		cmp #$41			cmp 	#"A"						; check A-Z
.019b4f	90 a2		bcc $019af3			bcc 	_TSMainLoop
.019b51	c9 5b		cmp #$5b			cmp 	#"Z"+1
.019b53	b0 9e		bcs $019af3			bcs 	_TSMainLoop
.019b55	29 3f		and #$3f			and 	#63 						; write it out
.019b57					_TSANOkay:
.019b57	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.019b5a	e8		inx				inx
.019b5b	c8		iny				iny
.019b5c	80 e2		bra $019b40			bra 	_TSAlphaNumeric
.019b5e	a9 00		lda #$00	_TSExit:lda 	#0 							; mark end of line.
.019b60	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.019b63	8a		txa				txa 								; return length of tokenised line in bytes.
.019b64	60		rts				rts
.019b65					_TSQuotedString:
.019b65	20 c5 9b	jsr $019bc5			jsr 	TokeniseQuotedString
.019b68	80 89		bra $019af3			bra 	_TSMainLoop
.019b6a					_TSDecimal:
.019b6a	20 eb 9b	jsr $019beb			jsr 	TokeniseDecimalString
.019b6d	80 84		bra $019af3			bra 	_TSMainLoop
.019b6f					TOKCheckREM:
.019b6f	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; check E
.019b71	20 8c 9b	jsr $019b8c			jsr 	TOKCapitalise
.019b74	c9 45		cmp #$45			cmp 	#"E"
.019b76	d0 12		bne $019b8a			bne 	_TCRFail
.019b78	c8		iny				iny
.019b79	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; check M
.019b7b	88		dey				dey
.019b7c	20 8c 9b	jsr $019b8c			jsr 	TOKCapitalise
.019b7f	c9 4d		cmp #$4d			cmp 	#"M"
.019b81	d0 07		bne $019b8a			bne 	_TCRFail
.019b83	c8		iny				iny									; point to first character
.019b84	c8		iny				iny
.019b85	20 97 9b	jsr $019b97			jsr 	TokeniseREMString 			; tokenise REM
.019b88	38		sec				sec
.019b89	60		rts				rts
.019b8a					_TCRFail:
.019b8a	18		clc				clc
.019b8b	60		rts				rts
.019b8c					TOKCapitalise:
.019b8c	c9 61		cmp #$61			cmp 	#"a"
.019b8e	90 06		bcc $019b96			bcc 	_TOKCExit
.019b90	c9 7b		cmp #$7b			cmp 	#"z"+1
.019b92	b0 02		bcs $019b96			bcs 	_TOKCExit
.019b94	49 20		eor #$20			eor 	#$20
.019b96					_TOKCExit:
.019b96	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/tokenise/tokseq.asm

.019b97					TokeniseREMString:
.019b97	86 10		stx $10				stx 	zTemp1 						; save position
.019b99	a9 ff		lda #$ff			lda 	#$FF 						; write marker
.019b9b	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.019b9e	9d 01 04	sta $0401,x			sta 	TokeniseBuffer+1,x 			; stops space removal.
.019ba1	e8		inx				inx 								; bump, and one space for the count.
.019ba2	e8		inx				inx
.019ba3					_TSRSkip:
.019ba3	b1 20		lda ($20),y			lda 	(zGenPtr),y
.019ba5	c8		iny				iny
.019ba6	c9 20		cmp #$20			cmp 	#" "
.019ba8	f0 f9		beq $019ba3			beq 	_TSRSkip
.019baa	c9 3a		cmp #$3a			cmp 	#":"						; first char is a colon
.019bac	f0 31		beq $019bdf			beq 	SequenceExit 				; ... that's it.
.019bae					_TSRCopy:
.019bae	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x 			; write out
.019bb1	e8		inx				inx
.019bb2	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; get next
.019bb4	f0 05		beq $019bbb			beq 	_TSRExit 					; zero is exit
.019bb6	c8		iny				iny 								; bump pointer
.019bb7	c9 3a		cmp #$3a			cmp 	#":"						; loop back if not colon.
.019bb9	d0 f3		bne $019bae			bne 	_TSRCopy
.019bbb					_TSRExit:
.019bbb	bd ff 03	lda $03ff,x			lda 	TokeniseBuffer-1,x 			; previous char space ?
.019bbe	c9 20		cmp #$20			cmp 	#" "
.019bc0	d0 1d		bne $019bdf			bne 	SequenceExit
.019bc2	ca		dex				dex 								; go back - will bump into $FF eventually.
.019bc3	80 f6		bra $019bbb			bra 	_TSRExit
.019bc5					TokeniseQuotedString:
.019bc5	86 10		stx $10				stx 	zTemp1 						; save position
.019bc7	a9 fe		lda #$fe			lda 	#$FE 						; write marker
.019bc9	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.019bcc	e8		inx				inx 								; bump, and one space for the count.
.019bcd	e8		inx				inx
.019bce					_TSQCopy:
.019bce	b1 20		lda ($20),y			lda 	(zGenPtr),y
.019bd0	c9 20		cmp #$20			cmp 	#" "
.019bd2	90 0b		bcc $019bdf			bcc 	SequenceExit 				; if < ' ' then exit, didn't find end.
.019bd4	c8		iny				iny
.019bd5	c9 22		cmp #$22			cmp 	#'"'						; if = quote, consume it and exit.
.019bd7	f0 06		beq $019bdf			beq 	SequenceExit
.019bd9	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x 			; write out and loop
.019bdc	e8		inx				inx
.019bdd	80 ef		bra $019bce			bra 	_TSQCopy
.019bdf					SequenceExit:
.019bdf	8a		txa				txa 								; current position
.019be0	38		sec				sec 								; subtract start.
.019be1	e5 10		sbc $10				sbc 	zTemp1
.019be3	da		phx				phx 								; copy that in
.019be4	a6 10		ldx $10				ldx 	zTemp1
.019be6	9d 01 04	sta $0401,x			sta 	TokeniseBuffer+1,x
.019be9	fa		plx				plx
.019bea	60		rts				rts
.019beb					TokeniseDecimalString:
.019beb	86 10		stx $10				stx 	zTemp1 						; save position
.019bed	a9 fd		lda #$fd			lda 	#$FD 						; write marker
.019bef	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.019bf2	e8		inx				inx 								; bump, and one space for the count.
.019bf3	e8		inx				inx
.019bf4	20 15 9c	jsr $019c15			jsr 	_TDSCopyNumber 				; copy a number.
.019bf7	b1 20		lda ($20),y			lda 	(zGenPtr),y	 				; next letter.
.019bf9	20 8c 9b	jsr $019b8c			jsr 	TOKCapitalise
.019bfc	c9 45		cmp #$45			cmp 	#"E" 						; if not an exponent.
.019bfe	d0 df		bne $019bdf			bne 	SequenceExit 				; exit now.
.019c00	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x 			; write E out
.019c03	e8		inx				inx
.019c04	c8		iny				iny
.019c05	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; followed by a minus ?
.019c07	c9 2d		cmp #$2d			cmp 	#"-"
.019c09	d0 05		bne $019c10			bne 	_TDSNoMinusExponent
.019c0b	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x 			; write - out
.019c0e	e8		inx				inx
.019c0f	c8		iny				iny
.019c10					_TDSNoMinusExponent:
.019c10	20 15 9c	jsr $019c15			jsr 	_TDSCopyNumber 				; do the exponent
.019c13	80 ca		bra $019bdf			bra 	SequenceExit
.019c15					_TDSCopyNumber:
.019c15	b1 20		lda ($20),y			lda 	(zGenPtr),y
.019c17	c9 30		cmp #$30			cmp 	#"0"
.019c19	90 0b		bcc $019c26			bcc 	_TDSCNExit
.019c1b	c9 3a		cmp #$3a			cmp 	#"9"+1
.019c1d	b0 07		bcs $019c26			bcs 	_TDSCNExit
.019c1f	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.019c22	e8		inx				inx
.019c23	c8		iny				iny
.019c24	80 ef		bra $019c15			bra 	_TDSCopyNumber
.019c26					_TDSCNExit:
.019c26	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/tokenise/tokconst.asm

.019c27					TokeniseConstant:
.019c27	da		phx				phx 								; save X
.019c28	a2 00		ldx #$00			ldx 	#0
.019c2a	20 fb a1	jsr $01a1fb			jsr 	IntFromStringY 				; get the integer out.
.019c2d	b0 37		bcs $019c66			bcs 	_TCQ 						; should not happen.
.019c2f	fa		plx				plx 								; restore X.
.019c30	a9 00		lda #$00			lda 	#0 							; zero count of restores.
.019c32	85 10		sta $10				sta 	zTemp1
.019c34					_TCRotate:
.019c34	a5 80		lda $80				lda 	XS_Mantissa+0 				; check bits 6/7 of 0
.019c36	29 c0		and #$c0			and 	#$C0
.019c38	05 81		ora $81				ora 	XS_Mantissa+1	 			; and 1/2/3 all zero
.019c3a	05 82		ora $82				ora 	XS_Mantissa+2
.019c3c	05 83		ora $83				ora 	XS_Mantissa+3
.019c3e	f0 16		beq $019c56			beq 	_TCDone						; if so, at the bottom.
.019c40	a5 80		lda $80				lda 	XS_Mantissa+0 				; push lower 6 bits of 0
.019c42	29 3f		and #$3f			and 	#$3F
.019c44	48		pha				pha
.019c45	e6 10		inc $10				inc 	zTemp1 						; increment the pop count.
.019c47	a9 06		lda #$06			lda 	#6 							; shift right 6 times
.019c49					_TCShiftRight:
.019c49	46 83		lsr $83				lsr 	XS_Mantissa+3
.019c4b	66 82		ror $82				ror 	XS_Mantissa+2
.019c4d	66 81		ror $81				ror 	XS_Mantissa+1
.019c4f	66 80		ror $80				ror 	XS_Mantissa+0
.019c51	3a		dec a				dec 	a
.019c52	d0 f5		bne $019c49			bne 	_TCShiftRight
.019c54	80 de		bra $019c34			bra 	_TCRotate 					; and go round again.
.019c56	a5 80		lda $80		_TCDone:lda 	XS_Mantissa+0
.019c58					_TCWrite:
.019c58	09 40		ora #$40			ora 	#$40						; write it out as inttoken
.019c5a	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.019c5d	e8		inx				inx
.019c5e	c6 10		dec $10				dec 	zTemp1 						; done all of them
.019c60	30 03		bmi $019c65			bmi 	_TCExit 					; no , more to pop
.019c62	68		pla				pla
.019c63	80 f3		bra $019c58			bra 	_TCWrite 					; until everything's off.
.019c65					_TCExit:
.019c65	60		rts				rts
.019c66					_TCQ:
.019c66	20 86 85	jsr $018586			jsr ERR_Handler
>019c69	54 4b 00				.text "TK",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/variables.asm

.019c6c					VariableFind:
.019c6c	20 d9 9c	jsr $019cd9			jsr 	VariableExtract 		; find out all about it ....
.019c6f	20 72 9f	jsr $019f72			jsr 	VariableLocate 			; does it already exist ?
.019c72	b0 03		bcs $019c77			bcs 	_VFExists 				; if so, use that.
.019c74	20 65 9d	jsr $019d65			jsr 	VariableCreate 			; otherwise create it.
.019c77					_VFExists:
.019c77	a5 26		lda $26				lda 	zVarType 				; is it still an array ?
.019c79	29 01		and #$01			and 	#1
.019c7b	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.019c7d	d0 28		bne $019ca7			bne 	_VFSingleElement
.019c7f					_VFNextIndex:
.019c7f	a5 24		lda $24				lda 	zVarDataPtr 			; push the data ptr and type on the stack.
.019c81	48		pha				pha
.019c82	a5 25		lda $25				lda 	zVarDataPtr+1
.019c84	48		pha				pha
.019c85	a5 26		lda $26				lda 	zVarType
.019c87	48		pha				pha
.019c88	20 a1 93	jsr $0193a1			jsr 	EvaluateInteger 		; calculate the index.
.019c8b	68		pla				pla 							; restore and index.
.019c8c	85 26		sta $26				sta 	zVarType
.019c8e	68		pla				pla
.019c8f	85 25		sta $25				sta 	zVarDataPtr+1
.019c91	68		pla				pla
.019c92	85 24		sta $24				sta 	zVarDataPtr
.019c94	20 f0 9d	jsr $019df0			jsr 	ArrayIndexFollow 		; do the index.
.019c97	a5 26		lda $26				lda 	zVarType 				; is it still an array ??
.019c99	29 01		and #$01			and 	#1
.019c9b	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.019c9d	d0 05		bne $019ca4			bne 	_VFArrayDone 			; if so then exit.
.019c9f	20 af 99	jsr $0199af			jsr 	CheckNextComma 			; comma should follow
.019ca2	80 db		bra $019c7f			bra 	_VFNextIndex
.019ca4					_VFArrayDone:
.019ca4	20 a7 99	jsr $0199a7			jsr 	CheckNextRParen 		; check closing right bracket.
.019ca7					_VFSingleElement:
.019ca7	60		rts				rts
.019ca8					VariableClear:
.019ca8	48		pha				pha 							; save registers
.019ca9	da		phx				phx
.019caa	a2 00		ldx #$00			ldx 	#0 						; clear out the hash table.
.019cac	8a		txa				txa
.019cad	9d 35 03	sta $0335,x	_VCLoop:sta 	HashTableBase,x
.019cb0	e8		inx				inx
.019cb1	e0 60		cpx #$60			cpx 	#HashTableEnd-HashTableBase
.019cb3	d0 f8		bne $019cad			bne 	_VCLoop
.019cb5	ad 04 03	lda $0304			lda 	endOfProgram
.019cb8	8d 02 03	sta $0302			sta 	VarMemPtr
.019cbb	ad 05 03	lda $0305			lda 	endOfProgram+1
.019cbe	8d 03 03	sta $0303			sta 	VarMemPtr+1
.019cc1	fa		plx				plx 							; restore registers
.019cc2	68		pla				pla
.019cc3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/extract.asm

.019cc4					VariableNameError:
.019cc4	20 86 85	jsr $018586			jsr ERR_Handler
>019cc7	42 61 64 20 56 61 72 69			.text "Bad Variable Name",0
>019ccf	61 62 6c 65 20 4e 61 6d 65 00
.019cd9					VariableExtract:
.019cd9	da		phx				phx 							; save X.
.019cda	a9 ba		lda #$ba			lda 	#token_hashlParen  		; set the type to #( e.g. real array.
.019cdc	8d 95 03	sta $0395			sta 	Var_Type
.019cdf	8d 96 03	sta $0396			sta 	Var_Hash 				; we initialise the hash with this. It doesn't matter
.019ce2	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019ce4	c9 00		cmp #$00			cmp 	#0 						; first one must be A-Z
.019ce6	f0 dc		beq $019cc4			beq 	VariableNameError
.019ce8	c9 1b		cmp #$1b			cmp 	#26+1
.019cea	b0 d8		bcs $019cc4			bcs 	VariableNameError
.019cec	a2 ff		ldx #$ff			ldx 	#255 					; now copy it into the variable buffer.
.019cee					_VECopyBuffer:
.019cee	e8		inx				inx
.019cef	e0 1f		cpx #$1f			cpx 	#31 					; too long
.019cf1	f0 d1		beq $019cc4			beq 	VariableNameError
.019cf3	9d 15 03	sta $0315,x			sta 	Var_Buffer,x 			; save character
.019cf6	18		clc				clc  							; update the hash value for it.
.019cf7	6d 96 03	adc $0396			adc 	Var_Hash
.019cfa	8d 96 03	sta $0396			sta 	Var_Hash
.019cfd	c8		iny				iny
.019cfe	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019d00	c9 00		cmp #$00			cmp 	#0 						; zero or token, end of variable
.019d02	f0 0e		beq $019d12			beq 	_VECopyEnd
.019d04	30 0c		bmi $019d12			bmi 	_VECopyEnd
.019d06	c9 1b		cmp #$1b			cmp 	#26+1 					; A-Z continue copying
.019d08	90 e4		bcc $019cee			bcc 	_VECopyBuffer
.019d0a	c9 30		cmp #$30			cmp 	#"0" 					; 0-9 copy as well.
.019d0c	90 04		bcc $019d12			bcc 	_VECopyEnd
.019d0e	c9 3a		cmp #$3a			cmp 	#"9"+1
.019d10	90 dc		bcc $019cee			bcc 	_VECopyBuffer
.019d12					_VECopyEnd:
.019d12	c8		iny				iny
.019d13	c9 b7		cmp #$b7			cmp 	#token_Dollar 			; first type token.
.019d15	90 04		bcc $019d1b			bcc 	_VEDefaultRequired
.019d17	c9 bd		cmp #$bd			cmp 	#token_PercentLParen+1	; last type token.
.019d19	90 0b		bcc $019d26			bcc 	_VEHaveType
.019d1b					_VEDefaultRequired:
.019d1b	c9 bd		cmp #$bd			cmp 	#token_LParen 			; if it ends in ( then use the real array
.019d1d	f0 04		beq $019d23			beq 	_VESetType 				; default set above.
.019d1f	ce 95 03	dec $0395			dec 	Var_Type 				; this changes that default to the variable default
.019d22	88		dey				dey
.019d23					_VESetType:
.019d23	ad 95 03	lda $0395			lda 	Var_Type 				; get type ....
.019d26					_VEHaveType:
.019d26	8d 95 03	sta $0395			sta 	Var_Type 				; save as type.
.019d29	bd 15 03	lda $0315,x			lda 	Var_Buffer,x 			; set bit 7 of name, marks the end.
.019d2c	09 80		ora #$80			ora 	#$80
.019d2e	9d 15 03	sta $0315,x			sta 	Var_Buffer,x
.019d31	e8		inx				inx 							; offset 3 => length 4.
.019d32	8e 97 03	stx $0397			stx 	Var_Length 				; save length of variable name.
.019d35	ad 95 03	lda $0395			lda 	Var_Type 				; get offset of var type from first type token
.019d38	38		sec				sec
.019d39	e9 b7		sbc #$b7			sbc 	#token_Dollar
.019d3b	0a		asl a				asl 	a 						; multiply by 16. This requires HashTableSize
.019d3c	0a		asl a				asl 	a 						; in data.asm to be 8 (8 sets of links,2 bytes each)
.019d3d	0a		asl a				asl 	a
.019d3e	0a		asl a				asl 	a
.019d3f	8d 98 03	sta $0398			sta 	Var_HashAddress
.019d42	ad 96 03	lda $0396			lda 	Var_Hash 				; get the hash
.019d45	29 07		and #$07			and 	#(HashTableSize-1) 		; force into range 0-tableSize-1
.019d47	0a		asl a				asl 	a 						; double it (2 bytes per entry) & clears carry
.019d48	6d 98 03	adc $0398			adc 	Var_HashAddress 		; add table offset.
.019d4b	69 35		adc #$35			adc 	#HashTableBase & $FF 	; now the low byte of the actual table address
.019d4d	8d 98 03	sta $0398			sta 	Var_HashAddress
.019d50	a2 05		ldx #$05			ldx 	#5 						; hash is 5 bytes (real)
.019d52	ad 95 03	lda $0395			lda 	Var_Type
.019d55	c9 b9		cmp #$b9			cmp 	#token_Hash
.019d57	f0 07		beq $019d60			beq 	_VEHaveSize
.019d59	ca		dex				dex
.019d5a	c9 bb		cmp #$bb			cmp 	#token_Percent 			; percent is 4 bytes (integer)
.019d5c	f0 02		beq $019d60			beq 	_VEHaveSize
.019d5e	a2 02		ldx #$02			ldx 	#2 						; everything else is two.
.019d60					_VEHaveSize:
.019d60	8e 99 03	stx $0399			stx 	Var_DataSize
.019d63	fa		plx				plx
.019d64	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varcreate.asm

.019d65					VariableCreate:
.019d65	da		phx				phx
.019d66	5a		phy				phy
.019d67	ad 02 03	lda $0302			lda 	VarMemPtr 					; get address of next free into zTemp1
.019d6a	85 10		sta $10				sta 	zTemp1
.019d6c	ad 03 03	lda $0303			lda 	VarMemPtr+1
.019d6f	85 11		sta $11				sta 	zTemp1+1
.019d71	ad 99 03	lda $0399			lda 	Var_DataSize 				; bytes for the data bit
.019d74	18		clc				clc
.019d75	6d 97 03	adc $0397			adc 	Var_Length 					; add the length of the name
.019d78	69 03		adc #$03			adc 	#3 							; 3 for the link and the hash.
.019d7a	6d 02 03	adc $0302			adc 	VarMemPtr 					; add to variable memory pointer
.019d7d	8d 02 03	sta $0302			sta 	VarMemPtr
.019d80	90 03		bcc $019d85			bcc 	_VCNoCarry
.019d82	ee 03 03	inc $0303			inc 	VarMemPtr+1
.019d85					_VCNoCarry:
.019d85	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.019d88	85 12		sta $12				sta 	zTemp2
.019d8a	a9 03		lda #$03			lda 	#HashTableBase >> 8
.019d8c	85 13		sta $13				sta 	zTemp2+1
.019d8e	a0 00		ldy #$00			ldy 	#0 							; put current hash link in position.
.019d90	b1 12		lda ($12),y			lda 	(zTemp2),y
.019d92	91 10		sta ($10),y			sta 	(zTemp1),y
.019d94	c8		iny				iny
.019d95	b1 12		lda ($12),y			lda 	(zTemp2),y
.019d97	91 10		sta ($10),y			sta 	(zTemp1),y
.019d99	c8		iny				iny
.019d9a	ad 96 03	lda $0396			lda 	Var_Hash 					; write the hash out.
.019d9d	91 10		sta ($10),y			sta 	(zTemp1),y
.019d9f	c8		iny				iny
.019da0	a2 00		ldx #$00			ldx 	#0 							; copy the name out.
.019da2					_VCCopyName:
.019da2	bd 15 03	lda $0315,x			lda 	Var_Buffer,x
.019da5	91 10		sta ($10),y			sta 	(zTemp1),y
.019da7	e8		inx				inx
.019da8	c8		iny				iny
.019da9	ec 97 03	cpx $0397			cpx 	Var_Length
.019dac	d0 f4		bne $019da2			bne 	_VCCopyName
.019dae	5a		phy				phy 								; save the data offset.
.019daf	ae 99 03	ldx $0399			ldx 	Var_DataSize 				; and write the data out.
.019db2	a9 00		lda #$00			lda 	#0 							; which is all zeroes.
.019db4					_VCClearData:
.019db4	91 10		sta ($10),y			sta 	(zTemp1),y
.019db6	c8		iny				iny
.019db7	ca		dex				dex
.019db8	d0 fa		bne $019db4			bne 	_VCClearData
.019dba	68		pla				pla 								; offset to the data
.019dbb	18		clc				clc
.019dbc	65 10		adc $10				adc 	zTemp1 						; add to start and save as data pointer.
.019dbe	85 24		sta $24				sta 	zVarDataPtr
.019dc0	a5 11		lda $11				lda 	zTemp1+1
.019dc2	69 00		adc #$00			adc 	#0
.019dc4	85 25		sta $25				sta 	zVarDataPtr+1
.019dc6	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.019dc9	85 26		sta $26				sta 	zVarType
.019dcb	a5 10		lda $10				lda 	zTemp1 						; fix hash link to point to new record
.019dcd	a0 00		ldy #$00			ldy 	#0
.019dcf	91 12		sta ($12),y			sta 	(zTemp2),y
.019dd1	c8		iny				iny
.019dd2	a5 11		lda $11				lda 	zTemp1+1
.019dd4	91 12		sta ($12),y			sta 	(zTemp2),y
.019dd6	ad 95 03	lda $0395			lda 	Var_Type 					; array ? if so create the empty one.
.019dd9	29 01		and #$01			and 	#1
.019ddb	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.019ddd	d0 0e		bne $019ded			bne 	_VCNotArray
.019ddf	a2 00		ldx #$00			ldx 	#0 							; call recursive array creator
.019de1	20 87 9e	jsr $019e87			jsr 	ArrayCreate
.019de4	5a		phy				phy 								; save YA at zVarDataPtr
.019de5	a0 00		ldy #$00			ldy 	#0
.019de7	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.019de9	c8		iny				iny
.019dea	68		pla				pla
.019deb	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.019ded					_VCNotArray:
.019ded	7a		ply				ply
.019dee	fa		plx				plx
.019def	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arrayidx.asm

.019df0					ArrayIndexFollow:
.019df0	5a		phy				phy
.019df1	a0 00		ldy #$00			ldy 	#0 							; make zVarDataPtr point to the array.
.019df3	b1 24		lda ($24),y			lda 	(zVarDataPtr),y 			; e.g. it points to itself.
.019df5	48		pha				pha
.019df6	c8		iny				iny
.019df7	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.019df9	85 25		sta $25				sta 	zVarDataPtr+1
.019dfb	68		pla				pla
.019dfc	85 24		sta $24				sta 	zVarDataPtr
.019dfe	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; MSB of 16 bit integer and bytes 2&3
.019e00	29 80		and #$80			and 	#$80 						; must be zero.
.019e02	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019e04	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019e06	d0 59		bne $019e61			bne 	_AIFError
.019e08	a0 00		ldy #$00			ldy 	#0 							; calculate size - current - 1
.019e0a	18		clc				clc
.019e0b	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.019e0d	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.019e0f	c8		iny				iny
.019e10	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.019e12	08		php				php 								; clear bit 7 retaining borrow.
.019e13	29 7f		and #$7f			and 	#$7F
.019e15	28		plp				plp
.019e16	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.019e18	90 47		bcc $019e61			bcc 	_AIFError 					; eror if size-current < 0
.019e1a	b5 80		lda $80,x			lda  	XS_Mantissa+0,x 			; copy and double the index
.019e1c	0a		asl a				asl 	a 							; (e.g. index * 2)
.019e1d	85 10		sta $10				sta 	zTemp1
.019e1f	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019e21	2a		rol a				rol 	a
.019e22	85 11		sta $11				sta 	zTemp1+1
.019e24	a0 01		ldy #$01			ldy 	#1 							; is this a data entry.
.019e26	b1 24		lda ($24),y			lda 	(zVarDataPtr),y 			; if so, then type is unchanged, offset set
.019e28	30 1d		bmi $019e47			bmi 	_AIFCalculate
.019e2a	c6 26		dec $26				dec 	zVarType 					; converts from an array to a type.
.019e2c	a5 26		lda $26				lda 	zVarType 					; check that type
.019e2e	c9 b7		cmp #$b7			cmp 	#token_Dollar 				; if string, use x 2
.019e30	f0 15		beq $019e47			beq 	_AIFCalculate
.019e32	06 10		asl $10				asl 	zTemp1			 			; double the index
.019e34	26 11		rol $11				rol 	zTemp1+1					; (e.g. index * 4)
.019e36	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if integer, use x 4
.019e38	f0 0d		beq $019e47			beq 	_AIFCalculate
.019e3a	18		clc				clc 								; add the original mantissa in again
.019e3b	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; which makes it x5, for float.
.019e3d	65 10		adc $10				adc 	zTemp1
.019e3f	85 10		sta $10				sta 	zTemp1
.019e41	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019e43	65 11		adc $11				adc 	zTemp1+1
.019e45	85 11		sta $11				sta 	zTemp1+1
.019e47					_AIFCalculate:
.019e47	18		clc				clc 								; add index x 2,4 or 5 to base
.019e48	a5 24		lda $24				lda 	zVarDataPtr
.019e4a	65 10		adc $10				adc 	zTemp1
.019e4c	85 24		sta $24				sta 	zVarDataPtr
.019e4e	a5 25		lda $25				lda 	zVarDataPtr+1
.019e50	65 11		adc $11				adc 	zTemp1+1
.019e52	85 25		sta $25				sta 	zVarDataPtr+1
.019e54	18		clc				clc 								; add 2 more for the length prefix.
.019e55	a5 24		lda $24				lda 	zVarDataPtr
.019e57	69 02		adc #$02			adc 	#2
.019e59	85 24		sta $24				sta 	zVarDataPtr
.019e5b	90 02		bcc $019e5f			bcc 	_AIFNoBump
.019e5d	e6 25		inc $25				inc 	zVarDataPtr+1
.019e5f					_AIFNoBump:
.019e5f	7a		ply				ply
.019e60	60		rts				rts
.019e61					_AIFError:
.019e61	20 86 85	jsr $018586			jsr ERR_Handler
>019e64	42 61 64 20 61 72 72 61			.text "Bad array index",0
>019e6c	79 20 69 6e 64 65 78 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arraydef.asm

.019e74					ArrayResetDefault:
.019e74	a9 0b		lda #$0b			lda 	#11 						; 0..10 one array
.019e76	8d a9 03	sta $03a9			sta 	ArrayDef+0
.019e79	a9 00		lda #$00			lda 	#0
.019e7b	8d aa 03	sta $03aa			sta 	ArrayDef+1
.019e7e	a9 ff		lda #$ff			lda 	#$FF
.019e80	8d ab 03	sta $03ab			sta 	ArrayDef+2 					; $FFFF implies no second element.
.019e83	8d ac 03	sta $03ac			sta 	ArrayDef+3					; (test bit 7 of 2nd byte)
.019e86	60		rts				rts
.019e87					ArrayCreate:
.019e87	bd a9 03	lda $03a9,x			lda 	ArrayDef+0,x 				; put size x 2 in zTemp1
.019e8a	0a		asl a				asl 	a
.019e8b	85 10		sta $10				sta 	zTemp1
.019e8d	bd aa 03	lda $03aa,x			lda 	ArrayDef+1,x
.019e90	2a		rol a				rol 	a
.019e91	85 11		sta $11				sta 	zTemp1+1
.019e93	bd ac 03	lda $03ac,x			lda 	ArrayDef+3,x 				; if this is the last element it's array of ptrs.
.019e96	10 22		bpl $019eba			bpl 	_ACSized 					; if not multiply size x 2 (str) 4 (int) 5 (real)
.019e98	ad 95 03	lda $0395			lda 	Var_Type 					; check the type
.019e9b	c9 b8		cmp #$b8			cmp 	#token_DollarLParen 		; also if it is an array of strings $(
.019e9d	f0 1b		beq $019eba			beq 	_ACSized
.019e9f	06 10		asl $10				asl 	zTemp1 						; double again
.019ea1	26 11		rol $11				rol 	zTemp1+1
.019ea3	b0 6f		bcs $019f14			bcs 	ArrayIndexError 			; too large.
.019ea5	c9 bc		cmp #$bc			cmp 	#token_PercentLParen 		; if %( four bytes/entry is enough.
.019ea7	f0 11		beq $019eba			beq 	_ACSized
.019ea9	18		clc				clc 								; add original value x 5 for reals.
.019eaa	a5 10		lda $10				lda 	zTemp1
.019eac	7d a9 03	adc $03a9,x			adc 	ArrayDef+0,x
.019eaf	85 10		sta $10				sta 	zTemp1
.019eb1	a5 11		lda $11				lda 	zTemp1+1
.019eb3	7d aa 03	adc $03aa,x			adc 	ArrayDef+1,x
.019eb6	85 11		sta $11				sta 	zTemp1+1
.019eb8	b0 5a		bcs $019f14			bcs 	ArrayIndexError
.019eba					_ACSized:
.019eba	18		clc				clc
.019ebb	a5 10		lda $10				lda 	zTemp1
.019ebd	69 02		adc #$02			adc 	#2
.019ebf	85 10		sta $10				sta 	zTemp1
.019ec1	90 04		bcc $019ec7			bcc 	_ACNoBump
.019ec3	e6 10		inc $10				inc 	zTemp1
.019ec5	f0 4d		beq $019f14			beq 	ArrayIndexError
.019ec7					_ACNoBump:
.019ec7	18		clc				clc
.019ec8	ad 02 03	lda $0302			lda 	VarMemPtr 					; add this allocated count to VarMemPtr
.019ecb	85 12		sta $12				sta 	zTemp2						; save start in zTemp2/zTemp3
.019ecd	85 14		sta $14				sta 	zTemp3
.019ecf	65 10		adc $10				adc 	zTemp1
.019ed1	8d 02 03	sta $0302			sta 	VarMemPtr
.019ed4	ad 03 03	lda $0303			lda 	VarMemPtr+1
.019ed7	85 13		sta $13				sta 	zTemp2+1
.019ed9	85 15		sta $15				sta 	zTemp3+1
.019edb	65 11		adc $11				adc 	zTemp1+1
.019edd	8d 03 03	sta $0303			sta 	VarMemPtr+1
.019ee0	85 11		sta $11				sta 	zTemp1+1
.019ee2	b0 30		bcs $019f14			bcs 	ArrayIndexError
.019ee4	a0 00		ldy #$00			ldy 	#0							; write $00 out.
.019ee6					_ACClear:
.019ee6	98		tya				tya
.019ee7	91 12		sta ($12),y			sta 	(zTemp2),y
.019ee9	e6 12		inc $12				inc 	zTemp2
.019eeb	d0 02		bne $019eef			bne 	_ACCBump
.019eed	e6 13		inc $13				inc 	zTemp2+1
.019eef					_ACCBump:
.019eef	a5 12		lda $12				lda 	zTemp2
.019ef1	cd 02 03	cmp $0302			cmp 	VarMemPtr
.019ef4	d0 f0		bne $019ee6			bne 	_ACClear
.019ef6	a5 13		lda $13				lda 	zTemp2+1
.019ef8	cd 03 03	cmp $0303			cmp 	VarMemPtr+1
.019efb	d0 e9		bne $019ee6			bne 	_ACClear
.019efd	a0 00		ldy #$00			ldy 	#0
.019eff	bd a9 03	lda $03a9,x			lda 	ArrayDef+0,x 				; copy the size into the start
.019f02	91 14		sta ($14),y			sta 	(zTemp3),y
.019f04	c8		iny				iny
.019f05	bd aa 03	lda $03aa,x			lda 	ArrayDef+1,x
.019f08	91 14		sta ($14),y			sta 	(zTemp3),y
.019f0a	bd ac 03	lda $03ac,x			lda 	ArrayDef+3,x 				; have we reached the end
.019f0d	10 18		bpl $019f27			bpl 	ACCFillRecursive
.019f0f	a4 15		ldy $15				ldy 	zTemp3+1 					; return address
.019f11	a5 14		lda $14				lda 	zTemp3
.019f13	60		rts				rts
.019f14					ArrayIndexError:
.019f14	20 86 85	jsr $018586			jsr ERR_Handler
>019f17	42 61 64 20 61 72 72 61			.text "Bad array index",0
>019f1f	79 20 69 6e 64 65 78 00
.019f27					ACCFillRecursive:
.019f27	a9 ff		lda #$ff			lda 	#$FF 						; we mark the end, this is free space.
.019f29	a0 00		ldy #$00			ldy 	#0 							; this is overwritten by size of next allocated
.019f2b	91 12		sta ($12),y			sta 	(zTemp2),y 					; array, but we might change that.
.019f2d	c8		iny				iny
.019f2e	b1 14		lda ($14),y			lda 	(zTemp3),y 					; set bit 15 of the max index indicating
.019f30	09 80		ora #$80			ora 	#$80 						; an array of pointers
.019f32	91 14		sta ($14),y			sta 	(zTemp3),y
.019f34	a5 14		lda $14				lda 	zTemp3 						; push the start on the stack
.019f36	48		pha				pha
.019f37	a5 15		lda $15				lda 	zTemp3+1
.019f39	48		pha				pha
.019f3a					_ACCFillLoop:
.019f3a	18		clc				clc
.019f3b	a5 14		lda $14				lda 	zTemp3 						; and work forwards.
.019f3d	69 02		adc #$02			adc 	#2
.019f3f	85 14		sta $14				sta 	zTemp3
.019f41	90 02		bcc $019f45			bcc 	_ACCSkip2
.019f43	e6 15		inc $15				inc 	zTemp3+1
.019f45					_ACCSkip2:
.019f45	a0 00		ldy #$00			ldy 	#0 							; reached the end ?
.019f47	b1 14		lda ($14),y			lda 	(zTemp3),y					; (looking for FF marker, everything else 00)
.019f49	c8		iny				iny
.019f4a	11 14		ora ($14),y			ora 	(zTemp3),y
.019f4c	d0 21		bne $019f6f			bne 	_ACCExit
.019f4e	a5 14		lda $14				lda 	zTemp3 						; push zTemp3
.019f50	48		pha				pha
.019f51	a5 15		lda $15				lda 	zTemp3+1
.019f53	48		pha				pha
.019f54	e8		inx				inx
.019f55	e8		inx				inx
.019f56	20 87 9e	jsr $019e87			jsr 	ArrayCreate 				; create array recursively.
.019f59	ca		dex				dex
.019f5a	ca		dex				dex
.019f5b	85 12		sta $12				sta 	zTemp2 						; save A
.019f5d	68		pla				pla
.019f5e	85 15		sta $15				sta 	zTemp3+1 					; restore zTemp3
.019f60	68		pla				pla
.019f61	85 14		sta $14				sta 	zTemp3
.019f63	98		tya				tya 								; write high bye from Y
.019f64	a0 01		ldy #$01			ldy 	#1
.019f66	91 14		sta ($14),y			sta 	(zTemp3),y
.019f68	88		dey				dey 								; write low byte out.
.019f69	a5 12		lda $12				lda 	zTemp2
.019f6b	91 14		sta ($14),y			sta 	(zTemp3),y
.019f6d	80 cb		bra $019f3a			bra 	_ACCFillLoop 				; and try again.
.019f6f					_ACCExit:
.019f6f	7a		ply				ply 								; restore the original address
.019f70	68		pla				pla
.019f71	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varfind.asm

.019f72					VariableLocate:
.019f72	da		phx				phx
.019f73	5a		phy				phy
.019f74	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.019f77	85 12		sta $12				sta 	zTemp2 						; points to first address.
.019f79	a9 03		lda #$03			lda 	#HashTableBase >> 8
.019f7b	85 13		sta $13				sta 	zTemp2+1
.019f7d	a0 00		ldy #$00	_VLNext:ldy 	#0 							; get next link into AX
.019f7f	b1 12		lda ($12),y			lda 	(zTemp2),y
.019f81	aa		tax				tax
.019f82	c8		iny				iny
.019f83	b1 12		lda ($12),y			lda 	(zTemp2),y
.019f85	85 13		sta $13				sta 	zTemp2+1 					; save in zTemp
.019f87	86 12		stx $12				stx 	zTemp2
.019f89	05 12		ora $12				ora 	zTemp2 						; got zero
.019f8b	18		clc				clc
.019f8c	f0 25		beq $019fb3			beq 	_VLExit 					; if so, then fail as end of chain.
.019f8e	c8		iny				iny 								; point to hash (offset + 2)
.019f8f	b1 12		lda ($12),y			lda 	(zTemp2),y
.019f91	cd 96 03	cmp $0396			cmp 	Var_Hash
.019f94	d0 e7		bne $019f7d			bne 	_VLNext 					; try next if different.
.019f96					_VLCompare:
.019f96	c8		iny				iny 								; next character
.019f97	b1 12		lda ($12),y			lda 	(zTemp2),y 					; compare variable field against buffer.
.019f99	d9 12 03	cmp $0312,y			cmp 	Var_Buffer-3,y 				; the -3 is because name starts at 3.
.019f9c	d0 df		bne $019f7d			bne 	_VLNext 					; fail if different, try next.
.019f9e	0a		asl a				asl 	a 							; until end character (bit 7 set) matched
.019f9f	90 f5		bcc $019f96			bcc 	_VLCompare
.019fa1	98		tya				tya
.019fa2	38		sec				sec 								; add 1 as Y points to last character
.019fa3	65 12		adc $12				adc 	zTemp2 						; add to the current address
.019fa5	85 24		sta $24				sta 	zVarDataPtr
.019fa7	a5 13		lda $13				lda 	zTemp2+1
.019fa9	69 00		adc #$00			adc 	#0
.019fab	85 25		sta $25				sta 	zVarDataPtr+1
.019fad	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.019fb0	85 26		sta $26				sta 	zVarType
.019fb2	38		sec				sec 								; return CS
.019fb3	7a		ply		_VLExit:ply
.019fb4	fa		plx				plx
.019fb5	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/vargetset.asm

.019fb6					VariableGet:
.019fb6	5a		phy				phy
.019fb7	a0 00		ldy #$00			ldy 	#0 							; copy first two bytes
.019fb9	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.019fbb	95 80		sta $80,x			sta 	XS_Mantissa,x
.019fbd	c8		iny				iny
.019fbe	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.019fc0	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019fc2	c8		iny				iny
.019fc3	a5 26		lda $26				lda 	zVarType 					; if it is a string, set up for that.
.019fc5	c9 b7		cmp #$b7			cmp 	#token_Dollar
.019fc7	f0 2c		beq $019ff5			beq 	_VGString
.019fc9	b1 24		lda ($24),y			lda 	(zVarDataPtr),y 			; copy the next two bytes.
.019fcb	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019fcd	c8		iny				iny
.019fce	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.019fd0	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019fd2	c8		iny				iny
.019fd3	a9 01		lda #$01			lda 	#1 							; set type to 1.
.019fd5	95 85		sta $85,x			sta 	XS_Type,x
.019fd7	a5 26		lda $26				lda 	zVarType
.019fd9	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if it is a %, then exit with default integer.
.019fdb	f0 28		beq $01a005			beq 	_VGExit
.019fdd	a9 40		lda #$40			lda 	#$40 						; set type byte to zero
.019fdf	95 85		sta $85,x			sta 	XS_Type,x 					; which is the code for zero/float.
.019fe1	b1 24		lda ($24),y			lda 	(zVarDataPtr),y 			; the last value to copy is the exponent.
.019fe3	95 84		sta $84,x			sta 	XS_Exponent,x
.019fe5	f0 1e		beq $01a005			beq 	_VGExit 					; if exponent is zero ... it's zero.
.019fe7	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; the sign bit is the top mantissa bit.
.019fe9	48		pha				pha
.019fea	29 80		and #$80			and 	#$80
.019fec	95 85		sta $85,x			sta 	XS_Type,x 					; this is the type byte.
.019fee	68		pla				pla
.019fef	09 80		ora #$80			ora 	#$80 						; set the MSB as you would expect.
.019ff1	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; so it's a normalised float.
.019ff3	80 10		bra $01a005			bra 	_VGExit
.019ff5					_VGString:
.019ff5	a9 02		lda #$02			lda 	#2 							; set type to 2, a string
.019ff7	95 85		sta $85,x			sta 	XS_Type,x
.019ff9	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; is the value there $0000
.019ffb	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019ffd	d0 06		bne $01a005			bne 	_VGExit 					; if not, exit.
.019fff	85 27		sta $27				sta 	zNullString 				; make zNullString a 00 string.
.01a001	a9 27		lda #$27			lda 	#zNullString
.01a003	95 80		sta $80,x			sta 	XS_Mantissa,x 				; make it point to it.
.01a005					_VGExit:
.01a005	7a		ply				ply
.01a006	60		rts				rts
.01a007					VariableSet:
.01a007	b5 85		lda $85,x			lda 	XS_Type,x 					; is the result a string
.01a009	29 02		and #$02			and 	#2 							; if so, it has to be
.01a00b	d0 3f		bne $01a04c			bne 	_VSString
.01a00d	a5 26		lda $26				lda 	zVarType 					; if type is $ there's an error.
.01a00f	c9 b7		cmp #$b7			cmp 	#token_Dollar
.01a011	f0 36		beq $01a049			beq 	_VSBadType
.01a013					_VSCopy:
.01a013	5a		phy				phy
.01a014	a0 00		ldy #$00			ldy 	#0 							; copy mantissa to target.
.01a016	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01a018	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a01a	c8		iny				iny
.01a01b	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a01d	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a01f	c8		iny				iny
.01a020	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a022	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a024	c8		iny				iny
.01a025	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a027	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a029	a5 26		lda $26				lda 	zVarType 					; if target is integer, alrady done.
.01a02b	c9 bb		cmp #$bb			cmp 	#token_Percent
.01a02d	f0 18		beq $01a047			beq 	_VSExit
.01a02f	b5 85		lda $85,x			lda 	XS_Type,x 					; get the sign bit into carry flag.
.01a031	0a		asl a				asl 	a
.01a032	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; shift the sign into the mantissa high.
.01a034	08		php				php
.01a035	0a		asl a				asl 	a
.01a036	28		plp				plp
.01a037	6a		ror a				ror 	a
.01a038	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a03a	c8		iny				iny
.01a03b	b5 84		lda $84,x			lda 	XS_Exponent,x 				; copy the exponent in
.01a03d	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a03f	34 85		bit $85,x			bit 	XS_Type,x 					; if the result is non zero
.01a041	50 04		bvc $01a047			bvc 	_VSExit
.01a043	a9 00		lda #$00			lda 	#0 							; zero exponent indicating 0.
.01a045	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a047					_VSExit:
.01a047	7a		ply				ply
.01a048	60		rts				rts
.01a049					_VSBadType:
.01a049	4c 67 85	jmp $018567			jmp 	TypeError
.01a04c					_VSString:
.01a04c	a5 26		lda $26				lda 	zVarType 					; type must be $
.01a04e	c9 b7		cmp #$b7			cmp 	#token_Dollar
.01a050	d0 f7		bne $01a049			bne 	_VSBadType
.01a052	da		phx				phx
.01a053	5a		phy				phy
.01a054	20 b7 99	jsr $0199b7			jsr 	StringConcrete 				; concrete the string in the mantissa -> AX
.01a057	a0 01		ldy #$01			ldy 	#1 							; save high byte
.01a059	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a05b	88		dey				dey 								; save low byte
.01a05c	8a		txa				txa
.01a05d	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a05f	7a		ply				ply 								; and exit.
.01a060	fa		plx				plx
.01a061	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.01a062					MulInteger32:
.01a062	b5 80		lda $80,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.01a064	95 8c		sta $8c,x			sta 	XS3_Mantissa,x
.01a066	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a068	95 8d		sta $8d,x			sta 	XS3_Mantissa+1,x
.01a06a	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a06c	95 8e		sta $8e,x			sta 	XS3_Mantissa+2,x
.01a06e	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a070	95 8f		sta $8f,x			sta 	XS3_Mantissa+3,x
.01a072	a9 00		lda #$00			lda 	#0
.01a074	95 80		sta $80,x			sta 	XS_Mantissa+0,x 				; zero +0, where the result goes.
.01a076	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a078	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a07a	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a07c					_BFMMultiply:
.01a07c	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.01a07e	29 01		and #$01			and 	#1
.01a080	f0 03		beq $01a085			beq 	_BFMNoAdd
.01a082	20 fc 94	jsr $0194fc			jsr 	AddInteger32 					; co-opt this code
.01a085					_BFMNoAdd:
.01a085	16 86		asl $86,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.01a087	36 87		rol $87,x			rol 	XS2_Mantissa+1,x
.01a089	36 88		rol $88,x			rol 	XS2_Mantissa+2,x
.01a08b	36 89		rol $89,x			rol 	XS2_Mantissa+3,x
.01a08d	56 8f		lsr $8f,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.01a08f	76 8e		ror $8e,x			ror 	XS3_Mantissa+2,x
.01a091	76 8d		ror $8d,x			ror 	XS3_Mantissa+1,x
.01a093	76 8c		ror $8c,x			ror 	XS3_Mantissa,x
.01a095	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.01a097	15 8d		ora $8d,x			ora 	XS3_Mantissa+1,x
.01a099	15 8e		ora $8e,x			ora 	XS3_Mantissa+2,x
.01a09b	15 8f		ora $8f,x			ora 	XS3_Mantissa+3,x
.01a09d	d0 dd		bne $01a07c			bne 	_BFMMultiply
.01a09f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.01a0a0					DivInteger32:
.01a0a0	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; check for division by zero.
.01a0a2	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.01a0a4	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.01a0a6	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.01a0a8	d0 14		bne $01a0be			bne 	_BFDOkay
.01a0aa	20 86 85	jsr $018586			jsr ERR_Handler
>01a0ad	44 69 76 69 73 69 6f 6e			.text "Division by Zero",0
>01a0b5	20 62 79 20 5a 65 72 6f 00
.01a0be					_BFDOkay:
.01a0be	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.01a0c0	85 1c		sta $1c				sta 	zLTemp1 					; Q/Dividend/Left in +0
.01a0c2	85 1d		sta $1d				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.01a0c4	85 1e		sta $1e				sta 	zLTemp1+2
.01a0c6	85 1f		sta $1f				sta 	zLTemp1+3
.01a0c8	8d 9e 03	sta $039e			sta 	SignCount 					; Count of signs.
.01a0cb	20 22 a1	jsr $01a122			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.01a0ce	da		phx				phx
.01a0cf	e8		inx				inx
.01a0d0	e8		inx				inx
.01a0d1	e8		inx				inx
.01a0d2	e8		inx				inx
.01a0d3	e8		inx				inx
.01a0d4	e8		inx				inx
.01a0d5	20 22 a1	jsr $01a122			jsr 	CheckIntegerNegate
.01a0d8	fa		plx				plx
.01a0d9	5a		phy				phy 								; Y is the counter
.01a0da	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.01a0dc					_BFDLoop:
.01a0dc	16 80		asl $80,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.01a0de	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.01a0e0	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.01a0e2	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.01a0e4	26 1c		rol $1c				rol 	zLTemp1
.01a0e6	26 1d		rol $1d				rol 	zLTemp1+1
.01a0e8	26 1e		rol $1e				rol 	zLTemp1+2
.01a0ea	26 1f		rol $1f				rol 	zLTemp1+3
.01a0ec	38		sec				sec
.01a0ed	a5 1c		lda $1c				lda 	zLTemp1+0 					; Calculate A-M on stack.
.01a0ef	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.01a0f1	48		pha				pha
.01a0f2	a5 1d		lda $1d				lda 	zLTemp1+1
.01a0f4	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.01a0f6	48		pha				pha
.01a0f7	a5 1e		lda $1e				lda 	zLTemp1+2
.01a0f9	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.01a0fb	48		pha				pha
.01a0fc	a5 1f		lda $1f				lda 	zLTemp1+3
.01a0fe	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.01a100	90 13		bcc $01a115			bcc 	_BFDNoAdd
.01a102	85 1f		sta $1f				sta 	zLTemp1+3 					; update A
.01a104	68		pla				pla
.01a105	85 1e		sta $1e				sta 	zLTemp1+2
.01a107	68		pla				pla
.01a108	85 1d		sta $1d				sta 	zLTemp1+1
.01a10a	68		pla				pla
.01a10b	85 1c		sta $1c				sta 	zLTemp1+0
.01a10d	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.01a10f	09 01		ora #$01			ora 	#1
.01a111	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a113	80 03		bra $01a118			bra 	_BFDNext
.01a115					_BFDNoAdd:
.01a115	68		pla				pla 								; Throw away the intermediate calculations
.01a116	68		pla				pla
.01a117	68		pla				pla
.01a118					_BFDNext:
.01a118	88		dey				dey
.01a119	d0 c1		bne $01a0dc			bne 	_BFDLoop
.01a11b	7a		ply				ply 								; restore Y
.01a11c	4e 9e 03	lsr $039e			lsr 	SignCount 					; if sign count odd,
.01a11f	b0 06		bcs $01a127			bcs		IntegerNegateAlways 		; negate the result
.01a121	60		rts				rts
.01a122					CheckIntegerNegate:
.01a122	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; is it -ve = MSB set ?
.01a124	30 01		bmi $01a127			bmi 	IntegerNegateAlways 		; if so negate it
.01a126	60		rts				rts
.01a127					IntegerNegateAlways:
.01a127	ee 9e 03	inc $039e			inc 	SignCount 					; bump the count of signs
.01a12a	38		sec				sec 								; 0-mantissa,x -> mantissa,x
.01a12b	a9 00		lda #$00			lda 	#0
.01a12d	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.01a12f	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a131	a9 00		lda #$00			lda 	#0
.01a133	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.01a135	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a137	a9 00		lda #$00			lda 	#0
.01a139	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.01a13b	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a13d	a9 00		lda #$00			lda 	#0
.01a13f	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.01a141	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a143	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.01a144					INTToString:
.01a144	48		pha				pha
.01a145	5a		phy				phy
.01a146	b5 83		lda $83,x			lda 		XS_Mantissa+3,x 		; check -ve
.01a148	10 08		bpl $01a152			bpl 		_ITSNotMinus
.01a14a	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.01a14c	20 e6 a1	jsr $01a1e6			jsr 		ITSOutputCharacter
.01a14f	20 27 a1	jsr $01a127			jsr 		IntegerNegateAlways 	; negate the number.
.01a152					_ITSNotMinus:
.01a152	a9 00		lda #$00			lda 		#0
.01a154	8d 9a 03	sta $039a			sta 		NumSuppress 			; clear the suppression flag.
.01a157	8a		txa				txa 								; use Y for the mantissa index.
.01a158	a8		tay				tay
.01a159	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.01a15b					_ITSNextSubtractor:
.01a15b	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.01a15d	8d 9b 03	sta $039b			sta 		NumConvCount
.01a160					_ITSSubtract:
.01a160	38		sec				sec
.01a161	b9 80 00	lda $0080,y			lda 		XS_Mantissa,y 			; subtract number and push on stack
.01a164	ff c2 a1 01	sbc $01a1c2,x			sbc 		_ITSSubtractors+0,x
.01a168	48		pha				pha
.01a169	b9 81 00	lda $0081,y			lda 		XS_Mantissa+1,y
.01a16c	ff c3 a1 01	sbc $01a1c3,x			sbc 		_ITSSubtractors+1,x
.01a170	48		pha				pha
.01a171	b9 82 00	lda $0082,y			lda 		XS_Mantissa+2,y
.01a174	ff c4 a1 01	sbc $01a1c4,x			sbc 		_ITSSubtractors+2,x
.01a178	48		pha				pha
.01a179	b9 83 00	lda $0083,y			lda 		XS_Mantissa+3,y
.01a17c	ff c5 a1 01	sbc $01a1c5,x			sbc 		_ITSSubtractors+3,x
.01a180	90 14		bcc $01a196			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.01a182	99 83 00	sta $0083,y			sta 		XS_Mantissa+3,y 		; save subtract off stack
.01a185	68		pla				pla
.01a186	99 82 00	sta $0082,y			sta 		XS_Mantissa+2,y
.01a189	68		pla				pla
.01a18a	99 81 00	sta $0081,y			sta 		XS_Mantissa+1,y
.01a18d	68		pla				pla
.01a18e	99 80 00	sta $0080,y			sta 		XS_Mantissa+0,y
.01a191	ee 9b 03	inc $039b			inc 		NumConvCount 			; bump count.
.01a194	80 ca		bra $01a160			bra 		_ITSSubtract 			; go round again.
.01a196					_ITSCantSubtract:
.01a196	68		pla				pla 								; throw away interim answers
.01a197	68		pla				pla
.01a198	68		pla				pla
.01a199	ad 9b 03	lda $039b			lda 		NumConvCount 			; if not zero then no suppression check
.01a19c	c9 30		cmp #$30			cmp 		#"0"
.01a19e	d0 05		bne $01a1a5			bne 		_ITSOutputDigit
.01a1a0	ad 9a 03	lda $039a			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.01a1a3	10 09		bpl $01a1ae			bpl	 		_ITSGoNextSubtractor
.01a1a5					_ITSOutputDigit:
.01a1a5	ce 9a 03	dec $039a			dec 		NumSuppress 			; suppression check will be non-zero.
.01a1a8	ad 9b 03	lda $039b			lda 		NumConvCount 			; count of subtractions
.01a1ab	20 e6 a1	jsr $01a1e6			jsr 		ITSOutputCharacter 		; output it.
.01a1ae					_ITSGoNextSubtractor:
.01a1ae	e8		inx				inx 								; next dword
.01a1af	e8		inx				inx
.01a1b0	e8		inx				inx
.01a1b1	e8		inx				inx
.01a1b2	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.01a1b4	d0 a5		bne $01a15b			bne 		_ITSNextSubtractor 		; do all the subtractors.
.01a1b6	98		tya				tya 								; X is back as the mantissa index
.01a1b7	aa		tax				tax
.01a1b8	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.01a1ba	09 30		ora #$30			ora 		#"0"
.01a1bc	20 e6 a1	jsr $01a1e6			jsr 		ITSOutputCharacter
.01a1bf	7a		ply				ply 								; and exit
.01a1c0	68		pla				pla
.01a1c1	60		rts				rts
.01a1c2					_ITSSubtractors:
>01a1c2	00 ca 9a 3b					.dword 		1000000000
>01a1c6	00 e1 f5 05					.dword 		100000000
>01a1ca	80 96 98 00					.dword 		10000000
>01a1ce	40 42 0f 00					.dword 		1000000
>01a1d2	a0 86 01 00					.dword 		100000
>01a1d6	10 27 00 00					.dword 		10000
>01a1da	e8 03 00 00					.dword 		1000
>01a1de	64 00 00 00					.dword 		100
>01a1e2	0a 00 00 00					.dword 		10
.01a1e6					_ITSSubtractorsEnd:
.01a1e6					ITSOutputCharacter:
.01a1e6	48		pha				pha
.01a1e7	da		phx				phx
.01a1e8	ae 14 03	ldx $0314			ldx 	NumBufX 					; save digit
.01a1eb	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.01a1ee	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.01a1f0	9d 16 03	sta $0316,x			sta 	Num_Buffer+1,x
.01a1f3	ee 14 03	inc $0314			inc 	NumBufX						; bump pointer.
.01a1f6	fa		plx				plx
.01a1f7	68		pla				pla
.01a1f8	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.01a1f9					IntFromString:
.01a1f9	a0 00		ldy #$00			ldy 	#0
.01a1fb					IntFromStringY:
.01a1fb	a9 00		lda #$00			lda 	#0
.01a1fd	8d 9c 03	sta $039c			sta 	ExpTemp 					; this is the converted digit count.
.01a200	48		pha				pha
.01a201	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.01a203	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a205	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a207	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a209	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a20b	a9 01		lda #$01			lda 	#1
.01a20d	95 85		sta $85,x			sta 	XS_Type,x
.01a20f					_IFSLoop:
.01a20f	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; get next
.01a211	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.01a213	90 4e		bcc $01a263			bcc 	_IFSExit
.01a215	c9 3a		cmp #$3a			cmp 	#"9"+1
.01a217	b0 4a		bcs $01a263			bcs 	_IFSExit
.01a219	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.01a21b	c9 0c		cmp #$0c			cmp 	#12
.01a21d	b0 4e		bcs $01a26d			bcs 	_IFSOverflow
.01a21f	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.01a221	48		pha				pha
.01a222	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a224	48		pha				pha
.01a225	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a227	48		pha				pha
.01a228	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01a22a	48		pha				pha
.01a22b	20 82 a2	jsr $01a282			jsr 	IFSX1ShiftLeft 				; double
.01a22e	20 82 a2	jsr $01a282			jsr 	IFSX1ShiftLeft 				; x 4
.01a231	18		clc				clc 								; add saved value x 5
.01a232	68		pla				pla
.01a233	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.01a235	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a237	68		pla				pla
.01a238	75 81		adc $81,x			adc 	XS_Mantissa+1,x
.01a23a	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a23c	68		pla				pla
.01a23d	75 82		adc $82,x			adc 	XS_Mantissa+2,x
.01a23f	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a241	68		pla				pla
.01a242	75 83		adc $83,x			adc 	XS_Mantissa+3,x
.01a244	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a246	20 82 a2	jsr $01a282			jsr 	IFSX1ShiftLeft 				; x 10
.01a249	ee 9c 03	inc $039c			inc 	ExpTemp 					; bump count of digits processed.
.01a24c	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; add digit
.01a24e	29 0f		and #$0f			and 	#15
.01a250	c8		iny				iny
.01a251	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.01a253	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a255	90 b8		bcc $01a20f			bcc 	_IFSLoop
.01a257	f6 81		inc $81,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.01a259	d0 b4		bne $01a20f			bne 	_IFSLoop
.01a25b	f6 82		inc $82,x			inc 	XS_Mantissa+2,x
.01a25d	d0 b0		bne $01a20f			bne 	_IFSLoop
.01a25f	f6 83		inc $83,x			inc 	XS_Mantissa+3,x
.01a261	80 ac		bra $01a20f			bra 	_IFSLoop
.01a263					_IFSExit:
.01a263	98		tya				tya 								; get offset
.01a264					_IFSOkay:
.01a264	38		sec				sec
.01a265	ad 9c 03	lda $039c			lda 	ExpTemp
.01a268	f0 01		beq $01a26b			beq 	_IFSSkipFail
.01a26a	18		clc				clc
.01a26b					_IFSSkipFail:
.01a26b	68		pla				pla 								; and exit.
.01a26c	60		rts				rts
.01a26d					_IFSOverflow:
.01a26d	20 86 85	jsr $018586			jsr 	ERR_Handler
>01a270	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>01a278	20 6f 76 65 72 66 6c 6f 77 00
.01a282					IFSX1ShiftLeft:
.01a282	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.01a284	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.01a286	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.01a288	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.01a28a	60		rts				rts

;******  Return to file: _include.asm


;******  Return to file: basic.asm

>01a28b	02						.byte 	2
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 c0						.word 	StartROM 					; Reset vector
>fffe	19 c0					.word TIM_BreakHandler

;******  End of listing
