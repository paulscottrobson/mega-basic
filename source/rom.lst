
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Sun Sep  1 11:55:24 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="65816"				cpu = "65816"
="em65816"				hardware = "em65816"
=1					exitonend = 1
=0					autorun = 0
=1					loadtest = 1
=1					hasfloat = 1
=1					hasinteger = 1
=253					maxstring = 253

;******  Processing file: modules/basic/pointer/em65816/src_em65816.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stackmarkers.inc

=5					SourcePosSize   =   5 							; Source position stack space needed.
=1					SMark_Gosub 	= 	1 							; 0 is GOSUB/RETURN.
=2					SMark_Repeat 	= 	2 							; 1 is REPEAT/UNTIL.
=3					SMark_While 	= 	3 							; 2 is WHILE/WEND.
=4					SMark_If 		= 	4 							; 3 is IF/ENDIF
=5					SMark_For 		= 	5 							; 4 is FOR/NEXT

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/hardware/common/macros32.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0020					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0022					zVarDataPtr: .word ? 						; position of variable data.
>0024					zVarType: 	.byte ? 						; type of data (token)
>0025					zNullString:.byte ? 						; represents a NULL string.
>0026					zBasicSP:	.word ? 						; stack pointer
>0080					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>0084					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>0085					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=134					XS2_Mantissa = XS_Mantissa+XS_Size
=138					XS2_Exponent = XS_Exponent+XS_Size
=139					XS2_Type = XS_Type+XS_Size
=140					XS3_Mantissa = XS_Mantissa+XS_Size*2
=144					XS3_Exponent = XS_Exponent+XS_Size*2
=145					XS3_Type = XS_Type+XS_Size*2
>0300					StringPtr:	.word ? 						; Top of free memory (for string allocation)
>0302					VarMemPtr: 	.word ?							; Bottom of free memory (for variables)
>0304					endOfProgram: .dword ? 						; End of Program Memory (long)
>0308					vecPrintCharacter .word ?
>030a					vecInputCharacter .word ?
>030c					UserVector .fill 4 							; USR(x) calls this.
>0310					LocalVector .fill 4 						; Indirect calls call this.
>0314					NumBufX 	.byte 	?						; buffer index position
>0315					Num_Buffer	.fill 	32 						; buffer for numeric conversions
=6					HashTableCount = 6 							; there are 6 hash tables, in token order.
=8					HashTableSize = 8 							; each hash table as 8 links.
.0335					HashTableBase:
>0335								.fill	HashTableCount * HashTableSize * 2
.0395					HashTableEnd:
=$315					Var_Buffer 	= Num_Buffer 					; buffer for variable name (same space)
>0395					Var_Type    .byte ? 						; type of variable (as a type token)
>0396					Var_Hash 	.byte ? 						; hash of identifier name.
>0397					Var_Length 	.byte ? 						; length of variable name
>0398					Var_HashAddress .byte ?						; low byte of hash table entry.
>0399					Var_DataSize .byte ?						; size of one element.
>039a					NumSuppress	.byte 	?						; leading zero suppression flag
>039b					NumConvCount .byte 	? 						; count for conversions.
>039c					ExpTemp:	.byte ?							; Working temp for exponents.
>039d					ExpCount:	.byte ? 						; Count of decimal exponents.
>039e					SignCount:	.byte ?							; Integer Divide Sign Counts.
>039f					TempStringWriteIndex: .byte ? 				; Write offset.
>03a0					ValSign: 	.byte ? 						; sign flag for val()
>03a1					SliceStart:	.byte ? 						; string slice parts
>03a2					SliceCount:	.byte ?
>03a3					RandomSeed:	.dword ? 						; Random seed.
>03a7					SignNext:	.byte ? 						; Used for keeping sign of STEP in FOR/NEXT
>03a8					BreakCount:	.byte ? 						; Counter, avoid checking break every command.
=3					ArrayMaxDim = 3 							; number of dimensions.
>03a9					ArrayDef:	.fill (ArrayMaxDim+1)*2 		; dimensions for auto-creation
>03b1					UsrArrayDef:.fill (ArrayMaxDim+1)*2 		; dimensions created in DIM
>03b9					UsrArrayIdx:.byte ? 						; index into UsrArrayDef
>03ba					LastPrinted:.byte ? 						; last printed char ?
>03bb					ListIndent: .byte ? 						; list indent level
>03bc					LastListIndent:.byte ? 						; previous one.
>03bd					DataLPtr: 	.dword ?						; the data long ptr (swapped with zCodePtr)
>03c1					DataIndex:	.byte ?							; index position.
>03c2					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>03c4					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>03c6					Tim_SR:		.byte ? 						; Processor Status
>03c7					Tim_A:		.byte ? 						; Processor Registers
>03c8					Tim_X:		.byte ?
>03c9					Tim_Y:		.byte ?
>03ca					Tim_Z:		.byte ?
>03cb					Tim_SP:		.word ?							; Stack Pointer (just in cases)
>0400					BasicStack:	.fill 	256 					; and occupy whole pages.
.0500					EndBasicStack:
>0500					IFT_XCursor:.byte ?							; current logical position on screen
>0501					IFT_YCursor:.byte ?
>0502					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0566					IFT_LineBuffer: .fill 100 					; line input buffer.

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/em65816.asm

=$7f00					HighMemory = $7F00
=$3000					VariableMemory = $3000
.1000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testcode.src

>1000	0f 0a 00 c6 01 bf 02 bb			.byte	$0f,$0a,$00,$c6,$01,$bf,$02,$bb
>1008	bf 03 c0 c6 04 b7 00 19			.byte	$bf,$03,$c0,$c6,$04,$b7,$00,$19
>1010	14 00 c5 58 bf 71 bf 41			.byte	$14,$00,$c5,$58,$bf,$71,$bf,$41
>1018	7c fd 03 37 c0 d6 fe 09			.byte	$7c,$fd,$03,$37,$c0,$d6,$fe,$09
>1020	52 65 61 64 2e 2e 2e 00			.byte	$52,$65,$61,$64,$2e,$2e,$2e,$00
>1028	1a 1e 00 c5 fe 07 48 65			.byte	$1a,$1e,$00,$c5,$fe,$07,$48,$65
>1030	6c 6c 6f c0 d6 fe 0c 61			.byte	$6c,$6c,$6f,$c0,$d6,$fe,$0c,$61
>1038	67 61 69 6e 20 2e 2e 2e			.byte	$67,$61,$69,$6e,$20,$2e,$2e,$2e
>1040	2e 00 0e 28 00 d6 01 bf			.byte	$2e,$00,$0e,$28,$00,$d6,$01,$bf
>1048	02 bb bf 03 bf 04 b7 00			.byte	$02,$bb,$bf,$03,$bf,$04,$b7,$00
>1050	05 32 00 d4 00 0f 3c 00			.byte	$05,$32,$00,$d4,$00,$0f,$3c,$00
>1058	c6 01 bf 02 bb bf 03 c0			.byte	$c6,$01,$bf,$02,$bb,$bf,$03,$c0
>1060	c6 04 b7 00 0e 46 00 d6			.byte	$c6,$04,$b7,$00,$0e,$46,$00,$d6
>1068	01 bf 02 bb bf 03 bf 04			.byte	$01,$bf,$02,$bb,$bf,$03,$bf,$04
>1070	b7 00 06 50 00 c6 18 00			.byte	$b7,$00,$06,$50,$00,$c6,$18,$00
>1078	05 5a 00 c4 00 00			.byte	$05,$5a,$00,$c4,$00,$00

;******  Return to file: modules/hardware/em65816.asm

.c000					StartROM:
.c000	18		clc				clc
.c001	fb		xce				xce
.c002	c2 30		rep #$30			rep 	#$30
.c004	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.c007	1b		tcs				tcs
.c008	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.c00b	e2 30		sep #$30			sep 	#$30
.c00d	c2 30		rep #$30			rep 	#$30						; clear AXY in 16 bit.
.c00f	a9 00		lda #$00			lda 	#$0000
.c011	aa		tax				tax
.c012	a8		tay				tay
.c013	e2 30		sep #$30			sep 	#$30
.c015	5c f6 87 01	jmp $0187f6		jmp BASIC_Start
.c019					TIM_BreakHandler:
.c019	5c 69 83 01	jmp $018369			jmp 	TIM_BreakVector

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.018000					IFT_ClearScreen:
.018000	48		pha				pha
.018001	da		phx				phx
.018002	5a		phy				phy
.018003	20 9c 81	jsr $01819c			jsr 	IF_Home 					; home cursor
.018006	a2 20		ldx #$20			ldx 	#IF_Height 					; this many lines.
.018008					_IFT_CS0:
.018008	a0 40		ldy #$40			ldy 	#IF_Width 					; this many chars/line
.01800a					_IFT_CS1:
.01800a	a9 20		lda #$20			lda 	#' '						; clear line.
.01800c	20 c8 81	jsr $0181c8			jsr 	IF_Write
.01800f	88		dey				dey
.018010	d0 f8		bne $01800a			bne 	_IFT_CS1
.018012	20 af 81	jsr $0181af			jsr 	IF_NewLine 					; next line down
.018015	ca		dex				dex
.018016	d0 f0		bne $018008			bne 	_IFT_CS0
.018018	7a		ply				ply
.018019	fa		plx				plx
.01801a	68		pla				pla
.01801b					IFT_HomeCursor:
.01801b	48		pha				pha
.01801c	20 9c 81	jsr $01819c			jsr 	IF_Home
.01801f	a9 00		lda #$00			lda 	#0
.018021	8d 00 05	sta $0500			sta 	IFT_XCursor
.018024	8d 01 05	sta $0501			sta 	IFT_YCursor
.018027	68		pla				pla
.018028	60		rts				rts
.018029					IFT_UpLine:
.018029	48		pha				pha
.01802a	ad 01 05	lda $0501			lda  	IFT_YCursor 				; get Y
.01802d	3a		dec a				dec 	a 							; line above
.01802e	30 03		bmi $018033			bmi 	_IFTULExit 					; too far, abort
.018030	20 be 80	jsr $0180be			jsr 	IFT_SetYPos					; set to that line.
.018033					_IFTULExit:
.018033	68		pla				pla
.018034	60		rts				rts
.018035					IFT_PrintCharacter:
.018035	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.018037	f0 16		beq $01804f			beq 	IFT_NewLine
.018039	48		pha				pha
.01803a	20 67 80	jsr $018067			jsr 	IFT_UpperCase 				; make upper case
.01803d	20 c8 81	jsr $0181c8			jsr 	IF_Write 					; write out.
.018040	ee 00 05	inc $0500			inc 	IFT_XCursor 				; bump x cursor
.018043	ad 00 05	lda $0500			lda 	IFT_XCursor 				; reached RHS ?
.018046	c9 40		cmp #$40			cmp 	#IF_Width
.018048	d0 03		bne $01804d			bne 	_IFT_PCNotEOL
.01804a	20 4f 80	jsr $01804f			jsr 	IFT_NewLine 				; if so do new line.
.01804d					_IFT_PCNotEOL:
.01804d	68		pla				pla
.01804e	60		rts				rts
.01804f					IFT_NewLine:
.01804f	48		pha				pha
.018050	20 af 81	jsr $0181af			jsr 	IF_NewLine 					; new line on actual screen.
.018053	a9 00		lda #$00			lda 	#0 							; reset x position
.018055	8d 00 05	sta $0500			sta 	IFT_XCursor
.018058	ee 01 05	inc $0501			inc 	IFT_YCursor 				; move down.
.01805b	ad 01 05	lda $0501			lda 	IFT_YCursor
.01805e	c9 20		cmp #$20			cmp 	#IF_Height 					; reached bottom.
.018060	d0 03		bne $018065			bne 	_IFT_NL_NotEOS
.018062	20 72 80	jsr $018072			jsr 	IFT_Scroll 					; scroll screen up.
.018065					_IFT_NL_NotEOS:
.018065	68		pla				pla
.018066	60		rts				rts
.018067					IFT_UpperCase:
.018067	c9 61		cmp #$61			cmp 	#"a"
.018069	90 06		bcc $018071			bcc 	_IFT_UCExit
.01806b	c9 7b		cmp #$7b			cmp 	#"z"+1
.01806d	b0 02		bcs $018071			bcs 	_IFT_UCExit
.01806f	49 20		eor #$20			eor 	#$20
.018071					_IFT_UCExit:
.018071	60		rts				rts
.018072					IFT_Scroll:
.018072	48		pha				pha 								; save AXY
.018073	da		phx				phx
.018074	5a		phy				phy
.018075	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.018077					_IFT_SLoop:
.018077	20 97 80	jsr $018097			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.01807a	e8		inx				inx
.01807b	e0 1f		cpx #$1f			cpx 	#IF_Height-1				; do whole screen
.01807d	d0 f8		bne $018077			bne 	_IFT_SLoop
.01807f	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.018081	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.018084	a2 40		ldx #$40			ldx 	#IF_Width 					; blank line
.018086					_IFT_SBlank:
.018086	a9 20		lda #$20			lda 	#32
.018088	20 c8 81	jsr $0181c8			jsr 	IF_Write
.01808b	ca		dex				dex
.01808c	d0 f8		bne $018086			bne 	_IFT_SBlank
.01808e	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.018090	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.018093	7a		ply				ply
.018094	fa		plx				plx
.018095	68		pla				pla
.018096	60		rts				rts
.018097					_IFT_ScrollLine:
.018097	da		phx				phx
.018098	da		phx				phx
.018099	8a		txa				txa 								; copy line into buffer.
.01809a	1a		inc a				inc 	a 							; next line down.
.01809b	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.01809e	a2 00		ldx #$00			ldx 	#0
.0180a0					_IFTScrollCopy1:
.0180a0	20 bf 81	jsr $0181bf			jsr 	IF_Read
.0180a3	9d 02 05	sta $0502,x			sta 	IFT_Buffer,x
.0180a6	e8		inx				inx
.0180a7	e0 40		cpx #$40			cpx 	#IF_Width
.0180a9	d0 f5		bne $0180a0			bne 	_IFTScrollCopy1
.0180ab	68		pla				pla
.0180ac	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.0180af	a2 00		ldx #$00			ldx 	#0
.0180b1					_IFTScrollCopy2:
.0180b1	bd 02 05	lda $0502,x			lda 	IFT_Buffer,x
.0180b4	20 c8 81	jsr $0181c8			jsr 	IF_Write
.0180b7	e8		inx				inx
.0180b8	e0 40		cpx #$40			cpx 	#IF_Width
.0180ba	d0 f5		bne $0180b1			bne 	_IFTScrollCopy2
.0180bc	fa		plx				plx
.0180bd	60		rts				rts
.0180be					IFT_SetYPos:
.0180be	48		pha				pha
.0180bf	da		phx				phx
.0180c0	aa		tax				tax
.0180c1	20 1b 80	jsr $01801b			jsr 	IFT_HomeCursor
.0180c4	e0 00		cpx #$00			cpx 	#0
.0180c6	f0 09		beq $0180d1			beq 	_IFT_MOAExit
.0180c8					_IFT_MOALoop:
.0180c8	20 af 81	jsr $0181af			jsr 	IF_NewLine
.0180cb	ee 01 05	inc $0501			inc 	IFT_YCursor
.0180ce	ca		dex				dex
.0180cf	d0 f7		bne $0180c8			bne		_IFT_MOALoop
.0180d1					_IFT_MOAExit:
.0180d1	fa		plx				plx
.0180d2	68		pla				pla
.0180d3	60		rts				rts
.0180d4					IFT_GetKeyCursor:
.0180d4	20 dc 80	jsr $0180dc			jsr 	_IFT_FlipCursor 			; reverse current
.0180d7					_IFT_GKCWait:
.0180d7	20 d9 81	jsr $0181d9			jsr 	IF_GetKey 					; get key
.0180da	f0 fb		beq $0180d7			beq 	_IFT_GKCWait
.0180dc					_IFT_FlipCursor:
.0180dc	48		pha				pha 								; save
.0180dd	20 bf 81	jsr $0181bf			jsr 	IF_Read 					; read
.0180e0	20 d1 81	jsr $0181d1			jsr 	IF_LeftOne
.0180e3	49 80		eor #$80			eor 	#$80 						; reverse
.0180e5	20 c8 81	jsr $0181c8			jsr 	IF_Write 					; write
.0180e8	20 d1 81	jsr $0181d1			jsr 	IF_LeftOne
.0180eb	68		pla				pla
.0180ec	60		rts				rts
.0180ed					IFT_ReadLine:
.0180ed	48		pha				pha
.0180ee					_IFT_RLLoop:
.0180ee	20 d4 80	jsr $0180d4			jsr 	IFT_GetKeyCursor 			; get keystroke
.0180f1	c9 0d		cmp #$0d			cmp 	#13							; return
.0180f3	f0 7d		beq $018172			beq 	_IFT_RLExit
.0180f5	c9 20		cmp #$20			cmp 	#32 						; control character
.0180f7	90 05		bcc $0180fe			bcc 	_IFT_Control
.0180f9	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0180fc	80 f0		bra $0180ee			bra 	_IFT_RLLoop
.0180fe					_IFT_Control:
.0180fe	c9 01		cmp #$01			cmp 	#"A"-64
.018100	f0 26		beq $018128			beq 	_IFT_Left
.018102	c9 04		cmp #$04			cmp 	#"D"-64
.018104	f0 2e		beq $018134			beq 	_IFT_Right
.018106	c9 17		cmp #$17			cmp 	#"W"-64
.018108	f0 36		beq $018140			beq 	_IFT_Up
.01810a	c9 13		cmp #$13			cmp 	#"S"-64
.01810c	f0 3e		beq $01814c			beq 	_IFT_Down
.01810e	c9 08		cmp #$08			cmp 	#"H"-64
.018110	f0 09		beq $01811b			beq 	_IFT_Backspace
.018112	c9 1a		cmp #$1a			cmp 	#"Z"-64
.018114	d0 d8		bne $0180ee			bne 	_IFT_RLLoop
.018116	20 00 80	jsr $018000			jsr 	IFT_ClearScreen				; clear CTL-Z
.018119	80 d3		bra $0180ee			bra 	_IFT_RLLoop
.01811b					_IFT_Backspace:
.01811b	ad 00 05	lda $0500			lda 	IFT_XCursor 				; check not start of line.
.01811e	f0 ce		beq $0180ee			beq 	_IFT_RLLoop
.018120	20 d1 81	jsr $0181d1			jsr 	IF_LeftOne
.018123	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.018125	20 c8 81	jsr $0181c8			jsr 	IF_Write
.018128					_IFT_Left:
.018128	ce 00 05	dec $0500			dec 	IFT_XCursor 				; left CTL-W
.01812b	10 29		bpl $018156			bpl 	_IFT_Reposition
.01812d	a9 3f		lda #$3f			lda 	#IF_Width-1
.01812f					_IFT_SetX:
.01812f	8d 00 05	sta $0500			sta 	IFT_XCursor
.018132	80 22		bra $018156			bra 	_IFT_Reposition
.018134					_IFT_Right:
.018134	ee 00 05	inc $0500			inc 	IFT_XCursor
.018137	ad 00 05	lda $0500			lda 	IFT_XCursor
.01813a	49 40		eor #$40			eor 	#IF_Width
.01813c	f0 f1		beq $01812f			beq 	_IFT_SetX
.01813e	80 16		bra $018156			bra 	_IFT_Reposition
.018140					_IFT_Up:
.018140	ce 01 05	dec $0501			dec 	IFT_YCursor
.018143	10 11		bpl $018156			bpl 	_IFT_Reposition
.018145	a9 1f		lda #$1f			lda 	#IF_Height-1
.018147					_IFT_SetY:
.018147	8d 01 05	sta $0501			sta 	IFT_YCursor
.01814a	80 0a		bra $018156			bra 	_IFT_Reposition
.01814c					_IFT_Down:
.01814c	ee 01 05	inc $0501			inc 	IFT_YCursor
.01814f	ad 01 05	lda $0501			lda 	IFT_YCursor
.018152	49 20		eor #$20			eor 	#IF_Height
.018154	f0 f1		beq $018147			beq 	_IFT_SetY
.018156					_IFT_Reposition:
.018156	ad 00 05	lda $0500			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.018159	48		pha				pha
.01815a	ad 01 05	lda $0501			lda 	IFT_YCursor
.01815d	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.018160	68		pla				pla
.018161	aa		tax				tax
.018162	e0 00		cpx #$00			cpx 	#0
.018164	f0 88		beq $0180ee			beq 	_IFT_RLLoop
.018166					_IFT_MoveRight:
.018166	20 bf 81	jsr $0181bf			jsr 	IF_Read
.018169	ee 00 05	inc $0500			inc 	IFT_XCursor
.01816c	ca		dex				dex
.01816d	d0 f7		bne $018166			bne 	_IFT_MoveRight
.01816f	4c ee 80	jmp $0180ee			jmp 	_IFT_RLLoop
.018172					_IFT_RLExit:
.018172	ad 01 05	lda $0501			lda 	IFT_YCursor 				; go to start of line.
.018175	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.018178	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.01817a					_IFT_RLRead:
.01817a	20 bf 81	jsr $0181bf			jsr 	IF_Read
.01817d	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.018180	e8		inx				inx
.018181	e0 40		cpx #$40			cpx 	#IF_Width
.018183	d0 f5		bne $01817a			bne 	_IFT_RLRead
.018185					_IFT_RL_Trim:
.018185	ca		dex				dex 	 							; previous char
.018186	30 07		bmi $01818f			bmi 	_IFT_Found 					; gone too far
.018188	bd 66 05	lda $0566,x			lda 	IFT_LineBuffer,x			; go back if space
.01818b	c9 20		cmp #$20			cmp 	#" "
.01818d	f0 f6		beq $018185			beq 	_IFT_RL_Trim
.01818f					_IFT_Found:
.01818f	e8		inx				inx 								; forward to non-space
.018190	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.018192	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.018195	68		pla				pla
.018196	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.018198	a0 05		ldy #$05			ldy 	#IFT_LineBuffer >> 8
.01819a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_em65816.asm

=64					IF_Width 	= 64 							; characters across
=32					IF_Height 	= 32 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line.
=8					IF_XPos 	= 8 							; current position, horizontal.
=$f0000					IF_Screen = $F0000							; 2k screen RAM here
=$f8010					IF_PKeyboard = $F8010						; Keyboard port.
=$f8000					IF_PBreak = $F8000 							; Break key.
.01819b					IF_Reset:
.01819b	60		rts				rts
.01819c					IF_Home:
.01819c	48		pha				pha
.01819d	64 08		stz $08				stz 	IF_XPos 					; zero X position
.01819f	a9 00		lda #$00			lda 	#IF_Screen & $FF 			; set r/w pos.
.0181a1	85 04		sta $04				sta 	IF_Pos
.0181a3	a9 00		lda #$00			lda 	#(IF_Screen >> 8) & $FF
.0181a5	85 05		sta $05				sta 	IF_Pos+1
.0181a7	a9 0f		lda #$0f			lda 	#IF_Screen >> 16
.0181a9	85 06		sta $06				sta 	IF_Pos+2
.0181ab	64 07		stz $07				stz 	IF_Pos+3
.0181ad	68		pla				pla
.0181ae	60		rts				rts
.0181af					IF_NewLine:
.0181af	48		pha				pha
.0181b0	64 08		stz $08				stz 	IF_XPos						; back to start of line
.0181b2	18		clc				clc 								; down one line
.0181b3	a5 04		lda $04				lda 	IF_Pos
.0181b5	69 40		adc #$40			adc 	#64
.0181b7	85 04		sta $04				sta 	IF_Pos
.0181b9	90 02		bcc $0181bd			bcc 	_IF_NoCarry 				; carry through.
.0181bb	e6 05		inc $05				inc 	IF_Pos+1
.0181bd					_IF_NoCarry:
.0181bd	68		pla				pla
.0181be	60		rts				rts
.0181bf					IF_Read:
.0181bf	5a		phy				phy 								; save current Y
.0181c0	a4 08		ldy $08				ldy 	IF_XPos 					; read character at current position
.0181c2	b7 04		lda [$04],y			lda 	[IF_Pos],y
.0181c4	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181c6	7a		ply				ply									; restore Y
.0181c7	60		rts				rts
.0181c8					IF_Write:
.0181c8	5a		phy				phy 								; save current Y
.0181c9	a4 08		ldy $08				ldy 	IF_XPos 					; write character at current position
.0181cb	97 04		sta [$04],y			sta 	[IF_Pos],y
.0181cd	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181cf	7a		ply				ply									; restore Y
.0181d0	60		rts				rts
.0181d1					IF_LeftOne:
.0181d1	c6 08		dec $08				dec 	IF_XPos
.0181d3	60		rts				rts
.0181d4					IF_CheckBreak:
.0181d4	af 00 80 0f	lda $0f8000			lda 	IF_PBreak					; non-zero if Ctrl+C pressed.
.0181d8	60		rts				rts
.0181d9					IF_GetKey:
.0181d9	af 10 80 0f	lda $0f8010			lda 	IF_PKeyboard				; read keyboard
.0181dd	f0 08		beq $0181e7			beq		_IFGK_NoKey 				; skip if zero,no key pressed
.0181df	48		pha				pha 								; key pressed, clear queue.
.0181e0	a9 00		lda #$00			lda 	#0
.0181e2	8f 10 80 0f	sta $0f8010			sta 	IF_PKeyboard
.0181e6	68		pla				pla
.0181e7					_IFGK_NoKey:
.0181e7	09 00		ora #$00			ora 	#0							; set Z flag appropriately.
.0181e9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.0181ea					TIM_Error:
.0181ea	20 29 80	jsr $018029			jsr 	IFT_UpLine 					; go up one line.
.0181ed	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.0181ef	80 02		bra $0181f3			bra 	TIM_ShowPrompt
.0181f1					TIM_NewCommand:
.0181f1	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.0181f3					TIM_ShowPrompt:
.0181f3	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.0181f6	20 ed 80	jsr $0180ed			jsr 	IFT_ReadLine	 			; get character, go to next line
.0181f9	20 4f 80	jsr $01804f			jsr 	IFT_NewLine					; go to next line.
.0181fc	86 10		stx $10				stx 	zTemp1 						; save line read address
.0181fe	84 11		sty $11				sty 	zTemp1+1
.018200	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.018202	b1 10		lda ($10),y			lda 	(zTemp1),y
.018204	c9 3f		cmp #$3f			cmp 	#"?"
.018206	f0 04		beq $01820c			beq 	TIM_SkipFirst
.018208	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.01820a	d0 01		bne $01820d			bne 	TIM_NotDot
.01820c					TIM_SkipFirst:
.01820c	c8		iny				iny
.01820d					TIM_NotDot:
.01820d	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.01820f	c9 52		cmp #$52			cmp 	#"R"						; show registers
.018211	f0 6b		beq $01827e			beq 	TIM_ShowRegisters
.018213	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.018215	f0 12		beq $018229			beq 	TIM_ShowMemory
.018217	c9 47		cmp #$47			cmp 	#"G"						; execute
.018219	f0 49		beq $018264			beq 	TIM_Execute
.01821b	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.01821d	f0 07		beq $018226			beq 	TIM_GoLoadMemory
.01821f	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.018221	d0 c7		bne $0181ea			bne 	TIM_Error
.018223	4c a2 83	jmp $0183a2			jmp 	TIM_UpdateRegisters
.018226					TIM_GoLoadMemory:
.018226	4c d2 83	jmp $0183d2			jmp 	TIM_LoadMemory
.018229					TIM_ShowMemory:
.018229	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.01822c	b0 bc		bcs $0181ea			bcs 	TIM_Error
.01822e	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.018230	85 12		sta $12				sta 	zTemp2
.018232	a5 15		lda $15				lda 	zTemp3+1
.018234	85 13		sta $13				sta 	zTemp2+1
.018236	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.018239	90 08		bcc $018243			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.01823b	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.01823d	85 14		sta $14				sta 	zTemp3
.01823f	a5 13		lda $13				lda 	zTemp2+1
.018241	85 15		sta $15				sta 	zTemp3+1
.018243					_TIMSM_Start:
.018243	20 f6 82	jsr $0182f6			jsr 	TIM_WriteLine 				; write one line of hex out
.018246	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.018248	18		clc				clc
.018249	69 10		adc #$10			adc 	#16
.01824b	85 12		sta $12				sta 	zTemp2
.01824d	90 02		bcc $018251			bcc 	_TIMSM_NoCarry
.01824f	e6 13		inc $13				inc 	zTemp2+1
.018251					_TIMSM_NoCarry:
.018251	20 d4 81	jsr $0181d4			jsr 	IF_CheckBreak 				; check CTL+C
.018254	d0 0b		bne $018261			bne 	_TIMSM_Ends 				; if pressed break out.
.018256	38		sec				sec 								; check past the end address in zTemp3
.018257	a5 14		lda $14				lda 	zTemp3
.018259	e5 12		sbc $12				sbc 	zTemp2
.01825b	a5 15		lda $15				lda 	zTemp3+1
.01825d	e5 13		sbc $13				sbc 	zTemp2+1
.01825f	10 e2		bpl $018243			bpl 	_TIMSM_Start
.018261					_TIMSM_Ends:
.018261	4c f1 81	jmp $0181f1			jmp 	TIM_NewCommand
.018264					TIM_Execute:
.018264	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; get the execute address
.018267	b0 81		bcs $0181ea			bcs 	TIM_Error 					; not legitimate
.018269	ae cb 03	ldx $03cb			ldx 	TIM_SP 						; set up SP
.01826c	9a		txs				txs
.01826d	ad c6 03	lda $03c6			lda 	TIM_SR 						; Status for PLP
.018270	48		pha				pha
.018271	ad c7 03	lda $03c7			lda 	TIM_A 						; restore AXYZ
.018274	ae c8 03	ldx $03c8			ldx 	TIM_X
.018277	ac c9 03	ldy $03c9			ldy 	TIM_Y
.01827a	28		plp				plp 								; and PS Byte.
.01827b	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.01827e					TIM_Start:
.01827e					TIM_ShowRegisters:
.01827e	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.018281	8d c5 03	sta $03c5			sta 	TIM_IRQ+1
.018284	ad ff ff	lda $ffff			lda 	$FFFF
.018287	8d c4 03	sta $03c4			sta 	TIM_IRQ
.01828a	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.01828c					_TIMSR_Text:
.01828c	bf bd 82 01	lda $0182bd,x			lda 	_TIMSR_Label,x
.018290	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018293	e8		inx				inx
.018294	e0 20		cpx #$20			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.018296	d0 f4		bne $01828c			bne 	_TIMSR_Text
.018298	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.01829a					_TIMSR_Skip:
.01829a	e8		inx				inx
.01829b					_TIMSR_LoopSpace:
.01829b	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.01829d	b0 04		bcs $0182a3			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.01829f	8a		txa				txa
.0182a0	4a		lsr a				lsr 	a
.0182a1	b0 05		bcs $0182a8			bcs 	_TIMSR_NoSpace
.0182a3					_TIMSR_Space:
.0182a3	a9 20		lda #$20			lda 	#" "
.0182a5	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182a8					_TIMSR_NoSpace:
.0182a8	bd c2 03	lda $03c2,x			lda 	TIM_PC,x 					; output hex value.
.0182ab	20 dd 82	jsr $0182dd			jsr 	TIM_WriteHex
.0182ae	e8		inx				inx
.0182af	e0 08		cpx #$08			cpx 	#TIM_Z-TIM_PC
.0182b1	f0 e7		beq $01829a			beq 	_TIMSR_Skip
.0182b3	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.0182b5	d0 e4		bne $01829b			bne 	_TimSR_LoopSpace
.0182b7	20 4f 80	jsr $01804f			jsr 	IFT_NewLine 				; new line
.0182ba	4c f1 81	jmp $0181f1			jmp	 	TIM_NewCommand 				; new command.
.0182bd					_TIMSR_Label:
>0182bd	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>0182c5	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>0182d5	52
>0182d6	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.0182dd					_TIMSR_LabelEnd:
.0182dd					TIM_WriteHex:
.0182dd	48		pha				pha 								; save A
.0182de	4a		lsr a				lsr 	a 							; shift MSB->LSB
.0182df	4a		lsr a				lsr 	a
.0182e0	4a		lsr a				lsr 	a
.0182e1	4a		lsr a				lsr 	a
.0182e2	20 e6 82	jsr $0182e6			jsr 	_TIMWH_Nibble 				; print MSB
.0182e5	68		pla				pla 								; restore and print LSB
.0182e6					_TIMWH_Nibble:
.0182e6	48		pha				pha
.0182e7	29 0f		and #$0f			and 	#15 						; mask out
.0182e9	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.0182eb	90 02		bcc $0182ef			bcc 	_TIMWHNoLetter
.0182ed	69 06		adc #$06			adc 	#6
.0182ef					_TIMWHNoLetter:
.0182ef	69 30		adc #$30			adc 	#48
.0182f1	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter 			; print it out.
.0182f4	68		pla				pla
.0182f5	60		rts				rts
.0182f6					TIM_WriteLine:
.0182f6	a9 2e		lda #$2e			lda 	#"." 						; prompt
.0182f8	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182fb	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.0182fd	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018300	a5 13		lda $13				lda 	zTemp2+1 					; write address
.018302	20 dd 82	jsr $0182dd			jsr 	TIM_WriteHex
.018305	a5 12		lda $12				lda 	zTemp2
.018307	20 dd 82	jsr $0182dd			jsr 	TIM_WriteHex
.01830a	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.01830c					_TIMWL_Loop:
.01830c	a9 20		lda #$20			lda 	#" "
.01830e	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018311	b1 12		lda ($12),y			lda 	(zTemp2),y
.018313	20 dd 82	jsr $0182dd			jsr 	TIM_WriteHex
.018316	c8		iny				iny
.018317	c0 10		cpy #$10			cpy 	#16
.018319	d0 f1		bne $01830c			bne 	_TIMWL_Loop
.01831b	4c 4f 80	jmp $01804f			jmp 	IFT_NewLine 				; new line and exit
.01831e					TIM_GetHex:
.01831e	c8		iny				iny
.01831f	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.018321	c9 20		cmp #$20			cmp 	#32
.018323	f0 f9		beq $01831e			beq 	TIM_GetHex
.018325	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.018327	f0 f5		beq $01831e			beq 	TIM_GetHex
.018329	20 52 83	jsr $018352			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.01832c	b0 23		bcs $018351			bcs 	_TIMGH_Exit					; if first bad then exit now.
.01832e	a9 00		lda #$00			lda 	#0 							; zero result
.018330	85 14		sta $14				sta 	zTemp3
.018332	85 15		sta $15				sta 	zTemp3+1
.018334					_TIM_GHLoop:
.018334	20 52 83	jsr $018352			jsr 	TIM_GetHexCharacter 		; get next character
.018337	b0 17		bcs $018350			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.018339	c8		iny				iny 								; skip over it.
.01833a	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.01833c	26 15		rol $15				rol 	zTemp3+1
.01833e	06 14		asl $14				asl 	zTemp3 						; now x 2
.018340	26 15		rol $15				rol 	zTemp3+1
.018342	06 14		asl $14				asl 	zTemp3						; now x 4
.018344	26 15		rol $15				rol 	zTemp3+1
.018346	06 14		asl $14				asl 	zTemp3 						; now x 8
.018348	26 15		rol $15				rol 	zTemp3+1
.01834a	05 14		ora $14				ora 	zTemp3 						; OR result in
.01834c	85 14		sta $14				sta 	zTemp3
.01834e	80 e4		bra $018334			bra 	_TIM_GHLoop 				; loop round again.
.018350					_TIMGH_Okay:
.018350	18		clc				clc
.018351					_TIMGH_Exit:
.018351	60		rts				rts
.018352					TIM_GetHexCharacter:
.018352	b1 10		lda ($10),y			lda 	(zTemp1),y
.018354	38		sec				sec
.018355	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.018357	90 0e		bcc $018367			bcc 	_TIM_GHCFail
.018359	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.01835b	90 0b		bcc $018368			bcc 	_TIM_GHCExit
.01835d	c9 11		cmp #$11			cmp 	#65-48						; < A
.01835f	90 06		bcc $018367			bcc		_TIM_GHCFail
.018361	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.018363	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.018365	90 01		bcc $018368			bcc		_TIM_GHCExit
.018367					_TIM_GHCFail:
.018367	38		sec				sec
.018368					_TIM_GHCExit:
.018368	60		rts				rts
.018369					TIM_BreakVector:
.018369	da		phx				phx									; save X/A on stack
.01836a	48		pha				pha
.01836b	ba		tsx				tsx 								; X points to S
.01836c	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.01836f	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.018371	d0 03		bne $018376			bne 	_TIMBreak					; if set, it's BRK
.018373	68		pla				pla 								; abandon routine.
.018374	fa		plx				plx
.018375	40		rti				rti
.018376					_TIMBreak:
.018376	68		pla				pla 								; save A X Y and maybe Z
.018377	8d c7 03	sta $03c7			sta 	TIM_A
.01837a	fa		plx				plx
.01837b	8e c8 03	stx $03c8			stx 	TIM_X
.01837e	8c c9 03	sty $03c9			sty 	TIM_Y
.018381	68		pla				pla 								; get Status Register
.018382	8d c6 03	sta $03c6			sta 	TIM_SR
.018385	68		pla				pla
.018386	8d c3 03	sta $03c3			sta 	TIM_PC+1 					; save calling address
.018389	68		pla				pla
.01838a	8d c2 03	sta $03c2			sta 	TIM_PC 						; high byte
.01838d	ad c3 03	lda $03c3			lda 	TIM_PC+1 					; dec PC to point right.
.018390	d0 03		bne $018395			bne 	_TIMDecrement 				; brk bumps it.
.018392	ce c2 03	dec $03c2			dec 	TIM_PC
.018395					_TIMDecrement:
.018395	ce c3 03	dec $03c3			dec 	TIM_PC+1
.018398	ba		tsx				tsx 								; and copy SP
.018399	8e cb 03	stx $03cb			stx 	TIM_SP
.01839c	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.01839e	9a		txs				txs
.01839f	4c 7e 82	jmp $01827e			jmp 	TIM_Start 					; and start up TIM monitor.
.0183a2					TIM_UpdateRegisters:
.0183a2	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; PC
.0183a5	b0 28		bcs $0183cf			bcs 	_TIMURFail
.0183a7	a5 14		lda $14				lda 	zTemp3
.0183a9	8d c3 03	sta $03c3			sta 	Tim_PC+1
.0183ac	a5 15		lda $15				lda 	zTemp3+1
.0183ae	8d c2 03	sta $03c2			sta 	Tim_PC
.0183b1	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; ignore IRQ
.0183b4	b0 19		bcs $0183cf			bcs 	_TIMURFail
.0183b6	a2 00		ldx #$00			ldx 	#0
.0183b8					_TIM_URLoop:
.0183b8	e0 04		cpx #$04			cpx 	#Tim_Z-Tim_SR
.0183ba	d0 01		bne $0183bd			bne 	_TIM_1
.0183bc	e8		inx				inx
.0183bd					_TIM_1:
.0183bd	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; registers
.0183c0	b0 0d		bcs $0183cf			bcs 	_TIMURFail
.0183c2	a5 14		lda $14				lda 	zTemp3
.0183c4	9d c6 03	sta $03c6,x			sta 	Tim_SR,x
.0183c7	e8		inx				inx
.0183c8	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.0183ca	d0 ec		bne $0183b8			bne 	_TIM_URLoop
.0183cc	4c f1 81	jmp $0181f1			jmp 	TIM_NewCommand
.0183cf					_TIMURFail:
.0183cf	4c ea 81	jmp $0181ea			jmp 	TIM_Error
.0183d2					TIM_LoadMemory:
.0183d2	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; target address => zTemp2
.0183d5	a5 14		lda $14				lda 	zTemp3
.0183d7	85 12		sta $12				sta 	zTemp2
.0183d9	a5 15		lda $15				lda 	zTemp3+1
.0183db	85 13		sta $13				sta 	zTemp2+1
.0183dd					_TIM_LMLoop:
.0183dd	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; next byte ?
.0183e0	b0 0e		bcs $0183f0			bcs 	_TIMLMDone 					; no more
.0183e2	a2 00		ldx #$00			ldx 	#0							; write out.
.0183e4	a5 14		lda $14				lda 	zTemp3
.0183e6	81 12		sta ($12,x)			sta 	(zTemp2,x)
.0183e8	e6 12		inc $12				inc 	zTemp2 						; bump address
.0183ea	d0 f1		bne $0183dd			bne 	_TIM_LMLoop
.0183ec	e6 13		inc $13				inc 	zTemp2+1
.0183ee	80 ed		bra $0183dd			bra 	_TIM_LMLoop
.0183f0					_TIMLMDone:
.0183f0	4c f1 81	jmp $0181f1			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/skip.asm

.0183f3					StructureSearchSingle:
.0183f3	a2 00		ldx #$00			ldx 	#0
.0183f5					StructureSearchDouble:
.0183f5	85 10		sta $10				sta 	zTemp1 						; save the target on zTemp1,zTemp1+1
.0183f7	86 11		stx $11				stx 	zTemp1+1
.0183f9	a9 00		lda #$00			lda 	#0 							; set the structure depth to zero (zTemp2)
.0183fb	85 12		sta $12				sta 	zTemp2
.0183fd	80 18		bra $018417			bra 	_SSWLoop 					; jump in, start scanning from here.
.0183ff					_SSWNextLine:
.0183ff	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018401	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.018403	18		clc				clc
.018404	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018406	85 16		sta $16				sta 	zCodePtr
.018408	90 02		bcc $01840c			bcc 	_SNLNoCarry
.01840a	e6 17		inc $17				inc 	zCodePtr+1
.01840c					_SNLNoCarry:
.01840c	a0 00		ldy #$00			ldy 	#0
.01840e	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018410	c9 00		cmp #$00			cmp 	#0					 		; if zero, fail.
.018412	f0 54		beq $018468			beq 	_SSWFail
.018414	c8		iny				iny
.018415	c8		iny				iny
.018416					_SSWNextSimple:
.018416	c8		iny				iny
.018417					_SSWLoop:
.018417	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018419	c9 00		cmp #$00			cmp 	#0 							; end of line ?
.01841b	f0 e2		beq $0183ff			beq 	_SSWNextLine 				; if so, then next line
.01841d	10 f7		bpl $018416			bpl 	_SSWNextSimple 				; needs to be a token, just skip char/number.
.01841f	a6 12		ldx $12				ldx 	zTemp2 						; check structure count
.018421	d0 08		bne $01842b			bne 	_SSWCheckUpDown 			; if it's non zero, then a match doesn't work.
.018423	c5 10		cmp $10				cmp 	zTemp1 						; found the right keyword, either choice.
.018425	f0 2d		beq $018454			beq 	_SSWFound 					; so exit.
.018427	c5 11		cmp $11				cmp 	zTemp1+1
.018429	f0 29		beq $018454			beq 	_SSWFound
.01842b					_SSWCheckUpDown:
.01842b	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus 			; if < keyword +
.01842d	90 10		bcc $01843f			bcc 	_SSWNext
.01842f	c9 93		cmp #$93			cmp 	#firstKeywordMinus 			; if < keyword - then as keyword +
.018431	90 08		bcc $01843b			bcc 	_SSWPlus
.018433	c9 98		cmp #$98			cmp 	#firstUnaryFunction			; if < first unary down as keyword -
.018435	b0 08		bcs $01843f			bcs 	_SSWNext
.018437	c6 12		dec $12				dec 	zTemp2 						; reduce structure count.
.018439	c6 12		dec $12				dec 	zTemp2
.01843b					_SSWPlus:
.01843b	e6 12		inc $12				inc 	zTemp2
.01843d	30 16		bmi $018455			bmi 	_SSWUnder					; error if driven -ve
.01843f					_SSWNext:
.01843f	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018441	c8		iny				iny 								; skip
.018442	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018444	90 0c		bcc $018452			bcc 	_SEDone 					; so just skip over it.
.018446	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018448	90 07		bcc $018451			bcc 	_SEDouble
.01844a	98		tya				tya 								; this is Y + 1
.01844b	18		clc				clc
.01844c	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.01844e	a8		tay				tay 								; back in Y.
.01844f	88		dey				dey 								; fix up, one for the +1, one for the iny
.018450	88		dey				dey
.018451					_SEDouble:
.018451	c8		iny				iny
.018452					_SEDone:
.018452	80 c3		bra $018417			bra 	_SSWLoop
.018454					_SSWFound:
.018454	60		rts				rts
.018455					_SSWUnder:
.018455	20 6e 85	jsr $01856e			jsr ERR_Handler
>018458	53 74 72 75 63 74 75 72			.text "Structure order",0
>018460	65 20 6f 72 64 65 72 00
.018468					_SSWFail:
.018468	20 6e 85	jsr $01856e			jsr ERR_Handler
>01846b	43 61 6e 27 74 20 66 69			.text "Can't find structure",0
>018473	6e 64 20 73 74 72 75 63 74 75 72 65 00
.018480					SkipEndOfCommand:
.018480	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018482	c9 00		cmp #$00			cmp 	#0 							; if zero, end of line, so exit
.018484	f0 19		beq $01849f			beq 	_SOCExit
.018486	c9 c0		cmp #$c0			cmp 	#token_Colon 				; if colon, end of command
.018488	f0 15		beq $01849f			beq 	_SOCExit
.01848a	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.01848c	c8		iny				iny 								; skip
.01848d	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.01848f	90 0c		bcc $01849d			bcc 	_SEDone 					; so just skip over it.
.018491	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018493	90 07		bcc $01849c			bcc 	_SEDouble
.018495	98		tya				tya 								; this is Y + 1
.018496	18		clc				clc
.018497	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018499	a8		tay				tay 								; back in Y.
.01849a	88		dey				dey 								; fix up, one for the +1, one for the iny
.01849b	88		dey				dey
.01849c					_SEDouble:
.01849c	c8		iny				iny
.01849d					_SEDone:
.01849d	80 e1		bra $018480			bra 	SkipEndOfCommand
.01849f					_SOCExit:
.01849f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stack.asm

.0184a0					StackReset:
.0184a0	48		pha				pha
.0184a1	5a		phy				phy
.0184a2	a9 00		lda #$00			lda 	#(BasicStack & $FF) 		; reset pointer
.0184a4	85 26		sta $26				sta 	zBasicSP
.0184a6	a9 04		lda #$04			lda 	#(BasicStack >> 8)
.0184a8	85 27		sta $27				sta 	zBasicSP+1
.0184aa	a0 00		ldy #$00			ldy 	#0 							; reset stack top to $00 which cannot
.0184ac	98		tya				tya 								; be a legal token.
.0184ad	91 26		sta ($26),y			sta 	(zBasicSP),y
.0184af	7a		ply				ply
.0184b0	68		pla				pla
.0184b1	60		rts				rts
.0184b2					StackPushFrame:
.0184b2	48		pha				pha
.0184b3	5a		phy				phy
.0184b4	1a		inc a				inc 	a 							; one extra byte in frame, for the marker.
.0184b5	48		pha				pha 								; save it.
.0184b6	29 0f		and #$0f			and 	#$0F 						; lower 4 bits
.0184b8	18		clc				clc 								; add to Basic Stack
.0184b9	65 26		adc $26				adc 	zBasicSP
.0184bb	85 26		sta $26				sta 	zBasicSP
.0184bd	90 02		bcc $0184c1			bcc 	_SPFNoBump
.0184bf	e6 27		inc $27				inc 	zBasicSP+1
.0184c1					_SPFNoBump:
.0184c1	a0 00		ldy #$00			ldy 	#0
.0184c3	68		pla				pla
.0184c4	91 26		sta ($26),y			sta 	(zBasicSP),y
.0184c6	7a		ply				ply
.0184c7	68		pla				pla
.0184c8	60		rts				rts
.0184c9					StackPopFrame:
.0184c9	48		pha				pha
.0184ca	5a		phy				phy
.0184cb	a0 00		ldy #$00			ldy 	#0 							; compare with top of stack using EOR
.0184cd	51 26		eor ($26),y			eor 	(zBasicSP),y
.0184cf	29 f0		and #$f0			and 	#$F0 						; top 4 bits zero, match
.0184d1	d0 12		bne $0184e5			bne 	SPFError 					; mixed structures
.0184d3	b1 26		lda ($26),y			lda 	(zBasicSP),y 				; get size from byte
.0184d5	29 0f		and #$0f			and 	#$0F
.0184d7	49 ff		eor #$ff			eor 	#$FF						; 2's complement
.0184d9	38		sec				sec
.0184da	65 26		adc $26				adc 	zBasicSP
.0184dc	85 26		sta $26				sta 	zBasicSP
.0184de	b0 02		bcs $0184e2			bcs 	_SPFNoBump
.0184e0	c6 27		dec $27				dec 	zBasicSP+1
.0184e2					_SPFNoBump:
.0184e2	7a		ply				ply
.0184e3	68		pla				pla
.0184e4	60		rts				rts
.0184e5					SPFError:
.0184e5	20 6e 85	jsr $01856e			jsr ERR_Handler
>0184e8	4d 69 78 65 64 20 53 74			.text "Mixed Structures",0
>0184f0	72 75 63 74 75 72 65 73 00
.0184f9					StackSavePosition:
.0184f9	98		tya				tya
.0184fa	5a		phy				phy
.0184fb	a0 05		ldy #$05			ldy 	#5
.0184fd	91 26		sta ($26),y			sta 	(zBasicSP),y
.0184ff	a0 01		ldy #$01			ldy 	#1
.018501	a5 16		lda $16				lda 	zCodePtr+0 					; 4 bytes, could reduce this for 65816/6502
.018503	91 26		sta ($26),y			sta 	(zBasicSP),y
.018505	c8		iny				iny
.018506	a5 17		lda $17				lda 	zCodePtr+1
.018508	91 26		sta ($26),y			sta 	(zBasicSP),y
.01850a	c8		iny				iny
.01850b	a5 18		lda $18				lda 	zCodePtr+2
.01850d	91 26		sta ($26),y			sta 	(zBasicSP),y
.01850f	c8		iny				iny
.018510	a5 19		lda $19				lda 	zCodePtr+3
.018512	91 26		sta ($26),y			sta 	(zBasicSP),y
.018514	7a		ply				ply
.018515	60		rts				rts
.018516					StackRestorePosition:
.018516	5a		phy				phy
.018517	a0 01		ldy #$01			ldy 	#1 							; copy 4 bytes that are the pointer
.018519	b1 26		lda ($26),y			lda 	(zBasicSP),y
.01851b	85 16		sta $16				sta 	zCodePtr+0
.01851d	c8		iny				iny
.01851e	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018520	85 17		sta $17				sta 	zCodePtr+1
.018522	c8		iny				iny
.018523	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018525	85 18		sta $18				sta 	zCodePtr+2
.018527	c8		iny				iny
.018528	b1 26		lda ($26),y			lda 	(zBasicSP),y
.01852a	85 19		sta $19				sta 	zCodePtr+3
.01852c	c8		iny				iny
.01852d	b1 26		lda ($26),y			lda 	(zBasicSP),y 				; offset
.01852f	7a		ply				ply 								; restore Y
.018530	a8		tay				tay
.018531	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/vectors.asm

.018532					CharPrint:
.018532	4c 35 80	jmp $018035			jmp 	IFT_PrintCharacter
.018535					CharGet:
.018535	4c d9 81	jmp $0181d9			jmp 	IF_GetKey
.018538					CheckBreak:
.018538	4c d4 81	jmp $0181d4			jmp 	IF_CheckBreak
.01853b					CharGetPosition:
.01853b	ad 00 05	lda $0500			lda 	IFT_XCursor
.01853e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/errors.asm

.01853f					SyntaxError:
.01853f	20 6e 85	jsr $01856e			jsr 	ERR_Handler
>018542	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>01854a	72 72 6f 72 00
.01854f					TypeError:
.01854f	20 6e 85	jsr $01856e			jsr 	ERR_Handler
>018552	57 72 6f 6e 67 20 74 79				.text 	"Wrong type",0
>01855a	70 65 00
.01855d					BadParamError:
.01855d	20 6e 85	jsr $01856e			jsr 	ERR_Handler
>018560	42 61 64 20 50 61 72 61				.text 	"Bad Parameter",0
>018568	6d 65 74 65 72 00
.01856e					ERR_Handler:
.01856e	a0 00		ldy #$00			ldy 	#0
.018570	c8		iny				iny
.018571	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018573	85 80		sta $80				sta 	XS_Mantissa
.018575	c8		iny				iny
.018576	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018578	85 81		sta $81				sta 	XS_Mantissa+1
.01857a	fa		plx				plx 								; address in XY
.01857b	7a		ply				ply
.01857c	e8		inx				inx 								; bump, because of RTS/JSR address -1
.01857d	d0 01		bne $018580			bne 	_EHNoSkip
.01857f	c8		iny				iny
.018580					_EHNoSkip:
.018580	20 9f 85	jsr $01859f			jsr 	PrintROMMessage 			; print message from ROM.
.018583	a5 80		lda $80				lda 	XS_Mantissa					; line number = 0
.018585	05 81		ora $81				ora 	XS_Mantissa+1
.018587	f0 0c		beq $018595			beq 	_EHNoLine
.018589	a2 9a		ldx #$9a			ldx 	#_EHAt & $FF 				; print " at "
.01858b	a0 85		ldy #$85			ldy 	#(_EHAt >> 8) & $FF
.01858d	20 9f 85	jsr $01859f			jsr 	PrintROMMessage
.018590	a2 00		ldx #$00			ldx 	#0 							; Print line number
.018592	20 b4 85	jsr $0185b4			jsr 	Print16BitInteger
.018595					_EHNoLine:
.018595	80 fe		bra $018595			bra 	_EHNoLine
.018597	4c 27 88	jmp $018827			jmp 	WarmStart
>01859a	20 61 74 20 00			_EHAt:	.text 	" at ",0
.01859f					PrintROMMessage:
.01859f	86 1a		stx $1a				stx 	zLTemp1 					; save addres
.0185a1	84 1b		sty $1b				sty 	zLTemp1+1
.0185a3	4b		phk				phk
.0185a4	68		pla				pla
.0185a5	85 1c		sta $1c				sta 	ZLTemp1+2
.0185a7	a0 00		ldy #$00			ldy 	#0
.0185a9					_PRMLoop:
.0185a9	b7 1a		lda [$1a],y			lda 	[zLTemp1],y
.0185ab	f0 06		beq $0185b3			beq		_PRMExit
.0185ad	c8		iny				iny
.0185ae	20 32 85	jsr $018532			jsr 	CharPrint
.0185b1	80 f6		bra $0185a9			bra 	_PRMLoop
.0185b3					_PRMExit:
.0185b3	60		rts				rts
.0185b4					Print16BitInteger:
.0185b4	a9 00		lda #$00			lda 	#0 							; make 32 bit
.0185b6	85 82		sta $82				sta 	XS_Mantissa+2
.0185b8	85 83		sta $83				sta 	XS_Mantissa+3
.0185ba					Print32BitInteger:
.0185ba	a9 00		lda #$00			lda 	#0
.0185bc	8d 14 03	sta $0314			sta 	NumBufX 					; reset the conversion pointer
.0185bf	aa		tax				tax 								; convert bottom level.
.0185c0	20 ba 9d	jsr $019dba			jsr 	INTToString 				; make string
.0185c3	a2 00		ldx #$00			ldx 	#0 							; print buffer
.0185c5	bd 15 03	lda $0315,x	_P1Loop:lda 	Num_Buffer,x
.0185c8	f0 06		beq $0185d0			beq 	_P1Exit
.0185ca	20 32 85	jsr $018532			jsr 	CharPrint
.0185cd	e8		inx				inx
.0185ce	80 f5		bra $0185c5			bra 	_P1Loop
.0185d0	8a		txa		_P1Exit:txa 								; return chars printed.
.0185d1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm


;******  Processing file: modules/basic/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b6					lastUnaryFunction = $b6
.0185d2					VectorTable:
>0185d2	12 92					.word BinaryOp_And         & $FFFF ; $80 and
>0185d4	2e 92					.word BinaryOp_Or          & $FFFF ; $81 or
>0185d6	4a 92					.word BinaryOp_Xor         & $FFFF ; $82 xor
>0185d8	4a 92					.word BinaryOp_Eor         & $FFFF ; $83 eor
>0185da	81 92					.word Binary_Equal         & $FFFF ; $84 =
>0185dc	9b 92					.word Binary_NotEqual      & $FFFF ; $85 <>
>0185de	a4 92					.word Binary_Less          & $FFFF ; $86 <
>0185e0	ad 92					.word Binary_LessEqual     & $FFFF ; $87 <=
>0185e2	bf 92					.word Binary_Greater       & $FFFF ; $88 >
>0185e4	b6 92					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>0185e6	44 93					.word BinaryOp_Add         & $FFFF ; $8a +
>0185e8	60 93					.word BinaryOp_Subtract    & $FFFF ; $8b -
>0185ea	71 93					.word BinaryOp_Multiply    & $FFFF ; $8c *
>0185ec	82 93					.word BinaryOp_Divide      & $FFFF ; $8d /
>0185ee	90 86					.word NotImplemented       & $FFFF ; $8e ^
>0185f0	bc 8b					.word Command_IF           & $FFFF ; $8f if
>0185f2	0e 90					.word Command_WHILE        & $FFFF ; $90 while
>0185f4	36 90					.word Command_REPEAT       & $FFFF ; $91 repeat
>0185f6	89 89					.word Command_FOR          & $FFFF ; $92 for
>0185f8	90 86					.word NotImplemented       & $FFFF ; $93 then
>0185fa	19 8c					.word Command_ENDIF        & $FFFF ; $94 endif
>0185fc	2b 90					.word Command_WEND         & $FFFF ; $95 wend
>0185fe	3f 90					.word Command_UNTIL        & $FFFF ; $96 until
>018600	06 8a					.word Command_NEXT         & $FFFF ; $97 next
>018602	90 86					.word NotImplemented       & $FFFF ; $98 not
>018604	90 86					.word NotImplemented       & $FFFF ; $99 fn(
>018606	87 94					.word Unary_Abs            & $FFFF ; $9a abs(
>018608	d4 95					.word Unary_Asc            & $FFFF ; $9b asc(
>01860a	e6 a4					.word Unary_Int            & $FFFF ; $9c int(
>01860c	a1 94					.word Unary_Peek           & $FFFF ; $9d peek(
>01860e	67 a4					.word Unary_Rnd            & $FFFF ; $9e rnd(
>018610	14 95					.word Unary_Usr            & $FFFF ; $9f usr(
>018612	13 96					.word Unary_Left           & $FFFF ; $a0 left$(
>018614	28 96					.word Unary_Right          & $FFFF ; $a1 right$(
>018616	fa 95					.word Unary_Mid            & $FFFF ; $a2 mid$(
>018618	71 97					.word Unary_Spc            & $FFFF ; $a3 spc(
>01861a	a2 95					.word Unary_Str            & $FFFF ; $a4 str$(
>01861c	36 95					.word Unary_Val            & $FFFF ; $a5 val(
>01861e	eb 95					.word Unary_Len            & $FFFF ; $a6 len(
>018620	a0 96					.word Unary_Hex            & $FFFF ; $a7 hex$(
>018622	90 86					.word NotImplemented       & $FFFF ; $a8 sin(
>018624	90 86					.word NotImplemented       & $FFFF ; $a9 cos(
>018626	90 86					.word NotImplemented       & $FFFF ; $aa tan(
>018628	90 86					.word NotImplemented       & $FFFF ; $ab atn(
>01862a	90 86					.word NotImplemented       & $FFFF ; $ac exp(
>01862c	90 86					.word NotImplemented       & $FFFF ; $ad log(
>01862e	90 86					.word NotImplemented       & $FFFF ; $ae sqr(
>018630	f6 96					.word Unary_Dec            & $FFFF ; $af dec(
>018632	a5 94					.word Unary_Deek           & $FFFF ; $b0 deek(
>018634	a9 94					.word Unary_Leek           & $FFFF ; $b1 leek(
>018636	e1 94					.word Unary_Mod            & $FFFF ; $b2 mod(
>018638	41 94					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>01863a	53 97					.word Unary_Chr            & $FFFF ; $b4 chr$(
>01863c	d5 94					.word Unary_Pos            & $FFFF ; $b5 pos(
>01863e	94 97					.word Unary_Tab            & $FFFF ; $b6 tab(
>018640	90 86					.word NotImplemented       & $FFFF ; $b7 $
>018642	90 86					.word NotImplemented       & $FFFF ; $b8 $(
>018644	90 86					.word NotImplemented       & $FFFF ; $b9 #
>018646	90 86					.word NotImplemented       & $FFFF ; $ba #(
>018648	90 86					.word NotImplemented       & $FFFF ; $bb %
>01864a	90 86					.word NotImplemented       & $FFFF ; $bc %(
>01864c	90 86					.word NotImplemented       & $FFFF ; $bd (
>01864e	90 86					.word NotImplemented       & $FFFF ; $be )
>018650	90 86					.word NotImplemented       & $FFFF ; $bf ,
>018652	88 89					.word Command_COLON        & $FFFF ; $c0 :
>018654	90 86					.word NotImplemented       & $FFFF ; $c1 ;
>018656	90 86					.word NotImplemented       & $FFFF ; $c2 def
>018658	ef 8f					.word Command_CLR          & $FFFF ; $c3 clr
>01865a	06 90					.word Command_STOP         & $FFFF ; $c4 stop
>01865c	df 8a					.word Command_DATA         & $FFFF ; $c5 data
>01865e	b9 8a					.word Command_READ         & $FFFF ; $c6 read
>018660	34 88					.word Command_DIM          & $FFFF ; $c7 dim
>018662	90 86					.word NotImplemented       & $FFFF ; $c8 to
>018664	90 86					.word NotImplemented       & $FFFF ; $c9 step
>018666	35 8f					.word Command_GOSUB        & $FFFF ; $ca gosub
>018668	45 8f					.word Command_RETURN       & $FFFF ; $cb return
>01866a	2d 8f					.word Command_GOTO         & $FFFF ; $cc goto
>01866c	b8 8b					.word Command_END          & $FFFF ; $cd end
>01866e	90 86					.word NotImplemented       & $FFFF ; $ce input
>018670	7d 8b					.word Command_LET          & $FFFF ; $cf let
>018672	1f 8c					.word Command_LIST         & $FFFF ; $d0 list
>018674	d6 8e					.word Command_NEW          & $FFFF ; $d1 new
>018676	f2 8e					.word Command_OLD          & $FFFF ; $d2 old
>018678	4e 8f					.word Command_ON           & $FFFF ; $d3 on
>01867a	e2 8a					.word Command_RESTORE      & $FFFF ; $d4 restore
>01867c	a5 8e					.word Command_POKE         & $FFFF ; $d5 poke
>01867e	13 8e					.word Command_PRINT        & $FFFF ; $d6 print
>018680	fa 88					.word Command_RUN          & $FFFF ; $d7 run
>018682	bc 88					.word Command_WAIT         & $FFFF ; $d8 wait
>018684	9e 8b					.word Command_SYS          & $FFFF ; $d9 sys
>018686	a9 8e					.word Command_DOKE         & $FFFF ; $da doke
>018688	ad 8e					.word Command_LOKE         & $FFFF ; $db loke
>01868a	8d 8e					.word Command_ASSERT       & $FFFF ; $dc assert
>01868c	90 86					.word NotImplemented       & $FFFF ; $dd get
>01868e	13 8c					.word Command_ELSE         & $FFFF ; $de else
.018690					NotImplemented:
.018690	20 6e 85	jsr $01856e			jsr ERR_Handler
>018693	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>01869b	65 6d 65 6e 74 65 64 00
.0186a3					BinaryPrecedence:
>0186a3	01					.byte 1    ; $80 and
>0186a4	01					.byte 1    ; $81 or
>0186a5	01					.byte 1    ; $82 xor
>0186a6	01					.byte 1    ; $83 eor
>0186a7	02					.byte 2    ; $84 =
>0186a8	02					.byte 2    ; $85 <>
>0186a9	02					.byte 2    ; $86 <
>0186aa	02					.byte 2    ; $87 <=
>0186ab	02					.byte 2    ; $88 >
>0186ac	02					.byte 2    ; $89 >=
>0186ad	03					.byte 3    ; $8a +
>0186ae	03					.byte 3    ; $8b -
>0186af	04					.byte 4    ; $8c *
>0186b0	04					.byte 4    ; $8d /
>0186b1	05					.byte 5    ; $8e ^
.0186b2					KeywordText:
>0186b2	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>0186b5	4f d2					.byte $4f,$d2                          ; $81 or
>0186b7	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>0186ba	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>0186bd	bd					.byte $bd                              ; $84 =
>0186be	3c be					.byte $3c,$be                          ; $85 <>
>0186c0	bc					.byte $bc                              ; $86 <
>0186c1	3c bd					.byte $3c,$bd                          ; $87 <=
>0186c3	be					.byte $be                              ; $88 >
>0186c4	3e bd					.byte $3e,$bd                          ; $89 >=
>0186c6	ab					.byte $ab                              ; $8a +
>0186c7	ad					.byte $ad                              ; $8b -
>0186c8	aa					.byte $aa                              ; $8c *
>0186c9	af					.byte $af                              ; $8d /
>0186ca	de					.byte $de                              ; $8e ^
>0186cb	49 c6					.byte $49,$c6                          ; $8f if
>0186cd	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>0186d2	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>0186d8	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>0186db	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>0186df	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>0186e4	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>0186e8	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>0186ed	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>0186f1	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>0186f4	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>0186f7	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>0186fb	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>0186ff	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>018703	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>018708	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>01870c	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>018710	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>018716	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>01871d	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>018722	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>018726	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>01872b	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>01872f	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>018733	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>018738	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>01873c	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>018740	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>018744	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>018748	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>01874c	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>018750	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>018754	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>018758	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>01875d	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>018762	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>018766	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>01876a	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>01876f	50 4f 53 a8				.byte $50,$4f,$53,$a8                  ; $b5 pos(
>018773	54 41 42 a8				.byte $54,$41,$42,$a8                  ; $b6 tab(
>018777	a4					.byte $a4                              ; $b7 $
>018778	24 a8					.byte $24,$a8                          ; $b8 $(
>01877a	a3					.byte $a3                              ; $b9 #
>01877b	23 a8					.byte $23,$a8                          ; $ba #(
>01877d	a5					.byte $a5                              ; $bb %
>01877e	25 a8					.byte $25,$a8                          ; $bc %(
>018780	a8					.byte $a8                              ; $bd (
>018781	a9					.byte $a9                              ; $be )
>018782	ac					.byte $ac                              ; $bf ,
>018783	ba					.byte $ba                              ; $c0 :
>018784	bb					.byte $bb                              ; $c1 ;
>018785	44 45 c6				.byte $44,$45,$c6                      ; $c2 def
>018788	43 4c d2				.byte $43,$4c,$d2                      ; $c3 clr
>01878b	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $c4 stop
>01878f	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c5 data
>018793	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c6 read
>018797	44 49 cd				.byte $44,$49,$cd                      ; $c7 dim
>01879a	54 cf					.byte $54,$cf                          ; $c8 to
>01879c	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c9 step
>0187a0	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $ca gosub
>0187a5	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $cb return
>0187ab	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $cc goto
>0187af	45 4e c4				.byte $45,$4e,$c4                      ; $cd end
>0187b2	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $ce input
>0187b7	4c 45 d4				.byte $4c,$45,$d4                      ; $cf let
>0187ba	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $d0 list
>0187be	4e 45 d7				.byte $4e,$45,$d7                      ; $d1 new
>0187c1	4f 4c c4				.byte $4f,$4c,$c4                      ; $d2 old
>0187c4	4f ce					.byte $4f,$ce                          ; $d3 on
>0187c6	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d4 restore
>0187cd	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d5 poke
>0187d1	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d6 print
>0187d6	52 55 ce				.byte $52,$55,$ce                      ; $d7 run
>0187d9	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d8 wait
>0187dd	53 59 d3				.byte $53,$59,$d3                      ; $d9 sys
>0187e0	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $da doke
>0187e4	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $db loke
>0187e8	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $dc assert
>0187ee	47 45 d4				.byte $47,$45,$d4                      ; $dd get
>0187f1	45 4c 53 c5				.byte $45,$4c,$53,$c5                  ; $de else
>0187f5	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_pos = $b5
=$b6					token_tab = $b6
=$b7					token_dollar = $b7
=$b8					token_dollarlparen = $b8
=$b9					token_hash = $b9
=$ba					token_hashlparen = $ba
=$bb					token_percent = $bb
=$bc					token_percentlparen = $bc
=$bd					token_lparen = $bd
=$be					token_rparen = $be
=$bf					token_comma = $bf
=$c0					token_colon = $c0
=$c1					token_semicolon = $c1
=$c2					token_def = $c2
=$c3					token_clr = $c3
=$c4					token_stop = $c4
=$c5					token_data = $c5
=$c6					token_read = $c6
=$c7					token_dim = $c7
=$c8					token_to = $c8
=$c9					token_step = $c9
=$ca					token_gosub = $ca
=$cb					token_return = $cb
=$cc					token_goto = $cc
=$cd					token_end = $cd
=$ce					token_input = $ce
=$cf					token_let = $cf
=$d0					token_list = $d0
=$d1					token_new = $d1
=$d2					token_old = $d2
=$d3					token_on = $d3
=$d4					token_restore = $d4
=$d5					token_poke = $d5
=$d6					token_print = $d6
=$d7					token_run = $d7
=$d8					token_wait = $d8
=$d9					token_sys = $d9
=$da					token_doke = $da
=$db					token_loke = $db
=$dc					token_assert = $dc
=$dd					token_get = $dd
=$de					token_else = $de

;******  Return to file: modules/basic/core.asm

.0187f6					BASIC_Start:
.0187f6	20 9b 81	jsr $01819b			jsr 	IF_Reset 					; set up and clear screen.
.0187f9	20 00 80	jsr $018000			jsr 	IFT_ClearScreen
.0187fc	a9 5c		lda #$5c			lda 	#$5C 						; JMP Long opcode
.0187fe	8d 10 03	sta $0310			sta 	LocalVector
.018801	8d 0c 03	sta $030c			sta 	UserVector
.018804	a9 24		lda #$24			lda 	#USRDefault & $FF 			; reset USR vector
.018806	8d 0d 03	sta $030d			sta 	UserVector+1
.018809	a9 95		lda #$95			lda 	#(USRDefault >> 8) & $FF
.01880b	8d 0e 03	sta $030e			sta 	UserVector+2
.01880e	a9 01		lda #$01			lda 	#(USRDefault >> 16) & $FF
.018810	8d 0f 03	sta $030f			sta 	UserVector+3
.018813	20 db 97	jsr $0197db			jsr 	UpdateProgramEnd 			; update the program end.
.018816	20 ef 8f	jsr $018fef			jsr 	ResetRunStatus 				; clear everything (CLR command)
.018819	c2 30		rep #$30			rep 	#$30
.01881b	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.01881e	1b		tcs				tcs
.01881f	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.018822	e2 30		sep #$30			sep 	#$30
.018824	4c fa 88	jmp $0188fa			jmp 	COMMAND_Run
.018827					WarmStart:
.018827	c2 30		rep #$30			rep 	#$30
.018829	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.01882c	1b		tcs				tcs
.01882d	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.018830	e2 30		sep #$30			sep 	#$30
.018832	80 f3		bra $018827			bra 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/dim.asm

.018834					Command_DIM:
.018834	98		tya				tya
.018835	48		pha				pha 								; push on stack.
.018836	20 43 99	jsr $019943			jsr 	VariableExtract 			; get the identifier
.018839	ad 95 03	lda $0395			lda 	Var_Type 					; check it is an array
.01883c	29 01		and #$01			and 	#1
.01883e	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.018840	d0 6c		bne $0188ae			bne 	_CDIError
.018842	a9 00		lda #$00			lda 	#0 							; reset the DIM index. The dimensions are
.018844	8d b9 03	sta $03b9			sta 	UsrArrayIdx 				; built up here and copied in case we autodim
.018847					_CDIGetDimension:
.018847	ad b9 03	lda $03b9			lda 	UsrArrayIdx 				; done too many ?
.01884a	c9 06		cmp #$06			cmp 	#ArrayMaxDim*2
.01884c	f0 60		beq $0188ae			beq 	_CDIError
.01884e	20 f3 91	jsr $0191f3			jsr 	EvaluateInteger 			; evaluate an index size
.018851	a5 81		lda $81				lda 	XS_Mantissa+1 				; check in range 0-7FFF
.018853	29 80		and #$80			and 	#$80
.018855	05 82		ora $82				ora 	XS_Mantissa+2
.018857	05 83		ora $83				ora 	XS_Mantissa+3
.018859	d0 53		bne $0188ae			bne 	_CDIError
.01885b	ae b9 03	ldx $03b9			ldx 	UsrArrayIdx 				; copy into the array table.
.01885e	18		clc				clc 								; add 1 - max index => size.
.01885f	a5 80		lda $80				lda 	XS_Mantissa+0
.018861	69 01		adc #$01			adc 	#1
.018863	9d b1 03	sta $03b1,x			sta 	UsrArrayDef+0,x
.018866	a5 81		lda $81				lda 	XS_Mantissa+1
.018868	69 00		adc #$00			adc 	#0
.01886a	9d b2 03	sta $03b2,x			sta 	UsrArrayDef+1,x
.01886d	30 3f		bmi $0188ae			bmi 	_CDIError 					; could be dim a(32767)
.01886f	e8		inx				inx 								; bump index.
.018870	e8		inx				inx
.018871	8e b9 03	stx $03b9			stx 	UsrArrayIdx
.018874	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018876	c8		iny				iny
.018877	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another dimension
.018879	f0 cc		beq $018847			beq 	_CDIGetDimension
.01887b	88		dey				dey
.01887c	20 37 98	jsr $019837			jsr 	CheckNextRParen 			; closing ) present ?
.01887f	ae b9 03	ldx $03b9			ldx 	UsrArrayIdx 				; copy USR array to default
.018882	a9 ff		lda #$ff			lda 	#$FF 						; put end marker in ArrayDef
.018884	9d aa 03	sta $03aa,x			sta 	ArrayDef+1,x
.018887					_CDICopy:
.018887	bd b1 03	lda $03b1,x			lda 	UsrArrayDef,x
.01888a	9d a9 03	sta $03a9,x			sta 	ArrayDef,x
.01888d	ca		dex				dex
.01888e	10 f7		bpl $018887			bpl 	_CDICopy
.018890	68		pla				pla									; position of array identifier
.018891	85 10		sta $10				sta 	zTemp1
.018893	98		tya				tya
.018894	48		pha				pha
.018895	a5 10		lda $10				lda 	zTemp1 						; point to identifier
.018897	a8		tay				tay
.018898	20 43 99	jsr $019943			jsr 	VariableExtract 			; get the identifier
.01889b	20 dc 9b	jsr $019bdc			jsr 	VariableLocate 				; check if it exists already.
.01889e	b0 0e		bcs $0188ae			bcs 	_CDIError
.0188a0	20 cf 99	jsr $0199cf			jsr 	VariableCreate 				; create it using the current ArrayDef
.0188a3	68		pla				pla 								; restore code position
.0188a4	a8		tay				tay
.0188a5	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0188a7	c8		iny				iny
.0188a8	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another DIM
.0188aa	f0 88		beq $018834			beq 	Command_DIM
.0188ac	88		dey				dey
.0188ad	60		rts				rts
.0188ae					_CDIError:
.0188ae	20 6e 85	jsr $01856e			jsr ERR_Handler
>0188b1	42 61 64 20 44 49 4d 00			.text "Bad DIM",0
.0188b9					_CDISyntax:
.0188b9	4c 3f 85	jmp $01853f			jmp 	SyntaxError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/wait.asm

.0188bc					Command_WAIT:
.0188bc	20 f3 91	jsr $0191f3			jsr		EvaluateInteger 			; address
.0188bf	a2 06		ldx #$06			ldx 	#XS_Size 					; and mask.
.0188c1	20 3f 98	jsr $01983f			jsr 	CheckNextComma
.0188c4	20 f5 91	jsr $0191f5			jsr 	EvaluateIntegerX
.0188c7	a9 00		lda #$00			lda 	#0							; set default xor.
.0188c9	85 8c		sta $8c				sta 	XS_Mantissa+XS_Size*2
.0188cb	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0188cd	c9 bf		cmp #$bf			cmp 	#token_Comma 				; no use the default
.0188cf	d0 06		bne $0188d7			bne 	_CWAXorDefault
.0188d1	c8		iny				iny
.0188d2	a2 0c		ldx #$0c			ldx 	#XS_Size*2
.0188d4	20 f5 91	jsr $0191f5			jsr 	EvaluateIntegerX
.0188d7					_CWAXorDefault:
.0188d7	a5 80		lda $80				lda 	XS_Mantissa 				; copy 24 bits of mantissa to ZLTemp1
.0188d9	85 1a		sta $1a				sta 	zLTemp1
.0188db	a5 81		lda $81				lda 	XS_Mantissa+1
.0188dd	85 1b		sta $1b				sta 	zLTemp1+1
.0188df	a5 82		lda $82				lda 	XS_Mantissa+2
.0188e1	85 1c		sta $1c				sta 	zLTemp1+2
.0188e3					_CWAWaitLoop:
.0188e3	20 38 85	jsr $018538			jsr 	CheckBreak 					; exit on break.
.0188e6	c9 00		cmp #$00			cmp 	#0
.0188e8	d0 0f		bne $0188f9			bne 	_CWAWaitExit
.0188ea	a9 01		lda #$01			lda 	#1							; read 1 byte to mantissa/0
.0188ec	a2 00		ldx #$00			ldx 	#0
.0188ee	5a		phy				phy 								; this is the same routine as PEEK.
.0188ef	20 b9 97	jsr $0197b9			jsr 	MemRead
.0188f2	7a		ply				ply
.0188f3	25 86		and $86				and 	XS_Mantissa+XS_Size 		; process it
.0188f5	45 8c		eor $8c				eor 	XS_Mantissa+XS_Size*2
.0188f7	f0 ea		beq $0188e3			beq 	_CWAWaitLoop
.0188f9					_CWAWaitExit:
.0188f9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/run.asm

.0188fa					Command_RUN:
.0188fa	20 ef 8f	jsr $018fef			jsr 	ResetRunStatus 				; clear, reset stacks etc.
.0188fd	a9 00		lda #$00			lda 	#BasicProgram & $FF
.0188ff	85 16		sta $16				sta 	zCodePtr+0
.018901	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018903	85 17		sta $17				sta 	zCodePtr+1
.018905	a9 00		lda #$00			lda 	#0
.018907	85 18		sta $18				sta 	zCodePtr+2
.018909	85 19		sta $19				sta 	zCodePtr+3
.01890b	a0 03		ldy #$03			ldy 	#3
.01890d					RUN_NewLine:
.01890d	a0 00		ldy #$00			ldy 	#0
.01890f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018911	c8		iny				iny
.018912	c8		iny				iny
.018913	c8		iny				iny
.018914	c9 00		cmp #$00			cmp 	#0 							; if the offset is zero then END.
.018916	d0 16		bne $01892e			bne 	RUN_NextCommand
.018918	4c b8 8b	jmp $018bb8			jmp 	Command_END 				; go do the command code.
.01891b					RUN_Skip:
.01891b	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.01891d	c8		iny				iny 								; skip
.01891e	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018920	90 0c		bcc $01892e			bcc 	_SEDone 					; so just skip over it.
.018922	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018924	90 07		bcc $01892d			bcc 	_SEDouble
.018926	98		tya				tya 								; this is Y + 1
.018927	18		clc				clc
.018928	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.01892a	a8		tay				tay 								; back in Y.
.01892b	88		dey				dey 								; fix up, one for the +1, one for the iny
.01892c	88		dey				dey
.01892d					_SEDouble:
.01892d	c8		iny				iny
.01892e					_SEDone:
.01892e					RUN_NextCommand:
.01892e	ad a8 03	lda $03a8			lda 	BreakCount 					; break counter
.018931	69 10		adc #$10			adc 	#16 						; one time in 16
.018933	8d a8 03	sta $03a8			sta 	BreakCount
.018936	90 0a		bcc $018942			bcc 	RUN_NoCheckBreak
.018938	20 38 85	jsr $018538			jsr 	CheckBreak 					; check for break
.01893b	c9 00		cmp #$00			cmp 	#0
.01893d	f0 03		beq $018942			beq 	RUN_NoCheckBreak
.01893f	4c 06 90	jmp $019006			jmp 	Command_STOP 				; stop on BREAK.
.018942					RUN_NoCheckBreak:
.018942	a9 00		lda #$00			lda 	#0 							; this resets temporary string allocation.
.018944	85 21		sta $21				sta 	zTempStr+1 					; (initialised when first called)
.018946	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018948	c9 c0		cmp #$c0			cmp 	#token_Colon 				; skip over colons
.01894a	f0 cf		beq $01891b			beq 	RUN_Skip
.01894c	c9 00		cmp #$00			cmp 	#0 							; if non-zero execute whatever
.01894e	d0 0f		bne $01895f			bne 	RUN_Execute
.018950					RUN_NextLine:
.018950	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018952	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.018954	18		clc				clc
.018955	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018957	85 16		sta $16				sta 	zCodePtr
.018959	90 02		bcc $01895d			bcc 	_SNLNoCarry
.01895b	e6 17		inc $17				inc 	zCodePtr+1
.01895d					_SNLNoCarry:
.01895d	80 ae		bra $01890d			bra 	RUN_NewLine 				; go do the new line code
.01895f					RUN_Execute:
.01895f	c9 f8		cmp #$f8			cmp 	#$F8 						; handle shifts, REM etc.
.018961	b0 1e		bcs $018981			bcs 	RUN_Extension
.018963	c8		iny				iny
.018964	0a		asl a				asl 	a 							; double the character read.
.018965	90 14		bcc $01897b			bcc 	RUN_Default 				; if carry clear was $00-$7F, so try LET.
.018967	aa		tax				tax 								; ready to look up.
.018968	bf d2 85 01	lda $0185d2,x			lda 	VectorTable,x 				; copy address into LocalVector
.01896c	8d 11 03	sta $0311			sta 	LocalVector+1
.01896f	bf d3 85 01	lda $0185d3,x			lda 	VectorTable+1,x
.018973	8d 12 03	sta $0312			sta 	LocalVector+2
.018976	20 40 91	jsr $019140			jsr 	EVCallLocalVector 			; execute the appropriate code.
.018979	80 b3		bra $01892e			bra 	RUN_NextCommand 			; do the next command.
.01897b					RUN_Default:
.01897b	88		dey				dey
.01897c	20 7d 8b	jsr $018b7d			jsr 	Command_LET 				; and try LET.
.01897f	80 ad		bra $01892e			bra 	RUN_NextCommand
.018981					RUN_Extension:
.018981	c9 ff		cmp #$ff			cmp 	#$FF 						; if $FF (REM)
.018983	f0 96		beq $01891b			beq 	RUN_Skip 					; skip over it.
.018985	4c 3f 85	jmp $01853f			jmp 	SyntaxError
.018988					Command_COLON:
.018988	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/for.asm

.018989					Command_FOR:
.018989	20 7d 8b	jsr $018b7d			jsr 	Command_LET 				; do the A = 99 bit
.01898c	a5 24		lda $24				lda 	zVarType 					; obviously has to be integer/real.
.01898e	c9 b7		cmp #$b7			cmp 	#token_Dollar
.018990	f0 71		beq $018a03			beq 	_CFOError
.018992	48		pha				pha 								; save the variable type.
.018993	5a		phy				phy 								; save type/variable address.
.018994	a0 01		ldy #$01			ldy 	#1							; type at + 1
.018996	91 26		sta ($26),y			sta 	(zBasicSP),y
.018998	c8		iny				iny
.018999	a5 22		lda $22				lda 	zVarDataPtr 				; data low at +2
.01899b	91 26		sta ($26),y			sta 	(zBasicSP),y
.01899d	c8		iny				iny
.01899e	a5 23		lda $23				lda 	zVarDataPtr+1 				; data high at +3
.0189a0	91 26		sta ($26),y			sta 	(zBasicSP),y
.0189a2	7a		ply				ply
.0189a3	a9 53		lda #$53			lda 	#(SMark_For << 4) + 3
.0189a5	20 b2 84	jsr $0184b2			jsr 	StackPushFrame 				; push on the stack with FOR marker.
.0189a8	a9 c8		lda #$c8			lda 	#token_TO
.0189aa	20 20 98	jsr $019820			jsr 	CheckNextToken
.0189ad	a2 00		ldx #$00			ldx 	#0 							; put in Mantissa, bottom
.0189af	20 5d 90	jsr $01905d			jsr 	EvaluateExpression
.0189b2	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0189b4	a2 06		ldx #$06			ldx 	#XS_Size 					; X to second level
.0189b6	c9 c9		cmp #$c9			cmp 	#token_STEP
.0189b8	d0 06		bne $0189c0			bne 	_CFOStep1
.0189ba	c8		iny				iny
.0189bb	20 5f 90	jsr $01905f			jsr 	EvaluateExpressionX 		; get STEP value.
.0189be	80 0e		bra $0189ce			bra 	_CFOHaveStep
.0189c0					_CFOStep1:
.0189c0	a9 00		lda #$00			lda 	#0							; set step to integer 1.
.0189c2	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0189c4	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0189c6	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0189c8	a9 01		lda #$01			lda 	#1
.0189ca	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0189cc	95 85		sta $85,x			sta 	XS_Type,x
.0189ce					_CFOHaveStep:
.0189ce	68		pla				pla 								; restore variable type
.0189cf	a2 00		ldx #$00			ldx 	#0
.0189d1	c9 bb		cmp #$bb			cmp 	#token_Percent 				; do conversion to type
.0189d3	f0 0a		beq $0189df			beq 	_CFOInteger
.0189d5	20 e7 a1	jsr $01a1e7			jsr 	FPUToFloat
.0189d8	a2 06		ldx #$06			ldx 	#6
.0189da	20 e7 a1	jsr $01a1e7			jsr 	FPUToFloat
.0189dd	80 08		bra $0189e7			bra 	_CFOEndConv
.0189df					_CFOInteger:
.0189df	20 33 a2	jsr $01a233			jsr 	FPUToInteger
.0189e2	a2 06		ldx #$06			ldx 	#6
.0189e4	20 33 a2	jsr $01a233			jsr 	FPUToInteger
.0189e7					_CFOEndConv:
.0189e7	20 f9 84	jsr $0184f9			jsr 	StackSavePosition 			; save the loop position at 1-5
.0189ea	a9 55		lda #$55			lda 	#(SMark_For << 4)+SourcePosSize
.0189ec	20 b2 84	jsr $0184b2			jsr 	StackPushFrame 				; push the loop address frame.
.0189ef	5a		phy				phy
.0189f0	a0 00		ldy #$00			ldy 	#0
.0189f2					_CFOCopy:
.0189f2	b9 80 00	lda $0080,y			lda 	XS_Mantissa+0,y
.0189f5	c8		iny				iny
.0189f6	91 26		sta ($26),y			sta 	(zBasicSP),y
.0189f8	c0 0c		cpy #$0c			cpy 	#XS_Size*2
.0189fa	d0 f6		bne $0189f2			bne 	_CFOCopy
.0189fc	7a		ply				ply
.0189fd	a9 5c		lda #$5c			lda 	#(SMark_For << 4)+(XS_Size*2)
.0189ff	20 b2 84	jsr $0184b2			jsr 	StackPushFrame
.018a02	60		rts				rts
.018a03					_CFOError:
.018a03	4c 4f 85	jmp $01854f			jmp 	TypeError 					; wrong type.
.018a06					Command_NEXT:
.018a06	a9 00		lda #$00			lda 	#0 							; set variable data pointer+1 to zero
.018a08	85 23		sta $23				sta 	zVarDataPtr+1 				; this means we don't check
.018a0a	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018a0c	c9 00		cmp #$00			cmp 	#0 							; EOL
.018a0e	f0 07		beq $018a17			beq 	_CNextNoVariable
.018a10	c9 40		cmp #$40			cmp 	#$40
.018a12	b0 03		bcs $018a17			bcs 	_CNextNoVariable
.018a14	20 d8 98	jsr $0198d8			jsr 	VariableFind
.018a17					_CNextNoVariable:
.018a17	a5 26		lda $26				lda 	zBasicSP 					; save on stack
.018a19	48		pha				pha
.018a1a	a5 27		lda $27				lda 	zBasicSP+1
.018a1c	48		pha				pha
.018a1d	a9 50		lda #$50			lda 	#(SMark_For << 4) 			; pop loop address frame
.018a1f	20 c9 84	jsr $0184c9			jsr 	StackPopFrame
.018a22	a9 50		lda #$50			lda 	#(SMark_For << 4) 			; pop STEP/TARGET frame.
.018a24	20 c9 84	jsr $0184c9			jsr 	StackPopFrame
.018a27	a9 50		lda #$50			lda 	#(Smark_For << 4) 			; pop variable address frame.
.018a29	20 c9 84	jsr $0184c9			jsr 	StackPopFrame
.018a2c	a5 23		lda $23				lda 	zVarDataPtr+1 				; if zero, then no variable provided
.018a2e	f0 11		beq $018a41			beq 	_CNextGetTarget 			; e.g. just NEXT not NEXT x
.018a30	5a		phy				phy 								; check addresses match.
.018a31	a0 02		ldy #$02			ldy 	#2
.018a33	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a35	c5 22		cmp $22				cmp 	zVarDataPtr
.018a37	d0 69		bne $018aa2			bne 	_CNextWrong
.018a39	c8		iny				iny
.018a3a	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a3c	c5 23		cmp $23				cmp 	zVarDataPtr+1
.018a3e	d0 62		bne $018aa2			bne 	_CNextWrong
.018a40	7a		ply				ply
.018a41					_CNextGetTarget:
.018a41	5a		phy				phy
.018a42	a0 01		ldy #$01			ldy 	#1 							; restore variable type and data.
.018a44	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a46	85 24		sta $24				sta 	zVarType
.018a48	c8		iny				iny
.018a49	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a4b	85 22		sta $22				sta 	zVarDataPtr
.018a4d	c8		iny				iny
.018a4e	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a50	85 23		sta $23				sta 	zVarDataPtr+1
.018a52	a2 0c		ldx #$0c			ldx 	#12
.018a54	20 20 9c	jsr $019c20			jsr 	VariableGet 				; get that variable value into expr[2]
.018a57	a2 00		ldx #$00			ldx 	#0 							; copy stacked Target/Step into expr[0] and [1]
.018a59	a0 0b		ldy #$0b			ldy 	#11
.018a5b					_CNXCopy:
.018a5b	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a5d	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018a5f	e8		inx				inx
.018a60	c8		iny				iny
.018a61	e0 0c		cpx #$0c			cpx 	#XS_Size*2
.018a63	d0 f6		bne $018a5b			bne 	_CNXCopy
.018a65	7a		ply				ply
.018a66	a2 06		ldx #$06			ldx 	#6 							; point at expr[1] s
.018a68	20 65 94	jsr $019465			jsr 	GetSignCurrent
.018a6b	8d a7 03	sta $03a7			sta 	SignNext 					; save in temporary.
.018a6e	a2 06		ldx #$06			ldx 	#6 							; add them, however
.018a70	20 44 93	jsr $019344			jsr 	BinaryOp_Add
.018a73	20 71 9c	jsr $019c71			jsr 	VariableSet					; and write variable back.
.018a76	a2 00		ldx #$00			ldx 	#0
.018a78	20 c8 92	jsr $0192c8			jsr 	CompareValues
.018a7b	09 00		ora #$00			ora 	#0
.018a7d	f0 05		beq $018a84			beq 	_CNXAgain 					; if true, then do it again.
.018a7f	cd a7 03	cmp $03a7			cmp 	SignNext 					; if sign different, then loop has finished.
.018a82	d0 0f		bne $018a93			bne 	_CNXLoopDone
.018a84					_CNXAgain:
.018a84	a9 53		lda #$53			lda 	#(SMark_For << 4) + 3		; re-stack variable address
.018a86	20 b2 84	jsr $0184b2			jsr 	StackPushFrame
.018a89	20 16 85	jsr $018516			jsr 	StackRestorePosition 		; get restore position back, e.g. loop round.
.018a8c	68		pla				pla
.018a8d	85 27		sta $27				sta 	zBasicSP+1
.018a8f	68		pla				pla
.018a90	85 26		sta $26				sta 	zBasicSP
.018a92					_CNXExit:
.018a92	60		rts				rts
.018a93					_CNXLoopDone:
.018a93	68		pla				pla
.018a94	68		pla				pla
.018a95	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018a97	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma ?
.018a99	d0 f7		bne $018a92			bne 	_CNXExit
.018a9b	c8		iny				iny
.018a9c	20 d8 98	jsr $0198d8			jsr 	VariableFind 				; identify the variable
.018a9f	4c 17 8a	jmp $018a17			jmp 	_CNextNoVariable 			; go back with variable pre-found
.018aa2					_CNextWrong:
.018aa2	20 6e 85	jsr $01856e			jsr ERR_Handler
>018aa5	57 72 6f 6e 67 20 4e 65			.text "Wrong Next Variable",0
>018aad	78 74 20 56 61 72 69 61 62 6c 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/read.asm

.018ab9					Command_READ:
.018ab9	20 d8 98	jsr $0198d8			jsr 	VariableFind 				; get variable/value into zVarDataPtr,zVarType
.018abc	a5 22		lda $22				lda 	zVarDataPtr 				; save variable info on stack
.018abe	48		pha				pha
.018abf	a5 23		lda $23				lda 	zVarDataPtr+1
.018ac1	48		pha				pha
.018ac2	a5 24		lda $24				lda 	zVarType
.018ac4	48		pha				pha
.018ac5	20 0b 8b	jsr $018b0b			jsr 	READGetDataItem 			; get the next data item
.018ac8	68		pla				pla 								; restore target variable information.
.018ac9	85 24		sta $24				sta 	zVarType
.018acb	68		pla				pla
.018acc	85 23		sta $23				sta 	zVarDataPtr+1
.018ace	68		pla				pla
.018acf	85 22		sta $22				sta 	zVarDataPtr
.018ad1	a2 00		ldx #$00			ldx 	#0
.018ad3	20 71 9c	jsr $019c71			jsr 	VariableSet 				; set the value out.
.018ad6	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018ad8	c8		iny				iny
.018ad9	c9 bf		cmp #$bf			cmp 	#token_Comma
.018adb	f0 dc		beq $018ab9			beq 	Command_READ 				; found, do another READ
.018add	88		dey				dey
.018ade	60		rts				rts
.018adf					Command_DATA:
.018adf	4c 80 84	jmp $018480			jmp 	SkipEndOfCommand
.018ae2					Command_RESTORE:
.018ae2	48		pha				pha
.018ae3	a9 00		lda #$00			lda 	#0 							; this being zero means 'initialise next read'
.018ae5	8d bd 03	sta $03bd			sta 	DataLPtr+0
.018ae8	8d be 03	sta $03be			sta 	DataLPtr+1
.018aeb	68		pla				pla
.018aec	60		rts				rts
.018aed					READSwapPointers:
.018aed	98		tya				tya
.018aee	48		pha				pha 								; save it
.018aef	ad c1 03	lda $03c1			lda 	DataIndex 					; get data offset, and copy to offset
.018af2	a8		tay				tay
.018af3	68		pla				pla 								; get code offset and save in DataIndex
.018af4	8d c1 03	sta $03c1			sta 	DataIndex
.018af7	da		phx				phx
.018af8	a2 03		ldx #$03			ldx 	#3 							; swap the Data Pointers (4 bytes) round.
.018afa					_RSWLoop:
.018afa	bd bd 03	lda $03bd,x			lda 	DataLPtr+0,x
.018afd	48		pha				pha
.018afe	b5 16		lda $16,x			lda 	zCodePtr+0,x
.018b00	9d bd 03	sta $03bd,x			sta 	DataLPtr+0,x
.018b03	68		pla				pla
.018b04	95 16		sta $16,x			sta 	zCodePtr+0,x
.018b06	ca		dex				dex
.018b07	10 f1		bpl $018afa			bpl 	_RSWLoop
.018b09	fa		plx				plx
.018b0a	60		rts				rts
.018b0b					READGetDataItem:
.018b0b	20 ed 8a	jsr $018aed			jsr 	ReadSwapPointers 			; swap code and data pointer.
.018b0e	a5 16		lda $16				lda		zCodePtr+0 					; initialise ?
.018b10	05 17		ora $17				ora 	zCodePtr+1
.018b12	d0 12		bne $018b26			bne 	_RGDIIsInitialised
.018b14	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018b16	85 16		sta $16				sta 	zCodePtr+0
.018b18	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018b1a	85 17		sta $17				sta 	zCodePtr+1
.018b1c	a9 00		lda #$00			lda 	#0
.018b1e	85 18		sta $18				sta 	zCodePtr+2
.018b20	85 19		sta $19				sta 	zCodePtr+3
.018b22	a0 03		ldy #$03			ldy 	#3
.018b24	80 06		bra $018b2c			bra 	_RGDIFindData 				; locate next data from start and read that.
.018b26					_RGDIIsInitialised:
.018b26	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018b28	c9 bf		cmp #$bf			cmp 	#token_Comma
.018b2a	f0 49		beq $018b75			beq 	_RGDISkipEvaluateExit
.018b2c					_RGDIFindData:
.018b2c	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018b2e	c9 00		cmp #$00			cmp 	#0 							; end of line
.018b30	f0 19		beq $018b4b			beq 	_RGDIFindNextLine
.018b32	c9 c5		cmp #$c5			cmp 	#token_DATA 				; found data token
.018b34	f0 3f		beq $018b75			beq 	_RGDISkipEvaluateExit 		; then skip it and evaluate
.018b36	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018b38	c8		iny				iny 								; skip
.018b39	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018b3b	90 0c		bcc $018b49			bcc 	_SEDone 					; so just skip over it.
.018b3d	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018b3f	90 07		bcc $018b48			bcc 	_SEDouble
.018b41	98		tya				tya 								; this is Y + 1
.018b42	18		clc				clc
.018b43	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018b45	a8		tay				tay 								; back in Y.
.018b46	88		dey				dey 								; fix up, one for the +1, one for the iny
.018b47	88		dey				dey
.018b48					_SEDouble:
.018b48	c8		iny				iny
.018b49					_SEDone:
.018b49	80 e1		bra $018b2c			bra 	_RGDIFindData
.018b4b					_RGDIFindNextLine:
.018b4b	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018b4d	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.018b4f	18		clc				clc
.018b50	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018b52	85 16		sta $16				sta 	zCodePtr
.018b54	90 02		bcc $018b58			bcc 	_SNLNoCarry
.018b56	e6 17		inc $17				inc 	zCodePtr+1
.018b58					_SNLNoCarry:
.018b58	a0 00		ldy #$00			ldy 	#0
.018b5a	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018b5c	48		pha				pha
.018b5d	c8		iny				iny
.018b5e	c8		iny				iny
.018b5f	c8		iny				iny
.018b60	68		pla				pla
.018b61	d0 c9		bne $018b2c			bne 	_RGDIFindData 				; back to scanning.
.018b63	20 ed 8a	jsr $018aed			jsr 	ReadSwapPointers 			; so we get error in line number of READ
.018b66	20 6e 85	jsr $01856e			jsr ERR_Handler
>018b69	4f 75 74 20 6f 66 20 44			.text "Out of Data",0
>018b71	61 74 61 00
.018b75					_RGDISkipEvaluateExit:
.018b75	c8		iny				iny
.018b76	20 5d 90	jsr $01905d			jsr 	EvaluateExpression 			; evaluate the expression
.018b79	20 ed 8a	jsr $018aed			jsr 	ReadSwapPointers 			; swap the pointers around.
.018b7c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/let.asm

.018b7d					Command_LET:
.018b7d	20 d8 98	jsr $0198d8			jsr 	VariableFind 				; get reference to one variable.
.018b80	a9 84		lda #$84			lda 	#token_Equal  				; get equals
.018b82	20 20 98	jsr $019820			jsr 	CheckNextToken
.018b85	a5 22		lda $22				lda 	zVarDataPtr 				; save variable info on stack
.018b87	48		pha				pha
.018b88	a5 23		lda $23				lda 	zVarDataPtr+1
.018b8a	48		pha				pha
.018b8b	a5 24		lda $24				lda 	zVarType
.018b8d	48		pha				pha
.018b8e	20 5d 90	jsr $01905d			jsr 	EvaluateExpression 			; evaluate the RHS, set X to zero.
.018b91	68		pla				pla 								; restore target variable information.
.018b92	85 24		sta $24				sta 	zVarType
.018b94	68		pla				pla
.018b95	85 23		sta $23				sta 	zVarDataPtr+1
.018b97	68		pla				pla
.018b98	85 22		sta $22				sta 	zVarDataPtr
.018b9a	20 71 9c	jsr $019c71			jsr 	VariableSet 				; set the value out.
.018b9d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/sys.asm

.018b9e					Command_SYS:
.018b9e	20 f3 91	jsr $0191f3			jsr 	EvaluateInteger 			; address
.018ba1	a5 80		lda $80				lda 	XS_Mantissa+0				; copy to localvector
.018ba3	8d 10 03	sta $0310			sta 	LocalVector+0 				; only three, can only do 24 bit calls
.018ba6	a5 81		lda $81				lda 	XS_Mantissa+1 				; and that only on 65816
.018ba8	8d 11 03	sta $0311			sta 	LocalVector+1
.018bab	a5 82		lda $82				lda 	XS_Mantissa+2
.018bad	8d 12 03	sta $0312			sta 	LocalVector+2
.018bb0	22 b5 8b 01	jsl $018bb5			jsl 	_CSYLocalCall
.018bb4	60		rts				rts
.018bb5					_CSYLocalCall:
.018bb5	dc 10 03	jmp [$0310]			jmp 	[LocalVector]

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/end.asm

.018bb8					Command_END:
>018bb8	02						.byte 	2
.018bb9	4c 27 88	jmp $018827			jmp 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/if.asm

.018bbc					Command_IF:
.018bbc	20 f3 91	jsr $0191f3			jsr 	EvaluateInteger 			; check success.
.018bbf	a5 80		lda $80				lda 	XS_Mantissa+0				; check the result if zero
.018bc1	05 81		ora $81				ora 	XS_Mantissa+1
.018bc3	05 82		ora $82				ora 	XS_Mantissa+2
.018bc5	05 83		ora $83				ora 	XS_Mantissa+3
.018bc7	aa		tax				tax 								; put into X.
.018bc8	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018bca	c9 93		cmp #$93			cmp 	#token_Then 				; then found.
.018bcc	d0 2c		bne $018bfa			bne 	_FIFExtended
.018bce	c8		iny				iny
.018bcf	e0 00		cpx #$00			cpx 	#0 							; was it successful.
.018bd1	f0 0b		beq $018bde			beq 	_FIFEndOfLine 				; if not, go to the end of the line.
.018bd3	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018bd5	29 c0		and #$c0			and 	#$C0 						; is it a number
.018bd7	c9 40		cmp #$40			cmp 	#$40
.018bd9	d0 1e		bne $018bf9			bne 	_FIFContinue 				; if not, do what ever follows.
.018bdb	4c 2d 8f	jmp $018f2d			jmp		Command_GOTO 				; we have IF <expr> THEN <number> so we do GOTO code.
.018bde					_FIFEndOfLine:
.018bde	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018be0	c9 00		cmp #$00			cmp 	#0 							; if zero, end of line, so exit
.018be2	f0 15		beq $018bf9			beq 	_FIFContinue
.018be4	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018be6	c8		iny				iny 								; skip
.018be7	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018be9	90 0c		bcc $018bf7			bcc 	_SEDone 					; so just skip over it.
.018beb	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018bed	90 07		bcc $018bf6			bcc 	_SEDouble
.018bef	98		tya				tya 								; this is Y + 1
.018bf0	18		clc				clc
.018bf1	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018bf3	a8		tay				tay 								; back in Y.
.018bf4	88		dey				dey 								; fix up, one for the +1, one for the iny
.018bf5	88		dey				dey
.018bf6					_SEDouble:
.018bf6	c8		iny				iny
.018bf7					_SEDone:
.018bf7	80 e5		bra $018bde			bra 	_FIFEndOfLine
.018bf9					_FIFContinue:
.018bf9	60		rts				rts
.018bfa					_FIFExtended:
.018bfa	da		phx				phx 								; save result
.018bfb	a9 40		lda #$40			lda 	#(SMark_If << 4) 			; push marker on the stack, nothing else.
.018bfd	20 b2 84	jsr $0184b2			jsr 	StackPushFrame
.018c00	68		pla				pla 								; restore result
.018c01	f0 01		beq $018c04			beq 	_FIXSkip 					; if zero then it has failed.
.018c03	60		rts				rts 								; test passed, so continue executing
.018c04					_FIXSkip:
.018c04	a9 94		lda #$94			lda 	#token_endif 				; scan forward till found either ELSE or ENDIF
.018c06	a2 de		ldx #$de			ldx 	#token_else 				; at the same level.
.018c08	20 f5 83	jsr $0183f5			jsr 	StructureSearchDouble
.018c0b	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c0d	c8		iny				iny
.018c0e	c9 94		cmp #$94			cmp 	#token_endif 				; if endif, handle endif code.
.018c10	f0 07		beq $018c19			beq 	Command_ENDIF
.018c12	60		rts				rts
.018c13					Command_ELSE:
.018c13	a9 94		lda #$94			lda 	#token_endif 				; scan forward till found ENDIF
.018c15	20 f3 83	jsr $0183f3			jsr 	StructureSearchSingle 		; then do the ENDIF pop.
.018c18	c8		iny				iny
.018c19					Command_ENDIF:
.018c19	a9 40		lda #$40			lda 	#(SMark_If << 4)
.018c1b	20 c9 84	jsr $0184c9			jsr 	StackPopFrame
.018c1e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/list.asm

.018c1f					Command_LIST:
.018c1f	20 ac 8d	jsr $018dac			jsr 	ListGetRange				; get any parameters
.018c22	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018c24	85 16		sta $16				sta 	zCodePtr+0
.018c26	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018c28	85 17		sta $17				sta 	zCodePtr+1
.018c2a	a9 00		lda #$00			lda 	#0
.018c2c	85 18		sta $18				sta 	zCodePtr+2
.018c2e	85 19		sta $19				sta 	zCodePtr+3
.018c30	a0 03		ldy #$03			ldy 	#3
.018c32	a9 00		lda #$00			lda 	#0 							; reset the indent & last indent
.018c34	8d bc 03	sta $03bc			sta 	LastListIndent
.018c37	8d bb 03	sta $03bb			sta 	ListIndent
.018c3a					_CILLoop:
.018c3a	a0 00		ldy #$00			ldy 	#0
.018c3c	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c3e	c9 00		cmp #$00			cmp 	#0 							; if zero, end of program
.018c40	f0 23		beq $018c65			beq 	_CILExit
.018c42	20 38 85	jsr $018538			jsr 	CheckBreak 					; check break
.018c45	c9 00		cmp #$00			cmp 	#0
.018c47	d0 1c		bne $018c65			bne 	_CILExit
.018c49	20 f3 8d	jsr $018df3			jsr 	ListCheckRange 				; check current line in range.
.018c4c	b0 08		bcs $018c56			bcs		_CILNext
.018c4e	a0 00		ldy #$00			ldy 	#0
.018c50	c8		iny				iny
.018c51	c8		iny				iny
.018c52	c8		iny				iny
.018c53	20 68 8c	jsr $018c68			jsr 	ListLine 					; list one line.
.018c56					_CILNext:
.018c56	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018c58	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.018c5a	18		clc				clc
.018c5b	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018c5d	85 16		sta $16				sta 	zCodePtr
.018c5f	90 02		bcc $018c63			bcc 	_SNLNoCarry
.018c61	e6 17		inc $17				inc 	zCodePtr+1
.018c63					_SNLNoCarry:
.018c63	80 d5		bra $018c3a			bra 	_CILLoop
.018c65					_CILExit:
.018c65	4c 27 88	jmp $018827			jmp 	WarmStart
.018c68					ListLine:
.018c68	ad bb 03	lda $03bb			lda 	ListIndent 					; copy current list indent -> last
.018c6b	8d bc 03	sta $03bc			sta 	LastListIndent
.018c6e					_LICountIndent:
.018c6e	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c70	c9 00		cmp #$00			cmp 	#0
.018c72	f0 2f		beq $018ca3			beq 	_LIDoneIndent
.018c74	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus
.018c76	90 16		bcc $018c8e			bcc 	_LICINext
.018c78	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.018c7a	b0 12		bcs $018c8e			bcs 	_LICINext
.018c7c	ee bb 03	inc $03bb			inc 	ListIndent
.018c7f	c9 93		cmp #$93			cmp 	#firstKeywordMinus
.018c81	90 0b		bcc $018c8e			bcc 	_LICINext
.018c83	ce bb 03	dec $03bb			dec 	ListIndent
.018c86	ce bb 03	dec $03bb			dec 	ListIndent
.018c89	10 03		bpl $018c8e			bpl 	_LICINext
.018c8b	ee bb 03	inc $03bb			inc 	ListIndent
.018c8e					_LICINext:
.018c8e	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018c90	c8		iny				iny 								; skip
.018c91	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018c93	90 0c		bcc $018ca1			bcc 	_SEDone 					; so just skip over it.
.018c95	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018c97	90 07		bcc $018ca0			bcc 	_SEDouble
.018c99	98		tya				tya 								; this is Y + 1
.018c9a	18		clc				clc
.018c9b	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018c9d	a8		tay				tay 								; back in Y.
.018c9e	88		dey				dey 								; fix up, one for the +1, one for the iny
.018c9f	88		dey				dey
.018ca0					_SEDouble:
.018ca0	c8		iny				iny
.018ca1					_SEDone:
.018ca1	80 cb		bra $018c6e			bra 	_LICountIndent
.018ca3					_LIDoneIndent:
.018ca3	a0 00		ldy #$00			ldy 	#0
.018ca5	c8		iny				iny
.018ca6	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018ca8	85 80		sta $80				sta 	XS_Mantissa
.018caa	c8		iny				iny
.018cab	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018cad	85 81		sta $81				sta 	XS_Mantissa+1
.018caf	20 b4 85	jsr $0185b4			jsr 	Print16BitInteger 			; print integer.
.018cb2	85 10		sta $10				sta 	zTemp1 						; save spaces printed.
.018cb4	ad bb 03	lda $03bb			lda 	ListIndent 					; smaller of current/prev indent
.018cb7	cd bc 03	cmp $03bc			cmp 	LastListIndent
.018cba	90 03		bcc $018cbf			bcc 	_LISmaller
.018cbc	ad bc 03	lda $03bc			lda 	LastListIndent
.018cbf					_LISmaller:
.018cbf	0a		asl a				asl 	a 							; double indent
.018cc0	49 ff		eor #$ff			eor 	#$FF 						; 2's complement arithmetic
.018cc2	38		sec				sec
.018cc3	65 10		adc $10				adc 	zTemp1 						; "subtract" indent e.g. print more.
.018cc5	aa		tax				tax 								; print spaces to column 6
.018cc6					_LISpace:
.018cc6	a9 20		lda #$20			lda 	#" "
.018cc8	20 9c 8d	jsr $018d9c			jsr 	ListPrintLC
.018ccb	e8		inx				inx
.018ccc	e0 06		cpx #$06			cpx 	#6
.018cce	d0 f6		bne $018cc6			bne 	_LISpace
.018cd0					_LIDecode:
.018cd0	c8		iny				iny
.018cd1	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018cd3	c9 00		cmp #$00			cmp 	#0 							; zero, exit.
.018cd5	f0 0f		beq $018ce6			beq 	_LIExit
.018cd7	30 12		bmi $018ceb			bmi 	_LIToken
.018cd9	c9 40		cmp #$40			cmp 	#$40 						; 01-$3F, character.
.018cdb	b0 50		bcs $018d2d			bcs 	_LIInteger
.018cdd	49 20		eor #$20			eor 	#$20 						; make 7 bit
.018cdf	69 20		adc #$20			adc 	#$20
.018ce1	20 9c 8d	jsr $018d9c			jsr 	ListPrintLC 				; print in LC
.018ce4	80 ea		bra $018cd0			bra 	_LIDecode
.018ce6					_LIExit:
.018ce6	a9 0d		lda #$0d			lda 	#13 						; print new line.
.018ce8	4c 9c 8d	jmp $018d9c			jmp 	ListPrintLC
.018ceb					_LIToken:
.018ceb	c9 fc		cmp #$fc			cmp 	#$FC 						; $FC-$FF ?
.018ced	90 49		bcc $018d38			bcc		_LICommandToken
.018cef	48		pha				pha 								; save in case end
.018cf0	a2 22		ldx #$22			ldx 	#'"'						; print if $FE quoted string
.018cf2	c9 fe		cmp #$fe			cmp 	#$FE
.018cf4	f0 17		beq $018d0d			beq 	_LIPrint
.018cf6	a2 2e		ldx #$2e			ldx 	#'.'						; print if $FD decimals
.018cf8	c9 fd		cmp #$fd			cmp 	#$FD
.018cfa	f0 11		beq $018d0d			beq 	_LIPrint
.018cfc	a9 52		lda #$52			lda 	#'R'						; must be REM
.018cfe	20 9c 8d	jsr $018d9c			jsr 	ListPrintLC
.018d01	a9 45		lda #$45			lda 	#'E'
.018d03	20 9c 8d	jsr $018d9c			jsr 	ListPrintLC
.018d06	a9 4d		lda #$4d			lda 	#'M'
.018d08	20 9c 8d	jsr $018d9c			jsr 	ListPrintLC
.018d0b	a2 20		ldx #$20			ldx 	#' '
.018d0d					_LIPrint:
.018d0d	8a		txa				txa
.018d0e	20 9c 8d	jsr $018d9c			jsr 	ListPrintLC
.018d11	c8		iny				iny
.018d12	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018d14	aa		tax				tax 								; put in X
.018d15	ca		dex				dex
.018d16					_LILoop:
.018d16	ca		dex				dex 								; exit when count reached zero.
.018d17	f0 08		beq $018d21			beq 	_LIEnd
.018d19	c8		iny				iny
.018d1a	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018d1c	20 9c 8d	jsr $018d9c			jsr 	ListPrintLC
.018d1f	80 f5		bra $018d16			bra 	_LILoop
.018d21	68		pla		_LIEnd:	pla 								; get A back
.018d22	c9 fe		cmp #$fe			cmp 	#$FE 						; if '"' need closing quotes
.018d24	d0 aa		bne $018cd0			bne 	_LIDecode
.018d26	a9 22		lda #$22			lda 	#'"'
.018d28	20 9c 8d	jsr $018d9c			jsr 	ListPrintLC
.018d2b	80 a3		bra $018cd0			bra 	_LIDecode
.018d2d					_LIInteger:
.018d2d	a2 00		ldx #$00			ldx 	#0
.018d2f	20 65 91	jsr $019165			jsr 	EvaluateGetInteger 			; get an atom
.018d32	88		dey				dey
.018d33	20 ba 85	jsr $0185ba			jsr 	Print32BitInteger 			; print integer.
.018d36	80 98		bra $018cd0			bra 	_LIDecode
.018d38					_LICommandToken:
.018d38	5a		phy				phy 								; save Y
.018d39	48		pha				pha 								; save token
.018d3a	a2 b2		ldx #$b2			ldx  	#KeywordText & $FF 			; address of keyword text table.
.018d3c	a9 86		lda #$86			lda 	(#KeywordText >> 8) & $FF
.018d3e	86 1a		stx $1a				stx 	zLTemp1
.018d40	85 1b		sta $1b				sta 	zLTemp1+1
.018d42	a9 01		lda #$01			lda 	(#KeywordText >> 16) & $FF 	; this is for 65816 (it's a table in code
.018d44	85 1c		sta $1c				sta 	zLTemp1+2 					; space) and won't affect a 6502 at all.
.018d46	68		pla				pla 								; get token
.018d47	29 7f		and #$7f			and 	#127 						; chuck bit 7.
.018d49	f0 16		beq $018d61			beq 	_LIFoundToken
.018d4b	aa		tax				tax
.018d4c					_LITokenLoop:
.018d4c	a0 00		ldy #$00			ldy 	#0 							; last character not a token.
.018d4e					_LIFindEnd:
.018d4e	b7 1a		lda [$1a],y			lda 	[zLTemp1],y
.018d50	c8		iny				iny
.018d51	0a		asl a				asl 	a
.018d52	90 fa		bcc $018d4e			bcc 	_LIFindEnd
.018d54	98		tya				tya 								; that is step to the next
.018d55	18		clc				clc 								; we don't bother bumping the 3rd byte
.018d56	65 1a		adc $1a				adc 	zLTemp1 					; here.
.018d58	85 1a		sta $1a				sta 	zLTemp1
.018d5a	90 02		bcc $018d5e			bcc 	_LINoBump
.018d5c	e6 1b		inc $1b				inc 	zLTemp1+1
.018d5e					_LINoBump:
.018d5e	ca		dex				dex 								; no go round again.
.018d5f	d0 eb		bne $018d4c			bne 	_LITokenLoop
.018d61					_LIFoundToken:
.018d61	a0 00		ldy #$00			ldy 	#0
.018d63					_LIPrintToken:
.018d63	b7 1a		lda [$1a],y			lda 	[zLTemp1],y
.018d65	c0 00		cpy #$00			cpy 	#0 							; see if needs prefix space
.018d67	d0 16		bne $018d7f			bne 	_LINoPrefixSpace
.018d69	c9 41		cmp #$41			cmp 	#"A" 						; e.g. alphabetic token.
.018d6b	90 12		bcc $018d7f			bcc 	_LINoPrefixSpace
.018d6d	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018d6f	b0 0e		bcs $018d7f			bcs 	_LINoPrefixSpace
.018d71	ae ba 03	ldx $03ba			ldx 	LastPrinted 				; if last was space not required
.018d74	e0 20		cpx #$20			cpx 	#" "
.018d76	f0 07		beq $018d7f			beq 	_LINoPrefixSpace
.018d78	48		pha				pha
.018d79	a9 20		lda #$20			lda 	#" "
.018d7b	20 9c 8d	jsr $018d9c			jsr 	ListPrintLC
.018d7e	68		pla				pla
.018d7f					_LINoPrefixSpace:
.018d7f	c8		iny				iny
.018d80	48		pha				pha 								; save it
.018d81	29 7f		and #$7f			and 	#$7F
.018d83	20 9c 8d	jsr $018d9c			jsr 	ListPrintLC
.018d86	68		pla				pla
.018d87	10 da		bpl $018d63			bpl 	_LIPrintToken 				; go back if not end
.018d89	7a		ply				ply 								; restore Y
.018d8a	29 7f		and #$7f			and 	#$7F 						; if last char is a letter
.018d8c	c9 41		cmp #$41			cmp 	#"A"
.018d8e	90 09		bcc $018d99			bcc 	_LINotLetter2
.018d90	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018d92	b0 05		bcs $018d99			bcs 	_LINotLetter2
.018d94	a9 20		lda #$20			lda 	#" " 						; add spacing
.018d96	20 9c 8d	jsr $018d9c			jsr 	ListPrintLC
.018d99					_LINotLetter2:
.018d99	4c d0 8c	jmp $018cd0			jmp 	_LIDecode
.018d9c					ListPrintLC:
.018d9c	8d ba 03	sta $03ba			sta 	LastPrinted
.018d9f	c9 41		cmp #$41			cmp 	#"A"
.018da1	90 06		bcc $018da9			bcc 	_LPLC0
.018da3	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018da5	b0 02		bcs $018da9			bcs 	_LPLC0
.018da7	69 20		adc #$20			adc 	#$20
.018da9	4c 32 85	jmp $018532	_LPLC0:	jmp 	CharPrint
.018dac					ListGetRange:
.018dac	a2 0b		ldx #$0b			ldx 	#XS_Size*2-1 				; clear first 2 slots back to defaults.
.018dae					_LGRClear:
.018dae	a9 00		lda #$00			lda 	#0
.018db0	95 80		sta $80,x			sta 	XS_Mantissa,x
.018db2	ca		dex				dex
.018db3	10 f9		bpl $018dae			bpl 	_LGRClear
.018db5	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018db7	c9 00		cmp #$00			cmp 	#0 							; nothing
.018db9	f0 21		beq $018ddc			beq 	_LGRBlank
.018dbb	c9 c0		cmp #$c0			cmp 	#token_Colon 				; or colon
.018dbd	f0 1d		beq $018ddc			beq 	_LGRBlank
.018dbf	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma
.018dc1	f0 18		beq $018ddb			beq 	_LGREnd 					; then it's LIST ,x
.018dc3	20 f3 91	jsr $0191f3			jsr 	EvaluateInteger 			; get the first number into bottom
.018dc6	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018dc8	c9 bf		cmp #$bf			cmp 	#token_Comma
.018dca	f0 0f		beq $018ddb			beq 	_LGREnd 					; then it is LIST a,b
.018dcc	a5 80		lda $80				lda 	XS_Mantissa+0 				; copy first to second LIST n is n,n
.018dce	85 86		sta $86				sta 	XS_Mantissa+XS_Size+0
.018dd0	a5 81		lda $81				lda 	XS_Mantissa+1
.018dd2	85 87		sta $87				sta 	XS_Mantissa+XS_Size+1
.018dd4					_LGRBumpExit:
.018dd4	e6 86		inc $86				inc 	XS_Mantissa+XS_Size 		; bump it so we can use cc.
.018dd6	d0 02		bne $018dda			bne 	_LGRBump2
.018dd8	e6 87		inc $87				inc 	XS_Mantissa+XS_Size+1
.018dda					_LGRBump2:
.018dda	60		rts				rts
.018ddb					_LGREnd:
.018ddb	c8		iny				iny
.018ddc					_LGRBlank:
.018ddc	a9 ff		lda #$ff			lda 	#$FF 						; default to the end.
.018dde	85 86		sta $86				sta 	XS_Mantissa+XS_Size
.018de0	85 87		sta $87				sta 	XS_Mantissa+XS_Size+1
.018de2	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018de4	c9 00		cmp #$00			cmp 	#0
.018de6	f0 f2		beq $018dda			beq 	_LGRBump2
.018de8	0a		asl a				asl 	a 							; if not a number, then exit (to end)
.018de9	b0 ef		bcs $018dda			bcs 	_LGRBump2
.018deb	a2 06		ldx #$06			ldx 	#XS_Size 					; get to range
.018ded	20 f5 91	jsr $0191f5			jsr 	EvaluateIntegerX
.018df0	80 e2		bra $018dd4			bra 	_LGRBumpExit
.018df2	60		rts				rts
.018df3					ListCheckRange:
.018df3	c8		iny				iny
.018df4	a2 00		ldx #$00			ldx 	#0 							; test low
.018df6	20 03 8e	jsr $018e03			jsr 	_LCRCompare
.018df9	90 06		bcc $018e01			bcc 	_LCRFail
.018dfb	a2 06		ldx #$06			ldx 	#XS_Size 					; test high
.018dfd	20 03 8e	jsr $018e03			jsr 	_LCRCompare
.018e00	60		rts				rts
.018e01					_LCRFail:
.018e01	38		sec				sec
.018e02	60		rts				rts
.018e03					_LCRCompare:
.018e03	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e05	38		sec				sec
.018e06	f5 80		sbc $80,x			sbc	 	XS_Mantissa+0,x
.018e08	08		php				php
.018e09	c8		iny				iny
.018e0a	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e0c	28		plp				plp
.018e0d	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.018e0f	08		php				php
.018e10	88		dey				dey
.018e11	28		plp				plp
.018e12	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/print.asm

.018e13					Command_PRINT:
.018e13	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e15	c9 00		cmp #$00			cmp 	#0 							; end
.018e17	f0 70		beq $018e89			beq 	_CPR_NewLine
.018e19	c9 c0		cmp #$c0			cmp 	#token_Colon
.018e1b	f0 6c		beq $018e89			beq 	_CPR_NewLine
.018e1d	c9 c1		cmp #$c1			cmp 	#token_SemiColon
.018e1f	f0 5b		beq $018e7c			beq 	_CPR_Skip
.018e21	c9 bf		cmp #$bf			cmp 	#token_Comma
.018e23	f0 49		beq $018e6e			beq 	_CPR_Tab
.018e25	20 5d 90	jsr $01905d			jsr 	EvaluateExpression 			; get expression.
.018e28	a5 85		lda $85				lda 	XS_Type 					; get type.
.018e2a	29 02		and #$02			and 	#2
.018e2c	d0 24		bne $018e52			bne 	_CPR_String 				; if type = 2 output as string.
.018e2e					_CPR_Number:
.018e2e	a9 00		lda #$00			lda 	#0 							; reset buffer index
.018e30	8d 14 03	sta $0314			sta 	NumBufX
.018e33	a5 85		lda $85				lda 	XS_Type 					; get type
.018e35	4a		lsr a				lsr 	a
.018e36	b0 05		bcs $018e3d			bcs 	_CPRInt 					; if msb set do as integer
.018e38	20 32 a3	jsr $01a332			jsr 	FPToString 					; call fp to str otherwise
.018e3b	80 03		bra $018e40			bra 	_CPRNPrint
.018e3d	20 ba 9d	jsr $019dba	_CPRInt:jsr 	IntToString
.018e40					_CPRNPrint:
.018e40	ad 15 03	lda $0315			lda 	Num_Buffer 					; is first character -
.018e43	c9 2d		cmp #$2d			cmp 	#"-"
.018e45	f0 05		beq $018e4c			beq 	_CPRNoSpace
.018e47	a9 20		lda #$20			lda 	#" "						; print the leading space
.018e49	20 32 85	jsr $018532			jsr 	CharPrint 					; so beloved of MS Basics.
.018e4c					_CPRNoSpace:
.018e4c	a2 14		ldx #$14			ldx 	#(Num_Buffer-1) & $FF
.018e4e	a9 03		lda #$03			lda 	#(Num_Buffer-1) >> 8
.018e50	80 04		bra $018e56			bra 	_CPRPrint
.018e52					_CPR_String:
.018e52	a6 80		ldx $80				ldx 	XS_Mantissa
.018e54	a5 81		lda $81				lda 	XS_Mantissa+1
.018e56					_CPRPrint:
.018e56	86 1e		stx $1e				stx 	zGenPtr
.018e58	85 1f		sta $1f				sta 	zGenPtr+1
.018e5a	5a		phy				phy
.018e5b	a0 00		ldy #$00			ldy 	#0							; get length into X
.018e5d	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018e5f	aa		tax				tax
.018e60	f0 09		beq $018e6b			beq 	_CPREndPrint 				; nothing to print
.018e62					_CPRLoop:
.018e62	c8		iny				iny
.018e63	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018e65	20 32 85	jsr $018532			jsr 	CharPrint
.018e68	ca		dex				dex
.018e69	d0 f7		bne $018e62			bne 	_CPRLoop
.018e6b					_CPREndPrint:
.018e6b	7a		ply				ply
.018e6c	80 a5		bra $018e13			bra 	Command_Print
.018e6e					_CPR_Tab:
.018e6e	20 3b 85	jsr $01853b			jsr 	CharGetPosition 			; print until position % 8 = 0
.018e71	29 07		and #$07			and 	#7
.018e73	f0 07		beq $018e7c			beq 	_CPR_Skip
.018e75	a9 20		lda #$20			lda 	#" "
.018e77	20 32 85	jsr $018532			jsr 	CharPrint
.018e7a	80 f2		bra $018e6e			bra 	_CPR_Tab
.018e7c					_CPR_Skip:
.018e7c	c8		iny				iny
.018e7d	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e7f	c9 c0		cmp #$c0			cmp 	#token_Colon 				; colon or $00, exit
.018e81	f0 09		beq $018e8c			beq 	_CPR_Exit
.018e83	c9 00		cmp #$00			cmp 	#0
.018e85	d0 8c		bne $018e13			bne 	Command_PRINT 				; if not go round again.
.018e87	80 03		bra $018e8c			bra 	_CPR_Exit
.018e89					_CPR_NewLine:
.018e89	20 4f 80	jsr $01804f			jsr 	IFT_NewLine
.018e8c					_CPR_Exit:
.018e8c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/assert.asm

.018e8d					Command_ASSERT:
.018e8d	20 f3 91	jsr $0191f3			jsr 	EvaluateInteger 			; calculate thing being asserted
.018e90	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; check if true (non-zero)
.018e92	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.018e94	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.018e96	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.018e98	f0 01		beq $018e9b			beq 	_ASFail
.018e9a	60		rts				rts
.018e9b					_ASFail:
.018e9b	20 6e 85	jsr $01856e			jsr ERR_Handler
>018e9e	41 73 73 65 72 74 00			.text "Assert",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/poke.asm

.018ea5					Command_POKE:
.018ea5	a9 01		lda #$01			lda 	#1
.018ea7	80 06		bra $018eaf			bra 	CmdPoke_Main
.018ea9					Command_DOKE:
.018ea9	a9 02		lda #$02			lda 	#2
.018eab	80 02		bra $018eaf			bra 	CmdPoke_Main
.018ead					Command_LOKE:
.018ead	a9 04		lda #$04			lda 	#4
.018eaf					CmdPoke_Main:
.018eaf	48		pha				pha
.018eb0	20 f3 91	jsr $0191f3			jsr 	EvaluateInteger 			; get two parameters.
.018eb3	e8		inx				inx
.018eb4	e8		inx				inx
.018eb5	e8		inx				inx
.018eb6	e8		inx				inx
.018eb7	e8		inx				inx
.018eb8	e8		inx				inx
.018eb9	20 3f 98	jsr $01983f			jsr 	CheckNextComma
.018ebc	20 f5 91	jsr $0191f5			jsr 	EvaluateIntegerX
.018ebf	a5 80		lda $80				lda 	XS_Mantissa+0 			; copy the mantissa into ZLTemp1 (address)
.018ec1	85 1a		sta $1a				sta 	zLTemp1
.018ec3	a5 81		lda $81				lda 	XS_Mantissa+1
.018ec5	85 1b		sta $1b				sta 	zLTemp1+1
.018ec7	a5 82		lda $82				lda 	XS_Mantissa+2
.018ec9	85 1c		sta $1c				sta 	zLTemp1+2
.018ecb	a5 83		lda $83				lda 	XS_Mantissa+3
.018ecd	85 1d		sta $1d				sta 	zLTemp1+3
.018ecf	68		pla				pla 								; get count
.018ed0	5a		phy				phy 								; save Y
.018ed1	20 ca 97	jsr $0197ca			jsr 	MemWrite 					; write it out
.018ed4	7a		ply				ply 								; restore Y and done.
.018ed5	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/newold.asm

.018ed6					Command_NEW:
.018ed6	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018ed8	85 16		sta $16				sta 	zCodePtr+0
.018eda	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018edc	85 17		sta $17				sta 	zCodePtr+1
.018ede	a9 00		lda #$00			lda 	#0
.018ee0	85 18		sta $18				sta 	zCodePtr+2
.018ee2	85 19		sta $19				sta 	zCodePtr+3
.018ee4	a0 03		ldy #$03			ldy 	#3
.018ee6	a0 00		ldy #$00			ldy 	#0
.018ee8	a9 00		lda #$00			lda 	#0 							; write a 0 there.
.018eea	97 16		sta [$16],y			sta 	[zCodePtr],y
.018eec	20 db 97	jsr $0197db			jsr 	UpdateProgramEnd 			; update program end.
.018eef	4c 27 88	jmp $018827			jmp 	WarmStart
.018ef2					Command_OLD:
.018ef2	ea		nop				nop
.018ef3	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018ef5	85 16		sta $16				sta 	zCodePtr+0
.018ef7	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018ef9	85 17		sta $17				sta 	zCodePtr+1
.018efb	a9 00		lda #$00			lda 	#0
.018efd	85 18		sta $18				sta 	zCodePtr+2
.018eff	85 19		sta $19				sta 	zCodePtr+3
.018f01	a0 03		ldy #$03			ldy 	#3
.018f03					_COL_Find:
.018f03	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018f05	c8		iny				iny
.018f06	c9 00		cmp #$00			cmp 	#0 							; if zero, then the position Y/Z is new offset
.018f08	f0 18		beq $018f22			beq 	_COL_Found
.018f0a	98		tya				tya
.018f0b	c9 00		cmp #$00			cmp 	#0
.018f0d	d0 f4		bne $018f03			bne 	_COL_Find 					; can't find old EOL, give up.
.018f0f	20 6e 85	jsr $01856e			jsr ERR_Handler
>018f12	50 72 6f 67 72 61 6d 20			.text "Program Corrupt",0
>018f1a	43 6f 72 72 75 70 74 00
.018f22					_COL_Found:
.018f22	98		tya				tya
.018f23	48		pha				pha
.018f24	a0 00		ldy #$00			ldy 	#0
.018f26	68		pla				pla
.018f27	97 16		sta [$16],y			sta 	[zCodePtr],y
.018f29	20 db 97	jsr $0197db			jsr 	UpdateProgramEnd 			; reset variable pointer
.018f2c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/branch.asm

.018f2d					Command_GOTO:
.018f2d	20 82 8f	jsr $018f82			jsr 	GotoGetLineNumber
.018f30					CmdGOTO:
.018f30	a2 00		ldx #$00			ldx 	#0
.018f32	4c 9f 8f	jmp $018f9f			jmp 	GotoChangeToLineNumberX
.018f35					Command_GOSUB:
.018f35	20 82 8f	jsr $018f82			jsr 	GotoGetLineNumber
.018f38					CmdGOSUB:
.018f38	20 f9 84	jsr $0184f9			jsr 	StackSavePosition
.018f3b	a9 15		lda #$15			lda 	#(SMark_Gosub << 4)+SourcePosSize
.018f3d	20 b2 84	jsr $0184b2			jsr 	StackPushFrame
.018f40	a2 00		ldx #$00			ldx		#0
.018f42	4c 9f 8f	jmp $018f9f			jmp 	GotoChangeToLineNumberX
.018f45					Command_RETURN:
.018f45	a9 10		lda #$10			lda 	#(SMark_Gosub << 4)
.018f47	20 c9 84	jsr $0184c9			jsr 	StackPopFrame
.018f4a	20 16 85	jsr $018516			jsr 	StackRestorePosition
.018f4d	60		rts				rts
.018f4e					Command_ON:
.018f4e	a2 00		ldx #$00			ldx 	#0 							; get the ON.
.018f50	20 8f 96	jsr $01968f			jsr 	SLIByteParameter
.018f53	a5 80		lda $80				lda 	XS_Mantissa+0 				; get the count
.018f55	f0 28		beq $018f7f			beq 	_CONFail 					; can't be zero.
.018f57	aa		tax				tax 								; save in X.
.018f58	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018f5a	c8		iny				iny
.018f5b	48		pha				pha
.018f5c	c9 cc		cmp #$cc			cmp 	#token_GOTO 				; must be GOTO or GOSUB
.018f5e	f0 07		beq $018f67			beq 	_CONOkayToken
.018f60	c9 ca		cmp #$ca			cmp 	#token_GOSUB
.018f62	f0 03		beq $018f67			beq 	_CONOkayToken
.018f64	4c 3f 85	jmp $01853f			jmp 	SyntaxError
.018f67					_CONOkayToken:
.018f67	da		phx				phx 								; count on top, GOTO/GOSUB token 2nd.
.018f68					_CONFindNumber:
.018f68	20 82 8f	jsr $018f82			jsr 	GotoGetLineNumber 			; get a line number.
.018f6b	fa		plx				plx 								; restore count
.018f6c	ca		dex				dex  								; decrement, exit if zero.
.018f6d	f0 06		beq $018f75			beq 	_CONFound
.018f6f	da		phx				phx 								; push back
.018f70	20 3f 98	jsr $01983f			jsr 	CheckNextComma				; check for comma
.018f73	80 f3		bra $018f68			bra 	_CONFindNumber
.018f75					_CONFound:
.018f75	68		pla				pla 								; get token
.018f76	c9 cc		cmp #$cc			cmp 	#token_GOTO 				; if GOTO
.018f78	f0 b6		beq $018f30			beq		CmdGOTO 					; then just branch.
.018f7a	20 80 84	jsr $018480			jsr 	SkipEndOfCommand 			; go to end of command
.018f7d	80 b9		bra $018f38			bra 	CmdGOSUB 					; and do a GOSUB.
.018f7f					_CONFail:
.018f7f	4c 5d 85	jmp $01855d			jmp 	BadParamError
.018f82					GotoGetLineNumber:
.018f82	20 f3 91	jsr $0191f3			jsr 	EvaluateInteger
.018f85	a5 82		lda $82				lda 	XS_Mantissa+2 				; check range
.018f87	05 83		ora $83				ora 	XS_Mantissa+3
.018f89	d0 01		bne $018f8c			bne 	_GLINError
.018f8b	60		rts				rts
.018f8c					_GLINError:
.018f8c	20 6e 85	jsr $01856e			jsr ERR_Handler
>018f8f	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>018f97	20 4e 75 6d 62 65 72 00
.018f9f					GotoChangeToLineNumberX:
.018f9f	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check line number not zero
.018fa1	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.018fa3	f0 37		beq $018fdc			beq 	_GCTLFail
.018fa5	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018fa7	85 16		sta $16				sta 	zCodePtr+0
.018fa9	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018fab	85 17		sta $17				sta 	zCodePtr+1
.018fad	a9 00		lda #$00			lda 	#0
.018faf	85 18		sta $18				sta 	zCodePtr+2
.018fb1	85 19		sta $19				sta 	zCodePtr+3
.018fb3	a0 03		ldy #$03			ldy 	#3
.018fb5					_GCTLLoop:
.018fb5	a0 00		ldy #$00			ldy 	#0
.018fb7	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018fb9	c9 00		cmp #$00			cmp 	#0
.018fbb	f0 1f		beq $018fdc			beq 	_GCTLFail
.018fbd	c8		iny				iny
.018fbe	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018fc0	d5 80		cmp $80,x			cmp 	XS_Mantissa+0,x
.018fc2	d0 07		bne $018fcb			bne 	_GCTLNext
.018fc4	c8		iny				iny
.018fc5	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018fc7	d5 81		cmp $81,x			cmp 	XS_Mantissa+1,x
.018fc9	f0 0f		beq $018fda			beq 	_GCTLExit
.018fcb					_GCTLNext:
.018fcb	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018fcd	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.018fcf	18		clc				clc
.018fd0	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018fd2	85 16		sta $16				sta 	zCodePtr
.018fd4	90 02		bcc $018fd8			bcc 	_SNLNoCarry
.018fd6	e6 17		inc $17				inc 	zCodePtr+1
.018fd8					_SNLNoCarry:
.018fd8	80 db		bra $018fb5			bra 	_GCTLLoop 					; try next line.
.018fda					_GCTLExit:
.018fda	c8		iny				iny
.018fdb	60		rts				rts
.018fdc					_GCTLFail:
.018fdc	20 6e 85	jsr $01856e			jsr ERR_Handler
>018fdf	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>018fe7	20 4e 75 6d 62 65 72 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.018fef					Command_CLR:
.018fef					ResetRunStatus:
.018fef	20 14 99	jsr $019914			jsr 	VariableClear
.018ff2	20 a0 84	jsr $0184a0			jsr 	StackReset
.018ff5	a9 00		lda #$00			lda 	#HighMemory & $FF
.018ff7	8d 00 03	sta $0300			sta 	StringPtr
.018ffa	a9 7f		lda #$7f			lda 	#HighMemory >> 8
.018ffc	8d 01 03	sta $0301			sta 	StringPtr+1
.018fff	20 de 9a	jsr $019ade			jsr 	ArrayResetDefault
.019002	20 e2 8a	jsr $018ae2			jsr 	Command_RESTORE
.019005	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/stop.asm

.019006					Command_STOP:
.019006	20 6e 85	jsr $01856e			jsr ERR_Handler
>019009	53 74 6f 70 00				.text "Stop",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/while.asm

.01900e					Command_WHILE:
.01900e	20 f9 84	jsr $0184f9			jsr 	StackSavePosition			; save position into stack, but don't yet push.
.019011	20 f3 91	jsr $0191f3			jsr 	EvaluateInteger 			; calculate the while loop value.
.019014	a5 80		lda $80				lda 	XS_Mantissa+0				; check the result if zero
.019016	05 81		ora $81				ora 	XS_Mantissa+1
.019018	05 82		ora $82				ora 	XS_Mantissa+2
.01901a	05 83		ora $83				ora 	XS_Mantissa+3
.01901c	f0 06		beq $019024			beq 	_CWHSkip 					; if it is zero, then skip to WEND.
.01901e	a9 35		lda #$35			lda 	#(SMark_While << 4)+SourcePosSize
.019020	20 b2 84	jsr $0184b2			jsr 	StackPushFrame 				; push on stack
.019023	60		rts				rts
.019024					_CWHSkip:
.019024	a9 95		lda #$95			lda 	#token_Wend 				; look for the WEND token.
.019026	20 f3 83	jsr $0183f3			jsr 	StructureSearchSingle
.019029	c8		iny				iny
.01902a	60		rts				rts
.01902b					Command_WEND:
.01902b	a9 30		lda #$30			lda 	#(SMark_While << 4)			; remove the frame
.01902d	20 c9 84	jsr $0184c9			jsr 	StackPopFrame
.019030	20 16 85	jsr $018516			jsr 	StackRestorePosition
.019033	80 d9		bra $01900e			bra 	Command_WHILE 				; and do the while again.
.019035	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/repeat.asm

.019036					Command_REPEAT:
.019036	20 f9 84	jsr $0184f9			jsr 	StackSavePosition			; save position into stack
.019039	a9 25		lda #$25			lda 	#(SMark_Repeat << 4)+SourcePosSize
.01903b	20 b2 84	jsr $0184b2			jsr 	StackPushFrame 				; push on stack
.01903e	60		rts				rts
.01903f					Command_UNTIL:
.01903f	a9 20		lda #$20			lda 	#(SMark_Repeat << 4)		; remove the frame
.019041	20 c9 84	jsr $0184c9			jsr 	StackPopFrame
.019044	20 f3 91	jsr $0191f3			jsr 	EvaluateInteger				; work out UNTIL
.019047	a5 80		lda $80				lda 	XS_Mantissa+0 				; check if zero.
.019049	05 81		ora $81				ora 	XS_Mantissa+1
.01904b	05 82		ora $82				ora 	XS_Mantissa+2
.01904d	05 83		ora $83				ora 	XS_Mantissa+3
.01904f	d0 08		bne $019059			bne 	_CUTExit 					; if not, just exit
.019051	20 16 85	jsr $018516			jsr 	StackRestorePosition 		; otherwise loop round again.
.019054	a9 25		lda #$25			lda 	#(SMark_Repeat << 4)+SourcePosSize
.019056	20 b2 84	jsr $0184b2			jsr 	StackPushFrame 				; fix the stack back.
.019059					_CUTExit:
.019059	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.01905a					EVESyntax:
.01905a	4c 3f 85	jmp $01853f			jmp 	SyntaxError
.01905d					EvaluateExpression:
.01905d	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.01905f					EvaluateExpressionX:
.01905f	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.019061					EvaluateExpressionXA:
.019061	48		pha				pha 								; save precedence on stack.
.019062	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019064	f0 f4		beq $01905a			beq 	EVESyntax 					; end of line, syntax error.
.019066	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.019068	b0 03		bcs $01906d			bcs 	_EVNotVariable
.01906a	4c 37 91	jmp $019137			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.01906d					_EVNotVariable:
.01906d	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.01906f	90 e9		bcc $01905a			bcc 	EVESyntax
.019071	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.019073	b0 58		bcs $0190cd			bcs 	_EVNotInteger
.019075	20 65 91	jsr $019165			jsr 	EvaluateGetInteger
.019078					_EVCheckDecimal:
.019078	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01907a	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.01907c	d0 05		bne $019083			bne 	_EVGotAtom 					; no, get atom.
.01907e					_EVIsDecimal:
.01907e	20 8b 91	jsr $01918b			jsr 	EVGetDecimal 				; extend to the decimal part.
.019081	80 00		bra $019083			bra 	_EVGotAtom 					; and continue to got atom.
.019083					_EVGotAtom:
.019083	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019085	10 44		bpl $0190cb			bpl 	_EVExitDrop 				; must be a token.
.019087	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.019089	b0 40		bcs $0190cb			bcs 	_EVExitDrop
.01908b	68		pla				pla 								; get current precedence
.01908c	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.01908e	da		phx				phx 								; save X
.01908f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019091	aa		tax				tax 								; put in X
.019092	bf 23 86 01	lda $018623,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.019096	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.019098	fa		plx				plx 								; restore X
.019099	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.01909b	90 2f		bcc $0190cc			bcc 	_EVExit 					; exit if too low.
.01909d	f0 2d		beq $0190cc			beq 	_EVExit 					; exit if equals
.01909f	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.0190a1	48		pha				pha
.0190a2	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0190a4	48		pha				pha
.0190a5	c8		iny				iny
.0190a6	da		phx				phx 								; save current position
.0190a7	e8		inx				inx
.0190a8	e8		inx				inx
.0190a9	e8		inx				inx
.0190aa	e8		inx				inx
.0190ab	e8		inx				inx
.0190ac	e8		inx				inx
.0190ad	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.0190af	20 61 90	jsr $019061			jsr 	EvaluateExpressionXA 		; do the RHS.
.0190b2	fa		plx				plx 								; restore X
.0190b3	68		pla				pla 								; get the binary operator in A.
.0190b4					_EVCallA:
.0190b4	da		phx				phx 								; save X again
.0190b5	0a		asl a				asl 	a 							; double, lose the MSB.
.0190b6	aa		tax				tax									; put in X
.0190b7	bf d2 85 01	lda $0185d2,x			lda 	VectorTable,x 				; copy address into zGenPtr
.0190bb	8d 11 03	sta $0311			sta 	LocalVector+1
.0190be	bf d3 85 01	lda $0185d3,x			lda 	VectorTable+1,x
.0190c2	8d 12 03	sta $0312			sta 	LocalVector+2
.0190c5	fa		plx				plx 								; restore X
.0190c6	20 40 91	jsr $019140			jsr 	EVCallLocalVector
.0190c9	80 b8		bra $019083			bra 	_EVGotAtom 					; and loop back.
.0190cb					_EVExitDrop:
.0190cb	68		pla				pla
.0190cc					_EVExit:
.0190cc	60		rts				rts
.0190cd					_EVNotInteger:
.0190cd	c8		iny				iny
.0190ce	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.0190d0	d0 16		bne $0190e8			bne 	_EVNotMinus
.0190d2	20 d4 91	jsr $0191d4			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.0190d5	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.0190d7	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.0190d9	f0 05		beq $0190e0			beq 	_EVMinusFloat
.0190db	20 9d 9d	jsr $019d9d			jsr 	IntegerNegateAlways 		; negation
.0190de	80 a3		bra $019083			bra 	_EVGotAtom 					; and go back.
.0190e0					_EVMinusFloat:
.0190e0	b5 85		lda $85,x			lda 	XS_Type,x 					; invert the sign bit.
.0190e2	49 80		eor #$80			eor 	#$80
.0190e4	95 85		sta $85,x			sta 	XS_Type,x
.0190e6	80 9b		bra $019083			bra 	_EVGotAtom
.0190e8					_EVNotMinus:
.0190e8	c9 bd		cmp #$bd			cmp 	#token_lparen 				; is it left parenthesis
.0190ea	d0 17		bne $019103			bne 	_EVNotParenthesis
.0190ec	20 5f 90	jsr $01905f			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.0190ef	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0190f1	c8		iny				iny
.0190f2	c9 be		cmp #$be			cmp 	#token_rparen 				; okay if right bracket.
.0190f4	f0 8d		beq $019083			beq 	_EVGotAtom
.0190f6	20 6e 85	jsr $01856e			jsr ERR_Handler
>0190f9	4d 69 73 73 69 6e 67 20			.text "Missing )",0
>019101	29 00
.019103					_EVNotParenthesis:
.019103	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.019105	d0 0c		bne $019113			bne 	_EVNotNot
.019107	20 d4 91	jsr $0191d4			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.01910a	20 33 a2	jsr $01a233			jsr 	FPUToInteger 				; make it an integer - if possible.
.01910d	20 b9 91	jsr $0191b9			jsr 	NotInteger 					; do the not calculation
.019110	4c 83 90	jmp $019083			jmp 	_EVGotAtom
.019113					_EVNotNot:
.019113	c9 fe		cmp #$fe			cmp 	#$FE
.019115	d0 12		bne $019129			bne 	_EVNotString
.019117	20 b2 98	jsr $0198b2			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.01911a	a5 20		lda $20				lda 	zTempStr 					; copy address of string into mantissa
.01911c	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01911e	a5 21		lda $21				lda 	zTempStr+1
.019120	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019122	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.019124	95 85		sta $85,x			sta 	XS_Type,x
.019126	4c 83 90	jmp $019083			jmp 	_EVGotAtom
.019129					_EVNotString:
.019129	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.01912b	90 04		bcc $019131			bcc 	_EVBadElement
.01912d	c9 b7		cmp #$b7			cmp 	#lastUnaryFunction+1
.01912f	90 03		bcc $019134			bcc 	_EVUnaryFunction
.019131					_EVBadElement:
.019131	4c 3f 85	jmp $01853f			jmp 	SyntaxError
.019134					_EVUnaryFunction:
.019134	4c b4 90	jmp $0190b4			jmp 	_EVCallA
.019137					_EVVariableHandler:
.019137	20 d8 98	jsr $0198d8			jsr 	VariableFind 				; locate a variable
.01913a	20 20 9c	jsr $019c20			jsr 	VariableGet 				; copy into memory.
.01913d	4c 83 90	jmp $019083			jmp 	_EVGotAtom 					; and go round.
.019140					EVCallLocalVector:
.019140	6c 11 03	jmp ($0311)			jmp 	(LocalVector+1)
.019143					EVShiftMantissaLeft6:
.019143	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.019145	95 84		sta $84,x			sta 	XS_Exponent,x
.019147	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019149	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01914b	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01914d	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01914f	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019151	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019153	a9 00		lda #$00			lda 	#0
.019155	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019157	20 5a 91	jsr $01915a			jsr 	_EVSMLShift 					; call it here to do it twice
.01915a					_EVSMLShift:
.01915a	56 84		lsr $84,x			lsr 	XS_Exponent,x
.01915c	76 83		ror $83,x			ror 	XS_Mantissa+3,x
.01915e	76 82		ror $82,x			ror 	XS_Mantissa+2,x
.019160	76 81		ror $81,x			ror 	XS_Mantissa+1,x
.019162	76 80		ror $80,x			ror 	XS_Mantissa+0,x
.019164	60		rts				rts
.019165					EvaluateGetInteger:
.019165	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019167	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.019169	95 80		sta $80,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.01916b	a9 00		lda #$00			lda 	#0
.01916d	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01916f	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019171	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019173	1a		inc a				inc 	a 							; set to type 1 (integer)
.019174	95 85		sta $85,x			sta 	XS_Type,x
.019176					_EVCheckNextInteger:
.019176	c8		iny				iny
.019177	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019179	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.01917b	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.01917d	b0 0b		bcs $01918a			bcs 	_EVEndInteger
.01917f	48		pha				pha 								; save it.
.019180	20 43 91	jsr $019143			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.019183	68		pla				pla
.019184	15 80		ora $80,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.019186	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019188	80 ec		bra $019176			bra 	_EVCheckNextInteger
.01918a					_EVEndInteger:
.01918a	60		rts				rts
.01918b					EVGetDecimal:
.01918b	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.01918d	8d 15 03	sta $0315			sta 	Num_Buffer
.019190	da		phx				phx
.019191	c8		iny				iny
.019192	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019194	c8		iny				iny
.019195	3a		dec a				dec 	a								; convert to a string length.
.019196	3a		dec a				dec 	a
.019197	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.019199					_EVGDCopy:
.019199	48		pha				pha 									; save count
.01919a	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01919c	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.01919f	e8		inx				inx 									; forward ....
.0191a0	c8		iny				iny
.0191a1	68		pla				pla 									; get count
.0191a2	3a		dec a				dec 	a 								; until zero
.0191a3	d0 f4		bne $019199			bne 	_EVGDCopy
.0191a5	9d 15 03	sta $0315,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.0191a8	fa		plx				plx 									; restore X
.0191a9	a9 15		lda #$15			lda 	#Num_Buffer & $FF 				; set zGenPtr
.0191ab	85 1e		sta $1e				sta 	zGenPtr
.0191ad	a9 03		lda #$03			lda 	#Num_Buffer >> 8
.0191af	85 1f		sta $1f				sta 	zGenPtr+1
.0191b1	5a		phy				phy 									; save Y
.0191b2	a0 00		ldy #$00			ldy 	#0 								; start position
.0191b4	20 ed a3	jsr $01a3ed			jsr 	FPFromString 					; convert current
.0191b7	7a		ply				ply 									; restore Y
.0191b8	60		rts				rts
.0191b9					NotInteger:
.0191b9	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0191bb	49 ff		eor #$ff			eor 	#$FF
.0191bd	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0191bf	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0191c1	49 ff		eor #$ff			eor 	#$FF
.0191c3	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0191c5	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0191c7	49 ff		eor #$ff			eor 	#$FF
.0191c9	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0191cb	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.0191cd	49 ff		eor #$ff			eor 	#$FF
.0191cf	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0191d1	60		rts				rts
.0191d2					EvaluateGetAtom:
.0191d2	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.0191d4					EvaluateGetAtomX:
.0191d4	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.0191d6	20 61 90	jsr $019061			jsr 	EvaluateExpressionXA
.0191d9	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.0191db	29 0f		and #$0f			and 	#15
.0191dd	c9 02		cmp #$02			cmp 	#2
.0191df	b0 01		bcs $0191e2			bcs 	EvaluateType
.0191e1	60		rts				rts
.0191e2					EvaluateType:
.0191e2	4c 4f 85	jmp $01854f			jmp 	TypeError
.0191e5					EvaluateNumber:
.0191e5	a2 00		ldx #$00			ldx 	#0
.0191e7					EvaluateNumberX:
.0191e7	20 5f 90	jsr $01905f			jsr 	EvaluateExpressionX
.0191ea	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0/1
.0191ec	29 0f		and #$0f			and 	#15
.0191ee	c9 02		cmp #$02			cmp 	#2
.0191f0	b0 f0		bcs $0191e2			bcs 	EvaluateType
.0191f2	60		rts				rts
.0191f3					EvaluateInteger:
.0191f3	a2 00		ldx #$00			ldx 	#0
.0191f5					EvaluateIntegerX:
.0191f5	20 e7 91	jsr $0191e7			jsr 	EvaluateNumberX
.0191f8	20 33 a2	jsr $01a233			jsr 	FPUToInteger
.0191fb	60		rts				rts
.0191fc					EvaluateString:
.0191fc	a2 00		ldx #$00			ldx 	#0
.0191fe					EvaluateStringX:
.0191fe	20 5f 90	jsr $01905f			jsr 	EvaluateExpressionX
.019201	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 2
.019203	29 0f		and #$0f			and 	#15
.019205	c9 02		cmp #$02			cmp 	#2
.019207	d0 d9		bne $0191e2			bne 	EvaluateType
.019209	b5 80		lda $80,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.01920b	85 1e		sta $1e				sta 	zGenPtr
.01920d	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01920f	85 1f		sta $1f				sta 	zGenPtr+1
.019211	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.019212					BinaryOp_And:
.019212	20 66 92	jsr $019266			jsr 	BinaryMakeBothInteger
.019215	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.019217	35 86		and $86,x			and 	XS2_Mantissa+0,x
.019219	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01921b	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.01921d	35 87		and $87,x			and 	XS2_Mantissa+1,x
.01921f	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019221	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.019223	35 88		and $88,x			and 	XS2_Mantissa+2,x
.019225	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019227	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.019229	35 89		and $89,x			and 	XS2_Mantissa+3,x
.01922b	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01922d	60		rts				rts
.01922e					BinaryOp_Or:
.01922e	20 66 92	jsr $019266			jsr 	BinaryMakeBothInteger
.019231	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.019233	15 86		ora $86,x			ora 	XS2_Mantissa+0,x
.019235	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019237	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.019239	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.01923b	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01923d	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.01923f	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.019241	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019243	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.019245	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.019247	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019249	60		rts				rts
.01924a					BinaryOp_Eor:
.01924a					BinaryOp_Xor:
.01924a	20 66 92	jsr $019266			jsr 	BinaryMakeBothInteger
.01924d	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.01924f	55 86		eor $86,x			eor 	XS2_Mantissa+0,x
.019251	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019253	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.019255	55 87		eor $87,x			eor 	XS2_Mantissa+1,x
.019257	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019259	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.01925b	55 88		eor $88,x			eor 	XS2_Mantissa+2,x
.01925d	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01925f	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.019261	55 89		eor $89,x			eor 	XS2_Mantissa+3,x
.019263	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019265	60		rts				rts
.019266					BinaryMakeBothInteger:
.019266	da		phx				phx 								; save X
.019267	e8		inx				inx
.019268	e8		inx				inx
.019269	e8		inx				inx
.01926a	e8		inx				inx
.01926b	e8		inx				inx
.01926c	e8		inx				inx
.01926d	20 71 92	jsr $019271			jsr 	BinaryMakeInteger 			; convert to integer.
.019270	fa		plx				plx 								; restore X and fall through.
.019271					BinaryMakeInteger:
.019271	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.019273	29 0f		and #$0f			and 	#15 						; check type zero
.019275	f0 04		beq $01927b			beq 	_BMIConvert 				; if float convert to integer.
.019277	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.019278	90 04		bcc $01927e			bcc 	_BMIError
.01927a	60		rts				rts
.01927b					_BMIConvert:
.01927b	4c 33 a2	jmp $01a233			jmp 	FPUToInteger 				; convert to integer
.01927e					_BMIError:
.01927e	4c 4f 85	jmp $01854f			jmp 	TypeError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.019281					Binary_Equal:
.019281	20 c8 92	jsr $0192c8			jsr 	CompareValues
.019284	09 00		ora #$00			ora 	#0
.019286	f0 04		beq $01928c			beq 	CCTrue
.019288	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.01928a	80 02		bra $01928e			bra 	CCWrite
.01928c	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.01928e	95 80		sta $80,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.019290	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019292	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019294	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019296	a9 01		lda #$01			lda 	#1
.019298	95 85		sta $85,x			sta 	XS_Type,x 					; set type to integer whatever.
.01929a	60		rts				rts
.01929b					Binary_NotEqual:
.01929b	20 c8 92	jsr $0192c8			jsr 	CompareValues
.01929e	09 00		ora #$00			ora 	#0
.0192a0	f0 e6		beq $019288			beq 	CCFalse
.0192a2	80 e8		bra $01928c			bra 	CCTrue
.0192a4					Binary_Less:
.0192a4	20 c8 92	jsr $0192c8			jsr 	CompareValues
.0192a7	09 00		ora #$00			ora 	#0
.0192a9	30 e1		bmi $01928c			bmi 	CCTrue
.0192ab	80 db		bra $019288			bra 	CCFalse
.0192ad					Binary_LessEqual:
.0192ad	20 c8 92	jsr $0192c8			jsr 	CompareValues
.0192b0	c9 01		cmp #$01			cmp 	#1
.0192b2	d0 d8		bne $01928c			bne 	CCTrue
.0192b4	80 d2		bra $019288			bra 	CCFalse
.0192b6					Binary_GreaterEqual:
.0192b6	20 c8 92	jsr $0192c8			jsr 	CompareValues
.0192b9	09 00		ora #$00			ora 	#0
.0192bb	10 cf		bpl $01928c			bpl 	CCTrue
.0192bd	80 c9		bra $019288			bra 	CCFalse
.0192bf					Binary_Greater:
.0192bf	20 c8 92	jsr $0192c8			jsr 	CompareValues
.0192c2	c9 01		cmp #$01			cmp 	#1
.0192c4	f0 c6		beq $01928c			beq 	CCTrue
.0192c6	80 c0		bra $019288			bra 	CCFalse
.0192c8					CompareValues:
.0192c8	b5 85		lda $85,x			lda 	XS_Type,x 					; and the types together
.0192ca	35 8b		and $8b,x			and 	XS2_Type,x
.0192cc	c9 02		cmp #$02			cmp 	#2
.0192ce	f0 11		beq $0192e1			beq 	_CVString
.0192d0	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.0192d2	35 8b		and $8b,x			and 	XS2_Type,x
.0192d4	4a		lsr a				lsr 	a 							; shift bit 0 into C
.0192d5	90 03		bcc $0192da			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.0192d7	4c 23 93	jmp $019323			jmp 	CompareInteger32 							; so execute code at \1
.0192da					_BCFloat:
.0192da	20 c7 93	jsr $0193c7			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.0192dd	4c 2c a1	jmp $01a12c			jmp 	FPCompare 							; and execute code at \2
.0192e0	60		rts				rts
.0192e1					_CVString:
.0192e1	da		phx				phx 								; save XY
.0192e2	5a		phy				phy
.0192e3	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.0192e5	85 1a		sta $1a				sta		zLTemp1+0
.0192e7	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0192e9	85 1b		sta $1b				sta 	zLTemp1+1
.0192eb	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.0192ed	85 1c		sta $1c				sta 	zLTemp1+2
.0192ef	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.0192f1	85 1d		sta $1d				sta 	zLTemp1+3
.0192f3	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.0192f5	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.0192f7	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.0192f9	90 02		bcc $0192fd			bcc 	_CVCommon
.0192fb	b1 1c		lda ($1c),y			lda 	(zLTemp1+2),y
.0192fd					_CVCommon:
.0192fd	aa		tax				tax 								; put shorter string length in zero.
.0192fe	f0 0c		beq $01930c			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.019300					_CVCompare:
.019300	c8		iny				iny 								; next character
.019301	b1 1a		lda ($1a),y			lda 	(zLTemp1),y 				; compare characters
.019303	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.019305	90 13		bcc $01931a			bcc 	_CVReturnLess 				; <
.019307	d0 15		bne $01931e			bne 	_CVReturnGreater 			; >
.019309	ca		dex				dex 								; until common length matched.
.01930a	d0 f4		bne $019300			bne 	_CVCompare
.01930c					_CVMatch:
.01930c	a0 00		ldy #$00			ldy 	#0
.01930e	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.019310	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.019312	90 06		bcc $01931a			bcc 	_CVReturnLess 				; <
.019314	d0 08		bne $01931e			bne 	_CVReturnGreater 			; >
.019316	a9 00		lda #$00			lda 	#0
.019318	80 06		bra $019320			bra 	_CVExit 					; same common, same length, same string
.01931a					_CVReturnLess:
.01931a	a9 ff		lda #$ff			lda 	#$FF
.01931c	80 02		bra $019320			bra 	_CVExit
.01931e					_CVReturnGreater:
.01931e	a9 01		lda #$01			lda 	#$01
.019320					_CVExit:
.019320	7a		ply				ply
.019321	fa		plx				plx
.019322	60		rts				rts
.019323					CompareInteger32:
.019323	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.019325	49 80		eor #$80			eor 	#$80
.019327	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019329	b5 89		lda $89,x			lda 	XS2_Mantissa+3,x
.01932b	49 80		eor #$80			eor 	#$80
.01932d	95 89		sta $89,x			sta 	XS2_Mantissa+3,x
.01932f	20 ad 93	jsr $0193ad			jsr 	SubInteger32 				; subtraction
.019332	90 0d		bcc $019341			bcc 	_CI32Less 					; cc return -1
.019334	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check if zero
.019336	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019338	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01933a	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01933c	f0 02		beq $019340			beq 	_CI32Exit
.01933e	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.019340					_CI32Exit:
.019340	60		rts				rts
.019341					_CI32Less:
.019341	a9 ff		lda #$ff			lda 	#$FF
.019343	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.019344					BinaryOp_Add:
.019344	b5 85		lda $85,x			lda 	XS_Type,x  					; and types together
.019346	35 8b		and $8b,x			and 	XS2_Type,x
.019348	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.01934a	d0 11		bne $01935d			bne 	_BOAString
.01934c	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.01934e	35 8b		and $8b,x			and 	XS2_Type,x
.019350	4a		lsr a				lsr 	a 							; shift bit 0 into C
.019351	90 03		bcc $019356			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.019353	4c 93 93	jmp $019393			jmp 	AddInteger32 							; so execute code at \1
.019356					_BCFloat:
.019356	20 c7 93	jsr $0193c7			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.019359	4c 07 9f	jmp $019f07			jmp 	FPAdd 							; and execute code at \2
.01935c	60		rts				rts
.01935d					_BOAString:
.01935d	4c e1 93	jmp $0193e1			jmp 	ConcatenateString 			; concatenate two strings.
.019360					BinaryOp_Subtract:
.019360	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.019362	35 8b		and $8b,x			and 	XS2_Type,x
.019364	4a		lsr a				lsr 	a 							; shift bit 0 into C
.019365	90 03		bcc $01936a			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.019367	4c ad 93	jmp $0193ad			jmp 	SubInteger32 							; so execute code at \1
.01936a					_BCFloat:
.01936a	20 c7 93	jsr $0193c7			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.01936d	4c ff 9e	jmp $019eff			jmp 	FPSubtract 							; and execute code at \2
.019370	60		rts				rts
.019371					BinaryOp_Multiply:
.019371	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.019373	35 8b		and $8b,x			and 	XS2_Type,x
.019375	4a		lsr a				lsr 	a 							; shift bit 0 into C
.019376	90 03		bcc $01937b			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.019378	4c d8 9c	jmp $019cd8			jmp 	MulInteger32 							; so execute code at \1
.01937b					_BCFloat:
.01937b	20 c7 93	jsr $0193c7			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.01937e	4c 2e a0	jmp $01a02e			jmp 	FPMultiply 							; and execute code at \2
.019381	60		rts				rts
.019382					BinaryOp_Divide:
.019382	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.019384	35 8b		and $8b,x			and 	XS2_Type,x
.019386	4a		lsr a				lsr 	a 							; shift bit 0 into C
.019387	90 03		bcc $01938c			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.019389	4c 16 9d	jmp $019d16			jmp 	DivInteger32 							; so execute code at \1
.01938c					_BCFloat:
.01938c	20 c7 93	jsr $0193c7			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.01938f	4c bb 9f	jmp $019fbb			jmp 	FPDivide 							; and execute code at \2
.019392	60		rts				rts
.019393					AddInteger32:
.019393	18		clc				clc
.019394	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019396	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.019398	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01939a	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01939c	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.01939e	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0193a0	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0193a2	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.0193a4	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0193a6	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.0193a8	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.0193aa	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0193ac	60		rts				rts
.0193ad					SubInteger32:
.0193ad	38		sec				sec
.0193ae	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0193b0	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.0193b2	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0193b4	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0193b6	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.0193b8	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0193ba	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0193bc	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.0193be	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0193c0	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.0193c2	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.0193c4	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0193c6	60		rts				rts
.0193c7					BinaryMakeBothFloat:
.0193c7	da		phx				phx 								; save X
.0193c8	e8		inx				inx
.0193c9	e8		inx				inx
.0193ca	e8		inx				inx
.0193cb	e8		inx				inx
.0193cc	e8		inx				inx
.0193cd	e8		inx				inx
.0193ce	20 d2 93	jsr $0193d2			jsr 	BinaryMakeFloat 			; convert to float.
.0193d1	fa		plx				plx 								; restore X and fall through.
.0193d2					BinaryMakeFloat:
.0193d2	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.0193d4	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.0193d5	b0 04		bcs $0193db			bcs 	_BMFConvert
.0193d7	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.0193d8	b0 04		bcs $0193de			bcs 	_BMFError
.0193da	60		rts				rts
.0193db					_BMFConvert:
.0193db	4c e7 a1	jmp $01a1e7			jmp 	FPUToFloat 					; convert to float
.0193de					_BMFError:
.0193de	4c 4f 85	jmp $01854f			jmp 	TypeError
.0193e1					ConcatenateString:
.0193e1	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.0193e3	85 1a		sta $1a				sta		zLTemp1+0
.0193e5	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0193e7	85 1b		sta $1b				sta 	zLTemp1+1
.0193e9	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.0193eb	85 1c		sta $1c				sta 	zLTemp1+2
.0193ed	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.0193ef	85 1d		sta $1d				sta 	zLTemp1+3
.0193f1	5a		phy				phy
.0193f2	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.0193f4	b1 1a		lda ($1a),y			lda 	(zlTemp1),y
.0193f6	71 1c		adc ($1c),y			adc 	(zlTemp1+2),y
.0193f8	7a		ply				ply
.0193f9	b0 33		bcs $01942e			bcs 	_CSError					; check in range.
.0193fb	c9 fe		cmp #$fe			cmp 	#maxString+1
.0193fd	b0 2f		bcs $01942e			bcs 	_CSError
.0193ff	20 77 98	jsr $019877			jsr 	AllocateTempString 			; store the result
.019402	20 19 94	jsr $019419			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.019405	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.019407	85 1a		sta $1a				sta 	zLTemp1
.019409	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.01940b	85 1b		sta $1b				sta 	zLTemp1+1
.01940d	20 19 94	jsr $019419			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.019410	a5 20		lda $20				lda 	zTempStr 					; point current to new string
.019412	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019414	a5 21		lda $21				lda 	zTempStr+1
.019416	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019418	60		rts				rts
.019419					_CSCopyString:
.019419	da		phx				phx
.01941a	5a		phy				phy
.01941b	a0 00		ldy #$00			ldy 	#0 							; get length
.01941d	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.01941f	f0 0a		beq $01942b			beq 	_CSCSExit 					; if zero, exit
.019421	aa		tax				tax 								; put in X
.019422					_CSCSLoop:
.019422	c8		iny				iny 								; get next char
.019423	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.019425	20 a2 98	jsr $0198a2			jsr		WriteTempString 			; copy out
.019428	ca		dex				dex 								; do whole string
.019429	d0 f7		bne $019422			bne 	_CSCSLoop
.01942b					_CSCSExit:
.01942b	7a		ply				ply
.01942c	fa		plx				plx
.01942d	60		rts				rts
.01942e					_CSError:
.01942e	20 6e 85	jsr $01856e			jsr ERR_Handler
>019431	53 74 72 69 6e 67 20 74			.text "String too long",0
>019439	6f 6f 20 6c 6f 6e 67 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.019441					Unary_Sgn:
.019441	20 e7 91	jsr $0191e7			jsr 	EvaluateNumberX 			; get value
.019444	20 37 98	jsr $019837			jsr 	CheckNextRParen 			; check right bracket.
.019447	20 65 94	jsr $019465			jsr 	GetSignCurrent 				; get sign.
.01944a	09 00		ora #$00			ora 	#0
.01944c	10 08		bpl $019456			bpl		UnarySetAInteger			; if 0,1 return that.
.01944e	80 00		bra $019450			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.019450					UnarySetAMinus1:
.019450	a9 ff		lda #$ff			lda 	#$FF
.019452	95 80		sta $80,x			sta 	XS_Mantissa,x
.019454	80 04		bra $01945a			bra 	UnarySetAFill
.019456					UnarySetAInteger:
.019456	95 80		sta $80,x			sta 	XS_Mantissa,x
.019458	a9 00		lda #$00			lda 	#0
.01945a					UnarySetAFill:
.01945a	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01945c	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01945e	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019460	a9 01		lda #$01			lda 	#1
.019462	95 85		sta $85,x			sta 	XS_Type,x
.019464	60		rts				rts
.019465					GetSignCurrent:
.019465	b5 85		lda $85,x			lda 	XS_Type,x 					; identify type.
.019467	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.019468	90 15		bcc $01947f			bcc 	_GSCFloat
.01946a	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01946c	30 0e		bmi $01947c			bmi 	_GSCMinus1
.01946e	15 80		ora $80,x			ora 	XS_Mantissa+0,x
.019470	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019472	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019474	d0 03		bne $019479			bne 	_GSCPlus1
.019476					_GSCZero:
.019476	a9 00		lda #$00			lda 	#0
.019478	60		rts				rts
.019479					_GSCPlus1:
.019479	a9 01		lda #$01			lda 	#$01
.01947b	60		rts				rts
.01947c					_GSCMinus1:
.01947c	a9 ff		lda #$ff			lda 	#$FF
.01947e	60		rts				rts
.01947f					_GSCFloat:
.01947f	34 85		bit $85,x			bit 	XS_Type,x
.019481	70 f3		bvs $019476			bvs 	_GSCZero
.019483	30 f7		bmi $01947c			bmi 	_GSCMinus1
.019485	80 f2		bra $019479			bra 	_GSCPlus1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.019487					Unary_Abs:
.019487	20 e7 91	jsr $0191e7			jsr 	EvaluateNumberX 			; get value
.01948a	20 37 98	jsr $019837			jsr 	CheckNextRParen 			; check right bracket.
.01948d	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.01948f	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.019491	f0 07		beq $01949a			beq 	_UAMinusFloat
.019493	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; check MSB
.019495	10 09		bpl $0194a0			bpl 	_UAExit
.019497	4c 9d 9d	jmp $019d9d			jmp 	IntegerNegateAlways 		; negation
.01949a					_UAMinusFloat:
.01949a	b5 85		lda $85,x			lda 	XS_Type,x 					; clear the sign bit.
.01949c	29 7f		and #$7f			and		#$7F
.01949e	95 85		sta $85,x			sta 	XS_Type,x
.0194a0					_UAExit:
.0194a0	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.0194a1					Unary_Peek:
.0194a1	a9 01		lda #$01			lda 	#1
.0194a3	80 06		bra $0194ab			bra 	UPMain
.0194a5					Unary_Deek:
.0194a5	a9 02		lda #$02			lda 	#2
.0194a7	80 02		bra $0194ab			bra 	UPMain
.0194a9					Unary_Leek:
.0194a9	a9 04		lda #$04			lda 	#4
.0194ab					UPMain:
.0194ab	48		pha				pha 								; set bytes to copy.
.0194ac	20 f5 91	jsr $0191f5			jsr 	EvaluateIntegerX 			; numeric parameter
.0194af	20 37 98	jsr $019837			jsr 	CheckNextRParen 			; right bracket.
.0194b2	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.0194b4	85 1a		sta $1a				sta 	zLTemp1
.0194b6	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0194b8	85 1b		sta $1b				sta 	zLTemp1+1
.0194ba	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0194bc	85 1c		sta $1c				sta 	zLTemp1+2
.0194be	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.0194c0	85 1d		sta $1d				sta 	zLTemp1+3
.0194c2	a9 00		lda #$00			lda 	#0 							; clear target area
.0194c4	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0194c6	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0194c8	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0194ca	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0194cc	68		pla				pla 								; restore bytes to copy
.0194cd	da		phx				phx 								; save XY
.0194ce	5a		phy				phy
.0194cf	20 b9 97	jsr $0197b9			jsr 	MemRead 					; read the bytes in
.0194d2	7a		ply				ply 								; restore and exit
.0194d3	fa		plx				plx
.0194d4	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/pos.asm

.0194d5					Unary_Pos:
.0194d5	20 e7 91	jsr $0191e7			jsr 	EvaluateNumberX 			; get value
.0194d8	20 37 98	jsr $019837			jsr 	CheckNextRParen 			; check right bracket.
.0194db	20 3b 85	jsr $01853b			jsr 	CharGetPosition 			; get the position
.0194de	4c 56 94	jmp $019456			jmp		UnarySetAInteger			; if 0,1 return that.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.0194e1					Unary_Mod:
.0194e1	20 09 95	jsr $019509			jsr 	_UMParameter 				; first parameter
.0194e4	20 3f 98	jsr $01983f			jsr 	CheckNextComma
.0194e7	da		phx				phx 								; second parameter
.0194e8	e8		inx				inx
.0194e9	e8		inx				inx
.0194ea	e8		inx				inx
.0194eb	e8		inx				inx
.0194ec	e8		inx				inx
.0194ed	e8		inx				inx
.0194ee	20 09 95	jsr $019509			jsr 	_UMParameter
.0194f1	fa		plx				plx
.0194f2	20 37 98	jsr $019837			jsr 	CheckNextRParen
.0194f5	20 16 9d	jsr $019d16			jsr 	DivInteger32 				; divide
.0194f8	a5 1a		lda $1a				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.0194fa	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0194fc	a5 1b		lda $1b				lda 	zLTemp1+1
.0194fe	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019500	a5 1c		lda $1c				lda 	zLTemp1+2
.019502	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019504	a5 1d		lda $1d				lda 	zLTemp1+3
.019506	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019508	60		rts				rts
.019509					_UMParameter:
.019509	20 f5 91	jsr $0191f5			jsr 	EvaluateIntegerX 			; get value
.01950c	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; absolute value
.01950e	10 03		bpl $019513			bpl 	_UMNotSigned
.019510	20 9d 9d	jsr $019d9d			jsr 	IntegerNegateAlways
.019513					_UMNotSigned:
.019513	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.019514					Unary_Usr:
.019514	20 e7 91	jsr $0191e7			jsr 	EvaluateNumberX 			; numeric parameter
.019517	20 37 98	jsr $019837			jsr 	CheckNextRParen 			; right bracket.
.01951a	da		phx				phx 								; save XY
.01951b	5a		phy				phy
.01951c	ea		nop				nop
.01951d	22 0c 03 00	jsl $00030c			jsl 	UserVector
.019521	7a		ply				ply 								; and exit
.019522	fa		plx				plx
.019523	60		rts				rts
.019524					USRDefault:
.019524	20 6e 85	jsr $01856e			jsr ERR_Handler
>019527	4e 6f 20 55 53 52 20 76			.text "No USR vector.",0
>01952f	65 63 74 6f 72 2e 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.019536					Unary_Val:
.019536	20 fe 91	jsr $0191fe			jsr 	EvaluateStringX 			; get string
.019539	20 37 98	jsr $019837			jsr 	CheckNextRParen 			; check right bracket.
.01953c	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.01953e	85 1e		sta $1e				sta 	zGenPtr
.019540	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019542	85 1f		sta $1f				sta 	zGenPtr+1
.019544	5a		phy				phy
.019545	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.019547	b1 1e		lda ($1e),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.019549	f0 54		beq $01959f			beq 	_UVBadNumber
.01954b	48		pha				pha 								; save length.
.01954c	1a		inc a				inc 	a 							; one for the length, one for the terminator
.01954d	1a		inc a				inc 	a
.01954e	20 77 98	jsr $019877			jsr 	AllocateTempString
.019551	c8		iny				iny 								; move to the next.
.019552	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get character
.019554	49 2d		eor #$2d			eor 	#"-"						; zero if minus sign
.019556	8d a0 03	sta $03a0			sta 	ValSign
.019559	d0 04		bne $01955f			bne 	_UVNotMinus
.01955b	c8		iny				iny 								; skip over it.
.01955c	68		pla				pla 								; decrement character count.
.01955d	3a		dec a				dec 	a
.01955e	48		pha				pha
.01955f					_UVNotMinus:
.01955f	68		pla				pla 								; this is the count.
.019560	48		pha		_UVCopy:pha									; copy into new temp string which is ASCIIZ
.019561	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.019563	c8		iny				iny
.019564	20 a2 98	jsr $0198a2			jsr 	WriteTempString
.019567	68		pla				pla
.019568	3a		dec a				dec 	a
.019569	d0 f5		bne $019560			bne 	_UVCopy
.01956b	20 a2 98	jsr $0198a2			jsr 	WriteTempString 			; make it ASCIIZ
.01956e	18		clc				clc
.01956f	a5 20		lda $20				lda 	zTempStr 					; tempstring +1 => genptr
.019571	69 01		adc #$01			adc 	#1
.019573	85 1e		sta $1e				sta 	zGenPtr
.019575	a5 21		lda $21				lda 	zTempStr+1
.019577	69 00		adc #$00			adc 	#0
.019579	85 1f		sta $1f				sta 	zGenPtr+1
.01957b	18		clc				clc
.01957c	20 6f 9e	jsr $019e6f			jsr 	IntFromString 				; first bit.
.01957f	b0 1e		bcs $01959f			bcs 	_UVBadNumber
.019581	20 ed a3	jsr $01a3ed			jsr 	FPFromString				; try for a float part.
.019584	ad a0 03	lda $03a0			lda 	ValSign 					; was it negative
.019587	d0 10		bne $019599			bne 	_UVNotNegative
.019589	b5 85		lda $85,x			lda 	XS_Type,x 					; check if integer
.01958b	4a		lsr a				lsr 	a
.01958c	b0 08		bcs $019596			bcs 	_UVInteger
.01958e	b5 85		lda $85,x			lda 	XS_Type,x 					; set sign bit
.019590	09 80		ora #$80			ora 	#$80
.019592	95 85		sta $85,x			sta 	XS_Type,x
.019594	80 03		bra $019599			bra 	_UVNotNegative
.019596					_UVInteger:
.019596	20 9d 9d	jsr $019d9d			jsr 	IntegerNegateAlways 		; sign it.
.019599					_UVNotNegative:
.019599	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; used everything
.01959b	d0 02		bne $01959f			bne 	_UVBadNumber
.01959d	7a		ply				ply
.01959e	60		rts				rts
.01959f					_UVBadNumber:
.01959f	4c 5d 85	jmp $01855d			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.0195a2					Unary_Str:
.0195a2	20 e7 91	jsr $0191e7			jsr 	EvaluateNumberX 			; numeric parameter
.0195a5	20 37 98	jsr $019837			jsr 	CheckNextRParen 			; right bracket.
.0195a8	a9 00		lda #$00			lda 	#0 							; reset buffer index
.0195aa	8d 14 03	sta $0314			sta 	NumBufX
.0195ad	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.0195af	4a		lsr a				lsr 	a
.0195b0	b0 05		bcs $0195b7			bcs 	_USInt 						; if msb set do as integer
.0195b2	20 32 a3	jsr $01a332			jsr 	FPToString 					; call fp to str otherwise
.0195b5	80 03		bra $0195ba			bra 	_USDuplicate
.0195b7	20 ba 9d	jsr $019dba	_USInt:	jsr 	IntToString
.0195ba					_USDuplicate:
.0195ba	ad 14 03	lda $0314			lda 	NumBufX 					; chars in buffer
.0195bd	1a		inc a				inc 	a 							; one more for length
.0195be	20 77 98	jsr $019877			jsr 	AllocateTempString 			; allocate space for it.
.0195c1	5a		phy				phy 								; save Y
.0195c2	a0 00		ldy #$00			ldy 	#0 							; start copying
.0195c4	b9 15 03	lda $0315,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.0195c7	20 a2 98	jsr $0198a2			jsr 	WriteTempString
.0195ca	c8		iny				iny
.0195cb	cc 14 03	cpy $0314			cpy 	NumBufX 					; done the lot
.0195ce	d0 f4		bne $0195c4			bne 	_USCopy
.0195d0	7a		ply				ply 								; restore Y
.0195d1	4c ac 97	jmp $0197ac			jmp 	UnaryReturnTempStr 			; return new temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.0195d4					Unary_Asc:
.0195d4	20 fe 91	jsr $0191fe			jsr 	EvaluateStringX 			; string parameter
.0195d7	20 37 98	jsr $019837			jsr 	CheckNextRParen 			; right bracket.
.0195da	5a		phy				phy 								; get the string length
.0195db	a0 00		ldy #$00			ldy 	#0
.0195dd	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.0195df	f0 07		beq $0195e8			beq 	_UAIllegal 					; must be at least one character
.0195e1	c8		iny				iny
.0195e2	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; read it.
.0195e4	7a		ply				ply
.0195e5	4c 56 94	jmp $019456			jmp 	UnarySetAInteger
.0195e8					_UAIllegal:
.0195e8	4c 5d 85	jmp $01855d			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.0195eb					Unary_Len:
.0195eb	20 fe 91	jsr $0191fe			jsr 	EvaluateStringX 			; string parameter
.0195ee	20 37 98	jsr $019837			jsr 	CheckNextRParen 			; right bracket.
.0195f1	5a		phy				phy 								; get the string length
.0195f2	a0 00		ldy #$00			ldy 	#0
.0195f4	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.0195f6	7a		ply				ply
.0195f7	4c 56 94	jmp $019456			jmp 	UnarySetAInteger

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.0195fa					Unary_Mid:
.0195fa	20 fe 91	jsr $0191fe			jsr 	EvaluateStringX 				; get string.
.0195fd	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.0195ff	48		pha				pha
.019600	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019602	48		pha				pha
.019603	20 3f 98	jsr $01983f			jsr 	CheckNextComma 					; skip comma
.019606	20 8f 96	jsr $01968f			jsr 	SLIByteParameter 				; get a byte parameter (start)
.019609	48		pha				pha 									; and push it.
.01960a	20 3f 98	jsr $01983f			jsr 	CheckNextComma 					; skip comma
.01960d	20 8f 96	jsr $01968f			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.019610	48		pha				pha 									; and push it.
.019611	80 41		bra $019654			bra 	SLIProcess
.019613					Unary_Left:
.019613	20 fe 91	jsr $0191fe			jsr 	EvaluateStringX 				; get string.
.019616	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.019618	48		pha				pha
.019619	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01961b	48		pha				pha
.01961c	a9 01		lda #$01			lda 	#1 								; push start position (1)
.01961e	48		pha				pha
.01961f	20 3f 98	jsr $01983f			jsr 	CheckNextComma 					; skip comma
.019622	20 8f 96	jsr $01968f			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.019625	48		pha				pha 									; and push it.
.019626	80 2c		bra $019654			bra 	SLIProcess
.019628					Unary_Right:
.019628	20 fe 91	jsr $0191fe			jsr 	EvaluateStringX 				; get string.
.01962b	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.01962d	48		pha				pha
.01962e	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019630	48		pha				pha
.019631	da		phx				phx 									; get the string length and push on stack.
.019632	a2 00		ldx #$00			ldx 	#0
.019634	a1 1e		lda ($1e,x)			lda		(zGenPtr,x)
.019636	fa		plx				plx
.019637	48		pha				pha
.019638	20 3f 98	jsr $01983f			jsr 	CheckNextComma 					; skip comma
.01963b	20 8f 96	jsr $01968f			jsr 	SLIByteParameter 				; get a byte parameter.
.01963e	8d 9e 03	sta $039e			sta 	SignCount 						; save in temporary.
.019641	68		pla				pla 									; restore string length.
.019642	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.019643	38		sec				sec
.019644	ed 9e 03	sbc $039e			sbc 	SignCount 						; subtract characters needed, gives start position.
.019647	f0 02		beq $01964b			beq 	_URStart 						; if <= 0 start from 1.
.019649	10 02		bpl $01964d			bpl 	_UROkay
.01964b					_URStart:
.01964b	a9 01		lda #$01			lda 	#1
.01964d					_UROkay:
.01964d	48		pha				pha 									; push start
.01964e	ad 9e 03	lda $039e			lda 	SignCount 						; push count of characters
.019651	48		pha				pha
.019652	80 00		bra $019654			bra 	SLIProcess
.019654					SLIProcess:
.019654	20 37 98	jsr $019837			jsr 	CheckNextRParen 				; closing right bracket.
.019657	68		pla				pla
.019658	8d a2 03	sta $03a2			sta 	SliceCount 						; count in signcount
.01965b	1a		inc a				inc 	a 								; allocate +1 for it.
.01965c	20 77 98	jsr $019877			jsr 	AllocateTempString
.01965f	68		pla				pla 									; pop start number off stack.
.019660	f0 3b		beq $01969d			beq 	SLIError 						; exit if start = 0
.019662	8d a1 03	sta $03a1			sta 	SliceStart
.019665	68		pla				pla  									; pop string address.
.019666	85 1f		sta $1f				sta 	zGenPtr+1
.019668	68		pla				pla
.019669	85 1e		sta $1e				sta 	zGenPtr
.01966b	da		phx				phx
.01966c	5a		phy				phy
.01966d	a2 00		ldx #$00			ldx 	#0 								; point to string length.
.01966f	ac a1 03	ldy $03a1			ldy 	SliceStart 						; start of the string (+1 for count)
.019672					_SLICopy:
.019672	ad a2 03	lda $03a2			lda 	SliceCount 						; done count characters
.019675	f0 12		beq $019689			beq 	_SLIExit
.019677	ce a2 03	dec $03a2			dec 	SliceCount
.01967a	98		tya				tya 									; index of character
.01967b	c1 1e		cmp ($1e,x)			cmp 	(zGenPtr,x)						; compare against length
.01967d	f0 02		beq $019681			beq 	_SLIOk 							; if equal, okay.
.01967f	b0 08		bcs $019689			bcs 	_SLIExit 						; if past end, then exit.
.019681	b1 1e		lda ($1e),y	_SLIOk:	lda 	(zGenPtr),y 					; copy one character
.019683	c8		iny				iny
.019684	20 a2 98	jsr $0198a2			jsr 	WriteTempString
.019687	80 e9		bra $019672			bra 	_SLICopy 						; go round till copied characters
.019689					_SLIExit:
.019689	7a		ply				ply 									; restore YX
.01968a	fa		plx				plx
.01968b	4c ac 97	jmp $0197ac			jmp 	UnaryReturnTempStr 				; return new temporary string.
.01968e	ea		nop				nop
.01968f					SLIByteParameter:
.01968f	20 f5 91	jsr $0191f5			jsr 	EvaluateIntegerX 				; get integer
.019692	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.019694	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019696	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019698	d0 03		bne $01969d			bne 	SLIError
.01969a	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01969c	60		rts				rts
.01969d					SLIError:
.01969d	4c 5d 85	jmp $01855d			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.0196a0					Unary_Hex:
.0196a0	20 f5 91	jsr $0191f5			jsr 	EvaluateIntegerX 			; numeric parameter
.0196a3	20 37 98	jsr $019837			jsr 	CheckNextRParen 			; right bracket.
.0196a6	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.0196a8	20 77 98	jsr $019877			jsr 	AllocateTempString			; allocate string space
.0196ab	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.0196ad	20 d1 96	jsr $0196d1			jsr 	_UHConvert
.0196b0	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0196b2	20 d1 96	jsr $0196d1			jsr 	_UHConvert
.0196b5	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0196b7	20 d1 96	jsr $0196d1			jsr 	_UHConvert
.0196ba	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0196bc	20 d1 96	jsr $0196d1			jsr 	_UHConvert
.0196bf	5a		phy				phy 								; get length of new string
.0196c0	a0 00		ldy #$00			ldy 	#0
.0196c2	b1 20		lda ($20),y			lda 	(zTempStr),y
.0196c4	7a		ply				ply
.0196c5	c9 00		cmp #$00			cmp 	#0
.0196c7	d0 05		bne $0196ce			bne 	_UHExit 					; if it was non zero okay
.0196c9	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.0196cb	20 a2 98	jsr $0198a2			jsr 	WriteTempString
.0196ce					_UHExit:
.0196ce	4c ac 97	jmp $0197ac			jmp 	UnaryReturnTempStr 			; return new temporary string.
.0196d1					_UHConvert:
.0196d1	48		pha				pha
.0196d2	4a		lsr a				lsr 	a 							; do MSB
.0196d3	4a		lsr a				lsr 	a
.0196d4	4a		lsr a				lsr 	a
.0196d5	4a		lsr a				lsr 	a
.0196d6	20 da 96	jsr $0196da			jsr 	_UHNibble
.0196d9	68		pla				pla 								; do LSB
.0196da					_UHNibble:
.0196da	29 0f		and #$0f			and 	#15 						; get nibble
.0196dc	d0 0c		bne $0196ea			bne 	_UHNonZero
.0196de	5a		phy				phy									; get the length
.0196df	a0 00		ldy #$00			ldy 	#0
.0196e1	b1 20		lda ($20),y			lda 	(zTempStr),y
.0196e3	7a		ply				ply
.0196e4	c9 00		cmp #$00			cmp 	#0 							; suppress leading zeros.
.0196e6	f0 0d		beq $0196f5			beq 	_UHExit2
.0196e8	a9 00		lda #$00			lda 	#0
.0196ea					_UHNonZero:
.0196ea	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.0196ec	90 02		bcc $0196f0			bcc 	_UHDigit
.0196ee	69 06		adc #$06			adc 	#7-1
.0196f0					_UHDigit:
.0196f0	69 30		adc #$30			adc 	#48
.0196f2	20 a2 98	jsr $0198a2			jsr 	WriteTempString				; output.
.0196f5					_UHExit2:
.0196f5	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.0196f6					Unary_Dec:
.0196f6	20 fe 91	jsr $0191fe			jsr 	EvaluateStringX 			; string parameter
.0196f9	20 37 98	jsr $019837			jsr 	CheckNextRParen 			; right bracket.
.0196fc	5a		phy				phy
.0196fd	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.0196ff	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.019701	f0 41		beq $019744			beq 	_UDFail 					; must fail if zero.
.019703	8d 9e 03	sta $039e			sta 	SignCount 					; use SignCount as a counter
.019706	a9 00		lda #$00			lda 	#0 							; set result to zero integer.
.019708	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01970a	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01970c	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01970e	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019710	a9 01		lda #$01			lda 	#1
.019712	95 85		sta $85,x			sta 	XS_Type,x
.019714					_UDConvertLoop:
.019714	5a		phy				phy 								; shift mantissa left 4
.019715	a0 04		ldy #$04			ldy 	#4
.019717					_UDShift:
.019717	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.019719	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.01971b	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.01971d	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.01971f	88		dey				dey
.019720	d0 f5		bne $019717			bne 	_UDShift
.019722	7a		ply				ply
.019723	c8		iny				iny 								; next character
.019724	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; fetch it.
.019726	20 47 97	jsr $019747			jsr 	ConvertUpper 				; convert to U/C
.019729	c9 30		cmp #$30			cmp 	#"0"
.01972b	90 17		bcc $019744			bcc 	_UDFail
.01972d	c9 3a		cmp #$3a			cmp 	#"9"+1
.01972f	90 06		bcc $019737			bcc 	_UDOkay
.019731	e9 37		sbc #$37			sbc 	#7+"0" 						; alpha fudge
.019733	c9 10		cmp #$10			cmp 	#16
.019735	b0 0d		bcs $019744			bcs 	_UDFail
.019737					_UDOkay:
.019737	29 0f		and #$0f			and 	#15 						; nibble only
.019739	15 80		ora $80,x			ora 	XS_Mantissa+0,x
.01973b	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01973d	ce 9e 03	dec $039e			dec 	SignCount 					; do it for each character
.019740	d0 d2		bne $019714			bne 	_UDConvertLoop
.019742	7a		ply				ply
.019743	60		rts				rts
.019744					_UDFail:
.019744	4c 5d 85	jmp $01855d			jmp 	BadParamError
.019747					ConvertUpper:
.019747	c9 61		cmp #$61			cmp 	#"a"
.019749	90 07		bcc $019752			bcc 	_CUExit
.01974b	c9 7b		cmp #$7b			cmp 	#"z"+1
.01974d	b0 03		bcs $019752			bcs 	_CUExit
.01974f	38		sec				sec
.019750	e9 20		sbc #$20			sbc 	#32
.019752	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.019753					Unary_Chr:
.019753	20 f5 91	jsr $0191f5			jsr 	EvaluateIntegerX			; numeric parameter
.019756	20 37 98	jsr $019837			jsr 	CheckNextRParen 			; right bracket.
.019759	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.01975b	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01975d	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01975f	d0 0d		bne $01976e			bne 	_UCChar
.019761	a9 01		lda #$01			lda 	#1 							; one character string
.019763	20 77 98	jsr $019877			jsr 	AllocateTempString
.019766	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.019768	20 a2 98	jsr $0198a2			jsr 	WriteTempString
.01976b	4c ac 97	jmp $0197ac			jmp 	UnaryReturnTempStr
.01976e					_UCChar:
.01976e	4c 5d 85	jmp $01855d			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.019771					Unary_Spc:
.019771	20 8f 96	jsr $01968f			jsr 	SLIByteParameter 			; check space.
.019774	20 37 98	jsr $019837			jsr 	CheckNextRParen
.019777	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019779					UnarySpcCreate:
.019779	c9 fe		cmp #$fe			cmp 	#maxString+1
.01977b	b0 14		bcs $019791			bcs 	_USSize
.01977d	48		pha				pha 								; save length
.01977e	1a		inc a				inc 	a 							; allocate one more.
.01977f	20 77 98	jsr $019877			jsr 	AllocateTempString
.019782	68		pla				pla 								; get length
.019783	f0 27		beq $0197ac			beq 	UnaryReturnTempStr 			; return the current temp string
.019785					_USLoop:
.019785	48		pha				pha
.019786	a9 20		lda #$20			lda 	#" "
.019788	20 a2 98	jsr $0198a2			jsr 	WriteTempString
.01978b	68		pla				pla
.01978c	3a		dec a				dec 	a
.01978d	d0 f6		bne $019785			bne 	_USLoop
.01978f	80 1b		bra $0197ac			bra 	UnaryReturnTempStr
.019791					_USSize:
.019791	4c 5d 85	jmp $01855d			jmp 	BadParamError
.019794					Unary_Tab:
.019794	a2 00		ldx #$00			ldx 	#0 							; required TAB position.
.019796	20 8f 96	jsr $01968f			jsr 	SLIByteParameter
.019799	20 37 98	jsr $019837			jsr 	CheckNextRParen
.01979c	20 3b 85	jsr $01853b			jsr 	CharGetPosition 			; were are we ?
.01979f	85 10		sta $10				sta 	zTemp1
.0197a1	38		sec				sec
.0197a2	a5 80		lda $80				lda 	XS_Mantissa+0 				; return chars required.
.0197a4	e5 10		sbc $10				sbc 	zTemp1
.0197a6	b0 d1		bcs $019779			bcs 	UnarySpcCreate
.0197a8	a9 00		lda #$00			lda 	#0
.0197aa	80 cd		bra $019779			bra 	UnarySpcCreate
.0197ac					UnaryReturnTempStr:
.0197ac	a5 20		lda $20				lda 	zTempStr 					; copy temp string addr -> mantissa
.0197ae	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0197b0	a5 21		lda $21				lda 	zTempStr+1
.0197b2	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0197b4	a9 02		lda #$02			lda 	#2 							; set type to string
.0197b6	95 85		sta $85,x			sta 	XS_Type,x
.0197b8	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/65816.asm

.0197b9					MemRead:
.0197b9	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.0197bc	a0 00		ldy #$00			ldy 	#0 							; start from here
.0197be	b7 1a		lda [$1a],y	_MLoop1:lda 	[zlTemp1],y 				; read the long address
.0197c0	95 80		sta $80,x			sta 	XS_Mantissa,x 				; copy into mantissa
.0197c2	c8		iny				iny 								; next to copy
.0197c3	e8		inx				inx
.0197c4	cc 9e 03	cpy $039e			cpy 	SignCount 					; do required # of bytes.
.0197c7	d0 f5		bne $0197be			bne 	_MLoop1
.0197c9	60		rts				rts
.0197ca					MemWrite:
.0197ca	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.0197cd	a0 00		ldy #$00			ldy 	#0 							; start from here
.0197cf	b5 80		lda $80,x	_MLoop1:lda 	XS_Mantissa,x 				; read mantisssa
.0197d1	97 1a		sta [$1a],y			sta 	[zlTemp1],y 				; write it out
.0197d3	c8		iny				iny 								; next to copy
.0197d4	e8		inx				inx
.0197d5	cc 9e 03	cpy $039e			cpy 	SignCount 					; do required # of bytes.
.0197d8	d0 f5		bne $0197cf			bne 	_MLoop1
.0197da	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/programend.asm

.0197db					UpdateProgramEnd:
.0197db	a9 00		lda #$00			lda 	#BasicProgram & $FF
.0197dd	85 16		sta $16				sta 	zCodePtr+0
.0197df	a9 10		lda #$10			lda 	#BasicProgram >> 8
.0197e1	85 17		sta $17				sta 	zCodePtr+1
.0197e3	a9 00		lda #$00			lda 	#0
.0197e5	85 18		sta $18				sta 	zCodePtr+2
.0197e7	85 19		sta $19				sta 	zCodePtr+3
.0197e9	a0 03		ldy #$03			ldy 	#3
.0197eb					_UPDLoop:
.0197eb	a0 00		ldy #$00			ldy 	#0
.0197ed	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0197ef	c9 00		cmp #$00			cmp 	#0 							; end if offset is zero.
.0197f1	f0 0f		beq $019802			beq 	_UPDFoundEnd
.0197f3	a0 00		ldy #$00			ldy 	#0 							; point to offset
.0197f5	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.0197f7	18		clc				clc
.0197f8	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.0197fa	85 16		sta $16				sta 	zCodePtr
.0197fc	90 02		bcc $019800			bcc 	_SNLNoCarry
.0197fe	e6 17		inc $17				inc 	zCodePtr+1
.019800					_SNLNoCarry:
.019800	80 e9		bra $0197eb			bra 	_UPDLoop
.019802					_UPDFoundEnd:
.019802	18		clc				clc 								; end of program 2 on.
.019803	a5 16		lda $16				lda 	zCodePtr
.019805	69 02		adc #$02			adc 	#2
.019807	8d 04 03	sta $0304			sta 	endOfProgram
.01980a	a5 17		lda $17				lda 	zCodePtr+1
.01980c	69 00		adc #$00			adc 	#0
.01980e	8d 05 03	sta $0305			sta 	endOfProgram+1
.019811	a5 18		lda $18				lda 	zCodePtr+2
.019813	69 00		adc #$00			adc		#0
.019815	8d 06 03	sta $0306			sta 	endOfProgram+2
.019818	a5 19		lda $19				lda 	zCodePtr+3
.01981a	69 00		adc #$00			adc 	#0
.01981c	8d 07 03	sta $0307			sta 	endOfProgram+3
.01981f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.019820					CheckNextToken:
.019820	d7 16		cmp [$16],y			cmp 	[zCodePtr],y
.019822	d0 02		bne $019826			bne 	CTFail 						; no, then fail
.019824	c8		iny				iny
.019825	60		rts				rts
.019826					CTFail:
.019826	20 6e 85	jsr $01856e			jsr ERR_Handler
>019829	4d 69 73 73 69 6e 67 20			.text "Missing token",0
>019831	74 6f 6b 65 6e 00
.019837					CheckNextRParen:
.019837	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019839	c9 be		cmp #$be			cmp 	#token_rparen
.01983b	d0 e9		bne $019826			bne 	CTFail
.01983d	c8		iny				iny
.01983e	60		rts				rts
.01983f					CheckNextComma:
.01983f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019841	c9 bf		cmp #$bf			cmp 	#token_comma
.019843	d0 e1		bne $019826			bne 	CTFail
.019845	c8		iny				iny
.019846	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/concrete.asm

.019847					StringConcrete:
.019847	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; save source to zTemp1
.019849	85 10		sta $10				sta 	zTemp1
.01984b	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01984d	85 11		sta $11				sta 	zTemp1+1
.01984f	a0 00		ldy #$00			ldy 	#0 							; subtract the length+1 (clc) of the string.
.019851	18		clc				clc 								; from the string pointer
.019852	ad 00 03	lda $0300			lda 	StringPtr 					; and put in zTemp2 as well
.019855	f1 10		sbc ($10),y			sbc 	(zTemp1),y
.019857	8d 00 03	sta $0300			sta 	StringPtr
.01985a	85 12		sta $12				sta 	zTemp2
.01985c	ad 01 03	lda $0301			lda 	StringPtr+1
.01985f	e9 00		sbc #$00			sbc 	#0
.019861	8d 01 03	sta $0301			sta 	StringPtr+1
.019864	85 13		sta $13				sta 	zTemp2+1
.019866	b1 10		lda ($10),y			lda 	(zTemp1),y 					; length add one for count
.019868	1a		inc a				inc 	a
.019869	aa		tax				tax
.01986a	b1 10		lda ($10),y	_SCCopy:lda 	(zTemp1),y 					; copy whole thing including length
.01986c	91 12		sta ($12),y			sta 	(zTemp2),y
.01986e	c8		iny				iny
.01986f	ca		dex				dex
.019870	d0 f8		bne $01986a			bne 	_SCCopy
.019872	a5 13		lda $13				lda 	zTemp2+1 					; return concrete string in AX
.019874	a6 12		ldx $12				ldx 	zTemp2
.019876	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.019877					AllocateTempString:
.019877	48		pha				pha 								; save required count.
.019878	a5 21		lda $21				lda 	zTempStr+1 					; check if initialised yet ?
.01987a	d0 0b		bne $019887			bne 	_ATSInitialised
.01987c	ad 00 03	lda $0300			lda 	StringPtr 					; set temporary string ptr 1 page below available
.01987f	85 20		sta $20				sta 	zTempStr					; space, this is for strings to be concreted.
.019881	ad 01 03	lda $0301			lda 	StringPtr+1
.019884	3a		dec a				dec 	a
.019885	85 21		sta $21				sta 	zTempStr+1
.019887					_ATSInitialised:
.019887	68		pla				pla 								; get required count back.
.019888	49 ff		eor #$ff			eor 	#$FF 						; negate 2's complement.
.01988a	1a		inc a				inc 	a
.01988b	18		clc				clc
.01988c	65 20		adc $20				adc 	zTempStr 					; "add" to the temp string pointer
.01988e	85 20		sta $20				sta 	zTempStr
.019890	a9 ff		lda #$ff			lda 	#$FF
.019892	65 21		adc $21				adc 	zTempStr+1
.019894	85 21		sta $21				sta 	zTempStr+1
.019896	a9 00		lda #$00			lda 	#0 							; clear temp string.
.019898	5a		phy				phy
.019899	a8		tay				tay
.01989a	91 20		sta ($20),y			sta 	(zTempStr),y
.01989c	7a		ply				ply
.01989d	1a		inc a				inc 	a 							; reset the write index.
.01989e	8d 9f 03	sta $039f			sta 	TempStringWriteIndex
.0198a1	60		rts				rts
.0198a2					WriteTempString:
.0198a2	5a		phy				phy 								; save Y
.0198a3	ac 9f 03	ldy $039f			ldy 	TempStringWriteIndex	 	; write position.
.0198a6	91 20		sta ($20),y			sta 	(zTempStr),y 				; write character out.
.0198a8	ee 9f 03	inc $039f			inc 	TempStringWriteIndex 		; increment the write position.
.0198ab	98		tya				tya 								; unchanged Y is now length
.0198ac	a0 00		ldy #$00			ldy 	#0
.0198ae	91 20		sta ($20),y			sta 	(zTempStr),y
.0198b0	7a		ply				ply 								; restore Y and exit
.0198b1	60		rts				rts
.0198b2					CreateTempStringCopy:
.0198b2	da		phx				phx 								; save X
.0198b3	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0198b5	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.0198b6	20 77 98	jsr $019877			jsr 	AllocateTempString 			; allocate memory for temporary string.
.0198b9	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0198bb	c8		iny				iny
.0198bc	3a		dec a				dec 	a 							; make the actual length in charactes
.0198bd	3a		dec a				dec 	a
.0198be	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.0198c0	81 20		sta ($20,x)			sta 	(zTempStr,x)
.0198c2	85 1a		sta $1a				sta 	zLTemp1 					; that's used as a count.
.0198c4	09 00		ora #$00			ora 	#0 							; if zero already, exit
.0198c6	f0 0e		beq $0198d6			beq 	_CTSCExit
.0198c8					_CTSCLoop:
.0198c8	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0198ca	c8		iny				iny
.0198cb	5a		phy				phy 								; save in Y
.0198cc	e8		inx				inx 								; bump index
.0198cd	da		phx				phx 								; index into Y
.0198ce	7a		ply				ply
.0198cf	91 20		sta ($20),y			sta 	(zTempStr),y 				; save at index
.0198d1	7a		ply				ply 								; restore Y
.0198d2	c6 1a		dec $1a				dec 	zLTemp1 					; do for each character
.0198d4	d0 f2		bne $0198c8			bne 	_CTSCLoop
.0198d6					_CTSCExit:
.0198d6	fa		plx				plx 								; restore X
.0198d7	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/variables.asm

.0198d8					VariableFind:
.0198d8	20 43 99	jsr $019943			jsr 	VariableExtract 		; find out all about it ....
.0198db	20 dc 9b	jsr $019bdc			jsr 	VariableLocate 			; does it already exist ?
.0198de	b0 03		bcs $0198e3			bcs 	_VFExists 				; if so, use that.
.0198e0	20 cf 99	jsr $0199cf			jsr 	VariableCreate 			; otherwise create it.
.0198e3					_VFExists:
.0198e3	a5 24		lda $24				lda 	zVarType 				; is it still an array ?
.0198e5	29 01		and #$01			and 	#1
.0198e7	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.0198e9	d0 28		bne $019913			bne 	_VFSingleElement
.0198eb					_VFNextIndex:
.0198eb	a5 22		lda $22				lda 	zVarDataPtr 			; push the data ptr and type on the stack.
.0198ed	48		pha				pha
.0198ee	a5 23		lda $23				lda 	zVarDataPtr+1
.0198f0	48		pha				pha
.0198f1	a5 24		lda $24				lda 	zVarType
.0198f3	48		pha				pha
.0198f4	20 f5 91	jsr $0191f5			jsr 	EvaluateIntegerX 		; calculate the index.
.0198f7	68		pla				pla 							; restore and index.
.0198f8	85 24		sta $24				sta 	zVarType
.0198fa	68		pla				pla
.0198fb	85 23		sta $23				sta 	zVarDataPtr+1
.0198fd	68		pla				pla
.0198fe	85 22		sta $22				sta 	zVarDataPtr
.019900	20 5a 9a	jsr $019a5a			jsr 	ArrayIndexFollow 		; do the index.
.019903	a5 24		lda $24				lda 	zVarType 				; is it still an array ??
.019905	29 01		and #$01			and 	#1
.019907	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.019909	d0 05		bne $019910			bne 	_VFArrayDone 			; if so then exit.
.01990b	20 3f 98	jsr $01983f			jsr 	CheckNextComma 			; comma should follow
.01990e	80 db		bra $0198eb			bra 	_VFNextIndex
.019910					_VFArrayDone:
.019910	20 37 98	jsr $019837			jsr 	CheckNextRParen 		; check closing right bracket.
.019913					_VFSingleElement:
.019913	60		rts				rts
.019914					VariableClear:
.019914	48		pha				pha 							; save registers
.019915	da		phx				phx
.019916	a2 00		ldx #$00			ldx 	#0 						; clear out the hash table.
.019918	8a		txa				txa
.019919	9d 35 03	sta $0335,x	_VCLoop:sta 	HashTableBase,x
.01991c	e8		inx				inx
.01991d	e0 60		cpx #$60			cpx 	#HashTableEnd-HashTableBase
.01991f	d0 f8		bne $019919			bne 	_VCLoop
.019921	a9 00		lda #$00			lda 	#VariableMemory & $FF
.019923	8d 02 03	sta $0302			sta 	VarMemPtr
.019926	a9 30		lda #$30			lda 	#VariableMemory >> 8
.019928	8d 03 03	sta $0303			sta 	VarMemPtr+1
.01992b	fa		plx				plx 							; restore registers
.01992c	68		pla				pla
.01992d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/extract.asm

.01992e					VariableNameError:
.01992e	20 6e 85	jsr $01856e			jsr ERR_Handler
>019931	42 61 64 20 56 61 72 69			.text "Bad Variable Name",0
>019939	61 62 6c 65 20 4e 61 6d 65 00
.019943					VariableExtract:
.019943	da		phx				phx 							; save X.
.019944	a9 ba		lda #$ba			lda 	#token_hashlParen  		; set the type to #( e.g. real array.
.019946	8d 95 03	sta $0395			sta 	Var_Type
.019949	8d 96 03	sta $0396			sta 	Var_Hash 				; we initialise the hash with this. It doesn't matter
.01994c	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01994e	c9 00		cmp #$00			cmp 	#0 						; first one must be A-Z
.019950	f0 dc		beq $01992e			beq 	VariableNameError
.019952	c9 1b		cmp #$1b			cmp 	#26+1
.019954	b0 d8		bcs $01992e			bcs 	VariableNameError
.019956	a2 ff		ldx #$ff			ldx 	#255 					; now copy it into the variable buffer.
.019958					_VECopyBuffer:
.019958	e8		inx				inx
.019959	e0 1f		cpx #$1f			cpx 	#31 					; too long
.01995b	f0 d1		beq $01992e			beq 	VariableNameError
.01995d	9d 15 03	sta $0315,x			sta 	Var_Buffer,x 			; save character
.019960	18		clc				clc  							; update the hash value for it.
.019961	6d 96 03	adc $0396			adc 	Var_Hash
.019964	8d 96 03	sta $0396			sta 	Var_Hash
.019967	c8		iny				iny
.019968	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01996a	c9 00		cmp #$00			cmp 	#0 						; zero or token, end of variable
.01996c	f0 0e		beq $01997c			beq 	_VECopyEnd
.01996e	30 0c		bmi $01997c			bmi 	_VECopyEnd
.019970	c9 1b		cmp #$1b			cmp 	#26+1 					; A-Z continue copying
.019972	90 e4		bcc $019958			bcc 	_VECopyBuffer
.019974	c9 30		cmp #$30			cmp 	#"0" 					; 0-9 copy as well.
.019976	90 04		bcc $01997c			bcc 	_VECopyEnd
.019978	c9 3a		cmp #$3a			cmp 	#"9"+1
.01997a	90 dc		bcc $019958			bcc 	_VECopyBuffer
.01997c					_VECopyEnd:
.01997c	c8		iny				iny
.01997d	c9 b7		cmp #$b7			cmp 	#token_Dollar 			; first type token.
.01997f	90 04		bcc $019985			bcc 	_VEDefaultRequired
.019981	c9 bd		cmp #$bd			cmp 	#token_PercentLParen+1	; last type token.
.019983	90 0b		bcc $019990			bcc 	_VEHaveType
.019985					_VEDefaultRequired:
.019985	c9 bd		cmp #$bd			cmp 	#token_LParen 			; if it ends in ( then use the real array
.019987	f0 04		beq $01998d			beq 	_VESetType 				; default set above.
.019989	ce 95 03	dec $0395			dec 	Var_Type 				; this changes that default to the variable default
.01998c	88		dey				dey
.01998d					_VESetType:
.01998d	ad 95 03	lda $0395			lda 	Var_Type 				; get type ....
.019990					_VEHaveType:
.019990	8d 95 03	sta $0395			sta 	Var_Type 				; save as type.
.019993	bd 15 03	lda $0315,x			lda 	Var_Buffer,x 			; set bit 7 of name, marks the end.
.019996	09 80		ora #$80			ora 	#$80
.019998	9d 15 03	sta $0315,x			sta 	Var_Buffer,x
.01999b	e8		inx				inx 							; offset 3 => length 4.
.01999c	8e 97 03	stx $0397			stx 	Var_Length 				; save length of variable name.
.01999f	ad 95 03	lda $0395			lda 	Var_Type 				; get offset of var type from first type token
.0199a2	38		sec				sec
.0199a3	e9 b7		sbc #$b7			sbc 	#token_Dollar
.0199a5	0a		asl a				asl 	a 						; multiply by 16. This requires HashTableSize
.0199a6	0a		asl a				asl 	a 						; in data.asm to be 8 (8 sets of links,2 bytes each)
.0199a7	0a		asl a				asl 	a
.0199a8	0a		asl a				asl 	a
.0199a9	8d 98 03	sta $0398			sta 	Var_HashAddress
.0199ac	ad 96 03	lda $0396			lda 	Var_Hash 				; get the hash
.0199af	29 07		and #$07			and 	#(HashTableSize-1) 		; force into range 0-tableSize-1
.0199b1	0a		asl a				asl 	a 						; double it (2 bytes per entry) & clears carry
.0199b2	6d 98 03	adc $0398			adc 	Var_HashAddress 		; add table offset.
.0199b5	69 35		adc #$35			adc 	#HashTableBase & $FF 	; now the low byte of the actual table address
.0199b7	8d 98 03	sta $0398			sta 	Var_HashAddress
.0199ba	a2 05		ldx #$05			ldx 	#5 						; hash is 5 bytes (real)
.0199bc	ad 95 03	lda $0395			lda 	Var_Type
.0199bf	c9 b9		cmp #$b9			cmp 	#token_Hash
.0199c1	f0 07		beq $0199ca			beq 	_VEHaveSize
.0199c3	ca		dex				dex
.0199c4	c9 bb		cmp #$bb			cmp 	#token_Percent 			; percent is 4 bytes (integer)
.0199c6	f0 02		beq $0199ca			beq 	_VEHaveSize
.0199c8	a2 02		ldx #$02			ldx 	#2 						; everything else is two.
.0199ca					_VEHaveSize:
.0199ca	8e 99 03	stx $0399			stx 	Var_DataSize
.0199cd	fa		plx				plx
.0199ce	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varcreate.asm

.0199cf					VariableCreate:
.0199cf	da		phx				phx
.0199d0	5a		phy				phy
.0199d1	ad 02 03	lda $0302			lda 	VarMemPtr 					; get address of next free into zTemp1
.0199d4	85 10		sta $10				sta 	zTemp1
.0199d6	ad 03 03	lda $0303			lda 	VarMemPtr+1
.0199d9	85 11		sta $11				sta 	zTemp1+1
.0199db	ad 99 03	lda $0399			lda 	Var_DataSize 				; bytes for the data bit
.0199de	18		clc				clc
.0199df	6d 97 03	adc $0397			adc 	Var_Length 					; add the length of the name
.0199e2	69 03		adc #$03			adc 	#3 							; 3 for the link and the hash.
.0199e4	6d 02 03	adc $0302			adc 	VarMemPtr 					; add to variable memory pointer
.0199e7	8d 02 03	sta $0302			sta 	VarMemPtr
.0199ea	90 03		bcc $0199ef			bcc 	_VCNoCarry
.0199ec	ee 03 03	inc $0303			inc 	VarMemPtr+1
.0199ef					_VCNoCarry:
.0199ef	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.0199f2	85 12		sta $12				sta 	zTemp2
.0199f4	a9 03		lda #$03			lda 	#HashTableBase >> 8
.0199f6	85 13		sta $13				sta 	zTemp2+1
.0199f8	a0 00		ldy #$00			ldy 	#0 							; put current hash link in position.
.0199fa	b1 12		lda ($12),y			lda 	(zTemp2),y
.0199fc	91 10		sta ($10),y			sta 	(zTemp1),y
.0199fe	c8		iny				iny
.0199ff	b1 12		lda ($12),y			lda 	(zTemp2),y
.019a01	91 10		sta ($10),y			sta 	(zTemp1),y
.019a03	c8		iny				iny
.019a04	ad 96 03	lda $0396			lda 	Var_Hash 					; write the hash out.
.019a07	91 10		sta ($10),y			sta 	(zTemp1),y
.019a09	c8		iny				iny
.019a0a	a2 00		ldx #$00			ldx 	#0 							; copy the name out.
.019a0c					_VCCopyName:
.019a0c	bd 15 03	lda $0315,x			lda 	Var_Buffer,x
.019a0f	91 10		sta ($10),y			sta 	(zTemp1),y
.019a11	e8		inx				inx
.019a12	c8		iny				iny
.019a13	ec 97 03	cpx $0397			cpx 	Var_Length
.019a16	d0 f4		bne $019a0c			bne 	_VCCopyName
.019a18	5a		phy				phy 								; save the data offset.
.019a19	ae 99 03	ldx $0399			ldx 	Var_DataSize 				; and write the data out.
.019a1c	a9 00		lda #$00			lda 	#0 							; which is all zeroes.
.019a1e					_VCClearData:
.019a1e	91 10		sta ($10),y			sta 	(zTemp1),y
.019a20	c8		iny				iny
.019a21	ca		dex				dex
.019a22	d0 fa		bne $019a1e			bne 	_VCClearData
.019a24	68		pla				pla 								; offset to the data
.019a25	18		clc				clc
.019a26	65 10		adc $10				adc 	zTemp1 						; add to start and save as data pointer.
.019a28	85 22		sta $22				sta 	zVarDataPtr
.019a2a	a5 11		lda $11				lda 	zTemp1+1
.019a2c	69 00		adc #$00			adc 	#0
.019a2e	85 23		sta $23				sta 	zVarDataPtr+1
.019a30	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.019a33	85 24		sta $24				sta 	zVarType
.019a35	a5 10		lda $10				lda 	zTemp1 						; fix hash link to point to new record
.019a37	a0 00		ldy #$00			ldy 	#0
.019a39	91 12		sta ($12),y			sta 	(zTemp2),y
.019a3b	c8		iny				iny
.019a3c	a5 11		lda $11				lda 	zTemp1+1
.019a3e	91 12		sta ($12),y			sta 	(zTemp2),y
.019a40	ad 95 03	lda $0395			lda 	Var_Type 					; array ? if so create the empty one.
.019a43	29 01		and #$01			and 	#1
.019a45	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.019a47	d0 0e		bne $019a57			bne 	_VCNotArray
.019a49	a2 00		ldx #$00			ldx 	#0 							; call recursive array creator
.019a4b	20 f1 9a	jsr $019af1			jsr 	ArrayCreate
.019a4e	5a		phy				phy 								; save YA at zVarDataPtr
.019a4f	a0 00		ldy #$00			ldy 	#0
.019a51	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019a53	c8		iny				iny
.019a54	68		pla				pla
.019a55	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019a57					_VCNotArray:
.019a57	7a		ply				ply
.019a58	fa		plx				plx
.019a59	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arrayidx.asm

.019a5a					ArrayIndexFollow:
.019a5a	5a		phy				phy
.019a5b	a0 00		ldy #$00			ldy 	#0 							; make zVarDataPtr point to the array.
.019a5d	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; e.g. it points to itself.
.019a5f	48		pha				pha
.019a60	c8		iny				iny
.019a61	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019a63	85 23		sta $23				sta 	zVarDataPtr+1
.019a65	68		pla				pla
.019a66	85 22		sta $22				sta 	zVarDataPtr
.019a68	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; MSB of 16 bit integer and bytes 2&3
.019a6a	29 80		and #$80			and 	#$80 						; must be zero.
.019a6c	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019a6e	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019a70	d0 59		bne $019acb			bne 	_AIFError
.019a72	a0 00		ldy #$00			ldy 	#0 							; calculate size - current - 1
.019a74	18		clc				clc
.019a75	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019a77	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.019a79	c8		iny				iny
.019a7a	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019a7c	08		php				php 								; clear bit 7 retaining borrow.
.019a7d	29 7f		and #$7f			and 	#$7F
.019a7f	28		plp				plp
.019a80	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.019a82	90 47		bcc $019acb			bcc 	_AIFError 					; eror if size-current < 0
.019a84	b5 80		lda $80,x			lda  	XS_Mantissa+0,x 			; copy and double the index
.019a86	0a		asl a				asl 	a 							; (e.g. index * 2)
.019a87	85 10		sta $10				sta 	zTemp1
.019a89	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019a8b	2a		rol a				rol 	a
.019a8c	85 11		sta $11				sta 	zTemp1+1
.019a8e	a0 01		ldy #$01			ldy 	#1 							; is this a data entry.
.019a90	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; if so, then type is unchanged, offset set
.019a92	30 1d		bmi $019ab1			bmi 	_AIFCalculate
.019a94	c6 24		dec $24				dec 	zVarType 					; converts from an array to a type.
.019a96	a5 24		lda $24				lda 	zVarType 					; check that type
.019a98	c9 b7		cmp #$b7			cmp 	#token_Dollar 				; if string, use x 2
.019a9a	f0 15		beq $019ab1			beq 	_AIFCalculate
.019a9c	06 10		asl $10				asl 	zTemp1			 			; double the index
.019a9e	26 11		rol $11				rol 	zTemp1+1					; (e.g. index * 4)
.019aa0	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if integer, use x 4
.019aa2	f0 0d		beq $019ab1			beq 	_AIFCalculate
.019aa4	18		clc				clc 								; add the original mantissa in again
.019aa5	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; which makes it x5, for float.
.019aa7	65 10		adc $10				adc 	zTemp1
.019aa9	85 10		sta $10				sta 	zTemp1
.019aab	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019aad	65 11		adc $11				adc 	zTemp1+1
.019aaf	85 11		sta $11				sta 	zTemp1+1
.019ab1					_AIFCalculate:
.019ab1	18		clc				clc 								; add index x 2,4 or 5 to base
.019ab2	a5 22		lda $22				lda 	zVarDataPtr
.019ab4	65 10		adc $10				adc 	zTemp1
.019ab6	85 22		sta $22				sta 	zVarDataPtr
.019ab8	a5 23		lda $23				lda 	zVarDataPtr+1
.019aba	65 11		adc $11				adc 	zTemp1+1
.019abc	85 23		sta $23				sta 	zVarDataPtr+1
.019abe	18		clc				clc 								; add 2 more for the length prefix.
.019abf	a5 22		lda $22				lda 	zVarDataPtr
.019ac1	69 02		adc #$02			adc 	#2
.019ac3	85 22		sta $22				sta 	zVarDataPtr
.019ac5	90 02		bcc $019ac9			bcc 	_AIFNoBump
.019ac7	e6 23		inc $23				inc 	zVarDataPtr+1
.019ac9					_AIFNoBump:
.019ac9	7a		ply				ply
.019aca	60		rts				rts
.019acb					_AIFError:
.019acb	20 6e 85	jsr $01856e			jsr ERR_Handler
>019ace	42 61 64 20 61 72 72 61			.text "Bad array index",0
>019ad6	79 20 69 6e 64 65 78 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arraydef.asm

.019ade					ArrayResetDefault:
.019ade	a9 0b		lda #$0b			lda 	#11 						; 0..10 one array
.019ae0	8d a9 03	sta $03a9			sta 	ArrayDef+0
.019ae3	a9 00		lda #$00			lda 	#0
.019ae5	8d aa 03	sta $03aa			sta 	ArrayDef+1
.019ae8	a9 ff		lda #$ff			lda 	#$FF
.019aea	8d ab 03	sta $03ab			sta 	ArrayDef+2 					; $FFFF implies no second element.
.019aed	8d ac 03	sta $03ac			sta 	ArrayDef+3					; (test bit 7 of 2nd byte)
.019af0	60		rts				rts
.019af1					ArrayCreate:
.019af1	bd a9 03	lda $03a9,x			lda 	ArrayDef+0,x 				; put size x 2 in zTemp1
.019af4	0a		asl a				asl 	a
.019af5	85 10		sta $10				sta 	zTemp1
.019af7	bd aa 03	lda $03aa,x			lda 	ArrayDef+1,x
.019afa	2a		rol a				rol 	a
.019afb	85 11		sta $11				sta 	zTemp1+1
.019afd	bd ac 03	lda $03ac,x			lda 	ArrayDef+3,x 				; if this is the last element it's array of ptrs.
.019b00	10 22		bpl $019b24			bpl 	_ACSized 					; if not multiply size x 2 (str) 4 (int) 5 (real)
.019b02	ad 95 03	lda $0395			lda 	Var_Type 					; check the type
.019b05	c9 b8		cmp #$b8			cmp 	#token_DollarLParen 		; also if it is an array of strings $(
.019b07	f0 1b		beq $019b24			beq 	_ACSized
.019b09	06 10		asl $10				asl 	zTemp1 						; double again
.019b0b	26 11		rol $11				rol 	zTemp1+1
.019b0d	b0 6f		bcs $019b7e			bcs 	ArrayIndexError 			; too large.
.019b0f	c9 bc		cmp #$bc			cmp 	#token_PercentLParen 		; if %( four bytes/entry is enough.
.019b11	f0 11		beq $019b24			beq 	_ACSized
.019b13	18		clc				clc 								; add original value x 5 for reals.
.019b14	a5 10		lda $10				lda 	zTemp1
.019b16	7d a9 03	adc $03a9,x			adc 	ArrayDef+0,x
.019b19	85 10		sta $10				sta 	zTemp1
.019b1b	a5 11		lda $11				lda 	zTemp1+1
.019b1d	7d aa 03	adc $03aa,x			adc 	ArrayDef+1,x
.019b20	85 11		sta $11				sta 	zTemp1+1
.019b22	b0 5a		bcs $019b7e			bcs 	ArrayIndexError
.019b24					_ACSized:
.019b24	18		clc				clc
.019b25	a5 10		lda $10				lda 	zTemp1
.019b27	69 02		adc #$02			adc 	#2
.019b29	85 10		sta $10				sta 	zTemp1
.019b2b	90 04		bcc $019b31			bcc 	_ACNoBump
.019b2d	e6 10		inc $10				inc 	zTemp1
.019b2f	f0 4d		beq $019b7e			beq 	ArrayIndexError
.019b31					_ACNoBump:
.019b31	18		clc				clc
.019b32	ad 02 03	lda $0302			lda 	VarMemPtr 					; add this allocated count to VarMemPtr
.019b35	85 12		sta $12				sta 	zTemp2						; save start in zTemp2/zTemp3
.019b37	85 14		sta $14				sta 	zTemp3
.019b39	65 10		adc $10				adc 	zTemp1
.019b3b	8d 02 03	sta $0302			sta 	VarMemPtr
.019b3e	ad 03 03	lda $0303			lda 	VarMemPtr+1
.019b41	85 13		sta $13				sta 	zTemp2+1
.019b43	85 15		sta $15				sta 	zTemp3+1
.019b45	65 11		adc $11				adc 	zTemp1+1
.019b47	8d 03 03	sta $0303			sta 	VarMemPtr+1
.019b4a	85 11		sta $11				sta 	zTemp1+1
.019b4c	b0 30		bcs $019b7e			bcs 	ArrayIndexError
.019b4e	a0 00		ldy #$00			ldy 	#0							; write $00 out.
.019b50					_ACClear:
.019b50	98		tya				tya
.019b51	91 12		sta ($12),y			sta 	(zTemp2),y
.019b53	e6 12		inc $12				inc 	zTemp2
.019b55	d0 02		bne $019b59			bne 	_ACCBump
.019b57	e6 13		inc $13				inc 	zTemp2+1
.019b59					_ACCBump:
.019b59	a5 12		lda $12				lda 	zTemp2
.019b5b	cd 02 03	cmp $0302			cmp 	VarMemPtr
.019b5e	d0 f0		bne $019b50			bne 	_ACClear
.019b60	a5 13		lda $13				lda 	zTemp2+1
.019b62	cd 03 03	cmp $0303			cmp 	VarMemPtr+1
.019b65	d0 e9		bne $019b50			bne 	_ACClear
.019b67	a0 00		ldy #$00			ldy 	#0
.019b69	bd a9 03	lda $03a9,x			lda 	ArrayDef+0,x 				; copy the size into the start
.019b6c	91 14		sta ($14),y			sta 	(zTemp3),y
.019b6e	c8		iny				iny
.019b6f	bd aa 03	lda $03aa,x			lda 	ArrayDef+1,x
.019b72	91 14		sta ($14),y			sta 	(zTemp3),y
.019b74	bd ac 03	lda $03ac,x			lda 	ArrayDef+3,x 				; have we reached the end
.019b77	10 18		bpl $019b91			bpl 	ACCFillRecursive
.019b79	a4 15		ldy $15				ldy 	zTemp3+1 					; return address
.019b7b	a5 14		lda $14				lda 	zTemp3
.019b7d	60		rts				rts
.019b7e					ArrayIndexError:
.019b7e	20 6e 85	jsr $01856e			jsr ERR_Handler
>019b81	42 61 64 20 61 72 72 61			.text "Bad array index",0
>019b89	79 20 69 6e 64 65 78 00
.019b91					ACCFillRecursive:
.019b91	a9 ff		lda #$ff			lda 	#$FF 						; we mark the end, this is free space.
.019b93	a0 00		ldy #$00			ldy 	#0 							; this is overwritten by size of next allocated
.019b95	91 12		sta ($12),y			sta 	(zTemp2),y 					; array, but we might change that.
.019b97	c8		iny				iny
.019b98	b1 14		lda ($14),y			lda 	(zTemp3),y 					; set bit 15 of the max index indicating
.019b9a	09 80		ora #$80			ora 	#$80 						; an array of pointers
.019b9c	91 14		sta ($14),y			sta 	(zTemp3),y
.019b9e	a5 14		lda $14				lda 	zTemp3 						; push the start on the stack
.019ba0	48		pha				pha
.019ba1	a5 15		lda $15				lda 	zTemp3+1
.019ba3	48		pha				pha
.019ba4					_ACCFillLoop:
.019ba4	18		clc				clc
.019ba5	a5 14		lda $14				lda 	zTemp3 						; and work forwards.
.019ba7	69 02		adc #$02			adc 	#2
.019ba9	85 14		sta $14				sta 	zTemp3
.019bab	90 02		bcc $019baf			bcc 	_ACCSkip2
.019bad	e6 15		inc $15				inc 	zTemp3+1
.019baf					_ACCSkip2:
.019baf	a0 00		ldy #$00			ldy 	#0 							; reached the end ?
.019bb1	b1 14		lda ($14),y			lda 	(zTemp3),y					; (looking for FF marker, everything else 00)
.019bb3	c8		iny				iny
.019bb4	11 14		ora ($14),y			ora 	(zTemp3),y
.019bb6	d0 21		bne $019bd9			bne 	_ACCExit
.019bb8	a5 14		lda $14				lda 	zTemp3 						; push zTemp3
.019bba	48		pha				pha
.019bbb	a5 15		lda $15				lda 	zTemp3+1
.019bbd	48		pha				pha
.019bbe	e8		inx				inx
.019bbf	e8		inx				inx
.019bc0	20 f1 9a	jsr $019af1			jsr 	ArrayCreate 				; create array recursively.
.019bc3	ca		dex				dex
.019bc4	ca		dex				dex
.019bc5	85 12		sta $12				sta 	zTemp2 						; save A
.019bc7	68		pla				pla
.019bc8	85 15		sta $15				sta 	zTemp3+1 					; restore zTemp3
.019bca	68		pla				pla
.019bcb	85 14		sta $14				sta 	zTemp3
.019bcd	98		tya				tya 								; write high bye from Y
.019bce	a0 01		ldy #$01			ldy 	#1
.019bd0	91 14		sta ($14),y			sta 	(zTemp3),y
.019bd2	88		dey				dey 								; write low byte out.
.019bd3	a5 12		lda $12				lda 	zTemp2
.019bd5	91 14		sta ($14),y			sta 	(zTemp3),y
.019bd7	80 cb		bra $019ba4			bra 	_ACCFillLoop 				; and try again.
.019bd9					_ACCExit:
.019bd9	7a		ply				ply 								; restore the original address
.019bda	68		pla				pla
.019bdb	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varfind.asm

.019bdc					VariableLocate:
.019bdc	da		phx				phx
.019bdd	5a		phy				phy
.019bde	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.019be1	85 12		sta $12				sta 	zTemp2 						; points to first address.
.019be3	a9 03		lda #$03			lda 	#HashTableBase >> 8
.019be5	85 13		sta $13				sta 	zTemp2+1
.019be7	a0 00		ldy #$00	_VLNext:ldy 	#0 							; get next link into AX
.019be9	b1 12		lda ($12),y			lda 	(zTemp2),y
.019beb	aa		tax				tax
.019bec	c8		iny				iny
.019bed	b1 12		lda ($12),y			lda 	(zTemp2),y
.019bef	85 13		sta $13				sta 	zTemp2+1 					; save in zTemp
.019bf1	86 12		stx $12				stx 	zTemp2
.019bf3	05 12		ora $12				ora 	zTemp2 						; got zero
.019bf5	18		clc				clc
.019bf6	f0 25		beq $019c1d			beq 	_VLExit 					; if so, then fail as end of chain.
.019bf8	c8		iny				iny 								; point to hash (offset + 2)
.019bf9	b1 12		lda ($12),y			lda 	(zTemp2),y
.019bfb	cd 96 03	cmp $0396			cmp 	Var_Hash
.019bfe	d0 e7		bne $019be7			bne 	_VLNext 					; try next if different.
.019c00					_VLCompare:
.019c00	c8		iny				iny 								; next character
.019c01	b1 12		lda ($12),y			lda 	(zTemp2),y 					; compare variable field against buffer.
.019c03	d9 12 03	cmp $0312,y			cmp 	Var_Buffer-3,y 				; the -3 is because name starts at 3.
.019c06	d0 df		bne $019be7			bne 	_VLNext 					; fail if different, try next.
.019c08	0a		asl a				asl 	a 							; until end character (bit 7 set) matched
.019c09	90 f5		bcc $019c00			bcc 	_VLCompare
.019c0b	98		tya				tya
.019c0c	38		sec				sec 								; add 1 as Y points to last character
.019c0d	65 12		adc $12				adc 	zTemp2 						; add to the current address
.019c0f	85 22		sta $22				sta 	zVarDataPtr
.019c11	a5 13		lda $13				lda 	zTemp2+1
.019c13	69 00		adc #$00			adc 	#0
.019c15	85 23		sta $23				sta 	zVarDataPtr+1
.019c17	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.019c1a	85 24		sta $24				sta 	zVarType
.019c1c	38		sec				sec 								; return CS
.019c1d	7a		ply		_VLExit:ply
.019c1e	fa		plx				plx
.019c1f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/vargetset.asm

.019c20					VariableGet:
.019c20	5a		phy				phy
.019c21	a0 00		ldy #$00			ldy 	#0 							; copy first two bytes
.019c23	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019c25	95 80		sta $80,x			sta 	XS_Mantissa,x
.019c27	c8		iny				iny
.019c28	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019c2a	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019c2c	c8		iny				iny
.019c2d	a5 24		lda $24				lda 	zVarType 					; if it is a string, set up for that.
.019c2f	c9 b7		cmp #$b7			cmp 	#token_Dollar
.019c31	f0 2c		beq $019c5f			beq 	_VGString
.019c33	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; copy the next two bytes.
.019c35	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019c37	c8		iny				iny
.019c38	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019c3a	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019c3c	c8		iny				iny
.019c3d	a9 01		lda #$01			lda 	#1 							; set type to 1.
.019c3f	95 85		sta $85,x			sta 	XS_Type,x
.019c41	a5 24		lda $24				lda 	zVarType
.019c43	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if it is a %, then exit with default integer.
.019c45	f0 28		beq $019c6f			beq 	_VGExit
.019c47	a9 40		lda #$40			lda 	#$40 						; set type byte to zero
.019c49	95 85		sta $85,x			sta 	XS_Type,x 					; which is the code for zero/float.
.019c4b	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; the last value to copy is the exponent.
.019c4d	95 84		sta $84,x			sta 	XS_Exponent,x
.019c4f	f0 1e		beq $019c6f			beq 	_VGExit 					; if exponent is zero ... it's zero.
.019c51	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; the sign bit is the top mantissa bit.
.019c53	48		pha				pha
.019c54	29 80		and #$80			and 	#$80
.019c56	95 85		sta $85,x			sta 	XS_Type,x 					; this is the type byte.
.019c58	68		pla				pla
.019c59	09 80		ora #$80			ora 	#$80 						; set the MSB as you would expect.
.019c5b	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; so it's a normalised float.
.019c5d	80 10		bra $019c6f			bra 	_VGExit
.019c5f					_VGString:
.019c5f	a9 02		lda #$02			lda 	#2 							; set type to 2, a string
.019c61	95 85		sta $85,x			sta 	XS_Type,x
.019c63	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; is the value there $0000
.019c65	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019c67	d0 06		bne $019c6f			bne 	_VGExit 					; if not, exit.
.019c69	85 25		sta $25				sta 	zNullString 				; make zNullString a 00 string.
.019c6b	a9 25		lda #$25			lda 	#zNullString
.019c6d	95 80		sta $80,x			sta 	XS_Mantissa,x 				; make it point to it.
.019c6f					_VGExit:
.019c6f	7a		ply				ply
.019c70	60		rts				rts
.019c71					VariableSet:
.019c71	b5 85		lda $85,x			lda 	XS_Type,x 					; is the result a string
.019c73	29 02		and #$02			and 	#2 							; if so, it has to be
.019c75	d0 4b		bne $019cc2			bne 	_VSString
.019c77	a5 24		lda $24				lda 	zVarType 					; if type is $ there's an error.
.019c79	c9 b7		cmp #$b7			cmp 	#token_Dollar
.019c7b	f0 42		beq $019cbf			beq 	_VSBadType
.019c7d	c9 bb		cmp #$bb			cmp 	#token_Percent 				; type convert to float/int
.019c7f	f0 05		beq $019c86			beq 	_VSMakeInt
.019c81	20 e7 a1	jsr $01a1e7			jsr 	FPUToFloat
.019c84	80 03		bra $019c89			bra 	_VSCopy
.019c86					_VSMakeInt:
.019c86	20 33 a2	jsr $01a233			jsr 	FPUToInteger
.019c89					_VSCopy:
.019c89	5a		phy				phy
.019c8a	a0 00		ldy #$00			ldy 	#0 							; copy mantissa to target.
.019c8c	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019c8e	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019c90	c8		iny				iny
.019c91	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019c93	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019c95	c8		iny				iny
.019c96	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019c98	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019c9a	c8		iny				iny
.019c9b	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019c9d	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019c9f	a5 24		lda $24				lda 	zVarType 					; if target is integer, alrady done.
.019ca1	c9 bb		cmp #$bb			cmp 	#token_Percent
.019ca3	f0 18		beq $019cbd			beq 	_VSExit
.019ca5	b5 85		lda $85,x			lda 	XS_Type,x 					; get the sign bit into carry flag.
.019ca7	0a		asl a				asl 	a
.019ca8	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; shift the sign into the mantissa high.
.019caa	08		php				php
.019cab	0a		asl a				asl 	a
.019cac	28		plp				plp
.019cad	6a		ror a				ror 	a
.019cae	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019cb0	c8		iny				iny
.019cb1	b5 84		lda $84,x			lda 	XS_Exponent,x 				; copy the exponent in
.019cb3	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019cb5	34 85		bit $85,x			bit 	XS_Type,x 					; if the result is non zero
.019cb7	50 04		bvc $019cbd			bvc 	_VSExit
.019cb9	a9 00		lda #$00			lda 	#00 						; zero exponent indicating 0.
.019cbb	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019cbd					_VSExit:
.019cbd	7a		ply				ply
.019cbe	60		rts				rts
.019cbf					_VSBadType:
.019cbf	4c 4f 85	jmp $01854f			jmp 	TypeError
.019cc2					_VSString:
.019cc2	a5 24		lda $24				lda 	zVarType 					; type must be $
.019cc4	c9 b7		cmp #$b7			cmp 	#token_Dollar
.019cc6	d0 f7		bne $019cbf			bne 	_VSBadType
.019cc8	da		phx				phx
.019cc9	5a		phy				phy
.019cca	20 47 98	jsr $019847			jsr 	StringConcrete 				; concrete the string in the mantissa -> AX
.019ccd	a0 01		ldy #$01			ldy 	#1 							; save high byte
.019ccf	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019cd1	88		dey				dey 								; save low byte
.019cd2	8a		txa				txa
.019cd3	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019cd5	7a		ply				ply 								; and exit.
.019cd6	fa		plx				plx
.019cd7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.019cd8					MulInteger32:
.019cd8	b5 80		lda $80,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.019cda	95 8c		sta $8c,x			sta 	XS3_Mantissa,x
.019cdc	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019cde	95 8d		sta $8d,x			sta 	XS3_Mantissa+1,x
.019ce0	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019ce2	95 8e		sta $8e,x			sta 	XS3_Mantissa+2,x
.019ce4	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019ce6	95 8f		sta $8f,x			sta 	XS3_Mantissa+3,x
.019ce8	a9 00		lda #$00			lda 	#0
.019cea	95 80		sta $80,x			sta 	XS_Mantissa+0,x 				; zero +0
.019cec	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019cee	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019cf0	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019cf2					_BFMMultiply:
.019cf2	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.019cf4	29 01		and #$01			and 	#1
.019cf6	f0 03		beq $019cfb			beq 	_BFMNoAdd
.019cf8	20 93 93	jsr $019393			jsr 	AddInteger32
.019cfb					_BFMNoAdd:
.019cfb	16 86		asl $86,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.019cfd	36 87		rol $87,x			rol 	XS2_Mantissa+1,x
.019cff	36 88		rol $88,x			rol 	XS2_Mantissa+2,x
.019d01	36 89		rol $89,x			rol 	XS2_Mantissa+3,x
.019d03	56 8f		lsr $8f,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.019d05	76 8e		ror $8e,x			ror 	XS3_Mantissa+2,x
.019d07	76 8d		ror $8d,x			ror 	XS3_Mantissa+1,x
.019d09	76 8c		ror $8c,x			ror 	XS3_Mantissa,x
.019d0b	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.019d0d	15 8d		ora $8d,x			ora 	XS3_Mantissa+1,x
.019d0f	15 8e		ora $8e,x			ora 	XS3_Mantissa+2,x
.019d11	15 8f		ora $8f,x			ora 	XS3_Mantissa+3,x
.019d13	d0 dd		bne $019cf2			bne 	_BFMMultiply
.019d15	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.019d16					DivInteger32:
.019d16	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; check for /0
.019d18	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.019d1a	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.019d1c	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.019d1e	d0 14		bne $019d34			bne 	_BFDOkay
.019d20	20 6e 85	jsr $01856e			jsr ERR_Handler
>019d23	44 69 76 69 73 69 6f 6e			.text "Division by Zero",0
>019d2b	20 62 79 20 5a 65 72 6f 00
.019d34					_BFDOkay:
.019d34	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.019d36	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.019d38	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.019d3a	85 1c		sta $1c				sta 	zLTemp1+2
.019d3c	85 1d		sta $1d				sta 	zLTemp1+3
.019d3e	8d 9e 03	sta $039e			sta 	SignCount 					; Count of signs.
.019d41	20 98 9d	jsr $019d98			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.019d44	da		phx				phx
.019d45	e8		inx				inx
.019d46	e8		inx				inx
.019d47	e8		inx				inx
.019d48	e8		inx				inx
.019d49	e8		inx				inx
.019d4a	e8		inx				inx
.019d4b	20 98 9d	jsr $019d98			jsr 	CheckIntegerNegate
.019d4e	fa		plx				plx
.019d4f	5a		phy				phy 								; Y is the counter
.019d50	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.019d52					_BFDLoop:
.019d52	16 80		asl $80,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.019d54	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.019d56	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.019d58	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.019d5a	26 1a		rol $1a				rol 	zLTemp1
.019d5c	26 1b		rol $1b				rol 	zLTemp1+1
.019d5e	26 1c		rol $1c				rol 	zLTemp1+2
.019d60	26 1d		rol $1d				rol 	zLTemp1+3
.019d62	38		sec				sec
.019d63	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.019d65	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.019d67	48		pha				pha
.019d68	a5 1b		lda $1b				lda 	zLTemp1+1
.019d6a	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.019d6c	48		pha				pha
.019d6d	a5 1c		lda $1c				lda 	zLTemp1+2
.019d6f	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.019d71	48		pha				pha
.019d72	a5 1d		lda $1d				lda 	zLTemp1+3
.019d74	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.019d76	90 13		bcc $019d8b			bcc 	_BFDNoAdd
.019d78	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.019d7a	68		pla				pla
.019d7b	85 1c		sta $1c				sta 	zLTemp1+2
.019d7d	68		pla				pla
.019d7e	85 1b		sta $1b				sta 	zLTemp1+1
.019d80	68		pla				pla
.019d81	85 1a		sta $1a				sta 	zLTemp1+0
.019d83	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.019d85	09 01		ora #$01			ora 	#1
.019d87	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019d89	80 03		bra $019d8e			bra 	_BFDNext
.019d8b					_BFDNoAdd:
.019d8b	68		pla				pla 								; Throw away the intermediate calculations
.019d8c	68		pla				pla
.019d8d	68		pla				pla
.019d8e					_BFDNext:
.019d8e	88		dey				dey
.019d8f	d0 c1		bne $019d52			bne 	_BFDLoop
.019d91	7a		ply				ply 								; restore Y and exit
.019d92	4e 9e 03	lsr $039e			lsr 	SignCount 					; if sign count odd,
.019d95	b0 06		bcs $019d9d			bcs		IntegerNegateAlways 			; negate the result
.019d97	60		rts				rts
.019d98					CheckIntegerNegate:
.019d98	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019d9a	30 01		bmi $019d9d			bmi 	IntegerNegateAlways
.019d9c	60		rts				rts
.019d9d					IntegerNegateAlways:
.019d9d	ee 9e 03	inc $039e			inc 	SignCount
.019da0	38		sec				sec
.019da1	a9 00		lda #$00			lda 	#0
.019da3	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.019da5	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019da7	a9 00		lda #$00			lda 	#0
.019da9	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.019dab	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019dad	a9 00		lda #$00			lda 	#0
.019daf	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.019db1	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019db3	a9 00		lda #$00			lda 	#0
.019db5	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.019db7	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019db9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.019dba					INTToString:
.019dba	48		pha				pha
.019dbb	5a		phy				phy
.019dbc	b5 83		lda $83,x			lda 		XS_Mantissa+3,x 		; check -ve
.019dbe	10 08		bpl $019dc8			bpl 		_ITSNotMinus
.019dc0	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.019dc2	20 5c 9e	jsr $019e5c			jsr 		ITSOutputCharacter
.019dc5	20 9d 9d	jsr $019d9d			jsr 		IntegerNegateAlways 	; negate the number.
.019dc8					_ITSNotMinus:
.019dc8	a9 00		lda #$00			lda 		#0
.019dca	8d 9a 03	sta $039a			sta 		NumSuppress 			; clear the suppression flag.
.019dcd	8a		txa				txa 								; use Y for the mantissa index.
.019dce	a8		tay				tay
.019dcf	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.019dd1					_ITSNextSubtractor:
.019dd1	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.019dd3	8d 9b 03	sta $039b			sta 		NumConvCount
.019dd6					_ITSSubtract:
.019dd6	38		sec				sec
.019dd7	b9 80 00	lda $0080,y			lda 		XS_Mantissa,y 			; subtract number and push on stack
.019dda	ff 38 9e 01	sbc $019e38,x			sbc 		_ITSSubtractors+0,x
.019dde	48		pha				pha
.019ddf	b9 81 00	lda $0081,y			lda 		XS_Mantissa+1,y
.019de2	ff 39 9e 01	sbc $019e39,x			sbc 		_ITSSubtractors+1,x
.019de6	48		pha				pha
.019de7	b9 82 00	lda $0082,y			lda 		XS_Mantissa+2,y
.019dea	ff 3a 9e 01	sbc $019e3a,x			sbc 		_ITSSubtractors+2,x
.019dee	48		pha				pha
.019def	b9 83 00	lda $0083,y			lda 		XS_Mantissa+3,y
.019df2	ff 3b 9e 01	sbc $019e3b,x			sbc 		_ITSSubtractors+3,x
.019df6	90 14		bcc $019e0c			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.019df8	99 83 00	sta $0083,y			sta 		XS_Mantissa+3,y 		; save subtract off stack
.019dfb	68		pla				pla
.019dfc	99 82 00	sta $0082,y			sta 		XS_Mantissa+2,y
.019dff	68		pla				pla
.019e00	99 81 00	sta $0081,y			sta 		XS_Mantissa+1,y
.019e03	68		pla				pla
.019e04	99 80 00	sta $0080,y			sta 		XS_Mantissa+0,y
.019e07	ee 9b 03	inc $039b			inc 		NumConvCount 			; bump count.
.019e0a	80 ca		bra $019dd6			bra 		_ITSSubtract 			; go round again.
.019e0c					_ITSCantSubtract:
.019e0c	68		pla				pla 								; throw away interim answers
.019e0d	68		pla				pla
.019e0e	68		pla				pla
.019e0f	ad 9b 03	lda $039b			lda 		NumConvCount 			; if not zero then no suppression check
.019e12	c9 30		cmp #$30			cmp 		#"0"
.019e14	d0 05		bne $019e1b			bne 		_ITSOutputDigit
.019e16	ad 9a 03	lda $039a			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.019e19	10 09		bpl $019e24			bpl	 		_ITSGoNextSubtractor
.019e1b					_ITSOutputDigit:
.019e1b	ce 9a 03	dec $039a			dec 		NumSuppress 			; suppression check will be non-zero.
.019e1e	ad 9b 03	lda $039b			lda 		NumConvCount 			; count of subtractions
.019e21	20 5c 9e	jsr $019e5c			jsr 		ITSOutputCharacter 		; output it.
.019e24					_ITSGoNextSubtractor:
.019e24	e8		inx				inx 								; next dword
.019e25	e8		inx				inx
.019e26	e8		inx				inx
.019e27	e8		inx				inx
.019e28	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.019e2a	d0 a5		bne $019dd1			bne 		_ITSNextSubtractor 		; do all the subtractors.
.019e2c	98		tya				tya 								; X is back as the mantissa index
.019e2d	aa		tax				tax
.019e2e	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.019e30	09 30		ora #$30			ora 		#"0"
.019e32	20 5c 9e	jsr $019e5c			jsr 		ITSOutputCharacter
.019e35	7a		ply				ply 								; and exit
.019e36	68		pla				pla
.019e37	60		rts				rts
.019e38					_ITSSubtractors:
>019e38	00 ca 9a 3b					.dword 		1000000000
>019e3c	00 e1 f5 05					.dword 		100000000
>019e40	80 96 98 00					.dword 		10000000
>019e44	40 42 0f 00					.dword 		1000000
>019e48	a0 86 01 00					.dword 		100000
>019e4c	10 27 00 00					.dword 		10000
>019e50	e8 03 00 00					.dword 		1000
>019e54	64 00 00 00					.dword 		100
>019e58	0a 00 00 00					.dword 		10
.019e5c					_ITSSubtractorsEnd:
.019e5c					ITSOutputCharacter:
.019e5c	48		pha				pha
.019e5d	da		phx				phx
.019e5e	ae 14 03	ldx $0314			ldx 	NumBufX 					; save digit
.019e61	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.019e64	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.019e66	9d 16 03	sta $0316,x			sta 	Num_Buffer+1,x
.019e69	ee 14 03	inc $0314			inc 	NumBufX						; bump pointer.
.019e6c	fa		plx				plx
.019e6d	68		pla				pla
.019e6e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.019e6f					IntFromString:
.019e6f	a0 00		ldy #$00			ldy 	#0
.019e71	8c 9c 03	sty $039c			sty 	ExpTemp 					; this is the converted digit count.
.019e74					IntFromStringY:
.019e74	48		pha				pha
.019e75	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.019e77	95 80		sta $80,x			sta 	XS_Mantissa,x
.019e79	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019e7b	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019e7d	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019e7f	a9 01		lda #$01			lda 	#1
.019e81	95 85		sta $85,x			sta 	XS_Type,x
.019e83					_IFSLoop:
.019e83	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.019e85	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.019e87	90 4e		bcc $019ed7			bcc 	_IFSExit
.019e89	c9 3a		cmp #$3a			cmp 	#"9"+1
.019e8b	b0 4a		bcs $019ed7			bcs 	_IFSExit
.019e8d	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.019e8f	c9 0c		cmp #$0c			cmp 	#12
.019e91	b0 4e		bcs $019ee1			bcs 	_IFSOverflow
.019e93	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.019e95	48		pha				pha
.019e96	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019e98	48		pha				pha
.019e99	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019e9b	48		pha				pha
.019e9c	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019e9e	48		pha				pha
.019e9f	20 f6 9e	jsr $019ef6			jsr 	IFSX1ShiftLeft 				; double
.019ea2	20 f6 9e	jsr $019ef6			jsr 	IFSX1ShiftLeft 				; x 4
.019ea5	18		clc				clc 								; add saved value x 5
.019ea6	68		pla				pla
.019ea7	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.019ea9	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019eab	68		pla				pla
.019eac	75 81		adc $81,x			adc 	XS_Mantissa+1,x
.019eae	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019eb0	68		pla				pla
.019eb1	75 82		adc $82,x			adc 	XS_Mantissa+2,x
.019eb3	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019eb5	68		pla				pla
.019eb6	75 83		adc $83,x			adc 	XS_Mantissa+3,x
.019eb8	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019eba	20 f6 9e	jsr $019ef6			jsr 	IFSX1ShiftLeft 				; x 10
.019ebd	ee 9c 03	inc $039c			inc 	ExpTemp 					; bump count of digits processed.
.019ec0	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.019ec2	29 0f		and #$0f			and 	#15
.019ec4	c8		iny				iny
.019ec5	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.019ec7	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019ec9	90 b8		bcc $019e83			bcc 	_IFSLoop
.019ecb	f6 81		inc $81,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.019ecd	d0 b4		bne $019e83			bne 	_IFSLoop
.019ecf	f6 82		inc $82,x			inc 	XS_Mantissa+2,x
.019ed1	d0 b0		bne $019e83			bne 	_IFSLoop
.019ed3	f6 83		inc $83,x			inc 	XS_Mantissa+3,x
.019ed5	80 ac		bra $019e83			bra 	_IFSLoop
.019ed7					_IFSExit:
.019ed7	98		tya				tya 								; get offset
.019ed8					_IFSOkay:
.019ed8	38		sec				sec
.019ed9	ad 9c 03	lda $039c			lda 	ExpTemp
.019edc	f0 01		beq $019edf			beq 	_IFSSkipFail
.019ede	18		clc				clc
.019edf					_IFSSkipFail:
.019edf	68		pla				pla 								; and exit.
.019ee0	60		rts				rts
.019ee1					_IFSOverflow:
.019ee1	20 6e 85	jsr $01856e			jsr 	ERR_Handler
>019ee4	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>019eec	20 6f 76 65 72 66 6c 6f 77 00
.019ef6					IFSX1ShiftLeft:
.019ef6	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.019ef8	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.019efa	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.019efc	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.019efe	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.019eff					FPSubtract:
.019eff	48		pha				pha
.019f00	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.019f02	49 80		eor #$80			eor 	#$80
.019f04	95 8b		sta $8b,x			sta 	XS2_Type,x
.019f06	68		pla				pla 								; --- and fall through ---
.019f07					FPAdd:
.019f07	48		pha				pha
.019f08	b5 85		lda $85,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.019f0a	d0 05		bne $019f11			bne 	_FPA_NegativeLHS
.019f0c	20 28 9f	jsr $019f28			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.019f0f	68		pla				pla
.019f10	60		rts				rts
.019f11					_FPA_NegativeLHS:
.019f11	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.019f13	49 80		eor #$80			eor 	#$80
.019f15	95 85		sta $85,x			sta 	XS_Type,x
.019f17	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of B and add
.019f19	49 80		eor #$80			eor 	#$80
.019f1b	95 8b		sta $8b,x			sta 	XS2_Type,x
.019f1d	20 28 9f	jsr $019f28			jsr 	FPAdd_Worker 				; do the add calculation.
.019f20	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 back
.019f22	49 80		eor #$80			eor 	#$80
.019f24	95 85		sta $85,x			sta 	XS_Type,x
.019f26	68		pla				pla
.019f27	60		rts				rts
.019f28					FPAdd_Worker:
.019f28	34 8b		bit $8b,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.019f2a	70 07		bvs $019f33			bvs 	_FPAWExit 					; no change.
.019f2c	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.019f2e	50 07		bvc $019f37			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.019f30	20 a5 a1	jsr $01a1a5			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.019f33					_FPAWExit:
.019f33	20 14 a2	jsr $01a214			jsr 	FPUNormalise 				; normalise the result.
.019f36	60		rts				rts
.019f37					_FPAWMakeSame:
.019f37	b5 84		lda $84,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.019f39	38		sec				sec
.019f3a	f5 8a		sbc $8a,x			sbc	 	XS2_Exponent,x 				; using subtraction
.019f3c	f0 16		beq $019f54			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.019f3e	da		phx				phx 								; save X
.019f3f	90 06		bcc $019f47			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.019f41	e8		inx				inx
.019f42	e8		inx				inx
.019f43	e8		inx				inx
.019f44	e8		inx				inx
.019f45	e8		inx				inx
.019f46	e8		inx				inx
.019f47					_FPAWShiftA:
.019f47	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.019f49	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.019f4b	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.019f4d	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.019f4f	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.019f51	fa		plx				plx 								; restore original X
.019f52	80 e3		bra $019f37			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.019f54					_FPAW_DoArithmetic:
.019f54	34 8b		bit $8b,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.019f56	30 28		bmi $019f80			bmi 	_FPAW_BNegative
.019f58	18		clc				clc
.019f59	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019f5b	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.019f5d	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019f5f	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019f61	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.019f63	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019f65	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019f67	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.019f69	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019f6b	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019f6d	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.019f6f	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019f71	90 c0		bcc $019f33			bcc 	_FPAWExit 					; no carry.
.019f73	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.019f75	38		sec				sec
.019f76	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.019f78	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.019f7a	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.019f7c	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.019f7e	80 b3		bra $019f33			bra 	_FPAWExit
.019f80					_FPAW_BNegative:
.019f80	38		sec				sec
.019f81	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019f83	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.019f85	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019f87	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019f89	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.019f8b	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019f8d	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019f8f	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.019f91	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019f93	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019f95	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.019f97	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019f99	b0 09		bcs $019fa4			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.019f9b	20 cb a1	jsr $01a1cb			jsr 	FPUNegateInteger			; negate the mantissa
.019f9e	b5 85		lda $85,x			lda 	XS_Type,x 					; flip result sign
.019fa0	49 80		eor #$80			eor 	#$80
.019fa2	95 85		sta $85,x			sta 	XS_Type,x
.019fa4					_FPAWGoExit:
.019fa4	4c 33 9f	jmp $019f33			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.019fa7					FPD_IsDivZero:
.019fa7	20 6e 85	jsr $01856e			jsr ERR_Handler
>019faa	44 69 76 69 73 69 6f 6e			.text "Division by zero",0
>019fb2	20 62 79 20 7a 65 72 6f 00
.019fbb					FPDivide:
.019fbb	48		pha				pha
.019fbc	5a		phy				phy
.019fbd	34 8b		bit $8b,x			bit 	XS2_Type,x 					; check if division by zero
.019fbf	70 e6		bvs $019fa7			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.019fc1	34 85		bit $85,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.019fc3	f0 03		beq $019fc8			beq 	_FPDCalculateExp
.019fc5					_FPD_Exit:
.019fc5	7a		ply				ply
.019fc6	68		pla				pla
.019fc7	60		rts				rts
.019fc8					_FPDCalculateExp:
.019fc8	b5 8a		lda $8a,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.019fca	49 ff		eor #$ff			eor 	#$FF
.019fcc	1a		inc a				inc 	a
.019fcd	95 8a		sta $8a,x			sta 	XS2_Exponent,x
.019fcf	20 9f a0	jsr $01a09f			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.019fd2	18		clc				clc 	 							; add 1 to the resulting exponent
.019fd3	69 01		adc #$01			adc 	#1
.019fd5	b0 54		bcs $01a02b			bcs 	_FPD_Overflow 				; which can overflow.
.019fd7	95 84		sta $84,x			sta 	XS_Exponent,x
.019fd9	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.019fdb	85 1a		sta $1a				sta 	zLTemp1+0
.019fdd	85 1b		sta $1b				sta 	zLTemp1+1
.019fdf	85 1c		sta $1c				sta 	zLTemp1+2
.019fe1	85 1d		sta $1d				sta 	zLTemp1+3
.019fe3	a0 20		ldy #$20			ldy 	#32 						; times round.
.019fe5					_FPD_Loop:
.019fe5	38		sec				sec 								; calculate X1-X2 stacking result because we might
.019fe6	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; not save it.
.019fe8	f5 86		sbc $86,x			sbc 	XS2_Mantissa,x
.019fea	48		pha				pha
.019feb	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019fed	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.019fef	48		pha				pha
.019ff0	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019ff2	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.019ff4	48		pha				pha
.019ff5	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019ff7	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.019ff9	90 13		bcc $01a00e			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.019ffb	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; save results out to A
.019ffd	68		pla				pla
.019ffe	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a000	68		pla				pla
.01a001	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a003	68		pla				pla
.01a004	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a006	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.01a008	09 80		ora #$80			ora 	#$80
.01a00a	85 1d		sta $1d				sta 	zLTemp1+3
.01a00c	80 03		bra $01a011			bra 	_FPD_Rotates
.01a00e					_FPD_NoSubtract:
.01a00e	68		pla				pla 								; throw away unwanted results
.01a00f	68		pla				pla
.01a010	68		pla				pla
.01a011					_FPD_Rotates:
.01a011	56 89		lsr $89,x			lsr 	3+XS2_Mantissa,x
.01a013	76 88		ror $88,x			ror 	2+XS2_Mantissa,x
.01a015	76 87		ror $87,x			ror 	1+XS2_Mantissa,x
.01a017	76 86		ror $86,x			ror 	0+XS2_Mantissa,x
.01a019	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.01a01b	26 1b		rol $1b				rol 	zLTemp1+1
.01a01d	26 1c		rol $1c				rol 	zLTemp1+2
.01a01f	26 1d		rol $1d				rol 	zLTemp1+3
.01a021	90 02		bcc $01a025			bcc 	_FPD_NoCarry
.01a023	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.01a025					_FPD_NoCarry:
.01a025	88		dey				dey 								; do 32 times
.01a026	d0 bd		bne $019fe5			bne 	_FPD_Loop
.01a028	4c 83 a0	jmp $01a083			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.01a02b					_FPD_Overflow:
.01a02b	4c 71 a2	jmp $01a271			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.01a02e					FPMultiply:
.01a02e	48		pha				pha
.01a02f	5a		phy				phy
.01a030	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.01a032	70 07		bvs $01a03b			bvs 	_FPM_Exit
.01a034	34 8b		bit $8b,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.01a036	50 06		bvc $01a03e			bvc 	_FPM_CalcExponent
.01a038	20 a5 a1	jsr $01a1a5			jsr 	FPUCopyX2ToX1
.01a03b					_FPM_Exit:
.01a03b	7a		ply				ply
.01a03c	68		pla				pla
.01a03d	60		rts				rts
.01a03e					_FPM_CalcExponent:
.01a03e	18		clc				clc
.01a03f	20 9f a0	jsr $01a09f			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.01a042	95 84		sta $84,x			sta 	XS_Exponent,x 				; save the result.
.01a044	a9 00		lda #$00			lda 	#0
.01a046	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.01a048	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.01a04a	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.01a04c	85 1d		sta $1d				sta 	zLTemp1+3
.01a04e	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.01a050					_FPM_Loop:
.01a050	b5 80		lda $80,x			lda 	XS_Mantissa,x				; check LSB of long product
.01a052	29 01		and #$01			and 	#1
.01a054	18		clc				clc 								; clear carry for the long rotate.
.01a055	f0 19		beq $01a070			beq 	_FPM_NoAddition
.01a057	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.01a058	a5 1a		lda $1a				lda 	zLTemp1+0
.01a05a	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.01a05c	85 1a		sta $1a				sta 	zLTemp1+0
.01a05e	a5 1b		lda $1b				lda 	zLTemp1+1
.01a060	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.01a062	85 1b		sta $1b				sta 	zLTemp1+1
.01a064	a5 1c		lda $1c				lda 	zLTemp1+2
.01a066	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.01a068	85 1c		sta $1c				sta 	zLTemp1+2
.01a06a	a5 1d		lda $1d				lda 	zLTemp1+3
.01a06c	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.01a06e	85 1d		sta $1d				sta 	zLTemp1+3
.01a070					_FPM_NoAddition:
.01a070	66 1d		ror $1d				ror 	3+zLTemp1
.01a072	66 1c		ror $1c				ror 	2+zLTemp1
.01a074	66 1b		ror $1b				ror 	1+zLTemp1
.01a076	66 1a		ror $1a				ror 	0+zLTemp1
.01a078	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.01a07a	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a07c	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a07e	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a080	88		dey				dey
.01a081	d0 cd		bne $01a050			bne 	_FPM_Loop 					; do this 32 times.
.01a083					FPM_CopySignNormalize:
.01a083	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.01a085	95 80		sta $80,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.01a087	a5 1b		lda $1b				lda 	zLTemp1+1
.01a089	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a08b	a5 1c		lda $1c				lda 	zLTemp1+2
.01a08d	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a08f	a5 1d		lda $1d				lda 	zLTemp1+3
.01a091	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a093	b5 85		lda $85,x			lda 	XS_Type,x 					; sign is xor of signs
.01a095	55 8b		eor $8b,x			eor 	XS2_Type,x
.01a097	95 85		sta $85,x			sta 	XS_Type,x
.01a099	20 14 a2	jsr $01a214			jsr 	FPUNormalise 				; normalise and exit.
.01a09c	7a		ply				ply
.01a09d	68		pla				pla
.01a09e	60		rts				rts
.01a09f					FPCalculateExponent:
.01a09f	18		clc				clc
.01a0a0	b5 84		lda $84,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.01a0a2	75 8a		adc $8a,x			adc 	XS2_Exponent,x
.01a0a4	b0 08		bcs $01a0ae			bcs 	_FPCECarry 					; carry out ?
.01a0a6	10 03		bpl $01a0ab			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.01a0a8	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.01a0aa	60		rts				rts
.01a0ab					_FPCEExpZero:
.01a0ab	a9 00		lda #$00			lda 	#0
.01a0ad	60		rts				rts
.01a0ae					_FPCECarry:
.01a0ae	30 03		bmi $01a0b3			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.01a0b0	09 80		ora #$80			ora 	#$80 						; put in right range
.01a0b2	60		rts				rts
.01a0b3					_FPCEOverflow:
.01a0b3	4c 71 a2	jmp $01a271			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.01a0b6					FPFractionalPart:
.01a0b6	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.01a0b8	38		sec				sec 								; this flag tells us to keep the fractional part
.01a0b9	30 0d		bmi $01a0c8			bmi 	FPGetPart
.01a0bb	60		rts				rts
.01a0bc					FPIntegerPart:
.01a0bc	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.01a0be	18		clc				clc 								; this flag says keep the integer part.
.01a0bf	30 07		bmi $01a0c8			bmi 	FPGetPart 					; -ve exponents are 0..127
.01a0c1	48		pha				pha
.01a0c2	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.01a0c4	95 85		sta $85,x			sta 	XS_Type,x
.01a0c6	68		pla				pla
.01a0c7	60		rts				rts
.01a0c8					FPGetPart:
.01a0c8	48		pha				pha
.01a0c9	5a		phy				phy 								; save Y
.01a0ca	08		php				php 								; save action
.01a0cb	34 85		bit $85,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.01a0cd	70 59		bvs $01a128			bvs 	_FPGP_Exit 					; then do nothing.
.01a0cf	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.01a0d1	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.01a0d3	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.01a0d5	85 1c		sta $1c				sta 	zLTemp1+2
.01a0d7	85 1d		sta $1d				sta 	zLTemp1+3
.01a0d9	b5 84		lda $84,x			lda 	XS_Exponent,x				; the number of shifts.
.01a0db	38		sec				sec
.01a0dc	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.01a0de	f0 12		beq $01a0f2			beq 	_FPGP_NoShift 				; ... if any
.01a0e0	c9 20		cmp #$20			cmp 	#32
.01a0e2	90 02		bcc $01a0e6			bcc 	_FPGP_NotMax
.01a0e4	a9 20		lda #$20			lda 	#32 						; max of 32.
.01a0e6					_FPGP_NotMax:
.01a0e6	a8		tay				tay 								; Y is the mask shift count.
.01a0e7					_FPGP_ShiftMask:
.01a0e7	46 1d		lsr $1d				lsr 	3+zLTemp1
.01a0e9	66 1c		ror $1c				ror 	2+zLTemp1
.01a0eb	66 1b		ror $1b				ror 	1+zLTemp1
.01a0ed	66 1a		ror $1a				ror 	0+zLTemp1
.01a0ef	88		dey				dey
.01a0f0	d0 f5		bne $01a0e7			bne 	_FPGP_ShiftMask
.01a0f2					_FPGP_NoShift:
.01a0f2	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.01a0f4	8e 9c 03	stx $039c			stx 	ExpTemp						; save X
.01a0f7					_FPGP_MaskLoop:
.01a0f7	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.01a0fa	28		plp				plp 								; if CC we keep the top part, so we
.01a0fb	08		php				php		 							; flip the mask.
.01a0fc	b0 02		bcs $01a100			bcs		_FPGP_NoFlip
.01a0fe	49 ff		eor #$ff			eor 	#$FF
.01a100					_FPGP_NoFlip:
.01a100	35 80		and $80,x			and 	XS_Mantissa,x 				; and into the mantissa.
.01a102	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a104	e8		inx				inx
.01a105	c8		iny				iny
.01a106	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.01a108	d0 ed		bne $01a0f7			bne 	_FPGP_MaskLoop
.01a10a	ae 9c 03	ldx $039c			ldx 	ExpTemp						; restore X
.01a10d	28		plp				plp
.01a10e	08		php				php 								; get action flag on the stack
.01a10f	90 04		bcc $01a115			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.01a111	a9 00		lda #$00			lda 	#0
.01a113	95 85		sta $85,x			sta 	XS_Type,x
.01a115					_FPGP_NotFractional:
.01a115	b5 80		lda $80,x			lda 	XS_Mantissa,x 						; check if \1 zero
.01a117	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.01a119	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01a11b	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01a11d	f0 05		beq $01a124			beq 	_FPGP_Zero 					; if zero, return zero
.01a11f	20 14 a2	jsr $01a214			jsr 	FPUNormalise
.01a122	80 04		bra $01a128			bra 	_FPGP_Exit 					; and exit
.01a124					_FPGP_Zero:
.01a124	a9 40		lda #$40			lda 	#$40 						; set zero flag
.01a126	95 85		sta $85,x			sta 	XS_Type,x
.01a128					_FPGP_Exit:
.01a128	68		pla				pla 								; throw saved action flag.
.01a129	7a		ply				ply
.01a12a	68		pla				pla
.01a12b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.01a12c					FPCompare:
.01a12c	20 6d a1	jsr $01a16d			jsr 	FPFastCompare 				; fast compare try first
.01a12f	b0 3b		bcs $01a16c			bcs 	_FPCExit 					; that worked.
.01a131	b5 84		lda $84,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.01a133	48		pha				pha
.01a134	b5 8a		lda $8a,x			lda 	XS2_Exponent,x
.01a136	48		pha				pha
.01a137	20 ff 9e	jsr $019eff			jsr 	FPSubtract 					; calculate X1-X2
.01a13a	34 85		bit $85,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.01a13c	70 2a		bvs $01a168			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.01a13e	68		pla				pla
.01a13f	8d 9c 03	sta $039c			sta 	ExpTemp						; save first exponent in temporary reg.
.01a142	68		pla				pla
.01a143	38		sec				sec
.01a144	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; calculate AX-BX
.01a147	70 14		bvs $01a15d			bvs 	_FPCNotEqual				; overflow, can't be equal.
.01a149	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.01a14a	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.01a14c	b0 0f		bcs $01a15d			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.01a14e	38		sec				sec
.01a14f	ad 9c 03	lda $039c			lda 	ExpTemp 					; get one of the exponents back.
.01a152	e9 12		sbc #$12			sbc 	#18 						; allow for 2^18 error, relatively.
.01a154	b0 02		bcs $01a158			bcs 	_FPCNotRange 				; keep in range.
.01a156	a9 01		lda #$01			lda 	#1
.01a158					_FPCNotRange:
.01a158	38		sec				sec
.01a159	f5 84		sbc $84,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.01a15b	b0 0d		bcs $01a16a			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.01a15d					_FPCNotEqual:
.01a15d	b5 85		lda $85,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.01a15f	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.01a161	f0 02		beq $01a165			beq 	_FPCNE2
.01a163	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.01a165	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.01a166	80 04		bra $01a16c			bra 	_FPCExit
.01a168					_FPCPullZero:
.01a168	68		pla				pla 								; throw saved exponents
.01a169	68		pla				pla
.01a16a					_FPCZero:
.01a16a	a9 00		lda #$00			lda 	#0 							; and return zero
.01a16c					_FPCExit:
.01a16c	60		rts				rts
.01a16d					FPFastCompare:
.01a16d	34 85		bit $85,x			bit 	XS_Type,x 					; n1 is zero.
.01a16f	70 23		bvs $01a194			bvs 	_FPFLeftZero
.01a171	34 8b		bit $8b,x			bit 	XS2_Type,x 					; n2 is zero
.01a173	b5 85		lda $85,x			lda 	XS_Type,x 					; if so, return sign bit of 1 (n-0)
.01a175	70 25		bvs $01a19c			bvs 	_FPFSignBit
.01a177	55 8b		eor $8b,x			eor 	XS2_Type,x 					; eor 2 type bits. now know both non-zero
.01a179	0a		asl a				asl 	a 							; put in CS if different.
.01a17a	b5 85		lda $85,x			lda 	XS_Type,x 					; if signs different return sign of first
.01a17c	b0 1e		bcs $01a19c			bcs 	_FPFSignBit
.01a17e	38		sec				sec 								; same sign and not-zero. compare exponents
.01a17f	b5 84		lda $84,x			lda 	XS_Exponent,x 				; compare exponents. if the same, then fail.
.01a181	f5 8a		sbc $8a,x			sbc 	XS2_Exponent,x 				; e.g. we have to do it via subtraction.
.01a183	f0 09		beq $01a18e			beq 	_FPNoFastCompare
.01a185	6a		ror a				ror 	a 							; put carry into bit 7.
.01a186	34 85		bit $85,x			bit 	XS_Type,X 					; if it is +x then flip it.
.01a188	30 02		bmi $01a18c			bmi		_FPFCNotMinus
.01a18a	49 80		eor #$80			eor 	#$80
.01a18c					_FPFCNotMinus:
.01a18c	80 0e		bra $01a19c			bra		_FPFSignBit
.01a18e					_FPNoFastCompare:
.01a18e	18		clc				clc
.01a18f	60		rts				rts
.01a190					_FPFZero:
.01a190	a9 00		lda #$00			lda 	#0
.01a192					_FPFExitSet:
.01a192	38		sec				sec
.01a193	60		rts				rts
.01a194					_FPFLeftZero:
.01a194	34 8b		bit $8b,x			bit 	XS2_Type,x 					; if right is zero, return zero.
.01a196	70 f8		bvs $01a190			bvs 	_FPFZero
.01a198	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip sign bit
.01a19a	49 80		eor #$80			eor 	#$80						; return that as a sign.
.01a19c					_FPFSignBit:
.01a19c	0a		asl a				asl 	a
.01a19d	a9 01		lda #$01			lda 	#1
.01a19f	90 f1		bcc $01a192			bcc		_FPFExitSet
.01a1a1	a9 ff		lda #$ff			lda 	#$FF
.01a1a3	38		sec				sec
.01a1a4	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.01a1a5					FPUCopyX2ToX1:
.01a1a5	48		pha				pha
.01a1a6	da		phx				phx
.01a1a7	5a		phy				phy
.01a1a8	a0 08		ldy #$08			ldy 	#8
.01a1aa	b5 86		lda $86,x	_FPUC21:lda 	XS2_Mantissa,x
.01a1ac	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a1ae	e8		inx				inx
.01a1af	88		dey				dey
.01a1b0	10 f8		bpl $01a1aa			bpl 	_FPUC21
.01a1b2	7a		ply				ply
.01a1b3	fa		plx				plx
.01a1b4	68		pla				pla
.01a1b5	60		rts				rts
.01a1b6					FPUSetInteger:
.01a1b6	48		pha				pha
.01a1b7	95 80		sta $80,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.01a1b9	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.01a1bb	10 02		bpl $01a1bf			bpl 	_FPUSIExtend
.01a1bd	a9 ff		lda #$ff			lda 	#$FF
.01a1bf					_FPUSIExtend:
.01a1bf	95 81		sta $81,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.01a1c1	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a1c3	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a1c5	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.01a1c7	95 85		sta $85,x			sta 	XS_Type,x
.01a1c9	68		pla				pla
.01a1ca	60		rts				rts
.01a1cb					FPUNegateInteger:
.01a1cb	48		pha				pha
.01a1cc	38		sec				sec
.01a1cd	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.01a1cf	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.01a1d1	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a1d3	a9 00		lda #$00			lda 	#0
.01a1d5	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.01a1d7	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a1d9	a9 00		lda #$00			lda 	#0
.01a1db	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.01a1dd	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a1df	a9 00		lda #$00			lda 	#0
.01a1e1	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.01a1e3	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a1e5	68		pla				pla
.01a1e6	60		rts				rts
.01a1e7					FPUToFloat:
.01a1e7	48		pha				pha
.01a1e8	b5 85		lda $85,x			lda 	XS_Type,x					; exit if already float.
.01a1ea	29 0f		and #$0f			and 	#$0F
.01a1ec	f0 24		beq $01a212			beq 	_FPUFExit
.01a1ee	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.01a1f0	95 85		sta $85,x			sta 	XS_Type,x
.01a1f2	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.01a1f4	95 84		sta $84,x			sta 	XS_Exponent,x 				; x mantissa.
.01a1f6	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.01a1f8	10 07		bpl $01a201			bpl		_FPUFPositive
.01a1fa	20 cb a1	jsr $01a1cb			jsr 	FPUNegateInteger 			; negate the mantissa
.01a1fd	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.01a1ff	95 85		sta $85,x			sta 	XS_Type,x
.01a201					_FPUFPositive:
.01a201	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.01a203	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.01a205	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01a207	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01a209	d0 04		bne $01a20f			bne 	_FPUFNonZero
.01a20b	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.01a20d	95 85		sta $85,x			sta 	XS_Type,x
.01a20f					_FPUFNonZero:
.01a20f	20 14 a2	jsr $01a214			jsr 	FPUNormalise 				; normalise the floating point.
.01a212					_FPUFExit:
.01a212	68		pla				pla
.01a213	60		rts				rts
.01a214					FPUNormalise:
.01a214	48		pha				pha
.01a215	34 85		bit $85,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.01a217	70 18		bvs $01a231			bvs 	_FPUNExit
.01a219	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.01a21b	f0 10		beq $01a22d			beq 	_FPUNSetZero
.01a21d					_FPUNLoop:
.01a21d	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.01a21f	30 10		bmi $01a231			bmi 	_FPUNExit 					; if so, we are normalised.
.01a221	16 80		asl $80,x			asl 	0+XS_Mantissa+0,x
.01a223	36 81		rol $81,x			rol 	1+XS_Mantissa+0,x
.01a225	36 82		rol $82,x			rol 	2+XS_Mantissa+0,x
.01a227	36 83		rol $83,x			rol 	3+XS_Mantissa+0,x
.01a229	d6 84		dec $84,x			dec 	XS_Exponent,x 				; decrement exponent
.01a22b	d0 f0		bne $01a21d			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.01a22d					_FPUNSetZero:
.01a22d	a9 40		lda #$40			lda 	#$40
.01a22f	95 85		sta $85,x			sta 	XS_Type,x 					; the result is now zero.
.01a231					_FPUNExit:
.01a231	68		pla				pla
.01a232	60		rts				rts
.01a233					FPUToInteger:
.01a233	48		pha				pha
.01a234	b5 85		lda $85,x			lda 	XS_Type,x 					; if already integer, exit
.01a236	29 01		and #$01			and 	#1
.01a238	d0 31		bne $01a26b			bne 	_FPUTOI_Exit
.01a23a	34 85		bit $85,x			bit 	XS_Type,x					; if zero, return zero.
.01a23c	70 23		bvs $01a261			bvs 	_FPUTOI_Zero
.01a23e	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.01a240	10 1f		bpl $01a261			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.01a242	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.01a244	b0 2b		bcs $01a271			bcs 	FP_Overflow
.01a246					_FPUToIToInteger:
.01a246	b5 84		lda $84,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.01a248	c9 a0		cmp #$a0			cmp 	#128+32
.01a24a	f0 0c		beq $01a258			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.01a24c	f6 84		inc $84,x			inc 	XS_Exponent,X 				; increment Exponent
.01a24e	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.01a250	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a252	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a254	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a256	80 ee		bra $01a246			bra 	_FPUToIToInteger 			; keep going.
.01a258					_FPUToICheckSign:
.01a258	b5 85		lda $85,x			lda 	XS_Type,x 					; check sign
.01a25a	10 0f		bpl $01a26b			bpl 	_FPUToI_Exit 				; exit if unsigned.
.01a25c	20 cb a1	jsr $01a1cb			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.01a25f	80 0a		bra $01a26b			bra 	_FPUTOI_Exit
.01a261					_FPUTOI_Zero:
.01a261	a9 00		lda #$00			lda 	#0 							; return zero integer.
.01a263	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a265	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a267	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a269	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a26b					_FPUToI_Exit:
.01a26b	a9 01		lda #$01			lda 	#1 							; set type to integer
.01a26d	95 85		sta $85,x			sta 	XS_Type,x
.01a26f	68		pla				pla
.01a270	60		rts				rts
.01a271					FP_Overflow:
.01a271	20 6e 85	jsr $01856e			jsr ERR_Handler
>01a274	46 6c 6f 61 74 69 6e 67			.text "Floating Point overflow",0
>01a27c	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.01a28c					FPUTimes10:
.01a28c	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.01a28e	85 1a		sta $1a				sta 	ZLTemp1+0
.01a290	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a292	85 1b		sta $1b				sta 	ZLTemp1+1
.01a294	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a296	85 1c		sta $1c				sta 	ZLTemp1+2
.01a298	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a29a	85 1d		sta $1d				sta 	ZLTemp1+3
.01a29c	20 d1 a2	jsr $01a2d1			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.01a29f	20 d1 a2	jsr $01a2d1			jsr 	_FPUT_LSR_ZLTemp1
.01a2a2	18		clc				clc
.01a2a3	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.01a2a5	65 1a		adc $1a				adc 	ZLTemp1+0
.01a2a7	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a2a9	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a2ab	65 1b		adc $1b				adc 	ZLTemp1+1
.01a2ad	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a2af	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a2b1	65 1c		adc $1c				adc 	ZLTemp1+2
.01a2b3	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a2b5	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a2b7	65 1d		adc $1d				adc 	ZLTemp1+3
.01a2b9	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a2bb	90 0a		bcc $01a2c7			bcc 	_FPUTimes10
.01a2bd	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.01a2bf	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a2c1	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a2c3	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a2c5	f6 84		inc $84,x			inc 	XS_Exponent,x				; fix exponent
.01a2c7					_FPUTimes10:
.01a2c7	b5 84		lda $84,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.01a2c9	18		clc				clc
.01a2ca	69 03		adc #$03			adc 	#3
.01a2cc	95 84		sta $84,x			sta 	XS_Exponent,x
.01a2ce	b0 a1		bcs $01a271			bcs 	FP_Overflow 				; error
.01a2d0	60		rts				rts
.01a2d1					_FPUT_LSR_ZLTemp1:
.01a2d1	46 1d		lsr $1d				lsr 	ZLTemp1+3
.01a2d3	66 1c		ror $1c				ror 	ZLTemp1+2
.01a2d5	66 1b		ror $1b				ror 	ZLTemp1+1
.01a2d7	66 1a		ror $1a				ror 	ZLTemp1+0
.01a2d9	60		rts				rts
.01a2da					FPUScale10A:
.01a2da	5a		phy				phy
.01a2db	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.01a2dd	f0 37		beq $01a316			beq 	_FPUScaleExit
.01a2df	da		phx				phx 								; save X
.01a2e0	e8		inx				inx
.01a2e1	e8		inx				inx
.01a2e2	e8		inx				inx
.01a2e3	e8		inx				inx
.01a2e4	e8		inx				inx
.01a2e5	e8		inx				inx
.01a2e6	a8		tay				tay 								; save power scalar in Y.
.01a2e7	a9 00		lda #$00			lda 	#0
.01a2e9	95 80		sta $80,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.01a2eb	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a2ed	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a2ef	95 85		sta $85,x			sta 	XS_Type,x
.01a2f1	a9 80		lda #$80			lda 	#$80
.01a2f3	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a2f5	a9 81		lda #$81			lda 	#$81
.01a2f7	95 84		sta $84,x			sta 	XS_Exponent,x
.01a2f9	5a		phy				phy 								; save 10^n on stack.
.01a2fa	c0 00		cpy #$00			cpy 	#0
.01a2fc	10 05		bpl $01a303			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.01a2fe	98		tya				tya
.01a2ff	49 ff		eor #$ff			eor 	#$FF
.01a301	1a		inc a				inc 	a
.01a302	a8		tay				tay
.01a303					_FPUSAbs:
.01a303	20 8c a2	jsr $01a28c			jsr 	FPUTimes10
.01a306	88		dey				dey
.01a307	d0 fa		bne $01a303			bne 	_FPUSAbs 					; tos is now 10^|AC|
.01a309	68		pla				pla 								; restore count in A
.01a30a	fa		plx				plx 								; restore X pointing to number to scale.
.01a30b	0a		asl a				asl 	a
.01a30c	b0 05		bcs $01a313			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.01a30e	20 2e a0	jsr $01a02e			jsr 	FPMultiply 					; if clear multiply.
.01a311	80 03		bra $01a316			bra		_FPUScaleExit
.01a313					_FPUSDivide:
.01a313	20 bb 9f	jsr $019fbb			jsr 	FPDivide
.01a316					_FPUScaleExit:
.01a316	7a		ply				ply
.01a317	60		rts				rts
.01a318					FPUCopyToNext:
.01a318	a0 06		ldy #$06			ldy 		#6
.01a31a	da		phx				phx
.01a31b					_FPUCopy1:
.01a31b	b5 80		lda $80,x			lda 	XS_Mantissa,x
.01a31d	95 86		sta $86,x			sta 	XS2_Mantissa,x
.01a31f	e8		inx				inx
.01a320	88		dey				dey
.01a321	d0 f8		bne $01a31b			bne 	_FPUCopy1
.01a323	fa		plx				plx
.01a324	60		rts				rts
.01a325					FPUCopyFromNext:
.01a325	a0 06		ldy #$06			ldy 		#6
.01a327	da		phx				phx
.01a328					_FPUCopy1:
.01a328	b5 86		lda $86,x			lda 	XS2_Mantissa,x
.01a32a	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a32c	e8		inx				inx
.01a32d	88		dey				dey
.01a32e	d0 f8		bne $01a328			bne 	_FPUCopy1
.01a330	fa		plx				plx
.01a331	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.01a332					FPToString:
.01a332	48		pha				pha
.01a333	5a		phy				phy
.01a334	34 85		bit $85,x			bit 		XS_Type,x 				; check zero flag
.01a336	50 0a		bvc $01a342			bvc 		_FPTSIsFloat 			; if zero,
.01a338					_FPTSZero:
.01a338	a9 30		lda #$30			lda 		#"0"
.01a33a	20 5c 9e	jsr $019e5c			jsr 		ITSOutputCharacter
.01a33d					_FPTSExit:
.01a33d	7a		ply				ply
.01a33e	68		pla				pla
.01a33f	60		rts				rts
.01a340	80 fb		bra $01a33d			bra 		_FPTSExit
.01a342					_FPTSIsFloat:
.01a342	b5 85		lda $85,x			lda 		XS_Type,x 				; is it signed ?
.01a344	10 09		bpl $01a34f			bpl 		_FPTSNotSigned
.01a346	a9 00		lda #$00			lda 		#0 						; clear sign flag
.01a348	95 85		sta $85,x			sta 		XS_Type,x
.01a34a	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.01a34c	20 5c 9e	jsr $019e5c			jsr 		ITSOutputCharacter
.01a34f					_FPTSNotSigned:
.01a34f	b5 84		lda $84,x			lda 		XS_Exponent,x
.01a351	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.01a353	b0 09		bcs $01a35e			bcs 		_FPTSExponent
.01a355	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.01a357	90 05		bcc $01a35e			bcc 		_FPTSExponent 			;
.01a359					_FPTSStandard:
.01a359	20 9d a3	jsr $01a39d			jsr 		FPTOutputBody 			; output the body.
.01a35c	80 df		bra $01a33d			bra 		_FPTSExit
.01a35e					_FPTSExponent:
.01a35e	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.01a360	8d 9d 03	sta $039d			sta 		ExpCount
.01a363					_FPTSExponentLoop:
.01a363	b5 84		lda $84,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.01a365	10 0e		bpl $01a375			bpl 		_FPTSTimes
.01a367	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.01a369	90 14		bcc $01a37f			bcc 		_FPTSScaledToExp
.01a36b	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.01a36d	20 da a2	jsr $01a2da			jsr 		FPUScale10A
.01a370	ee 9d 03	inc $039d			inc 		ExpCount
.01a373	80 ee		bra $01a363			bra 		_FPTSExponentLoop
.01a375					_FPTSTimes:
.01a375	a9 01		lda #$01			lda 		#1
.01a377	20 da a2	jsr $01a2da			jsr 		FPUScale10A
.01a37a	ce 9d 03	dec $039d			dec 		ExpCount
.01a37d	80 e4		bra $01a363			bra 		_FPTSExponentLoop
.01a37f					_FPTSScaledToExp:
.01a37f	20 9d a3	jsr $01a39d			jsr 		FPTOutputBody 			; output the body.
.01a382	a9 65		lda #$65			lda 		#"e"					; output E
.01a384	20 5c 9e	jsr $019e5c			jsr 		ITSOutputCharacter
.01a387	ad 9d 03	lda $039d			lda 		ExpCount 				; get the exponent
.01a38a	95 80		sta $80,x			sta 		XS_Mantissa,x
.01a38c	29 80		and #$80			and 		#$80 					; sign extend it
.01a38e	f0 02		beq $01a392			beq 		_FPTSSExt
.01a390	a9 ff		lda #$ff			lda 		#$FF
.01a392					_FPTSSExt:
.01a392	95 81		sta $81,x			sta 		XS_Mantissa+1,x
.01a394	95 82		sta $82,x			sta 		XS_Mantissa+2,x
.01a396	95 83		sta $83,x			sta 		XS_Mantissa+3,x
.01a398	20 ba 9d	jsr $019dba			jsr 		INTToString 			; output the exponent.
.01a39b	80 a0		bra $01a33d			bra			_FPTSExit 				; and exit.
.01a39d					FPTOutputBody:
.01a39d	20 18 a3	jsr $01a318			jsr 		FPUCopyToNext 			; copy to next slot.
.01a3a0	20 33 a2	jsr $01a233			jsr 		FPUToInteger 			; convert to an integer
.01a3a3	20 ba 9d	jsr $019dba			jsr 		INTToString 			; output the main integer part.
.01a3a6	20 25 a3	jsr $01a325			jsr 		FPUCopyFromNext 		; get the fractional part back.
.01a3a9	20 b6 a0	jsr $01a0b6			jsr 		FPFractionalPart 		; get the decimal part.
.01a3ac	34 85		bit $85,x			bit 		XS_Type,x 				; any fractional part.
.01a3ae	70 3c		bvs $01a3ec			bvs 		_FPTOExit 				; if not, exit now.
.01a3b0	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.01a3b2	20 5c 9e	jsr $019e5c			jsr 		ITSOutputCharacter
.01a3b5					_FPOutLoop:
.01a3b5	34 85		bit $85,x			bit 		XS_Type,x 				; finally reached zero.
.01a3b7	70 1d		bvs $01a3d6			bvs 		_FPStripZeros 			; strip trailing zeros
.01a3b9	20 8c a2	jsr $01a28c			jsr 		FPUTimes10 				; multiply by 10
.01a3bc	20 18 a3	jsr $01a318			jsr 		FPUCopyToNext			; copy to next slot.
.01a3bf	20 33 a2	jsr $01a233			jsr 		FPUToInteger 			; convert to integer
.01a3c2	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; print digit.
.01a3c4	09 30		ora #$30			ora 		#"0"
.01a3c6	20 5c 9e	jsr $019e5c			jsr 		ITSOutputCharacter
.01a3c9	20 25 a3	jsr $01a325			jsr 		FPUCopyFromNext 		; get it back
.01a3cc	20 b6 a0	jsr $01a0b6			jsr 		FPFractionalPart 		; get fractional part
.01a3cf	ad 14 03	lda $0314			lda 		NumBufX 				; done 11 characters yet ?
.01a3d2	c9 0b		cmp #$0b			cmp 	 	#11
.01a3d4	90 df		bcc $01a3b5			bcc 		_FPOutLoop 				; if so, keep going till zero.
.01a3d6					_FPStripZeros:
.01a3d6	ac 14 03	ldy $0314			ldy 		NumBufX 				; strip trailing zeros.
.01a3d9					_FPStripLoop:
.01a3d9	88		dey				dey 								; back one, if at start then no strip
.01a3da	f0 10		beq $01a3ec			beq 		_FPToExit
.01a3dc	b9 15 03	lda $0315,y			lda 		Num_Buffer,y 			; keep going if "0"
.01a3df	c9 30		cmp #$30			cmp 		#"0"
.01a3e1	f0 f6		beq $01a3d9			beq 		_FPStripLoop
.01a3e3	c8		iny				iny
.01a3e4	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.01a3e6	99 15 03	sta $0315,y			sta 		Num_Buffer,y
.01a3e9	8c 14 03	sty $0314			sty 		NumBufX 				; update position.
.01a3ec					_FPTOExit:
.01a3ec	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.01a3ed					FPFromString:
.01a3ed	48		pha				pha 								; push A
.01a3ee	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.01a3f0	c9 2e		cmp #$2e			cmp 	#"."
.01a3f2	f0 03		beq $01a3f7			beq	 	_FPFIsDecimal
.01a3f4	4c 53 a4	jmp $01a453			jmp 	_FPFNotDecimal
.01a3f7					_FPFIsDecimal:
.01a3f7	c8		iny				iny 								; consume the decimal.
.01a3f8	20 e7 a1	jsr $01a1e7			jsr 	FPUToFloat 					; convert the integer to float.
.01a3fb	da		phx				phx 								; save X.
.01a3fc	5a		phy				phy 								; save decimal start position
.01a3fd	e8		inx				inx
.01a3fe	e8		inx				inx
.01a3ff	e8		inx				inx
.01a400	e8		inx				inx
.01a401	e8		inx				inx
.01a402	e8		inx				inx
.01a403	20 74 9e	jsr $019e74			jsr 	INTFromStringY 				; get the part after the DP.
.01a406	20 e7 a1	jsr $01a1e7			jsr 	FPUToFloat 					; convert that to a float.
.01a409	68		pla				pla 								; calculate - chars consumed.
.01a40a	8c 9c 03	sty $039c			sty 	ExpTemp
.01a40d	38		sec				sec
.01a40e	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; this is the shift amount
.01a411	20 da a2	jsr $01a2da			jsr 	FPUScale10A 				; scale it by 10^AC
.01a414	fa		plx				plx 								; restore original X
.01a415	20 07 9f	jsr $019f07			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.01a418	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.01a41a	c9 45		cmp #$45			cmp 	#"E"
.01a41c	f0 04		beq $01a422			beq 	_FPFExponent
.01a41e	c9 65		cmp #$65			cmp 	#"e"
.01a420	d0 31		bne $01a453			bne 	_FPFNotDecimal 				; no, then exit normally.
.01a422					_FPFExponent:
.01a422	c8		iny				iny 								; skip over E symbol.
.01a423	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.01a425	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.01a427	d0 01		bne $01a42a			bne 	_FPFGotSign
.01a429	c8		iny				iny 								; if it was - skip over it.
.01a42a					_FPFGotSign:
.01a42a	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.01a42b	da		phx				phx
.01a42c	e8		inx				inx
.01a42d	e8		inx				inx
.01a42e	e8		inx				inx
.01a42f	e8		inx				inx
.01a430	e8		inx				inx
.01a431	e8		inx				inx
.01a432	20 74 9e	jsr $019e74			jsr 	INTFromStringY 				; get the exponent
.01a435	fa		plx				plx 								; restore X.
.01a436	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.01a438	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.01a43a	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.01a43c	d0 17		bne $01a455			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.01a43e	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.01a440	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.01a442	b0 11		bcs $01a455			bcs 	_FPFXOverflow
.01a444	68		pla				pla 								; get direction
.01a445	d0 07		bne $01a44e			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.01a447	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.01a449	49 ff		eor #$ff			eor 	#$FF
.01a44b	1a		inc a				inc 	a
.01a44c	95 86		sta $86,x			sta 	XS2_Mantissa+0,x
.01a44e					_FPFXScale:
.01a44e	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.01a450	20 da a2	jsr $01a2da			jsr 	FPUScale10A 				; scale by the exponent.
.01a453					_FPFNotDecimal:
.01a453	68		pla				pla
.01a454	60		rts				rts
.01a455					_FPFXOverflow:
.01a455	20 6e 85	jsr $01856e			jsr 	ERR_Handler
>01a458	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>01a460	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.01a467					Unary_Rnd:
.01a467	20 e7 91	jsr $0191e7			jsr 	EvaluateNumberX 			; get value
.01a46a	20 37 98	jsr $019837			jsr 	CheckNextRParen 			; check right bracket.
.01a46d	20 65 94	jsr $019465			jsr 	GetSignCurrent 				; get sign -1,0,1.
.01a470	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.01a472	30 10		bmi $01a484			bmi 	_URSetSeed
.01a474	f0 28		beq $01a49e			beq 	_URMakeRandom 				; if zero return same number.
.01a476	da		phx				phx
.01a477	a2 00		ldx #$00			ldx 	#0
.01a479	20 d5 a4	jsr $01a4d5			jsr 	Random16
.01a47c	a2 02		ldx #$02			ldx 	#2
.01a47e	20 d5 a4	jsr $01a4d5			jsr 	Random16
.01a481	fa		plx				plx
.01a482	80 1a		bra $01a49e			bra 	_URMakeRandom
.01a484					_URSetSeed:
.01a484	20 e7 a1	jsr $01a1e7			jsr 	FPUToFloat 					; make it a float to twiddle it.
.01a487	b5 80		lda $80,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.01a489	8d a3 03	sta $03a3			sta 	RandomSeed+0
.01a48c	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.01a48e	8d a4 03	sta $03a4			sta 	RandomSeed+1
.01a491	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.01a493	8d a5 03	sta $03a5			sta 	RandomSeed+2
.01a496	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.01a498	0a		asl a				asl 	a
.01a499	49 db		eor #$db			eor 	#$DB
.01a49b	8d a6 03	sta $03a6			sta 	RandomSeed+3
.01a49e					_URMakeRandom:
.01a49e	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; check if seed is zero.
.01a4a1	0d a4 03	ora $03a4			ora 	RandomSeed+1
.01a4a4	0d a5 03	ora $03a5			ora 	RandomSeed+2
.01a4a7	0d a6 03	ora $03a6			ora 	RandomSeed+3
.01a4aa	d0 0a		bne $01a4b6			bne 	_URNotZero
.01a4ac	a9 47		lda #$47			lda 	#$47
.01a4ae	8d a4 03	sta $03a4			sta 	RandomSeed+1				; if it is, make it non zero.
.01a4b1	a9 3d		lda #$3d			lda 	#$3D
.01a4b3	8d a6 03	sta $03a6			sta 	RandomSeed+3
.01a4b6					_URNotZero:
.01a4b6	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; copy seed into mantissa.
.01a4b9	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a4bb	ad a4 03	lda $03a4			lda 	RandomSeed+1
.01a4be	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a4c0	ad a5 03	lda $03a5			lda 	RandomSeed+2
.01a4c3	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a4c5	ad a6 03	lda $03a6			lda 	RandomSeed+3
.01a4c8	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a4ca	a9 00		lda #$00			lda 	#$00 						; set type to float.
.01a4cc	95 85		sta $85,x			sta 	XS_Type,x
.01a4ce	a9 80		lda #$80			lda 	#$80
.01a4d0	95 84		sta $84,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.01a4d2	4c 14 a2	jmp $01a214			jmp 	FPUNormalise
.01a4d5					Random16:
.01a4d5	5e a4 03	lsr $03a4,x			lsr 	RandomSeed+1,x				; shift seed right
.01a4d8	7e a3 03	ror $03a3,x			ror 	RandomSeed,x
.01a4db	90 08		bcc $01a4e5			bcc 	_R16_NoXor
.01a4dd	bd a4 03	lda $03a4,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.01a4e0	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.01a4e2	9d a4 03	sta $03a4,x			sta 	RandomSeed+1,x
.01a4e5					_R16_NoXor:
.01a4e5	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.01a4e6					Unary_Int:
.01a4e6	20 e7 91	jsr $0191e7			jsr 	EvaluateNumberX 			; get value
.01a4e9	20 37 98	jsr $019837			jsr 	CheckNextRParen 			; check right bracket.
.01a4ec	4c 33 a2	jmp $01a233			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Return to file: basic.asm

>01a4ef	02						.byte 	2
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 c0						.word 	StartROM
>fffe	19 c0					.word TIM_BreakHandler

;******  End of listing
