
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Wed Aug 28 08:57:17 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="6502"					cpu = "6502"
="em6502"				hardware = "em6502"
=1					exitonend = 1
=1					autorun = 1
=1					loadtest = 1
=1					hasfloat = 1
=1					hasinteger = 1
=253					maxstring = 253

;******  Processing file: modules/float/fpmacros.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/em6502/src_em6502.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0020					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0022					zVarDataPtr: .word ? 						; position of variable data.
>0024					zVarType: 	.byte ? 						; type of data (token)
>0025					zNullString:.byte ? 						; represents a NULL string.
>0200					IFT_XCursor:.byte ?							; current logical position on screen
>0201					IFT_YCursor:.byte ?
>0202					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0266					IFT_LineBuffer: .fill 100 					; line input buffer.
>0300					UserVector .fill 4 							; USR(x) calls this.
>0304					LocalVector .fill 4 						; Indirect calls call this.
>0308					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>030c					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>030d					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=782					XS2_Mantissa = XS_Mantissa+XS_Size
=786					XS2_Exponent = XS_Exponent+XS_Size
=787					XS2_Type = XS_Type+XS_Size
=788					XS3_Mantissa = XS_Mantissa+XS_Size*2
=792					XS3_Exponent = XS_Exponent+XS_Size*2
=793					XS3_Type = XS_Type+XS_Size*2
>0400					StringPtr:	.word ? 						; Top of free memory (for string allocation)
>0402					VarMemPtr: 	.word ?							; Bottom of free memory (for variables)
>0404					NumBufX 	.byte 	?						; buffer index position
>0405					Num_Buffer	.fill 	32 						; buffer for numeric conversions
=6					HashTableCount = 6 							; there are 6 hash tables, in token order.
=8					HashTableSize = 8 							; each hash table as 8 links.
.0425					HashTableBase:
>0425								.fill	HashTableCount * HashTableSize * 2
.0485					HashTableEnd:
=$405					Var_Buffer 	= Num_Buffer 					; buffer for variable name (same space)
>0485					Var_Type    .byte ? 						; type of variable (as a type token)
>0486					Var_Hash 	.byte ? 						; hash of identifier name.
>0487					Var_Length 	.byte ? 						; length of variable name
>0488					Var_HashAddress .byte ?						; low byte of hash table entry.
>0489					Var_DataSize .byte ?						; size of one element.
>048a					NumSuppress	.byte 	?						; leading zero suppression flag
>048b					NumConvCount .byte 	? 						; count for conversions.
>048c					ExpTemp:	.byte ?							; Working temp for exponents.
>048d					ExpCount:	.byte ? 						; Count of decimal exponents.
>048e					SignCount:	.byte ?							; Integer Divide Sign Counts.
>048f					TempStringWriteIndex: .byte ? 				; Write offset.
>0490					ValSign: 	.byte ? 						; sign flag for val()
>0491					SliceStart:	.byte ? 						; string slice parts
>0492					SliceCount:	.byte ?
>0493					RandomSeed:	.dword ? 						; Random seed.
=3					ArrayMaxDim = 3 							; number of dimensions.
>0497					ArrayDef:	.fill (ArrayMaxDim+1)*2 		; dimensions for auto-creation
>049f					UsrArrayDef:.fill (ArrayMaxDim+1)*2 		; dimensions created in DIM
>04a7					UsrArrayIdx:.byte ? 						; index into UsrArrayDef
>04a8					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>04aa					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>04ac					Tim_SR:		.byte ? 						; Processor Status
>04ad					Tim_A:		.byte ? 						; Processor Registers
>04ae					Tim_X:		.byte ?
>04af					Tim_Y:		.byte ?
>04b0					Tim_Z:		.byte ?
>04b1					Tim_SP:		.word ?							; Stack Pointer (just in cases)

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/em6502.asm

=$8000					HighMemory = $8000
=$2000					VariableMemory = $2000
.1000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testing.src

>1000	1b 02 00 dc bd 41 6c 66			.byte	$1b,$02,$00,$dc,$bd,$41,$6c,$66
>1008	49 fd 04 37 37 87 41 6c			.byte	$49,$fd,$04,$37,$37,$87,$41,$6c
>1010	66 49 fd 04 37 37 be 84			.byte	$66,$49,$fd,$04,$37,$37,$be,$84
>1018	8b 41 00 14 03 00 dc bd			.byte	$8b,$41,$00,$14,$03,$00,$dc,$bd
>1020	8b 41 70 5b 54 8d 8b 41			.byte	$8b,$41,$70,$5b,$54,$8d,$8b,$41
>1028	70 5b 54 be 84 41 00 17			.byte	$70,$5b,$54,$be,$84,$41,$00,$17
>1030	04 00 dc bd 8b 42 74 72			.byte	$04,$00,$dc,$bd,$8b,$42,$74,$72
>1038	42 81 8b 41 56 46 69 be			.byte	$42,$81,$8b,$41,$56,$46,$69,$be
>1040	84 8b 54 42 41 00 0f 05			.byte	$84,$8b,$54,$42,$41,$00,$0f,$05
>1048	00 dc 9a 8b 7d 66 47 be			.byte	$00,$dc,$9a,$8b,$7d,$66,$47,$be
>1050	84 7d 66 47 00 0e 06 00			.byte	$84,$7d,$66,$47,$00,$0e,$06,$00
>1058	dc a0 fe 02 bf 48 be 84			.byte	$dc,$a0,$fe,$02,$bf,$48,$be,$84
>1060	fe 02 00 1a 07 00 dc bd			.byte	$fe,$02,$00,$1a,$07,$00,$dc,$bd
>1068	8b 50 57 fd 05 39 31 39			.byte	$8b,$50,$57,$fd,$05,$39,$31,$39
>1070	86 8b 50 57 fd 05 39 31			.byte	$86,$8b,$50,$57,$fd,$05,$39,$31
>1078	39 be 84 40 00 14 08 00			.byte	$39,$be,$84,$40,$00,$14,$08,$00
>1080	dc bd 8b 42 4a 57 5b 85			.byte	$dc,$bd,$8b,$42,$4a,$57,$5b,$85
>1088	8b 42 4a 57 5b be 84 40			.byte	$8b,$42,$4a,$57,$5b,$be,$84,$40
>1090	00 15 09 00 dc bd 41 6b			.byte	$00,$15,$09,$00,$dc,$bd,$41,$6b
>1098	4b 50 80 43 45 60 64 be			.byte	$4b,$50,$80,$43,$45,$60,$64,$be
>10a0	84 41 41 40 40 00 0f 0a			.byte	$84,$41,$41,$40,$40,$00,$0f,$0a
>10a8	00 dc b3 8b 43 5c 68 6d			.byte	$00,$dc,$b3,$8b,$43,$5c,$68,$6d
>10b0	be 84 8b 41 00 15 0b 00			.byte	$be,$84,$8b,$41,$00,$15,$0b,$00
>10b8	dc a1 fe 06 79 6a 6f 66			.byte	$dc,$a1,$fe,$06,$79,$6a,$6f,$66
>10c0	bf 43 be 84 fe 05 6a 6f			.byte	$bf,$43,$be,$84,$fe,$05,$6a,$6f
>10c8	66 00 25 0c 00 dc bd 5d			.byte	$66,$00,$25,$0c,$00,$dc,$bd,$5d
>10d0	6f 51 fd 04 36 31 8c 5d			.byte	$6f,$51,$fd,$04,$36,$31,$8c,$5d
>10d8	6f 51 fd 04 36 31 be 84			.byte	$6f,$51,$fd,$04,$36,$31,$be,$84
>10e0	41 fd 0d 34 38 33 37 35			.byte	$41,$fd,$0d,$34,$38,$33,$37,$35
>10e8	38 30 36 65 31 30 00 12			.byte	$38,$30,$36,$65,$31,$30,$00,$12
>10f0	0d 00 dc bd 43 54 6a 71			.byte	$0d,$00,$dc,$bd,$43,$54,$6a,$71
>10f8	86 43 54 6a 71 be 84 40			.byte	$86,$43,$54,$6a,$71,$be,$84,$40
>1100	00 16 0e 00 dc bd 41 41			.byte	$00,$16,$0e,$00,$dc,$bd,$41,$41
>1108	5a 6e 81 8b 41 47 7d 63			.byte	$5a,$6e,$81,$8b,$41,$47,$7d,$63
>1110	be 84 8b 46 65 41 00 17			.byte	$be,$84,$8b,$46,$65,$41,$00,$17
>1118	0f 00 dc b2 8b 42 62 44			.byte	$0f,$00,$dc,$b2,$8b,$42,$62,$44
>1120	47 bf 8b 43 53 51 43 be			.byte	$47,$bf,$8b,$43,$53,$51,$43,$be
>1128	84 42 62 44 47 00 13 10			.byte	$84,$42,$62,$44,$47,$00,$13,$10
>1130	00 dc a2 fe 05 63 79 6d			.byte	$00,$dc,$a2,$fe,$05,$63,$79,$6d
>1138	bf 4a bf 44 be 84 fe 02			.byte	$bf,$4a,$bf,$44,$be,$84,$fe,$02
>1140	00 1d 11 00 dc bd 41 5a			.byte	$00,$1d,$11,$00,$dc,$bd,$41,$5a
>1148	73 7c fd 04 34 35 8d 41			.byte	$73,$7c,$fd,$04,$34,$35,$8d,$41
>1150	5a 73 7c fd 04 34 35 be			.byte	$5a,$73,$7c,$fd,$04,$34,$35,$be
>1158	84 41 fd 03 30 00 13 12			.byte	$84,$41,$fd,$03,$30,$00,$13,$12
>1160	00 dc bd 41 4b 5d 67 89			.byte	$00,$dc,$bd,$41,$4b,$5d,$67,$89
>1168	41 4b 5d 67 be 84 8b 41			.byte	$41,$4b,$5d,$67,$be,$84,$8b,$41
>1170	00 16 13 00 dc bd 8b 42			.byte	$00,$16,$13,$00,$dc,$bd,$8b,$42
>1178	6b 49 51 81 8b 6d 40 6e			.byte	$6b,$49,$51,$81,$8b,$6d,$40,$6e
>1180	be 84 8b 69 40 41 00 10			.byte	$be,$84,$8b,$69,$40,$41,$00,$10
>1188	14 00 dc 98 8b 43 47 7c			.byte	$14,$00,$dc,$98,$8b,$43,$47,$7c
>1190	4f 84 43 47 7c 4e 00 11			.byte	$4f,$84,$43,$47,$7c,$4e,$00,$11
>1198	15 00 dc a6 fe 08 69 71			.byte	$15,$00,$dc,$a6,$fe,$08,$69,$71
>11a0	62 62 70 61 be 84 46 00			.byte	$62,$62,$70,$61,$be,$84,$46,$00
>11a8	1d 16 00 dc bd 42 70 42			.byte	$1d,$16,$00,$dc,$bd,$42,$70,$42
>11b0	7a fd 04 35 35 8b 42 70			.byte	$7a,$fd,$04,$35,$35,$8b,$42,$70
>11b8	42 7a fd 04 35 35 be 84			.byte	$42,$7a,$fd,$04,$35,$35,$be,$84
>11c0	40 fd 03 30 00 12 17 00			.byte	$40,$fd,$03,$30,$00,$12,$17,$00
>11c8	dc bd 43 6b 4f 51 86 43			.byte	$dc,$bd,$43,$6b,$4f,$51,$86,$43
>11d0	6b 4f 51 be 84 40 00 17			.byte	$6b,$4f,$51,$be,$84,$40,$00,$17
>11d8	18 00 dc bd 8b 6b 7e 6f			.byte	$18,$00,$dc,$bd,$8b,$6b,$7e,$6f
>11e0	80 8b 43 71 6f 54 be 84			.byte	$80,$8b,$43,$71,$6f,$54,$be,$84
>11e8	8b 43 7c 40 40 00 14 19			.byte	$8b,$43,$7c,$40,$40,$00,$14,$19
>11f0	00 dc a5 a4 8b 43 4f 6f			.byte	$00,$dc,$a5,$a4,$8b,$43,$4f,$6f
>11f8	55 be be 84 8b 43 4f 6f			.byte	$55,$be,$be,$84,$8b,$43,$4f,$6f
>1200	55 00 1a 1a 00 dc bd 42			.byte	$55,$00,$1a,$1a,$00,$dc,$bd,$42
>1208	42 75 42 fd 04 34 33 88			.byte	$42,$75,$42,$fd,$04,$34,$33,$88
>1210	42 42 75 42 fd 04 34 33			.byte	$42,$42,$75,$42,$fd,$04,$34,$33
>1218	be 84 40 00 13 1b 00 dc			.byte	$be,$84,$40,$00,$13,$1b,$00,$dc
>1220	bd 8b 57 7a 64 87 8b 57			.byte	$bd,$8b,$57,$7a,$64,$87,$8b,$57
>1228	7a 64 be 84 8b 41 00 16			.byte	$7a,$64,$be,$84,$8b,$41,$00,$16
>1230	1c 00 dc bd 71 5f 7e 81			.byte	$1c,$00,$dc,$bd,$71,$5f,$7e,$81
>1238	8b 43 62 42 67 be 84 8b			.byte	$8b,$43,$62,$42,$67,$be,$84,$8b
>1240	43 42 40 41 00 11 1d 00			.byte	$43,$42,$40,$41,$00,$11,$1d,$00
>1248	dc 9a 8b 43 41 5b 65 be			.byte	$dc,$9a,$8b,$43,$41,$5b,$65,$be
>1250	84 43 41 5b 65 00 0d 1e			.byte	$84,$43,$41,$5b,$65,$00,$0d,$1e
>1258	00 dc b4 62 be 84 fe 02			.byte	$00,$dc,$b4,$62,$be,$84,$fe,$02
>1260	fe 02 00 29 1f 00 dc bd			.byte	$fe,$02,$00,$29,$1f,$00,$dc,$bd
>1268	8b 41 66 67 52 fd 04 34			.byte	$8b,$41,$66,$67,$52,$fd,$04,$34
>1270	39 8c 8b 41 66 67 52 fd			.byte	$39,$8c,$8b,$41,$66,$67,$52,$fd
>1278	04 34 39 be 84 41 fd 0d			.byte	$04,$34,$39,$be,$84,$41,$fd,$0d
>1280	37 36 36 35 37 35 34 38			.byte	$37,$36,$36,$35,$37,$35,$34,$38
>1288	65 31 31 00 15 20 00 dc			.byte	$65,$31,$31,$00,$15,$20,$00,$dc
>1290	bd 8b 42 67 4c 5f 87 8b			.byte	$bd,$8b,$42,$67,$4c,$5f,$87,$8b
>1298	42 67 4c 5f be 84 8b 41			.byte	$42,$67,$4c,$5f,$be,$84,$8b,$41
>12a0	00 15 21 00 dc bd 42 73			.byte	$00,$15,$21,$00,$dc,$bd,$42,$73
>12a8	4c 69 81 43 62 61 63 be			.byte	$4c,$69,$81,$43,$62,$61,$63,$be
>12b0	84 43 73 6d 6b 00 0e 22			.byte	$84,$43,$73,$6d,$6b,$00,$0e,$22
>12b8	00 dc b3 8b 43 60 59 be			.byte	$00,$dc,$b3,$8b,$43,$60,$59,$be
>12c0	84 8b 41 00 14 23 00 dc			.byte	$84,$8b,$41,$00,$14,$23,$00,$dc
>12c8	a3 49 be 84 fe 0b 20 20			.byte	$a3,$49,$be,$84,$fe,$0b,$20,$20
>12d0	20 20 20 20 20 20 20 00			.byte	$20,$20,$20,$20,$20,$20,$20,$00
>12d8	1d 24 00 dc bd 8b 41 42			.byte	$1d,$24,$00,$dc,$bd,$8b,$41,$42
>12e0	5f 64 fd 04 37 38 84 8b			.byte	$5f,$64,$fd,$04,$37,$38,$84,$8b
>12e8	41 42 5f 64 fd 04 37 38			.byte	$41,$42,$5f,$64,$fd,$04,$37,$38
>12f0	be 84 8b 41 00 14 25 00			.byte	$be,$84,$8b,$41,$00,$14,$25,$00
>12f8	dc bd 8b 43 55 42 52 8b			.byte	$dc,$bd,$8b,$43,$55,$42,$52,$8b
>1300	8b 43 55 42 52 be 84 40			.byte	$8b,$43,$55,$42,$52,$be,$84,$40
>1308	00 16 26 00 dc bd 50 78			.byte	$00,$16,$26,$00,$dc,$bd,$50,$78
>1310	7d 82 8b 42 6f 48 72 be			.byte	$7d,$82,$8b,$42,$6f,$48,$72,$be
>1318	84 8b 42 7f 70 4d 00 15			.byte	$84,$8b,$42,$7f,$70,$4d,$00,$15
>1320	27 00 dc b2 8b 65 78 7c			.byte	$27,$00,$dc,$b2,$8b,$65,$78,$7c
>1328	bf 8b 43 61 61 6f be 84			.byte	$bf,$8b,$43,$61,$61,$6f,$be,$84
>1330	65 78 7c 00 0c 28 00 dc			.byte	$65,$78,$7c,$00,$0c,$28,$00,$dc
>1338	a7 40 be 84 fe 03 30 00			.byte	$a7,$40,$be,$84,$fe,$03,$30,$00
>1340	1d 29 00 dc bd 41 7f 5e			.byte	$1d,$29,$00,$dc,$bd,$41,$7f,$5e
>1348	46 fd 04 35 39 8d 41 7f			.byte	$46,$fd,$04,$35,$39,$8d,$41,$7f
>1350	5e 46 fd 04 35 39 be 84			.byte	$5e,$46,$fd,$04,$35,$39,$be,$84
>1358	41 fd 03 30 00 12 2a 00			.byte	$41,$fd,$03,$30,$00,$12,$2a,$00
>1360	dc bd 43 46 55 6e 8d 43			.byte	$dc,$bd,$43,$46,$55,$6e,$8d,$43
>1368	46 55 6e be 84 41 00 15			.byte	$46,$55,$6e,$be,$84,$41,$00,$15
>1370	2b 00 dc bd 43 40 41 5f			.byte	$2b,$00,$dc,$bd,$43,$40,$41,$5f
>1378	80 41 5f 7d 63 be 84 41			.byte	$80,$41,$5f,$7d,$63,$be,$84,$41
>1380	40 41 43 00 10 2c 00 dc			.byte	$40,$41,$43,$00,$10,$2c,$00,$dc
>1388	98 8b 42 5c 45 49 84 42			.byte	$98,$8b,$42,$5c,$45,$49,$84,$42
>1390	5c 45 48 00 13 2d 00 dc			.byte	$5c,$45,$48,$00,$13,$2d,$00,$dc
>1398	af fe 07 37 42 43 41 41			.byte	$af,$fe,$07,$37,$42,$43,$41,$41
>13a0	be 84 41 7b 72 6a 00 1f			.byte	$be,$84,$41,$7b,$72,$6a,$00,$1f
>13a8	2e 00 dc bd 8b 43 44 67			.byte	$2e,$00,$dc,$bd,$8b,$43,$44,$67
>13b0	6f fd 04 32 33 8b 8b 43			.byte	$6f,$fd,$04,$32,$33,$8b,$8b,$43
>13b8	44 67 6f fd 04 32 33 be			.byte	$44,$67,$6f,$fd,$04,$32,$33,$be
>13c0	84 40 fd 03 30 00 13 2f			.byte	$84,$40,$fd,$03,$30,$00,$13,$2f
>13c8	00 dc bd 42 4a 6a 75 87			.byte	$00,$dc,$bd,$42,$4a,$6a,$75,$87
>13d0	42 4a 6a 75 be 84 8b 41			.byte	$42,$4a,$6a,$75,$be,$84,$8b,$41
>13d8	00 14 30 00 dc bd 41 7b			.byte	$00,$14,$30,$00,$dc,$bd,$41,$7b
>13e0	58 6e 80 42 53 7c 5d be			.byte	$58,$6e,$80,$42,$53,$7c,$5d,$be
>13e8	84 53 58 4c 00 12 31 00			.byte	$84,$53,$58,$4c,$00,$12,$31,$00
>13f0	dc a5 a4 41 69 40 4a be			.byte	$dc,$a5,$a4,$41,$69,$40,$4a,$be
>13f8	be 84 41 69 40 4a 00 10			.byte	$be,$84,$41,$69,$40,$4a,$00,$10
>1400	32 00 dc a0 fe 03 6a bf			.byte	$32,$00,$dc,$a0,$fe,$03,$6a,$bf
>1408	4a be 84 fe 03 6a 00 1f			.byte	$4a,$be,$84,$fe,$03,$6a,$00,$1f
>1410	33 00 dc bd 8b 42 70 42			.byte	$33,$00,$dc,$bd,$8b,$42,$70,$42
>1418	6b fd 04 36 36 8d 8b 42			.byte	$6b,$fd,$04,$36,$36,$8d,$8b,$42
>1420	70 42 6b fd 04 36 36 be			.byte	$70,$42,$6b,$fd,$04,$36,$36,$be
>1428	84 41 fd 03 30 00 10 34			.byte	$84,$41,$fd,$03,$30,$00,$10,$34
>1430	00 dc bd 73 66 7f 88 73			.byte	$00,$dc,$bd,$73,$66,$7f,$88,$73
>1438	66 7f be 84 40 00 16 35			.byte	$66,$7f,$be,$84,$40,$00,$16,$35
>1440	00 dc bd 41 62 5e 44 82			.byte	$00,$dc,$bd,$41,$62,$5e,$44,$82
>1448	8b 41 5f 74 6f be 84 8b			.byte	$8b,$41,$5f,$74,$6f,$be,$84,$8b
>1450	7d 6a 6b 00 0a 36 00 dc			.byte	$7d,$6a,$6b,$00,$0a,$36,$00,$dc
>1458	9a 40 be 84 40 00 16 37			.byte	$9a,$40,$be,$84,$40,$00,$16,$37
>1460	00 dc a1 fe 06 6a 65 78			.byte	$00,$dc,$a1,$fe,$06,$6a,$65,$78
>1468	72 bf 48 be 84 fe 06 6a			.byte	$72,$bf,$48,$be,$84,$fe,$06,$6a
>1470	65 78 72 00 1c 38 00 dc			.byte	$65,$78,$72,$00,$1c,$38,$00,$dc
>1478	bd 8b 41 75 45 66 fd 04			.byte	$bd,$8b,$41,$75,$45,$66,$fd,$04
>1480	39 32 88 8b 41 75 45 66			.byte	$39,$32,$88,$8b,$41,$75,$45,$66
>1488	fd 04 39 32 be 84 40 00			.byte	$fd,$04,$39,$32,$be,$84,$40,$00
>1490	12 39 00 dc bd 41 7f 41			.byte	$12,$39,$00,$dc,$bd,$41,$7f,$41
>1498	6f 8b 41 7f 41 6f be 84			.byte	$6f,$8b,$41,$7f,$41,$6f,$be,$84
>14a0	40 00 17 3a 00 dc bd 8b			.byte	$40,$00,$17,$3a,$00,$dc,$bd,$8b
>14a8	43 61 6f 47 80 8b 5e 41			.byte	$43,$61,$6f,$47,$80,$8b,$5e,$41
>14b0	6b be 84 8b 43 7f 6f 6f			.byte	$6b,$be,$84,$8b,$43,$7f,$6f,$6f
>14b8	00 0f 3b 00 dc b3 8b 43			.byte	$00,$0f,$3b,$00,$dc,$b3,$8b,$43
>14c0	6f 43 67 be 84 8b 41 00			.byte	$6f,$43,$67,$be,$84,$8b,$41,$00
>14c8	16 3c 00 dc a2 fe 08 66			.byte	$16,$3c,$00,$dc,$a2,$fe,$08,$66
>14d0	74 68 77 6d 6a bf 48 bf			.byte	$74,$68,$77,$6d,$6a,$bf,$48,$bf
>14d8	44 be 84 fe 02 00 1c 3d			.byte	$44,$be,$84,$fe,$02,$00,$1c,$3d
>14e0	00 dc bd 8b 42 45 5f 55			.byte	$00,$dc,$bd,$8b,$42,$45,$5f,$55
>14e8	fd 04 37 38 86 8b 42 45			.byte	$fd,$04,$37,$38,$86,$8b,$42,$45
>14f0	5f 55 fd 04 37 38 be 84			.byte	$5f,$55,$fd,$04,$37,$38,$be,$84
>14f8	40 00 16 3e 00 dc bd 8b			.byte	$40,$00,$16,$3e,$00,$dc,$bd,$8b
>1500	7a 4e 62 8a 8b 7a 4e 62			.byte	$7a,$4e,$62,$8a,$8b,$7a,$4e,$62
>1508	be 84 8b 41 74 5d 44 00			.byte	$be,$84,$8b,$41,$74,$5d,$44,$00
>1510	0f 3f 00 dc bd 40 80 41			.byte	$0f,$3f,$00,$dc,$bd,$40,$80,$41
>1518	6c 52 41 be 84 40 00 16			.byte	$6c,$52,$41,$be,$84,$40,$00,$16
>1520	40 00 dc b2 43 50 40 75			.byte	$40,$00,$dc,$b2,$43,$50,$40,$75
>1528	bf 8b 41 76 77 55 be 84			.byte	$bf,$8b,$41,$76,$77,$55,$be,$84
>1530	41 59 49 60 00 12 41 00			.byte	$41,$59,$49,$60,$00,$12,$41,$00
>1538	dc a6 fe 09 62 63 6a 6c			.byte	$dc,$a6,$fe,$09,$62,$63,$6a,$6c
>1540	6b 72 76 be 84 47 00 24			.byte	$6b,$72,$76,$be,$84,$47,$00,$24
>1548	42 00 dc bd 8b 41 50 5f			.byte	$42,$00,$dc,$bd,$8b,$41,$50,$5f
>1550	70 fd 04 37 38 8a 8b 41			.byte	$70,$fd,$04,$37,$38,$8a,$8b,$41
>1558	50 5f 70 fd 04 37 38 be			.byte	$50,$5f,$70,$fd,$04,$37,$38,$be
>1560	84 8b 42 60 7f 61 fd 04			.byte	$84,$8b,$42,$60,$7f,$61,$fd,$04
>1568	35 37 00 12 43 00 dc bd			.byte	$35,$37,$00,$12,$43,$00,$dc,$bd
>1570	8b 4f 69 76 8b 8b 4f 69			.byte	$8b,$4f,$69,$76,$8b,$8b,$4f,$69
>1578	76 be 84 40 00 16 44 00			.byte	$76,$be,$84,$40,$00,$16,$44,$00
>1580	dc bd 8b 41 59 54 51 81			.byte	$dc,$bd,$8b,$41,$59,$54,$51,$81
>1588	8b 58 64 4d be 84 8b 58			.byte	$8b,$58,$64,$4d,$be,$84,$8b,$58
>1590	44 41 00 0a 45 00 dc 98			.byte	$44,$41,$00,$0a,$45,$00,$dc,$98
>1598	40 84 8b 41 00 0f 46 00			.byte	$40,$84,$8b,$41,$00,$0f,$46,$00
>15a0	dc 9b fe 05 62 61 6b be			.byte	$dc,$9b,$fe,$05,$62,$61,$6b,$be
>15a8	84 41 62 00 1c 47 00 dc			.byte	$84,$41,$62,$00,$1c,$47,$00,$dc
>15b0	bd 8b 42 5d 7f 4f fd 04			.byte	$bd,$8b,$42,$5d,$7f,$4f,$fd,$04
>15b8	31 39 88 8b 42 5d 7f 4f			.byte	$31,$39,$88,$8b,$42,$5d,$7f,$4f
>15c0	fd 04 31 39 be 84 40 00			.byte	$fd,$04,$31,$39,$be,$84,$40,$00
>15c8	14 48 00 dc bd 8b 43 4f			.byte	$14,$48,$00,$dc,$bd,$8b,$43,$4f
>15d0	54 43 8d 8b 43 4f 54 43			.byte	$54,$43,$8d,$8b,$43,$4f,$54,$43
>15d8	be 84 41 00 16 49 00 dc			.byte	$be,$84,$41,$00,$16,$49,$00,$dc
>15e0	bd 8b 42 42 48 79 80 41			.byte	$bd,$8b,$42,$42,$48,$79,$80,$41
>15e8	57 4e 6c be 84 41 55 46			.byte	$57,$4e,$6c,$be,$84,$41,$55,$46
>15f0	44 00 1a 4a 00 dc a5 a4			.byte	$44,$00,$1a,$4a,$00,$dc,$a5,$a4
>15f8	42 7b 61 71 fd 04 30 33			.byte	$42,$7b,$61,$71,$fd,$04,$30,$33
>1600	be be 84 42 7b 61 71 fd			.byte	$be,$be,$84,$42,$7b,$61,$71,$fd
>1608	04 30 33 00 0d 4b 00 dc			.byte	$04,$30,$33,$00,$0d,$4b,$00,$dc
>1610	b4 41 5d be 84 fe 03 5d			.byte	$b4,$41,$5d,$be,$84,$fe,$03,$5d
>1618	00 1a 4c 00 dc bd 42 79			.byte	$00,$1a,$4c,$00,$dc,$bd,$42,$79
>1620	7e 73 fd 04 37 35 86 42			.byte	$7e,$73,$fd,$04,$37,$35,$86,$42
>1628	79 7e 73 fd 04 37 35 be			.byte	$79,$7e,$73,$fd,$04,$37,$35,$be
>1630	84 40 00 12 4d 00 dc bd			.byte	$84,$40,$00,$12,$4d,$00,$dc,$bd
>1638	41 54 7a 59 8d 41 54 7a			.byte	$41,$54,$7a,$59,$8d,$41,$54,$7a
>1640	59 be 84 41 00 14 4e 00			.byte	$59,$be,$84,$41,$00,$14,$4e,$00
>1648	dc bd 8b 41 69 63 74 82			.byte	$dc,$bd,$8b,$41,$69,$63,$74,$82
>1650	40 be 84 8b 41 69 63 74			.byte	$40,$be,$84,$8b,$41,$69,$63,$74
>1658	00 10 4f 00 dc 9a 41 4e			.byte	$00,$10,$4f,$00,$dc,$9a,$41,$4e
>1660	73 4a be 84 41 4e 73 4a			.byte	$73,$4a,$be,$84,$41,$4e,$73,$4a
>1668	00 1c 50 00 dc a3 51 be			.byte	$00,$1c,$50,$00,$dc,$a3,$51,$be
>1670	84 fe 13 20 20 20 20 20			.byte	$84,$fe,$13,$20,$20,$20,$20,$20
>1678	20 20 20 20 20 20 20 20			.byte	$20,$20,$20,$20,$20,$20,$20,$20
>1680	20 20 20 20 00 1f 51 00			.byte	$20,$20,$20,$20,$00,$1f,$51,$00
>1688	dc bd 66 44 7d fd 04 36			.byte	$dc,$bd,$66,$44,$7d,$fd,$04,$36
>1690	32 8a 66 44 7d fd 04 36			.byte	$32,$8a,$66,$44,$7d,$fd,$04,$36
>1698	32 be 84 41 4c 49 7b fd			.byte	$32,$be,$84,$41,$4c,$49,$7b,$fd
>16a0	04 32 33 00 12 52 00 dc			.byte	$04,$32,$33,$00,$12,$52,$00,$dc
>16a8	bd 42 79 6d 57 85 42 79			.byte	$bd,$42,$79,$6d,$57,$85,$42,$79
>16b0	6d 57 be 84 40 00 14 53			.byte	$6d,$57,$be,$84,$40,$00,$14,$53
>16b8	00 dc bd 41 7d 51 69 80			.byte	$00,$dc,$bd,$41,$7d,$51,$69,$80
>16c0	42 49 51 48 be 84 49 51			.byte	$42,$49,$51,$48,$be,$84,$49,$51
>16c8	48 00 0d 54 00 dc b3 42			.byte	$48,$00,$0d,$54,$00,$dc,$b3,$42
>16d0	7b 46 54 be 84 41 00 12			.byte	$7b,$46,$54,$be,$84,$41,$00,$12
>16d8	55 00 dc a7 6a 41 79 be			.byte	$55,$00,$dc,$a7,$6a,$41,$79,$be
>16e0	84 fe 07 32 41 30 37 39			.byte	$84,$fe,$07,$32,$41,$30,$37,$39
>16e8	00 19 56 00 dc bd 6c 73			.byte	$00,$19,$56,$00,$dc,$bd,$6c,$73
>16f0	44 fd 04 32 37 89 6c 73			.byte	$44,$fd,$04,$32,$37,$89,$6c,$73
>16f8	44 fd 04 32 37 be 84 8b			.byte	$44,$fd,$04,$32,$37,$be,$84,$8b
>1700	41 00 0d 57 00 dc bd 40			.byte	$41,$00,$0d,$57,$00,$dc,$bd,$40
>1708	89 40 be 84 8b 41 00 16			.byte	$89,$40,$be,$84,$8b,$41,$00,$16
>1710	58 00 dc bd 8b 41 4f 4e			.byte	$58,$00,$dc,$bd,$8b,$41,$4f,$4e
>1718	5a 80 43 67 64 56 be 84			.byte	$5a,$80,$43,$67,$64,$56,$be,$84
>1720	42 60 60 46 00 15 59 00			.byte	$42,$60,$60,$46,$00,$15,$59,$00
>1728	dc b2 8b 68 43 4e bf 8b			.byte	$dc,$b2,$8b,$68,$43,$4e,$bf,$8b
>1730	41 4f 6e 70 be 84 68 43			.byte	$41,$4f,$6e,$70,$be,$84,$68,$43
>1738	4e 00 12 5a 00 dc af fe			.byte	$4e,$00,$12,$5a,$00,$dc,$af,$fe
>1740	07 31 46 44 30 32 be 84			.byte	$07,$31,$46,$44,$30,$32,$be,$84
>1748	5f 74 42 00 1b 5b 00 dc			.byte	$5f,$74,$42,$00,$1b,$5b,$00,$dc
>1750	bd 41 5d 6e 64 fd 04 37			.byte	$bd,$41,$5d,$6e,$64,$fd,$04,$37
>1758	34 89 41 5d 6e 64 fd 04			.byte	$34,$89,$41,$5d,$6e,$64,$fd,$04
>1760	37 34 be 84 8b 41 00 15			.byte	$37,$34,$be,$84,$8b,$41,$00,$15
>1768	5c 00 dc bd 8b 41 52 77			.byte	$5c,$00,$dc,$bd,$8b,$41,$52,$77
>1770	4b 87 8b 41 52 77 4b be			.byte	$4b,$87,$8b,$41,$52,$77,$4b,$be
>1778	84 8b 41 00 18 5d 00 dc			.byte	$84,$8b,$41,$00,$18,$5d,$00,$dc
>1780	bd 8b 43 5c 48 66 81 8b			.byte	$bd,$8b,$43,$5c,$48,$66,$81,$8b
>1788	43 63 60 78 be 84 8b 43			.byte	$43,$63,$60,$78,$be,$84,$8b,$43
>1790	40 40 66 00 0a 5e 00 dc			.byte	$40,$40,$66,$00,$0a,$5e,$00,$dc
>1798	98 40 84 8b 41 00 12 5f			.byte	$98,$40,$84,$8b,$41,$00,$12,$5f
>17a0	00 dc a0 fe 04 79 62 bf			.byte	$00,$dc,$a0,$fe,$04,$79,$62,$bf
>17a8	49 be 84 fe 04 79 62 00			.byte	$49,$be,$84,$fe,$04,$79,$62,$00
>17b0	1a 60 00 dc bd 8b 41 5d			.byte	$1a,$60,$00,$dc,$bd,$8b,$41,$5d
>17b8	7c 5f fd 03 33 88 8b 41			.byte	$7c,$5f,$fd,$03,$33,$88,$8b,$41
>17c0	5d 7c 5f fd 03 33 be 84			.byte	$5d,$7c,$5f,$fd,$03,$33,$be,$84
>17c8	40 00 12 61 00 dc bd 41			.byte	$40,$00,$12,$61,$00,$dc,$bd,$41
>17d0	5c 67 68 85 41 5c 67 68			.byte	$5c,$67,$68,$85,$41,$5c,$67,$68
>17d8	be 84 40 00 17 62 00 dc			.byte	$be,$84,$40,$00,$17,$62,$00,$dc
>17e0	bd 43 55 6c 58 82 8b 41			.byte	$bd,$43,$55,$6c,$58,$82,$8b,$41
>17e8	5b 42 67 be 84 8b 42 4e			.byte	$5b,$42,$67,$be,$84,$8b,$42,$4e
>17f0	6e 7f 00 18 63 00 dc a5			.byte	$6e,$7f,$00,$18,$63,$00,$dc,$a5
>17f8	a4 6d 7a 46 fd 04 39 36			.byte	$a4,$6d,$7a,$46,$fd,$04,$39,$36
>1800	be be 84 6d 7a 46 fd 04			.byte	$be,$be,$84,$6d,$7a,$46,$fd,$04
>1808	39 36 00 10 64 00 dc a1			.byte	$39,$36,$00,$10,$64,$00,$dc,$a1
>1810	fe 03 7a bf 41 be 84 fe			.byte	$fe,$03,$7a,$bf,$41,$be,$84,$fe
>1818	03 7a 00 1b 65 00 dc bd			.byte	$03,$7a,$00,$1b,$65,$00,$dc,$bd
>1820	43 4e 46 61 fd 04 38 37			.byte	$43,$4e,$46,$61,$fd,$04,$38,$37
>1828	84 8b 43 72 4c 7f fd 04			.byte	$84,$8b,$43,$72,$4c,$7f,$fd,$04
>1830	30 35 be 84 40 00 14 66			.byte	$30,$35,$be,$84,$40,$00,$14,$66
>1838	00 dc bd 8b 41 49 5d 40			.byte	$00,$dc,$bd,$8b,$41,$49,$5d,$40
>1840	86 8b 41 49 5d 40 be 84			.byte	$86,$8b,$41,$49,$5d,$40,$be,$84
>1848	40 00 15 67 00 dc bd 41			.byte	$40,$00,$15,$67,$00,$dc,$bd,$41
>1850	6d 6b 70 80 8b 41 6c 73			.byte	$6d,$6b,$70,$80,$8b,$41,$6c,$73
>1858	63 be 84 41 48 50 00 11			.byte	$63,$be,$84,$41,$48,$50,$00,$11
>1860	68 00 dc 9a 8b 41 5b 64			.byte	$68,$00,$dc,$9a,$8b,$41,$5b,$64
>1868	4c be 84 41 5b 64 4c 00			.byte	$4c,$be,$84,$41,$5b,$64,$4c,$00
>1870	1b 69 00 dc a2 fe 09 73			.byte	$1b,$69,$00,$dc,$a2,$fe,$09,$73
>1878	76 7a 72 6c 6d 77 bf 44			.byte	$76,$7a,$72,$6c,$6d,$77,$bf,$44
>1880	bf 46 be 84 fe 06 72 6c			.byte	$bf,$46,$be,$84,$fe,$06,$72,$6c
>1888	6d 77 00 18 6a 00 dc bd			.byte	$6d,$77,$00,$18,$6a,$00,$dc,$bd
>1890	5d 72 5e fd 04 38 31 85			.byte	$5d,$72,$5e,$fd,$04,$38,$31,$85
>1898	5d 72 5e fd 04 38 31 be			.byte	$5d,$72,$5e,$fd,$04,$38,$31,$be
>18a0	84 40 00 12 6b 00 dc bd			.byte	$84,$40,$00,$12,$6b,$00,$dc,$bd
>18a8	42 7a 4e 55 88 42 7a 4e			.byte	$42,$7a,$4e,$55,$88,$42,$7a,$4e
>18b0	55 be 84 40 00 14 6c 00			.byte	$55,$be,$84,$40,$00,$14,$6c,$00
>18b8	dc bd 70 41 59 81 42 45			.byte	$dc,$bd,$70,$41,$59,$81,$42,$45
>18c0	44 62 be 84 42 75 45 7b			.byte	$44,$62,$be,$84,$42,$75,$45,$7b
>18c8	00 0f 6d 00 dc b3 8b 43			.byte	$00,$0f,$6d,$00,$dc,$b3,$8b,$43
>18d0	53 61 42 be 84 8b 41 00			.byte	$53,$61,$42,$be,$84,$8b,$41,$00
>18d8	0f 6e 00 dc a6 fe 06 6e			.byte	$0f,$6e,$00,$dc,$a6,$fe,$06,$6e
>18e0	72 6e 68 be 84 44 00 1c			.byte	$72,$6e,$68,$be,$84,$44,$00,$1c
>18e8	6f 00 dc bd 8b 41 7e 49			.byte	$6f,$00,$dc,$bd,$8b,$41,$7e,$49
>18f0	fd 05 31 35 31 86 8b 41			.byte	$fd,$05,$31,$35,$31,$86,$8b,$41
>18f8	7e 49 fd 05 31 35 31 be			.byte	$7e,$49,$fd,$05,$31,$35,$31,$be
>1900	84 40 00 0c 70 00 dc bd			.byte	$84,$40,$00,$0c,$70,$00,$dc,$bd
>1908	40 88 40 be 84 40 00 16			.byte	$40,$88,$40,$be,$84,$40,$00,$16
>1910	71 00 dc bd 5d 4e 4d 82			.byte	$71,$00,$dc,$bd,$5d,$4e,$4d,$82
>1918	8b 41 4f 78 72 be 84 8b			.byte	$8b,$41,$4f,$78,$72,$be,$84,$8b
>1920	41 52 76 7d 00 16 72 00			.byte	$41,$52,$76,$7d,$00,$16,$72,$00
>1928	dc b2 8b 43 53 47 70 bf			.byte	$dc,$b2,$8b,$43,$53,$47,$70,$bf
>1930	8b 42 5a 6a 52 be 84 78			.byte	$8b,$42,$5a,$6a,$52,$be,$84,$78
>1938	5d 5e 00 15 73 00 dc 9b			.byte	$5d,$5e,$00,$15,$73,$00,$dc,$9b
>1940	fe 0b 75 62 6e 6a 62 64			.byte	$fe,$0b,$75,$62,$6e,$6a,$62,$64
>1948	66 69 6c be 84 41 75 00			.byte	$66,$69,$6c,$be,$84,$41,$75,$00
>1950	1d 74 00 dc bd 8b 42 65			.byte	$1d,$74,$00,$dc,$bd,$8b,$42,$65
>1958	55 4f fd 04 38 38 87 8b			.byte	$55,$4f,$fd,$04,$38,$38,$87,$8b
>1960	42 65 55 4f fd 04 38 38			.byte	$42,$65,$55,$4f,$fd,$04,$38,$38
>1968	be 84 8b 41 00 14 75 00			.byte	$be,$84,$8b,$41,$00,$14,$75,$00
>1970	dc bd 8b 41 5f 50 52 8b			.byte	$dc,$bd,$8b,$41,$5f,$50,$52,$8b
>1978	8b 41 5f 50 52 be 84 40			.byte	$8b,$41,$5f,$50,$52,$be,$84,$40
>1980	00 17 76 00 dc bd 8b 43			.byte	$00,$17,$76,$00,$dc,$bd,$8b,$43
>1988	4e 6c 6c 82 8b 42 58 6e			.byte	$4e,$6c,$6c,$82,$8b,$42,$58,$6e
>1990	7d be 84 41 56 42 57 00			.byte	$7d,$be,$84,$41,$56,$42,$57,$00
>1998	10 77 00 dc 98 8b 43 43			.byte	$10,$77,$00,$dc,$98,$8b,$43,$43
>19a0	52 68 84 43 43 52 67 00			.byte	$52,$68,$84,$43,$43,$52,$67,$00
>19a8	0c 78 00 dc b4 78 be 84			.byte	$0c,$78,$00,$dc,$b4,$78,$be,$84
>19b0	fe 03 38 00 20 79 00 dc			.byte	$fe,$03,$38,$00,$20,$79,$00,$dc
>19b8	bd 42 62 7c 7e fd 04 36			.byte	$bd,$42,$62,$7c,$7e,$fd,$04,$36
>19c0	36 8a 42 62 7c 7e fd 04			.byte	$36,$8a,$42,$62,$7c,$7e,$fd,$04
>19c8	36 36 be 84 45 45 79 7d			.byte	$36,$36,$be,$84,$45,$45,$79,$7d
>19d0	fd 03 33 00 12 7a 00 dc			.byte	$fd,$03,$33,$00,$12,$7a,$00,$dc
>19d8	bd 43 4f 57 5b 86 43 4f			.byte	$bd,$43,$4f,$57,$5b,$86,$43,$4f
>19e0	57 5b be 84 40 00 17 7b			.byte	$57,$5b,$be,$84,$40,$00,$17,$7b
>19e8	00 dc bd 8b 43 5f 74 7c			.byte	$00,$dc,$bd,$8b,$43,$5f,$74,$7c
>19f0	82 8b 42 56 68 6d be 84			.byte	$82,$8b,$42,$56,$68,$6d,$be,$84
>19f8	41 49 5c 57 00 14 7c 00			.byte	$41,$49,$5c,$57,$00,$14,$7c,$00
>1a00	dc a5 a4 8b 41 7a 7b 42			.byte	$dc,$a5,$a4,$8b,$41,$7a,$7b,$42
>1a08	be be 84 8b 41 7a 7b 42			.byte	$be,$be,$84,$8b,$41,$7a,$7b,$42
>1a10	00 0b 7d 00 dc a3 40 be			.byte	$00,$0b,$7d,$00,$dc,$a3,$40,$be
>1a18	84 fe 02 00 19 7e 00 dc			.byte	$84,$fe,$02,$00,$19,$7e,$00,$dc
>1a20	bd 43 67 7b 4a fd 03 32			.byte	$bd,$43,$67,$7b,$4a,$fd,$03,$32
>1a28	84 43 67 7b 4a fd 03 32			.byte	$84,$43,$67,$7b,$4a,$fd,$03,$32
>1a30	be 84 8b 41 00 13 7f 00			.byte	$be,$84,$8b,$41,$00,$13,$7f,$00
>1a38	dc bd 42 52 64 44 87 42			.byte	$dc,$bd,$42,$52,$64,$44,$87,$42
>1a40	52 64 44 be 84 8b 41 00			.byte	$52,$64,$44,$be,$84,$8b,$41,$00
>1a48	14 80 00 dc bd 8b 6e 49			.byte	$14,$80,$00,$dc,$bd,$8b,$6e,$49
>1a50	55 81 8b 42 41 56 75 be			.byte	$55,$81,$8b,$42,$41,$56,$75,$be
>1a58	84 8b 55 00 11 81 00 dc			.byte	$84,$8b,$55,$00,$11,$81,$00,$dc
>1a60	9a 8b 42 51 55 76 be 84			.byte	$9a,$8b,$42,$51,$55,$76,$be,$84
>1a68	42 51 55 76 00 13 82 00			.byte	$42,$51,$55,$76,$00,$13,$82,$00
>1a70	dc a7 41 6f 65 7f be 84			.byte	$dc,$a7,$41,$6f,$65,$7f,$be,$84
>1a78	fe 07 36 46 39 37 46 00			.byte	$fe,$07,$36,$46,$39,$37,$46,$00
>1a80	23 83 00 dc bd 8b 42 43			.byte	$23,$83,$00,$dc,$bd,$8b,$42,$43
>1a88	5f 48 fd 04 32 32 8a 8b			.byte	$5f,$48,$fd,$04,$32,$32,$8a,$8b
>1a90	42 43 5f 48 fd 04 32 32			.byte	$42,$43,$5f,$48,$fd,$04,$32,$32
>1a98	be 84 8b 44 46 7e 50 fd			.byte	$be,$84,$8b,$44,$46,$7e,$50,$fd
>1aa0	03 34 00 13 84 00 dc bd			.byte	$03,$34,$00,$13,$84,$00,$dc,$bd
>1aa8	41 75 44 45 87 41 75 44			.byte	$41,$75,$44,$45,$87,$41,$75,$44
>1ab0	45 be 84 8b 41 00 15 85			.byte	$45,$be,$84,$8b,$41,$00,$15,$85
>1ab8	00 dc bd 42 5f 57 5f 82			.byte	$00,$dc,$bd,$42,$5f,$57,$5f,$82
>1ac0	41 6d 47 57 be 84 43 72			.byte	$41,$6d,$47,$57,$be,$84,$43,$72
>1ac8	50 48 00 0d 86 00 dc b3			.byte	$50,$48,$00,$0d,$86,$00,$dc,$b3
>1ad0	41 7f 5d 7c be 84 41 00			.byte	$41,$7f,$5d,$7c,$be,$84,$41,$00
>1ad8	13 87 00 dc af fe 07 39			.byte	$13,$87,$00,$dc,$af,$fe,$07,$39
>1ae0	32 46 35 37 be 84 42 52			.byte	$32,$46,$35,$37,$be,$84,$42,$52
>1ae8	7d 57 00 23 88 00 dc bd			.byte	$7d,$57,$00,$23,$88,$00,$dc,$bd
>1af0	8b 42 60 5e 6d fd 04 37			.byte	$8b,$42,$60,$5e,$6d,$fd,$04,$37
>1af8	32 8a 8b 42 60 5e 6d fd			.byte	$32,$8a,$8b,$42,$60,$5e,$6d,$fd
>1b00	04 37 32 be 84 8b 45 40			.byte	$04,$37,$32,$be,$84,$8b,$45,$40
>1b08	7d 5b fd 03 34 00 13 89			.byte	$7d,$5b,$fd,$03,$34,$00,$13,$89
>1b10	00 dc bd 42 53 5c 6a 87			.byte	$00,$dc,$bd,$42,$53,$5c,$6a,$87
>1b18	42 53 5c 6a be 84 8b 41			.byte	$42,$53,$5c,$6a,$be,$84,$8b,$41
>1b20	00 18 8a 00 dc bd 8b 43			.byte	$00,$18,$8a,$00,$dc,$bd,$8b,$43
>1b28	6b 43 56 81 8b 43 4c 68			.byte	$6b,$43,$56,$81,$8b,$43,$4c,$68
>1b30	58 be 84 8b 43 48 40 56			.byte	$58,$be,$84,$8b,$43,$48,$40,$56
>1b38	00 13 8b 00 dc b2 8b 6f			.byte	$00,$13,$8b,$00,$dc,$b2,$8b,$6f
>1b40	6c 61 bf 4a 62 6d be 84			.byte	$6c,$61,$bf,$4a,$62,$6d,$be,$84
>1b48	45 61 6d 00 18 8c 00 dc			.byte	$45,$61,$6d,$00,$18,$8c,$00,$dc
>1b50	a0 fe 0c 6e 6a 76 62 67			.byte	$a0,$fe,$0c,$6e,$6a,$76,$62,$67
>1b58	6c 63 63 6d 6c bf 40 be			.byte	$6c,$63,$63,$6d,$6c,$bf,$40,$be
>1b60	84 fe 02 00 1b 8d 00 dc			.byte	$84,$fe,$02,$00,$1b,$8d,$00,$dc
>1b68	bd 58 7b 42 fd 04 35 33			.byte	$bd,$58,$7b,$42,$fd,$04,$35,$33
>1b70	8d 58 7b 42 fd 04 35 33			.byte	$8d,$58,$7b,$42,$fd,$04,$35,$33
>1b78	be 84 41 fd 03 30 00 15			.byte	$be,$84,$41,$fd,$03,$30,$00,$15
>1b80	8e 00 dc bd 42 59 7d 4f			.byte	$8e,$00,$dc,$bd,$42,$59,$7d,$4f
>1b88	8a 42 59 7d 4f be 84 44			.byte	$8a,$42,$59,$7d,$4f,$be,$84,$44
>1b90	73 7a 5e 00 13 8f 00 dc			.byte	$73,$7a,$5e,$00,$13,$8f,$00,$dc
>1b98	bd 4d 4b 63 80 8b 73 4b			.byte	$bd,$4d,$4b,$63,$80,$8b,$73,$4b
>1ba0	5e be 84 4c 40 62 00 0e			.byte	$5e,$be,$84,$4c,$40,$62,$00,$0e
>1ba8	90 00 dc 98 79 67 68 84			.byte	$90,$00,$dc,$98,$79,$67,$68,$84
>1bb0	8b 79 67 69 00 1c 91 00			.byte	$8b,$79,$67,$69,$00,$1c,$91,$00
>1bb8	dc a1 fe 09 7a 70 6f 69			.byte	$dc,$a1,$fe,$09,$7a,$70,$6f,$69
>1bc0	71 70 6d bf 48 be 84 fe			.byte	$71,$70,$6d,$bf,$48,$be,$84,$fe
>1bc8	09 7a 70 6f 69 71 70 6d			.byte	$09,$7a,$70,$6f,$69,$71,$70,$6d
>1bd0	00 18 92 00 dc bd 72 47			.byte	$00,$18,$92,$00,$dc,$bd,$72,$47
>1bd8	56 fd 04 39 35 86 72 47			.byte	$56,$fd,$04,$39,$35,$86,$72,$47
>1be0	56 fd 04 39 35 be 84 40			.byte	$56,$fd,$04,$39,$35,$be,$84,$40
>1be8	00 13 93 00 dc bd 42 7b			.byte	$00,$13,$93,$00,$dc,$bd,$42,$7b
>1bf0	4e 66 89 42 7b 4e 66 be			.byte	$4e,$66,$89,$42,$7b,$4e,$66,$be
>1bf8	84 8b 41 00 15 94 00 dc			.byte	$84,$8b,$41,$00,$15,$94,$00,$dc
>1c00	bd 43 58 6a 45 81 41 64			.byte	$bd,$43,$58,$6a,$45,$81,$41,$64
>1c08	4d 79 be 84 43 7c 6f 7d			.byte	$4d,$79,$be,$84,$43,$7c,$6f,$7d
>1c10	00 1c 95 00 dc a5 a4 8b			.byte	$00,$1c,$95,$00,$dc,$a5,$a4,$8b
>1c18	51 58 6c fd 05 33 39 37			.byte	$51,$58,$6c,$fd,$05,$33,$39,$37
>1c20	be be 84 8b 51 58 6c fd			.byte	$be,$be,$84,$8b,$51,$58,$6c,$fd
>1c28	05 33 39 37 00 14 96 00			.byte	$05,$33,$39,$37,$00,$14,$96,$00
>1c30	dc a2 fe 06 6e 67 79 72			.byte	$dc,$a2,$fe,$06,$6e,$67,$79,$72
>1c38	bf 49 bf 40 be 84 fe 02			.byte	$bf,$49,$bf,$40,$be,$84,$fe,$02
>1c40	00 1a 97 00 dc bd 42 7c			.byte	$00,$1a,$97,$00,$dc,$bd,$42,$7c
>1c48	5b 5d fd 04 35 38 86 42			.byte	$5b,$5d,$fd,$04,$35,$38,$86,$42
>1c50	7c 5b 5d fd 04 35 38 be			.byte	$7c,$5b,$5d,$fd,$04,$35,$38,$be
>1c58	84 40 00 14 98 00 dc bd			.byte	$84,$40,$00,$14,$98,$00,$dc,$bd
>1c60	8b 43 5c 41 56 85 8b 43			.byte	$8b,$43,$5c,$41,$56,$85,$8b,$43
>1c68	5c 41 56 be 84 40 00 17			.byte	$5c,$41,$56,$be,$84,$40,$00,$17
>1c70	99 00 dc bd 43 60 66 66			.byte	$99,$00,$dc,$bd,$43,$60,$66,$66
>1c78	82 8b 42 61 6a 70 be 84			.byte	$82,$8b,$42,$61,$6a,$70,$be,$84
>1c80	8b 41 41 4c 4a 00 10 9a			.byte	$8b,$41,$41,$4c,$4a,$00,$10,$9a
>1c88	00 dc 9a 41 62 48 7b be			.byte	$00,$dc,$9a,$41,$62,$48,$7b,$be
>1c90	84 41 62 48 7b 00 0b 9b			.byte	$84,$41,$62,$48,$7b,$00,$0b,$9b
>1c98	00 dc a6 fe 02 be 84 40			.byte	$00,$dc,$a6,$fe,$02,$be,$84,$40
>1ca0	00 1a 9c 00 dc bd 8b 42			.byte	$00,$1a,$9c,$00,$dc,$bd,$8b,$42
>1ca8	7f 7a 56 fd 03 36 88 8b			.byte	$7f,$7a,$56,$fd,$03,$36,$88,$8b
>1cb0	42 7f 7a 56 fd 03 36 be			.byte	$42,$7f,$7a,$56,$fd,$03,$36,$be
>1cb8	84 40 00 13 9d 00 dc bd			.byte	$84,$40,$00,$13,$9d,$00,$dc,$bd
>1cc0	41 4c 48 4c 89 41 4c 48			.byte	$41,$4c,$48,$4c,$89,$41,$4c,$48
>1cc8	4c be 84 8b 41 00 10 9e			.byte	$4c,$be,$84,$8b,$41,$00,$10,$9e
>1cd0	00 dc bd 8b 43 60 6f 78			.byte	$00,$dc,$bd,$8b,$43,$60,$6f,$78
>1cd8	80 40 be 84 40 00 0d 9f			.byte	$80,$40,$be,$84,$40,$00,$0d,$9f
>1ce0	00 dc b3 41 6f 73 60 be			.byte	$00,$dc,$b3,$41,$6f,$73,$60,$be
>1ce8	84 41 00 13 a0 00 dc 9b			.byte	$84,$41,$00,$13,$a0,$00,$dc,$9b
>1cf0	fe 09 72 68 69 6e 73 68			.byte	$fe,$09,$72,$68,$69,$6e,$73,$68
>1cf8	73 be 84 41 72 00 29 a1			.byte	$73,$be,$84,$41,$72,$00,$29,$a1
>1d00	00 dc bd 8b 41 6f 73 55			.byte	$00,$dc,$bd,$8b,$41,$6f,$73,$55
>1d08	fd 04 33 34 8c 8b 41 6f			.byte	$fd,$04,$33,$34,$8c,$8b,$41,$6f
>1d10	73 55 fd 04 33 34 be 84			.byte	$73,$55,$fd,$04,$33,$34,$be,$84
>1d18	42 fd 0d 30 39 37 31 30			.byte	$42,$fd,$0d,$30,$39,$37,$31,$30
>1d20	32 37 33 65 31 31 00 14			.byte	$32,$37,$33,$65,$31,$31,$00,$14
>1d28	a2 00 dc bd 8b 41 45 5a			.byte	$a2,$00,$dc,$bd,$8b,$41,$45,$5a
>1d30	6e 86 8b 41 45 5a 6e be			.byte	$6e,$86,$8b,$41,$45,$5a,$6e,$be
>1d38	84 40 00 15 a3 00 dc bd			.byte	$84,$40,$00,$15,$a3,$00,$dc,$bd
>1d40	41 53 69 5a 80 41 6c 40			.byte	$41,$53,$69,$5a,$80,$41,$6c,$40
>1d48	6f be 84 41 40 40 4a 00			.byte	$6f,$be,$84,$41,$40,$40,$4a,$00
>1d50	14 a4 00 dc b2 41 67 43			.byte	$14,$a4,$00,$dc,$b2,$41,$67,$43
>1d58	7a bf 8b 76 79 5b be 84			.byte	$7a,$bf,$8b,$76,$79,$5b,$be,$84
>1d60	70 4a 5f 00 0d a5 00 dc			.byte	$70,$4a,$5f,$00,$0d,$a5,$00,$dc
>1d68	b4 41 65 be 84 fe 03 65			.byte	$b4,$41,$65,$be,$84,$fe,$03,$65
>1d70	00 1d a6 00 dc bd 4f 71			.byte	$00,$1d,$a6,$00,$dc,$bd,$4f,$71
>1d78	63 fd 05 34 34 31 8d 4f			.byte	$63,$fd,$05,$34,$34,$31,$8d,$4f
>1d80	71 63 fd 05 34 34 31 be			.byte	$71,$63,$fd,$05,$34,$34,$31,$be
>1d88	84 41 fd 03 30 00 14 a7			.byte	$84,$41,$fd,$03,$30,$00,$14,$a7
>1d90	00 dc bd 8b 42 63 6f 75			.byte	$00,$dc,$bd,$8b,$42,$63,$6f,$75
>1d98	8d 8b 42 63 6f 75 be 84			.byte	$8d,$8b,$42,$63,$6f,$75,$be,$84
>1da0	41 00 16 a8 00 dc bd 42			.byte	$41,$00,$16,$a8,$00,$dc,$bd,$42
>1da8	52 44 77 82 8b 42 47 76			.byte	$52,$44,$77,$82,$8b,$42,$47,$76
>1db0	4f be 84 8b 55 72 7a 00			.byte	$4f,$be,$84,$8b,$55,$72,$7a,$00
>1db8	10 a9 00 dc 98 8b 42 6f			.byte	$10,$a9,$00,$dc,$98,$8b,$42,$6f
>1dc0	41 46 84 42 6f 41 45 00			.byte	$41,$46,$84,$42,$6f,$41,$45,$00
>1dc8	15 aa 00 dc a3 4a be 84			.byte	$15,$aa,$00,$dc,$a3,$4a,$be,$84
>1dd0	fe 0c 20 20 20 20 20 20			.byte	$fe,$0c,$20,$20,$20,$20,$20,$20
>1dd8	20 20 20 20 00 1d ab 00			.byte	$20,$20,$20,$20,$00,$1d,$ab,$00
>1de0	dc bd 8b 42 7f 5e 5d fd			.byte	$dc,$bd,$8b,$42,$7f,$5e,$5d,$fd
>1de8	04 37 32 84 8b 42 7f 5e			.byte	$04,$37,$32,$84,$8b,$42,$7f,$5e
>1df0	5d fd 04 37 32 be 84 8b			.byte	$5d,$fd,$04,$37,$32,$be,$84,$8b
>1df8	41 00 0d ac 00 dc bd 40			.byte	$41,$00,$0d,$ac,$00,$dc,$bd,$40
>1e00	87 40 be 84 8b 41 00 15			.byte	$87,$40,$be,$84,$8b,$41,$00,$15
>1e08	ad 00 dc bd 42 62 53 66			.byte	$ad,$00,$dc,$bd,$42,$62,$53,$66
>1e10	80 42 40 64 73 be 84 42			.byte	$80,$42,$40,$64,$73,$be,$84,$42
>1e18	40 40 62 00 1a ae 00 dc			.byte	$40,$40,$62,$00,$1a,$ae,$00,$dc
>1e20	a5 a4 43 50 42 76 fd 04			.byte	$a5,$a4,$43,$50,$42,$76,$fd,$04
>1e28	33 34 be be 84 43 50 42			.byte	$33,$34,$be,$be,$84,$43,$50,$42
>1e30	76 fd 04 33 34 00 13 af			.byte	$76,$fd,$04,$33,$34,$00,$13,$af
>1e38	00 dc a7 42 4d 7f 61 be			.byte	$00,$dc,$a7,$42,$4d,$7f,$61,$be
>1e40	84 fe 07 38 44 46 45 31			.byte	$84,$fe,$07,$38,$44,$46,$45,$31
>1e48	00 1a b0 00 dc bd 55 4d			.byte	$00,$1a,$b0,$00,$dc,$bd,$55,$4d
>1e50	78 fd 05 39 32 39 88 55			.byte	$78,$fd,$05,$39,$32,$39,$88,$55
>1e58	4d 78 fd 05 39 32 39 be			.byte	$4d,$78,$fd,$05,$39,$32,$39,$be
>1e60	84 40 00 14 b1 00 dc bd			.byte	$84,$40,$00,$14,$b1,$00,$dc,$bd
>1e68	8b 42 4d 5d 5b 88 8b 42			.byte	$8b,$42,$4d,$5d,$5b,$88,$8b,$42
>1e70	4d 5d 5b be 84 40 00 14			.byte	$4d,$5d,$5b,$be,$84,$40,$00,$14
>1e78	b2 00 dc bd 5d 5a 46 82			.byte	$b2,$00,$dc,$bd,$5d,$5a,$46,$82
>1e80	8b 60 69 6c be 84 8b 7d			.byte	$8b,$60,$69,$6c,$be,$84,$8b,$7d
>1e88	73 6e 00 10 b3 00 dc 9a			.byte	$73,$6e,$00,$10,$b3,$00,$dc,$9a
>1e90	42 6d 48 7d be 84 42 6d			.byte	$42,$6d,$48,$7d,$be,$84,$42,$6d
>1e98	48 7d 00 0c b4 00 dc af			.byte	$48,$7d,$00,$0c,$b4,$00,$dc,$af
>1ea0	fe 03 30 be 84 40 00 27			.byte	$fe,$03,$30,$be,$84,$40,$00,$27
>1ea8	b5 00 dc bd 42 44 59 62			.byte	$b5,$00,$dc,$bd,$42,$44,$59,$62
>1eb0	fd 04 32 31 8c 42 44 59			.byte	$fd,$04,$32,$31,$8c,$42,$44,$59
>1eb8	62 fd 04 32 31 be 84 42			.byte	$62,$fd,$04,$32,$31,$be,$84,$42
>1ec0	fd 0d 39 34 30 39 36 30			.byte	$fd,$0d,$39,$34,$30,$39,$36,$30
>1ec8	32 31 65 31 31 00 15 b6			.byte	$32,$31,$65,$31,$31,$00,$15,$b6
>1ed0	00 dc bd 8b 42 6e 5b 77			.byte	$00,$dc,$bd,$8b,$42,$6e,$5b,$77
>1ed8	84 8b 42 6e 5b 77 be 84			.byte	$84,$8b,$42,$6e,$5b,$77,$be,$84
>1ee0	8b 41 00 15 b7 00 dc bd			.byte	$8b,$41,$00,$15,$b7,$00,$dc,$bd
>1ee8	8b 42 74 7a 78 80 42 61			.byte	$8b,$42,$74,$7a,$78,$80,$42,$61
>1ef0	6c 40 be 84 41 44 40 00			.byte	$6c,$40,$be,$84,$41,$44,$40,$00
>1ef8	0e b8 00 dc b3 8b 4a 45			.byte	$0e,$b8,$00,$dc,$b3,$8b,$4a,$45
>1f00	45 be 84 8b 41 00 1d b9			.byte	$45,$be,$84,$8b,$41,$00,$1d,$b9
>1f08	00 dc a0 fe 0c 70 76 74			.byte	$00,$dc,$a0,$fe,$0c,$70,$76,$74
>1f10	67 74 7a 67 75 73 79 bf			.byte	$67,$74,$7a,$67,$75,$73,$79,$bf
>1f18	45 be 84 fe 07 70 76 74			.byte	$45,$be,$84,$fe,$07,$70,$76,$74
>1f20	67 74 00 20 ba 00 dc bd			.byte	$67,$74,$00,$20,$ba,$00,$dc,$bd
>1f28	43 73 7b 53 fd 04 37 37			.byte	$43,$73,$7b,$53,$fd,$04,$37,$37
>1f30	8b 8b 42 74 7d 58 fd 03			.byte	$8b,$8b,$42,$74,$7d,$58,$fd,$03
>1f38	32 be 84 46 68 78 6c fd			.byte	$32,$be,$84,$46,$68,$78,$6c,$fd
>1f40	03 30 00 12 bb 00 dc bd			.byte	$03,$30,$00,$12,$bb,$00,$dc,$bd
>1f48	43 66 57 51 86 43 66 57			.byte	$43,$66,$57,$51,$86,$43,$66,$57
>1f50	51 be 84 40 00 16 bc 00			.byte	$51,$be,$84,$40,$00,$16,$bc,$00
>1f58	dc bd 8b 42 49 68 71 82			.byte	$dc,$bd,$8b,$42,$49,$68,$71,$82
>1f60	42 47 45 7b be 84 8b 4e			.byte	$42,$47,$45,$7b,$be,$84,$8b,$4e
>1f68	6d 4c 00 14 bd 00 dc b2			.byte	$6d,$4c,$00,$14,$bd,$00,$dc,$b2
>1f70	5f 61 44 bf 8b 42 4f 5a			.byte	$5f,$61,$44,$bf,$8b,$42,$4f,$5a
>1f78	7d be 84 5f 61 44 00 0e			.byte	$7d,$be,$84,$5f,$61,$44,$00,$0e
>1f80	be 00 dc a1 fe 02 bf 41			.byte	$be,$00,$dc,$a1,$fe,$02,$bf,$41
>1f88	be 84 fe 02 00 1a bf 00			.byte	$be,$84,$fe,$02,$00,$1a,$bf,$00
>1f90	dc bd 43 72 6d 6d fd 04			.byte	$dc,$bd,$43,$72,$6d,$6d,$fd,$04
>1f98	34 34 88 43 72 6d 6d fd			.byte	$34,$34,$88,$43,$72,$6d,$6d,$fd
>1fa0	04 34 34 be 84 40 00 11			.byte	$04,$34,$34,$be,$84,$40,$00,$11
>1fa8	c0 00 dc bd 54 60 70 87			.byte	$c0,$00,$dc,$bd,$54,$60,$70,$87
>1fb0	54 60 70 be 84 8b 41 00			.byte	$54,$60,$70,$be,$84,$8b,$41,$00
>1fb8	16 c1 00 dc bd 8b 42 62			.byte	$16,$c1,$00,$dc,$bd,$8b,$42,$62
>1fc0	6b 6c 81 42 6d 72 4b be			.byte	$6b,$6c,$81,$42,$6d,$72,$4b,$be
>1fc8	84 8b 42 49 61 00 10 c2			.byte	$84,$8b,$42,$49,$61,$00,$10,$c2
>1fd0	00 dc 98 43 71 43 4d 84			.byte	$00,$dc,$98,$43,$71,$43,$4d,$84
>1fd8	8b 43 71 43 4e 00 10 c3			.byte	$8b,$43,$71,$43,$4e,$00,$10,$c3
>1fe0	00 dc a2 fe 02 bf 4a bf			.byte	$00,$dc,$a2,$fe,$02,$bf,$4a,$bf
>1fe8	48 be 84 fe 02 00 1c c4			.byte	$48,$be,$84,$fe,$02,$00,$1c,$c4
>1ff0	00 dc bd 8b 41 69 62 52			.byte	$00,$dc,$bd,$8b,$41,$69,$62,$52
>1ff8	fd 04 33 34 86 8b 41 69			.byte	$fd,$04,$33,$34,$86,$8b,$41,$69
>2000	62 52 fd 04 33 34 be 84			.byte	$62,$52,$fd,$04,$33,$34,$be,$84
>2008	40 00 14 c5 00 dc bd 8b			.byte	$40,$00,$14,$c5,$00,$dc,$bd,$8b
>2010	42 52 51 78 88 8b 42 52			.byte	$42,$52,$51,$78,$88,$8b,$42,$52
>2018	51 78 be 84 40 00 16 c6			.byte	$51,$78,$be,$84,$40,$00,$16,$c6
>2020	00 dc bd 8b 41 71 7e 64			.byte	$00,$dc,$bd,$8b,$41,$71,$7e,$64
>2028	82 8b 41 4d 63 74 be 84			.byte	$82,$8b,$41,$4d,$63,$74,$be,$84
>2030	7c 5d 50 00 1c c7 00 dc			.byte	$7c,$5d,$50,$00,$1c,$c7,$00,$dc
>2038	a5 a4 8b 41 58 45 5b fd			.byte	$a5,$a4,$8b,$41,$58,$45,$5b,$fd
>2040	04 31 39 be be 84 8b 41			.byte	$04,$31,$39,$be,$be,$84,$8b,$41
>2048	58 45 5b fd 04 31 39 00			.byte	$58,$45,$5b,$fd,$04,$31,$39,$00
>2050	13 c8 00 dc a6 fe 0a 68			.byte	$13,$c8,$00,$dc,$a6,$fe,$0a,$68
>2058	75 63 79 72 6b 78 70 be			.byte	$75,$63,$79,$72,$6b,$78,$70,$be
>2060	84 48 00 24 c9 00 dc bd			.byte	$84,$48,$00,$24,$c9,$00,$dc,$bd
>2068	8b 41 53 4c 59 fd 04 39			.byte	$8b,$41,$53,$4c,$59,$fd,$04,$39
>2070	34 8a 8b 41 53 4c 59 fd			.byte	$34,$8a,$8b,$41,$53,$4c,$59,$fd
>2078	04 39 34 be 84 8b 42 66			.byte	$04,$39,$34,$be,$84,$8b,$42,$66
>2080	58 73 fd 04 38 38 00 15			.byte	$58,$73,$fd,$04,$38,$38,$00,$15
>2088	ca 00 dc bd 8b 42 65 5f			.byte	$ca,$00,$dc,$bd,$8b,$42,$65,$5f
>2090	5a 87 8b 42 65 5f 5a be			.byte	$5a,$87,$8b,$42,$65,$5f,$5a,$be
>2098	84 8b 41 00 15 cb 00 dc			.byte	$84,$8b,$41,$00,$15,$cb,$00,$dc
>20a0	bd 42 51 63 74 80 8b 42			.byte	$bd,$42,$51,$63,$74,$80,$8b,$42
>20a8	66 4f 45 be 84 51 60 70			.byte	$66,$4f,$45,$be,$84,$51,$60,$70
>20b0	00 0a cc 00 dc 9a 40 be			.byte	$00,$0a,$cc,$00,$dc,$9a,$40,$be
>20b8	84 40 00 1b cd 00 dc bd			.byte	$84,$40,$00,$1b,$cd,$00,$dc,$bd
>20c0	41 5d 4d 7c fd 04 38 39			.byte	$41,$5d,$4d,$7c,$fd,$04,$38,$39
>20c8	84 41 5d 4d 7c fd 04 38			.byte	$84,$41,$5d,$4d,$7c,$fd,$04,$38
>20d0	39 be 84 8b 41 00 12 ce			.byte	$39,$be,$84,$8b,$41,$00,$12,$ce
>20d8	00 dc bd 41 68 56 61 85			.byte	$00,$dc,$bd,$41,$68,$56,$61,$85
>20e0	41 68 56 61 be 84 40 00			.byte	$41,$68,$56,$61,$be,$84,$40,$00
>20e8	15 cf 00 dc bd 42 4e 45			.byte	$15,$cf,$00,$dc,$bd,$42,$4e,$45
>20f0	62 80 8b 67 6e 46 be 84			.byte	$62,$80,$8b,$67,$6e,$46,$be,$84
>20f8	42 48 41 62 00 0d d0 00			.byte	$42,$48,$41,$62,$00,$0d,$d0,$00
>2100	dc b3 41 42 6f 5a be 84			.byte	$dc,$b3,$41,$42,$6f,$5a,$be,$84
>2108	41 00 0d d1 00 dc b4 41			.byte	$41,$00,$0d,$d1,$00,$dc,$b4,$41
>2110	60 be 84 fe 03 60 00 1a			.byte	$60,$be,$84,$fe,$03,$60,$00,$1a
>2118	d2 00 dc bd 8b 6d 79 69			.byte	$d2,$00,$dc,$bd,$8b,$6d,$79,$69
>2120	fd 04 34 36 88 8b 6d 79			.byte	$fd,$04,$34,$36,$88,$8b,$6d,$79
>2128	69 fd 04 34 36 be 84 40			.byte	$69,$fd,$04,$34,$36,$be,$84,$40
>2130	00 15 d3 00 dc bd 8b 41			.byte	$00,$15,$d3,$00,$dc,$bd,$8b,$41
>2138	5c 76 5d 87 8b 41 5c 76			.byte	$5c,$76,$5d,$87,$8b,$41,$5c,$76
>2140	5d be 84 8b 41 00 15 d4			.byte	$5d,$be,$84,$8b,$41,$00,$15,$d4
>2148	00 dc bd 41 6e 4e 51 82			.byte	$00,$dc,$bd,$41,$6e,$4e,$51,$82
>2150	43 5c 4f 58 be 84 42 72			.byte	$43,$5c,$4f,$58,$be,$84,$42,$72
>2158	41 49 00 17 d5 00 dc b2			.byte	$41,$49,$00,$17,$d5,$00,$dc,$b2
>2160	8b 42 7e 5e 60 bf 8b 43			.byte	$8b,$42,$7e,$5e,$60,$bf,$8b,$43
>2168	4d 4d 7b be 84 42 7e 5e			.byte	$4d,$4d,$7b,$be,$84,$42,$7e,$5e
>2170	60 00 1b d6 00 dc a3 50			.byte	$60,$00,$1b,$d6,$00,$dc,$a3,$50
>2178	be 84 fe 12 20 20 20 20			.byte	$be,$84,$fe,$12,$20,$20,$20,$20
>2180	20 20 20 20 20 20 20 20			.byte	$20,$20,$20,$20,$20,$20,$20,$20
>2188	20 20 20 20 00 1c d7 00			.byte	$20,$20,$20,$20,$00,$1c,$d7,$00
>2190	dc bd 8b 41 62 7c 53 fd			.byte	$dc,$bd,$8b,$41,$62,$7c,$53,$fd
>2198	04 32 35 86 8b 41 62 7c			.byte	$04,$32,$35,$86,$8b,$41,$62,$7c
>21a0	53 fd 04 32 35 be 84 40			.byte	$53,$fd,$04,$32,$35,$be,$84,$40
>21a8	00 12 d8 00 dc bd 8b 57			.byte	$00,$12,$d8,$00,$dc,$bd,$8b,$57
>21b0	5b 49 88 8b 57 5b 49 be			.byte	$5b,$49,$88,$8b,$57,$5b,$49,$be
>21b8	84 40 00 14 d9 00 dc bd			.byte	$84,$40,$00,$14,$d9,$00,$dc,$bd
>21c0	8b 4c 45 47 82 79 47 5e			.byte	$8b,$4c,$45,$47,$82,$79,$47,$5e
>21c8	be 84 8b 75 42 59 00 0e			.byte	$be,$84,$8b,$75,$42,$59,$00,$0e
>21d0	da 00 dc 98 48 6e 42 84			.byte	$da,$00,$dc,$98,$48,$6e,$42,$84
>21d8	8b 48 6e 43 00 13 db 00			.byte	$8b,$48,$6e,$43,$00,$13,$db,$00
>21e0	dc a7 42 71 40 53 be 84			.byte	$dc,$a7,$42,$71,$40,$53,$be,$84
>21e8	fe 07 42 31 30 31 33 00			.byte	$fe,$07,$42,$31,$30,$31,$33,$00
>21f0	1f dc 00 dc bd 8b 42 67			.byte	$1f,$dc,$00,$dc,$bd,$8b,$42,$67
>21f8	6a 59 fd 04 37 38 8d 8b			.byte	$6a,$59,$fd,$04,$37,$38,$8d,$8b
>2200	42 67 6a 59 fd 04 37 38			.byte	$42,$67,$6a,$59,$fd,$04,$37,$38
>2208	be 84 41 fd 03 30 00 0c			.byte	$be,$84,$41,$fd,$03,$30,$00,$0c
>2210	dd 00 dc bd 40 8c 40 be			.byte	$dd,$00,$dc,$bd,$40,$8c,$40,$be
>2218	84 40 00 15 de 00 dc bd			.byte	$84,$40,$00,$15,$de,$00,$dc,$bd
>2220	42 67 73 40 81 8b 42 60			.byte	$42,$67,$73,$40,$81,$8b,$42,$60
>2228	58 79 be 84 8b 48 79 00			.byte	$58,$79,$be,$84,$8b,$48,$79,$00
>2230	12 df 00 dc a5 a4 41 75			.byte	$12,$df,$00,$dc,$a5,$a4,$41,$75
>2238	40 7d be be 84 41 75 40			.byte	$40,$7d,$be,$be,$84,$41,$75,$40
>2240	7d 00 0c e0 00 dc af fe			.byte	$7d,$00,$0c,$e0,$00,$dc,$af,$fe
>2248	03 30 be 84 40 00 1a e1			.byte	$03,$30,$be,$84,$40,$00,$1a,$e1
>2250	00 dc bd 49 42 48 fd 05			.byte	$00,$dc,$bd,$49,$42,$48,$fd,$05
>2258	30 38 38 85 49 42 48 fd			.byte	$30,$38,$38,$85,$49,$42,$48,$fd
>2260	05 30 38 38 be 84 40 00			.byte	$05,$30,$38,$38,$be,$84,$40,$00
>2268	15 e2 00 dc bd 42 45 52			.byte	$15,$e2,$00,$dc,$bd,$42,$45,$52
>2270	73 8a 42 45 52 73 be 84			.byte	$73,$8a,$42,$45,$52,$73,$be,$84
>2278	44 4a 65 66 00 17 e3 00			.byte	$44,$4a,$65,$66,$00,$17,$e3,$00
>2280	dc bd 42 68 75 62 81 8b			.byte	$dc,$bd,$42,$68,$75,$62,$81,$8b
>2288	43 69 5a 67 be 84 8b 41			.byte	$43,$69,$5a,$67,$be,$84,$8b,$41
>2290	41 4a 45 00 0f e4 00 dc			.byte	$41,$4a,$45,$00,$0f,$e4,$00,$dc
>2298	9a 8b 4d 7d 7a be 84 4d			.byte	$9a,$8b,$4d,$7d,$7a,$be,$84,$4d
>22a0	7d 7a 00 1c e5 00 dc a0			.byte	$7d,$7a,$00,$1c,$e5,$00,$dc,$a0
>22a8	fe 09 78 75 7a 6c 75 71			.byte	$fe,$09,$78,$75,$7a,$6c,$75,$71
>22b0	61 bf 47 be 84 fe 09 78			.byte	$61,$bf,$47,$be,$84,$fe,$09,$78
>22b8	75 7a 6c 75 71 61 00 1d			.byte	$75,$7a,$6c,$75,$71,$61,$00,$1d
>22c0	e6 00 dc bd 42 6e 63 61			.byte	$e6,$00,$dc,$bd,$42,$6e,$63,$61
>22c8	fd 04 32 33 8b 42 6e 63			.byte	$fd,$04,$32,$33,$8b,$42,$6e,$63
>22d0	61 fd 04 32 33 be 84 40			.byte	$61,$fd,$04,$32,$33,$be,$84,$40
>22d8	fd 03 30 00 14 e7 00 dc			.byte	$fd,$03,$30,$00,$14,$e7,$00,$dc
>22e0	bd 8b 42 58 6c 64 8d 8b			.byte	$bd,$8b,$42,$58,$6c,$64,$8d,$8b
>22e8	42 58 6c 64 be 84 41 00			.byte	$42,$58,$6c,$64,$be,$84,$41,$00
>22f0	16 e8 00 dc bd 8b 42 47			.byte	$16,$e8,$00,$dc,$bd,$8b,$42,$47
>22f8	5f 6d 81 43 54 5d 55 be			.byte	$5f,$6d,$81,$43,$54,$5d,$55,$be
>2300	84 8b 43 42 69 00 0d e9			.byte	$84,$8b,$43,$42,$69,$00,$0d,$e9
>2308	00 dc b3 42 60 5b 4a be			.byte	$00,$dc,$b3,$42,$60,$5b,$4a,$be
>2310	84 41 00 14 ea 00 dc a1			.byte	$84,$41,$00,$14,$ea,$00,$dc,$a1
>2318	fe 06 72 78 6c 65 bf 42			.byte	$fe,$06,$72,$78,$6c,$65,$bf,$42
>2320	be 84 fe 04 6c 65 00 19			.byte	$be,$84,$fe,$04,$6c,$65,$00,$19
>2328	eb 00 dc bd 65 52 59 fd			.byte	$eb,$00,$dc,$bd,$65,$52,$59,$fd
>2330	04 38 36 84 65 52 59 fd			.byte	$04,$38,$36,$84,$65,$52,$59,$fd
>2338	04 38 36 be 84 8b 41 00			.byte	$04,$38,$36,$be,$84,$8b,$41,$00
>2340	10 ec 00 dc bd 55 7e 42			.byte	$10,$ec,$00,$dc,$bd,$55,$7e,$42
>2348	88 55 7e 42 be 84 40 00			.byte	$88,$55,$7e,$42,$be,$84,$40,$00
>2350	16 ed 00 dc bd 8b 41 5d			.byte	$16,$ed,$00,$dc,$bd,$8b,$41,$5d
>2358	5e 6d 81 41 4e 43 71 be			.byte	$5e,$6d,$81,$41,$4e,$43,$71,$be
>2360	84 8b 51 5c 4d 00 15 ee			.byte	$84,$8b,$51,$5c,$4d,$00,$15,$ee
>2368	00 dc b2 41 6f 5f 6e bf			.byte	$00,$dc,$b2,$41,$6f,$5f,$6e,$bf
>2370	43 52 40 53 be 84 41 6f			.byte	$43,$52,$40,$53,$be,$84,$41,$6f
>2378	5f 6e 00 15 ef 00 dc a2			.byte	$5f,$6e,$00,$15,$ef,$00,$dc,$a2
>2380	fe 07 6c 63 6e 72 6c bf			.byte	$fe,$07,$6c,$63,$6e,$72,$6c,$bf
>2388	49 bf 49 be 84 fe 02 00			.byte	$49,$bf,$49,$be,$84,$fe,$02,$00
>2390	1d f0 00 dc bd 42 55 4e			.byte	$1d,$f0,$00,$dc,$bd,$42,$55,$4e
>2398	40 fd 04 32 37 8d 42 55			.byte	$40,$fd,$04,$32,$37,$8d,$42,$55
>23a0	4e 40 fd 04 32 37 be 84			.byte	$4e,$40,$fd,$04,$32,$37,$be,$84
>23a8	41 fd 03 30 00 12 f1 00			.byte	$41,$fd,$03,$30,$00,$12,$f1,$00
>23b0	dc bd 42 41 63 4b 85 42			.byte	$dc,$bd,$42,$41,$63,$4b,$85,$42
>23b8	41 63 4b be 84 40 00 0f			.byte	$41,$63,$4b,$be,$84,$40,$00,$0f
>23c0	f2 00 dc bd 40 80 41 6a			.byte	$f2,$00,$dc,$bd,$40,$80,$41,$6a
>23c8	63 73 be 84 40 00 10 f3			.byte	$63,$73,$be,$84,$40,$00,$10,$f3
>23d0	00 dc 98 41 44 7c 4c 84			.byte	$00,$dc,$98,$41,$44,$7c,$4c,$84
>23d8	8b 41 44 7c 4d 00 13 f4			.byte	$8b,$41,$44,$7c,$4d,$00,$13,$f4
>23e0	00 dc a6 fe 0a 62 69 6a			.byte	$00,$dc,$a6,$fe,$0a,$62,$69,$6a
>23e8	62 6d 72 63 78 be 84 48			.byte	$62,$6d,$72,$63,$78,$be,$84,$48
>23f0	00 1c f5 00 dc bd 8b 41			.byte	$00,$1c,$f5,$00,$dc,$bd,$8b,$41
>23f8	6c 71 42 fd 04 39 32 85			.byte	$6c,$71,$42,$fd,$04,$39,$32,$85
>2400	8b 41 6c 71 42 fd 04 39			.byte	$8b,$41,$6c,$71,$42,$fd,$04,$39
>2408	32 be 84 40 00 12 f6 00			.byte	$32,$be,$84,$40,$00,$12,$f6,$00
>2410	dc bd 8b 4a 48 56 85 8b			.byte	$dc,$bd,$8b,$4a,$48,$56,$85,$8b
>2418	4a 48 56 be 84 40 00 16			.byte	$4a,$48,$56,$be,$84,$40,$00,$16
>2420	f7 00 dc bd 8b 57 57 70			.byte	$f7,$00,$dc,$bd,$8b,$57,$57,$70
>2428	82 41 72 64 42 be 84 8b			.byte	$82,$41,$72,$64,$42,$be,$84,$8b
>2430	41 65 73 6e 00 1a f8 00			.byte	$41,$65,$73,$6e,$00,$1a,$f8,$00
>2438	dc a5 a4 43 6d 59 fd 05			.byte	$dc,$a5,$a4,$43,$6d,$59,$fd,$05
>2440	32 39 33 be be 84 43 6d			.byte	$32,$39,$33,$be,$be,$84,$43,$6d
>2448	59 fd 05 32 39 33 00 0f			.byte	$59,$fd,$05,$32,$39,$33,$00,$0f
>2450	f9 00 dc 9b fe 05 6f 64			.byte	$f9,$00,$dc,$9b,$fe,$05,$6f,$64
>2458	67 be 84 41 6f 00 1f fa			.byte	$67,$be,$84,$41,$6f,$00,$1f,$fa
>2460	00 dc bd 8b 42 6a 5d 50			.byte	$00,$dc,$bd,$8b,$42,$6a,$5d,$50
>2468	fd 04 33 37 8d 8b 42 6a			.byte	$fd,$04,$33,$37,$8d,$8b,$42,$6a
>2470	5d 50 fd 04 33 37 be 84			.byte	$5d,$50,$fd,$04,$33,$37,$be,$84
>2478	41 fd 03 30 00 0d fb 00			.byte	$41,$fd,$03,$30,$00,$0d,$fb,$00
>2480	dc bd 40 89 40 be 84 8b			.byte	$dc,$bd,$40,$89,$40,$be,$84,$8b
>2488	41 00 13 fc 00 dc bd 42			.byte	$41,$00,$13,$fc,$00,$dc,$bd,$42
>2490	57 63 62 80 63 4a 4f be			.byte	$57,$63,$62,$80,$63,$4a,$4f,$be
>2498	84 43 42 42 00 11 fd 00			.byte	$84,$43,$42,$42,$00,$11,$fd,$00
>24a0	dc 9a 8b 41 61 7c 67 be			.byte	$dc,$9a,$8b,$41,$61,$7c,$67,$be
>24a8	84 41 61 7c 67 00 0d fe			.byte	$84,$41,$61,$7c,$67,$00,$0d,$fe
>24b0	00 dc b4 41 60 be 84 fe			.byte	$00,$dc,$b4,$41,$60,$be,$84,$fe
>24b8	03 60 00 19 ff 00 dc bd			.byte	$03,$60,$00,$19,$ff,$00,$dc,$bd
>24c0	48 69 77 fd 04 35 39 84			.byte	$48,$69,$77,$fd,$04,$35,$39,$84
>24c8	48 69 77 fd 04 35 39 be			.byte	$48,$69,$77,$fd,$04,$35,$39,$be
>24d0	84 8b 41 00 0c 00 01 dc			.byte	$84,$8b,$41,$00,$0c,$00,$01,$dc
>24d8	bd 40 8c 40 be 84 40 00			.byte	$bd,$40,$8c,$40,$be,$84,$40,$00
>24e0	13 01 01 dc bd 41 45 40			.byte	$13,$01,$01,$dc,$bd,$41,$45,$40
>24e8	64 80 8b 43 5d 43 4e be			.byte	$64,$80,$8b,$43,$5d,$43,$4e,$be
>24f0	84 60 00 0c 02 01 dc b3			.byte	$84,$60,$00,$0c,$02,$01,$dc,$b3
>24f8	48 56 5d be 84 41 00 15			.byte	$48,$56,$5d,$be,$84,$41,$00,$15
>2500	03 01 dc a3 4a be 84 fe			.byte	$03,$01,$dc,$a3,$4a,$be,$84,$fe
>2508	0c 20 20 20 20 20 20 20			.byte	$0c,$20,$20,$20,$20,$20,$20,$20
>2510	20 20 20 00 1d 04 01 dc			.byte	$20,$20,$20,$00,$1d,$04,$01,$dc
>2518	bd 41 45 6e 5e fd 04 35			.byte	$bd,$41,$45,$6e,$5e,$fd,$04,$35
>2520	38 8b 41 45 6e 5e fd 04			.byte	$38,$8b,$41,$45,$6e,$5e,$fd,$04
>2528	35 38 be 84 40 fd 03 30			.byte	$35,$38,$be,$84,$40,$fd,$03,$30
>2530	00 14 05 01 dc bd 8b 41			.byte	$00,$14,$05,$01,$dc,$bd,$8b,$41
>2538	4a 7a 40 86 8b 41 4a 7a			.byte	$4a,$7a,$40,$86,$8b,$41,$4a,$7a
>2540	40 be 84 40 00 14 06 01			.byte	$40,$be,$84,$40,$00,$14,$06,$01
>2548	dc bd 76 7f 53 81 41 40			.byte	$dc,$bd,$76,$7f,$53,$81,$41,$40
>2550	43 62 be 84 41 76 7f 73			.byte	$43,$62,$be,$84,$41,$76,$7f,$73
>2558	00 17 07 01 dc b2 8b 42			.byte	$00,$17,$07,$01,$dc,$b2,$8b,$42
>2560	61 7e 56 bf 8b 43 6b 66			.byte	$61,$7e,$56,$bf,$8b,$43,$6b,$66
>2568	4d be 84 42 61 7e 56 00			.byte	$4d,$be,$84,$42,$61,$7e,$56,$00
>2570	13 08 01 dc a7 43 48 74			.byte	$13,$08,$01,$dc,$a7,$43,$48,$74
>2578	77 be 84 fe 07 43 38 44			.byte	$77,$be,$84,$fe,$07,$43,$38,$44
>2580	33 37 00 1a 09 01 dc bd			.byte	$33,$37,$00,$1a,$09,$01,$dc,$bd
>2588	42 5b 50 73 fd 04 35 34			.byte	$42,$5b,$50,$73,$fd,$04,$35,$34
>2590	85 42 5b 50 73 fd 04 35			.byte	$85,$42,$5b,$50,$73,$fd,$04,$35
>2598	34 be 84 40 00 14 0a 01			.byte	$34,$be,$84,$40,$00,$14,$0a,$01
>25a0	dc bd 8b 42 68 6d 7a 8d			.byte	$dc,$bd,$8b,$42,$68,$6d,$7a,$8d
>25a8	8b 42 68 6d 7a be 84 41			.byte	$8b,$42,$68,$6d,$7a,$be,$84,$41
>25b0	00 12 0b 01 dc bd 40 81			.byte	$00,$12,$0b,$01,$dc,$bd,$40,$81
>25b8	43 47 43 62 be 84 43 47			.byte	$43,$47,$43,$62,$be,$84,$43,$47
>25c0	43 62 00 10 0c 01 dc 98			.byte	$43,$62,$00,$10,$0c,$01,$dc,$98
>25c8	41 43 7d 57 84 8b 41 43			.byte	$41,$43,$7d,$57,$84,$8b,$41,$43
>25d0	7d 58 00 13 0d 01 dc af			.byte	$7d,$58,$00,$13,$0d,$01,$dc,$af
>25d8	fe 07 44 39 30 38 41 be			.byte	$fe,$07,$44,$39,$30,$38,$41,$be
>25e0	84 43 59 42 4a 00 1a 0e			.byte	$84,$43,$59,$42,$4a,$00,$1a,$0e
>25e8	01 dc bd 8b 41 7f 6c 70			.byte	$01,$dc,$bd,$8b,$41,$7f,$6c,$70
>25f0	fd 03 30 88 8b 41 7f 6c			.byte	$fd,$03,$30,$88,$8b,$41,$7f,$6c
>25f8	70 fd 03 30 be 84 40 00			.byte	$70,$fd,$03,$30,$be,$84,$40,$00
>2600	12 0f 01 dc bd 4c 75 63			.byte	$12,$0f,$01,$dc,$bd,$4c,$75,$63
>2608	8a 4c 75 63 be 84 59 6b			.byte	$8a,$4c,$75,$63,$be,$84,$59,$6b
>2610	46 00 12 10 01 dc bd 40			.byte	$46,$00,$12,$10,$01,$dc,$bd,$40
>2618	82 8b 64 45 62 be 84 8b			.byte	$82,$8b,$64,$45,$62,$be,$84,$8b
>2620	64 45 62 00 0c 11 01 dc			.byte	$64,$45,$62,$00,$0c,$11,$01,$dc
>2628	a5 a4 40 be be 84 40 00			.byte	$a5,$a4,$40,$be,$be,$84,$40,$00
>2630	10 12 01 dc a0 fe 04 62			.byte	$10,$12,$01,$dc,$a0,$fe,$04,$62
>2638	74 bf 40 be 84 fe 02 00			.byte	$74,$bf,$40,$be,$84,$fe,$02,$00
>2640	29 13 01 dc bd 8b 41 7a			.byte	$29,$13,$01,$dc,$bd,$8b,$41,$7a
>2648	68 6c fd 04 31 36 8c 8b			.byte	$68,$6c,$fd,$04,$31,$36,$8c,$8b
>2650	41 7a 68 6c fd 04 31 36			.byte	$41,$7a,$68,$6c,$fd,$04,$31,$36
>2658	be 84 42 fd 0d 35 32 33			.byte	$be,$84,$42,$fd,$0d,$35,$32,$33
>2660	32 31 35 32 39 65 31 31			.byte	$32,$31,$35,$32,$39,$65,$31,$31
>2668	00 13 14 01 dc bd 43 58			.byte	$00,$13,$14,$01,$dc,$bd,$43,$58
>2670	47 72 89 43 58 47 72 be			.byte	$47,$72,$89,$43,$58,$47,$72,$be
>2678	84 8b 41 00 18 15 01 dc			.byte	$84,$8b,$41,$00,$18,$15,$01,$dc
>2680	bd 8b 42 49 4d 4b 80 8b			.byte	$bd,$8b,$42,$49,$4d,$4b,$80,$8b
>2688	43 72 7e 5d be 84 8b 43			.byte	$43,$72,$7e,$5d,$be,$84,$8b,$43
>2690	7b 7f 5f 00 11 16 01 dc			.byte	$7b,$7f,$5f,$00,$11,$16,$01,$dc
>2698	9a 8b 41 6b 54 45 be 84			.byte	$9a,$8b,$41,$6b,$54,$45,$be,$84
>26a0	41 6b 54 45 00 0e 17 01			.byte	$41,$6b,$54,$45,$00,$0e,$17,$01
>26a8	dc a1 fe 02 bf 49 be 84			.byte	$dc,$a1,$fe,$02,$bf,$49,$be,$84
>26b0	fe 02 00 1a 18 01 dc bd			.byte	$fe,$02,$00,$1a,$18,$01,$dc,$bd
>26b8	43 44 77 4d fd 04 32 31			.byte	$43,$44,$77,$4d,$fd,$04,$32,$31
>26c0	85 43 44 77 4d fd 04 32			.byte	$85,$43,$44,$77,$4d,$fd,$04,$32
>26c8	31 be 84 40 00 16 19 01			.byte	$31,$be,$84,$40,$00,$16,$19,$01
>26d0	dc bd 8b 7f 7f 42 8a 8b			.byte	$dc,$bd,$8b,$7f,$7f,$42,$8a,$8b
>26d8	7f 7f 42 be 84 8b 41 7f			.byte	$7f,$7f,$42,$be,$84,$8b,$41,$7f
>26e0	7e 44 00 15 1a 01 dc bd			.byte	$7e,$44,$00,$15,$1a,$01,$dc,$bd
>26e8	42 77 6d 58 80 8b 43 6a			.byte	$42,$77,$6d,$58,$80,$8b,$43,$6a
>26f0	75 60 be 84 55 48 40 00			.byte	$75,$60,$be,$84,$55,$48,$40,$00
>26f8	0d 1b 01 dc b3 43 60 46			.byte	$0d,$1b,$01,$dc,$b3,$43,$60,$46
>2700	73 be 84 41 00 12 1c 01			.byte	$73,$be,$84,$41,$00,$12,$1c,$01
>2708	dc a2 fe 04 79 63 bf 44			.byte	$dc,$a2,$fe,$04,$79,$63,$bf,$44
>2710	bf 42 be 84 fe 02 00 1d			.byte	$bf,$42,$be,$84,$fe,$02,$00,$1d
>2718	1d 01 dc bd 8b 42 58 6a			.byte	$1d,$01,$dc,$bd,$8b,$42,$58,$6a
>2720	4c fd 04 38 34 84 8b 42			.byte	$4c,$fd,$04,$38,$34,$84,$8b,$42
>2728	58 6a 4c fd 04 38 34 be			.byte	$58,$6a,$4c,$fd,$04,$38,$34,$be
>2730	84 8b 41 00 14 1e 01 dc			.byte	$84,$8b,$41,$00,$14,$1e,$01,$dc
>2738	bd 8b 41 6a 79 7f 8b 8b			.byte	$bd,$8b,$41,$6a,$79,$7f,$8b,$8b
>2740	41 6a 79 7f be 84 40 00			.byte	$41,$6a,$79,$7f,$be,$84,$40,$00
>2748	16 1f 01 dc bd 8b 6b 72			.byte	$16,$1f,$01,$dc,$bd,$8b,$6b,$72
>2750	60 82 43 70 69 59 be 84			.byte	$60,$82,$43,$70,$69,$59,$be,$84
>2758	8b 43 5b 5b 47 00 15 20			.byte	$8b,$43,$5b,$5b,$47,$00,$15,$20
>2760	01 dc b2 42 55 6b 56 bf			.byte	$01,$dc,$b2,$42,$55,$6b,$56,$bf
>2768	41 4c 75 7c be 84 41 48			.byte	$41,$4c,$75,$7c,$be,$84,$41,$48
>2770	75 5a 00 10 21 01 dc a6			.byte	$75,$5a,$00,$10,$21,$01,$dc,$a6
>2778	fe 07 6f 6e 63 75 69 be			.byte	$fe,$07,$6f,$6e,$63,$75,$69,$be
>2780	84 45 00 1a 22 01 dc bd			.byte	$84,$45,$00,$1a,$22,$01,$dc,$bd
>2788	41 6b 63 4c fd 04 31 38			.byte	$41,$6b,$63,$4c,$fd,$04,$31,$38
>2790	86 41 6b 63 4c fd 04 31			.byte	$86,$41,$6b,$63,$4c,$fd,$04,$31
>2798	38 be 84 40 00 11 23 01			.byte	$38,$be,$84,$40,$00,$11,$23,$01
>27a0	dc bd 6c 75 76 89 6c 75			.byte	$dc,$bd,$6c,$75,$76,$89,$6c,$75
>27a8	76 be 84 8b 41 00 15 24			.byte	$76,$be,$84,$8b,$41,$00,$15,$24
>27b0	01 dc bd 41 58 5d 5c 81			.byte	$01,$dc,$bd,$41,$58,$5d,$5c,$81
>27b8	43 5d 56 49 be 84 43 5d			.byte	$43,$5d,$56,$49,$be,$84,$43,$5d
>27c0	5f 5d 00 0e 25 01 dc 98			.byte	$5f,$5d,$00,$0e,$25,$01,$dc,$98
>27c8	51 73 5a 84 8b 51 73 5b			.byte	$51,$73,$5a,$84,$8b,$51,$73,$5b
>27d0	00 0d 26 01 dc 9b fe 03			.byte	$00,$0d,$26,$01,$dc,$9b,$fe,$03
>27d8	66 be 84 41 66 00 1b 27			.byte	$66,$be,$84,$41,$66,$00,$1b,$27
>27e0	01 dc bd 41 6d 71 43 fd			.byte	$01,$dc,$bd,$41,$6d,$71,$43,$fd
>27e8	04 32 38 89 41 6d 71 43			.byte	$04,$32,$38,$89,$41,$6d,$71,$43
>27f0	fd 04 32 38 be 84 8b 41			.byte	$fd,$04,$32,$38,$be,$84,$8b,$41
>27f8	00 15 28 01 dc bd 8b 4b			.byte	$00,$15,$28,$01,$dc,$bd,$8b,$4b
>2800	54 4e 8a 8b 67 5e 46 be			.byte	$54,$4e,$8a,$8b,$67,$5e,$46,$be
>2808	84 8b 72 72 54 00 13 29			.byte	$84,$8b,$72,$72,$54,$00,$13,$29
>2810	01 dc bd 5e 41 40 80 41			.byte	$01,$dc,$bd,$5e,$41,$40,$80,$41
>2818	4b 5c 4d be 84 4a 40 40			.byte	$4b,$5c,$4d,$be,$84,$4a,$40,$40
>2820	00 14 2a 01 dc a5 a4 8b			.byte	$00,$14,$2a,$01,$dc,$a5,$a4,$8b
>2828	41 54 5d 5b be be 84 8b			.byte	$41,$54,$5d,$5b,$be,$be,$84,$8b
>2830	41 54 5d 5b 00 0d 2b 01			.byte	$41,$54,$5d,$5b,$00,$0d,$2b,$01
>2838	dc b4 41 58 be 84 fe 03			.byte	$dc,$b4,$41,$58,$be,$84,$fe,$03
>2840	58 00 1d 2c 01 dc bd 41			.byte	$58,$00,$1d,$2c,$01,$dc,$bd,$41
>2848	7e 6f 79 fd 04 37 33 8b			.byte	$7e,$6f,$79,$fd,$04,$37,$33,$8b
>2850	41 7e 6f 79 fd 04 37 33			.byte	$41,$7e,$6f,$79,$fd,$04,$37,$33
>2858	be 84 40 fd 03 30 00 12			.byte	$be,$84,$40,$fd,$03,$30,$00,$12
>2860	2d 01 dc bd 43 58 59 7d			.byte	$2d,$01,$dc,$bd,$43,$58,$59,$7d
>2868	86 43 58 59 7d be 84 40			.byte	$86,$43,$58,$59,$7d,$be,$84,$40
>2870	00 14 2e 01 dc bd 41 7d			.byte	$00,$14,$2e,$01,$dc,$bd,$41,$7d
>2878	75 49 81 6d 42 6c be 84			.byte	$75,$49,$81,$6d,$42,$6c,$be,$84
>2880	41 7d 77 6d 00 10 2f 01			.byte	$41,$7d,$77,$6d,$00,$10,$2f,$01
>2888	dc 9a 41 78 5d 76 be 84			.byte	$dc,$9a,$41,$78,$5d,$76,$be,$84
>2890	41 78 5d 76 00 1f 30 01			.byte	$41,$78,$5d,$76,$00,$1f,$30,$01
>2898	dc a3 54 be 84 fe 16 20			.byte	$dc,$a3,$54,$be,$84,$fe,$16,$20
>28a0	20 20 20 20 20 20 20 20			.byte	$20,$20,$20,$20,$20,$20,$20,$20
>28a8	20 20 20 20 20 20 20 20			.byte	$20,$20,$20,$20,$20,$20,$20,$20
>28b0	20 20 20 00 1d 31 01 dc			.byte	$20,$20,$20,$00,$1d,$31,$01,$dc
>28b8	bd 41 5c 5c 5f fd 04 34			.byte	$bd,$41,$5c,$5c,$5f,$fd,$04,$34
>28c0	39 8b 41 5c 5c 5f fd 04			.byte	$39,$8b,$41,$5c,$5c,$5f,$fd,$04
>28c8	34 39 be 84 40 fd 03 30			.byte	$34,$39,$be,$84,$40,$fd,$03,$30
>28d0	00 15 32 01 dc bd 43 5c			.byte	$00,$15,$32,$01,$dc,$bd,$43,$5c
>28d8	52 52 8a 43 5c 52 52 be			.byte	$52,$52,$8a,$43,$5c,$52,$52,$be
>28e0	84 46 78 64 64 00 16 33			.byte	$84,$46,$78,$64,$64,$00,$16,$33
>28e8	01 dc bd 8b 42 48 4a 77			.byte	$01,$dc,$bd,$8b,$42,$48,$4a,$77
>28f0	82 4c 48 50 be 84 8b 42			.byte	$82,$4c,$48,$50,$be,$84,$8b,$42
>28f8	44 42 67 00 0a 34 01 dc			.byte	$44,$42,$67,$00,$0a,$34,$01,$dc
>2900	b3 40 be 84 40 00 0c 35			.byte	$b3,$40,$be,$84,$40,$00,$0c,$35
>2908	01 dc a7 40 be 84 fe 03			.byte	$01,$dc,$a7,$40,$be,$84,$fe,$03
>2910	30 00 1d 36 01 dc bd 42			.byte	$30,$00,$1d,$36,$01,$dc,$bd,$42
>2918	49 55 79 fd 04 31 33 8d			.byte	$49,$55,$79,$fd,$04,$31,$33,$8d
>2920	42 49 55 79 fd 04 31 33			.byte	$42,$49,$55,$79,$fd,$04,$31,$33
>2928	be 84 41 fd 03 30 00 12			.byte	$be,$84,$41,$fd,$03,$30,$00,$12
>2930	37 01 dc bd 43 50 57 68			.byte	$37,$01,$dc,$bd,$43,$50,$57,$68
>2938	8b 43 50 57 68 be 84 40			.byte	$8b,$43,$50,$57,$68,$be,$84,$40
>2940	00 15 38 01 dc bd 43 6c			.byte	$00,$15,$38,$01,$dc,$bd,$43,$6c
>2948	5b 68 81 41 57 5e 50 be			.byte	$5b,$68,$81,$41,$57,$5e,$50,$be
>2950	84 43 7f 5f 78 00 16 39			.byte	$84,$43,$7f,$5f,$78,$00,$16,$39
>2958	01 dc b2 8b 41 79 7f 5f			.byte	$01,$dc,$b2,$8b,$41,$79,$7f,$5f
>2960	bf 43 5b 5b 45 be 84 41			.byte	$bf,$43,$5b,$5b,$45,$be,$84,$41
>2968	79 7f 5f 00 13 3a 01 dc			.byte	$79,$7f,$5f,$00,$13,$3a,$01,$dc
>2970	af fe 07 46 31 36 44 37			.byte	$af,$fe,$07,$46,$31,$36,$44,$37
>2978	be 84 43 71 5b 57 00 1c			.byte	$be,$84,$43,$71,$5b,$57,$00,$1c
>2980	3b 01 dc bd 8b 41 68 5f			.byte	$3b,$01,$dc,$bd,$8b,$41,$68,$5f
>2988	69 fd 04 33 32 86 8b 41			.byte	$69,$fd,$04,$33,$32,$86,$8b,$41
>2990	68 5f 69 fd 04 33 32 be			.byte	$68,$5f,$69,$fd,$04,$33,$32,$be
>2998	84 40 00 13 3c 01 dc bd			.byte	$84,$40,$00,$13,$3c,$01,$dc,$bd
>29a0	8b 61 4d 51 89 8b 61 4d			.byte	$8b,$61,$4d,$51,$89,$8b,$61,$4d
>29a8	51 be 84 8b 41 00 18 3d			.byte	$51,$be,$84,$8b,$41,$00,$18,$3d
>29b0	01 dc bd 8b 43 65 71 7d			.byte	$01,$dc,$bd,$8b,$43,$65,$71,$7d
>29b8	81 8b 42 71 7f 46 be 84			.byte	$81,$8b,$42,$71,$7f,$46,$be,$84
>29c0	8b 42 61 71 45 00 10 3e			.byte	$8b,$42,$61,$71,$45,$00,$10,$3e
>29c8	01 dc 98 43 61 7a 72 84			.byte	$01,$dc,$98,$43,$61,$7a,$72,$84
>29d0	8b 43 61 7a 73 00 18 3f			.byte	$8b,$43,$61,$7a,$73,$00,$18,$3f
>29d8	01 dc a0 fe 09 62 6e 6c			.byte	$01,$dc,$a0,$fe,$09,$62,$6e,$6c
>29e0	7a 6d 6c 76 bf 43 be 84			.byte	$7a,$6d,$6c,$76,$bf,$43,$be,$84
>29e8	fe 05 62 6e 6c 00 1c 40			.byte	$fe,$05,$62,$6e,$6c,$00,$1c,$40
>29f0	01 dc bd 8b 4e 42 6f fd			.byte	$01,$dc,$bd,$8b,$4e,$42,$6f,$fd
>29f8	05 31 34 32 88 8b 4e 42			.byte	$05,$31,$34,$32,$88,$8b,$4e,$42
>2a00	6f fd 05 31 34 32 be 84			.byte	$6f,$fd,$05,$31,$34,$32,$be,$84
>2a08	40 00 13 41 01 dc bd 41			.byte	$40,$00,$13,$41,$01,$dc,$bd,$41
>2a10	73 51 5c 89 41 73 51 5c			.byte	$73,$51,$5c,$89,$41,$73,$51,$5c
>2a18	be 84 8b 41 00 16 42 01			.byte	$be,$84,$8b,$41,$00,$16,$42,$01
>2a20	dc bd 8b 41 5b 46 65 80			.byte	$dc,$bd,$8b,$41,$5b,$46,$65,$80
>2a28	43 5e 75 74 be 84 42 44			.byte	$43,$5e,$75,$74,$be,$84,$42,$44
>2a30	71 50 00 1a 43 01 dc a5			.byte	$71,$50,$00,$1a,$43,$01,$dc,$a5
>2a38	a4 43 52 4f 45 fd 04 37			.byte	$a4,$43,$52,$4f,$45,$fd,$04,$37
>2a40	37 be be 84 43 52 4f 45			.byte	$37,$be,$be,$84,$43,$52,$4f,$45
>2a48	fd 04 37 37 00 18 44 01			.byte	$fd,$04,$37,$37,$00,$18,$44,$01
>2a50	dc a1 fe 07 63 75 73 66			.byte	$dc,$a1,$fe,$07,$63,$75,$73,$66
>2a58	6f bf 46 be 84 fe 07 63			.byte	$6f,$bf,$46,$be,$84,$fe,$07,$63
>2a60	75 73 66 6f 00 1d 45 01			.byte	$75,$73,$66,$6f,$00,$1d,$45,$01
>2a68	dc bd 8b 42 62 77 63 fd			.byte	$dc,$bd,$8b,$42,$62,$77,$63,$fd
>2a70	04 38 37 87 8b 42 62 77			.byte	$04,$38,$37,$87,$8b,$42,$62,$77
>2a78	63 fd 04 38 37 be 84 8b			.byte	$63,$fd,$04,$38,$37,$be,$84,$8b
>2a80	41 00 13 46 01 dc bd 42			.byte	$41,$00,$13,$46,$01,$dc,$bd,$42
>2a88	63 6b 7e 89 42 63 6b 7e			.byte	$63,$6b,$7e,$89,$42,$63,$6b,$7e
>2a90	be 84 8b 41 00 15 47 01			.byte	$be,$84,$8b,$41,$00,$15,$47,$01
>2a98	dc bd 41 77 5f 55 81 41			.byte	$dc,$bd,$41,$77,$5f,$55,$81,$41
>2aa0	5f 46 47 be 84 41 7f 5f			.byte	$5f,$46,$47,$be,$84,$41,$7f,$5f
>2aa8	57 00 10 48 01 dc 9a 41			.byte	$57,$00,$10,$48,$01,$dc,$9a,$41
>2ab0	4c 5d 45 be 84 41 4c 5d			.byte	$4c,$5d,$45,$be,$84,$41,$4c,$5d
>2ab8	45 00 19 49 01 dc a2 fe			.byte	$45,$00,$19,$49,$01,$dc,$a2,$fe
>2ac0	0b 62 71 6a 70 66 78 66			.byte	$0b,$62,$71,$6a,$70,$66,$78,$66
>2ac8	71 72 bf 43 bf 40 be 84			.byte	$71,$72,$bf,$43,$bf,$40,$be,$84
>2ad0	fe 02 00 1b 4a 01 dc bd			.byte	$fe,$02,$00,$1b,$4a,$01,$dc,$bd
>2ad8	41 42 48 41 fd 04 35 39			.byte	$41,$42,$48,$41,$fd,$04,$35,$39
>2ae0	87 41 42 48 41 fd 04 35			.byte	$87,$41,$42,$48,$41,$fd,$04,$35
>2ae8	39 be 84 8b 41 00 15 4b			.byte	$39,$be,$84,$8b,$41,$00,$15,$4b
>2af0	01 dc bd 8b 42 7d 41 5f			.byte	$01,$dc,$bd,$8b,$42,$7d,$41,$5f
>2af8	84 8b 42 7d 41 5f be 84			.byte	$84,$8b,$42,$7d,$41,$5f,$be,$84
>2b00	8b 41 00 15 4c 01 dc bd			.byte	$8b,$41,$00,$15,$4c,$01,$dc,$bd
>2b08	42 6c 4a 7e 82 8b 70 7d			.byte	$42,$6c,$4a,$7e,$82,$8b,$70,$7d
>2b10	be 84 8b 42 6c 7a 43 00			.byte	$be,$84,$8b,$42,$6c,$7a,$43,$00
>2b18	0f 4d 01 dc b3 8b 42 7d			.byte	$0f,$4d,$01,$dc,$b3,$8b,$42,$7d
>2b20	51 75 be 84 8b 41 00 0f			.byte	$51,$75,$be,$84,$8b,$41,$00,$0f
>2b28	4e 01 dc a6 fe 06 78 70			.byte	$4e,$01,$dc,$a6,$fe,$06,$78,$70
>2b30	62 66 be 84 44 00 27 4f			.byte	$62,$66,$be,$84,$44,$00,$27,$4f
>2b38	01 dc bd 41 5d 75 48 fd			.byte	$01,$dc,$bd,$41,$5d,$75,$48,$fd
>2b40	04 30 32 8c 41 5d 75 48			.byte	$04,$30,$32,$8c,$41,$5d,$75,$48
>2b48	fd 04 30 32 be 84 41 fd			.byte	$fd,$04,$30,$32,$be,$84,$41,$fd
>2b50	0d 34 37 37 30 38 30 33			.byte	$0d,$34,$37,$37,$30,$38,$30,$33
>2b58	30 65 31 31 00 11 50 01			.byte	$30,$65,$31,$31,$00,$11,$50,$01
>2b60	dc bd 4f 5f 6c 87 4f 5f			.byte	$dc,$bd,$4f,$5f,$6c,$87,$4f,$5f
>2b68	6c be 84 8b 41 00 17 51			.byte	$6c,$be,$84,$8b,$41,$00,$17,$51
>2b70	01 dc bd 43 6b 50 7a 82			.byte	$01,$dc,$bd,$43,$6b,$50,$7a,$82
>2b78	8b 41 59 6e 4d be 84 8b			.byte	$8b,$41,$59,$6e,$4d,$be,$84,$8b
>2b80	42 72 7e 77 00 14 52 01			.byte	$42,$72,$7e,$77,$00,$14,$52,$01
>2b88	dc b2 42 7c 7d 44 bf 42			.byte	$dc,$b2,$42,$7c,$7d,$44,$bf,$42
>2b90	78 58 64 be 84 44 64 60			.byte	$78,$58,$64,$be,$84,$44,$64,$60
>2b98	00 10 53 01 dc 9b fe 06			.byte	$00,$10,$53,$01,$dc,$9b,$fe,$06
>2ba0	62 63 6a 78 be 84 41 62			.byte	$62,$63,$6a,$78,$be,$84,$41,$62
>2ba8	00 29 54 01 dc bd 8b 42			.byte	$00,$29,$54,$01,$dc,$bd,$8b,$42
>2bb0	49 65 45 fd 04 33 34 8c			.byte	$49,$65,$45,$fd,$04,$33,$34,$8c
>2bb8	8b 42 49 65 45 fd 04 33			.byte	$8b,$42,$49,$65,$45,$fd,$04,$33
>2bc0	34 be 84 43 fd 0d 31 37			.byte	$34,$be,$84,$43,$fd,$0d,$31,$37
>2bc8	35 36 30 38 30 35 65 31			.byte	$35,$36,$30,$38,$30,$35,$65,$31
>2bd0	31 00 12 55 01 dc bd 41			.byte	$31,$00,$12,$55,$01,$dc,$bd,$41
>2bd8	72 65 4b 88 41 72 65 4b			.byte	$72,$65,$4b,$88,$41,$72,$65,$4b
>2be0	be 84 40 00 10 56 01 dc			.byte	$be,$84,$40,$00,$10,$56,$01,$dc
>2be8	bd 40 80 8b 42 73 41 6e			.byte	$bd,$40,$80,$8b,$42,$73,$41,$6e
>2bf0	be 84 40 00 10 57 01 dc			.byte	$be,$84,$40,$00,$10,$57,$01,$dc
>2bf8	98 42 57 6b 4f 84 8b 42			.byte	$98,$42,$57,$6b,$4f,$84,$8b,$42
>2c00	57 6b 50 00 0d 58 01 dc			.byte	$57,$6b,$50,$00,$0d,$58,$01,$dc
>2c08	b4 41 75 be 84 fe 03 75			.byte	$b4,$41,$75,$be,$84,$fe,$03,$75
>2c10	00 1c 59 01 dc bd 8b 43			.byte	$00,$1c,$59,$01,$dc,$bd,$8b,$43
>2c18	41 6c 5e fd 04 30 38 88			.byte	$41,$6c,$5e,$fd,$04,$30,$38,$88
>2c20	8b 43 41 6c 5e fd 04 30			.byte	$8b,$43,$41,$6c,$5e,$fd,$04,$30
>2c28	38 be 84 40 00 18 5a 01			.byte	$38,$be,$84,$40,$00,$18,$5a,$01
>2c30	dc bd 8b 42 54 49 40 8a			.byte	$dc,$bd,$8b,$42,$54,$49,$40,$8a
>2c38	8b 42 54 49 40 be 84 8b			.byte	$8b,$42,$54,$49,$40,$be,$84,$8b
>2c40	44 68 52 40 00 14 5b 01			.byte	$44,$68,$52,$40,$00,$14,$5b,$01
>2c48	dc bd 40 81 8b 42 45 70			.byte	$dc,$bd,$40,$81,$8b,$42,$45,$70
>2c50	62 be 84 8b 42 45 70 62			.byte	$62,$be,$84,$8b,$42,$45,$70,$62
>2c58	00 12 5c 01 dc a5 a4 41			.byte	$00,$12,$5c,$01,$dc,$a5,$a4,$41
>2c60	45 70 7e be be 84 41 45			.byte	$45,$70,$7e,$be,$be,$84,$41,$45
>2c68	70 7e 00 1c 5d 01 dc a3			.byte	$70,$7e,$00,$1c,$5d,$01,$dc,$a3
>2c70	51 be 84 fe 13 20 20 20			.byte	$51,$be,$84,$fe,$13,$20,$20,$20
>2c78	20 20 20 20 20 20 20 20			.byte	$20,$20,$20,$20,$20,$20,$20,$20
>2c80	20 20 20 20 20 20 00 29			.byte	$20,$20,$20,$20,$20,$20,$00,$29
>2c88	5e 01 d6 fe 22 50 61 73			.byte	$5e,$01,$d6,$fe,$22,$50,$61,$73
>2c90	73 65 64 20 41 72 69 74			.byte	$73,$65,$64,$20,$41,$72,$69,$74
>2c98	68 6d 65 74 69 63 2c 4c			.byte	$68,$6d,$65,$74,$69,$63,$2c,$4c
>2ca0	6f 67 69 63 61 6c 2c 55			.byte	$6f,$67,$69,$63,$61,$6c,$2c,$55
>2ca8	6e 61 72 79 2e c0 c4 00			.byte	$6e,$61,$72,$79,$2e,$c0,$c4,$00
>2cb0	00					.byte	$00

;******  Return to file: modules/hardware/em6502.asm

.c000					StartROM:
.c000	a2 ff		ldx #$ff			ldx 		#$FF 					; empty stack
.c002	9a		txs				txs
.c003	20 b4 c1	jsr $c1b4			jsr 	IF_Reset 					; reset external interface
.c006	20 0c c0	jsr $c00c			jsr 	IFT_ClearScreen
.c009	4c 74 c6	jmp $c674		jmp BASIC_Start

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.c00c					IFT_ClearScreen:
.c00c	48		pha				pha
.c00d	da		phx				phx
.c00e	5a		phy				phy
.c00f	20 b5 c1	jsr $c1b5			jsr 	IF_Home 					; home cursor
.c012	a2 20		ldx #$20			ldx 	#IF_Height 					; this many lines.
.c014					_IFT_CS0:
.c014	a0 40		ldy #$40			ldy 	#IF_Width 					; this many chars/line
.c016					_IFT_CS1:
.c016	a9 20		lda #$20			lda 	#' '						; clear line.
.c018	20 b8 c1	jsr $c1b8			jsr 	IF_Write
.c01b	88		dey				dey
.c01c	d0 f8		bne $c016			bne 	_IFT_CS1
.c01e	20 b6 c1	jsr $c1b6			jsr 	IF_NewLine 					; next line down
.c021	ca		dex				dex
.c022	d0 f0		bne $c014			bne 	_IFT_CS0
.c024	7a		ply				ply
.c025	fa		plx				plx
.c026	68		pla				pla
.c027					IFT_HomeCursor:
.c027	48		pha				pha
.c028	20 b5 c1	jsr $c1b5			jsr 	IF_Home
.c02b	a9 00		lda #$00			lda 	#0
.c02d	8d 00 02	sta $0200			sta 	IFT_XCursor
.c030	8d 01 02	sta $0201			sta 	IFT_YCursor
.c033	68		pla				pla
.c034	60		rts				rts
.c035					IFT_UpLine:
.c035	48		pha				pha
.c036	ad 01 02	lda $0201			lda  	IFT_YCursor 				; get Y
.c039	3a		dec a				dec 	a 							; line above
.c03a	30 03		bmi $c03f			bmi 	_IFTULExit 					; too far, abort
.c03c	20 d7 c0	jsr $c0d7			jsr 	IFT_SetYPos					; set to that line.
.c03f					_IFTULExit:
.c03f	68		pla				pla
.c040	60		rts				rts
.c041					IFT_PrintCharacter:
.c041	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.c043	f0 23		beq $c068			beq 	IFT_NewLine
.c045	48		pha				pha
.c046	20 80 c0	jsr $c080			jsr 	IFT_UpperCase 				; make upper case
.c049	20 b8 c1	jsr $c1b8			jsr 	IF_Write 					; write out.
.c04c	ee 00 02	inc $0200			inc 	IFT_XCursor 				; bump x cursor
.c04f	ad 00 02	lda $0200			lda 	IFT_XCursor 				; reached RHS ?
.c052	c9 40		cmp #$40			cmp 	#IF_Width
.c054	d0 03		bne $c059			bne 	_IFT_PCNotEOL
.c056	20 68 c0	jsr $c068			jsr 	IFT_NewLine 				; if so do new line.
.c059					_IFT_PCNotEOL:
.c059	68		pla				pla
.c05a	60		rts				rts
.c05b					IFT_Tab:
.c05b	a9 20		lda #$20			lda 	#" " 						; space
.c05d	20 41 c0	jsr $c041			jsr 	IFT_PrintCharacter
.c060	ad 00 02	lda $0200			lda 	IFT_XCursor 				; until x % 8 == 0
.c063	29 07		and #$07			and 	#7
.c065	d0 f4		bne $c05b			bne 	IFT_Tab
.c067	60		rts				rts
.c068					IFT_NewLine:
.c068	48		pha				pha
.c069	20 b6 c1	jsr $c1b6			jsr 	IF_NewLine 					; new line on actual screen.
.c06c	a9 00		lda #$00			lda 	#0 							; reset x position
.c06e	8d 00 02	sta $0200			sta 	IFT_XCursor
.c071	ee 01 02	inc $0201			inc 	IFT_YCursor 				; move down.
.c074	ad 01 02	lda $0201			lda 	IFT_YCursor
.c077	c9 20		cmp #$20			cmp 	#IF_Height 					; reached bottom.
.c079	d0 03		bne $c07e			bne 	_IFT_NL_NotEOS
.c07b	20 8b c0	jsr $c08b			jsr 	IFT_Scroll 					; scroll screen up.
.c07e					_IFT_NL_NotEOS:
.c07e	68		pla				pla
.c07f	60		rts				rts
.c080					IFT_UpperCase:
.c080	c9 61		cmp #$61			cmp 	#"a"
.c082	90 06		bcc $c08a			bcc 	_IFT_UCExit
.c084	c9 7b		cmp #$7b			cmp 	#"z"+1
.c086	b0 02		bcs $c08a			bcs 	_IFT_UCExit
.c088	49 20		eor #$20			eor 	#$20
.c08a					_IFT_UCExit:
.c08a	60		rts				rts
.c08b					IFT_Scroll:
.c08b	48		pha				pha 								; save AXY
.c08c	da		phx				phx
.c08d	5a		phy				phy
.c08e	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.c090					_IFT_SLoop:
.c090	20 b0 c0	jsr $c0b0			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.c093	e8		inx				inx
.c094	e0 1f		cpx #$1f			cpx 	#IF_Height-1				; do whole screen
.c096	d0 f8		bne $c090			bne 	_IFT_SLoop
.c098	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.c09a	20 d7 c0	jsr $c0d7			jsr 	IFT_SetYPos
.c09d	a2 40		ldx #$40			ldx 	#IF_Width 					; blank line
.c09f					_IFT_SBlank:
.c09f	a9 20		lda #$20			lda 	#32
.c0a1	20 b8 c1	jsr $c1b8			jsr 	IF_Write
.c0a4	ca		dex				dex
.c0a5	d0 f8		bne $c09f			bne 	_IFT_SBlank
.c0a7	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.c0a9	20 d7 c0	jsr $c0d7			jsr 	IFT_SetYPos
.c0ac	7a		ply				ply
.c0ad	fa		plx				plx
.c0ae	68		pla				pla
.c0af	60		rts				rts
.c0b0					_IFT_ScrollLine:
.c0b0	da		phx				phx
.c0b1	da		phx				phx
.c0b2	8a		txa				txa 								; copy line into buffer.
.c0b3	1a		inc a				inc 	a 							; next line down.
.c0b4	20 d7 c0	jsr $c0d7			jsr 	IFT_SetYPos
.c0b7	a2 00		ldx #$00			ldx 	#0
.c0b9					_IFTScrollCopy1:
.c0b9	20 b7 c1	jsr $c1b7			jsr 	IF_Read
.c0bc	9d 02 02	sta $0202,x			sta 	IFT_Buffer,x
.c0bf	e8		inx				inx
.c0c0	e0 40		cpx #$40			cpx 	#IF_Width
.c0c2	d0 f5		bne $c0b9			bne 	_IFTScrollCopy1
.c0c4	68		pla				pla
.c0c5	20 d7 c0	jsr $c0d7			jsr 	IFT_SetYPos
.c0c8	a2 00		ldx #$00			ldx 	#0
.c0ca					_IFTScrollCopy2:
.c0ca	bd 02 02	lda $0202,x			lda 	IFT_Buffer,x
.c0cd	20 b8 c1	jsr $c1b8			jsr 	IF_Write
.c0d0	e8		inx				inx
.c0d1	e0 40		cpx #$40			cpx 	#IF_Width
.c0d3	d0 f5		bne $c0ca			bne 	_IFTScrollCopy2
.c0d5	fa		plx				plx
.c0d6	60		rts				rts
.c0d7					IFT_SetYPos:
.c0d7	48		pha				pha
.c0d8	da		phx				phx
.c0d9	aa		tax				tax
.c0da	20 27 c0	jsr $c027			jsr 	IFT_HomeCursor
.c0dd	e0 00		cpx #$00			cpx 	#0
.c0df	f0 09		beq $c0ea			beq 	_IFT_MOAExit
.c0e1					_IFT_MOALoop:
.c0e1	20 b6 c1	jsr $c1b6			jsr 	IF_NewLine
.c0e4	ee 01 02	inc $0201			inc 	IFT_YCursor
.c0e7	ca		dex				dex
.c0e8	d0 f7		bne $c0e1			bne		_IFT_MOALoop
.c0ea					_IFT_MOAExit:
.c0ea	fa		plx				plx
.c0eb	68		pla				pla
.c0ec	60		rts				rts
.c0ed					IFT_GetKeyCursor:
.c0ed	20 f5 c0	jsr $c0f5			jsr 	_IFT_FlipCursor 			; reverse current
.c0f0					_IFT_GKCWait:
.c0f0	20 bb c1	jsr $c1bb			jsr 	IF_GetKey 					; get key
.c0f3	f0 fb		beq $c0f0			beq 	_IFT_GKCWait
.c0f5					_IFT_FlipCursor:
.c0f5	48		pha				pha 								; save
.c0f6	20 b7 c1	jsr $c1b7			jsr 	IF_Read 					; read
.c0f9	20 b9 c1	jsr $c1b9			jsr 	IF_LeftOne
.c0fc	49 80		eor #$80			eor 	#$80 						; reverse
.c0fe	20 b8 c1	jsr $c1b8			jsr 	IF_Write 					; write
.c101	20 b9 c1	jsr $c1b9			jsr 	IF_LeftOne
.c104	68		pla				pla
.c105	60		rts				rts
.c106					IFT_ReadLine:
.c106	48		pha				pha
.c107					_IFT_RLLoop:
.c107	20 ed c0	jsr $c0ed			jsr 	IFT_GetKeyCursor 			; get keystroke
.c10a	c9 0d		cmp #$0d			cmp 	#13							; return
.c10c	f0 7d		beq $c18b			beq 	_IFT_RLExit
.c10e	c9 20		cmp #$20			cmp 	#32 						; control character
.c110	90 05		bcc $c117			bcc 	_IFT_Control
.c112	20 41 c0	jsr $c041			jsr 	IFT_PrintCharacter
.c115	80 f0		bra $c107			bra 	_IFT_RLLoop
.c117					_IFT_Control:
.c117	c9 01		cmp #$01			cmp 	#"A"-64
.c119	f0 26		beq $c141			beq 	_IFT_Left
.c11b	c9 04		cmp #$04			cmp 	#"D"-64
.c11d	f0 2e		beq $c14d			beq 	_IFT_Right
.c11f	c9 17		cmp #$17			cmp 	#"W"-64
.c121	f0 36		beq $c159			beq 	_IFT_Up
.c123	c9 13		cmp #$13			cmp 	#"S"-64
.c125	f0 3e		beq $c165			beq 	_IFT_Down
.c127	c9 08		cmp #$08			cmp 	#"H"-64
.c129	f0 09		beq $c134			beq 	_IFT_Backspace
.c12b	c9 1a		cmp #$1a			cmp 	#"Z"-64
.c12d	d0 d8		bne $c107			bne 	_IFT_RLLoop
.c12f	20 0c c0	jsr $c00c			jsr 	IFT_ClearScreen				; clear CTL-Z
.c132	80 d3		bra $c107			bra 	_IFT_RLLoop
.c134					_IFT_Backspace:
.c134	ad 00 02	lda $0200			lda 	IFT_XCursor 				; check not start of line.
.c137	f0 ce		beq $c107			beq 	_IFT_RLLoop
.c139	20 b9 c1	jsr $c1b9			jsr 	IF_LeftOne
.c13c	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.c13e	20 b8 c1	jsr $c1b8			jsr 	IF_Write
.c141					_IFT_Left:
.c141	ce 00 02	dec $0200			dec 	IFT_XCursor 				; left CTL-W
.c144	10 29		bpl $c16f			bpl 	_IFT_Reposition
.c146	a9 3f		lda #$3f			lda 	#IF_Width-1
.c148					_IFT_SetX:
.c148	8d 00 02	sta $0200			sta 	IFT_XCursor
.c14b	80 22		bra $c16f			bra 	_IFT_Reposition
.c14d					_IFT_Right:
.c14d	ee 00 02	inc $0200			inc 	IFT_XCursor
.c150	ad 00 02	lda $0200			lda 	IFT_XCursor
.c153	49 40		eor #$40			eor 	#IF_Width
.c155	f0 f1		beq $c148			beq 	_IFT_SetX
.c157	80 16		bra $c16f			bra 	_IFT_Reposition
.c159					_IFT_Up:
.c159	ce 01 02	dec $0201			dec 	IFT_YCursor
.c15c	10 11		bpl $c16f			bpl 	_IFT_Reposition
.c15e	a9 1f		lda #$1f			lda 	#IF_Height-1
.c160					_IFT_SetY:
.c160	8d 01 02	sta $0201			sta 	IFT_YCursor
.c163	80 0a		bra $c16f			bra 	_IFT_Reposition
.c165					_IFT_Down:
.c165	ee 01 02	inc $0201			inc 	IFT_YCursor
.c168	ad 01 02	lda $0201			lda 	IFT_YCursor
.c16b	49 20		eor #$20			eor 	#IF_Height
.c16d	f0 f1		beq $c160			beq 	_IFT_SetY
.c16f					_IFT_Reposition:
.c16f	ad 00 02	lda $0200			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.c172	48		pha				pha
.c173	ad 01 02	lda $0201			lda 	IFT_YCursor
.c176	20 d7 c0	jsr $c0d7			jsr 	IFT_SetYPos
.c179	68		pla				pla
.c17a	aa		tax				tax
.c17b	e0 00		cpx #$00			cpx 	#0
.c17d	f0 88		beq $c107			beq 	_IFT_RLLoop
.c17f					_IFT_MoveRight:
.c17f	20 b7 c1	jsr $c1b7			jsr 	IF_Read
.c182	ee 00 02	inc $0200			inc 	IFT_XCursor
.c185	ca		dex				dex
.c186	d0 f7		bne $c17f			bne 	_IFT_MoveRight
.c188	4c 07 c1	jmp $c107			jmp 	_IFT_RLLoop
.c18b					_IFT_RLExit:
.c18b	ad 01 02	lda $0201			lda 	IFT_YCursor 				; go to start of line.
.c18e	20 d7 c0	jsr $c0d7			jsr 	IFT_SetYPos
.c191	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.c193					_IFT_RLRead:
.c193	20 b7 c1	jsr $c1b7			jsr 	IF_Read
.c196	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.c199	e8		inx				inx
.c19a	e0 40		cpx #$40			cpx 	#IF_Width
.c19c	d0 f5		bne $c193			bne 	_IFT_RLRead
.c19e					_IFT_RL_Trim:
.c19e	ca		dex				dex 	 							; previous char
.c19f	30 07		bmi $c1a8			bmi 	_IFT_Found 					; gone too far
.c1a1	bd 66 02	lda $0266,x			lda 	IFT_LineBuffer,x			; go back if space
.c1a4	c9 20		cmp #$20			cmp 	#" "
.c1a6	f0 f6		beq $c19e			beq 	_IFT_RL_Trim
.c1a8					_IFT_Found:
.c1a8	e8		inx				inx 								; forward to non-space
.c1a9	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.c1ab	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.c1ae	68		pla				pla
.c1af	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.c1b1	a0 02		ldy #$02			ldy 	#IFT_LineBuffer >> 8
.c1b3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_em6502.asm

=64					IF_Width 	= 64 							; characters across
=32					IF_Height 	= 32 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line.
=8					IF_XPos 	= 8 							; current position, horizontal.
=$f0000					IF_Screen = $F0000							; 2k screen RAM here
=$f8010					IF_PKeyboard = $F8010						; Keyboard port.
=$f8000					IF_PBreak = $F8000 							; Break key.
.c1b4					IF_Reset:
.c1b4	60		rts				rts
.c1b5					IF_Home:
.c1b5	60		rts				rts
.c1b6					IF_NewLine:
.c1b6					_IF_NoCarry:
.c1b6	60		rts				rts
.c1b7					IF_Read:
.c1b7	60		rts				rts
.c1b8					IF_Write:
.c1b8	60		rts				rts
.c1b9					IF_LeftOne:
.c1b9	60		rts				rts
.c1ba					IF_CheckBreak:
.c1ba	60		rts				rts
.c1bb					IF_GetKey:
.c1bb					_IFGK_NoKey:
.c1bb	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.c1bc					TIM_Error:
.c1bc	20 35 c0	jsr $c035			jsr 	IFT_UpLine 					; go up one line.
.c1bf	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.c1c1	80 02		bra $c1c5			bra 	TIM_ShowPrompt
.c1c3					TIM_NewCommand:
.c1c3	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.c1c5					TIM_ShowPrompt:
.c1c5	20 41 c0	jsr $c041			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.c1c8	20 06 c1	jsr $c106			jsr 	IFT_ReadLine	 			; get character, go to next line
.c1cb	20 68 c0	jsr $c068			jsr 	IFT_NewLine					; go to next line.
.c1ce	86 10		stx $10				stx 	zTemp1 						; save line read address
.c1d0	84 11		sty $11				sty 	zTemp1+1
.c1d2	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.c1d4	b1 10		lda ($10),y			lda 	(zTemp1),y
.c1d6	c9 3f		cmp #$3f			cmp 	#"?"
.c1d8	f0 04		beq $c1de			beq 	TIM_SkipFirst
.c1da	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.c1dc	d0 01		bne $c1df			bne 	TIM_NotDot
.c1de					TIM_SkipFirst:
.c1de	c8		iny				iny
.c1df					TIM_NotDot:
.c1df	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.c1e1	c9 52		cmp #$52			cmp 	#"R"						; show registers
.c1e3	f0 6b		beq $c250			beq 	TIM_ShowRegisters
.c1e5	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.c1e7	f0 12		beq $c1fb			beq 	TIM_ShowMemory
.c1e9	c9 47		cmp #$47			cmp 	#"G"						; execute
.c1eb	f0 49		beq $c236			beq 	TIM_Execute
.c1ed	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.c1ef	f0 07		beq $c1f8			beq 	TIM_GoLoadMemory
.c1f1	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.c1f3	d0 c7		bne $c1bc			bne 	TIM_Error
.c1f5	4c 73 c3	jmp $c373			jmp 	TIM_UpdateRegisters
.c1f8					TIM_GoLoadMemory:
.c1f8	4c a3 c3	jmp $c3a3			jmp 	TIM_LoadMemory
.c1fb					TIM_ShowMemory:
.c1fb	20 ef c2	jsr $c2ef			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.c1fe	b0 bc		bcs $c1bc			bcs 	TIM_Error
.c200	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.c202	85 12		sta $12				sta 	zTemp2
.c204	a5 15		lda $15				lda 	zTemp3+1
.c206	85 13		sta $13				sta 	zTemp2+1
.c208	20 ef c2	jsr $c2ef			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.c20b	90 08		bcc $c215			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.c20d	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.c20f	85 14		sta $14				sta 	zTemp3
.c211	a5 13		lda $13				lda 	zTemp2+1
.c213	85 15		sta $15				sta 	zTemp3+1
.c215					_TIMSM_Start:
.c215	20 c7 c2	jsr $c2c7			jsr 	TIM_WriteLine 				; write one line of hex out
.c218	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.c21a	18		clc				clc
.c21b	69 10		adc #$10			adc 	#16
.c21d	85 12		sta $12				sta 	zTemp2
.c21f	90 02		bcc $c223			bcc 	_TIMSM_NoCarry
.c221	e6 13		inc $13				inc 	zTemp2+1
.c223					_TIMSM_NoCarry:
.c223	20 ba c1	jsr $c1ba			jsr 	IF_CheckBreak 				; check CTL+C
.c226	d0 0b		bne $c233			bne 	_TIMSM_Ends 				; if pressed break out.
.c228	38		sec				sec 								; check past the end address in zTemp3
.c229	a5 14		lda $14				lda 	zTemp3
.c22b	e5 12		sbc $12				sbc 	zTemp2
.c22d	a5 15		lda $15				lda 	zTemp3+1
.c22f	e5 13		sbc $13				sbc 	zTemp2+1
.c231	10 e2		bpl $c215			bpl 	_TIMSM_Start
.c233					_TIMSM_Ends:
.c233	4c c3 c1	jmp $c1c3			jmp 	TIM_NewCommand
.c236					TIM_Execute:
.c236	20 ef c2	jsr $c2ef			jsr 	TIM_GetHex 					; get the execute address
.c239	b0 81		bcs $c1bc			bcs 	TIM_Error 					; not legitimate
.c23b	ae b1 04	ldx $04b1			ldx 	TIM_SP 						; set up SP
.c23e	9a		txs				txs
.c23f	ad ac 04	lda $04ac			lda 	TIM_SR 						; Status for PLP
.c242	48		pha				pha
.c243	ad ad 04	lda $04ad			lda 	TIM_A 						; restore AXYZ
.c246	ae ae 04	ldx $04ae			ldx 	TIM_X
.c249	ac af 04	ldy $04af			ldy 	TIM_Y
.c24c	28		plp				plp 								; and PS Byte.
.c24d	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.c250					TIM_Start:
.c250					TIM_ShowRegisters:
.c250	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.c253	8d ab 04	sta $04ab			sta 	TIM_IRQ+1
.c256	ad ff ff	lda $ffff			lda 	$FFFF
.c259	8d aa 04	sta $04aa			sta 	TIM_IRQ
.c25c	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.c25e					_TIMSR_Text:
.c25e	bd 8e c2	lda $c28e,x			lda 	_TIMSR_Label,x
.c261	20 41 c0	jsr $c041			jsr 	IFT_PrintCharacter
.c264	e8		inx				inx
.c265	e0 20		cpx #$20			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.c267	d0 f5		bne $c25e			bne 	_TIMSR_Text
.c269	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.c26b					_TIMSR_Skip:
.c26b	e8		inx				inx
.c26c					_TIMSR_LoopSpace:
.c26c	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.c26e	b0 04		bcs $c274			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.c270	8a		txa				txa
.c271	4a		lsr a				lsr 	a
.c272	b0 05		bcs $c279			bcs 	_TIMSR_NoSpace
.c274					_TIMSR_Space:
.c274	a9 20		lda #$20			lda 	#" "
.c276	20 41 c0	jsr $c041			jsr 	IFT_PrintCharacter
.c279					_TIMSR_NoSpace:
.c279	bd a8 04	lda $04a8,x			lda 	TIM_PC,x 					; output hex value.
.c27c	20 ae c2	jsr $c2ae			jsr 	TIM_WriteHex
.c27f	e8		inx				inx
.c280	e0 08		cpx #$08			cpx 	#TIM_Z-TIM_PC
.c282	f0 e7		beq $c26b			beq 	_TIMSR_Skip
.c284	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.c286	d0 e4		bne $c26c			bne 	_TimSR_LoopSpace
.c288	20 68 c0	jsr $c068			jsr 	IFT_NewLine 				; new line
.c28b	4c c3 c1	jmp $c1c3			jmp	 	TIM_NewCommand 				; new command.
.c28e					_TIMSR_Label:
>c28e	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>c296	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>c2a6	52
>c2a7	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.c2ae					_TIMSR_LabelEnd:
.c2ae					TIM_WriteHex:
.c2ae	48		pha				pha 								; save A
.c2af	4a		lsr a				lsr 	a 							; shift MSB->LSB
.c2b0	4a		lsr a				lsr 	a
.c2b1	4a		lsr a				lsr 	a
.c2b2	4a		lsr a				lsr 	a
.c2b3	20 b7 c2	jsr $c2b7			jsr 	_TIMWH_Nibble 				; print MSB
.c2b6	68		pla				pla 								; restore and print LSB
.c2b7					_TIMWH_Nibble:
.c2b7	48		pha				pha
.c2b8	29 0f		and #$0f			and 	#15 						; mask out
.c2ba	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.c2bc	90 02		bcc $c2c0			bcc 	_TIMWHNoLetter
.c2be	69 06		adc #$06			adc 	#6
.c2c0					_TIMWHNoLetter:
.c2c0	69 30		adc #$30			adc 	#48
.c2c2	20 41 c0	jsr $c041			jsr 	IFT_PrintCharacter 			; print it out.
.c2c5	68		pla				pla
.c2c6	60		rts				rts
.c2c7					TIM_WriteLine:
.c2c7	a9 2e		lda #$2e			lda 	#"." 						; prompt
.c2c9	20 41 c0	jsr $c041			jsr 	IFT_PrintCharacter
.c2cc	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.c2ce	20 41 c0	jsr $c041			jsr 	IFT_PrintCharacter
.c2d1	a5 13		lda $13				lda 	zTemp2+1 					; write address
.c2d3	20 ae c2	jsr $c2ae			jsr 	TIM_WriteHex
.c2d6	a5 12		lda $12				lda 	zTemp2
.c2d8	20 ae c2	jsr $c2ae			jsr 	TIM_WriteHex
.c2db	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.c2dd					_TIMWL_Loop:
.c2dd	a9 20		lda #$20			lda 	#" "
.c2df	20 41 c0	jsr $c041			jsr 	IFT_PrintCharacter
.c2e2	b1 12		lda ($12),y			lda 	(zTemp2),y
.c2e4	20 ae c2	jsr $c2ae			jsr 	TIM_WriteHex
.c2e7	c8		iny				iny
.c2e8	c0 10		cpy #$10			cpy 	#16
.c2ea	d0 f1		bne $c2dd			bne 	_TIMWL_Loop
.c2ec	4c 68 c0	jmp $c068			jmp 	IFT_NewLine 				; new line and exit
.c2ef					TIM_GetHex:
.c2ef	c8		iny				iny
.c2f0	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.c2f2	c9 20		cmp #$20			cmp 	#32
.c2f4	f0 f9		beq $c2ef			beq 	TIM_GetHex
.c2f6	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.c2f8	f0 f5		beq $c2ef			beq 	TIM_GetHex
.c2fa	20 23 c3	jsr $c323			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.c2fd	b0 23		bcs $c322			bcs 	_TIMGH_Exit					; if first bad then exit now.
.c2ff	a9 00		lda #$00			lda 	#0 							; zero result
.c301	85 14		sta $14				sta 	zTemp3
.c303	85 15		sta $15				sta 	zTemp3+1
.c305					_TIM_GHLoop:
.c305	20 23 c3	jsr $c323			jsr 	TIM_GetHexCharacter 		; get next character
.c308	b0 17		bcs $c321			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.c30a	c8		iny				iny 								; skip over it.
.c30b	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.c30d	26 15		rol $15				rol 	zTemp3+1
.c30f	06 14		asl $14				asl 	zTemp3 						; now x 2
.c311	26 15		rol $15				rol 	zTemp3+1
.c313	06 14		asl $14				asl 	zTemp3						; now x 4
.c315	26 15		rol $15				rol 	zTemp3+1
.c317	06 14		asl $14				asl 	zTemp3 						; now x 8
.c319	26 15		rol $15				rol 	zTemp3+1
.c31b	05 14		ora $14				ora 	zTemp3 						; OR result in
.c31d	85 14		sta $14				sta 	zTemp3
.c31f	80 e4		bra $c305			bra 	_TIM_GHLoop 				; loop round again.
.c321					_TIMGH_Okay:
.c321	18		clc				clc
.c322					_TIMGH_Exit:
.c322	60		rts				rts
.c323					TIM_GetHexCharacter:
.c323	b1 10		lda ($10),y			lda 	(zTemp1),y
.c325	38		sec				sec
.c326	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.c328	90 0e		bcc $c338			bcc 	_TIM_GHCFail
.c32a	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.c32c	90 0b		bcc $c339			bcc 	_TIM_GHCExit
.c32e	c9 11		cmp #$11			cmp 	#65-48						; < A
.c330	90 06		bcc $c338			bcc		_TIM_GHCFail
.c332	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.c334	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.c336	90 01		bcc $c339			bcc		_TIM_GHCExit
.c338					_TIM_GHCFail:
.c338	38		sec				sec
.c339					_TIM_GHCExit:
.c339	60		rts				rts
.c33a					TIM_BreakVector:
.c33a	da		phx				phx									; save X/A on stack
.c33b	48		pha				pha
.c33c	ba		tsx				tsx 								; X points to S
.c33d	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.c340	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.c342	d0 03		bne $c347			bne 	_TIMBreak					; if set, it's BRK
.c344	68		pla				pla 								; abandon routine.
.c345	fa		plx				plx
.c346	40		rti				rti
.c347					_TIMBreak:
.c347	68		pla				pla 								; save A X Y and maybe Z
.c348	8d ad 04	sta $04ad			sta 	TIM_A
.c34b	fa		plx				plx
.c34c	8e ae 04	stx $04ae			stx 	TIM_X
.c34f	8c af 04	sty $04af			sty 	TIM_Y
.c352	68		pla				pla 								; get Status Register
.c353	8d ac 04	sta $04ac			sta 	TIM_SR
.c356	68		pla				pla
.c357	8d a9 04	sta $04a9			sta 	TIM_PC+1 					; save calling address
.c35a	68		pla				pla
.c35b	8d a8 04	sta $04a8			sta 	TIM_PC 						; high byte
.c35e	ad a9 04	lda $04a9			lda 	TIM_PC+1 					; dec PC to point right.
.c361	d0 03		bne $c366			bne 	_TIMDecrement 				; brk bumps it.
.c363	ce a8 04	dec $04a8			dec 	TIM_PC
.c366					_TIMDecrement:
.c366	ce a9 04	dec $04a9			dec 	TIM_PC+1
.c369	ba		tsx				tsx 								; and copy SP
.c36a	8e b1 04	stx $04b1			stx 	TIM_SP
.c36d	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.c36f	9a		txs				txs
.c370	4c 50 c2	jmp $c250			jmp 	TIM_Start 					; and start up TIM monitor.
.c373					TIM_UpdateRegisters:
.c373	20 ef c2	jsr $c2ef			jsr 	TIM_GetHex 					; PC
.c376	b0 28		bcs $c3a0			bcs 	_TIMURFail
.c378	a5 14		lda $14				lda 	zTemp3
.c37a	8d a9 04	sta $04a9			sta 	Tim_PC+1
.c37d	a5 15		lda $15				lda 	zTemp3+1
.c37f	8d a8 04	sta $04a8			sta 	Tim_PC
.c382	20 ef c2	jsr $c2ef			jsr 	TIM_GetHex 					; ignore IRQ
.c385	b0 19		bcs $c3a0			bcs 	_TIMURFail
.c387	a2 00		ldx #$00			ldx 	#0
.c389					_TIM_URLoop:
.c389	e0 04		cpx #$04			cpx 	#Tim_Z-Tim_SR
.c38b	d0 01		bne $c38e			bne 	_TIM_1
.c38d	e8		inx				inx
.c38e					_TIM_1:
.c38e	20 ef c2	jsr $c2ef			jsr 	TIM_GetHex 					; registers
.c391	b0 0d		bcs $c3a0			bcs 	_TIMURFail
.c393	a5 14		lda $14				lda 	zTemp3
.c395	9d ac 04	sta $04ac,x			sta 	Tim_SR,x
.c398	e8		inx				inx
.c399	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.c39b	d0 ec		bne $c389			bne 	_TIM_URLoop
.c39d	4c c3 c1	jmp $c1c3			jmp 	TIM_NewCommand
.c3a0					_TIMURFail:
.c3a0	4c bc c1	jmp $c1bc			jmp 	TIM_Error
.c3a3					TIM_LoadMemory:
.c3a3	20 ef c2	jsr $c2ef			jsr 	TIM_GetHex 					; target address => zTemp2
.c3a6	a5 14		lda $14				lda 	zTemp3
.c3a8	85 12		sta $12				sta 	zTemp2
.c3aa	a5 15		lda $15				lda 	zTemp3+1
.c3ac	85 13		sta $13				sta 	zTemp2+1
.c3ae					_TIM_LMLoop:
.c3ae	20 ef c2	jsr $c2ef			jsr 	TIM_GetHex 					; next byte ?
.c3b1	b0 0e		bcs $c3c1			bcs 	_TIMLMDone 					; no more
.c3b3	a2 00		ldx #$00			ldx 	#0							; write out.
.c3b5	a5 14		lda $14				lda 	zTemp3
.c3b7	81 12		sta ($12,x)			sta 	(zTemp2,x)
.c3b9	e6 12		inc $12				inc 	zTemp2 						; bump address
.c3bb	d0 f1		bne $c3ae			bne 	_TIM_LMLoop
.c3bd	e6 13		inc $13				inc 	zTemp2+1
.c3bf	80 ed		bra $c3ae			bra 	_TIM_LMLoop
.c3c1					_TIMLMDone:
.c3c1	4c c3 c1	jmp $c1c3			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/errors.asm

.c3c4					SyntaxError:
.c3c4	20 f3 c3	jsr $c3f3			jsr 	ERR_Handler
>c3c7	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>c3cf	72 72 6f 72 00
.c3d4					TypeError:
.c3d4	20 f3 c3	jsr $c3f3			jsr 	ERR_Handler
>c3d7	57 72 6f 6e 67 20 74 79				.text 	"Wrong type",0
>c3df	70 65 00
.c3e2					BadParamError:
.c3e2	20 f3 c3	jsr $c3f3			jsr 	ERR_Handler
>c3e5	42 61 64 20 50 61 72 61				.text 	"Bad Parameter",0
>c3ed	6d 65 74 65 72 00
.c3f3					ERR_Handler:
.c3f3	a0 00		ldy #$00			ldy 	#0
.c3f5	c8		iny				iny
.c3f6	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c3f8	8d 08 03	sta $0308			sta 	XS_Mantissa
.c3fb	c8		iny				iny
.c3fc	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c3fe	8d 09 03	sta $0309			sta 	XS_Mantissa+1
.c401	fa		plx				plx 								; address in XY
.c402	7a		ply				ply
.c403	e8		inx				inx 								; bump, because of RTS/JSR address -1
.c404	d0 01		bne $c407			bne 	_EHNoSkip
.c406	c8		iny				iny
.c407					_EHNoSkip:
.c407	20 28 c4	jsr $c428			jsr 	PrintROMMessage 			; print message from ROM.
.c40a	ad 08 03	lda $0308			lda 	XS_Mantissa					; line number = 0
.c40d	0d 09 03	ora $0309			ora 	XS_Mantissa+1
.c410	f0 0c		beq $c41e			beq 	_EHNoLine
.c412	a2 23		ldx #$23			ldx 	#_EHAt & $FF 				; print " at "
.c414	a0 c4		ldy #$c4			ldy 	#(_EHAt >> 8) & $FF
.c416	20 28 c4	jsr $c428			jsr 	PrintROMMessage
.c419	a2 00		ldx #$00			ldx 	#0 							; Print line number
.c41b	20 39 c4	jsr $c439			jsr 	Print16BitInteger
.c41e					_EHNoLine:
.c41e	80 fe		bra $c41e			bra 	_EHNoLine
.c420	4c 94 c6	jmp $c694			jmp 	WarmStart
>c423	20 61 74 20 00			_EHAt:	.text 	" at ",0
.c428					PrintROMMessage:
.c428	86 1a		stx $1a				stx 	zLTemp1 					; save addres
.c42a	84 1b		sty $1b				sty 	zLTemp1+1
.c42c	a0 00		ldy #$00			ldy 	#0
.c42e					_PRMLoop:
.c42e	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.c430	f0 06		beq $c438			beq		_PRMExit
.c432	c8		iny				iny
.c433	20 41 c0	jsr $c041			jsr 	IFT_PrintCharacter
.c436	80 f6		bra $c42e			bra 	_PRMLoop
.c438					_PRMExit:
.c438	60		rts				rts
.c439					Print16BitInteger:
.c439	a9 00		lda #$00			lda 	#0 							; make 32 bit
.c43b	8d 0a 03	sta $030a			sta 	XS_Mantissa+2
.c43e	8d 0b 03	sta $030b			sta 	XS_Mantissa+3
.c441	8d 04 04	sta $0404			sta 	NumBufX 					; reset the conversion pointer
.c444	aa		tax				tax 								; convert bottom level.
.c445	20 78 d6	jsr $d678			jsr 	INTToString 				; make string
.c448	a2 00		ldx #$00			ldx 	#0 							; print buffer
.c44a	bd 05 04	lda $0405,x	_P1Loop:lda 	Num_Buffer,x
.c44d	f0 06		beq $c455			beq 	_P1Exit
.c44f	20 41 c0	jsr $c041			jsr 	IFT_PrintCharacter
.c452	e8		inx				inx
.c453	80 f5		bra $c44a			bra 	_P1Loop
.c455	60		rts		_P1Exit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm


;******  Processing file: modules/basic/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b6					lastUnaryFunction = $b6
.c456					VectorTable:
>c456	44 ca					.word BinaryOp_And         & $FFFF ; $80 and
>c458	6c ca					.word BinaryOp_Or          & $FFFF ; $81 or
>c45a	94 ca					.word BinaryOp_Xor         & $FFFF ; $82 xor
>c45c	94 ca					.word BinaryOp_Eor         & $FFFF ; $83 eor
>c45e	d8 ca					.word Binary_Equal         & $FFFF ; $84 =
>c460	f7 ca					.word Binary_NotEqual      & $FFFF ; $85 <>
>c462	00 cb					.word Binary_Less          & $FFFF ; $86 <
>c464	09 cb					.word Binary_LessEqual     & $FFFF ; $87 <=
>c466	1b cb					.word Binary_Greater       & $FFFF ; $88 >
>c468	12 cb					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>c46a	b0 cb					.word BinaryOp_Add         & $FFFF ; $8a +
>c46c	d0 cb					.word BinaryOp_Subtract    & $FFFF ; $8b -
>c46e	e3 cb					.word BinaryOp_Multiply    & $FFFF ; $8c *
>c470	f6 cb					.word BinaryOp_Divide      & $FFFF ; $8d /
>c472	12 c5					.word NotImplemented       & $FFFF ; $8e ^
>c474	12 c5					.word NotImplemented       & $FFFF ; $8f if
>c476	12 c5					.word NotImplemented       & $FFFF ; $90 while
>c478	12 c5					.word NotImplemented       & $FFFF ; $91 repeat
>c47a	12 c5					.word NotImplemented       & $FFFF ; $92 for
>c47c	12 c5					.word NotImplemented       & $FFFF ; $93 then
>c47e	12 c5					.word NotImplemented       & $FFFF ; $94 endif
>c480	12 c5					.word NotImplemented       & $FFFF ; $95 wend
>c482	12 c5					.word NotImplemented       & $FFFF ; $96 until
>c484	12 c5					.word NotImplemented       & $FFFF ; $97 next
>c486	12 c5					.word NotImplemented       & $FFFF ; $98 not
>c488	12 c5					.word NotImplemented       & $FFFF ; $99 fn(
>c48a	2a cd					.word Unary_Abs            & $FFFF ; $9a abs(
>c48c	81 ce					.word Unary_Asc            & $FFFF ; $9b asc(
>c48e	59 de					.word Unary_Int            & $FFFF ; $9c int(
>c490	48 cd					.word Unary_Peek           & $FFFF ; $9d peek(
>c492	d0 dd					.word Unary_Rnd            & $FFFF ; $9e rnd(
>c494	bc cd					.word Unary_Usr            & $FFFF ; $9f usr(
>c496	c2 ce					.word Unary_Left           & $FFFF ; $a0 left$(
>c498	d9 ce					.word Unary_Right          & $FFFF ; $a1 right$(
>c49a	a7 ce					.word Unary_Mid            & $FFFF ; $a2 mid$(
>c49c	3b d0					.word Unary_Spc            & $FFFF ; $a3 spc(
>c49e	4e ce					.word Unary_Str            & $FFFF ; $a4 str$(
>c4a0	dd cd					.word Unary_Val            & $FFFF ; $a5 val(
>c4a2	98 ce					.word Unary_Len            & $FFFF ; $a6 len(
>c4a4	57 cf					.word Unary_Hex            & $FFFF ; $a7 hex$(
>c4a6	12 c5					.word NotImplemented       & $FFFF ; $a8 sin(
>c4a8	12 c5					.word NotImplemented       & $FFFF ; $a9 cos(
>c4aa	12 c5					.word NotImplemented       & $FFFF ; $aa tan(
>c4ac	12 c5					.word NotImplemented       & $FFFF ; $ab atn(
>c4ae	12 c5					.word NotImplemented       & $FFFF ; $ac exp(
>c4b0	12 c5					.word NotImplemented       & $FFFF ; $ad log(
>c4b2	12 c5					.word NotImplemented       & $FFFF ; $ae sqr(
>c4b4	b1 cf					.word Unary_Dec            & $FFFF ; $af dec(
>c4b6	4c cd					.word Unary_Deek           & $FFFF ; $b0 deek(
>c4b8	50 cd					.word Unary_Leek           & $FFFF ; $b1 leek(
>c4ba	84 cd					.word Unary_Mod            & $FFFF ; $b2 mod(
>c4bc	d8 cc					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>c4be	19 d0					.word Unary_Chr            & $FFFF ; $b4 chr$(
>c4c0	12 c5					.word NotImplemented       & $FFFF ; $b5 pos(
>c4c2	12 c5					.word NotImplemented       & $FFFF ; $b6 tab(
>c4c4	12 c5					.word NotImplemented       & $FFFF ; $b7 $
>c4c6	12 c5					.word NotImplemented       & $FFFF ; $b8 $(
>c4c8	12 c5					.word NotImplemented       & $FFFF ; $b9 #
>c4ca	12 c5					.word NotImplemented       & $FFFF ; $ba #(
>c4cc	12 c5					.word NotImplemented       & $FFFF ; $bb %
>c4ce	12 c5					.word NotImplemented       & $FFFF ; $bc %(
>c4d0	12 c5					.word NotImplemented       & $FFFF ; $bd (
>c4d2	12 c5					.word NotImplemented       & $FFFF ; $be )
>c4d4	12 c5					.word NotImplemented       & $FFFF ; $bf ,
>c4d6	9f c7					.word Command_COLON        & $FFFF ; $c0 :
>c4d8	12 c5					.word NotImplemented       & $FFFF ; $c1 ;
>c4da	12 c5					.word NotImplemented       & $FFFF ; $c2 def
>c4dc	54 c8					.word Command_CLR          & $FFFF ; $c3 clr
>c4de	65 c8					.word Command_STOP         & $FFFF ; $c4 stop
>c4e0	12 c5					.word NotImplemented       & $FFFF ; $c5 data
>c4e2	12 c5					.word NotImplemented       & $FFFF ; $c6 read
>c4e4	9a c6					.word Command_DIM          & $FFFF ; $c7 dim
>c4e6	12 c5					.word NotImplemented       & $FFFF ; $c8 to
>c4e8	12 c5					.word NotImplemented       & $FFFF ; $c9 step
>c4ea	12 c5					.word NotImplemented       & $FFFF ; $ca gosub
>c4ec	12 c5					.word NotImplemented       & $FFFF ; $cb return
>c4ee	12 c5					.word NotImplemented       & $FFFF ; $cc goto
>c4f0	c1 c7					.word Command_END          & $FFFF ; $cd end
>c4f2	12 c5					.word NotImplemented       & $FFFF ; $ce input
>c4f4	a0 c7					.word Command_LET          & $FFFF ; $cf let
>c4f6	12 c5					.word NotImplemented       & $FFFF ; $d0 list
>c4f8	12 c5					.word NotImplemented       & $FFFF ; $d1 new
>c4fa	12 c5					.word NotImplemented       & $FFFF ; $d2 old
>c4fc	12 c5					.word NotImplemented       & $FFFF ; $d3 on
>c4fe	12 c5					.word NotImplemented       & $FFFF ; $d4 restore
>c500	12 c5					.word NotImplemented       & $FFFF ; $d5 poke
>c502	c5 c7					.word Command_PRINT        & $FFFF ; $d6 print
>c504	27 c7					.word Command_RUN          & $FFFF ; $d7 run
>c506	12 c5					.word NotImplemented       & $FFFF ; $d8 wait
>c508	12 c5					.word NotImplemented       & $FFFF ; $d9 sys
>c50a	12 c5					.word NotImplemented       & $FFFF ; $da doke
>c50c	12 c5					.word NotImplemented       & $FFFF ; $db loke
>c50e	38 c8					.word Command_ASSERT       & $FFFF ; $dc assert
>c510	12 c5					.word NotImplemented       & $FFFF ; $dd get
.c512					NotImplemented:
.c512	20 f3 c3	jsr $c3f3			jsr ERR_Handler
>c515	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>c51d	65 6d 65 6e 74 65 64 00
.c525					BinaryPrecedence:
>c525	01					.byte 1    ; $80 and
>c526	01					.byte 1    ; $81 or
>c527	01					.byte 1    ; $82 xor
>c528	01					.byte 1    ; $83 eor
>c529	02					.byte 2    ; $84 =
>c52a	02					.byte 2    ; $85 <>
>c52b	02					.byte 2    ; $86 <
>c52c	02					.byte 2    ; $87 <=
>c52d	02					.byte 2    ; $88 >
>c52e	02					.byte 2    ; $89 >=
>c52f	03					.byte 3    ; $8a +
>c530	03					.byte 3    ; $8b -
>c531	04					.byte 4    ; $8c *
>c532	04					.byte 4    ; $8d /
>c533	05					.byte 5    ; $8e ^
.c534					KeywordText:
>c534	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>c537	4f d2					.byte $4f,$d2                          ; $81 or
>c539	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>c53c	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>c53f	bd					.byte $bd                              ; $84 =
>c540	3c be					.byte $3c,$be                          ; $85 <>
>c542	bc					.byte $bc                              ; $86 <
>c543	3c bd					.byte $3c,$bd                          ; $87 <=
>c545	be					.byte $be                              ; $88 >
>c546	3e bd					.byte $3e,$bd                          ; $89 >=
>c548	ab					.byte $ab                              ; $8a +
>c549	ad					.byte $ad                              ; $8b -
>c54a	aa					.byte $aa                              ; $8c *
>c54b	af					.byte $af                              ; $8d /
>c54c	de					.byte $de                              ; $8e ^
>c54d	49 c6					.byte $49,$c6                          ; $8f if
>c54f	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>c554	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>c55a	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>c55d	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>c561	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>c566	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>c56a	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>c56f	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>c573	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>c576	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>c579	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>c57d	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>c581	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>c585	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>c58a	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>c58e	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>c592	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>c598	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>c59f	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>c5a4	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>c5a8	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>c5ad	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>c5b1	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>c5b5	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>c5ba	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>c5be	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>c5c2	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>c5c6	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>c5ca	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>c5ce	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>c5d2	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>c5d6	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>c5da	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>c5df	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>c5e4	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>c5e8	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>c5ec	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>c5f1	50 4f 53 a8				.byte $50,$4f,$53,$a8                  ; $b5 pos(
>c5f5	54 41 42 a8				.byte $54,$41,$42,$a8                  ; $b6 tab(
>c5f9	a4					.byte $a4                              ; $b7 $
>c5fa	24 a8					.byte $24,$a8                          ; $b8 $(
>c5fc	a3					.byte $a3                              ; $b9 #
>c5fd	23 a8					.byte $23,$a8                          ; $ba #(
>c5ff	a5					.byte $a5                              ; $bb %
>c600	25 a8					.byte $25,$a8                          ; $bc %(
>c602	a8					.byte $a8                              ; $bd (
>c603	a9					.byte $a9                              ; $be )
>c604	ac					.byte $ac                              ; $bf ,
>c605	ba					.byte $ba                              ; $c0 :
>c606	bb					.byte $bb                              ; $c1 ;
>c607	44 45 c6				.byte $44,$45,$c6                      ; $c2 def
>c60a	43 4c d2				.byte $43,$4c,$d2                      ; $c3 clr
>c60d	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $c4 stop
>c611	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c5 data
>c615	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c6 read
>c619	44 49 cd				.byte $44,$49,$cd                      ; $c7 dim
>c61c	54 cf					.byte $54,$cf                          ; $c8 to
>c61e	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c9 step
>c622	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $ca gosub
>c627	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $cb return
>c62d	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $cc goto
>c631	45 4e c4				.byte $45,$4e,$c4                      ; $cd end
>c634	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $ce input
>c639	4c 45 d4				.byte $4c,$45,$d4                      ; $cf let
>c63c	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $d0 list
>c640	4e 45 d7				.byte $4e,$45,$d7                      ; $d1 new
>c643	4f 4c c4				.byte $4f,$4c,$c4                      ; $d2 old
>c646	4f ce					.byte $4f,$ce                          ; $d3 on
>c648	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d4 restore
>c64f	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d5 poke
>c653	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d6 print
>c658	52 55 ce				.byte $52,$55,$ce                      ; $d7 run
>c65b	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d8 wait
>c65f	53 59 d3				.byte $53,$59,$d3                      ; $d9 sys
>c662	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $da doke
>c666	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $db loke
>c66a	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $dc assert
>c670	47 45 d4				.byte $47,$45,$d4                      ; $dd get
>c673	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_pos = $b5
=$b6					token_tab = $b6
=$b7					token_dollar = $b7
=$b8					token_dollarlparen = $b8
=$b9					token_hash = $b9
=$ba					token_hashlparen = $ba
=$bb					token_percent = $bb
=$bc					token_percentlparen = $bc
=$bd					token_lparen = $bd
=$be					token_rparen = $be
=$bf					token_comma = $bf
=$c0					token_colon = $c0
=$c1					token_semicolon = $c1
=$c2					token_def = $c2
=$c3					token_clr = $c3
=$c4					token_stop = $c4
=$c5					token_data = $c5
=$c6					token_read = $c6
=$c7					token_dim = $c7
=$c8					token_to = $c8
=$c9					token_step = $c9
=$ca					token_gosub = $ca
=$cb					token_return = $cb
=$cc					token_goto = $cc
=$cd					token_end = $cd
=$ce					token_input = $ce
=$cf					token_let = $cf
=$d0					token_list = $d0
=$d1					token_new = $d1
=$d2					token_old = $d2
=$d3					token_on = $d3
=$d4					token_restore = $d4
=$d5					token_poke = $d5
=$d6					token_print = $d6
=$d7					token_run = $d7
=$d8					token_wait = $d8
=$d9					token_sys = $d9
=$da					token_doke = $da
=$db					token_loke = $db
=$dc					token_assert = $dc
=$dd					token_get = $dd

;******  Return to file: modules/basic/core.asm

.c674					BASIC_Start:
.c674	20 b4 c1	jsr $c1b4			jsr 	IF_Reset 					; set up and clear screen.
.c677	20 0c c0	jsr $c00c			jsr 	IFT_ClearScreen
.c67a	a9 4c		lda #$4c			lda 	#$4C 						; JMP opcode
.c67c	8d 04 03	sta $0304			sta 	LocalVector
.c67f	8d 00 03	sta $0300			sta 	UserVector
.c682	a9 cb		lda #$cb			lda 	#USRDefault & $FF 			; reset USR vector
.c684	8d 01 03	sta $0301			sta 	UserVector+1
.c687	a9 cd		lda #$cd			lda 	#(USRDefault >> 8) & $FF
.c689	8d 02 03	sta $0302			sta 	UserVector+2
.c68c	a9 00		lda #$00			lda 	#(USRDefault >> 16) & $FF
.c68e	8d 03 03	sta $0303			sta 	UserVector+3
.c691	20 54 c8	jsr $c854			jsr 	ResetRunStatus 				; clear everything (CLR command)
.c694					WarmStart:
.c694	a2 ff		ldx #$ff			ldx 		#$FF 					; empty stack
.c696	9a		txs				txs
.c697	4c 27 c7	jmp $c727			jmp 	COMMAND_Run

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/dim.asm

.c69a					Command_DIM:
.c69a	98		tya				tya
.c69b	48		pha				pha 								; push on stack.
.c69c	20 b1 d1	jsr $d1b1			jsr 	VariableExtract 			; get the identifier
.c69f	ad 85 04	lda $0485			lda 	Var_Type 					; check it is an array
.c6a2	29 01		and #$01			and 	#1
.c6a4	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.c6a6	d0 71		bne $c719			bne 	_CDIError
.c6a8	a9 00		lda #$00			lda 	#0 							; reset the DIM index. The dimensions are
.c6aa	8d a7 04	sta $04a7			sta 	UsrArrayIdx 				; built up here and copied in case we autodim
.c6ad					_CDIGetDimension:
.c6ad	ad a7 04	lda $04a7			lda 	UsrArrayIdx 				; done too many ?
.c6b0	c9 06		cmp #$06			cmp 	#ArrayMaxDim*2
.c6b2	f0 65		beq $c719			beq 	_CDIError
.c6b4	20 70 c8	jsr $c870			jsr 	EvaluateExpression 			; evaluate an index size
.c6b7	ad 09 03	lda $0309			lda 	XS_Mantissa+1 				; check in range 0-7FFF
.c6ba	29 80		and #$80			and 	#$80
.c6bc	0d 0a 03	ora $030a			ora 	XS_Mantissa+2
.c6bf	0d 0b 03	ora $030b			ora 	XS_Mantissa+3
.c6c2	d0 55		bne $c719			bne 	_CDIError
.c6c4	ae a7 04	ldx $04a7			ldx 	UsrArrayIdx 				; copy into the array table.
.c6c7	18		clc				clc 								; add 1 - max index => size.
.c6c8	ad 08 03	lda $0308			lda 	XS_Mantissa+0
.c6cb	69 01		adc #$01			adc 	#1
.c6cd	9d 9f 04	sta $049f,x			sta 	UsrArrayDef+0,x
.c6d0	ad 09 03	lda $0309			lda 	XS_Mantissa+1
.c6d3	69 00		adc #$00			adc 	#0
.c6d5	9d a0 04	sta $04a0,x			sta 	UsrArrayDef+1,x
.c6d8	30 3f		bmi $c719			bmi 	_CDIError 					; could be dim a(32767)
.c6da	e8		inx				inx 								; bump index.
.c6db	e8		inx				inx
.c6dc	8e a7 04	stx $04a7			stx 	UsrArrayIdx
.c6df	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c6e1	c8		iny				iny
.c6e2	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another dimension
.c6e4	f0 c7		beq $c6ad			beq 	_CDIGetDimension
.c6e6	88		dey				dey
.c6e7	20 a3 d0	jsr $d0a3			jsr 	CheckNextRParen 			; closing ) present ?
.c6ea	ae a7 04	ldx $04a7			ldx 	UsrArrayIdx 				; copy USR array to default
.c6ed	a9 ff		lda #$ff			lda 	#$FF 						; put end marker in ArrayDef
.c6ef	9d 98 04	sta $0498,x			sta 	ArrayDef+1,x
.c6f2					_CDICopy:
.c6f2	bd 9f 04	lda $049f,x			lda 	UsrArrayDef,x
.c6f5	9d 97 04	sta $0497,x			sta 	ArrayDef,x
.c6f8	ca		dex				dex
.c6f9	10 f7		bpl $c6f2			bpl 	_CDICopy
.c6fb	68		pla				pla									; position of array identifier
.c6fc	85 10		sta $10				sta 	zTemp1
.c6fe	98		tya				tya
.c6ff	48		pha				pha
.c700	a5 10		lda $10				lda 	zTemp1 						; point to identifier
.c702	a8		tay				tay
.c703	20 b1 d1	jsr $d1b1			jsr 	VariableExtract 			; get the identifier
.c706	20 53 d4	jsr $d453			jsr 	VariableLocate 				; check if it exists already.
.c709	b0 0e		bcs $c719			bcs 	_CDIError
.c70b	20 3d d2	jsr $d23d			jsr 	VariableCreate 				; create it using the current ArrayDef
.c70e	68		pla				pla 								; restore code position
.c70f	a8		tay				tay
.c710	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c712	c8		iny				iny
.c713	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another DIM
.c715	f0 83		beq $c69a			beq 	Command_DIM
.c717	88		dey				dey
.c718	60		rts				rts
.c719					_CDIError:
.c719	20 f3 c3	jsr $c3f3			jsr ERR_Handler
>c71c	42 61 64 20 44 49 4d 00			.text "Bad DIM",0
.c724					_CDISyntax:
.c724	4c c4 c3	jmp $c3c4			jmp 	SyntaxError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/run.asm

.c727					Command_RUN:
.c727	20 54 c8	jsr $c854			jsr 	ResetRunStatus 				; clear, reset stacks etc.
.c72a	a9 00		lda #$00			lda 	#BasicProgram & $FF
.c72c	85 16		sta $16				sta 	zCodePtr+0
.c72e	a9 10		lda #$10			lda 	#BasicProgram >> 8
.c730	85 17		sta $17				sta 	zCodePtr+1
.c732	a9 00		lda #$00			lda 	#0
.c734	85 18		sta $18				sta 	zCodePtr+2
.c736	85 19		sta $19				sta 	zCodePtr+3
.c738	a0 03		ldy #$03			ldy 	#3
.c73a					RUN_NewLine:
.c73a	a0 00		ldy #$00			ldy 	#0
.c73c	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c73e	c8		iny				iny
.c73f	c8		iny				iny
.c740	c8		iny				iny
.c741	c9 00		cmp #$00			cmp 	#0 							; if the offset is zero then END.
.c743	d0 16		bne $c75b			bne 	RUN_NextCommand
.c745	4c 65 c8	jmp $c865			jmp 	Command_STOP 				; go do the command code.
.c748					RUN_Skip:
.c748	b1 16		lda ($16),y			lda 	(zCodePtr),y 				; read element
.c74a	c8		iny				iny 								; skip
.c74b	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.c74d	90 0c		bcc $c75b			bcc 	_SEDone 					; so just skip over it.
.c74f	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.c751	90 07		bcc $c75a			bcc 	_SEDouble
.c753	98		tya				tya 								; this is Y + 1
.c754	18		clc				clc
.c755	71 16		adc ($16),y			adc 	(zCodePtr),y 				; add total length of element
.c757	a8		tay				tay 								; back in Y.
.c758	88		dey				dey 								; fix up, one for the +1, one for the iny
.c759	88		dey				dey
.c75a					_SEDouble:
.c75a	c8		iny				iny
.c75b					_SEDone:
.c75b					RUN_NextCommand:
.c75b	a9 00		lda #$00			lda 	#0 							; this resets temporary string allocation.
.c75d	85 21		sta $21				sta 	zTempStr+1 					; (initialised when first called)
.c75f	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c761	c9 c0		cmp #$c0			cmp 	#token_Colon 				; skip over colons
.c763	f0 e3		beq $c748			beq 	RUN_Skip
.c765	c9 00		cmp #$00			cmp 	#0 							; if non-zero execute whatever
.c767	d0 0f		bne $c778			bne 	RUN_Execute
.c769					RUN_NextLine:
.c769	a0 00		ldy #$00			ldy 	#0 							; point to offset
.c76b	b1 16		lda ($16),y			lda 	(zCodePtr),y 				; read it
.c76d	18		clc				clc
.c76e	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.c770	85 16		sta $16				sta 	zCodePtr
.c772	90 02		bcc $c776			bcc 	_SNLNoCarry
.c774	e6 17		inc $17				inc 	zCodePtr+1
.c776					_SNLNoCarry:
.c776	80 c2		bra $c73a			bra 	RUN_NewLine 				; go do the new line code
.c778					RUN_Execute:
.c778	c9 f8		cmp #$f8			cmp 	#$F8 						; handle shifts, REM etc.
.c77a	b0 1c		bcs $c798			bcs 	RUN_Extension
.c77c	c8		iny				iny
.c77d	0a		asl a				asl 	a 							; double the character read.
.c77e	90 12		bcc $c792			bcc 	RUN_Default 				; if carry clear was $00-$7F, so try LET.
.c780	aa		tax				tax 								; ready to look up.
.c781	bd 56 c4	lda $c456,x			lda 	VectorTable,x 				; copy address into LocalVector
.c784	8d 05 03	sta $0305			sta 	LocalVector+1
.c787	bd 57 c4	lda $c457,x			lda 	VectorTable+1,x
.c78a	8d 06 03	sta $0306			sta 	LocalVector+2
.c78d	20 7d c9	jsr $c97d			jsr 	EVCallLocalVector 			; execute the appropriate code.
.c790	80 c9		bra $c75b			bra 	RUN_NextCommand 			; do the next command.
.c792					RUN_Default:
.c792	88		dey				dey
.c793	20 a0 c7	jsr $c7a0			jsr 	Command_LET 				; and try LET.
.c796	80 c3		bra $c75b			bra 	RUN_NextCommand
.c798					RUN_Extension:
.c798	c9 ff		cmp #$ff			cmp 	#$FF 						; if $FF (REM)
.c79a	f0 ac		beq $c748			beq 	RUN_Skip 					; skip over it.
.c79c	4c c4 c3	jmp $c3c4			jmp 	SyntaxError
.c79f					Command_COLON:
.c79f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/let.asm

.c7a0					Command_LET:
.c7a0	20 46 d1	jsr $d146			jsr 	VariableFind 				; get reference to one variable.
.c7a3	a9 84		lda #$84			lda 	#token_Equal  				; get equals
.c7a5	20 8c d0	jsr $d08c			jsr 	CheckNextToken
.c7a8	a5 22		lda $22				lda 	zVarDataPtr 				; save variable info on stack
.c7aa	48		pha				pha
.c7ab	a5 23		lda $23				lda 	zVarDataPtr+1
.c7ad	48		pha				pha
.c7ae	a5 24		lda $24				lda 	zVarType
.c7b0	48		pha				pha
.c7b1	20 70 c8	jsr $c870			jsr 	EvaluateExpression 			; evaluate the RHS.
.c7b4	68		pla				pla 								; restore target variable information.
.c7b5	85 24		sta $24				sta 	zVarType
.c7b7	68		pla				pla
.c7b8	85 23		sta $23				sta 	zVarDataPtr+1
.c7ba	68		pla				pla
.c7bb	85 22		sta $22				sta 	zVarDataPtr
.c7bd	20 f6 d4	jsr $d4f6			jsr 	VariableSet 				; set the value out.
.c7c0	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/end.asm

.c7c1					Command_END:
>c7c1	02						.byte 	2
.c7c2	4c 94 c6	jmp $c694			jmp 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/print.asm

.c7c5					Command_PRINT:
.c7c5	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c7c7	c9 00		cmp #$00			cmp 	#0 							; end
.c7c9	f0 69		beq $c834			beq 	_CPR_NewLine
.c7cb	c9 c0		cmp #$c0			cmp 	#token_Colon
.c7cd	f0 65		beq $c834			beq 	_CPR_NewLine
.c7cf	c9 c1		cmp #$c1			cmp 	#token_SemiColon
.c7d1	f0 54		beq $c827			beq 	_CPR_Skip
.c7d3	c9 bf		cmp #$bf			cmp 	#token_Comma
.c7d5	f0 4d		beq $c824			beq 	_CPR_Tab
.c7d7	20 70 c8	jsr $c870			jsr 	EvaluateExpression 			; get expression.
.c7da	ad 0d 03	lda $030d			lda 	XS_Type 					; get type.
.c7dd	29 02		and #$02			and 	#2
.c7df	d0 25		bne $c806			bne 	_CPR_String 				; if type = 2 output as string.
.c7e1					_CPR_Number:
.c7e1	a9 00		lda #$00			lda 	#0 							; reset buffer index
.c7e3	8d 04 04	sta $0404			sta 	NumBufX
.c7e6	ad 0d 03	lda $030d			lda 	XS_Type 					; get type
.c7e9	4a		lsr a				lsr 	a
.c7ea	b0 05		bcs $c7f1			bcs 	_CPRInt 					; if msb set do as integer
.c7ec	20 88 dc	jsr $dc88			jsr 	FPToString 					; call fp to str otherwise
.c7ef	80 03		bra $c7f4			bra 	_CPRNPrint
.c7f1	20 78 d6	jsr $d678	_CPRInt:jsr 	IntToString
.c7f4					_CPRNPrint:
.c7f4	ad 05 04	lda $0405			lda 	Num_Buffer 					; is first character -
.c7f7	c9 2d		cmp #$2d			cmp 	#"-"
.c7f9	f0 05		beq $c800			beq 	_CPRNoSpace
.c7fb	a9 20		lda #$20			lda 	#" "						; print the leading space
.c7fd	20 41 c0	jsr $c041			jsr 	IFT_PrintCharacter 			; so beloved of MS Basics.
.c800					_CPRNoSpace:
.c800	a2 04		ldx #$04			ldx 	#(Num_Buffer-1) & $FF
.c802	a9 04		lda #$04			lda 	#(Num_Buffer-1) >> 8
.c804	80 06		bra $c80c			bra 	_CPRPrint
.c806					_CPR_String:
.c806	ae 08 03	ldx $0308			ldx 	XS_Mantissa
.c809	ad 09 03	lda $0309			lda 	XS_Mantissa+1
.c80c					_CPRPrint:
.c80c	86 1e		stx $1e				stx 	zGenPtr
.c80e	85 1f		sta $1f				sta 	zGenPtr+1
.c810	5a		phy				phy
.c811	a0 00		ldy #$00			ldy 	#0							; get length into X
.c813	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.c815	aa		tax				tax
.c816	f0 09		beq $c821			beq 	_CPREndPrint 				; nothing to print
.c818					_CPRLoop:
.c818	c8		iny				iny
.c819	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.c81b	20 41 c0	jsr $c041			jsr 	IFT_PrintCharacter
.c81e	ca		dex				dex
.c81f	d0 f7		bne $c818			bne 	_CPRLoop
.c821					_CPREndPrint:
.c821	7a		ply				ply
.c822	80 a1		bra $c7c5			bra 	Command_Print
.c824					_CPR_Tab:
.c824	20 5b c0	jsr $c05b			jsr 	IFT_Tab
.c827					_CPR_Skip:
.c827	c8		iny				iny
.c828	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c82a	c9 c0		cmp #$c0			cmp 	#token_Colon 				; colon or $00, exit
.c82c	f0 09		beq $c837			beq 	_CPR_Exit
.c82e	c9 00		cmp #$00			cmp 	#0
.c830	d0 93		bne $c7c5			bne 	Command_PRINT 				; if not go round again.
.c832	80 03		bra $c837			bra 	_CPR_Exit
.c834					_CPR_NewLine:
.c834	20 68 c0	jsr $c068			jsr 	IFT_NewLine
.c837					_CPR_Exit:
.c837	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/assert.asm

.c838					Command_ASSERT:
.c838	20 13 ca	jsr $ca13			jsr 	EvaluateNumber 				; calculate thing being asserted
.c83b	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; check if true (non-zero)
.c83e	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.c841	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.c844	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.c847	f0 01		beq $c84a			beq 	_ASFail
.c849	60		rts				rts
.c84a					_ASFail:
.c84a	20 f3 c3	jsr $c3f3			jsr ERR_Handler
>c84d	41 73 73 65 72 74 00			.text "Assert",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.c854					Command_CLR:
.c854					ResetRunStatus:
.c854	20 82 d1	jsr $d182			jsr 	VariableClear
.c857	a9 00		lda #$00			lda 	#HighMemory & $FF
.c859	8d 00 04	sta $0400			sta 	StringPtr
.c85c	a9 80		lda #$80			lda 	#HighMemory >> 8
.c85e	8d 01 04	sta $0401			sta 	StringPtr+1
.c861	20 55 d3	jsr $d355			jsr 	ArrayResetDefault
.c864	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/stop.asm

.c865					Command_STOP:
.c865	20 f3 c3	jsr $c3f3			jsr ERR_Handler
>c868	53 74 6f 70 00				.text "Stop",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.c86d					EVESyntax:
.c86d	4c c4 c3	jmp $c3c4			jmp 	SyntaxError
.c870					EvaluateExpression:
.c870	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.c872					EvaluateExpressionX:
.c872	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.c874					EvaluateExpressionXA:
.c874	48		pha				pha 								; save precedence on stack.
.c875	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c877	f0 f4		beq $c86d			beq 	EVESyntax 					; end of line, syntax error.
.c879	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.c87b	b0 03		bcs $c880			bcs 	_EVNotVariable
.c87d	4c 74 c9	jmp $c974			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.c880					_EVNotVariable:
.c880	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.c882	90 e9		bcc $c86d			bcc 	EVESyntax
.c884	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.c886	b0 7c		bcs $c904			bcs 	_EVNotInteger
.c888	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.c88a	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.c88d	a9 00		lda #$00			lda 	#0
.c88f	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.c892	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.c895	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.c898	1a		inc a				inc 	a 							; set to type 1 (integer)
.c899	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.c89c					_EVCheckNextInteger:
.c89c	c8		iny				iny
.c89d	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c89f	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.c8a1	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.c8a3	b0 0d		bcs $c8b2			bcs 	_EVCheckDecimal
.c8a5	48		pha				pha 								; save it.
.c8a6	20 80 c9	jsr $c980			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.c8a9	68		pla				pla
.c8aa	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.c8ad	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.c8b0	80 ea		bra $c89c			bra 	_EVCheckNextInteger
.c8b2					_EVCheckDecimal:
.c8b2	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c8b4	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.c8b6	d0 05		bne $c8bd			bne 	_EVGotAtom 					; no, get atom.
.c8b8					_EVIsDecimal:
.c8b8	20 b0 c9	jsr $c9b0			jsr 	EVGetDecimal 				; extend to the decimal part.
.c8bb	80 00		bra $c8bd			bra 	_EVGotAtom 					; and continue to got atom.
.c8bd					_EVGotAtom:
.c8bd	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c8bf	10 41		bpl $c902			bpl 	_EVExitDrop 				; must be a token.
.c8c1	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.c8c3	b0 3d		bcs $c902			bcs 	_EVExitDrop
.c8c5	68		pla				pla 								; get current precedence
.c8c6	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.c8c8	da		phx				phx 								; save X
.c8c9	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c8cb	aa		tax				tax 								; put in X
.c8cc	bd a5 c4	lda $c4a5,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.c8cf	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.c8d1	fa		plx				plx 								; restore X
.c8d2	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.c8d4	90 2d		bcc $c903			bcc 	_EVExit 					; exit if too low.
.c8d6	f0 2b		beq $c903			beq 	_EVExit 					; exit if equals
.c8d8	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.c8da	48		pha				pha
.c8db	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c8dd	48		pha				pha
.c8de	c8		iny				iny
.c8df	da		phx				phx 								; save current position
.c8e0	e8		inx				inx
.c8e1	e8		inx				inx
.c8e2	e8		inx				inx
.c8e3	e8		inx				inx
.c8e4	e8		inx				inx
.c8e5	e8		inx				inx
.c8e6	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.c8e8	20 74 c8	jsr $c874			jsr 	EvaluateExpressionXA 		; do the RHS.
.c8eb	fa		plx				plx 								; restore X
.c8ec	68		pla				pla 								; get the binary operator in A.
.c8ed					_EVCallA:
.c8ed	da		phx				phx 								; save X again
.c8ee	0a		asl a				asl 	a 							; double, lose the MSB.
.c8ef	aa		tax				tax									; put in X
.c8f0	bd 56 c4	lda $c456,x			lda 	VectorTable,x 				; copy address into zGenPtr
.c8f3	8d 05 03	sta $0305			sta 	LocalVector+1
.c8f6	bd 57 c4	lda $c457,x			lda 	VectorTable+1,x
.c8f9	8d 06 03	sta $0306			sta 	LocalVector+2
.c8fc	fa		plx				plx 								; restore X
.c8fd	20 7d c9	jsr $c97d			jsr 	EVCallLocalVector
.c900	80 bb		bra $c8bd			bra 	_EVGotAtom 					; and loop back.
.c902					_EVExitDrop:
.c902	68		pla				pla
.c903					_EVExit:
.c903	60		rts				rts
.c904					_EVNotInteger:
.c904	c8		iny				iny
.c905	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.c907	d0 19		bne $c922			bne 	_EVNotMinus
.c909	20 01 ca	jsr $ca01			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.c90c	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.c90f	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.c911	f0 05		beq $c918			beq 	_EVMinusFloat
.c913	20 53 d6	jsr $d653			jsr 	IntegerNegateAlways 		; negation
.c916	80 a5		bra $c8bd			bra 	_EVGotAtom 					; and go back.
.c918					_EVMinusFloat:
.c918	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; invert the sign bit.
.c91b	49 80		eor #$80			eor 	#$80
.c91d	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.c920	80 9b		bra $c8bd			bra 	_EVGotAtom
.c922					_EVNotMinus:
.c922	c9 bd		cmp #$bd			cmp 	#token_lparen 				; is it left parenthesis
.c924	d0 17		bne $c93d			bne 	_EVNotParenthesis
.c926	20 72 c8	jsr $c872			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.c929	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c92b	c8		iny				iny
.c92c	c9 be		cmp #$be			cmp 	#token_rparen 				; okay if right bracket.
.c92e	f0 8d		beq $c8bd			beq 	_EVGotAtom
.c930	20 f3 c3	jsr $c3f3			jsr ERR_Handler
>c933	4d 69 73 73 69 6e 67 20			.text "Missing )",0
>c93b	29 00
.c93d					_EVNotParenthesis:
.c93d	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.c93f	d0 0c		bne $c94d			bne 	_EVNotNot
.c941	20 01 ca	jsr $ca01			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.c944	20 5d db	jsr $db5d			jsr 	FPUToInteger 				; make it an integer - if possible.
.c947	20 de c9	jsr $c9de			jsr 	NotInteger 					; do the not calculation
.c94a	4c bd c8	jmp $c8bd			jmp 	_EVGotAtom
.c94d					_EVNotNot:
.c94d	c9 fe		cmp #$fe			cmp 	#$FE
.c94f	d0 15		bne $c966			bne 	_EVNotString
.c951	20 20 d1	jsr $d120			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.c954	a5 20		lda $20				lda 	zTempStr 					; copy address of string into mantissa
.c956	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.c959	a5 21		lda $21				lda 	zTempStr+1
.c95b	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.c95e	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.c960	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.c963	4c bd c8	jmp $c8bd			jmp 	_EVGotAtom
.c966					_EVNotString:
.c966	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.c968	90 04		bcc $c96e			bcc 	_EVBadElement
.c96a	c9 b7		cmp #$b7			cmp 	#lastUnaryFunction+1
.c96c	90 03		bcc $c971			bcc 	_EVUnaryFunction
.c96e					_EVBadElement:
.c96e	4c c4 c3	jmp $c3c4			jmp 	SyntaxError
.c971					_EVUnaryFunction:
.c971	4c ed c8	jmp $c8ed			jmp 	_EVCallA
.c974					_EVVariableHandler:
.c974	20 46 d1	jsr $d146			jsr 	VariableFind 				; locate a variable
.c977	20 97 d4	jsr $d497			jsr 	VariableGet 				; copy into memory.
.c97a	4c bd c8	jmp $c8bd			jmp 	_EVGotAtom 					; and go round.
.c97d					EVCallLocalVector:
.c97d	6c 05 03	jmp ($0305)			jmp 	(LocalVector+1)
.c980					EVShiftMantissaLeft6:
.c980	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.c983	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.c986	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.c989	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.c98c	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.c98f	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.c992	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.c995	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.c998	a9 00		lda #$00			lda 	#0
.c99a	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.c99d	20 a0 c9	jsr $c9a0			jsr 	_EVSMLShift 					; call it here to do it twice
.c9a0					_EVSMLShift:
.c9a0	5e 0c 03	lsr $030c,x			lsr 	XS_Exponent,x
.c9a3	7e 0b 03	ror $030b,x			ror 	XS_Mantissa+3,x
.c9a6	7e 0a 03	ror $030a,x			ror 	XS_Mantissa+2,x
.c9a9	7e 09 03	ror $0309,x			ror 	XS_Mantissa+1,x
.c9ac	7e 08 03	ror $0308,x			ror 	XS_Mantissa+0,x
.c9af	60		rts				rts
.c9b0					EVGetDecimal:
.c9b0	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.c9b2	8d 05 04	sta $0405			sta 	Num_Buffer
.c9b5	da		phx				phx
.c9b6	c8		iny				iny
.c9b7	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c9b9	c8		iny				iny
.c9ba	3a		dec a				dec 	a								; convert to a string length.
.c9bb	3a		dec a				dec 	a
.c9bc	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.c9be					_EVGDCopy:
.c9be	48		pha				pha 									; save count
.c9bf	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c9c1	9d 05 04	sta $0405,x			sta 	Num_Buffer,x
.c9c4	e8		inx				inx 									; forward ....
.c9c5	c8		iny				iny
.c9c6	68		pla				pla 									; get count
.c9c7	3a		dec a				dec 	a 								; until zero
.c9c8	d0 f4		bne $c9be			bne 	_EVGDCopy
.c9ca	9d 05 04	sta $0405,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.c9cd	fa		plx				plx 									; restore X
.c9ce	a9 05		lda #$05			lda 	#Num_Buffer & $FF 				; set zGenPtr
.c9d0	85 1e		sta $1e				sta 	zGenPtr
.c9d2	a9 04		lda #$04			lda 	#Num_Buffer >> 8
.c9d4	85 1f		sta $1f				sta 	zGenPtr+1
.c9d6	5a		phy				phy 									; save Y
.c9d7	a0 00		ldy #$00			ldy 	#0 								; start position
.c9d9	20 4f dd	jsr $dd4f			jsr 	FPFromString 					; convert current
.c9dc	7a		ply				ply 									; restore Y
.c9dd	60		rts				rts
.c9de					NotInteger:
.c9de	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.c9e1	49 ff		eor #$ff			eor 	#$FF
.c9e3	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.c9e6	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.c9e9	49 ff		eor #$ff			eor 	#$FF
.c9eb	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.c9ee	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.c9f1	49 ff		eor #$ff			eor 	#$FF
.c9f3	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.c9f6	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.c9f9	49 ff		eor #$ff			eor 	#$FF
.c9fb	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.c9fe	60		rts				rts
.c9ff					EvaluateGetAtom:
.c9ff	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.ca01					EvaluateGetAtomX:
.ca01	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.ca03	20 74 c8	jsr $c874			jsr 	EvaluateExpressionXA
.ca06	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.ca09	29 0f		and #$0f			and 	#15
.ca0b	c9 02		cmp #$02			cmp 	#2
.ca0d	b0 01		bcs $ca10			bcs 	EvaluateType
.ca0f	60		rts				rts
.ca10					EvaluateType:
.ca10	4c d4 c3	jmp $c3d4			jmp 	TypeError
.ca13					EvaluateNumber:
.ca13	a2 00		ldx #$00			ldx 	#0
.ca15					EvaluateNumberX:
.ca15	20 72 c8	jsr $c872			jsr 	EvaluateExpressionX
.ca18	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 0/1
.ca1b	29 0f		and #$0f			and 	#15
.ca1d	c9 02		cmp #$02			cmp 	#2
.ca1f	b0 ef		bcs $ca10			bcs 	EvaluateType
.ca21	60		rts				rts
.ca22					EvaluateInteger:
.ca22	a2 00		ldx #$00			ldx 	#0
.ca24					EvaluateIntegerX:
.ca24	20 15 ca	jsr $ca15			jsr 	EvaluateNumberX
.ca27	20 5d db	jsr $db5d			jsr 	FPUToInteger
.ca2a	60		rts				rts
.ca2b					EvaluateString:
.ca2b	a2 00		ldx #$00			ldx 	#0
.ca2d					EvaluateStringX:
.ca2d	20 72 c8	jsr $c872			jsr 	EvaluateExpressionX
.ca30	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 2
.ca33	29 0f		and #$0f			and 	#15
.ca35	c9 02		cmp #$02			cmp 	#2
.ca37	d0 d7		bne $ca10			bne 	EvaluateType
.ca39	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.ca3c	85 1e		sta $1e				sta 	zGenPtr
.ca3e	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.ca41	85 1f		sta $1f				sta 	zGenPtr+1
.ca43	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.ca44					BinaryOp_And:
.ca44	20 bc ca	jsr $cabc			jsr 	BinaryMakeBothInteger
.ca47	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.ca4a	3d 0e 03	and $030e,x			and 	XS2_Mantissa+0,x
.ca4d	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.ca50	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.ca53	3d 0f 03	and $030f,x			and 	XS2_Mantissa+1,x
.ca56	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.ca59	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.ca5c	3d 10 03	and $0310,x			and 	XS2_Mantissa+2,x
.ca5f	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.ca62	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.ca65	3d 11 03	and $0311,x			and 	XS2_Mantissa+3,x
.ca68	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.ca6b	60		rts				rts
.ca6c					BinaryOp_Or:
.ca6c	20 bc ca	jsr $cabc			jsr 	BinaryMakeBothInteger
.ca6f	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.ca72	1d 0e 03	ora $030e,x			ora 	XS2_Mantissa+0,x
.ca75	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.ca78	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.ca7b	1d 0f 03	ora $030f,x			ora 	XS2_Mantissa+1,x
.ca7e	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.ca81	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.ca84	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.ca87	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.ca8a	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.ca8d	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.ca90	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.ca93	60		rts				rts
.ca94					BinaryOp_Eor:
.ca94					BinaryOp_Xor:
.ca94	20 bc ca	jsr $cabc			jsr 	BinaryMakeBothInteger
.ca97	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.ca9a	5d 0e 03	eor $030e,x			eor 	XS2_Mantissa+0,x
.ca9d	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.caa0	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.caa3	5d 0f 03	eor $030f,x			eor 	XS2_Mantissa+1,x
.caa6	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.caa9	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.caac	5d 10 03	eor $0310,x			eor 	XS2_Mantissa+2,x
.caaf	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.cab2	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.cab5	5d 11 03	eor $0311,x			eor 	XS2_Mantissa+3,x
.cab8	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.cabb	60		rts				rts
.cabc					BinaryMakeBothInteger:
.cabc	da		phx				phx 								; save X
.cabd	e8		inx				inx
.cabe	e8		inx				inx
.cabf	e8		inx				inx
.cac0	e8		inx				inx
.cac1	e8		inx				inx
.cac2	e8		inx				inx
.cac3	20 c7 ca	jsr $cac7			jsr 	BinaryMakeInteger 			; convert to integer.
.cac6	fa		plx				plx 								; restore X and fall through.
.cac7					BinaryMakeInteger:
.cac7	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type byte.
.caca	29 0f		and #$0f			and 	#15 						; check type zero
.cacc	f0 04		beq $cad2			beq 	_BMIConvert 				; if float convert to integer.
.cace	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.cacf	90 04		bcc $cad5			bcc 	_BMIError
.cad1	60		rts				rts
.cad2					_BMIConvert:
.cad2	4c 5d db	jmp $db5d			jmp 	FPUToInteger 				; convert to integer
.cad5					_BMIError:
.cad5	4c d4 c3	jmp $c3d4			jmp 	TypeError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.cad8					Binary_Equal:
.cad8	20 24 cb	jsr $cb24			jsr 	CompareValues
.cadb	09 00		ora #$00			ora 	#0
.cadd	f0 04		beq $cae3			beq 	CCTrue
.cadf	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.cae1	80 02		bra $cae5			bra 	CCWrite
.cae3	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.cae5	9d 08 03	sta $0308,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.cae8	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.caeb	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.caee	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.caf1	a9 01		lda #$01			lda 	#1
.caf3	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; set type to integer whatever.
.caf6	60		rts				rts
.caf7					Binary_NotEqual:
.caf7	20 24 cb	jsr $cb24			jsr 	CompareValues
.cafa	09 00		ora #$00			ora 	#0
.cafc	f0 e1		beq $cadf			beq 	CCFalse
.cafe	80 e3		bra $cae3			bra 	CCTrue
.cb00					Binary_Less:
.cb00	20 24 cb	jsr $cb24			jsr 	CompareValues
.cb03	09 00		ora #$00			ora 	#0
.cb05	30 dc		bmi $cae3			bmi 	CCTrue
.cb07	80 d6		bra $cadf			bra 	CCFalse
.cb09					Binary_LessEqual:
.cb09	20 24 cb	jsr $cb24			jsr 	CompareValues
.cb0c	c9 01		cmp #$01			cmp 	#1
.cb0e	d0 d3		bne $cae3			bne 	CCTrue
.cb10	80 cd		bra $cadf			bra 	CCFalse
.cb12					Binary_GreaterEqual:
.cb12	20 24 cb	jsr $cb24			jsr 	CompareValues
.cb15	09 00		ora #$00			ora 	#0
.cb17	10 ca		bpl $cae3			bpl 	CCTrue
.cb19	80 c4		bra $cadf			bra 	CCFalse
.cb1b					Binary_Greater:
.cb1b	20 24 cb	jsr $cb24			jsr 	CompareValues
.cb1e	c9 01		cmp #$01			cmp 	#1
.cb20	f0 c1		beq $cae3			beq 	CCTrue
.cb22	80 bb		bra $cadf			bra 	CCFalse
.cb24					CompareValues:
.cb24	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and the types together
.cb27	3d 13 03	and $0313,x			and 	XS2_Type,x
.cb2a	c9 02		cmp #$02			cmp 	#2
.cb2c	f0 13		beq $cb41			beq 	_CVString
.cb2e	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.cb31	3d 13 03	and $0313,x			and 	XS2_Type,x
.cb34	4a		lsr a				lsr 	a 							; shift bit 0 into C
.cb35	90 03		bcc $cb3a			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.cb37	4c 87 cb	jmp $cb87			jmp 	CompareInteger32 							; so execute code at \1
.cb3a					_BCFloat:
.cb3a	20 55 cc	jsr $cc55			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.cb3d	4c 6c da	jmp $da6c			jmp 	FPCompare 							; and execute code at \2
.cb40	60		rts				rts
.cb41					_CVString:
.cb41	da		phx				phx 								; save XY
.cb42	5a		phy				phy
.cb43	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.cb46	85 1a		sta $1a				sta		zLTemp1+0
.cb48	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.cb4b	85 1b		sta $1b				sta 	zLTemp1+1
.cb4d	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x
.cb50	85 1c		sta $1c				sta 	zLTemp1+2
.cb52	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.cb55	85 1d		sta $1d				sta 	zLTemp1+3
.cb57	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.cb59	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.cb5b	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.cb5d	90 02		bcc $cb61			bcc 	_CVCommon
.cb5f	b1 1c		lda ($1c),y			lda 	(zLTemp1+2),y
.cb61					_CVCommon:
.cb61	aa		tax				tax 								; put shorter string length in zero.
.cb62	f0 0c		beq $cb70			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.cb64					_CVCompare:
.cb64	c8		iny				iny 								; next character
.cb65	b1 1a		lda ($1a),y			lda 	(zLTemp1),y 				; compare characters
.cb67	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.cb69	90 13		bcc $cb7e			bcc 	_CVReturnLess 				; <
.cb6b	d0 15		bne $cb82			bne 	_CVReturnGreater 			; >
.cb6d	ca		dex				dex 								; until common length matched.
.cb6e	d0 f4		bne $cb64			bne 	_CVCompare
.cb70					_CVMatch:
.cb70	a0 00		ldy #$00			ldy 	#0
.cb72	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.cb74	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.cb76	90 06		bcc $cb7e			bcc 	_CVReturnLess 				; <
.cb78	d0 08		bne $cb82			bne 	_CVReturnGreater 			; >
.cb7a	a9 00		lda #$00			lda 	#0
.cb7c	80 06		bra $cb84			bra 	_CVExit 					; same common, same length, same string
.cb7e					_CVReturnLess:
.cb7e	a9 ff		lda #$ff			lda 	#$FF
.cb80	80 02		bra $cb84			bra 	_CVExit
.cb82					_CVReturnGreater:
.cb82	a9 01		lda #$01			lda 	#$01
.cb84					_CVExit:
.cb84	7a		ply				ply
.cb85	fa		plx				plx
.cb86	60		rts				rts
.cb87					CompareInteger32:
.cb87	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.cb8a	49 80		eor #$80			eor 	#$80
.cb8c	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.cb8f	bd 11 03	lda $0311,x			lda 	XS2_Mantissa+3,x
.cb92	49 80		eor #$80			eor 	#$80
.cb94	9d 11 03	sta $0311,x			sta 	XS2_Mantissa+3,x
.cb97	20 2f cc	jsr $cc2f			jsr 	SubInteger32 				; subtraction
.cb9a	90 11		bcc $cbad			bcc 	_CI32Less 					; cc return -1
.cb9c	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; check if zero
.cb9f	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.cba2	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.cba5	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.cba8	f0 02		beq $cbac			beq 	_CI32Exit
.cbaa	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.cbac					_CI32Exit:
.cbac	60		rts				rts
.cbad					_CI32Less:
.cbad	a9 ff		lda #$ff			lda 	#$FF
.cbaf	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.cbb0					BinaryOp_Add:
.cbb0	bd 0d 03	lda $030d,x			lda 	XS_Type,x  					; and types together
.cbb3	3d 13 03	and $0313,x			and 	XS2_Type,x
.cbb6	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.cbb8	d0 13		bne $cbcd			bne 	_BOAString
.cbba	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.cbbd	3d 13 03	and $0313,x			and 	XS2_Type,x
.cbc0	4a		lsr a				lsr 	a 							; shift bit 0 into C
.cbc1	90 03		bcc $cbc6			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.cbc3	4c 09 cc	jmp $cc09			jmp 	AddInteger32 							; so execute code at \1
.cbc6					_BCFloat:
.cbc6	20 55 cc	jsr $cc55			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.cbc9	4c e0 d7	jmp $d7e0			jmp 	FPAdd 							; and execute code at \2
.cbcc	60		rts				rts
.cbcd					_BOAString:
.cbcd	4c 70 cc	jmp $cc70			jmp 	ConcatenateString 			; concatenate two strings.
.cbd0					BinaryOp_Subtract:
.cbd0	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.cbd3	3d 13 03	and $0313,x			and 	XS2_Type,x
.cbd6	4a		lsr a				lsr 	a 							; shift bit 0 into C
.cbd7	90 03		bcc $cbdc			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.cbd9	4c 2f cc	jmp $cc2f			jmp 	SubInteger32 							; so execute code at \1
.cbdc					_BCFloat:
.cbdc	20 55 cc	jsr $cc55			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.cbdf	4c d6 d7	jmp $d7d6			jmp 	FPSubtract 							; and execute code at \2
.cbe2	60		rts				rts
.cbe3					BinaryOp_Multiply:
.cbe3	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.cbe6	3d 13 03	and $0313,x			and 	XS2_Type,x
.cbe9	4a		lsr a				lsr 	a 							; shift bit 0 into C
.cbea	90 03		bcc $cbef			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.cbec	4c 66 d5	jmp $d566			jmp 	MulInteger32 							; so execute code at \1
.cbef					_BCFloat:
.cbef	20 55 cc	jsr $cc55			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.cbf2	4c 4c d9	jmp $d94c			jmp 	FPMultiply 							; and execute code at \2
.cbf5	60		rts				rts
.cbf6					BinaryOp_Divide:
.cbf6	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.cbf9	3d 13 03	and $0313,x			and 	XS2_Type,x
.cbfc	4a		lsr a				lsr 	a 							; shift bit 0 into C
.cbfd	90 03		bcc $cc02			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.cbff	4c bd d5	jmp $d5bd			jmp 	DivInteger32 							; so execute code at \1
.cc02					_BCFloat:
.cc02	20 55 cc	jsr $cc55			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.cc05	4c c4 d8	jmp $d8c4			jmp 	FPDivide 							; and execute code at \2
.cc08	60		rts				rts
.cc09					AddInteger32:
.cc09	18		clc				clc
.cc0a	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.cc0d	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.cc10	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.cc13	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.cc16	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.cc19	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.cc1c	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.cc1f	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.cc22	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.cc25	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.cc28	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.cc2b	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.cc2e	60		rts				rts
.cc2f					SubInteger32:
.cc2f	38		sec				sec
.cc30	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.cc33	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.cc36	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.cc39	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.cc3c	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.cc3f	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.cc42	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.cc45	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.cc48	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.cc4b	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.cc4e	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.cc51	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.cc54	60		rts				rts
.cc55					BinaryMakeBothFloat:
.cc55	da		phx				phx 								; save X
.cc56	e8		inx				inx
.cc57	e8		inx				inx
.cc58	e8		inx				inx
.cc59	e8		inx				inx
.cc5a	e8		inx				inx
.cc5b	e8		inx				inx
.cc5c	20 60 cc	jsr $cc60			jsr 	BinaryMakeFloat 			; convert to float.
.cc5f	fa		plx				plx 								; restore X and fall through.
.cc60					BinaryMakeFloat:
.cc60	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type byte.
.cc63	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.cc64	b0 04		bcs $cc6a			bcs 	_BMFConvert
.cc66	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.cc67	b0 04		bcs $cc6d			bcs 	_BMFError
.cc69	60		rts				rts
.cc6a					_BMFConvert:
.cc6a	4c fe da	jmp $dafe			jmp 	FPUToFloat 					; convert to float
.cc6d					_BMFError:
.cc6d	4c d4 c3	jmp $c3d4			jmp 	TypeError
.cc70					ConcatenateString:
.cc70	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.cc73	85 1a		sta $1a				sta		zLTemp1+0
.cc75	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.cc78	85 1b		sta $1b				sta 	zLTemp1+1
.cc7a	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x
.cc7d	85 1c		sta $1c				sta 	zLTemp1+2
.cc7f	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.cc82	85 1d		sta $1d				sta 	zLTemp1+3
.cc84	5a		phy				phy
.cc85	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.cc87	b1 1a		lda ($1a),y			lda 	(zlTemp1),y
.cc89	71 1c		adc ($1c),y			adc 	(zlTemp1+2),y
.cc8b	7a		ply				ply
.cc8c	b0 37		bcs $ccc5			bcs 	_CSError					; check in range.
.cc8e	c9 fe		cmp #$fe			cmp 	#maxString+1
.cc90	b0 33		bcs $ccc5			bcs 	_CSError
.cc92	20 e5 d0	jsr $d0e5			jsr 	AllocateTempString 			; store the result
.cc95	20 b0 cc	jsr $ccb0			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.cc98	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.cc9b	85 1a		sta $1a				sta 	zLTemp1
.cc9d	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.cca0	85 1b		sta $1b				sta 	zLTemp1+1
.cca2	20 b0 cc	jsr $ccb0			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.cca5	a5 20		lda $20				lda 	zTempStr 					; point current to new string
.cca7	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.ccaa	a5 21		lda $21				lda 	zTempStr+1
.ccac	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.ccaf	60		rts				rts
.ccb0					_CSCopyString:
.ccb0	da		phx				phx
.ccb1	5a		phy				phy
.ccb2	a0 00		ldy #$00			ldy 	#0 							; get length
.ccb4	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.ccb6	f0 0a		beq $ccc2			beq 	_CSCSExit 					; if zero, exit
.ccb8	aa		tax				tax 								; put in X
.ccb9					_CSCSLoop:
.ccb9	c8		iny				iny 								; get next char
.ccba	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.ccbc	20 10 d1	jsr $d110			jsr		WriteTempString 			; copy out
.ccbf	ca		dex				dex 								; do whole string
.ccc0	d0 f7		bne $ccb9			bne 	_CSCSLoop
.ccc2					_CSCSExit:
.ccc2	7a		ply				ply
.ccc3	fa		plx				plx
.ccc4	60		rts				rts
.ccc5					_CSError:
.ccc5	20 f3 c3	jsr $c3f3			jsr ERR_Handler
>ccc8	53 74 72 69 6e 67 20 74			.text "String too long",0
>ccd0	6f 6f 20 6c 6f 6e 67 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.ccd8					Unary_Sgn:
.ccd8	20 15 ca	jsr $ca15			jsr 	EvaluateNumberX 			; get value
.ccdb	20 a3 d0	jsr $d0a3			jsr 	CheckNextRParen 			; check right bracket.
.ccde	20 02 cd	jsr $cd02			jsr 	GetSignCurrent 				; get sign.
.cce1	09 00		ora #$00			ora 	#0
.cce3	10 09		bpl $ccee			bpl		UnarySetAInteger			; if 0,1 return that.
.cce5	80 00		bra $cce7			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.cce7					UnarySetAMinus1:
.cce7	a9 ff		lda #$ff			lda 	#$FF
.cce9	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.ccec	80 05		bra $ccf3			bra 	UnarySetAFill
.ccee					UnarySetAInteger:
.ccee	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.ccf1	a9 00		lda #$00			lda 	#0
.ccf3					UnarySetAFill:
.ccf3	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.ccf6	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.ccf9	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.ccfc	a9 01		lda #$01			lda 	#1
.ccfe	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.cd01	60		rts				rts
.cd02					GetSignCurrent:
.cd02	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; identify type.
.cd05	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.cd06	90 19		bcc $cd21			bcc 	_GSCFloat
.cd08	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.cd0b	30 11		bmi $cd1e			bmi 	_GSCMinus1
.cd0d	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x
.cd10	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.cd13	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.cd16	d0 03		bne $cd1b			bne 	_GSCPlus1
.cd18					_GSCZero:
.cd18	a9 00		lda #$00			lda 	#0
.cd1a	60		rts				rts
.cd1b					_GSCPlus1:
.cd1b	a9 01		lda #$01			lda 	#$01
.cd1d	60		rts				rts
.cd1e					_GSCMinus1:
.cd1e	a9 ff		lda #$ff			lda 	#$FF
.cd20	60		rts				rts
.cd21					_GSCFloat:
.cd21	3c 0d 03	bit $030d,x			bit 	XS_Type,x
.cd24	70 f2		bvs $cd18			bvs 	_GSCZero
.cd26	30 f6		bmi $cd1e			bmi 	_GSCMinus1
.cd28	80 f1		bra $cd1b			bra 	_GSCPlus1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.cd2a					Unary_Abs:
.cd2a	20 15 ca	jsr $ca15			jsr 	EvaluateNumberX 			; get value
.cd2d	20 a3 d0	jsr $d0a3			jsr 	CheckNextRParen 			; check right bracket.
.cd30	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.cd33	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.cd35	f0 08		beq $cd3f			beq 	_UAMinusFloat
.cd37	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; check MSB
.cd3a	10 0b		bpl $cd47			bpl 	_UAExit
.cd3c	4c 53 d6	jmp $d653			jmp 	IntegerNegateAlways 		; negation
.cd3f					_UAMinusFloat:
.cd3f	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; clear the sign bit.
.cd42	29 7f		and #$7f			and		#$7F
.cd44	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.cd47					_UAExit:
.cd47	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.cd48					Unary_Peek:
.cd48	a9 01		lda #$01			lda 	#1
.cd4a	80 06		bra $cd52			bra 	UPMain
.cd4c					Unary_Deek:
.cd4c	a9 02		lda #$02			lda 	#2
.cd4e	80 02		bra $cd52			bra 	UPMain
.cd50					Unary_Leek:
.cd50	a9 04		lda #$04			lda 	#4
.cd52					UPMain:
.cd52	48		pha				pha 								; set bytes to copy.
.cd53	20 24 ca	jsr $ca24			jsr 	EvaluateIntegerX 			; numeric parameter
.cd56	20 a3 d0	jsr $d0a3			jsr 	CheckNextRParen 			; right bracket.
.cd59	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.cd5c	85 1a		sta $1a				sta 	zLTemp1
.cd5e	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.cd61	85 1b		sta $1b				sta 	zLTemp1+1
.cd63	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.cd66	85 1c		sta $1c				sta 	zLTemp1+2
.cd68	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.cd6b	85 1d		sta $1d				sta 	zLTemp1+3
.cd6d	a9 00		lda #$00			lda 	#0 							; clear target area
.cd6f	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.cd72	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.cd75	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.cd78	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.cd7b	68		pla				pla 								; restore bytes to copy
.cd7c	da		phx				phx 								; save XY
.cd7d	5a		phy				phy
.cd7e	20 7a d0	jsr $d07a			jsr 	MemRead 					; read the bytes in
.cd81	7a		ply				ply 								; restore and exit
.cd82	fa		plx				plx
.cd83	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.cd84					Unary_Mod:
.cd84	20 b0 cd	jsr $cdb0			jsr 	_UMParameter 				; first parameter
.cd87	20 ab d0	jsr $d0ab			jsr 	CheckNextComma
.cd8a	da		phx				phx 								; second parameter
.cd8b	e8		inx				inx
.cd8c	e8		inx				inx
.cd8d	e8		inx				inx
.cd8e	e8		inx				inx
.cd8f	e8		inx				inx
.cd90	e8		inx				inx
.cd91	20 b0 cd	jsr $cdb0			jsr 	_UMParameter
.cd94	fa		plx				plx
.cd95	20 a3 d0	jsr $d0a3			jsr 	CheckNextRParen
.cd98	20 bd d5	jsr $d5bd			jsr 	DivInteger32 				; divide
.cd9b	a5 1a		lda $1a				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.cd9d	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.cda0	a5 1b		lda $1b				lda 	zLTemp1+1
.cda2	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.cda5	a5 1c		lda $1c				lda 	zLTemp1+2
.cda7	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.cdaa	a5 1d		lda $1d				lda 	zLTemp1+3
.cdac	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.cdaf	60		rts				rts
.cdb0					_UMParameter:
.cdb0	20 24 ca	jsr $ca24			jsr 	EvaluateIntegerX 			; get value
.cdb3	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; absolute value
.cdb6	10 03		bpl $cdbb			bpl 	_UMNotSigned
.cdb8	20 53 d6	jsr $d653			jsr 	IntegerNegateAlways
.cdbb					_UMNotSigned:
.cdbb	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.cdbc					Unary_Usr:
.cdbc	20 15 ca	jsr $ca15			jsr 	EvaluateNumberX 			; numeric parameter
.cdbf	20 a3 d0	jsr $d0a3			jsr 	CheckNextRParen 			; right bracket.
.cdc2	da		phx				phx 								; save XY
.cdc3	5a		phy				phy
.cdc4	ea		nop				nop
.cdc5	20 00 03	jsr $0300			jsr 	UserVector 					; call the USR function.
.cdc8	7a		ply				ply 								; and exit
.cdc9	fa		plx				plx
.cdca	60		rts				rts
.cdcb					USRDefault:
.cdcb	20 f3 c3	jsr $c3f3			jsr ERR_Handler
>cdce	4e 6f 20 55 53 52 20 76			.text "No USR vector.",0
>cdd6	65 63 74 6f 72 2e 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.cddd					Unary_Val:
.cddd	20 2d ca	jsr $ca2d			jsr 	EvaluateStringX 			; get string
.cde0	20 a3 d0	jsr $d0a3			jsr 	CheckNextRParen 			; check right bracket.
.cde3	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.cde6	85 1e		sta $1e				sta 	zGenPtr
.cde8	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.cdeb	85 1f		sta $1f				sta 	zGenPtr+1
.cded	5a		phy				phy
.cdee	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.cdf0	b1 1e		lda ($1e),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.cdf2	f0 57		beq $ce4b			beq 	_UVBadNumber
.cdf4	48		pha				pha 								; save length.
.cdf5	1a		inc a				inc 	a 							; one for the length, one for the terminator
.cdf6	1a		inc a				inc 	a
.cdf7	20 e5 d0	jsr $d0e5			jsr 	AllocateTempString
.cdfa	c8		iny				iny 								; move to the next.
.cdfb	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get character
.cdfd	49 2d		eor #$2d			eor 	#"-"						; zero if minus sign
.cdff	8d 90 04	sta $0490			sta 	ValSign
.ce02	d0 04		bne $ce08			bne 	_UVNotMinus
.ce04	c8		iny				iny 								; skip over it.
.ce05	68		pla				pla 								; decrement character count.
.ce06	3a		dec a				dec 	a
.ce07	48		pha				pha
.ce08					_UVNotMinus:
.ce08	68		pla				pla 								; this is the count.
.ce09	48		pha		_UVCopy:pha									; copy into new temp string which is ASCIIZ
.ce0a	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.ce0c	c8		iny				iny
.ce0d	20 10 d1	jsr $d110			jsr 	WriteTempString
.ce10	68		pla				pla
.ce11	3a		dec a				dec 	a
.ce12	d0 f5		bne $ce09			bne 	_UVCopy
.ce14	20 10 d1	jsr $d110			jsr 	WriteTempString 			; make it ASCIIZ
.ce17	18		clc				clc
.ce18	a5 20		lda $20				lda 	zTempStr 					; tempstring +1 => genptr
.ce1a	69 01		adc #$01			adc 	#1
.ce1c	85 1e		sta $1e				sta 	zGenPtr
.ce1e	a5 21		lda $21				lda 	zTempStr+1
.ce20	69 00		adc #$00			adc 	#0
.ce22	85 1f		sta $1f				sta 	zGenPtr+1
.ce24	18		clc				clc
.ce25	20 2b d7	jsr $d72b			jsr 	IntFromString 				; first bit.
.ce28	b0 21		bcs $ce4b			bcs 	_UVBadNumber
.ce2a	20 4f dd	jsr $dd4f			jsr 	FPFromString				; try for a float part.
.ce2d	ad 90 04	lda $0490			lda 	ValSign 					; was it negative
.ce30	d0 13		bne $ce45			bne 	_UVNotNegative
.ce32	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; check if integer
.ce35	4a		lsr a				lsr 	a
.ce36	b0 0a		bcs $ce42			bcs 	_UVInteger
.ce38	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; set sign bit
.ce3b	09 80		ora #$80			ora 	#$80
.ce3d	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.ce40	80 03		bra $ce45			bra 	_UVNotNegative
.ce42					_UVInteger:
.ce42	20 53 d6	jsr $d653			jsr 	IntegerNegateAlways 		; sign it.
.ce45					_UVNotNegative:
.ce45	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; used everything
.ce47	d0 02		bne $ce4b			bne 	_UVBadNumber
.ce49	7a		ply				ply
.ce4a	60		rts				rts
.ce4b					_UVBadNumber:
.ce4b	4c e2 c3	jmp $c3e2			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.ce4e					Unary_Str:
.ce4e	20 15 ca	jsr $ca15			jsr 	EvaluateNumberX 			; numeric parameter
.ce51	20 a3 d0	jsr $d0a3			jsr 	CheckNextRParen 			; right bracket.
.ce54	a9 00		lda #$00			lda 	#0 							; reset buffer index
.ce56	8d 04 04	sta $0404			sta 	NumBufX
.ce59	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.ce5c	4a		lsr a				lsr 	a
.ce5d	b0 05		bcs $ce64			bcs 	_USInt 						; if msb set do as integer
.ce5f	20 88 dc	jsr $dc88			jsr 	FPToString 					; call fp to str otherwise
.ce62	80 03		bra $ce67			bra 	_USDuplicate
.ce64	20 78 d6	jsr $d678	_USInt:	jsr 	IntToString
.ce67					_USDuplicate:
.ce67	ad 04 04	lda $0404			lda 	NumBufX 					; chars in buffer
.ce6a	1a		inc a				inc 	a 							; one more for length
.ce6b	20 e5 d0	jsr $d0e5			jsr 	AllocateTempString 			; allocate space for it.
.ce6e	5a		phy				phy 								; save Y
.ce6f	a0 00		ldy #$00			ldy 	#0 							; start copying
.ce71	b9 05 04	lda $0405,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.ce74	20 10 d1	jsr $d110			jsr 	WriteTempString
.ce77	c8		iny				iny
.ce78	cc 04 04	cpy $0404			cpy 	NumBufX 					; done the lot
.ce7b	d0 f4		bne $ce71			bne 	_USCopy
.ce7d	7a		ply				ply 								; restore Y
.ce7e	4c 6a d0	jmp $d06a			jmp 	UnaryReturnTempStr 			; return new temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.ce81					Unary_Asc:
.ce81	20 2d ca	jsr $ca2d			jsr 	EvaluateStringX 			; string parameter
.ce84	20 a3 d0	jsr $d0a3			jsr 	CheckNextRParen 			; right bracket.
.ce87	5a		phy				phy 								; get the string length
.ce88	a0 00		ldy #$00			ldy 	#0
.ce8a	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.ce8c	f0 07		beq $ce95			beq 	_UAIllegal 					; must be at least one character
.ce8e	c8		iny				iny
.ce8f	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; read it.
.ce91	7a		ply				ply
.ce92	4c ee cc	jmp $ccee			jmp 	UnarySetAInteger
.ce95					_UAIllegal:
.ce95	4c e2 c3	jmp $c3e2			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.ce98					Unary_Len:
.ce98	20 2d ca	jsr $ca2d			jsr 	EvaluateStringX 			; string parameter
.ce9b	20 a3 d0	jsr $d0a3			jsr 	CheckNextRParen 			; right bracket.
.ce9e	5a		phy				phy 								; get the string length
.ce9f	a0 00		ldy #$00			ldy 	#0
.cea1	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.cea3	7a		ply				ply
.cea4	4c ee cc	jmp $ccee			jmp 	UnarySetAInteger

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.cea7					Unary_Mid:
.cea7	20 2d ca	jsr $ca2d			jsr 	EvaluateStringX 				; get string.
.ceaa	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.cead	48		pha				pha
.ceae	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.ceb1	48		pha				pha
.ceb2	20 ab d0	jsr $d0ab			jsr 	CheckNextComma 					; skip comma
.ceb5	20 42 cf	jsr $cf42			jsr 	SLIByteParameter 				; get a byte parameter (start)
.ceb8	48		pha				pha 									; and push it.
.ceb9	20 ab d0	jsr $d0ab			jsr 	CheckNextComma 					; skip comma
.cebc	20 42 cf	jsr $cf42			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.cebf	48		pha				pha 									; and push it.
.cec0	80 45		bra $cf07			bra 	SLIProcess
.cec2					Unary_Left:
.cec2	20 2d ca	jsr $ca2d			jsr 	EvaluateStringX 				; get string.
.cec5	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.cec8	48		pha				pha
.cec9	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.cecc	48		pha				pha
.cecd	a9 01		lda #$01			lda 	#1 								; push start position (1)
.cecf	48		pha				pha
.ced0	20 ab d0	jsr $d0ab			jsr 	CheckNextComma 					; skip comma
.ced3	20 42 cf	jsr $cf42			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.ced6	48		pha				pha 									; and push it.
.ced7	80 2e		bra $cf07			bra 	SLIProcess
.ced9					Unary_Right:
.ced9	20 2d ca	jsr $ca2d			jsr 	EvaluateStringX 				; get string.
.cedc	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.cedf	48		pha				pha
.cee0	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.cee3	48		pha				pha
.cee4	da		phx				phx 									; get the string length and push on stack.
.cee5	a2 00		ldx #$00			ldx 	#0
.cee7	a1 1e		lda ($1e,x)			lda		(zGenPtr,x)
.cee9	fa		plx				plx
.ceea	48		pha				pha
.ceeb	20 ab d0	jsr $d0ab			jsr 	CheckNextComma 					; skip comma
.ceee	20 42 cf	jsr $cf42			jsr 	SLIByteParameter 				; get a byte parameter.
.cef1	8d 8e 04	sta $048e			sta 	SignCount 						; save in temporary.
.cef4	68		pla				pla 									; restore string length.
.cef5	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.cef6	38		sec				sec
.cef7	ed 8e 04	sbc $048e			sbc 	SignCount 						; subtract characters needed, gives start position.
.cefa	f0 02		beq $cefe			beq 	_URStart 						; if <= 0 start from 1.
.cefc	10 02		bpl $cf00			bpl 	_UROkay
.cefe					_URStart:
.cefe	a9 01		lda #$01			lda 	#1
.cf00					_UROkay:
.cf00	48		pha				pha 									; push start
.cf01	ad 8e 04	lda $048e			lda 	SignCount 						; push count of characters
.cf04	48		pha				pha
.cf05	80 00		bra $cf07			bra 	SLIProcess
.cf07					SLIProcess:
.cf07	20 a3 d0	jsr $d0a3			jsr 	CheckNextRParen 				; closing right bracket.
.cf0a	68		pla				pla
.cf0b	8d 92 04	sta $0492			sta 	SliceCount 						; count in signcount
.cf0e	1a		inc a				inc 	a 								; allocate +1 for it.
.cf0f	20 e5 d0	jsr $d0e5			jsr 	AllocateTempString
.cf12	68		pla				pla 									; pop start number off stack.
.cf13	f0 3f		beq $cf54			beq 	SLIError 						; exit if start = 0
.cf15	8d 91 04	sta $0491			sta 	SliceStart
.cf18	68		pla				pla  									; pop string address.
.cf19	85 1f		sta $1f				sta 	zGenPtr+1
.cf1b	68		pla				pla
.cf1c	85 1e		sta $1e				sta 	zGenPtr
.cf1e	da		phx				phx
.cf1f	5a		phy				phy
.cf20	a2 00		ldx #$00			ldx 	#0 								; point to string length.
.cf22	ac 91 04	ldy $0491			ldy 	SliceStart 						; start of the string (+1 for count)
.cf25					_SLICopy:
.cf25	ad 92 04	lda $0492			lda 	SliceCount 						; done count characters
.cf28	f0 12		beq $cf3c			beq 	_SLIExit
.cf2a	ce 92 04	dec $0492			dec 	SliceCount
.cf2d	98		tya				tya 									; index of character
.cf2e	c1 1e		cmp ($1e,x)			cmp 	(zGenPtr,x)						; compare against length
.cf30	f0 02		beq $cf34			beq 	_SLIOk 							; if equal, okay.
.cf32	b0 08		bcs $cf3c			bcs 	_SLIExit 						; if past end, then exit.
.cf34	b1 1e		lda ($1e),y	_SLIOk:	lda 	(zGenPtr),y 					; copy one character
.cf36	c8		iny				iny
.cf37	20 10 d1	jsr $d110			jsr 	WriteTempString
.cf3a	80 e9		bra $cf25			bra 	_SLICopy 						; go round till copied characters
.cf3c					_SLIExit:
.cf3c	7a		ply				ply 									; restore YX
.cf3d	fa		plx				plx
.cf3e	4c 6a d0	jmp $d06a			jmp 	UnaryReturnTempStr 				; return new temporary string.
.cf41	ea		nop				nop
.cf42					SLIByteParameter:
.cf42	20 24 ca	jsr $ca24			jsr 	EvaluateIntegerX 				; get integer
.cf45	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.cf48	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.cf4b	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.cf4e	d0 04		bne $cf54			bne 	SLIError
.cf50	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.cf53	60		rts				rts
.cf54					SLIError:
.cf54	4c e2 c3	jmp $c3e2			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.cf57					Unary_Hex:
.cf57	20 24 ca	jsr $ca24			jsr 	EvaluateIntegerX 			; numeric parameter
.cf5a	20 a3 d0	jsr $d0a3			jsr 	CheckNextRParen 			; right bracket.
.cf5d	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.cf5f	20 e5 d0	jsr $d0e5			jsr 	AllocateTempString			; allocate string space
.cf62	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.cf65	20 8c cf	jsr $cf8c			jsr 	_UHConvert
.cf68	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.cf6b	20 8c cf	jsr $cf8c			jsr 	_UHConvert
.cf6e	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.cf71	20 8c cf	jsr $cf8c			jsr 	_UHConvert
.cf74	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.cf77	20 8c cf	jsr $cf8c			jsr 	_UHConvert
.cf7a	5a		phy				phy 								; get length of new string
.cf7b	a0 00		ldy #$00			ldy 	#0
.cf7d	b1 20		lda ($20),y			lda 	(zTempStr),y
.cf7f	7a		ply				ply
.cf80	c9 00		cmp #$00			cmp 	#0
.cf82	d0 05		bne $cf89			bne 	_UHExit 					; if it was non zero okay
.cf84	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.cf86	20 10 d1	jsr $d110			jsr 	WriteTempString
.cf89					_UHExit:
.cf89	4c 6a d0	jmp $d06a			jmp 	UnaryReturnTempStr 			; return new temporary string.
.cf8c					_UHConvert:
.cf8c	48		pha				pha
.cf8d	4a		lsr a				lsr 	a 							; do MSB
.cf8e	4a		lsr a				lsr 	a
.cf8f	4a		lsr a				lsr 	a
.cf90	4a		lsr a				lsr 	a
.cf91	20 95 cf	jsr $cf95			jsr 	_UHNibble
.cf94	68		pla				pla 								; do LSB
.cf95					_UHNibble:
.cf95	29 0f		and #$0f			and 	#15 						; get nibble
.cf97	d0 0c		bne $cfa5			bne 	_UHNonZero
.cf99	5a		phy				phy									; get the length
.cf9a	a0 00		ldy #$00			ldy 	#0
.cf9c	b1 20		lda ($20),y			lda 	(zTempStr),y
.cf9e	7a		ply				ply
.cf9f	c9 00		cmp #$00			cmp 	#0 							; suppress leading zeros.
.cfa1	f0 0d		beq $cfb0			beq 	_UHExit2
.cfa3	a9 00		lda #$00			lda 	#0
.cfa5					_UHNonZero:
.cfa5	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.cfa7	90 02		bcc $cfab			bcc 	_UHDigit
.cfa9	69 06		adc #$06			adc 	#7-1
.cfab					_UHDigit:
.cfab	69 30		adc #$30			adc 	#48
.cfad	20 10 d1	jsr $d110			jsr 	WriteTempString				; output.
.cfb0					_UHExit2:
.cfb0	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.cfb1					Unary_Dec:
.cfb1	20 2d ca	jsr $ca2d			jsr 	EvaluateStringX 			; string parameter
.cfb4	20 a3 d0	jsr $d0a3			jsr 	CheckNextRParen 			; right bracket.
.cfb7	5a		phy				phy
.cfb8	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.cfba	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.cfbc	f0 4c		beq $d00a			beq 	_UDFail 					; must fail if zero.
.cfbe	8d 8e 04	sta $048e			sta 	SignCount 					; use SignCount as a counter
.cfc1	a9 00		lda #$00			lda 	#0 							; set result to zero integer.
.cfc3	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.cfc6	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.cfc9	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.cfcc	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.cfcf	a9 01		lda #$01			lda 	#1
.cfd1	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.cfd4					_UDConvertLoop:
.cfd4	5a		phy				phy 								; shift mantissa left 4
.cfd5	a0 04		ldy #$04			ldy 	#4
.cfd7					_UDShift:
.cfd7	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x
.cfda	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.cfdd	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.cfe0	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.cfe3	88		dey				dey
.cfe4	d0 f1		bne $cfd7			bne 	_UDShift
.cfe6	7a		ply				ply
.cfe7	c8		iny				iny 								; next character
.cfe8	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; fetch it.
.cfea	20 0d d0	jsr $d00d			jsr 	ConvertUpper 				; convert to U/C
.cfed	c9 30		cmp #$30			cmp 	#"0"
.cfef	90 19		bcc $d00a			bcc 	_UDFail
.cff1	c9 3a		cmp #$3a			cmp 	#"9"+1
.cff3	90 06		bcc $cffb			bcc 	_UDOkay
.cff5	e9 37		sbc #$37			sbc 	#7+"0" 						; alpha fudge
.cff7	c9 10		cmp #$10			cmp 	#16
.cff9	b0 0f		bcs $d00a			bcs 	_UDFail
.cffb					_UDOkay:
.cffb	29 0f		and #$0f			and 	#15 						; nibble only
.cffd	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x
.d000	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.d003	ce 8e 04	dec $048e			dec 	SignCount 					; do it for each character
.d006	d0 cc		bne $cfd4			bne 	_UDConvertLoop
.d008	7a		ply				ply
.d009	60		rts				rts
.d00a					_UDFail:
.d00a	4c e2 c3	jmp $c3e2			jmp 	BadParamError
.d00d					ConvertUpper:
.d00d	c9 61		cmp #$61			cmp 	#"a"
.d00f	90 07		bcc $d018			bcc 	_CUExit
.d011	c9 7b		cmp #$7b			cmp 	#"z"+1
.d013	b0 03		bcs $d018			bcs 	_CUExit
.d015	38		sec				sec
.d016	e9 20		sbc #$20			sbc 	#32
.d018	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.d019					Unary_Chr:
.d019	20 24 ca	jsr $ca24			jsr 	EvaluateIntegerX			; numeric parameter
.d01c	20 a3 d0	jsr $d0a3			jsr 	CheckNextRParen 			; right bracket.
.d01f	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.d022	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.d025	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.d028	d0 0e		bne $d038			bne 	_UCChar
.d02a	a9 01		lda #$01			lda 	#1 							; one character string
.d02c	20 e5 d0	jsr $d0e5			jsr 	AllocateTempString
.d02f	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.d032	20 10 d1	jsr $d110			jsr 	WriteTempString
.d035	4c 6a d0	jmp $d06a			jmp 	UnaryReturnTempStr
.d038					_UCChar:
.d038	4c e2 c3	jmp $c3e2			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.d03b					Unary_Spc:
.d03b	20 24 ca	jsr $ca24			jsr 	EvaluateIntegerX 			; numeric parameter
.d03e	20 a3 d0	jsr $d0a3			jsr 	CheckNextRParen 			; right bracket.
.d041	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.d044	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.d047	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.d04a	d0 1b		bne $d067			bne 	_USSize
.d04c	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.d04f	c9 fe		cmp #$fe			cmp 	#maxString+1
.d051	b0 14		bcs $d067			bcs 	_USSize
.d053	48		pha				pha 								; save length
.d054	1a		inc a				inc 	a 							; allocate one more.
.d055	20 e5 d0	jsr $d0e5			jsr 	AllocateTempString
.d058	68		pla				pla 								; get length
.d059	f0 0f		beq $d06a			beq 	UnaryReturnTempStr 			; return the current temp string
.d05b					_USLoop:
.d05b	48		pha				pha
.d05c	a9 20		lda #$20			lda 	#" "
.d05e	20 10 d1	jsr $d110			jsr 	WriteTempString
.d061	68		pla				pla
.d062	3a		dec a				dec 	a
.d063	d0 f6		bne $d05b			bne 	_USLoop
.d065	80 03		bra $d06a			bra 	UnaryReturnTempStr
.d067					_USSize:
.d067	4c e2 c3	jmp $c3e2			jmp 	BadParamError
.d06a					UnaryReturnTempStr:
.d06a	a5 20		lda $20				lda 	zTempStr 					; copy temp string addr -> mantissa
.d06c	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.d06f	a5 21		lda $21				lda 	zTempStr+1
.d071	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.d074	a9 02		lda #$02			lda 	#2 							; set type to string
.d076	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.d079	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/6502.asm

.d07a					MemRead:
.d07a	8d 8e 04	sta $048e			sta 	SignCount 					; save count
.d07d	a0 00		ldy #$00			ldy 	#0 							; start from here
.d07f	b1 1a		lda ($1a),y	_MLoop1:lda 	(zlTemp1),y 				; read the long address
.d081	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; copy into mantissa
.d084	c8		iny				iny 								; next to copy
.d085	e8		inx				inx
.d086	cc 8e 04	cpy $048e			cpy 	SignCount 					; do required # of bytes.
.d089	d0 f4		bne $d07f			bne 	_MLoop1
.d08b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.d08c					CheckNextToken:
.d08c	d1 16		cmp ($16),y			cmp 	(zCodePtr),y
.d08e	d0 02		bne $d092			bne 	CTFail 						; no, then fail
.d090	c8		iny				iny
.d091	60		rts				rts
.d092					CTFail:
.d092	20 f3 c3	jsr $c3f3			jsr ERR_Handler
>d095	4d 69 73 73 69 6e 67 20			.text "Missing token",0
>d09d	74 6f 6b 65 6e 00
.d0a3					CheckNextRParen:
.d0a3	b1 16		lda ($16),y			lda 	(zCodePtr),y
.d0a5	c9 be		cmp #$be			cmp 	#token_rparen
.d0a7	d0 e9		bne $d092			bne 	CTFail
.d0a9	c8		iny				iny
.d0aa	60		rts				rts
.d0ab					CheckNextComma:
.d0ab	b1 16		lda ($16),y			lda 	(zCodePtr),y
.d0ad	c9 bf		cmp #$bf			cmp 	#token_comma
.d0af	d0 e1		bne $d092			bne 	CTFail
.d0b1	c8		iny				iny
.d0b2	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/concrete.asm

.d0b3					StringConcrete:
.d0b3	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; save source to zTemp1
.d0b6	85 10		sta $10				sta 	zTemp1
.d0b8	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.d0bb	85 11		sta $11				sta 	zTemp1+1
.d0bd	a0 00		ldy #$00			ldy 	#0 							; subtract the length+1 (clc) of the string.
.d0bf	18		clc				clc 								; from the string pointer
.d0c0	ad 00 04	lda $0400			lda 	StringPtr 					; and put in zTemp2 as well
.d0c3	f1 10		sbc ($10),y			sbc 	(zTemp1),y
.d0c5	8d 00 04	sta $0400			sta 	StringPtr
.d0c8	85 12		sta $12				sta 	zTemp2
.d0ca	ad 01 04	lda $0401			lda 	StringPtr+1
.d0cd	e9 00		sbc #$00			sbc 	#0
.d0cf	8d 01 04	sta $0401			sta 	StringPtr+1
.d0d2	85 13		sta $13				sta 	zTemp2+1
.d0d4	b1 10		lda ($10),y			lda 	(zTemp1),y 					; length add one for count
.d0d6	1a		inc a				inc 	a
.d0d7	aa		tax				tax
.d0d8	b1 10		lda ($10),y	_SCCopy:lda 	(zTemp1),y 					; copy whole thing including length
.d0da	91 12		sta ($12),y			sta 	(zTemp2),y
.d0dc	c8		iny				iny
.d0dd	ca		dex				dex
.d0de	d0 f8		bne $d0d8			bne 	_SCCopy
.d0e0	a5 13		lda $13				lda 	zTemp2+1 					; return concrete string in AX
.d0e2	a6 12		ldx $12				ldx 	zTemp2
.d0e4	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.d0e5					AllocateTempString:
.d0e5	48		pha				pha 								; save required count.
.d0e6	a5 21		lda $21				lda 	zTempStr+1 					; check if initialised yet ?
.d0e8	d0 0b		bne $d0f5			bne 	_ATSInitialised
.d0ea	ad 00 04	lda $0400			lda 	StringPtr 					; set temporary string ptr 1 page below available
.d0ed	85 20		sta $20				sta 	zTempStr					; space, this is for strings to be concreted.
.d0ef	ad 01 04	lda $0401			lda 	StringPtr+1
.d0f2	3a		dec a				dec 	a
.d0f3	85 21		sta $21				sta 	zTempStr+1
.d0f5					_ATSInitialised:
.d0f5	68		pla				pla 								; get required count back.
.d0f6	49 ff		eor #$ff			eor 	#$FF 						; negate 2's complement.
.d0f8	1a		inc a				inc 	a
.d0f9	18		clc				clc
.d0fa	65 20		adc $20				adc 	zTempStr 					; "add" to the temp string pointer
.d0fc	85 20		sta $20				sta 	zTempStr
.d0fe	a9 ff		lda #$ff			lda 	#$FF
.d100	65 21		adc $21				adc 	zTempStr+1
.d102	85 21		sta $21				sta 	zTempStr+1
.d104	a9 00		lda #$00			lda 	#0 							; clear temp string.
.d106	5a		phy				phy
.d107	a8		tay				tay
.d108	91 20		sta ($20),y			sta 	(zTempStr),y
.d10a	7a		ply				ply
.d10b	1a		inc a				inc 	a 							; reset the write index.
.d10c	8d 8f 04	sta $048f			sta 	TempStringWriteIndex
.d10f	60		rts				rts
.d110					WriteTempString:
.d110	5a		phy				phy 								; save Y
.d111	ac 8f 04	ldy $048f			ldy 	TempStringWriteIndex	 	; write position.
.d114	91 20		sta ($20),y			sta 	(zTempStr),y 				; write character out.
.d116	ee 8f 04	inc $048f			inc 	TempStringWriteIndex 		; increment the write position.
.d119	98		tya				tya 								; unchanged Y is now length
.d11a	a0 00		ldy #$00			ldy 	#0
.d11c	91 20		sta ($20),y			sta 	(zTempStr),y
.d11e	7a		ply				ply 								; restore Y and exit
.d11f	60		rts				rts
.d120					CreateTempStringCopy:
.d120	da		phx				phx 								; save X
.d121	b1 16		lda ($16),y			lda 	(zCodePtr),y
.d123	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.d124	20 e5 d0	jsr $d0e5			jsr 	AllocateTempString 			; allocate memory for temporary string.
.d127	b1 16		lda ($16),y			lda 	(zCodePtr),y
.d129	c8		iny				iny
.d12a	3a		dec a				dec 	a 							; make the actual length in charactes
.d12b	3a		dec a				dec 	a
.d12c	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.d12e	81 20		sta ($20,x)			sta 	(zTempStr,x)
.d130	85 1a		sta $1a				sta 	zLTemp1 					; that's used as a count.
.d132	09 00		ora #$00			ora 	#0 							; if zero already, exit
.d134	f0 0e		beq $d144			beq 	_CTSCExit
.d136					_CTSCLoop:
.d136	b1 16		lda ($16),y			lda 	(zCodePtr),y
.d138	c8		iny				iny
.d139	5a		phy				phy 								; save in Y
.d13a	e8		inx				inx 								; bump index
.d13b	da		phx				phx 								; index into Y
.d13c	7a		ply				ply
.d13d	91 20		sta ($20),y			sta 	(zTempStr),y 				; save at index
.d13f	7a		ply				ply 								; restore Y
.d140	c6 1a		dec $1a				dec 	zLTemp1 					; do for each character
.d142	d0 f2		bne $d136			bne 	_CTSCLoop
.d144					_CTSCExit:
.d144	fa		plx				plx 								; restore X
.d145	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/variables.asm

.d146					VariableFind:
.d146	20 b1 d1	jsr $d1b1			jsr 	VariableExtract 		; find out all about it ....
.d149	20 53 d4	jsr $d453			jsr 	VariableLocate 			; does it already exist ?
.d14c	b0 03		bcs $d151			bcs 	_VFExists 				; if so, use that.
.d14e	20 3d d2	jsr $d23d			jsr 	VariableCreate 			; otherwise create it.
.d151					_VFExists:
.d151	a5 24		lda $24				lda 	zVarType 				; is it still an array ?
.d153	29 01		and #$01			and 	#1
.d155	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.d157	d0 28		bne $d181			bne 	_VFSingleElement
.d159					_VFNextIndex:
.d159	a5 22		lda $22				lda 	zVarDataPtr 			; push the data ptr and type on the stack.
.d15b	48		pha				pha
.d15c	a5 23		lda $23				lda 	zVarDataPtr+1
.d15e	48		pha				pha
.d15f	a5 24		lda $24				lda 	zVarType
.d161	48		pha				pha
.d162	20 24 ca	jsr $ca24			jsr 	EvaluateIntegerX 		; calculate the index.
.d165	68		pla				pla 							; restore and index.
.d166	85 24		sta $24				sta 	zVarType
.d168	68		pla				pla
.d169	85 23		sta $23				sta 	zVarDataPtr+1
.d16b	68		pla				pla
.d16c	85 22		sta $22				sta 	zVarDataPtr
.d16e	20 c8 d2	jsr $d2c8			jsr 	ArrayIndexFollow 		; do the index.
.d171	a5 24		lda $24				lda 	zVarType 				; is it still an array ??
.d173	29 01		and #$01			and 	#1
.d175	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.d177	d0 05		bne $d17e			bne 	_VFArrayDone 			; if so then exit.
.d179	20 ab d0	jsr $d0ab			jsr 	CheckNextComma 			; comma should follow
.d17c	80 db		bra $d159			bra 	_VFNextIndex
.d17e					_VFArrayDone:
.d17e	20 a3 d0	jsr $d0a3			jsr 	CheckNextRParen 		; check closing right bracket.
.d181					_VFSingleElement:
.d181	60		rts				rts
.d182					VariableClear:
.d182	48		pha				pha 							; save registers
.d183	da		phx				phx
.d184	a2 00		ldx #$00			ldx 	#0 						; clear out the hash table.
.d186	8a		txa				txa
.d187	9d 25 04	sta $0425,x	_VCLoop:sta 	HashTableBase,x
.d18a	e8		inx				inx
.d18b	e0 60		cpx #$60			cpx 	#HashTableEnd-HashTableBase
.d18d	d0 f8		bne $d187			bne 	_VCLoop
.d18f	a9 00		lda #$00			lda 	#VariableMemory & $FF	; reset the free variable memory pointer
.d191	8d 02 04	sta $0402			sta 	VarMemPtr
.d194	a9 20		lda #$20			lda 	#VariableMemory >> 8
.d196	8d 03 04	sta $0403			sta 	VarMemPtr+1
.d199	fa		plx				plx 							; restore registers
.d19a	68		pla				pla
.d19b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/extract.asm

.d19c					VariableNameError:
.d19c	20 f3 c3	jsr $c3f3			jsr ERR_Handler
>d19f	42 61 64 20 56 61 72 69			.text "Bad Variable Name",0
>d1a7	61 62 6c 65 20 4e 61 6d 65 00
.d1b1					VariableExtract:
.d1b1	da		phx				phx 							; save X.
.d1b2	a9 ba		lda #$ba			lda 	#token_hashlParen  		; set the type to #( e.g. real array.
.d1b4	8d 85 04	sta $0485			sta 	Var_Type
.d1b7	8d 86 04	sta $0486			sta 	Var_Hash 				; we initialise the hash with this. It doesn't matter
.d1ba	b1 16		lda ($16),y			lda 	(zCodePtr),y
.d1bc	c9 00		cmp #$00			cmp 	#0 						; first one must be A-Z
.d1be	f0 dc		beq $d19c			beq 	VariableNameError
.d1c0	c9 1b		cmp #$1b			cmp 	#26+1
.d1c2	b0 d8		bcs $d19c			bcs 	VariableNameError
.d1c4	a2 ff		ldx #$ff			ldx 	#255 					; now copy it into the variable buffer.
.d1c6					_VECopyBuffer:
.d1c6	e8		inx				inx
.d1c7	e0 1f		cpx #$1f			cpx 	#31 					; too long
.d1c9	f0 d1		beq $d19c			beq 	VariableNameError
.d1cb	9d 05 04	sta $0405,x			sta 	Var_Buffer,x 			; save character
.d1ce	18		clc				clc  							; update the hash value for it.
.d1cf	6d 86 04	adc $0486			adc 	Var_Hash
.d1d2	8d 86 04	sta $0486			sta 	Var_Hash
.d1d5	c8		iny				iny
.d1d6	b1 16		lda ($16),y			lda 	(zCodePtr),y
.d1d8	c9 00		cmp #$00			cmp 	#0 						; zero or token, end of variable
.d1da	f0 0e		beq $d1ea			beq 	_VECopyEnd
.d1dc	30 0c		bmi $d1ea			bmi 	_VECopyEnd
.d1de	c9 1b		cmp #$1b			cmp 	#26+1 					; A-Z continue copying
.d1e0	90 e4		bcc $d1c6			bcc 	_VECopyBuffer
.d1e2	c9 30		cmp #$30			cmp 	#"0" 					; 0-9 copy as well.
.d1e4	90 04		bcc $d1ea			bcc 	_VECopyEnd
.d1e6	c9 3a		cmp #$3a			cmp 	#"9"+1
.d1e8	90 dc		bcc $d1c6			bcc 	_VECopyBuffer
.d1ea					_VECopyEnd:
.d1ea	c8		iny				iny
.d1eb	c9 b7		cmp #$b7			cmp 	#token_Dollar 			; first type token.
.d1ed	90 04		bcc $d1f3			bcc 	_VEDefaultRequired
.d1ef	c9 bd		cmp #$bd			cmp 	#token_PercentLParen+1	; last type token.
.d1f1	90 0b		bcc $d1fe			bcc 	_VEHaveType
.d1f3					_VEDefaultRequired:
.d1f3	c9 bd		cmp #$bd			cmp 	#token_LParen 			; if it ends in ( then use the real array
.d1f5	f0 04		beq $d1fb			beq 	_VESetType 				; default set above.
.d1f7	ce 85 04	dec $0485			dec 	Var_Type 				; this changes that default to the variable default
.d1fa	88		dey				dey
.d1fb					_VESetType:
.d1fb	ad 85 04	lda $0485			lda 	Var_Type 				; get type ....
.d1fe					_VEHaveType:
.d1fe	8d 85 04	sta $0485			sta 	Var_Type 				; save as type.
.d201	bd 05 04	lda $0405,x			lda 	Var_Buffer,x 			; set bit 7 of name, marks the end.
.d204	09 80		ora #$80			ora 	#$80
.d206	9d 05 04	sta $0405,x			sta 	Var_Buffer,x
.d209	e8		inx				inx 							; offset 3 => length 4.
.d20a	8e 87 04	stx $0487			stx 	Var_Length 				; save length of variable name.
.d20d	ad 85 04	lda $0485			lda 	Var_Type 				; get offset of var type from first type token
.d210	38		sec				sec
.d211	e9 b7		sbc #$b7			sbc 	#token_Dollar
.d213	0a		asl a				asl 	a 						; multiply by 16. This requires HashTableSize
.d214	0a		asl a				asl 	a 						; in data.asm to be 8 (8 sets of links,2 bytes each)
.d215	0a		asl a				asl 	a
.d216	0a		asl a				asl 	a
.d217	8d 88 04	sta $0488			sta 	Var_HashAddress
.d21a	ad 86 04	lda $0486			lda 	Var_Hash 				; get the hash
.d21d	29 07		and #$07			and 	#(HashTableSize-1) 		; force into range 0-tableSize-1
.d21f	0a		asl a				asl 	a 						; double it (2 bytes per entry) & clears carry
.d220	6d 88 04	adc $0488			adc 	Var_HashAddress 		; add table offset.
.d223	69 25		adc #$25			adc 	#HashTableBase & $FF 	; now the low byte of the actual table address
.d225	8d 88 04	sta $0488			sta 	Var_HashAddress
.d228	a2 05		ldx #$05			ldx 	#5 						; hash is 5 bytes (real)
.d22a	ad 85 04	lda $0485			lda 	Var_Type
.d22d	c9 b9		cmp #$b9			cmp 	#token_Hash
.d22f	f0 07		beq $d238			beq 	_VEHaveSize
.d231	ca		dex				dex
.d232	c9 bb		cmp #$bb			cmp 	#token_Percent 			; percent is 4 bytes (integer)
.d234	f0 02		beq $d238			beq 	_VEHaveSize
.d236	a2 02		ldx #$02			ldx 	#2 						; everything else is two.
.d238					_VEHaveSize:
.d238	8e 89 04	stx $0489			stx 	Var_DataSize
.d23b	fa		plx				plx
.d23c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varcreate.asm

.d23d					VariableCreate:
.d23d	da		phx				phx
.d23e	5a		phy				phy
.d23f	ad 02 04	lda $0402			lda 	VarMemPtr 					; get address of next free into zTemp1
.d242	85 10		sta $10				sta 	zTemp1
.d244	ad 03 04	lda $0403			lda 	VarMemPtr+1
.d247	85 11		sta $11				sta 	zTemp1+1
.d249	ad 89 04	lda $0489			lda 	Var_DataSize 				; bytes for the data bit
.d24c	18		clc				clc
.d24d	6d 87 04	adc $0487			adc 	Var_Length 					; add the length of the name
.d250	69 03		adc #$03			adc 	#3 							; 3 for the link and the hash.
.d252	6d 02 04	adc $0402			adc 	VarMemPtr 					; add to variable memory pointer
.d255	8d 02 04	sta $0402			sta 	VarMemPtr
.d258	90 03		bcc $d25d			bcc 	_VCNoCarry
.d25a	ee 03 04	inc $0403			inc 	VarMemPtr+1
.d25d					_VCNoCarry:
.d25d	ad 88 04	lda $0488			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.d260	85 12		sta $12				sta 	zTemp2
.d262	a9 04		lda #$04			lda 	#HashTableBase >> 8
.d264	85 13		sta $13				sta 	zTemp2+1
.d266	a0 00		ldy #$00			ldy 	#0 							; put current hash link in position.
.d268	b1 12		lda ($12),y			lda 	(zTemp2),y
.d26a	91 10		sta ($10),y			sta 	(zTemp1),y
.d26c	c8		iny				iny
.d26d	b1 12		lda ($12),y			lda 	(zTemp2),y
.d26f	91 10		sta ($10),y			sta 	(zTemp1),y
.d271	c8		iny				iny
.d272	ad 86 04	lda $0486			lda 	Var_Hash 					; write the hash out.
.d275	91 10		sta ($10),y			sta 	(zTemp1),y
.d277	c8		iny				iny
.d278	a2 00		ldx #$00			ldx 	#0 							; copy the name out.
.d27a					_VCCopyName:
.d27a	bd 05 04	lda $0405,x			lda 	Var_Buffer,x
.d27d	91 10		sta ($10),y			sta 	(zTemp1),y
.d27f	e8		inx				inx
.d280	c8		iny				iny
.d281	ec 87 04	cpx $0487			cpx 	Var_Length
.d284	d0 f4		bne $d27a			bne 	_VCCopyName
.d286	5a		phy				phy 								; save the data offset.
.d287	ae 89 04	ldx $0489			ldx 	Var_DataSize 				; and write the data out.
.d28a	a9 00		lda #$00			lda 	#0 							; which is all zeroes.
.d28c					_VCClearData:
.d28c	91 10		sta ($10),y			sta 	(zTemp1),y
.d28e	c8		iny				iny
.d28f	ca		dex				dex
.d290	d0 fa		bne $d28c			bne 	_VCClearData
.d292	68		pla				pla 								; offset to the data
.d293	18		clc				clc
.d294	65 10		adc $10				adc 	zTemp1 						; add to start and save as data pointer.
.d296	85 22		sta $22				sta 	zVarDataPtr
.d298	a5 11		lda $11				lda 	zTemp1+1
.d29a	69 00		adc #$00			adc 	#0
.d29c	85 23		sta $23				sta 	zVarDataPtr+1
.d29e	ad 85 04	lda $0485			lda 	Var_Type 					; and set the type.
.d2a1	85 24		sta $24				sta 	zVarType
.d2a3	a5 10		lda $10				lda 	zTemp1 						; fix hash link to point to new record
.d2a5	a0 00		ldy #$00			ldy 	#0
.d2a7	91 12		sta ($12),y			sta 	(zTemp2),y
.d2a9	c8		iny				iny
.d2aa	a5 11		lda $11				lda 	zTemp1+1
.d2ac	91 12		sta ($12),y			sta 	(zTemp2),y
.d2ae	ad 85 04	lda $0485			lda 	Var_Type 					; array ? if so create the empty one.
.d2b1	29 01		and #$01			and 	#1
.d2b3	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.d2b5	d0 0e		bne $d2c5			bne 	_VCNotArray
.d2b7	a2 00		ldx #$00			ldx 	#0 							; call recursive array creator
.d2b9	20 68 d3	jsr $d368			jsr 	ArrayCreate
.d2bc	5a		phy				phy 								; save YA at zVarDataPtr
.d2bd	a0 00		ldy #$00			ldy 	#0
.d2bf	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.d2c1	c8		iny				iny
.d2c2	68		pla				pla
.d2c3	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.d2c5					_VCNotArray:
.d2c5	7a		ply				ply
.d2c6	fa		plx				plx
.d2c7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arrayidx.asm

.d2c8					ArrayIndexFollow:
.d2c8	5a		phy				phy
.d2c9	a0 00		ldy #$00			ldy 	#0 							; make zVarDataPtr point to the array.
.d2cb	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; e.g. it points to itself.
.d2cd	48		pha				pha
.d2ce	c8		iny				iny
.d2cf	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.d2d1	85 23		sta $23				sta 	zVarDataPtr+1
.d2d3	68		pla				pla
.d2d4	85 22		sta $22				sta 	zVarDataPtr
.d2d6	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 			; MSB of 16 bit integer and bytes 2&3
.d2d9	29 80		and #$80			and 	#$80 						; must be zero.
.d2db	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.d2de	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.d2e1	d0 5f		bne $d342			bne 	_AIFError
.d2e3	a0 00		ldy #$00			ldy 	#0 							; calculate size - current - 1
.d2e5	18		clc				clc
.d2e6	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.d2e8	fd 08 03	sbc $0308,x			sbc 	XS_Mantissa+0,x
.d2eb	c8		iny				iny
.d2ec	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.d2ee	08		php				php 								; clear bit 7 retaining borrow.
.d2ef	29 7f		and #$7f			and 	#$7F
.d2f1	28		plp				plp
.d2f2	fd 09 03	sbc $0309,x			sbc 	XS_Mantissa+1,x
.d2f5	90 4b		bcc $d342			bcc 	_AIFError 					; eror if size-current < 0
.d2f7	bd 08 03	lda $0308,x			lda  	XS_Mantissa+0,x 			; copy and double the index
.d2fa	0a		asl a				asl 	a 							; (e.g. index * 2)
.d2fb	85 10		sta $10				sta 	zTemp1
.d2fd	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.d300	2a		rol a				rol 	a
.d301	85 11		sta $11				sta 	zTemp1+1
.d303	a0 01		ldy #$01			ldy 	#1 							; is this a data entry.
.d305	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; if so, then type is unchanged, offset set
.d307	30 1f		bmi $d328			bmi 	_AIFCalculate
.d309	c6 24		dec $24				dec 	zVarType 					; converts from an array to a type.
.d30b	a5 24		lda $24				lda 	zVarType 					; check that type
.d30d	c9 b7		cmp #$b7			cmp 	#token_Dollar 				; if string, use x 2
.d30f	f0 17		beq $d328			beq 	_AIFCalculate
.d311	06 10		asl $10				asl 	zTemp1			 			; double the index
.d313	26 11		rol $11				rol 	zTemp1+1					; (e.g. index * 4)
.d315	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if integer, use x 4
.d317	f0 0f		beq $d328			beq 	_AIFCalculate
.d319	18		clc				clc 								; add the original mantissa in again
.d31a	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; which makes it x5, for float.
.d31d	65 10		adc $10				adc 	zTemp1
.d31f	85 10		sta $10				sta 	zTemp1
.d321	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.d324	65 11		adc $11				adc 	zTemp1+1
.d326	85 11		sta $11				sta 	zTemp1+1
.d328					_AIFCalculate:
.d328	18		clc				clc 								; add index x 2,4 or 5 to base
.d329	a5 22		lda $22				lda 	zVarDataPtr
.d32b	65 10		adc $10				adc 	zTemp1
.d32d	85 22		sta $22				sta 	zVarDataPtr
.d32f	a5 23		lda $23				lda 	zVarDataPtr+1
.d331	65 11		adc $11				adc 	zTemp1+1
.d333	85 23		sta $23				sta 	zVarDataPtr+1
.d335	18		clc				clc 								; add 2 more for the length prefix.
.d336	a5 22		lda $22				lda 	zVarDataPtr
.d338	69 02		adc #$02			adc 	#2
.d33a	85 22		sta $22				sta 	zVarDataPtr
.d33c	90 02		bcc $d340			bcc 	_AIFNoBump
.d33e	e6 23		inc $23				inc 	zVarDataPtr+1
.d340					_AIFNoBump:
.d340	7a		ply				ply
.d341	60		rts				rts
.d342					_AIFError:
.d342	20 f3 c3	jsr $c3f3			jsr ERR_Handler
>d345	42 61 64 20 61 72 72 61			.text "Bad array index",0
>d34d	79 20 69 6e 64 65 78 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arraydef.asm

.d355					ArrayResetDefault:
.d355	a9 0b		lda #$0b			lda 	#11 						; 0..10 one array
.d357	8d 97 04	sta $0497			sta 	ArrayDef+0
.d35a	a9 00		lda #$00			lda 	#0
.d35c	8d 98 04	sta $0498			sta 	ArrayDef+1
.d35f	a9 ff		lda #$ff			lda 	#$FF
.d361	8d 99 04	sta $0499			sta 	ArrayDef+2 					; $FFFF implies no second element.
.d364	8d 9a 04	sta $049a			sta 	ArrayDef+3					; (test bit 7 of 2nd byte)
.d367	60		rts				rts
.d368					ArrayCreate:
.d368	bd 97 04	lda $0497,x			lda 	ArrayDef+0,x 				; put size x 2 in zTemp1
.d36b	0a		asl a				asl 	a
.d36c	85 10		sta $10				sta 	zTemp1
.d36e	bd 98 04	lda $0498,x			lda 	ArrayDef+1,x
.d371	2a		rol a				rol 	a
.d372	85 11		sta $11				sta 	zTemp1+1
.d374	bd 9a 04	lda $049a,x			lda 	ArrayDef+3,x 				; if this is the last element it's array of ptrs.
.d377	10 22		bpl $d39b			bpl 	_ACSized 					; if not multiply size x 2 (str) 4 (int) 5 (real)
.d379	ad 85 04	lda $0485			lda 	Var_Type 					; check the type
.d37c	c9 b8		cmp #$b8			cmp 	#token_DollarLParen 		; also if it is an array of strings $(
.d37e	f0 1b		beq $d39b			beq 	_ACSized
.d380	06 10		asl $10				asl 	zTemp1 						; double again
.d382	26 11		rol $11				rol 	zTemp1+1
.d384	b0 6f		bcs $d3f5			bcs 	ArrayIndexError 			; too large.
.d386	c9 bc		cmp #$bc			cmp 	#token_PercentLParen 		; if %( four bytes/entry is enough.
.d388	f0 11		beq $d39b			beq 	_ACSized
.d38a	18		clc				clc 								; add original value x 5 for reals.
.d38b	a5 10		lda $10				lda 	zTemp1
.d38d	7d 97 04	adc $0497,x			adc 	ArrayDef+0,x
.d390	85 10		sta $10				sta 	zTemp1
.d392	a5 11		lda $11				lda 	zTemp1+1
.d394	7d 98 04	adc $0498,x			adc 	ArrayDef+1,x
.d397	85 11		sta $11				sta 	zTemp1+1
.d399	b0 5a		bcs $d3f5			bcs 	ArrayIndexError
.d39b					_ACSized:
.d39b	18		clc				clc
.d39c	a5 10		lda $10				lda 	zTemp1
.d39e	69 02		adc #$02			adc 	#2
.d3a0	85 10		sta $10				sta 	zTemp1
.d3a2	90 04		bcc $d3a8			bcc 	_ACNoBump
.d3a4	e6 10		inc $10				inc 	zTemp1
.d3a6	f0 4d		beq $d3f5			beq 	ArrayIndexError
.d3a8					_ACNoBump:
.d3a8	18		clc				clc
.d3a9	ad 02 04	lda $0402			lda 	VarMemPtr 					; add this allocated count to VarMemPtr
.d3ac	85 12		sta $12				sta 	zTemp2						; save start in zTemp2/zTemp3
.d3ae	85 14		sta $14				sta 	zTemp3
.d3b0	65 10		adc $10				adc 	zTemp1
.d3b2	8d 02 04	sta $0402			sta 	VarMemPtr
.d3b5	ad 03 04	lda $0403			lda 	VarMemPtr+1
.d3b8	85 13		sta $13				sta 	zTemp2+1
.d3ba	85 15		sta $15				sta 	zTemp3+1
.d3bc	65 11		adc $11				adc 	zTemp1+1
.d3be	8d 03 04	sta $0403			sta 	VarMemPtr+1
.d3c1	85 11		sta $11				sta 	zTemp1+1
.d3c3	b0 30		bcs $d3f5			bcs 	ArrayIndexError
.d3c5	a0 00		ldy #$00			ldy 	#0							; write $00 out.
.d3c7					_ACClear:
.d3c7	98		tya				tya
.d3c8	91 12		sta ($12),y			sta 	(zTemp2),y
.d3ca	e6 12		inc $12				inc 	zTemp2
.d3cc	d0 02		bne $d3d0			bne 	_ACCBump
.d3ce	e6 13		inc $13				inc 	zTemp2+1
.d3d0					_ACCBump:
.d3d0	a5 12		lda $12				lda 	zTemp2
.d3d2	cd 02 04	cmp $0402			cmp 	VarMemPtr
.d3d5	d0 f0		bne $d3c7			bne 	_ACClear
.d3d7	a5 13		lda $13				lda 	zTemp2+1
.d3d9	cd 03 04	cmp $0403			cmp 	VarMemPtr+1
.d3dc	d0 e9		bne $d3c7			bne 	_ACClear
.d3de	a0 00		ldy #$00			ldy 	#0
.d3e0	bd 97 04	lda $0497,x			lda 	ArrayDef+0,x 				; copy the size into the start
.d3e3	91 14		sta ($14),y			sta 	(zTemp3),y
.d3e5	c8		iny				iny
.d3e6	bd 98 04	lda $0498,x			lda 	ArrayDef+1,x
.d3e9	91 14		sta ($14),y			sta 	(zTemp3),y
.d3eb	bd 9a 04	lda $049a,x			lda 	ArrayDef+3,x 				; have we reached the end
.d3ee	10 18		bpl $d408			bpl 	ACCFillRecursive
.d3f0	a4 15		ldy $15				ldy 	zTemp3+1 					; return address
.d3f2	a5 14		lda $14				lda 	zTemp3
.d3f4	60		rts				rts
.d3f5					ArrayIndexError:
.d3f5	20 f3 c3	jsr $c3f3			jsr ERR_Handler
>d3f8	42 61 64 20 61 72 72 61			.text "Bad array index",0
>d400	79 20 69 6e 64 65 78 00
.d408					ACCFillRecursive:
.d408	a9 ff		lda #$ff			lda 	#$FF 						; we mark the end, this is free space.
.d40a	a0 00		ldy #$00			ldy 	#0 							; this is overwritten by size of next allocated
.d40c	91 12		sta ($12),y			sta 	(zTemp2),y 					; array, but we might change that.
.d40e	c8		iny				iny
.d40f	b1 14		lda ($14),y			lda 	(zTemp3),y 					; set bit 15 of the max index indicating
.d411	09 80		ora #$80			ora 	#$80 						; an array of pointers
.d413	91 14		sta ($14),y			sta 	(zTemp3),y
.d415	a5 14		lda $14				lda 	zTemp3 						; push the start on the stack
.d417	48		pha				pha
.d418	a5 15		lda $15				lda 	zTemp3+1
.d41a	48		pha				pha
.d41b					_ACCFillLoop:
.d41b	18		clc				clc
.d41c	a5 14		lda $14				lda 	zTemp3 						; and work forwards.
.d41e	69 02		adc #$02			adc 	#2
.d420	85 14		sta $14				sta 	zTemp3
.d422	90 02		bcc $d426			bcc 	_ACCSkip2
.d424	e6 14		inc $14				inc 	zTemp3
.d426					_ACCSkip2:
.d426	a0 00		ldy #$00			ldy 	#0 							; reached the end ?
.d428	b1 14		lda ($14),y			lda 	(zTemp3),y					; (looking for FF marker, everything else 00)
.d42a	c8		iny				iny
.d42b	11 14		ora ($14),y			ora 	(zTemp3),y
.d42d	d0 21		bne $d450			bne 	_ACCExit
.d42f	a5 14		lda $14				lda 	zTemp3 						; push zTemp3
.d431	48		pha				pha
.d432	a5 15		lda $15				lda 	zTemp3+1
.d434	48		pha				pha
.d435	e8		inx				inx
.d436	e8		inx				inx
.d437	20 68 d3	jsr $d368			jsr 	ArrayCreate 				; create array recursively.
.d43a	ca		dex				dex
.d43b	ca		dex				dex
.d43c	85 12		sta $12				sta 	zTemp2 						; save A
.d43e	68		pla				pla
.d43f	85 15		sta $15				sta 	zTemp3+1 					; restore zTemp3
.d441	68		pla				pla
.d442	85 14		sta $14				sta 	zTemp3
.d444	98		tya				tya 								; write high bye from Y
.d445	a0 01		ldy #$01			ldy 	#1
.d447	91 14		sta ($14),y			sta 	(zTemp3),y
.d449	88		dey				dey 								; write low byte out.
.d44a	a5 12		lda $12				lda 	zTemp2
.d44c	91 14		sta ($14),y			sta 	(zTemp3),y
.d44e	80 cb		bra $d41b			bra 	_ACCFillLoop 				; and try again.
.d450					_ACCExit:
.d450	7a		ply				ply 								; restore the original address
.d451	68		pla				pla
.d452	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varfind.asm

.d453					VariableLocate:
.d453	da		phx				phx
.d454	5a		phy				phy
.d455	ad 88 04	lda $0488			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.d458	85 12		sta $12				sta 	zTemp2 						; points to first address.
.d45a	a9 04		lda #$04			lda 	#HashTableBase >> 8
.d45c	85 13		sta $13				sta 	zTemp2+1
.d45e	a0 00		ldy #$00	_VLNext:ldy 	#0 							; get next link into AX
.d460	b1 12		lda ($12),y			lda 	(zTemp2),y
.d462	aa		tax				tax
.d463	c8		iny				iny
.d464	b1 12		lda ($12),y			lda 	(zTemp2),y
.d466	85 13		sta $13				sta 	zTemp2+1 					; save in zTemp
.d468	86 12		stx $12				stx 	zTemp2
.d46a	05 12		ora $12				ora 	zTemp2 						; got zero
.d46c	18		clc				clc
.d46d	f0 25		beq $d494			beq 	_VLExit 					; if so, then fail as end of chain.
.d46f	c8		iny				iny 								; point to hash (offset + 2)
.d470	b1 12		lda ($12),y			lda 	(zTemp2),y
.d472	cd 86 04	cmp $0486			cmp 	Var_Hash
.d475	d0 e7		bne $d45e			bne 	_VLNext 					; try next if different.
.d477					_VLCompare:
.d477	c8		iny				iny 								; next character
.d478	b1 12		lda ($12),y			lda 	(zTemp2),y 					; compare variable field against buffer.
.d47a	d9 02 04	cmp $0402,y			cmp 	Var_Buffer-3,y 				; the -3 is because name starts at 3.
.d47d	d0 df		bne $d45e			bne 	_VLNext 					; fail if different, try next.
.d47f	0a		asl a				asl 	a 							; until end character (bit 7 set) matched
.d480	90 f5		bcc $d477			bcc 	_VLCompare
.d482	98		tya				tya
.d483	38		sec				sec 								; add 1 as Y points to last character
.d484	65 12		adc $12				adc 	zTemp2 						; add to the current address
.d486	85 22		sta $22				sta 	zVarDataPtr
.d488	a5 13		lda $13				lda 	zTemp2+1
.d48a	69 00		adc #$00			adc 	#0
.d48c	85 23		sta $23				sta 	zVarDataPtr+1
.d48e	ad 85 04	lda $0485			lda 	Var_Type 					; and set the type.
.d491	85 24		sta $24				sta 	zVarType
.d493	38		sec				sec 								; return CS
.d494	7a		ply		_VLExit:ply
.d495	fa		plx				plx
.d496	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/vargetset.asm

.d497					VariableGet:
.d497	5a		phy				phy
.d498	a0 00		ldy #$00			ldy 	#0 							; copy first two bytes
.d49a	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.d49c	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.d49f	c8		iny				iny
.d4a0	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.d4a2	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.d4a5	c8		iny				iny
.d4a6	a5 24		lda $24				lda 	zVarType 					; if it is a string, set up for that.
.d4a8	c9 b7		cmp #$b7			cmp 	#token_Dollar
.d4aa	f0 34		beq $d4e0			beq 	_VGString
.d4ac	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; copy the next two bytes.
.d4ae	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.d4b1	c8		iny				iny
.d4b2	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.d4b4	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.d4b7	c8		iny				iny
.d4b8	a9 01		lda #$01			lda 	#1 							; set type to 1.
.d4ba	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.d4bd	a5 24		lda $24				lda 	zVarType
.d4bf	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if it is a %, then exit with default integer.
.d4c1	f0 31		beq $d4f4			beq 	_VGExit
.d4c3	a9 40		lda #$40			lda 	#$40 						; set type byte to zero
.d4c5	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; which is the code for zero/float.
.d4c8	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; the last value to copy is the exponent.
.d4ca	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.d4cd	f0 25		beq $d4f4			beq 	_VGExit 					; if exponent is zero ... it's zero.
.d4cf	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; the sign bit is the top mantissa bit.
.d4d2	48		pha				pha
.d4d3	29 80		and #$80			and 	#$80
.d4d5	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; this is the type byte.
.d4d8	68		pla				pla
.d4d9	09 80		ora #$80			ora 	#$80 						; set the MSB as you would expect.
.d4db	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x 			; so it's a normalised float.
.d4de	80 14		bra $d4f4			bra 	_VGExit
.d4e0					_VGString:
.d4e0	a9 02		lda #$02			lda 	#2 							; set type to 2, a string
.d4e2	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.d4e5	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; is the value there $0000
.d4e8	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.d4eb	d0 07		bne $d4f4			bne 	_VGExit 					; if not, exit.
.d4ed	85 25		sta $25				sta 	zNullString 				; make zNullString a 00 string.
.d4ef	a9 25		lda #$25			lda 	#zNullString
.d4f1	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; make it point to it.
.d4f4					_VGExit:
.d4f4	7a		ply				ply
.d4f5	60		rts				rts
.d4f6					VariableSet:
.d4f6	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; is the result a string
.d4f9	29 02		and #$02			and 	#2 							; if so, it has to be
.d4fb	d0 53		bne $d550			bne 	_VSString
.d4fd	a5 24		lda $24				lda 	zVarType 					; if type is $ there's an error.
.d4ff	c9 b7		cmp #$b7			cmp 	#token_Dollar
.d501	f0 4a		beq $d54d			beq 	_VSBadType
.d503	c9 bb		cmp #$bb			cmp 	#token_Percent 				; type convert to float/int
.d505	f0 05		beq $d50c			beq 	_VSMakeInt
.d507	20 fe da	jsr $dafe			jsr 	FPUToFloat
.d50a	80 03		bra $d50f			bra 	_VSCopy
.d50c					_VSMakeInt:
.d50c	20 5d db	jsr $db5d			jsr 	FPUToInteger
.d50f					_VSCopy:
.d50f	5a		phy				phy
.d510	a0 00		ldy #$00			ldy 	#0 							; copy mantissa to target.
.d512	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.d515	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.d517	c8		iny				iny
.d518	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.d51b	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.d51d	c8		iny				iny
.d51e	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.d521	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.d523	c8		iny				iny
.d524	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.d527	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.d529	a5 24		lda $24				lda 	zVarType 					; if target is integer, alrady done.
.d52b	c9 bb		cmp #$bb			cmp 	#token_Percent
.d52d	f0 1c		beq $d54b			beq 	_VSExit
.d52f	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get the sign bit into carry flag.
.d532	0a		asl a				asl 	a
.d533	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; shift the sign into the mantissa high.
.d536	08		php				php
.d537	0a		asl a				asl 	a
.d538	28		plp				plp
.d539	6a		ror a				ror 	a
.d53a	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.d53c	c8		iny				iny
.d53d	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; copy the exponent in
.d540	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.d542	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if the result is non zero
.d545	50 04		bvc $d54b			bvc 	_VSExit
.d547	a9 00		lda #$00			lda 	#00 						; zero exponent indicating 0.
.d549	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.d54b					_VSExit:
.d54b	7a		ply				ply
.d54c	60		rts				rts
.d54d					_VSBadType:
.d54d	4c d4 c3	jmp $c3d4			jmp 	TypeError
.d550					_VSString:
.d550	a5 24		lda $24				lda 	zVarType 					; type must be $
.d552	c9 b7		cmp #$b7			cmp 	#token_Dollar
.d554	d0 f7		bne $d54d			bne 	_VSBadType
.d556	da		phx				phx
.d557	5a		phy				phy
.d558	20 b3 d0	jsr $d0b3			jsr 	StringConcrete 				; concrete the string in the mantissa -> AX
.d55b	a0 01		ldy #$01			ldy 	#1 							; save high byte
.d55d	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.d55f	88		dey				dey 								; save low byte
.d560	8a		txa				txa
.d561	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.d563	7a		ply				ply 								; and exit.
.d564	fa		plx				plx
.d565	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.d566					MulInteger32:
.d566	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.d569	9d 14 03	sta $0314,x			sta 	XS3_Mantissa,x
.d56c	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.d56f	9d 15 03	sta $0315,x			sta 	XS3_Mantissa+1,x
.d572	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.d575	9d 16 03	sta $0316,x			sta 	XS3_Mantissa+2,x
.d578	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.d57b	9d 17 03	sta $0317,x			sta 	XS3_Mantissa+3,x
.d57e	a9 00		lda #$00			lda 	#0
.d580	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x 				; zero +0
.d583	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.d586	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.d589	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.d58c					_BFMMultiply:
.d58c	bd 14 03	lda $0314,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.d58f	29 01		and #$01			and 	#1
.d591	f0 03		beq $d596			beq 	_BFMNoAdd
.d593	20 09 cc	jsr $cc09			jsr 	AddInteger32
.d596					_BFMNoAdd:
.d596	1e 0e 03	asl $030e,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.d599	3e 0f 03	rol $030f,x			rol 	XS2_Mantissa+1,x
.d59c	3e 10 03	rol $0310,x			rol 	XS2_Mantissa+2,x
.d59f	3e 11 03	rol $0311,x			rol 	XS2_Mantissa+3,x
.d5a2	5e 17 03	lsr $0317,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.d5a5	7e 16 03	ror $0316,x			ror 	XS3_Mantissa+2,x
.d5a8	7e 15 03	ror $0315,x			ror 	XS3_Mantissa+1,x
.d5ab	7e 14 03	ror $0314,x			ror 	XS3_Mantissa,x
.d5ae	bd 14 03	lda $0314,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.d5b1	1d 15 03	ora $0315,x			ora 	XS3_Mantissa+1,x
.d5b4	1d 16 03	ora $0316,x			ora 	XS3_Mantissa+2,x
.d5b7	1d 17 03	ora $0317,x			ora 	XS3_Mantissa+3,x
.d5ba	d0 d0		bne $d58c			bne 	_BFMMultiply
.d5bc	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.d5bd					DivInteger32:
.d5bd	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; check for /0
.d5c0	1d 0f 03	ora $030f,x			ora 	XS2_Mantissa+1,x
.d5c3	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.d5c6	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.d5c9	d0 14		bne $d5df			bne 	_BFDOkay
.d5cb	20 f3 c3	jsr $c3f3			jsr ERR_Handler
>d5ce	44 69 76 69 73 69 6f 6e			.text "Division by Zero",0
>d5d6	20 62 79 20 5a 65 72 6f 00
.d5df					_BFDOkay:
.d5df	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.d5e1	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.d5e3	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.d5e5	85 1c		sta $1c				sta 	zLTemp1+2
.d5e7	85 1d		sta $1d				sta 	zLTemp1+3
.d5e9	8d 8e 04	sta $048e			sta 	SignCount 					; Count of signs.
.d5ec	20 4d d6	jsr $d64d			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.d5ef	da		phx				phx
.d5f0	e8		inx				inx
.d5f1	e8		inx				inx
.d5f2	e8		inx				inx
.d5f3	e8		inx				inx
.d5f4	e8		inx				inx
.d5f5	e8		inx				inx
.d5f6	20 4d d6	jsr $d64d			jsr 	CheckIntegerNegate
.d5f9	fa		plx				plx
.d5fa	5a		phy				phy 								; Y is the counter
.d5fb	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.d5fd					_BFDLoop:
.d5fd	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.d600	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.d603	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.d606	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.d609	26 1a		rol $1a				rol 	zLTemp1
.d60b	26 1b		rol $1b				rol 	zLTemp1+1
.d60d	26 1c		rol $1c				rol 	zLTemp1+2
.d60f	26 1d		rol $1d				rol 	zLTemp1+3
.d611	38		sec				sec
.d612	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.d614	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.d617	48		pha				pha
.d618	a5 1b		lda $1b				lda 	zLTemp1+1
.d61a	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.d61d	48		pha				pha
.d61e	a5 1c		lda $1c				lda 	zLTemp1+2
.d620	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.d623	48		pha				pha
.d624	a5 1d		lda $1d				lda 	zLTemp1+3
.d626	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.d629	90 15		bcc $d640			bcc 	_BFDNoAdd
.d62b	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.d62d	68		pla				pla
.d62e	85 1c		sta $1c				sta 	zLTemp1+2
.d630	68		pla				pla
.d631	85 1b		sta $1b				sta 	zLTemp1+1
.d633	68		pla				pla
.d634	85 1a		sta $1a				sta 	zLTemp1+0
.d636	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.d639	09 01		ora #$01			ora 	#1
.d63b	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.d63e	80 03		bra $d643			bra 	_BFDNext
.d640					_BFDNoAdd:
.d640	68		pla				pla 								; Throw away the intermediate calculations
.d641	68		pla				pla
.d642	68		pla				pla
.d643					_BFDNext:
.d643	88		dey				dey
.d644	d0 b7		bne $d5fd			bne 	_BFDLoop
.d646	7a		ply				ply 								; restore Y and exit
.d647	4e 8e 04	lsr $048e			lsr 	SignCount 					; if sign count odd,
.d64a	b0 07		bcs $d653			bcs		IntegerNegateAlways 			; negate the result
.d64c	60		rts				rts
.d64d					CheckIntegerNegate:
.d64d	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.d650	30 01		bmi $d653			bmi 	IntegerNegateAlways
.d652	60		rts				rts
.d653					IntegerNegateAlways:
.d653	ee 8e 04	inc $048e			inc 	SignCount
.d656	38		sec				sec
.d657	a9 00		lda #$00			lda 	#0
.d659	fd 08 03	sbc $0308,x			sbc 	XS_Mantissa+0,x
.d65c	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.d65f	a9 00		lda #$00			lda 	#0
.d661	fd 09 03	sbc $0309,x			sbc 	XS_Mantissa+1,x
.d664	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.d667	a9 00		lda #$00			lda 	#0
.d669	fd 0a 03	sbc $030a,x			sbc 	XS_Mantissa+2,x
.d66c	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.d66f	a9 00		lda #$00			lda 	#0
.d671	fd 0b 03	sbc $030b,x			sbc 	XS_Mantissa+3,x
.d674	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.d677	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.d678					INTToString:
.d678	48		pha				pha
.d679	5a		phy				phy
.d67a	bd 0b 03	lda $030b,x			lda 		XS_Mantissa+3,x 		; check -ve
.d67d	10 08		bpl $d687			bpl 		_ITSNotMinus
.d67f	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.d681	20 18 d7	jsr $d718			jsr 		ITSOutputCharacter
.d684	20 53 d6	jsr $d653			jsr 		IntegerNegateAlways 	; negate the number.
.d687					_ITSNotMinus:
.d687	a9 00		lda #$00			lda 		#0
.d689	8d 8a 04	sta $048a			sta 		NumSuppress 			; clear the suppression flag.
.d68c	8a		txa				txa 								; use Y for the mantissa index.
.d68d	a8		tay				tay
.d68e	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.d690					_ITSNextSubtractor:
.d690	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.d692	8d 8b 04	sta $048b			sta 		NumConvCount
.d695					_ITSSubtract:
.d695	38		sec				sec
.d696	b9 08 03	lda $0308,y			lda 		XS_Mantissa,y 			; subtract number and push on stack
.d699	fd f4 d6	sbc $d6f4,x			sbc 		_ITSSubtractors+0,x
.d69c	48		pha				pha
.d69d	b9 09 03	lda $0309,y			lda 		XS_Mantissa+1,y
.d6a0	fd f5 d6	sbc $d6f5,x			sbc 		_ITSSubtractors+1,x
.d6a3	48		pha				pha
.d6a4	b9 0a 03	lda $030a,y			lda 		XS_Mantissa+2,y
.d6a7	fd f6 d6	sbc $d6f6,x			sbc 		_ITSSubtractors+2,x
.d6aa	48		pha				pha
.d6ab	b9 0b 03	lda $030b,y			lda 		XS_Mantissa+3,y
.d6ae	fd f7 d6	sbc $d6f7,x			sbc 		_ITSSubtractors+3,x
.d6b1	90 14		bcc $d6c7			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.d6b3	99 0b 03	sta $030b,y			sta 		XS_Mantissa+3,y 		; save subtract off stack
.d6b6	68		pla				pla
.d6b7	99 0a 03	sta $030a,y			sta 		XS_Mantissa+2,y
.d6ba	68		pla				pla
.d6bb	99 09 03	sta $0309,y			sta 		XS_Mantissa+1,y
.d6be	68		pla				pla
.d6bf	99 08 03	sta $0308,y			sta 		XS_Mantissa+0,y
.d6c2	ee 8b 04	inc $048b			inc 		NumConvCount 			; bump count.
.d6c5	80 ce		bra $d695			bra 		_ITSSubtract 			; go round again.
.d6c7					_ITSCantSubtract:
.d6c7	68		pla				pla 								; throw away interim answers
.d6c8	68		pla				pla
.d6c9	68		pla				pla
.d6ca	ad 8b 04	lda $048b			lda 		NumConvCount 			; if not zero then no suppression check
.d6cd	c9 30		cmp #$30			cmp 		#"0"
.d6cf	d0 05		bne $d6d6			bne 		_ITSOutputDigit
.d6d1	ad 8a 04	lda $048a			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.d6d4	10 09		bpl $d6df			bpl	 		_ITSGoNextSubtractor
.d6d6					_ITSOutputDigit:
.d6d6	ce 8a 04	dec $048a			dec 		NumSuppress 			; suppression check will be non-zero.
.d6d9	ad 8b 04	lda $048b			lda 		NumConvCount 			; count of subtractions
.d6dc	20 18 d7	jsr $d718			jsr 		ITSOutputCharacter 		; output it.
.d6df					_ITSGoNextSubtractor:
.d6df	e8		inx				inx 								; next dword
.d6e0	e8		inx				inx
.d6e1	e8		inx				inx
.d6e2	e8		inx				inx
.d6e3	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.d6e5	d0 a9		bne $d690			bne 		_ITSNextSubtractor 		; do all the subtractors.
.d6e7	98		tya				tya 								; X is back as the mantissa index
.d6e8	aa		tax				tax
.d6e9	bd 08 03	lda $0308,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.d6ec	09 30		ora #$30			ora 		#"0"
.d6ee	20 18 d7	jsr $d718			jsr 		ITSOutputCharacter
.d6f1	7a		ply				ply 								; and exit
.d6f2	68		pla				pla
.d6f3	60		rts				rts
.d6f4					_ITSSubtractors:
>d6f4	00 ca 9a 3b					.dword 		1000000000
>d6f8	00 e1 f5 05					.dword 		100000000
>d6fc	80 96 98 00					.dword 		10000000
>d700	40 42 0f 00					.dword 		1000000
>d704	a0 86 01 00					.dword 		100000
>d708	10 27 00 00					.dword 		10000
>d70c	e8 03 00 00					.dword 		1000
>d710	64 00 00 00					.dword 		100
>d714	0a 00 00 00					.dword 		10
.d718					_ITSSubtractorsEnd:
.d718					ITSOutputCharacter:
.d718	48		pha				pha
.d719	da		phx				phx
.d71a	ae 04 04	ldx $0404			ldx 	NumBufX 					; save digit
.d71d	9d 05 04	sta $0405,x			sta 	Num_Buffer,x
.d720	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.d722	9d 06 04	sta $0406,x			sta 	Num_Buffer+1,x
.d725	ee 04 04	inc $0404			inc 	NumBufX						; bump pointer.
.d728	fa		plx				plx
.d729	68		pla				pla
.d72a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.d72b					IntFromString:
.d72b	a0 00		ldy #$00			ldy 	#0
.d72d	8c 8c 04	sty $048c			sty 	ExpTemp 					; this is the converted digit count.
.d730					IntFromStringY:
.d730	48		pha				pha
.d731	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.d733	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.d736	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.d739	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.d73c	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.d73f	a9 01		lda #$01			lda 	#1
.d741	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.d744					_IFSLoop:
.d744	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.d746	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.d748	90 60		bcc $d7aa			bcc 	_IFSExit
.d74a	c9 3a		cmp #$3a			cmp 	#"9"+1
.d74c	b0 5c		bcs $d7aa			bcs 	_IFSExit
.d74e	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.d751	c9 0c		cmp #$0c			cmp 	#12
.d753	b0 5f		bcs $d7b4			bcs 	_IFSOverflow
.d755	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.d758	48		pha				pha
.d759	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.d75c	48		pha				pha
.d75d	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.d760	48		pha				pha
.d761	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.d764	48		pha				pha
.d765	20 c9 d7	jsr $d7c9			jsr 	IFSX1ShiftLeft 				; double
.d768	20 c9 d7	jsr $d7c9			jsr 	IFSX1ShiftLeft 				; x 4
.d76b	18		clc				clc 								; add saved value x 5
.d76c	68		pla				pla
.d76d	7d 08 03	adc $0308,x			adc 	XS_Mantissa+0,x
.d770	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.d773	68		pla				pla
.d774	7d 09 03	adc $0309,x			adc 	XS_Mantissa+1,x
.d777	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.d77a	68		pla				pla
.d77b	7d 0a 03	adc $030a,x			adc 	XS_Mantissa+2,x
.d77e	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.d781	68		pla				pla
.d782	7d 0b 03	adc $030b,x			adc 	XS_Mantissa+3,x
.d785	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.d788	20 c9 d7	jsr $d7c9			jsr 	IFSX1ShiftLeft 				; x 10
.d78b	ee 8c 04	inc $048c			inc 	ExpTemp 					; bump count of digits processed.
.d78e	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.d790	29 0f		and #$0f			and 	#15
.d792	c8		iny				iny
.d793	7d 08 03	adc $0308,x			adc 	XS_Mantissa+0,x
.d796	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.d799	90 a9		bcc $d744			bcc 	_IFSLoop
.d79b	fe 09 03	inc $0309,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.d79e	d0 a4		bne $d744			bne 	_IFSLoop
.d7a0	fe 0a 03	inc $030a,x			inc 	XS_Mantissa+2,x
.d7a3	d0 9f		bne $d744			bne 	_IFSLoop
.d7a5	fe 0b 03	inc $030b,x			inc 	XS_Mantissa+3,x
.d7a8	80 9a		bra $d744			bra 	_IFSLoop
.d7aa					_IFSExit:
.d7aa	98		tya				tya 								; get offset
.d7ab					_IFSOkay:
.d7ab	38		sec				sec
.d7ac	ad 8c 04	lda $048c			lda 	ExpTemp
.d7af	f0 01		beq $d7b2			beq 	_IFSSkipFail
.d7b1	18		clc				clc
.d7b2					_IFSSkipFail:
.d7b2	68		pla				pla 								; and exit.
.d7b3	60		rts				rts
.d7b4					_IFSOverflow:
.d7b4	20 f3 c3	jsr $c3f3			jsr 	ERR_Handler
>d7b7	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>d7bf	20 6f 76 65 72 66 6c 6f 77 00
.d7c9					IFSX1ShiftLeft:
.d7c9	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x
.d7cc	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.d7cf	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.d7d2	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.d7d5	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.d7d6					FPSubtract:
.d7d6	48		pha				pha
.d7d7	bd 13 03	lda $0313,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.d7da	49 80		eor #$80			eor 	#$80
.d7dc	9d 13 03	sta $0313,x			sta 	XS2_Type,x
.d7df	68		pla				pla 								; --- and fall through ---
.d7e0					FPAdd:
.d7e0	48		pha				pha
.d7e1	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.d7e4	d0 05		bne $d7eb			bne 	_FPA_NegativeLHS
.d7e6	20 08 d8	jsr $d808			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.d7e9	68		pla				pla
.d7ea	60		rts				rts
.d7eb					_FPA_NegativeLHS:
.d7eb	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.d7ee	49 80		eor #$80			eor 	#$80
.d7f0	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.d7f3	bd 13 03	lda $0313,x			lda 	XS2_Type,x 					; flip the sign of B and add
.d7f6	49 80		eor #$80			eor 	#$80
.d7f8	9d 13 03	sta $0313,x			sta 	XS2_Type,x
.d7fb	20 08 d8	jsr $d808			jsr 	FPAdd_Worker 				; do the add calculation.
.d7fe	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip sign of X1 back
.d801	49 80		eor #$80			eor 	#$80
.d803	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.d806	68		pla				pla
.d807	60		rts				rts
.d808					FPAdd_Worker:
.d808	3c 13 03	bit $0313,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.d80b	70 08		bvs $d815			bvs 	_FPAWExit 					; no change.
.d80d	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.d810	50 07		bvc $d819			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.d812	20 ad da	jsr $daad			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.d815					_FPAWExit:
.d815	20 35 db	jsr $db35			jsr 	FPUNormalise 				; normalise the result.
.d818	60		rts				rts
.d819					_FPAWMakeSame:
.d819	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.d81c	38		sec				sec
.d81d	fd 12 03	sbc $0312,x			sbc	 	XS2_Exponent,x 				; using subtraction
.d820	f0 1b		beq $d83d			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.d822	da		phx				phx 								; save X
.d823	90 06		bcc $d82b			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.d825	e8		inx				inx
.d826	e8		inx				inx
.d827	e8		inx				inx
.d828	e8		inx				inx
.d829	e8		inx				inx
.d82a	e8		inx				inx
.d82b					_FPAWShiftA:
.d82b	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x 				; so shift exponent up.
.d82e	5e 0b 03	lsr $030b,x			lsr 	3+XS_Mantissa,x
.d831	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.d834	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.d837	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.d83a	fa		plx				plx 								; restore original X
.d83b	80 dc		bra $d819			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.d83d					_FPAW_DoArithmetic:
.d83d	3c 13 03	bit $0313,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.d840	30 39		bmi $d87b			bmi 	_FPAW_BNegative
.d842	18		clc				clc
.d843	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.d846	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.d849	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.d84c	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.d84f	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.d852	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.d855	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.d858	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.d85b	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.d85e	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.d861	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.d864	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.d867	90 ac		bcc $d815			bcc 	_FPAWExit 					; no carry.
.d869	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x 				; so shift exponent up.
.d86c	38		sec				sec
.d86d	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.d870	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.d873	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.d876	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.d879	80 9a		bra $d815			bra 	_FPAWExit
.d87b					_FPAW_BNegative:
.d87b	38		sec				sec
.d87c	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.d87f	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.d882	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.d885	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.d888	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.d88b	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.d88e	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.d891	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.d894	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.d897	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.d89a	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.d89d	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.d8a0	b0 0b		bcs $d8ad			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.d8a2	20 da da	jsr $dada			jsr 	FPUNegateInteger			; negate the mantissa
.d8a5	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip result sign
.d8a8	49 80		eor #$80			eor 	#$80
.d8aa	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.d8ad					_FPAWGoExit:
.d8ad	4c 15 d8	jmp $d815			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.d8b0					FPD_IsDivZero:
.d8b0	20 f3 c3	jsr $c3f3			jsr ERR_Handler
>d8b3	44 69 76 69 73 69 6f 6e			.text "Division by zero",0
>d8bb	20 62 79 20 7a 65 72 6f 00
.d8c4					FPDivide:
.d8c4	48		pha				pha
.d8c5	5a		phy				phy
.d8c6	3c 13 03	bit $0313,x			bit 	XS2_Type,x 					; check if division by zero
.d8c9	70 e5		bvs $d8b0			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.d8cb	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.d8ce	f0 03		beq $d8d3			beq 	_FPDCalculateExp
.d8d0					_FPD_Exit:
.d8d0	7a		ply				ply
.d8d1	68		pla				pla
.d8d2	60		rts				rts
.d8d3					_FPDCalculateExp:
.d8d3	bd 12 03	lda $0312,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.d8d6	49 ff		eor #$ff			eor 	#$FF
.d8d8	1a		inc a				inc 	a
.d8d9	9d 12 03	sta $0312,x			sta 	XS2_Exponent,x
.d8dc	20 d0 d9	jsr $d9d0			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.d8df	18		clc				clc 	 							; add 1 to the resulting exponent
.d8e0	69 01		adc #$01			adc 	#1
.d8e2	b0 65		bcs $d949			bcs 	_FPD_Overflow 				; which can overflow.
.d8e4	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.d8e7	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.d8e9	85 1a		sta $1a				sta 	zLTemp1+0
.d8eb	85 1b		sta $1b				sta 	zLTemp1+1
.d8ed	85 1c		sta $1c				sta 	zLTemp1+2
.d8ef	85 1d		sta $1d				sta 	zLTemp1+3
.d8f1	a0 20		ldy #$20			ldy 	#32 						; times round.
.d8f3					_FPD_Loop:
.d8f3	38		sec				sec 								; calculate X1-X2 stacking result because we might
.d8f4	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; not save it.
.d8f7	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa,x
.d8fa	48		pha				pha
.d8fb	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.d8fe	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.d901	48		pha				pha
.d902	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.d905	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.d908	48		pha				pha
.d909	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.d90c	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.d90f	90 17		bcc $d928			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.d911	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x 			; save results out to A
.d914	68		pla				pla
.d915	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.d918	68		pla				pla
.d919	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.d91c	68		pla				pla
.d91d	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.d920	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.d922	09 80		ora #$80			ora 	#$80
.d924	85 1d		sta $1d				sta 	zLTemp1+3
.d926	80 03		bra $d92b			bra 	_FPD_Rotates
.d928					_FPD_NoSubtract:
.d928	68		pla				pla 								; throw away unwanted results
.d929	68		pla				pla
.d92a	68		pla				pla
.d92b					_FPD_Rotates:
.d92b	5e 11 03	lsr $0311,x			lsr 	3+XS2_Mantissa,x
.d92e	7e 10 03	ror $0310,x			ror 	2+XS2_Mantissa,x
.d931	7e 0f 03	ror $030f,x			ror 	1+XS2_Mantissa,x
.d934	7e 0e 03	ror $030e,x			ror 	0+XS2_Mantissa,x
.d937	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.d939	26 1b		rol $1b				rol 	zLTemp1+1
.d93b	26 1c		rol $1c				rol 	zLTemp1+2
.d93d	26 1d		rol $1d				rol 	zLTemp1+3
.d93f	90 02		bcc $d943			bcc 	_FPD_NoCarry
.d941	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.d943					_FPD_NoCarry:
.d943	88		dey				dey 								; do 32 times
.d944	d0 ad		bne $d8f3			bne 	_FPD_Loop
.d946	4c ad d9	jmp $d9ad			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.d949					_FPD_Overflow:
.d949	4c aa db	jmp $dbaa			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.d94c					FPMultiply:
.d94c	48		pha				pha
.d94d	5a		phy				phy
.d94e	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.d951	70 08		bvs $d95b			bvs 	_FPM_Exit
.d953	3c 13 03	bit $0313,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.d956	50 06		bvc $d95e			bvc 	_FPM_CalcExponent
.d958	20 ad da	jsr $daad			jsr 	FPUCopyX2ToX1
.d95b					_FPM_Exit:
.d95b	7a		ply				ply
.d95c	68		pla				pla
.d95d	60		rts				rts
.d95e					_FPM_CalcExponent:
.d95e	18		clc				clc
.d95f	20 d0 d9	jsr $d9d0			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.d962	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x 				; save the result.
.d965	a9 00		lda #$00			lda 	#0
.d967	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.d969	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.d96b	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.d96d	85 1d		sta $1d				sta 	zLTemp1+3
.d96f	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.d971					_FPM_Loop:
.d971	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x				; check LSB of long product
.d974	29 01		and #$01			and 	#1
.d976	18		clc				clc 								; clear carry for the long rotate.
.d977	f0 1d		beq $d996			beq 	_FPM_NoAddition
.d979	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.d97a	a5 1a		lda $1a				lda 	zLTemp1+0
.d97c	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.d97f	85 1a		sta $1a				sta 	zLTemp1+0
.d981	a5 1b		lda $1b				lda 	zLTemp1+1
.d983	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.d986	85 1b		sta $1b				sta 	zLTemp1+1
.d988	a5 1c		lda $1c				lda 	zLTemp1+2
.d98a	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.d98d	85 1c		sta $1c				sta 	zLTemp1+2
.d98f	a5 1d		lda $1d				lda 	zLTemp1+3
.d991	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.d994	85 1d		sta $1d				sta 	zLTemp1+3
.d996					_FPM_NoAddition:
.d996	66 1d		ror $1d				ror 	3+zLTemp1
.d998	66 1c		ror $1c				ror 	2+zLTemp1
.d99a	66 1b		ror $1b				ror 	1+zLTemp1
.d99c	66 1a		ror $1a				ror 	0+zLTemp1
.d99e	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.d9a1	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.d9a4	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.d9a7	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.d9aa	88		dey				dey
.d9ab	d0 c4		bne $d971			bne 	_FPM_Loop 					; do this 32 times.
.d9ad					FPM_CopySignNormalize:
.d9ad	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.d9af	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.d9b2	a5 1b		lda $1b				lda 	zLTemp1+1
.d9b4	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.d9b7	a5 1c		lda $1c				lda 	zLTemp1+2
.d9b9	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.d9bc	a5 1d		lda $1d				lda 	zLTemp1+3
.d9be	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.d9c1	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; sign is xor of signs
.d9c4	5d 13 03	eor $0313,x			eor 	XS2_Type,x
.d9c7	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.d9ca	20 35 db	jsr $db35			jsr 	FPUNormalise 				; normalise and exit.
.d9cd	7a		ply				ply
.d9ce	68		pla				pla
.d9cf	60		rts				rts
.d9d0					FPCalculateExponent:
.d9d0	18		clc				clc
.d9d1	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.d9d4	7d 12 03	adc $0312,x			adc 	XS2_Exponent,x
.d9d7	b0 08		bcs $d9e1			bcs 	_FPCECarry 					; carry out ?
.d9d9	10 03		bpl $d9de			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.d9db	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.d9dd	60		rts				rts
.d9de					_FPCEExpZero:
.d9de	a9 00		lda #$00			lda 	#0
.d9e0	60		rts				rts
.d9e1					_FPCECarry:
.d9e1	30 03		bmi $d9e6			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.d9e3	09 80		ora #$80			ora 	#$80 						; put in right range
.d9e5	60		rts				rts
.d9e6					_FPCEOverflow:
.d9e6	4c aa db	jmp $dbaa			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.d9e9					FPFractionalPart:
.d9e9	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.d9ec	38		sec				sec 								; this flag tells us to keep the fractional part
.d9ed	30 0f		bmi $d9fe			bmi 	FPGetPart
.d9ef	60		rts				rts
.d9f0					FPIntegerPart:
.d9f0	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.d9f3	18		clc				clc 								; this flag says keep the integer part.
.d9f4	30 08		bmi $d9fe			bmi 	FPGetPart 					; -ve exponents are 0..127
.d9f6	48		pha				pha
.d9f7	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.d9f9	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.d9fc	68		pla				pla
.d9fd	60		rts				rts
.d9fe					FPGetPart:
.d9fe	48		pha				pha
.d9ff	5a		phy				phy 								; save Y
.da00	08		php				php 								; save action
.da01	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.da04	70 62		bvs $da68			bvs 	_FPGP_Exit 					; then do nothing.
.da06	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.da08	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.da0a	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.da0c	85 1c		sta $1c				sta 	zLTemp1+2
.da0e	85 1d		sta $1d				sta 	zLTemp1+3
.da10	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x				; the number of shifts.
.da13	38		sec				sec
.da14	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.da16	f0 12		beq $da2a			beq 	_FPGP_NoShift 				; ... if any
.da18	c9 20		cmp #$20			cmp 	#32
.da1a	90 02		bcc $da1e			bcc 	_FPGP_NotMax
.da1c	a9 20		lda #$20			lda 	#32 						; max of 32.
.da1e					_FPGP_NotMax:
.da1e	a8		tay				tay 								; Y is the mask shift count.
.da1f					_FPGP_ShiftMask:
.da1f	46 1d		lsr $1d				lsr 	3+zLTemp1
.da21	66 1c		ror $1c				ror 	2+zLTemp1
.da23	66 1b		ror $1b				ror 	1+zLTemp1
.da25	66 1a		ror $1a				ror 	0+zLTemp1
.da27	88		dey				dey
.da28	d0 f5		bne $da1f			bne 	_FPGP_ShiftMask
.da2a					_FPGP_NoShift:
.da2a	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.da2c	8e 8c 04	stx $048c			stx 	ExpTemp						; save X
.da2f					_FPGP_MaskLoop:
.da2f	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.da32	28		plp				plp 								; if CC we keep the top part, so we
.da33	08		php				php		 							; flip the mask.
.da34	b0 02		bcs $da38			bcs		_FPGP_NoFlip
.da36	49 ff		eor #$ff			eor 	#$FF
.da38					_FPGP_NoFlip:
.da38	3d 08 03	and $0308,x			and 	XS_Mantissa,x 				; and into the mantissa.
.da3b	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.da3e	e8		inx				inx
.da3f	c8		iny				iny
.da40	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.da42	d0 eb		bne $da2f			bne 	_FPGP_MaskLoop
.da44	ae 8c 04	ldx $048c			ldx 	ExpTemp						; restore X
.da47	28		plp				plp
.da48	08		php				php 								; get action flag on the stack
.da49	90 05		bcc $da50			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.da4b	a9 00		lda #$00			lda 	#0
.da4d	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.da50					_FPGP_NotFractional:
.da50	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 						; check if \1 zero
.da53	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.da56	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.da59	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.da5c	f0 05		beq $da63			beq 	_FPGP_Zero 					; if zero, return zero
.da5e	20 35 db	jsr $db35			jsr 	FPUNormalise
.da61	80 05		bra $da68			bra 	_FPGP_Exit 					; and exit
.da63					_FPGP_Zero:
.da63	a9 40		lda #$40			lda 	#$40 						; set zero flag
.da65	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.da68					_FPGP_Exit:
.da68	68		pla				pla 								; throw saved action flag.
.da69	7a		ply				ply
.da6a	68		pla				pla
.da6b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.da6c					FPCompare:
.da6c	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.da6f	48		pha				pha
.da70	bd 12 03	lda $0312,x			lda 	XS2_Exponent,x
.da73	48		pha				pha
.da74	20 d6 d7	jsr $d7d6			jsr 	FPSubtract 					; calculate X1-X2
.da77	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.da7a	70 2c		bvs $daa8			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.da7c	68		pla				pla
.da7d	8d 8c 04	sta $048c			sta 	ExpTemp						; save first exponent in temporary reg.
.da80	68		pla				pla
.da81	38		sec				sec
.da82	ed 8c 04	sbc $048c			sbc 	ExpTemp 					; calculate AX-BX
.da85	70 15		bvs $da9c			bvs 	_FPCNotEqual				; overflow, can't be equal.
.da87	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.da88	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.da8a	b0 10		bcs $da9c			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.da8c	38		sec				sec
.da8d	ad 8c 04	lda $048c			lda 	ExpTemp 					; get one of the exponents back.
.da90	e9 12		sbc #$12			sbc 	#18 						; allow for 2^18 error, relatively.
.da92	b0 02		bcs $da96			bcs 	_FPCNotRange 				; keep in range.
.da94	a9 01		lda #$01			lda 	#1
.da96					_FPCNotRange:
.da96	38		sec				sec
.da97	fd 0c 03	sbc $030c,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.da9a	b0 0e		bcs $daaa			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.da9c					_FPCNotEqual:
.da9c	bd 0d 03	lda $030d,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.da9f	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.daa1	f0 02		beq $daa5			beq 	_FPCNE2
.daa3	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.daa5	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.daa6	80 04		bra $daac			bra 	_FPCExit
.daa8					_FPCPullZero:
.daa8	68		pla				pla 								; throw saved exponents
.daa9	68		pla				pla
.daaa					_FPCZero:
.daaa	a9 00		lda #$00			lda 	#0 							; and return zero
.daac					_FPCExit:
.daac	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.daad					FPUCopyX2ToX1:
.daad	48		pha				pha
.daae	da		phx				phx
.daaf	5a		phy				phy
.dab0	a0 08		ldy #$08			ldy 	#8
.dab2	bd 0e 03	lda $030e,x	_FPUC21:lda 	XS2_Mantissa,x
.dab5	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.dab8	e8		inx				inx
.dab9	88		dey				dey
.daba	10 f6		bpl $dab2			bpl 	_FPUC21
.dabc	7a		ply				ply
.dabd	fa		plx				plx
.dabe	68		pla				pla
.dabf	60		rts				rts
.dac0					FPUSetInteger:
.dac0	48		pha				pha
.dac1	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.dac4	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.dac6	10 02		bpl $daca			bpl 	_FPUSIExtend
.dac8	a9 ff		lda #$ff			lda 	#$FF
.daca					_FPUSIExtend:
.daca	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.dacd	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.dad0	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.dad3	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.dad5	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.dad8	68		pla				pla
.dad9	60		rts				rts
.dada					FPUNegateInteger:
.dada	48		pha				pha
.dadb	38		sec				sec
.dadc	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.dade	fd 08 03	sbc $0308,x			sbc 	XS_Mantissa+0,x
.dae1	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.dae4	a9 00		lda #$00			lda 	#0
.dae6	fd 09 03	sbc $0309,x			sbc 	XS_Mantissa+1,x
.dae9	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.daec	a9 00		lda #$00			lda 	#0
.daee	fd 0a 03	sbc $030a,x			sbc 	XS_Mantissa+2,x
.daf1	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.daf4	a9 00		lda #$00			lda 	#0
.daf6	fd 0b 03	sbc $030b,x			sbc 	XS_Mantissa+3,x
.daf9	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.dafc	68		pla				pla
.dafd	60		rts				rts
.dafe					FPUToFloat:
.dafe	48		pha				pha
.daff	bd 0d 03	lda $030d,x			lda 	XS_Type,x					; exit if already float.
.db02	29 0f		and #$0f			and 	#$0F
.db04	f0 2d		beq $db33			beq 	_FPUFExit
.db06	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.db08	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.db0b	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.db0d	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x 				; x mantissa.
.db10	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.db13	10 08		bpl $db1d			bpl		_FPUFPositive
.db15	20 da da	jsr $dada			jsr 	FPUNegateInteger 			; negate the mantissa
.db18	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.db1a	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.db1d					_FPUFPositive:
.db1d	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.db20	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.db23	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.db26	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.db29	d0 05		bne $db30			bne 	_FPUFNonZero
.db2b	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.db2d	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.db30					_FPUFNonZero:
.db30	20 35 db	jsr $db35			jsr 	FPUNormalise 				; normalise the floating point.
.db33					_FPUFExit:
.db33	68		pla				pla
.db34	60		rts				rts
.db35					FPUNormalise:
.db35	48		pha				pha
.db36	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.db39	70 20		bvs $db5b			bvs 	_FPUNExit
.db3b	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.db3e	f0 16		beq $db56			beq 	_FPUNSetZero
.db40					_FPUNLoop:
.db40	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.db43	30 16		bmi $db5b			bmi 	_FPUNExit 					; if so, we are normalised.
.db45	1e 08 03	asl $0308,x			asl 	0+XS_Mantissa+0,x
.db48	3e 09 03	rol $0309,x			rol 	1+XS_Mantissa+0,x
.db4b	3e 0a 03	rol $030a,x			rol 	2+XS_Mantissa+0,x
.db4e	3e 0b 03	rol $030b,x			rol 	3+XS_Mantissa+0,x
.db51	de 0c 03	dec $030c,x			dec 	XS_Exponent,x 				; decrement exponent
.db54	d0 ea		bne $db40			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.db56					_FPUNSetZero:
.db56	a9 40		lda #$40			lda 	#$40
.db58	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; the result is now zero.
.db5b					_FPUNExit:
.db5b	68		pla				pla
.db5c	60		rts				rts
.db5d					FPUToInteger:
.db5d	48		pha				pha
.db5e	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; if already integer, exit
.db61	29 01		and #$01			and 	#1
.db63	d0 3e		bne $dba3			bne 	_FPUTOI_Exit
.db65	3c 0d 03	bit $030d,x			bit 	XS_Type,x					; if zero, return zero.
.db68	70 2b		bvs $db95			bvs 	_FPUTOI_Zero
.db6a	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.db6d	10 26		bpl $db95			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.db6f	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.db71	b0 37		bcs $dbaa			bcs 	FP_Overflow
.db73					_FPUToIToInteger:
.db73	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.db76	c9 a0		cmp #$a0			cmp 	#128+32
.db78	f0 11		beq $db8b			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.db7a	fe 0c 03	inc $030c,x			inc 	XS_Exponent,X 				; increment Exponent
.db7d	5e 0b 03	lsr $030b,x			lsr 	3+XS_Mantissa,x
.db80	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.db83	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.db86	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.db89	80 e8		bra $db73			bra 	_FPUToIToInteger 			; keep going.
.db8b					_FPUToICheckSign:
.db8b	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; check sign
.db8e	10 13		bpl $dba3			bpl 	_FPUToI_Exit 				; exit if unsigned.
.db90	20 da da	jsr $dada			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.db93	80 0e		bra $dba3			bra 	_FPUTOI_Exit
.db95					_FPUTOI_Zero:
.db95	a9 00		lda #$00			lda 	#0 							; return zero integer.
.db97	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.db9a	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.db9d	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.dba0	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.dba3					_FPUToI_Exit:
.dba3	a9 01		lda #$01			lda 	#1 							; set type to integer
.dba5	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.dba8	68		pla				pla
.dba9	60		rts				rts
.dbaa					FP_Overflow:
.dbaa	20 f3 c3	jsr $c3f3			jsr ERR_Handler
>dbad	46 6c 6f 61 74 69 6e 67			.text "Floating Point overflow",0
>dbb5	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.dbc5					FPUTimes10:
.dbc5	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.dbc8	85 1a		sta $1a				sta 	ZLTemp1+0
.dbca	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.dbcd	85 1b		sta $1b				sta 	ZLTemp1+1
.dbcf	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.dbd2	85 1c		sta $1c				sta 	ZLTemp1+2
.dbd4	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.dbd7	85 1d		sta $1d				sta 	ZLTemp1+3
.dbd9	20 1d dc	jsr $dc1d			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.dbdc	20 1d dc	jsr $dc1d			jsr 	_FPUT_LSR_ZLTemp1
.dbdf	18		clc				clc
.dbe0	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.dbe3	65 1a		adc $1a				adc 	ZLTemp1+0
.dbe5	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.dbe8	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.dbeb	65 1b		adc $1b				adc 	ZLTemp1+1
.dbed	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.dbf0	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.dbf3	65 1c		adc $1c				adc 	ZLTemp1+2
.dbf5	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.dbf8	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.dbfb	65 1d		adc $1d				adc 	ZLTemp1+3
.dbfd	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.dc00	90 0f		bcc $dc11			bcc 	_FPUTimes10
.dc02	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.dc05	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.dc08	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.dc0b	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.dc0e	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x				; fix exponent
.dc11					_FPUTimes10:
.dc11	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.dc14	18		clc				clc
.dc15	69 03		adc #$03			adc 	#3
.dc17	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.dc1a	b0 8e		bcs $dbaa			bcs 	FP_Overflow 				; error
.dc1c	60		rts				rts
.dc1d					_FPUT_LSR_ZLTemp1:
.dc1d	46 1d		lsr $1d				lsr 	ZLTemp1+3
.dc1f	66 1c		ror $1c				ror 	ZLTemp1+2
.dc21	66 1b		ror $1b				ror 	ZLTemp1+1
.dc23	66 1a		ror $1a				ror 	ZLTemp1+0
.dc25	60		rts				rts
.dc26					FPUScale10A:
.dc26	5a		phy				phy
.dc27	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.dc29	f0 3d		beq $dc68			beq 	_FPUScaleExit
.dc2b	da		phx				phx 								; save X
.dc2c	e8		inx				inx
.dc2d	e8		inx				inx
.dc2e	e8		inx				inx
.dc2f	e8		inx				inx
.dc30	e8		inx				inx
.dc31	e8		inx				inx
.dc32	a8		tay				tay 								; save power scalar in Y.
.dc33	a9 00		lda #$00			lda 	#0
.dc35	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.dc38	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.dc3b	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.dc3e	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.dc41	a9 80		lda #$80			lda 	#$80
.dc43	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.dc46	a9 81		lda #$81			lda 	#$81
.dc48	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.dc4b	5a		phy				phy 								; save 10^n on stack.
.dc4c	c0 00		cpy #$00			cpy 	#0
.dc4e	10 05		bpl $dc55			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.dc50	98		tya				tya
.dc51	49 ff		eor #$ff			eor 	#$FF
.dc53	1a		inc a				inc 	a
.dc54	a8		tay				tay
.dc55					_FPUSAbs:
.dc55	20 c5 db	jsr $dbc5			jsr 	FPUTimes10
.dc58	88		dey				dey
.dc59	d0 fa		bne $dc55			bne 	_FPUSAbs 					; tos is now 10^|AC|
.dc5b	68		pla				pla 								; restore count in A
.dc5c	fa		plx				plx 								; restore X pointing to number to scale.
.dc5d	0a		asl a				asl 	a
.dc5e	b0 05		bcs $dc65			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.dc60	20 4c d9	jsr $d94c			jsr 	FPMultiply 					; if clear multiply.
.dc63	80 03		bra $dc68			bra		_FPUScaleExit
.dc65					_FPUSDivide:
.dc65	20 c4 d8	jsr $d8c4			jsr 	FPDivide
.dc68					_FPUScaleExit:
.dc68	7a		ply				ply
.dc69	60		rts				rts
.dc6a					FPUCopyToNext:
.dc6a	a0 06		ldy #$06			ldy 		#6
.dc6c	da		phx				phx
.dc6d					_FPUCopy1:
.dc6d	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x
.dc70	9d 0e 03	sta $030e,x			sta 	XS2_Mantissa,x
.dc73	e8		inx				inx
.dc74	88		dey				dey
.dc75	d0 f6		bne $dc6d			bne 	_FPUCopy1
.dc77	fa		plx				plx
.dc78	60		rts				rts
.dc79					FPUCopyFromNext:
.dc79	a0 06		ldy #$06			ldy 		#6
.dc7b	da		phx				phx
.dc7c					_FPUCopy1:
.dc7c	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa,x
.dc7f	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.dc82	e8		inx				inx
.dc83	88		dey				dey
.dc84	d0 f6		bne $dc7c			bne 	_FPUCopy1
.dc86	fa		plx				plx
.dc87	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.dc88					FPToString:
.dc88	48		pha				pha
.dc89	5a		phy				phy
.dc8a	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; check zero flag
.dc8d	50 0a		bvc $dc99			bvc 		_FPTSIsFloat 			; if zero,
.dc8f					_FPTSZero:
.dc8f	a9 30		lda #$30			lda 		#"0"
.dc91	20 18 d7	jsr $d718			jsr 		ITSOutputCharacter
.dc94					_FPTSExit:
.dc94	7a		ply				ply
.dc95	68		pla				pla
.dc96	60		rts				rts
.dc97	80 fb		bra $dc94			bra 		_FPTSExit
.dc99					_FPTSIsFloat:
.dc99	bd 0d 03	lda $030d,x			lda 		XS_Type,x 				; is it signed ?
.dc9c	10 0a		bpl $dca8			bpl 		_FPTSNotSigned
.dc9e	a9 00		lda #$00			lda 		#0 						; clear sign flag
.dca0	9d 0d 03	sta $030d,x			sta 		XS_Type,x
.dca3	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.dca5	20 18 d7	jsr $d718			jsr 		ITSOutputCharacter
.dca8					_FPTSNotSigned:
.dca8	bd 0c 03	lda $030c,x			lda 		XS_Exponent,x
.dcab	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.dcad	b0 09		bcs $dcb8			bcs 		_FPTSExponent
.dcaf	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.dcb1	90 05		bcc $dcb8			bcc 		_FPTSExponent 			;
.dcb3					_FPTSStandard:
.dcb3	20 fc dc	jsr $dcfc			jsr 		FPTOutputBody 			; output the body.
.dcb6	80 dc		bra $dc94			bra 		_FPTSExit
.dcb8					_FPTSExponent:
.dcb8	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.dcba	8d 8d 04	sta $048d			sta 		ExpCount
.dcbd					_FPTSExponentLoop:
.dcbd	bd 0c 03	lda $030c,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.dcc0	10 0e		bpl $dcd0			bpl 		_FPTSTimes
.dcc2	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.dcc4	90 14		bcc $dcda			bcc 		_FPTSScaledToExp
.dcc6	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.dcc8	20 26 dc	jsr $dc26			jsr 		FPUScale10A
.dccb	ee 8d 04	inc $048d			inc 		ExpCount
.dcce	80 ed		bra $dcbd			bra 		_FPTSExponentLoop
.dcd0					_FPTSTimes:
.dcd0	a9 01		lda #$01			lda 		#1
.dcd2	20 26 dc	jsr $dc26			jsr 		FPUScale10A
.dcd5	ce 8d 04	dec $048d			dec 		ExpCount
.dcd8	80 e3		bra $dcbd			bra 		_FPTSExponentLoop
.dcda					_FPTSScaledToExp:
.dcda	20 fc dc	jsr $dcfc			jsr 		FPTOutputBody 			; output the body.
.dcdd	a9 65		lda #$65			lda 		#"e"					; output E
.dcdf	20 18 d7	jsr $d718			jsr 		ITSOutputCharacter
.dce2	ad 8d 04	lda $048d			lda 		ExpCount 				; get the exponent
.dce5	9d 08 03	sta $0308,x			sta 		XS_Mantissa,x
.dce8	29 80		and #$80			and 		#$80 					; sign extend it
.dcea	f0 02		beq $dcee			beq 		_FPTSSExt
.dcec	a9 ff		lda #$ff			lda 		#$FF
.dcee					_FPTSSExt:
.dcee	9d 09 03	sta $0309,x			sta 		XS_Mantissa+1,x
.dcf1	9d 0a 03	sta $030a,x			sta 		XS_Mantissa+2,x
.dcf4	9d 0b 03	sta $030b,x			sta 		XS_Mantissa+3,x
.dcf7	20 78 d6	jsr $d678			jsr 		INTToString 			; output the exponent.
.dcfa	80 98		bra $dc94			bra			_FPTSExit 				; and exit.
.dcfc					FPTOutputBody:
.dcfc	20 6a dc	jsr $dc6a			jsr 		FPUCopyToNext 			; copy to next slot.
.dcff	20 5d db	jsr $db5d			jsr 		FPUToInteger 			; convert to an integer
.dd02	20 78 d6	jsr $d678			jsr 		INTToString 			; output the main integer part.
.dd05	20 79 dc	jsr $dc79			jsr 		FPUCopyFromNext 		; get the fractional part back.
.dd08	20 e9 d9	jsr $d9e9			jsr 		FPFractionalPart 		; get the decimal part.
.dd0b	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; any fractional part.
.dd0e	70 3e		bvs $dd4e			bvs 		_FPTOExit 				; if not, exit now.
.dd10	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.dd12	20 18 d7	jsr $d718			jsr 		ITSOutputCharacter
.dd15					_FPOutLoop:
.dd15	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; finally reached zero.
.dd18	70 1e		bvs $dd38			bvs 		_FPStripZeros 			; strip trailing zeros
.dd1a	20 c5 db	jsr $dbc5			jsr 		FPUTimes10 				; multiply by 10
.dd1d	20 6a dc	jsr $dc6a			jsr 		FPUCopyToNext			; copy to next slot.
.dd20	20 5d db	jsr $db5d			jsr 		FPUToInteger 			; convert to integer
.dd23	bd 08 03	lda $0308,x			lda 		XS_Mantissa+0,x 		; print digit.
.dd26	09 30		ora #$30			ora 		#"0"
.dd28	20 18 d7	jsr $d718			jsr 		ITSOutputCharacter
.dd2b	20 79 dc	jsr $dc79			jsr 		FPUCopyFromNext 		; get it back
.dd2e	20 e9 d9	jsr $d9e9			jsr 		FPFractionalPart 		; get fractional part
.dd31	ad 04 04	lda $0404			lda 		NumBufX 				; done 11 characters yet ?
.dd34	c9 0b		cmp #$0b			cmp 	 	#11
.dd36	90 dd		bcc $dd15			bcc 		_FPOutLoop 				; if so, keep going till zero.
.dd38					_FPStripZeros:
.dd38	ac 04 04	ldy $0404			ldy 		NumBufX 				; strip trailing zeros.
.dd3b					_FPStripLoop:
.dd3b	88		dey				dey 								; back one, if at start then no strip
.dd3c	f0 10		beq $dd4e			beq 		_FPToExit
.dd3e	b9 05 04	lda $0405,y			lda 		Num_Buffer,y 			; keep going if "0"
.dd41	c9 30		cmp #$30			cmp 		#"0"
.dd43	f0 f6		beq $dd3b			beq 		_FPStripLoop
.dd45	c8		iny				iny
.dd46	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.dd48	99 05 04	sta $0405,y			sta 		Num_Buffer,y
.dd4b	8c 04 04	sty $0404			sty 		NumBufX 				; update position.
.dd4e					_FPTOExit:
.dd4e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.dd4f					FPFromString:
.dd4f	48		pha				pha 								; push A
.dd50	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.dd52	c9 2e		cmp #$2e			cmp 	#"."
.dd54	f0 03		beq $dd59			beq	 	_FPFIsDecimal
.dd56	4c bc dd	jmp $ddbc			jmp 	_FPFNotDecimal
.dd59					_FPFIsDecimal:
.dd59	c8		iny				iny 								; consume the decimal.
.dd5a	20 fe da	jsr $dafe			jsr 	FPUToFloat 					; convert the integer to float.
.dd5d	da		phx				phx 								; save X.
.dd5e	5a		phy				phy 								; save decimal start position
.dd5f	e8		inx				inx
.dd60	e8		inx				inx
.dd61	e8		inx				inx
.dd62	e8		inx				inx
.dd63	e8		inx				inx
.dd64	e8		inx				inx
.dd65	20 30 d7	jsr $d730			jsr 	INTFromStringY 				; get the part after the DP.
.dd68	20 fe da	jsr $dafe			jsr 	FPUToFloat 					; convert that to a float.
.dd6b	68		pla				pla 								; calculate - chars consumed.
.dd6c	8c 8c 04	sty $048c			sty 	ExpTemp
.dd6f	38		sec				sec
.dd70	ed 8c 04	sbc $048c			sbc 	ExpTemp 					; this is the shift amount
.dd73	20 26 dc	jsr $dc26			jsr 	FPUScale10A 				; scale it by 10^AC
.dd76	fa		plx				plx 								; restore original X
.dd77	20 e0 d7	jsr $d7e0			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.dd7a	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.dd7c	c9 45		cmp #$45			cmp 	#"E"
.dd7e	f0 04		beq $dd84			beq 	_FPFExponent
.dd80	c9 65		cmp #$65			cmp 	#"e"
.dd82	d0 38		bne $ddbc			bne 	_FPFNotDecimal 				; no, then exit normally.
.dd84					_FPFExponent:
.dd84	c8		iny				iny 								; skip over E symbol.
.dd85	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.dd87	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.dd89	d0 01		bne $dd8c			bne 	_FPFGotSign
.dd8b	c8		iny				iny 								; if it was - skip over it.
.dd8c					_FPFGotSign:
.dd8c	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.dd8d	da		phx				phx
.dd8e	e8		inx				inx
.dd8f	e8		inx				inx
.dd90	e8		inx				inx
.dd91	e8		inx				inx
.dd92	e8		inx				inx
.dd93	e8		inx				inx
.dd94	20 30 d7	jsr $d730			jsr 	INTFromStringY 				; get the exponent
.dd97	fa		plx				plx 								; restore X.
.dd98	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.dd9b	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.dd9e	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.dda1	d0 1b		bne $ddbe			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.dda3	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.dda6	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.dda8	b0 14		bcs $ddbe			bcs 	_FPFXOverflow
.ddaa	68		pla				pla 								; get direction
.ddab	d0 09		bne $ddb6			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.ddad	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.ddb0	49 ff		eor #$ff			eor 	#$FF
.ddb2	1a		inc a				inc 	a
.ddb3	9d 0e 03	sta $030e,x			sta 	XS2_Mantissa+0,x
.ddb6					_FPFXScale:
.ddb6	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.ddb9	20 26 dc	jsr $dc26			jsr 	FPUScale10A 				; scale by the exponent.
.ddbc					_FPFNotDecimal:
.ddbc	68		pla				pla
.ddbd	60		rts				rts
.ddbe					_FPFXOverflow:
.ddbe	20 f3 c3	jsr $c3f3			jsr 	ERR_Handler
>ddc1	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>ddc9	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.ddd0					Unary_Rnd:
.ddd0	20 15 ca	jsr $ca15			jsr 	EvaluateNumberX 			; get value
.ddd3	20 a3 d0	jsr $d0a3			jsr 	CheckNextRParen 			; check right bracket.
.ddd6	20 02 cd	jsr $cd02			jsr 	GetSignCurrent 				; get sign -1,0,1.
.ddd9	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.dddb	30 10		bmi $dded			bmi 	_URSetSeed
.dddd	f0 2c		beq $de0b			beq 	_URMakeRandom 				; if zero return same number.
.dddf	da		phx				phx
.dde0	a2 00		ldx #$00			ldx 	#0
.dde2	20 48 de	jsr $de48			jsr 	Random16
.dde5	a2 02		ldx #$02			ldx 	#2
.dde7	20 48 de	jsr $de48			jsr 	Random16
.ddea	fa		plx				plx
.ddeb	80 1e		bra $de0b			bra 	_URMakeRandom
.dded					_URSetSeed:
.dded	20 fe da	jsr $dafe			jsr 	FPUToFloat 					; make it a float to twiddle it.
.ddf0	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.ddf3	8d 93 04	sta $0493			sta 	RandomSeed+0
.ddf6	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.ddf9	8d 94 04	sta $0494			sta 	RandomSeed+1
.ddfc	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.ddff	8d 95 04	sta $0495			sta 	RandomSeed+2
.de02	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.de05	0a		asl a				asl 	a
.de06	49 db		eor #$db			eor 	#$DB
.de08	8d 96 04	sta $0496			sta 	RandomSeed+3
.de0b					_URMakeRandom:
.de0b	ad 93 04	lda $0493			lda 	RandomSeed+0 				; check if seed is zero.
.de0e	0d 94 04	ora $0494			ora 	RandomSeed+1
.de11	0d 95 04	ora $0495			ora 	RandomSeed+2
.de14	0d 96 04	ora $0496			ora 	RandomSeed+3
.de17	d0 0a		bne $de23			bne 	_URNotZero
.de19	a9 47		lda #$47			lda 	#$47
.de1b	8d 94 04	sta $0494			sta 	RandomSeed+1				; if it is, make it non zero.
.de1e	a9 3d		lda #$3d			lda 	#$3D
.de20	8d 96 04	sta $0496			sta 	RandomSeed+3
.de23					_URNotZero:
.de23	ad 93 04	lda $0493			lda 	RandomSeed+0 				; copy seed into mantissa.
.de26	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.de29	ad 94 04	lda $0494			lda 	RandomSeed+1
.de2c	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.de2f	ad 95 04	lda $0495			lda 	RandomSeed+2
.de32	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.de35	ad 96 04	lda $0496			lda 	RandomSeed+3
.de38	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.de3b	a9 00		lda #$00			lda 	#$00 						; set type to float.
.de3d	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.de40	a9 80		lda #$80			lda 	#$80
.de42	9d 0c 03	sta $030c,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.de45	4c 35 db	jmp $db35			jmp 	FPUNormalise
.de48					Random16:
.de48	5e 94 04	lsr $0494,x			lsr 	RandomSeed+1,x				; shift seed right
.de4b	7e 93 04	ror $0493,x			ror 	RandomSeed,x
.de4e	90 08		bcc $de58			bcc 	_R16_NoXor
.de50	bd 94 04	lda $0494,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.de53	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.de55	9d 94 04	sta $0494,x			sta 	RandomSeed+1,x
.de58					_R16_NoXor:
.de58	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.de59					Unary_Int:
.de59	20 15 ca	jsr $ca15			jsr 	EvaluateNumberX 			; get value
.de5c	20 a3 d0	jsr $d0a3			jsr 	CheckNextRParen 			; check right bracket.
.de5f	4c 5d db	jmp $db5d			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Return to file: basic.asm

>de62	02						.byte 	2
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 c0						.word 	StartROM
>fffe	3a c3					.word TIM_BreakVector

;******  End of listing
