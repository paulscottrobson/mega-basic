
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Fri Aug 23 07:54:52 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="4510"					cpu = "4510"
="mega65"				hardware = "mega65"

;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0020					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0200					IFT_XCursor:.byte ?							; current logical position on screen
>0201					IFT_YCursor:.byte ?
>0202					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0266					IFT_LineBuffer: .fill 100 					; line input buffer.
>0300					UserVector .fill 4 							; USR(x) calls this.
>0304					LocalVector .fill 4 						; Indirect calls call this.
>0308					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>030c					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>030d					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=782					XS2_Mantissa = XS_Mantissa+XS_Size
=786					XS2_Exponent = XS_Exponent+XS_Size
=787					XS2_Type = XS_Type+XS_Size
=788					XS3_Mantissa = XS_Mantissa+XS_Size*2
=792					XS3_Exponent = XS_Exponent+XS_Size*2
=793					XS3_Type = XS_Type+XS_Size*2
>0400					Num_Buffer	.fill 	32 						; buffer for numeric conversions
>0420					NumBufX 	.byte 	?						; buffer index position
>0421					NumSuppress	.byte 	?						; leading zero suppression flag
>0422					NumConvCount .byte 	? 						; count for conversions.
>0423					ExpTemp:	.byte ?							; Working temp for exponents.
>0424					ExpCount:	.byte ? 						; Count of decimal exponents.
>0425					SignCount:	.byte ?							; Integer Divide Sign Counts.
>0426					StringPtr:	.byte ? 						; Top of free memory (for string allocation)
>0427					TempStringWriteIndex: .byte ? 				; Write offset.
>0428					ValSign: 	.byte ? 						; sign flag for val()
>0429					RandomSeed:	.dword ? 						; Random seed.
>042d					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>042f					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>0431					Tim_SR:		.byte ? 						; Processor Status
>0432					Tim_A:		.byte ? 						; Processor Registers
>0433					Tim_X:		.byte ?
>0434					Tim_Y:		.byte ?
>0435					Tim_Z:		.byte ?
>0436					Tim_SP:		.byte ?							; Stack Pointer

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/mega65.asm

=$a000					HighMemory = $A000
.1000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testcode.src

>1000	13 0a 00 d9 fe 07 61 62			.byte	$13,$0a,$00,$d9,$fe,$07,$61,$62
>1008	63 64 65 be ff 06 68 69			.byte	$63,$64,$65,$be,$ff,$06,$68,$69
>1010	20 21 00 00				.byte	$20,$21,$00,$00

;******  Return to file: modules/hardware/mega65.asm


;******  Processing file: modules/hardware/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b4					lastUnaryFunction = $b4
.a000					VectorTable:
>a000	b2 a0					.word NotImplemented       & $FFFF ; $80 and
>a002	b2 a0					.word NotImplemented       & $FFFF ; $81 or
>a004	b2 a0					.word NotImplemented       & $FFFF ; $82 xor
>a006	b2 a0					.word NotImplemented       & $FFFF ; $83 eor
>a008	b2 a0					.word NotImplemented       & $FFFF ; $84 =
>a00a	b2 a0					.word NotImplemented       & $FFFF ; $85 <>
>a00c	b2 a0					.word NotImplemented       & $FFFF ; $86 <
>a00e	b2 a0					.word NotImplemented       & $FFFF ; $87 <=
>a010	b2 a0					.word NotImplemented       & $FFFF ; $88 >
>a012	b2 a0					.word NotImplemented       & $FFFF ; $89 >=
>a014	b2 a0					.word NotImplemented       & $FFFF ; $8a +
>a016	b2 a0					.word NotImplemented       & $FFFF ; $8b -
>a018	b2 a0					.word NotImplemented       & $FFFF ; $8c *
>a01a	b2 a0					.word NotImplemented       & $FFFF ; $8d /
>a01c	b2 a0					.word NotImplemented       & $FFFF ; $8e ^
>a01e	b2 a0					.word NotImplemented       & $FFFF ; $8f if
>a020	b2 a0					.word NotImplemented       & $FFFF ; $90 while
>a022	b2 a0					.word NotImplemented       & $FFFF ; $91 repeat
>a024	b2 a0					.word NotImplemented       & $FFFF ; $92 for
>a026	b2 a0					.word NotImplemented       & $FFFF ; $93 then
>a028	b2 a0					.word NotImplemented       & $FFFF ; $94 endif
>a02a	b2 a0					.word NotImplemented       & $FFFF ; $95 wend
>a02c	b2 a0					.word NotImplemented       & $FFFF ; $96 until
>a02e	b2 a0					.word NotImplemented       & $FFFF ; $97 next
>a030	b2 a0					.word NotImplemented       & $FFFF ; $98 not
>a032	b2 a0					.word NotImplemented       & $FFFF ; $99 fn(
>a034	b2 a0					.word NotImplemented       & $FFFF ; $9a abs(
>a036	b2 a0					.word NotImplemented       & $FFFF ; $9b asc(
>a038	b2 a0					.word NotImplemented       & $FFFF ; $9c int(
>a03a	b2 a0					.word NotImplemented       & $FFFF ; $9d peek(
>a03c	b2 a0					.word NotImplemented       & $FFFF ; $9e rnd(
>a03e	b2 a0					.word NotImplemented       & $FFFF ; $9f usr(
>a040	b2 a0					.word NotImplemented       & $FFFF ; $a0 left$(
>a042	b2 a0					.word NotImplemented       & $FFFF ; $a1 right$(
>a044	b2 a0					.word NotImplemented       & $FFFF ; $a2 mid$(
>a046	b2 a0					.word NotImplemented       & $FFFF ; $a3 spc(
>a048	b2 a0					.word NotImplemented       & $FFFF ; $a4 str$(
>a04a	b2 a0					.word NotImplemented       & $FFFF ; $a5 val(
>a04c	b2 a0					.word NotImplemented       & $FFFF ; $a6 len(
>a04e	b2 a0					.word NotImplemented       & $FFFF ; $a7 hex$(
>a050	b2 a0					.word NotImplemented       & $FFFF ; $a8 sin(
>a052	b2 a0					.word NotImplemented       & $FFFF ; $a9 cos(
>a054	b2 a0					.word NotImplemented       & $FFFF ; $aa tan(
>a056	b2 a0					.word NotImplemented       & $FFFF ; $ab atn(
>a058	b2 a0					.word NotImplemented       & $FFFF ; $ac exp(
>a05a	b2 a0					.word NotImplemented       & $FFFF ; $ad log(
>a05c	b2 a0					.word NotImplemented       & $FFFF ; $ae sqr(
>a05e	b2 a0					.word NotImplemented       & $FFFF ; $af dec(
>a060	b2 a0					.word NotImplemented       & $FFFF ; $b0 deek(
>a062	b2 a0					.word NotImplemented       & $FFFF ; $b1 leek(
>a064	b2 a0					.word NotImplemented       & $FFFF ; $b2 mod(
>a066	b2 a0					.word NotImplemented       & $FFFF ; $b3 sgn(
>a068	b2 a0					.word NotImplemented       & $FFFF ; $b4 chr$(
>a06a	b2 a0					.word NotImplemented       & $FFFF ; $b5 $(
>a06c	b2 a0					.word NotImplemented       & $FFFF ; $b6 $
>a06e	b2 a0					.word NotImplemented       & $FFFF ; $b7 #(
>a070	b2 a0					.word NotImplemented       & $FFFF ; $b8 #
>a072	b2 a0					.word NotImplemented       & $FFFF ; $b9 %(
>a074	b2 a0					.word NotImplemented       & $FFFF ; $ba %
>a076	b2 a0					.word NotImplemented       & $FFFF ; $bb (
>a078	b2 a0					.word NotImplemented       & $FFFF ; $bc )
>a07a	b2 a0					.word NotImplemented       & $FFFF ; $bd ,
>a07c	b2 a0					.word NotImplemented       & $FFFF ; $be :
>a07e	b2 a0					.word NotImplemented       & $FFFF ; $bf ;
>a080	b2 a0					.word NotImplemented       & $FFFF ; $c0 def
>a082	b2 a0					.word NotImplemented       & $FFFF ; $c1 clr
>a084	b2 a0					.word NotImplemented       & $FFFF ; $c3 data
>a086	b2 a0					.word NotImplemented       & $FFFF ; $c4 read
>a088	b2 a0					.word NotImplemented       & $FFFF ; $c5 dim
>a08a	b2 a0					.word NotImplemented       & $FFFF ; $c6 to
>a08c	b2 a0					.word NotImplemented       & $FFFF ; $c7 step
>a08e	b2 a0					.word NotImplemented       & $FFFF ; $c8 gosub
>a090	b2 a0					.word NotImplemented       & $FFFF ; $c9 return
>a092	b2 a0					.word NotImplemented       & $FFFF ; $ca goto
>a094	b2 a0					.word NotImplemented       & $FFFF ; $cb input
>a096	b2 a0					.word NotImplemented       & $FFFF ; $cc let
>a098	b2 a0					.word NotImplemented       & $FFFF ; $cd list
>a09a	b2 a0					.word NotImplemented       & $FFFF ; $ce new
>a09c	b2 a0					.word NotImplemented       & $FFFF ; $cf old
>a09e	b2 a0					.word NotImplemented       & $FFFF ; $d0 on
>a0a0	b2 a0					.word NotImplemented       & $FFFF ; $d1 restore
>a0a2	b2 a0					.word NotImplemented       & $FFFF ; $d2 poke
>a0a4	b2 a0					.word NotImplemented       & $FFFF ; $d3 print
>a0a6	b2 a0					.word NotImplemented       & $FFFF ; $d4 run
>a0a8	b2 a0					.word NotImplemented       & $FFFF ; $d5 stop
>a0aa	b2 a0					.word NotImplemented       & $FFFF ; $d6 wait
>a0ac	b2 a0					.word NotImplemented       & $FFFF ; $d7 doke
>a0ae	b2 a0					.word NotImplemented       & $FFFF ; $d8 loke
>a0b0	b2 a0					.word NotImplemented       & $FFFF ; $d9 assert
.a0b2					NotImplemented:
.a0b2	80 fe		bra $a0b2		_error: bra _error
.a0b4					BinaryPrecedence:
>a0b4	01					.byte 1    ; $80 and
>a0b5	01					.byte 1    ; $81 or
>a0b6	01					.byte 1    ; $82 xor
>a0b7	01					.byte 1    ; $83 eor
>a0b8	02					.byte 2    ; $84 =
>a0b9	02					.byte 2    ; $85 <>
>a0ba	02					.byte 2    ; $86 <
>a0bb	02					.byte 2    ; $87 <=
>a0bc	02					.byte 2    ; $88 >
>a0bd	02					.byte 2    ; $89 >=
>a0be	03					.byte 3    ; $8a +
>a0bf	03					.byte 3    ; $8b -
>a0c0	04					.byte 4    ; $8c *
>a0c1	04					.byte 4    ; $8d /
>a0c2	05					.byte 5    ; $8e ^
.a0c3					KeywordText:
>a0c3	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>a0c6	4f d2					.byte $4f,$d2                          ; $81 or
>a0c8	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>a0cb	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>a0ce	bd					.byte $bd                              ; $84 =
>a0cf	3c be					.byte $3c,$be                          ; $85 <>
>a0d1	bc					.byte $bc                              ; $86 <
>a0d2	3c bd					.byte $3c,$bd                          ; $87 <=
>a0d4	be					.byte $be                              ; $88 >
>a0d5	3e bd					.byte $3e,$bd                          ; $89 >=
>a0d7	ab					.byte $ab                              ; $8a +
>a0d8	ad					.byte $ad                              ; $8b -
>a0d9	aa					.byte $aa                              ; $8c *
>a0da	af					.byte $af                              ; $8d /
>a0db	de					.byte $de                              ; $8e ^
>a0dc	49 c6					.byte $49,$c6                          ; $8f if
>a0de	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>a0e3	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>a0e9	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>a0ec	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>a0f0	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>a0f5	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>a0f9	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>a0fe	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>a102	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>a105	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>a108	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>a10c	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>a110	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>a114	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>a119	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>a11d	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>a121	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>a127	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>a12e	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>a133	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>a137	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>a13c	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>a140	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>a144	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>a149	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>a14d	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>a151	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>a155	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>a159	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>a15d	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>a161	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>a165	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>a169	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>a16e	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>a173	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>a177	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>a17b	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>a180	24 a8					.byte $24,$a8                          ; $b5 $(
>a182	a4					.byte $a4                              ; $b6 $
>a183	23 a8					.byte $23,$a8                          ; $b7 #(
>a185	a3					.byte $a3                              ; $b8 #
>a186	25 a8					.byte $25,$a8                          ; $b9 %(
>a188	a5					.byte $a5                              ; $ba %
>a189	a8					.byte $a8                              ; $bb (
>a18a	a9					.byte $a9                              ; $bc )
>a18b	ac					.byte $ac                              ; $bd ,
>a18c	ba					.byte $ba                              ; $be :
>a18d	bb					.byte $bb                              ; $bf ;
>a18e	44 45 c6				.byte $44,$45,$c6                      ; $c0 def
>a191	43 4c d2				.byte $43,$4c,$d2                      ; $c1 clr
>a194	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c3 data
>a198	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c4 read
>a19c	44 49 cd				.byte $44,$49,$cd                      ; $c5 dim
>a19f	54 cf					.byte $54,$cf                          ; $c6 to
>a1a1	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c7 step
>a1a5	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $c8 gosub
>a1aa	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $c9 return
>a1b0	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $ca goto
>a1b4	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $cb input
>a1b9	4c 45 d4				.byte $4c,$45,$d4                      ; $cc let
>a1bc	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $cd list
>a1c0	4e 45 d7				.byte $4e,$45,$d7                      ; $ce new
>a1c3	4f 4c c4				.byte $4f,$4c,$c4                      ; $cf old
>a1c6	4f ce					.byte $4f,$ce                          ; $d0 on
>a1c8	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d1 restore
>a1cf	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d2 poke
>a1d3	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d3 print
>a1d8	52 55 ce				.byte $52,$55,$ce                      ; $d4 run
>a1db	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $d5 stop
>a1df	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d6 wait
>a1e3	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $d7 doke
>a1e7	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $d8 loke
>a1eb	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $d9 assert
>a1f1	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_dollarlparen = $b5
=$b6					token_dollar = $b6
=$b7					token_hashlparen = $b7
=$b8					token_hash = $b8
=$b9					token_percentlparen = $b9
=$ba					token_percent = $ba
=$bb					token_lparen = $bb
=$bc					token_rparen = $bc
=$bd					token_comma = $bd
=$be					token_colon = $be
=$bf					token_semicolon = $bf
=$c0					token_def = $c0
=$c1					token_clr = $c1
=$c3					token_data = $c3
=$c4					token_read = $c4
=$c5					token_dim = $c5
=$c6					token_to = $c6
=$c7					token_step = $c7
=$c8					token_gosub = $c8
=$c9					token_return = $c9
=$ca					token_goto = $ca
=$cb					token_input = $cb
=$cc					token_let = $cc
=$cd					token_list = $cd
=$ce					token_new = $ce
=$cf					token_old = $cf
=$d0					token_on = $d0
=$d1					token_restore = $d1
=$d2					token_poke = $d2
=$d3					token_print = $d3
=$d4					token_run = $d4
=$d5					token_stop = $d5
=$d6					token_wait = $d6
=$d7					token_doke = $d7
=$d8					token_loke = $d8
=$d9					token_assert = $d9

;******  Return to file: modules/hardware/mega65.asm

.a1f2					StartROM:
.a1f2	a2 ff		ldx #$ff			ldx 		#$FF 					; empty stack
.a1f4	9a		txs				txs
.a1f5	20 32 a4	jsr $a432			jsr 	IF_Reset 					; reset external interface
.a1f8	20 fe a1	jsr $a1fe			jsr 	IFT_ClearScreen
.a1fb	4c 8d ad	jmp $ad8d		jmp TIM_Start

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.a1fe					IFT_ClearScreen:
.a1fe	48		pha				pha
.a1ff	da		phx				phx
.a200	5a		phy				phy
.a201	20 99 a3	jsr $a399			jsr 	IF_Home 					; home cursor
.a204	a2 19		ldx #$19			ldx 	#IF_Height 					; this many lines.
.a206					_IFT_CS0:
.a206	a0 50		ldy #$50			ldy 	#IF_Width 					; this many chars/line
.a208					_IFT_CS1:
.a208	a9 20		lda #$20			lda 	#' '						; clear line.
.a20a	20 c8 a3	jsr $a3c8			jsr 	IF_Write
.a20d	88		dey				dey
.a20e	d0 f8		bne $a208			bne 	_IFT_CS1
.a210	20 a8 a3	jsr $a3a8			jsr 	IF_NewLine 					; next line down
.a213	ca		dex				dex
.a214	d0 f0		bne $a206			bne 	_IFT_CS0
.a216	7a		ply				ply
.a217	fa		plx				plx
.a218	68		pla				pla
.a219					IFT_HomeCursor:
.a219	48		pha				pha
.a21a	20 99 a3	jsr $a399			jsr 	IF_Home
.a21d	a9 00		lda #$00			lda 	#0
.a21f	8d 00 02	sta $0200			sta 	IFT_XCursor
.a222	8d 01 02	sta $0201			sta 	IFT_YCursor
.a225	68		pla				pla
.a226	60		rts				rts
.a227					IFT_UpLine:
.a227	48		pha				pha
.a228	ad 01 02	lda $0201			lda  	IFT_YCursor 				; get Y
.a22b	3a		dec a				dec 	a 							; line above
.a22c	30 03		bmi $a231			bmi 	_IFTULExit 					; too far, abort
.a22e	20 bc a2	jsr $a2bc			jsr 	IFT_SetYPos					; set to that line.
.a231					_IFTULExit:
.a231	68		pla				pla
.a232	60		rts				rts
.a233					IFT_PrintCharacter:
.a233	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.a235	f0 16		beq $a24d			beq 	IFT_NewLine
.a237	48		pha				pha
.a238	20 65 a2	jsr $a265			jsr 	IFT_UpperCase 				; make upper case
.a23b	20 c8 a3	jsr $a3c8			jsr 	IF_Write 					; write out.
.a23e	ee 00 02	inc $0200			inc 	IFT_XCursor 				; bump x cursor
.a241	ad 00 02	lda $0200			lda 	IFT_XCursor 				; reached RHS ?
.a244	c9 50		cmp #$50			cmp 	#IF_Width
.a246	d0 03		bne $a24b			bne 	_IFT_PCNotEOL
.a248	20 4d a2	jsr $a24d			jsr 	IFT_NewLine 				; if so do new line.
.a24b					_IFT_PCNotEOL:
.a24b	68		pla				pla
.a24c	60		rts				rts
.a24d					IFT_NewLine:
.a24d	48		pha				pha
.a24e	20 a8 a3	jsr $a3a8			jsr 	IF_NewLine 					; new line on actual screen.
.a251	a9 00		lda #$00			lda 	#0 							; reset x position
.a253	8d 00 02	sta $0200			sta 	IFT_XCursor
.a256	ee 01 02	inc $0201			inc 	IFT_YCursor 				; move down.
.a259	ad 01 02	lda $0201			lda 	IFT_YCursor
.a25c	c9 19		cmp #$19			cmp 	#IF_Height 					; reached bottom.
.a25e	d0 03		bne $a263			bne 	_IFT_NL_NotEOS
.a260	20 70 a2	jsr $a270			jsr 	IFT_Scroll 					; scroll screen up.
.a263					_IFT_NL_NotEOS:
.a263	68		pla				pla
.a264	60		rts				rts
.a265					IFT_UpperCase:
.a265	c9 61		cmp #$61			cmp 	#"a"
.a267	90 06		bcc $a26f			bcc 	_IFT_UCExit
.a269	c9 7b		cmp #$7b			cmp 	#"z"+1
.a26b	b0 02		bcs $a26f			bcs 	_IFT_UCExit
.a26d	49 20		eor #$20			eor 	#$20
.a26f					_IFT_UCExit:
.a26f	60		rts				rts
.a270					IFT_Scroll:
.a270	48		pha				pha 								; save AXY
.a271	da		phx				phx
.a272	5a		phy				phy
.a273	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.a275					_IFT_SLoop:
.a275	20 95 a2	jsr $a295			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.a278	e8		inx				inx
.a279	e0 18		cpx #$18			cpx 	#IF_Height-1				; do whole screen
.a27b	d0 f8		bne $a275			bne 	_IFT_SLoop
.a27d	a9 18		lda #$18			lda 	#IF_Height-1 				; move to X = 0,Y = A
.a27f	20 bc a2	jsr $a2bc			jsr 	IFT_SetYPos
.a282	a2 50		ldx #$50			ldx 	#IF_Width 					; blank line
.a284					_IFT_SBlank:
.a284	a9 20		lda #$20			lda 	#32
.a286	20 c8 a3	jsr $a3c8			jsr 	IF_Write
.a289	ca		dex				dex
.a28a	d0 f8		bne $a284			bne 	_IFT_SBlank
.a28c	a9 18		lda #$18			lda 	#IF_Height-1 				; move to X = 0,Y = A
.a28e	20 bc a2	jsr $a2bc			jsr 	IFT_SetYPos
.a291	7a		ply				ply
.a292	fa		plx				plx
.a293	68		pla				pla
.a294	60		rts				rts
.a295					_IFT_ScrollLine:
.a295	da		phx				phx
.a296	da		phx				phx
.a297	8a		txa				txa 								; copy line into buffer.
.a298	1a		inc a				inc 	a 							; next line down.
.a299	20 bc a2	jsr $a2bc			jsr 	IFT_SetYPos
.a29c	a2 00		ldx #$00			ldx 	#0
.a29e					_IFTScrollCopy1:
.a29e	20 ba a3	jsr $a3ba			jsr 	IF_Read
.a2a1	9d 02 02	sta $0202,x			sta 	IFT_Buffer,x
.a2a4	e8		inx				inx
.a2a5	e0 50		cpx #$50			cpx 	#IF_Width
.a2a7	d0 f5		bne $a29e			bne 	_IFTScrollCopy1
.a2a9	68		pla				pla
.a2aa	20 bc a2	jsr $a2bc			jsr 	IFT_SetYPos
.a2ad	a2 00		ldx #$00			ldx 	#0
.a2af					_IFTScrollCopy2:
.a2af	bd 02 02	lda $0202,x			lda 	IFT_Buffer,x
.a2b2	20 c8 a3	jsr $a3c8			jsr 	IF_Write
.a2b5	e8		inx				inx
.a2b6	e0 50		cpx #$50			cpx 	#IF_Width
.a2b8	d0 f5		bne $a2af			bne 	_IFTScrollCopy2
.a2ba	fa		plx				plx
.a2bb	60		rts				rts
.a2bc					IFT_SetYPos:
.a2bc	48		pha				pha
.a2bd	da		phx				phx
.a2be	aa		tax				tax
.a2bf	20 19 a2	jsr $a219			jsr 	IFT_HomeCursor
.a2c2	e0 00		cpx #$00			cpx 	#0
.a2c4	f0 09		beq $a2cf			beq 	_IFT_MOAExit
.a2c6					_IFT_MOALoop:
.a2c6	20 a8 a3	jsr $a3a8			jsr 	IF_NewLine
.a2c9	ee 01 02	inc $0201			inc 	IFT_YCursor
.a2cc	ca		dex				dex
.a2cd	d0 f7		bne $a2c6			bne		_IFT_MOALoop
.a2cf					_IFT_MOAExit:
.a2cf	fa		plx				plx
.a2d0	68		pla				pla
.a2d1	60		rts				rts
.a2d2					IFT_GetKeyCursor:
.a2d2	20 da a2	jsr $a2da			jsr 	_IFT_FlipCursor 			; reverse current
.a2d5					_IFT_GKCWait:
.a2d5	20 eb a3	jsr $a3eb			jsr 	IF_GetKey 					; get key
.a2d8	f0 fb		beq $a2d5			beq 	_IFT_GKCWait
.a2da					_IFT_FlipCursor:
.a2da	48		pha				pha 								; save
.a2db	20 ba a3	jsr $a3ba			jsr 	IF_Read 					; read
.a2de	20 d3 a3	jsr $a3d3			jsr 	IF_LeftOne
.a2e1	49 80		eor #$80			eor 	#$80 						; reverse
.a2e3	20 c8 a3	jsr $a3c8			jsr 	IF_Write 					; write
.a2e6	20 d3 a3	jsr $a3d3			jsr 	IF_LeftOne
.a2e9	68		pla				pla
.a2ea	60		rts				rts
.a2eb					IFT_ReadLine:
.a2eb	48		pha				pha
.a2ec					_IFT_RLLoop:
.a2ec	20 d2 a2	jsr $a2d2			jsr 	IFT_GetKeyCursor 			; get keystroke
.a2ef	c9 0d		cmp #$0d			cmp 	#13							; return
.a2f1	f0 7d		beq $a370			beq 	_IFT_RLExit
.a2f3	c9 20		cmp #$20			cmp 	#32 						; control character
.a2f5	90 05		bcc $a2fc			bcc 	_IFT_Control
.a2f7	20 33 a2	jsr $a233			jsr 	IFT_PrintCharacter
.a2fa	80 f0		bra $a2ec			bra 	_IFT_RLLoop
.a2fc					_IFT_Control:
.a2fc	c9 01		cmp #$01			cmp 	#"A"-64
.a2fe	f0 26		beq $a326			beq 	_IFT_Left
.a300	c9 04		cmp #$04			cmp 	#"D"-64
.a302	f0 2e		beq $a332			beq 	_IFT_Right
.a304	c9 17		cmp #$17			cmp 	#"W"-64
.a306	f0 36		beq $a33e			beq 	_IFT_Up
.a308	c9 13		cmp #$13			cmp 	#"S"-64
.a30a	f0 3e		beq $a34a			beq 	_IFT_Down
.a30c	c9 08		cmp #$08			cmp 	#"H"-64
.a30e	f0 09		beq $a319			beq 	_IFT_Backspace
.a310	c9 1a		cmp #$1a			cmp 	#"Z"-64
.a312	d0 d8		bne $a2ec			bne 	_IFT_RLLoop
.a314	20 fe a1	jsr $a1fe			jsr 	IFT_ClearScreen				; clear CTL-Z
.a317	80 d3		bra $a2ec			bra 	_IFT_RLLoop
.a319					_IFT_Backspace:
.a319	ad 00 02	lda $0200			lda 	IFT_XCursor 				; check not start of line.
.a31c	f0 ce		beq $a2ec			beq 	_IFT_RLLoop
.a31e	20 d3 a3	jsr $a3d3			jsr 	IF_LeftOne
.a321	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.a323	20 c8 a3	jsr $a3c8			jsr 	IF_Write
.a326					_IFT_Left:
.a326	ce 00 02	dec $0200			dec 	IFT_XCursor 				; left CTL-W
.a329	10 29		bpl $a354			bpl 	_IFT_Reposition
.a32b	a9 4f		lda #$4f			lda 	#IF_Width-1
.a32d					_IFT_SetX:
.a32d	8d 00 02	sta $0200			sta 	IFT_XCursor
.a330	80 22		bra $a354			bra 	_IFT_Reposition
.a332					_IFT_Right:
.a332	ee 00 02	inc $0200			inc 	IFT_XCursor
.a335	ad 00 02	lda $0200			lda 	IFT_XCursor
.a338	49 50		eor #$50			eor 	#IF_Width
.a33a	f0 f1		beq $a32d			beq 	_IFT_SetX
.a33c	80 16		bra $a354			bra 	_IFT_Reposition
.a33e					_IFT_Up:
.a33e	ce 01 02	dec $0201			dec 	IFT_YCursor
.a341	10 11		bpl $a354			bpl 	_IFT_Reposition
.a343	a9 18		lda #$18			lda 	#IF_Height-1
.a345					_IFT_SetY:
.a345	8d 01 02	sta $0201			sta 	IFT_YCursor
.a348	80 0a		bra $a354			bra 	_IFT_Reposition
.a34a					_IFT_Down:
.a34a	ee 01 02	inc $0201			inc 	IFT_YCursor
.a34d	ad 01 02	lda $0201			lda 	IFT_YCursor
.a350	49 19		eor #$19			eor 	#IF_Height
.a352	f0 f1		beq $a345			beq 	_IFT_SetY
.a354					_IFT_Reposition:
.a354	ad 00 02	lda $0200			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.a357	48		pha				pha
.a358	ad 01 02	lda $0201			lda 	IFT_YCursor
.a35b	20 bc a2	jsr $a2bc			jsr 	IFT_SetYPos
.a35e	68		pla				pla
.a35f	aa		tax				tax
.a360	e0 00		cpx #$00			cpx 	#0
.a362	f0 88		beq $a2ec			beq 	_IFT_RLLoop
.a364					_IFT_MoveRight:
.a364	20 ba a3	jsr $a3ba			jsr 	IF_Read
.a367	ee 00 02	inc $0200			inc 	IFT_XCursor
.a36a	ca		dex				dex
.a36b	d0 f7		bne $a364			bne 	_IFT_MoveRight
.a36d	4c ec a2	jmp $a2ec			jmp 	_IFT_RLLoop
.a370					_IFT_RLExit:
.a370	ad 01 02	lda $0201			lda 	IFT_YCursor 				; go to start of line.
.a373	20 bc a2	jsr $a2bc			jsr 	IFT_SetYPos
.a376	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.a378					_IFT_RLRead:
.a378	20 ba a3	jsr $a3ba			jsr 	IF_Read
.a37b	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.a37e	e8		inx				inx
.a37f	e0 50		cpx #$50			cpx 	#IF_Width
.a381	d0 f5		bne $a378			bne 	_IFT_RLRead
.a383					_IFT_RL_Trim:
.a383	ca		dex				dex 	 							; previous char
.a384	30 07		bmi $a38d			bmi 	_IFT_Found 					; gone too far
.a386	bd 66 02	lda $0266,x			lda 	IFT_LineBuffer,x			; go back if space
.a389	c9 20		cmp #$20			cmp 	#" "
.a38b	f0 f6		beq $a383			beq 	_IFT_RL_Trim
.a38d					_IFT_Found:
.a38d	e8		inx				inx 								; forward to non-space
.a38e	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.a390	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.a393	68		pla				pla
.a394	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.a396	a0 02		ldy #$02			ldy 	#IFT_LineBuffer >> 8
.a398	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_mega65.asm

=80					IF_Width 	= 80 							; characters across
=25					IF_Height 	= 25 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line
=6					IF_XPos 	= 6 							; current position, horizontal.
=8					IF_FarPtr 	= 8 							; far pointer (4 bytes)
=$1000					IF_Screen = $1000							; 2k screen RAM here
=$800					IF_CharSet = $800							; 2k character set (0-7F) here
.a399					IF_Home:
.a399	48		pha				pha 								; reset cursor position
.a39a	a9 00		lda #$00			lda 	#IF_Screen & $FF
.a39c	85 04		sta $04				sta 	IF_Pos
.a39e	a9 10		lda #$10			lda 	#IF_Screen >> 8
.a3a0	85 05		sta $05				sta 	IF_Pos+1
.a3a2	a9 00		lda #$00			lda 	#0
.a3a4	85 06		sta $06				sta 	IF_XPos
.a3a6	68		pla				pla
.a3a7	60		rts				rts
.a3a8					IF_NewLine:
.a3a8	48		pha				pha
.a3a9	a9 00		lda #$00			lda 	#0 							; back to start of line
.a3ab	85 06		sta $06				sta 	IF_XPos
.a3ad	18		clc				clc 								; down one line
.a3ae	a5 04		lda $04				lda 	IF_Pos
.a3b0	69 50		adc #$50			adc 	#80
.a3b2	85 04		sta $04				sta 	IF_Pos
.a3b4	90 02		bcc $a3b8			bcc 	_IF_NoCarry 				; carry through.
.a3b6	e6 05		inc $05				inc 	IF_Pos+1
.a3b8					_IF_NoCarry:
.a3b8	68		pla				pla
.a3b9	60		rts				rts
.a3ba					IF_Read:
.a3ba	5a		phy				phy 								; save current Y
.a3bb	a4 06		ldy $06				ldy 	IF_XPos 					; read character at current position
.a3bd	b1 04		lda ($04),y			lda 	(IF_Pos),y
.a3bf	49 20		eor #$20			eor 	#$20
.a3c1	18		clc				clc
.a3c2	69 20		adc #$20			adc 	#$20
.a3c4	e6 06		inc $06				inc 	IF_XPos 					; step right.
.a3c6	7a		ply				ply									; restore Y
.a3c7	60		rts				rts
.a3c8					IF_Write:
.a3c8	5a		phy				phy 								; save current Y
.a3c9	a4 06		ldy $06				ldy 	IF_XPos 					; write character at current position
.a3cb	29 bf		and #$bf			and 	#63+128 					; PETSCII
.a3cd	91 04		sta ($04),y			sta 	(IF_Pos),y
.a3cf	e6 06		inc $06				inc 	IF_XPos 					; step right.
.a3d1	7a		ply				ply									; restore Y
.a3d2	60		rts				rts
.a3d3					IF_LeftOne:
.a3d3	c6 06		dec $06				dec 	IF_XPos
.a3d5	60		rts				rts
.a3d6					IF_CheckBreak:
.a3d6	db		phz				phz
.a3d7	20 1f a4	jsr $a41f			jsr 	IF_SetupKeyAddress 			; point to keyboard
.a3da	e6 08		inc $08				inc 	IF_FarPtr 					; point to modifiers.
.a3dc	ea		nop				nop 								; read modifiers.
.a3dd	b2 08		lda ($08),z			lda 	(IF_FarPtr),z
.a3df	fb		plz				plz 								; restore Z
.a3e0	29 05		and #$05			and 	#5							; break is LeftShift+Ctrl
.a3e2	c9 05		cmp #$05			cmp 	#5
.a3e4	f0 02		beq $a3e8			beq 	_IF_CBExit
.a3e6	a9 00		lda #$00			lda 	#0
.a3e8					_IF_CBExit:
.a3e8	c9 00		cmp #$00			cmp 	#0
.a3ea	60		rts				rts
.a3eb					IF_GetKey:
.a3eb	db		phz				phz
.a3ec	20 1f a4	jsr $a41f			jsr 	IF_SetupKeyAddress
.a3ef	ea		nop				nop 								; read keyboard
.a3f0	b2 08		lda ($08),z			lda 	(IF_FarPtr),z
.a3f2	c9 14		cmp #$14			cmp 	#20
.a3f4	d0 02		bne $a3f8			bne 	_KMNo
.a3f6	a9 08		lda #$08			lda 	#"H"-64
.a3f8					_KMNo:
.a3f8	c9 91		cmp #$91			cmp 	#145
.a3fa	d0 02		bne $a3fe			bne 	_KMNo
.a3fc	a9 17		lda #$17			lda 	#"W"-64
.a3fe					_KMNo:
.a3fe	c9 11		cmp #$11			cmp 	#17
.a400	d0 02		bne $a404			bne 	_KMNo
.a402	a9 13		lda #$13			lda 	#"S"-64
.a404					_KMNo:
.a404	c9 9d		cmp #$9d			cmp 	#157
.a406	d0 02		bne $a40a			bne 	_KMNo
.a408	a9 01		lda #$01			lda 	#"A"-64
.a40a					_KMNo:
.a40a	c9 1d		cmp #$1d			cmp 	#29
.a40c	d0 02		bne $a410			bne 	_KMNo
.a40e	a9 04		lda #$04			lda 	#"D"-64
.a410					_KMNo:
.a410	c9 00		cmp #$00			cmp 	#0
.a412	f0 07		beq $a41b			beq 	_IFGKEmpty
.a414	48		pha				pha
.a415	a9 00		lda #$00			lda 	#0
.a417	ea		nop				nop
.a418	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a41a	68		pla				pla
.a41b					_IFGKEmpty:
.a41b	fb		plz				plz
.a41c	c9 00		cmp #$00			cmp 	#0 							; set Z
.a41e	60		rts				rts
.a41f					IF_SetupKeyAddress:
.a41f	a9 0f		lda #$0f			lda 	#$0F 						; set up to write to read keyboard.
.a421	85 0b		sta $0b				sta 	IF_FarPtr+3
.a423	a9 fd		lda #$fd			lda 	#$FD
.a425	85 0a		sta $0a				sta 	IF_FarPtr+2
.a427	a9 36		lda #$36			lda 	#$36
.a429	85 09		sta $09				sta 	IF_FarPtr+1
.a42b	a9 10		lda #$10			lda 	#$10
.a42d	85 08		sta $08				sta 	IF_FarPtr+0
.a42f	a3 00		ldz #$00			ldz 	#0
.a431	60		rts				rts
.a432					IF_Reset:
.a432	48		pha				pha 								; save registers
.a433	da		phx				phx
.a434	5a		phy				phy
.a435	a9 0f		lda #$0f			lda 	#$0F 						; set up to write to video system.
.a437	85 0b		sta $0b				sta 	IF_FarPtr+3
.a439	a9 fd		lda #$fd			lda 	#$FD
.a43b	85 0a		sta $0a				sta 	IF_FarPtr+2
.a43d	a9 30		lda #$30			lda 	#$30
.a43f	85 09		sta $09				sta 	IF_FarPtr+1
.a441	a9 00		lda #$00			lda 	#$00
.a443	85 08		sta $08				sta 	IF_FarPtr+0
.a445	a3 2f		ldz #$2f			ldz 	#$2F 						; address already set up
.a447	a9 47		lda #$47			lda 	#$47
.a449	ea		nop				nop
.a44a	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a44c	a3 2f		ldz #$2f			ldz 	#$2F 						; address already set up
.a44e	a9 53		lda #$53			lda 	#$53
.a450	ea		nop				nop
.a451	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a453	a3 30		ldz #$30			ldz 	#$30 						; address already set up
.a455	a9 40		lda #$40			lda 	#$40
.a457	ea		nop				nop
.a458	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a45a	a3 31		ldz #$31			ldz 	#$31 						; address already set up
.a45c	a9 c0		lda #$c0			lda 	#$80+$40
.a45e	ea		nop				nop
.a45f	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a461	a3 20		ldz #$20			ldz 	#$20 						; address already set up
.a463	a9 00		lda #$00			lda 	#0
.a465	ea		nop				nop
.a466	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a468	a3 21		ldz #$21			ldz 	#$21 						; address already set up
.a46a	a9 00		lda #$00			lda 	#0
.a46c	ea		nop				nop
.a46d	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a46f	a3 54		ldz #$54			ldz 	#$54 						; address already set up
.a471	a9 40		lda #$40			lda 	#$40
.a473	ea		nop				nop
.a474	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a476	a3 01		ldz #$01			ldz 	#$01 						; address already set up
.a478	a9 ff		lda #$ff			lda 	#$FF
.a47a	ea		nop				nop
.a47b	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a47d	a3 00		ldz #$00			ldz 	#$00 						; address already set up
.a47f	a9 ff		lda #$ff			lda 	#$FF
.a481	ea		nop				nop
.a482	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a484	a3 16		ldz #$16			ldz 	#$16 						; address already set up
.a486	a9 cc		lda #$cc			lda 	#$CC
.a488	ea		nop				nop
.a489	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a48b	a3 18		ldz #$18			ldz 	#$18 						; address already set up
.a48d	a9 42		lda #$42			lda 	#$42
.a48f	ea		nop				nop
.a490	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a492	a3 11		ldz #$11			ldz 	#$11 						; address already set up
.a494	a9 1b		lda #$1b			lda 	#$1B
.a496	ea		nop				nop
.a497	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a499	a9 00		lda #$00			lda 	#$00						; colour RAM at $1F800-1FFFF (2kb)
.a49b	85 0b		sta $0b				sta 	IF_FarPtr+3
.a49d	a9 01		lda #$01			lda 	#$01
.a49f	85 0a		sta $0a				sta 	IF_FarPtr+2
.a4a1	a9 f8		lda #$f8			lda 	#$F8
.a4a3	85 09		sta $09				sta 	IF_FarPtr+1
.a4a5	a9 00		lda #$00			lda 	#$00
.a4a7	85 08		sta $08				sta 	IF_FarPtr+0
.a4a9	a3 00		ldz #$00			ldz 	#0
.a4ab					_EXTClearColorRam:
.a4ab	a9 05		lda #$05			lda 	#5							; fill that with this colour.
.a4ad	ea		nop				nop
.a4ae	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a4b0	3b		dez				dez
.a4b1	d0 f8		bne $a4ab			bne 	_EXTClearColorRam
.a4b3	e6 09		inc $09				inc 	IF_FarPtr+1
.a4b5	d0 f4		bne $a4ab			bne 	_EXTClearColorRam
.a4b7	a2 00		ldx #$00			ldx 	#0 							; copy PET Font into memory.
.a4b9					_EXTCopyCBMFont:
.a4b9	bd fa a4	lda $a4fa,x			lda 	IF_CBMFont,x 				; +$800 uses the lower case c/set
.a4bc	9d 00 08	sta $0800,x			sta 	IF_CharSet,x
.a4bf	49 ff		eor #$ff			eor 	#$FF
.a4c1	9d 00 0c	sta $0c00,x			sta 	IF_CharSet+$400,x
.a4c4	bd fa a5	lda $a5fa,x			lda 	IF_CBMFont+$100,x
.a4c7	9d 00 09	sta $0900,x			sta 	IF_CharSet+$100,x
.a4ca	49 ff		eor #$ff			eor 	#$FF
.a4cc	9d 00 0d	sta $0d00,x			sta 	IF_CharSet+$500,x
.a4cf	bd fa a6	lda $a6fa,x			lda 	IF_CBMFont+$200,x
.a4d2	9d 00 0a	sta $0a00,x			sta 	IF_CharSet+$200,x
.a4d5	49 ff		eor #$ff			eor 	#$FF
.a4d7	9d 00 0e	sta $0e00,x			sta 	IF_CharSet+$600,x
.a4da	bd fa a7	lda $a7fa,x			lda 	IF_CBMFont+$300,x
.a4dd	9d 00 0b	sta $0b00,x			sta 	IF_CharSet+$300,x
.a4e0	49 ff		eor #$ff			eor 	#$FF
.a4e2	9d 00 0f	sta $0f00,x			sta 	IF_CharSet+$700,x
.a4e5	ca		dex				dex
.a4e6	d0 d1		bne $a4b9			bne 	_EXTCopyCBMFont
.a4e8	a9 3b		lda #$3b			lda 	#$3F-4  					; puts ROM back in the map (the -4)
.a4ea	85 01		sta $01				sta 	$01
.a4ec	a9 00		lda #$00			lda 	#$00						; do not map bytes 0000-7FFF
.a4ee	a2 00		ldx #$00			ldx 	#$00						; (so we use the RAM physically at $0000-$7FFF)
.a4f0	a0 00		ldy #$00			ldy 	#$00 						; 8000-FFFF offset by $200. The lower 8 bits are $00
.a4f2	a3 f2		ldz #$f2			ldz 	#$F2 						; so this is an actual offset of $20000. So the space at
.a4f4	5c		map				map
.a4f5	ea		nop				eom
.a4f6	7a		ply				ply 								; restore and exit.
.a4f7	fa		plx				plx
.a4f8	68		pla				pla
.a4f9	60		rts				rts
.a4fa					IF_CBMFont:
>a4fa	1c 22 4a 56 4c 20 1e 00				.binary "pet-font.bin"
>a502	18 24 42 7e 42 42 42 00 7c 22 22 3c 22 22 7c 00
>a512	1c 22 40 40 40 22 1c 00 78 24 22 22 22 24 78 00
>a522	7e 40 40 78 40 40 7e 00 7e 40 40 78 40 40 40 00
>a532	1c 22 40 4e 42 22 1c 00 42 42 42 7e 42 42 42 00
>a542	1c 08 08 08 08 08 1c 00 0e 04 04 04 04 44 38 00
>a552	42 44 48 70 48 44 42 00 40 40 40 40 40 40 7e 00
>a562	42 66 5a 5a 42 42 42 00 42 62 52 4a 46 42 42 00
>a572	18 24 42 42 42 24 18 00 7c 42 42 7c 40 40 40 00
>a582	18 24 42 42 4a 24 1a 00 7c 42 42 7c 48 44 42 00
>a592	3c 42 40 3c 02 42 3c 00 3e 08 08 08 08 08 08 00
>a5a2	42 42 42 42 42 42 3c 00 42 42 42 24 24 18 18 00
>a5b2	42 42 42 5a 5a 66 42 00 42 42 24 18 24 42 42 00
>a5c2	22 22 22 1c 08 08 08 00 7e 02 04 18 20 40 7e 00
>a5d2	3c 20 20 20 20 20 3c 00 00 40 20 10 08 04 02 00
>a5e2	3c 04 04 04 04 04 3c 00 00 08 1c 2a 08 08 08 08
>a5f2	00 00 10 20 7f 20 10 00 00 00 00 00 00 00 00 00
>a602	08 08 08 08 00 00 08 00 24 24 24 00 00 00 00 00
>a612	24 24 7e 24 7e 24 24 00 08 1e 28 1c 0a 3c 08 00
>a622	00 62 64 08 10 26 46 00 30 48 48 30 4a 44 3a 00
>a632	04 08 10 00 00 00 00 00 04 08 10 10 10 08 04 00
>a642	20 10 08 08 08 10 20 00 08 2a 1c 3e 1c 2a 08 00
>a652	00 08 08 3e 08 08 00 00 00 00 00 00 00 08 08 10
>a662	00 00 00 7e 00 00 00 00 00 00 00 00 00 18 18 00
>a672	00 02 04 08 10 20 40 00 3c 42 46 5a 62 42 3c 00
>a682	08 18 28 08 08 08 3e 00 3c 42 02 0c 30 40 7e 00
>a692	3c 42 02 1c 02 42 3c 00 04 0c 14 24 7e 04 04 00
>a6a2	7e 40 78 04 02 44 38 00 1c 20 40 7c 42 42 3c 00
>a6b2	7e 42 04 08 10 10 10 00 3c 42 42 3c 42 42 3c 00
>a6c2	3c 42 42 3e 02 04 38 00 00 00 08 00 00 08 00 00
>a6d2	00 00 08 00 00 08 08 10 0e 18 30 60 30 18 0e 00
>a6e2	00 00 7e 00 7e 00 00 00 70 18 0c 06 0c 18 70 00
>a6f2	3c 42 02 0c 10 00 10 00 00 00 00 00 ff 00 00 00
>a702	08 1c 3e 7f 7f 1c 3e 00 10 10 10 10 10 10 10 10
>a712	00 00 00 ff 00 00 00 00 00 00 ff 00 00 00 00 00
>a722	00 ff 00 00 00 00 00 00 00 00 00 00 00 ff 00 00
>a732	20 20 20 20 20 20 20 20 04 04 04 04 04 04 04 04
>a742	00 00 00 00 e0 10 08 08 08 08 08 04 03 00 00 00
>a752	08 08 08 10 e0 00 00 00 80 80 80 80 80 80 80 ff
>a762	80 40 20 10 08 04 02 01 01 02 04 08 10 20 40 80
>a772	ff 80 80 80 80 80 80 80 ff 01 01 01 01 01 01 01
>a782	00 3c 7e 7e 7e 7e 3c 00 00 00 00 00 00 00 ff 00
>a792	36 7f 7f 7f 3e 1c 08 00 40 40 40 40 40 40 40 40
>a7a2	00 00 00 00 03 04 08 08 81 42 24 18 18 24 42 81
>a7b2	00 3c 42 42 42 42 3c 00 08 1c 2a 77 2a 08 08 00
>a7c2	02 02 02 02 02 02 02 02 08 1c 3e 7f 3e 1c 08 00
>a7d2	08 08 08 08 ff 08 08 08 a0 50 a0 50 a0 50 a0 50
>a7e2	08 08 08 08 08 08 08 08 00 00 01 3e 54 14 14 00
>a7f2	ff 7f 3f 1f 0f 07 03 01 00 00 00 00 00 00 00 00
>a802	f0 f0 f0 f0 f0 f0 f0 f0 00 00 00 00 ff ff ff ff
>a812	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff
>a822	80 80 80 80 80 80 80 80 aa 55 aa 55 aa 55 aa 55
>a832	01 01 01 01 01 01 01 01 00 00 00 00 aa 55 aa 55
>a842	ff fe fc f8 f0 e0 c0 80 03 03 03 03 03 03 03 03
>a852	08 08 08 08 0f 08 08 08 00 00 00 00 0f 0f 0f 0f
>a862	08 08 08 08 0f 00 00 00 00 00 00 00 f8 08 08 08
>a872	00 00 00 00 00 00 ff ff 00 00 00 00 0f 08 08 08
>a882	08 08 08 08 ff 00 00 00 00 00 00 00 ff 08 08 08
>a892	08 08 08 08 f8 08 08 08 c0 c0 c0 c0 c0 c0 c0 c0
>a8a2	e0 e0 e0 e0 e0 e0 e0 e0 07 07 07 07 07 07 07 07
>a8b2	ff ff 00 00 00 00 00 00 ff ff ff 00 00 00 00 00
>a8c2	00 00 00 00 00 ff ff ff 01 01 01 01 01 01 01 ff
>a8d2	00 00 00 00 f0 f0 f0 f0 0f 0f 0f 0f 00 00 00 00
>a8e2	08 08 08 08 f8 00 00 00 f0 f0 f0 f0 00 00 00 00
>a8f2	f0 f0 f0 f0 0f 0f 0f 0f 1c 22 4a 56 4c 20 1e 00
>a902	18 24 42 7e 42 42 42 00 7c 22 22 3c 22 22 7c 00
>a912	1c 22 40 40 40 22 1c 00 78 24 22 22 22 24 78 00
>a922	7e 40 40 78 40 40 7e 00 7e 40 40 78 40 40 40 00
>a932	1c 22 40 4e 42 22 1c 00 42 42 42 7e 42 42 42 00
>a942	1c 08 08 08 08 08 1c 00 0e 04 04 04 04 44 38 00
>a952	42 44 48 70 48 44 42 00 40 40 40 40 40 40 7e 00
>a962	42 66 5a 5a 42 42 42 00 42 62 52 4a 46 42 42 00
>a972	18 24 42 42 42 24 18 00 7c 42 42 7c 40 40 40 00
>a982	18 24 42 42 4a 24 1a 00 7c 42 42 7c 48 44 42 00
>a992	3c 42 40 3c 02 42 3c 00 3e 08 08 08 08 08 08 00
>a9a2	42 42 42 42 42 42 3c 00 42 42 42 24 24 18 18 00
>a9b2	42 42 42 5a 5a 66 42 00 42 42 24 18 24 42 42 00
>a9c2	22 22 22 1c 08 08 08 00 7e 02 04 18 20 40 7e 00
>a9d2	3c 20 20 20 20 20 3c 00 00 40 20 10 08 04 02 00
>a9e2	3c 04 04 04 04 04 3c 00 00 08 1c 2a 08 08 08 08
>a9f2	00 00 10 20 7f 20 10 00 00 00 00 00 00 00 00 00
>aa02	08 08 08 08 00 00 08 00 24 24 24 00 00 00 00 00
>aa12	24 24 7e 24 7e 24 24 00 08 1e 28 1c 0a 3c 08 00
>aa22	00 62 64 08 10 26 46 00 30 48 48 30 4a 44 3a 00
>aa32	04 08 10 00 00 00 00 00 04 08 10 10 10 08 04 00
>aa42	20 10 08 08 08 10 20 00 08 2a 1c 3e 1c 2a 08 00
>aa52	00 08 08 3e 08 08 00 00 00 00 00 00 00 08 08 10
>aa62	00 00 00 7e 00 00 00 00 00 00 00 00 00 18 18 00
>aa72	00 02 04 08 10 20 40 00 3c 42 46 5a 62 42 3c 00
>aa82	08 18 28 08 08 08 3e 00 3c 42 02 0c 30 40 7e 00
>aa92	3c 42 02 1c 02 42 3c 00 04 0c 14 24 7e 04 04 00
>aaa2	7e 40 78 04 02 44 38 00 1c 20 40 7c 42 42 3c 00
>aab2	7e 42 04 08 10 10 10 00 3c 42 42 3c 42 42 3c 00
>aac2	3c 42 42 3e 02 04 38 00 00 00 08 00 00 08 00 00
>aad2	00 00 08 00 00 08 08 10 0e 18 30 60 30 18 0e 00
>aae2	00 00 7e 00 7e 00 00 00 70 18 0c 06 0c 18 70 00
>aaf2	3c 42 02 0c 10 00 10 00 00 00 00 00 ff 00 00 00
>ab02	00 00 38 04 3c 44 3a 00 40 40 5c 62 42 62 5c 00
>ab12	00 00 3c 42 40 42 3c 00 02 02 3a 46 42 46 3a 00
>ab22	00 00 3c 42 7e 40 3c 00 0c 12 10 7c 10 10 10 00
>ab32	00 00 3a 46 46 3a 02 3c 40 40 5c 62 42 42 42 00
>ab42	08 00 18 08 08 08 1c 00 04 00 0c 04 04 04 44 38
>ab52	40 40 44 48 50 68 44 00 18 08 08 08 08 08 1c 00
>ab62	00 00 76 49 49 49 49 00 00 00 5c 62 42 42 42 00
>ab72	00 00 3c 42 42 42 3c 00 00 00 5c 62 62 5c 40 40
>ab82	00 00 3a 46 46 3a 02 02 00 00 5c 62 40 40 40 00
>ab92	00 00 3e 40 3c 02 7c 00 10 10 7c 10 10 12 0c 00
>aba2	00 00 42 42 42 46 3a 00 00 00 42 42 42 24 18 00
>abb2	00 00 41 49 49 49 36 00 00 00 42 24 18 24 42 00
>abc2	00 00 42 42 46 3a 02 3c 00 00 7e 04 18 20 7e 00
>abd2	08 08 08 08 ff 08 08 08 a0 50 a0 50 a0 50 a0 50
>abe2	08 08 08 08 08 08 08 08 cc cc 33 33 cc cc 33 33
>abf2	cc 66 33 99 cc 66 33 99 00 00 00 00 00 00 00 00
>ac02	f0 f0 f0 f0 f0 f0 f0 f0 00 00 00 00 ff ff ff ff
>ac12	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff
>ac22	80 80 80 80 80 80 80 80 aa 55 aa 55 aa 55 aa 55
>ac32	01 01 01 01 01 01 01 01 00 00 00 00 aa 55 aa 55
>ac42	99 33 66 cc 99 33 66 cc 03 03 03 03 03 03 03 03
>ac52	08 08 08 08 0f 08 08 08 00 00 00 00 0f 0f 0f 0f
>ac62	08 08 08 08 0f 00 00 00 00 00 00 00 f8 08 08 08
>ac72	00 00 00 00 00 00 ff ff 00 00 00 00 0f 08 08 08
>ac82	08 08 08 08 ff 00 00 00 00 00 00 00 ff 08 08 08
>ac92	08 08 08 08 f8 08 08 08 c0 c0 c0 c0 c0 c0 c0 c0
>aca2	e0 e0 e0 e0 e0 e0 e0 e0 07 07 07 07 07 07 07 07
>acb2	ff ff 00 00 00 00 00 00 ff ff ff 00 00 00 00 00
>acc2	00 00 00 00 00 ff ff ff 01 02 44 48 50 60 40 00
>acd2	00 00 00 00 f0 f0 f0 f0 0f 0f 0f 0f 00 00 00 00
>ace2	08 08 08 08 f8 00 00 00 f0 f0 f0 f0 00 00 00 00
>acf2	f0 f0 f0 f0 0f 0f 0f 0f

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.acfa					TIM_Error:
.acfa	20 27 a2	jsr $a227			jsr 	IFT_UpLine 					; go up one line.
.acfd	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.acff	80 02		bra $ad03			bra 	TIM_ShowPrompt
.ad01					TIM_NewCommand:
.ad01	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.ad03					TIM_ShowPrompt:
.ad03	20 33 a2	jsr $a233			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.ad06	20 eb a2	jsr $a2eb			jsr 	IFT_ReadLine	 			; get character, go to next line
.ad09	20 4d a2	jsr $a24d			jsr 	IFT_NewLine					; go to next line.
.ad0c	86 10		stx $10				stx 	zTemp1 						; save line read address
.ad0e	84 11		sty $11				sty 	zTemp1+1
.ad10	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.ad12	b1 10		lda ($10),y			lda 	(zTemp1),y
.ad14	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.ad16	d0 01		bne $ad19			bne 	TIM_NotDot
.ad18	c8		iny				iny
.ad19					TIM_NotDot:
.ad19	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.ad1b	c9 52		cmp #$52			cmp 	#"R"						; show registers
.ad1d	f0 6e		beq $ad8d			beq 	TIM_ShowRegisters
.ad1f	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.ad21	f0 12		beq $ad35			beq 	TIM_ShowMemory
.ad23	c9 47		cmp #$47			cmp 	#"G"						; execute
.ad25	f0 49		beq $ad70			beq 	TIM_Execute
.ad27	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.ad29	f0 07		beq $ad32			beq 	TIM_GoLoadMemory
.ad2b	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.ad2d	d0 cb		bne $acfa			bne 	TIM_Error
.ad2f	4c b2 ae	jmp $aeb2			jmp 	TIM_UpdateRegisters
.ad32					TIM_GoLoadMemory:
.ad32	4c dd ae	jmp $aedd			jmp 	TIM_LoadMemory
.ad35					TIM_ShowMemory:
.ad35	20 2b ae	jsr $ae2b			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.ad38	b0 c0		bcs $acfa			bcs 	TIM_Error
.ad3a	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.ad3c	85 12		sta $12				sta 	zTemp2
.ad3e	a5 15		lda $15				lda 	zTemp3+1
.ad40	85 13		sta $13				sta 	zTemp2+1
.ad42	20 2b ae	jsr $ae2b			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.ad45	90 08		bcc $ad4f			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.ad47	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.ad49	85 14		sta $14				sta 	zTemp3
.ad4b	a5 13		lda $13				lda 	zTemp2+1
.ad4d	85 15		sta $15				sta 	zTemp3+1
.ad4f					_TIMSM_Start:
.ad4f	20 03 ae	jsr $ae03			jsr 	TIM_WriteLine 				; write one line of hex out
.ad52	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.ad54	18		clc				clc
.ad55	69 10		adc #$10			adc 	#16
.ad57	85 12		sta $12				sta 	zTemp2
.ad59	90 02		bcc $ad5d			bcc 	_TIMSM_NoCarry
.ad5b	e6 13		inc $13				inc 	zTemp2+1
.ad5d					_TIMSM_NoCarry:
.ad5d	20 d6 a3	jsr $a3d6			jsr 	IF_CheckBreak 				; check CTL+C
.ad60	d0 0b		bne $ad6d			bne 	_TIMSM_Ends 				; if pressed break out.
.ad62	38		sec				sec 								; check past the end address in zTemp3
.ad63	a5 14		lda $14				lda 	zTemp3
.ad65	e5 12		sbc $12				sbc 	zTemp2
.ad67	a5 15		lda $15				lda 	zTemp3+1
.ad69	e5 13		sbc $13				sbc 	zTemp2+1
.ad6b	10 e2		bpl $ad4f			bpl 	_TIMSM_Start
.ad6d					_TIMSM_Ends:
.ad6d	4c 01 ad	jmp $ad01			jmp 	TIM_NewCommand
.ad70					TIM_Execute:
.ad70	20 2b ae	jsr $ae2b			jsr 	TIM_GetHex 					; get the execute address
.ad73	b0 85		bcs $acfa			bcs 	TIM_Error 					; not legitimate
.ad75	ae 36 04	ldx $0436			ldx 	TIM_SP 						; set up SP
.ad78	9a		txs				txs
.ad79	ad 31 04	lda $0431			lda 	TIM_SR 						; Status for PLP
.ad7c	48		pha				pha
.ad7d	ad 32 04	lda $0432			lda 	TIM_A 						; restore AXYZ
.ad80	ae 33 04	ldx $0433			ldx 	TIM_X
.ad83	ac 34 04	ldy $0434			ldy 	TIM_Y
.ad86	ab 35 04	ldz $0435			ldz 	TIM_Z
.ad89	28		plp				plp 								; and PS Byte.
.ad8a	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.ad8d					TIM_Start:
.ad8d					TIM_ShowRegisters:
.ad8d	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.ad90	8d 30 04	sta $0430			sta 	TIM_IRQ+1
.ad93	ad ff ff	lda $ffff			lda 	$FFFF
.ad96	8d 2f 04	sta $042f			sta 	TIM_IRQ
.ad99	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.ad9b					_TIMSR_Text:
.ad9b	bd c7 ad	lda $adc7,x			lda 	_TIMSR_Label,x
.ad9e	20 33 a2	jsr $a233			jsr 	IFT_PrintCharacter
.ada1	e8		inx				inx
.ada2	e0 23		cpx #$23			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.ada4	d0 f5		bne $ad9b			bne 	_TIMSR_Text
.ada6	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.ada8					_TIMSR_Skip:
.ada8	e8		inx				inx
.ada9					_TIMSR_LoopSpace:
.ada9	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.adab	b0 04		bcs $adb1			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.adad	8a		txa				txa
.adae	4a		lsr a				lsr 	a
.adaf	b0 05		bcs $adb6			bcs 	_TIMSR_NoSpace
.adb1					_TIMSR_Space:
.adb1	a9 20		lda #$20			lda 	#" "
.adb3	20 33 a2	jsr $a233			jsr 	IFT_PrintCharacter
.adb6					_TIMSR_NoSpace:
.adb6	bd 2d 04	lda $042d,x			lda 	TIM_PC,x 					; output hex value.
.adb9	20 ea ad	jsr $adea			jsr 	TIM_WriteHex
.adbc	e8		inx				inx
.adbd	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.adbf	d0 e8		bne $ada9			bne 	_TimSR_LoopSpace
.adc1	20 4d a2	jsr $a24d			jsr 	IFT_NewLine 				; new line
.adc4	4c 01 ad	jmp $ad01			jmp	 	TIM_NewCommand 				; new command.
.adc7					_TIMSR_Label:
>adc7	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>adcf	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>addf	52
>ade0	20 5a 52					.text 	" ZR"
>ade3	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.adea					_TIMSR_LabelEnd:
.adea					TIM_WriteHex:
.adea	48		pha				pha 								; save A
.adeb	4a		lsr a				lsr 	a 							; shift MSB->LSB
.adec	4a		lsr a				lsr 	a
.aded	4a		lsr a				lsr 	a
.adee	4a		lsr a				lsr 	a
.adef	20 f3 ad	jsr $adf3			jsr 	_TIMWH_Nibble 				; print MSB
.adf2	68		pla				pla 								; restore and print LSB
.adf3					_TIMWH_Nibble:
.adf3	48		pha				pha
.adf4	29 0f		and #$0f			and 	#15 						; mask out
.adf6	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.adf8	90 02		bcc $adfc			bcc 	_TIMWHNoLetter
.adfa	69 06		adc #$06			adc 	#6
.adfc					_TIMWHNoLetter:
.adfc	69 30		adc #$30			adc 	#48
.adfe	20 33 a2	jsr $a233			jsr 	IFT_PrintCharacter 			; print it out.
.ae01	68		pla				pla
.ae02	60		rts				rts
.ae03					TIM_WriteLine:
.ae03	a9 2e		lda #$2e			lda 	#"." 						; prompt
.ae05	20 33 a2	jsr $a233			jsr 	IFT_PrintCharacter
.ae08	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.ae0a	20 33 a2	jsr $a233			jsr 	IFT_PrintCharacter
.ae0d	a5 13		lda $13				lda 	zTemp2+1 					; write address
.ae0f	20 ea ad	jsr $adea			jsr 	TIM_WriteHex
.ae12	a5 12		lda $12				lda 	zTemp2
.ae14	20 ea ad	jsr $adea			jsr 	TIM_WriteHex
.ae17	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.ae19					_TIMWL_Loop:
.ae19	a9 20		lda #$20			lda 	#" "
.ae1b	20 33 a2	jsr $a233			jsr 	IFT_PrintCharacter
.ae1e	b1 12		lda ($12),y			lda 	(zTemp2),y
.ae20	20 ea ad	jsr $adea			jsr 	TIM_WriteHex
.ae23	c8		iny				iny
.ae24	c0 10		cpy #$10			cpy 	#16
.ae26	d0 f1		bne $ae19			bne 	_TIMWL_Loop
.ae28	4c 4d a2	jmp $a24d			jmp 	IFT_NewLine 				; new line and exit
.ae2b					TIM_GetHex:
.ae2b	c8		iny				iny
.ae2c	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.ae2e	c9 20		cmp #$20			cmp 	#32
.ae30	f0 f9		beq $ae2b			beq 	TIM_GetHex
.ae32	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.ae34	f0 f5		beq $ae2b			beq 	TIM_GetHex
.ae36	20 5f ae	jsr $ae5f			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.ae39	b0 23		bcs $ae5e			bcs 	_TIMGH_Exit					; if first bad then exit now.
.ae3b	a9 00		lda #$00			lda 	#0 							; zero result
.ae3d	85 14		sta $14				sta 	zTemp3
.ae3f	85 15		sta $15				sta 	zTemp3+1
.ae41					_TIM_GHLoop:
.ae41	20 5f ae	jsr $ae5f			jsr 	TIM_GetHexCharacter 		; get next character
.ae44	b0 17		bcs $ae5d			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.ae46	c8		iny				iny 								; skip over it.
.ae47	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.ae49	26 15		rol $15				rol 	zTemp3+1
.ae4b	06 14		asl $14				asl 	zTemp3 						; now x 2
.ae4d	26 15		rol $15				rol 	zTemp3+1
.ae4f	06 14		asl $14				asl 	zTemp3						; now x 4
.ae51	26 15		rol $15				rol 	zTemp3+1
.ae53	06 14		asl $14				asl 	zTemp3 						; now x 8
.ae55	26 15		rol $15				rol 	zTemp3+1
.ae57	05 14		ora $14				ora 	zTemp3 						; OR result in
.ae59	85 14		sta $14				sta 	zTemp3
.ae5b	80 e4		bra $ae41			bra 	_TIM_GHLoop 				; loop round again.
.ae5d					_TIMGH_Okay:
.ae5d	18		clc				clc
.ae5e					_TIMGH_Exit:
.ae5e	60		rts				rts
.ae5f					TIM_GetHexCharacter:
.ae5f	b1 10		lda ($10),y			lda 	(zTemp1),y
.ae61	38		sec				sec
.ae62	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.ae64	90 0e		bcc $ae74			bcc 	_TIM_GHCFail
.ae66	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.ae68	90 0b		bcc $ae75			bcc 	_TIM_GHCExit
.ae6a	c9 11		cmp #$11			cmp 	#65-48						; < A
.ae6c	90 06		bcc $ae74			bcc		_TIM_GHCFail
.ae6e	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.ae70	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.ae72	90 01		bcc $ae75			bcc		_TIM_GHCExit
.ae74					_TIM_GHCFail:
.ae74	38		sec				sec
.ae75					_TIM_GHCExit:
.ae75	60		rts				rts
.ae76					TIM_BreakVector:
.ae76	da		phx				phx									; save X/A on stack
.ae77	48		pha				pha
.ae78	ba		tsx				tsx 								; X points to S
.ae79	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.ae7c	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.ae7e	d0 03		bne $ae83			bne 	_TIMBreak					; if set, it's BRK
.ae80	68		pla				pla 								; abandon routine.
.ae81	fa		plx				plx
.ae82	40		rti				rti
.ae83					_TIMBreak:
.ae83	68		pla				pla 								; save A X Y and maybe Z
.ae84	8d 32 04	sta $0432			sta 	TIM_A
.ae87	fa		plx				plx
.ae88	8e 33 04	stx $0433			stx 	TIM_X
.ae8b	8c 34 04	sty $0434			sty 	TIM_Y
.ae8e	9c 35 04	stz $0435			stz 	TIM_Z
.ae91	68		pla				pla 								; get Status Register
.ae92	8d 31 04	sta $0431			sta 	TIM_SR
.ae95	68		pla				pla
.ae96	8d 2e 04	sta $042e			sta 	TIM_PC+1 					; save calling address
.ae99	68		pla				pla
.ae9a	8d 2d 04	sta $042d			sta 	TIM_PC 						; high byte
.ae9d	ad 2e 04	lda $042e			lda 	TIM_PC+1 					; dec PC to point right.
.aea0	d0 03		bne $aea5			bne 	_TIMDecrement 				; brk bumps it.
.aea2	ce 2d 04	dec $042d			dec 	TIM_PC
.aea5					_TIMDecrement:
.aea5	ce 2e 04	dec $042e			dec 	TIM_PC+1
.aea8	ba		tsx				tsx 								; and copy SP
.aea9	8e 36 04	stx $0436			stx 	TIM_SP
.aeac	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.aeae	9a		txs				txs
.aeaf	4c 8d ad	jmp $ad8d			jmp 	TIM_Start 					; and start up TIM monitor.
.aeb2					TIM_UpdateRegisters:
.aeb2	20 2b ae	jsr $ae2b			jsr 	TIM_GetHex 					; PC
.aeb5	b0 23		bcs $aeda			bcs 	_TIMURFail
.aeb7	a5 14		lda $14				lda 	zTemp3
.aeb9	8d 2e 04	sta $042e			sta 	Tim_PC+1
.aebc	a5 15		lda $15				lda 	zTemp3+1
.aebe	8d 2d 04	sta $042d			sta 	Tim_PC
.aec1	20 2b ae	jsr $ae2b			jsr 	TIM_GetHex 					; ignore IRQ
.aec4	b0 14		bcs $aeda			bcs 	_TIMURFail
.aec6	a2 00		ldx #$00			ldx 	#0
.aec8					_TIM_URLoop:
.aec8	20 2b ae	jsr $ae2b			jsr 	TIM_GetHex 					; registers
.aecb	b0 0d		bcs $aeda			bcs 	_TIMURFail
.aecd	a5 14		lda $14				lda 	zTemp3
.aecf	9d 31 04	sta $0431,x			sta 	Tim_SR,x
.aed2	e8		inx				inx
.aed3	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.aed5	d0 f1		bne $aec8			bne 	_TIM_URLoop
.aed7	4c 01 ad	jmp $ad01			jmp 	TIM_NewCommand
.aeda					_TIMURFail:
.aeda	4c fa ac	jmp $acfa			jmp 	TIM_Error
.aedd					TIM_LoadMemory:
.aedd	20 2b ae	jsr $ae2b			jsr 	TIM_GetHex 					; target address => zTemp2
.aee0	a5 14		lda $14				lda 	zTemp3
.aee2	85 12		sta $12				sta 	zTemp2
.aee4	a5 15		lda $15				lda 	zTemp3+1
.aee6	85 13		sta $13				sta 	zTemp2+1
.aee8					_TIM_LMLoop:
.aee8	20 2b ae	jsr $ae2b			jsr 	TIM_GetHex 					; next byte ?
.aeeb	b0 0e		bcs $aefb			bcs 	_TIMLMDone 					; no more
.aeed	a2 00		ldx #$00			ldx 	#0							; write out.
.aeef	a5 14		lda $14				lda 	zTemp3
.aef1	81 12		sta ($12,x)			sta 	(zTemp2,x)
.aef3	e6 12		inc $12				inc 	zTemp2 						; bump address
.aef5	d0 f1		bne $aee8			bne 	_TIM_LMLoop
.aef7	e6 13		inc $13				inc 	zTemp2+1
.aef9	80 ed		bra $aee8			bra 	_TIM_LMLoop
.aefb					_TIMLMDone:
.aefb	4c 01 ad	jmp $ad01			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Return to file: basic.asm

.aefe	80 fe		bra $aefe	_halt:	bra 		_halt
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	f2 a1						.word 	StartROM
>fffe	76 ae					.word TIM_BreakVector

;******  End of listing
