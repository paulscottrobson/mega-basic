
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Sun Aug 25 15:34:36 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="4510"					cpu = "4510"
="mega65"				hardware = "mega65"
=1					exitonend = 1
=1					autorun = 1
=1					loadtest = 1
=1					hasfloat = 1
=1					hasinteger = 1
=253					maxstring = 253

;******  Processing file: modules/float/fpmacros.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/mega65/src_mega65.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0020					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0022					zVarDataPtr: .word ? 						; position of variable data.
>0024					zVarType: 	.byte ? 						; type of data (token)
>0025					zNullString:.byte ? 						; represents a NULL string.
>0200					IFT_XCursor:.byte ?							; current logical position on screen
>0201					IFT_YCursor:.byte ?
>0202					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0266					IFT_LineBuffer: .fill 100 					; line input buffer.
>0300					UserVector .fill 4 							; USR(x) calls this.
>0304					LocalVector .fill 4 						; Indirect calls call this.
>0308					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>030c					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>030d					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=782					XS2_Mantissa = XS_Mantissa+XS_Size
=786					XS2_Exponent = XS_Exponent+XS_Size
=787					XS2_Type = XS_Type+XS_Size
=788					XS3_Mantissa = XS_Mantissa+XS_Size*2
=792					XS3_Exponent = XS_Exponent+XS_Size*2
=793					XS3_Type = XS_Type+XS_Size*2
>0400					StringPtr:	.word ? 						; Top of free memory (for string allocation)
>0402					VarMemPtr: 	.word ?							; Bottom of free memory (for variables)
>0404					NumBufX 	.byte 	?						; buffer index position
>0405					Num_Buffer	.fill 	32 						; buffer for numeric conversions
=6					HashTableCount = 6 							; there are 6 hash tables, in token order.
=8					HashTableSize = 8 							; each hash table as 8 links.
.0425					HashTableBase:
>0425								.fill	HashTableCount * HashTableSize * 2
.0485					HashTableEnd:
=$405					Var_Buffer 	= Num_Buffer 					; buffer for variable name (same space)
>0485					Var_Type    .byte ? 						; type of variable (as a type token)
>0486					Var_Hash 	.byte ? 						; hash of identifier name.
>0487					Var_Length 	.byte ? 						; length of variable name
>0488					Var_HashAddress .byte ?						; low byte of hash table entry.
>0489					Var_DataSize .byte ?						; size of one element.
>048a					NumSuppress	.byte 	?						; leading zero suppression flag
>048b					NumConvCount .byte 	? 						; count for conversions.
>048c					ExpTemp:	.byte ?							; Working temp for exponents.
>048d					ExpCount:	.byte ? 						; Count of decimal exponents.
>048e					SignCount:	.byte ?							; Integer Divide Sign Counts.
>048f					TempStringWriteIndex: .byte ? 				; Write offset.
>0490					ValSign: 	.byte ? 						; sign flag for val()
>0491					SliceStart:	.byte ? 						; string slice parts
>0492					SliceCount:	.byte ?
>0493					RandomSeed:	.dword ? 						; Random seed.
>0497					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>0499					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>049b					Tim_SR:		.byte ? 						; Processor Status
>049c					Tim_A:		.byte ? 						; Processor Registers
>049d					Tim_X:		.byte ?
>049e					Tim_Y:		.byte ?
>049f					Tim_Z:		.byte ?
>04a0					Tim_SP:		.word ?							; Stack Pointer (just in cases)

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/mega65.asm

=$7000					HighMemory = $7000
=$4000					VariableMemory = $4000
.8000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testing.src

>8000	1f 02 00 d9 bb 8b 41 70			.byte	$1f,$02,$00,$d9,$bb,$8b,$41,$70
>8008	4b 7e fd 04 30 39 8d 8b			.byte	$4b,$7e,$fd,$04,$30,$39,$8d,$8b
>8010	41 70 4b 7e fd 04 30 39			.byte	$41,$70,$4b,$7e,$fd,$04,$30,$39
>8018	bc 84 41 fd 03 30 00 15			.byte	$bc,$84,$41,$fd,$03,$30,$00,$15
>8020	03 00 d9 bb 8b 41 55 6d			.byte	$03,$00,$d9,$bb,$8b,$41,$55,$6d
>8028	57 89 8b 41 55 6d 57 bc			.byte	$57,$89,$8b,$41,$55,$6d,$57,$bc
>8030	84 8b 41 00 16 04 00 d9			.byte	$84,$8b,$41,$00,$16,$04,$00,$d9
>8038	bb 8b 54 76 46 82 43 43			.byte	$bb,$8b,$54,$76,$46,$82,$43,$43
>8040	40 4b bc 84 8b 43 57 76			.byte	$40,$4b,$bc,$84,$8b,$43,$57,$76
>8048	4f 00 10 05 00 d9 9a 42			.byte	$4f,$00,$10,$05,$00,$d9,$9a,$42
>8050	7b 78 57 bc 84 42 7b 78			.byte	$7b,$78,$57,$bc,$84,$42,$7b,$78
>8058	57 00 18 06 00 d9 a0 fe			.byte	$57,$00,$18,$06,$00,$d9,$a0,$fe
>8060	07 61 77 61 74 6c bd 47			.byte	$07,$61,$77,$61,$74,$6c,$bd,$47
>8068	bc 84 fe 07 61 77 61 74			.byte	$bc,$84,$fe,$07,$61,$77,$61,$74
>8070	6c 00 1a 07 00 d9 bb 43			.byte	$6c,$00,$1a,$07,$00,$d9,$bb,$43
>8078	56 64 4b fd 04 37 36 88			.byte	$56,$64,$4b,$fd,$04,$37,$36,$88
>8080	43 56 64 4b fd 04 37 36			.byte	$43,$56,$64,$4b,$fd,$04,$37,$36
>8088	bc 84 40 00 12 08 00 d9			.byte	$bc,$84,$40,$00,$12,$08,$00,$d9
>8090	bb 8b 63 72 7a 85 8b 63			.byte	$bb,$8b,$63,$72,$7a,$85,$8b,$63
>8098	72 7a bc 84 40 00 14 09			.byte	$72,$7a,$bc,$84,$40,$00,$14,$09
>80a0	00 d9 bb 41 5e 74 40 82			.byte	$00,$d9,$bb,$41,$5e,$74,$40,$82
>80a8	41 79 40 48 bc 84 67 74			.byte	$41,$79,$40,$48,$bc,$84,$67,$74
>80b0	48 00 0a 0a 00 d9 b3 40			.byte	$48,$00,$0a,$0a,$00,$d9,$b3,$40
>80b8	bc 84 40 00 1f 0b 00 d9			.byte	$bc,$84,$40,$00,$1f,$0b,$00,$d9
>80c0	a1 fe 0b 6d 70 71 77 66			.byte	$a1,$fe,$0b,$6d,$70,$71,$77,$66
>80c8	64 77 68 74 bd 48 bc 84			.byte	$64,$77,$68,$74,$bd,$48,$bc,$84
>80d0	fe 0a 70 71 77 66 64 77			.byte	$fe,$0a,$70,$71,$77,$66,$64,$77
>80d8	68 74 00 1a 0c 00 d9 bb			.byte	$68,$74,$00,$1a,$0c,$00,$d9,$bb
>80e0	8b 43 4e 42 59 fd 03 38			.byte	$8b,$43,$4e,$42,$59,$fd,$03,$38
>80e8	85 8b 43 4e 42 59 fd 03			.byte	$85,$8b,$43,$4e,$42,$59,$fd,$03
>80f0	38 bc 84 40 00 12 0d 00			.byte	$38,$bc,$84,$40,$00,$12,$0d,$00
>80f8	d9 bb 8b 53 63 71 86 8b			.byte	$d9,$bb,$8b,$53,$63,$71,$86,$8b
>8100	53 63 71 bc 84 40 00 0f			.byte	$53,$63,$71,$bc,$84,$40,$00,$0f
>8108	0e 00 d9 bb 40 80 43 60			.byte	$0e,$00,$d9,$bb,$40,$80,$43,$60
>8110	66 64 bc 84 40 00 14 0f			.byte	$66,$64,$bc,$84,$40,$00,$14,$0f
>8118	00 d9 b2 8b 44 43 43 bd			.byte	$00,$d9,$b2,$8b,$44,$43,$43,$bd
>8120	43 6a 59 47 bc 84 44 43			.byte	$43,$6a,$59,$47,$bc,$84,$44,$43
>8128	43 00 12 10 00 d9 a2 fe			.byte	$43,$00,$12,$10,$00,$d9,$a2,$fe
>8130	04 79 71 bd 48 bd 48 bc			.byte	$04,$79,$71,$bd,$48,$bd,$48,$bc
>8138	84 fe 02 00 1b 11 00 d9			.byte	$84,$fe,$02,$00,$1b,$11,$00,$d9
>8140	bb 41 7e 64 4a fd 04 33			.byte	$bb,$41,$7e,$64,$4a,$fd,$04,$33
>8148	36 89 41 7e 64 4a fd 04			.byte	$36,$89,$41,$7e,$64,$4a,$fd,$04
>8150	33 36 bc 84 8b 41 00 15			.byte	$33,$36,$bc,$84,$8b,$41,$00,$15
>8158	12 00 d9 bb 48 63 56 8c			.byte	$12,$00,$d9,$bb,$48,$63,$56,$8c
>8160	48 63 56 bc 84 41 49 49			.byte	$48,$63,$56,$bc,$84,$41,$49,$49
>8168	41 4b 64 00 16 13 00 d9			.byte	$41,$4b,$64,$00,$16,$13,$00,$d9
>8170	bb 8b 42 43 62 4b 81 43			.byte	$bb,$8b,$42,$43,$62,$4b,$81,$43
>8178	71 56 5f bc 84 8b 42 60			.byte	$71,$56,$5f,$bc,$84,$8b,$42,$60
>8180	41 00 10 14 00 d9 98 42			.byte	$41,$00,$10,$14,$00,$d9,$98,$42
>8188	61 5f 45 84 8b 42 61 5f			.byte	$61,$5f,$45,$84,$8b,$42,$61,$5f
>8190	46 00 14 15 00 d9 a6 fe			.byte	$46,$00,$14,$15,$00,$d9,$a6,$fe
>8198	0b 73 71 71 76 7a 78 71			.byte	$0b,$73,$71,$71,$76,$7a,$78,$71
>81a0	74 74 bc 84 49 00 1a 16			.byte	$74,$74,$bc,$84,$49,$00,$1a,$16
>81a8	00 d9 bb 42 4c 56 51 fd			.byte	$00,$d9,$bb,$42,$4c,$56,$51,$fd
>81b0	04 34 31 85 42 4c 56 51			.byte	$04,$34,$31,$85,$42,$4c,$56,$51
>81b8	fd 04 34 31 bc 84 40 00			.byte	$fd,$04,$34,$31,$bc,$84,$40,$00
>81c0	12 17 00 d9 bb 41 51 4b			.byte	$12,$17,$00,$d9,$bb,$41,$51,$4b
>81c8	67 86 41 51 4b 67 bc 84			.byte	$67,$86,$41,$51,$4b,$67,$bc,$84
>81d0	40 00 17 18 00 d9 bb 42			.byte	$40,$00,$17,$18,$00,$d9,$bb,$42
>81d8	66 7e 47 81 8b 43 72 45			.byte	$66,$7e,$47,$81,$8b,$43,$72,$45
>81e0	6d bc 84 8b 41 50 41 69			.byte	$6d,$bc,$84,$8b,$41,$50,$41,$69
>81e8	00 12 19 00 d9 a5 a4 42			.byte	$00,$12,$19,$00,$d9,$a5,$a4,$42
>81f0	67 4c 4b bc bc 84 42 67			.byte	$67,$4c,$4b,$bc,$bc,$84,$42,$67
>81f8	4c 4b 00 1c 1a 00 d9 bb			.byte	$4c,$4b,$00,$1c,$1a,$00,$d9,$bb
>8200	8b 41 69 57 4f fd 04 36			.byte	$8b,$41,$69,$57,$4f,$fd,$04,$36
>8208	35 86 8b 41 69 57 4f fd			.byte	$35,$86,$8b,$41,$69,$57,$4f,$fd
>8210	04 36 35 bc 84 40 00 13			.byte	$04,$36,$35,$bc,$84,$40,$00,$13
>8218	1b 00 d9 bb 43 6a 7b 76			.byte	$1b,$00,$d9,$bb,$43,$6a,$7b,$76
>8220	84 43 6a 7b 76 bc 84 8b			.byte	$84,$43,$6a,$7b,$76,$bc,$84,$8b
>8228	41 00 12 1c 00 d9 bb 42			.byte	$41,$00,$12,$1c,$00,$d9,$bb,$42
>8230	67 74 56 81 40 bc 84 42			.byte	$67,$74,$56,$81,$40,$bc,$84,$42
>8238	67 74 56 00 0f 1d 00 d9			.byte	$67,$74,$56,$00,$0f,$1d,$00,$d9
>8240	9a 8b 76 47 4b bc 84 76			.byte	$9a,$8b,$76,$47,$4b,$bc,$84,$76
>8248	47 4b 00 0d 1e 00 d9 b4			.byte	$47,$4b,$00,$0d,$1e,$00,$d9,$b4
>8250	41 7d bc 84 fe 03 7d 00			.byte	$41,$7d,$bc,$84,$fe,$03,$7d,$00
>8258	19 1f 00 d9 bb 64 4c 7c			.byte	$19,$1f,$00,$d9,$bb,$64,$4c,$7c
>8260	fd 04 38 34 87 64 4c 7c			.byte	$fd,$04,$38,$34,$87,$64,$4c,$7c
>8268	fd 04 38 34 bc 84 8b 41			.byte	$fd,$04,$38,$34,$bc,$84,$8b,$41
>8270	00 14 20 00 d9 bb 8b 42			.byte	$00,$14,$20,$00,$d9,$bb,$8b,$42
>8278	7a 44 42 86 8b 42 7a 44			.byte	$7a,$44,$42,$86,$8b,$42,$7a,$44
>8280	42 bc 84 40 00 13 21 00			.byte	$42,$bc,$84,$40,$00,$13,$21,$00
>8288	d9 bb 7f 7b 64 80 8b 41			.byte	$d9,$bb,$7f,$7b,$64,$80,$8b,$41
>8290	7f 40 64 bc 84 7b 44 00			.byte	$7f,$40,$64,$bc,$84,$7b,$44,$00
>8298	0f 22 00 d9 b3 8b 41 52			.byte	$0f,$22,$00,$d9,$b3,$8b,$41,$52
>82a0	4d 58 bc 84 8b 41 00 13			.byte	$4d,$58,$bc,$84,$8b,$41,$00,$13
>82a8	23 00 d9 a3 48 bc 84 fe			.byte	$23,$00,$d9,$a3,$48,$bc,$84,$fe
>82b0	0a 20 20 20 20 20 20 20			.byte	$0a,$20,$20,$20,$20,$20,$20,$20
>82b8	20 00 24 24 00 d9 bb 8b			.byte	$20,$00,$24,$24,$00,$d9,$bb,$8b
>82c0	43 4d 7a 6e fd 04 36 31			.byte	$43,$4d,$7a,$6e,$fd,$04,$36,$31
>82c8	8b 8b 41 43 65 46 fd 04			.byte	$8b,$8b,$41,$43,$65,$46,$fd,$04
>82d0	34 37 bc 84 8b 42 4a 55			.byte	$34,$37,$bc,$84,$8b,$42,$4a,$55
>82d8	68 fd 04 31 34 00 12 25			.byte	$68,$fd,$04,$31,$34,$00,$12,$25
>82e0	00 d9 bb 43 65 7e 49 88			.byte	$00,$d9,$bb,$43,$65,$7e,$49,$88
>82e8	43 65 7e 49 bc 84 40 00			.byte	$43,$65,$7e,$49,$bc,$84,$40,$00
>82f0	14 26 00 d9 bb 8b 53 73			.byte	$14,$26,$00,$d9,$bb,$8b,$53,$73
>82f8	40 82 8b 68 69 6f bc 84			.byte	$40,$82,$8b,$68,$69,$6f,$bc,$84
>8300	7b 5b 51 00 15 27 00 d9			.byte	$7b,$5b,$51,$00,$15,$27,$00,$d9
>8308	b2 8b 43 6e 69 7a bd 43			.byte	$b2,$8b,$43,$6e,$69,$7a,$bd,$43
>8310	5d 50 57 bc 84 51 59 63			.byte	$5d,$50,$57,$bc,$84,$51,$59,$63
>8318	00 13 28 00 d9 a7 41 4e			.byte	$00,$13,$28,$00,$d9,$a7,$41,$4e
>8320	50 58 bc 84 fe 07 34 45			.byte	$50,$58,$bc,$84,$fe,$07,$34,$45
>8328	34 31 38 00 19 29 00 d9			.byte	$34,$31,$38,$00,$19,$29,$00,$d9
>8330	bb 43 63 7e 6e fd 03 37			.byte	$bb,$43,$63,$7e,$6e,$fd,$03,$37
>8338	84 43 63 7e 6e fd 03 37			.byte	$84,$43,$63,$7e,$6e,$fd,$03,$37
>8340	bc 84 8b 41 00 12 2a 00			.byte	$bc,$84,$8b,$41,$00,$12,$2a,$00
>8348	d9 bb 42 6b 7b 76 85 42			.byte	$d9,$bb,$42,$6b,$7b,$76,$85,$42
>8350	6b 7b 76 bc 84 40 00 14			.byte	$6b,$7b,$76,$bc,$84,$40,$00,$14
>8358	2b 00 d9 bb 8b 5d 52 4d			.byte	$2b,$00,$d9,$bb,$8b,$5d,$52,$4d
>8360	81 4c 7d 43 bc 84 8b 51			.byte	$81,$4c,$7d,$43,$bc,$84,$8b,$51
>8368	42 4d 00 10 2c 00 d9 98			.byte	$42,$4d,$00,$10,$2c,$00,$d9,$98
>8370	41 7d 61 6a 84 8b 41 7d			.byte	$41,$7d,$61,$6a,$84,$8b,$41,$7d
>8378	61 6b 00 13 2d 00 d9 af			.byte	$61,$6b,$00,$13,$2d,$00,$d9,$af
>8380	fe 07 35 34 34 33 43 bc			.byte	$fe,$07,$35,$34,$34,$33,$43,$bc
>8388	84 41 54 50 7c 00 29 2e			.byte	$84,$41,$54,$50,$7c,$00,$29,$2e
>8390	00 d9 bb 8b 41 5f 6b 4f			.byte	$00,$d9,$bb,$8b,$41,$5f,$6b,$4f
>8398	fd 04 39 36 8c 8b 41 5f			.byte	$fd,$04,$39,$36,$8c,$8b,$41,$5f
>83a0	6b 4f fd 04 39 36 bc 84			.byte	$6b,$4f,$fd,$04,$39,$36,$bc,$84
>83a8	41 fd 0d 35 33 35 37 36			.byte	$41,$fd,$0d,$35,$33,$35,$37,$36
>83b0	31 36 39 65 31 31 00 15			.byte	$31,$36,$39,$65,$31,$31,$00,$15
>83b8	2f 00 d9 bb 8b 42 4d 6b			.byte	$2f,$00,$d9,$bb,$8b,$42,$4d,$6b
>83c0	59 89 8b 42 4d 6b 59 bc			.byte	$59,$89,$8b,$42,$4d,$6b,$59,$bc
>83c8	84 8b 41 00 14 30 00 d9			.byte	$84,$8b,$41,$00,$14,$30,$00,$d9
>83d0	bb 7f 63 63 81 43 61 76			.byte	$bb,$7f,$63,$63,$81,$43,$61,$76
>83d8	5e bc 84 43 7f 77 7f 00			.byte	$5e,$bc,$84,$43,$7f,$77,$7f,$00
>83e0	1a 31 00 d9 a5 a4 43 48			.byte	$1a,$31,$00,$d9,$a5,$a4,$43,$48
>83e8	5e 48 fd 04 37 37 bc bc			.byte	$5e,$48,$fd,$04,$37,$37,$bc,$bc
>83f0	84 43 48 5e 48 fd 04 37			.byte	$84,$43,$48,$5e,$48,$fd,$04,$37
>83f8	37 00 12 32 00 d9 a0 fe			.byte	$37,$00,$12,$32,$00,$d9,$a0,$fe
>8400	04 71 6e bd 48 bc 84 fe			.byte	$04,$71,$6e,$bd,$48,$bc,$84,$fe
>8408	04 71 6e 00 20 33 00 d9			.byte	$04,$71,$6e,$00,$20,$33,$00,$d9
>8410	bb 42 67 6a 7f fd 04 30			.byte	$bb,$42,$67,$6a,$7f,$fd,$04,$30
>8418	36 8a 42 67 6a 7f fd 04			.byte	$36,$8a,$42,$67,$6a,$7f,$fd,$04
>8420	30 36 bc 84 45 4f 55 7e			.byte	$30,$36,$bc,$84,$45,$4f,$55,$7e
>8428	fd 03 31 00 15 34 00 d9			.byte	$fd,$03,$31,$00,$15,$34,$00,$d9
>8430	bb 42 46 60 68 8a 42 46			.byte	$bb,$42,$46,$60,$68,$8a,$42,$46
>8438	60 68 bc 84 44 4d 41 50			.byte	$60,$68,$bc,$84,$44,$4d,$41,$50
>8440	00 16 35 00 d9 bb 8b 41			.byte	$00,$16,$35,$00,$d9,$bb,$8b,$41
>8448	4d 48 6b 80 43 5e 51 5e			.byte	$4d,$48,$6b,$80,$43,$5e,$51,$5e
>8450	bc 84 42 52 51 54 00 0f			.byte	$bc,$84,$42,$52,$51,$54,$00,$0f
>8458	36 00 d9 9a 8b 60 63 58			.byte	$36,$00,$d9,$9a,$8b,$60,$63,$58
>8460	bc 84 60 63 58 00 13 37			.byte	$bc,$84,$60,$63,$58,$00,$13,$37
>8468	00 d9 a1 fe 07 65 6c 7a			.byte	$00,$d9,$a1,$fe,$07,$65,$6c,$7a
>8470	70 62 bd 40 bc 84 fe 02			.byte	$70,$62,$bd,$40,$bc,$84,$fe,$02
>8478	00 1d 38 00 d9 bb 8b 41			.byte	$00,$1d,$38,$00,$d9,$bb,$8b,$41
>8480	53 4f 59 fd 04 36 38 87			.byte	$53,$4f,$59,$fd,$04,$36,$38,$87
>8488	8b 41 53 4f 59 fd 04 36			.byte	$8b,$41,$53,$4f,$59,$fd,$04,$36
>8490	38 bc 84 8b 41 00 12 39			.byte	$38,$bc,$84,$8b,$41,$00,$12,$39
>8498	00 d9 bb 4b 54 72 8a 4b			.byte	$00,$d9,$bb,$4b,$54,$72,$8a,$4b
>84a0	54 72 bc 84 56 69 64 00			.byte	$54,$72,$bc,$84,$56,$69,$64,$00
>84a8	14 3a 00 d9 bb 41 72 56			.byte	$14,$3a,$00,$d9,$bb,$41,$72,$56
>84b0	6f 82 41 71 7d 50 bc 84			.byte	$6f,$82,$41,$71,$7d,$50,$bc,$84
>84b8	43 6b 7f 00 0f 3b 00 d9			.byte	$43,$6b,$7f,$00,$0f,$3b,$00,$d9
>84c0	b3 8b 41 46 7c 49 bc 84			.byte	$b3,$8b,$41,$46,$7c,$49,$bc,$84
>84c8	8b 41 00 19 3c 00 d9 a2			.byte	$8b,$41,$00,$19,$3c,$00,$d9,$a2
>84d0	fe 09 74 62 68 74 68 78			.byte	$fe,$09,$74,$62,$68,$74,$68,$78
>84d8	65 bd 46 bd 45 bc 84 fe			.byte	$65,$bd,$46,$bd,$45,$bc,$84,$fe
>84e0	04 78 65 00 1d 3d 00 d9			.byte	$04,$78,$65,$00,$1d,$3d,$00,$d9
>84e8	bb 41 71 74 7a fd 04 36			.byte	$bb,$41,$71,$74,$7a,$fd,$04,$36
>84f0	37 8b 41 71 74 7a fd 04			.byte	$37,$8b,$41,$71,$74,$7a,$fd,$04
>84f8	36 37 bc 84 40 fd 03 30			.byte	$36,$37,$bc,$84,$40,$fd,$03,$30
>8500	00 14 3e 00 d9 bb 8b 43			.byte	$00,$14,$3e,$00,$d9,$bb,$8b,$43
>8508	4f 64 42 85 8b 43 4f 64			.byte	$4f,$64,$42,$85,$8b,$43,$4f,$64
>8510	42 bc 84 40 00 15 3f 00			.byte	$42,$bc,$84,$40,$00,$15,$3f,$00
>8518	d9 bb 8b 43 40 68 76 80			.byte	$d9,$bb,$8b,$43,$40,$68,$76,$80
>8520	41 7f 72 73 bc 84 7f 52			.byte	$41,$7f,$72,$73,$bc,$84,$7f,$52
>8528	42 00 15 40 00 d9 b2 41			.byte	$42,$00,$15,$40,$00,$d9,$b2,$41
>8530	7c 58 6f bd 8b 41 52 71			.byte	$7c,$58,$6f,$bd,$8b,$41,$52,$71
>8538	6c bc 84 69 67 43 00 0e			.byte	$6c,$bc,$84,$69,$67,$43,$00,$0e
>8540	41 00 d9 a6 fe 05 65 68			.byte	$41,$00,$d9,$a6,$fe,$05,$65,$68
>8548	67 bc 84 43 00 22 42 00			.byte	$67,$bc,$84,$43,$00,$22,$42,$00
>8550	d9 bb 8b 6d 73 64 fd 04			.byte	$d9,$bb,$8b,$6d,$73,$64,$fd,$04
>8558	35 32 8a 8b 6d 73 64 fd			.byte	$35,$32,$8a,$8b,$6d,$73,$64,$fd
>8560	04 35 32 bc 84 8b 41 5b			.byte	$04,$35,$32,$bc,$84,$8b,$41,$5b
>8568	67 49 fd 04 30 34 00 14			.byte	$67,$49,$fd,$04,$30,$34,$00,$14
>8570	43 00 d9 bb 8b 43 6b 45			.byte	$43,$00,$d9,$bb,$8b,$43,$6b,$45
>8578	46 85 8b 43 6b 45 46 bc			.byte	$46,$85,$8b,$43,$6b,$45,$46,$bc
>8580	84 40 00 13 44 00 d9 bb			.byte	$84,$40,$00,$13,$44,$00,$d9,$bb
>8588	8b 5c 50 61 80 76 7c 4f			.byte	$8b,$5c,$50,$61,$80,$76,$7c,$4f
>8590	bc 84 62 6c 4f 00 0e 45			.byte	$bc,$84,$62,$6c,$4f,$00,$0e,$45
>8598	00 d9 98 5c 4f 55 84 8b			.byte	$00,$d9,$98,$5c,$4f,$55,$84,$8b
>85a0	5c 4f 56 00 10 46 00 d9			.byte	$5c,$4f,$56,$00,$10,$46,$00,$d9
>85a8	9b fe 06 75 6d 66 76 bc			.byte	$9b,$fe,$06,$75,$6d,$66,$76,$bc
>85b0	84 41 75 00 1c 47 00 d9			.byte	$84,$41,$75,$00,$1c,$47,$00,$d9
>85b8	bb 8b 42 76 70 fd 05 30			.byte	$bb,$8b,$42,$76,$70,$fd,$05,$30
>85c0	32 35 86 8b 42 76 70 fd			.byte	$32,$35,$86,$8b,$42,$76,$70,$fd
>85c8	05 30 32 35 bc 84 40 00			.byte	$05,$30,$32,$35,$bc,$84,$40,$00
>85d0	18 48 00 d9 bb 8b 43 5c			.byte	$18,$48,$00,$d9,$bb,$8b,$43,$5c
>85d8	5e 72 8a 8b 43 5c 5e 72			.byte	$5e,$72,$8a,$8b,$43,$5c,$5e,$72
>85e0	bc 84 8b 46 78 7d 64 00			.byte	$bc,$84,$8b,$46,$78,$7d,$64,$00
>85e8	16 49 00 d9 bb 8b 42 62			.byte	$16,$49,$00,$d9,$bb,$8b,$42,$62
>85f0	6e 77 81 8b 41 5c 79 65			.byte	$6e,$77,$81,$8b,$41,$5c,$79,$65
>85f8	bc 84 8b 68 65 00 1c 4a			.byte	$bc,$84,$8b,$68,$65,$00,$1c,$4a
>8600	00 d9 a5 a4 8b 42 69 7c			.byte	$00,$d9,$a5,$a4,$8b,$42,$69,$7c
>8608	5e fd 04 32 33 bc bc 84			.byte	$5e,$fd,$04,$32,$33,$bc,$bc,$84
>8610	8b 42 69 7c 5e fd 04 32			.byte	$8b,$42,$69,$7c,$5e,$fd,$04,$32
>8618	33 00 0d 4b 00 d9 b4 41			.byte	$33,$00,$0d,$4b,$00,$d9,$b4,$41
>8620	4c bc 84 fe 03 4c 00 1d			.byte	$4c,$bc,$84,$fe,$03,$4c,$00,$1d
>8628	4c 00 d9 bb 42 78 6b 43			.byte	$4c,$00,$d9,$bb,$42,$78,$6b,$43
>8630	fd 04 34 37 8b 42 78 6b			.byte	$fd,$04,$34,$37,$8b,$42,$78,$6b
>8638	43 fd 04 34 37 bc 84 40			.byte	$43,$fd,$04,$34,$37,$bc,$84,$40
>8640	fd 03 30 00 18 4d 00 d9			.byte	$fd,$03,$30,$00,$18,$4d,$00,$d9
>8648	bb 8b 43 49 7f 71 8a 8b			.byte	$bb,$8b,$43,$49,$7f,$71,$8a,$8b
>8650	43 49 7f 71 bc 84 8b 46			.byte	$43,$49,$7f,$71,$bc,$84,$8b,$46
>8658	53 7f 62 00 12 4e 00 d9			.byte	$53,$7f,$62,$00,$12,$4e,$00,$d9
>8660	bb 42 7a 57 54 81 40 bc			.byte	$bb,$42,$7a,$57,$54,$81,$40,$bc
>8668	84 42 7a 57 54 00 10 4f			.byte	$84,$42,$7a,$57,$54,$00,$10,$4f
>8670	00 d9 9a 42 44 5b 4c bc			.byte	$00,$d9,$9a,$42,$44,$5b,$4c,$bc
>8678	84 42 44 5b 4c 00 1d 50			.byte	$84,$42,$44,$5b,$4c,$00,$1d,$50
>8680	00 d9 a3 52 bc 84 fe 14			.byte	$00,$d9,$a3,$52,$bc,$84,$fe,$14
>8688	20 20 20 20 20 20 20 20			.byte	$20,$20,$20,$20,$20,$20,$20,$20
>8690	20 20 20 20 20 20 20 20			.byte	$20,$20,$20,$20,$20,$20,$20,$20
>8698	20 20 00 19 51 00 d9 bb			.byte	$20,$20,$00,$19,$51,$00,$d9,$bb
>86a0	43 58 41 49 fd 03 31 87			.byte	$43,$58,$41,$49,$fd,$03,$31,$87
>86a8	43 58 41 49 fd 03 31 bc			.byte	$43,$58,$41,$49,$fd,$03,$31,$bc
>86b0	84 8b 41 00 12 52 00 d9			.byte	$84,$8b,$41,$00,$12,$52,$00,$d9
>86b8	bb 43 6b 55 59 86 42 6a			.byte	$bb,$43,$6b,$55,$59,$86,$42,$6a
>86c0	6e 4d bc 84 40 00 17 53			.byte	$6e,$4d,$bc,$84,$40,$00,$17,$53
>86c8	00 d9 bb 8b 41 4e 51 78			.byte	$00,$d9,$bb,$8b,$41,$4e,$51,$78
>86d0	81 8b 42 55 7f 77 bc 84			.byte	$81,$8b,$42,$55,$7f,$77,$bc,$84
>86d8	8b 44 51 77 00 0d 54 00			.byte	$8b,$44,$51,$77,$00,$0d,$54,$00
>86e0	d9 b3 42 71 43 4e bc 84			.byte	$d9,$b3,$42,$71,$43,$4e,$bc,$84
>86e8	41 00 13 55 00 d9 a7 41			.byte	$41,$00,$13,$55,$00,$d9,$a7,$41
>86f0	5c 52 7f bc 84 fe 07 35			.byte	$5c,$52,$7f,$bc,$84,$fe,$07,$35
>86f8	43 34 42 46 00 1d 56 00			.byte	$43,$34,$42,$46,$00,$1d,$56,$00
>8700	d9 bb 41 76 51 59 fd 04			.byte	$d9,$bb,$41,$76,$51,$59,$fd,$04
>8708	38 39 8b 41 76 51 59 fd			.byte	$38,$39,$8b,$41,$76,$51,$59,$fd
>8710	04 38 39 bc 84 40 fd 03			.byte	$04,$38,$39,$bc,$84,$40,$fd,$03
>8718	30 00 18 57 00 d9 bb 8b			.byte	$30,$00,$18,$57,$00,$d9,$bb,$8b
>8720	41 41 66 59 8a 8b 41 41			.byte	$41,$41,$66,$59,$8a,$8b,$41,$41
>8728	66 59 bc 84 8b 42 43 4c			.byte	$66,$59,$bc,$84,$8b,$42,$43,$4c
>8730	72 00 14 58 00 d9 bb 71			.byte	$72,$00,$14,$58,$00,$d9,$bb,$71
>8738	45 7e 82 41 5a 74 7f bc			.byte	$45,$7e,$82,$41,$5a,$74,$7f,$bc
>8740	84 41 6b 71 41 00 17 59			.byte	$84,$41,$6b,$71,$41,$00,$17,$59
>8748	00 d9 b2 8b 41 50 57 6b			.byte	$00,$d9,$b2,$8b,$41,$50,$57,$6b
>8750	bd 8b 42 63 60 7c bc 84			.byte	$bd,$8b,$42,$63,$60,$7c,$bc,$84
>8758	41 50 57 6b 00 13 5a 00			.byte	$41,$50,$57,$6b,$00,$13,$5a,$00
>8760	d9 af fe 07 43 36 42 44			.byte	$d9,$af,$fe,$07,$43,$36,$42,$44
>8768	46 bc 84 43 46 6f 5f 00			.byte	$46,$bc,$84,$43,$46,$6f,$5f,$00
>8770	20 5b 00 d9 bb 43 68 49			.byte	$20,$5b,$00,$d9,$bb,$43,$68,$49
>8778	47 fd 04 33 34 8a 43 68			.byte	$47,$fd,$04,$33,$34,$8a,$43,$68
>8780	49 47 fd 04 33 34 bc 84			.byte	$49,$47,$fd,$04,$33,$34,$bc,$84
>8788	47 50 52 4e fd 03 37 00			.byte	$47,$50,$52,$4e,$fd,$03,$37,$00
>8790	14 5c 00 d9 bb 8b 42 42			.byte	$14,$5c,$00,$d9,$bb,$8b,$42,$42
>8798	57 48 86 8b 42 42 57 48			.byte	$57,$48,$86,$8b,$42,$42,$57,$48
>87a0	bc 84 40 00 14 5d 00 d9			.byte	$bc,$84,$40,$00,$14,$5d,$00,$d9
>87a8	bb 8b 42 61 46 7f 80 6a			.byte	$bb,$8b,$42,$61,$46,$7f,$80,$6a
>87b0	4b 58 bc 84 4a 49 40 00			.byte	$4b,$58,$bc,$84,$4a,$49,$40,$00
>87b8	0e 5e 00 d9 98 8b 7f 57			.byte	$0e,$5e,$00,$d9,$98,$8b,$7f,$57
>87c0	77 84 7f 57 76 00 1f 5f			.byte	$77,$84,$7f,$57,$76,$00,$1f,$5f
>87c8	00 d9 a0 fe 0b 75 79 6a			.byte	$00,$d9,$a0,$fe,$0b,$75,$79,$6a
>87d0	6d 78 6c 64 73 76 bd 48			.byte	$6d,$78,$6c,$64,$73,$76,$bd,$48
>87d8	bc 84 fe 0a 75 79 6a 6d			.byte	$bc,$84,$fe,$0a,$75,$79,$6a,$6d
>87e0	78 6c 64 73 00 1f 60 00			.byte	$78,$6c,$64,$73,$00,$1f,$60,$00
>87e8	d9 bb 66 67 54 fd 04 32			.byte	$d9,$bb,$66,$67,$54,$fd,$04,$32
>87f0	33 8a 66 67 54 fd 04 32			.byte	$33,$8a,$66,$67,$54,$fd,$04,$32
>87f8	33 bc 84 41 4d 4e 68 fd			.byte	$33,$bc,$84,$41,$4d,$4e,$68,$fd
>8800	04 34 37 00 15 61 00 d9			.byte	$04,$34,$37,$00,$15,$61,$00,$d9
>8808	bb 8b 41 69 55 64 84 8b			.byte	$bb,$8b,$41,$69,$55,$64,$84,$8b
>8810	41 69 55 64 bc 84 8b 41			.byte	$41,$69,$55,$64,$bc,$84,$8b,$41
>8818	00 14 62 00 d9 bb 6d 43			.byte	$00,$14,$62,$00,$d9,$bb,$6d,$43
>8820	49 80 8b 43 73 4a 78 bc			.byte	$49,$80,$8b,$43,$73,$4a,$78,$bc
>8828	84 4c 41 48 00 12 63 00			.byte	$84,$4c,$41,$48,$00,$12,$63,$00
>8830	d9 a5 a4 43 72 7f 6e bc			.byte	$d9,$a5,$a4,$43,$72,$7f,$6e,$bc
>8838	bc 84 43 72 7f 6e 00 18			.byte	$bc,$84,$43,$72,$7f,$6e,$00,$18
>8840	64 00 d9 a1 fe 07 64 76			.byte	$64,$00,$d9,$a1,$fe,$07,$64,$76
>8848	65 71 61 bd 4a bc 84 fe			.byte	$65,$71,$61,$bd,$4a,$bc,$84,$fe
>8850	07 64 76 65 71 61 00 1a			.byte	$07,$64,$76,$65,$71,$61,$00,$1a
>8858	65 00 d9 bb 8b 61 6c 64			.byte	$65,$00,$d9,$bb,$8b,$61,$6c,$64
>8860	fd 04 31 32 85 8b 61 6c			.byte	$fd,$04,$31,$32,$85,$8b,$61,$6c
>8868	64 fd 04 31 32 bc 84 40			.byte	$64,$fd,$04,$31,$32,$bc,$84,$40
>8870	00 11 66 00 d9 bb 42 71			.byte	$00,$11,$66,$00,$d9,$bb,$42,$71
>8878	4a 89 42 71 4a bc 84 8b			.byte	$4a,$89,$42,$71,$4a,$bc,$84,$8b
>8880	41 00 16 67 00 d9 bb 8b			.byte	$41,$00,$16,$67,$00,$d9,$bb,$8b
>8888	42 51 72 43 82 8b 42 7d			.byte	$42,$51,$72,$43,$82,$8b,$42,$7d
>8890	62 6b bc 84 6c 50 68 00			.byte	$62,$6b,$bc,$84,$6c,$50,$68,$00
>8898	11 68 00 d9 9a 8b 42 79			.byte	$11,$68,$00,$d9,$9a,$8b,$42,$79
>88a0	70 5f bc 84 42 79 70 5f			.byte	$70,$5f,$bc,$84,$42,$79,$70,$5f
>88a8	00 1b 69 00 d9 a2 fe 0a			.byte	$00,$1b,$69,$00,$d9,$a2,$fe,$0a
>88b0	66 72 6e 76 79 79 78 6f			.byte	$66,$72,$6e,$76,$79,$79,$78,$6f
>88b8	bd 43 bd 43 bc 84 fe 05			.byte	$bd,$43,$bd,$43,$bc,$84,$fe,$05
>88c0	6e 76 79 00 1a 6a 00 d9			.byte	$6e,$76,$79,$00,$1a,$6a,$00,$d9
>88c8	bb 8b 7a 7d 42 fd 04 30			.byte	$bb,$8b,$7a,$7d,$42,$fd,$04,$30
>88d0	31 88 8b 7a 7d 42 fd 04			.byte	$31,$88,$8b,$7a,$7d,$42,$fd,$04
>88d8	30 31 bc 84 40 00 14 6b			.byte	$30,$31,$bc,$84,$40,$00,$14,$6b
>88e0	00 d9 bb 8b 41 75 50 55			.byte	$00,$d9,$bb,$8b,$41,$75,$50,$55
>88e8	86 8b 41 75 50 55 bc 84			.byte	$86,$8b,$41,$75,$50,$55,$bc,$84
>88f0	40 00 16 6c 00 d9 bb 8b			.byte	$40,$00,$16,$6c,$00,$d9,$bb,$8b
>88f8	42 63 5c 59 81 42 5a 78			.byte	$42,$63,$5c,$59,$81,$42,$5a,$78
>8900	78 bc 84 8b 61 44 41 00			.byte	$78,$bc,$84,$8b,$61,$44,$41,$00
>8908	0f 6d 00 d9 b3 8b 43 6c			.byte	$0f,$6d,$00,$d9,$b3,$8b,$43,$6c
>8910	7d 78 bc 84 8b 41 00 0f			.byte	$7d,$78,$bc,$84,$8b,$41,$00,$0f
>8918	6e 00 d9 a6 fe 06 61 6c			.byte	$6e,$00,$d9,$a6,$fe,$06,$61,$6c
>8920	79 77 bc 84 44 00 17 6f			.byte	$79,$77,$bc,$84,$44,$00,$17,$6f
>8928	00 d9 bb 7d 48 6d fd 03			.byte	$00,$d9,$bb,$7d,$48,$6d,$fd,$03
>8930	33 87 7d 48 6d fd 03 33			.byte	$33,$87,$7d,$48,$6d,$fd,$03,$33
>8938	bc 84 8b 41 00 18 70 00			.byte	$bc,$84,$8b,$41,$00,$18,$70,$00
>8940	d9 bb 8b 41 7d 6d 42 8a			.byte	$d9,$bb,$8b,$41,$7d,$6d,$42,$8a
>8948	8b 41 7d 6d 42 bc 84 8b			.byte	$8b,$41,$7d,$6d,$42,$bc,$84,$8b
>8950	43 7b 5a 44 00 12 71 00			.byte	$43,$7b,$5a,$44,$00,$12,$71,$00
>8958	d9 bb 8b 7d 46 62 82 40			.byte	$d9,$bb,$8b,$7d,$46,$62,$82,$40
>8960	bc 84 8b 7d 46 62 00 15			.byte	$bc,$84,$8b,$7d,$46,$62,$00,$15
>8968	72 00 d9 b2 42 72 6a 6d			.byte	$72,$00,$d9,$b2,$42,$72,$6a,$6d
>8970	bd 42 77 6f 47 bc 84 42			.byte	$bd,$42,$77,$6f,$47,$bc,$84,$42
>8978	72 6a 6d 00 13 73 00 d9			.byte	$72,$6a,$6d,$00,$13,$73,$00,$d9
>8980	9b fe 09 76 71 77 61 79			.byte	$9b,$fe,$09,$76,$71,$77,$61,$79
>8988	68 6f bc 84 41 76 00 1d			.byte	$68,$6f,$bc,$84,$41,$76,$00,$1d
>8990	74 00 d9 bb 41 77 4e 41			.byte	$74,$00,$d9,$bb,$41,$77,$4e,$41
>8998	fd 04 30 36 8d 41 77 4e			.byte	$fd,$04,$30,$36,$8d,$41,$77,$4e
>89a0	41 fd 04 30 36 bc 84 41			.byte	$41,$fd,$04,$30,$36,$bc,$84,$41
>89a8	fd 03 30 00 12 75 00 d9			.byte	$fd,$03,$30,$00,$12,$75,$00,$d9
>89b0	bb 42 42 77 7f 8b 42 42			.byte	$bb,$42,$42,$77,$7f,$8b,$42,$42
>89b8	77 7f bc 84 40 00 16 76			.byte	$77,$7f,$bc,$84,$40,$00,$16,$76
>89c0	00 d9 bb 8b 6c 6c 47 82			.byte	$00,$d9,$bb,$8b,$6c,$6c,$47,$82
>89c8	42 50 79 4d bc 84 8b 42			.byte	$42,$50,$79,$4d,$bc,$84,$8b,$42
>89d0	7c 55 4c 00 10 77 00 d9			.byte	$7c,$55,$4c,$00,$10,$77,$00,$d9
>89d8	98 8b 42 60 5b 7f 84 42			.byte	$98,$8b,$42,$60,$5b,$7f,$84,$42
>89e0	60 5b 7e 00 0d 78 00 d9			.byte	$60,$5b,$7e,$00,$0d,$78,$00,$d9
>89e8	b4 41 5a bc 84 fe 03 5a			.byte	$b4,$41,$5a,$bc,$84,$fe,$03,$5a
>89f0	00 1c 79 00 d9 bb 8b 41			.byte	$00,$1c,$79,$00,$d9,$bb,$8b,$41
>89f8	6b 75 58 fd 04 31 36 86			.byte	$6b,$75,$58,$fd,$04,$31,$36,$86
>8a00	8b 41 6b 75 58 fd 04 31			.byte	$8b,$41,$6b,$75,$58,$fd,$04,$31
>8a08	36 bc 84 40 00 13 7a 00			.byte	$36,$bc,$84,$40,$00,$13,$7a,$00
>8a10	d9 bb 41 64 54 55 84 41			.byte	$d9,$bb,$41,$64,$54,$55,$84,$41
>8a18	64 54 55 bc 84 8b 41 00			.byte	$64,$54,$55,$bc,$84,$8b,$41,$00
>8a20	16 7b 00 d9 bb 8b 41 69			.byte	$16,$7b,$00,$d9,$bb,$8b,$41,$69
>8a28	6d 7e 80 42 4d 6a 7f bc			.byte	$6d,$7e,$80,$42,$4d,$6a,$7f,$bc
>8a30	84 42 44 42 42 00 14 7c			.byte	$84,$42,$44,$42,$42,$00,$14,$7c
>8a38	00 d9 a5 a4 8b 41 4f 43			.byte	$00,$d9,$a5,$a4,$8b,$41,$4f,$43
>8a40	58 bc bc 84 8b 41 4f 43			.byte	$58,$bc,$bc,$84,$8b,$41,$4f,$43
>8a48	58 00 0b 7d 00 d9 a3 40			.byte	$58,$00,$0b,$7d,$00,$d9,$a3,$40
>8a50	bc 84 fe 02 00 22 7e 00			.byte	$bc,$84,$fe,$02,$00,$22,$7e,$00
>8a58	d9 bb 8b 69 51 50 fd 04			.byte	$d9,$bb,$8b,$69,$51,$50,$fd,$04
>8a60	30 36 8a 8b 69 51 50 fd			.byte	$30,$36,$8a,$8b,$69,$51,$50,$fd
>8a68	04 30 36 bc 84 8b 41 52			.byte	$04,$30,$36,$bc,$84,$8b,$41,$52
>8a70	62 60 fd 04 31 32 00 15			.byte	$62,$60,$fd,$04,$31,$32,$00,$15
>8a78	7f 00 d9 bb 8b 53 55 7e			.byte	$7f,$00,$d9,$bb,$8b,$53,$55,$7e
>8a80	8a 8b 53 55 7e bc 84 8b			.byte	$8a,$8b,$53,$55,$7e,$bc,$84,$8b
>8a88	66 6b 7c 00 10 80 00 d9			.byte	$66,$6b,$7c,$00,$10,$80,$00,$d9
>8a90	bb 40 80 8b 43 42 43 7a			.byte	$bb,$40,$80,$8b,$43,$42,$43,$7a
>8a98	bc 84 40 00 11 81 00 d9			.byte	$bc,$84,$40,$00,$11,$81,$00,$d9
>8aa0	9a 8b 42 61 7d 4b bc 84			.byte	$9a,$8b,$42,$61,$7d,$4b,$bc,$84
>8aa8	42 61 7d 4b 00 13 82 00			.byte	$42,$61,$7d,$4b,$00,$13,$82,$00
>8ab0	d9 a7 42 65 50 46 bc 84			.byte	$d9,$a7,$42,$65,$50,$46,$bc,$84
>8ab8	fe 07 41 35 34 30 36 00			.byte	$fe,$07,$41,$35,$34,$30,$36,$00
>8ac0	19 83 00 d9 bb 41 6f 50			.byte	$19,$83,$00,$d9,$bb,$41,$6f,$50
>8ac8	4b fd 03 33 87 41 6f 50			.byte	$4b,$fd,$03,$33,$87,$41,$6f,$50
>8ad0	4b fd 03 33 bc 84 8b 41			.byte	$4b,$fd,$03,$33,$bc,$84,$8b,$41
>8ad8	00 14 84 00 d9 bb 8b 41			.byte	$00,$14,$84,$00,$d9,$bb,$8b,$41
>8ae0	7a 7e 5e 86 8b 41 7a 7e			.byte	$7a,$7e,$5e,$86,$8b,$41,$7a,$7e
>8ae8	5e bc 84 40 00 16 85 00			.byte	$5e,$bc,$84,$40,$00,$16,$85,$00
>8af0	d9 bb 43 48 69 6d 82 8b			.byte	$d9,$bb,$43,$48,$69,$6d,$82,$8b
>8af8	43 4c 5f 63 bc 84 8b 44			.byte	$43,$4c,$5f,$63,$bc,$84,$8b,$44
>8b00	76 50 00 0a 86 00 d9 b3			.byte	$76,$50,$00,$0a,$86,$00,$d9,$b3
>8b08	40 bc 84 40 00 13 87 00			.byte	$40,$bc,$84,$40,$00,$13,$87,$00
>8b10	d9 af fe 07 43 30 45 45			.byte	$d9,$af,$fe,$07,$43,$30,$45,$45
>8b18	35 bc 84 43 40 7b 65 00			.byte	$35,$bc,$84,$43,$40,$7b,$65,$00
>8b20	1c 88 00 d9 bb 8b 42 76			.byte	$1c,$88,$00,$d9,$bb,$8b,$42,$76
>8b28	73 5d fd 04 36 39 88 8b			.byte	$73,$5d,$fd,$04,$36,$39,$88,$8b
>8b30	42 76 73 5d fd 04 36 39			.byte	$42,$76,$73,$5d,$fd,$04,$36,$39
>8b38	bc 84 40 00 12 89 00 d9			.byte	$bc,$84,$40,$00,$12,$89,$00,$d9
>8b40	bb 42 78 7e 41 8d 42 78			.byte	$bb,$42,$78,$7e,$41,$8d,$42,$78
>8b48	7e 41 bc 84 41 00 16 8a			.byte	$7e,$41,$bc,$84,$41,$00,$16,$8a
>8b50	00 d9 bb 8b 4d 5a 41 81			.byte	$00,$d9,$bb,$8b,$4d,$5a,$41,$81
>8b58	8b 42 64 77 4d bc 84 8b			.byte	$8b,$42,$64,$77,$4d,$bc,$84,$8b
>8b60	44 52 41 00 14 8b 00 d9			.byte	$44,$52,$41,$00,$14,$8b,$00,$d9
>8b68	b2 4b 79 5f bd 8b 42 47			.byte	$b2,$4b,$79,$5f,$bd,$8b,$42,$47
>8b70	7a 47 bc 84 4b 79 5f 00			.byte	$7a,$47,$bc,$84,$4b,$79,$5f,$00
>8b78	1c 8c 00 d9 a0 fe 09 74			.byte	$1c,$8c,$00,$d9,$a0,$fe,$09,$74
>8b80	72 74 66 6b 70 6c bd 49			.byte	$72,$74,$66,$6b,$70,$6c,$bd,$49
>8b88	bc 84 fe 09 74 72 74 66			.byte	$bc,$84,$fe,$09,$74,$72,$74,$66
>8b90	6b 70 6c 00 1b 8d 00 d9			.byte	$6b,$70,$6c,$00,$1b,$8d,$00,$d9
>8b98	bb 41 5e 5c 7e fd 04 32			.byte	$bb,$41,$5e,$5c,$7e,$fd,$04,$32
>8ba0	39 89 41 5e 5c 7e fd 04			.byte	$39,$89,$41,$5e,$5c,$7e,$fd,$04
>8ba8	32 39 bc 84 8b 41 00 18			.byte	$32,$39,$bc,$84,$8b,$41,$00,$18
>8bb0	8e 00 d9 bb 8b 41 44 58			.byte	$8e,$00,$d9,$bb,$8b,$41,$44,$58
>8bb8	69 8a 8b 41 44 58 69 bc			.byte	$69,$8a,$8b,$41,$44,$58,$69,$bc
>8bc0	84 8b 42 48 71 52 00 17			.byte	$84,$8b,$42,$48,$71,$52,$00,$17
>8bc8	8f 00 d9 bb 8b 43 43 53			.byte	$8f,$00,$d9,$bb,$8b,$43,$43,$53
>8bd0	40 81 42 78 69 4e bc 84			.byte	$40,$81,$42,$78,$69,$4e,$bc,$84
>8bd8	8b 41 43 52 72 00 10 90			.byte	$8b,$41,$43,$52,$72,$00,$10,$90
>8be0	00 d9 98 8b 42 7c 54 65			.byte	$00,$d9,$98,$8b,$42,$7c,$54,$65
>8be8	84 42 7c 54 64 00 1b 91			.byte	$84,$42,$7c,$54,$64,$00,$1b,$91
>8bf0	00 d9 a1 fe 0c 68 71 66			.byte	$00,$d9,$a1,$fe,$0c,$68,$71,$66
>8bf8	67 6f 71 74 6b 6b 65 bd			.byte	$67,$6f,$71,$74,$6b,$6b,$65,$bd
>8c00	43 bc 84 fe 05 6b 6b 65			.byte	$43,$bc,$84,$fe,$05,$6b,$6b,$65
>8c08	00 1c 92 00 d9 bb 8b 43			.byte	$00,$1c,$92,$00,$d9,$bb,$8b,$43
>8c10	70 5b 5b fd 04 37 39 85			.byte	$70,$5b,$5b,$fd,$04,$37,$39,$85
>8c18	8b 43 70 5b 5b fd 04 37			.byte	$8b,$43,$70,$5b,$5b,$fd,$04,$37
>8c20	39 bc 84 40 00 15 93 00			.byte	$39,$bc,$84,$40,$00,$15,$93,$00
>8c28	d9 bb 8b 43 62 77 79 87			.byte	$d9,$bb,$8b,$43,$62,$77,$79,$87
>8c30	8b 43 62 77 79 bc 84 8b			.byte	$8b,$43,$62,$77,$79,$bc,$84,$8b
>8c38	41 00 14 94 00 d9 bb 47			.byte	$41,$00,$14,$94,$00,$d9,$bb,$47
>8c40	75 71 81 41 43 46 68 bc			.byte	$75,$71,$81,$41,$43,$46,$68,$bc
>8c48	84 41 47 77 79 00 1c 95			.byte	$84,$41,$47,$77,$79,$00,$1c,$95
>8c50	00 d9 a5 a4 8b 41 4a 75			.byte	$00,$d9,$a5,$a4,$8b,$41,$4a,$75
>8c58	70 fd 04 31 38 bc bc 84			.byte	$70,$fd,$04,$31,$38,$bc,$bc,$84
>8c60	8b 41 4a 75 70 fd 04 31			.byte	$8b,$41,$4a,$75,$70,$fd,$04,$31
>8c68	38 00 1d 96 00 d9 a2 fe			.byte	$38,$00,$1d,$96,$00,$d9,$a2,$fe
>8c70	0b 65 72 6a 6a 69 77 61			.byte	$0b,$65,$72,$6a,$6a,$69,$77,$61
>8c78	72 6a bd 43 bd 44 bc 84			.byte	$72,$6a,$bd,$43,$bd,$44,$bc,$84
>8c80	fe 06 6a 6a 69 77 00 1b			.byte	$fe,$06,$6a,$6a,$69,$77,$00,$1b
>8c88	97 00 d9 bb 42 7e 7e 53			.byte	$97,$00,$d9,$bb,$42,$7e,$7e,$53
>8c90	fd 04 31 32 87 42 7e 7e			.byte	$fd,$04,$31,$32,$87,$42,$7e,$7e
>8c98	53 fd 04 31 32 bc 84 8b			.byte	$53,$fd,$04,$31,$32,$bc,$84,$8b
>8ca0	41 00 14 98 00 d9 bb 8b			.byte	$41,$00,$14,$98,$00,$d9,$bb,$8b
>8ca8	42 59 50 68 8d 8b 42 59			.byte	$42,$59,$50,$68,$8d,$8b,$42,$59
>8cb0	50 68 bc 84 41 00 17 99			.byte	$50,$68,$bc,$84,$41,$00,$17,$99
>8cb8	00 d9 bb 8b 5e 62 64 80			.byte	$00,$d9,$bb,$8b,$5e,$62,$64,$80
>8cc0	8b 43 53 6f 6d bc 84 8b			.byte	$8b,$43,$53,$6f,$6d,$bc,$84,$8b
>8cc8	43 5f 6f 70 00 11 9a 00			.byte	$43,$5f,$6f,$70,$00,$11,$9a,$00
>8cd0	d9 9a 8b 43 43 49 66 bc			.byte	$d9,$9a,$8b,$43,$43,$49,$66,$bc
>8cd8	84 43 43 49 66 00 0b 9b			.byte	$84,$43,$43,$49,$66,$00,$0b,$9b
>8ce0	00 d9 a6 fe 02 bc 84 40			.byte	$00,$d9,$a6,$fe,$02,$bc,$84,$40
>8ce8	00 1d 9c 00 d9 bb 42 7b			.byte	$00,$1d,$9c,$00,$d9,$bb,$42,$7b
>8cf0	7b 54 fd 04 33 34 8b 42			.byte	$7b,$54,$fd,$04,$33,$34,$8b,$42
>8cf8	7b 7b 54 fd 04 33 34 bc			.byte	$7b,$7b,$54,$fd,$04,$33,$34,$bc
>8d00	84 40 fd 03 30 00 14 9d			.byte	$84,$40,$fd,$03,$30,$00,$14,$9d
>8d08	00 d9 bb 8b 42 40 6d 66			.byte	$00,$d9,$bb,$8b,$42,$40,$6d,$66
>8d10	86 8b 42 40 6d 66 bc 84			.byte	$86,$8b,$42,$40,$6d,$66,$bc,$84
>8d18	40 00 16 9e 00 d9 bb 8b			.byte	$40,$00,$16,$9e,$00,$d9,$bb,$8b
>8d20	42 5d 59 79 82 8b 42 65			.byte	$42,$5d,$59,$79,$82,$8b,$42,$65
>8d28	6e 5b bc 84 78 77 62 00			.byte	$6e,$5b,$bc,$84,$78,$77,$62,$00
>8d30	0f 9f 00 d9 b3 8b 43 4c			.byte	$0f,$9f,$00,$d9,$b3,$8b,$43,$4c
>8d38	57 61 bc 84 8b 41 00 0f			.byte	$57,$61,$bc,$84,$8b,$41,$00,$0f
>8d40	a0 00 d9 9b fe 05 6c 79			.byte	$a0,$00,$d9,$9b,$fe,$05,$6c,$79
>8d48	75 bc 84 41 6c 00 25 a1			.byte	$75,$bc,$84,$41,$6c,$00,$25,$a1
>8d50	00 d9 bb 42 6b 5b 44 fd			.byte	$00,$d9,$bb,$42,$6b,$5b,$44,$fd
>8d58	03 37 8c 42 6b 5b 44 fd			.byte	$03,$37,$8c,$42,$6b,$5b,$44,$fd
>8d60	03 37 bc 84 44 fd 0d 39			.byte	$03,$37,$bc,$84,$44,$fd,$0d,$39
>8d68	33 30 31 32 38 30 34 65			.byte	$33,$30,$31,$32,$38,$30,$34,$65
>8d70	31 31 00 15 a2 00 d9 bb			.byte	$31,$31,$00,$15,$a2,$00,$d9,$bb
>8d78	8b 42 47 68 78 87 8b 42			.byte	$8b,$42,$47,$68,$78,$87,$8b,$42
>8d80	47 68 78 bc 84 8b 41 00			.byte	$47,$68,$78,$bc,$84,$8b,$41,$00
>8d88	0e a3 00 d9 bb 40 80 6d			.byte	$0e,$a3,$00,$d9,$bb,$40,$80,$6d
>8d90	67 4c bc 84 40 00 16 a4			.byte	$67,$4c,$bc,$84,$40,$00,$16,$a4
>8d98	00 d9 b2 8b 41 49 70 50			.byte	$00,$d9,$b2,$8b,$41,$49,$70,$50
>8da0	bd 41 71 77 5a bc 84 41			.byte	$bd,$41,$71,$77,$5a,$bc,$84,$41
>8da8	49 70 50 00 0c a5 00 d9			.byte	$49,$70,$50,$00,$0c,$a5,$00,$d9
>8db0	b4 7c bc 84 fe 03 3c 00			.byte	$b4,$7c,$bc,$84,$fe,$03,$3c,$00
>8db8	1b a6 00 d9 bb 8b 43 51			.byte	$1b,$a6,$00,$d9,$bb,$8b,$43,$51
>8dc0	5d 71 fd 03 37 84 8b 43			.byte	$5d,$71,$fd,$03,$37,$84,$8b,$43
>8dc8	51 5d 71 fd 03 37 bc 84			.byte	$51,$5d,$71,$fd,$03,$37,$bc,$84
>8dd0	8b 41 00 13 a7 00 d9 bb			.byte	$8b,$41,$00,$13,$a7,$00,$d9,$bb
>8dd8	42 4b 7f 6a 85 43 42 7c			.byte	$42,$4b,$7f,$6a,$85,$43,$42,$7c
>8de0	58 bc 84 8b 41 00 15 a8			.byte	$58,$bc,$84,$8b,$41,$00,$15,$a8
>8de8	00 d9 bb 42 60 65 60 82			.byte	$00,$d9,$bb,$42,$60,$65,$60,$82
>8df0	43 60 44 59 bc 84 41 40			.byte	$43,$60,$44,$59,$bc,$84,$41,$40
>8df8	61 79 00 10 a9 00 d9 98			.byte	$61,$79,$00,$10,$a9,$00,$d9,$98
>8e00	42 6c 5d 44 84 8b 42 6c			.byte	$42,$6c,$5d,$44,$84,$8b,$42,$6c
>8e08	5d 45 00 0e aa 00 d9 a3			.byte	$5d,$45,$00,$0e,$aa,$00,$d9,$a3
>8e10	43 bc 84 fe 05 20 20 20			.byte	$43,$bc,$84,$fe,$05,$20,$20,$20
>8e18	00 1a ab 00 d9 bb 42 6b			.byte	$00,$1a,$ab,$00,$d9,$bb,$42,$6b
>8e20	67 57 fd 04 32 35 84 47			.byte	$67,$57,$fd,$04,$32,$35,$84,$47
>8e28	68 62 fd 05 32 33 36 bc			.byte	$68,$62,$fd,$05,$32,$33,$36,$bc
>8e30	84 40 00 10 ac 00 d9 bb			.byte	$84,$40,$00,$10,$ac,$00,$d9,$bb
>8e38	6c 58 64 85 6c 58 64 bc			.byte	$6c,$58,$64,$85,$6c,$58,$64,$bc
>8e40	84 40 00 14 ad 00 d9 bb			.byte	$84,$40,$00,$14,$ad,$00,$d9,$bb
>8e48	40 81 8b 41 56 58 52 bc			.byte	$40,$81,$8b,$41,$56,$58,$52,$bc
>8e50	84 8b 41 56 58 52 00 1a			.byte	$84,$8b,$41,$56,$58,$52,$00,$1a
>8e58	ae 00 d9 a5 a4 42 45 58			.byte	$ae,$00,$d9,$a5,$a4,$42,$45,$58
>8e60	72 fd 04 39 36 bc bc 84			.byte	$72,$fd,$04,$39,$36,$bc,$bc,$84
>8e68	42 45 58 72 fd 04 39 36			.byte	$42,$45,$58,$72,$fd,$04,$39,$36
>8e70	00 12 af 00 d9 a7 7b 4b			.byte	$00,$12,$af,$00,$d9,$a7,$7b,$4b
>8e78	7d bc 84 fe 07 33 42 32			.byte	$7d,$bc,$84,$fe,$07,$33,$42,$32
>8e80	46 44 00 18 b0 00 d9 bb			.byte	$46,$44,$00,$18,$b0,$00,$d9,$bb
>8e88	75 40 72 fd 04 34 33 88			.byte	$75,$40,$72,$fd,$04,$34,$33,$88
>8e90	75 40 72 fd 04 34 33 bc			.byte	$75,$40,$72,$fd,$04,$34,$33,$bc
>8e98	84 40 00 15 b1 00 d9 bb			.byte	$84,$40,$00,$15,$b1,$00,$d9,$bb
>8ea0	8b 42 7a 77 48 89 8b 42			.byte	$8b,$42,$7a,$77,$48,$89,$8b,$42
>8ea8	7a 77 48 bc 84 8b 41 00			.byte	$7a,$77,$48,$bc,$84,$8b,$41,$00
>8eb0	16 b2 00 d9 bb 43 74 45			.byte	$16,$b2,$00,$d9,$bb,$43,$74,$45
>8eb8	65 80 8b 41 4a 70 5e bc			.byte	$65,$80,$8b,$41,$4a,$70,$5e,$bc
>8ec0	84 42 74 45 60 00 0f b3			.byte	$84,$42,$74,$45,$60,$00,$0f,$b3
>8ec8	00 d9 9a 8b 55 60 60 bc			.byte	$00,$d9,$9a,$8b,$55,$60,$60,$bc
>8ed0	84 55 60 60 00 13 b4 00			.byte	$84,$55,$60,$60,$00,$13,$b4,$00
>8ed8	d9 af fe 07 35 35 46 43			.byte	$d9,$af,$fe,$07,$35,$35,$46,$43
>8ee0	42 bc 84 41 55 7f 4b 00			.byte	$42,$bc,$84,$41,$55,$7f,$4b,$00
>8ee8	18 b5 00 d9 bb 5f 6f 71			.byte	$18,$b5,$00,$d9,$bb,$5f,$6f,$71
>8ef0	fd 04 35 36 86 5f 6f 71			.byte	$fd,$04,$35,$36,$86,$5f,$6f,$71
>8ef8	fd 04 35 36 bc 84 40 00			.byte	$fd,$04,$35,$36,$bc,$84,$40,$00
>8f00	0c b6 00 d9 bb 40 8b 40			.byte	$0c,$b6,$00,$d9,$bb,$40,$8b,$40
>8f08	bc 84 40 00 17 b7 00 d9			.byte	$bc,$84,$40,$00,$17,$b7,$00,$d9
>8f10	bb 8b 42 64 72 68 81 41			.byte	$bb,$8b,$42,$64,$72,$68,$81,$41
>8f18	61 45 66 bc 84 8b 42 44			.byte	$61,$45,$66,$bc,$84,$8b,$42,$44
>8f20	72 42 00 0e b8 00 d9 b3			.byte	$72,$42,$00,$0e,$b8,$00,$d9,$b3
>8f28	8b 76 60 68 bc 84 8b 41			.byte	$8b,$76,$60,$68,$bc,$84,$8b,$41
>8f30	00 10 b9 00 d9 a0 fe 03			.byte	$00,$10,$b9,$00,$d9,$a0,$fe,$03
>8f38	65 bd 44 bc 84 fe 03 65			.byte	$65,$bd,$44,$bc,$84,$fe,$03,$65
>8f40	00 1b ba 00 d9 bb 66 64			.byte	$00,$1b,$ba,$00,$d9,$bb,$66,$64
>8f48	68 fd 04 30 32 8d 66 64			.byte	$68,$fd,$04,$30,$32,$8d,$66,$64
>8f50	68 fd 04 30 32 bc 84 41			.byte	$68,$fd,$04,$30,$32,$bc,$84,$41
>8f58	fd 03 30 00 14 bb 00 d9			.byte	$fd,$03,$30,$00,$14,$bb,$00,$d9
>8f60	bb 8b 43 41 5f 7d 85 8b			.byte	$bb,$8b,$43,$41,$5f,$7d,$85,$8b
>8f68	43 41 5f 7d bc 84 40 00			.byte	$43,$41,$5f,$7d,$bc,$84,$40,$00
>8f70	15 bc 00 d9 bb 43 4c 7b			.byte	$15,$bc,$00,$d9,$bb,$43,$4c,$7b
>8f78	61 82 41 4a 4b 71 bc 84			.byte	$61,$82,$41,$4a,$4b,$71,$bc,$84
>8f80	42 46 70 50 00 17 bd 00			.byte	$42,$46,$70,$50,$00,$17,$bd,$00
>8f88	d9 a1 fe 0b 75 64 72 66			.byte	$d9,$a1,$fe,$0b,$75,$64,$72,$66
>8f90	6b 73 6d 6c 66 bd 40 bc			.byte	$6b,$73,$6d,$6c,$66,$bd,$40,$bc
>8f98	84 fe 02 00 1d be 00 d9			.byte	$84,$fe,$02,$00,$1d,$be,$00,$d9
>8fa0	bb 42 51 41 51 fd 04 37			.byte	$bb,$42,$51,$41,$51,$fd,$04,$37
>8fa8	39 8b 42 51 41 51 fd 04			.byte	$39,$8b,$42,$51,$41,$51,$fd,$04
>8fb0	37 39 bc 84 40 fd 03 30			.byte	$37,$39,$bc,$84,$40,$fd,$03,$30
>8fb8	00 13 bf 00 d9 bb 8b 57			.byte	$00,$13,$bf,$00,$d9,$bb,$8b,$57
>8fc0	52 52 89 8b 57 52 52 bc			.byte	$52,$52,$89,$8b,$57,$52,$52,$bc
>8fc8	84 8b 41 00 17 c0 00 d9			.byte	$84,$8b,$41,$00,$17,$c0,$00,$d9
>8fd0	bb 8b 41 6f 76 5d 81 8b			.byte	$bb,$8b,$41,$6f,$76,$5d,$81,$8b
>8fd8	42 55 7b 48 bc 84 8b 45			.byte	$42,$55,$7b,$48,$bc,$84,$8b,$45
>8fe0	72 45 00 0e c1 00 d9 98			.byte	$72,$45,$00,$0e,$c1,$00,$d9,$98
>8fe8	78 72 61 84 8b 78 72 62			.byte	$78,$72,$61,$84,$8b,$78,$72,$62
>8ff0	00 1a c2 00 d9 a2 fe 0b			.byte	$00,$1a,$c2,$00,$d9,$a2,$fe,$0b
>8ff8	76 77 6b 67 69 6e 6f 6e			.byte	$76,$77,$6b,$67,$69,$6e,$6f,$6e
>9000	71 bd 49 bd 4a bc 84 fe			.byte	$71,$bd,$49,$bd,$4a,$bc,$84,$fe
>9008	03 71 00 27 c3 00 d9 bb			.byte	$03,$71,$00,$27,$c3,$00,$d9,$bb
>9010	42 69 55 41 fd 04 32 35			.byte	$42,$69,$55,$41,$fd,$04,$32,$35
>9018	8c 42 69 55 41 fd 04 32			.byte	$8c,$42,$69,$55,$41,$fd,$04,$32
>9020	35 bc 84 44 fd 0d 38 31			.byte	$35,$bc,$84,$44,$fd,$0d,$38,$31
>9028	30 33 38 33 30 37 65 31			.byte	$30,$33,$38,$33,$30,$37,$65,$31
>9030	31 00 15 c4 00 d9 bb 8b			.byte	$31,$00,$15,$c4,$00,$d9,$bb,$8b
>9038	42 48 6a 74 84 8b 42 48			.byte	$42,$48,$6a,$74,$84,$8b,$42,$48
>9040	6a 74 bc 84 8b 41 00 15			.byte	$6a,$74,$bc,$84,$8b,$41,$00,$15
>9048	c5 00 d9 bb 42 64 51 6c			.byte	$c5,$00,$d9,$bb,$42,$64,$51,$6c
>9050	81 42 77 6a 79 bc 84 42			.byte	$81,$42,$77,$6a,$79,$bc,$84,$42
>9058	77 7b 7d 00 1c c6 00 d9			.byte	$77,$7b,$7d,$00,$1c,$c6,$00,$d9
>9060	a5 a4 8b 42 60 50 52 fd			.byte	$a5,$a4,$8b,$42,$60,$50,$52,$fd
>9068	04 37 37 bc bc 84 8b 42			.byte	$04,$37,$37,$bc,$bc,$84,$8b,$42
>9070	60 50 52 fd 04 37 37 00			.byte	$60,$50,$52,$fd,$04,$37,$37,$00
>9078	0d c7 00 d9 a6 fe 04 74			.byte	$0d,$c7,$00,$d9,$a6,$fe,$04,$74
>9080	79 bc 84 42 00 1b c8 00			.byte	$79,$bc,$84,$42,$00,$1b,$c8,$00
>9088	d9 bb 8b 60 4e 5c fd 04			.byte	$d9,$bb,$8b,$60,$4e,$5c,$fd,$04
>9090	36 32 87 8b 60 4e 5c fd			.byte	$36,$32,$87,$8b,$60,$4e,$5c,$fd
>9098	04 36 32 bc 84 8b 41 00			.byte	$04,$36,$32,$bc,$84,$8b,$41,$00
>90a0	13 c9 00 d9 bb 41 5c 7b			.byte	$13,$c9,$00,$d9,$bb,$41,$5c,$7b
>90a8	4c 84 41 5c 7b 4c bc 84			.byte	$4c,$84,$41,$5c,$7b,$4c,$bc,$84
>90b0	8b 41 00 15 ca 00 d9 bb			.byte	$8b,$41,$00,$15,$ca,$00,$d9,$bb
>90b8	42 72 67 69 81 8b 7a 44			.byte	$42,$72,$67,$69,$81,$8b,$7a,$44
>90c0	6c bc 84 8b 48 40 43 00			.byte	$6c,$bc,$84,$8b,$48,$40,$43,$00
>90c8	0a cb 00 d9 9a 40 bc 84			.byte	$0a,$cb,$00,$d9,$9a,$40,$bc,$84
>90d0	40 00 0d cc 00 d9 9b fe			.byte	$40,$00,$0d,$cc,$00,$d9,$9b,$fe
>90d8	03 78 bc 84 41 78 00 16			.byte	$03,$78,$bc,$84,$41,$78,$00,$16
>90e0	cd 00 d9 bb 5c 6d 58 fd			.byte	$cd,$00,$d9,$bb,$5c,$6d,$58,$fd
>90e8	03 38 85 5c 6d 58 fd 03			.byte	$03,$38,$85,$5c,$6d,$58,$fd,$03
>90f0	38 bc 84 40 00 13 ce 00			.byte	$38,$bc,$84,$40,$00,$13,$ce,$00
>90f8	d9 bb 42 5d 65 59 89 42			.byte	$d9,$bb,$42,$5d,$65,$59,$89,$42
>9100	5d 65 59 bc 84 8b 41 00			.byte	$5d,$65,$59,$bc,$84,$8b,$41,$00
>9108	17 cf 00 d9 bb 8b 41 47			.byte	$17,$cf,$00,$d9,$bb,$8b,$41,$47
>9110	44 45 80 8b 5e 6c 64 bc			.byte	$44,$45,$80,$8b,$5e,$6c,$64,$bc
>9118	84 8b 41 5f 6c 68 00 0a			.byte	$84,$8b,$41,$5f,$6c,$68,$00,$0a
>9120	d0 00 d9 b3 40 bc 84 40			.byte	$d0,$00,$d9,$b3,$40,$bc,$84,$40
>9128	00 0d d1 00 d9 b4 41 67			.byte	$00,$0d,$d1,$00,$d9,$b4,$41,$67
>9130	bc 84 fe 03 67 00 1d d2			.byte	$bc,$84,$fe,$03,$67,$00,$1d,$d2
>9138	00 d9 bb 8b 41 5f 6d 7d			.byte	$00,$d9,$bb,$8b,$41,$5f,$6d,$7d
>9140	fd 04 31 35 87 8b 41 5f			.byte	$fd,$04,$31,$35,$87,$8b,$41,$5f
>9148	6d 7d fd 04 31 35 bc 84			.byte	$6d,$7d,$fd,$04,$31,$35,$bc,$84
>9150	8b 41 00 14 d3 00 d9 bb			.byte	$8b,$41,$00,$14,$d3,$00,$d9,$bb
>9158	8b 42 59 76 60 86 8b 42			.byte	$8b,$42,$59,$76,$60,$86,$8b,$42
>9160	59 76 60 bc 84 40 00 17			.byte	$59,$76,$60,$bc,$84,$40,$00,$17
>9168	d4 00 d9 bb 8b 42 68 4c			.byte	$d4,$00,$d9,$bb,$8b,$42,$68,$4c
>9170	75 82 41 62 6a 57 bc 84			.byte	$75,$82,$41,$62,$6a,$57,$bc,$84
>9178	8b 43 4a 66 64 00 13 d5			.byte	$8b,$43,$4a,$66,$64,$00,$13,$d5
>9180	00 d9 b2 42 5b 53 4f bd			.byte	$00,$d9,$b2,$42,$5b,$53,$4f,$bd
>9188	64 62 7a bc 84 49 47 67			.byte	$64,$62,$7a,$bc,$84,$49,$47,$67
>9190	00 1e d6 00 d9 a3 53 bc			.byte	$00,$1e,$d6,$00,$d9,$a3,$53,$bc
>9198	84 fe 15 20 20 20 20 20			.byte	$84,$fe,$15,$20,$20,$20,$20,$20
>91a0	20 20 20 20 20 20 20 20			.byte	$20,$20,$20,$20,$20,$20,$20,$20
>91a8	20 20 20 20 20 20 00 1b			.byte	$20,$20,$20,$20,$20,$20,$00,$1b
>91b0	d7 00 d9 bb 8b 76 47 57			.byte	$d7,$00,$d9,$bb,$8b,$76,$47,$57
>91b8	fd 04 32 39 89 8b 76 47			.byte	$fd,$04,$32,$39,$89,$8b,$76,$47
>91c0	57 fd 04 32 39 bc 84 8b			.byte	$57,$fd,$04,$32,$39,$bc,$84,$8b
>91c8	41 00 13 d8 00 d9 bb 69			.byte	$41,$00,$13,$d8,$00,$d9,$bb,$69
>91d0	6f 48 8a 69 6f 48 bc 84			.byte	$6f,$48,$8a,$69,$6f,$48,$bc,$84
>91d8	41 53 5e 50 00 18 d9 00			.byte	$41,$53,$5e,$50,$00,$18,$d9,$00
>91e0	d9 bb 8b 43 60 64 54 80			.byte	$d9,$bb,$8b,$43,$60,$64,$54,$80
>91e8	8b 42 4d 49 56 bc 84 8b			.byte	$8b,$42,$4d,$49,$56,$bc,$84,$8b
>91f0	43 6d 6d 58 00 10 da 00			.byte	$43,$6d,$6d,$58,$00,$10,$da,$00
>91f8	d9 98 42 6f 43 50 84 8b			.byte	$d9,$98,$42,$6f,$43,$50,$84,$8b
>9200	42 6f 43 51 00 13 db 00			.byte	$42,$6f,$43,$51,$00,$13,$db,$00
>9208	d9 a7 43 60 71 7e bc 84			.byte	$d9,$a7,$43,$60,$71,$7e,$bc,$84
>9210	fe 07 45 30 43 37 45 00			.byte	$fe,$07,$45,$30,$43,$37,$45,$00
>9218	1a dc 00 d9 bb 41 61 57			.byte	$1a,$dc,$00,$d9,$bb,$41,$61,$57
>9220	7c fd 04 30 37 88 41 61			.byte	$7c,$fd,$04,$30,$37,$88,$41,$61
>9228	57 7c fd 04 30 37 bc 84			.byte	$57,$7c,$fd,$04,$30,$37,$bc,$84
>9230	40 00 10 dd 00 d9 bb 7c			.byte	$40,$00,$10,$dd,$00,$d9,$bb,$7c
>9238	5d 48 85 7c 5d 48 bc 84			.byte	$5d,$48,$85,$7c,$5d,$48,$bc,$84
>9240	40 00 15 de 00 d9 bb 41			.byte	$40,$00,$15,$de,$00,$d9,$bb,$41
>9248	60 65 61 80 8b 77 5b 54			.byte	$60,$65,$61,$80,$8b,$77,$5b,$54
>9250	bc 84 41 40 64 60 00 18			.byte	$bc,$84,$41,$40,$64,$60,$00,$18
>9258	df 00 d9 a5 a4 43 69 4b			.byte	$df,$00,$d9,$a5,$a4,$43,$69,$4b
>9260	61 fd 03 34 bc bc 84 43			.byte	$61,$fd,$03,$34,$bc,$bc,$84,$43
>9268	69 4b 61 fd 03 34 00 13			.byte	$69,$4b,$61,$fd,$03,$34,$00,$13
>9270	e0 00 d9 af fe 07 36 39			.byte	$e0,$00,$d9,$af,$fe,$07,$36,$39
>9278	36 31 46 bc 84 41 69 58			.byte	$36,$31,$46,$bc,$84,$41,$69,$58
>9280	5f 00 29 e1 00 d9 bb 8b			.byte	$5f,$00,$29,$e1,$00,$d9,$bb,$8b
>9288	50 4e 53 fd 05 32 32 31			.byte	$50,$4e,$53,$fd,$05,$32,$32,$31
>9290	8c 8b 50 4e 53 fd 05 32			.byte	$8c,$8b,$50,$4e,$53,$fd,$05,$32
>9298	32 31 bc 84 44 fd 0d 34			.byte	$32,$31,$bc,$84,$44,$fd,$0d,$34
>92a0	31 35 37 36 34 37 37 65			.byte	$31,$35,$37,$36,$34,$37,$37,$65
>92a8	30 39 00 12 e2 00 d9 bb			.byte	$30,$39,$00,$12,$e2,$00,$d9,$bb
>92b0	42 66 60 69 88 42 66 60			.byte	$42,$66,$60,$69,$88,$42,$66,$60
>92b8	69 bc 84 40 00 16 e3 00			.byte	$69,$bc,$84,$40,$00,$16,$e3,$00
>92c0	d9 bb 8b 43 72 59 57 81			.byte	$d9,$bb,$8b,$43,$72,$59,$57,$81
>92c8	65 7a 47 bc 84 8b 43 52			.byte	$65,$7a,$47,$bc,$84,$8b,$43,$52
>92d0	41 51 00 10 e4 00 d9 9a			.byte	$41,$51,$00,$10,$e4,$00,$d9,$9a
>92d8	41 5e 79 63 bc 84 41 5e			.byte	$41,$5e,$79,$63,$bc,$84,$41,$5e
>92e0	79 63 00 18 e5 00 d9 a0			.byte	$79,$63,$00,$18,$e5,$00,$d9,$a0
>92e8	fe 0a 61 64 74 7a 67 76			.byte	$fe,$0a,$61,$64,$74,$7a,$67,$76
>92f0	6f 6e bd 42 bc 84 fe 04			.byte	$6f,$6e,$bd,$42,$bc,$84,$fe,$04
>92f8	61 64 00 1d e6 00 d9 bb			.byte	$61,$64,$00,$1d,$e6,$00,$d9,$bb
>9300	8b 41 6d 71 74 fd 04 31			.byte	$8b,$41,$6d,$71,$74,$fd,$04,$31
>9308	32 87 8b 41 6d 71 74 fd			.byte	$32,$87,$8b,$41,$6d,$71,$74,$fd
>9310	04 31 32 bc 84 8b 41 00			.byte	$04,$31,$32,$bc,$84,$8b,$41,$00
>9318	13 e7 00 d9 bb 8b 73 57			.byte	$13,$e7,$00,$d9,$bb,$8b,$73,$57
>9320	66 89 8b 73 57 66 bc 84			.byte	$66,$89,$8b,$73,$57,$66,$bc,$84
>9328	8b 41 00 15 e8 00 d9 bb			.byte	$8b,$41,$00,$15,$e8,$00,$d9,$bb
>9330	42 4a 4e 73 80 8b 46 6a			.byte	$42,$4a,$4e,$73,$80,$8b,$46,$6a
>9338	7c bc 84 42 48 44 40 00			.byte	$7c,$bc,$84,$42,$48,$44,$40,$00
>9340	0f e9 00 d9 b3 8b 41 60			.byte	$0f,$e9,$00,$d9,$b3,$8b,$41,$60
>9348	55 67 bc 84 8b 41 00 11			.byte	$55,$67,$bc,$84,$8b,$41,$00,$11
>9350	ea 00 d9 a1 fe 05 62 75			.byte	$ea,$00,$d9,$a1,$fe,$05,$62,$75
>9358	77 bd 40 bc 84 fe 02 00			.byte	$77,$bd,$40,$bc,$84,$fe,$02,$00
>9360	1a eb 00 d9 bb 43 4c 71			.byte	$1a,$eb,$00,$d9,$bb,$43,$4c,$71
>9368	6b fd 04 31 38 88 43 4c			.byte	$6b,$fd,$04,$31,$38,$88,$43,$4c
>9370	71 6b fd 04 31 38 bc 84			.byte	$71,$6b,$fd,$04,$31,$38,$bc,$84
>9378	40 00 15 ec 00 d9 bb 8b			.byte	$40,$00,$15,$ec,$00,$d9,$bb,$8b
>9380	41 6b 62 41 89 8b 41 6b			.byte	$41,$6b,$62,$41,$89,$8b,$41,$6b
>9388	62 41 bc 84 8b 41 00 14			.byte	$62,$41,$bc,$84,$8b,$41,$00,$14
>9390	ed 00 d9 bb 42 54 46 54			.byte	$ed,$00,$d9,$bb,$42,$54,$46,$54
>9398	82 56 6f 55 bc 84 42 42			.byte	$82,$56,$6f,$55,$bc,$84,$42,$42
>93a0	69 41 00 16 ee 00 d9 b2			.byte	$69,$41,$00,$16,$ee,$00,$d9,$b2
>93a8	8b 43 53 73 79 bd 8b 42			.byte	$8b,$43,$53,$73,$79,$bd,$8b,$42
>93b0	5e 6e 62 bc 84 75 45 57			.byte	$5e,$6e,$62,$bc,$84,$75,$45,$57
>93b8	00 17 ef 00 d9 a2 fe 08			.byte	$00,$17,$ef,$00,$d9,$a2,$fe,$08
>93c0	73 77 72 63 7a 66 bd 45			.byte	$73,$77,$72,$63,$7a,$66,$bd,$45
>93c8	bd 41 bc 84 fe 03 7a 00			.byte	$bd,$41,$bc,$84,$fe,$03,$7a,$00
>93d0	1d f0 00 d9 bb 8b 42 7f			.byte	$1d,$f0,$00,$d9,$bb,$8b,$42,$7f
>93d8	59 71 fd 04 36 38 89 8b			.byte	$59,$71,$fd,$04,$36,$38,$89,$8b
>93e0	42 7f 59 71 fd 04 36 38			.byte	$42,$7f,$59,$71,$fd,$04,$36,$38
>93e8	bc 84 8b 41 00 15 f1 00			.byte	$bc,$84,$8b,$41,$00,$15,$f1,$00
>93f0	d9 bb 8b 42 50 74 75 84			.byte	$d9,$bb,$8b,$42,$50,$74,$75,$84
>93f8	8b 42 50 74 75 bc 84 8b			.byte	$8b,$42,$50,$74,$75,$bc,$84,$8b
>9400	41 00 16 f2 00 d9 bb 8b			.byte	$41,$00,$16,$f2,$00,$d9,$bb,$8b
>9408	46 52 69 82 43 58 4f 48			.byte	$46,$52,$69,$82,$43,$58,$4f,$48
>9410	bc 84 8b 43 5e 5d 61 00			.byte	$bc,$84,$8b,$43,$5e,$5d,$61,$00
>9418	0a f3 00 d9 98 40 84 8b			.byte	$0a,$f3,$00,$d9,$98,$40,$84,$8b
>9420	41 00 0b f4 00 d9 a6 fe			.byte	$41,$00,$0b,$f4,$00,$d9,$a6,$fe
>9428	02 bc 84 40 00 1c f5 00			.byte	$02,$bc,$84,$40,$00,$1c,$f5,$00
>9430	d9 bb 8b 42 63 5e 45 fd			.byte	$d9,$bb,$8b,$42,$63,$5e,$45,$fd
>9438	04 34 32 85 8b 42 63 5e			.byte	$04,$34,$32,$85,$8b,$42,$63,$5e
>9440	45 fd 04 34 32 bc 84 40			.byte	$45,$fd,$04,$34,$32,$bc,$84,$40
>9448	00 13 f6 00 d9 bb 41 42			.byte	$00,$13,$f6,$00,$d9,$bb,$41,$42
>9450	56 65 87 41 42 56 65 bc			.byte	$56,$65,$87,$41,$42,$56,$65,$bc
>9458	84 8b 41 00 13 f7 00 d9			.byte	$84,$8b,$41,$00,$13,$f7,$00,$d9
>9460	bb 41 58 53 56 80 6a 47			.byte	$bb,$41,$58,$53,$56,$80,$6a,$47
>9468	43 bc 84 48 43 42 00 1a			.byte	$43,$bc,$84,$48,$43,$42,$00,$1a
>9470	f8 00 d9 a5 a4 8b 6f 56			.byte	$f8,$00,$d9,$a5,$a4,$8b,$6f,$56
>9478	47 fd 04 31 34 bc bc 84			.byte	$47,$fd,$04,$31,$34,$bc,$bc,$84
>9480	8b 6f 56 47 fd 04 31 34			.byte	$8b,$6f,$56,$47,$fd,$04,$31,$34
>9488	00 0d f9 00 d9 9b fe 03			.byte	$00,$0d,$f9,$00,$d9,$9b,$fe,$03
>9490	76 bc 84 41 76 00 1f fa			.byte	$76,$bc,$84,$41,$76,$00,$1f,$fa
>9498	00 d9 bb 8b 41 76 5a 51			.byte	$00,$d9,$bb,$8b,$41,$76,$5a,$51
>94a0	fd 04 33 36 8b 8b 41 76			.byte	$fd,$04,$33,$36,$8b,$8b,$41,$76
>94a8	5a 51 fd 04 33 36 bc 84			.byte	$5a,$51,$fd,$04,$33,$36,$bc,$84
>94b0	40 fd 03 30 00 12 fb 00			.byte	$40,$fd,$03,$30,$00,$12,$fb,$00
>94b8	d9 bb 42 56 53 58 8d 42			.byte	$d9,$bb,$42,$56,$53,$58,$8d,$42
>94c0	56 53 58 bc 84 41 00 10			.byte	$56,$53,$58,$bc,$84,$41,$00,$10
>94c8	fc 00 d9 bb 8b 43 5d 57			.byte	$fc,$00,$d9,$bb,$8b,$43,$5d,$57
>94d0	79 80 40 bc 84 40 00 0a			.byte	$79,$80,$40,$bc,$84,$40,$00,$0a
>94d8	fd 00 d9 9a 40 bc 84 40			.byte	$fd,$00,$d9,$9a,$40,$bc,$84,$40
>94e0	00 0c fe 00 d9 b4 66 bc			.byte	$00,$0c,$fe,$00,$d9,$b4,$66,$bc
>94e8	84 fe 03 26 00 18 ff 00			.byte	$84,$fe,$03,$26,$00,$18,$ff,$00
>94f0	d9 bb 61 55 6d fd 04 31			.byte	$d9,$bb,$61,$55,$6d,$fd,$04,$31
>94f8	37 86 61 55 6d fd 04 31			.byte	$37,$86,$61,$55,$6d,$fd,$04,$31
>9500	37 bc 84 40 00 13 00 01			.byte	$37,$bc,$84,$40,$00,$13,$00,$01
>9508	d9 bb 42 7b 55 61 87 42			.byte	$d9,$bb,$42,$7b,$55,$61,$87,$42
>9510	7b 55 61 bc 84 8b 41 00			.byte	$7b,$55,$61,$bc,$84,$8b,$41,$00
>9518	16 01 01 d9 bb 8b 4f 49			.byte	$16,$01,$01,$d9,$bb,$8b,$4f,$49
>9520	55 81 8b 43 55 5b 52 bc			.byte	$55,$81,$8b,$43,$55,$5b,$52,$bc
>9528	84 8b 45 49 51 00 0c 02			.byte	$84,$8b,$45,$49,$51,$00,$0c,$02
>9530	01 d9 b3 4e 5c 70 bc 84			.byte	$01,$d9,$b3,$4e,$5c,$70,$bc,$84
>9538	41 00 13 03 01 d9 a3 48			.byte	$41,$00,$13,$03,$01,$d9,$a3,$48
>9540	bc 84 fe 0a 20 20 20 20			.byte	$bc,$84,$fe,$0a,$20,$20,$20,$20
>9548	20 20 20 20 00 1b 04 01			.byte	$20,$20,$20,$20,$00,$1b,$04,$01
>9550	d9 bb 43 6b 45 50 fd 04			.byte	$d9,$bb,$43,$6b,$45,$50,$fd,$04
>9558	39 38 87 43 6b 45 50 fd			.byte	$39,$38,$87,$43,$6b,$45,$50,$fd
>9560	04 39 38 bc 84 8b 41 00			.byte	$04,$39,$38,$bc,$84,$8b,$41,$00
>9568	14 05 01 d9 bb 8b 42 4d			.byte	$14,$05,$01,$d9,$bb,$8b,$42,$4d
>9570	43 5b 88 8b 41 74 59 7e			.byte	$43,$5b,$88,$8b,$41,$74,$59,$7e
>9578	bc 84 40 00 15 06 01 d9			.byte	$bc,$84,$40,$00,$15,$06,$01,$d9
>9580	bb 42 73 4d 5f 80 42 66			.byte	$bb,$42,$73,$4d,$5f,$80,$42,$66
>9588	7b 50 bc 84 42 62 49 50			.byte	$7b,$50,$bc,$84,$42,$62,$49,$50
>9590	00 0f 07 01 d9 b2 40 bd			.byte	$00,$0f,$07,$01,$d9,$b2,$40,$bd
>9598	42 4e 6f 50 bc 84 40 00			.byte	$42,$4e,$6f,$50,$bc,$84,$40,$00
>95a0	12 08 01 d9 a7 68 7c 44			.byte	$12,$08,$01,$d9,$a7,$68,$7c,$44
>95a8	bc 84 fe 07 32 38 46 30			.byte	$bc,$84,$fe,$07,$32,$38,$46,$30
>95b0	34 00 19 09 01 d9 bb 70			.byte	$34,$00,$19,$09,$01,$d9,$bb,$70
>95b8	61 7b fd 04 31 39 87 70			.byte	$61,$7b,$fd,$04,$31,$39,$87,$70
>95c0	61 7b fd 04 31 39 bc 84			.byte	$61,$7b,$fd,$04,$31,$39,$bc,$84
>95c8	8b 41 00 15 0a 01 d9 bb			.byte	$8b,$41,$00,$15,$0a,$01,$d9,$bb
>95d0	42 6b 59 66 8a 42 6b 59			.byte	$42,$6b,$59,$66,$8a,$42,$6b,$59
>95d8	66 bc 84 45 56 73 4c 00			.byte	$66,$bc,$84,$45,$56,$73,$4c,$00
>95e0	14 0b 01 d9 bb 42 64 40			.byte	$14,$0b,$01,$d9,$bb,$42,$64,$40
>95e8	6d 81 7e 5f 56 bc 84 42			.byte	$6d,$81,$7e,$5f,$56,$bc,$84,$42
>95f0	7e 5f 7f 00 10 0c 01 d9			.byte	$7e,$5f,$7f,$00,$10,$0c,$01,$d9
>95f8	98 41 5b 51 50 84 8b 41			.byte	$98,$41,$5b,$51,$50,$84,$8b,$41
>9600	5b 51 51 00 0c 0d 01 d9			.byte	$5b,$51,$51,$00,$0c,$0d,$01,$d9
>9608	af fe 03 30 bc 84 40 00			.byte	$af,$fe,$03,$30,$bc,$84,$40,$00
>9610	1d 0e 01 d9 bb 41 79 6c			.byte	$1d,$0e,$01,$d9,$bb,$41,$79,$6c
>9618	4b fd 04 32 34 8d 41 79			.byte	$4b,$fd,$04,$32,$34,$8d,$41,$79
>9620	6c 4b fd 04 32 34 bc 84			.byte	$6c,$4b,$fd,$04,$32,$34,$bc,$84
>9628	41 fd 03 30 00 0c 0f 01			.byte	$41,$fd,$03,$30,$00,$0c,$0f,$01
>9630	d9 bb 40 86 40 bc 84 40			.byte	$d9,$bb,$40,$86,$40,$bc,$84,$40
>9638	00 18 10 01 d9 bb 8b 43			.byte	$00,$18,$10,$01,$d9,$bb,$8b,$43
>9640	4a 67 70 80 8b 43 6d 6b			.byte	$4a,$67,$70,$80,$8b,$43,$6d,$6b
>9648	4c bc 84 8b 43 6f 6f 70			.byte	$4c,$bc,$84,$8b,$43,$6f,$6f,$70
>9650	00 12 11 01 d9 a5 a4 41			.byte	$00,$12,$11,$01,$d9,$a5,$a4,$41
>9658	71 66 4e bc bc 84 41 71			.byte	$71,$66,$4e,$bc,$bc,$84,$41,$71
>9660	66 4e 00 11 12 01 d9 a0			.byte	$66,$4e,$00,$11,$12,$01,$d9,$a0
>9668	fe 05 65 6c 63 bd 40 bc			.byte	$fe,$05,$65,$6c,$63,$bd,$40,$bc
>9670	84 fe 02 00 1b 13 01 d9			.byte	$84,$fe,$02,$00,$1b,$13,$01,$d9
>9678	bb 42 71 7b 40 fd 04 33			.byte	$bb,$42,$71,$7b,$40,$fd,$04,$33
>9680	39 84 42 71 7b 40 fd 04			.byte	$39,$84,$42,$71,$7b,$40,$fd,$04
>9688	33 39 bc 84 8b 41 00 15			.byte	$33,$39,$bc,$84,$8b,$41,$00,$15
>9690	14 01 d9 bb 8b 43 62 6f			.byte	$14,$01,$d9,$bb,$8b,$43,$62,$6f
>9698	74 87 8b 43 62 6f 74 bc			.byte	$74,$87,$8b,$43,$62,$6f,$74,$bc
>96a0	84 8b 41 00 0c 15 01 d9			.byte	$84,$8b,$41,$00,$0c,$15,$01,$d9
>96a8	bb 40 80 40 bc 84 40 00			.byte	$bb,$40,$80,$40,$bc,$84,$40,$00
>96b0	10 16 01 d9 9a 41 69 42			.byte	$10,$16,$01,$d9,$9a,$41,$69,$42
>96b8	46 bc 84 41 69 42 46 00			.byte	$46,$bc,$84,$41,$69,$42,$46,$00
>96c0	13 17 01 d9 a1 fe 05 61			.byte	$13,$17,$01,$d9,$a1,$fe,$05,$61
>96c8	74 64 bd 42 bc 84 fe 04			.byte	$74,$64,$bd,$42,$bc,$84,$fe,$04
>96d0	74 64 00 1c 18 01 d9 bb			.byte	$74,$64,$00,$1c,$18,$01,$d9,$bb
>96d8	8b 42 46 4d 59 fd 04 33			.byte	$8b,$42,$46,$4d,$59,$fd,$04,$33
>96e0	38 86 8b 42 46 4d 59 fd			.byte	$38,$86,$8b,$42,$46,$4d,$59,$fd
>96e8	04 33 38 bc 84 40 00 12			.byte	$04,$33,$38,$bc,$84,$40,$00,$12
>96f0	19 01 d9 bb 8b 56 67 5f			.byte	$19,$01,$d9,$bb,$8b,$56,$67,$5f
>96f8	86 8b 56 67 5f bc 84 40			.byte	$86,$8b,$56,$67,$5f,$bc,$84,$40
>9700	00 12 1a 01 d9 bb 43 6c			.byte	$00,$12,$1a,$01,$d9,$bb,$43,$6c
>9708	60 7a 82 40 bc 84 43 6c			.byte	$60,$7a,$82,$40,$bc,$84,$43,$6c
>9710	60 7a 00 0e 1b 01 d9 b3			.byte	$60,$7a,$00,$0e,$1b,$01,$d9,$b3
>9718	8b 5a 76 7d bc 84 8b 41			.byte	$8b,$5a,$76,$7d,$bc,$84,$8b,$41
>9720	00 16 1c 01 d9 a2 fe 06			.byte	$00,$16,$1c,$01,$d9,$a2,$fe,$06
>9728	79 73 69 62 bd 41 bd 42			.byte	$79,$73,$69,$62,$bd,$41,$bd,$42
>9730	bc 84 fe 04 79 73 00 1d			.byte	$bc,$84,$fe,$04,$79,$73,$00,$1d
>9738	1d 01 d9 bb 8b 42 5c 7c			.byte	$1d,$01,$d9,$bb,$8b,$42,$5c,$7c
>9740	69 fd 04 32 36 87 8b 42			.byte	$69,$fd,$04,$32,$36,$87,$8b,$42
>9748	5c 7c 69 fd 04 32 36 bc			.byte	$5c,$7c,$69,$fd,$04,$32,$36,$bc
>9750	84 8b 41 00 0d 1e 01 d9			.byte	$84,$8b,$41,$00,$0d,$1e,$01,$d9
>9758	bb 40 89 40 bc 84 8b 41			.byte	$bb,$40,$89,$40,$bc,$84,$8b,$41
>9760	00 18 1f 01 d9 bb 8b 41			.byte	$00,$18,$1f,$01,$d9,$bb,$8b,$41
>9768	4d 4d 77 80 8b 41 5c 69			.byte	$4d,$4d,$77,$80,$8b,$41,$5c,$69
>9770	53 bc 84 8b 41 5d 6d 77			.byte	$53,$bc,$84,$8b,$41,$5d,$6d,$77
>9778	00 0e 20 01 d9 b2 40 bd			.byte	$00,$0e,$20,$01,$d9,$b2,$40,$bd
>9780	70 46 5d bc 84 40 00 0b			.byte	$70,$46,$5d,$bc,$84,$40,$00,$0b
>9788	21 01 d9 a6 fe 02 bc 84			.byte	$21,$01,$d9,$a6,$fe,$02,$bc,$84
>9790	40 00 1d 22 01 d9 bb 43			.byte	$40,$00,$1d,$22,$01,$d9,$bb,$43
>9798	53 4b 79 fd 04 33 38 8d			.byte	$53,$4b,$79,$fd,$04,$33,$38,$8d
>97a0	43 53 4b 79 fd 04 33 38			.byte	$43,$53,$4b,$79,$fd,$04,$33,$38
>97a8	bc 84 41 fd 03 30 00 14			.byte	$bc,$84,$41,$fd,$03,$30,$00,$14
>97b0	23 01 d9 bb 8b 41 78 4a			.byte	$23,$01,$d9,$bb,$8b,$41,$78,$4a
>97b8	4c 8d 8b 41 78 4a 4c bc			.byte	$4c,$8d,$8b,$41,$78,$4a,$4c,$bc
>97c0	84 41 00 17 24 01 d9 bb			.byte	$84,$41,$00,$17,$24,$01,$d9,$bb
>97c8	42 4f 5d 74 81 8b 41 66			.byte	$42,$4f,$5d,$74,$81,$8b,$41,$66
>97d0	4e 61 bc 84 8b 41 60 42			.byte	$4e,$61,$bc,$84,$8b,$41,$60,$42
>97d8	41 00 10 25 01 d9 98 42			.byte	$41,$00,$10,$25,$01,$d9,$98,$42
>97e0	54 74 6f 84 8b 42 54 74			.byte	$54,$74,$6f,$84,$8b,$42,$54,$74
>97e8	70 00 11 26 01 d9 9b fe			.byte	$70,$00,$11,$26,$01,$d9,$9b,$fe
>97f0	07 61 61 66 7a 74 bc 84			.byte	$07,$61,$61,$66,$7a,$74,$bc,$84
>97f8	41 61 00 24 27 01 d9 bb			.byte	$41,$61,$00,$24,$27,$01,$d9,$bb
>9800	8b 41 71 4b 7c fd 04 39			.byte	$8b,$41,$71,$4b,$7c,$fd,$04,$39
>9808	31 8a 8b 41 71 4b 7c fd			.byte	$31,$8a,$8b,$41,$71,$4b,$7c,$fd
>9810	04 39 31 bc 84 8b 43 62			.byte	$04,$39,$31,$bc,$84,$8b,$43,$62
>9818	57 79 fd 04 38 31 00 0d			.byte	$57,$79,$fd,$04,$38,$31,$00,$0d
>9820	28 01 d9 bb 40 89 40 bc			.byte	$28,$01,$d9,$bb,$40,$89,$40,$bc
>9828	84 8b 41 00 17 29 01 d9			.byte	$84,$8b,$41,$00,$17,$29,$01,$d9
>9830	bb 8b 43 56 63 5f 82 41			.byte	$bb,$8b,$43,$56,$63,$5f,$82,$41
>9838	55 59 4c bc 84 8b 42 43			.byte	$55,$59,$4c,$bc,$84,$8b,$42,$43
>9840	7a 53 00 14 2a 01 d9 a5			.byte	$7a,$53,$00,$14,$2a,$01,$d9,$a5
>9848	a4 8b 43 40 6b 4f bc bc			.byte	$a4,$8b,$43,$40,$6b,$4f,$bc,$bc
>9850	84 8b 43 40 6b 4f 00 0d			.byte	$84,$8b,$43,$40,$6b,$4f,$00,$0d
>9858	2b 01 d9 b4 41 5b bc 84			.byte	$2b,$01,$d9,$b4,$41,$5b,$bc,$84
>9860	fe 03 5b 00 1b 2c 01 d9			.byte	$fe,$03,$5b,$00,$1b,$2c,$01,$d9
>9868	bb 8b 5b 66 50 fd 04 36			.byte	$bb,$8b,$5b,$66,$50,$fd,$04,$36
>9870	34 89 8b 5b 66 50 fd 04			.byte	$34,$89,$8b,$5b,$66,$50,$fd,$04
>9878	36 34 bc 84 8b 41 00 12			.byte	$36,$34,$bc,$84,$8b,$41,$00,$12
>9880	2d 01 d9 bb 41 67 45 7d			.byte	$2d,$01,$d9,$bb,$41,$67,$45,$7d
>9888	8d 41 67 45 7d bc 84 41			.byte	$8d,$41,$67,$45,$7d,$bc,$84,$41
>9890	00 17 2e 01 d9 bb 41 7f			.byte	$00,$17,$2e,$01,$d9,$bb,$41,$7f
>9898	7b 51 81 8b 43 47 4b 56			.byte	$7b,$51,$81,$8b,$43,$47,$4b,$56
>98a0	bc 84 8b 42 40 40 45 00			.byte	$bc,$84,$8b,$42,$40,$40,$45,$00
>98a8	11 2f 01 d9 9a 8b 42 7e			.byte	$11,$2f,$01,$d9,$9a,$8b,$42,$7e
>98b0	58 67 bc 84 42 7e 58 67			.byte	$58,$67,$bc,$84,$42,$7e,$58,$67
>98b8	00 12 30 01 d9 a3 47 bc			.byte	$00,$12,$30,$01,$d9,$a3,$47,$bc
>98c0	84 fe 09 20 20 20 20 20			.byte	$84,$fe,$09,$20,$20,$20,$20,$20
>98c8	20 20 00 1c 31 01 d9 bb			.byte	$20,$20,$00,$1c,$31,$01,$d9,$bb
>98d0	8b 41 7b 78 5d fd 04 36			.byte	$8b,$41,$7b,$78,$5d,$fd,$04,$36
>98d8	37 88 8b 41 7b 78 5d fd			.byte	$37,$88,$8b,$41,$7b,$78,$5d,$fd
>98e0	04 36 37 bc 84 40 00 14			.byte	$04,$36,$37,$bc,$84,$40,$00,$14
>98e8	32 01 d9 bb 8b 41 77 50			.byte	$32,$01,$d9,$bb,$8b,$41,$77,$50
>98f0	6b 86 8b 41 77 50 6b bc			.byte	$6b,$86,$8b,$41,$77,$50,$6b,$bc
>98f8	84 40 00 15 33 01 d9 bb			.byte	$84,$40,$00,$15,$33,$01,$d9,$bb
>9900	41 5f 60 55 81 8b 41 5c			.byte	$41,$5f,$60,$55,$81,$8b,$41,$5c
>9908	54 59 bc 84 8b 54 49 00			.byte	$54,$59,$bc,$84,$8b,$54,$49,$00
>9910	0d 34 01 d9 b3 41 68 6d			.byte	$0d,$34,$01,$d9,$b3,$41,$68,$6d
>9918	4d bc 84 41 00 12 35 01			.byte	$4d,$bc,$84,$41,$00,$12,$35,$01
>9920	d9 a7 60 4b 79 bc 84 fe			.byte	$d9,$a7,$60,$4b,$79,$bc,$84,$fe
>9928	07 32 30 32 46 39 00 1d			.byte	$07,$32,$30,$32,$46,$39,$00,$1d
>9930	36 01 d9 bb 43 48 54 65			.byte	$36,$01,$d9,$bb,$43,$48,$54,$65
>9938	fd 04 34 33 8b 43 48 54			.byte	$fd,$04,$34,$33,$8b,$43,$48,$54
>9940	65 fd 04 34 33 bc 84 40			.byte	$65,$fd,$04,$34,$33,$bc,$84,$40
>9948	fd 03 30 00 11 37 01 d9			.byte	$fd,$03,$30,$00,$11,$37,$01,$d9
>9950	bb 62 49 7f 89 62 49 7f			.byte	$bb,$62,$49,$7f,$89,$62,$49,$7f
>9958	bc 84 8b 41 00 18 38 01			.byte	$bc,$84,$8b,$41,$00,$18,$38,$01
>9960	d9 bb 8b 43 58 73 52 81			.byte	$d9,$bb,$8b,$43,$58,$73,$52,$81
>9968	8b 43 6c 7c 74 bc 84 8b			.byte	$8b,$43,$6c,$7c,$74,$bc,$84,$8b
>9970	43 48 70 52 00 10 39 01			.byte	$43,$48,$70,$52,$00,$10,$39,$01
>9978	d9 b2 40 bd 8b 42 57 4c			.byte	$d9,$b2,$40,$bd,$8b,$42,$57,$4c
>9980	7b bc 84 40 00 0c 3a 01			.byte	$7b,$bc,$84,$40,$00,$0c,$3a,$01
>9988	d9 af fe 03 30 bc 84 40			.byte	$d9,$af,$fe,$03,$30,$bc,$84,$40
>9990	00 1a 3b 01 d9 bb 42 71			.byte	$00,$1a,$3b,$01,$d9,$bb,$42,$71
>9998	7f 55 fd 04 31 39 85 42			.byte	$7f,$55,$fd,$04,$31,$39,$85,$42
>99a0	71 7f 55 fd 04 31 39 bc			.byte	$71,$7f,$55,$fd,$04,$31,$39,$bc
>99a8	84 40 00 14 3c 01 d9 bb			.byte	$84,$40,$00,$14,$3c,$01,$d9,$bb
>99b0	8b 43 53 68 54 86 8b 43			.byte	$8b,$43,$53,$68,$54,$86,$8b,$43
>99b8	53 68 54 bc 84 40 00 17			.byte	$53,$68,$54,$bc,$84,$40,$00,$17
>99c0	3d 01 d9 bb 8b 43 66 49			.byte	$3d,$01,$d9,$bb,$8b,$43,$66,$49
>99c8	6e 82 8b 42 77 71 5f bc			.byte	$6e,$82,$8b,$42,$77,$71,$5f,$bc
>99d0	84 41 51 78 73 00 0e 3e			.byte	$84,$41,$51,$78,$73,$00,$0e,$3e
>99d8	01 d9 98 8b 66 6d 6c 84			.byte	$01,$d9,$98,$8b,$66,$6d,$6c,$84
>99e0	66 6d 6b 00 0e 3f 01 d9			.byte	$66,$6d,$6b,$00,$0e,$3f,$01,$d9
>99e8	a0 fe 02 bd 43 bc 84 fe			.byte	$a0,$fe,$02,$bd,$43,$bc,$84,$fe
>99f0	02 00 1b 40 01 d9 bb 6f			.byte	$02,$00,$1b,$40,$01,$d9,$bb,$6f
>99f8	61 52 fd 04 31 34 8b 6f			.byte	$61,$52,$fd,$04,$31,$34,$8b,$6f
>9a00	61 52 fd 04 31 34 bc 84			.byte	$61,$52,$fd,$04,$31,$34,$bc,$84
>9a08	40 fd 03 30 00 13 41 01			.byte	$40,$fd,$03,$30,$00,$13,$41,$01
>9a10	d9 bb 42 76 75 78 89 42			.byte	$d9,$bb,$42,$76,$75,$78,$89,$42
>9a18	76 75 78 bc 84 8b 41 00			.byte	$76,$75,$78,$bc,$84,$8b,$41,$00
>9a20	16 42 01 d9 bb 43 41 54			.byte	$16,$42,$01,$d9,$bb,$43,$41,$54
>9a28	7b 80 8b 41 6c 66 7b bc			.byte	$7b,$80,$8b,$41,$6c,$66,$7b,$bc
>9a30	84 42 41 50 41 00 14 43			.byte	$84,$42,$41,$50,$41,$00,$14,$43
>9a38	01 d9 a5 a4 8b 41 78 6d			.byte	$01,$d9,$a5,$a4,$8b,$41,$78,$6d
>9a40	7b bc bc 84 8b 41 78 6d			.byte	$7b,$bc,$bc,$84,$8b,$41,$78,$6d
>9a48	7b 00 12 44 01 d9 a1 fe			.byte	$7b,$00,$12,$44,$01,$d9,$a1,$fe
>9a50	04 63 66 bd 49 bc 84 fe			.byte	$04,$63,$66,$bd,$49,$bc,$84,$fe
>9a58	04 63 66 00 21 45 01 d9			.byte	$04,$63,$66,$00,$21,$45,$01,$d9
>9a60	bb 41 67 5d 61 fd 04 37			.byte	$bb,$41,$67,$5d,$61,$fd,$04,$37
>9a68	32 8a 41 67 5d 61 fd 04			.byte	$32,$8a,$41,$67,$5d,$61,$fd,$04
>9a70	37 32 bc 84 43 4e 7b 43			.byte	$37,$32,$bc,$84,$43,$4e,$7b,$43
>9a78	fd 04 34 34 00 15 46 01			.byte	$fd,$04,$34,$34,$00,$15,$46,$01
>9a80	d9 bb 8b 41 5c 7b 72 87			.byte	$d9,$bb,$8b,$41,$5c,$7b,$72,$87
>9a88	8b 41 5c 7b 72 bc 84 8b			.byte	$8b,$41,$5c,$7b,$72,$bc,$84,$8b
>9a90	41 00 17 47 01 d9 bb 8b			.byte	$41,$00,$17,$47,$01,$d9,$bb,$8b
>9a98	42 5f 73 7f 82 43 4c 6b			.byte	$42,$5f,$73,$7f,$82,$43,$4c,$6b
>9aa0	50 bc 84 8b 41 53 58 6f			.byte	$50,$bc,$84,$8b,$41,$53,$58,$6f
>9aa8	00 11 48 01 d9 9a 8b 42			.byte	$00,$11,$48,$01,$d9,$9a,$8b,$42
>9ab0	41 58 67 bc 84 42 41 58			.byte	$41,$58,$67,$bc,$84,$42,$41,$58
>9ab8	67 00 13 49 01 d9 a2 fe			.byte	$67,$00,$13,$49,$01,$d9,$a2,$fe
>9ac0	05 64 73 6d bd 48 bd 48			.byte	$05,$64,$73,$6d,$bd,$48,$bd,$48
>9ac8	bc 84 fe 02 00 1a 4a 01			.byte	$bc,$84,$fe,$02,$00,$1a,$4a,$01
>9ad0	d9 bb 42 7a 50 6d fd 04			.byte	$d9,$bb,$42,$7a,$50,$6d,$fd,$04
>9ad8	30 32 88 42 7a 50 6d fd			.byte	$30,$32,$88,$42,$7a,$50,$6d,$fd
>9ae0	04 30 32 bc 84 40 00 10			.byte	$04,$30,$32,$bc,$84,$40,$00,$10
>9ae8	4b 01 d9 bb 65 43 55 8d			.byte	$4b,$01,$d9,$bb,$65,$43,$55,$8d
>9af0	65 43 55 bc 84 41 00 16			.byte	$65,$43,$55,$bc,$84,$41,$00,$16
>9af8	4c 01 d9 bb 43 57 6f 5c			.byte	$4c,$01,$d9,$bb,$43,$57,$6f,$5c
>9b00	80 8b 41 41 7e 6b bc 84			.byte	$80,$8b,$41,$41,$7e,$6b,$bc,$84
>9b08	42 56 41 54 00 0a 4d 01			.byte	$42,$56,$41,$54,$00,$0a,$4d,$01
>9b10	d9 b3 40 bc 84 40 00 11			.byte	$d9,$b3,$40,$bc,$84,$40,$00,$11
>9b18	4e 01 d9 a6 fe 08 62 6c			.byte	$4e,$01,$d9,$a6,$fe,$08,$62,$6c
>9b20	72 66 64 7a bc 84 46 00			.byte	$72,$66,$64,$7a,$bc,$84,$46,$00
>9b28	1d 4f 01 d9 bb 8b 41 4a			.byte	$1d,$4f,$01,$d9,$bb,$8b,$41,$4a
>9b30	73 5f fd 03 33 8d 8b 41			.byte	$73,$5f,$fd,$03,$33,$8d,$8b,$41
>9b38	4a 73 5f fd 03 33 bc 84			.byte	$4a,$73,$5f,$fd,$03,$33,$bc,$84
>9b40	41 fd 03 30 00 14 50 01			.byte	$41,$fd,$03,$30,$00,$14,$50,$01
>9b48	d9 bb 8b 43 5d 7d 58 8d			.byte	$d9,$bb,$8b,$43,$5d,$7d,$58,$8d
>9b50	8b 43 5d 7d 58 bc 84 41			.byte	$8b,$43,$5d,$7d,$58,$bc,$84,$41
>9b58	00 16 51 01 d9 bb 8b 41			.byte	$00,$16,$51,$01,$d9,$bb,$8b,$41
>9b60	43 69 7e 82 8b 4c 65 44			.byte	$43,$69,$7e,$82,$8b,$4c,$65,$44
>9b68	bc 84 41 4f 4c 7e 00 0f			.byte	$bc,$84,$41,$4f,$4c,$7e,$00,$0f
>9b70	52 01 d9 b2 40 bd 41 68			.byte	$52,$01,$d9,$b2,$40,$bd,$41,$68
>9b78	49 5e bc 84 40 00 16 53			.byte	$49,$5e,$bc,$84,$40,$00,$16,$53
>9b80	01 d9 9b fe 0c 71 74 67			.byte	$01,$d9,$9b,$fe,$0c,$71,$74,$67
>9b88	73 63 61 74 66 62 6f bc			.byte	$73,$63,$61,$74,$66,$62,$6f,$bc
>9b90	84 41 71 00 1d 54 01 d9			.byte	$84,$41,$71,$00,$1d,$54,$01,$d9
>9b98	bb 43 59 58 44 fd 04 35			.byte	$bb,$43,$59,$58,$44,$fd,$04,$35
>9ba0	37 8d 43 59 58 44 fd 04			.byte	$37,$8d,$43,$59,$58,$44,$fd,$04
>9ba8	35 37 bc 84 41 fd 03 30			.byte	$35,$37,$bc,$84,$41,$fd,$03,$30
>9bb0	00 14 55 01 d9 bb 8b 41			.byte	$00,$14,$55,$01,$d9,$bb,$8b,$41
>9bb8	52 59 67 85 8b 41 52 59			.byte	$52,$59,$67,$85,$8b,$41,$52,$59
>9bc0	67 bc 84 40 00 14 56 01			.byte	$67,$bc,$84,$40,$00,$14,$56,$01
>9bc8	d9 bb 42 59 76 51 80 8b			.byte	$d9,$bb,$42,$59,$76,$51,$80,$8b
>9bd0	43 5f 46 71 bc 84 70 41			.byte	$43,$5f,$46,$71,$bc,$84,$70,$41
>9bd8	00 0e 57 01 d9 98 8b 4d			.byte	$00,$0e,$57,$01,$d9,$98,$8b,$4d
>9be0	5c 70 84 4d 5c 6f 00 0d			.byte	$5c,$70,$84,$4d,$5c,$6f,$00,$0d
>9be8	58 01 d9 b4 41 75 bc 84			.byte	$58,$01,$d9,$b4,$41,$75,$bc,$84
>9bf0	fe 03 75 00 25 59 01 d9			.byte	$fe,$03,$75,$00,$25,$59,$01,$d9
>9bf8	bb 70 41 76 fd 04 36 38			.byte	$bb,$70,$41,$76,$fd,$04,$36,$38
>9c00	8c 70 41 76 fd 04 36 38			.byte	$8c,$70,$41,$76,$fd,$04,$36,$38
>9c08	bc 84 43 fd 0d 38 37 30			.byte	$bc,$84,$43,$fd,$0d,$38,$37,$30
>9c10	31 33 38 37 30 65 31 30			.byte	$31,$33,$38,$37,$30,$65,$31,$30
>9c18	00 15 5a 01 d9 bb 8b 41			.byte	$00,$15,$5a,$01,$d9,$bb,$8b,$41
>9c20	65 5c 66 89 8b 41 65 5c			.byte	$65,$5c,$66,$89,$8b,$41,$65,$5c
>9c28	66 bc 84 8b 41 00 15 5b			.byte	$66,$bc,$84,$8b,$41,$00,$15,$5b
>9c30	01 d9 bb 41 7a 5c 42 80			.byte	$01,$d9,$bb,$41,$7a,$5c,$42,$80
>9c38	41 61 7e 4b bc 84 41 60			.byte	$41,$61,$7e,$4b,$bc,$84,$41,$60
>9c40	5c 42 00 12 5c 01 d9 a5			.byte	$5c,$42,$00,$12,$5c,$01,$d9,$a5
>9c48	a4 8b 65 53 48 bc bc 84			.byte	$a4,$8b,$65,$53,$48,$bc,$bc,$84
>9c50	8b 65 53 48 00 15 5d 01			.byte	$8b,$65,$53,$48,$00,$15,$5d,$01
>9c58	d9 a3 4a bc 84 fe 0c 20			.byte	$d9,$a3,$4a,$bc,$84,$fe,$0c,$20
>9c60	20 20 20 20 20 20 20 20			.byte	$20,$20,$20,$20,$20,$20,$20,$20
>9c68	20 00 10 5e 01 d4 fe 09			.byte	$20,$00,$10,$5e,$01,$d4,$fe,$09
>9c70	50 61 73 73 65 64 2e be			.byte	$50,$61,$73,$73,$65,$64,$2e,$be
>9c78	c2 00 00				.byte	$c2,$00,$00

;******  Return to file: modules/hardware/mega65.asm

.a000					StartROM:
.a000	a2 ff		ldx #$ff			ldx 		#$FF 					; empty stack
.a002	9a		txs				txs
.a003	20 4d a2	jsr $a24d			jsr 	IF_Reset 					; reset external interface
.a006	20 0c a0	jsr $a00c			jsr 	IFT_ClearScreen
.a009	4c b1 ad	jmp $adb1		jmp BASIC_Start

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.a00c					IFT_ClearScreen:
.a00c	48		pha				pha
.a00d	da		phx				phx
.a00e	5a		phy				phy
.a00f	20 b4 a1	jsr $a1b4			jsr 	IF_Home 					; home cursor
.a012	a2 19		ldx #$19			ldx 	#IF_Height 					; this many lines.
.a014					_IFT_CS0:
.a014	a0 50		ldy #$50			ldy 	#IF_Width 					; this many chars/line
.a016					_IFT_CS1:
.a016	a9 20		lda #$20			lda 	#' '						; clear line.
.a018	20 e3 a1	jsr $a1e3			jsr 	IF_Write
.a01b	88		dey				dey
.a01c	d0 f8		bne $a016			bne 	_IFT_CS1
.a01e	20 c3 a1	jsr $a1c3			jsr 	IF_NewLine 					; next line down
.a021	ca		dex				dex
.a022	d0 f0		bne $a014			bne 	_IFT_CS0
.a024	7a		ply				ply
.a025	fa		plx				plx
.a026	68		pla				pla
.a027					IFT_HomeCursor:
.a027	48		pha				pha
.a028	20 b4 a1	jsr $a1b4			jsr 	IF_Home
.a02b	a9 00		lda #$00			lda 	#0
.a02d	8d 00 02	sta $0200			sta 	IFT_XCursor
.a030	8d 01 02	sta $0201			sta 	IFT_YCursor
.a033	68		pla				pla
.a034	60		rts				rts
.a035					IFT_UpLine:
.a035	48		pha				pha
.a036	ad 01 02	lda $0201			lda  	IFT_YCursor 				; get Y
.a039	3a		dec a				dec 	a 							; line above
.a03a	30 03		bmi $a03f			bmi 	_IFTULExit 					; too far, abort
.a03c	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos					; set to that line.
.a03f					_IFTULExit:
.a03f	68		pla				pla
.a040	60		rts				rts
.a041					IFT_PrintCharacter:
.a041	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.a043	f0 23		beq $a068			beq 	IFT_NewLine
.a045	48		pha				pha
.a046	20 80 a0	jsr $a080			jsr 	IFT_UpperCase 				; make upper case
.a049	20 e3 a1	jsr $a1e3			jsr 	IF_Write 					; write out.
.a04c	ee 00 02	inc $0200			inc 	IFT_XCursor 				; bump x cursor
.a04f	ad 00 02	lda $0200			lda 	IFT_XCursor 				; reached RHS ?
.a052	c9 50		cmp #$50			cmp 	#IF_Width
.a054	d0 03		bne $a059			bne 	_IFT_PCNotEOL
.a056	20 68 a0	jsr $a068			jsr 	IFT_NewLine 				; if so do new line.
.a059					_IFT_PCNotEOL:
.a059	68		pla				pla
.a05a	60		rts				rts
.a05b					IFT_Tab:
.a05b	a9 20		lda #$20			lda 	#" " 						; space
.a05d	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.a060	ad 00 02	lda $0200			lda 	IFT_XCursor 				; until x % 8 == 0
.a063	29 07		and #$07			and 	#7
.a065	d0 f4		bne $a05b			bne 	IFT_Tab
.a067	60		rts				rts
.a068					IFT_NewLine:
.a068	48		pha				pha
.a069	20 c3 a1	jsr $a1c3			jsr 	IF_NewLine 					; new line on actual screen.
.a06c	a9 00		lda #$00			lda 	#0 							; reset x position
.a06e	8d 00 02	sta $0200			sta 	IFT_XCursor
.a071	ee 01 02	inc $0201			inc 	IFT_YCursor 				; move down.
.a074	ad 01 02	lda $0201			lda 	IFT_YCursor
.a077	c9 19		cmp #$19			cmp 	#IF_Height 					; reached bottom.
.a079	d0 03		bne $a07e			bne 	_IFT_NL_NotEOS
.a07b	20 8b a0	jsr $a08b			jsr 	IFT_Scroll 					; scroll screen up.
.a07e					_IFT_NL_NotEOS:
.a07e	68		pla				pla
.a07f	60		rts				rts
.a080					IFT_UpperCase:
.a080	c9 61		cmp #$61			cmp 	#"a"
.a082	90 06		bcc $a08a			bcc 	_IFT_UCExit
.a084	c9 7b		cmp #$7b			cmp 	#"z"+1
.a086	b0 02		bcs $a08a			bcs 	_IFT_UCExit
.a088	49 20		eor #$20			eor 	#$20
.a08a					_IFT_UCExit:
.a08a	60		rts				rts
.a08b					IFT_Scroll:
.a08b	48		pha				pha 								; save AXY
.a08c	da		phx				phx
.a08d	5a		phy				phy
.a08e	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.a090					_IFT_SLoop:
.a090	20 b0 a0	jsr $a0b0			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.a093	e8		inx				inx
.a094	e0 18		cpx #$18			cpx 	#IF_Height-1				; do whole screen
.a096	d0 f8		bne $a090			bne 	_IFT_SLoop
.a098	a9 18		lda #$18			lda 	#IF_Height-1 				; move to X = 0,Y = A
.a09a	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a09d	a2 50		ldx #$50			ldx 	#IF_Width 					; blank line
.a09f					_IFT_SBlank:
.a09f	a9 20		lda #$20			lda 	#32
.a0a1	20 e3 a1	jsr $a1e3			jsr 	IF_Write
.a0a4	ca		dex				dex
.a0a5	d0 f8		bne $a09f			bne 	_IFT_SBlank
.a0a7	a9 18		lda #$18			lda 	#IF_Height-1 				; move to X = 0,Y = A
.a0a9	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a0ac	7a		ply				ply
.a0ad	fa		plx				plx
.a0ae	68		pla				pla
.a0af	60		rts				rts
.a0b0					_IFT_ScrollLine:
.a0b0	da		phx				phx
.a0b1	da		phx				phx
.a0b2	8a		txa				txa 								; copy line into buffer.
.a0b3	1a		inc a				inc 	a 							; next line down.
.a0b4	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a0b7	a2 00		ldx #$00			ldx 	#0
.a0b9					_IFTScrollCopy1:
.a0b9	20 d5 a1	jsr $a1d5			jsr 	IF_Read
.a0bc	9d 02 02	sta $0202,x			sta 	IFT_Buffer,x
.a0bf	e8		inx				inx
.a0c0	e0 50		cpx #$50			cpx 	#IF_Width
.a0c2	d0 f5		bne $a0b9			bne 	_IFTScrollCopy1
.a0c4	68		pla				pla
.a0c5	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a0c8	a2 00		ldx #$00			ldx 	#0
.a0ca					_IFTScrollCopy2:
.a0ca	bd 02 02	lda $0202,x			lda 	IFT_Buffer,x
.a0cd	20 e3 a1	jsr $a1e3			jsr 	IF_Write
.a0d0	e8		inx				inx
.a0d1	e0 50		cpx #$50			cpx 	#IF_Width
.a0d3	d0 f5		bne $a0ca			bne 	_IFTScrollCopy2
.a0d5	fa		plx				plx
.a0d6	60		rts				rts
.a0d7					IFT_SetYPos:
.a0d7	48		pha				pha
.a0d8	da		phx				phx
.a0d9	aa		tax				tax
.a0da	20 27 a0	jsr $a027			jsr 	IFT_HomeCursor
.a0dd	e0 00		cpx #$00			cpx 	#0
.a0df	f0 09		beq $a0ea			beq 	_IFT_MOAExit
.a0e1					_IFT_MOALoop:
.a0e1	20 c3 a1	jsr $a1c3			jsr 	IF_NewLine
.a0e4	ee 01 02	inc $0201			inc 	IFT_YCursor
.a0e7	ca		dex				dex
.a0e8	d0 f7		bne $a0e1			bne		_IFT_MOALoop
.a0ea					_IFT_MOAExit:
.a0ea	fa		plx				plx
.a0eb	68		pla				pla
.a0ec	60		rts				rts
.a0ed					IFT_GetKeyCursor:
.a0ed	20 f5 a0	jsr $a0f5			jsr 	_IFT_FlipCursor 			; reverse current
.a0f0					_IFT_GKCWait:
.a0f0	20 06 a2	jsr $a206			jsr 	IF_GetKey 					; get key
.a0f3	f0 fb		beq $a0f0			beq 	_IFT_GKCWait
.a0f5					_IFT_FlipCursor:
.a0f5	48		pha				pha 								; save
.a0f6	20 d5 a1	jsr $a1d5			jsr 	IF_Read 					; read
.a0f9	20 ee a1	jsr $a1ee			jsr 	IF_LeftOne
.a0fc	49 80		eor #$80			eor 	#$80 						; reverse
.a0fe	20 e3 a1	jsr $a1e3			jsr 	IF_Write 					; write
.a101	20 ee a1	jsr $a1ee			jsr 	IF_LeftOne
.a104	68		pla				pla
.a105	60		rts				rts
.a106					IFT_ReadLine:
.a106	48		pha				pha
.a107					_IFT_RLLoop:
.a107	20 ed a0	jsr $a0ed			jsr 	IFT_GetKeyCursor 			; get keystroke
.a10a	c9 0d		cmp #$0d			cmp 	#13							; return
.a10c	f0 7d		beq $a18b			beq 	_IFT_RLExit
.a10e	c9 20		cmp #$20			cmp 	#32 						; control character
.a110	90 05		bcc $a117			bcc 	_IFT_Control
.a112	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.a115	80 f0		bra $a107			bra 	_IFT_RLLoop
.a117					_IFT_Control:
.a117	c9 01		cmp #$01			cmp 	#"A"-64
.a119	f0 26		beq $a141			beq 	_IFT_Left
.a11b	c9 04		cmp #$04			cmp 	#"D"-64
.a11d	f0 2e		beq $a14d			beq 	_IFT_Right
.a11f	c9 17		cmp #$17			cmp 	#"W"-64
.a121	f0 36		beq $a159			beq 	_IFT_Up
.a123	c9 13		cmp #$13			cmp 	#"S"-64
.a125	f0 3e		beq $a165			beq 	_IFT_Down
.a127	c9 08		cmp #$08			cmp 	#"H"-64
.a129	f0 09		beq $a134			beq 	_IFT_Backspace
.a12b	c9 1a		cmp #$1a			cmp 	#"Z"-64
.a12d	d0 d8		bne $a107			bne 	_IFT_RLLoop
.a12f	20 0c a0	jsr $a00c			jsr 	IFT_ClearScreen				; clear CTL-Z
.a132	80 d3		bra $a107			bra 	_IFT_RLLoop
.a134					_IFT_Backspace:
.a134	ad 00 02	lda $0200			lda 	IFT_XCursor 				; check not start of line.
.a137	f0 ce		beq $a107			beq 	_IFT_RLLoop
.a139	20 ee a1	jsr $a1ee			jsr 	IF_LeftOne
.a13c	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.a13e	20 e3 a1	jsr $a1e3			jsr 	IF_Write
.a141					_IFT_Left:
.a141	ce 00 02	dec $0200			dec 	IFT_XCursor 				; left CTL-W
.a144	10 29		bpl $a16f			bpl 	_IFT_Reposition
.a146	a9 4f		lda #$4f			lda 	#IF_Width-1
.a148					_IFT_SetX:
.a148	8d 00 02	sta $0200			sta 	IFT_XCursor
.a14b	80 22		bra $a16f			bra 	_IFT_Reposition
.a14d					_IFT_Right:
.a14d	ee 00 02	inc $0200			inc 	IFT_XCursor
.a150	ad 00 02	lda $0200			lda 	IFT_XCursor
.a153	49 50		eor #$50			eor 	#IF_Width
.a155	f0 f1		beq $a148			beq 	_IFT_SetX
.a157	80 16		bra $a16f			bra 	_IFT_Reposition
.a159					_IFT_Up:
.a159	ce 01 02	dec $0201			dec 	IFT_YCursor
.a15c	10 11		bpl $a16f			bpl 	_IFT_Reposition
.a15e	a9 18		lda #$18			lda 	#IF_Height-1
.a160					_IFT_SetY:
.a160	8d 01 02	sta $0201			sta 	IFT_YCursor
.a163	80 0a		bra $a16f			bra 	_IFT_Reposition
.a165					_IFT_Down:
.a165	ee 01 02	inc $0201			inc 	IFT_YCursor
.a168	ad 01 02	lda $0201			lda 	IFT_YCursor
.a16b	49 19		eor #$19			eor 	#IF_Height
.a16d	f0 f1		beq $a160			beq 	_IFT_SetY
.a16f					_IFT_Reposition:
.a16f	ad 00 02	lda $0200			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.a172	48		pha				pha
.a173	ad 01 02	lda $0201			lda 	IFT_YCursor
.a176	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a179	68		pla				pla
.a17a	aa		tax				tax
.a17b	e0 00		cpx #$00			cpx 	#0
.a17d	f0 88		beq $a107			beq 	_IFT_RLLoop
.a17f					_IFT_MoveRight:
.a17f	20 d5 a1	jsr $a1d5			jsr 	IF_Read
.a182	ee 00 02	inc $0200			inc 	IFT_XCursor
.a185	ca		dex				dex
.a186	d0 f7		bne $a17f			bne 	_IFT_MoveRight
.a188	4c 07 a1	jmp $a107			jmp 	_IFT_RLLoop
.a18b					_IFT_RLExit:
.a18b	ad 01 02	lda $0201			lda 	IFT_YCursor 				; go to start of line.
.a18e	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a191	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.a193					_IFT_RLRead:
.a193	20 d5 a1	jsr $a1d5			jsr 	IF_Read
.a196	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.a199	e8		inx				inx
.a19a	e0 50		cpx #$50			cpx 	#IF_Width
.a19c	d0 f5		bne $a193			bne 	_IFT_RLRead
.a19e					_IFT_RL_Trim:
.a19e	ca		dex				dex 	 							; previous char
.a19f	30 07		bmi $a1a8			bmi 	_IFT_Found 					; gone too far
.a1a1	bd 66 02	lda $0266,x			lda 	IFT_LineBuffer,x			; go back if space
.a1a4	c9 20		cmp #$20			cmp 	#" "
.a1a6	f0 f6		beq $a19e			beq 	_IFT_RL_Trim
.a1a8					_IFT_Found:
.a1a8	e8		inx				inx 								; forward to non-space
.a1a9	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.a1ab	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.a1ae	68		pla				pla
.a1af	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.a1b1	a0 02		ldy #$02			ldy 	#IFT_LineBuffer >> 8
.a1b3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_mega65.asm

=80					IF_Width 	= 80 							; characters across
=25					IF_Height 	= 25 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line
=6					IF_XPos 	= 6 							; current position, horizontal.
=8					IF_FarPtr 	= 8 							; far pointer (4 bytes)
=$1000					IF_Screen = $1000							; 2k screen RAM here
=$800					IF_CharSet = $800							; 2k character set (0-7F) here
.a1b4					IF_Home:
.a1b4	48		pha				pha 								; reset cursor position
.a1b5	a9 00		lda #$00			lda 	#IF_Screen & $FF
.a1b7	85 04		sta $04				sta 	IF_Pos
.a1b9	a9 10		lda #$10			lda 	#IF_Screen >> 8
.a1bb	85 05		sta $05				sta 	IF_Pos+1
.a1bd	a9 00		lda #$00			lda 	#0
.a1bf	85 06		sta $06				sta 	IF_XPos
.a1c1	68		pla				pla
.a1c2	60		rts				rts
.a1c3					IF_NewLine:
.a1c3	48		pha				pha
.a1c4	a9 00		lda #$00			lda 	#0 							; back to start of line
.a1c6	85 06		sta $06				sta 	IF_XPos
.a1c8	18		clc				clc 								; down one line
.a1c9	a5 04		lda $04				lda 	IF_Pos
.a1cb	69 50		adc #$50			adc 	#80
.a1cd	85 04		sta $04				sta 	IF_Pos
.a1cf	90 02		bcc $a1d3			bcc 	_IF_NoCarry 				; carry through.
.a1d1	e6 05		inc $05				inc 	IF_Pos+1
.a1d3					_IF_NoCarry:
.a1d3	68		pla				pla
.a1d4	60		rts				rts
.a1d5					IF_Read:
.a1d5	5a		phy				phy 								; save current Y
.a1d6	a4 06		ldy $06				ldy 	IF_XPos 					; read character at current position
.a1d8	b1 04		lda ($04),y			lda 	(IF_Pos),y
.a1da	49 20		eor #$20			eor 	#$20
.a1dc	18		clc				clc
.a1dd	69 20		adc #$20			adc 	#$20
.a1df	e6 06		inc $06				inc 	IF_XPos 					; step right.
.a1e1	7a		ply				ply									; restore Y
.a1e2	60		rts				rts
.a1e3					IF_Write:
.a1e3	5a		phy				phy 								; save current Y
.a1e4	a4 06		ldy $06				ldy 	IF_XPos 					; write character at current position
.a1e6	29 bf		and #$bf			and 	#63+128 					; PETSCII
.a1e8	91 04		sta ($04),y			sta 	(IF_Pos),y
.a1ea	e6 06		inc $06				inc 	IF_XPos 					; step right.
.a1ec	7a		ply				ply									; restore Y
.a1ed	60		rts				rts
.a1ee					IF_LeftOne:
.a1ee	c6 06		dec $06				dec 	IF_XPos
.a1f0	60		rts				rts
.a1f1					IF_CheckBreak:
.a1f1	db		phz				phz
.a1f2	20 3a a2	jsr $a23a			jsr 	IF_SetupKeyAddress 			; point to keyboard
.a1f5	e6 08		inc $08				inc 	IF_FarPtr 					; point to modifiers.
.a1f7	ea		nop				nop 								; read modifiers.
.a1f8	b2 08		lda ($08),z			lda 	(IF_FarPtr),z
.a1fa	fb		plz				plz 								; restore Z
.a1fb	29 05		and #$05			and 	#5							; break is LeftShift+Ctrl
.a1fd	c9 05		cmp #$05			cmp 	#5
.a1ff	f0 02		beq $a203			beq 	_IF_CBExit
.a201	a9 00		lda #$00			lda 	#0
.a203					_IF_CBExit:
.a203	c9 00		cmp #$00			cmp 	#0
.a205	60		rts				rts
.a206					IF_GetKey:
.a206	db		phz				phz
.a207	20 3a a2	jsr $a23a			jsr 	IF_SetupKeyAddress
.a20a	ea		nop				nop 								; read keyboard
.a20b	b2 08		lda ($08),z			lda 	(IF_FarPtr),z
.a20d	c9 14		cmp #$14			cmp 	#20
.a20f	d0 02		bne $a213			bne 	_KMNo
.a211	a9 08		lda #$08			lda 	#"H"-64
.a213					_KMNo:
.a213	c9 91		cmp #$91			cmp 	#145
.a215	d0 02		bne $a219			bne 	_KMNo
.a217	a9 17		lda #$17			lda 	#"W"-64
.a219					_KMNo:
.a219	c9 11		cmp #$11			cmp 	#17
.a21b	d0 02		bne $a21f			bne 	_KMNo
.a21d	a9 13		lda #$13			lda 	#"S"-64
.a21f					_KMNo:
.a21f	c9 9d		cmp #$9d			cmp 	#157
.a221	d0 02		bne $a225			bne 	_KMNo
.a223	a9 01		lda #$01			lda 	#"A"-64
.a225					_KMNo:
.a225	c9 1d		cmp #$1d			cmp 	#29
.a227	d0 02		bne $a22b			bne 	_KMNo
.a229	a9 04		lda #$04			lda 	#"D"-64
.a22b					_KMNo:
.a22b	c9 00		cmp #$00			cmp 	#0
.a22d	f0 07		beq $a236			beq 	_IFGKEmpty
.a22f	48		pha				pha
.a230	a9 00		lda #$00			lda 	#0
.a232	ea		nop				nop
.a233	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a235	68		pla				pla
.a236					_IFGKEmpty:
.a236	fb		plz				plz
.a237	c9 00		cmp #$00			cmp 	#0 							; set Z
.a239	60		rts				rts
.a23a					IF_SetupKeyAddress:
.a23a	a9 0f		lda #$0f			lda 	#$0F 						; set up to write to read keyboard.
.a23c	85 0b		sta $0b				sta 	IF_FarPtr+3
.a23e	a9 fd		lda #$fd			lda 	#$FD
.a240	85 0a		sta $0a				sta 	IF_FarPtr+2
.a242	a9 36		lda #$36			lda 	#$36
.a244	85 09		sta $09				sta 	IF_FarPtr+1
.a246	a9 10		lda #$10			lda 	#$10
.a248	85 08		sta $08				sta 	IF_FarPtr+0
.a24a	a3 00		ldz #$00			ldz 	#0
.a24c	60		rts				rts
.a24d					IF_Reset:
.a24d	48		pha				pha 								; save registers
.a24e	da		phx				phx
.a24f	5a		phy				phy
.a250	a9 0f		lda #$0f			lda 	#$0F 						; set up to write to video system.
.a252	85 0b		sta $0b				sta 	IF_FarPtr+3
.a254	a9 fd		lda #$fd			lda 	#$FD
.a256	85 0a		sta $0a				sta 	IF_FarPtr+2
.a258	a9 30		lda #$30			lda 	#$30
.a25a	85 09		sta $09				sta 	IF_FarPtr+1
.a25c	a9 00		lda #$00			lda 	#$00
.a25e	85 08		sta $08				sta 	IF_FarPtr+0
.a260	a3 2f		ldz #$2f			ldz 	#$2F 						; address already set up
.a262	a9 47		lda #$47			lda 	#$47
.a264	ea		nop				nop
.a265	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a267	a3 2f		ldz #$2f			ldz 	#$2F 						; address already set up
.a269	a9 53		lda #$53			lda 	#$53
.a26b	ea		nop				nop
.a26c	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a26e	a3 30		ldz #$30			ldz 	#$30 						; address already set up
.a270	a9 40		lda #$40			lda 	#$40
.a272	ea		nop				nop
.a273	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a275	a3 31		ldz #$31			ldz 	#$31 						; address already set up
.a277	a9 c0		lda #$c0			lda 	#$80+$40
.a279	ea		nop				nop
.a27a	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a27c	a3 20		ldz #$20			ldz 	#$20 						; address already set up
.a27e	a9 00		lda #$00			lda 	#0
.a280	ea		nop				nop
.a281	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a283	a3 21		ldz #$21			ldz 	#$21 						; address already set up
.a285	a9 00		lda #$00			lda 	#0
.a287	ea		nop				nop
.a288	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a28a	a3 54		ldz #$54			ldz 	#$54 						; address already set up
.a28c	a9 40		lda #$40			lda 	#$40
.a28e	ea		nop				nop
.a28f	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a291	a3 01		ldz #$01			ldz 	#$01 						; address already set up
.a293	a9 ff		lda #$ff			lda 	#$FF
.a295	ea		nop				nop
.a296	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a298	a3 00		ldz #$00			ldz 	#$00 						; address already set up
.a29a	a9 ff		lda #$ff			lda 	#$FF
.a29c	ea		nop				nop
.a29d	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a29f	a3 16		ldz #$16			ldz 	#$16 						; address already set up
.a2a1	a9 cc		lda #$cc			lda 	#$CC
.a2a3	ea		nop				nop
.a2a4	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2a6	a3 18		ldz #$18			ldz 	#$18 						; address already set up
.a2a8	a9 42		lda #$42			lda 	#$42
.a2aa	ea		nop				nop
.a2ab	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2ad	a3 11		ldz #$11			ldz 	#$11 						; address already set up
.a2af	a9 1b		lda #$1b			lda 	#$1B
.a2b1	ea		nop				nop
.a2b2	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2b4	a9 00		lda #$00			lda 	#$00						; colour RAM at $1F800-1FFFF (2kb)
.a2b6	85 0b		sta $0b				sta 	IF_FarPtr+3
.a2b8	a9 01		lda #$01			lda 	#$01
.a2ba	85 0a		sta $0a				sta 	IF_FarPtr+2
.a2bc	a9 f8		lda #$f8			lda 	#$F8
.a2be	85 09		sta $09				sta 	IF_FarPtr+1
.a2c0	a9 00		lda #$00			lda 	#$00
.a2c2	85 08		sta $08				sta 	IF_FarPtr+0
.a2c4	a3 00		ldz #$00			ldz 	#0
.a2c6					_EXTClearColorRam:
.a2c6	a9 05		lda #$05			lda 	#5							; fill that with this colour.
.a2c8	ea		nop				nop
.a2c9	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2cb	3b		dez				dez
.a2cc	d0 f8		bne $a2c6			bne 	_EXTClearColorRam
.a2ce	e6 09		inc $09				inc 	IF_FarPtr+1
.a2d0	d0 f4		bne $a2c6			bne 	_EXTClearColorRam
.a2d2	a2 00		ldx #$00			ldx 	#0 							; copy PET Font into memory.
.a2d4					_EXTCopyCBMFont:
.a2d4	bd 15 a3	lda $a315,x			lda 	IF_CBMFont,x 				; +$800 uses the lower case c/set
.a2d7	9d 00 08	sta $0800,x			sta 	IF_CharSet,x
.a2da	49 ff		eor #$ff			eor 	#$FF
.a2dc	9d 00 0c	sta $0c00,x			sta 	IF_CharSet+$400,x
.a2df	bd 15 a4	lda $a415,x			lda 	IF_CBMFont+$100,x
.a2e2	9d 00 09	sta $0900,x			sta 	IF_CharSet+$100,x
.a2e5	49 ff		eor #$ff			eor 	#$FF
.a2e7	9d 00 0d	sta $0d00,x			sta 	IF_CharSet+$500,x
.a2ea	bd 15 a5	lda $a515,x			lda 	IF_CBMFont+$200,x
.a2ed	9d 00 0a	sta $0a00,x			sta 	IF_CharSet+$200,x
.a2f0	49 ff		eor #$ff			eor 	#$FF
.a2f2	9d 00 0e	sta $0e00,x			sta 	IF_CharSet+$600,x
.a2f5	bd 15 a6	lda $a615,x			lda 	IF_CBMFont+$300,x
.a2f8	9d 00 0b	sta $0b00,x			sta 	IF_CharSet+$300,x
.a2fb	49 ff		eor #$ff			eor 	#$FF
.a2fd	9d 00 0f	sta $0f00,x			sta 	IF_CharSet+$700,x
.a300	ca		dex				dex
.a301	d0 d1		bne $a2d4			bne 	_EXTCopyCBMFont
.a303	a9 3b		lda #$3b			lda 	#$3F-4  					; puts ROM back in the map (the -4)
.a305	85 01		sta $01				sta 	$01
.a307	a9 00		lda #$00			lda 	#$00						; do not map bytes 0000-7FFF
.a309	a2 00		ldx #$00			ldx 	#$00						; (so we use the RAM physically at $0000-$7FFF)
.a30b	a0 00		ldy #$00			ldy 	#$00 						; 8000-FFFF offset by $200. The lower 8 bits are $00
.a30d	a3 f2		ldz #$f2			ldz 	#$F2 						; so this is an actual offset of $20000. So the space at
.a30f	5c		map				map
.a310	ea		nop				eom
.a311	7a		ply				ply 								; restore and exit.
.a312	fa		plx				plx
.a313	68		pla				pla
.a314	60		rts				rts
.a315					IF_CBMFont:
>a315	1c 22 4a 56 4c 20 1e 00				.binary "pet-font.bin"
>a31d	18 24 42 7e 42 42 42 00 7c 22 22 3c 22 22 7c 00
>a32d	1c 22 40 40 40 22 1c 00 78 24 22 22 22 24 78 00
>a33d	7e 40 40 78 40 40 7e 00 7e 40 40 78 40 40 40 00
>a34d	1c 22 40 4e 42 22 1c 00 42 42 42 7e 42 42 42 00
>a35d	1c 08 08 08 08 08 1c 00 0e 04 04 04 04 44 38 00
>a36d	42 44 48 70 48 44 42 00 40 40 40 40 40 40 7e 00
>a37d	42 66 5a 5a 42 42 42 00 42 62 52 4a 46 42 42 00
>a38d	18 24 42 42 42 24 18 00 7c 42 42 7c 40 40 40 00
>a39d	18 24 42 42 4a 24 1a 00 7c 42 42 7c 48 44 42 00
>a3ad	3c 42 40 3c 02 42 3c 00 3e 08 08 08 08 08 08 00
>a3bd	42 42 42 42 42 42 3c 00 42 42 42 24 24 18 18 00
>a3cd	42 42 42 5a 5a 66 42 00 42 42 24 18 24 42 42 00
>a3dd	22 22 22 1c 08 08 08 00 7e 02 04 18 20 40 7e 00
>a3ed	3c 20 20 20 20 20 3c 00 00 40 20 10 08 04 02 00
>a3fd	3c 04 04 04 04 04 3c 00 00 08 1c 2a 08 08 08 08
>a40d	00 00 10 20 7f 20 10 00 00 00 00 00 00 00 00 00
>a41d	08 08 08 08 00 00 08 00 24 24 24 00 00 00 00 00
>a42d	24 24 7e 24 7e 24 24 00 08 1e 28 1c 0a 3c 08 00
>a43d	00 62 64 08 10 26 46 00 30 48 48 30 4a 44 3a 00
>a44d	04 08 10 00 00 00 00 00 04 08 10 10 10 08 04 00
>a45d	20 10 08 08 08 10 20 00 08 2a 1c 3e 1c 2a 08 00
>a46d	00 08 08 3e 08 08 00 00 00 00 00 00 00 08 08 10
>a47d	00 00 00 7e 00 00 00 00 00 00 00 00 00 18 18 00
>a48d	00 02 04 08 10 20 40 00 3c 42 46 5a 62 42 3c 00
>a49d	08 18 28 08 08 08 3e 00 3c 42 02 0c 30 40 7e 00
>a4ad	3c 42 02 1c 02 42 3c 00 04 0c 14 24 7e 04 04 00
>a4bd	7e 40 78 04 02 44 38 00 1c 20 40 7c 42 42 3c 00
>a4cd	7e 42 04 08 10 10 10 00 3c 42 42 3c 42 42 3c 00
>a4dd	3c 42 42 3e 02 04 38 00 00 00 08 00 00 08 00 00
>a4ed	00 00 08 00 00 08 08 10 0e 18 30 60 30 18 0e 00
>a4fd	00 00 7e 00 7e 00 00 00 70 18 0c 06 0c 18 70 00
>a50d	3c 42 02 0c 10 00 10 00 00 00 00 00 ff 00 00 00
>a51d	08 1c 3e 7f 7f 1c 3e 00 10 10 10 10 10 10 10 10
>a52d	00 00 00 ff 00 00 00 00 00 00 ff 00 00 00 00 00
>a53d	00 ff 00 00 00 00 00 00 00 00 00 00 00 ff 00 00
>a54d	20 20 20 20 20 20 20 20 04 04 04 04 04 04 04 04
>a55d	00 00 00 00 e0 10 08 08 08 08 08 04 03 00 00 00
>a56d	08 08 08 10 e0 00 00 00 80 80 80 80 80 80 80 ff
>a57d	80 40 20 10 08 04 02 01 01 02 04 08 10 20 40 80
>a58d	ff 80 80 80 80 80 80 80 ff 01 01 01 01 01 01 01
>a59d	00 3c 7e 7e 7e 7e 3c 00 00 00 00 00 00 00 ff 00
>a5ad	36 7f 7f 7f 3e 1c 08 00 40 40 40 40 40 40 40 40
>a5bd	00 00 00 00 03 04 08 08 81 42 24 18 18 24 42 81
>a5cd	00 3c 42 42 42 42 3c 00 08 1c 2a 77 2a 08 08 00
>a5dd	02 02 02 02 02 02 02 02 08 1c 3e 7f 3e 1c 08 00
>a5ed	08 08 08 08 ff 08 08 08 a0 50 a0 50 a0 50 a0 50
>a5fd	08 08 08 08 08 08 08 08 00 00 01 3e 54 14 14 00
>a60d	ff 7f 3f 1f 0f 07 03 01 00 00 00 00 00 00 00 00
>a61d	f0 f0 f0 f0 f0 f0 f0 f0 00 00 00 00 ff ff ff ff
>a62d	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff
>a63d	80 80 80 80 80 80 80 80 aa 55 aa 55 aa 55 aa 55
>a64d	01 01 01 01 01 01 01 01 00 00 00 00 aa 55 aa 55
>a65d	ff fe fc f8 f0 e0 c0 80 03 03 03 03 03 03 03 03
>a66d	08 08 08 08 0f 08 08 08 00 00 00 00 0f 0f 0f 0f
>a67d	08 08 08 08 0f 00 00 00 00 00 00 00 f8 08 08 08
>a68d	00 00 00 00 00 00 ff ff 00 00 00 00 0f 08 08 08
>a69d	08 08 08 08 ff 00 00 00 00 00 00 00 ff 08 08 08
>a6ad	08 08 08 08 f8 08 08 08 c0 c0 c0 c0 c0 c0 c0 c0
>a6bd	e0 e0 e0 e0 e0 e0 e0 e0 07 07 07 07 07 07 07 07
>a6cd	ff ff 00 00 00 00 00 00 ff ff ff 00 00 00 00 00
>a6dd	00 00 00 00 00 ff ff ff 01 01 01 01 01 01 01 ff
>a6ed	00 00 00 00 f0 f0 f0 f0 0f 0f 0f 0f 00 00 00 00
>a6fd	08 08 08 08 f8 00 00 00 f0 f0 f0 f0 00 00 00 00
>a70d	f0 f0 f0 f0 0f 0f 0f 0f 1c 22 4a 56 4c 20 1e 00
>a71d	18 24 42 7e 42 42 42 00 7c 22 22 3c 22 22 7c 00
>a72d	1c 22 40 40 40 22 1c 00 78 24 22 22 22 24 78 00
>a73d	7e 40 40 78 40 40 7e 00 7e 40 40 78 40 40 40 00
>a74d	1c 22 40 4e 42 22 1c 00 42 42 42 7e 42 42 42 00
>a75d	1c 08 08 08 08 08 1c 00 0e 04 04 04 04 44 38 00
>a76d	42 44 48 70 48 44 42 00 40 40 40 40 40 40 7e 00
>a77d	42 66 5a 5a 42 42 42 00 42 62 52 4a 46 42 42 00
>a78d	18 24 42 42 42 24 18 00 7c 42 42 7c 40 40 40 00
>a79d	18 24 42 42 4a 24 1a 00 7c 42 42 7c 48 44 42 00
>a7ad	3c 42 40 3c 02 42 3c 00 3e 08 08 08 08 08 08 00
>a7bd	42 42 42 42 42 42 3c 00 42 42 42 24 24 18 18 00
>a7cd	42 42 42 5a 5a 66 42 00 42 42 24 18 24 42 42 00
>a7dd	22 22 22 1c 08 08 08 00 7e 02 04 18 20 40 7e 00
>a7ed	3c 20 20 20 20 20 3c 00 00 40 20 10 08 04 02 00
>a7fd	3c 04 04 04 04 04 3c 00 00 08 1c 2a 08 08 08 08
>a80d	00 00 10 20 7f 20 10 00 00 00 00 00 00 00 00 00
>a81d	08 08 08 08 00 00 08 00 24 24 24 00 00 00 00 00
>a82d	24 24 7e 24 7e 24 24 00 08 1e 28 1c 0a 3c 08 00
>a83d	00 62 64 08 10 26 46 00 30 48 48 30 4a 44 3a 00
>a84d	04 08 10 00 00 00 00 00 04 08 10 10 10 08 04 00
>a85d	20 10 08 08 08 10 20 00 08 2a 1c 3e 1c 2a 08 00
>a86d	00 08 08 3e 08 08 00 00 00 00 00 00 00 08 08 10
>a87d	00 00 00 7e 00 00 00 00 00 00 00 00 00 18 18 00
>a88d	00 02 04 08 10 20 40 00 3c 42 46 5a 62 42 3c 00
>a89d	08 18 28 08 08 08 3e 00 3c 42 02 0c 30 40 7e 00
>a8ad	3c 42 02 1c 02 42 3c 00 04 0c 14 24 7e 04 04 00
>a8bd	7e 40 78 04 02 44 38 00 1c 20 40 7c 42 42 3c 00
>a8cd	7e 42 04 08 10 10 10 00 3c 42 42 3c 42 42 3c 00
>a8dd	3c 42 42 3e 02 04 38 00 00 00 08 00 00 08 00 00
>a8ed	00 00 08 00 00 08 08 10 0e 18 30 60 30 18 0e 00
>a8fd	00 00 7e 00 7e 00 00 00 70 18 0c 06 0c 18 70 00
>a90d	3c 42 02 0c 10 00 10 00 00 00 00 00 ff 00 00 00
>a91d	00 00 38 04 3c 44 3a 00 40 40 5c 62 42 62 5c 00
>a92d	00 00 3c 42 40 42 3c 00 02 02 3a 46 42 46 3a 00
>a93d	00 00 3c 42 7e 40 3c 00 0c 12 10 7c 10 10 10 00
>a94d	00 00 3a 46 46 3a 02 3c 40 40 5c 62 42 42 42 00
>a95d	08 00 18 08 08 08 1c 00 04 00 0c 04 04 04 44 38
>a96d	40 40 44 48 50 68 44 00 18 08 08 08 08 08 1c 00
>a97d	00 00 76 49 49 49 49 00 00 00 5c 62 42 42 42 00
>a98d	00 00 3c 42 42 42 3c 00 00 00 5c 62 62 5c 40 40
>a99d	00 00 3a 46 46 3a 02 02 00 00 5c 62 40 40 40 00
>a9ad	00 00 3e 40 3c 02 7c 00 10 10 7c 10 10 12 0c 00
>a9bd	00 00 42 42 42 46 3a 00 00 00 42 42 42 24 18 00
>a9cd	00 00 41 49 49 49 36 00 00 00 42 24 18 24 42 00
>a9dd	00 00 42 42 46 3a 02 3c 00 00 7e 04 18 20 7e 00
>a9ed	08 08 08 08 ff 08 08 08 a0 50 a0 50 a0 50 a0 50
>a9fd	08 08 08 08 08 08 08 08 cc cc 33 33 cc cc 33 33
>aa0d	cc 66 33 99 cc 66 33 99 00 00 00 00 00 00 00 00
>aa1d	f0 f0 f0 f0 f0 f0 f0 f0 00 00 00 00 ff ff ff ff
>aa2d	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff
>aa3d	80 80 80 80 80 80 80 80 aa 55 aa 55 aa 55 aa 55
>aa4d	01 01 01 01 01 01 01 01 00 00 00 00 aa 55 aa 55
>aa5d	99 33 66 cc 99 33 66 cc 03 03 03 03 03 03 03 03
>aa6d	08 08 08 08 0f 08 08 08 00 00 00 00 0f 0f 0f 0f
>aa7d	08 08 08 08 0f 00 00 00 00 00 00 00 f8 08 08 08
>aa8d	00 00 00 00 00 00 ff ff 00 00 00 00 0f 08 08 08
>aa9d	08 08 08 08 ff 00 00 00 00 00 00 00 ff 08 08 08
>aaad	08 08 08 08 f8 08 08 08 c0 c0 c0 c0 c0 c0 c0 c0
>aabd	e0 e0 e0 e0 e0 e0 e0 e0 07 07 07 07 07 07 07 07
>aacd	ff ff 00 00 00 00 00 00 ff ff ff 00 00 00 00 00
>aadd	00 00 00 00 00 ff ff ff 01 02 44 48 50 60 40 00
>aaed	00 00 00 00 f0 f0 f0 f0 0f 0f 0f 0f 00 00 00 00
>aafd	08 08 08 08 f8 00 00 00 f0 f0 f0 f0 00 00 00 00
>ab0d	f0 f0 f0 f0 0f 0f 0f 0f

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/errors.asm

.ab15					SyntaxError:
.ab15	20 44 ab	jsr $ab44			jsr 	ERR_Handler
>ab18	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>ab20	72 72 6f 72 00
.ab25					TypeError:
.ab25	20 44 ab	jsr $ab44			jsr 	ERR_Handler
>ab28	57 72 6f 6e 67 20 74 79				.text 	"Wrong type",0
>ab30	70 65 00
.ab33					BadParamError:
.ab33	20 44 ab	jsr $ab44			jsr 	ERR_Handler
>ab36	42 61 64 20 50 61 72 61				.text 	"Bad Parameter",0
>ab3e	6d 65 74 65 72 00
.ab44					ERR_Handler:
.ab44	a3 00		ldz #$00			ldz 	#0
.ab46	1b		inz				inz
.ab47	ea		nop				nop
.ab48	b2 16		lda ($16),z			lda 	(zCodePtr),z
.ab4a	8d 08 03	sta $0308			sta 	XS_Mantissa
.ab4d	1b		inz				inz
.ab4e	ea		nop				nop
.ab4f	b2 16		lda ($16),z			lda 	(zCodePtr),z
.ab51	8d 09 03	sta $0309			sta 	XS_Mantissa+1
.ab54	fa		plx				plx 								; address in XY
.ab55	7a		ply				ply
.ab56	e8		inx				inx 								; bump, because of RTS/JSR address -1
.ab57	d0 01		bne $ab5a			bne 	_EHNoSkip
.ab59	c8		iny				iny
.ab5a					_EHNoSkip:
.ab5a	20 7b ab	jsr $ab7b			jsr 	PrintROMMessage 			; print message from ROM.
.ab5d	ad 08 03	lda $0308			lda 	XS_Mantissa					; line number = 0
.ab60	0d 09 03	ora $0309			ora 	XS_Mantissa+1
.ab63	f0 0c		beq $ab71			beq 	_EHNoLine
.ab65	a2 76		ldx #$76			ldx 	#_EHAt & $FF 				; print " at "
.ab67	a0 ab		ldy #$ab			ldy 	#(_EHAt >> 8) & $FF
.ab69	20 7b ab	jsr $ab7b			jsr 	PrintROMMessage
.ab6c	a2 00		ldx #$00			ldx 	#0 							; Print line number
.ab6e	20 8c ab	jsr $ab8c			jsr 	Print16BitInteger
.ab71					_EHNoLine:
.ab71	80 fe		bra $ab71			bra 	_EHNoLine
.ab73	4c d1 ad	jmp $add1			jmp 	WarmStart
>ab76	20 61 74 20 00			_EHAt:	.text 	" at ",0
.ab7b					PrintROMMessage:
.ab7b	86 1a		stx $1a				stx 	zLTemp1 					; save addres
.ab7d	84 1b		sty $1b				sty 	zLTemp1+1
.ab7f	a0 00		ldy #$00			ldy 	#0
.ab81					_PRMLoop:
.ab81	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.ab83	f0 06		beq $ab8b			beq		_PRMExit
.ab85	c8		iny				iny
.ab86	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.ab89	80 f6		bra $ab81			bra 	_PRMLoop
.ab8b					_PRMExit:
.ab8b	60		rts				rts
.ab8c					Print16BitInteger:
.ab8c	a9 00		lda #$00			lda 	#0 							; make 32 bit
.ab8e	8d 0a 03	sta $030a			sta 	XS_Mantissa+2
.ab91	8d 0b 03	sta $030b			sta 	XS_Mantissa+3
.ab94	8d 04 04	sta $0404			sta 	NumBufX 					; reset the conversion pointer
.ab97	aa		tax				tax 								; convert bottom level.
.ab98	20 69 ba	jsr $ba69			jsr 	INTToString 				; make string
.ab9b	a2 00		ldx #$00			ldx 	#0 							; print buffer
.ab9d	bd 05 04	lda $0405,x	_P1Loop:lda 	Num_Buffer,x
.aba0	f0 06		beq $aba8			beq 	_P1Exit
.aba2	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.aba5	e8		inx				inx
.aba6	80 f5		bra $ab9d			bra 	_P1Loop
.aba8	60		rts		_P1Exit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm


;******  Processing file: modules/basic/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b4					lastUnaryFunction = $b4
.aba9					VectorTable:
>aba9	e0 b0					.word BinaryOp_And         & $FFFF ; $80 and
>abab	08 b1					.word BinaryOp_Or          & $FFFF ; $81 or
>abad	30 b1					.word BinaryOp_Xor         & $FFFF ; $82 xor
>abaf	30 b1					.word BinaryOp_Eor         & $FFFF ; $83 eor
>abb1	74 b1					.word Binary_Equal         & $FFFF ; $84 =
>abb3	93 b1					.word Binary_NotEqual      & $FFFF ; $85 <>
>abb5	9c b1					.word Binary_Less          & $FFFF ; $86 <
>abb7	a5 b1					.word Binary_LessEqual     & $FFFF ; $87 <=
>abb9	b7 b1					.word Binary_Greater       & $FFFF ; $88 >
>abbb	ae b1					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>abbd	4c b2					.word BinaryOp_Add         & $FFFF ; $8a +
>abbf	6c b2					.word BinaryOp_Subtract    & $FFFF ; $8b -
>abc1	7f b2					.word BinaryOp_Multiply    & $FFFF ; $8c *
>abc3	92 b2					.word BinaryOp_Divide      & $FFFF ; $8d /
>abc5	5d ac					.word NotImplemented       & $FFFF ; $8e ^
>abc7	5d ac					.word NotImplemented       & $FFFF ; $8f if
>abc9	5d ac					.word NotImplemented       & $FFFF ; $90 while
>abcb	5d ac					.word NotImplemented       & $FFFF ; $91 repeat
>abcd	5d ac					.word NotImplemented       & $FFFF ; $92 for
>abcf	5d ac					.word NotImplemented       & $FFFF ; $93 then
>abd1	5d ac					.word NotImplemented       & $FFFF ; $94 endif
>abd3	5d ac					.word NotImplemented       & $FFFF ; $95 wend
>abd5	5d ac					.word NotImplemented       & $FFFF ; $96 until
>abd7	5d ac					.word NotImplemented       & $FFFF ; $97 next
>abd9	5d ac					.word NotImplemented       & $FFFF ; $98 not
>abdb	5d ac					.word NotImplemented       & $FFFF ; $99 fn(
>abdd	c6 b3					.word Unary_Abs            & $FFFF ; $9a abs(
>abdf	1d b5					.word Unary_Asc            & $FFFF ; $9b asc(
>abe1	4a c2					.word Unary_Int            & $FFFF ; $9c int(
>abe3	e4 b3					.word Unary_Peek           & $FFFF ; $9d peek(
>abe5	c1 c1					.word Unary_Rnd            & $FFFF ; $9e rnd(
>abe7	58 b4					.word Unary_Usr            & $FFFF ; $9f usr(
>abe9	5e b5					.word Unary_Left           & $FFFF ; $a0 left$(
>abeb	75 b5					.word Unary_Right          & $FFFF ; $a1 right$(
>abed	43 b5					.word Unary_Mid            & $FFFF ; $a2 mid$(
>abef	d7 b6					.word Unary_Spc            & $FFFF ; $a3 spc(
>abf1	ea b4					.word Unary_Str            & $FFFF ; $a4 str$(
>abf3	79 b4					.word Unary_Val            & $FFFF ; $a5 val(
>abf5	34 b5					.word Unary_Len            & $FFFF ; $a6 len(
>abf7	f3 b5					.word Unary_Hex            & $FFFF ; $a7 hex$(
>abf9	5d ac					.word NotImplemented       & $FFFF ; $a8 sin(
>abfb	5d ac					.word NotImplemented       & $FFFF ; $a9 cos(
>abfd	5d ac					.word NotImplemented       & $FFFF ; $aa tan(
>abff	5d ac					.word NotImplemented       & $FFFF ; $ab atn(
>ac01	5d ac					.word NotImplemented       & $FFFF ; $ac exp(
>ac03	5d ac					.word NotImplemented       & $FFFF ; $ad log(
>ac05	5d ac					.word NotImplemented       & $FFFF ; $ae sqr(
>ac07	4d b6					.word Unary_Dec            & $FFFF ; $af dec(
>ac09	e8 b3					.word Unary_Deek           & $FFFF ; $b0 deek(
>ac0b	ec b3					.word Unary_Leek           & $FFFF ; $b1 leek(
>ac0d	20 b4					.word Unary_Mod            & $FFFF ; $b2 mod(
>ac0f	74 b3					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>ac11	b5 b6					.word Unary_Chr            & $FFFF ; $b4 chr$(
>ac13	5d ac					.word NotImplemented       & $FFFF ; $b5 $
>ac15	5d ac					.word NotImplemented       & $FFFF ; $b6 $(
>ac17	5d ac					.word NotImplemented       & $FFFF ; $b7 #
>ac19	5d ac					.word NotImplemented       & $FFFF ; $b8 #(
>ac1b	5d ac					.word NotImplemented       & $FFFF ; $b9 %
>ac1d	5d ac					.word NotImplemented       & $FFFF ; $ba %(
>ac1f	5d ac					.word NotImplemented       & $FFFF ; $bb (
>ac21	5d ac					.word NotImplemented       & $FFFF ; $bc )
>ac23	5d ac					.word NotImplemented       & $FFFF ; $bd ,
>ac25	52 ae					.word Command_COLON        & $FFFF ; $be :
>ac27	5d ac					.word NotImplemented       & $FFFF ; $bf ;
>ac29	5d ac					.word NotImplemented       & $FFFF ; $c0 def
>ac2b	e9 ae					.word Command_CLR          & $FFFF ; $c1 clr
>ac2d	f7 ae					.word Command_STOP         & $FFFF ; $c2 stop
>ac2f	5d ac					.word NotImplemented       & $FFFF ; $c3 data
>ac31	5d ac					.word NotImplemented       & $FFFF ; $c4 read
>ac33	5d ac					.word NotImplemented       & $FFFF ; $c5 dim
>ac35	5d ac					.word NotImplemented       & $FFFF ; $c6 to
>ac37	5d ac					.word NotImplemented       & $FFFF ; $c7 step
>ac39	5d ac					.word NotImplemented       & $FFFF ; $c8 gosub
>ac3b	5d ac					.word NotImplemented       & $FFFF ; $c9 return
>ac3d	5d ac					.word NotImplemented       & $FFFF ; $ca goto
>ac3f	53 ae					.word Command_END          & $FFFF ; $cb end
>ac41	5d ac					.word NotImplemented       & $FFFF ; $cc input
>ac43	5d ac					.word NotImplemented       & $FFFF ; $cd let
>ac45	5d ac					.word NotImplemented       & $FFFF ; $ce list
>ac47	5d ac					.word NotImplemented       & $FFFF ; $cf new
>ac49	5d ac					.word NotImplemented       & $FFFF ; $d0 old
>ac4b	5d ac					.word NotImplemented       & $FFFF ; $d1 on
>ac4d	5d ac					.word NotImplemented       & $FFFF ; $d2 restore
>ac4f	5d ac					.word NotImplemented       & $FFFF ; $d3 poke
>ac51	58 ae					.word Command_PRINT        & $FFFF ; $d4 print
>ac53	d7 ad					.word Command_RUN          & $FFFF ; $d5 run
>ac55	5d ac					.word NotImplemented       & $FFFF ; $d6 wait
>ac57	5d ac					.word NotImplemented       & $FFFF ; $d7 doke
>ac59	5d ac					.word NotImplemented       & $FFFF ; $d8 loke
>ac5b	cd ae					.word Command_ASSERT       & $FFFF ; $d9 assert
.ac5d					NotImplemented:
.ac5d	20 44 ab	jsr $ab44			jsr ERR_Handler
>ac60	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>ac68	65 6d 65 6e 74 65 64 00
.ac70					BinaryPrecedence:
>ac70	01					.byte 1    ; $80 and
>ac71	01					.byte 1    ; $81 or
>ac72	01					.byte 1    ; $82 xor
>ac73	01					.byte 1    ; $83 eor
>ac74	02					.byte 2    ; $84 =
>ac75	02					.byte 2    ; $85 <>
>ac76	02					.byte 2    ; $86 <
>ac77	02					.byte 2    ; $87 <=
>ac78	02					.byte 2    ; $88 >
>ac79	02					.byte 2    ; $89 >=
>ac7a	03					.byte 3    ; $8a +
>ac7b	03					.byte 3    ; $8b -
>ac7c	04					.byte 4    ; $8c *
>ac7d	04					.byte 4    ; $8d /
>ac7e	05					.byte 5    ; $8e ^
.ac7f					KeywordText:
>ac7f	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>ac82	4f d2					.byte $4f,$d2                          ; $81 or
>ac84	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>ac87	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>ac8a	bd					.byte $bd                              ; $84 =
>ac8b	3c be					.byte $3c,$be                          ; $85 <>
>ac8d	bc					.byte $bc                              ; $86 <
>ac8e	3c bd					.byte $3c,$bd                          ; $87 <=
>ac90	be					.byte $be                              ; $88 >
>ac91	3e bd					.byte $3e,$bd                          ; $89 >=
>ac93	ab					.byte $ab                              ; $8a +
>ac94	ad					.byte $ad                              ; $8b -
>ac95	aa					.byte $aa                              ; $8c *
>ac96	af					.byte $af                              ; $8d /
>ac97	de					.byte $de                              ; $8e ^
>ac98	49 c6					.byte $49,$c6                          ; $8f if
>ac9a	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>ac9f	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>aca5	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>aca8	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>acac	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>acb1	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>acb5	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>acba	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>acbe	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>acc1	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>acc4	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>acc8	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>accc	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>acd0	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>acd5	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>acd9	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>acdd	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>ace3	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>acea	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>acef	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>acf3	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>acf8	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>acfc	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>ad00	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>ad05	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>ad09	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>ad0d	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>ad11	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>ad15	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>ad19	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>ad1d	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>ad21	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>ad25	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>ad2a	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>ad2f	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>ad33	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>ad37	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>ad3c	a4					.byte $a4                              ; $b5 $
>ad3d	24 a8					.byte $24,$a8                          ; $b6 $(
>ad3f	a3					.byte $a3                              ; $b7 #
>ad40	23 a8					.byte $23,$a8                          ; $b8 #(
>ad42	a5					.byte $a5                              ; $b9 %
>ad43	25 a8					.byte $25,$a8                          ; $ba %(
>ad45	a8					.byte $a8                              ; $bb (
>ad46	a9					.byte $a9                              ; $bc )
>ad47	ac					.byte $ac                              ; $bd ,
>ad48	ba					.byte $ba                              ; $be :
>ad49	bb					.byte $bb                              ; $bf ;
>ad4a	44 45 c6				.byte $44,$45,$c6                      ; $c0 def
>ad4d	43 4c d2				.byte $43,$4c,$d2                      ; $c1 clr
>ad50	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $c2 stop
>ad54	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c3 data
>ad58	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c4 read
>ad5c	44 49 cd				.byte $44,$49,$cd                      ; $c5 dim
>ad5f	54 cf					.byte $54,$cf                          ; $c6 to
>ad61	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c7 step
>ad65	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $c8 gosub
>ad6a	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $c9 return
>ad70	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $ca goto
>ad74	45 4e c4				.byte $45,$4e,$c4                      ; $cb end
>ad77	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $cc input
>ad7c	4c 45 d4				.byte $4c,$45,$d4                      ; $cd let
>ad7f	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $ce list
>ad83	4e 45 d7				.byte $4e,$45,$d7                      ; $cf new
>ad86	4f 4c c4				.byte $4f,$4c,$c4                      ; $d0 old
>ad89	4f ce					.byte $4f,$ce                          ; $d1 on
>ad8b	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d2 restore
>ad92	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d3 poke
>ad96	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d4 print
>ad9b	52 55 ce				.byte $52,$55,$ce                      ; $d5 run
>ad9e	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d6 wait
>ada2	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $d7 doke
>ada6	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $d8 loke
>adaa	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $d9 assert
>adb0	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_dollar = $b5
=$b6					token_dollarlparen = $b6
=$b7					token_hash = $b7
=$b8					token_hashlparen = $b8
=$b9					token_percent = $b9
=$ba					token_percentlparen = $ba
=$bb					token_lparen = $bb
=$bc					token_rparen = $bc
=$bd					token_comma = $bd
=$be					token_colon = $be
=$bf					token_semicolon = $bf
=$c0					token_def = $c0
=$c1					token_clr = $c1
=$c2					token_stop = $c2
=$c3					token_data = $c3
=$c4					token_read = $c4
=$c5					token_dim = $c5
=$c6					token_to = $c6
=$c7					token_step = $c7
=$c8					token_gosub = $c8
=$c9					token_return = $c9
=$ca					token_goto = $ca
=$cb					token_end = $cb
=$cc					token_input = $cc
=$cd					token_let = $cd
=$ce					token_list = $ce
=$cf					token_new = $cf
=$d0					token_old = $d0
=$d1					token_on = $d1
=$d2					token_restore = $d2
=$d3					token_poke = $d3
=$d4					token_print = $d4
=$d5					token_run = $d5
=$d6					token_wait = $d6
=$d7					token_doke = $d7
=$d8					token_loke = $d8
=$d9					token_assert = $d9

;******  Return to file: modules/basic/core.asm

.adb1					BASIC_Start:
.adb1	20 4d a2	jsr $a24d			jsr 	IF_Reset 					; set up and clear screen.
.adb4	20 0c a0	jsr $a00c			jsr 	IFT_ClearScreen
.adb7	a9 4c		lda #$4c			lda 	#$4C 						; JMP opcode
.adb9	8d 04 03	sta $0304			sta 	LocalVector
.adbc	8d 00 03	sta $0300			sta 	UserVector
.adbf	a9 67		lda #$67			lda 	#USRDefault & $FF 			; reset USR vector
.adc1	8d 01 03	sta $0301			sta 	UserVector+1
.adc4	a9 b4		lda #$b4			lda 	#(USRDefault >> 8) & $FF
.adc6	8d 02 03	sta $0302			sta 	UserVector+2
.adc9	a9 00		lda #$00			lda 	#(USRDefault >> 16) & $FF
.adcb	8d 03 03	sta $0303			sta 	UserVector+3
.adce	20 e9 ae	jsr $aee9			jsr 	ResetRunStatus 				; clear everything (CLR command)
.add1					WarmStart:
.add1	a2 ff		ldx #$ff			ldx 		#$FF 					; empty stack
.add3	9a		txs				txs
.add4	4c d7 ad	jmp $add7			jmp 	COMMAND_Run

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/run.asm

.add7					Command_RUN:
.add7	20 e9 ae	jsr $aee9			jsr 	ResetRunStatus 				; clear, reset stacks etc.
.adda	a9 00		lda #$00			lda 	#BasicProgram & $FF
.addc	85 16		sta $16				sta 	zCodePtr+0
.adde	a9 80		lda #$80			lda 	#BasicProgram >> 8
.ade0	85 17		sta $17				sta 	zCodePtr+1
.ade2	a9 02		lda #$02			lda 	#2
.ade4	85 18		sta $18				sta 	zCodePtr+2
.ade6	a9 00		lda #$00			lda 	#0
.ade8	85 19		sta $19				sta 	zCodePtr+3
.adea	a3 03		ldz #$03			ldz 	#3
.adec					RUN_NewLine:
.adec	a3 00		ldz #$00			ldz 	#0
.adee	ea		nop				nop
.adef	b2 16		lda ($16),z			lda 	(zCodePtr),z
.adf1	1b		inz				inz
.adf2	1b		inz				inz
.adf3	1b		inz				inz
.adf4	c9 00		cmp #$00			cmp 	#0 							; if the offset is zero then END.
.adf6	d0 18		bne $ae10			bne 	RUN_NextCommand
.adf8	4c f7 ae	jmp $aef7			jmp 	Command_STOP 				; go do the command code.
.adfb					RUN_Skip:
.adfb	ea		nop				nop
.adfc	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read element
.adfe	1b		inz				inz 								; skip
.adff	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.ae01	90 0d		bcc $ae10			bcc 	_SEDone 					; so just skip over it.
.ae03	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.ae05	90 08		bcc $ae0f			bcc 	_SEDouble
.ae07	6b		tza				tza 								; this is Y + 1
.ae08	18		clc				clc
.ae09	ea		nop				nop
.ae0a	72 16		adc ($16),z			adc 	(zCodePtr),z 				; add total length of element
.ae0c	4b		taz				taz 								; back in Y.
.ae0d	3b		dez				dez 								; fix up, one for the +1, one for the iny
.ae0e	3b		dez				dez
.ae0f					_SEDouble:
.ae0f	1b		inz				inz
.ae10					_SEDone:
.ae10					RUN_NextCommand:
.ae10	a9 00		lda #$00			lda 	#0 							; this resets temporary string allocation.
.ae12	85 21		sta $21				sta 	zTempStr+1 					; (initialised when first called)
.ae14	ea		nop				nop
.ae15	b2 16		lda ($16),z			lda 	(zCodePtr),z
.ae17	c9 be		cmp #$be			cmp 	#token_Colon 				; skip over colons
.ae19	f0 e0		beq $adfb			beq 	RUN_Skip
.ae1b	c9 00		cmp #$00			cmp 	#0 							; if non-zero execute whatever
.ae1d	d0 10		bne $ae2f			bne 	RUN_Execute
.ae1f					RUN_NextLine:
.ae1f	a3 00		ldz #$00			ldz 	#0 							; point to offset
.ae21	ea		nop				nop
.ae22	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read it
.ae24	18		clc				clc
.ae25	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.ae27	85 16		sta $16				sta 	zCodePtr
.ae29	90 02		bcc $ae2d			bcc 	_SNLNoCarry
.ae2b	e6 17		inc $17				inc 	zCodePtr+1
.ae2d					_SNLNoCarry:
.ae2d	80 bd		bra $adec			bra 	RUN_NewLine 				; go do the new line code
.ae2f					RUN_Execute:
.ae2f	c9 f8		cmp #$f8			cmp 	#$F8 						; handle shifts, REM etc.
.ae31	b0 18		bcs $ae4b			bcs 	RUN_Extension
.ae33	1b		inz				inz
.ae34	0a		asl a				asl 	a 							; double the character read.
.ae35	90 12		bcc $ae49			bcc 	RUN_Default 				; if carry clear was $00-$7F, so try LET.
.ae37	aa		tax				tax 								; ready to look up.
.ae38	bd a9 ab	lda $aba9,x			lda 	VectorTable,x 				; copy address into LocalVector
.ae3b	8d 05 03	sta $0305			sta 	LocalVector+1
.ae3e	bd aa ab	lda $abaa,x			lda 	VectorTable+1,x
.ae41	8d 06 03	sta $0306			sta 	LocalVector+2
.ae44	20 17 b0	jsr $b017			jsr 	EVCallLocalVector 			; execute the appropriate code.
.ae47	80 c7		bra $ae10			bra 	RUN_NextCommand 			; do the next command.
.ae49					RUN_Default:
.ae49	80 fe		bra $ae49			bra 	RUN_Default
.ae4b					RUN_Extension:
.ae4b	c9 ff		cmp #$ff			cmp 	#$FF 						; if $FF (REM)
.ae4d	f0 ac		beq $adfb			beq 	RUN_Skip 					; skip over it.
.ae4f	4c 15 ab	jmp $ab15			jmp 	SyntaxError
.ae52					Command_COLON:
.ae52	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/end.asm

.ae53					Command_END:
.ae53	80 fe		bra $ae53	_halt:	bra 		_halt
.ae55	4c d1 ad	jmp $add1			jmp 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/print.asm

.ae58					Command_PRINT:
.ae58	ea		nop				nop
.ae59	b2 16		lda ($16),z			lda 	(zCodePtr),z
.ae5b	c9 00		cmp #$00			cmp 	#0 							; end
.ae5d	f0 6a		beq $aec9			beq 	_CPR_NewLine
.ae5f	c9 be		cmp #$be			cmp 	#token_Colon
.ae61	f0 66		beq $aec9			beq 	_CPR_NewLine
.ae63	c9 bf		cmp #$bf			cmp 	#token_SemiColon
.ae65	f0 54		beq $aebb			beq 	_CPR_Skip
.ae67	c9 bd		cmp #$bd			cmp 	#token_Comma
.ae69	f0 4d		beq $aeb8			beq 	_CPR_Tab
.ae6b	20 02 af	jsr $af02			jsr 	EvaluateExpression 			; get expression.
.ae6e	ad 0d 03	lda $030d			lda 	XS_Type 					; get type.
.ae71	29 02		and #$02			and 	#2
.ae73	d0 25		bne $ae9a			bne 	_CPR_String 				; if type = 2 output as string.
.ae75					_CPR_Number:
.ae75	a9 00		lda #$00			lda 	#0 							; reset buffer index
.ae77	8d 04 04	sta $0404			sta 	NumBufX
.ae7a	ad 0d 03	lda $030d			lda 	XS_Type 					; get type
.ae7d	4a		lsr a				lsr 	a
.ae7e	b0 05		bcs $ae85			bcs 	_CPRInt 					; if msb set do as integer
.ae80	20 79 c0	jsr $c079			jsr 	FPToString 					; call fp to str otherwise
.ae83	80 03		bra $ae88			bra 	_CPRNPrint
.ae85	20 69 ba	jsr $ba69	_CPRInt:jsr 	IntToString
.ae88					_CPRNPrint:
.ae88	ad 05 04	lda $0405			lda 	Num_Buffer 					; is first character -
.ae8b	c9 2d		cmp #$2d			cmp 	#"-"
.ae8d	f0 05		beq $ae94			beq 	_CPRNoSpace
.ae8f	a9 20		lda #$20			lda 	#" "						; print the leading space
.ae91	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter 			; so beloved of MS Basics.
.ae94					_CPRNoSpace:
.ae94	a2 04		ldx #$04			ldx 	#(Num_Buffer-1) & $FF
.ae96	a9 04		lda #$04			lda 	#(Num_Buffer-1) >> 8
.ae98	80 06		bra $aea0			bra 	_CPRPrint
.ae9a					_CPR_String:
.ae9a	ae 08 03	ldx $0308			ldx 	XS_Mantissa
.ae9d	ad 09 03	lda $0309			lda 	XS_Mantissa+1
.aea0					_CPRPrint:
.aea0	86 1e		stx $1e				stx 	zGenPtr
.aea2	85 1f		sta $1f				sta 	zGenPtr+1
.aea4	5a		phy				phy
.aea5	a0 00		ldy #$00			ldy 	#0							; get length into X
.aea7	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.aea9	aa		tax				tax
.aeaa	f0 09		beq $aeb5			beq 	_CPREndPrint 				; nothing to print
.aeac					_CPRLoop:
.aeac	c8		iny				iny
.aead	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.aeaf	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.aeb2	ca		dex				dex
.aeb3	d0 f7		bne $aeac			bne 	_CPRLoop
.aeb5					_CPREndPrint:
.aeb5	7a		ply				ply
.aeb6	80 a0		bra $ae58			bra 	Command_Print
.aeb8					_CPR_Tab:
.aeb8	20 5b a0	jsr $a05b			jsr 	IFT_Tab
.aebb					_CPR_Skip:
.aebb	1b		inz				inz
.aebc	ea		nop				nop
.aebd	b2 16		lda ($16),z			lda 	(zCodePtr),z
.aebf	c9 be		cmp #$be			cmp 	#token_Colon 				; colon or $00, exit
.aec1	f0 09		beq $aecc			beq 	_CPR_Exit
.aec3	c9 00		cmp #$00			cmp 	#0
.aec5	d0 91		bne $ae58			bne 	Command_PRINT 				; if not go round again.
.aec7	80 03		bra $aecc			bra 	_CPR_Exit
.aec9					_CPR_NewLine:
.aec9	20 68 a0	jsr $a068			jsr 	IFT_NewLine
.aecc					_CPR_Exit:
.aecc	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/assert.asm

.aecd					Command_ASSERT:
.aecd	20 af b0	jsr $b0af			jsr 	EvaluateNumber 				; calculate thing being asserted
.aed0	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; check if true (non-zero)
.aed3	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.aed6	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.aed9	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.aedc	f0 01		beq $aedf			beq 	_ASFail
.aede	60		rts				rts
.aedf					_ASFail:
.aedf	20 44 ab	jsr $ab44			jsr ERR_Handler
>aee2	41 73 73 65 72 74 00			.text "Assert",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.aee9					Command_CLR:
.aee9					ResetRunStatus:
.aee9	20 c5 b7	jsr $b7c5			jsr 	VariableClear
.aeec	a9 00		lda #$00			lda 	#HighMemory & $FF
.aeee	8d 00 04	sta $0400			sta 	StringPtr
.aef1	a9 70		lda #$70			lda 	#HighMemory >> 8
.aef3	8d 01 04	sta $0401			sta 	StringPtr+1
.aef6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/stop.asm

.aef7					Command_STOP:
.aef7	20 44 ab	jsr $ab44			jsr ERR_Handler
>aefa	53 74 6f 70 00				.text "Stop",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.aeff					EVESyntax:
.aeff	4c 15 ab	jmp $ab15			jmp 	SyntaxError
.af02					EvaluateExpression:
.af02	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.af04					EvaluateExpressionX:
.af04	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.af06					EvaluateExpressionXA:
.af06	48		pha				pha 								; save precedence on stack.
.af07	ea		nop				nop
.af08	b2 16		lda ($16),z			lda 	(zCodePtr),z
.af0a	f0 f3		beq $aeff			beq 	EVESyntax 					; end of line, syntax error.
.af0c	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.af0e	b0 03		bcs $af13			bcs 	_EVNotVariable
.af10	4c 0e b0	jmp $b00e			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.af13					_EVNotVariable:
.af13	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.af15	90 e8		bcc $aeff			bcc 	EVESyntax
.af17	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.af19	b3 82 00	bcs $af9d			bcs 	_EVNotInteger
.af1c	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.af1e	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.af21	a9 00		lda #$00			lda 	#0
.af23	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.af26	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.af29	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.af2c	1a		inc a				inc 	a 							; set to type 1 (integer)
.af2d	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.af30					_EVCheckNextInteger:
.af30	1b		inz				inz
.af31	ea		nop				nop
.af32	b2 16		lda ($16),z			lda 	(zCodePtr),z
.af34	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.af36	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.af38	b0 0d		bcs $af47			bcs 	_EVCheckDecimal
.af3a	48		pha				pha 								; save it.
.af3b	20 1a b0	jsr $b01a			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.af3e	68		pla				pla
.af3f	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.af42	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.af45	80 e9		bra $af30			bra 	_EVCheckNextInteger
.af47					_EVCheckDecimal:
.af47	ea		nop				nop
.af48	b2 16		lda ($16),z			lda 	(zCodePtr),z
.af4a	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.af4c	d0 05		bne $af53			bne 	_EVGotAtom 					; no, get atom.
.af4e					_EVIsDecimal:
.af4e	20 4a b0	jsr $b04a			jsr 	EVGetDecimal 				; extend to the decimal part.
.af51	80 00		bra $af53			bra 	_EVGotAtom 					; and continue to got atom.
.af53					_EVGotAtom:
.af53	ea		nop				nop
.af54	b2 16		lda ($16),z			lda 	(zCodePtr),z
.af56	10 43		bpl $af9b			bpl 	_EVExitDrop 				; must be a token.
.af58	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.af5a	b0 3f		bcs $af9b			bcs 	_EVExitDrop
.af5c	68		pla				pla 								; get current precedence
.af5d	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.af5f	da		phx				phx 								; save X
.af60	ea		nop				nop
.af61	b2 16		lda ($16),z			lda 	(zCodePtr),z
.af63	aa		tax				tax 								; put in X
.af64	bd f0 ab	lda $abf0,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.af67	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.af69	fa		plx				plx 								; restore X
.af6a	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.af6c	90 2e		bcc $af9c			bcc 	_EVExit 					; exit if too low.
.af6e	f0 2c		beq $af9c			beq 	_EVExit 					; exit if equals
.af70	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.af72	48		pha				pha
.af73	ea		nop				nop
.af74	b2 16		lda ($16),z			lda 	(zCodePtr),z
.af76	48		pha				pha
.af77	1b		inz				inz
.af78	da		phx				phx 								; save current position
.af79	e8		inx				inx
.af7a	e8		inx				inx
.af7b	e8		inx				inx
.af7c	e8		inx				inx
.af7d	e8		inx				inx
.af7e	e8		inx				inx
.af7f	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.af81	20 06 af	jsr $af06			jsr 	EvaluateExpressionXA 		; do the RHS.
.af84	fa		plx				plx 								; restore X
.af85	68		pla				pla 								; get the binary operator in A.
.af86					_EVCallA:
.af86	da		phx				phx 								; save X again
.af87	0a		asl a				asl 	a 							; double, lose the MSB.
.af88	aa		tax				tax									; put in X
.af89	bd a9 ab	lda $aba9,x			lda 	VectorTable,x 				; copy address into zGenPtr
.af8c	8d 05 03	sta $0305			sta 	LocalVector+1
.af8f	bd aa ab	lda $abaa,x			lda 	VectorTable+1,x
.af92	8d 06 03	sta $0306			sta 	LocalVector+2
.af95	fa		plx				plx 								; restore X
.af96	20 17 b0	jsr $b017			jsr 	EVCallLocalVector
.af99	80 b8		bra $af53			bra 	_EVGotAtom 					; and loop back.
.af9b					_EVExitDrop:
.af9b	68		pla				pla
.af9c					_EVExit:
.af9c	60		rts				rts
.af9d					_EVNotInteger:
.af9d	1b		inz				inz
.af9e	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.afa0	d0 19		bne $afbb			bne 	_EVNotMinus
.afa2	20 9d b0	jsr $b09d			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.afa5	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.afa8	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.afaa	f0 05		beq $afb1			beq 	_EVMinusFloat
.afac	20 44 ba	jsr $ba44			jsr 	IntegerNegateAlways 		; negation
.afaf	80 a2		bra $af53			bra 	_EVGotAtom 					; and go back.
.afb1					_EVMinusFloat:
.afb1	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; invert the sign bit.
.afb4	49 80		eor #$80			eor 	#$80
.afb6	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.afb9	80 98		bra $af53			bra 	_EVGotAtom
.afbb					_EVNotMinus:
.afbb	c9 bb		cmp #$bb			cmp 	#token_lparen 				; is it left parenthesis
.afbd	d0 18		bne $afd7			bne 	_EVNotParenthesis
.afbf	20 04 af	jsr $af04			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.afc2	ea		nop				nop
.afc3	b2 16		lda ($16),z			lda 	(zCodePtr),z
.afc5	1b		inz				inz
.afc6	c9 bc		cmp #$bc			cmp 	#token_rparen 				; okay if right bracket.
.afc8	f0 89		beq $af53			beq 	_EVGotAtom
.afca	20 44 ab	jsr $ab44			jsr ERR_Handler
>afcd	4d 69 73 73 69 6e 67 20			.text "Missing )",0
>afd5	29 00
.afd7					_EVNotParenthesis:
.afd7	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.afd9	d0 0c		bne $afe7			bne 	_EVNotNot
.afdb	20 9d b0	jsr $b09d			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.afde	20 4e bf	jsr $bf4e			jsr 	FPUToInteger 				; make it an integer - if possible.
.afe1	20 7a b0	jsr $b07a			jsr 	NotInteger 					; do the not calculation
.afe4	4c 53 af	jmp $af53			jmp 	_EVGotAtom
.afe7					_EVNotNot:
.afe7	c9 fe		cmp #$fe			cmp 	#$FE
.afe9	d0 15		bne $b000			bne 	_EVNotString
.afeb	20 90 b7	jsr $b790			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.afee	a5 20		lda $20				lda 	zTempStr 					; copy address of string into mantissa
.aff0	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.aff3	a5 21		lda $21				lda 	zTempStr+1
.aff5	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.aff8	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.affa	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.affd	4c 53 af	jmp $af53			jmp 	_EVGotAtom
.b000					_EVNotString:
.b000	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.b002	90 04		bcc $b008			bcc 	_EVBadElement
.b004	c9 b5		cmp #$b5			cmp 	#lastUnaryFunction+1
.b006	90 03		bcc $b00b			bcc 	_EVUnaryFunction
.b008					_EVBadElement:
.b008	4c 15 ab	jmp $ab15			jmp 	SyntaxError
.b00b					_EVUnaryFunction:
.b00b	4c 86 af	jmp $af86			jmp 	_EVCallA
.b00e					_EVVariableHandler:
.b00e	20 b9 b7	jsr $b7b9			jsr 	VariableFind 				; locate a variable
.b011	20 f8 b8	jsr $b8f8			jsr 	VariableGet 				; copy into memory.
.b014	4c 53 af	jmp $af53			jmp 	_EVGotAtom 					; and go round.
.b017					EVCallLocalVector:
.b017	6c 05 03	jmp ($0305)			jmp 	(LocalVector+1)
.b01a					EVShiftMantissaLeft6:
.b01a	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.b01d	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.b020	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.b023	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b026	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b029	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b02c	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b02f	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b032	a9 00		lda #$00			lda 	#0
.b034	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b037	20 3a b0	jsr $b03a			jsr 	_EVSMLShift 					; call it here to do it twice
.b03a					_EVSMLShift:
.b03a	5e 0c 03	lsr $030c,x			lsr 	XS_Exponent,x
.b03d	7e 0b 03	ror $030b,x			ror 	XS_Mantissa+3,x
.b040	7e 0a 03	ror $030a,x			ror 	XS_Mantissa+2,x
.b043	7e 09 03	ror $0309,x			ror 	XS_Mantissa+1,x
.b046	7e 08 03	ror $0308,x			ror 	XS_Mantissa+0,x
.b049	60		rts				rts
.b04a					EVGetDecimal:
.b04a	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.b04c	8d 05 04	sta $0405			sta 	Num_Buffer
.b04f	da		phx				phx
.b050	1b		inz				inz
.b051	ea		nop				nop
.b052	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b054	1b		inz				inz
.b055	3a		dec a				dec 	a								; convert to a string length.
.b056	3a		dec a				dec 	a
.b057	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.b059					_EVGDCopy:
.b059	48		pha				pha 									; save count
.b05a	ea		nop				nop
.b05b	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b05d	9d 05 04	sta $0405,x			sta 	Num_Buffer,x
.b060	e8		inx				inx 									; forward ....
.b061	1b		inz				inz
.b062	68		pla				pla 									; get count
.b063	3a		dec a				dec 	a 								; until zero
.b064	d0 f3		bne $b059			bne 	_EVGDCopy
.b066	9d 05 04	sta $0405,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.b069	fa		plx				plx 									; restore X
.b06a	a9 05		lda #$05			lda 	#Num_Buffer & $FF 				; set zGenPtr
.b06c	85 1e		sta $1e				sta 	zGenPtr
.b06e	a9 04		lda #$04			lda 	#Num_Buffer >> 8
.b070	85 1f		sta $1f				sta 	zGenPtr+1
.b072	5a		phy				phy 									; save Y
.b073	a0 00		ldy #$00			ldy 	#0 								; start position
.b075	20 40 c1	jsr $c140			jsr 	FPFromString 					; convert current
.b078	7a		ply				ply 									; restore Y
.b079	60		rts				rts
.b07a					NotInteger:
.b07a	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b07d	49 ff		eor #$ff			eor 	#$FF
.b07f	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b082	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b085	49 ff		eor #$ff			eor 	#$FF
.b087	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b08a	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.b08d	49 ff		eor #$ff			eor 	#$FF
.b08f	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b092	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.b095	49 ff		eor #$ff			eor 	#$FF
.b097	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b09a	60		rts				rts
.b09b					EvaluateGetAtom:
.b09b	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.b09d					EvaluateGetAtomX:
.b09d	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.b09f	20 06 af	jsr $af06			jsr 	EvaluateExpressionXA
.b0a2	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.b0a5	29 0f		and #$0f			and 	#15
.b0a7	c9 02		cmp #$02			cmp 	#2
.b0a9	b0 01		bcs $b0ac			bcs 	EvaluateType
.b0ab	60		rts				rts
.b0ac					EvaluateType:
.b0ac	4c 25 ab	jmp $ab25			jmp 	TypeError
.b0af					EvaluateNumber:
.b0af	a2 00		ldx #$00			ldx 	#0
.b0b1					EvaluateNumberX:
.b0b1	20 04 af	jsr $af04			jsr 	EvaluateExpressionX
.b0b4	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 0/1
.b0b7	29 0f		and #$0f			and 	#15
.b0b9	c9 02		cmp #$02			cmp 	#2
.b0bb	b0 ef		bcs $b0ac			bcs 	EvaluateType
.b0bd	60		rts				rts
.b0be					EvaluateInteger:
.b0be	a2 00		ldx #$00			ldx 	#0
.b0c0					EvaluateIntegerX:
.b0c0	20 b1 b0	jsr $b0b1			jsr 	EvaluateNumberX
.b0c3	20 4e bf	jsr $bf4e			jsr 	FPUToInteger
.b0c6	60		rts				rts
.b0c7					EvaluateString:
.b0c7	a2 00		ldx #$00			ldx 	#0
.b0c9					EvaluateStringX:
.b0c9	20 04 af	jsr $af04			jsr 	EvaluateExpressionX
.b0cc	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 2
.b0cf	29 0f		and #$0f			and 	#15
.b0d1	c9 02		cmp #$02			cmp 	#2
.b0d3	d0 d7		bne $b0ac			bne 	EvaluateType
.b0d5	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.b0d8	85 1e		sta $1e				sta 	zGenPtr
.b0da	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b0dd	85 1f		sta $1f				sta 	zGenPtr+1
.b0df	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.b0e0					BinaryOp_And:
.b0e0	20 58 b1	jsr $b158			jsr 	BinaryMakeBothInteger
.b0e3	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.b0e6	3d 0e 03	and $030e,x			and 	XS2_Mantissa+0,x
.b0e9	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b0ec	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.b0ef	3d 0f 03	and $030f,x			and 	XS2_Mantissa+1,x
.b0f2	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b0f5	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.b0f8	3d 10 03	and $0310,x			and 	XS2_Mantissa+2,x
.b0fb	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b0fe	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.b101	3d 11 03	and $0311,x			and 	XS2_Mantissa+3,x
.b104	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b107	60		rts				rts
.b108					BinaryOp_Or:
.b108	20 58 b1	jsr $b158			jsr 	BinaryMakeBothInteger
.b10b	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.b10e	1d 0e 03	ora $030e,x			ora 	XS2_Mantissa+0,x
.b111	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b114	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.b117	1d 0f 03	ora $030f,x			ora 	XS2_Mantissa+1,x
.b11a	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b11d	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.b120	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.b123	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b126	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.b129	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.b12c	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b12f	60		rts				rts
.b130					BinaryOp_Eor:
.b130					BinaryOp_Xor:
.b130	20 58 b1	jsr $b158			jsr 	BinaryMakeBothInteger
.b133	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.b136	5d 0e 03	eor $030e,x			eor 	XS2_Mantissa+0,x
.b139	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b13c	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.b13f	5d 0f 03	eor $030f,x			eor 	XS2_Mantissa+1,x
.b142	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b145	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.b148	5d 10 03	eor $0310,x			eor 	XS2_Mantissa+2,x
.b14b	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b14e	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.b151	5d 11 03	eor $0311,x			eor 	XS2_Mantissa+3,x
.b154	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b157	60		rts				rts
.b158					BinaryMakeBothInteger:
.b158	da		phx				phx 								; save X
.b159	e8		inx				inx
.b15a	e8		inx				inx
.b15b	e8		inx				inx
.b15c	e8		inx				inx
.b15d	e8		inx				inx
.b15e	e8		inx				inx
.b15f	20 63 b1	jsr $b163			jsr 	BinaryMakeInteger 			; convert to integer.
.b162	fa		plx				plx 								; restore X and fall through.
.b163					BinaryMakeInteger:
.b163	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type byte.
.b166	29 0f		and #$0f			and 	#15 						; check type zero
.b168	f0 04		beq $b16e			beq 	_BMIConvert 				; if float convert to integer.
.b16a	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.b16b	90 04		bcc $b171			bcc 	_BMIError
.b16d	60		rts				rts
.b16e					_BMIConvert:
.b16e	4c 4e bf	jmp $bf4e			jmp 	FPUToInteger 				; convert to integer
.b171					_BMIError:
.b171	4c 25 ab	jmp $ab25			jmp 	TypeError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.b174					Binary_Equal:
.b174	20 c0 b1	jsr $b1c0			jsr 	CompareValues
.b177	09 00		ora #$00			ora 	#0
.b179	f0 04		beq $b17f			beq 	CCTrue
.b17b	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.b17d	80 02		bra $b181			bra 	CCWrite
.b17f	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.b181	9d 08 03	sta $0308,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.b184	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b187	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b18a	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b18d	a9 01		lda #$01			lda 	#1
.b18f	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; set type to integer whatever.
.b192	60		rts				rts
.b193					Binary_NotEqual:
.b193	20 c0 b1	jsr $b1c0			jsr 	CompareValues
.b196	09 00		ora #$00			ora 	#0
.b198	f0 e1		beq $b17b			beq 	CCFalse
.b19a	80 e3		bra $b17f			bra 	CCTrue
.b19c					Binary_Less:
.b19c	20 c0 b1	jsr $b1c0			jsr 	CompareValues
.b19f	09 00		ora #$00			ora 	#0
.b1a1	30 dc		bmi $b17f			bmi 	CCTrue
.b1a3	80 d6		bra $b17b			bra 	CCFalse
.b1a5					Binary_LessEqual:
.b1a5	20 c0 b1	jsr $b1c0			jsr 	CompareValues
.b1a8	c9 01		cmp #$01			cmp 	#1
.b1aa	d0 d3		bne $b17f			bne 	CCTrue
.b1ac	80 cd		bra $b17b			bra 	CCFalse
.b1ae					Binary_GreaterEqual:
.b1ae	20 c0 b1	jsr $b1c0			jsr 	CompareValues
.b1b1	09 00		ora #$00			ora 	#0
.b1b3	10 ca		bpl $b17f			bpl 	CCTrue
.b1b5	80 c4		bra $b17b			bra 	CCFalse
.b1b7					Binary_Greater:
.b1b7	20 c0 b1	jsr $b1c0			jsr 	CompareValues
.b1ba	c9 01		cmp #$01			cmp 	#1
.b1bc	f0 c1		beq $b17f			beq 	CCTrue
.b1be	80 bb		bra $b17b			bra 	CCFalse
.b1c0					CompareValues:
.b1c0	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and the types together
.b1c3	3d 13 03	and $0313,x			and 	XS2_Type,x
.b1c6	c9 02		cmp #$02			cmp 	#2
.b1c8	f0 13		beq $b1dd			beq 	_CVString
.b1ca	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b1cd	3d 13 03	and $0313,x			and 	XS2_Type,x
.b1d0	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b1d1	90 03		bcc $b1d6			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b1d3	4c 23 b2	jmp $b223			jmp 	CompareInteger32 							; so execute code at \1
.b1d6					_BCFloat:
.b1d6	20 f1 b2	jsr $b2f1			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b1d9	4c 5d be	jmp $be5d			jmp 	FPCompare 							; and execute code at \2
.b1dc	60		rts				rts
.b1dd					_CVString:
.b1dd	da		phx				phx 								; save XY
.b1de	5a		phy				phy
.b1df	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.b1e2	85 1a		sta $1a				sta		zLTemp1+0
.b1e4	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b1e7	85 1b		sta $1b				sta 	zLTemp1+1
.b1e9	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x
.b1ec	85 1c		sta $1c				sta 	zLTemp1+2
.b1ee	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.b1f1	85 1d		sta $1d				sta 	zLTemp1+3
.b1f3	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.b1f5	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b1f7	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.b1f9	90 02		bcc $b1fd			bcc 	_CVCommon
.b1fb	b1 1c		lda ($1c),y			lda 	(zLTemp1+2),y
.b1fd					_CVCommon:
.b1fd	aa		tax				tax 								; put shorter string length in zero.
.b1fe	f0 0c		beq $b20c			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.b200					_CVCompare:
.b200	c8		iny				iny 								; next character
.b201	b1 1a		lda ($1a),y			lda 	(zLTemp1),y 				; compare characters
.b203	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.b205	90 13		bcc $b21a			bcc 	_CVReturnLess 				; <
.b207	d0 15		bne $b21e			bne 	_CVReturnGreater 			; >
.b209	ca		dex				dex 								; until common length matched.
.b20a	d0 f4		bne $b200			bne 	_CVCompare
.b20c					_CVMatch:
.b20c	a0 00		ldy #$00			ldy 	#0
.b20e	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b210	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.b212	90 06		bcc $b21a			bcc 	_CVReturnLess 				; <
.b214	d0 08		bne $b21e			bne 	_CVReturnGreater 			; >
.b216	a9 00		lda #$00			lda 	#0
.b218	80 06		bra $b220			bra 	_CVExit 					; same common, same length, same string
.b21a					_CVReturnLess:
.b21a	a9 ff		lda #$ff			lda 	#$FF
.b21c	80 02		bra $b220			bra 	_CVExit
.b21e					_CVReturnGreater:
.b21e	a9 01		lda #$01			lda 	#$01
.b220					_CVExit:
.b220	7a		ply				ply
.b221	fa		plx				plx
.b222	60		rts				rts
.b223					CompareInteger32:
.b223	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.b226	49 80		eor #$80			eor 	#$80
.b228	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b22b	bd 11 03	lda $0311,x			lda 	XS2_Mantissa+3,x
.b22e	49 80		eor #$80			eor 	#$80
.b230	9d 11 03	sta $0311,x			sta 	XS2_Mantissa+3,x
.b233	20 cb b2	jsr $b2cb			jsr 	SubInteger32 				; subtraction
.b236	90 11		bcc $b249			bcc 	_CI32Less 					; cc return -1
.b238	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; check if zero
.b23b	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.b23e	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.b241	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.b244	f0 02		beq $b248			beq 	_CI32Exit
.b246	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.b248					_CI32Exit:
.b248	60		rts				rts
.b249					_CI32Less:
.b249	a9 ff		lda #$ff			lda 	#$FF
.b24b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.b24c					BinaryOp_Add:
.b24c	bd 0d 03	lda $030d,x			lda 	XS_Type,x  					; and types together
.b24f	3d 13 03	and $0313,x			and 	XS2_Type,x
.b252	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.b254	d0 13		bne $b269			bne 	_BOAString
.b256	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b259	3d 13 03	and $0313,x			and 	XS2_Type,x
.b25c	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b25d	90 03		bcc $b262			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b25f	4c a5 b2	jmp $b2a5			jmp 	AddInteger32 							; so execute code at \1
.b262					_BCFloat:
.b262	20 f1 b2	jsr $b2f1			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b265	4c d1 bb	jmp $bbd1			jmp 	FPAdd 							; and execute code at \2
.b268	60		rts				rts
.b269					_BOAString:
.b269	4c 0c b3	jmp $b30c			jmp 	ConcatenateString 			; concatenate two strings.
.b26c					BinaryOp_Subtract:
.b26c	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b26f	3d 13 03	and $0313,x			and 	XS2_Type,x
.b272	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b273	90 03		bcc $b278			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b275	4c cb b2	jmp $b2cb			jmp 	SubInteger32 							; so execute code at \1
.b278					_BCFloat:
.b278	20 f1 b2	jsr $b2f1			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b27b	4c c7 bb	jmp $bbc7			jmp 	FPSubtract 							; and execute code at \2
.b27e	60		rts				rts
.b27f					BinaryOp_Multiply:
.b27f	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b282	3d 13 03	and $0313,x			and 	XS2_Type,x
.b285	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b286	90 03		bcc $b28b			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b288	4c 57 b9	jmp $b957			jmp 	MulInteger32 							; so execute code at \1
.b28b					_BCFloat:
.b28b	20 f1 b2	jsr $b2f1			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b28e	4c 3d bd	jmp $bd3d			jmp 	FPMultiply 							; and execute code at \2
.b291	60		rts				rts
.b292					BinaryOp_Divide:
.b292	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b295	3d 13 03	and $0313,x			and 	XS2_Type,x
.b298	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b299	90 03		bcc $b29e			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b29b	4c ae b9	jmp $b9ae			jmp 	DivInteger32 							; so execute code at \1
.b29e					_BCFloat:
.b29e	20 f1 b2	jsr $b2f1			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b2a1	4c b5 bc	jmp $bcb5			jmp 	FPDivide 							; and execute code at \2
.b2a4	60		rts				rts
.b2a5					AddInteger32:
.b2a5	18		clc				clc
.b2a6	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b2a9	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.b2ac	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b2af	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b2b2	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.b2b5	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b2b8	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.b2bb	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.b2be	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b2c1	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.b2c4	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.b2c7	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b2ca	60		rts				rts
.b2cb					SubInteger32:
.b2cb	38		sec				sec
.b2cc	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b2cf	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.b2d2	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b2d5	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b2d8	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.b2db	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b2de	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.b2e1	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.b2e4	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b2e7	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.b2ea	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.b2ed	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b2f0	60		rts				rts
.b2f1					BinaryMakeBothFloat:
.b2f1	da		phx				phx 								; save X
.b2f2	e8		inx				inx
.b2f3	e8		inx				inx
.b2f4	e8		inx				inx
.b2f5	e8		inx				inx
.b2f6	e8		inx				inx
.b2f7	e8		inx				inx
.b2f8	20 fc b2	jsr $b2fc			jsr 	BinaryMakeFloat 			; convert to float.
.b2fb	fa		plx				plx 								; restore X and fall through.
.b2fc					BinaryMakeFloat:
.b2fc	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type byte.
.b2ff	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.b300	b0 04		bcs $b306			bcs 	_BMFConvert
.b302	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.b303	b0 04		bcs $b309			bcs 	_BMFError
.b305	60		rts				rts
.b306					_BMFConvert:
.b306	4c ef be	jmp $beef			jmp 	FPUToFloat 					; convert to float
.b309					_BMFError:
.b309	4c 25 ab	jmp $ab25			jmp 	TypeError
.b30c					ConcatenateString:
.b30c	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.b30f	85 1a		sta $1a				sta		zLTemp1+0
.b311	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b314	85 1b		sta $1b				sta 	zLTemp1+1
.b316	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x
.b319	85 1c		sta $1c				sta 	zLTemp1+2
.b31b	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.b31e	85 1d		sta $1d				sta 	zLTemp1+3
.b320	5a		phy				phy
.b321	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.b323	b1 1a		lda ($1a),y			lda 	(zlTemp1),y
.b325	71 1c		adc ($1c),y			adc 	(zlTemp1+2),y
.b327	7a		ply				ply
.b328	b0 37		bcs $b361			bcs 	_CSError					; check in range.
.b32a	c9 fe		cmp #$fe			cmp 	#maxString+1
.b32c	b0 33		bcs $b361			bcs 	_CSError
.b32e	20 55 b7	jsr $b755			jsr 	AllocateTempString 			; store the result
.b331	20 4c b3	jsr $b34c			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.b334	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.b337	85 1a		sta $1a				sta 	zLTemp1
.b339	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.b33c	85 1b		sta $1b				sta 	zLTemp1+1
.b33e	20 4c b3	jsr $b34c			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.b341	a5 20		lda $20				lda 	zTempStr 					; point current to new string
.b343	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b346	a5 21		lda $21				lda 	zTempStr+1
.b348	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b34b	60		rts				rts
.b34c					_CSCopyString:
.b34c	da		phx				phx
.b34d	5a		phy				phy
.b34e	a0 00		ldy #$00			ldy 	#0 							; get length
.b350	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b352	f0 0a		beq $b35e			beq 	_CSCSExit 					; if zero, exit
.b354	aa		tax				tax 								; put in X
.b355					_CSCSLoop:
.b355	c8		iny				iny 								; get next char
.b356	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b358	20 80 b7	jsr $b780			jsr		WriteTempString 			; copy out
.b35b	ca		dex				dex 								; do whole string
.b35c	d0 f7		bne $b355			bne 	_CSCSLoop
.b35e					_CSCSExit:
.b35e	7a		ply				ply
.b35f	fa		plx				plx
.b360	60		rts				rts
.b361					_CSError:
.b361	20 44 ab	jsr $ab44			jsr ERR_Handler
>b364	53 74 72 69 6e 67 20 74			.text "String too long",0
>b36c	6f 6f 20 6c 6f 6e 67 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.b374					Unary_Sgn:
.b374	20 b1 b0	jsr $b0b1			jsr 	EvaluateNumberX 			; get value
.b377	20 43 b7	jsr $b743			jsr 	CheckNextRParen 			; check right bracket.
.b37a	20 9e b3	jsr $b39e			jsr 	GetSignCurrent 				; get sign.
.b37d	09 00		ora #$00			ora 	#0
.b37f	10 09		bpl $b38a			bpl		UnarySetAInteger			; if 0,1 return that.
.b381	80 00		bra $b383			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.b383					UnarySetAMinus1:
.b383	a9 ff		lda #$ff			lda 	#$FF
.b385	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.b388	80 05		bra $b38f			bra 	UnarySetAFill
.b38a					UnarySetAInteger:
.b38a	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.b38d	a9 00		lda #$00			lda 	#0
.b38f					UnarySetAFill:
.b38f	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b392	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b395	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b398	a9 01		lda #$01			lda 	#1
.b39a	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.b39d	60		rts				rts
.b39e					GetSignCurrent:
.b39e	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; identify type.
.b3a1	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.b3a2	90 19		bcc $b3bd			bcc 	_GSCFloat
.b3a4	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.b3a7	30 11		bmi $b3ba			bmi 	_GSCMinus1
.b3a9	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x
.b3ac	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.b3af	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.b3b2	d0 03		bne $b3b7			bne 	_GSCPlus1
.b3b4					_GSCZero:
.b3b4	a9 00		lda #$00			lda 	#0
.b3b6	60		rts				rts
.b3b7					_GSCPlus1:
.b3b7	a9 01		lda #$01			lda 	#$01
.b3b9	60		rts				rts
.b3ba					_GSCMinus1:
.b3ba	a9 ff		lda #$ff			lda 	#$FF
.b3bc	60		rts				rts
.b3bd					_GSCFloat:
.b3bd	3c 0d 03	bit $030d,x			bit 	XS_Type,x
.b3c0	70 f2		bvs $b3b4			bvs 	_GSCZero
.b3c2	30 f6		bmi $b3ba			bmi 	_GSCMinus1
.b3c4	80 f1		bra $b3b7			bra 	_GSCPlus1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.b3c6					Unary_Abs:
.b3c6	20 b1 b0	jsr $b0b1			jsr 	EvaluateNumberX 			; get value
.b3c9	20 43 b7	jsr $b743			jsr 	CheckNextRParen 			; check right bracket.
.b3cc	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.b3cf	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.b3d1	f0 08		beq $b3db			beq 	_UAMinusFloat
.b3d3	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; check MSB
.b3d6	10 0b		bpl $b3e3			bpl 	_UAExit
.b3d8	4c 44 ba	jmp $ba44			jmp 	IntegerNegateAlways 		; negation
.b3db					_UAMinusFloat:
.b3db	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; clear the sign bit.
.b3de	29 7f		and #$7f			and		#$7F
.b3e0	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.b3e3					_UAExit:
.b3e3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.b3e4					Unary_Peek:
.b3e4	a9 01		lda #$01			lda 	#1
.b3e6	80 06		bra $b3ee			bra 	UPMain
.b3e8					Unary_Deek:
.b3e8	a9 02		lda #$02			lda 	#2
.b3ea	80 02		bra $b3ee			bra 	UPMain
.b3ec					Unary_Leek:
.b3ec	a9 04		lda #$04			lda 	#4
.b3ee					UPMain:
.b3ee	48		pha				pha 								; set bytes to copy.
.b3ef	20 c0 b0	jsr $b0c0			jsr 	EvaluateIntegerX 			; numeric parameter
.b3f2	20 43 b7	jsr $b743			jsr 	CheckNextRParen 			; right bracket.
.b3f5	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.b3f8	85 1a		sta $1a				sta 	zLTemp1
.b3fa	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b3fd	85 1b		sta $1b				sta 	zLTemp1+1
.b3ff	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.b402	85 1c		sta $1c				sta 	zLTemp1+2
.b404	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.b407	85 1d		sta $1d				sta 	zLTemp1+3
.b409	a9 00		lda #$00			lda 	#0 							; clear target area
.b40b	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b40e	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b411	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b414	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b417	68		pla				pla 								; restore bytes to copy
.b418	da		phx				phx 								; save XY
.b419	5a		phy				phy
.b41a	20 16 b7	jsr $b716			jsr 	MemRead 					; read the bytes in
.b41d	7a		ply				ply 								; restore and exit
.b41e	fa		plx				plx
.b41f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.b420					Unary_Mod:
.b420	20 4c b4	jsr $b44c			jsr 	_UMParameter 				; first parameter
.b423	20 4c b7	jsr $b74c			jsr 	CheckNextComma
.b426	da		phx				phx 								; second parameter
.b427	e8		inx				inx
.b428	e8		inx				inx
.b429	e8		inx				inx
.b42a	e8		inx				inx
.b42b	e8		inx				inx
.b42c	e8		inx				inx
.b42d	20 4c b4	jsr $b44c			jsr 	_UMParameter
.b430	fa		plx				plx
.b431	20 43 b7	jsr $b743			jsr 	CheckNextRParen
.b434	20 ae b9	jsr $b9ae			jsr 	DivInteger32 				; divide
.b437	a5 1a		lda $1a				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.b439	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b43c	a5 1b		lda $1b				lda 	zLTemp1+1
.b43e	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b441	a5 1c		lda $1c				lda 	zLTemp1+2
.b443	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b446	a5 1d		lda $1d				lda 	zLTemp1+3
.b448	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b44b	60		rts				rts
.b44c					_UMParameter:
.b44c	20 c0 b0	jsr $b0c0			jsr 	EvaluateIntegerX 			; get value
.b44f	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; absolute value
.b452	10 03		bpl $b457			bpl 	_UMNotSigned
.b454	20 44 ba	jsr $ba44			jsr 	IntegerNegateAlways
.b457					_UMNotSigned:
.b457	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.b458					Unary_Usr:
.b458	20 b1 b0	jsr $b0b1			jsr 	EvaluateNumberX 			; numeric parameter
.b45b	20 43 b7	jsr $b743			jsr 	CheckNextRParen 			; right bracket.
.b45e	da		phx				phx 								; save XY
.b45f	5a		phy				phy
.b460	ea		nop				nop
.b461	20 00 03	jsr $0300			jsr 	UserVector 					; call the USR function.
.b464	7a		ply				ply 								; and exit
.b465	fa		plx				plx
.b466	60		rts				rts
.b467					USRDefault:
.b467	20 44 ab	jsr $ab44			jsr ERR_Handler
>b46a	4e 6f 20 55 53 52 20 76			.text "No USR vector.",0
>b472	65 63 74 6f 72 2e 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.b479					Unary_Val:
.b479	20 c9 b0	jsr $b0c9			jsr 	EvaluateStringX 			; get string
.b47c	20 43 b7	jsr $b743			jsr 	CheckNextRParen 			; check right bracket.
.b47f	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.b482	85 1e		sta $1e				sta 	zGenPtr
.b484	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b487	85 1f		sta $1f				sta 	zGenPtr+1
.b489	5a		phy				phy
.b48a	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.b48c	b1 1e		lda ($1e),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.b48e	f0 57		beq $b4e7			beq 	_UVBadNumber
.b490	48		pha				pha 								; save length.
.b491	1a		inc a				inc 	a 							; one for the length, one for the terminator
.b492	1a		inc a				inc 	a
.b493	20 55 b7	jsr $b755			jsr 	AllocateTempString
.b496	c8		iny				iny 								; move to the next.
.b497	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get character
.b499	49 2d		eor #$2d			eor 	#"-"						; zero if minus sign
.b49b	8d 90 04	sta $0490			sta 	ValSign
.b49e	d0 04		bne $b4a4			bne 	_UVNotMinus
.b4a0	c8		iny				iny 								; skip over it.
.b4a1	68		pla				pla 								; decrement character count.
.b4a2	3a		dec a				dec 	a
.b4a3	48		pha				pha
.b4a4					_UVNotMinus:
.b4a4	68		pla				pla 								; this is the count.
.b4a5	48		pha		_UVCopy:pha									; copy into new temp string which is ASCIIZ
.b4a6	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b4a8	c8		iny				iny
.b4a9	20 80 b7	jsr $b780			jsr 	WriteTempString
.b4ac	68		pla				pla
.b4ad	3a		dec a				dec 	a
.b4ae	d0 f5		bne $b4a5			bne 	_UVCopy
.b4b0	20 80 b7	jsr $b780			jsr 	WriteTempString 			; make it ASCIIZ
.b4b3	18		clc				clc
.b4b4	a5 20		lda $20				lda 	zTempStr 					; tempstring +1 => genptr
.b4b6	69 01		adc #$01			adc 	#1
.b4b8	85 1e		sta $1e				sta 	zGenPtr
.b4ba	a5 21		lda $21				lda 	zTempStr+1
.b4bc	69 00		adc #$00			adc 	#0
.b4be	85 1f		sta $1f				sta 	zGenPtr+1
.b4c0	18		clc				clc
.b4c1	20 1c bb	jsr $bb1c			jsr 	IntFromString 				; first bit.
.b4c4	b0 21		bcs $b4e7			bcs 	_UVBadNumber
.b4c6	20 40 c1	jsr $c140			jsr 	FPFromString				; try for a float part.
.b4c9	ad 90 04	lda $0490			lda 	ValSign 					; was it negative
.b4cc	d0 13		bne $b4e1			bne 	_UVNotNegative
.b4ce	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; check if integer
.b4d1	4a		lsr a				lsr 	a
.b4d2	b0 0a		bcs $b4de			bcs 	_UVInteger
.b4d4	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; set sign bit
.b4d7	09 80		ora #$80			ora 	#$80
.b4d9	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.b4dc	80 03		bra $b4e1			bra 	_UVNotNegative
.b4de					_UVInteger:
.b4de	20 44 ba	jsr $ba44			jsr 	IntegerNegateAlways 		; sign it.
.b4e1					_UVNotNegative:
.b4e1	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; used everything
.b4e3	d0 02		bne $b4e7			bne 	_UVBadNumber
.b4e5	7a		ply				ply
.b4e6	60		rts				rts
.b4e7					_UVBadNumber:
.b4e7	4c 33 ab	jmp $ab33			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.b4ea					Unary_Str:
.b4ea	20 b1 b0	jsr $b0b1			jsr 	EvaluateNumberX 			; numeric parameter
.b4ed	20 43 b7	jsr $b743			jsr 	CheckNextRParen 			; right bracket.
.b4f0	a9 00		lda #$00			lda 	#0 							; reset buffer index
.b4f2	8d 04 04	sta $0404			sta 	NumBufX
.b4f5	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.b4f8	4a		lsr a				lsr 	a
.b4f9	b0 05		bcs $b500			bcs 	_USInt 						; if msb set do as integer
.b4fb	20 79 c0	jsr $c079			jsr 	FPToString 					; call fp to str otherwise
.b4fe	80 03		bra $b503			bra 	_USDuplicate
.b500	20 69 ba	jsr $ba69	_USInt:	jsr 	IntToString
.b503					_USDuplicate:
.b503	ad 04 04	lda $0404			lda 	NumBufX 					; chars in buffer
.b506	1a		inc a				inc 	a 							; one more for length
.b507	20 55 b7	jsr $b755			jsr 	AllocateTempString 			; allocate space for it.
.b50a	5a		phy				phy 								; save Y
.b50b	a0 00		ldy #$00			ldy 	#0 							; start copying
.b50d	b9 05 04	lda $0405,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.b510	20 80 b7	jsr $b780			jsr 	WriteTempString
.b513	c8		iny				iny
.b514	cc 04 04	cpy $0404			cpy 	NumBufX 					; done the lot
.b517	d0 f4		bne $b50d			bne 	_USCopy
.b519	7a		ply				ply 								; restore Y
.b51a	4c 06 b7	jmp $b706			jmp 	UnaryReturnTempStr 			; return new temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.b51d					Unary_Asc:
.b51d	20 c9 b0	jsr $b0c9			jsr 	EvaluateStringX 			; string parameter
.b520	20 43 b7	jsr $b743			jsr 	CheckNextRParen 			; right bracket.
.b523	5a		phy				phy 								; get the string length
.b524	a0 00		ldy #$00			ldy 	#0
.b526	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b528	f0 07		beq $b531			beq 	_UAIllegal 					; must be at least one character
.b52a	c8		iny				iny
.b52b	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; read it.
.b52d	7a		ply				ply
.b52e	4c 8a b3	jmp $b38a			jmp 	UnarySetAInteger
.b531					_UAIllegal:
.b531	4c 33 ab	jmp $ab33			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.b534					Unary_Len:
.b534	20 c9 b0	jsr $b0c9			jsr 	EvaluateStringX 			; string parameter
.b537	20 43 b7	jsr $b743			jsr 	CheckNextRParen 			; right bracket.
.b53a	5a		phy				phy 								; get the string length
.b53b	a0 00		ldy #$00			ldy 	#0
.b53d	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b53f	7a		ply				ply
.b540	4c 8a b3	jmp $b38a			jmp 	UnarySetAInteger

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.b543					Unary_Mid:
.b543	20 c9 b0	jsr $b0c9			jsr 	EvaluateStringX 				; get string.
.b546	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.b549	48		pha				pha
.b54a	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b54d	48		pha				pha
.b54e	20 4c b7	jsr $b74c			jsr 	CheckNextComma 					; skip comma
.b551	20 de b5	jsr $b5de			jsr 	SLIByteParameter 				; get a byte parameter (start)
.b554	48		pha				pha 									; and push it.
.b555	20 4c b7	jsr $b74c			jsr 	CheckNextComma 					; skip comma
.b558	20 de b5	jsr $b5de			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.b55b	48		pha				pha 									; and push it.
.b55c	80 45		bra $b5a3			bra 	SLIProcess
.b55e					Unary_Left:
.b55e	20 c9 b0	jsr $b0c9			jsr 	EvaluateStringX 				; get string.
.b561	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.b564	48		pha				pha
.b565	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b568	48		pha				pha
.b569	a9 01		lda #$01			lda 	#1 								; push start position (1)
.b56b	48		pha				pha
.b56c	20 4c b7	jsr $b74c			jsr 	CheckNextComma 					; skip comma
.b56f	20 de b5	jsr $b5de			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.b572	48		pha				pha 									; and push it.
.b573	80 2e		bra $b5a3			bra 	SLIProcess
.b575					Unary_Right:
.b575	20 c9 b0	jsr $b0c9			jsr 	EvaluateStringX 				; get string.
.b578	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.b57b	48		pha				pha
.b57c	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b57f	48		pha				pha
.b580	da		phx				phx 									; get the string length and push on stack.
.b581	a2 00		ldx #$00			ldx 	#0
.b583	a1 1e		lda ($1e,x)			lda		(zGenPtr,x)
.b585	fa		plx				plx
.b586	48		pha				pha
.b587	20 4c b7	jsr $b74c			jsr 	CheckNextComma 					; skip comma
.b58a	20 de b5	jsr $b5de			jsr 	SLIByteParameter 				; get a byte parameter.
.b58d	8d 8e 04	sta $048e			sta 	SignCount 						; save in temporary.
.b590	68		pla				pla 									; restore string length.
.b591	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.b592	38		sec				sec
.b593	ed 8e 04	sbc $048e			sbc 	SignCount 						; subtract characters needed, gives start position.
.b596	f0 02		beq $b59a			beq 	_URStart 						; if <= 0 start from 1.
.b598	10 02		bpl $b59c			bpl 	_UROkay
.b59a					_URStart:
.b59a	a9 01		lda #$01			lda 	#1
.b59c					_UROkay:
.b59c	48		pha				pha 									; push start
.b59d	ad 8e 04	lda $048e			lda 	SignCount 						; push count of characters
.b5a0	48		pha				pha
.b5a1	80 00		bra $b5a3			bra 	SLIProcess
.b5a3					SLIProcess:
.b5a3	20 43 b7	jsr $b743			jsr 	CheckNextRParen 				; closing right bracket.
.b5a6	68		pla				pla
.b5a7	8d 92 04	sta $0492			sta 	SliceCount 						; count in signcount
.b5aa	1a		inc a				inc 	a 								; allocate +1 for it.
.b5ab	20 55 b7	jsr $b755			jsr 	AllocateTempString
.b5ae	68		pla				pla 									; pop start number off stack.
.b5af	f0 3f		beq $b5f0			beq 	SLIError 						; exit if start = 0
.b5b1	8d 91 04	sta $0491			sta 	SliceStart
.b5b4	68		pla				pla  									; pop string address.
.b5b5	85 1f		sta $1f				sta 	zGenPtr+1
.b5b7	68		pla				pla
.b5b8	85 1e		sta $1e				sta 	zGenPtr
.b5ba	da		phx				phx
.b5bb	5a		phy				phy
.b5bc	a2 00		ldx #$00			ldx 	#0 								; point to string length.
.b5be	ac 91 04	ldy $0491			ldy 	SliceStart 						; start of the string (+1 for count)
.b5c1					_SLICopy:
.b5c1	ad 92 04	lda $0492			lda 	SliceCount 						; done count characters
.b5c4	f0 12		beq $b5d8			beq 	_SLIExit
.b5c6	ce 92 04	dec $0492			dec 	SliceCount
.b5c9	98		tya				tya 									; index of character
.b5ca	c1 1e		cmp ($1e,x)			cmp 	(zGenPtr,x)						; compare against length
.b5cc	f0 02		beq $b5d0			beq 	_SLIOk 							; if equal, okay.
.b5ce	b0 08		bcs $b5d8			bcs 	_SLIExit 						; if past end, then exit.
.b5d0	b1 1e		lda ($1e),y	_SLIOk:	lda 	(zGenPtr),y 					; copy one character
.b5d2	c8		iny				iny
.b5d3	20 80 b7	jsr $b780			jsr 	WriteTempString
.b5d6	80 e9		bra $b5c1			bra 	_SLICopy 						; go round till copied characters
.b5d8					_SLIExit:
.b5d8	7a		ply				ply 									; restore YX
.b5d9	fa		plx				plx
.b5da	4c 06 b7	jmp $b706			jmp 	UnaryReturnTempStr 				; return new temporary string.
.b5dd	ea		nop				nop
.b5de					SLIByteParameter:
.b5de	20 c0 b0	jsr $b0c0			jsr 	EvaluateIntegerX 				; get integer
.b5e1	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.b5e4	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.b5e7	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.b5ea	d0 04		bne $b5f0			bne 	SLIError
.b5ec	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b5ef	60		rts				rts
.b5f0					SLIError:
.b5f0	4c 33 ab	jmp $ab33			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.b5f3					Unary_Hex:
.b5f3	20 c0 b0	jsr $b0c0			jsr 	EvaluateIntegerX 			; numeric parameter
.b5f6	20 43 b7	jsr $b743			jsr 	CheckNextRParen 			; right bracket.
.b5f9	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.b5fb	20 55 b7	jsr $b755			jsr 	AllocateTempString			; allocate string space
.b5fe	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.b601	20 28 b6	jsr $b628			jsr 	_UHConvert
.b604	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.b607	20 28 b6	jsr $b628			jsr 	_UHConvert
.b60a	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b60d	20 28 b6	jsr $b628			jsr 	_UHConvert
.b610	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b613	20 28 b6	jsr $b628			jsr 	_UHConvert
.b616	5a		phy				phy 								; get length of new string
.b617	a0 00		ldy #$00			ldy 	#0
.b619	b1 20		lda ($20),y			lda 	(zTempStr),y
.b61b	7a		ply				ply
.b61c	c9 00		cmp #$00			cmp 	#0
.b61e	d0 05		bne $b625			bne 	_UHExit 					; if it was non zero okay
.b620	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.b622	20 80 b7	jsr $b780			jsr 	WriteTempString
.b625					_UHExit:
.b625	4c 06 b7	jmp $b706			jmp 	UnaryReturnTempStr 			; return new temporary string.
.b628					_UHConvert:
.b628	48		pha				pha
.b629	4a		lsr a				lsr 	a 							; do MSB
.b62a	4a		lsr a				lsr 	a
.b62b	4a		lsr a				lsr 	a
.b62c	4a		lsr a				lsr 	a
.b62d	20 31 b6	jsr $b631			jsr 	_UHNibble
.b630	68		pla				pla 								; do LSB
.b631					_UHNibble:
.b631	29 0f		and #$0f			and 	#15 						; get nibble
.b633	d0 0c		bne $b641			bne 	_UHNonZero
.b635	5a		phy				phy									; get the length
.b636	a0 00		ldy #$00			ldy 	#0
.b638	b1 20		lda ($20),y			lda 	(zTempStr),y
.b63a	7a		ply				ply
.b63b	c9 00		cmp #$00			cmp 	#0 							; suppress leading zeros.
.b63d	f0 0d		beq $b64c			beq 	_UHExit2
.b63f	a9 00		lda #$00			lda 	#0
.b641					_UHNonZero:
.b641	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.b643	90 02		bcc $b647			bcc 	_UHDigit
.b645	69 06		adc #$06			adc 	#7-1
.b647					_UHDigit:
.b647	69 30		adc #$30			adc 	#48
.b649	20 80 b7	jsr $b780			jsr 	WriteTempString				; output.
.b64c					_UHExit2:
.b64c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.b64d					Unary_Dec:
.b64d	20 c9 b0	jsr $b0c9			jsr 	EvaluateStringX 			; string parameter
.b650	20 43 b7	jsr $b743			jsr 	CheckNextRParen 			; right bracket.
.b653	5a		phy				phy
.b654	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.b656	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b658	f0 4c		beq $b6a6			beq 	_UDFail 					; must fail if zero.
.b65a	8d 8e 04	sta $048e			sta 	SignCount 					; use SignCount as a counter
.b65d	a9 00		lda #$00			lda 	#0 							; set result to zero integer.
.b65f	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b662	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b665	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b668	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b66b	a9 01		lda #$01			lda 	#1
.b66d	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.b670					_UDConvertLoop:
.b670	5a		phy				phy 								; shift mantissa left 4
.b671	a0 04		ldy #$04			ldy 	#4
.b673					_UDShift:
.b673	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x
.b676	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.b679	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.b67c	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.b67f	88		dey				dey
.b680	d0 f1		bne $b673			bne 	_UDShift
.b682	7a		ply				ply
.b683	c8		iny				iny 								; next character
.b684	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; fetch it.
.b686	20 a9 b6	jsr $b6a9			jsr 	ConvertUpper 				; convert to U/C
.b689	c9 30		cmp #$30			cmp 	#"0"
.b68b	90 19		bcc $b6a6			bcc 	_UDFail
.b68d	c9 3a		cmp #$3a			cmp 	#"9"+1
.b68f	90 06		bcc $b697			bcc 	_UDOkay
.b691	e9 37		sbc #$37			sbc 	#7+"0" 						; alpha fudge
.b693	c9 10		cmp #$10			cmp 	#16
.b695	b0 0f		bcs $b6a6			bcs 	_UDFail
.b697					_UDOkay:
.b697	29 0f		and #$0f			and 	#15 						; nibble only
.b699	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x
.b69c	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b69f	ce 8e 04	dec $048e			dec 	SignCount 					; do it for each character
.b6a2	d0 cc		bne $b670			bne 	_UDConvertLoop
.b6a4	7a		ply				ply
.b6a5	60		rts				rts
.b6a6					_UDFail:
.b6a6	4c 33 ab	jmp $ab33			jmp 	BadParamError
.b6a9					ConvertUpper:
.b6a9	c9 61		cmp #$61			cmp 	#"a"
.b6ab	90 07		bcc $b6b4			bcc 	_CUExit
.b6ad	c9 7b		cmp #$7b			cmp 	#"z"+1
.b6af	b0 03		bcs $b6b4			bcs 	_CUExit
.b6b1	38		sec				sec
.b6b2	e9 20		sbc #$20			sbc 	#32
.b6b4	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.b6b5					Unary_Chr:
.b6b5	20 c0 b0	jsr $b0c0			jsr 	EvaluateIntegerX			; numeric parameter
.b6b8	20 43 b7	jsr $b743			jsr 	CheckNextRParen 			; right bracket.
.b6bb	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.b6be	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.b6c1	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.b6c4	d0 0e		bne $b6d4			bne 	_UCChar
.b6c6	a9 01		lda #$01			lda 	#1 							; one character string
.b6c8	20 55 b7	jsr $b755			jsr 	AllocateTempString
.b6cb	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.b6ce	20 80 b7	jsr $b780			jsr 	WriteTempString
.b6d1	4c 06 b7	jmp $b706			jmp 	UnaryReturnTempStr
.b6d4					_UCChar:
.b6d4	4c 33 ab	jmp $ab33			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.b6d7					Unary_Spc:
.b6d7	20 c0 b0	jsr $b0c0			jsr 	EvaluateIntegerX 			; numeric parameter
.b6da	20 43 b7	jsr $b743			jsr 	CheckNextRParen 			; right bracket.
.b6dd	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.b6e0	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.b6e3	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.b6e6	d0 1b		bne $b703			bne 	_USSize
.b6e8	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b6eb	c9 fe		cmp #$fe			cmp 	#maxString+1
.b6ed	b0 14		bcs $b703			bcs 	_USSize
.b6ef	48		pha				pha 								; save length
.b6f0	1a		inc a				inc 	a 							; allocate one more.
.b6f1	20 55 b7	jsr $b755			jsr 	AllocateTempString
.b6f4	68		pla				pla 								; get length
.b6f5	f0 0f		beq $b706			beq 	UnaryReturnTempStr 			; return the current temp string
.b6f7					_USLoop:
.b6f7	48		pha				pha
.b6f8	a9 20		lda #$20			lda 	#" "
.b6fa	20 80 b7	jsr $b780			jsr 	WriteTempString
.b6fd	68		pla				pla
.b6fe	3a		dec a				dec 	a
.b6ff	d0 f6		bne $b6f7			bne 	_USLoop
.b701	80 03		bra $b706			bra 	UnaryReturnTempStr
.b703					_USSize:
.b703	4c 33 ab	jmp $ab33			jmp 	BadParamError
.b706					UnaryReturnTempStr:
.b706	a5 20		lda $20				lda 	zTempStr 					; copy temp string addr -> mantissa
.b708	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b70b	a5 21		lda $21				lda 	zTempStr+1
.b70d	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b710	a9 02		lda #$02			lda 	#2 							; set type to string
.b712	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.b715	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/4510.asm

.b716	db		phz		MemRead:phz
.b717	8d 8e 04	sta $048e			sta 	SignCount 					; save count
.b71a	a3 00		ldz #$00			ldz 	#0 							; start from here
.b71c	ea		nop		_MLoop1:nop
.b71d	b2 1a		lda ($1a),z			lda 	(zlTemp1),z 				; read the long address
.b71f	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; copy into mantissa
.b722	1b		inz				inz 								; next to copy
.b723	e8		inx				inx
.b724	dc 8e 04	cpz $048e			cpz 	SignCount 					; do required # of bytes.
.b727	d0 f3		bne $b71c			bne 	_MLoop1
.b729	fb		plz				plz
.b72a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.b72b					CheckNextToken:
.b72b	ea		nop				nop
.b72c	d2 16		cmp ($16),z			cmp 	(zCodePtr),z
.b72e	d0 02		bne $b732			bne 	CTFail 						; no, then fail
.b730	1b		inz				inz
.b731	60		rts				rts
.b732					CTFail:
.b732	20 44 ab	jsr $ab44			jsr ERR_Handler
>b735	4d 69 73 73 69 6e 67 20			.text "Missing token",0
>b73d	74 6f 6b 65 6e 00
.b743					CheckNextRParen:
.b743	ea		nop				nop
.b744	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b746	c9 bc		cmp #$bc			cmp 	#token_rparen
.b748	d0 e8		bne $b732			bne 	CTFail
.b74a	1b		inz				inz
.b74b	60		rts				rts
.b74c					CheckNextComma:
.b74c	ea		nop				nop
.b74d	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b74f	c9 bd		cmp #$bd			cmp 	#token_comma
.b751	d0 df		bne $b732			bne 	CTFail
.b753	1b		inz				inz
.b754	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.b755					AllocateTempString:
.b755	48		pha				pha 								; save required count.
.b756	a5 21		lda $21				lda 	zTempStr+1 					; check if initialised yet ?
.b758	d0 0b		bne $b765			bne 	_ATSInitialised
.b75a	ad 00 04	lda $0400			lda 	StringPtr 					; set temporary string ptr 1 page below available
.b75d	85 20		sta $20				sta 	zTempStr					; space, this is for strings to be concreted.
.b75f	ad 01 04	lda $0401			lda 	StringPtr+1
.b762	3a		dec a				dec 	a
.b763	85 21		sta $21				sta 	zTempStr+1
.b765					_ATSInitialised:
.b765	68		pla				pla 								; get required count back.
.b766	49 ff		eor #$ff			eor 	#$FF 						; negate 2's complement.
.b768	1a		inc a				inc 	a
.b769	18		clc				clc
.b76a	65 20		adc $20				adc 	zTempStr 					; "add" to the temp string pointer
.b76c	85 20		sta $20				sta 	zTempStr
.b76e	a9 ff		lda #$ff			lda 	#$FF
.b770	65 21		adc $21				adc 	zTempStr+1
.b772	85 21		sta $21				sta 	zTempStr+1
.b774	a9 00		lda #$00			lda 	#0 							; clear temp string.
.b776	5a		phy				phy
.b777	a8		tay				tay
.b778	91 20		sta ($20),y			sta 	(zTempStr),y
.b77a	7a		ply				ply
.b77b	1a		inc a				inc 	a 							; reset the write index.
.b77c	8d 8f 04	sta $048f			sta 	TempStringWriteIndex
.b77f	60		rts				rts
.b780					WriteTempString:
.b780	5a		phy				phy 								; save Y
.b781	ac 8f 04	ldy $048f			ldy 	TempStringWriteIndex	 	; write position.
.b784	91 20		sta ($20),y			sta 	(zTempStr),y 				; write character out.
.b786	ee 8f 04	inc $048f			inc 	TempStringWriteIndex 		; increment the write position.
.b789	98		tya				tya 								; unchanged Y is now length
.b78a	a0 00		ldy #$00			ldy 	#0
.b78c	91 20		sta ($20),y			sta 	(zTempStr),y
.b78e	7a		ply				ply 								; restore Y and exit
.b78f	60		rts				rts
.b790					CreateTempStringCopy:
.b790	da		phx				phx 								; save X
.b791	ea		nop				nop
.b792	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b794	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.b795	20 55 b7	jsr $b755			jsr 	AllocateTempString 			; allocate memory for temporary string.
.b798	ea		nop				nop
.b799	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b79b	1b		inz				inz
.b79c	3a		dec a				dec 	a 							; make the actual length in charactes
.b79d	3a		dec a				dec 	a
.b79e	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.b7a0	81 20		sta ($20,x)			sta 	(zTempStr,x)
.b7a2	85 1a		sta $1a				sta 	zLTemp1 					; that's used as a count.
.b7a4	09 00		ora #$00			ora 	#0 							; if zero already, exit
.b7a6	f0 0f		beq $b7b7			beq 	_CTSCExit
.b7a8					_CTSCLoop:
.b7a8	ea		nop				nop
.b7a9	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b7ab	1b		inz				inz
.b7ac	5a		phy				phy 								; save in Y
.b7ad	e8		inx				inx 								; bump index
.b7ae	da		phx				phx 								; index into Y
.b7af	7a		ply				ply
.b7b0	91 20		sta ($20),y			sta 	(zTempStr),y 				; save at index
.b7b2	7a		ply				ply 								; restore Y
.b7b3	c6 1a		dec $1a				dec 	zLTemp1 					; do for each character
.b7b5	d0 f1		bne $b7a8			bne 	_CTSCLoop
.b7b7					_CTSCExit:
.b7b7	fa		plx				plx 								; restore X
.b7b8	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/variables.asm

.b7b9					VariableFind:
.b7b9	20 f4 b7	jsr $b7f4			jsr 	VariableExtract 		; find out all about it ....
.b7bc	20 f6 b8	jsr $b8f6			jsr 	VariableLocate 			; does it already exist ?
.b7bf	b0 03		bcs $b7c4			bcs 	_VFExists 				; if so, use that.
.b7c1	20 82 b8	jsr $b882			jsr 	VariableCreate 			; otherwise create it.
.b7c4					_VFExists:
.b7c4	60		rts				rts
.b7c5					VariableClear:
.b7c5	48		pha				pha 							; save registers
.b7c6	da		phx				phx
.b7c7	a2 00		ldx #$00			ldx 	#0 						; clear out the hash table.
.b7c9	8a		txa				txa
.b7ca	9d 25 04	sta $0425,x	_VCLoop:sta 	HashTableBase,x
.b7cd	e8		inx				inx
.b7ce	e0 60		cpx #$60			cpx 	#HashTableEnd-HashTableBase
.b7d0	d0 f8		bne $b7ca			bne 	_VCLoop
.b7d2	a9 00		lda #$00			lda 	#VariableMemory & $FF	; reset the free variable memory pointer
.b7d4	8d 02 04	sta $0402			sta 	VarMemPtr
.b7d7	a9 40		lda #$40			lda 	#VariableMemory >> 8
.b7d9	8d 03 04	sta $0403			sta 	VarMemPtr+1
.b7dc	fa		plx				plx 							; restore registers
.b7dd	68		pla				pla
.b7de	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/extract.asm

.b7df					VariableNameError:
.b7df	20 44 ab	jsr $ab44			jsr ERR_Handler
>b7e2	42 61 64 20 56 61 72 69			.text "Bad Variable Name",0
>b7ea	61 62 6c 65 20 4e 61 6d 65 00
.b7f4					VariableExtract:
.b7f4	da		phx				phx 							; save X.
.b7f5	a9 b8		lda #$b8			lda 	#token_hashlParen  		; set the type to #( e.g. real array.
.b7f7	8d 85 04	sta $0485			sta 	Var_Type
.b7fa	8d 86 04	sta $0486			sta 	Var_Hash 				; we initialise the hash with this. It doesn't matter
.b7fd	ea		nop				nop
.b7fe	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b800	c9 00		cmp #$00			cmp 	#0 						; first one must be A-Z
.b802	f0 db		beq $b7df			beq 	VariableNameError
.b804	c9 1b		cmp #$1b			cmp 	#26+1
.b806	b0 d7		bcs $b7df			bcs 	VariableNameError
.b808	a2 ff		ldx #$ff			ldx 	#255 					; now copy it into the variable buffer.
.b80a					_VECopyBuffer:
.b80a	e8		inx				inx
.b80b	e0 1f		cpx #$1f			cpx 	#31 					; too long
.b80d	f0 d0		beq $b7df			beq 	VariableNameError
.b80f	9d 05 04	sta $0405,x			sta 	Var_Buffer,x 			; save character
.b812	18		clc				clc  							; update the hash value for it.
.b813	6d 86 04	adc $0486			adc 	Var_Hash
.b816	8d 86 04	sta $0486			sta 	Var_Hash
.b819	1b		inz				inz
.b81a	ea		nop				nop
.b81b	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b81d	c9 00		cmp #$00			cmp 	#0 						; zero or token, end of variable
.b81f	f0 0e		beq $b82f			beq 	_VECopyEnd
.b821	30 0c		bmi $b82f			bmi 	_VECopyEnd
.b823	c9 1b		cmp #$1b			cmp 	#26+1 					; A-Z continue copying
.b825	90 e3		bcc $b80a			bcc 	_VECopyBuffer
.b827	c9 30		cmp #$30			cmp 	#"0" 					; 0-9 copy as well.
.b829	90 04		bcc $b82f			bcc 	_VECopyEnd
.b82b	c9 3a		cmp #$3a			cmp 	#"9"+1
.b82d	90 db		bcc $b80a			bcc 	_VECopyBuffer
.b82f					_VECopyEnd:
.b82f	1b		inz				inz
.b830	c9 b5		cmp #$b5			cmp 	#token_Dollar 			; first type token.
.b832	90 04		bcc $b838			bcc 	_VEDefaultRequired
.b834	c9 bb		cmp #$bb			cmp 	#token_PercentLParen+1	; last type token.
.b836	90 0b		bcc $b843			bcc 	_VEHaveType
.b838					_VEDefaultRequired:
.b838	c9 bb		cmp #$bb			cmp 	#token_LParen 			; if it ends in ( then use the real array
.b83a	f0 04		beq $b840			beq 	_VESetType 				; default set above.
.b83c	ce 85 04	dec $0485			dec 	Var_Type 				; this changes that default to the variable default
.b83f	3b		dez				dez
.b840					_VESetType:
.b840	ad 85 04	lda $0485			lda 	Var_Type 				; get type ....
.b843					_VEHaveType:
.b843	8d 85 04	sta $0485			sta 	Var_Type 				; save as type.
.b846	bd 05 04	lda $0405,x			lda 	Var_Buffer,x 			; set bit 7 of name, marks the end.
.b849	09 80		ora #$80			ora 	#$80
.b84b	9d 05 04	sta $0405,x			sta 	Var_Buffer,x
.b84e	e8		inx				inx 							; offset 3 => length 4.
.b84f	8e 87 04	stx $0487			stx 	Var_Length 				; save length of variable name.
.b852	ad 85 04	lda $0485			lda 	Var_Type 				; get offset of var type from first type token
.b855	38		sec				sec
.b856	e9 b5		sbc #$b5			sbc 	#token_Dollar
.b858	0a		asl a				asl 	a 						; multiply by 16. This requires HashTableSize
.b859	0a		asl a				asl 	a 						; in data.asm to be 8 (8 sets of links,2 bytes each)
.b85a	0a		asl a				asl 	a
.b85b	0a		asl a				asl 	a
.b85c	8d 88 04	sta $0488			sta 	Var_HashAddress
.b85f	ad 86 04	lda $0486			lda 	Var_Hash 				; get the hash
.b862	29 07		and #$07			and 	#(HashTableSize-1) 		; force into range 0-tableSize-1
.b864	0a		asl a				asl 	a 						; double it (2 bytes per entry) & clears carry
.b865	6d 88 04	adc $0488			adc 	Var_HashAddress 		; add table offset.
.b868	69 25		adc #$25			adc 	#HashTableBase & $FF 	; now the low byte of the actual table address
.b86a	8d 88 04	sta $0488			sta 	Var_HashAddress
.b86d	a2 05		ldx #$05			ldx 	#5 						; hash is 5 bytes (real)
.b86f	ad 85 04	lda $0485			lda 	Var_Type
.b872	c9 b7		cmp #$b7			cmp 	#token_Hash
.b874	f0 07		beq $b87d			beq 	_VEHaveSize
.b876	ca		dex				dex
.b877	c9 b9		cmp #$b9			cmp 	#token_Percent 			; percent is 4 bytes (integer)
.b879	f0 02		beq $b87d			beq 	_VEHaveSize
.b87b	a2 02		ldx #$02			ldx 	#2 						; everything else is two.
.b87d					_VEHaveSize:
.b87d	8e 89 04	stx $0489			stx 	Var_DataSize
.b880	fa		plx				plx
.b881	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varcreate.asm

.b882					VariableCreate:
.b882	da		phx				phx
.b883	5a		phy				phy
.b884	ad 02 04	lda $0402			lda 	VarMemPtr 					; get address of next free into zTemp1
.b887	85 10		sta $10				sta 	zTemp1
.b889	ad 03 04	lda $0403			lda 	VarMemPtr+1
.b88c	85 11		sta $11				sta 	zTemp1+1
.b88e	ad 89 04	lda $0489			lda 	Var_DataSize 				; bytes for the data bit
.b891	18		clc				clc
.b892	6d 87 04	adc $0487			adc 	Var_Length 					; add the length of the name
.b895	69 03		adc #$03			adc 	#3 							; 3 for the link and the hash.
.b897	6d 02 04	adc $0402			adc 	VarMemPtr 					; add to variable memory pointer
.b89a	8d 02 04	sta $0402			sta 	VarMemPtr
.b89d	90 03		bcc $b8a2			bcc 	_VCNoCarry
.b89f	ee 03 04	inc $0403			inc 	VarMemPtr+1
.b8a2					_VCNoCarry:
.b8a2	ad 88 04	lda $0488			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.b8a5	85 12		sta $12				sta 	zTemp2
.b8a7	a9 04		lda #$04			lda 	#HashTableBase >> 8
.b8a9	85 13		sta $13				sta 	zTemp2+1
.b8ab	a0 00		ldy #$00			ldy 	#0 							; put current hash link in position.
.b8ad	b1 12		lda ($12),y			lda 	(zTemp2),y
.b8af	91 10		sta ($10),y			sta 	(zTemp1),y
.b8b1	c8		iny				iny
.b8b2	b1 12		lda ($12),y			lda 	(zTemp2),y
.b8b4	91 10		sta ($10),y			sta 	(zTemp1),y
.b8b6	c8		iny				iny
.b8b7	ad 86 04	lda $0486			lda 	Var_Hash 					; write the hash out.
.b8ba	91 10		sta ($10),y			sta 	(zTemp1),y
.b8bc	c8		iny				iny
.b8bd	a2 00		ldx #$00			ldx 	#0 							; copy the name out.
.b8bf					_VCCopyName:
.b8bf	bd 05 04	lda $0405,x			lda 	Var_Buffer,x
.b8c2	91 10		sta ($10),y			sta 	(zTemp1),y
.b8c4	e8		inx				inx
.b8c5	c8		iny				iny
.b8c6	ec 87 04	cpx $0487			cpx 	Var_Length
.b8c9	d0 f4		bne $b8bf			bne 	_VCCopyName
.b8cb	5a		phy				phy 								; save the data offset.
.b8cc	ae 89 04	ldx $0489			ldx 	Var_DataSize 				; and write the data out.
.b8cf	a9 00		lda #$00			lda 	#0 							; which is all zeroes.
.b8d1					_VCClearData:
.b8d1	91 10		sta ($10),y			sta 	(zTemp1),y
.b8d3	c8		iny				iny
.b8d4	ca		dex				dex
.b8d5	d0 fa		bne $b8d1			bne 	_VCClearData
.b8d7	68		pla				pla 								; offset to the data
.b8d8	18		clc				clc
.b8d9	65 10		adc $10				adc 	zTemp1 						; add to start and save as data pointer.
.b8db	85 22		sta $22				sta 	zVarDataPtr
.b8dd	a5 11		lda $11				lda 	zTemp1+1
.b8df	69 00		adc #$00			adc 	#0
.b8e1	85 23		sta $23				sta 	zVarDataPtr+1
.b8e3	ad 85 04	lda $0485			lda 	Var_Type 					; and set the type.
.b8e6	85 24		sta $24				sta 	zVarType
.b8e8	a5 10		lda $10				lda 	zTemp1 						; fix hash link to point to new record
.b8ea	a0 00		ldy #$00			ldy 	#0
.b8ec	91 12		sta ($12),y			sta 	(zTemp2),y
.b8ee	c8		iny				iny
.b8ef	a5 11		lda $11				lda 	zTemp1+1
.b8f1	91 12		sta ($12),y			sta 	(zTemp2),y
.b8f3	7a		ply				ply
.b8f4	fa		plx				plx
.b8f5	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varfind.asm

.b8f6					VariableLocate:
.b8f6	18		clc				clc
.b8f7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/vargetset.asm

.b8f8					VariableGet:
.b8f8	5a		phy				phy
.b8f9	a0 00		ldy #$00			ldy 	#0 							; copy first two bytes
.b8fb	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.b8fd	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.b900	c8		iny				iny
.b901	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.b903	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b906	c8		iny				iny
.b907	ad 85 04	lda $0485			lda 	Var_Type 					; if it is a string, set up for that.
.b90a	c9 b5		cmp #$b5			cmp 	#token_Dollar
.b90c	f0 33		beq $b941			beq 	_VGString
.b90e	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; copy the next two bytes.
.b910	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b913	c8		iny				iny
.b914	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.b916	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b919	c8		iny				iny
.b91a	a9 01		lda #$01			lda 	#1 							; set type to 1.
.b91c	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.b91f	ad 85 04	lda $0485			lda 	Var_Type
.b922	c9 b9		cmp #$b9			cmp 	#token_Percent 				; if it is a %, then exit with default integer.
.b924	f0 2f		beq $b955			beq 	_VGExit
.b926	a9 40		lda #$40			lda 	#$40 						; set type byte to zero
.b928	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; which is the code for zero/float.
.b92b	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; the last value to copy is the exponent.
.b92d	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.b930	f0 23		beq $b955			beq 	_VGExit 					; if exponent is zero ... it's zero.
.b932	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; the sign bit is the top mantissa bit.
.b935	48		pha				pha
.b936	29 80		and #$80			and 	#$80
.b938	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; this is the type byte.
.b93b	68		pla				pla
.b93c	09 80		ora #$80			ora 	#$80 						; set the MSB as you would expect.
.b93e	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x 			; so it's a normalised float.
.b941					_VGString:
.b941	a9 02		lda #$02			lda 	#2 							; set type to 2, a string
.b943	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.b946	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; is the value there $0000
.b949	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.b94c	d0 07		bne $b955			bne 	_VGExit 					; if not, exit.
.b94e	85 25		sta $25				sta 	zNullString 				; make zNullString a 00 string.
.b950	a9 25		lda #$25			lda 	#zNullString
.b952	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; make it point to it.
.b955					_VGExit:
.b955	7a		ply				ply
.b956	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.b957					MulInteger32:
.b957	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.b95a	9d 14 03	sta $0314,x			sta 	XS3_Mantissa,x
.b95d	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b960	9d 15 03	sta $0315,x			sta 	XS3_Mantissa+1,x
.b963	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.b966	9d 16 03	sta $0316,x			sta 	XS3_Mantissa+2,x
.b969	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.b96c	9d 17 03	sta $0317,x			sta 	XS3_Mantissa+3,x
.b96f	a9 00		lda #$00			lda 	#0
.b971	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x 				; zero +0
.b974	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b977	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b97a	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b97d					_BFMMultiply:
.b97d	bd 14 03	lda $0314,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.b980	29 01		and #$01			and 	#1
.b982	f0 03		beq $b987			beq 	_BFMNoAdd
.b984	20 a5 b2	jsr $b2a5			jsr 	AddInteger32
.b987					_BFMNoAdd:
.b987	1e 0e 03	asl $030e,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.b98a	3e 0f 03	rol $030f,x			rol 	XS2_Mantissa+1,x
.b98d	3e 10 03	rol $0310,x			rol 	XS2_Mantissa+2,x
.b990	3e 11 03	rol $0311,x			rol 	XS2_Mantissa+3,x
.b993	5e 17 03	lsr $0317,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.b996	7e 16 03	ror $0316,x			ror 	XS3_Mantissa+2,x
.b999	7e 15 03	ror $0315,x			ror 	XS3_Mantissa+1,x
.b99c	7e 14 03	ror $0314,x			ror 	XS3_Mantissa,x
.b99f	bd 14 03	lda $0314,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.b9a2	1d 15 03	ora $0315,x			ora 	XS3_Mantissa+1,x
.b9a5	1d 16 03	ora $0316,x			ora 	XS3_Mantissa+2,x
.b9a8	1d 17 03	ora $0317,x			ora 	XS3_Mantissa+3,x
.b9ab	d0 d0		bne $b97d			bne 	_BFMMultiply
.b9ad	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.b9ae					DivInteger32:
.b9ae	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; check for /0
.b9b1	1d 0f 03	ora $030f,x			ora 	XS2_Mantissa+1,x
.b9b4	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.b9b7	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.b9ba	d0 14		bne $b9d0			bne 	_BFDOkay
.b9bc	20 44 ab	jsr $ab44			jsr ERR_Handler
>b9bf	44 69 76 69 73 69 6f 6e			.text "Division by Zero",0
>b9c7	20 62 79 20 5a 65 72 6f 00
.b9d0					_BFDOkay:
.b9d0	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.b9d2	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.b9d4	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.b9d6	85 1c		sta $1c				sta 	zLTemp1+2
.b9d8	85 1d		sta $1d				sta 	zLTemp1+3
.b9da	8d 8e 04	sta $048e			sta 	SignCount 					; Count of signs.
.b9dd	20 3e ba	jsr $ba3e			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.b9e0	da		phx				phx
.b9e1	e8		inx				inx
.b9e2	e8		inx				inx
.b9e3	e8		inx				inx
.b9e4	e8		inx				inx
.b9e5	e8		inx				inx
.b9e6	e8		inx				inx
.b9e7	20 3e ba	jsr $ba3e			jsr 	CheckIntegerNegate
.b9ea	fa		plx				plx
.b9eb	5a		phy				phy 								; Y is the counter
.b9ec	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.b9ee					_BFDLoop:
.b9ee	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.b9f1	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.b9f4	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.b9f7	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.b9fa	26 1a		rol $1a				rol 	zLTemp1
.b9fc	26 1b		rol $1b				rol 	zLTemp1+1
.b9fe	26 1c		rol $1c				rol 	zLTemp1+2
.ba00	26 1d		rol $1d				rol 	zLTemp1+3
.ba02	38		sec				sec
.ba03	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.ba05	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.ba08	48		pha				pha
.ba09	a5 1b		lda $1b				lda 	zLTemp1+1
.ba0b	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.ba0e	48		pha				pha
.ba0f	a5 1c		lda $1c				lda 	zLTemp1+2
.ba11	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.ba14	48		pha				pha
.ba15	a5 1d		lda $1d				lda 	zLTemp1+3
.ba17	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.ba1a	90 15		bcc $ba31			bcc 	_BFDNoAdd
.ba1c	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.ba1e	68		pla				pla
.ba1f	85 1c		sta $1c				sta 	zLTemp1+2
.ba21	68		pla				pla
.ba22	85 1b		sta $1b				sta 	zLTemp1+1
.ba24	68		pla				pla
.ba25	85 1a		sta $1a				sta 	zLTemp1+0
.ba27	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.ba2a	09 01		ora #$01			ora 	#1
.ba2c	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.ba2f	80 03		bra $ba34			bra 	_BFDNext
.ba31					_BFDNoAdd:
.ba31	68		pla				pla 								; Throw away the intermediate calculations
.ba32	68		pla				pla
.ba33	68		pla				pla
.ba34					_BFDNext:
.ba34	88		dey				dey
.ba35	d0 b7		bne $b9ee			bne 	_BFDLoop
.ba37	7a		ply				ply 								; restore Y and exit
.ba38	4e 8e 04	lsr $048e			lsr 	SignCount 					; if sign count odd,
.ba3b	b0 07		bcs $ba44			bcs		IntegerNegateAlways 			; negate the result
.ba3d	60		rts				rts
.ba3e					CheckIntegerNegate:
.ba3e	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.ba41	30 01		bmi $ba44			bmi 	IntegerNegateAlways
.ba43	60		rts				rts
.ba44					IntegerNegateAlways:
.ba44	ee 8e 04	inc $048e			inc 	SignCount
.ba47	38		sec				sec
.ba48	a9 00		lda #$00			lda 	#0
.ba4a	fd 08 03	sbc $0308,x			sbc 	XS_Mantissa+0,x
.ba4d	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.ba50	a9 00		lda #$00			lda 	#0
.ba52	fd 09 03	sbc $0309,x			sbc 	XS_Mantissa+1,x
.ba55	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.ba58	a9 00		lda #$00			lda 	#0
.ba5a	fd 0a 03	sbc $030a,x			sbc 	XS_Mantissa+2,x
.ba5d	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.ba60	a9 00		lda #$00			lda 	#0
.ba62	fd 0b 03	sbc $030b,x			sbc 	XS_Mantissa+3,x
.ba65	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.ba68	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.ba69					INTToString:
.ba69	48		pha				pha
.ba6a	5a		phy				phy
.ba6b	bd 0b 03	lda $030b,x			lda 		XS_Mantissa+3,x 		; check -ve
.ba6e	10 08		bpl $ba78			bpl 		_ITSNotMinus
.ba70	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.ba72	20 09 bb	jsr $bb09			jsr 		ITSOutputCharacter
.ba75	20 44 ba	jsr $ba44			jsr 		IntegerNegateAlways 	; negate the number.
.ba78					_ITSNotMinus:
.ba78	a9 00		lda #$00			lda 		#0
.ba7a	8d 8a 04	sta $048a			sta 		NumSuppress 			; clear the suppression flag.
.ba7d	8a		txa				txa 								; use Y for the mantissa index.
.ba7e	a8		tay				tay
.ba7f	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.ba81					_ITSNextSubtractor:
.ba81	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.ba83	8d 8b 04	sta $048b			sta 		NumConvCount
.ba86					_ITSSubtract:
.ba86	38		sec				sec
.ba87	b9 08 03	lda $0308,y			lda 		XS_Mantissa,y 			; subtract number and push on stack
.ba8a	fd e5 ba	sbc $bae5,x			sbc 		_ITSSubtractors+0,x
.ba8d	48		pha				pha
.ba8e	b9 09 03	lda $0309,y			lda 		XS_Mantissa+1,y
.ba91	fd e6 ba	sbc $bae6,x			sbc 		_ITSSubtractors+1,x
.ba94	48		pha				pha
.ba95	b9 0a 03	lda $030a,y			lda 		XS_Mantissa+2,y
.ba98	fd e7 ba	sbc $bae7,x			sbc 		_ITSSubtractors+2,x
.ba9b	48		pha				pha
.ba9c	b9 0b 03	lda $030b,y			lda 		XS_Mantissa+3,y
.ba9f	fd e8 ba	sbc $bae8,x			sbc 		_ITSSubtractors+3,x
.baa2	90 14		bcc $bab8			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.baa4	99 0b 03	sta $030b,y			sta 		XS_Mantissa+3,y 		; save subtract off stack
.baa7	68		pla				pla
.baa8	99 0a 03	sta $030a,y			sta 		XS_Mantissa+2,y
.baab	68		pla				pla
.baac	99 09 03	sta $0309,y			sta 		XS_Mantissa+1,y
.baaf	68		pla				pla
.bab0	99 08 03	sta $0308,y			sta 		XS_Mantissa+0,y
.bab3	ee 8b 04	inc $048b			inc 		NumConvCount 			; bump count.
.bab6	80 ce		bra $ba86			bra 		_ITSSubtract 			; go round again.
.bab8					_ITSCantSubtract:
.bab8	68		pla				pla 								; throw away interim answers
.bab9	68		pla				pla
.baba	68		pla				pla
.babb	ad 8b 04	lda $048b			lda 		NumConvCount 			; if not zero then no suppression check
.babe	c9 30		cmp #$30			cmp 		#"0"
.bac0	d0 05		bne $bac7			bne 		_ITSOutputDigit
.bac2	ad 8a 04	lda $048a			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.bac5	10 09		bpl $bad0			bpl	 		_ITSGoNextSubtractor
.bac7					_ITSOutputDigit:
.bac7	ce 8a 04	dec $048a			dec 		NumSuppress 			; suppression check will be non-zero.
.baca	ad 8b 04	lda $048b			lda 		NumConvCount 			; count of subtractions
.bacd	20 09 bb	jsr $bb09			jsr 		ITSOutputCharacter 		; output it.
.bad0					_ITSGoNextSubtractor:
.bad0	e8		inx				inx 								; next dword
.bad1	e8		inx				inx
.bad2	e8		inx				inx
.bad3	e8		inx				inx
.bad4	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.bad6	d0 a9		bne $ba81			bne 		_ITSNextSubtractor 		; do all the subtractors.
.bad8	98		tya				tya 								; X is back as the mantissa index
.bad9	aa		tax				tax
.bada	bd 08 03	lda $0308,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.badd	09 30		ora #$30			ora 		#"0"
.badf	20 09 bb	jsr $bb09			jsr 		ITSOutputCharacter
.bae2	7a		ply				ply 								; and exit
.bae3	68		pla				pla
.bae4	60		rts				rts
.bae5					_ITSSubtractors:
>bae5	00 ca 9a 3b					.dword 		1000000000
>bae9	00 e1 f5 05					.dword 		100000000
>baed	80 96 98 00					.dword 		10000000
>baf1	40 42 0f 00					.dword 		1000000
>baf5	a0 86 01 00					.dword 		100000
>baf9	10 27 00 00					.dword 		10000
>bafd	e8 03 00 00					.dword 		1000
>bb01	64 00 00 00					.dword 		100
>bb05	0a 00 00 00					.dword 		10
.bb09					_ITSSubtractorsEnd:
.bb09					ITSOutputCharacter:
.bb09	48		pha				pha
.bb0a	da		phx				phx
.bb0b	ae 04 04	ldx $0404			ldx 	NumBufX 					; save digit
.bb0e	9d 05 04	sta $0405,x			sta 	Num_Buffer,x
.bb11	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.bb13	9d 06 04	sta $0406,x			sta 	Num_Buffer+1,x
.bb16	ee 04 04	inc $0404			inc 	NumBufX						; bump pointer.
.bb19	fa		plx				plx
.bb1a	68		pla				pla
.bb1b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.bb1c					IntFromString:
.bb1c	a0 00		ldy #$00			ldy 	#0
.bb1e	8c 8c 04	sty $048c			sty 	ExpTemp 					; this is the converted digit count.
.bb21					IntFromStringY:
.bb21	48		pha				pha
.bb22	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.bb24	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.bb27	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.bb2a	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.bb2d	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.bb30	a9 01		lda #$01			lda 	#1
.bb32	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bb35					_IFSLoop:
.bb35	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.bb37	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.bb39	90 60		bcc $bb9b			bcc 	_IFSExit
.bb3b	c9 3a		cmp #$3a			cmp 	#"9"+1
.bb3d	b0 5c		bcs $bb9b			bcs 	_IFSExit
.bb3f	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.bb42	c9 0c		cmp #$0c			cmp 	#12
.bb44	b0 5f		bcs $bba5			bcs 	_IFSOverflow
.bb46	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.bb49	48		pha				pha
.bb4a	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.bb4d	48		pha				pha
.bb4e	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.bb51	48		pha				pha
.bb52	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.bb55	48		pha				pha
.bb56	20 ba bb	jsr $bbba			jsr 	IFSX1ShiftLeft 				; double
.bb59	20 ba bb	jsr $bbba			jsr 	IFSX1ShiftLeft 				; x 4
.bb5c	18		clc				clc 								; add saved value x 5
.bb5d	68		pla				pla
.bb5e	7d 08 03	adc $0308,x			adc 	XS_Mantissa+0,x
.bb61	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.bb64	68		pla				pla
.bb65	7d 09 03	adc $0309,x			adc 	XS_Mantissa+1,x
.bb68	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.bb6b	68		pla				pla
.bb6c	7d 0a 03	adc $030a,x			adc 	XS_Mantissa+2,x
.bb6f	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.bb72	68		pla				pla
.bb73	7d 0b 03	adc $030b,x			adc 	XS_Mantissa+3,x
.bb76	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.bb79	20 ba bb	jsr $bbba			jsr 	IFSX1ShiftLeft 				; x 10
.bb7c	ee 8c 04	inc $048c			inc 	ExpTemp 					; bump count of digits processed.
.bb7f	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.bb81	29 0f		and #$0f			and 	#15
.bb83	c8		iny				iny
.bb84	7d 08 03	adc $0308,x			adc 	XS_Mantissa+0,x
.bb87	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.bb8a	90 a9		bcc $bb35			bcc 	_IFSLoop
.bb8c	fe 09 03	inc $0309,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.bb8f	d0 a4		bne $bb35			bne 	_IFSLoop
.bb91	fe 0a 03	inc $030a,x			inc 	XS_Mantissa+2,x
.bb94	d0 9f		bne $bb35			bne 	_IFSLoop
.bb96	fe 0b 03	inc $030b,x			inc 	XS_Mantissa+3,x
.bb99	80 9a		bra $bb35			bra 	_IFSLoop
.bb9b					_IFSExit:
.bb9b	98		tya				tya 								; get offset
.bb9c					_IFSOkay:
.bb9c	38		sec				sec
.bb9d	ad 8c 04	lda $048c			lda 	ExpTemp
.bba0	f0 01		beq $bba3			beq 	_IFSSkipFail
.bba2	18		clc				clc
.bba3					_IFSSkipFail:
.bba3	68		pla				pla 								; and exit.
.bba4	60		rts				rts
.bba5					_IFSOverflow:
.bba5	20 44 ab	jsr $ab44			jsr 	ERR_Handler
>bba8	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>bbb0	20 6f 76 65 72 66 6c 6f 77 00
.bbba					IFSX1ShiftLeft:
.bbba	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x
.bbbd	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.bbc0	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.bbc3	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.bbc6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.bbc7					FPSubtract:
.bbc7	48		pha				pha
.bbc8	bd 13 03	lda $0313,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.bbcb	49 80		eor #$80			eor 	#$80
.bbcd	9d 13 03	sta $0313,x			sta 	XS2_Type,x
.bbd0	68		pla				pla 								; --- and fall through ---
.bbd1					FPAdd:
.bbd1	48		pha				pha
.bbd2	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.bbd5	d0 05		bne $bbdc			bne 	_FPA_NegativeLHS
.bbd7	20 f9 bb	jsr $bbf9			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.bbda	68		pla				pla
.bbdb	60		rts				rts
.bbdc					_FPA_NegativeLHS:
.bbdc	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.bbdf	49 80		eor #$80			eor 	#$80
.bbe1	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bbe4	bd 13 03	lda $0313,x			lda 	XS2_Type,x 					; flip the sign of B and add
.bbe7	49 80		eor #$80			eor 	#$80
.bbe9	9d 13 03	sta $0313,x			sta 	XS2_Type,x
.bbec	20 f9 bb	jsr $bbf9			jsr 	FPAdd_Worker 				; do the add calculation.
.bbef	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip sign of X1 back
.bbf2	49 80		eor #$80			eor 	#$80
.bbf4	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bbf7	68		pla				pla
.bbf8	60		rts				rts
.bbf9					FPAdd_Worker:
.bbf9	3c 13 03	bit $0313,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.bbfc	70 08		bvs $bc06			bvs 	_FPAWExit 					; no change.
.bbfe	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.bc01	50 07		bvc $bc0a			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.bc03	20 9e be	jsr $be9e			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.bc06					_FPAWExit:
.bc06	20 26 bf	jsr $bf26			jsr 	FPUNormalise 				; normalise the result.
.bc09	60		rts				rts
.bc0a					_FPAWMakeSame:
.bc0a	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.bc0d	38		sec				sec
.bc0e	fd 12 03	sbc $0312,x			sbc	 	XS2_Exponent,x 				; using subtraction
.bc11	f0 1b		beq $bc2e			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.bc13	da		phx				phx 								; save X
.bc14	90 06		bcc $bc1c			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.bc16	e8		inx				inx
.bc17	e8		inx				inx
.bc18	e8		inx				inx
.bc19	e8		inx				inx
.bc1a	e8		inx				inx
.bc1b	e8		inx				inx
.bc1c					_FPAWShiftA:
.bc1c	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x 				; so shift exponent up.
.bc1f	5e 0b 03	lsr $030b,x			lsr 	3+XS_Mantissa,x
.bc22	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.bc25	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.bc28	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.bc2b	fa		plx				plx 								; restore original X
.bc2c	80 dc		bra $bc0a			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.bc2e					_FPAW_DoArithmetic:
.bc2e	3c 13 03	bit $0313,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.bc31	30 39		bmi $bc6c			bmi 	_FPAW_BNegative
.bc33	18		clc				clc
.bc34	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.bc37	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.bc3a	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.bc3d	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.bc40	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.bc43	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.bc46	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.bc49	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.bc4c	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.bc4f	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.bc52	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.bc55	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.bc58	90 ac		bcc $bc06			bcc 	_FPAWExit 					; no carry.
.bc5a	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x 				; so shift exponent up.
.bc5d	38		sec				sec
.bc5e	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.bc61	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.bc64	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.bc67	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.bc6a	80 9a		bra $bc06			bra 	_FPAWExit
.bc6c					_FPAW_BNegative:
.bc6c	38		sec				sec
.bc6d	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.bc70	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.bc73	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.bc76	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.bc79	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.bc7c	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.bc7f	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.bc82	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.bc85	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.bc88	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.bc8b	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.bc8e	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.bc91	b0 0b		bcs $bc9e			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.bc93	20 cb be	jsr $becb			jsr 	FPUNegateInteger			; negate the mantissa
.bc96	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip result sign
.bc99	49 80		eor #$80			eor 	#$80
.bc9b	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bc9e					_FPAWGoExit:
.bc9e	4c 06 bc	jmp $bc06			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.bca1					FPD_IsDivZero:
.bca1	20 44 ab	jsr $ab44			jsr ERR_Handler
>bca4	44 69 76 69 73 69 6f 6e			.text "Division by zero",0
>bcac	20 62 79 20 7a 65 72 6f 00
.bcb5					FPDivide:
.bcb5	48		pha				pha
.bcb6	5a		phy				phy
.bcb7	3c 13 03	bit $0313,x			bit 	XS2_Type,x 					; check if division by zero
.bcba	70 e5		bvs $bca1			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.bcbc	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.bcbf	f0 03		beq $bcc4			beq 	_FPDCalculateExp
.bcc1					_FPD_Exit:
.bcc1	7a		ply				ply
.bcc2	68		pla				pla
.bcc3	60		rts				rts
.bcc4					_FPDCalculateExp:
.bcc4	bd 12 03	lda $0312,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.bcc7	49 ff		eor #$ff			eor 	#$FF
.bcc9	1a		inc a				inc 	a
.bcca	9d 12 03	sta $0312,x			sta 	XS2_Exponent,x
.bccd	20 c1 bd	jsr $bdc1			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.bcd0	18		clc				clc 	 							; add 1 to the resulting exponent
.bcd1	69 01		adc #$01			adc 	#1
.bcd3	b0 65		bcs $bd3a			bcs 	_FPD_Overflow 				; which can overflow.
.bcd5	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.bcd8	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.bcda	85 1a		sta $1a				sta 	zLTemp1+0
.bcdc	85 1b		sta $1b				sta 	zLTemp1+1
.bcde	85 1c		sta $1c				sta 	zLTemp1+2
.bce0	85 1d		sta $1d				sta 	zLTemp1+3
.bce2	a0 20		ldy #$20			ldy 	#32 						; times round.
.bce4					_FPD_Loop:
.bce4	38		sec				sec 								; calculate X1-X2 stacking result because we might
.bce5	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; not save it.
.bce8	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa,x
.bceb	48		pha				pha
.bcec	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.bcef	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.bcf2	48		pha				pha
.bcf3	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.bcf6	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.bcf9	48		pha				pha
.bcfa	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.bcfd	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.bd00	90 17		bcc $bd19			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.bd02	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x 			; save results out to A
.bd05	68		pla				pla
.bd06	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.bd09	68		pla				pla
.bd0a	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.bd0d	68		pla				pla
.bd0e	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.bd11	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.bd13	09 80		ora #$80			ora 	#$80
.bd15	85 1d		sta $1d				sta 	zLTemp1+3
.bd17	80 03		bra $bd1c			bra 	_FPD_Rotates
.bd19					_FPD_NoSubtract:
.bd19	68		pla				pla 								; throw away unwanted results
.bd1a	68		pla				pla
.bd1b	68		pla				pla
.bd1c					_FPD_Rotates:
.bd1c	5e 11 03	lsr $0311,x			lsr 	3+XS2_Mantissa,x
.bd1f	7e 10 03	ror $0310,x			ror 	2+XS2_Mantissa,x
.bd22	7e 0f 03	ror $030f,x			ror 	1+XS2_Mantissa,x
.bd25	7e 0e 03	ror $030e,x			ror 	0+XS2_Mantissa,x
.bd28	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.bd2a	26 1b		rol $1b				rol 	zLTemp1+1
.bd2c	26 1c		rol $1c				rol 	zLTemp1+2
.bd2e	26 1d		rol $1d				rol 	zLTemp1+3
.bd30	90 02		bcc $bd34			bcc 	_FPD_NoCarry
.bd32	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.bd34					_FPD_NoCarry:
.bd34	88		dey				dey 								; do 32 times
.bd35	d0 ad		bne $bce4			bne 	_FPD_Loop
.bd37	4c 9e bd	jmp $bd9e			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.bd3a					_FPD_Overflow:
.bd3a	4c 9b bf	jmp $bf9b			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.bd3d					FPMultiply:
.bd3d	48		pha				pha
.bd3e	5a		phy				phy
.bd3f	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.bd42	70 08		bvs $bd4c			bvs 	_FPM_Exit
.bd44	3c 13 03	bit $0313,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.bd47	50 06		bvc $bd4f			bvc 	_FPM_CalcExponent
.bd49	20 9e be	jsr $be9e			jsr 	FPUCopyX2ToX1
.bd4c					_FPM_Exit:
.bd4c	7a		ply				ply
.bd4d	68		pla				pla
.bd4e	60		rts				rts
.bd4f					_FPM_CalcExponent:
.bd4f	18		clc				clc
.bd50	20 c1 bd	jsr $bdc1			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.bd53	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x 				; save the result.
.bd56	a9 00		lda #$00			lda 	#0
.bd58	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.bd5a	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.bd5c	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.bd5e	85 1d		sta $1d				sta 	zLTemp1+3
.bd60	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.bd62					_FPM_Loop:
.bd62	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x				; check LSB of long product
.bd65	29 01		and #$01			and 	#1
.bd67	18		clc				clc 								; clear carry for the long rotate.
.bd68	f0 1d		beq $bd87			beq 	_FPM_NoAddition
.bd6a	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.bd6b	a5 1a		lda $1a				lda 	zLTemp1+0
.bd6d	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.bd70	85 1a		sta $1a				sta 	zLTemp1+0
.bd72	a5 1b		lda $1b				lda 	zLTemp1+1
.bd74	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.bd77	85 1b		sta $1b				sta 	zLTemp1+1
.bd79	a5 1c		lda $1c				lda 	zLTemp1+2
.bd7b	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.bd7e	85 1c		sta $1c				sta 	zLTemp1+2
.bd80	a5 1d		lda $1d				lda 	zLTemp1+3
.bd82	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.bd85	85 1d		sta $1d				sta 	zLTemp1+3
.bd87					_FPM_NoAddition:
.bd87	66 1d		ror $1d				ror 	3+zLTemp1
.bd89	66 1c		ror $1c				ror 	2+zLTemp1
.bd8b	66 1b		ror $1b				ror 	1+zLTemp1
.bd8d	66 1a		ror $1a				ror 	0+zLTemp1
.bd8f	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.bd92	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.bd95	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.bd98	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.bd9b	88		dey				dey
.bd9c	d0 c4		bne $bd62			bne 	_FPM_Loop 					; do this 32 times.
.bd9e					FPM_CopySignNormalize:
.bd9e	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.bda0	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.bda3	a5 1b		lda $1b				lda 	zLTemp1+1
.bda5	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.bda8	a5 1c		lda $1c				lda 	zLTemp1+2
.bdaa	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.bdad	a5 1d		lda $1d				lda 	zLTemp1+3
.bdaf	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.bdb2	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; sign is xor of signs
.bdb5	5d 13 03	eor $0313,x			eor 	XS2_Type,x
.bdb8	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bdbb	20 26 bf	jsr $bf26			jsr 	FPUNormalise 				; normalise and exit.
.bdbe	7a		ply				ply
.bdbf	68		pla				pla
.bdc0	60		rts				rts
.bdc1					FPCalculateExponent:
.bdc1	18		clc				clc
.bdc2	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.bdc5	7d 12 03	adc $0312,x			adc 	XS2_Exponent,x
.bdc8	b0 08		bcs $bdd2			bcs 	_FPCECarry 					; carry out ?
.bdca	10 03		bpl $bdcf			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.bdcc	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.bdce	60		rts				rts
.bdcf					_FPCEExpZero:
.bdcf	a9 00		lda #$00			lda 	#0
.bdd1	60		rts				rts
.bdd2					_FPCECarry:
.bdd2	30 03		bmi $bdd7			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.bdd4	09 80		ora #$80			ora 	#$80 						; put in right range
.bdd6	60		rts				rts
.bdd7					_FPCEOverflow:
.bdd7	4c 9b bf	jmp $bf9b			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.bdda					FPFractionalPart:
.bdda	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.bddd	38		sec				sec 								; this flag tells us to keep the fractional part
.bdde	30 0f		bmi $bdef			bmi 	FPGetPart
.bde0	60		rts				rts
.bde1					FPIntegerPart:
.bde1	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.bde4	18		clc				clc 								; this flag says keep the integer part.
.bde5	30 08		bmi $bdef			bmi 	FPGetPart 					; -ve exponents are 0..127
.bde7	48		pha				pha
.bde8	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.bdea	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bded	68		pla				pla
.bdee	60		rts				rts
.bdef					FPGetPart:
.bdef	48		pha				pha
.bdf0	5a		phy				phy 								; save Y
.bdf1	08		php				php 								; save action
.bdf2	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.bdf5	70 62		bvs $be59			bvs 	_FPGP_Exit 					; then do nothing.
.bdf7	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.bdf9	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.bdfb	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.bdfd	85 1c		sta $1c				sta 	zLTemp1+2
.bdff	85 1d		sta $1d				sta 	zLTemp1+3
.be01	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x				; the number of shifts.
.be04	38		sec				sec
.be05	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.be07	f0 12		beq $be1b			beq 	_FPGP_NoShift 				; ... if any
.be09	c9 20		cmp #$20			cmp 	#32
.be0b	90 02		bcc $be0f			bcc 	_FPGP_NotMax
.be0d	a9 20		lda #$20			lda 	#32 						; max of 32.
.be0f					_FPGP_NotMax:
.be0f	a8		tay				tay 								; Y is the mask shift count.
.be10					_FPGP_ShiftMask:
.be10	46 1d		lsr $1d				lsr 	3+zLTemp1
.be12	66 1c		ror $1c				ror 	2+zLTemp1
.be14	66 1b		ror $1b				ror 	1+zLTemp1
.be16	66 1a		ror $1a				ror 	0+zLTemp1
.be18	88		dey				dey
.be19	d0 f5		bne $be10			bne 	_FPGP_ShiftMask
.be1b					_FPGP_NoShift:
.be1b	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.be1d	8e 8c 04	stx $048c			stx 	ExpTemp						; save X
.be20					_FPGP_MaskLoop:
.be20	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.be23	28		plp				plp 								; if CC we keep the top part, so we
.be24	08		php				php		 							; flip the mask.
.be25	b0 02		bcs $be29			bcs		_FPGP_NoFlip
.be27	49 ff		eor #$ff			eor 	#$FF
.be29					_FPGP_NoFlip:
.be29	3d 08 03	and $0308,x			and 	XS_Mantissa,x 				; and into the mantissa.
.be2c	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.be2f	e8		inx				inx
.be30	c8		iny				iny
.be31	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.be33	d0 eb		bne $be20			bne 	_FPGP_MaskLoop
.be35	ae 8c 04	ldx $048c			ldx 	ExpTemp						; restore X
.be38	28		plp				plp
.be39	08		php				php 								; get action flag on the stack
.be3a	90 05		bcc $be41			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.be3c	a9 00		lda #$00			lda 	#0
.be3e	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.be41					_FPGP_NotFractional:
.be41	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 						; check if \1 zero
.be44	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.be47	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.be4a	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.be4d	f0 05		beq $be54			beq 	_FPGP_Zero 					; if zero, return zero
.be4f	20 26 bf	jsr $bf26			jsr 	FPUNormalise
.be52	80 05		bra $be59			bra 	_FPGP_Exit 					; and exit
.be54					_FPGP_Zero:
.be54	a9 40		lda #$40			lda 	#$40 						; set zero flag
.be56	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.be59					_FPGP_Exit:
.be59	68		pla				pla 								; throw saved action flag.
.be5a	7a		ply				ply
.be5b	68		pla				pla
.be5c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.be5d					FPCompare:
.be5d	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.be60	48		pha				pha
.be61	bd 12 03	lda $0312,x			lda 	XS2_Exponent,x
.be64	48		pha				pha
.be65	20 c7 bb	jsr $bbc7			jsr 	FPSubtract 					; calculate X1-X2
.be68	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.be6b	70 2c		bvs $be99			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.be6d	68		pla				pla
.be6e	8d 8c 04	sta $048c			sta 	ExpTemp						; save first exponent in temporary reg.
.be71	68		pla				pla
.be72	38		sec				sec
.be73	ed 8c 04	sbc $048c			sbc 	ExpTemp 					; calculate AX-BX
.be76	70 15		bvs $be8d			bvs 	_FPCNotEqual				; overflow, can't be equal.
.be78	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.be79	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.be7b	b0 10		bcs $be8d			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.be7d	38		sec				sec
.be7e	ad 8c 04	lda $048c			lda 	ExpTemp 					; get one of the exponents back.
.be81	e9 12		sbc #$12			sbc 	#18 						; allow for 2^18 error, relatively.
.be83	b0 02		bcs $be87			bcs 	_FPCNotRange 				; keep in range.
.be85	a9 01		lda #$01			lda 	#1
.be87					_FPCNotRange:
.be87	38		sec				sec
.be88	fd 0c 03	sbc $030c,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.be8b	b0 0e		bcs $be9b			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.be8d					_FPCNotEqual:
.be8d	bd 0d 03	lda $030d,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.be90	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.be92	f0 02		beq $be96			beq 	_FPCNE2
.be94	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.be96	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.be97	80 04		bra $be9d			bra 	_FPCExit
.be99					_FPCPullZero:
.be99	68		pla				pla 								; throw saved exponents
.be9a	68		pla				pla
.be9b					_FPCZero:
.be9b	a9 00		lda #$00			lda 	#0 							; and return zero
.be9d					_FPCExit:
.be9d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.be9e					FPUCopyX2ToX1:
.be9e	48		pha				pha
.be9f	da		phx				phx
.bea0	5a		phy				phy
.bea1	a0 08		ldy #$08			ldy 	#8
.bea3	bd 0e 03	lda $030e,x	_FPUC21:lda 	XS2_Mantissa,x
.bea6	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.bea9	e8		inx				inx
.beaa	88		dey				dey
.beab	10 f6		bpl $bea3			bpl 	_FPUC21
.bead	7a		ply				ply
.beae	fa		plx				plx
.beaf	68		pla				pla
.beb0	60		rts				rts
.beb1					FPUSetInteger:
.beb1	48		pha				pha
.beb2	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.beb5	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.beb7	10 02		bpl $bebb			bpl 	_FPUSIExtend
.beb9	a9 ff		lda #$ff			lda 	#$FF
.bebb					_FPUSIExtend:
.bebb	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.bebe	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.bec1	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.bec4	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.bec6	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bec9	68		pla				pla
.beca	60		rts				rts
.becb					FPUNegateInteger:
.becb	48		pha				pha
.becc	38		sec				sec
.becd	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.becf	fd 08 03	sbc $0308,x			sbc 	XS_Mantissa+0,x
.bed2	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.bed5	a9 00		lda #$00			lda 	#0
.bed7	fd 09 03	sbc $0309,x			sbc 	XS_Mantissa+1,x
.beda	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.bedd	a9 00		lda #$00			lda 	#0
.bedf	fd 0a 03	sbc $030a,x			sbc 	XS_Mantissa+2,x
.bee2	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.bee5	a9 00		lda #$00			lda 	#0
.bee7	fd 0b 03	sbc $030b,x			sbc 	XS_Mantissa+3,x
.beea	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.beed	68		pla				pla
.beee	60		rts				rts
.beef					FPUToFloat:
.beef	48		pha				pha
.bef0	bd 0d 03	lda $030d,x			lda 	XS_Type,x					; exit if already float.
.bef3	29 0f		and #$0f			and 	#$0F
.bef5	f0 2d		beq $bf24			beq 	_FPUFExit
.bef7	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.bef9	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.befc	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.befe	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x 				; x mantissa.
.bf01	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.bf04	10 08		bpl $bf0e			bpl		_FPUFPositive
.bf06	20 cb be	jsr $becb			jsr 	FPUNegateInteger 			; negate the mantissa
.bf09	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.bf0b	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bf0e					_FPUFPositive:
.bf0e	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.bf11	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.bf14	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.bf17	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.bf1a	d0 05		bne $bf21			bne 	_FPUFNonZero
.bf1c	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.bf1e	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bf21					_FPUFNonZero:
.bf21	20 26 bf	jsr $bf26			jsr 	FPUNormalise 				; normalise the floating point.
.bf24					_FPUFExit:
.bf24	68		pla				pla
.bf25	60		rts				rts
.bf26					FPUNormalise:
.bf26	48		pha				pha
.bf27	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.bf2a	70 20		bvs $bf4c			bvs 	_FPUNExit
.bf2c	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.bf2f	f0 16		beq $bf47			beq 	_FPUNSetZero
.bf31					_FPUNLoop:
.bf31	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.bf34	30 16		bmi $bf4c			bmi 	_FPUNExit 					; if so, we are normalised.
.bf36	1e 08 03	asl $0308,x			asl 	0+XS_Mantissa+0,x
.bf39	3e 09 03	rol $0309,x			rol 	1+XS_Mantissa+0,x
.bf3c	3e 0a 03	rol $030a,x			rol 	2+XS_Mantissa+0,x
.bf3f	3e 0b 03	rol $030b,x			rol 	3+XS_Mantissa+0,x
.bf42	de 0c 03	dec $030c,x			dec 	XS_Exponent,x 				; decrement exponent
.bf45	d0 ea		bne $bf31			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.bf47					_FPUNSetZero:
.bf47	a9 40		lda #$40			lda 	#$40
.bf49	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; the result is now zero.
.bf4c					_FPUNExit:
.bf4c	68		pla				pla
.bf4d	60		rts				rts
.bf4e					FPUToInteger:
.bf4e	48		pha				pha
.bf4f	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; if already integer, exit
.bf52	29 01		and #$01			and 	#1
.bf54	d0 3e		bne $bf94			bne 	_FPUTOI_Exit
.bf56	3c 0d 03	bit $030d,x			bit 	XS_Type,x					; if zero, return zero.
.bf59	70 2b		bvs $bf86			bvs 	_FPUTOI_Zero
.bf5b	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.bf5e	10 26		bpl $bf86			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.bf60	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.bf62	b0 37		bcs $bf9b			bcs 	FP_Overflow
.bf64					_FPUToIToInteger:
.bf64	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.bf67	c9 a0		cmp #$a0			cmp 	#128+32
.bf69	f0 11		beq $bf7c			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.bf6b	fe 0c 03	inc $030c,x			inc 	XS_Exponent,X 				; increment Exponent
.bf6e	5e 0b 03	lsr $030b,x			lsr 	3+XS_Mantissa,x
.bf71	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.bf74	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.bf77	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.bf7a	80 e8		bra $bf64			bra 	_FPUToIToInteger 			; keep going.
.bf7c					_FPUToICheckSign:
.bf7c	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; check sign
.bf7f	10 13		bpl $bf94			bpl 	_FPUToI_Exit 				; exit if unsigned.
.bf81	20 cb be	jsr $becb			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.bf84	80 0e		bra $bf94			bra 	_FPUTOI_Exit
.bf86					_FPUTOI_Zero:
.bf86	a9 00		lda #$00			lda 	#0 							; return zero integer.
.bf88	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.bf8b	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.bf8e	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.bf91	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.bf94					_FPUToI_Exit:
.bf94	a9 01		lda #$01			lda 	#1 							; set type to integer
.bf96	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bf99	68		pla				pla
.bf9a	60		rts				rts
.bf9b					FP_Overflow:
.bf9b	20 44 ab	jsr $ab44			jsr ERR_Handler
>bf9e	46 6c 6f 61 74 69 6e 67			.text "Floating Point overflow",0
>bfa6	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.bfb6					FPUTimes10:
.bfb6	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.bfb9	85 1a		sta $1a				sta 	ZLTemp1+0
.bfbb	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.bfbe	85 1b		sta $1b				sta 	ZLTemp1+1
.bfc0	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.bfc3	85 1c		sta $1c				sta 	ZLTemp1+2
.bfc5	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.bfc8	85 1d		sta $1d				sta 	ZLTemp1+3
.bfca	20 0e c0	jsr $c00e			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.bfcd	20 0e c0	jsr $c00e			jsr 	_FPUT_LSR_ZLTemp1
.bfd0	18		clc				clc
.bfd1	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.bfd4	65 1a		adc $1a				adc 	ZLTemp1+0
.bfd6	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.bfd9	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.bfdc	65 1b		adc $1b				adc 	ZLTemp1+1
.bfde	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.bfe1	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.bfe4	65 1c		adc $1c				adc 	ZLTemp1+2
.bfe6	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.bfe9	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.bfec	65 1d		adc $1d				adc 	ZLTemp1+3
.bfee	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.bff1	90 0f		bcc $c002			bcc 	_FPUTimes10
.bff3	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.bff6	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.bff9	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.bffc	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.bfff	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x				; fix exponent
.c002					_FPUTimes10:
.c002	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.c005	18		clc				clc
.c006	69 03		adc #$03			adc 	#3
.c008	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.c00b	b0 8e		bcs $bf9b			bcs 	FP_Overflow 				; error
.c00d	60		rts				rts
.c00e					_FPUT_LSR_ZLTemp1:
.c00e	46 1d		lsr $1d				lsr 	ZLTemp1+3
.c010	66 1c		ror $1c				ror 	ZLTemp1+2
.c012	66 1b		ror $1b				ror 	ZLTemp1+1
.c014	66 1a		ror $1a				ror 	ZLTemp1+0
.c016	60		rts				rts
.c017					FPUScale10A:
.c017	5a		phy				phy
.c018	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.c01a	f0 3d		beq $c059			beq 	_FPUScaleExit
.c01c	da		phx				phx 								; save X
.c01d	e8		inx				inx
.c01e	e8		inx				inx
.c01f	e8		inx				inx
.c020	e8		inx				inx
.c021	e8		inx				inx
.c022	e8		inx				inx
.c023	a8		tay				tay 								; save power scalar in Y.
.c024	a9 00		lda #$00			lda 	#0
.c026	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.c029	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.c02c	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.c02f	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.c032	a9 80		lda #$80			lda 	#$80
.c034	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.c037	a9 81		lda #$81			lda 	#$81
.c039	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.c03c	5a		phy				phy 								; save 10^n on stack.
.c03d	c0 00		cpy #$00			cpy 	#0
.c03f	10 05		bpl $c046			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.c041	98		tya				tya
.c042	49 ff		eor #$ff			eor 	#$FF
.c044	1a		inc a				inc 	a
.c045	a8		tay				tay
.c046					_FPUSAbs:
.c046	20 b6 bf	jsr $bfb6			jsr 	FPUTimes10
.c049	88		dey				dey
.c04a	d0 fa		bne $c046			bne 	_FPUSAbs 					; tos is now 10^|AC|
.c04c	68		pla				pla 								; restore count in A
.c04d	fa		plx				plx 								; restore X pointing to number to scale.
.c04e	0a		asl a				asl 	a
.c04f	b0 05		bcs $c056			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.c051	20 3d bd	jsr $bd3d			jsr 	FPMultiply 					; if clear multiply.
.c054	80 03		bra $c059			bra		_FPUScaleExit
.c056					_FPUSDivide:
.c056	20 b5 bc	jsr $bcb5			jsr 	FPDivide
.c059					_FPUScaleExit:
.c059	7a		ply				ply
.c05a	60		rts				rts
.c05b					FPUCopyToNext:
.c05b	a0 06		ldy #$06			ldy 		#6
.c05d	da		phx				phx
.c05e					_FPUCopy1:
.c05e	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x
.c061	9d 0e 03	sta $030e,x			sta 	XS2_Mantissa,x
.c064	e8		inx				inx
.c065	88		dey				dey
.c066	d0 f6		bne $c05e			bne 	_FPUCopy1
.c068	fa		plx				plx
.c069	60		rts				rts
.c06a					FPUCopyFromNext:
.c06a	a0 06		ldy #$06			ldy 		#6
.c06c	da		phx				phx
.c06d					_FPUCopy1:
.c06d	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa,x
.c070	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.c073	e8		inx				inx
.c074	88		dey				dey
.c075	d0 f6		bne $c06d			bne 	_FPUCopy1
.c077	fa		plx				plx
.c078	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.c079					FPToString:
.c079	48		pha				pha
.c07a	5a		phy				phy
.c07b	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; check zero flag
.c07e	50 0a		bvc $c08a			bvc 		_FPTSIsFloat 			; if zero,
.c080					_FPTSZero:
.c080	a9 30		lda #$30			lda 		#"0"
.c082	20 09 bb	jsr $bb09			jsr 		ITSOutputCharacter
.c085					_FPTSExit:
.c085	7a		ply				ply
.c086	68		pla				pla
.c087	60		rts				rts
.c088	80 fb		bra $c085			bra 		_FPTSExit
.c08a					_FPTSIsFloat:
.c08a	bd 0d 03	lda $030d,x			lda 		XS_Type,x 				; is it signed ?
.c08d	10 0a		bpl $c099			bpl 		_FPTSNotSigned
.c08f	a9 00		lda #$00			lda 		#0 						; clear sign flag
.c091	9d 0d 03	sta $030d,x			sta 		XS_Type,x
.c094	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.c096	20 09 bb	jsr $bb09			jsr 		ITSOutputCharacter
.c099					_FPTSNotSigned:
.c099	bd 0c 03	lda $030c,x			lda 		XS_Exponent,x
.c09c	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.c09e	b0 09		bcs $c0a9			bcs 		_FPTSExponent
.c0a0	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.c0a2	90 05		bcc $c0a9			bcc 		_FPTSExponent 			;
.c0a4					_FPTSStandard:
.c0a4	20 ed c0	jsr $c0ed			jsr 		FPTOutputBody 			; output the body.
.c0a7	80 dc		bra $c085			bra 		_FPTSExit
.c0a9					_FPTSExponent:
.c0a9	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.c0ab	8d 8d 04	sta $048d			sta 		ExpCount
.c0ae					_FPTSExponentLoop:
.c0ae	bd 0c 03	lda $030c,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.c0b1	10 0e		bpl $c0c1			bpl 		_FPTSTimes
.c0b3	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.c0b5	90 14		bcc $c0cb			bcc 		_FPTSScaledToExp
.c0b7	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.c0b9	20 17 c0	jsr $c017			jsr 		FPUScale10A
.c0bc	ee 8d 04	inc $048d			inc 		ExpCount
.c0bf	80 ed		bra $c0ae			bra 		_FPTSExponentLoop
.c0c1					_FPTSTimes:
.c0c1	a9 01		lda #$01			lda 		#1
.c0c3	20 17 c0	jsr $c017			jsr 		FPUScale10A
.c0c6	ce 8d 04	dec $048d			dec 		ExpCount
.c0c9	80 e3		bra $c0ae			bra 		_FPTSExponentLoop
.c0cb					_FPTSScaledToExp:
.c0cb	20 ed c0	jsr $c0ed			jsr 		FPTOutputBody 			; output the body.
.c0ce	a9 65		lda #$65			lda 		#"e"					; output E
.c0d0	20 09 bb	jsr $bb09			jsr 		ITSOutputCharacter
.c0d3	ad 8d 04	lda $048d			lda 		ExpCount 				; get the exponent
.c0d6	9d 08 03	sta $0308,x			sta 		XS_Mantissa,x
.c0d9	29 80		and #$80			and 		#$80 					; sign extend it
.c0db	f0 02		beq $c0df			beq 		_FPTSSExt
.c0dd	a9 ff		lda #$ff			lda 		#$FF
.c0df					_FPTSSExt:
.c0df	9d 09 03	sta $0309,x			sta 		XS_Mantissa+1,x
.c0e2	9d 0a 03	sta $030a,x			sta 		XS_Mantissa+2,x
.c0e5	9d 0b 03	sta $030b,x			sta 		XS_Mantissa+3,x
.c0e8	20 69 ba	jsr $ba69			jsr 		INTToString 			; output the exponent.
.c0eb	80 98		bra $c085			bra			_FPTSExit 				; and exit.
.c0ed					FPTOutputBody:
.c0ed	20 5b c0	jsr $c05b			jsr 		FPUCopyToNext 			; copy to next slot.
.c0f0	20 4e bf	jsr $bf4e			jsr 		FPUToInteger 			; convert to an integer
.c0f3	20 69 ba	jsr $ba69			jsr 		INTToString 			; output the main integer part.
.c0f6	20 6a c0	jsr $c06a			jsr 		FPUCopyFromNext 		; get the fractional part back.
.c0f9	20 da bd	jsr $bdda			jsr 		FPFractionalPart 		; get the decimal part.
.c0fc	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; any fractional part.
.c0ff	70 3e		bvs $c13f			bvs 		_FPTOExit 				; if not, exit now.
.c101	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.c103	20 09 bb	jsr $bb09			jsr 		ITSOutputCharacter
.c106					_FPOutLoop:
.c106	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; finally reached zero.
.c109	70 1e		bvs $c129			bvs 		_FPStripZeros 			; strip trailing zeros
.c10b	20 b6 bf	jsr $bfb6			jsr 		FPUTimes10 				; multiply by 10
.c10e	20 5b c0	jsr $c05b			jsr 		FPUCopyToNext			; copy to next slot.
.c111	20 4e bf	jsr $bf4e			jsr 		FPUToInteger 			; convert to integer
.c114	bd 08 03	lda $0308,x			lda 		XS_Mantissa+0,x 		; print digit.
.c117	09 30		ora #$30			ora 		#"0"
.c119	20 09 bb	jsr $bb09			jsr 		ITSOutputCharacter
.c11c	20 6a c0	jsr $c06a			jsr 		FPUCopyFromNext 		; get it back
.c11f	20 da bd	jsr $bdda			jsr 		FPFractionalPart 		; get fractional part
.c122	ad 04 04	lda $0404			lda 		NumBufX 				; done 11 characters yet ?
.c125	c9 0b		cmp #$0b			cmp 	 	#11
.c127	90 dd		bcc $c106			bcc 		_FPOutLoop 				; if so, keep going till zero.
.c129					_FPStripZeros:
.c129	ac 04 04	ldy $0404			ldy 		NumBufX 				; strip trailing zeros.
.c12c					_FPStripLoop:
.c12c	88		dey				dey 								; back one, if at start then no strip
.c12d	f0 10		beq $c13f			beq 		_FPToExit
.c12f	b9 05 04	lda $0405,y			lda 		Num_Buffer,y 			; keep going if "0"
.c132	c9 30		cmp #$30			cmp 		#"0"
.c134	f0 f6		beq $c12c			beq 		_FPStripLoop
.c136	c8		iny				iny
.c137	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.c139	99 05 04	sta $0405,y			sta 		Num_Buffer,y
.c13c	8c 04 04	sty $0404			sty 		NumBufX 				; update position.
.c13f					_FPTOExit:
.c13f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.c140					FPFromString:
.c140	48		pha				pha 								; push A
.c141	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.c143	c9 2e		cmp #$2e			cmp 	#"."
.c145	f0 03		beq $c14a			beq	 	_FPFIsDecimal
.c147	4c ad c1	jmp $c1ad			jmp 	_FPFNotDecimal
.c14a					_FPFIsDecimal:
.c14a	c8		iny				iny 								; consume the decimal.
.c14b	20 ef be	jsr $beef			jsr 	FPUToFloat 					; convert the integer to float.
.c14e	da		phx				phx 								; save X.
.c14f	5a		phy				phy 								; save decimal start position
.c150	e8		inx				inx
.c151	e8		inx				inx
.c152	e8		inx				inx
.c153	e8		inx				inx
.c154	e8		inx				inx
.c155	e8		inx				inx
.c156	20 21 bb	jsr $bb21			jsr 	INTFromStringY 				; get the part after the DP.
.c159	20 ef be	jsr $beef			jsr 	FPUToFloat 					; convert that to a float.
.c15c	68		pla				pla 								; calculate - chars consumed.
.c15d	8c 8c 04	sty $048c			sty 	ExpTemp
.c160	38		sec				sec
.c161	ed 8c 04	sbc $048c			sbc 	ExpTemp 					; this is the shift amount
.c164	20 17 c0	jsr $c017			jsr 	FPUScale10A 				; scale it by 10^AC
.c167	fa		plx				plx 								; restore original X
.c168	20 d1 bb	jsr $bbd1			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.c16b	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.c16d	c9 45		cmp #$45			cmp 	#"E"
.c16f	f0 04		beq $c175			beq 	_FPFExponent
.c171	c9 65		cmp #$65			cmp 	#"e"
.c173	d0 38		bne $c1ad			bne 	_FPFNotDecimal 				; no, then exit normally.
.c175					_FPFExponent:
.c175	c8		iny				iny 								; skip over E symbol.
.c176	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.c178	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.c17a	d0 01		bne $c17d			bne 	_FPFGotSign
.c17c	c8		iny				iny 								; if it was - skip over it.
.c17d					_FPFGotSign:
.c17d	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.c17e	da		phx				phx
.c17f	e8		inx				inx
.c180	e8		inx				inx
.c181	e8		inx				inx
.c182	e8		inx				inx
.c183	e8		inx				inx
.c184	e8		inx				inx
.c185	20 21 bb	jsr $bb21			jsr 	INTFromStringY 				; get the exponent
.c188	fa		plx				plx 								; restore X.
.c189	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.c18c	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.c18f	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.c192	d0 1b		bne $c1af			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.c194	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.c197	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.c199	b0 14		bcs $c1af			bcs 	_FPFXOverflow
.c19b	68		pla				pla 								; get direction
.c19c	d0 09		bne $c1a7			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.c19e	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.c1a1	49 ff		eor #$ff			eor 	#$FF
.c1a3	1a		inc a				inc 	a
.c1a4	9d 0e 03	sta $030e,x			sta 	XS2_Mantissa+0,x
.c1a7					_FPFXScale:
.c1a7	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.c1aa	20 17 c0	jsr $c017			jsr 	FPUScale10A 				; scale by the exponent.
.c1ad					_FPFNotDecimal:
.c1ad	68		pla				pla
.c1ae	60		rts				rts
.c1af					_FPFXOverflow:
.c1af	20 44 ab	jsr $ab44			jsr 	ERR_Handler
>c1b2	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>c1ba	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.c1c1					Unary_Rnd:
.c1c1	20 b1 b0	jsr $b0b1			jsr 	EvaluateNumberX 			; get value
.c1c4	20 43 b7	jsr $b743			jsr 	CheckNextRParen 			; check right bracket.
.c1c7	20 9e b3	jsr $b39e			jsr 	GetSignCurrent 				; get sign -1,0,1.
.c1ca	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.c1cc	30 10		bmi $c1de			bmi 	_URSetSeed
.c1ce	f0 2c		beq $c1fc			beq 	_URMakeRandom 				; if zero return same number.
.c1d0	da		phx				phx
.c1d1	a2 00		ldx #$00			ldx 	#0
.c1d3	20 39 c2	jsr $c239			jsr 	Random16
.c1d6	a2 02		ldx #$02			ldx 	#2
.c1d8	20 39 c2	jsr $c239			jsr 	Random16
.c1db	fa		plx				plx
.c1dc	80 1e		bra $c1fc			bra 	_URMakeRandom
.c1de					_URSetSeed:
.c1de	20 ef be	jsr $beef			jsr 	FPUToFloat 					; make it a float to twiddle it.
.c1e1	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.c1e4	8d 93 04	sta $0493			sta 	RandomSeed+0
.c1e7	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.c1ea	8d 94 04	sta $0494			sta 	RandomSeed+1
.c1ed	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.c1f0	8d 95 04	sta $0495			sta 	RandomSeed+2
.c1f3	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.c1f6	0a		asl a				asl 	a
.c1f7	49 db		eor #$db			eor 	#$DB
.c1f9	8d 96 04	sta $0496			sta 	RandomSeed+3
.c1fc					_URMakeRandom:
.c1fc	ad 93 04	lda $0493			lda 	RandomSeed+0 				; check if seed is zero.
.c1ff	0d 94 04	ora $0494			ora 	RandomSeed+1
.c202	0d 95 04	ora $0495			ora 	RandomSeed+2
.c205	0d 96 04	ora $0496			ora 	RandomSeed+3
.c208	d0 0a		bne $c214			bne 	_URNotZero
.c20a	a9 47		lda #$47			lda 	#$47
.c20c	8d 94 04	sta $0494			sta 	RandomSeed+1				; if it is, make it non zero.
.c20f	a9 3d		lda #$3d			lda 	#$3D
.c211	8d 96 04	sta $0496			sta 	RandomSeed+3
.c214					_URNotZero:
.c214	ad 93 04	lda $0493			lda 	RandomSeed+0 				; copy seed into mantissa.
.c217	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.c21a	ad 94 04	lda $0494			lda 	RandomSeed+1
.c21d	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.c220	ad 95 04	lda $0495			lda 	RandomSeed+2
.c223	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.c226	ad 96 04	lda $0496			lda 	RandomSeed+3
.c229	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.c22c	a9 00		lda #$00			lda 	#$00 						; set type to float.
.c22e	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.c231	a9 80		lda #$80			lda 	#$80
.c233	9d 0c 03	sta $030c,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.c236	4c 26 bf	jmp $bf26			jmp 	FPUNormalise
.c239					Random16:
.c239	5e 94 04	lsr $0494,x			lsr 	RandomSeed+1,x				; shift seed right
.c23c	7e 93 04	ror $0493,x			ror 	RandomSeed,x
.c23f	90 08		bcc $c249			bcc 	_R16_NoXor
.c241	bd 94 04	lda $0494,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.c244	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.c246	9d 94 04	sta $0494,x			sta 	RandomSeed+1,x
.c249					_R16_NoXor:
.c249	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.c24a					Unary_Int:
.c24a	20 b1 b0	jsr $b0b1			jsr 	EvaluateNumberX 			; get value
.c24d	20 43 b7	jsr $b743			jsr 	CheckNextRParen 			; check right bracket.
.c250	4c 4e bf	jmp $bf4e			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.c253					TIM_Error:
.c253	20 35 a0	jsr $a035			jsr 	IFT_UpLine 					; go up one line.
.c256	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.c258	80 02		bra $c25c			bra 	TIM_ShowPrompt
.c25a					TIM_NewCommand:
.c25a	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.c25c					TIM_ShowPrompt:
.c25c	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.c25f	20 06 a1	jsr $a106			jsr 	IFT_ReadLine	 			; get character, go to next line
.c262	20 68 a0	jsr $a068			jsr 	IFT_NewLine					; go to next line.
.c265	86 10		stx $10				stx 	zTemp1 						; save line read address
.c267	84 11		sty $11				sty 	zTemp1+1
.c269	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.c26b	b1 10		lda ($10),y			lda 	(zTemp1),y
.c26d	c9 3f		cmp #$3f			cmp 	#"?"
.c26f	f0 04		beq $c275			beq 	TIM_SkipFirst
.c271	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.c273	d0 01		bne $c276			bne 	TIM_NotDot
.c275					TIM_SkipFirst:
.c275	c8		iny				iny
.c276					TIM_NotDot:
.c276	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.c278	c9 52		cmp #$52			cmp 	#"R"						; show registers
.c27a	f0 6e		beq $c2ea			beq 	TIM_ShowRegisters
.c27c	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.c27e	f0 12		beq $c292			beq 	TIM_ShowMemory
.c280	c9 47		cmp #$47			cmp 	#"G"						; execute
.c282	f0 49		beq $c2cd			beq 	TIM_Execute
.c284	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.c286	f0 07		beq $c28f			beq 	TIM_GoLoadMemory
.c288	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.c28a	d0 c7		bne $c253			bne 	TIM_Error
.c28c	4c 0f c4	jmp $c40f			jmp 	TIM_UpdateRegisters
.c28f					TIM_GoLoadMemory:
.c28f	4c 3a c4	jmp $c43a			jmp 	TIM_LoadMemory
.c292					TIM_ShowMemory:
.c292	20 88 c3	jsr $c388			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.c295	b0 bc		bcs $c253			bcs 	TIM_Error
.c297	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.c299	85 12		sta $12				sta 	zTemp2
.c29b	a5 15		lda $15				lda 	zTemp3+1
.c29d	85 13		sta $13				sta 	zTemp2+1
.c29f	20 88 c3	jsr $c388			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.c2a2	90 08		bcc $c2ac			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.c2a4	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.c2a6	85 14		sta $14				sta 	zTemp3
.c2a8	a5 13		lda $13				lda 	zTemp2+1
.c2aa	85 15		sta $15				sta 	zTemp3+1
.c2ac					_TIMSM_Start:
.c2ac	20 60 c3	jsr $c360			jsr 	TIM_WriteLine 				; write one line of hex out
.c2af	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.c2b1	18		clc				clc
.c2b2	69 10		adc #$10			adc 	#16
.c2b4	85 12		sta $12				sta 	zTemp2
.c2b6	90 02		bcc $c2ba			bcc 	_TIMSM_NoCarry
.c2b8	e6 13		inc $13				inc 	zTemp2+1
.c2ba					_TIMSM_NoCarry:
.c2ba	20 f1 a1	jsr $a1f1			jsr 	IF_CheckBreak 				; check CTL+C
.c2bd	d0 0b		bne $c2ca			bne 	_TIMSM_Ends 				; if pressed break out.
.c2bf	38		sec				sec 								; check past the end address in zTemp3
.c2c0	a5 14		lda $14				lda 	zTemp3
.c2c2	e5 12		sbc $12				sbc 	zTemp2
.c2c4	a5 15		lda $15				lda 	zTemp3+1
.c2c6	e5 13		sbc $13				sbc 	zTemp2+1
.c2c8	10 e2		bpl $c2ac			bpl 	_TIMSM_Start
.c2ca					_TIMSM_Ends:
.c2ca	4c 5a c2	jmp $c25a			jmp 	TIM_NewCommand
.c2cd					TIM_Execute:
.c2cd	20 88 c3	jsr $c388			jsr 	TIM_GetHex 					; get the execute address
.c2d0	b0 81		bcs $c253			bcs 	TIM_Error 					; not legitimate
.c2d2	ae a0 04	ldx $04a0			ldx 	TIM_SP 						; set up SP
.c2d5	9a		txs				txs
.c2d6	ad 9b 04	lda $049b			lda 	TIM_SR 						; Status for PLP
.c2d9	48		pha				pha
.c2da	ad 9c 04	lda $049c			lda 	TIM_A 						; restore AXYZ
.c2dd	ae 9d 04	ldx $049d			ldx 	TIM_X
.c2e0	ac 9e 04	ldy $049e			ldy 	TIM_Y
.c2e3	ab 9f 04	ldz $049f			ldz 	TIM_Z
.c2e6	28		plp				plp 								; and PS Byte.
.c2e7	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.c2ea					TIM_Start:
.c2ea					TIM_ShowRegisters:
.c2ea	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.c2ed	8d 9a 04	sta $049a			sta 	TIM_IRQ+1
.c2f0	ad ff ff	lda $ffff			lda 	$FFFF
.c2f3	8d 99 04	sta $0499			sta 	TIM_IRQ
.c2f6	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.c2f8					_TIMSR_Text:
.c2f8	bd 24 c3	lda $c324,x			lda 	_TIMSR_Label,x
.c2fb	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.c2fe	e8		inx				inx
.c2ff	e0 23		cpx #$23			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.c301	d0 f5		bne $c2f8			bne 	_TIMSR_Text
.c303	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.c305					_TIMSR_Skip:
.c305	e8		inx				inx
.c306					_TIMSR_LoopSpace:
.c306	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.c308	b0 04		bcs $c30e			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.c30a	8a		txa				txa
.c30b	4a		lsr a				lsr 	a
.c30c	b0 05		bcs $c313			bcs 	_TIMSR_NoSpace
.c30e					_TIMSR_Space:
.c30e	a9 20		lda #$20			lda 	#" "
.c310	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.c313					_TIMSR_NoSpace:
.c313	bd 97 04	lda $0497,x			lda 	TIM_PC,x 					; output hex value.
.c316	20 47 c3	jsr $c347			jsr 	TIM_WriteHex
.c319	e8		inx				inx
.c31a	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.c31c	d0 e8		bne $c306			bne 	_TimSR_LoopSpace
.c31e	20 68 a0	jsr $a068			jsr 	IFT_NewLine 				; new line
.c321	4c 5a c2	jmp $c25a			jmp	 	TIM_NewCommand 				; new command.
.c324					_TIMSR_Label:
>c324	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>c32c	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>c33c	52
>c33d	20 5a 52					.text 	" ZR"
>c340	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.c347					_TIMSR_LabelEnd:
.c347					TIM_WriteHex:
.c347	48		pha				pha 								; save A
.c348	4a		lsr a				lsr 	a 							; shift MSB->LSB
.c349	4a		lsr a				lsr 	a
.c34a	4a		lsr a				lsr 	a
.c34b	4a		lsr a				lsr 	a
.c34c	20 50 c3	jsr $c350			jsr 	_TIMWH_Nibble 				; print MSB
.c34f	68		pla				pla 								; restore and print LSB
.c350					_TIMWH_Nibble:
.c350	48		pha				pha
.c351	29 0f		and #$0f			and 	#15 						; mask out
.c353	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.c355	90 02		bcc $c359			bcc 	_TIMWHNoLetter
.c357	69 06		adc #$06			adc 	#6
.c359					_TIMWHNoLetter:
.c359	69 30		adc #$30			adc 	#48
.c35b	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter 			; print it out.
.c35e	68		pla				pla
.c35f	60		rts				rts
.c360					TIM_WriteLine:
.c360	a9 2e		lda #$2e			lda 	#"." 						; prompt
.c362	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.c365	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.c367	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.c36a	a5 13		lda $13				lda 	zTemp2+1 					; write address
.c36c	20 47 c3	jsr $c347			jsr 	TIM_WriteHex
.c36f	a5 12		lda $12				lda 	zTemp2
.c371	20 47 c3	jsr $c347			jsr 	TIM_WriteHex
.c374	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.c376					_TIMWL_Loop:
.c376	a9 20		lda #$20			lda 	#" "
.c378	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.c37b	b1 12		lda ($12),y			lda 	(zTemp2),y
.c37d	20 47 c3	jsr $c347			jsr 	TIM_WriteHex
.c380	c8		iny				iny
.c381	c0 10		cpy #$10			cpy 	#16
.c383	d0 f1		bne $c376			bne 	_TIMWL_Loop
.c385	4c 68 a0	jmp $a068			jmp 	IFT_NewLine 				; new line and exit
.c388					TIM_GetHex:
.c388	c8		iny				iny
.c389	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.c38b	c9 20		cmp #$20			cmp 	#32
.c38d	f0 f9		beq $c388			beq 	TIM_GetHex
.c38f	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.c391	f0 f5		beq $c388			beq 	TIM_GetHex
.c393	20 bc c3	jsr $c3bc			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.c396	b0 23		bcs $c3bb			bcs 	_TIMGH_Exit					; if first bad then exit now.
.c398	a9 00		lda #$00			lda 	#0 							; zero result
.c39a	85 14		sta $14				sta 	zTemp3
.c39c	85 15		sta $15				sta 	zTemp3+1
.c39e					_TIM_GHLoop:
.c39e	20 bc c3	jsr $c3bc			jsr 	TIM_GetHexCharacter 		; get next character
.c3a1	b0 17		bcs $c3ba			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.c3a3	c8		iny				iny 								; skip over it.
.c3a4	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.c3a6	26 15		rol $15				rol 	zTemp3+1
.c3a8	06 14		asl $14				asl 	zTemp3 						; now x 2
.c3aa	26 15		rol $15				rol 	zTemp3+1
.c3ac	06 14		asl $14				asl 	zTemp3						; now x 4
.c3ae	26 15		rol $15				rol 	zTemp3+1
.c3b0	06 14		asl $14				asl 	zTemp3 						; now x 8
.c3b2	26 15		rol $15				rol 	zTemp3+1
.c3b4	05 14		ora $14				ora 	zTemp3 						; OR result in
.c3b6	85 14		sta $14				sta 	zTemp3
.c3b8	80 e4		bra $c39e			bra 	_TIM_GHLoop 				; loop round again.
.c3ba					_TIMGH_Okay:
.c3ba	18		clc				clc
.c3bb					_TIMGH_Exit:
.c3bb	60		rts				rts
.c3bc					TIM_GetHexCharacter:
.c3bc	b1 10		lda ($10),y			lda 	(zTemp1),y
.c3be	38		sec				sec
.c3bf	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.c3c1	90 0e		bcc $c3d1			bcc 	_TIM_GHCFail
.c3c3	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.c3c5	90 0b		bcc $c3d2			bcc 	_TIM_GHCExit
.c3c7	c9 11		cmp #$11			cmp 	#65-48						; < A
.c3c9	90 06		bcc $c3d1			bcc		_TIM_GHCFail
.c3cb	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.c3cd	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.c3cf	90 01		bcc $c3d2			bcc		_TIM_GHCExit
.c3d1					_TIM_GHCFail:
.c3d1	38		sec				sec
.c3d2					_TIM_GHCExit:
.c3d2	60		rts				rts
.c3d3					TIM_BreakVector:
.c3d3	da		phx				phx									; save X/A on stack
.c3d4	48		pha				pha
.c3d5	ba		tsx				tsx 								; X points to S
.c3d6	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.c3d9	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.c3db	d0 03		bne $c3e0			bne 	_TIMBreak					; if set, it's BRK
.c3dd	68		pla				pla 								; abandon routine.
.c3de	fa		plx				plx
.c3df	40		rti				rti
.c3e0					_TIMBreak:
.c3e0	68		pla				pla 								; save A X Y and maybe Z
.c3e1	8d 9c 04	sta $049c			sta 	TIM_A
.c3e4	fa		plx				plx
.c3e5	8e 9d 04	stx $049d			stx 	TIM_X
.c3e8	8c 9e 04	sty $049e			sty 	TIM_Y
.c3eb	9c 9f 04	stz $049f			stz 	TIM_Z
.c3ee	68		pla				pla 								; get Status Register
.c3ef	8d 9b 04	sta $049b			sta 	TIM_SR
.c3f2	68		pla				pla
.c3f3	8d 98 04	sta $0498			sta 	TIM_PC+1 					; save calling address
.c3f6	68		pla				pla
.c3f7	8d 97 04	sta $0497			sta 	TIM_PC 						; high byte
.c3fa	ad 98 04	lda $0498			lda 	TIM_PC+1 					; dec PC to point right.
.c3fd	d0 03		bne $c402			bne 	_TIMDecrement 				; brk bumps it.
.c3ff	ce 97 04	dec $0497			dec 	TIM_PC
.c402					_TIMDecrement:
.c402	ce 98 04	dec $0498			dec 	TIM_PC+1
.c405	ba		tsx				tsx 								; and copy SP
.c406	8e a0 04	stx $04a0			stx 	TIM_SP
.c409	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.c40b	9a		txs				txs
.c40c	4c ea c2	jmp $c2ea			jmp 	TIM_Start 					; and start up TIM monitor.
.c40f					TIM_UpdateRegisters:
.c40f	20 88 c3	jsr $c388			jsr 	TIM_GetHex 					; PC
.c412	b0 23		bcs $c437			bcs 	_TIMURFail
.c414	a5 14		lda $14				lda 	zTemp3
.c416	8d 98 04	sta $0498			sta 	Tim_PC+1
.c419	a5 15		lda $15				lda 	zTemp3+1
.c41b	8d 97 04	sta $0497			sta 	Tim_PC
.c41e	20 88 c3	jsr $c388			jsr 	TIM_GetHex 					; ignore IRQ
.c421	b0 14		bcs $c437			bcs 	_TIMURFail
.c423	a2 00		ldx #$00			ldx 	#0
.c425					_TIM_URLoop:
.c425	20 88 c3	jsr $c388			jsr 	TIM_GetHex 					; registers
.c428	b0 0d		bcs $c437			bcs 	_TIMURFail
.c42a	a5 14		lda $14				lda 	zTemp3
.c42c	9d 9b 04	sta $049b,x			sta 	Tim_SR,x
.c42f	e8		inx				inx
.c430	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.c432	d0 f1		bne $c425			bne 	_TIM_URLoop
.c434	4c 5a c2	jmp $c25a			jmp 	TIM_NewCommand
.c437					_TIMURFail:
.c437	4c 53 c2	jmp $c253			jmp 	TIM_Error
.c43a					TIM_LoadMemory:
.c43a	20 88 c3	jsr $c388			jsr 	TIM_GetHex 					; target address => zTemp2
.c43d	a5 14		lda $14				lda 	zTemp3
.c43f	85 12		sta $12				sta 	zTemp2
.c441	a5 15		lda $15				lda 	zTemp3+1
.c443	85 13		sta $13				sta 	zTemp2+1
.c445					_TIM_LMLoop:
.c445	20 88 c3	jsr $c388			jsr 	TIM_GetHex 					; next byte ?
.c448	b0 0e		bcs $c458			bcs 	_TIMLMDone 					; no more
.c44a	a2 00		ldx #$00			ldx 	#0							; write out.
.c44c	a5 14		lda $14				lda 	zTemp3
.c44e	81 12		sta ($12,x)			sta 	(zTemp2,x)
.c450	e6 12		inc $12				inc 	zTemp2 						; bump address
.c452	d0 f1		bne $c445			bne 	_TIM_LMLoop
.c454	e6 13		inc $13				inc 	zTemp2+1
.c456	80 ed		bra $c445			bra 	_TIM_LMLoop
.c458					_TIMLMDone:
.c458	4c 5a c2	jmp $c25a			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Return to file: basic.asm

.c45b	80 fe		bra $c45b	_halt:	bra 		_halt
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 a0						.word 	StartROM
>fffe	d3 c3					.word TIM_BreakVector

;******  End of listing
