
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Sun Sep  1 16:37:56 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="65816"				cpu = "65816"
="em65816"				hardware = "em65816"
=1					exitonend = 1
=1					autorun = 1
=2					loadtest = 2
=1					hasfloat = 1
=1					hasinteger = 1
=253					maxstring = 253

;******  Processing file: modules/basic/pointer/em65816/src_em65816.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stackmarkers.inc

=5					SourcePosSize   =   5 							; Source position stack space needed.
=1					SMark_Gosub 	= 	1 							; 0 is GOSUB/RETURN.
=2					SMark_Repeat 	= 	2 							; 1 is REPEAT/UNTIL.
=3					SMark_While 	= 	3 							; 2 is WHILE/WEND.
=4					SMark_If 		= 	4 							; 3 is IF/ENDIF
=5					SMark_For 		= 	5 							; 4 is FOR/NEXT

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/hardware/common/macros32.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0020					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0022					zVarDataPtr: .word ? 						; position of variable data.
>0024					zVarType: 	.byte ? 						; type of data (token)
>0025					zNullString:.byte ? 						; represents a NULL string.
>0026					zBasicSP:	.word ? 						; stack pointer
>0080					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>0084					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>0085					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=134					XS2_Mantissa = XS_Mantissa+XS_Size
=138					XS2_Exponent = XS_Exponent+XS_Size
=139					XS2_Type = XS_Type+XS_Size
=140					XS3_Mantissa = XS_Mantissa+XS_Size*2
=144					XS3_Exponent = XS_Exponent+XS_Size*2
=145					XS3_Type = XS_Type+XS_Size*2
>0300					StringPtr:	.word ? 						; Top of free memory (for string allocation)
>0302					VarMemPtr: 	.word ?							; Bottom of free memory (for variables)
>0304					endOfProgram: .dword ? 						; End of Program Memory (long)
>0308					vecPrintCharacter .word ?
>030a					vecInputCharacter .word ?
>030c					UserVector .fill 4 							; USR(x) calls this.
>0310					LocalVector .fill 4 						; Indirect calls call this.
>0314					NumBufX 	.byte 	?						; buffer index position
>0315					Num_Buffer	.fill 	32 						; buffer for numeric conversions
=6					HashTableCount = 6 							; there are 6 hash tables, in token order.
=8					HashTableSize = 8 							; each hash table as 8 links.
.0335					HashTableBase:
>0335								.fill	HashTableCount * HashTableSize * 2
.0395					HashTableEnd:
=$315					Var_Buffer 	= Num_Buffer 					; buffer for variable name (same space)
>0395					Var_Type    .byte ? 						; type of variable (as a type token)
>0396					Var_Hash 	.byte ? 						; hash of identifier name.
>0397					Var_Length 	.byte ? 						; length of variable name
>0398					Var_HashAddress .byte ?						; low byte of hash table entry.
>0399					Var_DataSize .byte ?						; size of one element.
>039a					NumSuppress	.byte 	?						; leading zero suppression flag
>039b					NumConvCount .byte 	? 						; count for conversions.
>039c					ExpTemp:	.byte ?							; Working temp for exponents.
>039d					ExpCount:	.byte ? 						; Count of decimal exponents.
>039e					SignCount:	.byte ?							; Integer Divide Sign Counts.
>039f					TempStringWriteIndex: .byte ? 				; Write offset.
>03a0					ValSign: 	.byte ? 						; sign flag for val()
>03a1					SliceStart:	.byte ? 						; string slice parts
>03a2					SliceCount:	.byte ?
>03a3					RandomSeed:	.dword ? 						; Random seed.
>03a7					SignNext:	.byte ? 						; Used for keeping sign of STEP in FOR/NEXT
>03a8					BreakCount:	.byte ? 						; Counter, avoid checking break every command.
=3					ArrayMaxDim = 3 							; number of dimensions.
>03a9					ArrayDef:	.fill (ArrayMaxDim+1)*2 		; dimensions for auto-creation
>03b1					UsrArrayDef:.fill (ArrayMaxDim+1)*2 		; dimensions created in DIM
>03b9					UsrArrayIdx:.byte ? 						; index into UsrArrayDef
>03ba					LastPrinted:.byte ? 						; last printed char ?
>03bb					ListIndent: .byte ? 						; list indent level
>03bc					LastListIndent:.byte ? 						; previous one.
>03bd					DataLPtr: 	.dword ?						; the data long ptr (swapped with zCodePtr)
>03c1					DataIndex:	.byte ?							; index position.
>03c2					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>03c4					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>03c6					Tim_SR:		.byte ? 						; Processor Status
>03c7					Tim_A:		.byte ? 						; Processor Registers
>03c8					Tim_X:		.byte ?
>03c9					Tim_Y:		.byte ?
>03ca					Tim_Z:		.byte ?
>03cb					Tim_SP:		.word ?							; Stack Pointer (just in cases)
>0400					BasicStack:	.fill 	256 					; and occupy whole pages.
.0500					EndBasicStack:
>0500					IFT_XCursor:.byte ?							; current logical position on screen
>0501					IFT_YCursor:.byte ?
>0502					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0566					IFT_LineBuffer: .fill 100 					; line input buffer.

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/em65816.asm

=$7f00					HighMemory = $7F00
=$3000					VariableMemory = $3000
.1000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testing.src

>1000	23 0a 00 dc bd 8b 43 45			.byte	$23,$0a,$00,$dc,$bd,$8b,$43,$45
>1008	4c 6b fd 04 30 33 8a 41			.byte	$4c,$6b,$fd,$04,$30,$33,$8a,$41
>1010	6a 60 7f fd 04 32 36 be			.byte	$6a,$60,$7f,$fd,$04,$32,$36,$be
>1018	84 8b 41 5a 6b 6b fd 04			.byte	$84,$8b,$41,$5a,$6b,$6b,$fd,$04
>1020	37 37 00 14 14 00 dc bd			.byte	$37,$37,$00,$14,$14,$00,$dc,$bd
>1028	41 5a 54 57 85 8b 43 4c			.byte	$41,$5a,$54,$57,$85,$8b,$43,$4c
>1030	65 6b be 84 8b 41 00 0f			.byte	$65,$6b,$be,$84,$8b,$41,$00,$0f
>1038	1e 00 dc bd 40 80 8b 6f			.byte	$1e,$00,$dc,$bd,$40,$80,$8b,$6f
>1040	40 77 be 84 40 00 0a 28			.byte	$40,$77,$be,$84,$40,$00,$0a,$28
>1048	00 dc 9a 40 be 84 40 00			.byte	$00,$dc,$9a,$40,$be,$84,$40,$00
>1050	12 32 00 dc a0 fe 04 7a			.byte	$12,$32,$00,$dc,$a0,$fe,$04,$7a
>1058	66 bf 42 be 84 fe 04 7a			.byte	$66,$bf,$42,$be,$84,$fe,$04,$7a
>1060	66 00 16 3c 00 dc bd 47			.byte	$66,$00,$16,$3c,$00,$dc,$bd,$47
>1068	77 7a fd 05 33 39 38 84			.byte	$77,$7a,$fd,$05,$33,$39,$38,$84
>1070	40 fd 03 30 be 84 40 00			.byte	$40,$fd,$03,$30,$be,$84,$40,$00
>1078	10 46 00 dc bd 42 52 57			.byte	$10,$46,$00,$dc,$bd,$42,$52,$57
>1080	54 88 40 be 84 8b 41 00			.byte	$54,$88,$40,$be,$84,$8b,$41,$00
>1088	0f 50 00 dc bd 42 5c 7e			.byte	$0f,$50,$00,$dc,$bd,$42,$5c,$7e
>1090	42 80 40 be 84 40 00 0f			.byte	$42,$80,$40,$be,$84,$40,$00,$0f
>1098	5a 00 dc b3 8b 41 7a 42			.byte	$5a,$00,$dc,$b3,$8b,$41,$7a,$42
>10a0	59 be 84 8b 41 00 16 64			.byte	$59,$be,$84,$8b,$41,$00,$16,$64
>10a8	00 dc a1 fe 0a 6c 63 79			.byte	$00,$dc,$a1,$fe,$0a,$6c,$63,$79
>10b0	6c 64 70 70 6e bf 40 be			.byte	$6c,$64,$70,$70,$6e,$bf,$40,$be
>10b8	84 fe 02 00 22 6e 00 dc			.byte	$84,$fe,$02,$00,$22,$6e,$00,$dc
>10c0	bd 8b 41 50 63 40 fd 04			.byte	$bd,$8b,$41,$50,$63,$40,$fd,$04
>10c8	33 31 8a 8b 78 77 75 fd			.byte	$33,$31,$8a,$8b,$78,$77,$75,$fd
>10d0	04 38 39 be 84 8b 42 49			.byte	$04,$38,$39,$be,$84,$8b,$42,$49
>10d8	5a 76 fd 03 32 00 10 78			.byte	$5a,$76,$fd,$03,$32,$00,$10,$78
>10e0	00 dc bd 40 85 41 4a 7e			.byte	$00,$dc,$bd,$40,$85,$41,$4a,$7e
>10e8	52 be 84 8b 41 00 16 82			.byte	$52,$be,$84,$8b,$41,$00,$16,$82
>10f0	00 dc bd 42 66 6c 79 80			.byte	$00,$dc,$bd,$42,$66,$6c,$79,$80
>10f8	8b 41 47 43 57 be 84 42			.byte	$8b,$41,$47,$43,$57,$be,$84,$42
>1100	60 6c 69 00 13 8c 00 dc			.byte	$60,$6c,$69,$00,$13,$8c,$00,$dc
>1108	b2 69 65 46 bf 41 78 4b			.byte	$b2,$69,$65,$46,$bf,$41,$78,$4b
>1110	42 be 84 69 65 46 00 10			.byte	$42,$be,$84,$69,$65,$46,$00,$10
>1118	96 00 dc a2 fe 02 bf 41			.byte	$96,$00,$dc,$a2,$fe,$02,$bf,$41
>1120	bf 40 be 84 fe 02 00 1c			.byte	$bf,$40,$be,$84,$fe,$02,$00,$1c
>1128	a0 00 dc bd 8b 42 69 5d			.byte	$a0,$00,$dc,$bd,$8b,$42,$69,$5d
>1130	45 fd 04 33 31 89 8b 41			.byte	$45,$fd,$04,$33,$31,$89,$8b,$41
>1138	44 51 54 fd 04 34 36 be			.byte	$44,$51,$54,$fd,$04,$34,$36,$be
>1140	84 40 00 13 aa 00 dc bd			.byte	$84,$40,$00,$13,$aa,$00,$dc,$bd
>1148	8b 79 52 6f 86 41 7b 74			.byte	$8b,$79,$52,$6f,$86,$41,$7b,$74
>1150	7b be 84 8b 41 00 17 b4			.byte	$7b,$be,$84,$8b,$41,$00,$17,$b4
>1158	00 dc bd 8b 41 5d 73 66			.byte	$00,$dc,$bd,$8b,$41,$5d,$73,$66
>1160	82 8b 42 59 55 7f be 84			.byte	$82,$8b,$42,$59,$55,$7f,$be,$84
>1168	43 44 66 5b 00 10 be 00			.byte	$43,$44,$66,$5b,$00,$10,$be,$00
>1170	dc 98 8b 42 57 6a 4e 84			.byte	$dc,$98,$8b,$42,$57,$6a,$4e,$84
>1178	42 57 6a 4d 00 10 c8 00			.byte	$42,$57,$6a,$4d,$00,$10,$c8,$00
>1180	dc a6 fe 07 6c 75 6c 72			.byte	$dc,$a6,$fe,$07,$6c,$75,$6c,$72
>1188	72 be 84 45 00 1b d2 00			.byte	$72,$be,$84,$45,$00,$1b,$d2,$00
>1190	dc bd 8b 41 76 48 5c fd			.byte	$dc,$bd,$8b,$41,$76,$48,$5c,$fd
>1198	04 39 37 89 8b 6a 5c 56			.byte	$04,$39,$37,$89,$8b,$6a,$5c,$56
>11a0	fd 04 31 32 be 84 40 00			.byte	$fd,$04,$31,$32,$be,$84,$40,$00
>11a8	14 dc 00 dc bd 8b 42 79			.byte	$14,$dc,$00,$dc,$bd,$8b,$42,$79
>11b0	60 67 8d 8b 43 60 76 5f			.byte	$60,$67,$8d,$8b,$43,$60,$76,$5f
>11b8	be 84 40 00 14 e6 00 dc			.byte	$be,$84,$40,$00,$14,$e6,$00,$dc
>11c0	bd 41 5c 64 7a 82 41 50			.byte	$bd,$41,$5c,$64,$7a,$82,$41,$50
>11c8	40 60 be 84 4c 64 5a 00			.byte	$40,$60,$be,$84,$4c,$64,$5a,$00
>11d0	12 f0 00 dc a5 a4 43 68			.byte	$12,$f0,$00,$dc,$a5,$a4,$43,$68
>11d8	50 76 be be 84 43 68 50			.byte	$50,$76,$be,$be,$84,$43,$68,$50
>11e0	76 00 1b fa 00 dc bd 8b			.byte	$76,$00,$1b,$fa,$00,$dc,$bd,$8b
>11e8	42 54 7b 52 fd 04 33 32			.byte	$42,$54,$7b,$52,$fd,$04,$33,$32
>11f0	87 41 56 5a 52 fd 03 38			.byte	$87,$41,$56,$5a,$52,$fd,$03,$38
>11f8	be 84 8b 41 00 16 04 01			.byte	$be,$84,$8b,$41,$00,$16,$04,$01
>1200	dc bd 8b 41 50 4a 8c 8b			.byte	$dc,$bd,$8b,$41,$50,$4a,$8c,$8b
>1208	64 67 45 be 84 6d 76 64			.byte	$64,$67,$45,$be,$84,$6d,$76,$64
>1210	56 72 00 12 0e 01 dc bd			.byte	$56,$72,$00,$12,$0e,$01,$dc,$bd
>1218	8b 6b 5a 69 81 40 be 84			.byte	$8b,$6b,$5a,$69,$81,$40,$be,$84
>1220	8b 6b 5a 69 00 11 18 01			.byte	$8b,$6b,$5a,$69,$00,$11,$18,$01
>1228	dc 9a 8b 43 5f 6a 51 be			.byte	$dc,$9a,$8b,$43,$5f,$6a,$51,$be
>1230	84 43 5f 6a 51 00 0c 22			.byte	$84,$43,$5f,$6a,$51,$00,$0c,$22
>1238	01 dc b4 7c be 84 fe 03			.byte	$01,$dc,$b4,$7c,$be,$84,$fe,$03
>1240	3c 00 1a 2c 01 dc bd 42			.byte	$3c,$00,$1a,$2c,$01,$dc,$bd,$42
>1248	7f 6c 7e fd 04 33 35 88			.byte	$7f,$6c,$7e,$fd,$04,$33,$35,$88
>1250	42 7f 6c 7e fd 04 33 35			.byte	$42,$7f,$6c,$7e,$fd,$04,$33,$35
>1258	be 84 40 00 16 36 01 dc			.byte	$be,$84,$40,$00,$16,$36,$01,$dc
>1260	bd 8b 43 6e 4f 47 8b 5c			.byte	$bd,$8b,$43,$6e,$4f,$47,$8b,$5c
>1268	62 69 be 84 8b 44 4a 71			.byte	$62,$69,$be,$84,$8b,$44,$4a,$71
>1270	70 00 17 40 01 dc bd 8b			.byte	$70,$00,$17,$40,$01,$dc,$bd,$8b
>1278	42 5d 4a 48 81 8b 41 6f			.byte	$42,$5d,$4a,$48,$81,$8b,$41,$6f
>1280	79 70 be 84 8b 4d 48 48			.byte	$79,$70,$be,$84,$8b,$4d,$48,$48
>1288	00 0f 4a 01 dc b3 8b 42			.byte	$00,$0f,$4a,$01,$dc,$b3,$8b,$42
>1290	7a 53 44 be 84 8b 41 00			.byte	$7a,$53,$44,$be,$84,$8b,$41,$00
>1298	12 54 01 dc a3 47 be 84			.byte	$12,$54,$01,$dc,$a3,$47,$be,$84
>12a0	fe 09 20 20 20 20 20 20			.byte	$fe,$09,$20,$20,$20,$20,$20,$20
>12a8	20 00 1c 5e 01 dc bd 41			.byte	$20,$00,$1c,$5e,$01,$dc,$bd,$41
>12b0	45 5c 5e fd 04 39 35 85			.byte	$45,$5c,$5e,$fd,$04,$39,$35,$85
>12b8	8b 4e 49 45 fd 05 35 39			.byte	$8b,$4e,$49,$45,$fd,$05,$35,$39
>12c0	33 be 84 8b 41 00 15 68			.byte	$33,$be,$84,$8b,$41,$00,$15,$68
>12c8	01 dc bd 8b 4d 51 52 8a			.byte	$01,$dc,$bd,$8b,$4d,$51,$52,$8a
>12d0	41 50 61 59 be 84 41 43			.byte	$41,$50,$61,$59,$be,$84,$41,$43
>12d8	50 47 00 15 72 01 dc bd			.byte	$50,$47,$00,$15,$72,$01,$dc,$bd
>12e0	8b 42 48 59 80 42 43 62			.byte	$8b,$42,$48,$59,$80,$42,$43,$62
>12e8	60 be 84 42 41 62 60 00			.byte	$60,$be,$84,$42,$41,$62,$60,$00
>12f0	17 7c 01 dc b2 8b 42 70			.byte	$17,$7c,$01,$dc,$b2,$8b,$42,$70
>12f8	65 67 bf 8b 43 40 46 68			.byte	$65,$67,$bf,$8b,$43,$40,$46,$68
>1300	be 84 42 70 65 67 00 13			.byte	$be,$84,$42,$70,$65,$67,$00,$13
>1308	86 01 dc a7 43 4f 4d 6f			.byte	$86,$01,$dc,$a7,$43,$4f,$4d,$6f
>1310	be 84 fe 07 43 46 33 36			.byte	$be,$84,$fe,$07,$43,$46,$33,$36
>1318	46 00 17 90 01 dc bd 40			.byte	$46,$00,$17,$90,$01,$dc,$bd,$40
>1320	fd 03 30 86 8b 43 6a 7d			.byte	$fd,$03,$30,$86,$8b,$43,$6a,$7d
>1328	4c fd 04 38 38 be 84 40			.byte	$4c,$fd,$04,$38,$38,$be,$84,$40
>1330	00 13 9a 01 dc bd 43 44			.byte	$00,$13,$9a,$01,$dc,$bd,$43,$44
>1338	5c 7d 85 42 51 73 73 be			.byte	$5c,$7d,$85,$42,$51,$73,$73,$be
>1340	84 8b 41 00 18 a4 01 dc			.byte	$84,$8b,$41,$00,$18,$a4,$01,$dc
>1348	bd 8b 42 46 46 4e 81 8b			.byte	$bd,$8b,$42,$46,$46,$4e,$81,$8b
>1350	42 53 7e 5e be 84 8b 42			.byte	$42,$53,$7e,$5e,$be,$84,$8b,$42
>1358	42 46 4e 00 10 ae 01 dc			.byte	$42,$46,$4e,$00,$10,$ae,$01,$dc
>1360	98 41 41 43 6e 84 8b 41			.byte	$98,$41,$41,$43,$6e,$84,$8b,$41
>1368	41 43 6f 00 13 b8 01 dc			.byte	$41,$43,$6f,$00,$13,$b8,$01,$dc
>1370	af fe 07 44 39 31 32 44			.byte	$af,$fe,$07,$44,$39,$31,$32,$44
>1378	be 84 43 59 44 6d 00 18			.byte	$be,$84,$43,$59,$44,$6d,$00,$18
>1380	c2 01 dc bd 40 fd 03 30			.byte	$c2,$01,$dc,$bd,$40,$fd,$03,$30
>1388	89 8b 42 47 5a 55 fd 04			.byte	$89,$8b,$42,$47,$5a,$55,$fd,$04
>1390	30 31 be 84 8b 41 00 13			.byte	$30,$31,$be,$84,$8b,$41,$00,$13
>1398	cc 01 dc bd 7a 41 61 88			.byte	$cc,$01,$dc,$bd,$7a,$41,$61,$88
>13a0	8b 43 6d 54 59 be 84 8b			.byte	$8b,$43,$6d,$54,$59,$be,$84,$8b
>13a8	41 00 12 d6 01 dc bd 42			.byte	$41,$00,$12,$d6,$01,$dc,$bd,$42
>13b0	53 53 51 81 40 be 84 42			.byte	$53,$53,$51,$81,$40,$be,$84,$42
>13b8	53 53 51 00 14 e0 01 dc			.byte	$53,$53,$51,$00,$14,$e0,$01,$dc
>13c0	a5 a4 8b 43 70 40 42 be			.byte	$a5,$a4,$8b,$43,$70,$40,$42,$be
>13c8	be 84 8b 43 70 40 42 00			.byte	$be,$84,$8b,$43,$70,$40,$42,$00
>13d0	16 ea 01 dc a0 fe 09 73			.byte	$16,$ea,$01,$dc,$a0,$fe,$09,$73
>13d8	65 7a 78 64 69 6f bf 41			.byte	$65,$7a,$78,$64,$69,$6f,$bf,$41
>13e0	be 84 fe 03 73 00 20 f4			.byte	$be,$84,$fe,$03,$73,$00,$20,$f4
>13e8	01 dc bd 8b 68 67 71 fd			.byte	$01,$dc,$bd,$8b,$68,$67,$71,$fd
>13f0	04 31 33 8a 41 4d 4b 7f			.byte	$04,$31,$33,$8a,$41,$4d,$4b,$7f
>13f8	fd 04 32 38 be 84 64 64			.byte	$fd,$04,$32,$38,$be,$84,$64,$64
>1400	4e fd 04 31 35 00 10 fe			.byte	$4e,$fd,$04,$31,$35,$00,$10,$fe
>1408	01 dc bd 8b 41 5b 4b 5d			.byte	$01,$dc,$bd,$8b,$41,$5b,$4b,$5d
>1410	8c 40 be 84 40 00 16 08			.byte	$8c,$40,$be,$84,$40,$00,$16,$08
>1418	02 dc bd 8b 43 42 46 71			.byte	$02,$dc,$bd,$8b,$43,$42,$46,$71
>1420	82 8b 4e 54 59 be 84 43			.byte	$82,$8b,$4e,$54,$59,$be,$84,$43
>1428	4c 52 68 00 10 12 02 dc			.byte	$4c,$52,$68,$00,$10,$12,$02,$dc
>1430	9a 41 4b 44 50 be 84 41			.byte	$9a,$41,$4b,$44,$50,$be,$84,$41
>1438	4b 44 50 00 14 1c 02 dc			.byte	$4b,$44,$50,$00,$14,$1c,$02,$dc
>1440	a1 fe 05 62 66 79 bf 48			.byte	$a1,$fe,$05,$62,$66,$79,$bf,$48
>1448	be 84 fe 05 62 66 79 00			.byte	$be,$84,$fe,$05,$62,$66,$79,$00
>1450	23 26 02 dc bd 8b 43 4c			.byte	$23,$26,$02,$dc,$bd,$8b,$43,$4c
>1458	72 49 fd 04 30 36 8a 8b			.byte	$72,$49,$fd,$04,$30,$36,$8a,$8b
>1460	42 4e 61 6f fd 04 33 36			.byte	$42,$4e,$61,$6f,$fd,$04,$33,$36
>1468	be 84 8b 45 5b 53 78 fd			.byte	$be,$84,$8b,$45,$5b,$53,$78,$fd
>1470	03 34 00 10 30 02 dc bd			.byte	$03,$34,$00,$10,$30,$02,$dc,$bd
>1478	40 84 8b 41 74 5f 56 be			.byte	$40,$84,$8b,$41,$74,$5f,$56,$be
>1480	84 40 00 16 3a 02 dc bd			.byte	$84,$40,$00,$16,$3a,$02,$dc,$bd
>1488	41 7a 62 81 8b 43 5c 41			.byte	$41,$7a,$62,$81,$8b,$43,$5c,$41
>1490	63 be 84 8b 43 5c 41 41			.byte	$63,$be,$84,$8b,$43,$5c,$41,$41
>1498	00 0c 44 02 dc b3 60 6c			.byte	$00,$0c,$44,$02,$dc,$b3,$60,$6c
>14a0	7f be 84 41 00 1e 4e 02			.byte	$7f,$be,$84,$41,$00,$1e,$4e,$02
>14a8	dc a2 fe 0c 6e 62 72 65			.byte	$dc,$a2,$fe,$0c,$6e,$62,$72,$65
>14b0	76 69 70 6b 75 73 bf 43			.byte	$76,$69,$70,$6b,$75,$73,$bf,$43
>14b8	bf 44 be 84 fe 06 72 65			.byte	$bf,$44,$be,$84,$fe,$06,$72,$65
>14c0	76 69 00 1c 58 02 dc bd			.byte	$76,$69,$00,$1c,$58,$02,$dc,$bd
>14c8	43 5e 47 5a fd 04 33 38			.byte	$43,$5e,$47,$5a,$fd,$04,$33,$38
>14d0	85 8b 42 5e 7e 79 fd 04			.byte	$85,$8b,$42,$5e,$7e,$79,$fd,$04
>14d8	33 33 be 84 8b 41 00 15			.byte	$33,$33,$be,$84,$8b,$41,$00,$15
>14e0	62 02 dc bd 8b 42 45 6f			.byte	$62,$02,$dc,$bd,$8b,$42,$45,$6f
>14e8	7b 89 8b 42 45 6f 7b be			.byte	$7b,$89,$8b,$42,$45,$6f,$7b,$be
>14f0	84 8b 41 00 14 6c 02 dc			.byte	$84,$8b,$41,$00,$14,$6c,$02,$dc
>14f8	bd 42 5e 6d 7d 81 76 49			.byte	$bd,$42,$5e,$6d,$7d,$81,$76,$49
>1500	5e be 84 42 7e 6d 7f 00			.byte	$5e,$be,$84,$42,$7e,$6d,$7f,$00
>1508	15 76 02 dc b2 41 69 6f			.byte	$15,$76,$02,$dc,$b2,$41,$69,$6f
>1510	7c bf 8b 41 4e 5f 62 be			.byte	$7c,$bf,$8b,$41,$4e,$5f,$62,$be
>1518	84 5b 50 5a 00 13 80 02			.byte	$84,$5b,$50,$5a,$00,$13,$80,$02
>1520	dc a6 fe 0a 70 78 78 6e			.byte	$dc,$a6,$fe,$0a,$70,$78,$78,$6e
>1528	71 70 74 70 be 84 48 00			.byte	$71,$70,$74,$70,$be,$84,$48,$00
>1530	16 8a 02 dc bd 40 fd 03			.byte	$16,$8a,$02,$dc,$bd,$40,$fd,$03
>1538	30 84 8b 7b 64 5d fd 04			.byte	$30,$84,$8b,$7b,$64,$5d,$fd,$04
>1540	33 35 be 84 40 00 12 94			.byte	$33,$35,$be,$84,$40,$00,$12,$94
>1548	02 dc bd 42 7b 79 50 86			.byte	$02,$dc,$bd,$42,$7b,$79,$50,$86
>1550	8b 63 63 47 be 84 40 00			.byte	$8b,$63,$63,$47,$be,$84,$40,$00
>1558	10 9e 02 dc bd 40 80 8b			.byte	$10,$9e,$02,$dc,$bd,$40,$80,$8b
>1560	42 57 7f 46 be 84 40 00			.byte	$42,$57,$7f,$46,$be,$84,$40,$00
>1568	10 a8 02 dc 98 8b 42 68			.byte	$10,$a8,$02,$dc,$98,$8b,$42,$68
>1570	6a 61 84 42 68 6a 60 00			.byte	$6a,$61,$84,$42,$68,$6a,$60,$00
>1578	0d b2 02 dc 9b fe 03 63			.byte	$0d,$b2,$02,$dc,$9b,$fe,$03,$63
>1580	be 84 41 63 00 29 bc 02			.byte	$be,$84,$41,$63,$00,$29,$bc,$02
>1588	dc bd 8b 41 41 5a 60 fd			.byte	$dc,$bd,$8b,$41,$41,$5a,$60,$fd
>1590	04 38 39 8c 41 7f 61 65			.byte	$04,$38,$39,$8c,$41,$7f,$61,$65
>1598	fd 04 38 37 be 84 8b 41			.byte	$fd,$04,$38,$37,$be,$84,$8b,$41
>15a0	fd 0d 33 39 39 35 34 36			.byte	$fd,$0d,$33,$39,$39,$35,$34,$36
>15a8	35 37 65 31 31 00 12 c6			.byte	$35,$37,$65,$31,$31,$00,$12,$c6
>15b0	02 dc bd 42 6f 4b 7a 85			.byte	$02,$dc,$bd,$42,$6f,$4b,$7a,$85
>15b8	46 5f 5a be 84 8b 41 00			.byte	$46,$5f,$5a,$be,$84,$8b,$41,$00
>15c0	15 d0 02 dc bd 43 47 4c			.byte	$15,$d0,$02,$dc,$bd,$43,$47,$4c
>15c8	49 80 8b 55 5f 64 be 84			.byte	$49,$80,$8b,$55,$5f,$64,$be,$84
>15d0	43 42 40 48 00 12 da 02			.byte	$43,$42,$40,$48,$00,$12,$da,$02
>15d8	dc a5 a4 40 fd 03 30 be			.byte	$dc,$a5,$a4,$40,$fd,$03,$30,$be
>15e0	be 84 40 fd 03 30 00 0d			.byte	$be,$84,$40,$fd,$03,$30,$00,$0d
>15e8	e4 02 dc b4 41 49 be 84			.byte	$e4,$02,$dc,$b4,$41,$49,$be,$84
>15f0	fe 03 49 00 1b ee 02 dc			.byte	$fe,$03,$49,$00,$1b,$ee,$02,$dc
>15f8	bd 8b 6f 7f 48 fd 04 39			.byte	$bd,$8b,$6f,$7f,$48,$fd,$04,$39
>1600	35 87 42 73 4f 6c fd 04			.byte	$35,$87,$42,$73,$4f,$6c,$fd,$04
>1608	39 33 be 84 8b 41 00 12			.byte	$39,$33,$be,$84,$8b,$41,$00,$12
>1610	f8 02 dc bd 43 44 55 68			.byte	$f8,$02,$dc,$bd,$43,$44,$55,$68
>1618	8b 40 be 84 43 44 55 68			.byte	$8b,$40,$be,$84,$43,$44,$55,$68
>1620	00 12 02 03 dc bd 63 6f			.byte	$00,$12,$02,$03,$dc,$bd,$63,$6f
>1628	4d 80 43 50 51 74 be 84			.byte	$4d,$80,$43,$50,$51,$74,$be,$84
>1630	41 44 00 0a 0c 03 dc 9a			.byte	$41,$44,$00,$0a,$0c,$03,$dc,$9a
>1638	40 be 84 40 00 1c 16 03			.byte	$40,$be,$84,$40,$00,$1c,$16,$03
>1640	dc a3 51 be 84 fe 13 20			.byte	$dc,$a3,$51,$be,$84,$fe,$13,$20
>1648	20 20 20 20 20 20 20 20			.byte	$20,$20,$20,$20,$20,$20,$20,$20
>1650	20 20 20 20 20 20 20 20			.byte	$20,$20,$20,$20,$20,$20,$20,$20
>1658	00 19 20 03 dc bd 69 6a			.byte	$00,$19,$20,$03,$dc,$bd,$69,$6a
>1660	7a fd 04 35 34 87 42 74			.byte	$7a,$fd,$04,$35,$34,$87,$42,$74
>1668	7e 69 fd 03 31 be 84 8b			.byte	$7e,$69,$fd,$03,$31,$be,$84,$8b
>1670	41 00 12 2a 03 dc bd 41			.byte	$41,$00,$12,$2a,$03,$dc,$bd,$41
>1678	53 58 70 89 7d 7f 63 be			.byte	$53,$58,$70,$89,$7d,$7f,$63,$be
>1680	84 8b 41 00 16 34 03 dc			.byte	$84,$8b,$41,$00,$16,$34,$03,$dc
>1688	bd 8b 79 67 57 82 41 79			.byte	$bd,$8b,$79,$67,$57,$82,$41,$79
>1690	44 56 be 84 8b 41 40 63			.byte	$44,$56,$be,$84,$8b,$41,$40,$63
>1698	41 00 0d 3e 03 dc b3 41			.byte	$41,$00,$0d,$3e,$03,$dc,$b3,$41
>16a0	6b 61 55 be 84 41 00 13			.byte	$6b,$61,$55,$be,$84,$41,$00,$13
>16a8	48 03 dc a7 42 5d 44 63			.byte	$48,$03,$dc,$a7,$42,$5d,$44,$63
>16b0	be 84 fe 07 39 44 31 32			.byte	$be,$84,$fe,$07,$39,$44,$31,$32
>16b8	33 00 1c 52 03 dc bd 8b			.byte	$33,$00,$1c,$52,$03,$dc,$bd,$8b
>16c0	43 4a 73 5c fd 04 34 32			.byte	$43,$4a,$73,$5c,$fd,$04,$34,$32
>16c8	88 8b 42 71 75 7a fd 04			.byte	$88,$8b,$42,$71,$75,$7a,$fd,$04
>16d0	35 37 be 84 40 00 13 5c			.byte	$35,$37,$be,$84,$40,$00,$13,$5c
>16d8	03 dc bd 42 5a 6a 59 89			.byte	$03,$dc,$bd,$42,$5a,$6a,$59,$89
>16e0	8b 6a 7c 72 be 84 8b 41			.byte	$8b,$6a,$7c,$72,$be,$84,$8b,$41
>16e8	00 18 66 03 dc bd 8b 41			.byte	$00,$18,$66,$03,$dc,$bd,$8b,$41
>16f0	41 6e 48 81 8b 41 5c 6c			.byte	$41,$6e,$48,$81,$8b,$41,$5c,$6c
>16f8	41 be 84 8b 41 40 6c 41			.byte	$41,$be,$84,$8b,$41,$40,$6c,$41
>1700	00 13 70 03 dc af fe 07			.byte	$00,$13,$70,$03,$dc,$af,$fe,$07
>1708	34 32 45 45 31 be 84 41			.byte	$34,$32,$45,$45,$31,$be,$84,$41
>1710	42 7b 61 00 1b 7a 03 dc			.byte	$42,$7b,$61,$00,$1b,$7a,$03,$dc
>1718	bd 43 68 52 6a fd 04 37			.byte	$bd,$43,$68,$52,$6a,$fd,$04,$37
>1720	33 88 8b 43 50 43 57 fd			.byte	$33,$88,$8b,$43,$50,$43,$57,$fd
>1728	03 38 be 84 8b 41 00 13			.byte	$03,$38,$be,$84,$8b,$41,$00,$13
>1730	84 03 dc bd 8b 41 5a 74			.byte	$84,$03,$dc,$bd,$8b,$41,$5a,$74
>1738	7b 8d 8b 49 56 45 be 84			.byte	$7b,$8d,$8b,$49,$56,$45,$be,$84
>1740	49 00 0f 8e 03 dc bd 41			.byte	$49,$00,$0f,$8e,$03,$dc,$bd,$41
>1748	7a 57 4f 80 40 be 84 40			.byte	$7a,$57,$4f,$80,$40,$be,$84,$40
>1750	00 10 98 03 dc 98 8b 41			.byte	$00,$10,$98,$03,$dc,$98,$8b,$41
>1758	73 44 54 84 41 73 44 53			.byte	$73,$44,$54,$84,$41,$73,$44,$53
>1760	00 10 a2 03 dc a0 fe 03			.byte	$00,$10,$a2,$03,$dc,$a0,$fe,$03
>1768	6e bf 41 be 84 fe 03 6e			.byte	$6e,$bf,$41,$be,$84,$fe,$03,$6e
>1770	00 1a ac 03 dc bd 8b 43			.byte	$00,$1a,$ac,$03,$dc,$bd,$8b,$43
>1778	58 5c 47 fd 04 34 37 89			.byte	$58,$5c,$47,$fd,$04,$34,$37,$89
>1780	41 44 7b 5e fd 03 34 be			.byte	$41,$44,$7b,$5e,$fd,$03,$34,$be
>1788	84 40 00 0f b6 03 dc bd			.byte	$84,$40,$00,$0f,$b6,$03,$dc,$bd
>1790	42 58 53 7e 87 40 be 84			.byte	$42,$58,$53,$7e,$87,$40,$be,$84
>1798	40 00 16 c0 03 dc bd 5c			.byte	$40,$00,$16,$c0,$03,$dc,$bd,$5c
>17a0	79 75 81 8b 42 6d 4d 70			.byte	$79,$75,$81,$8b,$42,$6d,$4d,$70
>17a8	be 84 8b 42 61 44 4b 00			.byte	$be,$84,$8b,$42,$61,$44,$4b,$00
>17b0	1a ca 03 dc a5 a4 43 49			.byte	$1a,$ca,$03,$dc,$a5,$a4,$43,$49
>17b8	4d 5e fd 04 31 38 be be			.byte	$4d,$5e,$fd,$04,$31,$38,$be,$be
>17c0	84 43 49 4d 5e fd 04 31			.byte	$84,$43,$49,$4d,$5e,$fd,$04,$31
>17c8	38 00 10 d4 03 dc a1 fe			.byte	$38,$00,$10,$d4,$03,$dc,$a1,$fe
>17d0	03 78 bf 44 be 84 fe 03			.byte	$03,$78,$bf,$44,$be,$84,$fe,$03
>17d8	78 00 1c de 03 dc bd 8b			.byte	$78,$00,$1c,$de,$03,$dc,$bd,$8b
>17e0	5e 59 69 fd 04 30 38 88			.byte	$5e,$59,$69,$fd,$04,$30,$38,$88
>17e8	8b 41 49 71 65 fd 04 30			.byte	$8b,$41,$49,$71,$65,$fd,$04,$30
>17f0	37 be 84 8b 41 00 12 e8			.byte	$37,$be,$84,$8b,$41,$00,$12,$e8
>17f8	03 dc bd 40 8a 8b 6f 6c			.byte	$03,$dc,$bd,$40,$8a,$8b,$6f,$6c
>1800	71 be 84 8b 6f 6c 71 00			.byte	$71,$be,$84,$8b,$6f,$6c,$71,$00
>1808	14 f2 03 dc bd 8b 42 66			.byte	$14,$f2,$03,$dc,$bd,$8b,$42,$66
>1810	75 62 81 40 be 84 8b 42			.byte	$75,$62,$81,$40,$be,$84,$8b,$42
>1818	66 75 62 00 11 fc 03 dc			.byte	$66,$75,$62,$00,$11,$fc,$03,$dc
>1820	9a 8b 42 70 5d 7d be 84			.byte	$9a,$8b,$42,$70,$5d,$7d,$be,$84
>1828	42 70 5d 7d 00 1e 06 04			.byte	$42,$70,$5d,$7d,$00,$1e,$06,$04
>1830	dc a2 fe 0b 66 76 7a 67			.byte	$dc,$a2,$fe,$0b,$66,$76,$7a,$67
>1838	69 61 68 61 75 bf 43 bf			.byte	$69,$61,$68,$61,$75,$bf,$43,$bf
>1840	45 be 84 fe 07 7a 67 69			.byte	$45,$be,$84,$fe,$07,$7a,$67,$69
>1848	61 68 00 1b 10 04 dc bd			.byte	$61,$68,$00,$1b,$10,$04,$dc,$bd
>1850	6a 56 63 fd 04 30 32 85			.byte	$6a,$56,$63,$fd,$04,$30,$32,$85
>1858	8b 41 54 4a 5b fd 04 37			.byte	$8b,$41,$54,$4a,$5b,$fd,$04,$37
>1860	34 be 84 8b 41 00 13 1a			.byte	$34,$be,$84,$8b,$41,$00,$13,$1a
>1868	04 dc bd 43 62 54 4b 86			.byte	$04,$dc,$bd,$43,$62,$54,$4b,$86
>1870	8b 43 47 62 41 be 84 40			.byte	$8b,$43,$47,$62,$41,$be,$84,$40
>1878	00 16 24 04 dc bd 54 45			.byte	$00,$16,$24,$04,$dc,$bd,$54,$45
>1880	4b 82 8b 41 51 4f 67 be			.byte	$4b,$82,$8b,$41,$51,$4f,$67,$be
>1888	84 8b 41 45 4a 6e 00 0e			.byte	$84,$8b,$41,$45,$4a,$6e,$00,$0e
>1890	2e 04 dc b3 8b 4a 6c 6d			.byte	$2e,$04,$dc,$b3,$8b,$4a,$6c,$6d
>1898	be 84 8b 41 00 11 38 04			.byte	$be,$84,$8b,$41,$00,$11,$38,$04
>18a0	dc a6 fe 08 62 6a 70 6a			.byte	$dc,$a6,$fe,$08,$62,$6a,$70,$6a
>18a8	75 62 be 84 46 00 1c 42			.byte	$75,$62,$be,$84,$46,$00,$1c,$42
>18b0	04 dc bd 8b 42 53 6b 4c			.byte	$04,$dc,$bd,$8b,$42,$53,$6b,$4c
>18b8	fd 04 33 39 89 8b 49 57			.byte	$fd,$04,$33,$39,$89,$8b,$49,$57
>18c0	6e fd 05 35 35 33 be 84			.byte	$6e,$fd,$05,$35,$35,$33,$be,$84
>18c8	40 00 10 4c 04 dc bd 8b			.byte	$40,$00,$10,$4c,$04,$dc,$bd,$8b
>18d0	43 43 5a 66 84 40 be 84			.byte	$43,$43,$5a,$66,$84,$40,$be,$84
>18d8	40 00 13 56 04 dc bd 56			.byte	$40,$00,$13,$56,$04,$dc,$bd,$56
>18e0	64 77 80 43 6d 7d 5c be			.byte	$64,$77,$80,$43,$6d,$7d,$5c,$be
>18e8	84 44 64 54 00 16 60 04			.byte	$84,$44,$64,$54,$00,$16,$60,$04
>18f0	dc b2 41 64 53 75 bf 8b			.byte	$dc,$b2,$41,$64,$53,$75,$bf,$8b
>18f8	43 49 6b 42 be 84 41 64			.byte	$43,$49,$6b,$42,$be,$84,$41,$64
>1900	53 75 00 0d 6a 04 dc 9b			.byte	$53,$75,$00,$0d,$6a,$04,$dc,$9b
>1908	fe 03 79 be 84 41 79 00			.byte	$fe,$03,$79,$be,$84,$41,$79,$00
>1910	1b 74 04 dc bd 73 66 73			.byte	$1b,$74,$04,$dc,$bd,$73,$66,$73
>1918	fd 04 39 38 88 8b 4e 66			.byte	$fd,$04,$39,$38,$88,$8b,$4e,$66
>1920	60 fd 05 31 38 36 be 84			.byte	$60,$fd,$05,$31,$38,$36,$be,$84
>1928	8b 41 00 17 7e 04 dc bd			.byte	$8b,$41,$00,$17,$7e,$04,$dc,$bd
>1930	8b 42 7c 61 4e 8a 8b 43			.byte	$8b,$42,$7c,$61,$4e,$8a,$8b,$43
>1938	46 62 be 84 8b 42 7f 67			.byte	$46,$62,$be,$84,$8b,$42,$7f,$67
>1940	70 00 13 88 04 dc bd 50			.byte	$70,$00,$13,$88,$04,$dc,$bd,$50
>1948	42 7c 80 8b 6d 4e 5a be			.byte	$42,$7c,$80,$8b,$6d,$4e,$5a,$be
>1950	84 50 40 64 00 0a 92 04			.byte	$84,$50,$40,$64,$00,$0a,$92,$04
>1958	dc 98 40 84 8b 41 00 0d			.byte	$dc,$98,$40,$84,$8b,$41,$00,$0d
>1960	9c 04 dc b4 41 7a be 84			.byte	$9c,$04,$dc,$b4,$41,$7a,$be,$84
>1968	fe 03 7a 00 22 a6 04 dc			.byte	$fe,$03,$7a,$00,$22,$a6,$04,$dc
>1970	bd 41 52 5a 5f fd 04 37			.byte	$bd,$41,$52,$5a,$5f,$fd,$04,$37
>1978	37 8b 43 46 7d 6f fd 04			.byte	$37,$8b,$43,$46,$7d,$6f,$fd,$04
>1980	36 32 be 84 8b 41 74 63			.byte	$36,$32,$be,$84,$8b,$41,$74,$63
>1988	4f fd 04 38 35 00 12 b0			.byte	$4f,$fd,$04,$38,$35,$00,$12,$b0
>1990	04 dc bd 79 7d 42 87 8b			.byte	$04,$dc,$bd,$79,$7d,$42,$87,$8b
>1998	43 4e 5f 42 be 84 40 00			.byte	$43,$4e,$5f,$42,$be,$84,$40,$00
>19a0	18 ba 04 dc bd 8b 41 51			.byte	$18,$ba,$04,$dc,$bd,$8b,$41,$51
>19a8	65 6b 81 8b 41 7b 4a 56			.byte	$65,$6b,$81,$8b,$41,$7b,$4a,$56
>19b0	be 84 8b 41 51 40 41 00			.byte	$be,$84,$8b,$41,$51,$40,$41,$00
>19b8	1c c4 04 dc a5 a4 8b 42			.byte	$1c,$c4,$04,$dc,$a5,$a4,$8b,$42
>19c0	50 56 74 fd 04 34 34 be			.byte	$50,$56,$74,$fd,$04,$34,$34,$be
>19c8	be 84 8b 42 50 56 74 fd			.byte	$be,$84,$8b,$42,$50,$56,$74,$fd
>19d0	04 34 34 00 0d ce 04 dc			.byte	$04,$34,$34,$00,$0d,$ce,$04,$dc
>19d8	a3 42 be 84 fe 04 20 20			.byte	$a3,$42,$be,$84,$fe,$04,$20,$20
>19e0	00 21 d8 04 dc bd 8b 78			.byte	$00,$21,$d8,$04,$dc,$bd,$8b,$78
>19e8	6b 40 fd 04 30 32 8b 8b			.byte	$6b,$40,$fd,$04,$30,$32,$8b,$8b
>19f0	41 61 7e 7c fd 04 31 36			.byte	$41,$61,$7e,$7c,$fd,$04,$31,$36
>19f8	be 84 69 53 7c fd 04 31			.byte	$be,$84,$69,$53,$7c,$fd,$04,$31
>1a00	34 00 12 e2 04 dc bd 7c			.byte	$34,$00,$12,$e2,$04,$dc,$bd,$7c
>1a08	42 72 87 8b 41 4b 64 57			.byte	$42,$72,$87,$8b,$41,$4b,$64,$57
>1a10	be 84 40 00 14 ec 04 dc			.byte	$be,$84,$40,$00,$14,$ec,$04,$dc
>1a18	bd 8b 43 72 61 68 82 40			.byte	$bd,$8b,$43,$72,$61,$68,$82,$40
>1a20	be 84 8b 43 72 61 68 00			.byte	$be,$84,$8b,$43,$72,$61,$68,$00
>1a28	0a f6 04 dc 9a 40 be 84			.byte	$0a,$f6,$04,$dc,$9a,$40,$be,$84
>1a30	40 00 13 00 05 dc a7 42			.byte	$40,$00,$13,$00,$05,$dc,$a7,$42
>1a38	69 48 50 be 84 fe 07 41			.byte	$69,$48,$50,$be,$84,$fe,$07,$41
>1a40	39 32 31 30 00 1b 0a 05			.byte	$39,$32,$31,$30,$00,$1b,$0a,$05
>1a48	dc bd 41 5e 71 66 fd 04			.byte	$dc,$bd,$41,$5e,$71,$66,$fd,$04
>1a50	38 34 86 42 4b 5c 5f fd			.byte	$38,$34,$86,$42,$4b,$5c,$5f,$fd
>1a58	04 35 39 be 84 8b 41 00			.byte	$04,$35,$39,$be,$84,$8b,$41,$00
>1a60	13 14 05 dc bd 43 4f 53			.byte	$13,$14,$05,$dc,$bd,$43,$4f,$53
>1a68	76 85 41 76 5f 45 be 84			.byte	$76,$85,$41,$76,$5f,$45,$be,$84
>1a70	8b 41 00 16 1e 05 dc bd			.byte	$8b,$41,$00,$16,$1e,$05,$dc,$bd
>1a78	8b 41 7c 53 6d 81 8b 6a			.byte	$8b,$41,$7c,$53,$6d,$81,$8b,$6a
>1a80	5d 4b be 84 8b 68 51 49			.byte	$5d,$4b,$be,$84,$8b,$68,$51,$49
>1a88	00 0d 28 05 dc b3 41 5a			.byte	$00,$0d,$28,$05,$dc,$b3,$41,$5a
>1a90	4d 55 be 84 41 00 13 32			.byte	$4d,$55,$be,$84,$41,$00,$13,$32
>1a98	05 dc af fe 07 39 34 38			.byte	$05,$dc,$af,$fe,$07,$39,$34,$38
>1aa0	45 35 be 84 42 54 63 65			.byte	$45,$35,$be,$84,$42,$54,$63,$65
>1aa8	00 1b 3c 05 dc bd 8b 41			.byte	$00,$1b,$3c,$05,$dc,$bd,$8b,$41
>1ab0	51 6a 50 fd 04 33 31 88			.byte	$51,$6a,$50,$fd,$04,$33,$31,$88
>1ab8	42 71 6d 43 fd 04 35 33			.byte	$42,$71,$6d,$43,$fd,$04,$35,$33
>1ac0	be 84 40 00 12 46 05 dc			.byte	$be,$84,$40,$00,$12,$46,$05,$dc
>1ac8	bd 8b 42 59 70 41 88 50			.byte	$bd,$8b,$42,$59,$70,$41,$88,$50
>1ad0	60 7f be 84 40 00 15 50			.byte	$60,$7f,$be,$84,$40,$00,$15,$50
>1ad8	05 dc bd 43 47 7d 45 82			.byte	$05,$dc,$bd,$43,$47,$7d,$45,$82
>1ae0	42 4f 4b 7c be 84 41 48			.byte	$42,$4f,$4b,$7c,$be,$84,$41,$48
>1ae8	76 79 00 16 5a 05 dc b2			.byte	$76,$79,$00,$16,$5a,$05,$dc,$b2
>1af0	41 52 71 6f bf 8b 43 6a			.byte	$41,$52,$71,$6f,$bf,$8b,$43,$6a
>1af8	6c 62 be 84 41 52 71 6f			.byte	$6c,$62,$be,$84,$41,$52,$71,$6f
>1b00	00 12 64 05 dc a0 fe 04			.byte	$00,$12,$64,$05,$dc,$a0,$fe,$04
>1b08	62 71 bf 4a be 84 fe 04			.byte	$62,$71,$bf,$4a,$be,$84,$fe,$04
>1b10	62 71 00 1c 6e 05 dc bd			.byte	$62,$71,$00,$1c,$6e,$05,$dc,$bd
>1b18	8b 49 53 70 fd 05 35 33			.byte	$8b,$49,$53,$70,$fd,$05,$35,$33
>1b20	32 87 8b 43 4b 45 54 fd			.byte	$32,$87,$8b,$43,$4b,$45,$54,$fd
>1b28	04 34 36 be 84 40 00 12			.byte	$04,$34,$36,$be,$84,$40,$00,$12
>1b30	78 05 dc bd 43 4c 5a 4c			.byte	$78,$05,$dc,$bd,$43,$4c,$5a,$4c
>1b38	8d 43 56 77 53 be 84 40			.byte	$8d,$43,$56,$77,$53,$be,$84,$40
>1b40	00 15 82 05 dc bd 43 4d			.byte	$00,$15,$82,$05,$dc,$bd,$43,$4d
>1b48	5f 52 81 8b 43 45 73 64			.byte	$5f,$52,$81,$8b,$43,$45,$73,$64
>1b50	be 84 8b 60 62 00 0a 8c			.byte	$be,$84,$8b,$60,$62,$00,$0a,$8c
>1b58	05 dc 98 40 84 8b 41 00			.byte	$05,$dc,$98,$40,$84,$8b,$41,$00
>1b60	16 96 05 dc a1 fe 06 7a			.byte	$16,$96,$05,$dc,$a1,$fe,$06,$7a
>1b68	65 63 74 bf 49 be 84 fe			.byte	$65,$63,$74,$bf,$49,$be,$84,$fe
>1b70	06 7a 65 63 74 00 21 a0			.byte	$06,$7a,$65,$63,$74,$00,$21,$a0
>1b78	05 dc bd 42 40 55 49 fd			.byte	$05,$dc,$bd,$42,$40,$55,$49,$fd
>1b80	04 32 32 8b 8b 42 7e 7c			.byte	$04,$32,$32,$8b,$8b,$42,$7e,$7c
>1b88	6e fd 04 36 32 be 84 44			.byte	$6e,$fd,$04,$36,$32,$be,$84,$44
>1b90	7f 51 77 fd 03 38 00 0f			.byte	$7f,$51,$77,$fd,$03,$38,$00,$0f
>1b98	aa 05 dc bd 40 88 42 65			.byte	$aa,$05,$dc,$bd,$40,$88,$42,$65
>1ba0	67 7f be 84 40 00 14 b4			.byte	$67,$7f,$be,$84,$40,$00,$14,$b4
>1ba8	05 dc bd 42 46 58 61 81			.byte	$05,$dc,$bd,$42,$46,$58,$61,$81
>1bb0	57 40 5c be 84 42 57 58			.byte	$57,$40,$5c,$be,$84,$42,$57,$58
>1bb8	7d 00 12 be 05 dc a5 a4			.byte	$7d,$00,$12,$be,$05,$dc,$a5,$a4
>1bc0	8b 43 70 54 be be 84 8b			.byte	$8b,$43,$70,$54,$be,$be,$84,$8b
>1bc8	43 70 54 00 10 c8 05 dc			.byte	$43,$70,$54,$00,$10,$c8,$05,$dc
>1bd0	a2 fe 02 bf 42 bf 49 be			.byte	$a2,$fe,$02,$bf,$42,$bf,$49,$be
>1bd8	84 fe 02 00 22 d2 05 dc			.byte	$84,$fe,$02,$00,$22,$d2,$05,$dc
>1be0	bd 41 7f 55 45 fd 03 39			.byte	$bd,$41,$7f,$55,$45,$fd,$03,$39
>1be8	8a 8b 43 60 7f 5e fd 04			.byte	$8a,$8b,$43,$60,$7f,$5e,$fd,$04
>1bf0	30 39 be 84 8b 41 61 6a			.byte	$30,$39,$be,$84,$8b,$41,$61,$6a
>1bf8	58 fd 04 31 39 00 10 dc			.byte	$58,$fd,$04,$31,$39,$00,$10,$dc
>1c00	05 dc bd 50 55 4e 88 50			.byte	$05,$dc,$bd,$50,$55,$4e,$88,$50
>1c08	55 4e be 84 40 00 12 e6			.byte	$55,$4e,$be,$84,$40,$00,$12,$e6
>1c10	05 dc bd 4d 48 76 80 5f			.byte	$05,$dc,$bd,$4d,$48,$76,$80,$5f
>1c18	57 4b be 84 4d 40 42 00			.byte	$57,$4b,$be,$84,$4d,$40,$42,$00
>1c20	0e f0 05 dc 9a 6d 73 73			.byte	$0e,$f0,$05,$dc,$9a,$6d,$73,$73
>1c28	be 84 6d 73 73 00 13 fa			.byte	$be,$84,$6d,$73,$73,$00,$13,$fa
>1c30	05 dc a6 fe 0a 76 73 73			.byte	$05,$dc,$a6,$fe,$0a,$76,$73,$73
>1c38	65 73 73 70 79 be 84 48			.byte	$65,$73,$73,$70,$79,$be,$84,$48
>1c40	00 22 04 06 dc bd 41 48			.byte	$00,$22,$04,$06,$dc,$bd,$41,$48
>1c48	64 7f fd 04 35 35 8a 8b			.byte	$64,$7f,$fd,$04,$35,$35,$8a,$8b
>1c50	42 70 5a 67 fd 03 33 be			.byte	$42,$70,$5a,$67,$fd,$03,$33,$be
>1c58	84 8b 41 67 75 67 fd 04			.byte	$84,$8b,$41,$67,$75,$67,$fd,$04
>1c60	37 35 00 16 0e 06 dc bd			.byte	$37,$35,$00,$16,$0e,$06,$dc,$bd
>1c68	42 6d 4f 5d 8b 8b 42 4d			.byte	$42,$6d,$4f,$5d,$8b,$8b,$42,$4d
>1c70	50 57 be 84 44 7a 5f 74			.byte	$50,$57,$be,$84,$44,$7a,$5f,$74
>1c78	00 17 18 06 dc bd 8b 43			.byte	$00,$17,$18,$06,$dc,$bd,$8b,$43
>1c80	73 4c 72 82 8b 42 50 69			.byte	$73,$4c,$72,$82,$8b,$42,$50,$69
>1c88	79 be 84 41 63 65 49 00			.byte	$79,$be,$84,$41,$63,$65,$49,$00
>1c90	0e 22 06 dc b3 8b 7c 52			.byte	$0e,$22,$06,$dc,$b3,$8b,$7c,$52
>1c98	6d be 84 8b 41 00 0e 2c			.byte	$6d,$be,$84,$8b,$41,$00,$0e,$2c
>1ca0	06 dc 9b fe 04 61 68 be			.byte	$06,$dc,$9b,$fe,$04,$61,$68,$be
>1ca8	84 41 61 00 1c 36 06 dc			.byte	$84,$41,$61,$00,$1c,$36,$06,$dc
>1cb0	bd 8b 42 48 4c 50 fd 04			.byte	$bd,$8b,$42,$48,$4c,$50,$fd,$04
>1cb8	38 39 86 43 63 79 40 fd			.byte	$38,$39,$86,$43,$63,$79,$40,$fd
>1cc0	04 33 31 be 84 8b 41 00			.byte	$04,$33,$31,$be,$84,$8b,$41,$00
>1cc8	12 40 06 dc bd 5a 75 48			.byte	$12,$40,$06,$dc,$bd,$5a,$75,$48
>1cd0	87 43 66 61 6d be 84 8b			.byte	$87,$43,$66,$61,$6d,$be,$84,$8b
>1cd8	41 00 15 4a 06 dc bd 41			.byte	$41,$00,$15,$4a,$06,$dc,$bd,$41
>1ce0	44 48 47 81 8b 73 52 69			.byte	$44,$48,$47,$81,$8b,$73,$52,$69
>1ce8	be 84 8b 73 52 69 00 17			.byte	$be,$84,$8b,$73,$52,$69,$00,$17
>1cf0	54 06 dc b2 8b 43 49 63			.byte	$54,$06,$dc,$b2,$8b,$43,$49,$63
>1cf8	75 bf 8b 43 66 4d 77 be			.byte	$75,$bf,$8b,$43,$66,$4d,$77,$be
>1d00	84 43 49 63 75 00 0c 5e			.byte	$84,$43,$49,$63,$75,$00,$0c,$5e
>1d08	06 dc b4 6c be 84 fe 03			.byte	$06,$dc,$b4,$6c,$be,$84,$fe,$03
>1d10	2c 00 28 68 06 dc bd 8b			.byte	$2c,$00,$28,$68,$06,$dc,$bd,$8b
>1d18	43 72 74 54 fd 04 39 32			.byte	$43,$72,$74,$54,$fd,$04,$39,$32
>1d20	8c 8b 73 5d 75 fd 04 30			.byte	$8c,$8b,$73,$5d,$75,$fd,$04,$30
>1d28	36 be 84 42 fd 0d 30 39			.byte	$36,$be,$84,$42,$fd,$0d,$30,$39
>1d30	36 36 32 36 38 38 65 31			.byte	$36,$36,$32,$36,$38,$38,$65,$31
>1d38	31 00 11 72 06 dc bd 42			.byte	$31,$00,$11,$72,$06,$dc,$bd,$42
>1d40	5c 58 60 8d 5e 76 58 be			.byte	$5c,$58,$60,$8d,$5e,$76,$58,$be
>1d48	84 45 00 16 7c 06 dc bd			.byte	$84,$45,$00,$16,$7c,$06,$dc,$bd
>1d50	8b 72 53 64 82 8b 41 4d			.byte	$8b,$72,$53,$64,$82,$8b,$41,$4d
>1d58	4e 4f be 84 41 7f 5d 6d			.byte	$4e,$4f,$be,$84,$41,$7f,$5d,$6d
>1d60	00 0e 86 06 dc 98 5c 5b			.byte	$00,$0e,$86,$06,$dc,$98,$5c,$5b
>1d68	6e 84 8b 5c 5b 6f 00 1d			.byte	$6e,$84,$8b,$5c,$5b,$6f,$00,$1d
>1d70	90 06 dc a3 52 be 84 fe			.byte	$90,$06,$dc,$a3,$52,$be,$84,$fe
>1d78	14 20 20 20 20 20 20 20			.byte	$14,$20,$20,$20,$20,$20,$20,$20
>1d80	20 20 20 20 20 20 20 20			.byte	$20,$20,$20,$20,$20,$20,$20,$20
>1d88	20 20 20 00 1d 9a 06 dc			.byte	$20,$20,$20,$00,$1d,$9a,$06,$dc
>1d90	bd 43 5e 59 50 fd 04 30			.byte	$bd,$43,$5e,$59,$50,$fd,$04,$30
>1d98	35 8a 40 fd 03 30 be 84			.byte	$35,$8a,$40,$fd,$03,$30,$be,$84
>1da0	43 5e 59 50 fd 04 30 35			.byte	$43,$5e,$59,$50,$fd,$04,$30,$35
>1da8	00 12 a4 06 dc bd 42 56			.byte	$00,$12,$a4,$06,$dc,$bd,$42,$56
>1db0	66 4c 84 8b 6b 78 6b be			.byte	$66,$4c,$84,$8b,$6b,$78,$6b,$be
>1db8	84 40 00 17 ae 06 dc bd			.byte	$84,$40,$00,$17,$ae,$06,$dc,$bd
>1dc0	8b 6b 4b 49 80 8b 43 60			.byte	$8b,$6b,$4b,$49,$80,$8b,$43,$60
>1dc8	58 4b be 84 8b 43 6b 5b			.byte	$58,$4b,$be,$84,$8b,$43,$6b,$5b
>1dd0	4b 00 12 b8 06 dc a5 a4			.byte	$4b,$00,$12,$b8,$06,$dc,$a5,$a4
>1dd8	8b 77 7e 74 be be 84 8b			.byte	$8b,$77,$7e,$74,$be,$be,$84,$8b
>1de0	77 7e 74 00 13 c2 06 dc			.byte	$77,$7e,$74,$00,$13,$c2,$06,$dc
>1de8	a7 42 67 5b 6a be 84 fe			.byte	$a7,$42,$67,$5b,$6a,$be,$84,$fe
>1df0	07 41 37 36 45 41 00 17			.byte	$07,$41,$37,$36,$45,$41,$00,$17
>1df8	cc 06 dc bd 40 fd 03 30			.byte	$cc,$06,$dc,$bd,$40,$fd,$03,$30
>1e00	84 8b 43 60 66 61 fd 04			.byte	$84,$8b,$43,$60,$66,$61,$fd,$04
>1e08	36 33 be 84 40 00 15 d6			.byte	$36,$33,$be,$84,$40,$00,$15,$d6
>1e10	06 dc bd 8b 42 66 67 6b			.byte	$06,$dc,$bd,$8b,$42,$66,$67,$6b
>1e18	89 8b 42 66 67 6b be 84			.byte	$89,$8b,$42,$66,$67,$6b,$be,$84
>1e20	8b 41 00 16 e0 06 dc bd			.byte	$8b,$41,$00,$16,$e0,$06,$dc,$bd
>1e28	8b 41 72 4a 6b 82 41 52			.byte	$8b,$41,$72,$4a,$6b,$82,$41,$52
>1e30	7b 77 be 84 8b 60 71 5e			.byte	$7b,$77,$be,$84,$8b,$60,$71,$5e
>1e38	00 11 ea 06 dc 9a 8b 43			.byte	$00,$11,$ea,$06,$dc,$9a,$8b,$43
>1e40	5a 68 5f be 84 43 5a 68			.byte	$5a,$68,$5f,$be,$84,$43,$5a,$68
>1e48	5f 00 13 f4 06 dc af fe			.byte	$5f,$00,$13,$f4,$06,$dc,$af,$fe
>1e50	07 42 39 38 38 46 be 84			.byte	$07,$42,$39,$38,$38,$46,$be,$84
>1e58	42 79 62 4f 00 28 fe 06			.byte	$42,$79,$62,$4f,$00,$28,$fe,$06
>1e60	dc bd 8b 55 6a 7c fd 05			.byte	$dc,$bd,$8b,$55,$6a,$7c,$fd,$05
>1e68	34 31 37 8c 41 44 50 68			.byte	$34,$31,$37,$8c,$41,$44,$50,$68
>1e70	fd 03 35 be 84 8b 42 fd			.byte	$fd,$03,$35,$be,$84,$8b,$42,$fd
>1e78	0d 34 38 31 37 38 36 35			.byte	$0d,$34,$38,$31,$37,$38,$36,$35
>1e80	36 65 31 30 00 15 08 07			.byte	$36,$65,$31,$30,$00,$15,$08,$07
>1e88	dc bd 8b 43 4e 62 58 89			.byte	$dc,$bd,$8b,$43,$4e,$62,$58,$89
>1e90	8b 43 4e 62 58 be 84 8b			.byte	$8b,$43,$4e,$62,$58,$be,$84,$8b
>1e98	41 00 16 12 07 dc bd 8b			.byte	$41,$00,$16,$12,$07,$dc,$bd,$8b
>1ea0	41 76 57 7e 82 8b 41 61			.byte	$41,$76,$57,$7e,$82,$8b,$41,$61
>1ea8	78 70 be 84 57 6f 52 00			.byte	$78,$70,$be,$84,$57,$6f,$52,$00
>1eb0	0f 1c 07 dc b3 8b 42 44			.byte	$0f,$1c,$07,$dc,$b3,$8b,$42,$44
>1eb8	73 58 be 84 8b 41 00 18			.byte	$73,$58,$be,$84,$8b,$41,$00,$18
>1ec0	26 07 dc a0 fe 07 74 6b			.byte	$26,$07,$dc,$a0,$fe,$07,$74,$6b
>1ec8	79 61 64 bf 48 be 84 fe			.byte	$79,$61,$64,$bf,$48,$be,$84,$fe
>1ed0	07 74 6b 79 61 64 00 1b			.byte	$07,$74,$6b,$79,$61,$64,$00,$1b
>1ed8	30 07 dc bd 7f 73 43 fd			.byte	$30,$07,$dc,$bd,$7f,$73,$43,$fd
>1ee0	04 38 37 88 8b 41 5b 56			.byte	$04,$38,$37,$88,$8b,$41,$5b,$56
>1ee8	63 fd 04 37 33 be 84 8b			.byte	$63,$fd,$04,$37,$33,$be,$84,$8b
>1ef0	41 00 15 3a 07 dc bd 42			.byte	$41,$00,$15,$3a,$07,$dc,$bd,$42
>1ef8	70 68 5f 8a 42 70 68 5f			.byte	$70,$68,$5f,$8a,$42,$70,$68,$5f
>1f00	be 84 45 61 50 7e 00 13			.byte	$be,$84,$45,$61,$50,$7e,$00,$13
>1f08	44 07 dc bd 6e 78 7a 80			.byte	$44,$07,$dc,$bd,$6e,$78,$7a,$80
>1f10	42 5e 55 55 be 84 4e 50			.byte	$42,$5e,$55,$55,$be,$84,$4e,$50
>1f18	50 00 17 4e 07 dc b2 8b			.byte	$50,$00,$17,$4e,$07,$dc,$b2,$8b
>1f20	42 6e 56 65 bf 8b 43 54			.byte	$42,$6e,$56,$65,$bf,$8b,$43,$54
>1f28	57 56 be 84 42 6e 56 65			.byte	$57,$56,$be,$84,$42,$6e,$56,$65
>1f30	00 17 58 07 dc a1 fe 07			.byte	$00,$17,$58,$07,$dc,$a1,$fe,$07
>1f38	62 61 79 6a 76 bf 44 be			.byte	$62,$61,$79,$6a,$76,$bf,$44,$be
>1f40	84 fe 06 61 79 6a 76 00			.byte	$84,$fe,$06,$61,$79,$6a,$76,$00
>1f48	1a 62 07 dc bd 5e 43 5f			.byte	$1a,$62,$07,$dc,$bd,$5e,$43,$5f
>1f50	fd 04 32 38 86 8b 42 5d			.byte	$fd,$04,$32,$38,$86,$8b,$42,$5d
>1f58	54 46 fd 04 34 38 be 84			.byte	$54,$46,$fd,$04,$34,$38,$be,$84
>1f60	40 00 12 6c 07 dc bd 42			.byte	$40,$00,$12,$6c,$07,$dc,$bd,$42
>1f68	7b 45 7d 84 43 61 7f 50			.byte	$7b,$45,$7d,$84,$43,$61,$7f,$50
>1f70	be 84 40 00 15 76 07 dc			.byte	$be,$84,$40,$00,$15,$76,$07,$dc
>1f78	bd 41 48 45 4a 82 42 44			.byte	$bd,$41,$48,$45,$4a,$82,$42,$44
>1f80	7c 57 be 84 43 4c 79 5d			.byte	$7c,$57,$be,$84,$43,$4c,$79,$5d
>1f88	00 0e 80 07 dc 98 8b 45			.byte	$00,$0e,$80,$07,$dc,$98,$8b,$45
>1f90	76 74 84 45 76 73 00 11			.byte	$76,$74,$84,$45,$76,$73,$00,$11
>1f98	8a 07 dc a2 fe 03 75 bf			.byte	$8a,$07,$dc,$a2,$fe,$03,$75,$bf
>1fa0	45 bf 44 be 84 fe 02 00			.byte	$45,$bf,$44,$be,$84,$fe,$02,$00
>1fa8	1c 94 07 dc bd 54 5c 40			.byte	$1c,$94,$07,$dc,$bd,$54,$5c,$40
>1fb0	fd 05 31 37 31 85 8b 41			.byte	$fd,$05,$31,$37,$31,$85,$8b,$41
>1fb8	64 66 66 fd 04 39 36 be			.byte	$64,$66,$66,$fd,$04,$39,$36,$be
>1fc0	84 8b 41 00 14 9e 07 dc			.byte	$84,$8b,$41,$00,$14,$9e,$07,$dc
>1fc8	bd 42 67 6f 7e 88 8b 42			.byte	$bd,$42,$67,$6f,$7e,$88,$8b,$42
>1fd0	6d 5e 45 be 84 8b 41 00			.byte	$6d,$5e,$45,$be,$84,$8b,$41,$00
>1fd8	16 a8 07 dc bd 8b 65 7b			.byte	$16,$a8,$07,$dc,$bd,$8b,$65,$7b
>1fe0	50 81 8b 42 51 78 71 be			.byte	$50,$81,$8b,$42,$51,$78,$71,$be
>1fe8	84 8b 41 78 41 00 18 b2			.byte	$84,$8b,$41,$78,$41,$00,$18,$b2
>1ff0	07 dc a5 a4 5c 54 66 fd			.byte	$07,$dc,$a5,$a4,$5c,$54,$66,$fd
>1ff8	04 38 34 be be 84 5c 54			.byte	$04,$38,$34,$be,$be,$84,$5c,$54
>2000	66 fd 04 38 34 00 14 bc			.byte	$66,$fd,$04,$38,$34,$00,$14,$bc
>2008	07 dc a6 fe 0b 64 77 6b			.byte	$07,$dc,$a6,$fe,$0b,$64,$77,$6b
>2010	69 63 78 6e 77 65 be 84			.byte	$69,$63,$78,$6e,$77,$65,$be,$84
>2018	49 00 1b c6 07 dc bd 42			.byte	$49,$00,$1b,$c6,$07,$dc,$bd,$42
>2020	5a 68 57 fd 03 36 88 8b			.byte	$5a,$68,$57,$fd,$03,$36,$88,$8b
>2028	41 7a 72 63 fd 04 31 37			.byte	$41,$7a,$72,$63,$fd,$04,$31,$37
>2030	be 84 8b 41 00 0f d0 07			.byte	$be,$84,$8b,$41,$00,$0f,$d0,$07
>2038	dc bd 41 53 77 57 8c 40			.byte	$dc,$bd,$41,$53,$77,$57,$8c,$40
>2040	be 84 40 00 14 da 07 dc			.byte	$be,$84,$40,$00,$14,$da,$07,$dc
>2048	bd 40 82 8b 42 7a 5b 6e			.byte	$bd,$40,$82,$8b,$42,$7a,$5b,$6e
>2050	be 84 8b 42 7a 5b 6e 00			.byte	$be,$84,$8b,$42,$7a,$5b,$6e,$00
>2058	0f e4 07 dc 9a 8b 48 65			.byte	$0f,$e4,$07,$dc,$9a,$8b,$48,$65
>2060	61 be 84 48 65 61 00 0f			.byte	$61,$be,$84,$48,$65,$61,$00,$0f
>2068	ee 07 dc 9b fe 05 6f 74			.byte	$ee,$07,$dc,$9b,$fe,$05,$6f,$74
>2070	70 be 84 41 6f 00 17 f8			.byte	$70,$be,$84,$41,$6f,$00,$17,$f8
>2078	07 dc bd 8b 42 50 44 63			.byte	$07,$dc,$bd,$8b,$42,$50,$44,$63
>2080	fd 04 35 36 88 40 fd 03			.byte	$fd,$04,$35,$36,$88,$40,$fd,$03
>2088	30 be 84 40 00 11 02 08			.byte	$30,$be,$84,$40,$00,$11,$02,$08
>2090	dc bd 54 6c 79 87 8b 69			.byte	$dc,$bd,$54,$6c,$79,$87,$8b,$69
>2098	7d 44 be 84 40 00 15 0c			.byte	$7d,$44,$be,$84,$40,$00,$15,$0c
>20a0	08 dc bd 42 6f 40 42 80			.byte	$08,$dc,$bd,$42,$6f,$40,$42,$80
>20a8	8b 7e 78 56 be 84 42 41			.byte	$8b,$7e,$78,$56,$be,$84,$42,$41
>20b0	40 42 00 0f 16 08 dc b3			.byte	$40,$42,$00,$0f,$16,$08,$dc,$b3
>20b8	8b 42 78 5b 60 be 84 8b			.byte	$8b,$42,$78,$5b,$60,$be,$84,$8b
>20c0	41 00 0d 20 08 dc b4 41			.byte	$41,$00,$0d,$20,$08,$dc,$b4,$41
>20c8	77 be 84 fe 03 77 00 19			.byte	$77,$be,$84,$fe,$03,$77,$00,$19
>20d0	2a 08 dc bd 43 51 59 6c			.byte	$2a,$08,$dc,$bd,$43,$51,$59,$6c
>20d8	fd 04 33 32 8c 40 fd 03			.byte	$fd,$04,$33,$32,$8c,$40,$fd,$03
>20e0	30 be 84 40 fd 03 30 00			.byte	$30,$be,$84,$40,$fd,$03,$30,$00
>20e8	12 34 08 dc bd 43 41 71			.byte	$12,$34,$08,$dc,$bd,$43,$41,$71
>20f0	55 87 8b 5e 6b 7a be 84			.byte	$55,$87,$8b,$5e,$6b,$7a,$be,$84
>20f8	40 00 0f 3e 08 dc bd 42			.byte	$40,$00,$0f,$3e,$08,$dc,$bd,$42
>2100	6e 77 56 80 40 be 84 40			.byte	$6e,$77,$56,$80,$40,$be,$84,$40
>2108	00 13 48 08 dc b2 41 41			.byte	$00,$13,$48,$08,$dc,$b2,$41,$41
>2110	7c 78 bf 48 62 76 be 84			.byte	$7c,$78,$bf,$48,$62,$76,$be,$84
>2118	46 48 7e 00 11 52 08 dc			.byte	$46,$48,$7e,$00,$11,$52,$08,$dc
>2120	a3 46 be 84 fe 08 20 20			.byte	$a3,$46,$be,$84,$fe,$08,$20,$20
>2128	20 20 20 20 00 1c 5c 08			.byte	$20,$20,$20,$20,$00,$1c,$5c,$08
>2130	dc bd 8b 49 61 5d fd 05			.byte	$dc,$bd,$8b,$49,$61,$5d,$fd,$05
>2138	30 38 36 88 8b 47 7c 6e			.byte	$30,$38,$36,$88,$8b,$47,$7c,$6e
>2140	fd 05 38 31 36 be 84 40			.byte	$fd,$05,$38,$31,$36,$be,$84,$40
>2148	00 14 66 08 dc bd 8b 42			.byte	$00,$14,$66,$08,$dc,$bd,$8b,$42
>2150	46 40 57 85 8b 55 46 48			.byte	$46,$40,$57,$85,$8b,$55,$46,$48
>2158	be 84 8b 41 00 14 70 08			.byte	$be,$84,$8b,$41,$00,$14,$70,$08
>2160	dc bd 40 82 8b 41 76 7d			.byte	$dc,$bd,$40,$82,$8b,$41,$76,$7d
>2168	58 be 84 8b 41 76 7d 58			.byte	$58,$be,$84,$8b,$41,$76,$7d,$58
>2170	00 10 7a 08 dc 98 42 41			.byte	$00,$10,$7a,$08,$dc,$98,$42,$41
>2178	4b 6d 84 8b 42 41 4b 6e			.byte	$4b,$6d,$84,$8b,$42,$41,$4b,$6e
>2180	00 12 84 08 dc a7 76 5d			.byte	$00,$12,$84,$08,$dc,$a7,$76,$5d
>2188	61 be 84 fe 07 33 36 37			.byte	$61,$be,$84,$fe,$07,$33,$36,$37
>2190	36 31 00 16 8e 08 dc bd			.byte	$36,$31,$00,$16,$8e,$08,$dc,$bd
>2198	40 fd 03 30 89 4c 51 4e			.byte	$40,$fd,$03,$30,$89,$4c,$51,$4e
>21a0	fd 05 39 35 35 be 84 40			.byte	$fd,$05,$39,$35,$35,$be,$84,$40
>21a8	00 13 98 08 dc bd 43 4d			.byte	$00,$13,$98,$08,$dc,$bd,$43,$4d
>21b0	65 60 87 8b 43 55 5f 46			.byte	$65,$60,$87,$8b,$43,$55,$5f,$46
>21b8	be 84 40 00 14 a2 08 dc			.byte	$be,$84,$40,$00,$14,$a2,$08,$dc
>21c0	bd 45 62 41 80 8b 41 5a			.byte	$bd,$45,$62,$41,$80,$8b,$41,$5a
>21c8	7a 51 be 84 45 40 41 00			.byte	$7a,$51,$be,$84,$45,$40,$41,$00
>21d0	1c ac 08 dc a5 a4 8b 42			.byte	$1c,$ac,$08,$dc,$a5,$a4,$8b,$42
>21d8	49 54 78 fd 04 30 37 be			.byte	$49,$54,$78,$fd,$04,$30,$37,$be
>21e0	be 84 8b 42 49 54 78 fd			.byte	$be,$84,$8b,$42,$49,$54,$78,$fd
>21e8	04 30 37 00 11 b6 08 dc			.byte	$04,$30,$37,$00,$11,$b6,$08,$dc
>21f0	af fe 06 45 37 39 33 be			.byte	$af,$fe,$06,$45,$37,$39,$33,$be
>21f8	84 4e 5e 53 00 23 c0 08			.byte	$84,$4e,$5e,$53,$00,$23,$c0,$08
>2200	dc bd 8b 42 63 69 64 fd			.byte	$dc,$bd,$8b,$42,$63,$69,$64,$fd
>2208	04 33 38 8a 8b 5a 7b 4c			.byte	$04,$33,$38,$8a,$8b,$5a,$7b,$4c
>2210	fd 04 36 35 be 84 8b 42			.byte	$fd,$04,$36,$35,$be,$84,$8b,$42
>2218	7e 64 71 fd 04 30 33 00			.byte	$7e,$64,$71,$fd,$04,$30,$33,$00
>2220	13 ca 08 dc bd 43 48 47			.byte	$13,$ca,$08,$dc,$bd,$43,$48,$47
>2228	4b 84 8b 43 5d 54 75 be			.byte	$4b,$84,$8b,$43,$5d,$54,$75,$be
>2230	84 40 00 16 d4 08 dc bd			.byte	$84,$40,$00,$16,$d4,$08,$dc,$bd
>2238	8b 43 5f 5d 50 81 64 5a			.byte	$8b,$43,$5f,$5d,$50,$81,$64,$5a
>2240	4a be 84 8b 43 5b 45 46			.byte	$4a,$be,$84,$8b,$43,$5b,$45,$46
>2248	00 11 de 08 dc 9a 8b 42			.byte	$00,$11,$de,$08,$dc,$9a,$8b,$42
>2250	49 58 45 be 84 42 49 58			.byte	$49,$58,$45,$be,$84,$42,$49,$58
>2258	45 00 14 e8 08 dc a0 fe			.byte	$45,$00,$14,$e8,$08,$dc,$a0,$fe
>2260	05 6d 67 78 bf 43 be 84			.byte	$05,$6d,$67,$78,$bf,$43,$be,$84
>2268	fe 05 6d 67 78 00 1b f2			.byte	$fe,$05,$6d,$67,$78,$00,$1b,$f2
>2270	08 dc bd 41 70 4d 41 fd			.byte	$08,$dc,$bd,$41,$70,$4d,$41,$fd
>2278	04 35 35 87 8b 41 6a 58			.byte	$04,$35,$35,$87,$8b,$41,$6a,$58
>2280	4b fd 04 39 38 be 84 40			.byte	$4b,$fd,$04,$39,$38,$be,$84,$40
>2288	00 10 fc 08 dc bd 4d 41			.byte	$00,$10,$fc,$08,$dc,$bd,$4d,$41
>2290	87 7e 4f 6c be 84 8b 41			.byte	$87,$7e,$4f,$6c,$be,$84,$8b,$41
>2298	00 15 06 09 dc bd 43 44			.byte	$00,$15,$06,$09,$dc,$bd,$43,$44
>22a0	5f 72 80 42 42 72 71 be			.byte	$5f,$72,$80,$42,$42,$72,$71,$be
>22a8	84 42 40 52 70 00 0f 10			.byte	$84,$42,$40,$52,$70,$00,$0f,$10
>22b0	09 dc b3 8b 43 55 62 53			.byte	$09,$dc,$b3,$8b,$43,$55,$62,$53
>22b8	be 84 8b 41 00 12 1a 09			.byte	$be,$84,$8b,$41,$00,$12,$1a,$09
>22c0	dc a1 fe 05 73 62 64 bf			.byte	$dc,$a1,$fe,$05,$73,$62,$64,$bf
>22c8	41 be 84 fe 03 64 00 21			.byte	$41,$be,$84,$fe,$03,$64,$00,$21
>22d0	24 09 dc bd 43 66 54 4d			.byte	$24,$09,$dc,$bd,$43,$66,$54,$4d
>22d8	fd 04 34 31 8b 41 7a 6b			.byte	$fd,$04,$34,$31,$8b,$41,$7a,$6b
>22e0	6c fd 04 33 32 be 84 41			.byte	$6c,$fd,$04,$33,$32,$be,$84,$41
>22e8	6b 68 61 fd 04 30 39 00			.byte	$6b,$68,$61,$fd,$04,$30,$39,$00
>22f0	15 2e 09 dc bd 8b 43 56			.byte	$15,$2e,$09,$dc,$bd,$8b,$43,$56
>22f8	6c 44 86 8b 41 7d 48 77			.byte	$6c,$44,$86,$8b,$41,$7d,$48,$77
>2300	be 84 8b 41 00 16 38 09			.byte	$be,$84,$8b,$41,$00,$16,$38,$09
>2308	dc bd 43 52 66 4a 82 8b			.byte	$dc,$bd,$43,$52,$66,$4a,$82,$8b
>2310	6f 67 7d be 84 8b 43 7d			.byte	$6f,$67,$7d,$be,$84,$8b,$43,$7d
>2318	41 77 00 15 42 09 dc b2			.byte	$41,$77,$00,$15,$42,$09,$dc,$b2
>2320	8b 43 4a 4e 65 bf 41 60			.byte	$8b,$43,$4a,$4e,$65,$bf,$41,$60
>2328	4d 69 be 84 49 73 53 00			.byte	$4d,$69,$be,$84,$49,$73,$53,$00
>2330	1b 4c 09 dc a2 fe 09 6b			.byte	$1b,$4c,$09,$dc,$a2,$fe,$09,$6b
>2338	6d 6a 7a 67 7a 62 bf 44			.byte	$6d,$6a,$7a,$67,$7a,$62,$bf,$44
>2340	bf 46 be 84 fe 06 7a 67			.byte	$bf,$46,$be,$84,$fe,$06,$7a,$67
>2348	7a 62 00 23 56 09 dc bd			.byte	$7a,$62,$00,$23,$56,$09,$dc,$bd
>2350	8b 42 71 51 64 fd 04 35			.byte	$8b,$42,$71,$51,$64,$fd,$04,$35
>2358	32 8b 8b 42 57 48 5c fd			.byte	$32,$8b,$8b,$42,$57,$48,$5c,$fd
>2360	04 33 31 be 84 8b 5a 49			.byte	$04,$33,$31,$be,$84,$8b,$5a,$49
>2368	48 fd 04 32 31 00 13 60			.byte	$48,$fd,$04,$32,$31,$00,$13,$60
>2370	09 dc bd 8b 41 6f 68 4f			.byte	$09,$dc,$bd,$8b,$41,$6f,$68,$4f
>2378	89 43 48 5a 76 be 84 40			.byte	$89,$43,$48,$5a,$76,$be,$84,$40
>2380	00 12 6a 09 dc bd 43 5e			.byte	$00,$12,$6a,$09,$dc,$bd,$43,$5e
>2388	58 6a 82 40 be 84 43 5e			.byte	$58,$6a,$82,$40,$be,$84,$43,$5e
>2390	58 6a 00 0e 74 09 dc 98			.byte	$58,$6a,$00,$0e,$74,$09,$dc,$98
>2398	8b 66 4f 4d 84 66 4f 4c			.byte	$8b,$66,$4f,$4d,$84,$66,$4f,$4c
>23a0	00 15 7e 09 dc a6 fe 0c			.byte	$00,$15,$7e,$09,$dc,$a6,$fe,$0c
>23a8	73 68 69 7a 78 75 76 76			.byte	$73,$68,$69,$7a,$78,$75,$76,$76
>23b0	6c 70 be 84 4a 00 29 88			.byte	$6c,$70,$be,$84,$4a,$00,$29,$88
>23b8	09 dc bd 42 5d 42 78 fd			.byte	$09,$dc,$bd,$42,$5d,$42,$78,$fd
>23c0	04 32 36 8c 8b 41 6b 43			.byte	$04,$32,$36,$8c,$8b,$41,$6b,$43
>23c8	4a fd 04 36 33 be 84 8b			.byte	$4a,$fd,$04,$36,$33,$be,$84,$8b
>23d0	42 fd 0d 38 32 30 35 31			.byte	$42,$fd,$0d,$38,$32,$30,$35,$31
>23d8	35 35 32 65 31 31 00 15			.byte	$35,$35,$32,$65,$31,$31,$00,$15
>23e0	92 09 dc bd 8b 42 53 59			.byte	$92,$09,$dc,$bd,$8b,$42,$53,$59
>23e8	7c 85 8b 41 51 49 42 be			.byte	$7c,$85,$8b,$41,$51,$49,$42,$be
>23f0	84 8b 41 00 16 9c 09 dc			.byte	$84,$8b,$41,$00,$16,$9c,$09,$dc
>23f8	bd 41 76 69 5a 80 8b 42			.byte	$bd,$41,$76,$69,$5a,$80,$8b,$42
>2400	4b 49 5c be 84 41 74 60			.byte	$4b,$49,$5c,$be,$84,$41,$74,$60
>2408	40 00 14 a6 09 dc a5 a4			.byte	$40,$00,$14,$a6,$09,$dc,$a5,$a4
>2410	8b 41 63 56 56 be be 84			.byte	$8b,$41,$63,$56,$56,$be,$be,$84
>2418	8b 41 63 56 56 00 15 b0			.byte	$8b,$41,$63,$56,$56,$00,$15,$b0
>2420	09 dc 9b fe 0b 64 7a 62			.byte	$09,$dc,$9b,$fe,$0b,$64,$7a,$62
>2428	7a 61 66 69 72 73 be 84			.byte	$7a,$61,$66,$69,$72,$73,$be,$84
>2430	41 64 00 1f ba 09 dc bd			.byte	$41,$64,$00,$1f,$ba,$09,$dc,$bd
>2438	8b 58 57 7a fd 05 33 31			.byte	$8b,$58,$57,$7a,$fd,$05,$33,$31
>2440	33 8a 40 fd 03 30 be 84			.byte	$33,$8a,$40,$fd,$03,$30,$be,$84
>2448	8b 58 57 7a fd 05 33 31			.byte	$8b,$58,$57,$7a,$fd,$05,$33,$31
>2450	33 00 0f c4 09 dc bd 43			.byte	$33,$00,$0f,$c4,$09,$dc,$bd,$43
>2458	60 54 76 8c 40 be 84 40			.byte	$60,$54,$76,$8c,$40,$be,$84,$40
>2460	00 17 ce 09 dc bd 8b 42			.byte	$00,$17,$ce,$09,$dc,$bd,$8b,$42
>2468	5c 5f 50 82 8b 41 7a 59			.byte	$5c,$5f,$50,$82,$8b,$41,$7a,$59
>2470	73 be 84 43 66 46 7d 00			.byte	$73,$be,$84,$43,$66,$46,$7d,$00
>2478	10 d8 09 dc 9a 42 76 69			.byte	$10,$d8,$09,$dc,$9a,$42,$76,$69
>2480	58 be 84 42 76 69 58 00			.byte	$58,$be,$84,$42,$76,$69,$58,$00
>2488	0d e2 09 dc b4 41 6a be			.byte	$0d,$e2,$09,$dc,$b4,$41,$6a,$be
>2490	84 fe 03 6a 00 1d ec 09			.byte	$84,$fe,$03,$6a,$00,$1d,$ec,$09
>2498	dc bd 42 44 52 61 fd 04			.byte	$dc,$bd,$42,$44,$52,$61,$fd,$04
>24a0	31 32 8b 42 44 52 61 fd			.byte	$31,$32,$8b,$42,$44,$52,$61,$fd
>24a8	04 31 32 be 84 40 fd 03			.byte	$04,$31,$32,$be,$84,$40,$fd,$03
>24b0	30 00 13 f6 09 dc bd 41			.byte	$30,$00,$13,$f6,$09,$dc,$bd,$41
>24b8	7e 45 7a 84 8b 43 64 5b			.byte	$7e,$45,$7a,$84,$8b,$43,$64,$5b
>24c0	60 be 84 40 00 17 00 0a			.byte	$60,$be,$84,$40,$00,$17,$00,$0a
>24c8	dc bd 8b 43 6f 67 5e 82			.byte	$dc,$bd,$8b,$43,$6f,$67,$5e,$82
>24d0	8b 42 76 6e 7b be 84 41			.byte	$8b,$42,$76,$6e,$7b,$be,$84,$41
>24d8	59 49 67 00 0e 0a 0a dc			.byte	$59,$49,$67,$00,$0e,$0a,$0a,$dc
>24e0	b3 8b 59 69 72 be 84 8b			.byte	$b3,$8b,$59,$69,$72,$be,$84,$8b
>24e8	41 00 0b 14 0a dc a3 40			.byte	$41,$00,$0b,$14,$0a,$dc,$a3,$40
>24f0	be 84 fe 02 00 1b 1e 0a			.byte	$be,$84,$fe,$02,$00,$1b,$1e,$0a
>24f8	dc bd 8b 73 75 6e fd 04			.byte	$dc,$bd,$8b,$73,$75,$6e,$fd,$04
>2500	36 38 86 8b 43 5a 59 61			.byte	$36,$38,$86,$8b,$43,$5a,$59,$61
>2508	fd 04 38 37 be 84 40 00			.byte	$fd,$04,$38,$37,$be,$84,$40,$00
>2510	10 28 0a dc bd 8b 43 46			.byte	$10,$28,$0a,$dc,$bd,$8b,$43,$46
>2518	5e 40 88 40 be 84 40 00			.byte	$5e,$40,$88,$40,$be,$84,$40,$00
>2520	13 32 0a dc bd 41 47 5e			.byte	$13,$32,$0a,$dc,$bd,$41,$47,$5e
>2528	67 80 42 68 54 5f be 84			.byte	$67,$80,$42,$68,$54,$5f,$be,$84
>2530	54 47 00 10 3c 0a dc b2			.byte	$54,$47,$00,$10,$3c,$0a,$dc,$b2
>2538	40 bf 8b 42 4a 76 5e be			.byte	$40,$bf,$8b,$42,$4a,$76,$5e,$be
>2540	84 40 00 12 46 0a dc a7			.byte	$84,$40,$00,$12,$46,$0a,$dc,$a7
>2548	78 4f 4b be 84 fe 07 33			.byte	$78,$4f,$4b,$be,$84,$fe,$07,$33
>2550	38 33 43 42 00 19 50 0a			.byte	$38,$33,$43,$42,$00,$19,$50,$0a
>2558	dc bd 40 fd 03 30 8d 42			.byte	$dc,$bd,$40,$fd,$03,$30,$8d,$42
>2560	6b 60 67 fd 04 35 38 be			.byte	$6b,$60,$67,$fd,$04,$35,$38,$be
>2568	84 40 fd 03 30 00 10 5a			.byte	$84,$40,$fd,$03,$30,$00,$10,$5a
>2570	0a dc bd 8b 42 7d 61 58			.byte	$0a,$dc,$bd,$8b,$42,$7d,$61,$58
>2578	8c 40 be 84 40 00 12 64			.byte	$8c,$40,$be,$84,$40,$00,$12,$64
>2580	0a dc bd 8b 7b 57 56 82			.byte	$0a,$dc,$bd,$8b,$7b,$57,$56,$82
>2588	40 be 84 8b 7b 57 56 00			.byte	$40,$be,$84,$8b,$7b,$57,$56,$00
>2590	10 6e 0a dc 98 8b 41 5d			.byte	$10,$6e,$0a,$dc,$98,$8b,$41,$5d
>2598	55 53 84 41 5d 55 52 00			.byte	$55,$53,$84,$41,$5d,$55,$52,$00
>25a0	12 78 0a dc af fe 07 31			.byte	$12,$78,$0a,$dc,$af,$fe,$07,$31
>25a8	37 30 41 43 be 84 57 42			.byte	$37,$30,$41,$43,$be,$84,$57,$42
>25b0	6c 00 13 82 0a dc bd 40			.byte	$6c,$00,$13,$82,$0a,$dc,$bd,$40
>25b8	fd 03 30 84 40 fd 03 30			.byte	$fd,$03,$30,$84,$40,$fd,$03,$30
>25c0	be 84 8b 41 00 15 8c 0a			.byte	$be,$84,$8b,$41,$00,$15,$8c,$0a
>25c8	dc bd 8b 41 73 49 5e 89			.byte	$dc,$bd,$8b,$41,$73,$49,$5e,$89
>25d0	8b 42 7d 52 70 be 84 8b			.byte	$8b,$42,$7d,$52,$70,$be,$84,$8b
>25d8	41 00 15 96 0a dc bd 41			.byte	$41,$00,$15,$96,$0a,$dc,$bd,$41
>25e0	5f 43 4b 82 42 64 73 58			.byte	$5f,$43,$4b,$82,$42,$64,$73,$58
>25e8	be 84 43 7b 70 53 00 12			.byte	$be,$84,$43,$7b,$70,$53,$00,$12
>25f0	a0 0a dc a5 a4 41 7e 57			.byte	$a0,$0a,$dc,$a5,$a4,$41,$7e,$57
>25f8	72 be be 84 41 7e 57 72			.byte	$72,$be,$be,$84,$41,$7e,$57,$72
>2600	00 0e aa 0a dc a0 fe 02			.byte	$00,$0e,$aa,$0a,$dc,$a0,$fe,$02
>2608	bf 41 be 84 fe 02 00 1a			.byte	$bf,$41,$be,$84,$fe,$02,$00,$1a
>2610	b4 0a dc bd 8b 43 5c 7a			.byte	$b4,$0a,$dc,$bd,$8b,$43,$5c,$7a
>2618	56 fd 03 31 89 42 78 56			.byte	$56,$fd,$03,$31,$89,$42,$78,$56
>2620	6c fd 04 38 33 be 84 40			.byte	$6c,$fd,$04,$38,$33,$be,$84,$40
>2628	00 13 be 0a dc bd 43 4f			.byte	$00,$13,$be,$0a,$dc,$bd,$43,$4f
>2630	5e 62 85 42 50 46 42 be			.byte	$5e,$62,$85,$42,$50,$46,$42,$be
>2638	84 8b 41 00 14 c8 0a dc			.byte	$84,$8b,$41,$00,$14,$c8,$0a,$dc
>2640	bd 8b 43 6a 7a 50 80 58			.byte	$bd,$8b,$43,$6a,$7a,$50,$80,$58
>2648	58 72 be 84 50 40 70 00			.byte	$58,$72,$be,$84,$50,$40,$70,$00
>2650	10 d2 0a dc 9a 41 63 42			.byte	$10,$d2,$0a,$dc,$9a,$41,$63,$42
>2658	7c be 84 41 63 42 7c 00			.byte	$7c,$be,$84,$41,$63,$42,$7c,$00
>2660	1f dc 0a dc a1 fe 0c 6b			.byte	$1f,$dc,$0a,$dc,$a1,$fe,$0c,$6b
>2668	66 64 6d 70 67 73 61 73			.byte	$66,$64,$6d,$70,$67,$73,$61,$73
>2670	6b bf 47 be 84 fe 09 6d			.byte	$6b,$bf,$47,$be,$84,$fe,$09,$6d
>2678	70 67 73 61 73 6b 00 28			.byte	$70,$67,$73,$61,$73,$6b,$00,$28
>2680	e6 0a dc bd 8b 41 48 69			.byte	$e6,$0a,$dc,$bd,$8b,$41,$48,$69
>2688	62 fd 04 30 31 8c 63 7e			.byte	$62,$fd,$04,$30,$31,$8c,$63,$7e
>2690	5b fd 04 32 36 be 84 8b			.byte	$5b,$fd,$04,$32,$36,$be,$84,$8b
>2698	44 fd 0d 33 38 34 38 35			.byte	$44,$fd,$0d,$33,$38,$34,$38,$35
>26a0	30 35 33 65 31 30 00 12			.byte	$30,$35,$33,$65,$31,$30,$00,$12
>26a8	f0 0a dc bd 8b 66 5c 6d			.byte	$f0,$0a,$dc,$bd,$8b,$66,$5c,$6d
>26b0	84 8b 46 44 6d be 84 40			.byte	$84,$8b,$46,$44,$6d,$be,$84,$40
>26b8	00 14 fa 0a dc bd 41 5a			.byte	$00,$14,$fa,$0a,$dc,$bd,$41,$5a
>26c0	4c 48 80 8b 41 7e 64 71			.byte	$4c,$48,$80,$8b,$41,$7e,$64,$71
>26c8	be 84 48 48 00 0e 04 0b			.byte	$be,$84,$48,$48,$00,$0e,$04,$0b
>26d0	dc b3 8b 5b 69 69 be 84			.byte	$dc,$b3,$8b,$5b,$69,$69,$be,$84
>26d8	8b 41 00 15 0e 0b dc a2			.byte	$8b,$41,$00,$15,$0e,$0b,$dc,$a2
>26e0	fe 06 71 72 64 7a bf 44			.byte	$fe,$06,$71,$72,$64,$7a,$bf,$44
>26e8	bf 46 be 84 fe 03 7a 00			.byte	$bf,$46,$be,$84,$fe,$03,$7a,$00
>26f0	1c 18 0b dc bd 8b 43 47			.byte	$1c,$18,$0b,$dc,$bd,$8b,$43,$47
>26f8	7b 69 fd 04 33 34 84 8b			.byte	$7b,$69,$fd,$04,$33,$34,$84,$8b
>2700	43 46 54 54 fd 04 37 36			.byte	$43,$46,$54,$54,$fd,$04,$37,$36
>2708	be 84 40 00 15 22 0b dc			.byte	$be,$84,$40,$00,$15,$22,$0b,$dc
>2710	bd 8b 41 72 4b 45 86 8b			.byte	$bd,$8b,$41,$72,$4b,$45,$86,$8b
>2718	41 55 53 63 be 84 8b 41			.byte	$41,$55,$53,$63,$be,$84,$8b,$41
>2720	00 15 2c 0b dc bd 41 6a			.byte	$00,$15,$2c,$0b,$dc,$bd,$41,$6a
>2728	64 5d 80 8b 5f 79 57 be			.byte	$64,$5d,$80,$8b,$5f,$79,$57,$be
>2730	84 41 60 44 49 00 10 36			.byte	$84,$41,$60,$44,$49,$00,$10,$36
>2738	0b dc b2 40 bf 8b 43 73			.byte	$0b,$dc,$b2,$40,$bf,$8b,$43,$73
>2740	5f 77 be 84 40 00 12 40			.byte	$5f,$77,$be,$84,$40,$00,$12,$40
>2748	0b dc a6 fe 09 69 66 76			.byte	$0b,$dc,$a6,$fe,$09,$69,$66,$76
>2750	6d 64 68 75 be 84 47 00			.byte	$6d,$64,$68,$75,$be,$84,$47,$00
>2758	1a 4a 0b dc bd 8b 74 5a			.byte	$1a,$4a,$0b,$dc,$bd,$8b,$74,$5a
>2760	4b fd 03 33 85 43 4b 50			.byte	$4b,$fd,$03,$33,$85,$43,$4b,$50
>2768	41 fd 04 38 34 be 84 8b			.byte	$41,$fd,$04,$38,$34,$be,$84,$8b
>2770	41 00 14 54 0b dc bd 8b			.byte	$41,$00,$14,$54,$0b,$dc,$bd,$8b
>2778	53 77 4a 85 8b 42 5c 4b			.byte	$53,$77,$4a,$85,$8b,$42,$5c,$4b
>2780	6b be 84 8b 41 00 12 5e			.byte	$6b,$be,$84,$8b,$41,$00,$12,$5e
>2788	0b dc bd 8b 57 69 51 80			.byte	$0b,$dc,$bd,$8b,$57,$69,$51,$80
>2790	41 65 61 be 84 44 61 00			.byte	$41,$65,$61,$be,$84,$44,$61,$00
>2798	10 68 0b dc 98 42 6d 44			.byte	$10,$68,$0b,$dc,$98,$42,$6d,$44
>27a0	49 84 8b 42 6d 44 4a 00			.byte	$49,$84,$8b,$42,$6d,$44,$4a,$00
>27a8	0e 72 0b dc 9b fe 04 6f			.byte	$0e,$72,$0b,$dc,$9b,$fe,$04,$6f
>27b0	68 be 84 41 6f 00 1b 7c			.byte	$68,$be,$84,$41,$6f,$00,$1b,$7c
>27b8	0b dc bd 42 75 44 63 fd			.byte	$0b,$dc,$bd,$42,$75,$44,$63,$fd
>27c0	04 37 34 84 42 75 44 63			.byte	$04,$37,$34,$84,$42,$75,$44,$63
>27c8	fd 04 37 34 be 84 8b 41			.byte	$fd,$04,$37,$34,$be,$84,$8b,$41
>27d0	00 13 86 0b dc bd 41 47			.byte	$00,$13,$86,$0b,$dc,$bd,$41,$47
>27d8	45 7c 88 8b 55 47 6b be			.byte	$45,$7c,$88,$8b,$55,$47,$6b,$be
>27e0	84 8b 41 00 18 90 0b dc			.byte	$84,$8b,$41,$00,$18,$90,$0b,$dc
>27e8	bd 8b 42 57 48 44 80 8b			.byte	$bd,$8b,$42,$57,$48,$44,$80,$8b
>27f0	43 64 6e 73 be 84 8b 43			.byte	$43,$64,$6e,$73,$be,$84,$8b,$43
>27f8	77 6e 74 00 12 9a 0b dc			.byte	$77,$6e,$74,$00,$12,$9a,$0b,$dc
>2800	a5 a4 40 fd 03 30 be be			.byte	$a5,$a4,$40,$fd,$03,$30,$be,$be
>2808	84 40 fd 03 30 00 0d a4			.byte	$84,$40,$fd,$03,$30,$00,$0d,$a4
>2810	0b dc b4 41 74 be 84 fe			.byte	$0b,$dc,$b4,$41,$74,$be,$84,$fe
>2818	03 74 00 1c ae 0b dc bd			.byte	$03,$74,$00,$1c,$ae,$0b,$dc,$bd
>2820	8b 42 73 4b 7c fd 04 31			.byte	$8b,$42,$73,$4b,$7c,$fd,$04,$31
>2828	38 86 8b 42 73 4b 7c fd			.byte	$38,$86,$8b,$42,$73,$4b,$7c,$fd
>2830	04 31 38 be 84 40 00 11			.byte	$04,$31,$38,$be,$84,$40,$00,$11
>2838	b8 0b dc bd 5f 5d 62 89			.byte	$b8,$0b,$dc,$bd,$5f,$5d,$62,$89
>2840	41 7a 5c 4a be 84 40 00			.byte	$41,$7a,$5c,$4a,$be,$84,$40,$00
>2848	15 c2 0b dc bd 43 43 5c			.byte	$15,$c2,$0b,$dc,$bd,$43,$43,$5c
>2850	41 82 41 57 7b 46 be 84			.byte	$41,$82,$41,$57,$7b,$46,$be,$84
>2858	42 54 67 47 00 11 cc 0b			.byte	$42,$54,$67,$47,$00,$11,$cc,$0b
>2860	dc 9a 8b 42 7c 4a 44 be			.byte	$dc,$9a,$8b,$42,$7c,$4a,$44,$be
>2868	84 42 7c 4a 44 00 17 d6			.byte	$84,$42,$7c,$4a,$44,$00,$17,$d6
>2870	0b dc a3 4c be 84 fe 0e			.byte	$0b,$dc,$a3,$4c,$be,$84,$fe,$0e
>2878	20 20 20 20 20 20 20 20			.byte	$20,$20,$20,$20,$20,$20,$20,$20
>2880	20 20 20 20 00 1a e0 0b			.byte	$20,$20,$20,$20,$00,$1a,$e0,$0b
>2888	dc bd 41 57 57 7a fd 04			.byte	$dc,$bd,$41,$57,$57,$7a,$fd,$04
>2890	36 38 88 43 66 72 44 fd			.byte	$36,$38,$88,$43,$66,$72,$44,$fd
>2898	04 38 31 be 84 40 00 13			.byte	$04,$38,$31,$be,$84,$40,$00,$13
>28a0	ea 0b dc bd 8b 5c 68 77			.byte	$ea,$0b,$dc,$bd,$8b,$5c,$68,$77
>28a8	85 8b 7a 60 4a be 84 8b			.byte	$85,$8b,$7a,$60,$4a,$be,$84,$8b
>28b0	41 00 10 f4 0b dc bd 40			.byte	$41,$00,$10,$f4,$0b,$dc,$bd,$40
>28b8	80 8b 42 47 6f 5d be 84			.byte	$80,$8b,$42,$47,$6f,$5d,$be,$84
>28c0	40 00 0c fe 0b dc b3 53			.byte	$40,$00,$0c,$fe,$0b,$dc,$b3,$53
>28c8	7e 46 be 84 41 00 13 08			.byte	$7e,$46,$be,$84,$41,$00,$13,$08
>28d0	0c dc a7 41 79 50 47 be			.byte	$0c,$dc,$a7,$41,$79,$50,$47,$be
>28d8	84 fe 07 37 39 34 30 37			.byte	$84,$fe,$07,$37,$39,$34,$30,$37
>28e0	00 1a 12 0c dc bd 41 43			.byte	$00,$1a,$12,$0c,$dc,$bd,$41,$43
>28e8	4c 5b fd 04 39 38 85 43			.byte	$4c,$5b,$fd,$04,$39,$38,$85,$43
>28f0	44 43 4f fd 03 33 be 84			.byte	$44,$43,$4f,$fd,$03,$33,$be,$84
>28f8	8b 41 00 13 1c 0c dc bd			.byte	$8b,$41,$00,$13,$1c,$0c,$dc,$bd
>2900	8b 43 5e 78 84 8b 43 6a			.byte	$8b,$43,$5e,$78,$84,$8b,$43,$6a
>2908	43 6d be 84 40 00 17 26			.byte	$43,$6d,$be,$84,$40,$00,$17,$26
>2910	0c dc bd 8b 41 66 51 46			.byte	$0c,$dc,$bd,$8b,$41,$66,$51,$46
>2918	82 8b 43 52 47 63 be 84			.byte	$82,$8b,$43,$52,$47,$63,$be,$84
>2920	42 74 56 67 00 13 30 0c			.byte	$42,$74,$56,$67,$00,$13,$30,$0c
>2928	dc b2 41 6f 6a 5d bf 55			.byte	$dc,$b2,$41,$6f,$6a,$5d,$bf,$55
>2930	45 7f be 84 46 4c 62 00			.byte	$45,$7f,$be,$84,$46,$4c,$62,$00
>2938	13 3a 0c dc af fe 07 43			.byte	$13,$3a,$0c,$dc,$af,$fe,$07,$43
>2940	42 33 38 44 be 84 43 4b			.byte	$42,$33,$38,$44,$be,$84,$43,$4b
>2948	4e 4d 00 27 44 0c dc bd			.byte	$4e,$4d,$00,$27,$44,$0c,$dc,$bd
>2950	43 72 6b 6c fd 04 38 35			.byte	$43,$72,$6b,$6c,$fd,$04,$38,$35
>2958	8c 43 72 6b 6c fd 04 38			.byte	$8c,$43,$72,$6b,$6c,$fd,$04,$38
>2960	35 be 84 49 fd 0d 38 38			.byte	$35,$be,$84,$49,$fd,$0d,$38,$38
>2968	30 39 33 33 36 35 65 31			.byte	$30,$39,$33,$33,$36,$35,$65,$31
>2970	31 00 16 4e 0c dc bd 8b			.byte	$31,$00,$16,$4e,$0c,$dc,$bd,$8b
>2978	50 54 8c 42 49 60 65 be			.byte	$50,$54,$8c,$42,$49,$60,$65,$be
>2980	84 8b 63 43 47 5b 64 00			.byte	$84,$8b,$63,$43,$47,$5b,$64,$00
>2988	12 58 0c dc bd 40 82 8b			.byte	$12,$58,$0c,$dc,$bd,$40,$82,$8b
>2990	5f 4f 6a be 84 8b 5f 4f			.byte	$5f,$4f,$6a,$be,$84,$8b,$5f,$4f
>2998	6a 00 10 62 0c dc 98 8b			.byte	$6a,$00,$10,$62,$0c,$dc,$98,$8b
>29a0	42 6c 5c 42 84 42 6c 5c			.byte	$42,$6c,$5c,$42,$84,$42,$6c,$5c
>29a8	41 00 10 6c 0c dc a0 fe			.byte	$41,$00,$10,$6c,$0c,$dc,$a0,$fe
>29b0	03 79 bf 47 be 84 fe 03			.byte	$03,$79,$bf,$47,$be,$84,$fe,$03
>29b8	79 00 19 76 0c dc bd 40			.byte	$79,$00,$19,$76,$0c,$dc,$bd,$40
>29c0	fd 03 30 8d 42 41 77 5d			.byte	$fd,$03,$30,$8d,$42,$41,$77,$5d
>29c8	fd 04 36 31 be 84 40 fd			.byte	$fd,$04,$36,$31,$be,$84,$40,$fd
>29d0	03 30 00 14 80 0c dc bd			.byte	$03,$30,$00,$14,$80,$0c,$dc,$bd
>29d8	70 71 6a 8b 8b 71 7a 5a			.byte	$70,$71,$6a,$8b,$8b,$71,$7a,$5a
>29e0	be 84 41 62 6c 44 00 12			.byte	$be,$84,$41,$62,$6c,$44,$00,$12
>29e8	8a 0c dc bd 8b 66 75 57			.byte	$8a,$0c,$dc,$bd,$8b,$66,$75,$57
>29f0	80 44 6d 49 be 84 48 49			.byte	$80,$44,$6d,$49,$be,$84,$48,$49
>29f8	00 14 94 0c dc a5 a4 8b			.byte	$00,$14,$94,$0c,$dc,$a5,$a4,$8b
>2a00	42 46 73 63 be be 84 8b			.byte	$42,$46,$73,$63,$be,$be,$84,$8b
>2a08	42 46 73 63 00 18 9e 0c			.byte	$42,$46,$73,$63,$00,$18,$9e,$0c
>2a10	dc a1 fe 08 70 77 77 72			.byte	$dc,$a1,$fe,$08,$70,$77,$77,$72
>2a18	76 66 bf 44 be 84 fe 06			.byte	$76,$66,$bf,$44,$be,$84,$fe,$06
>2a20	77 72 76 66 00 17 a8 0c			.byte	$77,$72,$76,$66,$00,$17,$a8,$0c
>2a28	dc bd 8b 43 58 45 55 fd			.byte	$dc,$bd,$8b,$43,$58,$45,$55,$fd
>2a30	04 35 36 84 40 fd 03 30			.byte	$04,$35,$36,$84,$40,$fd,$03,$30
>2a38	be 84 40 00 14 b2 0c dc			.byte	$be,$84,$40,$00,$14,$b2,$0c,$dc
>2a40	bd 8b 41 7c 5d 72 87 8b			.byte	$bd,$8b,$41,$7c,$5d,$72,$87,$8b
>2a48	5f 5c 76 be 84 8b 41 00			.byte	$5f,$5c,$76,$be,$84,$8b,$41,$00
>2a50	15 bc 0c dc bd 42 68 6f			.byte	$15,$bc,$0c,$dc,$bd,$42,$68,$6f
>2a58	4b 80 8b 42 77 56 41 be			.byte	$4b,$80,$8b,$42,$77,$56,$41,$be
>2a60	84 48 69 4b 00 11 c6 0c			.byte	$84,$48,$69,$4b,$00,$11,$c6,$0c
>2a68	dc 9a 8b 43 61 6e 4c be			.byte	$dc,$9a,$8b,$43,$61,$6e,$4c,$be
>2a70	84 43 61 6e 4c 00 11 d0			.byte	$84,$43,$61,$6e,$4c,$00,$11,$d0
>2a78	0c dc a2 fe 03 75 bf 47			.byte	$0c,$dc,$a2,$fe,$03,$75,$bf,$47
>2a80	bf 41 be 84 fe 02 00 23			.byte	$bf,$41,$be,$84,$fe,$02,$00,$23
>2a88	da 0c dc bd 8b 41 66 47			.byte	$da,$0c,$dc,$bd,$8b,$41,$66,$47
>2a90	6b fd 04 35 32 8a 50 62			.byte	$6b,$fd,$04,$35,$32,$8a,$50,$62
>2a98	63 fd 05 31 33 39 be 84			.byte	$63,$fd,$05,$31,$33,$39,$be,$84
>2aa0	8b 41 55 65 48 fd 04 33			.byte	$8b,$41,$55,$65,$48,$fd,$04,$33
>2aa8	38 00 10 e4 0c dc bd 40			.byte	$38,$00,$10,$e4,$0c,$dc,$bd,$40
>2ab0	86 42 47 68 76 be 84 8b			.byte	$86,$42,$47,$68,$76,$be,$84,$8b
>2ab8	41 00 16 ee 0c dc bd 41			.byte	$41,$00,$16,$ee,$0c,$dc,$bd,$41
>2ac0	6d 58 4b 80 8b 42 54 54			.byte	$6d,$58,$4b,$80,$8b,$42,$54,$54
>2ac8	5e be 84 41 69 48 42 00			.byte	$5e,$be,$84,$41,$69,$48,$42,$00
>2ad0	0a f8 0c dc b3 40 be 84			.byte	$0a,$f8,$0c,$dc,$b3,$40,$be,$84
>2ad8	40 00 0c 02 0d dc a6 fe			.byte	$40,$00,$0c,$02,$0d,$dc,$a6,$fe
>2ae0	03 70 be 84 41 00 1b 0c			.byte	$03,$70,$be,$84,$41,$00,$1b,$0c
>2ae8	0d dc bd 8b 42 5b 52 59			.byte	$0d,$dc,$bd,$8b,$42,$5b,$52,$59
>2af0	fd 04 36 39 87 42 76 64			.byte	$fd,$04,$36,$39,$87,$42,$76,$64
>2af8	58 fd 03 34 be 84 8b 41			.byte	$58,$fd,$03,$34,$be,$84,$8b,$41
>2b00	00 13 16 0d dc bd 8b 41			.byte	$00,$13,$16,$0d,$dc,$bd,$8b,$41
>2b08	76 70 7a 8d 41 78 62 4e			.byte	$76,$70,$7a,$8d,$41,$78,$62,$4e
>2b10	be 84 40 00 16 20 0d dc			.byte	$be,$84,$40,$00,$16,$20,$0d,$dc
>2b18	bd 41 68 74 77 82 8b 58			.byte	$bd,$41,$68,$74,$77,$82,$8b,$58
>2b20	6f 4d be 84 8b 41 70 5b			.byte	$6f,$4d,$be,$84,$8b,$41,$70,$5b
>2b28	7c 00 16 2a 0d dc b2 42			.byte	$7c,$00,$16,$2a,$0d,$dc,$b2,$42
>2b30	54 57 4e bf 8b 42 5e 52			.byte	$54,$57,$4e,$bf,$8b,$42,$5e,$52
>2b38	78 be 84 42 54 57 4e 00			.byte	$78,$be,$84,$42,$54,$57,$4e,$00
>2b40	13 34 0d dc 9b fe 09 77			.byte	$13,$34,$0d,$dc,$9b,$fe,$09,$77
>2b48	66 65 6c 64 72 73 be 84			.byte	$66,$65,$6c,$64,$72,$73,$be,$84
>2b50	41 77 00 23 3e 0d dc bd			.byte	$41,$77,$00,$23,$3e,$0d,$dc,$bd
>2b58	8b 47 40 58 fd 05 35 34			.byte	$8b,$47,$40,$58,$fd,$05,$35,$34
>2b60	37 8b 8b 43 45 77 72 fd			.byte	$37,$8b,$8b,$43,$45,$77,$72,$fd
>2b68	04 36 33 be 84 42 7e 77			.byte	$04,$36,$33,$be,$84,$42,$7e,$77
>2b70	5a fd 04 30 38 00 13 48			.byte	$5a,$fd,$04,$30,$38,$00,$13,$48
>2b78	0d dc bd 42 48 53 49 8d			.byte	$0d,$dc,$bd,$42,$48,$53,$49,$8d
>2b80	8b 42 5d 51 51 be 84 40			.byte	$8b,$42,$5d,$51,$51,$be,$84,$40
>2b88	00 18 52 0d dc bd 8b 41			.byte	$00,$18,$52,$0d,$dc,$bd,$8b,$41
>2b90	45 55 4e 80 8b 43 4b 7c			.byte	$45,$55,$4e,$80,$8b,$43,$4b,$7c
>2b98	79 be 84 8b 43 4f 7d 7e			.byte	$79,$be,$84,$8b,$43,$4f,$7d,$7e
>2ba0	00 10 5c 0d dc 98 8b 43			.byte	$00,$10,$5c,$0d,$dc,$98,$8b,$43
>2ba8	72 46 44 84 43 72 46 43			.byte	$72,$46,$44,$84,$43,$72,$46,$43
>2bb0	00 0d 66 0d dc b4 41 7a			.byte	$00,$0d,$66,$0d,$dc,$b4,$41,$7a
>2bb8	be 84 fe 03 7a 00 1a 70			.byte	$be,$84,$fe,$03,$7a,$00,$1a,$70
>2bc0	0d dc bd 41 41 51 75 fd			.byte	$0d,$dc,$bd,$41,$41,$51,$75,$fd
>2bc8	03 37 84 8b 41 5b 4c 7b			.byte	$03,$37,$84,$8b,$41,$5b,$4c,$7b
>2bd0	fd 04 34 38 be 84 40 00			.byte	$fd,$04,$34,$38,$be,$84,$40,$00
>2bd8	14 7a 0d dc bd 8b 42 48			.byte	$14,$7a,$0d,$dc,$bd,$8b,$42,$48
>2be0	72 4d 86 42 40 7d 7d be			.byte	$72,$4d,$86,$42,$40,$7d,$7d,$be
>2be8	84 8b 41 00 16 84 0d dc			.byte	$84,$8b,$41,$00,$16,$84,$0d,$dc
>2bf0	bd 8b 54 56 61 82 8b 43			.byte	$bd,$8b,$54,$56,$61,$82,$8b,$43
>2bf8	5e 71 5b be 84 43 4a 67			.byte	$5e,$71,$5b,$be,$84,$43,$4a,$67
>2c00	7a 00 1a 8e 0d dc a5 a4			.byte	$7a,$00,$1a,$8e,$0d,$dc,$a5,$a4
>2c08	42 71 61 4c fd 04 34 39			.byte	$42,$71,$61,$4c,$fd,$04,$34,$39
>2c10	be be 84 42 71 61 4c fd			.byte	$be,$be,$84,$42,$71,$61,$4c,$fd
>2c18	04 34 39 00 1e 98 0d dc			.byte	$04,$34,$39,$00,$1e,$98,$0d,$dc
>2c20	a3 53 be 84 fe 15 20 20			.byte	$a3,$53,$be,$84,$fe,$15,$20,$20
>2c28	20 20 20 20 20 20 20 20			.byte	$20,$20,$20,$20,$20,$20,$20,$20
>2c30	20 20 20 20 20 20 20 20			.byte	$20,$20,$20,$20,$20,$20,$20,$20
>2c38	20 00 29 a2 0d d6 fe 22			.byte	$20,$00,$29,$a2,$0d,$d6,$fe,$22
>2c40	50 61 73 73 65 64 20 41			.byte	$50,$61,$73,$73,$65,$64,$20,$41
>2c48	72 69 74 68 6d 65 74 69			.byte	$72,$69,$74,$68,$6d,$65,$74,$69
>2c50	63 2c 4c 6f 67 69 63 61			.byte	$63,$2c,$4c,$6f,$67,$69,$63,$61
>2c58	6c 2c 55 6e 61 72 79 2e			.byte	$6c,$2c,$55,$6e,$61,$72,$79,$2e
>2c60	c0 c4 00 00				.byte	$c0,$c4,$00,$00

;******  Return to file: modules/hardware/em65816.asm

.c000					StartROM:
.c000	18		clc				clc
.c001	fb		xce				xce
.c002	c2 30		rep #$30			rep 	#$30
.c004	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.c007	1b		tcs				tcs
.c008	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.c00b	e2 30		sep #$30			sep 	#$30
.c00d	c2 30		rep #$30			rep 	#$30						; clear AXY in 16 bit.
.c00f	a9 00		lda #$00			lda 	#$0000
.c011	aa		tax				tax
.c012	a8		tay				tay
.c013	e2 30		sep #$30			sep 	#$30
.c015	5c 01 88 01	jmp $018801		jmp BASIC_Start
.c019					TIM_BreakHandler:
.c019	5c 69 83 01	jmp $018369			jmp 	TIM_BreakVector

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.018000					IFT_ClearScreen:
.018000	48		pha				pha
.018001	da		phx				phx
.018002	5a		phy				phy
.018003	20 9c 81	jsr $01819c			jsr 	IF_Home 					; home cursor
.018006	a2 20		ldx #$20			ldx 	#IF_Height 					; this many lines.
.018008					_IFT_CS0:
.018008	a0 40		ldy #$40			ldy 	#IF_Width 					; this many chars/line
.01800a					_IFT_CS1:
.01800a	a9 20		lda #$20			lda 	#' '						; clear line.
.01800c	20 c8 81	jsr $0181c8			jsr 	IF_Write
.01800f	88		dey				dey
.018010	d0 f8		bne $01800a			bne 	_IFT_CS1
.018012	20 af 81	jsr $0181af			jsr 	IF_NewLine 					; next line down
.018015	ca		dex				dex
.018016	d0 f0		bne $018008			bne 	_IFT_CS0
.018018	7a		ply				ply
.018019	fa		plx				plx
.01801a	68		pla				pla
.01801b					IFT_HomeCursor:
.01801b	48		pha				pha
.01801c	20 9c 81	jsr $01819c			jsr 	IF_Home
.01801f	a9 00		lda #$00			lda 	#0
.018021	8d 00 05	sta $0500			sta 	IFT_XCursor
.018024	8d 01 05	sta $0501			sta 	IFT_YCursor
.018027	68		pla				pla
.018028	60		rts				rts
.018029					IFT_UpLine:
.018029	48		pha				pha
.01802a	ad 01 05	lda $0501			lda  	IFT_YCursor 				; get Y
.01802d	3a		dec a				dec 	a 							; line above
.01802e	30 03		bmi $018033			bmi 	_IFTULExit 					; too far, abort
.018030	20 be 80	jsr $0180be			jsr 	IFT_SetYPos					; set to that line.
.018033					_IFTULExit:
.018033	68		pla				pla
.018034	60		rts				rts
.018035					IFT_PrintCharacter:
.018035	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.018037	f0 16		beq $01804f			beq 	IFT_NewLine
.018039	48		pha				pha
.01803a	20 67 80	jsr $018067			jsr 	IFT_UpperCase 				; make upper case
.01803d	20 c8 81	jsr $0181c8			jsr 	IF_Write 					; write out.
.018040	ee 00 05	inc $0500			inc 	IFT_XCursor 				; bump x cursor
.018043	ad 00 05	lda $0500			lda 	IFT_XCursor 				; reached RHS ?
.018046	c9 40		cmp #$40			cmp 	#IF_Width
.018048	d0 03		bne $01804d			bne 	_IFT_PCNotEOL
.01804a	20 4f 80	jsr $01804f			jsr 	IFT_NewLine 				; if so do new line.
.01804d					_IFT_PCNotEOL:
.01804d	68		pla				pla
.01804e	60		rts				rts
.01804f					IFT_NewLine:
.01804f	48		pha				pha
.018050	20 af 81	jsr $0181af			jsr 	IF_NewLine 					; new line on actual screen.
.018053	a9 00		lda #$00			lda 	#0 							; reset x position
.018055	8d 00 05	sta $0500			sta 	IFT_XCursor
.018058	ee 01 05	inc $0501			inc 	IFT_YCursor 				; move down.
.01805b	ad 01 05	lda $0501			lda 	IFT_YCursor
.01805e	c9 20		cmp #$20			cmp 	#IF_Height 					; reached bottom.
.018060	d0 03		bne $018065			bne 	_IFT_NL_NotEOS
.018062	20 72 80	jsr $018072			jsr 	IFT_Scroll 					; scroll screen up.
.018065					_IFT_NL_NotEOS:
.018065	68		pla				pla
.018066	60		rts				rts
.018067					IFT_UpperCase:
.018067	c9 61		cmp #$61			cmp 	#"a"
.018069	90 06		bcc $018071			bcc 	_IFT_UCExit
.01806b	c9 7b		cmp #$7b			cmp 	#"z"+1
.01806d	b0 02		bcs $018071			bcs 	_IFT_UCExit
.01806f	49 20		eor #$20			eor 	#$20
.018071					_IFT_UCExit:
.018071	60		rts				rts
.018072					IFT_Scroll:
.018072	48		pha				pha 								; save AXY
.018073	da		phx				phx
.018074	5a		phy				phy
.018075	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.018077					_IFT_SLoop:
.018077	20 97 80	jsr $018097			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.01807a	e8		inx				inx
.01807b	e0 1f		cpx #$1f			cpx 	#IF_Height-1				; do whole screen
.01807d	d0 f8		bne $018077			bne 	_IFT_SLoop
.01807f	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.018081	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.018084	a2 40		ldx #$40			ldx 	#IF_Width 					; blank line
.018086					_IFT_SBlank:
.018086	a9 20		lda #$20			lda 	#32
.018088	20 c8 81	jsr $0181c8			jsr 	IF_Write
.01808b	ca		dex				dex
.01808c	d0 f8		bne $018086			bne 	_IFT_SBlank
.01808e	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.018090	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.018093	7a		ply				ply
.018094	fa		plx				plx
.018095	68		pla				pla
.018096	60		rts				rts
.018097					_IFT_ScrollLine:
.018097	da		phx				phx
.018098	da		phx				phx
.018099	8a		txa				txa 								; copy line into buffer.
.01809a	1a		inc a				inc 	a 							; next line down.
.01809b	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.01809e	a2 00		ldx #$00			ldx 	#0
.0180a0					_IFTScrollCopy1:
.0180a0	20 bf 81	jsr $0181bf			jsr 	IF_Read
.0180a3	9d 02 05	sta $0502,x			sta 	IFT_Buffer,x
.0180a6	e8		inx				inx
.0180a7	e0 40		cpx #$40			cpx 	#IF_Width
.0180a9	d0 f5		bne $0180a0			bne 	_IFTScrollCopy1
.0180ab	68		pla				pla
.0180ac	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.0180af	a2 00		ldx #$00			ldx 	#0
.0180b1					_IFTScrollCopy2:
.0180b1	bd 02 05	lda $0502,x			lda 	IFT_Buffer,x
.0180b4	20 c8 81	jsr $0181c8			jsr 	IF_Write
.0180b7	e8		inx				inx
.0180b8	e0 40		cpx #$40			cpx 	#IF_Width
.0180ba	d0 f5		bne $0180b1			bne 	_IFTScrollCopy2
.0180bc	fa		plx				plx
.0180bd	60		rts				rts
.0180be					IFT_SetYPos:
.0180be	48		pha				pha
.0180bf	da		phx				phx
.0180c0	aa		tax				tax
.0180c1	20 1b 80	jsr $01801b			jsr 	IFT_HomeCursor
.0180c4	e0 00		cpx #$00			cpx 	#0
.0180c6	f0 09		beq $0180d1			beq 	_IFT_MOAExit
.0180c8					_IFT_MOALoop:
.0180c8	20 af 81	jsr $0181af			jsr 	IF_NewLine
.0180cb	ee 01 05	inc $0501			inc 	IFT_YCursor
.0180ce	ca		dex				dex
.0180cf	d0 f7		bne $0180c8			bne		_IFT_MOALoop
.0180d1					_IFT_MOAExit:
.0180d1	fa		plx				plx
.0180d2	68		pla				pla
.0180d3	60		rts				rts
.0180d4					IFT_GetKeyCursor:
.0180d4	20 dc 80	jsr $0180dc			jsr 	_IFT_FlipCursor 			; reverse current
.0180d7					_IFT_GKCWait:
.0180d7	20 d9 81	jsr $0181d9			jsr 	IF_GetKey 					; get key
.0180da	f0 fb		beq $0180d7			beq 	_IFT_GKCWait
.0180dc					_IFT_FlipCursor:
.0180dc	48		pha				pha 								; save
.0180dd	20 bf 81	jsr $0181bf			jsr 	IF_Read 					; read
.0180e0	20 d1 81	jsr $0181d1			jsr 	IF_LeftOne
.0180e3	49 80		eor #$80			eor 	#$80 						; reverse
.0180e5	20 c8 81	jsr $0181c8			jsr 	IF_Write 					; write
.0180e8	20 d1 81	jsr $0181d1			jsr 	IF_LeftOne
.0180eb	68		pla				pla
.0180ec	60		rts				rts
.0180ed					IFT_ReadLine:
.0180ed	48		pha				pha
.0180ee					_IFT_RLLoop:
.0180ee	20 d4 80	jsr $0180d4			jsr 	IFT_GetKeyCursor 			; get keystroke
.0180f1	c9 0d		cmp #$0d			cmp 	#13							; return
.0180f3	f0 7d		beq $018172			beq 	_IFT_RLExit
.0180f5	c9 20		cmp #$20			cmp 	#32 						; control character
.0180f7	90 05		bcc $0180fe			bcc 	_IFT_Control
.0180f9	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0180fc	80 f0		bra $0180ee			bra 	_IFT_RLLoop
.0180fe					_IFT_Control:
.0180fe	c9 01		cmp #$01			cmp 	#"A"-64
.018100	f0 26		beq $018128			beq 	_IFT_Left
.018102	c9 04		cmp #$04			cmp 	#"D"-64
.018104	f0 2e		beq $018134			beq 	_IFT_Right
.018106	c9 17		cmp #$17			cmp 	#"W"-64
.018108	f0 36		beq $018140			beq 	_IFT_Up
.01810a	c9 13		cmp #$13			cmp 	#"S"-64
.01810c	f0 3e		beq $01814c			beq 	_IFT_Down
.01810e	c9 08		cmp #$08			cmp 	#"H"-64
.018110	f0 09		beq $01811b			beq 	_IFT_Backspace
.018112	c9 1a		cmp #$1a			cmp 	#"Z"-64
.018114	d0 d8		bne $0180ee			bne 	_IFT_RLLoop
.018116	20 00 80	jsr $018000			jsr 	IFT_ClearScreen				; clear CTL-Z
.018119	80 d3		bra $0180ee			bra 	_IFT_RLLoop
.01811b					_IFT_Backspace:
.01811b	ad 00 05	lda $0500			lda 	IFT_XCursor 				; check not start of line.
.01811e	f0 ce		beq $0180ee			beq 	_IFT_RLLoop
.018120	20 d1 81	jsr $0181d1			jsr 	IF_LeftOne
.018123	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.018125	20 c8 81	jsr $0181c8			jsr 	IF_Write
.018128					_IFT_Left:
.018128	ce 00 05	dec $0500			dec 	IFT_XCursor 				; left CTL-W
.01812b	10 29		bpl $018156			bpl 	_IFT_Reposition
.01812d	a9 3f		lda #$3f			lda 	#IF_Width-1
.01812f					_IFT_SetX:
.01812f	8d 00 05	sta $0500			sta 	IFT_XCursor
.018132	80 22		bra $018156			bra 	_IFT_Reposition
.018134					_IFT_Right:
.018134	ee 00 05	inc $0500			inc 	IFT_XCursor
.018137	ad 00 05	lda $0500			lda 	IFT_XCursor
.01813a	49 40		eor #$40			eor 	#IF_Width
.01813c	f0 f1		beq $01812f			beq 	_IFT_SetX
.01813e	80 16		bra $018156			bra 	_IFT_Reposition
.018140					_IFT_Up:
.018140	ce 01 05	dec $0501			dec 	IFT_YCursor
.018143	10 11		bpl $018156			bpl 	_IFT_Reposition
.018145	a9 1f		lda #$1f			lda 	#IF_Height-1
.018147					_IFT_SetY:
.018147	8d 01 05	sta $0501			sta 	IFT_YCursor
.01814a	80 0a		bra $018156			bra 	_IFT_Reposition
.01814c					_IFT_Down:
.01814c	ee 01 05	inc $0501			inc 	IFT_YCursor
.01814f	ad 01 05	lda $0501			lda 	IFT_YCursor
.018152	49 20		eor #$20			eor 	#IF_Height
.018154	f0 f1		beq $018147			beq 	_IFT_SetY
.018156					_IFT_Reposition:
.018156	ad 00 05	lda $0500			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.018159	48		pha				pha
.01815a	ad 01 05	lda $0501			lda 	IFT_YCursor
.01815d	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.018160	68		pla				pla
.018161	aa		tax				tax
.018162	e0 00		cpx #$00			cpx 	#0
.018164	f0 88		beq $0180ee			beq 	_IFT_RLLoop
.018166					_IFT_MoveRight:
.018166	20 bf 81	jsr $0181bf			jsr 	IF_Read
.018169	ee 00 05	inc $0500			inc 	IFT_XCursor
.01816c	ca		dex				dex
.01816d	d0 f7		bne $018166			bne 	_IFT_MoveRight
.01816f	4c ee 80	jmp $0180ee			jmp 	_IFT_RLLoop
.018172					_IFT_RLExit:
.018172	ad 01 05	lda $0501			lda 	IFT_YCursor 				; go to start of line.
.018175	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.018178	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.01817a					_IFT_RLRead:
.01817a	20 bf 81	jsr $0181bf			jsr 	IF_Read
.01817d	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.018180	e8		inx				inx
.018181	e0 40		cpx #$40			cpx 	#IF_Width
.018183	d0 f5		bne $01817a			bne 	_IFT_RLRead
.018185					_IFT_RL_Trim:
.018185	ca		dex				dex 	 							; previous char
.018186	30 07		bmi $01818f			bmi 	_IFT_Found 					; gone too far
.018188	bd 66 05	lda $0566,x			lda 	IFT_LineBuffer,x			; go back if space
.01818b	c9 20		cmp #$20			cmp 	#" "
.01818d	f0 f6		beq $018185			beq 	_IFT_RL_Trim
.01818f					_IFT_Found:
.01818f	e8		inx				inx 								; forward to non-space
.018190	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.018192	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.018195	68		pla				pla
.018196	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.018198	a0 05		ldy #$05			ldy 	#IFT_LineBuffer >> 8
.01819a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_em65816.asm

=64					IF_Width 	= 64 							; characters across
=32					IF_Height 	= 32 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line.
=8					IF_XPos 	= 8 							; current position, horizontal.
=$f0000					IF_Screen = $F0000							; 2k screen RAM here
=$f8010					IF_PKeyboard = $F8010						; Keyboard port.
=$f8000					IF_PBreak = $F8000 							; Break key.
.01819b					IF_Reset:
.01819b	60		rts				rts
.01819c					IF_Home:
.01819c	48		pha				pha
.01819d	64 08		stz $08				stz 	IF_XPos 					; zero X position
.01819f	a9 00		lda #$00			lda 	#IF_Screen & $FF 			; set r/w pos.
.0181a1	85 04		sta $04				sta 	IF_Pos
.0181a3	a9 00		lda #$00			lda 	#(IF_Screen >> 8) & $FF
.0181a5	85 05		sta $05				sta 	IF_Pos+1
.0181a7	a9 0f		lda #$0f			lda 	#IF_Screen >> 16
.0181a9	85 06		sta $06				sta 	IF_Pos+2
.0181ab	64 07		stz $07				stz 	IF_Pos+3
.0181ad	68		pla				pla
.0181ae	60		rts				rts
.0181af					IF_NewLine:
.0181af	48		pha				pha
.0181b0	64 08		stz $08				stz 	IF_XPos						; back to start of line
.0181b2	18		clc				clc 								; down one line
.0181b3	a5 04		lda $04				lda 	IF_Pos
.0181b5	69 40		adc #$40			adc 	#64
.0181b7	85 04		sta $04				sta 	IF_Pos
.0181b9	90 02		bcc $0181bd			bcc 	_IF_NoCarry 				; carry through.
.0181bb	e6 05		inc $05				inc 	IF_Pos+1
.0181bd					_IF_NoCarry:
.0181bd	68		pla				pla
.0181be	60		rts				rts
.0181bf					IF_Read:
.0181bf	5a		phy				phy 								; save current Y
.0181c0	a4 08		ldy $08				ldy 	IF_XPos 					; read character at current position
.0181c2	b7 04		lda [$04],y			lda 	[IF_Pos],y
.0181c4	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181c6	7a		ply				ply									; restore Y
.0181c7	60		rts				rts
.0181c8					IF_Write:
.0181c8	5a		phy				phy 								; save current Y
.0181c9	a4 08		ldy $08				ldy 	IF_XPos 					; write character at current position
.0181cb	97 04		sta [$04],y			sta 	[IF_Pos],y
.0181cd	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181cf	7a		ply				ply									; restore Y
.0181d0	60		rts				rts
.0181d1					IF_LeftOne:
.0181d1	c6 08		dec $08				dec 	IF_XPos
.0181d3	60		rts				rts
.0181d4					IF_CheckBreak:
.0181d4	af 00 80 0f	lda $0f8000			lda 	IF_PBreak					; non-zero if Ctrl+C pressed.
.0181d8	60		rts				rts
.0181d9					IF_GetKey:
.0181d9	af 10 80 0f	lda $0f8010			lda 	IF_PKeyboard				; read keyboard
.0181dd	f0 08		beq $0181e7			beq		_IFGK_NoKey 				; skip if zero,no key pressed
.0181df	48		pha				pha 								; key pressed, clear queue.
.0181e0	a9 00		lda #$00			lda 	#0
.0181e2	8f 10 80 0f	sta $0f8010			sta 	IF_PKeyboard
.0181e6	68		pla				pla
.0181e7					_IFGK_NoKey:
.0181e7	09 00		ora #$00			ora 	#0							; set Z flag appropriately.
.0181e9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.0181ea					TIM_Error:
.0181ea	20 29 80	jsr $018029			jsr 	IFT_UpLine 					; go up one line.
.0181ed	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.0181ef	80 02		bra $0181f3			bra 	TIM_ShowPrompt
.0181f1					TIM_NewCommand:
.0181f1	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.0181f3					TIM_ShowPrompt:
.0181f3	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.0181f6	20 ed 80	jsr $0180ed			jsr 	IFT_ReadLine	 			; get character, go to next line
.0181f9	20 4f 80	jsr $01804f			jsr 	IFT_NewLine					; go to next line.
.0181fc	86 10		stx $10				stx 	zTemp1 						; save line read address
.0181fe	84 11		sty $11				sty 	zTemp1+1
.018200	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.018202	b1 10		lda ($10),y			lda 	(zTemp1),y
.018204	c9 3f		cmp #$3f			cmp 	#"?"
.018206	f0 04		beq $01820c			beq 	TIM_SkipFirst
.018208	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.01820a	d0 01		bne $01820d			bne 	TIM_NotDot
.01820c					TIM_SkipFirst:
.01820c	c8		iny				iny
.01820d					TIM_NotDot:
.01820d	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.01820f	c9 52		cmp #$52			cmp 	#"R"						; show registers
.018211	f0 6b		beq $01827e			beq 	TIM_ShowRegisters
.018213	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.018215	f0 12		beq $018229			beq 	TIM_ShowMemory
.018217	c9 47		cmp #$47			cmp 	#"G"						; execute
.018219	f0 49		beq $018264			beq 	TIM_Execute
.01821b	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.01821d	f0 07		beq $018226			beq 	TIM_GoLoadMemory
.01821f	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.018221	d0 c7		bne $0181ea			bne 	TIM_Error
.018223	4c a2 83	jmp $0183a2			jmp 	TIM_UpdateRegisters
.018226					TIM_GoLoadMemory:
.018226	4c d2 83	jmp $0183d2			jmp 	TIM_LoadMemory
.018229					TIM_ShowMemory:
.018229	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.01822c	b0 bc		bcs $0181ea			bcs 	TIM_Error
.01822e	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.018230	85 12		sta $12				sta 	zTemp2
.018232	a5 15		lda $15				lda 	zTemp3+1
.018234	85 13		sta $13				sta 	zTemp2+1
.018236	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.018239	90 08		bcc $018243			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.01823b	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.01823d	85 14		sta $14				sta 	zTemp3
.01823f	a5 13		lda $13				lda 	zTemp2+1
.018241	85 15		sta $15				sta 	zTemp3+1
.018243					_TIMSM_Start:
.018243	20 f6 82	jsr $0182f6			jsr 	TIM_WriteLine 				; write one line of hex out
.018246	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.018248	18		clc				clc
.018249	69 10		adc #$10			adc 	#16
.01824b	85 12		sta $12				sta 	zTemp2
.01824d	90 02		bcc $018251			bcc 	_TIMSM_NoCarry
.01824f	e6 13		inc $13				inc 	zTemp2+1
.018251					_TIMSM_NoCarry:
.018251	20 d4 81	jsr $0181d4			jsr 	IF_CheckBreak 				; check CTL+C
.018254	d0 0b		bne $018261			bne 	_TIMSM_Ends 				; if pressed break out.
.018256	38		sec				sec 								; check past the end address in zTemp3
.018257	a5 14		lda $14				lda 	zTemp3
.018259	e5 12		sbc $12				sbc 	zTemp2
.01825b	a5 15		lda $15				lda 	zTemp3+1
.01825d	e5 13		sbc $13				sbc 	zTemp2+1
.01825f	10 e2		bpl $018243			bpl 	_TIMSM_Start
.018261					_TIMSM_Ends:
.018261	4c f1 81	jmp $0181f1			jmp 	TIM_NewCommand
.018264					TIM_Execute:
.018264	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; get the execute address
.018267	b0 81		bcs $0181ea			bcs 	TIM_Error 					; not legitimate
.018269	ae cb 03	ldx $03cb			ldx 	TIM_SP 						; set up SP
.01826c	9a		txs				txs
.01826d	ad c6 03	lda $03c6			lda 	TIM_SR 						; Status for PLP
.018270	48		pha				pha
.018271	ad c7 03	lda $03c7			lda 	TIM_A 						; restore AXYZ
.018274	ae c8 03	ldx $03c8			ldx 	TIM_X
.018277	ac c9 03	ldy $03c9			ldy 	TIM_Y
.01827a	28		plp				plp 								; and PS Byte.
.01827b	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.01827e					TIM_Start:
.01827e					TIM_ShowRegisters:
.01827e	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.018281	8d c5 03	sta $03c5			sta 	TIM_IRQ+1
.018284	ad ff ff	lda $ffff			lda 	$FFFF
.018287	8d c4 03	sta $03c4			sta 	TIM_IRQ
.01828a	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.01828c					_TIMSR_Text:
.01828c	bf bd 82 01	lda $0182bd,x			lda 	_TIMSR_Label,x
.018290	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018293	e8		inx				inx
.018294	e0 20		cpx #$20			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.018296	d0 f4		bne $01828c			bne 	_TIMSR_Text
.018298	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.01829a					_TIMSR_Skip:
.01829a	e8		inx				inx
.01829b					_TIMSR_LoopSpace:
.01829b	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.01829d	b0 04		bcs $0182a3			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.01829f	8a		txa				txa
.0182a0	4a		lsr a				lsr 	a
.0182a1	b0 05		bcs $0182a8			bcs 	_TIMSR_NoSpace
.0182a3					_TIMSR_Space:
.0182a3	a9 20		lda #$20			lda 	#" "
.0182a5	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182a8					_TIMSR_NoSpace:
.0182a8	bd c2 03	lda $03c2,x			lda 	TIM_PC,x 					; output hex value.
.0182ab	20 dd 82	jsr $0182dd			jsr 	TIM_WriteHex
.0182ae	e8		inx				inx
.0182af	e0 08		cpx #$08			cpx 	#TIM_Z-TIM_PC
.0182b1	f0 e7		beq $01829a			beq 	_TIMSR_Skip
.0182b3	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.0182b5	d0 e4		bne $01829b			bne 	_TimSR_LoopSpace
.0182b7	20 4f 80	jsr $01804f			jsr 	IFT_NewLine 				; new line
.0182ba	4c f1 81	jmp $0181f1			jmp	 	TIM_NewCommand 				; new command.
.0182bd					_TIMSR_Label:
>0182bd	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>0182c5	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>0182d5	52
>0182d6	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.0182dd					_TIMSR_LabelEnd:
.0182dd					TIM_WriteHex:
.0182dd	48		pha				pha 								; save A
.0182de	4a		lsr a				lsr 	a 							; shift MSB->LSB
.0182df	4a		lsr a				lsr 	a
.0182e0	4a		lsr a				lsr 	a
.0182e1	4a		lsr a				lsr 	a
.0182e2	20 e6 82	jsr $0182e6			jsr 	_TIMWH_Nibble 				; print MSB
.0182e5	68		pla				pla 								; restore and print LSB
.0182e6					_TIMWH_Nibble:
.0182e6	48		pha				pha
.0182e7	29 0f		and #$0f			and 	#15 						; mask out
.0182e9	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.0182eb	90 02		bcc $0182ef			bcc 	_TIMWHNoLetter
.0182ed	69 06		adc #$06			adc 	#6
.0182ef					_TIMWHNoLetter:
.0182ef	69 30		adc #$30			adc 	#48
.0182f1	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter 			; print it out.
.0182f4	68		pla				pla
.0182f5	60		rts				rts
.0182f6					TIM_WriteLine:
.0182f6	a9 2e		lda #$2e			lda 	#"." 						; prompt
.0182f8	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182fb	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.0182fd	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018300	a5 13		lda $13				lda 	zTemp2+1 					; write address
.018302	20 dd 82	jsr $0182dd			jsr 	TIM_WriteHex
.018305	a5 12		lda $12				lda 	zTemp2
.018307	20 dd 82	jsr $0182dd			jsr 	TIM_WriteHex
.01830a	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.01830c					_TIMWL_Loop:
.01830c	a9 20		lda #$20			lda 	#" "
.01830e	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018311	b1 12		lda ($12),y			lda 	(zTemp2),y
.018313	20 dd 82	jsr $0182dd			jsr 	TIM_WriteHex
.018316	c8		iny				iny
.018317	c0 10		cpy #$10			cpy 	#16
.018319	d0 f1		bne $01830c			bne 	_TIMWL_Loop
.01831b	4c 4f 80	jmp $01804f			jmp 	IFT_NewLine 				; new line and exit
.01831e					TIM_GetHex:
.01831e	c8		iny				iny
.01831f	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.018321	c9 20		cmp #$20			cmp 	#32
.018323	f0 f9		beq $01831e			beq 	TIM_GetHex
.018325	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.018327	f0 f5		beq $01831e			beq 	TIM_GetHex
.018329	20 52 83	jsr $018352			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.01832c	b0 23		bcs $018351			bcs 	_TIMGH_Exit					; if first bad then exit now.
.01832e	a9 00		lda #$00			lda 	#0 							; zero result
.018330	85 14		sta $14				sta 	zTemp3
.018332	85 15		sta $15				sta 	zTemp3+1
.018334					_TIM_GHLoop:
.018334	20 52 83	jsr $018352			jsr 	TIM_GetHexCharacter 		; get next character
.018337	b0 17		bcs $018350			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.018339	c8		iny				iny 								; skip over it.
.01833a	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.01833c	26 15		rol $15				rol 	zTemp3+1
.01833e	06 14		asl $14				asl 	zTemp3 						; now x 2
.018340	26 15		rol $15				rol 	zTemp3+1
.018342	06 14		asl $14				asl 	zTemp3						; now x 4
.018344	26 15		rol $15				rol 	zTemp3+1
.018346	06 14		asl $14				asl 	zTemp3 						; now x 8
.018348	26 15		rol $15				rol 	zTemp3+1
.01834a	05 14		ora $14				ora 	zTemp3 						; OR result in
.01834c	85 14		sta $14				sta 	zTemp3
.01834e	80 e4		bra $018334			bra 	_TIM_GHLoop 				; loop round again.
.018350					_TIMGH_Okay:
.018350	18		clc				clc
.018351					_TIMGH_Exit:
.018351	60		rts				rts
.018352					TIM_GetHexCharacter:
.018352	b1 10		lda ($10),y			lda 	(zTemp1),y
.018354	38		sec				sec
.018355	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.018357	90 0e		bcc $018367			bcc 	_TIM_GHCFail
.018359	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.01835b	90 0b		bcc $018368			bcc 	_TIM_GHCExit
.01835d	c9 11		cmp #$11			cmp 	#65-48						; < A
.01835f	90 06		bcc $018367			bcc		_TIM_GHCFail
.018361	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.018363	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.018365	90 01		bcc $018368			bcc		_TIM_GHCExit
.018367					_TIM_GHCFail:
.018367	38		sec				sec
.018368					_TIM_GHCExit:
.018368	60		rts				rts
.018369					TIM_BreakVector:
.018369	da		phx				phx									; save X/A on stack
.01836a	48		pha				pha
.01836b	ba		tsx				tsx 								; X points to S
.01836c	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.01836f	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.018371	d0 03		bne $018376			bne 	_TIMBreak					; if set, it's BRK
.018373	68		pla				pla 								; abandon routine.
.018374	fa		plx				plx
.018375	40		rti				rti
.018376					_TIMBreak:
.018376	68		pla				pla 								; save A X Y and maybe Z
.018377	8d c7 03	sta $03c7			sta 	TIM_A
.01837a	fa		plx				plx
.01837b	8e c8 03	stx $03c8			stx 	TIM_X
.01837e	8c c9 03	sty $03c9			sty 	TIM_Y
.018381	68		pla				pla 								; get Status Register
.018382	8d c6 03	sta $03c6			sta 	TIM_SR
.018385	68		pla				pla
.018386	8d c3 03	sta $03c3			sta 	TIM_PC+1 					; save calling address
.018389	68		pla				pla
.01838a	8d c2 03	sta $03c2			sta 	TIM_PC 						; high byte
.01838d	ad c3 03	lda $03c3			lda 	TIM_PC+1 					; dec PC to point right.
.018390	d0 03		bne $018395			bne 	_TIMDecrement 				; brk bumps it.
.018392	ce c2 03	dec $03c2			dec 	TIM_PC
.018395					_TIMDecrement:
.018395	ce c3 03	dec $03c3			dec 	TIM_PC+1
.018398	ba		tsx				tsx 								; and copy SP
.018399	8e cb 03	stx $03cb			stx 	TIM_SP
.01839c	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.01839e	9a		txs				txs
.01839f	4c 7e 82	jmp $01827e			jmp 	TIM_Start 					; and start up TIM monitor.
.0183a2					TIM_UpdateRegisters:
.0183a2	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; PC
.0183a5	b0 28		bcs $0183cf			bcs 	_TIMURFail
.0183a7	a5 14		lda $14				lda 	zTemp3
.0183a9	8d c3 03	sta $03c3			sta 	Tim_PC+1
.0183ac	a5 15		lda $15				lda 	zTemp3+1
.0183ae	8d c2 03	sta $03c2			sta 	Tim_PC
.0183b1	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; ignore IRQ
.0183b4	b0 19		bcs $0183cf			bcs 	_TIMURFail
.0183b6	a2 00		ldx #$00			ldx 	#0
.0183b8					_TIM_URLoop:
.0183b8	e0 04		cpx #$04			cpx 	#Tim_Z-Tim_SR
.0183ba	d0 01		bne $0183bd			bne 	_TIM_1
.0183bc	e8		inx				inx
.0183bd					_TIM_1:
.0183bd	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; registers
.0183c0	b0 0d		bcs $0183cf			bcs 	_TIMURFail
.0183c2	a5 14		lda $14				lda 	zTemp3
.0183c4	9d c6 03	sta $03c6,x			sta 	Tim_SR,x
.0183c7	e8		inx				inx
.0183c8	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.0183ca	d0 ec		bne $0183b8			bne 	_TIM_URLoop
.0183cc	4c f1 81	jmp $0181f1			jmp 	TIM_NewCommand
.0183cf					_TIMURFail:
.0183cf	4c ea 81	jmp $0181ea			jmp 	TIM_Error
.0183d2					TIM_LoadMemory:
.0183d2	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; target address => zTemp2
.0183d5	a5 14		lda $14				lda 	zTemp3
.0183d7	85 12		sta $12				sta 	zTemp2
.0183d9	a5 15		lda $15				lda 	zTemp3+1
.0183db	85 13		sta $13				sta 	zTemp2+1
.0183dd					_TIM_LMLoop:
.0183dd	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; next byte ?
.0183e0	b0 0e		bcs $0183f0			bcs 	_TIMLMDone 					; no more
.0183e2	a2 00		ldx #$00			ldx 	#0							; write out.
.0183e4	a5 14		lda $14				lda 	zTemp3
.0183e6	81 12		sta ($12,x)			sta 	(zTemp2,x)
.0183e8	e6 12		inc $12				inc 	zTemp2 						; bump address
.0183ea	d0 f1		bne $0183dd			bne 	_TIM_LMLoop
.0183ec	e6 13		inc $13				inc 	zTemp2+1
.0183ee	80 ed		bra $0183dd			bra 	_TIM_LMLoop
.0183f0					_TIMLMDone:
.0183f0	4c f1 81	jmp $0181f1			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/skip.asm

.0183f3					StructureSearchSingle:
.0183f3	a2 00		ldx #$00			ldx 	#0
.0183f5					StructureSearchDouble:
.0183f5	85 10		sta $10				sta 	zTemp1 						; save the target on zTemp1,zTemp1+1
.0183f7	86 11		stx $11				stx 	zTemp1+1
.0183f9	a9 00		lda #$00			lda 	#0 							; set the structure depth to zero (zTemp2)
.0183fb	85 12		sta $12				sta 	zTemp2
.0183fd	80 18		bra $018417			bra 	_SSWLoop 					; jump in, start scanning from here.
.0183ff					_SSWNextLine:
.0183ff	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018401	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.018403	18		clc				clc
.018404	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018406	85 16		sta $16				sta 	zCodePtr
.018408	90 02		bcc $01840c			bcc 	_SNLNoCarry
.01840a	e6 17		inc $17				inc 	zCodePtr+1
.01840c					_SNLNoCarry:
.01840c	a0 00		ldy #$00			ldy 	#0
.01840e	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018410	c9 00		cmp #$00			cmp 	#0					 		; if zero, fail.
.018412	f0 54		beq $018468			beq 	_SSWFail
.018414	c8		iny				iny
.018415	c8		iny				iny
.018416					_SSWNextSimple:
.018416	c8		iny				iny
.018417					_SSWLoop:
.018417	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018419	c9 00		cmp #$00			cmp 	#0 							; end of line ?
.01841b	f0 e2		beq $0183ff			beq 	_SSWNextLine 				; if so, then next line
.01841d	10 f7		bpl $018416			bpl 	_SSWNextSimple 				; needs to be a token, just skip char/number.
.01841f	a6 12		ldx $12				ldx 	zTemp2 						; check structure count
.018421	d0 08		bne $01842b			bne 	_SSWCheckUpDown 			; if it's non zero, then a match doesn't work.
.018423	c5 10		cmp $10				cmp 	zTemp1 						; found the right keyword, either choice.
.018425	f0 2d		beq $018454			beq 	_SSWFound 					; so exit.
.018427	c5 11		cmp $11				cmp 	zTemp1+1
.018429	f0 29		beq $018454			beq 	_SSWFound
.01842b					_SSWCheckUpDown:
.01842b	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus 			; if < keyword +
.01842d	90 10		bcc $01843f			bcc 	_SSWNext
.01842f	c9 93		cmp #$93			cmp 	#firstKeywordMinus 			; if < keyword - then as keyword +
.018431	90 08		bcc $01843b			bcc 	_SSWPlus
.018433	c9 98		cmp #$98			cmp 	#firstUnaryFunction			; if < first unary down as keyword -
.018435	b0 08		bcs $01843f			bcs 	_SSWNext
.018437	c6 12		dec $12				dec 	zTemp2 						; reduce structure count.
.018439	c6 12		dec $12				dec 	zTemp2
.01843b					_SSWPlus:
.01843b	e6 12		inc $12				inc 	zTemp2
.01843d	30 16		bmi $018455			bmi 	_SSWUnder					; error if driven -ve
.01843f					_SSWNext:
.01843f	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018441	c8		iny				iny 								; skip
.018442	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018444	90 0c		bcc $018452			bcc 	_SEDone 					; so just skip over it.
.018446	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018448	90 07		bcc $018451			bcc 	_SEDouble
.01844a	98		tya				tya 								; this is Y + 1
.01844b	18		clc				clc
.01844c	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.01844e	a8		tay				tay 								; back in Y.
.01844f	88		dey				dey 								; fix up, one for the +1, one for the iny
.018450	88		dey				dey
.018451					_SEDouble:
.018451	c8		iny				iny
.018452					_SEDone:
.018452	80 c3		bra $018417			bra 	_SSWLoop
.018454					_SSWFound:
.018454	60		rts				rts
.018455					_SSWUnder:
.018455	20 79 85	jsr $018579			jsr ERR_Handler
>018458	53 74 72 75 63 74 75 72			.text "Structure order",0
>018460	65 20 6f 72 64 65 72 00
.018468					_SSWFail:
.018468	20 79 85	jsr $018579			jsr ERR_Handler
>01846b	43 61 6e 27 74 20 66 69			.text "Can't find structure",0
>018473	6e 64 20 73 74 72 75 63 74 75 72 65 00
.018480					SkipEndOfCommand:
.018480	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018482	c9 00		cmp #$00			cmp 	#0 							; if zero, end of line, so exit
.018484	f0 19		beq $01849f			beq 	_SOCExit
.018486	c9 c0		cmp #$c0			cmp 	#token_Colon 				; if colon, end of command
.018488	f0 15		beq $01849f			beq 	_SOCExit
.01848a	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.01848c	c8		iny				iny 								; skip
.01848d	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.01848f	90 0c		bcc $01849d			bcc 	_SEDone 					; so just skip over it.
.018491	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018493	90 07		bcc $01849c			bcc 	_SEDouble
.018495	98		tya				tya 								; this is Y + 1
.018496	18		clc				clc
.018497	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018499	a8		tay				tay 								; back in Y.
.01849a	88		dey				dey 								; fix up, one for the +1, one for the iny
.01849b	88		dey				dey
.01849c					_SEDouble:
.01849c	c8		iny				iny
.01849d					_SEDone:
.01849d	80 e1		bra $018480			bra 	SkipEndOfCommand
.01849f					_SOCExit:
.01849f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stack.asm

.0184a0					StackReset:
.0184a0	48		pha				pha
.0184a1	5a		phy				phy
.0184a2	a9 00		lda #$00			lda 	#(BasicStack & $FF) 		; reset pointer
.0184a4	85 26		sta $26				sta 	zBasicSP
.0184a6	a9 04		lda #$04			lda 	#(BasicStack >> 8)
.0184a8	85 27		sta $27				sta 	zBasicSP+1
.0184aa	a0 00		ldy #$00			ldy 	#0 							; reset stack top to $00 which cannot
.0184ac	98		tya				tya 								; be a legal token.
.0184ad	91 26		sta ($26),y			sta 	(zBasicSP),y
.0184af	7a		ply				ply
.0184b0	68		pla				pla
.0184b1	60		rts				rts
.0184b2					StackPushFrame:
.0184b2	48		pha				pha
.0184b3	5a		phy				phy
.0184b4	1a		inc a				inc 	a 							; one extra byte in frame, for the marker.
.0184b5	48		pha				pha 								; save it.
.0184b6	29 0f		and #$0f			and 	#$0F 						; lower 4 bits
.0184b8	18		clc				clc 								; add to Basic Stack
.0184b9	65 26		adc $26				adc 	zBasicSP
.0184bb	85 26		sta $26				sta 	zBasicSP
.0184bd	90 02		bcc $0184c1			bcc 	_SPFNoBump
.0184bf	e6 27		inc $27				inc 	zBasicSP+1
.0184c1					_SPFNoBump:
.0184c1	a0 00		ldy #$00			ldy 	#0
.0184c3	68		pla				pla
.0184c4	91 26		sta ($26),y			sta 	(zBasicSP),y
.0184c6	7a		ply				ply
.0184c7	68		pla				pla
.0184c8	60		rts				rts
.0184c9					StackPopFrame:
.0184c9	48		pha				pha
.0184ca	5a		phy				phy
.0184cb	a0 00		ldy #$00			ldy 	#0 							; compare with top of stack using EOR
.0184cd	51 26		eor ($26),y			eor 	(zBasicSP),y
.0184cf	29 f0		and #$f0			and 	#$F0 						; top 4 bits zero, match
.0184d1	d0 12		bne $0184e5			bne 	SPFError 					; mixed structures
.0184d3	b1 26		lda ($26),y			lda 	(zBasicSP),y 				; get size from byte
.0184d5	29 0f		and #$0f			and 	#$0F
.0184d7	49 ff		eor #$ff			eor 	#$FF						; 2's complement
.0184d9	38		sec				sec
.0184da	65 26		adc $26				adc 	zBasicSP
.0184dc	85 26		sta $26				sta 	zBasicSP
.0184de	b0 02		bcs $0184e2			bcs 	_SPFNoBump
.0184e0	c6 27		dec $27				dec 	zBasicSP+1
.0184e2					_SPFNoBump:
.0184e2	7a		ply				ply
.0184e3	68		pla				pla
.0184e4	60		rts				rts
.0184e5					SPFError:
.0184e5	20 79 85	jsr $018579			jsr ERR_Handler
>0184e8	4d 69 78 65 64 20 53 74			.text "Mixed Structures",0
>0184f0	72 75 63 74 75 72 65 73 00
.0184f9					StackSavePosition:
.0184f9	98		tya				tya
.0184fa	5a		phy				phy
.0184fb	a0 05		ldy #$05			ldy 	#5
.0184fd	91 26		sta ($26),y			sta 	(zBasicSP),y
.0184ff	a0 01		ldy #$01			ldy 	#1
.018501	a5 16		lda $16				lda 	zCodePtr+0 					; 4 bytes, could reduce this for 65816/6502
.018503	91 26		sta ($26),y			sta 	(zBasicSP),y
.018505	c8		iny				iny
.018506	a5 17		lda $17				lda 	zCodePtr+1
.018508	91 26		sta ($26),y			sta 	(zBasicSP),y
.01850a	c8		iny				iny
.01850b	a5 18		lda $18				lda 	zCodePtr+2
.01850d	91 26		sta ($26),y			sta 	(zBasicSP),y
.01850f	c8		iny				iny
.018510	a5 19		lda $19				lda 	zCodePtr+3
.018512	91 26		sta ($26),y			sta 	(zBasicSP),y
.018514	7a		ply				ply
.018515	60		rts				rts
.018516					StackRestorePosition:
.018516	5a		phy				phy
.018517	a0 01		ldy #$01			ldy 	#1 							; copy 4 bytes that are the pointer
.018519	b1 26		lda ($26),y			lda 	(zBasicSP),y
.01851b	85 16		sta $16				sta 	zCodePtr+0
.01851d	c8		iny				iny
.01851e	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018520	85 17		sta $17				sta 	zCodePtr+1
.018522	c8		iny				iny
.018523	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018525	85 18		sta $18				sta 	zCodePtr+2
.018527	c8		iny				iny
.018528	b1 26		lda ($26),y			lda 	(zBasicSP),y
.01852a	85 19		sta $19				sta 	zCodePtr+3
.01852c	c8		iny				iny
.01852d	b1 26		lda ($26),y			lda 	(zBasicSP),y 				; offset
.01852f	7a		ply				ply 								; restore Y
.018530	a8		tay				tay
.018531	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/vectors.asm

.018532					VIOCharPrint:
.018532	4c 35 80	jmp $018035			jmp 	IFT_PrintCharacter
.018535					VIOCharGet:
.018535	20 d9 81	jsr $0181d9			jsr 	IF_GetKey
.018538	c9 00		cmp #$00			cmp 	#0
.01853a	f0 02		beq $01853e			beq 	_VCG0
.01853c	38		sec				sec
.01853d	60		rts				rts
.01853e	18		clc		_VCG0:	clc
.01853f	60		rts				rts
.018540					VIOCheckBreak:
.018540	4c d4 81	jmp $0181d4			jmp 	IF_CheckBreak
.018543					VIOCharGetPosition:
.018543	ad 00 05	lda $0500			lda 	IFT_XCursor
.018546	60		rts				rts
.018547					VIOReadLine:
.018547	4c ed 80	jmp $0180ed			jmp 	IFT_ReadLine

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/errors.asm

.01854a					SyntaxError:
.01854a	20 79 85	jsr $018579			jsr 	ERR_Handler
>01854d	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>018555	72 72 6f 72 00
.01855a					TypeError:
.01855a	20 79 85	jsr $018579			jsr 	ERR_Handler
>01855d	57 72 6f 6e 67 20 74 79				.text 	"Wrong type",0
>018565	70 65 00
.018568					BadParamError:
.018568	20 79 85	jsr $018579			jsr 	ERR_Handler
>01856b	42 61 64 20 50 61 72 61				.text 	"Bad Parameter",0
>018573	6d 65 74 65 72 00
.018579					ERR_Handler:
.018579	a0 00		ldy #$00			ldy 	#0
.01857b	c8		iny				iny
.01857c	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01857e	85 80		sta $80				sta 	XS_Mantissa
.018580	c8		iny				iny
.018581	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018583	85 81		sta $81				sta 	XS_Mantissa+1
.018585	fa		plx				plx 								; address in XY
.018586	7a		ply				ply
.018587	e8		inx				inx 								; bump, because of RTS/JSR address -1
.018588	d0 01		bne $01858b			bne 	_EHNoSkip
.01858a	c8		iny				iny
.01858b					_EHNoSkip:
.01858b	20 aa 85	jsr $0185aa			jsr 	PrintROMMessage 			; print message from ROM.
.01858e	a5 80		lda $80				lda 	XS_Mantissa					; line number = 0
.018590	05 81		ora $81				ora 	XS_Mantissa+1
.018592	f0 0c		beq $0185a0			beq 	_EHNoLine
.018594	a2 a5		ldx #$a5			ldx 	#_EHAt & $FF 				; print " at "
.018596	a0 85		ldy #$85			ldy 	#(_EHAt >> 8) & $FF
.018598	20 aa 85	jsr $0185aa			jsr 	PrintROMMessage
.01859b	a2 00		ldx #$00			ldx 	#0 							; Print line number
.01859d	20 bf 85	jsr $0185bf			jsr 	Print16BitInteger
.0185a0					_EHNoLine:
.0185a0	80 fe		bra $0185a0			bra 	_EHNoLine
.0185a2	4c 32 88	jmp $018832			jmp 	WarmStart 					; normally warm start.
>0185a5	20 61 74 20 00			_EHAt:	.text 	" at ",0
.0185aa					PrintROMMessage:
.0185aa	86 1a		stx $1a				stx 	zLTemp1 					; save addres
.0185ac	84 1b		sty $1b				sty 	zLTemp1+1
.0185ae	4b		phk				phk 								; get current code page
.0185af	68		pla				pla
.0185b0	85 1c		sta $1c				sta 	ZLTemp1+2 					; put into the 3rd byte so we can use
.0185b2	a0 00		ldy #$00			ldy 	#0
.0185b4					_PRMLoop:
.0185b4	b7 1a		lda [$1a],y			lda 	[zLTemp1],y 				; 65816
.0185b6	f0 06		beq $0185be			beq		_PRMExit 					; character $00 => exit
.0185b8	c8		iny				iny  								; bump Y and print it.
.0185b9	20 32 85	jsr $018532			jsr 	VIOCharPrint
.0185bc	80 f6		bra $0185b4			bra 	_PRMLoop
.0185be					_PRMExit:
.0185be	60		rts				rts
.0185bf					Print16BitInteger:
.0185bf	a9 00		lda #$00			lda 	#0 							; make 32 bit
.0185c1	85 82		sta $82				sta 	XS_Mantissa+2
.0185c3	85 83		sta $83				sta 	XS_Mantissa+3
.0185c5					Print32BitInteger:
.0185c5	a9 00		lda #$00			lda 	#0
.0185c7	8d 14 03	sta $0314			sta 	NumBufX 					; reset the conversion pointer
.0185ca	aa		tax				tax 								; convert bottom level.
.0185cb	20 3b 9e	jsr $019e3b			jsr 	INTToString 				; make string from integer in Num_Buffer
.0185ce	a2 00		ldx #$00			ldx 	#0 							; print buffer contents
.0185d0	bd 15 03	lda $0315,x	_P1Loop:lda 	Num_Buffer,x
.0185d3	f0 06		beq $0185db			beq 	_P1Exit
.0185d5	20 32 85	jsr $018532			jsr 	VIOCharPrint
.0185d8	e8		inx				inx
.0185d9	80 f5		bra $0185d0			bra 	_P1Loop
.0185db	8a		txa		_P1Exit:txa 								; return chars printed.
.0185dc	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm


;******  Processing file: modules/basic/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b6					lastUnaryFunction = $b6
.0185dd					VectorTable:
>0185dd	83 92					.word BinaryOp_And         & $FFFF ; $80 and
>0185df	9f 92					.word BinaryOp_Or          & $FFFF ; $81 or
>0185e1	bb 92					.word BinaryOp_Xor         & $FFFF ; $82 xor
>0185e3	bb 92					.word BinaryOp_Eor         & $FFFF ; $83 eor
>0185e5	f2 92					.word Binary_Equal         & $FFFF ; $84 =
>0185e7	fb 92					.word Binary_NotEqual      & $FFFF ; $85 <>
>0185e9	04 93					.word Binary_Less          & $FFFF ; $86 <
>0185eb	0d 93					.word Binary_LessEqual     & $FFFF ; $87 <=
>0185ed	1f 93					.word Binary_Greater       & $FFFF ; $88 >
>0185ef	16 93					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>0185f1	b7 93					.word BinaryOp_Add         & $FFFF ; $8a +
>0185f3	d3 93					.word BinaryOp_Subtract    & $FFFF ; $8b -
>0185f5	e4 93					.word BinaryOp_Multiply    & $FFFF ; $8c *
>0185f7	f5 93					.word BinaryOp_Divide      & $FFFF ; $8d /
>0185f9	9b 86					.word NotImplemented       & $FFFF ; $8e ^
>0185fb	11 8c					.word Command_IF           & $FFFF ; $8f if
>0185fd	7f 90					.word Command_WHILE        & $FFFF ; $90 while
>0185ff	a7 90					.word Command_REPEAT       & $FFFF ; $91 repeat
>018601	94 89					.word Command_FOR          & $FFFF ; $92 for
>018603	9b 86					.word NotImplemented       & $FFFF ; $93 then
>018605	6e 8c					.word Command_ENDIF        & $FFFF ; $94 endif
>018607	9c 90					.word Command_WEND         & $FFFF ; $95 wend
>018609	b0 90					.word Command_UNTIL        & $FFFF ; $96 until
>01860b	11 8a					.word Command_NEXT         & $FFFF ; $97 next
>01860d	9b 86					.word NotImplemented       & $FFFF ; $98 not
>01860f	9b 86					.word NotImplemented       & $FFFF ; $99 fn(
>018611	fa 94					.word Unary_Abs            & $FFFF ; $9a abs(
>018613	46 96					.word Unary_Asc            & $FFFF ; $9b asc(
>018615	67 a5					.word Unary_Int            & $FFFF ; $9c int(
>018617	14 95					.word Unary_Peek           & $FFFF ; $9d peek(
>018619	e8 a4					.word Unary_Rnd            & $FFFF ; $9e rnd(
>01861b	87 95					.word Unary_Usr            & $FFFF ; $9f usr(
>01861d	85 96					.word Unary_Left           & $FFFF ; $a0 left$(
>01861f	9a 96					.word Unary_Right          & $FFFF ; $a1 right$(
>018621	6c 96					.word Unary_Mid            & $FFFF ; $a2 mid$(
>018623	e5 97					.word Unary_Spc            & $FFFF ; $a3 spc(
>018625	14 96					.word Unary_Str            & $FFFF ; $a4 str$(
>018627	a8 95					.word Unary_Val            & $FFFF ; $a5 val(
>018629	5d 96					.word Unary_Len            & $FFFF ; $a6 len(
>01862b	12 97					.word Unary_Hex            & $FFFF ; $a7 hex$(
>01862d	9b 86					.word NotImplemented       & $FFFF ; $a8 sin(
>01862f	9b 86					.word NotImplemented       & $FFFF ; $a9 cos(
>018631	9b 86					.word NotImplemented       & $FFFF ; $aa tan(
>018633	9b 86					.word NotImplemented       & $FFFF ; $ab atn(
>018635	9b 86					.word NotImplemented       & $FFFF ; $ac exp(
>018637	9b 86					.word NotImplemented       & $FFFF ; $ad log(
>018639	9b 86					.word NotImplemented       & $FFFF ; $ae sqr(
>01863b	68 97					.word Unary_Dec            & $FFFF ; $af dec(
>01863d	18 95					.word Unary_Deek           & $FFFF ; $b0 deek(
>01863f	1c 95					.word Unary_Leek           & $FFFF ; $b1 leek(
>018641	54 95					.word Unary_Mod            & $FFFF ; $b2 mod(
>018643	b4 94					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>018645	c7 97					.word Unary_Chr            & $FFFF ; $b4 chr$(
>018647	48 95					.word Unary_Pos            & $FFFF ; $b5 pos(
>018649	08 98					.word Unary_Tab            & $FFFF ; $b6 tab(
>01864b	9b 86					.word NotImplemented       & $FFFF ; $b7 $
>01864d	9b 86					.word NotImplemented       & $FFFF ; $b8 $(
>01864f	9b 86					.word NotImplemented       & $FFFF ; $b9 #
>018651	9b 86					.word NotImplemented       & $FFFF ; $ba #(
>018653	9b 86					.word NotImplemented       & $FFFF ; $bb %
>018655	9b 86					.word NotImplemented       & $FFFF ; $bc %(
>018657	9b 86					.word NotImplemented       & $FFFF ; $bd (
>018659	9b 86					.word NotImplemented       & $FFFF ; $be )
>01865b	9b 86					.word NotImplemented       & $FFFF ; $bf ,
>01865d	93 89					.word Command_COLON        & $FFFF ; $c0 :
>01865f	9b 86					.word NotImplemented       & $FFFF ; $c1 ;
>018661	9b 86					.word NotImplemented       & $FFFF ; $c2 def
>018663	60 90					.word Command_CLR          & $FFFF ; $c3 clr
>018665	77 90					.word Command_STOP         & $FFFF ; $c4 stop
>018667	ea 8a					.word Command_DATA         & $FFFF ; $c5 data
>018669	c4 8a					.word Command_READ         & $FFFF ; $c6 read
>01866b	3f 88					.word Command_DIM          & $FFFF ; $c7 dim
>01866d	9b 86					.word NotImplemented       & $FFFF ; $c8 to
>01866f	9b 86					.word NotImplemented       & $FFFF ; $c9 step
>018671	a6 8f					.word Command_GOSUB        & $FFFF ; $ca gosub
>018673	b6 8f					.word Command_RETURN       & $FFFF ; $cb return
>018675	9e 8f					.word Command_GOTO         & $FFFF ; $cc goto
>018677	0d 8c					.word Command_END          & $FFFF ; $cd end
>018679	9b 86					.word NotImplemented       & $FFFF ; $ce input
>01867b	88 8b					.word Command_LET          & $FFFF ; $cf let
>01867d	74 8c					.word Command_LIST         & $FFFF ; $d0 list
>01867f	47 8f					.word Command_NEW          & $FFFF ; $d1 new
>018681	63 8f					.word Command_OLD          & $FFFF ; $d2 old
>018683	bf 8f					.word Command_ON           & $FFFF ; $d3 on
>018685	ed 8a					.word Command_RESTORE      & $FFFF ; $d4 restore
>018687	16 8f					.word Command_POKE         & $FFFF ; $d5 poke
>018689	68 8e					.word Command_PRINT        & $FFFF ; $d6 print
>01868b	05 89					.word Command_RUN          & $FFFF ; $d7 run
>01868d	c7 88					.word Command_WAIT         & $FFFF ; $d8 wait
>01868f	f3 8b					.word Command_SYS          & $FFFF ; $d9 sys
>018691	1a 8f					.word Command_DOKE         & $FFFF ; $da doke
>018693	1e 8f					.word Command_LOKE         & $FFFF ; $db loke
>018695	fe 8e					.word Command_ASSERT       & $FFFF ; $dc assert
>018697	a9 8b					.word Command_GET          & $FFFF ; $dd get
>018699	68 8c					.word Command_ELSE         & $FFFF ; $de else
.01869b					NotImplemented:
.01869b	20 79 85	jsr $018579			jsr ERR_Handler
>01869e	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>0186a6	65 6d 65 6e 74 65 64 00
.0186ae					BinaryPrecedence:
>0186ae	01					.byte 1    ; $80 and
>0186af	01					.byte 1    ; $81 or
>0186b0	01					.byte 1    ; $82 xor
>0186b1	01					.byte 1    ; $83 eor
>0186b2	02					.byte 2    ; $84 =
>0186b3	02					.byte 2    ; $85 <>
>0186b4	02					.byte 2    ; $86 <
>0186b5	02					.byte 2    ; $87 <=
>0186b6	02					.byte 2    ; $88 >
>0186b7	02					.byte 2    ; $89 >=
>0186b8	03					.byte 3    ; $8a +
>0186b9	03					.byte 3    ; $8b -
>0186ba	04					.byte 4    ; $8c *
>0186bb	04					.byte 4    ; $8d /
>0186bc	05					.byte 5    ; $8e ^
.0186bd					KeywordText:
>0186bd	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>0186c0	4f d2					.byte $4f,$d2                          ; $81 or
>0186c2	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>0186c5	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>0186c8	bd					.byte $bd                              ; $84 =
>0186c9	3c be					.byte $3c,$be                          ; $85 <>
>0186cb	bc					.byte $bc                              ; $86 <
>0186cc	3c bd					.byte $3c,$bd                          ; $87 <=
>0186ce	be					.byte $be                              ; $88 >
>0186cf	3e bd					.byte $3e,$bd                          ; $89 >=
>0186d1	ab					.byte $ab                              ; $8a +
>0186d2	ad					.byte $ad                              ; $8b -
>0186d3	aa					.byte $aa                              ; $8c *
>0186d4	af					.byte $af                              ; $8d /
>0186d5	de					.byte $de                              ; $8e ^
>0186d6	49 c6					.byte $49,$c6                          ; $8f if
>0186d8	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>0186dd	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>0186e3	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>0186e6	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>0186ea	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>0186ef	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>0186f3	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>0186f8	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>0186fc	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>0186ff	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>018702	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>018706	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>01870a	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>01870e	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>018713	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>018717	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>01871b	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>018721	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>018728	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>01872d	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>018731	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>018736	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>01873a	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>01873e	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>018743	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>018747	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>01874b	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>01874f	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>018753	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>018757	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>01875b	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>01875f	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>018763	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>018768	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>01876d	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>018771	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>018775	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>01877a	50 4f 53 a8				.byte $50,$4f,$53,$a8                  ; $b5 pos(
>01877e	54 41 42 a8				.byte $54,$41,$42,$a8                  ; $b6 tab(
>018782	a4					.byte $a4                              ; $b7 $
>018783	24 a8					.byte $24,$a8                          ; $b8 $(
>018785	a3					.byte $a3                              ; $b9 #
>018786	23 a8					.byte $23,$a8                          ; $ba #(
>018788	a5					.byte $a5                              ; $bb %
>018789	25 a8					.byte $25,$a8                          ; $bc %(
>01878b	a8					.byte $a8                              ; $bd (
>01878c	a9					.byte $a9                              ; $be )
>01878d	ac					.byte $ac                              ; $bf ,
>01878e	ba					.byte $ba                              ; $c0 :
>01878f	bb					.byte $bb                              ; $c1 ;
>018790	44 45 c6				.byte $44,$45,$c6                      ; $c2 def
>018793	43 4c d2				.byte $43,$4c,$d2                      ; $c3 clr
>018796	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $c4 stop
>01879a	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c5 data
>01879e	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c6 read
>0187a2	44 49 cd				.byte $44,$49,$cd                      ; $c7 dim
>0187a5	54 cf					.byte $54,$cf                          ; $c8 to
>0187a7	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c9 step
>0187ab	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $ca gosub
>0187b0	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $cb return
>0187b6	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $cc goto
>0187ba	45 4e c4				.byte $45,$4e,$c4                      ; $cd end
>0187bd	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $ce input
>0187c2	4c 45 d4				.byte $4c,$45,$d4                      ; $cf let
>0187c5	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $d0 list
>0187c9	4e 45 d7				.byte $4e,$45,$d7                      ; $d1 new
>0187cc	4f 4c c4				.byte $4f,$4c,$c4                      ; $d2 old
>0187cf	4f ce					.byte $4f,$ce                          ; $d3 on
>0187d1	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d4 restore
>0187d8	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d5 poke
>0187dc	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d6 print
>0187e1	52 55 ce				.byte $52,$55,$ce                      ; $d7 run
>0187e4	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d8 wait
>0187e8	53 59 d3				.byte $53,$59,$d3                      ; $d9 sys
>0187eb	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $da doke
>0187ef	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $db loke
>0187f3	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $dc assert
>0187f9	47 45 d4				.byte $47,$45,$d4                      ; $dd get
>0187fc	45 4c 53 c5				.byte $45,$4c,$53,$c5                  ; $de else
>018800	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_pos = $b5
=$b6					token_tab = $b6
=$b7					token_dollar = $b7
=$b8					token_dollarlparen = $b8
=$b9					token_hash = $b9
=$ba					token_hashlparen = $ba
=$bb					token_percent = $bb
=$bc					token_percentlparen = $bc
=$bd					token_lparen = $bd
=$be					token_rparen = $be
=$bf					token_comma = $bf
=$c0					token_colon = $c0
=$c1					token_semicolon = $c1
=$c2					token_def = $c2
=$c3					token_clr = $c3
=$c4					token_stop = $c4
=$c5					token_data = $c5
=$c6					token_read = $c6
=$c7					token_dim = $c7
=$c8					token_to = $c8
=$c9					token_step = $c9
=$ca					token_gosub = $ca
=$cb					token_return = $cb
=$cc					token_goto = $cc
=$cd					token_end = $cd
=$ce					token_input = $ce
=$cf					token_let = $cf
=$d0					token_list = $d0
=$d1					token_new = $d1
=$d2					token_old = $d2
=$d3					token_on = $d3
=$d4					token_restore = $d4
=$d5					token_poke = $d5
=$d6					token_print = $d6
=$d7					token_run = $d7
=$d8					token_wait = $d8
=$d9					token_sys = $d9
=$da					token_doke = $da
=$db					token_loke = $db
=$dc					token_assert = $dc
=$dd					token_get = $dd
=$de					token_else = $de

;******  Return to file: modules/basic/core.asm

.018801					BASIC_Start:
.018801	20 9b 81	jsr $01819b			jsr 	IF_Reset 					; set up and clear screen.
.018804	20 00 80	jsr $018000			jsr 	IFT_ClearScreen
.018807	a9 5c		lda #$5c			lda 	#$5C 						; JMP Long opcode
.018809	8d 10 03	sta $0310			sta 	LocalVector
.01880c	8d 0c 03	sta $030c			sta 	UserVector
.01880f	a9 96		lda #$96			lda 	#USRDefault & $FF 			; reset USR vector
.018811	8d 0d 03	sta $030d			sta 	UserVector+1
.018814	a9 95		lda #$95			lda 	#(USRDefault >> 8) & $FF
.018816	8d 0e 03	sta $030e			sta 	UserVector+2
.018819	a9 01		lda #$01			lda 	#(USRDefault >> 16) & $FF
.01881b	8d 0f 03	sta $030f			sta 	UserVector+3
.01881e	20 4f 98	jsr $01984f			jsr 	UpdateProgramEnd 			; update the program end.
.018821	20 60 90	jsr $019060			jsr 	ResetRunStatus 				; clear everything (CLR command)
.018824	c2 30		rep #$30			rep 	#$30
.018826	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.018829	1b		tcs				tcs
.01882a	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.01882d	e2 30		sep #$30			sep 	#$30
.01882f	4c 05 89	jmp $018905			jmp 	COMMAND_Run
.018832					WarmStart:
.018832	c2 30		rep #$30			rep 	#$30
.018834	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.018837	1b		tcs				tcs
.018838	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.01883b	e2 30		sep #$30			sep 	#$30
.01883d	80 f3		bra $018832			bra 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/dim.asm

.01883f					Command_DIM:
.01883f	98		tya				tya
.018840	48		pha				pha 								; push on stack.
.018841	20 c4 99	jsr $0199c4			jsr 	VariableExtract 			; get the identifier
.018844	ad 95 03	lda $0395			lda 	Var_Type 					; check it is an array
.018847	29 01		and #$01			and 	#1
.018849	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.01884b	d0 6c		bne $0188b9			bne 	_CDIError
.01884d	a9 00		lda #$00			lda 	#0 							; reset the DIM index. The dimensions are
.01884f	8d b9 03	sta $03b9			sta 	UsrArrayIdx 				; built up here and copied in case we autodim
.018852					_CDIGetDimension:
.018852	ad b9 03	lda $03b9			lda 	UsrArrayIdx 				; done too many ?
.018855	c9 06		cmp #$06			cmp 	#ArrayMaxDim*2
.018857	f0 60		beq $0188b9			beq 	_CDIError
.018859	20 64 92	jsr $019264			jsr 	EvaluateInteger 			; evaluate an index size
.01885c	a5 81		lda $81				lda 	XS_Mantissa+1 				; check in range 0-7FFF
.01885e	29 80		and #$80			and 	#$80
.018860	05 82		ora $82				ora 	XS_Mantissa+2
.018862	05 83		ora $83				ora 	XS_Mantissa+3
.018864	d0 53		bne $0188b9			bne 	_CDIError
.018866	ae b9 03	ldx $03b9			ldx 	UsrArrayIdx 				; copy into the array table.
.018869	18		clc				clc 								; add 1 - max index => size.
.01886a	a5 80		lda $80				lda 	XS_Mantissa+0
.01886c	69 01		adc #$01			adc 	#1
.01886e	9d b1 03	sta $03b1,x			sta 	UsrArrayDef+0,x
.018871	a5 81		lda $81				lda 	XS_Mantissa+1
.018873	69 00		adc #$00			adc 	#0
.018875	9d b2 03	sta $03b2,x			sta 	UsrArrayDef+1,x
.018878	30 3f		bmi $0188b9			bmi 	_CDIError 					; could be dim a(32767)
.01887a	e8		inx				inx 								; bump index.
.01887b	e8		inx				inx
.01887c	8e b9 03	stx $03b9			stx 	UsrArrayIdx
.01887f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018881	c8		iny				iny
.018882	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another dimension
.018884	f0 cc		beq $018852			beq 	_CDIGetDimension
.018886	88		dey				dey
.018887	20 ab 98	jsr $0198ab			jsr 	CheckNextRParen 			; closing ) present ?
.01888a	ae b9 03	ldx $03b9			ldx 	UsrArrayIdx 				; copy USR array to default
.01888d	a9 ff		lda #$ff			lda 	#$FF 						; put end marker in ArrayDef
.01888f	9d aa 03	sta $03aa,x			sta 	ArrayDef+1,x
.018892					_CDICopy:
.018892	bd b1 03	lda $03b1,x			lda 	UsrArrayDef,x
.018895	9d a9 03	sta $03a9,x			sta 	ArrayDef,x
.018898	ca		dex				dex
.018899	10 f7		bpl $018892			bpl 	_CDICopy
.01889b	68		pla				pla									; position of array identifier
.01889c	85 10		sta $10				sta 	zTemp1
.01889e	98		tya				tya
.01889f	48		pha				pha
.0188a0	a5 10		lda $10				lda 	zTemp1 						; point to identifier
.0188a2	a8		tay				tay
.0188a3	20 c4 99	jsr $0199c4			jsr 	VariableExtract 			; get the identifier
.0188a6	20 5d 9c	jsr $019c5d			jsr 	VariableLocate 				; check if it exists already.
.0188a9	b0 0e		bcs $0188b9			bcs 	_CDIError
.0188ab	20 50 9a	jsr $019a50			jsr 	VariableCreate 				; create it using the current ArrayDef
.0188ae	68		pla				pla 								; restore code position
.0188af	a8		tay				tay
.0188b0	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0188b2	c8		iny				iny
.0188b3	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another DIM
.0188b5	f0 88		beq $01883f			beq 	Command_DIM
.0188b7	88		dey				dey
.0188b8	60		rts				rts
.0188b9					_CDIError:
.0188b9	20 79 85	jsr $018579			jsr ERR_Handler
>0188bc	42 61 64 20 44 49 4d 00			.text "Bad DIM",0
.0188c4					_CDISyntax:
.0188c4	4c 4a 85	jmp $01854a			jmp 	SyntaxError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/wait.asm

.0188c7					Command_WAIT:
.0188c7	20 64 92	jsr $019264			jsr		EvaluateInteger 			; address
.0188ca	a2 06		ldx #$06			ldx 	#XS_Size 					; and mask.
.0188cc	20 b3 98	jsr $0198b3			jsr 	CheckNextComma
.0188cf	20 66 92	jsr $019266			jsr 	EvaluateIntegerX
.0188d2	a9 00		lda #$00			lda 	#0							; set default xor.
.0188d4	85 8c		sta $8c				sta 	XS_Mantissa+XS_Size*2
.0188d6	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0188d8	c9 bf		cmp #$bf			cmp 	#token_Comma 				; no use the default
.0188da	d0 06		bne $0188e2			bne 	_CWAXorDefault
.0188dc	c8		iny				iny
.0188dd	a2 0c		ldx #$0c			ldx 	#XS_Size*2
.0188df	20 66 92	jsr $019266			jsr 	EvaluateIntegerX
.0188e2					_CWAXorDefault:
.0188e2	a5 80		lda $80				lda 	XS_Mantissa 				; copy 24 bits of mantissa to ZLTemp1
.0188e4	85 1a		sta $1a				sta 	zLTemp1
.0188e6	a5 81		lda $81				lda 	XS_Mantissa+1
.0188e8	85 1b		sta $1b				sta 	zLTemp1+1
.0188ea	a5 82		lda $82				lda 	XS_Mantissa+2
.0188ec	85 1c		sta $1c				sta 	zLTemp1+2
.0188ee					_CWAWaitLoop:
.0188ee	20 40 85	jsr $018540			jsr 	VIOCheckBreak 				; exit on break.
.0188f1	c9 00		cmp #$00			cmp 	#0
.0188f3	d0 0f		bne $018904			bne 	_CWAWaitExit
.0188f5	a9 01		lda #$01			lda 	#1							; read 1 byte to mantissa/0
.0188f7	a2 00		ldx #$00			ldx 	#0
.0188f9	5a		phy				phy 								; this is the same routine as PEEK.
.0188fa	20 2d 98	jsr $01982d			jsr 	MemRead
.0188fd	7a		ply				ply
.0188fe	25 86		and $86				and 	XS_Mantissa+XS_Size 		; process it
.018900	45 8c		eor $8c				eor 	XS_Mantissa+XS_Size*2
.018902	f0 ea		beq $0188ee			beq 	_CWAWaitLoop
.018904					_CWAWaitExit:
.018904	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/run.asm

.018905					Command_RUN:
.018905	20 60 90	jsr $019060			jsr 	ResetRunStatus 				; clear, reset stacks etc.
.018908	a9 00		lda #$00			lda 	#BasicProgram & $FF
.01890a	85 16		sta $16				sta 	zCodePtr+0
.01890c	a9 10		lda #$10			lda 	#BasicProgram >> 8
.01890e	85 17		sta $17				sta 	zCodePtr+1
.018910	a9 00		lda #$00			lda 	#0
.018912	85 18		sta $18				sta 	zCodePtr+2
.018914	85 19		sta $19				sta 	zCodePtr+3
.018916	a0 03		ldy #$03			ldy 	#3
.018918					RUN_NewLine:
.018918	a0 00		ldy #$00			ldy 	#0
.01891a	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01891c	c8		iny				iny
.01891d	c8		iny				iny
.01891e	c8		iny				iny
.01891f	c9 00		cmp #$00			cmp 	#0 							; if the offset is zero then END.
.018921	d0 16		bne $018939			bne 	RUN_NextCommand
.018923	4c 0d 8c	jmp $018c0d			jmp 	Command_END 				; go do the command code.
.018926					RUN_Skip:
.018926	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018928	c8		iny				iny 								; skip
.018929	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.01892b	90 0c		bcc $018939			bcc 	_SEDone 					; so just skip over it.
.01892d	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.01892f	90 07		bcc $018938			bcc 	_SEDouble
.018931	98		tya				tya 								; this is Y + 1
.018932	18		clc				clc
.018933	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018935	a8		tay				tay 								; back in Y.
.018936	88		dey				dey 								; fix up, one for the +1, one for the iny
.018937	88		dey				dey
.018938					_SEDouble:
.018938	c8		iny				iny
.018939					_SEDone:
.018939					RUN_NextCommand:
.018939	ad a8 03	lda $03a8			lda 	BreakCount 					; break counter
.01893c	69 10		adc #$10			adc 	#16 						; one time in 16
.01893e	8d a8 03	sta $03a8			sta 	BreakCount
.018941	90 0a		bcc $01894d			bcc 	RUN_NoCheckBreak
.018943	20 40 85	jsr $018540			jsr 	VIOCheckBreak 				; check for break
.018946	c9 00		cmp #$00			cmp 	#0
.018948	f0 03		beq $01894d			beq 	RUN_NoCheckBreak
.01894a	4c 77 90	jmp $019077			jmp 	Command_STOP 				; stop on BREAK.
.01894d					RUN_NoCheckBreak:
.01894d	a9 00		lda #$00			lda 	#0 							; this resets temporary string allocation.
.01894f	85 21		sta $21				sta 	zTempStr+1 					; (initialised when first called)
.018951	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018953	c9 c0		cmp #$c0			cmp 	#token_Colon 				; skip over colons
.018955	f0 cf		beq $018926			beq 	RUN_Skip
.018957	c9 00		cmp #$00			cmp 	#0 							; if non-zero execute whatever
.018959	d0 0f		bne $01896a			bne 	RUN_Execute
.01895b					RUN_NextLine:
.01895b	a0 00		ldy #$00			ldy 	#0 							; point to offset
.01895d	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.01895f	18		clc				clc
.018960	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018962	85 16		sta $16				sta 	zCodePtr
.018964	90 02		bcc $018968			bcc 	_SNLNoCarry
.018966	e6 17		inc $17				inc 	zCodePtr+1
.018968					_SNLNoCarry:
.018968	80 ae		bra $018918			bra 	RUN_NewLine 				; go do the new line code
.01896a					RUN_Execute:
.01896a	c9 f8		cmp #$f8			cmp 	#$F8 						; handle shifts, REM etc.
.01896c	b0 1e		bcs $01898c			bcs 	RUN_Extension
.01896e	c8		iny				iny
.01896f	0a		asl a				asl 	a 							; double the character read.
.018970	90 14		bcc $018986			bcc 	RUN_Default 				; if carry clear was $00-$7F, so try LET.
.018972	aa		tax				tax 								; ready to look up.
.018973	bf dd 85 01	lda $0185dd,x			lda 	VectorTable,x 				; copy address into LocalVector
.018977	8d 11 03	sta $0311			sta 	LocalVector+1
.01897a	bf de 85 01	lda $0185de,x			lda 	VectorTable+1,x
.01897e	8d 12 03	sta $0312			sta 	LocalVector+2
.018981	20 b1 91	jsr $0191b1			jsr 	EVCallLocalVector 			; execute the appropriate code.
.018984	80 b3		bra $018939			bra 	RUN_NextCommand 			; do the next command.
.018986					RUN_Default:
.018986	88		dey				dey
.018987	20 88 8b	jsr $018b88			jsr 	Command_LET 				; and try LET.
.01898a	80 ad		bra $018939			bra 	RUN_NextCommand
.01898c					RUN_Extension:
.01898c	c9 ff		cmp #$ff			cmp 	#$FF 						; if $FF (REM)
.01898e	f0 96		beq $018926			beq 	RUN_Skip 					; skip over it.
.018990	4c 4a 85	jmp $01854a			jmp 	SyntaxError
.018993					Command_COLON:
.018993	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/for.asm

.018994					Command_FOR:
.018994	20 88 8b	jsr $018b88			jsr 	Command_LET 				; do the A = 99 bit
.018997	a5 24		lda $24				lda 	zVarType 					; obviously has to be integer/real.
.018999	c9 b7		cmp #$b7			cmp 	#token_Dollar
.01899b	f0 71		beq $018a0e			beq 	_CFOError
.01899d	48		pha				pha 								; save the variable type.
.01899e	5a		phy				phy 								; save type/variable address.
.01899f	a0 01		ldy #$01			ldy 	#1							; type at + 1
.0189a1	91 26		sta ($26),y			sta 	(zBasicSP),y
.0189a3	c8		iny				iny
.0189a4	a5 22		lda $22				lda 	zVarDataPtr 				; data low at +2
.0189a6	91 26		sta ($26),y			sta 	(zBasicSP),y
.0189a8	c8		iny				iny
.0189a9	a5 23		lda $23				lda 	zVarDataPtr+1 				; data high at +3
.0189ab	91 26		sta ($26),y			sta 	(zBasicSP),y
.0189ad	7a		ply				ply
.0189ae	a9 53		lda #$53			lda 	#(SMark_For << 4) + 3
.0189b0	20 b2 84	jsr $0184b2			jsr 	StackPushFrame 				; push on the stack with FOR marker.
.0189b3	a9 c8		lda #$c8			lda 	#token_TO
.0189b5	20 94 98	jsr $019894			jsr 	CheckNextToken
.0189b8	a2 00		ldx #$00			ldx 	#0 							; put in Mantissa, bottom
.0189ba	20 ce 90	jsr $0190ce			jsr 	EvaluateExpression
.0189bd	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0189bf	a2 06		ldx #$06			ldx 	#XS_Size 					; X to second level
.0189c1	c9 c9		cmp #$c9			cmp 	#token_STEP
.0189c3	d0 06		bne $0189cb			bne 	_CFOStep1
.0189c5	c8		iny				iny
.0189c6	20 d0 90	jsr $0190d0			jsr 	EvaluateExpressionX 		; get STEP value.
.0189c9	80 0e		bra $0189d9			bra 	_CFOHaveStep
.0189cb					_CFOStep1:
.0189cb	a9 00		lda #$00			lda 	#0							; set step to integer 1.
.0189cd	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0189cf	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0189d1	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0189d3	a9 01		lda #$01			lda 	#1
.0189d5	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0189d7	95 85		sta $85,x			sta 	XS_Type,x
.0189d9					_CFOHaveStep:
.0189d9	68		pla				pla 								; restore variable type
.0189da	a2 00		ldx #$00			ldx 	#0
.0189dc	c9 bb		cmp #$bb			cmp 	#token_Percent 				; do conversion to type
.0189de	f0 0a		beq $0189ea			beq 	_CFOInteger
.0189e0	20 68 a2	jsr $01a268			jsr 	FPUToFloat
.0189e3	a2 06		ldx #$06			ldx 	#6
.0189e5	20 68 a2	jsr $01a268			jsr 	FPUToFloat
.0189e8	80 08		bra $0189f2			bra 	_CFOEndConv
.0189ea					_CFOInteger:
.0189ea	20 b4 a2	jsr $01a2b4			jsr 	FPUToInteger
.0189ed	a2 06		ldx #$06			ldx 	#6
.0189ef	20 b4 a2	jsr $01a2b4			jsr 	FPUToInteger
.0189f2					_CFOEndConv:
.0189f2	20 f9 84	jsr $0184f9			jsr 	StackSavePosition 			; save the loop position at 1-5
.0189f5	a9 55		lda #$55			lda 	#(SMark_For << 4)+SourcePosSize
.0189f7	20 b2 84	jsr $0184b2			jsr 	StackPushFrame 				; push the loop address frame.
.0189fa	5a		phy				phy
.0189fb	a0 00		ldy #$00			ldy 	#0
.0189fd					_CFOCopy:
.0189fd	b9 80 00	lda $0080,y			lda 	XS_Mantissa+0,y
.018a00	c8		iny				iny
.018a01	91 26		sta ($26),y			sta 	(zBasicSP),y
.018a03	c0 0c		cpy #$0c			cpy 	#XS_Size*2
.018a05	d0 f6		bne $0189fd			bne 	_CFOCopy
.018a07	7a		ply				ply
.018a08	a9 5c		lda #$5c			lda 	#(SMark_For << 4)+(XS_Size*2)
.018a0a	20 b2 84	jsr $0184b2			jsr 	StackPushFrame
.018a0d	60		rts				rts
.018a0e					_CFOError:
.018a0e	4c 5a 85	jmp $01855a			jmp 	TypeError 					; wrong type.
.018a11					Command_NEXT:
.018a11	a9 00		lda #$00			lda 	#0 							; set variable data pointer+1 to zero
.018a13	85 23		sta $23				sta 	zVarDataPtr+1 				; this means we don't check
.018a15	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018a17	c9 00		cmp #$00			cmp 	#0 							; EOL
.018a19	f0 07		beq $018a22			beq 	_CNextNoVariable
.018a1b	c9 40		cmp #$40			cmp 	#$40
.018a1d	b0 03		bcs $018a22			bcs 	_CNextNoVariable
.018a1f	20 59 99	jsr $019959			jsr 	VariableFind
.018a22					_CNextNoVariable:
.018a22	a5 26		lda $26				lda 	zBasicSP 					; save on stack
.018a24	48		pha				pha
.018a25	a5 27		lda $27				lda 	zBasicSP+1
.018a27	48		pha				pha
.018a28	a9 50		lda #$50			lda 	#(SMark_For << 4) 			; pop loop address frame
.018a2a	20 c9 84	jsr $0184c9			jsr 	StackPopFrame
.018a2d	a9 50		lda #$50			lda 	#(SMark_For << 4) 			; pop STEP/TARGET frame.
.018a2f	20 c9 84	jsr $0184c9			jsr 	StackPopFrame
.018a32	a9 50		lda #$50			lda 	#(Smark_For << 4) 			; pop variable address frame.
.018a34	20 c9 84	jsr $0184c9			jsr 	StackPopFrame
.018a37	a5 23		lda $23				lda 	zVarDataPtr+1 				; if zero, then no variable provided
.018a39	f0 11		beq $018a4c			beq 	_CNextGetTarget 			; e.g. just NEXT not NEXT x
.018a3b	5a		phy				phy 								; check addresses match.
.018a3c	a0 02		ldy #$02			ldy 	#2
.018a3e	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a40	c5 22		cmp $22				cmp 	zVarDataPtr
.018a42	d0 69		bne $018aad			bne 	_CNextWrong
.018a44	c8		iny				iny
.018a45	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a47	c5 23		cmp $23				cmp 	zVarDataPtr+1
.018a49	d0 62		bne $018aad			bne 	_CNextWrong
.018a4b	7a		ply				ply
.018a4c					_CNextGetTarget:
.018a4c	5a		phy				phy
.018a4d	a0 01		ldy #$01			ldy 	#1 							; restore variable type and data.
.018a4f	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a51	85 24		sta $24				sta 	zVarType
.018a53	c8		iny				iny
.018a54	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a56	85 22		sta $22				sta 	zVarDataPtr
.018a58	c8		iny				iny
.018a59	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a5b	85 23		sta $23				sta 	zVarDataPtr+1
.018a5d	a2 0c		ldx #$0c			ldx 	#12
.018a5f	20 a1 9c	jsr $019ca1			jsr 	VariableGet 				; get that variable value into expr[2]
.018a62	a2 00		ldx #$00			ldx 	#0 							; copy stacked Target/Step into expr[0] and [1]
.018a64	a0 0b		ldy #$0b			ldy 	#11
.018a66					_CNXCopy:
.018a66	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a68	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018a6a	e8		inx				inx
.018a6b	c8		iny				iny
.018a6c	e0 0c		cpx #$0c			cpx 	#XS_Size*2
.018a6e	d0 f6		bne $018a66			bne 	_CNXCopy
.018a70	7a		ply				ply
.018a71	a2 06		ldx #$06			ldx 	#6 							; point at expr[1] s
.018a73	20 d8 94	jsr $0194d8			jsr 	GetSignCurrent
.018a76	8d a7 03	sta $03a7			sta 	SignNext 					; save in temporary.
.018a79	a2 06		ldx #$06			ldx 	#6 							; add them, however
.018a7b	20 b7 93	jsr $0193b7			jsr 	BinaryOp_Add
.018a7e	20 f2 9c	jsr $019cf2			jsr 	VariableSet					; and write variable back.
.018a81	a2 00		ldx #$00			ldx 	#0
.018a83	20 3b 93	jsr $01933b			jsr 	CompareValues
.018a86	09 00		ora #$00			ora 	#0
.018a88	f0 05		beq $018a8f			beq 	_CNXAgain 					; if true, then do it again.
.018a8a	cd a7 03	cmp $03a7			cmp 	SignNext 					; if sign different, then loop has finished.
.018a8d	d0 0f		bne $018a9e			bne 	_CNXLoopDone
.018a8f					_CNXAgain:
.018a8f	a9 53		lda #$53			lda 	#(SMark_For << 4) + 3		; re-stack variable address
.018a91	20 b2 84	jsr $0184b2			jsr 	StackPushFrame
.018a94	20 16 85	jsr $018516			jsr 	StackRestorePosition 		; get restore position back, e.g. loop round.
.018a97	68		pla				pla
.018a98	85 27		sta $27				sta 	zBasicSP+1
.018a9a	68		pla				pla
.018a9b	85 26		sta $26				sta 	zBasicSP
.018a9d					_CNXExit:
.018a9d	60		rts				rts
.018a9e					_CNXLoopDone:
.018a9e	68		pla				pla
.018a9f	68		pla				pla
.018aa0	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018aa2	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma ?
.018aa4	d0 f7		bne $018a9d			bne 	_CNXExit
.018aa6	c8		iny				iny
.018aa7	20 59 99	jsr $019959			jsr 	VariableFind 				; identify the variable
.018aaa	4c 22 8a	jmp $018a22			jmp 	_CNextNoVariable 			; go back with variable pre-found
.018aad					_CNextWrong:
.018aad	20 79 85	jsr $018579			jsr ERR_Handler
>018ab0	57 72 6f 6e 67 20 4e 65			.text "Wrong Next Variable",0
>018ab8	78 74 20 56 61 72 69 61 62 6c 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/read.asm

.018ac4					Command_READ:
.018ac4	20 59 99	jsr $019959			jsr 	VariableFind 				; get variable/value into zVarDataPtr,zVarType
.018ac7	a5 22		lda $22				lda 	zVarDataPtr 				; save variable info on stack
.018ac9	48		pha				pha
.018aca	a5 23		lda $23				lda 	zVarDataPtr+1
.018acc	48		pha				pha
.018acd	a5 24		lda $24				lda 	zVarType
.018acf	48		pha				pha
.018ad0	20 16 8b	jsr $018b16			jsr 	READGetDataItem 			; get the next data item
.018ad3	68		pla				pla 								; restore target variable information.
.018ad4	85 24		sta $24				sta 	zVarType
.018ad6	68		pla				pla
.018ad7	85 23		sta $23				sta 	zVarDataPtr+1
.018ad9	68		pla				pla
.018ada	85 22		sta $22				sta 	zVarDataPtr
.018adc	a2 00		ldx #$00			ldx 	#0
.018ade	20 f2 9c	jsr $019cf2			jsr 	VariableSet 				; set the value out.
.018ae1	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018ae3	c8		iny				iny
.018ae4	c9 bf		cmp #$bf			cmp 	#token_Comma
.018ae6	f0 dc		beq $018ac4			beq 	Command_READ 				; found, do another READ
.018ae8	88		dey				dey
.018ae9	60		rts				rts
.018aea					Command_DATA:
.018aea	4c 80 84	jmp $018480			jmp 	SkipEndOfCommand
.018aed					Command_RESTORE:
.018aed	48		pha				pha
.018aee	a9 00		lda #$00			lda 	#0 							; this being zero means 'initialise next read'
.018af0	8d bd 03	sta $03bd			sta 	DataLPtr+0
.018af3	8d be 03	sta $03be			sta 	DataLPtr+1
.018af6	68		pla				pla
.018af7	60		rts				rts
.018af8					READSwapPointers:
.018af8	98		tya				tya
.018af9	48		pha				pha 								; save it
.018afa	ad c1 03	lda $03c1			lda 	DataIndex 					; get data offset, and copy to offset
.018afd	a8		tay				tay
.018afe	68		pla				pla 								; get code offset and save in DataIndex
.018aff	8d c1 03	sta $03c1			sta 	DataIndex
.018b02	da		phx				phx
.018b03	a2 03		ldx #$03			ldx 	#3 							; swap the Data Pointers (4 bytes) round.
.018b05					_RSWLoop:
.018b05	bd bd 03	lda $03bd,x			lda 	DataLPtr+0,x
.018b08	48		pha				pha
.018b09	b5 16		lda $16,x			lda 	zCodePtr+0,x
.018b0b	9d bd 03	sta $03bd,x			sta 	DataLPtr+0,x
.018b0e	68		pla				pla
.018b0f	95 16		sta $16,x			sta 	zCodePtr+0,x
.018b11	ca		dex				dex
.018b12	10 f1		bpl $018b05			bpl 	_RSWLoop
.018b14	fa		plx				plx
.018b15	60		rts				rts
.018b16					READGetDataItem:
.018b16	20 f8 8a	jsr $018af8			jsr 	ReadSwapPointers 			; swap code and data pointer.
.018b19	a5 16		lda $16				lda		zCodePtr+0 					; initialise ?
.018b1b	05 17		ora $17				ora 	zCodePtr+1
.018b1d	d0 12		bne $018b31			bne 	_RGDIIsInitialised
.018b1f	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018b21	85 16		sta $16				sta 	zCodePtr+0
.018b23	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018b25	85 17		sta $17				sta 	zCodePtr+1
.018b27	a9 00		lda #$00			lda 	#0
.018b29	85 18		sta $18				sta 	zCodePtr+2
.018b2b	85 19		sta $19				sta 	zCodePtr+3
.018b2d	a0 03		ldy #$03			ldy 	#3
.018b2f	80 06		bra $018b37			bra 	_RGDIFindData 				; locate next data from start and read that.
.018b31					_RGDIIsInitialised:
.018b31	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018b33	c9 bf		cmp #$bf			cmp 	#token_Comma
.018b35	f0 49		beq $018b80			beq 	_RGDISkipEvaluateExit
.018b37					_RGDIFindData:
.018b37	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018b39	c9 00		cmp #$00			cmp 	#0 							; end of line
.018b3b	f0 19		beq $018b56			beq 	_RGDIFindNextLine
.018b3d	c9 c5		cmp #$c5			cmp 	#token_DATA 				; found data token
.018b3f	f0 3f		beq $018b80			beq 	_RGDISkipEvaluateExit 		; then skip it and evaluate
.018b41	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018b43	c8		iny				iny 								; skip
.018b44	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018b46	90 0c		bcc $018b54			bcc 	_SEDone 					; so just skip over it.
.018b48	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018b4a	90 07		bcc $018b53			bcc 	_SEDouble
.018b4c	98		tya				tya 								; this is Y + 1
.018b4d	18		clc				clc
.018b4e	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018b50	a8		tay				tay 								; back in Y.
.018b51	88		dey				dey 								; fix up, one for the +1, one for the iny
.018b52	88		dey				dey
.018b53					_SEDouble:
.018b53	c8		iny				iny
.018b54					_SEDone:
.018b54	80 e1		bra $018b37			bra 	_RGDIFindData
.018b56					_RGDIFindNextLine:
.018b56	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018b58	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.018b5a	18		clc				clc
.018b5b	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018b5d	85 16		sta $16				sta 	zCodePtr
.018b5f	90 02		bcc $018b63			bcc 	_SNLNoCarry
.018b61	e6 17		inc $17				inc 	zCodePtr+1
.018b63					_SNLNoCarry:
.018b63	a0 00		ldy #$00			ldy 	#0
.018b65	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018b67	48		pha				pha
.018b68	c8		iny				iny
.018b69	c8		iny				iny
.018b6a	c8		iny				iny
.018b6b	68		pla				pla
.018b6c	d0 c9		bne $018b37			bne 	_RGDIFindData 				; back to scanning.
.018b6e	20 f8 8a	jsr $018af8			jsr 	ReadSwapPointers 			; so we get error in line number of READ
.018b71	20 79 85	jsr $018579			jsr ERR_Handler
>018b74	4f 75 74 20 6f 66 20 44			.text "Out of Data",0
>018b7c	61 74 61 00
.018b80					_RGDISkipEvaluateExit:
.018b80	c8		iny				iny
.018b81	20 ce 90	jsr $0190ce			jsr 	EvaluateExpression 			; evaluate the expression
.018b84	20 f8 8a	jsr $018af8			jsr 	ReadSwapPointers 			; swap the pointers around.
.018b87	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/let.asm

.018b88					Command_LET:
.018b88	20 59 99	jsr $019959			jsr 	VariableFind 				; get reference to one variable.
.018b8b	a9 84		lda #$84			lda 	#token_Equal  				; get equals
.018b8d	20 94 98	jsr $019894			jsr 	CheckNextToken
.018b90	a5 22		lda $22				lda 	zVarDataPtr 				; save variable info on stack
.018b92	48		pha				pha
.018b93	a5 23		lda $23				lda 	zVarDataPtr+1
.018b95	48		pha				pha
.018b96	a5 24		lda $24				lda 	zVarType
.018b98	48		pha				pha
.018b99	20 ce 90	jsr $0190ce			jsr 	EvaluateExpression 			; evaluate the RHS, set X to zero.
.018b9c	68		pla				pla 								; restore target variable information.
.018b9d	85 24		sta $24				sta 	zVarType
.018b9f	68		pla				pla
.018ba0	85 23		sta $23				sta 	zVarDataPtr+1
.018ba2	68		pla				pla
.018ba3	85 22		sta $22				sta 	zVarDataPtr
.018ba5	20 f2 9c	jsr $019cf2			jsr 	VariableSet 				; set the value out.
.018ba8	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/get.asm

.018ba9					Command_GET:
.018ba9					_CGLoop:
.018ba9	20 59 99	jsr $019959			jsr 	VariableFind 				; get a variable.
.018bac	20 35 85	jsr $018535			jsr 	VIOCharGet 					; get character
.018baf	b0 02		bcs $018bb3			bcs 	_CGNoKey
.018bb1	a9 00		lda #$00			lda 	#0 							; if no character return zero
.018bb3					_CGNoKey:
.018bb3	48		pha				pha
.018bb4	a5 24		lda $24				lda 	zVarType 					; look at the data type.
.018bb6	c9 b7		cmp #$b7			cmp 	#token_Dollar
.018bb8	f0 1e		beq $018bd8			beq 	_CGString
.018bba	68		pla				pla 								; put character in slot.
.018bbb	85 80		sta $80				sta 	XS_Mantissa
.018bbd	a9 00		lda #$00			lda 	#0
.018bbf	85 81		sta $81				sta 	XS_Mantissa+1
.018bc1	85 82		sta $82				sta 	XS_Mantissa+2
.018bc3	85 83		sta $83				sta 	XS_Mantissa+3
.018bc5	a9 01		lda #$01			lda 	#1 							; type integer
.018bc7	85 85		sta $85				sta 	XS_Type
.018bc9					_CGWriteSetNext:
.018bc9	a2 00		ldx #$00			ldx 	#0 							; write number/WriteTempString out
.018bcb	20 f2 9c	jsr $019cf2			jsr 	VariableSet
.018bce	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018bd0	c9 bf		cmp #$bf			cmp 	#token_Comma 				; if not comma exit
.018bd2	d0 03		bne $018bd7			bne 	_CGExit
.018bd4	c8		iny				iny
.018bd5	80 d2		bra $018ba9			bra 	_CGLoop 					; and get another.
.018bd7					_CGExit:
.018bd7	60		rts				rts
.018bd8					_CGString:
.018bd8	a9 02		lda #$02			lda 	#2 							; allocate temp string, space for 2.
.018bda	20 f8 98	jsr $0198f8			jsr 	AllocateTempString 			; initially empty.
.018bdd	a5 20		lda $20				lda 	zTempStr 					; set up to be returned.
.018bdf	85 80		sta $80				sta 	XS_Mantissa
.018be1	a5 21		lda $21				lda 	zTempStr+1
.018be3	85 81		sta $81				sta 	XS_Mantissa+1
.018be5	a9 02		lda #$02			lda 	#2
.018be7	85 85		sta $85				sta 	XS_Type
.018be9	68		pla				pla 								; get A
.018bea	c9 00		cmp #$00			cmp 	#0
.018bec	f0 db		beq $018bc9			beq 	_CGWriteSetNext
.018bee	20 23 99	jsr $019923			jsr 	WriteTempString 			; write it into string
.018bf1	80 d6		bra $018bc9			bra 	_CGWriteSetNext

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/sys.asm

.018bf3					Command_SYS:
.018bf3	20 64 92	jsr $019264			jsr 	EvaluateInteger 			; address to call.
.018bf6	a5 80		lda $80				lda 	XS_Mantissa+0				; copy to localvector
.018bf8	8d 10 03	sta $0310			sta 	LocalVector+0 				; only three, can only do 24 bit calls
.018bfb	a5 81		lda $81				lda 	XS_Mantissa+1 				; and that only on 65816
.018bfd	8d 11 03	sta $0311			sta 	LocalVector+1
.018c00	a5 82		lda $82				lda 	XS_Mantissa+2
.018c02	8d 12 03	sta $0312			sta 	LocalVector+2
.018c05	22 0a 8c 01	jsl $018c0a			jsl 	_CSYLocalCall 				; jump depending on 24/16 bit code address
.018c09	60		rts				rts
.018c0a					_CSYLocalCall:
.018c0a	dc 10 03	jmp [$0310]			jmp 	[LocalVector]		 		; address

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/input.asm


;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/end.asm

.018c0d					Command_END:
>018c0d	02						.byte 	2
.018c0e	4c 32 88	jmp $018832			jmp 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/if.asm

.018c11					Command_IF:
.018c11	20 64 92	jsr $019264			jsr 	EvaluateInteger 			; check success.
.018c14	a5 80		lda $80				lda 	XS_Mantissa+0				; check the result if zero
.018c16	05 81		ora $81				ora 	XS_Mantissa+1
.018c18	05 82		ora $82				ora 	XS_Mantissa+2
.018c1a	05 83		ora $83				ora 	XS_Mantissa+3
.018c1c	aa		tax				tax 								; put into X.
.018c1d	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c1f	c9 93		cmp #$93			cmp 	#token_Then 				; then found.
.018c21	d0 2c		bne $018c4f			bne 	_FIFExtended
.018c23	c8		iny				iny
.018c24	e0 00		cpx #$00			cpx 	#0 							; was it successful.
.018c26	f0 0b		beq $018c33			beq 	_FIFEndOfLine 				; if not, go to the end of the line.
.018c28	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c2a	29 c0		and #$c0			and 	#$C0 						; is it a number
.018c2c	c9 40		cmp #$40			cmp 	#$40
.018c2e	d0 1e		bne $018c4e			bne 	_FIFContinue 				; if not, do what ever follows.
.018c30	4c 9e 8f	jmp $018f9e			jmp		Command_GOTO 				; we have IF <expr> THEN <number> so we do GOTO code.
.018c33					_FIFEndOfLine:
.018c33	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c35	c9 00		cmp #$00			cmp 	#0 							; if zero, end of line, so exit
.018c37	f0 15		beq $018c4e			beq 	_FIFContinue
.018c39	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018c3b	c8		iny				iny 								; skip
.018c3c	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018c3e	90 0c		bcc $018c4c			bcc 	_SEDone 					; so just skip over it.
.018c40	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018c42	90 07		bcc $018c4b			bcc 	_SEDouble
.018c44	98		tya				tya 								; this is Y + 1
.018c45	18		clc				clc
.018c46	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018c48	a8		tay				tay 								; back in Y.
.018c49	88		dey				dey 								; fix up, one for the +1, one for the iny
.018c4a	88		dey				dey
.018c4b					_SEDouble:
.018c4b	c8		iny				iny
.018c4c					_SEDone:
.018c4c	80 e5		bra $018c33			bra 	_FIFEndOfLine
.018c4e					_FIFContinue:
.018c4e	60		rts				rts
.018c4f					_FIFExtended:
.018c4f	da		phx				phx 								; save result
.018c50	a9 40		lda #$40			lda 	#(SMark_If << 4) 			; push marker on the stack, nothing else.
.018c52	20 b2 84	jsr $0184b2			jsr 	StackPushFrame
.018c55	68		pla				pla 								; restore result
.018c56	f0 01		beq $018c59			beq 	_FIXSkip 					; if zero then it has failed.
.018c58	60		rts				rts 								; test passed, so continue executing
.018c59					_FIXSkip:
.018c59	a9 94		lda #$94			lda 	#token_endif 				; scan forward till found either ELSE or ENDIF
.018c5b	a2 de		ldx #$de			ldx 	#token_else 				; at the same level.
.018c5d	20 f5 83	jsr $0183f5			jsr 	StructureSearchDouble
.018c60	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c62	c8		iny				iny
.018c63	c9 94		cmp #$94			cmp 	#token_endif 				; if endif, handle endif code.
.018c65	f0 07		beq $018c6e			beq 	Command_ENDIF
.018c67	60		rts				rts
.018c68					Command_ELSE:
.018c68	a9 94		lda #$94			lda 	#token_endif 				; scan forward till found ENDIF
.018c6a	20 f3 83	jsr $0183f3			jsr 	StructureSearchSingle 		; then do the ENDIF pop.
.018c6d	c8		iny				iny
.018c6e					Command_ENDIF:
.018c6e	a9 40		lda #$40			lda 	#(SMark_If << 4)
.018c70	20 c9 84	jsr $0184c9			jsr 	StackPopFrame
.018c73	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/list.asm

.018c74					Command_LIST:
.018c74	20 01 8e	jsr $018e01			jsr 	ListGetRange				; get any parameters
.018c77	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018c79	85 16		sta $16				sta 	zCodePtr+0
.018c7b	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018c7d	85 17		sta $17				sta 	zCodePtr+1
.018c7f	a9 00		lda #$00			lda 	#0
.018c81	85 18		sta $18				sta 	zCodePtr+2
.018c83	85 19		sta $19				sta 	zCodePtr+3
.018c85	a0 03		ldy #$03			ldy 	#3
.018c87	a9 00		lda #$00			lda 	#0 							; reset the indent & last indent
.018c89	8d bc 03	sta $03bc			sta 	LastListIndent
.018c8c	8d bb 03	sta $03bb			sta 	ListIndent
.018c8f					_CILLoop:
.018c8f	a0 00		ldy #$00			ldy 	#0
.018c91	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c93	c9 00		cmp #$00			cmp 	#0 							; if zero, end of program
.018c95	f0 23		beq $018cba			beq 	_CILExit
.018c97	20 40 85	jsr $018540			jsr 	VIOCheckBreak 				; check break
.018c9a	c9 00		cmp #$00			cmp 	#0
.018c9c	d0 1c		bne $018cba			bne 	_CILExit
.018c9e	20 48 8e	jsr $018e48			jsr 	ListCheckRange 				; check current line in range.
.018ca1	b0 08		bcs $018cab			bcs		_CILNext
.018ca3	a0 00		ldy #$00			ldy 	#0
.018ca5	c8		iny				iny
.018ca6	c8		iny				iny
.018ca7	c8		iny				iny
.018ca8	20 bd 8c	jsr $018cbd			jsr 	ListLine 					; list one line.
.018cab					_CILNext:
.018cab	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018cad	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.018caf	18		clc				clc
.018cb0	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018cb2	85 16		sta $16				sta 	zCodePtr
.018cb4	90 02		bcc $018cb8			bcc 	_SNLNoCarry
.018cb6	e6 17		inc $17				inc 	zCodePtr+1
.018cb8					_SNLNoCarry:
.018cb8	80 d5		bra $018c8f			bra 	_CILLoop
.018cba					_CILExit:
.018cba	4c 32 88	jmp $018832			jmp 	WarmStart
.018cbd					ListLine:
.018cbd	ad bb 03	lda $03bb			lda 	ListIndent 					; copy current list indent -> last
.018cc0	8d bc 03	sta $03bc			sta 	LastListIndent
.018cc3					_LICountIndent:
.018cc3	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018cc5	c9 00		cmp #$00			cmp 	#0
.018cc7	f0 2f		beq $018cf8			beq 	_LIDoneIndent
.018cc9	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus
.018ccb	90 16		bcc $018ce3			bcc 	_LICINext
.018ccd	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.018ccf	b0 12		bcs $018ce3			bcs 	_LICINext
.018cd1	ee bb 03	inc $03bb			inc 	ListIndent
.018cd4	c9 93		cmp #$93			cmp 	#firstKeywordMinus
.018cd6	90 0b		bcc $018ce3			bcc 	_LICINext
.018cd8	ce bb 03	dec $03bb			dec 	ListIndent
.018cdb	ce bb 03	dec $03bb			dec 	ListIndent
.018cde	10 03		bpl $018ce3			bpl 	_LICINext
.018ce0	ee bb 03	inc $03bb			inc 	ListIndent
.018ce3					_LICINext:
.018ce3	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018ce5	c8		iny				iny 								; skip
.018ce6	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018ce8	90 0c		bcc $018cf6			bcc 	_SEDone 					; so just skip over it.
.018cea	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018cec	90 07		bcc $018cf5			bcc 	_SEDouble
.018cee	98		tya				tya 								; this is Y + 1
.018cef	18		clc				clc
.018cf0	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018cf2	a8		tay				tay 								; back in Y.
.018cf3	88		dey				dey 								; fix up, one for the +1, one for the iny
.018cf4	88		dey				dey
.018cf5					_SEDouble:
.018cf5	c8		iny				iny
.018cf6					_SEDone:
.018cf6	80 cb		bra $018cc3			bra 	_LICountIndent
.018cf8					_LIDoneIndent:
.018cf8	a0 00		ldy #$00			ldy 	#0
.018cfa	c8		iny				iny
.018cfb	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018cfd	85 80		sta $80				sta 	XS_Mantissa
.018cff	c8		iny				iny
.018d00	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018d02	85 81		sta $81				sta 	XS_Mantissa+1
.018d04	20 bf 85	jsr $0185bf			jsr 	Print16BitInteger 			; print integer.
.018d07	85 10		sta $10				sta 	zTemp1 						; save spaces printed.
.018d09	ad bb 03	lda $03bb			lda 	ListIndent 					; smaller of current/prev indent
.018d0c	cd bc 03	cmp $03bc			cmp 	LastListIndent
.018d0f	90 03		bcc $018d14			bcc 	_LISmaller
.018d11	ad bc 03	lda $03bc			lda 	LastListIndent
.018d14					_LISmaller:
.018d14	0a		asl a				asl 	a 							; double indent
.018d15	49 ff		eor #$ff			eor 	#$FF 						; 2's complement arithmetic
.018d17	38		sec				sec
.018d18	65 10		adc $10				adc 	zTemp1 						; "subtract" indent e.g. print more.
.018d1a	aa		tax				tax 								; print spaces to column 6
.018d1b					_LISpace:
.018d1b	a9 20		lda #$20			lda 	#" "
.018d1d	20 f1 8d	jsr $018df1			jsr 	ListPrintLC
.018d20	e8		inx				inx
.018d21	e0 06		cpx #$06			cpx 	#6
.018d23	d0 f6		bne $018d1b			bne 	_LISpace
.018d25					_LIDecode:
.018d25	c8		iny				iny
.018d26	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018d28	c9 00		cmp #$00			cmp 	#0 							; zero, exit.
.018d2a	f0 0f		beq $018d3b			beq 	_LIExit
.018d2c	30 12		bmi $018d40			bmi 	_LIToken
.018d2e	c9 40		cmp #$40			cmp 	#$40 						; 01-$3F, character.
.018d30	b0 50		bcs $018d82			bcs 	_LIInteger
.018d32	49 20		eor #$20			eor 	#$20 						; make 7 bit
.018d34	69 20		adc #$20			adc 	#$20
.018d36	20 f1 8d	jsr $018df1			jsr 	ListPrintLC 				; print in LC
.018d39	80 ea		bra $018d25			bra 	_LIDecode
.018d3b					_LIExit:
.018d3b	a9 0d		lda #$0d			lda 	#13 						; print new line.
.018d3d	4c f1 8d	jmp $018df1			jmp 	ListPrintLC
.018d40					_LIToken:
.018d40	c9 fc		cmp #$fc			cmp 	#$FC 						; $FC-$FF ?
.018d42	90 49		bcc $018d8d			bcc		_LICommandToken
.018d44	48		pha				pha 								; save in case end
.018d45	a2 22		ldx #$22			ldx 	#'"'						; print if $FE quoted string
.018d47	c9 fe		cmp #$fe			cmp 	#$FE
.018d49	f0 17		beq $018d62			beq 	_LIPrint
.018d4b	a2 2e		ldx #$2e			ldx 	#'.'						; print if $FD decimals
.018d4d	c9 fd		cmp #$fd			cmp 	#$FD
.018d4f	f0 11		beq $018d62			beq 	_LIPrint
.018d51	a9 52		lda #$52			lda 	#'R'						; must be REM
.018d53	20 f1 8d	jsr $018df1			jsr 	ListPrintLC
.018d56	a9 45		lda #$45			lda 	#'E'
.018d58	20 f1 8d	jsr $018df1			jsr 	ListPrintLC
.018d5b	a9 4d		lda #$4d			lda 	#'M'
.018d5d	20 f1 8d	jsr $018df1			jsr 	ListPrintLC
.018d60	a2 20		ldx #$20			ldx 	#' '
.018d62					_LIPrint:
.018d62	8a		txa				txa
.018d63	20 f1 8d	jsr $018df1			jsr 	ListPrintLC
.018d66	c8		iny				iny
.018d67	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018d69	aa		tax				tax 								; put in X
.018d6a	ca		dex				dex
.018d6b					_LILoop:
.018d6b	ca		dex				dex 								; exit when count reached zero.
.018d6c	f0 08		beq $018d76			beq 	_LIEnd
.018d6e	c8		iny				iny
.018d6f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018d71	20 f1 8d	jsr $018df1			jsr 	ListPrintLC
.018d74	80 f5		bra $018d6b			bra 	_LILoop
.018d76	68		pla		_LIEnd:	pla 								; get A back
.018d77	c9 fe		cmp #$fe			cmp 	#$FE 						; if '"' need closing quotes
.018d79	d0 aa		bne $018d25			bne 	_LIDecode
.018d7b	a9 22		lda #$22			lda 	#'"'
.018d7d	20 f1 8d	jsr $018df1			jsr 	ListPrintLC
.018d80	80 a3		bra $018d25			bra 	_LIDecode
.018d82					_LIInteger:
.018d82	a2 00		ldx #$00			ldx 	#0
.018d84	20 d6 91	jsr $0191d6			jsr 	EvaluateGetInteger 			; get an atom
.018d87	88		dey				dey
.018d88	20 c5 85	jsr $0185c5			jsr 	Print32BitInteger 			; print integer.
.018d8b	80 98		bra $018d25			bra 	_LIDecode
.018d8d					_LICommandToken:
.018d8d	5a		phy				phy 								; save Y
.018d8e	48		pha				pha 								; save token
.018d8f	a2 bd		ldx #$bd			ldx  	#KeywordText & $FF 			; address of keyword text table.
.018d91	a9 86		lda #$86			lda 	(#KeywordText >> 8) & $FF
.018d93	86 1a		stx $1a				stx 	zLTemp1
.018d95	85 1b		sta $1b				sta 	zLTemp1+1
.018d97	a9 01		lda #$01			lda 	(#KeywordText >> 16) & $FF 	; this is for 65816 (it's a table in code
.018d99	85 1c		sta $1c				sta 	zLTemp1+2 					; space) and won't affect a 6502 at all.
.018d9b	68		pla				pla 								; get token
.018d9c	29 7f		and #$7f			and 	#127 						; chuck bit 7.
.018d9e	f0 16		beq $018db6			beq 	_LIFoundToken
.018da0	aa		tax				tax
.018da1					_LITokenLoop:
.018da1	a0 00		ldy #$00			ldy 	#0 							; last character not a token.
.018da3					_LIFindEnd:
.018da3	b7 1a		lda [$1a],y			lda 	[zLTemp1],y
.018da5	c8		iny				iny
.018da6	0a		asl a				asl 	a
.018da7	90 fa		bcc $018da3			bcc 	_LIFindEnd
.018da9	98		tya				tya 								; that is step to the next
.018daa	18		clc				clc 								; we don't bother bumping the 3rd byte
.018dab	65 1a		adc $1a				adc 	zLTemp1 					; here.
.018dad	85 1a		sta $1a				sta 	zLTemp1
.018daf	90 02		bcc $018db3			bcc 	_LINoBump
.018db1	e6 1b		inc $1b				inc 	zLTemp1+1
.018db3					_LINoBump:
.018db3	ca		dex				dex 								; no go round again.
.018db4	d0 eb		bne $018da1			bne 	_LITokenLoop
.018db6					_LIFoundToken:
.018db6	a0 00		ldy #$00			ldy 	#0
.018db8					_LIPrintToken:
.018db8	b7 1a		lda [$1a],y			lda 	[zLTemp1],y
.018dba	c0 00		cpy #$00			cpy 	#0 							; see if needs prefix space
.018dbc	d0 16		bne $018dd4			bne 	_LINoPrefixSpace
.018dbe	c9 41		cmp #$41			cmp 	#"A" 						; e.g. alphabetic token.
.018dc0	90 12		bcc $018dd4			bcc 	_LINoPrefixSpace
.018dc2	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018dc4	b0 0e		bcs $018dd4			bcs 	_LINoPrefixSpace
.018dc6	ae ba 03	ldx $03ba			ldx 	LastPrinted 				; if last was space not required
.018dc9	e0 20		cpx #$20			cpx 	#" "
.018dcb	f0 07		beq $018dd4			beq 	_LINoPrefixSpace
.018dcd	48		pha				pha
.018dce	a9 20		lda #$20			lda 	#" "
.018dd0	20 f1 8d	jsr $018df1			jsr 	ListPrintLC
.018dd3	68		pla				pla
.018dd4					_LINoPrefixSpace:
.018dd4	c8		iny				iny
.018dd5	48		pha				pha 								; save it
.018dd6	29 7f		and #$7f			and 	#$7F
.018dd8	20 f1 8d	jsr $018df1			jsr 	ListPrintLC
.018ddb	68		pla				pla
.018ddc	10 da		bpl $018db8			bpl 	_LIPrintToken 				; go back if not end
.018dde	7a		ply				ply 								; restore Y
.018ddf	29 7f		and #$7f			and 	#$7F 						; if last char is a letter
.018de1	c9 41		cmp #$41			cmp 	#"A"
.018de3	90 09		bcc $018dee			bcc 	_LINotLetter2
.018de5	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018de7	b0 05		bcs $018dee			bcs 	_LINotLetter2
.018de9	a9 20		lda #$20			lda 	#" " 						; add spacing
.018deb	20 f1 8d	jsr $018df1			jsr 	ListPrintLC
.018dee					_LINotLetter2:
.018dee	4c 25 8d	jmp $018d25			jmp 	_LIDecode
.018df1					ListPrintLC:
.018df1	8d ba 03	sta $03ba			sta 	LastPrinted
.018df4	c9 41		cmp #$41			cmp 	#"A"
.018df6	90 06		bcc $018dfe			bcc 	_LPLC0
.018df8	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018dfa	b0 02		bcs $018dfe			bcs 	_LPLC0
.018dfc	69 20		adc #$20			adc 	#$20
.018dfe	4c 32 85	jmp $018532	_LPLC0:	jmp 	VIOCharPrint
.018e01					ListGetRange:
.018e01	a2 0b		ldx #$0b			ldx 	#XS_Size*2-1 				; clear first 2 slots back to defaults.
.018e03					_LGRClear:
.018e03	a9 00		lda #$00			lda 	#0
.018e05	95 80		sta $80,x			sta 	XS_Mantissa,x
.018e07	ca		dex				dex
.018e08	10 f9		bpl $018e03			bpl 	_LGRClear
.018e0a	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e0c	c9 00		cmp #$00			cmp 	#0 							; nothing
.018e0e	f0 21		beq $018e31			beq 	_LGRBlank
.018e10	c9 c0		cmp #$c0			cmp 	#token_Colon 				; or colon
.018e12	f0 1d		beq $018e31			beq 	_LGRBlank
.018e14	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma
.018e16	f0 18		beq $018e30			beq 	_LGREnd 					; then it's LIST ,x
.018e18	20 64 92	jsr $019264			jsr 	EvaluateInteger 			; get the first number into bottom
.018e1b	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e1d	c9 bf		cmp #$bf			cmp 	#token_Comma
.018e1f	f0 0f		beq $018e30			beq 	_LGREnd 					; then it is LIST a,b
.018e21	a5 80		lda $80				lda 	XS_Mantissa+0 				; copy first to second LIST n is n,n
.018e23	85 86		sta $86				sta 	XS_Mantissa+XS_Size+0
.018e25	a5 81		lda $81				lda 	XS_Mantissa+1
.018e27	85 87		sta $87				sta 	XS_Mantissa+XS_Size+1
.018e29					_LGRBumpExit:
.018e29	e6 86		inc $86				inc 	XS_Mantissa+XS_Size 		; bump it so we can use cc.
.018e2b	d0 02		bne $018e2f			bne 	_LGRBump2
.018e2d	e6 87		inc $87				inc 	XS_Mantissa+XS_Size+1
.018e2f					_LGRBump2:
.018e2f	60		rts				rts
.018e30					_LGREnd:
.018e30	c8		iny				iny
.018e31					_LGRBlank:
.018e31	a9 ff		lda #$ff			lda 	#$FF 						; default to the end.
.018e33	85 86		sta $86				sta 	XS_Mantissa+XS_Size
.018e35	85 87		sta $87				sta 	XS_Mantissa+XS_Size+1
.018e37	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e39	c9 00		cmp #$00			cmp 	#0
.018e3b	f0 f2		beq $018e2f			beq 	_LGRBump2
.018e3d	0a		asl a				asl 	a 							; if not a number, then exit (to end)
.018e3e	b0 ef		bcs $018e2f			bcs 	_LGRBump2
.018e40	a2 06		ldx #$06			ldx 	#XS_Size 					; get to range
.018e42	20 66 92	jsr $019266			jsr 	EvaluateIntegerX
.018e45	80 e2		bra $018e29			bra 	_LGRBumpExit
.018e47	60		rts				rts
.018e48					ListCheckRange:
.018e48	c8		iny				iny
.018e49	a2 00		ldx #$00			ldx 	#0 							; test low
.018e4b	20 58 8e	jsr $018e58			jsr 	_LCRCompare
.018e4e	90 06		bcc $018e56			bcc 	_LCRFail
.018e50	a2 06		ldx #$06			ldx 	#XS_Size 					; test high
.018e52	20 58 8e	jsr $018e58			jsr 	_LCRCompare
.018e55	60		rts				rts
.018e56					_LCRFail:
.018e56	38		sec				sec
.018e57	60		rts				rts
.018e58					_LCRCompare:
.018e58	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e5a	38		sec				sec
.018e5b	f5 80		sbc $80,x			sbc	 	XS_Mantissa+0,x
.018e5d	08		php				php
.018e5e	c8		iny				iny
.018e5f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e61	28		plp				plp
.018e62	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.018e64	08		php				php
.018e65	88		dey				dey
.018e66	28		plp				plp
.018e67	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/print.asm

.018e68					Command_PRINT:
.018e68					_CPR_Loop:
.018e68	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e6a	c9 00		cmp #$00			cmp 	#0 							; end
.018e6c	f0 24		beq $018e92			beq 	_CPR_GoNewLine
.018e6e	c9 c0		cmp #$c0			cmp 	#token_Colon
.018e70	f0 20		beq $018e92			beq 	_CPR_GoNewLine
.018e72	c9 c1		cmp #$c1			cmp 	#token_SemiColon
.018e74	f0 74		beq $018eea			beq 	_CPR_Skip
.018e76	c9 bf		cmp #$bf			cmp 	#token_Comma
.018e78	f0 57		beq $018ed1			beq 	_CPR_Tab
.018e7a	20 ce 90	jsr $0190ce			jsr 	EvaluateExpression 			; get expression.
.018e7d	a5 85		lda $85				lda 	XS_Type 					; get type.
.018e7f	29 02		and #$02			and 	#2
.018e81	d0 27		bne $018eaa			bne 	_CPR_String 				; if type = 2 output as string.
.018e83					_CPR_Number:
.018e83	a9 00		lda #$00			lda 	#0 							; reset buffer index
.018e85	8d 14 03	sta $0314			sta 	NumBufX
.018e88	a5 85		lda $85				lda 	XS_Type 					; get type
.018e8a	4a		lsr a				lsr 	a
.018e8b	b0 08		bcs $018e95			bcs 	_CPRInt 					; if msb set do as integer
.018e8d	20 b3 a3	jsr $01a3b3			jsr 	FPToString 					; call fp to str otherwise
.018e90	80 06		bra $018e98			bra 	_CPRNPrint
.018e92					_CPR_GoNewLine:
.018e92	4c f8 8e	jmp $018ef8			jmp 	_CPR_NewLine
.018e95	20 3b 9e	jsr $019e3b	_CPRInt:jsr 	IntToString
.018e98					_CPRNPrint:
.018e98	ad 15 03	lda $0315			lda 	Num_Buffer 					; is first character -
.018e9b	c9 2d		cmp #$2d			cmp 	#"-"
.018e9d	f0 05		beq $018ea4			beq 	_CPRNoSpace
.018e9f	a9 20		lda #$20			lda 	#" "						; print the leading space
.018ea1	20 32 85	jsr $018532			jsr 	VIOCharPrint 				; so beloved of MS Basics.
.018ea4					_CPRNoSpace:
.018ea4	a2 14		ldx #$14			ldx 	#(Num_Buffer-1) & $FF
.018ea6	a9 03		lda #$03			lda 	#(Num_Buffer-1) >> 8
.018ea8	80 04		bra $018eae			bra 	_CPRPrint
.018eaa					_CPR_String:
.018eaa	a6 80		ldx $80				ldx 	XS_Mantissa
.018eac	a5 81		lda $81				lda 	XS_Mantissa+1
.018eae					_CPRPrint:
.018eae	86 1e		stx $1e				stx 	zGenPtr
.018eb0	85 1f		sta $1f				sta 	zGenPtr+1
.018eb2	5a		phy				phy
.018eb3	a0 00		ldy #$00			ldy 	#0							; get length into X
.018eb5	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018eb7	aa		tax				tax
.018eb8	f0 09		beq $018ec3			beq 	_CPREndPrint 				; nothing to print
.018eba					_CPRLoop:
.018eba	c8		iny				iny
.018ebb	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018ebd	20 32 85	jsr $018532			jsr 	VIOCharPrint
.018ec0	ca		dex				dex
.018ec1	d0 f7		bne $018eba			bne 	_CPRLoop
.018ec3					_CPREndPrint:
.018ec3	a5 85		lda $85				lda 	XS_Type 					; if numeric add trailing space
.018ec5	29 02		and #$02			and 	#2
.018ec7	d0 05		bne $018ece			bne 	_CPRNoTrail
.018ec9	a9 20		lda #$20			lda 	#" "
.018ecb	20 32 85	jsr $018532			jsr 	VIOCharPrint
.018ece					_CPRNoTrail:
.018ece	7a		ply				ply
.018ecf	80 97		bra $018e68			bra 	_CPR_Loop
.018ed1					_CPR_Tab:
.018ed1	20 43 85	jsr $018543			jsr 	VIOCharGetPosition 			; print until position % 8 = 0
.018ed4					_CPR_CalcSpaces:
.018ed4	38		sec				sec 								; calculate position mod 10.
.018ed5	e9 0a		sbc #$0a			sbc 	#10
.018ed7	b0 fb		bcs $018ed4			bcs 	_CPR_CalcSpaces
.018ed9	69 0a		adc #$0a			adc 	#10
.018edb	f0 0d		beq $018eea			beq 	_CPR_Skip 					; nothing to print
.018edd	aa		tax				tax 								; print out spaces to mod 10
.018ede					_CPRTabSpaces:
.018ede	a9 20		lda #$20			lda 	#" "
.018ee0	20 32 85	jsr $018532			jsr 	VIOCharPrint
.018ee3	e8		inx				inx
.018ee4	e0 0a		cpx #$0a			cpx 	#10
.018ee6	d0 f6		bne $018ede			bne 	_CPRTabSpaces
.018ee8	80 e7		bra $018ed1			bra 	_CPR_Tab
.018eea					_CPR_Skip:
.018eea	c8		iny				iny
.018eeb	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018eed	c9 c0		cmp #$c0			cmp 	#token_Colon 				; colon or $00, exit
.018eef	f0 0c		beq $018efd			beq 	_CPR_Exit
.018ef1	c9 00		cmp #$00			cmp 	#0
.018ef3	f0 08		beq $018efd			beq 	_CPR_Exit 					; if not go round again.
.018ef5	4c 68 8e	jmp $018e68			jmp 	_CPR_Loop
.018ef8					_CPR_NewLine:
.018ef8	a9 0d		lda #$0d			lda 	#13
.018efa	20 32 85	jsr $018532			jsr 	VIOCharPrint
.018efd					_CPR_Exit:
.018efd	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/assert.asm

.018efe					Command_ASSERT:
.018efe	20 64 92	jsr $019264			jsr 	EvaluateInteger 			; calculate thing being asserted, 0=>X
.018f01	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; check if true (non-zero)
.018f03	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.018f05	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.018f07	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.018f09	f0 01		beq $018f0c			beq 	_ASFail
.018f0b	60		rts				rts
.018f0c					_ASFail:
.018f0c	20 79 85	jsr $018579			jsr ERR_Handler
>018f0f	41 73 73 65 72 74 00			.text "Assert",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/poke.asm

.018f16					Command_POKE:
.018f16	a9 01		lda #$01			lda 	#1 							; 1 byte
.018f18	80 06		bra $018f20			bra 	CmdPoke_Main
.018f1a					Command_DOKE:
.018f1a	a9 02		lda #$02			lda 	#2 							; 2 bytes
.018f1c	80 02		bra $018f20			bra 	CmdPoke_Main
.018f1e					Command_LOKE:
.018f1e	a9 04		lda #$04			lda 	#4							; 4 bytes
.018f20					CmdPoke_Main:
.018f20	48		pha				pha
.018f21	20 64 92	jsr $019264			jsr 	EvaluateInteger 			; get two parameters. First is address
.018f24	e8		inx				inx
.018f25	e8		inx				inx
.018f26	e8		inx				inx
.018f27	e8		inx				inx
.018f28	e8		inx				inx
.018f29	e8		inx				inx
.018f2a	20 b3 98	jsr $0198b3			jsr 	CheckNextComma
.018f2d	20 66 92	jsr $019266			jsr 	EvaluateIntegerX 			; second is the data.
.018f30	a5 80		lda $80				lda 	XS_Mantissa+0 				; copy the mantissa into ZLTemp1 (address)
.018f32	85 1a		sta $1a				sta 	zLTemp1
.018f34	a5 81		lda $81				lda 	XS_Mantissa+1
.018f36	85 1b		sta $1b				sta 	zLTemp1+1
.018f38	a5 82		lda $82				lda 	XS_Mantissa+2
.018f3a	85 1c		sta $1c				sta 	zLTemp1+2
.018f3c	a5 83		lda $83				lda 	XS_Mantissa+3
.018f3e	85 1d		sta $1d				sta 	zLTemp1+3
.018f40	68		pla				pla 								; get count
.018f41	5a		phy				phy 								; save Y
.018f42	20 3e 98	jsr $01983e			jsr 	MemWrite 					; write it out
.018f45	7a		ply				ply 								; restore Y and done.
.018f46	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/newold.asm

.018f47					Command_NEW:
.018f47	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018f49	85 16		sta $16				sta 	zCodePtr+0
.018f4b	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018f4d	85 17		sta $17				sta 	zCodePtr+1
.018f4f	a9 00		lda #$00			lda 	#0
.018f51	85 18		sta $18				sta 	zCodePtr+2
.018f53	85 19		sta $19				sta 	zCodePtr+3
.018f55	a0 03		ldy #$03			ldy 	#3
.018f57	a0 00		ldy #$00			ldy 	#0
.018f59	a9 00		lda #$00			lda 	#0 							; write a 0 there.
.018f5b	97 16		sta [$16],y			sta 	[zCodePtr],y
.018f5d	20 4f 98	jsr $01984f			jsr 	UpdateProgramEnd 			; update program end.
.018f60	4c 32 88	jmp $018832			jmp 	WarmStart
.018f63					Command_OLD:
.018f63	ea		nop				nop
.018f64	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018f66	85 16		sta $16				sta 	zCodePtr+0
.018f68	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018f6a	85 17		sta $17				sta 	zCodePtr+1
.018f6c	a9 00		lda #$00			lda 	#0
.018f6e	85 18		sta $18				sta 	zCodePtr+2
.018f70	85 19		sta $19				sta 	zCodePtr+3
.018f72	a0 03		ldy #$03			ldy 	#3
.018f74					_COL_Find:
.018f74	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018f76	c8		iny				iny
.018f77	c9 00		cmp #$00			cmp 	#0 							; if zero, then the position Y/Z is new offset
.018f79	f0 18		beq $018f93			beq 	_COL_Found
.018f7b	98		tya				tya
.018f7c	c9 00		cmp #$00			cmp 	#0
.018f7e	d0 f4		bne $018f74			bne 	_COL_Find 					; can't find old EOL, give up.
.018f80	20 79 85	jsr $018579			jsr ERR_Handler
>018f83	50 72 6f 67 72 61 6d 20			.text "Program Corrupt",0
>018f8b	43 6f 72 72 75 70 74 00
.018f93					_COL_Found:
.018f93	98		tya				tya
.018f94	48		pha				pha
.018f95	a0 00		ldy #$00			ldy 	#0
.018f97	68		pla				pla
.018f98	97 16		sta [$16],y			sta 	[zCodePtr],y
.018f9a	20 4f 98	jsr $01984f			jsr 	UpdateProgramEnd 			; reset variable pointer
.018f9d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/branch.asm

.018f9e					Command_GOTO:
.018f9e	20 f3 8f	jsr $018ff3			jsr 	GotoGetLineNumber
.018fa1					CmdGOTO:
.018fa1	a2 00		ldx #$00			ldx 	#0
.018fa3	4c 10 90	jmp $019010			jmp 	GotoChangeToLineNumberX
.018fa6					Command_GOSUB:
.018fa6	20 f3 8f	jsr $018ff3			jsr 	GotoGetLineNumber
.018fa9					CmdGOSUB:
.018fa9	20 f9 84	jsr $0184f9			jsr 	StackSavePosition
.018fac	a9 15		lda #$15			lda 	#(SMark_Gosub << 4)+SourcePosSize
.018fae	20 b2 84	jsr $0184b2			jsr 	StackPushFrame
.018fb1	a2 00		ldx #$00			ldx		#0
.018fb3	4c 10 90	jmp $019010			jmp 	GotoChangeToLineNumberX
.018fb6					Command_RETURN:
.018fb6	a9 10		lda #$10			lda 	#(SMark_Gosub << 4)
.018fb8	20 c9 84	jsr $0184c9			jsr 	StackPopFrame
.018fbb	20 16 85	jsr $018516			jsr 	StackRestorePosition
.018fbe	60		rts				rts
.018fbf					Command_ON:
.018fbf	a2 00		ldx #$00			ldx 	#0 							; get the ON.
.018fc1	20 01 97	jsr $019701			jsr 	SLIByteParameter
.018fc4	a5 80		lda $80				lda 	XS_Mantissa+0 				; get the count
.018fc6	f0 28		beq $018ff0			beq 	_CONFail 					; can't be zero.
.018fc8	aa		tax				tax 								; save in X.
.018fc9	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018fcb	c8		iny				iny
.018fcc	48		pha				pha
.018fcd	c9 cc		cmp #$cc			cmp 	#token_GOTO 				; must be GOTO or GOSUB
.018fcf	f0 07		beq $018fd8			beq 	_CONOkayToken
.018fd1	c9 ca		cmp #$ca			cmp 	#token_GOSUB
.018fd3	f0 03		beq $018fd8			beq 	_CONOkayToken
.018fd5	4c 4a 85	jmp $01854a			jmp 	SyntaxError
.018fd8					_CONOkayToken:
.018fd8	da		phx				phx 								; count on top, GOTO/GOSUB token 2nd.
.018fd9					_CONFindNumber:
.018fd9	20 f3 8f	jsr $018ff3			jsr 	GotoGetLineNumber 			; get a line number.
.018fdc	fa		plx				plx 								; restore count
.018fdd	ca		dex				dex  								; decrement, exit if zero.
.018fde	f0 06		beq $018fe6			beq 	_CONFound
.018fe0	da		phx				phx 								; push back
.018fe1	20 b3 98	jsr $0198b3			jsr 	CheckNextComma				; check for comma
.018fe4	80 f3		bra $018fd9			bra 	_CONFindNumber
.018fe6					_CONFound:
.018fe6	68		pla				pla 								; get token
.018fe7	c9 cc		cmp #$cc			cmp 	#token_GOTO 				; if GOTO
.018fe9	f0 b6		beq $018fa1			beq		CmdGOTO 					; then just branch.
.018feb	20 80 84	jsr $018480			jsr 	SkipEndOfCommand 			; go to end of command
.018fee	80 b9		bra $018fa9			bra 	CmdGOSUB 					; and do a GOSUB.
.018ff0					_CONFail:
.018ff0	4c 68 85	jmp $018568			jmp 	BadParamError
.018ff3					GotoGetLineNumber:
.018ff3	20 64 92	jsr $019264			jsr 	EvaluateInteger
.018ff6	a5 82		lda $82				lda 	XS_Mantissa+2 				; check range
.018ff8	05 83		ora $83				ora 	XS_Mantissa+3
.018ffa	d0 01		bne $018ffd			bne 	_GLINError
.018ffc	60		rts				rts
.018ffd					_GLINError:
.018ffd	20 79 85	jsr $018579			jsr ERR_Handler
>019000	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>019008	20 4e 75 6d 62 65 72 00
.019010					GotoChangeToLineNumberX:
.019010	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check line number not zero
.019012	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019014	f0 37		beq $01904d			beq 	_GCTLFail
.019016	a9 00		lda #$00			lda 	#BasicProgram & $FF
.019018	85 16		sta $16				sta 	zCodePtr+0
.01901a	a9 10		lda #$10			lda 	#BasicProgram >> 8
.01901c	85 17		sta $17				sta 	zCodePtr+1
.01901e	a9 00		lda #$00			lda 	#0
.019020	85 18		sta $18				sta 	zCodePtr+2
.019022	85 19		sta $19				sta 	zCodePtr+3
.019024	a0 03		ldy #$03			ldy 	#3
.019026					_GCTLLoop:
.019026	a0 00		ldy #$00			ldy 	#0
.019028	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01902a	c9 00		cmp #$00			cmp 	#0
.01902c	f0 1f		beq $01904d			beq 	_GCTLFail
.01902e	c8		iny				iny
.01902f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019031	d5 80		cmp $80,x			cmp 	XS_Mantissa+0,x
.019033	d0 07		bne $01903c			bne 	_GCTLNext
.019035	c8		iny				iny
.019036	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019038	d5 81		cmp $81,x			cmp 	XS_Mantissa+1,x
.01903a	f0 0f		beq $01904b			beq 	_GCTLExit
.01903c					_GCTLNext:
.01903c	a0 00		ldy #$00			ldy 	#0 							; point to offset
.01903e	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.019040	18		clc				clc
.019041	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.019043	85 16		sta $16				sta 	zCodePtr
.019045	90 02		bcc $019049			bcc 	_SNLNoCarry
.019047	e6 17		inc $17				inc 	zCodePtr+1
.019049					_SNLNoCarry:
.019049	80 db		bra $019026			bra 	_GCTLLoop 					; try next line.
.01904b					_GCTLExit:
.01904b	c8		iny				iny
.01904c	60		rts				rts
.01904d					_GCTLFail:
.01904d	20 79 85	jsr $018579			jsr ERR_Handler
>019050	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>019058	20 4e 75 6d 62 65 72 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.019060					Command_CLR:
.019060					ResetRunStatus:
.019060	20 95 99	jsr $019995			jsr 	VariableClear
.019063	20 a0 84	jsr $0184a0			jsr 	StackReset
.019066	a9 00		lda #$00			lda 	#HighMemory & $FF
.019068	8d 00 03	sta $0300			sta 	StringPtr
.01906b	a9 7f		lda #$7f			lda 	#HighMemory >> 8
.01906d	8d 01 03	sta $0301			sta 	StringPtr+1
.019070	20 5f 9b	jsr $019b5f			jsr 	ArrayResetDefault
.019073	20 ed 8a	jsr $018aed			jsr 	Command_RESTORE
.019076	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/stop.asm

.019077					Command_STOP:
.019077	20 79 85	jsr $018579			jsr ERR_Handler
>01907a	53 74 6f 70 00				.text "Stop",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/while.asm

.01907f					Command_WHILE:
.01907f	20 f9 84	jsr $0184f9			jsr 	StackSavePosition			; save position into stack, but don't yet push.
.019082	20 64 92	jsr $019264			jsr 	EvaluateInteger 			; calculate the while loop value.
.019085	a5 80		lda $80				lda 	XS_Mantissa+0				; check the result if zero
.019087	05 81		ora $81				ora 	XS_Mantissa+1
.019089	05 82		ora $82				ora 	XS_Mantissa+2
.01908b	05 83		ora $83				ora 	XS_Mantissa+3
.01908d	f0 06		beq $019095			beq 	_CWHSkip 					; if it is zero, then skip to WEND.
.01908f	a9 35		lda #$35			lda 	#(SMark_While << 4)+SourcePosSize
.019091	20 b2 84	jsr $0184b2			jsr 	StackPushFrame 				; push on stack
.019094	60		rts				rts
.019095					_CWHSkip:
.019095	a9 95		lda #$95			lda 	#token_Wend 				; look for the WEND token.
.019097	20 f3 83	jsr $0183f3			jsr 	StructureSearchSingle
.01909a	c8		iny				iny
.01909b	60		rts				rts
.01909c					Command_WEND:
.01909c	a9 30		lda #$30			lda 	#(SMark_While << 4)			; remove the frame
.01909e	20 c9 84	jsr $0184c9			jsr 	StackPopFrame
.0190a1	20 16 85	jsr $018516			jsr 	StackRestorePosition
.0190a4	80 d9		bra $01907f			bra 	Command_WHILE 				; and do the while again.
.0190a6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/repeat.asm

.0190a7					Command_REPEAT:
.0190a7	20 f9 84	jsr $0184f9			jsr 	StackSavePosition			; save position into stack
.0190aa	a9 25		lda #$25			lda 	#(SMark_Repeat << 4)+SourcePosSize
.0190ac	20 b2 84	jsr $0184b2			jsr 	StackPushFrame 				; push on stack
.0190af	60		rts				rts
.0190b0					Command_UNTIL:
.0190b0	a9 20		lda #$20			lda 	#(SMark_Repeat << 4)		; remove the frame
.0190b2	20 c9 84	jsr $0184c9			jsr 	StackPopFrame
.0190b5	20 64 92	jsr $019264			jsr 	EvaluateInteger				; work out UNTIL
.0190b8	a5 80		lda $80				lda 	XS_Mantissa+0 				; check if zero.
.0190ba	05 81		ora $81				ora 	XS_Mantissa+1
.0190bc	05 82		ora $82				ora 	XS_Mantissa+2
.0190be	05 83		ora $83				ora 	XS_Mantissa+3
.0190c0	d0 08		bne $0190ca			bne 	_CUTExit 					; if not, just exit
.0190c2	20 16 85	jsr $018516			jsr 	StackRestorePosition 		; otherwise loop round again.
.0190c5	a9 25		lda #$25			lda 	#(SMark_Repeat << 4)+SourcePosSize
.0190c7	20 b2 84	jsr $0184b2			jsr 	StackPushFrame 				; fix the stack back.
.0190ca					_CUTExit:
.0190ca	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.0190cb					EVESyntax:
.0190cb	4c 4a 85	jmp $01854a			jmp 	SyntaxError
.0190ce					EvaluateExpression:
.0190ce	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.0190d0					EvaluateExpressionX:
.0190d0	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.0190d2					EvaluateExpressionXA:
.0190d2	48		pha				pha 								; save precedence on stack.
.0190d3	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0190d5	f0 f4		beq $0190cb			beq 	EVESyntax 					; end of line, syntax error.
.0190d7	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.0190d9	b0 03		bcs $0190de			bcs 	_EVNotVariable
.0190db	4c a8 91	jmp $0191a8			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.0190de					_EVNotVariable:
.0190de	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.0190e0	90 e9		bcc $0190cb			bcc 	EVESyntax
.0190e2	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.0190e4	b0 58		bcs $01913e			bcs 	_EVNotInteger
.0190e6	20 d6 91	jsr $0191d6			jsr 	EvaluateGetInteger
.0190e9					_EVCheckDecimal:
.0190e9	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0190eb	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.0190ed	d0 05		bne $0190f4			bne 	_EVGotAtom 					; no, get atom.
.0190ef					_EVIsDecimal:
.0190ef	20 fc 91	jsr $0191fc			jsr 	EVGetDecimal 				; extend to the decimal part.
.0190f2	80 00		bra $0190f4			bra 	_EVGotAtom 					; and continue to got atom.
.0190f4					_EVGotAtom:
.0190f4	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0190f6	10 44		bpl $01913c			bpl 	_EVExitDrop 				; must be a token.
.0190f8	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.0190fa	b0 40		bcs $01913c			bcs 	_EVExitDrop
.0190fc	68		pla				pla 								; get current precedence
.0190fd	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.0190ff	da		phx				phx 								; save X
.019100	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019102	aa		tax				tax 								; put in X
.019103	bf 2e 86 01	lda $01862e,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.019107	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.019109	fa		plx				plx 								; restore X
.01910a	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.01910c	90 2f		bcc $01913d			bcc 	_EVExit 					; exit if too low.
.01910e	f0 2d		beq $01913d			beq 	_EVExit 					; exit if equals
.019110	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.019112	48		pha				pha
.019113	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019115	48		pha				pha
.019116	c8		iny				iny
.019117	da		phx				phx 								; save current position
.019118	e8		inx				inx
.019119	e8		inx				inx
.01911a	e8		inx				inx
.01911b	e8		inx				inx
.01911c	e8		inx				inx
.01911d	e8		inx				inx
.01911e	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.019120	20 d2 90	jsr $0190d2			jsr 	EvaluateExpressionXA 		; do the RHS.
.019123	fa		plx				plx 								; restore X
.019124	68		pla				pla 								; get the binary operator in A.
.019125					_EVCallA:
.019125	da		phx				phx 								; save X again
.019126	0a		asl a				asl 	a 							; double, lose the MSB.
.019127	aa		tax				tax									; put in X
.019128	bf dd 85 01	lda $0185dd,x			lda 	VectorTable,x 				; copy address into zGenPtr
.01912c	8d 11 03	sta $0311			sta 	LocalVector+1
.01912f	bf de 85 01	lda $0185de,x			lda 	VectorTable+1,x
.019133	8d 12 03	sta $0312			sta 	LocalVector+2
.019136	fa		plx				plx 								; restore X
.019137	20 b1 91	jsr $0191b1			jsr 	EVCallLocalVector
.01913a	80 b8		bra $0190f4			bra 	_EVGotAtom 					; and loop back.
.01913c					_EVExitDrop:
.01913c	68		pla				pla
.01913d					_EVExit:
.01913d	60		rts				rts
.01913e					_EVNotInteger:
.01913e	c8		iny				iny
.01913f	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.019141	d0 16		bne $019159			bne 	_EVNotMinus
.019143	20 45 92	jsr $019245			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.019146	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.019148	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.01914a	f0 05		beq $019151			beq 	_EVMinusFloat
.01914c	20 1e 9e	jsr $019e1e			jsr 	IntegerNegateAlways 		; negation
.01914f	80 a3		bra $0190f4			bra 	_EVGotAtom 					; and go back.
.019151					_EVMinusFloat:
.019151	b5 85		lda $85,x			lda 	XS_Type,x 					; invert the sign bit.
.019153	49 80		eor #$80			eor 	#$80
.019155	95 85		sta $85,x			sta 	XS_Type,x
.019157	80 9b		bra $0190f4			bra 	_EVGotAtom
.019159					_EVNotMinus:
.019159	c9 bd		cmp #$bd			cmp 	#token_lparen 				; is it left parenthesis
.01915b	d0 17		bne $019174			bne 	_EVNotParenthesis
.01915d	20 d0 90	jsr $0190d0			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.019160	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019162	c8		iny				iny
.019163	c9 be		cmp #$be			cmp 	#token_rparen 				; okay if right bracket.
.019165	f0 8d		beq $0190f4			beq 	_EVGotAtom
.019167	20 79 85	jsr $018579			jsr ERR_Handler
>01916a	4d 69 73 73 69 6e 67 20			.text "Missing )",0
>019172	29 00
.019174					_EVNotParenthesis:
.019174	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.019176	d0 0c		bne $019184			bne 	_EVNotNot
.019178	20 45 92	jsr $019245			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.01917b	20 b4 a2	jsr $01a2b4			jsr 	FPUToInteger 				; make it an integer - if possible.
.01917e	20 2a 92	jsr $01922a			jsr 	NotInteger 					; do the not calculation
.019181	4c f4 90	jmp $0190f4			jmp 	_EVGotAtom
.019184					_EVNotNot:
.019184	c9 fe		cmp #$fe			cmp 	#$FE
.019186	d0 12		bne $01919a			bne 	_EVNotString
.019188	20 33 99	jsr $019933			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.01918b	a5 20		lda $20				lda 	zTempStr 					; copy address of string into mantissa
.01918d	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01918f	a5 21		lda $21				lda 	zTempStr+1
.019191	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019193	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.019195	95 85		sta $85,x			sta 	XS_Type,x
.019197	4c f4 90	jmp $0190f4			jmp 	_EVGotAtom
.01919a					_EVNotString:
.01919a	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.01919c	90 04		bcc $0191a2			bcc 	_EVBadElement
.01919e	c9 b7		cmp #$b7			cmp 	#lastUnaryFunction+1
.0191a0	90 03		bcc $0191a5			bcc 	_EVUnaryFunction
.0191a2					_EVBadElement:
.0191a2	4c 4a 85	jmp $01854a			jmp 	SyntaxError
.0191a5					_EVUnaryFunction:
.0191a5	4c 25 91	jmp $019125			jmp 	_EVCallA
.0191a8					_EVVariableHandler:
.0191a8	20 59 99	jsr $019959			jsr 	VariableFind 				; locate a variable
.0191ab	20 a1 9c	jsr $019ca1			jsr 	VariableGet 				; copy into memory.
.0191ae	4c f4 90	jmp $0190f4			jmp 	_EVGotAtom 					; and go round.
.0191b1					EVCallLocalVector:
.0191b1	6c 11 03	jmp ($0311)			jmp 	(LocalVector+1)
.0191b4					EVShiftMantissaLeft6:
.0191b4	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.0191b6	95 84		sta $84,x			sta 	XS_Exponent,x
.0191b8	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0191ba	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0191bc	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0191be	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0191c0	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0191c2	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0191c4	a9 00		lda #$00			lda 	#0
.0191c6	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0191c8	20 cb 91	jsr $0191cb			jsr 	_EVSMLShift 					; call it here to do it twice
.0191cb					_EVSMLShift:
.0191cb	56 84		lsr $84,x			lsr 	XS_Exponent,x
.0191cd	76 83		ror $83,x			ror 	XS_Mantissa+3,x
.0191cf	76 82		ror $82,x			ror 	XS_Mantissa+2,x
.0191d1	76 81		ror $81,x			ror 	XS_Mantissa+1,x
.0191d3	76 80		ror $80,x			ror 	XS_Mantissa+0,x
.0191d5	60		rts				rts
.0191d6					EvaluateGetInteger:
.0191d6	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0191d8	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.0191da	95 80		sta $80,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.0191dc	a9 00		lda #$00			lda 	#0
.0191de	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0191e0	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0191e2	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0191e4	1a		inc a				inc 	a 							; set to type 1 (integer)
.0191e5	95 85		sta $85,x			sta 	XS_Type,x
.0191e7					_EVCheckNextInteger:
.0191e7	c8		iny				iny
.0191e8	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0191ea	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.0191ec	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.0191ee	b0 0b		bcs $0191fb			bcs 	_EVEndInteger
.0191f0	48		pha				pha 								; save it.
.0191f1	20 b4 91	jsr $0191b4			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.0191f4	68		pla				pla
.0191f5	15 80		ora $80,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.0191f7	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0191f9	80 ec		bra $0191e7			bra 	_EVCheckNextInteger
.0191fb					_EVEndInteger:
.0191fb	60		rts				rts
.0191fc					EVGetDecimal:
.0191fc	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.0191fe	8d 15 03	sta $0315			sta 	Num_Buffer
.019201	da		phx				phx
.019202	c8		iny				iny
.019203	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019205	c8		iny				iny
.019206	3a		dec a				dec 	a								; convert to a string length.
.019207	3a		dec a				dec 	a
.019208	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.01920a					_EVGDCopy:
.01920a	48		pha				pha 									; save count
.01920b	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01920d	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.019210	e8		inx				inx 									; forward ....
.019211	c8		iny				iny
.019212	68		pla				pla 									; get count
.019213	3a		dec a				dec 	a 								; until zero
.019214	d0 f4		bne $01920a			bne 	_EVGDCopy
.019216	9d 15 03	sta $0315,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.019219	fa		plx				plx 									; restore X
.01921a	a9 15		lda #$15			lda 	#Num_Buffer & $FF 				; set zGenPtr
.01921c	85 1e		sta $1e				sta 	zGenPtr
.01921e	a9 03		lda #$03			lda 	#Num_Buffer >> 8
.019220	85 1f		sta $1f				sta 	zGenPtr+1
.019222	5a		phy				phy 									; save Y
.019223	a0 00		ldy #$00			ldy 	#0 								; start position
.019225	20 6e a4	jsr $01a46e			jsr 	FPFromString 					; convert current
.019228	7a		ply				ply 									; restore Y
.019229	60		rts				rts
.01922a					NotInteger:
.01922a	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01922c	49 ff		eor #$ff			eor 	#$FF
.01922e	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019230	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019232	49 ff		eor #$ff			eor 	#$FF
.019234	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019236	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019238	49 ff		eor #$ff			eor 	#$FF
.01923a	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01923c	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01923e	49 ff		eor #$ff			eor 	#$FF
.019240	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019242	60		rts				rts
.019243					EvaluateGetAtom:
.019243	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.019245					EvaluateGetAtomX:
.019245	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.019247	20 d2 90	jsr $0190d2			jsr 	EvaluateExpressionXA
.01924a	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.01924c	29 0f		and #$0f			and 	#15
.01924e	c9 02		cmp #$02			cmp 	#2
.019250	b0 01		bcs $019253			bcs 	EvaluateType
.019252	60		rts				rts
.019253					EvaluateType:
.019253	4c 5a 85	jmp $01855a			jmp 	TypeError
.019256					EvaluateNumber:
.019256	a2 00		ldx #$00			ldx 	#0
.019258					EvaluateNumberX:
.019258	20 d0 90	jsr $0190d0			jsr 	EvaluateExpressionX
.01925b	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0/1
.01925d	29 0f		and #$0f			and 	#15
.01925f	c9 02		cmp #$02			cmp 	#2
.019261	b0 f0		bcs $019253			bcs 	EvaluateType
.019263	60		rts				rts
.019264					EvaluateInteger:
.019264	a2 00		ldx #$00			ldx 	#0
.019266					EvaluateIntegerX:
.019266	20 58 92	jsr $019258			jsr 	EvaluateNumberX
.019269	20 b4 a2	jsr $01a2b4			jsr 	FPUToInteger
.01926c	60		rts				rts
.01926d					EvaluateString:
.01926d	a2 00		ldx #$00			ldx 	#0
.01926f					EvaluateStringX:
.01926f	20 d0 90	jsr $0190d0			jsr 	EvaluateExpressionX
.019272	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 2
.019274	29 0f		and #$0f			and 	#15
.019276	c9 02		cmp #$02			cmp 	#2
.019278	d0 d9		bne $019253			bne 	EvaluateType
.01927a	b5 80		lda $80,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.01927c	85 1e		sta $1e				sta 	zGenPtr
.01927e	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019280	85 1f		sta $1f				sta 	zGenPtr+1
.019282	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.019283					BinaryOp_And:
.019283	20 d7 92	jsr $0192d7			jsr 	BinaryMakeBothInteger
.019286	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.019288	35 86		and $86,x			and 	XS2_Mantissa+0,x
.01928a	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01928c	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.01928e	35 87		and $87,x			and 	XS2_Mantissa+1,x
.019290	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019292	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.019294	35 88		and $88,x			and 	XS2_Mantissa+2,x
.019296	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019298	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.01929a	35 89		and $89,x			and 	XS2_Mantissa+3,x
.01929c	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01929e	60		rts				rts
.01929f					BinaryOp_Or:
.01929f	20 d7 92	jsr $0192d7			jsr 	BinaryMakeBothInteger
.0192a2	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.0192a4	15 86		ora $86,x			ora 	XS2_Mantissa+0,x
.0192a6	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0192a8	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.0192aa	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.0192ac	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0192ae	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.0192b0	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.0192b2	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0192b4	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.0192b6	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.0192b8	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0192ba	60		rts				rts
.0192bb					BinaryOp_Eor:
.0192bb					BinaryOp_Xor:
.0192bb	20 d7 92	jsr $0192d7			jsr 	BinaryMakeBothInteger
.0192be	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.0192c0	55 86		eor $86,x			eor 	XS2_Mantissa+0,x
.0192c2	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0192c4	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.0192c6	55 87		eor $87,x			eor 	XS2_Mantissa+1,x
.0192c8	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0192ca	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.0192cc	55 88		eor $88,x			eor 	XS2_Mantissa+2,x
.0192ce	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0192d0	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.0192d2	55 89		eor $89,x			eor 	XS2_Mantissa+3,x
.0192d4	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0192d6	60		rts				rts
.0192d7					BinaryMakeBothInteger:
.0192d7	da		phx				phx 								; save X
.0192d8	e8		inx				inx
.0192d9	e8		inx				inx
.0192da	e8		inx				inx
.0192db	e8		inx				inx
.0192dc	e8		inx				inx
.0192dd	e8		inx				inx
.0192de	20 e2 92	jsr $0192e2			jsr 	BinaryMakeInteger 			; convert to integer.
.0192e1	fa		plx				plx 								; restore X and fall through.
.0192e2					BinaryMakeInteger:
.0192e2	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.0192e4	29 0f		and #$0f			and 	#15 						; check type zero
.0192e6	f0 04		beq $0192ec			beq 	_BMIConvert 				; if float convert to integer.
.0192e8	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.0192e9	90 04		bcc $0192ef			bcc 	_BMIError
.0192eb	60		rts				rts
.0192ec					_BMIConvert:
.0192ec	4c b4 a2	jmp $01a2b4			jmp 	FPUToInteger 				; convert to integer
.0192ef					_BMIError:
.0192ef	4c 5a 85	jmp $01855a			jmp 	TypeError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.0192f2					Binary_Equal:
.0192f2	20 3b 93	jsr $01933b			jsr 	CompareValues 				; compare the values
.0192f5	09 00		ora #$00			ora 	#0 							; true if 0
.0192f7	f0 33		beq $01932c			beq 	CCTrue
.0192f9	80 2d		bra $019328			bra 	CCFalse
.0192fb					Binary_NotEqual:
.0192fb	20 3b 93	jsr $01933b			jsr 	CompareValues
.0192fe	09 00		ora #$00			ora 	#0 							; true if -1 or 1
.019300	f0 26		beq $019328			beq 	CCFalse
.019302	80 28		bra $01932c			bra 	CCTrue
.019304					Binary_Less:
.019304	20 3b 93	jsr $01933b			jsr 	CompareValues
.019307	09 00		ora #$00			ora 	#0 							; true if -1
.019309	30 21		bmi $01932c			bmi 	CCTrue
.01930b	80 1b		bra $019328			bra 	CCFalse
.01930d					Binary_LessEqual:
.01930d	20 3b 93	jsr $01933b			jsr 	CompareValues
.019310	c9 01		cmp #$01			cmp 	#1 							; true if 0 or -1
.019312	d0 18		bne $01932c			bne 	CCTrue
.019314	80 12		bra $019328			bra 	CCFalse
.019316					Binary_GreaterEqual:
.019316	20 3b 93	jsr $01933b			jsr 	CompareValues
.019319	09 00		ora #$00			ora 	#0 							; true if 0 or 1
.01931b	10 0f		bpl $01932c			bpl 	CCTrue
.01931d	80 09		bra $019328			bra 	CCFalse
.01931f					Binary_Greater:
.01931f	20 3b 93	jsr $01933b			jsr 	CompareValues 				; true if 1
.019322	c9 01		cmp #$01			cmp 	#1
.019324	f0 06		beq $01932c			beq 	CCTrue
.019326	80 00		bra $019328			bra 	CCFalse
.019328	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.01932a	80 02		bra $01932e			bra 	CCWrite
.01932c	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.01932e	95 80		sta $80,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.019330	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019332	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019334	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019336	a9 01		lda #$01			lda 	#1
.019338	95 85		sta $85,x			sta 	XS_Type,x 					; set type to integer whatever.
.01933a	60		rts				rts
.01933b					CompareValues:
.01933b	b5 85		lda $85,x			lda 	XS_Type,x 					; and the types together
.01933d	35 8b		and $8b,x			and 	XS2_Type,x
.01933f	c9 02		cmp #$02			cmp 	#2 							; is it a string, then do the string
.019341	f0 11		beq $019354			beq 	_CVString					; comparison routine.
.019343	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.019345	35 8b		and $8b,x			and 	XS2_Type,x
.019347	4a		lsr a				lsr 	a 							; shift bit 0 into C
.019348	90 03		bcc $01934d			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.01934a	4c 96 93	jmp $019396			jmp 	CompareInteger32 							; so execute code at \1
.01934d					_BCFloat:
.01934d	20 3a 94	jsr $01943a			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.019350	4c ad a1	jmp $01a1ad			jmp 	FPCompare 							; and execute code at \2
.019353	60		rts				rts
.019354					_CVString:
.019354	da		phx				phx 								; save XY
.019355	5a		phy				phy
.019356	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.019358	85 1a		sta $1a				sta		zLTemp1+0
.01935a	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01935c	85 1b		sta $1b				sta 	zLTemp1+1
.01935e	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.019360	85 1c		sta $1c				sta 	zLTemp1+2
.019362	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.019364	85 1d		sta $1d				sta 	zLTemp1+3
.019366	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.019368	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.01936a	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.01936c	90 02		bcc $019370			bcc 	_CVCommon
.01936e	b1 1c		lda ($1c),y			lda 	(zLTemp1+2),y
.019370					_CVCommon:
.019370	aa		tax				tax 								; put shorter string length in zero.
.019371	f0 0c		beq $01937f			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.019373					_CVCompare:
.019373	c8		iny				iny 								; next character
.019374	b1 1a		lda ($1a),y			lda 	(zLTemp1),y 				; compare characters
.019376	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y 				; handle different values, < or >
.019378	90 13		bcc $01938d			bcc 	_CVReturnLess 				; <
.01937a	d0 15		bne $019391			bne 	_CVReturnGreater 			; >
.01937c	ca		dex				dex 								; until common length matched.
.01937d	d0 f4		bne $019373			bne 	_CVCompare
.01937f					_CVMatch:
.01937f	a0 00		ldy #$00			ldy 	#0
.019381	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.019383	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.019385	90 06		bcc $01938d			bcc 	_CVReturnLess 				; <
.019387	d0 08		bne $019391			bne 	_CVReturnGreater 			; >
.019389	a9 00		lda #$00			lda 	#0
.01938b	80 06		bra $019393			bra 	_CVExit
.01938d					_CVReturnLess:
.01938d	a9 ff		lda #$ff			lda 	#$FF
.01938f	80 02		bra $019393			bra 	_CVExit
.019391					_CVReturnGreater:
.019391	a9 01		lda #$01			lda 	#$01
.019393					_CVExit:
.019393	7a		ply				ply
.019394	fa		plx				plx
.019395	60		rts				rts
.019396					CompareInteger32:
.019396	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.019398	49 80		eor #$80			eor 	#$80
.01939a	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01939c	b5 89		lda $89,x			lda 	XS2_Mantissa+3,x
.01939e	49 80		eor #$80			eor 	#$80
.0193a0	95 89		sta $89,x			sta 	XS2_Mantissa+3,x
.0193a2	20 20 94	jsr $019420			jsr 	SubInteger32 				; subtraction
.0193a5	90 0d		bcc $0193b4			bcc 	_CI32Less 					; cc return -1
.0193a7	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check if zero
.0193a9	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.0193ab	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.0193ad	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.0193af	f0 02		beq $0193b3			beq 	_CI32Exit
.0193b1	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.0193b3					_CI32Exit:
.0193b3	60		rts				rts
.0193b4					_CI32Less:
.0193b4	a9 ff		lda #$ff			lda 	#$FF
.0193b6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.0193b7					BinaryOp_Add:
.0193b7	b5 85		lda $85,x			lda 	XS_Type,x  					; and types together
.0193b9	35 8b		and $8b,x			and 	XS2_Type,x
.0193bb	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.0193bd	d0 11		bne $0193d0			bne 	_BOAString 					; so go do the string code.
.0193bf	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.0193c1	35 8b		and $8b,x			and 	XS2_Type,x
.0193c3	4a		lsr a				lsr 	a 							; shift bit 0 into C
.0193c4	90 03		bcc $0193c9			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.0193c6	4c 06 94	jmp $019406			jmp 	AddInteger32 							; so execute code at \1
.0193c9					_BCFloat:
.0193c9	20 3a 94	jsr $01943a			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.0193cc	4c 88 9f	jmp $019f88			jmp 	FPAdd 							; and execute code at \2
.0193cf	60		rts				rts
.0193d0					_BOAString:
.0193d0	4c 54 94	jmp $019454			jmp 	ConcatenateString 			; concatenate two strings.
.0193d3					BinaryOp_Subtract:
.0193d3	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.0193d5	35 8b		and $8b,x			and 	XS2_Type,x
.0193d7	4a		lsr a				lsr 	a 							; shift bit 0 into C
.0193d8	90 03		bcc $0193dd			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.0193da	4c 20 94	jmp $019420			jmp 	SubInteger32 							; so execute code at \1
.0193dd					_BCFloat:
.0193dd	20 3a 94	jsr $01943a			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.0193e0	4c 80 9f	jmp $019f80			jmp 	FPSubtract 							; and execute code at \2
.0193e3	60		rts				rts
.0193e4					BinaryOp_Multiply:
.0193e4	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.0193e6	35 8b		and $8b,x			and 	XS2_Type,x
.0193e8	4a		lsr a				lsr 	a 							; shift bit 0 into C
.0193e9	90 03		bcc $0193ee			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.0193eb	4c 59 9d	jmp $019d59			jmp 	MulInteger32 							; so execute code at \1
.0193ee					_BCFloat:
.0193ee	20 3a 94	jsr $01943a			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.0193f1	4c af a0	jmp $01a0af			jmp 	FPMultiply 							; and execute code at \2
.0193f4	60		rts				rts
.0193f5					BinaryOp_Divide:
.0193f5	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.0193f7	35 8b		and $8b,x			and 	XS2_Type,x
.0193f9	4a		lsr a				lsr 	a 							; shift bit 0 into C
.0193fa	90 03		bcc $0193ff			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.0193fc	4c 97 9d	jmp $019d97			jmp 	DivInteger32 							; so execute code at \1
.0193ff					_BCFloat:
.0193ff	20 3a 94	jsr $01943a			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.019402	4c 3c a0	jmp $01a03c			jmp 	FPDivide 							; and execute code at \2
.019405	60		rts				rts
.019406					AddInteger32:
.019406	18		clc				clc
.019407	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019409	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.01940b	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01940d	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01940f	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.019411	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019413	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019415	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.019417	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019419	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01941b	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.01941d	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01941f	60		rts				rts
.019420					SubInteger32:
.019420	38		sec				sec
.019421	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019423	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.019425	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019427	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019429	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.01942b	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01942d	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01942f	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.019431	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019433	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019435	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.019437	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019439	60		rts				rts
.01943a					BinaryMakeBothFloat:
.01943a	da		phx				phx 								; save X
.01943b	e8		inx				inx
.01943c	e8		inx				inx
.01943d	e8		inx				inx
.01943e	e8		inx				inx
.01943f	e8		inx				inx
.019440	e8		inx				inx
.019441	20 45 94	jsr $019445			jsr 	BinaryMakeFloat 			; convert to float.
.019444	fa		plx				plx 								; restore X and fall through.
.019445					BinaryMakeFloat:
.019445	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.019447	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.019448	b0 04		bcs $01944e			bcs 	_BMFConvert
.01944a	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.01944b	b0 04		bcs $019451			bcs 	_BMFError
.01944d	60		rts				rts
.01944e					_BMFConvert:
.01944e	4c 68 a2	jmp $01a268			jmp 	FPUToFloat 					; convert to float, only float builds of course
.019451					_BMFError:
.019451	4c 5a 85	jmp $01855a			jmp 	TypeError
.019454					ConcatenateString:
.019454	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.019456	85 1a		sta $1a				sta		zLTemp1+0
.019458	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01945a	85 1b		sta $1b				sta 	zLTemp1+1
.01945c	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.01945e	85 1c		sta $1c				sta 	zLTemp1+2
.019460	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.019462	85 1d		sta $1d				sta 	zLTemp1+3
.019464	5a		phy				phy
.019465	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.019467	b1 1a		lda ($1a),y			lda 	(zlTemp1),y
.019469	71 1c		adc ($1c),y			adc 	(zlTemp1+2),y
.01946b	7a		ply				ply
.01946c	b0 33		bcs $0194a1			bcs 	_CSError					; check in range.
.01946e	c9 fe		cmp #$fe			cmp 	#maxString+1
.019470	b0 2f		bcs $0194a1			bcs 	_CSError
.019472	20 f8 98	jsr $0198f8			jsr 	AllocateTempString 			; store the result
.019475	20 8c 94	jsr $01948c			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.019478	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.01947a	85 1a		sta $1a				sta 	zLTemp1
.01947c	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.01947e	85 1b		sta $1b				sta 	zLTemp1+1
.019480	20 8c 94	jsr $01948c			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.019483	a5 20		lda $20				lda 	zTempStr 					; point current to new string
.019485	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019487	a5 21		lda $21				lda 	zTempStr+1
.019489	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01948b	60		rts				rts
.01948c					_CSCopyString:
.01948c	da		phx				phx
.01948d	5a		phy				phy
.01948e	a0 00		ldy #$00			ldy 	#0 							; get length
.019490	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.019492	f0 0a		beq $01949e			beq 	_CSCSExit 					; if zero, exit immediately
.019494	aa		tax				tax 								; put in X which is the counter.
.019495					_CSCSLoop:
.019495	c8		iny				iny 								; get next char
.019496	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.019498	20 23 99	jsr $019923			jsr		WriteTempString 			; copy out to new string
.01949b	ca		dex				dex 								; do whole string
.01949c	d0 f7		bne $019495			bne 	_CSCSLoop
.01949e					_CSCSExit:
.01949e	7a		ply				ply
.01949f	fa		plx				plx
.0194a0	60		rts				rts
.0194a1					_CSError:
.0194a1	20 79 85	jsr $018579			jsr ERR_Handler
>0194a4	53 74 72 69 6e 67 20 74			.text "String too long",0
>0194ac	6f 6f 20 6c 6f 6e 67 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.0194b4					Unary_Sgn:
.0194b4	20 58 92	jsr $019258			jsr 	EvaluateNumberX 			; get value
.0194b7	20 ab 98	jsr $0198ab			jsr 	CheckNextRParen 			; check right bracket.
.0194ba	20 d8 94	jsr $0194d8			jsr 	GetSignCurrent 				; get sign.
.0194bd	09 00		ora #$00			ora 	#0
.0194bf	10 08		bpl $0194c9			bpl		UnarySetAInteger			; if 0,1 return that.
.0194c1	80 00		bra $0194c3			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.0194c3					UnarySetAMinus1:
.0194c3	a9 ff		lda #$ff			lda 	#$FF 						; put -1 in all four slots.
.0194c5	95 80		sta $80,x			sta 	XS_Mantissa,x
.0194c7	80 04		bra $0194cd			bra 	UnarySetAFill
.0194c9					UnarySetAInteger:
.0194c9	95 80		sta $80,x			sta 	XS_Mantissa,x
.0194cb	a9 00		lda #$00			lda 	#0
.0194cd					UnarySetAFill:
.0194cd	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0194cf	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0194d1	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0194d3	a9 01		lda #$01			lda 	#1 							; set type to integer.
.0194d5	95 85		sta $85,x			sta 	XS_Type,x
.0194d7	60		rts				rts
.0194d8					GetSignCurrent:
.0194d8	b5 85		lda $85,x			lda 	XS_Type,x 					; identify type.
.0194da	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.0194db	90 15		bcc $0194f2			bcc 	_GSCFloat 					; if clear do the float code.
.0194dd	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; if msb of integer set, it's negative
.0194df	30 0e		bmi $0194ef			bmi 	_GSCMinus1
.0194e1	15 80		ora $80,x			ora 	XS_Mantissa+0,x
.0194e3	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.0194e5	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.0194e7	d0 03		bne $0194ec			bne 	_GSCPlus1 					; check if zero by oring all together.
.0194e9					_GSCZero:
.0194e9	a9 00		lda #$00			lda 	#0
.0194eb	60		rts				rts
.0194ec					_GSCPlus1:
.0194ec	a9 01		lda #$01			lda 	#$01
.0194ee	60		rts				rts
.0194ef					_GSCMinus1:
.0194ef	a9 ff		lda #$ff			lda 	#$FF
.0194f1	60		rts				rts
.0194f2					_GSCFloat:
.0194f2	34 85		bit $85,x			bit 	XS_Type,x 					; check bits
.0194f4	70 f3		bvs $0194e9			bvs 	_GSCZero 					; if zero flag set return zero
.0194f6	30 f7		bmi $0194ef			bmi 	_GSCMinus1 					; if sign set return -1
.0194f8	80 f2		bra $0194ec			bra 	_GSCPlus1		 			; else return +1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.0194fa					Unary_Abs:
.0194fa	20 58 92	jsr $019258			jsr 	EvaluateNumberX 			; get value
.0194fd	20 ab 98	jsr $0198ab			jsr 	CheckNextRParen 			; check right bracket.
.019500	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.019502	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.019504	f0 07		beq $01950d			beq 	_UAMinusFloat
.019506	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; check MSB of upper byte to see if negative
.019508	10 09		bpl $019513			bpl 	_UAExit
.01950a	4c 1e 9e	jmp $019e1e			jmp 	IntegerNegateAlways 		; if so negate it.
.01950d					_UAMinusFloat:
.01950d	b5 85		lda $85,x			lda 	XS_Type,x 					; clear the sign bit.
.01950f	29 7f		and #$7f			and		#$7F
.019511	95 85		sta $85,x			sta 	XS_Type,x
.019513					_UAExit:
.019513	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.019514					Unary_Peek:
.019514	a9 01		lda #$01			lda 	#1 							; 1 byte
.019516	80 06		bra $01951e			bra 	UPMain
.019518					Unary_Deek:
.019518	a9 02		lda #$02			lda 	#2 							; 2 bytes
.01951a	80 02		bra $01951e			bra 	UPMain
.01951c					Unary_Leek:
.01951c	a9 04		lda #$04			lda 	#4 							; 4 bytes
.01951e					UPMain:
.01951e	48		pha				pha 								; save bytes to copy.
.01951f	20 66 92	jsr $019266			jsr 	EvaluateIntegerX 			; numeric parameter, the address to xEEK
.019522	20 ab 98	jsr $0198ab			jsr 	CheckNextRParen 			; right bracket.
.019525	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.019527	85 1a		sta $1a				sta 	zLTemp1
.019529	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01952b	85 1b		sta $1b				sta 	zLTemp1+1
.01952d	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01952f	85 1c		sta $1c				sta 	zLTemp1+2
.019531	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019533	85 1d		sta $1d				sta 	zLTemp1+3
.019535	a9 00		lda #$00			lda 	#0 							; clear target area, which might get
.019537	95 80		sta $80,x			sta 	XS_Mantissa+0,x 			; 1,2 or 4 bytes.
.019539	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01953b	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01953d	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01953f	68		pla				pla 								; restore bytes to copy
.019540	da		phx				phx 								; save XY
.019541	5a		phy				phy
.019542	20 2d 98	jsr $01982d			jsr 	MemRead 					; read the bytes in, processor dependent routine.
.019545	7a		ply				ply 								; restore and exit
.019546	fa		plx				plx
.019547	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/pos.asm

.019548					Unary_Pos:
.019548	20 58 92	jsr $019258			jsr 	EvaluateNumberX 			; get value
.01954b	20 ab 98	jsr $0198ab			jsr 	CheckNextRParen 			; check right bracket.
.01954e	20 43 85	jsr $018543			jsr 	VIOCharGetPosition 			; get the position
.019551	4c c9 94	jmp $0194c9			jmp		UnarySetAInteger			; if 0,1 return that.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.019554					Unary_Mod:
.019554	20 7c 95	jsr $01957c			jsr 	_UMParameter 				; first parameter, get |param|
.019557	20 b3 98	jsr $0198b3			jsr 	CheckNextComma
.01955a	da		phx				phx 								; second parameter, get |param|
.01955b	e8		inx				inx
.01955c	e8		inx				inx
.01955d	e8		inx				inx
.01955e	e8		inx				inx
.01955f	e8		inx				inx
.019560	e8		inx				inx
.019561	20 7c 95	jsr $01957c			jsr 	_UMParameter
.019564	fa		plx				plx
.019565	20 ab 98	jsr $0198ab			jsr 	CheckNextRParen
.019568	20 97 9d	jsr $019d97			jsr 	DivInteger32 				; divide, which handily leaves ....
.01956b	a5 1a		lda $1a				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.01956d	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01956f	a5 1b		lda $1b				lda 	zLTemp1+1
.019571	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019573	a5 1c		lda $1c				lda 	zLTemp1+2
.019575	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019577	a5 1d		lda $1d				lda 	zLTemp1+3
.019579	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01957b	60		rts				rts
.01957c					_UMParameter:
.01957c	20 66 92	jsr $019266			jsr 	EvaluateIntegerX 			; get value
.01957f	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; absolute value
.019581	10 03		bpl $019586			bpl 	_UMNotSigned
.019583	20 1e 9e	jsr $019e1e			jsr 	IntegerNegateAlways
.019586					_UMNotSigned:
.019586	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.019587					Unary_Usr:
.019587	20 58 92	jsr $019258			jsr 	EvaluateNumberX 			; numeric parameter
.01958a	20 ab 98	jsr $0198ab			jsr 	CheckNextRParen 			; right bracket.
.01958d	da		phx				phx 								; save XY
.01958e	5a		phy				phy
.01958f	22 0c 03 00	jsl $00030c			jsl 	UserVector 					; with the parameter in the base mantissa
.019593	7a		ply				ply 								; restore YX and exit with whatever the
.019594	fa		plx				plx 								; routine called has chosen to do with it.
.019595	60		rts				rts
.019596					USRDefault:
.019596	20 79 85	jsr $018579			jsr ERR_Handler
>019599	4e 6f 20 55 53 52 20 76			.text "No USR vector.",0
>0195a1	65 63 74 6f 72 2e 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.0195a8					Unary_Val:
.0195a8	20 6f 92	jsr $01926f			jsr 	EvaluateStringX 			; get string
.0195ab	20 ab 98	jsr $0198ab			jsr 	CheckNextRParen 			; check right bracket.
.0195ae	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.0195b0	85 1e		sta $1e				sta 	zGenPtr
.0195b2	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0195b4	85 1f		sta $1f				sta 	zGenPtr+1
.0195b6	5a		phy				phy
.0195b7	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.0195b9	b1 1e		lda ($1e),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.0195bb	f0 54		beq $019611			beq 	_UVBadNumber
.0195bd	48		pha				pha 								; save length.
.0195be	1a		inc a				inc 	a 							; one for the length, one for the terminator
.0195bf	1a		inc a				inc 	a
.0195c0	20 f8 98	jsr $0198f8			jsr 	AllocateTempString
.0195c3	c8		iny				iny 								; move to the next.
.0195c4	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get character
.0195c6	49 2d		eor #$2d			eor 	#"-"						; zero if minus sign
.0195c8	8d a0 03	sta $03a0			sta 	ValSign
.0195cb	d0 04		bne $0195d1			bne 	_UVNotMinus
.0195cd	c8		iny				iny 								; skip over it.
.0195ce	68		pla				pla 								; decrement character count.
.0195cf	3a		dec a				dec 	a
.0195d0	48		pha				pha
.0195d1					_UVNotMinus:
.0195d1	68		pla				pla 								; this is the count.
.0195d2	48		pha		_UVCopy:pha									; copy into new temp string which is ASCIIZ
.0195d3	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.0195d5	c8		iny				iny
.0195d6	20 23 99	jsr $019923			jsr 	WriteTempString
.0195d9	68		pla				pla
.0195da	3a		dec a				dec 	a
.0195db	d0 f5		bne $0195d2			bne 	_UVCopy
.0195dd	20 23 99	jsr $019923			jsr 	WriteTempString 			; make it ASCIIZ
.0195e0	18		clc				clc
.0195e1	a5 20		lda $20				lda 	zTempStr 					; tempstring +1 => genptr
.0195e3	69 01		adc #$01			adc 	#1
.0195e5	85 1e		sta $1e				sta 	zGenPtr
.0195e7	a5 21		lda $21				lda 	zTempStr+1
.0195e9	69 00		adc #$00			adc 	#0
.0195eb	85 1f		sta $1f				sta 	zGenPtr+1
.0195ed	18		clc				clc
.0195ee	20 f0 9e	jsr $019ef0			jsr 	IntFromString 				; first bit.
.0195f1	b0 1e		bcs $019611			bcs 	_UVBadNumber
.0195f3	20 6e a4	jsr $01a46e			jsr 	FPFromString				; try for a float part.
.0195f6	ad a0 03	lda $03a0			lda 	ValSign 					; was it negative
.0195f9	d0 10		bne $01960b			bne 	_UVNotNegative
.0195fb	b5 85		lda $85,x			lda 	XS_Type,x 					; check if integer
.0195fd	4a		lsr a				lsr 	a
.0195fe	b0 08		bcs $019608			bcs 	_UVInteger
.019600	b5 85		lda $85,x			lda 	XS_Type,x 					; set sign bit
.019602	09 80		ora #$80			ora 	#$80
.019604	95 85		sta $85,x			sta 	XS_Type,x
.019606	80 03		bra $01960b			bra 	_UVNotNegative
.019608					_UVInteger:
.019608	20 1e 9e	jsr $019e1e			jsr 	IntegerNegateAlways 		; sign it.
.01960b					_UVNotNegative:
.01960b	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; used everything
.01960d	d0 02		bne $019611			bne 	_UVBadNumber
.01960f	7a		ply				ply
.019610	60		rts				rts
.019611					_UVBadNumber:
.019611	4c 68 85	jmp $018568			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.019614					Unary_Str:
.019614	20 58 92	jsr $019258			jsr 	EvaluateNumberX 			; numeric parameter
.019617	20 ab 98	jsr $0198ab			jsr 	CheckNextRParen 			; right bracket.
.01961a	a9 00		lda #$00			lda 	#0 							; reset buffer index
.01961c	8d 14 03	sta $0314			sta 	NumBufX
.01961f	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.019621	4a		lsr a				lsr 	a
.019622	b0 05		bcs $019629			bcs 	_USInt 						; if msb set do as integer
.019624	20 b3 a3	jsr $01a3b3			jsr 	FPToString 					; call fp to str otherwise
.019627	80 03		bra $01962c			bra 	_USDuplicate
.019629	20 3b 9e	jsr $019e3b	_USInt:	jsr 	IntToString
.01962c					_USDuplicate:
.01962c	ad 14 03	lda $0314			lda 	NumBufX 					; chars in buffer
.01962f	1a		inc a				inc 	a 							; one more for length
.019630	20 f8 98	jsr $0198f8			jsr 	AllocateTempString 			; allocate space for it.
.019633	5a		phy				phy 								; save Y
.019634	a0 00		ldy #$00			ldy 	#0 							; start copying
.019636	b9 15 03	lda $0315,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.019639	20 23 99	jsr $019923			jsr 	WriteTempString
.01963c	c8		iny				iny
.01963d	cc 14 03	cpy $0314			cpy 	NumBufX 					; done the lot
.019640	d0 f4		bne $019636			bne 	_USCopy
.019642	7a		ply				ply 								; restore Y
.019643	4c 20 98	jmp $019820			jmp 	UnaryReturnTempStr 			; return new temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.019646					Unary_Asc:
.019646	20 6f 92	jsr $01926f			jsr 	EvaluateStringX 			; string parameter
.019649	20 ab 98	jsr $0198ab			jsr 	CheckNextRParen 			; right bracket.
.01964c	5a		phy				phy 								; get the string length
.01964d	a0 00		ldy #$00			ldy 	#0
.01964f	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.019651	f0 07		beq $01965a			beq 	_UAIllegal 					; must be at least one character, 0 => error
.019653	c8		iny				iny
.019654	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; read the first character
.019656	7a		ply				ply
.019657	4c c9 94	jmp $0194c9			jmp 	UnarySetAInteger 			; return that as an integer 0-255.
.01965a					_UAIllegal:
.01965a	4c 68 85	jmp $018568			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.01965d					Unary_Len:
.01965d	20 6f 92	jsr $01926f			jsr 	EvaluateStringX 			; string parameter
.019660	20 ab 98	jsr $0198ab			jsr 	CheckNextRParen 			; right bracket.
.019663	5a		phy				phy 								; get the string length
.019664	a0 00		ldy #$00			ldy 	#0
.019666	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.019668	7a		ply				ply
.019669	4c c9 94	jmp $0194c9			jmp 	UnarySetAInteger 			; return as an integer.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.01966c					Unary_Mid:
.01966c	20 6f 92	jsr $01926f			jsr 	EvaluateStringX 				; get string.
.01966f	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.019671	48		pha				pha
.019672	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019674	48		pha				pha
.019675	20 b3 98	jsr $0198b3			jsr 	CheckNextComma 					; skip comma
.019678	20 01 97	jsr $019701			jsr 	SLIByteParameter 				; get a byte parameter (start)
.01967b	48		pha				pha 									; and push it.
.01967c	20 b3 98	jsr $0198b3			jsr 	CheckNextComma 					; skip comma
.01967f	20 01 97	jsr $019701			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.019682	48		pha				pha 									; and push it.
.019683	80 41		bra $0196c6			bra 	SLIProcess
.019685					Unary_Left:
.019685	20 6f 92	jsr $01926f			jsr 	EvaluateStringX 				; get string.
.019688	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.01968a	48		pha				pha
.01968b	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01968d	48		pha				pha
.01968e	a9 01		lda #$01			lda 	#1 								; push start position (1)
.019690	48		pha				pha
.019691	20 b3 98	jsr $0198b3			jsr 	CheckNextComma 					; skip comma
.019694	20 01 97	jsr $019701			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.019697	48		pha				pha 									; and push it.
.019698	80 2c		bra $0196c6			bra 	SLIProcess
.01969a					Unary_Right:
.01969a	20 6f 92	jsr $01926f			jsr 	EvaluateStringX 				; get string.
.01969d	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.01969f	48		pha				pha
.0196a0	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0196a2	48		pha				pha
.0196a3	da		phx				phx 									; get the string length and push on stack.
.0196a4	a2 00		ldx #$00			ldx 	#0
.0196a6	a1 1e		lda ($1e,x)			lda		(zGenPtr,x)
.0196a8	fa		plx				plx
.0196a9	48		pha				pha
.0196aa	20 b3 98	jsr $0198b3			jsr 	CheckNextComma 					; skip comma
.0196ad	20 01 97	jsr $019701			jsr 	SLIByteParameter 				; get a byte parameter.
.0196b0	8d 9e 03	sta $039e			sta 	SignCount 						; save in temporary.
.0196b3	68		pla				pla 									; restore string length.
.0196b4	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.0196b5	38		sec				sec
.0196b6	ed 9e 03	sbc $039e			sbc 	SignCount 						; subtract characters needed, gives start position.
.0196b9	f0 02		beq $0196bd			beq 	_URStart 						; if <= 0 start from 1.
.0196bb	10 02		bpl $0196bf			bpl 	_UROkay
.0196bd					_URStart:
.0196bd	a9 01		lda #$01			lda 	#1
.0196bf					_UROkay:
.0196bf	48		pha				pha 									; push start
.0196c0	ad 9e 03	lda $039e			lda 	SignCount 						; push count of characters
.0196c3	48		pha				pha
.0196c4	80 00		bra $0196c6			bra 	SLIProcess
.0196c6					SLIProcess:
.0196c6	20 ab 98	jsr $0198ab			jsr 	CheckNextRParen 				; closing right bracket.
.0196c9	68		pla				pla
.0196ca	8d a2 03	sta $03a2			sta 	SliceCount 						; count in signcount
.0196cd	1a		inc a				inc 	a 								; allocate +1 for it.
.0196ce	20 f8 98	jsr $0198f8			jsr 	AllocateTempString
.0196d1	68		pla				pla 									; pop start number off stack.
.0196d2	f0 3b		beq $01970f			beq 	SLIError 						; exit if start = 0
.0196d4	8d a1 03	sta $03a1			sta 	SliceStart
.0196d7	68		pla				pla  									; pop string address.
.0196d8	85 1f		sta $1f				sta 	zGenPtr+1
.0196da	68		pla				pla
.0196db	85 1e		sta $1e				sta 	zGenPtr
.0196dd	da		phx				phx
.0196de	5a		phy				phy
.0196df	a2 00		ldx #$00			ldx 	#0 								; point to string length.
.0196e1	ac a1 03	ldy $03a1			ldy 	SliceStart 						; start of the string (+1 for count)
.0196e4					_SLICopy:
.0196e4	ad a2 03	lda $03a2			lda 	SliceCount 						; done count characters
.0196e7	f0 12		beq $0196fb			beq 	_SLIExit
.0196e9	ce a2 03	dec $03a2			dec 	SliceCount
.0196ec	98		tya				tya 									; index of character
.0196ed	c1 1e		cmp ($1e,x)			cmp 	(zGenPtr,x)						; compare against length
.0196ef	f0 02		beq $0196f3			beq 	_SLIOk 							; if equal, okay.
.0196f1	b0 08		bcs $0196fb			bcs 	_SLIExit 						; if past end, then exit.
.0196f3	b1 1e		lda ($1e),y	_SLIOk:	lda 	(zGenPtr),y 					; copy one character
.0196f5	c8		iny				iny
.0196f6	20 23 99	jsr $019923			jsr 	WriteTempString
.0196f9	80 e9		bra $0196e4			bra 	_SLICopy 						; go round till copied characters
.0196fb					_SLIExit:
.0196fb	7a		ply				ply 									; restore YX
.0196fc	fa		plx				plx
.0196fd	4c 20 98	jmp $019820			jmp 	UnaryReturnTempStr 				; return new temporary string.
.019700	ea		nop				nop
.019701					SLIByteParameter:
.019701	20 66 92	jsr $019266			jsr 	EvaluateIntegerX 				; get integer
.019704	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.019706	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019708	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01970a	d0 03		bne $01970f			bne 	SLIError
.01970c	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01970e	60		rts				rts
.01970f					SLIError:
.01970f	4c 68 85	jmp $018568			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.019712					Unary_Hex:
.019712	20 66 92	jsr $019266			jsr 	EvaluateIntegerX 			; numeric parameter
.019715	20 ab 98	jsr $0198ab			jsr 	CheckNextRParen 			; right bracket.
.019718	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.01971a	20 f8 98	jsr $0198f8			jsr 	AllocateTempString			; allocate string space
.01971d	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.01971f	20 43 97	jsr $019743			jsr 	_UHConvert
.019722	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019724	20 43 97	jsr $019743			jsr 	_UHConvert
.019727	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019729	20 43 97	jsr $019743			jsr 	_UHConvert
.01972c	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01972e	20 43 97	jsr $019743			jsr 	_UHConvert
.019731	5a		phy				phy 								; get length of new string
.019732	a0 00		ldy #$00			ldy 	#0
.019734	b1 20		lda ($20),y			lda 	(zTempStr),y
.019736	7a		ply				ply
.019737	c9 00		cmp #$00			cmp 	#0 							; if it was non zero okay
.019739	d0 05		bne $019740			bne 	_UHExit 					; otherwise suppressed all leading zeros !
.01973b	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.01973d	20 23 99	jsr $019923			jsr 	WriteTempString
.019740					_UHExit:
.019740	4c 20 98	jmp $019820			jmp 	UnaryReturnTempStr 			; return new temporary string.
.019743					_UHConvert:
.019743	48		pha				pha
.019744	4a		lsr a				lsr 	a 							; do MSB
.019745	4a		lsr a				lsr 	a
.019746	4a		lsr a				lsr 	a
.019747	4a		lsr a				lsr 	a
.019748	20 4c 97	jsr $01974c			jsr 	_UHNibble
.01974b	68		pla				pla 								; do LSB
.01974c					_UHNibble:
.01974c	29 0f		and #$0f			and 	#15 						; get nibble
.01974e	d0 0c		bne $01975c			bne 	_UHNonZero 					; if not zero, write it out anyway.
.019750	5a		phy				phy									; get the length
.019751	a0 00		ldy #$00			ldy 	#0
.019753	b1 20		lda ($20),y			lda 	(zTempStr),y
.019755	7a		ply				ply
.019756	c9 00		cmp #$00			cmp 	#0 							; length = 0 => suppress leading zeros.
.019758	f0 0d		beq $019767			beq 	_UHExit2
.01975a	a9 00		lda #$00			lda 	#0 							; length > 0, so can't suppress any more.
.01975c					_UHNonZero:
.01975c	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.01975e	90 02		bcc $019762			bcc 	_UHDigit
.019760	69 06		adc #$06			adc 	#7-1
.019762					_UHDigit:
.019762	69 30		adc #$30			adc 	#48
.019764	20 23 99	jsr $019923			jsr 	WriteTempString				; output to temp string.
.019767					_UHExit2:
.019767	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.019768					Unary_Dec:
.019768	20 6f 92	jsr $01926f			jsr 	EvaluateStringX 			; string parameter
.01976b	20 ab 98	jsr $0198ab			jsr 	CheckNextRParen 			; right bracket.
.01976e	5a		phy				phy
.01976f	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.019771	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.019773	f0 43		beq $0197b8			beq 	_UDFail 					; must fail if zero.
.019775	8d 9e 03	sta $039e			sta 	SignCount 					; use SignCount as a counter of chars to process.
.019778	a9 00		lda #$00			lda 	#0 							; set result to zero
.01977a	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01977c	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01977e	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019780	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019782	a9 01		lda #$01			lda 	#1 							; set type to integer.
.019784	95 85		sta $85,x			sta 	XS_Type,x
.019786					_UDConvertLoop:
.019786	5a		phy				phy 								; shift mantissa left 4
.019787	a0 04		ldy #$04			ldy 	#4
.019789					_UDShift:
.019789	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.01978b	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.01978d	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.01978f	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.019791	88		dey				dey
.019792	d0 f5		bne $019789			bne 	_UDShift
.019794	7a		ply				ply
.019795	c8		iny				iny 								; next character
.019796	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; fetch it.
.019798	20 bb 97	jsr $0197bb			jsr 	ConvertUpper 				; convert to U/C
.01979b	c9 30		cmp #$30			cmp 	#"0" 						; range 0-9
.01979d	90 19		bcc $0197b8			bcc 	_UDFail
.01979f	c9 3a		cmp #$3a			cmp 	#"9"+1
.0197a1	90 08		bcc $0197ab			bcc 	_UDOkay
.0197a3	e9 37		sbc #$37			sbc 	#7+"0" 						; A-F fudge
.0197a5	90 11		bcc $0197b8			bcc 	_UDFail 					; fails if between 9 and @
.0197a7	c9 10		cmp #$10			cmp 	#16 						; must be < 16 as hexadecimal.
.0197a9	b0 0d		bcs $0197b8			bcs 	_UDFail
.0197ab					_UDOkay:
.0197ab	29 0f		and #$0f			and 	#15 						; nibble only
.0197ad	15 80		ora $80,x			ora 	XS_Mantissa+0,x 			; OR into the bottom byte.
.0197af	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0197b1	ce 9e 03	dec $039e			dec 	SignCount 					; do it for each character in the string.
.0197b4	d0 d0		bne $019786			bne 	_UDConvertLoop
.0197b6	7a		ply				ply
.0197b7	60		rts				rts
.0197b8					_UDFail:
.0197b8	4c 68 85	jmp $018568			jmp 	BadParamError
.0197bb					ConvertUpper:
.0197bb	c9 61		cmp #$61			cmp 	#"a"
.0197bd	90 07		bcc $0197c6			bcc 	_CUExit
.0197bf	c9 7b		cmp #$7b			cmp 	#"z"+1
.0197c1	b0 03		bcs $0197c6			bcs 	_CUExit
.0197c3	38		sec				sec
.0197c4	e9 20		sbc #$20			sbc 	#32
.0197c6	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.0197c7					Unary_Chr:
.0197c7	20 66 92	jsr $019266			jsr 	EvaluateIntegerX			; numeric parameter which is the character we want
.0197ca	20 ab 98	jsr $0198ab			jsr 	CheckNextRParen 			; right bracket.
.0197cd	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.0197cf	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.0197d1	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.0197d3	d0 0d		bne $0197e2			bne 	_UCChar
.0197d5	a9 02		lda #$02			lda 	#1+1 						; one character string. 2 bytes - size+char
.0197d7	20 f8 98	jsr $0198f8			jsr 	AllocateTempString			; allocate it.
.0197da	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.0197dc	20 23 99	jsr $019923			jsr 	WriteTempString
.0197df	4c 20 98	jmp $019820			jmp 	UnaryReturnTempStr 			; and return that string.
.0197e2					_UCChar:
.0197e2	4c 68 85	jmp $018568			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.0197e5					Unary_Spc:
.0197e5	20 01 97	jsr $019701			jsr 	SLIByteParameter 			; check space.
.0197e8	20 ab 98	jsr $0198ab			jsr 	CheckNextRParen
.0197eb	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0197ed					UnarySpcCreate:
.0197ed	c9 fe		cmp #$fe			cmp 	#maxString+1
.0197ef	b0 14		bcs $019805			bcs 	_USSize
.0197f1	48		pha				pha 								; save length
.0197f2	1a		inc a				inc 	a 							; allocate one more.
.0197f3	20 f8 98	jsr $0198f8			jsr 	AllocateTempString
.0197f6	68		pla				pla 								; get length
.0197f7	f0 27		beq $019820			beq 	UnaryReturnTempStr 			; return the current temp string
.0197f9					_USLoop:
.0197f9	48		pha				pha
.0197fa	a9 20		lda #$20			lda 	#" "
.0197fc	20 23 99	jsr $019923			jsr 	WriteTempString
.0197ff	68		pla				pla
.019800	3a		dec a				dec 	a
.019801	d0 f6		bne $0197f9			bne 	_USLoop
.019803	80 1b		bra $019820			bra 	UnaryReturnTempStr
.019805					_USSize:
.019805	4c 68 85	jmp $018568			jmp 	BadParamError
.019808					Unary_Tab:
.019808	a2 00		ldx #$00			ldx 	#0 							; required TAB position.
.01980a	20 01 97	jsr $019701			jsr 	SLIByteParameter
.01980d	20 ab 98	jsr $0198ab			jsr 	CheckNextRParen
.019810	20 43 85	jsr $018543			jsr 	VIOCharGetPosition 			; were are we ?
.019813	85 10		sta $10				sta 	zTemp1
.019815	38		sec				sec
.019816	a5 80		lda $80				lda 	XS_Mantissa+0 				; return chars required.
.019818	e5 10		sbc $10				sbc 	zTemp1
.01981a	b0 d1		bcs $0197ed			bcs 	UnarySpcCreate
.01981c	a9 00		lda #$00			lda 	#0
.01981e	80 cd		bra $0197ed			bra 	UnarySpcCreate
.019820					UnaryReturnTempStr:
.019820	a5 20		lda $20				lda 	zTempStr 					; copy temp string addr -> mantissa
.019822	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019824	a5 21		lda $21				lda 	zTempStr+1
.019826	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019828	a9 02		lda #$02			lda 	#2 							; set type to string
.01982a	95 85		sta $85,x			sta 	XS_Type,x
.01982c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/65816.asm

.01982d					MemRead:
.01982d	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.019830	a0 00		ldy #$00			ldy 	#0 							; start from here
.019832	b7 1a		lda [$1a],y	_MLoop1:lda 	[zlTemp1],y 				; read the long address
.019834	95 80		sta $80,x			sta 	XS_Mantissa,x 				; copy into mantissa
.019836	c8		iny				iny 								; next to copy
.019837	e8		inx				inx
.019838	cc 9e 03	cpy $039e			cpy 	SignCount 					; do required # of bytes.
.01983b	d0 f5		bne $019832			bne 	_MLoop1
.01983d	60		rts				rts
.01983e					MemWrite:
.01983e	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.019841	a0 00		ldy #$00			ldy 	#0 							; start from here
.019843	b5 80		lda $80,x	_MLoop1:lda 	XS_Mantissa,x 				; read mantisssa
.019845	97 1a		sta [$1a],y			sta 	[zlTemp1],y 				; write it out
.019847	c8		iny				iny 								; next to copy
.019848	e8		inx				inx
.019849	cc 9e 03	cpy $039e			cpy 	SignCount 					; do required # of bytes.
.01984c	d0 f5		bne $019843			bne 	_MLoop1
.01984e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/programend.asm

.01984f					UpdateProgramEnd:
.01984f	a9 00		lda #$00			lda 	#BasicProgram & $FF
.019851	85 16		sta $16				sta 	zCodePtr+0
.019853	a9 10		lda #$10			lda 	#BasicProgram >> 8
.019855	85 17		sta $17				sta 	zCodePtr+1
.019857	a9 00		lda #$00			lda 	#0
.019859	85 18		sta $18				sta 	zCodePtr+2
.01985b	85 19		sta $19				sta 	zCodePtr+3
.01985d	a0 03		ldy #$03			ldy 	#3
.01985f					_UPDLoop:
.01985f	a0 00		ldy #$00			ldy 	#0
.019861	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019863	c9 00		cmp #$00			cmp 	#0 							; end if offset is zero.
.019865	f0 0f		beq $019876			beq 	_UPDFoundEnd
.019867	a0 00		ldy #$00			ldy 	#0 							; point to offset
.019869	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.01986b	18		clc				clc
.01986c	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.01986e	85 16		sta $16				sta 	zCodePtr
.019870	90 02		bcc $019874			bcc 	_SNLNoCarry
.019872	e6 17		inc $17				inc 	zCodePtr+1
.019874					_SNLNoCarry:
.019874	80 e9		bra $01985f			bra 	_UPDLoop
.019876					_UPDFoundEnd:
.019876	18		clc				clc 								; end of program 2 on.
.019877	a5 16		lda $16				lda 	zCodePtr
.019879	69 02		adc #$02			adc 	#2
.01987b	8d 04 03	sta $0304			sta 	endOfProgram
.01987e	a5 17		lda $17				lda 	zCodePtr+1
.019880	69 00		adc #$00			adc 	#0
.019882	8d 05 03	sta $0305			sta 	endOfProgram+1
.019885	a5 18		lda $18				lda 	zCodePtr+2
.019887	69 00		adc #$00			adc		#0
.019889	8d 06 03	sta $0306			sta 	endOfProgram+2
.01988c	a5 19		lda $19				lda 	zCodePtr+3
.01988e	69 00		adc #$00			adc 	#0
.019890	8d 07 03	sta $0307			sta 	endOfProgram+3
.019893	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.019894					CheckNextToken:
.019894	d7 16		cmp [$16],y			cmp 	[zCodePtr],y
.019896	d0 02		bne $01989a			bne 	CTFail 						; no, then fail
.019898	c8		iny				iny
.019899	60		rts				rts
.01989a					CTFail:
.01989a	20 79 85	jsr $018579			jsr ERR_Handler
>01989d	4d 69 73 73 69 6e 67 20			.text "Missing token",0
>0198a5	74 6f 6b 65 6e 00
.0198ab					CheckNextRParen:
.0198ab	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0198ad	c9 be		cmp #$be			cmp 	#token_rparen
.0198af	d0 e9		bne $01989a			bne 	CTFail
.0198b1	c8		iny				iny
.0198b2	60		rts				rts
.0198b3					CheckNextComma:
.0198b3	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0198b5	c9 bf		cmp #$bf			cmp 	#token_comma
.0198b7	d0 e1		bne $01989a			bne 	CTFail
.0198b9	c8		iny				iny
.0198ba	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/concrete.asm

.0198bb					StringConcrete:
.0198bb	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; save source to zTemp1
.0198bd	85 10		sta $10				sta 	zTemp1
.0198bf	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0198c1	85 11		sta $11				sta 	zTemp1+1
.0198c3	a0 00		ldy #$00			ldy 	#0 							; empty string, return default empty
.0198c5	b1 10		lda ($10),y			lda 	(zTemp1),y
.0198c7	f0 26		beq $0198ef			beq		_SCEmpty
.0198c9	18		clc				clc 								; from the string pointer
.0198ca	ad 00 03	lda $0300			lda 	StringPtr 					; and put in zTemp2 as well
.0198cd	f1 10		sbc ($10),y			sbc 	(zTemp1),y
.0198cf	8d 00 03	sta $0300			sta 	StringPtr
.0198d2	85 12		sta $12				sta 	zTemp2
.0198d4	ad 01 03	lda $0301			lda 	StringPtr+1
.0198d7	e9 00		sbc #$00			sbc 	#0
.0198d9	8d 01 03	sta $0301			sta 	StringPtr+1
.0198dc	85 13		sta $13				sta 	zTemp2+1
.0198de	b1 10		lda ($10),y			lda 	(zTemp1),y 					; length add one for count
.0198e0	1a		inc a				inc 	a
.0198e1	aa		tax				tax
.0198e2	b1 10		lda ($10),y	_SCCopy:lda 	(zTemp1),y 					; copy whole thing including length
.0198e4	91 12		sta ($12),y			sta 	(zTemp2),y
.0198e6	c8		iny				iny
.0198e7	ca		dex				dex
.0198e8	d0 f8		bne $0198e2			bne 	_SCCopy
.0198ea	a5 13		lda $13				lda 	zTemp2+1 					; return concrete string in AX
.0198ec	a6 12		ldx $12				ldx 	zTemp2
.0198ee	60		rts				rts
.0198ef					_SCEmpty:
.0198ef	a9 00		lda #$00			lda 	#0
.0198f1	85 25		sta $25				sta 	zNullString
.0198f3	a9 00		lda #$00			lda 	#zNullString >> 8
.0198f5	a2 25		ldx #$25			ldx 	#zNulLString & $FF
.0198f7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.0198f8					AllocateTempString:
.0198f8	48		pha				pha 								; save required count.
.0198f9	a5 21		lda $21				lda 	zTempStr+1 					; check if initialised yet ?
.0198fb	d0 0b		bne $019908			bne 	_ATSInitialised
.0198fd	ad 00 03	lda $0300			lda 	StringPtr 					; set temporary string ptr 1 page below available
.019900	85 20		sta $20				sta 	zTempStr					; space, this is for strings to be concreted.
.019902	ad 01 03	lda $0301			lda 	StringPtr+1
.019905	3a		dec a				dec 	a
.019906	85 21		sta $21				sta 	zTempStr+1
.019908					_ATSInitialised:
.019908	68		pla				pla 								; get required count back.
.019909	49 ff		eor #$ff			eor 	#$FF 						; negate 2's complement.
.01990b	1a		inc a				inc 	a
.01990c	18		clc				clc
.01990d	65 20		adc $20				adc 	zTempStr 					; "add" to the temp string pointer
.01990f	85 20		sta $20				sta 	zTempStr
.019911	a9 ff		lda #$ff			lda 	#$FF
.019913	65 21		adc $21				adc 	zTempStr+1
.019915	85 21		sta $21				sta 	zTempStr+1
.019917	a9 00		lda #$00			lda 	#0 							; clear temp string.
.019919	5a		phy				phy
.01991a	a8		tay				tay
.01991b	91 20		sta ($20),y			sta 	(zTempStr),y
.01991d	7a		ply				ply
.01991e	1a		inc a				inc 	a 							; reset the write index.
.01991f	8d 9f 03	sta $039f			sta 	TempStringWriteIndex
.019922	60		rts				rts
.019923					WriteTempString:
.019923	5a		phy				phy 								; save Y
.019924	ac 9f 03	ldy $039f			ldy 	TempStringWriteIndex	 	; write position.
.019927	91 20		sta ($20),y			sta 	(zTempStr),y 				; write character out.
.019929	ee 9f 03	inc $039f			inc 	TempStringWriteIndex 		; increment the write position.
.01992c	98		tya				tya 								; unchanged Y is now length
.01992d	a0 00		ldy #$00			ldy 	#0
.01992f	91 20		sta ($20),y			sta 	(zTempStr),y
.019931	7a		ply				ply 								; restore Y and exit
.019932	60		rts				rts
.019933					CreateTempStringCopy:
.019933	da		phx				phx 								; save X
.019934	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019936	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.019937	20 f8 98	jsr $0198f8			jsr 	AllocateTempString 			; allocate memory for temporary string.
.01993a	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01993c	c8		iny				iny
.01993d	3a		dec a				dec 	a 							; make the actual length in charactes
.01993e	3a		dec a				dec 	a
.01993f	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.019941	81 20		sta ($20,x)			sta 	(zTempStr,x)
.019943	85 1a		sta $1a				sta 	zLTemp1 					; that's used as a count.
.019945	09 00		ora #$00			ora 	#0 							; if zero already, exit
.019947	f0 0e		beq $019957			beq 	_CTSCExit
.019949					_CTSCLoop:
.019949	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01994b	c8		iny				iny
.01994c	5a		phy				phy 								; save in Y
.01994d	e8		inx				inx 								; bump index
.01994e	da		phx				phx 								; index into Y
.01994f	7a		ply				ply
.019950	91 20		sta ($20),y			sta 	(zTempStr),y 				; save at index
.019952	7a		ply				ply 								; restore Y
.019953	c6 1a		dec $1a				dec 	zLTemp1 					; do for each character
.019955	d0 f2		bne $019949			bne 	_CTSCLoop
.019957					_CTSCExit:
.019957	fa		plx				plx 								; restore X
.019958	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/variables.asm

.019959					VariableFind:
.019959	20 c4 99	jsr $0199c4			jsr 	VariableExtract 		; find out all about it ....
.01995c	20 5d 9c	jsr $019c5d			jsr 	VariableLocate 			; does it already exist ?
.01995f	b0 03		bcs $019964			bcs 	_VFExists 				; if so, use that.
.019961	20 50 9a	jsr $019a50			jsr 	VariableCreate 			; otherwise create it.
.019964					_VFExists:
.019964	a5 24		lda $24				lda 	zVarType 				; is it still an array ?
.019966	29 01		and #$01			and 	#1
.019968	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.01996a	d0 28		bne $019994			bne 	_VFSingleElement
.01996c					_VFNextIndex:
.01996c	a5 22		lda $22				lda 	zVarDataPtr 			; push the data ptr and type on the stack.
.01996e	48		pha				pha
.01996f	a5 23		lda $23				lda 	zVarDataPtr+1
.019971	48		pha				pha
.019972	a5 24		lda $24				lda 	zVarType
.019974	48		pha				pha
.019975	20 66 92	jsr $019266			jsr 	EvaluateIntegerX 		; calculate the index.
.019978	68		pla				pla 							; restore and index.
.019979	85 24		sta $24				sta 	zVarType
.01997b	68		pla				pla
.01997c	85 23		sta $23				sta 	zVarDataPtr+1
.01997e	68		pla				pla
.01997f	85 22		sta $22				sta 	zVarDataPtr
.019981	20 db 9a	jsr $019adb			jsr 	ArrayIndexFollow 		; do the index.
.019984	a5 24		lda $24				lda 	zVarType 				; is it still an array ??
.019986	29 01		and #$01			and 	#1
.019988	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.01998a	d0 05		bne $019991			bne 	_VFArrayDone 			; if so then exit.
.01998c	20 b3 98	jsr $0198b3			jsr 	CheckNextComma 			; comma should follow
.01998f	80 db		bra $01996c			bra 	_VFNextIndex
.019991					_VFArrayDone:
.019991	20 ab 98	jsr $0198ab			jsr 	CheckNextRParen 		; check closing right bracket.
.019994					_VFSingleElement:
.019994	60		rts				rts
.019995					VariableClear:
.019995	48		pha				pha 							; save registers
.019996	da		phx				phx
.019997	a2 00		ldx #$00			ldx 	#0 						; clear out the hash table.
.019999	8a		txa				txa
.01999a	9d 35 03	sta $0335,x	_VCLoop:sta 	HashTableBase,x
.01999d	e8		inx				inx
.01999e	e0 60		cpx #$60			cpx 	#HashTableEnd-HashTableBase
.0199a0	d0 f8		bne $01999a			bne 	_VCLoop
.0199a2	a9 00		lda #$00			lda 	#VariableMemory & $FF
.0199a4	8d 02 03	sta $0302			sta 	VarMemPtr
.0199a7	a9 30		lda #$30			lda 	#VariableMemory >> 8
.0199a9	8d 03 03	sta $0303			sta 	VarMemPtr+1
.0199ac	fa		plx				plx 							; restore registers
.0199ad	68		pla				pla
.0199ae	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/extract.asm

.0199af					VariableNameError:
.0199af	20 79 85	jsr $018579			jsr ERR_Handler
>0199b2	42 61 64 20 56 61 72 69			.text "Bad Variable Name",0
>0199ba	61 62 6c 65 20 4e 61 6d 65 00
.0199c4					VariableExtract:
.0199c4	da		phx				phx 							; save X.
.0199c5	a9 ba		lda #$ba			lda 	#token_hashlParen  		; set the type to #( e.g. real array.
.0199c7	8d 95 03	sta $0395			sta 	Var_Type
.0199ca	8d 96 03	sta $0396			sta 	Var_Hash 				; we initialise the hash with this. It doesn't matter
.0199cd	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0199cf	c9 00		cmp #$00			cmp 	#0 						; first one must be A-Z
.0199d1	f0 dc		beq $0199af			beq 	VariableNameError
.0199d3	c9 1b		cmp #$1b			cmp 	#26+1
.0199d5	b0 d8		bcs $0199af			bcs 	VariableNameError
.0199d7	a2 ff		ldx #$ff			ldx 	#255 					; now copy it into the variable buffer.
.0199d9					_VECopyBuffer:
.0199d9	e8		inx				inx
.0199da	e0 1f		cpx #$1f			cpx 	#31 					; too long
.0199dc	f0 d1		beq $0199af			beq 	VariableNameError
.0199de	9d 15 03	sta $0315,x			sta 	Var_Buffer,x 			; save character
.0199e1	18		clc				clc  							; update the hash value for it.
.0199e2	6d 96 03	adc $0396			adc 	Var_Hash
.0199e5	8d 96 03	sta $0396			sta 	Var_Hash
.0199e8	c8		iny				iny
.0199e9	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0199eb	c9 00		cmp #$00			cmp 	#0 						; zero or token, end of variable
.0199ed	f0 0e		beq $0199fd			beq 	_VECopyEnd
.0199ef	30 0c		bmi $0199fd			bmi 	_VECopyEnd
.0199f1	c9 1b		cmp #$1b			cmp 	#26+1 					; A-Z continue copying
.0199f3	90 e4		bcc $0199d9			bcc 	_VECopyBuffer
.0199f5	c9 30		cmp #$30			cmp 	#"0" 					; 0-9 copy as well.
.0199f7	90 04		bcc $0199fd			bcc 	_VECopyEnd
.0199f9	c9 3a		cmp #$3a			cmp 	#"9"+1
.0199fb	90 dc		bcc $0199d9			bcc 	_VECopyBuffer
.0199fd					_VECopyEnd:
.0199fd	c8		iny				iny
.0199fe	c9 b7		cmp #$b7			cmp 	#token_Dollar 			; first type token.
.019a00	90 04		bcc $019a06			bcc 	_VEDefaultRequired
.019a02	c9 bd		cmp #$bd			cmp 	#token_PercentLParen+1	; last type token.
.019a04	90 0b		bcc $019a11			bcc 	_VEHaveType
.019a06					_VEDefaultRequired:
.019a06	c9 bd		cmp #$bd			cmp 	#token_LParen 			; if it ends in ( then use the real array
.019a08	f0 04		beq $019a0e			beq 	_VESetType 				; default set above.
.019a0a	ce 95 03	dec $0395			dec 	Var_Type 				; this changes that default to the variable default
.019a0d	88		dey				dey
.019a0e					_VESetType:
.019a0e	ad 95 03	lda $0395			lda 	Var_Type 				; get type ....
.019a11					_VEHaveType:
.019a11	8d 95 03	sta $0395			sta 	Var_Type 				; save as type.
.019a14	bd 15 03	lda $0315,x			lda 	Var_Buffer,x 			; set bit 7 of name, marks the end.
.019a17	09 80		ora #$80			ora 	#$80
.019a19	9d 15 03	sta $0315,x			sta 	Var_Buffer,x
.019a1c	e8		inx				inx 							; offset 3 => length 4.
.019a1d	8e 97 03	stx $0397			stx 	Var_Length 				; save length of variable name.
.019a20	ad 95 03	lda $0395			lda 	Var_Type 				; get offset of var type from first type token
.019a23	38		sec				sec
.019a24	e9 b7		sbc #$b7			sbc 	#token_Dollar
.019a26	0a		asl a				asl 	a 						; multiply by 16. This requires HashTableSize
.019a27	0a		asl a				asl 	a 						; in data.asm to be 8 (8 sets of links,2 bytes each)
.019a28	0a		asl a				asl 	a
.019a29	0a		asl a				asl 	a
.019a2a	8d 98 03	sta $0398			sta 	Var_HashAddress
.019a2d	ad 96 03	lda $0396			lda 	Var_Hash 				; get the hash
.019a30	29 07		and #$07			and 	#(HashTableSize-1) 		; force into range 0-tableSize-1
.019a32	0a		asl a				asl 	a 						; double it (2 bytes per entry) & clears carry
.019a33	6d 98 03	adc $0398			adc 	Var_HashAddress 		; add table offset.
.019a36	69 35		adc #$35			adc 	#HashTableBase & $FF 	; now the low byte of the actual table address
.019a38	8d 98 03	sta $0398			sta 	Var_HashAddress
.019a3b	a2 05		ldx #$05			ldx 	#5 						; hash is 5 bytes (real)
.019a3d	ad 95 03	lda $0395			lda 	Var_Type
.019a40	c9 b9		cmp #$b9			cmp 	#token_Hash
.019a42	f0 07		beq $019a4b			beq 	_VEHaveSize
.019a44	ca		dex				dex
.019a45	c9 bb		cmp #$bb			cmp 	#token_Percent 			; percent is 4 bytes (integer)
.019a47	f0 02		beq $019a4b			beq 	_VEHaveSize
.019a49	a2 02		ldx #$02			ldx 	#2 						; everything else is two.
.019a4b					_VEHaveSize:
.019a4b	8e 99 03	stx $0399			stx 	Var_DataSize
.019a4e	fa		plx				plx
.019a4f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varcreate.asm

.019a50					VariableCreate:
.019a50	da		phx				phx
.019a51	5a		phy				phy
.019a52	ad 02 03	lda $0302			lda 	VarMemPtr 					; get address of next free into zTemp1
.019a55	85 10		sta $10				sta 	zTemp1
.019a57	ad 03 03	lda $0303			lda 	VarMemPtr+1
.019a5a	85 11		sta $11				sta 	zTemp1+1
.019a5c	ad 99 03	lda $0399			lda 	Var_DataSize 				; bytes for the data bit
.019a5f	18		clc				clc
.019a60	6d 97 03	adc $0397			adc 	Var_Length 					; add the length of the name
.019a63	69 03		adc #$03			adc 	#3 							; 3 for the link and the hash.
.019a65	6d 02 03	adc $0302			adc 	VarMemPtr 					; add to variable memory pointer
.019a68	8d 02 03	sta $0302			sta 	VarMemPtr
.019a6b	90 03		bcc $019a70			bcc 	_VCNoCarry
.019a6d	ee 03 03	inc $0303			inc 	VarMemPtr+1
.019a70					_VCNoCarry:
.019a70	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.019a73	85 12		sta $12				sta 	zTemp2
.019a75	a9 03		lda #$03			lda 	#HashTableBase >> 8
.019a77	85 13		sta $13				sta 	zTemp2+1
.019a79	a0 00		ldy #$00			ldy 	#0 							; put current hash link in position.
.019a7b	b1 12		lda ($12),y			lda 	(zTemp2),y
.019a7d	91 10		sta ($10),y			sta 	(zTemp1),y
.019a7f	c8		iny				iny
.019a80	b1 12		lda ($12),y			lda 	(zTemp2),y
.019a82	91 10		sta ($10),y			sta 	(zTemp1),y
.019a84	c8		iny				iny
.019a85	ad 96 03	lda $0396			lda 	Var_Hash 					; write the hash out.
.019a88	91 10		sta ($10),y			sta 	(zTemp1),y
.019a8a	c8		iny				iny
.019a8b	a2 00		ldx #$00			ldx 	#0 							; copy the name out.
.019a8d					_VCCopyName:
.019a8d	bd 15 03	lda $0315,x			lda 	Var_Buffer,x
.019a90	91 10		sta ($10),y			sta 	(zTemp1),y
.019a92	e8		inx				inx
.019a93	c8		iny				iny
.019a94	ec 97 03	cpx $0397			cpx 	Var_Length
.019a97	d0 f4		bne $019a8d			bne 	_VCCopyName
.019a99	5a		phy				phy 								; save the data offset.
.019a9a	ae 99 03	ldx $0399			ldx 	Var_DataSize 				; and write the data out.
.019a9d	a9 00		lda #$00			lda 	#0 							; which is all zeroes.
.019a9f					_VCClearData:
.019a9f	91 10		sta ($10),y			sta 	(zTemp1),y
.019aa1	c8		iny				iny
.019aa2	ca		dex				dex
.019aa3	d0 fa		bne $019a9f			bne 	_VCClearData
.019aa5	68		pla				pla 								; offset to the data
.019aa6	18		clc				clc
.019aa7	65 10		adc $10				adc 	zTemp1 						; add to start and save as data pointer.
.019aa9	85 22		sta $22				sta 	zVarDataPtr
.019aab	a5 11		lda $11				lda 	zTemp1+1
.019aad	69 00		adc #$00			adc 	#0
.019aaf	85 23		sta $23				sta 	zVarDataPtr+1
.019ab1	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.019ab4	85 24		sta $24				sta 	zVarType
.019ab6	a5 10		lda $10				lda 	zTemp1 						; fix hash link to point to new record
.019ab8	a0 00		ldy #$00			ldy 	#0
.019aba	91 12		sta ($12),y			sta 	(zTemp2),y
.019abc	c8		iny				iny
.019abd	a5 11		lda $11				lda 	zTemp1+1
.019abf	91 12		sta ($12),y			sta 	(zTemp2),y
.019ac1	ad 95 03	lda $0395			lda 	Var_Type 					; array ? if so create the empty one.
.019ac4	29 01		and #$01			and 	#1
.019ac6	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.019ac8	d0 0e		bne $019ad8			bne 	_VCNotArray
.019aca	a2 00		ldx #$00			ldx 	#0 							; call recursive array creator
.019acc	20 72 9b	jsr $019b72			jsr 	ArrayCreate
.019acf	5a		phy				phy 								; save YA at zVarDataPtr
.019ad0	a0 00		ldy #$00			ldy 	#0
.019ad2	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019ad4	c8		iny				iny
.019ad5	68		pla				pla
.019ad6	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019ad8					_VCNotArray:
.019ad8	7a		ply				ply
.019ad9	fa		plx				plx
.019ada	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arrayidx.asm

.019adb					ArrayIndexFollow:
.019adb	5a		phy				phy
.019adc	a0 00		ldy #$00			ldy 	#0 							; make zVarDataPtr point to the array.
.019ade	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; e.g. it points to itself.
.019ae0	48		pha				pha
.019ae1	c8		iny				iny
.019ae2	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019ae4	85 23		sta $23				sta 	zVarDataPtr+1
.019ae6	68		pla				pla
.019ae7	85 22		sta $22				sta 	zVarDataPtr
.019ae9	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; MSB of 16 bit integer and bytes 2&3
.019aeb	29 80		and #$80			and 	#$80 						; must be zero.
.019aed	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019aef	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019af1	d0 59		bne $019b4c			bne 	_AIFError
.019af3	a0 00		ldy #$00			ldy 	#0 							; calculate size - current - 1
.019af5	18		clc				clc
.019af6	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019af8	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.019afa	c8		iny				iny
.019afb	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019afd	08		php				php 								; clear bit 7 retaining borrow.
.019afe	29 7f		and #$7f			and 	#$7F
.019b00	28		plp				plp
.019b01	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.019b03	90 47		bcc $019b4c			bcc 	_AIFError 					; eror if size-current < 0
.019b05	b5 80		lda $80,x			lda  	XS_Mantissa+0,x 			; copy and double the index
.019b07	0a		asl a				asl 	a 							; (e.g. index * 2)
.019b08	85 10		sta $10				sta 	zTemp1
.019b0a	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019b0c	2a		rol a				rol 	a
.019b0d	85 11		sta $11				sta 	zTemp1+1
.019b0f	a0 01		ldy #$01			ldy 	#1 							; is this a data entry.
.019b11	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; if so, then type is unchanged, offset set
.019b13	30 1d		bmi $019b32			bmi 	_AIFCalculate
.019b15	c6 24		dec $24				dec 	zVarType 					; converts from an array to a type.
.019b17	a5 24		lda $24				lda 	zVarType 					; check that type
.019b19	c9 b7		cmp #$b7			cmp 	#token_Dollar 				; if string, use x 2
.019b1b	f0 15		beq $019b32			beq 	_AIFCalculate
.019b1d	06 10		asl $10				asl 	zTemp1			 			; double the index
.019b1f	26 11		rol $11				rol 	zTemp1+1					; (e.g. index * 4)
.019b21	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if integer, use x 4
.019b23	f0 0d		beq $019b32			beq 	_AIFCalculate
.019b25	18		clc				clc 								; add the original mantissa in again
.019b26	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; which makes it x5, for float.
.019b28	65 10		adc $10				adc 	zTemp1
.019b2a	85 10		sta $10				sta 	zTemp1
.019b2c	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019b2e	65 11		adc $11				adc 	zTemp1+1
.019b30	85 11		sta $11				sta 	zTemp1+1
.019b32					_AIFCalculate:
.019b32	18		clc				clc 								; add index x 2,4 or 5 to base
.019b33	a5 22		lda $22				lda 	zVarDataPtr
.019b35	65 10		adc $10				adc 	zTemp1
.019b37	85 22		sta $22				sta 	zVarDataPtr
.019b39	a5 23		lda $23				lda 	zVarDataPtr+1
.019b3b	65 11		adc $11				adc 	zTemp1+1
.019b3d	85 23		sta $23				sta 	zVarDataPtr+1
.019b3f	18		clc				clc 								; add 2 more for the length prefix.
.019b40	a5 22		lda $22				lda 	zVarDataPtr
.019b42	69 02		adc #$02			adc 	#2
.019b44	85 22		sta $22				sta 	zVarDataPtr
.019b46	90 02		bcc $019b4a			bcc 	_AIFNoBump
.019b48	e6 23		inc $23				inc 	zVarDataPtr+1
.019b4a					_AIFNoBump:
.019b4a	7a		ply				ply
.019b4b	60		rts				rts
.019b4c					_AIFError:
.019b4c	20 79 85	jsr $018579			jsr ERR_Handler
>019b4f	42 61 64 20 61 72 72 61			.text "Bad array index",0
>019b57	79 20 69 6e 64 65 78 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arraydef.asm

.019b5f					ArrayResetDefault:
.019b5f	a9 0b		lda #$0b			lda 	#11 						; 0..10 one array
.019b61	8d a9 03	sta $03a9			sta 	ArrayDef+0
.019b64	a9 00		lda #$00			lda 	#0
.019b66	8d aa 03	sta $03aa			sta 	ArrayDef+1
.019b69	a9 ff		lda #$ff			lda 	#$FF
.019b6b	8d ab 03	sta $03ab			sta 	ArrayDef+2 					; $FFFF implies no second element.
.019b6e	8d ac 03	sta $03ac			sta 	ArrayDef+3					; (test bit 7 of 2nd byte)
.019b71	60		rts				rts
.019b72					ArrayCreate:
.019b72	bd a9 03	lda $03a9,x			lda 	ArrayDef+0,x 				; put size x 2 in zTemp1
.019b75	0a		asl a				asl 	a
.019b76	85 10		sta $10				sta 	zTemp1
.019b78	bd aa 03	lda $03aa,x			lda 	ArrayDef+1,x
.019b7b	2a		rol a				rol 	a
.019b7c	85 11		sta $11				sta 	zTemp1+1
.019b7e	bd ac 03	lda $03ac,x			lda 	ArrayDef+3,x 				; if this is the last element it's array of ptrs.
.019b81	10 22		bpl $019ba5			bpl 	_ACSized 					; if not multiply size x 2 (str) 4 (int) 5 (real)
.019b83	ad 95 03	lda $0395			lda 	Var_Type 					; check the type
.019b86	c9 b8		cmp #$b8			cmp 	#token_DollarLParen 		; also if it is an array of strings $(
.019b88	f0 1b		beq $019ba5			beq 	_ACSized
.019b8a	06 10		asl $10				asl 	zTemp1 						; double again
.019b8c	26 11		rol $11				rol 	zTemp1+1
.019b8e	b0 6f		bcs $019bff			bcs 	ArrayIndexError 			; too large.
.019b90	c9 bc		cmp #$bc			cmp 	#token_PercentLParen 		; if %( four bytes/entry is enough.
.019b92	f0 11		beq $019ba5			beq 	_ACSized
.019b94	18		clc				clc 								; add original value x 5 for reals.
.019b95	a5 10		lda $10				lda 	zTemp1
.019b97	7d a9 03	adc $03a9,x			adc 	ArrayDef+0,x
.019b9a	85 10		sta $10				sta 	zTemp1
.019b9c	a5 11		lda $11				lda 	zTemp1+1
.019b9e	7d aa 03	adc $03aa,x			adc 	ArrayDef+1,x
.019ba1	85 11		sta $11				sta 	zTemp1+1
.019ba3	b0 5a		bcs $019bff			bcs 	ArrayIndexError
.019ba5					_ACSized:
.019ba5	18		clc				clc
.019ba6	a5 10		lda $10				lda 	zTemp1
.019ba8	69 02		adc #$02			adc 	#2
.019baa	85 10		sta $10				sta 	zTemp1
.019bac	90 04		bcc $019bb2			bcc 	_ACNoBump
.019bae	e6 10		inc $10				inc 	zTemp1
.019bb0	f0 4d		beq $019bff			beq 	ArrayIndexError
.019bb2					_ACNoBump:
.019bb2	18		clc				clc
.019bb3	ad 02 03	lda $0302			lda 	VarMemPtr 					; add this allocated count to VarMemPtr
.019bb6	85 12		sta $12				sta 	zTemp2						; save start in zTemp2/zTemp3
.019bb8	85 14		sta $14				sta 	zTemp3
.019bba	65 10		adc $10				adc 	zTemp1
.019bbc	8d 02 03	sta $0302			sta 	VarMemPtr
.019bbf	ad 03 03	lda $0303			lda 	VarMemPtr+1
.019bc2	85 13		sta $13				sta 	zTemp2+1
.019bc4	85 15		sta $15				sta 	zTemp3+1
.019bc6	65 11		adc $11				adc 	zTemp1+1
.019bc8	8d 03 03	sta $0303			sta 	VarMemPtr+1
.019bcb	85 11		sta $11				sta 	zTemp1+1
.019bcd	b0 30		bcs $019bff			bcs 	ArrayIndexError
.019bcf	a0 00		ldy #$00			ldy 	#0							; write $00 out.
.019bd1					_ACClear:
.019bd1	98		tya				tya
.019bd2	91 12		sta ($12),y			sta 	(zTemp2),y
.019bd4	e6 12		inc $12				inc 	zTemp2
.019bd6	d0 02		bne $019bda			bne 	_ACCBump
.019bd8	e6 13		inc $13				inc 	zTemp2+1
.019bda					_ACCBump:
.019bda	a5 12		lda $12				lda 	zTemp2
.019bdc	cd 02 03	cmp $0302			cmp 	VarMemPtr
.019bdf	d0 f0		bne $019bd1			bne 	_ACClear
.019be1	a5 13		lda $13				lda 	zTemp2+1
.019be3	cd 03 03	cmp $0303			cmp 	VarMemPtr+1
.019be6	d0 e9		bne $019bd1			bne 	_ACClear
.019be8	a0 00		ldy #$00			ldy 	#0
.019bea	bd a9 03	lda $03a9,x			lda 	ArrayDef+0,x 				; copy the size into the start
.019bed	91 14		sta ($14),y			sta 	(zTemp3),y
.019bef	c8		iny				iny
.019bf0	bd aa 03	lda $03aa,x			lda 	ArrayDef+1,x
.019bf3	91 14		sta ($14),y			sta 	(zTemp3),y
.019bf5	bd ac 03	lda $03ac,x			lda 	ArrayDef+3,x 				; have we reached the end
.019bf8	10 18		bpl $019c12			bpl 	ACCFillRecursive
.019bfa	a4 15		ldy $15				ldy 	zTemp3+1 					; return address
.019bfc	a5 14		lda $14				lda 	zTemp3
.019bfe	60		rts				rts
.019bff					ArrayIndexError:
.019bff	20 79 85	jsr $018579			jsr ERR_Handler
>019c02	42 61 64 20 61 72 72 61			.text "Bad array index",0
>019c0a	79 20 69 6e 64 65 78 00
.019c12					ACCFillRecursive:
.019c12	a9 ff		lda #$ff			lda 	#$FF 						; we mark the end, this is free space.
.019c14	a0 00		ldy #$00			ldy 	#0 							; this is overwritten by size of next allocated
.019c16	91 12		sta ($12),y			sta 	(zTemp2),y 					; array, but we might change that.
.019c18	c8		iny				iny
.019c19	b1 14		lda ($14),y			lda 	(zTemp3),y 					; set bit 15 of the max index indicating
.019c1b	09 80		ora #$80			ora 	#$80 						; an array of pointers
.019c1d	91 14		sta ($14),y			sta 	(zTemp3),y
.019c1f	a5 14		lda $14				lda 	zTemp3 						; push the start on the stack
.019c21	48		pha				pha
.019c22	a5 15		lda $15				lda 	zTemp3+1
.019c24	48		pha				pha
.019c25					_ACCFillLoop:
.019c25	18		clc				clc
.019c26	a5 14		lda $14				lda 	zTemp3 						; and work forwards.
.019c28	69 02		adc #$02			adc 	#2
.019c2a	85 14		sta $14				sta 	zTemp3
.019c2c	90 02		bcc $019c30			bcc 	_ACCSkip2
.019c2e	e6 15		inc $15				inc 	zTemp3+1
.019c30					_ACCSkip2:
.019c30	a0 00		ldy #$00			ldy 	#0 							; reached the end ?
.019c32	b1 14		lda ($14),y			lda 	(zTemp3),y					; (looking for FF marker, everything else 00)
.019c34	c8		iny				iny
.019c35	11 14		ora ($14),y			ora 	(zTemp3),y
.019c37	d0 21		bne $019c5a			bne 	_ACCExit
.019c39	a5 14		lda $14				lda 	zTemp3 						; push zTemp3
.019c3b	48		pha				pha
.019c3c	a5 15		lda $15				lda 	zTemp3+1
.019c3e	48		pha				pha
.019c3f	e8		inx				inx
.019c40	e8		inx				inx
.019c41	20 72 9b	jsr $019b72			jsr 	ArrayCreate 				; create array recursively.
.019c44	ca		dex				dex
.019c45	ca		dex				dex
.019c46	85 12		sta $12				sta 	zTemp2 						; save A
.019c48	68		pla				pla
.019c49	85 15		sta $15				sta 	zTemp3+1 					; restore zTemp3
.019c4b	68		pla				pla
.019c4c	85 14		sta $14				sta 	zTemp3
.019c4e	98		tya				tya 								; write high bye from Y
.019c4f	a0 01		ldy #$01			ldy 	#1
.019c51	91 14		sta ($14),y			sta 	(zTemp3),y
.019c53	88		dey				dey 								; write low byte out.
.019c54	a5 12		lda $12				lda 	zTemp2
.019c56	91 14		sta ($14),y			sta 	(zTemp3),y
.019c58	80 cb		bra $019c25			bra 	_ACCFillLoop 				; and try again.
.019c5a					_ACCExit:
.019c5a	7a		ply				ply 								; restore the original address
.019c5b	68		pla				pla
.019c5c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varfind.asm

.019c5d					VariableLocate:
.019c5d	da		phx				phx
.019c5e	5a		phy				phy
.019c5f	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.019c62	85 12		sta $12				sta 	zTemp2 						; points to first address.
.019c64	a9 03		lda #$03			lda 	#HashTableBase >> 8
.019c66	85 13		sta $13				sta 	zTemp2+1
.019c68	a0 00		ldy #$00	_VLNext:ldy 	#0 							; get next link into AX
.019c6a	b1 12		lda ($12),y			lda 	(zTemp2),y
.019c6c	aa		tax				tax
.019c6d	c8		iny				iny
.019c6e	b1 12		lda ($12),y			lda 	(zTemp2),y
.019c70	85 13		sta $13				sta 	zTemp2+1 					; save in zTemp
.019c72	86 12		stx $12				stx 	zTemp2
.019c74	05 12		ora $12				ora 	zTemp2 						; got zero
.019c76	18		clc				clc
.019c77	f0 25		beq $019c9e			beq 	_VLExit 					; if so, then fail as end of chain.
.019c79	c8		iny				iny 								; point to hash (offset + 2)
.019c7a	b1 12		lda ($12),y			lda 	(zTemp2),y
.019c7c	cd 96 03	cmp $0396			cmp 	Var_Hash
.019c7f	d0 e7		bne $019c68			bne 	_VLNext 					; try next if different.
.019c81					_VLCompare:
.019c81	c8		iny				iny 								; next character
.019c82	b1 12		lda ($12),y			lda 	(zTemp2),y 					; compare variable field against buffer.
.019c84	d9 12 03	cmp $0312,y			cmp 	Var_Buffer-3,y 				; the -3 is because name starts at 3.
.019c87	d0 df		bne $019c68			bne 	_VLNext 					; fail if different, try next.
.019c89	0a		asl a				asl 	a 							; until end character (bit 7 set) matched
.019c8a	90 f5		bcc $019c81			bcc 	_VLCompare
.019c8c	98		tya				tya
.019c8d	38		sec				sec 								; add 1 as Y points to last character
.019c8e	65 12		adc $12				adc 	zTemp2 						; add to the current address
.019c90	85 22		sta $22				sta 	zVarDataPtr
.019c92	a5 13		lda $13				lda 	zTemp2+1
.019c94	69 00		adc #$00			adc 	#0
.019c96	85 23		sta $23				sta 	zVarDataPtr+1
.019c98	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.019c9b	85 24		sta $24				sta 	zVarType
.019c9d	38		sec				sec 								; return CS
.019c9e	7a		ply		_VLExit:ply
.019c9f	fa		plx				plx
.019ca0	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/vargetset.asm

.019ca1					VariableGet:
.019ca1	5a		phy				phy
.019ca2	a0 00		ldy #$00			ldy 	#0 							; copy first two bytes
.019ca4	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019ca6	95 80		sta $80,x			sta 	XS_Mantissa,x
.019ca8	c8		iny				iny
.019ca9	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019cab	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019cad	c8		iny				iny
.019cae	a5 24		lda $24				lda 	zVarType 					; if it is a string, set up for that.
.019cb0	c9 b7		cmp #$b7			cmp 	#token_Dollar
.019cb2	f0 2c		beq $019ce0			beq 	_VGString
.019cb4	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; copy the next two bytes.
.019cb6	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019cb8	c8		iny				iny
.019cb9	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019cbb	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019cbd	c8		iny				iny
.019cbe	a9 01		lda #$01			lda 	#1 							; set type to 1.
.019cc0	95 85		sta $85,x			sta 	XS_Type,x
.019cc2	a5 24		lda $24				lda 	zVarType
.019cc4	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if it is a %, then exit with default integer.
.019cc6	f0 28		beq $019cf0			beq 	_VGExit
.019cc8	a9 40		lda #$40			lda 	#$40 						; set type byte to zero
.019cca	95 85		sta $85,x			sta 	XS_Type,x 					; which is the code for zero/float.
.019ccc	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; the last value to copy is the exponent.
.019cce	95 84		sta $84,x			sta 	XS_Exponent,x
.019cd0	f0 1e		beq $019cf0			beq 	_VGExit 					; if exponent is zero ... it's zero.
.019cd2	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; the sign bit is the top mantissa bit.
.019cd4	48		pha				pha
.019cd5	29 80		and #$80			and 	#$80
.019cd7	95 85		sta $85,x			sta 	XS_Type,x 					; this is the type byte.
.019cd9	68		pla				pla
.019cda	09 80		ora #$80			ora 	#$80 						; set the MSB as you would expect.
.019cdc	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; so it's a normalised float.
.019cde	80 10		bra $019cf0			bra 	_VGExit
.019ce0					_VGString:
.019ce0	a9 02		lda #$02			lda 	#2 							; set type to 2, a string
.019ce2	95 85		sta $85,x			sta 	XS_Type,x
.019ce4	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; is the value there $0000
.019ce6	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019ce8	d0 06		bne $019cf0			bne 	_VGExit 					; if not, exit.
.019cea	85 25		sta $25				sta 	zNullString 				; make zNullString a 00 string.
.019cec	a9 25		lda #$25			lda 	#zNullString
.019cee	95 80		sta $80,x			sta 	XS_Mantissa,x 				; make it point to it.
.019cf0					_VGExit:
.019cf0	7a		ply				ply
.019cf1	60		rts				rts
.019cf2					VariableSet:
.019cf2	b5 85		lda $85,x			lda 	XS_Type,x 					; is the result a string
.019cf4	29 02		and #$02			and 	#2 							; if so, it has to be
.019cf6	d0 4b		bne $019d43			bne 	_VSString
.019cf8	a5 24		lda $24				lda 	zVarType 					; if type is $ there's an error.
.019cfa	c9 b7		cmp #$b7			cmp 	#token_Dollar
.019cfc	f0 42		beq $019d40			beq 	_VSBadType
.019cfe	c9 bb		cmp #$bb			cmp 	#token_Percent 				; type convert to float/int
.019d00	f0 05		beq $019d07			beq 	_VSMakeInt
.019d02	20 68 a2	jsr $01a268			jsr 	FPUToFloat
.019d05	80 03		bra $019d0a			bra 	_VSCopy
.019d07					_VSMakeInt:
.019d07	20 b4 a2	jsr $01a2b4			jsr 	FPUToInteger
.019d0a					_VSCopy:
.019d0a	5a		phy				phy
.019d0b	a0 00		ldy #$00			ldy 	#0 							; copy mantissa to target.
.019d0d	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019d0f	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019d11	c8		iny				iny
.019d12	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019d14	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019d16	c8		iny				iny
.019d17	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019d19	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019d1b	c8		iny				iny
.019d1c	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019d1e	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019d20	a5 24		lda $24				lda 	zVarType 					; if target is integer, alrady done.
.019d22	c9 bb		cmp #$bb			cmp 	#token_Percent
.019d24	f0 18		beq $019d3e			beq 	_VSExit
.019d26	b5 85		lda $85,x			lda 	XS_Type,x 					; get the sign bit into carry flag.
.019d28	0a		asl a				asl 	a
.019d29	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; shift the sign into the mantissa high.
.019d2b	08		php				php
.019d2c	0a		asl a				asl 	a
.019d2d	28		plp				plp
.019d2e	6a		ror a				ror 	a
.019d2f	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019d31	c8		iny				iny
.019d32	b5 84		lda $84,x			lda 	XS_Exponent,x 				; copy the exponent in
.019d34	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019d36	34 85		bit $85,x			bit 	XS_Type,x 					; if the result is non zero
.019d38	50 04		bvc $019d3e			bvc 	_VSExit
.019d3a	a9 00		lda #$00			lda 	#00 						; zero exponent indicating 0.
.019d3c	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019d3e					_VSExit:
.019d3e	7a		ply				ply
.019d3f	60		rts				rts
.019d40					_VSBadType:
.019d40	4c 5a 85	jmp $01855a			jmp 	TypeError
.019d43					_VSString:
.019d43	a5 24		lda $24				lda 	zVarType 					; type must be $
.019d45	c9 b7		cmp #$b7			cmp 	#token_Dollar
.019d47	d0 f7		bne $019d40			bne 	_VSBadType
.019d49	da		phx				phx
.019d4a	5a		phy				phy
.019d4b	20 bb 98	jsr $0198bb			jsr 	StringConcrete 				; concrete the string in the mantissa -> AX
.019d4e	a0 01		ldy #$01			ldy 	#1 							; save high byte
.019d50	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019d52	88		dey				dey 								; save low byte
.019d53	8a		txa				txa
.019d54	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019d56	7a		ply				ply 								; and exit.
.019d57	fa		plx				plx
.019d58	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.019d59					MulInteger32:
.019d59	b5 80		lda $80,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.019d5b	95 8c		sta $8c,x			sta 	XS3_Mantissa,x
.019d5d	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019d5f	95 8d		sta $8d,x			sta 	XS3_Mantissa+1,x
.019d61	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019d63	95 8e		sta $8e,x			sta 	XS3_Mantissa+2,x
.019d65	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019d67	95 8f		sta $8f,x			sta 	XS3_Mantissa+3,x
.019d69	a9 00		lda #$00			lda 	#0
.019d6b	95 80		sta $80,x			sta 	XS_Mantissa+0,x 				; zero +0, where the result goes.
.019d6d	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019d6f	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019d71	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019d73					_BFMMultiply:
.019d73	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.019d75	29 01		and #$01			and 	#1
.019d77	f0 03		beq $019d7c			beq 	_BFMNoAdd
.019d79	20 06 94	jsr $019406			jsr 	AddInteger32 					; co-opt this code
.019d7c					_BFMNoAdd:
.019d7c	16 86		asl $86,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.019d7e	36 87		rol $87,x			rol 	XS2_Mantissa+1,x
.019d80	36 88		rol $88,x			rol 	XS2_Mantissa+2,x
.019d82	36 89		rol $89,x			rol 	XS2_Mantissa+3,x
.019d84	56 8f		lsr $8f,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.019d86	76 8e		ror $8e,x			ror 	XS3_Mantissa+2,x
.019d88	76 8d		ror $8d,x			ror 	XS3_Mantissa+1,x
.019d8a	76 8c		ror $8c,x			ror 	XS3_Mantissa,x
.019d8c	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.019d8e	15 8d		ora $8d,x			ora 	XS3_Mantissa+1,x
.019d90	15 8e		ora $8e,x			ora 	XS3_Mantissa+2,x
.019d92	15 8f		ora $8f,x			ora 	XS3_Mantissa+3,x
.019d94	d0 dd		bne $019d73			bne 	_BFMMultiply
.019d96	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.019d97					DivInteger32:
.019d97	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; check for division by zero.
.019d99	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.019d9b	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.019d9d	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.019d9f	d0 14		bne $019db5			bne 	_BFDOkay
.019da1	20 79 85	jsr $018579			jsr ERR_Handler
>019da4	44 69 76 69 73 69 6f 6e			.text "Division by Zero",0
>019dac	20 62 79 20 5a 65 72 6f 00
.019db5					_BFDOkay:
.019db5	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.019db7	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.019db9	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.019dbb	85 1c		sta $1c				sta 	zLTemp1+2
.019dbd	85 1d		sta $1d				sta 	zLTemp1+3
.019dbf	8d 9e 03	sta $039e			sta 	SignCount 					; Count of signs.
.019dc2	20 19 9e	jsr $019e19			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.019dc5	da		phx				phx
.019dc6	e8		inx				inx
.019dc7	e8		inx				inx
.019dc8	e8		inx				inx
.019dc9	e8		inx				inx
.019dca	e8		inx				inx
.019dcb	e8		inx				inx
.019dcc	20 19 9e	jsr $019e19			jsr 	CheckIntegerNegate
.019dcf	fa		plx				plx
.019dd0	5a		phy				phy 								; Y is the counter
.019dd1	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.019dd3					_BFDLoop:
.019dd3	16 80		asl $80,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.019dd5	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.019dd7	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.019dd9	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.019ddb	26 1a		rol $1a				rol 	zLTemp1
.019ddd	26 1b		rol $1b				rol 	zLTemp1+1
.019ddf	26 1c		rol $1c				rol 	zLTemp1+2
.019de1	26 1d		rol $1d				rol 	zLTemp1+3
.019de3	38		sec				sec
.019de4	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.019de6	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.019de8	48		pha				pha
.019de9	a5 1b		lda $1b				lda 	zLTemp1+1
.019deb	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.019ded	48		pha				pha
.019dee	a5 1c		lda $1c				lda 	zLTemp1+2
.019df0	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.019df2	48		pha				pha
.019df3	a5 1d		lda $1d				lda 	zLTemp1+3
.019df5	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.019df7	90 13		bcc $019e0c			bcc 	_BFDNoAdd
.019df9	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.019dfb	68		pla				pla
.019dfc	85 1c		sta $1c				sta 	zLTemp1+2
.019dfe	68		pla				pla
.019dff	85 1b		sta $1b				sta 	zLTemp1+1
.019e01	68		pla				pla
.019e02	85 1a		sta $1a				sta 	zLTemp1+0
.019e04	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.019e06	09 01		ora #$01			ora 	#1
.019e08	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019e0a	80 03		bra $019e0f			bra 	_BFDNext
.019e0c					_BFDNoAdd:
.019e0c	68		pla				pla 								; Throw away the intermediate calculations
.019e0d	68		pla				pla
.019e0e	68		pla				pla
.019e0f					_BFDNext:
.019e0f	88		dey				dey
.019e10	d0 c1		bne $019dd3			bne 	_BFDLoop
.019e12	7a		ply				ply 								; restore Y
.019e13	4e 9e 03	lsr $039e			lsr 	SignCount 					; if sign count odd,
.019e16	b0 06		bcs $019e1e			bcs		IntegerNegateAlways 		; negate the result
.019e18	60		rts				rts
.019e19					CheckIntegerNegate:
.019e19	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; is it -ve = MSB set ?
.019e1b	30 01		bmi $019e1e			bmi 	IntegerNegateAlways 		; if so negate it
.019e1d	60		rts				rts
.019e1e					IntegerNegateAlways:
.019e1e	ee 9e 03	inc $039e			inc 	SignCount 					; bump the count of signs
.019e21	38		sec				sec 								; 0-mantissa,x -> mantissa,x
.019e22	a9 00		lda #$00			lda 	#0
.019e24	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.019e26	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019e28	a9 00		lda #$00			lda 	#0
.019e2a	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.019e2c	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019e2e	a9 00		lda #$00			lda 	#0
.019e30	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.019e32	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019e34	a9 00		lda #$00			lda 	#0
.019e36	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.019e38	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019e3a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.019e3b					INTToString:
.019e3b	48		pha				pha
.019e3c	5a		phy				phy
.019e3d	b5 83		lda $83,x			lda 		XS_Mantissa+3,x 		; check -ve
.019e3f	10 08		bpl $019e49			bpl 		_ITSNotMinus
.019e41	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.019e43	20 dd 9e	jsr $019edd			jsr 		ITSOutputCharacter
.019e46	20 1e 9e	jsr $019e1e			jsr 		IntegerNegateAlways 	; negate the number.
.019e49					_ITSNotMinus:
.019e49	a9 00		lda #$00			lda 		#0
.019e4b	8d 9a 03	sta $039a			sta 		NumSuppress 			; clear the suppression flag.
.019e4e	8a		txa				txa 								; use Y for the mantissa index.
.019e4f	a8		tay				tay
.019e50	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.019e52					_ITSNextSubtractor:
.019e52	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.019e54	8d 9b 03	sta $039b			sta 		NumConvCount
.019e57					_ITSSubtract:
.019e57	38		sec				sec
.019e58	b9 80 00	lda $0080,y			lda 		XS_Mantissa,y 			; subtract number and push on stack
.019e5b	ff b9 9e 01	sbc $019eb9,x			sbc 		_ITSSubtractors+0,x
.019e5f	48		pha				pha
.019e60	b9 81 00	lda $0081,y			lda 		XS_Mantissa+1,y
.019e63	ff ba 9e 01	sbc $019eba,x			sbc 		_ITSSubtractors+1,x
.019e67	48		pha				pha
.019e68	b9 82 00	lda $0082,y			lda 		XS_Mantissa+2,y
.019e6b	ff bb 9e 01	sbc $019ebb,x			sbc 		_ITSSubtractors+2,x
.019e6f	48		pha				pha
.019e70	b9 83 00	lda $0083,y			lda 		XS_Mantissa+3,y
.019e73	ff bc 9e 01	sbc $019ebc,x			sbc 		_ITSSubtractors+3,x
.019e77	90 14		bcc $019e8d			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.019e79	99 83 00	sta $0083,y			sta 		XS_Mantissa+3,y 		; save subtract off stack
.019e7c	68		pla				pla
.019e7d	99 82 00	sta $0082,y			sta 		XS_Mantissa+2,y
.019e80	68		pla				pla
.019e81	99 81 00	sta $0081,y			sta 		XS_Mantissa+1,y
.019e84	68		pla				pla
.019e85	99 80 00	sta $0080,y			sta 		XS_Mantissa+0,y
.019e88	ee 9b 03	inc $039b			inc 		NumConvCount 			; bump count.
.019e8b	80 ca		bra $019e57			bra 		_ITSSubtract 			; go round again.
.019e8d					_ITSCantSubtract:
.019e8d	68		pla				pla 								; throw away interim answers
.019e8e	68		pla				pla
.019e8f	68		pla				pla
.019e90	ad 9b 03	lda $039b			lda 		NumConvCount 			; if not zero then no suppression check
.019e93	c9 30		cmp #$30			cmp 		#"0"
.019e95	d0 05		bne $019e9c			bne 		_ITSOutputDigit
.019e97	ad 9a 03	lda $039a			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.019e9a	10 09		bpl $019ea5			bpl	 		_ITSGoNextSubtractor
.019e9c					_ITSOutputDigit:
.019e9c	ce 9a 03	dec $039a			dec 		NumSuppress 			; suppression check will be non-zero.
.019e9f	ad 9b 03	lda $039b			lda 		NumConvCount 			; count of subtractions
.019ea2	20 dd 9e	jsr $019edd			jsr 		ITSOutputCharacter 		; output it.
.019ea5					_ITSGoNextSubtractor:
.019ea5	e8		inx				inx 								; next dword
.019ea6	e8		inx				inx
.019ea7	e8		inx				inx
.019ea8	e8		inx				inx
.019ea9	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.019eab	d0 a5		bne $019e52			bne 		_ITSNextSubtractor 		; do all the subtractors.
.019ead	98		tya				tya 								; X is back as the mantissa index
.019eae	aa		tax				tax
.019eaf	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.019eb1	09 30		ora #$30			ora 		#"0"
.019eb3	20 dd 9e	jsr $019edd			jsr 		ITSOutputCharacter
.019eb6	7a		ply				ply 								; and exit
.019eb7	68		pla				pla
.019eb8	60		rts				rts
.019eb9					_ITSSubtractors:
>019eb9	00 ca 9a 3b					.dword 		1000000000
>019ebd	00 e1 f5 05					.dword 		100000000
>019ec1	80 96 98 00					.dword 		10000000
>019ec5	40 42 0f 00					.dword 		1000000
>019ec9	a0 86 01 00					.dword 		100000
>019ecd	10 27 00 00					.dword 		10000
>019ed1	e8 03 00 00					.dword 		1000
>019ed5	64 00 00 00					.dword 		100
>019ed9	0a 00 00 00					.dword 		10
.019edd					_ITSSubtractorsEnd:
.019edd					ITSOutputCharacter:
.019edd	48		pha				pha
.019ede	da		phx				phx
.019edf	ae 14 03	ldx $0314			ldx 	NumBufX 					; save digit
.019ee2	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.019ee5	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.019ee7	9d 16 03	sta $0316,x			sta 	Num_Buffer+1,x
.019eea	ee 14 03	inc $0314			inc 	NumBufX						; bump pointer.
.019eed	fa		plx				plx
.019eee	68		pla				pla
.019eef	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.019ef0					IntFromString:
.019ef0	a0 00		ldy #$00			ldy 	#0
.019ef2	8c 9c 03	sty $039c			sty 	ExpTemp 					; this is the converted digit count.
.019ef5					IntFromStringY:
.019ef5	48		pha				pha
.019ef6	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.019ef8	95 80		sta $80,x			sta 	XS_Mantissa,x
.019efa	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019efc	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019efe	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019f00	a9 01		lda #$01			lda 	#1
.019f02	95 85		sta $85,x			sta 	XS_Type,x
.019f04					_IFSLoop:
.019f04	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.019f06	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.019f08	90 4e		bcc $019f58			bcc 	_IFSExit
.019f0a	c9 3a		cmp #$3a			cmp 	#"9"+1
.019f0c	b0 4a		bcs $019f58			bcs 	_IFSExit
.019f0e	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.019f10	c9 0c		cmp #$0c			cmp 	#12
.019f12	b0 4e		bcs $019f62			bcs 	_IFSOverflow
.019f14	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.019f16	48		pha				pha
.019f17	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019f19	48		pha				pha
.019f1a	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019f1c	48		pha				pha
.019f1d	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019f1f	48		pha				pha
.019f20	20 77 9f	jsr $019f77			jsr 	IFSX1ShiftLeft 				; double
.019f23	20 77 9f	jsr $019f77			jsr 	IFSX1ShiftLeft 				; x 4
.019f26	18		clc				clc 								; add saved value x 5
.019f27	68		pla				pla
.019f28	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.019f2a	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019f2c	68		pla				pla
.019f2d	75 81		adc $81,x			adc 	XS_Mantissa+1,x
.019f2f	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019f31	68		pla				pla
.019f32	75 82		adc $82,x			adc 	XS_Mantissa+2,x
.019f34	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019f36	68		pla				pla
.019f37	75 83		adc $83,x			adc 	XS_Mantissa+3,x
.019f39	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019f3b	20 77 9f	jsr $019f77			jsr 	IFSX1ShiftLeft 				; x 10
.019f3e	ee 9c 03	inc $039c			inc 	ExpTemp 					; bump count of digits processed.
.019f41	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.019f43	29 0f		and #$0f			and 	#15
.019f45	c8		iny				iny
.019f46	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.019f48	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019f4a	90 b8		bcc $019f04			bcc 	_IFSLoop
.019f4c	f6 81		inc $81,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.019f4e	d0 b4		bne $019f04			bne 	_IFSLoop
.019f50	f6 82		inc $82,x			inc 	XS_Mantissa+2,x
.019f52	d0 b0		bne $019f04			bne 	_IFSLoop
.019f54	f6 83		inc $83,x			inc 	XS_Mantissa+3,x
.019f56	80 ac		bra $019f04			bra 	_IFSLoop
.019f58					_IFSExit:
.019f58	98		tya				tya 								; get offset
.019f59					_IFSOkay:
.019f59	38		sec				sec
.019f5a	ad 9c 03	lda $039c			lda 	ExpTemp
.019f5d	f0 01		beq $019f60			beq 	_IFSSkipFail
.019f5f	18		clc				clc
.019f60					_IFSSkipFail:
.019f60	68		pla				pla 								; and exit.
.019f61	60		rts				rts
.019f62					_IFSOverflow:
.019f62	20 79 85	jsr $018579			jsr 	ERR_Handler
>019f65	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>019f6d	20 6f 76 65 72 66 6c 6f 77 00
.019f77					IFSX1ShiftLeft:
.019f77	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.019f79	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.019f7b	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.019f7d	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.019f7f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.019f80					FPSubtract:
.019f80	48		pha				pha
.019f81	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.019f83	49 80		eor #$80			eor 	#$80
.019f85	95 8b		sta $8b,x			sta 	XS2_Type,x
.019f87	68		pla				pla 								; --- and fall through ---
.019f88					FPAdd:
.019f88	48		pha				pha
.019f89	b5 85		lda $85,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.019f8b	d0 05		bne $019f92			bne 	_FPA_NegativeLHS
.019f8d	20 a9 9f	jsr $019fa9			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.019f90	68		pla				pla
.019f91	60		rts				rts
.019f92					_FPA_NegativeLHS:
.019f92	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.019f94	49 80		eor #$80			eor 	#$80
.019f96	95 85		sta $85,x			sta 	XS_Type,x
.019f98	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of B and add
.019f9a	49 80		eor #$80			eor 	#$80
.019f9c	95 8b		sta $8b,x			sta 	XS2_Type,x
.019f9e	20 a9 9f	jsr $019fa9			jsr 	FPAdd_Worker 				; do the add calculation.
.019fa1	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 back
.019fa3	49 80		eor #$80			eor 	#$80
.019fa5	95 85		sta $85,x			sta 	XS_Type,x
.019fa7	68		pla				pla
.019fa8	60		rts				rts
.019fa9					FPAdd_Worker:
.019fa9	34 8b		bit $8b,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.019fab	70 07		bvs $019fb4			bvs 	_FPAWExit 					; no change.
.019fad	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.019faf	50 07		bvc $019fb8			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.019fb1	20 26 a2	jsr $01a226			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.019fb4					_FPAWExit:
.019fb4	20 95 a2	jsr $01a295			jsr 	FPUNormalise 				; normalise the result.
.019fb7	60		rts				rts
.019fb8					_FPAWMakeSame:
.019fb8	b5 84		lda $84,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.019fba	38		sec				sec
.019fbb	f5 8a		sbc $8a,x			sbc	 	XS2_Exponent,x 				; using subtraction
.019fbd	f0 16		beq $019fd5			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.019fbf	da		phx				phx 								; save X
.019fc0	90 06		bcc $019fc8			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.019fc2	e8		inx				inx
.019fc3	e8		inx				inx
.019fc4	e8		inx				inx
.019fc5	e8		inx				inx
.019fc6	e8		inx				inx
.019fc7	e8		inx				inx
.019fc8					_FPAWShiftA:
.019fc8	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.019fca	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.019fcc	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.019fce	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.019fd0	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.019fd2	fa		plx				plx 								; restore original X
.019fd3	80 e3		bra $019fb8			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.019fd5					_FPAW_DoArithmetic:
.019fd5	34 8b		bit $8b,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.019fd7	30 28		bmi $01a001			bmi 	_FPAW_BNegative
.019fd9	18		clc				clc
.019fda	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019fdc	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.019fde	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019fe0	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019fe2	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.019fe4	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019fe6	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019fe8	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.019fea	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019fec	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019fee	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.019ff0	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019ff2	90 c0		bcc $019fb4			bcc 	_FPAWExit 					; no carry.
.019ff4	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.019ff6	38		sec				sec
.019ff7	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.019ff9	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.019ffb	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.019ffd	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.019fff	80 b3		bra $019fb4			bra 	_FPAWExit
.01a001					_FPAW_BNegative:
.01a001	38		sec				sec
.01a002	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01a004	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.01a006	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a008	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a00a	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.01a00c	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a00e	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a010	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.01a012	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a014	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a016	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.01a018	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a01a	b0 09		bcs $01a025			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.01a01c	20 4c a2	jsr $01a24c			jsr 	FPUNegateInteger			; negate the mantissa
.01a01f	b5 85		lda $85,x			lda 	XS_Type,x 					; flip result sign
.01a021	49 80		eor #$80			eor 	#$80
.01a023	95 85		sta $85,x			sta 	XS_Type,x
.01a025					_FPAWGoExit:
.01a025	4c b4 9f	jmp $019fb4			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.01a028					FPD_IsDivZero:
.01a028	20 79 85	jsr $018579			jsr ERR_Handler
>01a02b	44 69 76 69 73 69 6f 6e			.text "Division by zero",0
>01a033	20 62 79 20 7a 65 72 6f 00
.01a03c					FPDivide:
.01a03c	48		pha				pha
.01a03d	5a		phy				phy
.01a03e	34 8b		bit $8b,x			bit 	XS2_Type,x 					; check if division by zero
.01a040	70 e6		bvs $01a028			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.01a042	34 85		bit $85,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.01a044	f0 03		beq $01a049			beq 	_FPDCalculateExp
.01a046					_FPD_Exit:
.01a046	7a		ply				ply
.01a047	68		pla				pla
.01a048	60		rts				rts
.01a049					_FPDCalculateExp:
.01a049	b5 8a		lda $8a,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.01a04b	49 ff		eor #$ff			eor 	#$FF
.01a04d	1a		inc a				inc 	a
.01a04e	95 8a		sta $8a,x			sta 	XS2_Exponent,x
.01a050	20 20 a1	jsr $01a120			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.01a053	18		clc				clc 	 							; add 1 to the resulting exponent
.01a054	69 01		adc #$01			adc 	#1
.01a056	b0 54		bcs $01a0ac			bcs 	_FPD_Overflow 				; which can overflow.
.01a058	95 84		sta $84,x			sta 	XS_Exponent,x
.01a05a	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.01a05c	85 1a		sta $1a				sta 	zLTemp1+0
.01a05e	85 1b		sta $1b				sta 	zLTemp1+1
.01a060	85 1c		sta $1c				sta 	zLTemp1+2
.01a062	85 1d		sta $1d				sta 	zLTemp1+3
.01a064	a0 20		ldy #$20			ldy 	#32 						; times round.
.01a066					_FPD_Loop:
.01a066	38		sec				sec 								; calculate X1-X2 stacking result because we might
.01a067	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; not save it.
.01a069	f5 86		sbc $86,x			sbc 	XS2_Mantissa,x
.01a06b	48		pha				pha
.01a06c	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a06e	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.01a070	48		pha				pha
.01a071	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a073	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.01a075	48		pha				pha
.01a076	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a078	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.01a07a	90 13		bcc $01a08f			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.01a07c	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; save results out to A
.01a07e	68		pla				pla
.01a07f	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a081	68		pla				pla
.01a082	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a084	68		pla				pla
.01a085	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a087	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.01a089	09 80		ora #$80			ora 	#$80
.01a08b	85 1d		sta $1d				sta 	zLTemp1+3
.01a08d	80 03		bra $01a092			bra 	_FPD_Rotates
.01a08f					_FPD_NoSubtract:
.01a08f	68		pla				pla 								; throw away unwanted results
.01a090	68		pla				pla
.01a091	68		pla				pla
.01a092					_FPD_Rotates:
.01a092	56 89		lsr $89,x			lsr 	3+XS2_Mantissa,x
.01a094	76 88		ror $88,x			ror 	2+XS2_Mantissa,x
.01a096	76 87		ror $87,x			ror 	1+XS2_Mantissa,x
.01a098	76 86		ror $86,x			ror 	0+XS2_Mantissa,x
.01a09a	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.01a09c	26 1b		rol $1b				rol 	zLTemp1+1
.01a09e	26 1c		rol $1c				rol 	zLTemp1+2
.01a0a0	26 1d		rol $1d				rol 	zLTemp1+3
.01a0a2	90 02		bcc $01a0a6			bcc 	_FPD_NoCarry
.01a0a4	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.01a0a6					_FPD_NoCarry:
.01a0a6	88		dey				dey 								; do 32 times
.01a0a7	d0 bd		bne $01a066			bne 	_FPD_Loop
.01a0a9	4c 04 a1	jmp $01a104			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.01a0ac					_FPD_Overflow:
.01a0ac	4c f2 a2	jmp $01a2f2			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.01a0af					FPMultiply:
.01a0af	48		pha				pha
.01a0b0	5a		phy				phy
.01a0b1	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.01a0b3	70 07		bvs $01a0bc			bvs 	_FPM_Exit
.01a0b5	34 8b		bit $8b,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.01a0b7	50 06		bvc $01a0bf			bvc 	_FPM_CalcExponent
.01a0b9	20 26 a2	jsr $01a226			jsr 	FPUCopyX2ToX1
.01a0bc					_FPM_Exit:
.01a0bc	7a		ply				ply
.01a0bd	68		pla				pla
.01a0be	60		rts				rts
.01a0bf					_FPM_CalcExponent:
.01a0bf	18		clc				clc
.01a0c0	20 20 a1	jsr $01a120			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.01a0c3	95 84		sta $84,x			sta 	XS_Exponent,x 				; save the result.
.01a0c5	a9 00		lda #$00			lda 	#0
.01a0c7	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.01a0c9	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.01a0cb	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.01a0cd	85 1d		sta $1d				sta 	zLTemp1+3
.01a0cf	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.01a0d1					_FPM_Loop:
.01a0d1	b5 80		lda $80,x			lda 	XS_Mantissa,x				; check LSB of long product
.01a0d3	29 01		and #$01			and 	#1
.01a0d5	18		clc				clc 								; clear carry for the long rotate.
.01a0d6	f0 19		beq $01a0f1			beq 	_FPM_NoAddition
.01a0d8	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.01a0d9	a5 1a		lda $1a				lda 	zLTemp1+0
.01a0db	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.01a0dd	85 1a		sta $1a				sta 	zLTemp1+0
.01a0df	a5 1b		lda $1b				lda 	zLTemp1+1
.01a0e1	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.01a0e3	85 1b		sta $1b				sta 	zLTemp1+1
.01a0e5	a5 1c		lda $1c				lda 	zLTemp1+2
.01a0e7	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.01a0e9	85 1c		sta $1c				sta 	zLTemp1+2
.01a0eb	a5 1d		lda $1d				lda 	zLTemp1+3
.01a0ed	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.01a0ef	85 1d		sta $1d				sta 	zLTemp1+3
.01a0f1					_FPM_NoAddition:
.01a0f1	66 1d		ror $1d				ror 	3+zLTemp1
.01a0f3	66 1c		ror $1c				ror 	2+zLTemp1
.01a0f5	66 1b		ror $1b				ror 	1+zLTemp1
.01a0f7	66 1a		ror $1a				ror 	0+zLTemp1
.01a0f9	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.01a0fb	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a0fd	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a0ff	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a101	88		dey				dey
.01a102	d0 cd		bne $01a0d1			bne 	_FPM_Loop 					; do this 32 times.
.01a104					FPM_CopySignNormalize:
.01a104	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.01a106	95 80		sta $80,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.01a108	a5 1b		lda $1b				lda 	zLTemp1+1
.01a10a	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a10c	a5 1c		lda $1c				lda 	zLTemp1+2
.01a10e	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a110	a5 1d		lda $1d				lda 	zLTemp1+3
.01a112	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a114	b5 85		lda $85,x			lda 	XS_Type,x 					; sign is xor of signs
.01a116	55 8b		eor $8b,x			eor 	XS2_Type,x
.01a118	95 85		sta $85,x			sta 	XS_Type,x
.01a11a	20 95 a2	jsr $01a295			jsr 	FPUNormalise 				; normalise and exit.
.01a11d	7a		ply				ply
.01a11e	68		pla				pla
.01a11f	60		rts				rts
.01a120					FPCalculateExponent:
.01a120	18		clc				clc
.01a121	b5 84		lda $84,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.01a123	75 8a		adc $8a,x			adc 	XS2_Exponent,x
.01a125	b0 08		bcs $01a12f			bcs 	_FPCECarry 					; carry out ?
.01a127	10 03		bpl $01a12c			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.01a129	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.01a12b	60		rts				rts
.01a12c					_FPCEExpZero:
.01a12c	a9 00		lda #$00			lda 	#0
.01a12e	60		rts				rts
.01a12f					_FPCECarry:
.01a12f	30 03		bmi $01a134			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.01a131	09 80		ora #$80			ora 	#$80 						; put in right range
.01a133	60		rts				rts
.01a134					_FPCEOverflow:
.01a134	4c f2 a2	jmp $01a2f2			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.01a137					FPFractionalPart:
.01a137	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.01a139	38		sec				sec 								; this flag tells us to keep the fractional part
.01a13a	30 0d		bmi $01a149			bmi 	FPGetPart
.01a13c	60		rts				rts
.01a13d					FPIntegerPart:
.01a13d	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.01a13f	18		clc				clc 								; this flag says keep the integer part.
.01a140	30 07		bmi $01a149			bmi 	FPGetPart 					; -ve exponents are 0..127
.01a142	48		pha				pha
.01a143	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.01a145	95 85		sta $85,x			sta 	XS_Type,x
.01a147	68		pla				pla
.01a148	60		rts				rts
.01a149					FPGetPart:
.01a149	48		pha				pha
.01a14a	5a		phy				phy 								; save Y
.01a14b	08		php				php 								; save action
.01a14c	34 85		bit $85,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.01a14e	70 59		bvs $01a1a9			bvs 	_FPGP_Exit 					; then do nothing.
.01a150	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.01a152	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.01a154	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.01a156	85 1c		sta $1c				sta 	zLTemp1+2
.01a158	85 1d		sta $1d				sta 	zLTemp1+3
.01a15a	b5 84		lda $84,x			lda 	XS_Exponent,x				; the number of shifts.
.01a15c	38		sec				sec
.01a15d	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.01a15f	f0 12		beq $01a173			beq 	_FPGP_NoShift 				; ... if any
.01a161	c9 20		cmp #$20			cmp 	#32
.01a163	90 02		bcc $01a167			bcc 	_FPGP_NotMax
.01a165	a9 20		lda #$20			lda 	#32 						; max of 32.
.01a167					_FPGP_NotMax:
.01a167	a8		tay				tay 								; Y is the mask shift count.
.01a168					_FPGP_ShiftMask:
.01a168	46 1d		lsr $1d				lsr 	3+zLTemp1
.01a16a	66 1c		ror $1c				ror 	2+zLTemp1
.01a16c	66 1b		ror $1b				ror 	1+zLTemp1
.01a16e	66 1a		ror $1a				ror 	0+zLTemp1
.01a170	88		dey				dey
.01a171	d0 f5		bne $01a168			bne 	_FPGP_ShiftMask
.01a173					_FPGP_NoShift:
.01a173	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.01a175	8e 9c 03	stx $039c			stx 	ExpTemp						; save X
.01a178					_FPGP_MaskLoop:
.01a178	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.01a17b	28		plp				plp 								; if CC we keep the top part, so we
.01a17c	08		php				php		 							; flip the mask.
.01a17d	b0 02		bcs $01a181			bcs		_FPGP_NoFlip
.01a17f	49 ff		eor #$ff			eor 	#$FF
.01a181					_FPGP_NoFlip:
.01a181	35 80		and $80,x			and 	XS_Mantissa,x 				; and into the mantissa.
.01a183	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a185	e8		inx				inx
.01a186	c8		iny				iny
.01a187	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.01a189	d0 ed		bne $01a178			bne 	_FPGP_MaskLoop
.01a18b	ae 9c 03	ldx $039c			ldx 	ExpTemp						; restore X
.01a18e	28		plp				plp
.01a18f	08		php				php 								; get action flag on the stack
.01a190	90 04		bcc $01a196			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.01a192	a9 00		lda #$00			lda 	#0
.01a194	95 85		sta $85,x			sta 	XS_Type,x
.01a196					_FPGP_NotFractional:
.01a196	b5 80		lda $80,x			lda 	XS_Mantissa,x 						; check if \1 zero
.01a198	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.01a19a	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01a19c	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01a19e	f0 05		beq $01a1a5			beq 	_FPGP_Zero 					; if zero, return zero
.01a1a0	20 95 a2	jsr $01a295			jsr 	FPUNormalise
.01a1a3	80 04		bra $01a1a9			bra 	_FPGP_Exit 					; and exit
.01a1a5					_FPGP_Zero:
.01a1a5	a9 40		lda #$40			lda 	#$40 						; set zero flag
.01a1a7	95 85		sta $85,x			sta 	XS_Type,x
.01a1a9					_FPGP_Exit:
.01a1a9	68		pla				pla 								; throw saved action flag.
.01a1aa	7a		ply				ply
.01a1ab	68		pla				pla
.01a1ac	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.01a1ad					FPCompare:
.01a1ad	20 ee a1	jsr $01a1ee			jsr 	FPFastCompare 				; fast compare try first
.01a1b0	b0 3b		bcs $01a1ed			bcs 	_FPCExit 					; that worked.
.01a1b2	b5 84		lda $84,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.01a1b4	48		pha				pha
.01a1b5	b5 8a		lda $8a,x			lda 	XS2_Exponent,x
.01a1b7	48		pha				pha
.01a1b8	20 80 9f	jsr $019f80			jsr 	FPSubtract 					; calculate X1-X2
.01a1bb	34 85		bit $85,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.01a1bd	70 2a		bvs $01a1e9			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.01a1bf	68		pla				pla
.01a1c0	8d 9c 03	sta $039c			sta 	ExpTemp						; save first exponent in temporary reg.
.01a1c3	68		pla				pla
.01a1c4	38		sec				sec
.01a1c5	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; calculate AX-BX
.01a1c8	70 14		bvs $01a1de			bvs 	_FPCNotEqual				; overflow, can't be equal.
.01a1ca	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.01a1cb	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.01a1cd	b0 0f		bcs $01a1de			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.01a1cf	38		sec				sec
.01a1d0	ad 9c 03	lda $039c			lda 	ExpTemp 					; get one of the exponents back.
.01a1d3	e9 12		sbc #$12			sbc 	#18 						; allow for 2^18 error, relatively.
.01a1d5	b0 02		bcs $01a1d9			bcs 	_FPCNotRange 				; keep in range.
.01a1d7	a9 01		lda #$01			lda 	#1
.01a1d9					_FPCNotRange:
.01a1d9	38		sec				sec
.01a1da	f5 84		sbc $84,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.01a1dc	b0 0d		bcs $01a1eb			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.01a1de					_FPCNotEqual:
.01a1de	b5 85		lda $85,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.01a1e0	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.01a1e2	f0 02		beq $01a1e6			beq 	_FPCNE2
.01a1e4	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.01a1e6	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.01a1e7	80 04		bra $01a1ed			bra 	_FPCExit
.01a1e9					_FPCPullZero:
.01a1e9	68		pla				pla 								; throw saved exponents
.01a1ea	68		pla				pla
.01a1eb					_FPCZero:
.01a1eb	a9 00		lda #$00			lda 	#0 							; and return zero
.01a1ed					_FPCExit:
.01a1ed	60		rts				rts
.01a1ee					FPFastCompare:
.01a1ee	34 85		bit $85,x			bit 	XS_Type,x 					; n1 is zero.
.01a1f0	70 23		bvs $01a215			bvs 	_FPFLeftZero
.01a1f2	34 8b		bit $8b,x			bit 	XS2_Type,x 					; n2 is zero
.01a1f4	b5 85		lda $85,x			lda 	XS_Type,x 					; if so, return sign bit of 1 (n-0)
.01a1f6	70 25		bvs $01a21d			bvs 	_FPFSignBit
.01a1f8	55 8b		eor $8b,x			eor 	XS2_Type,x 					; eor 2 type bits. now know both non-zero
.01a1fa	0a		asl a				asl 	a 							; put in CS if different.
.01a1fb	b5 85		lda $85,x			lda 	XS_Type,x 					; if signs different return sign of first
.01a1fd	b0 1e		bcs $01a21d			bcs 	_FPFSignBit
.01a1ff	38		sec				sec 								; same sign and not-zero. compare exponents
.01a200	b5 84		lda $84,x			lda 	XS_Exponent,x 				; compare exponents. if the same, then fail.
.01a202	f5 8a		sbc $8a,x			sbc 	XS2_Exponent,x 				; e.g. we have to do it via subtraction.
.01a204	f0 09		beq $01a20f			beq 	_FPNoFastCompare
.01a206	6a		ror a				ror 	a 							; put carry into bit 7.
.01a207	34 85		bit $85,x			bit 	XS_Type,X 					; if it is +x then flip it.
.01a209	30 02		bmi $01a20d			bmi		_FPFCNotMinus
.01a20b	49 80		eor #$80			eor 	#$80
.01a20d					_FPFCNotMinus:
.01a20d	80 0e		bra $01a21d			bra		_FPFSignBit
.01a20f					_FPNoFastCompare:
.01a20f	18		clc				clc
.01a210	60		rts				rts
.01a211					_FPFZero:
.01a211	a9 00		lda #$00			lda 	#0
.01a213					_FPFExitSet:
.01a213	38		sec				sec
.01a214	60		rts				rts
.01a215					_FPFLeftZero:
.01a215	34 8b		bit $8b,x			bit 	XS2_Type,x 					; if right is zero, return zero.
.01a217	70 f8		bvs $01a211			bvs 	_FPFZero
.01a219	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip sign bit
.01a21b	49 80		eor #$80			eor 	#$80						; return that as a sign.
.01a21d					_FPFSignBit:
.01a21d	0a		asl a				asl 	a
.01a21e	a9 01		lda #$01			lda 	#1
.01a220	90 f1		bcc $01a213			bcc		_FPFExitSet
.01a222	a9 ff		lda #$ff			lda 	#$FF
.01a224	38		sec				sec
.01a225	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.01a226					FPUCopyX2ToX1:
.01a226	48		pha				pha
.01a227	da		phx				phx
.01a228	5a		phy				phy
.01a229	a0 08		ldy #$08			ldy 	#8
.01a22b	b5 86		lda $86,x	_FPUC21:lda 	XS2_Mantissa,x
.01a22d	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a22f	e8		inx				inx
.01a230	88		dey				dey
.01a231	10 f8		bpl $01a22b			bpl 	_FPUC21
.01a233	7a		ply				ply
.01a234	fa		plx				plx
.01a235	68		pla				pla
.01a236	60		rts				rts
.01a237					FPUSetInteger:
.01a237	48		pha				pha
.01a238	95 80		sta $80,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.01a23a	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.01a23c	10 02		bpl $01a240			bpl 	_FPUSIExtend
.01a23e	a9 ff		lda #$ff			lda 	#$FF
.01a240					_FPUSIExtend:
.01a240	95 81		sta $81,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.01a242	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a244	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a246	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.01a248	95 85		sta $85,x			sta 	XS_Type,x
.01a24a	68		pla				pla
.01a24b	60		rts				rts
.01a24c					FPUNegateInteger:
.01a24c	48		pha				pha
.01a24d	38		sec				sec
.01a24e	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.01a250	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.01a252	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a254	a9 00		lda #$00			lda 	#0
.01a256	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.01a258	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a25a	a9 00		lda #$00			lda 	#0
.01a25c	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.01a25e	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a260	a9 00		lda #$00			lda 	#0
.01a262	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.01a264	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a266	68		pla				pla
.01a267	60		rts				rts
.01a268					FPUToFloat:
.01a268	48		pha				pha
.01a269	b5 85		lda $85,x			lda 	XS_Type,x					; exit if already float.
.01a26b	29 0f		and #$0f			and 	#$0F
.01a26d	f0 24		beq $01a293			beq 	_FPUFExit
.01a26f	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.01a271	95 85		sta $85,x			sta 	XS_Type,x
.01a273	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.01a275	95 84		sta $84,x			sta 	XS_Exponent,x 				; x mantissa.
.01a277	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.01a279	10 07		bpl $01a282			bpl		_FPUFPositive
.01a27b	20 4c a2	jsr $01a24c			jsr 	FPUNegateInteger 			; negate the mantissa
.01a27e	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.01a280	95 85		sta $85,x			sta 	XS_Type,x
.01a282					_FPUFPositive:
.01a282	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.01a284	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.01a286	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01a288	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01a28a	d0 04		bne $01a290			bne 	_FPUFNonZero
.01a28c	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.01a28e	95 85		sta $85,x			sta 	XS_Type,x
.01a290					_FPUFNonZero:
.01a290	20 95 a2	jsr $01a295			jsr 	FPUNormalise 				; normalise the floating point.
.01a293					_FPUFExit:
.01a293	68		pla				pla
.01a294	60		rts				rts
.01a295					FPUNormalise:
.01a295	48		pha				pha
.01a296	34 85		bit $85,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.01a298	70 18		bvs $01a2b2			bvs 	_FPUNExit
.01a29a	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.01a29c	f0 10		beq $01a2ae			beq 	_FPUNSetZero
.01a29e					_FPUNLoop:
.01a29e	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.01a2a0	30 10		bmi $01a2b2			bmi 	_FPUNExit 					; if so, we are normalised.
.01a2a2	16 80		asl $80,x			asl 	0+XS_Mantissa+0,x
.01a2a4	36 81		rol $81,x			rol 	1+XS_Mantissa+0,x
.01a2a6	36 82		rol $82,x			rol 	2+XS_Mantissa+0,x
.01a2a8	36 83		rol $83,x			rol 	3+XS_Mantissa+0,x
.01a2aa	d6 84		dec $84,x			dec 	XS_Exponent,x 				; decrement exponent
.01a2ac	d0 f0		bne $01a29e			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.01a2ae					_FPUNSetZero:
.01a2ae	a9 40		lda #$40			lda 	#$40
.01a2b0	95 85		sta $85,x			sta 	XS_Type,x 					; the result is now zero.
.01a2b2					_FPUNExit:
.01a2b2	68		pla				pla
.01a2b3	60		rts				rts
.01a2b4					FPUToInteger:
.01a2b4	48		pha				pha
.01a2b5	b5 85		lda $85,x			lda 	XS_Type,x 					; if already integer, exit
.01a2b7	29 01		and #$01			and 	#1
.01a2b9	d0 31		bne $01a2ec			bne 	_FPUTOI_Exit
.01a2bb	34 85		bit $85,x			bit 	XS_Type,x					; if zero, return zero.
.01a2bd	70 23		bvs $01a2e2			bvs 	_FPUTOI_Zero
.01a2bf	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.01a2c1	10 1f		bpl $01a2e2			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.01a2c3	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.01a2c5	b0 2b		bcs $01a2f2			bcs 	FP_Overflow
.01a2c7					_FPUToIToInteger:
.01a2c7	b5 84		lda $84,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.01a2c9	c9 a0		cmp #$a0			cmp 	#128+32
.01a2cb	f0 0c		beq $01a2d9			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.01a2cd	f6 84		inc $84,x			inc 	XS_Exponent,X 				; increment Exponent
.01a2cf	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.01a2d1	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a2d3	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a2d5	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a2d7	80 ee		bra $01a2c7			bra 	_FPUToIToInteger 			; keep going.
.01a2d9					_FPUToICheckSign:
.01a2d9	b5 85		lda $85,x			lda 	XS_Type,x 					; check sign
.01a2db	10 0f		bpl $01a2ec			bpl 	_FPUToI_Exit 				; exit if unsigned.
.01a2dd	20 4c a2	jsr $01a24c			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.01a2e0	80 0a		bra $01a2ec			bra 	_FPUTOI_Exit
.01a2e2					_FPUTOI_Zero:
.01a2e2	a9 00		lda #$00			lda 	#0 							; return zero integer.
.01a2e4	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a2e6	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a2e8	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a2ea	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a2ec					_FPUToI_Exit:
.01a2ec	a9 01		lda #$01			lda 	#1 							; set type to integer
.01a2ee	95 85		sta $85,x			sta 	XS_Type,x
.01a2f0	68		pla				pla
.01a2f1	60		rts				rts
.01a2f2					FP_Overflow:
.01a2f2	20 79 85	jsr $018579			jsr ERR_Handler
>01a2f5	46 6c 6f 61 74 69 6e 67			.text "Floating Point overflow",0
>01a2fd	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.01a30d					FPUTimes10:
.01a30d	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.01a30f	85 1a		sta $1a				sta 	ZLTemp1+0
.01a311	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a313	85 1b		sta $1b				sta 	ZLTemp1+1
.01a315	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a317	85 1c		sta $1c				sta 	ZLTemp1+2
.01a319	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a31b	85 1d		sta $1d				sta 	ZLTemp1+3
.01a31d	20 52 a3	jsr $01a352			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.01a320	20 52 a3	jsr $01a352			jsr 	_FPUT_LSR_ZLTemp1
.01a323	18		clc				clc
.01a324	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.01a326	65 1a		adc $1a				adc 	ZLTemp1+0
.01a328	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a32a	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a32c	65 1b		adc $1b				adc 	ZLTemp1+1
.01a32e	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a330	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a332	65 1c		adc $1c				adc 	ZLTemp1+2
.01a334	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a336	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a338	65 1d		adc $1d				adc 	ZLTemp1+3
.01a33a	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a33c	90 0a		bcc $01a348			bcc 	_FPUTimes10
.01a33e	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.01a340	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a342	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a344	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a346	f6 84		inc $84,x			inc 	XS_Exponent,x				; fix exponent
.01a348					_FPUTimes10:
.01a348	b5 84		lda $84,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.01a34a	18		clc				clc
.01a34b	69 03		adc #$03			adc 	#3
.01a34d	95 84		sta $84,x			sta 	XS_Exponent,x
.01a34f	b0 a1		bcs $01a2f2			bcs 	FP_Overflow 				; error
.01a351	60		rts				rts
.01a352					_FPUT_LSR_ZLTemp1:
.01a352	46 1d		lsr $1d				lsr 	ZLTemp1+3
.01a354	66 1c		ror $1c				ror 	ZLTemp1+2
.01a356	66 1b		ror $1b				ror 	ZLTemp1+1
.01a358	66 1a		ror $1a				ror 	ZLTemp1+0
.01a35a	60		rts				rts
.01a35b					FPUScale10A:
.01a35b	5a		phy				phy
.01a35c	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.01a35e	f0 37		beq $01a397			beq 	_FPUScaleExit
.01a360	da		phx				phx 								; save X
.01a361	e8		inx				inx
.01a362	e8		inx				inx
.01a363	e8		inx				inx
.01a364	e8		inx				inx
.01a365	e8		inx				inx
.01a366	e8		inx				inx
.01a367	a8		tay				tay 								; save power scalar in Y.
.01a368	a9 00		lda #$00			lda 	#0
.01a36a	95 80		sta $80,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.01a36c	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a36e	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a370	95 85		sta $85,x			sta 	XS_Type,x
.01a372	a9 80		lda #$80			lda 	#$80
.01a374	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a376	a9 81		lda #$81			lda 	#$81
.01a378	95 84		sta $84,x			sta 	XS_Exponent,x
.01a37a	5a		phy				phy 								; save 10^n on stack.
.01a37b	c0 00		cpy #$00			cpy 	#0
.01a37d	10 05		bpl $01a384			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.01a37f	98		tya				tya
.01a380	49 ff		eor #$ff			eor 	#$FF
.01a382	1a		inc a				inc 	a
.01a383	a8		tay				tay
.01a384					_FPUSAbs:
.01a384	20 0d a3	jsr $01a30d			jsr 	FPUTimes10
.01a387	88		dey				dey
.01a388	d0 fa		bne $01a384			bne 	_FPUSAbs 					; tos is now 10^|AC|
.01a38a	68		pla				pla 								; restore count in A
.01a38b	fa		plx				plx 								; restore X pointing to number to scale.
.01a38c	0a		asl a				asl 	a
.01a38d	b0 05		bcs $01a394			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.01a38f	20 af a0	jsr $01a0af			jsr 	FPMultiply 					; if clear multiply.
.01a392	80 03		bra $01a397			bra		_FPUScaleExit
.01a394					_FPUSDivide:
.01a394	20 3c a0	jsr $01a03c			jsr 	FPDivide
.01a397					_FPUScaleExit:
.01a397	7a		ply				ply
.01a398	60		rts				rts
.01a399					FPUCopyToNext:
.01a399	a0 06		ldy #$06			ldy 		#6
.01a39b	da		phx				phx
.01a39c					_FPUCopy1:
.01a39c	b5 80		lda $80,x			lda 	XS_Mantissa,x
.01a39e	95 86		sta $86,x			sta 	XS2_Mantissa,x
.01a3a0	e8		inx				inx
.01a3a1	88		dey				dey
.01a3a2	d0 f8		bne $01a39c			bne 	_FPUCopy1
.01a3a4	fa		plx				plx
.01a3a5	60		rts				rts
.01a3a6					FPUCopyFromNext:
.01a3a6	a0 06		ldy #$06			ldy 		#6
.01a3a8	da		phx				phx
.01a3a9					_FPUCopy1:
.01a3a9	b5 86		lda $86,x			lda 	XS2_Mantissa,x
.01a3ab	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a3ad	e8		inx				inx
.01a3ae	88		dey				dey
.01a3af	d0 f8		bne $01a3a9			bne 	_FPUCopy1
.01a3b1	fa		plx				plx
.01a3b2	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.01a3b3					FPToString:
.01a3b3	48		pha				pha
.01a3b4	5a		phy				phy
.01a3b5	34 85		bit $85,x			bit 		XS_Type,x 				; check zero flag
.01a3b7	50 0a		bvc $01a3c3			bvc 		_FPTSIsFloat 			; if zero,
.01a3b9					_FPTSZero:
.01a3b9	a9 30		lda #$30			lda 		#"0"
.01a3bb	20 dd 9e	jsr $019edd			jsr 		ITSOutputCharacter
.01a3be					_FPTSExit:
.01a3be	7a		ply				ply
.01a3bf	68		pla				pla
.01a3c0	60		rts				rts
.01a3c1	80 fb		bra $01a3be			bra 		_FPTSExit
.01a3c3					_FPTSIsFloat:
.01a3c3	b5 85		lda $85,x			lda 		XS_Type,x 				; is it signed ?
.01a3c5	10 09		bpl $01a3d0			bpl 		_FPTSNotSigned
.01a3c7	a9 00		lda #$00			lda 		#0 						; clear sign flag
.01a3c9	95 85		sta $85,x			sta 		XS_Type,x
.01a3cb	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.01a3cd	20 dd 9e	jsr $019edd			jsr 		ITSOutputCharacter
.01a3d0					_FPTSNotSigned:
.01a3d0	b5 84		lda $84,x			lda 		XS_Exponent,x
.01a3d2	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.01a3d4	b0 09		bcs $01a3df			bcs 		_FPTSExponent
.01a3d6	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.01a3d8	90 05		bcc $01a3df			bcc 		_FPTSExponent 			;
.01a3da					_FPTSStandard:
.01a3da	20 1e a4	jsr $01a41e			jsr 		FPTOutputBody 			; output the body.
.01a3dd	80 df		bra $01a3be			bra 		_FPTSExit
.01a3df					_FPTSExponent:
.01a3df	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.01a3e1	8d 9d 03	sta $039d			sta 		ExpCount
.01a3e4					_FPTSExponentLoop:
.01a3e4	b5 84		lda $84,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.01a3e6	10 0e		bpl $01a3f6			bpl 		_FPTSTimes
.01a3e8	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.01a3ea	90 14		bcc $01a400			bcc 		_FPTSScaledToExp
.01a3ec	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.01a3ee	20 5b a3	jsr $01a35b			jsr 		FPUScale10A
.01a3f1	ee 9d 03	inc $039d			inc 		ExpCount
.01a3f4	80 ee		bra $01a3e4			bra 		_FPTSExponentLoop
.01a3f6					_FPTSTimes:
.01a3f6	a9 01		lda #$01			lda 		#1
.01a3f8	20 5b a3	jsr $01a35b			jsr 		FPUScale10A
.01a3fb	ce 9d 03	dec $039d			dec 		ExpCount
.01a3fe	80 e4		bra $01a3e4			bra 		_FPTSExponentLoop
.01a400					_FPTSScaledToExp:
.01a400	20 1e a4	jsr $01a41e			jsr 		FPTOutputBody 			; output the body.
.01a403	a9 65		lda #$65			lda 		#"e"					; output E
.01a405	20 dd 9e	jsr $019edd			jsr 		ITSOutputCharacter
.01a408	ad 9d 03	lda $039d			lda 		ExpCount 				; get the exponent
.01a40b	95 80		sta $80,x			sta 		XS_Mantissa,x
.01a40d	29 80		and #$80			and 		#$80 					; sign extend it
.01a40f	f0 02		beq $01a413			beq 		_FPTSSExt
.01a411	a9 ff		lda #$ff			lda 		#$FF
.01a413					_FPTSSExt:
.01a413	95 81		sta $81,x			sta 		XS_Mantissa+1,x
.01a415	95 82		sta $82,x			sta 		XS_Mantissa+2,x
.01a417	95 83		sta $83,x			sta 		XS_Mantissa+3,x
.01a419	20 3b 9e	jsr $019e3b			jsr 		INTToString 			; output the exponent.
.01a41c	80 a0		bra $01a3be			bra			_FPTSExit 				; and exit.
.01a41e					FPTOutputBody:
.01a41e	20 99 a3	jsr $01a399			jsr 		FPUCopyToNext 			; copy to next slot.
.01a421	20 b4 a2	jsr $01a2b4			jsr 		FPUToInteger 			; convert to an integer
.01a424	20 3b 9e	jsr $019e3b			jsr 		INTToString 			; output the main integer part.
.01a427	20 a6 a3	jsr $01a3a6			jsr 		FPUCopyFromNext 		; get the fractional part back.
.01a42a	20 37 a1	jsr $01a137			jsr 		FPFractionalPart 		; get the decimal part.
.01a42d	34 85		bit $85,x			bit 		XS_Type,x 				; any fractional part.
.01a42f	70 3c		bvs $01a46d			bvs 		_FPTOExit 				; if not, exit now.
.01a431	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.01a433	20 dd 9e	jsr $019edd			jsr 		ITSOutputCharacter
.01a436					_FPOutLoop:
.01a436	34 85		bit $85,x			bit 		XS_Type,x 				; finally reached zero.
.01a438	70 1d		bvs $01a457			bvs 		_FPStripZeros 			; strip trailing zeros
.01a43a	20 0d a3	jsr $01a30d			jsr 		FPUTimes10 				; multiply by 10
.01a43d	20 99 a3	jsr $01a399			jsr 		FPUCopyToNext			; copy to next slot.
.01a440	20 b4 a2	jsr $01a2b4			jsr 		FPUToInteger 			; convert to integer
.01a443	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; print digit.
.01a445	09 30		ora #$30			ora 		#"0"
.01a447	20 dd 9e	jsr $019edd			jsr 		ITSOutputCharacter
.01a44a	20 a6 a3	jsr $01a3a6			jsr 		FPUCopyFromNext 		; get it back
.01a44d	20 37 a1	jsr $01a137			jsr 		FPFractionalPart 		; get fractional part
.01a450	ad 14 03	lda $0314			lda 		NumBufX 				; done 11 characters yet ?
.01a453	c9 0b		cmp #$0b			cmp 	 	#11
.01a455	90 df		bcc $01a436			bcc 		_FPOutLoop 				; if so, keep going till zero.
.01a457					_FPStripZeros:
.01a457	ac 14 03	ldy $0314			ldy 		NumBufX 				; strip trailing zeros.
.01a45a					_FPStripLoop:
.01a45a	88		dey				dey 								; back one, if at start then no strip
.01a45b	f0 10		beq $01a46d			beq 		_FPToExit
.01a45d	b9 15 03	lda $0315,y			lda 		Num_Buffer,y 			; keep going if "0"
.01a460	c9 30		cmp #$30			cmp 		#"0"
.01a462	f0 f6		beq $01a45a			beq 		_FPStripLoop
.01a464	c8		iny				iny
.01a465	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.01a467	99 15 03	sta $0315,y			sta 		Num_Buffer,y
.01a46a	8c 14 03	sty $0314			sty 		NumBufX 				; update position.
.01a46d					_FPTOExit:
.01a46d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.01a46e					FPFromString:
.01a46e	48		pha				pha 								; push A
.01a46f	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.01a471	c9 2e		cmp #$2e			cmp 	#"."
.01a473	f0 03		beq $01a478			beq	 	_FPFIsDecimal
.01a475	4c d4 a4	jmp $01a4d4			jmp 	_FPFNotDecimal
.01a478					_FPFIsDecimal:
.01a478	c8		iny				iny 								; consume the decimal.
.01a479	20 68 a2	jsr $01a268			jsr 	FPUToFloat 					; convert the integer to float.
.01a47c	da		phx				phx 								; save X.
.01a47d	5a		phy				phy 								; save decimal start position
.01a47e	e8		inx				inx
.01a47f	e8		inx				inx
.01a480	e8		inx				inx
.01a481	e8		inx				inx
.01a482	e8		inx				inx
.01a483	e8		inx				inx
.01a484	20 f5 9e	jsr $019ef5			jsr 	INTFromStringY 				; get the part after the DP.
.01a487	20 68 a2	jsr $01a268			jsr 	FPUToFloat 					; convert that to a float.
.01a48a	68		pla				pla 								; calculate - chars consumed.
.01a48b	8c 9c 03	sty $039c			sty 	ExpTemp
.01a48e	38		sec				sec
.01a48f	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; this is the shift amount
.01a492	20 5b a3	jsr $01a35b			jsr 	FPUScale10A 				; scale it by 10^AC
.01a495	fa		plx				plx 								; restore original X
.01a496	20 88 9f	jsr $019f88			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.01a499	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.01a49b	c9 45		cmp #$45			cmp 	#"E"
.01a49d	f0 04		beq $01a4a3			beq 	_FPFExponent
.01a49f	c9 65		cmp #$65			cmp 	#"e"
.01a4a1	d0 31		bne $01a4d4			bne 	_FPFNotDecimal 				; no, then exit normally.
.01a4a3					_FPFExponent:
.01a4a3	c8		iny				iny 								; skip over E symbol.
.01a4a4	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.01a4a6	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.01a4a8	d0 01		bne $01a4ab			bne 	_FPFGotSign
.01a4aa	c8		iny				iny 								; if it was - skip over it.
.01a4ab					_FPFGotSign:
.01a4ab	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.01a4ac	da		phx				phx
.01a4ad	e8		inx				inx
.01a4ae	e8		inx				inx
.01a4af	e8		inx				inx
.01a4b0	e8		inx				inx
.01a4b1	e8		inx				inx
.01a4b2	e8		inx				inx
.01a4b3	20 f5 9e	jsr $019ef5			jsr 	INTFromStringY 				; get the exponent
.01a4b6	fa		plx				plx 								; restore X.
.01a4b7	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.01a4b9	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.01a4bb	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.01a4bd	d0 17		bne $01a4d6			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.01a4bf	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.01a4c1	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.01a4c3	b0 11		bcs $01a4d6			bcs 	_FPFXOverflow
.01a4c5	68		pla				pla 								; get direction
.01a4c6	d0 07		bne $01a4cf			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.01a4c8	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.01a4ca	49 ff		eor #$ff			eor 	#$FF
.01a4cc	1a		inc a				inc 	a
.01a4cd	95 86		sta $86,x			sta 	XS2_Mantissa+0,x
.01a4cf					_FPFXScale:
.01a4cf	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.01a4d1	20 5b a3	jsr $01a35b			jsr 	FPUScale10A 				; scale by the exponent.
.01a4d4					_FPFNotDecimal:
.01a4d4	68		pla				pla
.01a4d5	60		rts				rts
.01a4d6					_FPFXOverflow:
.01a4d6	20 79 85	jsr $018579			jsr 	ERR_Handler
>01a4d9	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>01a4e1	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.01a4e8					Unary_Rnd:
.01a4e8	20 58 92	jsr $019258			jsr 	EvaluateNumberX 			; get value
.01a4eb	20 ab 98	jsr $0198ab			jsr 	CheckNextRParen 			; check right bracket.
.01a4ee	20 d8 94	jsr $0194d8			jsr 	GetSignCurrent 				; get sign -1,0,1.
.01a4f1	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.01a4f3	30 10		bmi $01a505			bmi 	_URSetSeed
.01a4f5	f0 28		beq $01a51f			beq 	_URMakeRandom 				; if zero return same number, don't advance sequence
.01a4f7	da		phx				phx
.01a4f8	a2 00		ldx #$00			ldx 	#0 							; run 16 bit RNG procession on upper/lower
.01a4fa	20 56 a5	jsr $01a556			jsr 	Random16
.01a4fd	a2 02		ldx #$02			ldx 	#2
.01a4ff	20 56 a5	jsr $01a556			jsr 	Random16
.01a502	fa		plx				plx
.01a503	80 1a		bra $01a51f			bra 	_URMakeRandom
.01a505					_URSetSeed:
.01a505	20 68 a2	jsr $01a268			jsr 	FPUToFloat 					; make it a float to twiddle it.
.01a508	b5 80		lda $80,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.01a50a	8d a3 03	sta $03a3			sta 	RandomSeed+0
.01a50d	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.01a50f	8d a4 03	sta $03a4			sta 	RandomSeed+1
.01a512	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.01a514	8d a5 03	sta $03a5			sta 	RandomSeed+2
.01a517	b5 83		lda $83,x			lda		XS_Mantissa+3,x 			; this is to make the seed bear not much
.01a519	0a		asl a				asl 	a 							; resemblance to the seed value.
.01a51a	49 db		eor #$db			eor 	#$DB
.01a51c	8d a6 03	sta $03a6			sta 	RandomSeed+3
.01a51f					_URMakeRandom:
.01a51f	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; check if seed is zero.
.01a522	0d a4 03	ora $03a4			ora 	RandomSeed+1
.01a525	0d a5 03	ora $03a5			ora 	RandomSeed+2
.01a528	0d a6 03	ora $03a6			ora 	RandomSeed+3
.01a52b	d0 0a		bne $01a537			bne 	_URNotZero
.01a52d	a9 47		lda #$47			lda 	#$47						; if it is, make it non zero.
.01a52f	8d a4 03	sta $03a4			sta 	RandomSeed+1				; in both parts.
.01a532	a9 3d		lda #$3d			lda 	#$3D
.01a534	8d a6 03	sta $03a6			sta 	RandomSeed+3
.01a537					_URNotZero:
.01a537	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; copy seed into mantissa.
.01a53a	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a53c	ad a4 03	lda $03a4			lda 	RandomSeed+1
.01a53f	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a541	ad a5 03	lda $03a5			lda 	RandomSeed+2
.01a544	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a546	ad a6 03	lda $03a6			lda 	RandomSeed+3
.01a549	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a54b	a9 00		lda #$00			lda 	#$00 						; set type to float.
.01a54d	95 85		sta $85,x			sta 	XS_Type,x
.01a54f	a9 80		lda #$80			lda 	#$80
.01a551	95 84		sta $84,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.01a553	4c 95 a2	jmp $01a295			jmp 	FPUNormalise 				; and normalise.
.01a556					Random16:
.01a556	5e a4 03	lsr $03a4,x			lsr 	RandomSeed+1,x				; shift seed right
.01a559	7e a3 03	ror $03a3,x			ror 	RandomSeed,x
.01a55c	90 08		bcc $01a566			bcc 	_R16_NoXor
.01a55e	bd a4 03	lda $03a4,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.01a561	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.01a563	9d a4 03	sta $03a4,x			sta 	RandomSeed+1,x
.01a566					_R16_NoXor:
.01a566	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.01a567					Unary_Int:
.01a567	20 58 92	jsr $019258			jsr 	EvaluateNumberX 			; get value
.01a56a	20 ab 98	jsr $0198ab			jsr 	CheckNextRParen 			; check right bracket.
.01a56d	4c b4 a2	jmp $01a2b4			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Return to file: basic.asm

>01a570	02						.byte 	2
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 c0						.word 	StartROM
>fffe	19 c0					.word TIM_BreakHandler

;******  End of listing
