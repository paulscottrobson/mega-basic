
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Thu Aug 22 17:11:26 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="65816"				cpu = "65816"
="em65816"				hardware = "em65816"
=0					hasFloat = 0
=1					hasInteger = 1
=253					maxString = 253

;******  Processing file: modules/basic/pointer/em65816/src_em65816.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0020					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0200					IFT_XCursor:.byte ?							; current logical position on screen
>0201					IFT_YCursor:.byte ?
>0202					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0266					IFT_LineBuffer: .fill 100 					; line input buffer.
>0300					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>0304					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>0305					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=774					XS2_Mantissa = XS_Mantissa+XS_Size
=778					XS2_Exponent = XS_Exponent+XS_Size
=779					XS2_Type = XS_Type+XS_Size
=780					XS3_Mantissa = XS_Mantissa+XS_Size*2
=784					XS3_Exponent = XS_Exponent+XS_Size*2
=785					XS3_Type = XS_Type+XS_Size*2
>0400					Num_Buffer	.fill 	32 						; buffer for numeric conversions
>0420					NumBufX 	.byte 	?						; buffer index position
>0421					NumSuppress	.byte 	?						; leading zero suppression flag
>0422					NumConvCount .byte 	? 						; count for conversions.
>0423					ExpTemp:	.byte ?							; Working temp for exponents.
>0424					ExpCount:	.byte ? 						; Count of decimal exponents.
>0425					SignCount:	.byte ?							; Integer Divide Sign Counts.
>0426					StringPtr:	.byte ? 						; Top of free memory (for string allocation)
>0427					TempStringWriteIndex: .byte ? 				; Write offset.
>0428					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>042a					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>042c					Tim_SR:		.byte ? 						; Processor Status
>042d					Tim_A:		.byte ? 						; Processor Registers
>042e					Tim_X:		.byte ?
>042f					Tim_Y:		.byte ?
>0430					Tim_Z:		.byte ?
>0431					Tim_SP:		.byte ?							; Stack Pointer

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/em65816.asm

=$8000					HighMemory = $8000
.1000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testcode.src

>1000	10 0a 00 d8 9a 8b 6a bb			.byte	$10,$0a,$00,$d8,$9a,$8b,$6a,$bb
>1008	bd ff 06 68 69 20 21 00			.byte	$bd,$ff,$06,$68,$69,$20,$21,$00
>1010	00					.byte	$00

;******  Return to file: modules/hardware/em65816.asm


;******  Processing file: modules/hardware/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b3					lastUnaryFunction = $b3
.c000					VectorTable:
>c000	a7 c5					.word BinaryOp_And         ; $80 and
>c002	cf c5					.word BinaryOp_Or          ; $81 or
>c004	f7 c5					.word BinaryOp_Xor         ; $82 xor
>c006	f7 c5					.word BinaryOp_Eor         ; $83 eor
>c008	37 c6					.word Binary_Equal         ; $84 =
>c00a	56 c6					.word Binary_NotEqual      ; $85 <>
>c00c	5f c6					.word Binary_Less          ; $86 <
>c00e	68 c6					.word Binary_LessEqual     ; $87 <=
>c010	7a c6					.word Binary_Greater       ; $88 >
>c012	71 c6					.word Binary_GreaterEqual  ; $89 >=
>c014	00 c7					.word BinaryOp_Add         ; $8a +
>c016	11 c7					.word BinaryOp_Subtract    ; $8b -
>c018	15 c7					.word BinaryOp_Multiply    ; $8c *
>c01a	19 c7					.word BinaryOp_Divide      ; $8d /
>c01c	b0 c0					.word NotImplemented       ; $8e ^
>c01e	b0 c0					.word NotImplemented       ; $8f if
>c020	b0 c0					.word NotImplemented       ; $90 while
>c022	b0 c0					.word NotImplemented       ; $91 repeat
>c024	b0 c0					.word NotImplemented       ; $92 for
>c026	b0 c0					.word NotImplemented       ; $93 then
>c028	b0 c0					.word NotImplemented       ; $94 endif
>c02a	b0 c0					.word NotImplemented       ; $95 wend
>c02c	b0 c0					.word NotImplemented       ; $96 until
>c02e	b0 c0					.word NotImplemented       ; $97 next
>c030	b0 c0					.word NotImplemented       ; $98 not
>c032	b0 c0					.word NotImplemented       ; $99 fn(
>c034	29 c8					.word Unary_Abs            ; $9a abs(
>c036	47 c8					.word Unary_Asc            ; $9b asc(
>c038	b0 c0					.word NotImplemented       ; $9c int(
>c03a	b0 c0					.word NotImplemented       ; $9d peek(
>c03c	b0 c0					.word NotImplemented       ; $9e rnd(
>c03e	b0 c0					.word NotImplemented       ; $9f usr(
>c040	b0 c0					.word NotImplemented       ; $a0 left$(
>c042	b0 c0					.word NotImplemented       ; $a1 right$(
>c044	b0 c0					.word NotImplemented       ; $a2 mid$(
>c046	b0 c0					.word NotImplemented       ; $a3 spc(
>c048	b0 c0					.word NotImplemented       ; $a4 str$(
>c04a	b0 c0					.word NotImplemented       ; $a5 val(
>c04c	5d c8					.word Unary_Len            ; $a6 len(
>c04e	b0 c0					.word NotImplemented       ; $a7 hex$(
>c050	b0 c0					.word NotImplemented       ; $a8 sin(
>c052	b0 c0					.word NotImplemented       ; $a9 cos(
>c054	b0 c0					.word NotImplemented       ; $aa tan(
>c056	b0 c0					.word NotImplemented       ; $ab atn(
>c058	b0 c0					.word NotImplemented       ; $ac exp(
>c05a	b0 c0					.word NotImplemented       ; $ad log(
>c05c	b0 c0					.word NotImplemented       ; $ae sqr(
>c05e	b0 c0					.word NotImplemented       ; $af dec(
>c060	b0 c0					.word NotImplemented       ; $b0 deek(
>c062	b0 c0					.word NotImplemented       ; $b1 leek(
>c064	b0 c0					.word NotImplemented       ; $b2 mod(
>c066	d7 c7					.word Unary_Sgn            ; $b3 sgn(
>c068	b0 c0					.word NotImplemented       ; $b4 $(
>c06a	b0 c0					.word NotImplemented       ; $b5 $
>c06c	b0 c0					.word NotImplemented       ; $b6 #(
>c06e	b0 c0					.word NotImplemented       ; $b7 #
>c070	b0 c0					.word NotImplemented       ; $b8 %(
>c072	b0 c0					.word NotImplemented       ; $b9 %
>c074	b0 c0					.word NotImplemented       ; $ba (
>c076	b0 c0					.word NotImplemented       ; $bb )
>c078	b0 c0					.word NotImplemented       ; $bc ,
>c07a	b0 c0					.word NotImplemented       ; $bd :
>c07c	b0 c0					.word NotImplemented       ; $be ;
>c07e	b0 c0					.word NotImplemented       ; $bf def
>c080	11 c4					.word CLR_Command          ; $c0 clr
>c082	b0 c0					.word NotImplemented       ; $c2 data
>c084	b0 c0					.word NotImplemented       ; $c3 read
>c086	b0 c0					.word NotImplemented       ; $c4 dim
>c088	b0 c0					.word NotImplemented       ; $c5 to
>c08a	b0 c0					.word NotImplemented       ; $c6 step
>c08c	b0 c0					.word NotImplemented       ; $c7 gosub
>c08e	b0 c0					.word NotImplemented       ; $c8 return
>c090	b0 c0					.word NotImplemented       ; $c9 goto
>c092	b0 c0					.word NotImplemented       ; $ca input
>c094	b0 c0					.word NotImplemented       ; $cb let
>c096	b0 c0					.word NotImplemented       ; $cc list
>c098	b0 c0					.word NotImplemented       ; $cd new
>c09a	b0 c0					.word NotImplemented       ; $ce old
>c09c	b0 c0					.word NotImplemented       ; $cf on
>c09e	b0 c0					.word NotImplemented       ; $d0 restore
>c0a0	b0 c0					.word NotImplemented       ; $d1 poke
>c0a2	b0 c0					.word NotImplemented       ; $d2 print
>c0a4	b0 c0					.word NotImplemented       ; $d3 run
>c0a6	b0 c0					.word NotImplemented       ; $d4 stop
>c0a8	b0 c0					.word NotImplemented       ; $d5 wait
>c0aa	b0 c0					.word NotImplemented       ; $d6 doke
>c0ac	b0 c0					.word NotImplemented       ; $d7 loke
>c0ae	b0 c0					.word NotImplemented       ; $d8 assert
.c0b0					NotImplemented:
.c0b0	80 fe		bra $c0b0		_error: bra _error
.c0b2					BinaryPrecedence:
>c0b2	01					.byte 1    ; $80 and
>c0b3	01					.byte 1    ; $81 or
>c0b4	01					.byte 1    ; $82 xor
>c0b5	01					.byte 1    ; $83 eor
>c0b6	02					.byte 2    ; $84 =
>c0b7	02					.byte 2    ; $85 <>
>c0b8	02					.byte 2    ; $86 <
>c0b9	02					.byte 2    ; $87 <=
>c0ba	02					.byte 2    ; $88 >
>c0bb	02					.byte 2    ; $89 >=
>c0bc	03					.byte 3    ; $8a +
>c0bd	03					.byte 3    ; $8b -
>c0be	04					.byte 4    ; $8c *
>c0bf	04					.byte 4    ; $8d /
>c0c0	05					.byte 5    ; $8e ^
.c0c1					KeywordText:
>c0c1	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>c0c4	4f d2					.byte $4f,$d2                          ; $81 or
>c0c6	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>c0c9	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>c0cc	bd					.byte $bd                              ; $84 =
>c0cd	3c be					.byte $3c,$be                          ; $85 <>
>c0cf	bc					.byte $bc                              ; $86 <
>c0d0	3c bd					.byte $3c,$bd                          ; $87 <=
>c0d2	be					.byte $be                              ; $88 >
>c0d3	3e bd					.byte $3e,$bd                          ; $89 >=
>c0d5	ab					.byte $ab                              ; $8a +
>c0d6	ad					.byte $ad                              ; $8b -
>c0d7	aa					.byte $aa                              ; $8c *
>c0d8	af					.byte $af                              ; $8d /
>c0d9	de					.byte $de                              ; $8e ^
>c0da	49 c6					.byte $49,$c6                          ; $8f if
>c0dc	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>c0e1	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>c0e7	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>c0ea	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>c0ee	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>c0f3	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>c0f7	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>c0fc	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>c100	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>c103	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>c106	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>c10a	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>c10e	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>c112	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>c117	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>c11b	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>c11f	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>c125	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>c12c	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>c131	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>c135	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>c13a	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>c13e	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>c142	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>c147	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>c14b	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>c14f	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>c153	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>c157	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>c15b	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>c15f	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>c163	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>c167	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>c16c	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>c171	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>c175	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>c179	24 a8					.byte $24,$a8                          ; $b4 $(
>c17b	a4					.byte $a4                              ; $b5 $
>c17c	23 a8					.byte $23,$a8                          ; $b6 #(
>c17e	a3					.byte $a3                              ; $b7 #
>c17f	25 a8					.byte $25,$a8                          ; $b8 %(
>c181	a5					.byte $a5                              ; $b9 %
>c182	a8					.byte $a8                              ; $ba (
>c183	a9					.byte $a9                              ; $bb )
>c184	ac					.byte $ac                              ; $bc ,
>c185	ba					.byte $ba                              ; $bd :
>c186	bb					.byte $bb                              ; $be ;
>c187	44 45 c6				.byte $44,$45,$c6                      ; $bf def
>c18a	43 4c d2				.byte $43,$4c,$d2                      ; $c0 clr
>c18d	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c2 data
>c191	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c3 read
>c195	44 49 cd				.byte $44,$49,$cd                      ; $c4 dim
>c198	54 cf					.byte $54,$cf                          ; $c5 to
>c19a	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c6 step
>c19e	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $c7 gosub
>c1a3	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $c8 return
>c1a9	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $c9 goto
>c1ad	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $ca input
>c1b2	4c 45 d4				.byte $4c,$45,$d4                      ; $cb let
>c1b5	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $cc list
>c1b9	4e 45 d7				.byte $4e,$45,$d7                      ; $cd new
>c1bc	4f 4c c4				.byte $4f,$4c,$c4                      ; $ce old
>c1bf	4f ce					.byte $4f,$ce                          ; $cf on
>c1c1	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d0 restore
>c1c8	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d1 poke
>c1cc	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d2 print
>c1d1	52 55 ce				.byte $52,$55,$ce                      ; $d3 run
>c1d4	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $d4 stop
>c1d8	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d5 wait
>c1dc	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $d6 doke
>c1e0	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $d7 loke
>c1e4	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $d8 assert
>c1ea	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_dollarlparen = $b4
=$b5					token_dollar = $b5
=$b6					token_hashlparen = $b6
=$b7					token_hash = $b7
=$b8					token_percentlparen = $b8
=$b9					token_percent = $b9
=$ba					token_lparen = $ba
=$bb					token_rparen = $bb
=$bc					token_comma = $bc
=$bd					token_colon = $bd
=$be					token_semicolon = $be
=$bf					token_def = $bf
=$c0					token_clr = $c0
=$c2					token_data = $c2
=$c3					token_read = $c3
=$c4					token_dim = $c4
=$c5					token_to = $c5
=$c6					token_step = $c6
=$c7					token_gosub = $c7
=$c8					token_return = $c8
=$c9					token_goto = $c9
=$ca					token_input = $ca
=$cb					token_let = $cb
=$cc					token_list = $cc
=$cd					token_new = $cd
=$ce					token_old = $ce
=$cf					token_on = $cf
=$d0					token_restore = $d0
=$d1					token_poke = $d1
=$d2					token_print = $d2
=$d3					token_run = $d3
=$d4					token_stop = $d4
=$d5					token_wait = $d5
=$d6					token_doke = $d6
=$d7					token_loke = $d7
=$d8					token_assert = $d8

;******  Return to file: modules/hardware/em65816.asm

.c1eb					StartROM:
.c1eb	18		clc				clc
.c1ec	fb		xce				xce
.c1ed	c2 30		rep #$30			rep 	#$30
.c1ef	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.c1f2	1b		tcs				tcs
.c1f3	e2 30		sep #$30			sep 	#$30 						; clear AXY in 16 bit.
.c1f5	c2 30		rep #$30			rep 	#$30
.c1f7	a9 00 00	lda #$0000			lda 	#$0000
.c1fa	aa		tax				tax
.c1fb	a8		tay				tay
.c1fc	e2 30		sep #$30			sep 	#$30
.c1fe	20 a2 c3	jsr $c3a2			jsr 	IF_Reset 					; reset external interface
.c201	20 07 c2	jsr $c207			jsr 	IFT_ClearScreen
.c204	4c f1 c3	jmp $c3f1		jmp BASIC_Start

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.c207					IFT_ClearScreen:
.c207	48		pha				pha
.c208	da		phx				phx
.c209	5a		phy				phy
.c20a	20 a3 c3	jsr $c3a3			jsr 	IF_Home 					; home cursor
.c20d	a2 20		ldx #$20			ldx 	#IF_Height 					; this many lines.
.c20f					_IFT_CS0:
.c20f	a0 40		ldy #$40			ldy 	#IF_Width 					; this many chars/line
.c211					_IFT_CS1:
.c211	a9 20		lda #$20			lda 	#' '						; clear line.
.c213	20 cf c3	jsr $c3cf			jsr 	IF_Write
.c216	88		dey				dey
.c217	d0 f8		bne $c211			bne 	_IFT_CS1
.c219	20 b6 c3	jsr $c3b6			jsr 	IF_NewLine 					; next line down
.c21c	ca		dex				dex
.c21d	d0 f0		bne $c20f			bne 	_IFT_CS0
.c21f	7a		ply				ply
.c220	fa		plx				plx
.c221	68		pla				pla
.c222					IFT_HomeCursor:
.c222	48		pha				pha
.c223	20 a3 c3	jsr $c3a3			jsr 	IF_Home
.c226	a9 00		lda #$00			lda 	#0
.c228	8d 00 02	sta $0200			sta 	IFT_XCursor
.c22b	8d 01 02	sta $0201			sta 	IFT_YCursor
.c22e	68		pla				pla
.c22f	60		rts				rts
.c230					IFT_UpLine:
.c230	48		pha				pha
.c231	ad 01 02	lda $0201			lda  	IFT_YCursor 				; get Y
.c234	3a		dec a				dec 	a 							; line above
.c235	30 03		bmi $c23a			bmi 	_IFTULExit 					; too far, abort
.c237	20 c5 c2	jsr $c2c5			jsr 	IFT_SetYPos					; set to that line.
.c23a					_IFTULExit:
.c23a	68		pla				pla
.c23b	60		rts				rts
.c23c					IFT_PrintCharacter:
.c23c	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.c23e	f0 16		beq $c256			beq 	IFT_NewLine
.c240	48		pha				pha
.c241	20 6e c2	jsr $c26e			jsr 	IFT_UpperCase 				; make upper case
.c244	20 cf c3	jsr $c3cf			jsr 	IF_Write 					; write out.
.c247	ee 00 02	inc $0200			inc 	IFT_XCursor 				; bump x cursor
.c24a	ad 00 02	lda $0200			lda 	IFT_XCursor 				; reached RHS ?
.c24d	c9 40		cmp #$40			cmp 	#IF_Width
.c24f	d0 03		bne $c254			bne 	_IFT_PCNotEOL
.c251	20 56 c2	jsr $c256			jsr 	IFT_NewLine 				; if so do new line.
.c254					_IFT_PCNotEOL:
.c254	68		pla				pla
.c255	60		rts				rts
.c256					IFT_NewLine:
.c256	48		pha				pha
.c257	20 b6 c3	jsr $c3b6			jsr 	IF_NewLine 					; new line on actual screen.
.c25a	a9 00		lda #$00			lda 	#0 							; reset x position
.c25c	8d 00 02	sta $0200			sta 	IFT_XCursor
.c25f	ee 01 02	inc $0201			inc 	IFT_YCursor 				; move down.
.c262	ad 01 02	lda $0201			lda 	IFT_YCursor
.c265	c9 20		cmp #$20			cmp 	#IF_Height 					; reached bottom.
.c267	d0 03		bne $c26c			bne 	_IFT_NL_NotEOS
.c269	20 79 c2	jsr $c279			jsr 	IFT_Scroll 					; scroll screen up.
.c26c					_IFT_NL_NotEOS:
.c26c	68		pla				pla
.c26d	60		rts				rts
.c26e					IFT_UpperCase:
.c26e	c9 61		cmp #$61			cmp 	#"a"
.c270	90 06		bcc $c278			bcc 	_IFT_UCExit
.c272	c9 7b		cmp #$7b			cmp 	#"z"+1
.c274	b0 02		bcs $c278			bcs 	_IFT_UCExit
.c276	49 20		eor #$20			eor 	#$20
.c278					_IFT_UCExit:
.c278	60		rts				rts
.c279					IFT_Scroll:
.c279	48		pha				pha 								; save AXY
.c27a	da		phx				phx
.c27b	5a		phy				phy
.c27c	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.c27e					_IFT_SLoop:
.c27e	20 9e c2	jsr $c29e			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.c281	e8		inx				inx
.c282	e0 1f		cpx #$1f			cpx 	#IF_Height-1				; do whole screen
.c284	d0 f8		bne $c27e			bne 	_IFT_SLoop
.c286	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.c288	20 c5 c2	jsr $c2c5			jsr 	IFT_SetYPos
.c28b	a2 40		ldx #$40			ldx 	#IF_Width 					; blank line
.c28d					_IFT_SBlank:
.c28d	a9 20		lda #$20			lda 	#32
.c28f	20 cf c3	jsr $c3cf			jsr 	IF_Write
.c292	ca		dex				dex
.c293	d0 f8		bne $c28d			bne 	_IFT_SBlank
.c295	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.c297	20 c5 c2	jsr $c2c5			jsr 	IFT_SetYPos
.c29a	7a		ply				ply
.c29b	fa		plx				plx
.c29c	68		pla				pla
.c29d	60		rts				rts
.c29e					_IFT_ScrollLine:
.c29e	da		phx				phx
.c29f	da		phx				phx
.c2a0	8a		txa				txa 								; copy line into buffer.
.c2a1	1a		inc a				inc 	a 							; next line down.
.c2a2	20 c5 c2	jsr $c2c5			jsr 	IFT_SetYPos
.c2a5	a2 00		ldx #$00			ldx 	#0
.c2a7					_IFTScrollCopy1:
.c2a7	20 c6 c3	jsr $c3c6			jsr 	IF_Read
.c2aa	9d 02 02	sta $0202,x			sta 	IFT_Buffer,x
.c2ad	e8		inx				inx
.c2ae	e0 40		cpx #$40			cpx 	#IF_Width
.c2b0	d0 f5		bne $c2a7			bne 	_IFTScrollCopy1
.c2b2	68		pla				pla
.c2b3	20 c5 c2	jsr $c2c5			jsr 	IFT_SetYPos
.c2b6	a2 00		ldx #$00			ldx 	#0
.c2b8					_IFTScrollCopy2:
.c2b8	bd 02 02	lda $0202,x			lda 	IFT_Buffer,x
.c2bb	20 cf c3	jsr $c3cf			jsr 	IF_Write
.c2be	e8		inx				inx
.c2bf	e0 40		cpx #$40			cpx 	#IF_Width
.c2c1	d0 f5		bne $c2b8			bne 	_IFTScrollCopy2
.c2c3	fa		plx				plx
.c2c4	60		rts				rts
.c2c5					IFT_SetYPos:
.c2c5	48		pha				pha
.c2c6	da		phx				phx
.c2c7	aa		tax				tax
.c2c8	20 22 c2	jsr $c222			jsr 	IFT_HomeCursor
.c2cb	e0 00		cpx #$00			cpx 	#0
.c2cd	f0 09		beq $c2d8			beq 	_IFT_MOAExit
.c2cf					_IFT_MOALoop:
.c2cf	20 b6 c3	jsr $c3b6			jsr 	IF_NewLine
.c2d2	ee 01 02	inc $0201			inc 	IFT_YCursor
.c2d5	ca		dex				dex
.c2d6	d0 f7		bne $c2cf			bne		_IFT_MOALoop
.c2d8					_IFT_MOAExit:
.c2d8	fa		plx				plx
.c2d9	68		pla				pla
.c2da	60		rts				rts
.c2db					IFT_GetKeyCursor:
.c2db	20 e3 c2	jsr $c2e3			jsr 	_IFT_FlipCursor 			; reverse current
.c2de					_IFT_GKCWait:
.c2de	20 e0 c3	jsr $c3e0			jsr 	IF_GetKey 					; get key
.c2e1	f0 fb		beq $c2de			beq 	_IFT_GKCWait
.c2e3					_IFT_FlipCursor:
.c2e3	48		pha				pha 								; save
.c2e4	20 c6 c3	jsr $c3c6			jsr 	IF_Read 					; read
.c2e7	20 d8 c3	jsr $c3d8			jsr 	IF_LeftOne
.c2ea	49 80		eor #$80			eor 	#$80 						; reverse
.c2ec	20 cf c3	jsr $c3cf			jsr 	IF_Write 					; write
.c2ef	20 d8 c3	jsr $c3d8			jsr 	IF_LeftOne
.c2f2	68		pla				pla
.c2f3	60		rts				rts
.c2f4					IFT_ReadLine:
.c2f4	48		pha				pha
.c2f5					_IFT_RLLoop:
.c2f5	20 db c2	jsr $c2db			jsr 	IFT_GetKeyCursor 			; get keystroke
.c2f8	c9 0d		cmp #$0d			cmp 	#13							; return
.c2fa	f0 7d		beq $c379			beq 	_IFT_RLExit
.c2fc	c9 20		cmp #$20			cmp 	#32 						; control character
.c2fe	90 05		bcc $c305			bcc 	_IFT_Control
.c300	20 3c c2	jsr $c23c			jsr 	IFT_PrintCharacter
.c303	80 f0		bra $c2f5			bra 	_IFT_RLLoop
.c305					_IFT_Control:
.c305	c9 01		cmp #$01			cmp 	#"A"-64
.c307	f0 26		beq $c32f			beq 	_IFT_Left
.c309	c9 04		cmp #$04			cmp 	#"D"-64
.c30b	f0 2e		beq $c33b			beq 	_IFT_Right
.c30d	c9 17		cmp #$17			cmp 	#"W"-64
.c30f	f0 36		beq $c347			beq 	_IFT_Up
.c311	c9 13		cmp #$13			cmp 	#"S"-64
.c313	f0 3e		beq $c353			beq 	_IFT_Down
.c315	c9 08		cmp #$08			cmp 	#"H"-64
.c317	f0 09		beq $c322			beq 	_IFT_Backspace
.c319	c9 1a		cmp #$1a			cmp 	#"Z"-64
.c31b	d0 d8		bne $c2f5			bne 	_IFT_RLLoop
.c31d	20 07 c2	jsr $c207			jsr 	IFT_ClearScreen				; clear CTL-Z
.c320	80 d3		bra $c2f5			bra 	_IFT_RLLoop
.c322					_IFT_Backspace:
.c322	ad 00 02	lda $0200			lda 	IFT_XCursor 				; check not start of line.
.c325	f0 ce		beq $c2f5			beq 	_IFT_RLLoop
.c327	20 d8 c3	jsr $c3d8			jsr 	IF_LeftOne
.c32a	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.c32c	20 cf c3	jsr $c3cf			jsr 	IF_Write
.c32f					_IFT_Left:
.c32f	ce 00 02	dec $0200			dec 	IFT_XCursor 				; left CTL-W
.c332	10 29		bpl $c35d			bpl 	_IFT_Reposition
.c334	a9 3f		lda #$3f			lda 	#IF_Width-1
.c336					_IFT_SetX:
.c336	8d 00 02	sta $0200			sta 	IFT_XCursor
.c339	80 22		bra $c35d			bra 	_IFT_Reposition
.c33b					_IFT_Right:
.c33b	ee 00 02	inc $0200			inc 	IFT_XCursor
.c33e	ad 00 02	lda $0200			lda 	IFT_XCursor
.c341	49 40		eor #$40			eor 	#IF_Width
.c343	f0 f1		beq $c336			beq 	_IFT_SetX
.c345	80 16		bra $c35d			bra 	_IFT_Reposition
.c347					_IFT_Up:
.c347	ce 01 02	dec $0201			dec 	IFT_YCursor
.c34a	10 11		bpl $c35d			bpl 	_IFT_Reposition
.c34c	a9 1f		lda #$1f			lda 	#IF_Height-1
.c34e					_IFT_SetY:
.c34e	8d 01 02	sta $0201			sta 	IFT_YCursor
.c351	80 0a		bra $c35d			bra 	_IFT_Reposition
.c353					_IFT_Down:
.c353	ee 01 02	inc $0201			inc 	IFT_YCursor
.c356	ad 01 02	lda $0201			lda 	IFT_YCursor
.c359	49 20		eor #$20			eor 	#IF_Height
.c35b	f0 f1		beq $c34e			beq 	_IFT_SetY
.c35d					_IFT_Reposition:
.c35d	ad 00 02	lda $0200			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.c360	48		pha				pha
.c361	ad 01 02	lda $0201			lda 	IFT_YCursor
.c364	20 c5 c2	jsr $c2c5			jsr 	IFT_SetYPos
.c367	68		pla				pla
.c368	aa		tax				tax
.c369	e0 00		cpx #$00			cpx 	#0
.c36b	f0 88		beq $c2f5			beq 	_IFT_RLLoop
.c36d					_IFT_MoveRight:
.c36d	20 c6 c3	jsr $c3c6			jsr 	IF_Read
.c370	ee 00 02	inc $0200			inc 	IFT_XCursor
.c373	ca		dex				dex
.c374	d0 f7		bne $c36d			bne 	_IFT_MoveRight
.c376	4c f5 c2	jmp $c2f5			jmp 	_IFT_RLLoop
.c379					_IFT_RLExit:
.c379	ad 01 02	lda $0201			lda 	IFT_YCursor 				; go to start of line.
.c37c	20 c5 c2	jsr $c2c5			jsr 	IFT_SetYPos
.c37f	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.c381					_IFT_RLRead:
.c381	20 c6 c3	jsr $c3c6			jsr 	IF_Read
.c384	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.c387	e8		inx				inx
.c388	e0 40		cpx #$40			cpx 	#IF_Width
.c38a	d0 f5		bne $c381			bne 	_IFT_RLRead
.c38c					_IFT_RL_Trim:
.c38c	ca		dex				dex 	 							; previous char
.c38d	30 07		bmi $c396			bmi 	_IFT_Found 					; gone too far
.c38f	bd 66 02	lda $0266,x			lda 	IFT_LineBuffer,x			; go back if space
.c392	c9 20		cmp #$20			cmp 	#" "
.c394	f0 f6		beq $c38c			beq 	_IFT_RL_Trim
.c396					_IFT_Found:
.c396	e8		inx				inx 								; forward to non-space
.c397	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.c399	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.c39c	68		pla				pla
.c39d	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.c39f	a0 02		ldy #$02			ldy 	#IFT_LineBuffer >> 8
.c3a1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_em65816.asm

=64					IF_Width 	= 64 							; characters across
=32					IF_Height 	= 32 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line.
=8					IF_XPos 	= 8 							; current position, horizontal.
=$f0000					IF_Screen = $F0000							; 2k screen RAM here
=$f8010					IF_PKeyboard = $F8010						; Keyboard port.
=$f8000					IF_PBreak = $F8000 							; Break key.
.c3a2					IF_Reset:
.c3a2	60		rts				rts
.c3a3					IF_Home:
.c3a3	48		pha				pha
.c3a4	64 08		stz $08				stz 	IF_XPos 					; zero X position
.c3a6	a9 00		lda #$00			lda 	#IF_Screen & $FF 			; set r/w pos.
.c3a8	85 04		sta $04				sta 	IF_Pos
.c3aa	a9 00		lda #$00			lda 	#(IF_Screen >> 8) & $FF
.c3ac	85 05		sta $05				sta 	IF_Pos+1
.c3ae	a9 0f		lda #$0f			lda 	#IF_Screen >> 16
.c3b0	85 06		sta $06				sta 	IF_Pos+2
.c3b2	64 07		stz $07				stz 	IF_Pos+3
.c3b4	68		pla				pla
.c3b5	60		rts				rts
.c3b6					IF_NewLine:
.c3b6	48		pha				pha
.c3b7	64 08		stz $08				stz 	IF_XPos						; back to start of line
.c3b9	18		clc				clc 								; down one line
.c3ba	a5 04		lda $04				lda 	IF_Pos
.c3bc	69 40		adc #$40			adc 	#64
.c3be	85 04		sta $04				sta 	IF_Pos
.c3c0	90 02		bcc $c3c4			bcc 	_IF_NoCarry 				; carry through.
.c3c2	e6 05		inc $05				inc 	IF_Pos+1
.c3c4					_IF_NoCarry:
.c3c4	68		pla				pla
.c3c5	60		rts				rts
.c3c6					IF_Read:
.c3c6	5a		phy				phy 								; save current Y
.c3c7	a4 08		ldy $08				ldy 	IF_XPos 					; read character at current position
.c3c9	b7 04		lda [$04],y			lda 	[IF_Pos],y
.c3cb	e6 08		inc $08				inc 	IF_XPos 					; step right.
.c3cd	7a		ply				ply									; restore Y
.c3ce	60		rts				rts
.c3cf					IF_Write:
.c3cf	5a		phy				phy 								; save current Y
.c3d0	a4 08		ldy $08				ldy 	IF_XPos 					; write character at current position
.c3d2	97 04		sta [$04],y			sta 	[IF_Pos],y
.c3d4	e6 08		inc $08				inc 	IF_XPos 					; step right.
.c3d6	7a		ply				ply									; restore Y
.c3d7	60		rts				rts
.c3d8					IF_LeftOne:
.c3d8	c6 08		dec $08				dec 	IF_XPos
.c3da	60		rts				rts
.c3db					IF_CheckBreak:
.c3db	af 00 80 0f	lda $0f8000			lda 	IF_PBreak					; non-zero if Ctrl+C pressed.
.c3df	60		rts				rts
.c3e0					IF_GetKey:
.c3e0	af 10 80 0f	lda $0f8010			lda 	IF_PKeyboard				; read keyboard
.c3e4	f0 08		beq $c3ee			beq		_IFGK_NoKey 				; skip if zero,no key pressed
.c3e6	48		pha				pha 								; key pressed, clear queue.
.c3e7	a9 00		lda #$00			lda 	#0
.c3e9	8f 10 80 0f	sta $0f8010			sta 	IF_PKeyboard
.c3ed	68		pla				pla
.c3ee					_IFGK_NoKey:
.c3ee	09 00		ora #$00			ora 	#0							; set Z flag appropriately.
.c3f0	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm

.c3f1					BASIC_Start:
.c3f1	20 11 c4	jsr $c411			jsr 	ResetRunStatus 				; clear everything (CLR command)
.c3f4	a9 00		lda #$00			lda 	#0 							; mark temp string pointer uninitialised.
.c3f6	85 21		sta $21				sta 	zTempStr+1 					; (done before every base level evaluation/or command)
.c3f8	a9 00		lda #$00			lda 	#BasicProgram & $FF
.c3fa	85 16		sta $16				sta 	zCodePtr+0
.c3fc	a9 10		lda #$10			lda 	#BasicProgram >> 8
.c3fe	85 17		sta $17				sta 	zCodePtr+1
.c400	a9 00		lda #$00			lda 	#0
.c402	85 18		sta $18				sta 	zCodePtr+2
.c404	85 19		sta $19				sta 	zCodePtr+3
.c406	a0 03		ldy #$03			ldy 	#3
.c408	c8		iny				iny
.c409	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c40b	20 1f c4	jsr $c41f			jsr 	EvaluateExpression
>c40e	02						.byte 	2
.c40f					SyntaxError:
.c40f					ERR_Handler:
.c40f	80 fe		bra $c40f			bra 	ERR_Handler

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.c411					CLR_Command:
.c411					ResetRunStatus:
.c411	a9 00		lda #$00			lda 	#HighMemory & $FF
.c413	8d 26 04	sta $0426			sta 	StringPtr
.c416	a9 80		lda #$80			lda 	#HighMemory >> 8
.c418	8d 27 04	sta $0427			sta 	StringPtr+1
.c41b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.c41c					EVESyntax:
.c41c	4c 0f c4	jmp $c40f			jmp 	SyntaxError
.c41f					EvaluateExpression:
.c41f	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.c421					EvaluateExpressionX:
.c421	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.c423					EvaluateExpressionXA:
.c423	48		pha				pha 								; save precedence on stack.
.c424	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c426	f0 f4		beq $c41c			beq 	EVESyntax 					; end of line, syntax error.
.c428	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.c42a	b0 03		bcs $c42f			bcs 	_EVNotVariable
.c42c	4c 14 c5	jmp $c514			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.c42f					_EVNotVariable:
.c42f	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.c431	90 e9		bcc $c41c			bcc 	EVESyntax
.c433	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.c435	b0 7b		bcs $c4b2			bcs 	_EVNotInteger
.c437	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.c439	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.c43c	a9 00		lda #$00			lda 	#0
.c43e	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c441	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c444	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c447	a9 01		lda #$01			lda 	#1 							; set to type 1 (integer)
.c449	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c44c					_EVCheckNextInteger:
.c44c	c8		iny				iny
.c44d	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c44f	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.c451	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.c453	b0 0d		bcs $c462			bcs 	_EVCheckDecimal
.c455	48		pha				pha 								; save it.
.c456	20 18 c5	jsr $c518			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.c459	68		pla				pla
.c45a	1d 00 03	ora $0300,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.c45d	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c460	80 ea		bra $c44c			bra 	_EVCheckNextInteger
.c462					_EVCheckDecimal:
.c462	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c464	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.c466	d0 05		bne $c46d			bne 	_EVGotAtom 					; no, get atom.
.c468					_EVIsDecimal:
.c468	20 48 c5	jsr $c548			jsr 	EVGetDecimal 				; extend to the decimal part.
.c46b	80 00		bra $c46d			bra 	_EVGotAtom 					; and continue to got atom.
.c46d					_EVGotAtom:
.c46d	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c46f	10 3f		bpl $c4b0			bpl 	_EVExitDrop 				; must be a token.
.c471	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.c473	b0 3b		bcs $c4b0			bcs 	_EVExitDrop
.c475	68		pla				pla 								; get current precedence
.c476	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.c478	da		phx				phx 								; save X
.c479	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c47b	aa		tax				tax 								; put in X
.c47c	bd 32 c0	lda $c032,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.c47f	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.c481	fa		plx				plx 								; restore X
.c482	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.c484	90 2b		bcc $c4b1			bcc 	_EVExit 					; exit if too low.
.c486	f0 29		beq $c4b1			beq 	_EVExit 					; exit if equals
.c488	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.c48a	48		pha				pha
.c48b	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c48d	48		pha				pha
.c48e	c8		iny				iny
.c48f	da		phx				phx 								; save current position
.c490	e8		inx				inx
.c491	e8		inx				inx
.c492	e8		inx				inx
.c493	e8		inx				inx
.c494	e8		inx				inx
.c495	e8		inx				inx
.c496	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.c498	20 23 c4	jsr $c423			jsr 	EvaluateExpressionXA 		; do the RHS.
.c49b	fa		plx				plx 								; restore X
.c49c	68		pla				pla 								; get the binary operator in A.
.c49d					_EVCallA:
.c49d	da		phx				phx 								; save X again
.c49e	0a		asl a				asl 	a 							; double, lose the MSB.
.c49f	aa		tax				tax									; put in X
.c4a0	bd 00 c0	lda $c000,x			lda 	VectorTable,x 				; copy address into zGenPtr
.c4a3	85 1e		sta $1e				sta 	zGenPtr
.c4a5	bd 01 c0	lda $c001,x			lda 	VectorTable+1,x
.c4a8	85 1f		sta $1f				sta 	zGenPtr+1
.c4aa	fa		plx				plx 								; restore X
.c4ab	20 15 c5	jsr $c515			jsr 	EVGoZGenPtr 				; execute that function/operator
.c4ae	80 bd		bra $c46d			bra 	_EVGotAtom 					; and loop back.
.c4b0					_EVExitDrop:
.c4b0	68		pla				pla
.c4b1					_EVExit:
.c4b1	60		rts				rts
.c4b2					_EVNotInteger:
.c4b2	c8		iny				iny
.c4b3	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.c4b5	d0 19		bne $c4d0			bne 	_EVNotMinus
.c4b7	20 6e c5	jsr $c56e			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.c4ba	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; get type
.c4bd	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.c4bf	f0 05		beq $c4c6			beq 	_EVMinusFloat
.c4c1	20 bf c9	jsr $c9bf			jsr 	IntegerNegateAlways 		; negation
.c4c4	80 a7		bra $c46d			bra 	_EVGotAtom 					; and go back.
.c4c6					_EVMinusFloat:
.c4c6	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; invert the sign bit.
.c4c9	49 80		eor #$80			eor 	#$80
.c4cb	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c4ce	80 9d		bra $c46d			bra 	_EVGotAtom
.c4d0					_EVNotMinus:
.c4d0	c9 ba		cmp #$ba			cmp 	#token_lparen 				; is it left parenthesis
.c4d2	d0 0c		bne $c4e0			bne 	_EVNotParenthesis
.c4d4	20 21 c4	jsr $c421			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.c4d7	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c4d9	c8		iny				iny
.c4da	c9 bb		cmp #$bb			cmp 	#token_rparen 				; okay if right bracket.
.c4dc	f0 8f		beq $c46d			beq 	_EVGotAtom
.c4de	80 fe		bra $c4de		_error: bra _error
.c4e0					_EVNotParenthesis:
.c4e0	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.c4e2	d0 09		bne $c4ed			bne 	_EVNotNot
.c4e4	20 6e c5	jsr $c56e			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.c4e7	20 4b c5	jsr $c54b			jsr 	NotInteger 					; do the not calculation
.c4ea	4c 6d c4	jmp $c46d			jmp 	_EVGotAtom
.c4ed					_EVNotNot:
.c4ed	c9 fe		cmp #$fe			cmp 	#$FE
.c4ef	d0 15		bne $c506			bne 	_EVNotString
.c4f1	20 bf c8	jsr $c8bf			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.c4f4	a5 20		lda $20				lda 	zTempStr 					; copy address of string into mantissa
.c4f6	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c4f9	a5 21		lda $21				lda 	zTempStr+1
.c4fb	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c4fe	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.c500	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c503	4c 6d c4	jmp $c46d			jmp 	_EVGotAtom
.c506					_EVNotString:
.c506	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.c508	90 04		bcc $c50e			bcc 	_EVBadElement
.c50a	c9 b4		cmp #$b4			cmp 	#lastUnaryFunction+1
.c50c	90 03		bcc $c511			bcc 	_EVUnaryFunction
.c50e					_EVBadElement:
.c50e	4c 0f c4	jmp $c40f			jmp 	SyntaxError
.c511					_EVUnaryFunction:
.c511	4c 9d c4	jmp $c49d			jmp 	_EVCallA
.c514					_EVVariableHandler:
.c514	ea		nop				nop
.c515					EVGoZGenPtr:
.c515	6c 1e 00	jmp ($001e)			jmp 	 (zGenPtr)
.c518					EVShiftMantissaLeft6:
.c518	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.c51b	9d 04 03	sta $0304,x			sta 	XS_Exponent,x
.c51e	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c521	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c524	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c527	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c52a	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.c52d	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c530	a9 00		lda #$00			lda 	#0
.c532	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c535	20 38 c5	jsr $c538			jsr 	_EVSMLShift 					; call it here to do it twice
.c538					_EVSMLShift:
.c538	5e 04 03	lsr $0304,x			lsr 	XS_Exponent,x
.c53b	7e 03 03	ror $0303,x			ror 	XS_Mantissa+3,x
.c53e	7e 02 03	ror $0302,x			ror 	XS_Mantissa+2,x
.c541	7e 01 03	ror $0301,x			ror 	XS_Mantissa+1,x
.c544	7e 00 03	ror $0300,x			ror 	XS_Mantissa+0,x
.c547	60		rts				rts
.c548					EVGetDecimal:
.c548	4c 0f c4	jmp $c40f			jmp 	SyntaxError
.c54b					NotInteger:
.c54b	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.c54e	49 ff		eor #$ff			eor 	#$FF
.c550	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c553	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c556	49 ff		eor #$ff			eor 	#$FF
.c558	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c55b	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c55e	49 ff		eor #$ff			eor 	#$FF
.c560	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c563	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c566	49 ff		eor #$ff			eor 	#$FF
.c568	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c56b	60		rts				rts
.c56c					EvaluateGetAtom:
.c56c	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.c56e					EvaluateGetAtomX:
.c56e	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.c570	20 23 c4	jsr $c423			jsr 	EvaluateExpressionXA
.c573	bd 05 03	lda $0305,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.c576	29 0f		and #$0f			and 	#15
.c578	c9 02		cmp #$02			cmp 	#2
.c57a	b0 01		bcs $c57d			bcs 	EvaluateType
.c57c	60		rts				rts
.c57d					EvaluateType:
.c57d	80 fe		bra $c57d		_error: bra _error
.c57f					EvaluateNumber:
.c57f	a2 00		ldx #$00			ldx 	#0
.c581					EvaluateNumberX:
.c581	20 21 c4	jsr $c421			jsr 	EvaluateExpressionX
.c584	ad 05 03	lda $0305			lda 	XS_Type 						; check type is 0/1
.c587	29 0f		and #$0f			and 	#15
.c589	c9 02		cmp #$02			cmp 	#2
.c58b	b0 f0		bcs $c57d			bcs 	EvaluateType
.c58d	60		rts				rts
.c58e					EvaluateString:
.c58e	a2 00		ldx #$00			ldx 	#0
.c590					EvaluateStringX:
.c590	20 21 c4	jsr $c421			jsr 	EvaluateExpressionX
.c593	ad 05 03	lda $0305			lda 	XS_Type 						; check type is 2
.c596	29 0f		and #$0f			and 	#15
.c598	c9 02		cmp #$02			cmp 	#2
.c59a	d0 e1		bne $c57d			bne 	EvaluateType
.c59c	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.c59f	85 1e		sta $1e				sta 	zGenPtr
.c5a1	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c5a4	85 1f		sta $1f				sta 	zGenPtr+1
.c5a6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.c5a7					BinaryOp_And:
.c5a7	20 1f c6	jsr $c61f			jsr 	BinaryMakeBothInteger
.c5aa	bd 00 03	lda $0300,x			lda		XS_Mantissa+0,x
.c5ad	3d 06 03	and $0306,x			and 	XS2_Mantissa+0,x
.c5b0	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c5b3	bd 01 03	lda $0301,x			lda		XS_Mantissa+1,x
.c5b6	3d 07 03	and $0307,x			and 	XS2_Mantissa+1,x
.c5b9	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c5bc	bd 02 03	lda $0302,x			lda		XS_Mantissa+2,x
.c5bf	3d 08 03	and $0308,x			and 	XS2_Mantissa+2,x
.c5c2	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c5c5	bd 03 03	lda $0303,x			lda		XS_Mantissa+3,x
.c5c8	3d 09 03	and $0309,x			and 	XS2_Mantissa+3,x
.c5cb	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c5ce	60		rts				rts
.c5cf					BinaryOp_Or:
.c5cf	20 1f c6	jsr $c61f			jsr 	BinaryMakeBothInteger
.c5d2	bd 00 03	lda $0300,x			lda		XS_Mantissa+0,x
.c5d5	1d 06 03	ora $0306,x			ora 	XS2_Mantissa+0,x
.c5d8	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c5db	bd 01 03	lda $0301,x			lda		XS_Mantissa+1,x
.c5de	1d 07 03	ora $0307,x			ora 	XS2_Mantissa+1,x
.c5e1	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c5e4	bd 02 03	lda $0302,x			lda		XS_Mantissa+2,x
.c5e7	1d 08 03	ora $0308,x			ora 	XS2_Mantissa+2,x
.c5ea	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c5ed	bd 03 03	lda $0303,x			lda		XS_Mantissa+3,x
.c5f0	1d 09 03	ora $0309,x			ora 	XS2_Mantissa+3,x
.c5f3	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c5f6	60		rts				rts
.c5f7					BinaryOp_Eor:
.c5f7					BinaryOp_Xor:
.c5f7	20 1f c6	jsr $c61f			jsr 	BinaryMakeBothInteger
.c5fa	bd 00 03	lda $0300,x			lda		XS_Mantissa+0,x
.c5fd	5d 06 03	eor $0306,x			eor 	XS2_Mantissa+0,x
.c600	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c603	bd 01 03	lda $0301,x			lda		XS_Mantissa+1,x
.c606	5d 07 03	eor $0307,x			eor 	XS2_Mantissa+1,x
.c609	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c60c	bd 02 03	lda $0302,x			lda		XS_Mantissa+2,x
.c60f	5d 08 03	eor $0308,x			eor 	XS2_Mantissa+2,x
.c612	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c615	bd 03 03	lda $0303,x			lda		XS_Mantissa+3,x
.c618	5d 09 03	eor $0309,x			eor 	XS2_Mantissa+3,x
.c61b	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c61e	60		rts				rts
.c61f					BinaryMakeBothInteger:
.c61f	da		phx				phx 								; save X
.c620	e8		inx				inx
.c621	e8		inx				inx
.c622	e8		inx				inx
.c623	e8		inx				inx
.c624	e8		inx				inx
.c625	e8		inx				inx
.c626	20 2a c6	jsr $c62a			jsr 	BinaryMakeInteger 			; convert to integer.
.c629	fa		plx				plx 								; restore X and fall through.
.c62a					BinaryMakeInteger:
.c62a	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; get type byte.
.c62d	29 0f		and #$0f			and 	#15 						; check type zero
.c62f	f0 04		beq $c635			beq 	_BMIConvert 				; if float convert to integer.
.c631	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.c632	90 01		bcc $c635			bcc 	_BMIError
.c634	60		rts				rts
.c635					_BMIConvert:
.c635					_BMIError:
.c635	80 fe		bra $c635		_error: bra _error

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.c637					Binary_Equal:
.c637	20 83 c6	jsr $c683			jsr 	CompareValues
.c63a	09 00		ora #$00			ora 	#0
.c63c	f0 04		beq $c642			beq 	CCTrue
.c63e	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.c640	80 02		bra $c644			bra 	CCWrite
.c642	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.c644	9d 00 03	sta $0300,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.c647	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c64a	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c64d	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c650	a9 01		lda #$01			lda 	#1
.c652	9d 05 03	sta $0305,x			sta 	XS_Type,x 					; set type to integer whatever.
.c655	60		rts				rts
.c656					Binary_NotEqual:
.c656	20 83 c6	jsr $c683			jsr 	CompareValues
.c659	09 00		ora #$00			ora 	#0
.c65b	d0 e1		bne $c63e			bne 	CCFalse
.c65d	80 e3		bra $c642			bra 	CCTrue
.c65f					Binary_Less:
.c65f	20 83 c6	jsr $c683			jsr 	CompareValues
.c662	09 00		ora #$00			ora 	#0
.c664	30 dc		bmi $c642			bmi 	CCTrue
.c666	80 d6		bra $c63e			bra 	CCFalse
.c668					Binary_LessEqual:
.c668	20 83 c6	jsr $c683			jsr 	CompareValues
.c66b	c9 01		cmp #$01			cmp 	#1
.c66d	d0 d3		bne $c642			bne 	CCTrue
.c66f	80 cd		bra $c63e			bra 	CCFalse
.c671					Binary_GreaterEqual:
.c671	20 83 c6	jsr $c683			jsr 	CompareValues
.c674	09 00		ora #$00			ora 	#0
.c676	10 ca		bpl $c642			bpl 	CCTrue
.c678	80 c4		bra $c63e			bra 	CCFalse
.c67a					Binary_Greater:
.c67a	20 83 c6	jsr $c683			jsr 	CompareValues
.c67d	c9 01		cmp #$01			cmp 	#1
.c67f	d0 c1		bne $c642			bne 	CCTrue
.c681	80 bb		bra $c63e			bra 	CCFalse
.c683					CompareValues:
.c683	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; and the types together
.c686	3d 0b 03	and $030b,x			and 	XS2_Type,x
.c689	c9 02		cmp #$02			cmp 	#2
.c68b	f0 04		beq $c691			beq 	_CVString
.c68d	4c d7 c6	jmp $c6d7			jmp 	CompareInteger32 							; so execute code at \1
.c690	60		rts				rts
.c691					_CVString:
.c691	da		phx				phx 								; save XY
.c692	5a		phy				phy
.c693	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.c696	85 1a		sta $1a				sta		zLTemp1+0
.c698	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c69b	85 1b		sta $1b				sta 	zLTemp1+1
.c69d	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x
.c6a0	85 1c		sta $1c				sta 	zLTemp1+2
.c6a2	bd 07 03	lda $0307,x			lda 	XS2_Mantissa+1,x
.c6a5	85 1d		sta $1d				sta 	zLTemp1+3
.c6a7	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.c6a9	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.c6ab	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.c6ad	90 02		bcc $c6b1			bcc 	_CVCommon
.c6af	b1 1c		lda ($1c),y			lda 	(zLTemp1+2),y
.c6b1					_CVCommon:
.c6b1	aa		tax				tax 								; put shorter string length in zero.
.c6b2	f0 0c		beq $c6c0			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.c6b4					_CVCompare:
.c6b4	c8		iny				iny 								; next character
.c6b5	b1 1a		lda ($1a),y			lda 	(zLTemp1),y 				; compare characters
.c6b7	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.c6b9	90 13		bcc $c6ce			bcc 	_CVReturnLess 				; <
.c6bb	d0 15		bne $c6d2			bne 	_CVReturnGreater 			; >
.c6bd	ca		dex				dex 								; until common length matched.
.c6be	d0 f4		bne $c6b4			bne 	_CVCompare
.c6c0					_CVMatch:
.c6c0	a0 00		ldy #$00			ldy 	#0
.c6c2	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.c6c4	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.c6c6	90 06		bcc $c6ce			bcc 	_CVReturnLess 				; <
.c6c8	d0 08		bne $c6d2			bne 	_CVReturnGreater 			; >
.c6ca	a9 00		lda #$00			lda 	#0
.c6cc	80 06		bra $c6d4			bra 	_CVExit 					; same common, same length, same string
.c6ce					_CVReturnLess:
.c6ce	a9 ff		lda #$ff			lda 	#$FF
.c6d0	80 02		bra $c6d4			bra 	_CVExit
.c6d2					_CVReturnGreater:
.c6d2	a9 01		lda #$01			lda 	#$01
.c6d4					_CVExit:
.c6d4	7a		ply				ply
.c6d5	fa		plx				plx
.c6d6	60		rts				rts
.c6d7					CompareInteger32:
.c6d7	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.c6da	49 80		eor #$80			eor 	#$80
.c6dc	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c6df	bd 09 03	lda $0309,x			lda 	XS2_Mantissa+3,x
.c6e2	49 80		eor #$80			eor 	#$80
.c6e4	9d 09 03	sta $0309,x			sta 	XS2_Mantissa+3,x
.c6e7	20 43 c7	jsr $c743			jsr 	SubInteger32 				; subtraction
.c6ea	90 11		bcc $c6fd			bcc 	_CI32Less 					; cc return -1
.c6ec	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x 			; check if zero
.c6ef	1d 01 03	ora $0301,x			ora 	XS_Mantissa+1,x
.c6f2	1d 02 03	ora $0302,x			ora 	XS_Mantissa+2,x
.c6f5	1d 03 03	ora $0303,x			ora 	XS_Mantissa+3,x
.c6f8	f0 02		beq $c6fc			beq 	_CI32Exit
.c6fa	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.c6fc					_CI32Exit:
.c6fc	60		rts				rts
.c6fd					_CI32Less:
.c6fd	a9 ff		lda #$ff			lda 	#$FF
.c6ff	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.c700					BinaryOp_Add:
.c700	bd 05 03	lda $0305,x			lda 	XS_Type,x  					; and types together
.c703	3d 0b 03	and $030b,x			and 	XS2_Type,x
.c706	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.c708	d0 04		bne $c70e			bne 	_BOAString
.c70a	4c 1d c7	jmp $c71d			jmp 	AddInteger32 							; so execute code at \1
.c70d	60		rts				rts
.c70e					_BOAString:
.c70e	4c 80 c7	jmp $c780			jmp 	ConcatenateString 			; concatenate two strings.
.c711					BinaryOp_Subtract:
.c711	4c 43 c7	jmp $c743			jmp 	SubInteger32 							; so execute code at \1
.c714	60		rts				rts
.c715					BinaryOp_Multiply:
.c715	4c e4 c8	jmp $c8e4			jmp 	MulInteger32 							; so execute code at \1
.c718	60		rts				rts
.c719					BinaryOp_Divide:
.c719	4c 3b c9	jmp $c93b			jmp 	DivInteger32 							; so execute code at \1
.c71c	60		rts				rts
.c71d					AddInteger32:
.c71d	18		clc				clc
.c71e	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.c721	7d 06 03	adc $0306,x			adc 	XS2_Mantissa+0,x
.c724	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c727	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c72a	7d 07 03	adc $0307,x			adc 	XS2_Mantissa+1,x
.c72d	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c730	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c733	7d 08 03	adc $0308,x			adc 	XS2_Mantissa+2,x
.c736	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c739	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c73c	7d 09 03	adc $0309,x			adc 	XS2_Mantissa+3,x
.c73f	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c742	60		rts				rts
.c743					SubInteger32:
.c743	38		sec				sec
.c744	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.c747	fd 06 03	sbc $0306,x			sbc 	XS2_Mantissa+0,x
.c74a	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c74d	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c750	fd 07 03	sbc $0307,x			sbc 	XS2_Mantissa+1,x
.c753	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c756	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c759	fd 08 03	sbc $0308,x			sbc 	XS2_Mantissa+2,x
.c75c	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c75f	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c762	fd 09 03	sbc $0309,x			sbc 	XS2_Mantissa+3,x
.c765	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c768	60		rts				rts
.c769					BinaryMakeBothFloat:
.c769	da		phx				phx 								; save X
.c76a	e8		inx				inx
.c76b	e8		inx				inx
.c76c	e8		inx				inx
.c76d	e8		inx				inx
.c76e	e8		inx				inx
.c76f	e8		inx				inx
.c770	20 74 c7	jsr $c774			jsr 	BinaryMakeFloat 			; convert to float.
.c773	fa		plx				plx 								; restore X and fall through.
.c774					BinaryMakeFloat:
.c774	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; get type byte.
.c777	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.c778	b0 04		bcs $c77e			bcs 	_BMFConvert
.c77a	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.c77b	b0 01		bcs $c77e			bcs 	_BMFError
.c77d	60		rts				rts
.c77e					_BMFConvert:
.c77e					_BMFError:
.c77e	80 fe		bra $c77e		_error: bra _error
.c780					ConcatenateString:
.c780	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.c783	85 1a		sta $1a				sta		zLTemp1+0
.c785	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c788	85 1b		sta $1b				sta 	zLTemp1+1
.c78a	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x
.c78d	85 1c		sta $1c				sta 	zLTemp1+2
.c78f	bd 07 03	lda $0307,x			lda 	XS2_Mantissa+1,x
.c792	85 1d		sta $1d				sta 	zLTemp1+3
.c794	5a		phy				phy
.c795	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.c797	b1 1a		lda ($1a),y			lda 	(zlTemp1),y
.c799	71 1c		adc ($1c),y			adc 	(zlTemp1+2),y
.c79b	7a		ply				ply
.c79c	b0 37		bcs $c7d5			bcs 	_CSError					; check in range.
.c79e	c9 fe		cmp #$fe			cmp 	#maxString+1
.c7a0	b0 33		bcs $c7d5			bcs 	_CSError
.c7a2	20 84 c8	jsr $c884			jsr 	AllocateTempString 			; store the result
.c7a5	20 c0 c7	jsr $c7c0			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.c7a8	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.c7ab	85 1a		sta $1a				sta 	zLTemp1
.c7ad	bd 07 03	lda $0307,x			lda 	XS2_Mantissa+1,x
.c7b0	85 1b		sta $1b				sta 	zLTemp1+1
.c7b2	20 c0 c7	jsr $c7c0			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.c7b5	a5 20		lda $20				lda 	zTempStr 					; point current to new string
.c7b7	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c7ba	a5 21		lda $21				lda 	zTempStr+1
.c7bc	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c7bf	60		rts				rts
.c7c0					_CSCopyString:
.c7c0	da		phx				phx
.c7c1	5a		phy				phy
.c7c2	a0 00		ldy #$00			ldy 	#0 							; get length
.c7c4	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.c7c6	f0 0a		beq $c7d2			beq 	_CSCSExit 					; if zero, exit
.c7c8	aa		tax				tax 								; put in X
.c7c9					_CSCSLoop:
.c7c9	c8		iny				iny 								; get next char
.c7ca	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.c7cc	20 af c8	jsr $c8af			jsr		WriteTempString 			; copy out
.c7cf	ca		dex				dex 								; do whole string
.c7d0	d0 f7		bne $c7c9			bne 	_CSCSLoop
.c7d2					_CSCSExit:
.c7d2	7a		ply				ply
.c7d3	fa		plx				plx
.c7d4	60		rts				rts
.c7d5					_CSError:
.c7d5	80 fe		bra $c7d5		_error: bra _error

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.c7d7					Unary_Sgn:
.c7d7	20 81 c5	jsr $c581			jsr 	EvaluateNumberX 			; get value
.c7da	20 74 c8	jsr $c874			jsr 	CheckNextRParen 			; check right bracket.
.c7dd	20 01 c8	jsr $c801			jsr 	GetSignCurrent 				; get sign.
.c7e0	09 00		ora #$00			ora 	#0
.c7e2	10 09		bpl $c7ed			bpl		UnarySetAInteger			; if 0,1 return that.
.c7e4	80 00		bra $c7e6			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.c7e6					UnarySetAMinus1:
.c7e6	a9 ff		lda #$ff			lda 	#$FF
.c7e8	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.c7eb	80 05		bra $c7f2			bra 	UnarySetAFill
.c7ed					UnarySetAInteger:
.c7ed	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.c7f0	a9 00		lda #$00			lda 	#0
.c7f2					UnarySetAFill:
.c7f2	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c7f5	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c7f8	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c7fb	a9 01		lda #$01			lda 	#1
.c7fd	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c800	60		rts				rts
.c801					GetSignCurrent:
.c801	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; identify type.
.c804	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.c805	90 19		bcc $c820			bcc 	_GSCFloat
.c807	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c80a	30 11		bmi $c81d			bmi 	_GSCMinus1
.c80c	1d 00 03	ora $0300,x			ora 	XS_Mantissa+0,x
.c80f	1d 01 03	ora $0301,x			ora 	XS_Mantissa+1,x
.c812	1d 02 03	ora $0302,x			ora 	XS_Mantissa+2,x
.c815	d0 03		bne $c81a			bne 	_GSCPlus1
.c817					_GSCZero:
.c817	a9 00		lda #$00			lda 	#0
.c819	60		rts				rts
.c81a					_GSCPlus1:
.c81a	a9 01		lda #$01			lda 	#$01
.c81c	60		rts				rts
.c81d					_GSCMinus1:
.c81d	a9 ff		lda #$ff			lda 	#$FF
.c81f	60		rts				rts
.c820					_GSCFloat:
.c820	3c 05 03	bit $0305,x			bit 	XS_Type,x
.c823	70 f2		bvs $c817			bvs 	_GSCZero
.c825	30 f6		bmi $c81d			bmi 	_GSCMinus1
.c827	80 f1		bra $c81a			bra 	_GSCPlus1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.c829					Unary_Abs:
.c829	20 81 c5	jsr $c581			jsr 	EvaluateNumberX 			; get value
.c82c	20 74 c8	jsr $c874			jsr 	CheckNextRParen 			; check right bracket.
.c82f	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; get type
.c832	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.c834	f0 08		beq $c83e			beq 	_UAMinusFloat
.c836	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; check MSB
.c839	10 0b		bpl $c846			bpl 	_UAExit
.c83b	4c bf c9	jmp $c9bf			jmp 	IntegerNegateAlways 		; negation
.c83e					_UAMinusFloat:
.c83e	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; clear the sign bit.
.c841	29 7f		and #$7f			and		#$7F
.c843	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c846					_UAExit:
.c846	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.c847					Unary_Asc:
.c847	20 90 c5	jsr $c590			jsr 	EvaluateStringX 			; string parameter
.c84a	20 74 c8	jsr $c874			jsr 	CheckNextRParen 			; right bracket.
.c84d	5a		phy				phy 								; get the string length
.c84e	a0 00		ldy #$00			ldy 	#0
.c850	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.c852	f0 07		beq $c85b			beq 	_UAIllegal 					; must be at least one character
.c854	c8		iny				iny
.c855	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; read it.
.c857	7a		ply				ply
.c858	4c ed c7	jmp $c7ed			jmp 	UnarySetAInteger
.c85b					_UAIllegal:
.c85b	80 fe		bra $c85b		_error: bra _error

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.c85d					Unary_Len:
.c85d	20 90 c5	jsr $c590			jsr 	EvaluateStringX 			; string parameter
.c860	20 74 c8	jsr $c874			jsr 	CheckNextRParen 			; right bracket.
.c863	5a		phy				phy 								; get the string length
.c864	a0 00		ldy #$00			ldy 	#0
.c866	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.c868	7a		ply				ply
.c869	4c ed c7	jmp $c7ed			jmp 	UnarySetAInteger

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.c86c					CheckNextToken:
.c86c	d1 16		cmp ($16),y			cmp 	(zCodePtr),y
.c86e	d0 02		bne $c872			bne 	CTFail 						; no, then fail
.c870	c8		iny				iny
.c871	60		rts				rts
.c872					CTFail:
.c872	80 fe		bra $c872		_error: bra _error
.c874					CheckNextRParen:
.c874	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c876	c9 bb		cmp #$bb			cmp 	#token_rparen
.c878	d0 f8		bne $c872			bne 	CTFail
.c87a	c8		iny				iny
.c87b	60		rts				rts
.c87c					CheckNextComma:
.c87c	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c87e	c9 bc		cmp #$bc			cmp 	#token_comma
.c880	d0 f0		bne $c872			bne 	CTFail
.c882	c8		iny				iny
.c883	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.c884					AllocateTempString:
.c884	48		pha				pha 								; save required count.
.c885	a5 21		lda $21				lda 	zTempStr+1 					; check if initialised yet ?
.c887	d0 0b		bne $c894			bne 	_ATSInitialised
.c889	ad 26 04	lda $0426			lda 	StringPtr 					; set temporary string ptr 1 page below available
.c88c	85 20		sta $20				sta 	zTempStr					; space, this is for strings to be concreted.
.c88e	ad 27 04	lda $0427			lda 	StringPtr+1
.c891	3a		dec a				dec 	a
.c892	85 21		sta $21				sta 	zTempStr+1
.c894					_ATSInitialised:
.c894	68		pla				pla 								; get required count back.
.c895	49 ff		eor #$ff			eor 	#$FF 						; negate 2's complement.
.c897	1a		inc a				inc 	a
.c898	18		clc				clc
.c899	65 20		adc $20				adc 	zTempStr 					; "add" to the temp string pointer
.c89b	85 20		sta $20				sta 	zTempStr
.c89d	a9 ff		lda #$ff			lda 	#$FF
.c89f	65 21		adc $21				adc 	zTempStr+1
.c8a1	85 21		sta $21				sta 	zTempStr+1
.c8a3	a9 00		lda #$00			lda 	#0 							; clear temp string.
.c8a5	5a		phy				phy
.c8a6	a8		tay				tay
.c8a7	91 20		sta ($20),y			sta 	(zTempStr),y
.c8a9	7a		ply				ply
.c8aa	1a		inc a				inc 	a 							; reset the write index.
.c8ab	8d 27 04	sta $0427			sta 	TempStringWriteIndex
.c8ae	60		rts				rts
.c8af					WriteTempString:
.c8af	5a		phy				phy 								; save Y
.c8b0	ac 27 04	ldy $0427			ldy 	TempStringWriteIndex	 	; write position.
.c8b3	91 20		sta ($20),y			sta 	(zTempStr),y 				; write character out.
.c8b5	ee 27 04	inc $0427			inc 	TempStringWriteIndex 		; increment the write position.
.c8b8	98		tya				tya 								; unchanged Y is now length
.c8b9	a0 00		ldy #$00			ldy 	#0
.c8bb	91 20		sta ($20),y			sta 	(zTempStr),y
.c8bd	7a		ply				ply 								; restore Y and exit
.c8be	60		rts				rts
.c8bf					CreateTempStringCopy:
.c8bf	da		phx				phx 								; save X
.c8c0	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c8c2	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.c8c3	20 84 c8	jsr $c884			jsr 	AllocateTempString 			; allocate memory for temporary string.
.c8c6	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c8c8	c8		iny				iny
.c8c9	3a		dec a				dec 	a 							; make the actual length in charactes
.c8ca	3a		dec a				dec 	a
.c8cb	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.c8cd	81 20		sta ($20,x)			sta 	(zTempStr,x)
.c8cf	85 1a		sta $1a				sta 	zLTemp1 					; that's used as a count.
.c8d1	09 00		ora #$00			ora 	#0 							; if zero already, exit
.c8d3	f0 0d		beq $c8e2			beq 	_CTSCExit
.c8d5					_CTSCLoop:
.c8d5	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c8d7	c8		iny				iny
.c8d8	5a		phy				phy 								; save in Y
.c8d9	e8		inx				inx 								; bump index
.c8da	9b		txy				txy 								; index into Y
.c8db	91 20		sta ($20),y			sta 	(zTempStr),y 				; save at index
.c8dd	7a		ply				ply 								; restore Y
.c8de	c6 1a		dec $1a				dec 	zLTemp1 					; do for each character
.c8e0	d0 f3		bne $c8d5			bne 	_CTSCLoop
.c8e2					_CTSCExit:
.c8e2	fa		plx				plx 								; restore X
.c8e3	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.c8e4					MulInteger32:
.c8e4	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.c8e7	9d 0c 03	sta $030c,x			sta 	XS3_Mantissa,x
.c8ea	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c8ed	9d 0d 03	sta $030d,x			sta 	XS3_Mantissa+1,x
.c8f0	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c8f3	9d 0e 03	sta $030e,x			sta 	XS3_Mantissa+2,x
.c8f6	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c8f9	9d 0f 03	sta $030f,x			sta 	XS3_Mantissa+3,x
.c8fc	a9 00		lda #$00			lda 	#0
.c8fe	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x 				; zero +0
.c901	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c904	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c907	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c90a					_BFMMultiply:
.c90a	bd 0c 03	lda $030c,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.c90d	29 01		and #$01			and 	#1
.c90f	f0 03		beq $c914			beq 	_BFMNoAdd
.c911	20 1d c7	jsr $c71d			jsr 	AddInteger32
.c914					_BFMNoAdd:
.c914	1e 06 03	asl $0306,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.c917	3e 07 03	rol $0307,x			rol 	XS2_Mantissa+1,x
.c91a	3e 08 03	rol $0308,x			rol 	XS2_Mantissa+2,x
.c91d	3e 09 03	rol $0309,x			rol 	XS2_Mantissa+3,x
.c920	5e 0f 03	lsr $030f,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.c923	7e 0e 03	ror $030e,x			ror 	XS3_Mantissa+2,x
.c926	7e 0d 03	ror $030d,x			ror 	XS3_Mantissa+1,x
.c929	7e 0c 03	ror $030c,x			ror 	XS3_Mantissa,x
.c92c	bd 0c 03	lda $030c,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.c92f	1d 0d 03	ora $030d,x			ora 	XS3_Mantissa+1,x
.c932	1d 0e 03	ora $030e,x			ora 	XS3_Mantissa+2,x
.c935	1d 0f 03	ora $030f,x			ora 	XS3_Mantissa+3,x
.c938	d0 d0		bne $c90a			bne 	_BFMMultiply
.c93a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.c93b					DivInteger32:
.c93b	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x 			; check for /0
.c93e	1d 07 03	ora $0307,x			ora 	XS2_Mantissa+1,x
.c941	1d 08 03	ora $0308,x			ora 	XS2_Mantissa+2,x
.c944	1d 09 03	ora $0309,x			ora 	XS2_Mantissa+3,x
.c947	d0 02		bne $c94b			bne 	_BFDOkay
.c949	80 fe		bra $c949		_error: bra _error
.c94b					_BFDOkay:
.c94b	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.c94d	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.c94f	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.c951	85 1c		sta $1c				sta 	zLTemp1+2
.c953	85 1d		sta $1d				sta 	zLTemp1+3
.c955	8d 25 04	sta $0425			sta 	SignCount 					; Count of signs.
.c958	20 b9 c9	jsr $c9b9			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.c95b	da		phx				phx
.c95c	e8		inx				inx
.c95d	e8		inx				inx
.c95e	e8		inx				inx
.c95f	e8		inx				inx
.c960	e8		inx				inx
.c961	e8		inx				inx
.c962	20 b9 c9	jsr $c9b9			jsr 	CheckIntegerNegate
.c965	fa		plx				plx
.c966	5a		phy				phy 								; Y is the counter
.c967	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.c969					_BFDLoop:
.c969	1e 00 03	asl $0300,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.c96c	3e 01 03	rol $0301,x			rol 	XS_Mantissa+1,x
.c96f	3e 02 03	rol $0302,x			rol 	XS_Mantissa+2,x
.c972	3e 03 03	rol $0303,x			rol 	XS_Mantissa+3,x
.c975	26 1a		rol $1a				rol 	zLTemp1
.c977	26 1b		rol $1b				rol 	zLTemp1+1
.c979	26 1c		rol $1c				rol 	zLTemp1+2
.c97b	26 1d		rol $1d				rol 	zLTemp1+3
.c97d	38		sec				sec
.c97e	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.c980	fd 06 03	sbc $0306,x			sbc 	XS2_Mantissa+0,x
.c983	48		pha				pha
.c984	a5 1b		lda $1b				lda 	zLTemp1+1
.c986	fd 07 03	sbc $0307,x			sbc 	XS2_Mantissa+1,x
.c989	48		pha				pha
.c98a	a5 1c		lda $1c				lda 	zLTemp1+2
.c98c	fd 08 03	sbc $0308,x			sbc 	XS2_Mantissa+2,x
.c98f	48		pha				pha
.c990	a5 1d		lda $1d				lda 	zLTemp1+3
.c992	fd 09 03	sbc $0309,x			sbc 	XS2_Mantissa+3,x
.c995	90 15		bcc $c9ac			bcc 	_BFDNoAdd
.c997	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.c999	68		pla				pla
.c99a	85 1c		sta $1c				sta 	zLTemp1+2
.c99c	68		pla				pla
.c99d	85 1b		sta $1b				sta 	zLTemp1+1
.c99f	68		pla				pla
.c9a0	85 1a		sta $1a				sta 	zLTemp1+0
.c9a2	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.c9a5	09 01		ora #$01			ora 	#1
.c9a7	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c9aa	80 03		bra $c9af			bra 	_BFDNext
.c9ac					_BFDNoAdd:
.c9ac	68		pla				pla 								; Throw away the intermediate calculations
.c9ad	68		pla				pla
.c9ae	68		pla				pla
.c9af					_BFDNext:
.c9af	88		dey				dey
.c9b0	d0 b7		bne $c969			bne 	_BFDLoop
.c9b2	7a		ply				ply 								; restore Y and exit
.c9b3	4e 25 04	lsr $0425			lsr 	SignCount 					; if sign count odd,
.c9b6	b0 07		bcs $c9bf			bcs		IntegerNegateAlways 			; negate the result
.c9b8	60		rts				rts
.c9b9					CheckIntegerNegate:
.c9b9	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c9bc	30 01		bmi $c9bf			bmi 	IntegerNegateAlways
.c9be	60		rts				rts
.c9bf					IntegerNegateAlways:
.c9bf	ee 25 04	inc $0425			inc 	SignCount
.c9c2	38		sec				sec
.c9c3	a9 00		lda #$00			lda 	#0
.c9c5	fd 00 03	sbc $0300,x			sbc 	XS_Mantissa+0,x
.c9c8	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c9cb	a9 00		lda #$00			lda 	#0
.c9cd	fd 01 03	sbc $0301,x			sbc 	XS_Mantissa+1,x
.c9d0	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c9d3	a9 00		lda #$00			lda 	#0
.c9d5	fd 02 03	sbc $0302,x			sbc 	XS_Mantissa+2,x
.c9d8	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c9db	a9 00		lda #$00			lda 	#0
.c9dd	fd 03 03	sbc $0303,x			sbc 	XS_Mantissa+3,x
.c9e0	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c9e3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.c9e4					INTToString:
.c9e4	48		pha				pha
.c9e5	5a		phy				phy
.c9e6	bd 03 03	lda $0303,x			lda 		XS_Mantissa+3,x 		; check -ve
.c9e9	10 08		bpl $c9f3			bpl 		_ITSNotMinus
.c9eb	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.c9ed	20 80 ca	jsr $ca80			jsr 		ITSOutputCharacter
.c9f0	20 bf c9	jsr $c9bf			jsr 		IntegerNegateAlways 	; negate the number.
.c9f3					_ITSNotMinus:
.c9f3	a9 00		lda #$00			lda 		#0 						; X is offset in table.
.c9f5	8d 21 04	sta $0421			sta 		NumSuppress 			; clear the suppression flag.
.c9f8	a0 00		ldy #$00			ldy 		#0 						; Y is index into dword subtraction table.
.c9fa					_ITSNextSubtractor:
.c9fa	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.c9fc	8d 22 04	sta $0422			sta 		NumConvCount
.c9ff					_ITSSubtract:
.c9ff	38		sec				sec
.ca00	bd 00 03	lda $0300,x			lda 		XS_Mantissa,x 			; subtract number and push on stack
.ca03	f9 5c ca	sbc $ca5c,y			sbc 		_ITSSubtractors+0,y
.ca06	48		pha				pha
.ca07	bd 01 03	lda $0301,x			lda 		XS_Mantissa+1,x
.ca0a	f9 5d ca	sbc $ca5d,y			sbc 		_ITSSubtractors+1,y
.ca0d	48		pha				pha
.ca0e	bd 02 03	lda $0302,x			lda 		XS_Mantissa+2,x
.ca11	f9 5e ca	sbc $ca5e,y			sbc 		_ITSSubtractors+2,y
.ca14	48		pha				pha
.ca15	bd 03 03	lda $0303,x			lda 		XS_Mantissa+3,x
.ca18	f9 5f ca	sbc $ca5f,y			sbc 		_ITSSubtractors+3,y
.ca1b	90 14		bcc $ca31			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.ca1d	9d 03 03	sta $0303,x			sta 		XS_Mantissa+3,x 		; save subtract off stack
.ca20	68		pla				pla
.ca21	9d 02 03	sta $0302,x			sta 		XS_Mantissa+2,x
.ca24	68		pla				pla
.ca25	9d 01 03	sta $0301,x			sta 		XS_Mantissa+1,x
.ca28	68		pla				pla
.ca29	9d 00 03	sta $0300,x			sta 		XS_Mantissa+0,x
.ca2c	ee 22 04	inc $0422			inc 		NumConvCount 			; bump count.
.ca2f	80 ce		bra $c9ff			bra 		_ITSSubtract 			; go round again.
.ca31					_ITSCantSubtract:
.ca31	68		pla				pla 								; throw away interim answers
.ca32	68		pla				pla
.ca33	68		pla				pla
.ca34	ad 22 04	lda $0422			lda 		NumConvCount 			; if not zero then no suppression check
.ca37	c9 30		cmp #$30			cmp 		#"0"
.ca39	d0 05		bne $ca40			bne 		_ITSOutputDigit
.ca3b	ad 21 04	lda $0421			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.ca3e	10 09		bpl $ca49			bpl 		_ITSGoNextSubtractor
.ca40					_ITSOutputDigit:
.ca40	ce 21 04	dec $0421			dec 		NumSuppress 			; suppression check will be non-zero.
.ca43	ad 22 04	lda $0422			lda 		NumConvCount 			; count of subtractions
.ca46	20 80 ca	jsr $ca80			jsr 		ITSOutputCharacter 		; output it.
.ca49					_ITSGoNextSubtractor:
.ca49	c8		iny				iny 								; next dword
.ca4a	c8		iny				iny
.ca4b	c8		iny				iny
.ca4c	c8		iny				iny
.ca4d	c0 24		cpy #$24			cpy 		#_ITSSubtractorsEnd-_ITSSubtractors
.ca4f	d0 a9		bne $c9fa			bne 		_ITSNextSubtractor 		; do all the subtractors.
.ca51	bd 00 03	lda $0300,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.ca54	09 30		ora #$30			ora 		#"0"
.ca56	20 80 ca	jsr $ca80			jsr 		ITSOutputCharacter
.ca59	7a		ply				ply 								; and exit
.ca5a	68		pla				pla
.ca5b	60		rts				rts
.ca5c					_ITSSubtractors:
>ca5c	00 ca 9a 3b					.dword 		1000000000
>ca60	00 e1 f5 05					.dword 		100000000
>ca64	80 96 98 00					.dword 		10000000
>ca68	40 42 0f 00					.dword 		1000000
>ca6c	a0 86 01 00					.dword 		100000
>ca70	10 27 00 00					.dword 		10000
>ca74	e8 03 00 00					.dword 		1000
>ca78	64 00 00 00					.dword 		100
>ca7c	0a 00 00 00					.dword 		10
.ca80					_ITSSubtractorsEnd:
.ca80					ITSOutputCharacter:
.ca80	48		pha				pha
.ca81	da		phx				phx
.ca82	ae 20 04	ldx $0420			ldx 	NumBufX 					; save digit
.ca85	9d 00 04	sta $0400,x			sta 	Num_Buffer,x
.ca88	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.ca8a	9d 01 04	sta $0401,x			sta 	Num_Buffer+1,x
.ca8d	ee 20 04	inc $0420			inc 	NumBufX						; bump pointer.
.ca90	fa		plx				plx
.ca91	68		pla				pla
.ca92	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.ca93					IntFromString:
.ca93	a0 00		ldy #$00			ldy 	#0
.ca95	8c 23 04	sty $0423			sty 	ExpTemp 					; this is the converted digit count.
.ca98					IntFromStringY:
.ca98	48		pha				pha
.ca99	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.ca9b	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.ca9e	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.caa1	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.caa4	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.caa7	a9 01		lda #$01			lda 	#1
.caa9	9d 05 03	sta $0305,x			sta 	XS_Type,x
.caac					_IFSLoop:
.caac	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.caae	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.cab0	90 60		bcc $cb12			bcc 	_IFSExit
.cab2	c9 3a		cmp #$3a			cmp 	#"9"+1
.cab4	b0 5c		bcs $cb12			bcs 	_IFSExit
.cab6	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.cab9	c9 0c		cmp #$0c			cmp 	#12
.cabb	b0 5f		bcs $cb1c			bcs 	_IFSOverflow
.cabd	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.cac0	48		pha				pha
.cac1	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.cac4	48		pha				pha
.cac5	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.cac8	48		pha				pha
.cac9	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.cacc	48		pha				pha
.cacd	20 31 cb	jsr $cb31			jsr 	IFSX1ShiftLeft 				; double
.cad0	20 31 cb	jsr $cb31			jsr 	IFSX1ShiftLeft 				; x 4
.cad3	18		clc				clc 								; add saved value x 5
.cad4	68		pla				pla
.cad5	7d 00 03	adc $0300,x			adc 	XS_Mantissa+0,x
.cad8	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.cadb	68		pla				pla
.cadc	7d 01 03	adc $0301,x			adc 	XS_Mantissa+1,x
.cadf	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.cae2	68		pla				pla
.cae3	7d 02 03	adc $0302,x			adc 	XS_Mantissa+2,x
.cae6	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cae9	68		pla				pla
.caea	7d 03 03	adc $0303,x			adc 	XS_Mantissa+3,x
.caed	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.caf0	20 31 cb	jsr $cb31			jsr 	IFSX1ShiftLeft 				; x 10
.caf3	ee 23 04	inc $0423			inc 	ExpTemp 					; bump count of digits processed.
.caf6	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.caf8	29 0f		and #$0f			and 	#15
.cafa	c8		iny				iny
.cafb	7d 00 03	adc $0300,x			adc 	XS_Mantissa+0,x
.cafe	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.cb01	90 a9		bcc $caac			bcc 	_IFSLoop
.cb03	fe 01 03	inc $0301,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.cb06	d0 a4		bne $caac			bne 	_IFSLoop
.cb08	fe 02 03	inc $0302,x			inc 	XS_Mantissa+2,x
.cb0b	d0 9f		bne $caac			bne 	_IFSLoop
.cb0d	fe 03 03	inc $0303,x			inc 	XS_Mantissa+3,x
.cb10	80 9a		bra $caac			bra 	_IFSLoop
.cb12					_IFSExit:
.cb12	98		tya				tya 								; get offset
.cb13					_IFSOkay:
.cb13	38		sec				sec
.cb14	ad 23 04	lda $0423			lda 	ExpTemp
.cb17	f0 01		beq $cb1a			beq 	_IFSSkipFail
.cb19	18		clc				clc
.cb1a					_IFSSkipFail:
.cb1a	68		pla				pla 								; and exit.
.cb1b	60		rts				rts
.cb1c					_IFSOverflow:
.cb1c	20 0f c4	jsr $c40f			jsr 	ERR_Handler
>cb1f	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>cb27	20 6f 76 65 72 66 6c 6f 77 00
.cb31					IFSX1ShiftLeft:
.cb31	1e 00 03	asl $0300,x			asl 	XS_Mantissa+0,x
.cb34	3e 01 03	rol $0301,x			rol 	XS_Mantissa+1,x
.cb37	3e 02 03	rol $0302,x			rol 	XS_Mantissa+2,x
.cb3a	3e 03 03	rol $0303,x			rol 	XS_Mantissa+3,x
.cb3d	60		rts				rts

;******  Return to file: _include.asm


;******  Return to file: basic.asm

>cb3e	02						.byte 	2
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	eb c1						.word 	StartROM
>fffe	f8 ff						.word DefaultInterrupt

;******  End of listing
