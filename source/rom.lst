
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Fri Aug 23 22:45:43 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="4510"					cpu = "4510"
="mega65"				hardware = "mega65"
=1					exitonend = 1
=1					hasfloat = 1
=1					hasinteger = 1
=253					maxstring = 253

;******  Processing file: modules/float/fpmacros.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/mega65/src_mega65.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0020					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0200					IFT_XCursor:.byte ?							; current logical position on screen
>0201					IFT_YCursor:.byte ?
>0202					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0266					IFT_LineBuffer: .fill 100 					; line input buffer.
>0300					UserVector .fill 4 							; USR(x) calls this.
>0304					LocalVector .fill 4 						; Indirect calls call this.
>0308					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>030c					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>030d					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=782					XS2_Mantissa = XS_Mantissa+XS_Size
=786					XS2_Exponent = XS_Exponent+XS_Size
=787					XS2_Type = XS_Type+XS_Size
=788					XS3_Mantissa = XS_Mantissa+XS_Size*2
=792					XS3_Exponent = XS_Exponent+XS_Size*2
=793					XS3_Type = XS_Type+XS_Size*2
>0400					Num_Buffer	.fill 	32 						; buffer for numeric conversions
>0420					NumBufX 	.byte 	?						; buffer index position
>0421					NumSuppress	.byte 	?						; leading zero suppression flag
>0422					NumConvCount .byte 	? 						; count for conversions.
>0423					ExpTemp:	.byte ?							; Working temp for exponents.
>0424					ExpCount:	.byte ? 						; Count of decimal exponents.
>0425					SignCount:	.byte ?							; Integer Divide Sign Counts.
>0426					StringPtr:	.byte ? 						; Top of free memory (for string allocation)
>0427					TempStringWriteIndex: .byte ? 				; Write offset.
>0428					ValSign: 	.byte ? 						; sign flag for val()
>0429					SliceStart:	.byte ? 						; string slice parts
>042a					SliceCount:	.byte ?
>042b					RandomSeed:	.dword ? 						; Random seed.
>042f					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>0431					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>0433					Tim_SR:		.byte ? 						; Processor Status
>0434					Tim_A:		.byte ? 						; Processor Registers
>0435					Tim_X:		.byte ?
>0436					Tim_Y:		.byte ?
>0437					Tim_Z:		.byte ?
>0438					Tim_SP:		.byte ?							; Stack Pointer

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/mega65.asm

=$a000					HighMemory = $A000
.8000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testcode.src

>8000	12 36 fb d9 41 fd 03 30			.byte	$12,$36,$fb,$d9,$41,$fd,$03,$30
>8008	84 40 be ff 06 68 69 20			.byte	$84,$40,$be,$ff,$06,$68,$69,$20
>8010	21 00 00				.byte	$21,$00,$00

;******  Return to file: modules/hardware/mega65.asm

.a000					StartROM:
.a000	a2 ff		ldx #$ff			ldx 		#$FF 					; empty stack
.a002	9a		txs				txs
.a003	20 40 a2	jsr $a240			jsr 	IF_Reset 					; reset external interface
.a006	20 0c a0	jsr $a00c			jsr 	IFT_ClearScreen
.a009	4c a2 ad	jmp $ada2		jmp BASIC_Start

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.a00c					IFT_ClearScreen:
.a00c	48		pha				pha
.a00d	da		phx				phx
.a00e	5a		phy				phy
.a00f	20 a7 a1	jsr $a1a7			jsr 	IF_Home 					; home cursor
.a012	a2 19		ldx #$19			ldx 	#IF_Height 					; this many lines.
.a014					_IFT_CS0:
.a014	a0 50		ldy #$50			ldy 	#IF_Width 					; this many chars/line
.a016					_IFT_CS1:
.a016	a9 20		lda #$20			lda 	#' '						; clear line.
.a018	20 d6 a1	jsr $a1d6			jsr 	IF_Write
.a01b	88		dey				dey
.a01c	d0 f8		bne $a016			bne 	_IFT_CS1
.a01e	20 b6 a1	jsr $a1b6			jsr 	IF_NewLine 					; next line down
.a021	ca		dex				dex
.a022	d0 f0		bne $a014			bne 	_IFT_CS0
.a024	7a		ply				ply
.a025	fa		plx				plx
.a026	68		pla				pla
.a027					IFT_HomeCursor:
.a027	48		pha				pha
.a028	20 a7 a1	jsr $a1a7			jsr 	IF_Home
.a02b	a9 00		lda #$00			lda 	#0
.a02d	8d 00 02	sta $0200			sta 	IFT_XCursor
.a030	8d 01 02	sta $0201			sta 	IFT_YCursor
.a033	68		pla				pla
.a034	60		rts				rts
.a035					IFT_UpLine:
.a035	48		pha				pha
.a036	ad 01 02	lda $0201			lda  	IFT_YCursor 				; get Y
.a039	3a		dec a				dec 	a 							; line above
.a03a	30 03		bmi $a03f			bmi 	_IFTULExit 					; too far, abort
.a03c	20 ca a0	jsr $a0ca			jsr 	IFT_SetYPos					; set to that line.
.a03f					_IFTULExit:
.a03f	68		pla				pla
.a040	60		rts				rts
.a041					IFT_PrintCharacter:
.a041	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.a043	f0 16		beq $a05b			beq 	IFT_NewLine
.a045	48		pha				pha
.a046	20 73 a0	jsr $a073			jsr 	IFT_UpperCase 				; make upper case
.a049	20 d6 a1	jsr $a1d6			jsr 	IF_Write 					; write out.
.a04c	ee 00 02	inc $0200			inc 	IFT_XCursor 				; bump x cursor
.a04f	ad 00 02	lda $0200			lda 	IFT_XCursor 				; reached RHS ?
.a052	c9 50		cmp #$50			cmp 	#IF_Width
.a054	d0 03		bne $a059			bne 	_IFT_PCNotEOL
.a056	20 5b a0	jsr $a05b			jsr 	IFT_NewLine 				; if so do new line.
.a059					_IFT_PCNotEOL:
.a059	68		pla				pla
.a05a	60		rts				rts
.a05b					IFT_NewLine:
.a05b	48		pha				pha
.a05c	20 b6 a1	jsr $a1b6			jsr 	IF_NewLine 					; new line on actual screen.
.a05f	a9 00		lda #$00			lda 	#0 							; reset x position
.a061	8d 00 02	sta $0200			sta 	IFT_XCursor
.a064	ee 01 02	inc $0201			inc 	IFT_YCursor 				; move down.
.a067	ad 01 02	lda $0201			lda 	IFT_YCursor
.a06a	c9 19		cmp #$19			cmp 	#IF_Height 					; reached bottom.
.a06c	d0 03		bne $a071			bne 	_IFT_NL_NotEOS
.a06e	20 7e a0	jsr $a07e			jsr 	IFT_Scroll 					; scroll screen up.
.a071					_IFT_NL_NotEOS:
.a071	68		pla				pla
.a072	60		rts				rts
.a073					IFT_UpperCase:
.a073	c9 61		cmp #$61			cmp 	#"a"
.a075	90 06		bcc $a07d			bcc 	_IFT_UCExit
.a077	c9 7b		cmp #$7b			cmp 	#"z"+1
.a079	b0 02		bcs $a07d			bcs 	_IFT_UCExit
.a07b	49 20		eor #$20			eor 	#$20
.a07d					_IFT_UCExit:
.a07d	60		rts				rts
.a07e					IFT_Scroll:
.a07e	48		pha				pha 								; save AXY
.a07f	da		phx				phx
.a080	5a		phy				phy
.a081	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.a083					_IFT_SLoop:
.a083	20 a3 a0	jsr $a0a3			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.a086	e8		inx				inx
.a087	e0 18		cpx #$18			cpx 	#IF_Height-1				; do whole screen
.a089	d0 f8		bne $a083			bne 	_IFT_SLoop
.a08b	a9 18		lda #$18			lda 	#IF_Height-1 				; move to X = 0,Y = A
.a08d	20 ca a0	jsr $a0ca			jsr 	IFT_SetYPos
.a090	a2 50		ldx #$50			ldx 	#IF_Width 					; blank line
.a092					_IFT_SBlank:
.a092	a9 20		lda #$20			lda 	#32
.a094	20 d6 a1	jsr $a1d6			jsr 	IF_Write
.a097	ca		dex				dex
.a098	d0 f8		bne $a092			bne 	_IFT_SBlank
.a09a	a9 18		lda #$18			lda 	#IF_Height-1 				; move to X = 0,Y = A
.a09c	20 ca a0	jsr $a0ca			jsr 	IFT_SetYPos
.a09f	7a		ply				ply
.a0a0	fa		plx				plx
.a0a1	68		pla				pla
.a0a2	60		rts				rts
.a0a3					_IFT_ScrollLine:
.a0a3	da		phx				phx
.a0a4	da		phx				phx
.a0a5	8a		txa				txa 								; copy line into buffer.
.a0a6	1a		inc a				inc 	a 							; next line down.
.a0a7	20 ca a0	jsr $a0ca			jsr 	IFT_SetYPos
.a0aa	a2 00		ldx #$00			ldx 	#0
.a0ac					_IFTScrollCopy1:
.a0ac	20 c8 a1	jsr $a1c8			jsr 	IF_Read
.a0af	9d 02 02	sta $0202,x			sta 	IFT_Buffer,x
.a0b2	e8		inx				inx
.a0b3	e0 50		cpx #$50			cpx 	#IF_Width
.a0b5	d0 f5		bne $a0ac			bne 	_IFTScrollCopy1
.a0b7	68		pla				pla
.a0b8	20 ca a0	jsr $a0ca			jsr 	IFT_SetYPos
.a0bb	a2 00		ldx #$00			ldx 	#0
.a0bd					_IFTScrollCopy2:
.a0bd	bd 02 02	lda $0202,x			lda 	IFT_Buffer,x
.a0c0	20 d6 a1	jsr $a1d6			jsr 	IF_Write
.a0c3	e8		inx				inx
.a0c4	e0 50		cpx #$50			cpx 	#IF_Width
.a0c6	d0 f5		bne $a0bd			bne 	_IFTScrollCopy2
.a0c8	fa		plx				plx
.a0c9	60		rts				rts
.a0ca					IFT_SetYPos:
.a0ca	48		pha				pha
.a0cb	da		phx				phx
.a0cc	aa		tax				tax
.a0cd	20 27 a0	jsr $a027			jsr 	IFT_HomeCursor
.a0d0	e0 00		cpx #$00			cpx 	#0
.a0d2	f0 09		beq $a0dd			beq 	_IFT_MOAExit
.a0d4					_IFT_MOALoop:
.a0d4	20 b6 a1	jsr $a1b6			jsr 	IF_NewLine
.a0d7	ee 01 02	inc $0201			inc 	IFT_YCursor
.a0da	ca		dex				dex
.a0db	d0 f7		bne $a0d4			bne		_IFT_MOALoop
.a0dd					_IFT_MOAExit:
.a0dd	fa		plx				plx
.a0de	68		pla				pla
.a0df	60		rts				rts
.a0e0					IFT_GetKeyCursor:
.a0e0	20 e8 a0	jsr $a0e8			jsr 	_IFT_FlipCursor 			; reverse current
.a0e3					_IFT_GKCWait:
.a0e3	20 f9 a1	jsr $a1f9			jsr 	IF_GetKey 					; get key
.a0e6	f0 fb		beq $a0e3			beq 	_IFT_GKCWait
.a0e8					_IFT_FlipCursor:
.a0e8	48		pha				pha 								; save
.a0e9	20 c8 a1	jsr $a1c8			jsr 	IF_Read 					; read
.a0ec	20 e1 a1	jsr $a1e1			jsr 	IF_LeftOne
.a0ef	49 80		eor #$80			eor 	#$80 						; reverse
.a0f1	20 d6 a1	jsr $a1d6			jsr 	IF_Write 					; write
.a0f4	20 e1 a1	jsr $a1e1			jsr 	IF_LeftOne
.a0f7	68		pla				pla
.a0f8	60		rts				rts
.a0f9					IFT_ReadLine:
.a0f9	48		pha				pha
.a0fa					_IFT_RLLoop:
.a0fa	20 e0 a0	jsr $a0e0			jsr 	IFT_GetKeyCursor 			; get keystroke
.a0fd	c9 0d		cmp #$0d			cmp 	#13							; return
.a0ff	f0 7d		beq $a17e			beq 	_IFT_RLExit
.a101	c9 20		cmp #$20			cmp 	#32 						; control character
.a103	90 05		bcc $a10a			bcc 	_IFT_Control
.a105	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.a108	80 f0		bra $a0fa			bra 	_IFT_RLLoop
.a10a					_IFT_Control:
.a10a	c9 01		cmp #$01			cmp 	#"A"-64
.a10c	f0 26		beq $a134			beq 	_IFT_Left
.a10e	c9 04		cmp #$04			cmp 	#"D"-64
.a110	f0 2e		beq $a140			beq 	_IFT_Right
.a112	c9 17		cmp #$17			cmp 	#"W"-64
.a114	f0 36		beq $a14c			beq 	_IFT_Up
.a116	c9 13		cmp #$13			cmp 	#"S"-64
.a118	f0 3e		beq $a158			beq 	_IFT_Down
.a11a	c9 08		cmp #$08			cmp 	#"H"-64
.a11c	f0 09		beq $a127			beq 	_IFT_Backspace
.a11e	c9 1a		cmp #$1a			cmp 	#"Z"-64
.a120	d0 d8		bne $a0fa			bne 	_IFT_RLLoop
.a122	20 0c a0	jsr $a00c			jsr 	IFT_ClearScreen				; clear CTL-Z
.a125	80 d3		bra $a0fa			bra 	_IFT_RLLoop
.a127					_IFT_Backspace:
.a127	ad 00 02	lda $0200			lda 	IFT_XCursor 				; check not start of line.
.a12a	f0 ce		beq $a0fa			beq 	_IFT_RLLoop
.a12c	20 e1 a1	jsr $a1e1			jsr 	IF_LeftOne
.a12f	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.a131	20 d6 a1	jsr $a1d6			jsr 	IF_Write
.a134					_IFT_Left:
.a134	ce 00 02	dec $0200			dec 	IFT_XCursor 				; left CTL-W
.a137	10 29		bpl $a162			bpl 	_IFT_Reposition
.a139	a9 4f		lda #$4f			lda 	#IF_Width-1
.a13b					_IFT_SetX:
.a13b	8d 00 02	sta $0200			sta 	IFT_XCursor
.a13e	80 22		bra $a162			bra 	_IFT_Reposition
.a140					_IFT_Right:
.a140	ee 00 02	inc $0200			inc 	IFT_XCursor
.a143	ad 00 02	lda $0200			lda 	IFT_XCursor
.a146	49 50		eor #$50			eor 	#IF_Width
.a148	f0 f1		beq $a13b			beq 	_IFT_SetX
.a14a	80 16		bra $a162			bra 	_IFT_Reposition
.a14c					_IFT_Up:
.a14c	ce 01 02	dec $0201			dec 	IFT_YCursor
.a14f	10 11		bpl $a162			bpl 	_IFT_Reposition
.a151	a9 18		lda #$18			lda 	#IF_Height-1
.a153					_IFT_SetY:
.a153	8d 01 02	sta $0201			sta 	IFT_YCursor
.a156	80 0a		bra $a162			bra 	_IFT_Reposition
.a158					_IFT_Down:
.a158	ee 01 02	inc $0201			inc 	IFT_YCursor
.a15b	ad 01 02	lda $0201			lda 	IFT_YCursor
.a15e	49 19		eor #$19			eor 	#IF_Height
.a160	f0 f1		beq $a153			beq 	_IFT_SetY
.a162					_IFT_Reposition:
.a162	ad 00 02	lda $0200			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.a165	48		pha				pha
.a166	ad 01 02	lda $0201			lda 	IFT_YCursor
.a169	20 ca a0	jsr $a0ca			jsr 	IFT_SetYPos
.a16c	68		pla				pla
.a16d	aa		tax				tax
.a16e	e0 00		cpx #$00			cpx 	#0
.a170	f0 88		beq $a0fa			beq 	_IFT_RLLoop
.a172					_IFT_MoveRight:
.a172	20 c8 a1	jsr $a1c8			jsr 	IF_Read
.a175	ee 00 02	inc $0200			inc 	IFT_XCursor
.a178	ca		dex				dex
.a179	d0 f7		bne $a172			bne 	_IFT_MoveRight
.a17b	4c fa a0	jmp $a0fa			jmp 	_IFT_RLLoop
.a17e					_IFT_RLExit:
.a17e	ad 01 02	lda $0201			lda 	IFT_YCursor 				; go to start of line.
.a181	20 ca a0	jsr $a0ca			jsr 	IFT_SetYPos
.a184	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.a186					_IFT_RLRead:
.a186	20 c8 a1	jsr $a1c8			jsr 	IF_Read
.a189	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.a18c	e8		inx				inx
.a18d	e0 50		cpx #$50			cpx 	#IF_Width
.a18f	d0 f5		bne $a186			bne 	_IFT_RLRead
.a191					_IFT_RL_Trim:
.a191	ca		dex				dex 	 							; previous char
.a192	30 07		bmi $a19b			bmi 	_IFT_Found 					; gone too far
.a194	bd 66 02	lda $0266,x			lda 	IFT_LineBuffer,x			; go back if space
.a197	c9 20		cmp #$20			cmp 	#" "
.a199	f0 f6		beq $a191			beq 	_IFT_RL_Trim
.a19b					_IFT_Found:
.a19b	e8		inx				inx 								; forward to non-space
.a19c	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.a19e	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.a1a1	68		pla				pla
.a1a2	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.a1a4	a0 02		ldy #$02			ldy 	#IFT_LineBuffer >> 8
.a1a6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_mega65.asm

=80					IF_Width 	= 80 							; characters across
=25					IF_Height 	= 25 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line
=6					IF_XPos 	= 6 							; current position, horizontal.
=8					IF_FarPtr 	= 8 							; far pointer (4 bytes)
=$1000					IF_Screen = $1000							; 2k screen RAM here
=$800					IF_CharSet = $800							; 2k character set (0-7F) here
.a1a7					IF_Home:
.a1a7	48		pha				pha 								; reset cursor position
.a1a8	a9 00		lda #$00			lda 	#IF_Screen & $FF
.a1aa	85 04		sta $04				sta 	IF_Pos
.a1ac	a9 10		lda #$10			lda 	#IF_Screen >> 8
.a1ae	85 05		sta $05				sta 	IF_Pos+1
.a1b0	a9 00		lda #$00			lda 	#0
.a1b2	85 06		sta $06				sta 	IF_XPos
.a1b4	68		pla				pla
.a1b5	60		rts				rts
.a1b6					IF_NewLine:
.a1b6	48		pha				pha
.a1b7	a9 00		lda #$00			lda 	#0 							; back to start of line
.a1b9	85 06		sta $06				sta 	IF_XPos
.a1bb	18		clc				clc 								; down one line
.a1bc	a5 04		lda $04				lda 	IF_Pos
.a1be	69 50		adc #$50			adc 	#80
.a1c0	85 04		sta $04				sta 	IF_Pos
.a1c2	90 02		bcc $a1c6			bcc 	_IF_NoCarry 				; carry through.
.a1c4	e6 05		inc $05				inc 	IF_Pos+1
.a1c6					_IF_NoCarry:
.a1c6	68		pla				pla
.a1c7	60		rts				rts
.a1c8					IF_Read:
.a1c8	5a		phy				phy 								; save current Y
.a1c9	a4 06		ldy $06				ldy 	IF_XPos 					; read character at current position
.a1cb	b1 04		lda ($04),y			lda 	(IF_Pos),y
.a1cd	49 20		eor #$20			eor 	#$20
.a1cf	18		clc				clc
.a1d0	69 20		adc #$20			adc 	#$20
.a1d2	e6 06		inc $06				inc 	IF_XPos 					; step right.
.a1d4	7a		ply				ply									; restore Y
.a1d5	60		rts				rts
.a1d6					IF_Write:
.a1d6	5a		phy				phy 								; save current Y
.a1d7	a4 06		ldy $06				ldy 	IF_XPos 					; write character at current position
.a1d9	29 bf		and #$bf			and 	#63+128 					; PETSCII
.a1db	91 04		sta ($04),y			sta 	(IF_Pos),y
.a1dd	e6 06		inc $06				inc 	IF_XPos 					; step right.
.a1df	7a		ply				ply									; restore Y
.a1e0	60		rts				rts
.a1e1					IF_LeftOne:
.a1e1	c6 06		dec $06				dec 	IF_XPos
.a1e3	60		rts				rts
.a1e4					IF_CheckBreak:
.a1e4	db		phz				phz
.a1e5	20 2d a2	jsr $a22d			jsr 	IF_SetupKeyAddress 			; point to keyboard
.a1e8	e6 08		inc $08				inc 	IF_FarPtr 					; point to modifiers.
.a1ea	ea		nop				nop 								; read modifiers.
.a1eb	b2 08		lda ($08),z			lda 	(IF_FarPtr),z
.a1ed	fb		plz				plz 								; restore Z
.a1ee	29 05		and #$05			and 	#5							; break is LeftShift+Ctrl
.a1f0	c9 05		cmp #$05			cmp 	#5
.a1f2	f0 02		beq $a1f6			beq 	_IF_CBExit
.a1f4	a9 00		lda #$00			lda 	#0
.a1f6					_IF_CBExit:
.a1f6	c9 00		cmp #$00			cmp 	#0
.a1f8	60		rts				rts
.a1f9					IF_GetKey:
.a1f9	db		phz				phz
.a1fa	20 2d a2	jsr $a22d			jsr 	IF_SetupKeyAddress
.a1fd	ea		nop				nop 								; read keyboard
.a1fe	b2 08		lda ($08),z			lda 	(IF_FarPtr),z
.a200	c9 14		cmp #$14			cmp 	#20
.a202	d0 02		bne $a206			bne 	_KMNo
.a204	a9 08		lda #$08			lda 	#"H"-64
.a206					_KMNo:
.a206	c9 91		cmp #$91			cmp 	#145
.a208	d0 02		bne $a20c			bne 	_KMNo
.a20a	a9 17		lda #$17			lda 	#"W"-64
.a20c					_KMNo:
.a20c	c9 11		cmp #$11			cmp 	#17
.a20e	d0 02		bne $a212			bne 	_KMNo
.a210	a9 13		lda #$13			lda 	#"S"-64
.a212					_KMNo:
.a212	c9 9d		cmp #$9d			cmp 	#157
.a214	d0 02		bne $a218			bne 	_KMNo
.a216	a9 01		lda #$01			lda 	#"A"-64
.a218					_KMNo:
.a218	c9 1d		cmp #$1d			cmp 	#29
.a21a	d0 02		bne $a21e			bne 	_KMNo
.a21c	a9 04		lda #$04			lda 	#"D"-64
.a21e					_KMNo:
.a21e	c9 00		cmp #$00			cmp 	#0
.a220	f0 07		beq $a229			beq 	_IFGKEmpty
.a222	48		pha				pha
.a223	a9 00		lda #$00			lda 	#0
.a225	ea		nop				nop
.a226	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a228	68		pla				pla
.a229					_IFGKEmpty:
.a229	fb		plz				plz
.a22a	c9 00		cmp #$00			cmp 	#0 							; set Z
.a22c	60		rts				rts
.a22d					IF_SetupKeyAddress:
.a22d	a9 0f		lda #$0f			lda 	#$0F 						; set up to write to read keyboard.
.a22f	85 0b		sta $0b				sta 	IF_FarPtr+3
.a231	a9 fd		lda #$fd			lda 	#$FD
.a233	85 0a		sta $0a				sta 	IF_FarPtr+2
.a235	a9 36		lda #$36			lda 	#$36
.a237	85 09		sta $09				sta 	IF_FarPtr+1
.a239	a9 10		lda #$10			lda 	#$10
.a23b	85 08		sta $08				sta 	IF_FarPtr+0
.a23d	a3 00		ldz #$00			ldz 	#0
.a23f	60		rts				rts
.a240					IF_Reset:
.a240	48		pha				pha 								; save registers
.a241	da		phx				phx
.a242	5a		phy				phy
.a243	a9 0f		lda #$0f			lda 	#$0F 						; set up to write to video system.
.a245	85 0b		sta $0b				sta 	IF_FarPtr+3
.a247	a9 fd		lda #$fd			lda 	#$FD
.a249	85 0a		sta $0a				sta 	IF_FarPtr+2
.a24b	a9 30		lda #$30			lda 	#$30
.a24d	85 09		sta $09				sta 	IF_FarPtr+1
.a24f	a9 00		lda #$00			lda 	#$00
.a251	85 08		sta $08				sta 	IF_FarPtr+0
.a253	a3 2f		ldz #$2f			ldz 	#$2F 						; address already set up
.a255	a9 47		lda #$47			lda 	#$47
.a257	ea		nop				nop
.a258	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a25a	a3 2f		ldz #$2f			ldz 	#$2F 						; address already set up
.a25c	a9 53		lda #$53			lda 	#$53
.a25e	ea		nop				nop
.a25f	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a261	a3 30		ldz #$30			ldz 	#$30 						; address already set up
.a263	a9 40		lda #$40			lda 	#$40
.a265	ea		nop				nop
.a266	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a268	a3 31		ldz #$31			ldz 	#$31 						; address already set up
.a26a	a9 c0		lda #$c0			lda 	#$80+$40
.a26c	ea		nop				nop
.a26d	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a26f	a3 20		ldz #$20			ldz 	#$20 						; address already set up
.a271	a9 00		lda #$00			lda 	#0
.a273	ea		nop				nop
.a274	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a276	a3 21		ldz #$21			ldz 	#$21 						; address already set up
.a278	a9 00		lda #$00			lda 	#0
.a27a	ea		nop				nop
.a27b	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a27d	a3 54		ldz #$54			ldz 	#$54 						; address already set up
.a27f	a9 40		lda #$40			lda 	#$40
.a281	ea		nop				nop
.a282	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a284	a3 01		ldz #$01			ldz 	#$01 						; address already set up
.a286	a9 ff		lda #$ff			lda 	#$FF
.a288	ea		nop				nop
.a289	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a28b	a3 00		ldz #$00			ldz 	#$00 						; address already set up
.a28d	a9 ff		lda #$ff			lda 	#$FF
.a28f	ea		nop				nop
.a290	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a292	a3 16		ldz #$16			ldz 	#$16 						; address already set up
.a294	a9 cc		lda #$cc			lda 	#$CC
.a296	ea		nop				nop
.a297	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a299	a3 18		ldz #$18			ldz 	#$18 						; address already set up
.a29b	a9 42		lda #$42			lda 	#$42
.a29d	ea		nop				nop
.a29e	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2a0	a3 11		ldz #$11			ldz 	#$11 						; address already set up
.a2a2	a9 1b		lda #$1b			lda 	#$1B
.a2a4	ea		nop				nop
.a2a5	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2a7	a9 00		lda #$00			lda 	#$00						; colour RAM at $1F800-1FFFF (2kb)
.a2a9	85 0b		sta $0b				sta 	IF_FarPtr+3
.a2ab	a9 01		lda #$01			lda 	#$01
.a2ad	85 0a		sta $0a				sta 	IF_FarPtr+2
.a2af	a9 f8		lda #$f8			lda 	#$F8
.a2b1	85 09		sta $09				sta 	IF_FarPtr+1
.a2b3	a9 00		lda #$00			lda 	#$00
.a2b5	85 08		sta $08				sta 	IF_FarPtr+0
.a2b7	a3 00		ldz #$00			ldz 	#0
.a2b9					_EXTClearColorRam:
.a2b9	a9 05		lda #$05			lda 	#5							; fill that with this colour.
.a2bb	ea		nop				nop
.a2bc	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2be	3b		dez				dez
.a2bf	d0 f8		bne $a2b9			bne 	_EXTClearColorRam
.a2c1	e6 09		inc $09				inc 	IF_FarPtr+1
.a2c3	d0 f4		bne $a2b9			bne 	_EXTClearColorRam
.a2c5	a2 00		ldx #$00			ldx 	#0 							; copy PET Font into memory.
.a2c7					_EXTCopyCBMFont:
.a2c7	bd 08 a3	lda $a308,x			lda 	IF_CBMFont,x 				; +$800 uses the lower case c/set
.a2ca	9d 00 08	sta $0800,x			sta 	IF_CharSet,x
.a2cd	49 ff		eor #$ff			eor 	#$FF
.a2cf	9d 00 0c	sta $0c00,x			sta 	IF_CharSet+$400,x
.a2d2	bd 08 a4	lda $a408,x			lda 	IF_CBMFont+$100,x
.a2d5	9d 00 09	sta $0900,x			sta 	IF_CharSet+$100,x
.a2d8	49 ff		eor #$ff			eor 	#$FF
.a2da	9d 00 0d	sta $0d00,x			sta 	IF_CharSet+$500,x
.a2dd	bd 08 a5	lda $a508,x			lda 	IF_CBMFont+$200,x
.a2e0	9d 00 0a	sta $0a00,x			sta 	IF_CharSet+$200,x
.a2e3	49 ff		eor #$ff			eor 	#$FF
.a2e5	9d 00 0e	sta $0e00,x			sta 	IF_CharSet+$600,x
.a2e8	bd 08 a6	lda $a608,x			lda 	IF_CBMFont+$300,x
.a2eb	9d 00 0b	sta $0b00,x			sta 	IF_CharSet+$300,x
.a2ee	49 ff		eor #$ff			eor 	#$FF
.a2f0	9d 00 0f	sta $0f00,x			sta 	IF_CharSet+$700,x
.a2f3	ca		dex				dex
.a2f4	d0 d1		bne $a2c7			bne 	_EXTCopyCBMFont
.a2f6	a9 3b		lda #$3b			lda 	#$3F-4  					; puts ROM back in the map (the -4)
.a2f8	85 01		sta $01				sta 	$01
.a2fa	a9 00		lda #$00			lda 	#$00						; do not map bytes 0000-7FFF
.a2fc	a2 00		ldx #$00			ldx 	#$00						; (so we use the RAM physically at $0000-$7FFF)
.a2fe	a0 00		ldy #$00			ldy 	#$00 						; 8000-FFFF offset by $200. The lower 8 bits are $00
.a300	a3 f2		ldz #$f2			ldz 	#$F2 						; so this is an actual offset of $20000. So the space at
.a302	5c		map				map
.a303	ea		nop				eom
.a304	7a		ply				ply 								; restore and exit.
.a305	fa		plx				plx
.a306	68		pla				pla
.a307	60		rts				rts
.a308					IF_CBMFont:
>a308	1c 22 4a 56 4c 20 1e 00				.binary "pet-font.bin"
>a310	18 24 42 7e 42 42 42 00 7c 22 22 3c 22 22 7c 00
>a320	1c 22 40 40 40 22 1c 00 78 24 22 22 22 24 78 00
>a330	7e 40 40 78 40 40 7e 00 7e 40 40 78 40 40 40 00
>a340	1c 22 40 4e 42 22 1c 00 42 42 42 7e 42 42 42 00
>a350	1c 08 08 08 08 08 1c 00 0e 04 04 04 04 44 38 00
>a360	42 44 48 70 48 44 42 00 40 40 40 40 40 40 7e 00
>a370	42 66 5a 5a 42 42 42 00 42 62 52 4a 46 42 42 00
>a380	18 24 42 42 42 24 18 00 7c 42 42 7c 40 40 40 00
>a390	18 24 42 42 4a 24 1a 00 7c 42 42 7c 48 44 42 00
>a3a0	3c 42 40 3c 02 42 3c 00 3e 08 08 08 08 08 08 00
>a3b0	42 42 42 42 42 42 3c 00 42 42 42 24 24 18 18 00
>a3c0	42 42 42 5a 5a 66 42 00 42 42 24 18 24 42 42 00
>a3d0	22 22 22 1c 08 08 08 00 7e 02 04 18 20 40 7e 00
>a3e0	3c 20 20 20 20 20 3c 00 00 40 20 10 08 04 02 00
>a3f0	3c 04 04 04 04 04 3c 00 00 08 1c 2a 08 08 08 08
>a400	00 00 10 20 7f 20 10 00 00 00 00 00 00 00 00 00
>a410	08 08 08 08 00 00 08 00 24 24 24 00 00 00 00 00
>a420	24 24 7e 24 7e 24 24 00 08 1e 28 1c 0a 3c 08 00
>a430	00 62 64 08 10 26 46 00 30 48 48 30 4a 44 3a 00
>a440	04 08 10 00 00 00 00 00 04 08 10 10 10 08 04 00
>a450	20 10 08 08 08 10 20 00 08 2a 1c 3e 1c 2a 08 00
>a460	00 08 08 3e 08 08 00 00 00 00 00 00 00 08 08 10
>a470	00 00 00 7e 00 00 00 00 00 00 00 00 00 18 18 00
>a480	00 02 04 08 10 20 40 00 3c 42 46 5a 62 42 3c 00
>a490	08 18 28 08 08 08 3e 00 3c 42 02 0c 30 40 7e 00
>a4a0	3c 42 02 1c 02 42 3c 00 04 0c 14 24 7e 04 04 00
>a4b0	7e 40 78 04 02 44 38 00 1c 20 40 7c 42 42 3c 00
>a4c0	7e 42 04 08 10 10 10 00 3c 42 42 3c 42 42 3c 00
>a4d0	3c 42 42 3e 02 04 38 00 00 00 08 00 00 08 00 00
>a4e0	00 00 08 00 00 08 08 10 0e 18 30 60 30 18 0e 00
>a4f0	00 00 7e 00 7e 00 00 00 70 18 0c 06 0c 18 70 00
>a500	3c 42 02 0c 10 00 10 00 00 00 00 00 ff 00 00 00
>a510	08 1c 3e 7f 7f 1c 3e 00 10 10 10 10 10 10 10 10
>a520	00 00 00 ff 00 00 00 00 00 00 ff 00 00 00 00 00
>a530	00 ff 00 00 00 00 00 00 00 00 00 00 00 ff 00 00
>a540	20 20 20 20 20 20 20 20 04 04 04 04 04 04 04 04
>a550	00 00 00 00 e0 10 08 08 08 08 08 04 03 00 00 00
>a560	08 08 08 10 e0 00 00 00 80 80 80 80 80 80 80 ff
>a570	80 40 20 10 08 04 02 01 01 02 04 08 10 20 40 80
>a580	ff 80 80 80 80 80 80 80 ff 01 01 01 01 01 01 01
>a590	00 3c 7e 7e 7e 7e 3c 00 00 00 00 00 00 00 ff 00
>a5a0	36 7f 7f 7f 3e 1c 08 00 40 40 40 40 40 40 40 40
>a5b0	00 00 00 00 03 04 08 08 81 42 24 18 18 24 42 81
>a5c0	00 3c 42 42 42 42 3c 00 08 1c 2a 77 2a 08 08 00
>a5d0	02 02 02 02 02 02 02 02 08 1c 3e 7f 3e 1c 08 00
>a5e0	08 08 08 08 ff 08 08 08 a0 50 a0 50 a0 50 a0 50
>a5f0	08 08 08 08 08 08 08 08 00 00 01 3e 54 14 14 00
>a600	ff 7f 3f 1f 0f 07 03 01 00 00 00 00 00 00 00 00
>a610	f0 f0 f0 f0 f0 f0 f0 f0 00 00 00 00 ff ff ff ff
>a620	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff
>a630	80 80 80 80 80 80 80 80 aa 55 aa 55 aa 55 aa 55
>a640	01 01 01 01 01 01 01 01 00 00 00 00 aa 55 aa 55
>a650	ff fe fc f8 f0 e0 c0 80 03 03 03 03 03 03 03 03
>a660	08 08 08 08 0f 08 08 08 00 00 00 00 0f 0f 0f 0f
>a670	08 08 08 08 0f 00 00 00 00 00 00 00 f8 08 08 08
>a680	00 00 00 00 00 00 ff ff 00 00 00 00 0f 08 08 08
>a690	08 08 08 08 ff 00 00 00 00 00 00 00 ff 08 08 08
>a6a0	08 08 08 08 f8 08 08 08 c0 c0 c0 c0 c0 c0 c0 c0
>a6b0	e0 e0 e0 e0 e0 e0 e0 e0 07 07 07 07 07 07 07 07
>a6c0	ff ff 00 00 00 00 00 00 ff ff ff 00 00 00 00 00
>a6d0	00 00 00 00 00 ff ff ff 01 01 01 01 01 01 01 ff
>a6e0	00 00 00 00 f0 f0 f0 f0 0f 0f 0f 0f 00 00 00 00
>a6f0	08 08 08 08 f8 00 00 00 f0 f0 f0 f0 00 00 00 00
>a700	f0 f0 f0 f0 0f 0f 0f 0f 1c 22 4a 56 4c 20 1e 00
>a710	18 24 42 7e 42 42 42 00 7c 22 22 3c 22 22 7c 00
>a720	1c 22 40 40 40 22 1c 00 78 24 22 22 22 24 78 00
>a730	7e 40 40 78 40 40 7e 00 7e 40 40 78 40 40 40 00
>a740	1c 22 40 4e 42 22 1c 00 42 42 42 7e 42 42 42 00
>a750	1c 08 08 08 08 08 1c 00 0e 04 04 04 04 44 38 00
>a760	42 44 48 70 48 44 42 00 40 40 40 40 40 40 7e 00
>a770	42 66 5a 5a 42 42 42 00 42 62 52 4a 46 42 42 00
>a780	18 24 42 42 42 24 18 00 7c 42 42 7c 40 40 40 00
>a790	18 24 42 42 4a 24 1a 00 7c 42 42 7c 48 44 42 00
>a7a0	3c 42 40 3c 02 42 3c 00 3e 08 08 08 08 08 08 00
>a7b0	42 42 42 42 42 42 3c 00 42 42 42 24 24 18 18 00
>a7c0	42 42 42 5a 5a 66 42 00 42 42 24 18 24 42 42 00
>a7d0	22 22 22 1c 08 08 08 00 7e 02 04 18 20 40 7e 00
>a7e0	3c 20 20 20 20 20 3c 00 00 40 20 10 08 04 02 00
>a7f0	3c 04 04 04 04 04 3c 00 00 08 1c 2a 08 08 08 08
>a800	00 00 10 20 7f 20 10 00 00 00 00 00 00 00 00 00
>a810	08 08 08 08 00 00 08 00 24 24 24 00 00 00 00 00
>a820	24 24 7e 24 7e 24 24 00 08 1e 28 1c 0a 3c 08 00
>a830	00 62 64 08 10 26 46 00 30 48 48 30 4a 44 3a 00
>a840	04 08 10 00 00 00 00 00 04 08 10 10 10 08 04 00
>a850	20 10 08 08 08 10 20 00 08 2a 1c 3e 1c 2a 08 00
>a860	00 08 08 3e 08 08 00 00 00 00 00 00 00 08 08 10
>a870	00 00 00 7e 00 00 00 00 00 00 00 00 00 18 18 00
>a880	00 02 04 08 10 20 40 00 3c 42 46 5a 62 42 3c 00
>a890	08 18 28 08 08 08 3e 00 3c 42 02 0c 30 40 7e 00
>a8a0	3c 42 02 1c 02 42 3c 00 04 0c 14 24 7e 04 04 00
>a8b0	7e 40 78 04 02 44 38 00 1c 20 40 7c 42 42 3c 00
>a8c0	7e 42 04 08 10 10 10 00 3c 42 42 3c 42 42 3c 00
>a8d0	3c 42 42 3e 02 04 38 00 00 00 08 00 00 08 00 00
>a8e0	00 00 08 00 00 08 08 10 0e 18 30 60 30 18 0e 00
>a8f0	00 00 7e 00 7e 00 00 00 70 18 0c 06 0c 18 70 00
>a900	3c 42 02 0c 10 00 10 00 00 00 00 00 ff 00 00 00
>a910	00 00 38 04 3c 44 3a 00 40 40 5c 62 42 62 5c 00
>a920	00 00 3c 42 40 42 3c 00 02 02 3a 46 42 46 3a 00
>a930	00 00 3c 42 7e 40 3c 00 0c 12 10 7c 10 10 10 00
>a940	00 00 3a 46 46 3a 02 3c 40 40 5c 62 42 42 42 00
>a950	08 00 18 08 08 08 1c 00 04 00 0c 04 04 04 44 38
>a960	40 40 44 48 50 68 44 00 18 08 08 08 08 08 1c 00
>a970	00 00 76 49 49 49 49 00 00 00 5c 62 42 42 42 00
>a980	00 00 3c 42 42 42 3c 00 00 00 5c 62 62 5c 40 40
>a990	00 00 3a 46 46 3a 02 02 00 00 5c 62 40 40 40 00
>a9a0	00 00 3e 40 3c 02 7c 00 10 10 7c 10 10 12 0c 00
>a9b0	00 00 42 42 42 46 3a 00 00 00 42 42 42 24 18 00
>a9c0	00 00 41 49 49 49 36 00 00 00 42 24 18 24 42 00
>a9d0	00 00 42 42 46 3a 02 3c 00 00 7e 04 18 20 7e 00
>a9e0	08 08 08 08 ff 08 08 08 a0 50 a0 50 a0 50 a0 50
>a9f0	08 08 08 08 08 08 08 08 cc cc 33 33 cc cc 33 33
>aa00	cc 66 33 99 cc 66 33 99 00 00 00 00 00 00 00 00
>aa10	f0 f0 f0 f0 f0 f0 f0 f0 00 00 00 00 ff ff ff ff
>aa20	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff
>aa30	80 80 80 80 80 80 80 80 aa 55 aa 55 aa 55 aa 55
>aa40	01 01 01 01 01 01 01 01 00 00 00 00 aa 55 aa 55
>aa50	99 33 66 cc 99 33 66 cc 03 03 03 03 03 03 03 03
>aa60	08 08 08 08 0f 08 08 08 00 00 00 00 0f 0f 0f 0f
>aa70	08 08 08 08 0f 00 00 00 00 00 00 00 f8 08 08 08
>aa80	00 00 00 00 00 00 ff ff 00 00 00 00 0f 08 08 08
>aa90	08 08 08 08 ff 00 00 00 00 00 00 00 ff 08 08 08
>aaa0	08 08 08 08 f8 08 08 08 c0 c0 c0 c0 c0 c0 c0 c0
>aab0	e0 e0 e0 e0 e0 e0 e0 e0 07 07 07 07 07 07 07 07
>aac0	ff ff 00 00 00 00 00 00 ff ff ff 00 00 00 00 00
>aad0	00 00 00 00 00 ff ff ff 01 02 44 48 50 60 40 00
>aae0	00 00 00 00 f0 f0 f0 f0 0f 0f 0f 0f 00 00 00 00
>aaf0	08 08 08 08 f8 00 00 00 f0 f0 f0 f0 00 00 00 00
>ab00	f0 f0 f0 f0 0f 0f 0f 0f

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/errors.asm

.ab08					SyntaxError:
.ab08	20 37 ab	jsr $ab37			jsr 	ERR_Handler
>ab0b	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>ab13	72 72 6f 72 00
.ab18					TypeError:
.ab18	20 37 ab	jsr $ab37			jsr 	ERR_Handler
>ab1b	57 72 6f 6e 67 20 74 79				.text 	"Wrong type",0
>ab23	70 65 00
.ab26					BadParamError:
.ab26	20 37 ab	jsr $ab37			jsr 	ERR_Handler
>ab29	42 61 64 20 50 61 72 61				.text 	"Bad Parameter",0
>ab31	6d 65 74 65 72 00
.ab37					ERR_Handler:
.ab37	a0 00		ldy #$00			ldy 	#0
.ab39	c8		iny				iny
.ab3a	b1 16		lda ($16),y			lda 	(zCodePtr),y
.ab3c	8d 08 03	sta $0308			sta 	XS_Mantissa
.ab3f	c8		iny				iny
.ab40	b1 16		lda ($16),y			lda 	(zCodePtr),y
.ab42	8d 09 03	sta $0309			sta 	XS_Mantissa+1
.ab45	fa		plx				plx 								; address in XY
.ab46	7a		ply				ply
.ab47	e8		inx				inx 								; bump, because of RTS/JSR address -1
.ab48	d0 01		bne $ab4b			bne 	_EHNoSkip
.ab4a	c8		iny				iny
.ab4b					_EHNoSkip:
.ab4b	20 6c ab	jsr $ab6c			jsr 	PrintROMMessage 			; print message from ROM.
.ab4e	ad 08 03	lda $0308			lda 	XS_Mantissa					; line number = 0
.ab51	0d 09 03	ora $0309			ora 	XS_Mantissa+1
.ab54	f0 0c		beq $ab62			beq 	_EHNoLine
.ab56	a2 67		ldx #$67			ldx 	#_EHAt & $FF 				; print " at "
.ab58	a0 ab		ldy #$ab			ldy 	#(_EHAt >> 8) & $FF
.ab5a	20 6c ab	jsr $ab6c			jsr 	PrintROMMessage
.ab5d	a2 00		ldx #$00			ldx 	#0 							; Print line number
.ab5f	20 7d ab	jsr $ab7d			jsr 	Print16BitInteger
.ab62					_EHNoLine:
.ab62	80 fe		bra $ab62			bra 	_EHNoLine
.ab64	4c c2 ad	jmp $adc2			jmp 	WarmStart
>ab67	20 61 74 20 00			_EHAt:	.text 	" at ",0
.ab6c					PrintROMMessage:
.ab6c	86 1a		stx $1a				stx 	zLTemp1 					; save addres
.ab6e	84 1b		sty $1b				sty 	zLTemp1+1
.ab70	a0 00		ldy #$00			ldy 	#0
.ab72					_PRMLoop:
.ab72	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.ab74	f0 06		beq $ab7c			beq		_PRMExit
.ab76	c8		iny				iny
.ab77	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.ab7a	80 f6		bra $ab72			bra 	_PRMLoop
.ab7c					_PRMExit:
.ab7c	60		rts				rts
.ab7d					Print16BitInteger:
.ab7d	a9 00		lda #$00			lda 	#0 							; make 32 bit
.ab7f	8d 0a 03	sta $030a			sta 	XS_Mantissa+2
.ab82	8d 0b 03	sta $030b			sta 	XS_Mantissa+3
.ab85	8d 20 04	sta $0420			sta 	NumBufX 					; reset the conversion pointer
.ab88	aa		tax				tax 								; convert bottom level.
.ab89	20 1e b8	jsr $b81e			jsr 	INTToString 				; make string
.ab8c	a2 00		ldx #$00			ldx 	#0 							; print buffer
.ab8e	bd 00 04	lda $0400,x	_P1Loop:lda 	Num_Buffer,x
.ab91	f0 06		beq $ab99			beq 	_P1Exit
.ab93	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.ab96	e8		inx				inx
.ab97	80 f5		bra $ab8e			bra 	_P1Loop
.ab99	60		rts		_P1Exit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm


;******  Processing file: modules/basic/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b4					lastUnaryFunction = $b4
.ab9a					VectorTable:
>ab9a	3f b0					.word BinaryOp_And         & $FFFF ; $80 and
>ab9c	67 b0					.word BinaryOp_Or          & $FFFF ; $81 or
>ab9e	8f b0					.word BinaryOp_Xor         & $FFFF ; $82 xor
>aba0	8f b0					.word BinaryOp_Eor         & $FFFF ; $83 eor
>aba2	d3 b0					.word Binary_Equal         & $FFFF ; $84 =
>aba4	f2 b0					.word Binary_NotEqual      & $FFFF ; $85 <>
>aba6	fb b0					.word Binary_Less          & $FFFF ; $86 <
>aba8	04 b1					.word Binary_LessEqual     & $FFFF ; $87 <=
>abaa	16 b1					.word Binary_Greater       & $FFFF ; $88 >
>abac	0d b1					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>abae	ab b1					.word BinaryOp_Add         & $FFFF ; $8a +
>abb0	cb b1					.word BinaryOp_Subtract    & $FFFF ; $8b -
>abb2	de b1					.word BinaryOp_Multiply    & $FFFF ; $8c *
>abb4	f1 b1					.word BinaryOp_Divide      & $FFFF ; $8d /
>abb6	4e ac					.word NotImplemented       & $FFFF ; $8e ^
>abb8	4e ac					.word NotImplemented       & $FFFF ; $8f if
>abba	4e ac					.word NotImplemented       & $FFFF ; $90 while
>abbc	4e ac					.word NotImplemented       & $FFFF ; $91 repeat
>abbe	4e ac					.word NotImplemented       & $FFFF ; $92 for
>abc0	4e ac					.word NotImplemented       & $FFFF ; $93 then
>abc2	4e ac					.word NotImplemented       & $FFFF ; $94 endif
>abc4	4e ac					.word NotImplemented       & $FFFF ; $95 wend
>abc6	4e ac					.word NotImplemented       & $FFFF ; $96 until
>abc8	4e ac					.word NotImplemented       & $FFFF ; $97 next
>abca	4e ac					.word NotImplemented       & $FFFF ; $98 not
>abcc	4e ac					.word NotImplemented       & $FFFF ; $99 fn(
>abce	25 b3					.word Unary_Abs            & $FFFF ; $9a abs(
>abd0	79 b4					.word Unary_Asc            & $FFFF ; $9b asc(
>abd2	ff bf					.word Unary_Int            & $FFFF ; $9c int(
>abd4	43 b3					.word Unary_Peek           & $FFFF ; $9d peek(
>abd6	76 bf					.word Unary_Rnd            & $FFFF ; $9e rnd(
>abd8	b7 b3					.word Unary_Usr            & $FFFF ; $9f usr(
>abda	ba b4					.word Unary_Left           & $FFFF ; $a0 left$(
>abdc	d1 b4					.word Unary_Right          & $FFFF ; $a1 right$(
>abde	9f b4					.word Unary_Mid            & $FFFF ; $a2 mid$(
>abe0	33 b6					.word Unary_Spc            & $FFFF ; $a3 spc(
>abe2	46 b4					.word Unary_Str            & $FFFF ; $a4 str$(
>abe4	d8 b3					.word Unary_Val            & $FFFF ; $a5 val(
>abe6	90 b4					.word Unary_Len            & $FFFF ; $a6 len(
>abe8	4f b5					.word Unary_Hex            & $FFFF ; $a7 hex$(
>abea	4e ac					.word NotImplemented       & $FFFF ; $a8 sin(
>abec	4e ac					.word NotImplemented       & $FFFF ; $a9 cos(
>abee	4e ac					.word NotImplemented       & $FFFF ; $aa tan(
>abf0	4e ac					.word NotImplemented       & $FFFF ; $ab atn(
>abf2	4e ac					.word NotImplemented       & $FFFF ; $ac exp(
>abf4	4e ac					.word NotImplemented       & $FFFF ; $ad log(
>abf6	4e ac					.word NotImplemented       & $FFFF ; $ae sqr(
>abf8	a9 b5					.word Unary_Dec            & $FFFF ; $af dec(
>abfa	47 b3					.word Unary_Deek           & $FFFF ; $b0 deek(
>abfc	4b b3					.word Unary_Leek           & $FFFF ; $b1 leek(
>abfe	7f b3					.word Unary_Mod            & $FFFF ; $b2 mod(
>ac00	d3 b2					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>ac02	11 b6					.word Unary_Chr            & $FFFF ; $b4 chr$(
>ac04	4e ac					.word NotImplemented       & $FFFF ; $b5 $(
>ac06	4e ac					.word NotImplemented       & $FFFF ; $b6 $
>ac08	4e ac					.word NotImplemented       & $FFFF ; $b7 #(
>ac0a	4e ac					.word NotImplemented       & $FFFF ; $b8 #
>ac0c	4e ac					.word NotImplemented       & $FFFF ; $b9 %(
>ac0e	4e ac					.word NotImplemented       & $FFFF ; $ba %
>ac10	4e ac					.word NotImplemented       & $FFFF ; $bb (
>ac12	4e ac					.word NotImplemented       & $FFFF ; $bc )
>ac14	4e ac					.word NotImplemented       & $FFFF ; $bd ,
>ac16	4e ac					.word NotImplemented       & $FFFF ; $be :
>ac18	4e ac					.word NotImplemented       & $FFFF ; $bf ;
>ac1a	4e ac					.word NotImplemented       & $FFFF ; $c0 def
>ac1c	5d ae					.word Command_CLR          & $FFFF ; $c1 clr
>ac1e	68 ae					.word Command_STOP         & $FFFF ; $c2 stop
>ac20	4e ac					.word NotImplemented       & $FFFF ; $c3 data
>ac22	4e ac					.word NotImplemented       & $FFFF ; $c4 read
>ac24	4e ac					.word NotImplemented       & $FFFF ; $c5 dim
>ac26	4e ac					.word NotImplemented       & $FFFF ; $c6 to
>ac28	4e ac					.word NotImplemented       & $FFFF ; $c7 step
>ac2a	4e ac					.word NotImplemented       & $FFFF ; $c8 gosub
>ac2c	4e ac					.word NotImplemented       & $FFFF ; $c9 return
>ac2e	4e ac					.word NotImplemented       & $FFFF ; $ca goto
>ac30	3c ae					.word Command_END          & $FFFF ; $cb end
>ac32	4e ac					.word NotImplemented       & $FFFF ; $cc input
>ac34	4e ac					.word NotImplemented       & $FFFF ; $cd let
>ac36	4e ac					.word NotImplemented       & $FFFF ; $ce list
>ac38	4e ac					.word NotImplemented       & $FFFF ; $cf new
>ac3a	4e ac					.word NotImplemented       & $FFFF ; $d0 old
>ac3c	4e ac					.word NotImplemented       & $FFFF ; $d1 on
>ac3e	4e ac					.word NotImplemented       & $FFFF ; $d2 restore
>ac40	4e ac					.word NotImplemented       & $FFFF ; $d3 poke
>ac42	4e ac					.word NotImplemented       & $FFFF ; $d4 print
>ac44	c8 ad					.word Command_RUN          & $FFFF ; $d5 run
>ac46	4e ac					.word NotImplemented       & $FFFF ; $d6 wait
>ac48	4e ac					.word NotImplemented       & $FFFF ; $d7 doke
>ac4a	4e ac					.word NotImplemented       & $FFFF ; $d8 loke
>ac4c	41 ae					.word Command_ASSERT       & $FFFF ; $d9 assert
.ac4e					NotImplemented:
.ac4e	20 37 ab	jsr $ab37			jsr ERR_Handler
>ac51	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>ac59	65 6d 65 6e 74 65 64 00
.ac61					BinaryPrecedence:
>ac61	01					.byte 1    ; $80 and
>ac62	01					.byte 1    ; $81 or
>ac63	01					.byte 1    ; $82 xor
>ac64	01					.byte 1    ; $83 eor
>ac65	02					.byte 2    ; $84 =
>ac66	02					.byte 2    ; $85 <>
>ac67	02					.byte 2    ; $86 <
>ac68	02					.byte 2    ; $87 <=
>ac69	02					.byte 2    ; $88 >
>ac6a	02					.byte 2    ; $89 >=
>ac6b	03					.byte 3    ; $8a +
>ac6c	03					.byte 3    ; $8b -
>ac6d	04					.byte 4    ; $8c *
>ac6e	04					.byte 4    ; $8d /
>ac6f	05					.byte 5    ; $8e ^
.ac70					KeywordText:
>ac70	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>ac73	4f d2					.byte $4f,$d2                          ; $81 or
>ac75	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>ac78	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>ac7b	bd					.byte $bd                              ; $84 =
>ac7c	3c be					.byte $3c,$be                          ; $85 <>
>ac7e	bc					.byte $bc                              ; $86 <
>ac7f	3c bd					.byte $3c,$bd                          ; $87 <=
>ac81	be					.byte $be                              ; $88 >
>ac82	3e bd					.byte $3e,$bd                          ; $89 >=
>ac84	ab					.byte $ab                              ; $8a +
>ac85	ad					.byte $ad                              ; $8b -
>ac86	aa					.byte $aa                              ; $8c *
>ac87	af					.byte $af                              ; $8d /
>ac88	de					.byte $de                              ; $8e ^
>ac89	49 c6					.byte $49,$c6                          ; $8f if
>ac8b	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>ac90	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>ac96	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>ac99	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>ac9d	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>aca2	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>aca6	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>acab	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>acaf	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>acb2	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>acb5	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>acb9	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>acbd	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>acc1	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>acc6	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>acca	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>acce	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>acd4	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>acdb	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>ace0	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>ace4	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>ace9	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>aced	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>acf1	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>acf6	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>acfa	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>acfe	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>ad02	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>ad06	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>ad0a	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>ad0e	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>ad12	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>ad16	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>ad1b	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>ad20	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>ad24	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>ad28	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>ad2d	24 a8					.byte $24,$a8                          ; $b5 $(
>ad2f	a4					.byte $a4                              ; $b6 $
>ad30	23 a8					.byte $23,$a8                          ; $b7 #(
>ad32	a3					.byte $a3                              ; $b8 #
>ad33	25 a8					.byte $25,$a8                          ; $b9 %(
>ad35	a5					.byte $a5                              ; $ba %
>ad36	a8					.byte $a8                              ; $bb (
>ad37	a9					.byte $a9                              ; $bc )
>ad38	ac					.byte $ac                              ; $bd ,
>ad39	ba					.byte $ba                              ; $be :
>ad3a	bb					.byte $bb                              ; $bf ;
>ad3b	44 45 c6				.byte $44,$45,$c6                      ; $c0 def
>ad3e	43 4c d2				.byte $43,$4c,$d2                      ; $c1 clr
>ad41	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $c2 stop
>ad45	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c3 data
>ad49	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c4 read
>ad4d	44 49 cd				.byte $44,$49,$cd                      ; $c5 dim
>ad50	54 cf					.byte $54,$cf                          ; $c6 to
>ad52	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c7 step
>ad56	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $c8 gosub
>ad5b	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $c9 return
>ad61	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $ca goto
>ad65	45 4e c4				.byte $45,$4e,$c4                      ; $cb end
>ad68	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $cc input
>ad6d	4c 45 d4				.byte $4c,$45,$d4                      ; $cd let
>ad70	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $ce list
>ad74	4e 45 d7				.byte $4e,$45,$d7                      ; $cf new
>ad77	4f 4c c4				.byte $4f,$4c,$c4                      ; $d0 old
>ad7a	4f ce					.byte $4f,$ce                          ; $d1 on
>ad7c	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d2 restore
>ad83	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d3 poke
>ad87	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d4 print
>ad8c	52 55 ce				.byte $52,$55,$ce                      ; $d5 run
>ad8f	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d6 wait
>ad93	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $d7 doke
>ad97	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $d8 loke
>ad9b	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $d9 assert
>ada1	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_dollarlparen = $b5
=$b6					token_dollar = $b6
=$b7					token_hashlparen = $b7
=$b8					token_hash = $b8
=$b9					token_percentlparen = $b9
=$ba					token_percent = $ba
=$bb					token_lparen = $bb
=$bc					token_rparen = $bc
=$bd					token_comma = $bd
=$be					token_colon = $be
=$bf					token_semicolon = $bf
=$c0					token_def = $c0
=$c1					token_clr = $c1
=$c2					token_stop = $c2
=$c3					token_data = $c3
=$c4					token_read = $c4
=$c5					token_dim = $c5
=$c6					token_to = $c6
=$c7					token_step = $c7
=$c8					token_gosub = $c8
=$c9					token_return = $c9
=$ca					token_goto = $ca
=$cb					token_end = $cb
=$cc					token_input = $cc
=$cd					token_let = $cd
=$ce					token_list = $ce
=$cf					token_new = $cf
=$d0					token_old = $d0
=$d1					token_on = $d1
=$d2					token_restore = $d2
=$d3					token_poke = $d3
=$d4					token_print = $d4
=$d5					token_run = $d5
=$d6					token_wait = $d6
=$d7					token_doke = $d7
=$d8					token_loke = $d8
=$d9					token_assert = $d9

;******  Return to file: modules/basic/core.asm

.ada2					BASIC_Start:
.ada2	20 40 a2	jsr $a240			jsr 	IF_Reset 					; set up and clear screen.
.ada5	20 0c a0	jsr $a00c			jsr 	IFT_ClearScreen
.ada8	a9 4c		lda #$4c			lda 	#$4C 						; JMP opcode
.adaa	8d 04 03	sta $0304			sta 	LocalVector
.adad	8d 00 03	sta $0300			sta 	UserVector
.adb0	a9 c6		lda #$c6			lda 	#USRDefault & $FF 			; reset USR vector
.adb2	8d 01 03	sta $0301			sta 	UserVector+1
.adb5	a9 b3		lda #$b3			lda 	#(USRDefault >> 8) & $FF
.adb7	8d 02 03	sta $0302			sta 	UserVector+2
.adba	a9 00		lda #$00			lda 	#(USRDefault >> 16) & $FF
.adbc	8d 03 03	sta $0303			sta 	UserVector+3
.adbf	20 5d ae	jsr $ae5d			jsr 	ResetRunStatus 				; clear everything (CLR command)
.adc2					WarmStart:
.adc2	a2 ff		ldx #$ff			ldx 		#$FF 					; empty stack
.adc4	9a		txs				txs
.adc5	4c c8 ad	jmp $adc8			jmp 	COMMAND_Run

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/run.asm

.adc8					Command_RUN:
.adc8	20 5d ae	jsr $ae5d			jsr 	ResetRunStatus 				; clear, reset stacks etc.
.adcb	a9 00		lda #$00			lda 	#BasicProgram & $FF
.adcd	85 16		sta $16				sta 	zCodePtr+0
.adcf	a9 80		lda #$80			lda 	#BasicProgram >> 8
.add1	85 17		sta $17				sta 	zCodePtr+1
.add3	a9 00		lda #$00			lda 	#0
.add5	85 18		sta $18				sta 	zCodePtr+2
.add7	85 19		sta $19				sta 	zCodePtr+3
.add9	a0 03		ldy #$03			ldy 	#3
.addb					RUN_NewLine:
.addb	a0 00		ldy #$00			ldy 	#0
.addd	b1 16		lda ($16),y			lda 	(zCodePtr),y
.addf	c8		iny				iny
.ade0	c8		iny				iny
.ade1	c8		iny				iny
.ade2	c9 00		cmp #$00			cmp 	#0 							; if the offset is zero then END.
.ade4	d0 16		bne $adfc			bne 	RUN_NextCommand
.ade6	4c 68 ae	jmp $ae68			jmp 	Command_STOP 				; go do the command code.
.ade9					RUN_Skip:
.ade9	b1 16		lda ($16),y			lda 	(zCodePtr),y 				; read element
.adeb	c8		iny				iny 								; skip
.adec	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.adee	90 0c		bcc $adfc			bcc 	_SEDone 					; so just skip over it.
.adf0	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.adf2	90 07		bcc $adfb			bcc 	_SEDouble
.adf4	98		tya				tya 								; this is Y + 1
.adf5	18		clc				clc
.adf6	71 16		adc ($16),y			adc 	(zCodePtr),y 				; add total length of element
.adf8	a8		tay				tay 								; back in Y.
.adf9	88		dey				dey 								; fix up, one for the +1, one for the iny
.adfa	88		dey				dey
.adfb					_SEDouble:
.adfb	c8		iny				iny
.adfc					_SEDone:
.adfc					RUN_NextCommand:
.adfc	a9 00		lda #$00			lda 	#0 							; this resets temporary string allocation.
.adfe	85 21		sta $21				sta 	zTempStr+1 					; (initialised when first called)
.ae00	b1 16		lda ($16),y			lda 	(zCodePtr),y
.ae02	c9 be		cmp #$be			cmp 	#token_Colon 				; skip over colons
.ae04	f0 e3		beq $ade9			beq 	RUN_Skip
.ae06	c9 00		cmp #$00			cmp 	#0 							; if non-zero execute whatever
.ae08	d0 0f		bne $ae19			bne 	RUN_Execute
.ae0a					RUN_NextLine:
.ae0a	a0 00		ldy #$00			ldy 	#0 							; point to offset
.ae0c	b1 16		lda ($16),y			lda 	(zCodePtr),y 				; read it
.ae0e	18		clc				clc
.ae0f	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.ae11	85 16		sta $16				sta 	zCodePtr
.ae13	90 02		bcc $ae17			bcc 	_SNLNoCarry
.ae15	e6 17		inc $17				inc 	zCodePtr+1
.ae17					_SNLNoCarry:
.ae17	80 c2		bra $addb			bra 	RUN_NewLine 				; go do the new line code
.ae19					RUN_Execute:
.ae19	c9 f8		cmp #$f8			cmp 	#$F8 						; handle shifts, REM etc.
.ae1b	b0 18		bcs $ae35			bcs 	RUN_Extension
.ae1d	c8		iny				iny
.ae1e	0a		asl a				asl 	a 							; double the character read.
.ae1f	90 12		bcc $ae33			bcc 	RUN_Default 				; if carry clear was $00-$7F, so try LET.
.ae21	aa		tax				tax 								; ready to look up.
.ae22	bd 9a ab	lda $ab9a,x			lda 	VectorTable,x 				; copy address into LocalVector
.ae25	8d 05 03	sta $0305			sta 	LocalVector+1
.ae28	bd 9b ab	lda $ab9b,x			lda 	VectorTable+1,x
.ae2b	8d 06 03	sta $0306			sta 	LocalVector+2
.ae2e	20 78 af	jsr $af78			jsr 	EVCallLocalVector 			; execute the appropriate code.
.ae31	80 c9		bra $adfc			bra 	RUN_NextCommand 			; do the next command.
.ae33					RUN_Default:
.ae33	80 fe		bra $ae33			bra 	RUN_Default
.ae35					RUN_Extension:
.ae35	c9 ff		cmp #$ff			cmp 	#$FF 						; if $FF (REM)
.ae37	f0 b0		beq $ade9			beq 	RUN_Skip 					; skip over it.
.ae39	4c 08 ab	jmp $ab08			jmp 	SyntaxError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/end.asm

.ae3c					Command_END:
.ae3c	80 fe		bra $ae3c	_halt:	bra 		_halt
.ae3e	4c c2 ad	jmp $adc2			jmp 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/assert.asm

.ae41					Command_ASSERT:
.ae41	20 0e b0	jsr $b00e			jsr 	EvaluateNumber 				; calculate thing being asserted
.ae44	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; check if true (non-zero)
.ae47	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.ae4a	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.ae4d	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.ae50	f0 01		beq $ae53			beq 	_ASFail
.ae52	60		rts				rts
.ae53					_ASFail:
.ae53	20 37 ab	jsr $ab37			jsr ERR_Handler
>ae56	41 73 73 65 72 74 00			.text "Assert",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.ae5d					Command_CLR:
.ae5d					ResetRunStatus:
.ae5d	a9 00		lda #$00			lda 	#HighMemory & $FF
.ae5f	8d 26 04	sta $0426			sta 	StringPtr
.ae62	a9 a0		lda #$a0			lda 	#HighMemory >> 8
.ae64	8d 27 04	sta $0427			sta 	StringPtr+1
.ae67	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/stop.asm

.ae68					Command_STOP:
.ae68	20 37 ab	jsr $ab37			jsr ERR_Handler
>ae6b	53 74 6f 70 00				.text "Stop",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.ae70					EVESyntax:
.ae70	4c 08 ab	jmp $ab08			jmp 	SyntaxError
.ae73					EvaluateExpression:
.ae73	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.ae75					EvaluateExpressionX:
.ae75	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.ae77					EvaluateExpressionXA:
.ae77	48		pha				pha 								; save precedence on stack.
.ae78	b1 16		lda ($16),y			lda 	(zCodePtr),y
.ae7a	f0 f4		beq $ae70			beq 	EVESyntax 					; end of line, syntax error.
.ae7c	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.ae7e	b0 03		bcs $ae83			bcs 	_EVNotVariable
.ae80	4c 77 af	jmp $af77			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.ae83					_EVNotVariable:
.ae83	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.ae85	90 e9		bcc $ae70			bcc 	EVESyntax
.ae87	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.ae89	b0 7c		bcs $af07			bcs 	_EVNotInteger
.ae8b	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.ae8d	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.ae90	a9 00		lda #$00			lda 	#0
.ae92	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.ae95	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.ae98	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.ae9b	1a		inc a				inc 	a 							; set to type 1 (integer)
.ae9c	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.ae9f					_EVCheckNextInteger:
.ae9f	c8		iny				iny
.aea0	b1 16		lda ($16),y			lda 	(zCodePtr),y
.aea2	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.aea4	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.aea6	b0 0d		bcs $aeb5			bcs 	_EVCheckDecimal
.aea8	48		pha				pha 								; save it.
.aea9	20 7b af	jsr $af7b			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.aeac	68		pla				pla
.aead	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.aeb0	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.aeb3	80 ea		bra $ae9f			bra 	_EVCheckNextInteger
.aeb5					_EVCheckDecimal:
.aeb5	b1 16		lda ($16),y			lda 	(zCodePtr),y
.aeb7	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.aeb9	d0 05		bne $aec0			bne 	_EVGotAtom 					; no, get atom.
.aebb					_EVIsDecimal:
.aebb	20 ab af	jsr $afab			jsr 	EVGetDecimal 				; extend to the decimal part.
.aebe	80 00		bra $aec0			bra 	_EVGotAtom 					; and continue to got atom.
.aec0					_EVGotAtom:
.aec0	b1 16		lda ($16),y			lda 	(zCodePtr),y
.aec2	10 41		bpl $af05			bpl 	_EVExitDrop 				; must be a token.
.aec4	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.aec6	b0 3d		bcs $af05			bcs 	_EVExitDrop
.aec8	68		pla				pla 								; get current precedence
.aec9	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.aecb	da		phx				phx 								; save X
.aecc	b1 16		lda ($16),y			lda 	(zCodePtr),y
.aece	aa		tax				tax 								; put in X
.aecf	bd e1 ab	lda $abe1,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.aed2	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.aed4	fa		plx				plx 								; restore X
.aed5	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.aed7	90 2d		bcc $af06			bcc 	_EVExit 					; exit if too low.
.aed9	f0 2b		beq $af06			beq 	_EVExit 					; exit if equals
.aedb	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.aedd	48		pha				pha
.aede	b1 16		lda ($16),y			lda 	(zCodePtr),y
.aee0	48		pha				pha
.aee1	c8		iny				iny
.aee2	da		phx				phx 								; save current position
.aee3	e8		inx				inx
.aee4	e8		inx				inx
.aee5	e8		inx				inx
.aee6	e8		inx				inx
.aee7	e8		inx				inx
.aee8	e8		inx				inx
.aee9	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.aeeb	20 77 ae	jsr $ae77			jsr 	EvaluateExpressionXA 		; do the RHS.
.aeee	fa		plx				plx 								; restore X
.aeef	68		pla				pla 								; get the binary operator in A.
.aef0					_EVCallA:
.aef0	da		phx				phx 								; save X again
.aef1	0a		asl a				asl 	a 							; double, lose the MSB.
.aef2	aa		tax				tax									; put in X
.aef3	bd 9a ab	lda $ab9a,x			lda 	VectorTable,x 				; copy address into zGenPtr
.aef6	8d 05 03	sta $0305			sta 	LocalVector+1
.aef9	bd 9b ab	lda $ab9b,x			lda 	VectorTable+1,x
.aefc	8d 06 03	sta $0306			sta 	LocalVector+2
.aeff	fa		plx				plx 								; restore X
.af00	20 78 af	jsr $af78			jsr 	EVCallLocalVector
.af03	80 bb		bra $aec0			bra 	_EVGotAtom 					; and loop back.
.af05					_EVExitDrop:
.af05	68		pla				pla
.af06					_EVExit:
.af06	60		rts				rts
.af07					_EVNotInteger:
.af07	c8		iny				iny
.af08	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.af0a	d0 19		bne $af25			bne 	_EVNotMinus
.af0c	20 fc af	jsr $affc			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.af0f	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.af12	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.af14	f0 05		beq $af1b			beq 	_EVMinusFloat
.af16	20 f9 b7	jsr $b7f9			jsr 	IntegerNegateAlways 		; negation
.af19	80 a5		bra $aec0			bra 	_EVGotAtom 					; and go back.
.af1b					_EVMinusFloat:
.af1b	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; invert the sign bit.
.af1e	49 80		eor #$80			eor 	#$80
.af20	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.af23	80 9b		bra $aec0			bra 	_EVGotAtom
.af25					_EVNotMinus:
.af25	c9 bb		cmp #$bb			cmp 	#token_lparen 				; is it left parenthesis
.af27	d0 17		bne $af40			bne 	_EVNotParenthesis
.af29	20 75 ae	jsr $ae75			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.af2c	b1 16		lda ($16),y			lda 	(zCodePtr),y
.af2e	c8		iny				iny
.af2f	c9 bc		cmp #$bc			cmp 	#token_rparen 				; okay if right bracket.
.af31	f0 8d		beq $aec0			beq 	_EVGotAtom
.af33	20 37 ab	jsr $ab37			jsr ERR_Handler
>af36	4d 69 73 73 69 6e 67 20			.text "Missing )",0
>af3e	29 00
.af40					_EVNotParenthesis:
.af40	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.af42	d0 0c		bne $af50			bne 	_EVNotNot
.af44	20 fc af	jsr $affc			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.af47	20 03 bd	jsr $bd03			jsr 	FPUToInteger 				; make it an integer - if possible.
.af4a	20 d9 af	jsr $afd9			jsr 	NotInteger 					; do the not calculation
.af4d	4c c0 ae	jmp $aec0			jmp 	_EVGotAtom
.af50					_EVNotNot:
.af50	c9 fe		cmp #$fe			cmp 	#$FE
.af52	d0 15		bne $af69			bne 	_EVNotString
.af54	20 e6 b6	jsr $b6e6			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.af57	a5 20		lda $20				lda 	zTempStr 					; copy address of string into mantissa
.af59	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.af5c	a5 21		lda $21				lda 	zTempStr+1
.af5e	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.af61	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.af63	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.af66	4c c0 ae	jmp $aec0			jmp 	_EVGotAtom
.af69					_EVNotString:
.af69	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.af6b	90 04		bcc $af71			bcc 	_EVBadElement
.af6d	c9 b5		cmp #$b5			cmp 	#lastUnaryFunction+1
.af6f	90 03		bcc $af74			bcc 	_EVUnaryFunction
.af71					_EVBadElement:
.af71	4c 08 ab	jmp $ab08			jmp 	SyntaxError
.af74					_EVUnaryFunction:
.af74	4c f0 ae	jmp $aef0			jmp 	_EVCallA
.af77					_EVVariableHandler:
.af77	ea		nop				nop
.af78					EVCallLocalVector:
.af78	6c 05 03	jmp ($0305)			jmp 	(LocalVector+1)
.af7b					EVShiftMantissaLeft6:
.af7b	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.af7e	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.af81	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.af84	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.af87	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.af8a	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.af8d	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.af90	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.af93	a9 00		lda #$00			lda 	#0
.af95	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.af98	20 9b af	jsr $af9b			jsr 	_EVSMLShift 					; call it here to do it twice
.af9b					_EVSMLShift:
.af9b	5e 0c 03	lsr $030c,x			lsr 	XS_Exponent,x
.af9e	7e 0b 03	ror $030b,x			ror 	XS_Mantissa+3,x
.afa1	7e 0a 03	ror $030a,x			ror 	XS_Mantissa+2,x
.afa4	7e 09 03	ror $0309,x			ror 	XS_Mantissa+1,x
.afa7	7e 08 03	ror $0308,x			ror 	XS_Mantissa+0,x
.afaa	60		rts				rts
.afab					EVGetDecimal:
.afab	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.afad	8d 00 04	sta $0400			sta 	Num_Buffer
.afb0	da		phx				phx
.afb1	c8		iny				iny
.afb2	b1 16		lda ($16),y			lda 	(zCodePtr),y
.afb4	c8		iny				iny
.afb5	3a		dec a				dec 	a								; convert to a string length.
.afb6	3a		dec a				dec 	a
.afb7	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.afb9					_EVGDCopy:
.afb9	48		pha				pha 									; save count
.afba	b1 16		lda ($16),y			lda 	(zCodePtr),y
.afbc	9d 00 04	sta $0400,x			sta 	Num_Buffer,x
.afbf	e8		inx				inx 									; forward ....
.afc0	c8		iny				iny
.afc1	68		pla				pla 									; get count
.afc2	3a		dec a				dec 	a 								; until zero
.afc3	d0 f4		bne $afb9			bne 	_EVGDCopy
.afc5	9d 00 04	sta $0400,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.afc8	fa		plx				plx 									; restore X
.afc9	a9 00		lda #$00			lda 	#Num_Buffer & $FF 				; set zGenPtr
.afcb	85 1e		sta $1e				sta 	zGenPtr
.afcd	a9 04		lda #$04			lda 	#Num_Buffer >> 8
.afcf	85 1f		sta $1f				sta 	zGenPtr+1
.afd1	5a		phy				phy 									; save Y
.afd2	a0 00		ldy #$00			ldy 	#0 								; start position
.afd4	20 f5 be	jsr $bef5			jsr 	FPFromString 					; convert current
.afd7	7a		ply				ply 									; restore Y
.afd8	60		rts				rts
.afd9					NotInteger:
.afd9	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.afdc	49 ff		eor #$ff			eor 	#$FF
.afde	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.afe1	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.afe4	49 ff		eor #$ff			eor 	#$FF
.afe6	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.afe9	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.afec	49 ff		eor #$ff			eor 	#$FF
.afee	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.aff1	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.aff4	49 ff		eor #$ff			eor 	#$FF
.aff6	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.aff9	60		rts				rts
.affa					EvaluateGetAtom:
.affa	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.affc					EvaluateGetAtomX:
.affc	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.affe	20 77 ae	jsr $ae77			jsr 	EvaluateExpressionXA
.b001	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.b004	29 0f		and #$0f			and 	#15
.b006	c9 02		cmp #$02			cmp 	#2
.b008	b0 01		bcs $b00b			bcs 	EvaluateType
.b00a	60		rts				rts
.b00b					EvaluateType:
.b00b	4c 18 ab	jmp $ab18			jmp 	TypeError
.b00e					EvaluateNumber:
.b00e	a2 00		ldx #$00			ldx 	#0
.b010					EvaluateNumberX:
.b010	20 75 ae	jsr $ae75			jsr 	EvaluateExpressionX
.b013	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 0/1
.b016	29 0f		and #$0f			and 	#15
.b018	c9 02		cmp #$02			cmp 	#2
.b01a	b0 ef		bcs $b00b			bcs 	EvaluateType
.b01c	60		rts				rts
.b01d					EvaluateInteger:
.b01d	a2 00		ldx #$00			ldx 	#0
.b01f					EvaluateIntegerX:
.b01f	20 10 b0	jsr $b010			jsr 	EvaluateNumberX
.b022	20 03 bd	jsr $bd03			jsr 	FPUToInteger
.b025	60		rts				rts
.b026					EvaluateString:
.b026	a2 00		ldx #$00			ldx 	#0
.b028					EvaluateStringX:
.b028	20 75 ae	jsr $ae75			jsr 	EvaluateExpressionX
.b02b	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 2
.b02e	29 0f		and #$0f			and 	#15
.b030	c9 02		cmp #$02			cmp 	#2
.b032	d0 d7		bne $b00b			bne 	EvaluateType
.b034	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.b037	85 1e		sta $1e				sta 	zGenPtr
.b039	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b03c	85 1f		sta $1f				sta 	zGenPtr+1
.b03e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.b03f					BinaryOp_And:
.b03f	20 b7 b0	jsr $b0b7			jsr 	BinaryMakeBothInteger
.b042	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.b045	3d 0e 03	and $030e,x			and 	XS2_Mantissa+0,x
.b048	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b04b	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.b04e	3d 0f 03	and $030f,x			and 	XS2_Mantissa+1,x
.b051	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b054	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.b057	3d 10 03	and $0310,x			and 	XS2_Mantissa+2,x
.b05a	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b05d	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.b060	3d 11 03	and $0311,x			and 	XS2_Mantissa+3,x
.b063	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b066	60		rts				rts
.b067					BinaryOp_Or:
.b067	20 b7 b0	jsr $b0b7			jsr 	BinaryMakeBothInteger
.b06a	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.b06d	1d 0e 03	ora $030e,x			ora 	XS2_Mantissa+0,x
.b070	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b073	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.b076	1d 0f 03	ora $030f,x			ora 	XS2_Mantissa+1,x
.b079	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b07c	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.b07f	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.b082	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b085	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.b088	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.b08b	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b08e	60		rts				rts
.b08f					BinaryOp_Eor:
.b08f					BinaryOp_Xor:
.b08f	20 b7 b0	jsr $b0b7			jsr 	BinaryMakeBothInteger
.b092	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.b095	5d 0e 03	eor $030e,x			eor 	XS2_Mantissa+0,x
.b098	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b09b	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.b09e	5d 0f 03	eor $030f,x			eor 	XS2_Mantissa+1,x
.b0a1	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b0a4	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.b0a7	5d 10 03	eor $0310,x			eor 	XS2_Mantissa+2,x
.b0aa	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b0ad	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.b0b0	5d 11 03	eor $0311,x			eor 	XS2_Mantissa+3,x
.b0b3	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b0b6	60		rts				rts
.b0b7					BinaryMakeBothInteger:
.b0b7	da		phx				phx 								; save X
.b0b8	e8		inx				inx
.b0b9	e8		inx				inx
.b0ba	e8		inx				inx
.b0bb	e8		inx				inx
.b0bc	e8		inx				inx
.b0bd	e8		inx				inx
.b0be	20 c2 b0	jsr $b0c2			jsr 	BinaryMakeInteger 			; convert to integer.
.b0c1	fa		plx				plx 								; restore X and fall through.
.b0c2					BinaryMakeInteger:
.b0c2	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type byte.
.b0c5	29 0f		and #$0f			and 	#15 						; check type zero
.b0c7	f0 04		beq $b0cd			beq 	_BMIConvert 				; if float convert to integer.
.b0c9	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.b0ca	90 04		bcc $b0d0			bcc 	_BMIError
.b0cc	60		rts				rts
.b0cd					_BMIConvert:
.b0cd	4c 03 bd	jmp $bd03			jmp 	FPUToInteger 				; convert to integer
.b0d0					_BMIError:
.b0d0	4c 18 ab	jmp $ab18			jmp 	TypeError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.b0d3					Binary_Equal:
.b0d3	20 1f b1	jsr $b11f			jsr 	CompareValues
.b0d6	09 00		ora #$00			ora 	#0
.b0d8	f0 04		beq $b0de			beq 	CCTrue
.b0da	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.b0dc	80 02		bra $b0e0			bra 	CCWrite
.b0de	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.b0e0	9d 08 03	sta $0308,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.b0e3	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b0e6	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b0e9	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b0ec	a9 01		lda #$01			lda 	#1
.b0ee	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; set type to integer whatever.
.b0f1	60		rts				rts
.b0f2					Binary_NotEqual:
.b0f2	20 1f b1	jsr $b11f			jsr 	CompareValues
.b0f5	09 00		ora #$00			ora 	#0
.b0f7	d0 e1		bne $b0da			bne 	CCFalse
.b0f9	80 e3		bra $b0de			bra 	CCTrue
.b0fb					Binary_Less:
.b0fb	20 1f b1	jsr $b11f			jsr 	CompareValues
.b0fe	09 00		ora #$00			ora 	#0
.b100	30 dc		bmi $b0de			bmi 	CCTrue
.b102	80 d6		bra $b0da			bra 	CCFalse
.b104					Binary_LessEqual:
.b104	20 1f b1	jsr $b11f			jsr 	CompareValues
.b107	c9 01		cmp #$01			cmp 	#1
.b109	d0 d3		bne $b0de			bne 	CCTrue
.b10b	80 cd		bra $b0da			bra 	CCFalse
.b10d					Binary_GreaterEqual:
.b10d	20 1f b1	jsr $b11f			jsr 	CompareValues
.b110	09 00		ora #$00			ora 	#0
.b112	10 ca		bpl $b0de			bpl 	CCTrue
.b114	80 c4		bra $b0da			bra 	CCFalse
.b116					Binary_Greater:
.b116	20 1f b1	jsr $b11f			jsr 	CompareValues
.b119	c9 01		cmp #$01			cmp 	#1
.b11b	d0 c1		bne $b0de			bne 	CCTrue
.b11d	80 bb		bra $b0da			bra 	CCFalse
.b11f					CompareValues:
.b11f	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and the types together
.b122	3d 13 03	and $0313,x			and 	XS2_Type,x
.b125	c9 02		cmp #$02			cmp 	#2
.b127	f0 13		beq $b13c			beq 	_CVString
.b129	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b12c	3d 13 03	and $0313,x			and 	XS2_Type,x
.b12f	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b130	90 03		bcc $b135			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b132	4c 82 b1	jmp $b182			jmp 	CompareInteger32 							; so execute code at \1
.b135					_BCFloat:
.b135	20 50 b2	jsr $b250			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b138	4c 12 bc	jmp $bc12			jmp 	FPCompare 							; and execute code at \2
.b13b	60		rts				rts
.b13c					_CVString:
.b13c	da		phx				phx 								; save XY
.b13d	5a		phy				phy
.b13e	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.b141	85 1a		sta $1a				sta		zLTemp1+0
.b143	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b146	85 1b		sta $1b				sta 	zLTemp1+1
.b148	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x
.b14b	85 1c		sta $1c				sta 	zLTemp1+2
.b14d	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.b150	85 1d		sta $1d				sta 	zLTemp1+3
.b152	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.b154	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b156	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.b158	90 02		bcc $b15c			bcc 	_CVCommon
.b15a	b1 1c		lda ($1c),y			lda 	(zLTemp1+2),y
.b15c					_CVCommon:
.b15c	aa		tax				tax 								; put shorter string length in zero.
.b15d	f0 0c		beq $b16b			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.b15f					_CVCompare:
.b15f	c8		iny				iny 								; next character
.b160	b1 1a		lda ($1a),y			lda 	(zLTemp1),y 				; compare characters
.b162	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.b164	90 13		bcc $b179			bcc 	_CVReturnLess 				; <
.b166	d0 15		bne $b17d			bne 	_CVReturnGreater 			; >
.b168	ca		dex				dex 								; until common length matched.
.b169	d0 f4		bne $b15f			bne 	_CVCompare
.b16b					_CVMatch:
.b16b	a0 00		ldy #$00			ldy 	#0
.b16d	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b16f	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.b171	90 06		bcc $b179			bcc 	_CVReturnLess 				; <
.b173	d0 08		bne $b17d			bne 	_CVReturnGreater 			; >
.b175	a9 00		lda #$00			lda 	#0
.b177	80 06		bra $b17f			bra 	_CVExit 					; same common, same length, same string
.b179					_CVReturnLess:
.b179	a9 ff		lda #$ff			lda 	#$FF
.b17b	80 02		bra $b17f			bra 	_CVExit
.b17d					_CVReturnGreater:
.b17d	a9 01		lda #$01			lda 	#$01
.b17f					_CVExit:
.b17f	7a		ply				ply
.b180	fa		plx				plx
.b181	60		rts				rts
.b182					CompareInteger32:
.b182	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.b185	49 80		eor #$80			eor 	#$80
.b187	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b18a	bd 11 03	lda $0311,x			lda 	XS2_Mantissa+3,x
.b18d	49 80		eor #$80			eor 	#$80
.b18f	9d 11 03	sta $0311,x			sta 	XS2_Mantissa+3,x
.b192	20 2a b2	jsr $b22a			jsr 	SubInteger32 				; subtraction
.b195	90 11		bcc $b1a8			bcc 	_CI32Less 					; cc return -1
.b197	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; check if zero
.b19a	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.b19d	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.b1a0	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.b1a3	f0 02		beq $b1a7			beq 	_CI32Exit
.b1a5	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.b1a7					_CI32Exit:
.b1a7	60		rts				rts
.b1a8					_CI32Less:
.b1a8	a9 ff		lda #$ff			lda 	#$FF
.b1aa	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.b1ab					BinaryOp_Add:
.b1ab	bd 0d 03	lda $030d,x			lda 	XS_Type,x  					; and types together
.b1ae	3d 13 03	and $0313,x			and 	XS2_Type,x
.b1b1	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.b1b3	d0 13		bne $b1c8			bne 	_BOAString
.b1b5	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b1b8	3d 13 03	and $0313,x			and 	XS2_Type,x
.b1bb	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b1bc	90 03		bcc $b1c1			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b1be	4c 04 b2	jmp $b204			jmp 	AddInteger32 							; so execute code at \1
.b1c1					_BCFloat:
.b1c1	20 50 b2	jsr $b250			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b1c4	4c 86 b9	jmp $b986			jmp 	FPAdd 							; and execute code at \2
.b1c7	60		rts				rts
.b1c8					_BOAString:
.b1c8	4c 6b b2	jmp $b26b			jmp 	ConcatenateString 			; concatenate two strings.
.b1cb					BinaryOp_Subtract:
.b1cb	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b1ce	3d 13 03	and $0313,x			and 	XS2_Type,x
.b1d1	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b1d2	90 03		bcc $b1d7			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b1d4	4c 2a b2	jmp $b22a			jmp 	SubInteger32 							; so execute code at \1
.b1d7					_BCFloat:
.b1d7	20 50 b2	jsr $b250			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b1da	4c 7c b9	jmp $b97c			jmp 	FPSubtract 							; and execute code at \2
.b1dd	60		rts				rts
.b1de					BinaryOp_Multiply:
.b1de	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b1e1	3d 13 03	and $0313,x			and 	XS2_Type,x
.b1e4	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b1e5	90 03		bcc $b1ea			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b1e7	4c 0c b7	jmp $b70c			jmp 	MulInteger32 							; so execute code at \1
.b1ea					_BCFloat:
.b1ea	20 50 b2	jsr $b250			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b1ed	4c f2 ba	jmp $baf2			jmp 	FPMultiply 							; and execute code at \2
.b1f0	60		rts				rts
.b1f1					BinaryOp_Divide:
.b1f1	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b1f4	3d 13 03	and $0313,x			and 	XS2_Type,x
.b1f7	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b1f8	90 03		bcc $b1fd			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b1fa	4c 63 b7	jmp $b763			jmp 	DivInteger32 							; so execute code at \1
.b1fd					_BCFloat:
.b1fd	20 50 b2	jsr $b250			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b200	4c 6a ba	jmp $ba6a			jmp 	FPDivide 							; and execute code at \2
.b203	60		rts				rts
.b204					AddInteger32:
.b204	18		clc				clc
.b205	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b208	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.b20b	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b20e	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b211	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.b214	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b217	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.b21a	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.b21d	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b220	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.b223	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.b226	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b229	60		rts				rts
.b22a					SubInteger32:
.b22a	38		sec				sec
.b22b	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b22e	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.b231	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b234	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b237	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.b23a	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b23d	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.b240	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.b243	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b246	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.b249	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.b24c	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b24f	60		rts				rts
.b250					BinaryMakeBothFloat:
.b250	da		phx				phx 								; save X
.b251	e8		inx				inx
.b252	e8		inx				inx
.b253	e8		inx				inx
.b254	e8		inx				inx
.b255	e8		inx				inx
.b256	e8		inx				inx
.b257	20 5b b2	jsr $b25b			jsr 	BinaryMakeFloat 			; convert to float.
.b25a	fa		plx				plx 								; restore X and fall through.
.b25b					BinaryMakeFloat:
.b25b	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type byte.
.b25e	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.b25f	b0 04		bcs $b265			bcs 	_BMFConvert
.b261	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.b262	b0 04		bcs $b268			bcs 	_BMFError
.b264	60		rts				rts
.b265					_BMFConvert:
.b265	4c a4 bc	jmp $bca4			jmp 	FPUToFloat 					; convert to float
.b268					_BMFError:
.b268	4c 18 ab	jmp $ab18			jmp 	TypeError
.b26b					ConcatenateString:
.b26b	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.b26e	85 1a		sta $1a				sta		zLTemp1+0
.b270	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b273	85 1b		sta $1b				sta 	zLTemp1+1
.b275	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x
.b278	85 1c		sta $1c				sta 	zLTemp1+2
.b27a	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.b27d	85 1d		sta $1d				sta 	zLTemp1+3
.b27f	5a		phy				phy
.b280	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.b282	b1 1a		lda ($1a),y			lda 	(zlTemp1),y
.b284	71 1c		adc ($1c),y			adc 	(zlTemp1+2),y
.b286	7a		ply				ply
.b287	b0 37		bcs $b2c0			bcs 	_CSError					; check in range.
.b289	c9 fe		cmp #$fe			cmp 	#maxString+1
.b28b	b0 33		bcs $b2c0			bcs 	_CSError
.b28d	20 ab b6	jsr $b6ab			jsr 	AllocateTempString 			; store the result
.b290	20 ab b2	jsr $b2ab			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.b293	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.b296	85 1a		sta $1a				sta 	zLTemp1
.b298	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.b29b	85 1b		sta $1b				sta 	zLTemp1+1
.b29d	20 ab b2	jsr $b2ab			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.b2a0	a5 20		lda $20				lda 	zTempStr 					; point current to new string
.b2a2	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b2a5	a5 21		lda $21				lda 	zTempStr+1
.b2a7	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b2aa	60		rts				rts
.b2ab					_CSCopyString:
.b2ab	da		phx				phx
.b2ac	5a		phy				phy
.b2ad	a0 00		ldy #$00			ldy 	#0 							; get length
.b2af	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b2b1	f0 0a		beq $b2bd			beq 	_CSCSExit 					; if zero, exit
.b2b3	aa		tax				tax 								; put in X
.b2b4					_CSCSLoop:
.b2b4	c8		iny				iny 								; get next char
.b2b5	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b2b7	20 d6 b6	jsr $b6d6			jsr		WriteTempString 			; copy out
.b2ba	ca		dex				dex 								; do whole string
.b2bb	d0 f7		bne $b2b4			bne 	_CSCSLoop
.b2bd					_CSCSExit:
.b2bd	7a		ply				ply
.b2be	fa		plx				plx
.b2bf	60		rts				rts
.b2c0					_CSError:
.b2c0	20 37 ab	jsr $ab37			jsr ERR_Handler
>b2c3	53 74 72 69 6e 67 20 74			.text "String too long",0
>b2cb	6f 6f 20 6c 6f 6e 67 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.b2d3					Unary_Sgn:
.b2d3	20 10 b0	jsr $b010			jsr 	EvaluateNumberX 			; get value
.b2d6	20 9b b6	jsr $b69b			jsr 	CheckNextRParen 			; check right bracket.
.b2d9	20 fd b2	jsr $b2fd			jsr 	GetSignCurrent 				; get sign.
.b2dc	09 00		ora #$00			ora 	#0
.b2de	10 09		bpl $b2e9			bpl		UnarySetAInteger			; if 0,1 return that.
.b2e0	80 00		bra $b2e2			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.b2e2					UnarySetAMinus1:
.b2e2	a9 ff		lda #$ff			lda 	#$FF
.b2e4	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.b2e7	80 05		bra $b2ee			bra 	UnarySetAFill
.b2e9					UnarySetAInteger:
.b2e9	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.b2ec	a9 00		lda #$00			lda 	#0
.b2ee					UnarySetAFill:
.b2ee	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b2f1	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b2f4	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b2f7	a9 01		lda #$01			lda 	#1
.b2f9	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.b2fc	60		rts				rts
.b2fd					GetSignCurrent:
.b2fd	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; identify type.
.b300	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.b301	90 19		bcc $b31c			bcc 	_GSCFloat
.b303	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.b306	30 11		bmi $b319			bmi 	_GSCMinus1
.b308	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x
.b30b	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.b30e	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.b311	d0 03		bne $b316			bne 	_GSCPlus1
.b313					_GSCZero:
.b313	a9 00		lda #$00			lda 	#0
.b315	60		rts				rts
.b316					_GSCPlus1:
.b316	a9 01		lda #$01			lda 	#$01
.b318	60		rts				rts
.b319					_GSCMinus1:
.b319	a9 ff		lda #$ff			lda 	#$FF
.b31b	60		rts				rts
.b31c					_GSCFloat:
.b31c	3c 0d 03	bit $030d,x			bit 	XS_Type,x
.b31f	70 f2		bvs $b313			bvs 	_GSCZero
.b321	30 f6		bmi $b319			bmi 	_GSCMinus1
.b323	80 f1		bra $b316			bra 	_GSCPlus1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.b325					Unary_Abs:
.b325	20 10 b0	jsr $b010			jsr 	EvaluateNumberX 			; get value
.b328	20 9b b6	jsr $b69b			jsr 	CheckNextRParen 			; check right bracket.
.b32b	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.b32e	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.b330	f0 08		beq $b33a			beq 	_UAMinusFloat
.b332	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; check MSB
.b335	10 0b		bpl $b342			bpl 	_UAExit
.b337	4c f9 b7	jmp $b7f9			jmp 	IntegerNegateAlways 		; negation
.b33a					_UAMinusFloat:
.b33a	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; clear the sign bit.
.b33d	29 7f		and #$7f			and		#$7F
.b33f	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.b342					_UAExit:
.b342	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.b343					Unary_Peek:
.b343	a9 01		lda #$01			lda 	#1
.b345	80 06		bra $b34d			bra 	UPMain
.b347					Unary_Deek:
.b347	a9 02		lda #$02			lda 	#2
.b349	80 02		bra $b34d			bra 	UPMain
.b34b					Unary_Leek:
.b34b	a9 04		lda #$04			lda 	#4
.b34d					UPMain:
.b34d	48		pha				pha 								; set bytes to copy.
.b34e	20 1f b0	jsr $b01f			jsr 	EvaluateIntegerX 			; numeric parameter
.b351	20 9b b6	jsr $b69b			jsr 	CheckNextRParen 			; right bracket.
.b354	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.b357	85 1a		sta $1a				sta 	zLTemp1
.b359	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b35c	85 1b		sta $1b				sta 	zLTemp1+1
.b35e	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.b361	85 1c		sta $1c				sta 	zLTemp1+2
.b363	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.b366	85 1d		sta $1d				sta 	zLTemp1+3
.b368	a9 00		lda #$00			lda 	#0 							; clear target area
.b36a	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b36d	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b370	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b373	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b376	68		pla				pla 								; restore bytes to copy
.b377	da		phx				phx 								; save XY
.b378	5a		phy				phy
.b379	20 72 b6	jsr $b672			jsr 	MemRead 					; read the bytes in
.b37c	7a		ply				ply 								; restore and exit
.b37d	fa		plx				plx
.b37e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.b37f					Unary_Mod:
.b37f	20 ab b3	jsr $b3ab			jsr 	_UMParameter 				; first parameter
.b382	20 a3 b6	jsr $b6a3			jsr 	CheckNextComma
.b385	da		phx				phx 								; second parameter
.b386	e8		inx				inx
.b387	e8		inx				inx
.b388	e8		inx				inx
.b389	e8		inx				inx
.b38a	e8		inx				inx
.b38b	e8		inx				inx
.b38c	20 ab b3	jsr $b3ab			jsr 	_UMParameter
.b38f	fa		plx				plx
.b390	20 9b b6	jsr $b69b			jsr 	CheckNextRParen
.b393	20 63 b7	jsr $b763			jsr 	DivInteger32 				; divide
.b396	a5 1a		lda $1a				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.b398	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b39b	a5 1b		lda $1b				lda 	zLTemp1+1
.b39d	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b3a0	a5 1c		lda $1c				lda 	zLTemp1+2
.b3a2	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b3a5	a5 1d		lda $1d				lda 	zLTemp1+3
.b3a7	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b3aa	60		rts				rts
.b3ab					_UMParameter:
.b3ab	20 1f b0	jsr $b01f			jsr 	EvaluateIntegerX 			; get value
.b3ae	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; absolute value
.b3b1	10 03		bpl $b3b6			bpl 	_UMNotSigned
.b3b3	20 f9 b7	jsr $b7f9			jsr 	IntegerNegateAlways
.b3b6					_UMNotSigned:
.b3b6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.b3b7					Unary_Usr:
.b3b7	20 10 b0	jsr $b010			jsr 	EvaluateNumberX 			; numeric parameter
.b3ba	20 9b b6	jsr $b69b			jsr 	CheckNextRParen 			; right bracket.
.b3bd	da		phx				phx 								; save XY
.b3be	5a		phy				phy
.b3bf	ea		nop				nop
.b3c0	20 00 03	jsr $0300			jsr 	UserVector 					; call the USR function.
.b3c3	7a		ply				ply 								; and exit
.b3c4	fa		plx				plx
.b3c5	60		rts				rts
.b3c6					USRDefault:
.b3c6	20 37 ab	jsr $ab37			jsr ERR_Handler
>b3c9	4e 6f 20 55 53 52 20 76			.text "No USR vector.",0
>b3d1	65 63 74 6f 72 2e 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.b3d8					Unary_Val:
.b3d8	20 28 b0	jsr $b028			jsr 	EvaluateStringX 			; get string
.b3db	20 9b b6	jsr $b69b			jsr 	CheckNextRParen 			; check right bracket.
.b3de	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.b3e1	85 1e		sta $1e				sta 	zGenPtr
.b3e3	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b3e6	85 1f		sta $1f				sta 	zGenPtr+1
.b3e8	5a		phy				phy
.b3e9	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.b3eb	b1 1e		lda ($1e),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.b3ed	f0 54		beq $b443			beq 	_UVBadNumber
.b3ef	48		pha				pha 								; save length.
.b3f0	1a		inc a				inc 	a 							; one for the length, one for the terminator
.b3f1	1a		inc a				inc 	a
.b3f2	20 ab b6	jsr $b6ab			jsr 	AllocateTempString
.b3f5	c8		iny				iny 								; move to the next.
.b3f6	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get character
.b3f8	49 2d		eor #$2d			eor 	#"-"						; zero if minus sign
.b3fa	8d 28 04	sta $0428			sta 	ValSign
.b3fd	d0 01		bne $b400			bne 	_UVNotMinus
.b3ff	c8		iny				iny 								; skip over it.
.b400					_UVNotMinus:
.b400	68		pla				pla 								; this is the count.
.b401	48		pha		_UVCopy:pha									; copy into new temp string which is ASCIIZ
.b402	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b404	c8		iny				iny
.b405	20 d6 b6	jsr $b6d6			jsr 	WriteTempString
.b408	68		pla				pla
.b409	3a		dec a				dec 	a
.b40a	d0 f5		bne $b401			bne 	_UVCopy
.b40c	20 d6 b6	jsr $b6d6			jsr 	WriteTempString 			; make it ASCIIZ
.b40f	18		clc				clc
.b410	a5 20		lda $20				lda 	zTempStr 					; tempstring +1 => genptr
.b412	69 01		adc #$01			adc 	#1
.b414	85 1e		sta $1e				sta 	zGenPtr
.b416	a5 21		lda $21				lda 	zTempStr+1
.b418	69 00		adc #$00			adc 	#0
.b41a	85 1f		sta $1f				sta 	zGenPtr+1
.b41c	18		clc				clc
.b41d	20 d1 b8	jsr $b8d1			jsr 	IntFromString 				; first bit.
.b420	b0 21		bcs $b443			bcs 	_UVBadNumber
.b422	20 f5 be	jsr $bef5			jsr 	FPFromString				; try for a float part.
.b425	ad 28 04	lda $0428			lda 	ValSign 					; was it negative
.b428	d0 13		bne $b43d			bne 	_UVNotNegative
.b42a	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; check if integer
.b42d	4a		lsr a				lsr 	a
.b42e	b0 0a		bcs $b43a			bcs 	_UVInteger
.b430	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; set sign bit
.b433	09 80		ora #$80			ora 	#$80
.b435	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.b438	80 03		bra $b43d			bra 	_UVNotNegative
.b43a					_UVInteger:
.b43a	20 f9 b7	jsr $b7f9			jsr 	IntegerNegateAlways 		; sign it.
.b43d					_UVNotNegative:
.b43d	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; used everything
.b43f	d0 02		bne $b443			bne 	_UVBadNumber
.b441	7a		ply				ply
.b442	60		rts				rts
.b443					_UVBadNumber:
.b443	4c 26 ab	jmp $ab26			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.b446					Unary_Str:
.b446	20 10 b0	jsr $b010			jsr 	EvaluateNumberX 			; numeric parameter
.b449	20 9b b6	jsr $b69b			jsr 	CheckNextRParen 			; right bracket.
.b44c	a9 00		lda #$00			lda 	#0 							; reset buffer index
.b44e	8d 20 04	sta $0420			sta 	NumBufX
.b451	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.b454	4a		lsr a				lsr 	a
.b455	b0 05		bcs $b45c			bcs 	_USInt 						; if msb set do as integer
.b457	20 2e be	jsr $be2e			jsr 	FPToString 					; call fp to str otherwise
.b45a	80 03		bra $b45f			bra 	_USDuplicate
.b45c	20 1e b8	jsr $b81e	_USInt:	jsr 	IntToString
.b45f					_USDuplicate:
.b45f	ad 20 04	lda $0420			lda 	NumBufX 					; chars in buffer
.b462	1a		inc a				inc 	a 							; one more for length
.b463	20 ab b6	jsr $b6ab			jsr 	AllocateTempString 			; allocate space for it.
.b466	5a		phy				phy 								; save Y
.b467	a0 00		ldy #$00			ldy 	#0 							; start copying
.b469	b9 00 04	lda $0400,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.b46c	20 d6 b6	jsr $b6d6			jsr 	WriteTempString
.b46f	c8		iny				iny
.b470	cc 20 04	cpy $0420			cpy 	NumBufX 					; done the lot
.b473	d0 f4		bne $b469			bne 	_USCopy
.b475	7a		ply				ply 								; restore Y
.b476	4c 62 b6	jmp $b662			jmp 	UnaryReturnTempStr 			; return new temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.b479					Unary_Asc:
.b479	20 28 b0	jsr $b028			jsr 	EvaluateStringX 			; string parameter
.b47c	20 9b b6	jsr $b69b			jsr 	CheckNextRParen 			; right bracket.
.b47f	5a		phy				phy 								; get the string length
.b480	a0 00		ldy #$00			ldy 	#0
.b482	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b484	f0 07		beq $b48d			beq 	_UAIllegal 					; must be at least one character
.b486	c8		iny				iny
.b487	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; read it.
.b489	7a		ply				ply
.b48a	4c e9 b2	jmp $b2e9			jmp 	UnarySetAInteger
.b48d					_UAIllegal:
.b48d	4c 26 ab	jmp $ab26			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.b490					Unary_Len:
.b490	20 28 b0	jsr $b028			jsr 	EvaluateStringX 			; string parameter
.b493	20 9b b6	jsr $b69b			jsr 	CheckNextRParen 			; right bracket.
.b496	5a		phy				phy 								; get the string length
.b497	a0 00		ldy #$00			ldy 	#0
.b499	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b49b	7a		ply				ply
.b49c	4c e9 b2	jmp $b2e9			jmp 	UnarySetAInteger

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.b49f					Unary_Mid:
.b49f	20 28 b0	jsr $b028			jsr 	EvaluateStringX 				; get string.
.b4a2	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.b4a5	48		pha				pha
.b4a6	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b4a9	48		pha				pha
.b4aa	20 a3 b6	jsr $b6a3			jsr 	CheckNextComma 					; skip comma
.b4ad	20 3a b5	jsr $b53a			jsr 	SLIByteParameter 				; get a byte parameter (start)
.b4b0	48		pha				pha 									; and push it.
.b4b1	20 a3 b6	jsr $b6a3			jsr 	CheckNextComma 					; skip comma
.b4b4	20 3a b5	jsr $b53a			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.b4b7	48		pha				pha 									; and push it.
.b4b8	80 45		bra $b4ff			bra 	SLIProcess
.b4ba					Unary_Left:
.b4ba	20 28 b0	jsr $b028			jsr 	EvaluateStringX 				; get string.
.b4bd	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.b4c0	48		pha				pha
.b4c1	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b4c4	48		pha				pha
.b4c5	a9 01		lda #$01			lda 	#1 								; push start position (1)
.b4c7	48		pha				pha
.b4c8	20 a3 b6	jsr $b6a3			jsr 	CheckNextComma 					; skip comma
.b4cb	20 3a b5	jsr $b53a			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.b4ce	48		pha				pha 									; and push it.
.b4cf	80 2e		bra $b4ff			bra 	SLIProcess
.b4d1					Unary_Right:
.b4d1	20 28 b0	jsr $b028			jsr 	EvaluateStringX 				; get string.
.b4d4	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.b4d7	48		pha				pha
.b4d8	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b4db	48		pha				pha
.b4dc	da		phx				phx 									; get the string length and push on stack.
.b4dd	a2 00		ldx #$00			ldx 	#0
.b4df	a1 1e		lda ($1e,x)			lda		(zGenPtr,x)
.b4e1	fa		plx				plx
.b4e2	48		pha				pha
.b4e3	20 a3 b6	jsr $b6a3			jsr 	CheckNextComma 					; skip comma
.b4e6	20 3a b5	jsr $b53a			jsr 	SLIByteParameter 				; get a byte parameter.
.b4e9	8d 25 04	sta $0425			sta 	SignCount 						; save in temporary.
.b4ec	68		pla				pla 									; restore string length.
.b4ed	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.b4ee	38		sec				sec
.b4ef	ed 25 04	sbc $0425			sbc 	SignCount 						; subtract characters needed, gives start position.
.b4f2	f0 02		beq $b4f6			beq 	_URStart 						; if <= 0 start from 1.
.b4f4	10 02		bpl $b4f8			bpl 	_UROkay
.b4f6					_URStart:
.b4f6	a9 01		lda #$01			lda 	#1
.b4f8					_UROkay:
.b4f8	48		pha				pha 									; push start
.b4f9	ad 25 04	lda $0425			lda 	SignCount 						; push count of characters
.b4fc	48		pha				pha
.b4fd	80 00		bra $b4ff			bra 	SLIProcess
.b4ff					SLIProcess:
.b4ff	20 9b b6	jsr $b69b			jsr 	CheckNextRParen 				; closing right bracket.
.b502	68		pla				pla
.b503	8d 2a 04	sta $042a			sta 	SliceCount 						; count in signcount
.b506	1a		inc a				inc 	a 								; allocate +1 for it.
.b507	20 ab b6	jsr $b6ab			jsr 	AllocateTempString
.b50a	68		pla				pla 									; pop start number off stack.
.b50b	f0 3f		beq $b54c			beq 	SLIError 						; exit if start = 0
.b50d	8d 29 04	sta $0429			sta 	SliceStart
.b510	68		pla				pla  									; pop string address.
.b511	85 1f		sta $1f				sta 	zGenPtr+1
.b513	68		pla				pla
.b514	85 1e		sta $1e				sta 	zGenPtr
.b516	da		phx				phx
.b517	5a		phy				phy
.b518	a2 00		ldx #$00			ldx 	#0 								; point to string length.
.b51a	ac 29 04	ldy $0429			ldy 	SliceStart 						; start of the string (+1 for count)
.b51d					_SLICopy:
.b51d	ad 2a 04	lda $042a			lda 	SliceCount 						; done count characters
.b520	f0 12		beq $b534			beq 	_SLIExit
.b522	ce 2a 04	dec $042a			dec 	SliceCount
.b525	98		tya				tya 									; index of character
.b526	c1 1e		cmp ($1e,x)			cmp 	(zGenPtr,x)						; compare against length
.b528	f0 02		beq $b52c			beq 	_SLIOk 							; if equal, okay.
.b52a	b0 08		bcs $b534			bcs 	_SLIExit 						; if past end, then exit.
.b52c	b1 1e		lda ($1e),y	_SLIOk:	lda 	(zGenPtr),y 					; copy one character
.b52e	c8		iny				iny
.b52f	20 d6 b6	jsr $b6d6			jsr 	WriteTempString
.b532	80 e9		bra $b51d			bra 	_SLICopy 						; go round till copied characters
.b534					_SLIExit:
.b534	7a		ply				ply 									; restore YX
.b535	fa		plx				plx
.b536	4c 62 b6	jmp $b662			jmp 	UnaryReturnTempStr 				; return new temporary string.
.b539	ea		nop				nop
.b53a					SLIByteParameter:
.b53a	20 1f b0	jsr $b01f			jsr 	EvaluateIntegerX 				; get integer
.b53d	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.b540	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.b543	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.b546	d0 04		bne $b54c			bne 	SLIError
.b548	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b54b	60		rts				rts
.b54c					SLIError:
.b54c	4c 26 ab	jmp $ab26			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.b54f					Unary_Hex:
.b54f	20 1f b0	jsr $b01f			jsr 	EvaluateIntegerX 			; numeric parameter
.b552	20 9b b6	jsr $b69b			jsr 	CheckNextRParen 			; right bracket.
.b555	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.b557	20 ab b6	jsr $b6ab			jsr 	AllocateTempString			; allocate string space
.b55a	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.b55d	20 84 b5	jsr $b584			jsr 	_UHConvert
.b560	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.b563	20 84 b5	jsr $b584			jsr 	_UHConvert
.b566	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b569	20 84 b5	jsr $b584			jsr 	_UHConvert
.b56c	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b56f	20 84 b5	jsr $b584			jsr 	_UHConvert
.b572	5a		phy				phy 								; get length of new string
.b573	a0 00		ldy #$00			ldy 	#0
.b575	b1 20		lda ($20),y			lda 	(zTempStr),y
.b577	7a		ply				ply
.b578	c9 00		cmp #$00			cmp 	#0
.b57a	d0 05		bne $b581			bne 	_UHExit 					; if it was non zero okay
.b57c	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.b57e	20 d6 b6	jsr $b6d6			jsr 	WriteTempString
.b581					_UHExit:
.b581	4c 62 b6	jmp $b662			jmp 	UnaryReturnTempStr 			; return new temporary string.
.b584					_UHConvert:
.b584	48		pha				pha
.b585	4a		lsr a				lsr 	a 							; do MSB
.b586	4a		lsr a				lsr 	a
.b587	4a		lsr a				lsr 	a
.b588	4a		lsr a				lsr 	a
.b589	20 8d b5	jsr $b58d			jsr 	_UHNibble
.b58c	68		pla				pla 								; do LSB
.b58d					_UHNibble:
.b58d	29 0f		and #$0f			and 	#15 						; get nibble
.b58f	d0 0c		bne $b59d			bne 	_UHNonZero
.b591	5a		phy				phy									; get the length
.b592	a0 00		ldy #$00			ldy 	#0
.b594	b1 20		lda ($20),y			lda 	(zTempStr),y
.b596	7a		ply				ply
.b597	c9 00		cmp #$00			cmp 	#0 							; suppress leading zeros.
.b599	f0 0d		beq $b5a8			beq 	_UHExit2
.b59b	a9 00		lda #$00			lda 	#0
.b59d					_UHNonZero:
.b59d	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.b59f	90 02		bcc $b5a3			bcc 	_UHDigit
.b5a1	69 06		adc #$06			adc 	#7-1
.b5a3					_UHDigit:
.b5a3	69 30		adc #$30			adc 	#48
.b5a5	20 d6 b6	jsr $b6d6			jsr 	WriteTempString				; output.
.b5a8					_UHExit2:
.b5a8	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.b5a9					Unary_Dec:
.b5a9	20 28 b0	jsr $b028			jsr 	EvaluateStringX 			; string parameter
.b5ac	20 9b b6	jsr $b69b			jsr 	CheckNextRParen 			; right bracket.
.b5af	5a		phy				phy
.b5b0	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.b5b2	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b5b4	f0 4c		beq $b602			beq 	_UDFail 					; must fail if zero.
.b5b6	8d 25 04	sta $0425			sta 	SignCount 					; use SignCount as a counter
.b5b9	a9 00		lda #$00			lda 	#0 							; set result to zero integer.
.b5bb	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b5be	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b5c1	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b5c4	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b5c7	a9 01		lda #$01			lda 	#1
.b5c9	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.b5cc					_UDConvertLoop:
.b5cc	5a		phy				phy 								; shift mantissa left 4
.b5cd	a0 04		ldy #$04			ldy 	#4
.b5cf					_UDShift:
.b5cf	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x
.b5d2	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.b5d5	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.b5d8	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.b5db	88		dey				dey
.b5dc	d0 f1		bne $b5cf			bne 	_UDShift
.b5de	7a		ply				ply
.b5df	c8		iny				iny 								; next character
.b5e0	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; fetch it.
.b5e2	20 05 b6	jsr $b605			jsr 	ConvertUpper 				; convert to U/C
.b5e5	c9 30		cmp #$30			cmp 	#"0"
.b5e7	90 19		bcc $b602			bcc 	_UDFail
.b5e9	c9 3a		cmp #$3a			cmp 	#"9"+1
.b5eb	90 06		bcc $b5f3			bcc 	_UDOkay
.b5ed	e9 37		sbc #$37			sbc 	#7+"0" 						; alpha fudge
.b5ef	c9 10		cmp #$10			cmp 	#16
.b5f1	b0 0f		bcs $b602			bcs 	_UDFail
.b5f3					_UDOkay:
.b5f3	29 0f		and #$0f			and 	#15 						; nibble only
.b5f5	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x
.b5f8	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b5fb	ce 25 04	dec $0425			dec 	SignCount 					; do it for each character
.b5fe	d0 cc		bne $b5cc			bne 	_UDConvertLoop
.b600	7a		ply				ply
.b601	60		rts				rts
.b602					_UDFail:
.b602	4c 26 ab	jmp $ab26			jmp 	BadParamError
.b605					ConvertUpper:
.b605	c9 61		cmp #$61			cmp 	#"a"
.b607	90 07		bcc $b610			bcc 	_CUExit
.b609	c9 7b		cmp #$7b			cmp 	#"z"+1
.b60b	b0 03		bcs $b610			bcs 	_CUExit
.b60d	38		sec				sec
.b60e	e9 20		sbc #$20			sbc 	#32
.b610	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.b611					Unary_Chr:
.b611	20 1f b0	jsr $b01f			jsr 	EvaluateIntegerX			; numeric parameter
.b614	20 9b b6	jsr $b69b			jsr 	CheckNextRParen 			; right bracket.
.b617	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.b61a	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.b61d	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.b620	d0 0e		bne $b630			bne 	_UCChar
.b622	a9 01		lda #$01			lda 	#1 							; one character string
.b624	20 ab b6	jsr $b6ab			jsr 	AllocateTempString
.b627	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.b62a	20 d6 b6	jsr $b6d6			jsr 	WriteTempString
.b62d	4c 62 b6	jmp $b662			jmp 	UnaryReturnTempStr
.b630					_UCChar:
.b630	4c 26 ab	jmp $ab26			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.b633					Unary_Spc:
.b633	20 1f b0	jsr $b01f			jsr 	EvaluateIntegerX 			; numeric parameter
.b636	20 9b b6	jsr $b69b			jsr 	CheckNextRParen 			; right bracket.
.b639	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.b63c	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.b63f	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.b642	d0 1b		bne $b65f			bne 	_USSize
.b644	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b647	c9 fe		cmp #$fe			cmp 	#maxString+1
.b649	b0 14		bcs $b65f			bcs 	_USSize
.b64b	48		pha				pha 								; save length
.b64c	1a		inc a				inc 	a 							; allocate one more.
.b64d	20 ab b6	jsr $b6ab			jsr 	AllocateTempString
.b650	68		pla				pla 								; get length
.b651	f0 0f		beq $b662			beq 	UnaryReturnTempStr 			; return the current temp string
.b653					_USLoop:
.b653	48		pha				pha
.b654	a9 20		lda #$20			lda 	#" "
.b656	20 d6 b6	jsr $b6d6			jsr 	WriteTempString
.b659	68		pla				pla
.b65a	3a		dec a				dec 	a
.b65b	d0 f6		bne $b653			bne 	_USLoop
.b65d	80 03		bra $b662			bra 	UnaryReturnTempStr
.b65f					_USSize:
.b65f	4c 26 ab	jmp $ab26			jmp 	BadParamError
.b662					UnaryReturnTempStr:
.b662	a5 20		lda $20				lda 	zTempStr 					; copy temp string addr -> mantissa
.b664	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b667	a5 21		lda $21				lda 	zTempStr+1
.b669	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b66c	a9 02		lda #$02			lda 	#2 							; set type to string
.b66e	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.b671	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/4510.asm

.b672					MemRead:
.b672	8d 25 04	sta $0425			sta 	SignCount 					; save count
.b675	a0 00		ldy #$00			ldy 	#0 							; start from here
.b677	b1 1a		lda ($1a),y	_MLoop1:lda 	(zlTemp1),y 				; read the long address
.b679	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; copy into mantissa
.b67c	c8		iny				iny 								; next to copy
.b67d	e8		inx				inx
.b67e	cc 25 04	cpy $0425			cpy 	SignCount 					; do required # of bytes.
.b681	d0 f4		bne $b677			bne 	_MLoop1
.b683	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.b684					CheckNextToken:
.b684	d1 16		cmp ($16),y			cmp 	(zCodePtr),y
.b686	d0 02		bne $b68a			bne 	CTFail 						; no, then fail
.b688	c8		iny				iny
.b689	60		rts				rts
.b68a					CTFail:
.b68a	20 37 ab	jsr $ab37			jsr ERR_Handler
>b68d	4d 69 73 73 69 6e 67 20			.text "Missing token",0
>b695	74 6f 6b 65 6e 00
.b69b					CheckNextRParen:
.b69b	b1 16		lda ($16),y			lda 	(zCodePtr),y
.b69d	c9 bc		cmp #$bc			cmp 	#token_rparen
.b69f	d0 e9		bne $b68a			bne 	CTFail
.b6a1	c8		iny				iny
.b6a2	60		rts				rts
.b6a3					CheckNextComma:
.b6a3	b1 16		lda ($16),y			lda 	(zCodePtr),y
.b6a5	c9 bd		cmp #$bd			cmp 	#token_comma
.b6a7	d0 e1		bne $b68a			bne 	CTFail
.b6a9	c8		iny				iny
.b6aa	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.b6ab					AllocateTempString:
.b6ab	48		pha				pha 								; save required count.
.b6ac	a5 21		lda $21				lda 	zTempStr+1 					; check if initialised yet ?
.b6ae	d0 0b		bne $b6bb			bne 	_ATSInitialised
.b6b0	ad 26 04	lda $0426			lda 	StringPtr 					; set temporary string ptr 1 page below available
.b6b3	85 20		sta $20				sta 	zTempStr					; space, this is for strings to be concreted.
.b6b5	ad 27 04	lda $0427			lda 	StringPtr+1
.b6b8	3a		dec a				dec 	a
.b6b9	85 21		sta $21				sta 	zTempStr+1
.b6bb					_ATSInitialised:
.b6bb	68		pla				pla 								; get required count back.
.b6bc	49 ff		eor #$ff			eor 	#$FF 						; negate 2's complement.
.b6be	1a		inc a				inc 	a
.b6bf	18		clc				clc
.b6c0	65 20		adc $20				adc 	zTempStr 					; "add" to the temp string pointer
.b6c2	85 20		sta $20				sta 	zTempStr
.b6c4	a9 ff		lda #$ff			lda 	#$FF
.b6c6	65 21		adc $21				adc 	zTempStr+1
.b6c8	85 21		sta $21				sta 	zTempStr+1
.b6ca	a9 00		lda #$00			lda 	#0 							; clear temp string.
.b6cc	5a		phy				phy
.b6cd	a8		tay				tay
.b6ce	91 20		sta ($20),y			sta 	(zTempStr),y
.b6d0	7a		ply				ply
.b6d1	1a		inc a				inc 	a 							; reset the write index.
.b6d2	8d 27 04	sta $0427			sta 	TempStringWriteIndex
.b6d5	60		rts				rts
.b6d6					WriteTempString:
.b6d6	5a		phy				phy 								; save Y
.b6d7	ac 27 04	ldy $0427			ldy 	TempStringWriteIndex	 	; write position.
.b6da	91 20		sta ($20),y			sta 	(zTempStr),y 				; write character out.
.b6dc	ee 27 04	inc $0427			inc 	TempStringWriteIndex 		; increment the write position.
.b6df	98		tya				tya 								; unchanged Y is now length
.b6e0	a0 00		ldy #$00			ldy 	#0
.b6e2	91 20		sta ($20),y			sta 	(zTempStr),y
.b6e4	7a		ply				ply 								; restore Y and exit
.b6e5	60		rts				rts
.b6e6					CreateTempStringCopy:
.b6e6	da		phx				phx 								; save X
.b6e7	b1 16		lda ($16),y			lda 	(zCodePtr),y
.b6e9	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.b6ea	20 ab b6	jsr $b6ab			jsr 	AllocateTempString 			; allocate memory for temporary string.
.b6ed	b1 16		lda ($16),y			lda 	(zCodePtr),y
.b6ef	c8		iny				iny
.b6f0	3a		dec a				dec 	a 							; make the actual length in charactes
.b6f1	3a		dec a				dec 	a
.b6f2	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.b6f4	81 20		sta ($20,x)			sta 	(zTempStr,x)
.b6f6	85 1a		sta $1a				sta 	zLTemp1 					; that's used as a count.
.b6f8	09 00		ora #$00			ora 	#0 							; if zero already, exit
.b6fa	f0 0e		beq $b70a			beq 	_CTSCExit
.b6fc					_CTSCLoop:
.b6fc	b1 16		lda ($16),y			lda 	(zCodePtr),y
.b6fe	c8		iny				iny
.b6ff	5a		phy				phy 								; save in Y
.b700	e8		inx				inx 								; bump index
.b701	da		phx				phx 								; index into Y
.b702	7a		ply				ply
.b703	91 20		sta ($20),y			sta 	(zTempStr),y 				; save at index
.b705	7a		ply				ply 								; restore Y
.b706	c6 1a		dec $1a				dec 	zLTemp1 					; do for each character
.b708	d0 f2		bne $b6fc			bne 	_CTSCLoop
.b70a					_CTSCExit:
.b70a	fa		plx				plx 								; restore X
.b70b	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.b70c					MulInteger32:
.b70c	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.b70f	9d 14 03	sta $0314,x			sta 	XS3_Mantissa,x
.b712	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b715	9d 15 03	sta $0315,x			sta 	XS3_Mantissa+1,x
.b718	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.b71b	9d 16 03	sta $0316,x			sta 	XS3_Mantissa+2,x
.b71e	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.b721	9d 17 03	sta $0317,x			sta 	XS3_Mantissa+3,x
.b724	a9 00		lda #$00			lda 	#0
.b726	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x 				; zero +0
.b729	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b72c	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b72f	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b732					_BFMMultiply:
.b732	bd 14 03	lda $0314,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.b735	29 01		and #$01			and 	#1
.b737	f0 03		beq $b73c			beq 	_BFMNoAdd
.b739	20 04 b2	jsr $b204			jsr 	AddInteger32
.b73c					_BFMNoAdd:
.b73c	1e 0e 03	asl $030e,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.b73f	3e 0f 03	rol $030f,x			rol 	XS2_Mantissa+1,x
.b742	3e 10 03	rol $0310,x			rol 	XS2_Mantissa+2,x
.b745	3e 11 03	rol $0311,x			rol 	XS2_Mantissa+3,x
.b748	5e 17 03	lsr $0317,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.b74b	7e 16 03	ror $0316,x			ror 	XS3_Mantissa+2,x
.b74e	7e 15 03	ror $0315,x			ror 	XS3_Mantissa+1,x
.b751	7e 14 03	ror $0314,x			ror 	XS3_Mantissa,x
.b754	bd 14 03	lda $0314,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.b757	1d 15 03	ora $0315,x			ora 	XS3_Mantissa+1,x
.b75a	1d 16 03	ora $0316,x			ora 	XS3_Mantissa+2,x
.b75d	1d 17 03	ora $0317,x			ora 	XS3_Mantissa+3,x
.b760	d0 d0		bne $b732			bne 	_BFMMultiply
.b762	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.b763					DivInteger32:
.b763	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; check for /0
.b766	1d 0f 03	ora $030f,x			ora 	XS2_Mantissa+1,x
.b769	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.b76c	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.b76f	d0 14		bne $b785			bne 	_BFDOkay
.b771	20 37 ab	jsr $ab37			jsr ERR_Handler
>b774	44 69 76 69 73 69 6f 6e			.text "Division by Zero",0
>b77c	20 62 79 20 5a 65 72 6f 00
.b785					_BFDOkay:
.b785	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.b787	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.b789	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.b78b	85 1c		sta $1c				sta 	zLTemp1+2
.b78d	85 1d		sta $1d				sta 	zLTemp1+3
.b78f	8d 25 04	sta $0425			sta 	SignCount 					; Count of signs.
.b792	20 f3 b7	jsr $b7f3			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.b795	da		phx				phx
.b796	e8		inx				inx
.b797	e8		inx				inx
.b798	e8		inx				inx
.b799	e8		inx				inx
.b79a	e8		inx				inx
.b79b	e8		inx				inx
.b79c	20 f3 b7	jsr $b7f3			jsr 	CheckIntegerNegate
.b79f	fa		plx				plx
.b7a0	5a		phy				phy 								; Y is the counter
.b7a1	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.b7a3					_BFDLoop:
.b7a3	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.b7a6	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.b7a9	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.b7ac	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.b7af	26 1a		rol $1a				rol 	zLTemp1
.b7b1	26 1b		rol $1b				rol 	zLTemp1+1
.b7b3	26 1c		rol $1c				rol 	zLTemp1+2
.b7b5	26 1d		rol $1d				rol 	zLTemp1+3
.b7b7	38		sec				sec
.b7b8	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.b7ba	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.b7bd	48		pha				pha
.b7be	a5 1b		lda $1b				lda 	zLTemp1+1
.b7c0	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.b7c3	48		pha				pha
.b7c4	a5 1c		lda $1c				lda 	zLTemp1+2
.b7c6	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.b7c9	48		pha				pha
.b7ca	a5 1d		lda $1d				lda 	zLTemp1+3
.b7cc	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.b7cf	90 15		bcc $b7e6			bcc 	_BFDNoAdd
.b7d1	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.b7d3	68		pla				pla
.b7d4	85 1c		sta $1c				sta 	zLTemp1+2
.b7d6	68		pla				pla
.b7d7	85 1b		sta $1b				sta 	zLTemp1+1
.b7d9	68		pla				pla
.b7da	85 1a		sta $1a				sta 	zLTemp1+0
.b7dc	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.b7df	09 01		ora #$01			ora 	#1
.b7e1	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b7e4	80 03		bra $b7e9			bra 	_BFDNext
.b7e6					_BFDNoAdd:
.b7e6	68		pla				pla 								; Throw away the intermediate calculations
.b7e7	68		pla				pla
.b7e8	68		pla				pla
.b7e9					_BFDNext:
.b7e9	88		dey				dey
.b7ea	d0 b7		bne $b7a3			bne 	_BFDLoop
.b7ec	7a		ply				ply 								; restore Y and exit
.b7ed	4e 25 04	lsr $0425			lsr 	SignCount 					; if sign count odd,
.b7f0	b0 07		bcs $b7f9			bcs		IntegerNegateAlways 			; negate the result
.b7f2	60		rts				rts
.b7f3					CheckIntegerNegate:
.b7f3	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.b7f6	30 01		bmi $b7f9			bmi 	IntegerNegateAlways
.b7f8	60		rts				rts
.b7f9					IntegerNegateAlways:
.b7f9	ee 25 04	inc $0425			inc 	SignCount
.b7fc	38		sec				sec
.b7fd	a9 00		lda #$00			lda 	#0
.b7ff	fd 08 03	sbc $0308,x			sbc 	XS_Mantissa+0,x
.b802	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b805	a9 00		lda #$00			lda 	#0
.b807	fd 09 03	sbc $0309,x			sbc 	XS_Mantissa+1,x
.b80a	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b80d	a9 00		lda #$00			lda 	#0
.b80f	fd 0a 03	sbc $030a,x			sbc 	XS_Mantissa+2,x
.b812	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b815	a9 00		lda #$00			lda 	#0
.b817	fd 0b 03	sbc $030b,x			sbc 	XS_Mantissa+3,x
.b81a	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b81d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.b81e					INTToString:
.b81e	48		pha				pha
.b81f	5a		phy				phy
.b820	bd 0b 03	lda $030b,x			lda 		XS_Mantissa+3,x 		; check -ve
.b823	10 08		bpl $b82d			bpl 		_ITSNotMinus
.b825	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.b827	20 be b8	jsr $b8be			jsr 		ITSOutputCharacter
.b82a	20 f9 b7	jsr $b7f9			jsr 		IntegerNegateAlways 	; negate the number.
.b82d					_ITSNotMinus:
.b82d	a9 00		lda #$00			lda 		#0
.b82f	8d 21 04	sta $0421			sta 		NumSuppress 			; clear the suppression flag.
.b832	8a		txa				txa 								; use Y for the mantissa index.
.b833	a8		tay				tay
.b834	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.b836					_ITSNextSubtractor:
.b836	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.b838	8d 22 04	sta $0422			sta 		NumConvCount
.b83b					_ITSSubtract:
.b83b	38		sec				sec
.b83c	b9 08 03	lda $0308,y			lda 		XS_Mantissa,y 			; subtract number and push on stack
.b83f	fd 9a b8	sbc $b89a,x			sbc 		_ITSSubtractors+0,x
.b842	48		pha				pha
.b843	b9 09 03	lda $0309,y			lda 		XS_Mantissa+1,y
.b846	fd 9b b8	sbc $b89b,x			sbc 		_ITSSubtractors+1,x
.b849	48		pha				pha
.b84a	b9 0a 03	lda $030a,y			lda 		XS_Mantissa+2,y
.b84d	fd 9c b8	sbc $b89c,x			sbc 		_ITSSubtractors+2,x
.b850	48		pha				pha
.b851	b9 0b 03	lda $030b,y			lda 		XS_Mantissa+3,y
.b854	fd 9d b8	sbc $b89d,x			sbc 		_ITSSubtractors+3,x
.b857	90 14		bcc $b86d			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.b859	99 0b 03	sta $030b,y			sta 		XS_Mantissa+3,y 		; save subtract off stack
.b85c	68		pla				pla
.b85d	99 0a 03	sta $030a,y			sta 		XS_Mantissa+2,y
.b860	68		pla				pla
.b861	99 09 03	sta $0309,y			sta 		XS_Mantissa+1,y
.b864	68		pla				pla
.b865	99 08 03	sta $0308,y			sta 		XS_Mantissa+0,y
.b868	ee 22 04	inc $0422			inc 		NumConvCount 			; bump count.
.b86b	80 ce		bra $b83b			bra 		_ITSSubtract 			; go round again.
.b86d					_ITSCantSubtract:
.b86d	68		pla				pla 								; throw away interim answers
.b86e	68		pla				pla
.b86f	68		pla				pla
.b870	ad 22 04	lda $0422			lda 		NumConvCount 			; if not zero then no suppression check
.b873	c9 30		cmp #$30			cmp 		#"0"
.b875	d0 05		bne $b87c			bne 		_ITSOutputDigit
.b877	ad 21 04	lda $0421			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.b87a	10 09		bpl $b885			bpl	 		_ITSGoNextSubtractor
.b87c					_ITSOutputDigit:
.b87c	ce 21 04	dec $0421			dec 		NumSuppress 			; suppression check will be non-zero.
.b87f	ad 22 04	lda $0422			lda 		NumConvCount 			; count of subtractions
.b882	20 be b8	jsr $b8be			jsr 		ITSOutputCharacter 		; output it.
.b885					_ITSGoNextSubtractor:
.b885	e8		inx				inx 								; next dword
.b886	e8		inx				inx
.b887	e8		inx				inx
.b888	e8		inx				inx
.b889	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.b88b	d0 a9		bne $b836			bne 		_ITSNextSubtractor 		; do all the subtractors.
.b88d	98		tya				tya 								; X is back as the mantissa index
.b88e	aa		tax				tax
.b88f	bd 08 03	lda $0308,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.b892	09 30		ora #$30			ora 		#"0"
.b894	20 be b8	jsr $b8be			jsr 		ITSOutputCharacter
.b897	7a		ply				ply 								; and exit
.b898	68		pla				pla
.b899	60		rts				rts
.b89a					_ITSSubtractors:
>b89a	00 ca 9a 3b					.dword 		1000000000
>b89e	00 e1 f5 05					.dword 		100000000
>b8a2	80 96 98 00					.dword 		10000000
>b8a6	40 42 0f 00					.dword 		1000000
>b8aa	a0 86 01 00					.dword 		100000
>b8ae	10 27 00 00					.dword 		10000
>b8b2	e8 03 00 00					.dword 		1000
>b8b6	64 00 00 00					.dword 		100
>b8ba	0a 00 00 00					.dword 		10
.b8be					_ITSSubtractorsEnd:
.b8be					ITSOutputCharacter:
.b8be	48		pha				pha
.b8bf	da		phx				phx
.b8c0	ae 20 04	ldx $0420			ldx 	NumBufX 					; save digit
.b8c3	9d 00 04	sta $0400,x			sta 	Num_Buffer,x
.b8c6	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.b8c8	9d 01 04	sta $0401,x			sta 	Num_Buffer+1,x
.b8cb	ee 20 04	inc $0420			inc 	NumBufX						; bump pointer.
.b8ce	fa		plx				plx
.b8cf	68		pla				pla
.b8d0	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.b8d1					IntFromString:
.b8d1	a0 00		ldy #$00			ldy 	#0
.b8d3	8c 23 04	sty $0423			sty 	ExpTemp 					; this is the converted digit count.
.b8d6					IntFromStringY:
.b8d6	48		pha				pha
.b8d7	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.b8d9	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.b8dc	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b8df	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b8e2	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b8e5	a9 01		lda #$01			lda 	#1
.b8e7	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.b8ea					_IFSLoop:
.b8ea	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.b8ec	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.b8ee	90 60		bcc $b950			bcc 	_IFSExit
.b8f0	c9 3a		cmp #$3a			cmp 	#"9"+1
.b8f2	b0 5c		bcs $b950			bcs 	_IFSExit
.b8f4	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.b8f7	c9 0c		cmp #$0c			cmp 	#12
.b8f9	b0 5f		bcs $b95a			bcs 	_IFSOverflow
.b8fb	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.b8fe	48		pha				pha
.b8ff	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.b902	48		pha				pha
.b903	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b906	48		pha				pha
.b907	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b90a	48		pha				pha
.b90b	20 6f b9	jsr $b96f			jsr 	IFSX1ShiftLeft 				; double
.b90e	20 6f b9	jsr $b96f			jsr 	IFSX1ShiftLeft 				; x 4
.b911	18		clc				clc 								; add saved value x 5
.b912	68		pla				pla
.b913	7d 08 03	adc $0308,x			adc 	XS_Mantissa+0,x
.b916	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b919	68		pla				pla
.b91a	7d 09 03	adc $0309,x			adc 	XS_Mantissa+1,x
.b91d	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b920	68		pla				pla
.b921	7d 0a 03	adc $030a,x			adc 	XS_Mantissa+2,x
.b924	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b927	68		pla				pla
.b928	7d 0b 03	adc $030b,x			adc 	XS_Mantissa+3,x
.b92b	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b92e	20 6f b9	jsr $b96f			jsr 	IFSX1ShiftLeft 				; x 10
.b931	ee 23 04	inc $0423			inc 	ExpTemp 					; bump count of digits processed.
.b934	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.b936	29 0f		and #$0f			and 	#15
.b938	c8		iny				iny
.b939	7d 08 03	adc $0308,x			adc 	XS_Mantissa+0,x
.b93c	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b93f	90 a9		bcc $b8ea			bcc 	_IFSLoop
.b941	fe 09 03	inc $0309,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.b944	d0 a4		bne $b8ea			bne 	_IFSLoop
.b946	fe 0a 03	inc $030a,x			inc 	XS_Mantissa+2,x
.b949	d0 9f		bne $b8ea			bne 	_IFSLoop
.b94b	fe 0b 03	inc $030b,x			inc 	XS_Mantissa+3,x
.b94e	80 9a		bra $b8ea			bra 	_IFSLoop
.b950					_IFSExit:
.b950	98		tya				tya 								; get offset
.b951					_IFSOkay:
.b951	38		sec				sec
.b952	ad 23 04	lda $0423			lda 	ExpTemp
.b955	f0 01		beq $b958			beq 	_IFSSkipFail
.b957	18		clc				clc
.b958					_IFSSkipFail:
.b958	68		pla				pla 								; and exit.
.b959	60		rts				rts
.b95a					_IFSOverflow:
.b95a	20 37 ab	jsr $ab37			jsr 	ERR_Handler
>b95d	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>b965	20 6f 76 65 72 66 6c 6f 77 00
.b96f					IFSX1ShiftLeft:
.b96f	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x
.b972	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.b975	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.b978	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.b97b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.b97c					FPSubtract:
.b97c	48		pha				pha
.b97d	bd 13 03	lda $0313,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.b980	49 80		eor #$80			eor 	#$80
.b982	9d 13 03	sta $0313,x			sta 	XS2_Type,x
.b985	68		pla				pla 								; --- and fall through ---
.b986					FPAdd:
.b986	48		pha				pha
.b987	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.b98a	d0 05		bne $b991			bne 	_FPA_NegativeLHS
.b98c	20 ae b9	jsr $b9ae			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.b98f	68		pla				pla
.b990	60		rts				rts
.b991					_FPA_NegativeLHS:
.b991	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.b994	49 80		eor #$80			eor 	#$80
.b996	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.b999	bd 13 03	lda $0313,x			lda 	XS2_Type,x 					; flip the sign of B and add
.b99c	49 80		eor #$80			eor 	#$80
.b99e	9d 13 03	sta $0313,x			sta 	XS2_Type,x
.b9a1	20 ae b9	jsr $b9ae			jsr 	FPAdd_Worker 				; do the add calculation.
.b9a4	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip sign of X1 back
.b9a7	49 80		eor #$80			eor 	#$80
.b9a9	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.b9ac	68		pla				pla
.b9ad	60		rts				rts
.b9ae					FPAdd_Worker:
.b9ae	3c 13 03	bit $0313,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.b9b1	70 08		bvs $b9bb			bvs 	_FPAWExit 					; no change.
.b9b3	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.b9b6	50 07		bvc $b9bf			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.b9b8	20 53 bc	jsr $bc53			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.b9bb					_FPAWExit:
.b9bb	20 db bc	jsr $bcdb			jsr 	FPUNormalise 				; normalise the result.
.b9be	60		rts				rts
.b9bf					_FPAWMakeSame:
.b9bf	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.b9c2	38		sec				sec
.b9c3	fd 12 03	sbc $0312,x			sbc	 	XS2_Exponent,x 				; using subtraction
.b9c6	f0 1b		beq $b9e3			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.b9c8	da		phx				phx 								; save X
.b9c9	90 06		bcc $b9d1			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.b9cb	e8		inx				inx
.b9cc	e8		inx				inx
.b9cd	e8		inx				inx
.b9ce	e8		inx				inx
.b9cf	e8		inx				inx
.b9d0	e8		inx				inx
.b9d1					_FPAWShiftA:
.b9d1	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x 				; so shift exponent up.
.b9d4	5e 0b 03	lsr $030b,x			lsr 	3+XS_Mantissa,x
.b9d7	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.b9da	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.b9dd	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.b9e0	fa		plx				plx 								; restore original X
.b9e1	80 dc		bra $b9bf			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.b9e3					_FPAW_DoArithmetic:
.b9e3	3c 13 03	bit $0313,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.b9e6	30 39		bmi $ba21			bmi 	_FPAW_BNegative
.b9e8	18		clc				clc
.b9e9	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b9ec	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.b9ef	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b9f2	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b9f5	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.b9f8	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b9fb	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.b9fe	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.ba01	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.ba04	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.ba07	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.ba0a	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.ba0d	90 ac		bcc $b9bb			bcc 	_FPAWExit 					; no carry.
.ba0f	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x 				; so shift exponent up.
.ba12	38		sec				sec
.ba13	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.ba16	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.ba19	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.ba1c	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.ba1f	80 9a		bra $b9bb			bra 	_FPAWExit
.ba21					_FPAW_BNegative:
.ba21	38		sec				sec
.ba22	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.ba25	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.ba28	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.ba2b	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.ba2e	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.ba31	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.ba34	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.ba37	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.ba3a	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.ba3d	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.ba40	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.ba43	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.ba46	b0 0b		bcs $ba53			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.ba48	20 80 bc	jsr $bc80			jsr 	FPUNegateInteger			; negate the mantissa
.ba4b	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip result sign
.ba4e	49 80		eor #$80			eor 	#$80
.ba50	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.ba53					_FPAWGoExit:
.ba53	4c bb b9	jmp $b9bb			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.ba56					FPD_IsDivZero:
.ba56	20 37 ab	jsr $ab37			jsr ERR_Handler
>ba59	44 69 76 69 73 69 6f 6e			.text "Division by zero",0
>ba61	20 62 79 20 7a 65 72 6f 00
.ba6a					FPDivide:
.ba6a	48		pha				pha
.ba6b	5a		phy				phy
.ba6c	3c 13 03	bit $0313,x			bit 	XS2_Type,x 					; check if division by zero
.ba6f	70 e5		bvs $ba56			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.ba71	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.ba74	f0 03		beq $ba79			beq 	_FPDCalculateExp
.ba76					_FPD_Exit:
.ba76	7a		ply				ply
.ba77	68		pla				pla
.ba78	60		rts				rts
.ba79					_FPDCalculateExp:
.ba79	bd 12 03	lda $0312,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.ba7c	49 ff		eor #$ff			eor 	#$FF
.ba7e	1a		inc a				inc 	a
.ba7f	9d 12 03	sta $0312,x			sta 	XS2_Exponent,x
.ba82	20 76 bb	jsr $bb76			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.ba85	18		clc				clc 	 							; add 1 to the resulting exponent
.ba86	69 01		adc #$01			adc 	#1
.ba88	b0 65		bcs $baef			bcs 	_FPD_Overflow 				; which can overflow.
.ba8a	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.ba8d	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.ba8f	85 1a		sta $1a				sta 	zLTemp1+0
.ba91	85 1b		sta $1b				sta 	zLTemp1+1
.ba93	85 1c		sta $1c				sta 	zLTemp1+2
.ba95	85 1d		sta $1d				sta 	zLTemp1+3
.ba97	a0 20		ldy #$20			ldy 	#32 						; times round.
.ba99					_FPD_Loop:
.ba99	38		sec				sec 								; calculate X1-X2 stacking result because we might
.ba9a	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; not save it.
.ba9d	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa,x
.baa0	48		pha				pha
.baa1	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.baa4	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.baa7	48		pha				pha
.baa8	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.baab	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.baae	48		pha				pha
.baaf	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.bab2	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.bab5	90 17		bcc $bace			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.bab7	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x 			; save results out to A
.baba	68		pla				pla
.babb	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.babe	68		pla				pla
.babf	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.bac2	68		pla				pla
.bac3	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.bac6	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.bac8	09 80		ora #$80			ora 	#$80
.baca	85 1d		sta $1d				sta 	zLTemp1+3
.bacc	80 03		bra $bad1			bra 	_FPD_Rotates
.bace					_FPD_NoSubtract:
.bace	68		pla				pla 								; throw away unwanted results
.bacf	68		pla				pla
.bad0	68		pla				pla
.bad1					_FPD_Rotates:
.bad1	5e 11 03	lsr $0311,x			lsr 	3+XS2_Mantissa,x
.bad4	7e 10 03	ror $0310,x			ror 	2+XS2_Mantissa,x
.bad7	7e 0f 03	ror $030f,x			ror 	1+XS2_Mantissa,x
.bada	7e 0e 03	ror $030e,x			ror 	0+XS2_Mantissa,x
.badd	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.badf	26 1b		rol $1b				rol 	zLTemp1+1
.bae1	26 1c		rol $1c				rol 	zLTemp1+2
.bae3	26 1d		rol $1d				rol 	zLTemp1+3
.bae5	90 02		bcc $bae9			bcc 	_FPD_NoCarry
.bae7	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.bae9					_FPD_NoCarry:
.bae9	88		dey				dey 								; do 32 times
.baea	d0 ad		bne $ba99			bne 	_FPD_Loop
.baec	4c 53 bb	jmp $bb53			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.baef					_FPD_Overflow:
.baef	4c 50 bd	jmp $bd50			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.baf2					FPMultiply:
.baf2	48		pha				pha
.baf3	5a		phy				phy
.baf4	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.baf7	70 08		bvs $bb01			bvs 	_FPM_Exit
.baf9	3c 13 03	bit $0313,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.bafc	50 06		bvc $bb04			bvc 	_FPM_CalcExponent
.bafe	20 53 bc	jsr $bc53			jsr 	FPUCopyX2ToX1
.bb01					_FPM_Exit:
.bb01	7a		ply				ply
.bb02	68		pla				pla
.bb03	60		rts				rts
.bb04					_FPM_CalcExponent:
.bb04	18		clc				clc
.bb05	20 76 bb	jsr $bb76			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.bb08	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x 				; save the result.
.bb0b	a9 00		lda #$00			lda 	#0
.bb0d	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.bb0f	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.bb11	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.bb13	85 1d		sta $1d				sta 	zLTemp1+3
.bb15	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.bb17					_FPM_Loop:
.bb17	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x				; check LSB of long product
.bb1a	29 01		and #$01			and 	#1
.bb1c	18		clc				clc 								; clear carry for the long rotate.
.bb1d	f0 1d		beq $bb3c			beq 	_FPM_NoAddition
.bb1f	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.bb20	a5 1a		lda $1a				lda 	zLTemp1+0
.bb22	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.bb25	85 1a		sta $1a				sta 	zLTemp1+0
.bb27	a5 1b		lda $1b				lda 	zLTemp1+1
.bb29	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.bb2c	85 1b		sta $1b				sta 	zLTemp1+1
.bb2e	a5 1c		lda $1c				lda 	zLTemp1+2
.bb30	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.bb33	85 1c		sta $1c				sta 	zLTemp1+2
.bb35	a5 1d		lda $1d				lda 	zLTemp1+3
.bb37	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.bb3a	85 1d		sta $1d				sta 	zLTemp1+3
.bb3c					_FPM_NoAddition:
.bb3c	66 1d		ror $1d				ror 	3+zLTemp1
.bb3e	66 1c		ror $1c				ror 	2+zLTemp1
.bb40	66 1b		ror $1b				ror 	1+zLTemp1
.bb42	66 1a		ror $1a				ror 	0+zLTemp1
.bb44	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.bb47	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.bb4a	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.bb4d	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.bb50	88		dey				dey
.bb51	d0 c4		bne $bb17			bne 	_FPM_Loop 					; do this 32 times.
.bb53					FPM_CopySignNormalize:
.bb53	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.bb55	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.bb58	a5 1b		lda $1b				lda 	zLTemp1+1
.bb5a	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.bb5d	a5 1c		lda $1c				lda 	zLTemp1+2
.bb5f	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.bb62	a5 1d		lda $1d				lda 	zLTemp1+3
.bb64	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.bb67	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; sign is xor of signs
.bb6a	5d 13 03	eor $0313,x			eor 	XS2_Type,x
.bb6d	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bb70	20 db bc	jsr $bcdb			jsr 	FPUNormalise 				; normalise and exit.
.bb73	7a		ply				ply
.bb74	68		pla				pla
.bb75	60		rts				rts
.bb76					FPCalculateExponent:
.bb76	18		clc				clc
.bb77	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.bb7a	7d 12 03	adc $0312,x			adc 	XS2_Exponent,x
.bb7d	b0 08		bcs $bb87			bcs 	_FPCECarry 					; carry out ?
.bb7f	10 03		bpl $bb84			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.bb81	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.bb83	60		rts				rts
.bb84					_FPCEExpZero:
.bb84	a9 00		lda #$00			lda 	#0
.bb86	60		rts				rts
.bb87					_FPCECarry:
.bb87	30 03		bmi $bb8c			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.bb89	09 80		ora #$80			ora 	#$80 						; put in right range
.bb8b	60		rts				rts
.bb8c					_FPCEOverflow:
.bb8c	4c 50 bd	jmp $bd50			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.bb8f					FPFractionalPart:
.bb8f	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.bb92	38		sec				sec 								; this flag tells us to keep the fractional part
.bb93	30 0f		bmi $bba4			bmi 	FPGetPart
.bb95	60		rts				rts
.bb96					FPIntegerPart:
.bb96	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.bb99	18		clc				clc 								; this flag says keep the integer part.
.bb9a	30 08		bmi $bba4			bmi 	FPGetPart 					; -ve exponents are 0..127
.bb9c	48		pha				pha
.bb9d	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.bb9f	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bba2	68		pla				pla
.bba3	60		rts				rts
.bba4					FPGetPart:
.bba4	48		pha				pha
.bba5	5a		phy				phy 								; save Y
.bba6	08		php				php 								; save action
.bba7	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.bbaa	70 62		bvs $bc0e			bvs 	_FPGP_Exit 					; then do nothing.
.bbac	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.bbae	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.bbb0	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.bbb2	85 1c		sta $1c				sta 	zLTemp1+2
.bbb4	85 1d		sta $1d				sta 	zLTemp1+3
.bbb6	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x				; the number of shifts.
.bbb9	38		sec				sec
.bbba	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.bbbc	f0 12		beq $bbd0			beq 	_FPGP_NoShift 				; ... if any
.bbbe	c9 20		cmp #$20			cmp 	#32
.bbc0	90 02		bcc $bbc4			bcc 	_FPGP_NotMax
.bbc2	a9 20		lda #$20			lda 	#32 						; max of 32.
.bbc4					_FPGP_NotMax:
.bbc4	a8		tay				tay 								; Y is the mask shift count.
.bbc5					_FPGP_ShiftMask:
.bbc5	46 1d		lsr $1d				lsr 	3+zLTemp1
.bbc7	66 1c		ror $1c				ror 	2+zLTemp1
.bbc9	66 1b		ror $1b				ror 	1+zLTemp1
.bbcb	66 1a		ror $1a				ror 	0+zLTemp1
.bbcd	88		dey				dey
.bbce	d0 f5		bne $bbc5			bne 	_FPGP_ShiftMask
.bbd0					_FPGP_NoShift:
.bbd0	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.bbd2	8e 23 04	stx $0423			stx 	ExpTemp						; save X
.bbd5					_FPGP_MaskLoop:
.bbd5	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.bbd8	28		plp				plp 								; if CC we keep the top part, so we
.bbd9	08		php				php		 							; flip the mask.
.bbda	b0 02		bcs $bbde			bcs		_FPGP_NoFlip
.bbdc	49 ff		eor #$ff			eor 	#$FF
.bbde					_FPGP_NoFlip:
.bbde	3d 08 03	and $0308,x			and 	XS_Mantissa,x 				; and into the mantissa.
.bbe1	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.bbe4	e8		inx				inx
.bbe5	c8		iny				iny
.bbe6	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.bbe8	d0 eb		bne $bbd5			bne 	_FPGP_MaskLoop
.bbea	ae 23 04	ldx $0423			ldx 	ExpTemp						; restore X
.bbed	28		plp				plp
.bbee	08		php				php 								; get action flag on the stack
.bbef	90 05		bcc $bbf6			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.bbf1	a9 00		lda #$00			lda 	#0
.bbf3	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bbf6					_FPGP_NotFractional:
.bbf6	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 						; check if \1 zero
.bbf9	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.bbfc	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.bbff	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.bc02	f0 05		beq $bc09			beq 	_FPGP_Zero 					; if zero, return zero
.bc04	20 db bc	jsr $bcdb			jsr 	FPUNormalise
.bc07	80 05		bra $bc0e			bra 	_FPGP_Exit 					; and exit
.bc09					_FPGP_Zero:
.bc09	a9 40		lda #$40			lda 	#$40 						; set zero flag
.bc0b	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bc0e					_FPGP_Exit:
.bc0e	68		pla				pla 								; throw saved action flag.
.bc0f	7a		ply				ply
.bc10	68		pla				pla
.bc11	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.bc12					FPCompare:
.bc12	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.bc15	48		pha				pha
.bc16	bd 12 03	lda $0312,x			lda 	XS2_Exponent,x
.bc19	48		pha				pha
.bc1a	20 7c b9	jsr $b97c			jsr 	FPSubtract 					; calculate X1-X2
.bc1d	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.bc20	70 2c		bvs $bc4e			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.bc22	68		pla				pla
.bc23	8d 23 04	sta $0423			sta 	ExpTemp						; save first exponent in temporary reg.
.bc26	68		pla				pla
.bc27	38		sec				sec
.bc28	ed 23 04	sbc $0423			sbc 	ExpTemp 					; calculate AX-BX
.bc2b	70 15		bvs $bc42			bvs 	_FPCNotEqual				; overflow, can't be equal.
.bc2d	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.bc2e	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.bc30	b0 10		bcs $bc42			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.bc32	38		sec				sec
.bc33	ad 23 04	lda $0423			lda 	ExpTemp 					; get one of the exponents back.
.bc36	e9 18		sbc #$18			sbc 	#24 						; allow for 2^24 error, relatively.
.bc38	b0 02		bcs $bc3c			bcs 	_FPCNotRange 				; keep in range.
.bc3a	a9 01		lda #$01			lda 	#1
.bc3c					_FPCNotRange:
.bc3c	38		sec				sec
.bc3d	fd 0c 03	sbc $030c,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.bc40	b0 0e		bcs $bc50			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.bc42					_FPCNotEqual:
.bc42	bd 0d 03	lda $030d,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.bc45	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.bc47	f0 02		beq $bc4b			beq 	_FPCNE2
.bc49	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.bc4b	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.bc4c	80 04		bra $bc52			bra 	_FPCExit
.bc4e					_FPCPullZero:
.bc4e	68		pla				pla 								; throw saved exponents
.bc4f	68		pla				pla
.bc50					_FPCZero:
.bc50	a9 00		lda #$00			lda 	#0 							; and return zero
.bc52					_FPCExit:
.bc52	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.bc53					FPUCopyX2ToX1:
.bc53	48		pha				pha
.bc54	da		phx				phx
.bc55	5a		phy				phy
.bc56	a0 08		ldy #$08			ldy 	#8
.bc58	bd 0e 03	lda $030e,x	_FPUC21:lda 	XS2_Mantissa,x
.bc5b	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.bc5e	e8		inx				inx
.bc5f	88		dey				dey
.bc60	10 f6		bpl $bc58			bpl 	_FPUC21
.bc62	7a		ply				ply
.bc63	fa		plx				plx
.bc64	68		pla				pla
.bc65	60		rts				rts
.bc66					FPUSetInteger:
.bc66	48		pha				pha
.bc67	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.bc6a	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.bc6c	10 02		bpl $bc70			bpl 	_FPUSIExtend
.bc6e	a9 ff		lda #$ff			lda 	#$FF
.bc70					_FPUSIExtend:
.bc70	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.bc73	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.bc76	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.bc79	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.bc7b	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bc7e	68		pla				pla
.bc7f	60		rts				rts
.bc80					FPUNegateInteger:
.bc80	48		pha				pha
.bc81	38		sec				sec
.bc82	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.bc84	fd 08 03	sbc $0308,x			sbc 	XS_Mantissa+0,x
.bc87	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.bc8a	a9 00		lda #$00			lda 	#0
.bc8c	fd 09 03	sbc $0309,x			sbc 	XS_Mantissa+1,x
.bc8f	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.bc92	a9 00		lda #$00			lda 	#0
.bc94	fd 0a 03	sbc $030a,x			sbc 	XS_Mantissa+2,x
.bc97	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.bc9a	a9 00		lda #$00			lda 	#0
.bc9c	fd 0b 03	sbc $030b,x			sbc 	XS_Mantissa+3,x
.bc9f	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.bca2	68		pla				pla
.bca3	60		rts				rts
.bca4					FPUToFloat:
.bca4	48		pha				pha
.bca5	bd 0d 03	lda $030d,x			lda 	XS_Type,x					; exit if already float.
.bca8	29 0f		and #$0f			and 	#$0F
.bcaa	f0 2d		beq $bcd9			beq 	_FPUFExit
.bcac	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.bcae	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bcb1	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.bcb3	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x 				; x mantissa.
.bcb6	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.bcb9	10 08		bpl $bcc3			bpl		_FPUFPositive
.bcbb	20 80 bc	jsr $bc80			jsr 	FPUNegateInteger 			; negate the mantissa
.bcbe	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.bcc0	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bcc3					_FPUFPositive:
.bcc3	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.bcc6	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.bcc9	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.bccc	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.bccf	d0 05		bne $bcd6			bne 	_FPUFNonZero
.bcd1	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.bcd3	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bcd6					_FPUFNonZero:
.bcd6	20 db bc	jsr $bcdb			jsr 	FPUNormalise 				; normalise the floating point.
.bcd9					_FPUFExit:
.bcd9	68		pla				pla
.bcda	60		rts				rts
.bcdb					FPUNormalise:
.bcdb	48		pha				pha
.bcdc	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.bcdf	70 20		bvs $bd01			bvs 	_FPUNExit
.bce1	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.bce4	f0 16		beq $bcfc			beq 	_FPUNSetZero
.bce6					_FPUNLoop:
.bce6	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.bce9	30 16		bmi $bd01			bmi 	_FPUNExit 					; if so, we are normalised.
.bceb	1e 08 03	asl $0308,x			asl 	0+XS_Mantissa+0,x
.bcee	3e 09 03	rol $0309,x			rol 	1+XS_Mantissa+0,x
.bcf1	3e 0a 03	rol $030a,x			rol 	2+XS_Mantissa+0,x
.bcf4	3e 0b 03	rol $030b,x			rol 	3+XS_Mantissa+0,x
.bcf7	de 0c 03	dec $030c,x			dec 	XS_Exponent,x 				; decrement exponent
.bcfa	d0 ea		bne $bce6			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.bcfc					_FPUNSetZero:
.bcfc	a9 40		lda #$40			lda 	#$40
.bcfe	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; the result is now zero.
.bd01					_FPUNExit:
.bd01	68		pla				pla
.bd02	60		rts				rts
.bd03					FPUToInteger:
.bd03	48		pha				pha
.bd04	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; if already integer, exit
.bd07	29 01		and #$01			and 	#1
.bd09	d0 3e		bne $bd49			bne 	_FPUTOI_Exit
.bd0b	3c 0d 03	bit $030d,x			bit 	XS_Type,x					; if zero, return zero.
.bd0e	70 2b		bvs $bd3b			bvs 	_FPUTOI_Zero
.bd10	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.bd13	10 26		bpl $bd3b			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.bd15	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.bd17	b0 37		bcs $bd50			bcs 	FP_Overflow
.bd19					_FPUToIToInteger:
.bd19	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.bd1c	c9 a0		cmp #$a0			cmp 	#128+32
.bd1e	f0 11		beq $bd31			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.bd20	fe 0c 03	inc $030c,x			inc 	XS_Exponent,X 				; increment Exponent
.bd23	5e 0b 03	lsr $030b,x			lsr 	3+XS_Mantissa,x
.bd26	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.bd29	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.bd2c	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.bd2f	80 e8		bra $bd19			bra 	_FPUToIToInteger 			; keep going.
.bd31					_FPUToICheckSign:
.bd31	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; check sign
.bd34	10 13		bpl $bd49			bpl 	_FPUToI_Exit 				; exit if unsigned.
.bd36	20 80 bc	jsr $bc80			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.bd39	80 0e		bra $bd49			bra 	_FPUTOI_Exit
.bd3b					_FPUTOI_Zero:
.bd3b	a9 00		lda #$00			lda 	#0 							; return zero integer.
.bd3d	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.bd40	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.bd43	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.bd46	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.bd49					_FPUToI_Exit:
.bd49	a9 01		lda #$01			lda 	#1 							; set type to integer
.bd4b	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bd4e	68		pla				pla
.bd4f	60		rts				rts
.bd50					FP_Overflow:
.bd50	20 37 ab	jsr $ab37			jsr ERR_Handler
>bd53	46 6c 6f 61 74 69 6e 67			.text "Floating Point overflow",0
>bd5b	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.bd6b					FPUTimes10:
.bd6b	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.bd6e	85 1a		sta $1a				sta 	ZLTemp1+0
.bd70	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.bd73	85 1b		sta $1b				sta 	ZLTemp1+1
.bd75	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.bd78	85 1c		sta $1c				sta 	ZLTemp1+2
.bd7a	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.bd7d	85 1d		sta $1d				sta 	ZLTemp1+3
.bd7f	20 c3 bd	jsr $bdc3			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.bd82	20 c3 bd	jsr $bdc3			jsr 	_FPUT_LSR_ZLTemp1
.bd85	18		clc				clc
.bd86	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.bd89	65 1a		adc $1a				adc 	ZLTemp1+0
.bd8b	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.bd8e	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.bd91	65 1b		adc $1b				adc 	ZLTemp1+1
.bd93	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.bd96	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.bd99	65 1c		adc $1c				adc 	ZLTemp1+2
.bd9b	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.bd9e	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.bda1	65 1d		adc $1d				adc 	ZLTemp1+3
.bda3	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.bda6	90 0f		bcc $bdb7			bcc 	_FPUTimes10
.bda8	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.bdab	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.bdae	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.bdb1	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.bdb4	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x				; fix exponent
.bdb7					_FPUTimes10:
.bdb7	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.bdba	18		clc				clc
.bdbb	69 03		adc #$03			adc 	#3
.bdbd	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.bdc0	b0 8e		bcs $bd50			bcs 	FP_Overflow 				; error
.bdc2	60		rts				rts
.bdc3					_FPUT_LSR_ZLTemp1:
.bdc3	46 1d		lsr $1d				lsr 	ZLTemp1+3
.bdc5	66 1c		ror $1c				ror 	ZLTemp1+2
.bdc7	66 1b		ror $1b				ror 	ZLTemp1+1
.bdc9	66 1a		ror $1a				ror 	ZLTemp1+0
.bdcb	60		rts				rts
.bdcc					FPUScale10A:
.bdcc	5a		phy				phy
.bdcd	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.bdcf	f0 3d		beq $be0e			beq 	_FPUScaleExit
.bdd1	da		phx				phx 								; save X
.bdd2	e8		inx				inx
.bdd3	e8		inx				inx
.bdd4	e8		inx				inx
.bdd5	e8		inx				inx
.bdd6	e8		inx				inx
.bdd7	e8		inx				inx
.bdd8	a8		tay				tay 								; save power scalar in Y.
.bdd9	a9 00		lda #$00			lda 	#0
.bddb	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.bdde	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.bde1	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.bde4	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bde7	a9 80		lda #$80			lda 	#$80
.bde9	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.bdec	a9 81		lda #$81			lda 	#$81
.bdee	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.bdf1	5a		phy				phy 								; save 10^n on stack.
.bdf2	c0 00		cpy #$00			cpy 	#0
.bdf4	10 05		bpl $bdfb			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.bdf6	98		tya				tya
.bdf7	49 ff		eor #$ff			eor 	#$FF
.bdf9	1a		inc a				inc 	a
.bdfa	a8		tay				tay
.bdfb					_FPUSAbs:
.bdfb	20 6b bd	jsr $bd6b			jsr 	FPUTimes10
.bdfe	88		dey				dey
.bdff	d0 fa		bne $bdfb			bne 	_FPUSAbs 					; tos is now 10^|AC|
.be01	68		pla				pla 								; restore count in A
.be02	fa		plx				plx 								; restore X pointing to number to scale.
.be03	0a		asl a				asl 	a
.be04	b0 05		bcs $be0b			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.be06	20 f2 ba	jsr $baf2			jsr 	FPMultiply 					; if clear multiply.
.be09	80 03		bra $be0e			bra		_FPUScaleExit
.be0b					_FPUSDivide:
.be0b	20 6a ba	jsr $ba6a			jsr 	FPDivide
.be0e					_FPUScaleExit:
.be0e	7a		ply				ply
.be0f	60		rts				rts
.be10					FPUCopyToNext:
.be10	a0 06		ldy #$06			ldy 		#6
.be12	da		phx				phx
.be13					_FPUCopy1:
.be13	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x
.be16	9d 0e 03	sta $030e,x			sta 	XS2_Mantissa,x
.be19	e8		inx				inx
.be1a	88		dey				dey
.be1b	d0 f6		bne $be13			bne 	_FPUCopy1
.be1d	fa		plx				plx
.be1e	60		rts				rts
.be1f					FPUCopyFromNext:
.be1f	a0 06		ldy #$06			ldy 		#6
.be21	da		phx				phx
.be22					_FPUCopy1:
.be22	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa,x
.be25	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.be28	e8		inx				inx
.be29	88		dey				dey
.be2a	d0 f6		bne $be22			bne 	_FPUCopy1
.be2c	fa		plx				plx
.be2d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.be2e					FPToString:
.be2e	48		pha				pha
.be2f	5a		phy				phy
.be30	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; check zero flag
.be33	50 0a		bvc $be3f			bvc 		_FPTSIsFloat 			; if zero,
.be35					_FPTSZero:
.be35	a9 30		lda #$30			lda 		#"0"
.be37	20 be b8	jsr $b8be			jsr 		ITSOutputCharacter
.be3a					_FPTSExit:
.be3a	7a		ply				ply
.be3b	68		pla				pla
.be3c	60		rts				rts
.be3d	80 fb		bra $be3a			bra 		_FPTSExit
.be3f					_FPTSIsFloat:
.be3f	bd 0d 03	lda $030d,x			lda 		XS_Type,x 				; is it signed ?
.be42	10 0a		bpl $be4e			bpl 		_FPTSNotSigned
.be44	a9 00		lda #$00			lda 		#0 						; clear sign flag
.be46	9d 0d 03	sta $030d,x			sta 		XS_Type,x
.be49	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.be4b	20 be b8	jsr $b8be			jsr 		ITSOutputCharacter
.be4e					_FPTSNotSigned:
.be4e	bd 0c 03	lda $030c,x			lda 		XS_Exponent,x
.be51	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.be53	b0 09		bcs $be5e			bcs 		_FPTSExponent
.be55	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.be57	90 05		bcc $be5e			bcc 		_FPTSExponent 			;
.be59					_FPTSStandard:
.be59	20 a2 be	jsr $bea2			jsr 		FPTOutputBody 			; output the body.
.be5c	80 dc		bra $be3a			bra 		_FPTSExit
.be5e					_FPTSExponent:
.be5e	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.be60	8d 24 04	sta $0424			sta 		ExpCount
.be63					_FPTSExponentLoop:
.be63	bd 0c 03	lda $030c,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.be66	10 0e		bpl $be76			bpl 		_FPTSTimes
.be68	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.be6a	90 14		bcc $be80			bcc 		_FPTSScaledToExp
.be6c	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.be6e	20 cc bd	jsr $bdcc			jsr 		FPUScale10A
.be71	ee 24 04	inc $0424			inc 		ExpCount
.be74	80 ed		bra $be63			bra 		_FPTSExponentLoop
.be76					_FPTSTimes:
.be76	a9 01		lda #$01			lda 		#1
.be78	20 cc bd	jsr $bdcc			jsr 		FPUScale10A
.be7b	ce 24 04	dec $0424			dec 		ExpCount
.be7e	80 e3		bra $be63			bra 		_FPTSExponentLoop
.be80					_FPTSScaledToExp:
.be80	20 a2 be	jsr $bea2			jsr 		FPTOutputBody 			; output the body.
.be83	a9 65		lda #$65			lda 		#"e"					; output E
.be85	20 be b8	jsr $b8be			jsr 		ITSOutputCharacter
.be88	ad 24 04	lda $0424			lda 		ExpCount 				; get the exponent
.be8b	9d 08 03	sta $0308,x			sta 		XS_Mantissa,x
.be8e	29 80		and #$80			and 		#$80 					; sign extend it
.be90	f0 02		beq $be94			beq 		_FPTSSExt
.be92	a9 ff		lda #$ff			lda 		#$FF
.be94					_FPTSSExt:
.be94	9d 09 03	sta $0309,x			sta 		XS_Mantissa+1,x
.be97	9d 0a 03	sta $030a,x			sta 		XS_Mantissa+2,x
.be9a	9d 0b 03	sta $030b,x			sta 		XS_Mantissa+3,x
.be9d	20 1e b8	jsr $b81e			jsr 		INTToString 			; output the exponent.
.bea0	80 98		bra $be3a			bra			_FPTSExit 				; and exit.
.bea2					FPTOutputBody:
.bea2	20 10 be	jsr $be10			jsr 		FPUCopyToNext 			; copy to next slot.
.bea5	20 03 bd	jsr $bd03			jsr 		FPUToInteger 			; convert to an integer
.bea8	20 1e b8	jsr $b81e			jsr 		INTToString 			; output the main integer part.
.beab	20 1f be	jsr $be1f			jsr 		FPUCopyFromNext 		; get the fractional part back.
.beae	20 8f bb	jsr $bb8f			jsr 		FPFractionalPart 		; get the decimal part.
.beb1	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; any fractional part.
.beb4	70 3e		bvs $bef4			bvs 		_FPTOExit 				; if not, exit now.
.beb6	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.beb8	20 be b8	jsr $b8be			jsr 		ITSOutputCharacter
.bebb					_FPOutLoop:
.bebb	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; finally reached zero.
.bebe	70 1e		bvs $bede			bvs 		_FPStripZeros 			; strip trailing zeros
.bec0	20 6b bd	jsr $bd6b			jsr 		FPUTimes10 				; multiply by 10
.bec3	20 10 be	jsr $be10			jsr 		FPUCopyToNext			; copy to next slot.
.bec6	20 03 bd	jsr $bd03			jsr 		FPUToInteger 			; convert to integer
.bec9	bd 08 03	lda $0308,x			lda 		XS_Mantissa+0,x 		; print digit.
.becc	09 30		ora #$30			ora 		#"0"
.bece	20 be b8	jsr $b8be			jsr 		ITSOutputCharacter
.bed1	20 1f be	jsr $be1f			jsr 		FPUCopyFromNext 		; get it back
.bed4	20 8f bb	jsr $bb8f			jsr 		FPFractionalPart 		; get fractional part
.bed7	ad 20 04	lda $0420			lda 		NumBufX 				; done 11 characters yet ?
.beda	c9 0b		cmp #$0b			cmp 	 	#11
.bedc	90 dd		bcc $bebb			bcc 		_FPOutLoop 				; if so, keep going till zero.
.bede					_FPStripZeros:
.bede	ac 20 04	ldy $0420			ldy 		NumBufX 				; strip trailing zeros.
.bee1					_FPStripLoop:
.bee1	88		dey				dey 								; back one, if at start then no strip
.bee2	f0 10		beq $bef4			beq 		_FPToExit
.bee4	b9 00 04	lda $0400,y			lda 		Num_Buffer,y 			; keep going if "0"
.bee7	c9 30		cmp #$30			cmp 		#"0"
.bee9	f0 f6		beq $bee1			beq 		_FPStripLoop
.beeb	c8		iny				iny
.beec	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.beee	99 00 04	sta $0400,y			sta 		Num_Buffer,y
.bef1	8c 20 04	sty $0420			sty 		NumBufX 				; update position.
.bef4					_FPTOExit:
.bef4	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.bef5					FPFromString:
.bef5	48		pha				pha 								; push A
.bef6	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.bef8	c9 2e		cmp #$2e			cmp 	#"."
.befa	f0 03		beq $beff			beq	 	_FPFIsDecimal
.befc	4c 62 bf	jmp $bf62			jmp 	_FPFNotDecimal
.beff					_FPFIsDecimal:
.beff	c8		iny				iny 								; consume the decimal.
.bf00	20 a4 bc	jsr $bca4			jsr 	FPUToFloat 					; convert the integer to float.
.bf03	da		phx				phx 								; save X.
.bf04	5a		phy				phy 								; save decimal start position
.bf05	e8		inx				inx
.bf06	e8		inx				inx
.bf07	e8		inx				inx
.bf08	e8		inx				inx
.bf09	e8		inx				inx
.bf0a	e8		inx				inx
.bf0b	20 d6 b8	jsr $b8d6			jsr 	INTFromStringY 				; get the part after the DP.
.bf0e	20 a4 bc	jsr $bca4			jsr 	FPUToFloat 					; convert that to a float.
.bf11	68		pla				pla 								; calculate - chars consumed.
.bf12	8c 23 04	sty $0423			sty 	ExpTemp
.bf15	38		sec				sec
.bf16	ed 23 04	sbc $0423			sbc 	ExpTemp 					; this is the shift amount
.bf19	20 cc bd	jsr $bdcc			jsr 	FPUScale10A 				; scale it by 10^AC
.bf1c	fa		plx				plx 								; restore original X
.bf1d	20 86 b9	jsr $b986			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.bf20	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.bf22	c9 45		cmp #$45			cmp 	#"E"
.bf24	f0 04		beq $bf2a			beq 	_FPFExponent
.bf26	c9 65		cmp #$65			cmp 	#"e"
.bf28	d0 38		bne $bf62			bne 	_FPFNotDecimal 				; no, then exit normally.
.bf2a					_FPFExponent:
.bf2a	c8		iny				iny 								; skip over E symbol.
.bf2b	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.bf2d	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.bf2f	d0 01		bne $bf32			bne 	_FPFGotSign
.bf31	c8		iny				iny 								; if it was - skip over it.
.bf32					_FPFGotSign:
.bf32	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.bf33	da		phx				phx
.bf34	e8		inx				inx
.bf35	e8		inx				inx
.bf36	e8		inx				inx
.bf37	e8		inx				inx
.bf38	e8		inx				inx
.bf39	e8		inx				inx
.bf3a	20 d6 b8	jsr $b8d6			jsr 	INTFromStringY 				; get the exponent
.bf3d	fa		plx				plx 								; restore X.
.bf3e	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.bf41	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.bf44	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.bf47	d0 1b		bne $bf64			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.bf49	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.bf4c	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.bf4e	b0 14		bcs $bf64			bcs 	_FPFXOverflow
.bf50	68		pla				pla 								; get direction
.bf51	d0 09		bne $bf5c			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.bf53	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.bf56	49 ff		eor #$ff			eor 	#$FF
.bf58	1a		inc a				inc 	a
.bf59	9d 0e 03	sta $030e,x			sta 	XS2_Mantissa+0,x
.bf5c					_FPFXScale:
.bf5c	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.bf5f	20 cc bd	jsr $bdcc			jsr 	FPUScale10A 				; scale by the exponent.
.bf62					_FPFNotDecimal:
.bf62	68		pla				pla
.bf63	60		rts				rts
.bf64					_FPFXOverflow:
.bf64	20 37 ab	jsr $ab37			jsr 	ERR_Handler
>bf67	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>bf6f	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.bf76					Unary_Rnd:
.bf76	20 10 b0	jsr $b010			jsr 	EvaluateNumberX 			; get value
.bf79	20 9b b6	jsr $b69b			jsr 	CheckNextRParen 			; check right bracket.
.bf7c	20 fd b2	jsr $b2fd			jsr 	GetSignCurrent 				; get sign -1,0,1.
.bf7f	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.bf81	30 10		bmi $bf93			bmi 	_URSetSeed
.bf83	f0 2c		beq $bfb1			beq 	_URMakeRandom 				; if zero return same number.
.bf85	da		phx				phx
.bf86	a2 00		ldx #$00			ldx 	#0
.bf88	20 ee bf	jsr $bfee			jsr 	Random16
.bf8b	a2 02		ldx #$02			ldx 	#2
.bf8d	20 ee bf	jsr $bfee			jsr 	Random16
.bf90	fa		plx				plx
.bf91	80 1e		bra $bfb1			bra 	_URMakeRandom
.bf93					_URSetSeed:
.bf93	20 a4 bc	jsr $bca4			jsr 	FPUToFloat 					; make it a float to twiddle it.
.bf96	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.bf99	8d 2b 04	sta $042b			sta 	RandomSeed+0
.bf9c	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.bf9f	8d 2c 04	sta $042c			sta 	RandomSeed+1
.bfa2	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.bfa5	8d 2d 04	sta $042d			sta 	RandomSeed+2
.bfa8	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.bfab	0a		asl a				asl 	a
.bfac	49 db		eor #$db			eor 	#$DB
.bfae	8d 2e 04	sta $042e			sta 	RandomSeed+3
.bfb1					_URMakeRandom:
.bfb1	ad 2b 04	lda $042b			lda 	RandomSeed+0 				; check if seed is zero.
.bfb4	0d 2c 04	ora $042c			ora 	RandomSeed+1
.bfb7	0d 2d 04	ora $042d			ora 	RandomSeed+2
.bfba	0d 2e 04	ora $042e			ora 	RandomSeed+3
.bfbd	d0 0a		bne $bfc9			bne 	_URNotZero
.bfbf	a9 47		lda #$47			lda 	#$47
.bfc1	8d 2c 04	sta $042c			sta 	RandomSeed+1				; if it is, make it non zero.
.bfc4	a9 3d		lda #$3d			lda 	#$3D
.bfc6	8d 2e 04	sta $042e			sta 	RandomSeed+3
.bfc9					_URNotZero:
.bfc9	ad 2b 04	lda $042b			lda 	RandomSeed+0 				; copy seed into mantissa.
.bfcc	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.bfcf	ad 2c 04	lda $042c			lda 	RandomSeed+1
.bfd2	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.bfd5	ad 2d 04	lda $042d			lda 	RandomSeed+2
.bfd8	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.bfdb	ad 2e 04	lda $042e			lda 	RandomSeed+3
.bfde	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.bfe1	a9 00		lda #$00			lda 	#$00 						; set type to float.
.bfe3	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bfe6	a9 80		lda #$80			lda 	#$80
.bfe8	9d 0c 03	sta $030c,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.bfeb	4c db bc	jmp $bcdb			jmp 	FPUNormalise
.bfee					Random16:
.bfee	5e 2c 04	lsr $042c,x			lsr 	RandomSeed+1,x				; shift seed right
.bff1	7e 2b 04	ror $042b,x			ror 	RandomSeed,x
.bff4	90 08		bcc $bffe			bcc 	_R16_NoXor
.bff6	bd 2c 04	lda $042c,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.bff9	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.bffb	9d 2c 04	sta $042c,x			sta 	RandomSeed+1,x
.bffe					_R16_NoXor:
.bffe	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.bfff					Unary_Int:
.bfff	20 10 b0	jsr $b010			jsr 	EvaluateNumberX 			; get value
.c002	20 9b b6	jsr $b69b			jsr 	CheckNextRParen 			; check right bracket.
.c005	4c 03 bd	jmp $bd03			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.c008					TIM_Error:
.c008	20 35 a0	jsr $a035			jsr 	IFT_UpLine 					; go up one line.
.c00b	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.c00d	80 02		bra $c011			bra 	TIM_ShowPrompt
.c00f					TIM_NewCommand:
.c00f	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.c011					TIM_ShowPrompt:
.c011	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.c014	20 f9 a0	jsr $a0f9			jsr 	IFT_ReadLine	 			; get character, go to next line
.c017	20 5b a0	jsr $a05b			jsr 	IFT_NewLine					; go to next line.
.c01a	86 10		stx $10				stx 	zTemp1 						; save line read address
.c01c	84 11		sty $11				sty 	zTemp1+1
.c01e	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.c020	b1 10		lda ($10),y			lda 	(zTemp1),y
.c022	c9 3f		cmp #$3f			cmp 	#"?"
.c024	f0 04		beq $c02a			beq 	TIM_SkipFirst
.c026	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.c028	d0 01		bne $c02b			bne 	TIM_NotDot
.c02a					TIM_SkipFirst:
.c02a	c8		iny				iny
.c02b					TIM_NotDot:
.c02b	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.c02d	c9 52		cmp #$52			cmp 	#"R"						; show registers
.c02f	f0 6e		beq $c09f			beq 	TIM_ShowRegisters
.c031	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.c033	f0 12		beq $c047			beq 	TIM_ShowMemory
.c035	c9 47		cmp #$47			cmp 	#"G"						; execute
.c037	f0 49		beq $c082			beq 	TIM_Execute
.c039	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.c03b	f0 07		beq $c044			beq 	TIM_GoLoadMemory
.c03d	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.c03f	d0 c7		bne $c008			bne 	TIM_Error
.c041	4c c4 c1	jmp $c1c4			jmp 	TIM_UpdateRegisters
.c044					TIM_GoLoadMemory:
.c044	4c ef c1	jmp $c1ef			jmp 	TIM_LoadMemory
.c047					TIM_ShowMemory:
.c047	20 3d c1	jsr $c13d			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.c04a	b0 bc		bcs $c008			bcs 	TIM_Error
.c04c	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.c04e	85 12		sta $12				sta 	zTemp2
.c050	a5 15		lda $15				lda 	zTemp3+1
.c052	85 13		sta $13				sta 	zTemp2+1
.c054	20 3d c1	jsr $c13d			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.c057	90 08		bcc $c061			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.c059	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.c05b	85 14		sta $14				sta 	zTemp3
.c05d	a5 13		lda $13				lda 	zTemp2+1
.c05f	85 15		sta $15				sta 	zTemp3+1
.c061					_TIMSM_Start:
.c061	20 15 c1	jsr $c115			jsr 	TIM_WriteLine 				; write one line of hex out
.c064	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.c066	18		clc				clc
.c067	69 10		adc #$10			adc 	#16
.c069	85 12		sta $12				sta 	zTemp2
.c06b	90 02		bcc $c06f			bcc 	_TIMSM_NoCarry
.c06d	e6 13		inc $13				inc 	zTemp2+1
.c06f					_TIMSM_NoCarry:
.c06f	20 e4 a1	jsr $a1e4			jsr 	IF_CheckBreak 				; check CTL+C
.c072	d0 0b		bne $c07f			bne 	_TIMSM_Ends 				; if pressed break out.
.c074	38		sec				sec 								; check past the end address in zTemp3
.c075	a5 14		lda $14				lda 	zTemp3
.c077	e5 12		sbc $12				sbc 	zTemp2
.c079	a5 15		lda $15				lda 	zTemp3+1
.c07b	e5 13		sbc $13				sbc 	zTemp2+1
.c07d	10 e2		bpl $c061			bpl 	_TIMSM_Start
.c07f					_TIMSM_Ends:
.c07f	4c 0f c0	jmp $c00f			jmp 	TIM_NewCommand
.c082					TIM_Execute:
.c082	20 3d c1	jsr $c13d			jsr 	TIM_GetHex 					; get the execute address
.c085	b0 81		bcs $c008			bcs 	TIM_Error 					; not legitimate
.c087	ae 38 04	ldx $0438			ldx 	TIM_SP 						; set up SP
.c08a	9a		txs				txs
.c08b	ad 33 04	lda $0433			lda 	TIM_SR 						; Status for PLP
.c08e	48		pha				pha
.c08f	ad 34 04	lda $0434			lda 	TIM_A 						; restore AXYZ
.c092	ae 35 04	ldx $0435			ldx 	TIM_X
.c095	ac 36 04	ldy $0436			ldy 	TIM_Y
.c098	ab 37 04	ldz $0437			ldz 	TIM_Z
.c09b	28		plp				plp 								; and PS Byte.
.c09c	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.c09f					TIM_Start:
.c09f					TIM_ShowRegisters:
.c09f	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.c0a2	8d 32 04	sta $0432			sta 	TIM_IRQ+1
.c0a5	ad ff ff	lda $ffff			lda 	$FFFF
.c0a8	8d 31 04	sta $0431			sta 	TIM_IRQ
.c0ab	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.c0ad					_TIMSR_Text:
.c0ad	bd d9 c0	lda $c0d9,x			lda 	_TIMSR_Label,x
.c0b0	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.c0b3	e8		inx				inx
.c0b4	e0 23		cpx #$23			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.c0b6	d0 f5		bne $c0ad			bne 	_TIMSR_Text
.c0b8	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.c0ba					_TIMSR_Skip:
.c0ba	e8		inx				inx
.c0bb					_TIMSR_LoopSpace:
.c0bb	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.c0bd	b0 04		bcs $c0c3			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.c0bf	8a		txa				txa
.c0c0	4a		lsr a				lsr 	a
.c0c1	b0 05		bcs $c0c8			bcs 	_TIMSR_NoSpace
.c0c3					_TIMSR_Space:
.c0c3	a9 20		lda #$20			lda 	#" "
.c0c5	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.c0c8					_TIMSR_NoSpace:
.c0c8	bd 2f 04	lda $042f,x			lda 	TIM_PC,x 					; output hex value.
.c0cb	20 fc c0	jsr $c0fc			jsr 	TIM_WriteHex
.c0ce	e8		inx				inx
.c0cf	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.c0d1	d0 e8		bne $c0bb			bne 	_TimSR_LoopSpace
.c0d3	20 5b a0	jsr $a05b			jsr 	IFT_NewLine 				; new line
.c0d6	4c 0f c0	jmp $c00f			jmp	 	TIM_NewCommand 				; new command.
.c0d9					_TIMSR_Label:
>c0d9	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>c0e1	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>c0f1	52
>c0f2	20 5a 52					.text 	" ZR"
>c0f5	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.c0fc					_TIMSR_LabelEnd:
.c0fc					TIM_WriteHex:
.c0fc	48		pha				pha 								; save A
.c0fd	4a		lsr a				lsr 	a 							; shift MSB->LSB
.c0fe	4a		lsr a				lsr 	a
.c0ff	4a		lsr a				lsr 	a
.c100	4a		lsr a				lsr 	a
.c101	20 05 c1	jsr $c105			jsr 	_TIMWH_Nibble 				; print MSB
.c104	68		pla				pla 								; restore and print LSB
.c105					_TIMWH_Nibble:
.c105	48		pha				pha
.c106	29 0f		and #$0f			and 	#15 						; mask out
.c108	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.c10a	90 02		bcc $c10e			bcc 	_TIMWHNoLetter
.c10c	69 06		adc #$06			adc 	#6
.c10e					_TIMWHNoLetter:
.c10e	69 30		adc #$30			adc 	#48
.c110	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter 			; print it out.
.c113	68		pla				pla
.c114	60		rts				rts
.c115					TIM_WriteLine:
.c115	a9 2e		lda #$2e			lda 	#"." 						; prompt
.c117	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.c11a	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.c11c	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.c11f	a5 13		lda $13				lda 	zTemp2+1 					; write address
.c121	20 fc c0	jsr $c0fc			jsr 	TIM_WriteHex
.c124	a5 12		lda $12				lda 	zTemp2
.c126	20 fc c0	jsr $c0fc			jsr 	TIM_WriteHex
.c129	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.c12b					_TIMWL_Loop:
.c12b	a9 20		lda #$20			lda 	#" "
.c12d	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.c130	b1 12		lda ($12),y			lda 	(zTemp2),y
.c132	20 fc c0	jsr $c0fc			jsr 	TIM_WriteHex
.c135	c8		iny				iny
.c136	c0 10		cpy #$10			cpy 	#16
.c138	d0 f1		bne $c12b			bne 	_TIMWL_Loop
.c13a	4c 5b a0	jmp $a05b			jmp 	IFT_NewLine 				; new line and exit
.c13d					TIM_GetHex:
.c13d	c8		iny				iny
.c13e	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.c140	c9 20		cmp #$20			cmp 	#32
.c142	f0 f9		beq $c13d			beq 	TIM_GetHex
.c144	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.c146	f0 f5		beq $c13d			beq 	TIM_GetHex
.c148	20 71 c1	jsr $c171			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.c14b	b0 23		bcs $c170			bcs 	_TIMGH_Exit					; if first bad then exit now.
.c14d	a9 00		lda #$00			lda 	#0 							; zero result
.c14f	85 14		sta $14				sta 	zTemp3
.c151	85 15		sta $15				sta 	zTemp3+1
.c153					_TIM_GHLoop:
.c153	20 71 c1	jsr $c171			jsr 	TIM_GetHexCharacter 		; get next character
.c156	b0 17		bcs $c16f			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.c158	c8		iny				iny 								; skip over it.
.c159	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.c15b	26 15		rol $15				rol 	zTemp3+1
.c15d	06 14		asl $14				asl 	zTemp3 						; now x 2
.c15f	26 15		rol $15				rol 	zTemp3+1
.c161	06 14		asl $14				asl 	zTemp3						; now x 4
.c163	26 15		rol $15				rol 	zTemp3+1
.c165	06 14		asl $14				asl 	zTemp3 						; now x 8
.c167	26 15		rol $15				rol 	zTemp3+1
.c169	05 14		ora $14				ora 	zTemp3 						; OR result in
.c16b	85 14		sta $14				sta 	zTemp3
.c16d	80 e4		bra $c153			bra 	_TIM_GHLoop 				; loop round again.
.c16f					_TIMGH_Okay:
.c16f	18		clc				clc
.c170					_TIMGH_Exit:
.c170	60		rts				rts
.c171					TIM_GetHexCharacter:
.c171	b1 10		lda ($10),y			lda 	(zTemp1),y
.c173	38		sec				sec
.c174	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.c176	90 0e		bcc $c186			bcc 	_TIM_GHCFail
.c178	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.c17a	90 0b		bcc $c187			bcc 	_TIM_GHCExit
.c17c	c9 11		cmp #$11			cmp 	#65-48						; < A
.c17e	90 06		bcc $c186			bcc		_TIM_GHCFail
.c180	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.c182	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.c184	90 01		bcc $c187			bcc		_TIM_GHCExit
.c186					_TIM_GHCFail:
.c186	38		sec				sec
.c187					_TIM_GHCExit:
.c187	60		rts				rts
.c188					TIM_BreakVector:
.c188	da		phx				phx									; save X/A on stack
.c189	48		pha				pha
.c18a	ba		tsx				tsx 								; X points to S
.c18b	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.c18e	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.c190	d0 03		bne $c195			bne 	_TIMBreak					; if set, it's BRK
.c192	68		pla				pla 								; abandon routine.
.c193	fa		plx				plx
.c194	40		rti				rti
.c195					_TIMBreak:
.c195	68		pla				pla 								; save A X Y and maybe Z
.c196	8d 34 04	sta $0434			sta 	TIM_A
.c199	fa		plx				plx
.c19a	8e 35 04	stx $0435			stx 	TIM_X
.c19d	8c 36 04	sty $0436			sty 	TIM_Y
.c1a0	9c 37 04	stz $0437			stz 	TIM_Z
.c1a3	68		pla				pla 								; get Status Register
.c1a4	8d 33 04	sta $0433			sta 	TIM_SR
.c1a7	68		pla				pla
.c1a8	8d 30 04	sta $0430			sta 	TIM_PC+1 					; save calling address
.c1ab	68		pla				pla
.c1ac	8d 2f 04	sta $042f			sta 	TIM_PC 						; high byte
.c1af	ad 30 04	lda $0430			lda 	TIM_PC+1 					; dec PC to point right.
.c1b2	d0 03		bne $c1b7			bne 	_TIMDecrement 				; brk bumps it.
.c1b4	ce 2f 04	dec $042f			dec 	TIM_PC
.c1b7					_TIMDecrement:
.c1b7	ce 30 04	dec $0430			dec 	TIM_PC+1
.c1ba	ba		tsx				tsx 								; and copy SP
.c1bb	8e 38 04	stx $0438			stx 	TIM_SP
.c1be	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.c1c0	9a		txs				txs
.c1c1	4c 9f c0	jmp $c09f			jmp 	TIM_Start 					; and start up TIM monitor.
.c1c4					TIM_UpdateRegisters:
.c1c4	20 3d c1	jsr $c13d			jsr 	TIM_GetHex 					; PC
.c1c7	b0 23		bcs $c1ec			bcs 	_TIMURFail
.c1c9	a5 14		lda $14				lda 	zTemp3
.c1cb	8d 30 04	sta $0430			sta 	Tim_PC+1
.c1ce	a5 15		lda $15				lda 	zTemp3+1
.c1d0	8d 2f 04	sta $042f			sta 	Tim_PC
.c1d3	20 3d c1	jsr $c13d			jsr 	TIM_GetHex 					; ignore IRQ
.c1d6	b0 14		bcs $c1ec			bcs 	_TIMURFail
.c1d8	a2 00		ldx #$00			ldx 	#0
.c1da					_TIM_URLoop:
.c1da	20 3d c1	jsr $c13d			jsr 	TIM_GetHex 					; registers
.c1dd	b0 0d		bcs $c1ec			bcs 	_TIMURFail
.c1df	a5 14		lda $14				lda 	zTemp3
.c1e1	9d 33 04	sta $0433,x			sta 	Tim_SR,x
.c1e4	e8		inx				inx
.c1e5	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.c1e7	d0 f1		bne $c1da			bne 	_TIM_URLoop
.c1e9	4c 0f c0	jmp $c00f			jmp 	TIM_NewCommand
.c1ec					_TIMURFail:
.c1ec	4c 08 c0	jmp $c008			jmp 	TIM_Error
.c1ef					TIM_LoadMemory:
.c1ef	20 3d c1	jsr $c13d			jsr 	TIM_GetHex 					; target address => zTemp2
.c1f2	a5 14		lda $14				lda 	zTemp3
.c1f4	85 12		sta $12				sta 	zTemp2
.c1f6	a5 15		lda $15				lda 	zTemp3+1
.c1f8	85 13		sta $13				sta 	zTemp2+1
.c1fa					_TIM_LMLoop:
.c1fa	20 3d c1	jsr $c13d			jsr 	TIM_GetHex 					; next byte ?
.c1fd	b0 0e		bcs $c20d			bcs 	_TIMLMDone 					; no more
.c1ff	a2 00		ldx #$00			ldx 	#0							; write out.
.c201	a5 14		lda $14				lda 	zTemp3
.c203	81 12		sta ($12,x)			sta 	(zTemp2,x)
.c205	e6 12		inc $12				inc 	zTemp2 						; bump address
.c207	d0 f1		bne $c1fa			bne 	_TIM_LMLoop
.c209	e6 13		inc $13				inc 	zTemp2+1
.c20b	80 ed		bra $c1fa			bra 	_TIM_LMLoop
.c20d					_TIMLMDone:
.c20d	4c 0f c0	jmp $c00f			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Return to file: basic.asm

.c210	80 fe		bra $c210	_halt:	bra 		_halt
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 a0						.word 	StartROM
>fffe	88 c1					.word TIM_BreakVector

;******  End of listing
