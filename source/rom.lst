
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Sat Aug 31 07:48:52 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="65816"				cpu = "65816"
="em65816"				hardware = "em65816"
=1					exitonend = 1
=0					autorun = 0
=1					loadtest = 1
=1					hasfloat = 1
=1					hasinteger = 1
=253					maxstring = 253

;******  Processing file: modules/basic/pointer/em65816/src_em65816.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stackmarkers.inc

=5					SourcePosSize   =   5 							; Source position stack space needed.
=0					SMark_Gosub 	= 	0 							; 0 is GOSUB/RETURN.
=1					SMark_Repeat 	= 	1 							; 1 is REPEAT/UNTIL.
=2					SMark_While 	= 	2 							; 2 is WHILE/WEND.
=3					SMark_If 		= 	3 							; 3 is IF/ENDIF
=4					SMark_For 		= 	4 							; 4 is FOR/NEXT

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/hardware/common/macros32.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0020					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0022					zVarDataPtr: .word ? 						; position of variable data.
>0024					zVarType: 	.byte ? 						; type of data (token)
>0025					zNullString:.byte ? 						; represents a NULL string.
>0026					zBasicSP:	.word ? 						; stack pointer
>0080					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>0084					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>0085					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=134					XS2_Mantissa = XS_Mantissa+XS_Size
=138					XS2_Exponent = XS_Exponent+XS_Size
=139					XS2_Type = XS_Type+XS_Size
=140					XS3_Mantissa = XS_Mantissa+XS_Size*2
=144					XS3_Exponent = XS_Exponent+XS_Size*2
=145					XS3_Type = XS_Type+XS_Size*2
>0300					StringPtr:	.word ? 						; Top of free memory (for string allocation)
>0302					VarMemPtr: 	.word ?							; Bottom of free memory (for variables)
>0304					endOfProgram: .dword ? 						; End of Program Memory (long)
>0308					vecPrintCharacter .word ?
>030a					vecInputCharacter .word ?
>030c					UserVector .fill 4 							; USR(x) calls this.
>0310					LocalVector .fill 4 						; Indirect calls call this.
>0314					NumBufX 	.byte 	?						; buffer index position
>0315					Num_Buffer	.fill 	32 						; buffer for numeric conversions
=6					HashTableCount = 6 							; there are 6 hash tables, in token order.
=8					HashTableSize = 8 							; each hash table as 8 links.
.0335					HashTableBase:
>0335								.fill	HashTableCount * HashTableSize * 2
.0395					HashTableEnd:
=$315					Var_Buffer 	= Num_Buffer 					; buffer for variable name (same space)
>0395					Var_Type    .byte ? 						; type of variable (as a type token)
>0396					Var_Hash 	.byte ? 						; hash of identifier name.
>0397					Var_Length 	.byte ? 						; length of variable name
>0398					Var_HashAddress .byte ?						; low byte of hash table entry.
>0399					Var_DataSize .byte ?						; size of one element.
>039a					NumSuppress	.byte 	?						; leading zero suppression flag
>039b					NumConvCount .byte 	? 						; count for conversions.
>039c					ExpTemp:	.byte ?							; Working temp for exponents.
>039d					ExpCount:	.byte ? 						; Count of decimal exponents.
>039e					SignCount:	.byte ?							; Integer Divide Sign Counts.
>039f					TempStringWriteIndex: .byte ? 				; Write offset.
>03a0					ValSign: 	.byte ? 						; sign flag for val()
>03a1					SliceStart:	.byte ? 						; string slice parts
>03a2					SliceCount:	.byte ?
>03a3					RandomSeed:	.dword ? 						; Random seed.
>03a7					SignNext:	.byte ? 						; Used for keeping sign of STEP in FOR/NEXT
>03a8					BreakCount:	.byte ? 						; Counter, avoid checking break every command.
=3					ArrayMaxDim = 3 							; number of dimensions.
>03a9					ArrayDef:	.fill (ArrayMaxDim+1)*2 		; dimensions for auto-creation
>03b1					UsrArrayDef:.fill (ArrayMaxDim+1)*2 		; dimensions created in DIM
>03b9					UsrArrayIdx:.byte ? 						; index into UsrArrayDef
>03ba					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>03bc					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>03be					Tim_SR:		.byte ? 						; Processor Status
>03bf					Tim_A:		.byte ? 						; Processor Registers
>03c0					Tim_X:		.byte ?
>03c1					Tim_Y:		.byte ?
>03c2					Tim_Z:		.byte ?
>03c3					Tim_SP:		.word ?							; Stack Pointer (just in cases)
>0400					BasicStack:	.fill 	256 					; and occupy whole pages.
.0500					EndBasicStack:
>0500					IFT_XCursor:.byte ?							; current logical position on screen
>0501					IFT_YCursor:.byte ?
>0502					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0566					IFT_LineBuffer: .fill 100 					; line input buffer.

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/em65816.asm

=$7f00					HighMemory = $7F00
=$3000					VariableMemory = $3000
.1000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testcode.src

>1000	0e 0a 00 92 09 84 41 c8			.byte	$0e,$0a,$00,$92,$09,$84,$41,$c8
>1008	4f 68 fd 03 30 00 06 14			.byte	$4f,$68,$fd,$03,$30,$00,$06,$14
>1010	00 97 09 00 05 1e 00 cd			.byte	$00,$97,$09,$00,$05,$1e,$00,$cd
>1018	00 00					.byte	$00,$00

;******  Return to file: modules/hardware/em65816.asm

.c000					StartROM:
.c000	18		clc				clc
.c001	fb		xce				xce
.c002	c2 30		rep #$30			rep 	#$30
.c004	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.c007	1b		tcs				tcs
.c008	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.c00b	e2 30		sep #$30			sep 	#$30
.c00d	c2 30		rep #$30			rep 	#$30						; clear AXY in 16 bit.
.c00f	a9 00		lda #$00			lda 	#$0000
.c011	aa		tax				tax
.c012	a8		tay				tay
.c013	e2 30		sep #$30			sep 	#$30
.c015	5c df 87 01	jmp $0187df		jmp BASIC_Start
.c019					TIM_BreakHandler:
.c019	5c 76 83 01	jmp $018376			jmp 	TIM_BreakVector

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.018000					IFT_ClearScreen:
.018000	48		pha				pha
.018001	da		phx				phx
.018002	5a		phy				phy
.018003	20 a9 81	jsr $0181a9			jsr 	IF_Home 					; home cursor
.018006	a2 20		ldx #$20			ldx 	#IF_Height 					; this many lines.
.018008					_IFT_CS0:
.018008	a0 40		ldy #$40			ldy 	#IF_Width 					; this many chars/line
.01800a					_IFT_CS1:
.01800a	a9 20		lda #$20			lda 	#' '						; clear line.
.01800c	20 d5 81	jsr $0181d5			jsr 	IF_Write
.01800f	88		dey				dey
.018010	d0 f8		bne $01800a			bne 	_IFT_CS1
.018012	20 bc 81	jsr $0181bc			jsr 	IF_NewLine 					; next line down
.018015	ca		dex				dex
.018016	d0 f0		bne $018008			bne 	_IFT_CS0
.018018	7a		ply				ply
.018019	fa		plx				plx
.01801a	68		pla				pla
.01801b					IFT_HomeCursor:
.01801b	48		pha				pha
.01801c	20 a9 81	jsr $0181a9			jsr 	IF_Home
.01801f	a9 00		lda #$00			lda 	#0
.018021	8d 00 05	sta $0500			sta 	IFT_XCursor
.018024	8d 01 05	sta $0501			sta 	IFT_YCursor
.018027	68		pla				pla
.018028	60		rts				rts
.018029					IFT_UpLine:
.018029	48		pha				pha
.01802a	ad 01 05	lda $0501			lda  	IFT_YCursor 				; get Y
.01802d	3a		dec a				dec 	a 							; line above
.01802e	30 03		bmi $018033			bmi 	_IFTULExit 					; too far, abort
.018030	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos					; set to that line.
.018033					_IFTULExit:
.018033	68		pla				pla
.018034	60		rts				rts
.018035					IFT_PrintCharacter:
.018035	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.018037	f0 23		beq $01805c			beq 	IFT_NewLine
.018039	48		pha				pha
.01803a	20 74 80	jsr $018074			jsr 	IFT_UpperCase 				; make upper case
.01803d	20 d5 81	jsr $0181d5			jsr 	IF_Write 					; write out.
.018040	ee 00 05	inc $0500			inc 	IFT_XCursor 				; bump x cursor
.018043	ad 00 05	lda $0500			lda 	IFT_XCursor 				; reached RHS ?
.018046	c9 40		cmp #$40			cmp 	#IF_Width
.018048	d0 03		bne $01804d			bne 	_IFT_PCNotEOL
.01804a	20 5c 80	jsr $01805c			jsr 	IFT_NewLine 				; if so do new line.
.01804d					_IFT_PCNotEOL:
.01804d	68		pla				pla
.01804e	60		rts				rts
.01804f					IFT_Tab:
.01804f	a9 20		lda #$20			lda 	#" " 						; space
.018051	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018054	ad 00 05	lda $0500			lda 	IFT_XCursor 				; until x % 8 == 0
.018057	29 07		and #$07			and 	#7
.018059	d0 f4		bne $01804f			bne 	IFT_Tab
.01805b	60		rts				rts
.01805c					IFT_NewLine:
.01805c	48		pha				pha
.01805d	20 bc 81	jsr $0181bc			jsr 	IF_NewLine 					; new line on actual screen.
.018060	a9 00		lda #$00			lda 	#0 							; reset x position
.018062	8d 00 05	sta $0500			sta 	IFT_XCursor
.018065	ee 01 05	inc $0501			inc 	IFT_YCursor 				; move down.
.018068	ad 01 05	lda $0501			lda 	IFT_YCursor
.01806b	c9 20		cmp #$20			cmp 	#IF_Height 					; reached bottom.
.01806d	d0 03		bne $018072			bne 	_IFT_NL_NotEOS
.01806f	20 7f 80	jsr $01807f			jsr 	IFT_Scroll 					; scroll screen up.
.018072					_IFT_NL_NotEOS:
.018072	68		pla				pla
.018073	60		rts				rts
.018074					IFT_UpperCase:
.018074	c9 61		cmp #$61			cmp 	#"a"
.018076	90 06		bcc $01807e			bcc 	_IFT_UCExit
.018078	c9 7b		cmp #$7b			cmp 	#"z"+1
.01807a	b0 02		bcs $01807e			bcs 	_IFT_UCExit
.01807c	49 20		eor #$20			eor 	#$20
.01807e					_IFT_UCExit:
.01807e	60		rts				rts
.01807f					IFT_Scroll:
.01807f	48		pha				pha 								; save AXY
.018080	da		phx				phx
.018081	5a		phy				phy
.018082	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.018084					_IFT_SLoop:
.018084	20 a4 80	jsr $0180a4			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.018087	e8		inx				inx
.018088	e0 1f		cpx #$1f			cpx 	#IF_Height-1				; do whole screen
.01808a	d0 f8		bne $018084			bne 	_IFT_SLoop
.01808c	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.01808e	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.018091	a2 40		ldx #$40			ldx 	#IF_Width 					; blank line
.018093					_IFT_SBlank:
.018093	a9 20		lda #$20			lda 	#32
.018095	20 d5 81	jsr $0181d5			jsr 	IF_Write
.018098	ca		dex				dex
.018099	d0 f8		bne $018093			bne 	_IFT_SBlank
.01809b	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.01809d	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.0180a0	7a		ply				ply
.0180a1	fa		plx				plx
.0180a2	68		pla				pla
.0180a3	60		rts				rts
.0180a4					_IFT_ScrollLine:
.0180a4	da		phx				phx
.0180a5	da		phx				phx
.0180a6	8a		txa				txa 								; copy line into buffer.
.0180a7	1a		inc a				inc 	a 							; next line down.
.0180a8	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.0180ab	a2 00		ldx #$00			ldx 	#0
.0180ad					_IFTScrollCopy1:
.0180ad	20 cc 81	jsr $0181cc			jsr 	IF_Read
.0180b0	9d 02 05	sta $0502,x			sta 	IFT_Buffer,x
.0180b3	e8		inx				inx
.0180b4	e0 40		cpx #$40			cpx 	#IF_Width
.0180b6	d0 f5		bne $0180ad			bne 	_IFTScrollCopy1
.0180b8	68		pla				pla
.0180b9	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.0180bc	a2 00		ldx #$00			ldx 	#0
.0180be					_IFTScrollCopy2:
.0180be	bd 02 05	lda $0502,x			lda 	IFT_Buffer,x
.0180c1	20 d5 81	jsr $0181d5			jsr 	IF_Write
.0180c4	e8		inx				inx
.0180c5	e0 40		cpx #$40			cpx 	#IF_Width
.0180c7	d0 f5		bne $0180be			bne 	_IFTScrollCopy2
.0180c9	fa		plx				plx
.0180ca	60		rts				rts
.0180cb					IFT_SetYPos:
.0180cb	48		pha				pha
.0180cc	da		phx				phx
.0180cd	aa		tax				tax
.0180ce	20 1b 80	jsr $01801b			jsr 	IFT_HomeCursor
.0180d1	e0 00		cpx #$00			cpx 	#0
.0180d3	f0 09		beq $0180de			beq 	_IFT_MOAExit
.0180d5					_IFT_MOALoop:
.0180d5	20 bc 81	jsr $0181bc			jsr 	IF_NewLine
.0180d8	ee 01 05	inc $0501			inc 	IFT_YCursor
.0180db	ca		dex				dex
.0180dc	d0 f7		bne $0180d5			bne		_IFT_MOALoop
.0180de					_IFT_MOAExit:
.0180de	fa		plx				plx
.0180df	68		pla				pla
.0180e0	60		rts				rts
.0180e1					IFT_GetKeyCursor:
.0180e1	20 e9 80	jsr $0180e9			jsr 	_IFT_FlipCursor 			; reverse current
.0180e4					_IFT_GKCWait:
.0180e4	20 e6 81	jsr $0181e6			jsr 	IF_GetKey 					; get key
.0180e7	f0 fb		beq $0180e4			beq 	_IFT_GKCWait
.0180e9					_IFT_FlipCursor:
.0180e9	48		pha				pha 								; save
.0180ea	20 cc 81	jsr $0181cc			jsr 	IF_Read 					; read
.0180ed	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.0180f0	49 80		eor #$80			eor 	#$80 						; reverse
.0180f2	20 d5 81	jsr $0181d5			jsr 	IF_Write 					; write
.0180f5	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.0180f8	68		pla				pla
.0180f9	60		rts				rts
.0180fa					IFT_ReadLine:
.0180fa	48		pha				pha
.0180fb					_IFT_RLLoop:
.0180fb	20 e1 80	jsr $0180e1			jsr 	IFT_GetKeyCursor 			; get keystroke
.0180fe	c9 0d		cmp #$0d			cmp 	#13							; return
.018100	f0 7d		beq $01817f			beq 	_IFT_RLExit
.018102	c9 20		cmp #$20			cmp 	#32 						; control character
.018104	90 05		bcc $01810b			bcc 	_IFT_Control
.018106	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018109	80 f0		bra $0180fb			bra 	_IFT_RLLoop
.01810b					_IFT_Control:
.01810b	c9 01		cmp #$01			cmp 	#"A"-64
.01810d	f0 26		beq $018135			beq 	_IFT_Left
.01810f	c9 04		cmp #$04			cmp 	#"D"-64
.018111	f0 2e		beq $018141			beq 	_IFT_Right
.018113	c9 17		cmp #$17			cmp 	#"W"-64
.018115	f0 36		beq $01814d			beq 	_IFT_Up
.018117	c9 13		cmp #$13			cmp 	#"S"-64
.018119	f0 3e		beq $018159			beq 	_IFT_Down
.01811b	c9 08		cmp #$08			cmp 	#"H"-64
.01811d	f0 09		beq $018128			beq 	_IFT_Backspace
.01811f	c9 1a		cmp #$1a			cmp 	#"Z"-64
.018121	d0 d8		bne $0180fb			bne 	_IFT_RLLoop
.018123	20 00 80	jsr $018000			jsr 	IFT_ClearScreen				; clear CTL-Z
.018126	80 d3		bra $0180fb			bra 	_IFT_RLLoop
.018128					_IFT_Backspace:
.018128	ad 00 05	lda $0500			lda 	IFT_XCursor 				; check not start of line.
.01812b	f0 ce		beq $0180fb			beq 	_IFT_RLLoop
.01812d	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.018130	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.018132	20 d5 81	jsr $0181d5			jsr 	IF_Write
.018135					_IFT_Left:
.018135	ce 00 05	dec $0500			dec 	IFT_XCursor 				; left CTL-W
.018138	10 29		bpl $018163			bpl 	_IFT_Reposition
.01813a	a9 3f		lda #$3f			lda 	#IF_Width-1
.01813c					_IFT_SetX:
.01813c	8d 00 05	sta $0500			sta 	IFT_XCursor
.01813f	80 22		bra $018163			bra 	_IFT_Reposition
.018141					_IFT_Right:
.018141	ee 00 05	inc $0500			inc 	IFT_XCursor
.018144	ad 00 05	lda $0500			lda 	IFT_XCursor
.018147	49 40		eor #$40			eor 	#IF_Width
.018149	f0 f1		beq $01813c			beq 	_IFT_SetX
.01814b	80 16		bra $018163			bra 	_IFT_Reposition
.01814d					_IFT_Up:
.01814d	ce 01 05	dec $0501			dec 	IFT_YCursor
.018150	10 11		bpl $018163			bpl 	_IFT_Reposition
.018152	a9 1f		lda #$1f			lda 	#IF_Height-1
.018154					_IFT_SetY:
.018154	8d 01 05	sta $0501			sta 	IFT_YCursor
.018157	80 0a		bra $018163			bra 	_IFT_Reposition
.018159					_IFT_Down:
.018159	ee 01 05	inc $0501			inc 	IFT_YCursor
.01815c	ad 01 05	lda $0501			lda 	IFT_YCursor
.01815f	49 20		eor #$20			eor 	#IF_Height
.018161	f0 f1		beq $018154			beq 	_IFT_SetY
.018163					_IFT_Reposition:
.018163	ad 00 05	lda $0500			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.018166	48		pha				pha
.018167	ad 01 05	lda $0501			lda 	IFT_YCursor
.01816a	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.01816d	68		pla				pla
.01816e	aa		tax				tax
.01816f	e0 00		cpx #$00			cpx 	#0
.018171	f0 88		beq $0180fb			beq 	_IFT_RLLoop
.018173					_IFT_MoveRight:
.018173	20 cc 81	jsr $0181cc			jsr 	IF_Read
.018176	ee 00 05	inc $0500			inc 	IFT_XCursor
.018179	ca		dex				dex
.01817a	d0 f7		bne $018173			bne 	_IFT_MoveRight
.01817c	4c fb 80	jmp $0180fb			jmp 	_IFT_RLLoop
.01817f					_IFT_RLExit:
.01817f	ad 01 05	lda $0501			lda 	IFT_YCursor 				; go to start of line.
.018182	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.018185	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.018187					_IFT_RLRead:
.018187	20 cc 81	jsr $0181cc			jsr 	IF_Read
.01818a	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.01818d	e8		inx				inx
.01818e	e0 40		cpx #$40			cpx 	#IF_Width
.018190	d0 f5		bne $018187			bne 	_IFT_RLRead
.018192					_IFT_RL_Trim:
.018192	ca		dex				dex 	 							; previous char
.018193	30 07		bmi $01819c			bmi 	_IFT_Found 					; gone too far
.018195	bd 66 05	lda $0566,x			lda 	IFT_LineBuffer,x			; go back if space
.018198	c9 20		cmp #$20			cmp 	#" "
.01819a	f0 f6		beq $018192			beq 	_IFT_RL_Trim
.01819c					_IFT_Found:
.01819c	e8		inx				inx 								; forward to non-space
.01819d	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.01819f	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.0181a2	68		pla				pla
.0181a3	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.0181a5	a0 05		ldy #$05			ldy 	#IFT_LineBuffer >> 8
.0181a7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_em65816.asm

=64					IF_Width 	= 64 							; characters across
=32					IF_Height 	= 32 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line.
=8					IF_XPos 	= 8 							; current position, horizontal.
=$f0000					IF_Screen = $F0000							; 2k screen RAM here
=$f8010					IF_PKeyboard = $F8010						; Keyboard port.
=$f8000					IF_PBreak = $F8000 							; Break key.
.0181a8					IF_Reset:
.0181a8	60		rts				rts
.0181a9					IF_Home:
.0181a9	48		pha				pha
.0181aa	64 08		stz $08				stz 	IF_XPos 					; zero X position
.0181ac	a9 00		lda #$00			lda 	#IF_Screen & $FF 			; set r/w pos.
.0181ae	85 04		sta $04				sta 	IF_Pos
.0181b0	a9 00		lda #$00			lda 	#(IF_Screen >> 8) & $FF
.0181b2	85 05		sta $05				sta 	IF_Pos+1
.0181b4	a9 0f		lda #$0f			lda 	#IF_Screen >> 16
.0181b6	85 06		sta $06				sta 	IF_Pos+2
.0181b8	64 07		stz $07				stz 	IF_Pos+3
.0181ba	68		pla				pla
.0181bb	60		rts				rts
.0181bc					IF_NewLine:
.0181bc	48		pha				pha
.0181bd	64 08		stz $08				stz 	IF_XPos						; back to start of line
.0181bf	18		clc				clc 								; down one line
.0181c0	a5 04		lda $04				lda 	IF_Pos
.0181c2	69 40		adc #$40			adc 	#64
.0181c4	85 04		sta $04				sta 	IF_Pos
.0181c6	90 02		bcc $0181ca			bcc 	_IF_NoCarry 				; carry through.
.0181c8	e6 05		inc $05				inc 	IF_Pos+1
.0181ca					_IF_NoCarry:
.0181ca	68		pla				pla
.0181cb	60		rts				rts
.0181cc					IF_Read:
.0181cc	5a		phy				phy 								; save current Y
.0181cd	a4 08		ldy $08				ldy 	IF_XPos 					; read character at current position
.0181cf	b7 04		lda [$04],y			lda 	[IF_Pos],y
.0181d1	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181d3	7a		ply				ply									; restore Y
.0181d4	60		rts				rts
.0181d5					IF_Write:
.0181d5	5a		phy				phy 								; save current Y
.0181d6	a4 08		ldy $08				ldy 	IF_XPos 					; write character at current position
.0181d8	97 04		sta [$04],y			sta 	[IF_Pos],y
.0181da	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181dc	7a		ply				ply									; restore Y
.0181dd	60		rts				rts
.0181de					IF_LeftOne:
.0181de	c6 08		dec $08				dec 	IF_XPos
.0181e0	60		rts				rts
.0181e1					IF_CheckBreak:
.0181e1	af 00 80 0f	lda $0f8000			lda 	IF_PBreak					; non-zero if Ctrl+C pressed.
.0181e5	60		rts				rts
.0181e6					IF_GetKey:
.0181e6	af 10 80 0f	lda $0f8010			lda 	IF_PKeyboard				; read keyboard
.0181ea	f0 08		beq $0181f4			beq		_IFGK_NoKey 				; skip if zero,no key pressed
.0181ec	48		pha				pha 								; key pressed, clear queue.
.0181ed	a9 00		lda #$00			lda 	#0
.0181ef	8f 10 80 0f	sta $0f8010			sta 	IF_PKeyboard
.0181f3	68		pla				pla
.0181f4					_IFGK_NoKey:
.0181f4	09 00		ora #$00			ora 	#0							; set Z flag appropriately.
.0181f6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.0181f7					TIM_Error:
.0181f7	20 29 80	jsr $018029			jsr 	IFT_UpLine 					; go up one line.
.0181fa	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.0181fc	80 02		bra $018200			bra 	TIM_ShowPrompt
.0181fe					TIM_NewCommand:
.0181fe	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.018200					TIM_ShowPrompt:
.018200	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.018203	20 fa 80	jsr $0180fa			jsr 	IFT_ReadLine	 			; get character, go to next line
.018206	20 5c 80	jsr $01805c			jsr 	IFT_NewLine					; go to next line.
.018209	86 10		stx $10				stx 	zTemp1 						; save line read address
.01820b	84 11		sty $11				sty 	zTemp1+1
.01820d	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.01820f	b1 10		lda ($10),y			lda 	(zTemp1),y
.018211	c9 3f		cmp #$3f			cmp 	#"?"
.018213	f0 04		beq $018219			beq 	TIM_SkipFirst
.018215	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.018217	d0 01		bne $01821a			bne 	TIM_NotDot
.018219					TIM_SkipFirst:
.018219	c8		iny				iny
.01821a					TIM_NotDot:
.01821a	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.01821c	c9 52		cmp #$52			cmp 	#"R"						; show registers
.01821e	f0 6b		beq $01828b			beq 	TIM_ShowRegisters
.018220	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.018222	f0 12		beq $018236			beq 	TIM_ShowMemory
.018224	c9 47		cmp #$47			cmp 	#"G"						; execute
.018226	f0 49		beq $018271			beq 	TIM_Execute
.018228	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.01822a	f0 07		beq $018233			beq 	TIM_GoLoadMemory
.01822c	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.01822e	d0 c7		bne $0181f7			bne 	TIM_Error
.018230	4c af 83	jmp $0183af			jmp 	TIM_UpdateRegisters
.018233					TIM_GoLoadMemory:
.018233	4c df 83	jmp $0183df			jmp 	TIM_LoadMemory
.018236					TIM_ShowMemory:
.018236	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.018239	b0 bc		bcs $0181f7			bcs 	TIM_Error
.01823b	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.01823d	85 12		sta $12				sta 	zTemp2
.01823f	a5 15		lda $15				lda 	zTemp3+1
.018241	85 13		sta $13				sta 	zTemp2+1
.018243	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.018246	90 08		bcc $018250			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.018248	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.01824a	85 14		sta $14				sta 	zTemp3
.01824c	a5 13		lda $13				lda 	zTemp2+1
.01824e	85 15		sta $15				sta 	zTemp3+1
.018250					_TIMSM_Start:
.018250	20 03 83	jsr $018303			jsr 	TIM_WriteLine 				; write one line of hex out
.018253	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.018255	18		clc				clc
.018256	69 10		adc #$10			adc 	#16
.018258	85 12		sta $12				sta 	zTemp2
.01825a	90 02		bcc $01825e			bcc 	_TIMSM_NoCarry
.01825c	e6 13		inc $13				inc 	zTemp2+1
.01825e					_TIMSM_NoCarry:
.01825e	20 e1 81	jsr $0181e1			jsr 	IF_CheckBreak 				; check CTL+C
.018261	d0 0b		bne $01826e			bne 	_TIMSM_Ends 				; if pressed break out.
.018263	38		sec				sec 								; check past the end address in zTemp3
.018264	a5 14		lda $14				lda 	zTemp3
.018266	e5 12		sbc $12				sbc 	zTemp2
.018268	a5 15		lda $15				lda 	zTemp3+1
.01826a	e5 13		sbc $13				sbc 	zTemp2+1
.01826c	10 e2		bpl $018250			bpl 	_TIMSM_Start
.01826e					_TIMSM_Ends:
.01826e	4c fe 81	jmp $0181fe			jmp 	TIM_NewCommand
.018271					TIM_Execute:
.018271	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; get the execute address
.018274	b0 81		bcs $0181f7			bcs 	TIM_Error 					; not legitimate
.018276	ae c3 03	ldx $03c3			ldx 	TIM_SP 						; set up SP
.018279	9a		txs				txs
.01827a	ad be 03	lda $03be			lda 	TIM_SR 						; Status for PLP
.01827d	48		pha				pha
.01827e	ad bf 03	lda $03bf			lda 	TIM_A 						; restore AXYZ
.018281	ae c0 03	ldx $03c0			ldx 	TIM_X
.018284	ac c1 03	ldy $03c1			ldy 	TIM_Y
.018287	28		plp				plp 								; and PS Byte.
.018288	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.01828b					TIM_Start:
.01828b					TIM_ShowRegisters:
.01828b	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.01828e	8d bd 03	sta $03bd			sta 	TIM_IRQ+1
.018291	ad ff ff	lda $ffff			lda 	$FFFF
.018294	8d bc 03	sta $03bc			sta 	TIM_IRQ
.018297	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.018299					_TIMSR_Text:
.018299	bf ca 82 01	lda $0182ca,x			lda 	_TIMSR_Label,x
.01829d	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182a0	e8		inx				inx
.0182a1	e0 20		cpx #$20			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.0182a3	d0 f4		bne $018299			bne 	_TIMSR_Text
.0182a5	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.0182a7					_TIMSR_Skip:
.0182a7	e8		inx				inx
.0182a8					_TIMSR_LoopSpace:
.0182a8	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.0182aa	b0 04		bcs $0182b0			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.0182ac	8a		txa				txa
.0182ad	4a		lsr a				lsr 	a
.0182ae	b0 05		bcs $0182b5			bcs 	_TIMSR_NoSpace
.0182b0					_TIMSR_Space:
.0182b0	a9 20		lda #$20			lda 	#" "
.0182b2	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182b5					_TIMSR_NoSpace:
.0182b5	bd ba 03	lda $03ba,x			lda 	TIM_PC,x 					; output hex value.
.0182b8	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.0182bb	e8		inx				inx
.0182bc	e0 08		cpx #$08			cpx 	#TIM_Z-TIM_PC
.0182be	f0 e7		beq $0182a7			beq 	_TIMSR_Skip
.0182c0	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.0182c2	d0 e4		bne $0182a8			bne 	_TimSR_LoopSpace
.0182c4	20 5c 80	jsr $01805c			jsr 	IFT_NewLine 				; new line
.0182c7	4c fe 81	jmp $0181fe			jmp	 	TIM_NewCommand 				; new command.
.0182ca					_TIMSR_Label:
>0182ca	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>0182d2	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>0182e2	52
>0182e3	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.0182ea					_TIMSR_LabelEnd:
.0182ea					TIM_WriteHex:
.0182ea	48		pha				pha 								; save A
.0182eb	4a		lsr a				lsr 	a 							; shift MSB->LSB
.0182ec	4a		lsr a				lsr 	a
.0182ed	4a		lsr a				lsr 	a
.0182ee	4a		lsr a				lsr 	a
.0182ef	20 f3 82	jsr $0182f3			jsr 	_TIMWH_Nibble 				; print MSB
.0182f2	68		pla				pla 								; restore and print LSB
.0182f3					_TIMWH_Nibble:
.0182f3	48		pha				pha
.0182f4	29 0f		and #$0f			and 	#15 						; mask out
.0182f6	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.0182f8	90 02		bcc $0182fc			bcc 	_TIMWHNoLetter
.0182fa	69 06		adc #$06			adc 	#6
.0182fc					_TIMWHNoLetter:
.0182fc	69 30		adc #$30			adc 	#48
.0182fe	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter 			; print it out.
.018301	68		pla				pla
.018302	60		rts				rts
.018303					TIM_WriteLine:
.018303	a9 2e		lda #$2e			lda 	#"." 						; prompt
.018305	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018308	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.01830a	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01830d	a5 13		lda $13				lda 	zTemp2+1 					; write address
.01830f	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.018312	a5 12		lda $12				lda 	zTemp2
.018314	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.018317	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.018319					_TIMWL_Loop:
.018319	a9 20		lda #$20			lda 	#" "
.01831b	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01831e	b1 12		lda ($12),y			lda 	(zTemp2),y
.018320	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.018323	c8		iny				iny
.018324	c0 10		cpy #$10			cpy 	#16
.018326	d0 f1		bne $018319			bne 	_TIMWL_Loop
.018328	4c 5c 80	jmp $01805c			jmp 	IFT_NewLine 				; new line and exit
.01832b					TIM_GetHex:
.01832b	c8		iny				iny
.01832c	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.01832e	c9 20		cmp #$20			cmp 	#32
.018330	f0 f9		beq $01832b			beq 	TIM_GetHex
.018332	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.018334	f0 f5		beq $01832b			beq 	TIM_GetHex
.018336	20 5f 83	jsr $01835f			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.018339	b0 23		bcs $01835e			bcs 	_TIMGH_Exit					; if first bad then exit now.
.01833b	a9 00		lda #$00			lda 	#0 							; zero result
.01833d	85 14		sta $14				sta 	zTemp3
.01833f	85 15		sta $15				sta 	zTemp3+1
.018341					_TIM_GHLoop:
.018341	20 5f 83	jsr $01835f			jsr 	TIM_GetHexCharacter 		; get next character
.018344	b0 17		bcs $01835d			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.018346	c8		iny				iny 								; skip over it.
.018347	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.018349	26 15		rol $15				rol 	zTemp3+1
.01834b	06 14		asl $14				asl 	zTemp3 						; now x 2
.01834d	26 15		rol $15				rol 	zTemp3+1
.01834f	06 14		asl $14				asl 	zTemp3						; now x 4
.018351	26 15		rol $15				rol 	zTemp3+1
.018353	06 14		asl $14				asl 	zTemp3 						; now x 8
.018355	26 15		rol $15				rol 	zTemp3+1
.018357	05 14		ora $14				ora 	zTemp3 						; OR result in
.018359	85 14		sta $14				sta 	zTemp3
.01835b	80 e4		bra $018341			bra 	_TIM_GHLoop 				; loop round again.
.01835d					_TIMGH_Okay:
.01835d	18		clc				clc
.01835e					_TIMGH_Exit:
.01835e	60		rts				rts
.01835f					TIM_GetHexCharacter:
.01835f	b1 10		lda ($10),y			lda 	(zTemp1),y
.018361	38		sec				sec
.018362	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.018364	90 0e		bcc $018374			bcc 	_TIM_GHCFail
.018366	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.018368	90 0b		bcc $018375			bcc 	_TIM_GHCExit
.01836a	c9 11		cmp #$11			cmp 	#65-48						; < A
.01836c	90 06		bcc $018374			bcc		_TIM_GHCFail
.01836e	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.018370	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.018372	90 01		bcc $018375			bcc		_TIM_GHCExit
.018374					_TIM_GHCFail:
.018374	38		sec				sec
.018375					_TIM_GHCExit:
.018375	60		rts				rts
.018376					TIM_BreakVector:
.018376	da		phx				phx									; save X/A on stack
.018377	48		pha				pha
.018378	ba		tsx				tsx 								; X points to S
.018379	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.01837c	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.01837e	d0 03		bne $018383			bne 	_TIMBreak					; if set, it's BRK
.018380	68		pla				pla 								; abandon routine.
.018381	fa		plx				plx
.018382	40		rti				rti
.018383					_TIMBreak:
.018383	68		pla				pla 								; save A X Y and maybe Z
.018384	8d bf 03	sta $03bf			sta 	TIM_A
.018387	fa		plx				plx
.018388	8e c0 03	stx $03c0			stx 	TIM_X
.01838b	8c c1 03	sty $03c1			sty 	TIM_Y
.01838e	68		pla				pla 								; get Status Register
.01838f	8d be 03	sta $03be			sta 	TIM_SR
.018392	68		pla				pla
.018393	8d bb 03	sta $03bb			sta 	TIM_PC+1 					; save calling address
.018396	68		pla				pla
.018397	8d ba 03	sta $03ba			sta 	TIM_PC 						; high byte
.01839a	ad bb 03	lda $03bb			lda 	TIM_PC+1 					; dec PC to point right.
.01839d	d0 03		bne $0183a2			bne 	_TIMDecrement 				; brk bumps it.
.01839f	ce ba 03	dec $03ba			dec 	TIM_PC
.0183a2					_TIMDecrement:
.0183a2	ce bb 03	dec $03bb			dec 	TIM_PC+1
.0183a5	ba		tsx				tsx 								; and copy SP
.0183a6	8e c3 03	stx $03c3			stx 	TIM_SP
.0183a9	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.0183ab	9a		txs				txs
.0183ac	4c 8b 82	jmp $01828b			jmp 	TIM_Start 					; and start up TIM monitor.
.0183af					TIM_UpdateRegisters:
.0183af	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; PC
.0183b2	b0 28		bcs $0183dc			bcs 	_TIMURFail
.0183b4	a5 14		lda $14				lda 	zTemp3
.0183b6	8d bb 03	sta $03bb			sta 	Tim_PC+1
.0183b9	a5 15		lda $15				lda 	zTemp3+1
.0183bb	8d ba 03	sta $03ba			sta 	Tim_PC
.0183be	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; ignore IRQ
.0183c1	b0 19		bcs $0183dc			bcs 	_TIMURFail
.0183c3	a2 00		ldx #$00			ldx 	#0
.0183c5					_TIM_URLoop:
.0183c5	e0 04		cpx #$04			cpx 	#Tim_Z-Tim_SR
.0183c7	d0 01		bne $0183ca			bne 	_TIM_1
.0183c9	e8		inx				inx
.0183ca					_TIM_1:
.0183ca	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; registers
.0183cd	b0 0d		bcs $0183dc			bcs 	_TIMURFail
.0183cf	a5 14		lda $14				lda 	zTemp3
.0183d1	9d be 03	sta $03be,x			sta 	Tim_SR,x
.0183d4	e8		inx				inx
.0183d5	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.0183d7	d0 ec		bne $0183c5			bne 	_TIM_URLoop
.0183d9	4c fe 81	jmp $0181fe			jmp 	TIM_NewCommand
.0183dc					_TIMURFail:
.0183dc	4c f7 81	jmp $0181f7			jmp 	TIM_Error
.0183df					TIM_LoadMemory:
.0183df	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; target address => zTemp2
.0183e2	a5 14		lda $14				lda 	zTemp3
.0183e4	85 12		sta $12				sta 	zTemp2
.0183e6	a5 15		lda $15				lda 	zTemp3+1
.0183e8	85 13		sta $13				sta 	zTemp2+1
.0183ea					_TIM_LMLoop:
.0183ea	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; next byte ?
.0183ed	b0 0e		bcs $0183fd			bcs 	_TIMLMDone 					; no more
.0183ef	a2 00		ldx #$00			ldx 	#0							; write out.
.0183f1	a5 14		lda $14				lda 	zTemp3
.0183f3	81 12		sta ($12,x)			sta 	(zTemp2,x)
.0183f5	e6 12		inc $12				inc 	zTemp2 						; bump address
.0183f7	d0 f1		bne $0183ea			bne 	_TIM_LMLoop
.0183f9	e6 13		inc $13				inc 	zTemp2+1
.0183fb	80 ed		bra $0183ea			bra 	_TIM_LMLoop
.0183fd					_TIMLMDone:
.0183fd	4c fe 81	jmp $0181fe			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/skip.asm

.018400					StructureSearchSingle:
.018400	a2 00		ldx #$00			ldx 	#0
.018402					StructureSearchDouble:
.018402	85 10		sta $10				sta 	zTemp1 						; save the target on zTemp1,zTemp1+1
.018404	86 11		stx $11				stx 	zTemp1+1
.018406	a9 00		lda #$00			lda 	#0 							; set the structure depth to zero (zTemp2)
.018408	85 12		sta $12				sta 	zTemp2
.01840a	80 18		bra $018424			bra 	_SSWLoop 					; jump in, start scanning from here.
.01840c					_SSWNextLine:
.01840c	a0 00		ldy #$00			ldy 	#0 							; point to offset
.01840e	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.018410	18		clc				clc
.018411	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018413	85 16		sta $16				sta 	zCodePtr
.018415	90 02		bcc $018419			bcc 	_SNLNoCarry
.018417	e6 17		inc $17				inc 	zCodePtr+1
.018419					_SNLNoCarry:
.018419	a0 00		ldy #$00			ldy 	#0
.01841b	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01841d	c9 00		cmp #$00			cmp 	#0					 		; if zero, fail.
.01841f	f0 54		beq $018475			beq 	_SSWFail
.018421	c8		iny				iny
.018422	c8		iny				iny
.018423					_SSWNextSimple:
.018423	c8		iny				iny
.018424					_SSWLoop:
.018424	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018426	c9 00		cmp #$00			cmp 	#0 							; end of line ?
.018428	f0 e2		beq $01840c			beq 	_SSWNextLine 				; if so, then next line
.01842a	10 f7		bpl $018423			bpl 	_SSWNextSimple 				; needs to be a token, just skip char/number.
.01842c	a6 12		ldx $12				ldx 	zTemp2 						; check structure count
.01842e	d0 08		bne $018438			bne 	_SSWCheckUpDown 			; if it's non zero, then a match doesn't work.
.018430	c5 10		cmp $10				cmp 	zTemp1 						; found the right keyword, either choice.
.018432	f0 2d		beq $018461			beq 	_SSWFound 					; so exit.
.018434	c5 11		cmp $11				cmp 	zTemp1+1
.018436	f0 29		beq $018461			beq 	_SSWFound
.018438					_SSWCheckUpDown:
.018438	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus 			; if < keyword +
.01843a	90 10		bcc $01844c			bcc 	_SSWNext
.01843c	c9 93		cmp #$93			cmp 	#firstKeywordMinus 			; if < keyword - then as keyword +
.01843e	90 08		bcc $018448			bcc 	_SSWPlus
.018440	c9 98		cmp #$98			cmp 	#firstUnaryFunction			; if < first unary down as keyword -
.018442	b0 08		bcs $01844c			bcs 	_SSWNext
.018444	c6 12		dec $12				dec 	zTemp2 						; reduce structure count.
.018446	c6 12		dec $12				dec 	zTemp2
.018448					_SSWPlus:
.018448	e6 12		inc $12				inc 	zTemp2
.01844a	30 16		bmi $018462			bmi 	_SSWUnder					; error if driven -ve
.01844c					_SSWNext:
.01844c	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.01844e	c8		iny				iny 								; skip
.01844f	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018451	90 0c		bcc $01845f			bcc 	_SEDone 					; so just skip over it.
.018453	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018455	90 07		bcc $01845e			bcc 	_SEDouble
.018457	98		tya				tya 								; this is Y + 1
.018458	18		clc				clc
.018459	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.01845b	a8		tay				tay 								; back in Y.
.01845c	88		dey				dey 								; fix up, one for the +1, one for the iny
.01845d	88		dey				dey
.01845e					_SEDouble:
.01845e	c8		iny				iny
.01845f					_SEDone:
.01845f	80 c3		bra $018424			bra 	_SSWLoop
.018461					_SSWFound:
.018461	60		rts				rts
.018462					_SSWUnder:
.018462	20 57 85	jsr $018557			jsr ERR_Handler
>018465	53 74 72 75 63 74 75 72			.text "Structure order",0
>01846d	65 20 6f 72 64 65 72 00
.018475					_SSWFail:
.018475	20 57 85	jsr $018557			jsr ERR_Handler
>018478	43 61 6e 27 74 20 66 69			.text "Can't find structure",0
>018480	6e 64 20 73 74 72 75 63 74 75 72 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stack.asm

.01848d					StackReset:
.01848d	48		pha				pha
.01848e	5a		phy				phy
.01848f	a9 00		lda #$00			lda 	#(BasicStack & $FF) 		; reset pointer
.018491	85 26		sta $26				sta 	zBasicSP
.018493	a9 04		lda #$04			lda 	#(BasicStack >> 8)
.018495	85 27		sta $27				sta 	zBasicSP+1
.018497	a0 00		ldy #$00			ldy 	#0 							; reset stack top to $00 which cannot
.018499	98		tya				tya 								; be a legal token.
.01849a	91 26		sta ($26),y			sta 	(zBasicSP),y
.01849c	7a		ply				ply
.01849d	68		pla				pla
.01849e	60		rts				rts
.01849f					StackPushFrame:
.01849f	48		pha				pha
.0184a0	5a		phy				phy
.0184a1	1a		inc a				inc 	a 							; one extra byte in frame, for the marker.
.0184a2	48		pha				pha 								; save it.
.0184a3	29 0f		and #$0f			and 	#$0F 						; lower 4 bits
.0184a5	18		clc				clc 								; add to Basic Stack
.0184a6	65 26		adc $26				adc 	zBasicSP
.0184a8	85 26		sta $26				sta 	zBasicSP
.0184aa	90 02		bcc $0184ae			bcc 	_SPFNoBump
.0184ac	e6 27		inc $27				inc 	zBasicSP+1
.0184ae					_SPFNoBump:
.0184ae	a0 00		ldy #$00			ldy 	#0
.0184b0	68		pla				pla
.0184b1	91 26		sta ($26),y			sta 	(zBasicSP),y
.0184b3	7a		ply				ply
.0184b4	68		pla				pla
.0184b5	60		rts				rts
.0184b6					StackPopFrame:
.0184b6	48		pha				pha
.0184b7	5a		phy				phy
.0184b8	a0 00		ldy #$00			ldy 	#0 							; compare with top of stack using EOR
.0184ba	51 26		eor ($26),y			eor 	(zBasicSP),y
.0184bc	29 f0		and #$f0			and 	#$F0 						; top 4 bits zero, match
.0184be	d0 12		bne $0184d2			bne 	_SPFError 					; mixed structures
.0184c0	b1 26		lda ($26),y			lda 	(zBasicSP),y 				; get size from byte
.0184c2	29 0f		and #$0f			and 	#$0F
.0184c4	49 ff		eor #$ff			eor 	#$FF						; 2's complement
.0184c6	38		sec				sec
.0184c7	65 26		adc $26				adc 	zBasicSP
.0184c9	85 26		sta $26				sta 	zBasicSP
.0184cb	b0 02		bcs $0184cf			bcs 	_SPFNoBump
.0184cd	c6 27		dec $27				dec 	zBasicSP+1
.0184cf					_SPFNoBump:
.0184cf	7a		ply				ply
.0184d0	68		pla				pla
.0184d1	60		rts				rts
.0184d2					_SPFError:
.0184d2	20 57 85	jsr $018557			jsr ERR_Handler
>0184d5	4d 69 78 65 64 20 53 74			.text "Mixed Structures",0
>0184dd	72 75 63 74 75 72 65 73 00
.0184e6					StackSavePosition:
.0184e6	98		tya				tya
.0184e7	5a		phy				phy
.0184e8	a0 05		ldy #$05			ldy 	#5
.0184ea	91 26		sta ($26),y			sta 	(zBasicSP),y
.0184ec	a0 01		ldy #$01			ldy 	#1
.0184ee	a5 16		lda $16				lda 	zCodePtr+0 					; 4 bytes, could reduce this for 65816/6502
.0184f0	91 26		sta ($26),y			sta 	(zBasicSP),y
.0184f2	c8		iny				iny
.0184f3	a5 17		lda $17				lda 	zCodePtr+1
.0184f5	91 26		sta ($26),y			sta 	(zBasicSP),y
.0184f7	c8		iny				iny
.0184f8	a5 18		lda $18				lda 	zCodePtr+2
.0184fa	91 26		sta ($26),y			sta 	(zBasicSP),y
.0184fc	c8		iny				iny
.0184fd	a5 19		lda $19				lda 	zCodePtr+3
.0184ff	91 26		sta ($26),y			sta 	(zBasicSP),y
.018501	7a		ply				ply
.018502	60		rts				rts
.018503					StackRestorePosition:
.018503	5a		phy				phy
.018504	a0 01		ldy #$01			ldy 	#1 							; copy 4 bytes that are the pointer
.018506	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018508	85 16		sta $16				sta 	zCodePtr+0
.01850a	c8		iny				iny
.01850b	b1 26		lda ($26),y			lda 	(zBasicSP),y
.01850d	85 17		sta $17				sta 	zCodePtr+1
.01850f	c8		iny				iny
.018510	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018512	85 18		sta $18				sta 	zCodePtr+2
.018514	c8		iny				iny
.018515	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018517	85 19		sta $19				sta 	zCodePtr+3
.018519	c8		iny				iny
.01851a	b1 26		lda ($26),y			lda 	(zBasicSP),y 				; offset
.01851c	7a		ply				ply 								; restore Y
.01851d	a8		tay				tay
.01851e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/vectors.asm

.01851f					CharPrint:
.01851f	4c 35 80	jmp $018035			jmp 	IFT_PrintCharacter
.018522					CharGet:
.018522	4c e6 81	jmp $0181e6			jmp 	IF_GetKey
.018525					CheckBreak:
.018525	4c e1 81	jmp $0181e1			jmp 	IF_CheckBreak

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/errors.asm

.018528					SyntaxError:
.018528	20 57 85	jsr $018557			jsr 	ERR_Handler
>01852b	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>018533	72 72 6f 72 00
.018538					TypeError:
.018538	20 57 85	jsr $018557			jsr 	ERR_Handler
>01853b	57 72 6f 6e 67 20 74 79				.text 	"Wrong type",0
>018543	70 65 00
.018546					BadParamError:
.018546	20 57 85	jsr $018557			jsr 	ERR_Handler
>018549	42 61 64 20 50 61 72 61				.text 	"Bad Parameter",0
>018551	6d 65 74 65 72 00
.018557					ERR_Handler:
.018557	a0 00		ldy #$00			ldy 	#0
.018559	c8		iny				iny
.01855a	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01855c	85 80		sta $80				sta 	XS_Mantissa
.01855e	c8		iny				iny
.01855f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018561	85 81		sta $81				sta 	XS_Mantissa+1
.018563	fa		plx				plx 								; address in XY
.018564	7a		ply				ply
.018565	e8		inx				inx 								; bump, because of RTS/JSR address -1
.018566	d0 01		bne $018569			bne 	_EHNoSkip
.018568	c8		iny				iny
.018569					_EHNoSkip:
.018569	20 88 85	jsr $018588			jsr 	PrintROMMessage 			; print message from ROM.
.01856c	a5 80		lda $80				lda 	XS_Mantissa					; line number = 0
.01856e	05 81		ora $81				ora 	XS_Mantissa+1
.018570	f0 0c		beq $01857e			beq 	_EHNoLine
.018572	a2 83		ldx #$83			ldx 	#_EHAt & $FF 				; print " at "
.018574	a0 85		ldy #$85			ldy 	#(_EHAt >> 8) & $FF
.018576	20 88 85	jsr $018588			jsr 	PrintROMMessage
.018579	a2 00		ldx #$00			ldx 	#0 							; Print line number
.01857b	20 9d 85	jsr $01859d			jsr 	Print16BitInteger
.01857e					_EHNoLine:
.01857e	80 fe		bra $01857e			bra 	_EHNoLine
.018580	4c 10 88	jmp $018810			jmp 	WarmStart
>018583	20 61 74 20 00			_EHAt:	.text 	" at ",0
.018588					PrintROMMessage:
.018588	86 1a		stx $1a				stx 	zLTemp1 					; save addres
.01858a	84 1b		sty $1b				sty 	zLTemp1+1
.01858c	4b		phk				phk
.01858d	68		pla				pla
.01858e	85 1c		sta $1c				sta 	ZLTemp1+2
.018590	a0 00		ldy #$00			ldy 	#0
.018592					_PRMLoop:
.018592	b7 1a		lda [$1a],y			lda 	[zLTemp1],y
.018594	f0 06		beq $01859c			beq		_PRMExit
.018596	c8		iny				iny
.018597	20 1f 85	jsr $01851f			jsr 	CharPrint
.01859a	80 f6		bra $018592			bra 	_PRMLoop
.01859c					_PRMExit:
.01859c	60		rts				rts
.01859d					Print16BitInteger:
.01859d	a9 00		lda #$00			lda 	#0 							; make 32 bit
.01859f	85 82		sta $82				sta 	XS_Mantissa+2
.0185a1	85 83		sta $83				sta 	XS_Mantissa+3
.0185a3					Print32BitInteger:
.0185a3	a9 00		lda #$00			lda 	#0
.0185a5	8d 14 03	sta $0314			sta 	NumBufX 					; reset the conversion pointer
.0185a8	aa		tax				tax 								; convert bottom level.
.0185a9	20 06 9c	jsr $019c06			jsr 	INTToString 				; make string
.0185ac	a2 00		ldx #$00			ldx 	#0 							; print buffer
.0185ae	bd 15 03	lda $0315,x	_P1Loop:lda 	Num_Buffer,x
.0185b1	f0 06		beq $0185b9			beq 	_P1Exit
.0185b3	20 1f 85	jsr $01851f			jsr 	CharPrint
.0185b6	e8		inx				inx
.0185b7	80 f5		bra $0185ae			bra 	_P1Loop
.0185b9	8a		txa		_P1Exit:txa 								; return chars printed.
.0185ba	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm


;******  Processing file: modules/basic/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b6					lastUnaryFunction = $b6
.0185bb					VectorTable:
>0185bb	7a 90					.word BinaryOp_And         & $FFFF ; $80 and
>0185bd	96 90					.word BinaryOp_Or          & $FFFF ; $81 or
>0185bf	b2 90					.word BinaryOp_Xor         & $FFFF ; $82 xor
>0185c1	b2 90					.word BinaryOp_Eor         & $FFFF ; $83 eor
>0185c3	e9 90					.word Binary_Equal         & $FFFF ; $84 =
>0185c5	03 91					.word Binary_NotEqual      & $FFFF ; $85 <>
>0185c7	0c 91					.word Binary_Less          & $FFFF ; $86 <
>0185c9	15 91					.word Binary_LessEqual     & $FFFF ; $87 <=
>0185cb	27 91					.word Binary_Greater       & $FFFF ; $88 >
>0185cd	1e 91					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>0185cf	ac 91					.word BinaryOp_Add         & $FFFF ; $8a +
>0185d1	c8 91					.word BinaryOp_Subtract    & $FFFF ; $8b -
>0185d3	d9 91					.word BinaryOp_Multiply    & $FFFF ; $8c *
>0185d5	ea 91					.word BinaryOp_Divide      & $FFFF ; $8d /
>0185d7	79 86					.word NotImplemented       & $FFFF ; $8e ^
>0185d9	dd 8a					.word Command_IF           & $FFFF ; $8f if
>0185db	76 8e					.word Command_WHILE        & $FFFF ; $90 while
>0185dd	9e 8e					.word Command_REPEAT       & $FFFF ; $91 repeat
>0185df	72 89					.word Command_FOR          & $FFFF ; $92 for
>0185e1	79 86					.word NotImplemented       & $FFFF ; $93 then
>0185e3	3a 8b					.word Command_ENDIF        & $FFFF ; $94 endif
>0185e5	93 8e					.word Command_WEND         & $FFFF ; $95 wend
>0185e7	a7 8e					.word Command_UNTIL        & $FFFF ; $96 until
>0185e9	ef 89					.word Command_NEXT         & $FFFF ; $97 next
>0185eb	79 86					.word NotImplemented       & $FFFF ; $98 not
>0185ed	79 86					.word NotImplemented       & $FFFF ; $99 fn(
>0185ef	ef 92					.word Unary_Abs            & $FFFF ; $9a abs(
>0185f1	30 94					.word Unary_Asc            & $FFFF ; $9b asc(
>0185f3	32 a3					.word Unary_Int            & $FFFF ; $9c int(
>0185f5	09 93					.word Unary_Peek           & $FFFF ; $9d peek(
>0185f7	b3 a2					.word Unary_Rnd            & $FFFF ; $9e rnd(
>0185f9	70 93					.word Unary_Usr            & $FFFF ; $9f usr(
>0185fb	6f 94					.word Unary_Left           & $FFFF ; $a0 left$(
>0185fd	84 94					.word Unary_Right          & $FFFF ; $a1 right$(
>0185ff	56 94					.word Unary_Mid            & $FFFF ; $a2 mid$(
>018601	cd 95					.word Unary_Spc            & $FFFF ; $a3 spc(
>018603	fe 93					.word Unary_Str            & $FFFF ; $a4 str$(
>018605	92 93					.word Unary_Val            & $FFFF ; $a5 val(
>018607	47 94					.word Unary_Len            & $FFFF ; $a6 len(
>018609	fc 94					.word Unary_Hex            & $FFFF ; $a7 hex$(
>01860b	79 86					.word NotImplemented       & $FFFF ; $a8 sin(
>01860d	79 86					.word NotImplemented       & $FFFF ; $a9 cos(
>01860f	79 86					.word NotImplemented       & $FFFF ; $aa tan(
>018611	79 86					.word NotImplemented       & $FFFF ; $ab atn(
>018613	79 86					.word NotImplemented       & $FFFF ; $ac exp(
>018615	79 86					.word NotImplemented       & $FFFF ; $ad log(
>018617	79 86					.word NotImplemented       & $FFFF ; $ae sqr(
>018619	52 95					.word Unary_Dec            & $FFFF ; $af dec(
>01861b	0d 93					.word Unary_Deek           & $FFFF ; $b0 deek(
>01861d	11 93					.word Unary_Leek           & $FFFF ; $b1 leek(
>01861f	3d 93					.word Unary_Mod            & $FFFF ; $b2 mod(
>018621	a9 92					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>018623	af 95					.word Unary_Chr            & $FFFF ; $b4 chr$(
>018625	79 86					.word NotImplemented       & $FFFF ; $b5 pos(
>018627	79 86					.word NotImplemented       & $FFFF ; $b6 tab(
>018629	79 86					.word NotImplemented       & $FFFF ; $b7 $
>01862b	79 86					.word NotImplemented       & $FFFF ; $b8 $(
>01862d	79 86					.word NotImplemented       & $FFFF ; $b9 #
>01862f	79 86					.word NotImplemented       & $FFFF ; $ba #(
>018631	79 86					.word NotImplemented       & $FFFF ; $bb %
>018633	79 86					.word NotImplemented       & $FFFF ; $bc %(
>018635	79 86					.word NotImplemented       & $FFFF ; $bd (
>018637	79 86					.word NotImplemented       & $FFFF ; $be )
>018639	79 86					.word NotImplemented       & $FFFF ; $bf ,
>01863b	71 89					.word Command_COLON        & $FFFF ; $c0 :
>01863d	79 86					.word NotImplemented       & $FFFF ; $c1 ;
>01863f	79 86					.word NotImplemented       & $FFFF ; $c2 def
>018641	5a 8e					.word Command_CLR          & $FFFF ; $c3 clr
>018643	6e 8e					.word Command_STOP         & $FFFF ; $c4 stop
>018645	79 86					.word NotImplemented       & $FFFF ; $c5 data
>018647	79 86					.word NotImplemented       & $FFFF ; $c6 read
>018649	1d 88					.word Command_DIM          & $FFFF ; $c7 dim
>01864b	79 86					.word NotImplemented       & $FFFF ; $c8 to
>01864d	79 86					.word NotImplemented       & $FFFF ; $c9 step
>01864f	d6 8d					.word Command_GOSUB        & $FFFF ; $ca gosub
>018651	e4 8d					.word Command_RETURN       & $FFFF ; $cb return
>018653	d0 8d					.word Command_GOTO         & $FFFF ; $cc goto
>018655	d9 8a					.word Command_END          & $FFFF ; $cd end
>018657	79 86					.word NotImplemented       & $FFFF ; $ce input
>018659	9e 8a					.word Command_LET          & $FFFF ; $cf let
>01865b	40 8b					.word Command_LIST         & $FFFF ; $d0 list
>01865d	79 8d					.word Command_NEW          & $FFFF ; $d1 new
>01865f	95 8d					.word Command_OLD          & $FFFF ; $d2 old
>018661	79 86					.word NotImplemented       & $FFFF ; $d3 on
>018663	79 86					.word NotImplemented       & $FFFF ; $d4 restore
>018665	48 8d					.word Command_POKE         & $FFFF ; $d5 poke
>018667	c1 8c					.word Command_PRINT        & $FFFF ; $d6 print
>018669	e3 88					.word Command_RUN          & $FFFF ; $d7 run
>01866b	a5 88					.word Command_WAIT         & $FFFF ; $d8 wait
>01866d	bf 8a					.word Command_SYS          & $FFFF ; $d9 sys
>01866f	4c 8d					.word Command_DOKE         & $FFFF ; $da doke
>018671	50 8d					.word Command_LOKE         & $FFFF ; $db loke
>018673	30 8d					.word Command_ASSERT       & $FFFF ; $dc assert
>018675	79 86					.word NotImplemented       & $FFFF ; $dd get
>018677	34 8b					.word Command_ELSE         & $FFFF ; $de else
.018679					NotImplemented:
.018679	20 57 85	jsr $018557			jsr ERR_Handler
>01867c	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>018684	65 6d 65 6e 74 65 64 00
.01868c					BinaryPrecedence:
>01868c	01					.byte 1    ; $80 and
>01868d	01					.byte 1    ; $81 or
>01868e	01					.byte 1    ; $82 xor
>01868f	01					.byte 1    ; $83 eor
>018690	02					.byte 2    ; $84 =
>018691	02					.byte 2    ; $85 <>
>018692	02					.byte 2    ; $86 <
>018693	02					.byte 2    ; $87 <=
>018694	02					.byte 2    ; $88 >
>018695	02					.byte 2    ; $89 >=
>018696	03					.byte 3    ; $8a +
>018697	03					.byte 3    ; $8b -
>018698	04					.byte 4    ; $8c *
>018699	04					.byte 4    ; $8d /
>01869a	05					.byte 5    ; $8e ^
.01869b					KeywordText:
>01869b	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>01869e	4f d2					.byte $4f,$d2                          ; $81 or
>0186a0	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>0186a3	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>0186a6	bd					.byte $bd                              ; $84 =
>0186a7	3c be					.byte $3c,$be                          ; $85 <>
>0186a9	bc					.byte $bc                              ; $86 <
>0186aa	3c bd					.byte $3c,$bd                          ; $87 <=
>0186ac	be					.byte $be                              ; $88 >
>0186ad	3e bd					.byte $3e,$bd                          ; $89 >=
>0186af	ab					.byte $ab                              ; $8a +
>0186b0	ad					.byte $ad                              ; $8b -
>0186b1	aa					.byte $aa                              ; $8c *
>0186b2	af					.byte $af                              ; $8d /
>0186b3	de					.byte $de                              ; $8e ^
>0186b4	49 c6					.byte $49,$c6                          ; $8f if
>0186b6	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>0186bb	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>0186c1	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>0186c4	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>0186c8	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>0186cd	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>0186d1	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>0186d6	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>0186da	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>0186dd	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>0186e0	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>0186e4	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>0186e8	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>0186ec	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>0186f1	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>0186f5	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>0186f9	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>0186ff	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>018706	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>01870b	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>01870f	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>018714	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>018718	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>01871c	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>018721	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>018725	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>018729	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>01872d	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>018731	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>018735	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>018739	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>01873d	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>018741	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>018746	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>01874b	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>01874f	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>018753	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>018758	50 4f 53 a8				.byte $50,$4f,$53,$a8                  ; $b5 pos(
>01875c	54 41 42 a8				.byte $54,$41,$42,$a8                  ; $b6 tab(
>018760	a4					.byte $a4                              ; $b7 $
>018761	24 a8					.byte $24,$a8                          ; $b8 $(
>018763	a3					.byte $a3                              ; $b9 #
>018764	23 a8					.byte $23,$a8                          ; $ba #(
>018766	a5					.byte $a5                              ; $bb %
>018767	25 a8					.byte $25,$a8                          ; $bc %(
>018769	a8					.byte $a8                              ; $bd (
>01876a	a9					.byte $a9                              ; $be )
>01876b	ac					.byte $ac                              ; $bf ,
>01876c	ba					.byte $ba                              ; $c0 :
>01876d	bb					.byte $bb                              ; $c1 ;
>01876e	44 45 c6				.byte $44,$45,$c6                      ; $c2 def
>018771	43 4c d2				.byte $43,$4c,$d2                      ; $c3 clr
>018774	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $c4 stop
>018778	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c5 data
>01877c	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c6 read
>018780	44 49 cd				.byte $44,$49,$cd                      ; $c7 dim
>018783	54 cf					.byte $54,$cf                          ; $c8 to
>018785	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c9 step
>018789	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $ca gosub
>01878e	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $cb return
>018794	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $cc goto
>018798	45 4e c4				.byte $45,$4e,$c4                      ; $cd end
>01879b	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $ce input
>0187a0	4c 45 d4				.byte $4c,$45,$d4                      ; $cf let
>0187a3	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $d0 list
>0187a7	4e 45 d7				.byte $4e,$45,$d7                      ; $d1 new
>0187aa	4f 4c c4				.byte $4f,$4c,$c4                      ; $d2 old
>0187ad	4f ce					.byte $4f,$ce                          ; $d3 on
>0187af	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d4 restore
>0187b6	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d5 poke
>0187ba	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d6 print
>0187bf	52 55 ce				.byte $52,$55,$ce                      ; $d7 run
>0187c2	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d8 wait
>0187c6	53 59 d3				.byte $53,$59,$d3                      ; $d9 sys
>0187c9	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $da doke
>0187cd	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $db loke
>0187d1	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $dc assert
>0187d7	47 45 d4				.byte $47,$45,$d4                      ; $dd get
>0187da	45 4c 53 c5				.byte $45,$4c,$53,$c5                  ; $de else
>0187de	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_pos = $b5
=$b6					token_tab = $b6
=$b7					token_dollar = $b7
=$b8					token_dollarlparen = $b8
=$b9					token_hash = $b9
=$ba					token_hashlparen = $ba
=$bb					token_percent = $bb
=$bc					token_percentlparen = $bc
=$bd					token_lparen = $bd
=$be					token_rparen = $be
=$bf					token_comma = $bf
=$c0					token_colon = $c0
=$c1					token_semicolon = $c1
=$c2					token_def = $c2
=$c3					token_clr = $c3
=$c4					token_stop = $c4
=$c5					token_data = $c5
=$c6					token_read = $c6
=$c7					token_dim = $c7
=$c8					token_to = $c8
=$c9					token_step = $c9
=$ca					token_gosub = $ca
=$cb					token_return = $cb
=$cc					token_goto = $cc
=$cd					token_end = $cd
=$ce					token_input = $ce
=$cf					token_let = $cf
=$d0					token_list = $d0
=$d1					token_new = $d1
=$d2					token_old = $d2
=$d3					token_on = $d3
=$d4					token_restore = $d4
=$d5					token_poke = $d5
=$d6					token_print = $d6
=$d7					token_run = $d7
=$d8					token_wait = $d8
=$d9					token_sys = $d9
=$da					token_doke = $da
=$db					token_loke = $db
=$dc					token_assert = $dc
=$dd					token_get = $dd
=$de					token_else = $de

;******  Return to file: modules/basic/core.asm

.0187df					BASIC_Start:
.0187df	20 a8 81	jsr $0181a8			jsr 	IF_Reset 					; set up and clear screen.
.0187e2	20 00 80	jsr $018000			jsr 	IFT_ClearScreen
.0187e5	a9 5c		lda #$5c			lda 	#$5C 						; JMP Long opcode
.0187e7	8d 10 03	sta $0310			sta 	LocalVector
.0187ea	8d 0c 03	sta $030c			sta 	UserVector
.0187ed	a9 80		lda #$80			lda 	#USRDefault & $FF 			; reset USR vector
.0187ef	8d 0d 03	sta $030d			sta 	UserVector+1
.0187f2	a9 93		lda #$93			lda 	#(USRDefault >> 8) & $FF
.0187f4	8d 0e 03	sta $030e			sta 	UserVector+2
.0187f7	a9 01		lda #$01			lda 	#(USRDefault >> 16) & $FF
.0187f9	8d 0f 03	sta $030f			sta 	UserVector+3
.0187fc	20 27 96	jsr $019627			jsr 	UpdateProgramEnd 			; update the program end.
.0187ff	20 5a 8e	jsr $018e5a			jsr 	ResetRunStatus 				; clear everything (CLR command)
.018802	c2 30		rep #$30			rep 	#$30
.018804	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.018807	1b		tcs				tcs
.018808	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.01880b	e2 30		sep #$30			sep 	#$30
.01880d	4c e3 88	jmp $0188e3			jmp 	COMMAND_Run
.018810					WarmStart:
.018810	c2 30		rep #$30			rep 	#$30
.018812	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.018815	1b		tcs				tcs
.018816	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.018819	e2 30		sep #$30			sep 	#$30
.01881b	80 f3		bra $018810			bra 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/dim.asm

.01881d					Command_DIM:
.01881d	98		tya				tya
.01881e	48		pha				pha 								; push on stack.
.01881f	20 8f 97	jsr $01978f			jsr 	VariableExtract 			; get the identifier
.018822	ad 95 03	lda $0395			lda 	Var_Type 					; check it is an array
.018825	29 01		and #$01			and 	#1
.018827	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.018829	d0 6c		bne $018897			bne 	_CDIError
.01882b	a9 00		lda #$00			lda 	#0 							; reset the DIM index. The dimensions are
.01882d	8d b9 03	sta $03b9			sta 	UsrArrayIdx 				; built up here and copied in case we autodim
.018830					_CDIGetDimension:
.018830	ad b9 03	lda $03b9			lda 	UsrArrayIdx 				; done too many ?
.018833	c9 06		cmp #$06			cmp 	#ArrayMaxDim*2
.018835	f0 60		beq $018897			beq 	_CDIError
.018837	20 5b 90	jsr $01905b			jsr 	EvaluateInteger 			; evaluate an index size
.01883a	a5 81		lda $81				lda 	XS_Mantissa+1 				; check in range 0-7FFF
.01883c	29 80		and #$80			and 	#$80
.01883e	05 82		ora $82				ora 	XS_Mantissa+2
.018840	05 83		ora $83				ora 	XS_Mantissa+3
.018842	d0 53		bne $018897			bne 	_CDIError
.018844	ae b9 03	ldx $03b9			ldx 	UsrArrayIdx 				; copy into the array table.
.018847	18		clc				clc 								; add 1 - max index => size.
.018848	a5 80		lda $80				lda 	XS_Mantissa+0
.01884a	69 01		adc #$01			adc 	#1
.01884c	9d b1 03	sta $03b1,x			sta 	UsrArrayDef+0,x
.01884f	a5 81		lda $81				lda 	XS_Mantissa+1
.018851	69 00		adc #$00			adc 	#0
.018853	9d b2 03	sta $03b2,x			sta 	UsrArrayDef+1,x
.018856	30 3f		bmi $018897			bmi 	_CDIError 					; could be dim a(32767)
.018858	e8		inx				inx 								; bump index.
.018859	e8		inx				inx
.01885a	8e b9 03	stx $03b9			stx 	UsrArrayIdx
.01885d	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01885f	c8		iny				iny
.018860	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another dimension
.018862	f0 cc		beq $018830			beq 	_CDIGetDimension
.018864	88		dey				dey
.018865	20 83 96	jsr $019683			jsr 	CheckNextRParen 			; closing ) present ?
.018868	ae b9 03	ldx $03b9			ldx 	UsrArrayIdx 				; copy USR array to default
.01886b	a9 ff		lda #$ff			lda 	#$FF 						; put end marker in ArrayDef
.01886d	9d aa 03	sta $03aa,x			sta 	ArrayDef+1,x
.018870					_CDICopy:
.018870	bd b1 03	lda $03b1,x			lda 	UsrArrayDef,x
.018873	9d a9 03	sta $03a9,x			sta 	ArrayDef,x
.018876	ca		dex				dex
.018877	10 f7		bpl $018870			bpl 	_CDICopy
.018879	68		pla				pla									; position of array identifier
.01887a	85 10		sta $10				sta 	zTemp1
.01887c	98		tya				tya
.01887d	48		pha				pha
.01887e	a5 10		lda $10				lda 	zTemp1 						; point to identifier
.018880	a8		tay				tay
.018881	20 8f 97	jsr $01978f			jsr 	VariableExtract 			; get the identifier
.018884	20 28 9a	jsr $019a28			jsr 	VariableLocate 				; check if it exists already.
.018887	b0 0e		bcs $018897			bcs 	_CDIError
.018889	20 1b 98	jsr $01981b			jsr 	VariableCreate 				; create it using the current ArrayDef
.01888c	68		pla				pla 								; restore code position
.01888d	a8		tay				tay
.01888e	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018890	c8		iny				iny
.018891	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another DIM
.018893	f0 88		beq $01881d			beq 	Command_DIM
.018895	88		dey				dey
.018896	60		rts				rts
.018897					_CDIError:
.018897	20 57 85	jsr $018557			jsr ERR_Handler
>01889a	42 61 64 20 44 49 4d 00			.text "Bad DIM",0
.0188a2					_CDISyntax:
.0188a2	4c 28 85	jmp $018528			jmp 	SyntaxError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/wait.asm

.0188a5					Command_WAIT:
.0188a5	20 5b 90	jsr $01905b			jsr		EvaluateInteger 			; address
.0188a8	a2 06		ldx #$06			ldx 	#XS_Size 					; and mask.
.0188aa	20 8b 96	jsr $01968b			jsr 	CheckNextComma
.0188ad	20 5d 90	jsr $01905d			jsr 	EvaluateIntegerX
.0188b0	a9 00		lda #$00			lda 	#0							; set default xor.
.0188b2	85 8c		sta $8c				sta 	XS_Mantissa+XS_Size*2
.0188b4	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0188b6	c9 bf		cmp #$bf			cmp 	#token_Comma 				; no use the default
.0188b8	d0 06		bne $0188c0			bne 	_CWAXorDefault
.0188ba	c8		iny				iny
.0188bb	a2 0c		ldx #$0c			ldx 	#XS_Size*2
.0188bd	20 5d 90	jsr $01905d			jsr 	EvaluateIntegerX
.0188c0					_CWAXorDefault:
.0188c0	a5 80		lda $80				lda 	XS_Mantissa 				; copy 24 bits of mantissa to ZLTemp1
.0188c2	85 1a		sta $1a				sta 	zLTemp1
.0188c4	a5 81		lda $81				lda 	XS_Mantissa+1
.0188c6	85 1b		sta $1b				sta 	zLTemp1+1
.0188c8	a5 82		lda $82				lda 	XS_Mantissa+2
.0188ca	85 1c		sta $1c				sta 	zLTemp1+2
.0188cc					_CWAWaitLoop:
.0188cc	20 25 85	jsr $018525			jsr 	CheckBreak 					; exit on break.
.0188cf	c9 00		cmp #$00			cmp 	#0
.0188d1	d0 0f		bne $0188e2			bne 	_CWAWaitExit
.0188d3	a9 01		lda #$01			lda 	#1							; read 1 byte to mantissa/0
.0188d5	a2 00		ldx #$00			ldx 	#0
.0188d7	5a		phy				phy 								; this is the same routine as PEEK.
.0188d8	20 05 96	jsr $019605			jsr 	MemRead
.0188db	7a		ply				ply
.0188dc	25 86		and $86				and 	XS_Mantissa+XS_Size 		; process it
.0188de	45 8c		eor $8c				eor 	XS_Mantissa+XS_Size*2
.0188e0	f0 ea		beq $0188cc			beq 	_CWAWaitLoop
.0188e2					_CWAWaitExit:
.0188e2	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/run.asm

.0188e3					Command_RUN:
.0188e3	20 5a 8e	jsr $018e5a			jsr 	ResetRunStatus 				; clear, reset stacks etc.
.0188e6	a9 00		lda #$00			lda 	#BasicProgram & $FF
.0188e8	85 16		sta $16				sta 	zCodePtr+0
.0188ea	a9 10		lda #$10			lda 	#BasicProgram >> 8
.0188ec	85 17		sta $17				sta 	zCodePtr+1
.0188ee	a9 00		lda #$00			lda 	#0
.0188f0	85 18		sta $18				sta 	zCodePtr+2
.0188f2	85 19		sta $19				sta 	zCodePtr+3
.0188f4	a0 03		ldy #$03			ldy 	#3
.0188f6					RUN_NewLine:
.0188f6	a0 00		ldy #$00			ldy 	#0
.0188f8	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0188fa	c8		iny				iny
.0188fb	c8		iny				iny
.0188fc	c8		iny				iny
.0188fd	c9 00		cmp #$00			cmp 	#0 							; if the offset is zero then END.
.0188ff	d0 16		bne $018917			bne 	RUN_NextCommand
.018901	4c d9 8a	jmp $018ad9			jmp 	Command_END 				; go do the command code.
.018904					RUN_Skip:
.018904	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018906	c8		iny				iny 								; skip
.018907	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018909	90 0c		bcc $018917			bcc 	_SEDone 					; so just skip over it.
.01890b	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.01890d	90 07		bcc $018916			bcc 	_SEDouble
.01890f	98		tya				tya 								; this is Y + 1
.018910	18		clc				clc
.018911	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018913	a8		tay				tay 								; back in Y.
.018914	88		dey				dey 								; fix up, one for the +1, one for the iny
.018915	88		dey				dey
.018916					_SEDouble:
.018916	c8		iny				iny
.018917					_SEDone:
.018917					RUN_NextCommand:
.018917	ad a8 03	lda $03a8			lda 	BreakCount 					; break counter
.01891a	69 10		adc #$10			adc 	#16 						; one time in 16
.01891c	8d a8 03	sta $03a8			sta 	BreakCount
.01891f	90 0a		bcc $01892b			bcc 	RUN_NoCheckBreak
.018921	20 25 85	jsr $018525			jsr 	CheckBreak 					; check for break
.018924	c9 00		cmp #$00			cmp 	#0
.018926	f0 03		beq $01892b			beq 	RUN_NoCheckBreak
.018928	4c 6e 8e	jmp $018e6e			jmp 	Command_STOP 				; stop on BREAK.
.01892b					RUN_NoCheckBreak:
.01892b	a9 00		lda #$00			lda 	#0 							; this resets temporary string allocation.
.01892d	85 21		sta $21				sta 	zTempStr+1 					; (initialised when first called)
.01892f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018931	c9 c0		cmp #$c0			cmp 	#token_Colon 				; skip over colons
.018933	f0 cf		beq $018904			beq 	RUN_Skip
.018935	c9 00		cmp #$00			cmp 	#0 							; if non-zero execute whatever
.018937	d0 0f		bne $018948			bne 	RUN_Execute
.018939					RUN_NextLine:
.018939	a0 00		ldy #$00			ldy 	#0 							; point to offset
.01893b	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.01893d	18		clc				clc
.01893e	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018940	85 16		sta $16				sta 	zCodePtr
.018942	90 02		bcc $018946			bcc 	_SNLNoCarry
.018944	e6 17		inc $17				inc 	zCodePtr+1
.018946					_SNLNoCarry:
.018946	80 ae		bra $0188f6			bra 	RUN_NewLine 				; go do the new line code
.018948					RUN_Execute:
.018948	c9 f8		cmp #$f8			cmp 	#$F8 						; handle shifts, REM etc.
.01894a	b0 1e		bcs $01896a			bcs 	RUN_Extension
.01894c	c8		iny				iny
.01894d	0a		asl a				asl 	a 							; double the character read.
.01894e	90 14		bcc $018964			bcc 	RUN_Default 				; if carry clear was $00-$7F, so try LET.
.018950	aa		tax				tax 								; ready to look up.
.018951	bf bb 85 01	lda $0185bb,x			lda 	VectorTable,x 				; copy address into LocalVector
.018955	8d 11 03	sta $0311			sta 	LocalVector+1
.018958	bf bc 85 01	lda $0185bc,x			lda 	VectorTable+1,x
.01895c	8d 12 03	sta $0312			sta 	LocalVector+2
.01895f	20 a8 8f	jsr $018fa8			jsr 	EVCallLocalVector 			; execute the appropriate code.
.018962	80 b3		bra $018917			bra 	RUN_NextCommand 			; do the next command.
.018964					RUN_Default:
.018964	88		dey				dey
.018965	20 9e 8a	jsr $018a9e			jsr 	Command_LET 				; and try LET.
.018968	80 ad		bra $018917			bra 	RUN_NextCommand
.01896a					RUN_Extension:
.01896a	c9 ff		cmp #$ff			cmp 	#$FF 						; if $FF (REM)
.01896c	f0 96		beq $018904			beq 	RUN_Skip 					; skip over it.
.01896e	4c 28 85	jmp $018528			jmp 	SyntaxError
.018971					Command_COLON:
.018971	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/for.asm

.018972					Command_FOR:
.018972	20 9e 8a	jsr $018a9e			jsr 	Command_LET 				; do the A = 99 bit
.018975	a5 24		lda $24				lda 	zVarType 					; obviously has to be integer/real.
.018977	c9 b7		cmp #$b7			cmp 	#token_Dollar
.018979	f0 71		beq $0189ec			beq 	_CFOError
.01897b	48		pha				pha 								; save the variable type.
.01897c	5a		phy				phy 								; save type/variable address.
.01897d	a0 01		ldy #$01			ldy 	#1							; type at + 1
.01897f	91 26		sta ($26),y			sta 	(zBasicSP),y
.018981	c8		iny				iny
.018982	a5 22		lda $22				lda 	zVarDataPtr 				; data low at +2
.018984	91 26		sta ($26),y			sta 	(zBasicSP),y
.018986	c8		iny				iny
.018987	a5 23		lda $23				lda 	zVarDataPtr+1 				; data high at +3
.018989	91 26		sta ($26),y			sta 	(zBasicSP),y
.01898b	7a		ply				ply
.01898c	a9 43		lda #$43			lda 	#(SMark_For << 4) + 3
.01898e	20 9f 84	jsr $01849f			jsr 	StackPushFrame 				; push on the stack with FOR marker.
.018991	a9 c8		lda #$c8			lda 	#token_TO
.018993	20 6c 96	jsr $01966c			jsr 	CheckNextToken
.018996	a2 00		ldx #$00			ldx 	#0 							; put in Mantissa, bottom
.018998	20 c5 8e	jsr $018ec5			jsr 	EvaluateExpression
.01899b	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01899d	a2 06		ldx #$06			ldx 	#XS_Size 					; X to second level
.01899f	c9 c9		cmp #$c9			cmp 	#token_STEP
.0189a1	d0 06		bne $0189a9			bne 	_CFOStep1
.0189a3	c8		iny				iny
.0189a4	20 c7 8e	jsr $018ec7			jsr 	EvaluateExpressionX 		; get STEP value.
.0189a7	80 0e		bra $0189b7			bra 	_CFOHaveStep
.0189a9					_CFOStep1:
.0189a9	a9 00		lda #$00			lda 	#0							; set step to integer 1.
.0189ab	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0189ad	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0189af	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0189b1	a9 01		lda #$01			lda 	#1
.0189b3	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0189b5	95 85		sta $85,x			sta 	XS_Type,x
.0189b7					_CFOHaveStep:
.0189b7	68		pla				pla 								; restore variable type
.0189b8	a2 00		ldx #$00			ldx 	#0
.0189ba	c9 bb		cmp #$bb			cmp 	#token_Percent 				; do conversion to type
.0189bc	f0 0a		beq $0189c8			beq 	_CFOInteger
.0189be	20 33 a0	jsr $01a033			jsr 	FPUToFloat
.0189c1	a2 06		ldx #$06			ldx 	#6
.0189c3	20 33 a0	jsr $01a033			jsr 	FPUToFloat
.0189c6	80 08		bra $0189d0			bra 	_CFOEndConv
.0189c8					_CFOInteger:
.0189c8	20 7f a0	jsr $01a07f			jsr 	FPUToInteger
.0189cb	a2 06		ldx #$06			ldx 	#6
.0189cd	20 7f a0	jsr $01a07f			jsr 	FPUToInteger
.0189d0					_CFOEndConv:
.0189d0	20 e6 84	jsr $0184e6			jsr 	StackSavePosition 			; save the loop position at 1-5
.0189d3	a9 45		lda #$45			lda 	#(SMark_For << 4)+SourcePosSize
.0189d5	20 9f 84	jsr $01849f			jsr 	StackPushFrame 				; push the loop address frame.
.0189d8	5a		phy				phy
.0189d9	a0 00		ldy #$00			ldy 	#0
.0189db					_CFOCopy:
.0189db	b9 80 00	lda $0080,y			lda 	XS_Mantissa+0,y
.0189de	c8		iny				iny
.0189df	91 26		sta ($26),y			sta 	(zBasicSP),y
.0189e1	c0 0c		cpy #$0c			cpy 	#XS_Size*2
.0189e3	d0 f6		bne $0189db			bne 	_CFOCopy
.0189e5	7a		ply				ply
.0189e6	a9 4c		lda #$4c			lda 	#(SMark_For << 4)+(XS_Size*2)
.0189e8	20 9f 84	jsr $01849f			jsr 	StackPushFrame
.0189eb	60		rts				rts
.0189ec					_CFOError:
.0189ec	4c 38 85	jmp $018538			jmp 	TypeError 					; wrong type.
.0189ef					Command_NEXT:
.0189ef	a9 00		lda #$00			lda 	#0 							; set variable data pointer+1 to zero
.0189f1	85 23		sta $23				sta 	zVarDataPtr+1 				; this means we don't check
.0189f3	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0189f5	c9 00		cmp #$00			cmp 	#0 							; EOL
.0189f7	f0 07		beq $018a00			beq 	_CNextNoVariable
.0189f9	c9 40		cmp #$40			cmp 	#$40
.0189fb	b0 03		bcs $018a00			bcs 	_CNextNoVariable
.0189fd	20 24 97	jsr $019724			jsr 	VariableFind
.018a00					_CNextNoVariable:
.018a00	a9 40		lda #$40			lda 	#(SMark_For << 4) 			; pop loop address frame
.018a02	20 b6 84	jsr $0184b6			jsr 	StackPopFrame
.018a05	a9 40		lda #$40			lda 	#(SMark_For << 4) 			; pop STEP/TARGET frame.
.018a07	20 b6 84	jsr $0184b6			jsr 	StackPopFrame
.018a0a	a9 40		lda #$40			lda 	#(Smark_For << 4) 			; pop variable address frame.
.018a0c	20 b6 84	jsr $0184b6			jsr 	StackPopFrame
.018a0f	a5 23		lda $23				lda 	zVarDataPtr+1 				; if zero, then no variable provided
.018a11	f0 11		beq $018a24			beq 	_CNextGetTarget 			; e.g. just NEXT not NEXT x
.018a13	5a		phy				phy 								; check addresses match.
.018a14	a0 02		ldy #$02			ldy 	#2
.018a16	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a18	c5 22		cmp $22				cmp 	zVarDataPtr
.018a1a	d0 6b		bne $018a87			bne 	_CNextWrong
.018a1c	c8		iny				iny
.018a1d	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a1f	c5 23		cmp $23				cmp 	zVarDataPtr+1
.018a21	d0 64		bne $018a87			bne 	_CNextWrong
.018a23	7a		ply				ply
.018a24					_CNextGetTarget:
.018a24	5a		phy				phy
.018a25	a0 01		ldy #$01			ldy 	#1 							; restore variable type and data.
.018a27	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a29	85 24		sta $24				sta 	zVarType
.018a2b	c8		iny				iny
.018a2c	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a2e	85 22		sta $22				sta 	zVarDataPtr
.018a30	c8		iny				iny
.018a31	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a33	85 23		sta $23				sta 	zVarDataPtr+1
.018a35	a2 0c		ldx #$0c			ldx 	#12
.018a37	20 6c 9a	jsr $019a6c			jsr 	VariableGet 				; get that variable value into expr[2]
.018a3a	a2 00		ldx #$00			ldx 	#0 							; copy stacked Target/Step into expr[0] and [1]
.018a3c	a0 0b		ldy #$0b			ldy 	#11
.018a3e					_CNXCopy:
.018a3e	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a40	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018a42	e8		inx				inx
.018a43	c8		iny				iny
.018a44	e0 0c		cpx #$0c			cpx 	#XS_Size*2
.018a46	d0 f6		bne $018a3e			bne 	_CNXCopy
.018a48	7a		ply				ply
.018a49	a2 06		ldx #$06			ldx 	#6 							; point at expr[1] s
.018a4b	20 cd 92	jsr $0192cd			jsr 	GetSignCurrent
.018a4e	8d a7 03	sta $03a7			sta 	SignNext 					; save in temporary.
.018a51	a2 06		ldx #$06			ldx 	#6 							; add them, however
.018a53	20 ac 91	jsr $0191ac			jsr 	BinaryOp_Add
.018a56	20 bd 9a	jsr $019abd			jsr 	VariableSet					; and write variable back.
.018a59	a2 00		ldx #$00			ldx 	#0
.018a5b	20 30 91	jsr $019130			jsr 	CompareValues
.018a5e	09 00		ora #$00			ora 	#0
.018a60	f0 05		beq $018a67			beq 	_CNXAgain 					; if true, then do it again.
.018a62	cd a7 03	cmp $03a7			cmp 	SignNext 					; if sign different, then loop has finished.
.018a65	d0 13		bne $018a7a			bne 	_CNXLoopDone
.018a67					_CNXAgain:
.018a67	a9 43		lda #$43			lda 	#(SMark_For << 4) + 3		; re-stack variable address
.018a69	20 9f 84	jsr $01849f			jsr 	StackPushFrame
.018a6c	20 03 85	jsr $018503			jsr 	StackRestorePosition 		; get restore position back, e.g. loop round.
.018a6f	a9 45		lda #$45			lda 	#(SMark_For << 4)+SourcePosSize
.018a71	20 9f 84	jsr $01849f			jsr 	StackPushFrame
.018a74	a9 4c		lda #$4c			lda 	#(SMark_For << 4)+(XS_Size*2)
.018a76	20 9f 84	jsr $01849f			jsr 	StackPushFrame
.018a79					_CNXExit:
.018a79	60		rts				rts
.018a7a					_CNXLoopDone:
.018a7a	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018a7c	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma ?
.018a7e	d0 f9		bne $018a79			bne 	_CNXExit
.018a80	c8		iny				iny
.018a81	20 24 97	jsr $019724			jsr 	VariableFind 				; identify the variable
.018a84	4c 00 8a	jmp $018a00			jmp 	_CNextNoVariable 			; go back with variable pre-found
.018a87					_CNextWrong:
.018a87	20 57 85	jsr $018557			jsr ERR_Handler
>018a8a	57 72 6f 6e 67 20 4e 65			.text "Wrong Next Variable",0
>018a92	78 74 20 56 61 72 69 61 62 6c 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/let.asm

.018a9e					Command_LET:
.018a9e	20 24 97	jsr $019724			jsr 	VariableFind 				; get reference to one variable.
.018aa1	a9 84		lda #$84			lda 	#token_Equal  				; get equals
.018aa3	20 6c 96	jsr $01966c			jsr 	CheckNextToken
.018aa6	a5 22		lda $22				lda 	zVarDataPtr 				; save variable info on stack
.018aa8	48		pha				pha
.018aa9	a5 23		lda $23				lda 	zVarDataPtr+1
.018aab	48		pha				pha
.018aac	a5 24		lda $24				lda 	zVarType
.018aae	48		pha				pha
.018aaf	20 c5 8e	jsr $018ec5			jsr 	EvaluateExpression 			; evaluate the RHS.
.018ab2	68		pla				pla 								; restore target variable information.
.018ab3	85 24		sta $24				sta 	zVarType
.018ab5	68		pla				pla
.018ab6	85 23		sta $23				sta 	zVarDataPtr+1
.018ab8	68		pla				pla
.018ab9	85 22		sta $22				sta 	zVarDataPtr
.018abb	20 bd 9a	jsr $019abd			jsr 	VariableSet 				; set the value out.
.018abe	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/sys.asm

.018abf					Command_SYS:
.018abf	20 5b 90	jsr $01905b			jsr 	EvaluateInteger 			; address
.018ac2	a5 80		lda $80				lda 	XS_Mantissa+0				; copy to localvector
.018ac4	8d 10 03	sta $0310			sta 	LocalVector+0 				; only three, can only do 24 bit calls
.018ac7	a5 81		lda $81				lda 	XS_Mantissa+1 				; and that only on 65816
.018ac9	8d 11 03	sta $0311			sta 	LocalVector+1
.018acc	a5 82		lda $82				lda 	XS_Mantissa+2
.018ace	8d 12 03	sta $0312			sta 	LocalVector+2
.018ad1	22 d6 8a 01	jsl $018ad6			jsl 	_CSYLocalCall
.018ad5	60		rts				rts
.018ad6					_CSYLocalCall:
.018ad6	dc 10 03	jmp [$0310]			jmp 	[LocalVector]

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/end.asm

.018ad9					Command_END:
>018ad9	02						.byte 	2
.018ada	4c 10 88	jmp $018810			jmp 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/if.asm

.018add					Command_IF:
.018add	20 5b 90	jsr $01905b			jsr 	EvaluateInteger 			; check success.
.018ae0	a5 80		lda $80				lda 	XS_Mantissa+0				; check the result if zero
.018ae2	05 81		ora $81				ora 	XS_Mantissa+1
.018ae4	05 82		ora $82				ora 	XS_Mantissa+2
.018ae6	05 83		ora $83				ora 	XS_Mantissa+3
.018ae8	aa		tax				tax 								; put into X.
.018ae9	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018aeb	c9 93		cmp #$93			cmp 	#token_Then 				; then found.
.018aed	d0 2c		bne $018b1b			bne 	_FIFExtended
.018aef	c8		iny				iny
.018af0	e0 00		cpx #$00			cpx 	#0 							; was it successful.
.018af2	f0 0b		beq $018aff			beq 	_FIFEndOfLine 				; if not, go to the end of the line.
.018af4	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018af6	29 c0		and #$c0			and 	#$C0 						; is it a number
.018af8	c9 40		cmp #$40			cmp 	#$40
.018afa	d0 1e		bne $018b1a			bne 	_FIFContinue 				; if not, do what ever follows.
.018afc	4c d0 8d	jmp $018dd0			jmp		Command_GOTO 				; we have IF <expr> THEN <number> so we do GOTO code.
.018aff					_FIFEndOfLine:
.018aff	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018b01	c9 00		cmp #$00			cmp 	#0 							; if zero, end of line, so exit
.018b03	f0 15		beq $018b1a			beq 	_FIFContinue
.018b05	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018b07	c8		iny				iny 								; skip
.018b08	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018b0a	90 0c		bcc $018b18			bcc 	_SEDone 					; so just skip over it.
.018b0c	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018b0e	90 07		bcc $018b17			bcc 	_SEDouble
.018b10	98		tya				tya 								; this is Y + 1
.018b11	18		clc				clc
.018b12	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018b14	a8		tay				tay 								; back in Y.
.018b15	88		dey				dey 								; fix up, one for the +1, one for the iny
.018b16	88		dey				dey
.018b17					_SEDouble:
.018b17	c8		iny				iny
.018b18					_SEDone:
.018b18	80 e5		bra $018aff			bra 	_FIFEndOfLine
.018b1a					_FIFContinue:
.018b1a	60		rts				rts
.018b1b					_FIFExtended:
.018b1b	da		phx				phx 								; save result
.018b1c	a9 30		lda #$30			lda 	#(SMark_If << 4) 			; push marker on the stack, nothing else.
.018b1e	20 9f 84	jsr $01849f			jsr 	StackPushFrame
.018b21	68		pla				pla 								; restore result
.018b22	f0 01		beq $018b25			beq 	_FIXSkip 					; if zero then it has failed.
.018b24	60		rts				rts 								; test passed, so continue executing
.018b25					_FIXSkip:
.018b25	a9 94		lda #$94			lda 	#token_endif 				; scan forward till found either ELSE or ENDIF
.018b27	a2 de		ldx #$de			ldx 	#token_else 				; at the same level.
.018b29	20 02 84	jsr $018402			jsr 	StructureSearchDouble
.018b2c	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018b2e	c8		iny				iny
.018b2f	c9 94		cmp #$94			cmp 	#token_endif 				; if endif, handle endif code.
.018b31	f0 07		beq $018b3a			beq 	Command_ENDIF
.018b33	60		rts				rts
.018b34					Command_ELSE:
.018b34	a9 94		lda #$94			lda 	#token_endif 				; scan forward till found ENDIF
.018b36	20 00 84	jsr $018400			jsr 	StructureSearchSingle 		; then do the ENDIF pop.
.018b39	c8		iny				iny
.018b3a					Command_ENDIF:
.018b3a	a9 30		lda #$30			lda 	#(SMark_If << 4)
.018b3c	20 b6 84	jsr $0184b6			jsr 	StackPopFrame
.018b3f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/list.asm

.018b40					Command_LIST:
.018b40	20 5a 8c	jsr $018c5a			jsr 	ListGetRange				; get any parameters
.018b43	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018b45	85 16		sta $16				sta 	zCodePtr+0
.018b47	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018b49	85 17		sta $17				sta 	zCodePtr+1
.018b4b	a9 00		lda #$00			lda 	#0
.018b4d	85 18		sta $18				sta 	zCodePtr+2
.018b4f	85 19		sta $19				sta 	zCodePtr+3
.018b51	a0 03		ldy #$03			ldy 	#3
.018b53					_CILLoop:
.018b53	a0 00		ldy #$00			ldy 	#0
.018b55	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018b57	c9 00		cmp #$00			cmp 	#0 							; if zero, end of program
.018b59	f0 23		beq $018b7e			beq 	_CILExit
.018b5b	20 25 85	jsr $018525			jsr 	CheckBreak 					; check break
.018b5e	c9 00		cmp #$00			cmp 	#0
.018b60	d0 1c		bne $018b7e			bne 	_CILExit
.018b62	20 a1 8c	jsr $018ca1			jsr 	ListCheckRange 				; check current line in range.
.018b65	b0 08		bcs $018b6f			bcs		_CILNext
.018b67	a0 00		ldy #$00			ldy 	#0
.018b69	c8		iny				iny
.018b6a	c8		iny				iny
.018b6b	c8		iny				iny
.018b6c	20 81 8b	jsr $018b81			jsr 	ListLine 					; list one line.
.018b6f					_CILNext:
.018b6f	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018b71	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.018b73	18		clc				clc
.018b74	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018b76	85 16		sta $16				sta 	zCodePtr
.018b78	90 02		bcc $018b7c			bcc 	_SNLNoCarry
.018b7a	e6 17		inc $17				inc 	zCodePtr+1
.018b7c					_SNLNoCarry:
.018b7c	80 d5		bra $018b53			bra 	_CILLoop
.018b7e					_CILExit:
.018b7e	4c 10 88	jmp $018810			jmp 	WarmStart
.018b81					ListLine:
.018b81	a0 00		ldy #$00			ldy 	#0
.018b83	c8		iny				iny
.018b84	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018b86	85 80		sta $80				sta 	XS_Mantissa
.018b88	c8		iny				iny
.018b89	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018b8b	85 81		sta $81				sta 	XS_Mantissa+1
.018b8d	20 9d 85	jsr $01859d			jsr 	Print16BitInteger 			; print integer.
.018b90	aa		tax				tax 								; print spaces to column 6
.018b91					_LISpace:
.018b91	a9 20		lda #$20			lda 	#" "
.018b93	20 1f 85	jsr $01851f			jsr 	CharPrint
.018b96	e8		inx				inx
.018b97	e0 06		cpx #$06			cpx 	#6
.018b99	d0 f6		bne $018b91			bne 	_LISpace
.018b9b					_LIDecode:
.018b9b	c8		iny				iny
.018b9c	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018b9e	c9 00		cmp #$00			cmp 	#0 							; zero, exit.
.018ba0	f0 0f		beq $018bb1			beq 	_LIExit
.018ba2	30 12		bmi $018bb6			bmi 	_LIToken
.018ba4	c9 40		cmp #$40			cmp 	#$40 						; 01-$3F, character.
.018ba6	b0 50		bcs $018bf8			bcs 	_LIInteger
.018ba8	49 20		eor #$20			eor 	#$20 						; make 7 bit
.018baa	69 20		adc #$20			adc 	#$20
.018bac	20 4d 8c	jsr $018c4d			jsr 	ListPrintLC 				; print in LC
.018baf	80 ea		bra $018b9b			bra 	_LIDecode
.018bb1					_LIExit:
.018bb1	a9 0d		lda #$0d			lda 	#13 						; print new line.
.018bb3	4c 1f 85	jmp $01851f			jmp 	CharPrint
.018bb6					_LIToken:
.018bb6	c9 fc		cmp #$fc			cmp 	#$FC 						; $FC-$FF ?
.018bb8	90 49		bcc $018c03			bcc		_LICommandToken
.018bba	48		pha				pha 								; save in case end
.018bbb	a2 22		ldx #$22			ldx 	#'"'						; print if $FE quoted string
.018bbd	c9 fe		cmp #$fe			cmp 	#$FE
.018bbf	f0 17		beq $018bd8			beq 	_LIPrint
.018bc1	a2 2e		ldx #$2e			ldx 	#'.'						; print if $FD decimals
.018bc3	c9 fd		cmp #$fd			cmp 	#$FD
.018bc5	f0 11		beq $018bd8			beq 	_LIPrint
.018bc7	a9 52		lda #$52			lda 	#'R'						; must be REM
.018bc9	20 4d 8c	jsr $018c4d			jsr 	ListPrintLC
.018bcc	a9 45		lda #$45			lda 	#'E'
.018bce	20 4d 8c	jsr $018c4d			jsr 	ListPrintLC
.018bd1	a9 4d		lda #$4d			lda 	#'M'
.018bd3	20 4d 8c	jsr $018c4d			jsr 	ListPrintLC
.018bd6	a2 20		ldx #$20			ldx 	#' '
.018bd8					_LIPrint:
.018bd8	8a		txa				txa
.018bd9	20 4d 8c	jsr $018c4d			jsr 	ListPrintLC
.018bdc	c8		iny				iny
.018bdd	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018bdf	aa		tax				tax 								; put in X
.018be0	ca		dex				dex
.018be1					_LILoop:
.018be1	ca		dex				dex 								; exit when count reached zero.
.018be2	f0 08		beq $018bec			beq 	_LIEnd
.018be4	c8		iny				iny
.018be5	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018be7	20 4d 8c	jsr $018c4d			jsr 	ListPrintLC
.018bea	80 f5		bra $018be1			bra 	_LILoop
.018bec	68		pla		_LIEnd:	pla 								; get A back
.018bed	c9 fe		cmp #$fe			cmp 	#$FE 						; if '"' need closing quotes
.018bef	d0 aa		bne $018b9b			bne 	_LIDecode
.018bf1	a9 22		lda #$22			lda 	#'"'
.018bf3	20 4d 8c	jsr $018c4d			jsr 	ListPrintLC
.018bf6	80 a3		bra $018b9b			bra 	_LIDecode
.018bf8					_LIInteger:
.018bf8	a2 00		ldx #$00			ldx 	#0
.018bfa	20 cd 8f	jsr $018fcd			jsr 	EvaluateGetInteger 			; get an atom
.018bfd	88		dey				dey
.018bfe	20 a3 85	jsr $0185a3			jsr 	Print32BitInteger 			; print integer.
.018c01	80 98		bra $018b9b			bra 	_LIDecode
.018c03					_LICommandToken:
.018c03	5a		phy				phy 								; save Y
.018c04	48		pha				pha 								; save token
.018c05	a2 9b		ldx #$9b			ldx  	#KeywordText & $FF 			; address of keyword text table.
.018c07	a9 86		lda #$86			lda 	(#KeywordText >> 8) & $FF
.018c09	86 1a		stx $1a				stx 	zLTemp1
.018c0b	85 1b		sta $1b				sta 	zLTemp1+1
.018c0d	a9 01		lda #$01			lda 	(#KeywordText >> 16) & $FF 	; this is for 65816 (it's a table in code
.018c0f	85 1c		sta $1c				sta 	zLTemp1+2 					; space) and won't affect a 6502 at all.
.018c11	68		pla				pla 								; get token, chuck bit 7.
.018c12	29 7f		and #$7f			and 	#127
.018c14	f0 16		beq $018c2c			beq 	_LIFoundToken
.018c16	aa		tax				tax
.018c17					_LITokenLoop:
.018c17	a0 00		ldy #$00			ldy 	#0
.018c19					_LIFindEnd:
.018c19	b7 1a		lda [$1a],y			lda 	[zLTemp1],y
.018c1b	c8		iny				iny
.018c1c	0a		asl a				asl 	a
.018c1d	90 fa		bcc $018c19			bcc 	_LIFindEnd
.018c1f	98		tya				tya 								; that is step to the next
.018c20	18		clc				clc 								; we don't bother bumping the 3rd byte
.018c21	65 1a		adc $1a				adc 	zLTemp1 					; here.
.018c23	85 1a		sta $1a				sta 	zLTemp1
.018c25	90 02		bcc $018c29			bcc 	_LINoBump
.018c27	e6 1b		inc $1b				inc 	zLTemp1+1
.018c29					_LINoBump:
.018c29	ca		dex				dex 								; no go round again.
.018c2a	d0 eb		bne $018c17			bne 	_LITokenLoop
.018c2c					_LIFoundToken:
.018c2c	a0 00		ldy #$00			ldy 	#0
.018c2e					_LIPrintToken:
.018c2e	b7 1a		lda [$1a],y			lda 	[zLTemp1],y
.018c30	c8		iny				iny
.018c31	48		pha				pha 								; save it
.018c32	29 7f		and #$7f			and 	#$7F
.018c34	20 4d 8c	jsr $018c4d			jsr 	ListPrintLC
.018c37	68		pla				pla
.018c38	10 f4		bpl $018c2e			bpl 	_LIPrintToken 				; go back if not end
.018c3a	7a		ply				ply 								; restore Y
.018c3b	29 7f		and #$7f			and 	#$7F 						; if last char is a letter
.018c3d	c9 41		cmp #$41			cmp 	#"A"
.018c3f	90 09		bcc $018c4a			bcc 	_LINotLetter
.018c41	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018c43	b0 05		bcs $018c4a			bcs 	_LINotLetter
.018c45	a9 20		lda #$20			lda 	#" " 						; add spacing
.018c47	20 4d 8c	jsr $018c4d			jsr 	ListPrintLC
.018c4a					_LINotLetter:
.018c4a	4c 9b 8b	jmp $018b9b			jmp 	_LIDecode
.018c4d					ListPrintLC:
.018c4d	c9 41		cmp #$41			cmp 	#"A"
.018c4f	90 06		bcc $018c57			bcc 	_LPLC0
.018c51	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018c53	b0 02		bcs $018c57			bcs 	_LPLC0
.018c55	69 20		adc #$20			adc 	#$20
.018c57	4c 1f 85	jmp $01851f	_LPLC0:	jmp 	CharPrint
.018c5a					ListGetRange:
.018c5a	a2 0b		ldx #$0b			ldx 	#XS_Size*2-1 				; clear first 2 slots back to defaults.
.018c5c					_LGRClear:
.018c5c	a9 00		lda #$00			lda 	#0
.018c5e	95 80		sta $80,x			sta 	XS_Mantissa,x
.018c60	ca		dex				dex
.018c61	10 f9		bpl $018c5c			bpl 	_LGRClear
.018c63	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c65	c9 00		cmp #$00			cmp 	#0 							; nothing
.018c67	f0 21		beq $018c8a			beq 	_LGRBlank
.018c69	c9 c0		cmp #$c0			cmp 	#token_Colon 				; or colon
.018c6b	f0 1d		beq $018c8a			beq 	_LGRBlank
.018c6d	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma
.018c6f	f0 18		beq $018c89			beq 	_LGREnd 					; then it's LIST ,x
.018c71	20 5b 90	jsr $01905b			jsr 	EvaluateInteger 			; get the first number into bottom
.018c74	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c76	c9 bf		cmp #$bf			cmp 	#token_Comma
.018c78	f0 0f		beq $018c89			beq 	_LGREnd 					; then it is LIST a,b
.018c7a	a5 80		lda $80				lda 	XS_Mantissa+0 				; copy first to second LIST n is n,n
.018c7c	85 86		sta $86				sta 	XS_Mantissa+XS_Size+0
.018c7e	a5 81		lda $81				lda 	XS_Mantissa+1
.018c80	85 87		sta $87				sta 	XS_Mantissa+XS_Size+1
.018c82					_LGRBumpExit:
.018c82	e6 86		inc $86				inc 	XS_Mantissa+XS_Size 		; bump it so we can use cc.
.018c84	d0 02		bne $018c88			bne 	_LGRBump2
.018c86	e6 87		inc $87				inc 	XS_Mantissa+XS_Size+1
.018c88					_LGRBump2:
.018c88	60		rts				rts
.018c89					_LGREnd:
.018c89	c8		iny				iny
.018c8a					_LGRBlank:
.018c8a	a9 ff		lda #$ff			lda 	#$FF 						; default to the end.
.018c8c	85 86		sta $86				sta 	XS_Mantissa+XS_Size
.018c8e	85 87		sta $87				sta 	XS_Mantissa+XS_Size+1
.018c90	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c92	c9 00		cmp #$00			cmp 	#0
.018c94	f0 f2		beq $018c88			beq 	_LGRBump2
.018c96	0a		asl a				asl 	a 							; if not a number, then exit (to end)
.018c97	b0 ef		bcs $018c88			bcs 	_LGRBump2
.018c99	a2 06		ldx #$06			ldx 	#XS_Size 					; get to range
.018c9b	20 5d 90	jsr $01905d			jsr 	EvaluateIntegerX
.018c9e	80 e2		bra $018c82			bra 	_LGRBumpExit
.018ca0	60		rts				rts
.018ca1					ListCheckRange:
.018ca1	c8		iny				iny
.018ca2	a2 00		ldx #$00			ldx 	#0 							; test low
.018ca4	20 b1 8c	jsr $018cb1			jsr 	_LCRCompare
.018ca7	90 06		bcc $018caf			bcc 	_LCRFail
.018ca9	a2 06		ldx #$06			ldx 	#XS_Size 					; test high
.018cab	20 b1 8c	jsr $018cb1			jsr 	_LCRCompare
.018cae	60		rts				rts
.018caf					_LCRFail:
.018caf	38		sec				sec
.018cb0	60		rts				rts
.018cb1					_LCRCompare:
.018cb1	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018cb3	38		sec				sec
.018cb4	f5 80		sbc $80,x			sbc	 	XS_Mantissa+0,x
.018cb6	08		php				php
.018cb7	c8		iny				iny
.018cb8	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018cba	28		plp				plp
.018cbb	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.018cbd	08		php				php
.018cbe	88		dey				dey
.018cbf	28		plp				plp
.018cc0	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/print.asm

.018cc1					Command_PRINT:
.018cc1	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018cc3	c9 00		cmp #$00			cmp 	#0 							; end
.018cc5	f0 65		beq $018d2c			beq 	_CPR_NewLine
.018cc7	c9 c0		cmp #$c0			cmp 	#token_Colon
.018cc9	f0 61		beq $018d2c			beq 	_CPR_NewLine
.018ccb	c9 c1		cmp #$c1			cmp 	#token_SemiColon
.018ccd	f0 50		beq $018d1f			beq 	_CPR_Skip
.018ccf	c9 bf		cmp #$bf			cmp 	#token_Comma
.018cd1	f0 49		beq $018d1c			beq 	_CPR_Tab
.018cd3	20 c5 8e	jsr $018ec5			jsr 	EvaluateExpression 			; get expression.
.018cd6	a5 85		lda $85				lda 	XS_Type 					; get type.
.018cd8	29 02		and #$02			and 	#2
.018cda	d0 24		bne $018d00			bne 	_CPR_String 				; if type = 2 output as string.
.018cdc					_CPR_Number:
.018cdc	a9 00		lda #$00			lda 	#0 							; reset buffer index
.018cde	8d 14 03	sta $0314			sta 	NumBufX
.018ce1	a5 85		lda $85				lda 	XS_Type 					; get type
.018ce3	4a		lsr a				lsr 	a
.018ce4	b0 05		bcs $018ceb			bcs 	_CPRInt 					; if msb set do as integer
.018ce6	20 7e a1	jsr $01a17e			jsr 	FPToString 					; call fp to str otherwise
.018ce9	80 03		bra $018cee			bra 	_CPRNPrint
.018ceb	20 06 9c	jsr $019c06	_CPRInt:jsr 	IntToString
.018cee					_CPRNPrint:
.018cee	ad 15 03	lda $0315			lda 	Num_Buffer 					; is first character -
.018cf1	c9 2d		cmp #$2d			cmp 	#"-"
.018cf3	f0 05		beq $018cfa			beq 	_CPRNoSpace
.018cf5	a9 20		lda #$20			lda 	#" "						; print the leading space
.018cf7	20 1f 85	jsr $01851f			jsr 	CharPrint 					; so beloved of MS Basics.
.018cfa					_CPRNoSpace:
.018cfa	a2 14		ldx #$14			ldx 	#(Num_Buffer-1) & $FF
.018cfc	a9 03		lda #$03			lda 	#(Num_Buffer-1) >> 8
.018cfe	80 04		bra $018d04			bra 	_CPRPrint
.018d00					_CPR_String:
.018d00	a6 80		ldx $80				ldx 	XS_Mantissa
.018d02	a5 81		lda $81				lda 	XS_Mantissa+1
.018d04					_CPRPrint:
.018d04	86 1e		stx $1e				stx 	zGenPtr
.018d06	85 1f		sta $1f				sta 	zGenPtr+1
.018d08	5a		phy				phy
.018d09	a0 00		ldy #$00			ldy 	#0							; get length into X
.018d0b	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018d0d	aa		tax				tax
.018d0e	f0 09		beq $018d19			beq 	_CPREndPrint 				; nothing to print
.018d10					_CPRLoop:
.018d10	c8		iny				iny
.018d11	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018d13	20 1f 85	jsr $01851f			jsr 	CharPrint
.018d16	ca		dex				dex
.018d17	d0 f7		bne $018d10			bne 	_CPRLoop
.018d19					_CPREndPrint:
.018d19	7a		ply				ply
.018d1a	80 a5		bra $018cc1			bra 	Command_Print
.018d1c					_CPR_Tab:
.018d1c	20 4f 80	jsr $01804f			jsr 	IFT_Tab
.018d1f					_CPR_Skip:
.018d1f	c8		iny				iny
.018d20	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018d22	c9 c0		cmp #$c0			cmp 	#token_Colon 				; colon or $00, exit
.018d24	f0 09		beq $018d2f			beq 	_CPR_Exit
.018d26	c9 00		cmp #$00			cmp 	#0
.018d28	d0 97		bne $018cc1			bne 	Command_PRINT 				; if not go round again.
.018d2a	80 03		bra $018d2f			bra 	_CPR_Exit
.018d2c					_CPR_NewLine:
.018d2c	20 5c 80	jsr $01805c			jsr 	IFT_NewLine
.018d2f					_CPR_Exit:
.018d2f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/assert.asm

.018d30					Command_ASSERT:
.018d30	20 5b 90	jsr $01905b			jsr 	EvaluateInteger 			; calculate thing being asserted
.018d33	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; check if true (non-zero)
.018d35	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.018d37	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.018d39	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.018d3b	f0 01		beq $018d3e			beq 	_ASFail
.018d3d	60		rts				rts
.018d3e					_ASFail:
.018d3e	20 57 85	jsr $018557			jsr ERR_Handler
>018d41	41 73 73 65 72 74 00			.text "Assert",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/poke.asm

.018d48					Command_POKE:
.018d48	a9 01		lda #$01			lda 	#1
.018d4a	80 06		bra $018d52			bra 	CmdPoke_Main
.018d4c					Command_DOKE:
.018d4c	a9 02		lda #$02			lda 	#2
.018d4e	80 02		bra $018d52			bra 	CmdPoke_Main
.018d50					Command_LOKE:
.018d50	a9 04		lda #$04			lda 	#4
.018d52					CmdPoke_Main:
.018d52	48		pha				pha
.018d53	20 5b 90	jsr $01905b			jsr 	EvaluateInteger 			; get two parameters.
.018d56	e8		inx				inx
.018d57	e8		inx				inx
.018d58	e8		inx				inx
.018d59	e8		inx				inx
.018d5a	e8		inx				inx
.018d5b	e8		inx				inx
.018d5c	20 8b 96	jsr $01968b			jsr 	CheckNextComma
.018d5f	20 5d 90	jsr $01905d			jsr 	EvaluateIntegerX
.018d62	a5 80		lda $80				lda 	XS_Mantissa+0 			; copy the mantissa into ZLTemp1 (address)
.018d64	85 1a		sta $1a				sta 	zLTemp1
.018d66	a5 81		lda $81				lda 	XS_Mantissa+1
.018d68	85 1b		sta $1b				sta 	zLTemp1+1
.018d6a	a5 82		lda $82				lda 	XS_Mantissa+2
.018d6c	85 1c		sta $1c				sta 	zLTemp1+2
.018d6e	a5 83		lda $83				lda 	XS_Mantissa+3
.018d70	85 1d		sta $1d				sta 	zLTemp1+3
.018d72	68		pla				pla 								; get count
.018d73	5a		phy				phy 								; save Y
.018d74	20 16 96	jsr $019616			jsr 	MemWrite 					; write it out
.018d77	7a		ply				ply 								; restore Y and done.
.018d78	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/newold.asm

.018d79					Command_NEW:
.018d79	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018d7b	85 16		sta $16				sta 	zCodePtr+0
.018d7d	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018d7f	85 17		sta $17				sta 	zCodePtr+1
.018d81	a9 00		lda #$00			lda 	#0
.018d83	85 18		sta $18				sta 	zCodePtr+2
.018d85	85 19		sta $19				sta 	zCodePtr+3
.018d87	a0 03		ldy #$03			ldy 	#3
.018d89	a0 00		ldy #$00			ldy 	#0
.018d8b	a9 00		lda #$00			lda 	#0 							; write a 0 there.
.018d8d	97 16		sta [$16],y			sta 	[zCodePtr],y
.018d8f	20 27 96	jsr $019627			jsr 	UpdateProgramEnd 			; update program end.
.018d92	4c 10 88	jmp $018810			jmp 	WarmStart
.018d95					Command_OLD:
.018d95	ea		nop				nop
.018d96	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018d98	85 16		sta $16				sta 	zCodePtr+0
.018d9a	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018d9c	85 17		sta $17				sta 	zCodePtr+1
.018d9e	a9 00		lda #$00			lda 	#0
.018da0	85 18		sta $18				sta 	zCodePtr+2
.018da2	85 19		sta $19				sta 	zCodePtr+3
.018da4	a0 03		ldy #$03			ldy 	#3
.018da6					_COL_Find:
.018da6	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018da8	c8		iny				iny
.018da9	c9 00		cmp #$00			cmp 	#0 							; if zero, then the position Y/Z is new offset
.018dab	f0 18		beq $018dc5			beq 	_COL_Found
.018dad	98		tya				tya
.018dae	c9 00		cmp #$00			cmp 	#0
.018db0	d0 f4		bne $018da6			bne 	_COL_Find 					; can't find old EOL, give up.
.018db2	20 57 85	jsr $018557			jsr ERR_Handler
>018db5	50 72 6f 67 72 61 6d 20			.text "Program Corrupt",0
>018dbd	43 6f 72 72 75 70 74 00
.018dc5					_COL_Found:
.018dc5	98		tya				tya
.018dc6	48		pha				pha
.018dc7	a0 00		ldy #$00			ldy 	#0
.018dc9	68		pla				pla
.018dca	97 16		sta [$16],y			sta 	[zCodePtr],y
.018dcc	20 27 96	jsr $019627			jsr 	UpdateProgramEnd 			; reset variable pointer
.018dcf	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/branch.asm

.018dd0					Command_GOTO:
.018dd0	20 ed 8d	jsr $018ded			jsr 	GotoGetLineNumber
.018dd3	4c 0a 8e	jmp $018e0a			jmp 	GotoChangeToLineNumber
.018dd6					Command_GOSUB:
.018dd6	20 ed 8d	jsr $018ded			jsr 	GotoGetLineNumber
.018dd9	20 e6 84	jsr $0184e6			jsr 	StackSavePosition
.018ddc	a9 05		lda #$05			lda 	#(SMark_Gosub << 4)+SourcePosSize
.018dde	20 9f 84	jsr $01849f			jsr 	StackPushFrame
.018de1	4c 0a 8e	jmp $018e0a			jmp 	GotoChangeToLineNumber
.018de4					Command_RETURN:
.018de4	a9 00		lda #$00			lda 	#(SMark_Gosub << 4)
.018de6	20 b6 84	jsr $0184b6			jsr 	StackPopFrame
.018de9	20 03 85	jsr $018503			jsr 	StackRestorePosition
.018dec	60		rts				rts
.018ded					GotoGetLineNumber:
.018ded	20 5b 90	jsr $01905b			jsr 	EvaluateInteger
.018df0	a5 82		lda $82				lda 	XS_Mantissa+2 				; check range
.018df2	05 83		ora $83				ora 	XS_Mantissa+3
.018df4	d0 01		bne $018df7			bne 	_GLINError
.018df6	60		rts				rts
.018df7					_GLINError:
.018df7	20 57 85	jsr $018557			jsr ERR_Handler
>018dfa	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>018e02	20 4e 75 6d 62 65 72 00
.018e0a					GotoChangeToLineNumber:
.018e0a	a5 80		lda $80				lda 	XS_Mantissa+0 				; check line number not zero
.018e0c	05 81		ora $81				ora 	XS_Mantissa+1
.018e0e	f0 37		beq $018e47			beq 	_GCTLFail
.018e10	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018e12	85 16		sta $16				sta 	zCodePtr+0
.018e14	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018e16	85 17		sta $17				sta 	zCodePtr+1
.018e18	a9 00		lda #$00			lda 	#0
.018e1a	85 18		sta $18				sta 	zCodePtr+2
.018e1c	85 19		sta $19				sta 	zCodePtr+3
.018e1e	a0 03		ldy #$03			ldy 	#3
.018e20					_GCTLLoop:
.018e20	a0 00		ldy #$00			ldy 	#0
.018e22	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e24	c9 00		cmp #$00			cmp 	#0
.018e26	f0 1f		beq $018e47			beq 	_GCTLFail
.018e28	c8		iny				iny
.018e29	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e2b	c5 80		cmp $80				cmp 	XS_Mantissa+0
.018e2d	d0 07		bne $018e36			bne 	_GCTLNext
.018e2f	c8		iny				iny
.018e30	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e32	c5 81		cmp $81				cmp 	XS_Mantissa+1
.018e34	f0 0f		beq $018e45			beq 	_GCTLExit
.018e36					_GCTLNext:
.018e36	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018e38	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.018e3a	18		clc				clc
.018e3b	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018e3d	85 16		sta $16				sta 	zCodePtr
.018e3f	90 02		bcc $018e43			bcc 	_SNLNoCarry
.018e41	e6 17		inc $17				inc 	zCodePtr+1
.018e43					_SNLNoCarry:
.018e43	80 db		bra $018e20			bra 	_GCTLLoop 					; try next line.
.018e45					_GCTLExit:
.018e45	c8		iny				iny
.018e46	60		rts				rts
.018e47					_GCTLFail:
.018e47	20 57 85	jsr $018557			jsr ERR_Handler
>018e4a	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>018e52	20 4e 75 6d 62 65 72 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.018e5a					Command_CLR:
.018e5a					ResetRunStatus:
.018e5a	20 60 97	jsr $019760			jsr 	VariableClear
.018e5d	20 8d 84	jsr $01848d			jsr 	StackReset
.018e60	a9 00		lda #$00			lda 	#HighMemory & $FF
.018e62	8d 00 03	sta $0300			sta 	StringPtr
.018e65	a9 7f		lda #$7f			lda 	#HighMemory >> 8
.018e67	8d 01 03	sta $0301			sta 	StringPtr+1
.018e6a	20 2a 99	jsr $01992a			jsr 	ArrayResetDefault
.018e6d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/stop.asm

.018e6e					Command_STOP:
.018e6e	20 57 85	jsr $018557			jsr ERR_Handler
>018e71	53 74 6f 70 00				.text "Stop",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/while.asm

.018e76					Command_WHILE:
.018e76	20 e6 84	jsr $0184e6			jsr 	StackSavePosition			; save position into stack, but don't yet push.
.018e79	20 5b 90	jsr $01905b			jsr 	EvaluateInteger 			; calculate the while loop value.
.018e7c	a5 80		lda $80				lda 	XS_Mantissa+0				; check the result if zero
.018e7e	05 81		ora $81				ora 	XS_Mantissa+1
.018e80	05 82		ora $82				ora 	XS_Mantissa+2
.018e82	05 83		ora $83				ora 	XS_Mantissa+3
.018e84	f0 06		beq $018e8c			beq 	_CWHSkip 					; if it is zero, then skip to WEND.
.018e86	a9 25		lda #$25			lda 	#(SMark_While << 4)+SourcePosSize
.018e88	20 9f 84	jsr $01849f			jsr 	StackPushFrame 				; push on stack
.018e8b	60		rts				rts
.018e8c					_CWHSkip:
.018e8c	a9 95		lda #$95			lda 	#token_Wend 				; look for the WEND token.
.018e8e	20 00 84	jsr $018400			jsr 	StructureSearchSingle
.018e91	c8		iny				iny
.018e92	60		rts				rts
.018e93					Command_WEND:
.018e93	a9 20		lda #$20			lda 	#(SMark_While << 4)			; remove the frame
.018e95	20 b6 84	jsr $0184b6			jsr 	StackPopFrame
.018e98	20 03 85	jsr $018503			jsr 	StackRestorePosition
.018e9b	80 d9		bra $018e76			bra 	Command_WHILE 				; and do the while again.
.018e9d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/repeat.asm

.018e9e					Command_REPEAT:
.018e9e	20 e6 84	jsr $0184e6			jsr 	StackSavePosition			; save position into stack
.018ea1	a9 15		lda #$15			lda 	#(SMark_Repeat << 4)+SourcePosSize
.018ea3	20 9f 84	jsr $01849f			jsr 	StackPushFrame 				; push on stack
.018ea6	60		rts				rts
.018ea7					Command_UNTIL:
.018ea7	a9 10		lda #$10			lda 	#(SMark_Repeat << 4)		; remove the frame
.018ea9	20 b6 84	jsr $0184b6			jsr 	StackPopFrame
.018eac	20 5b 90	jsr $01905b			jsr 	EvaluateInteger				; work out UNTIL
.018eaf	a5 80		lda $80				lda 	XS_Mantissa+0 				; check if zero.
.018eb1	05 81		ora $81				ora 	XS_Mantissa+1
.018eb3	05 82		ora $82				ora 	XS_Mantissa+2
.018eb5	05 83		ora $83				ora 	XS_Mantissa+3
.018eb7	d0 08		bne $018ec1			bne 	_CUTExit 					; if not, just exit
.018eb9	20 03 85	jsr $018503			jsr 	StackRestorePosition 		; otherwise loop round again.
.018ebc	a9 15		lda #$15			lda 	#(SMark_Repeat << 4)+SourcePosSize
.018ebe	20 9f 84	jsr $01849f			jsr 	StackPushFrame 				; fix the stack back.
.018ec1					_CUTExit:
.018ec1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.018ec2					EVESyntax:
.018ec2	4c 28 85	jmp $018528			jmp 	SyntaxError
.018ec5					EvaluateExpression:
.018ec5	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.018ec7					EvaluateExpressionX:
.018ec7	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.018ec9					EvaluateExpressionXA:
.018ec9	48		pha				pha 								; save precedence on stack.
.018eca	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018ecc	f0 f4		beq $018ec2			beq 	EVESyntax 					; end of line, syntax error.
.018ece	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.018ed0	b0 03		bcs $018ed5			bcs 	_EVNotVariable
.018ed2	4c 9f 8f	jmp $018f9f			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.018ed5					_EVNotVariable:
.018ed5	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.018ed7	90 e9		bcc $018ec2			bcc 	EVESyntax
.018ed9	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.018edb	b0 58		bcs $018f35			bcs 	_EVNotInteger
.018edd	20 cd 8f	jsr $018fcd			jsr 	EvaluateGetInteger
.018ee0					_EVCheckDecimal:
.018ee0	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018ee2	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.018ee4	d0 05		bne $018eeb			bne 	_EVGotAtom 					; no, get atom.
.018ee6					_EVIsDecimal:
.018ee6	20 f3 8f	jsr $018ff3			jsr 	EVGetDecimal 				; extend to the decimal part.
.018ee9	80 00		bra $018eeb			bra 	_EVGotAtom 					; and continue to got atom.
.018eeb					_EVGotAtom:
.018eeb	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018eed	10 44		bpl $018f33			bpl 	_EVExitDrop 				; must be a token.
.018eef	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.018ef1	b0 40		bcs $018f33			bcs 	_EVExitDrop
.018ef3	68		pla				pla 								; get current precedence
.018ef4	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.018ef6	da		phx				phx 								; save X
.018ef7	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018ef9	aa		tax				tax 								; put in X
.018efa	bf 0c 86 01	lda $01860c,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.018efe	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.018f00	fa		plx				plx 								; restore X
.018f01	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.018f03	90 2f		bcc $018f34			bcc 	_EVExit 					; exit if too low.
.018f05	f0 2d		beq $018f34			beq 	_EVExit 					; exit if equals
.018f07	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.018f09	48		pha				pha
.018f0a	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018f0c	48		pha				pha
.018f0d	c8		iny				iny
.018f0e	da		phx				phx 								; save current position
.018f0f	e8		inx				inx
.018f10	e8		inx				inx
.018f11	e8		inx				inx
.018f12	e8		inx				inx
.018f13	e8		inx				inx
.018f14	e8		inx				inx
.018f15	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.018f17	20 c9 8e	jsr $018ec9			jsr 	EvaluateExpressionXA 		; do the RHS.
.018f1a	fa		plx				plx 								; restore X
.018f1b	68		pla				pla 								; get the binary operator in A.
.018f1c					_EVCallA:
.018f1c	da		phx				phx 								; save X again
.018f1d	0a		asl a				asl 	a 							; double, lose the MSB.
.018f1e	aa		tax				tax									; put in X
.018f1f	bf bb 85 01	lda $0185bb,x			lda 	VectorTable,x 				; copy address into zGenPtr
.018f23	8d 11 03	sta $0311			sta 	LocalVector+1
.018f26	bf bc 85 01	lda $0185bc,x			lda 	VectorTable+1,x
.018f2a	8d 12 03	sta $0312			sta 	LocalVector+2
.018f2d	fa		plx				plx 								; restore X
.018f2e	20 a8 8f	jsr $018fa8			jsr 	EVCallLocalVector
.018f31	80 b8		bra $018eeb			bra 	_EVGotAtom 					; and loop back.
.018f33					_EVExitDrop:
.018f33	68		pla				pla
.018f34					_EVExit:
.018f34	60		rts				rts
.018f35					_EVNotInteger:
.018f35	c8		iny				iny
.018f36	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.018f38	d0 16		bne $018f50			bne 	_EVNotMinus
.018f3a	20 3c 90	jsr $01903c			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.018f3d	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.018f3f	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.018f41	f0 05		beq $018f48			beq 	_EVMinusFloat
.018f43	20 e9 9b	jsr $019be9			jsr 	IntegerNegateAlways 		; negation
.018f46	80 a3		bra $018eeb			bra 	_EVGotAtom 					; and go back.
.018f48					_EVMinusFloat:
.018f48	b5 85		lda $85,x			lda 	XS_Type,x 					; invert the sign bit.
.018f4a	49 80		eor #$80			eor 	#$80
.018f4c	95 85		sta $85,x			sta 	XS_Type,x
.018f4e	80 9b		bra $018eeb			bra 	_EVGotAtom
.018f50					_EVNotMinus:
.018f50	c9 bd		cmp #$bd			cmp 	#token_lparen 				; is it left parenthesis
.018f52	d0 17		bne $018f6b			bne 	_EVNotParenthesis
.018f54	20 c7 8e	jsr $018ec7			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.018f57	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018f59	c8		iny				iny
.018f5a	c9 be		cmp #$be			cmp 	#token_rparen 				; okay if right bracket.
.018f5c	f0 8d		beq $018eeb			beq 	_EVGotAtom
.018f5e	20 57 85	jsr $018557			jsr ERR_Handler
>018f61	4d 69 73 73 69 6e 67 20			.text "Missing )",0
>018f69	29 00
.018f6b					_EVNotParenthesis:
.018f6b	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.018f6d	d0 0c		bne $018f7b			bne 	_EVNotNot
.018f6f	20 3c 90	jsr $01903c			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.018f72	20 7f a0	jsr $01a07f			jsr 	FPUToInteger 				; make it an integer - if possible.
.018f75	20 21 90	jsr $019021			jsr 	NotInteger 					; do the not calculation
.018f78	4c eb 8e	jmp $018eeb			jmp 	_EVGotAtom
.018f7b					_EVNotNot:
.018f7b	c9 fe		cmp #$fe			cmp 	#$FE
.018f7d	d0 12		bne $018f91			bne 	_EVNotString
.018f7f	20 fe 96	jsr $0196fe			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.018f82	a5 20		lda $20				lda 	zTempStr 					; copy address of string into mantissa
.018f84	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018f86	a5 21		lda $21				lda 	zTempStr+1
.018f88	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018f8a	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.018f8c	95 85		sta $85,x			sta 	XS_Type,x
.018f8e	4c eb 8e	jmp $018eeb			jmp 	_EVGotAtom
.018f91					_EVNotString:
.018f91	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.018f93	90 04		bcc $018f99			bcc 	_EVBadElement
.018f95	c9 b7		cmp #$b7			cmp 	#lastUnaryFunction+1
.018f97	90 03		bcc $018f9c			bcc 	_EVUnaryFunction
.018f99					_EVBadElement:
.018f99	4c 28 85	jmp $018528			jmp 	SyntaxError
.018f9c					_EVUnaryFunction:
.018f9c	4c 1c 8f	jmp $018f1c			jmp 	_EVCallA
.018f9f					_EVVariableHandler:
.018f9f	20 24 97	jsr $019724			jsr 	VariableFind 				; locate a variable
.018fa2	20 6c 9a	jsr $019a6c			jsr 	VariableGet 				; copy into memory.
.018fa5	4c eb 8e	jmp $018eeb			jmp 	_EVGotAtom 					; and go round.
.018fa8					EVCallLocalVector:
.018fa8	6c 11 03	jmp ($0311)			jmp 	(LocalVector+1)
.018fab					EVShiftMantissaLeft6:
.018fab	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.018fad	95 84		sta $84,x			sta 	XS_Exponent,x
.018faf	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.018fb1	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018fb3	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.018fb5	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.018fb7	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.018fb9	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018fbb	a9 00		lda #$00			lda 	#0
.018fbd	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018fbf	20 c2 8f	jsr $018fc2			jsr 	_EVSMLShift 					; call it here to do it twice
.018fc2					_EVSMLShift:
.018fc2	56 84		lsr $84,x			lsr 	XS_Exponent,x
.018fc4	76 83		ror $83,x			ror 	XS_Mantissa+3,x
.018fc6	76 82		ror $82,x			ror 	XS_Mantissa+2,x
.018fc8	76 81		ror $81,x			ror 	XS_Mantissa+1,x
.018fca	76 80		ror $80,x			ror 	XS_Mantissa+0,x
.018fcc	60		rts				rts
.018fcd					EvaluateGetInteger:
.018fcd	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018fcf	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.018fd1	95 80		sta $80,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.018fd3	a9 00		lda #$00			lda 	#0
.018fd5	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018fd7	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.018fd9	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018fdb	1a		inc a				inc 	a 							; set to type 1 (integer)
.018fdc	95 85		sta $85,x			sta 	XS_Type,x
.018fde					_EVCheckNextInteger:
.018fde	c8		iny				iny
.018fdf	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018fe1	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.018fe3	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.018fe5	b0 0b		bcs $018ff2			bcs 	_EVEndInteger
.018fe7	48		pha				pha 								; save it.
.018fe8	20 ab 8f	jsr $018fab			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.018feb	68		pla				pla
.018fec	15 80		ora $80,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.018fee	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018ff0	80 ec		bra $018fde			bra 	_EVCheckNextInteger
.018ff2					_EVEndInteger:
.018ff2	60		rts				rts
.018ff3					EVGetDecimal:
.018ff3	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.018ff5	8d 15 03	sta $0315			sta 	Num_Buffer
.018ff8	da		phx				phx
.018ff9	c8		iny				iny
.018ffa	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018ffc	c8		iny				iny
.018ffd	3a		dec a				dec 	a								; convert to a string length.
.018ffe	3a		dec a				dec 	a
.018fff	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.019001					_EVGDCopy:
.019001	48		pha				pha 									; save count
.019002	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019004	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.019007	e8		inx				inx 									; forward ....
.019008	c8		iny				iny
.019009	68		pla				pla 									; get count
.01900a	3a		dec a				dec 	a 								; until zero
.01900b	d0 f4		bne $019001			bne 	_EVGDCopy
.01900d	9d 15 03	sta $0315,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.019010	fa		plx				plx 									; restore X
.019011	a9 15		lda #$15			lda 	#Num_Buffer & $FF 				; set zGenPtr
.019013	85 1e		sta $1e				sta 	zGenPtr
.019015	a9 03		lda #$03			lda 	#Num_Buffer >> 8
.019017	85 1f		sta $1f				sta 	zGenPtr+1
.019019	5a		phy				phy 									; save Y
.01901a	a0 00		ldy #$00			ldy 	#0 								; start position
.01901c	20 39 a2	jsr $01a239			jsr 	FPFromString 					; convert current
.01901f	7a		ply				ply 									; restore Y
.019020	60		rts				rts
.019021					NotInteger:
.019021	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019023	49 ff		eor #$ff			eor 	#$FF
.019025	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019027	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019029	49 ff		eor #$ff			eor 	#$FF
.01902b	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01902d	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01902f	49 ff		eor #$ff			eor 	#$FF
.019031	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019033	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019035	49 ff		eor #$ff			eor 	#$FF
.019037	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019039	60		rts				rts
.01903a					EvaluateGetAtom:
.01903a	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.01903c					EvaluateGetAtomX:
.01903c	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.01903e	20 c9 8e	jsr $018ec9			jsr 	EvaluateExpressionXA
.019041	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.019043	29 0f		and #$0f			and 	#15
.019045	c9 02		cmp #$02			cmp 	#2
.019047	b0 01		bcs $01904a			bcs 	EvaluateType
.019049	60		rts				rts
.01904a					EvaluateType:
.01904a	4c 38 85	jmp $018538			jmp 	TypeError
.01904d					EvaluateNumber:
.01904d	a2 00		ldx #$00			ldx 	#0
.01904f					EvaluateNumberX:
.01904f	20 c7 8e	jsr $018ec7			jsr 	EvaluateExpressionX
.019052	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0/1
.019054	29 0f		and #$0f			and 	#15
.019056	c9 02		cmp #$02			cmp 	#2
.019058	b0 f0		bcs $01904a			bcs 	EvaluateType
.01905a	60		rts				rts
.01905b					EvaluateInteger:
.01905b	a2 00		ldx #$00			ldx 	#0
.01905d					EvaluateIntegerX:
.01905d	20 4f 90	jsr $01904f			jsr 	EvaluateNumberX
.019060	20 7f a0	jsr $01a07f			jsr 	FPUToInteger
.019063	60		rts				rts
.019064					EvaluateString:
.019064	a2 00		ldx #$00			ldx 	#0
.019066					EvaluateStringX:
.019066	20 c7 8e	jsr $018ec7			jsr 	EvaluateExpressionX
.019069	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 2
.01906b	29 0f		and #$0f			and 	#15
.01906d	c9 02		cmp #$02			cmp 	#2
.01906f	d0 d9		bne $01904a			bne 	EvaluateType
.019071	b5 80		lda $80,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.019073	85 1e		sta $1e				sta 	zGenPtr
.019075	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019077	85 1f		sta $1f				sta 	zGenPtr+1
.019079	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.01907a					BinaryOp_And:
.01907a	20 ce 90	jsr $0190ce			jsr 	BinaryMakeBothInteger
.01907d	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.01907f	35 86		and $86,x			and 	XS2_Mantissa+0,x
.019081	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019083	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.019085	35 87		and $87,x			and 	XS2_Mantissa+1,x
.019087	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019089	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.01908b	35 88		and $88,x			and 	XS2_Mantissa+2,x
.01908d	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01908f	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.019091	35 89		and $89,x			and 	XS2_Mantissa+3,x
.019093	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019095	60		rts				rts
.019096					BinaryOp_Or:
.019096	20 ce 90	jsr $0190ce			jsr 	BinaryMakeBothInteger
.019099	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.01909b	15 86		ora $86,x			ora 	XS2_Mantissa+0,x
.01909d	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01909f	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.0190a1	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.0190a3	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0190a5	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.0190a7	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.0190a9	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0190ab	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.0190ad	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.0190af	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0190b1	60		rts				rts
.0190b2					BinaryOp_Eor:
.0190b2					BinaryOp_Xor:
.0190b2	20 ce 90	jsr $0190ce			jsr 	BinaryMakeBothInteger
.0190b5	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.0190b7	55 86		eor $86,x			eor 	XS2_Mantissa+0,x
.0190b9	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0190bb	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.0190bd	55 87		eor $87,x			eor 	XS2_Mantissa+1,x
.0190bf	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0190c1	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.0190c3	55 88		eor $88,x			eor 	XS2_Mantissa+2,x
.0190c5	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0190c7	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.0190c9	55 89		eor $89,x			eor 	XS2_Mantissa+3,x
.0190cb	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0190cd	60		rts				rts
.0190ce					BinaryMakeBothInteger:
.0190ce	da		phx				phx 								; save X
.0190cf	e8		inx				inx
.0190d0	e8		inx				inx
.0190d1	e8		inx				inx
.0190d2	e8		inx				inx
.0190d3	e8		inx				inx
.0190d4	e8		inx				inx
.0190d5	20 d9 90	jsr $0190d9			jsr 	BinaryMakeInteger 			; convert to integer.
.0190d8	fa		plx				plx 								; restore X and fall through.
.0190d9					BinaryMakeInteger:
.0190d9	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.0190db	29 0f		and #$0f			and 	#15 						; check type zero
.0190dd	f0 04		beq $0190e3			beq 	_BMIConvert 				; if float convert to integer.
.0190df	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.0190e0	90 04		bcc $0190e6			bcc 	_BMIError
.0190e2	60		rts				rts
.0190e3					_BMIConvert:
.0190e3	4c 7f a0	jmp $01a07f			jmp 	FPUToInteger 				; convert to integer
.0190e6					_BMIError:
.0190e6	4c 38 85	jmp $018538			jmp 	TypeError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.0190e9					Binary_Equal:
.0190e9	20 30 91	jsr $019130			jsr 	CompareValues
.0190ec	09 00		ora #$00			ora 	#0
.0190ee	f0 04		beq $0190f4			beq 	CCTrue
.0190f0	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.0190f2	80 02		bra $0190f6			bra 	CCWrite
.0190f4	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.0190f6	95 80		sta $80,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.0190f8	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0190fa	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0190fc	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0190fe	a9 01		lda #$01			lda 	#1
.019100	95 85		sta $85,x			sta 	XS_Type,x 					; set type to integer whatever.
.019102	60		rts				rts
.019103					Binary_NotEqual:
.019103	20 30 91	jsr $019130			jsr 	CompareValues
.019106	09 00		ora #$00			ora 	#0
.019108	f0 e6		beq $0190f0			beq 	CCFalse
.01910a	80 e8		bra $0190f4			bra 	CCTrue
.01910c					Binary_Less:
.01910c	20 30 91	jsr $019130			jsr 	CompareValues
.01910f	09 00		ora #$00			ora 	#0
.019111	30 e1		bmi $0190f4			bmi 	CCTrue
.019113	80 db		bra $0190f0			bra 	CCFalse
.019115					Binary_LessEqual:
.019115	20 30 91	jsr $019130			jsr 	CompareValues
.019118	c9 01		cmp #$01			cmp 	#1
.01911a	d0 d8		bne $0190f4			bne 	CCTrue
.01911c	80 d2		bra $0190f0			bra 	CCFalse
.01911e					Binary_GreaterEqual:
.01911e	20 30 91	jsr $019130			jsr 	CompareValues
.019121	09 00		ora #$00			ora 	#0
.019123	10 cf		bpl $0190f4			bpl 	CCTrue
.019125	80 c9		bra $0190f0			bra 	CCFalse
.019127					Binary_Greater:
.019127	20 30 91	jsr $019130			jsr 	CompareValues
.01912a	c9 01		cmp #$01			cmp 	#1
.01912c	f0 c6		beq $0190f4			beq 	CCTrue
.01912e	80 c0		bra $0190f0			bra 	CCFalse
.019130					CompareValues:
.019130	b5 85		lda $85,x			lda 	XS_Type,x 					; and the types together
.019132	35 8b		and $8b,x			and 	XS2_Type,x
.019134	c9 02		cmp #$02			cmp 	#2
.019136	f0 11		beq $019149			beq 	_CVString
.019138	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.01913a	35 8b		and $8b,x			and 	XS2_Type,x
.01913c	4a		lsr a				lsr 	a 							; shift bit 0 into C
.01913d	90 03		bcc $019142			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.01913f	4c 8b 91	jmp $01918b			jmp 	CompareInteger32 							; so execute code at \1
.019142					_BCFloat:
.019142	20 2f 92	jsr $01922f			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.019145	4c 78 9f	jmp $019f78			jmp 	FPCompare 							; and execute code at \2
.019148	60		rts				rts
.019149					_CVString:
.019149	da		phx				phx 								; save XY
.01914a	5a		phy				phy
.01914b	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.01914d	85 1a		sta $1a				sta		zLTemp1+0
.01914f	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019151	85 1b		sta $1b				sta 	zLTemp1+1
.019153	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.019155	85 1c		sta $1c				sta 	zLTemp1+2
.019157	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.019159	85 1d		sta $1d				sta 	zLTemp1+3
.01915b	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.01915d	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.01915f	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.019161	90 02		bcc $019165			bcc 	_CVCommon
.019163	b1 1c		lda ($1c),y			lda 	(zLTemp1+2),y
.019165					_CVCommon:
.019165	aa		tax				tax 								; put shorter string length in zero.
.019166	f0 0c		beq $019174			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.019168					_CVCompare:
.019168	c8		iny				iny 								; next character
.019169	b1 1a		lda ($1a),y			lda 	(zLTemp1),y 				; compare characters
.01916b	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.01916d	90 13		bcc $019182			bcc 	_CVReturnLess 				; <
.01916f	d0 15		bne $019186			bne 	_CVReturnGreater 			; >
.019171	ca		dex				dex 								; until common length matched.
.019172	d0 f4		bne $019168			bne 	_CVCompare
.019174					_CVMatch:
.019174	a0 00		ldy #$00			ldy 	#0
.019176	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.019178	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.01917a	90 06		bcc $019182			bcc 	_CVReturnLess 				; <
.01917c	d0 08		bne $019186			bne 	_CVReturnGreater 			; >
.01917e	a9 00		lda #$00			lda 	#0
.019180	80 06		bra $019188			bra 	_CVExit 					; same common, same length, same string
.019182					_CVReturnLess:
.019182	a9 ff		lda #$ff			lda 	#$FF
.019184	80 02		bra $019188			bra 	_CVExit
.019186					_CVReturnGreater:
.019186	a9 01		lda #$01			lda 	#$01
.019188					_CVExit:
.019188	7a		ply				ply
.019189	fa		plx				plx
.01918a	60		rts				rts
.01918b					CompareInteger32:
.01918b	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.01918d	49 80		eor #$80			eor 	#$80
.01918f	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019191	b5 89		lda $89,x			lda 	XS2_Mantissa+3,x
.019193	49 80		eor #$80			eor 	#$80
.019195	95 89		sta $89,x			sta 	XS2_Mantissa+3,x
.019197	20 15 92	jsr $019215			jsr 	SubInteger32 				; subtraction
.01919a	90 0d		bcc $0191a9			bcc 	_CI32Less 					; cc return -1
.01919c	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check if zero
.01919e	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.0191a0	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.0191a2	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.0191a4	f0 02		beq $0191a8			beq 	_CI32Exit
.0191a6	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.0191a8					_CI32Exit:
.0191a8	60		rts				rts
.0191a9					_CI32Less:
.0191a9	a9 ff		lda #$ff			lda 	#$FF
.0191ab	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.0191ac					BinaryOp_Add:
.0191ac	b5 85		lda $85,x			lda 	XS_Type,x  					; and types together
.0191ae	35 8b		and $8b,x			and 	XS2_Type,x
.0191b0	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.0191b2	d0 11		bne $0191c5			bne 	_BOAString
.0191b4	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.0191b6	35 8b		and $8b,x			and 	XS2_Type,x
.0191b8	4a		lsr a				lsr 	a 							; shift bit 0 into C
.0191b9	90 03		bcc $0191be			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.0191bb	4c fb 91	jmp $0191fb			jmp 	AddInteger32 							; so execute code at \1
.0191be					_BCFloat:
.0191be	20 2f 92	jsr $01922f			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.0191c1	4c 53 9d	jmp $019d53			jmp 	FPAdd 							; and execute code at \2
.0191c4	60		rts				rts
.0191c5					_BOAString:
.0191c5	4c 49 92	jmp $019249			jmp 	ConcatenateString 			; concatenate two strings.
.0191c8					BinaryOp_Subtract:
.0191c8	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.0191ca	35 8b		and $8b,x			and 	XS2_Type,x
.0191cc	4a		lsr a				lsr 	a 							; shift bit 0 into C
.0191cd	90 03		bcc $0191d2			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.0191cf	4c 15 92	jmp $019215			jmp 	SubInteger32 							; so execute code at \1
.0191d2					_BCFloat:
.0191d2	20 2f 92	jsr $01922f			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.0191d5	4c 4b 9d	jmp $019d4b			jmp 	FPSubtract 							; and execute code at \2
.0191d8	60		rts				rts
.0191d9					BinaryOp_Multiply:
.0191d9	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.0191db	35 8b		and $8b,x			and 	XS2_Type,x
.0191dd	4a		lsr a				lsr 	a 							; shift bit 0 into C
.0191de	90 03		bcc $0191e3			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.0191e0	4c 24 9b	jmp $019b24			jmp 	MulInteger32 							; so execute code at \1
.0191e3					_BCFloat:
.0191e3	20 2f 92	jsr $01922f			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.0191e6	4c 7a 9e	jmp $019e7a			jmp 	FPMultiply 							; and execute code at \2
.0191e9	60		rts				rts
.0191ea					BinaryOp_Divide:
.0191ea	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.0191ec	35 8b		and $8b,x			and 	XS2_Type,x
.0191ee	4a		lsr a				lsr 	a 							; shift bit 0 into C
.0191ef	90 03		bcc $0191f4			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.0191f1	4c 62 9b	jmp $019b62			jmp 	DivInteger32 							; so execute code at \1
.0191f4					_BCFloat:
.0191f4	20 2f 92	jsr $01922f			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.0191f7	4c 07 9e	jmp $019e07			jmp 	FPDivide 							; and execute code at \2
.0191fa	60		rts				rts
.0191fb					AddInteger32:
.0191fb	18		clc				clc
.0191fc	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0191fe	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.019200	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019202	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019204	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.019206	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019208	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01920a	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.01920c	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01920e	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019210	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.019212	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019214	60		rts				rts
.019215					SubInteger32:
.019215	38		sec				sec
.019216	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019218	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.01921a	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01921c	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01921e	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.019220	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019222	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019224	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.019226	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019228	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01922a	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.01922c	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01922e	60		rts				rts
.01922f					BinaryMakeBothFloat:
.01922f	da		phx				phx 								; save X
.019230	e8		inx				inx
.019231	e8		inx				inx
.019232	e8		inx				inx
.019233	e8		inx				inx
.019234	e8		inx				inx
.019235	e8		inx				inx
.019236	20 3a 92	jsr $01923a			jsr 	BinaryMakeFloat 			; convert to float.
.019239	fa		plx				plx 								; restore X and fall through.
.01923a					BinaryMakeFloat:
.01923a	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.01923c	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.01923d	b0 04		bcs $019243			bcs 	_BMFConvert
.01923f	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.019240	b0 04		bcs $019246			bcs 	_BMFError
.019242	60		rts				rts
.019243					_BMFConvert:
.019243	4c 33 a0	jmp $01a033			jmp 	FPUToFloat 					; convert to float
.019246					_BMFError:
.019246	4c 38 85	jmp $018538			jmp 	TypeError
.019249					ConcatenateString:
.019249	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.01924b	85 1a		sta $1a				sta		zLTemp1+0
.01924d	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01924f	85 1b		sta $1b				sta 	zLTemp1+1
.019251	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.019253	85 1c		sta $1c				sta 	zLTemp1+2
.019255	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.019257	85 1d		sta $1d				sta 	zLTemp1+3
.019259	5a		phy				phy
.01925a	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.01925c	b1 1a		lda ($1a),y			lda 	(zlTemp1),y
.01925e	71 1c		adc ($1c),y			adc 	(zlTemp1+2),y
.019260	7a		ply				ply
.019261	b0 33		bcs $019296			bcs 	_CSError					; check in range.
.019263	c9 fe		cmp #$fe			cmp 	#maxString+1
.019265	b0 2f		bcs $019296			bcs 	_CSError
.019267	20 c3 96	jsr $0196c3			jsr 	AllocateTempString 			; store the result
.01926a	20 81 92	jsr $019281			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.01926d	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.01926f	85 1a		sta $1a				sta 	zLTemp1
.019271	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.019273	85 1b		sta $1b				sta 	zLTemp1+1
.019275	20 81 92	jsr $019281			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.019278	a5 20		lda $20				lda 	zTempStr 					; point current to new string
.01927a	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01927c	a5 21		lda $21				lda 	zTempStr+1
.01927e	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019280	60		rts				rts
.019281					_CSCopyString:
.019281	da		phx				phx
.019282	5a		phy				phy
.019283	a0 00		ldy #$00			ldy 	#0 							; get length
.019285	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.019287	f0 0a		beq $019293			beq 	_CSCSExit 					; if zero, exit
.019289	aa		tax				tax 								; put in X
.01928a					_CSCSLoop:
.01928a	c8		iny				iny 								; get next char
.01928b	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.01928d	20 ee 96	jsr $0196ee			jsr		WriteTempString 			; copy out
.019290	ca		dex				dex 								; do whole string
.019291	d0 f7		bne $01928a			bne 	_CSCSLoop
.019293					_CSCSExit:
.019293	7a		ply				ply
.019294	fa		plx				plx
.019295	60		rts				rts
.019296					_CSError:
.019296	20 57 85	jsr $018557			jsr ERR_Handler
>019299	53 74 72 69 6e 67 20 74			.text "String too long",0
>0192a1	6f 6f 20 6c 6f 6e 67 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.0192a9					Unary_Sgn:
.0192a9	20 4f 90	jsr $01904f			jsr 	EvaluateNumberX 			; get value
.0192ac	20 83 96	jsr $019683			jsr 	CheckNextRParen 			; check right bracket.
.0192af	20 cd 92	jsr $0192cd			jsr 	GetSignCurrent 				; get sign.
.0192b2	09 00		ora #$00			ora 	#0
.0192b4	10 08		bpl $0192be			bpl		UnarySetAInteger			; if 0,1 return that.
.0192b6	80 00		bra $0192b8			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.0192b8					UnarySetAMinus1:
.0192b8	a9 ff		lda #$ff			lda 	#$FF
.0192ba	95 80		sta $80,x			sta 	XS_Mantissa,x
.0192bc	80 04		bra $0192c2			bra 	UnarySetAFill
.0192be					UnarySetAInteger:
.0192be	95 80		sta $80,x			sta 	XS_Mantissa,x
.0192c0	a9 00		lda #$00			lda 	#0
.0192c2					UnarySetAFill:
.0192c2	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0192c4	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0192c6	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0192c8	a9 01		lda #$01			lda 	#1
.0192ca	95 85		sta $85,x			sta 	XS_Type,x
.0192cc	60		rts				rts
.0192cd					GetSignCurrent:
.0192cd	b5 85		lda $85,x			lda 	XS_Type,x 					; identify type.
.0192cf	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.0192d0	90 15		bcc $0192e7			bcc 	_GSCFloat
.0192d2	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.0192d4	30 0e		bmi $0192e4			bmi 	_GSCMinus1
.0192d6	15 80		ora $80,x			ora 	XS_Mantissa+0,x
.0192d8	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.0192da	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.0192dc	d0 03		bne $0192e1			bne 	_GSCPlus1
.0192de					_GSCZero:
.0192de	a9 00		lda #$00			lda 	#0
.0192e0	60		rts				rts
.0192e1					_GSCPlus1:
.0192e1	a9 01		lda #$01			lda 	#$01
.0192e3	60		rts				rts
.0192e4					_GSCMinus1:
.0192e4	a9 ff		lda #$ff			lda 	#$FF
.0192e6	60		rts				rts
.0192e7					_GSCFloat:
.0192e7	34 85		bit $85,x			bit 	XS_Type,x
.0192e9	70 f3		bvs $0192de			bvs 	_GSCZero
.0192eb	30 f7		bmi $0192e4			bmi 	_GSCMinus1
.0192ed	80 f2		bra $0192e1			bra 	_GSCPlus1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.0192ef					Unary_Abs:
.0192ef	20 4f 90	jsr $01904f			jsr 	EvaluateNumberX 			; get value
.0192f2	20 83 96	jsr $019683			jsr 	CheckNextRParen 			; check right bracket.
.0192f5	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.0192f7	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.0192f9	f0 07		beq $019302			beq 	_UAMinusFloat
.0192fb	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; check MSB
.0192fd	10 09		bpl $019308			bpl 	_UAExit
.0192ff	4c e9 9b	jmp $019be9			jmp 	IntegerNegateAlways 		; negation
.019302					_UAMinusFloat:
.019302	b5 85		lda $85,x			lda 	XS_Type,x 					; clear the sign bit.
.019304	29 7f		and #$7f			and		#$7F
.019306	95 85		sta $85,x			sta 	XS_Type,x
.019308					_UAExit:
.019308	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.019309					Unary_Peek:
.019309	a9 01		lda #$01			lda 	#1
.01930b	80 06		bra $019313			bra 	UPMain
.01930d					Unary_Deek:
.01930d	a9 02		lda #$02			lda 	#2
.01930f	80 02		bra $019313			bra 	UPMain
.019311					Unary_Leek:
.019311	a9 04		lda #$04			lda 	#4
.019313					UPMain:
.019313	48		pha				pha 								; set bytes to copy.
.019314	20 5d 90	jsr $01905d			jsr 	EvaluateIntegerX 			; numeric parameter
.019317	20 83 96	jsr $019683			jsr 	CheckNextRParen 			; right bracket.
.01931a	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.01931c	85 1a		sta $1a				sta 	zLTemp1
.01931e	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019320	85 1b		sta $1b				sta 	zLTemp1+1
.019322	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019324	85 1c		sta $1c				sta 	zLTemp1+2
.019326	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019328	85 1d		sta $1d				sta 	zLTemp1+3
.01932a	a9 00		lda #$00			lda 	#0 							; clear target area
.01932c	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01932e	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019330	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019332	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019334	68		pla				pla 								; restore bytes to copy
.019335	da		phx				phx 								; save XY
.019336	5a		phy				phy
.019337	20 05 96	jsr $019605			jsr 	MemRead 					; read the bytes in
.01933a	7a		ply				ply 								; restore and exit
.01933b	fa		plx				plx
.01933c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.01933d					Unary_Mod:
.01933d	20 65 93	jsr $019365			jsr 	_UMParameter 				; first parameter
.019340	20 8b 96	jsr $01968b			jsr 	CheckNextComma
.019343	da		phx				phx 								; second parameter
.019344	e8		inx				inx
.019345	e8		inx				inx
.019346	e8		inx				inx
.019347	e8		inx				inx
.019348	e8		inx				inx
.019349	e8		inx				inx
.01934a	20 65 93	jsr $019365			jsr 	_UMParameter
.01934d	fa		plx				plx
.01934e	20 83 96	jsr $019683			jsr 	CheckNextRParen
.019351	20 62 9b	jsr $019b62			jsr 	DivInteger32 				; divide
.019354	a5 1a		lda $1a				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.019356	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019358	a5 1b		lda $1b				lda 	zLTemp1+1
.01935a	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01935c	a5 1c		lda $1c				lda 	zLTemp1+2
.01935e	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019360	a5 1d		lda $1d				lda 	zLTemp1+3
.019362	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019364	60		rts				rts
.019365					_UMParameter:
.019365	20 5d 90	jsr $01905d			jsr 	EvaluateIntegerX 			; get value
.019368	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; absolute value
.01936a	10 03		bpl $01936f			bpl 	_UMNotSigned
.01936c	20 e9 9b	jsr $019be9			jsr 	IntegerNegateAlways
.01936f					_UMNotSigned:
.01936f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.019370					Unary_Usr:
.019370	20 4f 90	jsr $01904f			jsr 	EvaluateNumberX 			; numeric parameter
.019373	20 83 96	jsr $019683			jsr 	CheckNextRParen 			; right bracket.
.019376	da		phx				phx 								; save XY
.019377	5a		phy				phy
.019378	ea		nop				nop
.019379	22 0c 03 00	jsl $00030c			jsl 	UserVector
.01937d	7a		ply				ply 								; and exit
.01937e	fa		plx				plx
.01937f	60		rts				rts
.019380					USRDefault:
.019380	20 57 85	jsr $018557			jsr ERR_Handler
>019383	4e 6f 20 55 53 52 20 76			.text "No USR vector.",0
>01938b	65 63 74 6f 72 2e 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.019392					Unary_Val:
.019392	20 66 90	jsr $019066			jsr 	EvaluateStringX 			; get string
.019395	20 83 96	jsr $019683			jsr 	CheckNextRParen 			; check right bracket.
.019398	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.01939a	85 1e		sta $1e				sta 	zGenPtr
.01939c	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01939e	85 1f		sta $1f				sta 	zGenPtr+1
.0193a0	5a		phy				phy
.0193a1	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.0193a3	b1 1e		lda ($1e),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.0193a5	f0 54		beq $0193fb			beq 	_UVBadNumber
.0193a7	48		pha				pha 								; save length.
.0193a8	1a		inc a				inc 	a 							; one for the length, one for the terminator
.0193a9	1a		inc a				inc 	a
.0193aa	20 c3 96	jsr $0196c3			jsr 	AllocateTempString
.0193ad	c8		iny				iny 								; move to the next.
.0193ae	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get character
.0193b0	49 2d		eor #$2d			eor 	#"-"						; zero if minus sign
.0193b2	8d a0 03	sta $03a0			sta 	ValSign
.0193b5	d0 04		bne $0193bb			bne 	_UVNotMinus
.0193b7	c8		iny				iny 								; skip over it.
.0193b8	68		pla				pla 								; decrement character count.
.0193b9	3a		dec a				dec 	a
.0193ba	48		pha				pha
.0193bb					_UVNotMinus:
.0193bb	68		pla				pla 								; this is the count.
.0193bc	48		pha		_UVCopy:pha									; copy into new temp string which is ASCIIZ
.0193bd	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.0193bf	c8		iny				iny
.0193c0	20 ee 96	jsr $0196ee			jsr 	WriteTempString
.0193c3	68		pla				pla
.0193c4	3a		dec a				dec 	a
.0193c5	d0 f5		bne $0193bc			bne 	_UVCopy
.0193c7	20 ee 96	jsr $0196ee			jsr 	WriteTempString 			; make it ASCIIZ
.0193ca	18		clc				clc
.0193cb	a5 20		lda $20				lda 	zTempStr 					; tempstring +1 => genptr
.0193cd	69 01		adc #$01			adc 	#1
.0193cf	85 1e		sta $1e				sta 	zGenPtr
.0193d1	a5 21		lda $21				lda 	zTempStr+1
.0193d3	69 00		adc #$00			adc 	#0
.0193d5	85 1f		sta $1f				sta 	zGenPtr+1
.0193d7	18		clc				clc
.0193d8	20 bb 9c	jsr $019cbb			jsr 	IntFromString 				; first bit.
.0193db	b0 1e		bcs $0193fb			bcs 	_UVBadNumber
.0193dd	20 39 a2	jsr $01a239			jsr 	FPFromString				; try for a float part.
.0193e0	ad a0 03	lda $03a0			lda 	ValSign 					; was it negative
.0193e3	d0 10		bne $0193f5			bne 	_UVNotNegative
.0193e5	b5 85		lda $85,x			lda 	XS_Type,x 					; check if integer
.0193e7	4a		lsr a				lsr 	a
.0193e8	b0 08		bcs $0193f2			bcs 	_UVInteger
.0193ea	b5 85		lda $85,x			lda 	XS_Type,x 					; set sign bit
.0193ec	09 80		ora #$80			ora 	#$80
.0193ee	95 85		sta $85,x			sta 	XS_Type,x
.0193f0	80 03		bra $0193f5			bra 	_UVNotNegative
.0193f2					_UVInteger:
.0193f2	20 e9 9b	jsr $019be9			jsr 	IntegerNegateAlways 		; sign it.
.0193f5					_UVNotNegative:
.0193f5	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; used everything
.0193f7	d0 02		bne $0193fb			bne 	_UVBadNumber
.0193f9	7a		ply				ply
.0193fa	60		rts				rts
.0193fb					_UVBadNumber:
.0193fb	4c 46 85	jmp $018546			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.0193fe					Unary_Str:
.0193fe	20 4f 90	jsr $01904f			jsr 	EvaluateNumberX 			; numeric parameter
.019401	20 83 96	jsr $019683			jsr 	CheckNextRParen 			; right bracket.
.019404	a9 00		lda #$00			lda 	#0 							; reset buffer index
.019406	8d 14 03	sta $0314			sta 	NumBufX
.019409	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.01940b	4a		lsr a				lsr 	a
.01940c	b0 05		bcs $019413			bcs 	_USInt 						; if msb set do as integer
.01940e	20 7e a1	jsr $01a17e			jsr 	FPToString 					; call fp to str otherwise
.019411	80 03		bra $019416			bra 	_USDuplicate
.019413	20 06 9c	jsr $019c06	_USInt:	jsr 	IntToString
.019416					_USDuplicate:
.019416	ad 14 03	lda $0314			lda 	NumBufX 					; chars in buffer
.019419	1a		inc a				inc 	a 							; one more for length
.01941a	20 c3 96	jsr $0196c3			jsr 	AllocateTempString 			; allocate space for it.
.01941d	5a		phy				phy 								; save Y
.01941e	a0 00		ldy #$00			ldy 	#0 							; start copying
.019420	b9 15 03	lda $0315,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.019423	20 ee 96	jsr $0196ee			jsr 	WriteTempString
.019426	c8		iny				iny
.019427	cc 14 03	cpy $0314			cpy 	NumBufX 					; done the lot
.01942a	d0 f4		bne $019420			bne 	_USCopy
.01942c	7a		ply				ply 								; restore Y
.01942d	4c f8 95	jmp $0195f8			jmp 	UnaryReturnTempStr 			; return new temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.019430					Unary_Asc:
.019430	20 66 90	jsr $019066			jsr 	EvaluateStringX 			; string parameter
.019433	20 83 96	jsr $019683			jsr 	CheckNextRParen 			; right bracket.
.019436	5a		phy				phy 								; get the string length
.019437	a0 00		ldy #$00			ldy 	#0
.019439	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.01943b	f0 07		beq $019444			beq 	_UAIllegal 					; must be at least one character
.01943d	c8		iny				iny
.01943e	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; read it.
.019440	7a		ply				ply
.019441	4c be 92	jmp $0192be			jmp 	UnarySetAInteger
.019444					_UAIllegal:
.019444	4c 46 85	jmp $018546			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.019447					Unary_Len:
.019447	20 66 90	jsr $019066			jsr 	EvaluateStringX 			; string parameter
.01944a	20 83 96	jsr $019683			jsr 	CheckNextRParen 			; right bracket.
.01944d	5a		phy				phy 								; get the string length
.01944e	a0 00		ldy #$00			ldy 	#0
.019450	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.019452	7a		ply				ply
.019453	4c be 92	jmp $0192be			jmp 	UnarySetAInteger

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.019456					Unary_Mid:
.019456	20 66 90	jsr $019066			jsr 	EvaluateStringX 				; get string.
.019459	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.01945b	48		pha				pha
.01945c	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01945e	48		pha				pha
.01945f	20 8b 96	jsr $01968b			jsr 	CheckNextComma 					; skip comma
.019462	20 eb 94	jsr $0194eb			jsr 	SLIByteParameter 				; get a byte parameter (start)
.019465	48		pha				pha 									; and push it.
.019466	20 8b 96	jsr $01968b			jsr 	CheckNextComma 					; skip comma
.019469	20 eb 94	jsr $0194eb			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.01946c	48		pha				pha 									; and push it.
.01946d	80 41		bra $0194b0			bra 	SLIProcess
.01946f					Unary_Left:
.01946f	20 66 90	jsr $019066			jsr 	EvaluateStringX 				; get string.
.019472	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.019474	48		pha				pha
.019475	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019477	48		pha				pha
.019478	a9 01		lda #$01			lda 	#1 								; push start position (1)
.01947a	48		pha				pha
.01947b	20 8b 96	jsr $01968b			jsr 	CheckNextComma 					; skip comma
.01947e	20 eb 94	jsr $0194eb			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.019481	48		pha				pha 									; and push it.
.019482	80 2c		bra $0194b0			bra 	SLIProcess
.019484					Unary_Right:
.019484	20 66 90	jsr $019066			jsr 	EvaluateStringX 				; get string.
.019487	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.019489	48		pha				pha
.01948a	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01948c	48		pha				pha
.01948d	da		phx				phx 									; get the string length and push on stack.
.01948e	a2 00		ldx #$00			ldx 	#0
.019490	a1 1e		lda ($1e,x)			lda		(zGenPtr,x)
.019492	fa		plx				plx
.019493	48		pha				pha
.019494	20 8b 96	jsr $01968b			jsr 	CheckNextComma 					; skip comma
.019497	20 eb 94	jsr $0194eb			jsr 	SLIByteParameter 				; get a byte parameter.
.01949a	8d 9e 03	sta $039e			sta 	SignCount 						; save in temporary.
.01949d	68		pla				pla 									; restore string length.
.01949e	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.01949f	38		sec				sec
.0194a0	ed 9e 03	sbc $039e			sbc 	SignCount 						; subtract characters needed, gives start position.
.0194a3	f0 02		beq $0194a7			beq 	_URStart 						; if <= 0 start from 1.
.0194a5	10 02		bpl $0194a9			bpl 	_UROkay
.0194a7					_URStart:
.0194a7	a9 01		lda #$01			lda 	#1
.0194a9					_UROkay:
.0194a9	48		pha				pha 									; push start
.0194aa	ad 9e 03	lda $039e			lda 	SignCount 						; push count of characters
.0194ad	48		pha				pha
.0194ae	80 00		bra $0194b0			bra 	SLIProcess
.0194b0					SLIProcess:
.0194b0	20 83 96	jsr $019683			jsr 	CheckNextRParen 				; closing right bracket.
.0194b3	68		pla				pla
.0194b4	8d a2 03	sta $03a2			sta 	SliceCount 						; count in signcount
.0194b7	1a		inc a				inc 	a 								; allocate +1 for it.
.0194b8	20 c3 96	jsr $0196c3			jsr 	AllocateTempString
.0194bb	68		pla				pla 									; pop start number off stack.
.0194bc	f0 3b		beq $0194f9			beq 	SLIError 						; exit if start = 0
.0194be	8d a1 03	sta $03a1			sta 	SliceStart
.0194c1	68		pla				pla  									; pop string address.
.0194c2	85 1f		sta $1f				sta 	zGenPtr+1
.0194c4	68		pla				pla
.0194c5	85 1e		sta $1e				sta 	zGenPtr
.0194c7	da		phx				phx
.0194c8	5a		phy				phy
.0194c9	a2 00		ldx #$00			ldx 	#0 								; point to string length.
.0194cb	ac a1 03	ldy $03a1			ldy 	SliceStart 						; start of the string (+1 for count)
.0194ce					_SLICopy:
.0194ce	ad a2 03	lda $03a2			lda 	SliceCount 						; done count characters
.0194d1	f0 12		beq $0194e5			beq 	_SLIExit
.0194d3	ce a2 03	dec $03a2			dec 	SliceCount
.0194d6	98		tya				tya 									; index of character
.0194d7	c1 1e		cmp ($1e,x)			cmp 	(zGenPtr,x)						; compare against length
.0194d9	f0 02		beq $0194dd			beq 	_SLIOk 							; if equal, okay.
.0194db	b0 08		bcs $0194e5			bcs 	_SLIExit 						; if past end, then exit.
.0194dd	b1 1e		lda ($1e),y	_SLIOk:	lda 	(zGenPtr),y 					; copy one character
.0194df	c8		iny				iny
.0194e0	20 ee 96	jsr $0196ee			jsr 	WriteTempString
.0194e3	80 e9		bra $0194ce			bra 	_SLICopy 						; go round till copied characters
.0194e5					_SLIExit:
.0194e5	7a		ply				ply 									; restore YX
.0194e6	fa		plx				plx
.0194e7	4c f8 95	jmp $0195f8			jmp 	UnaryReturnTempStr 				; return new temporary string.
.0194ea	ea		nop				nop
.0194eb					SLIByteParameter:
.0194eb	20 5d 90	jsr $01905d			jsr 	EvaluateIntegerX 				; get integer
.0194ee	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.0194f0	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.0194f2	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.0194f4	d0 03		bne $0194f9			bne 	SLIError
.0194f6	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0194f8	60		rts				rts
.0194f9					SLIError:
.0194f9	4c 46 85	jmp $018546			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.0194fc					Unary_Hex:
.0194fc	20 5d 90	jsr $01905d			jsr 	EvaluateIntegerX 			; numeric parameter
.0194ff	20 83 96	jsr $019683			jsr 	CheckNextRParen 			; right bracket.
.019502	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.019504	20 c3 96	jsr $0196c3			jsr 	AllocateTempString			; allocate string space
.019507	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.019509	20 2d 95	jsr $01952d			jsr 	_UHConvert
.01950c	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01950e	20 2d 95	jsr $01952d			jsr 	_UHConvert
.019511	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019513	20 2d 95	jsr $01952d			jsr 	_UHConvert
.019516	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019518	20 2d 95	jsr $01952d			jsr 	_UHConvert
.01951b	5a		phy				phy 								; get length of new string
.01951c	a0 00		ldy #$00			ldy 	#0
.01951e	b1 20		lda ($20),y			lda 	(zTempStr),y
.019520	7a		ply				ply
.019521	c9 00		cmp #$00			cmp 	#0
.019523	d0 05		bne $01952a			bne 	_UHExit 					; if it was non zero okay
.019525	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.019527	20 ee 96	jsr $0196ee			jsr 	WriteTempString
.01952a					_UHExit:
.01952a	4c f8 95	jmp $0195f8			jmp 	UnaryReturnTempStr 			; return new temporary string.
.01952d					_UHConvert:
.01952d	48		pha				pha
.01952e	4a		lsr a				lsr 	a 							; do MSB
.01952f	4a		lsr a				lsr 	a
.019530	4a		lsr a				lsr 	a
.019531	4a		lsr a				lsr 	a
.019532	20 36 95	jsr $019536			jsr 	_UHNibble
.019535	68		pla				pla 								; do LSB
.019536					_UHNibble:
.019536	29 0f		and #$0f			and 	#15 						; get nibble
.019538	d0 0c		bne $019546			bne 	_UHNonZero
.01953a	5a		phy				phy									; get the length
.01953b	a0 00		ldy #$00			ldy 	#0
.01953d	b1 20		lda ($20),y			lda 	(zTempStr),y
.01953f	7a		ply				ply
.019540	c9 00		cmp #$00			cmp 	#0 							; suppress leading zeros.
.019542	f0 0d		beq $019551			beq 	_UHExit2
.019544	a9 00		lda #$00			lda 	#0
.019546					_UHNonZero:
.019546	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.019548	90 02		bcc $01954c			bcc 	_UHDigit
.01954a	69 06		adc #$06			adc 	#7-1
.01954c					_UHDigit:
.01954c	69 30		adc #$30			adc 	#48
.01954e	20 ee 96	jsr $0196ee			jsr 	WriteTempString				; output.
.019551					_UHExit2:
.019551	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.019552					Unary_Dec:
.019552	20 66 90	jsr $019066			jsr 	EvaluateStringX 			; string parameter
.019555	20 83 96	jsr $019683			jsr 	CheckNextRParen 			; right bracket.
.019558	5a		phy				phy
.019559	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.01955b	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.01955d	f0 41		beq $0195a0			beq 	_UDFail 					; must fail if zero.
.01955f	8d 9e 03	sta $039e			sta 	SignCount 					; use SignCount as a counter
.019562	a9 00		lda #$00			lda 	#0 							; set result to zero integer.
.019564	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019566	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019568	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01956a	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01956c	a9 01		lda #$01			lda 	#1
.01956e	95 85		sta $85,x			sta 	XS_Type,x
.019570					_UDConvertLoop:
.019570	5a		phy				phy 								; shift mantissa left 4
.019571	a0 04		ldy #$04			ldy 	#4
.019573					_UDShift:
.019573	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.019575	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.019577	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.019579	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.01957b	88		dey				dey
.01957c	d0 f5		bne $019573			bne 	_UDShift
.01957e	7a		ply				ply
.01957f	c8		iny				iny 								; next character
.019580	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; fetch it.
.019582	20 a3 95	jsr $0195a3			jsr 	ConvertUpper 				; convert to U/C
.019585	c9 30		cmp #$30			cmp 	#"0"
.019587	90 17		bcc $0195a0			bcc 	_UDFail
.019589	c9 3a		cmp #$3a			cmp 	#"9"+1
.01958b	90 06		bcc $019593			bcc 	_UDOkay
.01958d	e9 37		sbc #$37			sbc 	#7+"0" 						; alpha fudge
.01958f	c9 10		cmp #$10			cmp 	#16
.019591	b0 0d		bcs $0195a0			bcs 	_UDFail
.019593					_UDOkay:
.019593	29 0f		and #$0f			and 	#15 						; nibble only
.019595	15 80		ora $80,x			ora 	XS_Mantissa+0,x
.019597	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019599	ce 9e 03	dec $039e			dec 	SignCount 					; do it for each character
.01959c	d0 d2		bne $019570			bne 	_UDConvertLoop
.01959e	7a		ply				ply
.01959f	60		rts				rts
.0195a0					_UDFail:
.0195a0	4c 46 85	jmp $018546			jmp 	BadParamError
.0195a3					ConvertUpper:
.0195a3	c9 61		cmp #$61			cmp 	#"a"
.0195a5	90 07		bcc $0195ae			bcc 	_CUExit
.0195a7	c9 7b		cmp #$7b			cmp 	#"z"+1
.0195a9	b0 03		bcs $0195ae			bcs 	_CUExit
.0195ab	38		sec				sec
.0195ac	e9 20		sbc #$20			sbc 	#32
.0195ae	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.0195af					Unary_Chr:
.0195af	20 5d 90	jsr $01905d			jsr 	EvaluateIntegerX			; numeric parameter
.0195b2	20 83 96	jsr $019683			jsr 	CheckNextRParen 			; right bracket.
.0195b5	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.0195b7	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.0195b9	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.0195bb	d0 0d		bne $0195ca			bne 	_UCChar
.0195bd	a9 01		lda #$01			lda 	#1 							; one character string
.0195bf	20 c3 96	jsr $0196c3			jsr 	AllocateTempString
.0195c2	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.0195c4	20 ee 96	jsr $0196ee			jsr 	WriteTempString
.0195c7	4c f8 95	jmp $0195f8			jmp 	UnaryReturnTempStr
.0195ca					_UCChar:
.0195ca	4c 46 85	jmp $018546			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.0195cd					Unary_Spc:
.0195cd	20 5d 90	jsr $01905d			jsr 	EvaluateIntegerX 			; numeric parameter
.0195d0	20 83 96	jsr $019683			jsr 	CheckNextRParen 			; right bracket.
.0195d3	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.0195d5	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.0195d7	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.0195d9	d0 1a		bne $0195f5			bne 	_USSize
.0195db	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0195dd	c9 fe		cmp #$fe			cmp 	#maxString+1
.0195df	b0 14		bcs $0195f5			bcs 	_USSize
.0195e1	48		pha				pha 								; save length
.0195e2	1a		inc a				inc 	a 							; allocate one more.
.0195e3	20 c3 96	jsr $0196c3			jsr 	AllocateTempString
.0195e6	68		pla				pla 								; get length
.0195e7	f0 0f		beq $0195f8			beq 	UnaryReturnTempStr 			; return the current temp string
.0195e9					_USLoop:
.0195e9	48		pha				pha
.0195ea	a9 20		lda #$20			lda 	#" "
.0195ec	20 ee 96	jsr $0196ee			jsr 	WriteTempString
.0195ef	68		pla				pla
.0195f0	3a		dec a				dec 	a
.0195f1	d0 f6		bne $0195e9			bne 	_USLoop
.0195f3	80 03		bra $0195f8			bra 	UnaryReturnTempStr
.0195f5					_USSize:
.0195f5	4c 46 85	jmp $018546			jmp 	BadParamError
.0195f8					UnaryReturnTempStr:
.0195f8	a5 20		lda $20				lda 	zTempStr 					; copy temp string addr -> mantissa
.0195fa	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0195fc	a5 21		lda $21				lda 	zTempStr+1
.0195fe	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019600	a9 02		lda #$02			lda 	#2 							; set type to string
.019602	95 85		sta $85,x			sta 	XS_Type,x
.019604	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/65816.asm

.019605					MemRead:
.019605	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.019608	a0 00		ldy #$00			ldy 	#0 							; start from here
.01960a	b7 1a		lda [$1a],y	_MLoop1:lda 	[zlTemp1],y 				; read the long address
.01960c	95 80		sta $80,x			sta 	XS_Mantissa,x 				; copy into mantissa
.01960e	c8		iny				iny 								; next to copy
.01960f	e8		inx				inx
.019610	cc 9e 03	cpy $039e			cpy 	SignCount 					; do required # of bytes.
.019613	d0 f5		bne $01960a			bne 	_MLoop1
.019615	60		rts				rts
.019616					MemWrite:
.019616	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.019619	a0 00		ldy #$00			ldy 	#0 							; start from here
.01961b	b5 80		lda $80,x	_MLoop1:lda 	XS_Mantissa,x 				; read mantisssa
.01961d	97 1a		sta [$1a],y			sta 	[zlTemp1],y 				; write it out
.01961f	c8		iny				iny 								; next to copy
.019620	e8		inx				inx
.019621	cc 9e 03	cpy $039e			cpy 	SignCount 					; do required # of bytes.
.019624	d0 f5		bne $01961b			bne 	_MLoop1
.019626	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/programend.asm

.019627					UpdateProgramEnd:
.019627	a9 00		lda #$00			lda 	#BasicProgram & $FF
.019629	85 16		sta $16				sta 	zCodePtr+0
.01962b	a9 10		lda #$10			lda 	#BasicProgram >> 8
.01962d	85 17		sta $17				sta 	zCodePtr+1
.01962f	a9 00		lda #$00			lda 	#0
.019631	85 18		sta $18				sta 	zCodePtr+2
.019633	85 19		sta $19				sta 	zCodePtr+3
.019635	a0 03		ldy #$03			ldy 	#3
.019637					_UPDLoop:
.019637	a0 00		ldy #$00			ldy 	#0
.019639	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01963b	c9 00		cmp #$00			cmp 	#0 							; end if offset is zero.
.01963d	f0 0f		beq $01964e			beq 	_UPDFoundEnd
.01963f	a0 00		ldy #$00			ldy 	#0 							; point to offset
.019641	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.019643	18		clc				clc
.019644	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.019646	85 16		sta $16				sta 	zCodePtr
.019648	90 02		bcc $01964c			bcc 	_SNLNoCarry
.01964a	e6 17		inc $17				inc 	zCodePtr+1
.01964c					_SNLNoCarry:
.01964c	80 e9		bra $019637			bra 	_UPDLoop
.01964e					_UPDFoundEnd:
.01964e	18		clc				clc 								; end of program 2 on.
.01964f	a5 16		lda $16				lda 	zCodePtr
.019651	69 02		adc #$02			adc 	#2
.019653	8d 04 03	sta $0304			sta 	endOfProgram
.019656	a5 17		lda $17				lda 	zCodePtr+1
.019658	69 00		adc #$00			adc 	#0
.01965a	8d 05 03	sta $0305			sta 	endOfProgram+1
.01965d	a5 18		lda $18				lda 	zCodePtr+2
.01965f	69 00		adc #$00			adc		#0
.019661	8d 06 03	sta $0306			sta 	endOfProgram+2
.019664	a5 19		lda $19				lda 	zCodePtr+3
.019666	69 00		adc #$00			adc 	#0
.019668	8d 07 03	sta $0307			sta 	endOfProgram+3
.01966b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.01966c					CheckNextToken:
.01966c	d7 16		cmp [$16],y			cmp 	[zCodePtr],y
.01966e	d0 02		bne $019672			bne 	CTFail 						; no, then fail
.019670	c8		iny				iny
.019671	60		rts				rts
.019672					CTFail:
.019672	20 57 85	jsr $018557			jsr ERR_Handler
>019675	4d 69 73 73 69 6e 67 20			.text "Missing token",0
>01967d	74 6f 6b 65 6e 00
.019683					CheckNextRParen:
.019683	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019685	c9 be		cmp #$be			cmp 	#token_rparen
.019687	d0 e9		bne $019672			bne 	CTFail
.019689	c8		iny				iny
.01968a	60		rts				rts
.01968b					CheckNextComma:
.01968b	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01968d	c9 bf		cmp #$bf			cmp 	#token_comma
.01968f	d0 e1		bne $019672			bne 	CTFail
.019691	c8		iny				iny
.019692	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/concrete.asm

.019693					StringConcrete:
.019693	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; save source to zTemp1
.019695	85 10		sta $10				sta 	zTemp1
.019697	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019699	85 11		sta $11				sta 	zTemp1+1
.01969b	a0 00		ldy #$00			ldy 	#0 							; subtract the length+1 (clc) of the string.
.01969d	18		clc				clc 								; from the string pointer
.01969e	ad 00 03	lda $0300			lda 	StringPtr 					; and put in zTemp2 as well
.0196a1	f1 10		sbc ($10),y			sbc 	(zTemp1),y
.0196a3	8d 00 03	sta $0300			sta 	StringPtr
.0196a6	85 12		sta $12				sta 	zTemp2
.0196a8	ad 01 03	lda $0301			lda 	StringPtr+1
.0196ab	e9 00		sbc #$00			sbc 	#0
.0196ad	8d 01 03	sta $0301			sta 	StringPtr+1
.0196b0	85 13		sta $13				sta 	zTemp2+1
.0196b2	b1 10		lda ($10),y			lda 	(zTemp1),y 					; length add one for count
.0196b4	1a		inc a				inc 	a
.0196b5	aa		tax				tax
.0196b6	b1 10		lda ($10),y	_SCCopy:lda 	(zTemp1),y 					; copy whole thing including length
.0196b8	91 12		sta ($12),y			sta 	(zTemp2),y
.0196ba	c8		iny				iny
.0196bb	ca		dex				dex
.0196bc	d0 f8		bne $0196b6			bne 	_SCCopy
.0196be	a5 13		lda $13				lda 	zTemp2+1 					; return concrete string in AX
.0196c0	a6 12		ldx $12				ldx 	zTemp2
.0196c2	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.0196c3					AllocateTempString:
.0196c3	48		pha				pha 								; save required count.
.0196c4	a5 21		lda $21				lda 	zTempStr+1 					; check if initialised yet ?
.0196c6	d0 0b		bne $0196d3			bne 	_ATSInitialised
.0196c8	ad 00 03	lda $0300			lda 	StringPtr 					; set temporary string ptr 1 page below available
.0196cb	85 20		sta $20				sta 	zTempStr					; space, this is for strings to be concreted.
.0196cd	ad 01 03	lda $0301			lda 	StringPtr+1
.0196d0	3a		dec a				dec 	a
.0196d1	85 21		sta $21				sta 	zTempStr+1
.0196d3					_ATSInitialised:
.0196d3	68		pla				pla 								; get required count back.
.0196d4	49 ff		eor #$ff			eor 	#$FF 						; negate 2's complement.
.0196d6	1a		inc a				inc 	a
.0196d7	18		clc				clc
.0196d8	65 20		adc $20				adc 	zTempStr 					; "add" to the temp string pointer
.0196da	85 20		sta $20				sta 	zTempStr
.0196dc	a9 ff		lda #$ff			lda 	#$FF
.0196de	65 21		adc $21				adc 	zTempStr+1
.0196e0	85 21		sta $21				sta 	zTempStr+1
.0196e2	a9 00		lda #$00			lda 	#0 							; clear temp string.
.0196e4	5a		phy				phy
.0196e5	a8		tay				tay
.0196e6	91 20		sta ($20),y			sta 	(zTempStr),y
.0196e8	7a		ply				ply
.0196e9	1a		inc a				inc 	a 							; reset the write index.
.0196ea	8d 9f 03	sta $039f			sta 	TempStringWriteIndex
.0196ed	60		rts				rts
.0196ee					WriteTempString:
.0196ee	5a		phy				phy 								; save Y
.0196ef	ac 9f 03	ldy $039f			ldy 	TempStringWriteIndex	 	; write position.
.0196f2	91 20		sta ($20),y			sta 	(zTempStr),y 				; write character out.
.0196f4	ee 9f 03	inc $039f			inc 	TempStringWriteIndex 		; increment the write position.
.0196f7	98		tya				tya 								; unchanged Y is now length
.0196f8	a0 00		ldy #$00			ldy 	#0
.0196fa	91 20		sta ($20),y			sta 	(zTempStr),y
.0196fc	7a		ply				ply 								; restore Y and exit
.0196fd	60		rts				rts
.0196fe					CreateTempStringCopy:
.0196fe	da		phx				phx 								; save X
.0196ff	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019701	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.019702	20 c3 96	jsr $0196c3			jsr 	AllocateTempString 			; allocate memory for temporary string.
.019705	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019707	c8		iny				iny
.019708	3a		dec a				dec 	a 							; make the actual length in charactes
.019709	3a		dec a				dec 	a
.01970a	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.01970c	81 20		sta ($20,x)			sta 	(zTempStr,x)
.01970e	85 1a		sta $1a				sta 	zLTemp1 					; that's used as a count.
.019710	09 00		ora #$00			ora 	#0 							; if zero already, exit
.019712	f0 0e		beq $019722			beq 	_CTSCExit
.019714					_CTSCLoop:
.019714	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019716	c8		iny				iny
.019717	5a		phy				phy 								; save in Y
.019718	e8		inx				inx 								; bump index
.019719	da		phx				phx 								; index into Y
.01971a	7a		ply				ply
.01971b	91 20		sta ($20),y			sta 	(zTempStr),y 				; save at index
.01971d	7a		ply				ply 								; restore Y
.01971e	c6 1a		dec $1a				dec 	zLTemp1 					; do for each character
.019720	d0 f2		bne $019714			bne 	_CTSCLoop
.019722					_CTSCExit:
.019722	fa		plx				plx 								; restore X
.019723	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/variables.asm

.019724					VariableFind:
.019724	20 8f 97	jsr $01978f			jsr 	VariableExtract 		; find out all about it ....
.019727	20 28 9a	jsr $019a28			jsr 	VariableLocate 			; does it already exist ?
.01972a	b0 03		bcs $01972f			bcs 	_VFExists 				; if so, use that.
.01972c	20 1b 98	jsr $01981b			jsr 	VariableCreate 			; otherwise create it.
.01972f					_VFExists:
.01972f	a5 24		lda $24				lda 	zVarType 				; is it still an array ?
.019731	29 01		and #$01			and 	#1
.019733	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.019735	d0 28		bne $01975f			bne 	_VFSingleElement
.019737					_VFNextIndex:
.019737	a5 22		lda $22				lda 	zVarDataPtr 			; push the data ptr and type on the stack.
.019739	48		pha				pha
.01973a	a5 23		lda $23				lda 	zVarDataPtr+1
.01973c	48		pha				pha
.01973d	a5 24		lda $24				lda 	zVarType
.01973f	48		pha				pha
.019740	20 5d 90	jsr $01905d			jsr 	EvaluateIntegerX 		; calculate the index.
.019743	68		pla				pla 							; restore and index.
.019744	85 24		sta $24				sta 	zVarType
.019746	68		pla				pla
.019747	85 23		sta $23				sta 	zVarDataPtr+1
.019749	68		pla				pla
.01974a	85 22		sta $22				sta 	zVarDataPtr
.01974c	20 a6 98	jsr $0198a6			jsr 	ArrayIndexFollow 		; do the index.
.01974f	a5 24		lda $24				lda 	zVarType 				; is it still an array ??
.019751	29 01		and #$01			and 	#1
.019753	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.019755	d0 05		bne $01975c			bne 	_VFArrayDone 			; if so then exit.
.019757	20 8b 96	jsr $01968b			jsr 	CheckNextComma 			; comma should follow
.01975a	80 db		bra $019737			bra 	_VFNextIndex
.01975c					_VFArrayDone:
.01975c	20 83 96	jsr $019683			jsr 	CheckNextRParen 		; check closing right bracket.
.01975f					_VFSingleElement:
.01975f	60		rts				rts
.019760					VariableClear:
.019760	48		pha				pha 							; save registers
.019761	da		phx				phx
.019762	a2 00		ldx #$00			ldx 	#0 						; clear out the hash table.
.019764	8a		txa				txa
.019765	9d 35 03	sta $0335,x	_VCLoop:sta 	HashTableBase,x
.019768	e8		inx				inx
.019769	e0 60		cpx #$60			cpx 	#HashTableEnd-HashTableBase
.01976b	d0 f8		bne $019765			bne 	_VCLoop
.01976d	a9 00		lda #$00			lda 	#VariableMemory & $FF
.01976f	8d 02 03	sta $0302			sta 	VarMemPtr
.019772	a9 30		lda #$30			lda 	#VariableMemory >> 8
.019774	8d 03 03	sta $0303			sta 	VarMemPtr+1
.019777	fa		plx				plx 							; restore registers
.019778	68		pla				pla
.019779	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/extract.asm

.01977a					VariableNameError:
.01977a	20 57 85	jsr $018557			jsr ERR_Handler
>01977d	42 61 64 20 56 61 72 69			.text "Bad Variable Name",0
>019785	61 62 6c 65 20 4e 61 6d 65 00
.01978f					VariableExtract:
.01978f	da		phx				phx 							; save X.
.019790	a9 ba		lda #$ba			lda 	#token_hashlParen  		; set the type to #( e.g. real array.
.019792	8d 95 03	sta $0395			sta 	Var_Type
.019795	8d 96 03	sta $0396			sta 	Var_Hash 				; we initialise the hash with this. It doesn't matter
.019798	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01979a	c9 00		cmp #$00			cmp 	#0 						; first one must be A-Z
.01979c	f0 dc		beq $01977a			beq 	VariableNameError
.01979e	c9 1b		cmp #$1b			cmp 	#26+1
.0197a0	b0 d8		bcs $01977a			bcs 	VariableNameError
.0197a2	a2 ff		ldx #$ff			ldx 	#255 					; now copy it into the variable buffer.
.0197a4					_VECopyBuffer:
.0197a4	e8		inx				inx
.0197a5	e0 1f		cpx #$1f			cpx 	#31 					; too long
.0197a7	f0 d1		beq $01977a			beq 	VariableNameError
.0197a9	9d 15 03	sta $0315,x			sta 	Var_Buffer,x 			; save character
.0197ac	18		clc				clc  							; update the hash value for it.
.0197ad	6d 96 03	adc $0396			adc 	Var_Hash
.0197b0	8d 96 03	sta $0396			sta 	Var_Hash
.0197b3	c8		iny				iny
.0197b4	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0197b6	c9 00		cmp #$00			cmp 	#0 						; zero or token, end of variable
.0197b8	f0 0e		beq $0197c8			beq 	_VECopyEnd
.0197ba	30 0c		bmi $0197c8			bmi 	_VECopyEnd
.0197bc	c9 1b		cmp #$1b			cmp 	#26+1 					; A-Z continue copying
.0197be	90 e4		bcc $0197a4			bcc 	_VECopyBuffer
.0197c0	c9 30		cmp #$30			cmp 	#"0" 					; 0-9 copy as well.
.0197c2	90 04		bcc $0197c8			bcc 	_VECopyEnd
.0197c4	c9 3a		cmp #$3a			cmp 	#"9"+1
.0197c6	90 dc		bcc $0197a4			bcc 	_VECopyBuffer
.0197c8					_VECopyEnd:
.0197c8	c8		iny				iny
.0197c9	c9 b7		cmp #$b7			cmp 	#token_Dollar 			; first type token.
.0197cb	90 04		bcc $0197d1			bcc 	_VEDefaultRequired
.0197cd	c9 bd		cmp #$bd			cmp 	#token_PercentLParen+1	; last type token.
.0197cf	90 0b		bcc $0197dc			bcc 	_VEHaveType
.0197d1					_VEDefaultRequired:
.0197d1	c9 bd		cmp #$bd			cmp 	#token_LParen 			; if it ends in ( then use the real array
.0197d3	f0 04		beq $0197d9			beq 	_VESetType 				; default set above.
.0197d5	ce 95 03	dec $0395			dec 	Var_Type 				; this changes that default to the variable default
.0197d8	88		dey				dey
.0197d9					_VESetType:
.0197d9	ad 95 03	lda $0395			lda 	Var_Type 				; get type ....
.0197dc					_VEHaveType:
.0197dc	8d 95 03	sta $0395			sta 	Var_Type 				; save as type.
.0197df	bd 15 03	lda $0315,x			lda 	Var_Buffer,x 			; set bit 7 of name, marks the end.
.0197e2	09 80		ora #$80			ora 	#$80
.0197e4	9d 15 03	sta $0315,x			sta 	Var_Buffer,x
.0197e7	e8		inx				inx 							; offset 3 => length 4.
.0197e8	8e 97 03	stx $0397			stx 	Var_Length 				; save length of variable name.
.0197eb	ad 95 03	lda $0395			lda 	Var_Type 				; get offset of var type from first type token
.0197ee	38		sec				sec
.0197ef	e9 b7		sbc #$b7			sbc 	#token_Dollar
.0197f1	0a		asl a				asl 	a 						; multiply by 16. This requires HashTableSize
.0197f2	0a		asl a				asl 	a 						; in data.asm to be 8 (8 sets of links,2 bytes each)
.0197f3	0a		asl a				asl 	a
.0197f4	0a		asl a				asl 	a
.0197f5	8d 98 03	sta $0398			sta 	Var_HashAddress
.0197f8	ad 96 03	lda $0396			lda 	Var_Hash 				; get the hash
.0197fb	29 07		and #$07			and 	#(HashTableSize-1) 		; force into range 0-tableSize-1
.0197fd	0a		asl a				asl 	a 						; double it (2 bytes per entry) & clears carry
.0197fe	6d 98 03	adc $0398			adc 	Var_HashAddress 		; add table offset.
.019801	69 35		adc #$35			adc 	#HashTableBase & $FF 	; now the low byte of the actual table address
.019803	8d 98 03	sta $0398			sta 	Var_HashAddress
.019806	a2 05		ldx #$05			ldx 	#5 						; hash is 5 bytes (real)
.019808	ad 95 03	lda $0395			lda 	Var_Type
.01980b	c9 b9		cmp #$b9			cmp 	#token_Hash
.01980d	f0 07		beq $019816			beq 	_VEHaveSize
.01980f	ca		dex				dex
.019810	c9 bb		cmp #$bb			cmp 	#token_Percent 			; percent is 4 bytes (integer)
.019812	f0 02		beq $019816			beq 	_VEHaveSize
.019814	a2 02		ldx #$02			ldx 	#2 						; everything else is two.
.019816					_VEHaveSize:
.019816	8e 99 03	stx $0399			stx 	Var_DataSize
.019819	fa		plx				plx
.01981a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varcreate.asm

.01981b					VariableCreate:
.01981b	da		phx				phx
.01981c	5a		phy				phy
.01981d	ad 02 03	lda $0302			lda 	VarMemPtr 					; get address of next free into zTemp1
.019820	85 10		sta $10				sta 	zTemp1
.019822	ad 03 03	lda $0303			lda 	VarMemPtr+1
.019825	85 11		sta $11				sta 	zTemp1+1
.019827	ad 99 03	lda $0399			lda 	Var_DataSize 				; bytes for the data bit
.01982a	18		clc				clc
.01982b	6d 97 03	adc $0397			adc 	Var_Length 					; add the length of the name
.01982e	69 03		adc #$03			adc 	#3 							; 3 for the link and the hash.
.019830	6d 02 03	adc $0302			adc 	VarMemPtr 					; add to variable memory pointer
.019833	8d 02 03	sta $0302			sta 	VarMemPtr
.019836	90 03		bcc $01983b			bcc 	_VCNoCarry
.019838	ee 03 03	inc $0303			inc 	VarMemPtr+1
.01983b					_VCNoCarry:
.01983b	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.01983e	85 12		sta $12				sta 	zTemp2
.019840	a9 03		lda #$03			lda 	#HashTableBase >> 8
.019842	85 13		sta $13				sta 	zTemp2+1
.019844	a0 00		ldy #$00			ldy 	#0 							; put current hash link in position.
.019846	b1 12		lda ($12),y			lda 	(zTemp2),y
.019848	91 10		sta ($10),y			sta 	(zTemp1),y
.01984a	c8		iny				iny
.01984b	b1 12		lda ($12),y			lda 	(zTemp2),y
.01984d	91 10		sta ($10),y			sta 	(zTemp1),y
.01984f	c8		iny				iny
.019850	ad 96 03	lda $0396			lda 	Var_Hash 					; write the hash out.
.019853	91 10		sta ($10),y			sta 	(zTemp1),y
.019855	c8		iny				iny
.019856	a2 00		ldx #$00			ldx 	#0 							; copy the name out.
.019858					_VCCopyName:
.019858	bd 15 03	lda $0315,x			lda 	Var_Buffer,x
.01985b	91 10		sta ($10),y			sta 	(zTemp1),y
.01985d	e8		inx				inx
.01985e	c8		iny				iny
.01985f	ec 97 03	cpx $0397			cpx 	Var_Length
.019862	d0 f4		bne $019858			bne 	_VCCopyName
.019864	5a		phy				phy 								; save the data offset.
.019865	ae 99 03	ldx $0399			ldx 	Var_DataSize 				; and write the data out.
.019868	a9 00		lda #$00			lda 	#0 							; which is all zeroes.
.01986a					_VCClearData:
.01986a	91 10		sta ($10),y			sta 	(zTemp1),y
.01986c	c8		iny				iny
.01986d	ca		dex				dex
.01986e	d0 fa		bne $01986a			bne 	_VCClearData
.019870	68		pla				pla 								; offset to the data
.019871	18		clc				clc
.019872	65 10		adc $10				adc 	zTemp1 						; add to start and save as data pointer.
.019874	85 22		sta $22				sta 	zVarDataPtr
.019876	a5 11		lda $11				lda 	zTemp1+1
.019878	69 00		adc #$00			adc 	#0
.01987a	85 23		sta $23				sta 	zVarDataPtr+1
.01987c	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.01987f	85 24		sta $24				sta 	zVarType
.019881	a5 10		lda $10				lda 	zTemp1 						; fix hash link to point to new record
.019883	a0 00		ldy #$00			ldy 	#0
.019885	91 12		sta ($12),y			sta 	(zTemp2),y
.019887	c8		iny				iny
.019888	a5 11		lda $11				lda 	zTemp1+1
.01988a	91 12		sta ($12),y			sta 	(zTemp2),y
.01988c	ad 95 03	lda $0395			lda 	Var_Type 					; array ? if so create the empty one.
.01988f	29 01		and #$01			and 	#1
.019891	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.019893	d0 0e		bne $0198a3			bne 	_VCNotArray
.019895	a2 00		ldx #$00			ldx 	#0 							; call recursive array creator
.019897	20 3d 99	jsr $01993d			jsr 	ArrayCreate
.01989a	5a		phy				phy 								; save YA at zVarDataPtr
.01989b	a0 00		ldy #$00			ldy 	#0
.01989d	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.01989f	c8		iny				iny
.0198a0	68		pla				pla
.0198a1	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0198a3					_VCNotArray:
.0198a3	7a		ply				ply
.0198a4	fa		plx				plx
.0198a5	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arrayidx.asm

.0198a6					ArrayIndexFollow:
.0198a6	5a		phy				phy
.0198a7	a0 00		ldy #$00			ldy 	#0 							; make zVarDataPtr point to the array.
.0198a9	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; e.g. it points to itself.
.0198ab	48		pha				pha
.0198ac	c8		iny				iny
.0198ad	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.0198af	85 23		sta $23				sta 	zVarDataPtr+1
.0198b1	68		pla				pla
.0198b2	85 22		sta $22				sta 	zVarDataPtr
.0198b4	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; MSB of 16 bit integer and bytes 2&3
.0198b6	29 80		and #$80			and 	#$80 						; must be zero.
.0198b8	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.0198ba	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.0198bc	d0 59		bne $019917			bne 	_AIFError
.0198be	a0 00		ldy #$00			ldy 	#0 							; calculate size - current - 1
.0198c0	18		clc				clc
.0198c1	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.0198c3	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.0198c5	c8		iny				iny
.0198c6	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.0198c8	08		php				php 								; clear bit 7 retaining borrow.
.0198c9	29 7f		and #$7f			and 	#$7F
.0198cb	28		plp				plp
.0198cc	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.0198ce	90 47		bcc $019917			bcc 	_AIFError 					; eror if size-current < 0
.0198d0	b5 80		lda $80,x			lda  	XS_Mantissa+0,x 			; copy and double the index
.0198d2	0a		asl a				asl 	a 							; (e.g. index * 2)
.0198d3	85 10		sta $10				sta 	zTemp1
.0198d5	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0198d7	2a		rol a				rol 	a
.0198d8	85 11		sta $11				sta 	zTemp1+1
.0198da	a0 01		ldy #$01			ldy 	#1 							; is this a data entry.
.0198dc	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; if so, then type is unchanged, offset set
.0198de	30 1d		bmi $0198fd			bmi 	_AIFCalculate
.0198e0	c6 24		dec $24				dec 	zVarType 					; converts from an array to a type.
.0198e2	a5 24		lda $24				lda 	zVarType 					; check that type
.0198e4	c9 b7		cmp #$b7			cmp 	#token_Dollar 				; if string, use x 2
.0198e6	f0 15		beq $0198fd			beq 	_AIFCalculate
.0198e8	06 10		asl $10				asl 	zTemp1			 			; double the index
.0198ea	26 11		rol $11				rol 	zTemp1+1					; (e.g. index * 4)
.0198ec	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if integer, use x 4
.0198ee	f0 0d		beq $0198fd			beq 	_AIFCalculate
.0198f0	18		clc				clc 								; add the original mantissa in again
.0198f1	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; which makes it x5, for float.
.0198f3	65 10		adc $10				adc 	zTemp1
.0198f5	85 10		sta $10				sta 	zTemp1
.0198f7	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0198f9	65 11		adc $11				adc 	zTemp1+1
.0198fb	85 11		sta $11				sta 	zTemp1+1
.0198fd					_AIFCalculate:
.0198fd	18		clc				clc 								; add index x 2,4 or 5 to base
.0198fe	a5 22		lda $22				lda 	zVarDataPtr
.019900	65 10		adc $10				adc 	zTemp1
.019902	85 22		sta $22				sta 	zVarDataPtr
.019904	a5 23		lda $23				lda 	zVarDataPtr+1
.019906	65 11		adc $11				adc 	zTemp1+1
.019908	85 23		sta $23				sta 	zVarDataPtr+1
.01990a	18		clc				clc 								; add 2 more for the length prefix.
.01990b	a5 22		lda $22				lda 	zVarDataPtr
.01990d	69 02		adc #$02			adc 	#2
.01990f	85 22		sta $22				sta 	zVarDataPtr
.019911	90 02		bcc $019915			bcc 	_AIFNoBump
.019913	e6 23		inc $23				inc 	zVarDataPtr+1
.019915					_AIFNoBump:
.019915	7a		ply				ply
.019916	60		rts				rts
.019917					_AIFError:
.019917	20 57 85	jsr $018557			jsr ERR_Handler
>01991a	42 61 64 20 61 72 72 61			.text "Bad array index",0
>019922	79 20 69 6e 64 65 78 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arraydef.asm

.01992a					ArrayResetDefault:
.01992a	a9 0b		lda #$0b			lda 	#11 						; 0..10 one array
.01992c	8d a9 03	sta $03a9			sta 	ArrayDef+0
.01992f	a9 00		lda #$00			lda 	#0
.019931	8d aa 03	sta $03aa			sta 	ArrayDef+1
.019934	a9 ff		lda #$ff			lda 	#$FF
.019936	8d ab 03	sta $03ab			sta 	ArrayDef+2 					; $FFFF implies no second element.
.019939	8d ac 03	sta $03ac			sta 	ArrayDef+3					; (test bit 7 of 2nd byte)
.01993c	60		rts				rts
.01993d					ArrayCreate:
.01993d	bd a9 03	lda $03a9,x			lda 	ArrayDef+0,x 				; put size x 2 in zTemp1
.019940	0a		asl a				asl 	a
.019941	85 10		sta $10				sta 	zTemp1
.019943	bd aa 03	lda $03aa,x			lda 	ArrayDef+1,x
.019946	2a		rol a				rol 	a
.019947	85 11		sta $11				sta 	zTemp1+1
.019949	bd ac 03	lda $03ac,x			lda 	ArrayDef+3,x 				; if this is the last element it's array of ptrs.
.01994c	10 22		bpl $019970			bpl 	_ACSized 					; if not multiply size x 2 (str) 4 (int) 5 (real)
.01994e	ad 95 03	lda $0395			lda 	Var_Type 					; check the type
.019951	c9 b8		cmp #$b8			cmp 	#token_DollarLParen 		; also if it is an array of strings $(
.019953	f0 1b		beq $019970			beq 	_ACSized
.019955	06 10		asl $10				asl 	zTemp1 						; double again
.019957	26 11		rol $11				rol 	zTemp1+1
.019959	b0 6f		bcs $0199ca			bcs 	ArrayIndexError 			; too large.
.01995b	c9 bc		cmp #$bc			cmp 	#token_PercentLParen 		; if %( four bytes/entry is enough.
.01995d	f0 11		beq $019970			beq 	_ACSized
.01995f	18		clc				clc 								; add original value x 5 for reals.
.019960	a5 10		lda $10				lda 	zTemp1
.019962	7d a9 03	adc $03a9,x			adc 	ArrayDef+0,x
.019965	85 10		sta $10				sta 	zTemp1
.019967	a5 11		lda $11				lda 	zTemp1+1
.019969	7d aa 03	adc $03aa,x			adc 	ArrayDef+1,x
.01996c	85 11		sta $11				sta 	zTemp1+1
.01996e	b0 5a		bcs $0199ca			bcs 	ArrayIndexError
.019970					_ACSized:
.019970	18		clc				clc
.019971	a5 10		lda $10				lda 	zTemp1
.019973	69 02		adc #$02			adc 	#2
.019975	85 10		sta $10				sta 	zTemp1
.019977	90 04		bcc $01997d			bcc 	_ACNoBump
.019979	e6 10		inc $10				inc 	zTemp1
.01997b	f0 4d		beq $0199ca			beq 	ArrayIndexError
.01997d					_ACNoBump:
.01997d	18		clc				clc
.01997e	ad 02 03	lda $0302			lda 	VarMemPtr 					; add this allocated count to VarMemPtr
.019981	85 12		sta $12				sta 	zTemp2						; save start in zTemp2/zTemp3
.019983	85 14		sta $14				sta 	zTemp3
.019985	65 10		adc $10				adc 	zTemp1
.019987	8d 02 03	sta $0302			sta 	VarMemPtr
.01998a	ad 03 03	lda $0303			lda 	VarMemPtr+1
.01998d	85 13		sta $13				sta 	zTemp2+1
.01998f	85 15		sta $15				sta 	zTemp3+1
.019991	65 11		adc $11				adc 	zTemp1+1
.019993	8d 03 03	sta $0303			sta 	VarMemPtr+1
.019996	85 11		sta $11				sta 	zTemp1+1
.019998	b0 30		bcs $0199ca			bcs 	ArrayIndexError
.01999a	a0 00		ldy #$00			ldy 	#0							; write $00 out.
.01999c					_ACClear:
.01999c	98		tya				tya
.01999d	91 12		sta ($12),y			sta 	(zTemp2),y
.01999f	e6 12		inc $12				inc 	zTemp2
.0199a1	d0 02		bne $0199a5			bne 	_ACCBump
.0199a3	e6 13		inc $13				inc 	zTemp2+1
.0199a5					_ACCBump:
.0199a5	a5 12		lda $12				lda 	zTemp2
.0199a7	cd 02 03	cmp $0302			cmp 	VarMemPtr
.0199aa	d0 f0		bne $01999c			bne 	_ACClear
.0199ac	a5 13		lda $13				lda 	zTemp2+1
.0199ae	cd 03 03	cmp $0303			cmp 	VarMemPtr+1
.0199b1	d0 e9		bne $01999c			bne 	_ACClear
.0199b3	a0 00		ldy #$00			ldy 	#0
.0199b5	bd a9 03	lda $03a9,x			lda 	ArrayDef+0,x 				; copy the size into the start
.0199b8	91 14		sta ($14),y			sta 	(zTemp3),y
.0199ba	c8		iny				iny
.0199bb	bd aa 03	lda $03aa,x			lda 	ArrayDef+1,x
.0199be	91 14		sta ($14),y			sta 	(zTemp3),y
.0199c0	bd ac 03	lda $03ac,x			lda 	ArrayDef+3,x 				; have we reached the end
.0199c3	10 18		bpl $0199dd			bpl 	ACCFillRecursive
.0199c5	a4 15		ldy $15				ldy 	zTemp3+1 					; return address
.0199c7	a5 14		lda $14				lda 	zTemp3
.0199c9	60		rts				rts
.0199ca					ArrayIndexError:
.0199ca	20 57 85	jsr $018557			jsr ERR_Handler
>0199cd	42 61 64 20 61 72 72 61			.text "Bad array index",0
>0199d5	79 20 69 6e 64 65 78 00
.0199dd					ACCFillRecursive:
.0199dd	a9 ff		lda #$ff			lda 	#$FF 						; we mark the end, this is free space.
.0199df	a0 00		ldy #$00			ldy 	#0 							; this is overwritten by size of next allocated
.0199e1	91 12		sta ($12),y			sta 	(zTemp2),y 					; array, but we might change that.
.0199e3	c8		iny				iny
.0199e4	b1 14		lda ($14),y			lda 	(zTemp3),y 					; set bit 15 of the max index indicating
.0199e6	09 80		ora #$80			ora 	#$80 						; an array of pointers
.0199e8	91 14		sta ($14),y			sta 	(zTemp3),y
.0199ea	a5 14		lda $14				lda 	zTemp3 						; push the start on the stack
.0199ec	48		pha				pha
.0199ed	a5 15		lda $15				lda 	zTemp3+1
.0199ef	48		pha				pha
.0199f0					_ACCFillLoop:
.0199f0	18		clc				clc
.0199f1	a5 14		lda $14				lda 	zTemp3 						; and work forwards.
.0199f3	69 02		adc #$02			adc 	#2
.0199f5	85 14		sta $14				sta 	zTemp3
.0199f7	90 02		bcc $0199fb			bcc 	_ACCSkip2
.0199f9	e6 15		inc $15				inc 	zTemp3+1
.0199fb					_ACCSkip2:
.0199fb	a0 00		ldy #$00			ldy 	#0 							; reached the end ?
.0199fd	b1 14		lda ($14),y			lda 	(zTemp3),y					; (looking for FF marker, everything else 00)
.0199ff	c8		iny				iny
.019a00	11 14		ora ($14),y			ora 	(zTemp3),y
.019a02	d0 21		bne $019a25			bne 	_ACCExit
.019a04	a5 14		lda $14				lda 	zTemp3 						; push zTemp3
.019a06	48		pha				pha
.019a07	a5 15		lda $15				lda 	zTemp3+1
.019a09	48		pha				pha
.019a0a	e8		inx				inx
.019a0b	e8		inx				inx
.019a0c	20 3d 99	jsr $01993d			jsr 	ArrayCreate 				; create array recursively.
.019a0f	ca		dex				dex
.019a10	ca		dex				dex
.019a11	85 12		sta $12				sta 	zTemp2 						; save A
.019a13	68		pla				pla
.019a14	85 15		sta $15				sta 	zTemp3+1 					; restore zTemp3
.019a16	68		pla				pla
.019a17	85 14		sta $14				sta 	zTemp3
.019a19	98		tya				tya 								; write high bye from Y
.019a1a	a0 01		ldy #$01			ldy 	#1
.019a1c	91 14		sta ($14),y			sta 	(zTemp3),y
.019a1e	88		dey				dey 								; write low byte out.
.019a1f	a5 12		lda $12				lda 	zTemp2
.019a21	91 14		sta ($14),y			sta 	(zTemp3),y
.019a23	80 cb		bra $0199f0			bra 	_ACCFillLoop 				; and try again.
.019a25					_ACCExit:
.019a25	7a		ply				ply 								; restore the original address
.019a26	68		pla				pla
.019a27	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varfind.asm

.019a28					VariableLocate:
.019a28	da		phx				phx
.019a29	5a		phy				phy
.019a2a	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.019a2d	85 12		sta $12				sta 	zTemp2 						; points to first address.
.019a2f	a9 03		lda #$03			lda 	#HashTableBase >> 8
.019a31	85 13		sta $13				sta 	zTemp2+1
.019a33	a0 00		ldy #$00	_VLNext:ldy 	#0 							; get next link into AX
.019a35	b1 12		lda ($12),y			lda 	(zTemp2),y
.019a37	aa		tax				tax
.019a38	c8		iny				iny
.019a39	b1 12		lda ($12),y			lda 	(zTemp2),y
.019a3b	85 13		sta $13				sta 	zTemp2+1 					; save in zTemp
.019a3d	86 12		stx $12				stx 	zTemp2
.019a3f	05 12		ora $12				ora 	zTemp2 						; got zero
.019a41	18		clc				clc
.019a42	f0 25		beq $019a69			beq 	_VLExit 					; if so, then fail as end of chain.
.019a44	c8		iny				iny 								; point to hash (offset + 2)
.019a45	b1 12		lda ($12),y			lda 	(zTemp2),y
.019a47	cd 96 03	cmp $0396			cmp 	Var_Hash
.019a4a	d0 e7		bne $019a33			bne 	_VLNext 					; try next if different.
.019a4c					_VLCompare:
.019a4c	c8		iny				iny 								; next character
.019a4d	b1 12		lda ($12),y			lda 	(zTemp2),y 					; compare variable field against buffer.
.019a4f	d9 12 03	cmp $0312,y			cmp 	Var_Buffer-3,y 				; the -3 is because name starts at 3.
.019a52	d0 df		bne $019a33			bne 	_VLNext 					; fail if different, try next.
.019a54	0a		asl a				asl 	a 							; until end character (bit 7 set) matched
.019a55	90 f5		bcc $019a4c			bcc 	_VLCompare
.019a57	98		tya				tya
.019a58	38		sec				sec 								; add 1 as Y points to last character
.019a59	65 12		adc $12				adc 	zTemp2 						; add to the current address
.019a5b	85 22		sta $22				sta 	zVarDataPtr
.019a5d	a5 13		lda $13				lda 	zTemp2+1
.019a5f	69 00		adc #$00			adc 	#0
.019a61	85 23		sta $23				sta 	zVarDataPtr+1
.019a63	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.019a66	85 24		sta $24				sta 	zVarType
.019a68	38		sec				sec 								; return CS
.019a69	7a		ply		_VLExit:ply
.019a6a	fa		plx				plx
.019a6b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/vargetset.asm

.019a6c					VariableGet:
.019a6c	5a		phy				phy
.019a6d	a0 00		ldy #$00			ldy 	#0 							; copy first two bytes
.019a6f	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019a71	95 80		sta $80,x			sta 	XS_Mantissa,x
.019a73	c8		iny				iny
.019a74	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019a76	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019a78	c8		iny				iny
.019a79	a5 24		lda $24				lda 	zVarType 					; if it is a string, set up for that.
.019a7b	c9 b7		cmp #$b7			cmp 	#token_Dollar
.019a7d	f0 2c		beq $019aab			beq 	_VGString
.019a7f	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; copy the next two bytes.
.019a81	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019a83	c8		iny				iny
.019a84	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019a86	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019a88	c8		iny				iny
.019a89	a9 01		lda #$01			lda 	#1 							; set type to 1.
.019a8b	95 85		sta $85,x			sta 	XS_Type,x
.019a8d	a5 24		lda $24				lda 	zVarType
.019a8f	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if it is a %, then exit with default integer.
.019a91	f0 28		beq $019abb			beq 	_VGExit
.019a93	a9 40		lda #$40			lda 	#$40 						; set type byte to zero
.019a95	95 85		sta $85,x			sta 	XS_Type,x 					; which is the code for zero/float.
.019a97	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; the last value to copy is the exponent.
.019a99	95 84		sta $84,x			sta 	XS_Exponent,x
.019a9b	f0 1e		beq $019abb			beq 	_VGExit 					; if exponent is zero ... it's zero.
.019a9d	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; the sign bit is the top mantissa bit.
.019a9f	48		pha				pha
.019aa0	29 80		and #$80			and 	#$80
.019aa2	95 85		sta $85,x			sta 	XS_Type,x 					; this is the type byte.
.019aa4	68		pla				pla
.019aa5	09 80		ora #$80			ora 	#$80 						; set the MSB as you would expect.
.019aa7	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; so it's a normalised float.
.019aa9	80 10		bra $019abb			bra 	_VGExit
.019aab					_VGString:
.019aab	a9 02		lda #$02			lda 	#2 							; set type to 2, a string
.019aad	95 85		sta $85,x			sta 	XS_Type,x
.019aaf	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; is the value there $0000
.019ab1	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019ab3	d0 06		bne $019abb			bne 	_VGExit 					; if not, exit.
.019ab5	85 25		sta $25				sta 	zNullString 				; make zNullString a 00 string.
.019ab7	a9 25		lda #$25			lda 	#zNullString
.019ab9	95 80		sta $80,x			sta 	XS_Mantissa,x 				; make it point to it.
.019abb					_VGExit:
.019abb	7a		ply				ply
.019abc	60		rts				rts
.019abd					VariableSet:
.019abd	b5 85		lda $85,x			lda 	XS_Type,x 					; is the result a string
.019abf	29 02		and #$02			and 	#2 							; if so, it has to be
.019ac1	d0 4b		bne $019b0e			bne 	_VSString
.019ac3	a5 24		lda $24				lda 	zVarType 					; if type is $ there's an error.
.019ac5	c9 b7		cmp #$b7			cmp 	#token_Dollar
.019ac7	f0 42		beq $019b0b			beq 	_VSBadType
.019ac9	c9 bb		cmp #$bb			cmp 	#token_Percent 				; type convert to float/int
.019acb	f0 05		beq $019ad2			beq 	_VSMakeInt
.019acd	20 33 a0	jsr $01a033			jsr 	FPUToFloat
.019ad0	80 03		bra $019ad5			bra 	_VSCopy
.019ad2					_VSMakeInt:
.019ad2	20 7f a0	jsr $01a07f			jsr 	FPUToInteger
.019ad5					_VSCopy:
.019ad5	5a		phy				phy
.019ad6	a0 00		ldy #$00			ldy 	#0 							; copy mantissa to target.
.019ad8	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019ada	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019adc	c8		iny				iny
.019add	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019adf	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019ae1	c8		iny				iny
.019ae2	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019ae4	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019ae6	c8		iny				iny
.019ae7	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019ae9	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019aeb	a5 24		lda $24				lda 	zVarType 					; if target is integer, alrady done.
.019aed	c9 bb		cmp #$bb			cmp 	#token_Percent
.019aef	f0 18		beq $019b09			beq 	_VSExit
.019af1	b5 85		lda $85,x			lda 	XS_Type,x 					; get the sign bit into carry flag.
.019af3	0a		asl a				asl 	a
.019af4	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; shift the sign into the mantissa high.
.019af6	08		php				php
.019af7	0a		asl a				asl 	a
.019af8	28		plp				plp
.019af9	6a		ror a				ror 	a
.019afa	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019afc	c8		iny				iny
.019afd	b5 84		lda $84,x			lda 	XS_Exponent,x 				; copy the exponent in
.019aff	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019b01	34 85		bit $85,x			bit 	XS_Type,x 					; if the result is non zero
.019b03	50 04		bvc $019b09			bvc 	_VSExit
.019b05	a9 00		lda #$00			lda 	#00 						; zero exponent indicating 0.
.019b07	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019b09					_VSExit:
.019b09	7a		ply				ply
.019b0a	60		rts				rts
.019b0b					_VSBadType:
.019b0b	4c 38 85	jmp $018538			jmp 	TypeError
.019b0e					_VSString:
.019b0e	a5 24		lda $24				lda 	zVarType 					; type must be $
.019b10	c9 b7		cmp #$b7			cmp 	#token_Dollar
.019b12	d0 f7		bne $019b0b			bne 	_VSBadType
.019b14	da		phx				phx
.019b15	5a		phy				phy
.019b16	20 93 96	jsr $019693			jsr 	StringConcrete 				; concrete the string in the mantissa -> AX
.019b19	a0 01		ldy #$01			ldy 	#1 							; save high byte
.019b1b	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019b1d	88		dey				dey 								; save low byte
.019b1e	8a		txa				txa
.019b1f	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019b21	7a		ply				ply 								; and exit.
.019b22	fa		plx				plx
.019b23	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.019b24					MulInteger32:
.019b24	b5 80		lda $80,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.019b26	95 8c		sta $8c,x			sta 	XS3_Mantissa,x
.019b28	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019b2a	95 8d		sta $8d,x			sta 	XS3_Mantissa+1,x
.019b2c	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019b2e	95 8e		sta $8e,x			sta 	XS3_Mantissa+2,x
.019b30	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019b32	95 8f		sta $8f,x			sta 	XS3_Mantissa+3,x
.019b34	a9 00		lda #$00			lda 	#0
.019b36	95 80		sta $80,x			sta 	XS_Mantissa+0,x 				; zero +0
.019b38	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019b3a	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019b3c	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019b3e					_BFMMultiply:
.019b3e	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.019b40	29 01		and #$01			and 	#1
.019b42	f0 03		beq $019b47			beq 	_BFMNoAdd
.019b44	20 fb 91	jsr $0191fb			jsr 	AddInteger32
.019b47					_BFMNoAdd:
.019b47	16 86		asl $86,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.019b49	36 87		rol $87,x			rol 	XS2_Mantissa+1,x
.019b4b	36 88		rol $88,x			rol 	XS2_Mantissa+2,x
.019b4d	36 89		rol $89,x			rol 	XS2_Mantissa+3,x
.019b4f	56 8f		lsr $8f,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.019b51	76 8e		ror $8e,x			ror 	XS3_Mantissa+2,x
.019b53	76 8d		ror $8d,x			ror 	XS3_Mantissa+1,x
.019b55	76 8c		ror $8c,x			ror 	XS3_Mantissa,x
.019b57	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.019b59	15 8d		ora $8d,x			ora 	XS3_Mantissa+1,x
.019b5b	15 8e		ora $8e,x			ora 	XS3_Mantissa+2,x
.019b5d	15 8f		ora $8f,x			ora 	XS3_Mantissa+3,x
.019b5f	d0 dd		bne $019b3e			bne 	_BFMMultiply
.019b61	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.019b62					DivInteger32:
.019b62	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; check for /0
.019b64	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.019b66	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.019b68	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.019b6a	d0 14		bne $019b80			bne 	_BFDOkay
.019b6c	20 57 85	jsr $018557			jsr ERR_Handler
>019b6f	44 69 76 69 73 69 6f 6e			.text "Division by Zero",0
>019b77	20 62 79 20 5a 65 72 6f 00
.019b80					_BFDOkay:
.019b80	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.019b82	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.019b84	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.019b86	85 1c		sta $1c				sta 	zLTemp1+2
.019b88	85 1d		sta $1d				sta 	zLTemp1+3
.019b8a	8d 9e 03	sta $039e			sta 	SignCount 					; Count of signs.
.019b8d	20 e4 9b	jsr $019be4			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.019b90	da		phx				phx
.019b91	e8		inx				inx
.019b92	e8		inx				inx
.019b93	e8		inx				inx
.019b94	e8		inx				inx
.019b95	e8		inx				inx
.019b96	e8		inx				inx
.019b97	20 e4 9b	jsr $019be4			jsr 	CheckIntegerNegate
.019b9a	fa		plx				plx
.019b9b	5a		phy				phy 								; Y is the counter
.019b9c	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.019b9e					_BFDLoop:
.019b9e	16 80		asl $80,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.019ba0	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.019ba2	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.019ba4	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.019ba6	26 1a		rol $1a				rol 	zLTemp1
.019ba8	26 1b		rol $1b				rol 	zLTemp1+1
.019baa	26 1c		rol $1c				rol 	zLTemp1+2
.019bac	26 1d		rol $1d				rol 	zLTemp1+3
.019bae	38		sec				sec
.019baf	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.019bb1	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.019bb3	48		pha				pha
.019bb4	a5 1b		lda $1b				lda 	zLTemp1+1
.019bb6	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.019bb8	48		pha				pha
.019bb9	a5 1c		lda $1c				lda 	zLTemp1+2
.019bbb	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.019bbd	48		pha				pha
.019bbe	a5 1d		lda $1d				lda 	zLTemp1+3
.019bc0	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.019bc2	90 13		bcc $019bd7			bcc 	_BFDNoAdd
.019bc4	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.019bc6	68		pla				pla
.019bc7	85 1c		sta $1c				sta 	zLTemp1+2
.019bc9	68		pla				pla
.019bca	85 1b		sta $1b				sta 	zLTemp1+1
.019bcc	68		pla				pla
.019bcd	85 1a		sta $1a				sta 	zLTemp1+0
.019bcf	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.019bd1	09 01		ora #$01			ora 	#1
.019bd3	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019bd5	80 03		bra $019bda			bra 	_BFDNext
.019bd7					_BFDNoAdd:
.019bd7	68		pla				pla 								; Throw away the intermediate calculations
.019bd8	68		pla				pla
.019bd9	68		pla				pla
.019bda					_BFDNext:
.019bda	88		dey				dey
.019bdb	d0 c1		bne $019b9e			bne 	_BFDLoop
.019bdd	7a		ply				ply 								; restore Y and exit
.019bde	4e 9e 03	lsr $039e			lsr 	SignCount 					; if sign count odd,
.019be1	b0 06		bcs $019be9			bcs		IntegerNegateAlways 			; negate the result
.019be3	60		rts				rts
.019be4					CheckIntegerNegate:
.019be4	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019be6	30 01		bmi $019be9			bmi 	IntegerNegateAlways
.019be8	60		rts				rts
.019be9					IntegerNegateAlways:
.019be9	ee 9e 03	inc $039e			inc 	SignCount
.019bec	38		sec				sec
.019bed	a9 00		lda #$00			lda 	#0
.019bef	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.019bf1	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019bf3	a9 00		lda #$00			lda 	#0
.019bf5	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.019bf7	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019bf9	a9 00		lda #$00			lda 	#0
.019bfb	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.019bfd	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019bff	a9 00		lda #$00			lda 	#0
.019c01	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.019c03	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019c05	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.019c06					INTToString:
.019c06	48		pha				pha
.019c07	5a		phy				phy
.019c08	b5 83		lda $83,x			lda 		XS_Mantissa+3,x 		; check -ve
.019c0a	10 08		bpl $019c14			bpl 		_ITSNotMinus
.019c0c	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.019c0e	20 a8 9c	jsr $019ca8			jsr 		ITSOutputCharacter
.019c11	20 e9 9b	jsr $019be9			jsr 		IntegerNegateAlways 	; negate the number.
.019c14					_ITSNotMinus:
.019c14	a9 00		lda #$00			lda 		#0
.019c16	8d 9a 03	sta $039a			sta 		NumSuppress 			; clear the suppression flag.
.019c19	8a		txa				txa 								; use Y for the mantissa index.
.019c1a	a8		tay				tay
.019c1b	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.019c1d					_ITSNextSubtractor:
.019c1d	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.019c1f	8d 9b 03	sta $039b			sta 		NumConvCount
.019c22					_ITSSubtract:
.019c22	38		sec				sec
.019c23	b9 80 00	lda $0080,y			lda 		XS_Mantissa,y 			; subtract number and push on stack
.019c26	ff 84 9c 01	sbc $019c84,x			sbc 		_ITSSubtractors+0,x
.019c2a	48		pha				pha
.019c2b	b9 81 00	lda $0081,y			lda 		XS_Mantissa+1,y
.019c2e	ff 85 9c 01	sbc $019c85,x			sbc 		_ITSSubtractors+1,x
.019c32	48		pha				pha
.019c33	b9 82 00	lda $0082,y			lda 		XS_Mantissa+2,y
.019c36	ff 86 9c 01	sbc $019c86,x			sbc 		_ITSSubtractors+2,x
.019c3a	48		pha				pha
.019c3b	b9 83 00	lda $0083,y			lda 		XS_Mantissa+3,y
.019c3e	ff 87 9c 01	sbc $019c87,x			sbc 		_ITSSubtractors+3,x
.019c42	90 14		bcc $019c58			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.019c44	99 83 00	sta $0083,y			sta 		XS_Mantissa+3,y 		; save subtract off stack
.019c47	68		pla				pla
.019c48	99 82 00	sta $0082,y			sta 		XS_Mantissa+2,y
.019c4b	68		pla				pla
.019c4c	99 81 00	sta $0081,y			sta 		XS_Mantissa+1,y
.019c4f	68		pla				pla
.019c50	99 80 00	sta $0080,y			sta 		XS_Mantissa+0,y
.019c53	ee 9b 03	inc $039b			inc 		NumConvCount 			; bump count.
.019c56	80 ca		bra $019c22			bra 		_ITSSubtract 			; go round again.
.019c58					_ITSCantSubtract:
.019c58	68		pla				pla 								; throw away interim answers
.019c59	68		pla				pla
.019c5a	68		pla				pla
.019c5b	ad 9b 03	lda $039b			lda 		NumConvCount 			; if not zero then no suppression check
.019c5e	c9 30		cmp #$30			cmp 		#"0"
.019c60	d0 05		bne $019c67			bne 		_ITSOutputDigit
.019c62	ad 9a 03	lda $039a			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.019c65	10 09		bpl $019c70			bpl	 		_ITSGoNextSubtractor
.019c67					_ITSOutputDigit:
.019c67	ce 9a 03	dec $039a			dec 		NumSuppress 			; suppression check will be non-zero.
.019c6a	ad 9b 03	lda $039b			lda 		NumConvCount 			; count of subtractions
.019c6d	20 a8 9c	jsr $019ca8			jsr 		ITSOutputCharacter 		; output it.
.019c70					_ITSGoNextSubtractor:
.019c70	e8		inx				inx 								; next dword
.019c71	e8		inx				inx
.019c72	e8		inx				inx
.019c73	e8		inx				inx
.019c74	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.019c76	d0 a5		bne $019c1d			bne 		_ITSNextSubtractor 		; do all the subtractors.
.019c78	98		tya				tya 								; X is back as the mantissa index
.019c79	aa		tax				tax
.019c7a	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.019c7c	09 30		ora #$30			ora 		#"0"
.019c7e	20 a8 9c	jsr $019ca8			jsr 		ITSOutputCharacter
.019c81	7a		ply				ply 								; and exit
.019c82	68		pla				pla
.019c83	60		rts				rts
.019c84					_ITSSubtractors:
>019c84	00 ca 9a 3b					.dword 		1000000000
>019c88	00 e1 f5 05					.dword 		100000000
>019c8c	80 96 98 00					.dword 		10000000
>019c90	40 42 0f 00					.dword 		1000000
>019c94	a0 86 01 00					.dword 		100000
>019c98	10 27 00 00					.dword 		10000
>019c9c	e8 03 00 00					.dword 		1000
>019ca0	64 00 00 00					.dword 		100
>019ca4	0a 00 00 00					.dword 		10
.019ca8					_ITSSubtractorsEnd:
.019ca8					ITSOutputCharacter:
.019ca8	48		pha				pha
.019ca9	da		phx				phx
.019caa	ae 14 03	ldx $0314			ldx 	NumBufX 					; save digit
.019cad	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.019cb0	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.019cb2	9d 16 03	sta $0316,x			sta 	Num_Buffer+1,x
.019cb5	ee 14 03	inc $0314			inc 	NumBufX						; bump pointer.
.019cb8	fa		plx				plx
.019cb9	68		pla				pla
.019cba	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.019cbb					IntFromString:
.019cbb	a0 00		ldy #$00			ldy 	#0
.019cbd	8c 9c 03	sty $039c			sty 	ExpTemp 					; this is the converted digit count.
.019cc0					IntFromStringY:
.019cc0	48		pha				pha
.019cc1	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.019cc3	95 80		sta $80,x			sta 	XS_Mantissa,x
.019cc5	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019cc7	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019cc9	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019ccb	a9 01		lda #$01			lda 	#1
.019ccd	95 85		sta $85,x			sta 	XS_Type,x
.019ccf					_IFSLoop:
.019ccf	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.019cd1	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.019cd3	90 4e		bcc $019d23			bcc 	_IFSExit
.019cd5	c9 3a		cmp #$3a			cmp 	#"9"+1
.019cd7	b0 4a		bcs $019d23			bcs 	_IFSExit
.019cd9	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.019cdb	c9 0c		cmp #$0c			cmp 	#12
.019cdd	b0 4e		bcs $019d2d			bcs 	_IFSOverflow
.019cdf	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.019ce1	48		pha				pha
.019ce2	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019ce4	48		pha				pha
.019ce5	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019ce7	48		pha				pha
.019ce8	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019cea	48		pha				pha
.019ceb	20 42 9d	jsr $019d42			jsr 	IFSX1ShiftLeft 				; double
.019cee	20 42 9d	jsr $019d42			jsr 	IFSX1ShiftLeft 				; x 4
.019cf1	18		clc				clc 								; add saved value x 5
.019cf2	68		pla				pla
.019cf3	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.019cf5	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019cf7	68		pla				pla
.019cf8	75 81		adc $81,x			adc 	XS_Mantissa+1,x
.019cfa	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019cfc	68		pla				pla
.019cfd	75 82		adc $82,x			adc 	XS_Mantissa+2,x
.019cff	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019d01	68		pla				pla
.019d02	75 83		adc $83,x			adc 	XS_Mantissa+3,x
.019d04	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019d06	20 42 9d	jsr $019d42			jsr 	IFSX1ShiftLeft 				; x 10
.019d09	ee 9c 03	inc $039c			inc 	ExpTemp 					; bump count of digits processed.
.019d0c	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.019d0e	29 0f		and #$0f			and 	#15
.019d10	c8		iny				iny
.019d11	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.019d13	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019d15	90 b8		bcc $019ccf			bcc 	_IFSLoop
.019d17	f6 81		inc $81,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.019d19	d0 b4		bne $019ccf			bne 	_IFSLoop
.019d1b	f6 82		inc $82,x			inc 	XS_Mantissa+2,x
.019d1d	d0 b0		bne $019ccf			bne 	_IFSLoop
.019d1f	f6 83		inc $83,x			inc 	XS_Mantissa+3,x
.019d21	80 ac		bra $019ccf			bra 	_IFSLoop
.019d23					_IFSExit:
.019d23	98		tya				tya 								; get offset
.019d24					_IFSOkay:
.019d24	38		sec				sec
.019d25	ad 9c 03	lda $039c			lda 	ExpTemp
.019d28	f0 01		beq $019d2b			beq 	_IFSSkipFail
.019d2a	18		clc				clc
.019d2b					_IFSSkipFail:
.019d2b	68		pla				pla 								; and exit.
.019d2c	60		rts				rts
.019d2d					_IFSOverflow:
.019d2d	20 57 85	jsr $018557			jsr 	ERR_Handler
>019d30	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>019d38	20 6f 76 65 72 66 6c 6f 77 00
.019d42					IFSX1ShiftLeft:
.019d42	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.019d44	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.019d46	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.019d48	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.019d4a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.019d4b					FPSubtract:
.019d4b	48		pha				pha
.019d4c	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.019d4e	49 80		eor #$80			eor 	#$80
.019d50	95 8b		sta $8b,x			sta 	XS2_Type,x
.019d52	68		pla				pla 								; --- and fall through ---
.019d53					FPAdd:
.019d53	48		pha				pha
.019d54	b5 85		lda $85,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.019d56	d0 05		bne $019d5d			bne 	_FPA_NegativeLHS
.019d58	20 74 9d	jsr $019d74			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.019d5b	68		pla				pla
.019d5c	60		rts				rts
.019d5d					_FPA_NegativeLHS:
.019d5d	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.019d5f	49 80		eor #$80			eor 	#$80
.019d61	95 85		sta $85,x			sta 	XS_Type,x
.019d63	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of B and add
.019d65	49 80		eor #$80			eor 	#$80
.019d67	95 8b		sta $8b,x			sta 	XS2_Type,x
.019d69	20 74 9d	jsr $019d74			jsr 	FPAdd_Worker 				; do the add calculation.
.019d6c	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 back
.019d6e	49 80		eor #$80			eor 	#$80
.019d70	95 85		sta $85,x			sta 	XS_Type,x
.019d72	68		pla				pla
.019d73	60		rts				rts
.019d74					FPAdd_Worker:
.019d74	34 8b		bit $8b,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.019d76	70 07		bvs $019d7f			bvs 	_FPAWExit 					; no change.
.019d78	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.019d7a	50 07		bvc $019d83			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.019d7c	20 f1 9f	jsr $019ff1			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.019d7f					_FPAWExit:
.019d7f	20 60 a0	jsr $01a060			jsr 	FPUNormalise 				; normalise the result.
.019d82	60		rts				rts
.019d83					_FPAWMakeSame:
.019d83	b5 84		lda $84,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.019d85	38		sec				sec
.019d86	f5 8a		sbc $8a,x			sbc	 	XS2_Exponent,x 				; using subtraction
.019d88	f0 16		beq $019da0			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.019d8a	da		phx				phx 								; save X
.019d8b	90 06		bcc $019d93			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.019d8d	e8		inx				inx
.019d8e	e8		inx				inx
.019d8f	e8		inx				inx
.019d90	e8		inx				inx
.019d91	e8		inx				inx
.019d92	e8		inx				inx
.019d93					_FPAWShiftA:
.019d93	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.019d95	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.019d97	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.019d99	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.019d9b	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.019d9d	fa		plx				plx 								; restore original X
.019d9e	80 e3		bra $019d83			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.019da0					_FPAW_DoArithmetic:
.019da0	34 8b		bit $8b,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.019da2	30 28		bmi $019dcc			bmi 	_FPAW_BNegative
.019da4	18		clc				clc
.019da5	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019da7	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.019da9	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019dab	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019dad	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.019daf	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019db1	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019db3	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.019db5	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019db7	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019db9	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.019dbb	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019dbd	90 c0		bcc $019d7f			bcc 	_FPAWExit 					; no carry.
.019dbf	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.019dc1	38		sec				sec
.019dc2	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.019dc4	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.019dc6	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.019dc8	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.019dca	80 b3		bra $019d7f			bra 	_FPAWExit
.019dcc					_FPAW_BNegative:
.019dcc	38		sec				sec
.019dcd	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019dcf	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.019dd1	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019dd3	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019dd5	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.019dd7	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019dd9	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019ddb	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.019ddd	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019ddf	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019de1	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.019de3	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019de5	b0 09		bcs $019df0			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.019de7	20 17 a0	jsr $01a017			jsr 	FPUNegateInteger			; negate the mantissa
.019dea	b5 85		lda $85,x			lda 	XS_Type,x 					; flip result sign
.019dec	49 80		eor #$80			eor 	#$80
.019dee	95 85		sta $85,x			sta 	XS_Type,x
.019df0					_FPAWGoExit:
.019df0	4c 7f 9d	jmp $019d7f			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.019df3					FPD_IsDivZero:
.019df3	20 57 85	jsr $018557			jsr ERR_Handler
>019df6	44 69 76 69 73 69 6f 6e			.text "Division by zero",0
>019dfe	20 62 79 20 7a 65 72 6f 00
.019e07					FPDivide:
.019e07	48		pha				pha
.019e08	5a		phy				phy
.019e09	34 8b		bit $8b,x			bit 	XS2_Type,x 					; check if division by zero
.019e0b	70 e6		bvs $019df3			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.019e0d	34 85		bit $85,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.019e0f	f0 03		beq $019e14			beq 	_FPDCalculateExp
.019e11					_FPD_Exit:
.019e11	7a		ply				ply
.019e12	68		pla				pla
.019e13	60		rts				rts
.019e14					_FPDCalculateExp:
.019e14	b5 8a		lda $8a,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.019e16	49 ff		eor #$ff			eor 	#$FF
.019e18	1a		inc a				inc 	a
.019e19	95 8a		sta $8a,x			sta 	XS2_Exponent,x
.019e1b	20 eb 9e	jsr $019eeb			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.019e1e	18		clc				clc 	 							; add 1 to the resulting exponent
.019e1f	69 01		adc #$01			adc 	#1
.019e21	b0 54		bcs $019e77			bcs 	_FPD_Overflow 				; which can overflow.
.019e23	95 84		sta $84,x			sta 	XS_Exponent,x
.019e25	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.019e27	85 1a		sta $1a				sta 	zLTemp1+0
.019e29	85 1b		sta $1b				sta 	zLTemp1+1
.019e2b	85 1c		sta $1c				sta 	zLTemp1+2
.019e2d	85 1d		sta $1d				sta 	zLTemp1+3
.019e2f	a0 20		ldy #$20			ldy 	#32 						; times round.
.019e31					_FPD_Loop:
.019e31	38		sec				sec 								; calculate X1-X2 stacking result because we might
.019e32	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; not save it.
.019e34	f5 86		sbc $86,x			sbc 	XS2_Mantissa,x
.019e36	48		pha				pha
.019e37	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019e39	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.019e3b	48		pha				pha
.019e3c	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019e3e	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.019e40	48		pha				pha
.019e41	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019e43	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.019e45	90 13		bcc $019e5a			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.019e47	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; save results out to A
.019e49	68		pla				pla
.019e4a	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019e4c	68		pla				pla
.019e4d	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019e4f	68		pla				pla
.019e50	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019e52	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.019e54	09 80		ora #$80			ora 	#$80
.019e56	85 1d		sta $1d				sta 	zLTemp1+3
.019e58	80 03		bra $019e5d			bra 	_FPD_Rotates
.019e5a					_FPD_NoSubtract:
.019e5a	68		pla				pla 								; throw away unwanted results
.019e5b	68		pla				pla
.019e5c	68		pla				pla
.019e5d					_FPD_Rotates:
.019e5d	56 89		lsr $89,x			lsr 	3+XS2_Mantissa,x
.019e5f	76 88		ror $88,x			ror 	2+XS2_Mantissa,x
.019e61	76 87		ror $87,x			ror 	1+XS2_Mantissa,x
.019e63	76 86		ror $86,x			ror 	0+XS2_Mantissa,x
.019e65	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.019e67	26 1b		rol $1b				rol 	zLTemp1+1
.019e69	26 1c		rol $1c				rol 	zLTemp1+2
.019e6b	26 1d		rol $1d				rol 	zLTemp1+3
.019e6d	90 02		bcc $019e71			bcc 	_FPD_NoCarry
.019e6f	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.019e71					_FPD_NoCarry:
.019e71	88		dey				dey 								; do 32 times
.019e72	d0 bd		bne $019e31			bne 	_FPD_Loop
.019e74	4c cf 9e	jmp $019ecf			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.019e77					_FPD_Overflow:
.019e77	4c bd a0	jmp $01a0bd			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.019e7a					FPMultiply:
.019e7a	48		pha				pha
.019e7b	5a		phy				phy
.019e7c	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.019e7e	70 07		bvs $019e87			bvs 	_FPM_Exit
.019e80	34 8b		bit $8b,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.019e82	50 06		bvc $019e8a			bvc 	_FPM_CalcExponent
.019e84	20 f1 9f	jsr $019ff1			jsr 	FPUCopyX2ToX1
.019e87					_FPM_Exit:
.019e87	7a		ply				ply
.019e88	68		pla				pla
.019e89	60		rts				rts
.019e8a					_FPM_CalcExponent:
.019e8a	18		clc				clc
.019e8b	20 eb 9e	jsr $019eeb			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.019e8e	95 84		sta $84,x			sta 	XS_Exponent,x 				; save the result.
.019e90	a9 00		lda #$00			lda 	#0
.019e92	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.019e94	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.019e96	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.019e98	85 1d		sta $1d				sta 	zLTemp1+3
.019e9a	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.019e9c					_FPM_Loop:
.019e9c	b5 80		lda $80,x			lda 	XS_Mantissa,x				; check LSB of long product
.019e9e	29 01		and #$01			and 	#1
.019ea0	18		clc				clc 								; clear carry for the long rotate.
.019ea1	f0 19		beq $019ebc			beq 	_FPM_NoAddition
.019ea3	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.019ea4	a5 1a		lda $1a				lda 	zLTemp1+0
.019ea6	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.019ea8	85 1a		sta $1a				sta 	zLTemp1+0
.019eaa	a5 1b		lda $1b				lda 	zLTemp1+1
.019eac	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.019eae	85 1b		sta $1b				sta 	zLTemp1+1
.019eb0	a5 1c		lda $1c				lda 	zLTemp1+2
.019eb2	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.019eb4	85 1c		sta $1c				sta 	zLTemp1+2
.019eb6	a5 1d		lda $1d				lda 	zLTemp1+3
.019eb8	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.019eba	85 1d		sta $1d				sta 	zLTemp1+3
.019ebc					_FPM_NoAddition:
.019ebc	66 1d		ror $1d				ror 	3+zLTemp1
.019ebe	66 1c		ror $1c				ror 	2+zLTemp1
.019ec0	66 1b		ror $1b				ror 	1+zLTemp1
.019ec2	66 1a		ror $1a				ror 	0+zLTemp1
.019ec4	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.019ec6	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.019ec8	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.019eca	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.019ecc	88		dey				dey
.019ecd	d0 cd		bne $019e9c			bne 	_FPM_Loop 					; do this 32 times.
.019ecf					FPM_CopySignNormalize:
.019ecf	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.019ed1	95 80		sta $80,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.019ed3	a5 1b		lda $1b				lda 	zLTemp1+1
.019ed5	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019ed7	a5 1c		lda $1c				lda 	zLTemp1+2
.019ed9	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019edb	a5 1d		lda $1d				lda 	zLTemp1+3
.019edd	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019edf	b5 85		lda $85,x			lda 	XS_Type,x 					; sign is xor of signs
.019ee1	55 8b		eor $8b,x			eor 	XS2_Type,x
.019ee3	95 85		sta $85,x			sta 	XS_Type,x
.019ee5	20 60 a0	jsr $01a060			jsr 	FPUNormalise 				; normalise and exit.
.019ee8	7a		ply				ply
.019ee9	68		pla				pla
.019eea	60		rts				rts
.019eeb					FPCalculateExponent:
.019eeb	18		clc				clc
.019eec	b5 84		lda $84,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.019eee	75 8a		adc $8a,x			adc 	XS2_Exponent,x
.019ef0	b0 08		bcs $019efa			bcs 	_FPCECarry 					; carry out ?
.019ef2	10 03		bpl $019ef7			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.019ef4	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.019ef6	60		rts				rts
.019ef7					_FPCEExpZero:
.019ef7	a9 00		lda #$00			lda 	#0
.019ef9	60		rts				rts
.019efa					_FPCECarry:
.019efa	30 03		bmi $019eff			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.019efc	09 80		ora #$80			ora 	#$80 						; put in right range
.019efe	60		rts				rts
.019eff					_FPCEOverflow:
.019eff	4c bd a0	jmp $01a0bd			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.019f02					FPFractionalPart:
.019f02	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.019f04	38		sec				sec 								; this flag tells us to keep the fractional part
.019f05	30 0d		bmi $019f14			bmi 	FPGetPart
.019f07	60		rts				rts
.019f08					FPIntegerPart:
.019f08	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.019f0a	18		clc				clc 								; this flag says keep the integer part.
.019f0b	30 07		bmi $019f14			bmi 	FPGetPart 					; -ve exponents are 0..127
.019f0d	48		pha				pha
.019f0e	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.019f10	95 85		sta $85,x			sta 	XS_Type,x
.019f12	68		pla				pla
.019f13	60		rts				rts
.019f14					FPGetPart:
.019f14	48		pha				pha
.019f15	5a		phy				phy 								; save Y
.019f16	08		php				php 								; save action
.019f17	34 85		bit $85,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.019f19	70 59		bvs $019f74			bvs 	_FPGP_Exit 					; then do nothing.
.019f1b	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.019f1d	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.019f1f	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.019f21	85 1c		sta $1c				sta 	zLTemp1+2
.019f23	85 1d		sta $1d				sta 	zLTemp1+3
.019f25	b5 84		lda $84,x			lda 	XS_Exponent,x				; the number of shifts.
.019f27	38		sec				sec
.019f28	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.019f2a	f0 12		beq $019f3e			beq 	_FPGP_NoShift 				; ... if any
.019f2c	c9 20		cmp #$20			cmp 	#32
.019f2e	90 02		bcc $019f32			bcc 	_FPGP_NotMax
.019f30	a9 20		lda #$20			lda 	#32 						; max of 32.
.019f32					_FPGP_NotMax:
.019f32	a8		tay				tay 								; Y is the mask shift count.
.019f33					_FPGP_ShiftMask:
.019f33	46 1d		lsr $1d				lsr 	3+zLTemp1
.019f35	66 1c		ror $1c				ror 	2+zLTemp1
.019f37	66 1b		ror $1b				ror 	1+zLTemp1
.019f39	66 1a		ror $1a				ror 	0+zLTemp1
.019f3b	88		dey				dey
.019f3c	d0 f5		bne $019f33			bne 	_FPGP_ShiftMask
.019f3e					_FPGP_NoShift:
.019f3e	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.019f40	8e 9c 03	stx $039c			stx 	ExpTemp						; save X
.019f43					_FPGP_MaskLoop:
.019f43	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.019f46	28		plp				plp 								; if CC we keep the top part, so we
.019f47	08		php				php		 							; flip the mask.
.019f48	b0 02		bcs $019f4c			bcs		_FPGP_NoFlip
.019f4a	49 ff		eor #$ff			eor 	#$FF
.019f4c					_FPGP_NoFlip:
.019f4c	35 80		and $80,x			and 	XS_Mantissa,x 				; and into the mantissa.
.019f4e	95 80		sta $80,x			sta 	XS_Mantissa,x
.019f50	e8		inx				inx
.019f51	c8		iny				iny
.019f52	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.019f54	d0 ed		bne $019f43			bne 	_FPGP_MaskLoop
.019f56	ae 9c 03	ldx $039c			ldx 	ExpTemp						; restore X
.019f59	28		plp				plp
.019f5a	08		php				php 								; get action flag on the stack
.019f5b	90 04		bcc $019f61			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.019f5d	a9 00		lda #$00			lda 	#0
.019f5f	95 85		sta $85,x			sta 	XS_Type,x
.019f61					_FPGP_NotFractional:
.019f61	b5 80		lda $80,x			lda 	XS_Mantissa,x 						; check if \1 zero
.019f63	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019f65	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019f67	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019f69	f0 05		beq $019f70			beq 	_FPGP_Zero 					; if zero, return zero
.019f6b	20 60 a0	jsr $01a060			jsr 	FPUNormalise
.019f6e	80 04		bra $019f74			bra 	_FPGP_Exit 					; and exit
.019f70					_FPGP_Zero:
.019f70	a9 40		lda #$40			lda 	#$40 						; set zero flag
.019f72	95 85		sta $85,x			sta 	XS_Type,x
.019f74					_FPGP_Exit:
.019f74	68		pla				pla 								; throw saved action flag.
.019f75	7a		ply				ply
.019f76	68		pla				pla
.019f77	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.019f78					FPCompare:
.019f78	20 b9 9f	jsr $019fb9			jsr 	FPFastCompare 				; fast compare try first
.019f7b	b0 3b		bcs $019fb8			bcs 	_FPCExit 					; that worked.
.019f7d	b5 84		lda $84,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.019f7f	48		pha				pha
.019f80	b5 8a		lda $8a,x			lda 	XS2_Exponent,x
.019f82	48		pha				pha
.019f83	20 4b 9d	jsr $019d4b			jsr 	FPSubtract 					; calculate X1-X2
.019f86	34 85		bit $85,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.019f88	70 2a		bvs $019fb4			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.019f8a	68		pla				pla
.019f8b	8d 9c 03	sta $039c			sta 	ExpTemp						; save first exponent in temporary reg.
.019f8e	68		pla				pla
.019f8f	38		sec				sec
.019f90	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; calculate AX-BX
.019f93	70 14		bvs $019fa9			bvs 	_FPCNotEqual				; overflow, can't be equal.
.019f95	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.019f96	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.019f98	b0 0f		bcs $019fa9			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.019f9a	38		sec				sec
.019f9b	ad 9c 03	lda $039c			lda 	ExpTemp 					; get one of the exponents back.
.019f9e	e9 12		sbc #$12			sbc 	#18 						; allow for 2^18 error, relatively.
.019fa0	b0 02		bcs $019fa4			bcs 	_FPCNotRange 				; keep in range.
.019fa2	a9 01		lda #$01			lda 	#1
.019fa4					_FPCNotRange:
.019fa4	38		sec				sec
.019fa5	f5 84		sbc $84,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.019fa7	b0 0d		bcs $019fb6			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.019fa9					_FPCNotEqual:
.019fa9	b5 85		lda $85,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.019fab	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.019fad	f0 02		beq $019fb1			beq 	_FPCNE2
.019faf	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.019fb1	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.019fb2	80 04		bra $019fb8			bra 	_FPCExit
.019fb4					_FPCPullZero:
.019fb4	68		pla				pla 								; throw saved exponents
.019fb5	68		pla				pla
.019fb6					_FPCZero:
.019fb6	a9 00		lda #$00			lda 	#0 							; and return zero
.019fb8					_FPCExit:
.019fb8	60		rts				rts
.019fb9					FPFastCompare:
.019fb9	34 85		bit $85,x			bit 	XS_Type,x 					; n1 is zero.
.019fbb	70 23		bvs $019fe0			bvs 	_FPFLeftZero
.019fbd	34 8b		bit $8b,x			bit 	XS2_Type,x 					; n2 is zero
.019fbf	b5 85		lda $85,x			lda 	XS_Type,x 					; if so, return sign bit of 1 (n-0)
.019fc1	70 25		bvs $019fe8			bvs 	_FPFSignBit
.019fc3	55 8b		eor $8b,x			eor 	XS2_Type,x 					; eor 2 type bits. now know both non-zero
.019fc5	0a		asl a				asl 	a 							; put in CS if different.
.019fc6	b5 85		lda $85,x			lda 	XS_Type,x 					; if signs different return sign of first
.019fc8	b0 1e		bcs $019fe8			bcs 	_FPFSignBit
.019fca	38		sec				sec 								; same sign and not-zero. compare exponents
.019fcb	b5 84		lda $84,x			lda 	XS_Exponent,x 				; compare exponents. if the same, then fail.
.019fcd	f5 8a		sbc $8a,x			sbc 	XS2_Exponent,x 				; e.g. we have to do it via subtraction.
.019fcf	f0 09		beq $019fda			beq 	_FPNoFastCompare
.019fd1	6a		ror a				ror 	a 							; put carry into bit 7.
.019fd2	34 85		bit $85,x			bit 	XS_Type,X 					; if it is +x then flip it.
.019fd4	30 02		bmi $019fd8			bmi		_FPFCNotMinus
.019fd6	49 80		eor #$80			eor 	#$80
.019fd8					_FPFCNotMinus:
.019fd8	80 0e		bra $019fe8			bra		_FPFSignBit
.019fda					_FPNoFastCompare:
.019fda	18		clc				clc
.019fdb	60		rts				rts
.019fdc					_FPFZero:
.019fdc	a9 00		lda #$00			lda 	#0
.019fde					_FPFExitSet:
.019fde	38		sec				sec
.019fdf	60		rts				rts
.019fe0					_FPFLeftZero:
.019fe0	34 8b		bit $8b,x			bit 	XS2_Type,x 					; if right is zero, return zero.
.019fe2	70 f8		bvs $019fdc			bvs 	_FPFZero
.019fe4	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip sign bit
.019fe6	49 80		eor #$80			eor 	#$80						; return that as a sign.
.019fe8					_FPFSignBit:
.019fe8	0a		asl a				asl 	a
.019fe9	a9 01		lda #$01			lda 	#1
.019feb	90 f1		bcc $019fde			bcc		_FPFExitSet
.019fed	a9 ff		lda #$ff			lda 	#$FF
.019fef	38		sec				sec
.019ff0	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.019ff1					FPUCopyX2ToX1:
.019ff1	48		pha				pha
.019ff2	da		phx				phx
.019ff3	5a		phy				phy
.019ff4	a0 08		ldy #$08			ldy 	#8
.019ff6	b5 86		lda $86,x	_FPUC21:lda 	XS2_Mantissa,x
.019ff8	95 80		sta $80,x			sta 	XS_Mantissa,x
.019ffa	e8		inx				inx
.019ffb	88		dey				dey
.019ffc	10 f8		bpl $019ff6			bpl 	_FPUC21
.019ffe	7a		ply				ply
.019fff	fa		plx				plx
.01a000	68		pla				pla
.01a001	60		rts				rts
.01a002					FPUSetInteger:
.01a002	48		pha				pha
.01a003	95 80		sta $80,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.01a005	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.01a007	10 02		bpl $01a00b			bpl 	_FPUSIExtend
.01a009	a9 ff		lda #$ff			lda 	#$FF
.01a00b					_FPUSIExtend:
.01a00b	95 81		sta $81,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.01a00d	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a00f	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a011	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.01a013	95 85		sta $85,x			sta 	XS_Type,x
.01a015	68		pla				pla
.01a016	60		rts				rts
.01a017					FPUNegateInteger:
.01a017	48		pha				pha
.01a018	38		sec				sec
.01a019	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.01a01b	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.01a01d	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a01f	a9 00		lda #$00			lda 	#0
.01a021	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.01a023	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a025	a9 00		lda #$00			lda 	#0
.01a027	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.01a029	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a02b	a9 00		lda #$00			lda 	#0
.01a02d	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.01a02f	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a031	68		pla				pla
.01a032	60		rts				rts
.01a033					FPUToFloat:
.01a033	48		pha				pha
.01a034	b5 85		lda $85,x			lda 	XS_Type,x					; exit if already float.
.01a036	29 0f		and #$0f			and 	#$0F
.01a038	f0 24		beq $01a05e			beq 	_FPUFExit
.01a03a	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.01a03c	95 85		sta $85,x			sta 	XS_Type,x
.01a03e	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.01a040	95 84		sta $84,x			sta 	XS_Exponent,x 				; x mantissa.
.01a042	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.01a044	10 07		bpl $01a04d			bpl		_FPUFPositive
.01a046	20 17 a0	jsr $01a017			jsr 	FPUNegateInteger 			; negate the mantissa
.01a049	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.01a04b	95 85		sta $85,x			sta 	XS_Type,x
.01a04d					_FPUFPositive:
.01a04d	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.01a04f	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.01a051	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01a053	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01a055	d0 04		bne $01a05b			bne 	_FPUFNonZero
.01a057	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.01a059	95 85		sta $85,x			sta 	XS_Type,x
.01a05b					_FPUFNonZero:
.01a05b	20 60 a0	jsr $01a060			jsr 	FPUNormalise 				; normalise the floating point.
.01a05e					_FPUFExit:
.01a05e	68		pla				pla
.01a05f	60		rts				rts
.01a060					FPUNormalise:
.01a060	48		pha				pha
.01a061	34 85		bit $85,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.01a063	70 18		bvs $01a07d			bvs 	_FPUNExit
.01a065	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.01a067	f0 10		beq $01a079			beq 	_FPUNSetZero
.01a069					_FPUNLoop:
.01a069	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.01a06b	30 10		bmi $01a07d			bmi 	_FPUNExit 					; if so, we are normalised.
.01a06d	16 80		asl $80,x			asl 	0+XS_Mantissa+0,x
.01a06f	36 81		rol $81,x			rol 	1+XS_Mantissa+0,x
.01a071	36 82		rol $82,x			rol 	2+XS_Mantissa+0,x
.01a073	36 83		rol $83,x			rol 	3+XS_Mantissa+0,x
.01a075	d6 84		dec $84,x			dec 	XS_Exponent,x 				; decrement exponent
.01a077	d0 f0		bne $01a069			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.01a079					_FPUNSetZero:
.01a079	a9 40		lda #$40			lda 	#$40
.01a07b	95 85		sta $85,x			sta 	XS_Type,x 					; the result is now zero.
.01a07d					_FPUNExit:
.01a07d	68		pla				pla
.01a07e	60		rts				rts
.01a07f					FPUToInteger:
.01a07f	48		pha				pha
.01a080	b5 85		lda $85,x			lda 	XS_Type,x 					; if already integer, exit
.01a082	29 01		and #$01			and 	#1
.01a084	d0 31		bne $01a0b7			bne 	_FPUTOI_Exit
.01a086	34 85		bit $85,x			bit 	XS_Type,x					; if zero, return zero.
.01a088	70 23		bvs $01a0ad			bvs 	_FPUTOI_Zero
.01a08a	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.01a08c	10 1f		bpl $01a0ad			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.01a08e	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.01a090	b0 2b		bcs $01a0bd			bcs 	FP_Overflow
.01a092					_FPUToIToInteger:
.01a092	b5 84		lda $84,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.01a094	c9 a0		cmp #$a0			cmp 	#128+32
.01a096	f0 0c		beq $01a0a4			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.01a098	f6 84		inc $84,x			inc 	XS_Exponent,X 				; increment Exponent
.01a09a	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.01a09c	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a09e	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a0a0	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a0a2	80 ee		bra $01a092			bra 	_FPUToIToInteger 			; keep going.
.01a0a4					_FPUToICheckSign:
.01a0a4	b5 85		lda $85,x			lda 	XS_Type,x 					; check sign
.01a0a6	10 0f		bpl $01a0b7			bpl 	_FPUToI_Exit 				; exit if unsigned.
.01a0a8	20 17 a0	jsr $01a017			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.01a0ab	80 0a		bra $01a0b7			bra 	_FPUTOI_Exit
.01a0ad					_FPUTOI_Zero:
.01a0ad	a9 00		lda #$00			lda 	#0 							; return zero integer.
.01a0af	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a0b1	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a0b3	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a0b5	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a0b7					_FPUToI_Exit:
.01a0b7	a9 01		lda #$01			lda 	#1 							; set type to integer
.01a0b9	95 85		sta $85,x			sta 	XS_Type,x
.01a0bb	68		pla				pla
.01a0bc	60		rts				rts
.01a0bd					FP_Overflow:
.01a0bd	20 57 85	jsr $018557			jsr ERR_Handler
>01a0c0	46 6c 6f 61 74 69 6e 67			.text "Floating Point overflow",0
>01a0c8	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.01a0d8					FPUTimes10:
.01a0d8	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.01a0da	85 1a		sta $1a				sta 	ZLTemp1+0
.01a0dc	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a0de	85 1b		sta $1b				sta 	ZLTemp1+1
.01a0e0	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a0e2	85 1c		sta $1c				sta 	ZLTemp1+2
.01a0e4	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a0e6	85 1d		sta $1d				sta 	ZLTemp1+3
.01a0e8	20 1d a1	jsr $01a11d			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.01a0eb	20 1d a1	jsr $01a11d			jsr 	_FPUT_LSR_ZLTemp1
.01a0ee	18		clc				clc
.01a0ef	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.01a0f1	65 1a		adc $1a				adc 	ZLTemp1+0
.01a0f3	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a0f5	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a0f7	65 1b		adc $1b				adc 	ZLTemp1+1
.01a0f9	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a0fb	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a0fd	65 1c		adc $1c				adc 	ZLTemp1+2
.01a0ff	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a101	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a103	65 1d		adc $1d				adc 	ZLTemp1+3
.01a105	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a107	90 0a		bcc $01a113			bcc 	_FPUTimes10
.01a109	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.01a10b	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a10d	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a10f	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a111	f6 84		inc $84,x			inc 	XS_Exponent,x				; fix exponent
.01a113					_FPUTimes10:
.01a113	b5 84		lda $84,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.01a115	18		clc				clc
.01a116	69 03		adc #$03			adc 	#3
.01a118	95 84		sta $84,x			sta 	XS_Exponent,x
.01a11a	b0 a1		bcs $01a0bd			bcs 	FP_Overflow 				; error
.01a11c	60		rts				rts
.01a11d					_FPUT_LSR_ZLTemp1:
.01a11d	46 1d		lsr $1d				lsr 	ZLTemp1+3
.01a11f	66 1c		ror $1c				ror 	ZLTemp1+2
.01a121	66 1b		ror $1b				ror 	ZLTemp1+1
.01a123	66 1a		ror $1a				ror 	ZLTemp1+0
.01a125	60		rts				rts
.01a126					FPUScale10A:
.01a126	5a		phy				phy
.01a127	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.01a129	f0 37		beq $01a162			beq 	_FPUScaleExit
.01a12b	da		phx				phx 								; save X
.01a12c	e8		inx				inx
.01a12d	e8		inx				inx
.01a12e	e8		inx				inx
.01a12f	e8		inx				inx
.01a130	e8		inx				inx
.01a131	e8		inx				inx
.01a132	a8		tay				tay 								; save power scalar in Y.
.01a133	a9 00		lda #$00			lda 	#0
.01a135	95 80		sta $80,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.01a137	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a139	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a13b	95 85		sta $85,x			sta 	XS_Type,x
.01a13d	a9 80		lda #$80			lda 	#$80
.01a13f	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a141	a9 81		lda #$81			lda 	#$81
.01a143	95 84		sta $84,x			sta 	XS_Exponent,x
.01a145	5a		phy				phy 								; save 10^n on stack.
.01a146	c0 00		cpy #$00			cpy 	#0
.01a148	10 05		bpl $01a14f			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.01a14a	98		tya				tya
.01a14b	49 ff		eor #$ff			eor 	#$FF
.01a14d	1a		inc a				inc 	a
.01a14e	a8		tay				tay
.01a14f					_FPUSAbs:
.01a14f	20 d8 a0	jsr $01a0d8			jsr 	FPUTimes10
.01a152	88		dey				dey
.01a153	d0 fa		bne $01a14f			bne 	_FPUSAbs 					; tos is now 10^|AC|
.01a155	68		pla				pla 								; restore count in A
.01a156	fa		plx				plx 								; restore X pointing to number to scale.
.01a157	0a		asl a				asl 	a
.01a158	b0 05		bcs $01a15f			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.01a15a	20 7a 9e	jsr $019e7a			jsr 	FPMultiply 					; if clear multiply.
.01a15d	80 03		bra $01a162			bra		_FPUScaleExit
.01a15f					_FPUSDivide:
.01a15f	20 07 9e	jsr $019e07			jsr 	FPDivide
.01a162					_FPUScaleExit:
.01a162	7a		ply				ply
.01a163	60		rts				rts
.01a164					FPUCopyToNext:
.01a164	a0 06		ldy #$06			ldy 		#6
.01a166	da		phx				phx
.01a167					_FPUCopy1:
.01a167	b5 80		lda $80,x			lda 	XS_Mantissa,x
.01a169	95 86		sta $86,x			sta 	XS2_Mantissa,x
.01a16b	e8		inx				inx
.01a16c	88		dey				dey
.01a16d	d0 f8		bne $01a167			bne 	_FPUCopy1
.01a16f	fa		plx				plx
.01a170	60		rts				rts
.01a171					FPUCopyFromNext:
.01a171	a0 06		ldy #$06			ldy 		#6
.01a173	da		phx				phx
.01a174					_FPUCopy1:
.01a174	b5 86		lda $86,x			lda 	XS2_Mantissa,x
.01a176	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a178	e8		inx				inx
.01a179	88		dey				dey
.01a17a	d0 f8		bne $01a174			bne 	_FPUCopy1
.01a17c	fa		plx				plx
.01a17d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.01a17e					FPToString:
.01a17e	48		pha				pha
.01a17f	5a		phy				phy
.01a180	34 85		bit $85,x			bit 		XS_Type,x 				; check zero flag
.01a182	50 0a		bvc $01a18e			bvc 		_FPTSIsFloat 			; if zero,
.01a184					_FPTSZero:
.01a184	a9 30		lda #$30			lda 		#"0"
.01a186	20 a8 9c	jsr $019ca8			jsr 		ITSOutputCharacter
.01a189					_FPTSExit:
.01a189	7a		ply				ply
.01a18a	68		pla				pla
.01a18b	60		rts				rts
.01a18c	80 fb		bra $01a189			bra 		_FPTSExit
.01a18e					_FPTSIsFloat:
.01a18e	b5 85		lda $85,x			lda 		XS_Type,x 				; is it signed ?
.01a190	10 09		bpl $01a19b			bpl 		_FPTSNotSigned
.01a192	a9 00		lda #$00			lda 		#0 						; clear sign flag
.01a194	95 85		sta $85,x			sta 		XS_Type,x
.01a196	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.01a198	20 a8 9c	jsr $019ca8			jsr 		ITSOutputCharacter
.01a19b					_FPTSNotSigned:
.01a19b	b5 84		lda $84,x			lda 		XS_Exponent,x
.01a19d	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.01a19f	b0 09		bcs $01a1aa			bcs 		_FPTSExponent
.01a1a1	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.01a1a3	90 05		bcc $01a1aa			bcc 		_FPTSExponent 			;
.01a1a5					_FPTSStandard:
.01a1a5	20 e9 a1	jsr $01a1e9			jsr 		FPTOutputBody 			; output the body.
.01a1a8	80 df		bra $01a189			bra 		_FPTSExit
.01a1aa					_FPTSExponent:
.01a1aa	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.01a1ac	8d 9d 03	sta $039d			sta 		ExpCount
.01a1af					_FPTSExponentLoop:
.01a1af	b5 84		lda $84,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.01a1b1	10 0e		bpl $01a1c1			bpl 		_FPTSTimes
.01a1b3	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.01a1b5	90 14		bcc $01a1cb			bcc 		_FPTSScaledToExp
.01a1b7	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.01a1b9	20 26 a1	jsr $01a126			jsr 		FPUScale10A
.01a1bc	ee 9d 03	inc $039d			inc 		ExpCount
.01a1bf	80 ee		bra $01a1af			bra 		_FPTSExponentLoop
.01a1c1					_FPTSTimes:
.01a1c1	a9 01		lda #$01			lda 		#1
.01a1c3	20 26 a1	jsr $01a126			jsr 		FPUScale10A
.01a1c6	ce 9d 03	dec $039d			dec 		ExpCount
.01a1c9	80 e4		bra $01a1af			bra 		_FPTSExponentLoop
.01a1cb					_FPTSScaledToExp:
.01a1cb	20 e9 a1	jsr $01a1e9			jsr 		FPTOutputBody 			; output the body.
.01a1ce	a9 65		lda #$65			lda 		#"e"					; output E
.01a1d0	20 a8 9c	jsr $019ca8			jsr 		ITSOutputCharacter
.01a1d3	ad 9d 03	lda $039d			lda 		ExpCount 				; get the exponent
.01a1d6	95 80		sta $80,x			sta 		XS_Mantissa,x
.01a1d8	29 80		and #$80			and 		#$80 					; sign extend it
.01a1da	f0 02		beq $01a1de			beq 		_FPTSSExt
.01a1dc	a9 ff		lda #$ff			lda 		#$FF
.01a1de					_FPTSSExt:
.01a1de	95 81		sta $81,x			sta 		XS_Mantissa+1,x
.01a1e0	95 82		sta $82,x			sta 		XS_Mantissa+2,x
.01a1e2	95 83		sta $83,x			sta 		XS_Mantissa+3,x
.01a1e4	20 06 9c	jsr $019c06			jsr 		INTToString 			; output the exponent.
.01a1e7	80 a0		bra $01a189			bra			_FPTSExit 				; and exit.
.01a1e9					FPTOutputBody:
.01a1e9	20 64 a1	jsr $01a164			jsr 		FPUCopyToNext 			; copy to next slot.
.01a1ec	20 7f a0	jsr $01a07f			jsr 		FPUToInteger 			; convert to an integer
.01a1ef	20 06 9c	jsr $019c06			jsr 		INTToString 			; output the main integer part.
.01a1f2	20 71 a1	jsr $01a171			jsr 		FPUCopyFromNext 		; get the fractional part back.
.01a1f5	20 02 9f	jsr $019f02			jsr 		FPFractionalPart 		; get the decimal part.
.01a1f8	34 85		bit $85,x			bit 		XS_Type,x 				; any fractional part.
.01a1fa	70 3c		bvs $01a238			bvs 		_FPTOExit 				; if not, exit now.
.01a1fc	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.01a1fe	20 a8 9c	jsr $019ca8			jsr 		ITSOutputCharacter
.01a201					_FPOutLoop:
.01a201	34 85		bit $85,x			bit 		XS_Type,x 				; finally reached zero.
.01a203	70 1d		bvs $01a222			bvs 		_FPStripZeros 			; strip trailing zeros
.01a205	20 d8 a0	jsr $01a0d8			jsr 		FPUTimes10 				; multiply by 10
.01a208	20 64 a1	jsr $01a164			jsr 		FPUCopyToNext			; copy to next slot.
.01a20b	20 7f a0	jsr $01a07f			jsr 		FPUToInteger 			; convert to integer
.01a20e	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; print digit.
.01a210	09 30		ora #$30			ora 		#"0"
.01a212	20 a8 9c	jsr $019ca8			jsr 		ITSOutputCharacter
.01a215	20 71 a1	jsr $01a171			jsr 		FPUCopyFromNext 		; get it back
.01a218	20 02 9f	jsr $019f02			jsr 		FPFractionalPart 		; get fractional part
.01a21b	ad 14 03	lda $0314			lda 		NumBufX 				; done 11 characters yet ?
.01a21e	c9 0b		cmp #$0b			cmp 	 	#11
.01a220	90 df		bcc $01a201			bcc 		_FPOutLoop 				; if so, keep going till zero.
.01a222					_FPStripZeros:
.01a222	ac 14 03	ldy $0314			ldy 		NumBufX 				; strip trailing zeros.
.01a225					_FPStripLoop:
.01a225	88		dey				dey 								; back one, if at start then no strip
.01a226	f0 10		beq $01a238			beq 		_FPToExit
.01a228	b9 15 03	lda $0315,y			lda 		Num_Buffer,y 			; keep going if "0"
.01a22b	c9 30		cmp #$30			cmp 		#"0"
.01a22d	f0 f6		beq $01a225			beq 		_FPStripLoop
.01a22f	c8		iny				iny
.01a230	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.01a232	99 15 03	sta $0315,y			sta 		Num_Buffer,y
.01a235	8c 14 03	sty $0314			sty 		NumBufX 				; update position.
.01a238					_FPTOExit:
.01a238	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.01a239					FPFromString:
.01a239	48		pha				pha 								; push A
.01a23a	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.01a23c	c9 2e		cmp #$2e			cmp 	#"."
.01a23e	f0 03		beq $01a243			beq	 	_FPFIsDecimal
.01a240	4c 9f a2	jmp $01a29f			jmp 	_FPFNotDecimal
.01a243					_FPFIsDecimal:
.01a243	c8		iny				iny 								; consume the decimal.
.01a244	20 33 a0	jsr $01a033			jsr 	FPUToFloat 					; convert the integer to float.
.01a247	da		phx				phx 								; save X.
.01a248	5a		phy				phy 								; save decimal start position
.01a249	e8		inx				inx
.01a24a	e8		inx				inx
.01a24b	e8		inx				inx
.01a24c	e8		inx				inx
.01a24d	e8		inx				inx
.01a24e	e8		inx				inx
.01a24f	20 c0 9c	jsr $019cc0			jsr 	INTFromStringY 				; get the part after the DP.
.01a252	20 33 a0	jsr $01a033			jsr 	FPUToFloat 					; convert that to a float.
.01a255	68		pla				pla 								; calculate - chars consumed.
.01a256	8c 9c 03	sty $039c			sty 	ExpTemp
.01a259	38		sec				sec
.01a25a	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; this is the shift amount
.01a25d	20 26 a1	jsr $01a126			jsr 	FPUScale10A 				; scale it by 10^AC
.01a260	fa		plx				plx 								; restore original X
.01a261	20 53 9d	jsr $019d53			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.01a264	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.01a266	c9 45		cmp #$45			cmp 	#"E"
.01a268	f0 04		beq $01a26e			beq 	_FPFExponent
.01a26a	c9 65		cmp #$65			cmp 	#"e"
.01a26c	d0 31		bne $01a29f			bne 	_FPFNotDecimal 				; no, then exit normally.
.01a26e					_FPFExponent:
.01a26e	c8		iny				iny 								; skip over E symbol.
.01a26f	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.01a271	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.01a273	d0 01		bne $01a276			bne 	_FPFGotSign
.01a275	c8		iny				iny 								; if it was - skip over it.
.01a276					_FPFGotSign:
.01a276	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.01a277	da		phx				phx
.01a278	e8		inx				inx
.01a279	e8		inx				inx
.01a27a	e8		inx				inx
.01a27b	e8		inx				inx
.01a27c	e8		inx				inx
.01a27d	e8		inx				inx
.01a27e	20 c0 9c	jsr $019cc0			jsr 	INTFromStringY 				; get the exponent
.01a281	fa		plx				plx 								; restore X.
.01a282	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.01a284	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.01a286	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.01a288	d0 17		bne $01a2a1			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.01a28a	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.01a28c	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.01a28e	b0 11		bcs $01a2a1			bcs 	_FPFXOverflow
.01a290	68		pla				pla 								; get direction
.01a291	d0 07		bne $01a29a			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.01a293	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.01a295	49 ff		eor #$ff			eor 	#$FF
.01a297	1a		inc a				inc 	a
.01a298	95 86		sta $86,x			sta 	XS2_Mantissa+0,x
.01a29a					_FPFXScale:
.01a29a	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.01a29c	20 26 a1	jsr $01a126			jsr 	FPUScale10A 				; scale by the exponent.
.01a29f					_FPFNotDecimal:
.01a29f	68		pla				pla
.01a2a0	60		rts				rts
.01a2a1					_FPFXOverflow:
.01a2a1	20 57 85	jsr $018557			jsr 	ERR_Handler
>01a2a4	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>01a2ac	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.01a2b3					Unary_Rnd:
.01a2b3	20 4f 90	jsr $01904f			jsr 	EvaluateNumberX 			; get value
.01a2b6	20 83 96	jsr $019683			jsr 	CheckNextRParen 			; check right bracket.
.01a2b9	20 cd 92	jsr $0192cd			jsr 	GetSignCurrent 				; get sign -1,0,1.
.01a2bc	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.01a2be	30 10		bmi $01a2d0			bmi 	_URSetSeed
.01a2c0	f0 28		beq $01a2ea			beq 	_URMakeRandom 				; if zero return same number.
.01a2c2	da		phx				phx
.01a2c3	a2 00		ldx #$00			ldx 	#0
.01a2c5	20 21 a3	jsr $01a321			jsr 	Random16
.01a2c8	a2 02		ldx #$02			ldx 	#2
.01a2ca	20 21 a3	jsr $01a321			jsr 	Random16
.01a2cd	fa		plx				plx
.01a2ce	80 1a		bra $01a2ea			bra 	_URMakeRandom
.01a2d0					_URSetSeed:
.01a2d0	20 33 a0	jsr $01a033			jsr 	FPUToFloat 					; make it a float to twiddle it.
.01a2d3	b5 80		lda $80,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.01a2d5	8d a3 03	sta $03a3			sta 	RandomSeed+0
.01a2d8	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.01a2da	8d a4 03	sta $03a4			sta 	RandomSeed+1
.01a2dd	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.01a2df	8d a5 03	sta $03a5			sta 	RandomSeed+2
.01a2e2	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.01a2e4	0a		asl a				asl 	a
.01a2e5	49 db		eor #$db			eor 	#$DB
.01a2e7	8d a6 03	sta $03a6			sta 	RandomSeed+3
.01a2ea					_URMakeRandom:
.01a2ea	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; check if seed is zero.
.01a2ed	0d a4 03	ora $03a4			ora 	RandomSeed+1
.01a2f0	0d a5 03	ora $03a5			ora 	RandomSeed+2
.01a2f3	0d a6 03	ora $03a6			ora 	RandomSeed+3
.01a2f6	d0 0a		bne $01a302			bne 	_URNotZero
.01a2f8	a9 47		lda #$47			lda 	#$47
.01a2fa	8d a4 03	sta $03a4			sta 	RandomSeed+1				; if it is, make it non zero.
.01a2fd	a9 3d		lda #$3d			lda 	#$3D
.01a2ff	8d a6 03	sta $03a6			sta 	RandomSeed+3
.01a302					_URNotZero:
.01a302	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; copy seed into mantissa.
.01a305	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a307	ad a4 03	lda $03a4			lda 	RandomSeed+1
.01a30a	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a30c	ad a5 03	lda $03a5			lda 	RandomSeed+2
.01a30f	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a311	ad a6 03	lda $03a6			lda 	RandomSeed+3
.01a314	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a316	a9 00		lda #$00			lda 	#$00 						; set type to float.
.01a318	95 85		sta $85,x			sta 	XS_Type,x
.01a31a	a9 80		lda #$80			lda 	#$80
.01a31c	95 84		sta $84,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.01a31e	4c 60 a0	jmp $01a060			jmp 	FPUNormalise
.01a321					Random16:
.01a321	5e a4 03	lsr $03a4,x			lsr 	RandomSeed+1,x				; shift seed right
.01a324	7e a3 03	ror $03a3,x			ror 	RandomSeed,x
.01a327	90 08		bcc $01a331			bcc 	_R16_NoXor
.01a329	bd a4 03	lda $03a4,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.01a32c	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.01a32e	9d a4 03	sta $03a4,x			sta 	RandomSeed+1,x
.01a331					_R16_NoXor:
.01a331	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.01a332					Unary_Int:
.01a332	20 4f 90	jsr $01904f			jsr 	EvaluateNumberX 			; get value
.01a335	20 83 96	jsr $019683			jsr 	CheckNextRParen 			; check right bracket.
.01a338	4c 7f a0	jmp $01a07f			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Return to file: basic.asm

>01a33b	02						.byte 	2
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 c0						.word 	StartROM
>fffe	19 c0					.word TIM_BreakHandler

;******  End of listing
