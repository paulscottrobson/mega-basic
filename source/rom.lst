
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Thu Aug 29 11:51:51 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="65816"				cpu = "65816"
="em65816"				hardware = "em65816"
=1					exitonend = 1
=1					autorun = 1
=3					loadtest = 3
=1					hasfloat = 1
=1					hasinteger = 1
=253					maxstring = 253

;******  Processing file: modules/float/fpmacros.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/em65816/src_em65816.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stackmarkers.inc

=5					SourcePosSize   =   5 							; Source position stack space needed.
=0					SMark_Gosub 	= 	0 							; 0 is GOSUB/RETURN
=1					SMark_Repeat 	= 	1 							; 1 is REPEAT/UNTIL.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0020					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0022					zVarDataPtr: .word ? 						; position of variable data.
>0024					zVarType: 	.byte ? 						; type of data (token)
>0025					zNullString:.byte ? 						; represents a NULL string.
>0026					zBasicSP:	.word ? 						; stack pointer
>0080					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>0084					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>0085					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=134					XS2_Mantissa = XS_Mantissa+XS_Size
=138					XS2_Exponent = XS_Exponent+XS_Size
=139					XS2_Type = XS_Type+XS_Size
=140					XS3_Mantissa = XS_Mantissa+XS_Size*2
=144					XS3_Exponent = XS_Exponent+XS_Size*2
=145					XS3_Type = XS_Type+XS_Size*2
>0300					StringPtr:	.word ? 						; Top of free memory (for string allocation)
>0302					VarMemPtr: 	.word ?							; Bottom of free memory (for variables)
>0304					endOfProgram: .dword ? 						; End of Program Memory (long)
>0308					vecPrintCharacter .word ?
>030a					vecInputCharacter .word ?
>030c					UserVector .fill 4 							; USR(x) calls this.
>0310					LocalVector .fill 4 						; Indirect calls call this.
>0314					NumBufX 	.byte 	?						; buffer index position
>0315					Num_Buffer	.fill 	32 						; buffer for numeric conversions
=6					HashTableCount = 6 							; there are 6 hash tables, in token order.
=8					HashTableSize = 8 							; each hash table as 8 links.
.0335					HashTableBase:
>0335								.fill	HashTableCount * HashTableSize * 2
.0395					HashTableEnd:
=$315					Var_Buffer 	= Num_Buffer 					; buffer for variable name (same space)
>0395					Var_Type    .byte ? 						; type of variable (as a type token)
>0396					Var_Hash 	.byte ? 						; hash of identifier name.
>0397					Var_Length 	.byte ? 						; length of variable name
>0398					Var_HashAddress .byte ?						; low byte of hash table entry.
>0399					Var_DataSize .byte ?						; size of one element.
>039a					NumSuppress	.byte 	?						; leading zero suppression flag
>039b					NumConvCount .byte 	? 						; count for conversions.
>039c					ExpTemp:	.byte ?							; Working temp for exponents.
>039d					ExpCount:	.byte ? 						; Count of decimal exponents.
>039e					SignCount:	.byte ?							; Integer Divide Sign Counts.
>039f					TempStringWriteIndex: .byte ? 				; Write offset.
>03a0					ValSign: 	.byte ? 						; sign flag for val()
>03a1					SliceStart:	.byte ? 						; string slice parts
>03a2					SliceCount:	.byte ?
>03a3					RandomSeed:	.dword ? 						; Random seed.
>03a7					BreakCount:	.byte ? 						; Counter, avoid checking break every command.
=3					ArrayMaxDim = 3 							; number of dimensions.
>03a8					ArrayDef:	.fill (ArrayMaxDim+1)*2 		; dimensions for auto-creation
>03b0					UsrArrayDef:.fill (ArrayMaxDim+1)*2 		; dimensions created in DIM
>03b8					UsrArrayIdx:.byte ? 						; index into UsrArrayDef
>03b9					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>03bb					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>03bd					Tim_SR:		.byte ? 						; Processor Status
>03be					Tim_A:		.byte ? 						; Processor Registers
>03bf					Tim_X:		.byte ?
>03c0					Tim_Y:		.byte ?
>03c1					Tim_Z:		.byte ?
>03c2					Tim_SP:		.word ?							; Stack Pointer (just in cases)
>0400					BasicStack:	.fill 	256 					; and occupy whole pages.
.0500					EndBasicStack:
>0500					IFT_XCursor:.byte ?							; current logical position on screen
>0501					IFT_YCursor:.byte ?
>0502					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0566					IFT_LineBuffer: .fill 100 					; line input buffer.

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/em65816.asm

=$7f00					HighMemory = $7F00
=$3000					VariableMemory = $3000
.1000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testassign.src

>1000	05 0a 00 d0 00 0c 14 00			.byte	$05,$0a,$00,$d0,$00,$0c,$14,$00
>1008	c7 14 34 08 1a ba 42 be			.byte	$c7,$14,$34,$08,$1a,$ba,$42,$be
>1010	00 0f 1e 00 c7 08 37 18			.byte	$00,$0f,$1e,$00,$c7,$08,$37,$18
>1018	07 09 ba 41 bf 41 be 00			.byte	$07,$09,$ba,$41,$bf,$41,$be,$00
>1020	09 28 00 c7 12 ba 42 be			.byte	$09,$28,$00,$c7,$12,$ba,$42,$be
>1028	00 0d 32 00 c7 14 38 04			.byte	$00,$0d,$32,$00,$c7,$14,$38,$04
>1030	0a 07 b8 41 be 00 0c 3c			.byte	$0a,$07,$b8,$41,$be,$00,$0c,$3c
>1038	00 c7 06 37 02 01 bc 42			.byte	$00,$c7,$06,$37,$02,$01,$bc,$42
>1040	be 00 0d 46 00 c7 10 31			.byte	$be,$00,$0d,$46,$00,$c7,$10,$31
>1048	04 15 15 bc 42 be 00 0f			.byte	$04,$15,$15,$bc,$42,$be,$00,$0f
>1050	50 00 c7 17 34 14 09 04			.byte	$50,$00,$c7,$17,$34,$14,$09,$04
>1058	bd 41 bf 41 be 00 0c 5a			.byte	$bd,$41,$bf,$41,$be,$00,$0c,$5a
>1060	00 c7 02 36 07 0b b8 42			.byte	$00,$c7,$02,$36,$07,$0b,$b8,$42
>1068	be 00 0c 64 00 c7 09 39			.byte	$be,$00,$0c,$64,$00,$c7,$09,$39
>1070	19 0f b8 42 be 00 0c 6e			.byte	$19,$0f,$b8,$42,$be,$00,$0c,$6e
>1078	00 c7 12 39 0e 0d ba 42			.byte	$00,$c7,$12,$39,$0e,$0d,$ba,$42
>1080	be 00 0c 78 00 c7 16 31			.byte	$be,$00,$0c,$78,$00,$c7,$16,$31
>1088	16 1a ba 42 be 00 0c 82			.byte	$16,$1a,$ba,$42,$be,$00,$0c,$82
>1090	00 c7 02 37 10 0b b8 42			.byte	$00,$c7,$02,$37,$10,$0b,$b8,$42
>1098	be 00 0f 8c 00 cf 17 84			.byte	$be,$00,$0f,$8c,$00,$cf,$17,$84
>10a0	46 67 fd 06 30 36 32 35			.byte	$46,$67,$fd,$06,$30,$36,$32,$35
>10a8	00 0f 96 00 cf 0f 31 0d			.byte	$00,$0f,$96,$00,$cf,$0f,$31,$0d
>10b0	15 10 bb 84 8b 4c 63 00			.byte	$15,$10,$bb,$84,$8b,$4c,$63,$00
>10b8	11 a0 00 cf 0e b9 84 8b			.byte	$11,$a0,$00,$cf,$0e,$b9,$84,$8b
>10c0	43 56 fd 06 35 36 32 35			.byte	$43,$56,$fd,$06,$35,$36,$32,$35
>10c8	00 0c aa 00 cf 17 37 17			.byte	$00,$0c,$aa,$00,$cf,$17,$37,$17
>10d0	bb 84 4e 50 00 10 b4 00			.byte	$bb,$84,$4e,$50,$00,$10,$b4,$00
>10d8	cf 02 37 10 0b b8 42 be			.byte	$cf,$02,$37,$10,$0b,$b8,$42,$be
>10e0	84 fe 03 4f 00 11 be 00			.byte	$84,$fe,$03,$4f,$00,$11,$be,$00
>10e8	cf 02 37 10 0b b8 40 be			.byte	$cf,$02,$37,$10,$0b,$b8,$40,$be
>10f0	84 fe 04 58 30 00 11 c8			.byte	$84,$fe,$04,$58,$30,$00,$11,$c8
>10f8	00 cf 05 30 09 84 45 65			.byte	$00,$cf,$05,$30,$09,$84,$45,$65
>1100	fd 06 30 36 32 35 00 0f			.byte	$fd,$06,$30,$36,$32,$35,$00,$0f
>1108	d2 00 cf 01 38 17 18 84			.byte	$d2,$00,$cf,$01,$38,$17,$18,$84
>1110	45 71 fd 03 35 00 10 dc			.byte	$45,$71,$fd,$03,$35,$00,$10,$dc
>1118	00 cf 08 32 10 17 b7 84			.byte	$00,$cf,$08,$32,$10,$17,$b7,$84
>1120	fe 05 4f 30 5a 00 0e e6			.byte	$fe,$05,$4f,$30,$5a,$00,$0e,$e6
>1128	00 cf 0f 31 0d 15 10 bb			.byte	$00,$cf,$0f,$31,$0d,$15,$10,$bb
>1130	84 48 6a 00 0f f0 00 cf			.byte	$84,$48,$6a,$00,$0f,$f0,$00,$cf
>1138	0e b9 84 48 55 fd 05 38			.byte	$0e,$b9,$84,$48,$55,$fd,$05,$38
>1140	37 35 00 13 fa 00 cf 0f			.byte	$37,$35,$00,$13,$fa,$00,$cf,$0f
>1148	32 07 15 0f b7 84 fe 07			.byte	$32,$07,$15,$0f,$b7,$84,$fe,$07
>1150	57 39 44 48 49 00 0d 04			.byte	$57,$39,$44,$48,$49,$00,$0d,$04
>1158	01 cf 0a 33 0e 0e bb 84			.byte	$01,$cf,$0a,$33,$0e,$0e,$bb,$84
>1160	46 7b 00 0e 0e 01 cf 0a			.byte	$46,$7b,$00,$0e,$0e,$01,$cf,$0a
>1168	33 0e 0e bb 84 8b 44 50			.byte	$33,$0e,$0e,$bb,$84,$8b,$44,$50
>1170	00 0e 18 01 cf 07 b7 84			.byte	$00,$0e,$18,$01,$cf,$07,$b7,$84
>1178	fe 06 55 38 4e 46 00 0c			.byte	$fe,$06,$55,$38,$4e,$46,$00,$0c
>1180	22 01 cf 0d 34 03 bb 84			.byte	$22,$01,$cf,$0d,$34,$03,$bb,$84
>1188	43 67 00 13 2c 01 cf 05			.byte	$43,$67,$00,$13,$2c,$01,$cf,$05
>1190	33 0b 0b b9 84 8b 41 4c			.byte	$33,$0b,$0b,$b9,$84,$8b,$41,$4c
>1198	fd 05 38 37 35 00 0f 36			.byte	$fd,$05,$38,$37,$35,$00,$0f,$36
>11a0	01 cf 03 38 0e b7 84 fe			.byte	$01,$cf,$03,$38,$0e,$b7,$84,$fe
>11a8	05 52 33 57 00 13 40 01			.byte	$05,$52,$33,$57,$00,$13,$40,$01
>11b0	cf 04 35 02 1a b9 84 49			.byte	$cf,$04,$35,$02,$1a,$b9,$84,$49
>11b8	58 fd 06 31 38 37 35 00			.byte	$58,$fd,$06,$31,$38,$37,$35,$00
>11c0	0d 4a 01 cf 0e b9 84 46			.byte	$0d,$4a,$01,$cf,$0e,$b9,$84,$46
>11c8	4c fd 03 30 00 11 54 01			.byte	$4c,$fd,$03,$30,$00,$11,$54,$01
>11d0	cf 10 37 0d 03 06 b7 84			.byte	$cf,$10,$37,$0d,$03,$06,$b7,$84
>11d8	fe 05 57 34 43 00 10 5e			.byte	$fe,$05,$57,$34,$43,$00,$10,$5e
>11e0	01 cf 0e 32 13 84 8b 41			.byte	$01,$cf,$0e,$32,$13,$84,$8b,$41
>11e8	5f fd 04 32 35 00 15 68			.byte	$5f,$fd,$04,$32,$35,$00,$15,$68
>11f0	01 cf 14 34 08 1a ba 40			.byte	$01,$cf,$14,$34,$08,$1a,$ba,$40
>11f8	be 84 8b 48 51 fd 05 36			.byte	$be,$84,$8b,$48,$51,$fd,$05,$36
>1200	32 35 00 10 72 01 cf 0a			.byte	$32,$35,$00,$10,$72,$01,$cf,$0a
>1208	39 06 84 8b 48 53 fd 04			.byte	$39,$06,$84,$8b,$48,$53,$fd,$04
>1210	32 35 00 18 7c 01 cf 17			.byte	$32,$35,$00,$18,$7c,$01,$cf,$17
>1218	34 14 09 04 bd 40 bf 40			.byte	$34,$14,$09,$04,$bd,$40,$bf,$40
>1220	be 84 42 74 fd 06 35 36			.byte	$be,$84,$42,$74,$fd,$06,$35,$36
>1228	32 35 00 0e 86 01 cf 1a			.byte	$32,$35,$00,$0e,$86,$01,$cf,$1a
>1230	32 15 08 0e bb 84 49 75			.byte	$32,$15,$08,$0e,$bb,$84,$49,$75
>1238	00 13 90 01 cf 19 32 1a			.byte	$00,$13,$90,$01,$cf,$19,$32,$1a
>1240	09 0f b7 84 fe 07 57 34			.byte	$09,$0f,$b7,$84,$fe,$07,$57,$34
>1248	4f 55 49 00 13 9a 01 cf			.byte	$4f,$55,$49,$00,$13,$9a,$01,$cf
>1250	12 ba 41 be 84 8b 42 6a			.byte	$12,$ba,$41,$be,$84,$8b,$42,$6a
>1258	fd 06 30 36 32 35 00 11			.byte	$fd,$06,$30,$36,$32,$35,$00,$11
>1260	a4 01 cf 08 32 10 17 b7			.byte	$a4,$01,$cf,$08,$32,$10,$17,$b7
>1268	84 fe 06 52 30 4c 53 00			.byte	$84,$fe,$06,$52,$30,$4c,$53,$00
>1270	10 ae 01 cf 18 30 16 17			.byte	$10,$ae,$01,$cf,$18,$30,$16,$17
>1278	b7 84 fe 05 46 36 4d 00			.byte	$b7,$84,$fe,$05,$46,$36,$4d,$00
>1280	11 b8 01 cf 07 34 16 07			.byte	$11,$b8,$01,$cf,$07,$34,$16,$07
>1288	b9 84 45 6e fd 04 37 35			.byte	$b9,$84,$45,$6e,$fd,$04,$37,$35
>1290	00 0d c2 01 cf 02 33 17			.byte	$00,$0d,$c2,$01,$cf,$02,$33,$17
>1298	bb 84 8b 46 75 00 14 cc			.byte	$bb,$84,$8b,$46,$75,$00,$14,$cc
>12a0	01 cf 01 38 17 03 0b 84			.byte	$01,$cf,$01,$38,$17,$03,$0b,$84
>12a8	8b 46 73 fd 06 35 36 32			.byte	$8b,$46,$73,$fd,$06,$35,$36,$32
>12b0	35 00 14 d6 01 cf 0c 39			.byte	$35,$00,$14,$d6,$01,$cf,$0c,$39
>12b8	08 15 0f 84 8b 49 5d fd			.byte	$08,$15,$0f,$84,$8b,$49,$5d,$fd
>12c0	06 31 38 37 35 00 0d e0			.byte	$06,$31,$38,$37,$35,$00,$0d,$e0
>12c8	01 cf 03 37 17 bb 84 8b			.byte	$01,$cf,$03,$37,$17,$bb,$84,$8b
>12d0	49 6b 00 0d ea 01 cf 08			.byte	$49,$6b,$00,$0d,$ea,$01,$cf,$08
>12d8	b7 84 fe 05 45 39 56 00			.byte	$b7,$84,$fe,$05,$45,$39,$56,$00
>12e0	0e f4 01 cf 02 35 08 10			.byte	$0e,$f4,$01,$cf,$02,$35,$08,$10
>12e8	bb 84 8b 49 62 00 0e fe			.byte	$bb,$84,$8b,$49,$62,$00,$0e,$fe
>12f0	01 cf 14 34 12 18 b7 84			.byte	$01,$cf,$14,$34,$12,$18,$b7,$84
>12f8	fe 03 51 00 0f 08 02 cf			.byte	$fe,$03,$51,$00,$0f,$08,$02,$cf
>1300	03 32 08 12 0c bb 84 8b			.byte	$03,$32,$08,$12,$0c,$bb,$84,$8b
>1308	4d 6b 00 13 12 02 cf 0d			.byte	$4d,$6b,$00,$13,$12,$02,$cf,$0d
>1310	35 08 06 0d 84 41 52 fd			.byte	$35,$08,$06,$0d,$84,$41,$52,$fd
>1318	06 31 38 37 35 00 13 1c			.byte	$06,$31,$38,$37,$35,$00,$13,$1c
>1320	02 cf 0e 33 11 05 b9 84			.byte	$02,$cf,$0e,$33,$11,$05,$b9,$84
>1328	8b 42 68 fd 05 38 37 35			.byte	$8b,$42,$68,$fd,$05,$38,$37,$35
>1330	00 12 26 02 cf 07 38 05			.byte	$00,$12,$26,$02,$cf,$07,$38,$05
>1338	06 b7 84 fe 07 58 33 52			.byte	$06,$b7,$84,$fe,$07,$58,$33,$52
>1340	54 4c 00 0f 30 02 cf 02			.byte	$54,$4c,$00,$0f,$30,$02,$cf,$02
>1348	37 10 0b b8 40 be 84 fe			.byte	$37,$10,$0b,$b8,$40,$be,$84,$fe
>1350	02 00 0f 3a 02 cf 0f 34			.byte	$02,$00,$0f,$3a,$02,$cf,$0f,$34
>1358	12 19 b7 84 fe 04 41 37			.byte	$12,$19,$b7,$84,$fe,$04,$41,$37
>1360	00 12 44 02 cf 10 32 01			.byte	$00,$12,$44,$02,$cf,$10,$32,$01
>1368	b9 84 47 57 fd 06 35 36			.byte	$b9,$84,$47,$57,$fd,$06,$35,$36
>1370	32 35 00 11 4e 02 cf 0f			.byte	$32,$35,$00,$11,$4e,$02,$cf,$0f
>1378	32 07 15 0f b7 84 fe 05			.byte	$32,$07,$15,$0f,$b7,$84,$fe,$05
>1380	56 39 53 00 11 58 02 cf			.byte	$56,$39,$53,$00,$11,$58,$02,$cf
>1388	13 37 15 04 b7 84 fe 06			.byte	$13,$37,$15,$04,$b7,$84,$fe,$06
>1390	59 35 49 4a 00 0e 62 02			.byte	$59,$35,$49,$4a,$00,$0e,$62,$02
>1398	cf 03 32 08 12 0c bb 84			.byte	$cf,$03,$32,$08,$12,$0c,$bb,$84
>13a0	43 6b 00 0e 6c 02 cf 01			.byte	$43,$6b,$00,$0e,$6c,$02,$cf,$01
>13a8	37 14 19 b7 84 fe 03 53			.byte	$37,$14,$19,$b7,$84,$fe,$03,$53
>13b0	00 14 76 02 cf 14 30 03			.byte	$00,$14,$76,$02,$cf,$14,$30,$03
>13b8	01 16 b9 84 49 47 fd 06			.byte	$01,$16,$b9,$84,$49,$47,$fd,$06
>13c0	38 31 32 35 00 11 80 02			.byte	$38,$31,$32,$35,$00,$11,$80,$02
>13c8	cf 19 34 15 19 0a b7 84			.byte	$cf,$19,$34,$15,$19,$0a,$b7,$84
>13d0	fe 05 44 37 53 00 0f 8a			.byte	$fe,$05,$44,$37,$53,$00,$0f,$8a
>13d8	02 cf 0f 31 0d 15 10 bb			.byte	$02,$cf,$0f,$31,$0d,$15,$10,$bb
>13e0	84 8b 44 47 00 13 94 02			.byte	$84,$8b,$44,$47,$00,$13,$94,$02
>13e8	cf 08 32 0a 06 b9 84 8b			.byte	$cf,$08,$32,$0a,$06,$b9,$84,$8b
>13f0	47 74 fd 05 36 32 35 00			.byte	$47,$74,$fd,$05,$36,$32,$35,$00
>13f8	0e 9e 02 cf 07 b7 84 fe			.byte	$0e,$9e,$02,$cf,$07,$b7,$84,$fe
>1400	06 59 32 4c 4b 00 0b a8			.byte	$06,$59,$32,$4c,$4b,$00,$0b,$a8
>1408	02 cf 01 bb 84 8b 48 6a			.byte	$02,$cf,$01,$bb,$84,$8b,$48,$6a
>1410	00 12 b2 02 cf 19 32 1a			.byte	$00,$12,$b2,$02,$cf,$19,$32,$1a
>1418	09 0f b7 84 fe 06 5a 39			.byte	$09,$0f,$b7,$84,$fe,$06,$5a,$39
>1420	4f 4f 00 11 bc 02 cf 07			.byte	$4f,$4f,$00,$11,$bc,$02,$cf,$07
>1428	38 05 06 b7 84 fe 06 5a			.byte	$38,$05,$06,$b7,$84,$fe,$06,$5a
>1430	39 45 57 00 0f c6 02 cf			.byte	$39,$45,$57,$00,$0f,$c6,$02,$cf
>1438	1a 32 15 08 0e bb 84 8b			.byte	$1a,$32,$15,$08,$0e,$bb,$84,$8b
>1440	44 59 00 12 d0 02 cf 11			.byte	$44,$59,$00,$12,$d0,$02,$cf,$11
>1448	33 04 84 8b 45 49 fd 06			.byte	$33,$04,$84,$8b,$45,$49,$fd,$06
>1450	35 36 32 35 00 0f da 02			.byte	$35,$36,$32,$35,$00,$0f,$da,$02
>1458	cf 06 37 02 01 bc 42 be			.byte	$cf,$06,$37,$02,$01,$bc,$42,$be
>1460	84 44 7b 00 13 e4 02 cf			.byte	$84,$44,$7b,$00,$13,$e4,$02,$cf
>1468	0b 35 13 11 07 84 8b 48			.byte	$0b,$35,$13,$11,$07,$84,$8b,$48
>1470	40 fd 05 36 32 35 00 0d			.byte	$40,$fd,$05,$36,$32,$35,$00,$0d
>1478	ee 02 cf 14 b7 84 fe 05			.byte	$ee,$02,$cf,$14,$b7,$84,$fe,$05
>1480	54 35 52 00 0e f8 02 cf			.byte	$54,$35,$52,$00,$0e,$f8,$02,$cf
>1488	07 36 18 04 0e bb 84 41			.byte	$07,$36,$18,$04,$0e,$bb,$84,$41
>1490	74 00 12 02 03 cf 07 35			.byte	$74,$00,$12,$02,$03,$cf,$07,$35
>1498	13 84 8b 48 60 fd 06 36			.byte	$13,$84,$8b,$48,$60,$fd,$06,$36
>14a0	38 37 35 00 13 0c 03 cf			.byte	$38,$37,$35,$00,$13,$0c,$03,$cf
>14a8	0a 30 17 1a b9 84 43 69			.byte	$0a,$30,$17,$1a,$b9,$84,$43,$69
>14b0	fd 06 33 31 32 35 00 14			.byte	$fd,$06,$33,$31,$32,$35,$00,$14
>14b8	16 03 cf 01 35 0b 03 13			.byte	$16,$03,$cf,$01,$35,$0b,$03,$13
>14c0	b9 84 48 60 fd 06 31 38			.byte	$b9,$84,$48,$60,$fd,$06,$31,$38
>14c8	37 35 00 12 20 03 cf 0c			.byte	$37,$35,$00,$12,$20,$03,$cf,$0c
>14d0	31 11 19 b9 84 8b 43 4f			.byte	$31,$11,$19,$b9,$84,$8b,$43,$4f
>14d8	fd 04 37 35 00 0d 2a 03			.byte	$fd,$04,$37,$35,$00,$0d,$2a,$03
>14e0	cf 14 37 07 bb 84 8b 4f			.byte	$cf,$14,$37,$07,$bb,$84,$8b,$4f
>14e8	4e 00 11 34 03 cf 09 39			.byte	$4e,$00,$11,$34,$03,$cf,$09,$39
>14f0	19 0f b8 40 be 84 fe 04			.byte	$19,$0f,$b8,$40,$be,$84,$fe,$04
>14f8	52 32 00 0d 3e 03 cf 18			.byte	$52,$32,$00,$0d,$3e,$03,$cf,$18
>1500	84 43 fd 05 36 32 35 00			.byte	$84,$43,$fd,$05,$36,$32,$35,$00
>1508	10 48 03 cf 01 37 14 19			.byte	$10,$48,$03,$cf,$01,$37,$14,$19
>1510	b7 84 fe 05 58 38 43 00			.byte	$b7,$84,$fe,$05,$58,$38,$43,$00
>1518	0d 52 03 cf 17 37 17 bb			.byte	$0d,$52,$03,$cf,$17,$37,$17,$bb
>1520	84 8b 4b 74 00 0f 5c 03			.byte	$84,$8b,$4b,$74,$00,$0f,$5c,$03
>1528	cf 0a 34 0e b9 84 45 4a			.byte	$cf,$0a,$34,$0e,$b9,$84,$45,$4a
>1530	fd 03 30 00 12 66 03 cf			.byte	$fd,$03,$30,$00,$12,$66,$03,$cf
>1538	0a 36 10 13 84 45 73 fd			.byte	$0a,$36,$10,$13,$84,$45,$73,$fd
>1540	06 30 36 32 35 00 12 70			.byte	$06,$30,$36,$32,$35,$00,$12,$70
>1548	03 cf 0f 32 07 15 0f b7			.byte	$03,$cf,$0f,$32,$07,$15,$0f,$b7
>1550	84 fe 06 42 35 47 5a 00			.byte	$84,$fe,$06,$42,$35,$47,$5a,$00
>1558	14 7a 03 cf 1a 37 01 10			.byte	$14,$7a,$03,$cf,$1a,$37,$01,$10
>1560	18 84 8b 46 60 fd 06 31			.byte	$18,$84,$8b,$46,$60,$fd,$06,$31
>1568	38 37 35 00 12 84 03 cf			.byte	$38,$37,$35,$00,$12,$84,$03,$cf
>1570	18 35 17 b9 84 46 48 fd			.byte	$18,$35,$17,$b9,$84,$46,$48,$fd
>1578	06 34 33 37 35 00 0d 8e			.byte	$06,$34,$33,$37,$35,$00,$0d,$8e
>1580	03 cf 07 33 11 bb 84 8b			.byte	$03,$cf,$07,$33,$11,$bb,$84,$8b
>1588	4d 45 00 11 98 03 cf 0a			.byte	$4d,$45,$00,$11,$98,$03,$cf,$0a
>1590	39 06 84 48 77 fd 06 35			.byte	$39,$06,$84,$48,$77,$fd,$06,$35
>1598	36 32 35 00 10 a2 03 cf			.byte	$36,$32,$35,$00,$10,$a2,$03,$cf
>15a0	05 33 0b 0b b9 84 46 5b			.byte	$05,$33,$0b,$0b,$b9,$84,$46,$5b
>15a8	fd 03 35 00 14 ac 03 cf			.byte	$fd,$03,$35,$00,$14,$ac,$03,$cf
>15b0	04 35 02 1a b9 84 8b 45			.byte	$04,$35,$02,$1a,$b9,$84,$8b,$45
>15b8	58 fd 06 33 31 32 35 00			.byte	$58,$fd,$06,$33,$31,$32,$35,$00
>15c0	11 b6 03 cf 01 38 17 18			.byte	$11,$b6,$03,$cf,$01,$38,$17,$18
>15c8	84 42 64 fd 05 36 32 35			.byte	$84,$42,$64,$fd,$05,$36,$32,$35
>15d0	00 12 c0 03 cf 03 30 08			.byte	$00,$12,$c0,$03,$cf,$03,$30,$08
>15d8	05 84 8b 44 4e fd 05 36			.byte	$05,$84,$8b,$44,$4e,$fd,$05,$36
>15e0	32 35 00 0f ca 03 cf 0d			.byte	$32,$35,$00,$0f,$ca,$03,$cf,$0d
>15e8	b7 84 fe 07 44 37 53 5a			.byte	$b7,$84,$fe,$07,$44,$37,$53,$5a
>15f0	4c 00 0c d4 03 cf 0e 35			.byte	$4c,$00,$0c,$d4,$03,$cf,$0e,$35
>15f8	05 bb 84 49 7a 00 15 de			.byte	$05,$bb,$84,$49,$7a,$00,$15,$de
>1600	03 cf 14 38 04 0a 07 b8			.byte	$03,$cf,$14,$38,$04,$0a,$07,$b8
>1608	40 be 84 fe 07 49 38 4d			.byte	$40,$be,$84,$fe,$07,$49,$38,$4d
>1610	51 44 00 11 e8 03 cf 0a			.byte	$51,$44,$00,$11,$e8,$03,$cf,$0a
>1618	31 0b 10 b7 84 fe 06 58			.byte	$31,$0b,$10,$b7,$84,$fe,$06,$58
>1620	31 48 55 00 11 f2 03 cf			.byte	$31,$48,$55,$00,$11,$f2,$03,$cf
>1628	18 30 16 17 b7 84 fe 06			.byte	$18,$30,$16,$17,$b7,$84,$fe,$06
>1630	54 32 44 5a 00 12 fc 03			.byte	$54,$32,$44,$5a,$00,$12,$fc,$03
>1638	cf 0a 38 0a 0a 84 8b 49			.byte	$cf,$0a,$38,$0a,$0a,$84,$8b,$49
>1640	5f fd 05 31 32 35 00 10			.byte	$5f,$fd,$05,$31,$32,$35,$00,$10
>1648	06 04 cf 07 34 16 07 b9			.byte	$06,$04,$cf,$07,$34,$16,$07,$b9
>1650	84 44 72 fd 03 35 00 14			.byte	$84,$44,$72,$fd,$03,$35,$00,$14
>1658	10 04 cf 05 33 0b 0b b9			.byte	$10,$04,$cf,$05,$33,$0b,$0b,$b9
>1660	84 8b 43 4e fd 06 39 33			.byte	$84,$8b,$43,$4e,$fd,$06,$39,$33
>1668	37 35 00 12 1a 04 cf 0c			.byte	$37,$35,$00,$12,$1a,$04,$cf,$0c
>1670	37 15 13 03 84 46 45 fd			.byte	$37,$15,$13,$03,$84,$46,$45,$fd
>1678	05 33 37 35 00 0f 24 04			.byte	$05,$33,$37,$35,$00,$0f,$24,$04
>1680	cf 07 36 18 04 0e bb 84			.byte	$cf,$07,$36,$18,$04,$0e,$bb,$84
>1688	8b 47 5f 00 0e 2e 04 cf			.byte	$8b,$47,$5f,$00,$0e,$2e,$04,$cf
>1690	13 37 15 04 b7 84 fe 03			.byte	$13,$37,$15,$04,$b7,$84,$fe,$03
>1698	52 00 11 38 04 cf 16 34			.byte	$52,$00,$11,$38,$04,$cf,$16,$34
>16a0	18 0d 0e b7 84 fe 05 43			.byte	$18,$0d,$0e,$b7,$84,$fe,$05,$43
>16a8	37 54 00 18 42 04 cf 08			.byte	$37,$54,$00,$18,$42,$04,$cf,$08
>16b0	37 18 07 09 ba 40 bf 41			.byte	$37,$18,$07,$09,$ba,$40,$bf,$41
>16b8	be 84 41 65 fd 06 36 38			.byte	$be,$84,$41,$65,$fd,$06,$36,$38
>16c0	37 35 00 0e 4c 04 cf 03			.byte	$37,$35,$00,$0e,$4c,$04,$cf,$03
>16c8	34 18 01 19 bb 84 4d 42			.byte	$34,$18,$01,$19,$bb,$84,$4d,$42
>16d0	00 12 56 04 cf 0c 37 15			.byte	$00,$12,$56,$04,$cf,$0c,$37,$15
>16d8	13 03 84 8b 45 47 fd 04			.byte	$13,$03,$84,$8b,$45,$47,$fd,$04
>16e0	32 35 00 10 60 04 cf 10			.byte	$32,$35,$00,$10,$60,$04,$cf,$10
>16e8	31 04 15 15 bc 40 be 84			.byte	$31,$04,$15,$15,$bc,$40,$be,$84
>16f0	44 73 00 13 6a 04 cf 08			.byte	$44,$73,$00,$13,$6a,$04,$cf,$08
>16f8	32 0a 06 b9 84 46 6a fd			.byte	$32,$0a,$06,$b9,$84,$46,$6a,$fd
>1700	06 35 36 32 35 00 0c 74			.byte	$06,$35,$36,$32,$35,$00,$0c,$74
>1708	04 cf 17 37 17 bb 84 4c			.byte	$04,$cf,$17,$37,$17,$bb,$84,$4c
>1710	7e 00 15 7e 04 cf 12 39			.byte	$7e,$00,$15,$7e,$04,$cf,$12,$39
>1718	0e 0d ba 42 be 84 8b 77			.byte	$0e,$0d,$ba,$42,$be,$84,$8b,$77
>1720	fd 06 38 31 32 35 00 12			.byte	$fd,$06,$38,$31,$32,$35,$00,$12
>1728	88 04 cf 11 33 04 84 8b			.byte	$88,$04,$cf,$11,$33,$04,$84,$8b
>1730	44 4b fd 06 31 38 37 35			.byte	$44,$4b,$fd,$06,$31,$38,$37,$35
>1738	00 13 92 04 cf 01 38 17			.byte	$00,$13,$92,$04,$cf,$01,$38,$17
>1740	03 0b 84 8b 45 54 fd 05			.byte	$03,$0b,$84,$8b,$45,$54,$fd,$05
>1748	36 32 35 00 11 9c 04 cf			.byte	$36,$32,$35,$00,$11,$9c,$04,$cf
>1750	03 30 08 05 84 42 56 fd			.byte	$03,$30,$08,$05,$84,$42,$56,$fd
>1758	05 31 32 35 00 10 a6 04			.byte	$05,$31,$32,$35,$00,$10,$a6,$04
>1760	cf 01 38 17 18 84 41 6d			.byte	$cf,$01,$38,$17,$18,$84,$41,$6d
>1768	fd 04 32 35 00 11 b0 04			.byte	$fd,$04,$32,$35,$00,$11,$b0,$04
>1770	cf 08 32 0a 06 b9 84 8b			.byte	$cf,$08,$32,$0a,$06,$b9,$84,$8b
>1778	48 7d fd 03 35 00 0a ba			.byte	$48,$7d,$fd,$03,$35,$00,$0a,$ba
>1780	04 cf 0b bb 84 48 7f 00			.byte	$04,$cf,$0b,$bb,$84,$48,$7f,$00
>1788	15 c4 04 cf 14 34 08 1a			.byte	$15,$c4,$04,$cf,$14,$34,$08,$1a
>1790	ba 41 be 84 42 61 fd 06			.byte	$ba,$41,$be,$84,$42,$61,$fd,$06
>1798	36 38 37 35 00 12 ce 04			.byte	$36,$38,$37,$35,$00,$12,$ce,$04
>17a0	cf 0a 31 0b 10 b7 84 fe			.byte	$cf,$0a,$31,$0b,$10,$b7,$84,$fe
>17a8	07 50 31 51 41 51 00 0b			.byte	$07,$50,$31,$51,$41,$51,$00,$0b
>17b0	d8 04 cf 10 b7 84 fe 03			.byte	$d8,$04,$cf,$10,$b7,$84,$fe,$03
>17b8	44 00 14 e2 04 cf 0d 35			.byte	$44,$00,$14,$e2,$04,$cf,$0d,$35
>17c0	0a 1a 0a b9 84 46 5c fd			.byte	$0a,$1a,$0a,$b9,$84,$46,$5c,$fd
>17c8	06 34 33 37 35 00 10 ec			.byte	$06,$34,$33,$37,$35,$00,$10,$ec
>17d0	04 cf 0e 31 03 b7 84 fe			.byte	$04,$cf,$0e,$31,$03,$b7,$84,$fe
>17d8	06 55 36 52 4a 00 12 f6			.byte	$06,$55,$36,$52,$4a,$00,$12,$f6
>17e0	04 cf 0e 32 13 84 8b 46			.byte	$04,$cf,$0e,$32,$13,$84,$8b,$46
>17e8	61 fd 06 35 36 32 35 00			.byte	$61,$fd,$06,$35,$36,$32,$35,$00
>17f0	14 00 05 cf 14 34 08 1a			.byte	$14,$00,$05,$cf,$14,$34,$08,$1a
>17f8	ba 41 be 84 8b 41 5d fd			.byte	$ba,$41,$be,$84,$8b,$41,$5d,$fd
>1800	04 32 35 00 13 0a 05 cf			.byte	$04,$32,$35,$00,$13,$0a,$05,$cf
>1808	01 35 0b 03 13 b9 84 8b			.byte	$01,$35,$0b,$03,$13,$b9,$84,$8b
>1810	47 64 fd 04 32 35 00 0f			.byte	$47,$64,$fd,$04,$32,$35,$00,$0f
>1818	14 05 cf 01 31 17 b9 84			.byte	$14,$05,$cf,$01,$31,$17,$b9,$84
>1820	46 73 fd 03 30 00 0d 1e			.byte	$46,$73,$fd,$03,$30,$00,$0d,$1e
>1828	05 cf 08 b7 84 fe 05 4f			.byte	$05,$cf,$08,$b7,$84,$fe,$05,$4f
>1830	32 47 00 0d 28 05 cf 16			.byte	$32,$47,$00,$0d,$28,$05,$cf,$16
>1838	31 17 07 bb 84 8b 6d 00			.byte	$31,$17,$07,$bb,$84,$8b,$6d,$00
>1840	0e 32 05 cf 0d b7 84 fe			.byte	$0e,$32,$05,$cf,$0d,$b7,$84,$fe
>1848	06 54 35 50 44 00 10 3c			.byte	$06,$54,$35,$50,$44,$00,$10,$3c
>1850	05 cf 13 37 15 04 b7 84			.byte	$05,$cf,$13,$37,$15,$04,$b7,$84
>1858	fe 05 52 32 48 00 11 46			.byte	$fe,$05,$52,$32,$48,$00,$11,$46
>1860	05 cf 05 30 09 84 47 72			.byte	$05,$cf,$05,$30,$09,$84,$47,$72
>1868	fd 06 34 33 37 35 00 0e			.byte	$fd,$06,$34,$33,$37,$35,$00,$0e
>1870	50 05 cf 08 35 05 02 04			.byte	$50,$05,$cf,$08,$35,$05,$02,$04
>1878	b7 84 fe 02 00 0e 5a 05			.byte	$b7,$84,$fe,$02,$00,$0e,$5a,$05
>1880	cf 11 30 10 06 bb 84 8b			.byte	$cf,$11,$30,$10,$06,$bb,$84,$8b
>1888	4e 75 00 14 64 05 cf 02			.byte	$4e,$75,$00,$14,$64,$05,$cf,$02
>1890	36 07 0b b8 41 be 84 fe			.byte	$36,$07,$0b,$b8,$41,$be,$84,$fe
>1898	07 4c 36 4c 45 45 00 0d			.byte	$07,$4c,$36,$4c,$45,$45,$00,$0d
>18a0	6e 05 cf 17 37 17 bb 84			.byte	$6e,$05,$cf,$17,$37,$17,$bb,$84
>18a8	8b 42 6b 00 11 78 05 cf			.byte	$8b,$42,$6b,$00,$11,$78,$05,$cf
>18b0	18 35 17 b9 84 8b 47 62			.byte	$18,$35,$17,$b9,$84,$8b,$47,$62
>18b8	fd 04 37 35 00 0f 82 05			.byte	$fd,$04,$37,$35,$00,$0f,$82,$05
>18c0	cf 08 35 05 02 04 b7 84			.byte	$cf,$08,$35,$05,$02,$04,$b7,$84
>18c8	fe 03 44 00 13 8c 05 cf			.byte	$fe,$03,$44,$00,$13,$8c,$05,$cf
>18d0	0e 33 11 05 b9 84 8b 41			.byte	$0e,$33,$11,$05,$b9,$84,$8b,$41
>18d8	72 fd 05 31 32 35 00 14			.byte	$72,$fd,$05,$31,$32,$35,$00,$14
>18e0	96 05 cf 01 35 0b 03 13			.byte	$96,$05,$cf,$01,$35,$0b,$03,$13
>18e8	b9 84 41 4e fd 06 36 38			.byte	$b9,$84,$41,$4e,$fd,$06,$36,$38
>18f0	37 35 00 12 a0 05 cf 09			.byte	$37,$35,$00,$12,$a0,$05,$cf,$09
>18f8	30 13 0a 04 b7 84 fe 06			.byte	$30,$13,$0a,$04,$b7,$84,$fe,$06
>1900	53 33 57 48 00 0f aa 05			.byte	$53,$33,$57,$48,$00,$0f,$aa,$05
>1908	cf 0a 37 15 11 0e bb 84			.byte	$cf,$0a,$37,$15,$11,$0e,$bb,$84
>1910	8b 4a 76 00 12 b4 05 cf			.byte	$8b,$4a,$76,$00,$12,$b4,$05,$cf
>1918	02 36 07 0b b8 42 be 84			.byte	$02,$36,$07,$0b,$b8,$42,$be,$84
>1920	fe 05 4b 35 53 00 15 be			.byte	$fe,$05,$4b,$35,$53,$00,$15,$be
>1928	05 cf 12 39 0e 0d ba 40			.byte	$05,$cf,$12,$39,$0e,$0d,$ba,$40
>1930	be 84 46 41 fd 06 35 36			.byte	$be,$84,$46,$41,$fd,$06,$35,$36
>1938	32 35 00 12 c8 05 cf 10			.byte	$32,$35,$00,$12,$c8,$05,$cf,$10
>1940	37 0d 03 06 b7 84 fe 06			.byte	$37,$0d,$03,$06,$b7,$84,$fe,$06
>1948	4c 32 45 46 00 0f d2 05			.byte	$4c,$32,$45,$46,$00,$0f,$d2,$05
>1950	cf 1a b9 84 8b 7f fd 05			.byte	$cf,$1a,$b9,$84,$8b,$7f,$fd,$05
>1958	38 37 35 00 12 dc 05 cf			.byte	$38,$37,$35,$00,$12,$dc,$05,$cf
>1960	14 34 12 18 b7 84 fe 07			.byte	$14,$34,$12,$18,$b7,$84,$fe,$07
>1968	4b 33 57 47 49 00 11 e6			.byte	$4b,$33,$57,$47,$49,$00,$11,$e6
>1970	05 cf 1a b9 84 8b 47 6b			.byte	$05,$cf,$1a,$b9,$84,$8b,$47,$6b
>1978	fd 06 30 36 32 35 00 11			.byte	$fd,$06,$30,$36,$32,$35,$00,$11
>1980	f0 05 cf 14 34 12 18 b7			.byte	$f0,$05,$cf,$14,$34,$12,$18,$b7
>1988	84 fe 06 48 37 56 50 00			.byte	$84,$fe,$06,$48,$37,$56,$50,$00
>1990	11 fa 05 cf 0a 31 0b 10			.byte	$11,$fa,$05,$cf,$0a,$31,$0b,$10
>1998	b7 84 fe 06 56 31 4e 46			.byte	$b7,$84,$fe,$06,$56,$31,$4e,$46
>19a0	00 13 04 06 cf 0e 39 10			.byte	$00,$13,$04,$06,$cf,$0e,$39,$10
>19a8	0d 06 b7 84 fe 07 44 37			.byte	$0d,$06,$b7,$84,$fe,$07,$44,$37
>19b0	4e 50 45 00 10 0e 06 cf			.byte	$4e,$50,$45,$00,$10,$0e,$06,$cf
>19b8	18 30 16 17 b7 84 fe 05			.byte	$18,$30,$16,$17,$b7,$84,$fe,$05
>19c0	58 38 4b 00 10 18 06 cf			.byte	$58,$38,$4b,$00,$10,$18,$06,$cf
>19c8	1a 37 01 10 18 84 44 6d			.byte	$1a,$37,$01,$10,$18,$84,$44,$6d
>19d0	fd 03 30 00 0e 22 06 cf			.byte	$fd,$03,$30,$00,$0e,$22,$06,$cf
>19d8	08 b7 84 fe 06 5a 38 42			.byte	$08,$b7,$84,$fe,$06,$5a,$38,$42
>19e0	57 00 18 2c 06 cf 08 37			.byte	$57,$00,$18,$2c,$06,$cf,$08,$37
>19e8	18 07 09 ba 41 bf 40 be			.byte	$18,$07,$09,$ba,$41,$bf,$40,$be
>19f0	84 8b 43 50 fd 05 31 32			.byte	$84,$8b,$43,$50,$fd,$05,$31,$32
>19f8	35 00 0f 36 06 cf 13 37			.byte	$35,$00,$0f,$36,$06,$cf,$13,$37
>1a00	0d 15 13 b7 84 fe 03 41			.byte	$0d,$15,$13,$b7,$84,$fe,$03,$41
>1a08	00 11 40 06 cf 12 ba 40			.byte	$00,$11,$40,$06,$cf,$12,$ba,$40
>1a10	be 84 44 46 fd 05 36 32			.byte	$be,$84,$44,$46,$fd,$05,$36,$32
>1a18	35 00 13 4a 06 cf 01 31			.byte	$35,$00,$13,$4a,$06,$cf,$01,$31
>1a20	17 b9 84 8b 42 6b fd 06			.byte	$17,$b9,$84,$8b,$42,$6b,$fd,$06
>1a28	35 36 32 35 00 13 54 06			.byte	$35,$36,$32,$35,$00,$13,$54,$06
>1a30	cf 0c 39 08 15 0f 84 8b			.byte	$cf,$0c,$39,$08,$15,$0f,$84,$8b
>1a38	7e fd 06 34 33 37 35 00			.byte	$7e,$fd,$06,$34,$33,$37,$35,$00
>1a40	0f 5e 06 cf 0f 31 0d 15			.byte	$0f,$5e,$06,$cf,$0f,$31,$0d,$15
>1a48	10 bb 84 8b 4d 7c 00 14			.byte	$10,$bb,$84,$8b,$4d,$7c,$00,$14
>1a50	68 06 cf 02 36 07 0b b8			.byte	$68,$06,$cf,$02,$36,$07,$0b,$b8
>1a58	41 be 84 fe 07 47 34 46			.byte	$41,$be,$84,$fe,$07,$47,$34,$46
>1a60	55 59 00 12 72 06 cf 12			.byte	$55,$59,$00,$12,$72,$06,$cf,$12
>1a68	ba 42 be 84 43 55 fd 06			.byte	$ba,$42,$be,$84,$43,$55,$fd,$06
>1a70	31 38 37 35 00 0f 7c 06			.byte	$31,$38,$37,$35,$00,$0f,$7c,$06
>1a78	cf 19 32 1a 09 0f b7 84			.byte	$cf,$19,$32,$1a,$09,$0f,$b7,$84
>1a80	fe 03 54 00 0e 86 06 cf			.byte	$fe,$03,$54,$00,$0e,$86,$06,$cf
>1a88	0a 37 15 11 0e bb 84 48			.byte	$0a,$37,$15,$11,$0e,$bb,$84,$48
>1a90	5e 00 0e 90 06 cf 18 36			.byte	$5e,$00,$0e,$90,$06,$cf,$18,$36
>1a98	01 11 bb 84 8b 45 62 00			.byte	$01,$11,$bb,$84,$8b,$45,$62,$00
>1aa0	0d 9a 06 cf 0e b9 84 42			.byte	$0d,$9a,$06,$cf,$0e,$b9,$84,$42
>1aa8	5e fd 03 30 00 0f a4 06			.byte	$5e,$fd,$03,$30,$00,$0f,$a4,$06
>1ab0	cf 0a 37 15 11 0e bb 84			.byte	$cf,$0a,$37,$15,$11,$0e,$bb,$84
>1ab8	8b 4f 63 00 0b ae 06 cf			.byte	$8b,$4f,$63,$00,$0b,$ae,$06,$cf
>1ac0	08 b7 84 fe 03 46 00 12			.byte	$08,$b7,$84,$fe,$03,$46,$00,$12
>1ac8	b8 06 cf 0a 31 0b 10 b7			.byte	$b8,$06,$cf,$0a,$31,$0b,$10,$b7
>1ad0	84 fe 07 57 30 4c 55 4e			.byte	$84,$fe,$07,$57,$30,$4c,$55,$4e
>1ad8	00 12 c2 06 cf 02 36 07			.byte	$00,$12,$c2,$06,$cf,$02,$36,$07
>1ae0	0b b8 40 be 84 fe 05 56			.byte	$0b,$b8,$40,$be,$84,$fe,$05,$56
>1ae8	32 53 00 0e cc 06 cf 08			.byte	$32,$53,$00,$0e,$cc,$06,$cf,$08
>1af0	33 06 05 09 bb 84 8b 47			.byte	$33,$06,$05,$09,$bb,$84,$8b,$47
>1af8	00 0f d6 06 cf 07 b7 84			.byte	$00,$0f,$d6,$06,$cf,$07,$b7,$84
>1b00	fe 07 5a 33 48 4d 57 00			.byte	$fe,$07,$5a,$33,$48,$4d,$57,$00
>1b08	13 e0 06 cf 14 38 17 06			.byte	$13,$e0,$06,$cf,$14,$38,$17,$06
>1b10	b9 84 45 61 fd 06 34 33			.byte	$b9,$84,$45,$61,$fd,$06,$34,$33
>1b18	37 35 00 10 ea 06 cf 0e			.byte	$37,$35,$00,$10,$ea,$06,$cf,$0e
>1b20	b9 84 43 57 fd 06 31 38			.byte	$b9,$84,$43,$57,$fd,$06,$31,$38
>1b28	37 35 00 10 f4 06 cf 0a			.byte	$37,$35,$00,$10,$f4,$06,$cf,$0a
>1b30	31 0b 10 b7 84 fe 05 51			.byte	$31,$0b,$10,$b7,$84,$fe,$05,$51
>1b38	34 43 00 0d fe 06 cf 17			.byte	$34,$43,$00,$0d,$fe,$06,$cf,$17
>1b40	37 17 bb 84 8b 4c 73 00			.byte	$37,$17,$bb,$84,$8b,$4c,$73,$00
>1b48	13 08 07 cf 0c 39 08 15			.byte	$13,$08,$07,$cf,$0c,$39,$08,$15
>1b50	0f 84 45 4c fd 06 34 33			.byte	$0f,$84,$45,$4c,$fd,$06,$34,$33
>1b58	37 35 00 11 12 07 cf 0c			.byte	$37,$35,$00,$11,$12,$07,$cf,$0c
>1b60	31 11 19 b9 84 44 4e fd			.byte	$31,$11,$19,$b9,$84,$44,$4e,$fd
>1b68	04 37 35 00 11 1c 07 cf			.byte	$04,$37,$35,$00,$11,$1c,$07,$cf
>1b70	0d 31 19 b9 84 46 79 fd			.byte	$0d,$31,$19,$b9,$84,$46,$79,$fd
>1b78	05 31 32 35 00 12 26 07			.byte	$05,$31,$32,$35,$00,$12,$26,$07
>1b80	cf 02 37 10 0b b8 42 be			.byte	$cf,$02,$37,$10,$0b,$b8,$42,$be
>1b88	84 fe 05 4f 38 55 00 12			.byte	$84,$fe,$05,$4f,$38,$55,$00,$12
>1b90	30 07 cf 14 34 12 18 b7			.byte	$30,$07,$cf,$14,$34,$12,$18,$b7
>1b98	84 fe 07 4a 30 42 50 51			.byte	$84,$fe,$07,$4a,$30,$42,$50,$51
>1ba0	00 0f 3a 07 cf 14 b7 84			.byte	$00,$0f,$3a,$07,$cf,$14,$b7,$84
>1ba8	fe 07 56 33 4e 55 46 00			.byte	$fe,$07,$56,$33,$4e,$55,$46,$00
>1bb0	10 44 07 cf 04 35 17 16			.byte	$10,$44,$07,$cf,$04,$35,$17,$16
>1bb8	b7 84 fe 05 4b 34 4f 00			.byte	$b7,$84,$fe,$05,$4b,$34,$4f,$00
>1bc0	14 4e 07 cf 0a 30 17 1a			.byte	$14,$4e,$07,$cf,$0a,$30,$17,$1a
>1bc8	b9 84 8b 49 51 fd 06 35			.byte	$b9,$84,$8b,$49,$51,$fd,$06,$35
>1bd0	36 32 35 00 0e 58 07 cf			.byte	$36,$32,$35,$00,$0e,$58,$07,$cf
>1bd8	0a 37 15 11 0e bb 84 45			.byte	$0a,$37,$15,$11,$0e,$bb,$84,$45
>1be0	49 00 15 62 07 cf 14 34			.byte	$49,$00,$15,$62,$07,$cf,$14,$34
>1be8	08 1a ba 42 be 84 45 43			.byte	$08,$1a,$ba,$42,$be,$84,$45,$43
>1bf0	fd 06 36 38 37 35 00 0d			.byte	$fd,$06,$36,$38,$37,$35,$00,$0d
>1bf8	6c 07 cf 18 36 01 11 bb			.byte	$6c,$07,$cf,$18,$36,$01,$11,$bb
>1c00	84 41 50 00 0c 76 07 cf			.byte	$84,$41,$50,$00,$0c,$76,$07,$cf
>1c08	18 84 46 53 fd 03 30 00			.byte	$18,$84,$46,$53,$fd,$03,$30,$00
>1c10	10 80 07 cf 06 37 02 01			.byte	$10,$80,$07,$cf,$06,$37,$02,$01
>1c18	bc 41 be 84 8b 4c 5b 00			.byte	$bc,$41,$be,$84,$8b,$4c,$5b,$00
>1c20	11 8a 07 cf 0d 35 0a 1a			.byte	$11,$8a,$07,$cf,$0d,$35,$0a,$1a
>1c28	0a b9 84 44 43 fd 03 30			.byte	$0a,$b9,$84,$44,$43,$fd,$03,$30
>1c30	00 11 94 07 cf 19 34 15			.byte	$00,$11,$94,$07,$cf,$19,$34,$15
>1c38	19 0a b7 84 fe 05 43 33			.byte	$19,$0a,$b7,$84,$fe,$05,$43,$33
>1c40	55 00 11 9e 07 cf 0f 32			.byte	$55,$00,$11,$9e,$07,$cf,$0f,$32
>1c48	07 15 0f b7 84 fe 05 52			.byte	$07,$15,$0f,$b7,$84,$fe,$05,$52
>1c50	30 51 00 10 a8 07 cf 02			.byte	$30,$51,$00,$10,$a8,$07,$cf,$02
>1c58	37 10 0b b8 42 be 84 fe			.byte	$37,$10,$0b,$b8,$42,$be,$84,$fe
>1c60	03 52 00 11 b2 07 cf 0e			.byte	$03,$52,$00,$11,$b2,$07,$cf,$0e
>1c68	b9 84 8b 48 6c fd 06 33			.byte	$b9,$84,$8b,$48,$6c,$fd,$06,$33
>1c70	31 32 35 00 14 bc 07 cf			.byte	$31,$32,$35,$00,$14,$bc,$07,$cf
>1c78	14 34 08 1a ba 42 be 84			.byte	$14,$34,$08,$1a,$ba,$42,$be,$84
>1c80	8b 43 79 fd 04 37 35 00			.byte	$8b,$43,$79,$fd,$04,$37,$35,$00
>1c88	15 c6 07 cf 14 30 03 01			.byte	$15,$c6,$07,$cf,$14,$30,$03,$01
>1c90	16 b9 84 8b 41 7f fd 06			.byte	$16,$b9,$84,$8b,$41,$7f,$fd,$06
>1c98	38 31 32 35 00 11 d0 07			.byte	$38,$31,$32,$35,$00,$11,$d0,$07
>1ca0	cf 05 30 09 84 46 66 fd			.byte	$cf,$05,$30,$09,$84,$46,$66,$fd
>1ca8	06 39 33 37 35 00 14 da			.byte	$06,$39,$33,$37,$35,$00,$14,$da
>1cb0	07 cf 0c 37 15 13 03 84			.byte	$07,$cf,$0c,$37,$15,$13,$03,$84
>1cb8	8b 44 7c fd 06 38 31 32			.byte	$8b,$44,$7c,$fd,$06,$38,$31,$32
>1cc0	35 00 0f e4 07 cf 02 38			.byte	$35,$00,$0f,$e4,$07,$cf,$02,$38
>1cc8	0b 12 07 bb 84 8b 4e 73			.byte	$0b,$12,$07,$bb,$84,$8b,$4e,$73
>1cd0	00 12 ee 07 cf 01 31 17			.byte	$00,$12,$ee,$07,$cf,$01,$31,$17
>1cd8	b9 84 8b 49 69 fd 05 36			.byte	$b9,$84,$8b,$49,$69,$fd,$05,$36
>1ce0	32 35 00 11 f8 07 cf 0a			.byte	$32,$35,$00,$11,$f8,$07,$cf,$0a
>1ce8	34 0e b9 84 69 fd 06 38			.byte	$34,$0e,$b9,$84,$69,$fd,$06,$38
>1cf0	31 32 35 00 0d 02 08 cf			.byte	$31,$32,$35,$00,$0d,$02,$08,$cf
>1cf8	0a 33 0e 0e bb 84 47 68			.byte	$0a,$33,$0e,$0e,$bb,$84,$47,$68
>1d00	00 14 0c 08 cf 0b 35 13			.byte	$00,$14,$0c,$08,$cf,$0b,$35,$13
>1d08	11 07 84 8b 43 53 fd 06			.byte	$11,$07,$84,$8b,$43,$53,$fd,$06
>1d10	35 36 32 35 00 10 16 08			.byte	$35,$36,$32,$35,$00,$10,$16,$08
>1d18	cf 0a 34 0e b9 84 43 77			.byte	$cf,$0a,$34,$0e,$b9,$84,$43,$77
>1d20	fd 04 32 35 00 0f 20 08			.byte	$fd,$04,$32,$35,$00,$0f,$20,$08
>1d28	cf 0a 37 15 11 0e bb 84			.byte	$cf,$0a,$37,$15,$11,$0e,$bb,$84
>1d30	8b 4e 75 00 13 2a 08 cf			.byte	$8b,$4e,$75,$00,$13,$2a,$08,$cf
>1d38	08 32 0a 06 b9 84 8b 48			.byte	$08,$32,$0a,$06,$b9,$84,$8b,$48
>1d40	6f fd 05 36 32 35 00 10			.byte	$6f,$fd,$05,$36,$32,$35,$00,$10
>1d48	34 08 cf 0e 39 10 0d 06			.byte	$34,$08,$cf,$0e,$39,$10,$0d,$06
>1d50	b7 84 fe 04 42 35 00 13			.byte	$b7,$84,$fe,$04,$42,$35,$00,$13
>1d58	3e 08 cf 14 38 17 06 b9			.byte	$3e,$08,$cf,$14,$38,$17,$06,$b9
>1d60	84 8b 44 6d fd 05 38 37			.byte	$84,$8b,$44,$6d,$fd,$05,$38,$37
>1d68	35 00 11 48 08 cf 08 32			.byte	$35,$00,$11,$48,$08,$cf,$08,$32
>1d70	0a 06 b9 84 8b 49 50 fd			.byte	$0a,$06,$b9,$84,$8b,$49,$50,$fd
>1d78	03 30 00 0b 52 08 cf 10			.byte	$03,$30,$00,$0b,$52,$08,$cf,$10
>1d80	b7 84 fe 03 41 00 0c 5c			.byte	$b7,$84,$fe,$03,$41,$00,$0c,$5c
>1d88	08 dc 18 37 03 11 03 84			.byte	$08,$dc,$18,$37,$03,$11,$03,$84
>1d90	40 00 11 66 08 dc 16 34			.byte	$40,$00,$11,$66,$08,$dc,$16,$34
>1d98	18 0d 0e b7 84 fe 05 43			.byte	$18,$0d,$0e,$b7,$84,$fe,$05,$43
>1da0	37 54 00 0f 70 08 dc 17			.byte	$37,$54,$00,$0f,$70,$08,$dc,$17
>1da8	84 46 67 fd 06 30 36 32			.byte	$84,$46,$67,$fd,$06,$30,$36,$32
>1db0	35 00 11 7a 08 dc 05 30			.byte	$35,$00,$11,$7a,$08,$dc,$05,$30
>1db8	09 84 46 66 fd 06 39 33			.byte	$09,$84,$46,$66,$fd,$06,$39,$33
>1dc0	37 35 00 14 84 08 dc 0a			.byte	$37,$35,$00,$14,$84,$08,$dc,$0a
>1dc8	30 17 1a b9 84 8b 49 51			.byte	$30,$17,$1a,$b9,$84,$8b,$49,$51
>1dd0	fd 06 35 36 32 35 00 14			.byte	$fd,$06,$35,$36,$32,$35,$00,$14
>1dd8	8e 08 dc 04 35 02 1a b9			.byte	$8e,$08,$dc,$04,$35,$02,$1a,$b9
>1de0	84 8b 45 58 fd 06 33 31			.byte	$84,$8b,$45,$58,$fd,$06,$33,$31
>1de8	32 35 00 0b 98 08 dc 01			.byte	$32,$35,$00,$0b,$98,$08,$dc,$01
>1df0	bb 84 8b 48 6a 00 11 a2			.byte	$bb,$84,$8b,$48,$6a,$00,$11,$a2
>1df8	08 dc 0e b9 84 8b 48 6c			.byte	$08,$dc,$0e,$b9,$84,$8b,$48,$6c
>1e00	fd 06 33 31 32 35 00 14			.byte	$fd,$06,$33,$31,$32,$35,$00,$14
>1e08	ac 08 dc 0b 35 13 11 07			.byte	$ac,$08,$dc,$0b,$35,$13,$11,$07
>1e10	84 8b 43 53 fd 06 35 36			.byte	$84,$8b,$43,$53,$fd,$06,$35,$36
>1e18	32 35 00 0d b6 08 dc 10			.byte	$32,$35,$00,$0d,$b6,$08,$dc,$10
>1e20	34 14 0f 1a bb 84 40 00			.byte	$34,$14,$0f,$1a,$bb,$84,$40,$00
>1e28	0f c0 08 dc 07 36 18 04			.byte	$0f,$c0,$08,$dc,$07,$36,$18,$04
>1e30	0e bb 84 8b 47 5f 00 09			.byte	$0e,$bb,$84,$8b,$47,$5f,$00,$09
>1e38	ca 08 dc 16 b9 84 40 00			.byte	$ca,$08,$dc,$16,$b9,$84,$40,$00
>1e40	0d d4 08 dc 14 37 07 bb			.byte	$0d,$d4,$08,$dc,$14,$37,$07,$bb
>1e48	84 8b 4f 4e 00 12 de 08			.byte	$84,$8b,$4f,$4e,$00,$12,$de,$08
>1e50	dc 07 35 13 84 8b 48 60			.byte	$dc,$07,$35,$13,$84,$8b,$48,$60
>1e58	fd 06 36 38 37 35 00 0e			.byte	$fd,$06,$36,$38,$37,$35,$00,$0e
>1e60	e8 08 dc 11 30 10 06 bb			.byte	$e8,$08,$dc,$11,$30,$10,$06,$bb
>1e68	84 8b 4e 75 00 11 f2 08			.byte	$84,$8b,$4e,$75,$00,$11,$f2,$08
>1e70	dc 03 30 08 05 84 42 56			.byte	$dc,$03,$30,$08,$05,$84,$42,$56
>1e78	fd 05 31 32 35 00 0f fc			.byte	$fd,$05,$31,$32,$35,$00,$0f,$fc
>1e80	08 dc 03 38 0e b7 84 fe			.byte	$08,$dc,$03,$38,$0e,$b7,$84,$fe
>1e88	05 52 33 57 00 12 06 09			.byte	$05,$52,$33,$57,$00,$12,$06,$09
>1e90	dc 0a 36 10 13 84 45 73			.byte	$dc,$0a,$36,$10,$13,$84,$45,$73
>1e98	fd 06 30 36 32 35 00 0c			.byte	$fd,$06,$30,$36,$32,$35,$00,$0c
>1ea0	10 09 dc 09 34 17 b7 84			.byte	$10,$09,$dc,$09,$34,$17,$b7,$84
>1ea8	fe 02 00 10 1a 09 dc 18			.byte	$fe,$02,$00,$10,$1a,$09,$dc,$18
>1eb0	30 16 17 b7 84 fe 05 58			.byte	$30,$16,$17,$b7,$84,$fe,$05,$58
>1eb8	38 4b 00 09 24 09 dc 09			.byte	$38,$4b,$00,$09,$24,$09,$dc,$09
>1ec0	bb 84 40 00 10 2e 09 dc			.byte	$bb,$84,$40,$00,$10,$2e,$09,$dc
>1ec8	04 35 17 16 b7 84 fe 05			.byte	$04,$35,$17,$16,$b7,$84,$fe,$05
>1ed0	4b 34 4f 00 0f 38 09 dc			.byte	$4b,$34,$4f,$00,$0f,$38,$09,$dc
>1ed8	13 37 0d 15 13 b7 84 fe			.byte	$13,$37,$0d,$15,$13,$b7,$84,$fe
>1ee0	03 41 00 0c 42 09 dc 1a			.byte	$03,$41,$00,$0c,$42,$09,$dc,$1a
>1ee8	35 19 05 b9 84 40 00 11			.byte	$35,$19,$05,$b9,$84,$40,$00,$11
>1ef0	4c 09 dc 0f 32 07 15 0f			.byte	$4c,$09,$dc,$0f,$32,$07,$15,$0f
>1ef8	b7 84 fe 05 52 30 51 00			.byte	$b7,$84,$fe,$05,$52,$30,$51,$00
>1f00	11 56 09 dc 1a b9 84 8b			.byte	$11,$56,$09,$dc,$1a,$b9,$84,$8b
>1f08	47 6b fd 06 30 36 32 35			.byte	$47,$6b,$fd,$06,$30,$36,$32,$35
>1f10	00 0d 60 09 dc 03 37 17			.byte	$00,$0d,$60,$09,$dc,$03,$37,$17
>1f18	bb 84 8b 49 6b 00 11 6a			.byte	$bb,$84,$8b,$49,$6b,$00,$11,$6a
>1f20	09 dc 18 35 17 b9 84 8b			.byte	$09,$dc,$18,$35,$17,$b9,$84,$8b
>1f28	47 62 fd 04 37 35 00 09			.byte	$47,$62,$fd,$04,$37,$35,$00,$09
>1f30	74 09 dc 11 bb 84 40 00			.byte	$74,$09,$dc,$11,$bb,$84,$40,$00
>1f38	11 7e 09 dc 07 38 05 06			.byte	$11,$7e,$09,$dc,$07,$38,$05,$06
>1f40	b7 84 fe 06 5a 39 45 57			.byte	$b7,$84,$fe,$06,$5a,$39,$45,$57
>1f48	00 12 88 09 dc 10 37 0d			.byte	$00,$12,$88,$09,$dc,$10,$37,$0d
>1f50	03 06 b7 84 fe 06 4c 32			.byte	$03,$06,$b7,$84,$fe,$06,$4c,$32
>1f58	45 46 00 0d 92 09 dc 17			.byte	$45,$46,$00,$0d,$92,$09,$dc,$17
>1f60	37 17 bb 84 8b 4c 73 00			.byte	$37,$17,$bb,$84,$8b,$4c,$73,$00
>1f68	0f 9c 09 dc 14 b7 84 fe			.byte	$0f,$9c,$09,$dc,$14,$b7,$84,$fe
>1f70	07 56 33 4e 55 46 00 0c			.byte	$07,$56,$33,$4e,$55,$46,$00,$0c
>1f78	a6 09 dc 18 84 46 53 fd			.byte	$a6,$09,$dc,$18,$84,$46,$53,$fd
>1f80	03 30 00 10 b0 09 dc 0e			.byte	$03,$30,$00,$10,$b0,$09,$dc,$0e
>1f88	39 10 0d 06 b7 84 fe 04			.byte	$39,$10,$0d,$06,$b7,$84,$fe,$04
>1f90	42 35 00 14 ba 09 dc 0c			.byte	$42,$35,$00,$14,$ba,$09,$dc,$0c
>1f98	37 15 13 03 84 8b 44 7c			.byte	$37,$15,$13,$03,$84,$8b,$44,$7c
>1fa0	fd 06 38 31 32 35 00 12			.byte	$fd,$06,$38,$31,$32,$35,$00,$12
>1fa8	c4 09 dc 09 30 13 0a 04			.byte	$c4,$09,$dc,$09,$30,$13,$0a,$04
>1fb0	b7 84 fe 06 53 33 57 48			.byte	$b7,$84,$fe,$06,$53,$33,$57,$48
>1fb8	00 0b ce 09 dc 08 b7 84			.byte	$00,$0b,$ce,$09,$dc,$08,$b7,$84
>1fc0	fe 03 46 00 10 d8 09 dc			.byte	$fe,$03,$46,$00,$10,$d8,$09,$dc
>1fc8	13 37 15 04 b7 84 fe 05			.byte	$13,$37,$15,$04,$b7,$84,$fe,$05
>1fd0	52 32 48 00 11 e2 09 dc			.byte	$52,$32,$48,$00,$11,$e2,$09,$dc
>1fd8	0d 31 19 b9 84 46 79 fd			.byte	$0d,$31,$19,$b9,$84,$46,$79,$fd
>1fe0	05 31 32 35 00 0c ec 09			.byte	$05,$31,$32,$35,$00,$0c,$ec,$09
>1fe8	dc 0d 34 03 bb 84 43 67			.byte	$dc,$0d,$34,$03,$bb,$84,$43,$67
>1ff0	00 0d f6 09 dc 18 36 01			.byte	$00,$0d,$f6,$09,$dc,$18,$36,$01
>1ff8	11 bb 84 41 50 00 09 00			.byte	$11,$bb,$84,$41,$50,$00,$09,$00
>2000	0a dc 13 b9 84 40 00 14			.byte	$0a,$dc,$13,$b9,$84,$40,$00,$14
>2008	0a 0a dc 01 35 0b 03 13			.byte	$0a,$0a,$dc,$01,$35,$0b,$03,$13
>2010	b9 84 41 4e fd 06 36 38			.byte	$b9,$84,$41,$4e,$fd,$06,$36,$38
>2018	37 35 00 12 14 0a dc 14			.byte	$37,$35,$00,$12,$14,$0a,$dc,$14
>2020	34 12 18 b7 84 fe 07 4a			.byte	$34,$12,$18,$b7,$84,$fe,$07,$4a
>2028	30 42 50 51 00 0f 1e 0a			.byte	$30,$42,$50,$51,$00,$0f,$1e,$0a
>2030	dc 08 35 05 02 04 b7 84			.byte	$dc,$08,$35,$05,$02,$04,$b7,$84
>2038	fe 03 44 00 11 28 0a dc			.byte	$fe,$03,$44,$00,$11,$28,$0a,$dc
>2040	19 34 15 19 0a b7 84 fe			.byte	$19,$34,$15,$19,$0a,$b7,$84,$fe
>2048	05 43 33 55 00 08 32 0a			.byte	$05,$43,$33,$55,$00,$08,$32,$0a
>2050	dc 15 84 40 00 11 3c 0a			.byte	$dc,$15,$84,$40,$00,$11,$3c,$0a
>2058	dc 0c 31 11 19 b9 84 44			.byte	$dc,$0c,$31,$11,$19,$b9,$84,$44
>2060	4e fd 04 37 35 00 0a 46			.byte	$4e,$fd,$04,$37,$35,$00,$0a,$46
>2068	0a dc 0c 38 05 84 40 00			.byte	$0a,$dc,$0c,$38,$05,$84,$40,$00
>2070	0e 50 0a dc 03 34 18 01			.byte	$0e,$50,$0a,$dc,$03,$34,$18,$01
>2078	19 bb 84 4d 42 00 14 5a			.byte	$19,$bb,$84,$4d,$42,$00,$14,$5a
>2080	0a dc 05 33 0b 0b b9 84			.byte	$0a,$dc,$05,$33,$0b,$0b,$b9,$84
>2088	8b 43 4e fd 06 39 33 37			.byte	$8b,$43,$4e,$fd,$06,$39,$33,$37
>2090	35 00 13 64 0a dc 0e 33			.byte	$35,$00,$13,$64,$0a,$dc,$0e,$33
>2098	11 05 b9 84 8b 41 72 fd			.byte	$11,$05,$b9,$84,$8b,$41,$72,$fd
>20a0	05 31 32 35 00 0f 6e 0a			.byte	$05,$31,$32,$35,$00,$0f,$6e,$0a
>20a8	dc 1a 32 15 08 0e bb 84			.byte	$dc,$1a,$32,$15,$08,$0e,$bb,$84
>20b0	8b 44 59 00 12 78 0a dc			.byte	$8b,$44,$59,$00,$12,$78,$0a,$dc
>20b8	0e 32 13 84 8b 46 61 fd			.byte	$0e,$32,$13,$84,$8b,$46,$61,$fd
>20c0	06 35 36 32 35 00 13 82			.byte	$06,$35,$36,$32,$35,$00,$13,$82
>20c8	0a dc 0d 35 08 06 0d 84			.byte	$0a,$dc,$0d,$35,$08,$06,$0d,$84
>20d0	41 52 fd 06 31 38 37 35			.byte	$41,$52,$fd,$06,$31,$38,$37,$35
>20d8	00 10 8c 0a dc 0a 34 0e			.byte	$00,$10,$8c,$0a,$dc,$0a,$34,$0e
>20e0	b9 84 43 77 fd 04 32 35			.byte	$b9,$84,$43,$77,$fd,$04,$32,$35
>20e8	00 0c 96 0a dc 06 30 0f			.byte	$00,$0c,$96,$0a,$dc,$06,$30,$0f
>20f0	0a 07 84 40 00 0f a0 0a			.byte	$0a,$07,$84,$40,$00,$0f,$a0,$0a
>20f8	dc 19 32 1a 09 0f b7 84			.byte	$dc,$19,$32,$1a,$09,$0f,$b7,$84
>2100	fe 03 54 00 11 aa 0a dc			.byte	$fe,$03,$54,$00,$11,$aa,$0a,$dc
>2108	08 32 0a 06 b9 84 8b 49			.byte	$08,$32,$0a,$06,$b9,$84,$8b,$49
>2110	50 fd 03 30 00 0e b4 0a			.byte	$50,$fd,$03,$30,$00,$0e,$b4,$0a
>2118	dc 02 35 08 10 bb 84 8b			.byte	$dc,$02,$35,$08,$10,$bb,$84,$8b
>2120	49 62 00 0b be 0a dc 06			.byte	$49,$62,$00,$0b,$be,$0a,$dc,$06
>2128	30 11 bb 84 40 00 10 c8			.byte	$30,$11,$bb,$84,$40,$00,$10,$c8
>2130	0a dc 0e 31 03 b7 84 fe			.byte	$0a,$dc,$0e,$31,$03,$b7,$84,$fe
>2138	06 55 36 52 4a 00 12 d2			.byte	$06,$55,$36,$52,$4a,$00,$12,$d2
>2140	0a dc 0a 38 0a 0a 84 8b			.byte	$0a,$dc,$0a,$38,$0a,$0a,$84,$8b
>2148	49 5f fd 05 31 32 35 00			.byte	$49,$5f,$fd,$05,$31,$32,$35,$00
>2150	0a dc 0a dc 16 30 0b 84			.byte	$0a,$dc,$0a,$dc,$16,$30,$0b,$84
>2158	40 00 0e e6 0a dc 0d b7			.byte	$40,$00,$0e,$e6,$0a,$dc,$0d,$b7
>2160	84 fe 06 54 35 50 44 00			.byte	$84,$fe,$06,$54,$35,$50,$44,$00
>2168	0a f0 0a dc 0b bb 84 48			.byte	$0a,$f0,$0a,$dc,$0b,$bb,$84,$48
>2170	7f 00 10 fa 0a dc 01 37			.byte	$7f,$00,$10,$fa,$0a,$dc,$01,$37
>2178	14 19 b7 84 fe 05 58 38			.byte	$14,$19,$b7,$84,$fe,$05,$58,$38
>2180	43 00 08 04 0b dc 03 84			.byte	$43,$00,$08,$04,$0b,$dc,$03,$84
>2188	40 00 12 0e 0b dc 01 31			.byte	$40,$00,$12,$0e,$0b,$dc,$01,$31
>2190	17 b9 84 8b 49 69 fd 05			.byte	$17,$b9,$84,$8b,$49,$69,$fd,$05
>2198	36 32 35 00 11 18 0b dc			.byte	$36,$32,$35,$00,$11,$18,$0b,$dc
>21a0	0a 39 06 84 48 77 fd 06			.byte	$0a,$39,$06,$84,$48,$77,$fd,$06
>21a8	35 36 32 35 00 0f 22 0b			.byte	$35,$36,$32,$35,$00,$0f,$22,$0b
>21b0	dc 07 b7 84 fe 07 5a 33			.byte	$dc,$07,$b7,$84,$fe,$07,$5a,$33
>21b8	48 4d 57 00 10 2c 0b dc			.byte	$48,$4d,$57,$00,$10,$2c,$0b,$dc
>21c0	1a 37 01 10 18 84 44 6d			.byte	$1a,$37,$01,$10,$18,$84,$44,$6d
>21c8	fd 03 30 00 0b 36 0b dc			.byte	$fd,$03,$30,$00,$0b,$36,$0b,$dc
>21d0	10 b7 84 fe 03 41 00 10			.byte	$10,$b7,$84,$fe,$03,$41,$00,$10
>21d8	40 0b dc 07 34 16 07 b9			.byte	$40,$0b,$dc,$07,$34,$16,$07,$b9
>21e0	84 44 72 fd 03 35 00 0f			.byte	$84,$44,$72,$fd,$03,$35,$00,$0f
>21e8	4a 0b dc 0f 31 0d 15 10			.byte	$4a,$0b,$dc,$0f,$31,$0d,$15,$10
>21f0	bb 84 8b 4d 7c 00 0c 54			.byte	$bb,$84,$8b,$4d,$7c,$00,$0c,$54
>21f8	0b dc 0e 35 05 bb 84 49			.byte	$0b,$dc,$0e,$35,$05,$bb,$84,$49
>2200	7a 00 0d 5e 0b dc 0a 33			.byte	$7a,$00,$0d,$5e,$0b,$dc,$0a,$33
>2208	0e 0e bb 84 47 68 00 0e			.byte	$0e,$0e,$bb,$84,$47,$68,$00,$0e
>2210	68 0b dc 16 30 11 08 12			.byte	$68,$0b,$dc,$16,$30,$11,$08,$12
>2218	b7 84 fe 02 00 0d 72 0b			.byte	$b7,$84,$fe,$02,$00,$0d,$72,$0b
>2220	dc 02 33 17 bb 84 8b 46			.byte	$dc,$02,$33,$17,$bb,$84,$8b,$46
>2228	75 00 12 7c 0b dc 11 33			.byte	$75,$00,$12,$7c,$0b,$dc,$11,$33
>2230	04 84 8b 44 4b fd 06 31			.byte	$04,$84,$8b,$44,$4b,$fd,$06,$31
>2238	38 37 35 00 13 86 0b dc			.byte	$38,$37,$35,$00,$13,$86,$0b,$dc
>2240	01 38 17 03 0b 84 8b 45			.byte	$01,$38,$17,$03,$0b,$84,$8b,$45
>2248	54 fd 05 36 32 35 00 0f			.byte	$54,$fd,$05,$36,$32,$35,$00,$0f
>2250	90 0b dc 0a 37 15 11 0e			.byte	$90,$0b,$dc,$0a,$37,$15,$11,$0e
>2258	bb 84 8b 4e 75 00 0d 9a			.byte	$bb,$84,$8b,$4e,$75,$00,$0d,$9a
>2260	0b dc 07 33 11 bb 84 8b			.byte	$0b,$dc,$07,$33,$11,$bb,$84,$8b
>2268	4d 45 00 0f a4 0b dc 02			.byte	$4d,$45,$00,$0f,$a4,$0b,$dc,$02
>2270	38 0b 12 07 bb 84 8b 4e			.byte	$38,$0b,$12,$07,$bb,$84,$8b,$4e
>2278	73 00 0e ae 0b dc 03 32			.byte	$73,$00,$0e,$ae,$0b,$dc,$03,$32
>2280	08 12 0c bb 84 43 6b 00			.byte	$08,$12,$0c,$bb,$84,$43,$6b,$00
>2288	12 b8 0b dc 10 32 01 b9			.byte	$12,$b8,$0b,$dc,$10,$32,$01,$b9
>2290	84 47 57 fd 06 35 36 32			.byte	$84,$47,$57,$fd,$06,$35,$36,$32
>2298	35 00 0d c2 0b dc 16 31			.byte	$35,$00,$0d,$c2,$0b,$dc,$16,$31
>22a0	17 07 bb 84 8b 6d 00 10			.byte	$17,$07,$bb,$84,$8b,$6d,$00,$10
>22a8	cc 0b dc 01 38 17 18 84			.byte	$cc,$0b,$dc,$01,$38,$17,$18,$84
>22b0	41 6d fd 04 32 35 00 0c			.byte	$41,$6d,$fd,$04,$32,$35,$00,$0c
>22b8	d6 0b dc 19 39 14 12 b9			.byte	$d6,$0b,$dc,$19,$39,$14,$12,$b9
>22c0	84 40 00 13 e0 0b dc 0c			.byte	$84,$40,$00,$13,$e0,$0b,$dc,$0c
>22c8	39 08 15 0f 84 45 4c fd			.byte	$39,$08,$15,$0f,$84,$45,$4c,$fd
>22d0	06 34 33 37 35 00 11 ea			.byte	$06,$34,$33,$37,$35,$00,$11,$ea
>22d8	0b dc 0d 35 0a 1a 0a b9			.byte	$0b,$dc,$0d,$35,$0a,$1a,$0a,$b9
>22e0	84 44 43 fd 03 30 00 0e			.byte	$84,$44,$43,$fd,$03,$30,$00,$0e
>22e8	f4 0b dc 08 33 06 05 09			.byte	$f4,$0b,$dc,$08,$33,$06,$05,$09
>22f0	bb 84 8b 47 00 08 fe 0b			.byte	$bb,$84,$8b,$47,$00,$08,$fe,$0b
>22f8	dc 06 84 40 00 15 08 0c			.byte	$dc,$06,$84,$40,$00,$15,$08,$0c
>2300	dc 14 30 03 01 16 b9 84			.byte	$dc,$14,$30,$03,$01,$16,$b9,$84
>2308	8b 41 7f fd 06 38 31 32			.byte	$8b,$41,$7f,$fd,$06,$38,$31,$32
>2310	35 00 0c 12 0c dc 14 38			.byte	$35,$00,$0c,$12,$0c,$dc,$14,$38
>2318	07 05 b9 84 40 00 0f 1c			.byte	$07,$05,$b9,$84,$40,$00,$0f,$1c
>2320	0c dc 0f 34 12 19 b7 84			.byte	$0c,$dc,$0f,$34,$12,$19,$b7,$84
>2328	fe 04 41 37 00 10 26 0c			.byte	$fe,$04,$41,$37,$00,$10,$26,$0c
>2330	dc 0a 31 0b 10 b7 84 fe			.byte	$dc,$0a,$31,$0b,$10,$b7,$84,$fe
>2338	05 51 34 43 00 13 30 0c			.byte	$05,$51,$34,$43,$00,$13,$30,$0c
>2340	dc 14 38 17 06 b9 84 8b			.byte	$dc,$14,$38,$17,$06,$b9,$84,$8b
>2348	44 6d fd 05 38 37 35 00			.byte	$44,$6d,$fd,$05,$38,$37,$35,$00
>2350	11 3a 0c dc 08 32 10 17			.byte	$11,$3a,$0c,$dc,$08,$32,$10,$17
>2358	b7 84 fe 06 52 30 4c 53			.byte	$b7,$84,$fe,$06,$52,$30,$4c,$53
>2360	00 37 44 0c dc 14 34 08			.byte	$00,$37,$44,$0c,$dc,$14,$34,$08
>2368	1a ba 40 be 84 8b 48 51			.byte	$1a,$ba,$40,$be,$84,$8b,$48,$51
>2370	fd 05 36 32 35 c0 dc 14			.byte	$fd,$05,$36,$32,$35,$c0,$dc,$14
>2378	34 08 1a ba 41 be 84 8b			.byte	$34,$08,$1a,$ba,$41,$be,$84,$8b
>2380	41 5d fd 04 32 35 c0 dc			.byte	$41,$5d,$fd,$04,$32,$35,$c0,$dc
>2388	14 34 08 1a ba 42 be 84			.byte	$14,$34,$08,$1a,$ba,$42,$be,$84
>2390	8b 43 79 fd 04 37 35 00			.byte	$8b,$43,$79,$fd,$04,$37,$35,$00
>2398	49 4e 0c dc 08 37 18 07			.byte	$49,$4e,$0c,$dc,$08,$37,$18,$07
>23a0	09 ba 40 bf 40 be 84 40			.byte	$09,$ba,$40,$bf,$40,$be,$84,$40
>23a8	c0 dc 08 37 18 07 09 ba			.byte	$c0,$dc,$08,$37,$18,$07,$09,$ba
>23b0	40 bf 41 be 84 41 65 fd			.byte	$40,$bf,$41,$be,$84,$41,$65,$fd
>23b8	06 36 38 37 35 c0 dc 08			.byte	$06,$36,$38,$37,$35,$c0,$dc,$08
>23c0	37 18 07 09 ba 41 bf 40			.byte	$37,$18,$07,$09,$ba,$41,$bf,$40
>23c8	be 84 8b 43 50 fd 05 31			.byte	$be,$84,$8b,$43,$50,$fd,$05,$31
>23d0	32 35 c0 dc 08 37 18 07			.byte	$32,$35,$c0,$dc,$08,$37,$18,$07
>23d8	09 ba 41 bf 41 be 84 40			.byte	$09,$ba,$41,$bf,$41,$be,$84,$40
>23e0	00 30 58 0c dc 12 ba 40			.byte	$00,$30,$58,$0c,$dc,$12,$ba,$40
>23e8	be 84 44 46 fd 05 36 32			.byte	$be,$84,$44,$46,$fd,$05,$36,$32
>23f0	35 c0 dc 12 ba 41 be 84			.byte	$35,$c0,$dc,$12,$ba,$41,$be,$84
>23f8	8b 42 6a fd 06 30 36 32			.byte	$8b,$42,$6a,$fd,$06,$30,$36,$32
>2400	35 c0 dc 12 ba 42 be 84			.byte	$35,$c0,$dc,$12,$ba,$42,$be,$84
>2408	43 55 fd 06 31 38 37 35			.byte	$43,$55,$fd,$06,$31,$38,$37,$35
>2410	00 22 62 0c dc 14 38 04			.byte	$00,$22,$62,$0c,$dc,$14,$38,$04
>2418	0a 07 b8 40 be 84 fe 07			.byte	$0a,$07,$b8,$40,$be,$84,$fe,$07
>2420	49 38 4d 51 44 c0 dc 14			.byte	$49,$38,$4d,$51,$44,$c0,$dc,$14
>2428	38 04 0a 07 b8 41 be 84			.byte	$38,$04,$0a,$07,$b8,$41,$be,$84
>2430	fe 02 00 27 6c 0c dc 06			.byte	$fe,$02,$00,$27,$6c,$0c,$dc,$06
>2438	37 02 01 bc 40 be 84 40			.byte	$37,$02,$01,$bc,$40,$be,$84,$40
>2440	c0 dc 06 37 02 01 bc 41			.byte	$c0,$dc,$06,$37,$02,$01,$bc,$41
>2448	be 84 8b 4c 5b c0 dc 06			.byte	$be,$84,$8b,$4c,$5b,$c0,$dc,$06
>2450	37 02 01 bc 42 be 84 44			.byte	$37,$02,$01,$bc,$42,$be,$84,$44
>2458	7b 00 28 76 0c dc 10 31			.byte	$7b,$00,$28,$76,$0c,$dc,$10,$31
>2460	04 15 15 bc 40 be 84 44			.byte	$04,$15,$15,$bc,$40,$be,$84,$44
>2468	73 c0 dc 10 31 04 15 15			.byte	$73,$c0,$dc,$10,$31,$04,$15,$15
>2470	bc 41 be 84 40 c0 dc 10			.byte	$bc,$41,$be,$84,$40,$c0,$dc,$10
>2478	31 04 15 15 bc 42 be 84			.byte	$31,$04,$15,$15,$bc,$42,$be,$84
>2480	40 00 42 80 0c dc 17 34			.byte	$40,$00,$42,$80,$0c,$dc,$17,$34
>2488	14 09 04 bd 40 bf 40 be			.byte	$14,$09,$04,$bd,$40,$bf,$40,$be
>2490	84 42 74 fd 06 35 36 32			.byte	$84,$42,$74,$fd,$06,$35,$36,$32
>2498	35 c0 dc 17 34 14 09 04			.byte	$35,$c0,$dc,$17,$34,$14,$09,$04
>24a0	bd 40 bf 41 be 84 40 c0			.byte	$bd,$40,$bf,$41,$be,$84,$40,$c0
>24a8	dc 17 34 14 09 04 bd 41			.byte	$dc,$17,$34,$14,$09,$04,$bd,$41
>24b0	bf 40 be 84 40 c0 dc 17			.byte	$bf,$40,$be,$84,$40,$c0,$dc,$17
>24b8	34 14 09 04 bd 41 bf 41			.byte	$34,$14,$09,$04,$bd,$41,$bf,$41
>24c0	be 84 40 00 32 8a 0c dc			.byte	$be,$84,$40,$00,$32,$8a,$0c,$dc
>24c8	02 36 07 0b b8 40 be 84			.byte	$02,$36,$07,$0b,$b8,$40,$be,$84
>24d0	fe 05 56 32 53 c0 dc 02			.byte	$fe,$05,$56,$32,$53,$c0,$dc,$02
>24d8	36 07 0b b8 41 be 84 fe			.byte	$36,$07,$0b,$b8,$41,$be,$84,$fe
>24e0	07 47 34 46 55 59 c0 dc			.byte	$07,$47,$34,$46,$55,$59,$c0,$dc
>24e8	02 36 07 0b b8 42 be 84			.byte	$02,$36,$07,$0b,$b8,$42,$be,$84
>24f0	fe 05 4b 35 53 00 29 94			.byte	$fe,$05,$4b,$35,$53,$00,$29,$94
>24f8	0c dc 09 39 19 0f b8 40			.byte	$0c,$dc,$09,$39,$19,$0f,$b8,$40
>2500	be 84 fe 04 52 32 c0 dc			.byte	$be,$84,$fe,$04,$52,$32,$c0,$dc
>2508	09 39 19 0f b8 41 be 84			.byte	$09,$39,$19,$0f,$b8,$41,$be,$84
>2510	fe 02 c0 dc 09 39 19 0f			.byte	$fe,$02,$c0,$dc,$09,$39,$19,$0f
>2518	b8 42 be 84 fe 02 00 32			.byte	$b8,$42,$be,$84,$fe,$02,$00,$32
>2520	9e 0c dc 12 39 0e 0d ba			.byte	$9e,$0c,$dc,$12,$39,$0e,$0d,$ba
>2528	40 be 84 46 41 fd 06 35			.byte	$40,$be,$84,$46,$41,$fd,$06,$35
>2530	36 32 35 c0 dc 12 39 0e			.byte	$36,$32,$35,$c0,$dc,$12,$39,$0e
>2538	0d ba 41 be 84 40 c0 dc			.byte	$0d,$ba,$41,$be,$84,$40,$c0,$dc
>2540	12 39 0e 0d ba 42 be 84			.byte	$12,$39,$0e,$0d,$ba,$42,$be,$84
>2548	8b 77 fd 06 38 31 32 35			.byte	$8b,$77,$fd,$06,$38,$31,$32,$35
>2550	00 24 a8 0c dc 16 31 16			.byte	$00,$24,$a8,$0c,$dc,$16,$31,$16
>2558	1a ba 40 be 84 40 c0 dc			.byte	$1a,$ba,$40,$be,$84,$40,$c0,$dc
>2560	16 31 16 1a ba 41 be 84			.byte	$16,$31,$16,$1a,$ba,$41,$be,$84
>2568	40 c0 dc 16 31 16 1a ba			.byte	$40,$c0,$dc,$16,$31,$16,$1a,$ba
>2570	42 be 84 40 00 28 b2 0c			.byte	$42,$be,$84,$40,$00,$28,$b2,$0c
>2578	dc 02 37 10 0b b8 40 be			.byte	$dc,$02,$37,$10,$0b,$b8,$40,$be
>2580	84 fe 02 c0 dc 02 37 10			.byte	$84,$fe,$02,$c0,$dc,$02,$37,$10
>2588	0b b8 41 be 84 fe 02 c0			.byte	$0b,$b8,$41,$be,$84,$fe,$02,$c0
>2590	dc 02 37 10 0b b8 42 be			.byte	$dc,$02,$37,$10,$0b,$b8,$42,$be
>2598	84 fe 03 52 00 1b bc 0c			.byte	$84,$fe,$03,$52,$00,$1b,$bc,$0c
>25a0	d6 fe 14 50 61 73 73 65			.byte	$d6,$fe,$14,$50,$61,$73,$73,$65
>25a8	64 20 41 73 73 69 67 6e			.byte	$64,$20,$41,$73,$73,$69,$67,$6e
>25b0	6d 65 6e 74 2e c0 c4 00			.byte	$6d,$65,$6e,$74,$2e,$c0,$c4,$00
>25b8	00					.byte	$00

;******  Return to file: modules/hardware/em65816.asm

.c000					StartROM:
.c000	18		clc				clc
.c001	fb		xce				xce
.c002	c2 30		rep #$30			rep 	#$30
.c004	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.c007	1b		tcs				tcs
.c008	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.c00b	e2 30		sep #$30			sep 	#$30
.c00d	c2 30		rep #$30			rep 	#$30						; clear AXY in 16 bit.
.c00f	a9 00		lda #$00			lda 	#$0000
.c011	aa		tax				tax
.c012	a8		tay				tay
.c013	e2 30		sep #$30			sep 	#$30
.c015	5c 4c 87 01	jmp $01874c		jmp BASIC_Start
.c019					TIM_BreakHandler:
.c019	5c 76 83 01	jmp $018376			jmp 	TIM_BreakVector

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.018000					IFT_ClearScreen:
.018000	48		pha				pha
.018001	da		phx				phx
.018002	5a		phy				phy
.018003	20 a9 81	jsr $0181a9			jsr 	IF_Home 					; home cursor
.018006	a2 20		ldx #$20			ldx 	#IF_Height 					; this many lines.
.018008					_IFT_CS0:
.018008	a0 40		ldy #$40			ldy 	#IF_Width 					; this many chars/line
.01800a					_IFT_CS1:
.01800a	a9 20		lda #$20			lda 	#' '						; clear line.
.01800c	20 d5 81	jsr $0181d5			jsr 	IF_Write
.01800f	88		dey				dey
.018010	d0 f8		bne $01800a			bne 	_IFT_CS1
.018012	20 bc 81	jsr $0181bc			jsr 	IF_NewLine 					; next line down
.018015	ca		dex				dex
.018016	d0 f0		bne $018008			bne 	_IFT_CS0
.018018	7a		ply				ply
.018019	fa		plx				plx
.01801a	68		pla				pla
.01801b					IFT_HomeCursor:
.01801b	48		pha				pha
.01801c	20 a9 81	jsr $0181a9			jsr 	IF_Home
.01801f	a9 00		lda #$00			lda 	#0
.018021	8d 00 05	sta $0500			sta 	IFT_XCursor
.018024	8d 01 05	sta $0501			sta 	IFT_YCursor
.018027	68		pla				pla
.018028	60		rts				rts
.018029					IFT_UpLine:
.018029	48		pha				pha
.01802a	ad 01 05	lda $0501			lda  	IFT_YCursor 				; get Y
.01802d	3a		dec a				dec 	a 							; line above
.01802e	30 03		bmi $018033			bmi 	_IFTULExit 					; too far, abort
.018030	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos					; set to that line.
.018033					_IFTULExit:
.018033	68		pla				pla
.018034	60		rts				rts
.018035					IFT_PrintCharacter:
.018035	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.018037	f0 23		beq $01805c			beq 	IFT_NewLine
.018039	48		pha				pha
.01803a	20 74 80	jsr $018074			jsr 	IFT_UpperCase 				; make upper case
.01803d	20 d5 81	jsr $0181d5			jsr 	IF_Write 					; write out.
.018040	ee 00 05	inc $0500			inc 	IFT_XCursor 				; bump x cursor
.018043	ad 00 05	lda $0500			lda 	IFT_XCursor 				; reached RHS ?
.018046	c9 40		cmp #$40			cmp 	#IF_Width
.018048	d0 03		bne $01804d			bne 	_IFT_PCNotEOL
.01804a	20 5c 80	jsr $01805c			jsr 	IFT_NewLine 				; if so do new line.
.01804d					_IFT_PCNotEOL:
.01804d	68		pla				pla
.01804e	60		rts				rts
.01804f					IFT_Tab:
.01804f	a9 20		lda #$20			lda 	#" " 						; space
.018051	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018054	ad 00 05	lda $0500			lda 	IFT_XCursor 				; until x % 8 == 0
.018057	29 07		and #$07			and 	#7
.018059	d0 f4		bne $01804f			bne 	IFT_Tab
.01805b	60		rts				rts
.01805c					IFT_NewLine:
.01805c	48		pha				pha
.01805d	20 bc 81	jsr $0181bc			jsr 	IF_NewLine 					; new line on actual screen.
.018060	a9 00		lda #$00			lda 	#0 							; reset x position
.018062	8d 00 05	sta $0500			sta 	IFT_XCursor
.018065	ee 01 05	inc $0501			inc 	IFT_YCursor 				; move down.
.018068	ad 01 05	lda $0501			lda 	IFT_YCursor
.01806b	c9 20		cmp #$20			cmp 	#IF_Height 					; reached bottom.
.01806d	d0 03		bne $018072			bne 	_IFT_NL_NotEOS
.01806f	20 7f 80	jsr $01807f			jsr 	IFT_Scroll 					; scroll screen up.
.018072					_IFT_NL_NotEOS:
.018072	68		pla				pla
.018073	60		rts				rts
.018074					IFT_UpperCase:
.018074	c9 61		cmp #$61			cmp 	#"a"
.018076	90 06		bcc $01807e			bcc 	_IFT_UCExit
.018078	c9 7b		cmp #$7b			cmp 	#"z"+1
.01807a	b0 02		bcs $01807e			bcs 	_IFT_UCExit
.01807c	49 20		eor #$20			eor 	#$20
.01807e					_IFT_UCExit:
.01807e	60		rts				rts
.01807f					IFT_Scroll:
.01807f	48		pha				pha 								; save AXY
.018080	da		phx				phx
.018081	5a		phy				phy
.018082	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.018084					_IFT_SLoop:
.018084	20 a4 80	jsr $0180a4			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.018087	e8		inx				inx
.018088	e0 1f		cpx #$1f			cpx 	#IF_Height-1				; do whole screen
.01808a	d0 f8		bne $018084			bne 	_IFT_SLoop
.01808c	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.01808e	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.018091	a2 40		ldx #$40			ldx 	#IF_Width 					; blank line
.018093					_IFT_SBlank:
.018093	a9 20		lda #$20			lda 	#32
.018095	20 d5 81	jsr $0181d5			jsr 	IF_Write
.018098	ca		dex				dex
.018099	d0 f8		bne $018093			bne 	_IFT_SBlank
.01809b	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.01809d	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.0180a0	7a		ply				ply
.0180a1	fa		plx				plx
.0180a2	68		pla				pla
.0180a3	60		rts				rts
.0180a4					_IFT_ScrollLine:
.0180a4	da		phx				phx
.0180a5	da		phx				phx
.0180a6	8a		txa				txa 								; copy line into buffer.
.0180a7	1a		inc a				inc 	a 							; next line down.
.0180a8	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.0180ab	a2 00		ldx #$00			ldx 	#0
.0180ad					_IFTScrollCopy1:
.0180ad	20 cc 81	jsr $0181cc			jsr 	IF_Read
.0180b0	9d 02 05	sta $0502,x			sta 	IFT_Buffer,x
.0180b3	e8		inx				inx
.0180b4	e0 40		cpx #$40			cpx 	#IF_Width
.0180b6	d0 f5		bne $0180ad			bne 	_IFTScrollCopy1
.0180b8	68		pla				pla
.0180b9	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.0180bc	a2 00		ldx #$00			ldx 	#0
.0180be					_IFTScrollCopy2:
.0180be	bd 02 05	lda $0502,x			lda 	IFT_Buffer,x
.0180c1	20 d5 81	jsr $0181d5			jsr 	IF_Write
.0180c4	e8		inx				inx
.0180c5	e0 40		cpx #$40			cpx 	#IF_Width
.0180c7	d0 f5		bne $0180be			bne 	_IFTScrollCopy2
.0180c9	fa		plx				plx
.0180ca	60		rts				rts
.0180cb					IFT_SetYPos:
.0180cb	48		pha				pha
.0180cc	da		phx				phx
.0180cd	aa		tax				tax
.0180ce	20 1b 80	jsr $01801b			jsr 	IFT_HomeCursor
.0180d1	e0 00		cpx #$00			cpx 	#0
.0180d3	f0 09		beq $0180de			beq 	_IFT_MOAExit
.0180d5					_IFT_MOALoop:
.0180d5	20 bc 81	jsr $0181bc			jsr 	IF_NewLine
.0180d8	ee 01 05	inc $0501			inc 	IFT_YCursor
.0180db	ca		dex				dex
.0180dc	d0 f7		bne $0180d5			bne		_IFT_MOALoop
.0180de					_IFT_MOAExit:
.0180de	fa		plx				plx
.0180df	68		pla				pla
.0180e0	60		rts				rts
.0180e1					IFT_GetKeyCursor:
.0180e1	20 e9 80	jsr $0180e9			jsr 	_IFT_FlipCursor 			; reverse current
.0180e4					_IFT_GKCWait:
.0180e4	20 e6 81	jsr $0181e6			jsr 	IF_GetKey 					; get key
.0180e7	f0 fb		beq $0180e4			beq 	_IFT_GKCWait
.0180e9					_IFT_FlipCursor:
.0180e9	48		pha				pha 								; save
.0180ea	20 cc 81	jsr $0181cc			jsr 	IF_Read 					; read
.0180ed	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.0180f0	49 80		eor #$80			eor 	#$80 						; reverse
.0180f2	20 d5 81	jsr $0181d5			jsr 	IF_Write 					; write
.0180f5	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.0180f8	68		pla				pla
.0180f9	60		rts				rts
.0180fa					IFT_ReadLine:
.0180fa	48		pha				pha
.0180fb					_IFT_RLLoop:
.0180fb	20 e1 80	jsr $0180e1			jsr 	IFT_GetKeyCursor 			; get keystroke
.0180fe	c9 0d		cmp #$0d			cmp 	#13							; return
.018100	f0 7d		beq $01817f			beq 	_IFT_RLExit
.018102	c9 20		cmp #$20			cmp 	#32 						; control character
.018104	90 05		bcc $01810b			bcc 	_IFT_Control
.018106	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018109	80 f0		bra $0180fb			bra 	_IFT_RLLoop
.01810b					_IFT_Control:
.01810b	c9 01		cmp #$01			cmp 	#"A"-64
.01810d	f0 26		beq $018135			beq 	_IFT_Left
.01810f	c9 04		cmp #$04			cmp 	#"D"-64
.018111	f0 2e		beq $018141			beq 	_IFT_Right
.018113	c9 17		cmp #$17			cmp 	#"W"-64
.018115	f0 36		beq $01814d			beq 	_IFT_Up
.018117	c9 13		cmp #$13			cmp 	#"S"-64
.018119	f0 3e		beq $018159			beq 	_IFT_Down
.01811b	c9 08		cmp #$08			cmp 	#"H"-64
.01811d	f0 09		beq $018128			beq 	_IFT_Backspace
.01811f	c9 1a		cmp #$1a			cmp 	#"Z"-64
.018121	d0 d8		bne $0180fb			bne 	_IFT_RLLoop
.018123	20 00 80	jsr $018000			jsr 	IFT_ClearScreen				; clear CTL-Z
.018126	80 d3		bra $0180fb			bra 	_IFT_RLLoop
.018128					_IFT_Backspace:
.018128	ad 00 05	lda $0500			lda 	IFT_XCursor 				; check not start of line.
.01812b	f0 ce		beq $0180fb			beq 	_IFT_RLLoop
.01812d	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.018130	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.018132	20 d5 81	jsr $0181d5			jsr 	IF_Write
.018135					_IFT_Left:
.018135	ce 00 05	dec $0500			dec 	IFT_XCursor 				; left CTL-W
.018138	10 29		bpl $018163			bpl 	_IFT_Reposition
.01813a	a9 3f		lda #$3f			lda 	#IF_Width-1
.01813c					_IFT_SetX:
.01813c	8d 00 05	sta $0500			sta 	IFT_XCursor
.01813f	80 22		bra $018163			bra 	_IFT_Reposition
.018141					_IFT_Right:
.018141	ee 00 05	inc $0500			inc 	IFT_XCursor
.018144	ad 00 05	lda $0500			lda 	IFT_XCursor
.018147	49 40		eor #$40			eor 	#IF_Width
.018149	f0 f1		beq $01813c			beq 	_IFT_SetX
.01814b	80 16		bra $018163			bra 	_IFT_Reposition
.01814d					_IFT_Up:
.01814d	ce 01 05	dec $0501			dec 	IFT_YCursor
.018150	10 11		bpl $018163			bpl 	_IFT_Reposition
.018152	a9 1f		lda #$1f			lda 	#IF_Height-1
.018154					_IFT_SetY:
.018154	8d 01 05	sta $0501			sta 	IFT_YCursor
.018157	80 0a		bra $018163			bra 	_IFT_Reposition
.018159					_IFT_Down:
.018159	ee 01 05	inc $0501			inc 	IFT_YCursor
.01815c	ad 01 05	lda $0501			lda 	IFT_YCursor
.01815f	49 20		eor #$20			eor 	#IF_Height
.018161	f0 f1		beq $018154			beq 	_IFT_SetY
.018163					_IFT_Reposition:
.018163	ad 00 05	lda $0500			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.018166	48		pha				pha
.018167	ad 01 05	lda $0501			lda 	IFT_YCursor
.01816a	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.01816d	68		pla				pla
.01816e	aa		tax				tax
.01816f	e0 00		cpx #$00			cpx 	#0
.018171	f0 88		beq $0180fb			beq 	_IFT_RLLoop
.018173					_IFT_MoveRight:
.018173	20 cc 81	jsr $0181cc			jsr 	IF_Read
.018176	ee 00 05	inc $0500			inc 	IFT_XCursor
.018179	ca		dex				dex
.01817a	d0 f7		bne $018173			bne 	_IFT_MoveRight
.01817c	4c fb 80	jmp $0180fb			jmp 	_IFT_RLLoop
.01817f					_IFT_RLExit:
.01817f	ad 01 05	lda $0501			lda 	IFT_YCursor 				; go to start of line.
.018182	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.018185	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.018187					_IFT_RLRead:
.018187	20 cc 81	jsr $0181cc			jsr 	IF_Read
.01818a	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.01818d	e8		inx				inx
.01818e	e0 40		cpx #$40			cpx 	#IF_Width
.018190	d0 f5		bne $018187			bne 	_IFT_RLRead
.018192					_IFT_RL_Trim:
.018192	ca		dex				dex 	 							; previous char
.018193	30 07		bmi $01819c			bmi 	_IFT_Found 					; gone too far
.018195	bd 66 05	lda $0566,x			lda 	IFT_LineBuffer,x			; go back if space
.018198	c9 20		cmp #$20			cmp 	#" "
.01819a	f0 f6		beq $018192			beq 	_IFT_RL_Trim
.01819c					_IFT_Found:
.01819c	e8		inx				inx 								; forward to non-space
.01819d	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.01819f	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.0181a2	68		pla				pla
.0181a3	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.0181a5	a0 05		ldy #$05			ldy 	#IFT_LineBuffer >> 8
.0181a7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_em65816.asm

=64					IF_Width 	= 64 							; characters across
=32					IF_Height 	= 32 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line.
=8					IF_XPos 	= 8 							; current position, horizontal.
=$f0000					IF_Screen = $F0000							; 2k screen RAM here
=$f8010					IF_PKeyboard = $F8010						; Keyboard port.
=$f8000					IF_PBreak = $F8000 							; Break key.
.0181a8					IF_Reset:
.0181a8	60		rts				rts
.0181a9					IF_Home:
.0181a9	48		pha				pha
.0181aa	64 08		stz $08				stz 	IF_XPos 					; zero X position
.0181ac	a9 00		lda #$00			lda 	#IF_Screen & $FF 			; set r/w pos.
.0181ae	85 04		sta $04				sta 	IF_Pos
.0181b0	a9 00		lda #$00			lda 	#(IF_Screen >> 8) & $FF
.0181b2	85 05		sta $05				sta 	IF_Pos+1
.0181b4	a9 0f		lda #$0f			lda 	#IF_Screen >> 16
.0181b6	85 06		sta $06				sta 	IF_Pos+2
.0181b8	64 07		stz $07				stz 	IF_Pos+3
.0181ba	68		pla				pla
.0181bb	60		rts				rts
.0181bc					IF_NewLine:
.0181bc	48		pha				pha
.0181bd	64 08		stz $08				stz 	IF_XPos						; back to start of line
.0181bf	18		clc				clc 								; down one line
.0181c0	a5 04		lda $04				lda 	IF_Pos
.0181c2	69 40		adc #$40			adc 	#64
.0181c4	85 04		sta $04				sta 	IF_Pos
.0181c6	90 02		bcc $0181ca			bcc 	_IF_NoCarry 				; carry through.
.0181c8	e6 05		inc $05				inc 	IF_Pos+1
.0181ca					_IF_NoCarry:
.0181ca	68		pla				pla
.0181cb	60		rts				rts
.0181cc					IF_Read:
.0181cc	5a		phy				phy 								; save current Y
.0181cd	a4 08		ldy $08				ldy 	IF_XPos 					; read character at current position
.0181cf	b7 04		lda [$04],y			lda 	[IF_Pos],y
.0181d1	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181d3	7a		ply				ply									; restore Y
.0181d4	60		rts				rts
.0181d5					IF_Write:
.0181d5	5a		phy				phy 								; save current Y
.0181d6	a4 08		ldy $08				ldy 	IF_XPos 					; write character at current position
.0181d8	97 04		sta [$04],y			sta 	[IF_Pos],y
.0181da	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181dc	7a		ply				ply									; restore Y
.0181dd	60		rts				rts
.0181de					IF_LeftOne:
.0181de	c6 08		dec $08				dec 	IF_XPos
.0181e0	60		rts				rts
.0181e1					IF_CheckBreak:
.0181e1	af 00 80 0f	lda $0f8000			lda 	IF_PBreak					; non-zero if Ctrl+C pressed.
.0181e5	60		rts				rts
.0181e6					IF_GetKey:
.0181e6	af 10 80 0f	lda $0f8010			lda 	IF_PKeyboard				; read keyboard
.0181ea	f0 08		beq $0181f4			beq		_IFGK_NoKey 				; skip if zero,no key pressed
.0181ec	48		pha				pha 								; key pressed, clear queue.
.0181ed	a9 00		lda #$00			lda 	#0
.0181ef	8f 10 80 0f	sta $0f8010			sta 	IF_PKeyboard
.0181f3	68		pla				pla
.0181f4					_IFGK_NoKey:
.0181f4	09 00		ora #$00			ora 	#0							; set Z flag appropriately.
.0181f6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.0181f7					TIM_Error:
.0181f7	20 29 80	jsr $018029			jsr 	IFT_UpLine 					; go up one line.
.0181fa	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.0181fc	80 02		bra $018200			bra 	TIM_ShowPrompt
.0181fe					TIM_NewCommand:
.0181fe	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.018200					TIM_ShowPrompt:
.018200	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.018203	20 fa 80	jsr $0180fa			jsr 	IFT_ReadLine	 			; get character, go to next line
.018206	20 5c 80	jsr $01805c			jsr 	IFT_NewLine					; go to next line.
.018209	86 10		stx $10				stx 	zTemp1 						; save line read address
.01820b	84 11		sty $11				sty 	zTemp1+1
.01820d	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.01820f	b1 10		lda ($10),y			lda 	(zTemp1),y
.018211	c9 3f		cmp #$3f			cmp 	#"?"
.018213	f0 04		beq $018219			beq 	TIM_SkipFirst
.018215	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.018217	d0 01		bne $01821a			bne 	TIM_NotDot
.018219					TIM_SkipFirst:
.018219	c8		iny				iny
.01821a					TIM_NotDot:
.01821a	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.01821c	c9 52		cmp #$52			cmp 	#"R"						; show registers
.01821e	f0 6b		beq $01828b			beq 	TIM_ShowRegisters
.018220	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.018222	f0 12		beq $018236			beq 	TIM_ShowMemory
.018224	c9 47		cmp #$47			cmp 	#"G"						; execute
.018226	f0 49		beq $018271			beq 	TIM_Execute
.018228	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.01822a	f0 07		beq $018233			beq 	TIM_GoLoadMemory
.01822c	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.01822e	d0 c7		bne $0181f7			bne 	TIM_Error
.018230	4c af 83	jmp $0183af			jmp 	TIM_UpdateRegisters
.018233					TIM_GoLoadMemory:
.018233	4c df 83	jmp $0183df			jmp 	TIM_LoadMemory
.018236					TIM_ShowMemory:
.018236	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.018239	b0 bc		bcs $0181f7			bcs 	TIM_Error
.01823b	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.01823d	85 12		sta $12				sta 	zTemp2
.01823f	a5 15		lda $15				lda 	zTemp3+1
.018241	85 13		sta $13				sta 	zTemp2+1
.018243	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.018246	90 08		bcc $018250			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.018248	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.01824a	85 14		sta $14				sta 	zTemp3
.01824c	a5 13		lda $13				lda 	zTemp2+1
.01824e	85 15		sta $15				sta 	zTemp3+1
.018250					_TIMSM_Start:
.018250	20 03 83	jsr $018303			jsr 	TIM_WriteLine 				; write one line of hex out
.018253	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.018255	18		clc				clc
.018256	69 10		adc #$10			adc 	#16
.018258	85 12		sta $12				sta 	zTemp2
.01825a	90 02		bcc $01825e			bcc 	_TIMSM_NoCarry
.01825c	e6 13		inc $13				inc 	zTemp2+1
.01825e					_TIMSM_NoCarry:
.01825e	20 e1 81	jsr $0181e1			jsr 	IF_CheckBreak 				; check CTL+C
.018261	d0 0b		bne $01826e			bne 	_TIMSM_Ends 				; if pressed break out.
.018263	38		sec				sec 								; check past the end address in zTemp3
.018264	a5 14		lda $14				lda 	zTemp3
.018266	e5 12		sbc $12				sbc 	zTemp2
.018268	a5 15		lda $15				lda 	zTemp3+1
.01826a	e5 13		sbc $13				sbc 	zTemp2+1
.01826c	10 e2		bpl $018250			bpl 	_TIMSM_Start
.01826e					_TIMSM_Ends:
.01826e	4c fe 81	jmp $0181fe			jmp 	TIM_NewCommand
.018271					TIM_Execute:
.018271	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; get the execute address
.018274	b0 81		bcs $0181f7			bcs 	TIM_Error 					; not legitimate
.018276	ae c2 03	ldx $03c2			ldx 	TIM_SP 						; set up SP
.018279	9a		txs				txs
.01827a	ad bd 03	lda $03bd			lda 	TIM_SR 						; Status for PLP
.01827d	48		pha				pha
.01827e	ad be 03	lda $03be			lda 	TIM_A 						; restore AXYZ
.018281	ae bf 03	ldx $03bf			ldx 	TIM_X
.018284	ac c0 03	ldy $03c0			ldy 	TIM_Y
.018287	28		plp				plp 								; and PS Byte.
.018288	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.01828b					TIM_Start:
.01828b					TIM_ShowRegisters:
.01828b	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.01828e	8d bc 03	sta $03bc			sta 	TIM_IRQ+1
.018291	ad ff ff	lda $ffff			lda 	$FFFF
.018294	8d bb 03	sta $03bb			sta 	TIM_IRQ
.018297	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.018299					_TIMSR_Text:
.018299	bf ca 82 01	lda $0182ca,x			lda 	_TIMSR_Label,x
.01829d	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182a0	e8		inx				inx
.0182a1	e0 20		cpx #$20			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.0182a3	d0 f4		bne $018299			bne 	_TIMSR_Text
.0182a5	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.0182a7					_TIMSR_Skip:
.0182a7	e8		inx				inx
.0182a8					_TIMSR_LoopSpace:
.0182a8	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.0182aa	b0 04		bcs $0182b0			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.0182ac	8a		txa				txa
.0182ad	4a		lsr a				lsr 	a
.0182ae	b0 05		bcs $0182b5			bcs 	_TIMSR_NoSpace
.0182b0					_TIMSR_Space:
.0182b0	a9 20		lda #$20			lda 	#" "
.0182b2	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182b5					_TIMSR_NoSpace:
.0182b5	bd b9 03	lda $03b9,x			lda 	TIM_PC,x 					; output hex value.
.0182b8	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.0182bb	e8		inx				inx
.0182bc	e0 08		cpx #$08			cpx 	#TIM_Z-TIM_PC
.0182be	f0 e7		beq $0182a7			beq 	_TIMSR_Skip
.0182c0	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.0182c2	d0 e4		bne $0182a8			bne 	_TimSR_LoopSpace
.0182c4	20 5c 80	jsr $01805c			jsr 	IFT_NewLine 				; new line
.0182c7	4c fe 81	jmp $0181fe			jmp	 	TIM_NewCommand 				; new command.
.0182ca					_TIMSR_Label:
>0182ca	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>0182d2	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>0182e2	52
>0182e3	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.0182ea					_TIMSR_LabelEnd:
.0182ea					TIM_WriteHex:
.0182ea	48		pha				pha 								; save A
.0182eb	4a		lsr a				lsr 	a 							; shift MSB->LSB
.0182ec	4a		lsr a				lsr 	a
.0182ed	4a		lsr a				lsr 	a
.0182ee	4a		lsr a				lsr 	a
.0182ef	20 f3 82	jsr $0182f3			jsr 	_TIMWH_Nibble 				; print MSB
.0182f2	68		pla				pla 								; restore and print LSB
.0182f3					_TIMWH_Nibble:
.0182f3	48		pha				pha
.0182f4	29 0f		and #$0f			and 	#15 						; mask out
.0182f6	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.0182f8	90 02		bcc $0182fc			bcc 	_TIMWHNoLetter
.0182fa	69 06		adc #$06			adc 	#6
.0182fc					_TIMWHNoLetter:
.0182fc	69 30		adc #$30			adc 	#48
.0182fe	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter 			; print it out.
.018301	68		pla				pla
.018302	60		rts				rts
.018303					TIM_WriteLine:
.018303	a9 2e		lda #$2e			lda 	#"." 						; prompt
.018305	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018308	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.01830a	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01830d	a5 13		lda $13				lda 	zTemp2+1 					; write address
.01830f	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.018312	a5 12		lda $12				lda 	zTemp2
.018314	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.018317	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.018319					_TIMWL_Loop:
.018319	a9 20		lda #$20			lda 	#" "
.01831b	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01831e	b1 12		lda ($12),y			lda 	(zTemp2),y
.018320	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.018323	c8		iny				iny
.018324	c0 10		cpy #$10			cpy 	#16
.018326	d0 f1		bne $018319			bne 	_TIMWL_Loop
.018328	4c 5c 80	jmp $01805c			jmp 	IFT_NewLine 				; new line and exit
.01832b					TIM_GetHex:
.01832b	c8		iny				iny
.01832c	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.01832e	c9 20		cmp #$20			cmp 	#32
.018330	f0 f9		beq $01832b			beq 	TIM_GetHex
.018332	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.018334	f0 f5		beq $01832b			beq 	TIM_GetHex
.018336	20 5f 83	jsr $01835f			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.018339	b0 23		bcs $01835e			bcs 	_TIMGH_Exit					; if first bad then exit now.
.01833b	a9 00		lda #$00			lda 	#0 							; zero result
.01833d	85 14		sta $14				sta 	zTemp3
.01833f	85 15		sta $15				sta 	zTemp3+1
.018341					_TIM_GHLoop:
.018341	20 5f 83	jsr $01835f			jsr 	TIM_GetHexCharacter 		; get next character
.018344	b0 17		bcs $01835d			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.018346	c8		iny				iny 								; skip over it.
.018347	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.018349	26 15		rol $15				rol 	zTemp3+1
.01834b	06 14		asl $14				asl 	zTemp3 						; now x 2
.01834d	26 15		rol $15				rol 	zTemp3+1
.01834f	06 14		asl $14				asl 	zTemp3						; now x 4
.018351	26 15		rol $15				rol 	zTemp3+1
.018353	06 14		asl $14				asl 	zTemp3 						; now x 8
.018355	26 15		rol $15				rol 	zTemp3+1
.018357	05 14		ora $14				ora 	zTemp3 						; OR result in
.018359	85 14		sta $14				sta 	zTemp3
.01835b	80 e4		bra $018341			bra 	_TIM_GHLoop 				; loop round again.
.01835d					_TIMGH_Okay:
.01835d	18		clc				clc
.01835e					_TIMGH_Exit:
.01835e	60		rts				rts
.01835f					TIM_GetHexCharacter:
.01835f	b1 10		lda ($10),y			lda 	(zTemp1),y
.018361	38		sec				sec
.018362	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.018364	90 0e		bcc $018374			bcc 	_TIM_GHCFail
.018366	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.018368	90 0b		bcc $018375			bcc 	_TIM_GHCExit
.01836a	c9 11		cmp #$11			cmp 	#65-48						; < A
.01836c	90 06		bcc $018374			bcc		_TIM_GHCFail
.01836e	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.018370	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.018372	90 01		bcc $018375			bcc		_TIM_GHCExit
.018374					_TIM_GHCFail:
.018374	38		sec				sec
.018375					_TIM_GHCExit:
.018375	60		rts				rts
.018376					TIM_BreakVector:
.018376	da		phx				phx									; save X/A on stack
.018377	48		pha				pha
.018378	ba		tsx				tsx 								; X points to S
.018379	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.01837c	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.01837e	d0 03		bne $018383			bne 	_TIMBreak					; if set, it's BRK
.018380	68		pla				pla 								; abandon routine.
.018381	fa		plx				plx
.018382	40		rti				rti
.018383					_TIMBreak:
.018383	68		pla				pla 								; save A X Y and maybe Z
.018384	8d be 03	sta $03be			sta 	TIM_A
.018387	fa		plx				plx
.018388	8e bf 03	stx $03bf			stx 	TIM_X
.01838b	8c c0 03	sty $03c0			sty 	TIM_Y
.01838e	68		pla				pla 								; get Status Register
.01838f	8d bd 03	sta $03bd			sta 	TIM_SR
.018392	68		pla				pla
.018393	8d ba 03	sta $03ba			sta 	TIM_PC+1 					; save calling address
.018396	68		pla				pla
.018397	8d b9 03	sta $03b9			sta 	TIM_PC 						; high byte
.01839a	ad ba 03	lda $03ba			lda 	TIM_PC+1 					; dec PC to point right.
.01839d	d0 03		bne $0183a2			bne 	_TIMDecrement 				; brk bumps it.
.01839f	ce b9 03	dec $03b9			dec 	TIM_PC
.0183a2					_TIMDecrement:
.0183a2	ce ba 03	dec $03ba			dec 	TIM_PC+1
.0183a5	ba		tsx				tsx 								; and copy SP
.0183a6	8e c2 03	stx $03c2			stx 	TIM_SP
.0183a9	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.0183ab	9a		txs				txs
.0183ac	4c 8b 82	jmp $01828b			jmp 	TIM_Start 					; and start up TIM monitor.
.0183af					TIM_UpdateRegisters:
.0183af	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; PC
.0183b2	b0 28		bcs $0183dc			bcs 	_TIMURFail
.0183b4	a5 14		lda $14				lda 	zTemp3
.0183b6	8d ba 03	sta $03ba			sta 	Tim_PC+1
.0183b9	a5 15		lda $15				lda 	zTemp3+1
.0183bb	8d b9 03	sta $03b9			sta 	Tim_PC
.0183be	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; ignore IRQ
.0183c1	b0 19		bcs $0183dc			bcs 	_TIMURFail
.0183c3	a2 00		ldx #$00			ldx 	#0
.0183c5					_TIM_URLoop:
.0183c5	e0 04		cpx #$04			cpx 	#Tim_Z-Tim_SR
.0183c7	d0 01		bne $0183ca			bne 	_TIM_1
.0183c9	e8		inx				inx
.0183ca					_TIM_1:
.0183ca	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; registers
.0183cd	b0 0d		bcs $0183dc			bcs 	_TIMURFail
.0183cf	a5 14		lda $14				lda 	zTemp3
.0183d1	9d bd 03	sta $03bd,x			sta 	Tim_SR,x
.0183d4	e8		inx				inx
.0183d5	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.0183d7	d0 ec		bne $0183c5			bne 	_TIM_URLoop
.0183d9	4c fe 81	jmp $0181fe			jmp 	TIM_NewCommand
.0183dc					_TIMURFail:
.0183dc	4c f7 81	jmp $0181f7			jmp 	TIM_Error
.0183df					TIM_LoadMemory:
.0183df	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; target address => zTemp2
.0183e2	a5 14		lda $14				lda 	zTemp3
.0183e4	85 12		sta $12				sta 	zTemp2
.0183e6	a5 15		lda $15				lda 	zTemp3+1
.0183e8	85 13		sta $13				sta 	zTemp2+1
.0183ea					_TIM_LMLoop:
.0183ea	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; next byte ?
.0183ed	b0 0e		bcs $0183fd			bcs 	_TIMLMDone 					; no more
.0183ef	a2 00		ldx #$00			ldx 	#0							; write out.
.0183f1	a5 14		lda $14				lda 	zTemp3
.0183f3	81 12		sta ($12,x)			sta 	(zTemp2,x)
.0183f5	e6 12		inc $12				inc 	zTemp2 						; bump address
.0183f7	d0 f1		bne $0183ea			bne 	_TIM_LMLoop
.0183f9	e6 13		inc $13				inc 	zTemp2+1
.0183fb	80 ed		bra $0183ea			bra 	_TIM_LMLoop
.0183fd					_TIMLMDone:
.0183fd	4c fe 81	jmp $0181fe			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stack.asm

.018400					StackReset:
.018400	48		pha				pha
.018401	5a		phy				phy
.018402	a9 00		lda #$00			lda 	#(BasicStack & $FF) 		; reset pointer
.018404	85 26		sta $26				sta 	zBasicSP
.018406	a9 04		lda #$04			lda 	#(BasicStack >> 8)
.018408	85 27		sta $27				sta 	zBasicSP+1
.01840a	a0 00		ldy #$00			ldy 	#0 							; reset stack top to $00 which cannot
.01840c	98		tya				tya 								; be a legal token.
.01840d	91 26		sta ($26),y			sta 	(zBasicSP),y
.01840f	7a		ply				ply
.018410	68		pla				pla
.018411	60		rts				rts
.018412					StackPushFrame:
.018412	48		pha				pha
.018413	5a		phy				phy
.018414	1a		inc a				inc 	a 							; one extra byte in frame, for the marker.
.018415	48		pha				pha 								; save it.
.018416	29 0f		and #$0f			and 	#$0F 						; lower 4 bits
.018418	18		clc				clc 								; add to Basic Stack
.018419	65 26		adc $26				adc 	zBasicSP
.01841b	85 26		sta $26				sta 	zBasicSP
.01841d	90 02		bcc $018421			bcc 	_SPFNoBump
.01841f	e6 27		inc $27				inc 	zBasicSP+1
.018421					_SPFNoBump:
.018421	a0 00		ldy #$00			ldy 	#0
.018423	68		pla				pla
.018424	91 26		sta ($26),y			sta 	(zBasicSP),y
.018426	7a		ply				ply
.018427	68		pla				pla
.018428	60		rts				rts
.018429					StackPopFrame:
.018429	48		pha				pha
.01842a	5a		phy				phy
.01842b	a0 00		ldy #$00			ldy 	#0 							; compare with top of stack using EOR
.01842d	51 26		eor ($26),y			eor 	(zBasicSP),y
.01842f	29 f0		and #$f0			and 	#$F0 						; top 4 bits zero, match
.018431	d0 12		bne $018445			bne 	_SPFError 					; mixed structures
.018433	b1 26		lda ($26),y			lda 	(zBasicSP),y 				; get size from byte
.018435	29 0f		and #$0f			and 	#$0F
.018437	49 ff		eor #$ff			eor 	#$FF						; 2's complement
.018439	38		sec				sec
.01843a	65 26		adc $26				adc 	zBasicSP
.01843c	85 26		sta $26				sta 	zBasicSP
.01843e	b0 02		bcs $018442			bcs 	_SPFNoBump
.018440	c6 27		dec $27				dec 	zBasicSP+1
.018442					_SPFNoBump:
.018442	7a		ply				ply
.018443	68		pla				pla
.018444	60		rts				rts
.018445					_SPFError:
.018445	20 ca 84	jsr $0184ca			jsr ERR_Handler
>018448	4d 69 78 65 64 20 53 74			.text "Mixed Structures",0
>018450	72 75 63 74 75 72 65 73 00
.018459					StackSavePosition:
.018459	98		tya				tya
.01845a	5a		phy				phy
.01845b	a0 05		ldy #$05			ldy 	#5
.01845d	91 26		sta ($26),y			sta 	(zBasicSP),y
.01845f	a0 01		ldy #$01			ldy 	#1
.018461	a5 16		lda $16				lda 	zCodePtr+0 					; 4 bytes, could reduce this for 65816/6502
.018463	91 26		sta ($26),y			sta 	(zBasicSP),y
.018465	c8		iny				iny
.018466	a5 17		lda $17				lda 	zCodePtr+1
.018468	91 26		sta ($26),y			sta 	(zBasicSP),y
.01846a	c8		iny				iny
.01846b	a5 18		lda $18				lda 	zCodePtr+2
.01846d	91 26		sta ($26),y			sta 	(zBasicSP),y
.01846f	c8		iny				iny
.018470	a5 19		lda $19				lda 	zCodePtr+3
.018472	91 26		sta ($26),y			sta 	(zBasicSP),y
.018474	7a		ply				ply
.018475	60		rts				rts
.018476					StackRestorePosition:
.018476	5a		phy				phy
.018477	a0 01		ldy #$01			ldy 	#1 							; copy 4 bytes that are the pointer
.018479	b1 26		lda ($26),y			lda 	(zBasicSP),y
.01847b	85 16		sta $16				sta 	zCodePtr+0
.01847d	c8		iny				iny
.01847e	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018480	85 17		sta $17				sta 	zCodePtr+1
.018482	c8		iny				iny
.018483	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018485	85 18		sta $18				sta 	zCodePtr+2
.018487	c8		iny				iny
.018488	b1 26		lda ($26),y			lda 	(zBasicSP),y
.01848a	85 19		sta $19				sta 	zCodePtr+3
.01848c	c8		iny				iny
.01848d	b1 26		lda ($26),y			lda 	(zBasicSP),y 				; offset
.01848f	7a		ply				ply 								; restore Y
.018490	a8		tay				tay
.018491	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/vectors.asm

.018492					CharPrint:
.018492	4c 35 80	jmp $018035			jmp 	IFT_PrintCharacter
.018495					CharGet:
.018495	4c e6 81	jmp $0181e6			jmp 	IF_GetKey
.018498					CheckBreak:
.018498	4c e1 81	jmp $0181e1			jmp 	IF_CheckBreak

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/errors.asm

.01849b					SyntaxError:
.01849b	20 ca 84	jsr $0184ca			jsr 	ERR_Handler
>01849e	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>0184a6	72 72 6f 72 00
.0184ab					TypeError:
.0184ab	20 ca 84	jsr $0184ca			jsr 	ERR_Handler
>0184ae	57 72 6f 6e 67 20 74 79				.text 	"Wrong type",0
>0184b6	70 65 00
.0184b9					BadParamError:
.0184b9	20 ca 84	jsr $0184ca			jsr 	ERR_Handler
>0184bc	42 61 64 20 50 61 72 61				.text 	"Bad Parameter",0
>0184c4	6d 65 74 65 72 00
.0184ca					ERR_Handler:
.0184ca	a0 00		ldy #$00			ldy 	#0
.0184cc	c8		iny				iny
.0184cd	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0184cf	85 80		sta $80				sta 	XS_Mantissa
.0184d1	c8		iny				iny
.0184d2	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0184d4	85 81		sta $81				sta 	XS_Mantissa+1
.0184d6	fa		plx				plx 								; address in XY
.0184d7	7a		ply				ply
.0184d8	e8		inx				inx 								; bump, because of RTS/JSR address -1
.0184d9	d0 01		bne $0184dc			bne 	_EHNoSkip
.0184db	c8		iny				iny
.0184dc					_EHNoSkip:
.0184dc	20 fb 84	jsr $0184fb			jsr 	PrintROMMessage 			; print message from ROM.
.0184df	a5 80		lda $80				lda 	XS_Mantissa					; line number = 0
.0184e1	05 81		ora $81				ora 	XS_Mantissa+1
.0184e3	f0 0c		beq $0184f1			beq 	_EHNoLine
.0184e5	a2 f6		ldx #$f6			ldx 	#_EHAt & $FF 				; print " at "
.0184e7	a0 84		ldy #$84			ldy 	#(_EHAt >> 8) & $FF
.0184e9	20 fb 84	jsr $0184fb			jsr 	PrintROMMessage
.0184ec	a2 00		ldx #$00			ldx 	#0 							; Print line number
.0184ee	20 10 85	jsr $018510			jsr 	Print16BitInteger
.0184f1					_EHNoLine:
.0184f1	80 fe		bra $0184f1			bra 	_EHNoLine
.0184f3	4c 72 87	jmp $018772			jmp 	WarmStart
>0184f6	20 61 74 20 00			_EHAt:	.text 	" at ",0
.0184fb					PrintROMMessage:
.0184fb	86 1a		stx $1a				stx 	zLTemp1 					; save addres
.0184fd	84 1b		sty $1b				sty 	zLTemp1+1
.0184ff	4b		phk				phk
.018500	68		pla				pla
.018501	85 1c		sta $1c				sta 	ZLTemp1+2
.018503	a0 00		ldy #$00			ldy 	#0
.018505					_PRMLoop:
.018505	b7 1a		lda [$1a],y			lda 	[zLTemp1],y
.018507	f0 06		beq $01850f			beq		_PRMExit
.018509	c8		iny				iny
.01850a	20 92 84	jsr $018492			jsr 	CharPrint
.01850d	80 f6		bra $018505			bra 	_PRMLoop
.01850f					_PRMExit:
.01850f	60		rts				rts
.018510					Print16BitInteger:
.018510	a9 00		lda #$00			lda 	#0 							; make 32 bit
.018512	85 82		sta $82				sta 	XS_Mantissa+2
.018514	85 83		sta $83				sta 	XS_Mantissa+3
.018516					Print32BitInteger:
.018516	a9 00		lda #$00			lda 	#0
.018518	8d 14 03	sta $0314			sta 	NumBufX 					; reset the conversion pointer
.01851b	aa		tax				tax 								; convert bottom level.
.01851c	20 e5 98	jsr $0198e5			jsr 	INTToString 				; make string
.01851f	a2 00		ldx #$00			ldx 	#0 							; print buffer
.018521	bd 15 03	lda $0315,x	_P1Loop:lda 	Num_Buffer,x
.018524	f0 06		beq $01852c			beq 	_P1Exit
.018526	20 92 84	jsr $018492			jsr 	CharPrint
.018529	e8		inx				inx
.01852a	80 f5		bra $018521			bra 	_P1Loop
.01852c	8a		txa		_P1Exit:txa 								; return chars printed.
.01852d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm


;******  Processing file: modules/basic/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b6					lastUnaryFunction = $b6
.01852e					VectorTable:
>01852e	59 8d					.word BinaryOp_And         & $FFFF ; $80 and
>018530	75 8d					.word BinaryOp_Or          & $FFFF ; $81 or
>018532	91 8d					.word BinaryOp_Xor         & $FFFF ; $82 xor
>018534	91 8d					.word BinaryOp_Eor         & $FFFF ; $83 eor
>018536	c8 8d					.word Binary_Equal         & $FFFF ; $84 =
>018538	e2 8d					.word Binary_NotEqual      & $FFFF ; $85 <>
>01853a	eb 8d					.word Binary_Less          & $FFFF ; $86 <
>01853c	f4 8d					.word Binary_LessEqual     & $FFFF ; $87 <=
>01853e	06 8e					.word Binary_Greater       & $FFFF ; $88 >
>018540	fd 8d					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>018542	8b 8e					.word BinaryOp_Add         & $FFFF ; $8a +
>018544	a7 8e					.word BinaryOp_Subtract    & $FFFF ; $8b -
>018546	b8 8e					.word BinaryOp_Multiply    & $FFFF ; $8c *
>018548	c9 8e					.word BinaryOp_Divide      & $FFFF ; $8d /
>01854a	ea 85					.word NotImplemented       & $FFFF ; $8e ^
>01854c	ea 85					.word NotImplemented       & $FFFF ; $8f if
>01854e	ea 85					.word NotImplemented       & $FFFF ; $90 while
>018550	7d 8b					.word Command_REPEAT       & $FFFF ; $91 repeat
>018552	ea 85					.word NotImplemented       & $FFFF ; $92 for
>018554	ea 85					.word NotImplemented       & $FFFF ; $93 then
>018556	ea 85					.word NotImplemented       & $FFFF ; $94 endif
>018558	ea 85					.word NotImplemented       & $FFFF ; $95 wend
>01855a	86 8b					.word Command_UNTIL        & $FFFF ; $96 until
>01855c	ea 85					.word NotImplemented       & $FFFF ; $97 next
>01855e	ea 85					.word NotImplemented       & $FFFF ; $98 not
>018560	ea 85					.word NotImplemented       & $FFFF ; $99 fn(
>018562	ce 8f					.word Unary_Abs            & $FFFF ; $9a abs(
>018564	0f 91					.word Unary_Asc            & $FFFF ; $9b asc(
>018566	d4 9f					.word Unary_Int            & $FFFF ; $9c int(
>018568	e8 8f					.word Unary_Peek           & $FFFF ; $9d peek(
>01856a	55 9f					.word Unary_Rnd            & $FFFF ; $9e rnd(
>01856c	4f 90					.word Unary_Usr            & $FFFF ; $9f usr(
>01856e	4e 91					.word Unary_Left           & $FFFF ; $a0 left$(
>018570	63 91					.word Unary_Right          & $FFFF ; $a1 right$(
>018572	35 91					.word Unary_Mid            & $FFFF ; $a2 mid$(
>018574	ac 92					.word Unary_Spc            & $FFFF ; $a3 spc(
>018576	dd 90					.word Unary_Str            & $FFFF ; $a4 str$(
>018578	71 90					.word Unary_Val            & $FFFF ; $a5 val(
>01857a	26 91					.word Unary_Len            & $FFFF ; $a6 len(
>01857c	db 91					.word Unary_Hex            & $FFFF ; $a7 hex$(
>01857e	ea 85					.word NotImplemented       & $FFFF ; $a8 sin(
>018580	ea 85					.word NotImplemented       & $FFFF ; $a9 cos(
>018582	ea 85					.word NotImplemented       & $FFFF ; $aa tan(
>018584	ea 85					.word NotImplemented       & $FFFF ; $ab atn(
>018586	ea 85					.word NotImplemented       & $FFFF ; $ac exp(
>018588	ea 85					.word NotImplemented       & $FFFF ; $ad log(
>01858a	ea 85					.word NotImplemented       & $FFFF ; $ae sqr(
>01858c	31 92					.word Unary_Dec            & $FFFF ; $af dec(
>01858e	ec 8f					.word Unary_Deek           & $FFFF ; $b0 deek(
>018590	f0 8f					.word Unary_Leek           & $FFFF ; $b1 leek(
>018592	1c 90					.word Unary_Mod            & $FFFF ; $b2 mod(
>018594	88 8f					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>018596	8e 92					.word Unary_Chr            & $FFFF ; $b4 chr$(
>018598	ea 85					.word NotImplemented       & $FFFF ; $b5 pos(
>01859a	ea 85					.word NotImplemented       & $FFFF ; $b6 tab(
>01859c	ea 85					.word NotImplemented       & $FFFF ; $b7 $
>01859e	ea 85					.word NotImplemented       & $FFFF ; $b8 $(
>0185a0	ea 85					.word NotImplemented       & $FFFF ; $b9 #
>0185a2	ea 85					.word NotImplemented       & $FFFF ; $ba #(
>0185a4	ea 85					.word NotImplemented       & $FFFF ; $bb %
>0185a6	ea 85					.word NotImplemented       & $FFFF ; $bc %(
>0185a8	ea 85					.word NotImplemented       & $FFFF ; $bd (
>0185aa	ea 85					.word NotImplemented       & $FFFF ; $be )
>0185ac	ea 85					.word NotImplemented       & $FFFF ; $bf ,
>0185ae	95 88					.word Command_COLON        & $FFFF ; $c0 :
>0185b0	ea 85					.word NotImplemented       & $FFFF ; $c1 ;
>0185b2	ea 85					.word NotImplemented       & $FFFF ; $c2 def
>0185b4	61 8b					.word Command_CLR          & $FFFF ; $c3 clr
>0185b6	75 8b					.word Command_STOP         & $FFFF ; $c4 stop
>0185b8	ea 85					.word NotImplemented       & $FFFF ; $c5 data
>0185ba	ea 85					.word NotImplemented       & $FFFF ; $c6 read
>0185bc	7f 87					.word Command_DIM          & $FFFF ; $c7 dim
>0185be	ea 85					.word NotImplemented       & $FFFF ; $c8 to
>0185c0	ea 85					.word NotImplemented       & $FFFF ; $c9 step
>0185c2	dd 8a					.word Command_GOSUB        & $FFFF ; $ca gosub
>0185c4	eb 8a					.word Command_RETURN       & $FFFF ; $cb return
>0185c6	d7 8a					.word Command_GOTO         & $FFFF ; $cc goto
>0185c8	b7 88					.word Command_END          & $FFFF ; $cd end
>0185ca	ea 85					.word NotImplemented       & $FFFF ; $ce input
>0185cc	96 88					.word Command_LET          & $FFFF ; $cf let
>0185ce	bb 88					.word Command_LIST         & $FFFF ; $d0 list
>0185d0	80 8a					.word Command_NEW          & $FFFF ; $d1 new
>0185d2	9c 8a					.word Command_OLD          & $FFFF ; $d2 old
>0185d4	ea 85					.word NotImplemented       & $FFFF ; $d3 on
>0185d6	ea 85					.word NotImplemented       & $FFFF ; $d4 restore
>0185d8	4f 8a					.word Command_POKE         & $FFFF ; $d5 poke
>0185da	c8 89					.word Command_PRINT        & $FFFF ; $d6 print
>0185dc	07 88					.word Command_RUN          & $FFFF ; $d7 run
>0185de	ea 85					.word NotImplemented       & $FFFF ; $d8 wait
>0185e0	ea 85					.word NotImplemented       & $FFFF ; $d9 sys
>0185e2	53 8a					.word Command_DOKE         & $FFFF ; $da doke
>0185e4	57 8a					.word Command_LOKE         & $FFFF ; $db loke
>0185e6	37 8a					.word Command_ASSERT       & $FFFF ; $dc assert
>0185e8	ea 85					.word NotImplemented       & $FFFF ; $dd get
.0185ea					NotImplemented:
.0185ea	20 ca 84	jsr $0184ca			jsr ERR_Handler
>0185ed	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>0185f5	65 6d 65 6e 74 65 64 00
.0185fd					BinaryPrecedence:
>0185fd	01					.byte 1    ; $80 and
>0185fe	01					.byte 1    ; $81 or
>0185ff	01					.byte 1    ; $82 xor
>018600	01					.byte 1    ; $83 eor
>018601	02					.byte 2    ; $84 =
>018602	02					.byte 2    ; $85 <>
>018603	02					.byte 2    ; $86 <
>018604	02					.byte 2    ; $87 <=
>018605	02					.byte 2    ; $88 >
>018606	02					.byte 2    ; $89 >=
>018607	03					.byte 3    ; $8a +
>018608	03					.byte 3    ; $8b -
>018609	04					.byte 4    ; $8c *
>01860a	04					.byte 4    ; $8d /
>01860b	05					.byte 5    ; $8e ^
.01860c					KeywordText:
>01860c	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>01860f	4f d2					.byte $4f,$d2                          ; $81 or
>018611	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>018614	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>018617	bd					.byte $bd                              ; $84 =
>018618	3c be					.byte $3c,$be                          ; $85 <>
>01861a	bc					.byte $bc                              ; $86 <
>01861b	3c bd					.byte $3c,$bd                          ; $87 <=
>01861d	be					.byte $be                              ; $88 >
>01861e	3e bd					.byte $3e,$bd                          ; $89 >=
>018620	ab					.byte $ab                              ; $8a +
>018621	ad					.byte $ad                              ; $8b -
>018622	aa					.byte $aa                              ; $8c *
>018623	af					.byte $af                              ; $8d /
>018624	de					.byte $de                              ; $8e ^
>018625	49 c6					.byte $49,$c6                          ; $8f if
>018627	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>01862c	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>018632	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>018635	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>018639	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>01863e	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>018642	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>018647	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>01864b	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>01864e	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>018651	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>018655	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>018659	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>01865d	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>018662	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>018666	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>01866a	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>018670	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>018677	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>01867c	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>018680	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>018685	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>018689	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>01868d	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>018692	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>018696	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>01869a	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>01869e	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>0186a2	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>0186a6	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>0186aa	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>0186ae	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>0186b2	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>0186b7	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>0186bc	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>0186c0	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>0186c4	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>0186c9	50 4f 53 a8				.byte $50,$4f,$53,$a8                  ; $b5 pos(
>0186cd	54 41 42 a8				.byte $54,$41,$42,$a8                  ; $b6 tab(
>0186d1	a4					.byte $a4                              ; $b7 $
>0186d2	24 a8					.byte $24,$a8                          ; $b8 $(
>0186d4	a3					.byte $a3                              ; $b9 #
>0186d5	23 a8					.byte $23,$a8                          ; $ba #(
>0186d7	a5					.byte $a5                              ; $bb %
>0186d8	25 a8					.byte $25,$a8                          ; $bc %(
>0186da	a8					.byte $a8                              ; $bd (
>0186db	a9					.byte $a9                              ; $be )
>0186dc	ac					.byte $ac                              ; $bf ,
>0186dd	ba					.byte $ba                              ; $c0 :
>0186de	bb					.byte $bb                              ; $c1 ;
>0186df	44 45 c6				.byte $44,$45,$c6                      ; $c2 def
>0186e2	43 4c d2				.byte $43,$4c,$d2                      ; $c3 clr
>0186e5	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $c4 stop
>0186e9	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c5 data
>0186ed	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c6 read
>0186f1	44 49 cd				.byte $44,$49,$cd                      ; $c7 dim
>0186f4	54 cf					.byte $54,$cf                          ; $c8 to
>0186f6	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c9 step
>0186fa	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $ca gosub
>0186ff	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $cb return
>018705	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $cc goto
>018709	45 4e c4				.byte $45,$4e,$c4                      ; $cd end
>01870c	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $ce input
>018711	4c 45 d4				.byte $4c,$45,$d4                      ; $cf let
>018714	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $d0 list
>018718	4e 45 d7				.byte $4e,$45,$d7                      ; $d1 new
>01871b	4f 4c c4				.byte $4f,$4c,$c4                      ; $d2 old
>01871e	4f ce					.byte $4f,$ce                          ; $d3 on
>018720	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d4 restore
>018727	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d5 poke
>01872b	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d6 print
>018730	52 55 ce				.byte $52,$55,$ce                      ; $d7 run
>018733	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d8 wait
>018737	53 59 d3				.byte $53,$59,$d3                      ; $d9 sys
>01873a	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $da doke
>01873e	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $db loke
>018742	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $dc assert
>018748	47 45 d4				.byte $47,$45,$d4                      ; $dd get
>01874b	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_pos = $b5
=$b6					token_tab = $b6
=$b7					token_dollar = $b7
=$b8					token_dollarlparen = $b8
=$b9					token_hash = $b9
=$ba					token_hashlparen = $ba
=$bb					token_percent = $bb
=$bc					token_percentlparen = $bc
=$bd					token_lparen = $bd
=$be					token_rparen = $be
=$bf					token_comma = $bf
=$c0					token_colon = $c0
=$c1					token_semicolon = $c1
=$c2					token_def = $c2
=$c3					token_clr = $c3
=$c4					token_stop = $c4
=$c5					token_data = $c5
=$c6					token_read = $c6
=$c7					token_dim = $c7
=$c8					token_to = $c8
=$c9					token_step = $c9
=$ca					token_gosub = $ca
=$cb					token_return = $cb
=$cc					token_goto = $cc
=$cd					token_end = $cd
=$ce					token_input = $ce
=$cf					token_let = $cf
=$d0					token_list = $d0
=$d1					token_new = $d1
=$d2					token_old = $d2
=$d3					token_on = $d3
=$d4					token_restore = $d4
=$d5					token_poke = $d5
=$d6					token_print = $d6
=$d7					token_run = $d7
=$d8					token_wait = $d8
=$d9					token_sys = $d9
=$da					token_doke = $da
=$db					token_loke = $db
=$dc					token_assert = $dc
=$dd					token_get = $dd

;******  Return to file: modules/basic/core.asm

.01874c					BASIC_Start:
.01874c	20 a8 81	jsr $0181a8			jsr 	IF_Reset 					; set up and clear screen.
.01874f	20 00 80	jsr $018000			jsr 	IFT_ClearScreen
.018752	a9 5c		lda #$5c			lda 	#$5C 						; JMP Long opcode
.018754	8d 10 03	sta $0310			sta 	LocalVector
.018757	8d 0c 03	sta $030c			sta 	UserVector
.01875a	a9 5f		lda #$5f			lda 	#USRDefault & $FF 			; reset USR vector
.01875c	8d 0d 03	sta $030d			sta 	UserVector+1
.01875f	a9 90		lda #$90			lda 	#(USRDefault >> 8) & $FF
.018761	8d 0e 03	sta $030e			sta 	UserVector+2
.018764	a9 01		lda #$01			lda 	#(USRDefault >> 16) & $FF
.018766	8d 0f 03	sta $030f			sta 	UserVector+3
.018769	20 06 93	jsr $019306			jsr 	UpdateProgramEnd 			; update the program end.
.01876c	20 61 8b	jsr $018b61			jsr 	ResetRunStatus 				; clear everything (CLR command)
.01876f	4c 07 88	jmp $018807			jmp 	COMMAND_Run
.018772					WarmStart:
.018772	c2 30		rep #$30			rep 	#$30
.018774	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.018777	1b		tcs				tcs
.018778	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.01877b	e2 30		sep #$30			sep 	#$30
.01877d	80 f3		bra $018772			bra 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/dim.asm

.01877f					Command_DIM:
.01877f	98		tya				tya
.018780	48		pha				pha 								; push on stack.
.018781	20 6e 94	jsr $01946e			jsr 	VariableExtract 			; get the identifier
.018784	ad 95 03	lda $0395			lda 	Var_Type 					; check it is an array
.018787	29 01		and #$01			and 	#1
.018789	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.01878b	d0 6c		bne $0187f9			bne 	_CDIError
.01878d	a9 00		lda #$00			lda 	#0 							; reset the DIM index. The dimensions are
.01878f	8d b8 03	sta $03b8			sta 	UsrArrayIdx 				; built up here and copied in case we autodim
.018792					_CDIGetDimension:
.018792	ad b8 03	lda $03b8			lda 	UsrArrayIdx 				; done too many ?
.018795	c9 06		cmp #$06			cmp 	#ArrayMaxDim*2
.018797	f0 60		beq $0187f9			beq 	_CDIError
.018799	20 3a 8d	jsr $018d3a			jsr 	EvaluateInteger 			; evaluate an index size
.01879c	a5 81		lda $81				lda 	XS_Mantissa+1 				; check in range 0-7FFF
.01879e	29 80		and #$80			and 	#$80
.0187a0	05 82		ora $82				ora 	XS_Mantissa+2
.0187a2	05 83		ora $83				ora 	XS_Mantissa+3
.0187a4	d0 53		bne $0187f9			bne 	_CDIError
.0187a6	ae b8 03	ldx $03b8			ldx 	UsrArrayIdx 				; copy into the array table.
.0187a9	18		clc				clc 								; add 1 - max index => size.
.0187aa	a5 80		lda $80				lda 	XS_Mantissa+0
.0187ac	69 01		adc #$01			adc 	#1
.0187ae	9d b0 03	sta $03b0,x			sta 	UsrArrayDef+0,x
.0187b1	a5 81		lda $81				lda 	XS_Mantissa+1
.0187b3	69 00		adc #$00			adc 	#0
.0187b5	9d b1 03	sta $03b1,x			sta 	UsrArrayDef+1,x
.0187b8	30 3f		bmi $0187f9			bmi 	_CDIError 					; could be dim a(32767)
.0187ba	e8		inx				inx 								; bump index.
.0187bb	e8		inx				inx
.0187bc	8e b8 03	stx $03b8			stx 	UsrArrayIdx
.0187bf	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0187c1	c8		iny				iny
.0187c2	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another dimension
.0187c4	f0 cc		beq $018792			beq 	_CDIGetDimension
.0187c6	88		dey				dey
.0187c7	20 62 93	jsr $019362			jsr 	CheckNextRParen 			; closing ) present ?
.0187ca	ae b8 03	ldx $03b8			ldx 	UsrArrayIdx 				; copy USR array to default
.0187cd	a9 ff		lda #$ff			lda 	#$FF 						; put end marker in ArrayDef
.0187cf	9d a9 03	sta $03a9,x			sta 	ArrayDef+1,x
.0187d2					_CDICopy:
.0187d2	bd b0 03	lda $03b0,x			lda 	UsrArrayDef,x
.0187d5	9d a8 03	sta $03a8,x			sta 	ArrayDef,x
.0187d8	ca		dex				dex
.0187d9	10 f7		bpl $0187d2			bpl 	_CDICopy
.0187db	68		pla				pla									; position of array identifier
.0187dc	85 10		sta $10				sta 	zTemp1
.0187de	98		tya				tya
.0187df	48		pha				pha
.0187e0	a5 10		lda $10				lda 	zTemp1 						; point to identifier
.0187e2	a8		tay				tay
.0187e3	20 6e 94	jsr $01946e			jsr 	VariableExtract 			; get the identifier
.0187e6	20 07 97	jsr $019707			jsr 	VariableLocate 				; check if it exists already.
.0187e9	b0 0e		bcs $0187f9			bcs 	_CDIError
.0187eb	20 fa 94	jsr $0194fa			jsr 	VariableCreate 				; create it using the current ArrayDef
.0187ee	68		pla				pla 								; restore code position
.0187ef	a8		tay				tay
.0187f0	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0187f2	c8		iny				iny
.0187f3	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another DIM
.0187f5	f0 88		beq $01877f			beq 	Command_DIM
.0187f7	88		dey				dey
.0187f8	60		rts				rts
.0187f9					_CDIError:
.0187f9	20 ca 84	jsr $0184ca			jsr ERR_Handler
>0187fc	42 61 64 20 44 49 4d 00			.text "Bad DIM",0
.018804					_CDISyntax:
.018804	4c 9b 84	jmp $01849b			jmp 	SyntaxError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/run.asm

.018807					Command_RUN:
.018807	20 61 8b	jsr $018b61			jsr 	ResetRunStatus 				; clear, reset stacks etc.
.01880a	a9 00		lda #$00			lda 	#BasicProgram & $FF
.01880c	85 16		sta $16				sta 	zCodePtr+0
.01880e	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018810	85 17		sta $17				sta 	zCodePtr+1
.018812	a9 00		lda #$00			lda 	#0
.018814	85 18		sta $18				sta 	zCodePtr+2
.018816	85 19		sta $19				sta 	zCodePtr+3
.018818	a0 03		ldy #$03			ldy 	#3
.01881a					RUN_NewLine:
.01881a	a0 00		ldy #$00			ldy 	#0
.01881c	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01881e	c8		iny				iny
.01881f	c8		iny				iny
.018820	c8		iny				iny
.018821	c9 00		cmp #$00			cmp 	#0 							; if the offset is zero then END.
.018823	d0 16		bne $01883b			bne 	RUN_NextCommand
.018825	4c b7 88	jmp $0188b7			jmp 	Command_END 				; go do the command code.
.018828					RUN_Skip:
.018828	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.01882a	c8		iny				iny 								; skip
.01882b	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.01882d	90 0c		bcc $01883b			bcc 	_SEDone 					; so just skip over it.
.01882f	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018831	90 07		bcc $01883a			bcc 	_SEDouble
.018833	98		tya				tya 								; this is Y + 1
.018834	18		clc				clc
.018835	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018837	a8		tay				tay 								; back in Y.
.018838	88		dey				dey 								; fix up, one for the +1, one for the iny
.018839	88		dey				dey
.01883a					_SEDouble:
.01883a	c8		iny				iny
.01883b					_SEDone:
.01883b					RUN_NextCommand:
.01883b	ad a7 03	lda $03a7			lda 	BreakCount 					; break counter
.01883e	69 10		adc #$10			adc 	#16 						; one time in 16
.018840	8d a7 03	sta $03a7			sta 	BreakCount
.018843	90 0a		bcc $01884f			bcc 	RUN_NoCheckBreak
.018845	20 98 84	jsr $018498			jsr 	CheckBreak 					; check for break
.018848	c9 00		cmp #$00			cmp 	#0
.01884a	f0 03		beq $01884f			beq 	RUN_NoCheckBreak
.01884c	4c 75 8b	jmp $018b75			jmp 	Command_STOP 				; stop on BREAK.
.01884f					RUN_NoCheckBreak:
.01884f	a9 00		lda #$00			lda 	#0 							; this resets temporary string allocation.
.018851	85 21		sta $21				sta 	zTempStr+1 					; (initialised when first called)
.018853	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018855	c9 c0		cmp #$c0			cmp 	#token_Colon 				; skip over colons
.018857	f0 cf		beq $018828			beq 	RUN_Skip
.018859	c9 00		cmp #$00			cmp 	#0 							; if non-zero execute whatever
.01885b	d0 0f		bne $01886c			bne 	RUN_Execute
.01885d					RUN_NextLine:
.01885d	a0 00		ldy #$00			ldy 	#0 							; point to offset
.01885f	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.018861	18		clc				clc
.018862	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018864	85 16		sta $16				sta 	zCodePtr
.018866	90 02		bcc $01886a			bcc 	_SNLNoCarry
.018868	e6 17		inc $17				inc 	zCodePtr+1
.01886a					_SNLNoCarry:
.01886a	80 ae		bra $01881a			bra 	RUN_NewLine 				; go do the new line code
.01886c					RUN_Execute:
.01886c	c9 f8		cmp #$f8			cmp 	#$F8 						; handle shifts, REM etc.
.01886e	b0 1e		bcs $01888e			bcs 	RUN_Extension
.018870	c8		iny				iny
.018871	0a		asl a				asl 	a 							; double the character read.
.018872	90 14		bcc $018888			bcc 	RUN_Default 				; if carry clear was $00-$7F, so try LET.
.018874	aa		tax				tax 								; ready to look up.
.018875	bf 2e 85 01	lda $01852e,x			lda 	VectorTable,x 				; copy address into LocalVector
.018879	8d 11 03	sta $0311			sta 	LocalVector+1
.01887c	bf 2f 85 01	lda $01852f,x			lda 	VectorTable+1,x
.018880	8d 12 03	sta $0312			sta 	LocalVector+2
.018883	20 87 8c	jsr $018c87			jsr 	EVCallLocalVector 			; execute the appropriate code.
.018886	80 b3		bra $01883b			bra 	RUN_NextCommand 			; do the next command.
.018888					RUN_Default:
.018888	88		dey				dey
.018889	20 96 88	jsr $018896			jsr 	Command_LET 				; and try LET.
.01888c	80 ad		bra $01883b			bra 	RUN_NextCommand
.01888e					RUN_Extension:
.01888e	c9 ff		cmp #$ff			cmp 	#$FF 						; if $FF (REM)
.018890	f0 96		beq $018828			beq 	RUN_Skip 					; skip over it.
.018892	4c 9b 84	jmp $01849b			jmp 	SyntaxError
.018895					Command_COLON:
.018895	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/let.asm

.018896					Command_LET:
.018896	20 03 94	jsr $019403			jsr 	VariableFind 				; get reference to one variable.
.018899	a9 84		lda #$84			lda 	#token_Equal  				; get equals
.01889b	20 4b 93	jsr $01934b			jsr 	CheckNextToken
.01889e	a5 22		lda $22				lda 	zVarDataPtr 				; save variable info on stack
.0188a0	48		pha				pha
.0188a1	a5 23		lda $23				lda 	zVarDataPtr+1
.0188a3	48		pha				pha
.0188a4	a5 24		lda $24				lda 	zVarType
.0188a6	48		pha				pha
.0188a7	20 a4 8b	jsr $018ba4			jsr 	EvaluateExpression 			; evaluate the RHS.
.0188aa	68		pla				pla 								; restore target variable information.
.0188ab	85 24		sta $24				sta 	zVarType
.0188ad	68		pla				pla
.0188ae	85 23		sta $23				sta 	zVarDataPtr+1
.0188b0	68		pla				pla
.0188b1	85 22		sta $22				sta 	zVarDataPtr
.0188b3	20 9c 97	jsr $01979c			jsr 	VariableSet 				; set the value out.
.0188b6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/end.asm

.0188b7					Command_END:
>0188b7	02						.byte 	2
.0188b8	4c 72 87	jmp $018772			jmp 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/list.asm

.0188bb					Command_LIST:
.0188bb	a9 00		lda #$00			lda 	#BasicProgram & $FF
.0188bd	85 16		sta $16				sta 	zCodePtr+0
.0188bf	a9 10		lda #$10			lda 	#BasicProgram >> 8
.0188c1	85 17		sta $17				sta 	zCodePtr+1
.0188c3	a9 00		lda #$00			lda 	#0
.0188c5	85 18		sta $18				sta 	zCodePtr+2
.0188c7	85 19		sta $19				sta 	zCodePtr+3
.0188c9	a0 03		ldy #$03			ldy 	#3
.0188cb					_CILLoop:
.0188cb	a0 00		ldy #$00			ldy 	#0
.0188cd	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0188cf	c9 00		cmp #$00			cmp 	#0 							; if zero, end of program
.0188d1	f0 19		beq $0188ec			beq 	_CILExit
.0188d3	20 98 84	jsr $018498			jsr 	CheckBreak 					; check break
.0188d6	c9 00		cmp #$00			cmp 	#0
.0188d8	d0 12		bne $0188ec			bne 	_CILExit
.0188da	20 ef 88	jsr $0188ef			jsr 	ListLine 					; list one line.
.0188dd	a0 00		ldy #$00			ldy 	#0 							; point to offset
.0188df	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.0188e1	18		clc				clc
.0188e2	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.0188e4	85 16		sta $16				sta 	zCodePtr
.0188e6	90 02		bcc $0188ea			bcc 	_SNLNoCarry
.0188e8	e6 17		inc $17				inc 	zCodePtr+1
.0188ea					_SNLNoCarry:
.0188ea	80 df		bra $0188cb			bra 	_CILLoop
.0188ec					_CILExit:
.0188ec	4c 72 87	jmp $018772			jmp 	WarmStart
.0188ef					ListLine:
.0188ef	a0 00		ldy #$00			ldy 	#0
.0188f1	c8		iny				iny
.0188f2	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0188f4	85 80		sta $80				sta 	XS_Mantissa
.0188f6	c8		iny				iny
.0188f7	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0188f9	85 81		sta $81				sta 	XS_Mantissa+1
.0188fb	20 10 85	jsr $018510			jsr 	Print16BitInteger 			; print integer.
.0188fe	aa		tax				tax 								; print spaces to column 6
.0188ff					_LISpace:
.0188ff	a9 20		lda #$20			lda 	#" "
.018901	20 92 84	jsr $018492			jsr 	CharPrint
.018904	e8		inx				inx
.018905	e0 06		cpx #$06			cpx 	#6
.018907	d0 f6		bne $0188ff			bne 	_LISpace
.018909					_LIDecode:
.018909	c8		iny				iny
.01890a	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01890c	c9 00		cmp #$00			cmp 	#0 							; zero, exit.
.01890e	f0 0f		beq $01891f			beq 	_LIExit
.018910	30 12		bmi $018924			bmi 	_LIToken
.018912	c9 40		cmp #$40			cmp 	#$40 						; 01-$3F, character.
.018914	b0 50		bcs $018966			bcs 	_LIInteger
.018916	49 20		eor #$20			eor 	#$20 						; make 7 bit
.018918	69 20		adc #$20			adc 	#$20
.01891a	20 bb 89	jsr $0189bb			jsr 	ListPrintLC 				; print in LC
.01891d	80 ea		bra $018909			bra 	_LIDecode
.01891f					_LIExit:
.01891f	a9 0d		lda #$0d			lda 	#13 						; print new line.
.018921	4c 92 84	jmp $018492			jmp 	CharPrint
.018924					_LIToken:
.018924	c9 fc		cmp #$fc			cmp 	#$FC 						; $FC-$FF ?
.018926	90 49		bcc $018971			bcc		_LICommandToken
.018928	48		pha				pha 								; save in case end
.018929	a2 22		ldx #$22			ldx 	#'"'						; print if $FE quoted string
.01892b	c9 fe		cmp #$fe			cmp 	#$FE
.01892d	f0 17		beq $018946			beq 	_LIPrint
.01892f	a2 2e		ldx #$2e			ldx 	#'.'						; print if $FD decimals
.018931	c9 fd		cmp #$fd			cmp 	#$FD
.018933	f0 11		beq $018946			beq 	_LIPrint
.018935	a9 52		lda #$52			lda 	#'R'						; must be REM
.018937	20 bb 89	jsr $0189bb			jsr 	ListPrintLC
.01893a	a9 45		lda #$45			lda 	#'E'
.01893c	20 bb 89	jsr $0189bb			jsr 	ListPrintLC
.01893f	a9 4d		lda #$4d			lda 	#'M'
.018941	20 bb 89	jsr $0189bb			jsr 	ListPrintLC
.018944	a2 20		ldx #$20			ldx 	#' '
.018946					_LIPrint:
.018946	8a		txa				txa
.018947	20 bb 89	jsr $0189bb			jsr 	ListPrintLC
.01894a	c8		iny				iny
.01894b	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01894d	aa		tax				tax 								; put in X
.01894e	ca		dex				dex
.01894f					_LILoop:
.01894f	ca		dex				dex 								; exit when count reached zero.
.018950	f0 08		beq $01895a			beq 	_LIEnd
.018952	c8		iny				iny
.018953	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018955	20 bb 89	jsr $0189bb			jsr 	ListPrintLC
.018958	80 f5		bra $01894f			bra 	_LILoop
.01895a	68		pla		_LIEnd:	pla 								; get A back
.01895b	c9 fe		cmp #$fe			cmp 	#$FE 						; if '"' need closing quotes
.01895d	d0 aa		bne $018909			bne 	_LIDecode
.01895f	a9 22		lda #$22			lda 	#'"'
.018961	20 bb 89	jsr $0189bb			jsr 	ListPrintLC
.018964	80 a3		bra $018909			bra 	_LIDecode
.018966					_LIInteger:
.018966	a2 00		ldx #$00			ldx 	#0
.018968	20 ac 8c	jsr $018cac			jsr 	EvaluateGetInteger 			; get an atom
.01896b	88		dey				dey
.01896c	20 16 85	jsr $018516			jsr 	Print32BitInteger 			; print integer.
.01896f	80 98		bra $018909			bra 	_LIDecode
.018971					_LICommandToken:
.018971	5a		phy				phy 								; save Y
.018972	48		pha				pha 								; save token
.018973	a2 0c		ldx #$0c			ldx  	#KeywordText & $FF 			; address of keyword text table.
.018975	a9 86		lda #$86			lda 	(#KeywordText >> 8) & $FF
.018977	86 1a		stx $1a				stx 	zLTemp1
.018979	85 1b		sta $1b				sta 	zLTemp1+1
.01897b	a9 01		lda #$01			lda 	(#KeywordText >> 16) & $FF 	; this is for 65816 (it's a table in code
.01897d	85 1c		sta $1c				sta 	zLTemp1+2 					; space) and won't affect a 6502 at all.
.01897f	68		pla				pla 								; get token, chuck bit 7.
.018980	29 7f		and #$7f			and 	#127
.018982	f0 16		beq $01899a			beq 	_LIFoundToken
.018984	aa		tax				tax
.018985					_LITokenLoop:
.018985	a0 00		ldy #$00			ldy 	#0
.018987					_LIFindEnd:
.018987	b7 1a		lda [$1a],y			lda 	[zLTemp1],y
.018989	c8		iny				iny
.01898a	0a		asl a				asl 	a
.01898b	90 fa		bcc $018987			bcc 	_LIFindEnd
.01898d	98		tya				tya 								; that is step to the next
.01898e	18		clc				clc 								; we don't bother bumping the 3rd byte
.01898f	65 1a		adc $1a				adc 	zLTemp1 					; here.
.018991	85 1a		sta $1a				sta 	zLTemp1
.018993	90 02		bcc $018997			bcc 	_LINoBump
.018995	e6 1b		inc $1b				inc 	zLTemp1+1
.018997					_LINoBump:
.018997	ca		dex				dex 								; no go round again.
.018998	d0 eb		bne $018985			bne 	_LITokenLoop
.01899a					_LIFoundToken:
.01899a	a0 00		ldy #$00			ldy 	#0
.01899c					_LIPrintToken:
.01899c	b7 1a		lda [$1a],y			lda 	[zLTemp1],y
.01899e	c8		iny				iny
.01899f	48		pha				pha 								; save it
.0189a0	29 7f		and #$7f			and 	#$7F
.0189a2	20 bb 89	jsr $0189bb			jsr 	ListPrintLC
.0189a5	68		pla				pla
.0189a6	10 f4		bpl $01899c			bpl 	_LIPrintToken 				; go back if not end
.0189a8	7a		ply				ply 								; restore Y
.0189a9	29 7f		and #$7f			and 	#$7F 						; if last char is a letter
.0189ab	c9 41		cmp #$41			cmp 	#"A"
.0189ad	90 09		bcc $0189b8			bcc 	_LINotLetter
.0189af	c9 5b		cmp #$5b			cmp 	#"Z"+1
.0189b1	b0 05		bcs $0189b8			bcs 	_LINotLetter
.0189b3	a9 20		lda #$20			lda 	#" " 						; add spacing
.0189b5	20 bb 89	jsr $0189bb			jsr 	ListPrintLC
.0189b8					_LINotLetter:
.0189b8	4c 09 89	jmp $018909			jmp 	_LIDecode
.0189bb					ListPrintLC:
.0189bb	c9 41		cmp #$41			cmp 	#"A"
.0189bd	90 06		bcc $0189c5			bcc 	_LPLC0
.0189bf	c9 5b		cmp #$5b			cmp 	#"Z"+1
.0189c1	b0 02		bcs $0189c5			bcs 	_LPLC0
.0189c3	69 20		adc #$20			adc 	#$20
.0189c5	4c 92 84	jmp $018492	_LPLC0:	jmp 	CharPrint

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/print.asm

.0189c8					Command_PRINT:
.0189c8	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0189ca	c9 00		cmp #$00			cmp 	#0 							; end
.0189cc	f0 65		beq $018a33			beq 	_CPR_NewLine
.0189ce	c9 c0		cmp #$c0			cmp 	#token_Colon
.0189d0	f0 61		beq $018a33			beq 	_CPR_NewLine
.0189d2	c9 c1		cmp #$c1			cmp 	#token_SemiColon
.0189d4	f0 50		beq $018a26			beq 	_CPR_Skip
.0189d6	c9 bf		cmp #$bf			cmp 	#token_Comma
.0189d8	f0 49		beq $018a23			beq 	_CPR_Tab
.0189da	20 a4 8b	jsr $018ba4			jsr 	EvaluateExpression 			; get expression.
.0189dd	a5 85		lda $85				lda 	XS_Type 					; get type.
.0189df	29 02		and #$02			and 	#2
.0189e1	d0 24		bne $018a07			bne 	_CPR_String 				; if type = 2 output as string.
.0189e3					_CPR_Number:
.0189e3	a9 00		lda #$00			lda 	#0 							; reset buffer index
.0189e5	8d 14 03	sta $0314			sta 	NumBufX
.0189e8	a5 85		lda $85				lda 	XS_Type 					; get type
.0189ea	4a		lsr a				lsr 	a
.0189eb	b0 05		bcs $0189f2			bcs 	_CPRInt 					; if msb set do as integer
.0189ed	20 20 9e	jsr $019e20			jsr 	FPToString 					; call fp to str otherwise
.0189f0	80 03		bra $0189f5			bra 	_CPRNPrint
.0189f2	20 e5 98	jsr $0198e5	_CPRInt:jsr 	IntToString
.0189f5					_CPRNPrint:
.0189f5	ad 15 03	lda $0315			lda 	Num_Buffer 					; is first character -
.0189f8	c9 2d		cmp #$2d			cmp 	#"-"
.0189fa	f0 05		beq $018a01			beq 	_CPRNoSpace
.0189fc	a9 20		lda #$20			lda 	#" "						; print the leading space
.0189fe	20 92 84	jsr $018492			jsr 	CharPrint 					; so beloved of MS Basics.
.018a01					_CPRNoSpace:
.018a01	a2 14		ldx #$14			ldx 	#(Num_Buffer-1) & $FF
.018a03	a9 03		lda #$03			lda 	#(Num_Buffer-1) >> 8
.018a05	80 04		bra $018a0b			bra 	_CPRPrint
.018a07					_CPR_String:
.018a07	a6 80		ldx $80				ldx 	XS_Mantissa
.018a09	a5 81		lda $81				lda 	XS_Mantissa+1
.018a0b					_CPRPrint:
.018a0b	86 1e		stx $1e				stx 	zGenPtr
.018a0d	85 1f		sta $1f				sta 	zGenPtr+1
.018a0f	5a		phy				phy
.018a10	a0 00		ldy #$00			ldy 	#0							; get length into X
.018a12	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018a14	aa		tax				tax
.018a15	f0 09		beq $018a20			beq 	_CPREndPrint 				; nothing to print
.018a17					_CPRLoop:
.018a17	c8		iny				iny
.018a18	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018a1a	20 92 84	jsr $018492			jsr 	CharPrint
.018a1d	ca		dex				dex
.018a1e	d0 f7		bne $018a17			bne 	_CPRLoop
.018a20					_CPREndPrint:
.018a20	7a		ply				ply
.018a21	80 a5		bra $0189c8			bra 	Command_Print
.018a23					_CPR_Tab:
.018a23	20 4f 80	jsr $01804f			jsr 	IFT_Tab
.018a26					_CPR_Skip:
.018a26	c8		iny				iny
.018a27	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018a29	c9 c0		cmp #$c0			cmp 	#token_Colon 				; colon or $00, exit
.018a2b	f0 09		beq $018a36			beq 	_CPR_Exit
.018a2d	c9 00		cmp #$00			cmp 	#0
.018a2f	d0 97		bne $0189c8			bne 	Command_PRINT 				; if not go round again.
.018a31	80 03		bra $018a36			bra 	_CPR_Exit
.018a33					_CPR_NewLine:
.018a33	20 5c 80	jsr $01805c			jsr 	IFT_NewLine
.018a36					_CPR_Exit:
.018a36	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/assert.asm

.018a37					Command_ASSERT:
.018a37	20 3a 8d	jsr $018d3a			jsr 	EvaluateInteger 			; calculate thing being asserted
.018a3a	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; check if true (non-zero)
.018a3c	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.018a3e	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.018a40	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.018a42	f0 01		beq $018a45			beq 	_ASFail
.018a44	60		rts				rts
.018a45					_ASFail:
.018a45	20 ca 84	jsr $0184ca			jsr ERR_Handler
>018a48	41 73 73 65 72 74 00			.text "Assert",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/poke.asm

.018a4f					Command_POKE:
.018a4f	a9 01		lda #$01			lda 	#1
.018a51	80 06		bra $018a59			bra 	CmdPoke_Main
.018a53					Command_DOKE:
.018a53	a9 02		lda #$02			lda 	#2
.018a55	80 02		bra $018a59			bra 	CmdPoke_Main
.018a57					Command_LOKE:
.018a57	a9 04		lda #$04			lda 	#4
.018a59					CmdPoke_Main:
.018a59	48		pha				pha
.018a5a	20 3a 8d	jsr $018d3a			jsr 	EvaluateInteger 			; get two parameters.
.018a5d	e8		inx				inx
.018a5e	e8		inx				inx
.018a5f	e8		inx				inx
.018a60	e8		inx				inx
.018a61	e8		inx				inx
.018a62	e8		inx				inx
.018a63	20 6a 93	jsr $01936a			jsr 	CheckNextComma
.018a66	20 3c 8d	jsr $018d3c			jsr 	EvaluateIntegerX
.018a69	a5 80		lda $80				lda 	XS_Mantissa+0 			; copy the mantissa into ZLTemp1 (address)
.018a6b	85 1a		sta $1a				sta 	zLTemp1
.018a6d	a5 81		lda $81				lda 	XS_Mantissa+1
.018a6f	85 1b		sta $1b				sta 	zLTemp1+1
.018a71	a5 82		lda $82				lda 	XS_Mantissa+2
.018a73	85 1c		sta $1c				sta 	zLTemp1+2
.018a75	a5 83		lda $83				lda 	XS_Mantissa+3
.018a77	85 1d		sta $1d				sta 	zLTemp1+3
.018a79	68		pla				pla 								; get count
.018a7a	5a		phy				phy 								; save Y
.018a7b	20 f5 92	jsr $0192f5			jsr 	MemWrite 					; write it out
.018a7e	7a		ply				ply 								; restore Y and done.
.018a7f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/newold.asm

.018a80					Command_NEW:
.018a80	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018a82	85 16		sta $16				sta 	zCodePtr+0
.018a84	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018a86	85 17		sta $17				sta 	zCodePtr+1
.018a88	a9 00		lda #$00			lda 	#0
.018a8a	85 18		sta $18				sta 	zCodePtr+2
.018a8c	85 19		sta $19				sta 	zCodePtr+3
.018a8e	a0 03		ldy #$03			ldy 	#3
.018a90	a0 00		ldy #$00			ldy 	#0
.018a92	a9 00		lda #$00			lda 	#0 							; write a 0 there.
.018a94	97 16		sta [$16],y			sta 	[zCodePtr],y
.018a96	20 06 93	jsr $019306			jsr 	UpdateProgramEnd 			; update program end.
.018a99	4c 72 87	jmp $018772			jmp 	WarmStart
.018a9c					Command_OLD:
.018a9c	ea		nop				nop
.018a9d	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018a9f	85 16		sta $16				sta 	zCodePtr+0
.018aa1	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018aa3	85 17		sta $17				sta 	zCodePtr+1
.018aa5	a9 00		lda #$00			lda 	#0
.018aa7	85 18		sta $18				sta 	zCodePtr+2
.018aa9	85 19		sta $19				sta 	zCodePtr+3
.018aab	a0 03		ldy #$03			ldy 	#3
.018aad					_COL_Find:
.018aad	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018aaf	c8		iny				iny
.018ab0	c9 00		cmp #$00			cmp 	#0 							; if zero, then the position Y/Z is new offset
.018ab2	f0 18		beq $018acc			beq 	_COL_Found
.018ab4	98		tya				tya
.018ab5	c9 00		cmp #$00			cmp 	#0
.018ab7	d0 f4		bne $018aad			bne 	_COL_Find 					; can't find old EOL, give up.
.018ab9	20 ca 84	jsr $0184ca			jsr ERR_Handler
>018abc	50 72 6f 67 72 61 6d 20			.text "Program Corrupt",0
>018ac4	43 6f 72 72 75 70 74 00
.018acc					_COL_Found:
.018acc	98		tya				tya
.018acd	48		pha				pha
.018ace	a0 00		ldy #$00			ldy 	#0
.018ad0	68		pla				pla
.018ad1	97 16		sta [$16],y			sta 	[zCodePtr],y
.018ad3	20 06 93	jsr $019306			jsr 	UpdateProgramEnd 			; reset variable pointer
.018ad6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/branch.asm

.018ad7					Command_GOTO:
.018ad7	20 f4 8a	jsr $018af4			jsr 	GotoGetLineNumber
.018ada	4c 11 8b	jmp $018b11			jmp 	GotoChangeToLineNumber
.018add					Command_GOSUB:
.018add	20 f4 8a	jsr $018af4			jsr 	GotoGetLineNumber
.018ae0	20 59 84	jsr $018459			jsr 	StackSavePosition
.018ae3	a9 05		lda #$05			lda 	#(SMark_Gosub << 4)+SourcePosSize
.018ae5	20 12 84	jsr $018412			jsr 	StackPushFrame
.018ae8	4c 11 8b	jmp $018b11			jmp 	GotoChangeToLineNumber
.018aeb					Command_RETURN:
.018aeb	a9 00		lda #$00			lda 	#(SMark_Gosub << 4)
.018aed	20 29 84	jsr $018429			jsr 	StackPopFrame
.018af0	20 76 84	jsr $018476			jsr 	StackRestorePosition
.018af3	60		rts				rts
.018af4					GotoGetLineNumber:
.018af4	20 3a 8d	jsr $018d3a			jsr 	EvaluateInteger
.018af7	a5 82		lda $82				lda 	XS_Mantissa+2 				; check range
.018af9	05 83		ora $83				ora 	XS_Mantissa+3
.018afb	d0 01		bne $018afe			bne 	_GLINError
.018afd	60		rts				rts
.018afe					_GLINError:
.018afe	20 ca 84	jsr $0184ca			jsr ERR_Handler
>018b01	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>018b09	20 4e 75 6d 62 65 72 00
.018b11					GotoChangeToLineNumber:
.018b11	a5 80		lda $80				lda 	XS_Mantissa+0 				; check line number not zero
.018b13	05 81		ora $81				ora 	XS_Mantissa+1
.018b15	f0 37		beq $018b4e			beq 	_GCTLFail
.018b17	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018b19	85 16		sta $16				sta 	zCodePtr+0
.018b1b	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018b1d	85 17		sta $17				sta 	zCodePtr+1
.018b1f	a9 00		lda #$00			lda 	#0
.018b21	85 18		sta $18				sta 	zCodePtr+2
.018b23	85 19		sta $19				sta 	zCodePtr+3
.018b25	a0 03		ldy #$03			ldy 	#3
.018b27					_GCTLLoop:
.018b27	a0 00		ldy #$00			ldy 	#0
.018b29	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018b2b	c9 00		cmp #$00			cmp 	#0
.018b2d	f0 1f		beq $018b4e			beq 	_GCTLFail
.018b2f	c8		iny				iny
.018b30	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018b32	c5 80		cmp $80				cmp 	XS_Mantissa+0
.018b34	d0 07		bne $018b3d			bne 	_GCTLNext
.018b36	c8		iny				iny
.018b37	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018b39	c5 81		cmp $81				cmp 	XS_Mantissa+1
.018b3b	f0 0f		beq $018b4c			beq 	_GCTLExit
.018b3d					_GCTLNext:
.018b3d	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018b3f	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.018b41	18		clc				clc
.018b42	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018b44	85 16		sta $16				sta 	zCodePtr
.018b46	90 02		bcc $018b4a			bcc 	_SNLNoCarry
.018b48	e6 17		inc $17				inc 	zCodePtr+1
.018b4a					_SNLNoCarry:
.018b4a	80 db		bra $018b27			bra 	_GCTLLoop 					; try next line.
.018b4c					_GCTLExit:
.018b4c	c8		iny				iny
.018b4d	60		rts				rts
.018b4e					_GCTLFail:
.018b4e	20 ca 84	jsr $0184ca			jsr ERR_Handler
>018b51	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>018b59	20 4e 75 6d 62 65 72 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.018b61					Command_CLR:
.018b61					ResetRunStatus:
.018b61	20 3f 94	jsr $01943f			jsr 	VariableClear
.018b64	20 00 84	jsr $018400			jsr 	StackReset
.018b67	a9 00		lda #$00			lda 	#HighMemory & $FF
.018b69	8d 00 03	sta $0300			sta 	StringPtr
.018b6c	a9 7f		lda #$7f			lda 	#HighMemory >> 8
.018b6e	8d 01 03	sta $0301			sta 	StringPtr+1
.018b71	20 09 96	jsr $019609			jsr 	ArrayResetDefault
.018b74	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/stop.asm

.018b75					Command_STOP:
.018b75	20 ca 84	jsr $0184ca			jsr ERR_Handler
>018b78	53 74 6f 70 00				.text "Stop",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/repeat.asm

.018b7d					Command_REPEAT:
.018b7d	20 59 84	jsr $018459			jsr 	StackSavePosition			; save position into stack
.018b80	a9 15		lda #$15			lda 	#(SMark_Repeat << 4)+SourcePosSize
.018b82	20 12 84	jsr $018412			jsr 	StackPushFrame 				; push on stack
.018b85	60		rts				rts
.018b86					Command_UNTIL:
.018b86	a9 10		lda #$10			lda 	#(SMark_Repeat << 4)		; remove the frame
.018b88	20 29 84	jsr $018429			jsr 	StackPopFrame
.018b8b	20 3a 8d	jsr $018d3a			jsr 	EvaluateInteger				; work out UNTIL
.018b8e	a5 80		lda $80				lda 	XS_Mantissa+0 				; check if zero.
.018b90	05 81		ora $81				ora 	XS_Mantissa+1
.018b92	05 82		ora $82				ora 	XS_Mantissa+2
.018b94	05 83		ora $83				ora 	XS_Mantissa+3
.018b96	d0 08		bne $018ba0			bne 	_CUTExit 					; if not, just exit
.018b98	20 76 84	jsr $018476			jsr 	StackRestorePosition 		; otherwise loop round again.
.018b9b	a9 15		lda #$15			lda 	#(SMark_Repeat << 4)+SourcePosSize
.018b9d	20 12 84	jsr $018412			jsr 	StackPushFrame 				; fix the stack back.
.018ba0					_CUTExit:
.018ba0	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.018ba1					EVESyntax:
.018ba1	4c 9b 84	jmp $01849b			jmp 	SyntaxError
.018ba4					EvaluateExpression:
.018ba4	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.018ba6					EvaluateExpressionX:
.018ba6	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.018ba8					EvaluateExpressionXA:
.018ba8	48		pha				pha 								; save precedence on stack.
.018ba9	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018bab	f0 f4		beq $018ba1			beq 	EVESyntax 					; end of line, syntax error.
.018bad	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.018baf	b0 03		bcs $018bb4			bcs 	_EVNotVariable
.018bb1	4c 7e 8c	jmp $018c7e			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.018bb4					_EVNotVariable:
.018bb4	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.018bb6	90 e9		bcc $018ba1			bcc 	EVESyntax
.018bb8	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.018bba	b0 58		bcs $018c14			bcs 	_EVNotInteger
.018bbc	20 ac 8c	jsr $018cac			jsr 	EvaluateGetInteger
.018bbf					_EVCheckDecimal:
.018bbf	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018bc1	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.018bc3	d0 05		bne $018bca			bne 	_EVGotAtom 					; no, get atom.
.018bc5					_EVIsDecimal:
.018bc5	20 d2 8c	jsr $018cd2			jsr 	EVGetDecimal 				; extend to the decimal part.
.018bc8	80 00		bra $018bca			bra 	_EVGotAtom 					; and continue to got atom.
.018bca					_EVGotAtom:
.018bca	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018bcc	10 44		bpl $018c12			bpl 	_EVExitDrop 				; must be a token.
.018bce	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.018bd0	b0 40		bcs $018c12			bcs 	_EVExitDrop
.018bd2	68		pla				pla 								; get current precedence
.018bd3	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.018bd5	da		phx				phx 								; save X
.018bd6	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018bd8	aa		tax				tax 								; put in X
.018bd9	bf 7d 85 01	lda $01857d,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.018bdd	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.018bdf	fa		plx				plx 								; restore X
.018be0	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.018be2	90 2f		bcc $018c13			bcc 	_EVExit 					; exit if too low.
.018be4	f0 2d		beq $018c13			beq 	_EVExit 					; exit if equals
.018be6	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.018be8	48		pha				pha
.018be9	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018beb	48		pha				pha
.018bec	c8		iny				iny
.018bed	da		phx				phx 								; save current position
.018bee	e8		inx				inx
.018bef	e8		inx				inx
.018bf0	e8		inx				inx
.018bf1	e8		inx				inx
.018bf2	e8		inx				inx
.018bf3	e8		inx				inx
.018bf4	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.018bf6	20 a8 8b	jsr $018ba8			jsr 	EvaluateExpressionXA 		; do the RHS.
.018bf9	fa		plx				plx 								; restore X
.018bfa	68		pla				pla 								; get the binary operator in A.
.018bfb					_EVCallA:
.018bfb	da		phx				phx 								; save X again
.018bfc	0a		asl a				asl 	a 							; double, lose the MSB.
.018bfd	aa		tax				tax									; put in X
.018bfe	bf 2e 85 01	lda $01852e,x			lda 	VectorTable,x 				; copy address into zGenPtr
.018c02	8d 11 03	sta $0311			sta 	LocalVector+1
.018c05	bf 2f 85 01	lda $01852f,x			lda 	VectorTable+1,x
.018c09	8d 12 03	sta $0312			sta 	LocalVector+2
.018c0c	fa		plx				plx 								; restore X
.018c0d	20 87 8c	jsr $018c87			jsr 	EVCallLocalVector
.018c10	80 b8		bra $018bca			bra 	_EVGotAtom 					; and loop back.
.018c12					_EVExitDrop:
.018c12	68		pla				pla
.018c13					_EVExit:
.018c13	60		rts				rts
.018c14					_EVNotInteger:
.018c14	c8		iny				iny
.018c15	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.018c17	d0 16		bne $018c2f			bne 	_EVNotMinus
.018c19	20 1b 8d	jsr $018d1b			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.018c1c	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.018c1e	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.018c20	f0 05		beq $018c27			beq 	_EVMinusFloat
.018c22	20 c8 98	jsr $0198c8			jsr 	IntegerNegateAlways 		; negation
.018c25	80 a3		bra $018bca			bra 	_EVGotAtom 					; and go back.
.018c27					_EVMinusFloat:
.018c27	b5 85		lda $85,x			lda 	XS_Type,x 					; invert the sign bit.
.018c29	49 80		eor #$80			eor 	#$80
.018c2b	95 85		sta $85,x			sta 	XS_Type,x
.018c2d	80 9b		bra $018bca			bra 	_EVGotAtom
.018c2f					_EVNotMinus:
.018c2f	c9 bd		cmp #$bd			cmp 	#token_lparen 				; is it left parenthesis
.018c31	d0 17		bne $018c4a			bne 	_EVNotParenthesis
.018c33	20 a6 8b	jsr $018ba6			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.018c36	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c38	c8		iny				iny
.018c39	c9 be		cmp #$be			cmp 	#token_rparen 				; okay if right bracket.
.018c3b	f0 8d		beq $018bca			beq 	_EVGotAtom
.018c3d	20 ca 84	jsr $0184ca			jsr ERR_Handler
>018c40	4d 69 73 73 69 6e 67 20			.text "Missing )",0
>018c48	29 00
.018c4a					_EVNotParenthesis:
.018c4a	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.018c4c	d0 0c		bne $018c5a			bne 	_EVNotNot
.018c4e	20 1b 8d	jsr $018d1b			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.018c51	20 21 9d	jsr $019d21			jsr 	FPUToInteger 				; make it an integer - if possible.
.018c54	20 00 8d	jsr $018d00			jsr 	NotInteger 					; do the not calculation
.018c57	4c ca 8b	jmp $018bca			jmp 	_EVGotAtom
.018c5a					_EVNotNot:
.018c5a	c9 fe		cmp #$fe			cmp 	#$FE
.018c5c	d0 12		bne $018c70			bne 	_EVNotString
.018c5e	20 dd 93	jsr $0193dd			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.018c61	a5 20		lda $20				lda 	zTempStr 					; copy address of string into mantissa
.018c63	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018c65	a5 21		lda $21				lda 	zTempStr+1
.018c67	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018c69	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.018c6b	95 85		sta $85,x			sta 	XS_Type,x
.018c6d	4c ca 8b	jmp $018bca			jmp 	_EVGotAtom
.018c70					_EVNotString:
.018c70	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.018c72	90 04		bcc $018c78			bcc 	_EVBadElement
.018c74	c9 b7		cmp #$b7			cmp 	#lastUnaryFunction+1
.018c76	90 03		bcc $018c7b			bcc 	_EVUnaryFunction
.018c78					_EVBadElement:
.018c78	4c 9b 84	jmp $01849b			jmp 	SyntaxError
.018c7b					_EVUnaryFunction:
.018c7b	4c fb 8b	jmp $018bfb			jmp 	_EVCallA
.018c7e					_EVVariableHandler:
.018c7e	20 03 94	jsr $019403			jsr 	VariableFind 				; locate a variable
.018c81	20 4b 97	jsr $01974b			jsr 	VariableGet 				; copy into memory.
.018c84	4c ca 8b	jmp $018bca			jmp 	_EVGotAtom 					; and go round.
.018c87					EVCallLocalVector:
.018c87	6c 11 03	jmp ($0311)			jmp 	(LocalVector+1)
.018c8a					EVShiftMantissaLeft6:
.018c8a	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.018c8c	95 84		sta $84,x			sta 	XS_Exponent,x
.018c8e	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.018c90	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018c92	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.018c94	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.018c96	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.018c98	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018c9a	a9 00		lda #$00			lda 	#0
.018c9c	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018c9e	20 a1 8c	jsr $018ca1			jsr 	_EVSMLShift 					; call it here to do it twice
.018ca1					_EVSMLShift:
.018ca1	56 84		lsr $84,x			lsr 	XS_Exponent,x
.018ca3	76 83		ror $83,x			ror 	XS_Mantissa+3,x
.018ca5	76 82		ror $82,x			ror 	XS_Mantissa+2,x
.018ca7	76 81		ror $81,x			ror 	XS_Mantissa+1,x
.018ca9	76 80		ror $80,x			ror 	XS_Mantissa+0,x
.018cab	60		rts				rts
.018cac					EvaluateGetInteger:
.018cac	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018cae	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.018cb0	95 80		sta $80,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.018cb2	a9 00		lda #$00			lda 	#0
.018cb4	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018cb6	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.018cb8	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018cba	1a		inc a				inc 	a 							; set to type 1 (integer)
.018cbb	95 85		sta $85,x			sta 	XS_Type,x
.018cbd					_EVCheckNextInteger:
.018cbd	c8		iny				iny
.018cbe	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018cc0	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.018cc2	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.018cc4	b0 0b		bcs $018cd1			bcs 	_EVEndInteger
.018cc6	48		pha				pha 								; save it.
.018cc7	20 8a 8c	jsr $018c8a			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.018cca	68		pla				pla
.018ccb	15 80		ora $80,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.018ccd	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018ccf	80 ec		bra $018cbd			bra 	_EVCheckNextInteger
.018cd1					_EVEndInteger:
.018cd1	60		rts				rts
.018cd2					EVGetDecimal:
.018cd2	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.018cd4	8d 15 03	sta $0315			sta 	Num_Buffer
.018cd7	da		phx				phx
.018cd8	c8		iny				iny
.018cd9	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018cdb	c8		iny				iny
.018cdc	3a		dec a				dec 	a								; convert to a string length.
.018cdd	3a		dec a				dec 	a
.018cde	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.018ce0					_EVGDCopy:
.018ce0	48		pha				pha 									; save count
.018ce1	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018ce3	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.018ce6	e8		inx				inx 									; forward ....
.018ce7	c8		iny				iny
.018ce8	68		pla				pla 									; get count
.018ce9	3a		dec a				dec 	a 								; until zero
.018cea	d0 f4		bne $018ce0			bne 	_EVGDCopy
.018cec	9d 15 03	sta $0315,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.018cef	fa		plx				plx 									; restore X
.018cf0	a9 15		lda #$15			lda 	#Num_Buffer & $FF 				; set zGenPtr
.018cf2	85 1e		sta $1e				sta 	zGenPtr
.018cf4	a9 03		lda #$03			lda 	#Num_Buffer >> 8
.018cf6	85 1f		sta $1f				sta 	zGenPtr+1
.018cf8	5a		phy				phy 									; save Y
.018cf9	a0 00		ldy #$00			ldy 	#0 								; start position
.018cfb	20 db 9e	jsr $019edb			jsr 	FPFromString 					; convert current
.018cfe	7a		ply				ply 									; restore Y
.018cff	60		rts				rts
.018d00					NotInteger:
.018d00	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.018d02	49 ff		eor #$ff			eor 	#$FF
.018d04	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018d06	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.018d08	49 ff		eor #$ff			eor 	#$FF
.018d0a	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018d0c	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.018d0e	49 ff		eor #$ff			eor 	#$FF
.018d10	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.018d12	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.018d14	49 ff		eor #$ff			eor 	#$FF
.018d16	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018d18	60		rts				rts
.018d19					EvaluateGetAtom:
.018d19	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.018d1b					EvaluateGetAtomX:
.018d1b	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.018d1d	20 a8 8b	jsr $018ba8			jsr 	EvaluateExpressionXA
.018d20	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.018d22	29 0f		and #$0f			and 	#15
.018d24	c9 02		cmp #$02			cmp 	#2
.018d26	b0 01		bcs $018d29			bcs 	EvaluateType
.018d28	60		rts				rts
.018d29					EvaluateType:
.018d29	4c ab 84	jmp $0184ab			jmp 	TypeError
.018d2c					EvaluateNumber:
.018d2c	a2 00		ldx #$00			ldx 	#0
.018d2e					EvaluateNumberX:
.018d2e	20 a6 8b	jsr $018ba6			jsr 	EvaluateExpressionX
.018d31	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0/1
.018d33	29 0f		and #$0f			and 	#15
.018d35	c9 02		cmp #$02			cmp 	#2
.018d37	b0 f0		bcs $018d29			bcs 	EvaluateType
.018d39	60		rts				rts
.018d3a					EvaluateInteger:
.018d3a	a2 00		ldx #$00			ldx 	#0
.018d3c					EvaluateIntegerX:
.018d3c	20 2e 8d	jsr $018d2e			jsr 	EvaluateNumberX
.018d3f	20 21 9d	jsr $019d21			jsr 	FPUToInteger
.018d42	60		rts				rts
.018d43					EvaluateString:
.018d43	a2 00		ldx #$00			ldx 	#0
.018d45					EvaluateStringX:
.018d45	20 a6 8b	jsr $018ba6			jsr 	EvaluateExpressionX
.018d48	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 2
.018d4a	29 0f		and #$0f			and 	#15
.018d4c	c9 02		cmp #$02			cmp 	#2
.018d4e	d0 d9		bne $018d29			bne 	EvaluateType
.018d50	b5 80		lda $80,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.018d52	85 1e		sta $1e				sta 	zGenPtr
.018d54	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.018d56	85 1f		sta $1f				sta 	zGenPtr+1
.018d58	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.018d59					BinaryOp_And:
.018d59	20 ad 8d	jsr $018dad			jsr 	BinaryMakeBothInteger
.018d5c	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.018d5e	35 86		and $86,x			and 	XS2_Mantissa+0,x
.018d60	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018d62	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.018d64	35 87		and $87,x			and 	XS2_Mantissa+1,x
.018d66	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018d68	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.018d6a	35 88		and $88,x			and 	XS2_Mantissa+2,x
.018d6c	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.018d6e	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.018d70	35 89		and $89,x			and 	XS2_Mantissa+3,x
.018d72	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018d74	60		rts				rts
.018d75					BinaryOp_Or:
.018d75	20 ad 8d	jsr $018dad			jsr 	BinaryMakeBothInteger
.018d78	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.018d7a	15 86		ora $86,x			ora 	XS2_Mantissa+0,x
.018d7c	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018d7e	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.018d80	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.018d82	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018d84	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.018d86	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.018d88	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.018d8a	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.018d8c	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.018d8e	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018d90	60		rts				rts
.018d91					BinaryOp_Eor:
.018d91					BinaryOp_Xor:
.018d91	20 ad 8d	jsr $018dad			jsr 	BinaryMakeBothInteger
.018d94	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.018d96	55 86		eor $86,x			eor 	XS2_Mantissa+0,x
.018d98	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018d9a	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.018d9c	55 87		eor $87,x			eor 	XS2_Mantissa+1,x
.018d9e	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018da0	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.018da2	55 88		eor $88,x			eor 	XS2_Mantissa+2,x
.018da4	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.018da6	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.018da8	55 89		eor $89,x			eor 	XS2_Mantissa+3,x
.018daa	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018dac	60		rts				rts
.018dad					BinaryMakeBothInteger:
.018dad	da		phx				phx 								; save X
.018dae	e8		inx				inx
.018daf	e8		inx				inx
.018db0	e8		inx				inx
.018db1	e8		inx				inx
.018db2	e8		inx				inx
.018db3	e8		inx				inx
.018db4	20 b8 8d	jsr $018db8			jsr 	BinaryMakeInteger 			; convert to integer.
.018db7	fa		plx				plx 								; restore X and fall through.
.018db8					BinaryMakeInteger:
.018db8	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.018dba	29 0f		and #$0f			and 	#15 						; check type zero
.018dbc	f0 04		beq $018dc2			beq 	_BMIConvert 				; if float convert to integer.
.018dbe	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.018dbf	90 04		bcc $018dc5			bcc 	_BMIError
.018dc1	60		rts				rts
.018dc2					_BMIConvert:
.018dc2	4c 21 9d	jmp $019d21			jmp 	FPUToInteger 				; convert to integer
.018dc5					_BMIError:
.018dc5	4c ab 84	jmp $0184ab			jmp 	TypeError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.018dc8					Binary_Equal:
.018dc8	20 0f 8e	jsr $018e0f			jsr 	CompareValues
.018dcb	09 00		ora #$00			ora 	#0
.018dcd	f0 04		beq $018dd3			beq 	CCTrue
.018dcf	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.018dd1	80 02		bra $018dd5			bra 	CCWrite
.018dd3	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.018dd5	95 80		sta $80,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.018dd7	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018dd9	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.018ddb	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018ddd	a9 01		lda #$01			lda 	#1
.018ddf	95 85		sta $85,x			sta 	XS_Type,x 					; set type to integer whatever.
.018de1	60		rts				rts
.018de2					Binary_NotEqual:
.018de2	20 0f 8e	jsr $018e0f			jsr 	CompareValues
.018de5	09 00		ora #$00			ora 	#0
.018de7	f0 e6		beq $018dcf			beq 	CCFalse
.018de9	80 e8		bra $018dd3			bra 	CCTrue
.018deb					Binary_Less:
.018deb	20 0f 8e	jsr $018e0f			jsr 	CompareValues
.018dee	09 00		ora #$00			ora 	#0
.018df0	30 e1		bmi $018dd3			bmi 	CCTrue
.018df2	80 db		bra $018dcf			bra 	CCFalse
.018df4					Binary_LessEqual:
.018df4	20 0f 8e	jsr $018e0f			jsr 	CompareValues
.018df7	c9 01		cmp #$01			cmp 	#1
.018df9	d0 d8		bne $018dd3			bne 	CCTrue
.018dfb	80 d2		bra $018dcf			bra 	CCFalse
.018dfd					Binary_GreaterEqual:
.018dfd	20 0f 8e	jsr $018e0f			jsr 	CompareValues
.018e00	09 00		ora #$00			ora 	#0
.018e02	10 cf		bpl $018dd3			bpl 	CCTrue
.018e04	80 c9		bra $018dcf			bra 	CCFalse
.018e06					Binary_Greater:
.018e06	20 0f 8e	jsr $018e0f			jsr 	CompareValues
.018e09	c9 01		cmp #$01			cmp 	#1
.018e0b	f0 c6		beq $018dd3			beq 	CCTrue
.018e0d	80 c0		bra $018dcf			bra 	CCFalse
.018e0f					CompareValues:
.018e0f	b5 85		lda $85,x			lda 	XS_Type,x 					; and the types together
.018e11	35 8b		and $8b,x			and 	XS2_Type,x
.018e13	c9 02		cmp #$02			cmp 	#2
.018e15	f0 11		beq $018e28			beq 	_CVString
.018e17	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018e19	35 8b		and $8b,x			and 	XS2_Type,x
.018e1b	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018e1c	90 03		bcc $018e21			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018e1e	4c 6a 8e	jmp $018e6a			jmp 	CompareInteger32 							; so execute code at \1
.018e21					_BCFloat:
.018e21	20 0e 8f	jsr $018f0e			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018e24	4c 57 9c	jmp $019c57			jmp 	FPCompare 							; and execute code at \2
.018e27	60		rts				rts
.018e28					_CVString:
.018e28	da		phx				phx 								; save XY
.018e29	5a		phy				phy
.018e2a	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.018e2c	85 1a		sta $1a				sta		zLTemp1+0
.018e2e	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.018e30	85 1b		sta $1b				sta 	zLTemp1+1
.018e32	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.018e34	85 1c		sta $1c				sta 	zLTemp1+2
.018e36	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.018e38	85 1d		sta $1d				sta 	zLTemp1+3
.018e3a	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.018e3c	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.018e3e	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.018e40	90 02		bcc $018e44			bcc 	_CVCommon
.018e42	b1 1c		lda ($1c),y			lda 	(zLTemp1+2),y
.018e44					_CVCommon:
.018e44	aa		tax				tax 								; put shorter string length in zero.
.018e45	f0 0c		beq $018e53			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.018e47					_CVCompare:
.018e47	c8		iny				iny 								; next character
.018e48	b1 1a		lda ($1a),y			lda 	(zLTemp1),y 				; compare characters
.018e4a	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.018e4c	90 13		bcc $018e61			bcc 	_CVReturnLess 				; <
.018e4e	d0 15		bne $018e65			bne 	_CVReturnGreater 			; >
.018e50	ca		dex				dex 								; until common length matched.
.018e51	d0 f4		bne $018e47			bne 	_CVCompare
.018e53					_CVMatch:
.018e53	a0 00		ldy #$00			ldy 	#0
.018e55	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.018e57	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.018e59	90 06		bcc $018e61			bcc 	_CVReturnLess 				; <
.018e5b	d0 08		bne $018e65			bne 	_CVReturnGreater 			; >
.018e5d	a9 00		lda #$00			lda 	#0
.018e5f	80 06		bra $018e67			bra 	_CVExit 					; same common, same length, same string
.018e61					_CVReturnLess:
.018e61	a9 ff		lda #$ff			lda 	#$FF
.018e63	80 02		bra $018e67			bra 	_CVExit
.018e65					_CVReturnGreater:
.018e65	a9 01		lda #$01			lda 	#$01
.018e67					_CVExit:
.018e67	7a		ply				ply
.018e68	fa		plx				plx
.018e69	60		rts				rts
.018e6a					CompareInteger32:
.018e6a	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.018e6c	49 80		eor #$80			eor 	#$80
.018e6e	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018e70	b5 89		lda $89,x			lda 	XS2_Mantissa+3,x
.018e72	49 80		eor #$80			eor 	#$80
.018e74	95 89		sta $89,x			sta 	XS2_Mantissa+3,x
.018e76	20 f4 8e	jsr $018ef4			jsr 	SubInteger32 				; subtraction
.018e79	90 0d		bcc $018e88			bcc 	_CI32Less 					; cc return -1
.018e7b	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check if zero
.018e7d	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.018e7f	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.018e81	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.018e83	f0 02		beq $018e87			beq 	_CI32Exit
.018e85	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.018e87					_CI32Exit:
.018e87	60		rts				rts
.018e88					_CI32Less:
.018e88	a9 ff		lda #$ff			lda 	#$FF
.018e8a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.018e8b					BinaryOp_Add:
.018e8b	b5 85		lda $85,x			lda 	XS_Type,x  					; and types together
.018e8d	35 8b		and $8b,x			and 	XS2_Type,x
.018e8f	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.018e91	d0 11		bne $018ea4			bne 	_BOAString
.018e93	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018e95	35 8b		and $8b,x			and 	XS2_Type,x
.018e97	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018e98	90 03		bcc $018e9d			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018e9a	4c da 8e	jmp $018eda			jmp 	AddInteger32 							; so execute code at \1
.018e9d					_BCFloat:
.018e9d	20 0e 8f	jsr $018f0e			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018ea0	4c 32 9a	jmp $019a32			jmp 	FPAdd 							; and execute code at \2
.018ea3	60		rts				rts
.018ea4					_BOAString:
.018ea4	4c 28 8f	jmp $018f28			jmp 	ConcatenateString 			; concatenate two strings.
.018ea7					BinaryOp_Subtract:
.018ea7	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018ea9	35 8b		and $8b,x			and 	XS2_Type,x
.018eab	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018eac	90 03		bcc $018eb1			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018eae	4c f4 8e	jmp $018ef4			jmp 	SubInteger32 							; so execute code at \1
.018eb1					_BCFloat:
.018eb1	20 0e 8f	jsr $018f0e			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018eb4	4c 2a 9a	jmp $019a2a			jmp 	FPSubtract 							; and execute code at \2
.018eb7	60		rts				rts
.018eb8					BinaryOp_Multiply:
.018eb8	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018eba	35 8b		and $8b,x			and 	XS2_Type,x
.018ebc	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018ebd	90 03		bcc $018ec2			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018ebf	4c 03 98	jmp $019803			jmp 	MulInteger32 							; so execute code at \1
.018ec2					_BCFloat:
.018ec2	20 0e 8f	jsr $018f0e			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018ec5	4c 59 9b	jmp $019b59			jmp 	FPMultiply 							; and execute code at \2
.018ec8	60		rts				rts
.018ec9					BinaryOp_Divide:
.018ec9	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018ecb	35 8b		and $8b,x			and 	XS2_Type,x
.018ecd	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018ece	90 03		bcc $018ed3			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018ed0	4c 41 98	jmp $019841			jmp 	DivInteger32 							; so execute code at \1
.018ed3					_BCFloat:
.018ed3	20 0e 8f	jsr $018f0e			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018ed6	4c e6 9a	jmp $019ae6			jmp 	FPDivide 							; and execute code at \2
.018ed9	60		rts				rts
.018eda					AddInteger32:
.018eda	18		clc				clc
.018edb	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.018edd	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.018edf	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018ee1	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.018ee3	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.018ee5	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018ee7	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.018ee9	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.018eeb	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.018eed	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.018eef	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.018ef1	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018ef3	60		rts				rts
.018ef4					SubInteger32:
.018ef4	38		sec				sec
.018ef5	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.018ef7	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.018ef9	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018efb	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.018efd	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.018eff	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018f01	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.018f03	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.018f05	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.018f07	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.018f09	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.018f0b	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018f0d	60		rts				rts
.018f0e					BinaryMakeBothFloat:
.018f0e	da		phx				phx 								; save X
.018f0f	e8		inx				inx
.018f10	e8		inx				inx
.018f11	e8		inx				inx
.018f12	e8		inx				inx
.018f13	e8		inx				inx
.018f14	e8		inx				inx
.018f15	20 19 8f	jsr $018f19			jsr 	BinaryMakeFloat 			; convert to float.
.018f18	fa		plx				plx 								; restore X and fall through.
.018f19					BinaryMakeFloat:
.018f19	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.018f1b	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.018f1c	b0 04		bcs $018f22			bcs 	_BMFConvert
.018f1e	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.018f1f	b0 04		bcs $018f25			bcs 	_BMFError
.018f21	60		rts				rts
.018f22					_BMFConvert:
.018f22	4c d5 9c	jmp $019cd5			jmp 	FPUToFloat 					; convert to float
.018f25					_BMFError:
.018f25	4c ab 84	jmp $0184ab			jmp 	TypeError
.018f28					ConcatenateString:
.018f28	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.018f2a	85 1a		sta $1a				sta		zLTemp1+0
.018f2c	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.018f2e	85 1b		sta $1b				sta 	zLTemp1+1
.018f30	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.018f32	85 1c		sta $1c				sta 	zLTemp1+2
.018f34	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.018f36	85 1d		sta $1d				sta 	zLTemp1+3
.018f38	5a		phy				phy
.018f39	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.018f3b	b1 1a		lda ($1a),y			lda 	(zlTemp1),y
.018f3d	71 1c		adc ($1c),y			adc 	(zlTemp1+2),y
.018f3f	7a		ply				ply
.018f40	b0 33		bcs $018f75			bcs 	_CSError					; check in range.
.018f42	c9 fe		cmp #$fe			cmp 	#maxString+1
.018f44	b0 2f		bcs $018f75			bcs 	_CSError
.018f46	20 a2 93	jsr $0193a2			jsr 	AllocateTempString 			; store the result
.018f49	20 60 8f	jsr $018f60			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.018f4c	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.018f4e	85 1a		sta $1a				sta 	zLTemp1
.018f50	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.018f52	85 1b		sta $1b				sta 	zLTemp1+1
.018f54	20 60 8f	jsr $018f60			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.018f57	a5 20		lda $20				lda 	zTempStr 					; point current to new string
.018f59	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018f5b	a5 21		lda $21				lda 	zTempStr+1
.018f5d	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018f5f	60		rts				rts
.018f60					_CSCopyString:
.018f60	da		phx				phx
.018f61	5a		phy				phy
.018f62	a0 00		ldy #$00			ldy 	#0 							; get length
.018f64	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.018f66	f0 0a		beq $018f72			beq 	_CSCSExit 					; if zero, exit
.018f68	aa		tax				tax 								; put in X
.018f69					_CSCSLoop:
.018f69	c8		iny				iny 								; get next char
.018f6a	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.018f6c	20 cd 93	jsr $0193cd			jsr		WriteTempString 			; copy out
.018f6f	ca		dex				dex 								; do whole string
.018f70	d0 f7		bne $018f69			bne 	_CSCSLoop
.018f72					_CSCSExit:
.018f72	7a		ply				ply
.018f73	fa		plx				plx
.018f74	60		rts				rts
.018f75					_CSError:
.018f75	20 ca 84	jsr $0184ca			jsr ERR_Handler
>018f78	53 74 72 69 6e 67 20 74			.text "String too long",0
>018f80	6f 6f 20 6c 6f 6e 67 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.018f88					Unary_Sgn:
.018f88	20 2e 8d	jsr $018d2e			jsr 	EvaluateNumberX 			; get value
.018f8b	20 62 93	jsr $019362			jsr 	CheckNextRParen 			; check right bracket.
.018f8e	20 ac 8f	jsr $018fac			jsr 	GetSignCurrent 				; get sign.
.018f91	09 00		ora #$00			ora 	#0
.018f93	10 08		bpl $018f9d			bpl		UnarySetAInteger			; if 0,1 return that.
.018f95	80 00		bra $018f97			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.018f97					UnarySetAMinus1:
.018f97	a9 ff		lda #$ff			lda 	#$FF
.018f99	95 80		sta $80,x			sta 	XS_Mantissa,x
.018f9b	80 04		bra $018fa1			bra 	UnarySetAFill
.018f9d					UnarySetAInteger:
.018f9d	95 80		sta $80,x			sta 	XS_Mantissa,x
.018f9f	a9 00		lda #$00			lda 	#0
.018fa1					UnarySetAFill:
.018fa1	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018fa3	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.018fa5	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018fa7	a9 01		lda #$01			lda 	#1
.018fa9	95 85		sta $85,x			sta 	XS_Type,x
.018fab	60		rts				rts
.018fac					GetSignCurrent:
.018fac	b5 85		lda $85,x			lda 	XS_Type,x 					; identify type.
.018fae	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.018faf	90 15		bcc $018fc6			bcc 	_GSCFloat
.018fb1	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.018fb3	30 0e		bmi $018fc3			bmi 	_GSCMinus1
.018fb5	15 80		ora $80,x			ora 	XS_Mantissa+0,x
.018fb7	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.018fb9	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.018fbb	d0 03		bne $018fc0			bne 	_GSCPlus1
.018fbd					_GSCZero:
.018fbd	a9 00		lda #$00			lda 	#0
.018fbf	60		rts				rts
.018fc0					_GSCPlus1:
.018fc0	a9 01		lda #$01			lda 	#$01
.018fc2	60		rts				rts
.018fc3					_GSCMinus1:
.018fc3	a9 ff		lda #$ff			lda 	#$FF
.018fc5	60		rts				rts
.018fc6					_GSCFloat:
.018fc6	34 85		bit $85,x			bit 	XS_Type,x
.018fc8	70 f3		bvs $018fbd			bvs 	_GSCZero
.018fca	30 f7		bmi $018fc3			bmi 	_GSCMinus1
.018fcc	80 f2		bra $018fc0			bra 	_GSCPlus1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.018fce					Unary_Abs:
.018fce	20 2e 8d	jsr $018d2e			jsr 	EvaluateNumberX 			; get value
.018fd1	20 62 93	jsr $019362			jsr 	CheckNextRParen 			; check right bracket.
.018fd4	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.018fd6	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.018fd8	f0 07		beq $018fe1			beq 	_UAMinusFloat
.018fda	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; check MSB
.018fdc	10 09		bpl $018fe7			bpl 	_UAExit
.018fde	4c c8 98	jmp $0198c8			jmp 	IntegerNegateAlways 		; negation
.018fe1					_UAMinusFloat:
.018fe1	b5 85		lda $85,x			lda 	XS_Type,x 					; clear the sign bit.
.018fe3	29 7f		and #$7f			and		#$7F
.018fe5	95 85		sta $85,x			sta 	XS_Type,x
.018fe7					_UAExit:
.018fe7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.018fe8					Unary_Peek:
.018fe8	a9 01		lda #$01			lda 	#1
.018fea	80 06		bra $018ff2			bra 	UPMain
.018fec					Unary_Deek:
.018fec	a9 02		lda #$02			lda 	#2
.018fee	80 02		bra $018ff2			bra 	UPMain
.018ff0					Unary_Leek:
.018ff0	a9 04		lda #$04			lda 	#4
.018ff2					UPMain:
.018ff2	48		pha				pha 								; set bytes to copy.
.018ff3	20 3c 8d	jsr $018d3c			jsr 	EvaluateIntegerX 			; numeric parameter
.018ff6	20 62 93	jsr $019362			jsr 	CheckNextRParen 			; right bracket.
.018ff9	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.018ffb	85 1a		sta $1a				sta 	zLTemp1
.018ffd	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.018fff	85 1b		sta $1b				sta 	zLTemp1+1
.019001	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019003	85 1c		sta $1c				sta 	zLTemp1+2
.019005	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019007	85 1d		sta $1d				sta 	zLTemp1+3
.019009	a9 00		lda #$00			lda 	#0 							; clear target area
.01900b	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01900d	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01900f	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019011	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019013	68		pla				pla 								; restore bytes to copy
.019014	da		phx				phx 								; save XY
.019015	5a		phy				phy
.019016	20 e4 92	jsr $0192e4			jsr 	MemRead 					; read the bytes in
.019019	7a		ply				ply 								; restore and exit
.01901a	fa		plx				plx
.01901b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.01901c					Unary_Mod:
.01901c	20 44 90	jsr $019044			jsr 	_UMParameter 				; first parameter
.01901f	20 6a 93	jsr $01936a			jsr 	CheckNextComma
.019022	da		phx				phx 								; second parameter
.019023	e8		inx				inx
.019024	e8		inx				inx
.019025	e8		inx				inx
.019026	e8		inx				inx
.019027	e8		inx				inx
.019028	e8		inx				inx
.019029	20 44 90	jsr $019044			jsr 	_UMParameter
.01902c	fa		plx				plx
.01902d	20 62 93	jsr $019362			jsr 	CheckNextRParen
.019030	20 41 98	jsr $019841			jsr 	DivInteger32 				; divide
.019033	a5 1a		lda $1a				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.019035	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019037	a5 1b		lda $1b				lda 	zLTemp1+1
.019039	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01903b	a5 1c		lda $1c				lda 	zLTemp1+2
.01903d	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01903f	a5 1d		lda $1d				lda 	zLTemp1+3
.019041	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019043	60		rts				rts
.019044					_UMParameter:
.019044	20 3c 8d	jsr $018d3c			jsr 	EvaluateIntegerX 			; get value
.019047	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; absolute value
.019049	10 03		bpl $01904e			bpl 	_UMNotSigned
.01904b	20 c8 98	jsr $0198c8			jsr 	IntegerNegateAlways
.01904e					_UMNotSigned:
.01904e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.01904f					Unary_Usr:
.01904f	20 2e 8d	jsr $018d2e			jsr 	EvaluateNumberX 			; numeric parameter
.019052	20 62 93	jsr $019362			jsr 	CheckNextRParen 			; right bracket.
.019055	da		phx				phx 								; save XY
.019056	5a		phy				phy
.019057	ea		nop				nop
.019058	22 0c 03 00	jsl $00030c			jsl 	UserVector
.01905c	7a		ply				ply 								; and exit
.01905d	fa		plx				plx
.01905e	60		rts				rts
.01905f					USRDefault:
.01905f	20 ca 84	jsr $0184ca			jsr ERR_Handler
>019062	4e 6f 20 55 53 52 20 76			.text "No USR vector.",0
>01906a	65 63 74 6f 72 2e 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.019071					Unary_Val:
.019071	20 45 8d	jsr $018d45			jsr 	EvaluateStringX 			; get string
.019074	20 62 93	jsr $019362			jsr 	CheckNextRParen 			; check right bracket.
.019077	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.019079	85 1e		sta $1e				sta 	zGenPtr
.01907b	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01907d	85 1f		sta $1f				sta 	zGenPtr+1
.01907f	5a		phy				phy
.019080	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.019082	b1 1e		lda ($1e),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.019084	f0 54		beq $0190da			beq 	_UVBadNumber
.019086	48		pha				pha 								; save length.
.019087	1a		inc a				inc 	a 							; one for the length, one for the terminator
.019088	1a		inc a				inc 	a
.019089	20 a2 93	jsr $0193a2			jsr 	AllocateTempString
.01908c	c8		iny				iny 								; move to the next.
.01908d	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get character
.01908f	49 2d		eor #$2d			eor 	#"-"						; zero if minus sign
.019091	8d a0 03	sta $03a0			sta 	ValSign
.019094	d0 04		bne $01909a			bne 	_UVNotMinus
.019096	c8		iny				iny 								; skip over it.
.019097	68		pla				pla 								; decrement character count.
.019098	3a		dec a				dec 	a
.019099	48		pha				pha
.01909a					_UVNotMinus:
.01909a	68		pla				pla 								; this is the count.
.01909b	48		pha		_UVCopy:pha									; copy into new temp string which is ASCIIZ
.01909c	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.01909e	c8		iny				iny
.01909f	20 cd 93	jsr $0193cd			jsr 	WriteTempString
.0190a2	68		pla				pla
.0190a3	3a		dec a				dec 	a
.0190a4	d0 f5		bne $01909b			bne 	_UVCopy
.0190a6	20 cd 93	jsr $0193cd			jsr 	WriteTempString 			; make it ASCIIZ
.0190a9	18		clc				clc
.0190aa	a5 20		lda $20				lda 	zTempStr 					; tempstring +1 => genptr
.0190ac	69 01		adc #$01			adc 	#1
.0190ae	85 1e		sta $1e				sta 	zGenPtr
.0190b0	a5 21		lda $21				lda 	zTempStr+1
.0190b2	69 00		adc #$00			adc 	#0
.0190b4	85 1f		sta $1f				sta 	zGenPtr+1
.0190b6	18		clc				clc
.0190b7	20 9a 99	jsr $01999a			jsr 	IntFromString 				; first bit.
.0190ba	b0 1e		bcs $0190da			bcs 	_UVBadNumber
.0190bc	20 db 9e	jsr $019edb			jsr 	FPFromString				; try for a float part.
.0190bf	ad a0 03	lda $03a0			lda 	ValSign 					; was it negative
.0190c2	d0 10		bne $0190d4			bne 	_UVNotNegative
.0190c4	b5 85		lda $85,x			lda 	XS_Type,x 					; check if integer
.0190c6	4a		lsr a				lsr 	a
.0190c7	b0 08		bcs $0190d1			bcs 	_UVInteger
.0190c9	b5 85		lda $85,x			lda 	XS_Type,x 					; set sign bit
.0190cb	09 80		ora #$80			ora 	#$80
.0190cd	95 85		sta $85,x			sta 	XS_Type,x
.0190cf	80 03		bra $0190d4			bra 	_UVNotNegative
.0190d1					_UVInteger:
.0190d1	20 c8 98	jsr $0198c8			jsr 	IntegerNegateAlways 		; sign it.
.0190d4					_UVNotNegative:
.0190d4	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; used everything
.0190d6	d0 02		bne $0190da			bne 	_UVBadNumber
.0190d8	7a		ply				ply
.0190d9	60		rts				rts
.0190da					_UVBadNumber:
.0190da	4c b9 84	jmp $0184b9			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.0190dd					Unary_Str:
.0190dd	20 2e 8d	jsr $018d2e			jsr 	EvaluateNumberX 			; numeric parameter
.0190e0	20 62 93	jsr $019362			jsr 	CheckNextRParen 			; right bracket.
.0190e3	a9 00		lda #$00			lda 	#0 							; reset buffer index
.0190e5	8d 14 03	sta $0314			sta 	NumBufX
.0190e8	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.0190ea	4a		lsr a				lsr 	a
.0190eb	b0 05		bcs $0190f2			bcs 	_USInt 						; if msb set do as integer
.0190ed	20 20 9e	jsr $019e20			jsr 	FPToString 					; call fp to str otherwise
.0190f0	80 03		bra $0190f5			bra 	_USDuplicate
.0190f2	20 e5 98	jsr $0198e5	_USInt:	jsr 	IntToString
.0190f5					_USDuplicate:
.0190f5	ad 14 03	lda $0314			lda 	NumBufX 					; chars in buffer
.0190f8	1a		inc a				inc 	a 							; one more for length
.0190f9	20 a2 93	jsr $0193a2			jsr 	AllocateTempString 			; allocate space for it.
.0190fc	5a		phy				phy 								; save Y
.0190fd	a0 00		ldy #$00			ldy 	#0 							; start copying
.0190ff	b9 15 03	lda $0315,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.019102	20 cd 93	jsr $0193cd			jsr 	WriteTempString
.019105	c8		iny				iny
.019106	cc 14 03	cpy $0314			cpy 	NumBufX 					; done the lot
.019109	d0 f4		bne $0190ff			bne 	_USCopy
.01910b	7a		ply				ply 								; restore Y
.01910c	4c d7 92	jmp $0192d7			jmp 	UnaryReturnTempStr 			; return new temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.01910f					Unary_Asc:
.01910f	20 45 8d	jsr $018d45			jsr 	EvaluateStringX 			; string parameter
.019112	20 62 93	jsr $019362			jsr 	CheckNextRParen 			; right bracket.
.019115	5a		phy				phy 								; get the string length
.019116	a0 00		ldy #$00			ldy 	#0
.019118	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.01911a	f0 07		beq $019123			beq 	_UAIllegal 					; must be at least one character
.01911c	c8		iny				iny
.01911d	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; read it.
.01911f	7a		ply				ply
.019120	4c 9d 8f	jmp $018f9d			jmp 	UnarySetAInteger
.019123					_UAIllegal:
.019123	4c b9 84	jmp $0184b9			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.019126					Unary_Len:
.019126	20 45 8d	jsr $018d45			jsr 	EvaluateStringX 			; string parameter
.019129	20 62 93	jsr $019362			jsr 	CheckNextRParen 			; right bracket.
.01912c	5a		phy				phy 								; get the string length
.01912d	a0 00		ldy #$00			ldy 	#0
.01912f	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.019131	7a		ply				ply
.019132	4c 9d 8f	jmp $018f9d			jmp 	UnarySetAInteger

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.019135					Unary_Mid:
.019135	20 45 8d	jsr $018d45			jsr 	EvaluateStringX 				; get string.
.019138	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.01913a	48		pha				pha
.01913b	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01913d	48		pha				pha
.01913e	20 6a 93	jsr $01936a			jsr 	CheckNextComma 					; skip comma
.019141	20 ca 91	jsr $0191ca			jsr 	SLIByteParameter 				; get a byte parameter (start)
.019144	48		pha				pha 									; and push it.
.019145	20 6a 93	jsr $01936a			jsr 	CheckNextComma 					; skip comma
.019148	20 ca 91	jsr $0191ca			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.01914b	48		pha				pha 									; and push it.
.01914c	80 41		bra $01918f			bra 	SLIProcess
.01914e					Unary_Left:
.01914e	20 45 8d	jsr $018d45			jsr 	EvaluateStringX 				; get string.
.019151	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.019153	48		pha				pha
.019154	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019156	48		pha				pha
.019157	a9 01		lda #$01			lda 	#1 								; push start position (1)
.019159	48		pha				pha
.01915a	20 6a 93	jsr $01936a			jsr 	CheckNextComma 					; skip comma
.01915d	20 ca 91	jsr $0191ca			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.019160	48		pha				pha 									; and push it.
.019161	80 2c		bra $01918f			bra 	SLIProcess
.019163					Unary_Right:
.019163	20 45 8d	jsr $018d45			jsr 	EvaluateStringX 				; get string.
.019166	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.019168	48		pha				pha
.019169	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01916b	48		pha				pha
.01916c	da		phx				phx 									; get the string length and push on stack.
.01916d	a2 00		ldx #$00			ldx 	#0
.01916f	a1 1e		lda ($1e,x)			lda		(zGenPtr,x)
.019171	fa		plx				plx
.019172	48		pha				pha
.019173	20 6a 93	jsr $01936a			jsr 	CheckNextComma 					; skip comma
.019176	20 ca 91	jsr $0191ca			jsr 	SLIByteParameter 				; get a byte parameter.
.019179	8d 9e 03	sta $039e			sta 	SignCount 						; save in temporary.
.01917c	68		pla				pla 									; restore string length.
.01917d	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.01917e	38		sec				sec
.01917f	ed 9e 03	sbc $039e			sbc 	SignCount 						; subtract characters needed, gives start position.
.019182	f0 02		beq $019186			beq 	_URStart 						; if <= 0 start from 1.
.019184	10 02		bpl $019188			bpl 	_UROkay
.019186					_URStart:
.019186	a9 01		lda #$01			lda 	#1
.019188					_UROkay:
.019188	48		pha				pha 									; push start
.019189	ad 9e 03	lda $039e			lda 	SignCount 						; push count of characters
.01918c	48		pha				pha
.01918d	80 00		bra $01918f			bra 	SLIProcess
.01918f					SLIProcess:
.01918f	20 62 93	jsr $019362			jsr 	CheckNextRParen 				; closing right bracket.
.019192	68		pla				pla
.019193	8d a2 03	sta $03a2			sta 	SliceCount 						; count in signcount
.019196	1a		inc a				inc 	a 								; allocate +1 for it.
.019197	20 a2 93	jsr $0193a2			jsr 	AllocateTempString
.01919a	68		pla				pla 									; pop start number off stack.
.01919b	f0 3b		beq $0191d8			beq 	SLIError 						; exit if start = 0
.01919d	8d a1 03	sta $03a1			sta 	SliceStart
.0191a0	68		pla				pla  									; pop string address.
.0191a1	85 1f		sta $1f				sta 	zGenPtr+1
.0191a3	68		pla				pla
.0191a4	85 1e		sta $1e				sta 	zGenPtr
.0191a6	da		phx				phx
.0191a7	5a		phy				phy
.0191a8	a2 00		ldx #$00			ldx 	#0 								; point to string length.
.0191aa	ac a1 03	ldy $03a1			ldy 	SliceStart 						; start of the string (+1 for count)
.0191ad					_SLICopy:
.0191ad	ad a2 03	lda $03a2			lda 	SliceCount 						; done count characters
.0191b0	f0 12		beq $0191c4			beq 	_SLIExit
.0191b2	ce a2 03	dec $03a2			dec 	SliceCount
.0191b5	98		tya				tya 									; index of character
.0191b6	c1 1e		cmp ($1e,x)			cmp 	(zGenPtr,x)						; compare against length
.0191b8	f0 02		beq $0191bc			beq 	_SLIOk 							; if equal, okay.
.0191ba	b0 08		bcs $0191c4			bcs 	_SLIExit 						; if past end, then exit.
.0191bc	b1 1e		lda ($1e),y	_SLIOk:	lda 	(zGenPtr),y 					; copy one character
.0191be	c8		iny				iny
.0191bf	20 cd 93	jsr $0193cd			jsr 	WriteTempString
.0191c2	80 e9		bra $0191ad			bra 	_SLICopy 						; go round till copied characters
.0191c4					_SLIExit:
.0191c4	7a		ply				ply 									; restore YX
.0191c5	fa		plx				plx
.0191c6	4c d7 92	jmp $0192d7			jmp 	UnaryReturnTempStr 				; return new temporary string.
.0191c9	ea		nop				nop
.0191ca					SLIByteParameter:
.0191ca	20 3c 8d	jsr $018d3c			jsr 	EvaluateIntegerX 				; get integer
.0191cd	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.0191cf	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.0191d1	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.0191d3	d0 03		bne $0191d8			bne 	SLIError
.0191d5	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0191d7	60		rts				rts
.0191d8					SLIError:
.0191d8	4c b9 84	jmp $0184b9			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.0191db					Unary_Hex:
.0191db	20 3c 8d	jsr $018d3c			jsr 	EvaluateIntegerX 			; numeric parameter
.0191de	20 62 93	jsr $019362			jsr 	CheckNextRParen 			; right bracket.
.0191e1	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.0191e3	20 a2 93	jsr $0193a2			jsr 	AllocateTempString			; allocate string space
.0191e6	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.0191e8	20 0c 92	jsr $01920c			jsr 	_UHConvert
.0191eb	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0191ed	20 0c 92	jsr $01920c			jsr 	_UHConvert
.0191f0	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0191f2	20 0c 92	jsr $01920c			jsr 	_UHConvert
.0191f5	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0191f7	20 0c 92	jsr $01920c			jsr 	_UHConvert
.0191fa	5a		phy				phy 								; get length of new string
.0191fb	a0 00		ldy #$00			ldy 	#0
.0191fd	b1 20		lda ($20),y			lda 	(zTempStr),y
.0191ff	7a		ply				ply
.019200	c9 00		cmp #$00			cmp 	#0
.019202	d0 05		bne $019209			bne 	_UHExit 					; if it was non zero okay
.019204	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.019206	20 cd 93	jsr $0193cd			jsr 	WriteTempString
.019209					_UHExit:
.019209	4c d7 92	jmp $0192d7			jmp 	UnaryReturnTempStr 			; return new temporary string.
.01920c					_UHConvert:
.01920c	48		pha				pha
.01920d	4a		lsr a				lsr 	a 							; do MSB
.01920e	4a		lsr a				lsr 	a
.01920f	4a		lsr a				lsr 	a
.019210	4a		lsr a				lsr 	a
.019211	20 15 92	jsr $019215			jsr 	_UHNibble
.019214	68		pla				pla 								; do LSB
.019215					_UHNibble:
.019215	29 0f		and #$0f			and 	#15 						; get nibble
.019217	d0 0c		bne $019225			bne 	_UHNonZero
.019219	5a		phy				phy									; get the length
.01921a	a0 00		ldy #$00			ldy 	#0
.01921c	b1 20		lda ($20),y			lda 	(zTempStr),y
.01921e	7a		ply				ply
.01921f	c9 00		cmp #$00			cmp 	#0 							; suppress leading zeros.
.019221	f0 0d		beq $019230			beq 	_UHExit2
.019223	a9 00		lda #$00			lda 	#0
.019225					_UHNonZero:
.019225	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.019227	90 02		bcc $01922b			bcc 	_UHDigit
.019229	69 06		adc #$06			adc 	#7-1
.01922b					_UHDigit:
.01922b	69 30		adc #$30			adc 	#48
.01922d	20 cd 93	jsr $0193cd			jsr 	WriteTempString				; output.
.019230					_UHExit2:
.019230	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.019231					Unary_Dec:
.019231	20 45 8d	jsr $018d45			jsr 	EvaluateStringX 			; string parameter
.019234	20 62 93	jsr $019362			jsr 	CheckNextRParen 			; right bracket.
.019237	5a		phy				phy
.019238	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.01923a	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.01923c	f0 41		beq $01927f			beq 	_UDFail 					; must fail if zero.
.01923e	8d 9e 03	sta $039e			sta 	SignCount 					; use SignCount as a counter
.019241	a9 00		lda #$00			lda 	#0 							; set result to zero integer.
.019243	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019245	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019247	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019249	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01924b	a9 01		lda #$01			lda 	#1
.01924d	95 85		sta $85,x			sta 	XS_Type,x
.01924f					_UDConvertLoop:
.01924f	5a		phy				phy 								; shift mantissa left 4
.019250	a0 04		ldy #$04			ldy 	#4
.019252					_UDShift:
.019252	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.019254	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.019256	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.019258	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.01925a	88		dey				dey
.01925b	d0 f5		bne $019252			bne 	_UDShift
.01925d	7a		ply				ply
.01925e	c8		iny				iny 								; next character
.01925f	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; fetch it.
.019261	20 82 92	jsr $019282			jsr 	ConvertUpper 				; convert to U/C
.019264	c9 30		cmp #$30			cmp 	#"0"
.019266	90 17		bcc $01927f			bcc 	_UDFail
.019268	c9 3a		cmp #$3a			cmp 	#"9"+1
.01926a	90 06		bcc $019272			bcc 	_UDOkay
.01926c	e9 37		sbc #$37			sbc 	#7+"0" 						; alpha fudge
.01926e	c9 10		cmp #$10			cmp 	#16
.019270	b0 0d		bcs $01927f			bcs 	_UDFail
.019272					_UDOkay:
.019272	29 0f		and #$0f			and 	#15 						; nibble only
.019274	15 80		ora $80,x			ora 	XS_Mantissa+0,x
.019276	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019278	ce 9e 03	dec $039e			dec 	SignCount 					; do it for each character
.01927b	d0 d2		bne $01924f			bne 	_UDConvertLoop
.01927d	7a		ply				ply
.01927e	60		rts				rts
.01927f					_UDFail:
.01927f	4c b9 84	jmp $0184b9			jmp 	BadParamError
.019282					ConvertUpper:
.019282	c9 61		cmp #$61			cmp 	#"a"
.019284	90 07		bcc $01928d			bcc 	_CUExit
.019286	c9 7b		cmp #$7b			cmp 	#"z"+1
.019288	b0 03		bcs $01928d			bcs 	_CUExit
.01928a	38		sec				sec
.01928b	e9 20		sbc #$20			sbc 	#32
.01928d	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.01928e					Unary_Chr:
.01928e	20 3c 8d	jsr $018d3c			jsr 	EvaluateIntegerX			; numeric parameter
.019291	20 62 93	jsr $019362			jsr 	CheckNextRParen 			; right bracket.
.019294	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.019296	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019298	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01929a	d0 0d		bne $0192a9			bne 	_UCChar
.01929c	a9 01		lda #$01			lda 	#1 							; one character string
.01929e	20 a2 93	jsr $0193a2			jsr 	AllocateTempString
.0192a1	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.0192a3	20 cd 93	jsr $0193cd			jsr 	WriteTempString
.0192a6	4c d7 92	jmp $0192d7			jmp 	UnaryReturnTempStr
.0192a9					_UCChar:
.0192a9	4c b9 84	jmp $0184b9			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.0192ac					Unary_Spc:
.0192ac	20 3c 8d	jsr $018d3c			jsr 	EvaluateIntegerX 			; numeric parameter
.0192af	20 62 93	jsr $019362			jsr 	CheckNextRParen 			; right bracket.
.0192b2	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.0192b4	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.0192b6	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.0192b8	d0 1a		bne $0192d4			bne 	_USSize
.0192ba	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0192bc	c9 fe		cmp #$fe			cmp 	#maxString+1
.0192be	b0 14		bcs $0192d4			bcs 	_USSize
.0192c0	48		pha				pha 								; save length
.0192c1	1a		inc a				inc 	a 							; allocate one more.
.0192c2	20 a2 93	jsr $0193a2			jsr 	AllocateTempString
.0192c5	68		pla				pla 								; get length
.0192c6	f0 0f		beq $0192d7			beq 	UnaryReturnTempStr 			; return the current temp string
.0192c8					_USLoop:
.0192c8	48		pha				pha
.0192c9	a9 20		lda #$20			lda 	#" "
.0192cb	20 cd 93	jsr $0193cd			jsr 	WriteTempString
.0192ce	68		pla				pla
.0192cf	3a		dec a				dec 	a
.0192d0	d0 f6		bne $0192c8			bne 	_USLoop
.0192d2	80 03		bra $0192d7			bra 	UnaryReturnTempStr
.0192d4					_USSize:
.0192d4	4c b9 84	jmp $0184b9			jmp 	BadParamError
.0192d7					UnaryReturnTempStr:
.0192d7	a5 20		lda $20				lda 	zTempStr 					; copy temp string addr -> mantissa
.0192d9	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0192db	a5 21		lda $21				lda 	zTempStr+1
.0192dd	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0192df	a9 02		lda #$02			lda 	#2 							; set type to string
.0192e1	95 85		sta $85,x			sta 	XS_Type,x
.0192e3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/65816.asm

.0192e4					MemRead:
.0192e4	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.0192e7	a0 00		ldy #$00			ldy 	#0 							; start from here
.0192e9	b7 1a		lda [$1a],y	_MLoop1:lda 	[zlTemp1],y 				; read the long address
.0192eb	95 80		sta $80,x			sta 	XS_Mantissa,x 				; copy into mantissa
.0192ed	c8		iny				iny 								; next to copy
.0192ee	e8		inx				inx
.0192ef	cc 9e 03	cpy $039e			cpy 	SignCount 					; do required # of bytes.
.0192f2	d0 f5		bne $0192e9			bne 	_MLoop1
.0192f4	60		rts				rts
.0192f5					MemWrite:
.0192f5	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.0192f8	a0 00		ldy #$00			ldy 	#0 							; start from here
.0192fa	b5 80		lda $80,x	_MLoop1:lda 	XS_Mantissa,x 				; read mantisssa
.0192fc	97 1a		sta [$1a],y			sta 	[zlTemp1],y 				; write it out
.0192fe	c8		iny				iny 								; next to copy
.0192ff	e8		inx				inx
.019300	cc 9e 03	cpy $039e			cpy 	SignCount 					; do required # of bytes.
.019303	d0 f5		bne $0192fa			bne 	_MLoop1
.019305	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/programend.asm

.019306					UpdateProgramEnd:
.019306	a9 00		lda #$00			lda 	#BasicProgram & $FF
.019308	85 16		sta $16				sta 	zCodePtr+0
.01930a	a9 10		lda #$10			lda 	#BasicProgram >> 8
.01930c	85 17		sta $17				sta 	zCodePtr+1
.01930e	a9 00		lda #$00			lda 	#0
.019310	85 18		sta $18				sta 	zCodePtr+2
.019312	85 19		sta $19				sta 	zCodePtr+3
.019314	a0 03		ldy #$03			ldy 	#3
.019316					_UPDLoop:
.019316	a0 00		ldy #$00			ldy 	#0
.019318	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01931a	c9 00		cmp #$00			cmp 	#0 							; end if offset is zero.
.01931c	f0 0f		beq $01932d			beq 	_UPDFoundEnd
.01931e	a0 00		ldy #$00			ldy 	#0 							; point to offset
.019320	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.019322	18		clc				clc
.019323	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.019325	85 16		sta $16				sta 	zCodePtr
.019327	90 02		bcc $01932b			bcc 	_SNLNoCarry
.019329	e6 17		inc $17				inc 	zCodePtr+1
.01932b					_SNLNoCarry:
.01932b	80 e9		bra $019316			bra 	_UPDLoop
.01932d					_UPDFoundEnd:
.01932d	18		clc				clc 								; end of program 2 on.
.01932e	a5 16		lda $16				lda 	zCodePtr
.019330	69 02		adc #$02			adc 	#2
.019332	8d 04 03	sta $0304			sta 	endOfProgram
.019335	a5 17		lda $17				lda 	zCodePtr+1
.019337	69 00		adc #$00			adc 	#0
.019339	8d 05 03	sta $0305			sta 	endOfProgram+1
.01933c	a5 18		lda $18				lda 	zCodePtr+2
.01933e	69 00		adc #$00			adc		#0
.019340	8d 06 03	sta $0306			sta 	endOfProgram+2
.019343	a5 19		lda $19				lda 	zCodePtr+3
.019345	69 00		adc #$00			adc 	#0
.019347	8d 07 03	sta $0307			sta 	endOfProgram+3
.01934a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.01934b					CheckNextToken:
.01934b	d7 16		cmp [$16],y			cmp 	[zCodePtr],y
.01934d	d0 02		bne $019351			bne 	CTFail 						; no, then fail
.01934f	c8		iny				iny
.019350	60		rts				rts
.019351					CTFail:
.019351	20 ca 84	jsr $0184ca			jsr ERR_Handler
>019354	4d 69 73 73 69 6e 67 20			.text "Missing token",0
>01935c	74 6f 6b 65 6e 00
.019362					CheckNextRParen:
.019362	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019364	c9 be		cmp #$be			cmp 	#token_rparen
.019366	d0 e9		bne $019351			bne 	CTFail
.019368	c8		iny				iny
.019369	60		rts				rts
.01936a					CheckNextComma:
.01936a	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01936c	c9 bf		cmp #$bf			cmp 	#token_comma
.01936e	d0 e1		bne $019351			bne 	CTFail
.019370	c8		iny				iny
.019371	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/concrete.asm

.019372					StringConcrete:
.019372	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; save source to zTemp1
.019374	85 10		sta $10				sta 	zTemp1
.019376	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019378	85 11		sta $11				sta 	zTemp1+1
.01937a	a0 00		ldy #$00			ldy 	#0 							; subtract the length+1 (clc) of the string.
.01937c	18		clc				clc 								; from the string pointer
.01937d	ad 00 03	lda $0300			lda 	StringPtr 					; and put in zTemp2 as well
.019380	f1 10		sbc ($10),y			sbc 	(zTemp1),y
.019382	8d 00 03	sta $0300			sta 	StringPtr
.019385	85 12		sta $12				sta 	zTemp2
.019387	ad 01 03	lda $0301			lda 	StringPtr+1
.01938a	e9 00		sbc #$00			sbc 	#0
.01938c	8d 01 03	sta $0301			sta 	StringPtr+1
.01938f	85 13		sta $13				sta 	zTemp2+1
.019391	b1 10		lda ($10),y			lda 	(zTemp1),y 					; length add one for count
.019393	1a		inc a				inc 	a
.019394	aa		tax				tax
.019395	b1 10		lda ($10),y	_SCCopy:lda 	(zTemp1),y 					; copy whole thing including length
.019397	91 12		sta ($12),y			sta 	(zTemp2),y
.019399	c8		iny				iny
.01939a	ca		dex				dex
.01939b	d0 f8		bne $019395			bne 	_SCCopy
.01939d	a5 13		lda $13				lda 	zTemp2+1 					; return concrete string in AX
.01939f	a6 12		ldx $12				ldx 	zTemp2
.0193a1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.0193a2					AllocateTempString:
.0193a2	48		pha				pha 								; save required count.
.0193a3	a5 21		lda $21				lda 	zTempStr+1 					; check if initialised yet ?
.0193a5	d0 0b		bne $0193b2			bne 	_ATSInitialised
.0193a7	ad 00 03	lda $0300			lda 	StringPtr 					; set temporary string ptr 1 page below available
.0193aa	85 20		sta $20				sta 	zTempStr					; space, this is for strings to be concreted.
.0193ac	ad 01 03	lda $0301			lda 	StringPtr+1
.0193af	3a		dec a				dec 	a
.0193b0	85 21		sta $21				sta 	zTempStr+1
.0193b2					_ATSInitialised:
.0193b2	68		pla				pla 								; get required count back.
.0193b3	49 ff		eor #$ff			eor 	#$FF 						; negate 2's complement.
.0193b5	1a		inc a				inc 	a
.0193b6	18		clc				clc
.0193b7	65 20		adc $20				adc 	zTempStr 					; "add" to the temp string pointer
.0193b9	85 20		sta $20				sta 	zTempStr
.0193bb	a9 ff		lda #$ff			lda 	#$FF
.0193bd	65 21		adc $21				adc 	zTempStr+1
.0193bf	85 21		sta $21				sta 	zTempStr+1
.0193c1	a9 00		lda #$00			lda 	#0 							; clear temp string.
.0193c3	5a		phy				phy
.0193c4	a8		tay				tay
.0193c5	91 20		sta ($20),y			sta 	(zTempStr),y
.0193c7	7a		ply				ply
.0193c8	1a		inc a				inc 	a 							; reset the write index.
.0193c9	8d 9f 03	sta $039f			sta 	TempStringWriteIndex
.0193cc	60		rts				rts
.0193cd					WriteTempString:
.0193cd	5a		phy				phy 								; save Y
.0193ce	ac 9f 03	ldy $039f			ldy 	TempStringWriteIndex	 	; write position.
.0193d1	91 20		sta ($20),y			sta 	(zTempStr),y 				; write character out.
.0193d3	ee 9f 03	inc $039f			inc 	TempStringWriteIndex 		; increment the write position.
.0193d6	98		tya				tya 								; unchanged Y is now length
.0193d7	a0 00		ldy #$00			ldy 	#0
.0193d9	91 20		sta ($20),y			sta 	(zTempStr),y
.0193db	7a		ply				ply 								; restore Y and exit
.0193dc	60		rts				rts
.0193dd					CreateTempStringCopy:
.0193dd	da		phx				phx 								; save X
.0193de	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0193e0	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.0193e1	20 a2 93	jsr $0193a2			jsr 	AllocateTempString 			; allocate memory for temporary string.
.0193e4	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0193e6	c8		iny				iny
.0193e7	3a		dec a				dec 	a 							; make the actual length in charactes
.0193e8	3a		dec a				dec 	a
.0193e9	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.0193eb	81 20		sta ($20,x)			sta 	(zTempStr,x)
.0193ed	85 1a		sta $1a				sta 	zLTemp1 					; that's used as a count.
.0193ef	09 00		ora #$00			ora 	#0 							; if zero already, exit
.0193f1	f0 0e		beq $019401			beq 	_CTSCExit
.0193f3					_CTSCLoop:
.0193f3	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0193f5	c8		iny				iny
.0193f6	5a		phy				phy 								; save in Y
.0193f7	e8		inx				inx 								; bump index
.0193f8	da		phx				phx 								; index into Y
.0193f9	7a		ply				ply
.0193fa	91 20		sta ($20),y			sta 	(zTempStr),y 				; save at index
.0193fc	7a		ply				ply 								; restore Y
.0193fd	c6 1a		dec $1a				dec 	zLTemp1 					; do for each character
.0193ff	d0 f2		bne $0193f3			bne 	_CTSCLoop
.019401					_CTSCExit:
.019401	fa		plx				plx 								; restore X
.019402	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/variables.asm

.019403					VariableFind:
.019403	20 6e 94	jsr $01946e			jsr 	VariableExtract 		; find out all about it ....
.019406	20 07 97	jsr $019707			jsr 	VariableLocate 			; does it already exist ?
.019409	b0 03		bcs $01940e			bcs 	_VFExists 				; if so, use that.
.01940b	20 fa 94	jsr $0194fa			jsr 	VariableCreate 			; otherwise create it.
.01940e					_VFExists:
.01940e	a5 24		lda $24				lda 	zVarType 				; is it still an array ?
.019410	29 01		and #$01			and 	#1
.019412	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.019414	d0 28		bne $01943e			bne 	_VFSingleElement
.019416					_VFNextIndex:
.019416	a5 22		lda $22				lda 	zVarDataPtr 			; push the data ptr and type on the stack.
.019418	48		pha				pha
.019419	a5 23		lda $23				lda 	zVarDataPtr+1
.01941b	48		pha				pha
.01941c	a5 24		lda $24				lda 	zVarType
.01941e	48		pha				pha
.01941f	20 3c 8d	jsr $018d3c			jsr 	EvaluateIntegerX 		; calculate the index.
.019422	68		pla				pla 							; restore and index.
.019423	85 24		sta $24				sta 	zVarType
.019425	68		pla				pla
.019426	85 23		sta $23				sta 	zVarDataPtr+1
.019428	68		pla				pla
.019429	85 22		sta $22				sta 	zVarDataPtr
.01942b	20 85 95	jsr $019585			jsr 	ArrayIndexFollow 		; do the index.
.01942e	a5 24		lda $24				lda 	zVarType 				; is it still an array ??
.019430	29 01		and #$01			and 	#1
.019432	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.019434	d0 05		bne $01943b			bne 	_VFArrayDone 			; if so then exit.
.019436	20 6a 93	jsr $01936a			jsr 	CheckNextComma 			; comma should follow
.019439	80 db		bra $019416			bra 	_VFNextIndex
.01943b					_VFArrayDone:
.01943b	20 62 93	jsr $019362			jsr 	CheckNextRParen 		; check closing right bracket.
.01943e					_VFSingleElement:
.01943e	60		rts				rts
.01943f					VariableClear:
.01943f	48		pha				pha 							; save registers
.019440	da		phx				phx
.019441	a2 00		ldx #$00			ldx 	#0 						; clear out the hash table.
.019443	8a		txa				txa
.019444	9d 35 03	sta $0335,x	_VCLoop:sta 	HashTableBase,x
.019447	e8		inx				inx
.019448	e0 60		cpx #$60			cpx 	#HashTableEnd-HashTableBase
.01944a	d0 f8		bne $019444			bne 	_VCLoop
.01944c	a9 00		lda #$00			lda 	#VariableMemory & $FF
.01944e	8d 02 03	sta $0302			sta 	VarMemPtr
.019451	a9 30		lda #$30			lda 	#VariableMemory >> 8
.019453	8d 03 03	sta $0303			sta 	VarMemPtr+1
.019456	fa		plx				plx 							; restore registers
.019457	68		pla				pla
.019458	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/extract.asm

.019459					VariableNameError:
.019459	20 ca 84	jsr $0184ca			jsr ERR_Handler
>01945c	42 61 64 20 56 61 72 69			.text "Bad Variable Name",0
>019464	61 62 6c 65 20 4e 61 6d 65 00
.01946e					VariableExtract:
.01946e	da		phx				phx 							; save X.
.01946f	a9 ba		lda #$ba			lda 	#token_hashlParen  		; set the type to #( e.g. real array.
.019471	8d 95 03	sta $0395			sta 	Var_Type
.019474	8d 96 03	sta $0396			sta 	Var_Hash 				; we initialise the hash with this. It doesn't matter
.019477	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019479	c9 00		cmp #$00			cmp 	#0 						; first one must be A-Z
.01947b	f0 dc		beq $019459			beq 	VariableNameError
.01947d	c9 1b		cmp #$1b			cmp 	#26+1
.01947f	b0 d8		bcs $019459			bcs 	VariableNameError
.019481	a2 ff		ldx #$ff			ldx 	#255 					; now copy it into the variable buffer.
.019483					_VECopyBuffer:
.019483	e8		inx				inx
.019484	e0 1f		cpx #$1f			cpx 	#31 					; too long
.019486	f0 d1		beq $019459			beq 	VariableNameError
.019488	9d 15 03	sta $0315,x			sta 	Var_Buffer,x 			; save character
.01948b	18		clc				clc  							; update the hash value for it.
.01948c	6d 96 03	adc $0396			adc 	Var_Hash
.01948f	8d 96 03	sta $0396			sta 	Var_Hash
.019492	c8		iny				iny
.019493	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019495	c9 00		cmp #$00			cmp 	#0 						; zero or token, end of variable
.019497	f0 0e		beq $0194a7			beq 	_VECopyEnd
.019499	30 0c		bmi $0194a7			bmi 	_VECopyEnd
.01949b	c9 1b		cmp #$1b			cmp 	#26+1 					; A-Z continue copying
.01949d	90 e4		bcc $019483			bcc 	_VECopyBuffer
.01949f	c9 30		cmp #$30			cmp 	#"0" 					; 0-9 copy as well.
.0194a1	90 04		bcc $0194a7			bcc 	_VECopyEnd
.0194a3	c9 3a		cmp #$3a			cmp 	#"9"+1
.0194a5	90 dc		bcc $019483			bcc 	_VECopyBuffer
.0194a7					_VECopyEnd:
.0194a7	c8		iny				iny
.0194a8	c9 b7		cmp #$b7			cmp 	#token_Dollar 			; first type token.
.0194aa	90 04		bcc $0194b0			bcc 	_VEDefaultRequired
.0194ac	c9 bd		cmp #$bd			cmp 	#token_PercentLParen+1	; last type token.
.0194ae	90 0b		bcc $0194bb			bcc 	_VEHaveType
.0194b0					_VEDefaultRequired:
.0194b0	c9 bd		cmp #$bd			cmp 	#token_LParen 			; if it ends in ( then use the real array
.0194b2	f0 04		beq $0194b8			beq 	_VESetType 				; default set above.
.0194b4	ce 95 03	dec $0395			dec 	Var_Type 				; this changes that default to the variable default
.0194b7	88		dey				dey
.0194b8					_VESetType:
.0194b8	ad 95 03	lda $0395			lda 	Var_Type 				; get type ....
.0194bb					_VEHaveType:
.0194bb	8d 95 03	sta $0395			sta 	Var_Type 				; save as type.
.0194be	bd 15 03	lda $0315,x			lda 	Var_Buffer,x 			; set bit 7 of name, marks the end.
.0194c1	09 80		ora #$80			ora 	#$80
.0194c3	9d 15 03	sta $0315,x			sta 	Var_Buffer,x
.0194c6	e8		inx				inx 							; offset 3 => length 4.
.0194c7	8e 97 03	stx $0397			stx 	Var_Length 				; save length of variable name.
.0194ca	ad 95 03	lda $0395			lda 	Var_Type 				; get offset of var type from first type token
.0194cd	38		sec				sec
.0194ce	e9 b7		sbc #$b7			sbc 	#token_Dollar
.0194d0	0a		asl a				asl 	a 						; multiply by 16. This requires HashTableSize
.0194d1	0a		asl a				asl 	a 						; in data.asm to be 8 (8 sets of links,2 bytes each)
.0194d2	0a		asl a				asl 	a
.0194d3	0a		asl a				asl 	a
.0194d4	8d 98 03	sta $0398			sta 	Var_HashAddress
.0194d7	ad 96 03	lda $0396			lda 	Var_Hash 				; get the hash
.0194da	29 07		and #$07			and 	#(HashTableSize-1) 		; force into range 0-tableSize-1
.0194dc	0a		asl a				asl 	a 						; double it (2 bytes per entry) & clears carry
.0194dd	6d 98 03	adc $0398			adc 	Var_HashAddress 		; add table offset.
.0194e0	69 35		adc #$35			adc 	#HashTableBase & $FF 	; now the low byte of the actual table address
.0194e2	8d 98 03	sta $0398			sta 	Var_HashAddress
.0194e5	a2 05		ldx #$05			ldx 	#5 						; hash is 5 bytes (real)
.0194e7	ad 95 03	lda $0395			lda 	Var_Type
.0194ea	c9 b9		cmp #$b9			cmp 	#token_Hash
.0194ec	f0 07		beq $0194f5			beq 	_VEHaveSize
.0194ee	ca		dex				dex
.0194ef	c9 bb		cmp #$bb			cmp 	#token_Percent 			; percent is 4 bytes (integer)
.0194f1	f0 02		beq $0194f5			beq 	_VEHaveSize
.0194f3	a2 02		ldx #$02			ldx 	#2 						; everything else is two.
.0194f5					_VEHaveSize:
.0194f5	8e 99 03	stx $0399			stx 	Var_DataSize
.0194f8	fa		plx				plx
.0194f9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varcreate.asm

.0194fa					VariableCreate:
.0194fa	da		phx				phx
.0194fb	5a		phy				phy
.0194fc	ad 02 03	lda $0302			lda 	VarMemPtr 					; get address of next free into zTemp1
.0194ff	85 10		sta $10				sta 	zTemp1
.019501	ad 03 03	lda $0303			lda 	VarMemPtr+1
.019504	85 11		sta $11				sta 	zTemp1+1
.019506	ad 99 03	lda $0399			lda 	Var_DataSize 				; bytes for the data bit
.019509	18		clc				clc
.01950a	6d 97 03	adc $0397			adc 	Var_Length 					; add the length of the name
.01950d	69 03		adc #$03			adc 	#3 							; 3 for the link and the hash.
.01950f	6d 02 03	adc $0302			adc 	VarMemPtr 					; add to variable memory pointer
.019512	8d 02 03	sta $0302			sta 	VarMemPtr
.019515	90 03		bcc $01951a			bcc 	_VCNoCarry
.019517	ee 03 03	inc $0303			inc 	VarMemPtr+1
.01951a					_VCNoCarry:
.01951a	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.01951d	85 12		sta $12				sta 	zTemp2
.01951f	a9 03		lda #$03			lda 	#HashTableBase >> 8
.019521	85 13		sta $13				sta 	zTemp2+1
.019523	a0 00		ldy #$00			ldy 	#0 							; put current hash link in position.
.019525	b1 12		lda ($12),y			lda 	(zTemp2),y
.019527	91 10		sta ($10),y			sta 	(zTemp1),y
.019529	c8		iny				iny
.01952a	b1 12		lda ($12),y			lda 	(zTemp2),y
.01952c	91 10		sta ($10),y			sta 	(zTemp1),y
.01952e	c8		iny				iny
.01952f	ad 96 03	lda $0396			lda 	Var_Hash 					; write the hash out.
.019532	91 10		sta ($10),y			sta 	(zTemp1),y
.019534	c8		iny				iny
.019535	a2 00		ldx #$00			ldx 	#0 							; copy the name out.
.019537					_VCCopyName:
.019537	bd 15 03	lda $0315,x			lda 	Var_Buffer,x
.01953a	91 10		sta ($10),y			sta 	(zTemp1),y
.01953c	e8		inx				inx
.01953d	c8		iny				iny
.01953e	ec 97 03	cpx $0397			cpx 	Var_Length
.019541	d0 f4		bne $019537			bne 	_VCCopyName
.019543	5a		phy				phy 								; save the data offset.
.019544	ae 99 03	ldx $0399			ldx 	Var_DataSize 				; and write the data out.
.019547	a9 00		lda #$00			lda 	#0 							; which is all zeroes.
.019549					_VCClearData:
.019549	91 10		sta ($10),y			sta 	(zTemp1),y
.01954b	c8		iny				iny
.01954c	ca		dex				dex
.01954d	d0 fa		bne $019549			bne 	_VCClearData
.01954f	68		pla				pla 								; offset to the data
.019550	18		clc				clc
.019551	65 10		adc $10				adc 	zTemp1 						; add to start and save as data pointer.
.019553	85 22		sta $22				sta 	zVarDataPtr
.019555	a5 11		lda $11				lda 	zTemp1+1
.019557	69 00		adc #$00			adc 	#0
.019559	85 23		sta $23				sta 	zVarDataPtr+1
.01955b	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.01955e	85 24		sta $24				sta 	zVarType
.019560	a5 10		lda $10				lda 	zTemp1 						; fix hash link to point to new record
.019562	a0 00		ldy #$00			ldy 	#0
.019564	91 12		sta ($12),y			sta 	(zTemp2),y
.019566	c8		iny				iny
.019567	a5 11		lda $11				lda 	zTemp1+1
.019569	91 12		sta ($12),y			sta 	(zTemp2),y
.01956b	ad 95 03	lda $0395			lda 	Var_Type 					; array ? if so create the empty one.
.01956e	29 01		and #$01			and 	#1
.019570	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.019572	d0 0e		bne $019582			bne 	_VCNotArray
.019574	a2 00		ldx #$00			ldx 	#0 							; call recursive array creator
.019576	20 1c 96	jsr $01961c			jsr 	ArrayCreate
.019579	5a		phy				phy 								; save YA at zVarDataPtr
.01957a	a0 00		ldy #$00			ldy 	#0
.01957c	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.01957e	c8		iny				iny
.01957f	68		pla				pla
.019580	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019582					_VCNotArray:
.019582	7a		ply				ply
.019583	fa		plx				plx
.019584	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arrayidx.asm

.019585					ArrayIndexFollow:
.019585	5a		phy				phy
.019586	a0 00		ldy #$00			ldy 	#0 							; make zVarDataPtr point to the array.
.019588	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; e.g. it points to itself.
.01958a	48		pha				pha
.01958b	c8		iny				iny
.01958c	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.01958e	85 23		sta $23				sta 	zVarDataPtr+1
.019590	68		pla				pla
.019591	85 22		sta $22				sta 	zVarDataPtr
.019593	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; MSB of 16 bit integer and bytes 2&3
.019595	29 80		and #$80			and 	#$80 						; must be zero.
.019597	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019599	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01959b	d0 59		bne $0195f6			bne 	_AIFError
.01959d	a0 00		ldy #$00			ldy 	#0 							; calculate size - current - 1
.01959f	18		clc				clc
.0195a0	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.0195a2	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.0195a4	c8		iny				iny
.0195a5	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.0195a7	08		php				php 								; clear bit 7 retaining borrow.
.0195a8	29 7f		and #$7f			and 	#$7F
.0195aa	28		plp				plp
.0195ab	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.0195ad	90 47		bcc $0195f6			bcc 	_AIFError 					; eror if size-current < 0
.0195af	b5 80		lda $80,x			lda  	XS_Mantissa+0,x 			; copy and double the index
.0195b1	0a		asl a				asl 	a 							; (e.g. index * 2)
.0195b2	85 10		sta $10				sta 	zTemp1
.0195b4	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0195b6	2a		rol a				rol 	a
.0195b7	85 11		sta $11				sta 	zTemp1+1
.0195b9	a0 01		ldy #$01			ldy 	#1 							; is this a data entry.
.0195bb	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; if so, then type is unchanged, offset set
.0195bd	30 1d		bmi $0195dc			bmi 	_AIFCalculate
.0195bf	c6 24		dec $24				dec 	zVarType 					; converts from an array to a type.
.0195c1	a5 24		lda $24				lda 	zVarType 					; check that type
.0195c3	c9 b7		cmp #$b7			cmp 	#token_Dollar 				; if string, use x 2
.0195c5	f0 15		beq $0195dc			beq 	_AIFCalculate
.0195c7	06 10		asl $10				asl 	zTemp1			 			; double the index
.0195c9	26 11		rol $11				rol 	zTemp1+1					; (e.g. index * 4)
.0195cb	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if integer, use x 4
.0195cd	f0 0d		beq $0195dc			beq 	_AIFCalculate
.0195cf	18		clc				clc 								; add the original mantissa in again
.0195d0	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; which makes it x5, for float.
.0195d2	65 10		adc $10				adc 	zTemp1
.0195d4	85 10		sta $10				sta 	zTemp1
.0195d6	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0195d8	65 11		adc $11				adc 	zTemp1+1
.0195da	85 11		sta $11				sta 	zTemp1+1
.0195dc					_AIFCalculate:
.0195dc	18		clc				clc 								; add index x 2,4 or 5 to base
.0195dd	a5 22		lda $22				lda 	zVarDataPtr
.0195df	65 10		adc $10				adc 	zTemp1
.0195e1	85 22		sta $22				sta 	zVarDataPtr
.0195e3	a5 23		lda $23				lda 	zVarDataPtr+1
.0195e5	65 11		adc $11				adc 	zTemp1+1
.0195e7	85 23		sta $23				sta 	zVarDataPtr+1
.0195e9	18		clc				clc 								; add 2 more for the length prefix.
.0195ea	a5 22		lda $22				lda 	zVarDataPtr
.0195ec	69 02		adc #$02			adc 	#2
.0195ee	85 22		sta $22				sta 	zVarDataPtr
.0195f0	90 02		bcc $0195f4			bcc 	_AIFNoBump
.0195f2	e6 23		inc $23				inc 	zVarDataPtr+1
.0195f4					_AIFNoBump:
.0195f4	7a		ply				ply
.0195f5	60		rts				rts
.0195f6					_AIFError:
.0195f6	20 ca 84	jsr $0184ca			jsr ERR_Handler
>0195f9	42 61 64 20 61 72 72 61			.text "Bad array index",0
>019601	79 20 69 6e 64 65 78 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arraydef.asm

.019609					ArrayResetDefault:
.019609	a9 0b		lda #$0b			lda 	#11 						; 0..10 one array
.01960b	8d a8 03	sta $03a8			sta 	ArrayDef+0
.01960e	a9 00		lda #$00			lda 	#0
.019610	8d a9 03	sta $03a9			sta 	ArrayDef+1
.019613	a9 ff		lda #$ff			lda 	#$FF
.019615	8d aa 03	sta $03aa			sta 	ArrayDef+2 					; $FFFF implies no second element.
.019618	8d ab 03	sta $03ab			sta 	ArrayDef+3					; (test bit 7 of 2nd byte)
.01961b	60		rts				rts
.01961c					ArrayCreate:
.01961c	bd a8 03	lda $03a8,x			lda 	ArrayDef+0,x 				; put size x 2 in zTemp1
.01961f	0a		asl a				asl 	a
.019620	85 10		sta $10				sta 	zTemp1
.019622	bd a9 03	lda $03a9,x			lda 	ArrayDef+1,x
.019625	2a		rol a				rol 	a
.019626	85 11		sta $11				sta 	zTemp1+1
.019628	bd ab 03	lda $03ab,x			lda 	ArrayDef+3,x 				; if this is the last element it's array of ptrs.
.01962b	10 22		bpl $01964f			bpl 	_ACSized 					; if not multiply size x 2 (str) 4 (int) 5 (real)
.01962d	ad 95 03	lda $0395			lda 	Var_Type 					; check the type
.019630	c9 b8		cmp #$b8			cmp 	#token_DollarLParen 		; also if it is an array of strings $(
.019632	f0 1b		beq $01964f			beq 	_ACSized
.019634	06 10		asl $10				asl 	zTemp1 						; double again
.019636	26 11		rol $11				rol 	zTemp1+1
.019638	b0 6f		bcs $0196a9			bcs 	ArrayIndexError 			; too large.
.01963a	c9 bc		cmp #$bc			cmp 	#token_PercentLParen 		; if %( four bytes/entry is enough.
.01963c	f0 11		beq $01964f			beq 	_ACSized
.01963e	18		clc				clc 								; add original value x 5 for reals.
.01963f	a5 10		lda $10				lda 	zTemp1
.019641	7d a8 03	adc $03a8,x			adc 	ArrayDef+0,x
.019644	85 10		sta $10				sta 	zTemp1
.019646	a5 11		lda $11				lda 	zTemp1+1
.019648	7d a9 03	adc $03a9,x			adc 	ArrayDef+1,x
.01964b	85 11		sta $11				sta 	zTemp1+1
.01964d	b0 5a		bcs $0196a9			bcs 	ArrayIndexError
.01964f					_ACSized:
.01964f	18		clc				clc
.019650	a5 10		lda $10				lda 	zTemp1
.019652	69 02		adc #$02			adc 	#2
.019654	85 10		sta $10				sta 	zTemp1
.019656	90 04		bcc $01965c			bcc 	_ACNoBump
.019658	e6 10		inc $10				inc 	zTemp1
.01965a	f0 4d		beq $0196a9			beq 	ArrayIndexError
.01965c					_ACNoBump:
.01965c	18		clc				clc
.01965d	ad 02 03	lda $0302			lda 	VarMemPtr 					; add this allocated count to VarMemPtr
.019660	85 12		sta $12				sta 	zTemp2						; save start in zTemp2/zTemp3
.019662	85 14		sta $14				sta 	zTemp3
.019664	65 10		adc $10				adc 	zTemp1
.019666	8d 02 03	sta $0302			sta 	VarMemPtr
.019669	ad 03 03	lda $0303			lda 	VarMemPtr+1
.01966c	85 13		sta $13				sta 	zTemp2+1
.01966e	85 15		sta $15				sta 	zTemp3+1
.019670	65 11		adc $11				adc 	zTemp1+1
.019672	8d 03 03	sta $0303			sta 	VarMemPtr+1
.019675	85 11		sta $11				sta 	zTemp1+1
.019677	b0 30		bcs $0196a9			bcs 	ArrayIndexError
.019679	a0 00		ldy #$00			ldy 	#0							; write $00 out.
.01967b					_ACClear:
.01967b	98		tya				tya
.01967c	91 12		sta ($12),y			sta 	(zTemp2),y
.01967e	e6 12		inc $12				inc 	zTemp2
.019680	d0 02		bne $019684			bne 	_ACCBump
.019682	e6 13		inc $13				inc 	zTemp2+1
.019684					_ACCBump:
.019684	a5 12		lda $12				lda 	zTemp2
.019686	cd 02 03	cmp $0302			cmp 	VarMemPtr
.019689	d0 f0		bne $01967b			bne 	_ACClear
.01968b	a5 13		lda $13				lda 	zTemp2+1
.01968d	cd 03 03	cmp $0303			cmp 	VarMemPtr+1
.019690	d0 e9		bne $01967b			bne 	_ACClear
.019692	a0 00		ldy #$00			ldy 	#0
.019694	bd a8 03	lda $03a8,x			lda 	ArrayDef+0,x 				; copy the size into the start
.019697	91 14		sta ($14),y			sta 	(zTemp3),y
.019699	c8		iny				iny
.01969a	bd a9 03	lda $03a9,x			lda 	ArrayDef+1,x
.01969d	91 14		sta ($14),y			sta 	(zTemp3),y
.01969f	bd ab 03	lda $03ab,x			lda 	ArrayDef+3,x 				; have we reached the end
.0196a2	10 18		bpl $0196bc			bpl 	ACCFillRecursive
.0196a4	a4 15		ldy $15				ldy 	zTemp3+1 					; return address
.0196a6	a5 14		lda $14				lda 	zTemp3
.0196a8	60		rts				rts
.0196a9					ArrayIndexError:
.0196a9	20 ca 84	jsr $0184ca			jsr ERR_Handler
>0196ac	42 61 64 20 61 72 72 61			.text "Bad array index",0
>0196b4	79 20 69 6e 64 65 78 00
.0196bc					ACCFillRecursive:
.0196bc	a9 ff		lda #$ff			lda 	#$FF 						; we mark the end, this is free space.
.0196be	a0 00		ldy #$00			ldy 	#0 							; this is overwritten by size of next allocated
.0196c0	91 12		sta ($12),y			sta 	(zTemp2),y 					; array, but we might change that.
.0196c2	c8		iny				iny
.0196c3	b1 14		lda ($14),y			lda 	(zTemp3),y 					; set bit 15 of the max index indicating
.0196c5	09 80		ora #$80			ora 	#$80 						; an array of pointers
.0196c7	91 14		sta ($14),y			sta 	(zTemp3),y
.0196c9	a5 14		lda $14				lda 	zTemp3 						; push the start on the stack
.0196cb	48		pha				pha
.0196cc	a5 15		lda $15				lda 	zTemp3+1
.0196ce	48		pha				pha
.0196cf					_ACCFillLoop:
.0196cf	18		clc				clc
.0196d0	a5 14		lda $14				lda 	zTemp3 						; and work forwards.
.0196d2	69 02		adc #$02			adc 	#2
.0196d4	85 14		sta $14				sta 	zTemp3
.0196d6	90 02		bcc $0196da			bcc 	_ACCSkip2
.0196d8	e6 15		inc $15				inc 	zTemp3+1
.0196da					_ACCSkip2:
.0196da	a0 00		ldy #$00			ldy 	#0 							; reached the end ?
.0196dc	b1 14		lda ($14),y			lda 	(zTemp3),y					; (looking for FF marker, everything else 00)
.0196de	c8		iny				iny
.0196df	11 14		ora ($14),y			ora 	(zTemp3),y
.0196e1	d0 21		bne $019704			bne 	_ACCExit
.0196e3	a5 14		lda $14				lda 	zTemp3 						; push zTemp3
.0196e5	48		pha				pha
.0196e6	a5 15		lda $15				lda 	zTemp3+1
.0196e8	48		pha				pha
.0196e9	e8		inx				inx
.0196ea	e8		inx				inx
.0196eb	20 1c 96	jsr $01961c			jsr 	ArrayCreate 				; create array recursively.
.0196ee	ca		dex				dex
.0196ef	ca		dex				dex
.0196f0	85 12		sta $12				sta 	zTemp2 						; save A
.0196f2	68		pla				pla
.0196f3	85 15		sta $15				sta 	zTemp3+1 					; restore zTemp3
.0196f5	68		pla				pla
.0196f6	85 14		sta $14				sta 	zTemp3
.0196f8	98		tya				tya 								; write high bye from Y
.0196f9	a0 01		ldy #$01			ldy 	#1
.0196fb	91 14		sta ($14),y			sta 	(zTemp3),y
.0196fd	88		dey				dey 								; write low byte out.
.0196fe	a5 12		lda $12				lda 	zTemp2
.019700	91 14		sta ($14),y			sta 	(zTemp3),y
.019702	80 cb		bra $0196cf			bra 	_ACCFillLoop 				; and try again.
.019704					_ACCExit:
.019704	7a		ply				ply 								; restore the original address
.019705	68		pla				pla
.019706	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varfind.asm

.019707					VariableLocate:
.019707	da		phx				phx
.019708	5a		phy				phy
.019709	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.01970c	85 12		sta $12				sta 	zTemp2 						; points to first address.
.01970e	a9 03		lda #$03			lda 	#HashTableBase >> 8
.019710	85 13		sta $13				sta 	zTemp2+1
.019712	a0 00		ldy #$00	_VLNext:ldy 	#0 							; get next link into AX
.019714	b1 12		lda ($12),y			lda 	(zTemp2),y
.019716	aa		tax				tax
.019717	c8		iny				iny
.019718	b1 12		lda ($12),y			lda 	(zTemp2),y
.01971a	85 13		sta $13				sta 	zTemp2+1 					; save in zTemp
.01971c	86 12		stx $12				stx 	zTemp2
.01971e	05 12		ora $12				ora 	zTemp2 						; got zero
.019720	18		clc				clc
.019721	f0 25		beq $019748			beq 	_VLExit 					; if so, then fail as end of chain.
.019723	c8		iny				iny 								; point to hash (offset + 2)
.019724	b1 12		lda ($12),y			lda 	(zTemp2),y
.019726	cd 96 03	cmp $0396			cmp 	Var_Hash
.019729	d0 e7		bne $019712			bne 	_VLNext 					; try next if different.
.01972b					_VLCompare:
.01972b	c8		iny				iny 								; next character
.01972c	b1 12		lda ($12),y			lda 	(zTemp2),y 					; compare variable field against buffer.
.01972e	d9 12 03	cmp $0312,y			cmp 	Var_Buffer-3,y 				; the -3 is because name starts at 3.
.019731	d0 df		bne $019712			bne 	_VLNext 					; fail if different, try next.
.019733	0a		asl a				asl 	a 							; until end character (bit 7 set) matched
.019734	90 f5		bcc $01972b			bcc 	_VLCompare
.019736	98		tya				tya
.019737	38		sec				sec 								; add 1 as Y points to last character
.019738	65 12		adc $12				adc 	zTemp2 						; add to the current address
.01973a	85 22		sta $22				sta 	zVarDataPtr
.01973c	a5 13		lda $13				lda 	zTemp2+1
.01973e	69 00		adc #$00			adc 	#0
.019740	85 23		sta $23				sta 	zVarDataPtr+1
.019742	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.019745	85 24		sta $24				sta 	zVarType
.019747	38		sec				sec 								; return CS
.019748	7a		ply		_VLExit:ply
.019749	fa		plx				plx
.01974a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/vargetset.asm

.01974b					VariableGet:
.01974b	5a		phy				phy
.01974c	a0 00		ldy #$00			ldy 	#0 							; copy first two bytes
.01974e	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019750	95 80		sta $80,x			sta 	XS_Mantissa,x
.019752	c8		iny				iny
.019753	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019755	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019757	c8		iny				iny
.019758	a5 24		lda $24				lda 	zVarType 					; if it is a string, set up for that.
.01975a	c9 b7		cmp #$b7			cmp 	#token_Dollar
.01975c	f0 2c		beq $01978a			beq 	_VGString
.01975e	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; copy the next two bytes.
.019760	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019762	c8		iny				iny
.019763	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019765	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019767	c8		iny				iny
.019768	a9 01		lda #$01			lda 	#1 							; set type to 1.
.01976a	95 85		sta $85,x			sta 	XS_Type,x
.01976c	a5 24		lda $24				lda 	zVarType
.01976e	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if it is a %, then exit with default integer.
.019770	f0 28		beq $01979a			beq 	_VGExit
.019772	a9 40		lda #$40			lda 	#$40 						; set type byte to zero
.019774	95 85		sta $85,x			sta 	XS_Type,x 					; which is the code for zero/float.
.019776	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; the last value to copy is the exponent.
.019778	95 84		sta $84,x			sta 	XS_Exponent,x
.01977a	f0 1e		beq $01979a			beq 	_VGExit 					; if exponent is zero ... it's zero.
.01977c	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; the sign bit is the top mantissa bit.
.01977e	48		pha				pha
.01977f	29 80		and #$80			and 	#$80
.019781	95 85		sta $85,x			sta 	XS_Type,x 					; this is the type byte.
.019783	68		pla				pla
.019784	09 80		ora #$80			ora 	#$80 						; set the MSB as you would expect.
.019786	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; so it's a normalised float.
.019788	80 10		bra $01979a			bra 	_VGExit
.01978a					_VGString:
.01978a	a9 02		lda #$02			lda 	#2 							; set type to 2, a string
.01978c	95 85		sta $85,x			sta 	XS_Type,x
.01978e	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; is the value there $0000
.019790	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019792	d0 06		bne $01979a			bne 	_VGExit 					; if not, exit.
.019794	85 25		sta $25				sta 	zNullString 				; make zNullString a 00 string.
.019796	a9 25		lda #$25			lda 	#zNullString
.019798	95 80		sta $80,x			sta 	XS_Mantissa,x 				; make it point to it.
.01979a					_VGExit:
.01979a	7a		ply				ply
.01979b	60		rts				rts
.01979c					VariableSet:
.01979c	b5 85		lda $85,x			lda 	XS_Type,x 					; is the result a string
.01979e	29 02		and #$02			and 	#2 							; if so, it has to be
.0197a0	d0 4b		bne $0197ed			bne 	_VSString
.0197a2	a5 24		lda $24				lda 	zVarType 					; if type is $ there's an error.
.0197a4	c9 b7		cmp #$b7			cmp 	#token_Dollar
.0197a6	f0 42		beq $0197ea			beq 	_VSBadType
.0197a8	c9 bb		cmp #$bb			cmp 	#token_Percent 				; type convert to float/int
.0197aa	f0 05		beq $0197b1			beq 	_VSMakeInt
.0197ac	20 d5 9c	jsr $019cd5			jsr 	FPUToFloat
.0197af	80 03		bra $0197b4			bra 	_VSCopy
.0197b1					_VSMakeInt:
.0197b1	20 21 9d	jsr $019d21			jsr 	FPUToInteger
.0197b4					_VSCopy:
.0197b4	5a		phy				phy
.0197b5	a0 00		ldy #$00			ldy 	#0 							; copy mantissa to target.
.0197b7	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0197b9	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0197bb	c8		iny				iny
.0197bc	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0197be	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0197c0	c8		iny				iny
.0197c1	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0197c3	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0197c5	c8		iny				iny
.0197c6	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.0197c8	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0197ca	a5 24		lda $24				lda 	zVarType 					; if target is integer, alrady done.
.0197cc	c9 bb		cmp #$bb			cmp 	#token_Percent
.0197ce	f0 18		beq $0197e8			beq 	_VSExit
.0197d0	b5 85		lda $85,x			lda 	XS_Type,x 					; get the sign bit into carry flag.
.0197d2	0a		asl a				asl 	a
.0197d3	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; shift the sign into the mantissa high.
.0197d5	08		php				php
.0197d6	0a		asl a				asl 	a
.0197d7	28		plp				plp
.0197d8	6a		ror a				ror 	a
.0197d9	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0197db	c8		iny				iny
.0197dc	b5 84		lda $84,x			lda 	XS_Exponent,x 				; copy the exponent in
.0197de	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0197e0	34 85		bit $85,x			bit 	XS_Type,x 					; if the result is non zero
.0197e2	50 04		bvc $0197e8			bvc 	_VSExit
.0197e4	a9 00		lda #$00			lda 	#00 						; zero exponent indicating 0.
.0197e6	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0197e8					_VSExit:
.0197e8	7a		ply				ply
.0197e9	60		rts				rts
.0197ea					_VSBadType:
.0197ea	4c ab 84	jmp $0184ab			jmp 	TypeError
.0197ed					_VSString:
.0197ed	a5 24		lda $24				lda 	zVarType 					; type must be $
.0197ef	c9 b7		cmp #$b7			cmp 	#token_Dollar
.0197f1	d0 f7		bne $0197ea			bne 	_VSBadType
.0197f3	da		phx				phx
.0197f4	5a		phy				phy
.0197f5	20 72 93	jsr $019372			jsr 	StringConcrete 				; concrete the string in the mantissa -> AX
.0197f8	a0 01		ldy #$01			ldy 	#1 							; save high byte
.0197fa	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0197fc	88		dey				dey 								; save low byte
.0197fd	8a		txa				txa
.0197fe	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019800	7a		ply				ply 								; and exit.
.019801	fa		plx				plx
.019802	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.019803					MulInteger32:
.019803	b5 80		lda $80,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.019805	95 8c		sta $8c,x			sta 	XS3_Mantissa,x
.019807	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019809	95 8d		sta $8d,x			sta 	XS3_Mantissa+1,x
.01980b	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01980d	95 8e		sta $8e,x			sta 	XS3_Mantissa+2,x
.01980f	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019811	95 8f		sta $8f,x			sta 	XS3_Mantissa+3,x
.019813	a9 00		lda #$00			lda 	#0
.019815	95 80		sta $80,x			sta 	XS_Mantissa+0,x 				; zero +0
.019817	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019819	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01981b	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01981d					_BFMMultiply:
.01981d	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.01981f	29 01		and #$01			and 	#1
.019821	f0 03		beq $019826			beq 	_BFMNoAdd
.019823	20 da 8e	jsr $018eda			jsr 	AddInteger32
.019826					_BFMNoAdd:
.019826	16 86		asl $86,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.019828	36 87		rol $87,x			rol 	XS2_Mantissa+1,x
.01982a	36 88		rol $88,x			rol 	XS2_Mantissa+2,x
.01982c	36 89		rol $89,x			rol 	XS2_Mantissa+3,x
.01982e	56 8f		lsr $8f,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.019830	76 8e		ror $8e,x			ror 	XS3_Mantissa+2,x
.019832	76 8d		ror $8d,x			ror 	XS3_Mantissa+1,x
.019834	76 8c		ror $8c,x			ror 	XS3_Mantissa,x
.019836	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.019838	15 8d		ora $8d,x			ora 	XS3_Mantissa+1,x
.01983a	15 8e		ora $8e,x			ora 	XS3_Mantissa+2,x
.01983c	15 8f		ora $8f,x			ora 	XS3_Mantissa+3,x
.01983e	d0 dd		bne $01981d			bne 	_BFMMultiply
.019840	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.019841					DivInteger32:
.019841	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; check for /0
.019843	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.019845	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.019847	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.019849	d0 14		bne $01985f			bne 	_BFDOkay
.01984b	20 ca 84	jsr $0184ca			jsr ERR_Handler
>01984e	44 69 76 69 73 69 6f 6e			.text "Division by Zero",0
>019856	20 62 79 20 5a 65 72 6f 00
.01985f					_BFDOkay:
.01985f	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.019861	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.019863	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.019865	85 1c		sta $1c				sta 	zLTemp1+2
.019867	85 1d		sta $1d				sta 	zLTemp1+3
.019869	8d 9e 03	sta $039e			sta 	SignCount 					; Count of signs.
.01986c	20 c3 98	jsr $0198c3			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.01986f	da		phx				phx
.019870	e8		inx				inx
.019871	e8		inx				inx
.019872	e8		inx				inx
.019873	e8		inx				inx
.019874	e8		inx				inx
.019875	e8		inx				inx
.019876	20 c3 98	jsr $0198c3			jsr 	CheckIntegerNegate
.019879	fa		plx				plx
.01987a	5a		phy				phy 								; Y is the counter
.01987b	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.01987d					_BFDLoop:
.01987d	16 80		asl $80,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.01987f	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.019881	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.019883	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.019885	26 1a		rol $1a				rol 	zLTemp1
.019887	26 1b		rol $1b				rol 	zLTemp1+1
.019889	26 1c		rol $1c				rol 	zLTemp1+2
.01988b	26 1d		rol $1d				rol 	zLTemp1+3
.01988d	38		sec				sec
.01988e	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.019890	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.019892	48		pha				pha
.019893	a5 1b		lda $1b				lda 	zLTemp1+1
.019895	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.019897	48		pha				pha
.019898	a5 1c		lda $1c				lda 	zLTemp1+2
.01989a	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.01989c	48		pha				pha
.01989d	a5 1d		lda $1d				lda 	zLTemp1+3
.01989f	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.0198a1	90 13		bcc $0198b6			bcc 	_BFDNoAdd
.0198a3	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.0198a5	68		pla				pla
.0198a6	85 1c		sta $1c				sta 	zLTemp1+2
.0198a8	68		pla				pla
.0198a9	85 1b		sta $1b				sta 	zLTemp1+1
.0198ab	68		pla				pla
.0198ac	85 1a		sta $1a				sta 	zLTemp1+0
.0198ae	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.0198b0	09 01		ora #$01			ora 	#1
.0198b2	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0198b4	80 03		bra $0198b9			bra 	_BFDNext
.0198b6					_BFDNoAdd:
.0198b6	68		pla				pla 								; Throw away the intermediate calculations
.0198b7	68		pla				pla
.0198b8	68		pla				pla
.0198b9					_BFDNext:
.0198b9	88		dey				dey
.0198ba	d0 c1		bne $01987d			bne 	_BFDLoop
.0198bc	7a		ply				ply 								; restore Y and exit
.0198bd	4e 9e 03	lsr $039e			lsr 	SignCount 					; if sign count odd,
.0198c0	b0 06		bcs $0198c8			bcs		IntegerNegateAlways 			; negate the result
.0198c2	60		rts				rts
.0198c3					CheckIntegerNegate:
.0198c3	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.0198c5	30 01		bmi $0198c8			bmi 	IntegerNegateAlways
.0198c7	60		rts				rts
.0198c8					IntegerNegateAlways:
.0198c8	ee 9e 03	inc $039e			inc 	SignCount
.0198cb	38		sec				sec
.0198cc	a9 00		lda #$00			lda 	#0
.0198ce	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.0198d0	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0198d2	a9 00		lda #$00			lda 	#0
.0198d4	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.0198d6	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0198d8	a9 00		lda #$00			lda 	#0
.0198da	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.0198dc	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0198de	a9 00		lda #$00			lda 	#0
.0198e0	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.0198e2	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0198e4	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.0198e5					INTToString:
.0198e5	48		pha				pha
.0198e6	5a		phy				phy
.0198e7	b5 83		lda $83,x			lda 		XS_Mantissa+3,x 		; check -ve
.0198e9	10 08		bpl $0198f3			bpl 		_ITSNotMinus
.0198eb	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.0198ed	20 87 99	jsr $019987			jsr 		ITSOutputCharacter
.0198f0	20 c8 98	jsr $0198c8			jsr 		IntegerNegateAlways 	; negate the number.
.0198f3					_ITSNotMinus:
.0198f3	a9 00		lda #$00			lda 		#0
.0198f5	8d 9a 03	sta $039a			sta 		NumSuppress 			; clear the suppression flag.
.0198f8	8a		txa				txa 								; use Y for the mantissa index.
.0198f9	a8		tay				tay
.0198fa	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.0198fc					_ITSNextSubtractor:
.0198fc	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.0198fe	8d 9b 03	sta $039b			sta 		NumConvCount
.019901					_ITSSubtract:
.019901	38		sec				sec
.019902	b9 80 00	lda $0080,y			lda 		XS_Mantissa,y 			; subtract number and push on stack
.019905	ff 63 99 01	sbc $019963,x			sbc 		_ITSSubtractors+0,x
.019909	48		pha				pha
.01990a	b9 81 00	lda $0081,y			lda 		XS_Mantissa+1,y
.01990d	ff 64 99 01	sbc $019964,x			sbc 		_ITSSubtractors+1,x
.019911	48		pha				pha
.019912	b9 82 00	lda $0082,y			lda 		XS_Mantissa+2,y
.019915	ff 65 99 01	sbc $019965,x			sbc 		_ITSSubtractors+2,x
.019919	48		pha				pha
.01991a	b9 83 00	lda $0083,y			lda 		XS_Mantissa+3,y
.01991d	ff 66 99 01	sbc $019966,x			sbc 		_ITSSubtractors+3,x
.019921	90 14		bcc $019937			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.019923	99 83 00	sta $0083,y			sta 		XS_Mantissa+3,y 		; save subtract off stack
.019926	68		pla				pla
.019927	99 82 00	sta $0082,y			sta 		XS_Mantissa+2,y
.01992a	68		pla				pla
.01992b	99 81 00	sta $0081,y			sta 		XS_Mantissa+1,y
.01992e	68		pla				pla
.01992f	99 80 00	sta $0080,y			sta 		XS_Mantissa+0,y
.019932	ee 9b 03	inc $039b			inc 		NumConvCount 			; bump count.
.019935	80 ca		bra $019901			bra 		_ITSSubtract 			; go round again.
.019937					_ITSCantSubtract:
.019937	68		pla				pla 								; throw away interim answers
.019938	68		pla				pla
.019939	68		pla				pla
.01993a	ad 9b 03	lda $039b			lda 		NumConvCount 			; if not zero then no suppression check
.01993d	c9 30		cmp #$30			cmp 		#"0"
.01993f	d0 05		bne $019946			bne 		_ITSOutputDigit
.019941	ad 9a 03	lda $039a			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.019944	10 09		bpl $01994f			bpl	 		_ITSGoNextSubtractor
.019946					_ITSOutputDigit:
.019946	ce 9a 03	dec $039a			dec 		NumSuppress 			; suppression check will be non-zero.
.019949	ad 9b 03	lda $039b			lda 		NumConvCount 			; count of subtractions
.01994c	20 87 99	jsr $019987			jsr 		ITSOutputCharacter 		; output it.
.01994f					_ITSGoNextSubtractor:
.01994f	e8		inx				inx 								; next dword
.019950	e8		inx				inx
.019951	e8		inx				inx
.019952	e8		inx				inx
.019953	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.019955	d0 a5		bne $0198fc			bne 		_ITSNextSubtractor 		; do all the subtractors.
.019957	98		tya				tya 								; X is back as the mantissa index
.019958	aa		tax				tax
.019959	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.01995b	09 30		ora #$30			ora 		#"0"
.01995d	20 87 99	jsr $019987			jsr 		ITSOutputCharacter
.019960	7a		ply				ply 								; and exit
.019961	68		pla				pla
.019962	60		rts				rts
.019963					_ITSSubtractors:
>019963	00 ca 9a 3b					.dword 		1000000000
>019967	00 e1 f5 05					.dword 		100000000
>01996b	80 96 98 00					.dword 		10000000
>01996f	40 42 0f 00					.dword 		1000000
>019973	a0 86 01 00					.dword 		100000
>019977	10 27 00 00					.dword 		10000
>01997b	e8 03 00 00					.dword 		1000
>01997f	64 00 00 00					.dword 		100
>019983	0a 00 00 00					.dword 		10
.019987					_ITSSubtractorsEnd:
.019987					ITSOutputCharacter:
.019987	48		pha				pha
.019988	da		phx				phx
.019989	ae 14 03	ldx $0314			ldx 	NumBufX 					; save digit
.01998c	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.01998f	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.019991	9d 16 03	sta $0316,x			sta 	Num_Buffer+1,x
.019994	ee 14 03	inc $0314			inc 	NumBufX						; bump pointer.
.019997	fa		plx				plx
.019998	68		pla				pla
.019999	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.01999a					IntFromString:
.01999a	a0 00		ldy #$00			ldy 	#0
.01999c	8c 9c 03	sty $039c			sty 	ExpTemp 					; this is the converted digit count.
.01999f					IntFromStringY:
.01999f	48		pha				pha
.0199a0	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.0199a2	95 80		sta $80,x			sta 	XS_Mantissa,x
.0199a4	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0199a6	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0199a8	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0199aa	a9 01		lda #$01			lda 	#1
.0199ac	95 85		sta $85,x			sta 	XS_Type,x
.0199ae					_IFSLoop:
.0199ae	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.0199b0	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.0199b2	90 4e		bcc $019a02			bcc 	_IFSExit
.0199b4	c9 3a		cmp #$3a			cmp 	#"9"+1
.0199b6	b0 4a		bcs $019a02			bcs 	_IFSExit
.0199b8	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.0199ba	c9 0c		cmp #$0c			cmp 	#12
.0199bc	b0 4e		bcs $019a0c			bcs 	_IFSOverflow
.0199be	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.0199c0	48		pha				pha
.0199c1	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0199c3	48		pha				pha
.0199c4	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0199c6	48		pha				pha
.0199c7	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0199c9	48		pha				pha
.0199ca	20 21 9a	jsr $019a21			jsr 	IFSX1ShiftLeft 				; double
.0199cd	20 21 9a	jsr $019a21			jsr 	IFSX1ShiftLeft 				; x 4
.0199d0	18		clc				clc 								; add saved value x 5
.0199d1	68		pla				pla
.0199d2	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.0199d4	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0199d6	68		pla				pla
.0199d7	75 81		adc $81,x			adc 	XS_Mantissa+1,x
.0199d9	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0199db	68		pla				pla
.0199dc	75 82		adc $82,x			adc 	XS_Mantissa+2,x
.0199de	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0199e0	68		pla				pla
.0199e1	75 83		adc $83,x			adc 	XS_Mantissa+3,x
.0199e3	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0199e5	20 21 9a	jsr $019a21			jsr 	IFSX1ShiftLeft 				; x 10
.0199e8	ee 9c 03	inc $039c			inc 	ExpTemp 					; bump count of digits processed.
.0199eb	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.0199ed	29 0f		and #$0f			and 	#15
.0199ef	c8		iny				iny
.0199f0	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.0199f2	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0199f4	90 b8		bcc $0199ae			bcc 	_IFSLoop
.0199f6	f6 81		inc $81,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.0199f8	d0 b4		bne $0199ae			bne 	_IFSLoop
.0199fa	f6 82		inc $82,x			inc 	XS_Mantissa+2,x
.0199fc	d0 b0		bne $0199ae			bne 	_IFSLoop
.0199fe	f6 83		inc $83,x			inc 	XS_Mantissa+3,x
.019a00	80 ac		bra $0199ae			bra 	_IFSLoop
.019a02					_IFSExit:
.019a02	98		tya				tya 								; get offset
.019a03					_IFSOkay:
.019a03	38		sec				sec
.019a04	ad 9c 03	lda $039c			lda 	ExpTemp
.019a07	f0 01		beq $019a0a			beq 	_IFSSkipFail
.019a09	18		clc				clc
.019a0a					_IFSSkipFail:
.019a0a	68		pla				pla 								; and exit.
.019a0b	60		rts				rts
.019a0c					_IFSOverflow:
.019a0c	20 ca 84	jsr $0184ca			jsr 	ERR_Handler
>019a0f	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>019a17	20 6f 76 65 72 66 6c 6f 77 00
.019a21					IFSX1ShiftLeft:
.019a21	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.019a23	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.019a25	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.019a27	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.019a29	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.019a2a					FPSubtract:
.019a2a	48		pha				pha
.019a2b	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.019a2d	49 80		eor #$80			eor 	#$80
.019a2f	95 8b		sta $8b,x			sta 	XS2_Type,x
.019a31	68		pla				pla 								; --- and fall through ---
.019a32					FPAdd:
.019a32	48		pha				pha
.019a33	b5 85		lda $85,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.019a35	d0 05		bne $019a3c			bne 	_FPA_NegativeLHS
.019a37	20 53 9a	jsr $019a53			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.019a3a	68		pla				pla
.019a3b	60		rts				rts
.019a3c					_FPA_NegativeLHS:
.019a3c	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.019a3e	49 80		eor #$80			eor 	#$80
.019a40	95 85		sta $85,x			sta 	XS_Type,x
.019a42	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of B and add
.019a44	49 80		eor #$80			eor 	#$80
.019a46	95 8b		sta $8b,x			sta 	XS2_Type,x
.019a48	20 53 9a	jsr $019a53			jsr 	FPAdd_Worker 				; do the add calculation.
.019a4b	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 back
.019a4d	49 80		eor #$80			eor 	#$80
.019a4f	95 85		sta $85,x			sta 	XS_Type,x
.019a51	68		pla				pla
.019a52	60		rts				rts
.019a53					FPAdd_Worker:
.019a53	34 8b		bit $8b,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.019a55	70 07		bvs $019a5e			bvs 	_FPAWExit 					; no change.
.019a57	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.019a59	50 07		bvc $019a62			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.019a5b	20 93 9c	jsr $019c93			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.019a5e					_FPAWExit:
.019a5e	20 02 9d	jsr $019d02			jsr 	FPUNormalise 				; normalise the result.
.019a61	60		rts				rts
.019a62					_FPAWMakeSame:
.019a62	b5 84		lda $84,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.019a64	38		sec				sec
.019a65	f5 8a		sbc $8a,x			sbc	 	XS2_Exponent,x 				; using subtraction
.019a67	f0 16		beq $019a7f			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.019a69	da		phx				phx 								; save X
.019a6a	90 06		bcc $019a72			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.019a6c	e8		inx				inx
.019a6d	e8		inx				inx
.019a6e	e8		inx				inx
.019a6f	e8		inx				inx
.019a70	e8		inx				inx
.019a71	e8		inx				inx
.019a72					_FPAWShiftA:
.019a72	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.019a74	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.019a76	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.019a78	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.019a7a	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.019a7c	fa		plx				plx 								; restore original X
.019a7d	80 e3		bra $019a62			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.019a7f					_FPAW_DoArithmetic:
.019a7f	34 8b		bit $8b,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.019a81	30 28		bmi $019aab			bmi 	_FPAW_BNegative
.019a83	18		clc				clc
.019a84	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019a86	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.019a88	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019a8a	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019a8c	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.019a8e	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019a90	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019a92	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.019a94	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019a96	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019a98	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.019a9a	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019a9c	90 c0		bcc $019a5e			bcc 	_FPAWExit 					; no carry.
.019a9e	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.019aa0	38		sec				sec
.019aa1	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.019aa3	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.019aa5	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.019aa7	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.019aa9	80 b3		bra $019a5e			bra 	_FPAWExit
.019aab					_FPAW_BNegative:
.019aab	38		sec				sec
.019aac	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019aae	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.019ab0	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019ab2	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019ab4	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.019ab6	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019ab8	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019aba	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.019abc	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019abe	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019ac0	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.019ac2	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019ac4	b0 09		bcs $019acf			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.019ac6	20 b9 9c	jsr $019cb9			jsr 	FPUNegateInteger			; negate the mantissa
.019ac9	b5 85		lda $85,x			lda 	XS_Type,x 					; flip result sign
.019acb	49 80		eor #$80			eor 	#$80
.019acd	95 85		sta $85,x			sta 	XS_Type,x
.019acf					_FPAWGoExit:
.019acf	4c 5e 9a	jmp $019a5e			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.019ad2					FPD_IsDivZero:
.019ad2	20 ca 84	jsr $0184ca			jsr ERR_Handler
>019ad5	44 69 76 69 73 69 6f 6e			.text "Division by zero",0
>019add	20 62 79 20 7a 65 72 6f 00
.019ae6					FPDivide:
.019ae6	48		pha				pha
.019ae7	5a		phy				phy
.019ae8	34 8b		bit $8b,x			bit 	XS2_Type,x 					; check if division by zero
.019aea	70 e6		bvs $019ad2			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.019aec	34 85		bit $85,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.019aee	f0 03		beq $019af3			beq 	_FPDCalculateExp
.019af0					_FPD_Exit:
.019af0	7a		ply				ply
.019af1	68		pla				pla
.019af2	60		rts				rts
.019af3					_FPDCalculateExp:
.019af3	b5 8a		lda $8a,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.019af5	49 ff		eor #$ff			eor 	#$FF
.019af7	1a		inc a				inc 	a
.019af8	95 8a		sta $8a,x			sta 	XS2_Exponent,x
.019afa	20 ca 9b	jsr $019bca			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.019afd	18		clc				clc 	 							; add 1 to the resulting exponent
.019afe	69 01		adc #$01			adc 	#1
.019b00	b0 54		bcs $019b56			bcs 	_FPD_Overflow 				; which can overflow.
.019b02	95 84		sta $84,x			sta 	XS_Exponent,x
.019b04	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.019b06	85 1a		sta $1a				sta 	zLTemp1+0
.019b08	85 1b		sta $1b				sta 	zLTemp1+1
.019b0a	85 1c		sta $1c				sta 	zLTemp1+2
.019b0c	85 1d		sta $1d				sta 	zLTemp1+3
.019b0e	a0 20		ldy #$20			ldy 	#32 						; times round.
.019b10					_FPD_Loop:
.019b10	38		sec				sec 								; calculate X1-X2 stacking result because we might
.019b11	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; not save it.
.019b13	f5 86		sbc $86,x			sbc 	XS2_Mantissa,x
.019b15	48		pha				pha
.019b16	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019b18	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.019b1a	48		pha				pha
.019b1b	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019b1d	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.019b1f	48		pha				pha
.019b20	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019b22	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.019b24	90 13		bcc $019b39			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.019b26	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; save results out to A
.019b28	68		pla				pla
.019b29	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019b2b	68		pla				pla
.019b2c	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019b2e	68		pla				pla
.019b2f	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019b31	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.019b33	09 80		ora #$80			ora 	#$80
.019b35	85 1d		sta $1d				sta 	zLTemp1+3
.019b37	80 03		bra $019b3c			bra 	_FPD_Rotates
.019b39					_FPD_NoSubtract:
.019b39	68		pla				pla 								; throw away unwanted results
.019b3a	68		pla				pla
.019b3b	68		pla				pla
.019b3c					_FPD_Rotates:
.019b3c	56 89		lsr $89,x			lsr 	3+XS2_Mantissa,x
.019b3e	76 88		ror $88,x			ror 	2+XS2_Mantissa,x
.019b40	76 87		ror $87,x			ror 	1+XS2_Mantissa,x
.019b42	76 86		ror $86,x			ror 	0+XS2_Mantissa,x
.019b44	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.019b46	26 1b		rol $1b				rol 	zLTemp1+1
.019b48	26 1c		rol $1c				rol 	zLTemp1+2
.019b4a	26 1d		rol $1d				rol 	zLTemp1+3
.019b4c	90 02		bcc $019b50			bcc 	_FPD_NoCarry
.019b4e	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.019b50					_FPD_NoCarry:
.019b50	88		dey				dey 								; do 32 times
.019b51	d0 bd		bne $019b10			bne 	_FPD_Loop
.019b53	4c ae 9b	jmp $019bae			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.019b56					_FPD_Overflow:
.019b56	4c 5f 9d	jmp $019d5f			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.019b59					FPMultiply:
.019b59	48		pha				pha
.019b5a	5a		phy				phy
.019b5b	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.019b5d	70 07		bvs $019b66			bvs 	_FPM_Exit
.019b5f	34 8b		bit $8b,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.019b61	50 06		bvc $019b69			bvc 	_FPM_CalcExponent
.019b63	20 93 9c	jsr $019c93			jsr 	FPUCopyX2ToX1
.019b66					_FPM_Exit:
.019b66	7a		ply				ply
.019b67	68		pla				pla
.019b68	60		rts				rts
.019b69					_FPM_CalcExponent:
.019b69	18		clc				clc
.019b6a	20 ca 9b	jsr $019bca			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.019b6d	95 84		sta $84,x			sta 	XS_Exponent,x 				; save the result.
.019b6f	a9 00		lda #$00			lda 	#0
.019b71	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.019b73	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.019b75	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.019b77	85 1d		sta $1d				sta 	zLTemp1+3
.019b79	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.019b7b					_FPM_Loop:
.019b7b	b5 80		lda $80,x			lda 	XS_Mantissa,x				; check LSB of long product
.019b7d	29 01		and #$01			and 	#1
.019b7f	18		clc				clc 								; clear carry for the long rotate.
.019b80	f0 19		beq $019b9b			beq 	_FPM_NoAddition
.019b82	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.019b83	a5 1a		lda $1a				lda 	zLTemp1+0
.019b85	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.019b87	85 1a		sta $1a				sta 	zLTemp1+0
.019b89	a5 1b		lda $1b				lda 	zLTemp1+1
.019b8b	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.019b8d	85 1b		sta $1b				sta 	zLTemp1+1
.019b8f	a5 1c		lda $1c				lda 	zLTemp1+2
.019b91	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.019b93	85 1c		sta $1c				sta 	zLTemp1+2
.019b95	a5 1d		lda $1d				lda 	zLTemp1+3
.019b97	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.019b99	85 1d		sta $1d				sta 	zLTemp1+3
.019b9b					_FPM_NoAddition:
.019b9b	66 1d		ror $1d				ror 	3+zLTemp1
.019b9d	66 1c		ror $1c				ror 	2+zLTemp1
.019b9f	66 1b		ror $1b				ror 	1+zLTemp1
.019ba1	66 1a		ror $1a				ror 	0+zLTemp1
.019ba3	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.019ba5	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.019ba7	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.019ba9	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.019bab	88		dey				dey
.019bac	d0 cd		bne $019b7b			bne 	_FPM_Loop 					; do this 32 times.
.019bae					FPM_CopySignNormalize:
.019bae	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.019bb0	95 80		sta $80,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.019bb2	a5 1b		lda $1b				lda 	zLTemp1+1
.019bb4	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019bb6	a5 1c		lda $1c				lda 	zLTemp1+2
.019bb8	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019bba	a5 1d		lda $1d				lda 	zLTemp1+3
.019bbc	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019bbe	b5 85		lda $85,x			lda 	XS_Type,x 					; sign is xor of signs
.019bc0	55 8b		eor $8b,x			eor 	XS2_Type,x
.019bc2	95 85		sta $85,x			sta 	XS_Type,x
.019bc4	20 02 9d	jsr $019d02			jsr 	FPUNormalise 				; normalise and exit.
.019bc7	7a		ply				ply
.019bc8	68		pla				pla
.019bc9	60		rts				rts
.019bca					FPCalculateExponent:
.019bca	18		clc				clc
.019bcb	b5 84		lda $84,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.019bcd	75 8a		adc $8a,x			adc 	XS2_Exponent,x
.019bcf	b0 08		bcs $019bd9			bcs 	_FPCECarry 					; carry out ?
.019bd1	10 03		bpl $019bd6			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.019bd3	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.019bd5	60		rts				rts
.019bd6					_FPCEExpZero:
.019bd6	a9 00		lda #$00			lda 	#0
.019bd8	60		rts				rts
.019bd9					_FPCECarry:
.019bd9	30 03		bmi $019bde			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.019bdb	09 80		ora #$80			ora 	#$80 						; put in right range
.019bdd	60		rts				rts
.019bde					_FPCEOverflow:
.019bde	4c 5f 9d	jmp $019d5f			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.019be1					FPFractionalPart:
.019be1	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.019be3	38		sec				sec 								; this flag tells us to keep the fractional part
.019be4	30 0d		bmi $019bf3			bmi 	FPGetPart
.019be6	60		rts				rts
.019be7					FPIntegerPart:
.019be7	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.019be9	18		clc				clc 								; this flag says keep the integer part.
.019bea	30 07		bmi $019bf3			bmi 	FPGetPart 					; -ve exponents are 0..127
.019bec	48		pha				pha
.019bed	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.019bef	95 85		sta $85,x			sta 	XS_Type,x
.019bf1	68		pla				pla
.019bf2	60		rts				rts
.019bf3					FPGetPart:
.019bf3	48		pha				pha
.019bf4	5a		phy				phy 								; save Y
.019bf5	08		php				php 								; save action
.019bf6	34 85		bit $85,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.019bf8	70 59		bvs $019c53			bvs 	_FPGP_Exit 					; then do nothing.
.019bfa	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.019bfc	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.019bfe	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.019c00	85 1c		sta $1c				sta 	zLTemp1+2
.019c02	85 1d		sta $1d				sta 	zLTemp1+3
.019c04	b5 84		lda $84,x			lda 	XS_Exponent,x				; the number of shifts.
.019c06	38		sec				sec
.019c07	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.019c09	f0 12		beq $019c1d			beq 	_FPGP_NoShift 				; ... if any
.019c0b	c9 20		cmp #$20			cmp 	#32
.019c0d	90 02		bcc $019c11			bcc 	_FPGP_NotMax
.019c0f	a9 20		lda #$20			lda 	#32 						; max of 32.
.019c11					_FPGP_NotMax:
.019c11	a8		tay				tay 								; Y is the mask shift count.
.019c12					_FPGP_ShiftMask:
.019c12	46 1d		lsr $1d				lsr 	3+zLTemp1
.019c14	66 1c		ror $1c				ror 	2+zLTemp1
.019c16	66 1b		ror $1b				ror 	1+zLTemp1
.019c18	66 1a		ror $1a				ror 	0+zLTemp1
.019c1a	88		dey				dey
.019c1b	d0 f5		bne $019c12			bne 	_FPGP_ShiftMask
.019c1d					_FPGP_NoShift:
.019c1d	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.019c1f	8e 9c 03	stx $039c			stx 	ExpTemp						; save X
.019c22					_FPGP_MaskLoop:
.019c22	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.019c25	28		plp				plp 								; if CC we keep the top part, so we
.019c26	08		php				php		 							; flip the mask.
.019c27	b0 02		bcs $019c2b			bcs		_FPGP_NoFlip
.019c29	49 ff		eor #$ff			eor 	#$FF
.019c2b					_FPGP_NoFlip:
.019c2b	35 80		and $80,x			and 	XS_Mantissa,x 				; and into the mantissa.
.019c2d	95 80		sta $80,x			sta 	XS_Mantissa,x
.019c2f	e8		inx				inx
.019c30	c8		iny				iny
.019c31	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.019c33	d0 ed		bne $019c22			bne 	_FPGP_MaskLoop
.019c35	ae 9c 03	ldx $039c			ldx 	ExpTemp						; restore X
.019c38	28		plp				plp
.019c39	08		php				php 								; get action flag on the stack
.019c3a	90 04		bcc $019c40			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.019c3c	a9 00		lda #$00			lda 	#0
.019c3e	95 85		sta $85,x			sta 	XS_Type,x
.019c40					_FPGP_NotFractional:
.019c40	b5 80		lda $80,x			lda 	XS_Mantissa,x 						; check if \1 zero
.019c42	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019c44	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019c46	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019c48	f0 05		beq $019c4f			beq 	_FPGP_Zero 					; if zero, return zero
.019c4a	20 02 9d	jsr $019d02			jsr 	FPUNormalise
.019c4d	80 04		bra $019c53			bra 	_FPGP_Exit 					; and exit
.019c4f					_FPGP_Zero:
.019c4f	a9 40		lda #$40			lda 	#$40 						; set zero flag
.019c51	95 85		sta $85,x			sta 	XS_Type,x
.019c53					_FPGP_Exit:
.019c53	68		pla				pla 								; throw saved action flag.
.019c54	7a		ply				ply
.019c55	68		pla				pla
.019c56	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.019c57					FPCompare:
.019c57	b5 84		lda $84,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.019c59	48		pha				pha
.019c5a	b5 8a		lda $8a,x			lda 	XS2_Exponent,x
.019c5c	48		pha				pha
.019c5d	20 2a 9a	jsr $019a2a			jsr 	FPSubtract 					; calculate X1-X2
.019c60	34 85		bit $85,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.019c62	70 2a		bvs $019c8e			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.019c64	68		pla				pla
.019c65	8d 9c 03	sta $039c			sta 	ExpTemp						; save first exponent in temporary reg.
.019c68	68		pla				pla
.019c69	38		sec				sec
.019c6a	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; calculate AX-BX
.019c6d	70 14		bvs $019c83			bvs 	_FPCNotEqual				; overflow, can't be equal.
.019c6f	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.019c70	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.019c72	b0 0f		bcs $019c83			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.019c74	38		sec				sec
.019c75	ad 9c 03	lda $039c			lda 	ExpTemp 					; get one of the exponents back.
.019c78	e9 12		sbc #$12			sbc 	#18 						; allow for 2^18 error, relatively.
.019c7a	b0 02		bcs $019c7e			bcs 	_FPCNotRange 				; keep in range.
.019c7c	a9 01		lda #$01			lda 	#1
.019c7e					_FPCNotRange:
.019c7e	38		sec				sec
.019c7f	f5 84		sbc $84,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.019c81	b0 0d		bcs $019c90			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.019c83					_FPCNotEqual:
.019c83	b5 85		lda $85,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.019c85	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.019c87	f0 02		beq $019c8b			beq 	_FPCNE2
.019c89	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.019c8b	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.019c8c	80 04		bra $019c92			bra 	_FPCExit
.019c8e					_FPCPullZero:
.019c8e	68		pla				pla 								; throw saved exponents
.019c8f	68		pla				pla
.019c90					_FPCZero:
.019c90	a9 00		lda #$00			lda 	#0 							; and return zero
.019c92					_FPCExit:
.019c92	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.019c93					FPUCopyX2ToX1:
.019c93	48		pha				pha
.019c94	da		phx				phx
.019c95	5a		phy				phy
.019c96	a0 08		ldy #$08			ldy 	#8
.019c98	b5 86		lda $86,x	_FPUC21:lda 	XS2_Mantissa,x
.019c9a	95 80		sta $80,x			sta 	XS_Mantissa,x
.019c9c	e8		inx				inx
.019c9d	88		dey				dey
.019c9e	10 f8		bpl $019c98			bpl 	_FPUC21
.019ca0	7a		ply				ply
.019ca1	fa		plx				plx
.019ca2	68		pla				pla
.019ca3	60		rts				rts
.019ca4					FPUSetInteger:
.019ca4	48		pha				pha
.019ca5	95 80		sta $80,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.019ca7	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.019ca9	10 02		bpl $019cad			bpl 	_FPUSIExtend
.019cab	a9 ff		lda #$ff			lda 	#$FF
.019cad					_FPUSIExtend:
.019cad	95 81		sta $81,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.019caf	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019cb1	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019cb3	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.019cb5	95 85		sta $85,x			sta 	XS_Type,x
.019cb7	68		pla				pla
.019cb8	60		rts				rts
.019cb9					FPUNegateInteger:
.019cb9	48		pha				pha
.019cba	38		sec				sec
.019cbb	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.019cbd	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.019cbf	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019cc1	a9 00		lda #$00			lda 	#0
.019cc3	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.019cc5	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019cc7	a9 00		lda #$00			lda 	#0
.019cc9	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.019ccb	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019ccd	a9 00		lda #$00			lda 	#0
.019ccf	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.019cd1	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019cd3	68		pla				pla
.019cd4	60		rts				rts
.019cd5					FPUToFloat:
.019cd5	48		pha				pha
.019cd6	b5 85		lda $85,x			lda 	XS_Type,x					; exit if already float.
.019cd8	29 0f		and #$0f			and 	#$0F
.019cda	f0 24		beq $019d00			beq 	_FPUFExit
.019cdc	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.019cde	95 85		sta $85,x			sta 	XS_Type,x
.019ce0	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.019ce2	95 84		sta $84,x			sta 	XS_Exponent,x 				; x mantissa.
.019ce4	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.019ce6	10 07		bpl $019cef			bpl		_FPUFPositive
.019ce8	20 b9 9c	jsr $019cb9			jsr 	FPUNegateInteger 			; negate the mantissa
.019ceb	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.019ced	95 85		sta $85,x			sta 	XS_Type,x
.019cef					_FPUFPositive:
.019cef	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.019cf1	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019cf3	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019cf5	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019cf7	d0 04		bne $019cfd			bne 	_FPUFNonZero
.019cf9	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.019cfb	95 85		sta $85,x			sta 	XS_Type,x
.019cfd					_FPUFNonZero:
.019cfd	20 02 9d	jsr $019d02			jsr 	FPUNormalise 				; normalise the floating point.
.019d00					_FPUFExit:
.019d00	68		pla				pla
.019d01	60		rts				rts
.019d02					FPUNormalise:
.019d02	48		pha				pha
.019d03	34 85		bit $85,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.019d05	70 18		bvs $019d1f			bvs 	_FPUNExit
.019d07	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.019d09	f0 10		beq $019d1b			beq 	_FPUNSetZero
.019d0b					_FPUNLoop:
.019d0b	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.019d0d	30 10		bmi $019d1f			bmi 	_FPUNExit 					; if so, we are normalised.
.019d0f	16 80		asl $80,x			asl 	0+XS_Mantissa+0,x
.019d11	36 81		rol $81,x			rol 	1+XS_Mantissa+0,x
.019d13	36 82		rol $82,x			rol 	2+XS_Mantissa+0,x
.019d15	36 83		rol $83,x			rol 	3+XS_Mantissa+0,x
.019d17	d6 84		dec $84,x			dec 	XS_Exponent,x 				; decrement exponent
.019d19	d0 f0		bne $019d0b			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.019d1b					_FPUNSetZero:
.019d1b	a9 40		lda #$40			lda 	#$40
.019d1d	95 85		sta $85,x			sta 	XS_Type,x 					; the result is now zero.
.019d1f					_FPUNExit:
.019d1f	68		pla				pla
.019d20	60		rts				rts
.019d21					FPUToInteger:
.019d21	48		pha				pha
.019d22	b5 85		lda $85,x			lda 	XS_Type,x 					; if already integer, exit
.019d24	29 01		and #$01			and 	#1
.019d26	d0 31		bne $019d59			bne 	_FPUTOI_Exit
.019d28	34 85		bit $85,x			bit 	XS_Type,x					; if zero, return zero.
.019d2a	70 23		bvs $019d4f			bvs 	_FPUTOI_Zero
.019d2c	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.019d2e	10 1f		bpl $019d4f			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.019d30	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.019d32	b0 2b		bcs $019d5f			bcs 	FP_Overflow
.019d34					_FPUToIToInteger:
.019d34	b5 84		lda $84,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.019d36	c9 a0		cmp #$a0			cmp 	#128+32
.019d38	f0 0c		beq $019d46			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.019d3a	f6 84		inc $84,x			inc 	XS_Exponent,X 				; increment Exponent
.019d3c	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.019d3e	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.019d40	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.019d42	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.019d44	80 ee		bra $019d34			bra 	_FPUToIToInteger 			; keep going.
.019d46					_FPUToICheckSign:
.019d46	b5 85		lda $85,x			lda 	XS_Type,x 					; check sign
.019d48	10 0f		bpl $019d59			bpl 	_FPUToI_Exit 				; exit if unsigned.
.019d4a	20 b9 9c	jsr $019cb9			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.019d4d	80 0a		bra $019d59			bra 	_FPUTOI_Exit
.019d4f					_FPUTOI_Zero:
.019d4f	a9 00		lda #$00			lda 	#0 							; return zero integer.
.019d51	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019d53	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019d55	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019d57	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019d59					_FPUToI_Exit:
.019d59	a9 01		lda #$01			lda 	#1 							; set type to integer
.019d5b	95 85		sta $85,x			sta 	XS_Type,x
.019d5d	68		pla				pla
.019d5e	60		rts				rts
.019d5f					FP_Overflow:
.019d5f	20 ca 84	jsr $0184ca			jsr ERR_Handler
>019d62	46 6c 6f 61 74 69 6e 67			.text "Floating Point overflow",0
>019d6a	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.019d7a					FPUTimes10:
.019d7a	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.019d7c	85 1a		sta $1a				sta 	ZLTemp1+0
.019d7e	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019d80	85 1b		sta $1b				sta 	ZLTemp1+1
.019d82	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019d84	85 1c		sta $1c				sta 	ZLTemp1+2
.019d86	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019d88	85 1d		sta $1d				sta 	ZLTemp1+3
.019d8a	20 bf 9d	jsr $019dbf			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.019d8d	20 bf 9d	jsr $019dbf			jsr 	_FPUT_LSR_ZLTemp1
.019d90	18		clc				clc
.019d91	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.019d93	65 1a		adc $1a				adc 	ZLTemp1+0
.019d95	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019d97	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019d99	65 1b		adc $1b				adc 	ZLTemp1+1
.019d9b	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019d9d	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019d9f	65 1c		adc $1c				adc 	ZLTemp1+2
.019da1	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019da3	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019da5	65 1d		adc $1d				adc 	ZLTemp1+3
.019da7	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019da9	90 0a		bcc $019db5			bcc 	_FPUTimes10
.019dab	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.019dad	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.019daf	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.019db1	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.019db3	f6 84		inc $84,x			inc 	XS_Exponent,x				; fix exponent
.019db5					_FPUTimes10:
.019db5	b5 84		lda $84,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.019db7	18		clc				clc
.019db8	69 03		adc #$03			adc 	#3
.019dba	95 84		sta $84,x			sta 	XS_Exponent,x
.019dbc	b0 a1		bcs $019d5f			bcs 	FP_Overflow 				; error
.019dbe	60		rts				rts
.019dbf					_FPUT_LSR_ZLTemp1:
.019dbf	46 1d		lsr $1d				lsr 	ZLTemp1+3
.019dc1	66 1c		ror $1c				ror 	ZLTemp1+2
.019dc3	66 1b		ror $1b				ror 	ZLTemp1+1
.019dc5	66 1a		ror $1a				ror 	ZLTemp1+0
.019dc7	60		rts				rts
.019dc8					FPUScale10A:
.019dc8	5a		phy				phy
.019dc9	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.019dcb	f0 37		beq $019e04			beq 	_FPUScaleExit
.019dcd	da		phx				phx 								; save X
.019dce	e8		inx				inx
.019dcf	e8		inx				inx
.019dd0	e8		inx				inx
.019dd1	e8		inx				inx
.019dd2	e8		inx				inx
.019dd3	e8		inx				inx
.019dd4	a8		tay				tay 								; save power scalar in Y.
.019dd5	a9 00		lda #$00			lda 	#0
.019dd7	95 80		sta $80,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.019dd9	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019ddb	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019ddd	95 85		sta $85,x			sta 	XS_Type,x
.019ddf	a9 80		lda #$80			lda 	#$80
.019de1	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019de3	a9 81		lda #$81			lda 	#$81
.019de5	95 84		sta $84,x			sta 	XS_Exponent,x
.019de7	5a		phy				phy 								; save 10^n on stack.
.019de8	c0 00		cpy #$00			cpy 	#0
.019dea	10 05		bpl $019df1			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.019dec	98		tya				tya
.019ded	49 ff		eor #$ff			eor 	#$FF
.019def	1a		inc a				inc 	a
.019df0	a8		tay				tay
.019df1					_FPUSAbs:
.019df1	20 7a 9d	jsr $019d7a			jsr 	FPUTimes10
.019df4	88		dey				dey
.019df5	d0 fa		bne $019df1			bne 	_FPUSAbs 					; tos is now 10^|AC|
.019df7	68		pla				pla 								; restore count in A
.019df8	fa		plx				plx 								; restore X pointing to number to scale.
.019df9	0a		asl a				asl 	a
.019dfa	b0 05		bcs $019e01			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.019dfc	20 59 9b	jsr $019b59			jsr 	FPMultiply 					; if clear multiply.
.019dff	80 03		bra $019e04			bra		_FPUScaleExit
.019e01					_FPUSDivide:
.019e01	20 e6 9a	jsr $019ae6			jsr 	FPDivide
.019e04					_FPUScaleExit:
.019e04	7a		ply				ply
.019e05	60		rts				rts
.019e06					FPUCopyToNext:
.019e06	a0 06		ldy #$06			ldy 		#6
.019e08	da		phx				phx
.019e09					_FPUCopy1:
.019e09	b5 80		lda $80,x			lda 	XS_Mantissa,x
.019e0b	95 86		sta $86,x			sta 	XS2_Mantissa,x
.019e0d	e8		inx				inx
.019e0e	88		dey				dey
.019e0f	d0 f8		bne $019e09			bne 	_FPUCopy1
.019e11	fa		plx				plx
.019e12	60		rts				rts
.019e13					FPUCopyFromNext:
.019e13	a0 06		ldy #$06			ldy 		#6
.019e15	da		phx				phx
.019e16					_FPUCopy1:
.019e16	b5 86		lda $86,x			lda 	XS2_Mantissa,x
.019e18	95 80		sta $80,x			sta 	XS_Mantissa,x
.019e1a	e8		inx				inx
.019e1b	88		dey				dey
.019e1c	d0 f8		bne $019e16			bne 	_FPUCopy1
.019e1e	fa		plx				plx
.019e1f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.019e20					FPToString:
.019e20	48		pha				pha
.019e21	5a		phy				phy
.019e22	34 85		bit $85,x			bit 		XS_Type,x 				; check zero flag
.019e24	50 0a		bvc $019e30			bvc 		_FPTSIsFloat 			; if zero,
.019e26					_FPTSZero:
.019e26	a9 30		lda #$30			lda 		#"0"
.019e28	20 87 99	jsr $019987			jsr 		ITSOutputCharacter
.019e2b					_FPTSExit:
.019e2b	7a		ply				ply
.019e2c	68		pla				pla
.019e2d	60		rts				rts
.019e2e	80 fb		bra $019e2b			bra 		_FPTSExit
.019e30					_FPTSIsFloat:
.019e30	b5 85		lda $85,x			lda 		XS_Type,x 				; is it signed ?
.019e32	10 09		bpl $019e3d			bpl 		_FPTSNotSigned
.019e34	a9 00		lda #$00			lda 		#0 						; clear sign flag
.019e36	95 85		sta $85,x			sta 		XS_Type,x
.019e38	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.019e3a	20 87 99	jsr $019987			jsr 		ITSOutputCharacter
.019e3d					_FPTSNotSigned:
.019e3d	b5 84		lda $84,x			lda 		XS_Exponent,x
.019e3f	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.019e41	b0 09		bcs $019e4c			bcs 		_FPTSExponent
.019e43	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.019e45	90 05		bcc $019e4c			bcc 		_FPTSExponent 			;
.019e47					_FPTSStandard:
.019e47	20 8b 9e	jsr $019e8b			jsr 		FPTOutputBody 			; output the body.
.019e4a	80 df		bra $019e2b			bra 		_FPTSExit
.019e4c					_FPTSExponent:
.019e4c	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.019e4e	8d 9d 03	sta $039d			sta 		ExpCount
.019e51					_FPTSExponentLoop:
.019e51	b5 84		lda $84,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.019e53	10 0e		bpl $019e63			bpl 		_FPTSTimes
.019e55	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.019e57	90 14		bcc $019e6d			bcc 		_FPTSScaledToExp
.019e59	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.019e5b	20 c8 9d	jsr $019dc8			jsr 		FPUScale10A
.019e5e	ee 9d 03	inc $039d			inc 		ExpCount
.019e61	80 ee		bra $019e51			bra 		_FPTSExponentLoop
.019e63					_FPTSTimes:
.019e63	a9 01		lda #$01			lda 		#1
.019e65	20 c8 9d	jsr $019dc8			jsr 		FPUScale10A
.019e68	ce 9d 03	dec $039d			dec 		ExpCount
.019e6b	80 e4		bra $019e51			bra 		_FPTSExponentLoop
.019e6d					_FPTSScaledToExp:
.019e6d	20 8b 9e	jsr $019e8b			jsr 		FPTOutputBody 			; output the body.
.019e70	a9 65		lda #$65			lda 		#"e"					; output E
.019e72	20 87 99	jsr $019987			jsr 		ITSOutputCharacter
.019e75	ad 9d 03	lda $039d			lda 		ExpCount 				; get the exponent
.019e78	95 80		sta $80,x			sta 		XS_Mantissa,x
.019e7a	29 80		and #$80			and 		#$80 					; sign extend it
.019e7c	f0 02		beq $019e80			beq 		_FPTSSExt
.019e7e	a9 ff		lda #$ff			lda 		#$FF
.019e80					_FPTSSExt:
.019e80	95 81		sta $81,x			sta 		XS_Mantissa+1,x
.019e82	95 82		sta $82,x			sta 		XS_Mantissa+2,x
.019e84	95 83		sta $83,x			sta 		XS_Mantissa+3,x
.019e86	20 e5 98	jsr $0198e5			jsr 		INTToString 			; output the exponent.
.019e89	80 a0		bra $019e2b			bra			_FPTSExit 				; and exit.
.019e8b					FPTOutputBody:
.019e8b	20 06 9e	jsr $019e06			jsr 		FPUCopyToNext 			; copy to next slot.
.019e8e	20 21 9d	jsr $019d21			jsr 		FPUToInteger 			; convert to an integer
.019e91	20 e5 98	jsr $0198e5			jsr 		INTToString 			; output the main integer part.
.019e94	20 13 9e	jsr $019e13			jsr 		FPUCopyFromNext 		; get the fractional part back.
.019e97	20 e1 9b	jsr $019be1			jsr 		FPFractionalPart 		; get the decimal part.
.019e9a	34 85		bit $85,x			bit 		XS_Type,x 				; any fractional part.
.019e9c	70 3c		bvs $019eda			bvs 		_FPTOExit 				; if not, exit now.
.019e9e	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.019ea0	20 87 99	jsr $019987			jsr 		ITSOutputCharacter
.019ea3					_FPOutLoop:
.019ea3	34 85		bit $85,x			bit 		XS_Type,x 				; finally reached zero.
.019ea5	70 1d		bvs $019ec4			bvs 		_FPStripZeros 			; strip trailing zeros
.019ea7	20 7a 9d	jsr $019d7a			jsr 		FPUTimes10 				; multiply by 10
.019eaa	20 06 9e	jsr $019e06			jsr 		FPUCopyToNext			; copy to next slot.
.019ead	20 21 9d	jsr $019d21			jsr 		FPUToInteger 			; convert to integer
.019eb0	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; print digit.
.019eb2	09 30		ora #$30			ora 		#"0"
.019eb4	20 87 99	jsr $019987			jsr 		ITSOutputCharacter
.019eb7	20 13 9e	jsr $019e13			jsr 		FPUCopyFromNext 		; get it back
.019eba	20 e1 9b	jsr $019be1			jsr 		FPFractionalPart 		; get fractional part
.019ebd	ad 14 03	lda $0314			lda 		NumBufX 				; done 11 characters yet ?
.019ec0	c9 0b		cmp #$0b			cmp 	 	#11
.019ec2	90 df		bcc $019ea3			bcc 		_FPOutLoop 				; if so, keep going till zero.
.019ec4					_FPStripZeros:
.019ec4	ac 14 03	ldy $0314			ldy 		NumBufX 				; strip trailing zeros.
.019ec7					_FPStripLoop:
.019ec7	88		dey				dey 								; back one, if at start then no strip
.019ec8	f0 10		beq $019eda			beq 		_FPToExit
.019eca	b9 15 03	lda $0315,y			lda 		Num_Buffer,y 			; keep going if "0"
.019ecd	c9 30		cmp #$30			cmp 		#"0"
.019ecf	f0 f6		beq $019ec7			beq 		_FPStripLoop
.019ed1	c8		iny				iny
.019ed2	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.019ed4	99 15 03	sta $0315,y			sta 		Num_Buffer,y
.019ed7	8c 14 03	sty $0314			sty 		NumBufX 				; update position.
.019eda					_FPTOExit:
.019eda	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.019edb					FPFromString:
.019edb	48		pha				pha 								; push A
.019edc	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.019ede	c9 2e		cmp #$2e			cmp 	#"."
.019ee0	f0 03		beq $019ee5			beq	 	_FPFIsDecimal
.019ee2	4c 41 9f	jmp $019f41			jmp 	_FPFNotDecimal
.019ee5					_FPFIsDecimal:
.019ee5	c8		iny				iny 								; consume the decimal.
.019ee6	20 d5 9c	jsr $019cd5			jsr 	FPUToFloat 					; convert the integer to float.
.019ee9	da		phx				phx 								; save X.
.019eea	5a		phy				phy 								; save decimal start position
.019eeb	e8		inx				inx
.019eec	e8		inx				inx
.019eed	e8		inx				inx
.019eee	e8		inx				inx
.019eef	e8		inx				inx
.019ef0	e8		inx				inx
.019ef1	20 9f 99	jsr $01999f			jsr 	INTFromStringY 				; get the part after the DP.
.019ef4	20 d5 9c	jsr $019cd5			jsr 	FPUToFloat 					; convert that to a float.
.019ef7	68		pla				pla 								; calculate - chars consumed.
.019ef8	8c 9c 03	sty $039c			sty 	ExpTemp
.019efb	38		sec				sec
.019efc	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; this is the shift amount
.019eff	20 c8 9d	jsr $019dc8			jsr 	FPUScale10A 				; scale it by 10^AC
.019f02	fa		plx				plx 								; restore original X
.019f03	20 32 9a	jsr $019a32			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.019f06	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.019f08	c9 45		cmp #$45			cmp 	#"E"
.019f0a	f0 04		beq $019f10			beq 	_FPFExponent
.019f0c	c9 65		cmp #$65			cmp 	#"e"
.019f0e	d0 31		bne $019f41			bne 	_FPFNotDecimal 				; no, then exit normally.
.019f10					_FPFExponent:
.019f10	c8		iny				iny 								; skip over E symbol.
.019f11	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.019f13	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.019f15	d0 01		bne $019f18			bne 	_FPFGotSign
.019f17	c8		iny				iny 								; if it was - skip over it.
.019f18					_FPFGotSign:
.019f18	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.019f19	da		phx				phx
.019f1a	e8		inx				inx
.019f1b	e8		inx				inx
.019f1c	e8		inx				inx
.019f1d	e8		inx				inx
.019f1e	e8		inx				inx
.019f1f	e8		inx				inx
.019f20	20 9f 99	jsr $01999f			jsr 	INTFromStringY 				; get the exponent
.019f23	fa		plx				plx 								; restore X.
.019f24	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.019f26	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.019f28	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.019f2a	d0 17		bne $019f43			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.019f2c	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.019f2e	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.019f30	b0 11		bcs $019f43			bcs 	_FPFXOverflow
.019f32	68		pla				pla 								; get direction
.019f33	d0 07		bne $019f3c			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.019f35	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.019f37	49 ff		eor #$ff			eor 	#$FF
.019f39	1a		inc a				inc 	a
.019f3a	95 86		sta $86,x			sta 	XS2_Mantissa+0,x
.019f3c					_FPFXScale:
.019f3c	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.019f3e	20 c8 9d	jsr $019dc8			jsr 	FPUScale10A 				; scale by the exponent.
.019f41					_FPFNotDecimal:
.019f41	68		pla				pla
.019f42	60		rts				rts
.019f43					_FPFXOverflow:
.019f43	20 ca 84	jsr $0184ca			jsr 	ERR_Handler
>019f46	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>019f4e	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.019f55					Unary_Rnd:
.019f55	20 2e 8d	jsr $018d2e			jsr 	EvaluateNumberX 			; get value
.019f58	20 62 93	jsr $019362			jsr 	CheckNextRParen 			; check right bracket.
.019f5b	20 ac 8f	jsr $018fac			jsr 	GetSignCurrent 				; get sign -1,0,1.
.019f5e	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.019f60	30 10		bmi $019f72			bmi 	_URSetSeed
.019f62	f0 28		beq $019f8c			beq 	_URMakeRandom 				; if zero return same number.
.019f64	da		phx				phx
.019f65	a2 00		ldx #$00			ldx 	#0
.019f67	20 c3 9f	jsr $019fc3			jsr 	Random16
.019f6a	a2 02		ldx #$02			ldx 	#2
.019f6c	20 c3 9f	jsr $019fc3			jsr 	Random16
.019f6f	fa		plx				plx
.019f70	80 1a		bra $019f8c			bra 	_URMakeRandom
.019f72					_URSetSeed:
.019f72	20 d5 9c	jsr $019cd5			jsr 	FPUToFloat 					; make it a float to twiddle it.
.019f75	b5 80		lda $80,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.019f77	8d a3 03	sta $03a3			sta 	RandomSeed+0
.019f7a	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.019f7c	8d a4 03	sta $03a4			sta 	RandomSeed+1
.019f7f	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.019f81	8d a5 03	sta $03a5			sta 	RandomSeed+2
.019f84	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.019f86	0a		asl a				asl 	a
.019f87	49 db		eor #$db			eor 	#$DB
.019f89	8d a6 03	sta $03a6			sta 	RandomSeed+3
.019f8c					_URMakeRandom:
.019f8c	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; check if seed is zero.
.019f8f	0d a4 03	ora $03a4			ora 	RandomSeed+1
.019f92	0d a5 03	ora $03a5			ora 	RandomSeed+2
.019f95	0d a6 03	ora $03a6			ora 	RandomSeed+3
.019f98	d0 0a		bne $019fa4			bne 	_URNotZero
.019f9a	a9 47		lda #$47			lda 	#$47
.019f9c	8d a4 03	sta $03a4			sta 	RandomSeed+1				; if it is, make it non zero.
.019f9f	a9 3d		lda #$3d			lda 	#$3D
.019fa1	8d a6 03	sta $03a6			sta 	RandomSeed+3
.019fa4					_URNotZero:
.019fa4	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; copy seed into mantissa.
.019fa7	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019fa9	ad a4 03	lda $03a4			lda 	RandomSeed+1
.019fac	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019fae	ad a5 03	lda $03a5			lda 	RandomSeed+2
.019fb1	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019fb3	ad a6 03	lda $03a6			lda 	RandomSeed+3
.019fb6	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019fb8	a9 00		lda #$00			lda 	#$00 						; set type to float.
.019fba	95 85		sta $85,x			sta 	XS_Type,x
.019fbc	a9 80		lda #$80			lda 	#$80
.019fbe	95 84		sta $84,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.019fc0	4c 02 9d	jmp $019d02			jmp 	FPUNormalise
.019fc3					Random16:
.019fc3	5e a4 03	lsr $03a4,x			lsr 	RandomSeed+1,x				; shift seed right
.019fc6	7e a3 03	ror $03a3,x			ror 	RandomSeed,x
.019fc9	90 08		bcc $019fd3			bcc 	_R16_NoXor
.019fcb	bd a4 03	lda $03a4,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.019fce	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.019fd0	9d a4 03	sta $03a4,x			sta 	RandomSeed+1,x
.019fd3					_R16_NoXor:
.019fd3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.019fd4					Unary_Int:
.019fd4	20 2e 8d	jsr $018d2e			jsr 	EvaluateNumberX 			; get value
.019fd7	20 62 93	jsr $019362			jsr 	CheckNextRParen 			; check right bracket.
.019fda	4c 21 9d	jmp $019d21			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Return to file: basic.asm

>019fdd	02						.byte 	2
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 c0						.word 	StartROM
>fffe	19 c0					.word TIM_BreakHandler

;******  End of listing
