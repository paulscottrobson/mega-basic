
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Thu Aug 29 15:54:58 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="4510"					cpu = "4510"
="mega65"				hardware = "mega65"
=1					exitonend = 1
=0					autorun = 0
=1					loadtest = 1
=1					hasfloat = 1
=1					hasinteger = 1
=253					maxstring = 253

;******  Processing file: modules/float/fpmacros.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/mega65/src_mega65.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stackmarkers.inc

=5					SourcePosSize   =   5 							; Source position stack space needed.
=0					SMark_Gosub 	= 	0 							; 0 is GOSUB/RETURN.
=1					SMark_Repeat 	= 	1 							; 1 is REPEAT/UNTIL.
=2					SMark_While 	= 	2 							; 2 is WHILE/WEND.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0020					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0022					zVarDataPtr: .word ? 						; position of variable data.
>0024					zVarType: 	.byte ? 						; type of data (token)
>0025					zNullString:.byte ? 						; represents a NULL string.
>0026					zBasicSP:	.word ? 						; stack pointer
>0080					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>0084					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>0085					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=134					XS2_Mantissa = XS_Mantissa+XS_Size
=138					XS2_Exponent = XS_Exponent+XS_Size
=139					XS2_Type = XS_Type+XS_Size
=140					XS3_Mantissa = XS_Mantissa+XS_Size*2
=144					XS3_Exponent = XS_Exponent+XS_Size*2
=145					XS3_Type = XS_Type+XS_Size*2
>0300					StringPtr:	.word ? 						; Top of free memory (for string allocation)
>0302					VarMemPtr: 	.word ?							; Bottom of free memory (for variables)
>0304					endOfProgram: .dword ? 						; End of Program Memory (long)
>0308					vecPrintCharacter .word ?
>030a					vecInputCharacter .word ?
>030c					UserVector .fill 4 							; USR(x) calls this.
>0310					LocalVector .fill 4 						; Indirect calls call this.
>0314					NumBufX 	.byte 	?						; buffer index position
>0315					Num_Buffer	.fill 	32 						; buffer for numeric conversions
=6					HashTableCount = 6 							; there are 6 hash tables, in token order.
=8					HashTableSize = 8 							; each hash table as 8 links.
.0335					HashTableBase:
>0335								.fill	HashTableCount * HashTableSize * 2
.0395					HashTableEnd:
=$315					Var_Buffer 	= Num_Buffer 					; buffer for variable name (same space)
>0395					Var_Type    .byte ? 						; type of variable (as a type token)
>0396					Var_Hash 	.byte ? 						; hash of identifier name.
>0397					Var_Length 	.byte ? 						; length of variable name
>0398					Var_HashAddress .byte ?						; low byte of hash table entry.
>0399					Var_DataSize .byte ?						; size of one element.
>039a					NumSuppress	.byte 	?						; leading zero suppression flag
>039b					NumConvCount .byte 	? 						; count for conversions.
>039c					ExpTemp:	.byte ?							; Working temp for exponents.
>039d					ExpCount:	.byte ? 						; Count of decimal exponents.
>039e					SignCount:	.byte ?							; Integer Divide Sign Counts.
>039f					TempStringWriteIndex: .byte ? 				; Write offset.
>03a0					ValSign: 	.byte ? 						; sign flag for val()
>03a1					SliceStart:	.byte ? 						; string slice parts
>03a2					SliceCount:	.byte ?
>03a3					RandomSeed:	.dword ? 						; Random seed.
>03a7					BreakCount:	.byte ? 						; Counter, avoid checking break every command.
=3					ArrayMaxDim = 3 							; number of dimensions.
>03a8					ArrayDef:	.fill (ArrayMaxDim+1)*2 		; dimensions for auto-creation
>03b0					UsrArrayDef:.fill (ArrayMaxDim+1)*2 		; dimensions created in DIM
>03b8					UsrArrayIdx:.byte ? 						; index into UsrArrayDef
>03b9					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>03bb					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>03bd					Tim_SR:		.byte ? 						; Processor Status
>03be					Tim_A:		.byte ? 						; Processor Registers
>03bf					Tim_X:		.byte ?
>03c0					Tim_Y:		.byte ?
>03c1					Tim_Z:		.byte ?
>03c2					Tim_SP:		.word ?							; Stack Pointer (just in cases)
>0400					BasicStack:	.fill 	256 					; and occupy whole pages.
.0500					EndBasicStack:
>0500					IFT_XCursor:.byte ?							; current logical position on screen
>0501					IFT_YCursor:.byte ?
>0502					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0566					IFT_LineBuffer: .fill 100 					; line input buffer.

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/mega65.asm

=$7f00					HighMemory = $7F00
=$2000					VariableMemory = $2000
.8000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testcode.src

>8000	0e 0a 00 d6 fe 09 48 65			.byte	$0e,$0a,$00,$d6,$fe,$09,$48,$65
>8008	6c 6c 6f 20 21 00 07 14			.byte	$6c,$6c,$6f,$20,$21,$00,$07,$14
>8010	00 18 84 46 00 08 1e 00			.byte	$00,$18,$84,$46,$00,$08,$1e,$00
>8018	90 18 88 40 00 07 28 00			.byte	$90,$18,$88,$40,$00,$07,$28,$00
>8020	19 84 40 00 05 32 00 91			.byte	$19,$84,$40,$00,$05,$32,$00,$91
>8028	00 0e 3c 00 d6 18 bf 19			.byte	$00,$0e,$3c,$00,$d6,$18,$bf,$19
>8030	c0 19 84 19 8a 41 00 10			.byte	$c0,$19,$84,$19,$8a,$41,$00,$10
>8038	46 00 96 19 84 43 c0 18			.byte	$46,$00,$96,$19,$84,$43,$c0,$18
>8040	84 18 8b 41 c0 95 00 0b			.byte	$84,$18,$8b,$41,$c0,$95,$00,$0b
>8048	50 00 d6 fe 06 45 6e 64			.byte	$50,$00,$d6,$fe,$06,$45,$6e,$64
>8050	2e 00 05 5a 00 c4 00 00			.byte	$2e,$00,$05,$5a,$00,$c4,$00,$00

;******  Return to file: modules/hardware/mega65.asm

.a000					StartROM:
.a000	a2 ff		ldx #$ff			ldx 		#$FF 					; empty stack
.a002	9a		txs				txs
.a003	20 4d a2	jsr $a24d			jsr 	IF_Reset 					; reset external interface
.a006	20 0c a0	jsr $a00c			jsr 	IFT_ClearScreen
.a009	4c 67 b0	jmp $b067		jmp BASIC_Start

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.a00c					IFT_ClearScreen:
.a00c	48		pha				pha
.a00d	da		phx				phx
.a00e	5a		phy				phy
.a00f	20 b4 a1	jsr $a1b4			jsr 	IF_Home 					; home cursor
.a012	a2 19		ldx #$19			ldx 	#IF_Height 					; this many lines.
.a014					_IFT_CS0:
.a014	a0 50		ldy #$50			ldy 	#IF_Width 					; this many chars/line
.a016					_IFT_CS1:
.a016	a9 20		lda #$20			lda 	#' '						; clear line.
.a018	20 e3 a1	jsr $a1e3			jsr 	IF_Write
.a01b	88		dey				dey
.a01c	d0 f8		bne $a016			bne 	_IFT_CS1
.a01e	20 c3 a1	jsr $a1c3			jsr 	IF_NewLine 					; next line down
.a021	ca		dex				dex
.a022	d0 f0		bne $a014			bne 	_IFT_CS0
.a024	7a		ply				ply
.a025	fa		plx				plx
.a026	68		pla				pla
.a027					IFT_HomeCursor:
.a027	48		pha				pha
.a028	20 b4 a1	jsr $a1b4			jsr 	IF_Home
.a02b	a9 00		lda #$00			lda 	#0
.a02d	8d 00 05	sta $0500			sta 	IFT_XCursor
.a030	8d 01 05	sta $0501			sta 	IFT_YCursor
.a033	68		pla				pla
.a034	60		rts				rts
.a035					IFT_UpLine:
.a035	48		pha				pha
.a036	ad 01 05	lda $0501			lda  	IFT_YCursor 				; get Y
.a039	3a		dec a				dec 	a 							; line above
.a03a	30 03		bmi $a03f			bmi 	_IFTULExit 					; too far, abort
.a03c	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos					; set to that line.
.a03f					_IFTULExit:
.a03f	68		pla				pla
.a040	60		rts				rts
.a041					IFT_PrintCharacter:
.a041	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.a043	f0 23		beq $a068			beq 	IFT_NewLine
.a045	48		pha				pha
.a046	20 80 a0	jsr $a080			jsr 	IFT_UpperCase 				; make upper case
.a049	20 e3 a1	jsr $a1e3			jsr 	IF_Write 					; write out.
.a04c	ee 00 05	inc $0500			inc 	IFT_XCursor 				; bump x cursor
.a04f	ad 00 05	lda $0500			lda 	IFT_XCursor 				; reached RHS ?
.a052	c9 50		cmp #$50			cmp 	#IF_Width
.a054	d0 03		bne $a059			bne 	_IFT_PCNotEOL
.a056	20 68 a0	jsr $a068			jsr 	IFT_NewLine 				; if so do new line.
.a059					_IFT_PCNotEOL:
.a059	68		pla				pla
.a05a	60		rts				rts
.a05b					IFT_Tab:
.a05b	a9 20		lda #$20			lda 	#" " 						; space
.a05d	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.a060	ad 00 05	lda $0500			lda 	IFT_XCursor 				; until x % 8 == 0
.a063	29 07		and #$07			and 	#7
.a065	d0 f4		bne $a05b			bne 	IFT_Tab
.a067	60		rts				rts
.a068					IFT_NewLine:
.a068	48		pha				pha
.a069	20 c3 a1	jsr $a1c3			jsr 	IF_NewLine 					; new line on actual screen.
.a06c	a9 00		lda #$00			lda 	#0 							; reset x position
.a06e	8d 00 05	sta $0500			sta 	IFT_XCursor
.a071	ee 01 05	inc $0501			inc 	IFT_YCursor 				; move down.
.a074	ad 01 05	lda $0501			lda 	IFT_YCursor
.a077	c9 19		cmp #$19			cmp 	#IF_Height 					; reached bottom.
.a079	d0 03		bne $a07e			bne 	_IFT_NL_NotEOS
.a07b	20 8b a0	jsr $a08b			jsr 	IFT_Scroll 					; scroll screen up.
.a07e					_IFT_NL_NotEOS:
.a07e	68		pla				pla
.a07f	60		rts				rts
.a080					IFT_UpperCase:
.a080	c9 61		cmp #$61			cmp 	#"a"
.a082	90 06		bcc $a08a			bcc 	_IFT_UCExit
.a084	c9 7b		cmp #$7b			cmp 	#"z"+1
.a086	b0 02		bcs $a08a			bcs 	_IFT_UCExit
.a088	49 20		eor #$20			eor 	#$20
.a08a					_IFT_UCExit:
.a08a	60		rts				rts
.a08b					IFT_Scroll:
.a08b	48		pha				pha 								; save AXY
.a08c	da		phx				phx
.a08d	5a		phy				phy
.a08e	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.a090					_IFT_SLoop:
.a090	20 b0 a0	jsr $a0b0			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.a093	e8		inx				inx
.a094	e0 18		cpx #$18			cpx 	#IF_Height-1				; do whole screen
.a096	d0 f8		bne $a090			bne 	_IFT_SLoop
.a098	a9 18		lda #$18			lda 	#IF_Height-1 				; move to X = 0,Y = A
.a09a	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a09d	a2 50		ldx #$50			ldx 	#IF_Width 					; blank line
.a09f					_IFT_SBlank:
.a09f	a9 20		lda #$20			lda 	#32
.a0a1	20 e3 a1	jsr $a1e3			jsr 	IF_Write
.a0a4	ca		dex				dex
.a0a5	d0 f8		bne $a09f			bne 	_IFT_SBlank
.a0a7	a9 18		lda #$18			lda 	#IF_Height-1 				; move to X = 0,Y = A
.a0a9	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a0ac	7a		ply				ply
.a0ad	fa		plx				plx
.a0ae	68		pla				pla
.a0af	60		rts				rts
.a0b0					_IFT_ScrollLine:
.a0b0	da		phx				phx
.a0b1	da		phx				phx
.a0b2	8a		txa				txa 								; copy line into buffer.
.a0b3	1a		inc a				inc 	a 							; next line down.
.a0b4	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a0b7	a2 00		ldx #$00			ldx 	#0
.a0b9					_IFTScrollCopy1:
.a0b9	20 d5 a1	jsr $a1d5			jsr 	IF_Read
.a0bc	9d 02 05	sta $0502,x			sta 	IFT_Buffer,x
.a0bf	e8		inx				inx
.a0c0	e0 50		cpx #$50			cpx 	#IF_Width
.a0c2	d0 f5		bne $a0b9			bne 	_IFTScrollCopy1
.a0c4	68		pla				pla
.a0c5	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a0c8	a2 00		ldx #$00			ldx 	#0
.a0ca					_IFTScrollCopy2:
.a0ca	bd 02 05	lda $0502,x			lda 	IFT_Buffer,x
.a0cd	20 e3 a1	jsr $a1e3			jsr 	IF_Write
.a0d0	e8		inx				inx
.a0d1	e0 50		cpx #$50			cpx 	#IF_Width
.a0d3	d0 f5		bne $a0ca			bne 	_IFTScrollCopy2
.a0d5	fa		plx				plx
.a0d6	60		rts				rts
.a0d7					IFT_SetYPos:
.a0d7	48		pha				pha
.a0d8	da		phx				phx
.a0d9	aa		tax				tax
.a0da	20 27 a0	jsr $a027			jsr 	IFT_HomeCursor
.a0dd	e0 00		cpx #$00			cpx 	#0
.a0df	f0 09		beq $a0ea			beq 	_IFT_MOAExit
.a0e1					_IFT_MOALoop:
.a0e1	20 c3 a1	jsr $a1c3			jsr 	IF_NewLine
.a0e4	ee 01 05	inc $0501			inc 	IFT_YCursor
.a0e7	ca		dex				dex
.a0e8	d0 f7		bne $a0e1			bne		_IFT_MOALoop
.a0ea					_IFT_MOAExit:
.a0ea	fa		plx				plx
.a0eb	68		pla				pla
.a0ec	60		rts				rts
.a0ed					IFT_GetKeyCursor:
.a0ed	20 f5 a0	jsr $a0f5			jsr 	_IFT_FlipCursor 			; reverse current
.a0f0					_IFT_GKCWait:
.a0f0	20 06 a2	jsr $a206			jsr 	IF_GetKey 					; get key
.a0f3	f0 fb		beq $a0f0			beq 	_IFT_GKCWait
.a0f5					_IFT_FlipCursor:
.a0f5	48		pha				pha 								; save
.a0f6	20 d5 a1	jsr $a1d5			jsr 	IF_Read 					; read
.a0f9	20 ee a1	jsr $a1ee			jsr 	IF_LeftOne
.a0fc	49 80		eor #$80			eor 	#$80 						; reverse
.a0fe	20 e3 a1	jsr $a1e3			jsr 	IF_Write 					; write
.a101	20 ee a1	jsr $a1ee			jsr 	IF_LeftOne
.a104	68		pla				pla
.a105	60		rts				rts
.a106					IFT_ReadLine:
.a106	48		pha				pha
.a107					_IFT_RLLoop:
.a107	20 ed a0	jsr $a0ed			jsr 	IFT_GetKeyCursor 			; get keystroke
.a10a	c9 0d		cmp #$0d			cmp 	#13							; return
.a10c	f0 7d		beq $a18b			beq 	_IFT_RLExit
.a10e	c9 20		cmp #$20			cmp 	#32 						; control character
.a110	90 05		bcc $a117			bcc 	_IFT_Control
.a112	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.a115	80 f0		bra $a107			bra 	_IFT_RLLoop
.a117					_IFT_Control:
.a117	c9 01		cmp #$01			cmp 	#"A"-64
.a119	f0 26		beq $a141			beq 	_IFT_Left
.a11b	c9 04		cmp #$04			cmp 	#"D"-64
.a11d	f0 2e		beq $a14d			beq 	_IFT_Right
.a11f	c9 17		cmp #$17			cmp 	#"W"-64
.a121	f0 36		beq $a159			beq 	_IFT_Up
.a123	c9 13		cmp #$13			cmp 	#"S"-64
.a125	f0 3e		beq $a165			beq 	_IFT_Down
.a127	c9 08		cmp #$08			cmp 	#"H"-64
.a129	f0 09		beq $a134			beq 	_IFT_Backspace
.a12b	c9 1a		cmp #$1a			cmp 	#"Z"-64
.a12d	d0 d8		bne $a107			bne 	_IFT_RLLoop
.a12f	20 0c a0	jsr $a00c			jsr 	IFT_ClearScreen				; clear CTL-Z
.a132	80 d3		bra $a107			bra 	_IFT_RLLoop
.a134					_IFT_Backspace:
.a134	ad 00 05	lda $0500			lda 	IFT_XCursor 				; check not start of line.
.a137	f0 ce		beq $a107			beq 	_IFT_RLLoop
.a139	20 ee a1	jsr $a1ee			jsr 	IF_LeftOne
.a13c	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.a13e	20 e3 a1	jsr $a1e3			jsr 	IF_Write
.a141					_IFT_Left:
.a141	ce 00 05	dec $0500			dec 	IFT_XCursor 				; left CTL-W
.a144	10 29		bpl $a16f			bpl 	_IFT_Reposition
.a146	a9 4f		lda #$4f			lda 	#IF_Width-1
.a148					_IFT_SetX:
.a148	8d 00 05	sta $0500			sta 	IFT_XCursor
.a14b	80 22		bra $a16f			bra 	_IFT_Reposition
.a14d					_IFT_Right:
.a14d	ee 00 05	inc $0500			inc 	IFT_XCursor
.a150	ad 00 05	lda $0500			lda 	IFT_XCursor
.a153	49 50		eor #$50			eor 	#IF_Width
.a155	f0 f1		beq $a148			beq 	_IFT_SetX
.a157	80 16		bra $a16f			bra 	_IFT_Reposition
.a159					_IFT_Up:
.a159	ce 01 05	dec $0501			dec 	IFT_YCursor
.a15c	10 11		bpl $a16f			bpl 	_IFT_Reposition
.a15e	a9 18		lda #$18			lda 	#IF_Height-1
.a160					_IFT_SetY:
.a160	8d 01 05	sta $0501			sta 	IFT_YCursor
.a163	80 0a		bra $a16f			bra 	_IFT_Reposition
.a165					_IFT_Down:
.a165	ee 01 05	inc $0501			inc 	IFT_YCursor
.a168	ad 01 05	lda $0501			lda 	IFT_YCursor
.a16b	49 19		eor #$19			eor 	#IF_Height
.a16d	f0 f1		beq $a160			beq 	_IFT_SetY
.a16f					_IFT_Reposition:
.a16f	ad 00 05	lda $0500			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.a172	48		pha				pha
.a173	ad 01 05	lda $0501			lda 	IFT_YCursor
.a176	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a179	68		pla				pla
.a17a	aa		tax				tax
.a17b	e0 00		cpx #$00			cpx 	#0
.a17d	f0 88		beq $a107			beq 	_IFT_RLLoop
.a17f					_IFT_MoveRight:
.a17f	20 d5 a1	jsr $a1d5			jsr 	IF_Read
.a182	ee 00 05	inc $0500			inc 	IFT_XCursor
.a185	ca		dex				dex
.a186	d0 f7		bne $a17f			bne 	_IFT_MoveRight
.a188	4c 07 a1	jmp $a107			jmp 	_IFT_RLLoop
.a18b					_IFT_RLExit:
.a18b	ad 01 05	lda $0501			lda 	IFT_YCursor 				; go to start of line.
.a18e	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a191	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.a193					_IFT_RLRead:
.a193	20 d5 a1	jsr $a1d5			jsr 	IF_Read
.a196	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.a199	e8		inx				inx
.a19a	e0 50		cpx #$50			cpx 	#IF_Width
.a19c	d0 f5		bne $a193			bne 	_IFT_RLRead
.a19e					_IFT_RL_Trim:
.a19e	ca		dex				dex 	 							; previous char
.a19f	30 07		bmi $a1a8			bmi 	_IFT_Found 					; gone too far
.a1a1	bd 66 05	lda $0566,x			lda 	IFT_LineBuffer,x			; go back if space
.a1a4	c9 20		cmp #$20			cmp 	#" "
.a1a6	f0 f6		beq $a19e			beq 	_IFT_RL_Trim
.a1a8					_IFT_Found:
.a1a8	e8		inx				inx 								; forward to non-space
.a1a9	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.a1ab	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.a1ae	68		pla				pla
.a1af	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.a1b1	a0 05		ldy #$05			ldy 	#IFT_LineBuffer >> 8
.a1b3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_mega65.asm

=80					IF_Width 	= 80 							; characters across
=25					IF_Height 	= 25 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line
=6					IF_XPos 	= 6 							; current position, horizontal.
=8					IF_FarPtr 	= 8 							; far pointer (4 bytes)
=$1000					IF_Screen = $1000							; 2k screen RAM here
=$800					IF_CharSet = $800							; 2k character set (0-7F) here
.a1b4					IF_Home:
.a1b4	48		pha				pha 								; reset cursor position
.a1b5	a9 00		lda #$00			lda 	#IF_Screen & $FF
.a1b7	85 04		sta $04				sta 	IF_Pos
.a1b9	a9 10		lda #$10			lda 	#IF_Screen >> 8
.a1bb	85 05		sta $05				sta 	IF_Pos+1
.a1bd	a9 00		lda #$00			lda 	#0
.a1bf	85 06		sta $06				sta 	IF_XPos
.a1c1	68		pla				pla
.a1c2	60		rts				rts
.a1c3					IF_NewLine:
.a1c3	48		pha				pha
.a1c4	a9 00		lda #$00			lda 	#0 							; back to start of line
.a1c6	85 06		sta $06				sta 	IF_XPos
.a1c8	18		clc				clc 								; down one line
.a1c9	a5 04		lda $04				lda 	IF_Pos
.a1cb	69 50		adc #$50			adc 	#80
.a1cd	85 04		sta $04				sta 	IF_Pos
.a1cf	90 02		bcc $a1d3			bcc 	_IF_NoCarry 				; carry through.
.a1d1	e6 05		inc $05				inc 	IF_Pos+1
.a1d3					_IF_NoCarry:
.a1d3	68		pla				pla
.a1d4	60		rts				rts
.a1d5					IF_Read:
.a1d5	5a		phy				phy 								; save current Y
.a1d6	a4 06		ldy $06				ldy 	IF_XPos 					; read character at current position
.a1d8	b1 04		lda ($04),y			lda 	(IF_Pos),y
.a1da	49 20		eor #$20			eor 	#$20
.a1dc	18		clc				clc
.a1dd	69 20		adc #$20			adc 	#$20
.a1df	e6 06		inc $06				inc 	IF_XPos 					; step right.
.a1e1	7a		ply				ply									; restore Y
.a1e2	60		rts				rts
.a1e3					IF_Write:
.a1e3	5a		phy				phy 								; save current Y
.a1e4	a4 06		ldy $06				ldy 	IF_XPos 					; write character at current position
.a1e6	29 bf		and #$bf			and 	#63+128 					; PETSCII
.a1e8	91 04		sta ($04),y			sta 	(IF_Pos),y
.a1ea	e6 06		inc $06				inc 	IF_XPos 					; step right.
.a1ec	7a		ply				ply									; restore Y
.a1ed	60		rts				rts
.a1ee					IF_LeftOne:
.a1ee	c6 06		dec $06				dec 	IF_XPos
.a1f0	60		rts				rts
.a1f1					IF_CheckBreak:
.a1f1	db		phz				phz
.a1f2	20 3a a2	jsr $a23a			jsr 	IF_SetupKeyAddress 			; point to keyboard
.a1f5	e6 08		inc $08				inc 	IF_FarPtr 					; point to modifiers.
.a1f7	ea		nop				nop 								; read modifiers.
.a1f8	b2 08		lda ($08),z			lda 	(IF_FarPtr),z
.a1fa	fb		plz				plz 								; restore Z
.a1fb	29 05		and #$05			and 	#5							; break is LeftShift+Ctrl
.a1fd	c9 05		cmp #$05			cmp 	#5
.a1ff	f0 02		beq $a203			beq 	_IF_CBExit
.a201	a9 00		lda #$00			lda 	#0
.a203					_IF_CBExit:
.a203	c9 00		cmp #$00			cmp 	#0
.a205	60		rts				rts
.a206					IF_GetKey:
.a206	db		phz				phz
.a207	20 3a a2	jsr $a23a			jsr 	IF_SetupKeyAddress
.a20a	ea		nop				nop 								; read keyboard
.a20b	b2 08		lda ($08),z			lda 	(IF_FarPtr),z
.a20d	c9 14		cmp #$14			cmp 	#20
.a20f	d0 02		bne $a213			bne 	_KMNo
.a211	a9 08		lda #$08			lda 	#"H"-64
.a213					_KMNo:
.a213	c9 91		cmp #$91			cmp 	#145
.a215	d0 02		bne $a219			bne 	_KMNo
.a217	a9 17		lda #$17			lda 	#"W"-64
.a219					_KMNo:
.a219	c9 11		cmp #$11			cmp 	#17
.a21b	d0 02		bne $a21f			bne 	_KMNo
.a21d	a9 13		lda #$13			lda 	#"S"-64
.a21f					_KMNo:
.a21f	c9 9d		cmp #$9d			cmp 	#157
.a221	d0 02		bne $a225			bne 	_KMNo
.a223	a9 01		lda #$01			lda 	#"A"-64
.a225					_KMNo:
.a225	c9 1d		cmp #$1d			cmp 	#29
.a227	d0 02		bne $a22b			bne 	_KMNo
.a229	a9 04		lda #$04			lda 	#"D"-64
.a22b					_KMNo:
.a22b	c9 00		cmp #$00			cmp 	#0
.a22d	f0 07		beq $a236			beq 	_IFGKEmpty
.a22f	48		pha				pha
.a230	a9 00		lda #$00			lda 	#0
.a232	ea		nop				nop
.a233	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a235	68		pla				pla
.a236					_IFGKEmpty:
.a236	fb		plz				plz
.a237	c9 00		cmp #$00			cmp 	#0 							; set Z
.a239	60		rts				rts
.a23a					IF_SetupKeyAddress:
.a23a	a9 0f		lda #$0f			lda 	#$0F 						; set up to write to read keyboard.
.a23c	85 0b		sta $0b				sta 	IF_FarPtr+3
.a23e	a9 fd		lda #$fd			lda 	#$FD
.a240	85 0a		sta $0a				sta 	IF_FarPtr+2
.a242	a9 36		lda #$36			lda 	#$36
.a244	85 09		sta $09				sta 	IF_FarPtr+1
.a246	a9 10		lda #$10			lda 	#$10
.a248	85 08		sta $08				sta 	IF_FarPtr+0
.a24a	a3 00		ldz #$00			ldz 	#0
.a24c	60		rts				rts
.a24d					IF_Reset:
.a24d	48		pha				pha 								; save registers
.a24e	da		phx				phx
.a24f	5a		phy				phy
.a250	a9 0f		lda #$0f			lda 	#$0F 						; set up to write to video system.
.a252	85 0b		sta $0b				sta 	IF_FarPtr+3
.a254	a9 fd		lda #$fd			lda 	#$FD
.a256	85 0a		sta $0a				sta 	IF_FarPtr+2
.a258	a9 30		lda #$30			lda 	#$30
.a25a	85 09		sta $09				sta 	IF_FarPtr+1
.a25c	a9 00		lda #$00			lda 	#$00
.a25e	85 08		sta $08				sta 	IF_FarPtr+0
.a260	a3 2f		ldz #$2f			ldz 	#$2F 						; address already set up
.a262	a9 47		lda #$47			lda 	#$47
.a264	ea		nop				nop
.a265	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a267	a3 2f		ldz #$2f			ldz 	#$2F 						; address already set up
.a269	a9 53		lda #$53			lda 	#$53
.a26b	ea		nop				nop
.a26c	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a26e	a3 30		ldz #$30			ldz 	#$30 						; address already set up
.a270	a9 40		lda #$40			lda 	#$40
.a272	ea		nop				nop
.a273	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a275	a3 31		ldz #$31			ldz 	#$31 						; address already set up
.a277	a9 c0		lda #$c0			lda 	#$80+$40
.a279	ea		nop				nop
.a27a	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a27c	a3 20		ldz #$20			ldz 	#$20 						; address already set up
.a27e	a9 00		lda #$00			lda 	#0
.a280	ea		nop				nop
.a281	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a283	a3 21		ldz #$21			ldz 	#$21 						; address already set up
.a285	a9 00		lda #$00			lda 	#0
.a287	ea		nop				nop
.a288	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a28a	a3 54		ldz #$54			ldz 	#$54 						; address already set up
.a28c	a9 40		lda #$40			lda 	#$40
.a28e	ea		nop				nop
.a28f	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a291	a3 01		ldz #$01			ldz 	#$01 						; address already set up
.a293	a9 ff		lda #$ff			lda 	#$FF
.a295	ea		nop				nop
.a296	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a298	a3 00		ldz #$00			ldz 	#$00 						; address already set up
.a29a	a9 ff		lda #$ff			lda 	#$FF
.a29c	ea		nop				nop
.a29d	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a29f	a3 16		ldz #$16			ldz 	#$16 						; address already set up
.a2a1	a9 cc		lda #$cc			lda 	#$CC
.a2a3	ea		nop				nop
.a2a4	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2a6	a3 18		ldz #$18			ldz 	#$18 						; address already set up
.a2a8	a9 42		lda #$42			lda 	#$42
.a2aa	ea		nop				nop
.a2ab	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2ad	a3 11		ldz #$11			ldz 	#$11 						; address already set up
.a2af	a9 1b		lda #$1b			lda 	#$1B
.a2b1	ea		nop				nop
.a2b2	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2b4	a9 00		lda #$00			lda 	#$00						; colour RAM at $1F800-1FFFF (2kb)
.a2b6	85 0b		sta $0b				sta 	IF_FarPtr+3
.a2b8	a9 01		lda #$01			lda 	#$01
.a2ba	85 0a		sta $0a				sta 	IF_FarPtr+2
.a2bc	a9 f8		lda #$f8			lda 	#$F8
.a2be	85 09		sta $09				sta 	IF_FarPtr+1
.a2c0	a9 00		lda #$00			lda 	#$00
.a2c2	85 08		sta $08				sta 	IF_FarPtr+0
.a2c4	a3 00		ldz #$00			ldz 	#0
.a2c6					_EXTClearColorRam:
.a2c6	a9 05		lda #$05			lda 	#5							; fill that with this colour.
.a2c8	ea		nop				nop
.a2c9	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2cb	3b		dez				dez
.a2cc	d0 f8		bne $a2c6			bne 	_EXTClearColorRam
.a2ce	e6 09		inc $09				inc 	IF_FarPtr+1
.a2d0	d0 f4		bne $a2c6			bne 	_EXTClearColorRam
.a2d2	a2 00		ldx #$00			ldx 	#0 							; copy PET Font into memory.
.a2d4					_EXTCopyCBMFont:
.a2d4	bd 15 a3	lda $a315,x			lda 	IF_CBMFont,x 				; +$800 uses the lower case c/set
.a2d7	9d 00 08	sta $0800,x			sta 	IF_CharSet,x
.a2da	49 ff		eor #$ff			eor 	#$FF
.a2dc	9d 00 0c	sta $0c00,x			sta 	IF_CharSet+$400,x
.a2df	bd 15 a4	lda $a415,x			lda 	IF_CBMFont+$100,x
.a2e2	9d 00 09	sta $0900,x			sta 	IF_CharSet+$100,x
.a2e5	49 ff		eor #$ff			eor 	#$FF
.a2e7	9d 00 0d	sta $0d00,x			sta 	IF_CharSet+$500,x
.a2ea	bd 15 a5	lda $a515,x			lda 	IF_CBMFont+$200,x
.a2ed	9d 00 0a	sta $0a00,x			sta 	IF_CharSet+$200,x
.a2f0	49 ff		eor #$ff			eor 	#$FF
.a2f2	9d 00 0e	sta $0e00,x			sta 	IF_CharSet+$600,x
.a2f5	bd 15 a6	lda $a615,x			lda 	IF_CBMFont+$300,x
.a2f8	9d 00 0b	sta $0b00,x			sta 	IF_CharSet+$300,x
.a2fb	49 ff		eor #$ff			eor 	#$FF
.a2fd	9d 00 0f	sta $0f00,x			sta 	IF_CharSet+$700,x
.a300	ca		dex				dex
.a301	d0 d1		bne $a2d4			bne 	_EXTCopyCBMFont
.a303	a9 3b		lda #$3b			lda 	#$3F-4  					; puts ROM back in the map (the -4)
.a305	85 01		sta $01				sta 	$01
.a307	a9 00		lda #$00			lda 	#$00						; do not map bytes 0000-7FFF
.a309	a2 00		ldx #$00			ldx 	#$00						; (so we use the RAM physically at $0000-$7FFF)
.a30b	a0 00		ldy #$00			ldy 	#$00 						; 8000-FFFF offset by $200. The lower 8 bits are $00
.a30d	a3 f2		ldz #$f2			ldz 	#$F2 						; so this is an actual offset of $20000. So the space at
.a30f	5c		map				map
.a310	ea		nop				eom
.a311	7a		ply				ply 								; restore and exit.
.a312	fa		plx				plx
.a313	68		pla				pla
.a314	60		rts				rts
.a315					IF_CBMFont:
>a315	1c 22 4a 56 4c 20 1e 00				.binary "pet-font.bin"
>a31d	18 24 42 7e 42 42 42 00 7c 22 22 3c 22 22 7c 00
>a32d	1c 22 40 40 40 22 1c 00 78 24 22 22 22 24 78 00
>a33d	7e 40 40 78 40 40 7e 00 7e 40 40 78 40 40 40 00
>a34d	1c 22 40 4e 42 22 1c 00 42 42 42 7e 42 42 42 00
>a35d	1c 08 08 08 08 08 1c 00 0e 04 04 04 04 44 38 00
>a36d	42 44 48 70 48 44 42 00 40 40 40 40 40 40 7e 00
>a37d	42 66 5a 5a 42 42 42 00 42 62 52 4a 46 42 42 00
>a38d	18 24 42 42 42 24 18 00 7c 42 42 7c 40 40 40 00
>a39d	18 24 42 42 4a 24 1a 00 7c 42 42 7c 48 44 42 00
>a3ad	3c 42 40 3c 02 42 3c 00 3e 08 08 08 08 08 08 00
>a3bd	42 42 42 42 42 42 3c 00 42 42 42 24 24 18 18 00
>a3cd	42 42 42 5a 5a 66 42 00 42 42 24 18 24 42 42 00
>a3dd	22 22 22 1c 08 08 08 00 7e 02 04 18 20 40 7e 00
>a3ed	3c 20 20 20 20 20 3c 00 00 40 20 10 08 04 02 00
>a3fd	3c 04 04 04 04 04 3c 00 00 08 1c 2a 08 08 08 08
>a40d	00 00 10 20 7f 20 10 00 00 00 00 00 00 00 00 00
>a41d	08 08 08 08 00 00 08 00 24 24 24 00 00 00 00 00
>a42d	24 24 7e 24 7e 24 24 00 08 1e 28 1c 0a 3c 08 00
>a43d	00 62 64 08 10 26 46 00 30 48 48 30 4a 44 3a 00
>a44d	04 08 10 00 00 00 00 00 04 08 10 10 10 08 04 00
>a45d	20 10 08 08 08 10 20 00 08 2a 1c 3e 1c 2a 08 00
>a46d	00 08 08 3e 08 08 00 00 00 00 00 00 00 08 08 10
>a47d	00 00 00 7e 00 00 00 00 00 00 00 00 00 18 18 00
>a48d	00 02 04 08 10 20 40 00 3c 42 46 5a 62 42 3c 00
>a49d	08 18 28 08 08 08 3e 00 3c 42 02 0c 30 40 7e 00
>a4ad	3c 42 02 1c 02 42 3c 00 04 0c 14 24 7e 04 04 00
>a4bd	7e 40 78 04 02 44 38 00 1c 20 40 7c 42 42 3c 00
>a4cd	7e 42 04 08 10 10 10 00 3c 42 42 3c 42 42 3c 00
>a4dd	3c 42 42 3e 02 04 38 00 00 00 08 00 00 08 00 00
>a4ed	00 00 08 00 00 08 08 10 0e 18 30 60 30 18 0e 00
>a4fd	00 00 7e 00 7e 00 00 00 70 18 0c 06 0c 18 70 00
>a50d	3c 42 02 0c 10 00 10 00 00 00 00 00 ff 00 00 00
>a51d	08 1c 3e 7f 7f 1c 3e 00 10 10 10 10 10 10 10 10
>a52d	00 00 00 ff 00 00 00 00 00 00 ff 00 00 00 00 00
>a53d	00 ff 00 00 00 00 00 00 00 00 00 00 00 ff 00 00
>a54d	20 20 20 20 20 20 20 20 04 04 04 04 04 04 04 04
>a55d	00 00 00 00 e0 10 08 08 08 08 08 04 03 00 00 00
>a56d	08 08 08 10 e0 00 00 00 80 80 80 80 80 80 80 ff
>a57d	80 40 20 10 08 04 02 01 01 02 04 08 10 20 40 80
>a58d	ff 80 80 80 80 80 80 80 ff 01 01 01 01 01 01 01
>a59d	00 3c 7e 7e 7e 7e 3c 00 00 00 00 00 00 00 ff 00
>a5ad	36 7f 7f 7f 3e 1c 08 00 40 40 40 40 40 40 40 40
>a5bd	00 00 00 00 03 04 08 08 81 42 24 18 18 24 42 81
>a5cd	00 3c 42 42 42 42 3c 00 08 1c 2a 77 2a 08 08 00
>a5dd	02 02 02 02 02 02 02 02 08 1c 3e 7f 3e 1c 08 00
>a5ed	08 08 08 08 ff 08 08 08 a0 50 a0 50 a0 50 a0 50
>a5fd	08 08 08 08 08 08 08 08 00 00 01 3e 54 14 14 00
>a60d	ff 7f 3f 1f 0f 07 03 01 00 00 00 00 00 00 00 00
>a61d	f0 f0 f0 f0 f0 f0 f0 f0 00 00 00 00 ff ff ff ff
>a62d	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff
>a63d	80 80 80 80 80 80 80 80 aa 55 aa 55 aa 55 aa 55
>a64d	01 01 01 01 01 01 01 01 00 00 00 00 aa 55 aa 55
>a65d	ff fe fc f8 f0 e0 c0 80 03 03 03 03 03 03 03 03
>a66d	08 08 08 08 0f 08 08 08 00 00 00 00 0f 0f 0f 0f
>a67d	08 08 08 08 0f 00 00 00 00 00 00 00 f8 08 08 08
>a68d	00 00 00 00 00 00 ff ff 00 00 00 00 0f 08 08 08
>a69d	08 08 08 08 ff 00 00 00 00 00 00 00 ff 08 08 08
>a6ad	08 08 08 08 f8 08 08 08 c0 c0 c0 c0 c0 c0 c0 c0
>a6bd	e0 e0 e0 e0 e0 e0 e0 e0 07 07 07 07 07 07 07 07
>a6cd	ff ff 00 00 00 00 00 00 ff ff ff 00 00 00 00 00
>a6dd	00 00 00 00 00 ff ff ff 01 01 01 01 01 01 01 ff
>a6ed	00 00 00 00 f0 f0 f0 f0 0f 0f 0f 0f 00 00 00 00
>a6fd	08 08 08 08 f8 00 00 00 f0 f0 f0 f0 00 00 00 00
>a70d	f0 f0 f0 f0 0f 0f 0f 0f 1c 22 4a 56 4c 20 1e 00
>a71d	18 24 42 7e 42 42 42 00 7c 22 22 3c 22 22 7c 00
>a72d	1c 22 40 40 40 22 1c 00 78 24 22 22 22 24 78 00
>a73d	7e 40 40 78 40 40 7e 00 7e 40 40 78 40 40 40 00
>a74d	1c 22 40 4e 42 22 1c 00 42 42 42 7e 42 42 42 00
>a75d	1c 08 08 08 08 08 1c 00 0e 04 04 04 04 44 38 00
>a76d	42 44 48 70 48 44 42 00 40 40 40 40 40 40 7e 00
>a77d	42 66 5a 5a 42 42 42 00 42 62 52 4a 46 42 42 00
>a78d	18 24 42 42 42 24 18 00 7c 42 42 7c 40 40 40 00
>a79d	18 24 42 42 4a 24 1a 00 7c 42 42 7c 48 44 42 00
>a7ad	3c 42 40 3c 02 42 3c 00 3e 08 08 08 08 08 08 00
>a7bd	42 42 42 42 42 42 3c 00 42 42 42 24 24 18 18 00
>a7cd	42 42 42 5a 5a 66 42 00 42 42 24 18 24 42 42 00
>a7dd	22 22 22 1c 08 08 08 00 7e 02 04 18 20 40 7e 00
>a7ed	3c 20 20 20 20 20 3c 00 00 40 20 10 08 04 02 00
>a7fd	3c 04 04 04 04 04 3c 00 00 08 1c 2a 08 08 08 08
>a80d	00 00 10 20 7f 20 10 00 00 00 00 00 00 00 00 00
>a81d	08 08 08 08 00 00 08 00 24 24 24 00 00 00 00 00
>a82d	24 24 7e 24 7e 24 24 00 08 1e 28 1c 0a 3c 08 00
>a83d	00 62 64 08 10 26 46 00 30 48 48 30 4a 44 3a 00
>a84d	04 08 10 00 00 00 00 00 04 08 10 10 10 08 04 00
>a85d	20 10 08 08 08 10 20 00 08 2a 1c 3e 1c 2a 08 00
>a86d	00 08 08 3e 08 08 00 00 00 00 00 00 00 08 08 10
>a87d	00 00 00 7e 00 00 00 00 00 00 00 00 00 18 18 00
>a88d	00 02 04 08 10 20 40 00 3c 42 46 5a 62 42 3c 00
>a89d	08 18 28 08 08 08 3e 00 3c 42 02 0c 30 40 7e 00
>a8ad	3c 42 02 1c 02 42 3c 00 04 0c 14 24 7e 04 04 00
>a8bd	7e 40 78 04 02 44 38 00 1c 20 40 7c 42 42 3c 00
>a8cd	7e 42 04 08 10 10 10 00 3c 42 42 3c 42 42 3c 00
>a8dd	3c 42 42 3e 02 04 38 00 00 00 08 00 00 08 00 00
>a8ed	00 00 08 00 00 08 08 10 0e 18 30 60 30 18 0e 00
>a8fd	00 00 7e 00 7e 00 00 00 70 18 0c 06 0c 18 70 00
>a90d	3c 42 02 0c 10 00 10 00 00 00 00 00 ff 00 00 00
>a91d	00 00 38 04 3c 44 3a 00 40 40 5c 62 42 62 5c 00
>a92d	00 00 3c 42 40 42 3c 00 02 02 3a 46 42 46 3a 00
>a93d	00 00 3c 42 7e 40 3c 00 0c 12 10 7c 10 10 10 00
>a94d	00 00 3a 46 46 3a 02 3c 40 40 5c 62 42 42 42 00
>a95d	08 00 18 08 08 08 1c 00 04 00 0c 04 04 04 44 38
>a96d	40 40 44 48 50 68 44 00 18 08 08 08 08 08 1c 00
>a97d	00 00 76 49 49 49 49 00 00 00 5c 62 42 42 42 00
>a98d	00 00 3c 42 42 42 3c 00 00 00 5c 62 62 5c 40 40
>a99d	00 00 3a 46 46 3a 02 02 00 00 5c 62 40 40 40 00
>a9ad	00 00 3e 40 3c 02 7c 00 10 10 7c 10 10 12 0c 00
>a9bd	00 00 42 42 42 46 3a 00 00 00 42 42 42 24 18 00
>a9cd	00 00 41 49 49 49 36 00 00 00 42 24 18 24 42 00
>a9dd	00 00 42 42 46 3a 02 3c 00 00 7e 04 18 20 7e 00
>a9ed	08 08 08 08 ff 08 08 08 a0 50 a0 50 a0 50 a0 50
>a9fd	08 08 08 08 08 08 08 08 cc cc 33 33 cc cc 33 33
>aa0d	cc 66 33 99 cc 66 33 99 00 00 00 00 00 00 00 00
>aa1d	f0 f0 f0 f0 f0 f0 f0 f0 00 00 00 00 ff ff ff ff
>aa2d	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff
>aa3d	80 80 80 80 80 80 80 80 aa 55 aa 55 aa 55 aa 55
>aa4d	01 01 01 01 01 01 01 01 00 00 00 00 aa 55 aa 55
>aa5d	99 33 66 cc 99 33 66 cc 03 03 03 03 03 03 03 03
>aa6d	08 08 08 08 0f 08 08 08 00 00 00 00 0f 0f 0f 0f
>aa7d	08 08 08 08 0f 00 00 00 00 00 00 00 f8 08 08 08
>aa8d	00 00 00 00 00 00 ff ff 00 00 00 00 0f 08 08 08
>aa9d	08 08 08 08 ff 00 00 00 00 00 00 00 ff 08 08 08
>aaad	08 08 08 08 f8 08 08 08 c0 c0 c0 c0 c0 c0 c0 c0
>aabd	e0 e0 e0 e0 e0 e0 e0 e0 07 07 07 07 07 07 07 07
>aacd	ff ff 00 00 00 00 00 00 ff ff ff 00 00 00 00 00
>aadd	00 00 00 00 00 ff ff ff 01 02 44 48 50 60 40 00
>aaed	00 00 00 00 f0 f0 f0 f0 0f 0f 0f 0f 00 00 00 00
>aafd	08 08 08 08 f8 00 00 00 f0 f0 f0 f0 00 00 00 00
>ab0d	f0 f0 f0 f0 0f 0f 0f 0f

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.ab15					TIM_Error:
.ab15	20 35 a0	jsr $a035			jsr 	IFT_UpLine 					; go up one line.
.ab18	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.ab1a	80 02		bra $ab1e			bra 	TIM_ShowPrompt
.ab1c					TIM_NewCommand:
.ab1c	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.ab1e					TIM_ShowPrompt:
.ab1e	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.ab21	20 06 a1	jsr $a106			jsr 	IFT_ReadLine	 			; get character, go to next line
.ab24	20 68 a0	jsr $a068			jsr 	IFT_NewLine					; go to next line.
.ab27	86 10		stx $10				stx 	zTemp1 						; save line read address
.ab29	84 11		sty $11				sty 	zTemp1+1
.ab2b	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.ab2d	b1 10		lda ($10),y			lda 	(zTemp1),y
.ab2f	c9 3f		cmp #$3f			cmp 	#"?"
.ab31	f0 04		beq $ab37			beq 	TIM_SkipFirst
.ab33	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.ab35	d0 01		bne $ab38			bne 	TIM_NotDot
.ab37					TIM_SkipFirst:
.ab37	c8		iny				iny
.ab38					TIM_NotDot:
.ab38	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.ab3a	c9 52		cmp #$52			cmp 	#"R"						; show registers
.ab3c	f0 6e		beq $abac			beq 	TIM_ShowRegisters
.ab3e	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.ab40	f0 12		beq $ab54			beq 	TIM_ShowMemory
.ab42	c9 47		cmp #$47			cmp 	#"G"						; execute
.ab44	f0 49		beq $ab8f			beq 	TIM_Execute
.ab46	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.ab48	f0 07		beq $ab51			beq 	TIM_GoLoadMemory
.ab4a	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.ab4c	d0 c7		bne $ab15			bne 	TIM_Error
.ab4e	4c d1 ac	jmp $acd1			jmp 	TIM_UpdateRegisters
.ab51					TIM_GoLoadMemory:
.ab51	4c fc ac	jmp $acfc			jmp 	TIM_LoadMemory
.ab54					TIM_ShowMemory:
.ab54	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.ab57	b0 bc		bcs $ab15			bcs 	TIM_Error
.ab59	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.ab5b	85 12		sta $12				sta 	zTemp2
.ab5d	a5 15		lda $15				lda 	zTemp3+1
.ab5f	85 13		sta $13				sta 	zTemp2+1
.ab61	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.ab64	90 08		bcc $ab6e			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.ab66	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.ab68	85 14		sta $14				sta 	zTemp3
.ab6a	a5 13		lda $13				lda 	zTemp2+1
.ab6c	85 15		sta $15				sta 	zTemp3+1
.ab6e					_TIMSM_Start:
.ab6e	20 22 ac	jsr $ac22			jsr 	TIM_WriteLine 				; write one line of hex out
.ab71	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.ab73	18		clc				clc
.ab74	69 10		adc #$10			adc 	#16
.ab76	85 12		sta $12				sta 	zTemp2
.ab78	90 02		bcc $ab7c			bcc 	_TIMSM_NoCarry
.ab7a	e6 13		inc $13				inc 	zTemp2+1
.ab7c					_TIMSM_NoCarry:
.ab7c	20 f1 a1	jsr $a1f1			jsr 	IF_CheckBreak 				; check CTL+C
.ab7f	d0 0b		bne $ab8c			bne 	_TIMSM_Ends 				; if pressed break out.
.ab81	38		sec				sec 								; check past the end address in zTemp3
.ab82	a5 14		lda $14				lda 	zTemp3
.ab84	e5 12		sbc $12				sbc 	zTemp2
.ab86	a5 15		lda $15				lda 	zTemp3+1
.ab88	e5 13		sbc $13				sbc 	zTemp2+1
.ab8a	10 e2		bpl $ab6e			bpl 	_TIMSM_Start
.ab8c					_TIMSM_Ends:
.ab8c	4c 1c ab	jmp $ab1c			jmp 	TIM_NewCommand
.ab8f					TIM_Execute:
.ab8f	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; get the execute address
.ab92	b0 81		bcs $ab15			bcs 	TIM_Error 					; not legitimate
.ab94	ae c2 03	ldx $03c2			ldx 	TIM_SP 						; set up SP
.ab97	9a		txs				txs
.ab98	ad bd 03	lda $03bd			lda 	TIM_SR 						; Status for PLP
.ab9b	48		pha				pha
.ab9c	ad be 03	lda $03be			lda 	TIM_A 						; restore AXYZ
.ab9f	ae bf 03	ldx $03bf			ldx 	TIM_X
.aba2	ac c0 03	ldy $03c0			ldy 	TIM_Y
.aba5	ab c1 03	ldz $03c1			ldz 	TIM_Z
.aba8	28		plp				plp 								; and PS Byte.
.aba9	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.abac					TIM_Start:
.abac					TIM_ShowRegisters:
.abac	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.abaf	8d bc 03	sta $03bc			sta 	TIM_IRQ+1
.abb2	ad ff ff	lda $ffff			lda 	$FFFF
.abb5	8d bb 03	sta $03bb			sta 	TIM_IRQ
.abb8	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.abba					_TIMSR_Text:
.abba	bd e6 ab	lda $abe6,x			lda 	_TIMSR_Label,x
.abbd	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.abc0	e8		inx				inx
.abc1	e0 23		cpx #$23			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.abc3	d0 f5		bne $abba			bne 	_TIMSR_Text
.abc5	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.abc7					_TIMSR_Skip:
.abc7	e8		inx				inx
.abc8					_TIMSR_LoopSpace:
.abc8	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.abca	b0 04		bcs $abd0			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.abcc	8a		txa				txa
.abcd	4a		lsr a				lsr 	a
.abce	b0 05		bcs $abd5			bcs 	_TIMSR_NoSpace
.abd0					_TIMSR_Space:
.abd0	a9 20		lda #$20			lda 	#" "
.abd2	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.abd5					_TIMSR_NoSpace:
.abd5	bd b9 03	lda $03b9,x			lda 	TIM_PC,x 					; output hex value.
.abd8	20 09 ac	jsr $ac09			jsr 	TIM_WriteHex
.abdb	e8		inx				inx
.abdc	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.abde	d0 e8		bne $abc8			bne 	_TimSR_LoopSpace
.abe0	20 68 a0	jsr $a068			jsr 	IFT_NewLine 				; new line
.abe3	4c 1c ab	jmp $ab1c			jmp	 	TIM_NewCommand 				; new command.
.abe6					_TIMSR_Label:
>abe6	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>abee	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>abfe	52
>abff	20 5a 52					.text 	" ZR"
>ac02	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.ac09					_TIMSR_LabelEnd:
.ac09					TIM_WriteHex:
.ac09	48		pha				pha 								; save A
.ac0a	4a		lsr a				lsr 	a 							; shift MSB->LSB
.ac0b	4a		lsr a				lsr 	a
.ac0c	4a		lsr a				lsr 	a
.ac0d	4a		lsr a				lsr 	a
.ac0e	20 12 ac	jsr $ac12			jsr 	_TIMWH_Nibble 				; print MSB
.ac11	68		pla				pla 								; restore and print LSB
.ac12					_TIMWH_Nibble:
.ac12	48		pha				pha
.ac13	29 0f		and #$0f			and 	#15 						; mask out
.ac15	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.ac17	90 02		bcc $ac1b			bcc 	_TIMWHNoLetter
.ac19	69 06		adc #$06			adc 	#6
.ac1b					_TIMWHNoLetter:
.ac1b	69 30		adc #$30			adc 	#48
.ac1d	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter 			; print it out.
.ac20	68		pla				pla
.ac21	60		rts				rts
.ac22					TIM_WriteLine:
.ac22	a9 2e		lda #$2e			lda 	#"." 						; prompt
.ac24	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.ac27	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.ac29	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.ac2c	a5 13		lda $13				lda 	zTemp2+1 					; write address
.ac2e	20 09 ac	jsr $ac09			jsr 	TIM_WriteHex
.ac31	a5 12		lda $12				lda 	zTemp2
.ac33	20 09 ac	jsr $ac09			jsr 	TIM_WriteHex
.ac36	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.ac38					_TIMWL_Loop:
.ac38	a9 20		lda #$20			lda 	#" "
.ac3a	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.ac3d	b1 12		lda ($12),y			lda 	(zTemp2),y
.ac3f	20 09 ac	jsr $ac09			jsr 	TIM_WriteHex
.ac42	c8		iny				iny
.ac43	c0 10		cpy #$10			cpy 	#16
.ac45	d0 f1		bne $ac38			bne 	_TIMWL_Loop
.ac47	4c 68 a0	jmp $a068			jmp 	IFT_NewLine 				; new line and exit
.ac4a					TIM_GetHex:
.ac4a	c8		iny				iny
.ac4b	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.ac4d	c9 20		cmp #$20			cmp 	#32
.ac4f	f0 f9		beq $ac4a			beq 	TIM_GetHex
.ac51	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.ac53	f0 f5		beq $ac4a			beq 	TIM_GetHex
.ac55	20 7e ac	jsr $ac7e			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.ac58	b0 23		bcs $ac7d			bcs 	_TIMGH_Exit					; if first bad then exit now.
.ac5a	a9 00		lda #$00			lda 	#0 							; zero result
.ac5c	85 14		sta $14				sta 	zTemp3
.ac5e	85 15		sta $15				sta 	zTemp3+1
.ac60					_TIM_GHLoop:
.ac60	20 7e ac	jsr $ac7e			jsr 	TIM_GetHexCharacter 		; get next character
.ac63	b0 17		bcs $ac7c			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.ac65	c8		iny				iny 								; skip over it.
.ac66	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.ac68	26 15		rol $15				rol 	zTemp3+1
.ac6a	06 14		asl $14				asl 	zTemp3 						; now x 2
.ac6c	26 15		rol $15				rol 	zTemp3+1
.ac6e	06 14		asl $14				asl 	zTemp3						; now x 4
.ac70	26 15		rol $15				rol 	zTemp3+1
.ac72	06 14		asl $14				asl 	zTemp3 						; now x 8
.ac74	26 15		rol $15				rol 	zTemp3+1
.ac76	05 14		ora $14				ora 	zTemp3 						; OR result in
.ac78	85 14		sta $14				sta 	zTemp3
.ac7a	80 e4		bra $ac60			bra 	_TIM_GHLoop 				; loop round again.
.ac7c					_TIMGH_Okay:
.ac7c	18		clc				clc
.ac7d					_TIMGH_Exit:
.ac7d	60		rts				rts
.ac7e					TIM_GetHexCharacter:
.ac7e	b1 10		lda ($10),y			lda 	(zTemp1),y
.ac80	38		sec				sec
.ac81	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.ac83	90 0e		bcc $ac93			bcc 	_TIM_GHCFail
.ac85	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.ac87	90 0b		bcc $ac94			bcc 	_TIM_GHCExit
.ac89	c9 11		cmp #$11			cmp 	#65-48						; < A
.ac8b	90 06		bcc $ac93			bcc		_TIM_GHCFail
.ac8d	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.ac8f	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.ac91	90 01		bcc $ac94			bcc		_TIM_GHCExit
.ac93					_TIM_GHCFail:
.ac93	38		sec				sec
.ac94					_TIM_GHCExit:
.ac94	60		rts				rts
.ac95					TIM_BreakVector:
.ac95	da		phx				phx									; save X/A on stack
.ac96	48		pha				pha
.ac97	ba		tsx				tsx 								; X points to S
.ac98	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.ac9b	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.ac9d	d0 03		bne $aca2			bne 	_TIMBreak					; if set, it's BRK
.ac9f	68		pla				pla 								; abandon routine.
.aca0	fa		plx				plx
.aca1	40		rti				rti
.aca2					_TIMBreak:
.aca2	68		pla				pla 								; save A X Y and maybe Z
.aca3	8d be 03	sta $03be			sta 	TIM_A
.aca6	fa		plx				plx
.aca7	8e bf 03	stx $03bf			stx 	TIM_X
.acaa	8c c0 03	sty $03c0			sty 	TIM_Y
.acad	9c c1 03	stz $03c1			stz 	TIM_Z
.acb0	68		pla				pla 								; get Status Register
.acb1	8d bd 03	sta $03bd			sta 	TIM_SR
.acb4	68		pla				pla
.acb5	8d ba 03	sta $03ba			sta 	TIM_PC+1 					; save calling address
.acb8	68		pla				pla
.acb9	8d b9 03	sta $03b9			sta 	TIM_PC 						; high byte
.acbc	ad ba 03	lda $03ba			lda 	TIM_PC+1 					; dec PC to point right.
.acbf	d0 03		bne $acc4			bne 	_TIMDecrement 				; brk bumps it.
.acc1	ce b9 03	dec $03b9			dec 	TIM_PC
.acc4					_TIMDecrement:
.acc4	ce ba 03	dec $03ba			dec 	TIM_PC+1
.acc7	ba		tsx				tsx 								; and copy SP
.acc8	8e c2 03	stx $03c2			stx 	TIM_SP
.accb	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.accd	9a		txs				txs
.acce	4c ac ab	jmp $abac			jmp 	TIM_Start 					; and start up TIM monitor.
.acd1					TIM_UpdateRegisters:
.acd1	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; PC
.acd4	b0 23		bcs $acf9			bcs 	_TIMURFail
.acd6	a5 14		lda $14				lda 	zTemp3
.acd8	8d ba 03	sta $03ba			sta 	Tim_PC+1
.acdb	a5 15		lda $15				lda 	zTemp3+1
.acdd	8d b9 03	sta $03b9			sta 	Tim_PC
.ace0	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; ignore IRQ
.ace3	b0 14		bcs $acf9			bcs 	_TIMURFail
.ace5	a2 00		ldx #$00			ldx 	#0
.ace7					_TIM_URLoop:
.ace7	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; registers
.acea	b0 0d		bcs $acf9			bcs 	_TIMURFail
.acec	a5 14		lda $14				lda 	zTemp3
.acee	9d bd 03	sta $03bd,x			sta 	Tim_SR,x
.acf1	e8		inx				inx
.acf2	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.acf4	d0 f1		bne $ace7			bne 	_TIM_URLoop
.acf6	4c 1c ab	jmp $ab1c			jmp 	TIM_NewCommand
.acf9					_TIMURFail:
.acf9	4c 15 ab	jmp $ab15			jmp 	TIM_Error
.acfc					TIM_LoadMemory:
.acfc	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; target address => zTemp2
.acff	a5 14		lda $14				lda 	zTemp3
.ad01	85 12		sta $12				sta 	zTemp2
.ad03	a5 15		lda $15				lda 	zTemp3+1
.ad05	85 13		sta $13				sta 	zTemp2+1
.ad07					_TIM_LMLoop:
.ad07	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; next byte ?
.ad0a	b0 0e		bcs $ad1a			bcs 	_TIMLMDone 					; no more
.ad0c	a2 00		ldx #$00			ldx 	#0							; write out.
.ad0e	a5 14		lda $14				lda 	zTemp3
.ad10	81 12		sta ($12,x)			sta 	(zTemp2,x)
.ad12	e6 12		inc $12				inc 	zTemp2 						; bump address
.ad14	d0 f1		bne $ad07			bne 	_TIM_LMLoop
.ad16	e6 13		inc $13				inc 	zTemp2+1
.ad18	80 ed		bra $ad07			bra 	_TIM_LMLoop
.ad1a					_TIMLMDone:
.ad1a	4c 1c ab	jmp $ab1c			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stack.asm

.ad1d					StackReset:
.ad1d	48		pha				pha
.ad1e	5a		phy				phy
.ad1f	a9 00		lda #$00			lda 	#(BasicStack & $FF) 		; reset pointer
.ad21	85 26		sta $26				sta 	zBasicSP
.ad23	a9 04		lda #$04			lda 	#(BasicStack >> 8)
.ad25	85 27		sta $27				sta 	zBasicSP+1
.ad27	a0 00		ldy #$00			ldy 	#0 							; reset stack top to $00 which cannot
.ad29	98		tya				tya 								; be a legal token.
.ad2a	91 26		sta ($26),y			sta 	(zBasicSP),y
.ad2c	7a		ply				ply
.ad2d	68		pla				pla
.ad2e	60		rts				rts
.ad2f					StackPushFrame:
.ad2f	48		pha				pha
.ad30	5a		phy				phy
.ad31	1a		inc a				inc 	a 							; one extra byte in frame, for the marker.
.ad32	48		pha				pha 								; save it.
.ad33	29 0f		and #$0f			and 	#$0F 						; lower 4 bits
.ad35	18		clc				clc 								; add to Basic Stack
.ad36	65 26		adc $26				adc 	zBasicSP
.ad38	85 26		sta $26				sta 	zBasicSP
.ad3a	90 02		bcc $ad3e			bcc 	_SPFNoBump
.ad3c	e6 27		inc $27				inc 	zBasicSP+1
.ad3e					_SPFNoBump:
.ad3e	a0 00		ldy #$00			ldy 	#0
.ad40	68		pla				pla
.ad41	91 26		sta ($26),y			sta 	(zBasicSP),y
.ad43	7a		ply				ply
.ad44	68		pla				pla
.ad45	60		rts				rts
.ad46					StackPopFrame:
.ad46	48		pha				pha
.ad47	5a		phy				phy
.ad48	a0 00		ldy #$00			ldy 	#0 							; compare with top of stack using EOR
.ad4a	51 26		eor ($26),y			eor 	(zBasicSP),y
.ad4c	29 f0		and #$f0			and 	#$F0 						; top 4 bits zero, match
.ad4e	d0 12		bne $ad62			bne 	_SPFError 					; mixed structures
.ad50	b1 26		lda ($26),y			lda 	(zBasicSP),y 				; get size from byte
.ad52	29 0f		and #$0f			and 	#$0F
.ad54	49 ff		eor #$ff			eor 	#$FF						; 2's complement
.ad56	38		sec				sec
.ad57	65 26		adc $26				adc 	zBasicSP
.ad59	85 26		sta $26				sta 	zBasicSP
.ad5b	b0 02		bcs $ad5f			bcs 	_SPFNoBump
.ad5d	c6 27		dec $27				dec 	zBasicSP+1
.ad5f					_SPFNoBump:
.ad5f	7a		ply				ply
.ad60	68		pla				pla
.ad61	60		rts				rts
.ad62					_SPFError:
.ad62	20 e7 ad	jsr $ade7			jsr ERR_Handler
>ad65	4d 69 78 65 64 20 53 74			.text "Mixed Structures",0
>ad6d	72 75 63 74 75 72 65 73 00
.ad76					StackSavePosition:
.ad76	6b		tza				tza
.ad77	5a		phy				phy
.ad78	a0 05		ldy #$05			ldy 	#5
.ad7a	91 26		sta ($26),y			sta 	(zBasicSP),y
.ad7c	a0 01		ldy #$01			ldy 	#1
.ad7e	a5 16		lda $16				lda 	zCodePtr+0 					; 4 bytes, could reduce this for 65816/6502
.ad80	91 26		sta ($26),y			sta 	(zBasicSP),y
.ad82	c8		iny				iny
.ad83	a5 17		lda $17				lda 	zCodePtr+1
.ad85	91 26		sta ($26),y			sta 	(zBasicSP),y
.ad87	c8		iny				iny
.ad88	a5 18		lda $18				lda 	zCodePtr+2
.ad8a	91 26		sta ($26),y			sta 	(zBasicSP),y
.ad8c	c8		iny				iny
.ad8d	a5 19		lda $19				lda 	zCodePtr+3
.ad8f	91 26		sta ($26),y			sta 	(zBasicSP),y
.ad91	7a		ply				ply
.ad92	60		rts				rts
.ad93					StackRestorePosition:
.ad93	5a		phy				phy
.ad94	a0 01		ldy #$01			ldy 	#1 							; copy 4 bytes that are the pointer
.ad96	b1 26		lda ($26),y			lda 	(zBasicSP),y
.ad98	85 16		sta $16				sta 	zCodePtr+0
.ad9a	c8		iny				iny
.ad9b	b1 26		lda ($26),y			lda 	(zBasicSP),y
.ad9d	85 17		sta $17				sta 	zCodePtr+1
.ad9f	c8		iny				iny
.ada0	b1 26		lda ($26),y			lda 	(zBasicSP),y
.ada2	85 18		sta $18				sta 	zCodePtr+2
.ada4	c8		iny				iny
.ada5	b1 26		lda ($26),y			lda 	(zBasicSP),y
.ada7	85 19		sta $19				sta 	zCodePtr+3
.ada9	c8		iny				iny
.adaa	b1 26		lda ($26),y			lda 	(zBasicSP),y 				; offset
.adac	7a		ply				ply 								; restore Y
.adad	4b		taz				taz
.adae	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/vectors.asm

.adaf					CharPrint:
.adaf	4c 41 a0	jmp $a041			jmp 	IFT_PrintCharacter
.adb2					CharGet:
.adb2	4c 06 a2	jmp $a206			jmp 	IF_GetKey
.adb5					CheckBreak:
.adb5	4c f1 a1	jmp $a1f1			jmp 	IF_CheckBreak

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/errors.asm

.adb8					SyntaxError:
.adb8	20 e7 ad	jsr $ade7			jsr 	ERR_Handler
>adbb	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>adc3	72 72 6f 72 00
.adc8					TypeError:
.adc8	20 e7 ad	jsr $ade7			jsr 	ERR_Handler
>adcb	57 72 6f 6e 67 20 74 79				.text 	"Wrong type",0
>add3	70 65 00
.add6					BadParamError:
.add6	20 e7 ad	jsr $ade7			jsr 	ERR_Handler
>add9	42 61 64 20 50 61 72 61				.text 	"Bad Parameter",0
>ade1	6d 65 74 65 72 00
.ade7					ERR_Handler:
.ade7	a3 00		ldz #$00			ldz 	#0
.ade9	1b		inz				inz
.adea	ea		nop				nop
.adeb	b2 16		lda ($16),z			lda 	(zCodePtr),z
.aded	85 80		sta $80				sta 	XS_Mantissa
.adef	1b		inz				inz
.adf0	ea		nop				nop
.adf1	b2 16		lda ($16),z			lda 	(zCodePtr),z
.adf3	85 81		sta $81				sta 	XS_Mantissa+1
.adf5	fa		plx				plx 								; address in XY
.adf6	7a		ply				ply
.adf7	e8		inx				inx 								; bump, because of RTS/JSR address -1
.adf8	d0 01		bne $adfb			bne 	_EHNoSkip
.adfa	c8		iny				iny
.adfb					_EHNoSkip:
.adfb	20 1a ae	jsr $ae1a			jsr 	PrintROMMessage 			; print message from ROM.
.adfe	a5 80		lda $80				lda 	XS_Mantissa					; line number = 0
.ae00	05 81		ora $81				ora 	XS_Mantissa+1
.ae02	f0 0c		beq $ae10			beq 	_EHNoLine
.ae04	a2 15		ldx #$15			ldx 	#_EHAt & $FF 				; print " at "
.ae06	a0 ae		ldy #$ae			ldy 	#(_EHAt >> 8) & $FF
.ae08	20 1a ae	jsr $ae1a			jsr 	PrintROMMessage
.ae0b	a2 00		ldx #$00			ldx 	#0 							; Print line number
.ae0d	20 2b ae	jsr $ae2b			jsr 	Print16BitInteger
.ae10					_EHNoLine:
.ae10	80 fe		bra $ae10			bra 	_EHNoLine
.ae12	4c 90 b0	jmp $b090			jmp 	WarmStart
>ae15	20 61 74 20 00			_EHAt:	.text 	" at ",0
.ae1a					PrintROMMessage:
.ae1a	86 1a		stx $1a				stx 	zLTemp1 					; save addres
.ae1c	84 1b		sty $1b				sty 	zLTemp1+1
.ae1e	a0 00		ldy #$00			ldy 	#0
.ae20					_PRMLoop:
.ae20	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.ae22	f0 06		beq $ae2a			beq		_PRMExit
.ae24	c8		iny				iny
.ae25	20 af ad	jsr $adaf			jsr 	CharPrint
.ae28	80 f6		bra $ae20			bra 	_PRMLoop
.ae2a					_PRMExit:
.ae2a	60		rts				rts
.ae2b					Print16BitInteger:
.ae2b	a9 00		lda #$00			lda 	#0 							; make 32 bit
.ae2d	85 82		sta $82				sta 	XS_Mantissa+2
.ae2f	85 83		sta $83				sta 	XS_Mantissa+3
.ae31					Print32BitInteger:
.ae31	a9 00		lda #$00			lda 	#0
.ae33	8d 14 03	sta $0314			sta 	NumBufX 					; reset the conversion pointer
.ae36	aa		tax				tax 								; convert bottom level.
.ae37	20 5e c3	jsr $c35e			jsr 	INTToString 				; make string
.ae3a	a2 00		ldx #$00			ldx 	#0 							; print buffer
.ae3c	bd 15 03	lda $0315,x	_P1Loop:lda 	Num_Buffer,x
.ae3f	f0 06		beq $ae47			beq 	_P1Exit
.ae41	20 af ad	jsr $adaf			jsr 	CharPrint
.ae44	e8		inx				inx
.ae45	80 f5		bra $ae3c			bra 	_P1Loop
.ae47	8a		txa		_P1Exit:txa 								; return chars printed.
.ae48	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm


;******  Processing file: modules/basic/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b6					lastUnaryFunction = $b6
.ae49					VectorTable:
>ae49	c1 b7					.word BinaryOp_And         & $FFFF ; $80 and
>ae4b	dd b7					.word BinaryOp_Or          & $FFFF ; $81 or
>ae4d	f9 b7					.word BinaryOp_Xor         & $FFFF ; $82 xor
>ae4f	f9 b7					.word BinaryOp_Eor         & $FFFF ; $83 eor
>ae51	30 b8					.word Binary_Equal         & $FFFF ; $84 =
>ae53	4a b8					.word Binary_NotEqual      & $FFFF ; $85 <>
>ae55	53 b8					.word Binary_Less          & $FFFF ; $86 <
>ae57	5c b8					.word Binary_LessEqual     & $FFFF ; $87 <=
>ae59	6e b8					.word Binary_Greater       & $FFFF ; $88 >
>ae5b	65 b8					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>ae5d	f3 b8					.word BinaryOp_Add         & $FFFF ; $8a +
>ae5f	0f b9					.word BinaryOp_Subtract    & $FFFF ; $8b -
>ae61	20 b9					.word BinaryOp_Multiply    & $FFFF ; $8c *
>ae63	31 b9					.word BinaryOp_Divide      & $FFFF ; $8d /
>ae65	05 af					.word NotImplemented       & $FFFF ; $8e ^
>ae67	05 af					.word NotImplemented       & $FFFF ; $8f if
>ae69	2c b5					.word Command_WHILE        & $FFFF ; $90 while
>ae6b	de b5					.word Command_REPEAT       & $FFFF ; $91 repeat
>ae6d	05 af					.word NotImplemented       & $FFFF ; $92 for
>ae6f	05 af					.word NotImplemented       & $FFFF ; $93 then
>ae71	05 af					.word NotImplemented       & $FFFF ; $94 endif
>ae73	48 b5					.word Command_WEND         & $FFFF ; $95 wend
>ae75	e7 b5					.word Command_UNTIL        & $FFFF ; $96 until
>ae77	05 af					.word NotImplemented       & $FFFF ; $97 next
>ae79	05 af					.word NotImplemented       & $FFFF ; $98 not
>ae7b	05 af					.word NotImplemented       & $FFFF ; $99 fn(
>ae7d	36 ba					.word Unary_Abs            & $FFFF ; $9a abs(
>ae7f	76 bb					.word Unary_Asc            & $FFFF ; $9b asc(
>ae81	49 ca					.word Unary_Int            & $FFFF ; $9c int(
>ae83	50 ba					.word Unary_Peek           & $FFFF ; $9d peek(
>ae85	ca c9					.word Unary_Rnd            & $FFFF ; $9e rnd(
>ae87	b7 ba					.word Unary_Usr            & $FFFF ; $9f usr(
>ae89	b5 bb					.word Unary_Left           & $FFFF ; $a0 left$(
>ae8b	ca bb					.word Unary_Right          & $FFFF ; $a1 right$(
>ae8d	9c bb					.word Unary_Mid            & $FFFF ; $a2 mid$(
>ae8f	13 bd					.word Unary_Spc            & $FFFF ; $a3 spc(
>ae91	44 bb					.word Unary_Str            & $FFFF ; $a4 str$(
>ae93	d8 ba					.word Unary_Val            & $FFFF ; $a5 val(
>ae95	8d bb					.word Unary_Len            & $FFFF ; $a6 len(
>ae97	42 bc					.word Unary_Hex            & $FFFF ; $a7 hex$(
>ae99	05 af					.word NotImplemented       & $FFFF ; $a8 sin(
>ae9b	05 af					.word NotImplemented       & $FFFF ; $a9 cos(
>ae9d	05 af					.word NotImplemented       & $FFFF ; $aa tan(
>ae9f	05 af					.word NotImplemented       & $FFFF ; $ab atn(
>aea1	05 af					.word NotImplemented       & $FFFF ; $ac exp(
>aea3	05 af					.word NotImplemented       & $FFFF ; $ad log(
>aea5	05 af					.word NotImplemented       & $FFFF ; $ae sqr(
>aea7	98 bc					.word Unary_Dec            & $FFFF ; $af dec(
>aea9	54 ba					.word Unary_Deek           & $FFFF ; $b0 deek(
>aeab	58 ba					.word Unary_Leek           & $FFFF ; $b1 leek(
>aead	84 ba					.word Unary_Mod            & $FFFF ; $b2 mod(
>aeaf	f0 b9					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>aeb1	f5 bc					.word Unary_Chr            & $FFFF ; $b4 chr$(
>aeb3	05 af					.word NotImplemented       & $FFFF ; $b5 pos(
>aeb5	05 af					.word NotImplemented       & $FFFF ; $b6 tab(
>aeb7	05 af					.word NotImplemented       & $FFFF ; $b7 $
>aeb9	05 af					.word NotImplemented       & $FFFF ; $b8 $(
>aebb	05 af					.word NotImplemented       & $FFFF ; $b9 #
>aebd	05 af					.word NotImplemented       & $FFFF ; $ba #(
>aebf	05 af					.word NotImplemented       & $FFFF ; $bb %
>aec1	05 af					.word NotImplemented       & $FFFF ; $bc %(
>aec3	05 af					.word NotImplemented       & $FFFF ; $bd (
>aec5	05 af					.word NotImplemented       & $FFFF ; $be )
>aec7	05 af					.word NotImplemented       & $FFFF ; $bf ,
>aec9	b2 b1					.word Command_COLON        & $FFFF ; $c0 :
>aecb	05 af					.word NotImplemented       & $FFFF ; $c1 ;
>aecd	05 af					.word NotImplemented       & $FFFF ; $c2 def
>aecf	10 b5					.word Command_CLR          & $FFFF ; $c3 clr
>aed1	24 b5					.word Command_STOP         & $FFFF ; $c4 stop
>aed3	05 af					.word NotImplemented       & $FFFF ; $c5 data
>aed5	05 af					.word NotImplemented       & $FFFF ; $c6 read
>aed7	95 b0					.word Command_DIM          & $FFFF ; $c7 dim
>aed9	05 af					.word NotImplemented       & $FFFF ; $c8 to
>aedb	05 af					.word NotImplemented       & $FFFF ; $c9 step
>aedd	86 b4					.word Command_GOSUB        & $FFFF ; $ca gosub
>aedf	94 b4					.word Command_RETURN       & $FFFF ; $cb return
>aee1	80 b4					.word Command_GOTO         & $FFFF ; $cc goto
>aee3	d4 b1					.word Command_END          & $FFFF ; $cd end
>aee5	05 af					.word NotImplemented       & $FFFF ; $ce input
>aee7	b3 b1					.word Command_LET          & $FFFF ; $cf let
>aee9	d9 b1					.word Command_LIST         & $FFFF ; $d0 list
>aeeb	22 b4					.word Command_NEW          & $FFFF ; $d1 new
>aeed	41 b4					.word Command_OLD          & $FFFF ; $d2 old
>aeef	05 af					.word NotImplemented       & $FFFF ; $d3 on
>aef1	05 af					.word NotImplemented       & $FFFF ; $d4 restore
>aef3	f1 b3					.word Command_POKE         & $FFFF ; $d5 poke
>aef5	68 b3					.word Command_PRINT        & $FFFF ; $d6 print
>aef7	1f b1					.word Command_RUN          & $FFFF ; $d7 run
>aef9	05 af					.word NotImplemented       & $FFFF ; $d8 wait
>aefb	05 af					.word NotImplemented       & $FFFF ; $d9 sys
>aefd	f5 b3					.word Command_DOKE         & $FFFF ; $da doke
>aeff	f9 b3					.word Command_LOKE         & $FFFF ; $db loke
>af01	d9 b3					.word Command_ASSERT       & $FFFF ; $dc assert
>af03	05 af					.word NotImplemented       & $FFFF ; $dd get
.af05					NotImplemented:
.af05	20 e7 ad	jsr $ade7			jsr ERR_Handler
>af08	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>af10	65 6d 65 6e 74 65 64 00
.af18					BinaryPrecedence:
>af18	01					.byte 1    ; $80 and
>af19	01					.byte 1    ; $81 or
>af1a	01					.byte 1    ; $82 xor
>af1b	01					.byte 1    ; $83 eor
>af1c	02					.byte 2    ; $84 =
>af1d	02					.byte 2    ; $85 <>
>af1e	02					.byte 2    ; $86 <
>af1f	02					.byte 2    ; $87 <=
>af20	02					.byte 2    ; $88 >
>af21	02					.byte 2    ; $89 >=
>af22	03					.byte 3    ; $8a +
>af23	03					.byte 3    ; $8b -
>af24	04					.byte 4    ; $8c *
>af25	04					.byte 4    ; $8d /
>af26	05					.byte 5    ; $8e ^
.af27					KeywordText:
>af27	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>af2a	4f d2					.byte $4f,$d2                          ; $81 or
>af2c	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>af2f	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>af32	bd					.byte $bd                              ; $84 =
>af33	3c be					.byte $3c,$be                          ; $85 <>
>af35	bc					.byte $bc                              ; $86 <
>af36	3c bd					.byte $3c,$bd                          ; $87 <=
>af38	be					.byte $be                              ; $88 >
>af39	3e bd					.byte $3e,$bd                          ; $89 >=
>af3b	ab					.byte $ab                              ; $8a +
>af3c	ad					.byte $ad                              ; $8b -
>af3d	aa					.byte $aa                              ; $8c *
>af3e	af					.byte $af                              ; $8d /
>af3f	de					.byte $de                              ; $8e ^
>af40	49 c6					.byte $49,$c6                          ; $8f if
>af42	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>af47	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>af4d	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>af50	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>af54	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>af59	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>af5d	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>af62	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>af66	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>af69	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>af6c	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>af70	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>af74	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>af78	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>af7d	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>af81	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>af85	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>af8b	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>af92	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>af97	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>af9b	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>afa0	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>afa4	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>afa8	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>afad	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>afb1	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>afb5	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>afb9	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>afbd	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>afc1	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>afc5	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>afc9	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>afcd	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>afd2	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>afd7	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>afdb	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>afdf	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>afe4	50 4f 53 a8				.byte $50,$4f,$53,$a8                  ; $b5 pos(
>afe8	54 41 42 a8				.byte $54,$41,$42,$a8                  ; $b6 tab(
>afec	a4					.byte $a4                              ; $b7 $
>afed	24 a8					.byte $24,$a8                          ; $b8 $(
>afef	a3					.byte $a3                              ; $b9 #
>aff0	23 a8					.byte $23,$a8                          ; $ba #(
>aff2	a5					.byte $a5                              ; $bb %
>aff3	25 a8					.byte $25,$a8                          ; $bc %(
>aff5	a8					.byte $a8                              ; $bd (
>aff6	a9					.byte $a9                              ; $be )
>aff7	ac					.byte $ac                              ; $bf ,
>aff8	ba					.byte $ba                              ; $c0 :
>aff9	bb					.byte $bb                              ; $c1 ;
>affa	44 45 c6				.byte $44,$45,$c6                      ; $c2 def
>affd	43 4c d2				.byte $43,$4c,$d2                      ; $c3 clr
>b000	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $c4 stop
>b004	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c5 data
>b008	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c6 read
>b00c	44 49 cd				.byte $44,$49,$cd                      ; $c7 dim
>b00f	54 cf					.byte $54,$cf                          ; $c8 to
>b011	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c9 step
>b015	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $ca gosub
>b01a	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $cb return
>b020	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $cc goto
>b024	45 4e c4				.byte $45,$4e,$c4                      ; $cd end
>b027	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $ce input
>b02c	4c 45 d4				.byte $4c,$45,$d4                      ; $cf let
>b02f	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $d0 list
>b033	4e 45 d7				.byte $4e,$45,$d7                      ; $d1 new
>b036	4f 4c c4				.byte $4f,$4c,$c4                      ; $d2 old
>b039	4f ce					.byte $4f,$ce                          ; $d3 on
>b03b	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d4 restore
>b042	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d5 poke
>b046	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d6 print
>b04b	52 55 ce				.byte $52,$55,$ce                      ; $d7 run
>b04e	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d8 wait
>b052	53 59 d3				.byte $53,$59,$d3                      ; $d9 sys
>b055	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $da doke
>b059	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $db loke
>b05d	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $dc assert
>b063	47 45 d4				.byte $47,$45,$d4                      ; $dd get
>b066	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_pos = $b5
=$b6					token_tab = $b6
=$b7					token_dollar = $b7
=$b8					token_dollarlparen = $b8
=$b9					token_hash = $b9
=$ba					token_hashlparen = $ba
=$bb					token_percent = $bb
=$bc					token_percentlparen = $bc
=$bd					token_lparen = $bd
=$be					token_rparen = $be
=$bf					token_comma = $bf
=$c0					token_colon = $c0
=$c1					token_semicolon = $c1
=$c2					token_def = $c2
=$c3					token_clr = $c3
=$c4					token_stop = $c4
=$c5					token_data = $c5
=$c6					token_read = $c6
=$c7					token_dim = $c7
=$c8					token_to = $c8
=$c9					token_step = $c9
=$ca					token_gosub = $ca
=$cb					token_return = $cb
=$cc					token_goto = $cc
=$cd					token_end = $cd
=$ce					token_input = $ce
=$cf					token_let = $cf
=$d0					token_list = $d0
=$d1					token_new = $d1
=$d2					token_old = $d2
=$d3					token_on = $d3
=$d4					token_restore = $d4
=$d5					token_poke = $d5
=$d6					token_print = $d6
=$d7					token_run = $d7
=$d8					token_wait = $d8
=$d9					token_sys = $d9
=$da					token_doke = $da
=$db					token_loke = $db
=$dc					token_assert = $dc
=$dd					token_get = $dd

;******  Return to file: modules/basic/core.asm

.b067					BASIC_Start:
.b067	20 4d a2	jsr $a24d			jsr 	IF_Reset 					; set up and clear screen.
.b06a	20 0c a0	jsr $a00c			jsr 	IFT_ClearScreen
.b06d	a9 4c		lda #$4c			lda 	#$4C 						; JMP opcode
.b06f	8d 10 03	sta $0310			sta 	LocalVector
.b072	8d 0c 03	sta $030c			sta 	UserVector
.b075	a9 c6		lda #$c6			lda 	#USRDefault & $FF 			; reset USR vector
.b077	8d 0d 03	sta $030d			sta 	UserVector+1
.b07a	a9 ba		lda #$ba			lda 	#(USRDefault >> 8) & $FF
.b07c	8d 0e 03	sta $030e			sta 	UserVector+2
.b07f	a9 00		lda #$00			lda 	#(USRDefault >> 16) & $FF
.b081	8d 0f 03	sta $030f			sta 	UserVector+3
.b084	20 73 bd	jsr $bd73			jsr 	UpdateProgramEnd 			; update the program end.
.b087	20 10 b5	jsr $b510			jsr 	ResetRunStatus 				; clear everything (CLR command)
.b08a	a2 ff		ldx #$ff			ldx 		#$FF 					; empty stack
.b08c	9a		txs				txs
.b08d	4c 1f b1	jmp $b11f			jmp 	COMMAND_Run
.b090					WarmStart:
.b090	a2 ff		ldx #$ff			ldx 		#$FF 					; empty stack
.b092	9a		txs				txs
.b093	80 fb		bra $b090			bra 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/dim.asm

.b095					Command_DIM:
.b095	6b		tza				tza
.b096	48		pha				pha 								; push on stack.
.b097	20 e5 be	jsr $bee5			jsr 	VariableExtract 			; get the identifier
.b09a	ad 95 03	lda $0395			lda 	Var_Type 					; check it is an array
.b09d	29 01		and #$01			and 	#1
.b09f	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.b0a1	d0 6e		bne $b111			bne 	_CDIError
.b0a3	a9 00		lda #$00			lda 	#0 							; reset the DIM index. The dimensions are
.b0a5	8d b8 03	sta $03b8			sta 	UsrArrayIdx 				; built up here and copied in case we autodim
.b0a8					_CDIGetDimension:
.b0a8	ad b8 03	lda $03b8			lda 	UsrArrayIdx 				; done too many ?
.b0ab	c9 06		cmp #$06			cmp 	#ArrayMaxDim*2
.b0ad	f0 62		beq $b111			beq 	_CDIError
.b0af	20 a2 b7	jsr $b7a2			jsr 	EvaluateInteger 			; evaluate an index size
.b0b2	a5 81		lda $81				lda 	XS_Mantissa+1 				; check in range 0-7FFF
.b0b4	29 80		and #$80			and 	#$80
.b0b6	05 82		ora $82				ora 	XS_Mantissa+2
.b0b8	05 83		ora $83				ora 	XS_Mantissa+3
.b0ba	d0 55		bne $b111			bne 	_CDIError
.b0bc	ae b8 03	ldx $03b8			ldx 	UsrArrayIdx 				; copy into the array table.
.b0bf	18		clc				clc 								; add 1 - max index => size.
.b0c0	a5 80		lda $80				lda 	XS_Mantissa+0
.b0c2	69 01		adc #$01			adc 	#1
.b0c4	9d b0 03	sta $03b0,x			sta 	UsrArrayDef+0,x
.b0c7	a5 81		lda $81				lda 	XS_Mantissa+1
.b0c9	69 00		adc #$00			adc 	#0
.b0cb	9d b1 03	sta $03b1,x			sta 	UsrArrayDef+1,x
.b0ce	30 41		bmi $b111			bmi 	_CDIError 					; could be dim a(32767)
.b0d0	e8		inx				inx 								; bump index.
.b0d1	e8		inx				inx
.b0d2	8e b8 03	stx $03b8			stx 	UsrArrayIdx
.b0d5	ea		nop				nop
.b0d6	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b0d8	1b		inz				inz
.b0d9	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another dimension
.b0db	f0 cb		beq $b0a8			beq 	_CDIGetDimension
.b0dd	3b		dez				dez
.b0de	20 d4 bd	jsr $bdd4			jsr 	CheckNextRParen 			; closing ) present ?
.b0e1	ae b8 03	ldx $03b8			ldx 	UsrArrayIdx 				; copy USR array to default
.b0e4	a9 ff		lda #$ff			lda 	#$FF 						; put end marker in ArrayDef
.b0e6	9d a9 03	sta $03a9,x			sta 	ArrayDef+1,x
.b0e9					_CDICopy:
.b0e9	bd b0 03	lda $03b0,x			lda 	UsrArrayDef,x
.b0ec	9d a8 03	sta $03a8,x			sta 	ArrayDef,x
.b0ef	ca		dex				dex
.b0f0	10 f7		bpl $b0e9			bpl 	_CDICopy
.b0f2	68		pla				pla									; position of array identifier
.b0f3	85 10		sta $10				sta 	zTemp1
.b0f5	6b		tza				tza
.b0f6	48		pha				pha
.b0f7	a5 10		lda $10				lda 	zTemp1 						; point to identifier
.b0f9	4b		taz				taz
.b0fa	20 e5 be	jsr $bee5			jsr 	VariableExtract 			; get the identifier
.b0fd	20 80 c1	jsr $c180			jsr 	VariableLocate 				; check if it exists already.
.b100	b0 0f		bcs $b111			bcs 	_CDIError
.b102	20 73 bf	jsr $bf73			jsr 	VariableCreate 				; create it using the current ArrayDef
.b105	68		pla				pla 								; restore code position
.b106	4b		taz				taz
.b107	ea		nop				nop
.b108	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b10a	1b		inz				inz
.b10b	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another DIM
.b10d	f0 86		beq $b095			beq 	Command_DIM
.b10f	3b		dez				dez
.b110	60		rts				rts
.b111					_CDIError:
.b111	20 e7 ad	jsr $ade7			jsr ERR_Handler
>b114	42 61 64 20 44 49 4d 00			.text "Bad DIM",0
.b11c					_CDISyntax:
.b11c	4c b8 ad	jmp $adb8			jmp 	SyntaxError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/run.asm

.b11f					Command_RUN:
.b11f	20 10 b5	jsr $b510			jsr 	ResetRunStatus 				; clear, reset stacks etc.
.b122	a9 00		lda #$00			lda 	#BasicProgram & $FF
.b124	85 16		sta $16				sta 	zCodePtr+0
.b126	a9 80		lda #$80			lda 	#BasicProgram >> 8
.b128	85 17		sta $17				sta 	zCodePtr+1
.b12a	a9 02		lda #$02			lda 	#2
.b12c	85 18		sta $18				sta 	zCodePtr+2
.b12e	a9 00		lda #$00			lda 	#0
.b130	85 19		sta $19				sta 	zCodePtr+3
.b132	a3 03		ldz #$03			ldz 	#3
.b134					RUN_NewLine:
.b134	a3 00		ldz #$00			ldz 	#0
.b136	ea		nop				nop
.b137	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b139	1b		inz				inz
.b13a	1b		inz				inz
.b13b	1b		inz				inz
.b13c	c9 00		cmp #$00			cmp 	#0 							; if the offset is zero then END.
.b13e	d0 18		bne $b158			bne 	RUN_NextCommand
.b140	4c d4 b1	jmp $b1d4			jmp 	Command_END 				; go do the command code.
.b143					RUN_Skip:
.b143	ea		nop				nop
.b144	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read element
.b146	1b		inz				inz 								; skip
.b147	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.b149	90 0d		bcc $b158			bcc 	_SEDone 					; so just skip over it.
.b14b	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.b14d	90 08		bcc $b157			bcc 	_SEDouble
.b14f	6b		tza				tza 								; this is Y + 1
.b150	18		clc				clc
.b151	ea		nop				nop
.b152	72 16		adc ($16),z			adc 	(zCodePtr),z 				; add total length of element
.b154	4b		taz				taz 								; back in Y.
.b155	3b		dez				dez 								; fix up, one for the +1, one for the iny
.b156	3b		dez				dez
.b157					_SEDouble:
.b157	1b		inz				inz
.b158					_SEDone:
.b158					RUN_NextCommand:
.b158	ad a7 03	lda $03a7			lda 	BreakCount 					; break counter
.b15b	69 10		adc #$10			adc 	#16 						; one time in 16
.b15d	8d a7 03	sta $03a7			sta 	BreakCount
.b160	90 0a		bcc $b16c			bcc 	RUN_NoCheckBreak
.b162	20 b5 ad	jsr $adb5			jsr 	CheckBreak 					; check for break
.b165	c9 00		cmp #$00			cmp 	#0
.b167	f0 03		beq $b16c			beq 	RUN_NoCheckBreak
.b169	4c 24 b5	jmp $b524			jmp 	Command_STOP 				; stop on BREAK.
.b16c					RUN_NoCheckBreak:
.b16c	a9 00		lda #$00			lda 	#0 							; this resets temporary string allocation.
.b16e	85 21		sta $21				sta 	zTempStr+1 					; (initialised when first called)
.b170	ea		nop				nop
.b171	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b173	c9 c0		cmp #$c0			cmp 	#token_Colon 				; skip over colons
.b175	f0 cc		beq $b143			beq 	RUN_Skip
.b177	c9 00		cmp #$00			cmp 	#0 							; if non-zero execute whatever
.b179	d0 10		bne $b18b			bne 	RUN_Execute
.b17b					RUN_NextLine:
.b17b	a3 00		ldz #$00			ldz 	#0 							; point to offset
.b17d	ea		nop				nop
.b17e	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read it
.b180	18		clc				clc
.b181	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.b183	85 16		sta $16				sta 	zCodePtr
.b185	90 02		bcc $b189			bcc 	_SNLNoCarry
.b187	e6 17		inc $17				inc 	zCodePtr+1
.b189					_SNLNoCarry:
.b189	80 a9		bra $b134			bra 	RUN_NewLine 				; go do the new line code
.b18b					RUN_Execute:
.b18b	c9 f8		cmp #$f8			cmp 	#$F8 						; handle shifts, REM etc.
.b18d	b0 1c		bcs $b1ab			bcs 	RUN_Extension
.b18f	1b		inz				inz
.b190	0a		asl a				asl 	a 							; double the character read.
.b191	90 12		bcc $b1a5			bcc 	RUN_Default 				; if carry clear was $00-$7F, so try LET.
.b193	aa		tax				tax 								; ready to look up.
.b194	bd 49 ae	lda $ae49,x			lda 	VectorTable,x 				; copy address into LocalVector
.b197	8d 11 03	sta $0311			sta 	LocalVector+1
.b19a	bd 4a ae	lda $ae4a,x			lda 	VectorTable+1,x
.b19d	8d 12 03	sta $0312			sta 	LocalVector+2
.b1a0	20 eb b6	jsr $b6eb			jsr 	EVCallLocalVector 			; execute the appropriate code.
.b1a3	80 b3		bra $b158			bra 	RUN_NextCommand 			; do the next command.
.b1a5					RUN_Default:
.b1a5	3b		dez				dez
.b1a6	20 b3 b1	jsr $b1b3			jsr 	Command_LET 				; and try LET.
.b1a9	80 ad		bra $b158			bra 	RUN_NextCommand
.b1ab					RUN_Extension:
.b1ab	c9 ff		cmp #$ff			cmp 	#$FF 						; if $FF (REM)
.b1ad	f0 94		beq $b143			beq 	RUN_Skip 					; skip over it.
.b1af	4c b8 ad	jmp $adb8			jmp 	SyntaxError
.b1b2					Command_COLON:
.b1b2	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/let.asm

.b1b3					Command_LET:
.b1b3	20 7a be	jsr $be7a			jsr 	VariableFind 				; get reference to one variable.
.b1b6	a9 84		lda #$84			lda 	#token_Equal  				; get equals
.b1b8	20 bc bd	jsr $bdbc			jsr 	CheckNextToken
.b1bb	a5 22		lda $22				lda 	zVarDataPtr 				; save variable info on stack
.b1bd	48		pha				pha
.b1be	a5 23		lda $23				lda 	zVarDataPtr+1
.b1c0	48		pha				pha
.b1c1	a5 24		lda $24				lda 	zVarType
.b1c3	48		pha				pha
.b1c4	20 05 b6	jsr $b605			jsr 	EvaluateExpression 			; evaluate the RHS.
.b1c7	68		pla				pla 								; restore target variable information.
.b1c8	85 24		sta $24				sta 	zVarType
.b1ca	68		pla				pla
.b1cb	85 23		sta $23				sta 	zVarDataPtr+1
.b1cd	68		pla				pla
.b1ce	85 22		sta $22				sta 	zVarDataPtr
.b1d0	20 15 c2	jsr $c215			jsr 	VariableSet 				; set the value out.
.b1d3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/end.asm

.b1d4					Command_END:
.b1d4	80 fe		bra $b1d4	_halt:	bra 		_halt
.b1d6	4c 90 b0	jmp $b090			jmp 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/list.asm

.b1d9					Command_LIST:
.b1d9	20 fc b2	jsr $b2fc			jsr 	ListGetRange				; get any parameters
.b1dc	a9 00		lda #$00			lda 	#BasicProgram & $FF
.b1de	85 16		sta $16				sta 	zCodePtr+0
.b1e0	a9 80		lda #$80			lda 	#BasicProgram >> 8
.b1e2	85 17		sta $17				sta 	zCodePtr+1
.b1e4	a9 02		lda #$02			lda 	#2
.b1e6	85 18		sta $18				sta 	zCodePtr+2
.b1e8	a9 00		lda #$00			lda 	#0
.b1ea	85 19		sta $19				sta 	zCodePtr+3
.b1ec	a3 03		ldz #$03			ldz 	#3
.b1ee					_CILLoop:
.b1ee	a3 00		ldz #$00			ldz 	#0
.b1f0	ea		nop				nop
.b1f1	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b1f3	c9 00		cmp #$00			cmp 	#0 							; if zero, end of program
.b1f5	f0 24		beq $b21b			beq 	_CILExit
.b1f7	20 b5 ad	jsr $adb5			jsr 	CheckBreak 					; check break
.b1fa	c9 00		cmp #$00			cmp 	#0
.b1fc	d0 1d		bne $b21b			bne 	_CILExit
.b1fe	20 46 b3	jsr $b346			jsr 	ListCheckRange 				; check current line in range.
.b201	b0 08		bcs $b20b			bcs		_CILNext
.b203	a3 00		ldz #$00			ldz 	#0
.b205	1b		inz				inz
.b206	1b		inz				inz
.b207	1b		inz				inz
.b208	20 1e b2	jsr $b21e			jsr 	ListLine 					; list one line.
.b20b					_CILNext:
.b20b	a3 00		ldz #$00			ldz 	#0 							; point to offset
.b20d	ea		nop				nop
.b20e	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read it
.b210	18		clc				clc
.b211	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.b213	85 16		sta $16				sta 	zCodePtr
.b215	90 02		bcc $b219			bcc 	_SNLNoCarry
.b217	e6 17		inc $17				inc 	zCodePtr+1
.b219					_SNLNoCarry:
.b219	80 d3		bra $b1ee			bra 	_CILLoop
.b21b					_CILExit:
.b21b	4c 90 b0	jmp $b090			jmp 	WarmStart
.b21e					ListLine:
.b21e	a3 00		ldz #$00			ldz 	#0
.b220	1b		inz				inz
.b221	ea		nop				nop
.b222	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b224	85 80		sta $80				sta 	XS_Mantissa
.b226	1b		inz				inz
.b227	ea		nop				nop
.b228	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b22a	85 81		sta $81				sta 	XS_Mantissa+1
.b22c	20 2b ae	jsr $ae2b			jsr 	Print16BitInteger 			; print integer.
.b22f	aa		tax				tax 								; print spaces to column 6
.b230					_LISpace:
.b230	a9 20		lda #$20			lda 	#" "
.b232	20 af ad	jsr $adaf			jsr 	CharPrint
.b235	e8		inx				inx
.b236	e0 06		cpx #$06			cpx 	#6
.b238	d0 f6		bne $b230			bne 	_LISpace
.b23a					_LIDecode:
.b23a	1b		inz				inz
.b23b	ea		nop				nop
.b23c	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b23e	c9 00		cmp #$00			cmp 	#0 							; zero, exit.
.b240	f0 0f		beq $b251			beq 	_LIExit
.b242	30 12		bmi $b256			bmi 	_LIToken
.b244	c9 40		cmp #$40			cmp 	#$40 						; 01-$3F, character.
.b246	b0 52		bcs $b29a			bcs 	_LIInteger
.b248	49 20		eor #$20			eor 	#$20 						; make 7 bit
.b24a	69 20		adc #$20			adc 	#$20
.b24c	20 ef b2	jsr $b2ef			jsr 	ListPrintLC 				; print in LC
.b24f	80 e9		bra $b23a			bra 	_LIDecode
.b251					_LIExit:
.b251	a9 0d		lda #$0d			lda 	#13 						; print new line.
.b253	4c af ad	jmp $adaf			jmp 	CharPrint
.b256					_LIToken:
.b256	c9 fc		cmp #$fc			cmp 	#$FC 						; $FC-$FF ?
.b258	90 4b		bcc $b2a5			bcc		_LICommandToken
.b25a	48		pha				pha 								; save in case end
.b25b	a2 22		ldx #$22			ldx 	#'"'						; print if $FE quoted string
.b25d	c9 fe		cmp #$fe			cmp 	#$FE
.b25f	f0 17		beq $b278			beq 	_LIPrint
.b261	a2 2e		ldx #$2e			ldx 	#'.'						; print if $FD decimals
.b263	c9 fd		cmp #$fd			cmp 	#$FD
.b265	f0 11		beq $b278			beq 	_LIPrint
.b267	a9 52		lda #$52			lda 	#'R'						; must be REM
.b269	20 ef b2	jsr $b2ef			jsr 	ListPrintLC
.b26c	a9 45		lda #$45			lda 	#'E'
.b26e	20 ef b2	jsr $b2ef			jsr 	ListPrintLC
.b271	a9 4d		lda #$4d			lda 	#'M'
.b273	20 ef b2	jsr $b2ef			jsr 	ListPrintLC
.b276	a2 20		ldx #$20			ldx 	#' '
.b278					_LIPrint:
.b278	8a		txa				txa
.b279	20 ef b2	jsr $b2ef			jsr 	ListPrintLC
.b27c	1b		inz				inz
.b27d	ea		nop				nop
.b27e	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b280	aa		tax				tax 								; put in X
.b281	ca		dex				dex
.b282					_LILoop:
.b282	ca		dex				dex 								; exit when count reached zero.
.b283	f0 09		beq $b28e			beq 	_LIEnd
.b285	1b		inz				inz
.b286	ea		nop				nop
.b287	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b289	20 ef b2	jsr $b2ef			jsr 	ListPrintLC
.b28c	80 f4		bra $b282			bra 	_LILoop
.b28e	68		pla		_LIEnd:	pla 								; get A back
.b28f	c9 fe		cmp #$fe			cmp 	#$FE 						; if '"' need closing quotes
.b291	d0 a7		bne $b23a			bne 	_LIDecode
.b293	a9 22		lda #$22			lda 	#'"'
.b295	20 ef b2	jsr $b2ef			jsr 	ListPrintLC
.b298	80 a0		bra $b23a			bra 	_LIDecode
.b29a					_LIInteger:
.b29a	a2 00		ldx #$00			ldx 	#0
.b29c	20 10 b7	jsr $b710			jsr 	EvaluateGetInteger 			; get an atom
.b29f	3b		dez				dez
.b2a0	20 31 ae	jsr $ae31			jsr 	Print32BitInteger 			; print integer.
.b2a3	80 95		bra $b23a			bra 	_LIDecode
.b2a5					_LICommandToken:
.b2a5	5a		phy				phy 								; save Y
.b2a6	48		pha				pha 								; save token
.b2a7	a2 27		ldx #$27			ldx  	#KeywordText & $FF 			; address of keyword text table.
.b2a9	a9 af		lda #$af			lda 	(#KeywordText >> 8) & $FF
.b2ab	86 1a		stx $1a				stx 	zLTemp1
.b2ad	85 1b		sta $1b				sta 	zLTemp1+1
.b2af	a9 00		lda #$00			lda 	(#KeywordText >> 16) & $FF 	; this is for 65816 (it's a table in code
.b2b1	85 1c		sta $1c				sta 	zLTemp1+2 					; space) and won't affect a 6502 at all.
.b2b3	68		pla				pla 								; get token, chuck bit 7.
.b2b4	29 7f		and #$7f			and 	#127
.b2b6	f0 16		beq $b2ce			beq 	_LIFoundToken
.b2b8	aa		tax				tax
.b2b9					_LITokenLoop:
.b2b9	a0 00		ldy #$00			ldy 	#0
.b2bb					_LIFindEnd:
.b2bb	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b2bd	c8		iny				iny
.b2be	0a		asl a				asl 	a
.b2bf	90 fa		bcc $b2bb			bcc 	_LIFindEnd
.b2c1	98		tya				tya 								; that is step to the next
.b2c2	18		clc				clc 								; we don't bother bumping the 3rd byte
.b2c3	65 1a		adc $1a				adc 	zLTemp1 					; here.
.b2c5	85 1a		sta $1a				sta 	zLTemp1
.b2c7	90 02		bcc $b2cb			bcc 	_LINoBump
.b2c9	e6 1b		inc $1b				inc 	zLTemp1+1
.b2cb					_LINoBump:
.b2cb	ca		dex				dex 								; no go round again.
.b2cc	d0 eb		bne $b2b9			bne 	_LITokenLoop
.b2ce					_LIFoundToken:
.b2ce	a0 00		ldy #$00			ldy 	#0
.b2d0					_LIPrintToken:
.b2d0	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b2d2	c8		iny				iny
.b2d3	48		pha				pha 								; save it
.b2d4	29 7f		and #$7f			and 	#$7F
.b2d6	20 ef b2	jsr $b2ef			jsr 	ListPrintLC
.b2d9	68		pla				pla
.b2da	10 f4		bpl $b2d0			bpl 	_LIPrintToken 				; go back if not end
.b2dc	7a		ply				ply 								; restore Y
.b2dd	29 7f		and #$7f			and 	#$7F 						; if last char is a letter
.b2df	c9 41		cmp #$41			cmp 	#"A"
.b2e1	90 09		bcc $b2ec			bcc 	_LINotLetter
.b2e3	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b2e5	b0 05		bcs $b2ec			bcs 	_LINotLetter
.b2e7	a9 20		lda #$20			lda 	#" " 						; add spacing
.b2e9	20 ef b2	jsr $b2ef			jsr 	ListPrintLC
.b2ec					_LINotLetter:
.b2ec	4c 3a b2	jmp $b23a			jmp 	_LIDecode
.b2ef					ListPrintLC:
.b2ef	c9 41		cmp #$41			cmp 	#"A"
.b2f1	90 06		bcc $b2f9			bcc 	_LPLC0
.b2f3	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b2f5	b0 02		bcs $b2f9			bcs 	_LPLC0
.b2f7	69 20		adc #$20			adc 	#$20
.b2f9	4c af ad	jmp $adaf	_LPLC0:	jmp 	CharPrint
.b2fc					ListGetRange:
.b2fc	a2 0b		ldx #$0b			ldx 	#XS_Size*2-1 				; clear first 2 slots back to defaults.
.b2fe					_LGRClear:
.b2fe	a9 00		lda #$00			lda 	#0
.b300	95 80		sta $80,x			sta 	XS_Mantissa,x
.b302	ca		dex				dex
.b303	10 f9		bpl $b2fe			bpl 	_LGRClear
.b305	ea		nop				nop
.b306	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b308	c9 00		cmp #$00			cmp 	#0 							; nothing
.b30a	f0 22		beq $b32e			beq 	_LGRBlank
.b30c	c9 c0		cmp #$c0			cmp 	#token_Colon 				; or colon
.b30e	f0 1e		beq $b32e			beq 	_LGRBlank
.b310	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma
.b312	f0 19		beq $b32d			beq 	_LGREnd 					; then it's LIST ,x
.b314	20 a2 b7	jsr $b7a2			jsr 	EvaluateInteger 			; get the first number into bottom
.b317	ea		nop				nop
.b318	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b31a	c9 bf		cmp #$bf			cmp 	#token_Comma
.b31c	f0 0f		beq $b32d			beq 	_LGREnd 					; then it is LIST a,b
.b31e	a5 80		lda $80				lda 	XS_Mantissa+0 				; copy first to second LIST n is n,n
.b320	85 86		sta $86				sta 	XS_Mantissa+XS_Size+0
.b322	a5 81		lda $81				lda 	XS_Mantissa+1
.b324	85 87		sta $87				sta 	XS_Mantissa+XS_Size+1
.b326					_LGRBumpExit:
.b326	e6 86		inc $86				inc 	XS_Mantissa+XS_Size 		; bump it so we can use cc.
.b328	d0 02		bne $b32c			bne 	_LGRBump2
.b32a	e6 87		inc $87				inc 	XS_Mantissa+XS_Size+1
.b32c					_LGRBump2:
.b32c	60		rts				rts
.b32d					_LGREnd:
.b32d	1b		inz				inz
.b32e					_LGRBlank:
.b32e	a9 ff		lda #$ff			lda 	#$FF 						; default to the end.
.b330	85 86		sta $86				sta 	XS_Mantissa+XS_Size
.b332	85 87		sta $87				sta 	XS_Mantissa+XS_Size+1
.b334	ea		nop				nop
.b335	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b337	c9 00		cmp #$00			cmp 	#0
.b339	f0 f1		beq $b32c			beq 	_LGRBump2
.b33b	0a		asl a				asl 	a 							; if not a number, then exit (to end)
.b33c	b0 ee		bcs $b32c			bcs 	_LGRBump2
.b33e	a2 06		ldx #$06			ldx 	#XS_Size 					; get to range
.b340	20 a4 b7	jsr $b7a4			jsr 	EvaluateIntegerX
.b343	80 e1		bra $b326			bra 	_LGRBumpExit
.b345	60		rts				rts
.b346					ListCheckRange:
.b346	1b		inz				inz
.b347	a2 00		ldx #$00			ldx 	#0 							; test low
.b349	20 56 b3	jsr $b356			jsr 	_LCRCompare
.b34c	90 06		bcc $b354			bcc 	_LCRFail
.b34e	a2 06		ldx #$06			ldx 	#XS_Size 					; test high
.b350	20 56 b3	jsr $b356			jsr 	_LCRCompare
.b353	60		rts				rts
.b354					_LCRFail:
.b354	38		sec				sec
.b355	60		rts				rts
.b356					_LCRCompare:
.b356	ea		nop				nop
.b357	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b359	38		sec				sec
.b35a	f5 80		sbc $80,x			sbc	 	XS_Mantissa+0,x
.b35c	08		php				php
.b35d	1b		inz				inz
.b35e	ea		nop				nop
.b35f	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b361	28		plp				plp
.b362	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.b364	08		php				php
.b365	3b		dez				dez
.b366	28		plp				plp
.b367	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/print.asm

.b368					Command_PRINT:
.b368	ea		nop				nop
.b369	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b36b	c9 00		cmp #$00			cmp 	#0 							; end
.b36d	f0 66		beq $b3d5			beq 	_CPR_NewLine
.b36f	c9 c0		cmp #$c0			cmp 	#token_Colon
.b371	f0 62		beq $b3d5			beq 	_CPR_NewLine
.b373	c9 c1		cmp #$c1			cmp 	#token_SemiColon
.b375	f0 50		beq $b3c7			beq 	_CPR_Skip
.b377	c9 bf		cmp #$bf			cmp 	#token_Comma
.b379	f0 49		beq $b3c4			beq 	_CPR_Tab
.b37b	20 05 b6	jsr $b605			jsr 	EvaluateExpression 			; get expression.
.b37e	a5 85		lda $85				lda 	XS_Type 					; get type.
.b380	29 02		and #$02			and 	#2
.b382	d0 24		bne $b3a8			bne 	_CPR_String 				; if type = 2 output as string.
.b384					_CPR_Number:
.b384	a9 00		lda #$00			lda 	#0 							; reset buffer index
.b386	8d 14 03	sta $0314			sta 	NumBufX
.b389	a5 85		lda $85				lda 	XS_Type 					; get type
.b38b	4a		lsr a				lsr 	a
.b38c	b0 05		bcs $b393			bcs 	_CPRInt 					; if msb set do as integer
.b38e	20 95 c8	jsr $c895			jsr 	FPToString 					; call fp to str otherwise
.b391	80 03		bra $b396			bra 	_CPRNPrint
.b393	20 5e c3	jsr $c35e	_CPRInt:jsr 	IntToString
.b396					_CPRNPrint:
.b396	ad 15 03	lda $0315			lda 	Num_Buffer 					; is first character -
.b399	c9 2d		cmp #$2d			cmp 	#"-"
.b39b	f0 05		beq $b3a2			beq 	_CPRNoSpace
.b39d	a9 20		lda #$20			lda 	#" "						; print the leading space
.b39f	20 af ad	jsr $adaf			jsr 	CharPrint 					; so beloved of MS Basics.
.b3a2					_CPRNoSpace:
.b3a2	a2 14		ldx #$14			ldx 	#(Num_Buffer-1) & $FF
.b3a4	a9 03		lda #$03			lda 	#(Num_Buffer-1) >> 8
.b3a6	80 04		bra $b3ac			bra 	_CPRPrint
.b3a8					_CPR_String:
.b3a8	a6 80		ldx $80				ldx 	XS_Mantissa
.b3aa	a5 81		lda $81				lda 	XS_Mantissa+1
.b3ac					_CPRPrint:
.b3ac	86 1e		stx $1e				stx 	zGenPtr
.b3ae	85 1f		sta $1f				sta 	zGenPtr+1
.b3b0	5a		phy				phy
.b3b1	a0 00		ldy #$00			ldy 	#0							; get length into X
.b3b3	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b3b5	aa		tax				tax
.b3b6	f0 09		beq $b3c1			beq 	_CPREndPrint 				; nothing to print
.b3b8					_CPRLoop:
.b3b8	c8		iny				iny
.b3b9	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b3bb	20 af ad	jsr $adaf			jsr 	CharPrint
.b3be	ca		dex				dex
.b3bf	d0 f7		bne $b3b8			bne 	_CPRLoop
.b3c1					_CPREndPrint:
.b3c1	7a		ply				ply
.b3c2	80 a4		bra $b368			bra 	Command_Print
.b3c4					_CPR_Tab:
.b3c4	20 5b a0	jsr $a05b			jsr 	IFT_Tab
.b3c7					_CPR_Skip:
.b3c7	1b		inz				inz
.b3c8	ea		nop				nop
.b3c9	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b3cb	c9 c0		cmp #$c0			cmp 	#token_Colon 				; colon or $00, exit
.b3cd	f0 09		beq $b3d8			beq 	_CPR_Exit
.b3cf	c9 00		cmp #$00			cmp 	#0
.b3d1	d0 95		bne $b368			bne 	Command_PRINT 				; if not go round again.
.b3d3	80 03		bra $b3d8			bra 	_CPR_Exit
.b3d5					_CPR_NewLine:
.b3d5	20 68 a0	jsr $a068			jsr 	IFT_NewLine
.b3d8					_CPR_Exit:
.b3d8	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/assert.asm

.b3d9					Command_ASSERT:
.b3d9	20 a2 b7	jsr $b7a2			jsr 	EvaluateInteger 			; calculate thing being asserted
.b3dc	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; check if true (non-zero)
.b3de	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.b3e0	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.b3e2	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.b3e4	f0 01		beq $b3e7			beq 	_ASFail
.b3e6	60		rts				rts
.b3e7					_ASFail:
.b3e7	20 e7 ad	jsr $ade7			jsr ERR_Handler
>b3ea	41 73 73 65 72 74 00			.text "Assert",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/poke.asm

.b3f1					Command_POKE:
.b3f1	a9 01		lda #$01			lda 	#1
.b3f3	80 06		bra $b3fb			bra 	CmdPoke_Main
.b3f5					Command_DOKE:
.b3f5	a9 02		lda #$02			lda 	#2
.b3f7	80 02		bra $b3fb			bra 	CmdPoke_Main
.b3f9					Command_LOKE:
.b3f9	a9 04		lda #$04			lda 	#4
.b3fb					CmdPoke_Main:
.b3fb	48		pha				pha
.b3fc	20 a2 b7	jsr $b7a2			jsr 	EvaluateInteger 			; get two parameters.
.b3ff	e8		inx				inx
.b400	e8		inx				inx
.b401	e8		inx				inx
.b402	e8		inx				inx
.b403	e8		inx				inx
.b404	e8		inx				inx
.b405	20 dd bd	jsr $bddd			jsr 	CheckNextComma
.b408	20 a4 b7	jsr $b7a4			jsr 	EvaluateIntegerX
.b40b	a5 80		lda $80				lda 	XS_Mantissa+0 			; copy the mantissa into ZLTemp1 (address)
.b40d	85 1a		sta $1a				sta 	zLTemp1
.b40f	a5 81		lda $81				lda 	XS_Mantissa+1
.b411	85 1b		sta $1b				sta 	zLTemp1+1
.b413	a5 82		lda $82				lda 	XS_Mantissa+2
.b415	85 1c		sta $1c				sta 	zLTemp1+2
.b417	a5 83		lda $83				lda 	XS_Mantissa+3
.b419	85 1d		sta $1d				sta 	zLTemp1+3
.b41b	68		pla				pla 								; get count
.b41c	5a		phy				phy 								; save Y
.b41d	20 5f bd	jsr $bd5f			jsr 	MemWrite 					; write it out
.b420	7a		ply				ply 								; restore Y and done.
.b421	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/newold.asm

.b422					Command_NEW:
.b422	a9 00		lda #$00			lda 	#BasicProgram & $FF
.b424	85 16		sta $16				sta 	zCodePtr+0
.b426	a9 80		lda #$80			lda 	#BasicProgram >> 8
.b428	85 17		sta $17				sta 	zCodePtr+1
.b42a	a9 02		lda #$02			lda 	#2
.b42c	85 18		sta $18				sta 	zCodePtr+2
.b42e	a9 00		lda #$00			lda 	#0
.b430	85 19		sta $19				sta 	zCodePtr+3
.b432	a3 03		ldz #$03			ldz 	#3
.b434	a3 00		ldz #$00			ldz 	#0
.b436	a9 00		lda #$00			lda 	#0 							; write a 0 there.
.b438	ea		nop				nop
.b439	92 16		sta ($16),z			sta 	(zCodePtr),z
.b43b	20 73 bd	jsr $bd73			jsr 	UpdateProgramEnd 			; update program end.
.b43e	4c 90 b0	jmp $b090			jmp 	WarmStart
.b441					Command_OLD:
.b441	ea		nop				nop
.b442	a9 00		lda #$00			lda 	#BasicProgram & $FF
.b444	85 16		sta $16				sta 	zCodePtr+0
.b446	a9 80		lda #$80			lda 	#BasicProgram >> 8
.b448	85 17		sta $17				sta 	zCodePtr+1
.b44a	a9 02		lda #$02			lda 	#2
.b44c	85 18		sta $18				sta 	zCodePtr+2
.b44e	a9 00		lda #$00			lda 	#0
.b450	85 19		sta $19				sta 	zCodePtr+3
.b452	a3 03		ldz #$03			ldz 	#3
.b454					_COL_Find:
.b454	ea		nop				nop
.b455	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b457	1b		inz				inz
.b458	c9 00		cmp #$00			cmp 	#0 							; if zero, then the position Y/Z is new offset
.b45a	f0 18		beq $b474			beq 	_COL_Found
.b45c	6b		tza				tza
.b45d	c9 00		cmp #$00			cmp 	#0
.b45f	d0 f3		bne $b454			bne 	_COL_Find 					; can't find old EOL, give up.
.b461	20 e7 ad	jsr $ade7			jsr ERR_Handler
>b464	50 72 6f 67 72 61 6d 20			.text "Program Corrupt",0
>b46c	43 6f 72 72 75 70 74 00
.b474					_COL_Found:
.b474	6b		tza				tza
.b475	48		pha				pha
.b476	a3 00		ldz #$00			ldz 	#0
.b478	68		pla				pla
.b479	ea		nop				nop
.b47a	92 16		sta ($16),z			sta 	(zCodePtr),z
.b47c	20 73 bd	jsr $bd73			jsr 	UpdateProgramEnd 			; reset variable pointer
.b47f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/branch.asm

.b480					Command_GOTO:
.b480	20 9d b4	jsr $b49d			jsr 	GotoGetLineNumber
.b483	4c ba b4	jmp $b4ba			jmp 	GotoChangeToLineNumber
.b486					Command_GOSUB:
.b486	20 9d b4	jsr $b49d			jsr 	GotoGetLineNumber
.b489	20 76 ad	jsr $ad76			jsr 	StackSavePosition
.b48c	a9 05		lda #$05			lda 	#(SMark_Gosub << 4)+SourcePosSize
.b48e	20 2f ad	jsr $ad2f			jsr 	StackPushFrame
.b491	4c ba b4	jmp $b4ba			jmp 	GotoChangeToLineNumber
.b494					Command_RETURN:
.b494	a9 00		lda #$00			lda 	#(SMark_Gosub << 4)
.b496	20 46 ad	jsr $ad46			jsr 	StackPopFrame
.b499	20 93 ad	jsr $ad93			jsr 	StackRestorePosition
.b49c	60		rts				rts
.b49d					GotoGetLineNumber:
.b49d	20 a2 b7	jsr $b7a2			jsr 	EvaluateInteger
.b4a0	a5 82		lda $82				lda 	XS_Mantissa+2 				; check range
.b4a2	05 83		ora $83				ora 	XS_Mantissa+3
.b4a4	d0 01		bne $b4a7			bne 	_GLINError
.b4a6	60		rts				rts
.b4a7					_GLINError:
.b4a7	20 e7 ad	jsr $ade7			jsr ERR_Handler
>b4aa	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>b4b2	20 4e 75 6d 62 65 72 00
.b4ba					GotoChangeToLineNumber:
.b4ba	a5 80		lda $80				lda 	XS_Mantissa+0 				; check line number not zero
.b4bc	05 81		ora $81				ora 	XS_Mantissa+1
.b4be	f0 3d		beq $b4fd			beq 	_GCTLFail
.b4c0	a9 00		lda #$00			lda 	#BasicProgram & $FF
.b4c2	85 16		sta $16				sta 	zCodePtr+0
.b4c4	a9 80		lda #$80			lda 	#BasicProgram >> 8
.b4c6	85 17		sta $17				sta 	zCodePtr+1
.b4c8	a9 02		lda #$02			lda 	#2
.b4ca	85 18		sta $18				sta 	zCodePtr+2
.b4cc	a9 00		lda #$00			lda 	#0
.b4ce	85 19		sta $19				sta 	zCodePtr+3
.b4d0	a3 03		ldz #$03			ldz 	#3
.b4d2					_GCTLLoop:
.b4d2	a3 00		ldz #$00			ldz 	#0
.b4d4	ea		nop				nop
.b4d5	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b4d7	c9 00		cmp #$00			cmp 	#0
.b4d9	f0 22		beq $b4fd			beq 	_GCTLFail
.b4db	1b		inz				inz
.b4dc	ea		nop				nop
.b4dd	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b4df	c5 80		cmp $80				cmp 	XS_Mantissa+0
.b4e1	d0 08		bne $b4eb			bne 	_GCTLNext
.b4e3	1b		inz				inz
.b4e4	ea		nop				nop
.b4e5	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b4e7	c5 81		cmp $81				cmp 	XS_Mantissa+1
.b4e9	f0 10		beq $b4fb			beq 	_GCTLExit
.b4eb					_GCTLNext:
.b4eb	a3 00		ldz #$00			ldz 	#0 							; point to offset
.b4ed	ea		nop				nop
.b4ee	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read it
.b4f0	18		clc				clc
.b4f1	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.b4f3	85 16		sta $16				sta 	zCodePtr
.b4f5	90 02		bcc $b4f9			bcc 	_SNLNoCarry
.b4f7	e6 17		inc $17				inc 	zCodePtr+1
.b4f9					_SNLNoCarry:
.b4f9	80 d7		bra $b4d2			bra 	_GCTLLoop 					; try next line.
.b4fb					_GCTLExit:
.b4fb	1b		inz				inz
.b4fc	60		rts				rts
.b4fd					_GCTLFail:
.b4fd	20 e7 ad	jsr $ade7			jsr ERR_Handler
>b500	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>b508	20 4e 75 6d 62 65 72 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.b510					Command_CLR:
.b510					ResetRunStatus:
.b510	20 b6 be	jsr $beb6			jsr 	VariableClear
.b513	20 1d ad	jsr $ad1d			jsr 	StackReset
.b516	a9 00		lda #$00			lda 	#HighMemory & $FF
.b518	8d 00 03	sta $0300			sta 	StringPtr
.b51b	a9 7f		lda #$7f			lda 	#HighMemory >> 8
.b51d	8d 01 03	sta $0301			sta 	StringPtr+1
.b520	20 82 c0	jsr $c082			jsr 	ArrayResetDefault
.b523	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/stop.asm

.b524					Command_STOP:
.b524	20 e7 ad	jsr $ade7			jsr ERR_Handler
>b527	53 74 6f 70 00				.text "Stop",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/while.asm

.b52c					Command_WHILE:
.b52c	20 76 ad	jsr $ad76			jsr 	StackSavePosition			; save position into stack, but don't yet push.
.b52f	20 a2 b7	jsr $b7a2			jsr 	EvaluateInteger 			; calculate the while loop value.
.b532	a5 80		lda $80				lda 	XS_Mantissa+0				; check the result if zero
.b534	05 81		ora $81				ora 	XS_Mantissa+1
.b536	05 82		ora $82				ora 	XS_Mantissa+2
.b538	05 83		ora $83				ora 	XS_Mantissa+3
.b53a	f0 06		beq $b542			beq 	_CWHSkip 					; if it is zero, then skip to WEND.
.b53c	a9 25		lda #$25			lda 	#(SMark_While << 4)+SourcePosSize
.b53e	20 2f ad	jsr $ad2f			jsr 	StackPushFrame 				; push on stack
.b541	60		rts				rts
.b542					_CWHSkip:
.b542	a9 95		lda #$95			lda 	#token_Wend 				; look for the WEND token.
.b544	20 53 b5	jsr $b553			jsr 	StructureSearchWend
.b547	60		rts				rts
.b548					Command_WEND:
.b548	a9 20		lda #$20			lda 	#(SMark_While << 4)			; remove the frame
.b54a	20 46 ad	jsr $ad46			jsr 	StackPopFrame
.b54d	20 93 ad	jsr $ad93			jsr 	StackRestorePosition
.b550	80 da		bra $b52c			bra 	Command_WHILE 				; and do the while again.
.b552	60		rts				rts
.b553					StructureSearchWend:
.b553	85 10		sta $10				sta 	zTemp1 						; save the target on zTemp1
.b555	a9 00		lda #$00			lda 	#0 							; set the structure depth to zero (zTemp2)
.b557	85 12		sta $12				sta 	zTemp2
.b559	80 1a		bra $b575			bra 	_SSWLoop 					; jump in, start scanning from here.
.b55b					_SSWNextLine:
.b55b	a3 00		ldz #$00			ldz 	#0 							; point to offset
.b55d	ea		nop				nop
.b55e	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read it
.b560	18		clc				clc
.b561	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.b563	85 16		sta $16				sta 	zCodePtr
.b565	90 02		bcc $b569			bcc 	_SNLNoCarry
.b567	e6 17		inc $17				inc 	zCodePtr+1
.b569					_SNLNoCarry:
.b569	a3 00		ldz #$00			ldz 	#0
.b56b	ea		nop				nop
.b56c	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b56e	c9 00		cmp #$00			cmp 	#0					 		; if zero, fail.
.b570	f0 54		beq $b5c6			beq 	_SSWFail
.b572	1b		inz				inz
.b573	1b		inz				inz
.b574					_SSWNextSimple:
.b574	1b		inz				inz
.b575					_SSWLoop:
.b575	ea		nop				nop
.b576	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b578	c9 00		cmp #$00			cmp 	#0 							; end of line ?
.b57a	f0 df		beq $b55b			beq 	_SSWNextLine 				; if so, then next line
.b57c	10 f6		bpl $b574			bpl 	_SSWNextSimple 				; needs to be a token, just skip char/number.
.b57e	a6 12		ldx $12				ldx 	zTemp2 						; check structure count
.b580	d0 04		bne $b586			bne 	_SSWCheckUpDown 			; if it's non zero, then a match doesn't work.
.b582	c5 10		cmp $10				cmp 	zTemp1 						; found the right keyword
.b584	f0 2b		beq $b5b1			beq 	_SSWFound 					; so exit.
.b586					_SSWCheckUpDown:
.b586	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus 			; if < keyword +
.b588	90 10		bcc $b59a			bcc 	_SSWNext
.b58a	c9 93		cmp #$93			cmp 	#firstKeywordMinus 			; if < keyword - then as keyword +
.b58c	90 08		bcc $b596			bcc 	_SSWPlus
.b58e	c9 98		cmp #$98			cmp 	#firstUnaryFunction			; if < first unary down as keyword -
.b590	b0 08		bcs $b59a			bcs 	_SSWNext
.b592	c6 12		dec $12				dec 	zTemp2 						; reduce structure count.
.b594	c6 12		dec $12				dec 	zTemp2
.b596					_SSWPlus:
.b596	e6 12		inc $12				inc 	zTemp2
.b598	30 19		bmi $b5b3			bmi 	_SSWUnder					; error if driven -ve
.b59a					_SSWNext:
.b59a	ea		nop				nop
.b59b	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read element
.b59d	1b		inz				inz 								; skip
.b59e	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.b5a0	90 0d		bcc $b5af			bcc 	_SEDone 					; so just skip over it.
.b5a2	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.b5a4	90 08		bcc $b5ae			bcc 	_SEDouble
.b5a6	6b		tza				tza 								; this is Y + 1
.b5a7	18		clc				clc
.b5a8	ea		nop				nop
.b5a9	72 16		adc ($16),z			adc 	(zCodePtr),z 				; add total length of element
.b5ab	4b		taz				taz 								; back in Y.
.b5ac	3b		dez				dez 								; fix up, one for the +1, one for the iny
.b5ad	3b		dez				dez
.b5ae					_SEDouble:
.b5ae	1b		inz				inz
.b5af					_SEDone:
.b5af	80 c4		bra $b575			bra 	_SSWLoop
.b5b1					_SSWFound:
.b5b1	1b		inz				inz
.b5b2	60		rts				rts
.b5b3					_SSWUnder:
.b5b3	20 e7 ad	jsr $ade7			jsr ERR_Handler
>b5b6	53 74 72 75 63 74 75 72			.text "Structure order",0
>b5be	65 20 6f 72 64 65 72 00
.b5c6					_SSWFail:
.b5c6	20 e7 ad	jsr $ade7			jsr ERR_Handler
>b5c9	43 61 6e 27 74 20 66 69			.text "Can't find structure",0
>b5d1	6e 64 20 73 74 72 75 63 74 75 72 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/repeat.asm

.b5de					Command_REPEAT:
.b5de	20 76 ad	jsr $ad76			jsr 	StackSavePosition			; save position into stack
.b5e1	a9 15		lda #$15			lda 	#(SMark_Repeat << 4)+SourcePosSize
.b5e3	20 2f ad	jsr $ad2f			jsr 	StackPushFrame 				; push on stack
.b5e6	60		rts				rts
.b5e7					Command_UNTIL:
.b5e7	a9 10		lda #$10			lda 	#(SMark_Repeat << 4)		; remove the frame
.b5e9	20 46 ad	jsr $ad46			jsr 	StackPopFrame
.b5ec	20 a2 b7	jsr $b7a2			jsr 	EvaluateInteger				; work out UNTIL
.b5ef	a5 80		lda $80				lda 	XS_Mantissa+0 				; check if zero.
.b5f1	05 81		ora $81				ora 	XS_Mantissa+1
.b5f3	05 82		ora $82				ora 	XS_Mantissa+2
.b5f5	05 83		ora $83				ora 	XS_Mantissa+3
.b5f7	d0 08		bne $b601			bne 	_CUTExit 					; if not, just exit
.b5f9	20 93 ad	jsr $ad93			jsr 	StackRestorePosition 		; otherwise loop round again.
.b5fc	a9 15		lda #$15			lda 	#(SMark_Repeat << 4)+SourcePosSize
.b5fe	20 2f ad	jsr $ad2f			jsr 	StackPushFrame 				; fix the stack back.
.b601					_CUTExit:
.b601	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.b602					EVESyntax:
.b602	4c b8 ad	jmp $adb8			jmp 	SyntaxError
.b605					EvaluateExpression:
.b605	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.b607					EvaluateExpressionX:
.b607	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.b609					EvaluateExpressionXA:
.b609	48		pha				pha 								; save precedence on stack.
.b60a	ea		nop				nop
.b60b	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b60d	f0 f3		beq $b602			beq 	EVESyntax 					; end of line, syntax error.
.b60f	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.b611	b0 03		bcs $b616			bcs 	_EVNotVariable
.b613	4c e2 b6	jmp $b6e2			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.b616					_EVNotVariable:
.b616	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.b618	90 e8		bcc $b602			bcc 	EVESyntax
.b61a	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.b61c	b0 59		bcs $b677			bcs 	_EVNotInteger
.b61e	20 10 b7	jsr $b710			jsr 	EvaluateGetInteger
.b621					_EVCheckDecimal:
.b621	ea		nop				nop
.b622	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b624	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.b626	d0 05		bne $b62d			bne 	_EVGotAtom 					; no, get atom.
.b628					_EVIsDecimal:
.b628	20 38 b7	jsr $b738			jsr 	EVGetDecimal 				; extend to the decimal part.
.b62b	80 00		bra $b62d			bra 	_EVGotAtom 					; and continue to got atom.
.b62d					_EVGotAtom:
.b62d	ea		nop				nop
.b62e	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b630	10 43		bpl $b675			bpl 	_EVExitDrop 				; must be a token.
.b632	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.b634	b0 3f		bcs $b675			bcs 	_EVExitDrop
.b636	68		pla				pla 								; get current precedence
.b637	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.b639	da		phx				phx 								; save X
.b63a	ea		nop				nop
.b63b	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b63d	aa		tax				tax 								; put in X
.b63e	bd 98 ae	lda $ae98,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.b641	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.b643	fa		plx				plx 								; restore X
.b644	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.b646	90 2e		bcc $b676			bcc 	_EVExit 					; exit if too low.
.b648	f0 2c		beq $b676			beq 	_EVExit 					; exit if equals
.b64a	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.b64c	48		pha				pha
.b64d	ea		nop				nop
.b64e	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b650	48		pha				pha
.b651	1b		inz				inz
.b652	da		phx				phx 								; save current position
.b653	e8		inx				inx
.b654	e8		inx				inx
.b655	e8		inx				inx
.b656	e8		inx				inx
.b657	e8		inx				inx
.b658	e8		inx				inx
.b659	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.b65b	20 09 b6	jsr $b609			jsr 	EvaluateExpressionXA 		; do the RHS.
.b65e	fa		plx				plx 								; restore X
.b65f	68		pla				pla 								; get the binary operator in A.
.b660					_EVCallA:
.b660	da		phx				phx 								; save X again
.b661	0a		asl a				asl 	a 							; double, lose the MSB.
.b662	aa		tax				tax									; put in X
.b663	bd 49 ae	lda $ae49,x			lda 	VectorTable,x 				; copy address into zGenPtr
.b666	8d 11 03	sta $0311			sta 	LocalVector+1
.b669	bd 4a ae	lda $ae4a,x			lda 	VectorTable+1,x
.b66c	8d 12 03	sta $0312			sta 	LocalVector+2
.b66f	fa		plx				plx 								; restore X
.b670	20 eb b6	jsr $b6eb			jsr 	EVCallLocalVector
.b673	80 b8		bra $b62d			bra 	_EVGotAtom 					; and loop back.
.b675					_EVExitDrop:
.b675	68		pla				pla
.b676					_EVExit:
.b676	60		rts				rts
.b677					_EVNotInteger:
.b677	1b		inz				inz
.b678	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.b67a	d0 16		bne $b692			bne 	_EVNotMinus
.b67c	20 83 b7	jsr $b783			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.b67f	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.b681	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.b683	f0 05		beq $b68a			beq 	_EVMinusFloat
.b685	20 41 c3	jsr $c341			jsr 	IntegerNegateAlways 		; negation
.b688	80 a3		bra $b62d			bra 	_EVGotAtom 					; and go back.
.b68a					_EVMinusFloat:
.b68a	b5 85		lda $85,x			lda 	XS_Type,x 					; invert the sign bit.
.b68c	49 80		eor #$80			eor 	#$80
.b68e	95 85		sta $85,x			sta 	XS_Type,x
.b690	80 9b		bra $b62d			bra 	_EVGotAtom
.b692					_EVNotMinus:
.b692	c9 bd		cmp #$bd			cmp 	#token_lparen 				; is it left parenthesis
.b694	d0 18		bne $b6ae			bne 	_EVNotParenthesis
.b696	20 07 b6	jsr $b607			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.b699	ea		nop				nop
.b69a	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b69c	1b		inz				inz
.b69d	c9 be		cmp #$be			cmp 	#token_rparen 				; okay if right bracket.
.b69f	f0 8c		beq $b62d			beq 	_EVGotAtom
.b6a1	20 e7 ad	jsr $ade7			jsr ERR_Handler
>b6a4	4d 69 73 73 69 6e 67 20			.text "Missing )",0
>b6ac	29 00
.b6ae					_EVNotParenthesis:
.b6ae	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.b6b0	d0 0c		bne $b6be			bne 	_EVNotNot
.b6b2	20 83 b7	jsr $b783			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.b6b5	20 96 c7	jsr $c796			jsr 	FPUToInteger 				; make it an integer - if possible.
.b6b8	20 68 b7	jsr $b768			jsr 	NotInteger 					; do the not calculation
.b6bb	4c 2d b6	jmp $b62d			jmp 	_EVGotAtom
.b6be					_EVNotNot:
.b6be	c9 fe		cmp #$fe			cmp 	#$FE
.b6c0	d0 12		bne $b6d4			bne 	_EVNotString
.b6c2	20 51 be	jsr $be51			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.b6c5	a5 20		lda $20				lda 	zTempStr 					; copy address of string into mantissa
.b6c7	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b6c9	a5 21		lda $21				lda 	zTempStr+1
.b6cb	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b6cd	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.b6cf	95 85		sta $85,x			sta 	XS_Type,x
.b6d1	4c 2d b6	jmp $b62d			jmp 	_EVGotAtom
.b6d4					_EVNotString:
.b6d4	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.b6d6	90 04		bcc $b6dc			bcc 	_EVBadElement
.b6d8	c9 b7		cmp #$b7			cmp 	#lastUnaryFunction+1
.b6da	90 03		bcc $b6df			bcc 	_EVUnaryFunction
.b6dc					_EVBadElement:
.b6dc	4c b8 ad	jmp $adb8			jmp 	SyntaxError
.b6df					_EVUnaryFunction:
.b6df	4c 60 b6	jmp $b660			jmp 	_EVCallA
.b6e2					_EVVariableHandler:
.b6e2	20 7a be	jsr $be7a			jsr 	VariableFind 				; locate a variable
.b6e5	20 c4 c1	jsr $c1c4			jsr 	VariableGet 				; copy into memory.
.b6e8	4c 2d b6	jmp $b62d			jmp 	_EVGotAtom 					; and go round.
.b6eb					EVCallLocalVector:
.b6eb	6c 11 03	jmp ($0311)			jmp 	(LocalVector+1)
.b6ee					EVShiftMantissaLeft6:
.b6ee	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.b6f0	95 84		sta $84,x			sta 	XS_Exponent,x
.b6f2	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.b6f4	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b6f6	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b6f8	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b6fa	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.b6fc	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b6fe	a9 00		lda #$00			lda 	#0
.b700	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b702	20 05 b7	jsr $b705			jsr 	_EVSMLShift 					; call it here to do it twice
.b705					_EVSMLShift:
.b705	56 84		lsr $84,x			lsr 	XS_Exponent,x
.b707	76 83		ror $83,x			ror 	XS_Mantissa+3,x
.b709	76 82		ror $82,x			ror 	XS_Mantissa+2,x
.b70b	76 81		ror $81,x			ror 	XS_Mantissa+1,x
.b70d	76 80		ror $80,x			ror 	XS_Mantissa+0,x
.b70f	60		rts				rts
.b710					EvaluateGetInteger:
.b710	ea		nop				nop
.b711	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b713	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.b715	95 80		sta $80,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.b717	a9 00		lda #$00			lda 	#0
.b719	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b71b	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b71d	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b71f	1a		inc a				inc 	a 							; set to type 1 (integer)
.b720	95 85		sta $85,x			sta 	XS_Type,x
.b722					_EVCheckNextInteger:
.b722	1b		inz				inz
.b723	ea		nop				nop
.b724	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b726	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.b728	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.b72a	b0 0b		bcs $b737			bcs 	_EVEndInteger
.b72c	48		pha				pha 								; save it.
.b72d	20 ee b6	jsr $b6ee			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.b730	68		pla				pla
.b731	15 80		ora $80,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.b733	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b735	80 eb		bra $b722			bra 	_EVCheckNextInteger
.b737					_EVEndInteger:
.b737	60		rts				rts
.b738					EVGetDecimal:
.b738	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.b73a	8d 15 03	sta $0315			sta 	Num_Buffer
.b73d	da		phx				phx
.b73e	1b		inz				inz
.b73f	ea		nop				nop
.b740	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b742	1b		inz				inz
.b743	3a		dec a				dec 	a								; convert to a string length.
.b744	3a		dec a				dec 	a
.b745	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.b747					_EVGDCopy:
.b747	48		pha				pha 									; save count
.b748	ea		nop				nop
.b749	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b74b	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.b74e	e8		inx				inx 									; forward ....
.b74f	1b		inz				inz
.b750	68		pla				pla 									; get count
.b751	3a		dec a				dec 	a 								; until zero
.b752	d0 f3		bne $b747			bne 	_EVGDCopy
.b754	9d 15 03	sta $0315,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.b757	fa		plx				plx 									; restore X
.b758	a9 15		lda #$15			lda 	#Num_Buffer & $FF 				; set zGenPtr
.b75a	85 1e		sta $1e				sta 	zGenPtr
.b75c	a9 03		lda #$03			lda 	#Num_Buffer >> 8
.b75e	85 1f		sta $1f				sta 	zGenPtr+1
.b760	5a		phy				phy 									; save Y
.b761	a0 00		ldy #$00			ldy 	#0 								; start position
.b763	20 50 c9	jsr $c950			jsr 	FPFromString 					; convert current
.b766	7a		ply				ply 									; restore Y
.b767	60		rts				rts
.b768					NotInteger:
.b768	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.b76a	49 ff		eor #$ff			eor 	#$FF
.b76c	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b76e	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b770	49 ff		eor #$ff			eor 	#$FF
.b772	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b774	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.b776	49 ff		eor #$ff			eor 	#$FF
.b778	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b77a	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.b77c	49 ff		eor #$ff			eor 	#$FF
.b77e	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b780	60		rts				rts
.b781					EvaluateGetAtom:
.b781	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.b783					EvaluateGetAtomX:
.b783	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.b785	20 09 b6	jsr $b609			jsr 	EvaluateExpressionXA
.b788	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.b78a	29 0f		and #$0f			and 	#15
.b78c	c9 02		cmp #$02			cmp 	#2
.b78e	b0 01		bcs $b791			bcs 	EvaluateType
.b790	60		rts				rts
.b791					EvaluateType:
.b791	4c c8 ad	jmp $adc8			jmp 	TypeError
.b794					EvaluateNumber:
.b794	a2 00		ldx #$00			ldx 	#0
.b796					EvaluateNumberX:
.b796	20 07 b6	jsr $b607			jsr 	EvaluateExpressionX
.b799	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0/1
.b79b	29 0f		and #$0f			and 	#15
.b79d	c9 02		cmp #$02			cmp 	#2
.b79f	b0 f0		bcs $b791			bcs 	EvaluateType
.b7a1	60		rts				rts
.b7a2					EvaluateInteger:
.b7a2	a2 00		ldx #$00			ldx 	#0
.b7a4					EvaluateIntegerX:
.b7a4	20 96 b7	jsr $b796			jsr 	EvaluateNumberX
.b7a7	20 96 c7	jsr $c796			jsr 	FPUToInteger
.b7aa	60		rts				rts
.b7ab					EvaluateString:
.b7ab	a2 00		ldx #$00			ldx 	#0
.b7ad					EvaluateStringX:
.b7ad	20 07 b6	jsr $b607			jsr 	EvaluateExpressionX
.b7b0	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 2
.b7b2	29 0f		and #$0f			and 	#15
.b7b4	c9 02		cmp #$02			cmp 	#2
.b7b6	d0 d9		bne $b791			bne 	EvaluateType
.b7b8	b5 80		lda $80,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.b7ba	85 1e		sta $1e				sta 	zGenPtr
.b7bc	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b7be	85 1f		sta $1f				sta 	zGenPtr+1
.b7c0	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.b7c1					BinaryOp_And:
.b7c1	20 15 b8	jsr $b815			jsr 	BinaryMakeBothInteger
.b7c4	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.b7c6	35 86		and $86,x			and 	XS2_Mantissa+0,x
.b7c8	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b7ca	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.b7cc	35 87		and $87,x			and 	XS2_Mantissa+1,x
.b7ce	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b7d0	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.b7d2	35 88		and $88,x			and 	XS2_Mantissa+2,x
.b7d4	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b7d6	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.b7d8	35 89		and $89,x			and 	XS2_Mantissa+3,x
.b7da	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b7dc	60		rts				rts
.b7dd					BinaryOp_Or:
.b7dd	20 15 b8	jsr $b815			jsr 	BinaryMakeBothInteger
.b7e0	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.b7e2	15 86		ora $86,x			ora 	XS2_Mantissa+0,x
.b7e4	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b7e6	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.b7e8	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.b7ea	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b7ec	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.b7ee	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.b7f0	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b7f2	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.b7f4	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.b7f6	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b7f8	60		rts				rts
.b7f9					BinaryOp_Eor:
.b7f9					BinaryOp_Xor:
.b7f9	20 15 b8	jsr $b815			jsr 	BinaryMakeBothInteger
.b7fc	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.b7fe	55 86		eor $86,x			eor 	XS2_Mantissa+0,x
.b800	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b802	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.b804	55 87		eor $87,x			eor 	XS2_Mantissa+1,x
.b806	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b808	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.b80a	55 88		eor $88,x			eor 	XS2_Mantissa+2,x
.b80c	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b80e	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.b810	55 89		eor $89,x			eor 	XS2_Mantissa+3,x
.b812	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b814	60		rts				rts
.b815					BinaryMakeBothInteger:
.b815	da		phx				phx 								; save X
.b816	e8		inx				inx
.b817	e8		inx				inx
.b818	e8		inx				inx
.b819	e8		inx				inx
.b81a	e8		inx				inx
.b81b	e8		inx				inx
.b81c	20 20 b8	jsr $b820			jsr 	BinaryMakeInteger 			; convert to integer.
.b81f	fa		plx				plx 								; restore X and fall through.
.b820					BinaryMakeInteger:
.b820	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.b822	29 0f		and #$0f			and 	#15 						; check type zero
.b824	f0 04		beq $b82a			beq 	_BMIConvert 				; if float convert to integer.
.b826	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.b827	90 04		bcc $b82d			bcc 	_BMIError
.b829	60		rts				rts
.b82a					_BMIConvert:
.b82a	4c 96 c7	jmp $c796			jmp 	FPUToInteger 				; convert to integer
.b82d					_BMIError:
.b82d	4c c8 ad	jmp $adc8			jmp 	TypeError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.b830					Binary_Equal:
.b830	20 77 b8	jsr $b877			jsr 	CompareValues
.b833	09 00		ora #$00			ora 	#0
.b835	f0 04		beq $b83b			beq 	CCTrue
.b837	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.b839	80 02		bra $b83d			bra 	CCWrite
.b83b	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.b83d	95 80		sta $80,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.b83f	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b841	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b843	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b845	a9 01		lda #$01			lda 	#1
.b847	95 85		sta $85,x			sta 	XS_Type,x 					; set type to integer whatever.
.b849	60		rts				rts
.b84a					Binary_NotEqual:
.b84a	20 77 b8	jsr $b877			jsr 	CompareValues
.b84d	09 00		ora #$00			ora 	#0
.b84f	f0 e6		beq $b837			beq 	CCFalse
.b851	80 e8		bra $b83b			bra 	CCTrue
.b853					Binary_Less:
.b853	20 77 b8	jsr $b877			jsr 	CompareValues
.b856	09 00		ora #$00			ora 	#0
.b858	30 e1		bmi $b83b			bmi 	CCTrue
.b85a	80 db		bra $b837			bra 	CCFalse
.b85c					Binary_LessEqual:
.b85c	20 77 b8	jsr $b877			jsr 	CompareValues
.b85f	c9 01		cmp #$01			cmp 	#1
.b861	d0 d8		bne $b83b			bne 	CCTrue
.b863	80 d2		bra $b837			bra 	CCFalse
.b865					Binary_GreaterEqual:
.b865	20 77 b8	jsr $b877			jsr 	CompareValues
.b868	09 00		ora #$00			ora 	#0
.b86a	10 cf		bpl $b83b			bpl 	CCTrue
.b86c	80 c9		bra $b837			bra 	CCFalse
.b86e					Binary_Greater:
.b86e	20 77 b8	jsr $b877			jsr 	CompareValues
.b871	c9 01		cmp #$01			cmp 	#1
.b873	f0 c6		beq $b83b			beq 	CCTrue
.b875	80 c0		bra $b837			bra 	CCFalse
.b877					CompareValues:
.b877	b5 85		lda $85,x			lda 	XS_Type,x 					; and the types together
.b879	35 8b		and $8b,x			and 	XS2_Type,x
.b87b	c9 02		cmp #$02			cmp 	#2
.b87d	f0 11		beq $b890			beq 	_CVString
.b87f	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b881	35 8b		and $8b,x			and 	XS2_Type,x
.b883	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b884	90 03		bcc $b889			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b886	4c d2 b8	jmp $b8d2			jmp 	CompareInteger32 							; so execute code at \1
.b889					_BCFloat:
.b889	20 76 b9	jsr $b976			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b88c	4c cc c6	jmp $c6cc			jmp 	FPCompare 							; and execute code at \2
.b88f	60		rts				rts
.b890					_CVString:
.b890	da		phx				phx 								; save XY
.b891	5a		phy				phy
.b892	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.b894	85 1a		sta $1a				sta		zLTemp1+0
.b896	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b898	85 1b		sta $1b				sta 	zLTemp1+1
.b89a	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.b89c	85 1c		sta $1c				sta 	zLTemp1+2
.b89e	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.b8a0	85 1d		sta $1d				sta 	zLTemp1+3
.b8a2	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.b8a4	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b8a6	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.b8a8	90 02		bcc $b8ac			bcc 	_CVCommon
.b8aa	b1 1c		lda ($1c),y			lda 	(zLTemp1+2),y
.b8ac					_CVCommon:
.b8ac	aa		tax				tax 								; put shorter string length in zero.
.b8ad	f0 0c		beq $b8bb			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.b8af					_CVCompare:
.b8af	c8		iny				iny 								; next character
.b8b0	b1 1a		lda ($1a),y			lda 	(zLTemp1),y 				; compare characters
.b8b2	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.b8b4	90 13		bcc $b8c9			bcc 	_CVReturnLess 				; <
.b8b6	d0 15		bne $b8cd			bne 	_CVReturnGreater 			; >
.b8b8	ca		dex				dex 								; until common length matched.
.b8b9	d0 f4		bne $b8af			bne 	_CVCompare
.b8bb					_CVMatch:
.b8bb	a0 00		ldy #$00			ldy 	#0
.b8bd	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b8bf	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.b8c1	90 06		bcc $b8c9			bcc 	_CVReturnLess 				; <
.b8c3	d0 08		bne $b8cd			bne 	_CVReturnGreater 			; >
.b8c5	a9 00		lda #$00			lda 	#0
.b8c7	80 06		bra $b8cf			bra 	_CVExit 					; same common, same length, same string
.b8c9					_CVReturnLess:
.b8c9	a9 ff		lda #$ff			lda 	#$FF
.b8cb	80 02		bra $b8cf			bra 	_CVExit
.b8cd					_CVReturnGreater:
.b8cd	a9 01		lda #$01			lda 	#$01
.b8cf					_CVExit:
.b8cf	7a		ply				ply
.b8d0	fa		plx				plx
.b8d1	60		rts				rts
.b8d2					CompareInteger32:
.b8d2	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.b8d4	49 80		eor #$80			eor 	#$80
.b8d6	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b8d8	b5 89		lda $89,x			lda 	XS2_Mantissa+3,x
.b8da	49 80		eor #$80			eor 	#$80
.b8dc	95 89		sta $89,x			sta 	XS2_Mantissa+3,x
.b8de	20 5c b9	jsr $b95c			jsr 	SubInteger32 				; subtraction
.b8e1	90 0d		bcc $b8f0			bcc 	_CI32Less 					; cc return -1
.b8e3	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check if zero
.b8e5	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.b8e7	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.b8e9	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.b8eb	f0 02		beq $b8ef			beq 	_CI32Exit
.b8ed	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.b8ef					_CI32Exit:
.b8ef	60		rts				rts
.b8f0					_CI32Less:
.b8f0	a9 ff		lda #$ff			lda 	#$FF
.b8f2	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.b8f3					BinaryOp_Add:
.b8f3	b5 85		lda $85,x			lda 	XS_Type,x  					; and types together
.b8f5	35 8b		and $8b,x			and 	XS2_Type,x
.b8f7	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.b8f9	d0 11		bne $b90c			bne 	_BOAString
.b8fb	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b8fd	35 8b		and $8b,x			and 	XS2_Type,x
.b8ff	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b900	90 03		bcc $b905			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b902	4c 42 b9	jmp $b942			jmp 	AddInteger32 							; so execute code at \1
.b905					_BCFloat:
.b905	20 76 b9	jsr $b976			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b908	4c a7 c4	jmp $c4a7			jmp 	FPAdd 							; and execute code at \2
.b90b	60		rts				rts
.b90c					_BOAString:
.b90c	4c 90 b9	jmp $b990			jmp 	ConcatenateString 			; concatenate two strings.
.b90f					BinaryOp_Subtract:
.b90f	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b911	35 8b		and $8b,x			and 	XS2_Type,x
.b913	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b914	90 03		bcc $b919			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b916	4c 5c b9	jmp $b95c			jmp 	SubInteger32 							; so execute code at \1
.b919					_BCFloat:
.b919	20 76 b9	jsr $b976			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b91c	4c 9f c4	jmp $c49f			jmp 	FPSubtract 							; and execute code at \2
.b91f	60		rts				rts
.b920					BinaryOp_Multiply:
.b920	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b922	35 8b		and $8b,x			and 	XS2_Type,x
.b924	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b925	90 03		bcc $b92a			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b927	4c 7c c2	jmp $c27c			jmp 	MulInteger32 							; so execute code at \1
.b92a					_BCFloat:
.b92a	20 76 b9	jsr $b976			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b92d	4c ce c5	jmp $c5ce			jmp 	FPMultiply 							; and execute code at \2
.b930	60		rts				rts
.b931					BinaryOp_Divide:
.b931	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b933	35 8b		and $8b,x			and 	XS2_Type,x
.b935	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b936	90 03		bcc $b93b			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b938	4c ba c2	jmp $c2ba			jmp 	DivInteger32 							; so execute code at \1
.b93b					_BCFloat:
.b93b	20 76 b9	jsr $b976			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b93e	4c 5b c5	jmp $c55b			jmp 	FPDivide 							; and execute code at \2
.b941	60		rts				rts
.b942					AddInteger32:
.b942	18		clc				clc
.b943	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.b945	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.b947	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b949	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b94b	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.b94d	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b94f	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.b951	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.b953	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b955	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.b957	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.b959	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b95b	60		rts				rts
.b95c					SubInteger32:
.b95c	38		sec				sec
.b95d	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.b95f	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.b961	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b963	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b965	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.b967	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b969	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.b96b	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.b96d	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b96f	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.b971	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.b973	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b975	60		rts				rts
.b976					BinaryMakeBothFloat:
.b976	da		phx				phx 								; save X
.b977	e8		inx				inx
.b978	e8		inx				inx
.b979	e8		inx				inx
.b97a	e8		inx				inx
.b97b	e8		inx				inx
.b97c	e8		inx				inx
.b97d	20 81 b9	jsr $b981			jsr 	BinaryMakeFloat 			; convert to float.
.b980	fa		plx				plx 								; restore X and fall through.
.b981					BinaryMakeFloat:
.b981	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.b983	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.b984	b0 04		bcs $b98a			bcs 	_BMFConvert
.b986	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.b987	b0 04		bcs $b98d			bcs 	_BMFError
.b989	60		rts				rts
.b98a					_BMFConvert:
.b98a	4c 4a c7	jmp $c74a			jmp 	FPUToFloat 					; convert to float
.b98d					_BMFError:
.b98d	4c c8 ad	jmp $adc8			jmp 	TypeError
.b990					ConcatenateString:
.b990	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.b992	85 1a		sta $1a				sta		zLTemp1+0
.b994	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b996	85 1b		sta $1b				sta 	zLTemp1+1
.b998	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.b99a	85 1c		sta $1c				sta 	zLTemp1+2
.b99c	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.b99e	85 1d		sta $1d				sta 	zLTemp1+3
.b9a0	5a		phy				phy
.b9a1	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.b9a3	b1 1a		lda ($1a),y			lda 	(zlTemp1),y
.b9a5	71 1c		adc ($1c),y			adc 	(zlTemp1+2),y
.b9a7	7a		ply				ply
.b9a8	b0 33		bcs $b9dd			bcs 	_CSError					; check in range.
.b9aa	c9 fe		cmp #$fe			cmp 	#maxString+1
.b9ac	b0 2f		bcs $b9dd			bcs 	_CSError
.b9ae	20 16 be	jsr $be16			jsr 	AllocateTempString 			; store the result
.b9b1	20 c8 b9	jsr $b9c8			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.b9b4	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.b9b6	85 1a		sta $1a				sta 	zLTemp1
.b9b8	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.b9ba	85 1b		sta $1b				sta 	zLTemp1+1
.b9bc	20 c8 b9	jsr $b9c8			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.b9bf	a5 20		lda $20				lda 	zTempStr 					; point current to new string
.b9c1	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b9c3	a5 21		lda $21				lda 	zTempStr+1
.b9c5	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b9c7	60		rts				rts
.b9c8					_CSCopyString:
.b9c8	da		phx				phx
.b9c9	5a		phy				phy
.b9ca	a0 00		ldy #$00			ldy 	#0 							; get length
.b9cc	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b9ce	f0 0a		beq $b9da			beq 	_CSCSExit 					; if zero, exit
.b9d0	aa		tax				tax 								; put in X
.b9d1					_CSCSLoop:
.b9d1	c8		iny				iny 								; get next char
.b9d2	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b9d4	20 41 be	jsr $be41			jsr		WriteTempString 			; copy out
.b9d7	ca		dex				dex 								; do whole string
.b9d8	d0 f7		bne $b9d1			bne 	_CSCSLoop
.b9da					_CSCSExit:
.b9da	7a		ply				ply
.b9db	fa		plx				plx
.b9dc	60		rts				rts
.b9dd					_CSError:
.b9dd	20 e7 ad	jsr $ade7			jsr ERR_Handler
>b9e0	53 74 72 69 6e 67 20 74			.text "String too long",0
>b9e8	6f 6f 20 6c 6f 6e 67 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.b9f0					Unary_Sgn:
.b9f0	20 96 b7	jsr $b796			jsr 	EvaluateNumberX 			; get value
.b9f3	20 d4 bd	jsr $bdd4			jsr 	CheckNextRParen 			; check right bracket.
.b9f6	20 14 ba	jsr $ba14			jsr 	GetSignCurrent 				; get sign.
.b9f9	09 00		ora #$00			ora 	#0
.b9fb	10 08		bpl $ba05			bpl		UnarySetAInteger			; if 0,1 return that.
.b9fd	80 00		bra $b9ff			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.b9ff					UnarySetAMinus1:
.b9ff	a9 ff		lda #$ff			lda 	#$FF
.ba01	95 80		sta $80,x			sta 	XS_Mantissa,x
.ba03	80 04		bra $ba09			bra 	UnarySetAFill
.ba05					UnarySetAInteger:
.ba05	95 80		sta $80,x			sta 	XS_Mantissa,x
.ba07	a9 00		lda #$00			lda 	#0
.ba09					UnarySetAFill:
.ba09	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.ba0b	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.ba0d	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.ba0f	a9 01		lda #$01			lda 	#1
.ba11	95 85		sta $85,x			sta 	XS_Type,x
.ba13	60		rts				rts
.ba14					GetSignCurrent:
.ba14	b5 85		lda $85,x			lda 	XS_Type,x 					; identify type.
.ba16	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.ba17	90 15		bcc $ba2e			bcc 	_GSCFloat
.ba19	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.ba1b	30 0e		bmi $ba2b			bmi 	_GSCMinus1
.ba1d	15 80		ora $80,x			ora 	XS_Mantissa+0,x
.ba1f	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.ba21	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.ba23	d0 03		bne $ba28			bne 	_GSCPlus1
.ba25					_GSCZero:
.ba25	a9 00		lda #$00			lda 	#0
.ba27	60		rts				rts
.ba28					_GSCPlus1:
.ba28	a9 01		lda #$01			lda 	#$01
.ba2a	60		rts				rts
.ba2b					_GSCMinus1:
.ba2b	a9 ff		lda #$ff			lda 	#$FF
.ba2d	60		rts				rts
.ba2e					_GSCFloat:
.ba2e	34 85		bit $85,x			bit 	XS_Type,x
.ba30	70 f3		bvs $ba25			bvs 	_GSCZero
.ba32	30 f7		bmi $ba2b			bmi 	_GSCMinus1
.ba34	80 f2		bra $ba28			bra 	_GSCPlus1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.ba36					Unary_Abs:
.ba36	20 96 b7	jsr $b796			jsr 	EvaluateNumberX 			; get value
.ba39	20 d4 bd	jsr $bdd4			jsr 	CheckNextRParen 			; check right bracket.
.ba3c	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.ba3e	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.ba40	f0 07		beq $ba49			beq 	_UAMinusFloat
.ba42	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; check MSB
.ba44	10 09		bpl $ba4f			bpl 	_UAExit
.ba46	4c 41 c3	jmp $c341			jmp 	IntegerNegateAlways 		; negation
.ba49					_UAMinusFloat:
.ba49	b5 85		lda $85,x			lda 	XS_Type,x 					; clear the sign bit.
.ba4b	29 7f		and #$7f			and		#$7F
.ba4d	95 85		sta $85,x			sta 	XS_Type,x
.ba4f					_UAExit:
.ba4f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.ba50					Unary_Peek:
.ba50	a9 01		lda #$01			lda 	#1
.ba52	80 06		bra $ba5a			bra 	UPMain
.ba54					Unary_Deek:
.ba54	a9 02		lda #$02			lda 	#2
.ba56	80 02		bra $ba5a			bra 	UPMain
.ba58					Unary_Leek:
.ba58	a9 04		lda #$04			lda 	#4
.ba5a					UPMain:
.ba5a	48		pha				pha 								; set bytes to copy.
.ba5b	20 a4 b7	jsr $b7a4			jsr 	EvaluateIntegerX 			; numeric parameter
.ba5e	20 d4 bd	jsr $bdd4			jsr 	CheckNextRParen 			; right bracket.
.ba61	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.ba63	85 1a		sta $1a				sta 	zLTemp1
.ba65	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.ba67	85 1b		sta $1b				sta 	zLTemp1+1
.ba69	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.ba6b	85 1c		sta $1c				sta 	zLTemp1+2
.ba6d	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.ba6f	85 1d		sta $1d				sta 	zLTemp1+3
.ba71	a9 00		lda #$00			lda 	#0 							; clear target area
.ba73	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.ba75	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.ba77	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.ba79	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.ba7b	68		pla				pla 								; restore bytes to copy
.ba7c	da		phx				phx 								; save XY
.ba7d	5a		phy				phy
.ba7e	20 4b bd	jsr $bd4b			jsr 	MemRead 					; read the bytes in
.ba81	7a		ply				ply 								; restore and exit
.ba82	fa		plx				plx
.ba83	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.ba84					Unary_Mod:
.ba84	20 ac ba	jsr $baac			jsr 	_UMParameter 				; first parameter
.ba87	20 dd bd	jsr $bddd			jsr 	CheckNextComma
.ba8a	da		phx				phx 								; second parameter
.ba8b	e8		inx				inx
.ba8c	e8		inx				inx
.ba8d	e8		inx				inx
.ba8e	e8		inx				inx
.ba8f	e8		inx				inx
.ba90	e8		inx				inx
.ba91	20 ac ba	jsr $baac			jsr 	_UMParameter
.ba94	fa		plx				plx
.ba95	20 d4 bd	jsr $bdd4			jsr 	CheckNextRParen
.ba98	20 ba c2	jsr $c2ba			jsr 	DivInteger32 				; divide
.ba9b	a5 1a		lda $1a				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.ba9d	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.ba9f	a5 1b		lda $1b				lda 	zLTemp1+1
.baa1	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.baa3	a5 1c		lda $1c				lda 	zLTemp1+2
.baa5	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.baa7	a5 1d		lda $1d				lda 	zLTemp1+3
.baa9	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.baab	60		rts				rts
.baac					_UMParameter:
.baac	20 a4 b7	jsr $b7a4			jsr 	EvaluateIntegerX 			; get value
.baaf	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; absolute value
.bab1	10 03		bpl $bab6			bpl 	_UMNotSigned
.bab3	20 41 c3	jsr $c341			jsr 	IntegerNegateAlways
.bab6					_UMNotSigned:
.bab6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.bab7					Unary_Usr:
.bab7	20 96 b7	jsr $b796			jsr 	EvaluateNumberX 			; numeric parameter
.baba	20 d4 bd	jsr $bdd4			jsr 	CheckNextRParen 			; right bracket.
.babd	da		phx				phx 								; save XY
.babe	5a		phy				phy
.babf	ea		nop				nop
.bac0	20 0c 03	jsr $030c			jsr 	UserVector 					; call the USR function.
.bac3	7a		ply				ply 								; and exit
.bac4	fa		plx				plx
.bac5	60		rts				rts
.bac6					USRDefault:
.bac6	20 e7 ad	jsr $ade7			jsr ERR_Handler
>bac9	4e 6f 20 55 53 52 20 76			.text "No USR vector.",0
>bad1	65 63 74 6f 72 2e 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.bad8					Unary_Val:
.bad8	20 ad b7	jsr $b7ad			jsr 	EvaluateStringX 			; get string
.badb	20 d4 bd	jsr $bdd4			jsr 	CheckNextRParen 			; check right bracket.
.bade	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.bae0	85 1e		sta $1e				sta 	zGenPtr
.bae2	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bae4	85 1f		sta $1f				sta 	zGenPtr+1
.bae6	5a		phy				phy
.bae7	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.bae9	b1 1e		lda ($1e),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.baeb	f0 54		beq $bb41			beq 	_UVBadNumber
.baed	48		pha				pha 								; save length.
.baee	1a		inc a				inc 	a 							; one for the length, one for the terminator
.baef	1a		inc a				inc 	a
.baf0	20 16 be	jsr $be16			jsr 	AllocateTempString
.baf3	c8		iny				iny 								; move to the next.
.baf4	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get character
.baf6	49 2d		eor #$2d			eor 	#"-"						; zero if minus sign
.baf8	8d a0 03	sta $03a0			sta 	ValSign
.bafb	d0 04		bne $bb01			bne 	_UVNotMinus
.bafd	c8		iny				iny 								; skip over it.
.bafe	68		pla				pla 								; decrement character count.
.baff	3a		dec a				dec 	a
.bb00	48		pha				pha
.bb01					_UVNotMinus:
.bb01	68		pla				pla 								; this is the count.
.bb02	48		pha		_UVCopy:pha									; copy into new temp string which is ASCIIZ
.bb03	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.bb05	c8		iny				iny
.bb06	20 41 be	jsr $be41			jsr 	WriteTempString
.bb09	68		pla				pla
.bb0a	3a		dec a				dec 	a
.bb0b	d0 f5		bne $bb02			bne 	_UVCopy
.bb0d	20 41 be	jsr $be41			jsr 	WriteTempString 			; make it ASCIIZ
.bb10	18		clc				clc
.bb11	a5 20		lda $20				lda 	zTempStr 					; tempstring +1 => genptr
.bb13	69 01		adc #$01			adc 	#1
.bb15	85 1e		sta $1e				sta 	zGenPtr
.bb17	a5 21		lda $21				lda 	zTempStr+1
.bb19	69 00		adc #$00			adc 	#0
.bb1b	85 1f		sta $1f				sta 	zGenPtr+1
.bb1d	18		clc				clc
.bb1e	20 0f c4	jsr $c40f			jsr 	IntFromString 				; first bit.
.bb21	b0 1e		bcs $bb41			bcs 	_UVBadNumber
.bb23	20 50 c9	jsr $c950			jsr 	FPFromString				; try for a float part.
.bb26	ad a0 03	lda $03a0			lda 	ValSign 					; was it negative
.bb29	d0 10		bne $bb3b			bne 	_UVNotNegative
.bb2b	b5 85		lda $85,x			lda 	XS_Type,x 					; check if integer
.bb2d	4a		lsr a				lsr 	a
.bb2e	b0 08		bcs $bb38			bcs 	_UVInteger
.bb30	b5 85		lda $85,x			lda 	XS_Type,x 					; set sign bit
.bb32	09 80		ora #$80			ora 	#$80
.bb34	95 85		sta $85,x			sta 	XS_Type,x
.bb36	80 03		bra $bb3b			bra 	_UVNotNegative
.bb38					_UVInteger:
.bb38	20 41 c3	jsr $c341			jsr 	IntegerNegateAlways 		; sign it.
.bb3b					_UVNotNegative:
.bb3b	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; used everything
.bb3d	d0 02		bne $bb41			bne 	_UVBadNumber
.bb3f	7a		ply				ply
.bb40	60		rts				rts
.bb41					_UVBadNumber:
.bb41	4c d6 ad	jmp $add6			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.bb44					Unary_Str:
.bb44	20 96 b7	jsr $b796			jsr 	EvaluateNumberX 			; numeric parameter
.bb47	20 d4 bd	jsr $bdd4			jsr 	CheckNextRParen 			; right bracket.
.bb4a	a9 00		lda #$00			lda 	#0 							; reset buffer index
.bb4c	8d 14 03	sta $0314			sta 	NumBufX
.bb4f	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.bb51	4a		lsr a				lsr 	a
.bb52	b0 05		bcs $bb59			bcs 	_USInt 						; if msb set do as integer
.bb54	20 95 c8	jsr $c895			jsr 	FPToString 					; call fp to str otherwise
.bb57	80 03		bra $bb5c			bra 	_USDuplicate
.bb59	20 5e c3	jsr $c35e	_USInt:	jsr 	IntToString
.bb5c					_USDuplicate:
.bb5c	ad 14 03	lda $0314			lda 	NumBufX 					; chars in buffer
.bb5f	1a		inc a				inc 	a 							; one more for length
.bb60	20 16 be	jsr $be16			jsr 	AllocateTempString 			; allocate space for it.
.bb63	5a		phy				phy 								; save Y
.bb64	a0 00		ldy #$00			ldy 	#0 							; start copying
.bb66	b9 15 03	lda $0315,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.bb69	20 41 be	jsr $be41			jsr 	WriteTempString
.bb6c	c8		iny				iny
.bb6d	cc 14 03	cpy $0314			cpy 	NumBufX 					; done the lot
.bb70	d0 f4		bne $bb66			bne 	_USCopy
.bb72	7a		ply				ply 								; restore Y
.bb73	4c 3e bd	jmp $bd3e			jmp 	UnaryReturnTempStr 			; return new temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.bb76					Unary_Asc:
.bb76	20 ad b7	jsr $b7ad			jsr 	EvaluateStringX 			; string parameter
.bb79	20 d4 bd	jsr $bdd4			jsr 	CheckNextRParen 			; right bracket.
.bb7c	5a		phy				phy 								; get the string length
.bb7d	a0 00		ldy #$00			ldy 	#0
.bb7f	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.bb81	f0 07		beq $bb8a			beq 	_UAIllegal 					; must be at least one character
.bb83	c8		iny				iny
.bb84	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; read it.
.bb86	7a		ply				ply
.bb87	4c 05 ba	jmp $ba05			jmp 	UnarySetAInteger
.bb8a					_UAIllegal:
.bb8a	4c d6 ad	jmp $add6			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.bb8d					Unary_Len:
.bb8d	20 ad b7	jsr $b7ad			jsr 	EvaluateStringX 			; string parameter
.bb90	20 d4 bd	jsr $bdd4			jsr 	CheckNextRParen 			; right bracket.
.bb93	5a		phy				phy 								; get the string length
.bb94	a0 00		ldy #$00			ldy 	#0
.bb96	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.bb98	7a		ply				ply
.bb99	4c 05 ba	jmp $ba05			jmp 	UnarySetAInteger

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.bb9c					Unary_Mid:
.bb9c	20 ad b7	jsr $b7ad			jsr 	EvaluateStringX 				; get string.
.bb9f	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.bba1	48		pha				pha
.bba2	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bba4	48		pha				pha
.bba5	20 dd bd	jsr $bddd			jsr 	CheckNextComma 					; skip comma
.bba8	20 31 bc	jsr $bc31			jsr 	SLIByteParameter 				; get a byte parameter (start)
.bbab	48		pha				pha 									; and push it.
.bbac	20 dd bd	jsr $bddd			jsr 	CheckNextComma 					; skip comma
.bbaf	20 31 bc	jsr $bc31			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.bbb2	48		pha				pha 									; and push it.
.bbb3	80 41		bra $bbf6			bra 	SLIProcess
.bbb5					Unary_Left:
.bbb5	20 ad b7	jsr $b7ad			jsr 	EvaluateStringX 				; get string.
.bbb8	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.bbba	48		pha				pha
.bbbb	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bbbd	48		pha				pha
.bbbe	a9 01		lda #$01			lda 	#1 								; push start position (1)
.bbc0	48		pha				pha
.bbc1	20 dd bd	jsr $bddd			jsr 	CheckNextComma 					; skip comma
.bbc4	20 31 bc	jsr $bc31			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.bbc7	48		pha				pha 									; and push it.
.bbc8	80 2c		bra $bbf6			bra 	SLIProcess
.bbca					Unary_Right:
.bbca	20 ad b7	jsr $b7ad			jsr 	EvaluateStringX 				; get string.
.bbcd	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.bbcf	48		pha				pha
.bbd0	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bbd2	48		pha				pha
.bbd3	da		phx				phx 									; get the string length and push on stack.
.bbd4	a2 00		ldx #$00			ldx 	#0
.bbd6	a1 1e		lda ($1e,x)			lda		(zGenPtr,x)
.bbd8	fa		plx				plx
.bbd9	48		pha				pha
.bbda	20 dd bd	jsr $bddd			jsr 	CheckNextComma 					; skip comma
.bbdd	20 31 bc	jsr $bc31			jsr 	SLIByteParameter 				; get a byte parameter.
.bbe0	8d 9e 03	sta $039e			sta 	SignCount 						; save in temporary.
.bbe3	68		pla				pla 									; restore string length.
.bbe4	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.bbe5	38		sec				sec
.bbe6	ed 9e 03	sbc $039e			sbc 	SignCount 						; subtract characters needed, gives start position.
.bbe9	f0 02		beq $bbed			beq 	_URStart 						; if <= 0 start from 1.
.bbeb	10 02		bpl $bbef			bpl 	_UROkay
.bbed					_URStart:
.bbed	a9 01		lda #$01			lda 	#1
.bbef					_UROkay:
.bbef	48		pha				pha 									; push start
.bbf0	ad 9e 03	lda $039e			lda 	SignCount 						; push count of characters
.bbf3	48		pha				pha
.bbf4	80 00		bra $bbf6			bra 	SLIProcess
.bbf6					SLIProcess:
.bbf6	20 d4 bd	jsr $bdd4			jsr 	CheckNextRParen 				; closing right bracket.
.bbf9	68		pla				pla
.bbfa	8d a2 03	sta $03a2			sta 	SliceCount 						; count in signcount
.bbfd	1a		inc a				inc 	a 								; allocate +1 for it.
.bbfe	20 16 be	jsr $be16			jsr 	AllocateTempString
.bc01	68		pla				pla 									; pop start number off stack.
.bc02	f0 3b		beq $bc3f			beq 	SLIError 						; exit if start = 0
.bc04	8d a1 03	sta $03a1			sta 	SliceStart
.bc07	68		pla				pla  									; pop string address.
.bc08	85 1f		sta $1f				sta 	zGenPtr+1
.bc0a	68		pla				pla
.bc0b	85 1e		sta $1e				sta 	zGenPtr
.bc0d	da		phx				phx
.bc0e	5a		phy				phy
.bc0f	a2 00		ldx #$00			ldx 	#0 								; point to string length.
.bc11	ac a1 03	ldy $03a1			ldy 	SliceStart 						; start of the string (+1 for count)
.bc14					_SLICopy:
.bc14	ad a2 03	lda $03a2			lda 	SliceCount 						; done count characters
.bc17	f0 12		beq $bc2b			beq 	_SLIExit
.bc19	ce a2 03	dec $03a2			dec 	SliceCount
.bc1c	98		tya				tya 									; index of character
.bc1d	c1 1e		cmp ($1e,x)			cmp 	(zGenPtr,x)						; compare against length
.bc1f	f0 02		beq $bc23			beq 	_SLIOk 							; if equal, okay.
.bc21	b0 08		bcs $bc2b			bcs 	_SLIExit 						; if past end, then exit.
.bc23	b1 1e		lda ($1e),y	_SLIOk:	lda 	(zGenPtr),y 					; copy one character
.bc25	c8		iny				iny
.bc26	20 41 be	jsr $be41			jsr 	WriteTempString
.bc29	80 e9		bra $bc14			bra 	_SLICopy 						; go round till copied characters
.bc2b					_SLIExit:
.bc2b	7a		ply				ply 									; restore YX
.bc2c	fa		plx				plx
.bc2d	4c 3e bd	jmp $bd3e			jmp 	UnaryReturnTempStr 				; return new temporary string.
.bc30	ea		nop				nop
.bc31					SLIByteParameter:
.bc31	20 a4 b7	jsr $b7a4			jsr 	EvaluateIntegerX 				; get integer
.bc34	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.bc36	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.bc38	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.bc3a	d0 03		bne $bc3f			bne 	SLIError
.bc3c	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.bc3e	60		rts				rts
.bc3f					SLIError:
.bc3f	4c d6 ad	jmp $add6			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.bc42					Unary_Hex:
.bc42	20 a4 b7	jsr $b7a4			jsr 	EvaluateIntegerX 			; numeric parameter
.bc45	20 d4 bd	jsr $bdd4			jsr 	CheckNextRParen 			; right bracket.
.bc48	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.bc4a	20 16 be	jsr $be16			jsr 	AllocateTempString			; allocate string space
.bc4d	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.bc4f	20 73 bc	jsr $bc73			jsr 	_UHConvert
.bc52	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.bc54	20 73 bc	jsr $bc73			jsr 	_UHConvert
.bc57	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bc59	20 73 bc	jsr $bc73			jsr 	_UHConvert
.bc5c	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.bc5e	20 73 bc	jsr $bc73			jsr 	_UHConvert
.bc61	5a		phy				phy 								; get length of new string
.bc62	a0 00		ldy #$00			ldy 	#0
.bc64	b1 20		lda ($20),y			lda 	(zTempStr),y
.bc66	7a		ply				ply
.bc67	c9 00		cmp #$00			cmp 	#0
.bc69	d0 05		bne $bc70			bne 	_UHExit 					; if it was non zero okay
.bc6b	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.bc6d	20 41 be	jsr $be41			jsr 	WriteTempString
.bc70					_UHExit:
.bc70	4c 3e bd	jmp $bd3e			jmp 	UnaryReturnTempStr 			; return new temporary string.
.bc73					_UHConvert:
.bc73	48		pha				pha
.bc74	4a		lsr a				lsr 	a 							; do MSB
.bc75	4a		lsr a				lsr 	a
.bc76	4a		lsr a				lsr 	a
.bc77	4a		lsr a				lsr 	a
.bc78	20 7c bc	jsr $bc7c			jsr 	_UHNibble
.bc7b	68		pla				pla 								; do LSB
.bc7c					_UHNibble:
.bc7c	29 0f		and #$0f			and 	#15 						; get nibble
.bc7e	d0 0c		bne $bc8c			bne 	_UHNonZero
.bc80	5a		phy				phy									; get the length
.bc81	a0 00		ldy #$00			ldy 	#0
.bc83	b1 20		lda ($20),y			lda 	(zTempStr),y
.bc85	7a		ply				ply
.bc86	c9 00		cmp #$00			cmp 	#0 							; suppress leading zeros.
.bc88	f0 0d		beq $bc97			beq 	_UHExit2
.bc8a	a9 00		lda #$00			lda 	#0
.bc8c					_UHNonZero:
.bc8c	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.bc8e	90 02		bcc $bc92			bcc 	_UHDigit
.bc90	69 06		adc #$06			adc 	#7-1
.bc92					_UHDigit:
.bc92	69 30		adc #$30			adc 	#48
.bc94	20 41 be	jsr $be41			jsr 	WriteTempString				; output.
.bc97					_UHExit2:
.bc97	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.bc98					Unary_Dec:
.bc98	20 ad b7	jsr $b7ad			jsr 	EvaluateStringX 			; string parameter
.bc9b	20 d4 bd	jsr $bdd4			jsr 	CheckNextRParen 			; right bracket.
.bc9e	5a		phy				phy
.bc9f	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.bca1	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.bca3	f0 41		beq $bce6			beq 	_UDFail 					; must fail if zero.
.bca5	8d 9e 03	sta $039e			sta 	SignCount 					; use SignCount as a counter
.bca8	a9 00		lda #$00			lda 	#0 							; set result to zero integer.
.bcaa	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.bcac	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bcae	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.bcb0	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.bcb2	a9 01		lda #$01			lda 	#1
.bcb4	95 85		sta $85,x			sta 	XS_Type,x
.bcb6					_UDConvertLoop:
.bcb6	5a		phy				phy 								; shift mantissa left 4
.bcb7	a0 04		ldy #$04			ldy 	#4
.bcb9					_UDShift:
.bcb9	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.bcbb	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.bcbd	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.bcbf	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.bcc1	88		dey				dey
.bcc2	d0 f5		bne $bcb9			bne 	_UDShift
.bcc4	7a		ply				ply
.bcc5	c8		iny				iny 								; next character
.bcc6	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; fetch it.
.bcc8	20 e9 bc	jsr $bce9			jsr 	ConvertUpper 				; convert to U/C
.bccb	c9 30		cmp #$30			cmp 	#"0"
.bccd	90 17		bcc $bce6			bcc 	_UDFail
.bccf	c9 3a		cmp #$3a			cmp 	#"9"+1
.bcd1	90 06		bcc $bcd9			bcc 	_UDOkay
.bcd3	e9 37		sbc #$37			sbc 	#7+"0" 						; alpha fudge
.bcd5	c9 10		cmp #$10			cmp 	#16
.bcd7	b0 0d		bcs $bce6			bcs 	_UDFail
.bcd9					_UDOkay:
.bcd9	29 0f		and #$0f			and 	#15 						; nibble only
.bcdb	15 80		ora $80,x			ora 	XS_Mantissa+0,x
.bcdd	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.bcdf	ce 9e 03	dec $039e			dec 	SignCount 					; do it for each character
.bce2	d0 d2		bne $bcb6			bne 	_UDConvertLoop
.bce4	7a		ply				ply
.bce5	60		rts				rts
.bce6					_UDFail:
.bce6	4c d6 ad	jmp $add6			jmp 	BadParamError
.bce9					ConvertUpper:
.bce9	c9 61		cmp #$61			cmp 	#"a"
.bceb	90 07		bcc $bcf4			bcc 	_CUExit
.bced	c9 7b		cmp #$7b			cmp 	#"z"+1
.bcef	b0 03		bcs $bcf4			bcs 	_CUExit
.bcf1	38		sec				sec
.bcf2	e9 20		sbc #$20			sbc 	#32
.bcf4	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.bcf5					Unary_Chr:
.bcf5	20 a4 b7	jsr $b7a4			jsr 	EvaluateIntegerX			; numeric parameter
.bcf8	20 d4 bd	jsr $bdd4			jsr 	CheckNextRParen 			; right bracket.
.bcfb	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.bcfd	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.bcff	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.bd01	d0 0d		bne $bd10			bne 	_UCChar
.bd03	a9 01		lda #$01			lda 	#1 							; one character string
.bd05	20 16 be	jsr $be16			jsr 	AllocateTempString
.bd08	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.bd0a	20 41 be	jsr $be41			jsr 	WriteTempString
.bd0d	4c 3e bd	jmp $bd3e			jmp 	UnaryReturnTempStr
.bd10					_UCChar:
.bd10	4c d6 ad	jmp $add6			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.bd13					Unary_Spc:
.bd13	20 a4 b7	jsr $b7a4			jsr 	EvaluateIntegerX 			; numeric parameter
.bd16	20 d4 bd	jsr $bdd4			jsr 	CheckNextRParen 			; right bracket.
.bd19	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.bd1b	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.bd1d	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.bd1f	d0 1a		bne $bd3b			bne 	_USSize
.bd21	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.bd23	c9 fe		cmp #$fe			cmp 	#maxString+1
.bd25	b0 14		bcs $bd3b			bcs 	_USSize
.bd27	48		pha				pha 								; save length
.bd28	1a		inc a				inc 	a 							; allocate one more.
.bd29	20 16 be	jsr $be16			jsr 	AllocateTempString
.bd2c	68		pla				pla 								; get length
.bd2d	f0 0f		beq $bd3e			beq 	UnaryReturnTempStr 			; return the current temp string
.bd2f					_USLoop:
.bd2f	48		pha				pha
.bd30	a9 20		lda #$20			lda 	#" "
.bd32	20 41 be	jsr $be41			jsr 	WriteTempString
.bd35	68		pla				pla
.bd36	3a		dec a				dec 	a
.bd37	d0 f6		bne $bd2f			bne 	_USLoop
.bd39	80 03		bra $bd3e			bra 	UnaryReturnTempStr
.bd3b					_USSize:
.bd3b	4c d6 ad	jmp $add6			jmp 	BadParamError
.bd3e					UnaryReturnTempStr:
.bd3e	a5 20		lda $20				lda 	zTempStr 					; copy temp string addr -> mantissa
.bd40	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.bd42	a5 21		lda $21				lda 	zTempStr+1
.bd44	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bd46	a9 02		lda #$02			lda 	#2 							; set type to string
.bd48	95 85		sta $85,x			sta 	XS_Type,x
.bd4a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/4510.asm

.bd4b	db		phz		MemRead:phz
.bd4c	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.bd4f	a3 00		ldz #$00			ldz 	#0 							; start from here
.bd51	ea		nop		_MLoop1:nop
.bd52	b2 1a		lda ($1a),z			lda 	(zlTemp1),z 				; read the long address
.bd54	95 80		sta $80,x			sta 	XS_Mantissa,x 				; copy into mantissa
.bd56	1b		inz				inz 								; next to copy
.bd57	e8		inx				inx
.bd58	dc 9e 03	cpz $039e			cpz 	SignCount 					; do required # of bytes.
.bd5b	d0 f4		bne $bd51			bne 	_MLoop1
.bd5d	fb		plz				plz
.bd5e	60		rts				rts
.bd5f					MemWrite:
.bd5f	db		phz				phz
.bd60	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.bd63	a3 00		ldz #$00			ldz 	#0 							; start from here
.bd65	b5 80		lda $80,x	_MLoop1:lda 	XS_Mantissa,x 				; read mantisssa
.bd67	ea		nop				nop
.bd68	92 1a		sta ($1a),z			sta 	(zlTemp1),z 				; write it out
.bd6a	1b		inz				inz 								; next to copy
.bd6b	e8		inx				inx
.bd6c	cc 9e 03	cpy $039e			cpy 	SignCount 					; do required # of bytes.
.bd6f	d0 f4		bne $bd65			bne 	_MLoop1
.bd71	fb		plz				plz
.bd72	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/programend.asm

.bd73					UpdateProgramEnd:
.bd73	a9 00		lda #$00			lda 	#BasicProgram & $FF
.bd75	85 16		sta $16				sta 	zCodePtr+0
.bd77	a9 80		lda #$80			lda 	#BasicProgram >> 8
.bd79	85 17		sta $17				sta 	zCodePtr+1
.bd7b	a9 02		lda #$02			lda 	#2
.bd7d	85 18		sta $18				sta 	zCodePtr+2
.bd7f	a9 00		lda #$00			lda 	#0
.bd81	85 19		sta $19				sta 	zCodePtr+3
.bd83	a3 03		ldz #$03			ldz 	#3
.bd85					_UPDLoop:
.bd85	a3 00		ldz #$00			ldz 	#0
.bd87	ea		nop				nop
.bd88	b2 16		lda ($16),z			lda 	(zCodePtr),z
.bd8a	c9 00		cmp #$00			cmp 	#0 							; end if offset is zero.
.bd8c	f0 10		beq $bd9e			beq 	_UPDFoundEnd
.bd8e	a3 00		ldz #$00			ldz 	#0 							; point to offset
.bd90	ea		nop				nop
.bd91	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read it
.bd93	18		clc				clc
.bd94	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.bd96	85 16		sta $16				sta 	zCodePtr
.bd98	90 02		bcc $bd9c			bcc 	_SNLNoCarry
.bd9a	e6 17		inc $17				inc 	zCodePtr+1
.bd9c					_SNLNoCarry:
.bd9c	80 e7		bra $bd85			bra 	_UPDLoop
.bd9e					_UPDFoundEnd:
.bd9e	18		clc				clc 								; end of program 2 on.
.bd9f	a5 16		lda $16				lda 	zCodePtr
.bda1	69 02		adc #$02			adc 	#2
.bda3	8d 04 03	sta $0304			sta 	endOfProgram
.bda6	a5 17		lda $17				lda 	zCodePtr+1
.bda8	69 00		adc #$00			adc 	#0
.bdaa	8d 05 03	sta $0305			sta 	endOfProgram+1
.bdad	a5 18		lda $18				lda 	zCodePtr+2
.bdaf	69 00		adc #$00			adc		#0
.bdb1	8d 06 03	sta $0306			sta 	endOfProgram+2
.bdb4	a5 19		lda $19				lda 	zCodePtr+3
.bdb6	69 00		adc #$00			adc 	#0
.bdb8	8d 07 03	sta $0307			sta 	endOfProgram+3
.bdbb	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.bdbc					CheckNextToken:
.bdbc	ea		nop				nop
.bdbd	d2 16		cmp ($16),z			cmp 	(zCodePtr),z
.bdbf	d0 02		bne $bdc3			bne 	CTFail 						; no, then fail
.bdc1	1b		inz				inz
.bdc2	60		rts				rts
.bdc3					CTFail:
.bdc3	20 e7 ad	jsr $ade7			jsr ERR_Handler
>bdc6	4d 69 73 73 69 6e 67 20			.text "Missing token",0
>bdce	74 6f 6b 65 6e 00
.bdd4					CheckNextRParen:
.bdd4	ea		nop				nop
.bdd5	b2 16		lda ($16),z			lda 	(zCodePtr),z
.bdd7	c9 be		cmp #$be			cmp 	#token_rparen
.bdd9	d0 e8		bne $bdc3			bne 	CTFail
.bddb	1b		inz				inz
.bddc	60		rts				rts
.bddd					CheckNextComma:
.bddd	ea		nop				nop
.bdde	b2 16		lda ($16),z			lda 	(zCodePtr),z
.bde0	c9 bf		cmp #$bf			cmp 	#token_comma
.bde2	d0 df		bne $bdc3			bne 	CTFail
.bde4	1b		inz				inz
.bde5	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/concrete.asm

.bde6					StringConcrete:
.bde6	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; save source to zTemp1
.bde8	85 10		sta $10				sta 	zTemp1
.bdea	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bdec	85 11		sta $11				sta 	zTemp1+1
.bdee	a0 00		ldy #$00			ldy 	#0 							; subtract the length+1 (clc) of the string.
.bdf0	18		clc				clc 								; from the string pointer
.bdf1	ad 00 03	lda $0300			lda 	StringPtr 					; and put in zTemp2 as well
.bdf4	f1 10		sbc ($10),y			sbc 	(zTemp1),y
.bdf6	8d 00 03	sta $0300			sta 	StringPtr
.bdf9	85 12		sta $12				sta 	zTemp2
.bdfb	ad 01 03	lda $0301			lda 	StringPtr+1
.bdfe	e9 00		sbc #$00			sbc 	#0
.be00	8d 01 03	sta $0301			sta 	StringPtr+1
.be03	85 13		sta $13				sta 	zTemp2+1
.be05	b1 10		lda ($10),y			lda 	(zTemp1),y 					; length add one for count
.be07	1a		inc a				inc 	a
.be08	aa		tax				tax
.be09	b1 10		lda ($10),y	_SCCopy:lda 	(zTemp1),y 					; copy whole thing including length
.be0b	91 12		sta ($12),y			sta 	(zTemp2),y
.be0d	c8		iny				iny
.be0e	ca		dex				dex
.be0f	d0 f8		bne $be09			bne 	_SCCopy
.be11	a5 13		lda $13				lda 	zTemp2+1 					; return concrete string in AX
.be13	a6 12		ldx $12				ldx 	zTemp2
.be15	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.be16					AllocateTempString:
.be16	48		pha				pha 								; save required count.
.be17	a5 21		lda $21				lda 	zTempStr+1 					; check if initialised yet ?
.be19	d0 0b		bne $be26			bne 	_ATSInitialised
.be1b	ad 00 03	lda $0300			lda 	StringPtr 					; set temporary string ptr 1 page below available
.be1e	85 20		sta $20				sta 	zTempStr					; space, this is for strings to be concreted.
.be20	ad 01 03	lda $0301			lda 	StringPtr+1
.be23	3a		dec a				dec 	a
.be24	85 21		sta $21				sta 	zTempStr+1
.be26					_ATSInitialised:
.be26	68		pla				pla 								; get required count back.
.be27	49 ff		eor #$ff			eor 	#$FF 						; negate 2's complement.
.be29	1a		inc a				inc 	a
.be2a	18		clc				clc
.be2b	65 20		adc $20				adc 	zTempStr 					; "add" to the temp string pointer
.be2d	85 20		sta $20				sta 	zTempStr
.be2f	a9 ff		lda #$ff			lda 	#$FF
.be31	65 21		adc $21				adc 	zTempStr+1
.be33	85 21		sta $21				sta 	zTempStr+1
.be35	a9 00		lda #$00			lda 	#0 							; clear temp string.
.be37	5a		phy				phy
.be38	a8		tay				tay
.be39	91 20		sta ($20),y			sta 	(zTempStr),y
.be3b	7a		ply				ply
.be3c	1a		inc a				inc 	a 							; reset the write index.
.be3d	8d 9f 03	sta $039f			sta 	TempStringWriteIndex
.be40	60		rts				rts
.be41					WriteTempString:
.be41	5a		phy				phy 								; save Y
.be42	ac 9f 03	ldy $039f			ldy 	TempStringWriteIndex	 	; write position.
.be45	91 20		sta ($20),y			sta 	(zTempStr),y 				; write character out.
.be47	ee 9f 03	inc $039f			inc 	TempStringWriteIndex 		; increment the write position.
.be4a	98		tya				tya 								; unchanged Y is now length
.be4b	a0 00		ldy #$00			ldy 	#0
.be4d	91 20		sta ($20),y			sta 	(zTempStr),y
.be4f	7a		ply				ply 								; restore Y and exit
.be50	60		rts				rts
.be51					CreateTempStringCopy:
.be51	da		phx				phx 								; save X
.be52	ea		nop				nop
.be53	b2 16		lda ($16),z			lda 	(zCodePtr),z
.be55	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.be56	20 16 be	jsr $be16			jsr 	AllocateTempString 			; allocate memory for temporary string.
.be59	ea		nop				nop
.be5a	b2 16		lda ($16),z			lda 	(zCodePtr),z
.be5c	1b		inz				inz
.be5d	3a		dec a				dec 	a 							; make the actual length in charactes
.be5e	3a		dec a				dec 	a
.be5f	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.be61	81 20		sta ($20,x)			sta 	(zTempStr,x)
.be63	85 1a		sta $1a				sta 	zLTemp1 					; that's used as a count.
.be65	09 00		ora #$00			ora 	#0 							; if zero already, exit
.be67	f0 0f		beq $be78			beq 	_CTSCExit
.be69					_CTSCLoop:
.be69	ea		nop				nop
.be6a	b2 16		lda ($16),z			lda 	(zCodePtr),z
.be6c	1b		inz				inz
.be6d	5a		phy				phy 								; save in Y
.be6e	e8		inx				inx 								; bump index
.be6f	da		phx				phx 								; index into Y
.be70	7a		ply				ply
.be71	91 20		sta ($20),y			sta 	(zTempStr),y 				; save at index
.be73	7a		ply				ply 								; restore Y
.be74	c6 1a		dec $1a				dec 	zLTemp1 					; do for each character
.be76	d0 f1		bne $be69			bne 	_CTSCLoop
.be78					_CTSCExit:
.be78	fa		plx				plx 								; restore X
.be79	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/variables.asm

.be7a					VariableFind:
.be7a	20 e5 be	jsr $bee5			jsr 	VariableExtract 		; find out all about it ....
.be7d	20 80 c1	jsr $c180			jsr 	VariableLocate 			; does it already exist ?
.be80	b0 03		bcs $be85			bcs 	_VFExists 				; if so, use that.
.be82	20 73 bf	jsr $bf73			jsr 	VariableCreate 			; otherwise create it.
.be85					_VFExists:
.be85	a5 24		lda $24				lda 	zVarType 				; is it still an array ?
.be87	29 01		and #$01			and 	#1
.be89	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.be8b	d0 28		bne $beb5			bne 	_VFSingleElement
.be8d					_VFNextIndex:
.be8d	a5 22		lda $22				lda 	zVarDataPtr 			; push the data ptr and type on the stack.
.be8f	48		pha				pha
.be90	a5 23		lda $23				lda 	zVarDataPtr+1
.be92	48		pha				pha
.be93	a5 24		lda $24				lda 	zVarType
.be95	48		pha				pha
.be96	20 a4 b7	jsr $b7a4			jsr 	EvaluateIntegerX 		; calculate the index.
.be99	68		pla				pla 							; restore and index.
.be9a	85 24		sta $24				sta 	zVarType
.be9c	68		pla				pla
.be9d	85 23		sta $23				sta 	zVarDataPtr+1
.be9f	68		pla				pla
.bea0	85 22		sta $22				sta 	zVarDataPtr
.bea2	20 fe bf	jsr $bffe			jsr 	ArrayIndexFollow 		; do the index.
.bea5	a5 24		lda $24				lda 	zVarType 				; is it still an array ??
.bea7	29 01		and #$01			and 	#1
.bea9	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.beab	d0 05		bne $beb2			bne 	_VFArrayDone 			; if so then exit.
.bead	20 dd bd	jsr $bddd			jsr 	CheckNextComma 			; comma should follow
.beb0	80 db		bra $be8d			bra 	_VFNextIndex
.beb2					_VFArrayDone:
.beb2	20 d4 bd	jsr $bdd4			jsr 	CheckNextRParen 		; check closing right bracket.
.beb5					_VFSingleElement:
.beb5	60		rts				rts
.beb6					VariableClear:
.beb6	48		pha				pha 							; save registers
.beb7	da		phx				phx
.beb8	a2 00		ldx #$00			ldx 	#0 						; clear out the hash table.
.beba	8a		txa				txa
.bebb	9d 35 03	sta $0335,x	_VCLoop:sta 	HashTableBase,x
.bebe	e8		inx				inx
.bebf	e0 60		cpx #$60			cpx 	#HashTableEnd-HashTableBase
.bec1	d0 f8		bne $bebb			bne 	_VCLoop
.bec3	a9 00		lda #$00			lda 	#VariableMemory & $FF
.bec5	8d 02 03	sta $0302			sta 	VarMemPtr
.bec8	a9 20		lda #$20			lda 	#VariableMemory >> 8
.beca	8d 03 03	sta $0303			sta 	VarMemPtr+1
.becd	fa		plx				plx 							; restore registers
.bece	68		pla				pla
.becf	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/extract.asm

.bed0					VariableNameError:
.bed0	20 e7 ad	jsr $ade7			jsr ERR_Handler
>bed3	42 61 64 20 56 61 72 69			.text "Bad Variable Name",0
>bedb	61 62 6c 65 20 4e 61 6d 65 00
.bee5					VariableExtract:
.bee5	da		phx				phx 							; save X.
.bee6	a9 ba		lda #$ba			lda 	#token_hashlParen  		; set the type to #( e.g. real array.
.bee8	8d 95 03	sta $0395			sta 	Var_Type
.beeb	8d 96 03	sta $0396			sta 	Var_Hash 				; we initialise the hash with this. It doesn't matter
.beee	ea		nop				nop
.beef	b2 16		lda ($16),z			lda 	(zCodePtr),z
.bef1	c9 00		cmp #$00			cmp 	#0 						; first one must be A-Z
.bef3	f0 db		beq $bed0			beq 	VariableNameError
.bef5	c9 1b		cmp #$1b			cmp 	#26+1
.bef7	b0 d7		bcs $bed0			bcs 	VariableNameError
.bef9	a2 ff		ldx #$ff			ldx 	#255 					; now copy it into the variable buffer.
.befb					_VECopyBuffer:
.befb	e8		inx				inx
.befc	e0 1f		cpx #$1f			cpx 	#31 					; too long
.befe	f0 d0		beq $bed0			beq 	VariableNameError
.bf00	9d 15 03	sta $0315,x			sta 	Var_Buffer,x 			; save character
.bf03	18		clc				clc  							; update the hash value for it.
.bf04	6d 96 03	adc $0396			adc 	Var_Hash
.bf07	8d 96 03	sta $0396			sta 	Var_Hash
.bf0a	1b		inz				inz
.bf0b	ea		nop				nop
.bf0c	b2 16		lda ($16),z			lda 	(zCodePtr),z
.bf0e	c9 00		cmp #$00			cmp 	#0 						; zero or token, end of variable
.bf10	f0 0e		beq $bf20			beq 	_VECopyEnd
.bf12	30 0c		bmi $bf20			bmi 	_VECopyEnd
.bf14	c9 1b		cmp #$1b			cmp 	#26+1 					; A-Z continue copying
.bf16	90 e3		bcc $befb			bcc 	_VECopyBuffer
.bf18	c9 30		cmp #$30			cmp 	#"0" 					; 0-9 copy as well.
.bf1a	90 04		bcc $bf20			bcc 	_VECopyEnd
.bf1c	c9 3a		cmp #$3a			cmp 	#"9"+1
.bf1e	90 db		bcc $befb			bcc 	_VECopyBuffer
.bf20					_VECopyEnd:
.bf20	1b		inz				inz
.bf21	c9 b7		cmp #$b7			cmp 	#token_Dollar 			; first type token.
.bf23	90 04		bcc $bf29			bcc 	_VEDefaultRequired
.bf25	c9 bd		cmp #$bd			cmp 	#token_PercentLParen+1	; last type token.
.bf27	90 0b		bcc $bf34			bcc 	_VEHaveType
.bf29					_VEDefaultRequired:
.bf29	c9 bd		cmp #$bd			cmp 	#token_LParen 			; if it ends in ( then use the real array
.bf2b	f0 04		beq $bf31			beq 	_VESetType 				; default set above.
.bf2d	ce 95 03	dec $0395			dec 	Var_Type 				; this changes that default to the variable default
.bf30	3b		dez				dez
.bf31					_VESetType:
.bf31	ad 95 03	lda $0395			lda 	Var_Type 				; get type ....
.bf34					_VEHaveType:
.bf34	8d 95 03	sta $0395			sta 	Var_Type 				; save as type.
.bf37	bd 15 03	lda $0315,x			lda 	Var_Buffer,x 			; set bit 7 of name, marks the end.
.bf3a	09 80		ora #$80			ora 	#$80
.bf3c	9d 15 03	sta $0315,x			sta 	Var_Buffer,x
.bf3f	e8		inx				inx 							; offset 3 => length 4.
.bf40	8e 97 03	stx $0397			stx 	Var_Length 				; save length of variable name.
.bf43	ad 95 03	lda $0395			lda 	Var_Type 				; get offset of var type from first type token
.bf46	38		sec				sec
.bf47	e9 b7		sbc #$b7			sbc 	#token_Dollar
.bf49	0a		asl a				asl 	a 						; multiply by 16. This requires HashTableSize
.bf4a	0a		asl a				asl 	a 						; in data.asm to be 8 (8 sets of links,2 bytes each)
.bf4b	0a		asl a				asl 	a
.bf4c	0a		asl a				asl 	a
.bf4d	8d 98 03	sta $0398			sta 	Var_HashAddress
.bf50	ad 96 03	lda $0396			lda 	Var_Hash 				; get the hash
.bf53	29 07		and #$07			and 	#(HashTableSize-1) 		; force into range 0-tableSize-1
.bf55	0a		asl a				asl 	a 						; double it (2 bytes per entry) & clears carry
.bf56	6d 98 03	adc $0398			adc 	Var_HashAddress 		; add table offset.
.bf59	69 35		adc #$35			adc 	#HashTableBase & $FF 	; now the low byte of the actual table address
.bf5b	8d 98 03	sta $0398			sta 	Var_HashAddress
.bf5e	a2 05		ldx #$05			ldx 	#5 						; hash is 5 bytes (real)
.bf60	ad 95 03	lda $0395			lda 	Var_Type
.bf63	c9 b9		cmp #$b9			cmp 	#token_Hash
.bf65	f0 07		beq $bf6e			beq 	_VEHaveSize
.bf67	ca		dex				dex
.bf68	c9 bb		cmp #$bb			cmp 	#token_Percent 			; percent is 4 bytes (integer)
.bf6a	f0 02		beq $bf6e			beq 	_VEHaveSize
.bf6c	a2 02		ldx #$02			ldx 	#2 						; everything else is two.
.bf6e					_VEHaveSize:
.bf6e	8e 99 03	stx $0399			stx 	Var_DataSize
.bf71	fa		plx				plx
.bf72	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varcreate.asm

.bf73					VariableCreate:
.bf73	da		phx				phx
.bf74	5a		phy				phy
.bf75	ad 02 03	lda $0302			lda 	VarMemPtr 					; get address of next free into zTemp1
.bf78	85 10		sta $10				sta 	zTemp1
.bf7a	ad 03 03	lda $0303			lda 	VarMemPtr+1
.bf7d	85 11		sta $11				sta 	zTemp1+1
.bf7f	ad 99 03	lda $0399			lda 	Var_DataSize 				; bytes for the data bit
.bf82	18		clc				clc
.bf83	6d 97 03	adc $0397			adc 	Var_Length 					; add the length of the name
.bf86	69 03		adc #$03			adc 	#3 							; 3 for the link and the hash.
.bf88	6d 02 03	adc $0302			adc 	VarMemPtr 					; add to variable memory pointer
.bf8b	8d 02 03	sta $0302			sta 	VarMemPtr
.bf8e	90 03		bcc $bf93			bcc 	_VCNoCarry
.bf90	ee 03 03	inc $0303			inc 	VarMemPtr+1
.bf93					_VCNoCarry:
.bf93	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.bf96	85 12		sta $12				sta 	zTemp2
.bf98	a9 03		lda #$03			lda 	#HashTableBase >> 8
.bf9a	85 13		sta $13				sta 	zTemp2+1
.bf9c	a0 00		ldy #$00			ldy 	#0 							; put current hash link in position.
.bf9e	b1 12		lda ($12),y			lda 	(zTemp2),y
.bfa0	91 10		sta ($10),y			sta 	(zTemp1),y
.bfa2	c8		iny				iny
.bfa3	b1 12		lda ($12),y			lda 	(zTemp2),y
.bfa5	91 10		sta ($10),y			sta 	(zTemp1),y
.bfa7	c8		iny				iny
.bfa8	ad 96 03	lda $0396			lda 	Var_Hash 					; write the hash out.
.bfab	91 10		sta ($10),y			sta 	(zTemp1),y
.bfad	c8		iny				iny
.bfae	a2 00		ldx #$00			ldx 	#0 							; copy the name out.
.bfb0					_VCCopyName:
.bfb0	bd 15 03	lda $0315,x			lda 	Var_Buffer,x
.bfb3	91 10		sta ($10),y			sta 	(zTemp1),y
.bfb5	e8		inx				inx
.bfb6	c8		iny				iny
.bfb7	ec 97 03	cpx $0397			cpx 	Var_Length
.bfba	d0 f4		bne $bfb0			bne 	_VCCopyName
.bfbc	5a		phy				phy 								; save the data offset.
.bfbd	ae 99 03	ldx $0399			ldx 	Var_DataSize 				; and write the data out.
.bfc0	a9 00		lda #$00			lda 	#0 							; which is all zeroes.
.bfc2					_VCClearData:
.bfc2	91 10		sta ($10),y			sta 	(zTemp1),y
.bfc4	c8		iny				iny
.bfc5	ca		dex				dex
.bfc6	d0 fa		bne $bfc2			bne 	_VCClearData
.bfc8	68		pla				pla 								; offset to the data
.bfc9	18		clc				clc
.bfca	65 10		adc $10				adc 	zTemp1 						; add to start and save as data pointer.
.bfcc	85 22		sta $22				sta 	zVarDataPtr
.bfce	a5 11		lda $11				lda 	zTemp1+1
.bfd0	69 00		adc #$00			adc 	#0
.bfd2	85 23		sta $23				sta 	zVarDataPtr+1
.bfd4	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.bfd7	85 24		sta $24				sta 	zVarType
.bfd9	a5 10		lda $10				lda 	zTemp1 						; fix hash link to point to new record
.bfdb	a0 00		ldy #$00			ldy 	#0
.bfdd	91 12		sta ($12),y			sta 	(zTemp2),y
.bfdf	c8		iny				iny
.bfe0	a5 11		lda $11				lda 	zTemp1+1
.bfe2	91 12		sta ($12),y			sta 	(zTemp2),y
.bfe4	ad 95 03	lda $0395			lda 	Var_Type 					; array ? if so create the empty one.
.bfe7	29 01		and #$01			and 	#1
.bfe9	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.bfeb	d0 0e		bne $bffb			bne 	_VCNotArray
.bfed	a2 00		ldx #$00			ldx 	#0 							; call recursive array creator
.bfef	20 95 c0	jsr $c095			jsr 	ArrayCreate
.bff2	5a		phy				phy 								; save YA at zVarDataPtr
.bff3	a0 00		ldy #$00			ldy 	#0
.bff5	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.bff7	c8		iny				iny
.bff8	68		pla				pla
.bff9	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.bffb					_VCNotArray:
.bffb	7a		ply				ply
.bffc	fa		plx				plx
.bffd	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arrayidx.asm

.bffe					ArrayIndexFollow:
.bffe	5a		phy				phy
.bfff	a0 00		ldy #$00			ldy 	#0 							; make zVarDataPtr point to the array.
.c001	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; e.g. it points to itself.
.c003	48		pha				pha
.c004	c8		iny				iny
.c005	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.c007	85 23		sta $23				sta 	zVarDataPtr+1
.c009	68		pla				pla
.c00a	85 22		sta $22				sta 	zVarDataPtr
.c00c	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; MSB of 16 bit integer and bytes 2&3
.c00e	29 80		and #$80			and 	#$80 						; must be zero.
.c010	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.c012	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.c014	d0 59		bne $c06f			bne 	_AIFError
.c016	a0 00		ldy #$00			ldy 	#0 							; calculate size - current - 1
.c018	18		clc				clc
.c019	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.c01b	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.c01d	c8		iny				iny
.c01e	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.c020	08		php				php 								; clear bit 7 retaining borrow.
.c021	29 7f		and #$7f			and 	#$7F
.c023	28		plp				plp
.c024	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.c026	90 47		bcc $c06f			bcc 	_AIFError 					; eror if size-current < 0
.c028	b5 80		lda $80,x			lda  	XS_Mantissa+0,x 			; copy and double the index
.c02a	0a		asl a				asl 	a 							; (e.g. index * 2)
.c02b	85 10		sta $10				sta 	zTemp1
.c02d	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c02f	2a		rol a				rol 	a
.c030	85 11		sta $11				sta 	zTemp1+1
.c032	a0 01		ldy #$01			ldy 	#1 							; is this a data entry.
.c034	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; if so, then type is unchanged, offset set
.c036	30 1d		bmi $c055			bmi 	_AIFCalculate
.c038	c6 24		dec $24				dec 	zVarType 					; converts from an array to a type.
.c03a	a5 24		lda $24				lda 	zVarType 					; check that type
.c03c	c9 b7		cmp #$b7			cmp 	#token_Dollar 				; if string, use x 2
.c03e	f0 15		beq $c055			beq 	_AIFCalculate
.c040	06 10		asl $10				asl 	zTemp1			 			; double the index
.c042	26 11		rol $11				rol 	zTemp1+1					; (e.g. index * 4)
.c044	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if integer, use x 4
.c046	f0 0d		beq $c055			beq 	_AIFCalculate
.c048	18		clc				clc 								; add the original mantissa in again
.c049	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; which makes it x5, for float.
.c04b	65 10		adc $10				adc 	zTemp1
.c04d	85 10		sta $10				sta 	zTemp1
.c04f	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c051	65 11		adc $11				adc 	zTemp1+1
.c053	85 11		sta $11				sta 	zTemp1+1
.c055					_AIFCalculate:
.c055	18		clc				clc 								; add index x 2,4 or 5 to base
.c056	a5 22		lda $22				lda 	zVarDataPtr
.c058	65 10		adc $10				adc 	zTemp1
.c05a	85 22		sta $22				sta 	zVarDataPtr
.c05c	a5 23		lda $23				lda 	zVarDataPtr+1
.c05e	65 11		adc $11				adc 	zTemp1+1
.c060	85 23		sta $23				sta 	zVarDataPtr+1
.c062	18		clc				clc 								; add 2 more for the length prefix.
.c063	a5 22		lda $22				lda 	zVarDataPtr
.c065	69 02		adc #$02			adc 	#2
.c067	85 22		sta $22				sta 	zVarDataPtr
.c069	90 02		bcc $c06d			bcc 	_AIFNoBump
.c06b	e6 23		inc $23				inc 	zVarDataPtr+1
.c06d					_AIFNoBump:
.c06d	7a		ply				ply
.c06e	60		rts				rts
.c06f					_AIFError:
.c06f	20 e7 ad	jsr $ade7			jsr ERR_Handler
>c072	42 61 64 20 61 72 72 61			.text "Bad array index",0
>c07a	79 20 69 6e 64 65 78 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arraydef.asm

.c082					ArrayResetDefault:
.c082	a9 0b		lda #$0b			lda 	#11 						; 0..10 one array
.c084	8d a8 03	sta $03a8			sta 	ArrayDef+0
.c087	a9 00		lda #$00			lda 	#0
.c089	8d a9 03	sta $03a9			sta 	ArrayDef+1
.c08c	a9 ff		lda #$ff			lda 	#$FF
.c08e	8d aa 03	sta $03aa			sta 	ArrayDef+2 					; $FFFF implies no second element.
.c091	8d ab 03	sta $03ab			sta 	ArrayDef+3					; (test bit 7 of 2nd byte)
.c094	60		rts				rts
.c095					ArrayCreate:
.c095	bd a8 03	lda $03a8,x			lda 	ArrayDef+0,x 				; put size x 2 in zTemp1
.c098	0a		asl a				asl 	a
.c099	85 10		sta $10				sta 	zTemp1
.c09b	bd a9 03	lda $03a9,x			lda 	ArrayDef+1,x
.c09e	2a		rol a				rol 	a
.c09f	85 11		sta $11				sta 	zTemp1+1
.c0a1	bd ab 03	lda $03ab,x			lda 	ArrayDef+3,x 				; if this is the last element it's array of ptrs.
.c0a4	10 22		bpl $c0c8			bpl 	_ACSized 					; if not multiply size x 2 (str) 4 (int) 5 (real)
.c0a6	ad 95 03	lda $0395			lda 	Var_Type 					; check the type
.c0a9	c9 b8		cmp #$b8			cmp 	#token_DollarLParen 		; also if it is an array of strings $(
.c0ab	f0 1b		beq $c0c8			beq 	_ACSized
.c0ad	06 10		asl $10				asl 	zTemp1 						; double again
.c0af	26 11		rol $11				rol 	zTemp1+1
.c0b1	b0 6f		bcs $c122			bcs 	ArrayIndexError 			; too large.
.c0b3	c9 bc		cmp #$bc			cmp 	#token_PercentLParen 		; if %( four bytes/entry is enough.
.c0b5	f0 11		beq $c0c8			beq 	_ACSized
.c0b7	18		clc				clc 								; add original value x 5 for reals.
.c0b8	a5 10		lda $10				lda 	zTemp1
.c0ba	7d a8 03	adc $03a8,x			adc 	ArrayDef+0,x
.c0bd	85 10		sta $10				sta 	zTemp1
.c0bf	a5 11		lda $11				lda 	zTemp1+1
.c0c1	7d a9 03	adc $03a9,x			adc 	ArrayDef+1,x
.c0c4	85 11		sta $11				sta 	zTemp1+1
.c0c6	b0 5a		bcs $c122			bcs 	ArrayIndexError
.c0c8					_ACSized:
.c0c8	18		clc				clc
.c0c9	a5 10		lda $10				lda 	zTemp1
.c0cb	69 02		adc #$02			adc 	#2
.c0cd	85 10		sta $10				sta 	zTemp1
.c0cf	90 04		bcc $c0d5			bcc 	_ACNoBump
.c0d1	e6 10		inc $10				inc 	zTemp1
.c0d3	f0 4d		beq $c122			beq 	ArrayIndexError
.c0d5					_ACNoBump:
.c0d5	18		clc				clc
.c0d6	ad 02 03	lda $0302			lda 	VarMemPtr 					; add this allocated count to VarMemPtr
.c0d9	85 12		sta $12				sta 	zTemp2						; save start in zTemp2/zTemp3
.c0db	85 14		sta $14				sta 	zTemp3
.c0dd	65 10		adc $10				adc 	zTemp1
.c0df	8d 02 03	sta $0302			sta 	VarMemPtr
.c0e2	ad 03 03	lda $0303			lda 	VarMemPtr+1
.c0e5	85 13		sta $13				sta 	zTemp2+1
.c0e7	85 15		sta $15				sta 	zTemp3+1
.c0e9	65 11		adc $11				adc 	zTemp1+1
.c0eb	8d 03 03	sta $0303			sta 	VarMemPtr+1
.c0ee	85 11		sta $11				sta 	zTemp1+1
.c0f0	b0 30		bcs $c122			bcs 	ArrayIndexError
.c0f2	a0 00		ldy #$00			ldy 	#0							; write $00 out.
.c0f4					_ACClear:
.c0f4	98		tya				tya
.c0f5	91 12		sta ($12),y			sta 	(zTemp2),y
.c0f7	e6 12		inc $12				inc 	zTemp2
.c0f9	d0 02		bne $c0fd			bne 	_ACCBump
.c0fb	e6 13		inc $13				inc 	zTemp2+1
.c0fd					_ACCBump:
.c0fd	a5 12		lda $12				lda 	zTemp2
.c0ff	cd 02 03	cmp $0302			cmp 	VarMemPtr
.c102	d0 f0		bne $c0f4			bne 	_ACClear
.c104	a5 13		lda $13				lda 	zTemp2+1
.c106	cd 03 03	cmp $0303			cmp 	VarMemPtr+1
.c109	d0 e9		bne $c0f4			bne 	_ACClear
.c10b	a0 00		ldy #$00			ldy 	#0
.c10d	bd a8 03	lda $03a8,x			lda 	ArrayDef+0,x 				; copy the size into the start
.c110	91 14		sta ($14),y			sta 	(zTemp3),y
.c112	c8		iny				iny
.c113	bd a9 03	lda $03a9,x			lda 	ArrayDef+1,x
.c116	91 14		sta ($14),y			sta 	(zTemp3),y
.c118	bd ab 03	lda $03ab,x			lda 	ArrayDef+3,x 				; have we reached the end
.c11b	10 18		bpl $c135			bpl 	ACCFillRecursive
.c11d	a4 15		ldy $15				ldy 	zTemp3+1 					; return address
.c11f	a5 14		lda $14				lda 	zTemp3
.c121	60		rts				rts
.c122					ArrayIndexError:
.c122	20 e7 ad	jsr $ade7			jsr ERR_Handler
>c125	42 61 64 20 61 72 72 61			.text "Bad array index",0
>c12d	79 20 69 6e 64 65 78 00
.c135					ACCFillRecursive:
.c135	a9 ff		lda #$ff			lda 	#$FF 						; we mark the end, this is free space.
.c137	a0 00		ldy #$00			ldy 	#0 							; this is overwritten by size of next allocated
.c139	91 12		sta ($12),y			sta 	(zTemp2),y 					; array, but we might change that.
.c13b	c8		iny				iny
.c13c	b1 14		lda ($14),y			lda 	(zTemp3),y 					; set bit 15 of the max index indicating
.c13e	09 80		ora #$80			ora 	#$80 						; an array of pointers
.c140	91 14		sta ($14),y			sta 	(zTemp3),y
.c142	a5 14		lda $14				lda 	zTemp3 						; push the start on the stack
.c144	48		pha				pha
.c145	a5 15		lda $15				lda 	zTemp3+1
.c147	48		pha				pha
.c148					_ACCFillLoop:
.c148	18		clc				clc
.c149	a5 14		lda $14				lda 	zTemp3 						; and work forwards.
.c14b	69 02		adc #$02			adc 	#2
.c14d	85 14		sta $14				sta 	zTemp3
.c14f	90 02		bcc $c153			bcc 	_ACCSkip2
.c151	e6 15		inc $15				inc 	zTemp3+1
.c153					_ACCSkip2:
.c153	a0 00		ldy #$00			ldy 	#0 							; reached the end ?
.c155	b1 14		lda ($14),y			lda 	(zTemp3),y					; (looking for FF marker, everything else 00)
.c157	c8		iny				iny
.c158	11 14		ora ($14),y			ora 	(zTemp3),y
.c15a	d0 21		bne $c17d			bne 	_ACCExit
.c15c	a5 14		lda $14				lda 	zTemp3 						; push zTemp3
.c15e	48		pha				pha
.c15f	a5 15		lda $15				lda 	zTemp3+1
.c161	48		pha				pha
.c162	e8		inx				inx
.c163	e8		inx				inx
.c164	20 95 c0	jsr $c095			jsr 	ArrayCreate 				; create array recursively.
.c167	ca		dex				dex
.c168	ca		dex				dex
.c169	85 12		sta $12				sta 	zTemp2 						; save A
.c16b	68		pla				pla
.c16c	85 15		sta $15				sta 	zTemp3+1 					; restore zTemp3
.c16e	68		pla				pla
.c16f	85 14		sta $14				sta 	zTemp3
.c171	98		tya				tya 								; write high bye from Y
.c172	a0 01		ldy #$01			ldy 	#1
.c174	91 14		sta ($14),y			sta 	(zTemp3),y
.c176	88		dey				dey 								; write low byte out.
.c177	a5 12		lda $12				lda 	zTemp2
.c179	91 14		sta ($14),y			sta 	(zTemp3),y
.c17b	80 cb		bra $c148			bra 	_ACCFillLoop 				; and try again.
.c17d					_ACCExit:
.c17d	7a		ply				ply 								; restore the original address
.c17e	68		pla				pla
.c17f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varfind.asm

.c180					VariableLocate:
.c180	da		phx				phx
.c181	5a		phy				phy
.c182	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.c185	85 12		sta $12				sta 	zTemp2 						; points to first address.
.c187	a9 03		lda #$03			lda 	#HashTableBase >> 8
.c189	85 13		sta $13				sta 	zTemp2+1
.c18b	a0 00		ldy #$00	_VLNext:ldy 	#0 							; get next link into AX
.c18d	b1 12		lda ($12),y			lda 	(zTemp2),y
.c18f	aa		tax				tax
.c190	c8		iny				iny
.c191	b1 12		lda ($12),y			lda 	(zTemp2),y
.c193	85 13		sta $13				sta 	zTemp2+1 					; save in zTemp
.c195	86 12		stx $12				stx 	zTemp2
.c197	05 12		ora $12				ora 	zTemp2 						; got zero
.c199	18		clc				clc
.c19a	f0 25		beq $c1c1			beq 	_VLExit 					; if so, then fail as end of chain.
.c19c	c8		iny				iny 								; point to hash (offset + 2)
.c19d	b1 12		lda ($12),y			lda 	(zTemp2),y
.c19f	cd 96 03	cmp $0396			cmp 	Var_Hash
.c1a2	d0 e7		bne $c18b			bne 	_VLNext 					; try next if different.
.c1a4					_VLCompare:
.c1a4	c8		iny				iny 								; next character
.c1a5	b1 12		lda ($12),y			lda 	(zTemp2),y 					; compare variable field against buffer.
.c1a7	d9 12 03	cmp $0312,y			cmp 	Var_Buffer-3,y 				; the -3 is because name starts at 3.
.c1aa	d0 df		bne $c18b			bne 	_VLNext 					; fail if different, try next.
.c1ac	0a		asl a				asl 	a 							; until end character (bit 7 set) matched
.c1ad	90 f5		bcc $c1a4			bcc 	_VLCompare
.c1af	98		tya				tya
.c1b0	38		sec				sec 								; add 1 as Y points to last character
.c1b1	65 12		adc $12				adc 	zTemp2 						; add to the current address
.c1b3	85 22		sta $22				sta 	zVarDataPtr
.c1b5	a5 13		lda $13				lda 	zTemp2+1
.c1b7	69 00		adc #$00			adc 	#0
.c1b9	85 23		sta $23				sta 	zVarDataPtr+1
.c1bb	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.c1be	85 24		sta $24				sta 	zVarType
.c1c0	38		sec				sec 								; return CS
.c1c1	7a		ply		_VLExit:ply
.c1c2	fa		plx				plx
.c1c3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/vargetset.asm

.c1c4					VariableGet:
.c1c4	5a		phy				phy
.c1c5	a0 00		ldy #$00			ldy 	#0 							; copy first two bytes
.c1c7	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.c1c9	95 80		sta $80,x			sta 	XS_Mantissa,x
.c1cb	c8		iny				iny
.c1cc	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.c1ce	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c1d0	c8		iny				iny
.c1d1	a5 24		lda $24				lda 	zVarType 					; if it is a string, set up for that.
.c1d3	c9 b7		cmp #$b7			cmp 	#token_Dollar
.c1d5	f0 2c		beq $c203			beq 	_VGString
.c1d7	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; copy the next two bytes.
.c1d9	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c1db	c8		iny				iny
.c1dc	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.c1de	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c1e0	c8		iny				iny
.c1e1	a9 01		lda #$01			lda 	#1 							; set type to 1.
.c1e3	95 85		sta $85,x			sta 	XS_Type,x
.c1e5	a5 24		lda $24				lda 	zVarType
.c1e7	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if it is a %, then exit with default integer.
.c1e9	f0 28		beq $c213			beq 	_VGExit
.c1eb	a9 40		lda #$40			lda 	#$40 						; set type byte to zero
.c1ed	95 85		sta $85,x			sta 	XS_Type,x 					; which is the code for zero/float.
.c1ef	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; the last value to copy is the exponent.
.c1f1	95 84		sta $84,x			sta 	XS_Exponent,x
.c1f3	f0 1e		beq $c213			beq 	_VGExit 					; if exponent is zero ... it's zero.
.c1f5	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; the sign bit is the top mantissa bit.
.c1f7	48		pha				pha
.c1f8	29 80		and #$80			and 	#$80
.c1fa	95 85		sta $85,x			sta 	XS_Type,x 					; this is the type byte.
.c1fc	68		pla				pla
.c1fd	09 80		ora #$80			ora 	#$80 						; set the MSB as you would expect.
.c1ff	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; so it's a normalised float.
.c201	80 10		bra $c213			bra 	_VGExit
.c203					_VGString:
.c203	a9 02		lda #$02			lda 	#2 							; set type to 2, a string
.c205	95 85		sta $85,x			sta 	XS_Type,x
.c207	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; is the value there $0000
.c209	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.c20b	d0 06		bne $c213			bne 	_VGExit 					; if not, exit.
.c20d	85 25		sta $25				sta 	zNullString 				; make zNullString a 00 string.
.c20f	a9 25		lda #$25			lda 	#zNullString
.c211	95 80		sta $80,x			sta 	XS_Mantissa,x 				; make it point to it.
.c213					_VGExit:
.c213	7a		ply				ply
.c214	60		rts				rts
.c215					VariableSet:
.c215	b5 85		lda $85,x			lda 	XS_Type,x 					; is the result a string
.c217	29 02		and #$02			and 	#2 							; if so, it has to be
.c219	d0 4b		bne $c266			bne 	_VSString
.c21b	a5 24		lda $24				lda 	zVarType 					; if type is $ there's an error.
.c21d	c9 b7		cmp #$b7			cmp 	#token_Dollar
.c21f	f0 42		beq $c263			beq 	_VSBadType
.c221	c9 bb		cmp #$bb			cmp 	#token_Percent 				; type convert to float/int
.c223	f0 05		beq $c22a			beq 	_VSMakeInt
.c225	20 4a c7	jsr $c74a			jsr 	FPUToFloat
.c228	80 03		bra $c22d			bra 	_VSCopy
.c22a					_VSMakeInt:
.c22a	20 96 c7	jsr $c796			jsr 	FPUToInteger
.c22d					_VSCopy:
.c22d	5a		phy				phy
.c22e	a0 00		ldy #$00			ldy 	#0 							; copy mantissa to target.
.c230	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.c232	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.c234	c8		iny				iny
.c235	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c237	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.c239	c8		iny				iny
.c23a	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c23c	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.c23e	c8		iny				iny
.c23f	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.c241	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.c243	a5 24		lda $24				lda 	zVarType 					; if target is integer, alrady done.
.c245	c9 bb		cmp #$bb			cmp 	#token_Percent
.c247	f0 18		beq $c261			beq 	_VSExit
.c249	b5 85		lda $85,x			lda 	XS_Type,x 					; get the sign bit into carry flag.
.c24b	0a		asl a				asl 	a
.c24c	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; shift the sign into the mantissa high.
.c24e	08		php				php
.c24f	0a		asl a				asl 	a
.c250	28		plp				plp
.c251	6a		ror a				ror 	a
.c252	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.c254	c8		iny				iny
.c255	b5 84		lda $84,x			lda 	XS_Exponent,x 				; copy the exponent in
.c257	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.c259	34 85		bit $85,x			bit 	XS_Type,x 					; if the result is non zero
.c25b	50 04		bvc $c261			bvc 	_VSExit
.c25d	a9 00		lda #$00			lda 	#00 						; zero exponent indicating 0.
.c25f	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.c261					_VSExit:
.c261	7a		ply				ply
.c262	60		rts				rts
.c263					_VSBadType:
.c263	4c c8 ad	jmp $adc8			jmp 	TypeError
.c266					_VSString:
.c266	a5 24		lda $24				lda 	zVarType 					; type must be $
.c268	c9 b7		cmp #$b7			cmp 	#token_Dollar
.c26a	d0 f7		bne $c263			bne 	_VSBadType
.c26c	da		phx				phx
.c26d	5a		phy				phy
.c26e	20 e6 bd	jsr $bde6			jsr 	StringConcrete 				; concrete the string in the mantissa -> AX
.c271	a0 01		ldy #$01			ldy 	#1 							; save high byte
.c273	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.c275	88		dey				dey 								; save low byte
.c276	8a		txa				txa
.c277	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.c279	7a		ply				ply 								; and exit.
.c27a	fa		plx				plx
.c27b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.c27c					MulInteger32:
.c27c	b5 80		lda $80,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.c27e	95 8c		sta $8c,x			sta 	XS3_Mantissa,x
.c280	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c282	95 8d		sta $8d,x			sta 	XS3_Mantissa+1,x
.c284	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c286	95 8e		sta $8e,x			sta 	XS3_Mantissa+2,x
.c288	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.c28a	95 8f		sta $8f,x			sta 	XS3_Mantissa+3,x
.c28c	a9 00		lda #$00			lda 	#0
.c28e	95 80		sta $80,x			sta 	XS_Mantissa+0,x 				; zero +0
.c290	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c292	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c294	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c296					_BFMMultiply:
.c296	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.c298	29 01		and #$01			and 	#1
.c29a	f0 03		beq $c29f			beq 	_BFMNoAdd
.c29c	20 42 b9	jsr $b942			jsr 	AddInteger32
.c29f					_BFMNoAdd:
.c29f	16 86		asl $86,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.c2a1	36 87		rol $87,x			rol 	XS2_Mantissa+1,x
.c2a3	36 88		rol $88,x			rol 	XS2_Mantissa+2,x
.c2a5	36 89		rol $89,x			rol 	XS2_Mantissa+3,x
.c2a7	56 8f		lsr $8f,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.c2a9	76 8e		ror $8e,x			ror 	XS3_Mantissa+2,x
.c2ab	76 8d		ror $8d,x			ror 	XS3_Mantissa+1,x
.c2ad	76 8c		ror $8c,x			ror 	XS3_Mantissa,x
.c2af	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.c2b1	15 8d		ora $8d,x			ora 	XS3_Mantissa+1,x
.c2b3	15 8e		ora $8e,x			ora 	XS3_Mantissa+2,x
.c2b5	15 8f		ora $8f,x			ora 	XS3_Mantissa+3,x
.c2b7	d0 dd		bne $c296			bne 	_BFMMultiply
.c2b9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.c2ba					DivInteger32:
.c2ba	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; check for /0
.c2bc	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.c2be	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.c2c0	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.c2c2	d0 14		bne $c2d8			bne 	_BFDOkay
.c2c4	20 e7 ad	jsr $ade7			jsr ERR_Handler
>c2c7	44 69 76 69 73 69 6f 6e			.text "Division by Zero",0
>c2cf	20 62 79 20 5a 65 72 6f 00
.c2d8					_BFDOkay:
.c2d8	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.c2da	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.c2dc	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.c2de	85 1c		sta $1c				sta 	zLTemp1+2
.c2e0	85 1d		sta $1d				sta 	zLTemp1+3
.c2e2	8d 9e 03	sta $039e			sta 	SignCount 					; Count of signs.
.c2e5	20 3c c3	jsr $c33c			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.c2e8	da		phx				phx
.c2e9	e8		inx				inx
.c2ea	e8		inx				inx
.c2eb	e8		inx				inx
.c2ec	e8		inx				inx
.c2ed	e8		inx				inx
.c2ee	e8		inx				inx
.c2ef	20 3c c3	jsr $c33c			jsr 	CheckIntegerNegate
.c2f2	fa		plx				plx
.c2f3	5a		phy				phy 								; Y is the counter
.c2f4	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.c2f6					_BFDLoop:
.c2f6	16 80		asl $80,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.c2f8	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.c2fa	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.c2fc	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.c2fe	26 1a		rol $1a				rol 	zLTemp1
.c300	26 1b		rol $1b				rol 	zLTemp1+1
.c302	26 1c		rol $1c				rol 	zLTemp1+2
.c304	26 1d		rol $1d				rol 	zLTemp1+3
.c306	38		sec				sec
.c307	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.c309	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.c30b	48		pha				pha
.c30c	a5 1b		lda $1b				lda 	zLTemp1+1
.c30e	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.c310	48		pha				pha
.c311	a5 1c		lda $1c				lda 	zLTemp1+2
.c313	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.c315	48		pha				pha
.c316	a5 1d		lda $1d				lda 	zLTemp1+3
.c318	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.c31a	90 13		bcc $c32f			bcc 	_BFDNoAdd
.c31c	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.c31e	68		pla				pla
.c31f	85 1c		sta $1c				sta 	zLTemp1+2
.c321	68		pla				pla
.c322	85 1b		sta $1b				sta 	zLTemp1+1
.c324	68		pla				pla
.c325	85 1a		sta $1a				sta 	zLTemp1+0
.c327	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.c329	09 01		ora #$01			ora 	#1
.c32b	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c32d	80 03		bra $c332			bra 	_BFDNext
.c32f					_BFDNoAdd:
.c32f	68		pla				pla 								; Throw away the intermediate calculations
.c330	68		pla				pla
.c331	68		pla				pla
.c332					_BFDNext:
.c332	88		dey				dey
.c333	d0 c1		bne $c2f6			bne 	_BFDLoop
.c335	7a		ply				ply 								; restore Y and exit
.c336	4e 9e 03	lsr $039e			lsr 	SignCount 					; if sign count odd,
.c339	b0 06		bcs $c341			bcs		IntegerNegateAlways 			; negate the result
.c33b	60		rts				rts
.c33c					CheckIntegerNegate:
.c33c	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.c33e	30 01		bmi $c341			bmi 	IntegerNegateAlways
.c340	60		rts				rts
.c341					IntegerNegateAlways:
.c341	ee 9e 03	inc $039e			inc 	SignCount
.c344	38		sec				sec
.c345	a9 00		lda #$00			lda 	#0
.c347	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.c349	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c34b	a9 00		lda #$00			lda 	#0
.c34d	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.c34f	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c351	a9 00		lda #$00			lda 	#0
.c353	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.c355	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c357	a9 00		lda #$00			lda 	#0
.c359	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.c35b	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c35d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.c35e					INTToString:
.c35e	48		pha				pha
.c35f	5a		phy				phy
.c360	b5 83		lda $83,x			lda 		XS_Mantissa+3,x 		; check -ve
.c362	10 08		bpl $c36c			bpl 		_ITSNotMinus
.c364	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.c366	20 fc c3	jsr $c3fc			jsr 		ITSOutputCharacter
.c369	20 41 c3	jsr $c341			jsr 		IntegerNegateAlways 	; negate the number.
.c36c					_ITSNotMinus:
.c36c	a9 00		lda #$00			lda 		#0
.c36e	8d 9a 03	sta $039a			sta 		NumSuppress 			; clear the suppression flag.
.c371	8a		txa				txa 								; use Y for the mantissa index.
.c372	a8		tay				tay
.c373	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.c375					_ITSNextSubtractor:
.c375	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.c377	8d 9b 03	sta $039b			sta 		NumConvCount
.c37a					_ITSSubtract:
.c37a	38		sec				sec
.c37b	b9 80 00	lda $0080,y			lda 		XS_Mantissa,y 			; subtract number and push on stack
.c37e	fd d8 c3	sbc $c3d8,x			sbc 		_ITSSubtractors+0,x
.c381	48		pha				pha
.c382	b9 81 00	lda $0081,y			lda 		XS_Mantissa+1,y
.c385	fd d9 c3	sbc $c3d9,x			sbc 		_ITSSubtractors+1,x
.c388	48		pha				pha
.c389	b9 82 00	lda $0082,y			lda 		XS_Mantissa+2,y
.c38c	fd da c3	sbc $c3da,x			sbc 		_ITSSubtractors+2,x
.c38f	48		pha				pha
.c390	b9 83 00	lda $0083,y			lda 		XS_Mantissa+3,y
.c393	fd db c3	sbc $c3db,x			sbc 		_ITSSubtractors+3,x
.c396	90 14		bcc $c3ac			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.c398	99 83 00	sta $0083,y			sta 		XS_Mantissa+3,y 		; save subtract off stack
.c39b	68		pla				pla
.c39c	99 82 00	sta $0082,y			sta 		XS_Mantissa+2,y
.c39f	68		pla				pla
.c3a0	99 81 00	sta $0081,y			sta 		XS_Mantissa+1,y
.c3a3	68		pla				pla
.c3a4	99 80 00	sta $0080,y			sta 		XS_Mantissa+0,y
.c3a7	ee 9b 03	inc $039b			inc 		NumConvCount 			; bump count.
.c3aa	80 ce		bra $c37a			bra 		_ITSSubtract 			; go round again.
.c3ac					_ITSCantSubtract:
.c3ac	68		pla				pla 								; throw away interim answers
.c3ad	68		pla				pla
.c3ae	68		pla				pla
.c3af	ad 9b 03	lda $039b			lda 		NumConvCount 			; if not zero then no suppression check
.c3b2	c9 30		cmp #$30			cmp 		#"0"
.c3b4	d0 05		bne $c3bb			bne 		_ITSOutputDigit
.c3b6	ad 9a 03	lda $039a			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.c3b9	10 09		bpl $c3c4			bpl	 		_ITSGoNextSubtractor
.c3bb					_ITSOutputDigit:
.c3bb	ce 9a 03	dec $039a			dec 		NumSuppress 			; suppression check will be non-zero.
.c3be	ad 9b 03	lda $039b			lda 		NumConvCount 			; count of subtractions
.c3c1	20 fc c3	jsr $c3fc			jsr 		ITSOutputCharacter 		; output it.
.c3c4					_ITSGoNextSubtractor:
.c3c4	e8		inx				inx 								; next dword
.c3c5	e8		inx				inx
.c3c6	e8		inx				inx
.c3c7	e8		inx				inx
.c3c8	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.c3ca	d0 a9		bne $c375			bne 		_ITSNextSubtractor 		; do all the subtractors.
.c3cc	98		tya				tya 								; X is back as the mantissa index
.c3cd	aa		tax				tax
.c3ce	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.c3d0	09 30		ora #$30			ora 		#"0"
.c3d2	20 fc c3	jsr $c3fc			jsr 		ITSOutputCharacter
.c3d5	7a		ply				ply 								; and exit
.c3d6	68		pla				pla
.c3d7	60		rts				rts
.c3d8					_ITSSubtractors:
>c3d8	00 ca 9a 3b					.dword 		1000000000
>c3dc	00 e1 f5 05					.dword 		100000000
>c3e0	80 96 98 00					.dword 		10000000
>c3e4	40 42 0f 00					.dword 		1000000
>c3e8	a0 86 01 00					.dword 		100000
>c3ec	10 27 00 00					.dword 		10000
>c3f0	e8 03 00 00					.dword 		1000
>c3f4	64 00 00 00					.dword 		100
>c3f8	0a 00 00 00					.dword 		10
.c3fc					_ITSSubtractorsEnd:
.c3fc					ITSOutputCharacter:
.c3fc	48		pha				pha
.c3fd	da		phx				phx
.c3fe	ae 14 03	ldx $0314			ldx 	NumBufX 					; save digit
.c401	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.c404	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.c406	9d 16 03	sta $0316,x			sta 	Num_Buffer+1,x
.c409	ee 14 03	inc $0314			inc 	NumBufX						; bump pointer.
.c40c	fa		plx				plx
.c40d	68		pla				pla
.c40e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.c40f					IntFromString:
.c40f	a0 00		ldy #$00			ldy 	#0
.c411	8c 9c 03	sty $039c			sty 	ExpTemp 					; this is the converted digit count.
.c414					IntFromStringY:
.c414	48		pha				pha
.c415	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.c417	95 80		sta $80,x			sta 	XS_Mantissa,x
.c419	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c41b	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c41d	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c41f	a9 01		lda #$01			lda 	#1
.c421	95 85		sta $85,x			sta 	XS_Type,x
.c423					_IFSLoop:
.c423	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.c425	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.c427	90 4e		bcc $c477			bcc 	_IFSExit
.c429	c9 3a		cmp #$3a			cmp 	#"9"+1
.c42b	b0 4a		bcs $c477			bcs 	_IFSExit
.c42d	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.c42f	c9 0c		cmp #$0c			cmp 	#12
.c431	b0 4e		bcs $c481			bcs 	_IFSOverflow
.c433	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.c435	48		pha				pha
.c436	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c438	48		pha				pha
.c439	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c43b	48		pha				pha
.c43c	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.c43e	48		pha				pha
.c43f	20 96 c4	jsr $c496			jsr 	IFSX1ShiftLeft 				; double
.c442	20 96 c4	jsr $c496			jsr 	IFSX1ShiftLeft 				; x 4
.c445	18		clc				clc 								; add saved value x 5
.c446	68		pla				pla
.c447	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.c449	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c44b	68		pla				pla
.c44c	75 81		adc $81,x			adc 	XS_Mantissa+1,x
.c44e	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c450	68		pla				pla
.c451	75 82		adc $82,x			adc 	XS_Mantissa+2,x
.c453	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c455	68		pla				pla
.c456	75 83		adc $83,x			adc 	XS_Mantissa+3,x
.c458	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c45a	20 96 c4	jsr $c496			jsr 	IFSX1ShiftLeft 				; x 10
.c45d	ee 9c 03	inc $039c			inc 	ExpTemp 					; bump count of digits processed.
.c460	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.c462	29 0f		and #$0f			and 	#15
.c464	c8		iny				iny
.c465	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.c467	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c469	90 b8		bcc $c423			bcc 	_IFSLoop
.c46b	f6 81		inc $81,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.c46d	d0 b4		bne $c423			bne 	_IFSLoop
.c46f	f6 82		inc $82,x			inc 	XS_Mantissa+2,x
.c471	d0 b0		bne $c423			bne 	_IFSLoop
.c473	f6 83		inc $83,x			inc 	XS_Mantissa+3,x
.c475	80 ac		bra $c423			bra 	_IFSLoop
.c477					_IFSExit:
.c477	98		tya				tya 								; get offset
.c478					_IFSOkay:
.c478	38		sec				sec
.c479	ad 9c 03	lda $039c			lda 	ExpTemp
.c47c	f0 01		beq $c47f			beq 	_IFSSkipFail
.c47e	18		clc				clc
.c47f					_IFSSkipFail:
.c47f	68		pla				pla 								; and exit.
.c480	60		rts				rts
.c481					_IFSOverflow:
.c481	20 e7 ad	jsr $ade7			jsr 	ERR_Handler
>c484	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>c48c	20 6f 76 65 72 66 6c 6f 77 00
.c496					IFSX1ShiftLeft:
.c496	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.c498	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.c49a	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.c49c	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.c49e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.c49f					FPSubtract:
.c49f	48		pha				pha
.c4a0	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.c4a2	49 80		eor #$80			eor 	#$80
.c4a4	95 8b		sta $8b,x			sta 	XS2_Type,x
.c4a6	68		pla				pla 								; --- and fall through ---
.c4a7					FPAdd:
.c4a7	48		pha				pha
.c4a8	b5 85		lda $85,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.c4aa	d0 05		bne $c4b1			bne 	_FPA_NegativeLHS
.c4ac	20 c8 c4	jsr $c4c8			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.c4af	68		pla				pla
.c4b0	60		rts				rts
.c4b1					_FPA_NegativeLHS:
.c4b1	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.c4b3	49 80		eor #$80			eor 	#$80
.c4b5	95 85		sta $85,x			sta 	XS_Type,x
.c4b7	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of B and add
.c4b9	49 80		eor #$80			eor 	#$80
.c4bb	95 8b		sta $8b,x			sta 	XS2_Type,x
.c4bd	20 c8 c4	jsr $c4c8			jsr 	FPAdd_Worker 				; do the add calculation.
.c4c0	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 back
.c4c2	49 80		eor #$80			eor 	#$80
.c4c4	95 85		sta $85,x			sta 	XS_Type,x
.c4c6	68		pla				pla
.c4c7	60		rts				rts
.c4c8					FPAdd_Worker:
.c4c8	34 8b		bit $8b,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.c4ca	70 07		bvs $c4d3			bvs 	_FPAWExit 					; no change.
.c4cc	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.c4ce	50 07		bvc $c4d7			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.c4d0	20 08 c7	jsr $c708			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.c4d3					_FPAWExit:
.c4d3	20 77 c7	jsr $c777			jsr 	FPUNormalise 				; normalise the result.
.c4d6	60		rts				rts
.c4d7					_FPAWMakeSame:
.c4d7	b5 84		lda $84,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.c4d9	38		sec				sec
.c4da	f5 8a		sbc $8a,x			sbc	 	XS2_Exponent,x 				; using subtraction
.c4dc	f0 16		beq $c4f4			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.c4de	da		phx				phx 								; save X
.c4df	90 06		bcc $c4e7			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.c4e1	e8		inx				inx
.c4e2	e8		inx				inx
.c4e3	e8		inx				inx
.c4e4	e8		inx				inx
.c4e5	e8		inx				inx
.c4e6	e8		inx				inx
.c4e7					_FPAWShiftA:
.c4e7	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.c4e9	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.c4eb	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.c4ed	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.c4ef	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.c4f1	fa		plx				plx 								; restore original X
.c4f2	80 e3		bra $c4d7			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.c4f4					_FPAW_DoArithmetic:
.c4f4	34 8b		bit $8b,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.c4f6	30 28		bmi $c520			bmi 	_FPAW_BNegative
.c4f8	18		clc				clc
.c4f9	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.c4fb	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.c4fd	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c4ff	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c501	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.c503	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c505	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c507	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.c509	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c50b	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.c50d	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.c50f	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c511	90 c0		bcc $c4d3			bcc 	_FPAWExit 					; no carry.
.c513	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.c515	38		sec				sec
.c516	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.c518	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.c51a	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.c51c	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.c51e	80 b3		bra $c4d3			bra 	_FPAWExit
.c520					_FPAW_BNegative:
.c520	38		sec				sec
.c521	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.c523	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.c525	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c527	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c529	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.c52b	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c52d	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c52f	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.c531	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c533	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.c535	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.c537	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c539	b0 09		bcs $c544			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.c53b	20 2e c7	jsr $c72e			jsr 	FPUNegateInteger			; negate the mantissa
.c53e	b5 85		lda $85,x			lda 	XS_Type,x 					; flip result sign
.c540	49 80		eor #$80			eor 	#$80
.c542	95 85		sta $85,x			sta 	XS_Type,x
.c544					_FPAWGoExit:
.c544	4c d3 c4	jmp $c4d3			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.c547					FPD_IsDivZero:
.c547	20 e7 ad	jsr $ade7			jsr ERR_Handler
>c54a	44 69 76 69 73 69 6f 6e			.text "Division by zero",0
>c552	20 62 79 20 7a 65 72 6f 00
.c55b					FPDivide:
.c55b	48		pha				pha
.c55c	5a		phy				phy
.c55d	34 8b		bit $8b,x			bit 	XS2_Type,x 					; check if division by zero
.c55f	70 e6		bvs $c547			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.c561	34 85		bit $85,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.c563	f0 03		beq $c568			beq 	_FPDCalculateExp
.c565					_FPD_Exit:
.c565	7a		ply				ply
.c566	68		pla				pla
.c567	60		rts				rts
.c568					_FPDCalculateExp:
.c568	b5 8a		lda $8a,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.c56a	49 ff		eor #$ff			eor 	#$FF
.c56c	1a		inc a				inc 	a
.c56d	95 8a		sta $8a,x			sta 	XS2_Exponent,x
.c56f	20 3f c6	jsr $c63f			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.c572	18		clc				clc 	 							; add 1 to the resulting exponent
.c573	69 01		adc #$01			adc 	#1
.c575	b0 54		bcs $c5cb			bcs 	_FPD_Overflow 				; which can overflow.
.c577	95 84		sta $84,x			sta 	XS_Exponent,x
.c579	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.c57b	85 1a		sta $1a				sta 	zLTemp1+0
.c57d	85 1b		sta $1b				sta 	zLTemp1+1
.c57f	85 1c		sta $1c				sta 	zLTemp1+2
.c581	85 1d		sta $1d				sta 	zLTemp1+3
.c583	a0 20		ldy #$20			ldy 	#32 						; times round.
.c585					_FPD_Loop:
.c585	38		sec				sec 								; calculate X1-X2 stacking result because we might
.c586	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; not save it.
.c588	f5 86		sbc $86,x			sbc 	XS2_Mantissa,x
.c58a	48		pha				pha
.c58b	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c58d	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.c58f	48		pha				pha
.c590	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c592	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.c594	48		pha				pha
.c595	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.c597	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.c599	90 13		bcc $c5ae			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.c59b	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; save results out to A
.c59d	68		pla				pla
.c59e	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c5a0	68		pla				pla
.c5a1	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c5a3	68		pla				pla
.c5a4	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c5a6	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.c5a8	09 80		ora #$80			ora 	#$80
.c5aa	85 1d		sta $1d				sta 	zLTemp1+3
.c5ac	80 03		bra $c5b1			bra 	_FPD_Rotates
.c5ae					_FPD_NoSubtract:
.c5ae	68		pla				pla 								; throw away unwanted results
.c5af	68		pla				pla
.c5b0	68		pla				pla
.c5b1					_FPD_Rotates:
.c5b1	56 89		lsr $89,x			lsr 	3+XS2_Mantissa,x
.c5b3	76 88		ror $88,x			ror 	2+XS2_Mantissa,x
.c5b5	76 87		ror $87,x			ror 	1+XS2_Mantissa,x
.c5b7	76 86		ror $86,x			ror 	0+XS2_Mantissa,x
.c5b9	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.c5bb	26 1b		rol $1b				rol 	zLTemp1+1
.c5bd	26 1c		rol $1c				rol 	zLTemp1+2
.c5bf	26 1d		rol $1d				rol 	zLTemp1+3
.c5c1	90 02		bcc $c5c5			bcc 	_FPD_NoCarry
.c5c3	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.c5c5					_FPD_NoCarry:
.c5c5	88		dey				dey 								; do 32 times
.c5c6	d0 bd		bne $c585			bne 	_FPD_Loop
.c5c8	4c 23 c6	jmp $c623			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.c5cb					_FPD_Overflow:
.c5cb	4c d4 c7	jmp $c7d4			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.c5ce					FPMultiply:
.c5ce	48		pha				pha
.c5cf	5a		phy				phy
.c5d0	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.c5d2	70 07		bvs $c5db			bvs 	_FPM_Exit
.c5d4	34 8b		bit $8b,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.c5d6	50 06		bvc $c5de			bvc 	_FPM_CalcExponent
.c5d8	20 08 c7	jsr $c708			jsr 	FPUCopyX2ToX1
.c5db					_FPM_Exit:
.c5db	7a		ply				ply
.c5dc	68		pla				pla
.c5dd	60		rts				rts
.c5de					_FPM_CalcExponent:
.c5de	18		clc				clc
.c5df	20 3f c6	jsr $c63f			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.c5e2	95 84		sta $84,x			sta 	XS_Exponent,x 				; save the result.
.c5e4	a9 00		lda #$00			lda 	#0
.c5e6	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.c5e8	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.c5ea	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.c5ec	85 1d		sta $1d				sta 	zLTemp1+3
.c5ee	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.c5f0					_FPM_Loop:
.c5f0	b5 80		lda $80,x			lda 	XS_Mantissa,x				; check LSB of long product
.c5f2	29 01		and #$01			and 	#1
.c5f4	18		clc				clc 								; clear carry for the long rotate.
.c5f5	f0 19		beq $c610			beq 	_FPM_NoAddition
.c5f7	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.c5f8	a5 1a		lda $1a				lda 	zLTemp1+0
.c5fa	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.c5fc	85 1a		sta $1a				sta 	zLTemp1+0
.c5fe	a5 1b		lda $1b				lda 	zLTemp1+1
.c600	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.c602	85 1b		sta $1b				sta 	zLTemp1+1
.c604	a5 1c		lda $1c				lda 	zLTemp1+2
.c606	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.c608	85 1c		sta $1c				sta 	zLTemp1+2
.c60a	a5 1d		lda $1d				lda 	zLTemp1+3
.c60c	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.c60e	85 1d		sta $1d				sta 	zLTemp1+3
.c610					_FPM_NoAddition:
.c610	66 1d		ror $1d				ror 	3+zLTemp1
.c612	66 1c		ror $1c				ror 	2+zLTemp1
.c614	66 1b		ror $1b				ror 	1+zLTemp1
.c616	66 1a		ror $1a				ror 	0+zLTemp1
.c618	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.c61a	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.c61c	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.c61e	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.c620	88		dey				dey
.c621	d0 cd		bne $c5f0			bne 	_FPM_Loop 					; do this 32 times.
.c623					FPM_CopySignNormalize:
.c623	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.c625	95 80		sta $80,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.c627	a5 1b		lda $1b				lda 	zLTemp1+1
.c629	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c62b	a5 1c		lda $1c				lda 	zLTemp1+2
.c62d	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c62f	a5 1d		lda $1d				lda 	zLTemp1+3
.c631	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c633	b5 85		lda $85,x			lda 	XS_Type,x 					; sign is xor of signs
.c635	55 8b		eor $8b,x			eor 	XS2_Type,x
.c637	95 85		sta $85,x			sta 	XS_Type,x
.c639	20 77 c7	jsr $c777			jsr 	FPUNormalise 				; normalise and exit.
.c63c	7a		ply				ply
.c63d	68		pla				pla
.c63e	60		rts				rts
.c63f					FPCalculateExponent:
.c63f	18		clc				clc
.c640	b5 84		lda $84,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.c642	75 8a		adc $8a,x			adc 	XS2_Exponent,x
.c644	b0 08		bcs $c64e			bcs 	_FPCECarry 					; carry out ?
.c646	10 03		bpl $c64b			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.c648	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.c64a	60		rts				rts
.c64b					_FPCEExpZero:
.c64b	a9 00		lda #$00			lda 	#0
.c64d	60		rts				rts
.c64e					_FPCECarry:
.c64e	30 03		bmi $c653			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.c650	09 80		ora #$80			ora 	#$80 						; put in right range
.c652	60		rts				rts
.c653					_FPCEOverflow:
.c653	4c d4 c7	jmp $c7d4			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.c656					FPFractionalPart:
.c656	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.c658	38		sec				sec 								; this flag tells us to keep the fractional part
.c659	30 0d		bmi $c668			bmi 	FPGetPart
.c65b	60		rts				rts
.c65c					FPIntegerPart:
.c65c	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.c65e	18		clc				clc 								; this flag says keep the integer part.
.c65f	30 07		bmi $c668			bmi 	FPGetPart 					; -ve exponents are 0..127
.c661	48		pha				pha
.c662	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.c664	95 85		sta $85,x			sta 	XS_Type,x
.c666	68		pla				pla
.c667	60		rts				rts
.c668					FPGetPart:
.c668	48		pha				pha
.c669	5a		phy				phy 								; save Y
.c66a	08		php				php 								; save action
.c66b	34 85		bit $85,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.c66d	70 59		bvs $c6c8			bvs 	_FPGP_Exit 					; then do nothing.
.c66f	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.c671	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.c673	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.c675	85 1c		sta $1c				sta 	zLTemp1+2
.c677	85 1d		sta $1d				sta 	zLTemp1+3
.c679	b5 84		lda $84,x			lda 	XS_Exponent,x				; the number of shifts.
.c67b	38		sec				sec
.c67c	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.c67e	f0 12		beq $c692			beq 	_FPGP_NoShift 				; ... if any
.c680	c9 20		cmp #$20			cmp 	#32
.c682	90 02		bcc $c686			bcc 	_FPGP_NotMax
.c684	a9 20		lda #$20			lda 	#32 						; max of 32.
.c686					_FPGP_NotMax:
.c686	a8		tay				tay 								; Y is the mask shift count.
.c687					_FPGP_ShiftMask:
.c687	46 1d		lsr $1d				lsr 	3+zLTemp1
.c689	66 1c		ror $1c				ror 	2+zLTemp1
.c68b	66 1b		ror $1b				ror 	1+zLTemp1
.c68d	66 1a		ror $1a				ror 	0+zLTemp1
.c68f	88		dey				dey
.c690	d0 f5		bne $c687			bne 	_FPGP_ShiftMask
.c692					_FPGP_NoShift:
.c692	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.c694	8e 9c 03	stx $039c			stx 	ExpTemp						; save X
.c697					_FPGP_MaskLoop:
.c697	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.c69a	28		plp				plp 								; if CC we keep the top part, so we
.c69b	08		php				php		 							; flip the mask.
.c69c	b0 02		bcs $c6a0			bcs		_FPGP_NoFlip
.c69e	49 ff		eor #$ff			eor 	#$FF
.c6a0					_FPGP_NoFlip:
.c6a0	35 80		and $80,x			and 	XS_Mantissa,x 				; and into the mantissa.
.c6a2	95 80		sta $80,x			sta 	XS_Mantissa,x
.c6a4	e8		inx				inx
.c6a5	c8		iny				iny
.c6a6	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.c6a8	d0 ed		bne $c697			bne 	_FPGP_MaskLoop
.c6aa	ae 9c 03	ldx $039c			ldx 	ExpTemp						; restore X
.c6ad	28		plp				plp
.c6ae	08		php				php 								; get action flag on the stack
.c6af	90 04		bcc $c6b5			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.c6b1	a9 00		lda #$00			lda 	#0
.c6b3	95 85		sta $85,x			sta 	XS_Type,x
.c6b5					_FPGP_NotFractional:
.c6b5	b5 80		lda $80,x			lda 	XS_Mantissa,x 						; check if \1 zero
.c6b7	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.c6b9	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.c6bb	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.c6bd	f0 05		beq $c6c4			beq 	_FPGP_Zero 					; if zero, return zero
.c6bf	20 77 c7	jsr $c777			jsr 	FPUNormalise
.c6c2	80 04		bra $c6c8			bra 	_FPGP_Exit 					; and exit
.c6c4					_FPGP_Zero:
.c6c4	a9 40		lda #$40			lda 	#$40 						; set zero flag
.c6c6	95 85		sta $85,x			sta 	XS_Type,x
.c6c8					_FPGP_Exit:
.c6c8	68		pla				pla 								; throw saved action flag.
.c6c9	7a		ply				ply
.c6ca	68		pla				pla
.c6cb	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.c6cc					FPCompare:
.c6cc	b5 84		lda $84,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.c6ce	48		pha				pha
.c6cf	b5 8a		lda $8a,x			lda 	XS2_Exponent,x
.c6d1	48		pha				pha
.c6d2	20 9f c4	jsr $c49f			jsr 	FPSubtract 					; calculate X1-X2
.c6d5	34 85		bit $85,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.c6d7	70 2a		bvs $c703			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.c6d9	68		pla				pla
.c6da	8d 9c 03	sta $039c			sta 	ExpTemp						; save first exponent in temporary reg.
.c6dd	68		pla				pla
.c6de	38		sec				sec
.c6df	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; calculate AX-BX
.c6e2	70 14		bvs $c6f8			bvs 	_FPCNotEqual				; overflow, can't be equal.
.c6e4	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.c6e5	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.c6e7	b0 0f		bcs $c6f8			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.c6e9	38		sec				sec
.c6ea	ad 9c 03	lda $039c			lda 	ExpTemp 					; get one of the exponents back.
.c6ed	e9 12		sbc #$12			sbc 	#18 						; allow for 2^18 error, relatively.
.c6ef	b0 02		bcs $c6f3			bcs 	_FPCNotRange 				; keep in range.
.c6f1	a9 01		lda #$01			lda 	#1
.c6f3					_FPCNotRange:
.c6f3	38		sec				sec
.c6f4	f5 84		sbc $84,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.c6f6	b0 0d		bcs $c705			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.c6f8					_FPCNotEqual:
.c6f8	b5 85		lda $85,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.c6fa	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.c6fc	f0 02		beq $c700			beq 	_FPCNE2
.c6fe	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.c700	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.c701	80 04		bra $c707			bra 	_FPCExit
.c703					_FPCPullZero:
.c703	68		pla				pla 								; throw saved exponents
.c704	68		pla				pla
.c705					_FPCZero:
.c705	a9 00		lda #$00			lda 	#0 							; and return zero
.c707					_FPCExit:
.c707	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.c708					FPUCopyX2ToX1:
.c708	48		pha				pha
.c709	da		phx				phx
.c70a	5a		phy				phy
.c70b	a0 08		ldy #$08			ldy 	#8
.c70d	b5 86		lda $86,x	_FPUC21:lda 	XS2_Mantissa,x
.c70f	95 80		sta $80,x			sta 	XS_Mantissa,x
.c711	e8		inx				inx
.c712	88		dey				dey
.c713	10 f8		bpl $c70d			bpl 	_FPUC21
.c715	7a		ply				ply
.c716	fa		plx				plx
.c717	68		pla				pla
.c718	60		rts				rts
.c719					FPUSetInteger:
.c719	48		pha				pha
.c71a	95 80		sta $80,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.c71c	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.c71e	10 02		bpl $c722			bpl 	_FPUSIExtend
.c720	a9 ff		lda #$ff			lda 	#$FF
.c722					_FPUSIExtend:
.c722	95 81		sta $81,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.c724	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c726	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c728	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.c72a	95 85		sta $85,x			sta 	XS_Type,x
.c72c	68		pla				pla
.c72d	60		rts				rts
.c72e					FPUNegateInteger:
.c72e	48		pha				pha
.c72f	38		sec				sec
.c730	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.c732	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.c734	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c736	a9 00		lda #$00			lda 	#0
.c738	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.c73a	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c73c	a9 00		lda #$00			lda 	#0
.c73e	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.c740	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c742	a9 00		lda #$00			lda 	#0
.c744	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.c746	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c748	68		pla				pla
.c749	60		rts				rts
.c74a					FPUToFloat:
.c74a	48		pha				pha
.c74b	b5 85		lda $85,x			lda 	XS_Type,x					; exit if already float.
.c74d	29 0f		and #$0f			and 	#$0F
.c74f	f0 24		beq $c775			beq 	_FPUFExit
.c751	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.c753	95 85		sta $85,x			sta 	XS_Type,x
.c755	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.c757	95 84		sta $84,x			sta 	XS_Exponent,x 				; x mantissa.
.c759	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.c75b	10 07		bpl $c764			bpl		_FPUFPositive
.c75d	20 2e c7	jsr $c72e			jsr 	FPUNegateInteger 			; negate the mantissa
.c760	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.c762	95 85		sta $85,x			sta 	XS_Type,x
.c764					_FPUFPositive:
.c764	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.c766	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.c768	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.c76a	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.c76c	d0 04		bne $c772			bne 	_FPUFNonZero
.c76e	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.c770	95 85		sta $85,x			sta 	XS_Type,x
.c772					_FPUFNonZero:
.c772	20 77 c7	jsr $c777			jsr 	FPUNormalise 				; normalise the floating point.
.c775					_FPUFExit:
.c775	68		pla				pla
.c776	60		rts				rts
.c777					FPUNormalise:
.c777	48		pha				pha
.c778	34 85		bit $85,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.c77a	70 18		bvs $c794			bvs 	_FPUNExit
.c77c	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.c77e	f0 10		beq $c790			beq 	_FPUNSetZero
.c780					_FPUNLoop:
.c780	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.c782	30 10		bmi $c794			bmi 	_FPUNExit 					; if so, we are normalised.
.c784	16 80		asl $80,x			asl 	0+XS_Mantissa+0,x
.c786	36 81		rol $81,x			rol 	1+XS_Mantissa+0,x
.c788	36 82		rol $82,x			rol 	2+XS_Mantissa+0,x
.c78a	36 83		rol $83,x			rol 	3+XS_Mantissa+0,x
.c78c	d6 84		dec $84,x			dec 	XS_Exponent,x 				; decrement exponent
.c78e	d0 f0		bne $c780			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.c790					_FPUNSetZero:
.c790	a9 40		lda #$40			lda 	#$40
.c792	95 85		sta $85,x			sta 	XS_Type,x 					; the result is now zero.
.c794					_FPUNExit:
.c794	68		pla				pla
.c795	60		rts				rts
.c796					FPUToInteger:
.c796	48		pha				pha
.c797	b5 85		lda $85,x			lda 	XS_Type,x 					; if already integer, exit
.c799	29 01		and #$01			and 	#1
.c79b	d0 31		bne $c7ce			bne 	_FPUTOI_Exit
.c79d	34 85		bit $85,x			bit 	XS_Type,x					; if zero, return zero.
.c79f	70 23		bvs $c7c4			bvs 	_FPUTOI_Zero
.c7a1	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.c7a3	10 1f		bpl $c7c4			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.c7a5	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.c7a7	b0 2b		bcs $c7d4			bcs 	FP_Overflow
.c7a9					_FPUToIToInteger:
.c7a9	b5 84		lda $84,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.c7ab	c9 a0		cmp #$a0			cmp 	#128+32
.c7ad	f0 0c		beq $c7bb			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.c7af	f6 84		inc $84,x			inc 	XS_Exponent,X 				; increment Exponent
.c7b1	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.c7b3	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.c7b5	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.c7b7	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.c7b9	80 ee		bra $c7a9			bra 	_FPUToIToInteger 			; keep going.
.c7bb					_FPUToICheckSign:
.c7bb	b5 85		lda $85,x			lda 	XS_Type,x 					; check sign
.c7bd	10 0f		bpl $c7ce			bpl 	_FPUToI_Exit 				; exit if unsigned.
.c7bf	20 2e c7	jsr $c72e			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.c7c2	80 0a		bra $c7ce			bra 	_FPUTOI_Exit
.c7c4					_FPUTOI_Zero:
.c7c4	a9 00		lda #$00			lda 	#0 							; return zero integer.
.c7c6	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c7c8	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c7ca	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c7cc	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c7ce					_FPUToI_Exit:
.c7ce	a9 01		lda #$01			lda 	#1 							; set type to integer
.c7d0	95 85		sta $85,x			sta 	XS_Type,x
.c7d2	68		pla				pla
.c7d3	60		rts				rts
.c7d4					FP_Overflow:
.c7d4	20 e7 ad	jsr $ade7			jsr ERR_Handler
>c7d7	46 6c 6f 61 74 69 6e 67			.text "Floating Point overflow",0
>c7df	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.c7ef					FPUTimes10:
.c7ef	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.c7f1	85 1a		sta $1a				sta 	ZLTemp1+0
.c7f3	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c7f5	85 1b		sta $1b				sta 	ZLTemp1+1
.c7f7	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c7f9	85 1c		sta $1c				sta 	ZLTemp1+2
.c7fb	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.c7fd	85 1d		sta $1d				sta 	ZLTemp1+3
.c7ff	20 34 c8	jsr $c834			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.c802	20 34 c8	jsr $c834			jsr 	_FPUT_LSR_ZLTemp1
.c805	18		clc				clc
.c806	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.c808	65 1a		adc $1a				adc 	ZLTemp1+0
.c80a	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c80c	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c80e	65 1b		adc $1b				adc 	ZLTemp1+1
.c810	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c812	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c814	65 1c		adc $1c				adc 	ZLTemp1+2
.c816	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c818	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.c81a	65 1d		adc $1d				adc 	ZLTemp1+3
.c81c	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c81e	90 0a		bcc $c82a			bcc 	_FPUTimes10
.c820	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.c822	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.c824	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.c826	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.c828	f6 84		inc $84,x			inc 	XS_Exponent,x				; fix exponent
.c82a					_FPUTimes10:
.c82a	b5 84		lda $84,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.c82c	18		clc				clc
.c82d	69 03		adc #$03			adc 	#3
.c82f	95 84		sta $84,x			sta 	XS_Exponent,x
.c831	b0 a1		bcs $c7d4			bcs 	FP_Overflow 				; error
.c833	60		rts				rts
.c834					_FPUT_LSR_ZLTemp1:
.c834	46 1d		lsr $1d				lsr 	ZLTemp1+3
.c836	66 1c		ror $1c				ror 	ZLTemp1+2
.c838	66 1b		ror $1b				ror 	ZLTemp1+1
.c83a	66 1a		ror $1a				ror 	ZLTemp1+0
.c83c	60		rts				rts
.c83d					FPUScale10A:
.c83d	5a		phy				phy
.c83e	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.c840	f0 37		beq $c879			beq 	_FPUScaleExit
.c842	da		phx				phx 								; save X
.c843	e8		inx				inx
.c844	e8		inx				inx
.c845	e8		inx				inx
.c846	e8		inx				inx
.c847	e8		inx				inx
.c848	e8		inx				inx
.c849	a8		tay				tay 								; save power scalar in Y.
.c84a	a9 00		lda #$00			lda 	#0
.c84c	95 80		sta $80,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.c84e	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c850	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c852	95 85		sta $85,x			sta 	XS_Type,x
.c854	a9 80		lda #$80			lda 	#$80
.c856	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c858	a9 81		lda #$81			lda 	#$81
.c85a	95 84		sta $84,x			sta 	XS_Exponent,x
.c85c	5a		phy				phy 								; save 10^n on stack.
.c85d	c0 00		cpy #$00			cpy 	#0
.c85f	10 05		bpl $c866			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.c861	98		tya				tya
.c862	49 ff		eor #$ff			eor 	#$FF
.c864	1a		inc a				inc 	a
.c865	a8		tay				tay
.c866					_FPUSAbs:
.c866	20 ef c7	jsr $c7ef			jsr 	FPUTimes10
.c869	88		dey				dey
.c86a	d0 fa		bne $c866			bne 	_FPUSAbs 					; tos is now 10^|AC|
.c86c	68		pla				pla 								; restore count in A
.c86d	fa		plx				plx 								; restore X pointing to number to scale.
.c86e	0a		asl a				asl 	a
.c86f	b0 05		bcs $c876			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.c871	20 ce c5	jsr $c5ce			jsr 	FPMultiply 					; if clear multiply.
.c874	80 03		bra $c879			bra		_FPUScaleExit
.c876					_FPUSDivide:
.c876	20 5b c5	jsr $c55b			jsr 	FPDivide
.c879					_FPUScaleExit:
.c879	7a		ply				ply
.c87a	60		rts				rts
.c87b					FPUCopyToNext:
.c87b	a0 06		ldy #$06			ldy 		#6
.c87d	da		phx				phx
.c87e					_FPUCopy1:
.c87e	b5 80		lda $80,x			lda 	XS_Mantissa,x
.c880	95 86		sta $86,x			sta 	XS2_Mantissa,x
.c882	e8		inx				inx
.c883	88		dey				dey
.c884	d0 f8		bne $c87e			bne 	_FPUCopy1
.c886	fa		plx				plx
.c887	60		rts				rts
.c888					FPUCopyFromNext:
.c888	a0 06		ldy #$06			ldy 		#6
.c88a	da		phx				phx
.c88b					_FPUCopy1:
.c88b	b5 86		lda $86,x			lda 	XS2_Mantissa,x
.c88d	95 80		sta $80,x			sta 	XS_Mantissa,x
.c88f	e8		inx				inx
.c890	88		dey				dey
.c891	d0 f8		bne $c88b			bne 	_FPUCopy1
.c893	fa		plx				plx
.c894	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.c895					FPToString:
.c895	48		pha				pha
.c896	5a		phy				phy
.c897	34 85		bit $85,x			bit 		XS_Type,x 				; check zero flag
.c899	50 0a		bvc $c8a5			bvc 		_FPTSIsFloat 			; if zero,
.c89b					_FPTSZero:
.c89b	a9 30		lda #$30			lda 		#"0"
.c89d	20 fc c3	jsr $c3fc			jsr 		ITSOutputCharacter
.c8a0					_FPTSExit:
.c8a0	7a		ply				ply
.c8a1	68		pla				pla
.c8a2	60		rts				rts
.c8a3	80 fb		bra $c8a0			bra 		_FPTSExit
.c8a5					_FPTSIsFloat:
.c8a5	b5 85		lda $85,x			lda 		XS_Type,x 				; is it signed ?
.c8a7	10 09		bpl $c8b2			bpl 		_FPTSNotSigned
.c8a9	a9 00		lda #$00			lda 		#0 						; clear sign flag
.c8ab	95 85		sta $85,x			sta 		XS_Type,x
.c8ad	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.c8af	20 fc c3	jsr $c3fc			jsr 		ITSOutputCharacter
.c8b2					_FPTSNotSigned:
.c8b2	b5 84		lda $84,x			lda 		XS_Exponent,x
.c8b4	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.c8b6	b0 09		bcs $c8c1			bcs 		_FPTSExponent
.c8b8	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.c8ba	90 05		bcc $c8c1			bcc 		_FPTSExponent 			;
.c8bc					_FPTSStandard:
.c8bc	20 00 c9	jsr $c900			jsr 		FPTOutputBody 			; output the body.
.c8bf	80 df		bra $c8a0			bra 		_FPTSExit
.c8c1					_FPTSExponent:
.c8c1	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.c8c3	8d 9d 03	sta $039d			sta 		ExpCount
.c8c6					_FPTSExponentLoop:
.c8c6	b5 84		lda $84,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.c8c8	10 0e		bpl $c8d8			bpl 		_FPTSTimes
.c8ca	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.c8cc	90 14		bcc $c8e2			bcc 		_FPTSScaledToExp
.c8ce	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.c8d0	20 3d c8	jsr $c83d			jsr 		FPUScale10A
.c8d3	ee 9d 03	inc $039d			inc 		ExpCount
.c8d6	80 ee		bra $c8c6			bra 		_FPTSExponentLoop
.c8d8					_FPTSTimes:
.c8d8	a9 01		lda #$01			lda 		#1
.c8da	20 3d c8	jsr $c83d			jsr 		FPUScale10A
.c8dd	ce 9d 03	dec $039d			dec 		ExpCount
.c8e0	80 e4		bra $c8c6			bra 		_FPTSExponentLoop
.c8e2					_FPTSScaledToExp:
.c8e2	20 00 c9	jsr $c900			jsr 		FPTOutputBody 			; output the body.
.c8e5	a9 65		lda #$65			lda 		#"e"					; output E
.c8e7	20 fc c3	jsr $c3fc			jsr 		ITSOutputCharacter
.c8ea	ad 9d 03	lda $039d			lda 		ExpCount 				; get the exponent
.c8ed	95 80		sta $80,x			sta 		XS_Mantissa,x
.c8ef	29 80		and #$80			and 		#$80 					; sign extend it
.c8f1	f0 02		beq $c8f5			beq 		_FPTSSExt
.c8f3	a9 ff		lda #$ff			lda 		#$FF
.c8f5					_FPTSSExt:
.c8f5	95 81		sta $81,x			sta 		XS_Mantissa+1,x
.c8f7	95 82		sta $82,x			sta 		XS_Mantissa+2,x
.c8f9	95 83		sta $83,x			sta 		XS_Mantissa+3,x
.c8fb	20 5e c3	jsr $c35e			jsr 		INTToString 			; output the exponent.
.c8fe	80 a0		bra $c8a0			bra			_FPTSExit 				; and exit.
.c900					FPTOutputBody:
.c900	20 7b c8	jsr $c87b			jsr 		FPUCopyToNext 			; copy to next slot.
.c903	20 96 c7	jsr $c796			jsr 		FPUToInteger 			; convert to an integer
.c906	20 5e c3	jsr $c35e			jsr 		INTToString 			; output the main integer part.
.c909	20 88 c8	jsr $c888			jsr 		FPUCopyFromNext 		; get the fractional part back.
.c90c	20 56 c6	jsr $c656			jsr 		FPFractionalPart 		; get the decimal part.
.c90f	34 85		bit $85,x			bit 		XS_Type,x 				; any fractional part.
.c911	70 3c		bvs $c94f			bvs 		_FPTOExit 				; if not, exit now.
.c913	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.c915	20 fc c3	jsr $c3fc			jsr 		ITSOutputCharacter
.c918					_FPOutLoop:
.c918	34 85		bit $85,x			bit 		XS_Type,x 				; finally reached zero.
.c91a	70 1d		bvs $c939			bvs 		_FPStripZeros 			; strip trailing zeros
.c91c	20 ef c7	jsr $c7ef			jsr 		FPUTimes10 				; multiply by 10
.c91f	20 7b c8	jsr $c87b			jsr 		FPUCopyToNext			; copy to next slot.
.c922	20 96 c7	jsr $c796			jsr 		FPUToInteger 			; convert to integer
.c925	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; print digit.
.c927	09 30		ora #$30			ora 		#"0"
.c929	20 fc c3	jsr $c3fc			jsr 		ITSOutputCharacter
.c92c	20 88 c8	jsr $c888			jsr 		FPUCopyFromNext 		; get it back
.c92f	20 56 c6	jsr $c656			jsr 		FPFractionalPart 		; get fractional part
.c932	ad 14 03	lda $0314			lda 		NumBufX 				; done 11 characters yet ?
.c935	c9 0b		cmp #$0b			cmp 	 	#11
.c937	90 df		bcc $c918			bcc 		_FPOutLoop 				; if so, keep going till zero.
.c939					_FPStripZeros:
.c939	ac 14 03	ldy $0314			ldy 		NumBufX 				; strip trailing zeros.
.c93c					_FPStripLoop:
.c93c	88		dey				dey 								; back one, if at start then no strip
.c93d	f0 10		beq $c94f			beq 		_FPToExit
.c93f	b9 15 03	lda $0315,y			lda 		Num_Buffer,y 			; keep going if "0"
.c942	c9 30		cmp #$30			cmp 		#"0"
.c944	f0 f6		beq $c93c			beq 		_FPStripLoop
.c946	c8		iny				iny
.c947	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.c949	99 15 03	sta $0315,y			sta 		Num_Buffer,y
.c94c	8c 14 03	sty $0314			sty 		NumBufX 				; update position.
.c94f					_FPTOExit:
.c94f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.c950					FPFromString:
.c950	48		pha				pha 								; push A
.c951	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.c953	c9 2e		cmp #$2e			cmp 	#"."
.c955	f0 03		beq $c95a			beq	 	_FPFIsDecimal
.c957	4c b6 c9	jmp $c9b6			jmp 	_FPFNotDecimal
.c95a					_FPFIsDecimal:
.c95a	c8		iny				iny 								; consume the decimal.
.c95b	20 4a c7	jsr $c74a			jsr 	FPUToFloat 					; convert the integer to float.
.c95e	da		phx				phx 								; save X.
.c95f	5a		phy				phy 								; save decimal start position
.c960	e8		inx				inx
.c961	e8		inx				inx
.c962	e8		inx				inx
.c963	e8		inx				inx
.c964	e8		inx				inx
.c965	e8		inx				inx
.c966	20 14 c4	jsr $c414			jsr 	INTFromStringY 				; get the part after the DP.
.c969	20 4a c7	jsr $c74a			jsr 	FPUToFloat 					; convert that to a float.
.c96c	68		pla				pla 								; calculate - chars consumed.
.c96d	8c 9c 03	sty $039c			sty 	ExpTemp
.c970	38		sec				sec
.c971	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; this is the shift amount
.c974	20 3d c8	jsr $c83d			jsr 	FPUScale10A 				; scale it by 10^AC
.c977	fa		plx				plx 								; restore original X
.c978	20 a7 c4	jsr $c4a7			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.c97b	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.c97d	c9 45		cmp #$45			cmp 	#"E"
.c97f	f0 04		beq $c985			beq 	_FPFExponent
.c981	c9 65		cmp #$65			cmp 	#"e"
.c983	d0 31		bne $c9b6			bne 	_FPFNotDecimal 				; no, then exit normally.
.c985					_FPFExponent:
.c985	c8		iny				iny 								; skip over E symbol.
.c986	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.c988	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.c98a	d0 01		bne $c98d			bne 	_FPFGotSign
.c98c	c8		iny				iny 								; if it was - skip over it.
.c98d					_FPFGotSign:
.c98d	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.c98e	da		phx				phx
.c98f	e8		inx				inx
.c990	e8		inx				inx
.c991	e8		inx				inx
.c992	e8		inx				inx
.c993	e8		inx				inx
.c994	e8		inx				inx
.c995	20 14 c4	jsr $c414			jsr 	INTFromStringY 				; get the exponent
.c998	fa		plx				plx 								; restore X.
.c999	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.c99b	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.c99d	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.c99f	d0 17		bne $c9b8			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.c9a1	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.c9a3	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.c9a5	b0 11		bcs $c9b8			bcs 	_FPFXOverflow
.c9a7	68		pla				pla 								; get direction
.c9a8	d0 07		bne $c9b1			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.c9aa	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.c9ac	49 ff		eor #$ff			eor 	#$FF
.c9ae	1a		inc a				inc 	a
.c9af	95 86		sta $86,x			sta 	XS2_Mantissa+0,x
.c9b1					_FPFXScale:
.c9b1	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.c9b3	20 3d c8	jsr $c83d			jsr 	FPUScale10A 				; scale by the exponent.
.c9b6					_FPFNotDecimal:
.c9b6	68		pla				pla
.c9b7	60		rts				rts
.c9b8					_FPFXOverflow:
.c9b8	20 e7 ad	jsr $ade7			jsr 	ERR_Handler
>c9bb	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>c9c3	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.c9ca					Unary_Rnd:
.c9ca	20 96 b7	jsr $b796			jsr 	EvaluateNumberX 			; get value
.c9cd	20 d4 bd	jsr $bdd4			jsr 	CheckNextRParen 			; check right bracket.
.c9d0	20 14 ba	jsr $ba14			jsr 	GetSignCurrent 				; get sign -1,0,1.
.c9d3	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.c9d5	30 10		bmi $c9e7			bmi 	_URSetSeed
.c9d7	f0 28		beq $ca01			beq 	_URMakeRandom 				; if zero return same number.
.c9d9	da		phx				phx
.c9da	a2 00		ldx #$00			ldx 	#0
.c9dc	20 38 ca	jsr $ca38			jsr 	Random16
.c9df	a2 02		ldx #$02			ldx 	#2
.c9e1	20 38 ca	jsr $ca38			jsr 	Random16
.c9e4	fa		plx				plx
.c9e5	80 1a		bra $ca01			bra 	_URMakeRandom
.c9e7					_URSetSeed:
.c9e7	20 4a c7	jsr $c74a			jsr 	FPUToFloat 					; make it a float to twiddle it.
.c9ea	b5 80		lda $80,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.c9ec	8d a3 03	sta $03a3			sta 	RandomSeed+0
.c9ef	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.c9f1	8d a4 03	sta $03a4			sta 	RandomSeed+1
.c9f4	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.c9f6	8d a5 03	sta $03a5			sta 	RandomSeed+2
.c9f9	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.c9fb	0a		asl a				asl 	a
.c9fc	49 db		eor #$db			eor 	#$DB
.c9fe	8d a6 03	sta $03a6			sta 	RandomSeed+3
.ca01					_URMakeRandom:
.ca01	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; check if seed is zero.
.ca04	0d a4 03	ora $03a4			ora 	RandomSeed+1
.ca07	0d a5 03	ora $03a5			ora 	RandomSeed+2
.ca0a	0d a6 03	ora $03a6			ora 	RandomSeed+3
.ca0d	d0 0a		bne $ca19			bne 	_URNotZero
.ca0f	a9 47		lda #$47			lda 	#$47
.ca11	8d a4 03	sta $03a4			sta 	RandomSeed+1				; if it is, make it non zero.
.ca14	a9 3d		lda #$3d			lda 	#$3D
.ca16	8d a6 03	sta $03a6			sta 	RandomSeed+3
.ca19					_URNotZero:
.ca19	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; copy seed into mantissa.
.ca1c	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.ca1e	ad a4 03	lda $03a4			lda 	RandomSeed+1
.ca21	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.ca23	ad a5 03	lda $03a5			lda 	RandomSeed+2
.ca26	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.ca28	ad a6 03	lda $03a6			lda 	RandomSeed+3
.ca2b	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.ca2d	a9 00		lda #$00			lda 	#$00 						; set type to float.
.ca2f	95 85		sta $85,x			sta 	XS_Type,x
.ca31	a9 80		lda #$80			lda 	#$80
.ca33	95 84		sta $84,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.ca35	4c 77 c7	jmp $c777			jmp 	FPUNormalise
.ca38					Random16:
.ca38	5e a4 03	lsr $03a4,x			lsr 	RandomSeed+1,x				; shift seed right
.ca3b	7e a3 03	ror $03a3,x			ror 	RandomSeed,x
.ca3e	90 08		bcc $ca48			bcc 	_R16_NoXor
.ca40	bd a4 03	lda $03a4,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.ca43	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.ca45	9d a4 03	sta $03a4,x			sta 	RandomSeed+1,x
.ca48					_R16_NoXor:
.ca48	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.ca49					Unary_Int:
.ca49	20 96 b7	jsr $b796			jsr 	EvaluateNumberX 			; get value
.ca4c	20 d4 bd	jsr $bdd4			jsr 	CheckNextRParen 			; check right bracket.
.ca4f	4c 96 c7	jmp $c796			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Return to file: basic.asm

.ca52	80 fe		bra $ca52	_halt:	bra 		_halt
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 a0						.word 	StartROM
>fffe	95 ac					.word TIM_BreakVector

;******  End of listing
