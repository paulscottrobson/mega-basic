
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Sat Aug 24 16:21:08 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="4510"					cpu = "4510"
="mega65"				hardware = "mega65"
=1					exitonend = 1
=0					autorun = 0
=0					loadtest = 0
=1					hasfloat = 1
=1					hasinteger = 1
=253					maxstring = 253

;******  Processing file: modules/float/fpmacros.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/mega65/src_mega65.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0020					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0200					IFT_XCursor:.byte ?							; current logical position on screen
>0201					IFT_YCursor:.byte ?
>0202					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0266					IFT_LineBuffer: .fill 100 					; line input buffer.
>0300					UserVector .fill 4 							; USR(x) calls this.
>0304					LocalVector .fill 4 						; Indirect calls call this.
>0308					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>030c					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>030d					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=782					XS2_Mantissa = XS_Mantissa+XS_Size
=786					XS2_Exponent = XS_Exponent+XS_Size
=787					XS2_Type = XS_Type+XS_Size
=788					XS3_Mantissa = XS_Mantissa+XS_Size*2
=792					XS3_Exponent = XS_Exponent+XS_Size*2
=793					XS3_Type = XS_Type+XS_Size*2
>0400					NumBufX 	.byte 	?						; buffer index position
>0401					Num_Buffer	.fill 	32 						; buffer for numeric conversions
>0421					NumSuppress	.byte 	?						; leading zero suppression flag
>0422					NumConvCount .byte 	? 						; count for conversions.
>0423					ExpTemp:	.byte ?							; Working temp for exponents.
>0424					ExpCount:	.byte ? 						; Count of decimal exponents.
>0425					SignCount:	.byte ?							; Integer Divide Sign Counts.
>0426					StringPtr:	.word ? 						; Top of free memory (for string allocation)
>0428					TempStringWriteIndex: .byte ? 				; Write offset.
>0429					ValSign: 	.byte ? 						; sign flag for val()
>042a					SliceStart:	.byte ? 						; string slice parts
>042b					SliceCount:	.byte ?
>042c					RandomSeed:	.dword ? 						; Random seed.
>0430					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>0432					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>0434					Tim_SR:		.byte ? 						; Processor Status
>0435					Tim_A:		.byte ? 						; Processor Registers
>0436					Tim_X:		.byte ?
>0437					Tim_Y:		.byte ?
>0438					Tim_Z:		.byte ?
>0439					Tim_SP:		.byte ?							; Stack Pointer

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/mega65.asm

=$7000					HighMemory = $7000
.8000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testcode.src

>8000	12 02 00 d4 a7 b1 4a 40			.byte	$12,$02,$00,$d4,$a7,$b1,$4a,$40
>8008	40 8a 50 40 40 8c 42 bc			.byte	$40,$8a,$50,$40,$40,$8c,$42,$bc
>8010	bc 00 05 03 00 c2 00 00			.byte	$bc,$00,$05,$03,$00,$c2,$00,$00

;******  Return to file: modules/hardware/mega65.asm

.a000					StartROM:
.a000	a2 ff		ldx #$ff			ldx 		#$FF 					; empty stack
.a002	9a		txs				txs
.a003	20 4d a2	jsr $a24d			jsr 	IF_Reset 					; reset external interface
.a006	20 0c a0	jsr $a00c			jsr 	IFT_ClearScreen
.a009	4c af ad	jmp $adaf		jmp BASIC_Start

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.a00c					IFT_ClearScreen:
.a00c	48		pha				pha
.a00d	da		phx				phx
.a00e	5a		phy				phy
.a00f	20 b4 a1	jsr $a1b4			jsr 	IF_Home 					; home cursor
.a012	a2 19		ldx #$19			ldx 	#IF_Height 					; this many lines.
.a014					_IFT_CS0:
.a014	a0 50		ldy #$50			ldy 	#IF_Width 					; this many chars/line
.a016					_IFT_CS1:
.a016	a9 20		lda #$20			lda 	#' '						; clear line.
.a018	20 e3 a1	jsr $a1e3			jsr 	IF_Write
.a01b	88		dey				dey
.a01c	d0 f8		bne $a016			bne 	_IFT_CS1
.a01e	20 c3 a1	jsr $a1c3			jsr 	IF_NewLine 					; next line down
.a021	ca		dex				dex
.a022	d0 f0		bne $a014			bne 	_IFT_CS0
.a024	7a		ply				ply
.a025	fa		plx				plx
.a026	68		pla				pla
.a027					IFT_HomeCursor:
.a027	48		pha				pha
.a028	20 b4 a1	jsr $a1b4			jsr 	IF_Home
.a02b	a9 00		lda #$00			lda 	#0
.a02d	8d 00 02	sta $0200			sta 	IFT_XCursor
.a030	8d 01 02	sta $0201			sta 	IFT_YCursor
.a033	68		pla				pla
.a034	60		rts				rts
.a035					IFT_UpLine:
.a035	48		pha				pha
.a036	ad 01 02	lda $0201			lda  	IFT_YCursor 				; get Y
.a039	3a		dec a				dec 	a 							; line above
.a03a	30 03		bmi $a03f			bmi 	_IFTULExit 					; too far, abort
.a03c	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos					; set to that line.
.a03f					_IFTULExit:
.a03f	68		pla				pla
.a040	60		rts				rts
.a041					IFT_PrintCharacter:
.a041	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.a043	f0 23		beq $a068			beq 	IFT_NewLine
.a045	48		pha				pha
.a046	20 80 a0	jsr $a080			jsr 	IFT_UpperCase 				; make upper case
.a049	20 e3 a1	jsr $a1e3			jsr 	IF_Write 					; write out.
.a04c	ee 00 02	inc $0200			inc 	IFT_XCursor 				; bump x cursor
.a04f	ad 00 02	lda $0200			lda 	IFT_XCursor 				; reached RHS ?
.a052	c9 50		cmp #$50			cmp 	#IF_Width
.a054	d0 03		bne $a059			bne 	_IFT_PCNotEOL
.a056	20 68 a0	jsr $a068			jsr 	IFT_NewLine 				; if so do new line.
.a059					_IFT_PCNotEOL:
.a059	68		pla				pla
.a05a	60		rts				rts
.a05b					IFT_Tab:
.a05b	a9 20		lda #$20			lda 	#" " 						; space
.a05d	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.a060	ad 00 02	lda $0200			lda 	IFT_XCursor 				; until x % 8 == 0
.a063	29 07		and #$07			and 	#7
.a065	d0 f4		bne $a05b			bne 	IFT_Tab
.a067	60		rts				rts
.a068					IFT_NewLine:
.a068	48		pha				pha
.a069	20 c3 a1	jsr $a1c3			jsr 	IF_NewLine 					; new line on actual screen.
.a06c	a9 00		lda #$00			lda 	#0 							; reset x position
.a06e	8d 00 02	sta $0200			sta 	IFT_XCursor
.a071	ee 01 02	inc $0201			inc 	IFT_YCursor 				; move down.
.a074	ad 01 02	lda $0201			lda 	IFT_YCursor
.a077	c9 19		cmp #$19			cmp 	#IF_Height 					; reached bottom.
.a079	d0 03		bne $a07e			bne 	_IFT_NL_NotEOS
.a07b	20 8b a0	jsr $a08b			jsr 	IFT_Scroll 					; scroll screen up.
.a07e					_IFT_NL_NotEOS:
.a07e	68		pla				pla
.a07f	60		rts				rts
.a080					IFT_UpperCase:
.a080	c9 61		cmp #$61			cmp 	#"a"
.a082	90 06		bcc $a08a			bcc 	_IFT_UCExit
.a084	c9 7b		cmp #$7b			cmp 	#"z"+1
.a086	b0 02		bcs $a08a			bcs 	_IFT_UCExit
.a088	49 20		eor #$20			eor 	#$20
.a08a					_IFT_UCExit:
.a08a	60		rts				rts
.a08b					IFT_Scroll:
.a08b	48		pha				pha 								; save AXY
.a08c	da		phx				phx
.a08d	5a		phy				phy
.a08e	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.a090					_IFT_SLoop:
.a090	20 b0 a0	jsr $a0b0			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.a093	e8		inx				inx
.a094	e0 18		cpx #$18			cpx 	#IF_Height-1				; do whole screen
.a096	d0 f8		bne $a090			bne 	_IFT_SLoop
.a098	a9 18		lda #$18			lda 	#IF_Height-1 				; move to X = 0,Y = A
.a09a	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a09d	a2 50		ldx #$50			ldx 	#IF_Width 					; blank line
.a09f					_IFT_SBlank:
.a09f	a9 20		lda #$20			lda 	#32
.a0a1	20 e3 a1	jsr $a1e3			jsr 	IF_Write
.a0a4	ca		dex				dex
.a0a5	d0 f8		bne $a09f			bne 	_IFT_SBlank
.a0a7	a9 18		lda #$18			lda 	#IF_Height-1 				; move to X = 0,Y = A
.a0a9	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a0ac	7a		ply				ply
.a0ad	fa		plx				plx
.a0ae	68		pla				pla
.a0af	60		rts				rts
.a0b0					_IFT_ScrollLine:
.a0b0	da		phx				phx
.a0b1	da		phx				phx
.a0b2	8a		txa				txa 								; copy line into buffer.
.a0b3	1a		inc a				inc 	a 							; next line down.
.a0b4	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a0b7	a2 00		ldx #$00			ldx 	#0
.a0b9					_IFTScrollCopy1:
.a0b9	20 d5 a1	jsr $a1d5			jsr 	IF_Read
.a0bc	9d 02 02	sta $0202,x			sta 	IFT_Buffer,x
.a0bf	e8		inx				inx
.a0c0	e0 50		cpx #$50			cpx 	#IF_Width
.a0c2	d0 f5		bne $a0b9			bne 	_IFTScrollCopy1
.a0c4	68		pla				pla
.a0c5	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a0c8	a2 00		ldx #$00			ldx 	#0
.a0ca					_IFTScrollCopy2:
.a0ca	bd 02 02	lda $0202,x			lda 	IFT_Buffer,x
.a0cd	20 e3 a1	jsr $a1e3			jsr 	IF_Write
.a0d0	e8		inx				inx
.a0d1	e0 50		cpx #$50			cpx 	#IF_Width
.a0d3	d0 f5		bne $a0ca			bne 	_IFTScrollCopy2
.a0d5	fa		plx				plx
.a0d6	60		rts				rts
.a0d7					IFT_SetYPos:
.a0d7	48		pha				pha
.a0d8	da		phx				phx
.a0d9	aa		tax				tax
.a0da	20 27 a0	jsr $a027			jsr 	IFT_HomeCursor
.a0dd	e0 00		cpx #$00			cpx 	#0
.a0df	f0 09		beq $a0ea			beq 	_IFT_MOAExit
.a0e1					_IFT_MOALoop:
.a0e1	20 c3 a1	jsr $a1c3			jsr 	IF_NewLine
.a0e4	ee 01 02	inc $0201			inc 	IFT_YCursor
.a0e7	ca		dex				dex
.a0e8	d0 f7		bne $a0e1			bne		_IFT_MOALoop
.a0ea					_IFT_MOAExit:
.a0ea	fa		plx				plx
.a0eb	68		pla				pla
.a0ec	60		rts				rts
.a0ed					IFT_GetKeyCursor:
.a0ed	20 f5 a0	jsr $a0f5			jsr 	_IFT_FlipCursor 			; reverse current
.a0f0					_IFT_GKCWait:
.a0f0	20 06 a2	jsr $a206			jsr 	IF_GetKey 					; get key
.a0f3	f0 fb		beq $a0f0			beq 	_IFT_GKCWait
.a0f5					_IFT_FlipCursor:
.a0f5	48		pha				pha 								; save
.a0f6	20 d5 a1	jsr $a1d5			jsr 	IF_Read 					; read
.a0f9	20 ee a1	jsr $a1ee			jsr 	IF_LeftOne
.a0fc	49 80		eor #$80			eor 	#$80 						; reverse
.a0fe	20 e3 a1	jsr $a1e3			jsr 	IF_Write 					; write
.a101	20 ee a1	jsr $a1ee			jsr 	IF_LeftOne
.a104	68		pla				pla
.a105	60		rts				rts
.a106					IFT_ReadLine:
.a106	48		pha				pha
.a107					_IFT_RLLoop:
.a107	20 ed a0	jsr $a0ed			jsr 	IFT_GetKeyCursor 			; get keystroke
.a10a	c9 0d		cmp #$0d			cmp 	#13							; return
.a10c	f0 7d		beq $a18b			beq 	_IFT_RLExit
.a10e	c9 20		cmp #$20			cmp 	#32 						; control character
.a110	90 05		bcc $a117			bcc 	_IFT_Control
.a112	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.a115	80 f0		bra $a107			bra 	_IFT_RLLoop
.a117					_IFT_Control:
.a117	c9 01		cmp #$01			cmp 	#"A"-64
.a119	f0 26		beq $a141			beq 	_IFT_Left
.a11b	c9 04		cmp #$04			cmp 	#"D"-64
.a11d	f0 2e		beq $a14d			beq 	_IFT_Right
.a11f	c9 17		cmp #$17			cmp 	#"W"-64
.a121	f0 36		beq $a159			beq 	_IFT_Up
.a123	c9 13		cmp #$13			cmp 	#"S"-64
.a125	f0 3e		beq $a165			beq 	_IFT_Down
.a127	c9 08		cmp #$08			cmp 	#"H"-64
.a129	f0 09		beq $a134			beq 	_IFT_Backspace
.a12b	c9 1a		cmp #$1a			cmp 	#"Z"-64
.a12d	d0 d8		bne $a107			bne 	_IFT_RLLoop
.a12f	20 0c a0	jsr $a00c			jsr 	IFT_ClearScreen				; clear CTL-Z
.a132	80 d3		bra $a107			bra 	_IFT_RLLoop
.a134					_IFT_Backspace:
.a134	ad 00 02	lda $0200			lda 	IFT_XCursor 				; check not start of line.
.a137	f0 ce		beq $a107			beq 	_IFT_RLLoop
.a139	20 ee a1	jsr $a1ee			jsr 	IF_LeftOne
.a13c	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.a13e	20 e3 a1	jsr $a1e3			jsr 	IF_Write
.a141					_IFT_Left:
.a141	ce 00 02	dec $0200			dec 	IFT_XCursor 				; left CTL-W
.a144	10 29		bpl $a16f			bpl 	_IFT_Reposition
.a146	a9 4f		lda #$4f			lda 	#IF_Width-1
.a148					_IFT_SetX:
.a148	8d 00 02	sta $0200			sta 	IFT_XCursor
.a14b	80 22		bra $a16f			bra 	_IFT_Reposition
.a14d					_IFT_Right:
.a14d	ee 00 02	inc $0200			inc 	IFT_XCursor
.a150	ad 00 02	lda $0200			lda 	IFT_XCursor
.a153	49 50		eor #$50			eor 	#IF_Width
.a155	f0 f1		beq $a148			beq 	_IFT_SetX
.a157	80 16		bra $a16f			bra 	_IFT_Reposition
.a159					_IFT_Up:
.a159	ce 01 02	dec $0201			dec 	IFT_YCursor
.a15c	10 11		bpl $a16f			bpl 	_IFT_Reposition
.a15e	a9 18		lda #$18			lda 	#IF_Height-1
.a160					_IFT_SetY:
.a160	8d 01 02	sta $0201			sta 	IFT_YCursor
.a163	80 0a		bra $a16f			bra 	_IFT_Reposition
.a165					_IFT_Down:
.a165	ee 01 02	inc $0201			inc 	IFT_YCursor
.a168	ad 01 02	lda $0201			lda 	IFT_YCursor
.a16b	49 19		eor #$19			eor 	#IF_Height
.a16d	f0 f1		beq $a160			beq 	_IFT_SetY
.a16f					_IFT_Reposition:
.a16f	ad 00 02	lda $0200			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.a172	48		pha				pha
.a173	ad 01 02	lda $0201			lda 	IFT_YCursor
.a176	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a179	68		pla				pla
.a17a	aa		tax				tax
.a17b	e0 00		cpx #$00			cpx 	#0
.a17d	f0 88		beq $a107			beq 	_IFT_RLLoop
.a17f					_IFT_MoveRight:
.a17f	20 d5 a1	jsr $a1d5			jsr 	IF_Read
.a182	ee 00 02	inc $0200			inc 	IFT_XCursor
.a185	ca		dex				dex
.a186	d0 f7		bne $a17f			bne 	_IFT_MoveRight
.a188	4c 07 a1	jmp $a107			jmp 	_IFT_RLLoop
.a18b					_IFT_RLExit:
.a18b	ad 01 02	lda $0201			lda 	IFT_YCursor 				; go to start of line.
.a18e	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a191	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.a193					_IFT_RLRead:
.a193	20 d5 a1	jsr $a1d5			jsr 	IF_Read
.a196	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.a199	e8		inx				inx
.a19a	e0 50		cpx #$50			cpx 	#IF_Width
.a19c	d0 f5		bne $a193			bne 	_IFT_RLRead
.a19e					_IFT_RL_Trim:
.a19e	ca		dex				dex 	 							; previous char
.a19f	30 07		bmi $a1a8			bmi 	_IFT_Found 					; gone too far
.a1a1	bd 66 02	lda $0266,x			lda 	IFT_LineBuffer,x			; go back if space
.a1a4	c9 20		cmp #$20			cmp 	#" "
.a1a6	f0 f6		beq $a19e			beq 	_IFT_RL_Trim
.a1a8					_IFT_Found:
.a1a8	e8		inx				inx 								; forward to non-space
.a1a9	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.a1ab	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.a1ae	68		pla				pla
.a1af	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.a1b1	a0 02		ldy #$02			ldy 	#IFT_LineBuffer >> 8
.a1b3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_mega65.asm

=80					IF_Width 	= 80 							; characters across
=25					IF_Height 	= 25 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line
=6					IF_XPos 	= 6 							; current position, horizontal.
=8					IF_FarPtr 	= 8 							; far pointer (4 bytes)
=$1000					IF_Screen = $1000							; 2k screen RAM here
=$800					IF_CharSet = $800							; 2k character set (0-7F) here
.a1b4					IF_Home:
.a1b4	48		pha				pha 								; reset cursor position
.a1b5	a9 00		lda #$00			lda 	#IF_Screen & $FF
.a1b7	85 04		sta $04				sta 	IF_Pos
.a1b9	a9 10		lda #$10			lda 	#IF_Screen >> 8
.a1bb	85 05		sta $05				sta 	IF_Pos+1
.a1bd	a9 00		lda #$00			lda 	#0
.a1bf	85 06		sta $06				sta 	IF_XPos
.a1c1	68		pla				pla
.a1c2	60		rts				rts
.a1c3					IF_NewLine:
.a1c3	48		pha				pha
.a1c4	a9 00		lda #$00			lda 	#0 							; back to start of line
.a1c6	85 06		sta $06				sta 	IF_XPos
.a1c8	18		clc				clc 								; down one line
.a1c9	a5 04		lda $04				lda 	IF_Pos
.a1cb	69 50		adc #$50			adc 	#80
.a1cd	85 04		sta $04				sta 	IF_Pos
.a1cf	90 02		bcc $a1d3			bcc 	_IF_NoCarry 				; carry through.
.a1d1	e6 05		inc $05				inc 	IF_Pos+1
.a1d3					_IF_NoCarry:
.a1d3	68		pla				pla
.a1d4	60		rts				rts
.a1d5					IF_Read:
.a1d5	5a		phy				phy 								; save current Y
.a1d6	a4 06		ldy $06				ldy 	IF_XPos 					; read character at current position
.a1d8	b1 04		lda ($04),y			lda 	(IF_Pos),y
.a1da	49 20		eor #$20			eor 	#$20
.a1dc	18		clc				clc
.a1dd	69 20		adc #$20			adc 	#$20
.a1df	e6 06		inc $06				inc 	IF_XPos 					; step right.
.a1e1	7a		ply				ply									; restore Y
.a1e2	60		rts				rts
.a1e3					IF_Write:
.a1e3	5a		phy				phy 								; save current Y
.a1e4	a4 06		ldy $06				ldy 	IF_XPos 					; write character at current position
.a1e6	29 bf		and #$bf			and 	#63+128 					; PETSCII
.a1e8	91 04		sta ($04),y			sta 	(IF_Pos),y
.a1ea	e6 06		inc $06				inc 	IF_XPos 					; step right.
.a1ec	7a		ply				ply									; restore Y
.a1ed	60		rts				rts
.a1ee					IF_LeftOne:
.a1ee	c6 06		dec $06				dec 	IF_XPos
.a1f0	60		rts				rts
.a1f1					IF_CheckBreak:
.a1f1	db		phz				phz
.a1f2	20 3a a2	jsr $a23a			jsr 	IF_SetupKeyAddress 			; point to keyboard
.a1f5	e6 08		inc $08				inc 	IF_FarPtr 					; point to modifiers.
.a1f7	ea		nop				nop 								; read modifiers.
.a1f8	b2 08		lda ($08),z			lda 	(IF_FarPtr),z
.a1fa	fb		plz				plz 								; restore Z
.a1fb	29 05		and #$05			and 	#5							; break is LeftShift+Ctrl
.a1fd	c9 05		cmp #$05			cmp 	#5
.a1ff	f0 02		beq $a203			beq 	_IF_CBExit
.a201	a9 00		lda #$00			lda 	#0
.a203					_IF_CBExit:
.a203	c9 00		cmp #$00			cmp 	#0
.a205	60		rts				rts
.a206					IF_GetKey:
.a206	db		phz				phz
.a207	20 3a a2	jsr $a23a			jsr 	IF_SetupKeyAddress
.a20a	ea		nop				nop 								; read keyboard
.a20b	b2 08		lda ($08),z			lda 	(IF_FarPtr),z
.a20d	c9 14		cmp #$14			cmp 	#20
.a20f	d0 02		bne $a213			bne 	_KMNo
.a211	a9 08		lda #$08			lda 	#"H"-64
.a213					_KMNo:
.a213	c9 91		cmp #$91			cmp 	#145
.a215	d0 02		bne $a219			bne 	_KMNo
.a217	a9 17		lda #$17			lda 	#"W"-64
.a219					_KMNo:
.a219	c9 11		cmp #$11			cmp 	#17
.a21b	d0 02		bne $a21f			bne 	_KMNo
.a21d	a9 13		lda #$13			lda 	#"S"-64
.a21f					_KMNo:
.a21f	c9 9d		cmp #$9d			cmp 	#157
.a221	d0 02		bne $a225			bne 	_KMNo
.a223	a9 01		lda #$01			lda 	#"A"-64
.a225					_KMNo:
.a225	c9 1d		cmp #$1d			cmp 	#29
.a227	d0 02		bne $a22b			bne 	_KMNo
.a229	a9 04		lda #$04			lda 	#"D"-64
.a22b					_KMNo:
.a22b	c9 00		cmp #$00			cmp 	#0
.a22d	f0 07		beq $a236			beq 	_IFGKEmpty
.a22f	48		pha				pha
.a230	a9 00		lda #$00			lda 	#0
.a232	ea		nop				nop
.a233	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a235	68		pla				pla
.a236					_IFGKEmpty:
.a236	fb		plz				plz
.a237	c9 00		cmp #$00			cmp 	#0 							; set Z
.a239	60		rts				rts
.a23a					IF_SetupKeyAddress:
.a23a	a9 0f		lda #$0f			lda 	#$0F 						; set up to write to read keyboard.
.a23c	85 0b		sta $0b				sta 	IF_FarPtr+3
.a23e	a9 fd		lda #$fd			lda 	#$FD
.a240	85 0a		sta $0a				sta 	IF_FarPtr+2
.a242	a9 36		lda #$36			lda 	#$36
.a244	85 09		sta $09				sta 	IF_FarPtr+1
.a246	a9 10		lda #$10			lda 	#$10
.a248	85 08		sta $08				sta 	IF_FarPtr+0
.a24a	a3 00		ldz #$00			ldz 	#0
.a24c	60		rts				rts
.a24d					IF_Reset:
.a24d	48		pha				pha 								; save registers
.a24e	da		phx				phx
.a24f	5a		phy				phy
.a250	a9 0f		lda #$0f			lda 	#$0F 						; set up to write to video system.
.a252	85 0b		sta $0b				sta 	IF_FarPtr+3
.a254	a9 fd		lda #$fd			lda 	#$FD
.a256	85 0a		sta $0a				sta 	IF_FarPtr+2
.a258	a9 30		lda #$30			lda 	#$30
.a25a	85 09		sta $09				sta 	IF_FarPtr+1
.a25c	a9 00		lda #$00			lda 	#$00
.a25e	85 08		sta $08				sta 	IF_FarPtr+0
.a260	a3 2f		ldz #$2f			ldz 	#$2F 						; address already set up
.a262	a9 47		lda #$47			lda 	#$47
.a264	ea		nop				nop
.a265	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a267	a3 2f		ldz #$2f			ldz 	#$2F 						; address already set up
.a269	a9 53		lda #$53			lda 	#$53
.a26b	ea		nop				nop
.a26c	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a26e	a3 30		ldz #$30			ldz 	#$30 						; address already set up
.a270	a9 40		lda #$40			lda 	#$40
.a272	ea		nop				nop
.a273	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a275	a3 31		ldz #$31			ldz 	#$31 						; address already set up
.a277	a9 c0		lda #$c0			lda 	#$80+$40
.a279	ea		nop				nop
.a27a	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a27c	a3 20		ldz #$20			ldz 	#$20 						; address already set up
.a27e	a9 00		lda #$00			lda 	#0
.a280	ea		nop				nop
.a281	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a283	a3 21		ldz #$21			ldz 	#$21 						; address already set up
.a285	a9 00		lda #$00			lda 	#0
.a287	ea		nop				nop
.a288	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a28a	a3 54		ldz #$54			ldz 	#$54 						; address already set up
.a28c	a9 40		lda #$40			lda 	#$40
.a28e	ea		nop				nop
.a28f	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a291	a3 01		ldz #$01			ldz 	#$01 						; address already set up
.a293	a9 ff		lda #$ff			lda 	#$FF
.a295	ea		nop				nop
.a296	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a298	a3 00		ldz #$00			ldz 	#$00 						; address already set up
.a29a	a9 ff		lda #$ff			lda 	#$FF
.a29c	ea		nop				nop
.a29d	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a29f	a3 16		ldz #$16			ldz 	#$16 						; address already set up
.a2a1	a9 cc		lda #$cc			lda 	#$CC
.a2a3	ea		nop				nop
.a2a4	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2a6	a3 18		ldz #$18			ldz 	#$18 						; address already set up
.a2a8	a9 42		lda #$42			lda 	#$42
.a2aa	ea		nop				nop
.a2ab	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2ad	a3 11		ldz #$11			ldz 	#$11 						; address already set up
.a2af	a9 1b		lda #$1b			lda 	#$1B
.a2b1	ea		nop				nop
.a2b2	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2b4	a9 00		lda #$00			lda 	#$00						; colour RAM at $1F800-1FFFF (2kb)
.a2b6	85 0b		sta $0b				sta 	IF_FarPtr+3
.a2b8	a9 01		lda #$01			lda 	#$01
.a2ba	85 0a		sta $0a				sta 	IF_FarPtr+2
.a2bc	a9 f8		lda #$f8			lda 	#$F8
.a2be	85 09		sta $09				sta 	IF_FarPtr+1
.a2c0	a9 00		lda #$00			lda 	#$00
.a2c2	85 08		sta $08				sta 	IF_FarPtr+0
.a2c4	a3 00		ldz #$00			ldz 	#0
.a2c6					_EXTClearColorRam:
.a2c6	a9 05		lda #$05			lda 	#5							; fill that with this colour.
.a2c8	ea		nop				nop
.a2c9	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2cb	3b		dez				dez
.a2cc	d0 f8		bne $a2c6			bne 	_EXTClearColorRam
.a2ce	e6 09		inc $09				inc 	IF_FarPtr+1
.a2d0	d0 f4		bne $a2c6			bne 	_EXTClearColorRam
.a2d2	a2 00		ldx #$00			ldx 	#0 							; copy PET Font into memory.
.a2d4					_EXTCopyCBMFont:
.a2d4	bd 15 a3	lda $a315,x			lda 	IF_CBMFont,x 				; +$800 uses the lower case c/set
.a2d7	9d 00 08	sta $0800,x			sta 	IF_CharSet,x
.a2da	49 ff		eor #$ff			eor 	#$FF
.a2dc	9d 00 0c	sta $0c00,x			sta 	IF_CharSet+$400,x
.a2df	bd 15 a4	lda $a415,x			lda 	IF_CBMFont+$100,x
.a2e2	9d 00 09	sta $0900,x			sta 	IF_CharSet+$100,x
.a2e5	49 ff		eor #$ff			eor 	#$FF
.a2e7	9d 00 0d	sta $0d00,x			sta 	IF_CharSet+$500,x
.a2ea	bd 15 a5	lda $a515,x			lda 	IF_CBMFont+$200,x
.a2ed	9d 00 0a	sta $0a00,x			sta 	IF_CharSet+$200,x
.a2f0	49 ff		eor #$ff			eor 	#$FF
.a2f2	9d 00 0e	sta $0e00,x			sta 	IF_CharSet+$600,x
.a2f5	bd 15 a6	lda $a615,x			lda 	IF_CBMFont+$300,x
.a2f8	9d 00 0b	sta $0b00,x			sta 	IF_CharSet+$300,x
.a2fb	49 ff		eor #$ff			eor 	#$FF
.a2fd	9d 00 0f	sta $0f00,x			sta 	IF_CharSet+$700,x
.a300	ca		dex				dex
.a301	d0 d1		bne $a2d4			bne 	_EXTCopyCBMFont
.a303	a9 3b		lda #$3b			lda 	#$3F-4  					; puts ROM back in the map (the -4)
.a305	85 01		sta $01				sta 	$01
.a307	a9 00		lda #$00			lda 	#$00						; do not map bytes 0000-7FFF
.a309	a2 00		ldx #$00			ldx 	#$00						; (so we use the RAM physically at $0000-$7FFF)
.a30b	a0 00		ldy #$00			ldy 	#$00 						; 8000-FFFF offset by $200. The lower 8 bits are $00
.a30d	a3 f2		ldz #$f2			ldz 	#$F2 						; so this is an actual offset of $20000. So the space at
.a30f	5c		map				map
.a310	ea		nop				eom
.a311	7a		ply				ply 								; restore and exit.
.a312	fa		plx				plx
.a313	68		pla				pla
.a314	60		rts				rts
.a315					IF_CBMFont:
>a315	1c 22 4a 56 4c 20 1e 00				.binary "pet-font.bin"
>a31d	18 24 42 7e 42 42 42 00 7c 22 22 3c 22 22 7c 00
>a32d	1c 22 40 40 40 22 1c 00 78 24 22 22 22 24 78 00
>a33d	7e 40 40 78 40 40 7e 00 7e 40 40 78 40 40 40 00
>a34d	1c 22 40 4e 42 22 1c 00 42 42 42 7e 42 42 42 00
>a35d	1c 08 08 08 08 08 1c 00 0e 04 04 04 04 44 38 00
>a36d	42 44 48 70 48 44 42 00 40 40 40 40 40 40 7e 00
>a37d	42 66 5a 5a 42 42 42 00 42 62 52 4a 46 42 42 00
>a38d	18 24 42 42 42 24 18 00 7c 42 42 7c 40 40 40 00
>a39d	18 24 42 42 4a 24 1a 00 7c 42 42 7c 48 44 42 00
>a3ad	3c 42 40 3c 02 42 3c 00 3e 08 08 08 08 08 08 00
>a3bd	42 42 42 42 42 42 3c 00 42 42 42 24 24 18 18 00
>a3cd	42 42 42 5a 5a 66 42 00 42 42 24 18 24 42 42 00
>a3dd	22 22 22 1c 08 08 08 00 7e 02 04 18 20 40 7e 00
>a3ed	3c 20 20 20 20 20 3c 00 00 40 20 10 08 04 02 00
>a3fd	3c 04 04 04 04 04 3c 00 00 08 1c 2a 08 08 08 08
>a40d	00 00 10 20 7f 20 10 00 00 00 00 00 00 00 00 00
>a41d	08 08 08 08 00 00 08 00 24 24 24 00 00 00 00 00
>a42d	24 24 7e 24 7e 24 24 00 08 1e 28 1c 0a 3c 08 00
>a43d	00 62 64 08 10 26 46 00 30 48 48 30 4a 44 3a 00
>a44d	04 08 10 00 00 00 00 00 04 08 10 10 10 08 04 00
>a45d	20 10 08 08 08 10 20 00 08 2a 1c 3e 1c 2a 08 00
>a46d	00 08 08 3e 08 08 00 00 00 00 00 00 00 08 08 10
>a47d	00 00 00 7e 00 00 00 00 00 00 00 00 00 18 18 00
>a48d	00 02 04 08 10 20 40 00 3c 42 46 5a 62 42 3c 00
>a49d	08 18 28 08 08 08 3e 00 3c 42 02 0c 30 40 7e 00
>a4ad	3c 42 02 1c 02 42 3c 00 04 0c 14 24 7e 04 04 00
>a4bd	7e 40 78 04 02 44 38 00 1c 20 40 7c 42 42 3c 00
>a4cd	7e 42 04 08 10 10 10 00 3c 42 42 3c 42 42 3c 00
>a4dd	3c 42 42 3e 02 04 38 00 00 00 08 00 00 08 00 00
>a4ed	00 00 08 00 00 08 08 10 0e 18 30 60 30 18 0e 00
>a4fd	00 00 7e 00 7e 00 00 00 70 18 0c 06 0c 18 70 00
>a50d	3c 42 02 0c 10 00 10 00 00 00 00 00 ff 00 00 00
>a51d	08 1c 3e 7f 7f 1c 3e 00 10 10 10 10 10 10 10 10
>a52d	00 00 00 ff 00 00 00 00 00 00 ff 00 00 00 00 00
>a53d	00 ff 00 00 00 00 00 00 00 00 00 00 00 ff 00 00
>a54d	20 20 20 20 20 20 20 20 04 04 04 04 04 04 04 04
>a55d	00 00 00 00 e0 10 08 08 08 08 08 04 03 00 00 00
>a56d	08 08 08 10 e0 00 00 00 80 80 80 80 80 80 80 ff
>a57d	80 40 20 10 08 04 02 01 01 02 04 08 10 20 40 80
>a58d	ff 80 80 80 80 80 80 80 ff 01 01 01 01 01 01 01
>a59d	00 3c 7e 7e 7e 7e 3c 00 00 00 00 00 00 00 ff 00
>a5ad	36 7f 7f 7f 3e 1c 08 00 40 40 40 40 40 40 40 40
>a5bd	00 00 00 00 03 04 08 08 81 42 24 18 18 24 42 81
>a5cd	00 3c 42 42 42 42 3c 00 08 1c 2a 77 2a 08 08 00
>a5dd	02 02 02 02 02 02 02 02 08 1c 3e 7f 3e 1c 08 00
>a5ed	08 08 08 08 ff 08 08 08 a0 50 a0 50 a0 50 a0 50
>a5fd	08 08 08 08 08 08 08 08 00 00 01 3e 54 14 14 00
>a60d	ff 7f 3f 1f 0f 07 03 01 00 00 00 00 00 00 00 00
>a61d	f0 f0 f0 f0 f0 f0 f0 f0 00 00 00 00 ff ff ff ff
>a62d	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff
>a63d	80 80 80 80 80 80 80 80 aa 55 aa 55 aa 55 aa 55
>a64d	01 01 01 01 01 01 01 01 00 00 00 00 aa 55 aa 55
>a65d	ff fe fc f8 f0 e0 c0 80 03 03 03 03 03 03 03 03
>a66d	08 08 08 08 0f 08 08 08 00 00 00 00 0f 0f 0f 0f
>a67d	08 08 08 08 0f 00 00 00 00 00 00 00 f8 08 08 08
>a68d	00 00 00 00 00 00 ff ff 00 00 00 00 0f 08 08 08
>a69d	08 08 08 08 ff 00 00 00 00 00 00 00 ff 08 08 08
>a6ad	08 08 08 08 f8 08 08 08 c0 c0 c0 c0 c0 c0 c0 c0
>a6bd	e0 e0 e0 e0 e0 e0 e0 e0 07 07 07 07 07 07 07 07
>a6cd	ff ff 00 00 00 00 00 00 ff ff ff 00 00 00 00 00
>a6dd	00 00 00 00 00 ff ff ff 01 01 01 01 01 01 01 ff
>a6ed	00 00 00 00 f0 f0 f0 f0 0f 0f 0f 0f 00 00 00 00
>a6fd	08 08 08 08 f8 00 00 00 f0 f0 f0 f0 00 00 00 00
>a70d	f0 f0 f0 f0 0f 0f 0f 0f 1c 22 4a 56 4c 20 1e 00
>a71d	18 24 42 7e 42 42 42 00 7c 22 22 3c 22 22 7c 00
>a72d	1c 22 40 40 40 22 1c 00 78 24 22 22 22 24 78 00
>a73d	7e 40 40 78 40 40 7e 00 7e 40 40 78 40 40 40 00
>a74d	1c 22 40 4e 42 22 1c 00 42 42 42 7e 42 42 42 00
>a75d	1c 08 08 08 08 08 1c 00 0e 04 04 04 04 44 38 00
>a76d	42 44 48 70 48 44 42 00 40 40 40 40 40 40 7e 00
>a77d	42 66 5a 5a 42 42 42 00 42 62 52 4a 46 42 42 00
>a78d	18 24 42 42 42 24 18 00 7c 42 42 7c 40 40 40 00
>a79d	18 24 42 42 4a 24 1a 00 7c 42 42 7c 48 44 42 00
>a7ad	3c 42 40 3c 02 42 3c 00 3e 08 08 08 08 08 08 00
>a7bd	42 42 42 42 42 42 3c 00 42 42 42 24 24 18 18 00
>a7cd	42 42 42 5a 5a 66 42 00 42 42 24 18 24 42 42 00
>a7dd	22 22 22 1c 08 08 08 00 7e 02 04 18 20 40 7e 00
>a7ed	3c 20 20 20 20 20 3c 00 00 40 20 10 08 04 02 00
>a7fd	3c 04 04 04 04 04 3c 00 00 08 1c 2a 08 08 08 08
>a80d	00 00 10 20 7f 20 10 00 00 00 00 00 00 00 00 00
>a81d	08 08 08 08 00 00 08 00 24 24 24 00 00 00 00 00
>a82d	24 24 7e 24 7e 24 24 00 08 1e 28 1c 0a 3c 08 00
>a83d	00 62 64 08 10 26 46 00 30 48 48 30 4a 44 3a 00
>a84d	04 08 10 00 00 00 00 00 04 08 10 10 10 08 04 00
>a85d	20 10 08 08 08 10 20 00 08 2a 1c 3e 1c 2a 08 00
>a86d	00 08 08 3e 08 08 00 00 00 00 00 00 00 08 08 10
>a87d	00 00 00 7e 00 00 00 00 00 00 00 00 00 18 18 00
>a88d	00 02 04 08 10 20 40 00 3c 42 46 5a 62 42 3c 00
>a89d	08 18 28 08 08 08 3e 00 3c 42 02 0c 30 40 7e 00
>a8ad	3c 42 02 1c 02 42 3c 00 04 0c 14 24 7e 04 04 00
>a8bd	7e 40 78 04 02 44 38 00 1c 20 40 7c 42 42 3c 00
>a8cd	7e 42 04 08 10 10 10 00 3c 42 42 3c 42 42 3c 00
>a8dd	3c 42 42 3e 02 04 38 00 00 00 08 00 00 08 00 00
>a8ed	00 00 08 00 00 08 08 10 0e 18 30 60 30 18 0e 00
>a8fd	00 00 7e 00 7e 00 00 00 70 18 0c 06 0c 18 70 00
>a90d	3c 42 02 0c 10 00 10 00 00 00 00 00 ff 00 00 00
>a91d	00 00 38 04 3c 44 3a 00 40 40 5c 62 42 62 5c 00
>a92d	00 00 3c 42 40 42 3c 00 02 02 3a 46 42 46 3a 00
>a93d	00 00 3c 42 7e 40 3c 00 0c 12 10 7c 10 10 10 00
>a94d	00 00 3a 46 46 3a 02 3c 40 40 5c 62 42 42 42 00
>a95d	08 00 18 08 08 08 1c 00 04 00 0c 04 04 04 44 38
>a96d	40 40 44 48 50 68 44 00 18 08 08 08 08 08 1c 00
>a97d	00 00 76 49 49 49 49 00 00 00 5c 62 42 42 42 00
>a98d	00 00 3c 42 42 42 3c 00 00 00 5c 62 62 5c 40 40
>a99d	00 00 3a 46 46 3a 02 02 00 00 5c 62 40 40 40 00
>a9ad	00 00 3e 40 3c 02 7c 00 10 10 7c 10 10 12 0c 00
>a9bd	00 00 42 42 42 46 3a 00 00 00 42 42 42 24 18 00
>a9cd	00 00 41 49 49 49 36 00 00 00 42 24 18 24 42 00
>a9dd	00 00 42 42 46 3a 02 3c 00 00 7e 04 18 20 7e 00
>a9ed	08 08 08 08 ff 08 08 08 a0 50 a0 50 a0 50 a0 50
>a9fd	08 08 08 08 08 08 08 08 cc cc 33 33 cc cc 33 33
>aa0d	cc 66 33 99 cc 66 33 99 00 00 00 00 00 00 00 00
>aa1d	f0 f0 f0 f0 f0 f0 f0 f0 00 00 00 00 ff ff ff ff
>aa2d	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff
>aa3d	80 80 80 80 80 80 80 80 aa 55 aa 55 aa 55 aa 55
>aa4d	01 01 01 01 01 01 01 01 00 00 00 00 aa 55 aa 55
>aa5d	99 33 66 cc 99 33 66 cc 03 03 03 03 03 03 03 03
>aa6d	08 08 08 08 0f 08 08 08 00 00 00 00 0f 0f 0f 0f
>aa7d	08 08 08 08 0f 00 00 00 00 00 00 00 f8 08 08 08
>aa8d	00 00 00 00 00 00 ff ff 00 00 00 00 0f 08 08 08
>aa9d	08 08 08 08 ff 00 00 00 00 00 00 00 ff 08 08 08
>aaad	08 08 08 08 f8 08 08 08 c0 c0 c0 c0 c0 c0 c0 c0
>aabd	e0 e0 e0 e0 e0 e0 e0 e0 07 07 07 07 07 07 07 07
>aacd	ff ff 00 00 00 00 00 00 ff ff ff 00 00 00 00 00
>aadd	00 00 00 00 00 ff ff ff 01 02 44 48 50 60 40 00
>aaed	00 00 00 00 f0 f0 f0 f0 0f 0f 0f 0f 00 00 00 00
>aafd	08 08 08 08 f8 00 00 00 f0 f0 f0 f0 00 00 00 00
>ab0d	f0 f0 f0 f0 0f 0f 0f 0f

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/errors.asm

.ab15					SyntaxError:
.ab15	20 44 ab	jsr $ab44			jsr 	ERR_Handler
>ab18	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>ab20	72 72 6f 72 00
.ab25					TypeError:
.ab25	20 44 ab	jsr $ab44			jsr 	ERR_Handler
>ab28	57 72 6f 6e 67 20 74 79				.text 	"Wrong type",0
>ab30	70 65 00
.ab33					BadParamError:
.ab33	20 44 ab	jsr $ab44			jsr 	ERR_Handler
>ab36	42 61 64 20 50 61 72 61				.text 	"Bad Parameter",0
>ab3e	6d 65 74 65 72 00
.ab44					ERR_Handler:
.ab44	a0 00		ldy #$00			ldy 	#0
.ab46	c8		iny				iny
.ab47	b1 16		lda ($16),y			lda 	(zCodePtr),y
.ab49	8d 08 03	sta $0308			sta 	XS_Mantissa
.ab4c	c8		iny				iny
.ab4d	b1 16		lda ($16),y			lda 	(zCodePtr),y
.ab4f	8d 09 03	sta $0309			sta 	XS_Mantissa+1
.ab52	fa		plx				plx 								; address in XY
.ab53	7a		ply				ply
.ab54	e8		inx				inx 								; bump, because of RTS/JSR address -1
.ab55	d0 01		bne $ab58			bne 	_EHNoSkip
.ab57	c8		iny				iny
.ab58					_EHNoSkip:
.ab58	20 79 ab	jsr $ab79			jsr 	PrintROMMessage 			; print message from ROM.
.ab5b	ad 08 03	lda $0308			lda 	XS_Mantissa					; line number = 0
.ab5e	0d 09 03	ora $0309			ora 	XS_Mantissa+1
.ab61	f0 0c		beq $ab6f			beq 	_EHNoLine
.ab63	a2 74		ldx #$74			ldx 	#_EHAt & $FF 				; print " at "
.ab65	a0 ab		ldy #$ab			ldy 	#(_EHAt >> 8) & $FF
.ab67	20 79 ab	jsr $ab79			jsr 	PrintROMMessage
.ab6a	a2 00		ldx #$00			ldx 	#0 							; Print line number
.ab6c	20 8a ab	jsr $ab8a			jsr 	Print16BitInteger
.ab6f					_EHNoLine:
.ab6f	80 fe		bra $ab6f			bra 	_EHNoLine
.ab71	4c cf ad	jmp $adcf			jmp 	WarmStart
>ab74	20 61 74 20 00			_EHAt:	.text 	" at ",0
.ab79					PrintROMMessage:
.ab79	86 1a		stx $1a				stx 	zLTemp1 					; save addres
.ab7b	84 1b		sty $1b				sty 	zLTemp1+1
.ab7d	a0 00		ldy #$00			ldy 	#0
.ab7f					_PRMLoop:
.ab7f	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.ab81	f0 06		beq $ab89			beq		_PRMExit
.ab83	c8		iny				iny
.ab84	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.ab87	80 f6		bra $ab7f			bra 	_PRMLoop
.ab89					_PRMExit:
.ab89	60		rts				rts
.ab8a					Print16BitInteger:
.ab8a	a9 00		lda #$00			lda 	#0 							; make 32 bit
.ab8c	8d 0a 03	sta $030a			sta 	XS_Mantissa+2
.ab8f	8d 0b 03	sta $030b			sta 	XS_Mantissa+3
.ab92	8d 00 04	sta $0400			sta 	NumBufX 					; reset the conversion pointer
.ab95	aa		tax				tax 								; convert bottom level.
.ab96	20 a3 b8	jsr $b8a3			jsr 	INTToString 				; make string
.ab99	a2 00		ldx #$00			ldx 	#0 							; print buffer
.ab9b	bd 01 04	lda $0401,x	_P1Loop:lda 	Num_Buffer,x
.ab9e	f0 06		beq $aba6			beq 	_P1Exit
.aba0	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.aba3	e8		inx				inx
.aba4	80 f5		bra $ab9b			bra 	_P1Loop
.aba6	60		rts		_P1Exit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm


;******  Processing file: modules/basic/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b4					lastUnaryFunction = $b4
.aba7					VectorTable:
>aba7	c0 b0					.word BinaryOp_And         & $FFFF ; $80 and
>aba9	e8 b0					.word BinaryOp_Or          & $FFFF ; $81 or
>abab	10 b1					.word BinaryOp_Xor         & $FFFF ; $82 xor
>abad	10 b1					.word BinaryOp_Eor         & $FFFF ; $83 eor
>abaf	54 b1					.word Binary_Equal         & $FFFF ; $84 =
>abb1	73 b1					.word Binary_NotEqual      & $FFFF ; $85 <>
>abb3	7c b1					.word Binary_Less          & $FFFF ; $86 <
>abb5	85 b1					.word Binary_LessEqual     & $FFFF ; $87 <=
>abb7	97 b1					.word Binary_Greater       & $FFFF ; $88 >
>abb9	8e b1					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>abbb	2c b2					.word BinaryOp_Add         & $FFFF ; $8a +
>abbd	4c b2					.word BinaryOp_Subtract    & $FFFF ; $8b -
>abbf	5f b2					.word BinaryOp_Multiply    & $FFFF ; $8c *
>abc1	72 b2					.word BinaryOp_Divide      & $FFFF ; $8d /
>abc3	5b ac					.word NotImplemented       & $FFFF ; $8e ^
>abc5	5b ac					.word NotImplemented       & $FFFF ; $8f if
>abc7	5b ac					.word NotImplemented       & $FFFF ; $90 while
>abc9	5b ac					.word NotImplemented       & $FFFF ; $91 repeat
>abcb	5b ac					.word NotImplemented       & $FFFF ; $92 for
>abcd	5b ac					.word NotImplemented       & $FFFF ; $93 then
>abcf	5b ac					.word NotImplemented       & $FFFF ; $94 endif
>abd1	5b ac					.word NotImplemented       & $FFFF ; $95 wend
>abd3	5b ac					.word NotImplemented       & $FFFF ; $96 until
>abd5	5b ac					.word NotImplemented       & $FFFF ; $97 next
>abd7	5b ac					.word NotImplemented       & $FFFF ; $98 not
>abd9	5b ac					.word NotImplemented       & $FFFF ; $99 fn(
>abdb	a6 b3					.word Unary_Abs            & $FFFF ; $9a abs(
>abdd	fd b4					.word Unary_Asc            & $FFFF ; $9b asc(
>abdf	84 c0					.word Unary_Int            & $FFFF ; $9c int(
>abe1	c4 b3					.word Unary_Peek           & $FFFF ; $9d peek(
>abe3	fb bf					.word Unary_Rnd            & $FFFF ; $9e rnd(
>abe5	38 b4					.word Unary_Usr            & $FFFF ; $9f usr(
>abe7	3e b5					.word Unary_Left           & $FFFF ; $a0 left$(
>abe9	55 b5					.word Unary_Right          & $FFFF ; $a1 right$(
>abeb	23 b5					.word Unary_Mid            & $FFFF ; $a2 mid$(
>abed	b7 b6					.word Unary_Spc            & $FFFF ; $a3 spc(
>abef	ca b4					.word Unary_Str            & $FFFF ; $a4 str$(
>abf1	59 b4					.word Unary_Val            & $FFFF ; $a5 val(
>abf3	14 b5					.word Unary_Len            & $FFFF ; $a6 len(
>abf5	d3 b5					.word Unary_Hex            & $FFFF ; $a7 hex$(
>abf7	5b ac					.word NotImplemented       & $FFFF ; $a8 sin(
>abf9	5b ac					.word NotImplemented       & $FFFF ; $a9 cos(
>abfb	5b ac					.word NotImplemented       & $FFFF ; $aa tan(
>abfd	5b ac					.word NotImplemented       & $FFFF ; $ab atn(
>abff	5b ac					.word NotImplemented       & $FFFF ; $ac exp(
>ac01	5b ac					.word NotImplemented       & $FFFF ; $ad log(
>ac03	5b ac					.word NotImplemented       & $FFFF ; $ae sqr(
>ac05	2d b6					.word Unary_Dec            & $FFFF ; $af dec(
>ac07	c8 b3					.word Unary_Deek           & $FFFF ; $b0 deek(
>ac09	cc b3					.word Unary_Leek           & $FFFF ; $b1 leek(
>ac0b	00 b4					.word Unary_Mod            & $FFFF ; $b2 mod(
>ac0d	54 b3					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>ac0f	95 b6					.word Unary_Chr            & $FFFF ; $b4 chr$(
>ac11	5b ac					.word NotImplemented       & $FFFF ; $b5 $(
>ac13	5b ac					.word NotImplemented       & $FFFF ; $b6 $
>ac15	5b ac					.word NotImplemented       & $FFFF ; $b7 #(
>ac17	5b ac					.word NotImplemented       & $FFFF ; $b8 #
>ac19	5b ac					.word NotImplemented       & $FFFF ; $b9 %(
>ac1b	5b ac					.word NotImplemented       & $FFFF ; $ba %
>ac1d	5b ac					.word NotImplemented       & $FFFF ; $bb (
>ac1f	5b ac					.word NotImplemented       & $FFFF ; $bc )
>ac21	5b ac					.word NotImplemented       & $FFFF ; $bd ,
>ac23	49 ae					.word Command_COLON        & $FFFF ; $be :
>ac25	5b ac					.word NotImplemented       & $FFFF ; $bf ;
>ac27	5b ac					.word NotImplemented       & $FFFF ; $c0 def
>ac29	de ae					.word Command_CLR          & $FFFF ; $c1 clr
>ac2b	e9 ae					.word Command_STOP         & $FFFF ; $c2 stop
>ac2d	5b ac					.word NotImplemented       & $FFFF ; $c3 data
>ac2f	5b ac					.word NotImplemented       & $FFFF ; $c4 read
>ac31	5b ac					.word NotImplemented       & $FFFF ; $c5 dim
>ac33	5b ac					.word NotImplemented       & $FFFF ; $c6 to
>ac35	5b ac					.word NotImplemented       & $FFFF ; $c7 step
>ac37	5b ac					.word NotImplemented       & $FFFF ; $c8 gosub
>ac39	5b ac					.word NotImplemented       & $FFFF ; $c9 return
>ac3b	5b ac					.word NotImplemented       & $FFFF ; $ca goto
>ac3d	4a ae					.word Command_END          & $FFFF ; $cb end
>ac3f	5b ac					.word NotImplemented       & $FFFF ; $cc input
>ac41	5b ac					.word NotImplemented       & $FFFF ; $cd let
>ac43	5b ac					.word NotImplemented       & $FFFF ; $ce list
>ac45	5b ac					.word NotImplemented       & $FFFF ; $cf new
>ac47	5b ac					.word NotImplemented       & $FFFF ; $d0 old
>ac49	5b ac					.word NotImplemented       & $FFFF ; $d1 on
>ac4b	5b ac					.word NotImplemented       & $FFFF ; $d2 restore
>ac4d	5b ac					.word NotImplemented       & $FFFF ; $d3 poke
>ac4f	4f ae					.word Command_PRINT        & $FFFF ; $d4 print
>ac51	d5 ad					.word Command_RUN          & $FFFF ; $d5 run
>ac53	5b ac					.word NotImplemented       & $FFFF ; $d6 wait
>ac55	5b ac					.word NotImplemented       & $FFFF ; $d7 doke
>ac57	5b ac					.word NotImplemented       & $FFFF ; $d8 loke
>ac59	c2 ae					.word Command_ASSERT       & $FFFF ; $d9 assert
.ac5b					NotImplemented:
.ac5b	20 44 ab	jsr $ab44			jsr ERR_Handler
>ac5e	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>ac66	65 6d 65 6e 74 65 64 00
.ac6e					BinaryPrecedence:
>ac6e	01					.byte 1    ; $80 and
>ac6f	01					.byte 1    ; $81 or
>ac70	01					.byte 1    ; $82 xor
>ac71	01					.byte 1    ; $83 eor
>ac72	02					.byte 2    ; $84 =
>ac73	02					.byte 2    ; $85 <>
>ac74	02					.byte 2    ; $86 <
>ac75	02					.byte 2    ; $87 <=
>ac76	02					.byte 2    ; $88 >
>ac77	02					.byte 2    ; $89 >=
>ac78	03					.byte 3    ; $8a +
>ac79	03					.byte 3    ; $8b -
>ac7a	04					.byte 4    ; $8c *
>ac7b	04					.byte 4    ; $8d /
>ac7c	05					.byte 5    ; $8e ^
.ac7d					KeywordText:
>ac7d	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>ac80	4f d2					.byte $4f,$d2                          ; $81 or
>ac82	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>ac85	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>ac88	bd					.byte $bd                              ; $84 =
>ac89	3c be					.byte $3c,$be                          ; $85 <>
>ac8b	bc					.byte $bc                              ; $86 <
>ac8c	3c bd					.byte $3c,$bd                          ; $87 <=
>ac8e	be					.byte $be                              ; $88 >
>ac8f	3e bd					.byte $3e,$bd                          ; $89 >=
>ac91	ab					.byte $ab                              ; $8a +
>ac92	ad					.byte $ad                              ; $8b -
>ac93	aa					.byte $aa                              ; $8c *
>ac94	af					.byte $af                              ; $8d /
>ac95	de					.byte $de                              ; $8e ^
>ac96	49 c6					.byte $49,$c6                          ; $8f if
>ac98	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>ac9d	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>aca3	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>aca6	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>acaa	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>acaf	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>acb3	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>acb8	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>acbc	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>acbf	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>acc2	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>acc6	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>acca	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>acce	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>acd3	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>acd7	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>acdb	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>ace1	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>ace8	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>aced	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>acf1	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>acf6	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>acfa	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>acfe	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>ad03	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>ad07	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>ad0b	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>ad0f	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>ad13	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>ad17	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>ad1b	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>ad1f	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>ad23	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>ad28	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>ad2d	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>ad31	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>ad35	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>ad3a	24 a8					.byte $24,$a8                          ; $b5 $(
>ad3c	a4					.byte $a4                              ; $b6 $
>ad3d	23 a8					.byte $23,$a8                          ; $b7 #(
>ad3f	a3					.byte $a3                              ; $b8 #
>ad40	25 a8					.byte $25,$a8                          ; $b9 %(
>ad42	a5					.byte $a5                              ; $ba %
>ad43	a8					.byte $a8                              ; $bb (
>ad44	a9					.byte $a9                              ; $bc )
>ad45	ac					.byte $ac                              ; $bd ,
>ad46	ba					.byte $ba                              ; $be :
>ad47	bb					.byte $bb                              ; $bf ;
>ad48	44 45 c6				.byte $44,$45,$c6                      ; $c0 def
>ad4b	43 4c d2				.byte $43,$4c,$d2                      ; $c1 clr
>ad4e	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $c2 stop
>ad52	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c3 data
>ad56	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c4 read
>ad5a	44 49 cd				.byte $44,$49,$cd                      ; $c5 dim
>ad5d	54 cf					.byte $54,$cf                          ; $c6 to
>ad5f	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c7 step
>ad63	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $c8 gosub
>ad68	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $c9 return
>ad6e	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $ca goto
>ad72	45 4e c4				.byte $45,$4e,$c4                      ; $cb end
>ad75	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $cc input
>ad7a	4c 45 d4				.byte $4c,$45,$d4                      ; $cd let
>ad7d	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $ce list
>ad81	4e 45 d7				.byte $4e,$45,$d7                      ; $cf new
>ad84	4f 4c c4				.byte $4f,$4c,$c4                      ; $d0 old
>ad87	4f ce					.byte $4f,$ce                          ; $d1 on
>ad89	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d2 restore
>ad90	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d3 poke
>ad94	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d4 print
>ad99	52 55 ce				.byte $52,$55,$ce                      ; $d5 run
>ad9c	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d6 wait
>ada0	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $d7 doke
>ada4	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $d8 loke
>ada8	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $d9 assert
>adae	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_dollarlparen = $b5
=$b6					token_dollar = $b6
=$b7					token_hashlparen = $b7
=$b8					token_hash = $b8
=$b9					token_percentlparen = $b9
=$ba					token_percent = $ba
=$bb					token_lparen = $bb
=$bc					token_rparen = $bc
=$bd					token_comma = $bd
=$be					token_colon = $be
=$bf					token_semicolon = $bf
=$c0					token_def = $c0
=$c1					token_clr = $c1
=$c2					token_stop = $c2
=$c3					token_data = $c3
=$c4					token_read = $c4
=$c5					token_dim = $c5
=$c6					token_to = $c6
=$c7					token_step = $c7
=$c8					token_gosub = $c8
=$c9					token_return = $c9
=$ca					token_goto = $ca
=$cb					token_end = $cb
=$cc					token_input = $cc
=$cd					token_let = $cd
=$ce					token_list = $ce
=$cf					token_new = $cf
=$d0					token_old = $d0
=$d1					token_on = $d1
=$d2					token_restore = $d2
=$d3					token_poke = $d3
=$d4					token_print = $d4
=$d5					token_run = $d5
=$d6					token_wait = $d6
=$d7					token_doke = $d7
=$d8					token_loke = $d8
=$d9					token_assert = $d9

;******  Return to file: modules/basic/core.asm

.adaf					BASIC_Start:
.adaf	20 4d a2	jsr $a24d			jsr 	IF_Reset 					; set up and clear screen.
.adb2	20 0c a0	jsr $a00c			jsr 	IFT_ClearScreen
.adb5	a9 4c		lda #$4c			lda 	#$4C 						; JMP opcode
.adb7	8d 04 03	sta $0304			sta 	LocalVector
.adba	8d 00 03	sta $0300			sta 	UserVector
.adbd	a9 47		lda #$47			lda 	#USRDefault & $FF 			; reset USR vector
.adbf	8d 01 03	sta $0301			sta 	UserVector+1
.adc2	a9 b4		lda #$b4			lda 	#(USRDefault >> 8) & $FF
.adc4	8d 02 03	sta $0302			sta 	UserVector+2
.adc7	a9 00		lda #$00			lda 	#(USRDefault >> 16) & $FF
.adc9	8d 03 03	sta $0303			sta 	UserVector+3
.adcc	20 de ae	jsr $aede			jsr 	ResetRunStatus 				; clear everything (CLR command)
.adcf					WarmStart:
.adcf	a2 ff		ldx #$ff			ldx 		#$FF 					; empty stack
.add1	9a		txs				txs
.add2	4c d5 ad	jmp $add5			jmp 	COMMAND_Run

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/run.asm

.add5					Command_RUN:
.add5	20 de ae	jsr $aede			jsr 	ResetRunStatus 				; clear, reset stacks etc.
.add8	a9 00		lda #$00			lda 	#BasicProgram & $FF
.adda	85 16		sta $16				sta 	zCodePtr+0
.addc	a9 80		lda #$80			lda 	#BasicProgram >> 8
.adde	85 17		sta $17				sta 	zCodePtr+1
.ade0	a9 00		lda #$00			lda 	#0
.ade2	85 18		sta $18				sta 	zCodePtr+2
.ade4	85 19		sta $19				sta 	zCodePtr+3
.ade6	a0 03		ldy #$03			ldy 	#3
.ade8					RUN_NewLine:
.ade8	a0 00		ldy #$00			ldy 	#0
.adea	b1 16		lda ($16),y			lda 	(zCodePtr),y
.adec	c8		iny				iny
.aded	c8		iny				iny
.adee	c8		iny				iny
.adef	c9 00		cmp #$00			cmp 	#0 							; if the offset is zero then END.
.adf1	d0 16		bne $ae09			bne 	RUN_NextCommand
.adf3	4c e9 ae	jmp $aee9			jmp 	Command_STOP 				; go do the command code.
.adf6					RUN_Skip:
.adf6	b1 16		lda ($16),y			lda 	(zCodePtr),y 				; read element
.adf8	c8		iny				iny 								; skip
.adf9	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.adfb	90 0c		bcc $ae09			bcc 	_SEDone 					; so just skip over it.
.adfd	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.adff	90 07		bcc $ae08			bcc 	_SEDouble
.ae01	98		tya				tya 								; this is Y + 1
.ae02	18		clc				clc
.ae03	71 16		adc ($16),y			adc 	(zCodePtr),y 				; add total length of element
.ae05	a8		tay				tay 								; back in Y.
.ae06	88		dey				dey 								; fix up, one for the +1, one for the iny
.ae07	88		dey				dey
.ae08					_SEDouble:
.ae08	c8		iny				iny
.ae09					_SEDone:
.ae09					RUN_NextCommand:
.ae09	a9 00		lda #$00			lda 	#0 							; this resets temporary string allocation.
.ae0b	85 21		sta $21				sta 	zTempStr+1 					; (initialised when first called)
.ae0d	b1 16		lda ($16),y			lda 	(zCodePtr),y
.ae0f	c9 be		cmp #$be			cmp 	#token_Colon 				; skip over colons
.ae11	f0 e3		beq $adf6			beq 	RUN_Skip
.ae13	c9 00		cmp #$00			cmp 	#0 							; if non-zero execute whatever
.ae15	d0 0f		bne $ae26			bne 	RUN_Execute
.ae17					RUN_NextLine:
.ae17	a0 00		ldy #$00			ldy 	#0 							; point to offset
.ae19	b1 16		lda ($16),y			lda 	(zCodePtr),y 				; read it
.ae1b	18		clc				clc
.ae1c	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.ae1e	85 16		sta $16				sta 	zCodePtr
.ae20	90 02		bcc $ae24			bcc 	_SNLNoCarry
.ae22	e6 17		inc $17				inc 	zCodePtr+1
.ae24					_SNLNoCarry:
.ae24	80 c2		bra $ade8			bra 	RUN_NewLine 				; go do the new line code
.ae26					RUN_Execute:
.ae26	c9 f8		cmp #$f8			cmp 	#$F8 						; handle shifts, REM etc.
.ae28	b0 18		bcs $ae42			bcs 	RUN_Extension
.ae2a	c8		iny				iny
.ae2b	0a		asl a				asl 	a 							; double the character read.
.ae2c	90 12		bcc $ae40			bcc 	RUN_Default 				; if carry clear was $00-$7F, so try LET.
.ae2e	aa		tax				tax 								; ready to look up.
.ae2f	bd a7 ab	lda $aba7,x			lda 	VectorTable,x 				; copy address into LocalVector
.ae32	8d 05 03	sta $0305			sta 	LocalVector+1
.ae35	bd a8 ab	lda $aba8,x			lda 	VectorTable+1,x
.ae38	8d 06 03	sta $0306			sta 	LocalVector+2
.ae3b	20 f9 af	jsr $aff9			jsr 	EVCallLocalVector 			; execute the appropriate code.
.ae3e	80 c9		bra $ae09			bra 	RUN_NextCommand 			; do the next command.
.ae40					RUN_Default:
.ae40	80 fe		bra $ae40			bra 	RUN_Default
.ae42					RUN_Extension:
.ae42	c9 ff		cmp #$ff			cmp 	#$FF 						; if $FF (REM)
.ae44	f0 b0		beq $adf6			beq 	RUN_Skip 					; skip over it.
.ae46	4c 15 ab	jmp $ab15			jmp 	SyntaxError
.ae49					Command_COLON:
.ae49	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/end.asm

.ae4a					Command_END:
.ae4a	80 fe		bra $ae4a	_halt:	bra 		_halt
.ae4c	4c cf ad	jmp $adcf			jmp 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/print.asm

.ae4f					Command_PRINT:
.ae4f	b1 16		lda ($16),y			lda 	(zCodePtr),y
.ae51	c9 00		cmp #$00			cmp 	#0 							; end
.ae53	f0 69		beq $aebe			beq 	_CPR_NewLine
.ae55	c9 be		cmp #$be			cmp 	#token_Colon
.ae57	f0 65		beq $aebe			beq 	_CPR_NewLine
.ae59	c9 bf		cmp #$bf			cmp 	#token_SemiColon
.ae5b	f0 54		beq $aeb1			beq 	_CPR_Skip
.ae5d	c9 bd		cmp #$bd			cmp 	#token_Comma
.ae5f	f0 4d		beq $aeae			beq 	_CPR_Tab
.ae61	20 f4 ae	jsr $aef4			jsr 	EvaluateExpression 			; get expression.
.ae64	ad 0d 03	lda $030d			lda 	XS_Type 					; get type.
.ae67	29 02		and #$02			and 	#2
.ae69	d0 25		bne $ae90			bne 	_CPR_String 				; if type = 2 output as string.
.ae6b					_CPR_Number:
.ae6b	a9 00		lda #$00			lda 	#0 							; reset buffer index
.ae6d	8d 00 04	sta $0400			sta 	NumBufX
.ae70	ad 0d 03	lda $030d			lda 	XS_Type 					; get type
.ae73	4a		lsr a				lsr 	a
.ae74	b0 05		bcs $ae7b			bcs 	_CPRInt 					; if msb set do as integer
.ae76	20 b3 be	jsr $beb3			jsr 	FPToString 					; call fp to str otherwise
.ae79	80 03		bra $ae7e			bra 	_CPRNPrint
.ae7b	20 a3 b8	jsr $b8a3	_CPRInt:jsr 	IntToString
.ae7e					_CPRNPrint:
.ae7e	ad 01 04	lda $0401			lda 	Num_Buffer 					; is first character -
.ae81	c9 2d		cmp #$2d			cmp 	#"-"
.ae83	f0 05		beq $ae8a			beq 	_CPRNoSpace
.ae85	a9 20		lda #$20			lda 	#" "						; print the leading space
.ae87	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter 			; so beloved of MS Basics.
.ae8a					_CPRNoSpace:
.ae8a	a2 00		ldx #$00			ldx 	#(Num_Buffer-1) & $FF
.ae8c	a9 04		lda #$04			lda 	#(Num_Buffer-1) >> 8
.ae8e	80 06		bra $ae96			bra 	_CPRPrint
.ae90					_CPR_String:
.ae90	ae 08 03	ldx $0308			ldx 	XS_Mantissa
.ae93	ad 09 03	lda $0309			lda 	XS_Mantissa+1
.ae96					_CPRPrint:
.ae96	86 1e		stx $1e				stx 	zGenPtr
.ae98	85 1f		sta $1f				sta 	zGenPtr+1
.ae9a	5a		phy				phy
.ae9b	a0 00		ldy #$00			ldy 	#0							; get length into X
.ae9d	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.ae9f	aa		tax				tax
.aea0	f0 09		beq $aeab			beq 	_CPREndPrint 				; nothing to print
.aea2					_CPRLoop:
.aea2	c8		iny				iny
.aea3	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.aea5	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.aea8	ca		dex				dex
.aea9	d0 f7		bne $aea2			bne 	_CPRLoop
.aeab					_CPREndPrint:
.aeab	7a		ply				ply
.aeac	80 a1		bra $ae4f			bra 	Command_Print
.aeae					_CPR_Tab:
.aeae	20 5b a0	jsr $a05b			jsr 	IFT_Tab
.aeb1					_CPR_Skip:
.aeb1	c8		iny				iny
.aeb2	b1 16		lda ($16),y			lda 	(zCodePtr),y
.aeb4	c9 be		cmp #$be			cmp 	#token_Colon 				; colon or $00, exit
.aeb6	f0 09		beq $aec1			beq 	_CPR_Exit
.aeb8	c9 00		cmp #$00			cmp 	#0
.aeba	d0 93		bne $ae4f			bne 	Command_PRINT 				; if not go round again.
.aebc	80 03		bra $aec1			bra 	_CPR_Exit
.aebe					_CPR_NewLine:
.aebe	20 68 a0	jsr $a068			jsr 	IFT_NewLine
.aec1					_CPR_Exit:
.aec1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/assert.asm

.aec2					Command_ASSERT:
.aec2	20 8f b0	jsr $b08f			jsr 	EvaluateNumber 				; calculate thing being asserted
.aec5	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; check if true (non-zero)
.aec8	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.aecb	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.aece	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.aed1	f0 01		beq $aed4			beq 	_ASFail
.aed3	60		rts				rts
.aed4					_ASFail:
.aed4	20 44 ab	jsr $ab44			jsr ERR_Handler
>aed7	41 73 73 65 72 74 00			.text "Assert",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.aede					Command_CLR:
.aede					ResetRunStatus:
.aede	a9 00		lda #$00			lda 	#HighMemory & $FF
.aee0	8d 26 04	sta $0426			sta 	StringPtr
.aee3	a9 70		lda #$70			lda 	#HighMemory >> 8
.aee5	8d 27 04	sta $0427			sta 	StringPtr+1
.aee8	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/stop.asm

.aee9					Command_STOP:
.aee9	20 44 ab	jsr $ab44			jsr ERR_Handler
>aeec	53 74 6f 70 00				.text "Stop",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.aef1					EVESyntax:
.aef1	4c 15 ab	jmp $ab15			jmp 	SyntaxError
.aef4					EvaluateExpression:
.aef4	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.aef6					EvaluateExpressionX:
.aef6	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.aef8					EvaluateExpressionXA:
.aef8	48		pha				pha 								; save precedence on stack.
.aef9	b1 16		lda ($16),y			lda 	(zCodePtr),y
.aefb	f0 f4		beq $aef1			beq 	EVESyntax 					; end of line, syntax error.
.aefd	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.aeff	b0 03		bcs $af04			bcs 	_EVNotVariable
.af01	4c f8 af	jmp $aff8			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.af04					_EVNotVariable:
.af04	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.af06	90 e9		bcc $aef1			bcc 	EVESyntax
.af08	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.af0a	b0 7c		bcs $af88			bcs 	_EVNotInteger
.af0c	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.af0e	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.af11	a9 00		lda #$00			lda 	#0
.af13	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.af16	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.af19	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.af1c	1a		inc a				inc 	a 							; set to type 1 (integer)
.af1d	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.af20					_EVCheckNextInteger:
.af20	c8		iny				iny
.af21	b1 16		lda ($16),y			lda 	(zCodePtr),y
.af23	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.af25	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.af27	b0 0d		bcs $af36			bcs 	_EVCheckDecimal
.af29	48		pha				pha 								; save it.
.af2a	20 fc af	jsr $affc			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.af2d	68		pla				pla
.af2e	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.af31	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.af34	80 ea		bra $af20			bra 	_EVCheckNextInteger
.af36					_EVCheckDecimal:
.af36	b1 16		lda ($16),y			lda 	(zCodePtr),y
.af38	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.af3a	d0 05		bne $af41			bne 	_EVGotAtom 					; no, get atom.
.af3c					_EVIsDecimal:
.af3c	20 2c b0	jsr $b02c			jsr 	EVGetDecimal 				; extend to the decimal part.
.af3f	80 00		bra $af41			bra 	_EVGotAtom 					; and continue to got atom.
.af41					_EVGotAtom:
.af41	b1 16		lda ($16),y			lda 	(zCodePtr),y
.af43	10 41		bpl $af86			bpl 	_EVExitDrop 				; must be a token.
.af45	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.af47	b0 3d		bcs $af86			bcs 	_EVExitDrop
.af49	68		pla				pla 								; get current precedence
.af4a	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.af4c	da		phx				phx 								; save X
.af4d	b1 16		lda ($16),y			lda 	(zCodePtr),y
.af4f	aa		tax				tax 								; put in X
.af50	bd ee ab	lda $abee,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.af53	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.af55	fa		plx				plx 								; restore X
.af56	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.af58	90 2d		bcc $af87			bcc 	_EVExit 					; exit if too low.
.af5a	f0 2b		beq $af87			beq 	_EVExit 					; exit if equals
.af5c	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.af5e	48		pha				pha
.af5f	b1 16		lda ($16),y			lda 	(zCodePtr),y
.af61	48		pha				pha
.af62	c8		iny				iny
.af63	da		phx				phx 								; save current position
.af64	e8		inx				inx
.af65	e8		inx				inx
.af66	e8		inx				inx
.af67	e8		inx				inx
.af68	e8		inx				inx
.af69	e8		inx				inx
.af6a	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.af6c	20 f8 ae	jsr $aef8			jsr 	EvaluateExpressionXA 		; do the RHS.
.af6f	fa		plx				plx 								; restore X
.af70	68		pla				pla 								; get the binary operator in A.
.af71					_EVCallA:
.af71	da		phx				phx 								; save X again
.af72	0a		asl a				asl 	a 							; double, lose the MSB.
.af73	aa		tax				tax									; put in X
.af74	bd a7 ab	lda $aba7,x			lda 	VectorTable,x 				; copy address into zGenPtr
.af77	8d 05 03	sta $0305			sta 	LocalVector+1
.af7a	bd a8 ab	lda $aba8,x			lda 	VectorTable+1,x
.af7d	8d 06 03	sta $0306			sta 	LocalVector+2
.af80	fa		plx				plx 								; restore X
.af81	20 f9 af	jsr $aff9			jsr 	EVCallLocalVector
.af84	80 bb		bra $af41			bra 	_EVGotAtom 					; and loop back.
.af86					_EVExitDrop:
.af86	68		pla				pla
.af87					_EVExit:
.af87	60		rts				rts
.af88					_EVNotInteger:
.af88	c8		iny				iny
.af89	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.af8b	d0 19		bne $afa6			bne 	_EVNotMinus
.af8d	20 7d b0	jsr $b07d			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.af90	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.af93	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.af95	f0 05		beq $af9c			beq 	_EVMinusFloat
.af97	20 7e b8	jsr $b87e			jsr 	IntegerNegateAlways 		; negation
.af9a	80 a5		bra $af41			bra 	_EVGotAtom 					; and go back.
.af9c					_EVMinusFloat:
.af9c	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; invert the sign bit.
.af9f	49 80		eor #$80			eor 	#$80
.afa1	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.afa4	80 9b		bra $af41			bra 	_EVGotAtom
.afa6					_EVNotMinus:
.afa6	c9 bb		cmp #$bb			cmp 	#token_lparen 				; is it left parenthesis
.afa8	d0 17		bne $afc1			bne 	_EVNotParenthesis
.afaa	20 f6 ae	jsr $aef6			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.afad	b1 16		lda ($16),y			lda 	(zCodePtr),y
.afaf	c8		iny				iny
.afb0	c9 bc		cmp #$bc			cmp 	#token_rparen 				; okay if right bracket.
.afb2	f0 8d		beq $af41			beq 	_EVGotAtom
.afb4	20 44 ab	jsr $ab44			jsr ERR_Handler
>afb7	4d 69 73 73 69 6e 67 20			.text "Missing )",0
>afbf	29 00
.afc1					_EVNotParenthesis:
.afc1	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.afc3	d0 0c		bne $afd1			bne 	_EVNotNot
.afc5	20 7d b0	jsr $b07d			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.afc8	20 88 bd	jsr $bd88			jsr 	FPUToInteger 				; make it an integer - if possible.
.afcb	20 5a b0	jsr $b05a			jsr 	NotInteger 					; do the not calculation
.afce	4c 41 af	jmp $af41			jmp 	_EVGotAtom
.afd1					_EVNotNot:
.afd1	c9 fe		cmp #$fe			cmp 	#$FE
.afd3	d0 15		bne $afea			bne 	_EVNotString
.afd5	20 6b b7	jsr $b76b			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.afd8	a5 20		lda $20				lda 	zTempStr 					; copy address of string into mantissa
.afda	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.afdd	a5 21		lda $21				lda 	zTempStr+1
.afdf	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.afe2	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.afe4	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.afe7	4c 41 af	jmp $af41			jmp 	_EVGotAtom
.afea					_EVNotString:
.afea	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.afec	90 04		bcc $aff2			bcc 	_EVBadElement
.afee	c9 b5		cmp #$b5			cmp 	#lastUnaryFunction+1
.aff0	90 03		bcc $aff5			bcc 	_EVUnaryFunction
.aff2					_EVBadElement:
.aff2	4c 15 ab	jmp $ab15			jmp 	SyntaxError
.aff5					_EVUnaryFunction:
.aff5	4c 71 af	jmp $af71			jmp 	_EVCallA
.aff8					_EVVariableHandler:
.aff8	ea		nop				nop
.aff9					EVCallLocalVector:
.aff9	6c 05 03	jmp ($0305)			jmp 	(LocalVector+1)
.affc					EVShiftMantissaLeft6:
.affc	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.afff	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.b002	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.b005	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b008	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b00b	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b00e	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b011	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b014	a9 00		lda #$00			lda 	#0
.b016	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b019	20 1c b0	jsr $b01c			jsr 	_EVSMLShift 					; call it here to do it twice
.b01c					_EVSMLShift:
.b01c	5e 0c 03	lsr $030c,x			lsr 	XS_Exponent,x
.b01f	7e 0b 03	ror $030b,x			ror 	XS_Mantissa+3,x
.b022	7e 0a 03	ror $030a,x			ror 	XS_Mantissa+2,x
.b025	7e 09 03	ror $0309,x			ror 	XS_Mantissa+1,x
.b028	7e 08 03	ror $0308,x			ror 	XS_Mantissa+0,x
.b02b	60		rts				rts
.b02c					EVGetDecimal:
.b02c	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.b02e	8d 01 04	sta $0401			sta 	Num_Buffer
.b031	da		phx				phx
.b032	c8		iny				iny
.b033	b1 16		lda ($16),y			lda 	(zCodePtr),y
.b035	c8		iny				iny
.b036	3a		dec a				dec 	a								; convert to a string length.
.b037	3a		dec a				dec 	a
.b038	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.b03a					_EVGDCopy:
.b03a	48		pha				pha 									; save count
.b03b	b1 16		lda ($16),y			lda 	(zCodePtr),y
.b03d	9d 01 04	sta $0401,x			sta 	Num_Buffer,x
.b040	e8		inx				inx 									; forward ....
.b041	c8		iny				iny
.b042	68		pla				pla 									; get count
.b043	3a		dec a				dec 	a 								; until zero
.b044	d0 f4		bne $b03a			bne 	_EVGDCopy
.b046	9d 01 04	sta $0401,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.b049	fa		plx				plx 									; restore X
.b04a	a9 01		lda #$01			lda 	#Num_Buffer & $FF 				; set zGenPtr
.b04c	85 1e		sta $1e				sta 	zGenPtr
.b04e	a9 04		lda #$04			lda 	#Num_Buffer >> 8
.b050	85 1f		sta $1f				sta 	zGenPtr+1
.b052	5a		phy				phy 									; save Y
.b053	a0 00		ldy #$00			ldy 	#0 								; start position
.b055	20 7a bf	jsr $bf7a			jsr 	FPFromString 					; convert current
.b058	7a		ply				ply 									; restore Y
.b059	60		rts				rts
.b05a					NotInteger:
.b05a	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b05d	49 ff		eor #$ff			eor 	#$FF
.b05f	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b062	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b065	49 ff		eor #$ff			eor 	#$FF
.b067	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b06a	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.b06d	49 ff		eor #$ff			eor 	#$FF
.b06f	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b072	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.b075	49 ff		eor #$ff			eor 	#$FF
.b077	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b07a	60		rts				rts
.b07b					EvaluateGetAtom:
.b07b	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.b07d					EvaluateGetAtomX:
.b07d	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.b07f	20 f8 ae	jsr $aef8			jsr 	EvaluateExpressionXA
.b082	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.b085	29 0f		and #$0f			and 	#15
.b087	c9 02		cmp #$02			cmp 	#2
.b089	b0 01		bcs $b08c			bcs 	EvaluateType
.b08b	60		rts				rts
.b08c					EvaluateType:
.b08c	4c 25 ab	jmp $ab25			jmp 	TypeError
.b08f					EvaluateNumber:
.b08f	a2 00		ldx #$00			ldx 	#0
.b091					EvaluateNumberX:
.b091	20 f6 ae	jsr $aef6			jsr 	EvaluateExpressionX
.b094	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 0/1
.b097	29 0f		and #$0f			and 	#15
.b099	c9 02		cmp #$02			cmp 	#2
.b09b	b0 ef		bcs $b08c			bcs 	EvaluateType
.b09d	60		rts				rts
.b09e					EvaluateInteger:
.b09e	a2 00		ldx #$00			ldx 	#0
.b0a0					EvaluateIntegerX:
.b0a0	20 91 b0	jsr $b091			jsr 	EvaluateNumberX
.b0a3	20 88 bd	jsr $bd88			jsr 	FPUToInteger
.b0a6	60		rts				rts
.b0a7					EvaluateString:
.b0a7	a2 00		ldx #$00			ldx 	#0
.b0a9					EvaluateStringX:
.b0a9	20 f6 ae	jsr $aef6			jsr 	EvaluateExpressionX
.b0ac	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 2
.b0af	29 0f		and #$0f			and 	#15
.b0b1	c9 02		cmp #$02			cmp 	#2
.b0b3	d0 d7		bne $b08c			bne 	EvaluateType
.b0b5	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.b0b8	85 1e		sta $1e				sta 	zGenPtr
.b0ba	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b0bd	85 1f		sta $1f				sta 	zGenPtr+1
.b0bf	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.b0c0					BinaryOp_And:
.b0c0	20 38 b1	jsr $b138			jsr 	BinaryMakeBothInteger
.b0c3	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.b0c6	3d 0e 03	and $030e,x			and 	XS2_Mantissa+0,x
.b0c9	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b0cc	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.b0cf	3d 0f 03	and $030f,x			and 	XS2_Mantissa+1,x
.b0d2	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b0d5	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.b0d8	3d 10 03	and $0310,x			and 	XS2_Mantissa+2,x
.b0db	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b0de	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.b0e1	3d 11 03	and $0311,x			and 	XS2_Mantissa+3,x
.b0e4	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b0e7	60		rts				rts
.b0e8					BinaryOp_Or:
.b0e8	20 38 b1	jsr $b138			jsr 	BinaryMakeBothInteger
.b0eb	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.b0ee	1d 0e 03	ora $030e,x			ora 	XS2_Mantissa+0,x
.b0f1	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b0f4	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.b0f7	1d 0f 03	ora $030f,x			ora 	XS2_Mantissa+1,x
.b0fa	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b0fd	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.b100	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.b103	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b106	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.b109	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.b10c	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b10f	60		rts				rts
.b110					BinaryOp_Eor:
.b110					BinaryOp_Xor:
.b110	20 38 b1	jsr $b138			jsr 	BinaryMakeBothInteger
.b113	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.b116	5d 0e 03	eor $030e,x			eor 	XS2_Mantissa+0,x
.b119	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b11c	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.b11f	5d 0f 03	eor $030f,x			eor 	XS2_Mantissa+1,x
.b122	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b125	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.b128	5d 10 03	eor $0310,x			eor 	XS2_Mantissa+2,x
.b12b	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b12e	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.b131	5d 11 03	eor $0311,x			eor 	XS2_Mantissa+3,x
.b134	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b137	60		rts				rts
.b138					BinaryMakeBothInteger:
.b138	da		phx				phx 								; save X
.b139	e8		inx				inx
.b13a	e8		inx				inx
.b13b	e8		inx				inx
.b13c	e8		inx				inx
.b13d	e8		inx				inx
.b13e	e8		inx				inx
.b13f	20 43 b1	jsr $b143			jsr 	BinaryMakeInteger 			; convert to integer.
.b142	fa		plx				plx 								; restore X and fall through.
.b143					BinaryMakeInteger:
.b143	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type byte.
.b146	29 0f		and #$0f			and 	#15 						; check type zero
.b148	f0 04		beq $b14e			beq 	_BMIConvert 				; if float convert to integer.
.b14a	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.b14b	90 04		bcc $b151			bcc 	_BMIError
.b14d	60		rts				rts
.b14e					_BMIConvert:
.b14e	4c 88 bd	jmp $bd88			jmp 	FPUToInteger 				; convert to integer
.b151					_BMIError:
.b151	4c 25 ab	jmp $ab25			jmp 	TypeError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.b154					Binary_Equal:
.b154	20 a0 b1	jsr $b1a0			jsr 	CompareValues
.b157	09 00		ora #$00			ora 	#0
.b159	f0 04		beq $b15f			beq 	CCTrue
.b15b	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.b15d	80 02		bra $b161			bra 	CCWrite
.b15f	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.b161	9d 08 03	sta $0308,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.b164	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b167	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b16a	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b16d	a9 01		lda #$01			lda 	#1
.b16f	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; set type to integer whatever.
.b172	60		rts				rts
.b173					Binary_NotEqual:
.b173	20 a0 b1	jsr $b1a0			jsr 	CompareValues
.b176	09 00		ora #$00			ora 	#0
.b178	f0 e1		beq $b15b			beq 	CCFalse
.b17a	80 e3		bra $b15f			bra 	CCTrue
.b17c					Binary_Less:
.b17c	20 a0 b1	jsr $b1a0			jsr 	CompareValues
.b17f	09 00		ora #$00			ora 	#0
.b181	30 dc		bmi $b15f			bmi 	CCTrue
.b183	80 d6		bra $b15b			bra 	CCFalse
.b185					Binary_LessEqual:
.b185	20 a0 b1	jsr $b1a0			jsr 	CompareValues
.b188	c9 01		cmp #$01			cmp 	#1
.b18a	d0 d3		bne $b15f			bne 	CCTrue
.b18c	80 cd		bra $b15b			bra 	CCFalse
.b18e					Binary_GreaterEqual:
.b18e	20 a0 b1	jsr $b1a0			jsr 	CompareValues
.b191	09 00		ora #$00			ora 	#0
.b193	10 ca		bpl $b15f			bpl 	CCTrue
.b195	80 c4		bra $b15b			bra 	CCFalse
.b197					Binary_Greater:
.b197	20 a0 b1	jsr $b1a0			jsr 	CompareValues
.b19a	c9 01		cmp #$01			cmp 	#1
.b19c	f0 c1		beq $b15f			beq 	CCTrue
.b19e	80 bb		bra $b15b			bra 	CCFalse
.b1a0					CompareValues:
.b1a0	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and the types together
.b1a3	3d 13 03	and $0313,x			and 	XS2_Type,x
.b1a6	c9 02		cmp #$02			cmp 	#2
.b1a8	f0 13		beq $b1bd			beq 	_CVString
.b1aa	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b1ad	3d 13 03	and $0313,x			and 	XS2_Type,x
.b1b0	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b1b1	90 03		bcc $b1b6			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b1b3	4c 03 b2	jmp $b203			jmp 	CompareInteger32 							; so execute code at \1
.b1b6					_BCFloat:
.b1b6	20 d1 b2	jsr $b2d1			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b1b9	4c 97 bc	jmp $bc97			jmp 	FPCompare 							; and execute code at \2
.b1bc	60		rts				rts
.b1bd					_CVString:
.b1bd	da		phx				phx 								; save XY
.b1be	5a		phy				phy
.b1bf	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.b1c2	85 1a		sta $1a				sta		zLTemp1+0
.b1c4	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b1c7	85 1b		sta $1b				sta 	zLTemp1+1
.b1c9	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x
.b1cc	85 1c		sta $1c				sta 	zLTemp1+2
.b1ce	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.b1d1	85 1d		sta $1d				sta 	zLTemp1+3
.b1d3	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.b1d5	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b1d7	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.b1d9	90 02		bcc $b1dd			bcc 	_CVCommon
.b1db	b1 1c		lda ($1c),y			lda 	(zLTemp1+2),y
.b1dd					_CVCommon:
.b1dd	aa		tax				tax 								; put shorter string length in zero.
.b1de	f0 0c		beq $b1ec			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.b1e0					_CVCompare:
.b1e0	c8		iny				iny 								; next character
.b1e1	b1 1a		lda ($1a),y			lda 	(zLTemp1),y 				; compare characters
.b1e3	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.b1e5	90 13		bcc $b1fa			bcc 	_CVReturnLess 				; <
.b1e7	d0 15		bne $b1fe			bne 	_CVReturnGreater 			; >
.b1e9	ca		dex				dex 								; until common length matched.
.b1ea	d0 f4		bne $b1e0			bne 	_CVCompare
.b1ec					_CVMatch:
.b1ec	a0 00		ldy #$00			ldy 	#0
.b1ee	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b1f0	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.b1f2	90 06		bcc $b1fa			bcc 	_CVReturnLess 				; <
.b1f4	d0 08		bne $b1fe			bne 	_CVReturnGreater 			; >
.b1f6	a9 00		lda #$00			lda 	#0
.b1f8	80 06		bra $b200			bra 	_CVExit 					; same common, same length, same string
.b1fa					_CVReturnLess:
.b1fa	a9 ff		lda #$ff			lda 	#$FF
.b1fc	80 02		bra $b200			bra 	_CVExit
.b1fe					_CVReturnGreater:
.b1fe	a9 01		lda #$01			lda 	#$01
.b200					_CVExit:
.b200	7a		ply				ply
.b201	fa		plx				plx
.b202	60		rts				rts
.b203					CompareInteger32:
.b203	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.b206	49 80		eor #$80			eor 	#$80
.b208	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b20b	bd 11 03	lda $0311,x			lda 	XS2_Mantissa+3,x
.b20e	49 80		eor #$80			eor 	#$80
.b210	9d 11 03	sta $0311,x			sta 	XS2_Mantissa+3,x
.b213	20 ab b2	jsr $b2ab			jsr 	SubInteger32 				; subtraction
.b216	90 11		bcc $b229			bcc 	_CI32Less 					; cc return -1
.b218	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; check if zero
.b21b	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.b21e	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.b221	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.b224	f0 02		beq $b228			beq 	_CI32Exit
.b226	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.b228					_CI32Exit:
.b228	60		rts				rts
.b229					_CI32Less:
.b229	a9 ff		lda #$ff			lda 	#$FF
.b22b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.b22c					BinaryOp_Add:
.b22c	bd 0d 03	lda $030d,x			lda 	XS_Type,x  					; and types together
.b22f	3d 13 03	and $0313,x			and 	XS2_Type,x
.b232	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.b234	d0 13		bne $b249			bne 	_BOAString
.b236	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b239	3d 13 03	and $0313,x			and 	XS2_Type,x
.b23c	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b23d	90 03		bcc $b242			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b23f	4c 85 b2	jmp $b285			jmp 	AddInteger32 							; so execute code at \1
.b242					_BCFloat:
.b242	20 d1 b2	jsr $b2d1			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b245	4c 0b ba	jmp $ba0b			jmp 	FPAdd 							; and execute code at \2
.b248	60		rts				rts
.b249					_BOAString:
.b249	4c ec b2	jmp $b2ec			jmp 	ConcatenateString 			; concatenate two strings.
.b24c					BinaryOp_Subtract:
.b24c	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b24f	3d 13 03	and $0313,x			and 	XS2_Type,x
.b252	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b253	90 03		bcc $b258			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b255	4c ab b2	jmp $b2ab			jmp 	SubInteger32 							; so execute code at \1
.b258					_BCFloat:
.b258	20 d1 b2	jsr $b2d1			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b25b	4c 01 ba	jmp $ba01			jmp 	FPSubtract 							; and execute code at \2
.b25e	60		rts				rts
.b25f					BinaryOp_Multiply:
.b25f	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b262	3d 13 03	and $0313,x			and 	XS2_Type,x
.b265	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b266	90 03		bcc $b26b			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b268	4c 91 b7	jmp $b791			jmp 	MulInteger32 							; so execute code at \1
.b26b					_BCFloat:
.b26b	20 d1 b2	jsr $b2d1			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b26e	4c 77 bb	jmp $bb77			jmp 	FPMultiply 							; and execute code at \2
.b271	60		rts				rts
.b272					BinaryOp_Divide:
.b272	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b275	3d 13 03	and $0313,x			and 	XS2_Type,x
.b278	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b279	90 03		bcc $b27e			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b27b	4c e8 b7	jmp $b7e8			jmp 	DivInteger32 							; so execute code at \1
.b27e					_BCFloat:
.b27e	20 d1 b2	jsr $b2d1			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b281	4c ef ba	jmp $baef			jmp 	FPDivide 							; and execute code at \2
.b284	60		rts				rts
.b285					AddInteger32:
.b285	18		clc				clc
.b286	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b289	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.b28c	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b28f	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b292	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.b295	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b298	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.b29b	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.b29e	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b2a1	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.b2a4	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.b2a7	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b2aa	60		rts				rts
.b2ab					SubInteger32:
.b2ab	38		sec				sec
.b2ac	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b2af	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.b2b2	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b2b5	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b2b8	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.b2bb	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b2be	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.b2c1	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.b2c4	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b2c7	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.b2ca	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.b2cd	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b2d0	60		rts				rts
.b2d1					BinaryMakeBothFloat:
.b2d1	da		phx				phx 								; save X
.b2d2	e8		inx				inx
.b2d3	e8		inx				inx
.b2d4	e8		inx				inx
.b2d5	e8		inx				inx
.b2d6	e8		inx				inx
.b2d7	e8		inx				inx
.b2d8	20 dc b2	jsr $b2dc			jsr 	BinaryMakeFloat 			; convert to float.
.b2db	fa		plx				plx 								; restore X and fall through.
.b2dc					BinaryMakeFloat:
.b2dc	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type byte.
.b2df	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.b2e0	b0 04		bcs $b2e6			bcs 	_BMFConvert
.b2e2	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.b2e3	b0 04		bcs $b2e9			bcs 	_BMFError
.b2e5	60		rts				rts
.b2e6					_BMFConvert:
.b2e6	4c 29 bd	jmp $bd29			jmp 	FPUToFloat 					; convert to float
.b2e9					_BMFError:
.b2e9	4c 25 ab	jmp $ab25			jmp 	TypeError
.b2ec					ConcatenateString:
.b2ec	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.b2ef	85 1a		sta $1a				sta		zLTemp1+0
.b2f1	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b2f4	85 1b		sta $1b				sta 	zLTemp1+1
.b2f6	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x
.b2f9	85 1c		sta $1c				sta 	zLTemp1+2
.b2fb	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.b2fe	85 1d		sta $1d				sta 	zLTemp1+3
.b300	5a		phy				phy
.b301	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.b303	b1 1a		lda ($1a),y			lda 	(zlTemp1),y
.b305	71 1c		adc ($1c),y			adc 	(zlTemp1+2),y
.b307	7a		ply				ply
.b308	b0 37		bcs $b341			bcs 	_CSError					; check in range.
.b30a	c9 fe		cmp #$fe			cmp 	#maxString+1
.b30c	b0 33		bcs $b341			bcs 	_CSError
.b30e	20 30 b7	jsr $b730			jsr 	AllocateTempString 			; store the result
.b311	20 2c b3	jsr $b32c			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.b314	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.b317	85 1a		sta $1a				sta 	zLTemp1
.b319	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.b31c	85 1b		sta $1b				sta 	zLTemp1+1
.b31e	20 2c b3	jsr $b32c			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.b321	a5 20		lda $20				lda 	zTempStr 					; point current to new string
.b323	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b326	a5 21		lda $21				lda 	zTempStr+1
.b328	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b32b	60		rts				rts
.b32c					_CSCopyString:
.b32c	da		phx				phx
.b32d	5a		phy				phy
.b32e	a0 00		ldy #$00			ldy 	#0 							; get length
.b330	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b332	f0 0a		beq $b33e			beq 	_CSCSExit 					; if zero, exit
.b334	aa		tax				tax 								; put in X
.b335					_CSCSLoop:
.b335	c8		iny				iny 								; get next char
.b336	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b338	20 5b b7	jsr $b75b			jsr		WriteTempString 			; copy out
.b33b	ca		dex				dex 								; do whole string
.b33c	d0 f7		bne $b335			bne 	_CSCSLoop
.b33e					_CSCSExit:
.b33e	7a		ply				ply
.b33f	fa		plx				plx
.b340	60		rts				rts
.b341					_CSError:
.b341	20 44 ab	jsr $ab44			jsr ERR_Handler
>b344	53 74 72 69 6e 67 20 74			.text "String too long",0
>b34c	6f 6f 20 6c 6f 6e 67 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.b354					Unary_Sgn:
.b354	20 91 b0	jsr $b091			jsr 	EvaluateNumberX 			; get value
.b357	20 20 b7	jsr $b720			jsr 	CheckNextRParen 			; check right bracket.
.b35a	20 7e b3	jsr $b37e			jsr 	GetSignCurrent 				; get sign.
.b35d	09 00		ora #$00			ora 	#0
.b35f	10 09		bpl $b36a			bpl		UnarySetAInteger			; if 0,1 return that.
.b361	80 00		bra $b363			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.b363					UnarySetAMinus1:
.b363	a9 ff		lda #$ff			lda 	#$FF
.b365	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.b368	80 05		bra $b36f			bra 	UnarySetAFill
.b36a					UnarySetAInteger:
.b36a	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.b36d	a9 00		lda #$00			lda 	#0
.b36f					UnarySetAFill:
.b36f	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b372	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b375	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b378	a9 01		lda #$01			lda 	#1
.b37a	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.b37d	60		rts				rts
.b37e					GetSignCurrent:
.b37e	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; identify type.
.b381	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.b382	90 19		bcc $b39d			bcc 	_GSCFloat
.b384	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.b387	30 11		bmi $b39a			bmi 	_GSCMinus1
.b389	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x
.b38c	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.b38f	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.b392	d0 03		bne $b397			bne 	_GSCPlus1
.b394					_GSCZero:
.b394	a9 00		lda #$00			lda 	#0
.b396	60		rts				rts
.b397					_GSCPlus1:
.b397	a9 01		lda #$01			lda 	#$01
.b399	60		rts				rts
.b39a					_GSCMinus1:
.b39a	a9 ff		lda #$ff			lda 	#$FF
.b39c	60		rts				rts
.b39d					_GSCFloat:
.b39d	3c 0d 03	bit $030d,x			bit 	XS_Type,x
.b3a0	70 f2		bvs $b394			bvs 	_GSCZero
.b3a2	30 f6		bmi $b39a			bmi 	_GSCMinus1
.b3a4	80 f1		bra $b397			bra 	_GSCPlus1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.b3a6					Unary_Abs:
.b3a6	20 91 b0	jsr $b091			jsr 	EvaluateNumberX 			; get value
.b3a9	20 20 b7	jsr $b720			jsr 	CheckNextRParen 			; check right bracket.
.b3ac	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.b3af	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.b3b1	f0 08		beq $b3bb			beq 	_UAMinusFloat
.b3b3	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; check MSB
.b3b6	10 0b		bpl $b3c3			bpl 	_UAExit
.b3b8	4c 7e b8	jmp $b87e			jmp 	IntegerNegateAlways 		; negation
.b3bb					_UAMinusFloat:
.b3bb	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; clear the sign bit.
.b3be	29 7f		and #$7f			and		#$7F
.b3c0	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.b3c3					_UAExit:
.b3c3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.b3c4					Unary_Peek:
.b3c4	a9 01		lda #$01			lda 	#1
.b3c6	80 06		bra $b3ce			bra 	UPMain
.b3c8					Unary_Deek:
.b3c8	a9 02		lda #$02			lda 	#2
.b3ca	80 02		bra $b3ce			bra 	UPMain
.b3cc					Unary_Leek:
.b3cc	a9 04		lda #$04			lda 	#4
.b3ce					UPMain:
.b3ce	48		pha				pha 								; set bytes to copy.
.b3cf	20 a0 b0	jsr $b0a0			jsr 	EvaluateIntegerX 			; numeric parameter
.b3d2	20 20 b7	jsr $b720			jsr 	CheckNextRParen 			; right bracket.
.b3d5	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.b3d8	85 1a		sta $1a				sta 	zLTemp1
.b3da	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b3dd	85 1b		sta $1b				sta 	zLTemp1+1
.b3df	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.b3e2	85 1c		sta $1c				sta 	zLTemp1+2
.b3e4	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.b3e7	85 1d		sta $1d				sta 	zLTemp1+3
.b3e9	a9 00		lda #$00			lda 	#0 							; clear target area
.b3eb	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b3ee	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b3f1	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b3f4	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b3f7	68		pla				pla 								; restore bytes to copy
.b3f8	da		phx				phx 								; save XY
.b3f9	5a		phy				phy
.b3fa	20 f6 b6	jsr $b6f6			jsr 	MemRead 					; read the bytes in
.b3fd	7a		ply				ply 								; restore and exit
.b3fe	fa		plx				plx
.b3ff	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.b400					Unary_Mod:
.b400	20 2c b4	jsr $b42c			jsr 	_UMParameter 				; first parameter
.b403	20 28 b7	jsr $b728			jsr 	CheckNextComma
.b406	da		phx				phx 								; second parameter
.b407	e8		inx				inx
.b408	e8		inx				inx
.b409	e8		inx				inx
.b40a	e8		inx				inx
.b40b	e8		inx				inx
.b40c	e8		inx				inx
.b40d	20 2c b4	jsr $b42c			jsr 	_UMParameter
.b410	fa		plx				plx
.b411	20 20 b7	jsr $b720			jsr 	CheckNextRParen
.b414	20 e8 b7	jsr $b7e8			jsr 	DivInteger32 				; divide
.b417	a5 1a		lda $1a				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.b419	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b41c	a5 1b		lda $1b				lda 	zLTemp1+1
.b41e	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b421	a5 1c		lda $1c				lda 	zLTemp1+2
.b423	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b426	a5 1d		lda $1d				lda 	zLTemp1+3
.b428	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b42b	60		rts				rts
.b42c					_UMParameter:
.b42c	20 a0 b0	jsr $b0a0			jsr 	EvaluateIntegerX 			; get value
.b42f	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; absolute value
.b432	10 03		bpl $b437			bpl 	_UMNotSigned
.b434	20 7e b8	jsr $b87e			jsr 	IntegerNegateAlways
.b437					_UMNotSigned:
.b437	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.b438					Unary_Usr:
.b438	20 91 b0	jsr $b091			jsr 	EvaluateNumberX 			; numeric parameter
.b43b	20 20 b7	jsr $b720			jsr 	CheckNextRParen 			; right bracket.
.b43e	da		phx				phx 								; save XY
.b43f	5a		phy				phy
.b440	ea		nop				nop
.b441	20 00 03	jsr $0300			jsr 	UserVector 					; call the USR function.
.b444	7a		ply				ply 								; and exit
.b445	fa		plx				plx
.b446	60		rts				rts
.b447					USRDefault:
.b447	20 44 ab	jsr $ab44			jsr ERR_Handler
>b44a	4e 6f 20 55 53 52 20 76			.text "No USR vector.",0
>b452	65 63 74 6f 72 2e 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.b459					Unary_Val:
.b459	20 a9 b0	jsr $b0a9			jsr 	EvaluateStringX 			; get string
.b45c	20 20 b7	jsr $b720			jsr 	CheckNextRParen 			; check right bracket.
.b45f	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.b462	85 1e		sta $1e				sta 	zGenPtr
.b464	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b467	85 1f		sta $1f				sta 	zGenPtr+1
.b469	5a		phy				phy
.b46a	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.b46c	b1 1e		lda ($1e),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.b46e	f0 57		beq $b4c7			beq 	_UVBadNumber
.b470	48		pha				pha 								; save length.
.b471	1a		inc a				inc 	a 							; one for the length, one for the terminator
.b472	1a		inc a				inc 	a
.b473	20 30 b7	jsr $b730			jsr 	AllocateTempString
.b476	c8		iny				iny 								; move to the next.
.b477	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get character
.b479	49 2d		eor #$2d			eor 	#"-"						; zero if minus sign
.b47b	8d 29 04	sta $0429			sta 	ValSign
.b47e	d0 04		bne $b484			bne 	_UVNotMinus
.b480	c8		iny				iny 								; skip over it.
.b481	68		pla				pla 								; decrement character count.
.b482	3a		dec a				dec 	a
.b483	48		pha				pha
.b484					_UVNotMinus:
.b484	68		pla				pla 								; this is the count.
.b485	48		pha		_UVCopy:pha									; copy into new temp string which is ASCIIZ
.b486	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b488	c8		iny				iny
.b489	20 5b b7	jsr $b75b			jsr 	WriteTempString
.b48c	68		pla				pla
.b48d	3a		dec a				dec 	a
.b48e	d0 f5		bne $b485			bne 	_UVCopy
.b490	20 5b b7	jsr $b75b			jsr 	WriteTempString 			; make it ASCIIZ
.b493	18		clc				clc
.b494	a5 20		lda $20				lda 	zTempStr 					; tempstring +1 => genptr
.b496	69 01		adc #$01			adc 	#1
.b498	85 1e		sta $1e				sta 	zGenPtr
.b49a	a5 21		lda $21				lda 	zTempStr+1
.b49c	69 00		adc #$00			adc 	#0
.b49e	85 1f		sta $1f				sta 	zGenPtr+1
.b4a0	18		clc				clc
.b4a1	20 56 b9	jsr $b956			jsr 	IntFromString 				; first bit.
.b4a4	b0 21		bcs $b4c7			bcs 	_UVBadNumber
.b4a6	20 7a bf	jsr $bf7a			jsr 	FPFromString				; try for a float part.
.b4a9	ad 29 04	lda $0429			lda 	ValSign 					; was it negative
.b4ac	d0 13		bne $b4c1			bne 	_UVNotNegative
.b4ae	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; check if integer
.b4b1	4a		lsr a				lsr 	a
.b4b2	b0 0a		bcs $b4be			bcs 	_UVInteger
.b4b4	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; set sign bit
.b4b7	09 80		ora #$80			ora 	#$80
.b4b9	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.b4bc	80 03		bra $b4c1			bra 	_UVNotNegative
.b4be					_UVInteger:
.b4be	20 7e b8	jsr $b87e			jsr 	IntegerNegateAlways 		; sign it.
.b4c1					_UVNotNegative:
.b4c1	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; used everything
.b4c3	d0 02		bne $b4c7			bne 	_UVBadNumber
.b4c5	7a		ply				ply
.b4c6	60		rts				rts
.b4c7					_UVBadNumber:
.b4c7	4c 33 ab	jmp $ab33			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.b4ca					Unary_Str:
.b4ca	20 91 b0	jsr $b091			jsr 	EvaluateNumberX 			; numeric parameter
.b4cd	20 20 b7	jsr $b720			jsr 	CheckNextRParen 			; right bracket.
.b4d0	a9 00		lda #$00			lda 	#0 							; reset buffer index
.b4d2	8d 00 04	sta $0400			sta 	NumBufX
.b4d5	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.b4d8	4a		lsr a				lsr 	a
.b4d9	b0 05		bcs $b4e0			bcs 	_USInt 						; if msb set do as integer
.b4db	20 b3 be	jsr $beb3			jsr 	FPToString 					; call fp to str otherwise
.b4de	80 03		bra $b4e3			bra 	_USDuplicate
.b4e0	20 a3 b8	jsr $b8a3	_USInt:	jsr 	IntToString
.b4e3					_USDuplicate:
.b4e3	ad 00 04	lda $0400			lda 	NumBufX 					; chars in buffer
.b4e6	1a		inc a				inc 	a 							; one more for length
.b4e7	20 30 b7	jsr $b730			jsr 	AllocateTempString 			; allocate space for it.
.b4ea	5a		phy				phy 								; save Y
.b4eb	a0 00		ldy #$00			ldy 	#0 							; start copying
.b4ed	b9 01 04	lda $0401,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.b4f0	20 5b b7	jsr $b75b			jsr 	WriteTempString
.b4f3	c8		iny				iny
.b4f4	cc 00 04	cpy $0400			cpy 	NumBufX 					; done the lot
.b4f7	d0 f4		bne $b4ed			bne 	_USCopy
.b4f9	7a		ply				ply 								; restore Y
.b4fa	4c e6 b6	jmp $b6e6			jmp 	UnaryReturnTempStr 			; return new temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.b4fd					Unary_Asc:
.b4fd	20 a9 b0	jsr $b0a9			jsr 	EvaluateStringX 			; string parameter
.b500	20 20 b7	jsr $b720			jsr 	CheckNextRParen 			; right bracket.
.b503	5a		phy				phy 								; get the string length
.b504	a0 00		ldy #$00			ldy 	#0
.b506	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b508	f0 07		beq $b511			beq 	_UAIllegal 					; must be at least one character
.b50a	c8		iny				iny
.b50b	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; read it.
.b50d	7a		ply				ply
.b50e	4c 6a b3	jmp $b36a			jmp 	UnarySetAInteger
.b511					_UAIllegal:
.b511	4c 33 ab	jmp $ab33			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.b514					Unary_Len:
.b514	20 a9 b0	jsr $b0a9			jsr 	EvaluateStringX 			; string parameter
.b517	20 20 b7	jsr $b720			jsr 	CheckNextRParen 			; right bracket.
.b51a	5a		phy				phy 								; get the string length
.b51b	a0 00		ldy #$00			ldy 	#0
.b51d	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b51f	7a		ply				ply
.b520	4c 6a b3	jmp $b36a			jmp 	UnarySetAInteger

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.b523					Unary_Mid:
.b523	20 a9 b0	jsr $b0a9			jsr 	EvaluateStringX 				; get string.
.b526	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.b529	48		pha				pha
.b52a	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b52d	48		pha				pha
.b52e	20 28 b7	jsr $b728			jsr 	CheckNextComma 					; skip comma
.b531	20 be b5	jsr $b5be			jsr 	SLIByteParameter 				; get a byte parameter (start)
.b534	48		pha				pha 									; and push it.
.b535	20 28 b7	jsr $b728			jsr 	CheckNextComma 					; skip comma
.b538	20 be b5	jsr $b5be			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.b53b	48		pha				pha 									; and push it.
.b53c	80 45		bra $b583			bra 	SLIProcess
.b53e					Unary_Left:
.b53e	20 a9 b0	jsr $b0a9			jsr 	EvaluateStringX 				; get string.
.b541	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.b544	48		pha				pha
.b545	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b548	48		pha				pha
.b549	a9 01		lda #$01			lda 	#1 								; push start position (1)
.b54b	48		pha				pha
.b54c	20 28 b7	jsr $b728			jsr 	CheckNextComma 					; skip comma
.b54f	20 be b5	jsr $b5be			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.b552	48		pha				pha 									; and push it.
.b553	80 2e		bra $b583			bra 	SLIProcess
.b555					Unary_Right:
.b555	20 a9 b0	jsr $b0a9			jsr 	EvaluateStringX 				; get string.
.b558	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.b55b	48		pha				pha
.b55c	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b55f	48		pha				pha
.b560	da		phx				phx 									; get the string length and push on stack.
.b561	a2 00		ldx #$00			ldx 	#0
.b563	a1 1e		lda ($1e,x)			lda		(zGenPtr,x)
.b565	fa		plx				plx
.b566	48		pha				pha
.b567	20 28 b7	jsr $b728			jsr 	CheckNextComma 					; skip comma
.b56a	20 be b5	jsr $b5be			jsr 	SLIByteParameter 				; get a byte parameter.
.b56d	8d 25 04	sta $0425			sta 	SignCount 						; save in temporary.
.b570	68		pla				pla 									; restore string length.
.b571	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.b572	38		sec				sec
.b573	ed 25 04	sbc $0425			sbc 	SignCount 						; subtract characters needed, gives start position.
.b576	f0 02		beq $b57a			beq 	_URStart 						; if <= 0 start from 1.
.b578	10 02		bpl $b57c			bpl 	_UROkay
.b57a					_URStart:
.b57a	a9 01		lda #$01			lda 	#1
.b57c					_UROkay:
.b57c	48		pha				pha 									; push start
.b57d	ad 25 04	lda $0425			lda 	SignCount 						; push count of characters
.b580	48		pha				pha
.b581	80 00		bra $b583			bra 	SLIProcess
.b583					SLIProcess:
.b583	20 20 b7	jsr $b720			jsr 	CheckNextRParen 				; closing right bracket.
.b586	68		pla				pla
.b587	8d 2b 04	sta $042b			sta 	SliceCount 						; count in signcount
.b58a	1a		inc a				inc 	a 								; allocate +1 for it.
.b58b	20 30 b7	jsr $b730			jsr 	AllocateTempString
.b58e	68		pla				pla 									; pop start number off stack.
.b58f	f0 3f		beq $b5d0			beq 	SLIError 						; exit if start = 0
.b591	8d 2a 04	sta $042a			sta 	SliceStart
.b594	68		pla				pla  									; pop string address.
.b595	85 1f		sta $1f				sta 	zGenPtr+1
.b597	68		pla				pla
.b598	85 1e		sta $1e				sta 	zGenPtr
.b59a	da		phx				phx
.b59b	5a		phy				phy
.b59c	a2 00		ldx #$00			ldx 	#0 								; point to string length.
.b59e	ac 2a 04	ldy $042a			ldy 	SliceStart 						; start of the string (+1 for count)
.b5a1					_SLICopy:
.b5a1	ad 2b 04	lda $042b			lda 	SliceCount 						; done count characters
.b5a4	f0 12		beq $b5b8			beq 	_SLIExit
.b5a6	ce 2b 04	dec $042b			dec 	SliceCount
.b5a9	98		tya				tya 									; index of character
.b5aa	c1 1e		cmp ($1e,x)			cmp 	(zGenPtr,x)						; compare against length
.b5ac	f0 02		beq $b5b0			beq 	_SLIOk 							; if equal, okay.
.b5ae	b0 08		bcs $b5b8			bcs 	_SLIExit 						; if past end, then exit.
.b5b0	b1 1e		lda ($1e),y	_SLIOk:	lda 	(zGenPtr),y 					; copy one character
.b5b2	c8		iny				iny
.b5b3	20 5b b7	jsr $b75b			jsr 	WriteTempString
.b5b6	80 e9		bra $b5a1			bra 	_SLICopy 						; go round till copied characters
.b5b8					_SLIExit:
.b5b8	7a		ply				ply 									; restore YX
.b5b9	fa		plx				plx
.b5ba	4c e6 b6	jmp $b6e6			jmp 	UnaryReturnTempStr 				; return new temporary string.
.b5bd	ea		nop				nop
.b5be					SLIByteParameter:
.b5be	20 a0 b0	jsr $b0a0			jsr 	EvaluateIntegerX 				; get integer
.b5c1	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.b5c4	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.b5c7	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.b5ca	d0 04		bne $b5d0			bne 	SLIError
.b5cc	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b5cf	60		rts				rts
.b5d0					SLIError:
.b5d0	4c 33 ab	jmp $ab33			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.b5d3					Unary_Hex:
.b5d3	20 a0 b0	jsr $b0a0			jsr 	EvaluateIntegerX 			; numeric parameter
.b5d6	20 20 b7	jsr $b720			jsr 	CheckNextRParen 			; right bracket.
.b5d9	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.b5db	20 30 b7	jsr $b730			jsr 	AllocateTempString			; allocate string space
.b5de	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.b5e1	20 08 b6	jsr $b608			jsr 	_UHConvert
.b5e4	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.b5e7	20 08 b6	jsr $b608			jsr 	_UHConvert
.b5ea	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b5ed	20 08 b6	jsr $b608			jsr 	_UHConvert
.b5f0	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b5f3	20 08 b6	jsr $b608			jsr 	_UHConvert
.b5f6	5a		phy				phy 								; get length of new string
.b5f7	a0 00		ldy #$00			ldy 	#0
.b5f9	b1 20		lda ($20),y			lda 	(zTempStr),y
.b5fb	7a		ply				ply
.b5fc	c9 00		cmp #$00			cmp 	#0
.b5fe	d0 05		bne $b605			bne 	_UHExit 					; if it was non zero okay
.b600	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.b602	20 5b b7	jsr $b75b			jsr 	WriteTempString
.b605					_UHExit:
.b605	4c e6 b6	jmp $b6e6			jmp 	UnaryReturnTempStr 			; return new temporary string.
.b608					_UHConvert:
.b608	48		pha				pha
.b609	4a		lsr a				lsr 	a 							; do MSB
.b60a	4a		lsr a				lsr 	a
.b60b	4a		lsr a				lsr 	a
.b60c	4a		lsr a				lsr 	a
.b60d	20 11 b6	jsr $b611			jsr 	_UHNibble
.b610	68		pla				pla 								; do LSB
.b611					_UHNibble:
.b611	29 0f		and #$0f			and 	#15 						; get nibble
.b613	d0 0c		bne $b621			bne 	_UHNonZero
.b615	5a		phy				phy									; get the length
.b616	a0 00		ldy #$00			ldy 	#0
.b618	b1 20		lda ($20),y			lda 	(zTempStr),y
.b61a	7a		ply				ply
.b61b	c9 00		cmp #$00			cmp 	#0 							; suppress leading zeros.
.b61d	f0 0d		beq $b62c			beq 	_UHExit2
.b61f	a9 00		lda #$00			lda 	#0
.b621					_UHNonZero:
.b621	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.b623	90 02		bcc $b627			bcc 	_UHDigit
.b625	69 06		adc #$06			adc 	#7-1
.b627					_UHDigit:
.b627	69 30		adc #$30			adc 	#48
.b629	20 5b b7	jsr $b75b			jsr 	WriteTempString				; output.
.b62c					_UHExit2:
.b62c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.b62d					Unary_Dec:
.b62d	20 a9 b0	jsr $b0a9			jsr 	EvaluateStringX 			; string parameter
.b630	20 20 b7	jsr $b720			jsr 	CheckNextRParen 			; right bracket.
.b633	5a		phy				phy
.b634	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.b636	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b638	f0 4c		beq $b686			beq 	_UDFail 					; must fail if zero.
.b63a	8d 25 04	sta $0425			sta 	SignCount 					; use SignCount as a counter
.b63d	a9 00		lda #$00			lda 	#0 							; set result to zero integer.
.b63f	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b642	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b645	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b648	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b64b	a9 01		lda #$01			lda 	#1
.b64d	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.b650					_UDConvertLoop:
.b650	5a		phy				phy 								; shift mantissa left 4
.b651	a0 04		ldy #$04			ldy 	#4
.b653					_UDShift:
.b653	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x
.b656	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.b659	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.b65c	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.b65f	88		dey				dey
.b660	d0 f1		bne $b653			bne 	_UDShift
.b662	7a		ply				ply
.b663	c8		iny				iny 								; next character
.b664	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; fetch it.
.b666	20 89 b6	jsr $b689			jsr 	ConvertUpper 				; convert to U/C
.b669	c9 30		cmp #$30			cmp 	#"0"
.b66b	90 19		bcc $b686			bcc 	_UDFail
.b66d	c9 3a		cmp #$3a			cmp 	#"9"+1
.b66f	90 06		bcc $b677			bcc 	_UDOkay
.b671	e9 37		sbc #$37			sbc 	#7+"0" 						; alpha fudge
.b673	c9 10		cmp #$10			cmp 	#16
.b675	b0 0f		bcs $b686			bcs 	_UDFail
.b677					_UDOkay:
.b677	29 0f		and #$0f			and 	#15 						; nibble only
.b679	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x
.b67c	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b67f	ce 25 04	dec $0425			dec 	SignCount 					; do it for each character
.b682	d0 cc		bne $b650			bne 	_UDConvertLoop
.b684	7a		ply				ply
.b685	60		rts				rts
.b686					_UDFail:
.b686	4c 33 ab	jmp $ab33			jmp 	BadParamError
.b689					ConvertUpper:
.b689	c9 61		cmp #$61			cmp 	#"a"
.b68b	90 07		bcc $b694			bcc 	_CUExit
.b68d	c9 7b		cmp #$7b			cmp 	#"z"+1
.b68f	b0 03		bcs $b694			bcs 	_CUExit
.b691	38		sec				sec
.b692	e9 20		sbc #$20			sbc 	#32
.b694	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.b695					Unary_Chr:
.b695	20 a0 b0	jsr $b0a0			jsr 	EvaluateIntegerX			; numeric parameter
.b698	20 20 b7	jsr $b720			jsr 	CheckNextRParen 			; right bracket.
.b69b	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.b69e	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.b6a1	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.b6a4	d0 0e		bne $b6b4			bne 	_UCChar
.b6a6	a9 01		lda #$01			lda 	#1 							; one character string
.b6a8	20 30 b7	jsr $b730			jsr 	AllocateTempString
.b6ab	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.b6ae	20 5b b7	jsr $b75b			jsr 	WriteTempString
.b6b1	4c e6 b6	jmp $b6e6			jmp 	UnaryReturnTempStr
.b6b4					_UCChar:
.b6b4	4c 33 ab	jmp $ab33			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.b6b7					Unary_Spc:
.b6b7	20 a0 b0	jsr $b0a0			jsr 	EvaluateIntegerX 			; numeric parameter
.b6ba	20 20 b7	jsr $b720			jsr 	CheckNextRParen 			; right bracket.
.b6bd	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.b6c0	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.b6c3	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.b6c6	d0 1b		bne $b6e3			bne 	_USSize
.b6c8	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b6cb	c9 fe		cmp #$fe			cmp 	#maxString+1
.b6cd	b0 14		bcs $b6e3			bcs 	_USSize
.b6cf	48		pha				pha 								; save length
.b6d0	1a		inc a				inc 	a 							; allocate one more.
.b6d1	20 30 b7	jsr $b730			jsr 	AllocateTempString
.b6d4	68		pla				pla 								; get length
.b6d5	f0 0f		beq $b6e6			beq 	UnaryReturnTempStr 			; return the current temp string
.b6d7					_USLoop:
.b6d7	48		pha				pha
.b6d8	a9 20		lda #$20			lda 	#" "
.b6da	20 5b b7	jsr $b75b			jsr 	WriteTempString
.b6dd	68		pla				pla
.b6de	3a		dec a				dec 	a
.b6df	d0 f6		bne $b6d7			bne 	_USLoop
.b6e1	80 03		bra $b6e6			bra 	UnaryReturnTempStr
.b6e3					_USSize:
.b6e3	4c 33 ab	jmp $ab33			jmp 	BadParamError
.b6e6					UnaryReturnTempStr:
.b6e6	a5 20		lda $20				lda 	zTempStr 					; copy temp string addr -> mantissa
.b6e8	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b6eb	a5 21		lda $21				lda 	zTempStr+1
.b6ed	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b6f0	a9 02		lda #$02			lda 	#2 							; set type to string
.b6f2	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.b6f5	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/4510.asm

.b6f6					MemRead:
.b6f6	8d 25 04	sta $0425			sta 	SignCount 					; save count
.b6f9	a3 00		ldz #$00			ldz 	#0 							; start from here
.b6fb	ea		nop		_MLoop1:nop
.b6fc	b2 1a		lda ($1a),z			lda 	(zlTemp1),z 				; read the long address
.b6fe	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; copy into mantissa
.b701	1b		inz				inz 								; next to copy
.b702	e8		inx				inx
.b703	dc 25 04	cpz $0425			cpz 	SignCount 					; do required # of bytes.
.b706	d0 f3		bne $b6fb			bne 	_MLoop1
.b708	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.b709					CheckNextToken:
.b709	d1 16		cmp ($16),y			cmp 	(zCodePtr),y
.b70b	d0 02		bne $b70f			bne 	CTFail 						; no, then fail
.b70d	c8		iny				iny
.b70e	60		rts				rts
.b70f					CTFail:
.b70f	20 44 ab	jsr $ab44			jsr ERR_Handler
>b712	4d 69 73 73 69 6e 67 20			.text "Missing token",0
>b71a	74 6f 6b 65 6e 00
.b720					CheckNextRParen:
.b720	b1 16		lda ($16),y			lda 	(zCodePtr),y
.b722	c9 bc		cmp #$bc			cmp 	#token_rparen
.b724	d0 e9		bne $b70f			bne 	CTFail
.b726	c8		iny				iny
.b727	60		rts				rts
.b728					CheckNextComma:
.b728	b1 16		lda ($16),y			lda 	(zCodePtr),y
.b72a	c9 bd		cmp #$bd			cmp 	#token_comma
.b72c	d0 e1		bne $b70f			bne 	CTFail
.b72e	c8		iny				iny
.b72f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.b730					AllocateTempString:
.b730	48		pha				pha 								; save required count.
.b731	a5 21		lda $21				lda 	zTempStr+1 					; check if initialised yet ?
.b733	d0 0b		bne $b740			bne 	_ATSInitialised
.b735	ad 26 04	lda $0426			lda 	StringPtr 					; set temporary string ptr 1 page below available
.b738	85 20		sta $20				sta 	zTempStr					; space, this is for strings to be concreted.
.b73a	ad 27 04	lda $0427			lda 	StringPtr+1
.b73d	3a		dec a				dec 	a
.b73e	85 21		sta $21				sta 	zTempStr+1
.b740					_ATSInitialised:
.b740	68		pla				pla 								; get required count back.
.b741	49 ff		eor #$ff			eor 	#$FF 						; negate 2's complement.
.b743	1a		inc a				inc 	a
.b744	18		clc				clc
.b745	65 20		adc $20				adc 	zTempStr 					; "add" to the temp string pointer
.b747	85 20		sta $20				sta 	zTempStr
.b749	a9 ff		lda #$ff			lda 	#$FF
.b74b	65 21		adc $21				adc 	zTempStr+1
.b74d	85 21		sta $21				sta 	zTempStr+1
.b74f	a9 00		lda #$00			lda 	#0 							; clear temp string.
.b751	5a		phy				phy
.b752	a8		tay				tay
.b753	91 20		sta ($20),y			sta 	(zTempStr),y
.b755	7a		ply				ply
.b756	1a		inc a				inc 	a 							; reset the write index.
.b757	8d 28 04	sta $0428			sta 	TempStringWriteIndex
.b75a	60		rts				rts
.b75b					WriteTempString:
.b75b	5a		phy				phy 								; save Y
.b75c	ac 28 04	ldy $0428			ldy 	TempStringWriteIndex	 	; write position.
.b75f	91 20		sta ($20),y			sta 	(zTempStr),y 				; write character out.
.b761	ee 28 04	inc $0428			inc 	TempStringWriteIndex 		; increment the write position.
.b764	98		tya				tya 								; unchanged Y is now length
.b765	a0 00		ldy #$00			ldy 	#0
.b767	91 20		sta ($20),y			sta 	(zTempStr),y
.b769	7a		ply				ply 								; restore Y and exit
.b76a	60		rts				rts
.b76b					CreateTempStringCopy:
.b76b	da		phx				phx 								; save X
.b76c	b1 16		lda ($16),y			lda 	(zCodePtr),y
.b76e	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.b76f	20 30 b7	jsr $b730			jsr 	AllocateTempString 			; allocate memory for temporary string.
.b772	b1 16		lda ($16),y			lda 	(zCodePtr),y
.b774	c8		iny				iny
.b775	3a		dec a				dec 	a 							; make the actual length in charactes
.b776	3a		dec a				dec 	a
.b777	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.b779	81 20		sta ($20,x)			sta 	(zTempStr,x)
.b77b	85 1a		sta $1a				sta 	zLTemp1 					; that's used as a count.
.b77d	09 00		ora #$00			ora 	#0 							; if zero already, exit
.b77f	f0 0e		beq $b78f			beq 	_CTSCExit
.b781					_CTSCLoop:
.b781	b1 16		lda ($16),y			lda 	(zCodePtr),y
.b783	c8		iny				iny
.b784	5a		phy				phy 								; save in Y
.b785	e8		inx				inx 								; bump index
.b786	da		phx				phx 								; index into Y
.b787	7a		ply				ply
.b788	91 20		sta ($20),y			sta 	(zTempStr),y 				; save at index
.b78a	7a		ply				ply 								; restore Y
.b78b	c6 1a		dec $1a				dec 	zLTemp1 					; do for each character
.b78d	d0 f2		bne $b781			bne 	_CTSCLoop
.b78f					_CTSCExit:
.b78f	fa		plx				plx 								; restore X
.b790	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.b791					MulInteger32:
.b791	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.b794	9d 14 03	sta $0314,x			sta 	XS3_Mantissa,x
.b797	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b79a	9d 15 03	sta $0315,x			sta 	XS3_Mantissa+1,x
.b79d	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.b7a0	9d 16 03	sta $0316,x			sta 	XS3_Mantissa+2,x
.b7a3	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.b7a6	9d 17 03	sta $0317,x			sta 	XS3_Mantissa+3,x
.b7a9	a9 00		lda #$00			lda 	#0
.b7ab	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x 				; zero +0
.b7ae	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b7b1	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b7b4	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b7b7					_BFMMultiply:
.b7b7	bd 14 03	lda $0314,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.b7ba	29 01		and #$01			and 	#1
.b7bc	f0 03		beq $b7c1			beq 	_BFMNoAdd
.b7be	20 85 b2	jsr $b285			jsr 	AddInteger32
.b7c1					_BFMNoAdd:
.b7c1	1e 0e 03	asl $030e,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.b7c4	3e 0f 03	rol $030f,x			rol 	XS2_Mantissa+1,x
.b7c7	3e 10 03	rol $0310,x			rol 	XS2_Mantissa+2,x
.b7ca	3e 11 03	rol $0311,x			rol 	XS2_Mantissa+3,x
.b7cd	5e 17 03	lsr $0317,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.b7d0	7e 16 03	ror $0316,x			ror 	XS3_Mantissa+2,x
.b7d3	7e 15 03	ror $0315,x			ror 	XS3_Mantissa+1,x
.b7d6	7e 14 03	ror $0314,x			ror 	XS3_Mantissa,x
.b7d9	bd 14 03	lda $0314,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.b7dc	1d 15 03	ora $0315,x			ora 	XS3_Mantissa+1,x
.b7df	1d 16 03	ora $0316,x			ora 	XS3_Mantissa+2,x
.b7e2	1d 17 03	ora $0317,x			ora 	XS3_Mantissa+3,x
.b7e5	d0 d0		bne $b7b7			bne 	_BFMMultiply
.b7e7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.b7e8					DivInteger32:
.b7e8	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; check for /0
.b7eb	1d 0f 03	ora $030f,x			ora 	XS2_Mantissa+1,x
.b7ee	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.b7f1	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.b7f4	d0 14		bne $b80a			bne 	_BFDOkay
.b7f6	20 44 ab	jsr $ab44			jsr ERR_Handler
>b7f9	44 69 76 69 73 69 6f 6e			.text "Division by Zero",0
>b801	20 62 79 20 5a 65 72 6f 00
.b80a					_BFDOkay:
.b80a	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.b80c	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.b80e	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.b810	85 1c		sta $1c				sta 	zLTemp1+2
.b812	85 1d		sta $1d				sta 	zLTemp1+3
.b814	8d 25 04	sta $0425			sta 	SignCount 					; Count of signs.
.b817	20 78 b8	jsr $b878			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.b81a	da		phx				phx
.b81b	e8		inx				inx
.b81c	e8		inx				inx
.b81d	e8		inx				inx
.b81e	e8		inx				inx
.b81f	e8		inx				inx
.b820	e8		inx				inx
.b821	20 78 b8	jsr $b878			jsr 	CheckIntegerNegate
.b824	fa		plx				plx
.b825	5a		phy				phy 								; Y is the counter
.b826	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.b828					_BFDLoop:
.b828	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.b82b	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.b82e	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.b831	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.b834	26 1a		rol $1a				rol 	zLTemp1
.b836	26 1b		rol $1b				rol 	zLTemp1+1
.b838	26 1c		rol $1c				rol 	zLTemp1+2
.b83a	26 1d		rol $1d				rol 	zLTemp1+3
.b83c	38		sec				sec
.b83d	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.b83f	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.b842	48		pha				pha
.b843	a5 1b		lda $1b				lda 	zLTemp1+1
.b845	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.b848	48		pha				pha
.b849	a5 1c		lda $1c				lda 	zLTemp1+2
.b84b	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.b84e	48		pha				pha
.b84f	a5 1d		lda $1d				lda 	zLTemp1+3
.b851	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.b854	90 15		bcc $b86b			bcc 	_BFDNoAdd
.b856	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.b858	68		pla				pla
.b859	85 1c		sta $1c				sta 	zLTemp1+2
.b85b	68		pla				pla
.b85c	85 1b		sta $1b				sta 	zLTemp1+1
.b85e	68		pla				pla
.b85f	85 1a		sta $1a				sta 	zLTemp1+0
.b861	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.b864	09 01		ora #$01			ora 	#1
.b866	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b869	80 03		bra $b86e			bra 	_BFDNext
.b86b					_BFDNoAdd:
.b86b	68		pla				pla 								; Throw away the intermediate calculations
.b86c	68		pla				pla
.b86d	68		pla				pla
.b86e					_BFDNext:
.b86e	88		dey				dey
.b86f	d0 b7		bne $b828			bne 	_BFDLoop
.b871	7a		ply				ply 								; restore Y and exit
.b872	4e 25 04	lsr $0425			lsr 	SignCount 					; if sign count odd,
.b875	b0 07		bcs $b87e			bcs		IntegerNegateAlways 			; negate the result
.b877	60		rts				rts
.b878					CheckIntegerNegate:
.b878	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.b87b	30 01		bmi $b87e			bmi 	IntegerNegateAlways
.b87d	60		rts				rts
.b87e					IntegerNegateAlways:
.b87e	ee 25 04	inc $0425			inc 	SignCount
.b881	38		sec				sec
.b882	a9 00		lda #$00			lda 	#0
.b884	fd 08 03	sbc $0308,x			sbc 	XS_Mantissa+0,x
.b887	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b88a	a9 00		lda #$00			lda 	#0
.b88c	fd 09 03	sbc $0309,x			sbc 	XS_Mantissa+1,x
.b88f	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b892	a9 00		lda #$00			lda 	#0
.b894	fd 0a 03	sbc $030a,x			sbc 	XS_Mantissa+2,x
.b897	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b89a	a9 00		lda #$00			lda 	#0
.b89c	fd 0b 03	sbc $030b,x			sbc 	XS_Mantissa+3,x
.b89f	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b8a2	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.b8a3					INTToString:
.b8a3	48		pha				pha
.b8a4	5a		phy				phy
.b8a5	bd 0b 03	lda $030b,x			lda 		XS_Mantissa+3,x 		; check -ve
.b8a8	10 08		bpl $b8b2			bpl 		_ITSNotMinus
.b8aa	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.b8ac	20 43 b9	jsr $b943			jsr 		ITSOutputCharacter
.b8af	20 7e b8	jsr $b87e			jsr 		IntegerNegateAlways 	; negate the number.
.b8b2					_ITSNotMinus:
.b8b2	a9 00		lda #$00			lda 		#0
.b8b4	8d 21 04	sta $0421			sta 		NumSuppress 			; clear the suppression flag.
.b8b7	8a		txa				txa 								; use Y for the mantissa index.
.b8b8	a8		tay				tay
.b8b9	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.b8bb					_ITSNextSubtractor:
.b8bb	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.b8bd	8d 22 04	sta $0422			sta 		NumConvCount
.b8c0					_ITSSubtract:
.b8c0	38		sec				sec
.b8c1	b9 08 03	lda $0308,y			lda 		XS_Mantissa,y 			; subtract number and push on stack
.b8c4	fd 1f b9	sbc $b91f,x			sbc 		_ITSSubtractors+0,x
.b8c7	48		pha				pha
.b8c8	b9 09 03	lda $0309,y			lda 		XS_Mantissa+1,y
.b8cb	fd 20 b9	sbc $b920,x			sbc 		_ITSSubtractors+1,x
.b8ce	48		pha				pha
.b8cf	b9 0a 03	lda $030a,y			lda 		XS_Mantissa+2,y
.b8d2	fd 21 b9	sbc $b921,x			sbc 		_ITSSubtractors+2,x
.b8d5	48		pha				pha
.b8d6	b9 0b 03	lda $030b,y			lda 		XS_Mantissa+3,y
.b8d9	fd 22 b9	sbc $b922,x			sbc 		_ITSSubtractors+3,x
.b8dc	90 14		bcc $b8f2			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.b8de	99 0b 03	sta $030b,y			sta 		XS_Mantissa+3,y 		; save subtract off stack
.b8e1	68		pla				pla
.b8e2	99 0a 03	sta $030a,y			sta 		XS_Mantissa+2,y
.b8e5	68		pla				pla
.b8e6	99 09 03	sta $0309,y			sta 		XS_Mantissa+1,y
.b8e9	68		pla				pla
.b8ea	99 08 03	sta $0308,y			sta 		XS_Mantissa+0,y
.b8ed	ee 22 04	inc $0422			inc 		NumConvCount 			; bump count.
.b8f0	80 ce		bra $b8c0			bra 		_ITSSubtract 			; go round again.
.b8f2					_ITSCantSubtract:
.b8f2	68		pla				pla 								; throw away interim answers
.b8f3	68		pla				pla
.b8f4	68		pla				pla
.b8f5	ad 22 04	lda $0422			lda 		NumConvCount 			; if not zero then no suppression check
.b8f8	c9 30		cmp #$30			cmp 		#"0"
.b8fa	d0 05		bne $b901			bne 		_ITSOutputDigit
.b8fc	ad 21 04	lda $0421			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.b8ff	10 09		bpl $b90a			bpl	 		_ITSGoNextSubtractor
.b901					_ITSOutputDigit:
.b901	ce 21 04	dec $0421			dec 		NumSuppress 			; suppression check will be non-zero.
.b904	ad 22 04	lda $0422			lda 		NumConvCount 			; count of subtractions
.b907	20 43 b9	jsr $b943			jsr 		ITSOutputCharacter 		; output it.
.b90a					_ITSGoNextSubtractor:
.b90a	e8		inx				inx 								; next dword
.b90b	e8		inx				inx
.b90c	e8		inx				inx
.b90d	e8		inx				inx
.b90e	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.b910	d0 a9		bne $b8bb			bne 		_ITSNextSubtractor 		; do all the subtractors.
.b912	98		tya				tya 								; X is back as the mantissa index
.b913	aa		tax				tax
.b914	bd 08 03	lda $0308,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.b917	09 30		ora #$30			ora 		#"0"
.b919	20 43 b9	jsr $b943			jsr 		ITSOutputCharacter
.b91c	7a		ply				ply 								; and exit
.b91d	68		pla				pla
.b91e	60		rts				rts
.b91f					_ITSSubtractors:
>b91f	00 ca 9a 3b					.dword 		1000000000
>b923	00 e1 f5 05					.dword 		100000000
>b927	80 96 98 00					.dword 		10000000
>b92b	40 42 0f 00					.dword 		1000000
>b92f	a0 86 01 00					.dword 		100000
>b933	10 27 00 00					.dword 		10000
>b937	e8 03 00 00					.dword 		1000
>b93b	64 00 00 00					.dword 		100
>b93f	0a 00 00 00					.dword 		10
.b943					_ITSSubtractorsEnd:
.b943					ITSOutputCharacter:
.b943	48		pha				pha
.b944	da		phx				phx
.b945	ae 00 04	ldx $0400			ldx 	NumBufX 					; save digit
.b948	9d 01 04	sta $0401,x			sta 	Num_Buffer,x
.b94b	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.b94d	9d 02 04	sta $0402,x			sta 	Num_Buffer+1,x
.b950	ee 00 04	inc $0400			inc 	NumBufX						; bump pointer.
.b953	fa		plx				plx
.b954	68		pla				pla
.b955	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.b956					IntFromString:
.b956	a0 00		ldy #$00			ldy 	#0
.b958	8c 23 04	sty $0423			sty 	ExpTemp 					; this is the converted digit count.
.b95b					IntFromStringY:
.b95b	48		pha				pha
.b95c	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.b95e	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.b961	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b964	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b967	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b96a	a9 01		lda #$01			lda 	#1
.b96c	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.b96f					_IFSLoop:
.b96f	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.b971	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.b973	90 60		bcc $b9d5			bcc 	_IFSExit
.b975	c9 3a		cmp #$3a			cmp 	#"9"+1
.b977	b0 5c		bcs $b9d5			bcs 	_IFSExit
.b979	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.b97c	c9 0c		cmp #$0c			cmp 	#12
.b97e	b0 5f		bcs $b9df			bcs 	_IFSOverflow
.b980	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.b983	48		pha				pha
.b984	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.b987	48		pha				pha
.b988	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b98b	48		pha				pha
.b98c	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b98f	48		pha				pha
.b990	20 f4 b9	jsr $b9f4			jsr 	IFSX1ShiftLeft 				; double
.b993	20 f4 b9	jsr $b9f4			jsr 	IFSX1ShiftLeft 				; x 4
.b996	18		clc				clc 								; add saved value x 5
.b997	68		pla				pla
.b998	7d 08 03	adc $0308,x			adc 	XS_Mantissa+0,x
.b99b	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b99e	68		pla				pla
.b99f	7d 09 03	adc $0309,x			adc 	XS_Mantissa+1,x
.b9a2	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b9a5	68		pla				pla
.b9a6	7d 0a 03	adc $030a,x			adc 	XS_Mantissa+2,x
.b9a9	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b9ac	68		pla				pla
.b9ad	7d 0b 03	adc $030b,x			adc 	XS_Mantissa+3,x
.b9b0	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b9b3	20 f4 b9	jsr $b9f4			jsr 	IFSX1ShiftLeft 				; x 10
.b9b6	ee 23 04	inc $0423			inc 	ExpTemp 					; bump count of digits processed.
.b9b9	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.b9bb	29 0f		and #$0f			and 	#15
.b9bd	c8		iny				iny
.b9be	7d 08 03	adc $0308,x			adc 	XS_Mantissa+0,x
.b9c1	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b9c4	90 a9		bcc $b96f			bcc 	_IFSLoop
.b9c6	fe 09 03	inc $0309,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.b9c9	d0 a4		bne $b96f			bne 	_IFSLoop
.b9cb	fe 0a 03	inc $030a,x			inc 	XS_Mantissa+2,x
.b9ce	d0 9f		bne $b96f			bne 	_IFSLoop
.b9d0	fe 0b 03	inc $030b,x			inc 	XS_Mantissa+3,x
.b9d3	80 9a		bra $b96f			bra 	_IFSLoop
.b9d5					_IFSExit:
.b9d5	98		tya				tya 								; get offset
.b9d6					_IFSOkay:
.b9d6	38		sec				sec
.b9d7	ad 23 04	lda $0423			lda 	ExpTemp
.b9da	f0 01		beq $b9dd			beq 	_IFSSkipFail
.b9dc	18		clc				clc
.b9dd					_IFSSkipFail:
.b9dd	68		pla				pla 								; and exit.
.b9de	60		rts				rts
.b9df					_IFSOverflow:
.b9df	20 44 ab	jsr $ab44			jsr 	ERR_Handler
>b9e2	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>b9ea	20 6f 76 65 72 66 6c 6f 77 00
.b9f4					IFSX1ShiftLeft:
.b9f4	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x
.b9f7	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.b9fa	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.b9fd	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.ba00	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.ba01					FPSubtract:
.ba01	48		pha				pha
.ba02	bd 13 03	lda $0313,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.ba05	49 80		eor #$80			eor 	#$80
.ba07	9d 13 03	sta $0313,x			sta 	XS2_Type,x
.ba0a	68		pla				pla 								; --- and fall through ---
.ba0b					FPAdd:
.ba0b	48		pha				pha
.ba0c	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.ba0f	d0 05		bne $ba16			bne 	_FPA_NegativeLHS
.ba11	20 33 ba	jsr $ba33			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.ba14	68		pla				pla
.ba15	60		rts				rts
.ba16					_FPA_NegativeLHS:
.ba16	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.ba19	49 80		eor #$80			eor 	#$80
.ba1b	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.ba1e	bd 13 03	lda $0313,x			lda 	XS2_Type,x 					; flip the sign of B and add
.ba21	49 80		eor #$80			eor 	#$80
.ba23	9d 13 03	sta $0313,x			sta 	XS2_Type,x
.ba26	20 33 ba	jsr $ba33			jsr 	FPAdd_Worker 				; do the add calculation.
.ba29	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip sign of X1 back
.ba2c	49 80		eor #$80			eor 	#$80
.ba2e	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.ba31	68		pla				pla
.ba32	60		rts				rts
.ba33					FPAdd_Worker:
.ba33	3c 13 03	bit $0313,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.ba36	70 08		bvs $ba40			bvs 	_FPAWExit 					; no change.
.ba38	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.ba3b	50 07		bvc $ba44			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.ba3d	20 d8 bc	jsr $bcd8			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.ba40					_FPAWExit:
.ba40	20 60 bd	jsr $bd60			jsr 	FPUNormalise 				; normalise the result.
.ba43	60		rts				rts
.ba44					_FPAWMakeSame:
.ba44	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.ba47	38		sec				sec
.ba48	fd 12 03	sbc $0312,x			sbc	 	XS2_Exponent,x 				; using subtraction
.ba4b	f0 1b		beq $ba68			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.ba4d	da		phx				phx 								; save X
.ba4e	90 06		bcc $ba56			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.ba50	e8		inx				inx
.ba51	e8		inx				inx
.ba52	e8		inx				inx
.ba53	e8		inx				inx
.ba54	e8		inx				inx
.ba55	e8		inx				inx
.ba56					_FPAWShiftA:
.ba56	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x 				; so shift exponent up.
.ba59	5e 0b 03	lsr $030b,x			lsr 	3+XS_Mantissa,x
.ba5c	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.ba5f	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.ba62	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.ba65	fa		plx				plx 								; restore original X
.ba66	80 dc		bra $ba44			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.ba68					_FPAW_DoArithmetic:
.ba68	3c 13 03	bit $0313,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.ba6b	30 39		bmi $baa6			bmi 	_FPAW_BNegative
.ba6d	18		clc				clc
.ba6e	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.ba71	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.ba74	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.ba77	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.ba7a	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.ba7d	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.ba80	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.ba83	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.ba86	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.ba89	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.ba8c	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.ba8f	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.ba92	90 ac		bcc $ba40			bcc 	_FPAWExit 					; no carry.
.ba94	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x 				; so shift exponent up.
.ba97	38		sec				sec
.ba98	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.ba9b	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.ba9e	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.baa1	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.baa4	80 9a		bra $ba40			bra 	_FPAWExit
.baa6					_FPAW_BNegative:
.baa6	38		sec				sec
.baa7	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.baaa	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.baad	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.bab0	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.bab3	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.bab6	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.bab9	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.babc	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.babf	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.bac2	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.bac5	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.bac8	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.bacb	b0 0b		bcs $bad8			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.bacd	20 05 bd	jsr $bd05			jsr 	FPUNegateInteger			; negate the mantissa
.bad0	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip result sign
.bad3	49 80		eor #$80			eor 	#$80
.bad5	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bad8					_FPAWGoExit:
.bad8	4c 40 ba	jmp $ba40			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.badb					FPD_IsDivZero:
.badb	20 44 ab	jsr $ab44			jsr ERR_Handler
>bade	44 69 76 69 73 69 6f 6e			.text "Division by zero",0
>bae6	20 62 79 20 7a 65 72 6f 00
.baef					FPDivide:
.baef	48		pha				pha
.baf0	5a		phy				phy
.baf1	3c 13 03	bit $0313,x			bit 	XS2_Type,x 					; check if division by zero
.baf4	70 e5		bvs $badb			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.baf6	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.baf9	f0 03		beq $bafe			beq 	_FPDCalculateExp
.bafb					_FPD_Exit:
.bafb	7a		ply				ply
.bafc	68		pla				pla
.bafd	60		rts				rts
.bafe					_FPDCalculateExp:
.bafe	bd 12 03	lda $0312,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.bb01	49 ff		eor #$ff			eor 	#$FF
.bb03	1a		inc a				inc 	a
.bb04	9d 12 03	sta $0312,x			sta 	XS2_Exponent,x
.bb07	20 fb bb	jsr $bbfb			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.bb0a	18		clc				clc 	 							; add 1 to the resulting exponent
.bb0b	69 01		adc #$01			adc 	#1
.bb0d	b0 65		bcs $bb74			bcs 	_FPD_Overflow 				; which can overflow.
.bb0f	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.bb12	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.bb14	85 1a		sta $1a				sta 	zLTemp1+0
.bb16	85 1b		sta $1b				sta 	zLTemp1+1
.bb18	85 1c		sta $1c				sta 	zLTemp1+2
.bb1a	85 1d		sta $1d				sta 	zLTemp1+3
.bb1c	a0 20		ldy #$20			ldy 	#32 						; times round.
.bb1e					_FPD_Loop:
.bb1e	38		sec				sec 								; calculate X1-X2 stacking result because we might
.bb1f	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; not save it.
.bb22	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa,x
.bb25	48		pha				pha
.bb26	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.bb29	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.bb2c	48		pha				pha
.bb2d	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.bb30	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.bb33	48		pha				pha
.bb34	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.bb37	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.bb3a	90 17		bcc $bb53			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.bb3c	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x 			; save results out to A
.bb3f	68		pla				pla
.bb40	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.bb43	68		pla				pla
.bb44	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.bb47	68		pla				pla
.bb48	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.bb4b	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.bb4d	09 80		ora #$80			ora 	#$80
.bb4f	85 1d		sta $1d				sta 	zLTemp1+3
.bb51	80 03		bra $bb56			bra 	_FPD_Rotates
.bb53					_FPD_NoSubtract:
.bb53	68		pla				pla 								; throw away unwanted results
.bb54	68		pla				pla
.bb55	68		pla				pla
.bb56					_FPD_Rotates:
.bb56	5e 11 03	lsr $0311,x			lsr 	3+XS2_Mantissa,x
.bb59	7e 10 03	ror $0310,x			ror 	2+XS2_Mantissa,x
.bb5c	7e 0f 03	ror $030f,x			ror 	1+XS2_Mantissa,x
.bb5f	7e 0e 03	ror $030e,x			ror 	0+XS2_Mantissa,x
.bb62	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.bb64	26 1b		rol $1b				rol 	zLTemp1+1
.bb66	26 1c		rol $1c				rol 	zLTemp1+2
.bb68	26 1d		rol $1d				rol 	zLTemp1+3
.bb6a	90 02		bcc $bb6e			bcc 	_FPD_NoCarry
.bb6c	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.bb6e					_FPD_NoCarry:
.bb6e	88		dey				dey 								; do 32 times
.bb6f	d0 ad		bne $bb1e			bne 	_FPD_Loop
.bb71	4c d8 bb	jmp $bbd8			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.bb74					_FPD_Overflow:
.bb74	4c d5 bd	jmp $bdd5			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.bb77					FPMultiply:
.bb77	48		pha				pha
.bb78	5a		phy				phy
.bb79	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.bb7c	70 08		bvs $bb86			bvs 	_FPM_Exit
.bb7e	3c 13 03	bit $0313,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.bb81	50 06		bvc $bb89			bvc 	_FPM_CalcExponent
.bb83	20 d8 bc	jsr $bcd8			jsr 	FPUCopyX2ToX1
.bb86					_FPM_Exit:
.bb86	7a		ply				ply
.bb87	68		pla				pla
.bb88	60		rts				rts
.bb89					_FPM_CalcExponent:
.bb89	18		clc				clc
.bb8a	20 fb bb	jsr $bbfb			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.bb8d	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x 				; save the result.
.bb90	a9 00		lda #$00			lda 	#0
.bb92	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.bb94	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.bb96	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.bb98	85 1d		sta $1d				sta 	zLTemp1+3
.bb9a	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.bb9c					_FPM_Loop:
.bb9c	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x				; check LSB of long product
.bb9f	29 01		and #$01			and 	#1
.bba1	18		clc				clc 								; clear carry for the long rotate.
.bba2	f0 1d		beq $bbc1			beq 	_FPM_NoAddition
.bba4	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.bba5	a5 1a		lda $1a				lda 	zLTemp1+0
.bba7	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.bbaa	85 1a		sta $1a				sta 	zLTemp1+0
.bbac	a5 1b		lda $1b				lda 	zLTemp1+1
.bbae	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.bbb1	85 1b		sta $1b				sta 	zLTemp1+1
.bbb3	a5 1c		lda $1c				lda 	zLTemp1+2
.bbb5	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.bbb8	85 1c		sta $1c				sta 	zLTemp1+2
.bbba	a5 1d		lda $1d				lda 	zLTemp1+3
.bbbc	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.bbbf	85 1d		sta $1d				sta 	zLTemp1+3
.bbc1					_FPM_NoAddition:
.bbc1	66 1d		ror $1d				ror 	3+zLTemp1
.bbc3	66 1c		ror $1c				ror 	2+zLTemp1
.bbc5	66 1b		ror $1b				ror 	1+zLTemp1
.bbc7	66 1a		ror $1a				ror 	0+zLTemp1
.bbc9	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.bbcc	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.bbcf	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.bbd2	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.bbd5	88		dey				dey
.bbd6	d0 c4		bne $bb9c			bne 	_FPM_Loop 					; do this 32 times.
.bbd8					FPM_CopySignNormalize:
.bbd8	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.bbda	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.bbdd	a5 1b		lda $1b				lda 	zLTemp1+1
.bbdf	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.bbe2	a5 1c		lda $1c				lda 	zLTemp1+2
.bbe4	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.bbe7	a5 1d		lda $1d				lda 	zLTemp1+3
.bbe9	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.bbec	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; sign is xor of signs
.bbef	5d 13 03	eor $0313,x			eor 	XS2_Type,x
.bbf2	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bbf5	20 60 bd	jsr $bd60			jsr 	FPUNormalise 				; normalise and exit.
.bbf8	7a		ply				ply
.bbf9	68		pla				pla
.bbfa	60		rts				rts
.bbfb					FPCalculateExponent:
.bbfb	18		clc				clc
.bbfc	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.bbff	7d 12 03	adc $0312,x			adc 	XS2_Exponent,x
.bc02	b0 08		bcs $bc0c			bcs 	_FPCECarry 					; carry out ?
.bc04	10 03		bpl $bc09			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.bc06	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.bc08	60		rts				rts
.bc09					_FPCEExpZero:
.bc09	a9 00		lda #$00			lda 	#0
.bc0b	60		rts				rts
.bc0c					_FPCECarry:
.bc0c	30 03		bmi $bc11			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.bc0e	09 80		ora #$80			ora 	#$80 						; put in right range
.bc10	60		rts				rts
.bc11					_FPCEOverflow:
.bc11	4c d5 bd	jmp $bdd5			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.bc14					FPFractionalPart:
.bc14	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.bc17	38		sec				sec 								; this flag tells us to keep the fractional part
.bc18	30 0f		bmi $bc29			bmi 	FPGetPart
.bc1a	60		rts				rts
.bc1b					FPIntegerPart:
.bc1b	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.bc1e	18		clc				clc 								; this flag says keep the integer part.
.bc1f	30 08		bmi $bc29			bmi 	FPGetPart 					; -ve exponents are 0..127
.bc21	48		pha				pha
.bc22	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.bc24	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bc27	68		pla				pla
.bc28	60		rts				rts
.bc29					FPGetPart:
.bc29	48		pha				pha
.bc2a	5a		phy				phy 								; save Y
.bc2b	08		php				php 								; save action
.bc2c	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.bc2f	70 62		bvs $bc93			bvs 	_FPGP_Exit 					; then do nothing.
.bc31	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.bc33	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.bc35	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.bc37	85 1c		sta $1c				sta 	zLTemp1+2
.bc39	85 1d		sta $1d				sta 	zLTemp1+3
.bc3b	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x				; the number of shifts.
.bc3e	38		sec				sec
.bc3f	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.bc41	f0 12		beq $bc55			beq 	_FPGP_NoShift 				; ... if any
.bc43	c9 20		cmp #$20			cmp 	#32
.bc45	90 02		bcc $bc49			bcc 	_FPGP_NotMax
.bc47	a9 20		lda #$20			lda 	#32 						; max of 32.
.bc49					_FPGP_NotMax:
.bc49	a8		tay				tay 								; Y is the mask shift count.
.bc4a					_FPGP_ShiftMask:
.bc4a	46 1d		lsr $1d				lsr 	3+zLTemp1
.bc4c	66 1c		ror $1c				ror 	2+zLTemp1
.bc4e	66 1b		ror $1b				ror 	1+zLTemp1
.bc50	66 1a		ror $1a				ror 	0+zLTemp1
.bc52	88		dey				dey
.bc53	d0 f5		bne $bc4a			bne 	_FPGP_ShiftMask
.bc55					_FPGP_NoShift:
.bc55	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.bc57	8e 23 04	stx $0423			stx 	ExpTemp						; save X
.bc5a					_FPGP_MaskLoop:
.bc5a	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.bc5d	28		plp				plp 								; if CC we keep the top part, so we
.bc5e	08		php				php		 							; flip the mask.
.bc5f	b0 02		bcs $bc63			bcs		_FPGP_NoFlip
.bc61	49 ff		eor #$ff			eor 	#$FF
.bc63					_FPGP_NoFlip:
.bc63	3d 08 03	and $0308,x			and 	XS_Mantissa,x 				; and into the mantissa.
.bc66	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.bc69	e8		inx				inx
.bc6a	c8		iny				iny
.bc6b	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.bc6d	d0 eb		bne $bc5a			bne 	_FPGP_MaskLoop
.bc6f	ae 23 04	ldx $0423			ldx 	ExpTemp						; restore X
.bc72	28		plp				plp
.bc73	08		php				php 								; get action flag on the stack
.bc74	90 05		bcc $bc7b			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.bc76	a9 00		lda #$00			lda 	#0
.bc78	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bc7b					_FPGP_NotFractional:
.bc7b	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 						; check if \1 zero
.bc7e	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.bc81	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.bc84	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.bc87	f0 05		beq $bc8e			beq 	_FPGP_Zero 					; if zero, return zero
.bc89	20 60 bd	jsr $bd60			jsr 	FPUNormalise
.bc8c	80 05		bra $bc93			bra 	_FPGP_Exit 					; and exit
.bc8e					_FPGP_Zero:
.bc8e	a9 40		lda #$40			lda 	#$40 						; set zero flag
.bc90	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bc93					_FPGP_Exit:
.bc93	68		pla				pla 								; throw saved action flag.
.bc94	7a		ply				ply
.bc95	68		pla				pla
.bc96	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.bc97					FPCompare:
.bc97	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.bc9a	48		pha				pha
.bc9b	bd 12 03	lda $0312,x			lda 	XS2_Exponent,x
.bc9e	48		pha				pha
.bc9f	20 01 ba	jsr $ba01			jsr 	FPSubtract 					; calculate X1-X2
.bca2	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.bca5	70 2c		bvs $bcd3			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.bca7	68		pla				pla
.bca8	8d 23 04	sta $0423			sta 	ExpTemp						; save first exponent in temporary reg.
.bcab	68		pla				pla
.bcac	38		sec				sec
.bcad	ed 23 04	sbc $0423			sbc 	ExpTemp 					; calculate AX-BX
.bcb0	70 15		bvs $bcc7			bvs 	_FPCNotEqual				; overflow, can't be equal.
.bcb2	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.bcb3	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.bcb5	b0 10		bcs $bcc7			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.bcb7	38		sec				sec
.bcb8	ad 23 04	lda $0423			lda 	ExpTemp 					; get one of the exponents back.
.bcbb	e9 12		sbc #$12			sbc 	#18 						; allow for 2^18 error, relatively.
.bcbd	b0 02		bcs $bcc1			bcs 	_FPCNotRange 				; keep in range.
.bcbf	a9 01		lda #$01			lda 	#1
.bcc1					_FPCNotRange:
.bcc1	38		sec				sec
.bcc2	fd 0c 03	sbc $030c,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.bcc5	b0 0e		bcs $bcd5			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.bcc7					_FPCNotEqual:
.bcc7	bd 0d 03	lda $030d,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.bcca	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.bccc	f0 02		beq $bcd0			beq 	_FPCNE2
.bcce	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.bcd0	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.bcd1	80 04		bra $bcd7			bra 	_FPCExit
.bcd3					_FPCPullZero:
.bcd3	68		pla				pla 								; throw saved exponents
.bcd4	68		pla				pla
.bcd5					_FPCZero:
.bcd5	a9 00		lda #$00			lda 	#0 							; and return zero
.bcd7					_FPCExit:
.bcd7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.bcd8					FPUCopyX2ToX1:
.bcd8	48		pha				pha
.bcd9	da		phx				phx
.bcda	5a		phy				phy
.bcdb	a0 08		ldy #$08			ldy 	#8
.bcdd	bd 0e 03	lda $030e,x	_FPUC21:lda 	XS2_Mantissa,x
.bce0	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.bce3	e8		inx				inx
.bce4	88		dey				dey
.bce5	10 f6		bpl $bcdd			bpl 	_FPUC21
.bce7	7a		ply				ply
.bce8	fa		plx				plx
.bce9	68		pla				pla
.bcea	60		rts				rts
.bceb					FPUSetInteger:
.bceb	48		pha				pha
.bcec	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.bcef	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.bcf1	10 02		bpl $bcf5			bpl 	_FPUSIExtend
.bcf3	a9 ff		lda #$ff			lda 	#$FF
.bcf5					_FPUSIExtend:
.bcf5	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.bcf8	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.bcfb	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.bcfe	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.bd00	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bd03	68		pla				pla
.bd04	60		rts				rts
.bd05					FPUNegateInteger:
.bd05	48		pha				pha
.bd06	38		sec				sec
.bd07	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.bd09	fd 08 03	sbc $0308,x			sbc 	XS_Mantissa+0,x
.bd0c	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.bd0f	a9 00		lda #$00			lda 	#0
.bd11	fd 09 03	sbc $0309,x			sbc 	XS_Mantissa+1,x
.bd14	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.bd17	a9 00		lda #$00			lda 	#0
.bd19	fd 0a 03	sbc $030a,x			sbc 	XS_Mantissa+2,x
.bd1c	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.bd1f	a9 00		lda #$00			lda 	#0
.bd21	fd 0b 03	sbc $030b,x			sbc 	XS_Mantissa+3,x
.bd24	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.bd27	68		pla				pla
.bd28	60		rts				rts
.bd29					FPUToFloat:
.bd29	48		pha				pha
.bd2a	bd 0d 03	lda $030d,x			lda 	XS_Type,x					; exit if already float.
.bd2d	29 0f		and #$0f			and 	#$0F
.bd2f	f0 2d		beq $bd5e			beq 	_FPUFExit
.bd31	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.bd33	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bd36	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.bd38	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x 				; x mantissa.
.bd3b	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.bd3e	10 08		bpl $bd48			bpl		_FPUFPositive
.bd40	20 05 bd	jsr $bd05			jsr 	FPUNegateInteger 			; negate the mantissa
.bd43	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.bd45	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bd48					_FPUFPositive:
.bd48	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.bd4b	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.bd4e	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.bd51	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.bd54	d0 05		bne $bd5b			bne 	_FPUFNonZero
.bd56	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.bd58	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bd5b					_FPUFNonZero:
.bd5b	20 60 bd	jsr $bd60			jsr 	FPUNormalise 				; normalise the floating point.
.bd5e					_FPUFExit:
.bd5e	68		pla				pla
.bd5f	60		rts				rts
.bd60					FPUNormalise:
.bd60	48		pha				pha
.bd61	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.bd64	70 20		bvs $bd86			bvs 	_FPUNExit
.bd66	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.bd69	f0 16		beq $bd81			beq 	_FPUNSetZero
.bd6b					_FPUNLoop:
.bd6b	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.bd6e	30 16		bmi $bd86			bmi 	_FPUNExit 					; if so, we are normalised.
.bd70	1e 08 03	asl $0308,x			asl 	0+XS_Mantissa+0,x
.bd73	3e 09 03	rol $0309,x			rol 	1+XS_Mantissa+0,x
.bd76	3e 0a 03	rol $030a,x			rol 	2+XS_Mantissa+0,x
.bd79	3e 0b 03	rol $030b,x			rol 	3+XS_Mantissa+0,x
.bd7c	de 0c 03	dec $030c,x			dec 	XS_Exponent,x 				; decrement exponent
.bd7f	d0 ea		bne $bd6b			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.bd81					_FPUNSetZero:
.bd81	a9 40		lda #$40			lda 	#$40
.bd83	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; the result is now zero.
.bd86					_FPUNExit:
.bd86	68		pla				pla
.bd87	60		rts				rts
.bd88					FPUToInteger:
.bd88	48		pha				pha
.bd89	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; if already integer, exit
.bd8c	29 01		and #$01			and 	#1
.bd8e	d0 3e		bne $bdce			bne 	_FPUTOI_Exit
.bd90	3c 0d 03	bit $030d,x			bit 	XS_Type,x					; if zero, return zero.
.bd93	70 2b		bvs $bdc0			bvs 	_FPUTOI_Zero
.bd95	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.bd98	10 26		bpl $bdc0			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.bd9a	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.bd9c	b0 37		bcs $bdd5			bcs 	FP_Overflow
.bd9e					_FPUToIToInteger:
.bd9e	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.bda1	c9 a0		cmp #$a0			cmp 	#128+32
.bda3	f0 11		beq $bdb6			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.bda5	fe 0c 03	inc $030c,x			inc 	XS_Exponent,X 				; increment Exponent
.bda8	5e 0b 03	lsr $030b,x			lsr 	3+XS_Mantissa,x
.bdab	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.bdae	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.bdb1	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.bdb4	80 e8		bra $bd9e			bra 	_FPUToIToInteger 			; keep going.
.bdb6					_FPUToICheckSign:
.bdb6	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; check sign
.bdb9	10 13		bpl $bdce			bpl 	_FPUToI_Exit 				; exit if unsigned.
.bdbb	20 05 bd	jsr $bd05			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.bdbe	80 0e		bra $bdce			bra 	_FPUTOI_Exit
.bdc0					_FPUTOI_Zero:
.bdc0	a9 00		lda #$00			lda 	#0 							; return zero integer.
.bdc2	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.bdc5	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.bdc8	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.bdcb	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.bdce					_FPUToI_Exit:
.bdce	a9 01		lda #$01			lda 	#1 							; set type to integer
.bdd0	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bdd3	68		pla				pla
.bdd4	60		rts				rts
.bdd5					FP_Overflow:
.bdd5	20 44 ab	jsr $ab44			jsr ERR_Handler
>bdd8	46 6c 6f 61 74 69 6e 67			.text "Floating Point overflow",0
>bde0	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.bdf0					FPUTimes10:
.bdf0	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.bdf3	85 1a		sta $1a				sta 	ZLTemp1+0
.bdf5	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.bdf8	85 1b		sta $1b				sta 	ZLTemp1+1
.bdfa	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.bdfd	85 1c		sta $1c				sta 	ZLTemp1+2
.bdff	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.be02	85 1d		sta $1d				sta 	ZLTemp1+3
.be04	20 48 be	jsr $be48			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.be07	20 48 be	jsr $be48			jsr 	_FPUT_LSR_ZLTemp1
.be0a	18		clc				clc
.be0b	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.be0e	65 1a		adc $1a				adc 	ZLTemp1+0
.be10	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.be13	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.be16	65 1b		adc $1b				adc 	ZLTemp1+1
.be18	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.be1b	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.be1e	65 1c		adc $1c				adc 	ZLTemp1+2
.be20	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.be23	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.be26	65 1d		adc $1d				adc 	ZLTemp1+3
.be28	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.be2b	90 0f		bcc $be3c			bcc 	_FPUTimes10
.be2d	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.be30	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.be33	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.be36	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.be39	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x				; fix exponent
.be3c					_FPUTimes10:
.be3c	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.be3f	18		clc				clc
.be40	69 03		adc #$03			adc 	#3
.be42	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.be45	b0 8e		bcs $bdd5			bcs 	FP_Overflow 				; error
.be47	60		rts				rts
.be48					_FPUT_LSR_ZLTemp1:
.be48	46 1d		lsr $1d				lsr 	ZLTemp1+3
.be4a	66 1c		ror $1c				ror 	ZLTemp1+2
.be4c	66 1b		ror $1b				ror 	ZLTemp1+1
.be4e	66 1a		ror $1a				ror 	ZLTemp1+0
.be50	60		rts				rts
.be51					FPUScale10A:
.be51	5a		phy				phy
.be52	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.be54	f0 3d		beq $be93			beq 	_FPUScaleExit
.be56	da		phx				phx 								; save X
.be57	e8		inx				inx
.be58	e8		inx				inx
.be59	e8		inx				inx
.be5a	e8		inx				inx
.be5b	e8		inx				inx
.be5c	e8		inx				inx
.be5d	a8		tay				tay 								; save power scalar in Y.
.be5e	a9 00		lda #$00			lda 	#0
.be60	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.be63	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.be66	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.be69	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.be6c	a9 80		lda #$80			lda 	#$80
.be6e	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.be71	a9 81		lda #$81			lda 	#$81
.be73	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.be76	5a		phy				phy 								; save 10^n on stack.
.be77	c0 00		cpy #$00			cpy 	#0
.be79	10 05		bpl $be80			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.be7b	98		tya				tya
.be7c	49 ff		eor #$ff			eor 	#$FF
.be7e	1a		inc a				inc 	a
.be7f	a8		tay				tay
.be80					_FPUSAbs:
.be80	20 f0 bd	jsr $bdf0			jsr 	FPUTimes10
.be83	88		dey				dey
.be84	d0 fa		bne $be80			bne 	_FPUSAbs 					; tos is now 10^|AC|
.be86	68		pla				pla 								; restore count in A
.be87	fa		plx				plx 								; restore X pointing to number to scale.
.be88	0a		asl a				asl 	a
.be89	b0 05		bcs $be90			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.be8b	20 77 bb	jsr $bb77			jsr 	FPMultiply 					; if clear multiply.
.be8e	80 03		bra $be93			bra		_FPUScaleExit
.be90					_FPUSDivide:
.be90	20 ef ba	jsr $baef			jsr 	FPDivide
.be93					_FPUScaleExit:
.be93	7a		ply				ply
.be94	60		rts				rts
.be95					FPUCopyToNext:
.be95	a0 06		ldy #$06			ldy 		#6
.be97	da		phx				phx
.be98					_FPUCopy1:
.be98	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x
.be9b	9d 0e 03	sta $030e,x			sta 	XS2_Mantissa,x
.be9e	e8		inx				inx
.be9f	88		dey				dey
.bea0	d0 f6		bne $be98			bne 	_FPUCopy1
.bea2	fa		plx				plx
.bea3	60		rts				rts
.bea4					FPUCopyFromNext:
.bea4	a0 06		ldy #$06			ldy 		#6
.bea6	da		phx				phx
.bea7					_FPUCopy1:
.bea7	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa,x
.beaa	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.bead	e8		inx				inx
.beae	88		dey				dey
.beaf	d0 f6		bne $bea7			bne 	_FPUCopy1
.beb1	fa		plx				plx
.beb2	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.beb3					FPToString:
.beb3	48		pha				pha
.beb4	5a		phy				phy
.beb5	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; check zero flag
.beb8	50 0a		bvc $bec4			bvc 		_FPTSIsFloat 			; if zero,
.beba					_FPTSZero:
.beba	a9 30		lda #$30			lda 		#"0"
.bebc	20 43 b9	jsr $b943			jsr 		ITSOutputCharacter
.bebf					_FPTSExit:
.bebf	7a		ply				ply
.bec0	68		pla				pla
.bec1	60		rts				rts
.bec2	80 fb		bra $bebf			bra 		_FPTSExit
.bec4					_FPTSIsFloat:
.bec4	bd 0d 03	lda $030d,x			lda 		XS_Type,x 				; is it signed ?
.bec7	10 0a		bpl $bed3			bpl 		_FPTSNotSigned
.bec9	a9 00		lda #$00			lda 		#0 						; clear sign flag
.becb	9d 0d 03	sta $030d,x			sta 		XS_Type,x
.bece	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.bed0	20 43 b9	jsr $b943			jsr 		ITSOutputCharacter
.bed3					_FPTSNotSigned:
.bed3	bd 0c 03	lda $030c,x			lda 		XS_Exponent,x
.bed6	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.bed8	b0 09		bcs $bee3			bcs 		_FPTSExponent
.beda	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.bedc	90 05		bcc $bee3			bcc 		_FPTSExponent 			;
.bede					_FPTSStandard:
.bede	20 27 bf	jsr $bf27			jsr 		FPTOutputBody 			; output the body.
.bee1	80 dc		bra $bebf			bra 		_FPTSExit
.bee3					_FPTSExponent:
.bee3	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.bee5	8d 24 04	sta $0424			sta 		ExpCount
.bee8					_FPTSExponentLoop:
.bee8	bd 0c 03	lda $030c,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.beeb	10 0e		bpl $befb			bpl 		_FPTSTimes
.beed	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.beef	90 14		bcc $bf05			bcc 		_FPTSScaledToExp
.bef1	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.bef3	20 51 be	jsr $be51			jsr 		FPUScale10A
.bef6	ee 24 04	inc $0424			inc 		ExpCount
.bef9	80 ed		bra $bee8			bra 		_FPTSExponentLoop
.befb					_FPTSTimes:
.befb	a9 01		lda #$01			lda 		#1
.befd	20 51 be	jsr $be51			jsr 		FPUScale10A
.bf00	ce 24 04	dec $0424			dec 		ExpCount
.bf03	80 e3		bra $bee8			bra 		_FPTSExponentLoop
.bf05					_FPTSScaledToExp:
.bf05	20 27 bf	jsr $bf27			jsr 		FPTOutputBody 			; output the body.
.bf08	a9 65		lda #$65			lda 		#"e"					; output E
.bf0a	20 43 b9	jsr $b943			jsr 		ITSOutputCharacter
.bf0d	ad 24 04	lda $0424			lda 		ExpCount 				; get the exponent
.bf10	9d 08 03	sta $0308,x			sta 		XS_Mantissa,x
.bf13	29 80		and #$80			and 		#$80 					; sign extend it
.bf15	f0 02		beq $bf19			beq 		_FPTSSExt
.bf17	a9 ff		lda #$ff			lda 		#$FF
.bf19					_FPTSSExt:
.bf19	9d 09 03	sta $0309,x			sta 		XS_Mantissa+1,x
.bf1c	9d 0a 03	sta $030a,x			sta 		XS_Mantissa+2,x
.bf1f	9d 0b 03	sta $030b,x			sta 		XS_Mantissa+3,x
.bf22	20 a3 b8	jsr $b8a3			jsr 		INTToString 			; output the exponent.
.bf25	80 98		bra $bebf			bra			_FPTSExit 				; and exit.
.bf27					FPTOutputBody:
.bf27	20 95 be	jsr $be95			jsr 		FPUCopyToNext 			; copy to next slot.
.bf2a	20 88 bd	jsr $bd88			jsr 		FPUToInteger 			; convert to an integer
.bf2d	20 a3 b8	jsr $b8a3			jsr 		INTToString 			; output the main integer part.
.bf30	20 a4 be	jsr $bea4			jsr 		FPUCopyFromNext 		; get the fractional part back.
.bf33	20 14 bc	jsr $bc14			jsr 		FPFractionalPart 		; get the decimal part.
.bf36	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; any fractional part.
.bf39	70 3e		bvs $bf79			bvs 		_FPTOExit 				; if not, exit now.
.bf3b	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.bf3d	20 43 b9	jsr $b943			jsr 		ITSOutputCharacter
.bf40					_FPOutLoop:
.bf40	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; finally reached zero.
.bf43	70 1e		bvs $bf63			bvs 		_FPStripZeros 			; strip trailing zeros
.bf45	20 f0 bd	jsr $bdf0			jsr 		FPUTimes10 				; multiply by 10
.bf48	20 95 be	jsr $be95			jsr 		FPUCopyToNext			; copy to next slot.
.bf4b	20 88 bd	jsr $bd88			jsr 		FPUToInteger 			; convert to integer
.bf4e	bd 08 03	lda $0308,x			lda 		XS_Mantissa+0,x 		; print digit.
.bf51	09 30		ora #$30			ora 		#"0"
.bf53	20 43 b9	jsr $b943			jsr 		ITSOutputCharacter
.bf56	20 a4 be	jsr $bea4			jsr 		FPUCopyFromNext 		; get it back
.bf59	20 14 bc	jsr $bc14			jsr 		FPFractionalPart 		; get fractional part
.bf5c	ad 00 04	lda $0400			lda 		NumBufX 				; done 11 characters yet ?
.bf5f	c9 0b		cmp #$0b			cmp 	 	#11
.bf61	90 dd		bcc $bf40			bcc 		_FPOutLoop 				; if so, keep going till zero.
.bf63					_FPStripZeros:
.bf63	ac 00 04	ldy $0400			ldy 		NumBufX 				; strip trailing zeros.
.bf66					_FPStripLoop:
.bf66	88		dey				dey 								; back one, if at start then no strip
.bf67	f0 10		beq $bf79			beq 		_FPToExit
.bf69	b9 01 04	lda $0401,y			lda 		Num_Buffer,y 			; keep going if "0"
.bf6c	c9 30		cmp #$30			cmp 		#"0"
.bf6e	f0 f6		beq $bf66			beq 		_FPStripLoop
.bf70	c8		iny				iny
.bf71	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.bf73	99 01 04	sta $0401,y			sta 		Num_Buffer,y
.bf76	8c 00 04	sty $0400			sty 		NumBufX 				; update position.
.bf79					_FPTOExit:
.bf79	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.bf7a					FPFromString:
.bf7a	48		pha				pha 								; push A
.bf7b	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.bf7d	c9 2e		cmp #$2e			cmp 	#"."
.bf7f	f0 03		beq $bf84			beq	 	_FPFIsDecimal
.bf81	4c e7 bf	jmp $bfe7			jmp 	_FPFNotDecimal
.bf84					_FPFIsDecimal:
.bf84	c8		iny				iny 								; consume the decimal.
.bf85	20 29 bd	jsr $bd29			jsr 	FPUToFloat 					; convert the integer to float.
.bf88	da		phx				phx 								; save X.
.bf89	5a		phy				phy 								; save decimal start position
.bf8a	e8		inx				inx
.bf8b	e8		inx				inx
.bf8c	e8		inx				inx
.bf8d	e8		inx				inx
.bf8e	e8		inx				inx
.bf8f	e8		inx				inx
.bf90	20 5b b9	jsr $b95b			jsr 	INTFromStringY 				; get the part after the DP.
.bf93	20 29 bd	jsr $bd29			jsr 	FPUToFloat 					; convert that to a float.
.bf96	68		pla				pla 								; calculate - chars consumed.
.bf97	8c 23 04	sty $0423			sty 	ExpTemp
.bf9a	38		sec				sec
.bf9b	ed 23 04	sbc $0423			sbc 	ExpTemp 					; this is the shift amount
.bf9e	20 51 be	jsr $be51			jsr 	FPUScale10A 				; scale it by 10^AC
.bfa1	fa		plx				plx 								; restore original X
.bfa2	20 0b ba	jsr $ba0b			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.bfa5	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.bfa7	c9 45		cmp #$45			cmp 	#"E"
.bfa9	f0 04		beq $bfaf			beq 	_FPFExponent
.bfab	c9 65		cmp #$65			cmp 	#"e"
.bfad	d0 38		bne $bfe7			bne 	_FPFNotDecimal 				; no, then exit normally.
.bfaf					_FPFExponent:
.bfaf	c8		iny				iny 								; skip over E symbol.
.bfb0	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.bfb2	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.bfb4	d0 01		bne $bfb7			bne 	_FPFGotSign
.bfb6	c8		iny				iny 								; if it was - skip over it.
.bfb7					_FPFGotSign:
.bfb7	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.bfb8	da		phx				phx
.bfb9	e8		inx				inx
.bfba	e8		inx				inx
.bfbb	e8		inx				inx
.bfbc	e8		inx				inx
.bfbd	e8		inx				inx
.bfbe	e8		inx				inx
.bfbf	20 5b b9	jsr $b95b			jsr 	INTFromStringY 				; get the exponent
.bfc2	fa		plx				plx 								; restore X.
.bfc3	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.bfc6	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.bfc9	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.bfcc	d0 1b		bne $bfe9			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.bfce	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.bfd1	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.bfd3	b0 14		bcs $bfe9			bcs 	_FPFXOverflow
.bfd5	68		pla				pla 								; get direction
.bfd6	d0 09		bne $bfe1			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.bfd8	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.bfdb	49 ff		eor #$ff			eor 	#$FF
.bfdd	1a		inc a				inc 	a
.bfde	9d 0e 03	sta $030e,x			sta 	XS2_Mantissa+0,x
.bfe1					_FPFXScale:
.bfe1	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.bfe4	20 51 be	jsr $be51			jsr 	FPUScale10A 				; scale by the exponent.
.bfe7					_FPFNotDecimal:
.bfe7	68		pla				pla
.bfe8	60		rts				rts
.bfe9					_FPFXOverflow:
.bfe9	20 44 ab	jsr $ab44			jsr 	ERR_Handler
>bfec	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>bff4	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.bffb					Unary_Rnd:
.bffb	20 91 b0	jsr $b091			jsr 	EvaluateNumberX 			; get value
.bffe	20 20 b7	jsr $b720			jsr 	CheckNextRParen 			; check right bracket.
.c001	20 7e b3	jsr $b37e			jsr 	GetSignCurrent 				; get sign -1,0,1.
.c004	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.c006	30 10		bmi $c018			bmi 	_URSetSeed
.c008	f0 2c		beq $c036			beq 	_URMakeRandom 				; if zero return same number.
.c00a	da		phx				phx
.c00b	a2 00		ldx #$00			ldx 	#0
.c00d	20 73 c0	jsr $c073			jsr 	Random16
.c010	a2 02		ldx #$02			ldx 	#2
.c012	20 73 c0	jsr $c073			jsr 	Random16
.c015	fa		plx				plx
.c016	80 1e		bra $c036			bra 	_URMakeRandom
.c018					_URSetSeed:
.c018	20 29 bd	jsr $bd29			jsr 	FPUToFloat 					; make it a float to twiddle it.
.c01b	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.c01e	8d 2c 04	sta $042c			sta 	RandomSeed+0
.c021	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.c024	8d 2d 04	sta $042d			sta 	RandomSeed+1
.c027	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.c02a	8d 2e 04	sta $042e			sta 	RandomSeed+2
.c02d	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.c030	0a		asl a				asl 	a
.c031	49 db		eor #$db			eor 	#$DB
.c033	8d 2f 04	sta $042f			sta 	RandomSeed+3
.c036					_URMakeRandom:
.c036	ad 2c 04	lda $042c			lda 	RandomSeed+0 				; check if seed is zero.
.c039	0d 2d 04	ora $042d			ora 	RandomSeed+1
.c03c	0d 2e 04	ora $042e			ora 	RandomSeed+2
.c03f	0d 2f 04	ora $042f			ora 	RandomSeed+3
.c042	d0 0a		bne $c04e			bne 	_URNotZero
.c044	a9 47		lda #$47			lda 	#$47
.c046	8d 2d 04	sta $042d			sta 	RandomSeed+1				; if it is, make it non zero.
.c049	a9 3d		lda #$3d			lda 	#$3D
.c04b	8d 2f 04	sta $042f			sta 	RandomSeed+3
.c04e					_URNotZero:
.c04e	ad 2c 04	lda $042c			lda 	RandomSeed+0 				; copy seed into mantissa.
.c051	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.c054	ad 2d 04	lda $042d			lda 	RandomSeed+1
.c057	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.c05a	ad 2e 04	lda $042e			lda 	RandomSeed+2
.c05d	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.c060	ad 2f 04	lda $042f			lda 	RandomSeed+3
.c063	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.c066	a9 00		lda #$00			lda 	#$00 						; set type to float.
.c068	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.c06b	a9 80		lda #$80			lda 	#$80
.c06d	9d 0c 03	sta $030c,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.c070	4c 60 bd	jmp $bd60			jmp 	FPUNormalise
.c073					Random16:
.c073	5e 2d 04	lsr $042d,x			lsr 	RandomSeed+1,x				; shift seed right
.c076	7e 2c 04	ror $042c,x			ror 	RandomSeed,x
.c079	90 08		bcc $c083			bcc 	_R16_NoXor
.c07b	bd 2d 04	lda $042d,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.c07e	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.c080	9d 2d 04	sta $042d,x			sta 	RandomSeed+1,x
.c083					_R16_NoXor:
.c083	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.c084					Unary_Int:
.c084	20 91 b0	jsr $b091			jsr 	EvaluateNumberX 			; get value
.c087	20 20 b7	jsr $b720			jsr 	CheckNextRParen 			; check right bracket.
.c08a	4c 88 bd	jmp $bd88			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.c08d					TIM_Error:
.c08d	20 35 a0	jsr $a035			jsr 	IFT_UpLine 					; go up one line.
.c090	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.c092	80 02		bra $c096			bra 	TIM_ShowPrompt
.c094					TIM_NewCommand:
.c094	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.c096					TIM_ShowPrompt:
.c096	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.c099	20 06 a1	jsr $a106			jsr 	IFT_ReadLine	 			; get character, go to next line
.c09c	20 68 a0	jsr $a068			jsr 	IFT_NewLine					; go to next line.
.c09f	86 10		stx $10				stx 	zTemp1 						; save line read address
.c0a1	84 11		sty $11				sty 	zTemp1+1
.c0a3	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.c0a5	b1 10		lda ($10),y			lda 	(zTemp1),y
.c0a7	c9 3f		cmp #$3f			cmp 	#"?"
.c0a9	f0 04		beq $c0af			beq 	TIM_SkipFirst
.c0ab	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.c0ad	d0 01		bne $c0b0			bne 	TIM_NotDot
.c0af					TIM_SkipFirst:
.c0af	c8		iny				iny
.c0b0					TIM_NotDot:
.c0b0	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.c0b2	c9 52		cmp #$52			cmp 	#"R"						; show registers
.c0b4	f0 6e		beq $c124			beq 	TIM_ShowRegisters
.c0b6	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.c0b8	f0 12		beq $c0cc			beq 	TIM_ShowMemory
.c0ba	c9 47		cmp #$47			cmp 	#"G"						; execute
.c0bc	f0 49		beq $c107			beq 	TIM_Execute
.c0be	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.c0c0	f0 07		beq $c0c9			beq 	TIM_GoLoadMemory
.c0c2	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.c0c4	d0 c7		bne $c08d			bne 	TIM_Error
.c0c6	4c 49 c2	jmp $c249			jmp 	TIM_UpdateRegisters
.c0c9					TIM_GoLoadMemory:
.c0c9	4c 74 c2	jmp $c274			jmp 	TIM_LoadMemory
.c0cc					TIM_ShowMemory:
.c0cc	20 c2 c1	jsr $c1c2			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.c0cf	b0 bc		bcs $c08d			bcs 	TIM_Error
.c0d1	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.c0d3	85 12		sta $12				sta 	zTemp2
.c0d5	a5 15		lda $15				lda 	zTemp3+1
.c0d7	85 13		sta $13				sta 	zTemp2+1
.c0d9	20 c2 c1	jsr $c1c2			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.c0dc	90 08		bcc $c0e6			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.c0de	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.c0e0	85 14		sta $14				sta 	zTemp3
.c0e2	a5 13		lda $13				lda 	zTemp2+1
.c0e4	85 15		sta $15				sta 	zTemp3+1
.c0e6					_TIMSM_Start:
.c0e6	20 9a c1	jsr $c19a			jsr 	TIM_WriteLine 				; write one line of hex out
.c0e9	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.c0eb	18		clc				clc
.c0ec	69 10		adc #$10			adc 	#16
.c0ee	85 12		sta $12				sta 	zTemp2
.c0f0	90 02		bcc $c0f4			bcc 	_TIMSM_NoCarry
.c0f2	e6 13		inc $13				inc 	zTemp2+1
.c0f4					_TIMSM_NoCarry:
.c0f4	20 f1 a1	jsr $a1f1			jsr 	IF_CheckBreak 				; check CTL+C
.c0f7	d0 0b		bne $c104			bne 	_TIMSM_Ends 				; if pressed break out.
.c0f9	38		sec				sec 								; check past the end address in zTemp3
.c0fa	a5 14		lda $14				lda 	zTemp3
.c0fc	e5 12		sbc $12				sbc 	zTemp2
.c0fe	a5 15		lda $15				lda 	zTemp3+1
.c100	e5 13		sbc $13				sbc 	zTemp2+1
.c102	10 e2		bpl $c0e6			bpl 	_TIMSM_Start
.c104					_TIMSM_Ends:
.c104	4c 94 c0	jmp $c094			jmp 	TIM_NewCommand
.c107					TIM_Execute:
.c107	20 c2 c1	jsr $c1c2			jsr 	TIM_GetHex 					; get the execute address
.c10a	b0 81		bcs $c08d			bcs 	TIM_Error 					; not legitimate
.c10c	ae 39 04	ldx $0439			ldx 	TIM_SP 						; set up SP
.c10f	9a		txs				txs
.c110	ad 34 04	lda $0434			lda 	TIM_SR 						; Status for PLP
.c113	48		pha				pha
.c114	ad 35 04	lda $0435			lda 	TIM_A 						; restore AXYZ
.c117	ae 36 04	ldx $0436			ldx 	TIM_X
.c11a	ac 37 04	ldy $0437			ldy 	TIM_Y
.c11d	ab 38 04	ldz $0438			ldz 	TIM_Z
.c120	28		plp				plp 								; and PS Byte.
.c121	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.c124					TIM_Start:
.c124					TIM_ShowRegisters:
.c124	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.c127	8d 33 04	sta $0433			sta 	TIM_IRQ+1
.c12a	ad ff ff	lda $ffff			lda 	$FFFF
.c12d	8d 32 04	sta $0432			sta 	TIM_IRQ
.c130	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.c132					_TIMSR_Text:
.c132	bd 5e c1	lda $c15e,x			lda 	_TIMSR_Label,x
.c135	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.c138	e8		inx				inx
.c139	e0 23		cpx #$23			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.c13b	d0 f5		bne $c132			bne 	_TIMSR_Text
.c13d	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.c13f					_TIMSR_Skip:
.c13f	e8		inx				inx
.c140					_TIMSR_LoopSpace:
.c140	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.c142	b0 04		bcs $c148			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.c144	8a		txa				txa
.c145	4a		lsr a				lsr 	a
.c146	b0 05		bcs $c14d			bcs 	_TIMSR_NoSpace
.c148					_TIMSR_Space:
.c148	a9 20		lda #$20			lda 	#" "
.c14a	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.c14d					_TIMSR_NoSpace:
.c14d	bd 30 04	lda $0430,x			lda 	TIM_PC,x 					; output hex value.
.c150	20 81 c1	jsr $c181			jsr 	TIM_WriteHex
.c153	e8		inx				inx
.c154	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.c156	d0 e8		bne $c140			bne 	_TimSR_LoopSpace
.c158	20 68 a0	jsr $a068			jsr 	IFT_NewLine 				; new line
.c15b	4c 94 c0	jmp $c094			jmp	 	TIM_NewCommand 				; new command.
.c15e					_TIMSR_Label:
>c15e	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>c166	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>c176	52
>c177	20 5a 52					.text 	" ZR"
>c17a	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.c181					_TIMSR_LabelEnd:
.c181					TIM_WriteHex:
.c181	48		pha				pha 								; save A
.c182	4a		lsr a				lsr 	a 							; shift MSB->LSB
.c183	4a		lsr a				lsr 	a
.c184	4a		lsr a				lsr 	a
.c185	4a		lsr a				lsr 	a
.c186	20 8a c1	jsr $c18a			jsr 	_TIMWH_Nibble 				; print MSB
.c189	68		pla				pla 								; restore and print LSB
.c18a					_TIMWH_Nibble:
.c18a	48		pha				pha
.c18b	29 0f		and #$0f			and 	#15 						; mask out
.c18d	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.c18f	90 02		bcc $c193			bcc 	_TIMWHNoLetter
.c191	69 06		adc #$06			adc 	#6
.c193					_TIMWHNoLetter:
.c193	69 30		adc #$30			adc 	#48
.c195	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter 			; print it out.
.c198	68		pla				pla
.c199	60		rts				rts
.c19a					TIM_WriteLine:
.c19a	a9 2e		lda #$2e			lda 	#"." 						; prompt
.c19c	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.c19f	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.c1a1	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.c1a4	a5 13		lda $13				lda 	zTemp2+1 					; write address
.c1a6	20 81 c1	jsr $c181			jsr 	TIM_WriteHex
.c1a9	a5 12		lda $12				lda 	zTemp2
.c1ab	20 81 c1	jsr $c181			jsr 	TIM_WriteHex
.c1ae	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.c1b0					_TIMWL_Loop:
.c1b0	a9 20		lda #$20			lda 	#" "
.c1b2	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.c1b5	b1 12		lda ($12),y			lda 	(zTemp2),y
.c1b7	20 81 c1	jsr $c181			jsr 	TIM_WriteHex
.c1ba	c8		iny				iny
.c1bb	c0 10		cpy #$10			cpy 	#16
.c1bd	d0 f1		bne $c1b0			bne 	_TIMWL_Loop
.c1bf	4c 68 a0	jmp $a068			jmp 	IFT_NewLine 				; new line and exit
.c1c2					TIM_GetHex:
.c1c2	c8		iny				iny
.c1c3	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.c1c5	c9 20		cmp #$20			cmp 	#32
.c1c7	f0 f9		beq $c1c2			beq 	TIM_GetHex
.c1c9	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.c1cb	f0 f5		beq $c1c2			beq 	TIM_GetHex
.c1cd	20 f6 c1	jsr $c1f6			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.c1d0	b0 23		bcs $c1f5			bcs 	_TIMGH_Exit					; if first bad then exit now.
.c1d2	a9 00		lda #$00			lda 	#0 							; zero result
.c1d4	85 14		sta $14				sta 	zTemp3
.c1d6	85 15		sta $15				sta 	zTemp3+1
.c1d8					_TIM_GHLoop:
.c1d8	20 f6 c1	jsr $c1f6			jsr 	TIM_GetHexCharacter 		; get next character
.c1db	b0 17		bcs $c1f4			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.c1dd	c8		iny				iny 								; skip over it.
.c1de	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.c1e0	26 15		rol $15				rol 	zTemp3+1
.c1e2	06 14		asl $14				asl 	zTemp3 						; now x 2
.c1e4	26 15		rol $15				rol 	zTemp3+1
.c1e6	06 14		asl $14				asl 	zTemp3						; now x 4
.c1e8	26 15		rol $15				rol 	zTemp3+1
.c1ea	06 14		asl $14				asl 	zTemp3 						; now x 8
.c1ec	26 15		rol $15				rol 	zTemp3+1
.c1ee	05 14		ora $14				ora 	zTemp3 						; OR result in
.c1f0	85 14		sta $14				sta 	zTemp3
.c1f2	80 e4		bra $c1d8			bra 	_TIM_GHLoop 				; loop round again.
.c1f4					_TIMGH_Okay:
.c1f4	18		clc				clc
.c1f5					_TIMGH_Exit:
.c1f5	60		rts				rts
.c1f6					TIM_GetHexCharacter:
.c1f6	b1 10		lda ($10),y			lda 	(zTemp1),y
.c1f8	38		sec				sec
.c1f9	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.c1fb	90 0e		bcc $c20b			bcc 	_TIM_GHCFail
.c1fd	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.c1ff	90 0b		bcc $c20c			bcc 	_TIM_GHCExit
.c201	c9 11		cmp #$11			cmp 	#65-48						; < A
.c203	90 06		bcc $c20b			bcc		_TIM_GHCFail
.c205	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.c207	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.c209	90 01		bcc $c20c			bcc		_TIM_GHCExit
.c20b					_TIM_GHCFail:
.c20b	38		sec				sec
.c20c					_TIM_GHCExit:
.c20c	60		rts				rts
.c20d					TIM_BreakVector:
.c20d	da		phx				phx									; save X/A on stack
.c20e	48		pha				pha
.c20f	ba		tsx				tsx 								; X points to S
.c210	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.c213	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.c215	d0 03		bne $c21a			bne 	_TIMBreak					; if set, it's BRK
.c217	68		pla				pla 								; abandon routine.
.c218	fa		plx				plx
.c219	40		rti				rti
.c21a					_TIMBreak:
.c21a	68		pla				pla 								; save A X Y and maybe Z
.c21b	8d 35 04	sta $0435			sta 	TIM_A
.c21e	fa		plx				plx
.c21f	8e 36 04	stx $0436			stx 	TIM_X
.c222	8c 37 04	sty $0437			sty 	TIM_Y
.c225	9c 38 04	stz $0438			stz 	TIM_Z
.c228	68		pla				pla 								; get Status Register
.c229	8d 34 04	sta $0434			sta 	TIM_SR
.c22c	68		pla				pla
.c22d	8d 31 04	sta $0431			sta 	TIM_PC+1 					; save calling address
.c230	68		pla				pla
.c231	8d 30 04	sta $0430			sta 	TIM_PC 						; high byte
.c234	ad 31 04	lda $0431			lda 	TIM_PC+1 					; dec PC to point right.
.c237	d0 03		bne $c23c			bne 	_TIMDecrement 				; brk bumps it.
.c239	ce 30 04	dec $0430			dec 	TIM_PC
.c23c					_TIMDecrement:
.c23c	ce 31 04	dec $0431			dec 	TIM_PC+1
.c23f	ba		tsx				tsx 								; and copy SP
.c240	8e 39 04	stx $0439			stx 	TIM_SP
.c243	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.c245	9a		txs				txs
.c246	4c 24 c1	jmp $c124			jmp 	TIM_Start 					; and start up TIM monitor.
.c249					TIM_UpdateRegisters:
.c249	20 c2 c1	jsr $c1c2			jsr 	TIM_GetHex 					; PC
.c24c	b0 23		bcs $c271			bcs 	_TIMURFail
.c24e	a5 14		lda $14				lda 	zTemp3
.c250	8d 31 04	sta $0431			sta 	Tim_PC+1
.c253	a5 15		lda $15				lda 	zTemp3+1
.c255	8d 30 04	sta $0430			sta 	Tim_PC
.c258	20 c2 c1	jsr $c1c2			jsr 	TIM_GetHex 					; ignore IRQ
.c25b	b0 14		bcs $c271			bcs 	_TIMURFail
.c25d	a2 00		ldx #$00			ldx 	#0
.c25f					_TIM_URLoop:
.c25f	20 c2 c1	jsr $c1c2			jsr 	TIM_GetHex 					; registers
.c262	b0 0d		bcs $c271			bcs 	_TIMURFail
.c264	a5 14		lda $14				lda 	zTemp3
.c266	9d 34 04	sta $0434,x			sta 	Tim_SR,x
.c269	e8		inx				inx
.c26a	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.c26c	d0 f1		bne $c25f			bne 	_TIM_URLoop
.c26e	4c 94 c0	jmp $c094			jmp 	TIM_NewCommand
.c271					_TIMURFail:
.c271	4c 8d c0	jmp $c08d			jmp 	TIM_Error
.c274					TIM_LoadMemory:
.c274	20 c2 c1	jsr $c1c2			jsr 	TIM_GetHex 					; target address => zTemp2
.c277	a5 14		lda $14				lda 	zTemp3
.c279	85 12		sta $12				sta 	zTemp2
.c27b	a5 15		lda $15				lda 	zTemp3+1
.c27d	85 13		sta $13				sta 	zTemp2+1
.c27f					_TIM_LMLoop:
.c27f	20 c2 c1	jsr $c1c2			jsr 	TIM_GetHex 					; next byte ?
.c282	b0 0e		bcs $c292			bcs 	_TIMLMDone 					; no more
.c284	a2 00		ldx #$00			ldx 	#0							; write out.
.c286	a5 14		lda $14				lda 	zTemp3
.c288	81 12		sta ($12,x)			sta 	(zTemp2,x)
.c28a	e6 12		inc $12				inc 	zTemp2 						; bump address
.c28c	d0 f1		bne $c27f			bne 	_TIM_LMLoop
.c28e	e6 13		inc $13				inc 	zTemp2+1
.c290	80 ed		bra $c27f			bra 	_TIM_LMLoop
.c292					_TIMLMDone:
.c292	4c 94 c0	jmp $c094			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Return to file: basic.asm

.c295	80 fe		bra $c295	_halt:	bra 		_halt
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 a0						.word 	StartROM
>fffe	0d c2					.word TIM_BreakVector

;******  End of listing
