
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -Wall -b -q -L rom.lst -o rom.bin basic.asm
; Wed Sep  4 17:20:00 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="65816"				cpu = "65816"
="em65816"				hardware = "em65816"
=1					exitonend = 1
=1					autorun = 1
=2					loadtest = 2
=1					hasfloat = 1
=1					hasinteger = 1
=253					maxstring = 253

;******  Processing file: modules/basic/pointer/em65816/src_em65816.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stackmarkers.inc

=5					SourcePosSize   =   5 							; Source position stack space needed.
=1					SMark_Gosub 	= 	1 							; 0 is GOSUB/RETURN.
=2					SMark_Repeat 	= 	2 							; 1 is REPEAT/UNTIL.
=3					SMark_While 	= 	3 							; 2 is WHILE/WEND.
=4					SMark_If 		= 	4 							; 3 is IF/ENDIF
=5					SMark_For 		= 	5 							; 4 is FOR/NEXT

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/hardware/common/macros32.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zTemp4: 	.word ?
>0018					zCodePtr:	.dword ? 						; code pointer (long)
>001c					zLTemp1:	.dword ?						; long word (used in multiply)
>0020					zGenPtr:	.word ? 						; general pointer.
>0022					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0024					zVarDataPtr: .word ? 						; position of variable data.
>0026					zVarType: 	.byte ? 						; type of data (token)
>0027					zNullString:.byte ? 						; represents a NULL string.
>0028					zBasicSP:	.word ? 						; stack pointer
>0080					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>0084					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>0085					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=134					XS2_Mantissa = XS_Mantissa+XS_Size
=138					XS2_Exponent = XS_Exponent+XS_Size
=139					XS2_Type = XS_Type+XS_Size
=140					XS3_Mantissa = XS_Mantissa+XS_Size*2
=144					XS3_Exponent = XS_Exponent+XS_Size*2
=145					XS3_Type = XS_Type+XS_Size*2
>0300					StringPtr:	.word ? 						; Top of free memory (for string allocation)
>0302					VarMemPtr: 	.word ?							; Bottom of free memory (for variables)
>0304					endOfProgram: .dword ? 						; End of Program Memory (long)
>0308					vecPrintCharacter .word ?
>030a					vecInputCharacter .word ?
>030c					UserVector .fill 4 							; USR(x) calls this.
>0310					LocalVector .fill 4 						; Indirect calls call this.
>0314					NumBufX 	.byte 	?						; buffer index position
>0315					Num_Buffer	.fill 	32 						; buffer for numeric conversions
=6					HashTableCount = 6 							; there are 6 hash tables, in token order.
=8					HashTableSize = 8 							; each hash table as 8 links.
.0335					HashTableBase:
>0335								.fill	HashTableCount * HashTableSize * 2
.0395					HashTableEnd:
=$315					Var_Buffer 	= Num_Buffer 					; buffer for variable name (same space)
>0395					Var_Type    .byte ? 						; type of variable (as a type token)
>0396					Var_Hash 	.byte ? 						; hash of identifier name.
>0397					Var_Length 	.byte ? 						; length of variable name
>0398					Var_HashAddress .byte ?						; low byte of hash table entry.
>0399					Var_DataSize .byte ?						; size of one element.
>039a					NumSuppress	.byte 	?						; leading zero suppression flag
>039b					NumConvCount .byte 	? 						; count for conversions.
>039c					ExpTemp:	.byte ?							; Working temp for exponents.
>039d					ExpCount:	.byte ? 						; Count of decimal exponents.
>039e					SignCount:	.byte ?							; Integer Divide Sign Counts.
>039f					TempStringWriteIndex: .byte ? 				; Write offset.
>03a0					ValSign: 	.byte ? 						; sign flag for val()
>03a1					SliceStart:	.byte ? 						; string slice parts
>03a2					SliceCount:	.byte ?
>03a3					RandomSeed:	.dword ? 						; Random seed.
>03a7					SignNext:	.byte ? 						; Used for keeping sign of STEP in FOR/NEXT
>03a8					BreakCount:	.byte ? 						; Counter, avoid checking break every command.
=3					ArrayMaxDim = 3 							; number of dimensions.
>03a9					ArrayDef:	.fill (ArrayMaxDim+1)*2 		; dimensions for auto-creation
>03b1					UsrArrayDef:.fill (ArrayMaxDim+1)*2 		; dimensions created in DIM
>03b9					UsrArrayIdx:.byte ? 						; index into UsrArrayDef
>03ba					LastPrinted:.byte ? 						; last printed char ?
>03bb					ListIndent: .byte ? 						; list indent level
>03bc					LastListIndent:.byte ? 						; previous one.
>03bd					DataLPtr: 	.dword ?						; the data long ptr (swapped with zCodePtr)
>03c1					DataIndex:	.byte ?							; index position.
>03c2					InputAvailable: .byte ? 					; characters available in input buffer.
>03c3					InputRetry:	.byte ? 						; true if INPUT is retrying.
>03c4					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>03c6					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>03c8					Tim_SR:		.byte ? 						; Processor Status
>03c9					Tim_A:		.byte ? 						; Processor Registers
>03ca					Tim_X:		.byte ?
>03cb					Tim_Y:		.byte ?
>03cc					Tim_Z:		.byte ?
>03cd					Tim_SP:		.word ?							; Stack Pointer (just in cases)
.0400					TokeniseBuffer:
>0400								.fill 	256
>0500					IFT_XCursor:.byte ?							; current logical position on screen
>0501					IFT_YCursor:.byte ?
>0502					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0566					IFT_LineBuffer: .fill 100 					; line input buffer.
>05ca					BasicStack:	.fill 	256 					; and occupy whole pages.
.06ca					EndBasicStack:

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/em65816.asm

=$7f00					HighMemory = $7F00
=$3000					VariableMemory = $3000
.1000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testing.src

>1000	19 0a 00 dc bd 40 fd 03			.byte	$19,$0a,$00,$dc,$bd,$40,$fd,$03
>1008	30 8d 41 74 43 72 fd 04			.byte	$30,$8d,$41,$74,$43,$72,$fd,$04
>1010	38 32 be 84 40 fd 03 30			.byte	$38,$32,$be,$84,$40,$fd,$03,$30
>1018	00 10 14 00 dc bd 40 8d			.byte	$00,$10,$14,$00,$dc,$bd,$40,$8d
>1020	8b 41 70 48 56 be 84 40			.byte	$8b,$41,$70,$48,$56,$be,$84,$40
>1028	00 14 1e 00 dc bd 40 82			.byte	$00,$14,$1e,$00,$dc,$bd,$40,$82
>1030	8b 41 4a 5b 66 be 84 8b			.byte	$8b,$41,$4a,$5b,$66,$be,$84,$8b
>1038	41 4a 5b 66 00 0c 28 00			.byte	$41,$4a,$5b,$66,$00,$0c,$28,$00
>1040	dc bd 9a 40 be be 84 40			.byte	$dc,$bd,$9a,$40,$be,$be,$84,$40
>1048	00 1d 32 00 dc bd a0 fe			.byte	$00,$1d,$32,$00,$dc,$bd,$a0,$fe
>1050	0a 62 6d 70 67 62 75 64			.byte	$0a,$62,$6d,$70,$67,$62,$75,$64
>1058	79 bf 45 be be 84 fe 07			.byte	$79,$bf,$45,$be,$be,$84,$fe,$07
>1060	62 6d 70 67 62 00 1c 3c			.byte	$62,$6d,$70,$67,$62,$00,$1c,$3c
>1068	00 dc bd 41 6a 7a 6b fd			.byte	$00,$dc,$bd,$41,$6a,$7a,$6b,$fd
>1070	04 37 32 85 8b 43 6b 4b			.byte	$04,$37,$32,$85,$8b,$43,$6b,$4b
>1078	55 fd 04 31 32 be 84 8b			.byte	$55,$fd,$04,$31,$32,$be,$84,$8b
>1080	41 00 13 46 00 dc bd 41			.byte	$41,$00,$13,$46,$00,$dc,$bd,$41
>1088	7a 55 6c 86 8b 42 6f 56			.byte	$7a,$55,$6c,$86,$8b,$42,$6f,$56
>1090	40 be 84 40 00 12 50 00			.byte	$40,$be,$84,$40,$00,$12,$50,$00
>1098	dc bd 40 82 43 61 5e 46			.byte	$dc,$bd,$40,$82,$43,$61,$5e,$46
>10a0	be 84 43 61 5e 46 00 11			.byte	$be,$84,$43,$61,$5e,$46,$00,$11
>10a8	5a 00 dc bd b3 8b 42 42			.byte	$5a,$00,$dc,$bd,$b3,$8b,$42,$42
>10b0	77 64 be be 84 8b 41 00			.byte	$77,$64,$be,$be,$84,$8b,$41,$00
>10b8	14 64 00 dc bd a1 fe 05			.byte	$14,$64,$00,$dc,$bd,$a1,$fe,$05
>10c0	6f 74 61 bf 41 be be 84			.byte	$6f,$74,$61,$bf,$41,$be,$be,$84
>10c8	fe 03 61 00 25 6e 00 dc			.byte	$fe,$03,$61,$00,$25,$6e,$00,$dc
>10d0	bd 5d 71 5f fd 04 38 35			.byte	$bd,$5d,$71,$5f,$fd,$04,$38,$35
>10d8	8c 5d 71 5f fd 04 38 35			.byte	$8c,$5d,$71,$5f,$fd,$04,$38,$35
>10e0	be 84 41 fd 0d 34 38 37			.byte	$be,$84,$41,$fd,$0d,$34,$38,$37
>10e8	32 32 35 33 35 45 31 30			.byte	$32,$32,$35,$33,$35,$45,$31,$30
>10f0	00 15 78 00 dc bd 43 60			.byte	$00,$15,$78,$00,$dc,$bd,$43,$60
>10f8	7e 47 8a 41 69 49 5a be			.byte	$7e,$47,$8a,$41,$69,$49,$5a,$be
>1100	84 45 4a 47 61 00 16 82			.byte	$84,$45,$4a,$47,$61,$00,$16,$82
>1108	00 dc bd 42 6b 77 41 82			.byte	$00,$dc,$bd,$42,$6b,$77,$41,$82
>1110	8b 57 6b 5a be 84 8b 42			.byte	$8b,$57,$6b,$5a,$be,$84,$8b,$42
>1118	7c 5c 59 00 18 8c 00 dc			.byte	$7c,$5c,$59,$00,$18,$8c,$00,$dc
>1120	bd b2 8b 42 6a 6f 5b bf			.byte	$bd,$b2,$8b,$42,$6a,$6f,$5b,$bf
>1128	8b 42 4f 7d 49 be be 84			.byte	$8b,$42,$4f,$7d,$49,$be,$be,$84
>1130	5a 72 52 00 1b 96 00 dc			.byte	$5a,$72,$52,$00,$1b,$96,$00,$dc
>1138	bd a2 fe 0a 72 6d 6f 66			.byte	$bd,$a2,$fe,$0a,$72,$6d,$6f,$66
>1140	63 64 68 76 bf 41 bf 41			.byte	$63,$64,$68,$76,$bf,$41,$bf,$41
>1148	be be 84 fe 03 72 00 1c			.byte	$be,$be,$84,$fe,$03,$72,$00,$1c
>1150	a0 00 dc bd 8b 4a 67 68			.byte	$a0,$00,$dc,$bd,$8b,$4a,$67,$68
>1158	fd 05 38 31 33 86 8b 43			.byte	$fd,$05,$38,$31,$33,$86,$8b,$43
>1160	62 5e 69 fd 04 38 39 be			.byte	$62,$5e,$69,$fd,$04,$38,$39,$be
>1168	84 40 00 15 aa 00 dc bd			.byte	$84,$40,$00,$15,$aa,$00,$dc,$bd
>1170	8b 41 6c 56 70 8a 42 5a			.byte	$8b,$41,$6c,$56,$70,$8a,$42,$5a
>1178	55 6d be 84 6d 7e 7d 00			.byte	$55,$6d,$be,$84,$6d,$7e,$7d,$00
>1180	14 b4 00 dc bd 40 81 8b			.byte	$14,$b4,$00,$dc,$bd,$40,$81,$8b
>1188	42 67 56 73 be 84 8b 42			.byte	$42,$67,$56,$73,$be,$84,$8b,$42
>1190	67 56 73 00 0c be 00 dc			.byte	$67,$56,$73,$00,$0c,$be,$00,$dc
>1198	bd 98 40 be 84 8b 41 00			.byte	$bd,$98,$40,$be,$84,$8b,$41,$00
>11a0	16 c8 00 dc bd a6 fe 0b			.byte	$16,$c8,$00,$dc,$bd,$a6,$fe,$0b
>11a8	67 68 63 76 75 72 66 74			.byte	$67,$68,$63,$76,$75,$72,$66,$74
>11b0	7a be be 84 49 00 17 d2			.byte	$7a,$be,$be,$84,$49,$00,$17,$d2
>11b8	00 dc bd 40 fd 03 30 86			.byte	$00,$dc,$bd,$40,$fd,$03,$30,$86
>11c0	42 66 4f 69 fd 04 38 36			.byte	$42,$66,$4f,$69,$fd,$04,$38,$36
>11c8	be 84 8b 41 00 12 dc 00			.byte	$be,$84,$8b,$41,$00,$12,$dc,$00
>11d0	dc bd 8b 42 7c 53 44 84			.byte	$dc,$bd,$8b,$42,$7c,$53,$44,$84
>11d8	6a 7c 53 be 84 40 00 18			.byte	$6a,$7c,$53,$be,$84,$40,$00,$18
>11e0	e6 00 dc bd 8b 41 47 40			.byte	$e6,$00,$dc,$bd,$8b,$41,$47,$40
>11e8	74 80 8b 43 66 46 78 be			.byte	$74,$80,$8b,$43,$66,$46,$78,$be
>11f0	84 8b 43 67 46 78 00 1e			.byte	$84,$8b,$43,$67,$46,$78,$00,$1e
>11f8	f0 00 dc bd a5 a4 8b 42			.byte	$f0,$00,$dc,$bd,$a5,$a4,$8b,$42
>1200	69 62 61 fd 04 36 36 be			.byte	$69,$62,$61,$fd,$04,$36,$36,$be
>1208	be be 84 8b 42 69 62 61			.byte	$be,$be,$84,$8b,$42,$69,$62,$61
>1210	fd 04 36 36 00 0f fa 00			.byte	$fd,$04,$36,$36,$00,$0f,$fa,$00
>1218	dc bd 9b fe 03 63 be be			.byte	$dc,$bd,$9b,$fe,$03,$63,$be,$be
>1220	84 41 63 00 1c 04 01 dc			.byte	$84,$41,$63,$00,$1c,$04,$01,$dc
>1228	bd 41 76 75 61 fd 04 38			.byte	$bd,$41,$76,$75,$61,$fd,$04,$38
>1230	39 89 8b 43 4d 4d 69 fd			.byte	$39,$89,$8b,$43,$4d,$4d,$69,$fd
>1238	04 39 39 be 84 8b 41 00			.byte	$04,$39,$39,$be,$84,$8b,$41,$00
>1240	0f 0e 01 dc bd 40 88 41			.byte	$0f,$0e,$01,$dc,$bd,$40,$88,$41
>1248	55 5c 4f be 84 40 00 14			.byte	$55,$5c,$4f,$be,$84,$40,$00,$14
>1250	18 01 dc bd 5a 4f 56 81			.byte	$18,$01,$dc,$bd,$5a,$4f,$56,$81
>1258	8b 4b 42 54 be 84 8b 41			.byte	$8b,$4b,$42,$54,$be,$84,$8b,$41
>1260	40 42 00 11 22 01 dc bd			.byte	$40,$42,$00,$11,$22,$01,$dc,$bd
>1268	9a 8b 60 5b 4a be be 84			.byte	$9a,$8b,$60,$5b,$4a,$be,$be,$84
>1270	60 5b 4a 00 0f 2c 01 dc			.byte	$60,$5b,$4a,$00,$0f,$2c,$01,$dc
>1278	bd b4 41 72 be be 84 fe			.byte	$bd,$b4,$41,$72,$be,$be,$84,$fe
>1280	03 72 00 1b 36 01 dc bd			.byte	$03,$72,$00,$1b,$36,$01,$dc,$bd
>1288	8b 41 43 4e 71 fd 03 33			.byte	$8b,$41,$43,$4e,$71,$fd,$03,$33
>1290	86 4c 48 4e fd 05 35 37			.byte	$86,$4c,$48,$4e,$fd,$05,$35,$37
>1298	34 be 84 8b 41 00 16 40			.byte	$34,$be,$84,$8b,$41,$00,$16,$40
>12a0	01 dc bd 8b 42 45 76 57			.byte	$01,$dc,$bd,$8b,$42,$45,$76,$57
>12a8	8b 8b 42 75 4f 69 be 84			.byte	$8b,$8b,$42,$75,$4f,$69,$be,$84
>12b0	6f 59 52 00 16 4a 01 dc			.byte	$6f,$59,$52,$00,$16,$4a,$01,$dc
>12b8	bd 43 5f 7b 55 82 8b 43			.byte	$bd,$43,$5f,$7b,$55,$82,$8b,$43
>12c0	66 7c 75 be 84 8b 79 47			.byte	$66,$7c,$75,$be,$84,$8b,$79,$47
>12c8	62 00 10 54 01 dc bd b3			.byte	$62,$00,$10,$54,$01,$dc,$bd,$b3
>12d0	8b 66 53 48 be be 84 8b			.byte	$8b,$66,$53,$48,$be,$be,$84,$8b
>12d8	41 00 0f 5e 01 dc bd a3			.byte	$41,$00,$0f,$5e,$01,$dc,$bd,$a3
>12e0	42 be be 84 fe 04 20 20			.byte	$42,$be,$be,$84,$fe,$04,$20,$20
>12e8	00 25 68 01 dc bd 42 6b			.byte	$00,$25,$68,$01,$dc,$bd,$42,$6b
>12f0	43 48 fd 03 33 8d 8b 43			.byte	$43,$48,$fd,$03,$33,$8d,$8b,$43
>12f8	41 51 71 fd 04 31 31 be			.byte	$41,$51,$71,$fd,$04,$31,$31,$be
>1300	84 8b 40 fd 0a 38 38 34			.byte	$84,$8b,$40,$fd,$0a,$38,$38,$34
>1308	39 39 30 37 35 00 14 72			.byte	$39,$39,$30,$37,$35,$00,$14,$72
>1310	01 dc bd 8b 41 58 73 4e			.byte	$01,$dc,$bd,$8b,$41,$58,$73,$4e
>1318	8d 8b 43 40 77 54 be 84			.byte	$8d,$8b,$43,$40,$77,$54,$be,$84
>1320	40 00 16 7c 01 dc bd 8b			.byte	$40,$00,$16,$7c,$01,$dc,$bd,$8b
>1328	41 5f 7d 49 82 8b 41 7d			.byte	$41,$5f,$7d,$49,$82,$8b,$41,$7d
>1330	46 53 be 84 62 7b 5a 00			.byte	$46,$53,$be,$84,$62,$7b,$5a,$00
>1338	18 86 01 dc bd b2 41 61			.byte	$18,$86,$01,$dc,$bd,$b2,$41,$61
>1340	5e 5f bf 8b 41 6c 47 49			.byte	$5e,$5f,$bf,$8b,$41,$6c,$47,$49
>1348	be be 84 41 61 5e 5f 00			.byte	$be,$be,$84,$41,$61,$5e,$5f,$00
>1350	15 90 01 dc bd a7 41 6d			.byte	$15,$90,$01,$dc,$bd,$a7,$41,$6d
>1358	7e 6d be be 84 fe 07 36			.byte	$7e,$6d,$be,$be,$84,$fe,$07,$36
>1360	44 46 41 44 00 1d 9a 01			.byte	$44,$46,$41,$44,$00,$1d,$9a,$01
>1368	dc bd 8b 41 46 59 52 fd			.byte	$dc,$bd,$8b,$41,$46,$59,$52,$fd
>1370	04 34 32 89 8b 42 69 41			.byte	$04,$34,$32,$89,$8b,$42,$69,$41
>1378	70 fd 04 36 34 be 84 8b			.byte	$70,$fd,$04,$36,$34,$be,$84,$8b
>1380	41 00 14 a4 01 dc bd 8b			.byte	$41,$00,$14,$a4,$01,$dc,$bd,$8b
>1388	43 54 58 7c 8d 43 49 58			.byte	$43,$54,$58,$7c,$8d,$43,$49,$58
>1390	6f be 84 8b 41 00 15 ae			.byte	$6f,$be,$84,$8b,$41,$00,$15,$ae
>1398	01 dc bd 41 61 65 78 80			.byte	$01,$dc,$bd,$41,$61,$65,$78,$80
>13a0	41 71 7a 5b be 84 41 61			.byte	$41,$71,$7a,$5b,$be,$84,$41,$61
>13a8	60 58 00 12 b8 01 dc bd			.byte	$60,$58,$00,$12,$b8,$01,$dc,$bd
>13b0	98 42 6d 5e 5b be 84 8b			.byte	$98,$42,$6d,$5e,$5b,$be,$84,$8b
>13b8	42 6d 5e 5c 00 15 c2 01			.byte	$42,$6d,$5e,$5c,$00,$15,$c2,$01
>13c0	dc bd af fe 07 34 34 38			.byte	$dc,$bd,$af,$fe,$07,$34,$34,$38
>13c8	36 38 be be 84 41 44 61			.byte	$36,$38,$be,$be,$84,$41,$44,$61
>13d0	68 00 1b cc 01 dc bd 8b			.byte	$68,$00,$1b,$cc,$01,$dc,$bd,$8b
>13d8	42 56 46 74 fd 04 37 35			.byte	$42,$56,$46,$74,$fd,$04,$37,$35
>13e0	84 43 61 5c 72 fd 04 37			.byte	$84,$43,$61,$5c,$72,$fd,$04,$37
>13e8	33 be 84 40 00 15 d6 01			.byte	$33,$be,$84,$40,$00,$15,$d6,$01
>13f0	dc bd 8b 42 5f 69 4b 85			.byte	$dc,$bd,$8b,$42,$5f,$69,$4b,$85
>13f8	8b 43 74 40 7d be 84 8b			.byte	$8b,$43,$74,$40,$7d,$be,$84,$8b
>1400	41 00 13 e0 01 dc bd 6d			.byte	$41,$00,$13,$e0,$01,$dc,$bd,$6d
>1408	5c 6c 80 43 66 72 61 be			.byte	$5c,$6c,$80,$43,$66,$72,$61,$be
>1410	84 64 50 60 00 14 ea 01			.byte	$84,$64,$50,$60,$00,$14,$ea,$01
>1418	dc bd a5 a4 41 42 5b 6c			.byte	$dc,$bd,$a5,$a4,$41,$42,$5b,$6c
>1420	be be be 84 41 42 5b 6c			.byte	$be,$be,$be,$84,$41,$42,$5b,$6c
>1428	00 18 f4 01 dc bd a0 fe			.byte	$00,$18,$f4,$01,$dc,$bd,$a0,$fe
>1430	06 69 76 77 71 bf 48 be			.byte	$06,$69,$76,$77,$71,$bf,$48,$be
>1438	be 84 fe 06 69 76 77 71			.byte	$be,$84,$fe,$06,$69,$76,$77,$71
>1440	00 1c fe 01 dc bd 8b 42			.byte	$00,$1c,$fe,$01,$dc,$bd,$8b,$42
>1448	7c 7d 4e fd 04 36 33 87			.byte	$7c,$7d,$4e,$fd,$04,$36,$33,$87
>1450	8b 43 64 59 70 fd 04 37			.byte	$8b,$43,$64,$59,$70,$fd,$04,$37
>1458	38 be 84 40 00 12 08 02			.byte	$38,$be,$84,$40,$00,$12,$08,$02
>1460	dc bd 4e 42 73 88 8b 78			.byte	$dc,$bd,$4e,$42,$73,$88,$8b,$78
>1468	62 6f be 84 8b 41 00 15			.byte	$62,$6f,$be,$84,$8b,$41,$00,$15
>1470	12 02 dc bd 8b 42 56 6b			.byte	$12,$02,$dc,$bd,$8b,$42,$56,$6b
>1478	6a 80 42 4d 69 6f be 84			.byte	$6a,$80,$42,$4d,$69,$6f,$be,$84
>1480	49 40 46 00 12 1c 02 dc			.byte	$49,$40,$46,$00,$12,$1c,$02,$dc
>1488	bd 9a 42 4d 5f 62 be be			.byte	$bd,$9a,$42,$4d,$5f,$62,$be,$be
>1490	84 42 4d 5f 62 00 1a 26			.byte	$84,$42,$4d,$5f,$62,$00,$1a,$26
>1498	02 dc bd a1 fe 09 6b 74			.byte	$02,$dc,$bd,$a1,$fe,$09,$6b,$74
>14a0	64 77 74 77 6f bf 43 be			.byte	$64,$77,$74,$77,$6f,$bf,$43,$be
>14a8	be 84 fe 05 74 77 6f 00			.byte	$be,$84,$fe,$05,$74,$77,$6f,$00
>14b0	1c 30 02 dc bd 8b 43 42			.byte	$1c,$30,$02,$dc,$bd,$8b,$43,$42
>14b8	48 7d fd 03 37 85 8b 43			.byte	$48,$7d,$fd,$03,$37,$85,$8b,$43
>14c0	6d 65 5e fd 04 34 37 be			.byte	$6d,$65,$5e,$fd,$04,$34,$37,$be
>14c8	84 8b 41 00 10 3a 02 dc			.byte	$84,$8b,$41,$00,$10,$3a,$02,$dc
>14d0	bd 43 73 6f 49 89 40 be			.byte	$bd,$43,$73,$6f,$49,$89,$40,$be
>14d8	84 8b 41 00 0c 44 02 dc			.byte	$84,$8b,$41,$00,$0c,$44,$02,$dc
>14e0	bd 40 80 40 be 84 40 00			.byte	$bd,$40,$80,$40,$be,$84,$40,$00
>14e8	0e 4e 02 dc bd b3 44 73			.byte	$0e,$4e,$02,$dc,$bd,$b3,$44,$73
>14f0	68 be be 84 41 00 15 58			.byte	$68,$be,$be,$84,$41,$00,$15,$58
>14f8	02 dc bd a2 fe 05 70 68			.byte	$02,$dc,$bd,$a2,$fe,$05,$70,$68
>1500	6a bf 4a bf 47 be be 84			.byte	$6a,$bf,$4a,$bf,$47,$be,$be,$84
>1508	fe 02 00 23 62 02 dc bd			.byte	$fe,$02,$00,$23,$62,$02,$dc,$bd
>1510	8b 4a 7d 7f fd 05 34 30			.byte	$8b,$4a,$7d,$7f,$fd,$05,$34,$30
>1518	31 8b 42 58 6f 6f fd 04			.byte	$31,$8b,$42,$58,$6f,$6f,$fd,$04
>1520	32 33 be 84 8b 42 63 6d			.byte	$32,$33,$be,$84,$8b,$42,$63,$6d
>1528	6e fd 04 36 33 00 10 6c			.byte	$6e,$fd,$04,$36,$33,$00,$10,$6c
>1530	02 dc bd 40 86 8b 43 6a			.byte	$02,$dc,$bd,$40,$86,$8b,$43,$6a
>1538	7f 5a be 84 40 00 13 76			.byte	$7f,$5a,$be,$84,$40,$00,$13,$76
>1540	02 dc bd 8b 43 5f 73 49			.byte	$02,$dc,$bd,$8b,$43,$5f,$73,$49
>1548	80 42 4c 41 4f be 84 47			.byte	$80,$42,$4c,$41,$4f,$be,$84,$47
>1550	00 16 80 02 dc bd b2 42			.byte	$00,$16,$80,$02,$dc,$bd,$b2,$42
>1558	6e 46 79 bf 8b 74 6d 52			.byte	$6e,$46,$79,$bf,$8b,$74,$6d,$52
>1560	be be 84 4f 7f 43 00 15			.byte	$be,$be,$84,$4f,$7f,$43,$00,$15
>1568	8a 02 dc bd a6 fe 0a 74			.byte	$8a,$02,$dc,$bd,$a6,$fe,$0a,$74
>1570	65 68 6e 6b 70 71 6a be			.byte	$65,$68,$6e,$6b,$70,$71,$6a,$be
>1578	be 84 48 00 1f 94 02 dc			.byte	$be,$84,$48,$00,$1f,$94,$02,$dc
>1580	bd 8b 41 5a 7b 71 fd 04			.byte	$bd,$8b,$41,$5a,$7b,$71,$fd,$04
>1588	35 39 8d 8b 41 5a 7b 71			.byte	$35,$39,$8d,$8b,$41,$5a,$7b,$71
>1590	fd 04 35 39 be 84 41 fd			.byte	$fd,$04,$35,$39,$be,$84,$41,$fd
>1598	03 30 00 13 9e 02 dc bd			.byte	$03,$30,$00,$13,$9e,$02,$dc,$bd
>15a0	79 59 78 89 8b 42 48 4f			.byte	$79,$59,$78,$89,$8b,$42,$48,$4f
>15a8	4b be 84 8b 41 00 14 a8			.byte	$4b,$be,$84,$8b,$41,$00,$14,$a8
>15b0	02 dc bd 41 6b 53 58 82			.byte	$02,$dc,$bd,$41,$6b,$53,$58,$82
>15b8	41 59 6f 7e be 84 72 7c			.byte	$41,$59,$6f,$7e,$be,$84,$72,$7c
>15c0	66 00 12 b2 02 dc bd 98			.byte	$66,$00,$12,$b2,$02,$dc,$bd,$98
>15c8	8b 41 60 72 6e be 84 41			.byte	$8b,$41,$60,$72,$6e,$be,$84,$41
>15d0	60 72 6d 00 11 bc 02 dc			.byte	$60,$72,$6d,$00,$11,$bc,$02,$dc
>15d8	bd 9b fe 05 70 67 67 be			.byte	$bd,$9b,$fe,$05,$70,$67,$67,$be
>15e0	be 84 41 70 00 1c c6 02			.byte	$be,$84,$41,$70,$00,$1c,$c6,$02
>15e8	dc bd 8b 42 57 69 69 fd			.byte	$dc,$bd,$8b,$42,$57,$69,$69,$fd
>15f0	04 37 34 84 8b 43 54 7c			.byte	$04,$37,$34,$84,$8b,$43,$54,$7c
>15f8	71 fd 04 31 38 be 84 40			.byte	$71,$fd,$04,$31,$38,$be,$84,$40
>1600	00 11 d0 02 dc bd 8b 41			.byte	$00,$11,$d0,$02,$dc,$bd,$8b,$41
>1608	64 42 7f 86 40 be 84 8b			.byte	$64,$42,$7f,$86,$40,$be,$84,$8b
>1610	41 00 14 da 02 dc bd 7b			.byte	$41,$00,$14,$da,$02,$dc,$bd,$7b
>1618	7f 7d 81 8b 7d 56 71 be			.byte	$7f,$7d,$81,$8b,$7d,$56,$71,$be
>1620	84 8b 44 40 41 00 1a e4			.byte	$84,$8b,$44,$40,$41,$00,$1a,$e4
>1628	02 dc bd a5 a4 77 6a 51			.byte	$02,$dc,$bd,$a5,$a4,$77,$6a,$51
>1630	fd 04 33 36 be be be 84			.byte	$fd,$04,$33,$36,$be,$be,$be,$84
>1638	77 6a 51 fd 04 33 36 00			.byte	$77,$6a,$51,$fd,$04,$33,$36,$00
>1640	0f ee 02 dc bd b4 41 47			.byte	$0f,$ee,$02,$dc,$bd,$b4,$41,$47
>1648	be be 84 fe 03 47 00 18			.byte	$be,$be,$84,$fe,$03,$47,$00,$18
>1650	f8 02 dc bd 40 fd 03 30			.byte	$f8,$02,$dc,$bd,$40,$fd,$03,$30
>1658	88 8b 41 43 77 5d fd 04			.byte	$88,$8b,$41,$43,$77,$5d,$fd,$04
>1660	32 34 be 84 8b 41 00 10			.byte	$32,$34,$be,$84,$8b,$41,$00,$10
>1668	02 03 dc bd 41 4d 65 41			.byte	$02,$03,$dc,$bd,$41,$4d,$65,$41
>1670	88 40 be 84 8b 41 00 16			.byte	$88,$40,$be,$84,$8b,$41,$00,$16
>1678	0c 03 dc bd 8b 42 76 63			.byte	$0c,$03,$dc,$bd,$8b,$42,$76,$63
>1680	69 82 42 69 4d 6d be 84			.byte	$69,$82,$42,$69,$4d,$6d,$be,$84
>1688	8b 5f 6e 46 00 12 16 03			.byte	$8b,$5f,$6e,$46,$00,$12,$16,$03
>1690	dc bd 9a 42 63 65 51 be			.byte	$dc,$bd,$9a,$42,$63,$65,$51,$be
>1698	be 84 42 63 65 51 00 1e			.byte	$be,$84,$42,$63,$65,$51,$00,$1e
>16a0	20 03 dc bd a3 51 be be			.byte	$20,$03,$dc,$bd,$a3,$51,$be,$be
>16a8	84 fe 13 20 20 20 20 20			.byte	$84,$fe,$13,$20,$20,$20,$20,$20
>16b0	20 20 20 20 20 20 20 20			.byte	$20,$20,$20,$20,$20,$20,$20,$20
>16b8	20 20 20 20 00 20 2a 03			.byte	$20,$20,$20,$20,$00,$20,$2a,$03
>16c0	dc bd 78 49 64 fd 04 31			.byte	$dc,$bd,$78,$49,$64,$fd,$04,$31
>16c8	37 8b 8b 41 46 65 4a fd			.byte	$37,$8b,$8b,$41,$46,$65,$4a,$fd
>16d0	03 36 be 84 41 7e 6e 6e			.byte	$03,$36,$be,$84,$41,$7e,$6e,$6e
>16d8	fd 04 37 37 00 13 34 03			.byte	$fd,$04,$37,$37,$00,$13,$34,$03
>16e0	dc bd 43 42 5b 52 86 8b			.byte	$dc,$bd,$43,$42,$5b,$52,$86,$8b
>16e8	43 62 7b 6e be 84 40 00			.byte	$43,$62,$7b,$6e,$be,$84,$40,$00
>16f0	15 3e 03 dc bd 43 67 6d			.byte	$15,$3e,$03,$dc,$bd,$43,$67,$6d
>16f8	6c 80 43 71 6d 58 be 84			.byte	$6c,$80,$43,$71,$6d,$58,$be,$84
>1700	43 61 6d 48 00 11 48 03			.byte	$43,$61,$6d,$48,$00,$11,$48,$03
>1708	dc bd b3 8b 42 76 70 5c			.byte	$dc,$bd,$b3,$8b,$42,$76,$70,$5c
>1710	be be 84 8b 41 00 15 52			.byte	$be,$be,$84,$8b,$41,$00,$15,$52
>1718	03 dc bd a7 41 77 6f 4a			.byte	$03,$dc,$bd,$a7,$41,$77,$6f,$4a
>1720	be be 84 fe 07 37 37 42			.byte	$be,$be,$84,$fe,$07,$37,$37,$42
>1728	43 41 00 22 5c 03 dc bd			.byte	$43,$41,$00,$22,$5c,$03,$dc,$bd
>1730	8b 43 66 6c 45 fd 04 33			.byte	$8b,$43,$66,$6c,$45,$fd,$04,$33
>1738	34 8b 43 45 6d 48 fd 04			.byte	$34,$8b,$43,$45,$6d,$48,$fd,$04
>1740	39 34 be 84 8b 46 6c 59			.byte	$39,$34,$be,$84,$8b,$46,$6c,$59
>1748	4e fd 03 33 00 11 66 03			.byte	$4e,$fd,$03,$33,$00,$11,$66,$03
>1750	dc bd 8b 42 71 5c 5e 86			.byte	$dc,$bd,$8b,$42,$71,$5c,$5e,$86
>1758	40 be 84 8b 41 00 12 70			.byte	$40,$be,$84,$8b,$41,$00,$12,$70
>1760	03 dc bd 40 81 41 7d 52			.byte	$03,$dc,$bd,$40,$81,$41,$7d,$52
>1768	7c be 84 41 7d 52 7c 00			.byte	$7c,$be,$84,$41,$7d,$52,$7c,$00
>1770	18 7a 03 dc bd b2 42 5b			.byte	$18,$7a,$03,$dc,$bd,$b2,$42,$5b
>1778	75 42 bf 8b 43 61 76 5f			.byte	$75,$42,$bf,$8b,$43,$61,$76,$5f
>1780	be be 84 42 5b 75 42 00			.byte	$be,$be,$84,$42,$5b,$75,$42,$00
>1788	14 84 03 dc bd af fe 07			.byte	$14,$84,$03,$dc,$bd,$af,$fe,$07
>1790	32 38 43 38 46 be be 84			.byte	$32,$38,$43,$38,$46,$be,$be,$84
>1798	68 72 4f 00 1c 8e 03 dc			.byte	$68,$72,$4f,$00,$1c,$8e,$03,$dc
>17a0	bd 8b 42 55 5a 7d fd 04			.byte	$bd,$8b,$42,$55,$5a,$7d,$fd,$04
>17a8	31 33 86 4f 53 7a fd 05			.byte	$31,$33,$86,$4f,$53,$7a,$fd,$05
>17b0	35 39 36 be 84 8b 41 00			.byte	$35,$39,$36,$be,$84,$8b,$41,$00
>17b8	12 98 03 dc bd 41 76 7e			.byte	$12,$98,$03,$dc,$bd,$41,$76,$7e
>17c0	68 88 41 7a 43 7f be 84			.byte	$68,$88,$41,$7a,$43,$7f,$be,$84
>17c8	40 00 12 a2 03 dc bd 40			.byte	$40,$00,$12,$a2,$03,$dc,$bd,$40
>17d0	81 42 70 7b 42 be 84 42			.byte	$81,$42,$70,$7b,$42,$be,$84,$42
>17d8	70 7b 42 00 12 ac 03 dc			.byte	$70,$7b,$42,$00,$12,$ac,$03,$dc
>17e0	bd 98 41 72 70 46 be 84			.byte	$bd,$98,$41,$72,$70,$46,$be,$84
>17e8	8b 41 72 70 47 00 10 b6			.byte	$8b,$41,$72,$70,$47,$00,$10,$b6
>17f0	03 dc bd a0 fe 02 bf 43			.byte	$03,$dc,$bd,$a0,$fe,$02,$bf,$43
>17f8	be be 84 fe 02 00 20 c0			.byte	$be,$be,$84,$fe,$02,$00,$20,$c0
>1800	03 dc bd 8b 5c 65 7b fd			.byte	$03,$dc,$bd,$8b,$5c,$65,$7b,$fd
>1808	03 38 8b 8b 41 57 77 72			.byte	$03,$38,$8b,$8b,$41,$57,$77,$72
>1810	fd 04 32 34 be 84 7b 51			.byte	$fd,$04,$32,$34,$be,$84,$7b,$51
>1818	76 fd 04 34 34 00 12 ca			.byte	$76,$fd,$04,$34,$34,$00,$12,$ca
>1820	03 dc bd 42 67 7e 6f 87			.byte	$03,$dc,$bd,$42,$67,$7e,$6f,$87
>1828	41 7c 45 7f be 84 40 00			.byte	$41,$7c,$45,$7f,$be,$84,$40,$00
>1830	16 d4 03 dc bd 8b 41 5b			.byte	$16,$d4,$03,$dc,$bd,$8b,$41,$5b
>1838	56 4b 82 8b 41 68 62 6d			.byte	$56,$4b,$82,$8b,$41,$68,$62,$6d
>1840	be 84 73 74 66 00 16 de			.byte	$be,$84,$73,$74,$66,$00,$16,$de
>1848	03 dc bd a5 a4 8b 42 43			.byte	$03,$dc,$bd,$a5,$a4,$8b,$42,$43
>1850	76 4e be be be 84 8b 42			.byte	$76,$4e,$be,$be,$be,$84,$8b,$42
>1858	43 76 4e 00 18 e8 03 dc			.byte	$43,$76,$4e,$00,$18,$e8,$03,$dc
>1860	bd a1 fe 06 73 6d 70 76			.byte	$bd,$a1,$fe,$06,$73,$6d,$70,$76
>1868	bf 49 be be 84 fe 06 73			.byte	$bf,$49,$be,$be,$84,$fe,$06,$73
>1870	6d 70 76 00 1a f2 03 dc			.byte	$6d,$70,$76,$00,$1a,$f2,$03,$dc
>1878	bd 8b 5e 76 75 fd 04 32			.byte	$bd,$8b,$5e,$76,$75,$fd,$04,$32
>1880	33 87 60 65 40 fd 04 38			.byte	$33,$87,$60,$65,$40,$fd,$04,$38
>1888	33 be 84 8b 41 00 11 fc			.byte	$33,$be,$84,$8b,$41,$00,$11,$fc
>1890	03 dc bd 76 72 88 8b 6a			.byte	$03,$dc,$bd,$76,$72,$88,$8b,$6a
>1898	7d 7f be 84 8b 41 00 17			.byte	$7d,$7f,$be,$84,$8b,$41,$00,$17
>18a0	06 04 dc bd 8b 42 58 65			.byte	$06,$04,$dc,$bd,$8b,$42,$58,$65
>18a8	54 82 8b 43 6a 53 63 be			.byte	$54,$82,$8b,$43,$6a,$53,$63,$be
>18b0	84 41 72 76 71 00 0c 10			.byte	$84,$41,$72,$76,$71,$00,$0c,$10
>18b8	04 dc bd 9a 40 be be 84			.byte	$04,$dc,$bd,$9a,$40,$be,$be,$84
>18c0	40 00 1a 1a 04 dc bd a2			.byte	$40,$00,$1a,$1a,$04,$dc,$bd,$a2
>18c8	fe 08 74 75 74 6e 73 6b			.byte	$fe,$08,$74,$75,$74,$6e,$73,$6b
>18d0	bf 45 bf 46 be be 84 fe			.byte	$bf,$45,$bf,$46,$be,$be,$84,$fe
>18d8	04 73 6b 00 1b 24 04 dc			.byte	$04,$73,$6b,$00,$1b,$24,$04,$dc
>18e0	bd 8b 41 58 67 46 fd 04			.byte	$bd,$8b,$41,$58,$67,$46,$fd,$04
>18e8	30 39 87 43 59 56 61 fd			.byte	$30,$39,$87,$43,$59,$56,$61,$fd
>18f0	03 39 be 84 8b 41 00 13			.byte	$03,$39,$be,$84,$8b,$41,$00,$13
>18f8	2e 04 dc bd 43 65 5a 6b			.byte	$2e,$04,$dc,$bd,$43,$65,$5a,$6b
>1900	88 42 64 6a 79 be 84 8b			.byte	$88,$42,$64,$6a,$79,$be,$84,$8b
>1908	41 00 17 38 04 dc bd 41			.byte	$41,$00,$17,$38,$04,$dc,$bd,$41
>1910	72 6d 52 82 8b 42 5f 7d			.byte	$72,$6d,$52,$82,$8b,$42,$5f,$7d
>1918	7e be 84 8b 43 6d 50 70			.byte	$7e,$be,$84,$8b,$43,$6d,$50,$70
>1920	00 11 42 04 dc bd b3 8b			.byte	$00,$11,$42,$04,$dc,$bd,$b3,$8b
>1928	42 40 61 56 be be 84 8b			.byte	$42,$40,$61,$56,$be,$be,$84,$8b
>1930	41 00 11 4c 04 dc bd a6			.byte	$41,$00,$11,$4c,$04,$dc,$bd,$a6
>1938	fe 06 63 6e 71 66 be be			.byte	$fe,$06,$63,$6e,$71,$66,$be,$be
>1940	84 44 00 1c 56 04 dc bd			.byte	$84,$44,$00,$1c,$56,$04,$dc,$bd
>1948	8b 66 78 6b fd 04 32 32			.byte	$8b,$66,$78,$6b,$fd,$04,$32,$32
>1950	85 8b 41 44 5e 66 fd 04			.byte	$85,$8b,$41,$44,$5e,$66,$fd,$04
>1958	35 35 be 84 8b 41 00 14			.byte	$35,$35,$be,$84,$8b,$41,$00,$14
>1960	60 04 dc bd 8b 42 46 67			.byte	$60,$04,$dc,$bd,$8b,$42,$46,$67
>1968	68 8d 41 58 5a 7f be 84			.byte	$68,$8d,$41,$58,$5a,$7f,$be,$84
>1970	8b 41 00 15 6a 04 dc bd			.byte	$8b,$41,$00,$15,$6a,$04,$dc,$bd
>1978	8b 41 59 5c 71 80 41 7d			.byte	$8b,$41,$59,$5c,$71,$80,$41,$7d
>1980	41 5a be 84 64 41 4a 00			.byte	$41,$5a,$be,$84,$64,$41,$4a,$00
>1988	16 74 04 dc bd b2 8b 76			.byte	$16,$74,$04,$dc,$bd,$b2,$8b,$76
>1990	6d 44 bf 41 78 55 51 be			.byte	$6d,$44,$bf,$41,$78,$55,$51,$be
>1998	be 84 76 6d 44 00 14 7e			.byte	$be,$84,$76,$6d,$44,$00,$14,$7e
>19a0	04 dc bd 9b fe 08 64 61			.byte	$04,$dc,$bd,$9b,$fe,$08,$64,$61
>19a8	6d 77 6b 69 be be 84 41			.byte	$6d,$77,$6b,$69,$be,$be,$84,$41
>19b0	64 00 1d 88 04 dc bd 40			.byte	$64,$00,$1d,$88,$04,$dc,$bd,$40
>19b8	fd 03 30 8a 41 49 5e 67			.byte	$fd,$03,$30,$8a,$41,$49,$5e,$67
>19c0	fd 04 39 35 be 84 41 49			.byte	$fd,$04,$39,$35,$be,$84,$41,$49
>19c8	5e 67 fd 04 39 35 00 11			.byte	$5e,$67,$fd,$04,$39,$35,$00,$11
>19d0	92 04 dc bd 41 4a 73 69			.byte	$92,$04,$dc,$bd,$41,$4a,$73,$69
>19d8	86 50 45 6f be 84 40 00			.byte	$86,$50,$45,$6f,$be,$84,$40,$00
>19e0	15 9c 04 dc bd 8b 43 45			.byte	$15,$9c,$04,$dc,$bd,$8b,$43,$45
>19e8	61 4a 82 43 45 4c 49 be			.byte	$61,$4a,$82,$43,$45,$4c,$49,$be
>19f0	84 8b 6d 41 00 10 a6 04			.byte	$84,$8b,$6d,$41,$00,$10,$a6,$04
>19f8	dc bd 98 5f 55 53 be 84			.byte	$dc,$bd,$98,$5f,$55,$53,$be,$84
>1a00	8b 5f 55 54 00 0f b0 04			.byte	$8b,$5f,$55,$54,$00,$0f,$b0,$04
>1a08	dc bd b4 41 40 be be 84			.byte	$dc,$bd,$b4,$41,$40,$be,$be,$84
>1a10	fe 03 40 00 1b ba 04 dc			.byte	$fe,$03,$40,$00,$1b,$ba,$04,$dc
>1a18	bd 8b 73 49 67 fd 04 33			.byte	$bd,$8b,$73,$49,$67,$fd,$04,$33
>1a20	31 85 41 49 5d 7f fd 04			.byte	$31,$85,$41,$49,$5d,$7f,$fd,$04
>1a28	35 34 be 84 8b 41 00 13			.byte	$35,$34,$be,$84,$8b,$41,$00,$13
>1a30	c4 04 dc bd 40 8b 41 55			.byte	$c4,$04,$dc,$bd,$40,$8b,$41,$55
>1a38	4a 76 be 84 8b 41 55 4a			.byte	$4a,$76,$be,$84,$8b,$41,$55,$4a
>1a40	76 00 16 ce 04 dc bd 8b			.byte	$76,$00,$16,$ce,$04,$dc,$bd,$8b
>1a48	41 64 6e 48 82 60 44 49			.byte	$41,$64,$6e,$48,$82,$60,$44,$49
>1a50	be 84 8b 41 44 6a 4f 00			.byte	$be,$84,$8b,$41,$44,$6a,$4f,$00
>1a58	14 d8 04 dc bd a5 a4 8b			.byte	$14,$d8,$04,$dc,$bd,$a5,$a4,$8b
>1a60	7c 6a 53 be be be 84 8b			.byte	$7c,$6a,$53,$be,$be,$be,$84,$8b
>1a68	7c 6a 53 00 17 e2 04 dc			.byte	$7c,$6a,$53,$00,$17,$e2,$04,$dc
>1a70	bd a3 4a be be 84 fe 0c			.byte	$bd,$a3,$4a,$be,$be,$84,$fe,$0c
>1a78	20 20 20 20 20 20 20 20			.byte	$20,$20,$20,$20,$20,$20,$20,$20
>1a80	20 20 00 29 ec 04 dc bd			.byte	$20,$20,$00,$29,$ec,$04,$dc,$bd
>1a88	43 66 6a 48 fd 04 33 32			.byte	$43,$66,$6a,$48,$fd,$04,$33,$32
>1a90	8c 8b 42 64 61 49 fd 04			.byte	$8c,$8b,$42,$64,$61,$49,$fd,$04
>1a98	38 34 be 84 8b 46 fd 0d			.byte	$38,$34,$be,$84,$8b,$46,$fd,$0d
>1aa0	33 36 36 35 32 34 39 30			.byte	$33,$36,$36,$35,$32,$34,$39,$30
>1aa8	45 31 31 00 13 f6 04 dc			.byte	$45,$31,$31,$00,$13,$f6,$04,$dc
>1ab0	bd 43 70 5d 5c 85 42 70			.byte	$bd,$43,$70,$5d,$5c,$85,$42,$70
>1ab8	65 55 be 84 8b 41 00 14			.byte	$65,$55,$be,$84,$8b,$41,$00,$14
>1ac0	00 05 dc bd 43 55 4f 48			.byte	$00,$05,$dc,$bd,$43,$55,$4f,$48
>1ac8	81 4f 61 7e be 84 43 5f			.byte	$81,$4f,$61,$7e,$be,$84,$43,$5f
>1ad0	6f 7e 00 11 0a 05 dc bd			.byte	$6f,$7e,$00,$11,$0a,$05,$dc,$bd
>1ad8	9a 8b 51 7a 6d be be 84			.byte	$9a,$8b,$51,$7a,$6d,$be,$be,$84
>1ae0	51 7a 6d 00 15 14 05 dc			.byte	$51,$7a,$6d,$00,$15,$14,$05,$dc
>1ae8	bd a7 42 69 70 62 be be			.byte	$bd,$a7,$42,$69,$70,$62,$be,$be
>1af0	84 fe 07 41 39 43 32 32			.byte	$84,$fe,$07,$41,$39,$43,$32,$32
>1af8	00 1a 1e 05 dc bd 66 6f			.byte	$00,$1a,$1e,$05,$dc,$bd,$66,$6f
>1b00	49 fd 04 35 36 84 8b 41			.byte	$49,$fd,$04,$35,$36,$84,$8b,$41
>1b08	40 73 46 fd 04 39 33 be			.byte	$40,$73,$46,$fd,$04,$39,$33,$be
>1b10	84 40 00 14 28 05 dc bd			.byte	$84,$40,$00,$14,$28,$05,$dc,$bd
>1b18	43 54 66 47 8d 8b 42 43			.byte	$43,$54,$66,$47,$8d,$8b,$42,$43
>1b20	5d 4a be 84 8b 41 00 16			.byte	$5d,$4a,$be,$84,$8b,$41,$00,$16
>1b28	32 05 dc bd 8b 41 57 68			.byte	$32,$05,$dc,$bd,$8b,$41,$57,$68
>1b30	7c 80 42 68 63 71 be 84			.byte	$7c,$80,$42,$68,$63,$71,$be,$84
>1b38	42 68 43 40 00 0c 3c 05			.byte	$42,$68,$43,$40,$00,$0c,$3c,$05
>1b40	dc bd b3 40 be be 84 40			.byte	$dc,$bd,$b3,$40,$be,$be,$84,$40
>1b48	00 15 46 05 dc bd af fe			.byte	$00,$15,$46,$05,$dc,$bd,$af,$fe
>1b50	07 39 30 38 38 43 be be			.byte	$07,$39,$30,$38,$38,$43,$be,$be
>1b58	84 42 50 62 4c 00 18 50			.byte	$84,$42,$50,$62,$4c,$00,$18,$50
>1b60	05 dc bd 6b 6b 42 fd 04			.byte	$05,$dc,$bd,$6b,$6b,$42,$fd,$04
>1b68	33 37 85 6b 6b 42 fd 04			.byte	$33,$37,$85,$6b,$6b,$42,$fd,$04
>1b70	33 37 be 84 40 00 16 5a			.byte	$33,$37,$be,$84,$40,$00,$16,$5a
>1b78	05 dc bd 43 40 52 76 8a			.byte	$05,$dc,$bd,$43,$40,$52,$76,$8a
>1b80	8b 41 53 6d 75 be 84 41			.byte	$8b,$41,$53,$6d,$75,$be,$84,$41
>1b88	6c 65 41 00 0f 64 05 dc			.byte	$6c,$65,$41,$00,$0f,$64,$05,$dc
>1b90	bd 40 80 43 5f 7d 6a be			.byte	$bd,$40,$80,$43,$5f,$7d,$6a,$be
>1b98	84 40 00 19 6e 05 dc bd			.byte	$84,$40,$00,$19,$6e,$05,$dc,$bd
>1ba0	b2 8b 42 61 64 78 bf 8b			.byte	$b2,$8b,$42,$61,$64,$78,$bf,$8b
>1ba8	41 53 45 5b be be 84 41			.byte	$41,$53,$45,$5b,$be,$be,$84,$41
>1bb0	4e 5f 5d 00 20 78 05 dc			.byte	$4e,$5f,$5d,$00,$20,$78,$05,$dc
>1bb8	bd a0 fe 0a 6b 72 63 76			.byte	$bd,$a0,$fe,$0a,$6b,$72,$63,$76
>1bc0	6a 61 6c 76 bf 4a be be			.byte	$6a,$61,$6c,$76,$bf,$4a,$be,$be
>1bc8	84 fe 0a 6b 72 63 76 6a			.byte	$84,$fe,$0a,$6b,$72,$63,$76,$6a
>1bd0	61 6c 76 00 1a 82 05 dc			.byte	$61,$6c,$76,$00,$1a,$82,$05,$dc
>1bd8	bd 64 4c 7a fd 04 37 33			.byte	$bd,$64,$4c,$7a,$fd,$04,$37,$33
>1be0	85 41 62 46 6b fd 04 39			.byte	$85,$41,$62,$46,$6b,$fd,$04,$39
>1be8	34 be 84 8b 41 00 12 8c			.byte	$34,$be,$84,$8b,$41,$00,$12,$8c
>1bf0	05 dc bd 42 74 49 59 85			.byte	$05,$dc,$bd,$42,$74,$49,$59,$85
>1bf8	42 74 49 59 be 84 40 00			.byte	$42,$74,$49,$59,$be,$84,$40,$00
>1c00	10 96 05 dc bd 40 82 5d			.byte	$10,$96,$05,$dc,$bd,$40,$82,$5d
>1c08	49 6a be 84 5d 49 6a 00			.byte	$49,$6a,$be,$84,$5d,$49,$6a,$00
>1c10	10 a0 05 dc bd 98 66 66			.byte	$10,$a0,$05,$dc,$bd,$98,$66,$66
>1c18	5c be 84 8b 66 66 5d 00			.byte	$5c,$be,$84,$8b,$66,$66,$5d,$00
>1c20	16 aa 05 dc bd a1 fe 05			.byte	$16,$aa,$05,$dc,$bd,$a1,$fe,$05
>1c28	6f 79 78 bf 46 be be 84			.byte	$6f,$79,$78,$bf,$46,$be,$be,$84
>1c30	fe 05 6f 79 78 00 28 b4			.byte	$fe,$05,$6f,$79,$78,$00,$28,$b4
>1c38	05 dc bd 58 4e 4f fd 05			.byte	$05,$dc,$bd,$58,$4e,$4f,$fd,$05
>1c40	32 38 33 8c 8b 6b 69 4e			.byte	$32,$38,$33,$8c,$8b,$6b,$69,$4e
>1c48	fd 04 31 35 be 84 8b 41			.byte	$fd,$04,$31,$35,$be,$84,$8b,$41
>1c50	fd 0d 37 37 33 36 33 33			.byte	$fd,$0d,$37,$37,$33,$36,$33,$33
>1c58	33 39 45 31 30 00 13 be			.byte	$33,$39,$45,$31,$30,$00,$13,$be
>1c60	05 dc bd 8b 43 73 7f 46			.byte	$05,$dc,$bd,$8b,$43,$73,$7f,$46
>1c68	87 79 7a 58 be 84 8b 41			.byte	$87,$79,$7a,$58,$be,$84,$8b,$41
>1c70	00 17 c8 05 dc bd 8b 41			.byte	$00,$17,$c8,$05,$dc,$bd,$8b,$41
>1c78	5f 4d 43 82 42 55 66 6f			.byte	$5f,$4d,$43,$82,$42,$55,$66,$6f
>1c80	be 84 8b 43 4a 6b 6e 00			.byte	$be,$84,$8b,$43,$4a,$6b,$6e,$00
>1c88	1c d2 05 dc bd a5 a4 42			.byte	$1c,$d2,$05,$dc,$bd,$a5,$a4,$42
>1c90	41 49 6a fd 04 31 35 be			.byte	$41,$49,$6a,$fd,$04,$31,$35,$be
>1c98	be be 84 42 41 49 6a fd			.byte	$be,$be,$84,$42,$41,$49,$6a,$fd
>1ca0	04 31 35 00 1f dc 05 dc			.byte	$04,$31,$35,$00,$1f,$dc,$05,$dc
>1ca8	bd a2 fe 0c 64 6b 77 70			.byte	$bd,$a2,$fe,$0c,$64,$6b,$77,$70
>1cb0	79 73 68 62 75 7a bf 48			.byte	$79,$73,$68,$62,$75,$7a,$bf,$48
>1cb8	bf 46 be be 84 fe 05 62			.byte	$bf,$46,$be,$be,$84,$fe,$05,$62
>1cc0	75 7a 00 17 e6 05 dc bd			.byte	$75,$7a,$00,$17,$e6,$05,$dc,$bd
>1cc8	8b 7d 6a 54 fd 04 39 35			.byte	$8b,$7d,$6a,$54,$fd,$04,$39,$35
>1cd0	87 40 fd 03 30 be 84 8b			.byte	$87,$40,$fd,$03,$30,$be,$84,$8b
>1cd8	41 00 10 f0 05 dc bd 40			.byte	$41,$00,$10,$f0,$05,$dc,$bd,$40
>1ce0	84 8b 43 46 7a 57 be 84			.byte	$84,$8b,$43,$46,$7a,$57,$be,$84
>1ce8	40 00 14 fa 05 dc bd 8b			.byte	$40,$00,$14,$fa,$05,$dc,$bd,$8b
>1cf0	42 48 7d 6f 80 6a 45 6e			.byte	$42,$48,$7d,$6f,$80,$6a,$45,$6e
>1cf8	be 84 62 40 40 00 11 04			.byte	$be,$84,$62,$40,$40,$00,$11,$04
>1d00	06 dc bd 9a 8b 68 53 4f			.byte	$06,$dc,$bd,$9a,$8b,$68,$53,$4f
>1d08	be be 84 68 53 4f 00 16			.byte	$be,$be,$84,$68,$53,$4f,$00,$16
>1d10	0e 06 dc bd a6 fe 0b 70			.byte	$0e,$06,$dc,$bd,$a6,$fe,$0b,$70
>1d18	7a 6b 61 71 70 73 63 63			.byte	$7a,$6b,$61,$71,$70,$73,$63,$63
>1d20	be be 84 49 00 1b 18 06			.byte	$be,$be,$84,$49,$00,$1b,$18,$06
>1d28	dc bd 41 4f 66 45 fd 04			.byte	$dc,$bd,$41,$4f,$66,$45,$fd,$04
>1d30	32 33 86 41 5a 68 54 fd			.byte	$32,$33,$86,$41,$5a,$68,$54,$fd
>1d38	04 39 34 be 84 8b 41 00			.byte	$04,$39,$34,$be,$84,$8b,$41,$00
>1d40	15 22 06 dc bd 42 53 7b			.byte	$15,$22,$06,$dc,$bd,$42,$53,$7b
>1d48	40 8a 43 65 72 4e be 84			.byte	$40,$8a,$43,$65,$72,$4e,$be,$84
>1d50	45 79 6d 4e 00 14 2c 06			.byte	$45,$79,$6d,$4e,$00,$14,$2c,$06
>1d58	dc bd 8b 6b 45 4a 82 8b			.byte	$dc,$bd,$8b,$6b,$45,$4a,$82,$8b
>1d60	7a 7b 74 be 84 51 7e 7a			.byte	$7a,$7b,$74,$be,$84,$51,$7e,$7a
>1d68	00 10 36 06 dc bd b3 8b			.byte	$00,$10,$36,$06,$dc,$bd,$b3,$8b
>1d70	4a 43 40 be be 84 8b 41			.byte	$4a,$43,$40,$be,$be,$84,$8b,$41
>1d78	00 0f 40 06 dc bd 9b fe			.byte	$00,$0f,$40,$06,$dc,$bd,$9b,$fe
>1d80	03 70 be be 84 41 70 00			.byte	$03,$70,$be,$be,$84,$41,$70,$00
>1d88	16 4a 06 dc bd 43 72 45			.byte	$16,$4a,$06,$dc,$bd,$43,$72,$45
>1d90	53 fd 04 30 37 87 40 fd			.byte	$53,$fd,$04,$30,$37,$87,$40,$fd
>1d98	03 30 be 84 40 00 14 54			.byte	$03,$30,$be,$84,$40,$00,$14,$54
>1da0	06 dc bd 8b 5b 74 4d 88			.byte	$06,$dc,$bd,$8b,$5b,$74,$4d,$88
>1da8	8b 43 5f 4f 62 be 84 8b			.byte	$8b,$43,$5f,$4f,$62,$be,$84,$8b
>1db0	41 00 16 5e 06 dc bd 41			.byte	$41,$00,$16,$5e,$06,$dc,$bd,$41
>1db8	50 69 45 82 8b 41 5d 63			.byte	$50,$69,$45,$82,$8b,$41,$5d,$63
>1dc0	70 be 84 8b 4d 4a 6b 00			.byte	$70,$be,$84,$8b,$4d,$4a,$6b,$00
>1dc8	18 68 06 dc bd b2 8b 43			.byte	$18,$68,$06,$dc,$bd,$b2,$8b,$43
>1dd0	68 72 68 bf 41 76 76 5b			.byte	$68,$72,$68,$bf,$41,$76,$76,$5b
>1dd8	be be 84 41 71 7c 4d 00			.byte	$be,$be,$84,$41,$71,$7c,$4d,$00
>1de0	0f 72 06 dc bd b4 41 70			.byte	$0f,$72,$06,$dc,$bd,$b4,$41,$70
>1de8	be be 84 fe 03 70 00 1f			.byte	$be,$be,$84,$fe,$03,$70,$00,$1f
>1df0	7c 06 dc bd 40 fd 03 30			.byte	$7c,$06,$dc,$bd,$40,$fd,$03,$30
>1df8	8a 8b 43 4b 49 46 fd 04			.byte	$8a,$8b,$43,$4b,$49,$46,$fd,$04
>1e00	38 39 be 84 8b 43 4b 49			.byte	$38,$39,$be,$84,$8b,$43,$4b,$49
>1e08	46 fd 04 38 39 00 13 86			.byte	$46,$fd,$04,$38,$39,$00,$13,$86
>1e10	06 dc bd 43 6f 44 60 85			.byte	$06,$dc,$bd,$43,$6f,$44,$60,$85
>1e18	42 6c 5e 5f be 84 8b 41			.byte	$42,$6c,$5e,$5f,$be,$84,$8b,$41
>1e20	00 15 90 06 dc bd 42 53			.byte	$00,$15,$90,$06,$dc,$bd,$42,$53
>1e28	53 78 80 42 70 5a 70 be			.byte	$53,$78,$80,$42,$70,$5a,$70,$be
>1e30	84 42 50 52 70 00 12 9a			.byte	$84,$42,$50,$52,$70,$00,$12,$9a
>1e38	06 dc bd 98 42 68 52 76			.byte	$06,$dc,$bd,$98,$42,$68,$52,$76
>1e40	be 84 8b 42 68 52 77 00			.byte	$be,$84,$8b,$42,$68,$52,$77,$00
>1e48	19 a4 06 dc bd a3 4c be			.byte	$19,$a4,$06,$dc,$bd,$a3,$4c,$be
>1e50	be 84 fe 0e 20 20 20 20			.byte	$be,$84,$fe,$0e,$20,$20,$20,$20
>1e58	20 20 20 20 20 20 20 20			.byte	$20,$20,$20,$20,$20,$20,$20,$20
>1e60	00 18 ae 06 dc bd 41 7e			.byte	$00,$18,$ae,$06,$dc,$bd,$41,$7e
>1e68	79 6c fd 03 31 8c 40 fd			.byte	$79,$6c,$fd,$03,$31,$8c,$40,$fd
>1e70	03 30 be 84 40 fd 03 30			.byte	$03,$30,$be,$84,$40,$fd,$03,$30
>1e78	00 14 b8 06 dc bd 8b 42			.byte	$00,$14,$b8,$06,$dc,$bd,$8b,$42
>1e80	78 45 8b 8b 49 5e 68 be			.byte	$78,$45,$8b,$8b,$49,$5e,$68,$be
>1e88	84 46 66 63 00 17 c2 06			.byte	$84,$46,$66,$63,$00,$17,$c2,$06
>1e90	dc bd 8b 43 56 5a 75 82			.byte	$dc,$bd,$8b,$43,$56,$5a,$75,$82
>1e98	41 7c 76 47 be 84 8b 42			.byte	$41,$7c,$76,$47,$be,$84,$8b,$42
>1ea0	6a 6c 74 00 1c cc 06 dc			.byte	$6a,$6c,$74,$00,$1c,$cc,$06,$dc
>1ea8	bd a5 a4 43 4a 57 6e fd			.byte	$bd,$a5,$a4,$43,$4a,$57,$6e,$fd
>1eb0	04 30 37 be be be 84 43			.byte	$04,$30,$37,$be,$be,$be,$84,$43
>1eb8	4a 57 6e fd 04 30 37 00			.byte	$4a,$57,$6e,$fd,$04,$30,$37,$00
>1ec0	15 d6 06 dc bd a7 41 4a			.byte	$15,$d6,$06,$dc,$bd,$a7,$41,$4a
>1ec8	48 5a be be 84 fe 07 34			.byte	$48,$5a,$be,$be,$84,$fe,$07,$34
>1ed0	41 32 31 41 00 1d e0 06			.byte	$41,$32,$31,$41,$00,$1d,$e0,$06
>1ed8	dc bd 8b 43 5d 74 65 fd			.byte	$dc,$bd,$8b,$43,$5d,$74,$65,$fd
>1ee0	04 31 34 85 8b 58 4a 79			.byte	$04,$31,$34,$85,$8b,$58,$4a,$79
>1ee8	fd 05 37 35 33 be 84 8b			.byte	$fd,$05,$37,$35,$33,$be,$84,$8b
>1ef0	41 00 14 ea 06 dc bd 41			.byte	$41,$00,$14,$ea,$06,$dc,$bd,$41
>1ef8	74 5b 63 8b 71 4f 6d be			.byte	$74,$5b,$63,$8b,$71,$4f,$6d,$be
>1f00	84 41 43 4b 76 00 12 f4			.byte	$84,$41,$43,$4b,$76,$00,$12,$f4
>1f08	06 dc bd 42 4c 6e 7f 81			.byte	$06,$dc,$bd,$42,$4c,$6e,$7f,$81
>1f10	40 be 84 42 4c 6e 7f 00			.byte	$40,$be,$84,$42,$4c,$6e,$7f,$00
>1f18	13 fe 06 dc bd 9a 8b 43			.byte	$13,$fe,$06,$dc,$bd,$9a,$8b,$43
>1f20	71 72 51 be be 84 43 71			.byte	$71,$72,$51,$be,$be,$84,$43,$71
>1f28	72 51 00 14 08 07 dc bd			.byte	$72,$51,$00,$14,$08,$07,$dc,$bd
>1f30	af fe 07 33 45 37 38 45			.byte	$af,$fe,$07,$33,$45,$37,$38,$45
>1f38	be be 84 7e 5e 4e 00 15			.byte	$be,$be,$84,$7e,$5e,$4e,$00,$15
>1f40	12 07 dc bd 40 fd 03 30			.byte	$12,$07,$dc,$bd,$40,$fd,$03,$30
>1f48	88 43 5c 59 4b fd 03 32			.byte	$88,$43,$5c,$59,$4b,$fd,$03,$32
>1f50	be 84 40 00 12 1c 07 dc			.byte	$be,$84,$40,$00,$12,$1c,$07,$dc
>1f58	bd 41 6e 58 55 8d 43 5d			.byte	$bd,$41,$6e,$58,$55,$8d,$43,$5d
>1f60	5b 46 be 84 40 00 15 26			.byte	$5b,$46,$be,$84,$40,$00,$15,$26
>1f68	07 dc bd 41 7d 4b 53 82			.byte	$07,$dc,$bd,$41,$7d,$4b,$53,$82
>1f70	42 5b 46 66 be 84 43 66			.byte	$42,$5b,$46,$66,$be,$84,$43,$66
>1f78	4d 75 00 0f 30 07 dc bd			.byte	$4d,$75,$00,$0f,$30,$07,$dc,$bd
>1f80	b3 41 6a 55 7d be be 84			.byte	$b3,$41,$6a,$55,$7d,$be,$be,$84
>1f88	41 00 1b 3a 07 dc bd a0			.byte	$41,$00,$1b,$3a,$07,$dc,$bd,$a0
>1f90	fe 0a 73 67 77 74 73 6e			.byte	$fe,$0a,$73,$67,$77,$74,$73,$6e
>1f98	78 6a bf 43 be be 84 fe			.byte	$78,$6a,$bf,$43,$be,$be,$84,$fe
>1fa0	05 73 67 77 00 1c 44 07			.byte	$05,$73,$67,$77,$00,$1c,$44,$07
>1fa8	dc bd 8b 42 7a 4b 6b fd			.byte	$dc,$bd,$8b,$42,$7a,$4b,$6b,$fd
>1fb0	04 39 35 89 8b 41 5f 7e			.byte	$04,$39,$35,$89,$8b,$41,$5f,$7e
>1fb8	75 fd 04 36 33 be 84 40			.byte	$75,$fd,$04,$36,$33,$be,$84,$40
>1fc0	00 10 4e 07 dc bd 8b 43			.byte	$00,$10,$4e,$07,$dc,$bd,$8b,$43
>1fc8	50 5c 7f 88 40 be 84 40			.byte	$50,$5c,$7f,$88,$40,$be,$84,$40
>1fd0	00 18 58 07 dc bd 8b 41			.byte	$00,$18,$58,$07,$dc,$bd,$8b,$41
>1fd8	54 6d 59 80 8b 42 4a 47			.byte	$54,$6d,$59,$80,$8b,$42,$4a,$47
>1fe0	62 be 84 8b 43 5e 6f 7a			.byte	$62,$be,$84,$8b,$43,$5e,$6f,$7a
>1fe8	00 10 62 07 dc bd b2 40			.byte	$00,$10,$62,$07,$dc,$bd,$b2,$40
>1ff0	bf 78 6d 7f be be 84 40			.byte	$bf,$78,$6d,$7f,$be,$be,$84,$40
>1ff8	00 1c 6c 07 dc bd a1 fe			.byte	$00,$1c,$6c,$07,$dc,$bd,$a1,$fe
>2000	08 6d 6a 72 70 72 61 bf			.byte	$08,$6d,$6a,$72,$70,$72,$61,$bf
>2008	48 be be 84 fe 08 6d 6a			.byte	$48,$be,$be,$84,$fe,$08,$6d,$6a
>2010	72 70 72 61 00 1a 76 07			.byte	$72,$70,$72,$61,$00,$1a,$76,$07
>2018	dc bd 42 6b 7d 51 fd 03			.byte	$dc,$bd,$42,$6b,$7d,$51,$fd,$03
>2020	35 88 42 4a 43 59 fd 04			.byte	$35,$88,$42,$4a,$43,$59,$fd,$04
>2028	31 31 be 84 8b 41 00 12			.byte	$31,$31,$be,$84,$8b,$41,$00,$12
>2030	80 07 dc bd 6b 66 49 85			.byte	$80,$07,$dc,$bd,$6b,$66,$49,$85
>2038	41 6e 73 42 be 84 8b 41			.byte	$41,$6e,$73,$42,$be,$84,$8b,$41
>2040	00 16 8a 07 dc bd 42 76			.byte	$00,$16,$8a,$07,$dc,$bd,$42,$76
>2048	54 50 80 8b 41 5a 5b 74			.byte	$54,$50,$80,$8b,$41,$5a,$5b,$74
>2050	be 84 42 64 44 40 00 0c			.byte	$be,$84,$42,$64,$44,$40,$00,$0c
>2058	94 07 dc bd 98 40 be 84			.byte	$94,$07,$dc,$bd,$98,$40,$be,$84
>2060	8b 41 00 19 9e 07 dc bd			.byte	$8b,$41,$00,$19,$9e,$07,$dc,$bd
>2068	a2 fe 06 65 79 63 77 bf			.byte	$a2,$fe,$06,$65,$79,$63,$77,$bf
>2070	42 bf 44 be be 84 fe 05			.byte	$42,$bf,$44,$be,$be,$84,$fe,$05
>2078	79 63 77 00 20 a8 07 dc			.byte	$79,$63,$77,$00,$20,$a8,$07,$dc
>2080	bd 43 57 68 7c fd 04 37			.byte	$bd,$43,$57,$68,$7c,$fd,$04,$37
>2088	32 8a 43 5d 58 50 fd 04			.byte	$32,$8a,$43,$5d,$58,$50,$fd,$04
>2090	39 31 be 84 46 75 41 4d			.byte	$39,$31,$be,$84,$46,$75,$41,$4d
>2098	fd 03 36 00 12 b2 07 dc			.byte	$fd,$03,$36,$00,$12,$b2,$07,$dc
>20a0	bd 8b 77 6f 73 8d 8b 5e			.byte	$bd,$8b,$77,$6f,$73,$8d,$8b,$5e
>20a8	7a 46 be 84 41 00 16 bc			.byte	$7a,$46,$be,$84,$41,$00,$16,$bc
>20b0	07 dc bd 43 4b 5f 4e 81			.byte	$07,$dc,$bd,$43,$4b,$5f,$4e,$81
>20b8	8b 42 58 5d 53 be 84 8b			.byte	$8b,$42,$58,$5d,$53,$be,$84,$8b
>20c0	50 40 51 00 1c c6 07 dc			.byte	$50,$40,$51,$00,$1c,$c6,$07,$dc
>20c8	bd a5 a4 41 49 44 7d fd			.byte	$bd,$a5,$a4,$41,$49,$44,$7d,$fd
>20d0	04 39 33 be be be 84 41			.byte	$04,$39,$33,$be,$be,$be,$84,$41
>20d8	49 44 7d fd 04 39 33 00			.byte	$49,$44,$7d,$fd,$04,$39,$33,$00
>20e0	0e d0 07 dc bd a6 fe 03			.byte	$0e,$d0,$07,$dc,$bd,$a6,$fe,$03
>20e8	78 be be 84 41 00 1a da			.byte	$78,$be,$be,$84,$41,$00,$1a,$da
>20f0	07 dc bd 8b 54 55 4b fd			.byte	$07,$dc,$bd,$8b,$54,$55,$4b,$fd
>20f8	05 38 37 38 84 76 67 60			.byte	$05,$38,$37,$38,$84,$76,$67,$60
>2100	fd 04 38 36 be 84 40 00			.byte	$fd,$04,$38,$36,$be,$84,$40,$00
>2108	13 e4 07 dc bd 8b 42 50			.byte	$13,$e4,$07,$dc,$bd,$8b,$42,$50
>2110	46 79 8d 42 52 5f 5f be			.byte	$46,$79,$8d,$42,$52,$5f,$5f,$be
>2118	84 40 00 15 ee 07 dc bd			.byte	$84,$40,$00,$15,$ee,$07,$dc,$bd
>2120	42 68 76 46 81 42 4f 67			.byte	$42,$68,$76,$46,$81,$42,$4f,$67
>2128	64 be 84 42 6f 77 66 00			.byte	$64,$be,$84,$42,$6f,$77,$66,$00
>2130	0c f8 07 dc bd 9a 40 be			.byte	$0c,$f8,$07,$dc,$bd,$9a,$40,$be
>2138	be 84 40 00 10 02 08 dc			.byte	$be,$84,$40,$00,$10,$02,$08,$dc
>2140	bd 9b fe 04 6a 64 be be			.byte	$bd,$9b,$fe,$04,$6a,$64,$be,$be
>2148	84 41 6a 00 1b 0c 08 dc			.byte	$84,$41,$6a,$00,$1b,$0c,$08,$dc
>2150	bd 8b 43 40 59 5b fd 04			.byte	$bd,$8b,$43,$40,$59,$5b,$fd,$04
>2158	34 36 84 42 54 55 42 fd			.byte	$34,$36,$84,$42,$54,$55,$42,$fd
>2160	04 37 39 be 84 40 00 14			.byte	$04,$37,$39,$be,$84,$40,$00,$14
>2168	16 08 dc bd 8b 41 6c 74			.byte	$16,$08,$dc,$bd,$8b,$41,$6c,$74
>2170	52 8d 8b 41 79 4d 49 be			.byte	$52,$8d,$8b,$41,$79,$4d,$49,$be
>2178	84 40 00 15 20 08 dc bd			.byte	$84,$40,$00,$15,$20,$08,$dc,$bd
>2180	42 5f 6e 55 82 41 49 7e			.byte	$42,$5f,$6e,$55,$82,$41,$49,$7e
>2188	5b be 84 43 56 50 4e 00			.byte	$5b,$be,$84,$43,$56,$50,$4e,$00
>2190	0c 2a 08 dc bd b3 40 be			.byte	$0c,$2a,$08,$dc,$bd,$b3,$40,$be
>2198	be 84 40 00 0e 34 08 dc			.byte	$be,$84,$40,$00,$0e,$34,$08,$dc
>21a0	bd b4 7e be be 84 fe 03			.byte	$bd,$b4,$7e,$be,$be,$84,$fe,$03
>21a8	3e 00 1c 3e 08 dc bd 8b			.byte	$3e,$00,$1c,$3e,$08,$dc,$bd,$8b
>21b0	41 64 74 59 fd 04 37 32			.byte	$41,$64,$74,$59,$fd,$04,$37,$32
>21b8	86 8b 41 64 74 59 fd 04			.byte	$86,$8b,$41,$64,$74,$59,$fd,$04
>21c0	37 32 be 84 40 00 13 48			.byte	$37,$32,$be,$84,$40,$00,$13,$48
>21c8	08 dc bd 40 8b 42 49 6e			.byte	$08,$dc,$bd,$40,$8b,$42,$49,$6e
>21d0	71 be 84 8b 42 49 6e 71			.byte	$71,$be,$84,$8b,$42,$49,$6e,$71
>21d8	00 15 52 08 dc bd 43 70			.byte	$00,$15,$52,$08,$dc,$bd,$43,$70
>21e0	62 7f 81 41 43 6e 5c be			.byte	$62,$7f,$81,$41,$43,$6e,$5c,$be
>21e8	84 43 73 6e 7f 00 15 5c			.byte	$84,$43,$73,$6e,$7f,$00,$15,$5c
>21f0	08 dc bd b2 8b 75 63 55			.byte	$08,$dc,$bd,$b2,$8b,$75,$63,$55
>21f8	bf 72 7d 68 be be 84 42			.byte	$bf,$72,$7d,$68,$be,$be,$84,$42
>2200	65 6d 00 13 66 08 dc bd			.byte	$65,$6d,$00,$13,$66,$08,$dc,$bd
>2208	a3 46 be be 84 fe 08 20			.byte	$a3,$46,$be,$be,$84,$fe,$08,$20
>2210	20 20 20 20 20 00 18 70			.byte	$20,$20,$20,$20,$20,$00,$18,$70
>2218	08 dc bd 8b 43 73 42 5c			.byte	$08,$dc,$bd,$8b,$43,$73,$42,$5c
>2220	fd 04 30 36 87 40 fd 03			.byte	$fd,$04,$30,$36,$87,$40,$fd,$03
>2228	30 be 84 8b 41 00 13 7a			.byte	$30,$be,$84,$8b,$41,$00,$13,$7a
>2230	08 dc bd 43 60 5c 46 89			.byte	$08,$dc,$bd,$43,$60,$5c,$46,$89
>2238	42 71 6a 67 be 84 8b 41			.byte	$42,$71,$6a,$67,$be,$84,$8b,$41
>2240	00 0f 84 08 dc bd 43 6f			.byte	$00,$0f,$84,$08,$dc,$bd,$43,$6f
>2248	79 60 80 40 be 84 40 00			.byte	$79,$60,$80,$40,$be,$84,$40,$00
>2250	12 8e 08 dc bd 98 41 44			.byte	$12,$8e,$08,$dc,$bd,$98,$41,$44
>2258	45 4c be 84 8b 41 44 45			.byte	$45,$4c,$be,$84,$8b,$41,$44,$45
>2260	4d 00 15 98 08 dc bd a7			.byte	$4d,$00,$15,$98,$08,$dc,$bd,$a7
>2268	41 6b 5b 74 be be 84 fe			.byte	$41,$6b,$5b,$74,$be,$be,$84,$fe
>2270	07 36 42 36 46 34 00 24			.byte	$07,$36,$42,$36,$46,$34,$00,$24
>2278	a2 08 dc bd 8b 41 6a 46			.byte	$a2,$08,$dc,$bd,$8b,$41,$6a,$46
>2280	73 fd 04 34 39 8a 8b 47			.byte	$73,$fd,$04,$34,$39,$8a,$8b,$47
>2288	72 6a fd 05 31 37 37 be			.byte	$72,$6a,$fd,$05,$31,$37,$37,$be
>2290	84 8b 41 71 79 5d fd 04			.byte	$84,$8b,$41,$71,$79,$5d,$fd,$04
>2298	36 37 00 14 ac 08 dc bd			.byte	$36,$37,$00,$14,$ac,$08,$dc,$bd
>22a0	43 46 40 56 85 8b 43 4f			.byte	$43,$46,$40,$56,$85,$8b,$43,$4f
>22a8	65 7a be 84 8b 41 00 18			.byte	$65,$7a,$be,$84,$8b,$41,$00,$18
>22b0	b6 08 dc bd 8b 41 71 5f			.byte	$b6,$08,$dc,$bd,$8b,$41,$71,$5f
>22b8	5b 81 8b 41 4f 62 73 be			.byte	$5b,$81,$8b,$41,$4f,$62,$73,$be
>22c0	84 8b 41 41 42 53 00 12			.byte	$84,$8b,$41,$41,$42,$53,$00,$12
>22c8	c0 08 dc bd a5 a4 67 63			.byte	$c0,$08,$dc,$bd,$a5,$a4,$67,$63
>22d0	47 be be be 84 67 63 47			.byte	$47,$be,$be,$be,$84,$67,$63,$47
>22d8	00 15 ca 08 dc bd af fe			.byte	$00,$15,$ca,$08,$dc,$bd,$af,$fe
>22e0	07 39 42 43 36 39 be be			.byte	$07,$39,$42,$43,$36,$39,$be,$be
>22e8	84 42 5b 71 69 00 1a d4			.byte	$84,$42,$5b,$71,$69,$00,$1a,$d4
>22f0	08 dc bd 41 75 78 58 fd			.byte	$08,$dc,$bd,$41,$75,$78,$58,$fd
>22f8	04 30 34 87 41 5b 7f 7b			.byte	$04,$30,$34,$87,$41,$5b,$7f,$7b
>2300	fd 04 35 35 be 84 40 00			.byte	$fd,$04,$35,$35,$be,$84,$40,$00
>2308	12 de 08 dc bd 42 7a 58			.byte	$12,$de,$08,$dc,$bd,$42,$7a,$58
>2310	49 86 8b 72 7b 42 be 84			.byte	$49,$86,$8b,$72,$7b,$42,$be,$84
>2318	40 00 14 e8 08 dc bd 4a			.byte	$40,$00,$14,$e8,$08,$dc,$bd,$4a
>2320	70 62 80 8b 43 6c 78 41			.byte	$70,$62,$80,$8b,$43,$6c,$78,$41
>2328	be 84 42 40 62 00 12 f2			.byte	$be,$84,$42,$40,$62,$00,$12,$f2
>2330	08 dc bd 9a 41 6c 79 77			.byte	$08,$dc,$bd,$9a,$41,$6c,$79,$77
>2338	be be 84 41 6c 79 77 00			.byte	$be,$be,$84,$41,$6c,$79,$77,$00
>2340	17 fc 08 dc bd a0 fe 08			.byte	$17,$fc,$08,$dc,$bd,$a0,$fe,$08
>2348	78 6f 7a 67 69 77 bf 41			.byte	$78,$6f,$7a,$67,$69,$77,$bf,$41
>2350	be be 84 fe 03 78 00 1d			.byte	$be,$be,$84,$fe,$03,$78,$00,$1d
>2358	06 09 dc bd 43 59 7e 58			.byte	$06,$09,$dc,$bd,$43,$59,$7e,$58
>2360	fd 04 33 36 8d 43 59 7e			.byte	$fd,$04,$33,$36,$8d,$43,$59,$7e
>2368	58 fd 04 33 36 be 84 41			.byte	$58,$fd,$04,$33,$36,$be,$84,$41
>2370	fd 03 30 00 13 10 09 dc			.byte	$fd,$03,$30,$00,$13,$10,$09,$dc
>2378	bd 8b 6a 69 69 89 8b 6a			.byte	$bd,$8b,$6a,$69,$69,$89,$8b,$6a
>2380	69 69 be 84 8b 41 00 18			.byte	$69,$69,$be,$84,$8b,$41,$00,$18
>2388	1a 09 dc bd 8b 43 5b 61			.byte	$1a,$09,$dc,$bd,$8b,$43,$5b,$61
>2390	64 80 8b 42 4c 57 71 be			.byte	$64,$80,$8b,$42,$4c,$57,$71,$be
>2398	84 8b 43 5f 77 74 00 11			.byte	$84,$8b,$43,$5f,$77,$74,$00,$11
>23a0	24 09 dc bd b3 8b 42 5f			.byte	$24,$09,$dc,$bd,$b3,$8b,$42,$5f
>23a8	49 62 be be 84 8b 41 00			.byte	$49,$62,$be,$be,$84,$8b,$41,$00
>23b0	1b 2e 09 dc bd a1 fe 0c			.byte	$1b,$2e,$09,$dc,$bd,$a1,$fe,$0c
>23b8	76 6b 75 65 6d 69 61 65			.byte	$76,$6b,$75,$65,$6d,$69,$61,$65
>23c0	74 70 bf 41 be be 84 fe			.byte	$74,$70,$bf,$41,$be,$be,$84,$fe
>23c8	03 70 00 24 38 09 dc bd			.byte	$03,$70,$00,$24,$38,$09,$dc,$bd
>23d0	43 51 78 6e fd 04 38 32			.byte	$43,$51,$78,$6e,$fd,$04,$38,$32
>23d8	8d 8b 77 7c 43 fd 04 33			.byte	$8d,$8b,$77,$7c,$43,$fd,$04,$33
>23e0	31 be 84 8b 43 fd 09 37			.byte	$31,$be,$84,$8b,$43,$fd,$09,$37
>23e8	35 32 31 30 35 34 00 16			.byte	$35,$32,$31,$30,$35,$34,$00,$16
>23f0	42 09 dc bd 41 52 6c 53			.byte	$42,$09,$dc,$bd,$41,$52,$6c,$53
>23f8	8b 8b 43 44 5e 75 be 84			.byte	$8b,$8b,$43,$44,$5e,$75,$be,$84
>2400	44 57 4b 48 00 14 4c 09			.byte	$44,$57,$4b,$48,$00,$14,$4c,$09
>2408	dc bd 5f 79 4c 82 41 73			.byte	$dc,$bd,$5f,$79,$4c,$82,$41,$73
>2410	6d 6d be 84 41 6c 54 61			.byte	$6d,$6d,$be,$84,$41,$6c,$54,$61
>2418	00 15 56 09 dc bd b2 41			.byte	$00,$15,$56,$09,$dc,$bd,$b2,$41
>2420	68 58 7d bf 5f 78 48 be			.byte	$68,$58,$7d,$bf,$5f,$78,$48,$be
>2428	be 84 48 70 65 00 18 60			.byte	$be,$84,$48,$70,$65,$00,$18,$60
>2430	09 dc bd a2 fe 08 75 6f			.byte	$09,$dc,$bd,$a2,$fe,$08,$75,$6f
>2438	62 6e 77 79 bf 48 bf 41			.byte	$62,$6e,$77,$79,$bf,$48,$bf,$41
>2440	be be 84 fe 02 00 1d 6a			.byte	$be,$be,$84,$fe,$02,$00,$1d,$6a
>2448	09 dc bd 8b 42 55 6b 73			.byte	$09,$dc,$bd,$8b,$42,$55,$6b,$73
>2450	fd 04 35 31 87 8b 41 51			.byte	$fd,$04,$35,$31,$87,$8b,$41,$51
>2458	4e 64 fd 04 33 31 be 84			.byte	$4e,$64,$fd,$04,$33,$31,$be,$84
>2460	8b 41 00 12 74 09 dc bd			.byte	$8b,$41,$00,$12,$74,$09,$dc,$bd
>2468	8b 60 71 63 87 8b 6f 77			.byte	$8b,$60,$71,$63,$87,$8b,$6f,$77
>2470	5a be 84 40 00 17 7e 09			.byte	$5a,$be,$84,$40,$00,$17,$7e,$09
>2478	dc bd 8b 41 63 76 40 82			.byte	$dc,$bd,$8b,$41,$63,$76,$40,$82
>2480	42 4a 6a 6d be 84 8b 43			.byte	$42,$4a,$6a,$6d,$be,$84,$8b,$43
>2488	69 5f 53 00 12 88 09 dc			.byte	$69,$5f,$53,$00,$12,$88,$09,$dc
>2490	bd 98 8b 41 59 50 5e be			.byte	$bd,$98,$8b,$41,$59,$50,$5e,$be
>2498	84 41 59 50 5d 00 14 92			.byte	$84,$41,$59,$50,$5d,$00,$14,$92
>24a0	09 dc bd a6 fe 09 79 72			.byte	$09,$dc,$bd,$a6,$fe,$09,$79,$72
>24a8	63 78 6b 77 6e be be 84			.byte	$63,$78,$6b,$77,$6e,$be,$be,$84
>24b0	47 00 1b 9c 09 dc bd 42			.byte	$47,$00,$1b,$9c,$09,$dc,$bd,$42
>24b8	5c 7a 76 fd 04 38 33 87			.byte	$5c,$7a,$76,$fd,$04,$38,$33,$87
>24c0	8b 41 53 65 7b fd 04 30			.byte	$8b,$41,$53,$65,$7b,$fd,$04,$30
>24c8	39 be 84 40 00 0f a6 09			.byte	$39,$be,$84,$40,$00,$0f,$a6,$09
>24d0	dc bd 40 8c 43 73 49 78			.byte	$dc,$bd,$40,$8c,$43,$73,$49,$78
>24d8	be 84 40 00 17 b0 09 dc			.byte	$be,$84,$40,$00,$17,$b0,$09,$dc
>24e0	bd 41 45 56 73 82 8b 43			.byte	$bd,$41,$45,$56,$73,$82,$8b,$43
>24e8	50 72 5c be 84 8b 42 55			.byte	$50,$72,$5c,$be,$84,$8b,$42,$55
>24f0	64 69 00 16 ba 09 dc bd			.byte	$64,$69,$00,$16,$ba,$09,$dc,$bd
>24f8	a5 a4 8b 43 42 71 54 be			.byte	$a5,$a4,$8b,$43,$42,$71,$54,$be
>2500	be be 84 8b 43 42 71 54			.byte	$be,$be,$84,$8b,$43,$42,$71,$54
>2508	00 17 c4 09 dc bd 9b fe			.byte	$00,$17,$c4,$09,$dc,$bd,$9b,$fe
>2510	0b 64 65 68 70 7a 6c 79			.byte	$0b,$64,$65,$68,$70,$7a,$6c,$79
>2518	72 73 be be 84 41 64 00			.byte	$72,$73,$be,$be,$84,$41,$64,$00
>2520	1b ce 09 dc bd 8b 43 45			.byte	$1b,$ce,$09,$dc,$bd,$8b,$43,$45
>2528	52 52 fd 04 35 31 84 41			.byte	$52,$52,$fd,$04,$35,$31,$84,$41
>2530	44 56 77 fd 04 30 36 be			.byte	$44,$56,$77,$fd,$04,$30,$36,$be
>2538	84 40 00 12 d8 09 dc bd			.byte	$84,$40,$00,$12,$d8,$09,$dc,$bd
>2540	41 4b 74 55 88 41 68 43			.byte	$41,$4b,$74,$55,$88,$41,$68,$43
>2548	6d be 84 40 00 15 e2 09			.byte	$6d,$be,$84,$40,$00,$15,$e2,$09
>2550	dc bd 42 5c 7c 5f 80 8b			.byte	$dc,$bd,$42,$5c,$7c,$5f,$80,$8b
>2558	42 4b 58 4b be 84 54 64			.byte	$42,$4b,$58,$4b,$be,$84,$54,$64
>2560	55 00 12 ec 09 dc bd 9a			.byte	$55,$00,$12,$ec,$09,$dc,$bd,$9a
>2568	42 62 78 7d be be 84 42			.byte	$42,$62,$78,$7d,$be,$be,$84,$42
>2570	62 78 7d 00 0e f6 09 dc			.byte	$62,$78,$7d,$00,$0e,$f6,$09,$dc
>2578	bd b4 77 be be 84 fe 03			.byte	$bd,$b4,$77,$be,$be,$84,$fe,$03
>2580	37 00 1a 00 0a dc bd 8b			.byte	$37,$00,$1a,$00,$0a,$dc,$bd,$8b
>2588	41 67 49 63 fd 04 39 32			.byte	$41,$67,$49,$63,$fd,$04,$39,$32
>2590	89 68 7f 53 fd 04 37 32			.byte	$89,$68,$7f,$53,$fd,$04,$37,$32
>2598	be 84 40 00 14 0a 0a dc			.byte	$be,$84,$40,$00,$14,$0a,$0a,$dc
>25a0	bd 8b 42 7b 7d 79 88 8b			.byte	$bd,$8b,$42,$7b,$7d,$79,$88,$8b
>25a8	42 6f 5b 7b be 84 40 00			.byte	$42,$6f,$5b,$7b,$be,$84,$40,$00
>25b0	15 14 0a dc bd 41 41 48			.byte	$15,$14,$0a,$dc,$bd,$41,$41,$48
>25b8	48 81 43 64 6b 4f be 84			.byte	$48,$81,$43,$64,$6b,$4f,$be,$84
>25c0	43 65 6b 4f 00 0f 1e 0a			.byte	$43,$65,$6b,$4f,$00,$0f,$1e,$0a
>25c8	dc bd b3 41 47 6f 41 be			.byte	$dc,$bd,$b3,$41,$47,$6f,$41,$be
>25d0	be 84 41 00 21 28 0a dc			.byte	$be,$84,$41,$00,$21,$28,$0a,$dc
>25d8	bd a3 54 be be 84 fe 16			.byte	$bd,$a3,$54,$be,$be,$84,$fe,$16
>25e0	20 20 20 20 20 20 20 20			.byte	$20,$20,$20,$20,$20,$20,$20,$20
>25e8	20 20 20 20 20 20 20 20			.byte	$20,$20,$20,$20,$20,$20,$20,$20
>25f0	20 20 20 20 00 1a 32 0a			.byte	$20,$20,$20,$20,$00,$1a,$32,$0a
>25f8	dc bd 41 7e 4d 4f fd 03			.byte	$dc,$bd,$41,$7e,$4d,$4f,$fd,$03
>2600	38 87 8b 42 42 66 68 fd			.byte	$38,$87,$8b,$42,$42,$66,$68,$fd
>2608	04 36 31 be 84 40 00 12			.byte	$04,$36,$31,$be,$84,$40,$00,$12
>2610	3c 0a dc bd 71 7d 44 86			.byte	$3c,$0a,$dc,$bd,$71,$7d,$44,$86
>2618	42 5f 47 40 be 84 8b 41			.byte	$42,$5f,$47,$40,$be,$84,$8b,$41
>2620	00 18 46 0a dc bd 8b 42			.byte	$00,$18,$46,$0a,$dc,$bd,$8b,$42
>2628	55 70 79 81 8b 43 69 55			.byte	$55,$70,$79,$81,$8b,$43,$69,$55
>2630	67 be 84 8b 42 41 50 61			.byte	$67,$be,$84,$8b,$42,$41,$50,$61
>2638	00 16 50 0a dc bd b2 8b			.byte	$00,$16,$50,$0a,$dc,$bd,$b2,$8b
>2640	55 5f 75 bf 43 61 65 79			.byte	$55,$5f,$75,$bf,$43,$61,$65,$79
>2648	be be 84 55 5f 75 00 15			.byte	$be,$be,$84,$55,$5f,$75,$00,$15
>2650	5a 0a dc bd a7 41 4a 7b			.byte	$5a,$0a,$dc,$bd,$a7,$41,$4a,$7b
>2658	66 be be 84 fe 07 34 41			.byte	$66,$be,$be,$84,$fe,$07,$34,$41
>2660	45 45 36 00 12 64 0a dc			.byte	$45,$45,$36,$00,$12,$64,$0a,$dc
>2668	bd 40 fd 03 30 88 40 fd			.byte	$bd,$40,$fd,$03,$30,$88,$40,$fd
>2670	03 30 be 84 40 00 14 6e			.byte	$03,$30,$be,$84,$40,$00,$14,$6e
>2678	0a dc bd 42 40 40 7f 88			.byte	$0a,$dc,$bd,$42,$40,$40,$7f,$88
>2680	8b 41 49 59 50 be 84 8b			.byte	$8b,$41,$49,$59,$50,$be,$84,$8b
>2688	41 00 12 78 0a dc bd 64			.byte	$41,$00,$12,$78,$0a,$dc,$bd,$64
>2690	4a 4a 80 41 4a 5d 72 be			.byte	$4a,$4a,$80,$41,$4a,$5d,$72,$be
>2698	84 48 42 00 12 82 0a dc			.byte	$84,$48,$42,$00,$12,$82,$0a,$dc
>26a0	bd 98 8b 43 47 6d 77 be			.byte	$bd,$98,$8b,$43,$47,$6d,$77,$be
>26a8	84 43 47 6d 76 00 15 8c			.byte	$84,$43,$47,$6d,$76,$00,$15,$8c
>26b0	0a dc bd af fe 07 37 35			.byte	$0a,$dc,$bd,$af,$fe,$07,$37,$35
>26b8	39 33 30 be be 84 41 75			.byte	$39,$33,$30,$be,$be,$84,$41,$75
>26c0	64 70 00 1c 96 0a dc bd			.byte	$64,$70,$00,$1c,$96,$0a,$dc,$bd
>26c8	8b 42 40 6a 63 fd 04 38			.byte	$8b,$42,$40,$6a,$63,$fd,$04,$38
>26d0	35 85 8b 41 46 63 49 fd			.byte	$35,$85,$8b,$41,$46,$63,$49,$fd
>26d8	03 31 be 84 8b 41 00 12			.byte	$03,$31,$be,$84,$8b,$41,$00,$12
>26e0	a0 0a dc bd 4e 78 62 86			.byte	$a0,$0a,$dc,$bd,$4e,$78,$62,$86
>26e8	41 69 5c 76 be 84 8b 41			.byte	$41,$69,$5c,$76,$be,$84,$8b,$41
>26f0	00 15 aa 0a dc bd 41 60			.byte	$00,$15,$aa,$0a,$dc,$bd,$41,$60
>26f8	4a 73 80 8b 5a 65 5f be			.byte	$4a,$73,$80,$8b,$5a,$65,$5f,$be
>2700	84 41 60 4a 61 00 1e b4			.byte	$84,$41,$60,$4a,$61,$00,$1e,$b4
>2708	0a dc bd a5 a4 8b 43 59			.byte	$0a,$dc,$bd,$a5,$a4,$8b,$43,$59
>2710	6d 79 fd 04 32 31 be be			.byte	$6d,$79,$fd,$04,$32,$31,$be,$be
>2718	be 84 8b 43 59 6d 79 fd			.byte	$be,$84,$8b,$43,$59,$6d,$79,$fd
>2720	04 32 31 00 10 be 0a dc			.byte	$04,$32,$31,$00,$10,$be,$0a,$dc
>2728	bd a0 fe 02 bf 46 be be			.byte	$bd,$a0,$fe,$02,$bf,$46,$be,$be
>2730	84 fe 02 00 17 c8 0a dc			.byte	$84,$fe,$02,$00,$17,$c8,$0a,$dc
>2738	bd 40 fd 03 30 86 8b 41			.byte	$bd,$40,$fd,$03,$30,$86,$8b,$41
>2740	78 58 4a fd 04 31 37 be			.byte	$78,$58,$4a,$fd,$04,$31,$37,$be
>2748	84 40 00 14 d2 0a dc bd			.byte	$84,$40,$00,$14,$d2,$0a,$dc,$bd
>2750	8b 41 45 52 47 8d 8b 43			.byte	$8b,$41,$45,$52,$47,$8d,$8b,$43
>2758	43 55 41 be 84 40 00 12			.byte	$43,$55,$41,$be,$84,$40,$00,$12
>2760	dc 0a dc bd 71 76 67 80			.byte	$dc,$0a,$dc,$bd,$71,$76,$67,$80
>2768	43 4e 73 71 be 84 72 61			.byte	$43,$4e,$73,$71,$be,$84,$72,$61
>2770	00 12 e6 0a dc bd 9a 43			.byte	$00,$12,$e6,$0a,$dc,$bd,$9a,$43
>2778	48 55 51 be be 84 43 48			.byte	$48,$55,$51,$be,$be,$84,$43,$48
>2780	55 51 00 22 f0 0a dc bd			.byte	$55,$51,$00,$22,$f0,$0a,$dc,$bd
>2788	a1 fe 0c 6f 72 68 74 68			.byte	$a1,$fe,$0c,$6f,$72,$68,$74,$68
>2790	7a 75 61 66 78 bf 48 be			.byte	$7a,$75,$61,$66,$78,$bf,$48,$be
>2798	be 84 fe 0a 68 74 68 7a			.byte	$be,$84,$fe,$0a,$68,$74,$68,$7a
>27a0	75 61 66 78 00 1d fa 0a			.byte	$75,$61,$66,$78,$00,$1d,$fa,$0a
>27a8	dc bd 41 54 75 68 fd 04			.byte	$dc,$bd,$41,$54,$75,$68,$fd,$04
>27b0	39 38 8d 41 54 75 68 fd			.byte	$39,$38,$8d,$41,$54,$75,$68,$fd
>27b8	04 39 38 be 84 41 fd 03			.byte	$04,$39,$38,$be,$84,$41,$fd,$03
>27c0	30 00 12 04 0b dc bd 8b			.byte	$30,$00,$12,$04,$0b,$dc,$bd,$8b
>27c8	46 44 44 89 42 57 5e 6c			.byte	$46,$44,$44,$89,$42,$57,$5e,$6c
>27d0	be 84 40 00 13 0e 0b dc			.byte	$be,$84,$40,$00,$13,$0e,$0b,$dc
>27d8	bd 76 6b 6d 80 41 4b 72			.byte	$bd,$76,$6b,$6d,$80,$41,$4b,$72
>27e0	6e be 84 42 62 6c 00 11			.byte	$6e,$be,$84,$42,$62,$6c,$00,$11
>27e8	18 0b dc bd b3 8b 43 58			.byte	$18,$0b,$dc,$bd,$b3,$8b,$43,$58
>27f0	5e 41 be be 84 8b 41 00			.byte	$5e,$41,$be,$be,$84,$8b,$41,$00
>27f8	12 22 0b dc bd a2 fe 02			.byte	$12,$22,$0b,$dc,$bd,$a2,$fe,$02
>2800	bf 4a bf 4a be be 84 fe			.byte	$bf,$4a,$bf,$4a,$be,$be,$84,$fe
>2808	02 00 22 2c 0b dc bd 7e			.byte	$02,$00,$22,$2c,$0b,$dc,$bd,$7e
>2810	43 66 fd 04 35 35 8d 54			.byte	$43,$66,$fd,$04,$35,$35,$8d,$54
>2818	7b 53 fd 05 38 39 34 be			.byte	$7b,$53,$fd,$05,$38,$39,$34,$be
>2820	84 42 fd 09 39 36 35 34			.byte	$84,$42,$fd,$09,$39,$36,$35,$34
>2828	30 37 35 00 10 36 0b dc			.byte	$30,$37,$35,$00,$10,$36,$0b,$dc
>2830	bd 40 86 8b 42 45 70 43			.byte	$bd,$40,$86,$8b,$42,$45,$70,$43
>2838	be 84 40 00 14 40 0b dc			.byte	$be,$84,$40,$00,$14,$40,$0b,$dc
>2840	bd 42 41 6c 55 82 42 48			.byte	$bd,$42,$41,$6c,$55,$82,$42,$48
>2848	73 43 be 84 49 5f 56 00			.byte	$73,$43,$be,$84,$49,$5f,$56,$00
>2850	18 4a 0b dc bd b2 8b 42			.byte	$18,$4a,$0b,$dc,$bd,$b2,$8b,$42
>2858	76 61 5a bf 43 73 7d 7b			.byte	$76,$61,$5a,$bf,$43,$73,$7d,$7b
>2860	be be 84 42 76 61 5a 00			.byte	$be,$be,$84,$42,$76,$61,$5a,$00
>2868	0f 54 0b dc bd a6 fe 04			.byte	$0f,$54,$0b,$dc,$bd,$a6,$fe,$04
>2870	7a 6b be be 84 42 00 1a			.byte	$7a,$6b,$be,$be,$84,$42,$00,$1a
>2878	5e 0b dc bd 8b 5b 5d 48			.byte	$5e,$0b,$dc,$bd,$8b,$5b,$5d,$48
>2880	fd 04 36 33 8c 40 fd 03			.byte	$fd,$04,$36,$33,$8c,$40,$fd,$03
>2888	30 be 84 8b 40 fd 03 30			.byte	$30,$be,$84,$8b,$40,$fd,$03,$30
>2890	00 12 68 0b dc bd 43 66			.byte	$00,$12,$68,$0b,$dc,$bd,$43,$66
>2898	64 76 8d 42 75 71 65 be			.byte	$64,$76,$8d,$42,$75,$71,$65,$be
>28a0	84 41 00 14 72 0b dc bd			.byte	$84,$41,$00,$14,$72,$0b,$dc,$bd
>28a8	41 69 4a 5d 81 5a 6e 5b			.byte	$41,$69,$4a,$5d,$81,$5a,$6e,$5b
>28b0	be 84 41 7b 6e 5f 00 12			.byte	$be,$84,$41,$7b,$6e,$5f,$00,$12
>28b8	7c 0b dc bd 98 41 5e 64			.byte	$7c,$0b,$dc,$bd,$98,$41,$5e,$64
>28c0	60 be 84 8b 41 5e 64 61			.byte	$60,$be,$84,$8b,$41,$5e,$64,$61
>28c8	00 17 86 0b dc bd 9b fe			.byte	$00,$17,$86,$0b,$dc,$bd,$9b,$fe
>28d0	0b 71 65 66 78 68 67 63			.byte	$0b,$71,$65,$66,$78,$68,$67,$63
>28d8	73 68 be be 84 41 71 00			.byte	$73,$68,$be,$be,$84,$41,$71,$00
>28e0	18 90 0b dc bd 8b 42 5b			.byte	$18,$90,$0b,$dc,$bd,$8b,$42,$5b
>28e8	52 65 fd 04 30 33 86 40			.byte	$52,$65,$fd,$04,$30,$33,$86,$40
>28f0	fd 03 30 be 84 8b 41 00			.byte	$fd,$03,$30,$be,$84,$8b,$41,$00
>28f8	13 9a 0b dc bd 43 65 6c			.byte	$13,$9a,$0b,$dc,$bd,$43,$65,$6c
>2900	47 86 8b 43 5d 59 42 be			.byte	$47,$86,$8b,$43,$5d,$59,$42,$be
>2908	84 40 00 15 a4 0b dc bd			.byte	$84,$40,$00,$15,$a4,$0b,$dc,$bd
>2910	41 5e 4a 57 82 43 6e 77			.byte	$41,$5e,$4a,$57,$82,$43,$6e,$77
>2918	7a be 84 42 70 7d 6d 00			.byte	$7a,$be,$84,$42,$70,$7d,$6d,$00
>2920	1c ae 0b dc bd a5 a4 43			.byte	$1c,$ae,$0b,$dc,$bd,$a5,$a4,$43
>2928	69 71 5a fd 04 30 38 be			.byte	$69,$71,$5a,$fd,$04,$30,$38,$be
>2930	be be 84 43 69 71 5a fd			.byte	$be,$be,$84,$43,$69,$71,$5a,$fd
>2938	04 30 38 00 0f b8 0b dc			.byte	$04,$30,$38,$00,$0f,$b8,$0b,$dc
>2940	bd b4 41 72 be be 84 fe			.byte	$bd,$b4,$41,$72,$be,$be,$84,$fe
>2948	03 72 00 19 c2 0b dc bd			.byte	$03,$72,$00,$19,$c2,$0b,$dc,$bd
>2950	43 4a 40 58 fd 04 33 38			.byte	$43,$4a,$40,$58,$fd,$04,$33,$38
>2958	8c 40 fd 03 30 be 84 40			.byte	$8c,$40,$fd,$03,$30,$be,$84,$40
>2960	fd 03 30 00 15 cc 0b dc			.byte	$fd,$03,$30,$00,$15,$cc,$0b,$dc
>2968	bd 8b 41 7e 75 45 88 8b			.byte	$bd,$8b,$41,$7e,$75,$45,$88,$8b
>2970	42 78 5f 7c be 84 8b 41			.byte	$42,$78,$5f,$7c,$be,$84,$8b,$41
>2978	00 15 d6 0b dc bd 8b 43			.byte	$00,$15,$d6,$0b,$dc,$bd,$8b,$43
>2980	68 7c 6b 80 41 53 79 64			.byte	$68,$7c,$6b,$80,$41,$53,$79,$64
>2988	be 84 53 41 44 00 13 e0			.byte	$be,$84,$53,$41,$44,$00,$13,$e0
>2990	0b dc bd 9a 8b 43 59 73			.byte	$0b,$dc,$bd,$9a,$8b,$43,$59,$73
>2998	68 be be 84 43 59 73 68			.byte	$68,$be,$be,$84,$43,$59,$73,$68
>29a0	00 11 ea 0b dc bd a3 44			.byte	$00,$11,$ea,$0b,$dc,$bd,$a3,$44
>29a8	be be 84 fe 06 20 20 20			.byte	$be,$be,$84,$fe,$06,$20,$20,$20
>29b0	20 00 1d f4 0b dc bd 8b			.byte	$20,$00,$1d,$f4,$0b,$dc,$bd,$8b
>29b8	43 6c 7c 5d fd 04 32 34			.byte	$43,$6c,$7c,$5d,$fd,$04,$32,$34
>29c0	86 8b 41 6f 42 6f fd 04			.byte	$86,$8b,$41,$6f,$42,$6f,$fd,$04
>29c8	34 37 be 84 8b 41 00 13			.byte	$34,$37,$be,$84,$8b,$41,$00,$13
>29d0	fe 0b dc bd 40 8b 8b 42			.byte	$fe,$0b,$dc,$bd,$40,$8b,$8b,$42
>29d8	7f 64 7d be 84 42 7f 64			.byte	$7f,$64,$7d,$be,$84,$42,$7f,$64
>29e0	7d 00 15 08 0c dc bd 41			.byte	$7d,$00,$15,$08,$0c,$dc,$bd,$41
>29e8	53 4c 7c 80 43 55 5a 5d			.byte	$53,$4c,$7c,$80,$43,$55,$5a,$5d
>29f0	be 84 41 51 48 5c 00 0f			.byte	$be,$84,$41,$51,$48,$5c,$00,$0f
>29f8	12 0c dc bd b3 41 63 72			.byte	$12,$0c,$dc,$bd,$b3,$41,$63,$72
>2a00	68 be be 84 41 00 15 1c			.byte	$68,$be,$be,$84,$41,$00,$15,$1c
>2a08	0c dc bd a7 41 6c 66 6c			.byte	$0c,$dc,$bd,$a7,$41,$6c,$66,$6c
>2a10	be be 84 fe 07 36 43 39			.byte	$be,$be,$84,$fe,$07,$36,$43,$39
>2a18	41 43 00 1b 26 0c dc bd			.byte	$41,$43,$00,$1b,$26,$0c,$dc,$bd
>2a20	42 71 44 79 fd 04 32 35			.byte	$42,$71,$44,$79,$fd,$04,$32,$35
>2a28	86 8b 42 64 51 48 fd 04			.byte	$86,$8b,$42,$64,$51,$48,$fd,$04
>2a30	39 34 be 84 40 00 15 30			.byte	$39,$34,$be,$84,$40,$00,$15,$30
>2a38	0c dc bd 42 50 67 6c 8a			.byte	$0c,$dc,$bd,$42,$50,$67,$6c,$8a
>2a40	8b 52 73 77 be 84 41 7d			.byte	$8b,$52,$73,$77,$be,$84,$41,$7d
>2a48	73 75 00 15 3a 0c dc bd			.byte	$73,$75,$00,$15,$3a,$0c,$dc,$bd
>2a50	41 72 63 79 81 8b 4e 42			.byte	$41,$72,$63,$79,$81,$8b,$4e,$42
>2a58	41 be 84 8b 4c 40 41 00			.byte	$41,$be,$84,$8b,$4c,$40,$41,$00
>2a60	16 44 0c dc bd b2 43 4a			.byte	$16,$44,$0c,$dc,$bd,$b2,$43,$4a
>2a68	68 71 bf 42 5e 7c 46 be			.byte	$68,$71,$bf,$42,$5e,$7c,$46,$be
>2a70	be 84 6b 6c 6b 00 14 4e			.byte	$be,$84,$6b,$6c,$6b,$00,$14,$4e
>2a78	0c dc bd af fe 07 33 43			.byte	$0c,$dc,$bd,$af,$fe,$07,$33,$43
>2a80	30 35 37 be be 84 7c 41			.byte	$30,$35,$37,$be,$be,$84,$7c,$41
>2a88	57 00 22 58 0c dc bd 8b			.byte	$57,$00,$22,$58,$0c,$dc,$bd,$8b
>2a90	43 4b 60 46 fd 04 38 33			.byte	$43,$4b,$60,$46,$fd,$04,$38,$33
>2a98	8b 8b 42 66 7c 49 fd 03			.byte	$8b,$8b,$42,$66,$7c,$49,$fd,$03
>2aa0	38 be 84 8b 64 63 7d fd			.byte	$38,$be,$84,$8b,$64,$63,$7d,$fd
>2aa8	04 30 33 00 11 62 0c dc			.byte	$04,$30,$33,$00,$11,$62,$0c,$dc
>2ab0	bd 8b 50 43 49 89 50 66			.byte	$bd,$8b,$50,$43,$49,$89,$50,$66
>2ab8	7b be 84 40 00 13 6c 0c			.byte	$7b,$be,$84,$40,$00,$13,$6c,$0c
>2ac0	dc bd 7e 67 74 81 8b 6a			.byte	$dc,$bd,$7e,$67,$74,$81,$8b,$6a
>2ac8	58 68 be 84 8b 58 44 00			.byte	$58,$68,$be,$84,$8b,$58,$44,$00
>2ad0	0c 76 0c dc bd 98 40 be			.byte	$0c,$76,$0c,$dc,$bd,$98,$40,$be
>2ad8	84 8b 41 00 1e 80 0c dc			.byte	$84,$8b,$41,$00,$1e,$80,$0c,$dc
>2ae0	bd a0 fe 09 7a 6e 64 76			.byte	$bd,$a0,$fe,$09,$7a,$6e,$64,$76
>2ae8	6d 65 69 bf 4a be be 84			.byte	$6d,$65,$69,$bf,$4a,$be,$be,$84
>2af0	fe 09 7a 6e 64 76 6d 65			.byte	$fe,$09,$7a,$6e,$64,$76,$6d,$65
>2af8	69 00 1a 8a 0c dc bd 45			.byte	$69,$00,$1a,$8a,$0c,$dc,$bd,$45
>2b00	50 5d fd 05 30 36 33 89			.byte	$50,$5d,$fd,$05,$30,$36,$33,$89
>2b08	73 6e fd 05 37 32 32 be			.byte	$73,$6e,$fd,$05,$37,$32,$32,$be
>2b10	84 8b 41 00 11 94 0c dc			.byte	$84,$8b,$41,$00,$11,$94,$0c,$dc
>2b18	bd 42 72 4d 72 86 5d 79			.byte	$bd,$42,$72,$4d,$72,$86,$5d,$79
>2b20	67 be 84 40 00 14 9e 0c			.byte	$67,$be,$84,$40,$00,$14,$9e,$0c
>2b28	dc bd 42 66 6c 46 82 42			.byte	$dc,$bd,$42,$66,$6c,$46,$82,$42
>2b30	6c 71 65 be 84 4a 5d 63			.byte	$6c,$71,$65,$be,$84,$4a,$5d,$63
>2b38	00 14 a8 0c dc bd a5 a4			.byte	$00,$14,$a8,$0c,$dc,$bd,$a5,$a4
>2b40	40 fd 03 30 be be be 84			.byte	$40,$fd,$03,$30,$be,$be,$be,$84
>2b48	40 fd 03 30 00 1b b2 0c			.byte	$40,$fd,$03,$30,$00,$1b,$b2,$0c
>2b50	dc bd a1 fe 09 6e 63 70			.byte	$dc,$bd,$a1,$fe,$09,$6e,$63,$70
>2b58	7a 7a 7a 75 bf 44 be be			.byte	$7a,$7a,$7a,$75,$bf,$44,$be,$be
>2b60	84 fe 06 7a 7a 7a 75 00			.byte	$84,$fe,$06,$7a,$7a,$7a,$75,$00
>2b68	22 bc 0c dc bd 8b 43 6a			.byte	$22,$bc,$0c,$dc,$bd,$8b,$43,$6a
>2b70	61 6c fd 04 34 31 8b 53			.byte	$61,$6c,$fd,$04,$34,$31,$8b,$53
>2b78	44 4a fd 05 31 34 32 be			.byte	$44,$4a,$fd,$05,$31,$34,$32,$be
>2b80	84 8b 43 7d 65 76 fd 03			.byte	$84,$8b,$43,$7d,$65,$76,$fd,$03
>2b88	36 00 14 c6 0c dc bd 41			.byte	$36,$00,$14,$c6,$0c,$dc,$bd,$41
>2b90	66 54 4c 88 8b 41 7c 4c			.byte	$66,$54,$4c,$88,$8b,$41,$7c,$4c
>2b98	71 be 84 8b 41 00 15 d0			.byte	$71,$be,$84,$8b,$41,$00,$15,$d0
>2ba0	0c dc bd 42 6a 71 68 80			.byte	$0c,$dc,$bd,$42,$6a,$71,$68,$80
>2ba8	8b 70 73 6f be 84 42 4a			.byte	$8b,$70,$73,$6f,$be,$84,$42,$4a
>2bb0	40 40 00 0c da 0c dc bd			.byte	$40,$40,$00,$0c,$da,$0c,$dc,$bd
>2bb8	9a 40 be be 84 40 00 1f			.byte	$9a,$40,$be,$be,$84,$40,$00,$1f
>2bc0	e4 0c dc bd a2 fe 0c 6e			.byte	$e4,$0c,$dc,$bd,$a2,$fe,$0c,$6e
>2bc8	70 61 66 6c 66 77 6f 67			.byte	$70,$61,$66,$6c,$66,$77,$6f,$67
>2bd0	6a bf 48 bf 4a be be 84			.byte	$6a,$bf,$48,$bf,$4a,$be,$be,$84
>2bd8	fe 05 6f 67 6a 00 25 ee			.byte	$fe,$05,$6f,$67,$6a,$00,$25,$ee
>2be0	0c dc bd 8b 43 4a 43 6d			.byte	$0c,$dc,$bd,$8b,$43,$4a,$43,$6d
>2be8	fd 04 35 33 8d 42 58 59			.byte	$fd,$04,$35,$33,$8d,$42,$58,$59
>2bf0	69 fd 04 32 33 be 84 8b			.byte	$69,$fd,$04,$32,$33,$be,$84,$8b
>2bf8	41 fd 09 33 32 35 38 33			.byte	$41,$fd,$09,$33,$32,$35,$38,$33
>2c00	33 38 00 11 f8 0c dc bd			.byte	$33,$38,$00,$11,$f8,$0c,$dc,$bd
>2c08	40 85 8b 41 72 57 6c be			.byte	$40,$85,$8b,$41,$72,$57,$6c,$be
>2c10	84 8b 41 00 0e 02 0d dc			.byte	$84,$8b,$41,$00,$0e,$02,$0d,$dc
>2c18	bd 74 53 5e 80 40 be 84			.byte	$bd,$74,$53,$5e,$80,$40,$be,$84
>2c20	40 00 11 0c 0d dc bd b3			.byte	$40,$00,$11,$0c,$0d,$dc,$bd,$b3
>2c28	8b 43 4f 58 7e be be 84			.byte	$8b,$43,$4f,$58,$7e,$be,$be,$84
>2c30	8b 41 00 12 16 0d dc bd			.byte	$8b,$41,$00,$12,$16,$0d,$dc,$bd
>2c38	a6 fe 07 65 64 67 71 62			.byte	$a6,$fe,$07,$65,$64,$67,$71,$62
>2c40	be be 84 45 00 1b 20 0d			.byte	$be,$be,$84,$45,$00,$1b,$20,$0d
>2c48	dc bd 41 51 70 4f fd 04			.byte	$dc,$bd,$41,$51,$70,$4f,$fd,$04
>2c50	36 32 89 8b 65 75 7c fd			.byte	$36,$32,$89,$8b,$65,$75,$7c,$fd
>2c58	04 30 33 be 84 8b 41 00			.byte	$04,$30,$33,$be,$84,$8b,$41,$00
>2c60	14 2a 0d dc bd 8b 41 42			.byte	$14,$2a,$0d,$dc,$bd,$8b,$41,$42
>2c68	54 67 87 41 46 4e 63 be			.byte	$54,$67,$87,$41,$46,$4e,$63,$be
>2c70	84 8b 41 00 16 34 0d dc			.byte	$84,$8b,$41,$00,$16,$34,$0d,$dc
>2c78	bd 57 78 71 82 8b 41 73			.byte	$bd,$57,$78,$71,$82,$8b,$41,$73
>2c80	5a 41 be 84 8b 41 64 62			.byte	$5a,$41,$be,$84,$8b,$41,$64,$62
>2c88	72 00 19 3e 0d dc bd b2			.byte	$72,$00,$19,$3e,$0d,$dc,$bd,$b2
>2c90	8b 43 43 7d 79 bf 8b 43			.byte	$8b,$43,$43,$7d,$79,$bf,$8b,$43
>2c98	4f 50 4f be be 84 43 43			.byte	$4f,$50,$4f,$be,$be,$84,$43,$43
>2ca0	7d 79 00 16 48 0d dc bd			.byte	$7d,$79,$00,$16,$48,$0d,$dc,$bd
>2ca8	9b fe 0a 76 70 61 69 77			.byte	$9b,$fe,$0a,$76,$70,$61,$69,$77
>2cb0	6f 6d 66 be be 84 41 76			.byte	$6f,$6d,$66,$be,$be,$84,$41,$76
>2cb8	00 17 52 0d dc bd 8b 4b			.byte	$00,$17,$52,$0d,$dc,$bd,$8b,$4b
>2cc0	52 5d fd 05 39 33 32 84			.byte	$52,$5d,$fd,$05,$39,$33,$32,$84
>2cc8	40 fd 03 30 be 84 40 00			.byte	$40,$fd,$03,$30,$be,$84,$40,$00
>2cd0	14 5c 0d dc bd 67 79 60			.byte	$14,$5c,$0d,$dc,$bd,$67,$79,$60
>2cd8	8a 41 6f 6a 4e be 84 42			.byte	$8a,$41,$6f,$6a,$4e,$be,$84,$42
>2ce0	57 63 6e 00 17 66 0d dc			.byte	$57,$63,$6e,$00,$17,$66,$0d,$dc
>2ce8	bd 8b 42 43 5f 5c 82 8b			.byte	$bd,$8b,$42,$43,$5f,$5c,$82,$8b
>2cf0	41 5f 4c 6a be 84 43 5c			.byte	$41,$5f,$4c,$6a,$be,$84,$43,$5c
>2cf8	53 72 00 12 70 0d dc bd			.byte	$53,$72,$00,$12,$70,$0d,$dc,$bd
>2d00	98 8b 43 47 79 63 be 84			.byte	$98,$8b,$43,$47,$79,$63,$be,$84
>2d08	43 47 79 62 00 0f 7a 0d			.byte	$43,$47,$79,$62,$00,$0f,$7a,$0d
>2d10	dc bd b4 41 78 be be 84			.byte	$dc,$bd,$b4,$41,$78,$be,$be,$84
>2d18	fe 03 78 00 1a 84 0d dc			.byte	$fe,$03,$78,$00,$1a,$84,$0d,$dc
>2d20	bd 4e 54 4e fd 05 31 37			.byte	$bd,$4e,$54,$4e,$fd,$05,$31,$37
>2d28	33 87 8b 6a 63 4f fd 04			.byte	$33,$87,$8b,$6a,$63,$4f,$fd,$04
>2d30	38 39 be 84 40 00 13 8e			.byte	$38,$39,$be,$84,$40,$00,$13,$8e
>2d38	0d dc bd 40 8b 43 71 7f			.byte	$0d,$dc,$bd,$40,$8b,$43,$71,$7f
>2d40	70 be 84 8b 43 71 7f 70			.byte	$70,$be,$84,$8b,$43,$71,$7f,$70
>2d48	00 16 98 0d dc bd 8b 42			.byte	$00,$16,$98,$0d,$dc,$bd,$8b,$42
>2d50	64 5c 64 82 42 45 7a 6c			.byte	$64,$5c,$64,$82,$42,$45,$7a,$6c
>2d58	be 84 8b 61 66 50 00 1c			.byte	$be,$84,$8b,$61,$66,$50,$00,$1c
>2d60	a2 0d dc bd a5 a4 41 5a			.byte	$a2,$0d,$dc,$bd,$a5,$a4,$41,$5a
>2d68	72 63 fd 04 30 32 be be			.byte	$72,$63,$fd,$04,$30,$32,$be,$be
>2d70	be 84 41 5a 72 63 fd 04			.byte	$be,$84,$41,$5a,$72,$63,$fd,$04
>2d78	30 32 00 14 ac 0d dc bd			.byte	$30,$32,$00,$14,$ac,$0d,$dc,$bd
>2d80	a3 47 be be 84 fe 09 20			.byte	$a3,$47,$be,$be,$84,$fe,$09,$20
>2d88	20 20 20 20 20 20 00 29			.byte	$20,$20,$20,$20,$20,$20,$00,$29
>2d90	b6 0d d6 fe 22 50 61 73			.byte	$b6,$0d,$d6,$fe,$22,$50,$61,$73
>2d98	73 65 64 20 41 72 69 74			.byte	$73,$65,$64,$20,$41,$72,$69,$74
>2da0	68 6d 65 74 69 63 2c 4c			.byte	$68,$6d,$65,$74,$69,$63,$2c,$4c
>2da8	6f 67 69 63 61 6c 2c 55			.byte	$6f,$67,$69,$63,$61,$6c,$2c,$55
>2db0	6e 61 72 79 2e c0 c4 00			.byte	$6e,$61,$72,$79,$2e,$c0,$c4,$00
>2db8	00					.byte	$00

;******  Return to file: modules/hardware/em65816.asm

.c000					StartROM:
.c000	18		clc				clc
.c001	fb		xce				xce
.c002	c2 30		rep #$30			rep 	#$30
.c004	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.c007	1b		tcs				tcs
.c008	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.c00b	e2 30		sep #$30			sep 	#$30
.c00d	c2 30		rep #$30			rep 	#$30						; clear AXY in 16 bit.
.c00f	a9 00		lda #$00			lda 	#$0000
.c011	aa		tax				tax
.c012	a8		tay				tay
.c013	e2 30		sep #$30			sep 	#$30
.c015	5c 13 88 01	jmp $018813		jmp BASIC_Start
.c019					TIM_BreakHandler:
.c019	5c 76 83 01	jmp $018376			jmp 	TIM_BreakVector

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.018000					IFT_ClearScreen:
.018000	48		pha				pha
.018001	da		phx				phx
.018002	5a		phy				phy
.018003	20 a9 81	jsr $0181a9			jsr 	IF_Home 					; home cursor
.018006	a2 20		ldx #$20			ldx 	#IF_Height 					; this many lines.
.018008					_IFT_CS0:
.018008	a0 40		ldy #$40			ldy 	#IF_Width 					; this many chars/line
.01800a					_IFT_CS1:
.01800a	a9 20		lda #$20			lda 	#' '						; clear line.
.01800c	20 d5 81	jsr $0181d5			jsr 	IF_Write
.01800f	88		dey				dey
.018010	d0 f8		bne $01800a			bne 	_IFT_CS1
.018012	20 bc 81	jsr $0181bc			jsr 	IF_NewLine 					; next line down
.018015	ca		dex				dex
.018016	d0 f0		bne $018008			bne 	_IFT_CS0
.018018	7a		ply				ply
.018019	fa		plx				plx
.01801a	68		pla				pla
.01801b					IFT_HomeCursor:
.01801b	48		pha				pha
.01801c	20 a9 81	jsr $0181a9			jsr 	IF_Home
.01801f	a9 00		lda #$00			lda 	#0
.018021	8d 00 05	sta $0500			sta 	IFT_XCursor
.018024	8d 01 05	sta $0501			sta 	IFT_YCursor
.018027	68		pla				pla
.018028	60		rts				rts
.018029					IFT_UpLine:
.018029	48		pha				pha
.01802a	ad 01 05	lda $0501			lda  	IFT_YCursor 				; get Y
.01802d	3a		dec a				dec 	a 							; line above
.01802e	30 03		bmi $018033			bmi 	_IFTULExit 					; too far, abort
.018030	20 c8 80	jsr $0180c8			jsr 	IFT_SetYPos					; set to that line.
.018033					_IFTULExit:
.018033	68		pla				pla
.018034	60		rts				rts
.018035					IFT_PrintCharacter:
.018035	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.018037	f0 20		beq $018059			beq 	IFT_NewLine
.018039	c9 08		cmp #$08			cmp 	#8
.01803b	f0 16		beq $018053			beq 	_IFT_Left
.01803d	48		pha				pha
.01803e	20 71 80	jsr $018071			jsr 	IFT_UpperCase 				; make upper case
.018041	20 d5 81	jsr $0181d5			jsr 	IF_Write 					; write out.
.018044	ee 00 05	inc $0500			inc 	IFT_XCursor 				; bump x cursor
.018047	ad 00 05	lda $0500			lda 	IFT_XCursor 				; reached RHS ?
.01804a	c9 40		cmp #$40			cmp 	#IF_Width
.01804c	d0 03		bne $018051			bne 	_IFT_PCNotEOL
.01804e	20 59 80	jsr $018059			jsr 	IFT_NewLine 				; if so do new line.
.018051					_IFT_PCNotEOL:
.018051	68		pla				pla
.018052	60		rts				rts
.018053					_IFT_Left:
.018053	48		pha				pha
.018054	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.018057	68		pla				pla
.018058	60		rts				rts
.018059					IFT_NewLine:
.018059	48		pha				pha
.01805a	20 bc 81	jsr $0181bc			jsr 	IF_NewLine 					; new line on actual screen.
.01805d	a9 00		lda #$00			lda 	#0 							; reset x position
.01805f	8d 00 05	sta $0500			sta 	IFT_XCursor
.018062	ee 01 05	inc $0501			inc 	IFT_YCursor 				; move down.
.018065	ad 01 05	lda $0501			lda 	IFT_YCursor
.018068	c9 20		cmp #$20			cmp 	#IF_Height 					; reached bottom.
.01806a	d0 03		bne $01806f			bne 	_IFT_NL_NotEOS
.01806c	20 7c 80	jsr $01807c			jsr 	IFT_Scroll 					; scroll screen up.
.01806f					_IFT_NL_NotEOS:
.01806f	68		pla				pla
.018070	60		rts				rts
.018071					IFT_UpperCase:
.018071	c9 61		cmp #$61			cmp 	#"a"
.018073	90 06		bcc $01807b			bcc 	_IFT_UCExit
.018075	c9 7b		cmp #$7b			cmp 	#"z"+1
.018077	b0 02		bcs $01807b			bcs 	_IFT_UCExit
.018079	49 20		eor #$20			eor 	#$20
.01807b					_IFT_UCExit:
.01807b	60		rts				rts
.01807c					IFT_Scroll:
.01807c	48		pha				pha 								; save AXY
.01807d	da		phx				phx
.01807e	5a		phy				phy
.01807f	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.018081					_IFT_SLoop:
.018081	20 a1 80	jsr $0180a1			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.018084	e8		inx				inx
.018085	e0 1f		cpx #$1f			cpx 	#IF_Height-1				; do whole screen
.018087	d0 f8		bne $018081			bne 	_IFT_SLoop
.018089	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.01808b	20 c8 80	jsr $0180c8			jsr 	IFT_SetYPos
.01808e	a2 40		ldx #$40			ldx 	#IF_Width 					; blank line
.018090					_IFT_SBlank:
.018090	a9 20		lda #$20			lda 	#32
.018092	20 d5 81	jsr $0181d5			jsr 	IF_Write
.018095	ca		dex				dex
.018096	d0 f8		bne $018090			bne 	_IFT_SBlank
.018098	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.01809a	20 c8 80	jsr $0180c8			jsr 	IFT_SetYPos
.01809d	7a		ply				ply
.01809e	fa		plx				plx
.01809f	68		pla				pla
.0180a0	60		rts				rts
.0180a1					_IFT_ScrollLine:
.0180a1	da		phx				phx
.0180a2	da		phx				phx
.0180a3	8a		txa				txa 								; copy line into buffer.
.0180a4	1a		inc a				inc 	a 							; next line down.
.0180a5	20 c8 80	jsr $0180c8			jsr 	IFT_SetYPos
.0180a8	a2 00		ldx #$00			ldx 	#0
.0180aa					_IFTScrollCopy1:
.0180aa	20 cc 81	jsr $0181cc			jsr 	IF_Read
.0180ad	9d 02 05	sta $0502,x			sta 	IFT_Buffer,x
.0180b0	e8		inx				inx
.0180b1	e0 40		cpx #$40			cpx 	#IF_Width
.0180b3	d0 f5		bne $0180aa			bne 	_IFTScrollCopy1
.0180b5	68		pla				pla
.0180b6	20 c8 80	jsr $0180c8			jsr 	IFT_SetYPos
.0180b9	a2 00		ldx #$00			ldx 	#0
.0180bb					_IFTScrollCopy2:
.0180bb	bd 02 05	lda $0502,x			lda 	IFT_Buffer,x
.0180be	20 d5 81	jsr $0181d5			jsr 	IF_Write
.0180c1	e8		inx				inx
.0180c2	e0 40		cpx #$40			cpx 	#IF_Width
.0180c4	d0 f5		bne $0180bb			bne 	_IFTScrollCopy2
.0180c6	fa		plx				plx
.0180c7	60		rts				rts
.0180c8					IFT_SetYPos:
.0180c8	48		pha				pha
.0180c9	da		phx				phx
.0180ca	aa		tax				tax
.0180cb	20 1b 80	jsr $01801b			jsr 	IFT_HomeCursor
.0180ce	e0 00		cpx #$00			cpx 	#0
.0180d0	f0 09		beq $0180db			beq 	_IFT_MOAExit
.0180d2					_IFT_MOALoop:
.0180d2	20 bc 81	jsr $0181bc			jsr 	IF_NewLine
.0180d5	ee 01 05	inc $0501			inc 	IFT_YCursor
.0180d8	ca		dex				dex
.0180d9	d0 f7		bne $0180d2			bne		_IFT_MOALoop
.0180db					_IFT_MOAExit:
.0180db	fa		plx				plx
.0180dc	68		pla				pla
.0180dd	60		rts				rts
.0180de					IFT_GetKeyCursor:
.0180de	20 e6 80	jsr $0180e6			jsr 	_IFT_FlipCursor 			; reverse current
.0180e1					_IFT_GKCWait:
.0180e1	20 e6 81	jsr $0181e6			jsr 	IF_GetKey 					; get key
.0180e4	f0 fb		beq $0180e1			beq 	_IFT_GKCWait
.0180e6					_IFT_FlipCursor:
.0180e6	48		pha				pha 								; save
.0180e7	20 cc 81	jsr $0181cc			jsr 	IF_Read 					; read
.0180ea	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.0180ed	49 80		eor #$80			eor 	#$80 						; reverse
.0180ef	20 d5 81	jsr $0181d5			jsr 	IF_Write 					; write
.0180f2	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.0180f5	68		pla				pla
.0180f6	60		rts				rts
.0180f7					IFT_ReadLine:
.0180f7	48		pha				pha
.0180f8					_IFT_RLLoop:
.0180f8	20 de 80	jsr $0180de			jsr 	IFT_GetKeyCursor 			; get keystroke
.0180fb	c9 0d		cmp #$0d			cmp 	#13							; return
.0180fd	f0 7d		beq $01817c			beq 	_IFT_RLExit
.0180ff	c9 20		cmp #$20			cmp 	#32 						; control character
.018101	90 05		bcc $018108			bcc 	_IFT_Control
.018103	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018106	80 f0		bra $0180f8			bra 	_IFT_RLLoop
.018108					_IFT_Control:
.018108	c9 01		cmp #$01			cmp 	#"A"-64
.01810a	f0 26		beq $018132			beq 	_IFT_Left
.01810c	c9 04		cmp #$04			cmp 	#"D"-64
.01810e	f0 2e		beq $01813e			beq 	_IFT_Right
.018110	c9 17		cmp #$17			cmp 	#"W"-64
.018112	f0 36		beq $01814a			beq 	_IFT_Up
.018114	c9 13		cmp #$13			cmp 	#"S"-64
.018116	f0 3e		beq $018156			beq 	_IFT_Down
.018118	c9 08		cmp #$08			cmp 	#"H"-64
.01811a	f0 09		beq $018125			beq 	_IFT_Backspace
.01811c	c9 1a		cmp #$1a			cmp 	#"Z"-64
.01811e	d0 d8		bne $0180f8			bne 	_IFT_RLLoop
.018120	20 00 80	jsr $018000			jsr 	IFT_ClearScreen				; clear CTL-Z
.018123	80 d3		bra $0180f8			bra 	_IFT_RLLoop
.018125					_IFT_Backspace:
.018125	ad 00 05	lda $0500			lda 	IFT_XCursor 				; check not start of line.
.018128	f0 ce		beq $0180f8			beq 	_IFT_RLLoop
.01812a	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.01812d	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.01812f	20 d5 81	jsr $0181d5			jsr 	IF_Write
.018132					_IFT_Left:
.018132	ce 00 05	dec $0500			dec 	IFT_XCursor 				; left CTL-W
.018135	10 29		bpl $018160			bpl 	_IFT_Reposition
.018137	a9 3f		lda #$3f			lda 	#IF_Width-1
.018139					_IFT_SetX:
.018139	8d 00 05	sta $0500			sta 	IFT_XCursor
.01813c	80 22		bra $018160			bra 	_IFT_Reposition
.01813e					_IFT_Right:
.01813e	ee 00 05	inc $0500			inc 	IFT_XCursor
.018141	ad 00 05	lda $0500			lda 	IFT_XCursor
.018144	49 40		eor #$40			eor 	#IF_Width
.018146	f0 f1		beq $018139			beq 	_IFT_SetX
.018148	80 16		bra $018160			bra 	_IFT_Reposition
.01814a					_IFT_Up:
.01814a	ce 01 05	dec $0501			dec 	IFT_YCursor
.01814d	10 11		bpl $018160			bpl 	_IFT_Reposition
.01814f	a9 1f		lda #$1f			lda 	#IF_Height-1
.018151					_IFT_SetY:
.018151	8d 01 05	sta $0501			sta 	IFT_YCursor
.018154	80 0a		bra $018160			bra 	_IFT_Reposition
.018156					_IFT_Down:
.018156	ee 01 05	inc $0501			inc 	IFT_YCursor
.018159	ad 01 05	lda $0501			lda 	IFT_YCursor
.01815c	49 20		eor #$20			eor 	#IF_Height
.01815e	f0 f1		beq $018151			beq 	_IFT_SetY
.018160					_IFT_Reposition:
.018160	ad 00 05	lda $0500			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.018163	48		pha				pha
.018164	ad 01 05	lda $0501			lda 	IFT_YCursor
.018167	20 c8 80	jsr $0180c8			jsr 	IFT_SetYPos
.01816a	68		pla				pla
.01816b	aa		tax				tax
.01816c	e0 00		cpx #$00			cpx 	#0
.01816e	f0 88		beq $0180f8			beq 	_IFT_RLLoop
.018170					_IFT_MoveRight:
.018170	20 cc 81	jsr $0181cc			jsr 	IF_Read
.018173	ee 00 05	inc $0500			inc 	IFT_XCursor
.018176	ca		dex				dex
.018177	d0 f7		bne $018170			bne 	_IFT_MoveRight
.018179	4c f8 80	jmp $0180f8			jmp 	_IFT_RLLoop
.01817c					_IFT_RLExit:
.01817c	ad 01 05	lda $0501			lda 	IFT_YCursor 				; go to start of line.
.01817f	20 c8 80	jsr $0180c8			jsr 	IFT_SetYPos
.018182	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.018184					_IFT_RLRead:
.018184	20 cc 81	jsr $0181cc			jsr 	IF_Read
.018187	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.01818a	e8		inx				inx
.01818b	e0 40		cpx #$40			cpx 	#IF_Width
.01818d	d0 f5		bne $018184			bne 	_IFT_RLRead
.01818f					_IFT_RL_Trim:
.01818f	ca		dex				dex 	 							; previous char
.018190	30 07		bmi $018199			bmi 	_IFT_Found 					; gone too far
.018192	bd 66 05	lda $0566,x			lda 	IFT_LineBuffer,x			; go back if space
.018195	c9 20		cmp #$20			cmp 	#" "
.018197	f0 f6		beq $01818f			beq 	_IFT_RL_Trim
.018199					_IFT_Found:
.018199	e8		inx				inx 								; forward to non-space
.01819a	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.01819c	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.01819f	20 59 80	jsr $018059			jsr 	IFT_NewLine 				; go to next line.
.0181a2	68		pla				pla
.0181a3	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.0181a5	a0 05		ldy #$05			ldy 	#IFT_LineBuffer >> 8
.0181a7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_em65816.asm

=64					IF_Width 	= 64 							; characters across
=32					IF_Height 	= 32 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line.
=8					IF_XPos 	= 8 							; current position, horizontal.
=$f0000					IF_Screen = $F0000							; 2k screen RAM here
=$f8010					IF_PKeyboard = $F8010						; Keyboard port.
=$f8000					IF_PBreak = $F8000 							; Break key.
.0181a8					IF_Reset:
.0181a8	60		rts				rts
.0181a9					IF_Home:
.0181a9	48		pha				pha
.0181aa	64 08		stz $08				stz 	IF_XPos 					; zero X position
.0181ac	a9 00		lda #$00			lda 	#IF_Screen & $FF 			; set r/w pos.
.0181ae	85 04		sta $04				sta 	IF_Pos
.0181b0	a9 00		lda #$00			lda 	#(IF_Screen >> 8) & $FF
.0181b2	85 05		sta $05				sta 	IF_Pos+1
.0181b4	a9 0f		lda #$0f			lda 	#IF_Screen >> 16
.0181b6	85 06		sta $06				sta 	IF_Pos+2
.0181b8	64 07		stz $07				stz 	IF_Pos+3
.0181ba	68		pla				pla
.0181bb	60		rts				rts
.0181bc					IF_NewLine:
.0181bc	48		pha				pha
.0181bd	64 08		stz $08				stz 	IF_XPos						; back to start of line
.0181bf	18		clc				clc 								; down one line
.0181c0	a5 04		lda $04				lda 	IF_Pos
.0181c2	69 40		adc #$40			adc 	#64
.0181c4	85 04		sta $04				sta 	IF_Pos
.0181c6	90 02		bcc $0181ca			bcc 	_IF_NoCarry 				; carry through.
.0181c8	e6 05		inc $05				inc 	IF_Pos+1
.0181ca					_IF_NoCarry:
.0181ca	68		pla				pla
.0181cb	60		rts				rts
.0181cc					IF_Read:
.0181cc	5a		phy				phy 								; save current Y
.0181cd	a4 08		ldy $08				ldy 	IF_XPos 					; read character at current position
.0181cf	b7 04		lda [$04],y			lda 	[IF_Pos],y
.0181d1	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181d3	7a		ply				ply									; restore Y
.0181d4	60		rts				rts
.0181d5					IF_Write:
.0181d5	5a		phy				phy 								; save current Y
.0181d6	a4 08		ldy $08				ldy 	IF_XPos 					; write character at current position
.0181d8	97 04		sta [$04],y			sta 	[IF_Pos],y
.0181da	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181dc	7a		ply				ply									; restore Y
.0181dd	60		rts				rts
.0181de					IF_LeftOne:
.0181de	c6 08		dec $08				dec 	IF_XPos
.0181e0	60		rts				rts
.0181e1					IF_CheckBreak:
.0181e1	af 00 80 0f	lda $0f8000			lda 	IF_PBreak					; non-zero if Ctrl+C pressed.
.0181e5	60		rts				rts
.0181e6					IF_GetKey:
.0181e6	af 10 80 0f	lda $0f8010			lda 	IF_PKeyboard				; read keyboard
.0181ea	f0 08		beq $0181f4			beq		_IFGK_NoKey 				; skip if zero,no key pressed
.0181ec	48		pha				pha 								; key pressed, clear queue.
.0181ed	a9 00		lda #$00			lda 	#0
.0181ef	8f 10 80 0f	sta $0f8010			sta 	IF_PKeyboard
.0181f3	68		pla				pla
.0181f4					_IFGK_NoKey:
.0181f4	09 00		ora #$00			ora 	#0							; set Z flag appropriately.
.0181f6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.0181f7					TIM_Error:
.0181f7	20 29 80	jsr $018029			jsr 	IFT_UpLine 					; go up one line.
.0181fa	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.0181fc	80 02		bra $018200			bra 	TIM_ShowPrompt
.0181fe					TIM_NewCommand:
.0181fe	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.018200					TIM_ShowPrompt:
.018200	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.018203	20 f7 80	jsr $0180f7			jsr 	IFT_ReadLine	 			; get character, go to next line
.018206	20 59 80	jsr $018059			jsr 	IFT_NewLine					; go to next line.
.018209	86 10		stx $10				stx 	zTemp1 						; save line read address
.01820b	84 11		sty $11				sty 	zTemp1+1
.01820d	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.01820f	b1 10		lda ($10),y			lda 	(zTemp1),y
.018211	c9 3f		cmp #$3f			cmp 	#"?"
.018213	f0 04		beq $018219			beq 	TIM_SkipFirst
.018215	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.018217	d0 01		bne $01821a			bne 	TIM_NotDot
.018219					TIM_SkipFirst:
.018219	c8		iny				iny
.01821a					TIM_NotDot:
.01821a	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.01821c	c9 52		cmp #$52			cmp 	#"R"						; show registers
.01821e	f0 6b		beq $01828b			beq 	TIM_ShowRegisters
.018220	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.018222	f0 12		beq $018236			beq 	TIM_ShowMemory
.018224	c9 47		cmp #$47			cmp 	#"G"						; execute
.018226	f0 49		beq $018271			beq 	TIM_Execute
.018228	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.01822a	f0 07		beq $018233			beq 	TIM_GoLoadMemory
.01822c	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.01822e	d0 c7		bne $0181f7			bne 	TIM_Error
.018230	4c af 83	jmp $0183af			jmp 	TIM_UpdateRegisters
.018233					TIM_GoLoadMemory:
.018233	4c df 83	jmp $0183df			jmp 	TIM_LoadMemory
.018236					TIM_ShowMemory:
.018236	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.018239	b0 bc		bcs $0181f7			bcs 	TIM_Error
.01823b	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.01823d	85 12		sta $12				sta 	zTemp2
.01823f	a5 15		lda $15				lda 	zTemp3+1
.018241	85 13		sta $13				sta 	zTemp2+1
.018243	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.018246	90 08		bcc $018250			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.018248	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.01824a	85 14		sta $14				sta 	zTemp3
.01824c	a5 13		lda $13				lda 	zTemp2+1
.01824e	85 15		sta $15				sta 	zTemp3+1
.018250					_TIMSM_Start:
.018250	20 03 83	jsr $018303			jsr 	TIM_WriteLine 				; write one line of hex out
.018253	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.018255	18		clc				clc
.018256	69 10		adc #$10			adc 	#16
.018258	85 12		sta $12				sta 	zTemp2
.01825a	90 02		bcc $01825e			bcc 	_TIMSM_NoCarry
.01825c	e6 13		inc $13				inc 	zTemp2+1
.01825e					_TIMSM_NoCarry:
.01825e	20 e1 81	jsr $0181e1			jsr 	IF_CheckBreak 				; check CTL+C
.018261	d0 0b		bne $01826e			bne 	_TIMSM_Ends 				; if pressed break out.
.018263	38		sec				sec 								; check past the end address in zTemp3
.018264	a5 14		lda $14				lda 	zTemp3
.018266	e5 12		sbc $12				sbc 	zTemp2
.018268	a5 15		lda $15				lda 	zTemp3+1
.01826a	e5 13		sbc $13				sbc 	zTemp2+1
.01826c	10 e2		bpl $018250			bpl 	_TIMSM_Start
.01826e					_TIMSM_Ends:
.01826e	4c fe 81	jmp $0181fe			jmp 	TIM_NewCommand
.018271					TIM_Execute:
.018271	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; get the execute address
.018274	b0 81		bcs $0181f7			bcs 	TIM_Error 					; not legitimate
.018276	ae cd 03	ldx $03cd			ldx 	TIM_SP 						; set up SP
.018279	9a		txs				txs
.01827a	ad c8 03	lda $03c8			lda 	TIM_SR 						; Status for PLP
.01827d	48		pha				pha
.01827e	ad c9 03	lda $03c9			lda 	TIM_A 						; restore AXYZ
.018281	ae ca 03	ldx $03ca			ldx 	TIM_X
.018284	ac cb 03	ldy $03cb			ldy 	TIM_Y
.018287	28		plp				plp 								; and PS Byte.
.018288	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.01828b					TIM_Start:
.01828b					TIM_ShowRegisters:
.01828b	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.01828e	8d c7 03	sta $03c7			sta 	TIM_IRQ+1
.018291	ad ff ff	lda $ffff			lda 	$FFFF
.018294	8d c6 03	sta $03c6			sta 	TIM_IRQ
.018297	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.018299					_TIMSR_Text:
.018299	bf ca 82 01	lda $0182ca,x			lda 	_TIMSR_Label,x
.01829d	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182a0	e8		inx				inx
.0182a1	e0 20		cpx #$20			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.0182a3	d0 f4		bne $018299			bne 	_TIMSR_Text
.0182a5	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.0182a7					_TIMSR_Skip:
.0182a7	e8		inx				inx
.0182a8					_TIMSR_LoopSpace:
.0182a8	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.0182aa	b0 04		bcs $0182b0			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.0182ac	8a		txa				txa
.0182ad	4a		lsr a				lsr 	a
.0182ae	b0 05		bcs $0182b5			bcs 	_TIMSR_NoSpace
.0182b0					_TIMSR_Space:
.0182b0	a9 20		lda #$20			lda 	#" "
.0182b2	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182b5					_TIMSR_NoSpace:
.0182b5	bd c4 03	lda $03c4,x			lda 	TIM_PC,x 					; output hex value.
.0182b8	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.0182bb	e8		inx				inx
.0182bc	e0 08		cpx #$08			cpx 	#TIM_Z-TIM_PC
.0182be	f0 e7		beq $0182a7			beq 	_TIMSR_Skip
.0182c0	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.0182c2	d0 e4		bne $0182a8			bne 	_TimSR_LoopSpace
.0182c4	20 59 80	jsr $018059			jsr 	IFT_NewLine 				; new line
.0182c7	4c fe 81	jmp $0181fe			jmp	 	TIM_NewCommand 				; new command.
.0182ca					_TIMSR_Label:
>0182ca	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>0182d2	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>0182e2	52
>0182e3	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.0182ea					_TIMSR_LabelEnd:
.0182ea					TIM_WriteHex:
.0182ea	48		pha				pha 								; save A
.0182eb	4a		lsr a				lsr 	a 							; shift MSB->LSB
.0182ec	4a		lsr a				lsr 	a
.0182ed	4a		lsr a				lsr 	a
.0182ee	4a		lsr a				lsr 	a
.0182ef	20 f3 82	jsr $0182f3			jsr 	_TIMWH_Nibble 				; print MSB
.0182f2	68		pla				pla 								; restore and print LSB
.0182f3					_TIMWH_Nibble:
.0182f3	48		pha				pha
.0182f4	29 0f		and #$0f			and 	#15 						; mask out
.0182f6	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.0182f8	90 02		bcc $0182fc			bcc 	_TIMWHNoLetter
.0182fa	69 06		adc #$06			adc 	#6
.0182fc					_TIMWHNoLetter:
.0182fc	69 30		adc #$30			adc 	#48
.0182fe	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter 			; print it out.
.018301	68		pla				pla
.018302	60		rts				rts
.018303					TIM_WriteLine:
.018303	a9 2e		lda #$2e			lda 	#"." 						; prompt
.018305	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018308	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.01830a	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01830d	a5 13		lda $13				lda 	zTemp2+1 					; write address
.01830f	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.018312	a5 12		lda $12				lda 	zTemp2
.018314	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.018317	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.018319					_TIMWL_Loop:
.018319	a9 20		lda #$20			lda 	#" "
.01831b	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01831e	b1 12		lda ($12),y			lda 	(zTemp2),y
.018320	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.018323	c8		iny				iny
.018324	c0 10		cpy #$10			cpy 	#16
.018326	d0 f1		bne $018319			bne 	_TIMWL_Loop
.018328	4c 59 80	jmp $018059			jmp 	IFT_NewLine 				; new line and exit
.01832b					TIM_GetHex:
.01832b	c8		iny				iny
.01832c	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.01832e	c9 20		cmp #$20			cmp 	#32
.018330	f0 f9		beq $01832b			beq 	TIM_GetHex
.018332	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.018334	f0 f5		beq $01832b			beq 	TIM_GetHex
.018336	20 5f 83	jsr $01835f			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.018339	b0 23		bcs $01835e			bcs 	_TIMGH_Exit					; if first bad then exit now.
.01833b	a9 00		lda #$00			lda 	#0 							; zero result
.01833d	85 14		sta $14				sta 	zTemp3
.01833f	85 15		sta $15				sta 	zTemp3+1
.018341					_TIM_GHLoop:
.018341	20 5f 83	jsr $01835f			jsr 	TIM_GetHexCharacter 		; get next character
.018344	b0 17		bcs $01835d			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.018346	c8		iny				iny 								; skip over it.
.018347	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.018349	26 15		rol $15				rol 	zTemp3+1
.01834b	06 14		asl $14				asl 	zTemp3 						; now x 2
.01834d	26 15		rol $15				rol 	zTemp3+1
.01834f	06 14		asl $14				asl 	zTemp3						; now x 4
.018351	26 15		rol $15				rol 	zTemp3+1
.018353	06 14		asl $14				asl 	zTemp3 						; now x 8
.018355	26 15		rol $15				rol 	zTemp3+1
.018357	05 14		ora $14				ora 	zTemp3 						; OR result in
.018359	85 14		sta $14				sta 	zTemp3
.01835b	80 e4		bra $018341			bra 	_TIM_GHLoop 				; loop round again.
.01835d					_TIMGH_Okay:
.01835d	18		clc				clc
.01835e					_TIMGH_Exit:
.01835e	60		rts				rts
.01835f					TIM_GetHexCharacter:
.01835f	b1 10		lda ($10),y			lda 	(zTemp1),y
.018361	38		sec				sec
.018362	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.018364	90 0e		bcc $018374			bcc 	_TIM_GHCFail
.018366	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.018368	90 0b		bcc $018375			bcc 	_TIM_GHCExit
.01836a	c9 11		cmp #$11			cmp 	#65-48						; < A
.01836c	90 06		bcc $018374			bcc		_TIM_GHCFail
.01836e	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.018370	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.018372	90 01		bcc $018375			bcc		_TIM_GHCExit
.018374					_TIM_GHCFail:
.018374	38		sec				sec
.018375					_TIM_GHCExit:
.018375	60		rts				rts
.018376					TIM_BreakVector:
.018376	da		phx				phx									; save X/A on stack
.018377	48		pha				pha
.018378	ba		tsx				tsx 								; X points to S
.018379	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.01837c	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.01837e	d0 03		bne $018383			bne 	_TIMBreak					; if set, it's BRK
.018380	68		pla				pla 								; abandon routine.
.018381	fa		plx				plx
.018382	40		rti				rti
.018383					_TIMBreak:
.018383	68		pla				pla 								; save A X Y and maybe Z
.018384	8d c9 03	sta $03c9			sta 	TIM_A
.018387	fa		plx				plx
.018388	8e ca 03	stx $03ca			stx 	TIM_X
.01838b	8c cb 03	sty $03cb			sty 	TIM_Y
.01838e	68		pla				pla 								; get Status Register
.01838f	8d c8 03	sta $03c8			sta 	TIM_SR
.018392	68		pla				pla
.018393	8d c5 03	sta $03c5			sta 	TIM_PC+1 					; save calling address
.018396	68		pla				pla
.018397	8d c4 03	sta $03c4			sta 	TIM_PC 						; high byte
.01839a	ad c5 03	lda $03c5			lda 	TIM_PC+1 					; dec PC to point right.
.01839d	d0 03		bne $0183a2			bne 	_TIMDecrement 				; brk bumps it.
.01839f	ce c4 03	dec $03c4			dec 	TIM_PC
.0183a2					_TIMDecrement:
.0183a2	ce c5 03	dec $03c5			dec 	TIM_PC+1
.0183a5	ba		tsx				tsx 								; and copy SP
.0183a6	8e cd 03	stx $03cd			stx 	TIM_SP
.0183a9	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.0183ab	9a		txs				txs
.0183ac	4c 8b 82	jmp $01828b			jmp 	TIM_Start 					; and start up TIM monitor.
.0183af					TIM_UpdateRegisters:
.0183af	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; PC
.0183b2	b0 28		bcs $0183dc			bcs 	_TIMURFail
.0183b4	a5 14		lda $14				lda 	zTemp3
.0183b6	8d c5 03	sta $03c5			sta 	Tim_PC+1
.0183b9	a5 15		lda $15				lda 	zTemp3+1
.0183bb	8d c4 03	sta $03c4			sta 	Tim_PC
.0183be	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; ignore IRQ
.0183c1	b0 19		bcs $0183dc			bcs 	_TIMURFail
.0183c3	a2 00		ldx #$00			ldx 	#0
.0183c5					_TIM_URLoop:
.0183c5	e0 04		cpx #$04			cpx 	#Tim_Z-Tim_SR
.0183c7	d0 01		bne $0183ca			bne 	_TIM_1
.0183c9	e8		inx				inx
.0183ca					_TIM_1:
.0183ca	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; registers
.0183cd	b0 0d		bcs $0183dc			bcs 	_TIMURFail
.0183cf	a5 14		lda $14				lda 	zTemp3
.0183d1	9d c8 03	sta $03c8,x			sta 	Tim_SR,x
.0183d4	e8		inx				inx
.0183d5	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.0183d7	d0 ec		bne $0183c5			bne 	_TIM_URLoop
.0183d9	4c fe 81	jmp $0181fe			jmp 	TIM_NewCommand
.0183dc					_TIMURFail:
.0183dc	4c f7 81	jmp $0181f7			jmp 	TIM_Error
.0183df					TIM_LoadMemory:
.0183df	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; target address => zTemp2
.0183e2	a5 14		lda $14				lda 	zTemp3
.0183e4	85 12		sta $12				sta 	zTemp2
.0183e6	a5 15		lda $15				lda 	zTemp3+1
.0183e8	85 13		sta $13				sta 	zTemp2+1
.0183ea					_TIM_LMLoop:
.0183ea	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; next byte ?
.0183ed	b0 0e		bcs $0183fd			bcs 	_TIMLMDone 					; no more
.0183ef	a2 00		ldx #$00			ldx 	#0							; write out.
.0183f1	a5 14		lda $14				lda 	zTemp3
.0183f3	81 12		sta ($12,x)			sta 	(zTemp2,x)
.0183f5	e6 12		inc $12				inc 	zTemp2 						; bump address
.0183f7	d0 f1		bne $0183ea			bne 	_TIM_LMLoop
.0183f9	e6 13		inc $13				inc 	zTemp2+1
.0183fb	80 ed		bra $0183ea			bra 	_TIM_LMLoop
.0183fd					_TIMLMDone:
.0183fd	4c fe 81	jmp $0181fe			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/skip.asm

.018400					StructureSearchSingle:
.018400	a2 00		ldx #$00			ldx 	#0 							; we always search for XA. This disables X.
.018402					StructureSearchDouble:
.018402	85 10		sta $10				sta 	zTemp1 						; save the targets in zTemp1,zTemp1+1
.018404	86 11		stx $11				stx 	zTemp1+1
.018406	a9 00		lda #$00			lda 	#0 							; set the structure depth to zero (zTemp2)
.018408	85 12		sta $12				sta 	zTemp2
.01840a	80 18		bra $018424			bra 	_SSWLoop 					; jump in, start scanning from here.
.01840c					_SSWNextLine:
.01840c	a0 00		ldy #$00			ldy 	#0 							; point to offset
.01840e	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read it
.018410	18		clc				clc
.018411	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.018413	85 18		sta $18				sta 	zCodePtr
.018415	90 02		bcc $018419			bcc 	_SNLNoCarry
.018417	e6 19		inc $19				inc 	zCodePtr+1
.018419					_SNLNoCarry:
.018419	a0 00		ldy #$00			ldy 	#0
.01841b	b7 18		lda [$18],y			lda 	[zCodePtr],y
.01841d	c9 00		cmp #$00			cmp 	#0					 		; if zero, fail.
.01841f	f0 54		beq $018475			beq 	_SSWFail
.018421	c8		iny				iny
.018422	c8		iny				iny
.018423					_SSWNextSimple:
.018423	c8		iny				iny
.018424					_SSWLoop:
.018424	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018426	c9 00		cmp #$00			cmp 	#0 							; end of line ?
.018428	f0 e2		beq $01840c			beq 	_SSWNextLine 				; if so, then next line
.01842a	10 f7		bpl $018423			bpl 	_SSWNextSimple 				; needs to be a token, just skip char/number.
.01842c	a6 12		ldx $12				ldx 	zTemp2 						; check structure count
.01842e	d0 08		bne $018438			bne 	_SSWCheckUpDown 			; if it's non zero, then a match doesn't work.
.018430	c5 10		cmp $10				cmp 	zTemp1 						; found the right keyword, either choice.
.018432	f0 2d		beq $018461			beq 	_SSWFound 					; then exit.
.018434	c5 11		cmp $11				cmp 	zTemp1+1
.018436	f0 29		beq $018461			beq 	_SSWFound
.018438					_SSWCheckUpDown:
.018438	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus 			; if < keyword +
.01843a	90 10		bcc $01844c			bcc 	_SSWNext
.01843c	c9 93		cmp #$93			cmp 	#firstKeywordMinus 			; if < keyword - then as keyword +
.01843e	90 08		bcc $018448			bcc 	_SSWPlus
.018440	c9 98		cmp #$98			cmp 	#firstUnaryFunction			; if < first unary down as keyword -
.018442	b0 08		bcs $01844c			bcs 	_SSWNext
.018444	c6 12		dec $12				dec 	zTemp2 						; reduce structure count.
.018446	c6 12		dec $12				dec 	zTemp2
.018448					_SSWPlus:
.018448	e6 12		inc $12				inc 	zTemp2
.01844a	30 16		bmi $018462			bmi 	_SSWUnder					; error if driven -ve
.01844c					_SSWNext:
.01844c	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read element
.01844e	c8		iny				iny 								; skip
.01844f	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018451	90 0c		bcc $01845f			bcc 	_SEDone 					; so just skip over it.
.018453	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018455	90 07		bcc $01845e			bcc 	_SEDouble
.018457	98		tya				tya 								; this is Y + 1
.018458	18		clc				clc
.018459	77 18		adc [$18],y			adc 	[zCodePtr],y 				; add total length of element
.01845b	a8		tay				tay 								; back in Y.
.01845c	88		dey				dey 								; fix up, one for the +1, one for the iny
.01845d	88		dey				dey
.01845e					_SEDouble:
.01845e	c8		iny				iny
.01845f					_SEDone:
.01845f	80 c3		bra $018424			bra 	_SSWLoop
.018461					_SSWFound:
.018461	60		rts				rts
.018462					_SSWUnder:
.018462	20 86 85	jsr $018586			jsr ERR_Handler
>018465	53 74 72 75 63 74 75 72			.text "Structure order",0
>01846d	65 20 6f 72 64 65 72 00
.018475					_SSWFail:
.018475	20 86 85	jsr $018586			jsr ERR_Handler
>018478	43 61 6e 27 74 20 66 69			.text "Can't find structure",0
>018480	6e 64 20 73 74 72 75 63 74 75 72 65 00
.01848d					SkipEndOfCommand:
.01848d	b7 18		lda [$18],y			lda 	[zCodePtr],y
.01848f	c9 00		cmp #$00			cmp 	#0 							; if zero, end of line, so exit
.018491	f0 19		beq $0184ac			beq 	_SOCExit
.018493	c9 c0		cmp #$c0			cmp 	#token_Colon 				; if colon, end of command
.018495	f0 15		beq $0184ac			beq 	_SOCExit
.018497	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read element
.018499	c8		iny				iny 								; skip
.01849a	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.01849c	90 0c		bcc $0184aa			bcc 	_SEDone 					; so just skip over it.
.01849e	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.0184a0	90 07		bcc $0184a9			bcc 	_SEDouble
.0184a2	98		tya				tya 								; this is Y + 1
.0184a3	18		clc				clc
.0184a4	77 18		adc [$18],y			adc 	[zCodePtr],y 				; add total length of element
.0184a6	a8		tay				tay 								; back in Y.
.0184a7	88		dey				dey 								; fix up, one for the +1, one for the iny
.0184a8	88		dey				dey
.0184a9					_SEDouble:
.0184a9	c8		iny				iny
.0184aa					_SEDone:
.0184aa	80 e1		bra $01848d			bra 	SkipEndOfCommand
.0184ac					_SOCExit:
.0184ac	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stack.asm

.0184ad					StackReset:
.0184ad	48		pha				pha
.0184ae	5a		phy				phy
.0184af	a9 ca		lda #$ca			lda 	#(BasicStack & $FF) 		; reset pointer
.0184b1	85 28		sta $28				sta 	zBasicSP
.0184b3	a9 05		lda #$05			lda 	#(BasicStack >> 8)
.0184b5	85 29		sta $29				sta 	zBasicSP+1
.0184b7	a0 00		ldy #$00			ldy 	#0 							; reset stack top to $00 which cannot
.0184b9	98		tya				tya 								; be a legal token.
.0184ba	91 28		sta ($28),y			sta 	(zBasicSP),y
.0184bc	7a		ply				ply
.0184bd	68		pla				pla
.0184be	60		rts				rts
.0184bf					StackPushFrame:
.0184bf	48		pha				pha
.0184c0	5a		phy				phy
.0184c1	1a		inc a				inc 	a 							; one extra byte in frame, for the marker.
.0184c2	48		pha				pha 								; save it.
.0184c3	29 0f		and #$0f			and 	#$0F 						; lower 4 bits
.0184c5	18		clc				clc 								; add to Basic Stack
.0184c6	65 28		adc $28				adc 	zBasicSP
.0184c8	85 28		sta $28				sta 	zBasicSP
.0184ca	90 02		bcc $0184ce			bcc 	_SPFNoBump
.0184cc	e6 29		inc $29				inc 	zBasicSP+1
.0184ce					_SPFNoBump:
.0184ce	a0 00		ldy #$00			ldy 	#0
.0184d0	68		pla				pla
.0184d1	91 28		sta ($28),y			sta 	(zBasicSP),y
.0184d3	7a		ply				ply
.0184d4	68		pla				pla
.0184d5	60		rts				rts
.0184d6					StackPopFrame:
.0184d6	48		pha				pha
.0184d7	5a		phy				phy
.0184d8	a0 00		ldy #$00			ldy 	#0 							; compare with top of stack using EOR
.0184da	51 28		eor ($28),y			eor 	(zBasicSP),y
.0184dc	29 f0		and #$f0			and 	#$F0 						; top 4 bits zero, match
.0184de	d0 12		bne $0184f2			bne 	SPFError 					; mixed structures
.0184e0	b1 28		lda ($28),y			lda 	(zBasicSP),y 				; get size from byte
.0184e2	29 0f		and #$0f			and 	#$0F
.0184e4	49 ff		eor #$ff			eor 	#$FF						; 2's complement
.0184e6	38		sec				sec
.0184e7	65 28		adc $28				adc 	zBasicSP
.0184e9	85 28		sta $28				sta 	zBasicSP
.0184eb	b0 02		bcs $0184ef			bcs 	_SPFNoBump
.0184ed	c6 29		dec $29				dec 	zBasicSP+1
.0184ef					_SPFNoBump:
.0184ef	7a		ply				ply
.0184f0	68		pla				pla
.0184f1	60		rts				rts
.0184f2					SPFError:
.0184f2	20 86 85	jsr $018586			jsr ERR_Handler
>0184f5	4d 69 78 65 64 20 53 74			.text "Mixed Structures",0
>0184fd	72 75 63 74 75 72 65 73 00
.018506					StackSavePosition:
.018506	98		tya				tya
.018507	5a		phy				phy
.018508	a0 05		ldy #$05			ldy 	#5
.01850a	91 28		sta ($28),y			sta 	(zBasicSP),y
.01850c	a0 01		ldy #$01			ldy 	#1
.01850e	a5 18		lda $18				lda 	zCodePtr+0 					; 4 bytes, could reduce this for 65816/6502
.018510	91 28		sta ($28),y			sta 	(zBasicSP),y
.018512	c8		iny				iny
.018513	a5 19		lda $19				lda 	zCodePtr+1
.018515	91 28		sta ($28),y			sta 	(zBasicSP),y
.018517	c8		iny				iny
.018518	a5 1a		lda $1a				lda 	zCodePtr+2
.01851a	91 28		sta ($28),y			sta 	(zBasicSP),y
.01851c	c8		iny				iny
.01851d	a5 1b		lda $1b				lda 	zCodePtr+3
.01851f	91 28		sta ($28),y			sta 	(zBasicSP),y
.018521	7a		ply				ply
.018522	60		rts				rts
.018523					StackRestorePosition:
.018523	5a		phy				phy
.018524	a0 01		ldy #$01			ldy 	#1 							; copy 4 bytes that are the pointer
.018526	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018528	85 18		sta $18				sta 	zCodePtr+0
.01852a	c8		iny				iny
.01852b	b1 28		lda ($28),y			lda 	(zBasicSP),y
.01852d	85 19		sta $19				sta 	zCodePtr+1
.01852f	c8		iny				iny
.018530	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018532	85 1a		sta $1a				sta 	zCodePtr+2
.018534	c8		iny				iny
.018535	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018537	85 1b		sta $1b				sta 	zCodePtr+3
.018539	c8		iny				iny
.01853a	b1 28		lda ($28),y			lda 	(zBasicSP),y 				; offset
.01853c	7a		ply				ply 								; restore Y
.01853d	a8		tay				tay
.01853e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/vectors.asm

.01853f					VIOCharPrint:
.01853f	4c 35 80	jmp $018035			jmp 	IFT_PrintCharacter
.018542					VIOCharGet:
.018542	20 e6 81	jsr $0181e6			jsr 	IF_GetKey
.018545	c9 00		cmp #$00			cmp 	#0
.018547	f0 02		beq $01854b			beq 	_VCG0
.018549	38		sec				sec
.01854a	60		rts				rts
.01854b	18		clc		_VCG0:	clc
.01854c	60		rts				rts
.01854d					VIOCheckBreak:
.01854d	4c e1 81	jmp $0181e1			jmp 	IF_CheckBreak
.018550					VIOCharGetPosition:
.018550	ad 00 05	lda $0500			lda 	IFT_XCursor
.018553	60		rts				rts
.018554					VIOReadLine:
.018554	4c f7 80	jmp $0180f7			jmp 	IFT_ReadLine

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/errors.asm

.018557					SyntaxError:
.018557	20 86 85	jsr $018586			jsr 	ERR_Handler
>01855a	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>018562	72 72 6f 72 00
.018567					TypeError:
.018567	20 86 85	jsr $018586			jsr 	ERR_Handler
>01856a	57 72 6f 6e 67 20 74 79				.text 	"Wrong type",0
>018572	70 65 00
.018575					BadParamError:
.018575	20 86 85	jsr $018586			jsr 	ERR_Handler
>018578	42 61 64 20 50 61 72 61				.text 	"Bad Parameter",0
>018580	6d 65 74 65 72 00
.018586					ERR_Handler:
.018586	a0 00		ldy #$00			ldy 	#0
.018588	c8		iny				iny
.018589	b7 18		lda [$18],y			lda 	[zCodePtr],y
.01858b	85 80		sta $80				sta 	XS_Mantissa
.01858d	c8		iny				iny
.01858e	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018590	85 81		sta $81				sta 	XS_Mantissa+1
.018592	fa		plx				plx 								; address in XY
.018593	7a		ply				ply
.018594	e8		inx				inx 								; bump, because of RTS/JSR address -1
.018595	d0 01		bne $018598			bne 	_EHNoSkip
.018597	c8		iny				iny
.018598					_EHNoSkip:
.018598	20 bc 85	jsr $0185bc			jsr 	PrintROMMessage 			; print message from ROM.
.01859b	a5 80		lda $80				lda 	XS_Mantissa					; line number = 0
.01859d	05 81		ora $81				ora 	XS_Mantissa+1
.01859f	f0 0c		beq $0185ad			beq 	_EHNoLine
.0185a1	a2 b7		ldx #$b7			ldx 	#_EHAt & $FF 				; print " at "
.0185a3	a0 85		ldy #$85			ldy 	#(_EHAt >> 8) & $FF
.0185a5	20 bc 85	jsr $0185bc			jsr 	PrintROMMessage
.0185a8	a2 00		ldx #$00			ldx 	#0 							; Print line number
.0185aa	20 d1 85	jsr $0185d1			jsr 	Print16BitInteger
.0185ad					_EHNoLine:
.0185ad	80 fe		bra $0185ad			bra 	_EHNoLine
.0185af	a9 0d		lda #$0d			lda 	#13
.0185b1	20 3f 85	jsr $01853f			jsr 	VIOCharPrint
.0185b4	4c 4e 88	jmp $01884e			jmp 	ErrorStart 					; normally warm start, no message.
>0185b7	20 61 74 20 00			_EHAt:	.text 	" at ",0
.0185bc					PrintROMMessage:
.0185bc	86 1c		stx $1c				stx 	zLTemp1 					; save addres
.0185be	84 1d		sty $1d				sty 	zLTemp1+1
.0185c0	4b		phk				phk 								; get current code page
.0185c1	68		pla				pla
.0185c2	85 1e		sta $1e				sta 	ZLTemp1+2 					; put into the 3rd byte so we can use
.0185c4	a0 00		ldy #$00			ldy 	#0
.0185c6					_PRMLoop:
.0185c6	b7 1c		lda [$1c],y			lda 	[zLTemp1],y 				; 65816
.0185c8	f0 06		beq $0185d0			beq		_PRMExit 					; character $00 => exit
.0185ca	c8		iny				iny  								; bump Y and print it.
.0185cb	20 3f 85	jsr $01853f			jsr 	VIOCharPrint
.0185ce	80 f6		bra $0185c6			bra 	_PRMLoop
.0185d0					_PRMExit:
.0185d0	60		rts				rts
.0185d1					Print16BitInteger:
.0185d1	a9 00		lda #$00			lda 	#0 							; make 32 bit
.0185d3	85 82		sta $82				sta 	XS_Mantissa+2
.0185d5	85 83		sta $83				sta 	XS_Mantissa+3
.0185d7					Print32BitInteger:
.0185d7	a9 00		lda #$00			lda 	#0
.0185d9	8d 14 03	sta $0314			sta 	NumBufX 					; reset the conversion pointer
.0185dc	aa		tax				tax 								; convert bottom level.
.0185dd	20 e0 a1	jsr $01a1e0			jsr 	INTToString 				; make string from integer in Num_Buffer
.0185e0	a2 00		ldx #$00			ldx 	#0 							; print buffer contents
.0185e2	bd 15 03	lda $0315,x	_P1Loop:lda 	Num_Buffer,x
.0185e5	f0 06		beq $0185ed			beq 	_P1Exit
.0185e7	20 3f 85	jsr $01853f			jsr 	VIOCharPrint
.0185ea	e8		inx				inx
.0185eb	80 f5		bra $0185e2			bra 	_P1Loop
.0185ed	8a		txa		_P1Exit:txa 								; return chars printed.
.0185ee	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm


;******  Processing file: modules/basic/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b6					lastUnaryFunction = $b6
.0185ef					VectorTable:
>0185ef	02 94					.word BinaryOp_And         & $FFFF ; $80 and
>0185f1	1e 94					.word BinaryOp_Or          & $FFFF ; $81 or
>0185f3	3a 94					.word BinaryOp_Xor         & $FFFF ; $82 xor
>0185f5	3a 94					.word BinaryOp_Eor         & $FFFF ; $83 eor
>0185f7	71 94					.word Binary_Equal         & $FFFF ; $84 =
>0185f9	7a 94					.word Binary_NotEqual      & $FFFF ; $85 <>
>0185fb	83 94					.word Binary_Less          & $FFFF ; $86 <
>0185fd	8c 94					.word Binary_LessEqual     & $FFFF ; $87 <=
>0185ff	9e 94					.word Binary_Greater       & $FFFF ; $88 >
>018601	95 94					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>018603	36 95					.word BinaryOp_Add         & $FFFF ; $8a +
>018605	52 95					.word BinaryOp_Subtract    & $FFFF ; $8b -
>018607	63 95					.word BinaryOp_Multiply    & $FFFF ; $8c *
>018609	74 95					.word BinaryOp_Divide      & $FFFF ; $8d /
>01860b	ad 86					.word NotImplemented       & $FFFF ; $8e ^
>01860d	91 8d					.word Command_IF           & $FFFF ; $8f if
>01860f	fe 91					.word Command_WHILE        & $FFFF ; $90 while
>018611	26 92					.word Command_REPEAT       & $FFFF ; $91 repeat
>018613	e3 89					.word Command_FOR          & $FFFF ; $92 for
>018615	ad 86					.word NotImplemented       & $FFFF ; $93 then
>018617	ee 8d					.word Command_ENDIF        & $FFFF ; $94 endif
>018619	1b 92					.word Command_WEND         & $FFFF ; $95 wend
>01861b	2f 92					.word Command_UNTIL        & $FFFF ; $96 until
>01861d	60 8a					.word Command_NEXT         & $FFFF ; $97 next
>01861f	ad 86					.word NotImplemented       & $FFFF ; $98 not
>018621	ad 86					.word NotImplemented       & $FFFF ; $99 fn(
>018623	79 96					.word Unary_Abs            & $FFFF ; $9a abs(
>018625	d4 97					.word Unary_Asc            & $FFFF ; $9b asc(
>018627	0e a9					.word Unary_Int            & $FFFF ; $9c int(
>018629	93 96					.word Unary_Peek           & $FFFF ; $9d peek(
>01862b	8f a8					.word Unary_Rnd            & $FFFF ; $9e rnd(
>01862d	06 97					.word Unary_Usr            & $FFFF ; $9f usr(
>01862f	13 98					.word Unary_Left           & $FFFF ; $a0 left$(
>018631	28 98					.word Unary_Right          & $FFFF ; $a1 right$(
>018633	fa 97					.word Unary_Mid            & $FFFF ; $a2 mid$(
>018635	73 99					.word Unary_Spc            & $FFFF ; $a3 spc(
>018637	a2 97					.word Unary_Str            & $FFFF ; $a4 str$(
>018639	27 97					.word Unary_Val            & $FFFF ; $a5 val(
>01863b	eb 97					.word Unary_Len            & $FFFF ; $a6 len(
>01863d	a0 98					.word Unary_Hex            & $FFFF ; $a7 hex$(
>01863f	ad 86					.word NotImplemented       & $FFFF ; $a8 sin(
>018641	ad 86					.word NotImplemented       & $FFFF ; $a9 cos(
>018643	ad 86					.word NotImplemented       & $FFFF ; $aa tan(
>018645	ad 86					.word NotImplemented       & $FFFF ; $ab atn(
>018647	ad 86					.word NotImplemented       & $FFFF ; $ac exp(
>018649	ad 86					.word NotImplemented       & $FFFF ; $ad log(
>01864b	ad 86					.word NotImplemented       & $FFFF ; $ae sqr(
>01864d	f6 98					.word Unary_Dec            & $FFFF ; $af dec(
>01864f	97 96					.word Unary_Deek           & $FFFF ; $b0 deek(
>018651	9b 96					.word Unary_Leek           & $FFFF ; $b1 leek(
>018653	d3 96					.word Unary_Mod            & $FFFF ; $b2 mod(
>018655	33 96					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>018657	55 99					.word Unary_Chr            & $FFFF ; $b4 chr$(
>018659	c7 96					.word Unary_Pos            & $FFFF ; $b5 pos(
>01865b	96 99					.word Unary_Tab            & $FFFF ; $b6 tab(
>01865d	ad 86					.word NotImplemented       & $FFFF ; $b7 $
>01865f	ad 86					.word NotImplemented       & $FFFF ; $b8 $(
>018661	ad 86					.word NotImplemented       & $FFFF ; $b9 #
>018663	ad 86					.word NotImplemented       & $FFFF ; $ba #(
>018665	ad 86					.word NotImplemented       & $FFFF ; $bb %
>018667	ad 86					.word NotImplemented       & $FFFF ; $bc %(
>018669	ad 86					.word NotImplemented       & $FFFF ; $bd (
>01866b	ad 86					.word NotImplemented       & $FFFF ; $be )
>01866d	ad 86					.word NotImplemented       & $FFFF ; $bf ,
>01866f	e2 89					.word Command_COLON        & $FFFF ; $c0 :
>018671	ad 86					.word NotImplemented       & $FFFF ; $c1 ;
>018673	ad 86					.word NotImplemented       & $FFFF ; $c2 def
>018675	df 91					.word Command_CLR          & $FFFF ; $c3 clr
>018677	f6 91					.word Command_STOP         & $FFFF ; $c4 stop
>018679	39 8b					.word Command_DATA         & $FFFF ; $c5 data
>01867b	13 8b					.word Command_READ         & $FFFF ; $c6 read
>01867d	89 88					.word Command_DIM          & $FFFF ; $c7 dim
>01867f	ad 86					.word NotImplemented       & $FFFF ; $c8 to
>018681	ad 86					.word NotImplemented       & $FFFF ; $c9 step
>018683	25 91					.word Command_GOSUB        & $FFFF ; $ca gosub
>018685	35 91					.word Command_RETURN       & $FFFF ; $cb return
>018687	1d 91					.word Command_GOTO         & $FFFF ; $cc goto
>018689	8d 8d					.word Command_END          & $FFFF ; $cd end
>01868b	5c 8c					.word Command_INPUT        & $FFFF ; $ce input
>01868d	d7 8b					.word Command_LET          & $FFFF ; $cf let
>01868f	f4 8d					.word Command_LIST         & $FFFF ; $d0 list
>018691	c7 90					.word Command_NEW          & $FFFF ; $d1 new
>018693	e3 90					.word Command_OLD          & $FFFF ; $d2 old
>018695	3e 91					.word Command_ON           & $FFFF ; $d3 on
>018697	3c 8b					.word Command_RESTORE      & $FFFF ; $d4 restore
>018699	96 90					.word Command_POKE         & $FFFF ; $d5 poke
>01869b	e8 8f					.word Command_PRINT        & $FFFF ; $d6 print
>01869d	54 89					.word Command_RUN          & $FFFF ; $d7 run
>01869f	14 89					.word Command_WAIT         & $FFFF ; $d8 wait
>0186a1	42 8c					.word Command_SYS          & $FFFF ; $d9 sys
>0186a3	9a 90					.word Command_DOKE         & $FFFF ; $da doke
>0186a5	9e 90					.word Command_LOKE         & $FFFF ; $db loke
>0186a7	7e 90					.word Command_ASSERT       & $FFFF ; $dc assert
>0186a9	f8 8b					.word Command_GET          & $FFFF ; $dd get
>0186ab	e8 8d					.word Command_ELSE         & $FFFF ; $de else
.0186ad					NotImplemented:
.0186ad	20 86 85	jsr $018586			jsr ERR_Handler
>0186b0	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>0186b8	65 6d 65 6e 74 65 64 00
.0186c0					BinaryPrecedence:
>0186c0	01					.byte 1    ; $80 and
>0186c1	01					.byte 1    ; $81 or
>0186c2	01					.byte 1    ; $82 xor
>0186c3	01					.byte 1    ; $83 eor
>0186c4	02					.byte 2    ; $84 =
>0186c5	02					.byte 2    ; $85 <>
>0186c6	02					.byte 2    ; $86 <
>0186c7	02					.byte 2    ; $87 <=
>0186c8	02					.byte 2    ; $88 >
>0186c9	02					.byte 2    ; $89 >=
>0186ca	03					.byte 3    ; $8a +
>0186cb	03					.byte 3    ; $8b -
>0186cc	04					.byte 4    ; $8c *
>0186cd	04					.byte 4    ; $8d /
>0186ce	05					.byte 5    ; $8e ^
.0186cf					KeywordText:
>0186cf	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>0186d2	4f d2					.byte $4f,$d2                          ; $81 or
>0186d4	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>0186d7	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>0186da	bd					.byte $bd                              ; $84 =
>0186db	3c be					.byte $3c,$be                          ; $85 <>
>0186dd	bc					.byte $bc                              ; $86 <
>0186de	3c bd					.byte $3c,$bd                          ; $87 <=
>0186e0	be					.byte $be                              ; $88 >
>0186e1	3e bd					.byte $3e,$bd                          ; $89 >=
>0186e3	ab					.byte $ab                              ; $8a +
>0186e4	ad					.byte $ad                              ; $8b -
>0186e5	aa					.byte $aa                              ; $8c *
>0186e6	af					.byte $af                              ; $8d /
>0186e7	de					.byte $de                              ; $8e ^
>0186e8	49 c6					.byte $49,$c6                          ; $8f if
>0186ea	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>0186ef	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>0186f5	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>0186f8	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>0186fc	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>018701	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>018705	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>01870a	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>01870e	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>018711	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>018714	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>018718	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>01871c	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>018720	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>018725	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>018729	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>01872d	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>018733	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>01873a	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>01873f	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>018743	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>018748	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>01874c	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>018750	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>018755	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>018759	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>01875d	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>018761	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>018765	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>018769	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>01876d	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>018771	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>018775	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>01877a	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>01877f	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>018783	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>018787	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>01878c	50 4f 53 a8				.byte $50,$4f,$53,$a8                  ; $b5 pos(
>018790	54 41 42 a8				.byte $54,$41,$42,$a8                  ; $b6 tab(
>018794	a4					.byte $a4                              ; $b7 $
>018795	24 a8					.byte $24,$a8                          ; $b8 $(
>018797	a3					.byte $a3                              ; $b9 #
>018798	23 a8					.byte $23,$a8                          ; $ba #(
>01879a	a5					.byte $a5                              ; $bb %
>01879b	25 a8					.byte $25,$a8                          ; $bc %(
>01879d	a8					.byte $a8                              ; $bd (
>01879e	a9					.byte $a9                              ; $be )
>01879f	ac					.byte $ac                              ; $bf ,
>0187a0	ba					.byte $ba                              ; $c0 :
>0187a1	bb					.byte $bb                              ; $c1 ;
>0187a2	44 45 c6				.byte $44,$45,$c6                      ; $c2 def
>0187a5	43 4c d2				.byte $43,$4c,$d2                      ; $c3 clr
>0187a8	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $c4 stop
>0187ac	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c5 data
>0187b0	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c6 read
>0187b4	44 49 cd				.byte $44,$49,$cd                      ; $c7 dim
>0187b7	54 cf					.byte $54,$cf                          ; $c8 to
>0187b9	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c9 step
>0187bd	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $ca gosub
>0187c2	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $cb return
>0187c8	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $cc goto
>0187cc	45 4e c4				.byte $45,$4e,$c4                      ; $cd end
>0187cf	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $ce input
>0187d4	4c 45 d4				.byte $4c,$45,$d4                      ; $cf let
>0187d7	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $d0 list
>0187db	4e 45 d7				.byte $4e,$45,$d7                      ; $d1 new
>0187de	4f 4c c4				.byte $4f,$4c,$c4                      ; $d2 old
>0187e1	4f ce					.byte $4f,$ce                          ; $d3 on
>0187e3	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d4 restore
>0187ea	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d5 poke
>0187ee	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d6 print
>0187f3	52 55 ce				.byte $52,$55,$ce                      ; $d7 run
>0187f6	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d8 wait
>0187fa	53 59 d3				.byte $53,$59,$d3                      ; $d9 sys
>0187fd	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $da doke
>018801	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $db loke
>018805	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $dc assert
>01880b	47 45 d4				.byte $47,$45,$d4                      ; $dd get
>01880e	45 4c 53 c5				.byte $45,$4c,$53,$c5                  ; $de else
>018812	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_pos = $b5
=$b6					token_tab = $b6
=$b7					token_dollar = $b7
=$b8					token_dollarlparen = $b8
=$b9					token_hash = $b9
=$ba					token_hashlparen = $ba
=$bb					token_percent = $bb
=$bc					token_percentlparen = $bc
=$bd					token_lparen = $bd
=$be					token_rparen = $be
=$bf					token_comma = $bf
=$c0					token_colon = $c0
=$c1					token_semicolon = $c1
=$c2					token_def = $c2
=$c3					token_clr = $c3
=$c4					token_stop = $c4
=$c5					token_data = $c5
=$c6					token_read = $c6
=$c7					token_dim = $c7
=$c8					token_to = $c8
=$c9					token_step = $c9
=$ca					token_gosub = $ca
=$cb					token_return = $cb
=$cc					token_goto = $cc
=$cd					token_end = $cd
=$ce					token_input = $ce
=$cf					token_let = $cf
=$d0					token_list = $d0
=$d1					token_new = $d1
=$d2					token_old = $d2
=$d3					token_on = $d3
=$d4					token_restore = $d4
=$d5					token_poke = $d5
=$d6					token_print = $d6
=$d7					token_run = $d7
=$d8					token_wait = $d8
=$d9					token_sys = $d9
=$da					token_doke = $da
=$db					token_loke = $db
=$dc					token_assert = $dc
=$dd					token_get = $dd
=$de					token_else = $de

;******  Return to file: modules/basic/core.asm

.018813					BASIC_Start:
.018813	20 a8 81	jsr $0181a8			jsr 	IF_Reset 					; set up and clear screen.
.018816	20 00 80	jsr $018000			jsr 	IFT_ClearScreen
.018819	a9 5c		lda #$5c			lda 	#$5C 						; JMP Long opcode
.01881b	8d 10 03	sta $0310			sta 	LocalVector
.01881e	8d 0c 03	sta $030c			sta 	UserVector
.018821	a9 15		lda #$15			lda 	#USRDefault & $FF 			; reset USR vector to a default
.018823	8d 0d 03	sta $030d			sta 	UserVector+1 				; 24 / 16 bit address
.018826	a9 97		lda #$97			lda 	#(USRDefault >> 8) & $FF 	; e.g. it becomes JMP USRDefault
.018828	8d 0e 03	sta $030e			sta 	UserVector+2
.01882b	a9 01		lda #$01			lda 	#(USRDefault >> 16) & $FF
.01882d	8d 0f 03	sta $030f			sta 	UserVector+3
.018830	20 dd 99	jsr $0199dd			jsr 	UpdateProgramEnd 			; update the program end.
.018833	20 df 91	jsr $0191df			jsr 	ResetRunStatus 				; clear everything (CLR command)
.018836	c2 30		rep #$30			rep 	#$30
.018838	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.01883b	1b		tcs				tcs
.01883c	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.01883f	e2 30		sep #$30			sep 	#$30
.018841	4c 54 89	jmp $018954			jmp 	COMMAND_Run
.018844	20 c7 90	jsr $0190c7			jsr 	Command_NEW 				; new command, will not return.
.018847					WarmStart:
.018847	a2 7f		ldx #$7f			ldx 	#ReadyMsg & $FF 			; Print READY.
.018849	a0 88		ldy #$88			ldy 	#(ReadyMsg >> 8) & $FF
.01884b	20 bc 85	jsr $0185bc			jsr 	PrintROMMessage
.01884e					ErrorStart:
.01884e	c2 30		rep #$30			rep 	#$30
.018850	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.018853	1b		tcs				tcs
.018854	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.018857	e2 30		sep #$30			sep 	#$30
.018859	20 f7 80	jsr $0180f7			jsr 	IFT_ReadLine 				; read line in.
.01885c	a9 66		lda #$66			lda 	#IFT_LineBuffer & $FF 		; tokenise it.
.01885e	a2 05		ldx #$05			ldx 	#IFT_LineBuffer >> 8
.018860	20 74 9b	jsr $019b74			jsr 	TokeniseString
.018863	ad 03 04	lda $0403			lda 	TokeniseBuffer+3 			; what is first.
.018866	29 c0		and #$c0			and 	#$C0 						; is it a number 4000-7FFF
.018868	c9 40		cmp #$40			cmp 	#$40
.01886a	f0 1b		beq $018887			beq 	EditLine 					; if true, go to edit line.
.01886c	a9 00		lda #$00			lda 	#(TokeniseBuffer) & $FF
.01886e	85 18		sta $18				sta 	zCodePtr+0
.018870	a9 04		lda #$04			lda 	#(TokeniseBuffer) >> 8
.018872	85 19		sta $19				sta 	zCodePtr+1
.018874	a9 00		lda #$00			lda 	#0
.018876	85 1a		sta $1a				sta 	zCodePtr+2
.018878	85 1b		sta $1b				sta 	zCodePtr+3
.01887a	a0 03		ldy #$03			ldy 	#3
.01887c	4c 88 89	jmp $018988			jmp 	RUN_NextCommand
.01887f					ReadyMsg:
>01887f	52 65 61 64 79 2e 0d 00				.text 	"Ready.",13,0
.018887					EditLine:
.018887	80 fe		bra $018887			bra 	EditLine

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/dim.asm

.018889					Command_DIM:
.018889	98		tya				tya
.01888a	48		pha				pha 								; push on stack.
.01888b	20 69 9d	jsr $019d69			jsr 	VariableExtract 			; get the identifier
.01888e	ad 95 03	lda $0395			lda 	Var_Type 					; check it is an array
.018891	29 01		and #$01			and 	#1
.018893	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.018895	d0 6f		bne $018906			bne 	_CDIError
.018897	a9 00		lda #$00			lda 	#0 							; reset the DIM index. The dimensions are
.018899	8d b9 03	sta $03b9			sta 	UsrArrayIdx 				; built up here and copied in case we autodim
.01889c					_CDIGetDimension:
.01889c	ad b9 03	lda $03b9			lda 	UsrArrayIdx 				; done too many ?
.01889f	c9 06		cmp #$06			cmp 	#ArrayMaxDim*2
.0188a1	f0 63		beq $018906			beq 	_CDIError
.0188a3	20 e3 93	jsr $0193e3			jsr 	EvaluateInteger 			; evaluate an index size
.0188a6	a5 81		lda $81				lda 	XS_Mantissa+1 				; check in range 0-7FFF
.0188a8	29 80		and #$80			and 	#$80
.0188aa	05 82		ora $82				ora 	XS_Mantissa+2
.0188ac	05 83		ora $83				ora 	XS_Mantissa+3
.0188ae	d0 56		bne $018906			bne 	_CDIError
.0188b0	ae b9 03	ldx $03b9			ldx 	UsrArrayIdx 				; copy into the array table.
.0188b3	18		clc				clc 								; add 1 - max index => size.
.0188b4	a5 80		lda $80				lda 	XS_Mantissa+0
.0188b6	69 01		adc #$01			adc 	#1
.0188b8	9d b1 03	sta $03b1,x			sta 	UsrArrayDef+0,x
.0188bb	a5 81		lda $81				lda 	XS_Mantissa+1
.0188bd	69 00		adc #$00			adc 	#0
.0188bf	9d b2 03	sta $03b2,x			sta 	UsrArrayDef+1,x
.0188c2	30 42		bmi $018906			bmi 	_CDIError 					; could be dim a(32767)
.0188c4	e8		inx				inx 								; bump index.
.0188c5	e8		inx				inx
.0188c6	8e b9 03	stx $03b9			stx 	UsrArrayIdx
.0188c9	b7 18		lda [$18],y			lda 	[zCodePtr],y
.0188cb	c8		iny				iny
.0188cc	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another dimension
.0188ce	f0 cc		beq $01889c			beq 	_CDIGetDimension
.0188d0	88		dey				dey
.0188d1	20 39 9a	jsr $019a39			jsr 	CheckNextRParen 			; closing ) present ?
.0188d4	ae b9 03	ldx $03b9			ldx 	UsrArrayIdx 				; copy USR array to default
.0188d7	a9 ff		lda #$ff			lda 	#$FF 						; put end marker in ArrayDef
.0188d9	9d aa 03	sta $03aa,x			sta 	ArrayDef+1,x
.0188dc					_CDICopy:
.0188dc	bd b1 03	lda $03b1,x			lda 	UsrArrayDef,x
.0188df	9d a9 03	sta $03a9,x			sta 	ArrayDef,x
.0188e2	ca		dex				dex
.0188e3	10 f7		bpl $0188dc			bpl 	_CDICopy
.0188e5	68		pla				pla									; position of array identifier
.0188e6	85 10		sta $10				sta 	zTemp1
.0188e8	98		tya				tya
.0188e9	48		pha				pha
.0188ea	a5 10		lda $10				lda 	zTemp1 						; point to identifier
.0188ec	a8		tay				tay
.0188ed	20 69 9d	jsr $019d69			jsr 	VariableExtract 			; get the identifier
.0188f0	20 02 a0	jsr $01a002			jsr 	VariableLocate 				; check if it exists already.
.0188f3	b0 11		bcs $018906			bcs 	_CDIError
.0188f5	20 f5 9d	jsr $019df5			jsr 	VariableCreate 				; create it using the current ArrayDef
.0188f8	68		pla				pla 								; restore code position
.0188f9	a8		tay				tay
.0188fa	b7 18		lda [$18],y			lda 	[zCodePtr],y
.0188fc	c8		iny				iny
.0188fd	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another DIM
.0188ff	f0 88		beq $018889			beq 	Command_DIM
.018901	88		dey				dey
.018902	20 04 9f	jsr $019f04			jsr 	ArrayResetDefault 			; subsequent automatic DIMs will be (10)
.018905	60		rts				rts
.018906					_CDIError:
.018906	20 86 85	jsr $018586			jsr ERR_Handler
>018909	42 61 64 20 44 49 4d 00			.text "Bad DIM",0
.018911					_CDISyntax:
.018911	4c 57 85	jmp $018557			jmp 	SyntaxError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/wait.asm

.018914					Command_WAIT:
.018914	20 e3 93	jsr $0193e3			jsr		EvaluateInteger 			; get address to monitor
.018917	a2 06		ldx #$06			ldx 	#XS_Size 					; get and mask
.018919	20 41 9a	jsr $019a41			jsr 	CheckNextComma
.01891c	20 e5 93	jsr $0193e5			jsr 	EvaluateIntegerX
.01891f	a9 00		lda #$00			lda 	#0							; set default xor value.
.018921	85 8c		sta $8c				sta 	XS_Mantissa+XS_Size*2
.018923	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018925	c9 bf		cmp #$bf			cmp 	#token_Comma 				; no use the default
.018927	d0 06		bne $01892f			bne 	_CWAXorDefault
.018929	c8		iny				iny
.01892a	a2 0c		ldx #$0c			ldx 	#XS_Size*2					; and get the xor value
.01892c	20 e5 93	jsr $0193e5			jsr 	EvaluateIntegerX
.01892f					_CWAXorDefault:
.01892f	a5 80		lda $80				lda 	XS_Mantissa 				; copy 24 bits of mantissa to ZLTemp1
.018931	85 1c		sta $1c				sta 	zLTemp1
.018933	a5 81		lda $81				lda 	XS_Mantissa+1
.018935	85 1d		sta $1d				sta 	zLTemp1+1
.018937	a5 82		lda $82				lda 	XS_Mantissa+2
.018939	85 1e		sta $1e				sta 	zLTemp1+2
.01893b					_CWAWaitLoop:
.01893b	20 4d 85	jsr $01854d			jsr 	VIOCheckBreak 				; exit on break.
.01893e	c9 00		cmp #$00			cmp 	#0
.018940	d0 11		bne $018953			bne 	_CWAWaitExit
.018942	a9 01		lda #$01			lda 	#1							; read 1 byte to mantissa/0
.018944	a2 00		ldx #$00			ldx 	#0
.018946	5a		phy				phy 								; this is the same routine as PEEK.
.018947	20 bb 99	jsr $0199bb			jsr 	MemRead
.01894a	7a		ply				ply
.01894b	a5 80		lda $80				lda 	XS_Mantissa+0 				; get byte
.01894d	25 86		and $86				and 	XS_Mantissa+XS_Size 		; and it
.01894f	45 8c		eor $8c				eor 	XS_Mantissa+XS_Size*2		; eor it.
.018951	f0 e8		beq $01893b			beq 	_CWAWaitLoop 				; and loop if zero.
.018953					_CWAWaitExit:
.018953	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/run.asm

.018954					Command_RUN:
.018954	20 df 91	jsr $0191df			jsr 	ResetRunStatus 				; clear, reset stacks etc.
.018957	a9 00		lda #$00			lda 	#(BasicProgram) & $FF
.018959	85 18		sta $18				sta 	zCodePtr+0
.01895b	a9 10		lda #$10			lda 	#(BasicProgram) >> 8
.01895d	85 19		sta $19				sta 	zCodePtr+1
.01895f	a9 00		lda #$00			lda 	#0
.018961	85 1a		sta $1a				sta 	zCodePtr+2
.018963	85 1b		sta $1b				sta 	zCodePtr+3
.018965	a0 03		ldy #$03			ldy 	#3
.018967					RUN_NewLine:
.018967	a0 00		ldy #$00			ldy 	#0
.018969	b7 18		lda [$18],y			lda 	[zCodePtr],y
.01896b	c8		iny				iny
.01896c	c8		iny				iny
.01896d	c8		iny				iny
.01896e	c9 00		cmp #$00			cmp 	#0 							; if the offset is zero then END.
.018970	d0 16		bne $018988			bne 	RUN_NextCommand
.018972	4c 8d 8d	jmp $018d8d			jmp 	Command_END 				; go do the command code.
.018975					RUN_Skip:
.018975	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read element
.018977	c8		iny				iny 								; skip
.018978	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.01897a	90 0c		bcc $018988			bcc 	_SEDone 					; so just skip over it.
.01897c	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.01897e	90 07		bcc $018987			bcc 	_SEDouble
.018980	98		tya				tya 								; this is Y + 1
.018981	18		clc				clc
.018982	77 18		adc [$18],y			adc 	[zCodePtr],y 				; add total length of element
.018984	a8		tay				tay 								; back in Y.
.018985	88		dey				dey 								; fix up, one for the +1, one for the iny
.018986	88		dey				dey
.018987					_SEDouble:
.018987	c8		iny				iny
.018988					_SEDone:
.018988					RUN_NextCommand:
.018988	ad a8 03	lda $03a8			lda 	BreakCount 					; break counter
.01898b	69 10		adc #$10			adc 	#16 						; one time in 16
.01898d	8d a8 03	sta $03a8			sta 	BreakCount
.018990	90 0a		bcc $01899c			bcc 	RUN_NoCheckBreak
.018992	20 4d 85	jsr $01854d			jsr 	VIOCheckBreak 				; check for break
.018995	c9 00		cmp #$00			cmp 	#0
.018997	f0 03		beq $01899c			beq 	RUN_NoCheckBreak
.018999	4c f6 91	jmp $0191f6			jmp 	Command_STOP 				; stop on BREAK.
.01899c					RUN_NoCheckBreak:
.01899c	a9 00		lda #$00			lda 	#0 							; this resets temporary string allocation.
.01899e	85 23		sta $23				sta 	zTempStr+1 					; (initialised when first called)
.0189a0	b7 18		lda [$18],y			lda 	[zCodePtr],y
.0189a2	c9 c0		cmp #$c0			cmp 	#token_Colon 				; skip over colons
.0189a4	f0 cf		beq $018975			beq 	RUN_Skip
.0189a6	c9 00		cmp #$00			cmp 	#0 							; if non-zero execute whatever
.0189a8	d0 0f		bne $0189b9			bne 	RUN_Execute
.0189aa					RUN_NextLine:
.0189aa	a0 00		ldy #$00			ldy 	#0 							; point to offset
.0189ac	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read it
.0189ae	18		clc				clc
.0189af	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.0189b1	85 18		sta $18				sta 	zCodePtr
.0189b3	90 02		bcc $0189b7			bcc 	_SNLNoCarry
.0189b5	e6 19		inc $19				inc 	zCodePtr+1
.0189b7					_SNLNoCarry:
.0189b7	80 ae		bra $018967			bra 	RUN_NewLine 				; go do the new line code
.0189b9					RUN_Execute:
.0189b9	c9 f8		cmp #$f8			cmp 	#$F8 						; handle shifts, REM etc.
.0189bb	b0 1e		bcs $0189db			bcs 	RUN_Extension
.0189bd	c8		iny				iny
.0189be	0a		asl a				asl 	a 							; double the character read.
.0189bf	90 14		bcc $0189d5			bcc 	RUN_Default 				; if carry clear was $00-$7F, so try LET.
.0189c1	aa		tax				tax 								; ready to look up.
.0189c2	bf ef 85 01	lda $0185ef,x			lda 	VectorTable,x 				; copy address into LocalVector
.0189c6	8d 11 03	sta $0311			sta 	LocalVector+1
.0189c9	bf f0 85 01	lda $0185f0,x			lda 	VectorTable+1,x
.0189cd	8d 12 03	sta $0312			sta 	LocalVector+2
.0189d0	20 30 93	jsr $019330			jsr 	EVCallLocalVector 			; execute the appropriate code.
.0189d3	80 b3		bra $018988			bra 	RUN_NextCommand 			; do the next command.
.0189d5					RUN_Default:
.0189d5	88		dey				dey
.0189d6	20 d7 8b	jsr $018bd7			jsr 	Command_LET 				; and try LET.
.0189d9	80 ad		bra $018988			bra 	RUN_NextCommand
.0189db					RUN_Extension:
.0189db	c9 ff		cmp #$ff			cmp 	#$FF 						; if $FF (REM)
.0189dd	f0 96		beq $018975			beq 	RUN_Skip 					; skip over it.
.0189df	4c 57 85	jmp $018557			jmp 	SyntaxError
.0189e2					Command_COLON:
.0189e2	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/for.asm

.0189e3					Command_FOR:
.0189e3	20 d7 8b	jsr $018bd7			jsr 	Command_LET 				; do the A = 99 bit
.0189e6	a5 26		lda $26				lda 	zVarType 					; obviously has to be integer/real.
.0189e8	c9 b7		cmp #$b7			cmp 	#token_Dollar
.0189ea	f0 71		beq $018a5d			beq 	_CFOError
.0189ec	48		pha				pha 								; save the variable type.
.0189ed	5a		phy				phy 								; save type/variable address.
.0189ee	a0 01		ldy #$01			ldy 	#1							; type at + 1
.0189f0	91 28		sta ($28),y			sta 	(zBasicSP),y
.0189f2	c8		iny				iny
.0189f3	a5 24		lda $24				lda 	zVarDataPtr 				; data low at +2
.0189f5	91 28		sta ($28),y			sta 	(zBasicSP),y
.0189f7	c8		iny				iny
.0189f8	a5 25		lda $25				lda 	zVarDataPtr+1 				; data high at +3
.0189fa	91 28		sta ($28),y			sta 	(zBasicSP),y
.0189fc	7a		ply				ply
.0189fd	a9 53		lda #$53			lda 	#(SMark_For << 4) + 3
.0189ff	20 bf 84	jsr $0184bf			jsr 	StackPushFrame 				; push on the stack with FOR marker.
.018a02	a9 c8		lda #$c8			lda 	#token_TO
.018a04	20 22 9a	jsr $019a22			jsr 	CheckNextToken
.018a07	a2 00		ldx #$00			ldx 	#0 							; put in Mantissa, bottom
.018a09	20 4d 92	jsr $01924d			jsr 	EvaluateExpression
.018a0c	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018a0e	a2 06		ldx #$06			ldx 	#XS_Size 					; X to second level
.018a10	c9 c9		cmp #$c9			cmp 	#token_STEP
.018a12	d0 06		bne $018a1a			bne 	_CFOStep1
.018a14	c8		iny				iny
.018a15	20 4f 92	jsr $01924f			jsr 	EvaluateExpressionX 		; get STEP value.
.018a18	80 0e		bra $018a28			bra 	_CFOHaveStep
.018a1a					_CFOStep1:
.018a1a	a9 00		lda #$00			lda 	#0							; set step to integer 1.
.018a1c	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018a1e	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.018a20	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018a22	a9 01		lda #$01			lda 	#1
.018a24	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018a26	95 85		sta $85,x			sta 	XS_Type,x
.018a28					_CFOHaveStep:
.018a28	68		pla				pla 								; restore variable type
.018a29	a2 00		ldx #$00			ldx 	#0
.018a2b	c9 bb		cmp #$bb			cmp 	#token_Percent 				; do conversion to type
.018a2d	f0 0a		beq $018a39			beq 	_CFOInteger
.018a2f	20 0f a6	jsr $01a60f			jsr 	FPUToFloat
.018a32	a2 06		ldx #$06			ldx 	#6
.018a34	20 0f a6	jsr $01a60f			jsr 	FPUToFloat
.018a37	80 08		bra $018a41			bra 	_CFOEndConv
.018a39					_CFOInteger:
.018a39	20 5b a6	jsr $01a65b			jsr 	FPUToInteger
.018a3c	a2 06		ldx #$06			ldx 	#6
.018a3e	20 5b a6	jsr $01a65b			jsr 	FPUToInteger
.018a41					_CFOEndConv:
.018a41	20 06 85	jsr $018506			jsr 	StackSavePosition 			; save the loop position at 1-5
.018a44	a9 55		lda #$55			lda 	#(SMark_For << 4)+SourcePosSize
.018a46	20 bf 84	jsr $0184bf			jsr 	StackPushFrame 				; push the loop address frame.
.018a49	5a		phy				phy
.018a4a	a0 00		ldy #$00			ldy 	#0
.018a4c					_CFOCopy:
.018a4c	b9 80 00	lda $0080,y			lda 	XS_Mantissa+0,y
.018a4f	c8		iny				iny
.018a50	91 28		sta ($28),y			sta 	(zBasicSP),y
.018a52	c0 0c		cpy #$0c			cpy 	#XS_Size*2
.018a54	d0 f6		bne $018a4c			bne 	_CFOCopy
.018a56	7a		ply				ply
.018a57	a9 5c		lda #$5c			lda 	#(SMark_For << 4)+(XS_Size*2)
.018a59	20 bf 84	jsr $0184bf			jsr 	StackPushFrame
.018a5c	60		rts				rts
.018a5d					_CFOError:
.018a5d	4c 67 85	jmp $018567			jmp 	TypeError 					; wrong type.
.018a60					Command_NEXT:
.018a60	a9 00		lda #$00			lda 	#0 							; set variable data pointer+1 to zero
.018a62	85 25		sta $25				sta 	zVarDataPtr+1 				; this means we don't check
.018a64	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018a66	c9 00		cmp #$00			cmp 	#0 							; EOL
.018a68	f0 07		beq $018a71			beq 	_CNextNoVariable
.018a6a	c9 40		cmp #$40			cmp 	#$40
.018a6c	b0 03		bcs $018a71			bcs 	_CNextNoVariable
.018a6e	20 fe 9c	jsr $019cfe			jsr 	VariableFind
.018a71					_CNextNoVariable:
.018a71	a5 28		lda $28				lda 	zBasicSP 					; save on stack
.018a73	48		pha				pha
.018a74	a5 29		lda $29				lda 	zBasicSP+1
.018a76	48		pha				pha
.018a77	a9 50		lda #$50			lda 	#(SMark_For << 4) 			; pop loop address frame
.018a79	20 d6 84	jsr $0184d6			jsr 	StackPopFrame
.018a7c	a9 50		lda #$50			lda 	#(SMark_For << 4) 			; pop STEP/TARGET frame.
.018a7e	20 d6 84	jsr $0184d6			jsr 	StackPopFrame
.018a81	a9 50		lda #$50			lda 	#(Smark_For << 4) 			; pop variable address frame.
.018a83	20 d6 84	jsr $0184d6			jsr 	StackPopFrame
.018a86	a5 25		lda $25				lda 	zVarDataPtr+1 				; if zero, then no variable provided
.018a88	f0 11		beq $018a9b			beq 	_CNextGetTarget 			; e.g. just NEXT not NEXT x
.018a8a	5a		phy				phy 								; check addresses match.
.018a8b	a0 02		ldy #$02			ldy 	#2
.018a8d	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018a8f	c5 24		cmp $24				cmp 	zVarDataPtr
.018a91	d0 69		bne $018afc			bne 	_CNextWrong
.018a93	c8		iny				iny
.018a94	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018a96	c5 25		cmp $25				cmp 	zVarDataPtr+1
.018a98	d0 62		bne $018afc			bne 	_CNextWrong
.018a9a	7a		ply				ply
.018a9b					_CNextGetTarget:
.018a9b	5a		phy				phy
.018a9c	a0 01		ldy #$01			ldy 	#1 							; restore variable type and data.
.018a9e	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018aa0	85 26		sta $26				sta 	zVarType
.018aa2	c8		iny				iny
.018aa3	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018aa5	85 24		sta $24				sta 	zVarDataPtr
.018aa7	c8		iny				iny
.018aa8	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018aaa	85 25		sta $25				sta 	zVarDataPtr+1
.018aac	a2 0c		ldx #$0c			ldx 	#12
.018aae	20 46 a0	jsr $01a046			jsr 	VariableGet 				; get that variable value into expr[2]
.018ab1	a2 00		ldx #$00			ldx 	#0 							; copy stacked Target/Step into expr[0] and [1]
.018ab3	a0 0b		ldy #$0b			ldy 	#11
.018ab5					_CNXCopy:
.018ab5	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018ab7	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018ab9	e8		inx				inx
.018aba	c8		iny				iny
.018abb	e0 0c		cpx #$0c			cpx 	#XS_Size*2
.018abd	d0 f6		bne $018ab5			bne 	_CNXCopy
.018abf	7a		ply				ply
.018ac0	a2 06		ldx #$06			ldx 	#6 							; point at expr[1] s
.018ac2	20 57 96	jsr $019657			jsr 	GetSignCurrent
.018ac5	8d a7 03	sta $03a7			sta 	SignNext 					; save in temporary.
.018ac8	a2 06		ldx #$06			ldx 	#6 							; add them, however
.018aca	20 36 95	jsr $019536			jsr 	BinaryOp_Add
.018acd	20 97 a0	jsr $01a097			jsr 	VariableSet					; and write variable back.
.018ad0	a2 00		ldx #$00			ldx 	#0
.018ad2	20 ba 94	jsr $0194ba			jsr 	CompareValues
.018ad5	09 00		ora #$00			ora 	#0
.018ad7	f0 05		beq $018ade			beq 	_CNXAgain 					; if true, then do it again.
.018ad9	cd a7 03	cmp $03a7			cmp 	SignNext 					; if sign different, then loop has finished.
.018adc	d0 0f		bne $018aed			bne 	_CNXLoopDone
.018ade					_CNXAgain:
.018ade	a9 53		lda #$53			lda 	#(SMark_For << 4) + 3		; re-stack variable address
.018ae0	20 bf 84	jsr $0184bf			jsr 	StackPushFrame
.018ae3	20 23 85	jsr $018523			jsr 	StackRestorePosition 		; get restore position back, e.g. loop round.
.018ae6	68		pla				pla
.018ae7	85 29		sta $29				sta 	zBasicSP+1
.018ae9	68		pla				pla
.018aea	85 28		sta $28				sta 	zBasicSP
.018aec					_CNXExit:
.018aec	60		rts				rts
.018aed					_CNXLoopDone:
.018aed	68		pla				pla 								; throw away saved to Basic Stack Pointer
.018aee	68		pla				pla
.018aef	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018af1	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma ?
.018af3	d0 f7		bne $018aec			bne 	_CNXExit
.018af5	c8		iny				iny
.018af6	20 fe 9c	jsr $019cfe			jsr 	VariableFind 				; identify the variable
.018af9	4c 71 8a	jmp $018a71			jmp 	_CNextNoVariable 			; go back with variable pre-found
.018afc					_CNextWrong:
.018afc	20 86 85	jsr $018586			jsr ERR_Handler
>018aff	57 72 6f 6e 67 20 4e 65			.text "Wrong Next Variable",0
>018b07	78 74 20 56 61 72 69 61 62 6c 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/read.asm

.018b13					Command_READ:
.018b13	20 fe 9c	jsr $019cfe			jsr 	VariableFind 				; get variable/value into zVarDataPtr,zVarType
.018b16	a5 24		lda $24				lda 	zVarDataPtr 				; save variable info on stack
.018b18	48		pha				pha
.018b19	a5 25		lda $25				lda 	zVarDataPtr+1
.018b1b	48		pha				pha
.018b1c	a5 26		lda $26				lda 	zVarType
.018b1e	48		pha				pha
.018b1f	20 65 8b	jsr $018b65			jsr 	READGetDataItem 			; get the next data item
.018b22	68		pla				pla 								; restore target variable information.
.018b23	85 26		sta $26				sta 	zVarType
.018b25	68		pla				pla
.018b26	85 25		sta $25				sta 	zVarDataPtr+1
.018b28	68		pla				pla
.018b29	85 24		sta $24				sta 	zVarDataPtr
.018b2b	a2 00		ldx #$00			ldx 	#0
.018b2d	20 97 a0	jsr $01a097			jsr 	VariableSet 				; set the value out.
.018b30	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018b32	c8		iny				iny
.018b33	c9 bf		cmp #$bf			cmp 	#token_Comma
.018b35	f0 dc		beq $018b13			beq 	Command_READ 				; found, do another READ
.018b37	88		dey				dey
.018b38	60		rts				rts
.018b39					Command_DATA:
.018b39	4c 8d 84	jmp $01848d			jmp 	SkipEndOfCommand
.018b3c					Command_RESTORE:
.018b3c	48		pha				pha
.018b3d	a9 00		lda #$00			lda 	#0 							; this being zero means 'initialise next read'
.018b3f	8d bd 03	sta $03bd			sta 	DataLPtr+0
.018b42	8d be 03	sta $03be			sta 	DataLPtr+1
.018b45	68		pla				pla
.018b46	60		rts				rts
.018b47					READSwapPointers:
.018b47	98		tya				tya
.018b48	48		pha				pha 								; save it
.018b49	ad c1 03	lda $03c1			lda 	DataIndex 					; get data offset, and copy to offset
.018b4c	a8		tay				tay
.018b4d	68		pla				pla 								; get code offset and save in DataIndex
.018b4e	8d c1 03	sta $03c1			sta 	DataIndex
.018b51	da		phx				phx
.018b52	a2 03		ldx #$03			ldx 	#3 							; swap the Data Pointers (4 bytes) round.
.018b54					_RSWLoop:
.018b54	bd bd 03	lda $03bd,x			lda 	DataLPtr+0,x
.018b57	48		pha				pha
.018b58	b5 18		lda $18,x			lda 	zCodePtr+0,x
.018b5a	9d bd 03	sta $03bd,x			sta 	DataLPtr+0,x
.018b5d	68		pla				pla
.018b5e	95 18		sta $18,x			sta 	zCodePtr+0,x
.018b60	ca		dex				dex
.018b61	10 f1		bpl $018b54			bpl 	_RSWLoop
.018b63	fa		plx				plx
.018b64	60		rts				rts
.018b65					READGetDataItem:
.018b65	20 47 8b	jsr $018b47			jsr 	ReadSwapPointers 			; swap code and data pointer.
.018b68	a5 18		lda $18				lda		zCodePtr+0 					; initialise ?
.018b6a	05 19		ora $19				ora 	zCodePtr+1
.018b6c	d0 12		bne $018b80			bne 	_RGDIIsInitialised
.018b6e	a9 00		lda #$00			lda 	#(BasicProgram) & $FF
.018b70	85 18		sta $18				sta 	zCodePtr+0
.018b72	a9 10		lda #$10			lda 	#(BasicProgram) >> 8
.018b74	85 19		sta $19				sta 	zCodePtr+1
.018b76	a9 00		lda #$00			lda 	#0
.018b78	85 1a		sta $1a				sta 	zCodePtr+2
.018b7a	85 1b		sta $1b				sta 	zCodePtr+3
.018b7c	a0 03		ldy #$03			ldy 	#3
.018b7e	80 06		bra $018b86			bra 	_RGDIFindData 				; locate next data from start and read that.
.018b80					_RGDIIsInitialised:
.018b80	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018b82	c9 bf		cmp #$bf			cmp 	#token_Comma
.018b84	f0 49		beq $018bcf			beq 	_RGDISkipEvaluateExit
.018b86					_RGDIFindData:
.018b86	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018b88	c9 00		cmp #$00			cmp 	#0 							; end of line
.018b8a	f0 19		beq $018ba5			beq 	_RGDIFindNextLine
.018b8c	c9 c5		cmp #$c5			cmp 	#token_DATA 				; found data token
.018b8e	f0 3f		beq $018bcf			beq 	_RGDISkipEvaluateExit 		; then skip it and evaluate
.018b90	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read element
.018b92	c8		iny				iny 								; skip
.018b93	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018b95	90 0c		bcc $018ba3			bcc 	_SEDone 					; so just skip over it.
.018b97	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018b99	90 07		bcc $018ba2			bcc 	_SEDouble
.018b9b	98		tya				tya 								; this is Y + 1
.018b9c	18		clc				clc
.018b9d	77 18		adc [$18],y			adc 	[zCodePtr],y 				; add total length of element
.018b9f	a8		tay				tay 								; back in Y.
.018ba0	88		dey				dey 								; fix up, one for the +1, one for the iny
.018ba1	88		dey				dey
.018ba2					_SEDouble:
.018ba2	c8		iny				iny
.018ba3					_SEDone:
.018ba3	80 e1		bra $018b86			bra 	_RGDIFindData
.018ba5					_RGDIFindNextLine:
.018ba5	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018ba7	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read it
.018ba9	18		clc				clc
.018baa	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.018bac	85 18		sta $18				sta 	zCodePtr
.018bae	90 02		bcc $018bb2			bcc 	_SNLNoCarry
.018bb0	e6 19		inc $19				inc 	zCodePtr+1
.018bb2					_SNLNoCarry:
.018bb2	a0 00		ldy #$00			ldy 	#0
.018bb4	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018bb6	48		pha				pha
.018bb7	c8		iny				iny
.018bb8	c8		iny				iny
.018bb9	c8		iny				iny
.018bba	68		pla				pla
.018bbb	d0 c9		bne $018b86			bne 	_RGDIFindData 				; back to scanning.
.018bbd	20 47 8b	jsr $018b47			jsr 	ReadSwapPointers 			; so we get error in line number of READ
.018bc0	20 86 85	jsr $018586			jsr ERR_Handler
>018bc3	4f 75 74 20 6f 66 20 44			.text "Out of Data",0
>018bcb	61 74 61 00
.018bcf					_RGDISkipEvaluateExit:
.018bcf	c8		iny				iny
.018bd0	20 4d 92	jsr $01924d			jsr 	EvaluateExpression 			; evaluate the expression
.018bd3	20 47 8b	jsr $018b47			jsr 	ReadSwapPointers 			; swap the pointers around.
.018bd6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/let.asm

.018bd7					Command_LET:
.018bd7	20 fe 9c	jsr $019cfe			jsr 	VariableFind 				; get reference to one variable.
.018bda	a9 84		lda #$84			lda 	#token_Equal  				; get equals
.018bdc	20 22 9a	jsr $019a22			jsr 	CheckNextToken
.018bdf	a5 24		lda $24				lda 	zVarDataPtr 				; save variable info on stack
.018be1	48		pha				pha
.018be2	a5 25		lda $25				lda 	zVarDataPtr+1
.018be4	48		pha				pha
.018be5	a5 26		lda $26				lda 	zVarType
.018be7	48		pha				pha
.018be8	20 4d 92	jsr $01924d			jsr 	EvaluateExpression 			; evaluate the RHS, set X to zero.
.018beb	68		pla				pla 								; restore target variable information.
.018bec	85 26		sta $26				sta 	zVarType
.018bee	68		pla				pla
.018bef	85 25		sta $25				sta 	zVarDataPtr+1
.018bf1	68		pla				pla
.018bf2	85 24		sta $24				sta 	zVarDataPtr
.018bf4	20 97 a0	jsr $01a097			jsr 	VariableSet 				; set the value out.
.018bf7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/get.asm

.018bf8					Command_GET:
.018bf8					_CGLoop:
.018bf8	20 fe 9c	jsr $019cfe			jsr 	VariableFind 				; get a variable.
.018bfb	20 42 85	jsr $018542			jsr 	VIOCharGet 					; get character
.018bfe	b0 02		bcs $018c02			bcs 	_CGNoKey
.018c00	a9 00		lda #$00			lda 	#0 							; if no character return zero
.018c02					_CGNoKey:
.018c02	48		pha				pha
.018c03	a5 26		lda $26				lda 	zVarType 					; look at the data type.
.018c05	c9 b7		cmp #$b7			cmp 	#token_Dollar
.018c07	f0 1e		beq $018c27			beq 	_CGString
.018c09	68		pla				pla 								; put character in slot.
.018c0a	85 80		sta $80				sta 	XS_Mantissa
.018c0c	a9 00		lda #$00			lda 	#0
.018c0e	85 81		sta $81				sta 	XS_Mantissa+1
.018c10	85 82		sta $82				sta 	XS_Mantissa+2
.018c12	85 83		sta $83				sta 	XS_Mantissa+3
.018c14	a9 01		lda #$01			lda 	#1 							; type integer
.018c16	85 85		sta $85				sta 	XS_Type
.018c18					_CGWriteSetNext:
.018c18	a2 00		ldx #$00			ldx 	#0 							; write number/WriteTempString out
.018c1a	20 97 a0	jsr $01a097			jsr 	VariableSet
.018c1d	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018c1f	c9 bf		cmp #$bf			cmp 	#token_Comma 				; if not comma exit
.018c21	d0 03		bne $018c26			bne 	_CGExit
.018c23	c8		iny				iny
.018c24	80 d2		bra $018bf8			bra 	_CGLoop 					; and get another.
.018c26					_CGExit:
.018c26	60		rts				rts
.018c27					_CGString:
.018c27	a9 02		lda #$02			lda 	#2 							; allocate temp string, space for 2.
.018c29	20 86 9a	jsr $019a86			jsr 	AllocateTempString 			; initially empty.
.018c2c	a5 22		lda $22				lda 	zTempStr 					; set up to be returned.
.018c2e	85 80		sta $80				sta 	XS_Mantissa
.018c30	a5 23		lda $23				lda 	zTempStr+1
.018c32	85 81		sta $81				sta 	XS_Mantissa+1
.018c34	a9 02		lda #$02			lda 	#2
.018c36	85 85		sta $85				sta 	XS_Type
.018c38	68		pla				pla 								; get A
.018c39	c9 00		cmp #$00			cmp 	#0
.018c3b	f0 db		beq $018c18			beq 	_CGWriteSetNext
.018c3d	20 b1 9a	jsr $019ab1			jsr 	WriteTempString 			; write it into string
.018c40	80 d6		bra $018c18			bra 	_CGWriteSetNext

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/sys.asm

.018c42					Command_SYS:
.018c42	20 e3 93	jsr $0193e3			jsr 	EvaluateInteger 			; address to call.
.018c45	a5 80		lda $80				lda 	XS_Mantissa+0				; copy to localvector
.018c47	8d 10 03	sta $0310			sta 	LocalVector+0 				; only three, can only do 24 bit calls
.018c4a	a5 81		lda $81				lda 	XS_Mantissa+1 				; and that only on 65816
.018c4c	8d 11 03	sta $0311			sta 	LocalVector+1
.018c4f	a5 82		lda $82				lda 	XS_Mantissa+2
.018c51	8d 12 03	sta $0312			sta 	LocalVector+2
.018c54	22 59 8c 01	jsl $018c59			jsl 	_CSYLocalCall 				; jump depending on 24/16 bit code address
.018c58	60		rts				rts
.018c59					_CSYLocalCall:
.018c59	dc 10 03	jmp [$0310]			jmp 	[LocalVector]		 		; address

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/input.asm

.018c5c					Command_INPUT:
.018c5c	a9 00		lda #$00		lda 	#0 								; clear number of characters required.
.018c5e	8d c2 03	sta $03c2		sta 	InputAvailable 					; save character count
.018c61	8d c3 03	sta $03c3		sta 	InputRetry
.018c64					_CILoop:
.018c64	a9 00		lda #$00		lda 	#0 								; this resets temporary string allocation.
.018c66	85 23		sta $23			sta 	zTempStr+1 						; (could get lots of long strings)
.018c68	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018c6a	c9 fe		cmp #$fe		cmp 	#$FE 							; is it a prompt string
.018c6c	d0 15		bne $018c83		bne 	_CINoPrompt
.018c6e	c8		iny				iny
.018c6f	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018c71	aa		tax			tax 									; into X
.018c72	c8		iny				iny
.018c73	ca		dex			dex 									; deduct marker/prompt length
.018c74	ca		dex			dex
.018c75	f0 ed		beq $018c64		beq 	_CILoop 						; nothing.
.018c77					_CIShowPrompt:
.018c77	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018c79	20 3f 85	jsr $01853f		jsr 	VIOCharPrint
.018c7c	c8		iny				iny
.018c7d	ca		dex			dex
.018c7e	d0 f7		bne $018c77		bne 	_CIShowPrompt
.018c80	80 e2		bra $018c64		bra 	_CILoop
.018c82					_CIAdvance:
.018c82	c8		iny				iny
.018c83					_CINoPrompt:
.018c83	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018c85	c9 bf		cmp #$bf		cmp 	#token_Comma 					; skip , and ;
.018c87	f0 f9		beq $018c82		beq 	_CIAdvance
.018c89	c9 c1		cmp #$c1		cmp 	#token_SemiColon
.018c8b	f0 f5		beq $018c82		beq 	_CIAdvance
.018c8d	c9 00		cmp #$00		cmp 	#0 								; exit if 0 or :
.018c8f	f0 04		beq $018c95		beq 	_CIExit
.018c91	c9 c0		cmp #$c0		cmp 	#token_Colon
.018c93	d0 01		bne $018c96		bne 	_CIIsVariable  					; if not then there#s a variable or should be !
.018c95					_CIExit:
.018c95	60		rts			rts
.018c96					_CIIsVariable:
.018c96	20 fe 9c	jsr $019cfe		jsr 	VariableFind 					; set zVarType and zVarDataPtr accordingly.
.018c99	a5 26		lda $26			lda 	zVarType
.018c9b	c9 b7		cmp #$b7		cmp 	#token_Dollar 					; is it a string ?
.018c9d	f0 40		beq $018cdf		beq 	_CIIsString
.018c9f					_CINGetText:
.018c9f	a9 00		lda #$00		lda 	#0
.018ca1	8d 14 03	sta $0314		sta 	NumBufX
.018ca4					_CINSkip:
.018ca4	20 3e 8d	jsr $018d3e		jsr 	CIGetCharacter 					; get character skip spaces
.018ca7	c9 20		cmp #$20		cmp 	#" "
.018ca9	f0 f9		beq $018ca4		beq 	_CINSkip
.018cab	c9 2c		cmp #$2c		cmp 	#","
.018cad	f0 f5		beq $018ca4		beq 	_CINSkip
.018caf					_CINLoop:
.018caf	ae 14 03	ldx $0314		ldx 	NumBufX 						; output character
.018cb2	9d 15 03	sta $0315,x		sta 	Num_Buffer,x
.018cb5	a9 00		lda #$00		lda 	#0 								; add trailing NULL
.018cb7	9d 16 03	sta $0316,x		sta 	Num_Buffer+1,x
.018cba	ee 14 03	inc $0314		inc 	NumBufX 						; bump ptr
.018cbd	20 3e 8d	jsr $018d3e		jsr 	CIGetCharacter 					; get next character
.018cc0	c9 3a		cmp #$3a		cmp 	#":" 							; stop on : ,
.018cc2	f0 08		beq $018ccc		beq 	_CINCopied
.018cc4	c9 2c		cmp #$2c		cmp 	#","
.018cc6	f0 04		beq $018ccc		beq 	_CINCopied
.018cc8	c9 21		cmp #$21		cmp 	#" "+1
.018cca	b0 e3		bcs $018caf		bcs 	_CINLoop
.018ccc					_CINCopied:
.018ccc	a2 00		ldx #$00		ldx 	#0
.018cce	20 66 97	jsr $019766		jsr 	ConvertNumBuffer 				; convert number
.018cd1	b0 05		bcs $018cd8		bcs 	_CINFailed 						; didn't work.
.018cd3	20 97 a0	jsr $01a097		jsr 	VariableSet 					; set variable.
.018cd6	80 8c		bra $018c64		bra 	_CILoop 						; go round again.
.018cd8					_CINFailed:
.018cd8	a9 00		lda #$00		lda 	#0 								; set to request input next time.
.018cda	8d c2 03	sta $03c2		sta 	InputAvailable
.018cdd	80 c0		bra $018c9f		bra 	_CINGetText 					; and try again
.018cdf					_CIIsString:
.018cdf	a9 82		lda #$82		lda 	#130 							; max of 128 characters
.018ce1	20 86 9a	jsr $019a86		jsr 	AllocateTempString
.018ce4	a9 00		lda #$00		lda 	#0 								; this is the quote flag.
.018ce6	8d 14 03	sta $0314		sta 	NumBufX
.018ce9					_CISSkip:
.018ce9	20 3e 8d	jsr $018d3e		jsr 	CIGetCharacter 					; get character skip spaces
.018cec	c9 20		cmp #$20		cmp 	#" "
.018cee	f0 f9		beq $018ce9		beq 	_CISSkip
.018cf0	80 03		bra $018cf5		bra 	_CISInputProcess 				; handle that as the first character
.018cf2					_CISInput:
.018cf2	20 3e 8d	jsr $018d3e		jsr 	CIGetCharacter
.018cf5					_CISInputProcess:
.018cf5	c9 0d		cmp #$0d		cmp 	#13 							; EOL ?
.018cf7	f0 31		beq $018d2a		beq 	_CISDone
.018cf9	c9 3a		cmp #$3a		cmp 	#":"							; colon exits if not in quotes. who knows why?
.018cfb	d0 05		bne $018d02		bne 	_CISNotColon
.018cfd	2c 14 03	bit $0314		bit 	NumBufX 						; check quote flag
.018d00	10 28		bpl $018d2a		bpl 	_CISDone 						; if quote flag zero, done
.018d02					_CISNotColon:
.018d02	c9 22		cmp #$22		cmp 	#'"'							; quoted string ?
.018d04	f0 1a		beq $018d20		beq 	_CISIsQuote						; if so handle that code.
.018d06	20 b1 9a	jsr $019ab1		jsr 	WriteTempString 				; write to the temporary string
.018d09	ad 9f 03	lda $039f		lda 	TempStringWriteIndex 			; string too long ?
.018d0c	10 e4		bpl $018cf2		bpl 	_CISInput
.018d0e	20 86 85	jsr $018586			jsr ERR_Handler
>018d11	49 6e 70 75 74 20 74 6f			.text "Input too long",0
>018d19	6f 20 6c 6f 6e 67 00
.018d20					_CISIsQuote:
.018d20	ad 14 03	lda $0314		lda 	NumBufX 						; this is the 'in quote flag'
.018d23	49 80		eor #$80		eor 	#$80 							; toggle bit 7
.018d25	8d 14 03	sta $0314		sta 	NumBufX
.018d28	d0 c8		bne $018cf2		bne 	_CISInput 						; if entered quote mode, get next character
.018d2a					_CISDone:
.018d2a	a5 22		lda $22			lda 	zTempStr 						; return the temporary string
.018d2c	85 80		sta $80			sta 	XS_Mantissa+0
.018d2e	a5 23		lda $23			lda 	zTempStr+1
.018d30	85 81		sta $81			sta 	XS_Mantissa+1
.018d32	a9 02		lda #$02		lda 	#2
.018d34	85 85		sta $85			sta 	XS_Type
.018d36	a2 00		ldx #$00		ldx 	#0
.018d38	20 97 a0	jsr $01a097		jsr 	VariableSet 					; set variable.
.018d3b	4c 64 8c	jmp $018c64		jmp 	_CILoop 						; and try again
.018d3e					CIGetCharacter:
.018d3e	5a		phy			phy
.018d3f	ac c2 03	ldy $03c2		ldy		InputAvailable 					; anything available
.018d42	f0 0c		beq $018d50		beq 	_CIGCNewLine 					; no, needs a new line.
.018d44	b9 66 05	lda $0566,y		lda 	IFT_LineBuffer,y 				; read line buffer entry
.018d47	c9 0d		cmp #$0d		cmp 	#13 							; got 13 ?
.018d49	f0 03		beq $018d4e		beq 	_CIGCNoInc
.018d4b	ee c2 03	inc $03c2		inc 	InputAvailable 					; if not, advance character pointer.
.018d4e					_CIGCNoInc:
.018d4e	7a		ply			ply
.018d4f	60		rts			rts
.018d50					_CIGCNewLine:
.018d50	ee c2 03	inc $03c2		inc 	InputAvailable 					; next pointer to 1 (first char this time)
.018d53	a9 3f		lda #$3f		lda 	#"?"
.018d55	20 3f 85	jsr $01853f		jsr 	VIOCharPrint
.018d58	ac c3 03	ldy $03c3		ldy 	InputRetry 						; retry flag set
.018d5b	f0 03		beq $018d60		beq 	_CIGCPrompt 					; if so, then print ? again
.018d5d	20 3f 85	jsr $01853f		jsr 	VIOCharPrint
.018d60					_CIGCPrompt:
.018d60	a0 01		ldy #$01		ldy 	#1
.018d62	8c c3 03	sty $03c3		sty 	InputRetry 						; set the input retry flag to non-zero
.018d65					_CIGCBackOne:
.018d65	88		dey			dey
.018d66					_CIGCLoop:
.018d66	c0 50		cpy #$50		cpy 	#80 							; stop overflow.
.018d68	f0 fb		beq $018d65		beq 	_CIGCBackOne
.018d6a	20 42 85	jsr $018542		jsr 	VIOCharGet 						; get a character
.018d6d	f0 f7		beq $018d66		beq 	_CIGCLoop 						; wait until key pressed
.018d6f	c9 08		cmp #$08		cmp 	#8 								; backspace
.018d71	f0 10		beq $018d83		beq 	_CIGCBackSpace
.018d73	20 3f 85	jsr $01853f		jsr 	VIOCharPrint 					; echo character
.018d76	99 66 05	sta $0566,y		sta		IFT_LineBuffer,y 				; write into buffer and bump
.018d79	c8		iny			iny
.018d7a	c9 0d		cmp #$0d		cmp 	#13 							; until CR pressed.
.018d7c	d0 e8		bne $018d66		bne 	_CIGCLoop
.018d7e	ad 66 05	lda $0566		lda 	IFT_LineBuffer 					; return first char in buffer
.018d81	7a		ply			ply 									; restore Y
.018d82	60		rts			rts
.018d83					_CIGCBackSpace:
.018d83	c0 00		cpy #$00		cpy 	#0 								; can only B/S if not first
.018d85	f0 df		beq $018d66		beq 	_CIGCLoop
.018d87	20 3f 85	jsr $01853f		jsr 	VIOCharPrint 					; echo BS
.018d8a	88		dey			dey 									; go back one.
.018d8b	80 d9		bra $018d66		bra 	_CIGCLoop

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/end.asm

.018d8d					Command_END:
>018d8d	02						.byte 	2
.018d8e	4c 47 88	jmp $018847			jmp 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/if.asm

.018d91					Command_IF:
.018d91	20 e3 93	jsr $0193e3			jsr 	EvaluateInteger 			; check success.
.018d94	a5 80		lda $80				lda 	XS_Mantissa+0				; check the result if zero
.018d96	05 81		ora $81				ora 	XS_Mantissa+1
.018d98	05 82		ora $82				ora 	XS_Mantissa+2
.018d9a	05 83		ora $83				ora 	XS_Mantissa+3
.018d9c	aa		tax				tax 								; put into X.
.018d9d	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018d9f	c9 93		cmp #$93			cmp 	#token_Then 				; then found.
.018da1	d0 2c		bne $018dcf			bne 	_FIFExtended
.018da3	c8		iny				iny
.018da4	e0 00		cpx #$00			cpx 	#0 							; was it successful.
.018da6	f0 0b		beq $018db3			beq 	_FIFEndOfLine 				; if not, go to the end of the line.
.018da8	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018daa	29 c0		and #$c0			and 	#$C0 						; is it a number
.018dac	c9 40		cmp #$40			cmp 	#$40
.018dae	d0 1e		bne $018dce			bne 	_FIFContinue 				; if not, do what ever follows.
.018db0	4c 1d 91	jmp $01911d			jmp		Command_GOTO 				; we have IF <expr> THEN <number> so we do GOTO code.
.018db3					_FIFEndOfLine:
.018db3	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018db5	c9 00		cmp #$00			cmp 	#0 							; if zero, end of line, so exit
.018db7	f0 15		beq $018dce			beq 	_FIFContinue
.018db9	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read element
.018dbb	c8		iny				iny 								; skip
.018dbc	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018dbe	90 0c		bcc $018dcc			bcc 	_SEDone 					; so just skip over it.
.018dc0	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018dc2	90 07		bcc $018dcb			bcc 	_SEDouble
.018dc4	98		tya				tya 								; this is Y + 1
.018dc5	18		clc				clc
.018dc6	77 18		adc [$18],y			adc 	[zCodePtr],y 				; add total length of element
.018dc8	a8		tay				tay 								; back in Y.
.018dc9	88		dey				dey 								; fix up, one for the +1, one for the iny
.018dca	88		dey				dey
.018dcb					_SEDouble:
.018dcb	c8		iny				iny
.018dcc					_SEDone:
.018dcc	80 e5		bra $018db3			bra 	_FIFEndOfLine
.018dce					_FIFContinue:
.018dce	60		rts				rts
.018dcf					_FIFExtended:
.018dcf	da		phx				phx 								; save result
.018dd0	a9 40		lda #$40			lda 	#(SMark_If << 4) 			; push marker on the stack, nothing else.
.018dd2	20 bf 84	jsr $0184bf			jsr 	StackPushFrame
.018dd5	68		pla				pla 								; restore result
.018dd6	f0 01		beq $018dd9			beq 	_FIXSkip 					; if zero then it has failed.
.018dd8	60		rts				rts 								; test passed, so continue executing
.018dd9					_FIXSkip:
.018dd9	a9 94		lda #$94			lda 	#token_endif 				; scan forward till found either ELSE or ENDIF
.018ddb	a2 de		ldx #$de			ldx 	#token_else 				; at the same level.
.018ddd	20 02 84	jsr $018402			jsr 	StructureSearchDouble
.018de0	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018de2	c8		iny				iny
.018de3	c9 94		cmp #$94			cmp 	#token_endif 				; if endif, handle endif code.
.018de5	f0 07		beq $018dee			beq 	Command_ENDIF
.018de7	60		rts				rts
.018de8					Command_ELSE:
.018de8	a9 94		lda #$94			lda 	#token_endif 				; scan forward till found ENDIF
.018dea	20 00 84	jsr $018400			jsr 	StructureSearchSingle 		; then do the ENDIF pop.
.018ded	c8		iny				iny
.018dee					Command_ENDIF:
.018dee	a9 40		lda #$40			lda 	#(SMark_If << 4)
.018df0	20 d6 84	jsr $0184d6			jsr 	StackPopFrame
.018df3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/list.asm

.018df4					Command_LIST:
.018df4	20 81 8f	jsr $018f81			jsr 	ListGetRange				; get any parameters
.018df7	a9 00		lda #$00			lda 	#(BasicProgram) & $FF
.018df9	85 18		sta $18				sta 	zCodePtr+0
.018dfb	a9 10		lda #$10			lda 	#(BasicProgram) >> 8
.018dfd	85 19		sta $19				sta 	zCodePtr+1
.018dff	a9 00		lda #$00			lda 	#0
.018e01	85 1a		sta $1a				sta 	zCodePtr+2
.018e03	85 1b		sta $1b				sta 	zCodePtr+3
.018e05	a0 03		ldy #$03			ldy 	#3
.018e07	a9 00		lda #$00			lda 	#0 							; reset the indent & last indent
.018e09	8d bc 03	sta $03bc			sta 	LastListIndent
.018e0c	8d bb 03	sta $03bb			sta 	ListIndent
.018e0f					_CILLoop:
.018e0f	a0 00		ldy #$00			ldy 	#0
.018e11	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018e13	c9 00		cmp #$00			cmp 	#0 							; if zero, end of program
.018e15	f0 23		beq $018e3a			beq 	_CILExit
.018e17	20 4d 85	jsr $01854d			jsr 	VIOCheckBreak 				; check break
.018e1a	c9 00		cmp #$00			cmp 	#0
.018e1c	d0 1c		bne $018e3a			bne 	_CILExit
.018e1e	20 c8 8f	jsr $018fc8			jsr 	ListCheckRange 				; check current line in range.
.018e21	b0 08		bcs $018e2b			bcs		_CILNext
.018e23	a0 00		ldy #$00			ldy 	#0
.018e25	c8		iny				iny
.018e26	c8		iny				iny
.018e27	c8		iny				iny
.018e28	20 3d 8e	jsr $018e3d			jsr 	ListLine 					; list one line.
.018e2b					_CILNext:
.018e2b	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018e2d	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read it
.018e2f	18		clc				clc
.018e30	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.018e32	85 18		sta $18				sta 	zCodePtr
.018e34	90 02		bcc $018e38			bcc 	_SNLNoCarry
.018e36	e6 19		inc $19				inc 	zCodePtr+1
.018e38					_SNLNoCarry:
.018e38	80 d5		bra $018e0f			bra 	_CILLoop
.018e3a					_CILExit:
.018e3a	4c 47 88	jmp $018847			jmp 	WarmStart
.018e3d					ListLine:
.018e3d	ad bb 03	lda $03bb			lda 	ListIndent 					; copy current list indent -> last
.018e40	8d bc 03	sta $03bc			sta 	LastListIndent
.018e43					_LICountIndent:
.018e43	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018e45	c9 00		cmp #$00			cmp 	#0
.018e47	f0 2f		beq $018e78			beq 	_LIDoneIndent
.018e49	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus
.018e4b	90 16		bcc $018e63			bcc 	_LICINext
.018e4d	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.018e4f	b0 12		bcs $018e63			bcs 	_LICINext
.018e51	ee bb 03	inc $03bb			inc 	ListIndent
.018e54	c9 93		cmp #$93			cmp 	#firstKeywordMinus
.018e56	90 0b		bcc $018e63			bcc 	_LICINext
.018e58	ce bb 03	dec $03bb			dec 	ListIndent
.018e5b	ce bb 03	dec $03bb			dec 	ListIndent
.018e5e	10 03		bpl $018e63			bpl 	_LICINext
.018e60	ee bb 03	inc $03bb			inc 	ListIndent
.018e63					_LICINext:
.018e63	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read element
.018e65	c8		iny				iny 								; skip
.018e66	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018e68	90 0c		bcc $018e76			bcc 	_SEDone 					; so just skip over it.
.018e6a	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018e6c	90 07		bcc $018e75			bcc 	_SEDouble
.018e6e	98		tya				tya 								; this is Y + 1
.018e6f	18		clc				clc
.018e70	77 18		adc [$18],y			adc 	[zCodePtr],y 				; add total length of element
.018e72	a8		tay				tay 								; back in Y.
.018e73	88		dey				dey 								; fix up, one for the +1, one for the iny
.018e74	88		dey				dey
.018e75					_SEDouble:
.018e75	c8		iny				iny
.018e76					_SEDone:
.018e76	80 cb		bra $018e43			bra 	_LICountIndent
.018e78					_LIDoneIndent:
.018e78	a0 00		ldy #$00			ldy 	#0
.018e7a	c8		iny				iny
.018e7b	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018e7d	85 80		sta $80				sta 	XS_Mantissa
.018e7f	c8		iny				iny
.018e80	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018e82	85 81		sta $81				sta 	XS_Mantissa+1
.018e84	20 d1 85	jsr $0185d1			jsr 	Print16BitInteger 			; print integer.
.018e87	85 10		sta $10				sta 	zTemp1 						; save spaces printed.
.018e89	ad bb 03	lda $03bb			lda 	ListIndent 					; smaller of current/prev indent
.018e8c	cd bc 03	cmp $03bc			cmp 	LastListIndent
.018e8f	90 03		bcc $018e94			bcc 	_LISmaller
.018e91	ad bc 03	lda $03bc			lda 	LastListIndent
.018e94					_LISmaller:
.018e94	0a		asl a				asl 	a 							; double indent
.018e95	49 ff		eor #$ff			eor 	#$FF 						; 2's complement arithmetic
.018e97	38		sec				sec
.018e98	65 10		adc $10				adc 	zTemp1 						; "subtract" indent e.g. print more.
.018e9a	aa		tax				tax 								; print spaces to column 6
.018e9b					_LISpace:
.018e9b	a9 20		lda #$20			lda 	#" "
.018e9d	20 71 8f	jsr $018f71			jsr 	ListPrintLC
.018ea0	e8		inx				inx
.018ea1	e0 06		cpx #$06			cpx 	#6
.018ea3	d0 f6		bne $018e9b			bne 	_LISpace
.018ea5					_LIDecode:
.018ea5	c8		iny				iny
.018ea6	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018ea8	c9 00		cmp #$00			cmp 	#0 							; zero, exit.
.018eaa	f0 0f		beq $018ebb			beq 	_LIExit
.018eac	30 12		bmi $018ec0			bmi 	_LIToken
.018eae	c9 40		cmp #$40			cmp 	#$40 						; 01-$3F, character.
.018eb0	b0 50		bcs $018f02			bcs 	_LIInteger
.018eb2	49 20		eor #$20			eor 	#$20 						; make 7 bit
.018eb4	69 20		adc #$20			adc 	#$20
.018eb6	20 71 8f	jsr $018f71			jsr 	ListPrintLC 				; print in LC
.018eb9	80 ea		bra $018ea5			bra 	_LIDecode
.018ebb					_LIExit:
.018ebb	a9 0d		lda #$0d			lda 	#13 						; print new line.
.018ebd	4c 71 8f	jmp $018f71			jmp 	ListPrintLC
.018ec0					_LIToken:
.018ec0	c9 fc		cmp #$fc			cmp 	#$FC 						; $FC-$FF ?
.018ec2	90 49		bcc $018f0d			bcc		_LICommandToken
.018ec4	48		pha				pha 								; save in case end
.018ec5	a2 22		ldx #$22			ldx 	#'"'						; print if $FE quoted string
.018ec7	c9 fe		cmp #$fe			cmp 	#$FE
.018ec9	f0 17		beq $018ee2			beq 	_LIPrint
.018ecb	a2 2e		ldx #$2e			ldx 	#'.'						; print if $FD decimals
.018ecd	c9 fd		cmp #$fd			cmp 	#$FD
.018ecf	f0 11		beq $018ee2			beq 	_LIPrint
.018ed1	a9 52		lda #$52			lda 	#'R'						; must be REM
.018ed3	20 71 8f	jsr $018f71			jsr 	ListPrintLC
.018ed6	a9 45		lda #$45			lda 	#'E'
.018ed8	20 71 8f	jsr $018f71			jsr 	ListPrintLC
.018edb	a9 4d		lda #$4d			lda 	#'M'
.018edd	20 71 8f	jsr $018f71			jsr 	ListPrintLC
.018ee0	a2 20		ldx #$20			ldx 	#' '
.018ee2					_LIPrint:
.018ee2	8a		txa				txa
.018ee3	20 71 8f	jsr $018f71			jsr 	ListPrintLC
.018ee6	c8		iny				iny
.018ee7	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018ee9	aa		tax				tax 								; put in X
.018eea	ca		dex				dex
.018eeb					_LILoop:
.018eeb	ca		dex				dex 								; exit when count reached zero.
.018eec	f0 08		beq $018ef6			beq 	_LIEnd
.018eee	c8		iny				iny
.018eef	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018ef1	20 71 8f	jsr $018f71			jsr 	ListPrintLC
.018ef4	80 f5		bra $018eeb			bra 	_LILoop
.018ef6	68		pla		_LIEnd:	pla 								; get A back
.018ef7	c9 fe		cmp #$fe			cmp 	#$FE 						; if '"' need closing quotes
.018ef9	d0 aa		bne $018ea5			bne 	_LIDecode
.018efb	a9 22		lda #$22			lda 	#'"'
.018efd	20 71 8f	jsr $018f71			jsr 	ListPrintLC
.018f00	80 a3		bra $018ea5			bra 	_LIDecode
.018f02					_LIInteger:
.018f02	a2 00		ldx #$00			ldx 	#0
.018f04	20 55 93	jsr $019355			jsr 	EvaluateGetInteger 			; get an atom
.018f07	88		dey				dey
.018f08	20 d7 85	jsr $0185d7			jsr 	Print32BitInteger 			; print integer.
.018f0b	80 98		bra $018ea5			bra 	_LIDecode
.018f0d					_LICommandToken:
.018f0d	5a		phy				phy 								; save Y
.018f0e	48		pha				pha 								; save token
.018f0f	a2 cf		ldx #$cf			ldx  	#KeywordText & $FF 			; address of keyword text table.
.018f11	a9 86		lda #$86			lda 	(#KeywordText >> 8) & $FF
.018f13	86 1c		stx $1c				stx 	zLTemp1
.018f15	85 1d		sta $1d				sta 	zLTemp1+1
.018f17	a9 01		lda #$01			lda 	(#KeywordText >> 16) & $FF 	; this is for 65816 (it's a table in code
.018f19	85 1e		sta $1e				sta 	zLTemp1+2 					; space) and won't affect a 6502 at all.
.018f1b	68		pla				pla 								; get token
.018f1c	29 7f		and #$7f			and 	#127 						; chuck bit 7.
.018f1e	f0 16		beq $018f36			beq 	_LIFoundToken
.018f20	aa		tax				tax
.018f21					_LITokenLoop:
.018f21	a0 00		ldy #$00			ldy 	#0 							; last character not a token.
.018f23					_LIFindEnd:
.018f23	b7 1c		lda [$1c],y			lda 	[zLTemp1],y
.018f25	c8		iny				iny
.018f26	0a		asl a				asl 	a
.018f27	90 fa		bcc $018f23			bcc 	_LIFindEnd
.018f29	98		tya				tya 								; that is step to the next
.018f2a	18		clc				clc 								; we don't bother bumping the 3rd byte
.018f2b	65 1c		adc $1c				adc 	zLTemp1 					; here.
.018f2d	85 1c		sta $1c				sta 	zLTemp1
.018f2f	90 02		bcc $018f33			bcc 	_LINoBump
.018f31	e6 1d		inc $1d				inc 	zLTemp1+1
.018f33					_LINoBump:
.018f33	ca		dex				dex 								; no go round again.
.018f34	d0 eb		bne $018f21			bne 	_LITokenLoop
.018f36					_LIFoundToken:
.018f36	a0 00		ldy #$00			ldy 	#0
.018f38					_LIPrintToken:
.018f38	b7 1c		lda [$1c],y			lda 	[zLTemp1],y
.018f3a	c0 00		cpy #$00			cpy 	#0 							; see if needs prefix space
.018f3c	d0 16		bne $018f54			bne 	_LINoPrefixSpace
.018f3e	c9 41		cmp #$41			cmp 	#"A" 						; e.g. alphabetic token.
.018f40	90 12		bcc $018f54			bcc 	_LINoPrefixSpace
.018f42	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018f44	b0 0e		bcs $018f54			bcs 	_LINoPrefixSpace
.018f46	ae ba 03	ldx $03ba			ldx 	LastPrinted 				; if last was space not required
.018f49	e0 20		cpx #$20			cpx 	#" "
.018f4b	f0 07		beq $018f54			beq 	_LINoPrefixSpace
.018f4d	48		pha				pha
.018f4e	a9 20		lda #$20			lda 	#" "
.018f50	20 71 8f	jsr $018f71			jsr 	ListPrintLC
.018f53	68		pla				pla
.018f54					_LINoPrefixSpace:
.018f54	c8		iny				iny
.018f55	48		pha				pha 								; save it
.018f56	29 7f		and #$7f			and 	#$7F
.018f58	20 71 8f	jsr $018f71			jsr 	ListPrintLC
.018f5b	68		pla				pla
.018f5c	10 da		bpl $018f38			bpl 	_LIPrintToken 				; go back if not end
.018f5e	7a		ply				ply 								; restore Y
.018f5f	29 7f		and #$7f			and 	#$7F 						; if last char is a letter
.018f61	c9 41		cmp #$41			cmp 	#"A"
.018f63	90 09		bcc $018f6e			bcc 	_LINotLetter2
.018f65	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018f67	b0 05		bcs $018f6e			bcs 	_LINotLetter2
.018f69	a9 20		lda #$20			lda 	#" " 						; add spacing
.018f6b	20 71 8f	jsr $018f71			jsr 	ListPrintLC
.018f6e					_LINotLetter2:
.018f6e	4c a5 8e	jmp $018ea5			jmp 	_LIDecode
.018f71					ListPrintLC:
.018f71	8d ba 03	sta $03ba			sta 	LastPrinted
.018f74	c9 41		cmp #$41			cmp 	#"A"
.018f76	90 06		bcc $018f7e			bcc 	_LPLC0
.018f78	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018f7a	b0 02		bcs $018f7e			bcs 	_LPLC0
.018f7c	69 20		adc #$20			adc 	#$20
.018f7e	4c 3f 85	jmp $01853f	_LPLC0:	jmp 	VIOCharPrint
.018f81					ListGetRange:
.018f81	a2 0b		ldx #$0b			ldx 	#XS_Size*2-1 				; clear first 2 slots back to defaults.
.018f83					_LGRClear:
.018f83	a9 00		lda #$00			lda 	#0
.018f85	95 80		sta $80,x			sta 	XS_Mantissa,x
.018f87	ca		dex				dex
.018f88	10 f9		bpl $018f83			bpl 	_LGRClear
.018f8a	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018f8c	c9 00		cmp #$00			cmp 	#0 							; nothing
.018f8e	f0 21		beq $018fb1			beq 	_LGRBlank
.018f90	c9 c0		cmp #$c0			cmp 	#token_Colon 				; or colon
.018f92	f0 1d		beq $018fb1			beq 	_LGRBlank
.018f94	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma
.018f96	f0 18		beq $018fb0			beq 	_LGREnd 					; then it's LIST ,x
.018f98	20 e3 93	jsr $0193e3			jsr 	EvaluateInteger 			; get the first number into bottom
.018f9b	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018f9d	c9 bf		cmp #$bf			cmp 	#token_Comma
.018f9f	f0 0f		beq $018fb0			beq 	_LGREnd 					; then it is LIST a,b
.018fa1	a5 80		lda $80				lda 	XS_Mantissa+0 				; copy first to second LIST n is n,n
.018fa3	85 86		sta $86				sta 	XS_Mantissa+XS_Size+0
.018fa5	a5 81		lda $81				lda 	XS_Mantissa+1
.018fa7	85 87		sta $87				sta 	XS_Mantissa+XS_Size+1
.018fa9					_LGRBumpExit:
.018fa9	e6 86		inc $86				inc 	XS_Mantissa+XS_Size 		; bump it so we can use cc.
.018fab	d0 02		bne $018faf			bne 	_LGRBump2
.018fad	e6 87		inc $87				inc 	XS_Mantissa+XS_Size+1
.018faf					_LGRBump2:
.018faf	60		rts				rts
.018fb0					_LGREnd:
.018fb0	c8		iny				iny
.018fb1					_LGRBlank:
.018fb1	a9 ff		lda #$ff			lda 	#$FF 						; default to the end.
.018fb3	85 86		sta $86				sta 	XS_Mantissa+XS_Size
.018fb5	85 87		sta $87				sta 	XS_Mantissa+XS_Size+1
.018fb7	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018fb9	c9 00		cmp #$00			cmp 	#0
.018fbb	f0 f2		beq $018faf			beq 	_LGRBump2
.018fbd	0a		asl a				asl 	a 							; if not a number, then exit (to end)
.018fbe	b0 ef		bcs $018faf			bcs 	_LGRBump2
.018fc0	a2 06		ldx #$06			ldx 	#XS_Size 					; get to range
.018fc2	20 e5 93	jsr $0193e5			jsr 	EvaluateIntegerX
.018fc5	80 e2		bra $018fa9			bra 	_LGRBumpExit
.018fc7	60		rts				rts
.018fc8					ListCheckRange:
.018fc8	c8		iny				iny
.018fc9	a2 00		ldx #$00			ldx 	#0 							; test low
.018fcb	20 d8 8f	jsr $018fd8			jsr 	_LCRCompare
.018fce	90 06		bcc $018fd6			bcc 	_LCRFail
.018fd0	a2 06		ldx #$06			ldx 	#XS_Size 					; test high
.018fd2	20 d8 8f	jsr $018fd8			jsr 	_LCRCompare
.018fd5	60		rts				rts
.018fd6					_LCRFail:
.018fd6	38		sec				sec
.018fd7	60		rts				rts
.018fd8					_LCRCompare:
.018fd8	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018fda	38		sec				sec
.018fdb	f5 80		sbc $80,x			sbc	 	XS_Mantissa+0,x
.018fdd	08		php				php
.018fde	c8		iny				iny
.018fdf	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018fe1	28		plp				plp
.018fe2	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.018fe4	08		php				php
.018fe5	88		dey				dey
.018fe6	28		plp				plp
.018fe7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/print.asm

.018fe8					Command_PRINT:
.018fe8					_CPR_Loop:
.018fe8	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018fea	c9 00		cmp #$00			cmp 	#0 							; end
.018fec	f0 24		beq $019012			beq 	_CPR_GoNewLine
.018fee	c9 c0		cmp #$c0			cmp 	#token_Colon
.018ff0	f0 20		beq $019012			beq 	_CPR_GoNewLine
.018ff2	c9 c1		cmp #$c1			cmp 	#token_SemiColon
.018ff4	f0 74		beq $01906a			beq 	_CPR_Skip
.018ff6	c9 bf		cmp #$bf			cmp 	#token_Comma
.018ff8	f0 57		beq $019051			beq 	_CPR_Tab
.018ffa	20 4d 92	jsr $01924d			jsr 	EvaluateExpression 			; get expression.
.018ffd	a5 85		lda $85				lda 	XS_Type 					; get type.
.018fff	29 02		and #$02			and 	#2
.019001	d0 27		bne $01902a			bne 	_CPR_String 				; if type = 2 output as string.
.019003					_CPR_Number:
.019003	a9 00		lda #$00			lda 	#0 							; reset buffer index
.019005	8d 14 03	sta $0314			sta 	NumBufX
.019008	a5 85		lda $85				lda 	XS_Type 					; get type
.01900a	4a		lsr a				lsr 	a
.01900b	b0 08		bcs $019015			bcs 	_CPRInt 					; if msb set do as integer
.01900d	20 5a a7	jsr $01a75a			jsr 	FPToString 					; call fp to str otherwise
.019010	80 06		bra $019018			bra 	_CPRNPrint
.019012					_CPR_GoNewLine:
.019012	4c 78 90	jmp $019078			jmp 	_CPR_NewLine
.019015	20 e0 a1	jsr $01a1e0	_CPRInt:jsr 	IntToString
.019018					_CPRNPrint:
.019018	ad 15 03	lda $0315			lda 	Num_Buffer 					; is first character -
.01901b	c9 2d		cmp #$2d			cmp 	#"-"
.01901d	f0 05		beq $019024			beq 	_CPRNoSpace
.01901f	a9 20		lda #$20			lda 	#" "						; print the leading space
.019021	20 3f 85	jsr $01853f			jsr 	VIOCharPrint 				; so beloved of MS Basics.
.019024					_CPRNoSpace:
.019024	a2 14		ldx #$14			ldx 	#(Num_Buffer-1) & $FF
.019026	a9 03		lda #$03			lda 	#(Num_Buffer-1) >> 8
.019028	80 04		bra $01902e			bra 	_CPRPrint
.01902a					_CPR_String:
.01902a	a6 80		ldx $80				ldx 	XS_Mantissa
.01902c	a5 81		lda $81				lda 	XS_Mantissa+1
.01902e					_CPRPrint:
.01902e	86 20		stx $20				stx 	zGenPtr
.019030	85 21		sta $21				sta 	zGenPtr+1
.019032	5a		phy				phy
.019033	a0 00		ldy #$00			ldy 	#0							; get length into X
.019035	b1 20		lda ($20),y			lda 	(zGenPtr),y
.019037	aa		tax				tax
.019038	f0 09		beq $019043			beq 	_CPREndPrint 				; nothing to print
.01903a					_CPRLoop:
.01903a	c8		iny				iny
.01903b	b1 20		lda ($20),y			lda 	(zGenPtr),y
.01903d	20 3f 85	jsr $01853f			jsr 	VIOCharPrint
.019040	ca		dex				dex
.019041	d0 f7		bne $01903a			bne 	_CPRLoop
.019043					_CPREndPrint:
.019043	a5 85		lda $85				lda 	XS_Type 					; if numeric add trailing space
.019045	29 02		and #$02			and 	#2
.019047	d0 05		bne $01904e			bne 	_CPRNoTrail
.019049	a9 20		lda #$20			lda 	#" "
.01904b	20 3f 85	jsr $01853f			jsr 	VIOCharPrint
.01904e					_CPRNoTrail:
.01904e	7a		ply				ply
.01904f	80 97		bra $018fe8			bra 	_CPR_Loop
.019051					_CPR_Tab:
.019051	20 50 85	jsr $018550			jsr 	VIOCharGetPosition 			; print until position % 8 = 0
.019054					_CPR_CalcSpaces:
.019054	38		sec				sec 								; calculate position mod 10.
.019055	e9 0a		sbc #$0a			sbc 	#10
.019057	b0 fb		bcs $019054			bcs 	_CPR_CalcSpaces
.019059	69 0a		adc #$0a			adc 	#10
.01905b	f0 0d		beq $01906a			beq 	_CPR_Skip 					; nothing to print
.01905d	aa		tax				tax 								; print out spaces to mod 10
.01905e					_CPRTabSpaces:
.01905e	a9 20		lda #$20			lda 	#" "
.019060	20 3f 85	jsr $01853f			jsr 	VIOCharPrint
.019063	e8		inx				inx
.019064	e0 0a		cpx #$0a			cpx 	#10
.019066	d0 f6		bne $01905e			bne 	_CPRTabSpaces
.019068	80 e7		bra $019051			bra 	_CPR_Tab
.01906a					_CPR_Skip:
.01906a	c8		iny				iny
.01906b	b7 18		lda [$18],y			lda 	[zCodePtr],y
.01906d	c9 c0		cmp #$c0			cmp 	#token_Colon 				; colon or $00, exit
.01906f	f0 0c		beq $01907d			beq 	_CPR_Exit
.019071	c9 00		cmp #$00			cmp 	#0
.019073	f0 08		beq $01907d			beq 	_CPR_Exit 					; if not go round again.
.019075	4c e8 8f	jmp $018fe8			jmp 	_CPR_Loop
.019078					_CPR_NewLine:
.019078	a9 0d		lda #$0d			lda 	#13
.01907a	20 3f 85	jsr $01853f			jsr 	VIOCharPrint
.01907d					_CPR_Exit:
.01907d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/assert.asm

.01907e					Command_ASSERT:
.01907e	20 e3 93	jsr $0193e3			jsr 	EvaluateInteger 			; calculate thing being asserted, 0=>X
.019081	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; check if true (non-zero)
.019083	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019085	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019087	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019089	f0 01		beq $01908c			beq 	_ASFail
.01908b	60		rts				rts
.01908c					_ASFail:
.01908c	20 86 85	jsr $018586			jsr ERR_Handler
>01908f	41 73 73 65 72 74 00			.text "Assert",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/poke.asm

.019096					Command_POKE:
.019096	a9 01		lda #$01			lda 	#1 							; 1 byte
.019098	80 06		bra $0190a0			bra 	CmdPoke_Main
.01909a					Command_DOKE:
.01909a	a9 02		lda #$02			lda 	#2 							; 2 bytes
.01909c	80 02		bra $0190a0			bra 	CmdPoke_Main
.01909e					Command_LOKE:
.01909e	a9 04		lda #$04			lda 	#4							; 4 bytes
.0190a0					CmdPoke_Main:
.0190a0	48		pha				pha
.0190a1	20 e3 93	jsr $0193e3			jsr 	EvaluateInteger 			; get two parameters. First is address
.0190a4	e8		inx				inx
.0190a5	e8		inx				inx
.0190a6	e8		inx				inx
.0190a7	e8		inx				inx
.0190a8	e8		inx				inx
.0190a9	e8		inx				inx
.0190aa	20 41 9a	jsr $019a41			jsr 	CheckNextComma
.0190ad	20 e5 93	jsr $0193e5			jsr 	EvaluateIntegerX 			; second is the data.
.0190b0	a5 80		lda $80				lda 	XS_Mantissa+0 				; copy the mantissa into ZLTemp1 (address)
.0190b2	85 1c		sta $1c				sta 	zLTemp1
.0190b4	a5 81		lda $81				lda 	XS_Mantissa+1
.0190b6	85 1d		sta $1d				sta 	zLTemp1+1
.0190b8	a5 82		lda $82				lda 	XS_Mantissa+2
.0190ba	85 1e		sta $1e				sta 	zLTemp1+2
.0190bc	a5 83		lda $83				lda 	XS_Mantissa+3
.0190be	85 1f		sta $1f				sta 	zLTemp1+3
.0190c0	68		pla				pla 								; get count
.0190c1	5a		phy				phy 								; save Y
.0190c2	20 cc 99	jsr $0199cc			jsr 	MemWrite 					; write it out
.0190c5	7a		ply				ply 								; restore Y and done.
.0190c6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/newold.asm

.0190c7					Command_NEW:
.0190c7	a9 00		lda #$00			lda 	#(BasicProgram) & $FF
.0190c9	85 18		sta $18				sta 	zCodePtr+0
.0190cb	a9 10		lda #$10			lda 	#(BasicProgram) >> 8
.0190cd	85 19		sta $19				sta 	zCodePtr+1
.0190cf	a9 00		lda #$00			lda 	#0
.0190d1	85 1a		sta $1a				sta 	zCodePtr+2
.0190d3	85 1b		sta $1b				sta 	zCodePtr+3
.0190d5	a0 03		ldy #$03			ldy 	#3
.0190d7	a0 00		ldy #$00			ldy 	#0
.0190d9	a9 00		lda #$00			lda 	#0 							; write a 0 there, null first offset
.0190db	97 18		sta [$18],y			sta 	[zCodePtr],y
.0190dd	20 dd 99	jsr $0199dd			jsr 	UpdateProgramEnd 			; update program end.
.0190e0	4c 47 88	jmp $018847			jmp 	WarmStart 					; and always warmstart, can't be running program.
.0190e3					Command_OLD:
.0190e3	a9 00		lda #$00			lda 	#(BasicProgram) & $FF
.0190e5	85 18		sta $18				sta 	zCodePtr+0
.0190e7	a9 10		lda #$10			lda 	#(BasicProgram) >> 8
.0190e9	85 19		sta $19				sta 	zCodePtr+1
.0190eb	a9 00		lda #$00			lda 	#0
.0190ed	85 1a		sta $1a				sta 	zCodePtr+2
.0190ef	85 1b		sta $1b				sta 	zCodePtr+3
.0190f1	a0 03		ldy #$03			ldy 	#3
.0190f3					_COL_Find:
.0190f3	b7 18		lda [$18],y			lda 	[zCodePtr],y
.0190f5	c8		iny				iny
.0190f6	c9 00		cmp #$00			cmp 	#0 							; if zero, then the position Y/Z is new offset
.0190f8	f0 18		beq $019112			beq 	_COL_Found
.0190fa	98		tya				tya
.0190fb	c9 00		cmp #$00			cmp 	#0 							; e.g. there is no program line end.
.0190fd	d0 f4		bne $0190f3			bne 	_COL_Find 					; can't find old EOL, give up.
.0190ff	20 86 85	jsr $018586			jsr ERR_Handler
>019102	50 72 6f 67 72 61 6d 20			.text "Program Corrupt",0
>01910a	43 6f 72 72 75 70 74 00
.019112					_COL_Found:
.019112	98		tya				tya
.019113	48		pha				pha
.019114	a0 00		ldy #$00			ldy 	#0
.019116	68		pla				pla
.019117	97 18		sta [$18],y			sta 	[zCodePtr],y
.019119	20 dd 99	jsr $0199dd			jsr 	UpdateProgramEnd 			; reset variable pointer
.01911c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/branch.asm

.01911d					Command_GOTO:
.01911d	20 72 91	jsr $019172			jsr 	GotoGetLineNumber 			; get line number
.019120					CmdGOTO:
.019120	a2 00		ldx #$00			ldx 	#0 							; go to that line number
.019122	4c 8f 91	jmp $01918f			jmp 	GotoChangeToLineNumberX
.019125					Command_GOSUB:
.019125	20 72 91	jsr $019172			jsr 	GotoGetLineNumber 			; get line number
.019128					CmdGOSUB:
.019128	20 06 85	jsr $018506			jsr 	StackSavePosition 			; save position on stack and push frame
.01912b	a9 15		lda #$15			lda 	#(SMark_Gosub << 4)+SourcePosSize
.01912d	20 bf 84	jsr $0184bf			jsr 	StackPushFrame
.019130	a2 00		ldx #$00			ldx		#0 							; go to that line number
.019132	4c 8f 91	jmp $01918f			jmp 	GotoChangeToLineNumberX
.019135					Command_RETURN:
.019135	a9 10		lda #$10			lda 	#(SMark_Gosub << 4) 		; pop frame
.019137	20 d6 84	jsr $0184d6			jsr 	StackPopFrame
.01913a	20 23 85	jsr $018523			jsr 	StackRestorePosition 		; restore position.
.01913d	60		rts				rts
.01913e					Command_ON:
.01913e	a2 00		ldx #$00			ldx 	#0 							; get the ON value into mantissa.0
.019140	20 8f 98	jsr $01988f			jsr 	SLIByteParameter
.019143	a5 80		lda $80				lda 	XS_Mantissa+0 				; get the count
.019145	f0 28		beq $01916f			beq 	_CONFail 					; can't be zero, error if it is.
.019147	aa		tax				tax 								; save in X.
.019148	b7 18		lda [$18],y			lda 	[zCodePtr],y
.01914a	c8		iny				iny
.01914b	48		pha				pha 								; so we can check what we're doing later.
.01914c	c9 cc		cmp #$cc			cmp 	#token_GOTO 				; must be GOTO or GOSUB
.01914e	f0 07		beq $019157			beq 	_CONOkayToken
.019150	c9 ca		cmp #$ca			cmp 	#token_GOSUB
.019152	f0 03		beq $019157			beq 	_CONOkayToken
.019154	4c 57 85	jmp $018557			jmp 	SyntaxError
.019157					_CONOkayToken:
.019157	da		phx				phx 								; count on top, GOTO/GOSUB token 2nd.
.019158					_CONFindNumber:
.019158	20 72 91	jsr $019172			jsr 	GotoGetLineNumber 			; get a line number.
.01915b	fa		plx				plx 								; restore count
.01915c	ca		dex				dex  								; decrement, exit if zero.
.01915d	f0 06		beq $019165			beq 	_CONFound
.01915f	da		phx				phx 								; push back
.019160	20 41 9a	jsr $019a41			jsr 	CheckNextComma				; check for comma
.019163	80 f3		bra $019158			bra 	_CONFindNumber 				; go round again.
.019165					_CONFound:
.019165	68		pla				pla 								; get token to decide what to do
.019166	c9 cc		cmp #$cc			cmp 	#token_GOTO 				; if GOTO
.019168	f0 b6		beq $019120			beq		CmdGOTO 					; then just branch.
.01916a	20 8d 84	jsr $01848d			jsr 	SkipEndOfCommand 			; go to end of command
.01916d	80 b9		bra $019128			bra 	CmdGOSUB 					; and do a GOSUB.
.01916f					_CONFail:
.01916f	4c 75 85	jmp $018575			jmp 	BadParamError
.019172					GotoGetLineNumber:
.019172	20 e3 93	jsr $0193e3			jsr 	EvaluateInteger 			; get integer into mantissa.0
.019175	a5 82		lda $82				lda 	XS_Mantissa+2 				; check range
.019177	05 83		ora $83				ora 	XS_Mantissa+3 				; check it is 0-32767
.019179	d0 01		bne $01917c			bne 	_GLINError
.01917b	60		rts				rts
.01917c					_GLINError:
.01917c	20 86 85	jsr $018586			jsr ERR_Handler
>01917f	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>019187	20 4e 75 6d 62 65 72 00
.01918f					GotoChangeToLineNumberX:
.01918f	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check line number not zero
.019191	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019193	f0 37		beq $0191cc			beq 	_GCTLFail 					; if so, no can do.
.019195	a9 00		lda #$00			lda 	#(BasicProgram) & $FF
.019197	85 18		sta $18				sta 	zCodePtr+0
.019199	a9 10		lda #$10			lda 	#(BasicProgram) >> 8
.01919b	85 19		sta $19				sta 	zCodePtr+1
.01919d	a9 00		lda #$00			lda 	#0
.01919f	85 1a		sta $1a				sta 	zCodePtr+2
.0191a1	85 1b		sta $1b				sta 	zCodePtr+3
.0191a3	a0 03		ldy #$03			ldy 	#3
.0191a5					_GCTLLoop:
.0191a5	a0 00		ldy #$00			ldy 	#0
.0191a7	b7 18		lda [$18],y			lda 	[zCodePtr],y
.0191a9	c9 00		cmp #$00			cmp 	#0
.0191ab	f0 1f		beq $0191cc			beq 	_GCTLFail
.0191ad	c8		iny				iny
.0191ae	b7 18		lda [$18],y			lda 	[zCodePtr],y
.0191b0	d5 80		cmp $80,x			cmp 	XS_Mantissa+0,x
.0191b2	d0 07		bne $0191bb			bne 	_GCTLNext
.0191b4	c8		iny				iny
.0191b5	b7 18		lda [$18],y			lda 	[zCodePtr],y
.0191b7	d5 81		cmp $81,x			cmp 	XS_Mantissa+1,x
.0191b9	f0 0f		beq $0191ca			beq 	_GCTLExit
.0191bb					_GCTLNext:
.0191bb	a0 00		ldy #$00			ldy 	#0 							; point to offset
.0191bd	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read it
.0191bf	18		clc				clc
.0191c0	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.0191c2	85 18		sta $18				sta 	zCodePtr
.0191c4	90 02		bcc $0191c8			bcc 	_SNLNoCarry
.0191c6	e6 19		inc $19				inc 	zCodePtr+1
.0191c8					_SNLNoCarry:
.0191c8	80 db		bra $0191a5			bra 	_GCTLLoop 					; try next line.
.0191ca					_GCTLExit:
.0191ca	c8		iny				iny
.0191cb	60		rts				rts
.0191cc					_GCTLFail:
.0191cc	20 86 85	jsr $018586			jsr ERR_Handler
>0191cf	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>0191d7	20 4e 75 6d 62 65 72 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.0191df					Command_CLR:
.0191df					ResetRunStatus:
.0191df	20 3a 9d	jsr $019d3a			jsr 	VariableClear
.0191e2	20 ad 84	jsr $0184ad			jsr 	StackReset
.0191e5	a9 00		lda #$00			lda 	#HighMemory & $FF
.0191e7	8d 00 03	sta $0300			sta 	StringPtr
.0191ea	a9 7f		lda #$7f			lda 	#HighMemory >> 8
.0191ec	8d 01 03	sta $0301			sta 	StringPtr+1
.0191ef	20 04 9f	jsr $019f04			jsr 	ArrayResetDefault
.0191f2	20 3c 8b	jsr $018b3c			jsr 	Command_RESTORE
.0191f5	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/stop.asm

.0191f6					Command_STOP:
.0191f6	20 86 85	jsr $018586			jsr ERR_Handler
>0191f9	53 74 6f 70 00				.text "Stop",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/while.asm

.0191fe					Command_WHILE:
.0191fe	20 06 85	jsr $018506			jsr 	StackSavePosition			; save position into stack, but don't yet push.
.019201	20 e3 93	jsr $0193e3			jsr 	EvaluateInteger 			; calculate the while loop value.
.019204	a5 80		lda $80				lda 	XS_Mantissa+0				; check the result if zero
.019206	05 81		ora $81				ora 	XS_Mantissa+1
.019208	05 82		ora $82				ora 	XS_Mantissa+2
.01920a	05 83		ora $83				ora 	XS_Mantissa+3
.01920c	f0 06		beq $019214			beq 	_CWHSkip 					; if it is zero, then skip to WEND.
.01920e	a9 35		lda #$35			lda 	#(SMark_While << 4)+SourcePosSize
.019210	20 bf 84	jsr $0184bf			jsr 	StackPushFrame 				; push on stack
.019213	60		rts				rts
.019214					_CWHSkip:
.019214	a9 95		lda #$95			lda 	#token_Wend 				; look for the WEND token.
.019216	20 00 84	jsr $018400			jsr 	StructureSearchSingle
.019219	c8		iny				iny
.01921a	60		rts				rts
.01921b					Command_WEND:
.01921b	a9 30		lda #$30			lda 	#(SMark_While << 4)			; remove the frame
.01921d	20 d6 84	jsr $0184d6			jsr 	StackPopFrame
.019220	20 23 85	jsr $018523			jsr 	StackRestorePosition
.019223	80 d9		bra $0191fe			bra 	Command_WHILE 				; and do the while again.
.019225	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/repeat.asm

.019226					Command_REPEAT:
.019226	20 06 85	jsr $018506			jsr 	StackSavePosition			; save position into stack
.019229	a9 25		lda #$25			lda 	#(SMark_Repeat << 4)+SourcePosSize
.01922b	20 bf 84	jsr $0184bf			jsr 	StackPushFrame 				; push on stack
.01922e	60		rts				rts
.01922f					Command_UNTIL:
.01922f	a9 20		lda #$20			lda 	#(SMark_Repeat << 4)		; remove the frame, checking it.
.019231	20 d6 84	jsr $0184d6			jsr 	StackPopFrame
.019234	20 e3 93	jsr $0193e3			jsr 	EvaluateInteger				; work out the UNTIL expression.
.019237	a5 80		lda $80				lda 	XS_Mantissa+0 				; check if zero.
.019239	05 81		ora $81				ora 	XS_Mantissa+1
.01923b	05 82		ora $82				ora 	XS_Mantissa+2
.01923d	05 83		ora $83				ora 	XS_Mantissa+3
.01923f	d0 08		bne $019249			bne 	_CUTExit 					; if not, just exit
.019241	20 23 85	jsr $018523			jsr 	StackRestorePosition 		; otherwise loop round again.
.019244	a9 25		lda #$25			lda 	#(SMark_Repeat << 4)+SourcePosSize
.019246	20 bf 84	jsr $0184bf			jsr 	StackPushFrame 				; fix the stack back so we can pop it again.
.019249					_CUTExit:
.019249	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.01924a					EVESyntax:
.01924a	4c 57 85	jmp $018557			jmp 	SyntaxError
.01924d					EvaluateExpression:
.01924d	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.01924f					EvaluateExpressionX:
.01924f	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.019251					EvaluateExpressionXA:
.019251	48		pha				pha 								; save precedence on stack.
.019252	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019254	f0 f4		beq $01924a			beq 	EVESyntax 					; end of line, syntax error.
.019256	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.019258	b0 03		bcs $01925d			bcs 	_EVNotVariable
.01925a	4c 27 93	jmp $019327			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.01925d					_EVNotVariable:
.01925d	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.01925f	90 e9		bcc $01924a			bcc 	EVESyntax
.019261	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.019263	b0 58		bcs $0192bd			bcs 	_EVNotInteger
.019265	20 55 93	jsr $019355			jsr 	EvaluateGetInteger
.019268					_EVCheckDecimal:
.019268	b7 18		lda [$18],y			lda 	[zCodePtr],y
.01926a	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.01926c	d0 05		bne $019273			bne 	_EVGotAtom 					; no, get atom.
.01926e					_EVIsDecimal:
.01926e	20 7b 93	jsr $01937b			jsr 	EVGetDecimal 				; extend to the decimal part.
.019271	80 00		bra $019273			bra 	_EVGotAtom 					; and continue to got atom.
.019273					_EVGotAtom:
.019273	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019275	10 44		bpl $0192bb			bpl 	_EVExitDrop 				; must be a token.
.019277	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.019279	b0 40		bcs $0192bb			bcs 	_EVExitDrop
.01927b	68		pla				pla 								; get current precedence
.01927c	85 20		sta $20				sta 	zGenPtr 					; save in zGenPtr as temp.
.01927e	da		phx				phx 								; save X
.01927f	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019281	aa		tax				tax 								; put in X
.019282	bf 40 86 01	lda $018640,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.019286	85 21		sta $21				sta 	zGenPtr+1 					; save it.
.019288	fa		plx				plx 								; restore X
.019289	c5 20		cmp $20				cmp 	zGenPtr 					; compared against the current precedence
.01928b	90 2f		bcc $0192bc			bcc 	_EVExit 					; exit if too low.
.01928d	f0 2d		beq $0192bc			beq 	_EVExit 					; exit if equals
.01928f	a5 20		lda $20				lda 	zGenPtr 					; push precedence
.019291	48		pha				pha
.019292	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019294	48		pha				pha
.019295	c8		iny				iny
.019296	da		phx				phx 								; save current position
.019297	e8		inx				inx
.019298	e8		inx				inx
.019299	e8		inx				inx
.01929a	e8		inx				inx
.01929b	e8		inx				inx
.01929c	e8		inx				inx
.01929d	a5 21		lda $21				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.01929f	20 51 92	jsr $019251			jsr 	EvaluateExpressionXA 		; do the RHS.
.0192a2	fa		plx				plx 								; restore X
.0192a3	68		pla				pla 								; get the binary operator in A.
.0192a4					_EVCallA:
.0192a4	da		phx				phx 								; save X again
.0192a5	0a		asl a				asl 	a 							; double, lose the MSB.
.0192a6	aa		tax				tax									; put in X
.0192a7	bf ef 85 01	lda $0185ef,x			lda 	VectorTable,x 				; copy address into zGenPtr
.0192ab	8d 11 03	sta $0311			sta 	LocalVector+1
.0192ae	bf f0 85 01	lda $0185f0,x			lda 	VectorTable+1,x
.0192b2	8d 12 03	sta $0312			sta 	LocalVector+2
.0192b5	fa		plx				plx 								; restore X
.0192b6	20 30 93	jsr $019330			jsr 	EVCallLocalVector
.0192b9	80 b8		bra $019273			bra 	_EVGotAtom 					; and loop back.
.0192bb					_EVExitDrop:
.0192bb	68		pla				pla
.0192bc					_EVExit:
.0192bc	60		rts				rts
.0192bd					_EVNotInteger:
.0192bd	c8		iny				iny
.0192be	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.0192c0	d0 16		bne $0192d8			bne 	_EVNotMinus
.0192c2	20 c4 93	jsr $0193c4			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.0192c5	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.0192c7	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.0192c9	f0 05		beq $0192d0			beq 	_EVMinusFloat
.0192cb	20 c3 a1	jsr $01a1c3			jsr 	IntegerNegateAlways 		; negation
.0192ce	80 a3		bra $019273			bra 	_EVGotAtom 					; and go back.
.0192d0					_EVMinusFloat:
.0192d0	b5 85		lda $85,x			lda 	XS_Type,x 					; invert the sign bit.
.0192d2	49 80		eor #$80			eor 	#$80
.0192d4	95 85		sta $85,x			sta 	XS_Type,x
.0192d6	80 9b		bra $019273			bra 	_EVGotAtom
.0192d8					_EVNotMinus:
.0192d8	c9 bd		cmp #$bd			cmp 	#token_lparen 				; is it left parenthesis
.0192da	d0 17		bne $0192f3			bne 	_EVNotParenthesis
.0192dc	20 4f 92	jsr $01924f			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.0192df	b7 18		lda [$18],y			lda 	[zCodePtr],y
.0192e1	c8		iny				iny
.0192e2	c9 be		cmp #$be			cmp 	#token_rparen 				; okay if right bracket.
.0192e4	f0 8d		beq $019273			beq 	_EVGotAtom
.0192e6	20 86 85	jsr $018586			jsr ERR_Handler
>0192e9	4d 69 73 73 69 6e 67 20			.text "Missing )",0
>0192f1	29 00
.0192f3					_EVNotParenthesis:
.0192f3	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.0192f5	d0 0c		bne $019303			bne 	_EVNotNot
.0192f7	20 c4 93	jsr $0193c4			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.0192fa	20 5b a6	jsr $01a65b			jsr 	FPUToInteger 				; make it an integer - if possible.
.0192fd	20 a9 93	jsr $0193a9			jsr 	NotInteger 					; do the not calculation
.019300	4c 73 92	jmp $019273			jmp 	_EVGotAtom
.019303					_EVNotNot:
.019303	c9 fe		cmp #$fe			cmp 	#$FE
.019305	d0 12		bne $019319			bne 	_EVNotString
.019307	20 c1 9a	jsr $019ac1			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.01930a	a5 22		lda $22				lda 	zTempStr 					; copy address of string into mantissa
.01930c	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01930e	a5 23		lda $23				lda 	zTempStr+1
.019310	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019312	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.019314	95 85		sta $85,x			sta 	XS_Type,x
.019316	4c 73 92	jmp $019273			jmp 	_EVGotAtom
.019319					_EVNotString:
.019319	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.01931b	90 04		bcc $019321			bcc 	_EVBadElement
.01931d	c9 b7		cmp #$b7			cmp 	#lastUnaryFunction+1
.01931f	90 03		bcc $019324			bcc 	_EVUnaryFunction
.019321					_EVBadElement:
.019321	4c 57 85	jmp $018557			jmp 	SyntaxError
.019324					_EVUnaryFunction:
.019324	4c a4 92	jmp $0192a4			jmp 	_EVCallA
.019327					_EVVariableHandler:
.019327	20 fe 9c	jsr $019cfe			jsr 	VariableFind 				; locate a variable
.01932a	20 46 a0	jsr $01a046			jsr 	VariableGet 				; copy into memory.
.01932d	4c 73 92	jmp $019273			jmp 	_EVGotAtom 					; and go round.
.019330					EVCallLocalVector:
.019330	6c 11 03	jmp ($0311)			jmp 	(LocalVector+1)
.019333					EVShiftMantissaLeft6:
.019333	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.019335	95 84		sta $84,x			sta 	XS_Exponent,x
.019337	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019339	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01933b	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01933d	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01933f	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019341	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019343	a9 00		lda #$00			lda 	#0
.019345	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019347	20 4a 93	jsr $01934a			jsr 	_EVSMLShift 					; call it here to do it twice
.01934a					_EVSMLShift:
.01934a	56 84		lsr $84,x			lsr 	XS_Exponent,x
.01934c	76 83		ror $83,x			ror 	XS_Mantissa+3,x
.01934e	76 82		ror $82,x			ror 	XS_Mantissa+2,x
.019350	76 81		ror $81,x			ror 	XS_Mantissa+1,x
.019352	76 80		ror $80,x			ror 	XS_Mantissa+0,x
.019354	60		rts				rts
.019355					EvaluateGetInteger:
.019355	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019357	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.019359	95 80		sta $80,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.01935b	a9 00		lda #$00			lda 	#0
.01935d	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01935f	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019361	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019363	1a		inc a				inc 	a 							; set to type 1 (integer)
.019364	95 85		sta $85,x			sta 	XS_Type,x
.019366					_EVCheckNextInteger:
.019366	c8		iny				iny
.019367	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019369	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.01936b	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.01936d	b0 0b		bcs $01937a			bcs 	_EVEndInteger
.01936f	48		pha				pha 								; save it.
.019370	20 33 93	jsr $019333			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.019373	68		pla				pla
.019374	15 80		ora $80,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.019376	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019378	80 ec		bra $019366			bra 	_EVCheckNextInteger
.01937a					_EVEndInteger:
.01937a	60		rts				rts
.01937b					EVGetDecimal:
.01937b	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.01937d	8d 15 03	sta $0315			sta 	Num_Buffer
.019380	da		phx				phx
.019381	c8		iny				iny
.019382	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019384	c8		iny				iny
.019385	3a		dec a				dec 	a								; convert to a string length.
.019386	3a		dec a				dec 	a
.019387	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.019389					_EVGDCopy:
.019389	48		pha				pha 									; save count
.01938a	b7 18		lda [$18],y			lda 	[zCodePtr],y
.01938c	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.01938f	e8		inx				inx 									; forward ....
.019390	c8		iny				iny
.019391	68		pla				pla 									; get count
.019392	3a		dec a				dec 	a 								; until zero
.019393	d0 f4		bne $019389			bne 	_EVGDCopy
.019395	9d 15 03	sta $0315,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.019398	fa		plx				plx 									; restore X
.019399	a9 15		lda #$15			lda 	#Num_Buffer & $FF 				; set zGenPtr
.01939b	85 20		sta $20				sta 	zGenPtr
.01939d	a9 03		lda #$03			lda 	#Num_Buffer >> 8
.01939f	85 21		sta $21				sta 	zGenPtr+1
.0193a1	5a		phy				phy 									; save Y
.0193a2	a0 00		ldy #$00			ldy 	#0 								; start position
.0193a4	20 15 a8	jsr $01a815			jsr 	FPFromString 					; convert current
.0193a7	7a		ply				ply 									; restore Y
.0193a8	60		rts				rts
.0193a9					NotInteger:
.0193a9	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0193ab	49 ff		eor #$ff			eor 	#$FF
.0193ad	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0193af	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0193b1	49 ff		eor #$ff			eor 	#$FF
.0193b3	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0193b5	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0193b7	49 ff		eor #$ff			eor 	#$FF
.0193b9	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0193bb	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.0193bd	49 ff		eor #$ff			eor 	#$FF
.0193bf	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0193c1	60		rts				rts
.0193c2					EvaluateGetAtom:
.0193c2	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.0193c4					EvaluateGetAtomX:
.0193c4	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.0193c6	20 51 92	jsr $019251			jsr 	EvaluateExpressionXA
.0193c9	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.0193cb	29 0f		and #$0f			and 	#15
.0193cd	c9 02		cmp #$02			cmp 	#2
.0193cf	b0 01		bcs $0193d2			bcs 	EvaluateType
.0193d1	60		rts				rts
.0193d2					EvaluateType:
.0193d2	4c 67 85	jmp $018567			jmp 	TypeError
.0193d5					EvaluateNumber:
.0193d5	a2 00		ldx #$00			ldx 	#0
.0193d7					EvaluateNumberX:
.0193d7	20 4f 92	jsr $01924f			jsr 	EvaluateExpressionX
.0193da	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0/1
.0193dc	29 0f		and #$0f			and 	#15
.0193de	c9 02		cmp #$02			cmp 	#2
.0193e0	b0 f0		bcs $0193d2			bcs 	EvaluateType
.0193e2	60		rts				rts
.0193e3					EvaluateInteger:
.0193e3	a2 00		ldx #$00			ldx 	#0
.0193e5					EvaluateIntegerX:
.0193e5	20 d7 93	jsr $0193d7			jsr 	EvaluateNumberX
.0193e8	20 5b a6	jsr $01a65b			jsr 	FPUToInteger
.0193eb	60		rts				rts
.0193ec					EvaluateString:
.0193ec	a2 00		ldx #$00			ldx 	#0
.0193ee					EvaluateStringX:
.0193ee	20 4f 92	jsr $01924f			jsr 	EvaluateExpressionX
.0193f1	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 2
.0193f3	29 0f		and #$0f			and 	#15
.0193f5	c9 02		cmp #$02			cmp 	#2
.0193f7	d0 d9		bne $0193d2			bne 	EvaluateType
.0193f9	b5 80		lda $80,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.0193fb	85 20		sta $20				sta 	zGenPtr
.0193fd	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0193ff	85 21		sta $21				sta 	zGenPtr+1
.019401	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.019402					BinaryOp_And:
.019402	20 56 94	jsr $019456			jsr 	BinaryMakeBothInteger
.019405	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.019407	35 86		and $86,x			and 	XS2_Mantissa+0,x
.019409	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01940b	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.01940d	35 87		and $87,x			and 	XS2_Mantissa+1,x
.01940f	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019411	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.019413	35 88		and $88,x			and 	XS2_Mantissa+2,x
.019415	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019417	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.019419	35 89		and $89,x			and 	XS2_Mantissa+3,x
.01941b	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01941d	60		rts				rts
.01941e					BinaryOp_Or:
.01941e	20 56 94	jsr $019456			jsr 	BinaryMakeBothInteger
.019421	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.019423	15 86		ora $86,x			ora 	XS2_Mantissa+0,x
.019425	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019427	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.019429	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.01942b	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01942d	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.01942f	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.019431	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019433	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.019435	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.019437	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019439	60		rts				rts
.01943a					BinaryOp_Eor:
.01943a					BinaryOp_Xor:
.01943a	20 56 94	jsr $019456			jsr 	BinaryMakeBothInteger
.01943d	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.01943f	55 86		eor $86,x			eor 	XS2_Mantissa+0,x
.019441	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019443	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.019445	55 87		eor $87,x			eor 	XS2_Mantissa+1,x
.019447	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019449	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.01944b	55 88		eor $88,x			eor 	XS2_Mantissa+2,x
.01944d	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01944f	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.019451	55 89		eor $89,x			eor 	XS2_Mantissa+3,x
.019453	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019455	60		rts				rts
.019456					BinaryMakeBothInteger:
.019456	da		phx				phx 								; save X
.019457	e8		inx				inx
.019458	e8		inx				inx
.019459	e8		inx				inx
.01945a	e8		inx				inx
.01945b	e8		inx				inx
.01945c	e8		inx				inx
.01945d	20 61 94	jsr $019461			jsr 	BinaryMakeInteger 			; convert to integer.
.019460	fa		plx				plx 								; restore X and fall through.
.019461					BinaryMakeInteger:
.019461	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.019463	29 0f		and #$0f			and 	#15 						; check type zero
.019465	f0 04		beq $01946b			beq 	_BMIConvert 				; if float convert to integer.
.019467	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.019468	90 04		bcc $01946e			bcc 	_BMIError
.01946a	60		rts				rts
.01946b					_BMIConvert:
.01946b	4c 5b a6	jmp $01a65b			jmp 	FPUToInteger 				; convert to integer
.01946e					_BMIError:
.01946e	4c 67 85	jmp $018567			jmp 	TypeError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.019471					Binary_Equal:
.019471	20 ba 94	jsr $0194ba			jsr 	CompareValues 				; compare the values
.019474	09 00		ora #$00			ora 	#0 							; true if 0
.019476	f0 33		beq $0194ab			beq 	CCTrue
.019478	80 2d		bra $0194a7			bra 	CCFalse
.01947a					Binary_NotEqual:
.01947a	20 ba 94	jsr $0194ba			jsr 	CompareValues
.01947d	09 00		ora #$00			ora 	#0 							; true if -1 or 1
.01947f	f0 26		beq $0194a7			beq 	CCFalse
.019481	80 28		bra $0194ab			bra 	CCTrue
.019483					Binary_Less:
.019483	20 ba 94	jsr $0194ba			jsr 	CompareValues
.019486	09 00		ora #$00			ora 	#0 							; true if -1
.019488	30 21		bmi $0194ab			bmi 	CCTrue
.01948a	80 1b		bra $0194a7			bra 	CCFalse
.01948c					Binary_LessEqual:
.01948c	20 ba 94	jsr $0194ba			jsr 	CompareValues
.01948f	c9 01		cmp #$01			cmp 	#1 							; true if 0 or -1
.019491	d0 18		bne $0194ab			bne 	CCTrue
.019493	80 12		bra $0194a7			bra 	CCFalse
.019495					Binary_GreaterEqual:
.019495	20 ba 94	jsr $0194ba			jsr 	CompareValues
.019498	09 00		ora #$00			ora 	#0 							; true if 0 or 1
.01949a	10 0f		bpl $0194ab			bpl 	CCTrue
.01949c	80 09		bra $0194a7			bra 	CCFalse
.01949e					Binary_Greater:
.01949e	20 ba 94	jsr $0194ba			jsr 	CompareValues 				; true if 1
.0194a1	c9 01		cmp #$01			cmp 	#1
.0194a3	f0 06		beq $0194ab			beq 	CCTrue
.0194a5	80 00		bra $0194a7			bra 	CCFalse
.0194a7	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.0194a9	80 02		bra $0194ad			bra 	CCWrite
.0194ab	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.0194ad	95 80		sta $80,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.0194af	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0194b1	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0194b3	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0194b5	a9 01		lda #$01			lda 	#1
.0194b7	95 85		sta $85,x			sta 	XS_Type,x 					; set type to integer whatever.
.0194b9	60		rts				rts
.0194ba					CompareValues:
.0194ba	b5 85		lda $85,x			lda 	XS_Type,x 					; and the types together
.0194bc	35 8b		and $8b,x			and 	XS2_Type,x
.0194be	c9 02		cmp #$02			cmp 	#2 							; is it a string, then do the string
.0194c0	f0 11		beq $0194d3			beq 	_CVString					; comparison routine.
.0194c2	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.0194c4	35 8b		and $8b,x			and 	XS2_Type,x
.0194c6	4a		lsr a				lsr 	a 							; shift bit 0 into C
.0194c7	90 03		bcc $0194cc			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.0194c9	4c 15 95	jmp $019515			jmp 	CompareInteger32 							; so execute code at \1
.0194cc					_BCFloat:
.0194cc	20 b9 95	jsr $0195b9			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.0194cf	4c 54 a5	jmp $01a554			jmp 	FPCompare 							; and execute code at \2
.0194d2	60		rts				rts
.0194d3					_CVString:
.0194d3	da		phx				phx 								; save XY
.0194d4	5a		phy				phy
.0194d5	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.0194d7	85 1c		sta $1c				sta		zLTemp1+0
.0194d9	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0194db	85 1d		sta $1d				sta 	zLTemp1+1
.0194dd	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.0194df	85 1e		sta $1e				sta 	zLTemp1+2
.0194e1	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.0194e3	85 1f		sta $1f				sta 	zLTemp1+3
.0194e5	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.0194e7	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.0194e9	d1 1e		cmp ($1e),y			cmp 	(zLTemp1+2),y
.0194eb	90 02		bcc $0194ef			bcc 	_CVCommon
.0194ed	b1 1e		lda ($1e),y			lda 	(zLTemp1+2),y
.0194ef					_CVCommon:
.0194ef	aa		tax				tax 								; put shorter string length in zero.
.0194f0	f0 0c		beq $0194fe			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.0194f2					_CVCompare:
.0194f2	c8		iny				iny 								; next character
.0194f3	b1 1c		lda ($1c),y			lda 	(zLTemp1),y 				; compare characters
.0194f5	d1 1e		cmp ($1e),y			cmp 	(zLTemp1+2),y 				; handle different values, < or >
.0194f7	90 13		bcc $01950c			bcc 	_CVReturnLess 				; <
.0194f9	d0 15		bne $019510			bne 	_CVReturnGreater 			; >
.0194fb	ca		dex				dex 								; until common length matched.
.0194fc	d0 f4		bne $0194f2			bne 	_CVCompare
.0194fe					_CVMatch:
.0194fe	a0 00		ldy #$00			ldy 	#0
.019500	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.019502	d1 1e		cmp ($1e),y			cmp 	(zLTemp1+2),y
.019504	90 06		bcc $01950c			bcc 	_CVReturnLess 				; <
.019506	d0 08		bne $019510			bne 	_CVReturnGreater 			; >
.019508	a9 00		lda #$00			lda 	#0
.01950a	80 06		bra $019512			bra 	_CVExit
.01950c					_CVReturnLess:
.01950c	a9 ff		lda #$ff			lda 	#$FF
.01950e	80 02		bra $019512			bra 	_CVExit
.019510					_CVReturnGreater:
.019510	a9 01		lda #$01			lda 	#$01
.019512					_CVExit:
.019512	7a		ply				ply
.019513	fa		plx				plx
.019514	60		rts				rts
.019515					CompareInteger32:
.019515	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.019517	49 80		eor #$80			eor 	#$80
.019519	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01951b	b5 89		lda $89,x			lda 	XS2_Mantissa+3,x
.01951d	49 80		eor #$80			eor 	#$80
.01951f	95 89		sta $89,x			sta 	XS2_Mantissa+3,x
.019521	20 9f 95	jsr $01959f			jsr 	SubInteger32 				; subtraction
.019524	90 0d		bcc $019533			bcc 	_CI32Less 					; cc return -1
.019526	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check if zero
.019528	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.01952a	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01952c	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01952e	f0 02		beq $019532			beq 	_CI32Exit
.019530	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.019532					_CI32Exit:
.019532	60		rts				rts
.019533					_CI32Less:
.019533	a9 ff		lda #$ff			lda 	#$FF
.019535	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.019536					BinaryOp_Add:
.019536	b5 85		lda $85,x			lda 	XS_Type,x  					; and types together
.019538	35 8b		and $8b,x			and 	XS2_Type,x
.01953a	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.01953c	d0 11		bne $01954f			bne 	_BOAString 					; so go do the string code.
.01953e	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.019540	35 8b		and $8b,x			and 	XS2_Type,x
.019542	4a		lsr a				lsr 	a 							; shift bit 0 into C
.019543	90 03		bcc $019548			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.019545	4c 85 95	jmp $019585			jmp 	AddInteger32 							; so execute code at \1
.019548					_BCFloat:
.019548	20 b9 95	jsr $0195b9			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.01954b	4c 2f a3	jmp $01a32f			jmp 	FPAdd 							; and execute code at \2
.01954e	60		rts				rts
.01954f					_BOAString:
.01954f	4c d3 95	jmp $0195d3			jmp 	ConcatenateString 			; concatenate two strings.
.019552					BinaryOp_Subtract:
.019552	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.019554	35 8b		and $8b,x			and 	XS2_Type,x
.019556	4a		lsr a				lsr 	a 							; shift bit 0 into C
.019557	90 03		bcc $01955c			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.019559	4c 9f 95	jmp $01959f			jmp 	SubInteger32 							; so execute code at \1
.01955c					_BCFloat:
.01955c	20 b9 95	jsr $0195b9			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.01955f	4c 27 a3	jmp $01a327			jmp 	FPSubtract 							; and execute code at \2
.019562	60		rts				rts
.019563					BinaryOp_Multiply:
.019563	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.019565	35 8b		and $8b,x			and 	XS2_Type,x
.019567	4a		lsr a				lsr 	a 							; shift bit 0 into C
.019568	90 03		bcc $01956d			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.01956a	4c fe a0	jmp $01a0fe			jmp 	MulInteger32 							; so execute code at \1
.01956d					_BCFloat:
.01956d	20 b9 95	jsr $0195b9			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.019570	4c 56 a4	jmp $01a456			jmp 	FPMultiply 							; and execute code at \2
.019573	60		rts				rts
.019574					BinaryOp_Divide:
.019574	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.019576	35 8b		and $8b,x			and 	XS2_Type,x
.019578	4a		lsr a				lsr 	a 							; shift bit 0 into C
.019579	90 03		bcc $01957e			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.01957b	4c 3c a1	jmp $01a13c			jmp 	DivInteger32 							; so execute code at \1
.01957e					_BCFloat:
.01957e	20 b9 95	jsr $0195b9			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.019581	4c e3 a3	jmp $01a3e3			jmp 	FPDivide 							; and execute code at \2
.019584	60		rts				rts
.019585					AddInteger32:
.019585	18		clc				clc
.019586	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019588	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.01958a	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01958c	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01958e	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.019590	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019592	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019594	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.019596	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019598	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01959a	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.01959c	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01959e	60		rts				rts
.01959f					SubInteger32:
.01959f	38		sec				sec
.0195a0	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0195a2	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.0195a4	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0195a6	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0195a8	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.0195aa	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0195ac	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0195ae	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.0195b0	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0195b2	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.0195b4	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.0195b6	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0195b8	60		rts				rts
.0195b9					BinaryMakeBothFloat:
.0195b9	da		phx				phx 								; save X
.0195ba	e8		inx				inx
.0195bb	e8		inx				inx
.0195bc	e8		inx				inx
.0195bd	e8		inx				inx
.0195be	e8		inx				inx
.0195bf	e8		inx				inx
.0195c0	20 c4 95	jsr $0195c4			jsr 	BinaryMakeFloat 			; convert to float.
.0195c3	fa		plx				plx 								; restore X and fall through.
.0195c4					BinaryMakeFloat:
.0195c4	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.0195c6	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.0195c7	b0 04		bcs $0195cd			bcs 	_BMFConvert
.0195c9	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.0195ca	b0 04		bcs $0195d0			bcs 	_BMFError
.0195cc	60		rts				rts
.0195cd					_BMFConvert:
.0195cd	4c 0f a6	jmp $01a60f			jmp 	FPUToFloat 					; convert to float, only float builds of course
.0195d0					_BMFError:
.0195d0	4c 67 85	jmp $018567			jmp 	TypeError
.0195d3					ConcatenateString:
.0195d3	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.0195d5	85 1c		sta $1c				sta		zLTemp1+0
.0195d7	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0195d9	85 1d		sta $1d				sta 	zLTemp1+1
.0195db	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.0195dd	85 1e		sta $1e				sta 	zLTemp1+2
.0195df	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.0195e1	85 1f		sta $1f				sta 	zLTemp1+3
.0195e3	5a		phy				phy
.0195e4	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.0195e6	b1 1c		lda ($1c),y			lda 	(zlTemp1),y
.0195e8	71 1e		adc ($1e),y			adc 	(zlTemp1+2),y
.0195ea	7a		ply				ply
.0195eb	b0 33		bcs $019620			bcs 	_CSError					; check in range.
.0195ed	c9 fe		cmp #$fe			cmp 	#maxString+1
.0195ef	b0 2f		bcs $019620			bcs 	_CSError
.0195f1	20 86 9a	jsr $019a86			jsr 	AllocateTempString 			; store the result
.0195f4	20 0b 96	jsr $01960b			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.0195f7	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.0195f9	85 1c		sta $1c				sta 	zLTemp1
.0195fb	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.0195fd	85 1d		sta $1d				sta 	zLTemp1+1
.0195ff	20 0b 96	jsr $01960b			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.019602	a5 22		lda $22				lda 	zTempStr 					; point current to new string
.019604	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019606	a5 23		lda $23				lda 	zTempStr+1
.019608	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01960a	60		rts				rts
.01960b					_CSCopyString:
.01960b	da		phx				phx
.01960c	5a		phy				phy
.01960d	a0 00		ldy #$00			ldy 	#0 							; get length
.01960f	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.019611	f0 0a		beq $01961d			beq 	_CSCSExit 					; if zero, exit immediately
.019613	aa		tax				tax 								; put in X which is the counter.
.019614					_CSCSLoop:
.019614	c8		iny				iny 								; get next char
.019615	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.019617	20 b1 9a	jsr $019ab1			jsr		WriteTempString 			; copy out to new string
.01961a	ca		dex				dex 								; do whole string
.01961b	d0 f7		bne $019614			bne 	_CSCSLoop
.01961d					_CSCSExit:
.01961d	7a		ply				ply
.01961e	fa		plx				plx
.01961f	60		rts				rts
.019620					_CSError:
.019620	20 86 85	jsr $018586			jsr ERR_Handler
>019623	53 74 72 69 6e 67 20 74			.text "String too long",0
>01962b	6f 6f 20 6c 6f 6e 67 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.019633					Unary_Sgn:
.019633	20 d7 93	jsr $0193d7			jsr 	EvaluateNumberX 			; get value
.019636	20 39 9a	jsr $019a39			jsr 	CheckNextRParen 			; check right bracket.
.019639	20 57 96	jsr $019657			jsr 	GetSignCurrent 				; get sign.
.01963c	09 00		ora #$00			ora 	#0
.01963e	10 08		bpl $019648			bpl		UnarySetAInteger			; if 0,1 return that.
.019640	80 00		bra $019642			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.019642					UnarySetAMinus1:
.019642	a9 ff		lda #$ff			lda 	#$FF 						; put -1 in all four slots.
.019644	95 80		sta $80,x			sta 	XS_Mantissa,x
.019646	80 04		bra $01964c			bra 	UnarySetAFill
.019648					UnarySetAInteger:
.019648	95 80		sta $80,x			sta 	XS_Mantissa,x
.01964a	a9 00		lda #$00			lda 	#0
.01964c					UnarySetAFill:
.01964c	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01964e	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019650	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019652	a9 01		lda #$01			lda 	#1 							; set type to integer.
.019654	95 85		sta $85,x			sta 	XS_Type,x
.019656	60		rts				rts
.019657					GetSignCurrent:
.019657	b5 85		lda $85,x			lda 	XS_Type,x 					; identify type.
.019659	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.01965a	90 15		bcc $019671			bcc 	_GSCFloat 					; if clear do the float code.
.01965c	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; if msb of integer set, it's negative
.01965e	30 0e		bmi $01966e			bmi 	_GSCMinus1
.019660	15 80		ora $80,x			ora 	XS_Mantissa+0,x
.019662	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019664	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019666	d0 03		bne $01966b			bne 	_GSCPlus1 					; check if zero by oring all together.
.019668					_GSCZero:
.019668	a9 00		lda #$00			lda 	#0
.01966a	60		rts				rts
.01966b					_GSCPlus1:
.01966b	a9 01		lda #$01			lda 	#$01
.01966d	60		rts				rts
.01966e					_GSCMinus1:
.01966e	a9 ff		lda #$ff			lda 	#$FF
.019670	60		rts				rts
.019671					_GSCFloat:
.019671	34 85		bit $85,x			bit 	XS_Type,x 					; check bits
.019673	70 f3		bvs $019668			bvs 	_GSCZero 					; if zero flag set return zero
.019675	30 f7		bmi $01966e			bmi 	_GSCMinus1 					; if sign set return -1
.019677	80 f2		bra $01966b			bra 	_GSCPlus1		 			; else return +1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.019679					Unary_Abs:
.019679	20 d7 93	jsr $0193d7			jsr 	EvaluateNumberX 			; get value
.01967c	20 39 9a	jsr $019a39			jsr 	CheckNextRParen 			; check right bracket.
.01967f	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.019681	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.019683	f0 07		beq $01968c			beq 	_UAMinusFloat
.019685	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; check MSB of upper byte to see if negative
.019687	10 09		bpl $019692			bpl 	_UAExit
.019689	4c c3 a1	jmp $01a1c3			jmp 	IntegerNegateAlways 		; if so negate it.
.01968c					_UAMinusFloat:
.01968c	b5 85		lda $85,x			lda 	XS_Type,x 					; clear the sign bit.
.01968e	29 7f		and #$7f			and		#$7F
.019690	95 85		sta $85,x			sta 	XS_Type,x
.019692					_UAExit:
.019692	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.019693					Unary_Peek:
.019693	a9 01		lda #$01			lda 	#1 							; 1 byte
.019695	80 06		bra $01969d			bra 	UPMain
.019697					Unary_Deek:
.019697	a9 02		lda #$02			lda 	#2 							; 2 bytes
.019699	80 02		bra $01969d			bra 	UPMain
.01969b					Unary_Leek:
.01969b	a9 04		lda #$04			lda 	#4 							; 4 bytes
.01969d					UPMain:
.01969d	48		pha				pha 								; save bytes to copy.
.01969e	20 e5 93	jsr $0193e5			jsr 	EvaluateIntegerX 			; numeric parameter, the address to xEEK
.0196a1	20 39 9a	jsr $019a39			jsr 	CheckNextRParen 			; right bracket.
.0196a4	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.0196a6	85 1c		sta $1c				sta 	zLTemp1
.0196a8	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0196aa	85 1d		sta $1d				sta 	zLTemp1+1
.0196ac	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0196ae	85 1e		sta $1e				sta 	zLTemp1+2
.0196b0	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.0196b2	85 1f		sta $1f				sta 	zLTemp1+3
.0196b4	a9 00		lda #$00			lda 	#0 							; clear target area, which might get
.0196b6	95 80		sta $80,x			sta 	XS_Mantissa+0,x 			; 1,2 or 4 bytes.
.0196b8	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0196ba	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0196bc	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0196be	68		pla				pla 								; restore bytes to copy
.0196bf	da		phx				phx 								; save XY
.0196c0	5a		phy				phy
.0196c1	20 bb 99	jsr $0199bb			jsr 	MemRead 					; read the bytes in, processor dependent routine.
.0196c4	7a		ply				ply 								; restore and exit
.0196c5	fa		plx				plx
.0196c6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/pos.asm

.0196c7					Unary_Pos:
.0196c7	20 d7 93	jsr $0193d7			jsr 	EvaluateNumberX 			; get value, which is a dummy.
.0196ca	20 39 9a	jsr $019a39			jsr 	CheckNextRParen 			; check right bracket.
.0196cd	20 50 85	jsr $018550			jsr 	VIOCharGetPosition 			; get the position
.0196d0	4c 48 96	jmp $019648			jmp		UnarySetAInteger			; and return that.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.0196d3					Unary_Mod:
.0196d3	20 fb 96	jsr $0196fb			jsr 	_UMParameter 				; first parameter, get |param|
.0196d6	20 41 9a	jsr $019a41			jsr 	CheckNextComma
.0196d9	da		phx				phx 								; second parameter, get |param|
.0196da	e8		inx				inx
.0196db	e8		inx				inx
.0196dc	e8		inx				inx
.0196dd	e8		inx				inx
.0196de	e8		inx				inx
.0196df	e8		inx				inx
.0196e0	20 fb 96	jsr $0196fb			jsr 	_UMParameter
.0196e3	fa		plx				plx
.0196e4	20 39 9a	jsr $019a39			jsr 	CheckNextRParen
.0196e7	20 3c a1	jsr $01a13c			jsr 	DivInteger32 				; divide, which handily leaves ....
.0196ea	a5 1c		lda $1c				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.0196ec	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0196ee	a5 1d		lda $1d				lda 	zLTemp1+1
.0196f0	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0196f2	a5 1e		lda $1e				lda 	zLTemp1+2
.0196f4	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0196f6	a5 1f		lda $1f				lda 	zLTemp1+3
.0196f8	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0196fa	60		rts				rts
.0196fb					_UMParameter:
.0196fb	20 e5 93	jsr $0193e5			jsr 	EvaluateIntegerX 			; get value
.0196fe	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; absolute value
.019700	10 03		bpl $019705			bpl 	_UMNotSigned
.019702	20 c3 a1	jsr $01a1c3			jsr 	IntegerNegateAlways
.019705					_UMNotSigned:
.019705	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.019706					Unary_Usr:
.019706	20 d7 93	jsr $0193d7			jsr 	EvaluateNumberX 			; numeric parameter
.019709	20 39 9a	jsr $019a39			jsr 	CheckNextRParen 			; right bracket.
.01970c	da		phx				phx 								; save XY
.01970d	5a		phy				phy
.01970e	22 0c 03 00	jsl $00030c			jsl 	UserVector 					; with the parameter in the base mantissa
.019712	7a		ply				ply 								; restore YX and exit with whatever the
.019713	fa		plx				plx 								; routine called has chosen to do with it.
.019714	60		rts				rts
.019715					USRDefault:
.019715	20 86 85	jsr $018586			jsr ERR_Handler
>019718	4e 6f 20 55 53 52 20 76			.text "No USR vector.",0
>019720	65 63 74 6f 72 2e 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.019727					Unary_Val:
.019727	20 ee 93	jsr $0193ee			jsr 	EvaluateStringX 			; get string
.01972a	20 39 9a	jsr $019a39			jsr 	CheckNextRParen 			; check right bracket.
.01972d	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.01972f	85 20		sta $20				sta 	zGenPtr
.019731	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019733	85 21		sta $21				sta 	zGenPtr+1
.019735	da		phx				phx
.019736	5a		phy				phy
.019737	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.019739	b1 20		lda ($20),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.01973b	f0 1b		beq $019758			beq 	UVBadNumber
.01973d	aa		tax				tax
.01973e					_UVCopy1:
.01973e	c8		iny				iny
.01973f	c0 18		cpy #$18			cpy 	#24 						; too long
.019741	f0 15		beq $019758			beq 	UVBadNumber
.019743	b1 20		lda ($20),y			lda 	(zGenPtr),y					; copy character
.019745	99 14 03	sta $0314,y			sta 	Num_Buffer-1,y
.019748	a9 00		lda #$00			lda 	#0 							; make string ASCIIZ.
.01974a	99 15 03	sta $0315,y			sta 	Num_Buffer,y
.01974d	ca		dex				dex
.01974e	d0 ee		bne $01973e			bne 	_UVCopy1
.019750	7a		ply				ply
.019751	fa		plx				plx
.019752	20 66 97	jsr $019766			jsr 	ConvertNumBuffer 			; convert string in NumBuffer to mantissa,x
.019755	b0 01		bcs $019758			bcs 	UVBadNumber
.019757	60		rts				rts
.019758					UVBadNumber:
.019758	20 86 85	jsr $018586			jsr ERR_Handler
>01975b	42 61 64 20 4e 75 6d 62			.text "Bad Number",0
>019763	65 72 00
.019766					ConvertNumBuffer:
.019766	5a		phy				phy
.019767	a9 15		lda #$15			lda 	#Num_Buffer & $FF 			; set zGenPtr to point to buffer.
.019769	85 20		sta $20				sta 	zGenPtr
.01976b	a9 03		lda #$03			lda 	#Num_Buffer >> 8
.01976d	85 21		sta $21				sta 	zGenPtr+1
.01976f	ad 15 03	lda $0315			lda 	Num_Buffer 					; first character is - ?
.019772	c9 2d		cmp #$2d			cmp 	#"-"
.019774	d0 02		bne $019778			bne 	_UVNotMinus1
.019776	e6 20		inc $20				inc 	zGenPtr 					; this time just fix the pointer.
.019778					_UVNotMinus1:
.019778	20 95 a2	jsr $01a295			jsr 	IntFromString 				; get integer
.01977b	b0 22		bcs $01979f			bcs 	_UVFail
.01977d	20 15 a8	jsr $01a815			jsr 	FPFromString 				; possibly float it.
.019780	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; done the whole string
.019782	d0 1b		bne $01979f			bne 	_UVFail 					; no, exit.
.019784	ad 15 03	lda $0315			lda 	Num_Buffer 					; look at numbuffer
.019787	c9 2d		cmp #$2d			cmp 	#"-"
.019789	d0 11		bne $01979c			bne 	_UVNotMinus2
.01978b	b5 85		lda $85,x			lda 	XS_Type,x 					; type is float ?
.01978d	29 0f		and #$0f			and 	#$0F
.01978f	f0 05		beq $019796			beq 	_UVNegateFloat
.019791	20 c3 a1	jsr $01a1c3			jsr 	IntegerNegateAlways
.019794	80 06		bra $01979c			bra 	_UVNotMinus2
.019796					_UVNegateFloat:
.019796	b5 85		lda $85,x			lda 	XS_Type,x 					; set the sign bit.
.019798	09 80		ora #$80			ora 	#$80
.01979a	95 85		sta $85,x			sta 	XS_Type,x
.01979c					_UVNotMinus2:
.01979c	7a		ply				ply
.01979d	18		clc				clc
.01979e	60		rts				rts
.01979f	7a		ply		_UVFail:ply
.0197a0	38		sec				sec
.0197a1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.0197a2					Unary_Str:
.0197a2	20 d7 93	jsr $0193d7			jsr 	EvaluateNumberX 			; numeric parameter
.0197a5	20 39 9a	jsr $019a39			jsr 	CheckNextRParen 			; right bracket.
.0197a8	a9 00		lda #$00			lda 	#0 							; reset buffer index
.0197aa	8d 14 03	sta $0314			sta 	NumBufX
.0197ad	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.0197af	4a		lsr a				lsr 	a 							; bit 0 identifies an integer.
.0197b0	b0 05		bcs $0197b7			bcs 	_USInt 						; if msb set do as integer
.0197b2	20 5a a7	jsr $01a75a			jsr 	FPToString 					; call fp to str otherwise
.0197b5	80 03		bra $0197ba			bra 	_USDuplicate
.0197b7	20 e0 a1	jsr $01a1e0	_USInt:	jsr 	IntToString					; call int to str.
.0197ba					_USDuplicate:
.0197ba	ad 14 03	lda $0314			lda 	NumBufX 					; chars in buffer
.0197bd	1a		inc a				inc 	a 							; one more for length
.0197be	20 86 9a	jsr $019a86			jsr 	AllocateTempString 			; allocate space for it.
.0197c1	5a		phy				phy 								; save Y
.0197c2	a0 00		ldy #$00			ldy 	#0 							; start copying
.0197c4	b9 15 03	lda $0315,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.0197c7	20 b1 9a	jsr $019ab1			jsr 	WriteTempString
.0197ca	c8		iny				iny
.0197cb	cc 14 03	cpy $0314			cpy 	NumBufX 					; done the lot
.0197ce	d0 f4		bne $0197c4			bne 	_USCopy
.0197d0	7a		ply				ply 								; restore Y
.0197d1	4c ae 99	jmp $0199ae			jmp 	UnaryReturnTempStr 			; return newly created temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.0197d4					Unary_Asc:
.0197d4	20 ee 93	jsr $0193ee			jsr 	EvaluateStringX 			; string parameter
.0197d7	20 39 9a	jsr $019a39			jsr 	CheckNextRParen 			; right bracket.
.0197da	5a		phy				phy 								; get the string length
.0197db	a0 00		ldy #$00			ldy 	#0
.0197dd	b1 20		lda ($20),y			lda 	(zGenPtr),y
.0197df	f0 07		beq $0197e8			beq 	_UAIllegal 					; must be at least one character, 0 => error
.0197e1	c8		iny				iny
.0197e2	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; read the first character
.0197e4	7a		ply				ply
.0197e5	4c 48 96	jmp $019648			jmp 	UnarySetAInteger 			; return that as an integer 0-255.
.0197e8					_UAIllegal:
.0197e8	4c 75 85	jmp $018575			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.0197eb					Unary_Len:
.0197eb	20 ee 93	jsr $0193ee			jsr 	EvaluateStringX 			; string parameter
.0197ee	20 39 9a	jsr $019a39			jsr 	CheckNextRParen 			; right bracket.
.0197f1	5a		phy				phy 								; get the string length
.0197f2	a0 00		ldy #$00			ldy 	#0
.0197f4	b1 20		lda ($20),y			lda 	(zGenPtr),y
.0197f6	7a		ply				ply
.0197f7	4c 48 96	jmp $019648			jmp 	UnarySetAInteger 			; return as an integer.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.0197fa					Unary_Mid:
.0197fa	20 ee 93	jsr $0193ee			jsr 	EvaluateStringX 				; get string.
.0197fd	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.0197ff	48		pha				pha
.019800	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019802	48		pha				pha
.019803	20 41 9a	jsr $019a41			jsr 	CheckNextComma 					; skip comma
.019806	20 8f 98	jsr $01988f			jsr 	SLIByteParameter 				; get a byte parameter (start)
.019809	48		pha				pha 									; and push it.
.01980a	20 41 9a	jsr $019a41			jsr 	CheckNextComma 					; skip comma
.01980d	20 8f 98	jsr $01988f			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.019810	48		pha				pha 									; and push it.
.019811	80 41		bra $019854			bra 	SLIProcess
.019813					Unary_Left:
.019813	20 ee 93	jsr $0193ee			jsr 	EvaluateStringX 				; get string.
.019816	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.019818	48		pha				pha
.019819	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01981b	48		pha				pha
.01981c	a9 01		lda #$01			lda 	#1 								; push start position (1)
.01981e	48		pha				pha
.01981f	20 41 9a	jsr $019a41			jsr 	CheckNextComma 					; skip comma
.019822	20 8f 98	jsr $01988f			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.019825	48		pha				pha 									; and push it.
.019826	80 2c		bra $019854			bra 	SLIProcess
.019828					Unary_Right:
.019828	20 ee 93	jsr $0193ee			jsr 	EvaluateStringX 				; get string.
.01982b	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.01982d	48		pha				pha
.01982e	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019830	48		pha				pha
.019831	da		phx				phx 									; get the string length and push on stack.
.019832	a2 00		ldx #$00			ldx 	#0
.019834	a1 20		lda ($20,x)			lda		(zGenPtr,x)
.019836	fa		plx				plx
.019837	48		pha				pha
.019838	20 41 9a	jsr $019a41			jsr 	CheckNextComma 					; skip comma
.01983b	20 8f 98	jsr $01988f			jsr 	SLIByteParameter 				; get a byte parameter.
.01983e	8d 9e 03	sta $039e			sta 	SignCount 						; save in temporary.
.019841	68		pla				pla 									; restore string length.
.019842	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.019843	38		sec				sec
.019844	ed 9e 03	sbc $039e			sbc 	SignCount 						; subtract characters needed, gives start position.
.019847	f0 02		beq $01984b			beq 	_URStart 						; if <= 0 start from 1.
.019849	10 02		bpl $01984d			bpl 	_UROkay
.01984b					_URStart:
.01984b	a9 01		lda #$01			lda 	#1
.01984d					_UROkay:
.01984d	48		pha				pha 									; push start
.01984e	ad 9e 03	lda $039e			lda 	SignCount 						; push count of characters
.019851	48		pha				pha
.019852	80 00		bra $019854			bra 	SLIProcess
.019854					SLIProcess:
.019854	20 39 9a	jsr $019a39			jsr 	CheckNextRParen 				; closing right bracket.
.019857	68		pla				pla
.019858	8d a2 03	sta $03a2			sta 	SliceCount 						; count in signcount
.01985b	1a		inc a				inc 	a 								; allocate +1 for it.
.01985c	20 86 9a	jsr $019a86			jsr 	AllocateTempString
.01985f	68		pla				pla 									; pop start number off stack.
.019860	f0 3b		beq $01989d			beq 	SLIError 						; exit if start = 0
.019862	8d a1 03	sta $03a1			sta 	SliceStart
.019865	68		pla				pla  									; pop string address.
.019866	85 21		sta $21				sta 	zGenPtr+1
.019868	68		pla				pla
.019869	85 20		sta $20				sta 	zGenPtr
.01986b	da		phx				phx
.01986c	5a		phy				phy
.01986d	a2 00		ldx #$00			ldx 	#0 								; point to string length.
.01986f	ac a1 03	ldy $03a1			ldy 	SliceStart 						; start of the string (+1 for count)
.019872					_SLICopy:
.019872	ad a2 03	lda $03a2			lda 	SliceCount 						; done count characters
.019875	f0 12		beq $019889			beq 	_SLIExit
.019877	ce a2 03	dec $03a2			dec 	SliceCount
.01987a	98		tya				tya 									; index of character
.01987b	c1 20		cmp ($20,x)			cmp 	(zGenPtr,x)						; compare against length
.01987d	f0 02		beq $019881			beq 	_SLIOk 							; if equal, okay.
.01987f	b0 08		bcs $019889			bcs 	_SLIExit 						; if past end, then exit.
.019881	b1 20		lda ($20),y	_SLIOk:	lda 	(zGenPtr),y 					; copy one character
.019883	c8		iny				iny
.019884	20 b1 9a	jsr $019ab1			jsr 	WriteTempString
.019887	80 e9		bra $019872			bra 	_SLICopy 						; go round till copied characters
.019889					_SLIExit:
.019889	7a		ply				ply 									; restore YX
.01988a	fa		plx				plx
.01988b	4c ae 99	jmp $0199ae			jmp 	UnaryReturnTempStr 				; return new temporary string.
.01988e	ea		nop				nop
.01988f					SLIByteParameter:
.01988f	20 e5 93	jsr $0193e5			jsr 	EvaluateIntegerX 				; get integer
.019892	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.019894	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019896	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019898	d0 03		bne $01989d			bne 	SLIError
.01989a	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01989c	60		rts				rts
.01989d					SLIError:
.01989d	4c 75 85	jmp $018575			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.0198a0					Unary_Hex:
.0198a0	20 e5 93	jsr $0193e5			jsr 	EvaluateIntegerX 			; numeric parameter
.0198a3	20 39 9a	jsr $019a39			jsr 	CheckNextRParen 			; right bracket.
.0198a6	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.0198a8	20 86 9a	jsr $019a86			jsr 	AllocateTempString			; allocate string space
.0198ab	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.0198ad	20 d1 98	jsr $0198d1			jsr 	_UHConvert
.0198b0	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0198b2	20 d1 98	jsr $0198d1			jsr 	_UHConvert
.0198b5	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0198b7	20 d1 98	jsr $0198d1			jsr 	_UHConvert
.0198ba	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0198bc	20 d1 98	jsr $0198d1			jsr 	_UHConvert
.0198bf	5a		phy				phy 								; get length of new string
.0198c0	a0 00		ldy #$00			ldy 	#0
.0198c2	b1 22		lda ($22),y			lda 	(zTempStr),y
.0198c4	7a		ply				ply
.0198c5	c9 00		cmp #$00			cmp 	#0 							; if it was non zero okay
.0198c7	d0 05		bne $0198ce			bne 	_UHExit 					; otherwise suppressed all leading zeros !
.0198c9	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.0198cb	20 b1 9a	jsr $019ab1			jsr 	WriteTempString
.0198ce					_UHExit:
.0198ce	4c ae 99	jmp $0199ae			jmp 	UnaryReturnTempStr 			; return new temporary string.
.0198d1					_UHConvert:
.0198d1	48		pha				pha
.0198d2	4a		lsr a				lsr 	a 							; do MSB
.0198d3	4a		lsr a				lsr 	a
.0198d4	4a		lsr a				lsr 	a
.0198d5	4a		lsr a				lsr 	a
.0198d6	20 da 98	jsr $0198da			jsr 	_UHNibble
.0198d9	68		pla				pla 								; do LSB
.0198da					_UHNibble:
.0198da	29 0f		and #$0f			and 	#15 						; get nibble
.0198dc	d0 0c		bne $0198ea			bne 	_UHNonZero 					; if not zero, write it out anyway.
.0198de	5a		phy				phy									; get the length
.0198df	a0 00		ldy #$00			ldy 	#0
.0198e1	b1 22		lda ($22),y			lda 	(zTempStr),y
.0198e3	7a		ply				ply
.0198e4	c9 00		cmp #$00			cmp 	#0 							; length = 0 => suppress leading zeros.
.0198e6	f0 0d		beq $0198f5			beq 	_UHExit2
.0198e8	a9 00		lda #$00			lda 	#0 							; length > 0, so can't suppress any more.
.0198ea					_UHNonZero:
.0198ea	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.0198ec	90 02		bcc $0198f0			bcc 	_UHDigit
.0198ee	69 06		adc #$06			adc 	#7-1
.0198f0					_UHDigit:
.0198f0	69 30		adc #$30			adc 	#48
.0198f2	20 b1 9a	jsr $019ab1			jsr 	WriteTempString				; output to temp string.
.0198f5					_UHExit2:
.0198f5	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.0198f6					Unary_Dec:
.0198f6	20 ee 93	jsr $0193ee			jsr 	EvaluateStringX 			; string parameter
.0198f9	20 39 9a	jsr $019a39			jsr 	CheckNextRParen 			; right bracket.
.0198fc	5a		phy				phy
.0198fd	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.0198ff	b1 20		lda ($20),y			lda 	(zGenPtr),y
.019901	f0 43		beq $019946			beq 	_UDFail 					; must fail if zero.
.019903	8d 9e 03	sta $039e			sta 	SignCount 					; use SignCount as a counter of chars to process.
.019906	a9 00		lda #$00			lda 	#0 							; set result to zero
.019908	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01990a	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01990c	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01990e	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019910	a9 01		lda #$01			lda 	#1 							; set type to integer.
.019912	95 85		sta $85,x			sta 	XS_Type,x
.019914					_UDConvertLoop:
.019914	5a		phy				phy 								; shift mantissa left 4
.019915	a0 04		ldy #$04			ldy 	#4
.019917					_UDShift:
.019917	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.019919	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.01991b	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.01991d	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.01991f	88		dey				dey
.019920	d0 f5		bne $019917			bne 	_UDShift
.019922	7a		ply				ply
.019923	c8		iny				iny 								; next character
.019924	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; fetch it.
.019926	20 49 99	jsr $019949			jsr 	ConvertUpper 				; convert to U/C
.019929	c9 30		cmp #$30			cmp 	#"0" 						; range 0-9
.01992b	90 19		bcc $019946			bcc 	_UDFail
.01992d	c9 3a		cmp #$3a			cmp 	#"9"+1
.01992f	90 08		bcc $019939			bcc 	_UDOkay
.019931	e9 37		sbc #$37			sbc 	#7+"0" 						; A-F fudge
.019933	90 11		bcc $019946			bcc 	_UDFail 					; fails if between 9 and @
.019935	c9 10		cmp #$10			cmp 	#16 						; must be < 16 as hexadecimal.
.019937	b0 0d		bcs $019946			bcs 	_UDFail
.019939					_UDOkay:
.019939	29 0f		and #$0f			and 	#15 						; nibble only
.01993b	15 80		ora $80,x			ora 	XS_Mantissa+0,x 			; OR into the bottom byte.
.01993d	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01993f	ce 9e 03	dec $039e			dec 	SignCount 					; do it for each character in the string.
.019942	d0 d0		bne $019914			bne 	_UDConvertLoop
.019944	7a		ply				ply
.019945	60		rts				rts
.019946					_UDFail:
.019946	4c 75 85	jmp $018575			jmp 	BadParamError
.019949					ConvertUpper:
.019949	c9 61		cmp #$61			cmp 	#"a"
.01994b	90 07		bcc $019954			bcc 	_CUExit
.01994d	c9 7b		cmp #$7b			cmp 	#"z"+1
.01994f	b0 03		bcs $019954			bcs 	_CUExit
.019951	38		sec				sec
.019952	e9 20		sbc #$20			sbc 	#32
.019954	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.019955					Unary_Chr:
.019955	20 e5 93	jsr $0193e5			jsr 	EvaluateIntegerX			; numeric parameter which is the character we want
.019958	20 39 9a	jsr $019a39			jsr 	CheckNextRParen 			; right bracket.
.01995b	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.01995d	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01995f	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019961	d0 0d		bne $019970			bne 	_UCChar
.019963	a9 02		lda #$02			lda 	#1+1 						; one character string. 2 bytes - size+char
.019965	20 86 9a	jsr $019a86			jsr 	AllocateTempString			; allocate it.
.019968	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.01996a	20 b1 9a	jsr $019ab1			jsr 	WriteTempString
.01996d	4c ae 99	jmp $0199ae			jmp 	UnaryReturnTempStr 			; and return that string.
.019970					_UCChar:
.019970	4c 75 85	jmp $018575			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.019973					Unary_Spc:
.019973	20 8f 98	jsr $01988f			jsr 	SLIByteParameter 			; get number of spaces
.019976	20 39 9a	jsr $019a39			jsr 	CheckNextRParen 			; skip )
.019979	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; count of spaces
.01997b					UnarySpcCreate:
.01997b	c9 fe		cmp #$fe			cmp 	#maxString+1				; validate
.01997d	b0 14		bcs $019993			bcs 	_USSize
.01997f	48		pha				pha 								; save length
.019980	1a		inc a				inc 	a 							; allocate one more.
.019981	20 86 9a	jsr $019a86			jsr 	AllocateTempString
.019984	68		pla				pla 								; get length
.019985	f0 27		beq $0199ae			beq 	UnaryReturnTempStr 			; if zero (spc(0)) return the current temp string
.019987					_USLoop:
.019987	48		pha				pha
.019988	a9 20		lda #$20			lda 	#" "
.01998a	20 b1 9a	jsr $019ab1			jsr 	WriteTempString
.01998d	68		pla				pla
.01998e	3a		dec a				dec 	a
.01998f	d0 f6		bne $019987			bne 	_USLoop
.019991	80 1b		bra $0199ae			bra 	UnaryReturnTempStr 			; and return the temporary space.
.019993					_USSize:
.019993	4c 75 85	jmp $018575			jmp 	BadParamError
.019996					Unary_Tab:
.019996	a2 00		ldx #$00			ldx 	#0 							; required TAB position.
.019998	20 8f 98	jsr $01988f			jsr 	SLIByteParameter
.01999b	20 39 9a	jsr $019a39			jsr 	CheckNextRParen
.01999e	20 50 85	jsr $018550			jsr 	VIOCharGetPosition 			; were are we ?
.0199a1	85 10		sta $10				sta 	zTemp1 						; calculate required-current
.0199a3	38		sec				sec
.0199a4	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; return chars required.
.0199a6	e5 10		sbc $10				sbc 	zTemp1
.0199a8	b0 d1		bcs $01997b			bcs 	UnarySpcCreate 				; if not there, use SPC() code to generate string
.0199aa	a9 00		lda #$00			lda 	#0 							; if there or better, no characters required.
.0199ac	80 cd		bra $01997b			bra 	UnarySpcCreate
.0199ae					UnaryReturnTempStr:
.0199ae	a5 22		lda $22				lda 	zTempStr 					; copy temp string addr -> mantissa
.0199b0	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0199b2	a5 23		lda $23				lda 	zTempStr+1
.0199b4	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0199b6	a9 02		lda #$02			lda 	#2 							; set type to string
.0199b8	95 85		sta $85,x			sta 	XS_Type,x
.0199ba	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/65816.asm

.0199bb					MemRead:
.0199bb	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.0199be	a0 00		ldy #$00			ldy 	#0 							; start from here
.0199c0	b7 1c		lda [$1c],y	_MLoop1:lda 	[zlTemp1],y 				; read the long address
.0199c2	95 80		sta $80,x			sta 	XS_Mantissa,x 				; copy into mantissa
.0199c4	c8		iny				iny 								; next to copy
.0199c5	e8		inx				inx
.0199c6	cc 9e 03	cpy $039e			cpy 	SignCount 					; do required # of bytes.
.0199c9	d0 f5		bne $0199c0			bne 	_MLoop1
.0199cb	60		rts				rts
.0199cc					MemWrite:
.0199cc	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.0199cf	a0 00		ldy #$00			ldy 	#0 							; start from here
.0199d1	b5 80		lda $80,x	_MLoop1:lda 	XS_Mantissa,x 				; read mantisssa
.0199d3	97 1c		sta [$1c],y			sta 	[zlTemp1],y 				; write it out
.0199d5	c8		iny				iny 								; next to copy
.0199d6	e8		inx				inx
.0199d7	cc 9e 03	cpy $039e			cpy 	SignCount 					; do required # of bytes.
.0199da	d0 f5		bne $0199d1			bne 	_MLoop1
.0199dc	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/programend.asm

.0199dd					UpdateProgramEnd:
.0199dd	a9 00		lda #$00			lda 	#(BasicProgram) & $FF
.0199df	85 18		sta $18				sta 	zCodePtr+0
.0199e1	a9 10		lda #$10			lda 	#(BasicProgram) >> 8
.0199e3	85 19		sta $19				sta 	zCodePtr+1
.0199e5	a9 00		lda #$00			lda 	#0
.0199e7	85 1a		sta $1a				sta 	zCodePtr+2
.0199e9	85 1b		sta $1b				sta 	zCodePtr+3
.0199eb	a0 03		ldy #$03			ldy 	#3
.0199ed					_UPDLoop:
.0199ed	a0 00		ldy #$00			ldy 	#0
.0199ef	b7 18		lda [$18],y			lda 	[zCodePtr],y
.0199f1	c9 00		cmp #$00			cmp 	#0 							; end if offset is zero.
.0199f3	f0 0f		beq $019a04			beq 	_UPDFoundEnd
.0199f5	a0 00		ldy #$00			ldy 	#0 							; point to offset
.0199f7	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read it
.0199f9	18		clc				clc
.0199fa	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.0199fc	85 18		sta $18				sta 	zCodePtr
.0199fe	90 02		bcc $019a02			bcc 	_SNLNoCarry
.019a00	e6 19		inc $19				inc 	zCodePtr+1
.019a02					_SNLNoCarry:
.019a02	80 e9		bra $0199ed			bra 	_UPDLoop
.019a04					_UPDFoundEnd:
.019a04	18		clc				clc 								; end of program 2 on.
.019a05	a5 18		lda $18				lda 	zCodePtr
.019a07	69 02		adc #$02			adc 	#2
.019a09	8d 04 03	sta $0304			sta 	endOfProgram
.019a0c	a5 19		lda $19				lda 	zCodePtr+1
.019a0e	69 00		adc #$00			adc 	#0
.019a10	8d 05 03	sta $0305			sta 	endOfProgram+1
.019a13	a5 1a		lda $1a				lda 	zCodePtr+2
.019a15	69 00		adc #$00			adc		#0
.019a17	8d 06 03	sta $0306			sta 	endOfProgram+2
.019a1a	a5 1b		lda $1b				lda 	zCodePtr+3
.019a1c	69 00		adc #$00			adc 	#0
.019a1e	8d 07 03	sta $0307			sta 	endOfProgram+3
.019a21	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.019a22					CheckNextToken:
.019a22	d7 18		cmp [$18],y			cmp 	[zCodePtr],y
.019a24	d0 02		bne $019a28			bne 	CTFail 						; no, then fail
.019a26	c8		iny				iny
.019a27	60		rts				rts
.019a28					CTFail:
.019a28	20 86 85	jsr $018586			jsr ERR_Handler
>019a2b	4d 69 73 73 69 6e 67 20			.text "Missing token",0
>019a33	74 6f 6b 65 6e 00
.019a39					CheckNextRParen:
.019a39	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019a3b	c9 be		cmp #$be			cmp 	#token_rparen 						; does it match
.019a3d	d0 e9		bne $019a28			bne 	CTFail 						; fail if not
.019a3f	c8		iny				iny
.019a40	60		rts				rts
.019a41					CheckNextComma:
.019a41	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019a43	c9 bf		cmp #$bf			cmp 	#token_comma 						; does it match
.019a45	d0 e1		bne $019a28			bne 	CTFail 						; fail if not
.019a47	c8		iny				iny
.019a48	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/concrete.asm

.019a49					StringConcrete:
.019a49	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; save source string to zTemp1
.019a4b	85 10		sta $10				sta 	zTemp1
.019a4d	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019a4f	85 11		sta $11				sta 	zTemp1+1
.019a51	a0 00		ldy #$00			ldy 	#0 							; empty string, return default empty
.019a53	b1 10		lda ($10),y			lda 	(zTemp1),y
.019a55	f0 26		beq $019a7d			beq		_SCEmpty 					; concreting it wastes memory.
.019a57	18		clc				clc 								; from the string pointer
.019a58	ad 00 03	lda $0300			lda 	StringPtr 					; and put in zTemp2 as well
.019a5b	f1 10		sbc ($10),y			sbc 	(zTemp1),y
.019a5d	8d 00 03	sta $0300			sta 	StringPtr
.019a60	85 12		sta $12				sta 	zTemp2
.019a62	ad 01 03	lda $0301			lda 	StringPtr+1
.019a65	e9 00		sbc #$00			sbc 	#0
.019a67	8d 01 03	sta $0301			sta 	StringPtr+1
.019a6a	85 13		sta $13				sta 	zTemp2+1
.019a6c	b1 10		lda ($10),y			lda 	(zTemp1),y 					; length add one for count
.019a6e	1a		inc a				inc 	a
.019a6f	aa		tax				tax
.019a70	b1 10		lda ($10),y	_SCCopy:lda 	(zTemp1),y 					; copy whole thing including length
.019a72	91 12		sta ($12),y			sta 	(zTemp2),y
.019a74	c8		iny				iny
.019a75	ca		dex				dex
.019a76	d0 f8		bne $019a70			bne 	_SCCopy
.019a78	a5 13		lda $13				lda 	zTemp2+1 					; return concrete string in AX
.019a7a	a6 12		ldx $12				ldx 	zTemp2
.019a7c	60		rts				rts
.019a7d					_SCEmpty:
.019a7d	a9 00		lda #$00			lda 	#0
.019a7f	85 27		sta $27				sta 	zNullString
.019a81	a9 00		lda #$00			lda 	#zNullString >> 8
.019a83	a2 27		ldx #$27			ldx 	#zNulLString & $FF
.019a85	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.019a86					AllocateTempString:
.019a86	48		pha				pha 								; save required count.
.019a87	a5 23		lda $23				lda 	zTempStr+1 					; check if initialised yet ?
.019a89	d0 0b		bne $019a96			bne 	_ATSInitialised
.019a8b	ad 00 03	lda $0300			lda 	StringPtr 					; set temporary string ptr 1 page below available
.019a8e	85 22		sta $22				sta 	zTempStr					; space, this is for strings to be concreted.
.019a90	ad 01 03	lda $0301			lda 	StringPtr+1
.019a93	3a		dec a				dec 	a 							; allow the page.
.019a94	85 23		sta $23				sta 	zTempStr+1
.019a96					_ATSInitialised:
.019a96	68		pla				pla 								; get required count back.
.019a97	49 ff		eor #$ff			eor 	#$FF 						; negate and add 2's complement.
.019a99	1a		inc a				inc 	a
.019a9a	18		clc				clc
.019a9b	65 22		adc $22				adc 	zTempStr 					; "add" to the temp string pointer
.019a9d	85 22		sta $22				sta 	zTempStr					; which means the tsp is also the current.
.019a9f	a9 ff		lda #$ff			lda 	#$FF
.019aa1	65 23		adc $23				adc 	zTempStr+1
.019aa3	85 23		sta $23				sta 	zTempStr+1
.019aa5	a9 00		lda #$00			lda 	#0 							; clear temp string by zeroing length.
.019aa7	5a		phy				phy
.019aa8	a8		tay				tay
.019aa9	91 22		sta ($22),y			sta 	(zTempStr),y
.019aab	7a		ply				ply
.019aac	1a		inc a				inc 	a 							; reset the write index to 1 (first character)
.019aad	8d 9f 03	sta $039f			sta 	TempStringWriteIndex
.019ab0	60		rts				rts
.019ab1					WriteTempString:
.019ab1	5a		phy				phy 								; save Y
.019ab2	ac 9f 03	ldy $039f			ldy 	TempStringWriteIndex	 	; write position.
.019ab5	91 22		sta ($22),y			sta 	(zTempStr),y 				; write character out.
.019ab7	ee 9f 03	inc $039f			inc 	TempStringWriteIndex 		; increment the write position.
.019aba	98		tya				tya 								; unchanged Y is now length
.019abb	a0 00		ldy #$00			ldy 	#0
.019abd	91 22		sta ($22),y			sta 	(zTempStr),y
.019abf	7a		ply				ply 								; restore Y and exit
.019ac0	60		rts				rts
.019ac1					CreateTempStringCopy:
.019ac1	da		phx				phx 								; save X
.019ac2	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019ac4	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.019ac5	20 86 9a	jsr $019a86			jsr 	AllocateTempString 			; allocate memory for temporary string.
.019ac8	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019aca	c8		iny				iny
.019acb	3a		dec a				dec 	a 							; make the actual length in characters, allowing
.019acc	3a		dec a				dec 	a 							; for the marker and the length.
.019acd	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.019acf	81 22		sta ($22,x)			sta 	(zTempStr,x)
.019ad1	85 1c		sta $1c				sta 	zLTemp1 					; that's used as a count.
.019ad3	09 00		ora #$00			ora 	#0 							; if zero already, exit
.019ad5	f0 0e		beq $019ae5			beq 	_CTSCExit
.019ad7					_CTSCLoop:
.019ad7	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019ad9	c8		iny				iny
.019ada	5a		phy				phy 								; save Y
.019adb	e8		inx				inx 								; bump index
.019adc	da		phx				phx 								; save that
.019add	7a		ply				ply 								; index into Y
.019ade	91 22		sta ($22),y			sta 	(zTempStr),y 				; save at index position
.019ae0	7a		ply				ply 								; restore Y
.019ae1	c6 1c		dec $1c				dec 	zLTemp1 					; do for each character, this is the counter.
.019ae3	d0 f2		bne $019ad7			bne 	_CTSCLoop
.019ae5					_CTSCExit:
.019ae5	fa		plx				plx 								; restore X
.019ae6	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/basic/tokenise/tokkeyword.asm

.019ae7					TokeniseKeyword:
.019ae7	98		tya				tya 								; fix up genptr so Y = 0 access the current one.
.019ae8	18		clc				clc
.019ae9	65 20		adc $20				adc 	zGenPtr
.019aeb	85 20		sta $20				sta 	zGenPtr
.019aed	90 02		bcc $019af1			bcc 	_TKWNoBump
.019aef	e6 21		inc $21				inc 	zGenPtr+1
.019af1					_TKWNoBump:
.019af1	a0 00		ldy #$00			ldy 	#0 							; this adds Y to genPtr, so it will still scan
.019af3	da		phx				phx
.019af4	a9 cf		lda #$cf			lda 	#KeyWordText & $FF 			; scan this table.
.019af6	a2 86		ldx #$86			ldx 	#(KeyWordText >> 8) & $FF
.019af8	20 03 9b	jsr $019b03			jsr 	TKWScanTokenTable
.019afb	fa		plx				plx
.019afc	90 04		bcc $019b02			bcc 	_TKWNoWrite
.019afe	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x 			; write the token out.
.019b01	e8		inx				inx
.019b02					_TKWNoWrite:
.019b02	60		rts				rts
.019b03					TKWScanTokenTable:
.019b03	86 1d		stx $1d				stx 	zLTemp1+1
.019b05	85 1c		sta $1c				sta 	zLTemp1+0 						; store at zLTemp1
.019b07	a9 01		lda #$01			lda 	#KeywordText >> 16 				; 24 bit addresses in the 65816
.019b09	85 1e		sta $1e				sta 	zLTemp1+2 						; lovely.
.019b0b	a0 00		ldy #$00			ldy 	#0 								; read and capitalise the first character
.019b0d	84 12		sty $12				sty 	zTemp2 							; zero the longest length match.
.019b0f	b1 20		lda ($20),y			lda 	(zGenPtr),y
.019b11	20 1e 9c	jsr $019c1e			jsr 	TOKCapitalise 					; save this in zTemp3
.019b14	85 14		sta $14				sta 	zTemp3
.019b16	a9 80		lda #$80			lda 	#$80 							; current token in zTemp3+1
.019b18	85 15		sta $15				sta 	zTemp3+1
.019b1a					_TKWScanLoop:
.019b1a	b7 1c		lda [$1c],y			lda 	[zLTemp1],y
.019b1c	29 7f		and #$7f			and 	#$7F 							; drop bit 7, it might be 1 character long.
.019b1e	c5 14		cmp $14				cmp 	zTemp3 							; compare against got character.
.019b20	d0 26		bne $019b48			bne		_TKWNext 						; if it doesn't match, go to next.
.019b22	20 67 9b	jsr $019b67			jsr 	_TKWClearY 						; make it so (zTemp1),y now points to zTemp1
.019b25	a0 00		ldy #$00			ldy 	#0 								; compare the tokens directly
.019b27					_TKWCompareFull:
.019b27	b7 1c		lda [$1c],y			lda 	[zLTemp1],y
.019b29	29 7f		and #$7f			and 	#$7F 							; drop bit 7
.019b2b	85 16		sta $16				sta 	zTemp4
.019b2d	b1 20		lda ($20),y			lda 	(zGenPtr),y 					; compare against keyword in text.
.019b2f	20 1e 9c	jsr $019c1e			jsr 	TOKCapitalise 					; make it U/C
.019b32	c5 16		cmp $16				cmp 	zTemp4 							; compare against table char w/o bit 7.
.019b34	d0 12		bne $019b48			bne 	_TKWNext 						; failed, go to next slot.
.019b36	b7 1c		lda [$1c],y			lda 	[zLTemp1],y
.019b38	c8		iny				iny 									; bump pointer
.019b39	0a		asl a				asl 	a 								; shift bit 7 into C
.019b3a	90 eb		bcc $019b27			bcc 	_TKWCompareFull					; keep going till that bit is 7 e.g. token matches
.019b3c	c4 12		cpy $12				cpy 	zTemp2 							; compare against longest match
.019b3e	90 08		bcc $019b48			bcc 	_TKWNext 						; if shorter, the original was better
.019b40	84 12		sty $12				sty 	zTemp2							; update longest match.
.019b42	a5 15		lda $15				lda 	zTemp3+1 						; copy current token
.019b44	85 13		sta $13				sta 	zTemp2+1 						; into matched token slot.
.019b46	a0 00		ldy #$00			ldy 	#0 								; reset to start of matched token for forward
.019b48					_TKWNext:
.019b48	b7 1c		lda [$1c],y			lda 	[zLTemp1],y
.019b4a	c8		iny				iny 									; next one.
.019b4b	0a		asl a				asl 	a 								; if bit 7 clear loop back.
.019b4c	90 fa		bcc $019b48			bcc 	_TKWNext
.019b4e	e6 15		inc $15				inc 	zTemp3+1 						; increment current token.
.019b50	98		tya				tya 									; has Y gone negative.
.019b51	10 03		bpl $019b56			bpl 	_TKWNoYZero
.019b53	20 67 9b	jsr $019b67			jsr 	_TKWClearY 						; make it so (zTemp1),y now points to zTemp1
.019b56					_TKWNoYZero:
.019b56	b7 1c		lda [$1c],y			lda 	[zLTemp1],y
.019b58	d0 c0		bne $019b1a			bne 	_TKWScanLoop 					; if not, try the next one.
.019b5a	a5 12		lda $12				lda 	zTemp2 							; length of longest match
.019b5c	f0 05		beq $019b63			beq 	_TKWFail 						; if zero, none found.
.019b5e	a8		tay				tay 									; return the token in zTemp2, length => y
.019b5f	a5 13		lda $13				lda 	zTemp2+1 						; so the offset is right.
.019b61	38		sec				sec
.019b62	60		rts				rts
.019b63					_TKWFail:
.019b63	a0 00		ldy #$00			ldy 	#0 								; return with Y = 0 and carry clear.
.019b65	18		clc				clc
.019b66	60		rts				rts
.019b67					_TKWClearY:
.019b67	98		tya				tya
.019b68	18		clc				clc
.019b69	65 1c		adc $1c				adc 	zLTemp1
.019b6b	85 1c		sta $1c				sta 	zLTemp1
.019b6d	90 02		bcc $019b71			bcc 	_TKWCNoBump
.019b6f	e6 1d		inc $1d				inc 	zLTemp1+1
.019b71					_TKWCNoBump:
.019b71	a0 00		ldy #$00			ldy 	#0
.019b73	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/tokenise/tokenise.asm

.019b74					TokeniseString:
.019b74	85 20		sta $20				sta 	zGenPtr 					; save source
.019b76	86 21		stx $21				stx 	zGenPtr+1
.019b78	a0 00		ldy #$00			ldy 	#0 							; source
.019b7a	a2 03		ldx #$03			ldx 	#3 							; target
.019b7c	8c 00 04	sty $0400			sty 	TokeniseBuffer+0 			; write three NULLs. So it looks like
.019b7f	8c 01 04	sty $0401			sty 	TokeniseBuffer+1 			; there's a line number zero.
.019b82	8c 02 04	sty $0402			sty 	TokeniseBuffer+2
.019b85					_TSMainLoop:
.019b85					_TSSkipSpaces:
.019b85	b1 20		lda ($20),y			lda 	(zGenPtr),y					; skip over spaces.
.019b87	c8		iny				iny
.019b88	c9 20		cmp #$20			cmp 	#" "
.019b8a	f0 f9		beq $019b85			beq 	_TSSkipSpaces
.019b8c	c9 30		cmp #$30			cmp 	#"0" 						; is it a constant
.019b8e	90 0a		bcc $019b9a			bcc 	_TSNotConstant
.019b90	c9 3a		cmp #$3a			cmp 	#"9"+1
.019b92	b0 06		bcs $019b9a			bcs 	_TSNotConstant
.019b94	88		dey				dey 								; point back to start
.019b95	20 b9 9c	jsr $019cb9			jsr 	TokeniseConstant 			; tokenise a constant
.019b98	80 eb		bra $019b85			bra 	_TSMainLoop			 		; and loop back.
.019b9a					_TSNotConstant:
.019b9a	c9 20		cmp #$20			cmp 	#32 						; end of line.
.019b9c	90 52		bcc $019bf0			bcc 	_TSExit
.019b9e	c9 22		cmp #$22			cmp		#'"'						; quoted string
.019ba0	f0 55		beq $019bf7			beq 	_TSQuotedString
.019ba2	c9 2e		cmp #$2e			cmp 	#'.' 						; decimal.
.019ba4	f0 56		beq $019bfc			beq 	_TSDecimal
.019ba6	20 1e 9c	jsr $019c1e			jsr 	TOKCapitalise 				; make U/C
.019ba9	c9 52		cmp #$52			cmp 	#"R" 						; is it R, if so check for REM ?
.019bab	d0 05		bne $019bb2			bne 	_TSNoRemCheck
.019bad	20 01 9c	jsr $019c01			jsr 	TOKCheckREM
.019bb0	b0 d3		bcs $019b85			bcs 	_TSMainLoop 				; and if REM okay, go back.
.019bb2					_TSNoRemCheck:
.019bb2	88		dey				dey 								; point to character
.019bb3	20 e7 9a	jsr $019ae7			jsr 	TokeniseKeyword 			; try to tokenise a keyword.
.019bb6	b0 cd		bcs $019b85			bcs 	_TSMainLoop					; true if tokenised okay.
.019bb8	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; get character
.019bba	20 1e 9c	jsr $019c1e			jsr 	TOKCapitalise
.019bbd	c9 41		cmp #$41			cmp 	#"A"						; is it A-Z, if so it's an alphanumeric sequence.
.019bbf	90 04		bcc $019bc5			bcc 	_TSSingle
.019bc1	c9 5b		cmp #$5b			cmp 	#"Z"+1
.019bc3	90 0d		bcc $019bd2			bcc 	_TSAlphaNumeric
.019bc5					_TSSingle:
.019bc5	c8		iny				iny 								; skip over output
.019bc6	29 3f		and #$3f			and 	#63 						; make 6 bit ASCII
.019bc8	09 80		ora #$80			ora 	#128
.019bca	f0 b9		beq $019b85			beq 	_TSMainLoop 				; ignore @, which doesn't tokenise.
.019bcc	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.019bcf	e8		inx				inx
.019bd0	80 b3		bra $019b85			bra 	_TSMainLoop
.019bd2					_TSAlphaNumeric:
.019bd2	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; get
.019bd4	20 1e 9c	jsr $019c1e			jsr 	TOKCapitalise
.019bd7	c9 30		cmp #$30			cmp 	#"0" 	 					; check 0-9
.019bd9	90 aa		bcc $019b85			bcc 	_TSMainLoop
.019bdb	c9 3a		cmp #$3a			cmp 	#"9"+1
.019bdd	90 0a		bcc $019be9			bcc 	_TSANOkay
.019bdf	c9 41		cmp #$41			cmp 	#"A"						; check A-Z
.019be1	90 a2		bcc $019b85			bcc 	_TSMainLoop
.019be3	c9 5b		cmp #$5b			cmp 	#"Z"+1
.019be5	b0 9e		bcs $019b85			bcs 	_TSMainLoop
.019be7	29 3f		and #$3f			and 	#63 						; write it out
.019be9					_TSANOkay:
.019be9	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.019bec	e8		inx				inx
.019bed	c8		iny				iny
.019bee	80 e2		bra $019bd2			bra 	_TSAlphaNumeric
.019bf0	a9 00		lda #$00	_TSExit:lda 	#0 							; mark end of line.
.019bf2	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.019bf5	8a		txa				txa 								; return length of tokenised line in bytes.
.019bf6	60		rts				rts
.019bf7					_TSQuotedString:
.019bf7	20 57 9c	jsr $019c57			jsr 	TokeniseQuotedString
.019bfa	80 89		bra $019b85			bra 	_TSMainLoop
.019bfc					_TSDecimal:
.019bfc	20 7d 9c	jsr $019c7d			jsr 	TokeniseDecimalString
.019bff	80 84		bra $019b85			bra 	_TSMainLoop
.019c01					TOKCheckREM:
.019c01	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; check E
.019c03	20 1e 9c	jsr $019c1e			jsr 	TOKCapitalise
.019c06	c9 45		cmp #$45			cmp 	#"E"
.019c08	d0 12		bne $019c1c			bne 	_TCRFail
.019c0a	c8		iny				iny
.019c0b	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; check M
.019c0d	88		dey				dey
.019c0e	20 1e 9c	jsr $019c1e			jsr 	TOKCapitalise
.019c11	c9 4d		cmp #$4d			cmp 	#"M"
.019c13	d0 07		bne $019c1c			bne 	_TCRFail
.019c15	c8		iny				iny									; point to first character
.019c16	c8		iny				iny
.019c17	20 29 9c	jsr $019c29			jsr 	TokeniseREMString 			; tokenise REM
.019c1a	38		sec				sec
.019c1b	60		rts				rts
.019c1c					_TCRFail:
.019c1c	18		clc				clc
.019c1d	60		rts				rts
.019c1e					TOKCapitalise:
.019c1e	c9 61		cmp #$61			cmp 	#"a"
.019c20	90 06		bcc $019c28			bcc 	_TOKCExit
.019c22	c9 7b		cmp #$7b			cmp 	#"z"+1
.019c24	b0 02		bcs $019c28			bcs 	_TOKCExit
.019c26	49 20		eor #$20			eor 	#$20
.019c28					_TOKCExit:
.019c28	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/tokenise/tokseq.asm

.019c29					TokeniseREMString:
.019c29	86 10		stx $10				stx 	zTemp1 						; save position
.019c2b	a9 ff		lda #$ff			lda 	#$FF 						; write marker
.019c2d	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.019c30	9d 01 04	sta $0401,x			sta 	TokeniseBuffer+1,x 			; stops space removal.
.019c33	e8		inx				inx 								; bump, and one space for the count.
.019c34	e8		inx				inx
.019c35					_TSRSkip:
.019c35	b1 20		lda ($20),y			lda 	(zGenPtr),y
.019c37	c8		iny				iny
.019c38	c9 20		cmp #$20			cmp 	#" "
.019c3a	f0 f9		beq $019c35			beq 	_TSRSkip
.019c3c	c9 3a		cmp #$3a			cmp 	#":"						; first char is a colon
.019c3e	f0 31		beq $019c71			beq 	SequenceExit 				; ... that's it.
.019c40					_TSRCopy:
.019c40	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x 			; write out
.019c43	e8		inx				inx
.019c44	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; get next
.019c46	f0 05		beq $019c4d			beq 	_TSRExit 					; zero is exit
.019c48	c8		iny				iny 								; bump pointer
.019c49	c9 3a		cmp #$3a			cmp 	#":"						; loop back if not colon.
.019c4b	d0 f3		bne $019c40			bne 	_TSRCopy
.019c4d					_TSRExit:
.019c4d	bd ff 03	lda $03ff,x			lda 	TokeniseBuffer-1,x 			; previous char space ?
.019c50	c9 20		cmp #$20			cmp 	#" "
.019c52	d0 1d		bne $019c71			bne 	SequenceExit
.019c54	ca		dex				dex 								; go back - will bump into $FF eventually.
.019c55	80 f6		bra $019c4d			bra 	_TSRExit
.019c57					TokeniseQuotedString:
.019c57	86 10		stx $10				stx 	zTemp1 						; save position
.019c59	a9 fe		lda #$fe			lda 	#$FE 						; write marker
.019c5b	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.019c5e	e8		inx				inx 								; bump, and one space for the count.
.019c5f	e8		inx				inx
.019c60					_TSQCopy:
.019c60	b1 20		lda ($20),y			lda 	(zGenPtr),y
.019c62	c9 20		cmp #$20			cmp 	#" "
.019c64	90 0b		bcc $019c71			bcc 	SequenceExit 				; if < ' ' then exit, didn't find end.
.019c66	c8		iny				iny
.019c67	c9 22		cmp #$22			cmp 	#'"'						; if = quote, consume it and exit.
.019c69	f0 06		beq $019c71			beq 	SequenceExit
.019c6b	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x 			; write out and loop
.019c6e	e8		inx				inx
.019c6f	80 ef		bra $019c60			bra 	_TSQCopy
.019c71					SequenceExit:
.019c71	8a		txa				txa 								; current position
.019c72	38		sec				sec 								; subtract start.
.019c73	e5 10		sbc $10				sbc 	zTemp1
.019c75	da		phx				phx 								; copy that in
.019c76	a6 10		ldx $10				ldx 	zTemp1
.019c78	9d 01 04	sta $0401,x			sta 	TokeniseBuffer+1,x
.019c7b	fa		plx				plx
.019c7c	60		rts				rts
.019c7d					TokeniseDecimalString:
.019c7d	86 10		stx $10				stx 	zTemp1 						; save position
.019c7f	a9 fd		lda #$fd			lda 	#$FD 						; write marker
.019c81	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.019c84	e8		inx				inx 								; bump, and one space for the count.
.019c85	e8		inx				inx
.019c86	20 a7 9c	jsr $019ca7			jsr 	_TDSCopyNumber 				; copy a number.
.019c89	b1 20		lda ($20),y			lda 	(zGenPtr),y	 				; next letter.
.019c8b	20 1e 9c	jsr $019c1e			jsr 	TOKCapitalise
.019c8e	c9 45		cmp #$45			cmp 	#"E" 						; if not an exponent.
.019c90	d0 df		bne $019c71			bne 	SequenceExit 				; exit now.
.019c92	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x 			; write E out
.019c95	e8		inx				inx
.019c96	c8		iny				iny
.019c97	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; followed by a minus ?
.019c99	c9 2d		cmp #$2d			cmp 	#"-"
.019c9b	d0 05		bne $019ca2			bne 	_TDSNoMinusExponent
.019c9d	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x 			; write - out
.019ca0	e8		inx				inx
.019ca1	c8		iny				iny
.019ca2					_TDSNoMinusExponent:
.019ca2	20 a7 9c	jsr $019ca7			jsr 	_TDSCopyNumber 				; do the exponent
.019ca5	80 ca		bra $019c71			bra 	SequenceExit
.019ca7					_TDSCopyNumber:
.019ca7	b1 20		lda ($20),y			lda 	(zGenPtr),y
.019ca9	c9 30		cmp #$30			cmp 	#"0"
.019cab	90 0b		bcc $019cb8			bcc 	_TDSCNExit
.019cad	c9 3a		cmp #$3a			cmp 	#"9"+1
.019caf	b0 07		bcs $019cb8			bcs 	_TDSCNExit
.019cb1	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.019cb4	e8		inx				inx
.019cb5	c8		iny				iny
.019cb6	80 ef		bra $019ca7			bra 	_TDSCopyNumber
.019cb8					_TDSCNExit:
.019cb8	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/tokenise/tokconst.asm

.019cb9					TokeniseConstant:
.019cb9	da		phx				phx 								; save X
.019cba	a2 00		ldx #$00			ldx 	#0
.019cbc	20 97 a2	jsr $01a297			jsr 	IntFromStringY 				; get the integer out.
.019cbf	b0 37		bcs $019cf8			bcs 	_TCQ 						; should not happen.
.019cc1	fa		plx				plx 								; restore X.
.019cc2	a9 00		lda #$00			lda 	#0 							; zero count of restores.
.019cc4	85 10		sta $10				sta 	zTemp1
.019cc6					_TCRotate:
.019cc6	a5 80		lda $80				lda 	XS_Mantissa+0 				; check bits 6/7 of 0
.019cc8	29 c0		and #$c0			and 	#$C0
.019cca	05 81		ora $81				ora 	XS_Mantissa+1	 			; and 1/2/3 all zero
.019ccc	05 82		ora $82				ora 	XS_Mantissa+2
.019cce	05 83		ora $83				ora 	XS_Mantissa+3
.019cd0	f0 16		beq $019ce8			beq 	_TCDone						; if so, at the bottom.
.019cd2	a5 80		lda $80				lda 	XS_Mantissa+0 				; push lower 6 bits of 0
.019cd4	29 3f		and #$3f			and 	#$3F
.019cd6	48		pha				pha
.019cd7	e6 10		inc $10				inc 	zTemp1 						; increment the pop count.
.019cd9	a9 06		lda #$06			lda 	#6 							; shift right 6 times
.019cdb					_TCShiftRight:
.019cdb	46 83		lsr $83				lsr 	XS_Mantissa+3
.019cdd	66 82		ror $82				ror 	XS_Mantissa+2
.019cdf	66 81		ror $81				ror 	XS_Mantissa+1
.019ce1	66 80		ror $80				ror 	XS_Mantissa+0
.019ce3	3a		dec a				dec 	a
.019ce4	d0 f5		bne $019cdb			bne 	_TCShiftRight
.019ce6	80 de		bra $019cc6			bra 	_TCRotate 					; and go round again.
.019ce8	a5 80		lda $80		_TCDone:lda 	XS_Mantissa+0
.019cea					_TCWrite:
.019cea	09 40		ora #$40			ora 	#$40						; write it out as inttoken
.019cec	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.019cef	e8		inx				inx
.019cf0	c6 10		dec $10				dec 	zTemp1 						; done all of them
.019cf2	30 03		bmi $019cf7			bmi 	_TCExit 					; no , more to pop
.019cf4	68		pla				pla
.019cf5	80 f3		bra $019cea			bra 	_TCWrite 					; until everything's off.
.019cf7					_TCExit:
.019cf7	60		rts				rts
.019cf8					_TCQ:
.019cf8	20 86 85	jsr $018586			jsr ERR_Handler
>019cfb	54 4b 00				.text "TK",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/variables.asm

.019cfe					VariableFind:
.019cfe	20 69 9d	jsr $019d69			jsr 	VariableExtract 		; find out all about it ....
.019d01	20 02 a0	jsr $01a002			jsr 	VariableLocate 			; does it already exist ?
.019d04	b0 03		bcs $019d09			bcs 	_VFExists 				; if so, use that.
.019d06	20 f5 9d	jsr $019df5			jsr 	VariableCreate 			; otherwise create it.
.019d09					_VFExists:
.019d09	a5 26		lda $26				lda 	zVarType 				; is it still an array ?
.019d0b	29 01		and #$01			and 	#1
.019d0d	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.019d0f	d0 28		bne $019d39			bne 	_VFSingleElement
.019d11					_VFNextIndex:
.019d11	a5 24		lda $24				lda 	zVarDataPtr 			; push the data ptr and type on the stack.
.019d13	48		pha				pha
.019d14	a5 25		lda $25				lda 	zVarDataPtr+1
.019d16	48		pha				pha
.019d17	a5 26		lda $26				lda 	zVarType
.019d19	48		pha				pha
.019d1a	20 e3 93	jsr $0193e3			jsr 	EvaluateInteger 		; calculate the index.
.019d1d	68		pla				pla 							; restore and index.
.019d1e	85 26		sta $26				sta 	zVarType
.019d20	68		pla				pla
.019d21	85 25		sta $25				sta 	zVarDataPtr+1
.019d23	68		pla				pla
.019d24	85 24		sta $24				sta 	zVarDataPtr
.019d26	20 80 9e	jsr $019e80			jsr 	ArrayIndexFollow 		; do the index.
.019d29	a5 26		lda $26				lda 	zVarType 				; is it still an array ??
.019d2b	29 01		and #$01			and 	#1
.019d2d	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.019d2f	d0 05		bne $019d36			bne 	_VFArrayDone 			; if so then exit.
.019d31	20 41 9a	jsr $019a41			jsr 	CheckNextComma 			; comma should follow
.019d34	80 db		bra $019d11			bra 	_VFNextIndex
.019d36					_VFArrayDone:
.019d36	20 39 9a	jsr $019a39			jsr 	CheckNextRParen 		; check closing right bracket.
.019d39					_VFSingleElement:
.019d39	60		rts				rts
.019d3a					VariableClear:
.019d3a	48		pha				pha 							; save registers
.019d3b	da		phx				phx
.019d3c	a2 00		ldx #$00			ldx 	#0 						; clear out the hash table.
.019d3e	8a		txa				txa
.019d3f	9d 35 03	sta $0335,x	_VCLoop:sta 	HashTableBase,x
.019d42	e8		inx				inx
.019d43	e0 60		cpx #$60			cpx 	#HashTableEnd-HashTableBase
.019d45	d0 f8		bne $019d3f			bne 	_VCLoop
.019d47	a9 00		lda #$00			lda 	#VariableMemory & $FF
.019d49	8d 02 03	sta $0302			sta 	VarMemPtr
.019d4c	a9 30		lda #$30			lda 	#VariableMemory >> 8
.019d4e	8d 03 03	sta $0303			sta 	VarMemPtr+1
.019d51	fa		plx				plx 							; restore registers
.019d52	68		pla				pla
.019d53	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/extract.asm

.019d54					VariableNameError:
.019d54	20 86 85	jsr $018586			jsr ERR_Handler
>019d57	42 61 64 20 56 61 72 69			.text "Bad Variable Name",0
>019d5f	61 62 6c 65 20 4e 61 6d 65 00
.019d69					VariableExtract:
.019d69	da		phx				phx 							; save X.
.019d6a	a9 ba		lda #$ba			lda 	#token_hashlParen  		; set the type to #( e.g. real array.
.019d6c	8d 95 03	sta $0395			sta 	Var_Type
.019d6f	8d 96 03	sta $0396			sta 	Var_Hash 				; we initialise the hash with this. It doesn't matter
.019d72	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019d74	c9 00		cmp #$00			cmp 	#0 						; first one must be A-Z
.019d76	f0 dc		beq $019d54			beq 	VariableNameError
.019d78	c9 1b		cmp #$1b			cmp 	#26+1
.019d7a	b0 d8		bcs $019d54			bcs 	VariableNameError
.019d7c	a2 ff		ldx #$ff			ldx 	#255 					; now copy it into the variable buffer.
.019d7e					_VECopyBuffer:
.019d7e	e8		inx				inx
.019d7f	e0 1f		cpx #$1f			cpx 	#31 					; too long
.019d81	f0 d1		beq $019d54			beq 	VariableNameError
.019d83	9d 15 03	sta $0315,x			sta 	Var_Buffer,x 			; save character
.019d86	18		clc				clc  							; update the hash value for it.
.019d87	6d 96 03	adc $0396			adc 	Var_Hash
.019d8a	8d 96 03	sta $0396			sta 	Var_Hash
.019d8d	c8		iny				iny
.019d8e	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019d90	c9 00		cmp #$00			cmp 	#0 						; zero or token, end of variable
.019d92	f0 0e		beq $019da2			beq 	_VECopyEnd
.019d94	30 0c		bmi $019da2			bmi 	_VECopyEnd
.019d96	c9 1b		cmp #$1b			cmp 	#26+1 					; A-Z continue copying
.019d98	90 e4		bcc $019d7e			bcc 	_VECopyBuffer
.019d9a	c9 30		cmp #$30			cmp 	#"0" 					; 0-9 copy as well.
.019d9c	90 04		bcc $019da2			bcc 	_VECopyEnd
.019d9e	c9 3a		cmp #$3a			cmp 	#"9"+1
.019da0	90 dc		bcc $019d7e			bcc 	_VECopyBuffer
.019da2					_VECopyEnd:
.019da2	c8		iny				iny
.019da3	c9 b7		cmp #$b7			cmp 	#token_Dollar 			; first type token.
.019da5	90 04		bcc $019dab			bcc 	_VEDefaultRequired
.019da7	c9 bd		cmp #$bd			cmp 	#token_PercentLParen+1	; last type token.
.019da9	90 0b		bcc $019db6			bcc 	_VEHaveType
.019dab					_VEDefaultRequired:
.019dab	c9 bd		cmp #$bd			cmp 	#token_LParen 			; if it ends in ( then use the real array
.019dad	f0 04		beq $019db3			beq 	_VESetType 				; default set above.
.019daf	ce 95 03	dec $0395			dec 	Var_Type 				; this changes that default to the variable default
.019db2	88		dey				dey
.019db3					_VESetType:
.019db3	ad 95 03	lda $0395			lda 	Var_Type 				; get type ....
.019db6					_VEHaveType:
.019db6	8d 95 03	sta $0395			sta 	Var_Type 				; save as type.
.019db9	bd 15 03	lda $0315,x			lda 	Var_Buffer,x 			; set bit 7 of name, marks the end.
.019dbc	09 80		ora #$80			ora 	#$80
.019dbe	9d 15 03	sta $0315,x			sta 	Var_Buffer,x
.019dc1	e8		inx				inx 							; offset 3 => length 4.
.019dc2	8e 97 03	stx $0397			stx 	Var_Length 				; save length of variable name.
.019dc5	ad 95 03	lda $0395			lda 	Var_Type 				; get offset of var type from first type token
.019dc8	38		sec				sec
.019dc9	e9 b7		sbc #$b7			sbc 	#token_Dollar
.019dcb	0a		asl a				asl 	a 						; multiply by 16. This requires HashTableSize
.019dcc	0a		asl a				asl 	a 						; in data.asm to be 8 (8 sets of links,2 bytes each)
.019dcd	0a		asl a				asl 	a
.019dce	0a		asl a				asl 	a
.019dcf	8d 98 03	sta $0398			sta 	Var_HashAddress
.019dd2	ad 96 03	lda $0396			lda 	Var_Hash 				; get the hash
.019dd5	29 07		and #$07			and 	#(HashTableSize-1) 		; force into range 0-tableSize-1
.019dd7	0a		asl a				asl 	a 						; double it (2 bytes per entry) & clears carry
.019dd8	6d 98 03	adc $0398			adc 	Var_HashAddress 		; add table offset.
.019ddb	69 35		adc #$35			adc 	#HashTableBase & $FF 	; now the low byte of the actual table address
.019ddd	8d 98 03	sta $0398			sta 	Var_HashAddress
.019de0	a2 05		ldx #$05			ldx 	#5 						; hash is 5 bytes (real)
.019de2	ad 95 03	lda $0395			lda 	Var_Type
.019de5	c9 b9		cmp #$b9			cmp 	#token_Hash
.019de7	f0 07		beq $019df0			beq 	_VEHaveSize
.019de9	ca		dex				dex
.019dea	c9 bb		cmp #$bb			cmp 	#token_Percent 			; percent is 4 bytes (integer)
.019dec	f0 02		beq $019df0			beq 	_VEHaveSize
.019dee	a2 02		ldx #$02			ldx 	#2 						; everything else is two.
.019df0					_VEHaveSize:
.019df0	8e 99 03	stx $0399			stx 	Var_DataSize
.019df3	fa		plx				plx
.019df4	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varcreate.asm

.019df5					VariableCreate:
.019df5	da		phx				phx
.019df6	5a		phy				phy
.019df7	ad 02 03	lda $0302			lda 	VarMemPtr 					; get address of next free into zTemp1
.019dfa	85 10		sta $10				sta 	zTemp1
.019dfc	ad 03 03	lda $0303			lda 	VarMemPtr+1
.019dff	85 11		sta $11				sta 	zTemp1+1
.019e01	ad 99 03	lda $0399			lda 	Var_DataSize 				; bytes for the data bit
.019e04	18		clc				clc
.019e05	6d 97 03	adc $0397			adc 	Var_Length 					; add the length of the name
.019e08	69 03		adc #$03			adc 	#3 							; 3 for the link and the hash.
.019e0a	6d 02 03	adc $0302			adc 	VarMemPtr 					; add to variable memory pointer
.019e0d	8d 02 03	sta $0302			sta 	VarMemPtr
.019e10	90 03		bcc $019e15			bcc 	_VCNoCarry
.019e12	ee 03 03	inc $0303			inc 	VarMemPtr+1
.019e15					_VCNoCarry:
.019e15	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.019e18	85 12		sta $12				sta 	zTemp2
.019e1a	a9 03		lda #$03			lda 	#HashTableBase >> 8
.019e1c	85 13		sta $13				sta 	zTemp2+1
.019e1e	a0 00		ldy #$00			ldy 	#0 							; put current hash link in position.
.019e20	b1 12		lda ($12),y			lda 	(zTemp2),y
.019e22	91 10		sta ($10),y			sta 	(zTemp1),y
.019e24	c8		iny				iny
.019e25	b1 12		lda ($12),y			lda 	(zTemp2),y
.019e27	91 10		sta ($10),y			sta 	(zTemp1),y
.019e29	c8		iny				iny
.019e2a	ad 96 03	lda $0396			lda 	Var_Hash 					; write the hash out.
.019e2d	91 10		sta ($10),y			sta 	(zTemp1),y
.019e2f	c8		iny				iny
.019e30	a2 00		ldx #$00			ldx 	#0 							; copy the name out.
.019e32					_VCCopyName:
.019e32	bd 15 03	lda $0315,x			lda 	Var_Buffer,x
.019e35	91 10		sta ($10),y			sta 	(zTemp1),y
.019e37	e8		inx				inx
.019e38	c8		iny				iny
.019e39	ec 97 03	cpx $0397			cpx 	Var_Length
.019e3c	d0 f4		bne $019e32			bne 	_VCCopyName
.019e3e	5a		phy				phy 								; save the data offset.
.019e3f	ae 99 03	ldx $0399			ldx 	Var_DataSize 				; and write the data out.
.019e42	a9 00		lda #$00			lda 	#0 							; which is all zeroes.
.019e44					_VCClearData:
.019e44	91 10		sta ($10),y			sta 	(zTemp1),y
.019e46	c8		iny				iny
.019e47	ca		dex				dex
.019e48	d0 fa		bne $019e44			bne 	_VCClearData
.019e4a	68		pla				pla 								; offset to the data
.019e4b	18		clc				clc
.019e4c	65 10		adc $10				adc 	zTemp1 						; add to start and save as data pointer.
.019e4e	85 24		sta $24				sta 	zVarDataPtr
.019e50	a5 11		lda $11				lda 	zTemp1+1
.019e52	69 00		adc #$00			adc 	#0
.019e54	85 25		sta $25				sta 	zVarDataPtr+1
.019e56	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.019e59	85 26		sta $26				sta 	zVarType
.019e5b	a5 10		lda $10				lda 	zTemp1 						; fix hash link to point to new record
.019e5d	a0 00		ldy #$00			ldy 	#0
.019e5f	91 12		sta ($12),y			sta 	(zTemp2),y
.019e61	c8		iny				iny
.019e62	a5 11		lda $11				lda 	zTemp1+1
.019e64	91 12		sta ($12),y			sta 	(zTemp2),y
.019e66	ad 95 03	lda $0395			lda 	Var_Type 					; array ? if so create the empty one.
.019e69	29 01		and #$01			and 	#1
.019e6b	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.019e6d	d0 0e		bne $019e7d			bne 	_VCNotArray
.019e6f	a2 00		ldx #$00			ldx 	#0 							; call recursive array creator
.019e71	20 17 9f	jsr $019f17			jsr 	ArrayCreate
.019e74	5a		phy				phy 								; save YA at zVarDataPtr
.019e75	a0 00		ldy #$00			ldy 	#0
.019e77	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.019e79	c8		iny				iny
.019e7a	68		pla				pla
.019e7b	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.019e7d					_VCNotArray:
.019e7d	7a		ply				ply
.019e7e	fa		plx				plx
.019e7f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arrayidx.asm

.019e80					ArrayIndexFollow:
.019e80	5a		phy				phy
.019e81	a0 00		ldy #$00			ldy 	#0 							; make zVarDataPtr point to the array.
.019e83	b1 24		lda ($24),y			lda 	(zVarDataPtr),y 			; e.g. it points to itself.
.019e85	48		pha				pha
.019e86	c8		iny				iny
.019e87	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.019e89	85 25		sta $25				sta 	zVarDataPtr+1
.019e8b	68		pla				pla
.019e8c	85 24		sta $24				sta 	zVarDataPtr
.019e8e	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; MSB of 16 bit integer and bytes 2&3
.019e90	29 80		and #$80			and 	#$80 						; must be zero.
.019e92	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019e94	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019e96	d0 59		bne $019ef1			bne 	_AIFError
.019e98	a0 00		ldy #$00			ldy 	#0 							; calculate size - current - 1
.019e9a	18		clc				clc
.019e9b	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.019e9d	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.019e9f	c8		iny				iny
.019ea0	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.019ea2	08		php				php 								; clear bit 7 retaining borrow.
.019ea3	29 7f		and #$7f			and 	#$7F
.019ea5	28		plp				plp
.019ea6	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.019ea8	90 47		bcc $019ef1			bcc 	_AIFError 					; eror if size-current < 0
.019eaa	b5 80		lda $80,x			lda  	XS_Mantissa+0,x 			; copy and double the index
.019eac	0a		asl a				asl 	a 							; (e.g. index * 2)
.019ead	85 10		sta $10				sta 	zTemp1
.019eaf	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019eb1	2a		rol a				rol 	a
.019eb2	85 11		sta $11				sta 	zTemp1+1
.019eb4	a0 01		ldy #$01			ldy 	#1 							; is this a data entry.
.019eb6	b1 24		lda ($24),y			lda 	(zVarDataPtr),y 			; if so, then type is unchanged, offset set
.019eb8	30 1d		bmi $019ed7			bmi 	_AIFCalculate
.019eba	c6 26		dec $26				dec 	zVarType 					; converts from an array to a type.
.019ebc	a5 26		lda $26				lda 	zVarType 					; check that type
.019ebe	c9 b7		cmp #$b7			cmp 	#token_Dollar 				; if string, use x 2
.019ec0	f0 15		beq $019ed7			beq 	_AIFCalculate
.019ec2	06 10		asl $10				asl 	zTemp1			 			; double the index
.019ec4	26 11		rol $11				rol 	zTemp1+1					; (e.g. index * 4)
.019ec6	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if integer, use x 4
.019ec8	f0 0d		beq $019ed7			beq 	_AIFCalculate
.019eca	18		clc				clc 								; add the original mantissa in again
.019ecb	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; which makes it x5, for float.
.019ecd	65 10		adc $10				adc 	zTemp1
.019ecf	85 10		sta $10				sta 	zTemp1
.019ed1	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019ed3	65 11		adc $11				adc 	zTemp1+1
.019ed5	85 11		sta $11				sta 	zTemp1+1
.019ed7					_AIFCalculate:
.019ed7	18		clc				clc 								; add index x 2,4 or 5 to base
.019ed8	a5 24		lda $24				lda 	zVarDataPtr
.019eda	65 10		adc $10				adc 	zTemp1
.019edc	85 24		sta $24				sta 	zVarDataPtr
.019ede	a5 25		lda $25				lda 	zVarDataPtr+1
.019ee0	65 11		adc $11				adc 	zTemp1+1
.019ee2	85 25		sta $25				sta 	zVarDataPtr+1
.019ee4	18		clc				clc 								; add 2 more for the length prefix.
.019ee5	a5 24		lda $24				lda 	zVarDataPtr
.019ee7	69 02		adc #$02			adc 	#2
.019ee9	85 24		sta $24				sta 	zVarDataPtr
.019eeb	90 02		bcc $019eef			bcc 	_AIFNoBump
.019eed	e6 25		inc $25				inc 	zVarDataPtr+1
.019eef					_AIFNoBump:
.019eef	7a		ply				ply
.019ef0	60		rts				rts
.019ef1					_AIFError:
.019ef1	20 86 85	jsr $018586			jsr ERR_Handler
>019ef4	42 61 64 20 61 72 72 61			.text "Bad array index",0
>019efc	79 20 69 6e 64 65 78 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arraydef.asm

.019f04					ArrayResetDefault:
.019f04	a9 0b		lda #$0b			lda 	#11 						; 0..10 one array
.019f06	8d a9 03	sta $03a9			sta 	ArrayDef+0
.019f09	a9 00		lda #$00			lda 	#0
.019f0b	8d aa 03	sta $03aa			sta 	ArrayDef+1
.019f0e	a9 ff		lda #$ff			lda 	#$FF
.019f10	8d ab 03	sta $03ab			sta 	ArrayDef+2 					; $FFFF implies no second element.
.019f13	8d ac 03	sta $03ac			sta 	ArrayDef+3					; (test bit 7 of 2nd byte)
.019f16	60		rts				rts
.019f17					ArrayCreate:
.019f17	bd a9 03	lda $03a9,x			lda 	ArrayDef+0,x 				; put size x 2 in zTemp1
.019f1a	0a		asl a				asl 	a
.019f1b	85 10		sta $10				sta 	zTemp1
.019f1d	bd aa 03	lda $03aa,x			lda 	ArrayDef+1,x
.019f20	2a		rol a				rol 	a
.019f21	85 11		sta $11				sta 	zTemp1+1
.019f23	bd ac 03	lda $03ac,x			lda 	ArrayDef+3,x 				; if this is the last element it's array of ptrs.
.019f26	10 22		bpl $019f4a			bpl 	_ACSized 					; if not multiply size x 2 (str) 4 (int) 5 (real)
.019f28	ad 95 03	lda $0395			lda 	Var_Type 					; check the type
.019f2b	c9 b8		cmp #$b8			cmp 	#token_DollarLParen 		; also if it is an array of strings $(
.019f2d	f0 1b		beq $019f4a			beq 	_ACSized
.019f2f	06 10		asl $10				asl 	zTemp1 						; double again
.019f31	26 11		rol $11				rol 	zTemp1+1
.019f33	b0 6f		bcs $019fa4			bcs 	ArrayIndexError 			; too large.
.019f35	c9 bc		cmp #$bc			cmp 	#token_PercentLParen 		; if %( four bytes/entry is enough.
.019f37	f0 11		beq $019f4a			beq 	_ACSized
.019f39	18		clc				clc 								; add original value x 5 for reals.
.019f3a	a5 10		lda $10				lda 	zTemp1
.019f3c	7d a9 03	adc $03a9,x			adc 	ArrayDef+0,x
.019f3f	85 10		sta $10				sta 	zTemp1
.019f41	a5 11		lda $11				lda 	zTemp1+1
.019f43	7d aa 03	adc $03aa,x			adc 	ArrayDef+1,x
.019f46	85 11		sta $11				sta 	zTemp1+1
.019f48	b0 5a		bcs $019fa4			bcs 	ArrayIndexError
.019f4a					_ACSized:
.019f4a	18		clc				clc
.019f4b	a5 10		lda $10				lda 	zTemp1
.019f4d	69 02		adc #$02			adc 	#2
.019f4f	85 10		sta $10				sta 	zTemp1
.019f51	90 04		bcc $019f57			bcc 	_ACNoBump
.019f53	e6 10		inc $10				inc 	zTemp1
.019f55	f0 4d		beq $019fa4			beq 	ArrayIndexError
.019f57					_ACNoBump:
.019f57	18		clc				clc
.019f58	ad 02 03	lda $0302			lda 	VarMemPtr 					; add this allocated count to VarMemPtr
.019f5b	85 12		sta $12				sta 	zTemp2						; save start in zTemp2/zTemp3
.019f5d	85 14		sta $14				sta 	zTemp3
.019f5f	65 10		adc $10				adc 	zTemp1
.019f61	8d 02 03	sta $0302			sta 	VarMemPtr
.019f64	ad 03 03	lda $0303			lda 	VarMemPtr+1
.019f67	85 13		sta $13				sta 	zTemp2+1
.019f69	85 15		sta $15				sta 	zTemp3+1
.019f6b	65 11		adc $11				adc 	zTemp1+1
.019f6d	8d 03 03	sta $0303			sta 	VarMemPtr+1
.019f70	85 11		sta $11				sta 	zTemp1+1
.019f72	b0 30		bcs $019fa4			bcs 	ArrayIndexError
.019f74	a0 00		ldy #$00			ldy 	#0							; write $00 out.
.019f76					_ACClear:
.019f76	98		tya				tya
.019f77	91 12		sta ($12),y			sta 	(zTemp2),y
.019f79	e6 12		inc $12				inc 	zTemp2
.019f7b	d0 02		bne $019f7f			bne 	_ACCBump
.019f7d	e6 13		inc $13				inc 	zTemp2+1
.019f7f					_ACCBump:
.019f7f	a5 12		lda $12				lda 	zTemp2
.019f81	cd 02 03	cmp $0302			cmp 	VarMemPtr
.019f84	d0 f0		bne $019f76			bne 	_ACClear
.019f86	a5 13		lda $13				lda 	zTemp2+1
.019f88	cd 03 03	cmp $0303			cmp 	VarMemPtr+1
.019f8b	d0 e9		bne $019f76			bne 	_ACClear
.019f8d	a0 00		ldy #$00			ldy 	#0
.019f8f	bd a9 03	lda $03a9,x			lda 	ArrayDef+0,x 				; copy the size into the start
.019f92	91 14		sta ($14),y			sta 	(zTemp3),y
.019f94	c8		iny				iny
.019f95	bd aa 03	lda $03aa,x			lda 	ArrayDef+1,x
.019f98	91 14		sta ($14),y			sta 	(zTemp3),y
.019f9a	bd ac 03	lda $03ac,x			lda 	ArrayDef+3,x 				; have we reached the end
.019f9d	10 18		bpl $019fb7			bpl 	ACCFillRecursive
.019f9f	a4 15		ldy $15				ldy 	zTemp3+1 					; return address
.019fa1	a5 14		lda $14				lda 	zTemp3
.019fa3	60		rts				rts
.019fa4					ArrayIndexError:
.019fa4	20 86 85	jsr $018586			jsr ERR_Handler
>019fa7	42 61 64 20 61 72 72 61			.text "Bad array index",0
>019faf	79 20 69 6e 64 65 78 00
.019fb7					ACCFillRecursive:
.019fb7	a9 ff		lda #$ff			lda 	#$FF 						; we mark the end, this is free space.
.019fb9	a0 00		ldy #$00			ldy 	#0 							; this is overwritten by size of next allocated
.019fbb	91 12		sta ($12),y			sta 	(zTemp2),y 					; array, but we might change that.
.019fbd	c8		iny				iny
.019fbe	b1 14		lda ($14),y			lda 	(zTemp3),y 					; set bit 15 of the max index indicating
.019fc0	09 80		ora #$80			ora 	#$80 						; an array of pointers
.019fc2	91 14		sta ($14),y			sta 	(zTemp3),y
.019fc4	a5 14		lda $14				lda 	zTemp3 						; push the start on the stack
.019fc6	48		pha				pha
.019fc7	a5 15		lda $15				lda 	zTemp3+1
.019fc9	48		pha				pha
.019fca					_ACCFillLoop:
.019fca	18		clc				clc
.019fcb	a5 14		lda $14				lda 	zTemp3 						; and work forwards.
.019fcd	69 02		adc #$02			adc 	#2
.019fcf	85 14		sta $14				sta 	zTemp3
.019fd1	90 02		bcc $019fd5			bcc 	_ACCSkip2
.019fd3	e6 15		inc $15				inc 	zTemp3+1
.019fd5					_ACCSkip2:
.019fd5	a0 00		ldy #$00			ldy 	#0 							; reached the end ?
.019fd7	b1 14		lda ($14),y			lda 	(zTemp3),y					; (looking for FF marker, everything else 00)
.019fd9	c8		iny				iny
.019fda	11 14		ora ($14),y			ora 	(zTemp3),y
.019fdc	d0 21		bne $019fff			bne 	_ACCExit
.019fde	a5 14		lda $14				lda 	zTemp3 						; push zTemp3
.019fe0	48		pha				pha
.019fe1	a5 15		lda $15				lda 	zTemp3+1
.019fe3	48		pha				pha
.019fe4	e8		inx				inx
.019fe5	e8		inx				inx
.019fe6	20 17 9f	jsr $019f17			jsr 	ArrayCreate 				; create array recursively.
.019fe9	ca		dex				dex
.019fea	ca		dex				dex
.019feb	85 12		sta $12				sta 	zTemp2 						; save A
.019fed	68		pla				pla
.019fee	85 15		sta $15				sta 	zTemp3+1 					; restore zTemp3
.019ff0	68		pla				pla
.019ff1	85 14		sta $14				sta 	zTemp3
.019ff3	98		tya				tya 								; write high bye from Y
.019ff4	a0 01		ldy #$01			ldy 	#1
.019ff6	91 14		sta ($14),y			sta 	(zTemp3),y
.019ff8	88		dey				dey 								; write low byte out.
.019ff9	a5 12		lda $12				lda 	zTemp2
.019ffb	91 14		sta ($14),y			sta 	(zTemp3),y
.019ffd	80 cb		bra $019fca			bra 	_ACCFillLoop 				; and try again.
.019fff					_ACCExit:
.019fff	7a		ply				ply 								; restore the original address
.01a000	68		pla				pla
.01a001	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varfind.asm

.01a002					VariableLocate:
.01a002	da		phx				phx
.01a003	5a		phy				phy
.01a004	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.01a007	85 12		sta $12				sta 	zTemp2 						; points to first address.
.01a009	a9 03		lda #$03			lda 	#HashTableBase >> 8
.01a00b	85 13		sta $13				sta 	zTemp2+1
.01a00d	a0 00		ldy #$00	_VLNext:ldy 	#0 							; get next link into AX
.01a00f	b1 12		lda ($12),y			lda 	(zTemp2),y
.01a011	aa		tax				tax
.01a012	c8		iny				iny
.01a013	b1 12		lda ($12),y			lda 	(zTemp2),y
.01a015	85 13		sta $13				sta 	zTemp2+1 					; save in zTemp
.01a017	86 12		stx $12				stx 	zTemp2
.01a019	05 12		ora $12				ora 	zTemp2 						; got zero
.01a01b	18		clc				clc
.01a01c	f0 25		beq $01a043			beq 	_VLExit 					; if so, then fail as end of chain.
.01a01e	c8		iny				iny 								; point to hash (offset + 2)
.01a01f	b1 12		lda ($12),y			lda 	(zTemp2),y
.01a021	cd 96 03	cmp $0396			cmp 	Var_Hash
.01a024	d0 e7		bne $01a00d			bne 	_VLNext 					; try next if different.
.01a026					_VLCompare:
.01a026	c8		iny				iny 								; next character
.01a027	b1 12		lda ($12),y			lda 	(zTemp2),y 					; compare variable field against buffer.
.01a029	d9 12 03	cmp $0312,y			cmp 	Var_Buffer-3,y 				; the -3 is because name starts at 3.
.01a02c	d0 df		bne $01a00d			bne 	_VLNext 					; fail if different, try next.
.01a02e	0a		asl a				asl 	a 							; until end character (bit 7 set) matched
.01a02f	90 f5		bcc $01a026			bcc 	_VLCompare
.01a031	98		tya				tya
.01a032	38		sec				sec 								; add 1 as Y points to last character
.01a033	65 12		adc $12				adc 	zTemp2 						; add to the current address
.01a035	85 24		sta $24				sta 	zVarDataPtr
.01a037	a5 13		lda $13				lda 	zTemp2+1
.01a039	69 00		adc #$00			adc 	#0
.01a03b	85 25		sta $25				sta 	zVarDataPtr+1
.01a03d	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.01a040	85 26		sta $26				sta 	zVarType
.01a042	38		sec				sec 								; return CS
.01a043	7a		ply		_VLExit:ply
.01a044	fa		plx				plx
.01a045	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/vargetset.asm

.01a046					VariableGet:
.01a046	5a		phy				phy
.01a047	a0 00		ldy #$00			ldy 	#0 							; copy first two bytes
.01a049	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.01a04b	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a04d	c8		iny				iny
.01a04e	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.01a050	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a052	c8		iny				iny
.01a053	a5 26		lda $26				lda 	zVarType 					; if it is a string, set up for that.
.01a055	c9 b7		cmp #$b7			cmp 	#token_Dollar
.01a057	f0 2c		beq $01a085			beq 	_VGString
.01a059	b1 24		lda ($24),y			lda 	(zVarDataPtr),y 			; copy the next two bytes.
.01a05b	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a05d	c8		iny				iny
.01a05e	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.01a060	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a062	c8		iny				iny
.01a063	a9 01		lda #$01			lda 	#1 							; set type to 1.
.01a065	95 85		sta $85,x			sta 	XS_Type,x
.01a067	a5 26		lda $26				lda 	zVarType
.01a069	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if it is a %, then exit with default integer.
.01a06b	f0 28		beq $01a095			beq 	_VGExit
.01a06d	a9 40		lda #$40			lda 	#$40 						; set type byte to zero
.01a06f	95 85		sta $85,x			sta 	XS_Type,x 					; which is the code for zero/float.
.01a071	b1 24		lda ($24),y			lda 	(zVarDataPtr),y 			; the last value to copy is the exponent.
.01a073	95 84		sta $84,x			sta 	XS_Exponent,x
.01a075	f0 1e		beq $01a095			beq 	_VGExit 					; if exponent is zero ... it's zero.
.01a077	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; the sign bit is the top mantissa bit.
.01a079	48		pha				pha
.01a07a	29 80		and #$80			and 	#$80
.01a07c	95 85		sta $85,x			sta 	XS_Type,x 					; this is the type byte.
.01a07e	68		pla				pla
.01a07f	09 80		ora #$80			ora 	#$80 						; set the MSB as you would expect.
.01a081	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; so it's a normalised float.
.01a083	80 10		bra $01a095			bra 	_VGExit
.01a085					_VGString:
.01a085	a9 02		lda #$02			lda 	#2 							; set type to 2, a string
.01a087	95 85		sta $85,x			sta 	XS_Type,x
.01a089	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; is the value there $0000
.01a08b	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.01a08d	d0 06		bne $01a095			bne 	_VGExit 					; if not, exit.
.01a08f	85 27		sta $27				sta 	zNullString 				; make zNullString a 00 string.
.01a091	a9 27		lda #$27			lda 	#zNullString
.01a093	95 80		sta $80,x			sta 	XS_Mantissa,x 				; make it point to it.
.01a095					_VGExit:
.01a095	7a		ply				ply
.01a096	60		rts				rts
.01a097					VariableSet:
.01a097	b5 85		lda $85,x			lda 	XS_Type,x 					; is the result a string
.01a099	29 02		and #$02			and 	#2 							; if so, it has to be
.01a09b	d0 4b		bne $01a0e8			bne 	_VSString
.01a09d	a5 26		lda $26				lda 	zVarType 					; if type is $ there's an error.
.01a09f	c9 b7		cmp #$b7			cmp 	#token_Dollar
.01a0a1	f0 42		beq $01a0e5			beq 	_VSBadType
.01a0a3	c9 bb		cmp #$bb			cmp 	#token_Percent 				; type convert to float/int
.01a0a5	f0 05		beq $01a0ac			beq 	_VSMakeInt
.01a0a7	20 0f a6	jsr $01a60f			jsr 	FPUToFloat
.01a0aa	80 03		bra $01a0af			bra 	_VSCopy
.01a0ac					_VSMakeInt:
.01a0ac	20 5b a6	jsr $01a65b			jsr 	FPUToInteger
.01a0af					_VSCopy:
.01a0af	5a		phy				phy
.01a0b0	a0 00		ldy #$00			ldy 	#0 							; copy mantissa to target.
.01a0b2	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01a0b4	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a0b6	c8		iny				iny
.01a0b7	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a0b9	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a0bb	c8		iny				iny
.01a0bc	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a0be	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a0c0	c8		iny				iny
.01a0c1	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a0c3	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a0c5	a5 26		lda $26				lda 	zVarType 					; if target is integer, alrady done.
.01a0c7	c9 bb		cmp #$bb			cmp 	#token_Percent
.01a0c9	f0 18		beq $01a0e3			beq 	_VSExit
.01a0cb	b5 85		lda $85,x			lda 	XS_Type,x 					; get the sign bit into carry flag.
.01a0cd	0a		asl a				asl 	a
.01a0ce	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; shift the sign into the mantissa high.
.01a0d0	08		php				php
.01a0d1	0a		asl a				asl 	a
.01a0d2	28		plp				plp
.01a0d3	6a		ror a				ror 	a
.01a0d4	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a0d6	c8		iny				iny
.01a0d7	b5 84		lda $84,x			lda 	XS_Exponent,x 				; copy the exponent in
.01a0d9	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a0db	34 85		bit $85,x			bit 	XS_Type,x 					; if the result is non zero
.01a0dd	50 04		bvc $01a0e3			bvc 	_VSExit
.01a0df	a9 00		lda #$00			lda 	#0 							; zero exponent indicating 0.
.01a0e1	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a0e3					_VSExit:
.01a0e3	7a		ply				ply
.01a0e4	60		rts				rts
.01a0e5					_VSBadType:
.01a0e5	4c 67 85	jmp $018567			jmp 	TypeError
.01a0e8					_VSString:
.01a0e8	a5 26		lda $26				lda 	zVarType 					; type must be $
.01a0ea	c9 b7		cmp #$b7			cmp 	#token_Dollar
.01a0ec	d0 f7		bne $01a0e5			bne 	_VSBadType
.01a0ee	da		phx				phx
.01a0ef	5a		phy				phy
.01a0f0	20 49 9a	jsr $019a49			jsr 	StringConcrete 				; concrete the string in the mantissa -> AX
.01a0f3	a0 01		ldy #$01			ldy 	#1 							; save high byte
.01a0f5	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a0f7	88		dey				dey 								; save low byte
.01a0f8	8a		txa				txa
.01a0f9	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a0fb	7a		ply				ply 								; and exit.
.01a0fc	fa		plx				plx
.01a0fd	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.01a0fe					MulInteger32:
.01a0fe	b5 80		lda $80,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.01a100	95 8c		sta $8c,x			sta 	XS3_Mantissa,x
.01a102	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a104	95 8d		sta $8d,x			sta 	XS3_Mantissa+1,x
.01a106	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a108	95 8e		sta $8e,x			sta 	XS3_Mantissa+2,x
.01a10a	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a10c	95 8f		sta $8f,x			sta 	XS3_Mantissa+3,x
.01a10e	a9 00		lda #$00			lda 	#0
.01a110	95 80		sta $80,x			sta 	XS_Mantissa+0,x 				; zero +0, where the result goes.
.01a112	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a114	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a116	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a118					_BFMMultiply:
.01a118	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.01a11a	29 01		and #$01			and 	#1
.01a11c	f0 03		beq $01a121			beq 	_BFMNoAdd
.01a11e	20 85 95	jsr $019585			jsr 	AddInteger32 					; co-opt this code
.01a121					_BFMNoAdd:
.01a121	16 86		asl $86,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.01a123	36 87		rol $87,x			rol 	XS2_Mantissa+1,x
.01a125	36 88		rol $88,x			rol 	XS2_Mantissa+2,x
.01a127	36 89		rol $89,x			rol 	XS2_Mantissa+3,x
.01a129	56 8f		lsr $8f,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.01a12b	76 8e		ror $8e,x			ror 	XS3_Mantissa+2,x
.01a12d	76 8d		ror $8d,x			ror 	XS3_Mantissa+1,x
.01a12f	76 8c		ror $8c,x			ror 	XS3_Mantissa,x
.01a131	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.01a133	15 8d		ora $8d,x			ora 	XS3_Mantissa+1,x
.01a135	15 8e		ora $8e,x			ora 	XS3_Mantissa+2,x
.01a137	15 8f		ora $8f,x			ora 	XS3_Mantissa+3,x
.01a139	d0 dd		bne $01a118			bne 	_BFMMultiply
.01a13b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.01a13c					DivInteger32:
.01a13c	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; check for division by zero.
.01a13e	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.01a140	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.01a142	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.01a144	d0 14		bne $01a15a			bne 	_BFDOkay
.01a146	20 86 85	jsr $018586			jsr ERR_Handler
>01a149	44 69 76 69 73 69 6f 6e			.text "Division by Zero",0
>01a151	20 62 79 20 5a 65 72 6f 00
.01a15a					_BFDOkay:
.01a15a	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.01a15c	85 1c		sta $1c				sta 	zLTemp1 					; Q/Dividend/Left in +0
.01a15e	85 1d		sta $1d				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.01a160	85 1e		sta $1e				sta 	zLTemp1+2
.01a162	85 1f		sta $1f				sta 	zLTemp1+3
.01a164	8d 9e 03	sta $039e			sta 	SignCount 					; Count of signs.
.01a167	20 be a1	jsr $01a1be			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.01a16a	da		phx				phx
.01a16b	e8		inx				inx
.01a16c	e8		inx				inx
.01a16d	e8		inx				inx
.01a16e	e8		inx				inx
.01a16f	e8		inx				inx
.01a170	e8		inx				inx
.01a171	20 be a1	jsr $01a1be			jsr 	CheckIntegerNegate
.01a174	fa		plx				plx
.01a175	5a		phy				phy 								; Y is the counter
.01a176	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.01a178					_BFDLoop:
.01a178	16 80		asl $80,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.01a17a	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.01a17c	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.01a17e	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.01a180	26 1c		rol $1c				rol 	zLTemp1
.01a182	26 1d		rol $1d				rol 	zLTemp1+1
.01a184	26 1e		rol $1e				rol 	zLTemp1+2
.01a186	26 1f		rol $1f				rol 	zLTemp1+3
.01a188	38		sec				sec
.01a189	a5 1c		lda $1c				lda 	zLTemp1+0 					; Calculate A-M on stack.
.01a18b	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.01a18d	48		pha				pha
.01a18e	a5 1d		lda $1d				lda 	zLTemp1+1
.01a190	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.01a192	48		pha				pha
.01a193	a5 1e		lda $1e				lda 	zLTemp1+2
.01a195	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.01a197	48		pha				pha
.01a198	a5 1f		lda $1f				lda 	zLTemp1+3
.01a19a	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.01a19c	90 13		bcc $01a1b1			bcc 	_BFDNoAdd
.01a19e	85 1f		sta $1f				sta 	zLTemp1+3 					; update A
.01a1a0	68		pla				pla
.01a1a1	85 1e		sta $1e				sta 	zLTemp1+2
.01a1a3	68		pla				pla
.01a1a4	85 1d		sta $1d				sta 	zLTemp1+1
.01a1a6	68		pla				pla
.01a1a7	85 1c		sta $1c				sta 	zLTemp1+0
.01a1a9	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.01a1ab	09 01		ora #$01			ora 	#1
.01a1ad	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a1af	80 03		bra $01a1b4			bra 	_BFDNext
.01a1b1					_BFDNoAdd:
.01a1b1	68		pla				pla 								; Throw away the intermediate calculations
.01a1b2	68		pla				pla
.01a1b3	68		pla				pla
.01a1b4					_BFDNext:
.01a1b4	88		dey				dey
.01a1b5	d0 c1		bne $01a178			bne 	_BFDLoop
.01a1b7	7a		ply				ply 								; restore Y
.01a1b8	4e 9e 03	lsr $039e			lsr 	SignCount 					; if sign count odd,
.01a1bb	b0 06		bcs $01a1c3			bcs		IntegerNegateAlways 		; negate the result
.01a1bd	60		rts				rts
.01a1be					CheckIntegerNegate:
.01a1be	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; is it -ve = MSB set ?
.01a1c0	30 01		bmi $01a1c3			bmi 	IntegerNegateAlways 		; if so negate it
.01a1c2	60		rts				rts
.01a1c3					IntegerNegateAlways:
.01a1c3	ee 9e 03	inc $039e			inc 	SignCount 					; bump the count of signs
.01a1c6	38		sec				sec 								; 0-mantissa,x -> mantissa,x
.01a1c7	a9 00		lda #$00			lda 	#0
.01a1c9	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.01a1cb	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a1cd	a9 00		lda #$00			lda 	#0
.01a1cf	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.01a1d1	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a1d3	a9 00		lda #$00			lda 	#0
.01a1d5	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.01a1d7	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a1d9	a9 00		lda #$00			lda 	#0
.01a1db	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.01a1dd	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a1df	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.01a1e0					INTToString:
.01a1e0	48		pha				pha
.01a1e1	5a		phy				phy
.01a1e2	b5 83		lda $83,x			lda 		XS_Mantissa+3,x 		; check -ve
.01a1e4	10 08		bpl $01a1ee			bpl 		_ITSNotMinus
.01a1e6	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.01a1e8	20 82 a2	jsr $01a282			jsr 		ITSOutputCharacter
.01a1eb	20 c3 a1	jsr $01a1c3			jsr 		IntegerNegateAlways 	; negate the number.
.01a1ee					_ITSNotMinus:
.01a1ee	a9 00		lda #$00			lda 		#0
.01a1f0	8d 9a 03	sta $039a			sta 		NumSuppress 			; clear the suppression flag.
.01a1f3	8a		txa				txa 								; use Y for the mantissa index.
.01a1f4	a8		tay				tay
.01a1f5	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.01a1f7					_ITSNextSubtractor:
.01a1f7	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.01a1f9	8d 9b 03	sta $039b			sta 		NumConvCount
.01a1fc					_ITSSubtract:
.01a1fc	38		sec				sec
.01a1fd	b9 80 00	lda $0080,y			lda 		XS_Mantissa,y 			; subtract number and push on stack
.01a200	ff 5e a2 01	sbc $01a25e,x			sbc 		_ITSSubtractors+0,x
.01a204	48		pha				pha
.01a205	b9 81 00	lda $0081,y			lda 		XS_Mantissa+1,y
.01a208	ff 5f a2 01	sbc $01a25f,x			sbc 		_ITSSubtractors+1,x
.01a20c	48		pha				pha
.01a20d	b9 82 00	lda $0082,y			lda 		XS_Mantissa+2,y
.01a210	ff 60 a2 01	sbc $01a260,x			sbc 		_ITSSubtractors+2,x
.01a214	48		pha				pha
.01a215	b9 83 00	lda $0083,y			lda 		XS_Mantissa+3,y
.01a218	ff 61 a2 01	sbc $01a261,x			sbc 		_ITSSubtractors+3,x
.01a21c	90 14		bcc $01a232			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.01a21e	99 83 00	sta $0083,y			sta 		XS_Mantissa+3,y 		; save subtract off stack
.01a221	68		pla				pla
.01a222	99 82 00	sta $0082,y			sta 		XS_Mantissa+2,y
.01a225	68		pla				pla
.01a226	99 81 00	sta $0081,y			sta 		XS_Mantissa+1,y
.01a229	68		pla				pla
.01a22a	99 80 00	sta $0080,y			sta 		XS_Mantissa+0,y
.01a22d	ee 9b 03	inc $039b			inc 		NumConvCount 			; bump count.
.01a230	80 ca		bra $01a1fc			bra 		_ITSSubtract 			; go round again.
.01a232					_ITSCantSubtract:
.01a232	68		pla				pla 								; throw away interim answers
.01a233	68		pla				pla
.01a234	68		pla				pla
.01a235	ad 9b 03	lda $039b			lda 		NumConvCount 			; if not zero then no suppression check
.01a238	c9 30		cmp #$30			cmp 		#"0"
.01a23a	d0 05		bne $01a241			bne 		_ITSOutputDigit
.01a23c	ad 9a 03	lda $039a			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.01a23f	10 09		bpl $01a24a			bpl	 		_ITSGoNextSubtractor
.01a241					_ITSOutputDigit:
.01a241	ce 9a 03	dec $039a			dec 		NumSuppress 			; suppression check will be non-zero.
.01a244	ad 9b 03	lda $039b			lda 		NumConvCount 			; count of subtractions
.01a247	20 82 a2	jsr $01a282			jsr 		ITSOutputCharacter 		; output it.
.01a24a					_ITSGoNextSubtractor:
.01a24a	e8		inx				inx 								; next dword
.01a24b	e8		inx				inx
.01a24c	e8		inx				inx
.01a24d	e8		inx				inx
.01a24e	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.01a250	d0 a5		bne $01a1f7			bne 		_ITSNextSubtractor 		; do all the subtractors.
.01a252	98		tya				tya 								; X is back as the mantissa index
.01a253	aa		tax				tax
.01a254	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.01a256	09 30		ora #$30			ora 		#"0"
.01a258	20 82 a2	jsr $01a282			jsr 		ITSOutputCharacter
.01a25b	7a		ply				ply 								; and exit
.01a25c	68		pla				pla
.01a25d	60		rts				rts
.01a25e					_ITSSubtractors:
>01a25e	00 ca 9a 3b					.dword 		1000000000
>01a262	00 e1 f5 05					.dword 		100000000
>01a266	80 96 98 00					.dword 		10000000
>01a26a	40 42 0f 00					.dword 		1000000
>01a26e	a0 86 01 00					.dword 		100000
>01a272	10 27 00 00					.dword 		10000
>01a276	e8 03 00 00					.dword 		1000
>01a27a	64 00 00 00					.dword 		100
>01a27e	0a 00 00 00					.dword 		10
.01a282					_ITSSubtractorsEnd:
.01a282					ITSOutputCharacter:
.01a282	48		pha				pha
.01a283	da		phx				phx
.01a284	ae 14 03	ldx $0314			ldx 	NumBufX 					; save digit
.01a287	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.01a28a	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.01a28c	9d 16 03	sta $0316,x			sta 	Num_Buffer+1,x
.01a28f	ee 14 03	inc $0314			inc 	NumBufX						; bump pointer.
.01a292	fa		plx				plx
.01a293	68		pla				pla
.01a294	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.01a295					IntFromString:
.01a295	a0 00		ldy #$00			ldy 	#0
.01a297					IntFromStringY:
.01a297	a9 00		lda #$00			lda 	#0
.01a299	8d 9c 03	sta $039c			sta 	ExpTemp 					; this is the converted digit count.
.01a29c	48		pha				pha
.01a29d	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.01a29f	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a2a1	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a2a3	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a2a5	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a2a7	a9 01		lda #$01			lda 	#1
.01a2a9	95 85		sta $85,x			sta 	XS_Type,x
.01a2ab					_IFSLoop:
.01a2ab	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; get next
.01a2ad	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.01a2af	90 4e		bcc $01a2ff			bcc 	_IFSExit
.01a2b1	c9 3a		cmp #$3a			cmp 	#"9"+1
.01a2b3	b0 4a		bcs $01a2ff			bcs 	_IFSExit
.01a2b5	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.01a2b7	c9 0c		cmp #$0c			cmp 	#12
.01a2b9	b0 4e		bcs $01a309			bcs 	_IFSOverflow
.01a2bb	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.01a2bd	48		pha				pha
.01a2be	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a2c0	48		pha				pha
.01a2c1	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a2c3	48		pha				pha
.01a2c4	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01a2c6	48		pha				pha
.01a2c7	20 1e a3	jsr $01a31e			jsr 	IFSX1ShiftLeft 				; double
.01a2ca	20 1e a3	jsr $01a31e			jsr 	IFSX1ShiftLeft 				; x 4
.01a2cd	18		clc				clc 								; add saved value x 5
.01a2ce	68		pla				pla
.01a2cf	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.01a2d1	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a2d3	68		pla				pla
.01a2d4	75 81		adc $81,x			adc 	XS_Mantissa+1,x
.01a2d6	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a2d8	68		pla				pla
.01a2d9	75 82		adc $82,x			adc 	XS_Mantissa+2,x
.01a2db	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a2dd	68		pla				pla
.01a2de	75 83		adc $83,x			adc 	XS_Mantissa+3,x
.01a2e0	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a2e2	20 1e a3	jsr $01a31e			jsr 	IFSX1ShiftLeft 				; x 10
.01a2e5	ee 9c 03	inc $039c			inc 	ExpTemp 					; bump count of digits processed.
.01a2e8	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; add digit
.01a2ea	29 0f		and #$0f			and 	#15
.01a2ec	c8		iny				iny
.01a2ed	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.01a2ef	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a2f1	90 b8		bcc $01a2ab			bcc 	_IFSLoop
.01a2f3	f6 81		inc $81,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.01a2f5	d0 b4		bne $01a2ab			bne 	_IFSLoop
.01a2f7	f6 82		inc $82,x			inc 	XS_Mantissa+2,x
.01a2f9	d0 b0		bne $01a2ab			bne 	_IFSLoop
.01a2fb	f6 83		inc $83,x			inc 	XS_Mantissa+3,x
.01a2fd	80 ac		bra $01a2ab			bra 	_IFSLoop
.01a2ff					_IFSExit:
.01a2ff	98		tya				tya 								; get offset
.01a300					_IFSOkay:
.01a300	38		sec				sec
.01a301	ad 9c 03	lda $039c			lda 	ExpTemp
.01a304	f0 01		beq $01a307			beq 	_IFSSkipFail
.01a306	18		clc				clc
.01a307					_IFSSkipFail:
.01a307	68		pla				pla 								; and exit.
.01a308	60		rts				rts
.01a309					_IFSOverflow:
.01a309	20 86 85	jsr $018586			jsr 	ERR_Handler
>01a30c	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>01a314	20 6f 76 65 72 66 6c 6f 77 00
.01a31e					IFSX1ShiftLeft:
.01a31e	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.01a320	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.01a322	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.01a324	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.01a326	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.01a327					FPSubtract:
.01a327	48		pha				pha
.01a328	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.01a32a	49 80		eor #$80			eor 	#$80
.01a32c	95 8b		sta $8b,x			sta 	XS2_Type,x
.01a32e	68		pla				pla 								; --- and fall through ---
.01a32f					FPAdd:
.01a32f	48		pha				pha
.01a330	b5 85		lda $85,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.01a332	d0 05		bne $01a339			bne 	_FPA_NegativeLHS
.01a334	20 50 a3	jsr $01a350			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.01a337	68		pla				pla
.01a338	60		rts				rts
.01a339					_FPA_NegativeLHS:
.01a339	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.01a33b	49 80		eor #$80			eor 	#$80
.01a33d	95 85		sta $85,x			sta 	XS_Type,x
.01a33f	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of B and add
.01a341	49 80		eor #$80			eor 	#$80
.01a343	95 8b		sta $8b,x			sta 	XS2_Type,x
.01a345	20 50 a3	jsr $01a350			jsr 	FPAdd_Worker 				; do the add calculation.
.01a348	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 back
.01a34a	49 80		eor #$80			eor 	#$80
.01a34c	95 85		sta $85,x			sta 	XS_Type,x
.01a34e	68		pla				pla
.01a34f	60		rts				rts
.01a350					FPAdd_Worker:
.01a350	34 8b		bit $8b,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.01a352	70 07		bvs $01a35b			bvs 	_FPAWExit 					; no change.
.01a354	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.01a356	50 07		bvc $01a35f			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.01a358	20 cd a5	jsr $01a5cd			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.01a35b					_FPAWExit:
.01a35b	20 3c a6	jsr $01a63c			jsr 	FPUNormalise 				; normalise the result.
.01a35e	60		rts				rts
.01a35f					_FPAWMakeSame:
.01a35f	b5 84		lda $84,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.01a361	38		sec				sec
.01a362	f5 8a		sbc $8a,x			sbc	 	XS2_Exponent,x 				; using subtraction
.01a364	f0 16		beq $01a37c			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.01a366	da		phx				phx 								; save X
.01a367	90 06		bcc $01a36f			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.01a369	e8		inx				inx
.01a36a	e8		inx				inx
.01a36b	e8		inx				inx
.01a36c	e8		inx				inx
.01a36d	e8		inx				inx
.01a36e	e8		inx				inx
.01a36f					_FPAWShiftA:
.01a36f	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.01a371	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.01a373	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a375	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a377	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a379	fa		plx				plx 								; restore original X
.01a37a	80 e3		bra $01a35f			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.01a37c					_FPAW_DoArithmetic:
.01a37c	34 8b		bit $8b,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.01a37e	30 28		bmi $01a3a8			bmi 	_FPAW_BNegative
.01a380	18		clc				clc
.01a381	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01a383	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.01a385	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a387	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a389	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.01a38b	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a38d	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a38f	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.01a391	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a393	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a395	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.01a397	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a399	90 c0		bcc $01a35b			bcc 	_FPAWExit 					; no carry.
.01a39b	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.01a39d	38		sec				sec
.01a39e	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.01a3a0	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a3a2	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a3a4	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a3a6	80 b3		bra $01a35b			bra 	_FPAWExit
.01a3a8					_FPAW_BNegative:
.01a3a8	38		sec				sec
.01a3a9	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01a3ab	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.01a3ad	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a3af	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a3b1	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.01a3b3	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a3b5	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a3b7	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.01a3b9	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a3bb	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a3bd	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.01a3bf	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a3c1	b0 09		bcs $01a3cc			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.01a3c3	20 f3 a5	jsr $01a5f3			jsr 	FPUNegateInteger			; negate the mantissa
.01a3c6	b5 85		lda $85,x			lda 	XS_Type,x 					; flip result sign
.01a3c8	49 80		eor #$80			eor 	#$80
.01a3ca	95 85		sta $85,x			sta 	XS_Type,x
.01a3cc					_FPAWGoExit:
.01a3cc	4c 5b a3	jmp $01a35b			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.01a3cf					FPD_IsDivZero:
.01a3cf	20 86 85	jsr $018586			jsr ERR_Handler
>01a3d2	44 69 76 69 73 69 6f 6e			.text "Division by zero",0
>01a3da	20 62 79 20 7a 65 72 6f 00
.01a3e3					FPDivide:
.01a3e3	48		pha				pha
.01a3e4	5a		phy				phy
.01a3e5	34 8b		bit $8b,x			bit 	XS2_Type,x 					; check if division by zero
.01a3e7	70 e6		bvs $01a3cf			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.01a3e9	34 85		bit $85,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.01a3eb	f0 03		beq $01a3f0			beq 	_FPDCalculateExp
.01a3ed					_FPD_Exit:
.01a3ed	7a		ply				ply
.01a3ee	68		pla				pla
.01a3ef	60		rts				rts
.01a3f0					_FPDCalculateExp:
.01a3f0	b5 8a		lda $8a,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.01a3f2	49 ff		eor #$ff			eor 	#$FF
.01a3f4	1a		inc a				inc 	a
.01a3f5	95 8a		sta $8a,x			sta 	XS2_Exponent,x
.01a3f7	20 c7 a4	jsr $01a4c7			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.01a3fa	18		clc				clc 	 							; add 1 to the resulting exponent
.01a3fb	69 01		adc #$01			adc 	#1
.01a3fd	b0 54		bcs $01a453			bcs 	_FPD_Overflow 				; which can overflow.
.01a3ff	95 84		sta $84,x			sta 	XS_Exponent,x
.01a401	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.01a403	85 1c		sta $1c				sta 	zLTemp1+0
.01a405	85 1d		sta $1d				sta 	zLTemp1+1
.01a407	85 1e		sta $1e				sta 	zLTemp1+2
.01a409	85 1f		sta $1f				sta 	zLTemp1+3
.01a40b	a0 20		ldy #$20			ldy 	#32 						; times round.
.01a40d					_FPD_Loop:
.01a40d	38		sec				sec 								; calculate X1-X2 stacking result because we might
.01a40e	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; not save it.
.01a410	f5 86		sbc $86,x			sbc 	XS2_Mantissa,x
.01a412	48		pha				pha
.01a413	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a415	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.01a417	48		pha				pha
.01a418	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a41a	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.01a41c	48		pha				pha
.01a41d	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a41f	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.01a421	90 13		bcc $01a436			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.01a423	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; save results out to A
.01a425	68		pla				pla
.01a426	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a428	68		pla				pla
.01a429	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a42b	68		pla				pla
.01a42c	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a42e	a5 1f		lda $1f				lda 	zLTemp1+3 					; set high bit of result
.01a430	09 80		ora #$80			ora 	#$80
.01a432	85 1f		sta $1f				sta 	zLTemp1+3
.01a434	80 03		bra $01a439			bra 	_FPD_Rotates
.01a436					_FPD_NoSubtract:
.01a436	68		pla				pla 								; throw away unwanted results
.01a437	68		pla				pla
.01a438	68		pla				pla
.01a439					_FPD_Rotates:
.01a439	56 89		lsr $89,x			lsr 	3+XS2_Mantissa,x
.01a43b	76 88		ror $88,x			ror 	2+XS2_Mantissa,x
.01a43d	76 87		ror $87,x			ror 	1+XS2_Mantissa,x
.01a43f	76 86		ror $86,x			ror 	0+XS2_Mantissa,x
.01a441	06 1c		asl $1c				asl 	0+zLTemp1
.01a443	26 1d		rol $1d				rol 	1+zLTemp1
.01a445	26 1e		rol $1e				rol 	2+zLTemp1
.01a447	26 1f		rol $1f				rol 	3+zLTemp1
.01a449	90 02		bcc $01a44d			bcc 	_FPD_NoCarry
.01a44b	e6 1c		inc $1c				inc 	zLTemp1 					; if rotated out, set LSB.
.01a44d					_FPD_NoCarry:
.01a44d	88		dey				dey 								; do 32 times
.01a44e	d0 bd		bne $01a40d			bne 	_FPD_Loop
.01a450	4c ab a4	jmp $01a4ab			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.01a453					_FPD_Overflow:
.01a453	4c 99 a6	jmp $01a699			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.01a456					FPMultiply:
.01a456	48		pha				pha
.01a457	5a		phy				phy
.01a458	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.01a45a	70 07		bvs $01a463			bvs 	_FPM_Exit
.01a45c	34 8b		bit $8b,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.01a45e	50 06		bvc $01a466			bvc 	_FPM_CalcExponent
.01a460	20 cd a5	jsr $01a5cd			jsr 	FPUCopyX2ToX1
.01a463					_FPM_Exit:
.01a463	7a		ply				ply
.01a464	68		pla				pla
.01a465	60		rts				rts
.01a466					_FPM_CalcExponent:
.01a466	18		clc				clc
.01a467	20 c7 a4	jsr $01a4c7			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.01a46a	95 84		sta $84,x			sta 	XS_Exponent,x 				; save the result.
.01a46c	a9 00		lda #$00			lda 	#0
.01a46e	85 1c		sta $1c				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.01a470	85 1d		sta $1d				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.01a472	85 1e		sta $1e				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.01a474	85 1f		sta $1f				sta 	zLTemp1+3
.01a476	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.01a478					_FPM_Loop:
.01a478	b5 80		lda $80,x			lda 	XS_Mantissa,x				; check LSB of long product
.01a47a	29 01		and #$01			and 	#1
.01a47c	18		clc				clc 								; clear carry for the long rotate.
.01a47d	f0 19		beq $01a498			beq 	_FPM_NoAddition
.01a47f	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.01a480	a5 1c		lda $1c				lda 	zLTemp1+0
.01a482	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.01a484	85 1c		sta $1c				sta 	zLTemp1+0
.01a486	a5 1d		lda $1d				lda 	zLTemp1+1
.01a488	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.01a48a	85 1d		sta $1d				sta 	zLTemp1+1
.01a48c	a5 1e		lda $1e				lda 	zLTemp1+2
.01a48e	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.01a490	85 1e		sta $1e				sta 	zLTemp1+2
.01a492	a5 1f		lda $1f				lda 	zLTemp1+3
.01a494	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.01a496	85 1f		sta $1f				sta 	zLTemp1+3
.01a498					_FPM_NoAddition:
.01a498	66 1f		ror $1f				ror 	3+zLTemp1
.01a49a	66 1e		ror $1e				ror 	2+zLTemp1
.01a49c	66 1d		ror $1d				ror 	1+zLTemp1
.01a49e	66 1c		ror $1c				ror 	0+zLTemp1
.01a4a0	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.01a4a2	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a4a4	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a4a6	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a4a8	88		dey				dey
.01a4a9	d0 cd		bne $01a478			bne 	_FPM_Loop 					; do this 32 times.
.01a4ab					FPM_CopySignNormalize:
.01a4ab	a5 1c		lda $1c				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.01a4ad	95 80		sta $80,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.01a4af	a5 1d		lda $1d				lda 	zLTemp1+1
.01a4b1	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a4b3	a5 1e		lda $1e				lda 	zLTemp1+2
.01a4b5	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a4b7	a5 1f		lda $1f				lda 	zLTemp1+3
.01a4b9	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a4bb	b5 85		lda $85,x			lda 	XS_Type,x 					; sign is xor of signs
.01a4bd	55 8b		eor $8b,x			eor 	XS2_Type,x
.01a4bf	95 85		sta $85,x			sta 	XS_Type,x
.01a4c1	20 3c a6	jsr $01a63c			jsr 	FPUNormalise 				; normalise and exit.
.01a4c4	7a		ply				ply
.01a4c5	68		pla				pla
.01a4c6	60		rts				rts
.01a4c7					FPCalculateExponent:
.01a4c7	18		clc				clc
.01a4c8	b5 84		lda $84,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.01a4ca	75 8a		adc $8a,x			adc 	XS2_Exponent,x
.01a4cc	b0 08		bcs $01a4d6			bcs 	_FPCECarry 					; carry out ?
.01a4ce	10 03		bpl $01a4d3			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.01a4d0	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.01a4d2	60		rts				rts
.01a4d3					_FPCEExpZero:
.01a4d3	a9 00		lda #$00			lda 	#0
.01a4d5	60		rts				rts
.01a4d6					_FPCECarry:
.01a4d6	30 03		bmi $01a4db			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.01a4d8	09 80		ora #$80			ora 	#$80 						; put in right range
.01a4da	60		rts				rts
.01a4db					_FPCEOverflow:
.01a4db	4c 99 a6	jmp $01a699			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.01a4de					FPFractionalPart:
.01a4de	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.01a4e0	38		sec				sec 								; this flag tells us to keep the fractional part
.01a4e1	30 0d		bmi $01a4f0			bmi 	FPGetPart
.01a4e3	60		rts				rts
.01a4e4					FPIntegerPart:
.01a4e4	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.01a4e6	18		clc				clc 								; this flag says keep the integer part.
.01a4e7	30 07		bmi $01a4f0			bmi 	FPGetPart 					; -ve exponents are 0..127
.01a4e9	48		pha				pha
.01a4ea	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.01a4ec	95 85		sta $85,x			sta 	XS_Type,x
.01a4ee	68		pla				pla
.01a4ef	60		rts				rts
.01a4f0					FPGetPart:
.01a4f0	48		pha				pha
.01a4f1	5a		phy				phy 								; save Y
.01a4f2	08		php				php 								; save action
.01a4f3	34 85		bit $85,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.01a4f5	70 59		bvs $01a550			bvs 	_FPGP_Exit 					; then do nothing.
.01a4f7	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.01a4f9	85 1c		sta $1c				sta 	zLTemp1+0 					; this mask is applied to chop out the
.01a4fb	85 1d		sta $1d				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.01a4fd	85 1e		sta $1e				sta 	zLTemp1+2
.01a4ff	85 1f		sta $1f				sta 	zLTemp1+3
.01a501	b5 84		lda $84,x			lda 	XS_Exponent,x				; the number of shifts.
.01a503	38		sec				sec
.01a504	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.01a506	f0 12		beq $01a51a			beq 	_FPGP_NoShift 				; ... if any
.01a508	c9 20		cmp #$20			cmp 	#32
.01a50a	90 02		bcc $01a50e			bcc 	_FPGP_NotMax
.01a50c	a9 20		lda #$20			lda 	#32 						; max of 32.
.01a50e					_FPGP_NotMax:
.01a50e	a8		tay				tay 								; Y is the mask shift count.
.01a50f					_FPGP_ShiftMask:
.01a50f	46 1f		lsr $1f				lsr 	3+zLTemp1
.01a511	66 1e		ror $1e				ror 	2+zLTemp1
.01a513	66 1d		ror $1d				ror 	1+zLTemp1
.01a515	66 1c		ror $1c				ror 	0+zLTemp1
.01a517	88		dey				dey
.01a518	d0 f5		bne $01a50f			bne 	_FPGP_ShiftMask
.01a51a					_FPGP_NoShift:
.01a51a	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.01a51c	8e 9c 03	stx $039c			stx 	ExpTemp						; save X
.01a51f					_FPGP_MaskLoop:
.01a51f	b9 1c 00	lda $001c,y			lda 	zlTemp1,y 					; get mask byte
.01a522	28		plp				plp 								; if CC we keep the top part, so we
.01a523	08		php				php		 							; flip the mask.
.01a524	b0 02		bcs $01a528			bcs		_FPGP_NoFlip
.01a526	49 ff		eor #$ff			eor 	#$FF
.01a528					_FPGP_NoFlip:
.01a528	35 80		and $80,x			and 	XS_Mantissa,x 				; and into the mantissa.
.01a52a	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a52c	e8		inx				inx
.01a52d	c8		iny				iny
.01a52e	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.01a530	d0 ed		bne $01a51f			bne 	_FPGP_MaskLoop
.01a532	ae 9c 03	ldx $039c			ldx 	ExpTemp						; restore X
.01a535	28		plp				plp
.01a536	08		php				php 								; get action flag on the stack
.01a537	90 04		bcc $01a53d			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.01a539	a9 00		lda #$00			lda 	#0
.01a53b	95 85		sta $85,x			sta 	XS_Type,x
.01a53d					_FPGP_NotFractional:
.01a53d	b5 80		lda $80,x			lda 	XS_Mantissa,x 						; check if \1 zero
.01a53f	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.01a541	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01a543	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01a545	f0 05		beq $01a54c			beq 	_FPGP_Zero 					; if zero, return zero
.01a547	20 3c a6	jsr $01a63c			jsr 	FPUNormalise
.01a54a	80 04		bra $01a550			bra 	_FPGP_Exit 					; and exit
.01a54c					_FPGP_Zero:
.01a54c	a9 40		lda #$40			lda 	#$40 						; set zero flag
.01a54e	95 85		sta $85,x			sta 	XS_Type,x
.01a550					_FPGP_Exit:
.01a550	68		pla				pla 								; throw saved action flag.
.01a551	7a		ply				ply
.01a552	68		pla				pla
.01a553	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.01a554					FPCompare:
.01a554	20 95 a5	jsr $01a595			jsr 	FPFastCompare 				; fast compare try first
.01a557	b0 3b		bcs $01a594			bcs 	_FPCExit 					; that worked.
.01a559	b5 84		lda $84,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.01a55b	48		pha				pha
.01a55c	b5 8a		lda $8a,x			lda 	XS2_Exponent,x
.01a55e	48		pha				pha
.01a55f	20 27 a3	jsr $01a327			jsr 	FPSubtract 					; calculate X1-X2
.01a562	34 85		bit $85,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.01a564	70 2a		bvs $01a590			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exponents
.01a566	68		pla				pla
.01a567	8d 9c 03	sta $039c			sta 	ExpTemp						; save first exponent in temporary reg.
.01a56a	68		pla				pla
.01a56b	38		sec				sec
.01a56c	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; calculate AX-BX
.01a56f	70 14		bvs $01a585			bvs 	_FPCNotEqual				; overflow, can't be equal.
.01a571	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.01a572	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.01a574	b0 0f		bcs $01a585			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.01a576	38		sec				sec
.01a577	ad 9c 03	lda $039c			lda 	ExpTemp 					; get one of the exponents back.
.01a57a	e9 12		sbc #$12			sbc 	#18 						; allow for 2^18 error, relatively.
.01a57c	b0 02		bcs $01a580			bcs 	_FPCNotRange 				; keep in range.
.01a57e	a9 01		lda #$01			lda 	#1
.01a580					_FPCNotRange:
.01a580	38		sec				sec
.01a581	f5 84		sbc $84,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.01a583	b0 0d		bcs $01a592			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.01a585					_FPCNotEqual:
.01a585	b5 85		lda $85,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.01a587	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.01a589	f0 02		beq $01a58d			beq 	_FPCNE2
.01a58b	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.01a58d	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.01a58e	80 04		bra $01a594			bra 	_FPCExit
.01a590					_FPCPullZero:
.01a590	68		pla				pla 								; throw saved exponents
.01a591	68		pla				pla
.01a592					_FPCZero:
.01a592	a9 00		lda #$00			lda 	#0 							; and return zero
.01a594					_FPCExit:
.01a594	60		rts				rts
.01a595					FPFastCompare:
.01a595	34 85		bit $85,x			bit 	XS_Type,x 					; n1 is zero.
.01a597	70 23		bvs $01a5bc			bvs 	_FPFLeftZero 				; return invert sign of n2 (0-n2)
.01a599	34 8b		bit $8b,x			bit 	XS2_Type,x 					; n2 is zero ?
.01a59b	b5 85		lda $85,x			lda 	XS_Type,x 					; if so, return sign bit of n1 (n1-0)
.01a59d	70 25		bvs $01a5c4			bvs 	_FPFSignBit
.01a59f	55 8b		eor $8b,x			eor 	XS2_Type,x 					; eor 2 type bits. now know both non-zero
.01a5a1	0a		asl a				asl 	a 							; put in CS if different.
.01a5a2	b5 85		lda $85,x			lda 	XS_Type,x 					; if signs different return sign of first
.01a5a4	b0 1e		bcs $01a5c4			bcs 	_FPFSignBit
.01a5a6	38		sec				sec 								; same sign and not-zero. compare exponents
.01a5a7	b5 84		lda $84,x			lda 	XS_Exponent,x 				; compare exponents. if the same, then fail.
.01a5a9	f5 8a		sbc $8a,x			sbc 	XS2_Exponent,x 				; e.g. we have to do it via subtraction.
.01a5ab	f0 09		beq $01a5b6			beq 	_FPNoFastCompare
.01a5ad	6a		ror a				ror 	a 							; put carry into bit 7.
.01a5ae	34 85		bit $85,x			bit 	XS_Type,X 					; if it is +x then flip it.
.01a5b0	30 02		bmi $01a5b4			bmi		_FPFCNotMinus
.01a5b2	49 80		eor #$80			eor 	#$80
.01a5b4					_FPFCNotMinus:
.01a5b4	80 0e		bra $01a5c4			bra		_FPFSignBit
.01a5b6					_FPNoFastCompare:
.01a5b6	18		clc				clc
.01a5b7	60		rts				rts
.01a5b8					_FPFZero:
.01a5b8	a9 00		lda #$00			lda 	#0
.01a5ba					_FPFExitSet:
.01a5ba	38		sec				sec
.01a5bb	60		rts				rts
.01a5bc					_FPFLeftZero:
.01a5bc	34 8b		bit $8b,x			bit 	XS2_Type,x 					; if right is zero, return zero.
.01a5be	70 f8		bvs $01a5b8			bvs 	_FPFZero
.01a5c0	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip sign bit
.01a5c2	49 80		eor #$80			eor 	#$80						; return that as a sign.
.01a5c4					_FPFSignBit:
.01a5c4	0a		asl a				asl 	a
.01a5c5	a9 01		lda #$01			lda 	#1
.01a5c7	90 f1		bcc $01a5ba			bcc		_FPFExitSet
.01a5c9	a9 ff		lda #$ff			lda 	#$FF
.01a5cb	38		sec				sec
.01a5cc	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.01a5cd					FPUCopyX2ToX1:
.01a5cd	48		pha				pha									; save AXY
.01a5ce	da		phx				phx
.01a5cf	5a		phy				phy
.01a5d0	a0 08		ldy #$08			ldy 	#8 							; copy the whole mantissa
.01a5d2	b5 86		lda $86,x	_FPUC21:lda 	XS2_Mantissa,x
.01a5d4	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a5d6	e8		inx				inx
.01a5d7	88		dey				dey
.01a5d8	10 f8		bpl $01a5d2			bpl 	_FPUC21
.01a5da	7a		ply				ply 								; restore and exit
.01a5db	fa		plx				plx
.01a5dc	68		pla				pla
.01a5dd	60		rts				rts
.01a5de					FPUSetInteger:
.01a5de	48		pha				pha
.01a5df	95 80		sta $80,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.01a5e1	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.01a5e3	10 02		bpl $01a5e7			bpl 	_FPUSIExtend 				; so sign extend it into the mantissa
.01a5e5	a9 ff		lda #$ff			lda 	#$FF
.01a5e7					_FPUSIExtend:
.01a5e7	95 81		sta $81,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.01a5e9	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a5eb	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a5ed	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.01a5ef	95 85		sta $85,x			sta 	XS_Type,x
.01a5f1	68		pla				pla
.01a5f2	60		rts				rts
.01a5f3					FPUNegateInteger:
.01a5f3	48		pha				pha
.01a5f4	38		sec				sec
.01a5f5	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.01a5f7	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.01a5f9	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a5fb	a9 00		lda #$00			lda 	#0
.01a5fd	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.01a5ff	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a601	a9 00		lda #$00			lda 	#0
.01a603	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.01a605	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a607	a9 00		lda #$00			lda 	#0
.01a609	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.01a60b	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a60d	68		pla				pla
.01a60e	60		rts				rts
.01a60f					FPUToFloat:
.01a60f	48		pha				pha
.01a610	b5 85		lda $85,x			lda 	XS_Type,x					; exit if already float.
.01a612	29 0f		and #$0f			and 	#$0F 						; (e.g. type is zero)
.01a614	f0 24		beq $01a63a			beq 	_FPUFExit
.01a616	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.01a618	95 85		sta $85,x			sta 	XS_Type,x
.01a61a	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.01a61c	95 84		sta $84,x			sta 	XS_Exponent,x 				; x mantissa.
.01a61e	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.01a620	10 07		bpl $01a629			bpl		_FPUFPositive
.01a622	20 f3 a5	jsr $01a5f3			jsr 	FPUNegateInteger 			; negate the mantissa
.01a625	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.01a627	95 85		sta $85,x			sta 	XS_Type,x
.01a629					_FPUFPositive:
.01a629	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.01a62b	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.01a62d	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01a62f	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01a631	d0 04		bne $01a637			bne 	_FPUFNonZero
.01a633	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.01a635	95 85		sta $85,x			sta 	XS_Type,x
.01a637					_FPUFNonZero:
.01a637	20 3c a6	jsr $01a63c			jsr 	FPUNormalise 				; normalise the floating point.
.01a63a					_FPUFExit:
.01a63a	68		pla				pla
.01a63b	60		rts				rts
.01a63c					FPUNormalise:
.01a63c	48		pha				pha
.01a63d	34 85		bit $85,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.01a63f	70 18		bvs $01a659			bvs 	_FPUNExit
.01a641	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.01a643	f0 10		beq $01a655			beq 	_FPUNSetZero 				; (e.g. the float value zero)
.01a645					_FPUNLoop:
.01a645	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.01a647	30 10		bmi $01a659			bmi 	_FPUNExit 					; if so, we are normalised.
.01a649	16 80		asl $80,x			asl 	0+XS_Mantissa+0,x
.01a64b	36 81		rol $81,x			rol 	1+XS_Mantissa+0,x
.01a64d	36 82		rol $82,x			rol 	2+XS_Mantissa+0,x
.01a64f	36 83		rol $83,x			rol 	3+XS_Mantissa+0,x
.01a651	d6 84		dec $84,x			dec 	XS_Exponent,x 				; decrement exponent
.01a653	d0 f0		bne $01a645			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.01a655					_FPUNSetZero:
.01a655	a9 40		lda #$40			lda 	#$40
.01a657	95 85		sta $85,x			sta 	XS_Type,x 					; the result is now zero.
.01a659					_FPUNExit:
.01a659	68		pla				pla
.01a65a	60		rts				rts
.01a65b					FPUToInteger:
.01a65b	48		pha				pha
.01a65c	b5 85		lda $85,x			lda 	XS_Type,x 					; if already integer, exit
.01a65e	29 01		and #$01			and 	#1
.01a660	d0 31		bne $01a693			bne 	_FPUTOI_Exit
.01a662	34 85		bit $85,x			bit 	XS_Type,x					; if zero, return zero.
.01a664	70 23		bvs $01a689			bvs 	_FPUTOI_Zero
.01a666	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.01a668	10 1f		bpl $01a689			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.01a66a	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.01a66c	b0 2b		bcs $01a699			bcs 	FP_Overflow 				; can't cope with that as an integer.
.01a66e					_FPUToIToInteger:
.01a66e	b5 84		lda $84,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.01a670	c9 a0		cmp #$a0			cmp 	#128+32
.01a672	f0 0c		beq $01a680			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.01a674	f6 84		inc $84,x			inc 	XS_Exponent,X 				; increment Exponent
.01a676	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.01a678	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a67a	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a67c	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a67e	80 ee		bra $01a66e			bra 	_FPUToIToInteger 			; keep going.
.01a680					_FPUToICheckSign:
.01a680	b5 85		lda $85,x			lda 	XS_Type,x 					; check sign
.01a682	10 0f		bpl $01a693			bpl 	_FPUToI_Exit 				; exit if unsigned.
.01a684	20 f3 a5	jsr $01a5f3			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.01a687	80 0a		bra $01a693			bra 	_FPUTOI_Exit
.01a689					_FPUTOI_Zero:
.01a689	a9 00		lda #$00			lda 	#0 							; return zero integer.
.01a68b	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a68d	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a68f	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a691	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a693					_FPUToI_Exit:
.01a693	a9 01		lda #$01			lda 	#1 							; set type to integer
.01a695	95 85		sta $85,x			sta 	XS_Type,x
.01a697	68		pla				pla
.01a698	60		rts				rts
.01a699					FP_Overflow:
.01a699	20 86 85	jsr $018586			jsr ERR_Handler
>01a69c	46 6c 6f 61 74 69 6e 67			.text "Floating Point overflow",0
>01a6a4	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.01a6b4					FPUTimes10:
.01a6b4	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.01a6b6	85 1c		sta $1c				sta 	ZLTemp1+0
.01a6b8	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a6ba	85 1d		sta $1d				sta 	ZLTemp1+1
.01a6bc	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a6be	85 1e		sta $1e				sta 	ZLTemp1+2
.01a6c0	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a6c2	85 1f		sta $1f				sta 	ZLTemp1+3
.01a6c4	20 f9 a6	jsr $01a6f9			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.01a6c7	20 f9 a6	jsr $01a6f9			jsr 	_FPUT_LSR_ZLTemp1
.01a6ca	18		clc				clc
.01a6cb	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.01a6cd	65 1c		adc $1c				adc 	ZLTemp1+0
.01a6cf	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a6d1	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a6d3	65 1d		adc $1d				adc 	ZLTemp1+1
.01a6d5	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a6d7	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a6d9	65 1e		adc $1e				adc 	ZLTemp1+2
.01a6db	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a6dd	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a6df	65 1f		adc $1f				adc 	ZLTemp1+3
.01a6e1	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a6e3	90 0a		bcc $01a6ef			bcc 	_FPUTimes10
.01a6e5	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.01a6e7	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a6e9	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a6eb	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a6ed	f6 84		inc $84,x			inc 	XS_Exponent,x				; fix exponent
.01a6ef					_FPUTimes10:
.01a6ef	b5 84		lda $84,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.01a6f1	18		clc				clc
.01a6f2	69 03		adc #$03			adc 	#3
.01a6f4	95 84		sta $84,x			sta 	XS_Exponent,x
.01a6f6	b0 a1		bcs $01a699			bcs 	FP_Overflow 				; error
.01a6f8	60		rts				rts
.01a6f9					_FPUT_LSR_ZLTemp1:
.01a6f9	46 1f		lsr $1f				lsr 	ZLTemp1+3
.01a6fb	66 1e		ror $1e				ror 	ZLTemp1+2
.01a6fd	66 1d		ror $1d				ror 	ZLTemp1+1
.01a6ff	66 1c		ror $1c				ror 	ZLTemp1+0
.01a701	60		rts				rts
.01a702					FPUScale10A:
.01a702	5a		phy				phy
.01a703	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.01a705	f0 37		beq $01a73e			beq 	_FPUScaleExit
.01a707	da		phx				phx 								; save X
.01a708	e8		inx				inx
.01a709	e8		inx				inx
.01a70a	e8		inx				inx
.01a70b	e8		inx				inx
.01a70c	e8		inx				inx
.01a70d	e8		inx				inx
.01a70e	a8		tay				tay 								; save power scalar in Y.
.01a70f	a9 00		lda #$00			lda 	#0
.01a711	95 80		sta $80,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0 in float.
.01a713	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a715	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a717	95 85		sta $85,x			sta 	XS_Type,x
.01a719	a9 80		lda #$80			lda 	#$80
.01a71b	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a71d	a9 81		lda #$81			lda 	#$81
.01a71f	95 84		sta $84,x			sta 	XS_Exponent,x
.01a721	5a		phy				phy 								; save 10^n (e.g. the scalar) on stack.
.01a722	c0 00		cpy #$00			cpy 	#0
.01a724	10 05		bpl $01a72b			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.01a726	98		tya				tya
.01a727	49 ff		eor #$ff			eor 	#$FF
.01a729	1a		inc a				inc 	a
.01a72a	a8		tay				tay
.01a72b					_FPUSAbs:
.01a72b	20 b4 a6	jsr $01a6b4			jsr 	FPUTimes10
.01a72e	88		dey				dey
.01a72f	d0 fa		bne $01a72b			bne 	_FPUSAbs 					; tos is now 10^|AC|
.01a731	68		pla				pla 								; restore count in A
.01a732	fa		plx				plx 								; restore X pointing to number to scale.
.01a733	0a		asl a				asl 	a
.01a734	b0 05		bcs $01a73b			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.01a736	20 56 a4	jsr $01a456			jsr 	FPMultiply 					; if clear multiply.
.01a739	80 03		bra $01a73e			bra		_FPUScaleExit
.01a73b					_FPUSDivide:
.01a73b	20 e3 a3	jsr $01a3e3			jsr 	FPDivide
.01a73e					_FPUScaleExit:
.01a73e	7a		ply				ply
.01a73f	60		rts				rts
.01a740					FPUCopyToNext:
.01a740	a0 06		ldy #$06			ldy 		#6
.01a742	da		phx				phx
.01a743					_FPUCopy1:
.01a743	b5 80		lda $80,x			lda 	XS_Mantissa,x
.01a745	95 86		sta $86,x			sta 	XS2_Mantissa,x
.01a747	e8		inx				inx
.01a748	88		dey				dey
.01a749	d0 f8		bne $01a743			bne 	_FPUCopy1
.01a74b	fa		plx				plx
.01a74c	60		rts				rts
.01a74d					FPUCopyFromNext:
.01a74d	a0 06		ldy #$06			ldy 		#6
.01a74f	da		phx				phx
.01a750					_FPUCopy1:
.01a750	b5 86		lda $86,x			lda 	XS2_Mantissa,x
.01a752	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a754	e8		inx				inx
.01a755	88		dey				dey
.01a756	d0 f8		bne $01a750			bne 	_FPUCopy1
.01a758	fa		plx				plx
.01a759	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.01a75a					FPToString:
.01a75a	48		pha				pha
.01a75b	5a		phy				phy
.01a75c	34 85		bit $85,x			bit 		XS_Type,x 				; check zero flag
.01a75e	50 0a		bvc $01a76a			bvc 		_FPTSIsFloat 			; if zero,
.01a760					_FPTSZero:
.01a760	a9 30		lda #$30			lda 		#"0"
.01a762	20 82 a2	jsr $01a282			jsr 		ITSOutputCharacter
.01a765					_FPTSExit:
.01a765	7a		ply				ply
.01a766	68		pla				pla
.01a767	60		rts				rts
.01a768	80 fb		bra $01a765			bra 		_FPTSExit
.01a76a					_FPTSIsFloat:
.01a76a	b5 85		lda $85,x			lda 		XS_Type,x 				; is it signed ?
.01a76c	10 09		bpl $01a777			bpl 		_FPTSNotSigned
.01a76e	a9 00		lda #$00			lda 		#0 						; clear sign flag
.01a770	95 85		sta $85,x			sta 		XS_Type,x
.01a772	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.01a774	20 82 a2	jsr $01a282			jsr 		ITSOutputCharacter
.01a777					_FPTSNotSigned:
.01a777	b5 84		lda $84,x			lda 		XS_Exponent,x
.01a779	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.01a77b	b0 09		bcs $01a786			bcs 		_FPTSExponent
.01a77d	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.01a77f	90 05		bcc $01a786			bcc 		_FPTSExponent 			;
.01a781					_FPTSStandard:
.01a781	20 c5 a7	jsr $01a7c5			jsr 		FPTOutputBody 			; output the body.
.01a784	80 df		bra $01a765			bra 		_FPTSExit
.01a786					_FPTSExponent:
.01a786	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.01a788	8d 9d 03	sta $039d			sta 		ExpCount
.01a78b					_FPTSExponentLoop:
.01a78b	b5 84		lda $84,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.01a78d	10 0e		bpl $01a79d			bpl 		_FPTSTimes
.01a78f	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.01a791	90 14		bcc $01a7a7			bcc 		_FPTSScaledToExp
.01a793	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.01a795	20 02 a7	jsr $01a702			jsr 		FPUScale10A
.01a798	ee 9d 03	inc $039d			inc 		ExpCount
.01a79b	80 ee		bra $01a78b			bra 		_FPTSExponentLoop
.01a79d					_FPTSTimes:
.01a79d	a9 01		lda #$01			lda 		#1
.01a79f	20 02 a7	jsr $01a702			jsr 		FPUScale10A
.01a7a2	ce 9d 03	dec $039d			dec 		ExpCount
.01a7a5	80 e4		bra $01a78b			bra 		_FPTSExponentLoop
.01a7a7					_FPTSScaledToExp:
.01a7a7	20 c5 a7	jsr $01a7c5			jsr 		FPTOutputBody 			; output the body.
.01a7aa	a9 65		lda #$65			lda 		#"e"					; output E
.01a7ac	20 82 a2	jsr $01a282			jsr 		ITSOutputCharacter
.01a7af	ad 9d 03	lda $039d			lda 		ExpCount 				; get the exponent
.01a7b2	95 80		sta $80,x			sta 		XS_Mantissa,x
.01a7b4	29 80		and #$80			and 		#$80 					; sign extend it
.01a7b6	f0 02		beq $01a7ba			beq 		_FPTSSExt
.01a7b8	a9 ff		lda #$ff			lda 		#$FF
.01a7ba					_FPTSSExt:
.01a7ba	95 81		sta $81,x			sta 		XS_Mantissa+1,x
.01a7bc	95 82		sta $82,x			sta 		XS_Mantissa+2,x
.01a7be	95 83		sta $83,x			sta 		XS_Mantissa+3,x
.01a7c0	20 e0 a1	jsr $01a1e0			jsr 		INTToString 			; output the exponent.
.01a7c3	80 a0		bra $01a765			bra			_FPTSExit 				; and exit.
.01a7c5					FPTOutputBody:
.01a7c5	20 40 a7	jsr $01a740			jsr 		FPUCopyToNext 			; copy to next slot.
.01a7c8	20 5b a6	jsr $01a65b			jsr 		FPUToInteger 			; convert to an integer
.01a7cb	20 e0 a1	jsr $01a1e0			jsr 		INTToString 			; output the main integer part.
.01a7ce	20 4d a7	jsr $01a74d			jsr 		FPUCopyFromNext 		; get the fractional part back.
.01a7d1	20 de a4	jsr $01a4de			jsr 		FPFractionalPart 		; get the decimal part.
.01a7d4	34 85		bit $85,x			bit 		XS_Type,x 				; any fractional part.
.01a7d6	70 3c		bvs $01a814			bvs 		_FPTOExit 				; if not, exit now.
.01a7d8	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.01a7da	20 82 a2	jsr $01a282			jsr 		ITSOutputCharacter
.01a7dd					_FPOutLoop:
.01a7dd	34 85		bit $85,x			bit 		XS_Type,x 				; finally reached zero.
.01a7df	70 1d		bvs $01a7fe			bvs 		_FPStripZeros 			; strip trailing zeros
.01a7e1	20 b4 a6	jsr $01a6b4			jsr 		FPUTimes10 				; multiply by 10
.01a7e4	20 40 a7	jsr $01a740			jsr 		FPUCopyToNext			; copy to next slot.
.01a7e7	20 5b a6	jsr $01a65b			jsr 		FPUToInteger 			; convert to integer
.01a7ea	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; print digit.
.01a7ec	09 30		ora #$30			ora 		#"0"
.01a7ee	20 82 a2	jsr $01a282			jsr 		ITSOutputCharacter
.01a7f1	20 4d a7	jsr $01a74d			jsr 		FPUCopyFromNext 		; get it back
.01a7f4	20 de a4	jsr $01a4de			jsr 		FPFractionalPart 		; get fractional part
.01a7f7	ad 14 03	lda $0314			lda 		NumBufX 				; done 11 characters yet ?
.01a7fa	c9 0b		cmp #$0b			cmp 	 	#11
.01a7fc	90 df		bcc $01a7dd			bcc 		_FPOutLoop 				; if so, keep going till zero.
.01a7fe					_FPStripZeros:
.01a7fe	ac 14 03	ldy $0314			ldy 		NumBufX 				; strip trailing zeros.
.01a801					_FPStripLoop:
.01a801	88		dey				dey 								; back one, if at start then no strip
.01a802	f0 10		beq $01a814			beq 		_FPToExit
.01a804	b9 15 03	lda $0315,y			lda 		Num_Buffer,y 			; keep going if "0"
.01a807	c9 30		cmp #$30			cmp 		#"0"
.01a809	f0 f6		beq $01a801			beq 		_FPStripLoop
.01a80b	c8		iny				iny
.01a80c	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.01a80e	99 15 03	sta $0315,y			sta 		Num_Buffer,y
.01a811	8c 14 03	sty $0314			sty 		NumBufX 				; update position.
.01a814					_FPTOExit:
.01a814	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.01a815					FPFromString:
.01a815	48		pha				pha 								; push A
.01a816	b1 20		lda ($20),y			lda		(zGenPtr),y					; is it followed by a DP ?
.01a818	c9 2e		cmp #$2e			cmp 	#"."
.01a81a	f0 03		beq $01a81f			beq	 	_FPFIsDecimal
.01a81c	4c 7b a8	jmp $01a87b			jmp 	_FPFNotDecimal
.01a81f					_FPFIsDecimal:
.01a81f	c8		iny				iny 								; consume the decimal.
.01a820	20 0f a6	jsr $01a60f			jsr 	FPUToFloat 					; convert the integer to float.
.01a823	da		phx				phx 								; save X.
.01a824	5a		phy				phy 								; save decimal start position
.01a825	e8		inx				inx
.01a826	e8		inx				inx
.01a827	e8		inx				inx
.01a828	e8		inx				inx
.01a829	e8		inx				inx
.01a82a	e8		inx				inx
.01a82b	20 97 a2	jsr $01a297			jsr 	INTFromStringY 				; get the part after the DP.
.01a82e	20 0f a6	jsr $01a60f			jsr 	FPUToFloat 					; convert that to a float.
.01a831	68		pla				pla 								; calculate - chars consumed.
.01a832	8c 9c 03	sty $039c			sty 	ExpTemp
.01a835	38		sec				sec
.01a836	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; this is the shift amount
.01a839	20 02 a7	jsr $01a702			jsr 	FPUScale10A 				; scale it by 10^AC
.01a83c	fa		plx				plx 								; restore original X
.01a83d	20 2f a3	jsr $01a32f			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.01a840	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; exponent ?
.01a842	c9 45		cmp #$45			cmp 	#"E"
.01a844	f0 04		beq $01a84a			beq 	_FPFExponent
.01a846	c9 65		cmp #$65			cmp 	#"e"
.01a848	d0 31		bne $01a87b			bne 	_FPFNotDecimal 				; no, then exit normally.
.01a84a					_FPFExponent:
.01a84a	c8		iny				iny 								; skip over E symbol.
.01a84b	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; look at next
.01a84d	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.01a84f	d0 01		bne $01a852			bne 	_FPFGotSign
.01a851	c8		iny				iny 								; if it was - skip over it.
.01a852					_FPFGotSign:
.01a852	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.01a853	da		phx				phx
.01a854	e8		inx				inx
.01a855	e8		inx				inx
.01a856	e8		inx				inx
.01a857	e8		inx				inx
.01a858	e8		inx				inx
.01a859	e8		inx				inx
.01a85a	20 97 a2	jsr $01a297			jsr 	INTFromStringY 				; get the exponent
.01a85d	fa		plx				plx 								; restore X.
.01a85e	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.01a860	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.01a862	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.01a864	d0 17		bne $01a87d			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.01a866	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.01a868	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.01a86a	b0 11		bcs $01a87d			bcs 	_FPFXOverflow
.01a86c	68		pla				pla 								; get direction
.01a86d	d0 07		bne $01a876			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.01a86f	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.01a871	49 ff		eor #$ff			eor 	#$FF
.01a873	1a		inc a				inc 	a
.01a874	95 86		sta $86,x			sta 	XS2_Mantissa+0,x
.01a876					_FPFXScale:
.01a876	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.01a878	20 02 a7	jsr $01a702			jsr 	FPUScale10A 				; scale by the exponent.
.01a87b					_FPFNotDecimal:
.01a87b	68		pla				pla
.01a87c	60		rts				rts
.01a87d					_FPFXOverflow:
.01a87d	20 86 85	jsr $018586			jsr 	ERR_Handler
>01a880	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>01a888	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.01a88f					Unary_Rnd:
.01a88f	20 d7 93	jsr $0193d7			jsr 	EvaluateNumberX 			; get value
.01a892	20 39 9a	jsr $019a39			jsr 	CheckNextRParen 			; check right bracket.
.01a895	20 57 96	jsr $019657			jsr 	GetSignCurrent 				; get sign -1,0,1.
.01a898	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.01a89a	30 10		bmi $01a8ac			bmi 	_URSetSeed
.01a89c	f0 28		beq $01a8c6			beq 	_URMakeRandom 				; if zero return same number, don't advance sequence
.01a89e	da		phx				phx
.01a89f	a2 00		ldx #$00			ldx 	#0 							; run 16 bit RNG procession on upper/lower
.01a8a1	20 fd a8	jsr $01a8fd			jsr 	Random16
.01a8a4	a2 02		ldx #$02			ldx 	#2
.01a8a6	20 fd a8	jsr $01a8fd			jsr 	Random16
.01a8a9	fa		plx				plx
.01a8aa	80 1a		bra $01a8c6			bra 	_URMakeRandom
.01a8ac					_URSetSeed:
.01a8ac	20 0f a6	jsr $01a60f			jsr 	FPUToFloat 					; make it a float to twiddle it.
.01a8af	b5 80		lda $80,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.01a8b1	8d a3 03	sta $03a3			sta 	RandomSeed+0
.01a8b4	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.01a8b6	8d a4 03	sta $03a4			sta 	RandomSeed+1
.01a8b9	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.01a8bb	8d a5 03	sta $03a5			sta 	RandomSeed+2
.01a8be	b5 83		lda $83,x			lda		XS_Mantissa+3,x 			; this is to make the seed bear not much
.01a8c0	0a		asl a				asl 	a 							; resemblance to the seed value.
.01a8c1	49 db		eor #$db			eor 	#$DB
.01a8c3	8d a6 03	sta $03a6			sta 	RandomSeed+3
.01a8c6					_URMakeRandom:
.01a8c6	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; check if seed is zero.
.01a8c9	0d a4 03	ora $03a4			ora 	RandomSeed+1
.01a8cc	0d a5 03	ora $03a5			ora 	RandomSeed+2
.01a8cf	0d a6 03	ora $03a6			ora 	RandomSeed+3
.01a8d2	d0 0a		bne $01a8de			bne 	_URNotZero
.01a8d4	a9 47		lda #$47			lda 	#$47						; if it is, make it non zero.
.01a8d6	8d a4 03	sta $03a4			sta 	RandomSeed+1				; in both parts.
.01a8d9	a9 3d		lda #$3d			lda 	#$3D
.01a8db	8d a6 03	sta $03a6			sta 	RandomSeed+3
.01a8de					_URNotZero:
.01a8de	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; copy seed into mantissa.
.01a8e1	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a8e3	ad a4 03	lda $03a4			lda 	RandomSeed+1
.01a8e6	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a8e8	ad a5 03	lda $03a5			lda 	RandomSeed+2
.01a8eb	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a8ed	ad a6 03	lda $03a6			lda 	RandomSeed+3
.01a8f0	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a8f2	a9 00		lda #$00			lda 	#$00 						; set type to float.
.01a8f4	95 85		sta $85,x			sta 	XS_Type,x
.01a8f6	a9 80		lda #$80			lda 	#$80
.01a8f8	95 84		sta $84,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.01a8fa	4c 3c a6	jmp $01a63c			jmp 	FPUNormalise 				; and normalise.
.01a8fd					Random16:
.01a8fd	5e a4 03	lsr $03a4,x			lsr 	RandomSeed+1,x				; shift seed right
.01a900	7e a3 03	ror $03a3,x			ror 	RandomSeed,x
.01a903	90 08		bcc $01a90d			bcc 	_R16_NoXor
.01a905	bd a4 03	lda $03a4,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.01a908	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.01a90a	9d a4 03	sta $03a4,x			sta 	RandomSeed+1,x
.01a90d					_R16_NoXor:
.01a90d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.01a90e					Unary_Int:
.01a90e	20 d7 93	jsr $0193d7			jsr 	EvaluateNumberX 			; get value
.01a911	20 39 9a	jsr $019a39			jsr 	CheckNextRParen 			; check right bracket.
.01a914	4c 5b a6	jmp $01a65b			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Return to file: basic.asm

>01a917	02						.byte 	2
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 c0						.word 	StartROM 					; Reset vector
>fffe	19 c0					.word TIM_BreakHandler

;******  End of listing
