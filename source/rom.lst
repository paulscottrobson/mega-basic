
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Wed Aug 21 19:23:31 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="65816"				cpu = "65816"
="em65816"				hardware = "em65816"
=1					hasFloat = 1
=1					hasInteger = 1

;******  Processing file: modules/float/fpmacros.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/em65816/src_em65816.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/common/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0200					IFT_XCursor:.byte ?							; current logical position on screen
>0201					IFT_YCursor:.byte ?
>0202					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0266					IFT_LineBuffer: .fill 100 					; line input buffer.
>0300					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>0304					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>0305					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=774					XS2_Mantissa = XS_Mantissa+XS_Size
=778					XS2_Exponent = XS_Exponent+XS_Size
=779					XS2_Type = XS_Type+XS_Size
=780					XS3_Mantissa = XS_Mantissa+XS_Size*2
=784					XS3_Exponent = XS_Exponent+XS_Size*2
=785					XS3_Type = XS_Type+XS_Size*2
>0400					Num_Buffer	.fill 	32 						; buffer for numeric conversions
>0420					NumBufX 	.byte 	?						; buffer index position
>0421					NumSuppress	.byte 	?						; leading zero suppression flag
>0422					NumConvCount .byte 	? 						; count for conversions.
>0423					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>0425					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>0427					Tim_SR:		.byte ? 						; Processor Status
>0428					Tim_A:		.byte ? 						; Processor Registers
>0429					Tim_X:		.byte ?
>042a					Tim_Y:		.byte ?
>042b					Tim_Z:		.byte ?
>042c					Tim_SP:		.byte ?							; Stack Pointer
>042d					ExpTemp:	.byte ?							; Working temp for exponents.
>042e					ExpCount:	.byte ? 						; Count of decimal exponents.

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/em65816.asm

.1000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testcode.src

>1000	13 0a 00 d6 43 74 49 40			.byte	$13,$0a,$00,$d6,$43,$74,$49,$40
>1008	8c 43 48 bb ff 06 68 69			.byte	$8c,$43,$48,$bb,$ff,$06,$68,$69
>1010	20 21 00 00				.byte	$20,$21,$00,$00

;******  Return to file: modules/hardware/em65816.asm


;******  Processing file: modules/hardware/../common/header/header.src

=$92					firstKeywordMinus = $92
=$8e					firstKeywordPlus = $8e
=$97					firstUnaryFunction = $97
=$b1					lastUnaryFunction = $b1
.c000					VectorTable:
>c000	ac c0					.word NotImplemented       ; $80 and
>c002	ac c0					.word NotImplemented       ; $81 or
>c004	ac c0					.word NotImplemented       ; $82 xor
>c006	ac c0					.word NotImplemented       ; $83 =
>c008	ac c0					.word NotImplemented       ; $84 <>
>c00a	ac c0					.word NotImplemented       ; $85 <
>c00c	ac c0					.word NotImplemented       ; $86 <=
>c00e	ac c0					.word NotImplemented       ; $87 >
>c010	ac c0					.word NotImplemented       ; $88 >=
>c012	d5 c5					.word BinaryOp_Add         ; $89 +
>c014	e8 c5					.word BinaryOp_Subtract    ; $8a -
>c016	fb c5					.word BinaryOp_Multiply    ; $8b *
>c018	0e c6					.word BinaryOp_Divide      ; $8c /
>c01a	ac c0					.word NotImplemented       ; $8d ^
>c01c	ac c0					.word NotImplemented       ; $8e if
>c01e	ac c0					.word NotImplemented       ; $8f while
>c020	ac c0					.word NotImplemented       ; $90 repeat
>c022	ac c0					.word NotImplemented       ; $91 for
>c024	ac c0					.word NotImplemented       ; $92 then
>c026	ac c0					.word NotImplemented       ; $93 endif
>c028	ac c0					.word NotImplemented       ; $94 wend
>c02a	ac c0					.word NotImplemented       ; $95 until
>c02c	ac c0					.word NotImplemented       ; $96 next
>c02e	ac c0					.word NotImplemented       ; $97 not
>c030	ac c0					.word NotImplemented       ; $98 fn(
>c032	ac c0					.word NotImplemented       ; $99 abs(
>c034	ac c0					.word NotImplemented       ; $9a asc(
>c036	ac c0					.word NotImplemented       ; $9b int(
>c038	ac c0					.word NotImplemented       ; $9c peek(
>c03a	ac c0					.word NotImplemented       ; $9d rnd(
>c03c	ac c0					.word NotImplemented       ; $9e usr(
>c03e	ac c0					.word NotImplemented       ; $9f left$(
>c040	ac c0					.word NotImplemented       ; $a0 right$(
>c042	ac c0					.word NotImplemented       ; $a1 mid$(
>c044	ac c0					.word NotImplemented       ; $a2 spc(
>c046	ac c0					.word NotImplemented       ; $a3 str$(
>c048	ac c0					.word NotImplemented       ; $a4 val(
>c04a	ac c0					.word NotImplemented       ; $a5 len(
>c04c	ac c0					.word NotImplemented       ; $a6 hex$(
>c04e	ac c0					.word NotImplemented       ; $a7 sin(
>c050	ac c0					.word NotImplemented       ; $a8 cos(
>c052	ac c0					.word NotImplemented       ; $a9 tan(
>c054	ac c0					.word NotImplemented       ; $aa atn(
>c056	ac c0					.word NotImplemented       ; $ab exp(
>c058	ac c0					.word NotImplemented       ; $ac log(
>c05a	ac c0					.word NotImplemented       ; $ad sqr(
>c05c	ac c0					.word NotImplemented       ; $ae dec(
>c05e	ac c0					.word NotImplemented       ; $af deek(
>c060	ac c0					.word NotImplemented       ; $b0 leek(
>c062	ac c0					.word NotImplemented       ; $b1 mod(
>c064	ac c0					.word NotImplemented       ; $b2 $(
>c066	ac c0					.word NotImplemented       ; $b3 $
>c068	ac c0					.word NotImplemented       ; $b4 #(
>c06a	ac c0					.word NotImplemented       ; $b5 #
>c06c	ac c0					.word NotImplemented       ; $b6 %(
>c06e	ac c0					.word NotImplemented       ; $b7 %
>c070	ac c0					.word NotImplemented       ; $b8 (
>c072	ac c0					.word NotImplemented       ; $b9 )
>c074	ac c0					.word NotImplemented       ; $ba ,
>c076	ac c0					.word NotImplemented       ; $bb :
>c078	ac c0					.word NotImplemented       ; $bc ;
>c07a	ac c0					.word NotImplemented       ; $bd def
>c07c	ac c0					.word NotImplemented       ; $be clr
>c07e	ac c0					.word NotImplemented       ; $c0 data
>c080	ac c0					.word NotImplemented       ; $c1 read
>c082	ac c0					.word NotImplemented       ; $c2 dim
>c084	ac c0					.word NotImplemented       ; $c3 to
>c086	ac c0					.word NotImplemented       ; $c4 step
>c088	ac c0					.word NotImplemented       ; $c5 gosub
>c08a	ac c0					.word NotImplemented       ; $c6 return
>c08c	ac c0					.word NotImplemented       ; $c7 goto
>c08e	ac c0					.word NotImplemented       ; $c8 input
>c090	ac c0					.word NotImplemented       ; $c9 let
>c092	ac c0					.word NotImplemented       ; $ca list
>c094	ac c0					.word NotImplemented       ; $cb new
>c096	ac c0					.word NotImplemented       ; $cc old
>c098	ac c0					.word NotImplemented       ; $cd on
>c09a	ac c0					.word NotImplemented       ; $ce restore
>c09c	ac c0					.word NotImplemented       ; $cf poke
>c09e	ac c0					.word NotImplemented       ; $d0 print
>c0a0	ac c0					.word NotImplemented       ; $d1 run
>c0a2	ac c0					.word NotImplemented       ; $d2 stop
>c0a4	ac c0					.word NotImplemented       ; $d3 wait
>c0a6	ac c0					.word NotImplemented       ; $d4 doke
>c0a8	ac c0					.word NotImplemented       ; $d5 loke
>c0aa	ac c0					.word NotImplemented       ; $d6 assert
.c0ac					NotImplemented:
.c0ac	80 fe		bra $c0ac		_error: bra _error
>c0ae	53 79 6e 74 61 78 20 45			.text "Syntax Error",0
>c0b6	72 72 6f 72 00
.c0bb					BinaryPrecedence:
>c0bb	01					.byte 1    ; $80 and
>c0bc	01					.byte 1    ; $81 or
>c0bd	01					.byte 1    ; $82 xor
>c0be	02					.byte 2    ; $83 =
>c0bf	02					.byte 2    ; $84 <>
>c0c0	02					.byte 2    ; $85 <
>c0c1	02					.byte 2    ; $86 <=
>c0c2	02					.byte 2    ; $87 >
>c0c3	02					.byte 2    ; $88 >=
>c0c4	03					.byte 3    ; $89 +
>c0c5	03					.byte 3    ; $8a -
>c0c6	04					.byte 4    ; $8b *
>c0c7	04					.byte 4    ; $8c /
>c0c8	05					.byte 5    ; $8d ^
.c0c9					KeywordText:
>c0c9	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>c0cc	4f d2					.byte $4f,$d2                          ; $81 or
>c0ce	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>c0d1	bd					.byte $bd                              ; $83 =
>c0d2	3c be					.byte $3c,$be                          ; $84 <>
>c0d4	bc					.byte $bc                              ; $85 <
>c0d5	3c bd					.byte $3c,$bd                          ; $86 <=
>c0d7	be					.byte $be                              ; $87 >
>c0d8	3e bd					.byte $3e,$bd                          ; $88 >=
>c0da	ab					.byte $ab                              ; $89 +
>c0db	ad					.byte $ad                              ; $8a -
>c0dc	aa					.byte $aa                              ; $8b *
>c0dd	af					.byte $af                              ; $8c /
>c0de	de					.byte $de                              ; $8d ^
>c0df	49 c6					.byte $49,$c6                          ; $8e if
>c0e1	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $8f while
>c0e6	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $90 repeat
>c0ec	46 4f d2				.byte $46,$4f,$d2                      ; $91 for
>c0ef	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $92 then
>c0f3	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $93 endif
>c0f8	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $94 wend
>c0fc	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $95 until
>c101	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $96 next
>c105	4e 4f d4				.byte $4e,$4f,$d4                      ; $97 not
>c108	46 4e a8				.byte $46,$4e,$a8                      ; $98 fn(
>c10b	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $99 abs(
>c10f	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9a asc(
>c113	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9b int(
>c117	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9c peek(
>c11c	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9d rnd(
>c120	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9e usr(
>c124	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $9f left$(
>c12a	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a0 right$(
>c131	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a1 mid$(
>c136	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a2 spc(
>c13a	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a3 str$(
>c13f	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a4 val(
>c143	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a5 len(
>c147	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a6 hex$(
>c14c	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a7 sin(
>c150	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a8 cos(
>c154	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $a9 tan(
>c158	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $aa atn(
>c15c	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ab exp(
>c160	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ac log(
>c164	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ad sqr(
>c168	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $ae dec(
>c16c	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $af deek(
>c171	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b0 leek(
>c176	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b1 mod(
>c17a	24 a8					.byte $24,$a8                          ; $b2 $(
>c17c	a4					.byte $a4                              ; $b3 $
>c17d	23 a8					.byte $23,$a8                          ; $b4 #(
>c17f	a3					.byte $a3                              ; $b5 #
>c180	25 a8					.byte $25,$a8                          ; $b6 %(
>c182	a5					.byte $a5                              ; $b7 %
>c183	a8					.byte $a8                              ; $b8 (
>c184	a9					.byte $a9                              ; $b9 )
>c185	ac					.byte $ac                              ; $ba ,
>c186	ba					.byte $ba                              ; $bb :
>c187	bb					.byte $bb                              ; $bc ;
>c188	44 45 c6				.byte $44,$45,$c6                      ; $bd def
>c18b	43 4c d2				.byte $43,$4c,$d2                      ; $be clr
>c18e	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c0 data
>c192	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c1 read
>c196	44 49 cd				.byte $44,$49,$cd                      ; $c2 dim
>c199	54 cf					.byte $54,$cf                          ; $c3 to
>c19b	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c4 step
>c19f	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $c5 gosub
>c1a4	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $c6 return
>c1aa	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $c7 goto
>c1ae	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $c8 input
>c1b3	4c 45 d4				.byte $4c,$45,$d4                      ; $c9 let
>c1b6	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $ca list
>c1ba	4e 45 d7				.byte $4e,$45,$d7                      ; $cb new
>c1bd	4f 4c c4				.byte $4f,$4c,$c4                      ; $cc old
>c1c0	4f ce					.byte $4f,$ce                          ; $cd on
>c1c2	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $ce restore
>c1c9	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $cf poke
>c1cd	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d0 print
>c1d2	52 55 ce				.byte $52,$55,$ce                      ; $d1 run
>c1d5	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $d2 stop
>c1d9	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d3 wait
>c1dd	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $d4 doke
>c1e1	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $d5 loke
>c1e5	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $d6 assert
>c1eb	00					.byte $00

;******  Return to file: modules/hardware/em65816.asm

.c1ec					StartROM:
.c1ec	18		clc				clc
.c1ed	fb		xce				xce
.c1ee	c2 30		rep #$30			rep 	#$30
.c1f0	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.c1f3	1b		tcs				tcs
.c1f4	e2 30		sep #$30			sep 	#$30 						; clear AXY in 16 bit.
.c1f6	c2 30		rep #$30			rep 	#$30
.c1f8	a9 00 00	lda #$0000			lda 	#$0000
.c1fb	aa		tax				tax
.c1fc	a8		tay				tay
.c1fd	e2 30		sep #$30			sep 	#$30
.c1ff	20 a3 c3	jsr $c3a3			jsr 	IF_Reset 					; reset external interface
.c202	20 08 c2	jsr $c208			jsr 	IFT_ClearScreen
.c205	4c f2 c3	jmp $c3f2		jmp BASIC_Start

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.c208					IFT_ClearScreen:
.c208	48		pha				pha
.c209	da		phx				phx
.c20a	5a		phy				phy
.c20b	20 a4 c3	jsr $c3a4			jsr 	IF_Home 					; home cursor
.c20e	a2 20		ldx #$20			ldx 	#IF_Height 					; this many lines.
.c210					_IFT_CS0:
.c210	a0 40		ldy #$40			ldy 	#IF_Width 					; this many chars/line
.c212					_IFT_CS1:
.c212	a9 20		lda #$20			lda 	#' '						; clear line.
.c214	20 d0 c3	jsr $c3d0			jsr 	IF_Write
.c217	88		dey				dey
.c218	d0 f8		bne $c212			bne 	_IFT_CS1
.c21a	20 b7 c3	jsr $c3b7			jsr 	IF_NewLine 					; next line down
.c21d	ca		dex				dex
.c21e	d0 f0		bne $c210			bne 	_IFT_CS0
.c220	7a		ply				ply
.c221	fa		plx				plx
.c222	68		pla				pla
.c223					IFT_HomeCursor:
.c223	48		pha				pha
.c224	20 a4 c3	jsr $c3a4			jsr 	IF_Home
.c227	a9 00		lda #$00			lda 	#0
.c229	8d 00 02	sta $0200			sta 	IFT_XCursor
.c22c	8d 01 02	sta $0201			sta 	IFT_YCursor
.c22f	68		pla				pla
.c230	60		rts				rts
.c231					IFT_UpLine:
.c231	48		pha				pha
.c232	ad 01 02	lda $0201			lda  	IFT_YCursor 				; get Y
.c235	3a		dec a				dec 	a 							; line above
.c236	30 03		bmi $c23b			bmi 	_IFTULExit 					; too far, abort
.c238	20 c6 c2	jsr $c2c6			jsr 	IFT_SetYPos					; set to that line.
.c23b					_IFTULExit:
.c23b	68		pla				pla
.c23c	60		rts				rts
.c23d					IFT_PrintCharacter:
.c23d	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.c23f	f0 16		beq $c257			beq 	IFT_NewLine
.c241	48		pha				pha
.c242	20 6f c2	jsr $c26f			jsr 	IFT_UpperCase 				; make upper case
.c245	20 d0 c3	jsr $c3d0			jsr 	IF_Write 					; write out.
.c248	ee 00 02	inc $0200			inc 	IFT_XCursor 				; bump x cursor
.c24b	ad 00 02	lda $0200			lda 	IFT_XCursor 				; reached RHS ?
.c24e	c9 40		cmp #$40			cmp 	#IF_Width
.c250	d0 03		bne $c255			bne 	_IFT_PCNotEOL
.c252	20 57 c2	jsr $c257			jsr 	IFT_NewLine 				; if so do new line.
.c255					_IFT_PCNotEOL:
.c255	68		pla				pla
.c256	60		rts				rts
.c257					IFT_NewLine:
.c257	48		pha				pha
.c258	20 b7 c3	jsr $c3b7			jsr 	IF_NewLine 					; new line on actual screen.
.c25b	a9 00		lda #$00			lda 	#0 							; reset x position
.c25d	8d 00 02	sta $0200			sta 	IFT_XCursor
.c260	ee 01 02	inc $0201			inc 	IFT_YCursor 				; move down.
.c263	ad 01 02	lda $0201			lda 	IFT_YCursor
.c266	c9 20		cmp #$20			cmp 	#IF_Height 					; reached bottom.
.c268	d0 03		bne $c26d			bne 	_IFT_NL_NotEOS
.c26a	20 7a c2	jsr $c27a			jsr 	IFT_Scroll 					; scroll screen up.
.c26d					_IFT_NL_NotEOS:
.c26d	68		pla				pla
.c26e	60		rts				rts
.c26f					IFT_UpperCase:
.c26f	c9 61		cmp #$61			cmp 	#"a"
.c271	90 06		bcc $c279			bcc 	_IFT_UCExit
.c273	c9 7b		cmp #$7b			cmp 	#"z"+1
.c275	b0 02		bcs $c279			bcs 	_IFT_UCExit
.c277	49 20		eor #$20			eor 	#$20
.c279					_IFT_UCExit:
.c279	60		rts				rts
.c27a					IFT_Scroll:
.c27a	48		pha				pha 								; save AXY
.c27b	da		phx				phx
.c27c	5a		phy				phy
.c27d	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.c27f					_IFT_SLoop:
.c27f	20 9f c2	jsr $c29f			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.c282	e8		inx				inx
.c283	e0 1f		cpx #$1f			cpx 	#IF_Height-1				; do whole screen
.c285	d0 f8		bne $c27f			bne 	_IFT_SLoop
.c287	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.c289	20 c6 c2	jsr $c2c6			jsr 	IFT_SetYPos
.c28c	a2 40		ldx #$40			ldx 	#IF_Width 					; blank line
.c28e					_IFT_SBlank:
.c28e	a9 20		lda #$20			lda 	#32
.c290	20 d0 c3	jsr $c3d0			jsr 	IF_Write
.c293	ca		dex				dex
.c294	d0 f8		bne $c28e			bne 	_IFT_SBlank
.c296	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.c298	20 c6 c2	jsr $c2c6			jsr 	IFT_SetYPos
.c29b	7a		ply				ply
.c29c	fa		plx				plx
.c29d	68		pla				pla
.c29e	60		rts				rts
.c29f					_IFT_ScrollLine:
.c29f	da		phx				phx
.c2a0	da		phx				phx
.c2a1	8a		txa				txa 								; copy line into buffer.
.c2a2	1a		inc a				inc 	a 							; next line down.
.c2a3	20 c6 c2	jsr $c2c6			jsr 	IFT_SetYPos
.c2a6	a2 00		ldx #$00			ldx 	#0
.c2a8					_IFTScrollCopy1:
.c2a8	20 c7 c3	jsr $c3c7			jsr 	IF_Read
.c2ab	9d 02 02	sta $0202,x			sta 	IFT_Buffer,x
.c2ae	e8		inx				inx
.c2af	e0 40		cpx #$40			cpx 	#IF_Width
.c2b1	d0 f5		bne $c2a8			bne 	_IFTScrollCopy1
.c2b3	68		pla				pla
.c2b4	20 c6 c2	jsr $c2c6			jsr 	IFT_SetYPos
.c2b7	a2 00		ldx #$00			ldx 	#0
.c2b9					_IFTScrollCopy2:
.c2b9	bd 02 02	lda $0202,x			lda 	IFT_Buffer,x
.c2bc	20 d0 c3	jsr $c3d0			jsr 	IF_Write
.c2bf	e8		inx				inx
.c2c0	e0 40		cpx #$40			cpx 	#IF_Width
.c2c2	d0 f5		bne $c2b9			bne 	_IFTScrollCopy2
.c2c4	fa		plx				plx
.c2c5	60		rts				rts
.c2c6					IFT_SetYPos:
.c2c6	48		pha				pha
.c2c7	da		phx				phx
.c2c8	aa		tax				tax
.c2c9	20 23 c2	jsr $c223			jsr 	IFT_HomeCursor
.c2cc	e0 00		cpx #$00			cpx 	#0
.c2ce	f0 09		beq $c2d9			beq 	_IFT_MOAExit
.c2d0					_IFT_MOALoop:
.c2d0	20 b7 c3	jsr $c3b7			jsr 	IF_NewLine
.c2d3	ee 01 02	inc $0201			inc 	IFT_YCursor
.c2d6	ca		dex				dex
.c2d7	d0 f7		bne $c2d0			bne		_IFT_MOALoop
.c2d9					_IFT_MOAExit:
.c2d9	fa		plx				plx
.c2da	68		pla				pla
.c2db	60		rts				rts
.c2dc					IFT_GetKeyCursor:
.c2dc	20 e4 c2	jsr $c2e4			jsr 	_IFT_FlipCursor 			; reverse current
.c2df					_IFT_GKCWait:
.c2df	20 e1 c3	jsr $c3e1			jsr 	IF_GetKey 					; get key
.c2e2	f0 fb		beq $c2df			beq 	_IFT_GKCWait
.c2e4					_IFT_FlipCursor:
.c2e4	48		pha				pha 								; save
.c2e5	20 c7 c3	jsr $c3c7			jsr 	IF_Read 					; read
.c2e8	20 d9 c3	jsr $c3d9			jsr 	IF_LeftOne
.c2eb	49 80		eor #$80			eor 	#$80 						; reverse
.c2ed	20 d0 c3	jsr $c3d0			jsr 	IF_Write 					; write
.c2f0	20 d9 c3	jsr $c3d9			jsr 	IF_LeftOne
.c2f3	68		pla				pla
.c2f4	60		rts				rts
.c2f5					IFT_ReadLine:
.c2f5	48		pha				pha
.c2f6					_IFT_RLLoop:
.c2f6	20 dc c2	jsr $c2dc			jsr 	IFT_GetKeyCursor 			; get keystroke
.c2f9	c9 0d		cmp #$0d			cmp 	#13							; return
.c2fb	f0 7d		beq $c37a			beq 	_IFT_RLExit
.c2fd	c9 20		cmp #$20			cmp 	#32 						; control character
.c2ff	90 05		bcc $c306			bcc 	_IFT_Control
.c301	20 3d c2	jsr $c23d			jsr 	IFT_PrintCharacter
.c304	80 f0		bra $c2f6			bra 	_IFT_RLLoop
.c306					_IFT_Control:
.c306	c9 01		cmp #$01			cmp 	#"A"-64
.c308	f0 26		beq $c330			beq 	_IFT_Left
.c30a	c9 04		cmp #$04			cmp 	#"D"-64
.c30c	f0 2e		beq $c33c			beq 	_IFT_Right
.c30e	c9 17		cmp #$17			cmp 	#"W"-64
.c310	f0 36		beq $c348			beq 	_IFT_Up
.c312	c9 13		cmp #$13			cmp 	#"S"-64
.c314	f0 3e		beq $c354			beq 	_IFT_Down
.c316	c9 08		cmp #$08			cmp 	#"H"-64
.c318	f0 09		beq $c323			beq 	_IFT_Backspace
.c31a	c9 1a		cmp #$1a			cmp 	#"Z"-64
.c31c	d0 d8		bne $c2f6			bne 	_IFT_RLLoop
.c31e	20 08 c2	jsr $c208			jsr 	IFT_ClearScreen				; clear CTL-Z
.c321	80 d3		bra $c2f6			bra 	_IFT_RLLoop
.c323					_IFT_Backspace:
.c323	ad 00 02	lda $0200			lda 	IFT_XCursor 				; check not start of line.
.c326	f0 ce		beq $c2f6			beq 	_IFT_RLLoop
.c328	20 d9 c3	jsr $c3d9			jsr 	IF_LeftOne
.c32b	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.c32d	20 d0 c3	jsr $c3d0			jsr 	IF_Write
.c330					_IFT_Left:
.c330	ce 00 02	dec $0200			dec 	IFT_XCursor 				; left CTL-W
.c333	10 29		bpl $c35e			bpl 	_IFT_Reposition
.c335	a9 3f		lda #$3f			lda 	#IF_Width-1
.c337					_IFT_SetX:
.c337	8d 00 02	sta $0200			sta 	IFT_XCursor
.c33a	80 22		bra $c35e			bra 	_IFT_Reposition
.c33c					_IFT_Right:
.c33c	ee 00 02	inc $0200			inc 	IFT_XCursor
.c33f	ad 00 02	lda $0200			lda 	IFT_XCursor
.c342	49 40		eor #$40			eor 	#IF_Width
.c344	f0 f1		beq $c337			beq 	_IFT_SetX
.c346	80 16		bra $c35e			bra 	_IFT_Reposition
.c348					_IFT_Up:
.c348	ce 01 02	dec $0201			dec 	IFT_YCursor
.c34b	10 11		bpl $c35e			bpl 	_IFT_Reposition
.c34d	a9 1f		lda #$1f			lda 	#IF_Height-1
.c34f					_IFT_SetY:
.c34f	8d 01 02	sta $0201			sta 	IFT_YCursor
.c352	80 0a		bra $c35e			bra 	_IFT_Reposition
.c354					_IFT_Down:
.c354	ee 01 02	inc $0201			inc 	IFT_YCursor
.c357	ad 01 02	lda $0201			lda 	IFT_YCursor
.c35a	49 20		eor #$20			eor 	#IF_Height
.c35c	f0 f1		beq $c34f			beq 	_IFT_SetY
.c35e					_IFT_Reposition:
.c35e	ad 00 02	lda $0200			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.c361	48		pha				pha
.c362	ad 01 02	lda $0201			lda 	IFT_YCursor
.c365	20 c6 c2	jsr $c2c6			jsr 	IFT_SetYPos
.c368	68		pla				pla
.c369	aa		tax				tax
.c36a	e0 00		cpx #$00			cpx 	#0
.c36c	f0 88		beq $c2f6			beq 	_IFT_RLLoop
.c36e					_IFT_MoveRight:
.c36e	20 c7 c3	jsr $c3c7			jsr 	IF_Read
.c371	ee 00 02	inc $0200			inc 	IFT_XCursor
.c374	ca		dex				dex
.c375	d0 f7		bne $c36e			bne 	_IFT_MoveRight
.c377	4c f6 c2	jmp $c2f6			jmp 	_IFT_RLLoop
.c37a					_IFT_RLExit:
.c37a	ad 01 02	lda $0201			lda 	IFT_YCursor 				; go to start of line.
.c37d	20 c6 c2	jsr $c2c6			jsr 	IFT_SetYPos
.c380	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.c382					_IFT_RLRead:
.c382	20 c7 c3	jsr $c3c7			jsr 	IF_Read
.c385	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.c388	e8		inx				inx
.c389	e0 40		cpx #$40			cpx 	#IF_Width
.c38b	d0 f5		bne $c382			bne 	_IFT_RLRead
.c38d					_IFT_RL_Trim:
.c38d	ca		dex				dex 	 							; previous char
.c38e	30 07		bmi $c397			bmi 	_IFT_Found 					; gone too far
.c390	bd 66 02	lda $0266,x			lda 	IFT_LineBuffer,x			; go back if space
.c393	c9 20		cmp #$20			cmp 	#" "
.c395	f0 f6		beq $c38d			beq 	_IFT_RL_Trim
.c397					_IFT_Found:
.c397	e8		inx				inx 								; forward to non-space
.c398	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.c39a	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.c39d	68		pla				pla
.c39e	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.c3a0	a0 02		ldy #$02			ldy 	#IFT_LineBuffer >> 8
.c3a2	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_em65816.asm

=64					IF_Width 	= 64 							; characters across
=32					IF_Height 	= 32 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line.
=8					IF_XPos 	= 8 							; current position, horizontal.
=$f0000					IF_Screen = $F0000							; 2k screen RAM here
=$f8010					IF_PKeyboard = $F8010						; Keyboard port.
=$f8000					IF_PBreak = $F8000 							; Break key.
.c3a3					IF_Reset:
.c3a3	60		rts				rts
.c3a4					IF_Home:
.c3a4	48		pha				pha
.c3a5	64 08		stz $08				stz 	IF_XPos 					; zero X position
.c3a7	a9 00		lda #$00			lda 	#IF_Screen & $FF 			; set r/w pos.
.c3a9	85 04		sta $04				sta 	IF_Pos
.c3ab	a9 00		lda #$00			lda 	#(IF_Screen >> 8) & $FF
.c3ad	85 05		sta $05				sta 	IF_Pos+1
.c3af	a9 0f		lda #$0f			lda 	#IF_Screen >> 16
.c3b1	85 06		sta $06				sta 	IF_Pos+2
.c3b3	64 07		stz $07				stz 	IF_Pos+3
.c3b5	68		pla				pla
.c3b6	60		rts				rts
.c3b7					IF_NewLine:
.c3b7	48		pha				pha
.c3b8	64 08		stz $08				stz 	IF_XPos						; back to start of line
.c3ba	18		clc				clc 								; down one line
.c3bb	a5 04		lda $04				lda 	IF_Pos
.c3bd	69 40		adc #$40			adc 	#64
.c3bf	85 04		sta $04				sta 	IF_Pos
.c3c1	90 02		bcc $c3c5			bcc 	_IF_NoCarry 				; carry through.
.c3c3	e6 05		inc $05				inc 	IF_Pos+1
.c3c5					_IF_NoCarry:
.c3c5	68		pla				pla
.c3c6	60		rts				rts
.c3c7					IF_Read:
.c3c7	5a		phy				phy 								; save current Y
.c3c8	a4 08		ldy $08				ldy 	IF_XPos 					; read character at current position
.c3ca	b7 04		lda [$04],y			lda 	[IF_Pos],y
.c3cc	e6 08		inc $08				inc 	IF_XPos 					; step right.
.c3ce	7a		ply				ply									; restore Y
.c3cf	60		rts				rts
.c3d0					IF_Write:
.c3d0	5a		phy				phy 								; save current Y
.c3d1	a4 08		ldy $08				ldy 	IF_XPos 					; write character at current position
.c3d3	97 04		sta [$04],y			sta 	[IF_Pos],y
.c3d5	e6 08		inc $08				inc 	IF_XPos 					; step right.
.c3d7	7a		ply				ply									; restore Y
.c3d8	60		rts				rts
.c3d9					IF_LeftOne:
.c3d9	c6 08		dec $08				dec 	IF_XPos
.c3db	60		rts				rts
.c3dc					IF_CheckBreak:
.c3dc	af 00 80 0f	lda $0f8000			lda 	IF_PBreak					; non-zero if Ctrl+C pressed.
.c3e0	60		rts				rts
.c3e1					IF_GetKey:
.c3e1	af 10 80 0f	lda $0f8010			lda 	IF_PKeyboard				; read keyboard
.c3e5	f0 08		beq $c3ef			beq		_IFGK_NoKey 				; skip if zero,no key pressed
.c3e7	48		pha				pha 								; key pressed, clear queue.
.c3e8	a9 00		lda #$00			lda 	#0
.c3ea	8f 10 80 0f	sta $0f8010			sta 	IF_PKeyboard
.c3ee	68		pla				pla
.c3ef					_IFGK_NoKey:
.c3ef	09 00		ora #$00			ora 	#0							; set Z flag appropriately.
.c3f1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm

.c3f2					BASIC_Start:
.c3f2	a9 00		lda #$00			lda 	#BasicProgram & $FF
.c3f4	85 16		sta $16				sta 	zCodePtr+0
.c3f6	a9 10		lda #$10			lda 	#BasicProgram >> 8
.c3f8	85 17		sta $17				sta 	zCodePtr+1
.c3fa	a9 00		lda #$00			lda 	#0
.c3fc	85 18		sta $18				sta 	zCodePtr+2
.c3fe	85 19		sta $19				sta 	zCodePtr+3
.c400	a0 03		ldy #$03			ldy 	#3
.c402	c8		iny				iny
.c403	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c405	20 0e c4	jsr $c40e			jsr 	EvaluateExpression
>c408	02						.byte 	2
.c409					SyntaxError:
.c409					ERR_Handler:
.c409	80 fe		bra $c409			bra 	ERR_Handler

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.c40b					EVESyntax:
.c40b	4c 09 c4	jmp $c409			jmp 	SyntaxError
.c40e					EvaluateExpression:
.c40e	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.c410					EvaluateExpressionX:
.c410	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.c412					EvaluateExpressionXA:
.c412	48		pha				pha 								; save precedence on stack.
.c413	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c415	f0 f4		beq $c40b			beq 	EVESyntax 					; end of line, syntax error.
.c417	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.c419	b0 03		bcs $c41e			bcs 	_EVNotVariable
.c41b	4c a3 c4	jmp $c4a3			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.c41e					_EVNotVariable:
.c41e	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.c420	90 e9		bcc $c40b			bcc 	EVESyntax
.c422	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.c424	b0 7b		bcs $c4a1			bcs 	_EVNotInteger
.c426	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.c428	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.c42b	a9 00		lda #$00			lda 	#0
.c42d	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c430	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c433	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c436	a9 01		lda #$01			lda 	#1 							; set to type 1 (integer)
.c438	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c43b					_EVCheckNextInteger:
.c43b	c8		iny				iny
.c43c	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c43e	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.c440	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.c442	b0 0d		bcs $c451			bcs 	_EVCheckDecimal
.c444	48		pha				pha 								; save it.
.c445	20 a7 c4	jsr $c4a7			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.c448	68		pla				pla
.c449	1d 00 03	ora $0300,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.c44c	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c44f	80 ea		bra $c43b			bra 	_EVCheckNextInteger
.c451					_EVCheckDecimal:
.c451	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c453	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.c455	d0 05		bne $c45c			bne 	_EVGotAtom 					; no, get atom.
.c457					_EVIsDecimal:
.c457	20 d7 c4	jsr $c4d7			jsr 	EVGetDecimal 				; extend to the decimal part.
.c45a	80 00		bra $c45c			bra 	_EVGotAtom 					; and continue to got atom.
.c45c					_EVGotAtom:
.c45c	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c45e	10 3f		bpl $c49f			bpl 	_EVExitDrop 				; must be a token.
.c460	c9 8e		cmp #$8e			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.c462	b0 3b		bcs $c49f			bcs 	_EVExitDrop
.c464	68		pla				pla 								; get current precedence
.c465	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.c467	da		phx				phx 								; save X
.c468	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c46a	aa		tax				tax 								; put in X
.c46b	bd 3b c0	lda $c03b,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.c46e	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.c470	fa		plx				plx 								; restore X
.c471	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.c473	90 2b		bcc $c4a0			bcc 	_EVExit 					; exit if too low.
.c475	f0 29		beq $c4a0			beq 	_EVExit 					; exit if equals
.c477	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.c479	48		pha				pha
.c47a	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c47c	48		pha				pha
.c47d	c8		iny				iny
.c47e	da		phx				phx 								; save current position
.c47f	e8		inx				inx
.c480	e8		inx				inx
.c481	e8		inx				inx
.c482	e8		inx				inx
.c483	e8		inx				inx
.c484	e8		inx				inx
.c485	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.c487	20 12 c4	jsr $c412			jsr 	EvaluateExpressionXA 		; do the RHS.
.c48a	fa		plx				plx 								; restore X
.c48b	68		pla				pla 								; get the binary operator in A.
.c48c	da		phx				phx 								; save X again
.c48d	0a		asl a				asl 	a 							; double, lose the MSB.
.c48e	aa		tax				tax									; put in X
.c48f	bd 00 c0	lda $c000,x			lda 	VectorTable,x 				; copy address into zGenPtr
.c492	85 1e		sta $1e				sta 	zGenPtr
.c494	bd 01 c0	lda $c001,x			lda 	VectorTable+1,x
.c497	85 1f		sta $1f				sta 	zGenPtr+1
.c499	fa		plx				plx 								; restore X
.c49a	20 a4 c4	jsr $c4a4			jsr 	EVGoZGenPtr 				; execute that function/operator
.c49d	80 bd		bra $c45c			bra 	_EVGotAtom 					; and loop back.
.c49f					_EVExitDrop:
.c49f	68		pla				pla
.c4a0					_EVExit:
.c4a0	60		rts				rts
.c4a1					_EVNotInteger:
.c4a1	80 fe		bra $c4a1			bra 	_EVNotInteger
.c4a3					_EVVariableHandler:
.c4a3	ea		nop				nop
.c4a4					EVGoZGenPtr:
.c4a4	6c 1e 00	jmp ($001e)			jmp 	 (zGenPtr)
.c4a7					EVShiftMantissaLeft6:
.c4a7	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.c4aa	9d 04 03	sta $0304,x			sta 	XS_Exponent,x
.c4ad	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c4b0	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c4b3	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c4b6	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c4b9	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.c4bc	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c4bf	a9 00		lda #$00			lda 	#0
.c4c1	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c4c4	20 c7 c4	jsr $c4c7			jsr 	_EVSMLShift 					; call it here to do it twice
.c4c7					_EVSMLShift:
.c4c7	5e 04 03	lsr $0304,x			lsr 	XS_Exponent,x
.c4ca	7e 03 03	ror $0303,x			ror 	XS_Mantissa+3,x
.c4cd	7e 02 03	ror $0302,x			ror 	XS_Mantissa+2,x
.c4d0	7e 01 03	ror $0301,x			ror 	XS_Mantissa+1,x
.c4d3	7e 00 03	ror $0300,x			ror 	XS_Mantissa+0,x
.c4d6	60		rts				rts
.c4d7					EVGetDecimal:
.c4d7	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.c4d9	8d 00 04	sta $0400			sta 	Num_Buffer
.c4dc	da		phx				phx
.c4dd	c8		iny				iny
.c4de	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c4e0	c8		iny				iny
.c4e1	3a		dec a				dec 	a								; convert to a string length.
.c4e2	3a		dec a				dec 	a
.c4e3	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.c4e5					_EVGDCopy:
.c4e5	48		pha				pha 									; save count
.c4e6	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c4e8	9d 00 04	sta $0400,x			sta 	Num_Buffer,x
.c4eb	e8		inx				inx 									; forward ....
.c4ec	c8		iny				iny
.c4ed	68		pla				pla 									; get count
.c4ee	3a		dec a				dec 	a 								; until zero
.c4ef	d0 f4		bne $c4e5			bne 	_EVGDCopy
.c4f1	9d 00 04	sta $0400,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.c4f4	fa		plx				plx 									; restore X
.c4f5	a9 00		lda #$00			lda 	#Num_Buffer & $FF 				; set zGenPtr
.c4f7	85 1e		sta $1e				sta 	zGenPtr
.c4f9	a9 04		lda #$04			lda 	#Num_Buffer >> 8
.c4fb	85 1f		sta $1f				sta 	zGenPtr+1
.c4fd	5a		phy				phy 									; save Y
.c4fe	a0 00		ldy #$00			ldy 	#0 								; start position
.c500	20 14 cc	jsr $cc14			jsr 	FPFromString 					; convert current
.c503	7a		ply				ply 									; restore Y
.c504	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/multiply.asm

.c505					MulInteger32:
.c505	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.c508	9d 0c 03	sta $030c,x			sta 	XS3_Mantissa,x
.c50b	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c50e	9d 0d 03	sta $030d,x			sta 	XS3_Mantissa+1,x
.c511	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c514	9d 0e 03	sta $030e,x			sta 	XS3_Mantissa+2,x
.c517	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c51a	9d 0f 03	sta $030f,x			sta 	XS3_Mantissa+3,x
.c51d	a9 00		lda #$00			lda 	#0
.c51f	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x 				; zero +0
.c522	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c525	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c528	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c52b					_BFMMultiply:
.c52b	bd 0c 03	lda $030c,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.c52e	29 01		and #$01			and 	#1
.c530	f0 03		beq $c535			beq 	_BFMNoAdd
.c532	20 21 c6	jsr $c621			jsr 	AddInteger32
.c535					_BFMNoAdd:
.c535	1e 06 03	asl $0306,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.c538	3e 07 03	rol $0307,x			rol 	XS2_Mantissa+1,x
.c53b	3e 08 03	rol $0308,x			rol 	XS2_Mantissa+2,x
.c53e	3e 09 03	rol $0309,x			rol 	XS2_Mantissa+3,x
.c541	5e 0f 03	lsr $030f,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.c544	7e 0e 03	ror $030e,x			ror 	XS3_Mantissa+2,x
.c547	7e 0d 03	ror $030d,x			ror 	XS3_Mantissa+1,x
.c54a	7e 0c 03	ror $030c,x			ror 	XS3_Mantissa,x
.c54d	bd 0c 03	lda $030c,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.c550	1d 0d 03	ora $030d,x			ora 	XS3_Mantissa+1,x
.c553	1d 0e 03	ora $030e,x			ora 	XS3_Mantissa+2,x
.c556	1d 0f 03	ora $030f,x			ora 	XS3_Mantissa+3,x
.c559	d0 d0		bne $c52b			bne 	_BFMMultiply
.c55b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/divide.asm

.c55c					DivInteger32:
.c55c	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x 			; check for /0
.c55f	1d 07 03	ora $0307,x			ora 	XS2_Mantissa+1,x
.c562	1d 08 03	ora $0308,x			ora 	XS2_Mantissa+2,x
.c565	1d 09 03	ora $0309,x			ora 	XS2_Mantissa+3,x
.c568	d0 13		bne $c57d			bne 	_BFDOkay
.c56a	80 fe		bra $c56a		_error: bra _error
>c56c	44 69 76 69 73 69 6f 6e				.text "Division by Zero",0
>c574	20 62 79 20 5a 65 72 6f 00
.c57d					_BFDOkay:
.c57d	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.c57f	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.c581	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.c583	85 1c		sta $1c				sta 	zLTemp1+2
.c585	85 1d		sta $1d				sta 	zLTemp1+3
.c587	5a		phy				phy 								; Y is the counter
.c588	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.c58a					_BFDLoop:
.c58a	1e 00 03	asl $0300,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.c58d	3e 01 03	rol $0301,x			rol 	XS_Mantissa+1,x
.c590	3e 02 03	rol $0302,x			rol 	XS_Mantissa+2,x
.c593	3e 03 03	rol $0303,x			rol 	XS_Mantissa+3,x
.c596	26 1a		rol $1a				rol 	zLTemp1
.c598	26 1b		rol $1b				rol 	zLTemp1+1
.c59a	26 1c		rol $1c				rol 	zLTemp1+2
.c59c	26 1d		rol $1d				rol 	zLTemp1+3
.c59e	38		sec				sec
.c59f	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.c5a1	fd 06 03	sbc $0306,x			sbc 	XS2_Mantissa+0,x
.c5a4	48		pha				pha
.c5a5	a5 1b		lda $1b				lda 	zLTemp1+1
.c5a7	fd 07 03	sbc $0307,x			sbc 	XS2_Mantissa+1,x
.c5aa	48		pha				pha
.c5ab	a5 1c		lda $1c				lda 	zLTemp1+2
.c5ad	fd 08 03	sbc $0308,x			sbc 	XS2_Mantissa+2,x
.c5b0	48		pha				pha
.c5b1	a5 1d		lda $1d				lda 	zLTemp1+3
.c5b3	fd 09 03	sbc $0309,x			sbc 	XS2_Mantissa+3,x
.c5b6	90 15		bcc $c5cd			bcc 	_BFDNoAdd
.c5b8	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.c5ba	68		pla				pla
.c5bb	85 1c		sta $1c				sta 	zLTemp1+2
.c5bd	68		pla				pla
.c5be	85 1b		sta $1b				sta 	zLTemp1+1
.c5c0	68		pla				pla
.c5c1	85 1a		sta $1a				sta 	zLTemp1+0
.c5c3	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.c5c6	09 01		ora #$01			ora 	#1
.c5c8	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c5cb	80 03		bra $c5d0			bra 	_BFDNext
.c5cd					_BFDNoAdd:
.c5cd	68		pla				pla 								; Throw away the intermediate calculations
.c5ce	68		pla				pla
.c5cf	68		pla				pla
.c5d0					_BFDNext:
.c5d0	88		dey				dey
.c5d1	d0 b7		bne $c58a			bne 	_BFDLoop
.c5d3	7a		ply				ply 								; restore Y and exit
.c5d4	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.c5d5					BinaryOp_Add:
.c5d5	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; and 2 type bytes together.
.c5d8	3d 0b 03	and $030b,x			and 	XS2_Type,x
.c5db	4a		lsr a				lsr 	a 							; shift bit 0 into C
.c5dc	90 03		bcc $c5e1			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.c5de	4c 21 c6	jmp $c621			jmp 	AddInteger32 							; so execute code at \1
.c5e1					_BCFloat:
.c5e1	20 6d c6	jsr $c66d			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.c5e4	4c a7 c6	jmp $c6a7			jmp 	FPAdd 							; and execute code at \2
.c5e7	60		rts				rts
.c5e8					BinaryOp_Subtract:
.c5e8	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; and 2 type bytes together.
.c5eb	3d 0b 03	and $030b,x			and 	XS2_Type,x
.c5ee	4a		lsr a				lsr 	a 							; shift bit 0 into C
.c5ef	90 03		bcc $c5f4			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.c5f1	4c 47 c6	jmp $c647			jmp 	SubInteger32 							; so execute code at \1
.c5f4					_BCFloat:
.c5f4	20 6d c6	jsr $c66d			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.c5f7	4c 9d c6	jmp $c69d			jmp 	FPSubtract 							; and execute code at \2
.c5fa	60		rts				rts
.c5fb					BinaryOp_Multiply:
.c5fb	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; and 2 type bytes together.
.c5fe	3d 0b 03	and $030b,x			and 	XS2_Type,x
.c601	4a		lsr a				lsr 	a 							; shift bit 0 into C
.c602	90 03		bcc $c607			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.c604	4c 05 c5	jmp $c505			jmp 	MulInteger32 							; so execute code at \1
.c607					_BCFloat:
.c607	20 6d c6	jsr $c66d			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.c60a	4c 12 c8	jmp $c812			jmp 	FPMultiply 							; and execute code at \2
.c60d	60		rts				rts
.c60e					BinaryOp_Divide:
.c60e	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; and 2 type bytes together.
.c611	3d 0b 03	and $030b,x			and 	XS2_Type,x
.c614	4a		lsr a				lsr 	a 							; shift bit 0 into C
.c615	90 03		bcc $c61a			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.c617	4c 5c c5	jmp $c55c			jmp 	DivInteger32 							; so execute code at \1
.c61a					_BCFloat:
.c61a	20 6d c6	jsr $c66d			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.c61d	4c 8a c7	jmp $c78a			jmp 	FPDivide 							; and execute code at \2
.c620	60		rts				rts
.c621					AddInteger32:
.c621	18		clc				clc
.c622	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.c625	7d 06 03	adc $0306,x			adc 	XS2_Mantissa+0,x
.c628	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c62b	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c62e	7d 07 03	adc $0307,x			adc 	XS2_Mantissa+1,x
.c631	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c634	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c637	7d 08 03	adc $0308,x			adc 	XS2_Mantissa+2,x
.c63a	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c63d	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c640	7d 09 03	adc $0309,x			adc 	XS2_Mantissa+3,x
.c643	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c646	60		rts				rts
.c647					SubInteger32:
.c647	38		sec				sec
.c648	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.c64b	fd 06 03	sbc $0306,x			sbc 	XS2_Mantissa+0,x
.c64e	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c651	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c654	fd 07 03	sbc $0307,x			sbc 	XS2_Mantissa+1,x
.c657	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c65a	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c65d	fd 08 03	sbc $0308,x			sbc 	XS2_Mantissa+2,x
.c660	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c663	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c666	fd 09 03	sbc $0309,x			sbc 	XS2_Mantissa+3,x
.c669	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c66c	60		rts				rts
.c66d					BinaryMakeBothFloat:
.c66d	da		phx				phx 								; save X
.c66e	e8		inx				inx
.c66f	e8		inx				inx
.c670	e8		inx				inx
.c671	e8		inx				inx
.c672	e8		inx				inx
.c673	e8		inx				inx
.c674	20 78 c6	jsr $c678			jsr 	BinaryMakeFloat 			; convert to float.
.c677	fa		plx				plx 								; restore X and fall through.
.c678					BinaryMakeFloat:
.c678	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; get type byte.
.c67b	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.c67c	b0 04		bcs $c682			bcs 	_BMFConvert
.c67e	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.c67f	b0 04		bcs $c685			bcs 	_BMFError
.c681	60		rts				rts
.c682					_BMFConvert:
.c682	4c c4 c9	jmp $c9c4			jmp 	FPUToFloat 					; convert to float
.c685					_BMFError:
.c685	80 fe		bra $c685		_error: bra _error
>c687	4e 75 6d 65 72 69 63 20				.text 	"Numeric type required",0
>c68f	74 79 70 65 20 72 65 71 75 69 72 65 64 00

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.c69d					FPSubtract:
.c69d	48		pha				pha
.c69e	bd 0b 03	lda $030b,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.c6a1	49 80		eor #$80			eor 	#$80
.c6a3	9d 0b 03	sta $030b,x			sta 	XS2_Type,x
.c6a6	68		pla				pla 								; --- and fall through ---
.c6a7					FPAdd:
.c6a7	48		pha				pha
.c6a8	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.c6ab	d0 05		bne $c6b2			bne 	_FPA_NegativeLHS
.c6ad	20 cf c6	jsr $c6cf			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.c6b0	68		pla				pla
.c6b1	60		rts				rts
.c6b2					_FPA_NegativeLHS:
.c6b2	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.c6b5	49 80		eor #$80			eor 	#$80
.c6b7	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c6ba	bd 0b 03	lda $030b,x			lda 	XS2_Type,x 					; flip the sign of B and add
.c6bd	49 80		eor #$80			eor 	#$80
.c6bf	9d 0b 03	sta $030b,x			sta 	XS2_Type,x
.c6c2	20 cf c6	jsr $c6cf			jsr 	FPAdd_Worker 				; do the add calculation.
.c6c5	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; flip sign of X1 back
.c6c8	49 80		eor #$80			eor 	#$80
.c6ca	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c6cd	68		pla				pla
.c6ce	60		rts				rts
.c6cf					FPAdd_Worker:
.c6cf	3c 0b 03	bit $030b,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.c6d2	70 08		bvs $c6dc			bvs 	_FPAWExit 					; no change.
.c6d4	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.c6d7	50 07		bvc $c6e0			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.c6d9	20 73 c9	jsr $c973			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.c6dc					_FPAWExit:
.c6dc	20 fb c9	jsr $c9fb			jsr 	FPUNormalise 				; normalise the result.
.c6df	60		rts				rts
.c6e0					_FPAWMakeSame:
.c6e0	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.c6e3	38		sec				sec
.c6e4	fd 0a 03	sbc $030a,x			sbc	 	XS2_Exponent,x 				; using subtraction
.c6e7	f0 1b		beq $c704			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.c6e9	da		phx				phx 								; save X
.c6ea	90 06		bcc $c6f2			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.c6ec	e8		inx				inx
.c6ed	e8		inx				inx
.c6ee	e8		inx				inx
.c6ef	e8		inx				inx
.c6f0	e8		inx				inx
.c6f1	e8		inx				inx
.c6f2					_FPAWShiftA:
.c6f2	fe 04 03	inc $0304,x			inc 	XS_Exponent,x 				; so shift exponent up.
.c6f5	5e 03 03	lsr $0303,x			lsr 	3+XS_Mantissa,x
.c6f8	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.c6fb	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.c6fe	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.c701	fa		plx				plx 								; restore original X
.c702	80 dc		bra $c6e0			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.c704					_FPAW_DoArithmetic:
.c704	3c 0b 03	bit $030b,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.c707	30 39		bmi $c742			bmi 	_FPAW_BNegative
.c709	18		clc				clc
.c70a	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.c70d	7d 06 03	adc $0306,x			adc 	XS2_Mantissa+0,x
.c710	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c713	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c716	7d 07 03	adc $0307,x			adc 	XS2_Mantissa+1,x
.c719	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c71c	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c71f	7d 08 03	adc $0308,x			adc 	XS2_Mantissa+2,x
.c722	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c725	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c728	7d 09 03	adc $0309,x			adc 	XS2_Mantissa+3,x
.c72b	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c72e	90 ac		bcc $c6dc			bcc 	_FPAWExit 					; no carry.
.c730	fe 04 03	inc $0304,x			inc 	XS_Exponent,x 				; so shift exponent up.
.c733	38		sec				sec
.c734	7e 03 03	ror $0303,x			ror 	3+XS_Mantissa,x
.c737	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.c73a	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.c73d	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.c740	80 9a		bra $c6dc			bra 	_FPAWExit
.c742					_FPAW_BNegative:
.c742	38		sec				sec
.c743	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.c746	fd 06 03	sbc $0306,x			sbc 	XS2_Mantissa+0,x
.c749	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c74c	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c74f	fd 07 03	sbc $0307,x			sbc 	XS2_Mantissa+1,x
.c752	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c755	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c758	fd 08 03	sbc $0308,x			sbc 	XS2_Mantissa+2,x
.c75b	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c75e	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c761	fd 09 03	sbc $0309,x			sbc 	XS2_Mantissa+3,x
.c764	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c767	b0 0b		bcs $c774			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.c769	20 a0 c9	jsr $c9a0			jsr 	FPUNegateInteger			; negate the mantissa
.c76c	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; flip result sign
.c76f	49 80		eor #$80			eor 	#$80
.c771	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c774					_FPAWGoExit:
.c774	4c dc c6	jmp $c6dc			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.c777					FPD_IsDivZero:
.c777	80 fe		bra $c777		_error: bra _error
>c779	44 69 76 69 73 69 6f 6e				.text 		"Division by zero",0
>c781	20 62 79 20 7a 65 72 6f 00
.c78a					FPDivide:
.c78a	48		pha				pha
.c78b	5a		phy				phy
.c78c	3c 0b 03	bit $030b,x			bit 	XS2_Type,x 					; check if division by zero
.c78f	70 e6		bvs $c777			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.c791	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.c794	f0 03		beq $c799			beq 	_FPDCalculateExp
.c796					_FPD_Exit:
.c796	7a		ply				ply
.c797	68		pla				pla
.c798	60		rts				rts
.c799					_FPDCalculateExp:
.c799	bd 0a 03	lda $030a,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.c79c	49 ff		eor #$ff			eor 	#$FF
.c79e	1a		inc a				inc 	a
.c79f	9d 0a 03	sta $030a,x			sta 	XS2_Exponent,x
.c7a2	20 96 c8	jsr $c896			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.c7a5	18		clc				clc 	 							; add 1 to the resulting exponent
.c7a6	69 01		adc #$01			adc 	#1
.c7a8	b0 65		bcs $c80f			bcs 	_FPD_Overflow 				; which can overflow.
.c7aa	9d 04 03	sta $0304,x			sta 	XS_Exponent,x
.c7ad	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.c7af	85 1a		sta $1a				sta 	zLTemp1+0
.c7b1	85 1b		sta $1b				sta 	zLTemp1+1
.c7b3	85 1c		sta $1c				sta 	zLTemp1+2
.c7b5	85 1d		sta $1d				sta 	zLTemp1+3
.c7b7	a0 20		ldy #$20			ldy 	#32 						; times round.
.c7b9					_FPD_Loop:
.c7b9	38		sec				sec 								; calculate X1-X2 stacking result because we might
.c7ba	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x 				; not save it.
.c7bd	fd 06 03	sbc $0306,x			sbc 	XS2_Mantissa,x
.c7c0	48		pha				pha
.c7c1	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c7c4	fd 07 03	sbc $0307,x			sbc 	XS2_Mantissa+1,x
.c7c7	48		pha				pha
.c7c8	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c7cb	fd 08 03	sbc $0308,x			sbc 	XS2_Mantissa+2,x
.c7ce	48		pha				pha
.c7cf	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c7d2	fd 09 03	sbc $0309,x			sbc 	XS2_Mantissa+3,x
.c7d5	90 17		bcc $c7ee			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.c7d7	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x 			; save results out to A
.c7da	68		pla				pla
.c7db	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c7de	68		pla				pla
.c7df	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c7e2	68		pla				pla
.c7e3	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c7e6	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.c7e8	09 80		ora #$80			ora 	#$80
.c7ea	85 1d		sta $1d				sta 	zLTemp1+3
.c7ec	80 03		bra $c7f1			bra 	_FPD_Rotates
.c7ee					_FPD_NoSubtract:
.c7ee	68		pla				pla 								; throw away unwanted results
.c7ef	68		pla				pla
.c7f0	68		pla				pla
.c7f1					_FPD_Rotates:
.c7f1	5e 09 03	lsr $0309,x			lsr 	3+XS2_Mantissa,x
.c7f4	7e 08 03	ror $0308,x			ror 	2+XS2_Mantissa,x
.c7f7	7e 07 03	ror $0307,x			ror 	1+XS2_Mantissa,x
.c7fa	7e 06 03	ror $0306,x			ror 	0+XS2_Mantissa,x
.c7fd	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.c7ff	26 1b		rol $1b				rol 	zLTemp1+1
.c801	26 1c		rol $1c				rol 	zLTemp1+2
.c803	26 1d		rol $1d				rol 	zLTemp1+3
.c805	90 02		bcc $c809			bcc 	_FPD_NoCarry
.c807	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.c809					_FPD_NoCarry:
.c809	88		dey				dey 								; do 32 times
.c80a	d0 ad		bne $c7b9			bne 	_FPD_Loop
.c80c	4c 73 c8	jmp $c873			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.c80f					_FPD_Overflow:
.c80f	4c 70 ca	jmp $ca70			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.c812					FPMultiply:
.c812	48		pha				pha
.c813	5a		phy				phy
.c814	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.c817	70 08		bvs $c821			bvs 	_FPM_Exit
.c819	3c 0b 03	bit $030b,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.c81c	50 06		bvc $c824			bvc 	_FPM_CalcExponent
.c81e	20 73 c9	jsr $c973			jsr 	FPUCopyX2ToX1
.c821					_FPM_Exit:
.c821	7a		ply				ply
.c822	68		pla				pla
.c823	60		rts				rts
.c824					_FPM_CalcExponent:
.c824	18		clc				clc
.c825	20 96 c8	jsr $c896			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.c828	9d 04 03	sta $0304,x			sta 	XS_Exponent,x 				; save the result.
.c82b	a9 00		lda #$00			lda 	#0
.c82d	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.c82f	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.c831	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.c833	85 1d		sta $1d				sta 	zLTemp1+3
.c835	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.c837					_FPM_Loop:
.c837	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x				; check LSB of long product
.c83a	29 01		and #$01			and 	#1
.c83c	18		clc				clc 								; clear carry for the long rotate.
.c83d	f0 1d		beq $c85c			beq 	_FPM_NoAddition
.c83f	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.c840	a5 1a		lda $1a				lda 	zLTemp1+0
.c842	7d 06 03	adc $0306,x			adc 	XS2_Mantissa+0,x
.c845	85 1a		sta $1a				sta 	zLTemp1+0
.c847	a5 1b		lda $1b				lda 	zLTemp1+1
.c849	7d 07 03	adc $0307,x			adc 	XS2_Mantissa+1,x
.c84c	85 1b		sta $1b				sta 	zLTemp1+1
.c84e	a5 1c		lda $1c				lda 	zLTemp1+2
.c850	7d 08 03	adc $0308,x			adc 	XS2_Mantissa+2,x
.c853	85 1c		sta $1c				sta 	zLTemp1+2
.c855	a5 1d		lda $1d				lda 	zLTemp1+3
.c857	7d 09 03	adc $0309,x			adc 	XS2_Mantissa+3,x
.c85a	85 1d		sta $1d				sta 	zLTemp1+3
.c85c					_FPM_NoAddition:
.c85c	66 1d		ror $1d				ror 	3+zLTemp1
.c85e	66 1c		ror $1c				ror 	2+zLTemp1
.c860	66 1b		ror $1b				ror 	1+zLTemp1
.c862	66 1a		ror $1a				ror 	0+zLTemp1
.c864	7e 03 03	ror $0303,x			ror 	3+XS_Mantissa,x
.c867	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.c86a	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.c86d	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.c870	88		dey				dey
.c871	d0 c4		bne $c837			bne 	_FPM_Loop 					; do this 32 times.
.c873					FPM_CopySignNormalize:
.c873	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.c875	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.c878	a5 1b		lda $1b				lda 	zLTemp1+1
.c87a	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c87d	a5 1c		lda $1c				lda 	zLTemp1+2
.c87f	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c882	a5 1d		lda $1d				lda 	zLTemp1+3
.c884	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c887	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; sign is xor of signs
.c88a	5d 0b 03	eor $030b,x			eor 	XS2_Type,x
.c88d	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c890	20 fb c9	jsr $c9fb			jsr 	FPUNormalise 				; normalise and exit.
.c893	7a		ply				ply
.c894	68		pla				pla
.c895	60		rts				rts
.c896					FPCalculateExponent:
.c896	18		clc				clc
.c897	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.c89a	7d 0a 03	adc $030a,x			adc 	XS2_Exponent,x
.c89d	b0 08		bcs $c8a7			bcs 	_FPCECarry 					; carry out ?
.c89f	10 03		bpl $c8a4			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.c8a1	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.c8a3	60		rts				rts
.c8a4					_FPCEExpZero:
.c8a4	a9 00		lda #$00			lda 	#0
.c8a6	60		rts				rts
.c8a7					_FPCECarry:
.c8a7	30 03		bmi $c8ac			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.c8a9	09 80		ora #$80			ora 	#$80 						; put in right range
.c8ab	60		rts				rts
.c8ac					_FPCEOverflow:
.c8ac	4c 70 ca	jmp $ca70			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.c8af					FPFractionalPart:
.c8af	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.c8b2	38		sec				sec 								; this flag tells us to keep the fractional part
.c8b3	30 0f		bmi $c8c4			bmi 	FPGetPart
.c8b5	60		rts				rts
.c8b6					FPIntegerPart:
.c8b6	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.c8b9	18		clc				clc 								; this flag says keep the integer part.
.c8ba	30 08		bmi $c8c4			bmi 	FPGetPart 					; -ve exponents are 0..127
.c8bc	48		pha				pha
.c8bd	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.c8bf	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c8c2	68		pla				pla
.c8c3	60		rts				rts
.c8c4					FPGetPart:
.c8c4	48		pha				pha
.c8c5	5a		phy				phy 								; save Y
.c8c6	08		php				php 								; save action
.c8c7	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.c8ca	70 62		bvs $c92e			bvs 	_FPGP_Exit 					; then do nothing.
.c8cc	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.c8ce	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.c8d0	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.c8d2	85 1c		sta $1c				sta 	zLTemp1+2
.c8d4	85 1d		sta $1d				sta 	zLTemp1+3
.c8d6	bd 04 03	lda $0304,x			lda 	XS_Exponent,x				; the number of shifts.
.c8d9	38		sec				sec
.c8da	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.c8dc	f0 12		beq $c8f0			beq 	_FPGP_NoShift 				; ... if any
.c8de	c9 20		cmp #$20			cmp 	#32
.c8e0	90 02		bcc $c8e4			bcc 	_FPGP_NotMax
.c8e2	a9 20		lda #$20			lda 	#32 						; max of 32.
.c8e4					_FPGP_NotMax:
.c8e4	a8		tay				tay 								; Y is the mask shift count.
.c8e5					_FPGP_ShiftMask:
.c8e5	46 1d		lsr $1d				lsr 	3+zLTemp1
.c8e7	66 1c		ror $1c				ror 	2+zLTemp1
.c8e9	66 1b		ror $1b				ror 	1+zLTemp1
.c8eb	66 1a		ror $1a				ror 	0+zLTemp1
.c8ed	88		dey				dey
.c8ee	d0 f5		bne $c8e5			bne 	_FPGP_ShiftMask
.c8f0					_FPGP_NoShift:
.c8f0	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.c8f2	8e 2d 04	stx $042d			stx 	ExpTemp						; save X
.c8f5					_FPGP_MaskLoop:
.c8f5	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.c8f8	28		plp				plp 								; if CC we keep the top part, so we
.c8f9	08		php				php		 							; flip the mask.
.c8fa	b0 02		bcs $c8fe			bcs		_FPGP_NoFlip
.c8fc	49 ff		eor #$ff			eor 	#$FF
.c8fe					_FPGP_NoFlip:
.c8fe	3d 00 03	and $0300,x			and 	XS_Mantissa,x 				; and into the mantissa.
.c901	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.c904	e8		inx				inx
.c905	c8		iny				iny
.c906	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.c908	d0 eb		bne $c8f5			bne 	_FPGP_MaskLoop
.c90a	ae 2d 04	ldx $042d			ldx 	ExpTemp						; restore X
.c90d	28		plp				plp
.c90e	08		php				php 								; get action flag on the stack
.c90f	90 05		bcc $c916			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.c911	a9 00		lda #$00			lda 	#0
.c913	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c916					_FPGP_NotFractional:
.c916	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x 						; check if \1 zero
.c919	1d 01 03	ora $0301,x			ora 	XS_Mantissa+1,x
.c91c	1d 02 03	ora $0302,x			ora 	XS_Mantissa+2,x
.c91f	1d 03 03	ora $0303,x			ora 	XS_Mantissa+3,x
.c922	f0 05		beq $c929			beq 	_FPGP_Zero 					; if zero, return zero
.c924	20 fb c9	jsr $c9fb			jsr 	FPUNormalise
.c927	80 05		bra $c92e			bra 	_FPGP_Exit 					; and exit
.c929					_FPGP_Zero:
.c929	a9 40		lda #$40			lda 	#$40 						; set zero flag
.c92b	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c92e					_FPGP_Exit:
.c92e	68		pla				pla 								; throw saved action flag.
.c92f	7a		ply				ply
.c930	68		pla				pla
.c931	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.c932					FPCompare:
.c932	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.c935	48		pha				pha
.c936	bd 0a 03	lda $030a,x			lda 	XS2_Exponent,x
.c939	48		pha				pha
.c93a	20 9d c6	jsr $c69d			jsr 	FPSubtract 					; calculate X1-X2
.c93d	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.c940	70 2c		bvs $c96e			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.c942	68		pla				pla
.c943	8d 2d 04	sta $042d			sta 	ExpTemp						; save first exponent in temporary reg.
.c946	68		pla				pla
.c947	38		sec				sec
.c948	ed 2d 04	sbc $042d			sbc 	ExpTemp 					; calculate AX-BX
.c94b	70 15		bvs $c962			bvs 	_FPCNotEqual				; overflow, can't be equal.
.c94d	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.c94e	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.c950	b0 10		bcs $c962			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.c952	38		sec				sec
.c953	ad 2d 04	lda $042d			lda 	ExpTemp 					; get one of the exponents back.
.c956	e9 18		sbc #$18			sbc 	#24 						; allow for 2^24 error, relatively.
.c958	b0 02		bcs $c95c			bcs 	_FPCNotRange 				; keep in range.
.c95a	a9 01		lda #$01			lda 	#1
.c95c					_FPCNotRange:
.c95c	38		sec				sec
.c95d	fd 04 03	sbc $0304,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.c960	b0 0e		bcs $c970			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.c962					_FPCNotEqual:
.c962	bd 05 03	lda $0305,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.c965	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.c967	f0 02		beq $c96b			beq 	_FPCNE2
.c969	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.c96b	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.c96c	80 04		bra $c972			bra 	_FPCExit
.c96e					_FPCPullZero:
.c96e	68		pla				pla 								; throw saved exponents
.c96f	68		pla				pla
.c970					_FPCZero:
.c970	a9 00		lda #$00			lda 	#0 							; and return zero
.c972					_FPCExit:
.c972	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.c973					FPUCopyX2ToX1:
.c973	48		pha				pha
.c974	da		phx				phx
.c975	5a		phy				phy
.c976	a0 08		ldy #$08			ldy 	#8
.c978	bd 06 03	lda $0306,x	_FPUC21:lda 	XS2_Mantissa,x
.c97b	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.c97e	e8		inx				inx
.c97f	88		dey				dey
.c980	10 f6		bpl $c978			bpl 	_FPUC21
.c982	7a		ply				ply
.c983	fa		plx				plx
.c984	68		pla				pla
.c985	60		rts				rts
.c986					FPUSetInteger:
.c986	48		pha				pha
.c987	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.c98a	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.c98c	10 02		bpl $c990			bpl 	_FPUSIExtend
.c98e	a9 ff		lda #$ff			lda 	#$FF
.c990					_FPUSIExtend:
.c990	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.c993	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c996	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c999	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.c99b	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c99e	68		pla				pla
.c99f	60		rts				rts
.c9a0					FPUNegateInteger:
.c9a0	48		pha				pha
.c9a1	38		sec				sec
.c9a2	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.c9a4	fd 00 03	sbc $0300,x			sbc 	XS_Mantissa+0,x
.c9a7	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c9aa	a9 00		lda #$00			lda 	#0
.c9ac	fd 01 03	sbc $0301,x			sbc 	XS_Mantissa+1,x
.c9af	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c9b2	a9 00		lda #$00			lda 	#0
.c9b4	fd 02 03	sbc $0302,x			sbc 	XS_Mantissa+2,x
.c9b7	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c9ba	a9 00		lda #$00			lda 	#0
.c9bc	fd 03 03	sbc $0303,x			sbc 	XS_Mantissa+3,x
.c9bf	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c9c2	68		pla				pla
.c9c3	60		rts				rts
.c9c4					FPUToFloat:
.c9c4	48		pha				pha
.c9c5	bd 05 03	lda $0305,x			lda 	XS_Type,x					; exit if already float.
.c9c8	29 0f		and #$0f			and 	#$0F
.c9ca	f0 2d		beq $c9f9			beq 	_FPUFExit
.c9cc	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.c9ce	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c9d1	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.c9d3	9d 04 03	sta $0304,x			sta 	XS_Exponent,x 				; x mantissa.
.c9d6	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.c9d9	10 08		bpl $c9e3			bpl		_FPUFPositive
.c9db	20 a0 c9	jsr $c9a0			jsr 	FPUNegateInteger 			; negate the mantissa
.c9de	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.c9e0	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c9e3					_FPUFPositive:
.c9e3	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.c9e6	1d 01 03	ora $0301,x			ora 	XS_Mantissa+1,x
.c9e9	1d 02 03	ora $0302,x			ora 	XS_Mantissa+2,x
.c9ec	1d 03 03	ora $0303,x			ora 	XS_Mantissa+3,x
.c9ef	d0 05		bne $c9f6			bne 	_FPUFNonZero
.c9f1	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.c9f3	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c9f6					_FPUFNonZero:
.c9f6	20 fb c9	jsr $c9fb			jsr 	FPUNormalise 				; normalise the floating point.
.c9f9					_FPUFExit:
.c9f9	68		pla				pla
.c9fa	60		rts				rts
.c9fb					FPUNormalise:
.c9fb	48		pha				pha
.c9fc	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.c9ff	70 20		bvs $ca21			bvs 	_FPUNExit
.ca01	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.ca04	f0 16		beq $ca1c			beq 	_FPUNSetZero
.ca06					_FPUNLoop:
.ca06	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.ca09	30 16		bmi $ca21			bmi 	_FPUNExit 					; if so, we are normalised.
.ca0b	1e 00 03	asl $0300,x			asl 	0+XS_Mantissa+0,x
.ca0e	3e 01 03	rol $0301,x			rol 	1+XS_Mantissa+0,x
.ca11	3e 02 03	rol $0302,x			rol 	2+XS_Mantissa+0,x
.ca14	3e 03 03	rol $0303,x			rol 	3+XS_Mantissa+0,x
.ca17	de 04 03	dec $0304,x			dec 	XS_Exponent,x 				; decrement exponent
.ca1a	d0 ea		bne $ca06			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.ca1c					_FPUNSetZero:
.ca1c	a9 40		lda #$40			lda 	#$40
.ca1e	9d 05 03	sta $0305,x			sta 	XS_Type,x 					; the result is now zero.
.ca21					_FPUNExit:
.ca21	68		pla				pla
.ca22	60		rts				rts
.ca23					FPUToInteger:
.ca23	48		pha				pha
.ca24	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; if already integer, exit
.ca27	29 01		and #$01			and 	#1
.ca29	d0 3e		bne $ca69			bne 	_FPUTOI_Exit
.ca2b	3c 05 03	bit $0305,x			bit 	XS_Type,x					; if zero, return zero.
.ca2e	70 2b		bvs $ca5b			bvs 	_FPUTOI_Zero
.ca30	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.ca33	10 26		bpl $ca5b			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.ca35	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.ca37	b0 37		bcs $ca70			bcs 	FP_Overflow
.ca39					_FPUToIToInteger:
.ca39	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.ca3c	c9 a0		cmp #$a0			cmp 	#128+32
.ca3e	f0 11		beq $ca51			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.ca40	fe 04 03	inc $0304,x			inc 	XS_Exponent,X 				; increment Exponent
.ca43	5e 03 03	lsr $0303,x			lsr 	3+XS_Mantissa,x
.ca46	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.ca49	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.ca4c	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.ca4f	80 e8		bra $ca39			bra 	_FPUToIToInteger 			; keep going.
.ca51					_FPUToICheckSign:
.ca51	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; check sign
.ca54	10 13		bpl $ca69			bpl 	_FPUToI_Exit 				; exit if unsigned.
.ca56	20 a0 c9	jsr $c9a0			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.ca59	80 0e		bra $ca69			bra 	_FPUTOI_Exit
.ca5b					_FPUTOI_Zero:
.ca5b	a9 00		lda #$00			lda 	#0 							; return zero integer.
.ca5d	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.ca60	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.ca63	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.ca66	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.ca69					_FPUToI_Exit:
.ca69	a9 01		lda #$01			lda 	#1 							; set type to integer
.ca6b	9d 05 03	sta $0305,x			sta 	XS_Type,x
.ca6e	68		pla				pla
.ca6f	60		rts				rts
.ca70					FP_Overflow:
.ca70	80 fe		bra $ca70		_error: bra _error
>ca72	46 6c 6f 61 74 69 6e 67				.text 	"Floating Point overflow",0
>ca7a	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.ca8a					FPUTimes10:
.ca8a	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.ca8d	85 1a		sta $1a				sta 	ZLTemp1+0
.ca8f	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.ca92	85 1b		sta $1b				sta 	ZLTemp1+1
.ca94	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.ca97	85 1c		sta $1c				sta 	ZLTemp1+2
.ca99	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.ca9c	85 1d		sta $1d				sta 	ZLTemp1+3
.ca9e	20 e2 ca	jsr $cae2			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.caa1	20 e2 ca	jsr $cae2			jsr 	_FPUT_LSR_ZLTemp1
.caa4	18		clc				clc
.caa5	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.caa8	65 1a		adc $1a				adc 	ZLTemp1+0
.caaa	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.caad	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.cab0	65 1b		adc $1b				adc 	ZLTemp1+1
.cab2	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.cab5	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.cab8	65 1c		adc $1c				adc 	ZLTemp1+2
.caba	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cabd	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.cac0	65 1d		adc $1d				adc 	ZLTemp1+3
.cac2	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.cac5	90 0f		bcc $cad6			bcc 	_FPUTimes10
.cac7	7e 03 03	ror $0303,x			ror 	3+XS_Mantissa,x
.caca	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.cacd	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.cad0	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.cad3	fe 04 03	inc $0304,x			inc 	XS_Exponent,x				; fix exponent
.cad6					_FPUTimes10:
.cad6	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.cad9	18		clc				clc
.cada	69 03		adc #$03			adc 	#3
.cadc	9d 04 03	sta $0304,x			sta 	XS_Exponent,x
.cadf	b0 8f		bcs $ca70			bcs 	FP_Overflow 				; error
.cae1	60		rts				rts
.cae2					_FPUT_LSR_ZLTemp1:
.cae2	46 1d		lsr $1d				lsr 	ZLTemp1+3
.cae4	66 1c		ror $1c				ror 	ZLTemp1+2
.cae6	66 1b		ror $1b				ror 	ZLTemp1+1
.cae8	66 1a		ror $1a				ror 	ZLTemp1+0
.caea	60		rts				rts
.caeb					FPUScale10A:
.caeb	5a		phy				phy
.caec	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.caee	f0 3d		beq $cb2d			beq 	_FPUScaleExit
.caf0	da		phx				phx 								; save X
.caf1	e8		inx				inx
.caf2	e8		inx				inx
.caf3	e8		inx				inx
.caf4	e8		inx				inx
.caf5	e8		inx				inx
.caf6	e8		inx				inx
.caf7	a8		tay				tay 								; save power scalar in Y.
.caf8	a9 00		lda #$00			lda 	#0
.cafa	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.cafd	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.cb00	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cb03	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cb06	a9 80		lda #$80			lda 	#$80
.cb08	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.cb0b	a9 81		lda #$81			lda 	#$81
.cb0d	9d 04 03	sta $0304,x			sta 	XS_Exponent,x
.cb10	5a		phy				phy 								; save 10^n on stack.
.cb11	c0 00		cpy #$00			cpy 	#0
.cb13	10 05		bpl $cb1a			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.cb15	98		tya				tya
.cb16	49 ff		eor #$ff			eor 	#$FF
.cb18	1a		inc a				inc 	a
.cb19	a8		tay				tay
.cb1a					_FPUSAbs:
.cb1a	20 8a ca	jsr $ca8a			jsr 	FPUTimes10
.cb1d	88		dey				dey
.cb1e	d0 fa		bne $cb1a			bne 	_FPUSAbs 					; tos is now 10^|AC|
.cb20	68		pla				pla 								; restore count in A
.cb21	fa		plx				plx 								; restore X pointing to number to scale.
.cb22	0a		asl a				asl 	a
.cb23	b0 05		bcs $cb2a			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.cb25	20 12 c8	jsr $c812			jsr 	FPMultiply 					; if clear multiply.
.cb28	80 03		bra $cb2d			bra		_FPUScaleExit
.cb2a					_FPUSDivide:
.cb2a	20 8a c7	jsr $c78a			jsr 	FPDivide
.cb2d					_FPUScaleExit:
.cb2d	7a		ply				ply
.cb2e	60		rts				rts
.cb2f					FPUCopyToNext:
.cb2f	a0 06		ldy #$06			ldy 		#6
.cb31	da		phx				phx
.cb32					_FPUCopy1:
.cb32	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x
.cb35	9d 06 03	sta $0306,x			sta 	XS2_Mantissa,x
.cb38	e8		inx				inx
.cb39	88		dey				dey
.cb3a	d0 f6		bne $cb32			bne 	_FPUCopy1
.cb3c	fa		plx				plx
.cb3d	60		rts				rts
.cb3e					FPUCopyFromNext:
.cb3e	a0 06		ldy #$06			ldy 		#6
.cb40	da		phx				phx
.cb41					_FPUCopy1:
.cb41	bd 06 03	lda $0306,x			lda 	XS2_Mantissa,x
.cb44	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.cb47	e8		inx				inx
.cb48	88		dey				dey
.cb49	d0 f6		bne $cb41			bne 	_FPUCopy1
.cb4b	fa		plx				plx
.cb4c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.cb4d					FPToString:
.cb4d	48		pha				pha
.cb4e	5a		phy				phy
.cb4f	3c 05 03	bit $0305,x			bit 		XS_Type,x 				; check zero flag
.cb52	50 0a		bvc $cb5e			bvc 		_FPTSIsFloat 			; if zero,
.cb54					_FPTSZero:
.cb54	a9 30		lda #$30			lda 		#"0"
.cb56	20 31 cd	jsr $cd31			jsr 		ITSOutputCharacter
.cb59					_FPTSExit:
.cb59	7a		ply				ply
.cb5a	68		pla				pla
.cb5b	60		rts				rts
.cb5c	80 fb		bra $cb59			bra 		_FPTSExit
.cb5e					_FPTSIsFloat:
.cb5e	bd 05 03	lda $0305,x			lda 		XS_Type,x 				; is it signed ?
.cb61	10 0a		bpl $cb6d			bpl 		_FPTSNotSigned
.cb63	a9 00		lda #$00			lda 		#0 						; clear sign flag
.cb65	9d 05 03	sta $0305,x			sta 		XS_Type,x
.cb68	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.cb6a	20 31 cd	jsr $cd31			jsr 		ITSOutputCharacter
.cb6d					_FPTSNotSigned:
.cb6d	bd 04 03	lda $0304,x			lda 		XS_Exponent,x
.cb70	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.cb72	b0 09		bcs $cb7d			bcs 		_FPTSExponent
.cb74	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.cb76	90 05		bcc $cb7d			bcc 		_FPTSExponent 			;
.cb78					_FPTSStandard:
.cb78	20 c1 cb	jsr $cbc1			jsr 		FPTOutputBody 			; output the body.
.cb7b	80 dc		bra $cb59			bra 		_FPTSExit
.cb7d					_FPTSExponent:
.cb7d	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.cb7f	8d 2e 04	sta $042e			sta 		ExpCount
.cb82					_FPTSExponentLoop:
.cb82	bd 04 03	lda $0304,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.cb85	10 0e		bpl $cb95			bpl 		_FPTSTimes
.cb87	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.cb89	90 14		bcc $cb9f			bcc 		_FPTSScaledToExp
.cb8b	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.cb8d	20 eb ca	jsr $caeb			jsr 		FPUScale10A
.cb90	ee 2e 04	inc $042e			inc 		ExpCount
.cb93	80 ed		bra $cb82			bra 		_FPTSExponentLoop
.cb95					_FPTSTimes:
.cb95	a9 01		lda #$01			lda 		#1
.cb97	20 eb ca	jsr $caeb			jsr 		FPUScale10A
.cb9a	ce 2e 04	dec $042e			dec 		ExpCount
.cb9d	80 e3		bra $cb82			bra 		_FPTSExponentLoop
.cb9f					_FPTSScaledToExp:
.cb9f	20 c1 cb	jsr $cbc1			jsr 		FPTOutputBody 			; output the body.
.cba2	a9 65		lda #$65			lda 		#"e"					; output E
.cba4	20 31 cd	jsr $cd31			jsr 		ITSOutputCharacter
.cba7	ad 2e 04	lda $042e			lda 		ExpCount 				; get the exponent
.cbaa	9d 00 03	sta $0300,x			sta 		XS_Mantissa,x
.cbad	29 80		and #$80			and 		#$80 					; sign extend it
.cbaf	f0 02		beq $cbb3			beq 		_FPTSSExt
.cbb1	a9 ff		lda #$ff			lda 		#$FF
.cbb3					_FPTSSExt:
.cbb3	9d 01 03	sta $0301,x			sta 		XS_Mantissa+1,x
.cbb6	9d 02 03	sta $0302,x			sta 		XS_Mantissa+2,x
.cbb9	9d 03 03	sta $0303,x			sta 		XS_Mantissa+3,x
.cbbc	20 95 cc	jsr $cc95			jsr 		INTToString 			; output the exponent.
.cbbf	80 98		bra $cb59			bra			_FPTSExit 				; and exit.
.cbc1					FPTOutputBody:
.cbc1	20 2f cb	jsr $cb2f			jsr 		FPUCopyToNext 			; copy to next slot.
.cbc4	20 23 ca	jsr $ca23			jsr 		FPUToInteger 			; convert to an integer
.cbc7	20 95 cc	jsr $cc95			jsr 		INTToString 			; output the main integer part.
.cbca	20 3e cb	jsr $cb3e			jsr 		FPUCopyFromNext 		; get the fractional part back.
.cbcd	20 af c8	jsr $c8af			jsr 		FPFractionalPart 		; get the decimal part.
.cbd0	3c 05 03	bit $0305,x			bit 		XS_Type,x 				; any fractional part.
.cbd3	70 3e		bvs $cc13			bvs 		_FPTOExit 				; if not, exit now.
.cbd5	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.cbd7	20 31 cd	jsr $cd31			jsr 		ITSOutputCharacter
.cbda					_FPOutLoop:
.cbda	3c 05 03	bit $0305,x			bit 		XS_Type,x 				; finally reached zero.
.cbdd	70 1e		bvs $cbfd			bvs 		_FPStripZeros 			; strip trailing zeros
.cbdf	20 8a ca	jsr $ca8a			jsr 		FPUTimes10 				; multiply by 10
.cbe2	20 2f cb	jsr $cb2f			jsr 		FPUCopyToNext			; copy to next slot.
.cbe5	20 23 ca	jsr $ca23			jsr 		FPUToInteger 			; convert to integer
.cbe8	bd 00 03	lda $0300,x			lda 		XS_Mantissa+0,x 		; print digit.
.cbeb	09 30		ora #$30			ora 		#"0"
.cbed	20 31 cd	jsr $cd31			jsr 		ITSOutputCharacter
.cbf0	20 3e cb	jsr $cb3e			jsr 		FPUCopyFromNext 		; get it back
.cbf3	20 af c8	jsr $c8af			jsr 		FPFractionalPart 		; get fractional part
.cbf6	ad 20 04	lda $0420			lda 		NumBufX 				; done 11 characters yet ?
.cbf9	c9 0b		cmp #$0b			cmp 	 	#11
.cbfb	90 dd		bcc $cbda			bcc 		_FPOutLoop 				; if so, keep going till zero.
.cbfd					_FPStripZeros:
.cbfd	ac 20 04	ldy $0420			ldy 		NumBufX 				; strip trailing zeros.
.cc00					_FPStripLoop:
.cc00	88		dey				dey 								; back one, if at start then no strip
.cc01	f0 10		beq $cc13			beq 		_FPToExit
.cc03	b9 00 04	lda $0400,y			lda 		Num_Buffer,y 			; keep going if "0"
.cc06	c9 30		cmp #$30			cmp 		#"0"
.cc08	f0 f6		beq $cc00			beq 		_FPStripLoop
.cc0a	c8		iny				iny
.cc0b	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.cc0d	99 00 04	sta $0400,y			sta 		Num_Buffer,y
.cc10	8c 20 04	sty $0420			sty 		NumBufX 				; update position.
.cc13					_FPTOExit:
.cc13	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.cc14					FPFromString:
.cc14	48		pha				pha 								; push A
.cc15	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.cc17	c9 2e		cmp #$2e			cmp 	#"."
.cc19	f0 03		beq $cc1e			beq	 	_FPFIsDecimal
.cc1b	4c 81 cc	jmp $cc81			jmp 	_FPFNotDecimal
.cc1e					_FPFIsDecimal:
.cc1e	c8		iny				iny 								; consume the decimal.
.cc1f	20 c4 c9	jsr $c9c4			jsr 	FPUToFloat 					; convert the integer to float.
.cc22	da		phx				phx 								; save X.
.cc23	5a		phy				phy 								; save decimal start position
.cc24	e8		inx				inx
.cc25	e8		inx				inx
.cc26	e8		inx				inx
.cc27	e8		inx				inx
.cc28	e8		inx				inx
.cc29	e8		inx				inx
.cc2a	20 49 cd	jsr $cd49			jsr 	INTFromStringY 				; get the part after the DP.
.cc2d	20 c4 c9	jsr $c9c4			jsr 	FPUToFloat 					; convert that to a float.
.cc30	68		pla				pla 								; calculate - chars consumed.
.cc31	8c 2d 04	sty $042d			sty 	ExpTemp
.cc34	38		sec				sec
.cc35	ed 2d 04	sbc $042d			sbc 	ExpTemp 					; this is the shift amount
.cc38	20 eb ca	jsr $caeb			jsr 	FPUScale10A 				; scale it by 10^AC
.cc3b	fa		plx				plx 								; restore original X
.cc3c	20 a7 c6	jsr $c6a7			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.cc3f	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.cc41	c9 45		cmp #$45			cmp 	#"E"
.cc43	f0 04		beq $cc49			beq 	_FPFExponent
.cc45	c9 65		cmp #$65			cmp 	#"e"
.cc47	d0 38		bne $cc81			bne 	_FPFNotDecimal 				; no, then exit normally.
.cc49					_FPFExponent:
.cc49	c8		iny				iny 								; skip over E symbol.
.cc4a	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.cc4c	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.cc4e	d0 01		bne $cc51			bne 	_FPFGotSign
.cc50	c8		iny				iny 								; if it was - skip over it.
.cc51					_FPFGotSign:
.cc51	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.cc52	da		phx				phx
.cc53	e8		inx				inx
.cc54	e8		inx				inx
.cc55	e8		inx				inx
.cc56	e8		inx				inx
.cc57	e8		inx				inx
.cc58	e8		inx				inx
.cc59	20 49 cd	jsr $cd49			jsr 	INTFromStringY 				; get the exponent
.cc5c	fa		plx				plx 								; restore X.
.cc5d	bd 07 03	lda $0307,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.cc60	1d 09 03	ora $0309,x			ora 	XS2_Mantissa+3,x
.cc63	1d 08 03	ora $0308,x			ora 	XS2_Mantissa+2,x
.cc66	d0 1b		bne $cc83			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.cc68	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.cc6b	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.cc6d	b0 14		bcs $cc83			bcs 	_FPFXOverflow
.cc6f	68		pla				pla 								; get direction
.cc70	d0 09		bne $cc7b			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.cc72	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.cc75	49 ff		eor #$ff			eor 	#$FF
.cc77	1a		inc a				inc 	a
.cc78	9d 06 03	sta $0306,x			sta 	XS2_Mantissa+0,x
.cc7b					_FPFXScale:
.cc7b	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.cc7e	20 eb ca	jsr $caeb			jsr 	FPUScale10A 				; scale by the exponent.
.cc81					_FPFNotDecimal:
.cc81	68		pla				pla
.cc82	60		rts				rts
.cc83					_FPFXOverflow:
.cc83	20 09 c4	jsr $c409			jsr 	ERR_Handler
>cc86	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>cc8e	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.cc95					INTToString:
.cc95	48		pha				pha
.cc96	5a		phy				phy
.cc97	bd 03 03	lda $0303,x			lda 		XS_Mantissa+3,x 		; check -ve
.cc9a	10 08		bpl $cca4			bpl 		_ITSNotMinus
.cc9c	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.cc9e	20 31 cd	jsr $cd31			jsr 		ITSOutputCharacter
.cca1	20 a0 c9	jsr $c9a0			jsr 		FPUNegateInteger
.cca4					_ITSNotMinus:
.cca4	a9 00		lda #$00			lda 		#0 						; X is offset in table.
.cca6	8d 21 04	sta $0421			sta 		NumSuppress 			; clear the suppression flag.
.cca9	a0 00		ldy #$00			ldy 		#0 						; Y is index into dword subtraction table.
.ccab					_ITSNextSubtractor:
.ccab	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.ccad	8d 22 04	sta $0422			sta 		NumConvCount
.ccb0					_ITSSubtract:
.ccb0	38		sec				sec
.ccb1	bd 00 03	lda $0300,x			lda 		XS_Mantissa,x 			; subtract number and push on stack
.ccb4	f9 0d cd	sbc $cd0d,y			sbc 		_ITSSubtractors+0,y
.ccb7	48		pha				pha
.ccb8	bd 01 03	lda $0301,x			lda 		XS_Mantissa+1,x
.ccbb	f9 0e cd	sbc $cd0e,y			sbc 		_ITSSubtractors+1,y
.ccbe	48		pha				pha
.ccbf	bd 02 03	lda $0302,x			lda 		XS_Mantissa+2,x
.ccc2	f9 0f cd	sbc $cd0f,y			sbc 		_ITSSubtractors+2,y
.ccc5	48		pha				pha
.ccc6	bd 03 03	lda $0303,x			lda 		XS_Mantissa+3,x
.ccc9	f9 10 cd	sbc $cd10,y			sbc 		_ITSSubtractors+3,y
.cccc	90 14		bcc $cce2			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.ccce	9d 03 03	sta $0303,x			sta 		XS_Mantissa+3,x 		; save subtract off stack
.ccd1	68		pla				pla
.ccd2	9d 02 03	sta $0302,x			sta 		XS_Mantissa+2,x
.ccd5	68		pla				pla
.ccd6	9d 01 03	sta $0301,x			sta 		XS_Mantissa+1,x
.ccd9	68		pla				pla
.ccda	9d 00 03	sta $0300,x			sta 		XS_Mantissa+0,x
.ccdd	ee 22 04	inc $0422			inc 		NumConvCount 			; bump count.
.cce0	80 ce		bra $ccb0			bra 		_ITSSubtract 			; go round again.
.cce2					_ITSCantSubtract:
.cce2	68		pla				pla 								; throw away interim answers
.cce3	68		pla				pla
.cce4	68		pla				pla
.cce5	ad 22 04	lda $0422			lda 		NumConvCount 			; if not zero then no suppression check
.cce8	c9 30		cmp #$30			cmp 		#"0"
.ccea	d0 05		bne $ccf1			bne 		_ITSOutputDigit
.ccec	ad 21 04	lda $0421			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.ccef	10 09		bpl $ccfa			bpl 		_ITSGoNextSubtractor
.ccf1					_ITSOutputDigit:
.ccf1	ce 21 04	dec $0421			dec 		NumSuppress 			; suppression check will be non-zero.
.ccf4	ad 22 04	lda $0422			lda 		NumConvCount 			; count of subtractions
.ccf7	20 31 cd	jsr $cd31			jsr 		ITSOutputCharacter 		; output it.
.ccfa					_ITSGoNextSubtractor:
.ccfa	c8		iny				iny 								; next dword
.ccfb	c8		iny				iny
.ccfc	c8		iny				iny
.ccfd	c8		iny				iny
.ccfe	c0 24		cpy #$24			cpy 		#_ITSSubtractorsEnd-_ITSSubtractors
.cd00	d0 a9		bne $ccab			bne 		_ITSNextSubtractor 		; do all the subtractors.
.cd02	bd 00 03	lda $0300,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.cd05	09 30		ora #$30			ora 		#"0"
.cd07	20 31 cd	jsr $cd31			jsr 		ITSOutputCharacter
.cd0a	7a		ply				ply 								; and exit
.cd0b	68		pla				pla
.cd0c	60		rts				rts
.cd0d					_ITSSubtractors:
>cd0d	00 ca 9a 3b					.dword 		1000000000
>cd11	00 e1 f5 05					.dword 		100000000
>cd15	80 96 98 00					.dword 		10000000
>cd19	40 42 0f 00					.dword 		1000000
>cd1d	a0 86 01 00					.dword 		100000
>cd21	10 27 00 00					.dword 		10000
>cd25	e8 03 00 00					.dword 		1000
>cd29	64 00 00 00					.dword 		100
>cd2d	0a 00 00 00					.dword 		10
.cd31					_ITSSubtractorsEnd:
.cd31					ITSOutputCharacter:
.cd31	48		pha				pha
.cd32	da		phx				phx
.cd33	ae 20 04	ldx $0420			ldx 	NumBufX 					; save digit
.cd36	9d 00 04	sta $0400,x			sta 	Num_Buffer,x
.cd39	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.cd3b	9d 01 04	sta $0401,x			sta 	Num_Buffer+1,x
.cd3e	ee 20 04	inc $0420			inc 	NumBufX						; bump pointer.
.cd41	fa		plx				plx
.cd42	68		pla				pla
.cd43	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.cd44					IntFromString:
.cd44	a0 00		ldy #$00			ldy 	#0
.cd46	8c 2d 04	sty $042d			sty 	ExpTemp 					; this is the converted digit count.
.cd49					IntFromStringY:
.cd49	48		pha				pha
.cd4a	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.cd4c	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.cd4f	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.cd52	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cd55	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.cd58	a9 01		lda #$01			lda 	#1
.cd5a	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cd5d					_IFSLoop:
.cd5d	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.cd5f	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.cd61	90 60		bcc $cdc3			bcc 	_IFSExit
.cd63	c9 3a		cmp #$3a			cmp 	#"9"+1
.cd65	b0 5c		bcs $cdc3			bcs 	_IFSExit
.cd67	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.cd6a	c9 0c		cmp #$0c			cmp 	#12
.cd6c	b0 5f		bcs $cdcd			bcs 	_IFSOverflow
.cd6e	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.cd71	48		pha				pha
.cd72	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.cd75	48		pha				pha
.cd76	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.cd79	48		pha				pha
.cd7a	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.cd7d	48		pha				pha
.cd7e	20 e2 cd	jsr $cde2			jsr 	IFSX1ShiftLeft 				; double
.cd81	20 e2 cd	jsr $cde2			jsr 	IFSX1ShiftLeft 				; x 4
.cd84	18		clc				clc 								; add saved value x 5
.cd85	68		pla				pla
.cd86	7d 00 03	adc $0300,x			adc 	XS_Mantissa+0,x
.cd89	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.cd8c	68		pla				pla
.cd8d	7d 01 03	adc $0301,x			adc 	XS_Mantissa+1,x
.cd90	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.cd93	68		pla				pla
.cd94	7d 02 03	adc $0302,x			adc 	XS_Mantissa+2,x
.cd97	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cd9a	68		pla				pla
.cd9b	7d 03 03	adc $0303,x			adc 	XS_Mantissa+3,x
.cd9e	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.cda1	20 e2 cd	jsr $cde2			jsr 	IFSX1ShiftLeft 				; x 10
.cda4	ee 2d 04	inc $042d			inc 	ExpTemp 					; bump count of digits processed.
.cda7	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.cda9	29 0f		and #$0f			and 	#15
.cdab	c8		iny				iny
.cdac	7d 00 03	adc $0300,x			adc 	XS_Mantissa+0,x
.cdaf	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.cdb2	90 a9		bcc $cd5d			bcc 	_IFSLoop
.cdb4	fe 01 03	inc $0301,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.cdb7	d0 a4		bne $cd5d			bne 	_IFSLoop
.cdb9	fe 02 03	inc $0302,x			inc 	XS_Mantissa+2,x
.cdbc	d0 9f		bne $cd5d			bne 	_IFSLoop
.cdbe	fe 03 03	inc $0303,x			inc 	XS_Mantissa+3,x
.cdc1	80 9a		bra $cd5d			bra 	_IFSLoop
.cdc3					_IFSExit:
.cdc3	98		tya				tya 								; get offset
.cdc4					_IFSOkay:
.cdc4	38		sec				sec
.cdc5	ad 2d 04	lda $042d			lda 	ExpTemp
.cdc8	f0 01		beq $cdcb			beq 	_IFSSkipFail
.cdca	18		clc				clc
.cdcb					_IFSSkipFail:
.cdcb	68		pla				pla 								; and exit.
.cdcc	60		rts				rts
.cdcd					_IFSOverflow:
.cdcd	20 09 c4	jsr $c409			jsr 	ERR_Handler
>cdd0	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>cdd8	20 6f 76 65 72 66 6c 6f 77 00
.cde2					IFSX1ShiftLeft:
.cde2	1e 00 03	asl $0300,x			asl 	0+XS_Mantissa,x
.cde5	3e 01 03	rol $0301,x			rol 	1+XS_Mantissa,x
.cde8	3e 02 03	rol $0302,x			rol 	2+XS_Mantissa,x
.cdeb	3e 03 03	rol $0303,x			rol 	3+XS_Mantissa,x
.cdee	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.cdef					TIM_Error:
.cdef	20 31 c2	jsr $c231			jsr 	IFT_UpLine 					; go up one line.
.cdf2	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.cdf4	80 02		bra $cdf8			bra 	TIM_ShowPrompt
.cdf6					TIM_NewCommand:
.cdf6	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.cdf8					TIM_ShowPrompt:
.cdf8	20 3d c2	jsr $c23d			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.cdfb	20 f5 c2	jsr $c2f5			jsr 	IFT_ReadLine	 			; get character, go to next line
.cdfe	20 57 c2	jsr $c257			jsr 	IFT_NewLine					; go to next line.
.ce01	86 10		stx $10				stx 	zTemp1 						; save line read address
.ce03	84 11		sty $11				sty 	zTemp1+1
.ce05	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.ce07	b1 10		lda ($10),y			lda 	(zTemp1),y
.ce09	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.ce0b	d0 01		bne $ce0e			bne 	TIM_NotDot
.ce0d	c8		iny				iny
.ce0e					TIM_NotDot:
.ce0e	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.ce10	c9 52		cmp #$52			cmp 	#"R"						; show registers
.ce12	f0 6b		beq $ce7f			beq 	TIM_ShowRegisters
.ce14	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.ce16	f0 12		beq $ce2a			beq 	TIM_ShowMemory
.ce18	c9 47		cmp #$47			cmp 	#"G"						; execute
.ce1a	f0 49		beq $ce65			beq 	TIM_Execute
.ce1c	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.ce1e	f0 07		beq $ce27			beq 	TIM_GoLoadMemory
.ce20	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.ce22	d0 cb		bne $cdef			bne 	TIM_Error
.ce24	4c a2 cf	jmp $cfa2			jmp 	TIM_UpdateRegisters
.ce27					TIM_GoLoadMemory:
.ce27	4c d2 cf	jmp $cfd2			jmp 	TIM_LoadMemory
.ce2a					TIM_ShowMemory:
.ce2a	20 1e cf	jsr $cf1e			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.ce2d	b0 c0		bcs $cdef			bcs 	TIM_Error
.ce2f	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.ce31	85 12		sta $12				sta 	zTemp2
.ce33	a5 15		lda $15				lda 	zTemp3+1
.ce35	85 13		sta $13				sta 	zTemp2+1
.ce37	20 1e cf	jsr $cf1e			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.ce3a	90 08		bcc $ce44			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.ce3c	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.ce3e	85 14		sta $14				sta 	zTemp3
.ce40	a5 13		lda $13				lda 	zTemp2+1
.ce42	85 15		sta $15				sta 	zTemp3+1
.ce44					_TIMSM_Start:
.ce44	20 f6 ce	jsr $cef6			jsr 	TIM_WriteLine 				; write one line of hex out
.ce47	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.ce49	18		clc				clc
.ce4a	69 10		adc #$10			adc 	#16
.ce4c	85 12		sta $12				sta 	zTemp2
.ce4e	90 02		bcc $ce52			bcc 	_TIMSM_NoCarry
.ce50	e6 13		inc $13				inc 	zTemp2+1
.ce52					_TIMSM_NoCarry:
.ce52	20 dc c3	jsr $c3dc			jsr 	IF_CheckBreak 				; check CTL+C
.ce55	d0 0b		bne $ce62			bne 	_TIMSM_Ends 				; if pressed break out.
.ce57	38		sec				sec 								; check past the end address in zTemp3
.ce58	a5 14		lda $14				lda 	zTemp3
.ce5a	e5 12		sbc $12				sbc 	zTemp2
.ce5c	a5 15		lda $15				lda 	zTemp3+1
.ce5e	e5 13		sbc $13				sbc 	zTemp2+1
.ce60	10 e2		bpl $ce44			bpl 	_TIMSM_Start
.ce62					_TIMSM_Ends:
.ce62	4c f6 cd	jmp $cdf6			jmp 	TIM_NewCommand
.ce65					TIM_Execute:
.ce65	20 1e cf	jsr $cf1e			jsr 	TIM_GetHex 					; get the execute address
.ce68	b0 85		bcs $cdef			bcs 	TIM_Error 					; not legitimate
.ce6a	ae 2c 04	ldx $042c			ldx 	TIM_SP 						; set up SP
.ce6d	9a		txs				txs
.ce6e	ad 27 04	lda $0427			lda 	TIM_SR 						; Status for PLP
.ce71	48		pha				pha
.ce72	ad 28 04	lda $0428			lda 	TIM_A 						; restore AXYZ
.ce75	ae 29 04	ldx $0429			ldx 	TIM_X
.ce78	ac 2a 04	ldy $042a			ldy 	TIM_Y
.ce7b	28		plp				plp 								; and PS Byte.
.ce7c	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.ce7f					TIM_Start:
.ce7f					TIM_ShowRegisters:
.ce7f	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.ce82	8d 26 04	sta $0426			sta 	TIM_IRQ+1
.ce85	ad ff ff	lda $ffff			lda 	$FFFF
.ce88	8d 25 04	sta $0425			sta 	TIM_IRQ
.ce8b	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.ce8d					_TIMSR_Text:
.ce8d	bd bd ce	lda $cebd,x			lda 	_TIMSR_Label,x
.ce90	20 3d c2	jsr $c23d			jsr 	IFT_PrintCharacter
.ce93	e8		inx				inx
.ce94	e0 20		cpx #$20			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.ce96	d0 f5		bne $ce8d			bne 	_TIMSR_Text
.ce98	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.ce9a					_TIMSR_Skip:
.ce9a	e8		inx				inx
.ce9b					_TIMSR_LoopSpace:
.ce9b	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.ce9d	b0 04		bcs $cea3			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.ce9f	8a		txa				txa
.cea0	4a		lsr a				lsr 	a
.cea1	b0 05		bcs $cea8			bcs 	_TIMSR_NoSpace
.cea3					_TIMSR_Space:
.cea3	a9 20		lda #$20			lda 	#" "
.cea5	20 3d c2	jsr $c23d			jsr 	IFT_PrintCharacter
.cea8					_TIMSR_NoSpace:
.cea8	bd 23 04	lda $0423,x			lda 	TIM_PC,x 					; output hex value.
.ceab	20 dd ce	jsr $cedd			jsr 	TIM_WriteHex
.ceae	e8		inx				inx
.ceaf	e0 08		cpx #$08			cpx 	#TIM_Z-TIM_PC
.ceb1	f0 e7		beq $ce9a			beq 	_TIMSR_Skip
.ceb3	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.ceb5	d0 e4		bne $ce9b			bne 	_TimSR_LoopSpace
.ceb7	20 57 c2	jsr $c257			jsr 	IFT_NewLine 				; new line
.ceba	4c f6 cd	jmp $cdf6			jmp	 	TIM_NewCommand 				; new command.
.cebd					_TIMSR_Label:
>cebd	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>cec5	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>ced5	52
>ced6	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.cedd					_TIMSR_LabelEnd:
.cedd					TIM_WriteHex:
.cedd	48		pha				pha 								; save A
.cede	4a		lsr a				lsr 	a 							; shift MSB->LSB
.cedf	4a		lsr a				lsr 	a
.cee0	4a		lsr a				lsr 	a
.cee1	4a		lsr a				lsr 	a
.cee2	20 e6 ce	jsr $cee6			jsr 	_TIMWH_Nibble 				; print MSB
.cee5	68		pla				pla 								; restore and print LSB
.cee6					_TIMWH_Nibble:
.cee6	48		pha				pha
.cee7	29 0f		and #$0f			and 	#15 						; mask out
.cee9	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.ceeb	90 02		bcc $ceef			bcc 	_TIMWHNoLetter
.ceed	69 06		adc #$06			adc 	#6
.ceef					_TIMWHNoLetter:
.ceef	69 30		adc #$30			adc 	#48
.cef1	20 3d c2	jsr $c23d			jsr 	IFT_PrintCharacter 			; print it out.
.cef4	68		pla				pla
.cef5	60		rts				rts
.cef6					TIM_WriteLine:
.cef6	a9 2e		lda #$2e			lda 	#"." 						; prompt
.cef8	20 3d c2	jsr $c23d			jsr 	IFT_PrintCharacter
.cefb	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.cefd	20 3d c2	jsr $c23d			jsr 	IFT_PrintCharacter
.cf00	a5 13		lda $13				lda 	zTemp2+1 					; write address
.cf02	20 dd ce	jsr $cedd			jsr 	TIM_WriteHex
.cf05	a5 12		lda $12				lda 	zTemp2
.cf07	20 dd ce	jsr $cedd			jsr 	TIM_WriteHex
.cf0a	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.cf0c					_TIMWL_Loop:
.cf0c	a9 20		lda #$20			lda 	#" "
.cf0e	20 3d c2	jsr $c23d			jsr 	IFT_PrintCharacter
.cf11	b1 12		lda ($12),y			lda 	(zTemp2),y
.cf13	20 dd ce	jsr $cedd			jsr 	TIM_WriteHex
.cf16	c8		iny				iny
.cf17	c0 10		cpy #$10			cpy 	#16
.cf19	d0 f1		bne $cf0c			bne 	_TIMWL_Loop
.cf1b	4c 57 c2	jmp $c257			jmp 	IFT_NewLine 				; new line and exit
.cf1e					TIM_GetHex:
.cf1e	c8		iny				iny
.cf1f	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.cf21	c9 20		cmp #$20			cmp 	#32
.cf23	f0 f9		beq $cf1e			beq 	TIM_GetHex
.cf25	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.cf27	f0 f5		beq $cf1e			beq 	TIM_GetHex
.cf29	20 52 cf	jsr $cf52			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.cf2c	b0 23		bcs $cf51			bcs 	_TIMGH_Exit					; if first bad then exit now.
.cf2e	a9 00		lda #$00			lda 	#0 							; zero result
.cf30	85 14		sta $14				sta 	zTemp3
.cf32	85 15		sta $15				sta 	zTemp3+1
.cf34					_TIM_GHLoop:
.cf34	20 52 cf	jsr $cf52			jsr 	TIM_GetHexCharacter 		; get next character
.cf37	b0 17		bcs $cf50			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.cf39	c8		iny				iny 								; skip over it.
.cf3a	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.cf3c	26 15		rol $15				rol 	zTemp3+1
.cf3e	06 14		asl $14				asl 	zTemp3 						; now x 2
.cf40	26 15		rol $15				rol 	zTemp3+1
.cf42	06 14		asl $14				asl 	zTemp3						; now x 4
.cf44	26 15		rol $15				rol 	zTemp3+1
.cf46	06 14		asl $14				asl 	zTemp3 						; now x 8
.cf48	26 15		rol $15				rol 	zTemp3+1
.cf4a	05 14		ora $14				ora 	zTemp3 						; OR result in
.cf4c	85 14		sta $14				sta 	zTemp3
.cf4e	80 e4		bra $cf34			bra 	_TIM_GHLoop 				; loop round again.
.cf50					_TIMGH_Okay:
.cf50	18		clc				clc
.cf51					_TIMGH_Exit:
.cf51	60		rts				rts
.cf52					TIM_GetHexCharacter:
.cf52	b1 10		lda ($10),y			lda 	(zTemp1),y
.cf54	38		sec				sec
.cf55	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.cf57	90 0e		bcc $cf67			bcc 	_TIM_GHCFail
.cf59	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.cf5b	90 0b		bcc $cf68			bcc 	_TIM_GHCExit
.cf5d	c9 11		cmp #$11			cmp 	#65-48						; < A
.cf5f	90 06		bcc $cf67			bcc		_TIM_GHCFail
.cf61	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.cf63	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.cf65	90 01		bcc $cf68			bcc		_TIM_GHCExit
.cf67					_TIM_GHCFail:
.cf67	38		sec				sec
.cf68					_TIM_GHCExit:
.cf68	60		rts				rts
.cf69					TIM_BreakVector:
.cf69	da		phx				phx									; save X/A on stack
.cf6a	48		pha				pha
.cf6b	ba		tsx				tsx 								; X points to S
.cf6c	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.cf6f	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.cf71	d0 03		bne $cf76			bne 	_TIMBreak					; if set, it's BRK
.cf73	68		pla				pla 								; abandon routine.
.cf74	fa		plx				plx
.cf75	40		rti				rti
.cf76					_TIMBreak:
.cf76	68		pla				pla 								; save A X Y and maybe Z
.cf77	8d 28 04	sta $0428			sta 	TIM_A
.cf7a	fa		plx				plx
.cf7b	8e 29 04	stx $0429			stx 	TIM_X
.cf7e	8c 2a 04	sty $042a			sty 	TIM_Y
.cf81	68		pla				pla 								; get Status Register
.cf82	8d 27 04	sta $0427			sta 	TIM_SR
.cf85	68		pla				pla
.cf86	8d 24 04	sta $0424			sta 	TIM_PC+1 					; save calling address
.cf89	68		pla				pla
.cf8a	8d 23 04	sta $0423			sta 	TIM_PC 						; high byte
.cf8d	ad 24 04	lda $0424			lda 	TIM_PC+1 					; dec PC to point right.
.cf90	d0 03		bne $cf95			bne 	_TIMDecrement 				; brk bumps it.
.cf92	ce 23 04	dec $0423			dec 	TIM_PC
.cf95					_TIMDecrement:
.cf95	ce 24 04	dec $0424			dec 	TIM_PC+1
.cf98	ba		tsx				tsx 								; and copy SP
.cf99	8e 2c 04	stx $042c			stx 	TIM_SP
.cf9c	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.cf9e	9a		txs				txs
.cf9f	4c 7f ce	jmp $ce7f			jmp 	TIM_Start 					; and start up TIM monitor.
.cfa2					TIM_UpdateRegisters:
.cfa2	20 1e cf	jsr $cf1e			jsr 	TIM_GetHex 					; PC
.cfa5	b0 28		bcs $cfcf			bcs 	_TIMURFail
.cfa7	a5 14		lda $14				lda 	zTemp3
.cfa9	8d 24 04	sta $0424			sta 	Tim_PC+1
.cfac	a5 15		lda $15				lda 	zTemp3+1
.cfae	8d 23 04	sta $0423			sta 	Tim_PC
.cfb1	20 1e cf	jsr $cf1e			jsr 	TIM_GetHex 					; ignore IRQ
.cfb4	b0 19		bcs $cfcf			bcs 	_TIMURFail
.cfb6	a2 00		ldx #$00			ldx 	#0
.cfb8					_TIM_URLoop:
.cfb8	e0 04		cpx #$04			cpx 	#Tim_Z-Tim_SR
.cfba	d0 01		bne $cfbd			bne 	_TIM_1
.cfbc	e8		inx				inx
.cfbd					_TIM_1:
.cfbd	20 1e cf	jsr $cf1e			jsr 	TIM_GetHex 					; registers
.cfc0	b0 0d		bcs $cfcf			bcs 	_TIMURFail
.cfc2	a5 14		lda $14				lda 	zTemp3
.cfc4	9d 27 04	sta $0427,x			sta 	Tim_SR,x
.cfc7	e8		inx				inx
.cfc8	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.cfca	d0 ec		bne $cfb8			bne 	_TIM_URLoop
.cfcc	4c f6 cd	jmp $cdf6			jmp 	TIM_NewCommand
.cfcf					_TIMURFail:
.cfcf	4c ef cd	jmp $cdef			jmp 	TIM_Error
.cfd2					TIM_LoadMemory:
.cfd2	20 1e cf	jsr $cf1e			jsr 	TIM_GetHex 					; target address => zTemp2
.cfd5	a5 14		lda $14				lda 	zTemp3
.cfd7	85 12		sta $12				sta 	zTemp2
.cfd9	a5 15		lda $15				lda 	zTemp3+1
.cfdb	85 13		sta $13				sta 	zTemp2+1
.cfdd					_TIM_LMLoop:
.cfdd	20 1e cf	jsr $cf1e			jsr 	TIM_GetHex 					; next byte ?
.cfe0	b0 0e		bcs $cff0			bcs 	_TIMLMDone 					; no more
.cfe2	a2 00		ldx #$00			ldx 	#0							; write out.
.cfe4	a5 14		lda $14				lda 	zTemp3
.cfe6	81 12		sta ($12,x)			sta 	(zTemp2,x)
.cfe8	e6 12		inc $12				inc 	zTemp2 						; bump address
.cfea	d0 f1		bne $cfdd			bne 	_TIM_LMLoop
.cfec	e6 13		inc $13				inc 	zTemp2+1
.cfee	80 ed		bra $cfdd			bra 	_TIM_LMLoop
.cff0					_TIMLMDone:
.cff0	4c f6 cd	jmp $cdf6			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Return to file: basic.asm

>cff3	02						.byte 	2
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	ec c1						.word 	StartROM
>fffe	69 cf					.word TIM_BreakVector

;******  End of listing
