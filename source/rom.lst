
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -c -b -L rom.lst -o rom.bin basic.asm
; Sun Aug 18 19:45:51 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="65816"				CPU = "65816"
="em65816"				HARDWARE = "em65816"

;******  Processing file: modules/common/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zLTemp1:	.dword ?						; long word (used in multiply)
>001a					zGenPtr:	.word ? 						; general pointer.
>0200					IFT_XCursor:.byte ?							; current logical position on screen
>0201					IFT_YCursor:.byte ?
>0202					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0266					IFT_LineBuffer: .fill 100 					; line input buffer.
>0300					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>0304					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>0305					XS_Type 	.byte ? 						; bit 7 sign (float only)
=774					XS2_Mantissa = XS_Mantissa+6
=778					XS2_Exponent = XS_Exponent+6
=779					XS2_Type = XS_Type+6
>0400					Num_Buffer	.fill 	32 						; buffer for numeric conversions
>0420					NumBufX 	.byte 	?						; buffer index position
>0421					NumSuppress	.byte 	?						; leading zero suppression flag
>0422					NumConvCount .byte 	? 						; count for conversions.
>0423					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>0425					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>0427					Tim_SR:		.byte ? 						; Processor Status
>0428					Tim_A:		.byte ? 						; Processor Registers
>0429					Tim_X:		.byte ?
>042a					Tim_Y:		.byte ?
>042b					Tim_Z:		.byte ?
>042c					Tim_SP:		.byte ?							; Stack Pointer
>042d					ExpTemp:	.byte ?							; Working temp for exponents.
>042e					ExpCount:	.byte ? 						; Count of decimal exponents.

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/em65816.asm

.c000					StartROM:
.c000	18		clc				clc
.c001	fb		xce				xce
.c002	c2 30		rep #$30			rep 	#$30
.c004	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.c007	1b		tcs				tcs
.c008	e2 30		sep #$30			sep 	#$30
.c00a	c2 30		rep #$30			rep 	#$30
.c00c	a9 00 00	lda #$0000			lda 	#$0000
.c00f	aa		tax				tax
.c010	a8		tay				tay
.c011	e2 30		sep #$30			sep 	#$30
.c013	20 b7 c1	jsr $c1b7			jsr 	IF_Reset 					; reset external interface
.c016	20 1c c0	jsr $c01c			jsr 	IFT_ClearScreen
.c019	4c 8f c2	jmp $c28f		jmp TIM_Start

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.c01c					IFT_ClearScreen:
.c01c	48		pha				pha
.c01d	da		phx				phx
.c01e	5a		phy				phy
.c01f	20 b8 c1	jsr $c1b8			jsr 	IF_Home 					; home cursor
.c022	a2 20		ldx #$20			ldx 	#IF_Height 					; this many lines.
.c024					_IFT_CS0:
.c024	a0 40		ldy #$40			ldy 	#IF_Width 					; this many chars/line
.c026					_IFT_CS1:
.c026	a9 20		lda #$20			lda 	#' '						; clear line.
.c028	20 e4 c1	jsr $c1e4			jsr 	IF_Write
.c02b	88		dey				dey
.c02c	d0 f8		bne $c026			bne 	_IFT_CS1
.c02e	20 cb c1	jsr $c1cb			jsr 	IF_NewLine 					; next line down
.c031	ca		dex				dex
.c032	d0 f0		bne $c024			bne 	_IFT_CS0
.c034	7a		ply				ply
.c035	fa		plx				plx
.c036	68		pla				pla
.c037					IFT_HomeCursor:
.c037	48		pha				pha
.c038	20 b8 c1	jsr $c1b8			jsr 	IF_Home
.c03b	a9 00		lda #$00			lda 	#0
.c03d	8d 00 02	sta $0200			sta 	IFT_XCursor
.c040	8d 01 02	sta $0201			sta 	IFT_YCursor
.c043	68		pla				pla
.c044	60		rts				rts
.c045					IFT_UpLine:
.c045	48		pha				pha
.c046	ad 01 02	lda $0201			lda  	IFT_YCursor 				; get Y
.c049	3a		dec a				dec 	a 							; line above
.c04a	30 03		bmi $c04f			bmi 	_IFTULExit 					; too far, abort
.c04c	20 da c0	jsr $c0da			jsr 	IFT_SetYPos					; set to that line.
.c04f					_IFTULExit:
.c04f	68		pla				pla
.c050	60		rts				rts
.c051					IFT_PrintCharacter:
.c051	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.c053	f0 16		beq $c06b			beq 	IFT_NewLine
.c055	48		pha				pha
.c056	20 83 c0	jsr $c083			jsr 	IFT_UpperCase 				; make upper case
.c059	20 e4 c1	jsr $c1e4			jsr 	IF_Write 					; write out.
.c05c	ee 00 02	inc $0200			inc 	IFT_XCursor 				; bump x cursor
.c05f	ad 00 02	lda $0200			lda 	IFT_XCursor 				; reached RHS ?
.c062	c9 40		cmp #$40			cmp 	#IF_Width
.c064	d0 03		bne $c069			bne 	_IFT_PCNotEOL
.c066	20 6b c0	jsr $c06b			jsr 	IFT_NewLine 				; if so do new line.
.c069					_IFT_PCNotEOL:
.c069	68		pla				pla
.c06a	60		rts				rts
.c06b					IFT_NewLine:
.c06b	48		pha				pha
.c06c	20 cb c1	jsr $c1cb			jsr 	IF_NewLine 					; new line on actual screen.
.c06f	a9 00		lda #$00			lda 	#0 							; reset x position
.c071	8d 00 02	sta $0200			sta 	IFT_XCursor
.c074	ee 01 02	inc $0201			inc 	IFT_YCursor 				; move down.
.c077	ad 01 02	lda $0201			lda 	IFT_YCursor
.c07a	c9 20		cmp #$20			cmp 	#IF_Height 					; reached bottom.
.c07c	d0 03		bne $c081			bne 	_IFT_NL_NotEOS
.c07e	20 8e c0	jsr $c08e			jsr 	IFT_Scroll 					; scroll screen up.
.c081					_IFT_NL_NotEOS:
.c081	68		pla				pla
.c082	60		rts				rts
.c083					IFT_UpperCase:
.c083	c9 61		cmp #$61			cmp 	#"a"
.c085	90 06		bcc $c08d			bcc 	_IFT_UCExit
.c087	c9 7b		cmp #$7b			cmp 	#"z"+1
.c089	b0 02		bcs $c08d			bcs 	_IFT_UCExit
.c08b	49 20		eor #$20			eor 	#$20
.c08d					_IFT_UCExit:
.c08d	60		rts				rts
.c08e					IFT_Scroll:
.c08e	48		pha				pha 								; save AXY
.c08f	da		phx				phx
.c090	5a		phy				phy
.c091	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.c093					_IFT_SLoop:
.c093	20 b3 c0	jsr $c0b3			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.c096	e8		inx				inx
.c097	e0 1f		cpx #$1f			cpx 	#IF_Height-1				; do whole screen
.c099	d0 f8		bne $c093			bne 	_IFT_SLoop
.c09b	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.c09d	20 da c0	jsr $c0da			jsr 	IFT_SetYPos
.c0a0	a2 40		ldx #$40			ldx 	#IF_Width 					; blank line
.c0a2					_IFT_SBlank:
.c0a2	a9 20		lda #$20			lda 	#32
.c0a4	20 e4 c1	jsr $c1e4			jsr 	IF_Write
.c0a7	ca		dex				dex
.c0a8	d0 f8		bne $c0a2			bne 	_IFT_SBlank
.c0aa	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.c0ac	20 da c0	jsr $c0da			jsr 	IFT_SetYPos
.c0af	7a		ply				ply
.c0b0	fa		plx				plx
.c0b1	68		pla				pla
.c0b2	60		rts				rts
.c0b3					_IFT_ScrollLine:
.c0b3	da		phx				phx
.c0b4	da		phx				phx
.c0b5	8a		txa				txa 								; copy line into buffer.
.c0b6	1a		inc a				inc 	a 							; next line down.
.c0b7	20 da c0	jsr $c0da			jsr 	IFT_SetYPos
.c0ba	a2 00		ldx #$00			ldx 	#0
.c0bc					_IFTScrollCopy1:
.c0bc	20 db c1	jsr $c1db			jsr 	IF_Read
.c0bf	9d 02 02	sta $0202,x			sta 	IFT_Buffer,x
.c0c2	e8		inx				inx
.c0c3	e0 40		cpx #$40			cpx 	#IF_Width
.c0c5	d0 f5		bne $c0bc			bne 	_IFTScrollCopy1
.c0c7	68		pla				pla
.c0c8	20 da c0	jsr $c0da			jsr 	IFT_SetYPos
.c0cb	a2 00		ldx #$00			ldx 	#0
.c0cd					_IFTScrollCopy2:
.c0cd	bd 02 02	lda $0202,x			lda 	IFT_Buffer,x
.c0d0	20 e4 c1	jsr $c1e4			jsr 	IF_Write
.c0d3	e8		inx				inx
.c0d4	e0 40		cpx #$40			cpx 	#IF_Width
.c0d6	d0 f5		bne $c0cd			bne 	_IFTScrollCopy2
.c0d8	fa		plx				plx
.c0d9	60		rts				rts
.c0da					IFT_SetYPos:
.c0da	48		pha				pha
.c0db	da		phx				phx
.c0dc	aa		tax				tax
.c0dd	20 37 c0	jsr $c037			jsr 	IFT_HomeCursor
.c0e0	e0 00		cpx #$00			cpx 	#0
.c0e2	f0 09		beq $c0ed			beq 	_IFT_MOAExit
.c0e4					_IFT_MOALoop:
.c0e4	20 cb c1	jsr $c1cb			jsr 	IF_NewLine
.c0e7	ee 01 02	inc $0201			inc 	IFT_YCursor
.c0ea	ca		dex				dex
.c0eb	d0 f7		bne $c0e4			bne		_IFT_MOALoop
.c0ed					_IFT_MOAExit:
.c0ed	fa		plx				plx
.c0ee	68		pla				pla
.c0ef	60		rts				rts
.c0f0					IFT_GetKeyCursor:
.c0f0	20 f8 c0	jsr $c0f8			jsr 	_IFT_FlipCursor 			; reverse current
.c0f3					_IFT_GKCWait:
.c0f3	20 f5 c1	jsr $c1f5			jsr 	IF_GetKey 					; get key
.c0f6	f0 fb		beq $c0f3			beq 	_IFT_GKCWait
.c0f8					_IFT_FlipCursor:
.c0f8	48		pha				pha 								; save
.c0f9	20 db c1	jsr $c1db			jsr 	IF_Read 					; read
.c0fc	20 ed c1	jsr $c1ed			jsr 	IF_LeftOne
.c0ff	49 80		eor #$80			eor 	#$80 						; reverse
.c101	20 e4 c1	jsr $c1e4			jsr 	IF_Write 					; write
.c104	20 ed c1	jsr $c1ed			jsr 	IF_LeftOne
.c107	68		pla				pla
.c108	60		rts				rts
.c109					IFT_ReadLine:
.c109	48		pha				pha
.c10a					_IFT_RLLoop:
.c10a	20 f0 c0	jsr $c0f0			jsr 	IFT_GetKeyCursor 			; get keystroke
.c10d	c9 0d		cmp #$0d			cmp 	#13							; return
.c10f	f0 7d		beq $c18e			beq 	_IFT_RLExit
.c111	c9 20		cmp #$20			cmp 	#32 						; control character
.c113	90 05		bcc $c11a			bcc 	_IFT_Control
.c115	20 51 c0	jsr $c051			jsr 	IFT_PrintCharacter
.c118	80 f0		bra $c10a			bra 	_IFT_RLLoop
.c11a					_IFT_Control:
.c11a	c9 01		cmp #$01			cmp 	#"A"-64
.c11c	f0 26		beq $c144			beq 	_IFT_Left
.c11e	c9 04		cmp #$04			cmp 	#"D"-64
.c120	f0 2e		beq $c150			beq 	_IFT_Right
.c122	c9 17		cmp #$17			cmp 	#"W"-64
.c124	f0 36		beq $c15c			beq 	_IFT_Up
.c126	c9 13		cmp #$13			cmp 	#"S"-64
.c128	f0 3e		beq $c168			beq 	_IFT_Down
.c12a	c9 08		cmp #$08			cmp 	#"H"-64
.c12c	f0 09		beq $c137			beq 	_IFT_Backspace
.c12e	c9 1a		cmp #$1a			cmp 	#"Z"-64
.c130	d0 d8		bne $c10a			bne 	_IFT_RLLoop
.c132	20 1c c0	jsr $c01c			jsr 	IFT_ClearScreen				; clear CTL-Z
.c135	80 d3		bra $c10a			bra 	_IFT_RLLoop
.c137					_IFT_Backspace:
.c137	ad 00 02	lda $0200			lda 	IFT_XCursor 				; check not start of line.
.c13a	f0 ce		beq $c10a			beq 	_IFT_RLLoop
.c13c	20 ed c1	jsr $c1ed			jsr 	IF_LeftOne
.c13f	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.c141	20 e4 c1	jsr $c1e4			jsr 	IF_Write
.c144					_IFT_Left:
.c144	ce 00 02	dec $0200			dec 	IFT_XCursor 				; left CTL-W
.c147	10 29		bpl $c172			bpl 	_IFT_Reposition
.c149	a9 3f		lda #$3f			lda 	#IF_Width-1
.c14b					_IFT_SetX:
.c14b	8d 00 02	sta $0200			sta 	IFT_XCursor
.c14e	80 22		bra $c172			bra 	_IFT_Reposition
.c150					_IFT_Right:
.c150	ee 00 02	inc $0200			inc 	IFT_XCursor
.c153	ad 00 02	lda $0200			lda 	IFT_XCursor
.c156	49 40		eor #$40			eor 	#IF_Width
.c158	f0 f1		beq $c14b			beq 	_IFT_SetX
.c15a	80 16		bra $c172			bra 	_IFT_Reposition
.c15c					_IFT_Up:
.c15c	ce 01 02	dec $0201			dec 	IFT_YCursor
.c15f	10 11		bpl $c172			bpl 	_IFT_Reposition
.c161	a9 1f		lda #$1f			lda 	#IF_Height-1
.c163					_IFT_SetY:
.c163	8d 01 02	sta $0201			sta 	IFT_YCursor
.c166	80 0a		bra $c172			bra 	_IFT_Reposition
.c168					_IFT_Down:
.c168	ee 01 02	inc $0201			inc 	IFT_YCursor
.c16b	ad 01 02	lda $0201			lda 	IFT_YCursor
.c16e	49 20		eor #$20			eor 	#IF_Height
.c170	f0 f1		beq $c163			beq 	_IFT_SetY
.c172					_IFT_Reposition:
.c172	ad 00 02	lda $0200			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.c175	48		pha				pha
.c176	ad 01 02	lda $0201			lda 	IFT_YCursor
.c179	20 da c0	jsr $c0da			jsr 	IFT_SetYPos
.c17c	68		pla				pla
.c17d	aa		tax				tax
.c17e	e0 00		cpx #$00			cpx 	#0
.c180	f0 88		beq $c10a			beq 	_IFT_RLLoop
.c182					_IFT_MoveRight:
.c182	20 db c1	jsr $c1db			jsr 	IF_Read
.c185	ee 00 02	inc $0200			inc 	IFT_XCursor
.c188	ca		dex				dex
.c189	d0 f7		bne $c182			bne 	_IFT_MoveRight
.c18b	4c 0a c1	jmp $c10a			jmp 	_IFT_RLLoop
.c18e					_IFT_RLExit:
.c18e	ad 01 02	lda $0201			lda 	IFT_YCursor 				; go to start of line.
.c191	20 da c0	jsr $c0da			jsr 	IFT_SetYPos
.c194	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.c196					_IFT_RLRead:
.c196	20 db c1	jsr $c1db			jsr 	IF_Read
.c199	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.c19c	e8		inx				inx
.c19d	e0 40		cpx #$40			cpx 	#IF_Width
.c19f	d0 f5		bne $c196			bne 	_IFT_RLRead
.c1a1					_IFT_RL_Trim:
.c1a1	ca		dex				dex 	 							; previous char
.c1a2	30 07		bmi $c1ab			bmi 	_IFT_Found 					; gone too far
.c1a4	bd 66 02	lda $0266,x			lda 	IFT_LineBuffer,x			; go back if space
.c1a7	c9 20		cmp #$20			cmp 	#" "
.c1a9	f0 f6		beq $c1a1			beq 	_IFT_RL_Trim
.c1ab					_IFT_Found:
.c1ab	e8		inx				inx 								; forward to non-space
.c1ac	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.c1ae	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.c1b1	68		pla				pla
.c1b2	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.c1b4	a0 02		ldy #$02			ldy 	#IFT_LineBuffer >> 8
.c1b6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_em65816.asm

=64					IF_Width 	= 64 							; characters across
=32					IF_Height 	= 32 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line.
=8					IF_XPos 	= 8 							; current position, horizontal.
=$f0000					IF_Screen = $F0000							; 2k screen RAM here
=$f8010					IF_PKeyboard = $F8010						; Keyboard port.
=$f8000					IF_PBreak = $F8000 							; Break key.
.c1b7					IF_Reset:
.c1b7	60		rts				rts
.c1b8					IF_Home:
.c1b8	48		pha				pha
.c1b9	64 08		stz $08				stz 	IF_XPos 					; zero X position
.c1bb	a9 00		lda #$00			lda 	#IF_Screen & $FF 			; set r/w pos.
.c1bd	85 04		sta $04				sta 	IF_Pos
.c1bf	a9 00		lda #$00			lda 	#(IF_Screen >> 8) & $FF
.c1c1	85 05		sta $05				sta 	IF_Pos+1
.c1c3	a9 0f		lda #$0f			lda 	#IF_Screen >> 16
.c1c5	85 06		sta $06				sta 	IF_Pos+2
.c1c7	64 07		stz $07				stz 	IF_Pos+3
.c1c9	68		pla				pla
.c1ca	60		rts				rts
.c1cb					IF_NewLine:
.c1cb	48		pha				pha
.c1cc	64 08		stz $08				stz 	IF_XPos						; back to start of line
.c1ce	18		clc				clc 								; down one line
.c1cf	a5 04		lda $04				lda 	IF_Pos
.c1d1	69 40		adc #$40			adc 	#64
.c1d3	85 04		sta $04				sta 	IF_Pos
.c1d5	90 02		bcc $c1d9			bcc 	_IF_NoCarry 				; carry through.
.c1d7	e6 05		inc $05				inc 	IF_Pos+1
.c1d9					_IF_NoCarry:
.c1d9	68		pla				pla
.c1da	60		rts				rts
.c1db					IF_Read:
.c1db	5a		phy				phy 								; save current Y
.c1dc	a4 08		ldy $08				ldy 	IF_XPos 					; read character at current position
.c1de	b7 04		lda [$04],y			lda 	[IF_Pos],y
.c1e0	e6 08		inc $08				inc 	IF_XPos 					; step right.
.c1e2	7a		ply				ply									; restore Y
.c1e3	60		rts				rts
.c1e4					IF_Write:
.c1e4	5a		phy				phy 								; save current Y
.c1e5	a4 08		ldy $08				ldy 	IF_XPos 					; write character at current position
.c1e7	97 04		sta [$04],y			sta 	[IF_Pos],y
.c1e9	e6 08		inc $08				inc 	IF_XPos 					; step right.
.c1eb	7a		ply				ply									; restore Y
.c1ec	60		rts				rts
.c1ed					IF_LeftOne:
.c1ed	c6 08		dec $08				dec 	IF_XPos
.c1ef	60		rts				rts
.c1f0					IF_CheckBreak:
.c1f0	af 00 80 0f	lda $0f8000			lda 	IF_PBreak					; non-zero if Ctrl+C pressed.
.c1f4	60		rts				rts
.c1f5					IF_GetKey:
.c1f5	af 10 80 0f	lda $0f8010			lda 	IF_PKeyboard				; read keyboard
.c1f9	f0 08		beq $c203			beq		_IFGK_NoKey 				; skip if zero,no key pressed
.c1fb	48		pha				pha 								; key pressed, clear queue.
.c1fc	a9 00		lda #$00			lda 	#0
.c1fe	8f 10 80 0f	sta $0f8010			sta 	IF_PKeyboard
.c202	68		pla				pla
.c203					_IFGK_NoKey:
.c203	09 00		ora #$00			ora 	#0							; set Z flag appropriately.
.c205	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.c206					TIM_Error:
.c206	20 45 c0	jsr $c045			jsr 	IFT_UpLine 					; go up one line.
.c209	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.c20b	80 02		bra $c20f			bra 	TIM_ShowPrompt
.c20d					TIM_NewCommand:
.c20d	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.c20f					TIM_ShowPrompt:
.c20f	20 51 c0	jsr $c051			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.c212	20 09 c1	jsr $c109			jsr 	IFT_ReadLine	 			; get character, go to next line
.c215	20 6b c0	jsr $c06b			jsr 	IFT_NewLine					; go to next line.
.c218	86 10		stx $10				stx 	zTemp1 						; save line read address
.c21a	84 11		sty $11				sty 	zTemp1+1
.c21c	a0 01		ldy #$01			ldy 	#1 							; get first character after the prompt.
.c21e	b1 10		lda ($10),y			lda 	(zTemp1),y
.c220	c9 52		cmp #$52			cmp 	#"R"						; show registers
.c222	f0 6b		beq $c28f			beq 	TIM_ShowRegisters
.c224	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.c226	f0 12		beq $c23a			beq 	TIM_ShowMemory
.c228	c9 47		cmp #$47			cmp 	#"G"						; execute
.c22a	f0 49		beq $c275			beq 	TIM_Execute
.c22c	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.c22e	f0 07		beq $c237			beq 	TIM_GoLoadMemory
.c230	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.c232	d0 d2		bne $c206			bne 	TIM_Error
.c234	4c b2 c3	jmp $c3b2			jmp 	TIM_UpdateRegisters
.c237					TIM_GoLoadMemory:
.c237	4c dd c3	jmp $c3dd			jmp 	TIM_LoadMemory
.c23a					TIM_ShowMemory:
.c23a	20 2e c3	jsr $c32e			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.c23d	b0 c7		bcs $c206			bcs 	TIM_Error
.c23f	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.c241	85 12		sta $12				sta 	zTemp2
.c243	a5 15		lda $15				lda 	zTemp3+1
.c245	85 13		sta $13				sta 	zTemp2+1
.c247	20 2e c3	jsr $c32e			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.c24a	90 08		bcc $c254			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.c24c	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.c24e	85 14		sta $14				sta 	zTemp3
.c250	a5 13		lda $13				lda 	zTemp2+1
.c252	85 15		sta $15				sta 	zTemp3+1
.c254					_TIMSM_Start:
.c254	20 06 c3	jsr $c306			jsr 	TIM_WriteLine 				; write one line of hex out
.c257	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.c259	18		clc				clc
.c25a	69 10		adc #$10			adc 	#16
.c25c	85 12		sta $12				sta 	zTemp2
.c25e	90 02		bcc $c262			bcc 	_TIMSM_NoCarry
.c260	e6 13		inc $13				inc 	zTemp2+1
.c262					_TIMSM_NoCarry:
.c262	20 f0 c1	jsr $c1f0			jsr 	IF_CheckBreak 				; check CTL+C
.c265	d0 0b		bne $c272			bne 	_TIMSM_Ends 				; if pressed break out.
.c267	38		sec				sec 								; check past the end address in zTemp3
.c268	a5 14		lda $14				lda 	zTemp3
.c26a	e5 12		sbc $12				sbc 	zTemp2
.c26c	a5 15		lda $15				lda 	zTemp3+1
.c26e	e5 13		sbc $13				sbc 	zTemp2+1
.c270	10 e2		bpl $c254			bpl 	_TIMSM_Start
.c272					_TIMSM_Ends:
.c272	4c 0d c2	jmp $c20d			jmp 	TIM_NewCommand
.c275					TIM_Execute:
.c275	20 2e c3	jsr $c32e			jsr 	TIM_GetHex 					; get the execute address
.c278	b0 8c		bcs $c206			bcs 	TIM_Error 					; not legitimate
.c27a	ae 2c 04	ldx $042c			ldx 	TIM_SP 						; set up SP
.c27d	9a		txs				txs
.c27e	ad 27 04	lda $0427			lda 	TIM_SR 						; Status for PLP
.c281	48		pha				pha
.c282	ad 28 04	lda $0428			lda 	TIM_A 						; restore AXYZ
.c285	ae 29 04	ldx $0429			ldx 	TIM_X
.c288	ac 2a 04	ldy $042a			ldy 	TIM_Y
.c28b	28		plp				plp 								; and PS Byte.
.c28c	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.c28f					TIM_Start:
.c28f					TIM_ShowRegisters:
.c28f	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.c292	8d 26 04	sta $0426			sta 	TIM_IRQ+1
.c295	ad ff ff	lda $ffff			lda 	$FFFF
.c298	8d 25 04	sta $0425			sta 	TIM_IRQ
.c29b	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.c29d					_TIMSR_Text:
.c29d	bd cd c2	lda $c2cd,x			lda 	_TIMSR_Label,x
.c2a0	20 51 c0	jsr $c051			jsr 	IFT_PrintCharacter
.c2a3	e8		inx				inx
.c2a4	e0 20		cpx #$20			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.c2a6	d0 f5		bne $c29d			bne 	_TIMSR_Text
.c2a8	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.c2aa					_TIMSR_Skip:
.c2aa	e8		inx				inx
.c2ab					_TIMSR_LoopSpace:
.c2ab	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.c2ad	b0 04		bcs $c2b3			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.c2af	8a		txa				txa
.c2b0	4a		lsr a				lsr 	a
.c2b1	b0 05		bcs $c2b8			bcs 	_TIMSR_NoSpace
.c2b3					_TIMSR_Space:
.c2b3	a9 20		lda #$20			lda 	#" "
.c2b5	20 51 c0	jsr $c051			jsr 	IFT_PrintCharacter
.c2b8					_TIMSR_NoSpace:
.c2b8	bd 23 04	lda $0423,x			lda 	TIM_PC,x 					; output hex value.
.c2bb	20 ed c2	jsr $c2ed			jsr 	TIM_WriteHex
.c2be	e8		inx				inx
.c2bf	e0 08		cpx #$08			cpx 	#TIM_Z-TIM_PC
.c2c1	f0 e7		beq $c2aa			beq 	_TIMSR_Skip
.c2c3	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.c2c5	d0 e4		bne $c2ab			bne 	_TimSR_LoopSpace
.c2c7	20 6b c0	jsr $c06b			jsr 	IFT_NewLine 				; new line
.c2ca	4c 0d c2	jmp $c20d			jmp	 	TIM_NewCommand 				; new command.
.c2cd					_TIMSR_Label:
>c2cd	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>c2d5	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>c2e5	52
>c2e6	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.c2ed					_TIMSR_LabelEnd:
.c2ed					TIM_WriteHex:
.c2ed	48		pha				pha 								; save A
.c2ee	4a		lsr a				lsr 	a 							; shift MSB->LSB
.c2ef	4a		lsr a				lsr 	a
.c2f0	4a		lsr a				lsr 	a
.c2f1	4a		lsr a				lsr 	a
.c2f2	20 f6 c2	jsr $c2f6			jsr 	_TIMWH_Nibble 				; print MSB
.c2f5	68		pla				pla 								; restore and print LSB
.c2f6					_TIMWH_Nibble:
.c2f6	48		pha				pha
.c2f7	29 0f		and #$0f			and 	#15 						; mask out
.c2f9	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.c2fb	90 02		bcc $c2ff			bcc 	_TIMWHNoLetter
.c2fd	69 06		adc #$06			adc 	#6
.c2ff					_TIMWHNoLetter:
.c2ff	69 30		adc #$30			adc 	#48
.c301	20 51 c0	jsr $c051			jsr 	IFT_PrintCharacter 			; print it out.
.c304	68		pla				pla
.c305	60		rts				rts
.c306					TIM_WriteLine:
.c306	a9 2e		lda #$2e			lda 	#"." 						; prompt
.c308	20 51 c0	jsr $c051			jsr 	IFT_PrintCharacter
.c30b	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.c30d	20 51 c0	jsr $c051			jsr 	IFT_PrintCharacter
.c310	a5 13		lda $13				lda 	zTemp2+1 					; write address
.c312	20 ed c2	jsr $c2ed			jsr 	TIM_WriteHex
.c315	a5 12		lda $12				lda 	zTemp2
.c317	20 ed c2	jsr $c2ed			jsr 	TIM_WriteHex
.c31a	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.c31c					_TIMWL_Loop:
.c31c	a9 20		lda #$20			lda 	#" "
.c31e	20 51 c0	jsr $c051			jsr 	IFT_PrintCharacter
.c321	b1 12		lda ($12),y			lda 	(zTemp2),y
.c323	20 ed c2	jsr $c2ed			jsr 	TIM_WriteHex
.c326	c8		iny				iny
.c327	c0 10		cpy #$10			cpy 	#16
.c329	d0 f1		bne $c31c			bne 	_TIMWL_Loop
.c32b	4c 6b c0	jmp $c06b			jmp 	IFT_NewLine 				; new line and exit
.c32e					TIM_GetHex:
.c32e	c8		iny				iny
.c32f	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.c331	c9 20		cmp #$20			cmp 	#32
.c333	f0 f9		beq $c32e			beq 	TIM_GetHex
.c335	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.c337	f0 f5		beq $c32e			beq 	TIM_GetHex
.c339	20 62 c3	jsr $c362			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.c33c	b0 23		bcs $c361			bcs 	_TIMGH_Exit					; if first bad then exit now.
.c33e	a9 00		lda #$00			lda 	#0 							; zero result
.c340	85 14		sta $14				sta 	zTemp3
.c342	85 15		sta $15				sta 	zTemp3+1
.c344					_TIM_GHLoop:
.c344	20 62 c3	jsr $c362			jsr 	TIM_GetHexCharacter 		; get next character
.c347	b0 17		bcs $c360			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.c349	c8		iny				iny 								; skip over it.
.c34a	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.c34c	26 15		rol $15				rol 	zTemp3+1
.c34e	06 14		asl $14				asl 	zTemp3 						; now x 2
.c350	26 15		rol $15				rol 	zTemp3+1
.c352	06 14		asl $14				asl 	zTemp3						; now x 4
.c354	26 15		rol $15				rol 	zTemp3+1
.c356	06 14		asl $14				asl 	zTemp3 						; now x 8
.c358	26 15		rol $15				rol 	zTemp3+1
.c35a	05 14		ora $14				ora 	zTemp3 						; OR result in
.c35c	85 14		sta $14				sta 	zTemp3
.c35e	80 e4		bra $c344			bra 	_TIM_GHLoop 				; loop round again.
.c360					_TIMGH_Okay:
.c360	18		clc				clc
.c361					_TIMGH_Exit:
.c361	60		rts				rts
.c362					TIM_GetHexCharacter:
.c362	b1 10		lda ($10),y			lda 	(zTemp1),y
.c364	38		sec				sec
.c365	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.c367	90 0e		bcc $c377			bcc 	_TIM_GHCFail
.c369	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.c36b	90 0b		bcc $c378			bcc 	_TIM_GHCExit
.c36d	c9 11		cmp #$11			cmp 	#65-48						; < A
.c36f	90 06		bcc $c377			bcc		_TIM_GHCFail
.c371	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.c373	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.c375	90 01		bcc $c378			bcc		_TIM_GHCExit
.c377					_TIM_GHCFail:
.c377	38		sec				sec
.c378					_TIM_GHCExit:
.c378	60		rts				rts
.c379					TIM_BreakVector:
.c379	da		phx				phx									; save X/A on stack
.c37a	48		pha				pha
.c37b	ba		tsx				tsx 								; X points to S
.c37c	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.c37f	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.c381	d0 03		bne $c386			bne 	_TIMBreak					; if set, it's BRK
.c383	68		pla				pla 								; abandon routine.
.c384	fa		plx				plx
.c385	40		rti				rti
.c386					_TIMBreak:
.c386	68		pla				pla 								; save A X Y and maybe Z
.c387	8d 28 04	sta $0428			sta 	TIM_A
.c38a	fa		plx				plx
.c38b	8e 29 04	stx $0429			stx 	TIM_X
.c38e	8c 2a 04	sty $042a			sty 	TIM_Y
.c391	68		pla				pla 								; get Status Register
.c392	8d 27 04	sta $0427			sta 	TIM_SR
.c395	68		pla				pla
.c396	8d 24 04	sta $0424			sta 	TIM_PC+1 					; save calling address
.c399	68		pla				pla
.c39a	8d 23 04	sta $0423			sta 	TIM_PC 						; high byte
.c39d	ad 24 04	lda $0424			lda 	TIM_PC+1 					; dec PC to point right.
.c3a0	d0 03		bne $c3a5			bne 	_TIMDecrement 				; brk bumps it.
.c3a2	ce 23 04	dec $0423			dec 	TIM_PC
.c3a5					_TIMDecrement:
.c3a5	ce 24 04	dec $0424			dec 	TIM_PC+1
.c3a8	ba		tsx				tsx 								; and copy SP
.c3a9	8e 2c 04	stx $042c			stx 	TIM_SP
.c3ac	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.c3ae	9a		txs				txs
.c3af	4c 8f c2	jmp $c28f			jmp 	TIM_Start 					; and start up TIM monitor.
.c3b2					TIM_UpdateRegisters:
.c3b2	20 2e c3	jsr $c32e			jsr 	TIM_GetHex 					; PC
.c3b5	b0 23		bcs $c3da			bcs 	_TIMURFail
.c3b7	a5 14		lda $14				lda 	zTemp3
.c3b9	8d 24 04	sta $0424			sta 	Tim_PC+1
.c3bc	a5 15		lda $15				lda 	zTemp3+1
.c3be	8d 23 04	sta $0423			sta 	Tim_PC
.c3c1	20 2e c3	jsr $c32e			jsr 	TIM_GetHex 					; ignore IRQ
.c3c4	b0 14		bcs $c3da			bcs 	_TIMURFail
.c3c6	a2 00		ldx #$00			ldx 	#0
.c3c8					_TIM_URLoop:
.c3c8	20 2e c3	jsr $c32e			jsr 	TIM_GetHex 					; registers
.c3cb	b0 0d		bcs $c3da			bcs 	_TIMURFail
.c3cd	a5 14		lda $14				lda 	zTemp3
.c3cf	9d 27 04	sta $0427,x			sta 	Tim_SR,x
.c3d2	e8		inx				inx
.c3d3	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.c3d5	d0 f1		bne $c3c8			bne 	_TIM_URLoop
.c3d7	4c 0d c2	jmp $c20d			jmp 	TIM_NewCommand
.c3da					_TIMURFail:
.c3da	4c 06 c2	jmp $c206			jmp 	TIM_Error
.c3dd					TIM_LoadMemory:
.c3dd	20 2e c3	jsr $c32e			jsr 	TIM_GetHex 					; target address => zTemp2
.c3e0	a5 14		lda $14				lda 	zTemp3
.c3e2	85 12		sta $12				sta 	zTemp2
.c3e4	a5 15		lda $15				lda 	zTemp3+1
.c3e6	85 13		sta $13				sta 	zTemp2+1
.c3e8					_TIM_LMLoop:
.c3e8	20 2e c3	jsr $c32e			jsr 	TIM_GetHex 					; next byte ?
.c3eb	b0 0e		bcs $c3fb			bcs 	_TIMLMDone 					; no more
.c3ed	a2 00		ldx #$00			ldx 	#0							; write out.
.c3ef	a5 14		lda $14				lda 	zTemp3
.c3f1	81 12		sta ($12,x)			sta 	(zTemp2,x)
.c3f3	e6 12		inc $12				inc 	zTemp2 						; bump address
.c3f5	d0 f1		bne $c3e8			bne 	_TIM_LMLoop
.c3f7	e6 13		inc $13				inc 	zTemp2+1
.c3f9	80 ed		bra $c3e8			bra 	_TIM_LMLoop
.c3fb					_TIMLMDone:
.c3fb	4c 0d c2	jmp $c20d			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Return to file: basic.asm

.c3fe					StartBASIC:
.c3fe	20 b7 c1	jsr $c1b7			jsr 	IF_Reset 					; reset external interface
.c401	20 1c c0	jsr $c01c			jsr 	IFT_ClearScreen
.c404	20 8f c2	jsr $c28f			jsr 	TIM_Start
>c407	02						.byte 	2
.c408					ERR_Handler:
.c408	80 fe		bra $c408			bra 	ERR_Handler
.c40a					NMIHandler:
.c40a	40		rti				rti
>fffa	0a c4						.word	NMIHandler
>fffc	00 c0						.word 	StartROM
>fffe	79 c3						.word 	TIM_BreakVector

;******  End of listing
