
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Sun Sep  1 19:02:20 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="4510"					cpu = "4510"
="mega65"				hardware = "mega65"
=1					exitonend = 1
=1					autorun = 1
=3					loadtest = 3
=1					hasfloat = 1
=1					hasinteger = 1
=253					maxstring = 253

;******  Processing file: modules/basic/pointer/mega65/src_mega65.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stackmarkers.inc

=5					SourcePosSize   =   5 							; Source position stack space needed.
=1					SMark_Gosub 	= 	1 							; 0 is GOSUB/RETURN.
=2					SMark_Repeat 	= 	2 							; 1 is REPEAT/UNTIL.
=3					SMark_While 	= 	3 							; 2 is WHILE/WEND.
=4					SMark_If 		= 	4 							; 3 is IF/ENDIF
=5					SMark_For 		= 	5 							; 4 is FOR/NEXT

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/hardware/common/macros32.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0020					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0022					zVarDataPtr: .word ? 						; position of variable data.
>0024					zVarType: 	.byte ? 						; type of data (token)
>0025					zNullString:.byte ? 						; represents a NULL string.
>0026					zBasicSP:	.word ? 						; stack pointer
>0080					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>0084					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>0085					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=134					XS2_Mantissa = XS_Mantissa+XS_Size
=138					XS2_Exponent = XS_Exponent+XS_Size
=139					XS2_Type = XS_Type+XS_Size
=140					XS3_Mantissa = XS_Mantissa+XS_Size*2
=144					XS3_Exponent = XS_Exponent+XS_Size*2
=145					XS3_Type = XS_Type+XS_Size*2
>0300					StringPtr:	.word ? 						; Top of free memory (for string allocation)
>0302					VarMemPtr: 	.word ?							; Bottom of free memory (for variables)
>0304					endOfProgram: .dword ? 						; End of Program Memory (long)
>0308					vecPrintCharacter .word ?
>030a					vecInputCharacter .word ?
>030c					UserVector .fill 4 							; USR(x) calls this.
>0310					LocalVector .fill 4 						; Indirect calls call this.
>0314					NumBufX 	.byte 	?						; buffer index position
>0315					Num_Buffer	.fill 	32 						; buffer for numeric conversions
=6					HashTableCount = 6 							; there are 6 hash tables, in token order.
=8					HashTableSize = 8 							; each hash table as 8 links.
.0335					HashTableBase:
>0335								.fill	HashTableCount * HashTableSize * 2
.0395					HashTableEnd:
=$315					Var_Buffer 	= Num_Buffer 					; buffer for variable name (same space)
>0395					Var_Type    .byte ? 						; type of variable (as a type token)
>0396					Var_Hash 	.byte ? 						; hash of identifier name.
>0397					Var_Length 	.byte ? 						; length of variable name
>0398					Var_HashAddress .byte ?						; low byte of hash table entry.
>0399					Var_DataSize .byte ?						; size of one element.
>039a					NumSuppress	.byte 	?						; leading zero suppression flag
>039b					NumConvCount .byte 	? 						; count for conversions.
>039c					ExpTemp:	.byte ?							; Working temp for exponents.
>039d					ExpCount:	.byte ? 						; Count of decimal exponents.
>039e					SignCount:	.byte ?							; Integer Divide Sign Counts.
>039f					TempStringWriteIndex: .byte ? 				; Write offset.
>03a0					ValSign: 	.byte ? 						; sign flag for val()
>03a1					SliceStart:	.byte ? 						; string slice parts
>03a2					SliceCount:	.byte ?
>03a3					RandomSeed:	.dword ? 						; Random seed.
>03a7					SignNext:	.byte ? 						; Used for keeping sign of STEP in FOR/NEXT
>03a8					BreakCount:	.byte ? 						; Counter, avoid checking break every command.
=3					ArrayMaxDim = 3 							; number of dimensions.
>03a9					ArrayDef:	.fill (ArrayMaxDim+1)*2 		; dimensions for auto-creation
>03b1					UsrArrayDef:.fill (ArrayMaxDim+1)*2 		; dimensions created in DIM
>03b9					UsrArrayIdx:.byte ? 						; index into UsrArrayDef
>03ba					LastPrinted:.byte ? 						; last printed char ?
>03bb					ListIndent: .byte ? 						; list indent level
>03bc					LastListIndent:.byte ? 						; previous one.
>03bd					DataLPtr: 	.dword ?						; the data long ptr (swapped with zCodePtr)
>03c1					DataIndex:	.byte ?							; index position.
>03c2					InputAvailable: .byte ? 					; characters available in input buffer.
>03c3					InputRetry:	.byte ? 						; true if INPUT is retrying.
>03c4					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>03c6					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>03c8					Tim_SR:		.byte ? 						; Processor Status
>03c9					Tim_A:		.byte ? 						; Processor Registers
>03ca					Tim_X:		.byte ?
>03cb					Tim_Y:		.byte ?
>03cc					Tim_Z:		.byte ?
>03cd					Tim_SP:		.word ?							; Stack Pointer (just in cases)
>0400					BasicStack:	.fill 	256 					; and occupy whole pages.
.0500					EndBasicStack:
>0500					IFT_XCursor:.byte ?							; current logical position on screen
>0501					IFT_YCursor:.byte ?
>0502					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0566					IFT_LineBuffer: .fill 100 					; line input buffer.

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/mega65.asm

=$7f00					HighMemory = $7F00
=$2000					VariableMemory = $2000
.8000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testassign.src

>8000	0d 0a 00 c7 16 32 15 bc			.byte	$0d,$0a,$00,$c7,$16,$32,$15,$bc
>8008	42 bf 41 be 00 0b 14 00			.byte	$42,$bf,$41,$be,$00,$0b,$14,$00
>8010	c7 11 39 16 bd 41 be 00			.byte	$c7,$11,$39,$16,$bd,$41,$be,$00
>8018	0d 1e 00 c7 03 35 07 b8			.byte	$0d,$1e,$00,$c7,$03,$35,$07,$b8
>8020	41 bf 41 be 00 0c 28 00			.byte	$41,$bf,$41,$be,$00,$0c,$28,$00
>8028	c7 13 34 0c 09 bd 41 be			.byte	$c7,$13,$34,$0c,$09,$bd,$41,$be
>8030	00 0c 32 00 c7 15 31 04			.byte	$00,$0c,$32,$00,$c7,$15,$31,$04
>8038	05 bc 42 be 00 0d 3c 00			.byte	$05,$bc,$42,$be,$00,$0d,$3c,$00
>8040	c7 01 33 0a bc 42 bf 42			.byte	$c7,$01,$33,$0a,$bc,$42,$bf,$42
>8048	be 00 0c 46 00 c7 0f 33			.byte	$be,$00,$0c,$46,$00,$c7,$0f,$33
>8050	17 13 bc 41 be 00 0c 50			.byte	$17,$13,$bc,$41,$be,$00,$0c,$50
>8058	00 c7 05 31 09 0f ba 41			.byte	$00,$c7,$05,$31,$09,$0f,$ba,$41
>8060	be 00 0c 5a 00 c7 15 33			.byte	$be,$00,$0c,$5a,$00,$c7,$15,$33
>8068	05 04 ba 42 be 00 0e 64			.byte	$05,$04,$ba,$42,$be,$00,$0e,$64
>8070	00 c7 01 34 11 14 bc 42			.byte	$00,$c7,$01,$34,$11,$14,$bc,$42
>8078	bf 41 be 00 0b 6e 00 c7			.byte	$bf,$41,$be,$00,$0b,$6e,$00,$c7
>8080	08 34 0f bd 42 be 00 0f			.byte	$08,$34,$0f,$bd,$42,$be,$00,$0f
>8088	78 00 c7 16 37 01 19 0d			.byte	$78,$00,$c7,$16,$37,$01,$19,$0d
>8090	b8 42 bf 42 be 00 10 82			.byte	$b8,$42,$bf,$42,$be,$00,$10,$82
>8098	00 cf 15 b9 84 41 7e fd			.byte	$00,$cf,$15,$b9,$84,$41,$7e,$fd
>80a0	06 30 36 32 35 00 0e 8c			.byte	$06,$30,$36,$32,$35,$00,$0e,$8c
>80a8	00 cf 17 38 13 07 b7 84			.byte	$00,$cf,$17,$38,$13,$07,$b7,$84
>80b0	fe 03 4e 00 11 96 00 cf			.byte	$fe,$03,$4e,$00,$11,$96,$00,$cf
>80b8	0a 36 06 b7 84 fe 07 52			.byte	$0a,$36,$06,$b7,$84,$fe,$07,$52
>80c0	33 4f 44 43 00 14 a0 00			.byte	$33,$4f,$44,$43,$00,$14,$a0,$00
>80c8	cf 0e 37 1a 18 0a 84 8b			.byte	$cf,$0e,$37,$1a,$18,$0a,$84,$8b
>80d0	47 5e fd 06 34 33 37 35			.byte	$47,$5e,$fd,$06,$34,$33,$37,$35
>80d8	00 0e aa 00 cf 13 b7 84			.byte	$00,$0e,$aa,$00,$cf,$13,$b7,$84
>80e0	fe 06 57 35 41 49 00 0f			.byte	$fe,$06,$57,$35,$41,$49,$00,$0f
>80e8	b4 00 cf 01 32 05 06 0f			.byte	$b4,$00,$cf,$01,$32,$05,$06,$0f
>80f0	bb 84 8b 48 4c 00 11 be			.byte	$bb,$84,$8b,$48,$4c,$00,$11,$be
>80f8	00 cf 0a 39 12 b9 84 47			.byte	$00,$cf,$0a,$39,$12,$b9,$84,$47
>8100	7b fd 05 36 32 35 00 12			.byte	$7b,$fd,$05,$36,$32,$35,$00,$12
>8108	c8 00 cf 19 37 09 0e 19			.byte	$c8,$00,$cf,$19,$37,$09,$0e,$19
>8110	b9 84 8b 62 fd 04 32 35			.byte	$b9,$84,$8b,$62,$fd,$04,$32,$35
>8118	00 11 d2 00 cf 01 31 16			.byte	$00,$11,$d2,$00,$cf,$01,$31,$16
>8120	02 b9 84 47 7a fd 04 37			.byte	$02,$b9,$84,$47,$7a,$fd,$04,$37
>8128	35 00 13 dc 00 cf 1a 34			.byte	$35,$00,$13,$dc,$00,$cf,$1a,$34
>8130	13 14 b9 84 44 70 fd 06			.byte	$13,$14,$b9,$84,$44,$70,$fd,$06
>8138	30 36 32 35 00 0c e6 00			.byte	$30,$36,$32,$35,$00,$0c,$e6,$00
>8140	cf 0e 37 0e bb 84 4b 75			.byte	$cf,$0e,$37,$0e,$bb,$84,$4b,$75
>8148	00 11 f0 00 cf 16 32 15			.byte	$00,$11,$f0,$00,$cf,$16,$32,$15
>8150	bc 41 bf 41 be 84 8b 4c			.byte	$bc,$41,$bf,$41,$be,$84,$8b,$4c
>8158	61 00 0f fa 00 cf 17 84			.byte	$61,$00,$0f,$fa,$00,$cf,$17,$84
>8160	43 7c fd 06 38 31 32 35			.byte	$43,$7c,$fd,$06,$38,$31,$32,$35
>8168	00 17 04 01 cf 16 37 01			.byte	$00,$17,$04,$01,$cf,$16,$37,$01
>8170	19 0d b8 42 bf 40 be 84			.byte	$19,$0d,$b8,$42,$bf,$40,$be,$84
>8178	fe 07 41 35 45 4f 49 00			.byte	$fe,$07,$41,$35,$45,$4f,$49,$00
>8180	11 0e 01 cf 0a 39 01 01			.byte	$11,$0e,$01,$cf,$0a,$39,$01,$01
>8188	b9 84 49 5a fd 04 37 35			.byte	$b9,$84,$49,$5a,$fd,$04,$37,$35
>8190	00 14 18 01 cf 11 33 0e			.byte	$00,$14,$18,$01,$cf,$11,$33,$0e
>8198	09 b9 84 8b 45 4c fd 06			.byte	$09,$b9,$84,$8b,$45,$4c,$fd,$06
>81a0	38 31 32 35 00 17 22 01			.byte	$38,$31,$32,$35,$00,$17,$22,$01
>81a8	cf 16 37 01 19 0d b8 41			.byte	$cf,$16,$37,$01,$19,$0d,$b8,$41
>81b0	bf 42 be 84 fe 07 4e 34			.byte	$bf,$42,$be,$84,$fe,$07,$4e,$34
>81b8	45 46 54 00 0d 2c 01 cf			.byte	$45,$46,$54,$00,$0d,$2c,$01,$cf
>81c0	02 33 12 12 b7 84 fe 02			.byte	$02,$33,$12,$12,$b7,$84,$fe,$02
>81c8	00 10 36 01 cf 06 35 0c			.byte	$00,$10,$36,$01,$cf,$06,$35,$0c
>81d0	b7 84 fe 06 50 37 51 4b			.byte	$b7,$84,$fe,$06,$50,$37,$51,$4b
>81d8	00 0e 40 01 cf 05 35 0e			.byte	$00,$0e,$40,$01,$cf,$05,$35,$0e
>81e0	1a bb 84 8b 49 7b 00 0f			.byte	$1a,$bb,$84,$8b,$49,$7b,$00,$0f
>81e8	4a 01 cf 01 32 05 06 0f			.byte	$4a,$01,$cf,$01,$32,$05,$06,$0f
>81f0	bb 84 8b 47 79 00 14 54			.byte	$bb,$84,$8b,$47,$79,$00,$14,$54
>81f8	01 cf 08 30 16 0b 13 b9			.byte	$01,$cf,$08,$30,$16,$0b,$13,$b9
>8200	84 43 56 fd 06 34 33 37			.byte	$84,$43,$56,$fd,$06,$34,$33,$37
>8208	35 00 11 5e 01 cf 1a 38			.byte	$35,$00,$11,$5e,$01,$cf,$1a,$38
>8210	19 09 84 42 5c fd 05 31			.byte	$19,$09,$84,$42,$5c,$fd,$05,$31
>8218	32 35 00 0d 68 01 cf 18			.byte	$32,$35,$00,$0d,$68,$01,$cf,$18
>8220	32 0f 08 0f bb 84 40 00			.byte	$32,$0f,$08,$0f,$bb,$84,$40,$00
>8228	12 72 01 cf 03 35 07 b8			.byte	$12,$72,$01,$cf,$03,$35,$07,$b8
>8230	40 bf 41 be 84 fe 04 41			.byte	$40,$bf,$41,$be,$84,$fe,$04,$41
>8238	37 00 10 7c 01 cf 15 b9			.byte	$37,$00,$10,$7c,$01,$cf,$15,$b9
>8240	84 45 62 fd 06 36 38 37			.byte	$84,$45,$62,$fd,$06,$36,$38,$37
>8248	35 00 0e 86 01 cf 19 37			.byte	$35,$00,$0e,$86,$01,$cf,$19,$37
>8250	0a 07 19 bb 84 4c 6a 00			.byte	$0a,$07,$19,$bb,$84,$4c,$6a,$00
>8258	11 90 01 cf 0d 34 01 18			.byte	$11,$90,$01,$cf,$0d,$34,$01,$18
>8260	b7 84 fe 06 42 37 4a 45			.byte	$b7,$84,$fe,$06,$42,$37,$4a,$45
>8268	00 0c 9a 01 cf 03 30 0b			.byte	$00,$0c,$9a,$01,$cf,$03,$30,$0b
>8270	bb 84 42 4d 00 15 a4 01			.byte	$bb,$84,$42,$4d,$00,$15,$a4,$01
>8278	cf 15 33 05 04 ba 41 be			.byte	$cf,$15,$33,$05,$04,$ba,$41,$be
>8280	84 43 58 fd 06 33 31 32			.byte	$84,$43,$58,$fd,$06,$33,$31,$32
>8288	35 00 0a ae 01 cf 0d bb			.byte	$35,$00,$0a,$ae,$01,$cf,$0d,$bb
>8290	84 4e 42 00 0d b8 01 cf			.byte	$84,$4e,$42,$00,$0d,$b8,$01,$cf
>8298	08 38 04 11 0d bb 84 4f			.byte	$08,$38,$04,$11,$0d,$bb,$84,$4f
>82a0	00 0e c2 01 cf 05 36 0a			.byte	$00,$0e,$c2,$01,$cf,$05,$36,$0a
>82a8	05 10 b7 84 fe 02 00 13			.byte	$05,$10,$b7,$84,$fe,$02,$00,$13
>82b0	cc 01 cf 02 36 07 b9 84			.byte	$cc,$01,$cf,$02,$36,$07,$b9,$84
>82b8	8b 49 4d fd 06 30 36 32			.byte	$8b,$49,$4d,$fd,$06,$30,$36,$32
>82c0	35 00 0f d6 01 cf 19 31			.byte	$35,$00,$0f,$d6,$01,$cf,$19,$31
>82c8	06 84 47 79 fd 04 37 35			.byte	$06,$84,$47,$79,$fd,$04,$37,$35
>82d0	00 0f e0 01 cf 19 31 06			.byte	$00,$0f,$e0,$01,$cf,$19,$31,$06
>82d8	84 42 71 fd 04 32 35 00			.byte	$84,$42,$71,$fd,$04,$32,$35,$00
>82e0	11 ea 01 cf 0a 36 06 b7			.byte	$11,$ea,$01,$cf,$0a,$36,$06,$b7
>82e8	84 fe 07 41 35 45 52 4b			.byte	$84,$fe,$07,$41,$35,$45,$52,$4b
>82f0	00 0d f4 01 cf 06 36 0d			.byte	$00,$0d,$f4,$01,$cf,$06,$36,$0d
>82f8	bb 84 8b 48 4e 00 13 fe			.byte	$bb,$84,$8b,$48,$4e,$00,$13,$fe
>8300	01 cf 1a 30 0b 09 16 84			.byte	$01,$cf,$1a,$30,$0b,$09,$16,$84
>8308	47 64 fd 06 31 38 37 35			.byte	$47,$64,$fd,$06,$31,$38,$37,$35
>8310	00 0f 08 02 cf 02 35 06			.byte	$00,$0f,$08,$02,$cf,$02,$35,$06
>8318	b9 84 45 44 fd 03 35 00			.byte	$b9,$84,$45,$44,$fd,$03,$35,$00
>8320	10 12 02 cf 12 33 03 b9			.byte	$10,$12,$02,$cf,$12,$33,$03,$b9
>8328	84 8b 47 53 fd 03 35 00			.byte	$84,$8b,$47,$53,$fd,$03,$35,$00
>8330	0b 1c 02 cf 12 b7 84 fe			.byte	$0b,$1c,$02,$cf,$12,$b7,$84,$fe
>8338	03 4a 00 0f 26 02 cf 01			.byte	$03,$4a,$00,$0f,$26,$02,$cf,$01
>8340	32 05 06 0f bb 84 8b 49			.byte	$32,$05,$06,$0f,$bb,$84,$8b,$49
>8348	5e 00 12 30 02 cf 05 36			.byte	$5e,$00,$12,$30,$02,$cf,$05,$36
>8350	0a 05 10 b7 84 fe 06 55			.byte	$0a,$05,$10,$b7,$84,$fe,$06,$55
>8358	32 57 54 00 0d 3a 02 cf			.byte	$32,$57,$54,$00,$0d,$3a,$02,$cf
>8360	15 b9 84 43 75 fd 03 30			.byte	$15,$b9,$84,$43,$75,$fd,$03,$30
>8368	00 12 44 02 cf 02 33 12			.byte	$00,$12,$44,$02,$cf,$02,$33,$12
>8370	12 b7 84 fe 07 5a 34 42			.byte	$12,$b7,$84,$fe,$07,$5a,$34,$42
>8378	55 51 00 10 4e 02 cf 19			.byte	$55,$51,$00,$10,$4e,$02,$cf,$19
>8380	31 06 84 8b 47 47 fd 04			.byte	$31,$06,$84,$8b,$47,$47,$fd,$04
>8388	32 35 00 14 58 02 cf 15			.byte	$32,$35,$00,$14,$58,$02,$cf,$15
>8390	33 15 11 18 84 8b 48 6d			.byte	$33,$15,$11,$18,$84,$8b,$48,$6d
>8398	fd 06 34 33 37 35 00 0d			.byte	$fd,$06,$34,$33,$37,$35,$00,$0d
>83a0	62 02 cf 01 37 16 bb 84			.byte	$62,$02,$cf,$01,$37,$16,$bb,$84
>83a8	8b 4a 42 00 0c 6c 02 cf			.byte	$8b,$4a,$42,$00,$0c,$6c,$02,$cf
>83b0	01 34 05 b7 84 fe 02 00			.byte	$01,$34,$05,$b7,$84,$fe,$02,$00
>83b8	0e 76 02 cf 0d 34 01 18			.byte	$0e,$76,$02,$cf,$0d,$34,$01,$18
>83c0	b7 84 fe 03 58 00 0d 80			.byte	$b7,$84,$fe,$03,$58,$00,$0d,$80
>83c8	02 cf 05 35 0e 1a bb 84			.byte	$02,$cf,$05,$35,$0e,$1a,$bb,$84
>83d0	48 68 00 0f 8a 02 cf 18			.byte	$48,$68,$00,$0f,$8a,$02,$cf,$18
>83d8	32 0f 08 0f bb 84 8b 4c			.byte	$32,$0f,$08,$0f,$bb,$84,$8b,$4c
>83e0	68 00 14 94 02 cf 08 30			.byte	$68,$00,$14,$94,$02,$cf,$08,$30
>83e8	16 0b 13 b9 84 42 4b fd			.byte	$16,$0b,$13,$b9,$84,$42,$4b,$fd
>83f0	06 36 38 37 35 00 0a 9e			.byte	$06,$36,$38,$37,$35,$00,$0a,$9e
>83f8	02 cf 01 bb 84 47 40 00			.byte	$02,$cf,$01,$bb,$84,$47,$40,$00
>8400	14 a8 02 cf 13 34 0c 09			.byte	$14,$a8,$02,$cf,$13,$34,$0c,$09
>8408	bd 40 be 84 8b 43 7a fd			.byte	$bd,$40,$be,$84,$8b,$43,$7a,$fd
>8410	04 32 35 00 13 b2 02 cf			.byte	$04,$32,$35,$00,$13,$b2,$02,$cf
>8418	09 39 14 b9 84 8b 45 6f			.byte	$09,$39,$14,$b9,$84,$8b,$45,$6f
>8420	fd 06 33 31 32 35 00 0e			.byte	$fd,$06,$33,$31,$32,$35,$00,$0e
>8428	bc 02 cf 08 38 04 11 0d			.byte	$bc,$02,$cf,$08,$38,$04,$11,$0d
>8430	bb 84 42 4e 00 13 c6 02			.byte	$bb,$84,$42,$4e,$00,$13,$c6,$02
>8438	cf 0e 37 1a 18 0a 84 42			.byte	$cf,$0e,$37,$1a,$18,$0a,$84,$42
>8440	5c fd 06 30 36 32 35 00			.byte	$5c,$fd,$06,$30,$36,$32,$35,$00
>8448	0e d0 02 cf 15 30 0e 0e			.byte	$0e,$d0,$02,$cf,$15,$30,$0e,$0e
>8450	bb 84 8b 42 5f 00 0f da			.byte	$bb,$84,$8b,$42,$5f,$00,$0f,$da
>8458	02 cf 19 84 8b 43 5e fd			.byte	$02,$cf,$19,$84,$8b,$43,$5e,$fd
>8460	05 38 37 35 00 0e e4 02			.byte	$05,$38,$37,$35,$00,$0e,$e4,$02
>8468	cf 05 32 13 0c 1a bb 84			.byte	$cf,$05,$32,$13,$0c,$1a,$bb,$84
>8470	4d 60 00 11 ee 02 cf 04			.byte	$4d,$60,$00,$11,$ee,$02,$cf,$04
>8478	38 16 b7 84 fe 07 46 38			.byte	$38,$16,$b7,$84,$fe,$07,$46,$38
>8480	49 43 4c 00 12 f8 02 cf			.byte	$49,$43,$4c,$00,$12,$f8,$02,$cf
>8488	13 35 17 84 8b 49 69 fd			.byte	$13,$35,$17,$84,$8b,$49,$69,$fd
>8490	06 30 36 32 35 00 12 02			.byte	$06,$30,$36,$32,$35,$00,$12,$02
>8498	03 cf 1a 31 0f 15 05 b9			.byte	$03,$cf,$1a,$31,$0f,$15,$05,$b9
>84a0	84 48 78 fd 04 32 35 00			.byte	$84,$48,$78,$fd,$04,$32,$35,$00
>84a8	0d 0c 03 cf 05 35 0e 1a			.byte	$0d,$0c,$03,$cf,$05,$35,$0e,$1a
>84b0	bb 84 4a 41 00 0d 16 03			.byte	$bb,$84,$4a,$41,$00,$0d,$16,$03
>84b8	cf 05 35 0e 1a bb 84 49			.byte	$cf,$05,$35,$0e,$1a,$bb,$84,$49
>84c0	76 00 11 20 03 cf 02 36			.byte	$76,$00,$11,$20,$03,$cf,$02,$36
>84c8	07 b9 84 41 56 fd 05 36			.byte	$07,$b9,$84,$41,$56,$fd,$05,$36
>84d0	32 35 00 10 2a 03 cf 08			.byte	$32,$35,$00,$10,$2a,$03,$cf,$08
>84d8	33 1a b7 84 fe 06 46 33			.byte	$33,$1a,$b7,$84,$fe,$06,$46,$33
>84e0	54 55 00 0f 34 03 cf 0b			.byte	$54,$55,$00,$0f,$34,$03,$cf,$0b
>84e8	b7 84 fe 07 47 32 4a 58			.byte	$b7,$84,$fe,$07,$47,$32,$4a,$58
>84f0	46 00 0d 3e 03 cf 01 34			.byte	$46,$00,$0d,$3e,$03,$cf,$01,$34
>84f8	05 b7 84 fe 03 47 00 12			.byte	$05,$b7,$84,$fe,$03,$47,$00,$12
>8500	48 03 cf 02 33 06 10 84			.byte	$48,$03,$cf,$02,$33,$06,$10,$84
>8508	45 46 fd 06 35 36 32 35			.byte	$45,$46,$fd,$06,$35,$36,$32,$35
>8510	00 0d 52 03 cf 01 37 16			.byte	$00,$0d,$52,$03,$cf,$01,$37,$16
>8518	bb 84 8b 48 5d 00 11 5c			.byte	$bb,$84,$8b,$48,$5d,$00,$11,$5c
>8520	03 cf 17 38 13 07 b7 84			.byte	$03,$cf,$17,$38,$13,$07,$b7,$84
>8528	fe 06 57 32 4e 49 00 13			.byte	$fe,$06,$57,$32,$4e,$49,$00,$13
>8530	66 03 cf 05 30 16 18 05			.byte	$66,$03,$cf,$05,$30,$16,$18,$05
>8538	84 8b 48 6c fd 05 36 32			.byte	$84,$8b,$48,$6c,$fd,$05,$36,$32
>8540	35 00 11 70 03 cf 15 b9			.byte	$35,$00,$11,$70,$03,$cf,$15,$b9
>8548	84 8b 44 61 fd 06 31 38			.byte	$84,$8b,$44,$61,$fd,$06,$31,$38
>8550	37 35 00 0d 7a 03 cf 0b			.byte	$37,$35,$00,$0d,$7a,$03,$cf,$0b
>8558	34 09 1a b7 84 fe 02 00			.byte	$34,$09,$1a,$b7,$84,$fe,$02,$00
>8560	13 84 03 cf 0a 39 12 b9			.byte	$13,$84,$03,$cf,$0a,$39,$12,$b9
>8568	84 8b 48 48 fd 06 30 36			.byte	$84,$8b,$48,$48,$fd,$06,$30,$36
>8570	32 35 00 0a 8e 03 cf 0d			.byte	$32,$35,$00,$0a,$8e,$03,$cf,$0d
>8578	bb 84 4c 60 00 11 98 03			.byte	$bb,$84,$4c,$60,$00,$11,$98,$03
>8580	cf 01 33 0a bc 41 bf 41			.byte	$cf,$01,$33,$0a,$bc,$41,$bf,$41
>8588	be 84 8b 4d 44 00 14 a2			.byte	$be,$84,$8b,$4d,$44,$00,$14,$a2
>8590	03 cf 11 39 03 06 11 84			.byte	$03,$cf,$11,$39,$03,$06,$11,$84
>8598	8b 48 49 fd 06 33 31 32			.byte	$8b,$48,$49,$fd,$06,$33,$31,$32
>85a0	35 00 16 ac 03 cf 16 37			.byte	$35,$00,$16,$ac,$03,$cf,$16,$37
>85a8	01 19 0d b8 41 bf 40 be			.byte	$01,$19,$0d,$b8,$41,$bf,$40,$be
>85b0	84 fe 06 51 31 4e 4c 00			.byte	$84,$fe,$06,$51,$31,$4e,$4c,$00
>85b8	16 b6 03 cf 16 37 01 19			.byte	$16,$b6,$03,$cf,$16,$37,$01,$19
>85c0	0d b8 40 bf 40 be 84 fe			.byte	$0d,$b8,$40,$bf,$40,$be,$84,$fe
>85c8	06 4b 34 59 44 00 0e c0			.byte	$06,$4b,$34,$59,$44,$00,$0e,$c0
>85d0	03 cf 13 b7 84 fe 06 45			.byte	$03,$cf,$13,$b7,$84,$fe,$06,$45
>85d8	34 48 4a 00 10 ca 03 cf			.byte	$34,$48,$4a,$00,$10,$ca,$03,$cf
>85e0	15 31 04 05 bc 42 be 84			.byte	$15,$31,$04,$05,$bc,$42,$be,$84
>85e8	8b 4e 56 00 10 d4 03 cf			.byte	$8b,$4e,$56,$00,$10,$d4,$03,$cf
>85f0	14 36 0f 0e b7 84 fe 05			.byte	$14,$36,$0f,$0e,$b7,$84,$fe,$05
>85f8	43 31 5a 00 0d de 03 cf			.byte	$43,$31,$5a,$00,$0d,$de,$03,$cf
>8600	0e 37 0e bb 84 8b 4f 5c			.byte	$0e,$37,$0e,$bb,$84,$8b,$4f,$5c
>8608	00 13 e8 03 cf 13 34 0c			.byte	$00,$13,$e8,$03,$cf,$13,$34,$0c
>8610	09 bd 40 be 84 47 51 fd			.byte	$09,$bd,$40,$be,$84,$47,$51,$fd
>8618	04 37 35 00 10 f2 03 cf			.byte	$04,$37,$35,$00,$10,$f2,$03,$cf
>8620	02 36 07 b9 84 42 5c fd			.byte	$02,$36,$07,$b9,$84,$42,$5c,$fd
>8628	04 37 35 00 0d fc 03 cf			.byte	$04,$37,$35,$00,$0d,$fc,$03,$cf
>8630	03 30 0b bb 84 8b 49 4f			.byte	$03,$30,$0b,$bb,$84,$8b,$49,$4f
>8638	00 10 06 04 cf 05 36 0a			.byte	$00,$10,$06,$04,$cf,$05,$36,$0a
>8640	05 10 b7 84 fe 04 5a 35			.byte	$05,$10,$b7,$84,$fe,$04,$5a,$35
>8648	00 0b 10 04 cf 06 b7 84			.byte	$00,$0b,$10,$04,$cf,$06,$b7,$84
>8650	fe 03 4a 00 0f 1a 04 cf			.byte	$fe,$03,$4a,$00,$0f,$1a,$04,$cf
>8658	15 31 04 05 bc 41 be 84			.byte	$15,$31,$04,$05,$bc,$41,$be,$84
>8660	49 58 00 12 24 04 cf 08			.byte	$49,$58,$00,$12,$24,$04,$cf,$08
>8668	34 0f bd 42 be 84 47 75			.byte	$34,$0f,$bd,$42,$be,$84,$47,$75
>8670	fd 04 32 35 00 0f 2e 04			.byte	$fd,$04,$32,$35,$00,$0f,$2e,$04
>8678	cf 0a b9 84 44 6c fd 05			.byte	$cf,$0a,$b9,$84,$44,$6c,$fd,$05
>8680	33 37 35 00 14 38 04 cf			.byte	$33,$37,$35,$00,$14,$38,$04,$cf
>8688	0d 37 19 02 05 84 8b 48			.byte	$0d,$37,$19,$02,$05,$84,$8b,$48
>8690	61 fd 06 34 33 37 35 00			.byte	$61,$fd,$06,$34,$33,$37,$35,$00
>8698	0c 42 04 cf 0e 84 42 77			.byte	$0c,$42,$04,$cf,$0e,$84,$42,$77
>86a0	fd 03 30 00 0e 4c 04 cf			.byte	$fd,$03,$30,$00,$0e,$4c,$04,$cf
>86a8	14 36 0f 0e b7 84 fe 03			.byte	$14,$36,$0f,$0e,$b7,$84,$fe,$03
>86b0	45 00 12 56 04 cf 19 31			.byte	$45,$00,$12,$56,$04,$cf,$19,$31
>86b8	06 84 8b 41 75 fd 06 30			.byte	$06,$84,$8b,$41,$75,$fd,$06,$30
>86c0	36 32 35 00 10 60 04 cf			.byte	$36,$32,$35,$00,$10,$60,$04,$cf
>86c8	05 39 0c 0d b7 84 fe 05			.byte	$05,$39,$0c,$0d,$b7,$84,$fe,$05
>86d0	4f 38 46 00 14 6a 04 cf			.byte	$4f,$38,$46,$00,$14,$6a,$04,$cf
>86d8	01 39 08 14 05 84 8b 49			.byte	$01,$39,$08,$14,$05,$84,$8b,$49
>86e0	42 fd 06 36 38 37 35 00			.byte	$42,$fd,$06,$36,$38,$37,$35,$00
>86e8	11 74 04 cf 16 32 15 bc			.byte	$11,$74,$04,$cf,$16,$32,$15,$bc
>86f0	41 bf 41 be 84 8b 48 47			.byte	$41,$bf,$41,$be,$84,$8b,$48,$47
>86f8	00 11 7e 04 cf 16 32 15			.byte	$00,$11,$7e,$04,$cf,$16,$32,$15
>8700	bc 40 bf 41 be 84 8b 41			.byte	$bc,$40,$bf,$41,$be,$84,$8b,$41
>8708	75 00 0f 88 04 cf 11 84			.byte	$75,$00,$0f,$88,$04,$cf,$11,$84
>8710	8b 7c fd 06 34 33 37 35			.byte	$8b,$7c,$fd,$06,$34,$33,$37,$35
>8718	00 13 92 04 cf 01 39 08			.byte	$00,$13,$92,$04,$cf,$01,$39,$08
>8720	14 05 84 8b 41 78 fd 05			.byte	$14,$05,$84,$8b,$41,$78,$fd,$05
>8728	33 37 35 00 0c 9c 04 cf			.byte	$33,$37,$35,$00,$0c,$9c,$04,$cf
>8730	11 35 07 b7 84 fe 02 00			.byte	$11,$35,$07,$b7,$84,$fe,$02,$00
>8738	0c a6 04 cf 06 36 0d bb			.byte	$0c,$a6,$04,$cf,$06,$36,$0d,$bb
>8740	84 8b 50 00 14 b0 04 cf			.byte	$84,$8b,$50,$00,$14,$b0,$04,$cf
>8748	02 34 0e 19 b9 84 8b 45			.byte	$02,$34,$0e,$19,$b9,$84,$8b,$45
>8750	79 fd 06 35 36 32 35 00			.byte	$79,$fd,$06,$35,$36,$32,$35,$00
>8758	13 ba 04 cf 0e 30 09 10			.byte	$13,$ba,$04,$cf,$0e,$30,$09,$10
>8760	84 8b 43 5a fd 06 39 33			.byte	$84,$8b,$43,$5a,$fd,$06,$39,$33
>8768	37 35 00 10 c4 04 cf 05			.byte	$37,$35,$00,$10,$c4,$04,$cf,$05
>8770	36 12 0e 84 49 4b fd 04			.byte	$36,$12,$0e,$84,$49,$4b,$fd,$04
>8778	32 35 00 0e ce 04 cf 01			.byte	$32,$35,$00,$0e,$ce,$04,$cf,$01
>8780	32 05 06 0f bb 84 4c 43			.byte	$32,$05,$06,$0f,$bb,$84,$4c,$43
>8788	00 13 d8 04 cf 13 31 15			.byte	$00,$13,$d8,$04,$cf,$13,$31,$15
>8790	07 84 8b 46 41 fd 06 39			.byte	$07,$84,$8b,$46,$41,$fd,$06,$39
>8798	33 37 35 00 0d e2 04 cf			.byte	$33,$37,$35,$00,$0d,$e2,$04,$cf
>87a0	06 35 0c b7 84 fe 03 4d			.byte	$06,$35,$0c,$b7,$84,$fe,$03,$4d
>87a8	00 12 ec 04 cf 02 33 06			.byte	$00,$12,$ec,$04,$cf,$02,$33,$06
>87b0	10 84 42 7c fd 06 35 36			.byte	$10,$84,$42,$7c,$fd,$06,$35,$36
>87b8	32 35 00 0e f6 04 cf 04			.byte	$32,$35,$00,$0e,$f6,$04,$cf,$04
>87c0	38 16 b7 84 fe 04 51 32			.byte	$38,$16,$b7,$84,$fe,$04,$51,$32
>87c8	00 11 00 05 cf 0b 30 18			.byte	$00,$11,$00,$05,$cf,$0b,$30,$18
>87d0	84 8b 45 7a fd 05 38 37			.byte	$84,$8b,$45,$7a,$fd,$05,$38,$37
>87d8	35 00 14 0a 05 cf 08 30			.byte	$35,$00,$14,$0a,$05,$cf,$08,$30
>87e0	16 0b 13 b9 84 48 69 fd			.byte	$16,$0b,$13,$b9,$84,$48,$69,$fd
>87e8	06 34 33 37 35 00 0f 14			.byte	$06,$34,$33,$37,$35,$00,$0f,$14
>87f0	05 cf 08 38 04 11 0d bb			.byte	$05,$cf,$08,$38,$04,$11,$0d,$bb
>87f8	84 8b 4e 5d 00 0d 1e 05			.byte	$84,$8b,$4e,$5d,$00,$0d,$1e,$05
>8800	cf 13 b7 84 fe 05 53 39			.byte	$cf,$13,$b7,$84,$fe,$05,$53,$39
>8808	47 00 12 28 05 cf 19 31			.byte	$47,$00,$12,$28,$05,$cf,$19,$31
>8810	06 84 8b 47 4b fd 06 31			.byte	$06,$84,$8b,$47,$4b,$fd,$06,$31
>8818	38 37 35 00 11 32 05 cf			.byte	$38,$37,$35,$00,$11,$32,$05,$cf
>8820	19 31 06 84 43 6a fd 06			.byte	$19,$31,$06,$84,$43,$6a,$fd,$06
>8828	38 31 32 35 00 12 3c 05			.byte	$38,$31,$32,$35,$00,$12,$3c,$05
>8830	cf 15 33 03 08 0c b7 84			.byte	$cf,$15,$33,$03,$08,$0c,$b7,$84
>8838	fe 06 51 32 43 51 00 0f			.byte	$fe,$06,$51,$32,$43,$51,$00,$0f
>8840	46 05 cf 15 b9 84 8b 47			.byte	$46,$05,$cf,$15,$b9,$84,$8b,$47
>8848	42 fd 04 32 35 00 14 50			.byte	$42,$fd,$04,$32,$35,$00,$14,$50
>8850	05 cf 0d 37 19 02 05 84			.byte	$05,$cf,$0d,$37,$19,$02,$05,$84
>8858	8b 47 6c fd 06 34 33 37			.byte	$8b,$47,$6c,$fd,$06,$34,$33,$37
>8860	35 00 0d 5a 05 cf 03 30			.byte	$35,$00,$0d,$5a,$05,$cf,$03,$30
>8868	0b bb 84 8b 41 6e 00 11			.byte	$0b,$bb,$84,$8b,$41,$6e,$00,$11
>8870	64 05 cf 0f 39 04 11 b7			.byte	$64,$05,$cf,$0f,$39,$04,$11,$b7
>8878	84 fe 06 54 36 52 4f 00			.byte	$84,$fe,$06,$54,$36,$52,$4f,$00
>8880	0e 6e 05 cf 19 31 06 84			.byte	$0e,$6e,$05,$cf,$19,$31,$06,$84
>8888	46 53 fd 03 35 00 0f 78			.byte	$46,$53,$fd,$03,$35,$00,$0f,$78
>8890	05 cf 17 84 8b 41 7a fd			.byte	$05,$cf,$17,$84,$8b,$41,$7a,$fd
>8898	05 36 32 35 00 13 82 05			.byte	$05,$36,$32,$35,$00,$13,$82,$05
>88a0	cf 05 36 0a 05 10 b7 84			.byte	$cf,$05,$36,$0a,$05,$10,$b7,$84
>88a8	fe 07 4b 37 58 52 47 00			.byte	$fe,$07,$4b,$37,$58,$52,$47,$00
>88b0	0b 8c 05 cf 13 b7 84 fe			.byte	$0b,$8c,$05,$cf,$13,$b7,$84,$fe
>88b8	03 58 00 0f 96 05 cf 05			.byte	$03,$58,$00,$0f,$96,$05,$cf,$05
>88c0	37 07 16 0e bb 84 8b 41			.byte	$37,$07,$16,$0e,$bb,$84,$8b,$41
>88c8	49 00 11 a0 05 cf 15 33			.byte	$49,$00,$11,$a0,$05,$cf,$15,$33
>88d0	15 11 18 84 8b 45 5f fd			.byte	$15,$11,$18,$84,$8b,$45,$5f,$fd
>88d8	03 30 00 0e aa 05 cf 0b			.byte	$03,$30,$00,$0e,$aa,$05,$cf,$0b
>88e0	b7 84 fe 06 4a 37 56 52			.byte	$b7,$84,$fe,$06,$4a,$37,$56,$52
>88e8	00 12 b4 05 cf 05 31 09			.byte	$00,$12,$b4,$05,$cf,$05,$31,$09
>88f0	0f ba 41 be 84 43 40 fd			.byte	$0f,$ba,$41,$be,$84,$43,$40,$fd
>88f8	03 35 00 10 be 05 cf 15			.byte	$03,$35,$00,$10,$be,$05,$cf,$15
>8900	31 04 05 bc 41 be 84 8b			.byte	$31,$04,$05,$bc,$41,$be,$84,$8b
>8908	41 65 00 0a c8 05 cf 09			.byte	$41,$65,$00,$0a,$c8,$05,$cf,$09
>8910	bb 84 42 5f 00 12 d2 05			.byte	$bb,$84,$42,$5f,$00,$12,$d2,$05
>8918	cf 0a 39 01 01 b9 84 8b			.byte	$cf,$0a,$39,$01,$01,$b9,$84,$8b
>8920	61 fd 05 31 32 35 00 10			.byte	$61,$fd,$05,$31,$32,$35,$00,$10
>8928	dc 05 cf 13 36 17 b7 84			.byte	$dc,$05,$cf,$13,$36,$17,$b7,$84
>8930	fe 06 44 33 41 44 00 13			.byte	$fe,$06,$44,$33,$41,$44,$00,$13
>8938	e6 05 cf 1a 31 14 0a 84			.byte	$e6,$05,$cf,$1a,$31,$14,$0a,$84
>8940	8b 41 60 fd 06 39 33 37			.byte	$8b,$41,$60,$fd,$06,$39,$33,$37
>8948	35 00 0e f0 05 cf 03 32			.byte	$35,$00,$0e,$f0,$05,$cf,$03,$32
>8950	18 0e 08 b7 84 fe 02 00			.byte	$18,$0e,$08,$b7,$84,$fe,$02,$00
>8958	13 fa 05 cf 11 39 16 bd			.byte	$13,$fa,$05,$cf,$11,$39,$16,$bd
>8960	40 be 84 48 50 fd 05 33			.byte	$40,$be,$84,$48,$50,$fd,$05,$33
>8968	37 35 00 13 04 06 cf 11			.byte	$37,$35,$00,$13,$04,$06,$cf,$11
>8970	37 17 11 12 b9 84 47 4c			.byte	$37,$17,$11,$12,$b9,$84,$47,$4c
>8978	fd 05 31 32 35 00 0b 0e			.byte	$fd,$05,$31,$32,$35,$00,$0b,$0e
>8980	06 cf 09 bb 84 8b 45 66			.byte	$06,$cf,$09,$bb,$84,$8b,$45,$66
>8988	00 0d 18 06 cf 03 b7 84			.byte	$00,$0d,$18,$06,$cf,$03,$b7,$84
>8990	fe 05 5a 34 50 00 0e 22			.byte	$fe,$05,$5a,$34,$50,$00,$0e,$22
>8998	06 cf 03 33 0c 06 15 bb			.byte	$06,$cf,$03,$33,$0c,$06,$15,$bb
>89a0	84 43 46 00 10 2c 06 cf			.byte	$84,$43,$46,$00,$10,$2c,$06,$cf
>89a8	13 35 17 84 8b 54 fd 05			.byte	$13,$35,$17,$84,$8b,$54,$fd,$05
>89b0	33 37 35 00 15 36 06 cf			.byte	$33,$37,$35,$00,$15,$36,$06,$cf
>89b8	11 37 17 11 12 b9 84 8b			.byte	$11,$37,$17,$11,$12,$b9,$84,$8b
>89c0	47 64 fd 06 39 33 37 35			.byte	$47,$64,$fd,$06,$39,$33,$37,$35
>89c8	00 0a 40 06 cf 01 bb 84			.byte	$00,$0a,$40,$06,$cf,$01,$bb,$84
>89d0	4b 43 00 12 4a 06 cf 0a			.byte	$4b,$43,$00,$12,$4a,$06,$cf,$0a
>89d8	39 12 b9 84 8b 47 50 fd			.byte	$39,$12,$b9,$84,$8b,$47,$50,$fd
>89e0	05 38 37 35 00 12 54 06			.byte	$05,$38,$37,$35,$00,$12,$54,$06
>89e8	cf 1a 31 14 0a 84 44 74			.byte	$cf,$1a,$31,$14,$0a,$84,$44,$74
>89f0	fd 06 38 31 32 35 00 12			.byte	$fd,$06,$38,$31,$32,$35,$00,$12
>89f8	5e 06 cf 02 33 12 12 b7			.byte	$5e,$06,$cf,$02,$33,$12,$12,$b7
>8a00	84 fe 07 53 37 44 51 47			.byte	$84,$fe,$07,$53,$37,$44,$51,$47
>8a08	00 0f 68 06 cf 07 33 1a			.byte	$00,$0f,$68,$06,$cf,$07,$33,$1a
>8a10	15 0f b7 84 fe 03 46 00			.byte	$15,$0f,$b7,$84,$fe,$03,$46,$00
>8a18	10 72 06 cf 11 37 14 03			.byte	$10,$72,$06,$cf,$11,$37,$14,$03
>8a20	b7 84 fe 05 48 36 48 00			.byte	$b7,$84,$fe,$05,$48,$36,$48,$00
>8a28	13 7c 06 cf 03 35 07 b8			.byte	$13,$7c,$06,$cf,$03,$35,$07,$b8
>8a30	41 bf 41 be 84 fe 05 41			.byte	$41,$bf,$41,$be,$84,$fe,$05,$41
>8a38	31 41 00 0d 86 06 cf 11			.byte	$31,$41,$00,$0d,$86,$06,$cf,$11
>8a40	35 07 b7 84 fe 03 46 00			.byte	$35,$07,$b7,$84,$fe,$03,$46,$00
>8a48	0f 90 06 cf 19 31 06 84			.byte	$0f,$90,$06,$cf,$19,$31,$06,$84
>8a50	44 53 fd 04 37 35 00 0d			.byte	$44,$53,$fd,$04,$37,$35,$00,$0d
>8a58	9a 06 cf 0b b7 84 fe 05			.byte	$9a,$06,$cf,$0b,$b7,$84,$fe,$05
>8a60	4b 38 47 00 11 a4 06 cf			.byte	$4b,$38,$47,$00,$11,$a4,$06,$cf
>8a68	01 33 0a bc 40 bf 40 be			.byte	$01,$33,$0a,$bc,$40,$bf,$40,$be
>8a70	84 8b 42 43 00 13 ae 06			.byte	$84,$8b,$42,$43,$00,$13,$ae,$06
>8a78	cf 18 37 0e 01 01 84 8b			.byte	$cf,$18,$37,$0e,$01,$01,$84,$8b
>8a80	42 75 fd 05 38 37 35 00			.byte	$42,$75,$fd,$05,$38,$37,$35,$00
>8a88	10 b8 06 cf 0f 33 17 13			.byte	$10,$b8,$06,$cf,$0f,$33,$17,$13
>8a90	bc 40 be 84 8b 43 67 00			.byte	$bc,$40,$be,$84,$8b,$43,$67,$00
>8a98	0e c2 06 cf 13 35 17 84			.byte	$0e,$c2,$06,$cf,$13,$35,$17,$84
>8aa0	45 7f fd 03 30 00 0f cc			.byte	$45,$7f,$fd,$03,$30,$00,$0f,$cc
>8aa8	06 cf 1a 31 14 0a 84 48			.byte	$06,$cf,$1a,$31,$14,$0a,$84,$48
>8ab0	71 fd 03 35 00 12 d6 06			.byte	$71,$fd,$03,$35,$00,$12,$d6,$06
>8ab8	cf 01 38 11 17 06 b9 84			.byte	$cf,$01,$38,$11,$17,$06,$b9,$84
>8ac0	8b 42 6a fd 03 35 00 10			.byte	$8b,$42,$6a,$fd,$03,$35,$00,$10
>8ac8	e0 06 cf 0a 39 12 b9 84			.byte	$e0,$06,$cf,$0a,$39,$12,$b9,$84
>8ad0	46 7e fd 04 37 35 00 10			.byte	$46,$7e,$fd,$04,$37,$35,$00,$10
>8ad8	ea 06 cf 02 34 0e 19 b9			.byte	$ea,$06,$cf,$02,$34,$0e,$19,$b9
>8ae0	84 63 fd 04 32 35 00 10			.byte	$84,$63,$fd,$04,$32,$35,$00,$10
>8ae8	f4 06 cf 12 33 03 b9 84			.byte	$f4,$06,$cf,$12,$33,$03,$b9,$84
>8af0	42 59 fd 04 32 35 00 12			.byte	$42,$59,$fd,$04,$32,$35,$00,$12
>8af8	fe 06 cf 0a 37 01 03 b7			.byte	$fe,$06,$cf,$0a,$37,$01,$03,$b7
>8b00	84 fe 07 57 31 5a 4f 58			.byte	$84,$fe,$07,$57,$31,$5a,$4f,$58
>8b08	00 0d 08 07 cf 0f 31 0b			.byte	$00,$0d,$08,$07,$cf,$0f,$31,$0b
>8b10	0a 0f bb 84 67 00 0f 12			.byte	$0a,$0f,$bb,$84,$67,$00,$0f,$12
>8b18	07 cf 18 32 0f 08 0f bb			.byte	$07,$cf,$18,$32,$0f,$08,$0f,$bb
>8b20	84 8b 44 4e 00 10 1c 07			.byte	$84,$8b,$44,$4e,$00,$10,$1c,$07
>8b28	cf 15 31 04 05 bc 41 be			.byte	$cf,$15,$31,$04,$05,$bc,$41,$be
>8b30	84 8b 44 7b 00 0d 26 07			.byte	$84,$8b,$44,$7b,$00,$0d,$26,$07
>8b38	cf 0a 31 08 bb 84 8b 4f			.byte	$cf,$0a,$31,$08,$bb,$84,$8b,$4f
>8b40	64 00 12 30 07 cf 0b 38			.byte	$64,$00,$12,$30,$07,$cf,$0b,$38
>8b48	06 b9 84 8b 45 72 fd 05			.byte	$06,$b9,$84,$8b,$45,$72,$fd,$05
>8b50	33 37 35 00 0e 3a 07 cf			.byte	$33,$37,$35,$00,$0e,$3a,$07,$cf
>8b58	0e 32 01 07 01 bb 84 4e			.byte	$0e,$32,$01,$07,$01,$bb,$84,$4e
>8b60	4f 00 15 44 07 cf 01 38			.byte	$4f,$00,$15,$44,$07,$cf,$01,$38
>8b68	11 17 06 b9 84 8b 49 49			.byte	$11,$17,$06,$b9,$84,$8b,$49,$49
>8b70	fd 06 38 31 32 35 00 10			.byte	$fd,$06,$38,$31,$32,$35,$00,$10
>8b78	4e 07 cf 0c 37 0b 08 b7			.byte	$4e,$07,$cf,$0c,$37,$0b,$08,$b7
>8b80	84 fe 05 52 35 4e 00 11			.byte	$84,$fe,$05,$52,$35,$4e,$00,$11
>8b88	58 07 cf 16 32 15 bc 41			.byte	$58,$07,$cf,$16,$32,$15,$bc,$41
>8b90	bf 41 be 84 8b 44 5b 00			.byte	$bf,$41,$be,$84,$8b,$44,$5b,$00
>8b98	0e 62 07 cf 11 35 07 b7			.byte	$0e,$62,$07,$cf,$11,$35,$07,$b7
>8ba0	84 fe 04 4e 30 00 0d 6c			.byte	$84,$fe,$04,$4e,$30,$00,$0d,$6c
>8ba8	07 cf 12 b7 84 fe 05 56			.byte	$07,$cf,$12,$b7,$84,$fe,$05,$56
>8bb0	31 52 00 13 76 07 cf 03			.byte	$31,$52,$00,$13,$76,$07,$cf,$03
>8bb8	35 07 b8 41 bf 41 be 84			.byte	$35,$07,$b8,$41,$bf,$41,$be,$84
>8bc0	fe 05 4a 30 56 00 12 80			.byte	$fe,$05,$4a,$30,$56,$00,$12,$80
>8bc8	07 cf 08 34 0f bd 41 be			.byte	$07,$cf,$08,$34,$0f,$bd,$41,$be
>8bd0	84 8b 48 62 fd 03 30 00			.byte	$84,$8b,$48,$62,$fd,$03,$30,$00
>8bd8	0b 8a 07 cf 03 30 0b bb			.byte	$0b,$8a,$07,$cf,$03,$30,$0b,$bb
>8be0	84 5a 00 13 94 07 cf 09			.byte	$84,$5a,$00,$13,$94,$07,$cf,$09
>8be8	30 11 03 11 84 8b 44 fd			.byte	$30,$11,$03,$11,$84,$8b,$44,$fd
>8bf0	06 30 36 32 35 00 0c 9e			.byte	$06,$30,$36,$32,$35,$00,$0c,$9e
>8bf8	07 cf 15 33 1a bb 84 4c			.byte	$07,$cf,$15,$33,$1a,$bb,$84,$4c
>8c00	67 00 10 a8 07 cf 0a 39			.byte	$67,$00,$10,$a8,$07,$cf,$0a,$39
>8c08	12 b9 84 8b 48 58 fd 03			.byte	$12,$b9,$84,$8b,$48,$58,$fd,$03
>8c10	30 00 0a b2 07 cf 0d bb			.byte	$30,$00,$0a,$b2,$07,$cf,$0d,$bb
>8c18	84 49 60 00 0e bc 07 cf			.byte	$84,$49,$60,$00,$0e,$bc,$07,$cf
>8c20	08 38 04 11 0d bb 84 4b			.byte	$08,$38,$04,$11,$0d,$bb,$84,$4b
>8c28	5f 00 11 c6 07 cf 02 35			.byte	$5f,$00,$11,$c6,$07,$cf,$02,$35
>8c30	06 b9 84 8b 47 62 fd 04			.byte	$06,$b9,$84,$8b,$47,$62,$fd,$04
>8c38	32 35 00 11 d0 07 cf 08			.byte	$32,$35,$00,$11,$d0,$07,$cf,$08
>8c40	34 0f bd 42 be 84 45 41			.byte	$34,$0f,$bd,$42,$be,$84,$45,$41
>8c48	fd 03 35 00 10 da 07 cf			.byte	$fd,$03,$35,$00,$10,$da,$07,$cf
>8c50	0d 37 19 02 05 84 48 63			.byte	$0d,$37,$19,$02,$05,$84,$48,$63
>8c58	fd 03 30 00 0c e4 07 cf			.byte	$fd,$03,$30,$00,$0c,$e4,$07,$cf
>8c60	19 84 41 48 fd 03 35 00			.byte	$19,$84,$41,$48,$fd,$03,$35,$00
>8c68	13 ee 07 cf 1a 30 0b 09			.byte	$13,$ee,$07,$cf,$1a,$30,$0b,$09
>8c70	16 84 8b 43 4b fd 05 31			.byte	$16,$84,$8b,$43,$4b,$fd,$05,$31
>8c78	32 35 00 10 f8 07 cf 0a			.byte	$32,$35,$00,$10,$f8,$07,$cf,$0a
>8c80	36 06 b7 84 fe 06 5a 35			.byte	$36,$06,$b7,$84,$fe,$06,$5a,$35
>8c88	47 58 00 12 02 08 cf 08			.byte	$47,$58,$00,$12,$02,$08,$cf,$08
>8c90	34 0f bd 40 be 84 45 75			.byte	$34,$0f,$bd,$40,$be,$84,$45,$75
>8c98	fd 04 37 35 00 0e 0c 08			.byte	$fd,$04,$37,$35,$00,$0e,$0c,$08
>8ca0	cf 10 b7 84 fe 06 48 36			.byte	$cf,$10,$b7,$84,$fe,$06,$48,$36
>8ca8	55 59 00 0c 16 08 cf 01			.byte	$55,$59,$00,$0c,$16,$08,$cf,$01
>8cb0	34 05 b7 84 fe 02 00 12			.byte	$34,$05,$b7,$84,$fe,$02,$00,$12
>8cb8	20 08 cf 0d 34 01 18 b7			.byte	$20,$08,$cf,$0d,$34,$01,$18,$b7
>8cc0	84 fe 07 53 33 53 4e 4d			.byte	$84,$fe,$07,$53,$33,$53,$4e,$4d
>8cc8	00 0e 2a 08 cf 0f 31 0b			.byte	$00,$0e,$2a,$08,$cf,$0f,$31,$0b
>8cd0	0a 0f bb 84 4a 4d 00 13			.byte	$0a,$0f,$bb,$84,$4a,$4d,$00,$13
>8cd8	34 08 cf 11 39 16 bd 41			.byte	$34,$08,$cf,$11,$39,$16,$bd,$41
>8ce0	be 84 48 59 fd 05 33 37			.byte	$be,$84,$48,$59,$fd,$05,$33,$37
>8ce8	35 00 0d 3e 08 cf 08 33			.byte	$35,$00,$0d,$3e,$08,$cf,$08,$33
>8cf0	1a b7 84 fe 03 47 00 13			.byte	$1a,$b7,$84,$fe,$03,$47,$00,$13
>8cf8	48 08 cf 09 30 11 03 11			.byte	$48,$08,$cf,$09,$30,$11,$03,$11
>8d00	84 8b 42 63 fd 05 31 32			.byte	$84,$8b,$42,$63,$fd,$05,$31,$32
>8d08	35 00 0b 52 08 dc 09 bb			.byte	$35,$00,$0b,$52,$08,$dc,$09,$bb
>8d10	84 8b 45 66 00 0e 5c 08			.byte	$84,$8b,$45,$66,$00,$0e,$5c,$08
>8d18	dc 03 33 0c 06 15 bb 84			.byte	$dc,$03,$33,$0c,$06,$15,$bb,$84
>8d20	43 46 00 12 66 08 dc 19			.byte	$43,$46,$00,$12,$66,$08,$dc,$19
>8d28	37 09 0e 19 b9 84 8b 62			.byte	$37,$09,$0e,$19,$b9,$84,$8b,$62
>8d30	fd 04 32 35 00 10 70 08			.byte	$fd,$04,$32,$35,$00,$10,$70,$08
>8d38	dc 11 37 14 03 b7 84 fe			.byte	$dc,$11,$37,$14,$03,$b7,$84,$fe
>8d40	05 48 36 48 00 0b 7a 08			.byte	$05,$48,$36,$48,$00,$0b,$7a,$08
>8d48	dc 06 b7 84 fe 03 4a 00			.byte	$dc,$06,$b7,$84,$fe,$03,$4a,$00
>8d50	12 84 08 dc 02 33 06 10			.byte	$12,$84,$08,$dc,$02,$33,$06,$10
>8d58	84 42 7c fd 06 35 36 32			.byte	$84,$42,$7c,$fd,$06,$35,$36,$32
>8d60	35 00 13 8e 08 dc 01 39			.byte	$35,$00,$13,$8e,$08,$dc,$01,$39
>8d68	08 14 05 84 8b 41 78 fd			.byte	$08,$14,$05,$84,$8b,$41,$78,$fd
>8d70	05 33 37 35 00 0f 98 08			.byte	$05,$33,$37,$35,$00,$0f,$98,$08
>8d78	dc 05 37 07 16 0e bb 84			.byte	$dc,$05,$37,$07,$16,$0e,$bb,$84
>8d80	8b 41 49 00 13 a2 08 dc			.byte	$8b,$41,$49,$00,$13,$a2,$08,$dc
>8d88	1a 30 0b 09 16 84 8b 43			.byte	$1a,$30,$0b,$09,$16,$84,$8b,$43
>8d90	4b fd 05 31 32 35 00 0d			.byte	$4b,$fd,$05,$31,$32,$35,$00,$0d
>8d98	ac 08 dc 0e 37 0e bb 84			.byte	$ac,$08,$dc,$0e,$37,$0e,$bb,$84
>8da0	8b 4f 5c 00 0a b6 08 dc			.byte	$8b,$4f,$5c,$00,$0a,$b6,$08,$dc
>8da8	01 bb 84 4b 43 00 0f c0			.byte	$01,$bb,$84,$4b,$43,$00,$0f,$c0
>8db0	08 dc 19 31 06 84 44 53			.byte	$08,$dc,$19,$31,$06,$84,$44,$53
>8db8	fd 04 37 35 00 0f ca 08			.byte	$fd,$04,$37,$35,$00,$0f,$ca,$08
>8dc0	dc 0a b9 84 44 6c fd 05			.byte	$dc,$0a,$b9,$84,$44,$6c,$fd,$05
>8dc8	33 37 35 00 0e d4 08 dc			.byte	$33,$37,$35,$00,$0e,$d4,$08,$dc
>8dd0	04 38 16 b7 84 fe 04 51			.byte	$04,$38,$16,$b7,$84,$fe,$04,$51
>8dd8	32 00 10 de 08 dc 05 39			.byte	$32,$00,$10,$de,$08,$dc,$05,$39
>8de0	0c 0d b7 84 fe 05 4f 38			.byte	$0c,$0d,$b7,$84,$fe,$05,$4f,$38
>8de8	46 00 15 e8 08 dc 01 38			.byte	$46,$00,$15,$e8,$08,$dc,$01,$38
>8df0	11 17 06 b9 84 8b 49 49			.byte	$11,$17,$06,$b9,$84,$8b,$49,$49
>8df8	fd 06 38 31 32 35 00 11			.byte	$fd,$06,$38,$31,$32,$35,$00,$11
>8e00	f2 08 dc 0f 39 04 11 b7			.byte	$f2,$08,$dc,$0f,$39,$04,$11,$b7
>8e08	84 fe 06 54 36 52 4f 00			.byte	$84,$fe,$06,$54,$36,$52,$4f,$00
>8e10	14 fc 08 dc 11 33 0e 09			.byte	$14,$fc,$08,$dc,$11,$33,$0e,$09
>8e18	b9 84 8b 45 4c fd 06 38			.byte	$b9,$84,$8b,$45,$4c,$fd,$06,$38
>8e20	31 32 35 00 0d 06 09 dc			.byte	$31,$32,$35,$00,$0d,$06,$09,$dc
>8e28	0a 31 08 bb 84 8b 4f 64			.byte	$0a,$31,$08,$bb,$84,$8b,$4f,$64
>8e30	00 0f 10 09 dc 18 32 0f			.byte	$00,$0f,$10,$09,$dc,$18,$32,$0f
>8e38	08 0f bb 84 8b 44 4e 00			.byte	$08,$0f,$bb,$84,$8b,$44,$4e,$00
>8e40	0d 1a 09 dc 0d 35 0d 19			.byte	$0d,$1a,$09,$dc,$0d,$35,$0d,$19
>8e48	13 b9 84 40 00 0d 24 09			.byte	$13,$b9,$84,$40,$00,$0d,$24,$09
>8e50	dc 12 b7 84 fe 05 56 31			.byte	$dc,$12,$b7,$84,$fe,$05,$56,$31
>8e58	52 00 11 2e 09 dc 0b 30			.byte	$52,$00,$11,$2e,$09,$dc,$0b,$30
>8e60	18 84 8b 45 7a fd 05 38			.byte	$18,$84,$8b,$45,$7a,$fd,$05,$38
>8e68	37 35 00 0f 38 09 dc 15			.byte	$37,$35,$00,$0f,$38,$09,$dc,$15
>8e70	b9 84 8b 47 42 fd 04 32			.byte	$b9,$84,$8b,$47,$42,$fd,$04,$32
>8e78	35 00 12 42 09 dc 15 33			.byte	$35,$00,$12,$42,$09,$dc,$15,$33
>8e80	03 08 0c b7 84 fe 06 51			.byte	$03,$08,$0c,$b7,$84,$fe,$06,$51
>8e88	32 43 51 00 15 4c 09 dc			.byte	$32,$43,$51,$00,$15,$4c,$09,$dc
>8e90	11 37 17 11 12 b9 84 8b			.byte	$11,$37,$17,$11,$12,$b9,$84,$8b
>8e98	47 64 fd 06 39 33 37 35			.byte	$47,$64,$fd,$06,$39,$33,$37,$35
>8ea0	00 14 56 09 dc 11 39 03			.byte	$00,$14,$56,$09,$dc,$11,$39,$03
>8ea8	06 11 84 8b 48 49 fd 06			.byte	$06,$11,$84,$8b,$48,$49,$fd,$06
>8eb0	33 31 32 35 00 0d 60 09			.byte	$33,$31,$32,$35,$00,$0d,$60,$09
>8eb8	dc 03 b7 84 fe 05 5a 34			.byte	$dc,$03,$b7,$84,$fe,$05,$5a,$34
>8ec0	50 00 0d 6a 09 dc 08 33			.byte	$50,$00,$0d,$6a,$09,$dc,$08,$33
>8ec8	1a b7 84 fe 03 47 00 0e			.byte	$1a,$b7,$84,$fe,$03,$47,$00,$0e
>8ed0	74 09 dc 19 37 0a 07 19			.byte	$74,$09,$dc,$19,$37,$0a,$07,$19
>8ed8	bb 84 4c 6a 00 10 7e 09			.byte	$bb,$84,$4c,$6a,$00,$10,$7e,$09
>8ee0	dc 12 33 03 b9 84 42 59			.byte	$dc,$12,$33,$03,$b9,$84,$42,$59
>8ee8	fd 04 32 35 00 0d 88 09			.byte	$fd,$04,$32,$35,$00,$0d,$88,$09
>8ef0	dc 0b 34 09 1a b7 84 fe			.byte	$dc,$0b,$34,$09,$1a,$b7,$84,$fe
>8ef8	02 00 0e 92 09 dc 01 32			.byte	$02,$00,$0e,$92,$09,$dc,$01,$32
>8f00	05 06 0f bb 84 4c 43 00			.byte	$05,$06,$0f,$bb,$84,$4c,$43,$00
>8f08	13 9c 09 dc 09 39 14 b9			.byte	$13,$9c,$09,$dc,$09,$39,$14,$b9
>8f10	84 8b 45 6f fd 06 33 31			.byte	$84,$8b,$45,$6f,$fd,$06,$33,$31
>8f18	32 35 00 13 a6 09 dc 05			.byte	$32,$35,$00,$13,$a6,$09,$dc,$05
>8f20	36 0a 05 10 b7 84 fe 07			.byte	$36,$0a,$05,$10,$b7,$84,$fe,$07
>8f28	4b 37 58 52 47 00 10 b0			.byte	$4b,$37,$58,$52,$47,$00,$10,$b0
>8f30	09 dc 02 34 0e 19 b9 84			.byte	$09,$dc,$02,$34,$0e,$19,$b9,$84
>8f38	63 fd 04 32 35 00 12 ba			.byte	$63,$fd,$04,$32,$35,$00,$12,$ba
>8f40	09 dc 02 33 12 12 b7 84			.byte	$09,$dc,$02,$33,$12,$12,$b7,$84
>8f48	fe 07 53 37 44 51 47 00			.byte	$fe,$07,$53,$37,$44,$51,$47,$00
>8f50	0d c4 09 dc 0e 35 15 0f			.byte	$0d,$c4,$09,$dc,$0e,$35,$15,$0f
>8f58	04 b9 84 40 00 0d ce 09			.byte	$04,$b9,$84,$40,$00,$0d,$ce,$09
>8f60	dc 06 35 0c b7 84 fe 03			.byte	$dc,$06,$35,$0c,$b7,$84,$fe,$03
>8f68	4d 00 10 d8 09 dc 13 36			.byte	$4d,$00,$10,$d8,$09,$dc,$13,$36
>8f70	17 b7 84 fe 06 44 33 41			.byte	$17,$b7,$84,$fe,$06,$44,$33,$41
>8f78	44 00 11 e2 09 dc 15 33			.byte	$44,$00,$11,$e2,$09,$dc,$15,$33
>8f80	15 11 18 84 8b 45 5f fd			.byte	$15,$11,$18,$84,$8b,$45,$5f,$fd
>8f88	03 30 00 0f ec 09 dc 11			.byte	$03,$30,$00,$0f,$ec,$09,$dc,$11
>8f90	84 8b 7c fd 06 34 33 37			.byte	$84,$8b,$7c,$fd,$06,$34,$33,$37
>8f98	35 00 0d f6 09 dc 0f 35			.byte	$35,$00,$0d,$f6,$09,$dc,$0f,$35
>8fa0	02 14 b7 84 fe 02 00 0f			.byte	$02,$14,$b7,$84,$fe,$02,$00,$0f
>8fa8	00 0a dc 17 84 8b 41 7a			.byte	$00,$0a,$dc,$17,$84,$8b,$41,$7a
>8fb0	fd 05 36 32 35 00 0e 0a			.byte	$fd,$05,$36,$32,$35,$00,$0e,$0a
>8fb8	0a dc 08 38 04 11 0d bb			.byte	$0a,$dc,$08,$38,$04,$11,$0d,$bb
>8fc0	84 4b 5f 00 0f 14 0a dc			.byte	$84,$4b,$5f,$00,$0f,$14,$0a,$dc
>8fc8	1a 31 14 0a 84 48 71 fd			.byte	$1a,$31,$14,$0a,$84,$48,$71,$fd
>8fd0	03 35 00 11 1e 0a dc 01			.byte	$03,$35,$00,$11,$1e,$0a,$dc,$01
>8fd8	31 16 02 b9 84 47 7a fd			.byte	$31,$16,$02,$b9,$84,$47,$7a,$fd
>8fe0	04 37 35 00 0c 28 0a dc			.byte	$04,$37,$35,$00,$0c,$28,$0a,$dc
>8fe8	17 33 17 07 14 84 40 00			.byte	$17,$33,$17,$07,$14,$84,$40,$00
>8ff0	0f 32 0a dc 07 33 1a 15			.byte	$0f,$32,$0a,$dc,$07,$33,$1a,$15
>8ff8	0f b7 84 fe 03 46 00 10			.byte	$0f,$b7,$84,$fe,$03,$46,$00,$10
>9000	3c 0a dc 05 36 12 0e 84			.byte	$3c,$0a,$dc,$05,$36,$12,$0e,$84
>9008	49 4b fd 04 32 35 00 0b			.byte	$49,$4b,$fd,$04,$32,$35,$00,$0b
>9010	46 0a dc 13 b7 84 fe 03			.byte	$46,$0a,$dc,$13,$b7,$84,$fe,$03
>9018	58 00 12 50 0a dc 0a 37			.byte	$58,$00,$12,$50,$0a,$dc,$0a,$37
>9020	01 03 b7 84 fe 07 57 31			.byte	$01,$03,$b7,$84,$fe,$07,$57,$31
>9028	5a 4f 58 00 0e 5a 0a dc			.byte	$5a,$4f,$58,$00,$0e,$5a,$0a,$dc
>9030	10 b7 84 fe 06 48 36 55			.byte	$10,$b7,$84,$fe,$06,$48,$36,$55
>9038	59 00 12 64 0a dc 0b 38			.byte	$59,$00,$12,$64,$0a,$dc,$0b,$38
>9040	06 b9 84 8b 45 72 fd 05			.byte	$06,$b9,$84,$8b,$45,$72,$fd,$05
>9048	33 37 35 00 0c 6e 0a dc			.byte	$33,$37,$35,$00,$0c,$6e,$0a,$dc
>9050	0e 84 42 77 fd 03 30 00			.byte	$0e,$84,$42,$77,$fd,$03,$30,$00
>9058	13 78 0a dc 09 30 11 03			.byte	$13,$78,$0a,$dc,$09,$30,$11,$03
>9060	11 84 8b 42 63 fd 05 31			.byte	$11,$84,$8b,$42,$63,$fd,$05,$31
>9068	32 35 00 13 82 0a dc 0e			.byte	$32,$35,$00,$13,$82,$0a,$dc,$0e
>9070	30 09 10 84 8b 43 5a fd			.byte	$30,$09,$10,$84,$8b,$43,$5a,$fd
>9078	06 39 33 37 35 00 0a 8c			.byte	$06,$39,$33,$37,$35,$00,$0a,$8c
>9080	0a dc 14 b7 84 fe 02 00			.byte	$0a,$dc,$14,$b7,$84,$fe,$02,$00
>9088	0d 96 0a dc 05 35 11 0a			.byte	$0d,$96,$0a,$dc,$05,$35,$11,$0a
>9090	09 bb 84 40 00 0c a0 0a			.byte	$09,$bb,$84,$40,$00,$0c,$a0,$0a
>9098	dc 06 36 0d bb 84 8b 50			.byte	$dc,$06,$36,$0d,$bb,$84,$8b,$50
>90a0	00 0b aa 0a dc 11 38 0f			.byte	$00,$0b,$aa,$0a,$dc,$11,$38,$0f
>90a8	08 84 40 00 0e b4 0a dc			.byte	$08,$84,$40,$00,$0e,$b4,$0a,$dc
>90b0	0e 32 01 07 01 bb 84 4e			.byte	$0e,$32,$01,$07,$01,$bb,$84,$4e
>90b8	4f 00 0b be 0a dc 03 30			.byte	$4f,$00,$0b,$be,$0a,$dc,$03,$30
>90c0	0b bb 84 5a 00 0e c8 0a			.byte	$0b,$bb,$84,$5a,$00,$0e,$c8,$0a
>90c8	dc 03 32 18 0e 08 b7 84			.byte	$dc,$03,$32,$18,$0e,$08,$b7,$84
>90d0	fe 02 00 0a d2 0a dc 12			.byte	$fe,$02,$00,$0a,$d2,$0a,$dc,$12
>90d8	33 0c 84 40 00 0d dc 0a			.byte	$33,$0c,$84,$40,$00,$0d,$dc,$0a
>90e0	dc 14 31 07 17 0a bb 84			.byte	$dc,$14,$31,$07,$17,$0a,$bb,$84
>90e8	40 00 13 e6 0a dc 05 30			.byte	$40,$00,$13,$e6,$0a,$dc,$05,$30
>90f0	16 18 05 84 8b 48 6c fd			.byte	$16,$18,$05,$84,$8b,$48,$6c,$fd
>90f8	05 36 32 35 00 12 f0 0a			.byte	$05,$36,$32,$35,$00,$12,$f0,$0a
>9100	dc 0a 39 01 01 b9 84 8b			.byte	$dc,$0a,$39,$01,$01,$b9,$84,$8b
>9108	61 fd 05 31 32 35 00 10			.byte	$61,$fd,$05,$31,$32,$35,$00,$10
>9110	fa 0a dc 0d 37 19 02 05			.byte	$fa,$0a,$dc,$0d,$37,$19,$02,$05
>9118	84 48 63 fd 03 30 00 13			.byte	$84,$48,$63,$fd,$03,$30,$00,$13
>9120	04 0b dc 1a 34 13 14 b9			.byte	$04,$0b,$dc,$1a,$34,$13,$14,$b9
>9128	84 44 70 fd 06 30 36 32			.byte	$84,$44,$70,$fd,$06,$30,$36,$32
>9130	35 00 10 0e 0b dc 0a 39			.byte	$35,$00,$10,$0e,$0b,$dc,$0a,$39
>9138	12 b9 84 8b 48 58 fd 03			.byte	$12,$b9,$84,$8b,$48,$58,$fd,$03
>9140	30 00 0c 18 0b dc 19 84			.byte	$30,$00,$0c,$18,$0b,$dc,$19,$84
>9148	41 48 fd 03 35 00 0d 22			.byte	$41,$48,$fd,$03,$35,$00,$0d,$22
>9150	0b dc 05 35 0e 1a bb 84			.byte	$0b,$dc,$05,$35,$0e,$1a,$bb,$84
>9158	49 76 00 0d 2c 0b dc 01			.byte	$49,$76,$00,$0d,$2c,$0b,$dc,$01
>9160	37 16 bb 84 8b 48 5d 00			.byte	$37,$16,$bb,$84,$8b,$48,$5d,$00
>9168	11 36 0b dc 17 38 13 07			.byte	$11,$36,$0b,$dc,$17,$38,$13,$07
>9170	b7 84 fe 06 57 32 4e 49			.byte	$b7,$84,$fe,$06,$57,$32,$4e,$49
>9178	00 0e 40 0b dc 0f 31 0b			.byte	$00,$0e,$40,$0b,$dc,$0f,$31,$0b
>9180	0a 0f bb 84 4a 4d 00 0e			.byte	$0a,$0f,$bb,$84,$4a,$4d,$00,$0e
>9188	4a 0b dc 14 36 0f 0e b7			.byte	$4a,$0b,$dc,$14,$36,$0f,$0e,$b7
>9190	84 fe 03 45 00 0c 54 0b			.byte	$84,$fe,$03,$45,$00,$0c,$54,$0b
>9198	dc 01 34 05 b7 84 fe 02			.byte	$dc,$01,$34,$05,$b7,$84,$fe,$02
>91a0	00 0c 5e 0b dc 05 34 09			.byte	$00,$0c,$5e,$0b,$dc,$05,$34,$09
>91a8	13 09 84 40 00 12 68 0b			.byte	$13,$09,$84,$40,$00,$12,$68,$0b
>91b0	dc 1a 31 0f 15 05 b9 84			.byte	$dc,$1a,$31,$0f,$15,$05,$b9,$84
>91b8	48 78 fd 04 32 35 00 0d			.byte	$48,$78,$fd,$04,$32,$35,$00,$0d
>91c0	72 0b dc 0f 34 15 16 16			.byte	$72,$0b,$dc,$0f,$34,$15,$16,$16
>91c8	b9 84 40 00 13 7c 0b dc			.byte	$b9,$84,$40,$00,$13,$7c,$0b,$dc
>91d0	13 31 15 07 84 8b 46 41			.byte	$13,$31,$15,$07,$84,$8b,$46,$41
>91d8	fd 06 39 33 37 35 00 11			.byte	$fd,$06,$39,$33,$37,$35,$00,$11
>91e0	86 0b dc 1a 38 19 09 84			.byte	$86,$0b,$dc,$1a,$38,$19,$09,$84
>91e8	42 5c fd 05 31 32 35 00			.byte	$42,$5c,$fd,$05,$31,$32,$35,$00
>91f0	0c 90 0b dc 15 33 1a bb			.byte	$0c,$90,$0b,$dc,$15,$33,$1a,$bb
>91f8	84 4c 67 00 0d 9a 0b dc			.byte	$84,$4c,$67,$00,$0d,$9a,$0b,$dc
>9200	18 30 15 0f 19 bb 84 40			.byte	$18,$30,$15,$0f,$19,$bb,$84,$40
>9208	00 11 a4 0b dc 02 35 06			.byte	$00,$11,$a4,$0b,$dc,$02,$35,$06
>9210	b9 84 8b 47 62 fd 04 32			.byte	$b9,$84,$8b,$47,$62,$fd,$04,$32
>9218	35 00 0d ae 0b dc 0b b7			.byte	$35,$00,$0d,$ae,$0b,$dc,$0b,$b7
>9220	84 fe 05 4b 38 47 00 10			.byte	$84,$fe,$05,$4b,$38,$47,$00,$10
>9228	b8 0b dc 0c 37 0b 08 b7			.byte	$b8,$0b,$dc,$0c,$37,$0b,$08,$b7
>9230	84 fe 05 52 35 4e 00 0e			.byte	$84,$fe,$05,$52,$35,$4e,$00,$0e
>9238	c2 0b dc 05 32 13 0c 1a			.byte	$c2,$0b,$dc,$05,$32,$13,$0c,$1a
>9240	bb 84 4d 60 00 13 cc 0b			.byte	$bb,$84,$4d,$60,$00,$13,$cc,$0b
>9248	dc 18 37 0e 01 01 84 8b			.byte	$dc,$18,$37,$0e,$01,$01,$84,$8b
>9250	42 75 fd 05 38 37 35 00			.byte	$42,$75,$fd,$05,$38,$37,$35,$00
>9258	13 d6 0b dc 0e 37 1a 18			.byte	$13,$d6,$0b,$dc,$0e,$37,$1a,$18
>9260	0a 84 42 5c fd 06 30 36			.byte	$0a,$84,$42,$5c,$fd,$06,$30,$36
>9268	32 35 00 0e e0 0b dc 15			.byte	$32,$35,$00,$0e,$e0,$0b,$dc,$15
>9270	30 0e 0e bb 84 8b 42 5f			.byte	$30,$0e,$0e,$bb,$84,$8b,$42,$5f
>9278	00 0e ea 0b dc 13 35 17			.byte	$00,$0e,$ea,$0b,$dc,$13,$35,$17
>9280	84 45 7f fd 03 30 00 12			.byte	$84,$45,$7f,$fd,$03,$30,$00,$12
>9288	f4 0b dc 0d 34 01 18 b7			.byte	$f4,$0b,$dc,$0d,$34,$01,$18,$b7
>9290	84 fe 07 53 33 53 4e 4d			.byte	$84,$fe,$07,$53,$33,$53,$4e,$4d
>9298	00 0c fe 0b dc 09 36 0a			.byte	$00,$0c,$fe,$0b,$dc,$09,$36,$0a
>92a0	18 b9 84 40 00 14 08 0c			.byte	$18,$b9,$84,$40,$00,$14,$08,$0c
>92a8	dc 08 30 16 0b 13 b9 84			.byte	$dc,$08,$30,$16,$0b,$13,$b9,$84
>92b0	48 69 fd 06 34 33 37 35			.byte	$48,$69,$fd,$06,$34,$33,$37,$35
>92b8	00 10 12 0c dc 0a 36 06			.byte	$00,$10,$12,$0c,$dc,$0a,$36,$06
>92c0	b7 84 fe 06 5a 35 47 58			.byte	$b7,$84,$fe,$06,$5a,$35,$47,$58
>92c8	00 10 1c 0c dc 02 36 07			.byte	$00,$10,$1c,$0c,$dc,$02,$36,$07
>92d0	b9 84 42 5c fd 04 37 35			.byte	$b9,$84,$42,$5c,$fd,$04,$37,$35
>92d8	00 0e 26 0c dc 11 35 07			.byte	$00,$0e,$26,$0c,$dc,$11,$35,$07
>92e0	b7 84 fe 04 4e 30 00 0a			.byte	$b7,$84,$fe,$04,$4e,$30,$00,$0a
>92e8	30 0c dc 0d bb 84 49 60			.byte	$30,$0c,$dc,$0d,$bb,$84,$49,$60
>92f0	00 4f 3a 0c dc 16 32 15			.byte	$00,$4f,$3a,$0c,$dc,$16,$32,$15
>92f8	bc 40 bf 40 be 84 40 c0			.byte	$bc,$40,$bf,$40,$be,$84,$40,$c0
>9300	dc 16 32 15 bc 40 bf 41			.byte	$dc,$16,$32,$15,$bc,$40,$bf,$41
>9308	be 84 8b 41 75 c0 dc 16			.byte	$be,$84,$8b,$41,$75,$c0,$dc,$16
>9310	32 15 bc 41 bf 40 be 84			.byte	$32,$15,$bc,$41,$bf,$40,$be,$84
>9318	40 c0 dc 16 32 15 bc 41			.byte	$40,$c0,$dc,$16,$32,$15,$bc,$41
>9320	bf 41 be 84 8b 44 5b c0			.byte	$bf,$41,$be,$84,$8b,$44,$5b,$c0
>9328	dc 16 32 15 bc 42 bf 40			.byte	$dc,$16,$32,$15,$bc,$42,$bf,$40
>9330	be 84 40 c0 dc 16 32 15			.byte	$be,$84,$40,$c0,$dc,$16,$32,$15
>9338	bc 42 bf 41 be 84 40 00			.byte	$bc,$42,$bf,$41,$be,$84,$40,$00
>9340	23 44 0c dc 11 39 16 bd			.byte	$23,$44,$0c,$dc,$11,$39,$16,$bd
>9348	40 be 84 48 50 fd 05 33			.byte	$40,$be,$84,$48,$50,$fd,$05,$33
>9350	37 35 c0 dc 11 39 16 bd			.byte	$37,$35,$c0,$dc,$11,$39,$16,$bd
>9358	41 be 84 48 59 fd 05 33			.byte	$41,$be,$84,$48,$59,$fd,$05,$33
>9360	37 35 00 3c 4e 0c dc 03			.byte	$37,$35,$00,$3c,$4e,$0c,$dc,$03
>9368	35 07 b8 40 bf 40 be 84			.byte	$35,$07,$b8,$40,$bf,$40,$be,$84
>9370	fe 02 c0 dc 03 35 07 b8			.byte	$fe,$02,$c0,$dc,$03,$35,$07,$b8
>9378	40 bf 41 be 84 fe 04 41			.byte	$40,$bf,$41,$be,$84,$fe,$04,$41
>9380	37 c0 dc 03 35 07 b8 41			.byte	$37,$c0,$dc,$03,$35,$07,$b8,$41
>9388	bf 40 be 84 fe 02 c0 dc			.byte	$bf,$40,$be,$84,$fe,$02,$c0,$dc
>9390	03 35 07 b8 41 bf 41 be			.byte	$03,$35,$07,$b8,$41,$bf,$41,$be
>9398	84 fe 05 4a 30 56 00 1e			.byte	$84,$fe,$05,$4a,$30,$56,$00,$1e
>93a0	58 0c dc 13 34 0c 09 bd			.byte	$58,$0c,$dc,$13,$34,$0c,$09,$bd
>93a8	40 be 84 47 51 fd 04 37			.byte	$40,$be,$84,$47,$51,$fd,$04,$37
>93b0	35 c0 dc 13 34 0c 09 bd			.byte	$35,$c0,$dc,$13,$34,$0c,$09,$bd
>93b8	41 be 84 40 00 28 62 0c			.byte	$41,$be,$84,$40,$00,$28,$62,$0c
>93c0	dc 15 31 04 05 bc 40 be			.byte	$dc,$15,$31,$04,$05,$bc,$40,$be
>93c8	84 40 c0 dc 15 31 04 05			.byte	$84,$40,$c0,$dc,$15,$31,$04,$05
>93d0	bc 41 be 84 8b 44 7b c0			.byte	$bc,$41,$be,$84,$8b,$44,$7b,$c0
>93d8	dc 15 31 04 05 bc 42 be			.byte	$dc,$15,$31,$04,$05,$bc,$42,$be
>93e0	84 8b 4e 56 00 73 6c 0c			.byte	$84,$8b,$4e,$56,$00,$73,$6c,$0c
>93e8	dc 01 33 0a bc 40 bf 40			.byte	$dc,$01,$33,$0a,$bc,$40,$bf,$40
>93f0	be 84 8b 42 43 c0 dc 01			.byte	$be,$84,$8b,$42,$43,$c0,$dc,$01
>93f8	33 0a bc 40 bf 41 be 84			.byte	$33,$0a,$bc,$40,$bf,$41,$be,$84
>9400	40 c0 dc 01 33 0a bc 40			.byte	$40,$c0,$dc,$01,$33,$0a,$bc,$40
>9408	bf 42 be 84 40 c0 dc 01			.byte	$bf,$42,$be,$84,$40,$c0,$dc,$01
>9410	33 0a bc 41 bf 40 be 84			.byte	$33,$0a,$bc,$41,$bf,$40,$be,$84
>9418	40 c0 dc 01 33 0a bc 41			.byte	$40,$c0,$dc,$01,$33,$0a,$bc,$41
>9420	bf 41 be 84 8b 4d 44 c0			.byte	$bf,$41,$be,$84,$8b,$4d,$44,$c0
>9428	dc 01 33 0a bc 41 bf 42			.byte	$dc,$01,$33,$0a,$bc,$41,$bf,$42
>9430	be 84 40 c0 dc 01 33 0a			.byte	$be,$84,$40,$c0,$dc,$01,$33,$0a
>9438	bc 42 bf 40 be 84 40 c0			.byte	$bc,$42,$bf,$40,$be,$84,$40,$c0
>9440	dc 01 33 0a bc 42 bf 41			.byte	$dc,$01,$33,$0a,$bc,$42,$bf,$41
>9448	be 84 40 c0 dc 01 33 0a			.byte	$be,$84,$40,$c0,$dc,$01,$33,$0a
>9450	bc 42 bf 42 be 84 40 00			.byte	$bc,$42,$bf,$42,$be,$84,$40,$00
>9458	1b 76 0c dc 0f 33 17 13			.byte	$1b,$76,$0c,$dc,$0f,$33,$17,$13
>9460	bc 40 be 84 8b 43 67 c0			.byte	$bc,$40,$be,$84,$8b,$43,$67,$c0
>9468	dc 0f 33 17 13 bc 41 be			.byte	$dc,$0f,$33,$17,$13,$bc,$41,$be
>9470	84 40 00 1d 80 0c dc 05			.byte	$84,$40,$00,$1d,$80,$0c,$dc,$05
>9478	31 09 0f ba 40 be 84 40			.byte	$31,$09,$0f,$ba,$40,$be,$84,$40
>9480	c0 dc 05 31 09 0f ba 41			.byte	$c0,$dc,$05,$31,$09,$0f,$ba,$41
>9488	be 84 43 40 fd 03 35 00			.byte	$be,$84,$43,$40,$fd,$03,$35,$00
>9490	2b 8a 0c dc 15 33 05 04			.byte	$2b,$8a,$0c,$dc,$15,$33,$05,$04
>9498	ba 40 be 84 40 c0 dc 15			.byte	$ba,$40,$be,$84,$40,$c0,$dc,$15
>94a0	33 05 04 ba 41 be 84 43			.byte	$33,$05,$04,$ba,$41,$be,$84,$43
>94a8	58 fd 06 33 31 32 35 c0			.byte	$58,$fd,$06,$33,$31,$32,$35,$c0
>94b0	dc 15 33 05 04 ba 42 be			.byte	$dc,$15,$33,$05,$04,$ba,$42,$be
>94b8	84 40 00 51 94 0c dc 01			.byte	$84,$40,$00,$51,$94,$0c,$dc,$01
>94c0	34 11 14 bc 40 bf 40 be			.byte	$34,$11,$14,$bc,$40,$bf,$40,$be
>94c8	84 40 c0 dc 01 34 11 14			.byte	$84,$40,$c0,$dc,$01,$34,$11,$14
>94d0	bc 40 bf 41 be 84 40 c0			.byte	$bc,$40,$bf,$41,$be,$84,$40,$c0
>94d8	dc 01 34 11 14 bc 41 bf			.byte	$dc,$01,$34,$11,$14,$bc,$41,$bf
>94e0	40 be 84 40 c0 dc 01 34			.byte	$40,$be,$84,$40,$c0,$dc,$01,$34
>94e8	11 14 bc 41 bf 41 be 84			.byte	$11,$14,$bc,$41,$bf,$41,$be,$84
>94f0	40 c0 dc 01 34 11 14 bc			.byte	$40,$c0,$dc,$01,$34,$11,$14,$bc
>94f8	42 bf 40 be 84 40 c0 dc			.byte	$42,$bf,$40,$be,$84,$40,$c0,$dc
>9500	01 34 11 14 bc 42 bf 41			.byte	$01,$34,$11,$14,$bc,$42,$bf,$41
>9508	be 84 40 00 2f 9e 0c dc			.byte	$be,$84,$40,$00,$2f,$9e,$0c,$dc
>9510	08 34 0f bd 40 be 84 45			.byte	$08,$34,$0f,$bd,$40,$be,$84,$45
>9518	75 fd 04 37 35 c0 dc 08			.byte	$75,$fd,$04,$37,$35,$c0,$dc,$08
>9520	34 0f bd 41 be 84 8b 48			.byte	$34,$0f,$bd,$41,$be,$84,$8b,$48
>9528	62 fd 03 30 c0 dc 08 34			.byte	$62,$fd,$03,$30,$c0,$dc,$08,$34
>9530	0f bd 42 be 84 45 41 fd			.byte	$0f,$bd,$42,$be,$84,$45,$41,$fd
>9538	03 35 00 9c a8 0c dc 16			.byte	$03,$35,$00,$9c,$a8,$0c,$dc,$16
>9540	37 01 19 0d b8 40 bf 40			.byte	$37,$01,$19,$0d,$b8,$40,$bf,$40
>9548	be 84 fe 06 4b 34 59 44			.byte	$be,$84,$fe,$06,$4b,$34,$59,$44
>9550	c0 dc 16 37 01 19 0d b8			.byte	$c0,$dc,$16,$37,$01,$19,$0d,$b8
>9558	40 bf 41 be 84 fe 02 c0			.byte	$40,$bf,$41,$be,$84,$fe,$02,$c0
>9560	dc 16 37 01 19 0d b8 40			.byte	$dc,$16,$37,$01,$19,$0d,$b8,$40
>9568	bf 42 be 84 fe 02 c0 dc			.byte	$bf,$42,$be,$84,$fe,$02,$c0,$dc
>9570	16 37 01 19 0d b8 41 bf			.byte	$16,$37,$01,$19,$0d,$b8,$41,$bf
>9578	40 be 84 fe 06 51 31 4e			.byte	$40,$be,$84,$fe,$06,$51,$31,$4e
>9580	4c c0 dc 16 37 01 19 0d			.byte	$4c,$c0,$dc,$16,$37,$01,$19,$0d
>9588	b8 41 bf 41 be 84 fe 02			.byte	$b8,$41,$bf,$41,$be,$84,$fe,$02
>9590	c0 dc 16 37 01 19 0d b8			.byte	$c0,$dc,$16,$37,$01,$19,$0d,$b8
>9598	41 bf 42 be 84 fe 07 4e			.byte	$41,$bf,$42,$be,$84,$fe,$07,$4e
>95a0	34 45 46 54 c0 dc 16 37			.byte	$34,$45,$46,$54,$c0,$dc,$16,$37
>95a8	01 19 0d b8 42 bf 40 be			.byte	$01,$19,$0d,$b8,$42,$bf,$40,$be
>95b0	84 fe 07 41 35 45 4f 49			.byte	$84,$fe,$07,$41,$35,$45,$4f,$49
>95b8	c0 dc 16 37 01 19 0d b8			.byte	$c0,$dc,$16,$37,$01,$19,$0d,$b8
>95c0	42 bf 41 be 84 fe 02 c0			.byte	$42,$bf,$41,$be,$84,$fe,$02,$c0
>95c8	dc 16 37 01 19 0d b8 42			.byte	$dc,$16,$37,$01,$19,$0d,$b8,$42
>95d0	bf 42 be 84 fe 02 00 1b			.byte	$bf,$42,$be,$84,$fe,$02,$00,$1b
>95d8	b2 0c d6 fe 14 50 61 73			.byte	$b2,$0c,$d6,$fe,$14,$50,$61,$73
>95e0	73 65 64 20 41 73 73 69			.byte	$73,$65,$64,$20,$41,$73,$73,$69
>95e8	67 6e 6d 65 6e 74 2e c0			.byte	$67,$6e,$6d,$65,$6e,$74,$2e,$c0
>95f0	c4 00 00				.byte	$c4,$00,$00

;******  Return to file: modules/hardware/mega65.asm

.a000					StartROM:
.a000	a2 ff		ldx #$ff			ldx 		#$FF 					; empty stack
.a002	9a		txs				txs
.a003	20 40 a2	jsr $a240			jsr 	IF_Reset 					; reset external interface
.a006	20 0c a0	jsr $a00c			jsr 	IFT_ClearScreen
.a009	4c 24 b1	jmp $b124		jmp BASIC_Start

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.a00c					IFT_ClearScreen:
.a00c	48		pha				pha
.a00d	da		phx				phx
.a00e	5a		phy				phy
.a00f	20 a7 a1	jsr $a1a7			jsr 	IF_Home 					; home cursor
.a012	a2 19		ldx #$19			ldx 	#IF_Height 					; this many lines.
.a014					_IFT_CS0:
.a014	a0 50		ldy #$50			ldy 	#IF_Width 					; this many chars/line
.a016					_IFT_CS1:
.a016	a9 20		lda #$20			lda 	#' '						; clear line.
.a018	20 d6 a1	jsr $a1d6			jsr 	IF_Write
.a01b	88		dey				dey
.a01c	d0 f8		bne $a016			bne 	_IFT_CS1
.a01e	20 b6 a1	jsr $a1b6			jsr 	IF_NewLine 					; next line down
.a021	ca		dex				dex
.a022	d0 f0		bne $a014			bne 	_IFT_CS0
.a024	7a		ply				ply
.a025	fa		plx				plx
.a026	68		pla				pla
.a027					IFT_HomeCursor:
.a027	48		pha				pha
.a028	20 a7 a1	jsr $a1a7			jsr 	IF_Home
.a02b	a9 00		lda #$00			lda 	#0
.a02d	8d 00 05	sta $0500			sta 	IFT_XCursor
.a030	8d 01 05	sta $0501			sta 	IFT_YCursor
.a033	68		pla				pla
.a034	60		rts				rts
.a035					IFT_UpLine:
.a035	48		pha				pha
.a036	ad 01 05	lda $0501			lda  	IFT_YCursor 				; get Y
.a039	3a		dec a				dec 	a 							; line above
.a03a	30 03		bmi $a03f			bmi 	_IFTULExit 					; too far, abort
.a03c	20 ca a0	jsr $a0ca			jsr 	IFT_SetYPos					; set to that line.
.a03f					_IFTULExit:
.a03f	68		pla				pla
.a040	60		rts				rts
.a041					IFT_PrintCharacter:
.a041	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.a043	f0 16		beq $a05b			beq 	IFT_NewLine
.a045	48		pha				pha
.a046	20 73 a0	jsr $a073			jsr 	IFT_UpperCase 				; make upper case
.a049	20 d6 a1	jsr $a1d6			jsr 	IF_Write 					; write out.
.a04c	ee 00 05	inc $0500			inc 	IFT_XCursor 				; bump x cursor
.a04f	ad 00 05	lda $0500			lda 	IFT_XCursor 				; reached RHS ?
.a052	c9 50		cmp #$50			cmp 	#IF_Width
.a054	d0 03		bne $a059			bne 	_IFT_PCNotEOL
.a056	20 5b a0	jsr $a05b			jsr 	IFT_NewLine 				; if so do new line.
.a059					_IFT_PCNotEOL:
.a059	68		pla				pla
.a05a	60		rts				rts
.a05b					IFT_NewLine:
.a05b	48		pha				pha
.a05c	20 b6 a1	jsr $a1b6			jsr 	IF_NewLine 					; new line on actual screen.
.a05f	a9 00		lda #$00			lda 	#0 							; reset x position
.a061	8d 00 05	sta $0500			sta 	IFT_XCursor
.a064	ee 01 05	inc $0501			inc 	IFT_YCursor 				; move down.
.a067	ad 01 05	lda $0501			lda 	IFT_YCursor
.a06a	c9 19		cmp #$19			cmp 	#IF_Height 					; reached bottom.
.a06c	d0 03		bne $a071			bne 	_IFT_NL_NotEOS
.a06e	20 7e a0	jsr $a07e			jsr 	IFT_Scroll 					; scroll screen up.
.a071					_IFT_NL_NotEOS:
.a071	68		pla				pla
.a072	60		rts				rts
.a073					IFT_UpperCase:
.a073	c9 61		cmp #$61			cmp 	#"a"
.a075	90 06		bcc $a07d			bcc 	_IFT_UCExit
.a077	c9 7b		cmp #$7b			cmp 	#"z"+1
.a079	b0 02		bcs $a07d			bcs 	_IFT_UCExit
.a07b	49 20		eor #$20			eor 	#$20
.a07d					_IFT_UCExit:
.a07d	60		rts				rts
.a07e					IFT_Scroll:
.a07e	48		pha				pha 								; save AXY
.a07f	da		phx				phx
.a080	5a		phy				phy
.a081	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.a083					_IFT_SLoop:
.a083	20 a3 a0	jsr $a0a3			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.a086	e8		inx				inx
.a087	e0 18		cpx #$18			cpx 	#IF_Height-1				; do whole screen
.a089	d0 f8		bne $a083			bne 	_IFT_SLoop
.a08b	a9 18		lda #$18			lda 	#IF_Height-1 				; move to X = 0,Y = A
.a08d	20 ca a0	jsr $a0ca			jsr 	IFT_SetYPos
.a090	a2 50		ldx #$50			ldx 	#IF_Width 					; blank line
.a092					_IFT_SBlank:
.a092	a9 20		lda #$20			lda 	#32
.a094	20 d6 a1	jsr $a1d6			jsr 	IF_Write
.a097	ca		dex				dex
.a098	d0 f8		bne $a092			bne 	_IFT_SBlank
.a09a	a9 18		lda #$18			lda 	#IF_Height-1 				; move to X = 0,Y = A
.a09c	20 ca a0	jsr $a0ca			jsr 	IFT_SetYPos
.a09f	7a		ply				ply
.a0a0	fa		plx				plx
.a0a1	68		pla				pla
.a0a2	60		rts				rts
.a0a3					_IFT_ScrollLine:
.a0a3	da		phx				phx
.a0a4	da		phx				phx
.a0a5	8a		txa				txa 								; copy line into buffer.
.a0a6	1a		inc a				inc 	a 							; next line down.
.a0a7	20 ca a0	jsr $a0ca			jsr 	IFT_SetYPos
.a0aa	a2 00		ldx #$00			ldx 	#0
.a0ac					_IFTScrollCopy1:
.a0ac	20 c8 a1	jsr $a1c8			jsr 	IF_Read
.a0af	9d 02 05	sta $0502,x			sta 	IFT_Buffer,x
.a0b2	e8		inx				inx
.a0b3	e0 50		cpx #$50			cpx 	#IF_Width
.a0b5	d0 f5		bne $a0ac			bne 	_IFTScrollCopy1
.a0b7	68		pla				pla
.a0b8	20 ca a0	jsr $a0ca			jsr 	IFT_SetYPos
.a0bb	a2 00		ldx #$00			ldx 	#0
.a0bd					_IFTScrollCopy2:
.a0bd	bd 02 05	lda $0502,x			lda 	IFT_Buffer,x
.a0c0	20 d6 a1	jsr $a1d6			jsr 	IF_Write
.a0c3	e8		inx				inx
.a0c4	e0 50		cpx #$50			cpx 	#IF_Width
.a0c6	d0 f5		bne $a0bd			bne 	_IFTScrollCopy2
.a0c8	fa		plx				plx
.a0c9	60		rts				rts
.a0ca					IFT_SetYPos:
.a0ca	48		pha				pha
.a0cb	da		phx				phx
.a0cc	aa		tax				tax
.a0cd	20 27 a0	jsr $a027			jsr 	IFT_HomeCursor
.a0d0	e0 00		cpx #$00			cpx 	#0
.a0d2	f0 09		beq $a0dd			beq 	_IFT_MOAExit
.a0d4					_IFT_MOALoop:
.a0d4	20 b6 a1	jsr $a1b6			jsr 	IF_NewLine
.a0d7	ee 01 05	inc $0501			inc 	IFT_YCursor
.a0da	ca		dex				dex
.a0db	d0 f7		bne $a0d4			bne		_IFT_MOALoop
.a0dd					_IFT_MOAExit:
.a0dd	fa		plx				plx
.a0de	68		pla				pla
.a0df	60		rts				rts
.a0e0					IFT_GetKeyCursor:
.a0e0	20 e8 a0	jsr $a0e8			jsr 	_IFT_FlipCursor 			; reverse current
.a0e3					_IFT_GKCWait:
.a0e3	20 f9 a1	jsr $a1f9			jsr 	IF_GetKey 					; get key
.a0e6	f0 fb		beq $a0e3			beq 	_IFT_GKCWait
.a0e8					_IFT_FlipCursor:
.a0e8	48		pha				pha 								; save
.a0e9	20 c8 a1	jsr $a1c8			jsr 	IF_Read 					; read
.a0ec	20 e1 a1	jsr $a1e1			jsr 	IF_LeftOne
.a0ef	49 80		eor #$80			eor 	#$80 						; reverse
.a0f1	20 d6 a1	jsr $a1d6			jsr 	IF_Write 					; write
.a0f4	20 e1 a1	jsr $a1e1			jsr 	IF_LeftOne
.a0f7	68		pla				pla
.a0f8	60		rts				rts
.a0f9					IFT_ReadLine:
.a0f9	48		pha				pha
.a0fa					_IFT_RLLoop:
.a0fa	20 e0 a0	jsr $a0e0			jsr 	IFT_GetKeyCursor 			; get keystroke
.a0fd	c9 0d		cmp #$0d			cmp 	#13							; return
.a0ff	f0 7d		beq $a17e			beq 	_IFT_RLExit
.a101	c9 20		cmp #$20			cmp 	#32 						; control character
.a103	90 05		bcc $a10a			bcc 	_IFT_Control
.a105	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.a108	80 f0		bra $a0fa			bra 	_IFT_RLLoop
.a10a					_IFT_Control:
.a10a	c9 01		cmp #$01			cmp 	#"A"-64
.a10c	f0 26		beq $a134			beq 	_IFT_Left
.a10e	c9 04		cmp #$04			cmp 	#"D"-64
.a110	f0 2e		beq $a140			beq 	_IFT_Right
.a112	c9 17		cmp #$17			cmp 	#"W"-64
.a114	f0 36		beq $a14c			beq 	_IFT_Up
.a116	c9 13		cmp #$13			cmp 	#"S"-64
.a118	f0 3e		beq $a158			beq 	_IFT_Down
.a11a	c9 08		cmp #$08			cmp 	#"H"-64
.a11c	f0 09		beq $a127			beq 	_IFT_Backspace
.a11e	c9 1a		cmp #$1a			cmp 	#"Z"-64
.a120	d0 d8		bne $a0fa			bne 	_IFT_RLLoop
.a122	20 0c a0	jsr $a00c			jsr 	IFT_ClearScreen				; clear CTL-Z
.a125	80 d3		bra $a0fa			bra 	_IFT_RLLoop
.a127					_IFT_Backspace:
.a127	ad 00 05	lda $0500			lda 	IFT_XCursor 				; check not start of line.
.a12a	f0 ce		beq $a0fa			beq 	_IFT_RLLoop
.a12c	20 e1 a1	jsr $a1e1			jsr 	IF_LeftOne
.a12f	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.a131	20 d6 a1	jsr $a1d6			jsr 	IF_Write
.a134					_IFT_Left:
.a134	ce 00 05	dec $0500			dec 	IFT_XCursor 				; left CTL-W
.a137	10 29		bpl $a162			bpl 	_IFT_Reposition
.a139	a9 4f		lda #$4f			lda 	#IF_Width-1
.a13b					_IFT_SetX:
.a13b	8d 00 05	sta $0500			sta 	IFT_XCursor
.a13e	80 22		bra $a162			bra 	_IFT_Reposition
.a140					_IFT_Right:
.a140	ee 00 05	inc $0500			inc 	IFT_XCursor
.a143	ad 00 05	lda $0500			lda 	IFT_XCursor
.a146	49 50		eor #$50			eor 	#IF_Width
.a148	f0 f1		beq $a13b			beq 	_IFT_SetX
.a14a	80 16		bra $a162			bra 	_IFT_Reposition
.a14c					_IFT_Up:
.a14c	ce 01 05	dec $0501			dec 	IFT_YCursor
.a14f	10 11		bpl $a162			bpl 	_IFT_Reposition
.a151	a9 18		lda #$18			lda 	#IF_Height-1
.a153					_IFT_SetY:
.a153	8d 01 05	sta $0501			sta 	IFT_YCursor
.a156	80 0a		bra $a162			bra 	_IFT_Reposition
.a158					_IFT_Down:
.a158	ee 01 05	inc $0501			inc 	IFT_YCursor
.a15b	ad 01 05	lda $0501			lda 	IFT_YCursor
.a15e	49 19		eor #$19			eor 	#IF_Height
.a160	f0 f1		beq $a153			beq 	_IFT_SetY
.a162					_IFT_Reposition:
.a162	ad 00 05	lda $0500			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.a165	48		pha				pha
.a166	ad 01 05	lda $0501			lda 	IFT_YCursor
.a169	20 ca a0	jsr $a0ca			jsr 	IFT_SetYPos
.a16c	68		pla				pla
.a16d	aa		tax				tax
.a16e	e0 00		cpx #$00			cpx 	#0
.a170	f0 88		beq $a0fa			beq 	_IFT_RLLoop
.a172					_IFT_MoveRight:
.a172	20 c8 a1	jsr $a1c8			jsr 	IF_Read
.a175	ee 00 05	inc $0500			inc 	IFT_XCursor
.a178	ca		dex				dex
.a179	d0 f7		bne $a172			bne 	_IFT_MoveRight
.a17b	4c fa a0	jmp $a0fa			jmp 	_IFT_RLLoop
.a17e					_IFT_RLExit:
.a17e	ad 01 05	lda $0501			lda 	IFT_YCursor 				; go to start of line.
.a181	20 ca a0	jsr $a0ca			jsr 	IFT_SetYPos
.a184	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.a186					_IFT_RLRead:
.a186	20 c8 a1	jsr $a1c8			jsr 	IF_Read
.a189	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.a18c	e8		inx				inx
.a18d	e0 50		cpx #$50			cpx 	#IF_Width
.a18f	d0 f5		bne $a186			bne 	_IFT_RLRead
.a191					_IFT_RL_Trim:
.a191	ca		dex				dex 	 							; previous char
.a192	30 07		bmi $a19b			bmi 	_IFT_Found 					; gone too far
.a194	bd 66 05	lda $0566,x			lda 	IFT_LineBuffer,x			; go back if space
.a197	c9 20		cmp #$20			cmp 	#" "
.a199	f0 f6		beq $a191			beq 	_IFT_RL_Trim
.a19b					_IFT_Found:
.a19b	e8		inx				inx 								; forward to non-space
.a19c	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.a19e	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.a1a1	68		pla				pla
.a1a2	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.a1a4	a0 05		ldy #$05			ldy 	#IFT_LineBuffer >> 8
.a1a6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_mega65.asm

=80					IF_Width 	= 80 							; characters across
=25					IF_Height 	= 25 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line
=6					IF_XPos 	= 6 							; current position, horizontal.
=8					IF_FarPtr 	= 8 							; far pointer (4 bytes)
=$1000					IF_Screen = $1000							; 2k screen RAM here
=$800					IF_CharSet = $800							; 2k character set (0-7F) here
.a1a7					IF_Home:
.a1a7	48		pha				pha 								; reset cursor position
.a1a8	a9 00		lda #$00			lda 	#IF_Screen & $FF
.a1aa	85 04		sta $04				sta 	IF_Pos
.a1ac	a9 10		lda #$10			lda 	#IF_Screen >> 8
.a1ae	85 05		sta $05				sta 	IF_Pos+1
.a1b0	a9 00		lda #$00			lda 	#0
.a1b2	85 06		sta $06				sta 	IF_XPos
.a1b4	68		pla				pla
.a1b5	60		rts				rts
.a1b6					IF_NewLine:
.a1b6	48		pha				pha
.a1b7	a9 00		lda #$00			lda 	#0 							; back to start of line
.a1b9	85 06		sta $06				sta 	IF_XPos
.a1bb	18		clc				clc 								; down one line
.a1bc	a5 04		lda $04				lda 	IF_Pos
.a1be	69 50		adc #$50			adc 	#80
.a1c0	85 04		sta $04				sta 	IF_Pos
.a1c2	90 02		bcc $a1c6			bcc 	_IF_NoCarry 				; carry through.
.a1c4	e6 05		inc $05				inc 	IF_Pos+1
.a1c6					_IF_NoCarry:
.a1c6	68		pla				pla
.a1c7	60		rts				rts
.a1c8					IF_Read:
.a1c8	5a		phy				phy 								; save current Y
.a1c9	a4 06		ldy $06				ldy 	IF_XPos 					; read character at current position
.a1cb	b1 04		lda ($04),y			lda 	(IF_Pos),y
.a1cd	49 20		eor #$20			eor 	#$20
.a1cf	18		clc				clc
.a1d0	69 20		adc #$20			adc 	#$20
.a1d2	e6 06		inc $06				inc 	IF_XPos 					; step right.
.a1d4	7a		ply				ply									; restore Y
.a1d5	60		rts				rts
.a1d6					IF_Write:
.a1d6	5a		phy				phy 								; save current Y
.a1d7	a4 06		ldy $06				ldy 	IF_XPos 					; write character at current position
.a1d9	29 bf		and #$bf			and 	#63+128 					; PETSCII
.a1db	91 04		sta ($04),y			sta 	(IF_Pos),y
.a1dd	e6 06		inc $06				inc 	IF_XPos 					; step right.
.a1df	7a		ply				ply									; restore Y
.a1e0	60		rts				rts
.a1e1					IF_LeftOne:
.a1e1	c6 06		dec $06				dec 	IF_XPos
.a1e3	60		rts				rts
.a1e4					IF_CheckBreak:
.a1e4	db		phz				phz
.a1e5	20 2d a2	jsr $a22d			jsr 	IF_SetupKeyAddress 			; point to keyboard
.a1e8	e6 08		inc $08				inc 	IF_FarPtr 					; point to modifiers.
.a1ea	ea		nop				nop 								; read modifiers.
.a1eb	b2 08		lda ($08),z			lda 	(IF_FarPtr),z
.a1ed	fb		plz				plz 								; restore Z
.a1ee	29 05		and #$05			and 	#5							; break is LeftShift+Ctrl
.a1f0	c9 05		cmp #$05			cmp 	#5
.a1f2	f0 02		beq $a1f6			beq 	_IF_CBExit
.a1f4	a9 00		lda #$00			lda 	#0
.a1f6					_IF_CBExit:
.a1f6	c9 00		cmp #$00			cmp 	#0
.a1f8	60		rts				rts
.a1f9					IF_GetKey:
.a1f9	db		phz				phz
.a1fa	20 2d a2	jsr $a22d			jsr 	IF_SetupKeyAddress
.a1fd	ea		nop				nop 								; read keyboard
.a1fe	b2 08		lda ($08),z			lda 	(IF_FarPtr),z
.a200	c9 14		cmp #$14			cmp 	#20
.a202	d0 02		bne $a206			bne 	_KMNo
.a204	a9 08		lda #$08			lda 	#"H"-64
.a206					_KMNo:
.a206	c9 91		cmp #$91			cmp 	#145
.a208	d0 02		bne $a20c			bne 	_KMNo
.a20a	a9 17		lda #$17			lda 	#"W"-64
.a20c					_KMNo:
.a20c	c9 11		cmp #$11			cmp 	#17
.a20e	d0 02		bne $a212			bne 	_KMNo
.a210	a9 13		lda #$13			lda 	#"S"-64
.a212					_KMNo:
.a212	c9 9d		cmp #$9d			cmp 	#157
.a214	d0 02		bne $a218			bne 	_KMNo
.a216	a9 01		lda #$01			lda 	#"A"-64
.a218					_KMNo:
.a218	c9 1d		cmp #$1d			cmp 	#29
.a21a	d0 02		bne $a21e			bne 	_KMNo
.a21c	a9 04		lda #$04			lda 	#"D"-64
.a21e					_KMNo:
.a21e	c9 00		cmp #$00			cmp 	#0
.a220	f0 07		beq $a229			beq 	_IFGKEmpty
.a222	48		pha				pha
.a223	a9 00		lda #$00			lda 	#0
.a225	ea		nop				nop
.a226	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a228	68		pla				pla
.a229					_IFGKEmpty:
.a229	fb		plz				plz
.a22a	c9 00		cmp #$00			cmp 	#0 							; set Z
.a22c	60		rts				rts
.a22d					IF_SetupKeyAddress:
.a22d	a9 0f		lda #$0f			lda 	#$0F 						; set up to write to read keyboard.
.a22f	85 0b		sta $0b				sta 	IF_FarPtr+3
.a231	a9 fd		lda #$fd			lda 	#$FD
.a233	85 0a		sta $0a				sta 	IF_FarPtr+2
.a235	a9 36		lda #$36			lda 	#$36
.a237	85 09		sta $09				sta 	IF_FarPtr+1
.a239	a9 10		lda #$10			lda 	#$10
.a23b	85 08		sta $08				sta 	IF_FarPtr+0
.a23d	a3 00		ldz #$00			ldz 	#0
.a23f	60		rts				rts
.a240					IF_Reset:
.a240	48		pha				pha 								; save registers
.a241	da		phx				phx
.a242	5a		phy				phy
.a243	a9 0f		lda #$0f			lda 	#$0F 						; set up to write to video system.
.a245	85 0b		sta $0b				sta 	IF_FarPtr+3
.a247	a9 fd		lda #$fd			lda 	#$FD
.a249	85 0a		sta $0a				sta 	IF_FarPtr+2
.a24b	a9 30		lda #$30			lda 	#$30
.a24d	85 09		sta $09				sta 	IF_FarPtr+1
.a24f	a9 00		lda #$00			lda 	#$00
.a251	85 08		sta $08				sta 	IF_FarPtr+0
.a253	a3 2f		ldz #$2f			ldz 	#$2F 						; address already set up
.a255	a9 47		lda #$47			lda 	#$47
.a257	ea		nop				nop
.a258	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a25a	a3 2f		ldz #$2f			ldz 	#$2F 						; address already set up
.a25c	a9 53		lda #$53			lda 	#$53
.a25e	ea		nop				nop
.a25f	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a261	a3 30		ldz #$30			ldz 	#$30 						; address already set up
.a263	a9 40		lda #$40			lda 	#$40
.a265	ea		nop				nop
.a266	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a268	a3 31		ldz #$31			ldz 	#$31 						; address already set up
.a26a	a9 c0		lda #$c0			lda 	#$80+$40
.a26c	ea		nop				nop
.a26d	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a26f	a3 20		ldz #$20			ldz 	#$20 						; address already set up
.a271	a9 00		lda #$00			lda 	#0
.a273	ea		nop				nop
.a274	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a276	a3 21		ldz #$21			ldz 	#$21 						; address already set up
.a278	a9 00		lda #$00			lda 	#0
.a27a	ea		nop				nop
.a27b	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a27d	a3 54		ldz #$54			ldz 	#$54 						; address already set up
.a27f	a9 40		lda #$40			lda 	#$40
.a281	ea		nop				nop
.a282	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a284	a3 01		ldz #$01			ldz 	#$01 						; address already set up
.a286	a9 ff		lda #$ff			lda 	#$FF
.a288	ea		nop				nop
.a289	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a28b	a3 00		ldz #$00			ldz 	#$00 						; address already set up
.a28d	a9 ff		lda #$ff			lda 	#$FF
.a28f	ea		nop				nop
.a290	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a292	a3 16		ldz #$16			ldz 	#$16 						; address already set up
.a294	a9 cc		lda #$cc			lda 	#$CC
.a296	ea		nop				nop
.a297	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a299	a3 18		ldz #$18			ldz 	#$18 						; address already set up
.a29b	a9 42		lda #$42			lda 	#$42
.a29d	ea		nop				nop
.a29e	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2a0	a3 11		ldz #$11			ldz 	#$11 						; address already set up
.a2a2	a9 1b		lda #$1b			lda 	#$1B
.a2a4	ea		nop				nop
.a2a5	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2a7	a9 00		lda #$00			lda 	#$00						; colour RAM at $1F800-1FFFF (2kb)
.a2a9	85 0b		sta $0b				sta 	IF_FarPtr+3
.a2ab	a9 01		lda #$01			lda 	#$01
.a2ad	85 0a		sta $0a				sta 	IF_FarPtr+2
.a2af	a9 f8		lda #$f8			lda 	#$F8
.a2b1	85 09		sta $09				sta 	IF_FarPtr+1
.a2b3	a9 00		lda #$00			lda 	#$00
.a2b5	85 08		sta $08				sta 	IF_FarPtr+0
.a2b7	a3 00		ldz #$00			ldz 	#0
.a2b9					_EXTClearColorRam:
.a2b9	a9 05		lda #$05			lda 	#5							; fill that with this colour.
.a2bb	ea		nop				nop
.a2bc	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2be	3b		dez				dez
.a2bf	d0 f8		bne $a2b9			bne 	_EXTClearColorRam
.a2c1	e6 09		inc $09				inc 	IF_FarPtr+1
.a2c3	d0 f4		bne $a2b9			bne 	_EXTClearColorRam
.a2c5	a2 00		ldx #$00			ldx 	#0 							; copy PET Font into memory.
.a2c7					_EXTCopyCBMFont:
.a2c7	bd 08 a3	lda $a308,x			lda 	IF_CBMFont,x 				; +$800 uses the lower case c/set
.a2ca	9d 00 08	sta $0800,x			sta 	IF_CharSet,x
.a2cd	49 ff		eor #$ff			eor 	#$FF
.a2cf	9d 00 0c	sta $0c00,x			sta 	IF_CharSet+$400,x
.a2d2	bd 08 a4	lda $a408,x			lda 	IF_CBMFont+$100,x
.a2d5	9d 00 09	sta $0900,x			sta 	IF_CharSet+$100,x
.a2d8	49 ff		eor #$ff			eor 	#$FF
.a2da	9d 00 0d	sta $0d00,x			sta 	IF_CharSet+$500,x
.a2dd	bd 08 a5	lda $a508,x			lda 	IF_CBMFont+$200,x
.a2e0	9d 00 0a	sta $0a00,x			sta 	IF_CharSet+$200,x
.a2e3	49 ff		eor #$ff			eor 	#$FF
.a2e5	9d 00 0e	sta $0e00,x			sta 	IF_CharSet+$600,x
.a2e8	bd 08 a6	lda $a608,x			lda 	IF_CBMFont+$300,x
.a2eb	9d 00 0b	sta $0b00,x			sta 	IF_CharSet+$300,x
.a2ee	49 ff		eor #$ff			eor 	#$FF
.a2f0	9d 00 0f	sta $0f00,x			sta 	IF_CharSet+$700,x
.a2f3	ca		dex				dex
.a2f4	d0 d1		bne $a2c7			bne 	_EXTCopyCBMFont
.a2f6	a9 3b		lda #$3b			lda 	#$3F-4  					; puts ROM back in the map (the -4)
.a2f8	85 01		sta $01				sta 	$01
.a2fa	a9 00		lda #$00			lda 	#$00						; do not map bytes 0000-7FFF
.a2fc	a2 00		ldx #$00			ldx 	#$00						; (so we use the RAM physically at $0000-$7FFF)
.a2fe	a0 00		ldy #$00			ldy 	#$00 						; 8000-FFFF offset by $200. The lower 8 bits are $00
.a300	a3 f2		ldz #$f2			ldz 	#$F2 						; so this is an actual offset of $20000. So the space at
.a302	5c		map				map
.a303	ea		nop				eom
.a304	7a		ply				ply 								; restore and exit.
.a305	fa		plx				plx
.a306	68		pla				pla
.a307	60		rts				rts
.a308					IF_CBMFont:
>a308	1c 22 4a 56 4c 20 1e 00				.binary "pet-font.bin"
>a310	18 24 42 7e 42 42 42 00 7c 22 22 3c 22 22 7c 00
>a320	1c 22 40 40 40 22 1c 00 78 24 22 22 22 24 78 00
>a330	7e 40 40 78 40 40 7e 00 7e 40 40 78 40 40 40 00
>a340	1c 22 40 4e 42 22 1c 00 42 42 42 7e 42 42 42 00
>a350	1c 08 08 08 08 08 1c 00 0e 04 04 04 04 44 38 00
>a360	42 44 48 70 48 44 42 00 40 40 40 40 40 40 7e 00
>a370	42 66 5a 5a 42 42 42 00 42 62 52 4a 46 42 42 00
>a380	18 24 42 42 42 24 18 00 7c 42 42 7c 40 40 40 00
>a390	18 24 42 42 4a 24 1a 00 7c 42 42 7c 48 44 42 00
>a3a0	3c 42 40 3c 02 42 3c 00 3e 08 08 08 08 08 08 00
>a3b0	42 42 42 42 42 42 3c 00 42 42 42 24 24 18 18 00
>a3c0	42 42 42 5a 5a 66 42 00 42 42 24 18 24 42 42 00
>a3d0	22 22 22 1c 08 08 08 00 7e 02 04 18 20 40 7e 00
>a3e0	3c 20 20 20 20 20 3c 00 00 40 20 10 08 04 02 00
>a3f0	3c 04 04 04 04 04 3c 00 00 08 1c 2a 08 08 08 08
>a400	00 00 10 20 7f 20 10 00 00 00 00 00 00 00 00 00
>a410	08 08 08 08 00 00 08 00 24 24 24 00 00 00 00 00
>a420	24 24 7e 24 7e 24 24 00 08 1e 28 1c 0a 3c 08 00
>a430	00 62 64 08 10 26 46 00 30 48 48 30 4a 44 3a 00
>a440	04 08 10 00 00 00 00 00 04 08 10 10 10 08 04 00
>a450	20 10 08 08 08 10 20 00 08 2a 1c 3e 1c 2a 08 00
>a460	00 08 08 3e 08 08 00 00 00 00 00 00 00 08 08 10
>a470	00 00 00 7e 00 00 00 00 00 00 00 00 00 18 18 00
>a480	00 02 04 08 10 20 40 00 3c 42 46 5a 62 42 3c 00
>a490	08 18 28 08 08 08 3e 00 3c 42 02 0c 30 40 7e 00
>a4a0	3c 42 02 1c 02 42 3c 00 04 0c 14 24 7e 04 04 00
>a4b0	7e 40 78 04 02 44 38 00 1c 20 40 7c 42 42 3c 00
>a4c0	7e 42 04 08 10 10 10 00 3c 42 42 3c 42 42 3c 00
>a4d0	3c 42 42 3e 02 04 38 00 00 00 08 00 00 08 00 00
>a4e0	00 00 08 00 00 08 08 10 0e 18 30 60 30 18 0e 00
>a4f0	00 00 7e 00 7e 00 00 00 70 18 0c 06 0c 18 70 00
>a500	3c 42 02 0c 10 00 10 00 00 00 00 00 ff 00 00 00
>a510	08 1c 3e 7f 7f 1c 3e 00 10 10 10 10 10 10 10 10
>a520	00 00 00 ff 00 00 00 00 00 00 ff 00 00 00 00 00
>a530	00 ff 00 00 00 00 00 00 00 00 00 00 00 ff 00 00
>a540	20 20 20 20 20 20 20 20 04 04 04 04 04 04 04 04
>a550	00 00 00 00 e0 10 08 08 08 08 08 04 03 00 00 00
>a560	08 08 08 10 e0 00 00 00 80 80 80 80 80 80 80 ff
>a570	80 40 20 10 08 04 02 01 01 02 04 08 10 20 40 80
>a580	ff 80 80 80 80 80 80 80 ff 01 01 01 01 01 01 01
>a590	00 3c 7e 7e 7e 7e 3c 00 00 00 00 00 00 00 ff 00
>a5a0	36 7f 7f 7f 3e 1c 08 00 40 40 40 40 40 40 40 40
>a5b0	00 00 00 00 03 04 08 08 81 42 24 18 18 24 42 81
>a5c0	00 3c 42 42 42 42 3c 00 08 1c 2a 77 2a 08 08 00
>a5d0	02 02 02 02 02 02 02 02 08 1c 3e 7f 3e 1c 08 00
>a5e0	08 08 08 08 ff 08 08 08 a0 50 a0 50 a0 50 a0 50
>a5f0	08 08 08 08 08 08 08 08 00 00 01 3e 54 14 14 00
>a600	ff 7f 3f 1f 0f 07 03 01 00 00 00 00 00 00 00 00
>a610	f0 f0 f0 f0 f0 f0 f0 f0 00 00 00 00 ff ff ff ff
>a620	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff
>a630	80 80 80 80 80 80 80 80 aa 55 aa 55 aa 55 aa 55
>a640	01 01 01 01 01 01 01 01 00 00 00 00 aa 55 aa 55
>a650	ff fe fc f8 f0 e0 c0 80 03 03 03 03 03 03 03 03
>a660	08 08 08 08 0f 08 08 08 00 00 00 00 0f 0f 0f 0f
>a670	08 08 08 08 0f 00 00 00 00 00 00 00 f8 08 08 08
>a680	00 00 00 00 00 00 ff ff 00 00 00 00 0f 08 08 08
>a690	08 08 08 08 ff 00 00 00 00 00 00 00 ff 08 08 08
>a6a0	08 08 08 08 f8 08 08 08 c0 c0 c0 c0 c0 c0 c0 c0
>a6b0	e0 e0 e0 e0 e0 e0 e0 e0 07 07 07 07 07 07 07 07
>a6c0	ff ff 00 00 00 00 00 00 ff ff ff 00 00 00 00 00
>a6d0	00 00 00 00 00 ff ff ff 01 01 01 01 01 01 01 ff
>a6e0	00 00 00 00 f0 f0 f0 f0 0f 0f 0f 0f 00 00 00 00
>a6f0	08 08 08 08 f8 00 00 00 f0 f0 f0 f0 00 00 00 00
>a700	f0 f0 f0 f0 0f 0f 0f 0f 1c 22 4a 56 4c 20 1e 00
>a710	18 24 42 7e 42 42 42 00 7c 22 22 3c 22 22 7c 00
>a720	1c 22 40 40 40 22 1c 00 78 24 22 22 22 24 78 00
>a730	7e 40 40 78 40 40 7e 00 7e 40 40 78 40 40 40 00
>a740	1c 22 40 4e 42 22 1c 00 42 42 42 7e 42 42 42 00
>a750	1c 08 08 08 08 08 1c 00 0e 04 04 04 04 44 38 00
>a760	42 44 48 70 48 44 42 00 40 40 40 40 40 40 7e 00
>a770	42 66 5a 5a 42 42 42 00 42 62 52 4a 46 42 42 00
>a780	18 24 42 42 42 24 18 00 7c 42 42 7c 40 40 40 00
>a790	18 24 42 42 4a 24 1a 00 7c 42 42 7c 48 44 42 00
>a7a0	3c 42 40 3c 02 42 3c 00 3e 08 08 08 08 08 08 00
>a7b0	42 42 42 42 42 42 3c 00 42 42 42 24 24 18 18 00
>a7c0	42 42 42 5a 5a 66 42 00 42 42 24 18 24 42 42 00
>a7d0	22 22 22 1c 08 08 08 00 7e 02 04 18 20 40 7e 00
>a7e0	3c 20 20 20 20 20 3c 00 00 40 20 10 08 04 02 00
>a7f0	3c 04 04 04 04 04 3c 00 00 08 1c 2a 08 08 08 08
>a800	00 00 10 20 7f 20 10 00 00 00 00 00 00 00 00 00
>a810	08 08 08 08 00 00 08 00 24 24 24 00 00 00 00 00
>a820	24 24 7e 24 7e 24 24 00 08 1e 28 1c 0a 3c 08 00
>a830	00 62 64 08 10 26 46 00 30 48 48 30 4a 44 3a 00
>a840	04 08 10 00 00 00 00 00 04 08 10 10 10 08 04 00
>a850	20 10 08 08 08 10 20 00 08 2a 1c 3e 1c 2a 08 00
>a860	00 08 08 3e 08 08 00 00 00 00 00 00 00 08 08 10
>a870	00 00 00 7e 00 00 00 00 00 00 00 00 00 18 18 00
>a880	00 02 04 08 10 20 40 00 3c 42 46 5a 62 42 3c 00
>a890	08 18 28 08 08 08 3e 00 3c 42 02 0c 30 40 7e 00
>a8a0	3c 42 02 1c 02 42 3c 00 04 0c 14 24 7e 04 04 00
>a8b0	7e 40 78 04 02 44 38 00 1c 20 40 7c 42 42 3c 00
>a8c0	7e 42 04 08 10 10 10 00 3c 42 42 3c 42 42 3c 00
>a8d0	3c 42 42 3e 02 04 38 00 00 00 08 00 00 08 00 00
>a8e0	00 00 08 00 00 08 08 10 0e 18 30 60 30 18 0e 00
>a8f0	00 00 7e 00 7e 00 00 00 70 18 0c 06 0c 18 70 00
>a900	3c 42 02 0c 10 00 10 00 00 00 00 00 ff 00 00 00
>a910	00 00 38 04 3c 44 3a 00 40 40 5c 62 42 62 5c 00
>a920	00 00 3c 42 40 42 3c 00 02 02 3a 46 42 46 3a 00
>a930	00 00 3c 42 7e 40 3c 00 0c 12 10 7c 10 10 10 00
>a940	00 00 3a 46 46 3a 02 3c 40 40 5c 62 42 42 42 00
>a950	08 00 18 08 08 08 1c 00 04 00 0c 04 04 04 44 38
>a960	40 40 44 48 50 68 44 00 18 08 08 08 08 08 1c 00
>a970	00 00 76 49 49 49 49 00 00 00 5c 62 42 42 42 00
>a980	00 00 3c 42 42 42 3c 00 00 00 5c 62 62 5c 40 40
>a990	00 00 3a 46 46 3a 02 02 00 00 5c 62 40 40 40 00
>a9a0	00 00 3e 40 3c 02 7c 00 10 10 7c 10 10 12 0c 00
>a9b0	00 00 42 42 42 46 3a 00 00 00 42 42 42 24 18 00
>a9c0	00 00 41 49 49 49 36 00 00 00 42 24 18 24 42 00
>a9d0	00 00 42 42 46 3a 02 3c 00 00 7e 04 18 20 7e 00
>a9e0	08 08 08 08 ff 08 08 08 a0 50 a0 50 a0 50 a0 50
>a9f0	08 08 08 08 08 08 08 08 cc cc 33 33 cc cc 33 33
>aa00	cc 66 33 99 cc 66 33 99 00 00 00 00 00 00 00 00
>aa10	f0 f0 f0 f0 f0 f0 f0 f0 00 00 00 00 ff ff ff ff
>aa20	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff
>aa30	80 80 80 80 80 80 80 80 aa 55 aa 55 aa 55 aa 55
>aa40	01 01 01 01 01 01 01 01 00 00 00 00 aa 55 aa 55
>aa50	99 33 66 cc 99 33 66 cc 03 03 03 03 03 03 03 03
>aa60	08 08 08 08 0f 08 08 08 00 00 00 00 0f 0f 0f 0f
>aa70	08 08 08 08 0f 00 00 00 00 00 00 00 f8 08 08 08
>aa80	00 00 00 00 00 00 ff ff 00 00 00 00 0f 08 08 08
>aa90	08 08 08 08 ff 00 00 00 00 00 00 00 ff 08 08 08
>aaa0	08 08 08 08 f8 08 08 08 c0 c0 c0 c0 c0 c0 c0 c0
>aab0	e0 e0 e0 e0 e0 e0 e0 e0 07 07 07 07 07 07 07 07
>aac0	ff ff 00 00 00 00 00 00 ff ff ff 00 00 00 00 00
>aad0	00 00 00 00 00 ff ff ff 01 02 44 48 50 60 40 00
>aae0	00 00 00 00 f0 f0 f0 f0 0f 0f 0f 0f 00 00 00 00
>aaf0	08 08 08 08 f8 00 00 00 f0 f0 f0 f0 00 00 00 00
>ab00	f0 f0 f0 f0 0f 0f 0f 0f

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.ab08					TIM_Error:
.ab08	20 35 a0	jsr $a035			jsr 	IFT_UpLine 					; go up one line.
.ab0b	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.ab0d	80 02		bra $ab11			bra 	TIM_ShowPrompt
.ab0f					TIM_NewCommand:
.ab0f	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.ab11					TIM_ShowPrompt:
.ab11	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.ab14	20 f9 a0	jsr $a0f9			jsr 	IFT_ReadLine	 			; get character, go to next line
.ab17	20 5b a0	jsr $a05b			jsr 	IFT_NewLine					; go to next line.
.ab1a	86 10		stx $10				stx 	zTemp1 						; save line read address
.ab1c	84 11		sty $11				sty 	zTemp1+1
.ab1e	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.ab20	b1 10		lda ($10),y			lda 	(zTemp1),y
.ab22	c9 3f		cmp #$3f			cmp 	#"?"
.ab24	f0 04		beq $ab2a			beq 	TIM_SkipFirst
.ab26	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.ab28	d0 01		bne $ab2b			bne 	TIM_NotDot
.ab2a					TIM_SkipFirst:
.ab2a	c8		iny				iny
.ab2b					TIM_NotDot:
.ab2b	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.ab2d	c9 52		cmp #$52			cmp 	#"R"						; show registers
.ab2f	f0 6e		beq $ab9f			beq 	TIM_ShowRegisters
.ab31	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.ab33	f0 12		beq $ab47			beq 	TIM_ShowMemory
.ab35	c9 47		cmp #$47			cmp 	#"G"						; execute
.ab37	f0 49		beq $ab82			beq 	TIM_Execute
.ab39	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.ab3b	f0 07		beq $ab44			beq 	TIM_GoLoadMemory
.ab3d	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.ab3f	d0 c7		bne $ab08			bne 	TIM_Error
.ab41	4c c4 ac	jmp $acc4			jmp 	TIM_UpdateRegisters
.ab44					TIM_GoLoadMemory:
.ab44	4c ef ac	jmp $acef			jmp 	TIM_LoadMemory
.ab47					TIM_ShowMemory:
.ab47	20 3d ac	jsr $ac3d			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.ab4a	b0 bc		bcs $ab08			bcs 	TIM_Error
.ab4c	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.ab4e	85 12		sta $12				sta 	zTemp2
.ab50	a5 15		lda $15				lda 	zTemp3+1
.ab52	85 13		sta $13				sta 	zTemp2+1
.ab54	20 3d ac	jsr $ac3d			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.ab57	90 08		bcc $ab61			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.ab59	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.ab5b	85 14		sta $14				sta 	zTemp3
.ab5d	a5 13		lda $13				lda 	zTemp2+1
.ab5f	85 15		sta $15				sta 	zTemp3+1
.ab61					_TIMSM_Start:
.ab61	20 15 ac	jsr $ac15			jsr 	TIM_WriteLine 				; write one line of hex out
.ab64	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.ab66	18		clc				clc
.ab67	69 10		adc #$10			adc 	#16
.ab69	85 12		sta $12				sta 	zTemp2
.ab6b	90 02		bcc $ab6f			bcc 	_TIMSM_NoCarry
.ab6d	e6 13		inc $13				inc 	zTemp2+1
.ab6f					_TIMSM_NoCarry:
.ab6f	20 e4 a1	jsr $a1e4			jsr 	IF_CheckBreak 				; check CTL+C
.ab72	d0 0b		bne $ab7f			bne 	_TIMSM_Ends 				; if pressed break out.
.ab74	38		sec				sec 								; check past the end address in zTemp3
.ab75	a5 14		lda $14				lda 	zTemp3
.ab77	e5 12		sbc $12				sbc 	zTemp2
.ab79	a5 15		lda $15				lda 	zTemp3+1
.ab7b	e5 13		sbc $13				sbc 	zTemp2+1
.ab7d	10 e2		bpl $ab61			bpl 	_TIMSM_Start
.ab7f					_TIMSM_Ends:
.ab7f	4c 0f ab	jmp $ab0f			jmp 	TIM_NewCommand
.ab82					TIM_Execute:
.ab82	20 3d ac	jsr $ac3d			jsr 	TIM_GetHex 					; get the execute address
.ab85	b0 81		bcs $ab08			bcs 	TIM_Error 					; not legitimate
.ab87	ae cd 03	ldx $03cd			ldx 	TIM_SP 						; set up SP
.ab8a	9a		txs				txs
.ab8b	ad c8 03	lda $03c8			lda 	TIM_SR 						; Status for PLP
.ab8e	48		pha				pha
.ab8f	ad c9 03	lda $03c9			lda 	TIM_A 						; restore AXYZ
.ab92	ae ca 03	ldx $03ca			ldx 	TIM_X
.ab95	ac cb 03	ldy $03cb			ldy 	TIM_Y
.ab98	ab cc 03	ldz $03cc			ldz 	TIM_Z
.ab9b	28		plp				plp 								; and PS Byte.
.ab9c	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.ab9f					TIM_Start:
.ab9f					TIM_ShowRegisters:
.ab9f	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.aba2	8d c7 03	sta $03c7			sta 	TIM_IRQ+1
.aba5	ad ff ff	lda $ffff			lda 	$FFFF
.aba8	8d c6 03	sta $03c6			sta 	TIM_IRQ
.abab	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.abad					_TIMSR_Text:
.abad	bd d9 ab	lda $abd9,x			lda 	_TIMSR_Label,x
.abb0	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.abb3	e8		inx				inx
.abb4	e0 23		cpx #$23			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.abb6	d0 f5		bne $abad			bne 	_TIMSR_Text
.abb8	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.abba					_TIMSR_Skip:
.abba	e8		inx				inx
.abbb					_TIMSR_LoopSpace:
.abbb	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.abbd	b0 04		bcs $abc3			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.abbf	8a		txa				txa
.abc0	4a		lsr a				lsr 	a
.abc1	b0 05		bcs $abc8			bcs 	_TIMSR_NoSpace
.abc3					_TIMSR_Space:
.abc3	a9 20		lda #$20			lda 	#" "
.abc5	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.abc8					_TIMSR_NoSpace:
.abc8	bd c4 03	lda $03c4,x			lda 	TIM_PC,x 					; output hex value.
.abcb	20 fc ab	jsr $abfc			jsr 	TIM_WriteHex
.abce	e8		inx				inx
.abcf	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.abd1	d0 e8		bne $abbb			bne 	_TimSR_LoopSpace
.abd3	20 5b a0	jsr $a05b			jsr 	IFT_NewLine 				; new line
.abd6	4c 0f ab	jmp $ab0f			jmp	 	TIM_NewCommand 				; new command.
.abd9					_TIMSR_Label:
>abd9	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>abe1	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>abf1	52
>abf2	20 5a 52					.text 	" ZR"
>abf5	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.abfc					_TIMSR_LabelEnd:
.abfc					TIM_WriteHex:
.abfc	48		pha				pha 								; save A
.abfd	4a		lsr a				lsr 	a 							; shift MSB->LSB
.abfe	4a		lsr a				lsr 	a
.abff	4a		lsr a				lsr 	a
.ac00	4a		lsr a				lsr 	a
.ac01	20 05 ac	jsr $ac05			jsr 	_TIMWH_Nibble 				; print MSB
.ac04	68		pla				pla 								; restore and print LSB
.ac05					_TIMWH_Nibble:
.ac05	48		pha				pha
.ac06	29 0f		and #$0f			and 	#15 						; mask out
.ac08	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.ac0a	90 02		bcc $ac0e			bcc 	_TIMWHNoLetter
.ac0c	69 06		adc #$06			adc 	#6
.ac0e					_TIMWHNoLetter:
.ac0e	69 30		adc #$30			adc 	#48
.ac10	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter 			; print it out.
.ac13	68		pla				pla
.ac14	60		rts				rts
.ac15					TIM_WriteLine:
.ac15	a9 2e		lda #$2e			lda 	#"." 						; prompt
.ac17	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.ac1a	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.ac1c	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.ac1f	a5 13		lda $13				lda 	zTemp2+1 					; write address
.ac21	20 fc ab	jsr $abfc			jsr 	TIM_WriteHex
.ac24	a5 12		lda $12				lda 	zTemp2
.ac26	20 fc ab	jsr $abfc			jsr 	TIM_WriteHex
.ac29	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.ac2b					_TIMWL_Loop:
.ac2b	a9 20		lda #$20			lda 	#" "
.ac2d	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.ac30	b1 12		lda ($12),y			lda 	(zTemp2),y
.ac32	20 fc ab	jsr $abfc			jsr 	TIM_WriteHex
.ac35	c8		iny				iny
.ac36	c0 10		cpy #$10			cpy 	#16
.ac38	d0 f1		bne $ac2b			bne 	_TIMWL_Loop
.ac3a	4c 5b a0	jmp $a05b			jmp 	IFT_NewLine 				; new line and exit
.ac3d					TIM_GetHex:
.ac3d	c8		iny				iny
.ac3e	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.ac40	c9 20		cmp #$20			cmp 	#32
.ac42	f0 f9		beq $ac3d			beq 	TIM_GetHex
.ac44	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.ac46	f0 f5		beq $ac3d			beq 	TIM_GetHex
.ac48	20 71 ac	jsr $ac71			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.ac4b	b0 23		bcs $ac70			bcs 	_TIMGH_Exit					; if first bad then exit now.
.ac4d	a9 00		lda #$00			lda 	#0 							; zero result
.ac4f	85 14		sta $14				sta 	zTemp3
.ac51	85 15		sta $15				sta 	zTemp3+1
.ac53					_TIM_GHLoop:
.ac53	20 71 ac	jsr $ac71			jsr 	TIM_GetHexCharacter 		; get next character
.ac56	b0 17		bcs $ac6f			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.ac58	c8		iny				iny 								; skip over it.
.ac59	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.ac5b	26 15		rol $15				rol 	zTemp3+1
.ac5d	06 14		asl $14				asl 	zTemp3 						; now x 2
.ac5f	26 15		rol $15				rol 	zTemp3+1
.ac61	06 14		asl $14				asl 	zTemp3						; now x 4
.ac63	26 15		rol $15				rol 	zTemp3+1
.ac65	06 14		asl $14				asl 	zTemp3 						; now x 8
.ac67	26 15		rol $15				rol 	zTemp3+1
.ac69	05 14		ora $14				ora 	zTemp3 						; OR result in
.ac6b	85 14		sta $14				sta 	zTemp3
.ac6d	80 e4		bra $ac53			bra 	_TIM_GHLoop 				; loop round again.
.ac6f					_TIMGH_Okay:
.ac6f	18		clc				clc
.ac70					_TIMGH_Exit:
.ac70	60		rts				rts
.ac71					TIM_GetHexCharacter:
.ac71	b1 10		lda ($10),y			lda 	(zTemp1),y
.ac73	38		sec				sec
.ac74	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.ac76	90 0e		bcc $ac86			bcc 	_TIM_GHCFail
.ac78	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.ac7a	90 0b		bcc $ac87			bcc 	_TIM_GHCExit
.ac7c	c9 11		cmp #$11			cmp 	#65-48						; < A
.ac7e	90 06		bcc $ac86			bcc		_TIM_GHCFail
.ac80	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.ac82	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.ac84	90 01		bcc $ac87			bcc		_TIM_GHCExit
.ac86					_TIM_GHCFail:
.ac86	38		sec				sec
.ac87					_TIM_GHCExit:
.ac87	60		rts				rts
.ac88					TIM_BreakVector:
.ac88	da		phx				phx									; save X/A on stack
.ac89	48		pha				pha
.ac8a	ba		tsx				tsx 								; X points to S
.ac8b	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.ac8e	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.ac90	d0 03		bne $ac95			bne 	_TIMBreak					; if set, it's BRK
.ac92	68		pla				pla 								; abandon routine.
.ac93	fa		plx				plx
.ac94	40		rti				rti
.ac95					_TIMBreak:
.ac95	68		pla				pla 								; save A X Y and maybe Z
.ac96	8d c9 03	sta $03c9			sta 	TIM_A
.ac99	fa		plx				plx
.ac9a	8e ca 03	stx $03ca			stx 	TIM_X
.ac9d	8c cb 03	sty $03cb			sty 	TIM_Y
.aca0	9c cc 03	stz $03cc			stz 	TIM_Z
.aca3	68		pla				pla 								; get Status Register
.aca4	8d c8 03	sta $03c8			sta 	TIM_SR
.aca7	68		pla				pla
.aca8	8d c5 03	sta $03c5			sta 	TIM_PC+1 					; save calling address
.acab	68		pla				pla
.acac	8d c4 03	sta $03c4			sta 	TIM_PC 						; high byte
.acaf	ad c5 03	lda $03c5			lda 	TIM_PC+1 					; dec PC to point right.
.acb2	d0 03		bne $acb7			bne 	_TIMDecrement 				; brk bumps it.
.acb4	ce c4 03	dec $03c4			dec 	TIM_PC
.acb7					_TIMDecrement:
.acb7	ce c5 03	dec $03c5			dec 	TIM_PC+1
.acba	ba		tsx				tsx 								; and copy SP
.acbb	8e cd 03	stx $03cd			stx 	TIM_SP
.acbe	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.acc0	9a		txs				txs
.acc1	4c 9f ab	jmp $ab9f			jmp 	TIM_Start 					; and start up TIM monitor.
.acc4					TIM_UpdateRegisters:
.acc4	20 3d ac	jsr $ac3d			jsr 	TIM_GetHex 					; PC
.acc7	b0 23		bcs $acec			bcs 	_TIMURFail
.acc9	a5 14		lda $14				lda 	zTemp3
.accb	8d c5 03	sta $03c5			sta 	Tim_PC+1
.acce	a5 15		lda $15				lda 	zTemp3+1
.acd0	8d c4 03	sta $03c4			sta 	Tim_PC
.acd3	20 3d ac	jsr $ac3d			jsr 	TIM_GetHex 					; ignore IRQ
.acd6	b0 14		bcs $acec			bcs 	_TIMURFail
.acd8	a2 00		ldx #$00			ldx 	#0
.acda					_TIM_URLoop:
.acda	20 3d ac	jsr $ac3d			jsr 	TIM_GetHex 					; registers
.acdd	b0 0d		bcs $acec			bcs 	_TIMURFail
.acdf	a5 14		lda $14				lda 	zTemp3
.ace1	9d c8 03	sta $03c8,x			sta 	Tim_SR,x
.ace4	e8		inx				inx
.ace5	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.ace7	d0 f1		bne $acda			bne 	_TIM_URLoop
.ace9	4c 0f ab	jmp $ab0f			jmp 	TIM_NewCommand
.acec					_TIMURFail:
.acec	4c 08 ab	jmp $ab08			jmp 	TIM_Error
.acef					TIM_LoadMemory:
.acef	20 3d ac	jsr $ac3d			jsr 	TIM_GetHex 					; target address => zTemp2
.acf2	a5 14		lda $14				lda 	zTemp3
.acf4	85 12		sta $12				sta 	zTemp2
.acf6	a5 15		lda $15				lda 	zTemp3+1
.acf8	85 13		sta $13				sta 	zTemp2+1
.acfa					_TIM_LMLoop:
.acfa	20 3d ac	jsr $ac3d			jsr 	TIM_GetHex 					; next byte ?
.acfd	b0 0e		bcs $ad0d			bcs 	_TIMLMDone 					; no more
.acff	a2 00		ldx #$00			ldx 	#0							; write out.
.ad01	a5 14		lda $14				lda 	zTemp3
.ad03	81 12		sta ($12,x)			sta 	(zTemp2,x)
.ad05	e6 12		inc $12				inc 	zTemp2 						; bump address
.ad07	d0 f1		bne $acfa			bne 	_TIM_LMLoop
.ad09	e6 13		inc $13				inc 	zTemp2+1
.ad0b	80 ed		bra $acfa			bra 	_TIM_LMLoop
.ad0d					_TIMLMDone:
.ad0d	4c 0f ab	jmp $ab0f			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/skip.asm

.ad10					StructureSearchSingle:
.ad10	a2 00		ldx #$00			ldx 	#0
.ad12					StructureSearchDouble:
.ad12	85 10		sta $10				sta 	zTemp1 						; save the target on zTemp1,zTemp1+1
.ad14	86 11		stx $11				stx 	zTemp1+1
.ad16	a9 00		lda #$00			lda 	#0 							; set the structure depth to zero (zTemp2)
.ad18	85 12		sta $12				sta 	zTemp2
.ad1a	80 1a		bra $ad36			bra 	_SSWLoop 					; jump in, start scanning from here.
.ad1c					_SSWNextLine:
.ad1c	a3 00		ldz #$00			ldz 	#0 							; point to offset
.ad1e	ea		nop				nop
.ad1f	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read it
.ad21	18		clc				clc
.ad22	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.ad24	85 16		sta $16				sta 	zCodePtr
.ad26	90 02		bcc $ad2a			bcc 	_SNLNoCarry
.ad28	e6 17		inc $17				inc 	zCodePtr+1
.ad2a					_SNLNoCarry:
.ad2a	a3 00		ldz #$00			ldz 	#0
.ad2c	ea		nop				nop
.ad2d	b2 16		lda ($16),z			lda 	(zCodePtr),z
.ad2f	c9 00		cmp #$00			cmp 	#0					 		; if zero, fail.
.ad31	f0 57		beq $ad8a			beq 	_SSWFail
.ad33	1b		inz				inz
.ad34	1b		inz				inz
.ad35					_SSWNextSimple:
.ad35	1b		inz				inz
.ad36					_SSWLoop:
.ad36	ea		nop				nop
.ad37	b2 16		lda ($16),z			lda 	(zCodePtr),z
.ad39	c9 00		cmp #$00			cmp 	#0 							; end of line ?
.ad3b	f0 df		beq $ad1c			beq 	_SSWNextLine 				; if so, then next line
.ad3d	10 f6		bpl $ad35			bpl 	_SSWNextSimple 				; needs to be a token, just skip char/number.
.ad3f	a6 12		ldx $12				ldx 	zTemp2 						; check structure count
.ad41	d0 08		bne $ad4b			bne 	_SSWCheckUpDown 			; if it's non zero, then a match doesn't work.
.ad43	c5 10		cmp $10				cmp 	zTemp1 						; found the right keyword, either choice.
.ad45	f0 2f		beq $ad76			beq 	_SSWFound 					; so exit.
.ad47	c5 11		cmp $11				cmp 	zTemp1+1
.ad49	f0 2b		beq $ad76			beq 	_SSWFound
.ad4b					_SSWCheckUpDown:
.ad4b	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus 			; if < keyword +
.ad4d	90 10		bcc $ad5f			bcc 	_SSWNext
.ad4f	c9 93		cmp #$93			cmp 	#firstKeywordMinus 			; if < keyword - then as keyword +
.ad51	90 08		bcc $ad5b			bcc 	_SSWPlus
.ad53	c9 98		cmp #$98			cmp 	#firstUnaryFunction			; if < first unary down as keyword -
.ad55	b0 08		bcs $ad5f			bcs 	_SSWNext
.ad57	c6 12		dec $12				dec 	zTemp2 						; reduce structure count.
.ad59	c6 12		dec $12				dec 	zTemp2
.ad5b					_SSWPlus:
.ad5b	e6 12		inc $12				inc 	zTemp2
.ad5d	30 18		bmi $ad77			bmi 	_SSWUnder					; error if driven -ve
.ad5f					_SSWNext:
.ad5f	ea		nop				nop
.ad60	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read element
.ad62	1b		inz				inz 								; skip
.ad63	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.ad65	90 0d		bcc $ad74			bcc 	_SEDone 					; so just skip over it.
.ad67	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.ad69	90 08		bcc $ad73			bcc 	_SEDouble
.ad6b	6b		tza				tza 								; this is Y + 1
.ad6c	18		clc				clc
.ad6d	ea		nop				nop
.ad6e	72 16		adc ($16),z			adc 	(zCodePtr),z 				; add total length of element
.ad70	4b		taz				taz 								; back in Y.
.ad71	3b		dez				dez 								; fix up, one for the +1, one for the iny
.ad72	3b		dez				dez
.ad73					_SEDouble:
.ad73	1b		inz				inz
.ad74					_SEDone:
.ad74	80 c0		bra $ad36			bra 	_SSWLoop
.ad76					_SSWFound:
.ad76	60		rts				rts
.ad77					_SSWUnder:
.ad77	20 9e ae	jsr $ae9e			jsr ERR_Handler
>ad7a	53 74 72 75 63 74 75 72			.text "Structure order",0
>ad82	65 20 6f 72 64 65 72 00
.ad8a					_SSWFail:
.ad8a	20 9e ae	jsr $ae9e			jsr ERR_Handler
>ad8d	43 61 6e 27 74 20 66 69			.text "Can't find structure",0
>ad95	6e 64 20 73 74 72 75 63 74 75 72 65 00
.ada2					SkipEndOfCommand:
.ada2	ea		nop				nop
.ada3	b2 16		lda ($16),z			lda 	(zCodePtr),z
.ada5	c9 00		cmp #$00			cmp 	#0 							; if zero, end of line, so exit
.ada7	f0 1b		beq $adc4			beq 	_SOCExit
.ada9	c9 c0		cmp #$c0			cmp 	#token_Colon 				; if colon, end of command
.adab	f0 17		beq $adc4			beq 	_SOCExit
.adad	ea		nop				nop
.adae	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read element
.adb0	1b		inz				inz 								; skip
.adb1	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.adb3	90 0d		bcc $adc2			bcc 	_SEDone 					; so just skip over it.
.adb5	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.adb7	90 08		bcc $adc1			bcc 	_SEDouble
.adb9	6b		tza				tza 								; this is Y + 1
.adba	18		clc				clc
.adbb	ea		nop				nop
.adbc	72 16		adc ($16),z			adc 	(zCodePtr),z 				; add total length of element
.adbe	4b		taz				taz 								; back in Y.
.adbf	3b		dez				dez 								; fix up, one for the +1, one for the iny
.adc0	3b		dez				dez
.adc1					_SEDouble:
.adc1	1b		inz				inz
.adc2					_SEDone:
.adc2	80 de		bra $ada2			bra 	SkipEndOfCommand
.adc4					_SOCExit:
.adc4	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stack.asm

.adc5					StackReset:
.adc5	48		pha				pha
.adc6	5a		phy				phy
.adc7	a9 00		lda #$00			lda 	#(BasicStack & $FF) 		; reset pointer
.adc9	85 26		sta $26				sta 	zBasicSP
.adcb	a9 04		lda #$04			lda 	#(BasicStack >> 8)
.adcd	85 27		sta $27				sta 	zBasicSP+1
.adcf	a0 00		ldy #$00			ldy 	#0 							; reset stack top to $00 which cannot
.add1	98		tya				tya 								; be a legal token.
.add2	91 26		sta ($26),y			sta 	(zBasicSP),y
.add4	7a		ply				ply
.add5	68		pla				pla
.add6	60		rts				rts
.add7					StackPushFrame:
.add7	48		pha				pha
.add8	5a		phy				phy
.add9	1a		inc a				inc 	a 							; one extra byte in frame, for the marker.
.adda	48		pha				pha 								; save it.
.addb	29 0f		and #$0f			and 	#$0F 						; lower 4 bits
.addd	18		clc				clc 								; add to Basic Stack
.adde	65 26		adc $26				adc 	zBasicSP
.ade0	85 26		sta $26				sta 	zBasicSP
.ade2	90 02		bcc $ade6			bcc 	_SPFNoBump
.ade4	e6 27		inc $27				inc 	zBasicSP+1
.ade6					_SPFNoBump:
.ade6	a0 00		ldy #$00			ldy 	#0
.ade8	68		pla				pla
.ade9	91 26		sta ($26),y			sta 	(zBasicSP),y
.adeb	7a		ply				ply
.adec	68		pla				pla
.aded	60		rts				rts
.adee					StackPopFrame:
.adee	48		pha				pha
.adef	5a		phy				phy
.adf0	a0 00		ldy #$00			ldy 	#0 							; compare with top of stack using EOR
.adf2	51 26		eor ($26),y			eor 	(zBasicSP),y
.adf4	29 f0		and #$f0			and 	#$F0 						; top 4 bits zero, match
.adf6	d0 12		bne $ae0a			bne 	SPFError 					; mixed structures
.adf8	b1 26		lda ($26),y			lda 	(zBasicSP),y 				; get size from byte
.adfa	29 0f		and #$0f			and 	#$0F
.adfc	49 ff		eor #$ff			eor 	#$FF						; 2's complement
.adfe	38		sec				sec
.adff	65 26		adc $26				adc 	zBasicSP
.ae01	85 26		sta $26				sta 	zBasicSP
.ae03	b0 02		bcs $ae07			bcs 	_SPFNoBump
.ae05	c6 27		dec $27				dec 	zBasicSP+1
.ae07					_SPFNoBump:
.ae07	7a		ply				ply
.ae08	68		pla				pla
.ae09	60		rts				rts
.ae0a					SPFError:
.ae0a	20 9e ae	jsr $ae9e			jsr ERR_Handler
>ae0d	4d 69 78 65 64 20 53 74			.text "Mixed Structures",0
>ae15	72 75 63 74 75 72 65 73 00
.ae1e					StackSavePosition:
.ae1e	6b		tza				tza
.ae1f	5a		phy				phy
.ae20	a0 05		ldy #$05			ldy 	#5
.ae22	91 26		sta ($26),y			sta 	(zBasicSP),y
.ae24	a0 01		ldy #$01			ldy 	#1
.ae26	a5 16		lda $16				lda 	zCodePtr+0 					; 4 bytes, could reduce this for 65816/6502
.ae28	91 26		sta ($26),y			sta 	(zBasicSP),y
.ae2a	c8		iny				iny
.ae2b	a5 17		lda $17				lda 	zCodePtr+1
.ae2d	91 26		sta ($26),y			sta 	(zBasicSP),y
.ae2f	c8		iny				iny
.ae30	a5 18		lda $18				lda 	zCodePtr+2
.ae32	91 26		sta ($26),y			sta 	(zBasicSP),y
.ae34	c8		iny				iny
.ae35	a5 19		lda $19				lda 	zCodePtr+3
.ae37	91 26		sta ($26),y			sta 	(zBasicSP),y
.ae39	7a		ply				ply
.ae3a	60		rts				rts
.ae3b					StackRestorePosition:
.ae3b	5a		phy				phy
.ae3c	a0 01		ldy #$01			ldy 	#1 							; copy 4 bytes that are the pointer
.ae3e	b1 26		lda ($26),y			lda 	(zBasicSP),y
.ae40	85 16		sta $16				sta 	zCodePtr+0
.ae42	c8		iny				iny
.ae43	b1 26		lda ($26),y			lda 	(zBasicSP),y
.ae45	85 17		sta $17				sta 	zCodePtr+1
.ae47	c8		iny				iny
.ae48	b1 26		lda ($26),y			lda 	(zBasicSP),y
.ae4a	85 18		sta $18				sta 	zCodePtr+2
.ae4c	c8		iny				iny
.ae4d	b1 26		lda ($26),y			lda 	(zBasicSP),y
.ae4f	85 19		sta $19				sta 	zCodePtr+3
.ae51	c8		iny				iny
.ae52	b1 26		lda ($26),y			lda 	(zBasicSP),y 				; offset
.ae54	7a		ply				ply 								; restore Y
.ae55	4b		taz				taz
.ae56	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/vectors.asm

.ae57					VIOCharPrint:
.ae57	4c 41 a0	jmp $a041			jmp 	IFT_PrintCharacter
.ae5a					VIOCharGet:
.ae5a	20 f9 a1	jsr $a1f9			jsr 	IF_GetKey
.ae5d	c9 00		cmp #$00			cmp 	#0
.ae5f	f0 02		beq $ae63			beq 	_VCG0
.ae61	38		sec				sec
.ae62	60		rts				rts
.ae63	18		clc		_VCG0:	clc
.ae64	60		rts				rts
.ae65					VIOCheckBreak:
.ae65	4c e4 a1	jmp $a1e4			jmp 	IF_CheckBreak
.ae68					VIOCharGetPosition:
.ae68	ad 00 05	lda $0500			lda 	IFT_XCursor
.ae6b	60		rts				rts
.ae6c					VIOReadLine:
.ae6c	4c f9 a0	jmp $a0f9			jmp 	IFT_ReadLine

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/errors.asm

.ae6f					SyntaxError:
.ae6f	20 9e ae	jsr $ae9e			jsr 	ERR_Handler
>ae72	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>ae7a	72 72 6f 72 00
.ae7f					TypeError:
.ae7f	20 9e ae	jsr $ae9e			jsr 	ERR_Handler
>ae82	57 72 6f 6e 67 20 74 79				.text 	"Wrong type",0
>ae8a	70 65 00
.ae8d					BadParamError:
.ae8d	20 9e ae	jsr $ae9e			jsr 	ERR_Handler
>ae90	42 61 64 20 50 61 72 61				.text 	"Bad Parameter",0
>ae98	6d 65 74 65 72 00
.ae9e					ERR_Handler:
.ae9e	a3 00		ldz #$00			ldz 	#0
.aea0	1b		inz				inz
.aea1	ea		nop				nop
.aea2	b2 16		lda ($16),z			lda 	(zCodePtr),z
.aea4	85 80		sta $80				sta 	XS_Mantissa
.aea6	1b		inz				inz
.aea7	ea		nop				nop
.aea8	b2 16		lda ($16),z			lda 	(zCodePtr),z
.aeaa	85 81		sta $81				sta 	XS_Mantissa+1
.aeac	fa		plx				plx 								; address in XY
.aead	7a		ply				ply
.aeae	e8		inx				inx 								; bump, because of RTS/JSR address -1
.aeaf	d0 01		bne $aeb2			bne 	_EHNoSkip
.aeb1	c8		iny				iny
.aeb2					_EHNoSkip:
.aeb2	20 d1 ae	jsr $aed1			jsr 	PrintROMMessage 			; print message from ROM.
.aeb5	a5 80		lda $80				lda 	XS_Mantissa					; line number = 0
.aeb7	05 81		ora $81				ora 	XS_Mantissa+1
.aeb9	f0 0c		beq $aec7			beq 	_EHNoLine
.aebb	a2 cc		ldx #$cc			ldx 	#_EHAt & $FF 				; print " at "
.aebd	a0 ae		ldy #$ae			ldy 	#(_EHAt >> 8) & $FF
.aebf	20 d1 ae	jsr $aed1			jsr 	PrintROMMessage
.aec2	a2 00		ldx #$00			ldx 	#0 							; Print line number
.aec4	20 e2 ae	jsr $aee2			jsr 	Print16BitInteger
.aec7					_EHNoLine:
.aec7	80 fe		bra $aec7			bra 	_EHNoLine
.aec9	4c 4d b1	jmp $b14d			jmp 	WarmStart 					; normally warm start.
>aecc	20 61 74 20 00			_EHAt:	.text 	" at ",0
.aed1					PrintROMMessage:
.aed1	86 1a		stx $1a				stx 	zLTemp1 					; save addres
.aed3	84 1b		sty $1b				sty 	zLTemp1+1
.aed5	a0 00		ldy #$00			ldy 	#0
.aed7					_PRMLoop:
.aed7	b1 1a		lda ($1a),y			lda 	(zLTemp1),y 				; 6502/4510
.aed9	f0 06		beq $aee1			beq		_PRMExit 					; character $00 => exit
.aedb	c8		iny				iny  								; bump Y and print it.
.aedc	20 57 ae	jsr $ae57			jsr 	VIOCharPrint
.aedf	80 f6		bra $aed7			bra 	_PRMLoop
.aee1					_PRMExit:
.aee1	60		rts				rts
.aee2					Print16BitInteger:
.aee2	a9 00		lda #$00			lda 	#0 							; make 32 bit
.aee4	85 82		sta $82				sta 	XS_Mantissa+2
.aee6	85 83		sta $83				sta 	XS_Mantissa+3
.aee8					Print32BitInteger:
.aee8	a9 00		lda #$00			lda 	#0
.aeea	8d 14 03	sta $0314			sta 	NumBufX 					; reset the conversion pointer
.aeed	aa		tax				tax 								; convert bottom level.
.aeee	20 27 c8	jsr $c827			jsr 	INTToString 				; make string from integer in Num_Buffer
.aef1	a2 00		ldx #$00			ldx 	#0 							; print buffer contents
.aef3	bd 15 03	lda $0315,x	_P1Loop:lda 	Num_Buffer,x
.aef6	f0 06		beq $aefe			beq 	_P1Exit
.aef8	20 57 ae	jsr $ae57			jsr 	VIOCharPrint
.aefb	e8		inx				inx
.aefc	80 f5		bra $aef3			bra 	_P1Loop
.aefe	8a		txa		_P1Exit:txa 								; return chars printed.
.aeff	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm


;******  Processing file: modules/basic/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b6					lastUnaryFunction = $b6
.af00					VectorTable:
>af00	55 bc					.word BinaryOp_And         & $FFFF ; $80 and
>af02	71 bc					.word BinaryOp_Or          & $FFFF ; $81 or
>af04	8d bc					.word BinaryOp_Xor         & $FFFF ; $82 xor
>af06	8d bc					.word BinaryOp_Eor         & $FFFF ; $83 eor
>af08	c4 bc					.word Binary_Equal         & $FFFF ; $84 =
>af0a	cd bc					.word Binary_NotEqual      & $FFFF ; $85 <>
>af0c	d6 bc					.word Binary_Less          & $FFFF ; $86 <
>af0e	df bc					.word Binary_LessEqual     & $FFFF ; $87 <=
>af10	f1 bc					.word Binary_Greater       & $FFFF ; $88 >
>af12	e8 bc					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>af14	89 bd					.word BinaryOp_Add         & $FFFF ; $8a +
>af16	a5 bd					.word BinaryOp_Subtract    & $FFFF ; $8b -
>af18	b6 bd					.word BinaryOp_Multiply    & $FFFF ; $8c *
>af1a	c7 bd					.word BinaryOp_Divide      & $FFFF ; $8d /
>af1c	be af					.word NotImplemented       & $FFFF ; $8e ^
>af1e	b5 b5					.word Command_IF           & $FFFF ; $8f if
>af20	4a ba					.word Command_WHILE        & $FFFF ; $90 while
>af22	72 ba					.word Command_REPEAT       & $FFFF ; $91 repeat
>af24	af b2					.word Command_FOR          & $FFFF ; $92 for
>af26	be af					.word NotImplemented       & $FFFF ; $93 then
>af28	18 b6					.word Command_ENDIF        & $FFFF ; $94 endif
>af2a	67 ba					.word Command_WEND         & $FFFF ; $95 wend
>af2c	7b ba					.word Command_UNTIL        & $FFFF ; $96 until
>af2e	2d b3					.word Command_NEXT         & $FFFF ; $97 next
>af30	be af					.word NotImplemented       & $FFFF ; $98 not
>af32	be af					.word NotImplemented       & $FFFF ; $99 fn(
>af34	cc be					.word Unary_Abs            & $FFFF ; $9a abs(
>af36	20 c0					.word Unary_Asc            & $FFFF ; $9b asc(
>af38	4f cf					.word Unary_Int            & $FFFF ; $9c int(
>af3a	e6 be					.word Unary_Peek           & $FFFF ; $9d peek(
>af3c	d0 ce					.word Unary_Rnd            & $FFFF ; $9e rnd(
>af3e	59 bf					.word Unary_Usr            & $FFFF ; $9f usr(
>af40	5f c0					.word Unary_Left           & $FFFF ; $a0 left$(
>af42	74 c0					.word Unary_Right          & $FFFF ; $a1 right$(
>af44	46 c0					.word Unary_Mid            & $FFFF ; $a2 mid$(
>af46	bf c1					.word Unary_Spc            & $FFFF ; $a3 spc(
>af48	ee bf					.word Unary_Str            & $FFFF ; $a4 str$(
>af4a	79 bf					.word Unary_Val            & $FFFF ; $a5 val(
>af4c	37 c0					.word Unary_Len            & $FFFF ; $a6 len(
>af4e	ec c0					.word Unary_Hex            & $FFFF ; $a7 hex$(
>af50	be af					.word NotImplemented       & $FFFF ; $a8 sin(
>af52	be af					.word NotImplemented       & $FFFF ; $a9 cos(
>af54	be af					.word NotImplemented       & $FFFF ; $aa tan(
>af56	be af					.word NotImplemented       & $FFFF ; $ab atn(
>af58	be af					.word NotImplemented       & $FFFF ; $ac exp(
>af5a	be af					.word NotImplemented       & $FFFF ; $ad log(
>af5c	be af					.word NotImplemented       & $FFFF ; $ae sqr(
>af5e	42 c1					.word Unary_Dec            & $FFFF ; $af dec(
>af60	ea be					.word Unary_Deek           & $FFFF ; $b0 deek(
>af62	ee be					.word Unary_Leek           & $FFFF ; $b1 leek(
>af64	26 bf					.word Unary_Mod            & $FFFF ; $b2 mod(
>af66	86 be					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>af68	a1 c1					.word Unary_Chr            & $FFFF ; $b4 chr$(
>af6a	1a bf					.word Unary_Pos            & $FFFF ; $b5 pos(
>af6c	e2 c1					.word Unary_Tab            & $FFFF ; $b6 tab(
>af6e	be af					.word NotImplemented       & $FFFF ; $b7 $
>af70	be af					.word NotImplemented       & $FFFF ; $b8 $(
>af72	be af					.word NotImplemented       & $FFFF ; $b9 #
>af74	be af					.word NotImplemented       & $FFFF ; $ba #(
>af76	be af					.word NotImplemented       & $FFFF ; $bb %
>af78	be af					.word NotImplemented       & $FFFF ; $bc %(
>af7a	be af					.word NotImplemented       & $FFFF ; $bd (
>af7c	be af					.word NotImplemented       & $FFFF ; $be )
>af7e	be af					.word NotImplemented       & $FFFF ; $bf ,
>af80	ae b2					.word Command_COLON        & $FFFF ; $c0 :
>af82	be af					.word NotImplemented       & $FFFF ; $c1 ;
>af84	be af					.word NotImplemented       & $FFFF ; $c2 def
>af86	2b ba					.word Command_CLR          & $FFFF ; $c3 clr
>af88	42 ba					.word Command_STOP         & $FFFF ; $c4 stop
>af8a	09 b4					.word Command_DATA         & $FFFF ; $c5 data
>af8c	e2 b3					.word Command_READ         & $FFFF ; $c6 read
>af8e	52 b1					.word Command_DIM          & $FFFF ; $c7 dim
>af90	be af					.word NotImplemented       & $FFFF ; $c8 to
>af92	be af					.word NotImplemented       & $FFFF ; $c9 step
>af94	6a b9					.word Command_GOSUB        & $FFFF ; $ca gosub
>af96	7a b9					.word Command_RETURN       & $FFFF ; $cb return
>af98	62 b9					.word Command_GOTO         & $FFFF ; $cc goto
>af9a	b0 b5					.word Command_END          & $FFFF ; $cd end
>af9c	34 b5					.word Command_INPUT        & $FFFF ; $ce input
>af9e	af b4					.word Command_LET          & $FFFF ; $cf let
>afa0	1e b6					.word Command_LIST         & $FFFF ; $d0 list
>afa2	04 b9					.word Command_NEW          & $FFFF ; $d1 new
>afa4	23 b9					.word Command_OLD          & $FFFF ; $d2 old
>afa6	83 b9					.word Command_ON           & $FFFF ; $d3 on
>afa8	0c b4					.word Command_RESTORE      & $FFFF ; $d4 restore
>afaa	d3 b8					.word Command_POKE         & $FFFF ; $d5 poke
>afac	23 b8					.word Command_PRINT        & $FFFF ; $d6 print
>afae	1b b2					.word Command_RUN          & $FFFF ; $d7 run
>afb0	dc b1					.word Command_WAIT         & $FFFF ; $d8 wait
>afb2	1b b5					.word Command_SYS          & $FFFF ; $d9 sys
>afb4	d7 b8					.word Command_DOKE         & $FFFF ; $da doke
>afb6	db b8					.word Command_LOKE         & $FFFF ; $db loke
>afb8	bb b8					.word Command_ASSERT       & $FFFF ; $dc assert
>afba	d0 b4					.word Command_GET          & $FFFF ; $dd get
>afbc	12 b6					.word Command_ELSE         & $FFFF ; $de else
.afbe					NotImplemented:
.afbe	20 9e ae	jsr $ae9e			jsr ERR_Handler
>afc1	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>afc9	65 6d 65 6e 74 65 64 00
.afd1					BinaryPrecedence:
>afd1	01					.byte 1    ; $80 and
>afd2	01					.byte 1    ; $81 or
>afd3	01					.byte 1    ; $82 xor
>afd4	01					.byte 1    ; $83 eor
>afd5	02					.byte 2    ; $84 =
>afd6	02					.byte 2    ; $85 <>
>afd7	02					.byte 2    ; $86 <
>afd8	02					.byte 2    ; $87 <=
>afd9	02					.byte 2    ; $88 >
>afda	02					.byte 2    ; $89 >=
>afdb	03					.byte 3    ; $8a +
>afdc	03					.byte 3    ; $8b -
>afdd	04					.byte 4    ; $8c *
>afde	04					.byte 4    ; $8d /
>afdf	05					.byte 5    ; $8e ^
.afe0					KeywordText:
>afe0	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>afe3	4f d2					.byte $4f,$d2                          ; $81 or
>afe5	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>afe8	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>afeb	bd					.byte $bd                              ; $84 =
>afec	3c be					.byte $3c,$be                          ; $85 <>
>afee	bc					.byte $bc                              ; $86 <
>afef	3c bd					.byte $3c,$bd                          ; $87 <=
>aff1	be					.byte $be                              ; $88 >
>aff2	3e bd					.byte $3e,$bd                          ; $89 >=
>aff4	ab					.byte $ab                              ; $8a +
>aff5	ad					.byte $ad                              ; $8b -
>aff6	aa					.byte $aa                              ; $8c *
>aff7	af					.byte $af                              ; $8d /
>aff8	de					.byte $de                              ; $8e ^
>aff9	49 c6					.byte $49,$c6                          ; $8f if
>affb	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>b000	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>b006	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>b009	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>b00d	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>b012	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>b016	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>b01b	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>b01f	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>b022	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>b025	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>b029	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>b02d	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>b031	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>b036	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>b03a	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>b03e	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>b044	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>b04b	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>b050	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>b054	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>b059	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>b05d	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>b061	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>b066	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>b06a	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>b06e	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>b072	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>b076	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>b07a	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>b07e	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>b082	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>b086	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>b08b	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>b090	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>b094	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>b098	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>b09d	50 4f 53 a8				.byte $50,$4f,$53,$a8                  ; $b5 pos(
>b0a1	54 41 42 a8				.byte $54,$41,$42,$a8                  ; $b6 tab(
>b0a5	a4					.byte $a4                              ; $b7 $
>b0a6	24 a8					.byte $24,$a8                          ; $b8 $(
>b0a8	a3					.byte $a3                              ; $b9 #
>b0a9	23 a8					.byte $23,$a8                          ; $ba #(
>b0ab	a5					.byte $a5                              ; $bb %
>b0ac	25 a8					.byte $25,$a8                          ; $bc %(
>b0ae	a8					.byte $a8                              ; $bd (
>b0af	a9					.byte $a9                              ; $be )
>b0b0	ac					.byte $ac                              ; $bf ,
>b0b1	ba					.byte $ba                              ; $c0 :
>b0b2	bb					.byte $bb                              ; $c1 ;
>b0b3	44 45 c6				.byte $44,$45,$c6                      ; $c2 def
>b0b6	43 4c d2				.byte $43,$4c,$d2                      ; $c3 clr
>b0b9	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $c4 stop
>b0bd	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c5 data
>b0c1	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c6 read
>b0c5	44 49 cd				.byte $44,$49,$cd                      ; $c7 dim
>b0c8	54 cf					.byte $54,$cf                          ; $c8 to
>b0ca	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c9 step
>b0ce	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $ca gosub
>b0d3	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $cb return
>b0d9	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $cc goto
>b0dd	45 4e c4				.byte $45,$4e,$c4                      ; $cd end
>b0e0	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $ce input
>b0e5	4c 45 d4				.byte $4c,$45,$d4                      ; $cf let
>b0e8	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $d0 list
>b0ec	4e 45 d7				.byte $4e,$45,$d7                      ; $d1 new
>b0ef	4f 4c c4				.byte $4f,$4c,$c4                      ; $d2 old
>b0f2	4f ce					.byte $4f,$ce                          ; $d3 on
>b0f4	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d4 restore
>b0fb	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d5 poke
>b0ff	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d6 print
>b104	52 55 ce				.byte $52,$55,$ce                      ; $d7 run
>b107	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d8 wait
>b10b	53 59 d3				.byte $53,$59,$d3                      ; $d9 sys
>b10e	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $da doke
>b112	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $db loke
>b116	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $dc assert
>b11c	47 45 d4				.byte $47,$45,$d4                      ; $dd get
>b11f	45 4c 53 c5				.byte $45,$4c,$53,$c5                  ; $de else
>b123	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_pos = $b5
=$b6					token_tab = $b6
=$b7					token_dollar = $b7
=$b8					token_dollarlparen = $b8
=$b9					token_hash = $b9
=$ba					token_hashlparen = $ba
=$bb					token_percent = $bb
=$bc					token_percentlparen = $bc
=$bd					token_lparen = $bd
=$be					token_rparen = $be
=$bf					token_comma = $bf
=$c0					token_colon = $c0
=$c1					token_semicolon = $c1
=$c2					token_def = $c2
=$c3					token_clr = $c3
=$c4					token_stop = $c4
=$c5					token_data = $c5
=$c6					token_read = $c6
=$c7					token_dim = $c7
=$c8					token_to = $c8
=$c9					token_step = $c9
=$ca					token_gosub = $ca
=$cb					token_return = $cb
=$cc					token_goto = $cc
=$cd					token_end = $cd
=$ce					token_input = $ce
=$cf					token_let = $cf
=$d0					token_list = $d0
=$d1					token_new = $d1
=$d2					token_old = $d2
=$d3					token_on = $d3
=$d4					token_restore = $d4
=$d5					token_poke = $d5
=$d6					token_print = $d6
=$d7					token_run = $d7
=$d8					token_wait = $d8
=$d9					token_sys = $d9
=$da					token_doke = $da
=$db					token_loke = $db
=$dc					token_assert = $dc
=$dd					token_get = $dd
=$de					token_else = $de

;******  Return to file: modules/basic/core.asm

.b124					BASIC_Start:
.b124	20 40 a2	jsr $a240			jsr 	IF_Reset 					; set up and clear screen.
.b127	20 0c a0	jsr $a00c			jsr 	IFT_ClearScreen
.b12a	a9 4c		lda #$4c			lda 	#$4C 						; JMP opcode
.b12c	8d 10 03	sta $0310			sta 	LocalVector
.b12f	8d 0c 03	sta $030c			sta 	UserVector
.b132	a9 67		lda #$67			lda 	#USRDefault & $FF 			; reset USR vector
.b134	8d 0d 03	sta $030d			sta 	UserVector+1
.b137	a9 bf		lda #$bf			lda 	#(USRDefault >> 8) & $FF
.b139	8d 0e 03	sta $030e			sta 	UserVector+2
.b13c	a9 00		lda #$00			lda 	#(USRDefault >> 16) & $FF
.b13e	8d 0f 03	sta $030f			sta 	UserVector+3
.b141	20 2f c2	jsr $c22f			jsr 	UpdateProgramEnd 			; update the program end.
.b144	20 2b ba	jsr $ba2b			jsr 	ResetRunStatus 				; clear everything (CLR command)
.b147	a2 ff		ldx #$ff			ldx 		#$FF 					; empty stack
.b149	9a		txs				txs
.b14a	4c 1b b2	jmp $b21b			jmp 	COMMAND_Run
.b14d					WarmStart:
.b14d	a2 ff		ldx #$ff			ldx 		#$FF 					; empty stack
.b14f	9a		txs				txs
.b150	80 fb		bra $b14d			bra 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/dim.asm

.b152					Command_DIM:
.b152	6b		tza				tza
.b153	48		pha				pha 								; push on stack.
.b154	20 ae c3	jsr $c3ae			jsr 	VariableExtract 			; get the identifier
.b157	ad 95 03	lda $0395			lda 	Var_Type 					; check it is an array
.b15a	29 01		and #$01			and 	#1
.b15c	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.b15e	d0 6e		bne $b1ce			bne 	_CDIError
.b160	a9 00		lda #$00			lda 	#0 							; reset the DIM index. The dimensions are
.b162	8d b9 03	sta $03b9			sta 	UsrArrayIdx 				; built up here and copied in case we autodim
.b165					_CDIGetDimension:
.b165	ad b9 03	lda $03b9			lda 	UsrArrayIdx 				; done too many ?
.b168	c9 06		cmp #$06			cmp 	#ArrayMaxDim*2
.b16a	f0 62		beq $b1ce			beq 	_CDIError
.b16c	20 36 bc	jsr $bc36			jsr 	EvaluateInteger 			; evaluate an index size
.b16f	a5 81		lda $81				lda 	XS_Mantissa+1 				; check in range 0-7FFF
.b171	29 80		and #$80			and 	#$80
.b173	05 82		ora $82				ora 	XS_Mantissa+2
.b175	05 83		ora $83				ora 	XS_Mantissa+3
.b177	d0 55		bne $b1ce			bne 	_CDIError
.b179	ae b9 03	ldx $03b9			ldx 	UsrArrayIdx 				; copy into the array table.
.b17c	18		clc				clc 								; add 1 - max index => size.
.b17d	a5 80		lda $80				lda 	XS_Mantissa+0
.b17f	69 01		adc #$01			adc 	#1
.b181	9d b1 03	sta $03b1,x			sta 	UsrArrayDef+0,x
.b184	a5 81		lda $81				lda 	XS_Mantissa+1
.b186	69 00		adc #$00			adc 	#0
.b188	9d b2 03	sta $03b2,x			sta 	UsrArrayDef+1,x
.b18b	30 41		bmi $b1ce			bmi 	_CDIError 					; could be dim a(32767)
.b18d	e8		inx				inx 								; bump index.
.b18e	e8		inx				inx
.b18f	8e b9 03	stx $03b9			stx 	UsrArrayIdx
.b192	ea		nop				nop
.b193	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b195	1b		inz				inz
.b196	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another dimension
.b198	f0 cb		beq $b165			beq 	_CDIGetDimension
.b19a	3b		dez				dez
.b19b	20 90 c2	jsr $c290			jsr 	CheckNextRParen 			; closing ) present ?
.b19e	ae b9 03	ldx $03b9			ldx 	UsrArrayIdx 				; copy USR array to default
.b1a1	a9 ff		lda #$ff			lda 	#$FF 						; put end marker in ArrayDef
.b1a3	9d aa 03	sta $03aa,x			sta 	ArrayDef+1,x
.b1a6					_CDICopy:
.b1a6	bd b1 03	lda $03b1,x			lda 	UsrArrayDef,x
.b1a9	9d a9 03	sta $03a9,x			sta 	ArrayDef,x
.b1ac	ca		dex				dex
.b1ad	10 f7		bpl $b1a6			bpl 	_CDICopy
.b1af	68		pla				pla									; position of array identifier
.b1b0	85 10		sta $10				sta 	zTemp1
.b1b2	6b		tza				tza
.b1b3	48		pha				pha
.b1b4	a5 10		lda $10				lda 	zTemp1 						; point to identifier
.b1b6	4b		taz				taz
.b1b7	20 ae c3	jsr $c3ae			jsr 	VariableExtract 			; get the identifier
.b1ba	20 49 c6	jsr $c649			jsr 	VariableLocate 				; check if it exists already.
.b1bd	b0 0f		bcs $b1ce			bcs 	_CDIError
.b1bf	20 3c c4	jsr $c43c			jsr 	VariableCreate 				; create it using the current ArrayDef
.b1c2	68		pla				pla 								; restore code position
.b1c3	4b		taz				taz
.b1c4	ea		nop				nop
.b1c5	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b1c7	1b		inz				inz
.b1c8	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another DIM
.b1ca	f0 86		beq $b152			beq 	Command_DIM
.b1cc	3b		dez				dez
.b1cd	60		rts				rts
.b1ce					_CDIError:
.b1ce	20 9e ae	jsr $ae9e			jsr ERR_Handler
>b1d1	42 61 64 20 44 49 4d 00			.text "Bad DIM",0
.b1d9					_CDISyntax:
.b1d9	4c 6f ae	jmp $ae6f			jmp 	SyntaxError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/wait.asm

.b1dc					Command_WAIT:
.b1dc	20 36 bc	jsr $bc36			jsr		EvaluateInteger 			; address
.b1df	a2 06		ldx #$06			ldx 	#XS_Size 					; and mask.
.b1e1	20 99 c2	jsr $c299			jsr 	CheckNextComma
.b1e4	20 38 bc	jsr $bc38			jsr 	EvaluateIntegerX
.b1e7	a9 00		lda #$00			lda 	#0							; set default xor.
.b1e9	85 8c		sta $8c				sta 	XS_Mantissa+XS_Size*2
.b1eb	ea		nop				nop
.b1ec	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b1ee	c9 bf		cmp #$bf			cmp 	#token_Comma 				; no use the default
.b1f0	d0 06		bne $b1f8			bne 	_CWAXorDefault
.b1f2	1b		inz				inz
.b1f3	a2 0c		ldx #$0c			ldx 	#XS_Size*2
.b1f5	20 38 bc	jsr $bc38			jsr 	EvaluateIntegerX
.b1f8					_CWAXorDefault:
.b1f8	a5 80		lda $80				lda 	XS_Mantissa 				; copy 24 bits of mantissa to ZLTemp1
.b1fa	85 1a		sta $1a				sta 	zLTemp1
.b1fc	a5 81		lda $81				lda 	XS_Mantissa+1
.b1fe	85 1b		sta $1b				sta 	zLTemp1+1
.b200	a5 82		lda $82				lda 	XS_Mantissa+2
.b202	85 1c		sta $1c				sta 	zLTemp1+2
.b204					_CWAWaitLoop:
.b204	20 65 ae	jsr $ae65			jsr 	VIOCheckBreak 				; exit on break.
.b207	c9 00		cmp #$00			cmp 	#0
.b209	d0 0f		bne $b21a			bne 	_CWAWaitExit
.b20b	a9 01		lda #$01			lda 	#1							; read 1 byte to mantissa/0
.b20d	a2 00		ldx #$00			ldx 	#0
.b20f	5a		phy				phy 								; this is the same routine as PEEK.
.b210	20 07 c2	jsr $c207			jsr 	MemRead
.b213	7a		ply				ply
.b214	25 86		and $86				and 	XS_Mantissa+XS_Size 		; process it
.b216	45 8c		eor $8c				eor 	XS_Mantissa+XS_Size*2
.b218	f0 ea		beq $b204			beq 	_CWAWaitLoop
.b21a					_CWAWaitExit:
.b21a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/run.asm

.b21b					Command_RUN:
.b21b	20 2b ba	jsr $ba2b			jsr 	ResetRunStatus 				; clear, reset stacks etc.
.b21e	a9 00		lda #$00			lda 	#BasicProgram & $FF
.b220	85 16		sta $16				sta 	zCodePtr+0
.b222	a9 80		lda #$80			lda 	#BasicProgram >> 8
.b224	85 17		sta $17				sta 	zCodePtr+1
.b226	a9 02		lda #$02			lda 	#2
.b228	85 18		sta $18				sta 	zCodePtr+2
.b22a	a9 00		lda #$00			lda 	#0
.b22c	85 19		sta $19				sta 	zCodePtr+3
.b22e	a3 03		ldz #$03			ldz 	#3
.b230					RUN_NewLine:
.b230	a3 00		ldz #$00			ldz 	#0
.b232	ea		nop				nop
.b233	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b235	1b		inz				inz
.b236	1b		inz				inz
.b237	1b		inz				inz
.b238	c9 00		cmp #$00			cmp 	#0 							; if the offset is zero then END.
.b23a	d0 18		bne $b254			bne 	RUN_NextCommand
.b23c	4c b0 b5	jmp $b5b0			jmp 	Command_END 				; go do the command code.
.b23f					RUN_Skip:
.b23f	ea		nop				nop
.b240	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read element
.b242	1b		inz				inz 								; skip
.b243	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.b245	90 0d		bcc $b254			bcc 	_SEDone 					; so just skip over it.
.b247	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.b249	90 08		bcc $b253			bcc 	_SEDouble
.b24b	6b		tza				tza 								; this is Y + 1
.b24c	18		clc				clc
.b24d	ea		nop				nop
.b24e	72 16		adc ($16),z			adc 	(zCodePtr),z 				; add total length of element
.b250	4b		taz				taz 								; back in Y.
.b251	3b		dez				dez 								; fix up, one for the +1, one for the iny
.b252	3b		dez				dez
.b253					_SEDouble:
.b253	1b		inz				inz
.b254					_SEDone:
.b254					RUN_NextCommand:
.b254	ad a8 03	lda $03a8			lda 	BreakCount 					; break counter
.b257	69 10		adc #$10			adc 	#16 						; one time in 16
.b259	8d a8 03	sta $03a8			sta 	BreakCount
.b25c	90 0a		bcc $b268			bcc 	RUN_NoCheckBreak
.b25e	20 65 ae	jsr $ae65			jsr 	VIOCheckBreak 				; check for break
.b261	c9 00		cmp #$00			cmp 	#0
.b263	f0 03		beq $b268			beq 	RUN_NoCheckBreak
.b265	4c 42 ba	jmp $ba42			jmp 	Command_STOP 				; stop on BREAK.
.b268					RUN_NoCheckBreak:
.b268	a9 00		lda #$00			lda 	#0 							; this resets temporary string allocation.
.b26a	85 21		sta $21				sta 	zTempStr+1 					; (initialised when first called)
.b26c	ea		nop				nop
.b26d	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b26f	c9 c0		cmp #$c0			cmp 	#token_Colon 				; skip over colons
.b271	f0 cc		beq $b23f			beq 	RUN_Skip
.b273	c9 00		cmp #$00			cmp 	#0 							; if non-zero execute whatever
.b275	d0 10		bne $b287			bne 	RUN_Execute
.b277					RUN_NextLine:
.b277	a3 00		ldz #$00			ldz 	#0 							; point to offset
.b279	ea		nop				nop
.b27a	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read it
.b27c	18		clc				clc
.b27d	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.b27f	85 16		sta $16				sta 	zCodePtr
.b281	90 02		bcc $b285			bcc 	_SNLNoCarry
.b283	e6 17		inc $17				inc 	zCodePtr+1
.b285					_SNLNoCarry:
.b285	80 a9		bra $b230			bra 	RUN_NewLine 				; go do the new line code
.b287					RUN_Execute:
.b287	c9 f8		cmp #$f8			cmp 	#$F8 						; handle shifts, REM etc.
.b289	b0 1c		bcs $b2a7			bcs 	RUN_Extension
.b28b	1b		inz				inz
.b28c	0a		asl a				asl 	a 							; double the character read.
.b28d	90 12		bcc $b2a1			bcc 	RUN_Default 				; if carry clear was $00-$7F, so try LET.
.b28f	aa		tax				tax 								; ready to look up.
.b290	bd 00 af	lda $af00,x			lda 	VectorTable,x 				; copy address into LocalVector
.b293	8d 11 03	sta $0311			sta 	LocalVector+1
.b296	bd 01 af	lda $af01,x			lda 	VectorTable+1,x
.b299	8d 12 03	sta $0312			sta 	LocalVector+2
.b29c	20 7f bb	jsr $bb7f			jsr 	EVCallLocalVector 			; execute the appropriate code.
.b29f	80 b3		bra $b254			bra 	RUN_NextCommand 			; do the next command.
.b2a1					RUN_Default:
.b2a1	3b		dez				dez
.b2a2	20 af b4	jsr $b4af			jsr 	Command_LET 				; and try LET.
.b2a5	80 ad		bra $b254			bra 	RUN_NextCommand
.b2a7					RUN_Extension:
.b2a7	c9 ff		cmp #$ff			cmp 	#$FF 						; if $FF (REM)
.b2a9	f0 94		beq $b23f			beq 	RUN_Skip 					; skip over it.
.b2ab	4c 6f ae	jmp $ae6f			jmp 	SyntaxError
.b2ae					Command_COLON:
.b2ae	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/for.asm

.b2af					Command_FOR:
.b2af	20 af b4	jsr $b4af			jsr 	Command_LET 				; do the A = 99 bit
.b2b2	a5 24		lda $24				lda 	zVarType 					; obviously has to be integer/real.
.b2b4	c9 b7		cmp #$b7			cmp 	#token_Dollar
.b2b6	f0 72		beq $b32a			beq 	_CFOError
.b2b8	48		pha				pha 								; save the variable type.
.b2b9	5a		phy				phy 								; save type/variable address.
.b2ba	a0 01		ldy #$01			ldy 	#1							; type at + 1
.b2bc	91 26		sta ($26),y			sta 	(zBasicSP),y
.b2be	c8		iny				iny
.b2bf	a5 22		lda $22				lda 	zVarDataPtr 				; data low at +2
.b2c1	91 26		sta ($26),y			sta 	(zBasicSP),y
.b2c3	c8		iny				iny
.b2c4	a5 23		lda $23				lda 	zVarDataPtr+1 				; data high at +3
.b2c6	91 26		sta ($26),y			sta 	(zBasicSP),y
.b2c8	7a		ply				ply
.b2c9	a9 53		lda #$53			lda 	#(SMark_For << 4) + 3
.b2cb	20 d7 ad	jsr $add7			jsr 	StackPushFrame 				; push on the stack with FOR marker.
.b2ce	a9 c8		lda #$c8			lda 	#token_TO
.b2d0	20 78 c2	jsr $c278			jsr 	CheckNextToken
.b2d3	a2 00		ldx #$00			ldx 	#0 							; put in Mantissa, bottom
.b2d5	20 99 ba	jsr $ba99			jsr 	EvaluateExpression
.b2d8	ea		nop				nop
.b2d9	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b2db	a2 06		ldx #$06			ldx 	#XS_Size 					; X to second level
.b2dd	c9 c9		cmp #$c9			cmp 	#token_STEP
.b2df	d0 06		bne $b2e7			bne 	_CFOStep1
.b2e1	1b		inz				inz
.b2e2	20 9b ba	jsr $ba9b			jsr 	EvaluateExpressionX 		; get STEP value.
.b2e5	80 0e		bra $b2f5			bra 	_CFOHaveStep
.b2e7					_CFOStep1:
.b2e7	a9 00		lda #$00			lda 	#0							; set step to integer 1.
.b2e9	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b2eb	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b2ed	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b2ef	a9 01		lda #$01			lda 	#1
.b2f1	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b2f3	95 85		sta $85,x			sta 	XS_Type,x
.b2f5					_CFOHaveStep:
.b2f5	68		pla				pla 								; restore variable type
.b2f6	a2 00		ldx #$00			ldx 	#0
.b2f8	c9 bb		cmp #$bb			cmp 	#token_Percent 				; do conversion to type
.b2fa	f0 0a		beq $b306			beq 	_CFOInteger
.b2fc	20 50 cc	jsr $cc50			jsr 	FPUToFloat
.b2ff	a2 06		ldx #$06			ldx 	#6
.b301	20 50 cc	jsr $cc50			jsr 	FPUToFloat
.b304	80 08		bra $b30e			bra 	_CFOEndConv
.b306					_CFOInteger:
.b306	20 9c cc	jsr $cc9c			jsr 	FPUToInteger
.b309	a2 06		ldx #$06			ldx 	#6
.b30b	20 9c cc	jsr $cc9c			jsr 	FPUToInteger
.b30e					_CFOEndConv:
.b30e	20 1e ae	jsr $ae1e			jsr 	StackSavePosition 			; save the loop position at 1-5
.b311	a9 55		lda #$55			lda 	#(SMark_For << 4)+SourcePosSize
.b313	20 d7 ad	jsr $add7			jsr 	StackPushFrame 				; push the loop address frame.
.b316	5a		phy				phy
.b317	a0 00		ldy #$00			ldy 	#0
.b319					_CFOCopy:
.b319	b9 80 00	lda $0080,y			lda 	XS_Mantissa+0,y
.b31c	c8		iny				iny
.b31d	91 26		sta ($26),y			sta 	(zBasicSP),y
.b31f	c0 0c		cpy #$0c			cpy 	#XS_Size*2
.b321	d0 f6		bne $b319			bne 	_CFOCopy
.b323	7a		ply				ply
.b324	a9 5c		lda #$5c			lda 	#(SMark_For << 4)+(XS_Size*2)
.b326	20 d7 ad	jsr $add7			jsr 	StackPushFrame
.b329	60		rts				rts
.b32a					_CFOError:
.b32a	4c 7f ae	jmp $ae7f			jmp 	TypeError 					; wrong type.
.b32d					Command_NEXT:
.b32d	a9 00		lda #$00			lda 	#0 							; set variable data pointer+1 to zero
.b32f	85 23		sta $23				sta 	zVarDataPtr+1 				; this means we don't check
.b331	ea		nop				nop
.b332	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b334	c9 00		cmp #$00			cmp 	#0 							; EOL
.b336	f0 07		beq $b33f			beq 	_CNextNoVariable
.b338	c9 40		cmp #$40			cmp 	#$40
.b33a	b0 03		bcs $b33f			bcs 	_CNextNoVariable
.b33c	20 43 c3	jsr $c343			jsr 	VariableFind
.b33f					_CNextNoVariable:
.b33f	a5 26		lda $26				lda 	zBasicSP 					; save on stack
.b341	48		pha				pha
.b342	a5 27		lda $27				lda 	zBasicSP+1
.b344	48		pha				pha
.b345	a9 50		lda #$50			lda 	#(SMark_For << 4) 			; pop loop address frame
.b347	20 ee ad	jsr $adee			jsr 	StackPopFrame
.b34a	a9 50		lda #$50			lda 	#(SMark_For << 4) 			; pop STEP/TARGET frame.
.b34c	20 ee ad	jsr $adee			jsr 	StackPopFrame
.b34f	a9 50		lda #$50			lda 	#(Smark_For << 4) 			; pop variable address frame.
.b351	20 ee ad	jsr $adee			jsr 	StackPopFrame
.b354	a5 23		lda $23				lda 	zVarDataPtr+1 				; if zero, then no variable provided
.b356	f0 11		beq $b369			beq 	_CNextGetTarget 			; e.g. just NEXT not NEXT x
.b358	5a		phy				phy 								; check addresses match.
.b359	a0 02		ldy #$02			ldy 	#2
.b35b	b1 26		lda ($26),y			lda 	(zBasicSP),y
.b35d	c5 22		cmp $22				cmp 	zVarDataPtr
.b35f	d0 6a		bne $b3cb			bne 	_CNextWrong
.b361	c8		iny				iny
.b362	b1 26		lda ($26),y			lda 	(zBasicSP),y
.b364	c5 23		cmp $23				cmp 	zVarDataPtr+1
.b366	d0 63		bne $b3cb			bne 	_CNextWrong
.b368	7a		ply				ply
.b369					_CNextGetTarget:
.b369	5a		phy				phy
.b36a	a0 01		ldy #$01			ldy 	#1 							; restore variable type and data.
.b36c	b1 26		lda ($26),y			lda 	(zBasicSP),y
.b36e	85 24		sta $24				sta 	zVarType
.b370	c8		iny				iny
.b371	b1 26		lda ($26),y			lda 	(zBasicSP),y
.b373	85 22		sta $22				sta 	zVarDataPtr
.b375	c8		iny				iny
.b376	b1 26		lda ($26),y			lda 	(zBasicSP),y
.b378	85 23		sta $23				sta 	zVarDataPtr+1
.b37a	a2 0c		ldx #$0c			ldx 	#12
.b37c	20 8d c6	jsr $c68d			jsr 	VariableGet 				; get that variable value into expr[2]
.b37f	a2 00		ldx #$00			ldx 	#0 							; copy stacked Target/Step into expr[0] and [1]
.b381	a0 0b		ldy #$0b			ldy 	#11
.b383					_CNXCopy:
.b383	b1 26		lda ($26),y			lda 	(zBasicSP),y
.b385	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b387	e8		inx				inx
.b388	c8		iny				iny
.b389	e0 0c		cpx #$0c			cpx 	#XS_Size*2
.b38b	d0 f6		bne $b383			bne 	_CNXCopy
.b38d	7a		ply				ply
.b38e	a2 06		ldx #$06			ldx 	#6 							; point at expr[1] s
.b390	20 aa be	jsr $beaa			jsr 	GetSignCurrent
.b393	8d a7 03	sta $03a7			sta 	SignNext 					; save in temporary.
.b396	a2 06		ldx #$06			ldx 	#6 							; add them, however
.b398	20 89 bd	jsr $bd89			jsr 	BinaryOp_Add
.b39b	20 de c6	jsr $c6de			jsr 	VariableSet					; and write variable back.
.b39e	a2 00		ldx #$00			ldx 	#0
.b3a0	20 0d bd	jsr $bd0d			jsr 	CompareValues
.b3a3	09 00		ora #$00			ora 	#0
.b3a5	f0 05		beq $b3ac			beq 	_CNXAgain 					; if true, then do it again.
.b3a7	cd a7 03	cmp $03a7			cmp 	SignNext 					; if sign different, then loop has finished.
.b3aa	d0 0f		bne $b3bb			bne 	_CNXLoopDone
.b3ac					_CNXAgain:
.b3ac	a9 53		lda #$53			lda 	#(SMark_For << 4) + 3		; re-stack variable address
.b3ae	20 d7 ad	jsr $add7			jsr 	StackPushFrame
.b3b1	20 3b ae	jsr $ae3b			jsr 	StackRestorePosition 		; get restore position back, e.g. loop round.
.b3b4	68		pla				pla
.b3b5	85 27		sta $27				sta 	zBasicSP+1
.b3b7	68		pla				pla
.b3b8	85 26		sta $26				sta 	zBasicSP
.b3ba					_CNXExit:
.b3ba	60		rts				rts
.b3bb					_CNXLoopDone:
.b3bb	68		pla				pla
.b3bc	68		pla				pla
.b3bd	ea		nop				nop
.b3be	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b3c0	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma ?
.b3c2	d0 f6		bne $b3ba			bne 	_CNXExit
.b3c4	1b		inz				inz
.b3c5	20 43 c3	jsr $c343			jsr 	VariableFind 				; identify the variable
.b3c8	4c 3f b3	jmp $b33f			jmp 	_CNextNoVariable 			; go back with variable pre-found
.b3cb					_CNextWrong:
.b3cb	20 9e ae	jsr $ae9e			jsr ERR_Handler
>b3ce	57 72 6f 6e 67 20 4e 65			.text "Wrong Next Variable",0
>b3d6	78 74 20 56 61 72 69 61 62 6c 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/read.asm

.b3e2					Command_READ:
.b3e2	20 43 c3	jsr $c343			jsr 	VariableFind 				; get variable/value into zVarDataPtr,zVarType
.b3e5	a5 22		lda $22				lda 	zVarDataPtr 				; save variable info on stack
.b3e7	48		pha				pha
.b3e8	a5 23		lda $23				lda 	zVarDataPtr+1
.b3ea	48		pha				pha
.b3eb	a5 24		lda $24				lda 	zVarType
.b3ed	48		pha				pha
.b3ee	20 35 b4	jsr $b435			jsr 	READGetDataItem 			; get the next data item
.b3f1	68		pla				pla 								; restore target variable information.
.b3f2	85 24		sta $24				sta 	zVarType
.b3f4	68		pla				pla
.b3f5	85 23		sta $23				sta 	zVarDataPtr+1
.b3f7	68		pla				pla
.b3f8	85 22		sta $22				sta 	zVarDataPtr
.b3fa	a2 00		ldx #$00			ldx 	#0
.b3fc	20 de c6	jsr $c6de			jsr 	VariableSet 				; set the value out.
.b3ff	ea		nop				nop
.b400	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b402	1b		inz				inz
.b403	c9 bf		cmp #$bf			cmp 	#token_Comma
.b405	f0 db		beq $b3e2			beq 	Command_READ 				; found, do another READ
.b407	3b		dez				dez
.b408	60		rts				rts
.b409					Command_DATA:
.b409	4c a2 ad	jmp $ada2			jmp 	SkipEndOfCommand
.b40c					Command_RESTORE:
.b40c	48		pha				pha
.b40d	a9 00		lda #$00			lda 	#0 							; this being zero means 'initialise next read'
.b40f	8d bd 03	sta $03bd			sta 	DataLPtr+0
.b412	8d be 03	sta $03be			sta 	DataLPtr+1
.b415	68		pla				pla
.b416	60		rts				rts
.b417					READSwapPointers:
.b417	6b		tza				tza
.b418	48		pha				pha 								; save it
.b419	ad c1 03	lda $03c1			lda 	DataIndex 					; get data offset, and copy to offset
.b41c	4b		taz				taz
.b41d	68		pla				pla 								; get code offset and save in DataIndex
.b41e	8d c1 03	sta $03c1			sta 	DataIndex
.b421	da		phx				phx
.b422	a2 03		ldx #$03			ldx 	#3 							; swap the Data Pointers (4 bytes) round.
.b424					_RSWLoop:
.b424	bd bd 03	lda $03bd,x			lda 	DataLPtr+0,x
.b427	48		pha				pha
.b428	b5 16		lda $16,x			lda 	zCodePtr+0,x
.b42a	9d bd 03	sta $03bd,x			sta 	DataLPtr+0,x
.b42d	68		pla				pla
.b42e	95 16		sta $16,x			sta 	zCodePtr+0,x
.b430	ca		dex				dex
.b431	10 f1		bpl $b424			bpl 	_RSWLoop
.b433	fa		plx				plx
.b434	60		rts				rts
.b435					READGetDataItem:
.b435	20 17 b4	jsr $b417			jsr 	ReadSwapPointers 			; swap code and data pointer.
.b438	a5 16		lda $16				lda		zCodePtr+0 					; initialise ?
.b43a	05 17		ora $17				ora 	zCodePtr+1
.b43c	d0 14		bne $b452			bne 	_RGDIIsInitialised
.b43e	a9 00		lda #$00			lda 	#BasicProgram & $FF
.b440	85 16		sta $16				sta 	zCodePtr+0
.b442	a9 80		lda #$80			lda 	#BasicProgram >> 8
.b444	85 17		sta $17				sta 	zCodePtr+1
.b446	a9 02		lda #$02			lda 	#2
.b448	85 18		sta $18				sta 	zCodePtr+2
.b44a	a9 00		lda #$00			lda 	#0
.b44c	85 19		sta $19				sta 	zCodePtr+3
.b44e	a3 03		ldz #$03			ldz 	#3
.b450	80 07		bra $b459			bra 	_RGDIFindData 				; locate next data from start and read that.
.b452					_RGDIIsInitialised:
.b452	ea		nop				nop
.b453	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b455	c9 bf		cmp #$bf			cmp 	#token_Comma
.b457	f0 4e		beq $b4a7			beq 	_RGDISkipEvaluateExit
.b459					_RGDIFindData:
.b459	ea		nop				nop
.b45a	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b45c	c9 00		cmp #$00			cmp 	#0 							; end of line
.b45e	f0 1b		beq $b47b			beq 	_RGDIFindNextLine
.b460	c9 c5		cmp #$c5			cmp 	#token_DATA 				; found data token
.b462	f0 43		beq $b4a7			beq 	_RGDISkipEvaluateExit 		; then skip it and evaluate
.b464	ea		nop				nop
.b465	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read element
.b467	1b		inz				inz 								; skip
.b468	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.b46a	90 0d		bcc $b479			bcc 	_SEDone 					; so just skip over it.
.b46c	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.b46e	90 08		bcc $b478			bcc 	_SEDouble
.b470	6b		tza				tza 								; this is Y + 1
.b471	18		clc				clc
.b472	ea		nop				nop
.b473	72 16		adc ($16),z			adc 	(zCodePtr),z 				; add total length of element
.b475	4b		taz				taz 								; back in Y.
.b476	3b		dez				dez 								; fix up, one for the +1, one for the iny
.b477	3b		dez				dez
.b478					_SEDouble:
.b478	1b		inz				inz
.b479					_SEDone:
.b479	80 de		bra $b459			bra 	_RGDIFindData
.b47b					_RGDIFindNextLine:
.b47b	a3 00		ldz #$00			ldz 	#0 							; point to offset
.b47d	ea		nop				nop
.b47e	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read it
.b480	18		clc				clc
.b481	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.b483	85 16		sta $16				sta 	zCodePtr
.b485	90 02		bcc $b489			bcc 	_SNLNoCarry
.b487	e6 17		inc $17				inc 	zCodePtr+1
.b489					_SNLNoCarry:
.b489	a3 00		ldz #$00			ldz 	#0
.b48b	ea		nop				nop
.b48c	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b48e	48		pha				pha
.b48f	1b		inz				inz
.b490	1b		inz				inz
.b491	1b		inz				inz
.b492	68		pla				pla
.b493	d0 c4		bne $b459			bne 	_RGDIFindData 				; back to scanning.
.b495	20 17 b4	jsr $b417			jsr 	ReadSwapPointers 			; so we get error in line number of READ
.b498	20 9e ae	jsr $ae9e			jsr ERR_Handler
>b49b	4f 75 74 20 6f 66 20 44			.text "Out of Data",0
>b4a3	61 74 61 00
.b4a7					_RGDISkipEvaluateExit:
.b4a7	1b		inz				inz
.b4a8	20 99 ba	jsr $ba99			jsr 	EvaluateExpression 			; evaluate the expression
.b4ab	20 17 b4	jsr $b417			jsr 	ReadSwapPointers 			; swap the pointers around.
.b4ae	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/let.asm

.b4af					Command_LET:
.b4af	20 43 c3	jsr $c343			jsr 	VariableFind 				; get reference to one variable.
.b4b2	a9 84		lda #$84			lda 	#token_Equal  				; get equals
.b4b4	20 78 c2	jsr $c278			jsr 	CheckNextToken
.b4b7	a5 22		lda $22				lda 	zVarDataPtr 				; save variable info on stack
.b4b9	48		pha				pha
.b4ba	a5 23		lda $23				lda 	zVarDataPtr+1
.b4bc	48		pha				pha
.b4bd	a5 24		lda $24				lda 	zVarType
.b4bf	48		pha				pha
.b4c0	20 99 ba	jsr $ba99			jsr 	EvaluateExpression 			; evaluate the RHS, set X to zero.
.b4c3	68		pla				pla 								; restore target variable information.
.b4c4	85 24		sta $24				sta 	zVarType
.b4c6	68		pla				pla
.b4c7	85 23		sta $23				sta 	zVarDataPtr+1
.b4c9	68		pla				pla
.b4ca	85 22		sta $22				sta 	zVarDataPtr
.b4cc	20 de c6	jsr $c6de			jsr 	VariableSet 				; set the value out.
.b4cf	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/get.asm

.b4d0					Command_GET:
.b4d0					_CGLoop:
.b4d0	20 43 c3	jsr $c343			jsr 	VariableFind 				; get a variable.
.b4d3	20 5a ae	jsr $ae5a			jsr 	VIOCharGet 					; get character
.b4d6	b0 02		bcs $b4da			bcs 	_CGNoKey
.b4d8	a9 00		lda #$00			lda 	#0 							; if no character return zero
.b4da					_CGNoKey:
.b4da	48		pha				pha
.b4db	a5 24		lda $24				lda 	zVarType 					; look at the data type.
.b4dd	c9 b7		cmp #$b7			cmp 	#token_Dollar
.b4df	f0 1f		beq $b500			beq 	_CGString
.b4e1	68		pla				pla 								; put character in slot.
.b4e2	85 80		sta $80				sta 	XS_Mantissa
.b4e4	a9 00		lda #$00			lda 	#0
.b4e6	85 81		sta $81				sta 	XS_Mantissa+1
.b4e8	85 82		sta $82				sta 	XS_Mantissa+2
.b4ea	85 83		sta $83				sta 	XS_Mantissa+3
.b4ec	a9 01		lda #$01			lda 	#1 							; type integer
.b4ee	85 85		sta $85				sta 	XS_Type
.b4f0					_CGWriteSetNext:
.b4f0	a2 00		ldx #$00			ldx 	#0 							; write number/WriteTempString out
.b4f2	20 de c6	jsr $c6de			jsr 	VariableSet
.b4f5	ea		nop				nop
.b4f6	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b4f8	c9 bf		cmp #$bf			cmp 	#token_Comma 				; if not comma exit
.b4fa	d0 03		bne $b4ff			bne 	_CGExit
.b4fc	1b		inz				inz
.b4fd	80 d1		bra $b4d0			bra 	_CGLoop 					; and get another.
.b4ff					_CGExit:
.b4ff	60		rts				rts
.b500					_CGString:
.b500	a9 02		lda #$02			lda 	#2 							; allocate temp string, space for 2.
.b502	20 df c2	jsr $c2df			jsr 	AllocateTempString 			; initially empty.
.b505	a5 20		lda $20				lda 	zTempStr 					; set up to be returned.
.b507	85 80		sta $80				sta 	XS_Mantissa
.b509	a5 21		lda $21				lda 	zTempStr+1
.b50b	85 81		sta $81				sta 	XS_Mantissa+1
.b50d	a9 02		lda #$02			lda 	#2
.b50f	85 85		sta $85				sta 	XS_Type
.b511	68		pla				pla 								; get A
.b512	c9 00		cmp #$00			cmp 	#0
.b514	f0 da		beq $b4f0			beq 	_CGWriteSetNext
.b516	20 0a c3	jsr $c30a			jsr 	WriteTempString 			; write it into string
.b519	80 d5		bra $b4f0			bra 	_CGWriteSetNext

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/sys.asm

.b51b					Command_SYS:
.b51b	20 36 bc	jsr $bc36			jsr 	EvaluateInteger 			; address to call.
.b51e	a5 80		lda $80				lda 	XS_Mantissa+0				; copy to localvector
.b520	8d 10 03	sta $0310			sta 	LocalVector+0 				; only three, can only do 24 bit calls
.b523	a5 81		lda $81				lda 	XS_Mantissa+1 				; and that only on 65816
.b525	8d 11 03	sta $0311			sta 	LocalVector+1
.b528	a5 82		lda $82				lda 	XS_Mantissa+2
.b52a	8d 12 03	sta $0312			sta 	LocalVector+2
.b52d	20 31 b5	jsr $b531			jsr 	_CSYLocalCall
.b530	60		rts				rts
.b531					_CSYLocalCall:
.b531	6c 10 03	jmp ($0310)			jmp 	(LocalVector)

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/input.asm

.b534					Command_INPUT:
.b534	a9 00		lda #$00		lda 	#0 								; clear number of characters required.
.b536	8d c2 03	sta $03c2		sta 	InputAvailable 					; save character count
.b539	8d c3 03	sta $03c3		sta 	InputRetry
.b53c					_CILoop:
.b53c	ea		nop				nop
.b53d	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b53f	c9 fe		cmp #$fe		cmp 	#$FE 							; is it a prompt string
.b541	d0 17		bne $b55a		bne 	_CINoPrompt
.b543	1b		inz				inz
.b544	ea		nop				nop
.b545	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b547	aa		tax			tax 									; into X
.b548	1b		inz				inz
.b549	ca		dex			dex 									; deduct marker/prompt length
.b54a	ca		dex			dex
.b54b	f0 ef		beq $b53c		beq 	_CILoop 						; nothing.
.b54d					_CIShowPrompt:
.b54d	ea		nop				nop
.b54e	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b550	20 57 ae	jsr $ae57		jsr 	VIOCharPrint
.b553	1b		inz				inz
.b554	ca		dex			dex
.b555	d0 f6		bne $b54d		bne 	_CIShowPrompt
.b557	80 e3		bra $b53c		bra 	_CILoop
.b559					_CIAdvance:
.b559	1b		inz				inz
.b55a					_CINoPrompt:
.b55a	ea		nop				nop
.b55b	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b55d	c9 bf		cmp #$bf		cmp 	#token_Comma 					; skip , and ;
.b55f	f0 f8		beq $b559		beq 	_CIAdvance
.b561	c9 c1		cmp #$c1		cmp 	#token_SemiColon
.b563	f0 f4		beq $b559		beq 	_CIAdvance
.b565	c9 00		cmp #$00		cmp 	#0 								; exit if 0 or :
.b567	f0 04		beq $b56d		beq 	_CIExit
.b569	c9 c0		cmp #$c0		cmp 	#token_Colon
.b56b	d0 01		bne $b56e		bne 	_CIIsVariable  					; if not then there#s a variable or should be !
.b56d					_CIExit:
.b56d	60		rts			rts
.b56e					_CIIsVariable:
.b56e	20 43 c3	jsr $c343		jsr 	VariableFind 					; set zVarType and zVarDataPtr accordingly.
.b571	ea		nop			nop
.b572	a5 24		lda $24			lda 	zVarType
.b574	c9 b7		cmp #$b7		cmp 	#token_Dollar 					; is it a string ?
.b576	f0 36		beq $b5ae		beq 	_CIIsString
.b578					_CINGetText:
.b578	a9 00		lda #$00		lda 	#0
.b57a	8d 14 03	sta $0314		sta 	NumBufX
.b57d					_CINSkip:
.b57d	20 af b5	jsr $b5af		jsr 	CIGetCharacter 					; get character skip spaces
.b580	c9 20		cmp #$20		cmp 	#" "
.b582	f0 f9		beq $b57d		beq 	_CINSkip
.b584					_CINLoop:
.b584	ae 14 03	ldx $0314		ldx 	NumBufX 						; output character
.b587	9d 15 03	sta $0315,x		sta 	Num_Buffer,x
.b58a	a9 00		lda #$00		lda 	#0 								; add trailing NULL
.b58c	9d 16 03	sta $0316,x		sta 	Num_Buffer+1,x
.b58f	ee 14 03	inc $0314		inc 	NumBufX 						; bump ptr
.b592	20 af b5	jsr $b5af		jsr 	CIGetCharacter 					; get next character
.b595	c9 3a		cmp #$3a		cmp 	#":"
.b597	f0 04		beq $b59d		beq 	_CINCopied
.b599	c9 21		cmp #$21		cmp 	#" "+1
.b59b	b0 e7		bcs $b584		bcs 	_CINLoop
.b59d					_CINCopied:
.b59d	a2 00		ldx #$00		ldx 	#0
.b59f	20 b6 bf	jsr $bfb6		jsr 	ConvertNumBuffer 				; convert number
.b5a2	20 de c6	jsr $c6de		jsr 	VariableSet 					; set variable.
.b5a5	80 95		bra $b53c		bra 	_CILoop 						; go round again.
.b5a7					_CINFailed:
.b5a7	a9 00		lda #$00		lda 	#0 								; set to request input next time.
.b5a9	8d c2 03	sta $03c2		sta 	InputAvailable
.b5ac	80 ca		bra $b578		bra 	_CINGetText 					; and try again
.b5ae					_CIIsString:
.b5ae	ea		nop			nop
.b5af					CIGetCharacter:
.b5af	ea		nop			nop

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/end.asm

.b5b0					Command_END:
.b5b0	80 fe		bra $b5b0	_halt:	bra 		_halt
.b5b2	4c 4d b1	jmp $b14d			jmp 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/if.asm

.b5b5					Command_IF:
.b5b5	20 36 bc	jsr $bc36			jsr 	EvaluateInteger 			; check success.
.b5b8	a5 80		lda $80				lda 	XS_Mantissa+0				; check the result if zero
.b5ba	05 81		ora $81				ora 	XS_Mantissa+1
.b5bc	05 82		ora $82				ora 	XS_Mantissa+2
.b5be	05 83		ora $83				ora 	XS_Mantissa+3
.b5c0	aa		tax				tax 								; put into X.
.b5c1	ea		nop				nop
.b5c2	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b5c4	c9 93		cmp #$93			cmp 	#token_Then 				; then found.
.b5c6	d0 30		bne $b5f8			bne 	_FIFExtended
.b5c8	1b		inz				inz
.b5c9	e0 00		cpx #$00			cpx 	#0 							; was it successful.
.b5cb	f0 0c		beq $b5d9			beq 	_FIFEndOfLine 				; if not, go to the end of the line.
.b5cd	ea		nop				nop
.b5ce	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b5d0	29 c0		and #$c0			and 	#$C0 						; is it a number
.b5d2	c9 40		cmp #$40			cmp 	#$40
.b5d4	d0 21		bne $b5f7			bne 	_FIFContinue 				; if not, do what ever follows.
.b5d6	4c 62 b9	jmp $b962			jmp		Command_GOTO 				; we have IF <expr> THEN <number> so we do GOTO code.
.b5d9					_FIFEndOfLine:
.b5d9	ea		nop				nop
.b5da	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b5dc	c9 00		cmp #$00			cmp 	#0 							; if zero, end of line, so exit
.b5de	f0 17		beq $b5f7			beq 	_FIFContinue
.b5e0	ea		nop				nop
.b5e1	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read element
.b5e3	1b		inz				inz 								; skip
.b5e4	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.b5e6	90 0d		bcc $b5f5			bcc 	_SEDone 					; so just skip over it.
.b5e8	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.b5ea	90 08		bcc $b5f4			bcc 	_SEDouble
.b5ec	6b		tza				tza 								; this is Y + 1
.b5ed	18		clc				clc
.b5ee	ea		nop				nop
.b5ef	72 16		adc ($16),z			adc 	(zCodePtr),z 				; add total length of element
.b5f1	4b		taz				taz 								; back in Y.
.b5f2	3b		dez				dez 								; fix up, one for the +1, one for the iny
.b5f3	3b		dez				dez
.b5f4					_SEDouble:
.b5f4	1b		inz				inz
.b5f5					_SEDone:
.b5f5	80 e2		bra $b5d9			bra 	_FIFEndOfLine
.b5f7					_FIFContinue:
.b5f7	60		rts				rts
.b5f8					_FIFExtended:
.b5f8	da		phx				phx 								; save result
.b5f9	a9 40		lda #$40			lda 	#(SMark_If << 4) 			; push marker on the stack, nothing else.
.b5fb	20 d7 ad	jsr $add7			jsr 	StackPushFrame
.b5fe	68		pla				pla 								; restore result
.b5ff	f0 01		beq $b602			beq 	_FIXSkip 					; if zero then it has failed.
.b601	60		rts				rts 								; test passed, so continue executing
.b602					_FIXSkip:
.b602	a9 94		lda #$94			lda 	#token_endif 				; scan forward till found either ELSE or ENDIF
.b604	a2 de		ldx #$de			ldx 	#token_else 				; at the same level.
.b606	20 12 ad	jsr $ad12			jsr 	StructureSearchDouble
.b609	ea		nop				nop
.b60a	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b60c	1b		inz				inz
.b60d	c9 94		cmp #$94			cmp 	#token_endif 				; if endif, handle endif code.
.b60f	f0 07		beq $b618			beq 	Command_ENDIF
.b611	60		rts				rts
.b612					Command_ELSE:
.b612	a9 94		lda #$94			lda 	#token_endif 				; scan forward till found ENDIF
.b614	20 10 ad	jsr $ad10			jsr 	StructureSearchSingle 		; then do the ENDIF pop.
.b617	1b		inz				inz
.b618					Command_ENDIF:
.b618	a9 40		lda #$40			lda 	#(SMark_If << 4)
.b61a	20 ee ad	jsr $adee			jsr 	StackPopFrame
.b61d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/list.asm

.b61e					Command_LIST:
.b61e	20 b7 b7	jsr $b7b7			jsr 	ListGetRange				; get any parameters
.b621	a9 00		lda #$00			lda 	#BasicProgram & $FF
.b623	85 16		sta $16				sta 	zCodePtr+0
.b625	a9 80		lda #$80			lda 	#BasicProgram >> 8
.b627	85 17		sta $17				sta 	zCodePtr+1
.b629	a9 02		lda #$02			lda 	#2
.b62b	85 18		sta $18				sta 	zCodePtr+2
.b62d	a9 00		lda #$00			lda 	#0
.b62f	85 19		sta $19				sta 	zCodePtr+3
.b631	a3 03		ldz #$03			ldz 	#3
.b633	a9 00		lda #$00			lda 	#0 							; reset the indent & last indent
.b635	8d bc 03	sta $03bc			sta 	LastListIndent
.b638	8d bb 03	sta $03bb			sta 	ListIndent
.b63b					_CILLoop:
.b63b	a3 00		ldz #$00			ldz 	#0
.b63d	ea		nop				nop
.b63e	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b640	c9 00		cmp #$00			cmp 	#0 							; if zero, end of program
.b642	f0 24		beq $b668			beq 	_CILExit
.b644	20 65 ae	jsr $ae65			jsr 	VIOCheckBreak 				; check break
.b647	c9 00		cmp #$00			cmp 	#0
.b649	d0 1d		bne $b668			bne 	_CILExit
.b64b	20 01 b8	jsr $b801			jsr 	ListCheckRange 				; check current line in range.
.b64e	b0 08		bcs $b658			bcs		_CILNext
.b650	a3 00		ldz #$00			ldz 	#0
.b652	1b		inz				inz
.b653	1b		inz				inz
.b654	1b		inz				inz
.b655	20 6b b6	jsr $b66b			jsr 	ListLine 					; list one line.
.b658					_CILNext:
.b658	a3 00		ldz #$00			ldz 	#0 							; point to offset
.b65a	ea		nop				nop
.b65b	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read it
.b65d	18		clc				clc
.b65e	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.b660	85 16		sta $16				sta 	zCodePtr
.b662	90 02		bcc $b666			bcc 	_SNLNoCarry
.b664	e6 17		inc $17				inc 	zCodePtr+1
.b666					_SNLNoCarry:
.b666	80 d3		bra $b63b			bra 	_CILLoop
.b668					_CILExit:
.b668	4c 4d b1	jmp $b14d			jmp 	WarmStart
.b66b					ListLine:
.b66b	ad bb 03	lda $03bb			lda 	ListIndent 					; copy current list indent -> last
.b66e	8d bc 03	sta $03bc			sta 	LastListIndent
.b671					_LICountIndent:
.b671	ea		nop				nop
.b672	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b674	c9 00		cmp #$00			cmp 	#0
.b676	f0 31		beq $b6a9			beq 	_LIDoneIndent
.b678	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus
.b67a	90 16		bcc $b692			bcc 	_LICINext
.b67c	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.b67e	b0 12		bcs $b692			bcs 	_LICINext
.b680	ee bb 03	inc $03bb			inc 	ListIndent
.b683	c9 93		cmp #$93			cmp 	#firstKeywordMinus
.b685	90 0b		bcc $b692			bcc 	_LICINext
.b687	ce bb 03	dec $03bb			dec 	ListIndent
.b68a	ce bb 03	dec $03bb			dec 	ListIndent
.b68d	10 03		bpl $b692			bpl 	_LICINext
.b68f	ee bb 03	inc $03bb			inc 	ListIndent
.b692					_LICINext:
.b692	ea		nop				nop
.b693	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read element
.b695	1b		inz				inz 								; skip
.b696	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.b698	90 0d		bcc $b6a7			bcc 	_SEDone 					; so just skip over it.
.b69a	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.b69c	90 08		bcc $b6a6			bcc 	_SEDouble
.b69e	6b		tza				tza 								; this is Y + 1
.b69f	18		clc				clc
.b6a0	ea		nop				nop
.b6a1	72 16		adc ($16),z			adc 	(zCodePtr),z 				; add total length of element
.b6a3	4b		taz				taz 								; back in Y.
.b6a4	3b		dez				dez 								; fix up, one for the +1, one for the iny
.b6a5	3b		dez				dez
.b6a6					_SEDouble:
.b6a6	1b		inz				inz
.b6a7					_SEDone:
.b6a7	80 c8		bra $b671			bra 	_LICountIndent
.b6a9					_LIDoneIndent:
.b6a9	a3 00		ldz #$00			ldz 	#0
.b6ab	1b		inz				inz
.b6ac	ea		nop				nop
.b6ad	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b6af	85 80		sta $80				sta 	XS_Mantissa
.b6b1	1b		inz				inz
.b6b2	ea		nop				nop
.b6b3	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b6b5	85 81		sta $81				sta 	XS_Mantissa+1
.b6b7	20 e2 ae	jsr $aee2			jsr 	Print16BitInteger 			; print integer.
.b6ba	85 10		sta $10				sta 	zTemp1 						; save spaces printed.
.b6bc	ad bb 03	lda $03bb			lda 	ListIndent 					; smaller of current/prev indent
.b6bf	cd bc 03	cmp $03bc			cmp 	LastListIndent
.b6c2	90 03		bcc $b6c7			bcc 	_LISmaller
.b6c4	ad bc 03	lda $03bc			lda 	LastListIndent
.b6c7					_LISmaller:
.b6c7	0a		asl a				asl 	a 							; double indent
.b6c8	49 ff		eor #$ff			eor 	#$FF 						; 2's complement arithmetic
.b6ca	38		sec				sec
.b6cb	65 10		adc $10				adc 	zTemp1 						; "subtract" indent e.g. print more.
.b6cd	aa		tax				tax 								; print spaces to column 6
.b6ce					_LISpace:
.b6ce	a9 20		lda #$20			lda 	#" "
.b6d0	20 a7 b7	jsr $b7a7			jsr 	ListPrintLC
.b6d3	e8		inx				inx
.b6d4	e0 06		cpx #$06			cpx 	#6
.b6d6	d0 f6		bne $b6ce			bne 	_LISpace
.b6d8					_LIDecode:
.b6d8	1b		inz				inz
.b6d9	ea		nop				nop
.b6da	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b6dc	c9 00		cmp #$00			cmp 	#0 							; zero, exit.
.b6de	f0 0f		beq $b6ef			beq 	_LIExit
.b6e0	30 12		bmi $b6f4			bmi 	_LIToken
.b6e2	c9 40		cmp #$40			cmp 	#$40 						; 01-$3F, character.
.b6e4	b0 52		bcs $b738			bcs 	_LIInteger
.b6e6	49 20		eor #$20			eor 	#$20 						; make 7 bit
.b6e8	69 20		adc #$20			adc 	#$20
.b6ea	20 a7 b7	jsr $b7a7			jsr 	ListPrintLC 				; print in LC
.b6ed	80 e9		bra $b6d8			bra 	_LIDecode
.b6ef					_LIExit:
.b6ef	a9 0d		lda #$0d			lda 	#13 						; print new line.
.b6f1	4c a7 b7	jmp $b7a7			jmp 	ListPrintLC
.b6f4					_LIToken:
.b6f4	c9 fc		cmp #$fc			cmp 	#$FC 						; $FC-$FF ?
.b6f6	90 4b		bcc $b743			bcc		_LICommandToken
.b6f8	48		pha				pha 								; save in case end
.b6f9	a2 22		ldx #$22			ldx 	#'"'						; print if $FE quoted string
.b6fb	c9 fe		cmp #$fe			cmp 	#$FE
.b6fd	f0 17		beq $b716			beq 	_LIPrint
.b6ff	a2 2e		ldx #$2e			ldx 	#'.'						; print if $FD decimals
.b701	c9 fd		cmp #$fd			cmp 	#$FD
.b703	f0 11		beq $b716			beq 	_LIPrint
.b705	a9 52		lda #$52			lda 	#'R'						; must be REM
.b707	20 a7 b7	jsr $b7a7			jsr 	ListPrintLC
.b70a	a9 45		lda #$45			lda 	#'E'
.b70c	20 a7 b7	jsr $b7a7			jsr 	ListPrintLC
.b70f	a9 4d		lda #$4d			lda 	#'M'
.b711	20 a7 b7	jsr $b7a7			jsr 	ListPrintLC
.b714	a2 20		ldx #$20			ldx 	#' '
.b716					_LIPrint:
.b716	8a		txa				txa
.b717	20 a7 b7	jsr $b7a7			jsr 	ListPrintLC
.b71a	1b		inz				inz
.b71b	ea		nop				nop
.b71c	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b71e	aa		tax				tax 								; put in X
.b71f	ca		dex				dex
.b720					_LILoop:
.b720	ca		dex				dex 								; exit when count reached zero.
.b721	f0 09		beq $b72c			beq 	_LIEnd
.b723	1b		inz				inz
.b724	ea		nop				nop
.b725	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b727	20 a7 b7	jsr $b7a7			jsr 	ListPrintLC
.b72a	80 f4		bra $b720			bra 	_LILoop
.b72c	68		pla		_LIEnd:	pla 								; get A back
.b72d	c9 fe		cmp #$fe			cmp 	#$FE 						; if '"' need closing quotes
.b72f	d0 a7		bne $b6d8			bne 	_LIDecode
.b731	a9 22		lda #$22			lda 	#'"'
.b733	20 a7 b7	jsr $b7a7			jsr 	ListPrintLC
.b736	80 a0		bra $b6d8			bra 	_LIDecode
.b738					_LIInteger:
.b738	a2 00		ldx #$00			ldx 	#0
.b73a	20 a4 bb	jsr $bba4			jsr 	EvaluateGetInteger 			; get an atom
.b73d	3b		dez				dez
.b73e	20 e8 ae	jsr $aee8			jsr 	Print32BitInteger 			; print integer.
.b741	80 95		bra $b6d8			bra 	_LIDecode
.b743					_LICommandToken:
.b743	5a		phy				phy 								; save Y
.b744	48		pha				pha 								; save token
.b745	a2 e0		ldx #$e0			ldx  	#KeywordText & $FF 			; address of keyword text table.
.b747	a9 af		lda #$af			lda 	(#KeywordText >> 8) & $FF
.b749	86 1a		stx $1a				stx 	zLTemp1
.b74b	85 1b		sta $1b				sta 	zLTemp1+1
.b74d	a9 00		lda #$00			lda 	(#KeywordText >> 16) & $FF 	; this is for 65816 (it's a table in code
.b74f	85 1c		sta $1c				sta 	zLTemp1+2 					; space) and won't affect a 6502 at all.
.b751	68		pla				pla 								; get token
.b752	29 7f		and #$7f			and 	#127 						; chuck bit 7.
.b754	f0 16		beq $b76c			beq 	_LIFoundToken
.b756	aa		tax				tax
.b757					_LITokenLoop:
.b757	a0 00		ldy #$00			ldy 	#0 							; last character not a token.
.b759					_LIFindEnd:
.b759	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b75b	c8		iny				iny
.b75c	0a		asl a				asl 	a
.b75d	90 fa		bcc $b759			bcc 	_LIFindEnd
.b75f	98		tya				tya 								; that is step to the next
.b760	18		clc				clc 								; we don't bother bumping the 3rd byte
.b761	65 1a		adc $1a				adc 	zLTemp1 					; here.
.b763	85 1a		sta $1a				sta 	zLTemp1
.b765	90 02		bcc $b769			bcc 	_LINoBump
.b767	e6 1b		inc $1b				inc 	zLTemp1+1
.b769					_LINoBump:
.b769	ca		dex				dex 								; no go round again.
.b76a	d0 eb		bne $b757			bne 	_LITokenLoop
.b76c					_LIFoundToken:
.b76c	a0 00		ldy #$00			ldy 	#0
.b76e					_LIPrintToken:
.b76e	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b770	c0 00		cpy #$00			cpy 	#0 							; see if needs prefix space
.b772	d0 16		bne $b78a			bne 	_LINoPrefixSpace
.b774	c9 41		cmp #$41			cmp 	#"A" 						; e.g. alphabetic token.
.b776	90 12		bcc $b78a			bcc 	_LINoPrefixSpace
.b778	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b77a	b0 0e		bcs $b78a			bcs 	_LINoPrefixSpace
.b77c	ae ba 03	ldx $03ba			ldx 	LastPrinted 				; if last was space not required
.b77f	e0 20		cpx #$20			cpx 	#" "
.b781	f0 07		beq $b78a			beq 	_LINoPrefixSpace
.b783	48		pha				pha
.b784	a9 20		lda #$20			lda 	#" "
.b786	20 a7 b7	jsr $b7a7			jsr 	ListPrintLC
.b789	68		pla				pla
.b78a					_LINoPrefixSpace:
.b78a	c8		iny				iny
.b78b	48		pha				pha 								; save it
.b78c	29 7f		and #$7f			and 	#$7F
.b78e	20 a7 b7	jsr $b7a7			jsr 	ListPrintLC
.b791	68		pla				pla
.b792	10 da		bpl $b76e			bpl 	_LIPrintToken 				; go back if not end
.b794	7a		ply				ply 								; restore Y
.b795	29 7f		and #$7f			and 	#$7F 						; if last char is a letter
.b797	c9 41		cmp #$41			cmp 	#"A"
.b799	90 09		bcc $b7a4			bcc 	_LINotLetter2
.b79b	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b79d	b0 05		bcs $b7a4			bcs 	_LINotLetter2
.b79f	a9 20		lda #$20			lda 	#" " 						; add spacing
.b7a1	20 a7 b7	jsr $b7a7			jsr 	ListPrintLC
.b7a4					_LINotLetter2:
.b7a4	4c d8 b6	jmp $b6d8			jmp 	_LIDecode
.b7a7					ListPrintLC:
.b7a7	8d ba 03	sta $03ba			sta 	LastPrinted
.b7aa	c9 41		cmp #$41			cmp 	#"A"
.b7ac	90 06		bcc $b7b4			bcc 	_LPLC0
.b7ae	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b7b0	b0 02		bcs $b7b4			bcs 	_LPLC0
.b7b2	69 20		adc #$20			adc 	#$20
.b7b4	4c 57 ae	jmp $ae57	_LPLC0:	jmp 	VIOCharPrint
.b7b7					ListGetRange:
.b7b7	a2 0b		ldx #$0b			ldx 	#XS_Size*2-1 				; clear first 2 slots back to defaults.
.b7b9					_LGRClear:
.b7b9	a9 00		lda #$00			lda 	#0
.b7bb	95 80		sta $80,x			sta 	XS_Mantissa,x
.b7bd	ca		dex				dex
.b7be	10 f9		bpl $b7b9			bpl 	_LGRClear
.b7c0	ea		nop				nop
.b7c1	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b7c3	c9 00		cmp #$00			cmp 	#0 							; nothing
.b7c5	f0 22		beq $b7e9			beq 	_LGRBlank
.b7c7	c9 c0		cmp #$c0			cmp 	#token_Colon 				; or colon
.b7c9	f0 1e		beq $b7e9			beq 	_LGRBlank
.b7cb	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma
.b7cd	f0 19		beq $b7e8			beq 	_LGREnd 					; then it's LIST ,x
.b7cf	20 36 bc	jsr $bc36			jsr 	EvaluateInteger 			; get the first number into bottom
.b7d2	ea		nop				nop
.b7d3	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b7d5	c9 bf		cmp #$bf			cmp 	#token_Comma
.b7d7	f0 0f		beq $b7e8			beq 	_LGREnd 					; then it is LIST a,b
.b7d9	a5 80		lda $80				lda 	XS_Mantissa+0 				; copy first to second LIST n is n,n
.b7db	85 86		sta $86				sta 	XS_Mantissa+XS_Size+0
.b7dd	a5 81		lda $81				lda 	XS_Mantissa+1
.b7df	85 87		sta $87				sta 	XS_Mantissa+XS_Size+1
.b7e1					_LGRBumpExit:
.b7e1	e6 86		inc $86				inc 	XS_Mantissa+XS_Size 		; bump it so we can use cc.
.b7e3	d0 02		bne $b7e7			bne 	_LGRBump2
.b7e5	e6 87		inc $87				inc 	XS_Mantissa+XS_Size+1
.b7e7					_LGRBump2:
.b7e7	60		rts				rts
.b7e8					_LGREnd:
.b7e8	1b		inz				inz
.b7e9					_LGRBlank:
.b7e9	a9 ff		lda #$ff			lda 	#$FF 						; default to the end.
.b7eb	85 86		sta $86				sta 	XS_Mantissa+XS_Size
.b7ed	85 87		sta $87				sta 	XS_Mantissa+XS_Size+1
.b7ef	ea		nop				nop
.b7f0	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b7f2	c9 00		cmp #$00			cmp 	#0
.b7f4	f0 f1		beq $b7e7			beq 	_LGRBump2
.b7f6	0a		asl a				asl 	a 							; if not a number, then exit (to end)
.b7f7	b0 ee		bcs $b7e7			bcs 	_LGRBump2
.b7f9	a2 06		ldx #$06			ldx 	#XS_Size 					; get to range
.b7fb	20 38 bc	jsr $bc38			jsr 	EvaluateIntegerX
.b7fe	80 e1		bra $b7e1			bra 	_LGRBumpExit
.b800	60		rts				rts
.b801					ListCheckRange:
.b801	1b		inz				inz
.b802	a2 00		ldx #$00			ldx 	#0 							; test low
.b804	20 11 b8	jsr $b811			jsr 	_LCRCompare
.b807	90 06		bcc $b80f			bcc 	_LCRFail
.b809	a2 06		ldx #$06			ldx 	#XS_Size 					; test high
.b80b	20 11 b8	jsr $b811			jsr 	_LCRCompare
.b80e	60		rts				rts
.b80f					_LCRFail:
.b80f	38		sec				sec
.b810	60		rts				rts
.b811					_LCRCompare:
.b811	ea		nop				nop
.b812	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b814	38		sec				sec
.b815	f5 80		sbc $80,x			sbc	 	XS_Mantissa+0,x
.b817	08		php				php
.b818	1b		inz				inz
.b819	ea		nop				nop
.b81a	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b81c	28		plp				plp
.b81d	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.b81f	08		php				php
.b820	3b		dez				dez
.b821	28		plp				plp
.b822	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/print.asm

.b823					Command_PRINT:
.b823					_CPR_Loop:
.b823	ea		nop				nop
.b824	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b826	c9 00		cmp #$00			cmp 	#0 							; end
.b828	f0 24		beq $b84e			beq 	_CPR_GoNewLine
.b82a	c9 c0		cmp #$c0			cmp 	#token_Colon
.b82c	f0 20		beq $b84e			beq 	_CPR_GoNewLine
.b82e	c9 c1		cmp #$c1			cmp 	#token_SemiColon
.b830	f0 74		beq $b8a6			beq 	_CPR_Skip
.b832	c9 bf		cmp #$bf			cmp 	#token_Comma
.b834	f0 57		beq $b88d			beq 	_CPR_Tab
.b836	20 99 ba	jsr $ba99			jsr 	EvaluateExpression 			; get expression.
.b839	a5 85		lda $85				lda 	XS_Type 					; get type.
.b83b	29 02		and #$02			and 	#2
.b83d	d0 27		bne $b866			bne 	_CPR_String 				; if type = 2 output as string.
.b83f					_CPR_Number:
.b83f	a9 00		lda #$00			lda 	#0 							; reset buffer index
.b841	8d 14 03	sta $0314			sta 	NumBufX
.b844	a5 85		lda $85				lda 	XS_Type 					; get type
.b846	4a		lsr a				lsr 	a
.b847	b0 08		bcs $b851			bcs 	_CPRInt 					; if msb set do as integer
.b849	20 9b cd	jsr $cd9b			jsr 	FPToString 					; call fp to str otherwise
.b84c	80 06		bra $b854			bra 	_CPRNPrint
.b84e					_CPR_GoNewLine:
.b84e	4c b5 b8	jmp $b8b5			jmp 	_CPR_NewLine
.b851	20 27 c8	jsr $c827	_CPRInt:jsr 	IntToString
.b854					_CPRNPrint:
.b854	ad 15 03	lda $0315			lda 	Num_Buffer 					; is first character -
.b857	c9 2d		cmp #$2d			cmp 	#"-"
.b859	f0 05		beq $b860			beq 	_CPRNoSpace
.b85b	a9 20		lda #$20			lda 	#" "						; print the leading space
.b85d	20 57 ae	jsr $ae57			jsr 	VIOCharPrint 				; so beloved of MS Basics.
.b860					_CPRNoSpace:
.b860	a2 14		ldx #$14			ldx 	#(Num_Buffer-1) & $FF
.b862	a9 03		lda #$03			lda 	#(Num_Buffer-1) >> 8
.b864	80 04		bra $b86a			bra 	_CPRPrint
.b866					_CPR_String:
.b866	a6 80		ldx $80				ldx 	XS_Mantissa
.b868	a5 81		lda $81				lda 	XS_Mantissa+1
.b86a					_CPRPrint:
.b86a	86 1e		stx $1e				stx 	zGenPtr
.b86c	85 1f		sta $1f				sta 	zGenPtr+1
.b86e	5a		phy				phy
.b86f	a0 00		ldy #$00			ldy 	#0							; get length into X
.b871	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b873	aa		tax				tax
.b874	f0 09		beq $b87f			beq 	_CPREndPrint 				; nothing to print
.b876					_CPRLoop:
.b876	c8		iny				iny
.b877	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b879	20 57 ae	jsr $ae57			jsr 	VIOCharPrint
.b87c	ca		dex				dex
.b87d	d0 f7		bne $b876			bne 	_CPRLoop
.b87f					_CPREndPrint:
.b87f	a5 85		lda $85				lda 	XS_Type 					; if numeric add trailing space
.b881	29 02		and #$02			and 	#2
.b883	d0 05		bne $b88a			bne 	_CPRNoTrail
.b885	a9 20		lda #$20			lda 	#" "
.b887	20 57 ae	jsr $ae57			jsr 	VIOCharPrint
.b88a					_CPRNoTrail:
.b88a	7a		ply				ply
.b88b	80 96		bra $b823			bra 	_CPR_Loop
.b88d					_CPR_Tab:
.b88d	20 68 ae	jsr $ae68			jsr 	VIOCharGetPosition 			; print until position % 8 = 0
.b890					_CPR_CalcSpaces:
.b890	38		sec				sec 								; calculate position mod 10.
.b891	e9 0a		sbc #$0a			sbc 	#10
.b893	b0 fb		bcs $b890			bcs 	_CPR_CalcSpaces
.b895	69 0a		adc #$0a			adc 	#10
.b897	f0 0d		beq $b8a6			beq 	_CPR_Skip 					; nothing to print
.b899	aa		tax				tax 								; print out spaces to mod 10
.b89a					_CPRTabSpaces:
.b89a	a9 20		lda #$20			lda 	#" "
.b89c	20 57 ae	jsr $ae57			jsr 	VIOCharPrint
.b89f	e8		inx				inx
.b8a0	e0 0a		cpx #$0a			cpx 	#10
.b8a2	d0 f6		bne $b89a			bne 	_CPRTabSpaces
.b8a4	80 e7		bra $b88d			bra 	_CPR_Tab
.b8a6					_CPR_Skip:
.b8a6	1b		inz				inz
.b8a7	ea		nop				nop
.b8a8	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b8aa	c9 c0		cmp #$c0			cmp 	#token_Colon 				; colon or $00, exit
.b8ac	f0 0c		beq $b8ba			beq 	_CPR_Exit
.b8ae	c9 00		cmp #$00			cmp 	#0
.b8b0	f0 08		beq $b8ba			beq 	_CPR_Exit 					; if not go round again.
.b8b2	4c 23 b8	jmp $b823			jmp 	_CPR_Loop
.b8b5					_CPR_NewLine:
.b8b5	a9 0d		lda #$0d			lda 	#13
.b8b7	20 57 ae	jsr $ae57			jsr 	VIOCharPrint
.b8ba					_CPR_Exit:
.b8ba	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/assert.asm

.b8bb					Command_ASSERT:
.b8bb	20 36 bc	jsr $bc36			jsr 	EvaluateInteger 			; calculate thing being asserted, 0=>X
.b8be	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; check if true (non-zero)
.b8c0	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.b8c2	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.b8c4	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.b8c6	f0 01		beq $b8c9			beq 	_ASFail
.b8c8	60		rts				rts
.b8c9					_ASFail:
.b8c9	20 9e ae	jsr $ae9e			jsr ERR_Handler
>b8cc	41 73 73 65 72 74 00			.text "Assert",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/poke.asm

.b8d3					Command_POKE:
.b8d3	a9 01		lda #$01			lda 	#1 							; 1 byte
.b8d5	80 06		bra $b8dd			bra 	CmdPoke_Main
.b8d7					Command_DOKE:
.b8d7	a9 02		lda #$02			lda 	#2 							; 2 bytes
.b8d9	80 02		bra $b8dd			bra 	CmdPoke_Main
.b8db					Command_LOKE:
.b8db	a9 04		lda #$04			lda 	#4							; 4 bytes
.b8dd					CmdPoke_Main:
.b8dd	48		pha				pha
.b8de	20 36 bc	jsr $bc36			jsr 	EvaluateInteger 			; get two parameters. First is address
.b8e1	e8		inx				inx
.b8e2	e8		inx				inx
.b8e3	e8		inx				inx
.b8e4	e8		inx				inx
.b8e5	e8		inx				inx
.b8e6	e8		inx				inx
.b8e7	20 99 c2	jsr $c299			jsr 	CheckNextComma
.b8ea	20 38 bc	jsr $bc38			jsr 	EvaluateIntegerX 			; second is the data.
.b8ed	a5 80		lda $80				lda 	XS_Mantissa+0 				; copy the mantissa into ZLTemp1 (address)
.b8ef	85 1a		sta $1a				sta 	zLTemp1
.b8f1	a5 81		lda $81				lda 	XS_Mantissa+1
.b8f3	85 1b		sta $1b				sta 	zLTemp1+1
.b8f5	a5 82		lda $82				lda 	XS_Mantissa+2
.b8f7	85 1c		sta $1c				sta 	zLTemp1+2
.b8f9	a5 83		lda $83				lda 	XS_Mantissa+3
.b8fb	85 1d		sta $1d				sta 	zLTemp1+3
.b8fd	68		pla				pla 								; get count
.b8fe	5a		phy				phy 								; save Y
.b8ff	20 1b c2	jsr $c21b			jsr 	MemWrite 					; write it out
.b902	7a		ply				ply 								; restore Y and done.
.b903	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/newold.asm

.b904					Command_NEW:
.b904	a9 00		lda #$00			lda 	#BasicProgram & $FF
.b906	85 16		sta $16				sta 	zCodePtr+0
.b908	a9 80		lda #$80			lda 	#BasicProgram >> 8
.b90a	85 17		sta $17				sta 	zCodePtr+1
.b90c	a9 02		lda #$02			lda 	#2
.b90e	85 18		sta $18				sta 	zCodePtr+2
.b910	a9 00		lda #$00			lda 	#0
.b912	85 19		sta $19				sta 	zCodePtr+3
.b914	a3 03		ldz #$03			ldz 	#3
.b916	a3 00		ldz #$00			ldz 	#0
.b918	a9 00		lda #$00			lda 	#0 							; write a 0 there.
.b91a	ea		nop				nop
.b91b	92 16		sta ($16),z			sta 	(zCodePtr),z
.b91d	20 2f c2	jsr $c22f			jsr 	UpdateProgramEnd 			; update program end.
.b920	4c 4d b1	jmp $b14d			jmp 	WarmStart
.b923					Command_OLD:
.b923	ea		nop				nop
.b924	a9 00		lda #$00			lda 	#BasicProgram & $FF
.b926	85 16		sta $16				sta 	zCodePtr+0
.b928	a9 80		lda #$80			lda 	#BasicProgram >> 8
.b92a	85 17		sta $17				sta 	zCodePtr+1
.b92c	a9 02		lda #$02			lda 	#2
.b92e	85 18		sta $18				sta 	zCodePtr+2
.b930	a9 00		lda #$00			lda 	#0
.b932	85 19		sta $19				sta 	zCodePtr+3
.b934	a3 03		ldz #$03			ldz 	#3
.b936					_COL_Find:
.b936	ea		nop				nop
.b937	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b939	1b		inz				inz
.b93a	c9 00		cmp #$00			cmp 	#0 							; if zero, then the position Y/Z is new offset
.b93c	f0 18		beq $b956			beq 	_COL_Found
.b93e	6b		tza				tza
.b93f	c9 00		cmp #$00			cmp 	#0
.b941	d0 f3		bne $b936			bne 	_COL_Find 					; can't find old EOL, give up.
.b943	20 9e ae	jsr $ae9e			jsr ERR_Handler
>b946	50 72 6f 67 72 61 6d 20			.text "Program Corrupt",0
>b94e	43 6f 72 72 75 70 74 00
.b956					_COL_Found:
.b956	6b		tza				tza
.b957	48		pha				pha
.b958	a3 00		ldz #$00			ldz 	#0
.b95a	68		pla				pla
.b95b	ea		nop				nop
.b95c	92 16		sta ($16),z			sta 	(zCodePtr),z
.b95e	20 2f c2	jsr $c22f			jsr 	UpdateProgramEnd 			; reset variable pointer
.b961	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/branch.asm

.b962					Command_GOTO:
.b962	20 b8 b9	jsr $b9b8			jsr 	GotoGetLineNumber
.b965					CmdGOTO:
.b965	a2 00		ldx #$00			ldx 	#0
.b967	4c d5 b9	jmp $b9d5			jmp 	GotoChangeToLineNumberX
.b96a					Command_GOSUB:
.b96a	20 b8 b9	jsr $b9b8			jsr 	GotoGetLineNumber
.b96d					CmdGOSUB:
.b96d	20 1e ae	jsr $ae1e			jsr 	StackSavePosition
.b970	a9 15		lda #$15			lda 	#(SMark_Gosub << 4)+SourcePosSize
.b972	20 d7 ad	jsr $add7			jsr 	StackPushFrame
.b975	a2 00		ldx #$00			ldx		#0
.b977	4c d5 b9	jmp $b9d5			jmp 	GotoChangeToLineNumberX
.b97a					Command_RETURN:
.b97a	a9 10		lda #$10			lda 	#(SMark_Gosub << 4)
.b97c	20 ee ad	jsr $adee			jsr 	StackPopFrame
.b97f	20 3b ae	jsr $ae3b			jsr 	StackRestorePosition
.b982	60		rts				rts
.b983					Command_ON:
.b983	a2 00		ldx #$00			ldx 	#0 							; get the ON.
.b985	20 db c0	jsr $c0db			jsr 	SLIByteParameter
.b988	a5 80		lda $80				lda 	XS_Mantissa+0 				; get the count
.b98a	f0 29		beq $b9b5			beq 	_CONFail 					; can't be zero.
.b98c	aa		tax				tax 								; save in X.
.b98d	ea		nop				nop
.b98e	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b990	1b		inz				inz
.b991	48		pha				pha
.b992	c9 cc		cmp #$cc			cmp 	#token_GOTO 				; must be GOTO or GOSUB
.b994	f0 07		beq $b99d			beq 	_CONOkayToken
.b996	c9 ca		cmp #$ca			cmp 	#token_GOSUB
.b998	f0 03		beq $b99d			beq 	_CONOkayToken
.b99a	4c 6f ae	jmp $ae6f			jmp 	SyntaxError
.b99d					_CONOkayToken:
.b99d	da		phx				phx 								; count on top, GOTO/GOSUB token 2nd.
.b99e					_CONFindNumber:
.b99e	20 b8 b9	jsr $b9b8			jsr 	GotoGetLineNumber 			; get a line number.
.b9a1	fa		plx				plx 								; restore count
.b9a2	ca		dex				dex  								; decrement, exit if zero.
.b9a3	f0 06		beq $b9ab			beq 	_CONFound
.b9a5	da		phx				phx 								; push back
.b9a6	20 99 c2	jsr $c299			jsr 	CheckNextComma				; check for comma
.b9a9	80 f3		bra $b99e			bra 	_CONFindNumber
.b9ab					_CONFound:
.b9ab	68		pla				pla 								; get token
.b9ac	c9 cc		cmp #$cc			cmp 	#token_GOTO 				; if GOTO
.b9ae	f0 b5		beq $b965			beq		CmdGOTO 					; then just branch.
.b9b0	20 a2 ad	jsr $ada2			jsr 	SkipEndOfCommand 			; go to end of command
.b9b3	80 b8		bra $b96d			bra 	CmdGOSUB 					; and do a GOSUB.
.b9b5					_CONFail:
.b9b5	4c 8d ae	jmp $ae8d			jmp 	BadParamError
.b9b8					GotoGetLineNumber:
.b9b8	20 36 bc	jsr $bc36			jsr 	EvaluateInteger
.b9bb	a5 82		lda $82				lda 	XS_Mantissa+2 				; check range
.b9bd	05 83		ora $83				ora 	XS_Mantissa+3
.b9bf	d0 01		bne $b9c2			bne 	_GLINError
.b9c1	60		rts				rts
.b9c2					_GLINError:
.b9c2	20 9e ae	jsr $ae9e			jsr ERR_Handler
>b9c5	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>b9cd	20 4e 75 6d 62 65 72 00
.b9d5					GotoChangeToLineNumberX:
.b9d5	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check line number not zero
.b9d7	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.b9d9	f0 3d		beq $ba18			beq 	_GCTLFail
.b9db	a9 00		lda #$00			lda 	#BasicProgram & $FF
.b9dd	85 16		sta $16				sta 	zCodePtr+0
.b9df	a9 80		lda #$80			lda 	#BasicProgram >> 8
.b9e1	85 17		sta $17				sta 	zCodePtr+1
.b9e3	a9 02		lda #$02			lda 	#2
.b9e5	85 18		sta $18				sta 	zCodePtr+2
.b9e7	a9 00		lda #$00			lda 	#0
.b9e9	85 19		sta $19				sta 	zCodePtr+3
.b9eb	a3 03		ldz #$03			ldz 	#3
.b9ed					_GCTLLoop:
.b9ed	a3 00		ldz #$00			ldz 	#0
.b9ef	ea		nop				nop
.b9f0	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b9f2	c9 00		cmp #$00			cmp 	#0
.b9f4	f0 22		beq $ba18			beq 	_GCTLFail
.b9f6	1b		inz				inz
.b9f7	ea		nop				nop
.b9f8	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b9fa	d5 80		cmp $80,x			cmp 	XS_Mantissa+0,x
.b9fc	d0 08		bne $ba06			bne 	_GCTLNext
.b9fe	1b		inz				inz
.b9ff	ea		nop				nop
.ba00	b2 16		lda ($16),z			lda 	(zCodePtr),z
.ba02	d5 81		cmp $81,x			cmp 	XS_Mantissa+1,x
.ba04	f0 10		beq $ba16			beq 	_GCTLExit
.ba06					_GCTLNext:
.ba06	a3 00		ldz #$00			ldz 	#0 							; point to offset
.ba08	ea		nop				nop
.ba09	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read it
.ba0b	18		clc				clc
.ba0c	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.ba0e	85 16		sta $16				sta 	zCodePtr
.ba10	90 02		bcc $ba14			bcc 	_SNLNoCarry
.ba12	e6 17		inc $17				inc 	zCodePtr+1
.ba14					_SNLNoCarry:
.ba14	80 d7		bra $b9ed			bra 	_GCTLLoop 					; try next line.
.ba16					_GCTLExit:
.ba16	1b		inz				inz
.ba17	60		rts				rts
.ba18					_GCTLFail:
.ba18	20 9e ae	jsr $ae9e			jsr ERR_Handler
>ba1b	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>ba23	20 4e 75 6d 62 65 72 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.ba2b					Command_CLR:
.ba2b					ResetRunStatus:
.ba2b	20 7f c3	jsr $c37f			jsr 	VariableClear
.ba2e	20 c5 ad	jsr $adc5			jsr 	StackReset
.ba31	a9 00		lda #$00			lda 	#HighMemory & $FF
.ba33	8d 00 03	sta $0300			sta 	StringPtr
.ba36	a9 7f		lda #$7f			lda 	#HighMemory >> 8
.ba38	8d 01 03	sta $0301			sta 	StringPtr+1
.ba3b	20 4b c5	jsr $c54b			jsr 	ArrayResetDefault
.ba3e	20 0c b4	jsr $b40c			jsr 	Command_RESTORE
.ba41	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/stop.asm

.ba42					Command_STOP:
.ba42	20 9e ae	jsr $ae9e			jsr ERR_Handler
>ba45	53 74 6f 70 00				.text "Stop",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/while.asm

.ba4a					Command_WHILE:
.ba4a	20 1e ae	jsr $ae1e			jsr 	StackSavePosition			; save position into stack, but don't yet push.
.ba4d	20 36 bc	jsr $bc36			jsr 	EvaluateInteger 			; calculate the while loop value.
.ba50	a5 80		lda $80				lda 	XS_Mantissa+0				; check the result if zero
.ba52	05 81		ora $81				ora 	XS_Mantissa+1
.ba54	05 82		ora $82				ora 	XS_Mantissa+2
.ba56	05 83		ora $83				ora 	XS_Mantissa+3
.ba58	f0 06		beq $ba60			beq 	_CWHSkip 					; if it is zero, then skip to WEND.
.ba5a	a9 35		lda #$35			lda 	#(SMark_While << 4)+SourcePosSize
.ba5c	20 d7 ad	jsr $add7			jsr 	StackPushFrame 				; push on stack
.ba5f	60		rts				rts
.ba60					_CWHSkip:
.ba60	a9 95		lda #$95			lda 	#token_Wend 				; look for the WEND token.
.ba62	20 10 ad	jsr $ad10			jsr 	StructureSearchSingle
.ba65	1b		inz				inz
.ba66	60		rts				rts
.ba67					Command_WEND:
.ba67	a9 30		lda #$30			lda 	#(SMark_While << 4)			; remove the frame
.ba69	20 ee ad	jsr $adee			jsr 	StackPopFrame
.ba6c	20 3b ae	jsr $ae3b			jsr 	StackRestorePosition
.ba6f	80 d9		bra $ba4a			bra 	Command_WHILE 				; and do the while again.
.ba71	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/repeat.asm

.ba72					Command_REPEAT:
.ba72	20 1e ae	jsr $ae1e			jsr 	StackSavePosition			; save position into stack
.ba75	a9 25		lda #$25			lda 	#(SMark_Repeat << 4)+SourcePosSize
.ba77	20 d7 ad	jsr $add7			jsr 	StackPushFrame 				; push on stack
.ba7a	60		rts				rts
.ba7b					Command_UNTIL:
.ba7b	a9 20		lda #$20			lda 	#(SMark_Repeat << 4)		; remove the frame
.ba7d	20 ee ad	jsr $adee			jsr 	StackPopFrame
.ba80	20 36 bc	jsr $bc36			jsr 	EvaluateInteger				; work out UNTIL
.ba83	a5 80		lda $80				lda 	XS_Mantissa+0 				; check if zero.
.ba85	05 81		ora $81				ora 	XS_Mantissa+1
.ba87	05 82		ora $82				ora 	XS_Mantissa+2
.ba89	05 83		ora $83				ora 	XS_Mantissa+3
.ba8b	d0 08		bne $ba95			bne 	_CUTExit 					; if not, just exit
.ba8d	20 3b ae	jsr $ae3b			jsr 	StackRestorePosition 		; otherwise loop round again.
.ba90	a9 25		lda #$25			lda 	#(SMark_Repeat << 4)+SourcePosSize
.ba92	20 d7 ad	jsr $add7			jsr 	StackPushFrame 				; fix the stack back.
.ba95					_CUTExit:
.ba95	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.ba96					EVESyntax:
.ba96	4c 6f ae	jmp $ae6f			jmp 	SyntaxError
.ba99					EvaluateExpression:
.ba99	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.ba9b					EvaluateExpressionX:
.ba9b	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.ba9d					EvaluateExpressionXA:
.ba9d	48		pha				pha 								; save precedence on stack.
.ba9e	ea		nop				nop
.ba9f	b2 16		lda ($16),z			lda 	(zCodePtr),z
.baa1	f0 f3		beq $ba96			beq 	EVESyntax 					; end of line, syntax error.
.baa3	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.baa5	b0 03		bcs $baaa			bcs 	_EVNotVariable
.baa7	4c 76 bb	jmp $bb76			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.baaa					_EVNotVariable:
.baaa	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.baac	90 e8		bcc $ba96			bcc 	EVESyntax
.baae	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.bab0	b0 59		bcs $bb0b			bcs 	_EVNotInteger
.bab2	20 a4 bb	jsr $bba4			jsr 	EvaluateGetInteger
.bab5					_EVCheckDecimal:
.bab5	ea		nop				nop
.bab6	b2 16		lda ($16),z			lda 	(zCodePtr),z
.bab8	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.baba	d0 05		bne $bac1			bne 	_EVGotAtom 					; no, get atom.
.babc					_EVIsDecimal:
.babc	20 cc bb	jsr $bbcc			jsr 	EVGetDecimal 				; extend to the decimal part.
.babf	80 00		bra $bac1			bra 	_EVGotAtom 					; and continue to got atom.
.bac1					_EVGotAtom:
.bac1	ea		nop				nop
.bac2	b2 16		lda ($16),z			lda 	(zCodePtr),z
.bac4	10 43		bpl $bb09			bpl 	_EVExitDrop 				; must be a token.
.bac6	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.bac8	b0 3f		bcs $bb09			bcs 	_EVExitDrop
.baca	68		pla				pla 								; get current precedence
.bacb	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.bacd	da		phx				phx 								; save X
.bace	ea		nop				nop
.bacf	b2 16		lda ($16),z			lda 	(zCodePtr),z
.bad1	aa		tax				tax 								; put in X
.bad2	bd 51 af	lda $af51,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.bad5	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.bad7	fa		plx				plx 								; restore X
.bad8	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.bada	90 2e		bcc $bb0a			bcc 	_EVExit 					; exit if too low.
.badc	f0 2c		beq $bb0a			beq 	_EVExit 					; exit if equals
.bade	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.bae0	48		pha				pha
.bae1	ea		nop				nop
.bae2	b2 16		lda ($16),z			lda 	(zCodePtr),z
.bae4	48		pha				pha
.bae5	1b		inz				inz
.bae6	da		phx				phx 								; save current position
.bae7	e8		inx				inx
.bae8	e8		inx				inx
.bae9	e8		inx				inx
.baea	e8		inx				inx
.baeb	e8		inx				inx
.baec	e8		inx				inx
.baed	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.baef	20 9d ba	jsr $ba9d			jsr 	EvaluateExpressionXA 		; do the RHS.
.baf2	fa		plx				plx 								; restore X
.baf3	68		pla				pla 								; get the binary operator in A.
.baf4					_EVCallA:
.baf4	da		phx				phx 								; save X again
.baf5	0a		asl a				asl 	a 							; double, lose the MSB.
.baf6	aa		tax				tax									; put in X
.baf7	bd 00 af	lda $af00,x			lda 	VectorTable,x 				; copy address into zGenPtr
.bafa	8d 11 03	sta $0311			sta 	LocalVector+1
.bafd	bd 01 af	lda $af01,x			lda 	VectorTable+1,x
.bb00	8d 12 03	sta $0312			sta 	LocalVector+2
.bb03	fa		plx				plx 								; restore X
.bb04	20 7f bb	jsr $bb7f			jsr 	EVCallLocalVector
.bb07	80 b8		bra $bac1			bra 	_EVGotAtom 					; and loop back.
.bb09					_EVExitDrop:
.bb09	68		pla				pla
.bb0a					_EVExit:
.bb0a	60		rts				rts
.bb0b					_EVNotInteger:
.bb0b	1b		inz				inz
.bb0c	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.bb0e	d0 16		bne $bb26			bne 	_EVNotMinus
.bb10	20 17 bc	jsr $bc17			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.bb13	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.bb15	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.bb17	f0 05		beq $bb1e			beq 	_EVMinusFloat
.bb19	20 0a c8	jsr $c80a			jsr 	IntegerNegateAlways 		; negation
.bb1c	80 a3		bra $bac1			bra 	_EVGotAtom 					; and go back.
.bb1e					_EVMinusFloat:
.bb1e	b5 85		lda $85,x			lda 	XS_Type,x 					; invert the sign bit.
.bb20	49 80		eor #$80			eor 	#$80
.bb22	95 85		sta $85,x			sta 	XS_Type,x
.bb24	80 9b		bra $bac1			bra 	_EVGotAtom
.bb26					_EVNotMinus:
.bb26	c9 bd		cmp #$bd			cmp 	#token_lparen 				; is it left parenthesis
.bb28	d0 18		bne $bb42			bne 	_EVNotParenthesis
.bb2a	20 9b ba	jsr $ba9b			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.bb2d	ea		nop				nop
.bb2e	b2 16		lda ($16),z			lda 	(zCodePtr),z
.bb30	1b		inz				inz
.bb31	c9 be		cmp #$be			cmp 	#token_rparen 				; okay if right bracket.
.bb33	f0 8c		beq $bac1			beq 	_EVGotAtom
.bb35	20 9e ae	jsr $ae9e			jsr ERR_Handler
>bb38	4d 69 73 73 69 6e 67 20			.text "Missing )",0
>bb40	29 00
.bb42					_EVNotParenthesis:
.bb42	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.bb44	d0 0c		bne $bb52			bne 	_EVNotNot
.bb46	20 17 bc	jsr $bc17			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.bb49	20 9c cc	jsr $cc9c			jsr 	FPUToInteger 				; make it an integer - if possible.
.bb4c	20 fc bb	jsr $bbfc			jsr 	NotInteger 					; do the not calculation
.bb4f	4c c1 ba	jmp $bac1			jmp 	_EVGotAtom
.bb52					_EVNotNot:
.bb52	c9 fe		cmp #$fe			cmp 	#$FE
.bb54	d0 12		bne $bb68			bne 	_EVNotString
.bb56	20 1a c3	jsr $c31a			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.bb59	a5 20		lda $20				lda 	zTempStr 					; copy address of string into mantissa
.bb5b	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.bb5d	a5 21		lda $21				lda 	zTempStr+1
.bb5f	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bb61	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.bb63	95 85		sta $85,x			sta 	XS_Type,x
.bb65	4c c1 ba	jmp $bac1			jmp 	_EVGotAtom
.bb68					_EVNotString:
.bb68	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.bb6a	90 04		bcc $bb70			bcc 	_EVBadElement
.bb6c	c9 b7		cmp #$b7			cmp 	#lastUnaryFunction+1
.bb6e	90 03		bcc $bb73			bcc 	_EVUnaryFunction
.bb70					_EVBadElement:
.bb70	4c 6f ae	jmp $ae6f			jmp 	SyntaxError
.bb73					_EVUnaryFunction:
.bb73	4c f4 ba	jmp $baf4			jmp 	_EVCallA
.bb76					_EVVariableHandler:
.bb76	20 43 c3	jsr $c343			jsr 	VariableFind 				; locate a variable
.bb79	20 8d c6	jsr $c68d			jsr 	VariableGet 				; copy into memory.
.bb7c	4c c1 ba	jmp $bac1			jmp 	_EVGotAtom 					; and go round.
.bb7f					EVCallLocalVector:
.bb7f	6c 11 03	jmp ($0311)			jmp 	(LocalVector+1)
.bb82					EVShiftMantissaLeft6:
.bb82	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.bb84	95 84		sta $84,x			sta 	XS_Exponent,x
.bb86	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.bb88	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.bb8a	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bb8c	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.bb8e	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.bb90	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bb92	a9 00		lda #$00			lda 	#0
.bb94	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.bb96	20 99 bb	jsr $bb99			jsr 	_EVSMLShift 					; call it here to do it twice
.bb99					_EVSMLShift:
.bb99	56 84		lsr $84,x			lsr 	XS_Exponent,x
.bb9b	76 83		ror $83,x			ror 	XS_Mantissa+3,x
.bb9d	76 82		ror $82,x			ror 	XS_Mantissa+2,x
.bb9f	76 81		ror $81,x			ror 	XS_Mantissa+1,x
.bba1	76 80		ror $80,x			ror 	XS_Mantissa+0,x
.bba3	60		rts				rts
.bba4					EvaluateGetInteger:
.bba4	ea		nop				nop
.bba5	b2 16		lda ($16),z			lda 	(zCodePtr),z
.bba7	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.bba9	95 80		sta $80,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.bbab	a9 00		lda #$00			lda 	#0
.bbad	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bbaf	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.bbb1	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.bbb3	1a		inc a				inc 	a 							; set to type 1 (integer)
.bbb4	95 85		sta $85,x			sta 	XS_Type,x
.bbb6					_EVCheckNextInteger:
.bbb6	1b		inz				inz
.bbb7	ea		nop				nop
.bbb8	b2 16		lda ($16),z			lda 	(zCodePtr),z
.bbba	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.bbbc	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.bbbe	b0 0b		bcs $bbcb			bcs 	_EVEndInteger
.bbc0	48		pha				pha 								; save it.
.bbc1	20 82 bb	jsr $bb82			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.bbc4	68		pla				pla
.bbc5	15 80		ora $80,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.bbc7	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.bbc9	80 eb		bra $bbb6			bra 	_EVCheckNextInteger
.bbcb					_EVEndInteger:
.bbcb	60		rts				rts
.bbcc					EVGetDecimal:
.bbcc	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.bbce	8d 15 03	sta $0315			sta 	Num_Buffer
.bbd1	da		phx				phx
.bbd2	1b		inz				inz
.bbd3	ea		nop				nop
.bbd4	b2 16		lda ($16),z			lda 	(zCodePtr),z
.bbd6	1b		inz				inz
.bbd7	3a		dec a				dec 	a								; convert to a string length.
.bbd8	3a		dec a				dec 	a
.bbd9	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.bbdb					_EVGDCopy:
.bbdb	48		pha				pha 									; save count
.bbdc	ea		nop				nop
.bbdd	b2 16		lda ($16),z			lda 	(zCodePtr),z
.bbdf	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.bbe2	e8		inx				inx 									; forward ....
.bbe3	1b		inz				inz
.bbe4	68		pla				pla 									; get count
.bbe5	3a		dec a				dec 	a 								; until zero
.bbe6	d0 f3		bne $bbdb			bne 	_EVGDCopy
.bbe8	9d 15 03	sta $0315,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.bbeb	fa		plx				plx 									; restore X
.bbec	a9 15		lda #$15			lda 	#Num_Buffer & $FF 				; set zGenPtr
.bbee	85 1e		sta $1e				sta 	zGenPtr
.bbf0	a9 03		lda #$03			lda 	#Num_Buffer >> 8
.bbf2	85 1f		sta $1f				sta 	zGenPtr+1
.bbf4	5a		phy				phy 									; save Y
.bbf5	a0 00		ldy #$00			ldy 	#0 								; start position
.bbf7	20 56 ce	jsr $ce56			jsr 	FPFromString 					; convert current
.bbfa	7a		ply				ply 									; restore Y
.bbfb	60		rts				rts
.bbfc					NotInteger:
.bbfc	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.bbfe	49 ff		eor #$ff			eor 	#$FF
.bc00	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.bc02	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bc04	49 ff		eor #$ff			eor 	#$FF
.bc06	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bc08	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.bc0a	49 ff		eor #$ff			eor 	#$FF
.bc0c	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.bc0e	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.bc10	49 ff		eor #$ff			eor 	#$FF
.bc12	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.bc14	60		rts				rts
.bc15					EvaluateGetAtom:
.bc15	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.bc17					EvaluateGetAtomX:
.bc17	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.bc19	20 9d ba	jsr $ba9d			jsr 	EvaluateExpressionXA
.bc1c	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.bc1e	29 0f		and #$0f			and 	#15
.bc20	c9 02		cmp #$02			cmp 	#2
.bc22	b0 01		bcs $bc25			bcs 	EvaluateType
.bc24	60		rts				rts
.bc25					EvaluateType:
.bc25	4c 7f ae	jmp $ae7f			jmp 	TypeError
.bc28					EvaluateNumber:
.bc28	a2 00		ldx #$00			ldx 	#0
.bc2a					EvaluateNumberX:
.bc2a	20 9b ba	jsr $ba9b			jsr 	EvaluateExpressionX
.bc2d	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0/1
.bc2f	29 0f		and #$0f			and 	#15
.bc31	c9 02		cmp #$02			cmp 	#2
.bc33	b0 f0		bcs $bc25			bcs 	EvaluateType
.bc35	60		rts				rts
.bc36					EvaluateInteger:
.bc36	a2 00		ldx #$00			ldx 	#0
.bc38					EvaluateIntegerX:
.bc38	20 2a bc	jsr $bc2a			jsr 	EvaluateNumberX
.bc3b	20 9c cc	jsr $cc9c			jsr 	FPUToInteger
.bc3e	60		rts				rts
.bc3f					EvaluateString:
.bc3f	a2 00		ldx #$00			ldx 	#0
.bc41					EvaluateStringX:
.bc41	20 9b ba	jsr $ba9b			jsr 	EvaluateExpressionX
.bc44	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 2
.bc46	29 0f		and #$0f			and 	#15
.bc48	c9 02		cmp #$02			cmp 	#2
.bc4a	d0 d9		bne $bc25			bne 	EvaluateType
.bc4c	b5 80		lda $80,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.bc4e	85 1e		sta $1e				sta 	zGenPtr
.bc50	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bc52	85 1f		sta $1f				sta 	zGenPtr+1
.bc54	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.bc55					BinaryOp_And:
.bc55	20 a9 bc	jsr $bca9			jsr 	BinaryMakeBothInteger
.bc58	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.bc5a	35 86		and $86,x			and 	XS2_Mantissa+0,x
.bc5c	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.bc5e	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.bc60	35 87		and $87,x			and 	XS2_Mantissa+1,x
.bc62	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bc64	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.bc66	35 88		and $88,x			and 	XS2_Mantissa+2,x
.bc68	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.bc6a	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.bc6c	35 89		and $89,x			and 	XS2_Mantissa+3,x
.bc6e	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.bc70	60		rts				rts
.bc71					BinaryOp_Or:
.bc71	20 a9 bc	jsr $bca9			jsr 	BinaryMakeBothInteger
.bc74	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.bc76	15 86		ora $86,x			ora 	XS2_Mantissa+0,x
.bc78	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.bc7a	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.bc7c	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.bc7e	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bc80	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.bc82	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.bc84	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.bc86	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.bc88	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.bc8a	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.bc8c	60		rts				rts
.bc8d					BinaryOp_Eor:
.bc8d					BinaryOp_Xor:
.bc8d	20 a9 bc	jsr $bca9			jsr 	BinaryMakeBothInteger
.bc90	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.bc92	55 86		eor $86,x			eor 	XS2_Mantissa+0,x
.bc94	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.bc96	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.bc98	55 87		eor $87,x			eor 	XS2_Mantissa+1,x
.bc9a	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bc9c	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.bc9e	55 88		eor $88,x			eor 	XS2_Mantissa+2,x
.bca0	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.bca2	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.bca4	55 89		eor $89,x			eor 	XS2_Mantissa+3,x
.bca6	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.bca8	60		rts				rts
.bca9					BinaryMakeBothInteger:
.bca9	da		phx				phx 								; save X
.bcaa	e8		inx				inx
.bcab	e8		inx				inx
.bcac	e8		inx				inx
.bcad	e8		inx				inx
.bcae	e8		inx				inx
.bcaf	e8		inx				inx
.bcb0	20 b4 bc	jsr $bcb4			jsr 	BinaryMakeInteger 			; convert to integer.
.bcb3	fa		plx				plx 								; restore X and fall through.
.bcb4					BinaryMakeInteger:
.bcb4	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.bcb6	29 0f		and #$0f			and 	#15 						; check type zero
.bcb8	f0 04		beq $bcbe			beq 	_BMIConvert 				; if float convert to integer.
.bcba	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.bcbb	90 04		bcc $bcc1			bcc 	_BMIError
.bcbd	60		rts				rts
.bcbe					_BMIConvert:
.bcbe	4c 9c cc	jmp $cc9c			jmp 	FPUToInteger 				; convert to integer
.bcc1					_BMIError:
.bcc1	4c 7f ae	jmp $ae7f			jmp 	TypeError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.bcc4					Binary_Equal:
.bcc4	20 0d bd	jsr $bd0d			jsr 	CompareValues 				; compare the values
.bcc7	09 00		ora #$00			ora 	#0 							; true if 0
.bcc9	f0 33		beq $bcfe			beq 	CCTrue
.bccb	80 2d		bra $bcfa			bra 	CCFalse
.bccd					Binary_NotEqual:
.bccd	20 0d bd	jsr $bd0d			jsr 	CompareValues
.bcd0	09 00		ora #$00			ora 	#0 							; true if -1 or 1
.bcd2	f0 26		beq $bcfa			beq 	CCFalse
.bcd4	80 28		bra $bcfe			bra 	CCTrue
.bcd6					Binary_Less:
.bcd6	20 0d bd	jsr $bd0d			jsr 	CompareValues
.bcd9	09 00		ora #$00			ora 	#0 							; true if -1
.bcdb	30 21		bmi $bcfe			bmi 	CCTrue
.bcdd	80 1b		bra $bcfa			bra 	CCFalse
.bcdf					Binary_LessEqual:
.bcdf	20 0d bd	jsr $bd0d			jsr 	CompareValues
.bce2	c9 01		cmp #$01			cmp 	#1 							; true if 0 or -1
.bce4	d0 18		bne $bcfe			bne 	CCTrue
.bce6	80 12		bra $bcfa			bra 	CCFalse
.bce8					Binary_GreaterEqual:
.bce8	20 0d bd	jsr $bd0d			jsr 	CompareValues
.bceb	09 00		ora #$00			ora 	#0 							; true if 0 or 1
.bced	10 0f		bpl $bcfe			bpl 	CCTrue
.bcef	80 09		bra $bcfa			bra 	CCFalse
.bcf1					Binary_Greater:
.bcf1	20 0d bd	jsr $bd0d			jsr 	CompareValues 				; true if 1
.bcf4	c9 01		cmp #$01			cmp 	#1
.bcf6	f0 06		beq $bcfe			beq 	CCTrue
.bcf8	80 00		bra $bcfa			bra 	CCFalse
.bcfa	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.bcfc	80 02		bra $bd00			bra 	CCWrite
.bcfe	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.bd00	95 80		sta $80,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.bd02	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bd04	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.bd06	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.bd08	a9 01		lda #$01			lda 	#1
.bd0a	95 85		sta $85,x			sta 	XS_Type,x 					; set type to integer whatever.
.bd0c	60		rts				rts
.bd0d					CompareValues:
.bd0d	b5 85		lda $85,x			lda 	XS_Type,x 					; and the types together
.bd0f	35 8b		and $8b,x			and 	XS2_Type,x
.bd11	c9 02		cmp #$02			cmp 	#2 							; is it a string, then do the string
.bd13	f0 11		beq $bd26			beq 	_CVString					; comparison routine.
.bd15	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.bd17	35 8b		and $8b,x			and 	XS2_Type,x
.bd19	4a		lsr a				lsr 	a 							; shift bit 0 into C
.bd1a	90 03		bcc $bd1f			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.bd1c	4c 68 bd	jmp $bd68			jmp 	CompareInteger32 							; so execute code at \1
.bd1f					_BCFloat:
.bd1f	20 0c be	jsr $be0c			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.bd22	4c 95 cb	jmp $cb95			jmp 	FPCompare 							; and execute code at \2
.bd25	60		rts				rts
.bd26					_CVString:
.bd26	da		phx				phx 								; save XY
.bd27	5a		phy				phy
.bd28	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.bd2a	85 1a		sta $1a				sta		zLTemp1+0
.bd2c	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bd2e	85 1b		sta $1b				sta 	zLTemp1+1
.bd30	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.bd32	85 1c		sta $1c				sta 	zLTemp1+2
.bd34	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.bd36	85 1d		sta $1d				sta 	zLTemp1+3
.bd38	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.bd3a	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.bd3c	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.bd3e	90 02		bcc $bd42			bcc 	_CVCommon
.bd40	b1 1c		lda ($1c),y			lda 	(zLTemp1+2),y
.bd42					_CVCommon:
.bd42	aa		tax				tax 								; put shorter string length in zero.
.bd43	f0 0c		beq $bd51			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.bd45					_CVCompare:
.bd45	c8		iny				iny 								; next character
.bd46	b1 1a		lda ($1a),y			lda 	(zLTemp1),y 				; compare characters
.bd48	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y 				; handle different values, < or >
.bd4a	90 13		bcc $bd5f			bcc 	_CVReturnLess 				; <
.bd4c	d0 15		bne $bd63			bne 	_CVReturnGreater 			; >
.bd4e	ca		dex				dex 								; until common length matched.
.bd4f	d0 f4		bne $bd45			bne 	_CVCompare
.bd51					_CVMatch:
.bd51	a0 00		ldy #$00			ldy 	#0
.bd53	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.bd55	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.bd57	90 06		bcc $bd5f			bcc 	_CVReturnLess 				; <
.bd59	d0 08		bne $bd63			bne 	_CVReturnGreater 			; >
.bd5b	a9 00		lda #$00			lda 	#0
.bd5d	80 06		bra $bd65			bra 	_CVExit
.bd5f					_CVReturnLess:
.bd5f	a9 ff		lda #$ff			lda 	#$FF
.bd61	80 02		bra $bd65			bra 	_CVExit
.bd63					_CVReturnGreater:
.bd63	a9 01		lda #$01			lda 	#$01
.bd65					_CVExit:
.bd65	7a		ply				ply
.bd66	fa		plx				plx
.bd67	60		rts				rts
.bd68					CompareInteger32:
.bd68	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.bd6a	49 80		eor #$80			eor 	#$80
.bd6c	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.bd6e	b5 89		lda $89,x			lda 	XS2_Mantissa+3,x
.bd70	49 80		eor #$80			eor 	#$80
.bd72	95 89		sta $89,x			sta 	XS2_Mantissa+3,x
.bd74	20 f2 bd	jsr $bdf2			jsr 	SubInteger32 				; subtraction
.bd77	90 0d		bcc $bd86			bcc 	_CI32Less 					; cc return -1
.bd79	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check if zero
.bd7b	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.bd7d	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.bd7f	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.bd81	f0 02		beq $bd85			beq 	_CI32Exit
.bd83	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.bd85					_CI32Exit:
.bd85	60		rts				rts
.bd86					_CI32Less:
.bd86	a9 ff		lda #$ff			lda 	#$FF
.bd88	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.bd89					BinaryOp_Add:
.bd89	b5 85		lda $85,x			lda 	XS_Type,x  					; and types together
.bd8b	35 8b		and $8b,x			and 	XS2_Type,x
.bd8d	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.bd8f	d0 11		bne $bda2			bne 	_BOAString 					; so go do the string code.
.bd91	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.bd93	35 8b		and $8b,x			and 	XS2_Type,x
.bd95	4a		lsr a				lsr 	a 							; shift bit 0 into C
.bd96	90 03		bcc $bd9b			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.bd98	4c d8 bd	jmp $bdd8			jmp 	AddInteger32 							; so execute code at \1
.bd9b					_BCFloat:
.bd9b	20 0c be	jsr $be0c			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.bd9e	4c 70 c9	jmp $c970			jmp 	FPAdd 							; and execute code at \2
.bda1	60		rts				rts
.bda2					_BOAString:
.bda2	4c 26 be	jmp $be26			jmp 	ConcatenateString 			; concatenate two strings.
.bda5					BinaryOp_Subtract:
.bda5	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.bda7	35 8b		and $8b,x			and 	XS2_Type,x
.bda9	4a		lsr a				lsr 	a 							; shift bit 0 into C
.bdaa	90 03		bcc $bdaf			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.bdac	4c f2 bd	jmp $bdf2			jmp 	SubInteger32 							; so execute code at \1
.bdaf					_BCFloat:
.bdaf	20 0c be	jsr $be0c			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.bdb2	4c 68 c9	jmp $c968			jmp 	FPSubtract 							; and execute code at \2
.bdb5	60		rts				rts
.bdb6					BinaryOp_Multiply:
.bdb6	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.bdb8	35 8b		and $8b,x			and 	XS2_Type,x
.bdba	4a		lsr a				lsr 	a 							; shift bit 0 into C
.bdbb	90 03		bcc $bdc0			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.bdbd	4c 45 c7	jmp $c745			jmp 	MulInteger32 							; so execute code at \1
.bdc0					_BCFloat:
.bdc0	20 0c be	jsr $be0c			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.bdc3	4c 97 ca	jmp $ca97			jmp 	FPMultiply 							; and execute code at \2
.bdc6	60		rts				rts
.bdc7					BinaryOp_Divide:
.bdc7	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.bdc9	35 8b		and $8b,x			and 	XS2_Type,x
.bdcb	4a		lsr a				lsr 	a 							; shift bit 0 into C
.bdcc	90 03		bcc $bdd1			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.bdce	4c 83 c7	jmp $c783			jmp 	DivInteger32 							; so execute code at \1
.bdd1					_BCFloat:
.bdd1	20 0c be	jsr $be0c			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.bdd4	4c 24 ca	jmp $ca24			jmp 	FPDivide 							; and execute code at \2
.bdd7	60		rts				rts
.bdd8					AddInteger32:
.bdd8	18		clc				clc
.bdd9	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.bddb	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.bddd	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.bddf	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bde1	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.bde3	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bde5	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.bde7	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.bde9	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.bdeb	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.bded	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.bdef	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.bdf1	60		rts				rts
.bdf2					SubInteger32:
.bdf2	38		sec				sec
.bdf3	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.bdf5	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.bdf7	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.bdf9	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bdfb	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.bdfd	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bdff	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.be01	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.be03	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.be05	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.be07	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.be09	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.be0b	60		rts				rts
.be0c					BinaryMakeBothFloat:
.be0c	da		phx				phx 								; save X
.be0d	e8		inx				inx
.be0e	e8		inx				inx
.be0f	e8		inx				inx
.be10	e8		inx				inx
.be11	e8		inx				inx
.be12	e8		inx				inx
.be13	20 17 be	jsr $be17			jsr 	BinaryMakeFloat 			; convert to float.
.be16	fa		plx				plx 								; restore X and fall through.
.be17					BinaryMakeFloat:
.be17	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.be19	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.be1a	b0 04		bcs $be20			bcs 	_BMFConvert
.be1c	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.be1d	b0 04		bcs $be23			bcs 	_BMFError
.be1f	60		rts				rts
.be20					_BMFConvert:
.be20	4c 50 cc	jmp $cc50			jmp 	FPUToFloat 					; convert to float, only float builds of course
.be23					_BMFError:
.be23	4c 7f ae	jmp $ae7f			jmp 	TypeError
.be26					ConcatenateString:
.be26	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.be28	85 1a		sta $1a				sta		zLTemp1+0
.be2a	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.be2c	85 1b		sta $1b				sta 	zLTemp1+1
.be2e	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.be30	85 1c		sta $1c				sta 	zLTemp1+2
.be32	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.be34	85 1d		sta $1d				sta 	zLTemp1+3
.be36	5a		phy				phy
.be37	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.be39	b1 1a		lda ($1a),y			lda 	(zlTemp1),y
.be3b	71 1c		adc ($1c),y			adc 	(zlTemp1+2),y
.be3d	7a		ply				ply
.be3e	b0 33		bcs $be73			bcs 	_CSError					; check in range.
.be40	c9 fe		cmp #$fe			cmp 	#maxString+1
.be42	b0 2f		bcs $be73			bcs 	_CSError
.be44	20 df c2	jsr $c2df			jsr 	AllocateTempString 			; store the result
.be47	20 5e be	jsr $be5e			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.be4a	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.be4c	85 1a		sta $1a				sta 	zLTemp1
.be4e	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.be50	85 1b		sta $1b				sta 	zLTemp1+1
.be52	20 5e be	jsr $be5e			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.be55	a5 20		lda $20				lda 	zTempStr 					; point current to new string
.be57	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.be59	a5 21		lda $21				lda 	zTempStr+1
.be5b	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.be5d	60		rts				rts
.be5e					_CSCopyString:
.be5e	da		phx				phx
.be5f	5a		phy				phy
.be60	a0 00		ldy #$00			ldy 	#0 							; get length
.be62	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.be64	f0 0a		beq $be70			beq 	_CSCSExit 					; if zero, exit immediately
.be66	aa		tax				tax 								; put in X which is the counter.
.be67					_CSCSLoop:
.be67	c8		iny				iny 								; get next char
.be68	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.be6a	20 0a c3	jsr $c30a			jsr		WriteTempString 			; copy out to new string
.be6d	ca		dex				dex 								; do whole string
.be6e	d0 f7		bne $be67			bne 	_CSCSLoop
.be70					_CSCSExit:
.be70	7a		ply				ply
.be71	fa		plx				plx
.be72	60		rts				rts
.be73					_CSError:
.be73	20 9e ae	jsr $ae9e			jsr ERR_Handler
>be76	53 74 72 69 6e 67 20 74			.text "String too long",0
>be7e	6f 6f 20 6c 6f 6e 67 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.be86					Unary_Sgn:
.be86	20 2a bc	jsr $bc2a			jsr 	EvaluateNumberX 			; get value
.be89	20 90 c2	jsr $c290			jsr 	CheckNextRParen 			; check right bracket.
.be8c	20 aa be	jsr $beaa			jsr 	GetSignCurrent 				; get sign.
.be8f	09 00		ora #$00			ora 	#0
.be91	10 08		bpl $be9b			bpl		UnarySetAInteger			; if 0,1 return that.
.be93	80 00		bra $be95			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.be95					UnarySetAMinus1:
.be95	a9 ff		lda #$ff			lda 	#$FF 						; put -1 in all four slots.
.be97	95 80		sta $80,x			sta 	XS_Mantissa,x
.be99	80 04		bra $be9f			bra 	UnarySetAFill
.be9b					UnarySetAInteger:
.be9b	95 80		sta $80,x			sta 	XS_Mantissa,x
.be9d	a9 00		lda #$00			lda 	#0
.be9f					UnarySetAFill:
.be9f	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bea1	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.bea3	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.bea5	a9 01		lda #$01			lda 	#1 							; set type to integer.
.bea7	95 85		sta $85,x			sta 	XS_Type,x
.bea9	60		rts				rts
.beaa					GetSignCurrent:
.beaa	b5 85		lda $85,x			lda 	XS_Type,x 					; identify type.
.beac	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.bead	90 15		bcc $bec4			bcc 	_GSCFloat 					; if clear do the float code.
.beaf	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; if msb of integer set, it's negative
.beb1	30 0e		bmi $bec1			bmi 	_GSCMinus1
.beb3	15 80		ora $80,x			ora 	XS_Mantissa+0,x
.beb5	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.beb7	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.beb9	d0 03		bne $bebe			bne 	_GSCPlus1 					; check if zero by oring all together.
.bebb					_GSCZero:
.bebb	a9 00		lda #$00			lda 	#0
.bebd	60		rts				rts
.bebe					_GSCPlus1:
.bebe	a9 01		lda #$01			lda 	#$01
.bec0	60		rts				rts
.bec1					_GSCMinus1:
.bec1	a9 ff		lda #$ff			lda 	#$FF
.bec3	60		rts				rts
.bec4					_GSCFloat:
.bec4	34 85		bit $85,x			bit 	XS_Type,x 					; check bits
.bec6	70 f3		bvs $bebb			bvs 	_GSCZero 					; if zero flag set return zero
.bec8	30 f7		bmi $bec1			bmi 	_GSCMinus1 					; if sign set return -1
.beca	80 f2		bra $bebe			bra 	_GSCPlus1		 			; else return +1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.becc					Unary_Abs:
.becc	20 2a bc	jsr $bc2a			jsr 	EvaluateNumberX 			; get value
.becf	20 90 c2	jsr $c290			jsr 	CheckNextRParen 			; check right bracket.
.bed2	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.bed4	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.bed6	f0 07		beq $bedf			beq 	_UAMinusFloat
.bed8	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; check MSB of upper byte to see if negative
.beda	10 09		bpl $bee5			bpl 	_UAExit
.bedc	4c 0a c8	jmp $c80a			jmp 	IntegerNegateAlways 		; if so negate it.
.bedf					_UAMinusFloat:
.bedf	b5 85		lda $85,x			lda 	XS_Type,x 					; clear the sign bit.
.bee1	29 7f		and #$7f			and		#$7F
.bee3	95 85		sta $85,x			sta 	XS_Type,x
.bee5					_UAExit:
.bee5	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.bee6					Unary_Peek:
.bee6	a9 01		lda #$01			lda 	#1 							; 1 byte
.bee8	80 06		bra $bef0			bra 	UPMain
.beea					Unary_Deek:
.beea	a9 02		lda #$02			lda 	#2 							; 2 bytes
.beec	80 02		bra $bef0			bra 	UPMain
.beee					Unary_Leek:
.beee	a9 04		lda #$04			lda 	#4 							; 4 bytes
.bef0					UPMain:
.bef0	48		pha				pha 								; save bytes to copy.
.bef1	20 38 bc	jsr $bc38			jsr 	EvaluateIntegerX 			; numeric parameter, the address to xEEK
.bef4	20 90 c2	jsr $c290			jsr 	CheckNextRParen 			; right bracket.
.bef7	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.bef9	85 1a		sta $1a				sta 	zLTemp1
.befb	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.befd	85 1b		sta $1b				sta 	zLTemp1+1
.beff	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.bf01	85 1c		sta $1c				sta 	zLTemp1+2
.bf03	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.bf05	85 1d		sta $1d				sta 	zLTemp1+3
.bf07	a9 00		lda #$00			lda 	#0 							; clear target area, which might get
.bf09	95 80		sta $80,x			sta 	XS_Mantissa+0,x 			; 1,2 or 4 bytes.
.bf0b	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bf0d	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.bf0f	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.bf11	68		pla				pla 								; restore bytes to copy
.bf12	da		phx				phx 								; save XY
.bf13	5a		phy				phy
.bf14	20 07 c2	jsr $c207			jsr 	MemRead 					; read the bytes in, processor dependent routine.
.bf17	7a		ply				ply 								; restore and exit
.bf18	fa		plx				plx
.bf19	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/pos.asm

.bf1a					Unary_Pos:
.bf1a	20 2a bc	jsr $bc2a			jsr 	EvaluateNumberX 			; get value, which is a dummy.
.bf1d	20 90 c2	jsr $c290			jsr 	CheckNextRParen 			; check right bracket.
.bf20	20 68 ae	jsr $ae68			jsr 	VIOCharGetPosition 			; get the position
.bf23	4c 9b be	jmp $be9b			jmp		UnarySetAInteger			; and return that.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.bf26					Unary_Mod:
.bf26	20 4e bf	jsr $bf4e			jsr 	_UMParameter 				; first parameter, get |param|
.bf29	20 99 c2	jsr $c299			jsr 	CheckNextComma
.bf2c	da		phx				phx 								; second parameter, get |param|
.bf2d	e8		inx				inx
.bf2e	e8		inx				inx
.bf2f	e8		inx				inx
.bf30	e8		inx				inx
.bf31	e8		inx				inx
.bf32	e8		inx				inx
.bf33	20 4e bf	jsr $bf4e			jsr 	_UMParameter
.bf36	fa		plx				plx
.bf37	20 90 c2	jsr $c290			jsr 	CheckNextRParen
.bf3a	20 83 c7	jsr $c783			jsr 	DivInteger32 				; divide, which handily leaves ....
.bf3d	a5 1a		lda $1a				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.bf3f	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.bf41	a5 1b		lda $1b				lda 	zLTemp1+1
.bf43	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bf45	a5 1c		lda $1c				lda 	zLTemp1+2
.bf47	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.bf49	a5 1d		lda $1d				lda 	zLTemp1+3
.bf4b	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.bf4d	60		rts				rts
.bf4e					_UMParameter:
.bf4e	20 38 bc	jsr $bc38			jsr 	EvaluateIntegerX 			; get value
.bf51	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; absolute value
.bf53	10 03		bpl $bf58			bpl 	_UMNotSigned
.bf55	20 0a c8	jsr $c80a			jsr 	IntegerNegateAlways
.bf58					_UMNotSigned:
.bf58	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.bf59					Unary_Usr:
.bf59	20 2a bc	jsr $bc2a			jsr 	EvaluateNumberX 			; numeric parameter
.bf5c	20 90 c2	jsr $c290			jsr 	CheckNextRParen 			; right bracket.
.bf5f	da		phx				phx 								; save XY
.bf60	5a		phy				phy
.bf61	20 0c 03	jsr $030c			jsr 	UserVector 					; call the USR function.
.bf64	7a		ply				ply 								; restore YX and exit with whatever the
.bf65	fa		plx				plx 								; routine called has chosen to do with it.
.bf66	60		rts				rts
.bf67					USRDefault:
.bf67	20 9e ae	jsr $ae9e			jsr ERR_Handler
>bf6a	4e 6f 20 55 53 52 20 76			.text "No USR vector.",0
>bf72	65 63 74 6f 72 2e 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.bf79					Unary_Val:
.bf79	20 41 bc	jsr $bc41			jsr 	EvaluateStringX 			; get string
.bf7c	20 90 c2	jsr $c290			jsr 	CheckNextRParen 			; check right bracket.
.bf7f	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.bf81	85 1e		sta $1e				sta 	zGenPtr
.bf83	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bf85	85 1f		sta $1f				sta 	zGenPtr+1
.bf87	da		phx				phx
.bf88	5a		phy				phy
.bf89	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.bf8b	b1 1e		lda ($1e),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.bf8d	f0 19		beq $bfa8			beq 	UVBadNumber
.bf8f	aa		tax				tax
.bf90					_UVCopy1:
.bf90	c8		iny				iny
.bf91	c0 18		cpy #$18			cpy 	#24 						; too long
.bf93	f0 13		beq $bfa8			beq 	UVBadNumber
.bf95	b1 1e		lda ($1e),y			lda 	(zGenPtr),y					; copy character
.bf97	99 14 03	sta $0314,y			sta 	Num_Buffer-1,y
.bf9a	a9 00		lda #$00			lda 	#0 							; make string ASCIIZ.
.bf9c	99 15 03	sta $0315,y			sta 	Num_Buffer,y
.bf9f	ca		dex				dex
.bfa0	d0 ee		bne $bf90			bne 	_UVCopy1
.bfa2	7a		ply				ply
.bfa3	fa		plx				plx
.bfa4	20 b6 bf	jsr $bfb6			jsr 	ConvertNumBuffer 			; convert string in NumBuffer to mantissa,x
.bfa7	60		rts				rts
.bfa8					UVBadNumber:
.bfa8	20 9e ae	jsr $ae9e			jsr ERR_Handler
>bfab	42 61 64 20 4e 75 6d 62			.text "Bad Number",0
>bfb3	65 72 00
.bfb6					ConvertNumBuffer:
.bfb6	5a		phy				phy
.bfb7	a9 15		lda #$15			lda 	#Num_Buffer & $FF 			; set zGenPtr to point to buffer.
.bfb9	85 1e		sta $1e				sta 	zGenPtr
.bfbb	a9 03		lda #$03			lda 	#Num_Buffer >> 8
.bfbd	85 1f		sta $1f				sta 	zGenPtr+1
.bfbf	ad 15 03	lda $0315			lda 	Num_Buffer 					; first character is - ?
.bfc2	c9 2d		cmp #$2d			cmp 	#"-"
.bfc4	d0 02		bne $bfc8			bne 	_UVNotMinus1
.bfc6	e6 1e		inc $1e				inc 	zGenPtr 					; this time just fix the pointer.
.bfc8					_UVNotMinus1:
.bfc8	20 d8 c8	jsr $c8d8			jsr 	IntFromString 				; get integer
.bfcb	b0 db		bcs $bfa8			bcs 	UVBadNumber
.bfcd	20 56 ce	jsr $ce56			jsr 	FPFromString 				; possibly float it.
.bfd0	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; done the whole string
.bfd2	d0 d4		bne $bfa8			bne 	UVBadNumber 				; no, exit.
.bfd4	ad 15 03	lda $0315			lda 	Num_Buffer 					; look at numbuffer
.bfd7	c9 2d		cmp #$2d			cmp 	#"-"
.bfd9	d0 11		bne $bfec			bne 	_UVNotMinus2
.bfdb	b5 85		lda $85,x			lda 	XS_Type,x 					; type is float ?
.bfdd	29 0f		and #$0f			and 	#$0F
.bfdf	f0 05		beq $bfe6			beq 	_UVNegateFloat
.bfe1	20 0a c8	jsr $c80a			jsr 	IntegerNegateAlways
.bfe4	80 06		bra $bfec			bra 	_UVNotMinus2
.bfe6					_UVNegateFloat:
.bfe6	b5 85		lda $85,x			lda 	XS_Type,x 					; set the sign bit.
.bfe8	09 80		ora #$80			ora 	#$80
.bfea	95 85		sta $85,x			sta 	XS_Type,x
.bfec					_UVNotMinus2:
.bfec	7a		ply				ply
.bfed	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.bfee					Unary_Str:
.bfee	20 2a bc	jsr $bc2a			jsr 	EvaluateNumberX 			; numeric parameter
.bff1	20 90 c2	jsr $c290			jsr 	CheckNextRParen 			; right bracket.
.bff4	a9 00		lda #$00			lda 	#0 							; reset buffer index
.bff6	8d 14 03	sta $0314			sta 	NumBufX
.bff9	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.bffb	4a		lsr a				lsr 	a 							; bit 0 identifies an integer.
.bffc	b0 05		bcs $c003			bcs 	_USInt 						; if msb set do as integer
.bffe	20 9b cd	jsr $cd9b			jsr 	FPToString 					; call fp to str otherwise
.c001	80 03		bra $c006			bra 	_USDuplicate
.c003	20 27 c8	jsr $c827	_USInt:	jsr 	IntToString					; call int to str.
.c006					_USDuplicate:
.c006	ad 14 03	lda $0314			lda 	NumBufX 					; chars in buffer
.c009	1a		inc a				inc 	a 							; one more for length
.c00a	20 df c2	jsr $c2df			jsr 	AllocateTempString 			; allocate space for it.
.c00d	5a		phy				phy 								; save Y
.c00e	a0 00		ldy #$00			ldy 	#0 							; start copying
.c010	b9 15 03	lda $0315,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.c013	20 0a c3	jsr $c30a			jsr 	WriteTempString
.c016	c8		iny				iny
.c017	cc 14 03	cpy $0314			cpy 	NumBufX 					; done the lot
.c01a	d0 f4		bne $c010			bne 	_USCopy
.c01c	7a		ply				ply 								; restore Y
.c01d	4c fa c1	jmp $c1fa			jmp 	UnaryReturnTempStr 			; return newly created temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.c020					Unary_Asc:
.c020	20 41 bc	jsr $bc41			jsr 	EvaluateStringX 			; string parameter
.c023	20 90 c2	jsr $c290			jsr 	CheckNextRParen 			; right bracket.
.c026	5a		phy				phy 								; get the string length
.c027	a0 00		ldy #$00			ldy 	#0
.c029	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.c02b	f0 07		beq $c034			beq 	_UAIllegal 					; must be at least one character, 0 => error
.c02d	c8		iny				iny
.c02e	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; read the first character
.c030	7a		ply				ply
.c031	4c 9b be	jmp $be9b			jmp 	UnarySetAInteger 			; return that as an integer 0-255.
.c034					_UAIllegal:
.c034	4c 8d ae	jmp $ae8d			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.c037					Unary_Len:
.c037	20 41 bc	jsr $bc41			jsr 	EvaluateStringX 			; string parameter
.c03a	20 90 c2	jsr $c290			jsr 	CheckNextRParen 			; right bracket.
.c03d	5a		phy				phy 								; get the string length
.c03e	a0 00		ldy #$00			ldy 	#0
.c040	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.c042	7a		ply				ply
.c043	4c 9b be	jmp $be9b			jmp 	UnarySetAInteger 			; return as an integer.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.c046					Unary_Mid:
.c046	20 41 bc	jsr $bc41			jsr 	EvaluateStringX 				; get string.
.c049	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.c04b	48		pha				pha
.c04c	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c04e	48		pha				pha
.c04f	20 99 c2	jsr $c299			jsr 	CheckNextComma 					; skip comma
.c052	20 db c0	jsr $c0db			jsr 	SLIByteParameter 				; get a byte parameter (start)
.c055	48		pha				pha 									; and push it.
.c056	20 99 c2	jsr $c299			jsr 	CheckNextComma 					; skip comma
.c059	20 db c0	jsr $c0db			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.c05c	48		pha				pha 									; and push it.
.c05d	80 41		bra $c0a0			bra 	SLIProcess
.c05f					Unary_Left:
.c05f	20 41 bc	jsr $bc41			jsr 	EvaluateStringX 				; get string.
.c062	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.c064	48		pha				pha
.c065	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c067	48		pha				pha
.c068	a9 01		lda #$01			lda 	#1 								; push start position (1)
.c06a	48		pha				pha
.c06b	20 99 c2	jsr $c299			jsr 	CheckNextComma 					; skip comma
.c06e	20 db c0	jsr $c0db			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.c071	48		pha				pha 									; and push it.
.c072	80 2c		bra $c0a0			bra 	SLIProcess
.c074					Unary_Right:
.c074	20 41 bc	jsr $bc41			jsr 	EvaluateStringX 				; get string.
.c077	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.c079	48		pha				pha
.c07a	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c07c	48		pha				pha
.c07d	da		phx				phx 									; get the string length and push on stack.
.c07e	a2 00		ldx #$00			ldx 	#0
.c080	a1 1e		lda ($1e,x)			lda		(zGenPtr,x)
.c082	fa		plx				plx
.c083	48		pha				pha
.c084	20 99 c2	jsr $c299			jsr 	CheckNextComma 					; skip comma
.c087	20 db c0	jsr $c0db			jsr 	SLIByteParameter 				; get a byte parameter.
.c08a	8d 9e 03	sta $039e			sta 	SignCount 						; save in temporary.
.c08d	68		pla				pla 									; restore string length.
.c08e	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.c08f	38		sec				sec
.c090	ed 9e 03	sbc $039e			sbc 	SignCount 						; subtract characters needed, gives start position.
.c093	f0 02		beq $c097			beq 	_URStart 						; if <= 0 start from 1.
.c095	10 02		bpl $c099			bpl 	_UROkay
.c097					_URStart:
.c097	a9 01		lda #$01			lda 	#1
.c099					_UROkay:
.c099	48		pha				pha 									; push start
.c09a	ad 9e 03	lda $039e			lda 	SignCount 						; push count of characters
.c09d	48		pha				pha
.c09e	80 00		bra $c0a0			bra 	SLIProcess
.c0a0					SLIProcess:
.c0a0	20 90 c2	jsr $c290			jsr 	CheckNextRParen 				; closing right bracket.
.c0a3	68		pla				pla
.c0a4	8d a2 03	sta $03a2			sta 	SliceCount 						; count in signcount
.c0a7	1a		inc a				inc 	a 								; allocate +1 for it.
.c0a8	20 df c2	jsr $c2df			jsr 	AllocateTempString
.c0ab	68		pla				pla 									; pop start number off stack.
.c0ac	f0 3b		beq $c0e9			beq 	SLIError 						; exit if start = 0
.c0ae	8d a1 03	sta $03a1			sta 	SliceStart
.c0b1	68		pla				pla  									; pop string address.
.c0b2	85 1f		sta $1f				sta 	zGenPtr+1
.c0b4	68		pla				pla
.c0b5	85 1e		sta $1e				sta 	zGenPtr
.c0b7	da		phx				phx
.c0b8	5a		phy				phy
.c0b9	a2 00		ldx #$00			ldx 	#0 								; point to string length.
.c0bb	ac a1 03	ldy $03a1			ldy 	SliceStart 						; start of the string (+1 for count)
.c0be					_SLICopy:
.c0be	ad a2 03	lda $03a2			lda 	SliceCount 						; done count characters
.c0c1	f0 12		beq $c0d5			beq 	_SLIExit
.c0c3	ce a2 03	dec $03a2			dec 	SliceCount
.c0c6	98		tya				tya 									; index of character
.c0c7	c1 1e		cmp ($1e,x)			cmp 	(zGenPtr,x)						; compare against length
.c0c9	f0 02		beq $c0cd			beq 	_SLIOk 							; if equal, okay.
.c0cb	b0 08		bcs $c0d5			bcs 	_SLIExit 						; if past end, then exit.
.c0cd	b1 1e		lda ($1e),y	_SLIOk:	lda 	(zGenPtr),y 					; copy one character
.c0cf	c8		iny				iny
.c0d0	20 0a c3	jsr $c30a			jsr 	WriteTempString
.c0d3	80 e9		bra $c0be			bra 	_SLICopy 						; go round till copied characters
.c0d5					_SLIExit:
.c0d5	7a		ply				ply 									; restore YX
.c0d6	fa		plx				plx
.c0d7	4c fa c1	jmp $c1fa			jmp 	UnaryReturnTempStr 				; return new temporary string.
.c0da	ea		nop				nop
.c0db					SLIByteParameter:
.c0db	20 38 bc	jsr $bc38			jsr 	EvaluateIntegerX 				; get integer
.c0de	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.c0e0	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.c0e2	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.c0e4	d0 03		bne $c0e9			bne 	SLIError
.c0e6	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.c0e8	60		rts				rts
.c0e9					SLIError:
.c0e9	4c 8d ae	jmp $ae8d			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.c0ec					Unary_Hex:
.c0ec	20 38 bc	jsr $bc38			jsr 	EvaluateIntegerX 			; numeric parameter
.c0ef	20 90 c2	jsr $c290			jsr 	CheckNextRParen 			; right bracket.
.c0f2	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.c0f4	20 df c2	jsr $c2df			jsr 	AllocateTempString			; allocate string space
.c0f7	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.c0f9	20 1d c1	jsr $c11d			jsr 	_UHConvert
.c0fc	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c0fe	20 1d c1	jsr $c11d			jsr 	_UHConvert
.c101	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c103	20 1d c1	jsr $c11d			jsr 	_UHConvert
.c106	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.c108	20 1d c1	jsr $c11d			jsr 	_UHConvert
.c10b	5a		phy				phy 								; get length of new string
.c10c	a0 00		ldy #$00			ldy 	#0
.c10e	b1 20		lda ($20),y			lda 	(zTempStr),y
.c110	7a		ply				ply
.c111	c9 00		cmp #$00			cmp 	#0 							; if it was non zero okay
.c113	d0 05		bne $c11a			bne 	_UHExit 					; otherwise suppressed all leading zeros !
.c115	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.c117	20 0a c3	jsr $c30a			jsr 	WriteTempString
.c11a					_UHExit:
.c11a	4c fa c1	jmp $c1fa			jmp 	UnaryReturnTempStr 			; return new temporary string.
.c11d					_UHConvert:
.c11d	48		pha				pha
.c11e	4a		lsr a				lsr 	a 							; do MSB
.c11f	4a		lsr a				lsr 	a
.c120	4a		lsr a				lsr 	a
.c121	4a		lsr a				lsr 	a
.c122	20 26 c1	jsr $c126			jsr 	_UHNibble
.c125	68		pla				pla 								; do LSB
.c126					_UHNibble:
.c126	29 0f		and #$0f			and 	#15 						; get nibble
.c128	d0 0c		bne $c136			bne 	_UHNonZero 					; if not zero, write it out anyway.
.c12a	5a		phy				phy									; get the length
.c12b	a0 00		ldy #$00			ldy 	#0
.c12d	b1 20		lda ($20),y			lda 	(zTempStr),y
.c12f	7a		ply				ply
.c130	c9 00		cmp #$00			cmp 	#0 							; length = 0 => suppress leading zeros.
.c132	f0 0d		beq $c141			beq 	_UHExit2
.c134	a9 00		lda #$00			lda 	#0 							; length > 0, so can't suppress any more.
.c136					_UHNonZero:
.c136	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.c138	90 02		bcc $c13c			bcc 	_UHDigit
.c13a	69 06		adc #$06			adc 	#7-1
.c13c					_UHDigit:
.c13c	69 30		adc #$30			adc 	#48
.c13e	20 0a c3	jsr $c30a			jsr 	WriteTempString				; output to temp string.
.c141					_UHExit2:
.c141	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.c142					Unary_Dec:
.c142	20 41 bc	jsr $bc41			jsr 	EvaluateStringX 			; string parameter
.c145	20 90 c2	jsr $c290			jsr 	CheckNextRParen 			; right bracket.
.c148	5a		phy				phy
.c149	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.c14b	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.c14d	f0 43		beq $c192			beq 	_UDFail 					; must fail if zero.
.c14f	8d 9e 03	sta $039e			sta 	SignCount 					; use SignCount as a counter of chars to process.
.c152	a9 00		lda #$00			lda 	#0 							; set result to zero
.c154	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c156	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c158	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c15a	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c15c	a9 01		lda #$01			lda 	#1 							; set type to integer.
.c15e	95 85		sta $85,x			sta 	XS_Type,x
.c160					_UDConvertLoop:
.c160	5a		phy				phy 								; shift mantissa left 4
.c161	a0 04		ldy #$04			ldy 	#4
.c163					_UDShift:
.c163	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.c165	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.c167	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.c169	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.c16b	88		dey				dey
.c16c	d0 f5		bne $c163			bne 	_UDShift
.c16e	7a		ply				ply
.c16f	c8		iny				iny 								; next character
.c170	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; fetch it.
.c172	20 95 c1	jsr $c195			jsr 	ConvertUpper 				; convert to U/C
.c175	c9 30		cmp #$30			cmp 	#"0" 						; range 0-9
.c177	90 19		bcc $c192			bcc 	_UDFail
.c179	c9 3a		cmp #$3a			cmp 	#"9"+1
.c17b	90 08		bcc $c185			bcc 	_UDOkay
.c17d	e9 37		sbc #$37			sbc 	#7+"0" 						; A-F fudge
.c17f	90 11		bcc $c192			bcc 	_UDFail 					; fails if between 9 and @
.c181	c9 10		cmp #$10			cmp 	#16 						; must be < 16 as hexadecimal.
.c183	b0 0d		bcs $c192			bcs 	_UDFail
.c185					_UDOkay:
.c185	29 0f		and #$0f			and 	#15 						; nibble only
.c187	15 80		ora $80,x			ora 	XS_Mantissa+0,x 			; OR into the bottom byte.
.c189	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c18b	ce 9e 03	dec $039e			dec 	SignCount 					; do it for each character in the string.
.c18e	d0 d0		bne $c160			bne 	_UDConvertLoop
.c190	7a		ply				ply
.c191	60		rts				rts
.c192					_UDFail:
.c192	4c 8d ae	jmp $ae8d			jmp 	BadParamError
.c195					ConvertUpper:
.c195	c9 61		cmp #$61			cmp 	#"a"
.c197	90 07		bcc $c1a0			bcc 	_CUExit
.c199	c9 7b		cmp #$7b			cmp 	#"z"+1
.c19b	b0 03		bcs $c1a0			bcs 	_CUExit
.c19d	38		sec				sec
.c19e	e9 20		sbc #$20			sbc 	#32
.c1a0	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.c1a1					Unary_Chr:
.c1a1	20 38 bc	jsr $bc38			jsr 	EvaluateIntegerX			; numeric parameter which is the character we want
.c1a4	20 90 c2	jsr $c290			jsr 	CheckNextRParen 			; right bracket.
.c1a7	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.c1a9	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.c1ab	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.c1ad	d0 0d		bne $c1bc			bne 	_UCChar
.c1af	a9 02		lda #$02			lda 	#1+1 						; one character string. 2 bytes - size+char
.c1b1	20 df c2	jsr $c2df			jsr 	AllocateTempString			; allocate it.
.c1b4	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.c1b6	20 0a c3	jsr $c30a			jsr 	WriteTempString
.c1b9	4c fa c1	jmp $c1fa			jmp 	UnaryReturnTempStr 			; and return that string.
.c1bc					_UCChar:
.c1bc	4c 8d ae	jmp $ae8d			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.c1bf					Unary_Spc:
.c1bf	20 db c0	jsr $c0db			jsr 	SLIByteParameter 			; check space.
.c1c2	20 90 c2	jsr $c290			jsr 	CheckNextRParen
.c1c5	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.c1c7					UnarySpcCreate:
.c1c7	c9 fe		cmp #$fe			cmp 	#maxString+1
.c1c9	b0 14		bcs $c1df			bcs 	_USSize
.c1cb	48		pha				pha 								; save length
.c1cc	1a		inc a				inc 	a 							; allocate one more.
.c1cd	20 df c2	jsr $c2df			jsr 	AllocateTempString
.c1d0	68		pla				pla 								; get length
.c1d1	f0 27		beq $c1fa			beq 	UnaryReturnTempStr 			; return the current temp string
.c1d3					_USLoop:
.c1d3	48		pha				pha
.c1d4	a9 20		lda #$20			lda 	#" "
.c1d6	20 0a c3	jsr $c30a			jsr 	WriteTempString
.c1d9	68		pla				pla
.c1da	3a		dec a				dec 	a
.c1db	d0 f6		bne $c1d3			bne 	_USLoop
.c1dd	80 1b		bra $c1fa			bra 	UnaryReturnTempStr
.c1df					_USSize:
.c1df	4c 8d ae	jmp $ae8d			jmp 	BadParamError
.c1e2					Unary_Tab:
.c1e2	a2 00		ldx #$00			ldx 	#0 							; required TAB position.
.c1e4	20 db c0	jsr $c0db			jsr 	SLIByteParameter
.c1e7	20 90 c2	jsr $c290			jsr 	CheckNextRParen
.c1ea	20 68 ae	jsr $ae68			jsr 	VIOCharGetPosition 			; were are we ?
.c1ed	85 10		sta $10				sta 	zTemp1
.c1ef	38		sec				sec
.c1f0	a5 80		lda $80				lda 	XS_Mantissa+0 				; return chars required.
.c1f2	e5 10		sbc $10				sbc 	zTemp1
.c1f4	b0 d1		bcs $c1c7			bcs 	UnarySpcCreate
.c1f6	a9 00		lda #$00			lda 	#0
.c1f8	80 cd		bra $c1c7			bra 	UnarySpcCreate
.c1fa					UnaryReturnTempStr:
.c1fa	a5 20		lda $20				lda 	zTempStr 					; copy temp string addr -> mantissa
.c1fc	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c1fe	a5 21		lda $21				lda 	zTempStr+1
.c200	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c202	a9 02		lda #$02			lda 	#2 							; set type to string
.c204	95 85		sta $85,x			sta 	XS_Type,x
.c206	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/4510.asm

.c207	db		phz		MemRead:phz
.c208	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.c20b	a3 00		ldz #$00			ldz 	#0 							; start from here
.c20d	ea		nop		_MLoop1:nop
.c20e	b2 1a		lda ($1a),z			lda 	(zlTemp1),z 				; read the long address
.c210	95 80		sta $80,x			sta 	XS_Mantissa,x 				; copy into mantissa
.c212	1b		inz				inz 								; next to copy
.c213	e8		inx				inx
.c214	dc 9e 03	cpz $039e			cpz 	SignCount 					; do required # of bytes.
.c217	d0 f4		bne $c20d			bne 	_MLoop1
.c219	fb		plz				plz
.c21a	60		rts				rts
.c21b					MemWrite:
.c21b	db		phz				phz
.c21c	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.c21f	a3 00		ldz #$00			ldz 	#0 							; start from here
.c221	b5 80		lda $80,x	_MLoop1:lda 	XS_Mantissa,x 				; read mantisssa
.c223	ea		nop				nop
.c224	92 1a		sta ($1a),z			sta 	(zlTemp1),z 				; write it out
.c226	1b		inz				inz 								; next to copy
.c227	e8		inx				inx
.c228	dc 9e 03	cpz $039e			cpz 	SignCount 					; do required # of bytes.
.c22b	d0 f4		bne $c221			bne 	_MLoop1
.c22d	fb		plz				plz
.c22e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/programend.asm

.c22f					UpdateProgramEnd:
.c22f	a9 00		lda #$00			lda 	#BasicProgram & $FF
.c231	85 16		sta $16				sta 	zCodePtr+0
.c233	a9 80		lda #$80			lda 	#BasicProgram >> 8
.c235	85 17		sta $17				sta 	zCodePtr+1
.c237	a9 02		lda #$02			lda 	#2
.c239	85 18		sta $18				sta 	zCodePtr+2
.c23b	a9 00		lda #$00			lda 	#0
.c23d	85 19		sta $19				sta 	zCodePtr+3
.c23f	a3 03		ldz #$03			ldz 	#3
.c241					_UPDLoop:
.c241	a3 00		ldz #$00			ldz 	#0
.c243	ea		nop				nop
.c244	b2 16		lda ($16),z			lda 	(zCodePtr),z
.c246	c9 00		cmp #$00			cmp 	#0 							; end if offset is zero.
.c248	f0 10		beq $c25a			beq 	_UPDFoundEnd
.c24a	a3 00		ldz #$00			ldz 	#0 							; point to offset
.c24c	ea		nop				nop
.c24d	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read it
.c24f	18		clc				clc
.c250	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.c252	85 16		sta $16				sta 	zCodePtr
.c254	90 02		bcc $c258			bcc 	_SNLNoCarry
.c256	e6 17		inc $17				inc 	zCodePtr+1
.c258					_SNLNoCarry:
.c258	80 e7		bra $c241			bra 	_UPDLoop
.c25a					_UPDFoundEnd:
.c25a	18		clc				clc 								; end of program 2 on.
.c25b	a5 16		lda $16				lda 	zCodePtr
.c25d	69 02		adc #$02			adc 	#2
.c25f	8d 04 03	sta $0304			sta 	endOfProgram
.c262	a5 17		lda $17				lda 	zCodePtr+1
.c264	69 00		adc #$00			adc 	#0
.c266	8d 05 03	sta $0305			sta 	endOfProgram+1
.c269	a5 18		lda $18				lda 	zCodePtr+2
.c26b	69 00		adc #$00			adc		#0
.c26d	8d 06 03	sta $0306			sta 	endOfProgram+2
.c270	a5 19		lda $19				lda 	zCodePtr+3
.c272	69 00		adc #$00			adc 	#0
.c274	8d 07 03	sta $0307			sta 	endOfProgram+3
.c277	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.c278					CheckNextToken:
.c278	ea		nop				nop
.c279	d2 16		cmp ($16),z			cmp 	(zCodePtr),z
.c27b	d0 02		bne $c27f			bne 	CTFail 						; no, then fail
.c27d	1b		inz				inz
.c27e	60		rts				rts
.c27f					CTFail:
.c27f	20 9e ae	jsr $ae9e			jsr ERR_Handler
>c282	4d 69 73 73 69 6e 67 20			.text "Missing token",0
>c28a	74 6f 6b 65 6e 00
.c290					CheckNextRParen:
.c290	ea		nop				nop
.c291	b2 16		lda ($16),z			lda 	(zCodePtr),z
.c293	c9 be		cmp #$be			cmp 	#token_rparen
.c295	d0 e8		bne $c27f			bne 	CTFail
.c297	1b		inz				inz
.c298	60		rts				rts
.c299					CheckNextComma:
.c299	ea		nop				nop
.c29a	b2 16		lda ($16),z			lda 	(zCodePtr),z
.c29c	c9 bf		cmp #$bf			cmp 	#token_comma
.c29e	d0 df		bne $c27f			bne 	CTFail
.c2a0	1b		inz				inz
.c2a1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/concrete.asm

.c2a2					StringConcrete:
.c2a2	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; save source string to zTemp1
.c2a4	85 10		sta $10				sta 	zTemp1
.c2a6	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c2a8	85 11		sta $11				sta 	zTemp1+1
.c2aa	a0 00		ldy #$00			ldy 	#0 							; empty string, return default empty
.c2ac	b1 10		lda ($10),y			lda 	(zTemp1),y
.c2ae	f0 26		beq $c2d6			beq		_SCEmpty 					; concreting it wastes memory.
.c2b0	18		clc				clc 								; from the string pointer
.c2b1	ad 00 03	lda $0300			lda 	StringPtr 					; and put in zTemp2 as well
.c2b4	f1 10		sbc ($10),y			sbc 	(zTemp1),y
.c2b6	8d 00 03	sta $0300			sta 	StringPtr
.c2b9	85 12		sta $12				sta 	zTemp2
.c2bb	ad 01 03	lda $0301			lda 	StringPtr+1
.c2be	e9 00		sbc #$00			sbc 	#0
.c2c0	8d 01 03	sta $0301			sta 	StringPtr+1
.c2c3	85 13		sta $13				sta 	zTemp2+1
.c2c5	b1 10		lda ($10),y			lda 	(zTemp1),y 					; length add one for count
.c2c7	1a		inc a				inc 	a
.c2c8	aa		tax				tax
.c2c9	b1 10		lda ($10),y	_SCCopy:lda 	(zTemp1),y 					; copy whole thing including length
.c2cb	91 12		sta ($12),y			sta 	(zTemp2),y
.c2cd	c8		iny				iny
.c2ce	ca		dex				dex
.c2cf	d0 f8		bne $c2c9			bne 	_SCCopy
.c2d1	a5 13		lda $13				lda 	zTemp2+1 					; return concrete string in AX
.c2d3	a6 12		ldx $12				ldx 	zTemp2
.c2d5	60		rts				rts
.c2d6					_SCEmpty:
.c2d6	a9 00		lda #$00			lda 	#0
.c2d8	85 25		sta $25				sta 	zNullString
.c2da	a9 00		lda #$00			lda 	#zNullString >> 8
.c2dc	a2 25		ldx #$25			ldx 	#zNulLString & $FF
.c2de	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.c2df					AllocateTempString:
.c2df	48		pha				pha 								; save required count.
.c2e0	a5 21		lda $21				lda 	zTempStr+1 					; check if initialised yet ?
.c2e2	d0 0b		bne $c2ef			bne 	_ATSInitialised
.c2e4	ad 00 03	lda $0300			lda 	StringPtr 					; set temporary string ptr 1 page below available
.c2e7	85 20		sta $20				sta 	zTempStr					; space, this is for strings to be concreted.
.c2e9	ad 01 03	lda $0301			lda 	StringPtr+1
.c2ec	3a		dec a				dec 	a 							; allow the page.
.c2ed	85 21		sta $21				sta 	zTempStr+1
.c2ef					_ATSInitialised:
.c2ef	68		pla				pla 								; get required count back.
.c2f0	49 ff		eor #$ff			eor 	#$FF 						; negate and add 2's complement.
.c2f2	1a		inc a				inc 	a
.c2f3	18		clc				clc
.c2f4	65 20		adc $20				adc 	zTempStr 					; "add" to the temp string pointer
.c2f6	85 20		sta $20				sta 	zTempStr					; which means the tsp is also the current.
.c2f8	a9 ff		lda #$ff			lda 	#$FF
.c2fa	65 21		adc $21				adc 	zTempStr+1
.c2fc	85 21		sta $21				sta 	zTempStr+1
.c2fe	a9 00		lda #$00			lda 	#0 							; clear temp string by zeroing length.
.c300	5a		phy				phy
.c301	a8		tay				tay
.c302	91 20		sta ($20),y			sta 	(zTempStr),y
.c304	7a		ply				ply
.c305	1a		inc a				inc 	a 							; reset the write index to 1 (first character)
.c306	8d 9f 03	sta $039f			sta 	TempStringWriteIndex
.c309	60		rts				rts
.c30a					WriteTempString:
.c30a	5a		phy				phy 								; save Y
.c30b	ac 9f 03	ldy $039f			ldy 	TempStringWriteIndex	 	; write position.
.c30e	91 20		sta ($20),y			sta 	(zTempStr),y 				; write character out.
.c310	ee 9f 03	inc $039f			inc 	TempStringWriteIndex 		; increment the write position.
.c313	98		tya				tya 								; unchanged Y is now length
.c314	a0 00		ldy #$00			ldy 	#0
.c316	91 20		sta ($20),y			sta 	(zTempStr),y
.c318	7a		ply				ply 								; restore Y and exit
.c319	60		rts				rts
.c31a					CreateTempStringCopy:
.c31a	da		phx				phx 								; save X
.c31b	ea		nop				nop
.c31c	b2 16		lda ($16),z			lda 	(zCodePtr),z
.c31e	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.c31f	20 df c2	jsr $c2df			jsr 	AllocateTempString 			; allocate memory for temporary string.
.c322	ea		nop				nop
.c323	b2 16		lda ($16),z			lda 	(zCodePtr),z
.c325	1b		inz				inz
.c326	3a		dec a				dec 	a 							; make the actual length in characters, allowing
.c327	3a		dec a				dec 	a 							; for the marker and the length.
.c328	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.c32a	81 20		sta ($20,x)			sta 	(zTempStr,x)
.c32c	85 1a		sta $1a				sta 	zLTemp1 					; that's used as a count.
.c32e	09 00		ora #$00			ora 	#0 							; if zero already, exit
.c330	f0 0f		beq $c341			beq 	_CTSCExit
.c332					_CTSCLoop:
.c332	ea		nop				nop
.c333	b2 16		lda ($16),z			lda 	(zCodePtr),z
.c335	1b		inz				inz
.c336	5a		phy				phy 								; save Y
.c337	e8		inx				inx 								; bump index
.c338	da		phx				phx 								; save that
.c339	7a		ply				ply 								; index into Y
.c33a	91 20		sta ($20),y			sta 	(zTempStr),y 				; save at index position
.c33c	7a		ply				ply 								; restore Y
.c33d	c6 1a		dec $1a				dec 	zLTemp1 					; do for each character, this is the counter.
.c33f	d0 f1		bne $c332			bne 	_CTSCLoop
.c341					_CTSCExit:
.c341	fa		plx				plx 								; restore X
.c342	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/variables.asm

.c343					VariableFind:
.c343	20 ae c3	jsr $c3ae			jsr 	VariableExtract 		; find out all about it ....
.c346	20 49 c6	jsr $c649			jsr 	VariableLocate 			; does it already exist ?
.c349	b0 03		bcs $c34e			bcs 	_VFExists 				; if so, use that.
.c34b	20 3c c4	jsr $c43c			jsr 	VariableCreate 			; otherwise create it.
.c34e					_VFExists:
.c34e	a5 24		lda $24				lda 	zVarType 				; is it still an array ?
.c350	29 01		and #$01			and 	#1
.c352	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.c354	d0 28		bne $c37e			bne 	_VFSingleElement
.c356					_VFNextIndex:
.c356	a5 22		lda $22				lda 	zVarDataPtr 			; push the data ptr and type on the stack.
.c358	48		pha				pha
.c359	a5 23		lda $23				lda 	zVarDataPtr+1
.c35b	48		pha				pha
.c35c	a5 24		lda $24				lda 	zVarType
.c35e	48		pha				pha
.c35f	20 38 bc	jsr $bc38			jsr 	EvaluateIntegerX 		; calculate the index.
.c362	68		pla				pla 							; restore and index.
.c363	85 24		sta $24				sta 	zVarType
.c365	68		pla				pla
.c366	85 23		sta $23				sta 	zVarDataPtr+1
.c368	68		pla				pla
.c369	85 22		sta $22				sta 	zVarDataPtr
.c36b	20 c7 c4	jsr $c4c7			jsr 	ArrayIndexFollow 		; do the index.
.c36e	a5 24		lda $24				lda 	zVarType 				; is it still an array ??
.c370	29 01		and #$01			and 	#1
.c372	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.c374	d0 05		bne $c37b			bne 	_VFArrayDone 			; if so then exit.
.c376	20 99 c2	jsr $c299			jsr 	CheckNextComma 			; comma should follow
.c379	80 db		bra $c356			bra 	_VFNextIndex
.c37b					_VFArrayDone:
.c37b	20 90 c2	jsr $c290			jsr 	CheckNextRParen 		; check closing right bracket.
.c37e					_VFSingleElement:
.c37e	60		rts				rts
.c37f					VariableClear:
.c37f	48		pha				pha 							; save registers
.c380	da		phx				phx
.c381	a2 00		ldx #$00			ldx 	#0 						; clear out the hash table.
.c383	8a		txa				txa
.c384	9d 35 03	sta $0335,x	_VCLoop:sta 	HashTableBase,x
.c387	e8		inx				inx
.c388	e0 60		cpx #$60			cpx 	#HashTableEnd-HashTableBase
.c38a	d0 f8		bne $c384			bne 	_VCLoop
.c38c	a9 00		lda #$00			lda 	#VariableMemory & $FF
.c38e	8d 02 03	sta $0302			sta 	VarMemPtr
.c391	a9 20		lda #$20			lda 	#VariableMemory >> 8
.c393	8d 03 03	sta $0303			sta 	VarMemPtr+1
.c396	fa		plx				plx 							; restore registers
.c397	68		pla				pla
.c398	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/extract.asm

.c399					VariableNameError:
.c399	20 9e ae	jsr $ae9e			jsr ERR_Handler
>c39c	42 61 64 20 56 61 72 69			.text "Bad Variable Name",0
>c3a4	61 62 6c 65 20 4e 61 6d 65 00
.c3ae					VariableExtract:
.c3ae	da		phx				phx 							; save X.
.c3af	a9 ba		lda #$ba			lda 	#token_hashlParen  		; set the type to #( e.g. real array.
.c3b1	8d 95 03	sta $0395			sta 	Var_Type
.c3b4	8d 96 03	sta $0396			sta 	Var_Hash 				; we initialise the hash with this. It doesn't matter
.c3b7	ea		nop				nop
.c3b8	b2 16		lda ($16),z			lda 	(zCodePtr),z
.c3ba	c9 00		cmp #$00			cmp 	#0 						; first one must be A-Z
.c3bc	f0 db		beq $c399			beq 	VariableNameError
.c3be	c9 1b		cmp #$1b			cmp 	#26+1
.c3c0	b0 d7		bcs $c399			bcs 	VariableNameError
.c3c2	a2 ff		ldx #$ff			ldx 	#255 					; now copy it into the variable buffer.
.c3c4					_VECopyBuffer:
.c3c4	e8		inx				inx
.c3c5	e0 1f		cpx #$1f			cpx 	#31 					; too long
.c3c7	f0 d0		beq $c399			beq 	VariableNameError
.c3c9	9d 15 03	sta $0315,x			sta 	Var_Buffer,x 			; save character
.c3cc	18		clc				clc  							; update the hash value for it.
.c3cd	6d 96 03	adc $0396			adc 	Var_Hash
.c3d0	8d 96 03	sta $0396			sta 	Var_Hash
.c3d3	1b		inz				inz
.c3d4	ea		nop				nop
.c3d5	b2 16		lda ($16),z			lda 	(zCodePtr),z
.c3d7	c9 00		cmp #$00			cmp 	#0 						; zero or token, end of variable
.c3d9	f0 0e		beq $c3e9			beq 	_VECopyEnd
.c3db	30 0c		bmi $c3e9			bmi 	_VECopyEnd
.c3dd	c9 1b		cmp #$1b			cmp 	#26+1 					; A-Z continue copying
.c3df	90 e3		bcc $c3c4			bcc 	_VECopyBuffer
.c3e1	c9 30		cmp #$30			cmp 	#"0" 					; 0-9 copy as well.
.c3e3	90 04		bcc $c3e9			bcc 	_VECopyEnd
.c3e5	c9 3a		cmp #$3a			cmp 	#"9"+1
.c3e7	90 db		bcc $c3c4			bcc 	_VECopyBuffer
.c3e9					_VECopyEnd:
.c3e9	1b		inz				inz
.c3ea	c9 b7		cmp #$b7			cmp 	#token_Dollar 			; first type token.
.c3ec	90 04		bcc $c3f2			bcc 	_VEDefaultRequired
.c3ee	c9 bd		cmp #$bd			cmp 	#token_PercentLParen+1	; last type token.
.c3f0	90 0b		bcc $c3fd			bcc 	_VEHaveType
.c3f2					_VEDefaultRequired:
.c3f2	c9 bd		cmp #$bd			cmp 	#token_LParen 			; if it ends in ( then use the real array
.c3f4	f0 04		beq $c3fa			beq 	_VESetType 				; default set above.
.c3f6	ce 95 03	dec $0395			dec 	Var_Type 				; this changes that default to the variable default
.c3f9	3b		dez				dez
.c3fa					_VESetType:
.c3fa	ad 95 03	lda $0395			lda 	Var_Type 				; get type ....
.c3fd					_VEHaveType:
.c3fd	8d 95 03	sta $0395			sta 	Var_Type 				; save as type.
.c400	bd 15 03	lda $0315,x			lda 	Var_Buffer,x 			; set bit 7 of name, marks the end.
.c403	09 80		ora #$80			ora 	#$80
.c405	9d 15 03	sta $0315,x			sta 	Var_Buffer,x
.c408	e8		inx				inx 							; offset 3 => length 4.
.c409	8e 97 03	stx $0397			stx 	Var_Length 				; save length of variable name.
.c40c	ad 95 03	lda $0395			lda 	Var_Type 				; get offset of var type from first type token
.c40f	38		sec				sec
.c410	e9 b7		sbc #$b7			sbc 	#token_Dollar
.c412	0a		asl a				asl 	a 						; multiply by 16. This requires HashTableSize
.c413	0a		asl a				asl 	a 						; in data.asm to be 8 (8 sets of links,2 bytes each)
.c414	0a		asl a				asl 	a
.c415	0a		asl a				asl 	a
.c416	8d 98 03	sta $0398			sta 	Var_HashAddress
.c419	ad 96 03	lda $0396			lda 	Var_Hash 				; get the hash
.c41c	29 07		and #$07			and 	#(HashTableSize-1) 		; force into range 0-tableSize-1
.c41e	0a		asl a				asl 	a 						; double it (2 bytes per entry) & clears carry
.c41f	6d 98 03	adc $0398			adc 	Var_HashAddress 		; add table offset.
.c422	69 35		adc #$35			adc 	#HashTableBase & $FF 	; now the low byte of the actual table address
.c424	8d 98 03	sta $0398			sta 	Var_HashAddress
.c427	a2 05		ldx #$05			ldx 	#5 						; hash is 5 bytes (real)
.c429	ad 95 03	lda $0395			lda 	Var_Type
.c42c	c9 b9		cmp #$b9			cmp 	#token_Hash
.c42e	f0 07		beq $c437			beq 	_VEHaveSize
.c430	ca		dex				dex
.c431	c9 bb		cmp #$bb			cmp 	#token_Percent 			; percent is 4 bytes (integer)
.c433	f0 02		beq $c437			beq 	_VEHaveSize
.c435	a2 02		ldx #$02			ldx 	#2 						; everything else is two.
.c437					_VEHaveSize:
.c437	8e 99 03	stx $0399			stx 	Var_DataSize
.c43a	fa		plx				plx
.c43b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varcreate.asm

.c43c					VariableCreate:
.c43c	da		phx				phx
.c43d	5a		phy				phy
.c43e	ad 02 03	lda $0302			lda 	VarMemPtr 					; get address of next free into zTemp1
.c441	85 10		sta $10				sta 	zTemp1
.c443	ad 03 03	lda $0303			lda 	VarMemPtr+1
.c446	85 11		sta $11				sta 	zTemp1+1
.c448	ad 99 03	lda $0399			lda 	Var_DataSize 				; bytes for the data bit
.c44b	18		clc				clc
.c44c	6d 97 03	adc $0397			adc 	Var_Length 					; add the length of the name
.c44f	69 03		adc #$03			adc 	#3 							; 3 for the link and the hash.
.c451	6d 02 03	adc $0302			adc 	VarMemPtr 					; add to variable memory pointer
.c454	8d 02 03	sta $0302			sta 	VarMemPtr
.c457	90 03		bcc $c45c			bcc 	_VCNoCarry
.c459	ee 03 03	inc $0303			inc 	VarMemPtr+1
.c45c					_VCNoCarry:
.c45c	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.c45f	85 12		sta $12				sta 	zTemp2
.c461	a9 03		lda #$03			lda 	#HashTableBase >> 8
.c463	85 13		sta $13				sta 	zTemp2+1
.c465	a0 00		ldy #$00			ldy 	#0 							; put current hash link in position.
.c467	b1 12		lda ($12),y			lda 	(zTemp2),y
.c469	91 10		sta ($10),y			sta 	(zTemp1),y
.c46b	c8		iny				iny
.c46c	b1 12		lda ($12),y			lda 	(zTemp2),y
.c46e	91 10		sta ($10),y			sta 	(zTemp1),y
.c470	c8		iny				iny
.c471	ad 96 03	lda $0396			lda 	Var_Hash 					; write the hash out.
.c474	91 10		sta ($10),y			sta 	(zTemp1),y
.c476	c8		iny				iny
.c477	a2 00		ldx #$00			ldx 	#0 							; copy the name out.
.c479					_VCCopyName:
.c479	bd 15 03	lda $0315,x			lda 	Var_Buffer,x
.c47c	91 10		sta ($10),y			sta 	(zTemp1),y
.c47e	e8		inx				inx
.c47f	c8		iny				iny
.c480	ec 97 03	cpx $0397			cpx 	Var_Length
.c483	d0 f4		bne $c479			bne 	_VCCopyName
.c485	5a		phy				phy 								; save the data offset.
.c486	ae 99 03	ldx $0399			ldx 	Var_DataSize 				; and write the data out.
.c489	a9 00		lda #$00			lda 	#0 							; which is all zeroes.
.c48b					_VCClearData:
.c48b	91 10		sta ($10),y			sta 	(zTemp1),y
.c48d	c8		iny				iny
.c48e	ca		dex				dex
.c48f	d0 fa		bne $c48b			bne 	_VCClearData
.c491	68		pla				pla 								; offset to the data
.c492	18		clc				clc
.c493	65 10		adc $10				adc 	zTemp1 						; add to start and save as data pointer.
.c495	85 22		sta $22				sta 	zVarDataPtr
.c497	a5 11		lda $11				lda 	zTemp1+1
.c499	69 00		adc #$00			adc 	#0
.c49b	85 23		sta $23				sta 	zVarDataPtr+1
.c49d	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.c4a0	85 24		sta $24				sta 	zVarType
.c4a2	a5 10		lda $10				lda 	zTemp1 						; fix hash link to point to new record
.c4a4	a0 00		ldy #$00			ldy 	#0
.c4a6	91 12		sta ($12),y			sta 	(zTemp2),y
.c4a8	c8		iny				iny
.c4a9	a5 11		lda $11				lda 	zTemp1+1
.c4ab	91 12		sta ($12),y			sta 	(zTemp2),y
.c4ad	ad 95 03	lda $0395			lda 	Var_Type 					; array ? if so create the empty one.
.c4b0	29 01		and #$01			and 	#1
.c4b2	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.c4b4	d0 0e		bne $c4c4			bne 	_VCNotArray
.c4b6	a2 00		ldx #$00			ldx 	#0 							; call recursive array creator
.c4b8	20 5e c5	jsr $c55e			jsr 	ArrayCreate
.c4bb	5a		phy				phy 								; save YA at zVarDataPtr
.c4bc	a0 00		ldy #$00			ldy 	#0
.c4be	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.c4c0	c8		iny				iny
.c4c1	68		pla				pla
.c4c2	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.c4c4					_VCNotArray:
.c4c4	7a		ply				ply
.c4c5	fa		plx				plx
.c4c6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arrayidx.asm

.c4c7					ArrayIndexFollow:
.c4c7	5a		phy				phy
.c4c8	a0 00		ldy #$00			ldy 	#0 							; make zVarDataPtr point to the array.
.c4ca	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; e.g. it points to itself.
.c4cc	48		pha				pha
.c4cd	c8		iny				iny
.c4ce	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.c4d0	85 23		sta $23				sta 	zVarDataPtr+1
.c4d2	68		pla				pla
.c4d3	85 22		sta $22				sta 	zVarDataPtr
.c4d5	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; MSB of 16 bit integer and bytes 2&3
.c4d7	29 80		and #$80			and 	#$80 						; must be zero.
.c4d9	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.c4db	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.c4dd	d0 59		bne $c538			bne 	_AIFError
.c4df	a0 00		ldy #$00			ldy 	#0 							; calculate size - current - 1
.c4e1	18		clc				clc
.c4e2	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.c4e4	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.c4e6	c8		iny				iny
.c4e7	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.c4e9	08		php				php 								; clear bit 7 retaining borrow.
.c4ea	29 7f		and #$7f			and 	#$7F
.c4ec	28		plp				plp
.c4ed	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.c4ef	90 47		bcc $c538			bcc 	_AIFError 					; eror if size-current < 0
.c4f1	b5 80		lda $80,x			lda  	XS_Mantissa+0,x 			; copy and double the index
.c4f3	0a		asl a				asl 	a 							; (e.g. index * 2)
.c4f4	85 10		sta $10				sta 	zTemp1
.c4f6	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c4f8	2a		rol a				rol 	a
.c4f9	85 11		sta $11				sta 	zTemp1+1
.c4fb	a0 01		ldy #$01			ldy 	#1 							; is this a data entry.
.c4fd	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; if so, then type is unchanged, offset set
.c4ff	30 1d		bmi $c51e			bmi 	_AIFCalculate
.c501	c6 24		dec $24				dec 	zVarType 					; converts from an array to a type.
.c503	a5 24		lda $24				lda 	zVarType 					; check that type
.c505	c9 b7		cmp #$b7			cmp 	#token_Dollar 				; if string, use x 2
.c507	f0 15		beq $c51e			beq 	_AIFCalculate
.c509	06 10		asl $10				asl 	zTemp1			 			; double the index
.c50b	26 11		rol $11				rol 	zTemp1+1					; (e.g. index * 4)
.c50d	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if integer, use x 4
.c50f	f0 0d		beq $c51e			beq 	_AIFCalculate
.c511	18		clc				clc 								; add the original mantissa in again
.c512	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; which makes it x5, for float.
.c514	65 10		adc $10				adc 	zTemp1
.c516	85 10		sta $10				sta 	zTemp1
.c518	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c51a	65 11		adc $11				adc 	zTemp1+1
.c51c	85 11		sta $11				sta 	zTemp1+1
.c51e					_AIFCalculate:
.c51e	18		clc				clc 								; add index x 2,4 or 5 to base
.c51f	a5 22		lda $22				lda 	zVarDataPtr
.c521	65 10		adc $10				adc 	zTemp1
.c523	85 22		sta $22				sta 	zVarDataPtr
.c525	a5 23		lda $23				lda 	zVarDataPtr+1
.c527	65 11		adc $11				adc 	zTemp1+1
.c529	85 23		sta $23				sta 	zVarDataPtr+1
.c52b	18		clc				clc 								; add 2 more for the length prefix.
.c52c	a5 22		lda $22				lda 	zVarDataPtr
.c52e	69 02		adc #$02			adc 	#2
.c530	85 22		sta $22				sta 	zVarDataPtr
.c532	90 02		bcc $c536			bcc 	_AIFNoBump
.c534	e6 23		inc $23				inc 	zVarDataPtr+1
.c536					_AIFNoBump:
.c536	7a		ply				ply
.c537	60		rts				rts
.c538					_AIFError:
.c538	20 9e ae	jsr $ae9e			jsr ERR_Handler
>c53b	42 61 64 20 61 72 72 61			.text "Bad array index",0
>c543	79 20 69 6e 64 65 78 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arraydef.asm

.c54b					ArrayResetDefault:
.c54b	a9 0b		lda #$0b			lda 	#11 						; 0..10 one array
.c54d	8d a9 03	sta $03a9			sta 	ArrayDef+0
.c550	a9 00		lda #$00			lda 	#0
.c552	8d aa 03	sta $03aa			sta 	ArrayDef+1
.c555	a9 ff		lda #$ff			lda 	#$FF
.c557	8d ab 03	sta $03ab			sta 	ArrayDef+2 					; $FFFF implies no second element.
.c55a	8d ac 03	sta $03ac			sta 	ArrayDef+3					; (test bit 7 of 2nd byte)
.c55d	60		rts				rts
.c55e					ArrayCreate:
.c55e	bd a9 03	lda $03a9,x			lda 	ArrayDef+0,x 				; put size x 2 in zTemp1
.c561	0a		asl a				asl 	a
.c562	85 10		sta $10				sta 	zTemp1
.c564	bd aa 03	lda $03aa,x			lda 	ArrayDef+1,x
.c567	2a		rol a				rol 	a
.c568	85 11		sta $11				sta 	zTemp1+1
.c56a	bd ac 03	lda $03ac,x			lda 	ArrayDef+3,x 				; if this is the last element it's array of ptrs.
.c56d	10 22		bpl $c591			bpl 	_ACSized 					; if not multiply size x 2 (str) 4 (int) 5 (real)
.c56f	ad 95 03	lda $0395			lda 	Var_Type 					; check the type
.c572	c9 b8		cmp #$b8			cmp 	#token_DollarLParen 		; also if it is an array of strings $(
.c574	f0 1b		beq $c591			beq 	_ACSized
.c576	06 10		asl $10				asl 	zTemp1 						; double again
.c578	26 11		rol $11				rol 	zTemp1+1
.c57a	b0 6f		bcs $c5eb			bcs 	ArrayIndexError 			; too large.
.c57c	c9 bc		cmp #$bc			cmp 	#token_PercentLParen 		; if %( four bytes/entry is enough.
.c57e	f0 11		beq $c591			beq 	_ACSized
.c580	18		clc				clc 								; add original value x 5 for reals.
.c581	a5 10		lda $10				lda 	zTemp1
.c583	7d a9 03	adc $03a9,x			adc 	ArrayDef+0,x
.c586	85 10		sta $10				sta 	zTemp1
.c588	a5 11		lda $11				lda 	zTemp1+1
.c58a	7d aa 03	adc $03aa,x			adc 	ArrayDef+1,x
.c58d	85 11		sta $11				sta 	zTemp1+1
.c58f	b0 5a		bcs $c5eb			bcs 	ArrayIndexError
.c591					_ACSized:
.c591	18		clc				clc
.c592	a5 10		lda $10				lda 	zTemp1
.c594	69 02		adc #$02			adc 	#2
.c596	85 10		sta $10				sta 	zTemp1
.c598	90 04		bcc $c59e			bcc 	_ACNoBump
.c59a	e6 10		inc $10				inc 	zTemp1
.c59c	f0 4d		beq $c5eb			beq 	ArrayIndexError
.c59e					_ACNoBump:
.c59e	18		clc				clc
.c59f	ad 02 03	lda $0302			lda 	VarMemPtr 					; add this allocated count to VarMemPtr
.c5a2	85 12		sta $12				sta 	zTemp2						; save start in zTemp2/zTemp3
.c5a4	85 14		sta $14				sta 	zTemp3
.c5a6	65 10		adc $10				adc 	zTemp1
.c5a8	8d 02 03	sta $0302			sta 	VarMemPtr
.c5ab	ad 03 03	lda $0303			lda 	VarMemPtr+1
.c5ae	85 13		sta $13				sta 	zTemp2+1
.c5b0	85 15		sta $15				sta 	zTemp3+1
.c5b2	65 11		adc $11				adc 	zTemp1+1
.c5b4	8d 03 03	sta $0303			sta 	VarMemPtr+1
.c5b7	85 11		sta $11				sta 	zTemp1+1
.c5b9	b0 30		bcs $c5eb			bcs 	ArrayIndexError
.c5bb	a0 00		ldy #$00			ldy 	#0							; write $00 out.
.c5bd					_ACClear:
.c5bd	98		tya				tya
.c5be	91 12		sta ($12),y			sta 	(zTemp2),y
.c5c0	e6 12		inc $12				inc 	zTemp2
.c5c2	d0 02		bne $c5c6			bne 	_ACCBump
.c5c4	e6 13		inc $13				inc 	zTemp2+1
.c5c6					_ACCBump:
.c5c6	a5 12		lda $12				lda 	zTemp2
.c5c8	cd 02 03	cmp $0302			cmp 	VarMemPtr
.c5cb	d0 f0		bne $c5bd			bne 	_ACClear
.c5cd	a5 13		lda $13				lda 	zTemp2+1
.c5cf	cd 03 03	cmp $0303			cmp 	VarMemPtr+1
.c5d2	d0 e9		bne $c5bd			bne 	_ACClear
.c5d4	a0 00		ldy #$00			ldy 	#0
.c5d6	bd a9 03	lda $03a9,x			lda 	ArrayDef+0,x 				; copy the size into the start
.c5d9	91 14		sta ($14),y			sta 	(zTemp3),y
.c5db	c8		iny				iny
.c5dc	bd aa 03	lda $03aa,x			lda 	ArrayDef+1,x
.c5df	91 14		sta ($14),y			sta 	(zTemp3),y
.c5e1	bd ac 03	lda $03ac,x			lda 	ArrayDef+3,x 				; have we reached the end
.c5e4	10 18		bpl $c5fe			bpl 	ACCFillRecursive
.c5e6	a4 15		ldy $15				ldy 	zTemp3+1 					; return address
.c5e8	a5 14		lda $14				lda 	zTemp3
.c5ea	60		rts				rts
.c5eb					ArrayIndexError:
.c5eb	20 9e ae	jsr $ae9e			jsr ERR_Handler
>c5ee	42 61 64 20 61 72 72 61			.text "Bad array index",0
>c5f6	79 20 69 6e 64 65 78 00
.c5fe					ACCFillRecursive:
.c5fe	a9 ff		lda #$ff			lda 	#$FF 						; we mark the end, this is free space.
.c600	a0 00		ldy #$00			ldy 	#0 							; this is overwritten by size of next allocated
.c602	91 12		sta ($12),y			sta 	(zTemp2),y 					; array, but we might change that.
.c604	c8		iny				iny
.c605	b1 14		lda ($14),y			lda 	(zTemp3),y 					; set bit 15 of the max index indicating
.c607	09 80		ora #$80			ora 	#$80 						; an array of pointers
.c609	91 14		sta ($14),y			sta 	(zTemp3),y
.c60b	a5 14		lda $14				lda 	zTemp3 						; push the start on the stack
.c60d	48		pha				pha
.c60e	a5 15		lda $15				lda 	zTemp3+1
.c610	48		pha				pha
.c611					_ACCFillLoop:
.c611	18		clc				clc
.c612	a5 14		lda $14				lda 	zTemp3 						; and work forwards.
.c614	69 02		adc #$02			adc 	#2
.c616	85 14		sta $14				sta 	zTemp3
.c618	90 02		bcc $c61c			bcc 	_ACCSkip2
.c61a	e6 15		inc $15				inc 	zTemp3+1
.c61c					_ACCSkip2:
.c61c	a0 00		ldy #$00			ldy 	#0 							; reached the end ?
.c61e	b1 14		lda ($14),y			lda 	(zTemp3),y					; (looking for FF marker, everything else 00)
.c620	c8		iny				iny
.c621	11 14		ora ($14),y			ora 	(zTemp3),y
.c623	d0 21		bne $c646			bne 	_ACCExit
.c625	a5 14		lda $14				lda 	zTemp3 						; push zTemp3
.c627	48		pha				pha
.c628	a5 15		lda $15				lda 	zTemp3+1
.c62a	48		pha				pha
.c62b	e8		inx				inx
.c62c	e8		inx				inx
.c62d	20 5e c5	jsr $c55e			jsr 	ArrayCreate 				; create array recursively.
.c630	ca		dex				dex
.c631	ca		dex				dex
.c632	85 12		sta $12				sta 	zTemp2 						; save A
.c634	68		pla				pla
.c635	85 15		sta $15				sta 	zTemp3+1 					; restore zTemp3
.c637	68		pla				pla
.c638	85 14		sta $14				sta 	zTemp3
.c63a	98		tya				tya 								; write high bye from Y
.c63b	a0 01		ldy #$01			ldy 	#1
.c63d	91 14		sta ($14),y			sta 	(zTemp3),y
.c63f	88		dey				dey 								; write low byte out.
.c640	a5 12		lda $12				lda 	zTemp2
.c642	91 14		sta ($14),y			sta 	(zTemp3),y
.c644	80 cb		bra $c611			bra 	_ACCFillLoop 				; and try again.
.c646					_ACCExit:
.c646	7a		ply				ply 								; restore the original address
.c647	68		pla				pla
.c648	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varfind.asm

.c649					VariableLocate:
.c649	da		phx				phx
.c64a	5a		phy				phy
.c64b	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.c64e	85 12		sta $12				sta 	zTemp2 						; points to first address.
.c650	a9 03		lda #$03			lda 	#HashTableBase >> 8
.c652	85 13		sta $13				sta 	zTemp2+1
.c654	a0 00		ldy #$00	_VLNext:ldy 	#0 							; get next link into AX
.c656	b1 12		lda ($12),y			lda 	(zTemp2),y
.c658	aa		tax				tax
.c659	c8		iny				iny
.c65a	b1 12		lda ($12),y			lda 	(zTemp2),y
.c65c	85 13		sta $13				sta 	zTemp2+1 					; save in zTemp
.c65e	86 12		stx $12				stx 	zTemp2
.c660	05 12		ora $12				ora 	zTemp2 						; got zero
.c662	18		clc				clc
.c663	f0 25		beq $c68a			beq 	_VLExit 					; if so, then fail as end of chain.
.c665	c8		iny				iny 								; point to hash (offset + 2)
.c666	b1 12		lda ($12),y			lda 	(zTemp2),y
.c668	cd 96 03	cmp $0396			cmp 	Var_Hash
.c66b	d0 e7		bne $c654			bne 	_VLNext 					; try next if different.
.c66d					_VLCompare:
.c66d	c8		iny				iny 								; next character
.c66e	b1 12		lda ($12),y			lda 	(zTemp2),y 					; compare variable field against buffer.
.c670	d9 12 03	cmp $0312,y			cmp 	Var_Buffer-3,y 				; the -3 is because name starts at 3.
.c673	d0 df		bne $c654			bne 	_VLNext 					; fail if different, try next.
.c675	0a		asl a				asl 	a 							; until end character (bit 7 set) matched
.c676	90 f5		bcc $c66d			bcc 	_VLCompare
.c678	98		tya				tya
.c679	38		sec				sec 								; add 1 as Y points to last character
.c67a	65 12		adc $12				adc 	zTemp2 						; add to the current address
.c67c	85 22		sta $22				sta 	zVarDataPtr
.c67e	a5 13		lda $13				lda 	zTemp2+1
.c680	69 00		adc #$00			adc 	#0
.c682	85 23		sta $23				sta 	zVarDataPtr+1
.c684	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.c687	85 24		sta $24				sta 	zVarType
.c689	38		sec				sec 								; return CS
.c68a	7a		ply		_VLExit:ply
.c68b	fa		plx				plx
.c68c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/vargetset.asm

.c68d					VariableGet:
.c68d	5a		phy				phy
.c68e	a0 00		ldy #$00			ldy 	#0 							; copy first two bytes
.c690	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.c692	95 80		sta $80,x			sta 	XS_Mantissa,x
.c694	c8		iny				iny
.c695	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.c697	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c699	c8		iny				iny
.c69a	a5 24		lda $24				lda 	zVarType 					; if it is a string, set up for that.
.c69c	c9 b7		cmp #$b7			cmp 	#token_Dollar
.c69e	f0 2c		beq $c6cc			beq 	_VGString
.c6a0	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; copy the next two bytes.
.c6a2	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c6a4	c8		iny				iny
.c6a5	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.c6a7	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c6a9	c8		iny				iny
.c6aa	a9 01		lda #$01			lda 	#1 							; set type to 1.
.c6ac	95 85		sta $85,x			sta 	XS_Type,x
.c6ae	a5 24		lda $24				lda 	zVarType
.c6b0	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if it is a %, then exit with default integer.
.c6b2	f0 28		beq $c6dc			beq 	_VGExit
.c6b4	a9 40		lda #$40			lda 	#$40 						; set type byte to zero
.c6b6	95 85		sta $85,x			sta 	XS_Type,x 					; which is the code for zero/float.
.c6b8	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; the last value to copy is the exponent.
.c6ba	95 84		sta $84,x			sta 	XS_Exponent,x
.c6bc	f0 1e		beq $c6dc			beq 	_VGExit 					; if exponent is zero ... it's zero.
.c6be	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; the sign bit is the top mantissa bit.
.c6c0	48		pha				pha
.c6c1	29 80		and #$80			and 	#$80
.c6c3	95 85		sta $85,x			sta 	XS_Type,x 					; this is the type byte.
.c6c5	68		pla				pla
.c6c6	09 80		ora #$80			ora 	#$80 						; set the MSB as you would expect.
.c6c8	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; so it's a normalised float.
.c6ca	80 10		bra $c6dc			bra 	_VGExit
.c6cc					_VGString:
.c6cc	a9 02		lda #$02			lda 	#2 							; set type to 2, a string
.c6ce	95 85		sta $85,x			sta 	XS_Type,x
.c6d0	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; is the value there $0000
.c6d2	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.c6d4	d0 06		bne $c6dc			bne 	_VGExit 					; if not, exit.
.c6d6	85 25		sta $25				sta 	zNullString 				; make zNullString a 00 string.
.c6d8	a9 25		lda #$25			lda 	#zNullString
.c6da	95 80		sta $80,x			sta 	XS_Mantissa,x 				; make it point to it.
.c6dc					_VGExit:
.c6dc	7a		ply				ply
.c6dd	60		rts				rts
.c6de					VariableSet:
.c6de	b5 85		lda $85,x			lda 	XS_Type,x 					; is the result a string
.c6e0	29 02		and #$02			and 	#2 							; if so, it has to be
.c6e2	d0 4b		bne $c72f			bne 	_VSString
.c6e4	a5 24		lda $24				lda 	zVarType 					; if type is $ there's an error.
.c6e6	c9 b7		cmp #$b7			cmp 	#token_Dollar
.c6e8	f0 42		beq $c72c			beq 	_VSBadType
.c6ea	c9 bb		cmp #$bb			cmp 	#token_Percent 				; type convert to float/int
.c6ec	f0 05		beq $c6f3			beq 	_VSMakeInt
.c6ee	20 50 cc	jsr $cc50			jsr 	FPUToFloat
.c6f1	80 03		bra $c6f6			bra 	_VSCopy
.c6f3					_VSMakeInt:
.c6f3	20 9c cc	jsr $cc9c			jsr 	FPUToInteger
.c6f6					_VSCopy:
.c6f6	5a		phy				phy
.c6f7	a0 00		ldy #$00			ldy 	#0 							; copy mantissa to target.
.c6f9	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.c6fb	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.c6fd	c8		iny				iny
.c6fe	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c700	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.c702	c8		iny				iny
.c703	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c705	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.c707	c8		iny				iny
.c708	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.c70a	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.c70c	a5 24		lda $24				lda 	zVarType 					; if target is integer, alrady done.
.c70e	c9 bb		cmp #$bb			cmp 	#token_Percent
.c710	f0 18		beq $c72a			beq 	_VSExit
.c712	b5 85		lda $85,x			lda 	XS_Type,x 					; get the sign bit into carry flag.
.c714	0a		asl a				asl 	a
.c715	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; shift the sign into the mantissa high.
.c717	08		php				php
.c718	0a		asl a				asl 	a
.c719	28		plp				plp
.c71a	6a		ror a				ror 	a
.c71b	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.c71d	c8		iny				iny
.c71e	b5 84		lda $84,x			lda 	XS_Exponent,x 				; copy the exponent in
.c720	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.c722	34 85		bit $85,x			bit 	XS_Type,x 					; if the result is non zero
.c724	50 04		bvc $c72a			bvc 	_VSExit
.c726	a9 00		lda #$00			lda 	#00 						; zero exponent indicating 0.
.c728	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.c72a					_VSExit:
.c72a	7a		ply				ply
.c72b	60		rts				rts
.c72c					_VSBadType:
.c72c	4c 7f ae	jmp $ae7f			jmp 	TypeError
.c72f					_VSString:
.c72f	a5 24		lda $24				lda 	zVarType 					; type must be $
.c731	c9 b7		cmp #$b7			cmp 	#token_Dollar
.c733	d0 f7		bne $c72c			bne 	_VSBadType
.c735	da		phx				phx
.c736	5a		phy				phy
.c737	20 a2 c2	jsr $c2a2			jsr 	StringConcrete 				; concrete the string in the mantissa -> AX
.c73a	a0 01		ldy #$01			ldy 	#1 							; save high byte
.c73c	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.c73e	88		dey				dey 								; save low byte
.c73f	8a		txa				txa
.c740	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.c742	7a		ply				ply 								; and exit.
.c743	fa		plx				plx
.c744	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.c745					MulInteger32:
.c745	b5 80		lda $80,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.c747	95 8c		sta $8c,x			sta 	XS3_Mantissa,x
.c749	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c74b	95 8d		sta $8d,x			sta 	XS3_Mantissa+1,x
.c74d	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c74f	95 8e		sta $8e,x			sta 	XS3_Mantissa+2,x
.c751	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.c753	95 8f		sta $8f,x			sta 	XS3_Mantissa+3,x
.c755	a9 00		lda #$00			lda 	#0
.c757	95 80		sta $80,x			sta 	XS_Mantissa+0,x 				; zero +0, where the result goes.
.c759	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c75b	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c75d	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c75f					_BFMMultiply:
.c75f	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.c761	29 01		and #$01			and 	#1
.c763	f0 03		beq $c768			beq 	_BFMNoAdd
.c765	20 d8 bd	jsr $bdd8			jsr 	AddInteger32 					; co-opt this code
.c768					_BFMNoAdd:
.c768	16 86		asl $86,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.c76a	36 87		rol $87,x			rol 	XS2_Mantissa+1,x
.c76c	36 88		rol $88,x			rol 	XS2_Mantissa+2,x
.c76e	36 89		rol $89,x			rol 	XS2_Mantissa+3,x
.c770	56 8f		lsr $8f,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.c772	76 8e		ror $8e,x			ror 	XS3_Mantissa+2,x
.c774	76 8d		ror $8d,x			ror 	XS3_Mantissa+1,x
.c776	76 8c		ror $8c,x			ror 	XS3_Mantissa,x
.c778	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.c77a	15 8d		ora $8d,x			ora 	XS3_Mantissa+1,x
.c77c	15 8e		ora $8e,x			ora 	XS3_Mantissa+2,x
.c77e	15 8f		ora $8f,x			ora 	XS3_Mantissa+3,x
.c780	d0 dd		bne $c75f			bne 	_BFMMultiply
.c782	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.c783					DivInteger32:
.c783	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; check for division by zero.
.c785	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.c787	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.c789	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.c78b	d0 14		bne $c7a1			bne 	_BFDOkay
.c78d	20 9e ae	jsr $ae9e			jsr ERR_Handler
>c790	44 69 76 69 73 69 6f 6e			.text "Division by Zero",0
>c798	20 62 79 20 5a 65 72 6f 00
.c7a1					_BFDOkay:
.c7a1	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.c7a3	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.c7a5	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.c7a7	85 1c		sta $1c				sta 	zLTemp1+2
.c7a9	85 1d		sta $1d				sta 	zLTemp1+3
.c7ab	8d 9e 03	sta $039e			sta 	SignCount 					; Count of signs.
.c7ae	20 05 c8	jsr $c805			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.c7b1	da		phx				phx
.c7b2	e8		inx				inx
.c7b3	e8		inx				inx
.c7b4	e8		inx				inx
.c7b5	e8		inx				inx
.c7b6	e8		inx				inx
.c7b7	e8		inx				inx
.c7b8	20 05 c8	jsr $c805			jsr 	CheckIntegerNegate
.c7bb	fa		plx				plx
.c7bc	5a		phy				phy 								; Y is the counter
.c7bd	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.c7bf					_BFDLoop:
.c7bf	16 80		asl $80,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.c7c1	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.c7c3	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.c7c5	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.c7c7	26 1a		rol $1a				rol 	zLTemp1
.c7c9	26 1b		rol $1b				rol 	zLTemp1+1
.c7cb	26 1c		rol $1c				rol 	zLTemp1+2
.c7cd	26 1d		rol $1d				rol 	zLTemp1+3
.c7cf	38		sec				sec
.c7d0	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.c7d2	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.c7d4	48		pha				pha
.c7d5	a5 1b		lda $1b				lda 	zLTemp1+1
.c7d7	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.c7d9	48		pha				pha
.c7da	a5 1c		lda $1c				lda 	zLTemp1+2
.c7dc	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.c7de	48		pha				pha
.c7df	a5 1d		lda $1d				lda 	zLTemp1+3
.c7e1	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.c7e3	90 13		bcc $c7f8			bcc 	_BFDNoAdd
.c7e5	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.c7e7	68		pla				pla
.c7e8	85 1c		sta $1c				sta 	zLTemp1+2
.c7ea	68		pla				pla
.c7eb	85 1b		sta $1b				sta 	zLTemp1+1
.c7ed	68		pla				pla
.c7ee	85 1a		sta $1a				sta 	zLTemp1+0
.c7f0	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.c7f2	09 01		ora #$01			ora 	#1
.c7f4	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c7f6	80 03		bra $c7fb			bra 	_BFDNext
.c7f8					_BFDNoAdd:
.c7f8	68		pla				pla 								; Throw away the intermediate calculations
.c7f9	68		pla				pla
.c7fa	68		pla				pla
.c7fb					_BFDNext:
.c7fb	88		dey				dey
.c7fc	d0 c1		bne $c7bf			bne 	_BFDLoop
.c7fe	7a		ply				ply 								; restore Y
.c7ff	4e 9e 03	lsr $039e			lsr 	SignCount 					; if sign count odd,
.c802	b0 06		bcs $c80a			bcs		IntegerNegateAlways 		; negate the result
.c804	60		rts				rts
.c805					CheckIntegerNegate:
.c805	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; is it -ve = MSB set ?
.c807	30 01		bmi $c80a			bmi 	IntegerNegateAlways 		; if so negate it
.c809	60		rts				rts
.c80a					IntegerNegateAlways:
.c80a	ee 9e 03	inc $039e			inc 	SignCount 					; bump the count of signs
.c80d	38		sec				sec 								; 0-mantissa,x -> mantissa,x
.c80e	a9 00		lda #$00			lda 	#0
.c810	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.c812	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c814	a9 00		lda #$00			lda 	#0
.c816	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.c818	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c81a	a9 00		lda #$00			lda 	#0
.c81c	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.c81e	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c820	a9 00		lda #$00			lda 	#0
.c822	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.c824	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c826	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.c827					INTToString:
.c827	48		pha				pha
.c828	5a		phy				phy
.c829	b5 83		lda $83,x			lda 		XS_Mantissa+3,x 		; check -ve
.c82b	10 08		bpl $c835			bpl 		_ITSNotMinus
.c82d	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.c82f	20 c5 c8	jsr $c8c5			jsr 		ITSOutputCharacter
.c832	20 0a c8	jsr $c80a			jsr 		IntegerNegateAlways 	; negate the number.
.c835					_ITSNotMinus:
.c835	a9 00		lda #$00			lda 		#0
.c837	8d 9a 03	sta $039a			sta 		NumSuppress 			; clear the suppression flag.
.c83a	8a		txa				txa 								; use Y for the mantissa index.
.c83b	a8		tay				tay
.c83c	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.c83e					_ITSNextSubtractor:
.c83e	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.c840	8d 9b 03	sta $039b			sta 		NumConvCount
.c843					_ITSSubtract:
.c843	38		sec				sec
.c844	b9 80 00	lda $0080,y			lda 		XS_Mantissa,y 			; subtract number and push on stack
.c847	fd a1 c8	sbc $c8a1,x			sbc 		_ITSSubtractors+0,x
.c84a	48		pha				pha
.c84b	b9 81 00	lda $0081,y			lda 		XS_Mantissa+1,y
.c84e	fd a2 c8	sbc $c8a2,x			sbc 		_ITSSubtractors+1,x
.c851	48		pha				pha
.c852	b9 82 00	lda $0082,y			lda 		XS_Mantissa+2,y
.c855	fd a3 c8	sbc $c8a3,x			sbc 		_ITSSubtractors+2,x
.c858	48		pha				pha
.c859	b9 83 00	lda $0083,y			lda 		XS_Mantissa+3,y
.c85c	fd a4 c8	sbc $c8a4,x			sbc 		_ITSSubtractors+3,x
.c85f	90 14		bcc $c875			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.c861	99 83 00	sta $0083,y			sta 		XS_Mantissa+3,y 		; save subtract off stack
.c864	68		pla				pla
.c865	99 82 00	sta $0082,y			sta 		XS_Mantissa+2,y
.c868	68		pla				pla
.c869	99 81 00	sta $0081,y			sta 		XS_Mantissa+1,y
.c86c	68		pla				pla
.c86d	99 80 00	sta $0080,y			sta 		XS_Mantissa+0,y
.c870	ee 9b 03	inc $039b			inc 		NumConvCount 			; bump count.
.c873	80 ce		bra $c843			bra 		_ITSSubtract 			; go round again.
.c875					_ITSCantSubtract:
.c875	68		pla				pla 								; throw away interim answers
.c876	68		pla				pla
.c877	68		pla				pla
.c878	ad 9b 03	lda $039b			lda 		NumConvCount 			; if not zero then no suppression check
.c87b	c9 30		cmp #$30			cmp 		#"0"
.c87d	d0 05		bne $c884			bne 		_ITSOutputDigit
.c87f	ad 9a 03	lda $039a			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.c882	10 09		bpl $c88d			bpl	 		_ITSGoNextSubtractor
.c884					_ITSOutputDigit:
.c884	ce 9a 03	dec $039a			dec 		NumSuppress 			; suppression check will be non-zero.
.c887	ad 9b 03	lda $039b			lda 		NumConvCount 			; count of subtractions
.c88a	20 c5 c8	jsr $c8c5			jsr 		ITSOutputCharacter 		; output it.
.c88d					_ITSGoNextSubtractor:
.c88d	e8		inx				inx 								; next dword
.c88e	e8		inx				inx
.c88f	e8		inx				inx
.c890	e8		inx				inx
.c891	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.c893	d0 a9		bne $c83e			bne 		_ITSNextSubtractor 		; do all the subtractors.
.c895	98		tya				tya 								; X is back as the mantissa index
.c896	aa		tax				tax
.c897	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.c899	09 30		ora #$30			ora 		#"0"
.c89b	20 c5 c8	jsr $c8c5			jsr 		ITSOutputCharacter
.c89e	7a		ply				ply 								; and exit
.c89f	68		pla				pla
.c8a0	60		rts				rts
.c8a1					_ITSSubtractors:
>c8a1	00 ca 9a 3b					.dword 		1000000000
>c8a5	00 e1 f5 05					.dword 		100000000
>c8a9	80 96 98 00					.dword 		10000000
>c8ad	40 42 0f 00					.dword 		1000000
>c8b1	a0 86 01 00					.dword 		100000
>c8b5	10 27 00 00					.dword 		10000
>c8b9	e8 03 00 00					.dword 		1000
>c8bd	64 00 00 00					.dword 		100
>c8c1	0a 00 00 00					.dword 		10
.c8c5					_ITSSubtractorsEnd:
.c8c5					ITSOutputCharacter:
.c8c5	48		pha				pha
.c8c6	da		phx				phx
.c8c7	ae 14 03	ldx $0314			ldx 	NumBufX 					; save digit
.c8ca	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.c8cd	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.c8cf	9d 16 03	sta $0316,x			sta 	Num_Buffer+1,x
.c8d2	ee 14 03	inc $0314			inc 	NumBufX						; bump pointer.
.c8d5	fa		plx				plx
.c8d6	68		pla				pla
.c8d7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.c8d8					IntFromString:
.c8d8	a0 00		ldy #$00			ldy 	#0
.c8da	8c 9c 03	sty $039c			sty 	ExpTemp 					; this is the converted digit count.
.c8dd					IntFromStringY:
.c8dd	48		pha				pha
.c8de	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.c8e0	95 80		sta $80,x			sta 	XS_Mantissa,x
.c8e2	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c8e4	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c8e6	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c8e8	a9 01		lda #$01			lda 	#1
.c8ea	95 85		sta $85,x			sta 	XS_Type,x
.c8ec					_IFSLoop:
.c8ec	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.c8ee	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.c8f0	90 4e		bcc $c940			bcc 	_IFSExit
.c8f2	c9 3a		cmp #$3a			cmp 	#"9"+1
.c8f4	b0 4a		bcs $c940			bcs 	_IFSExit
.c8f6	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.c8f8	c9 0c		cmp #$0c			cmp 	#12
.c8fa	b0 4e		bcs $c94a			bcs 	_IFSOverflow
.c8fc	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.c8fe	48		pha				pha
.c8ff	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c901	48		pha				pha
.c902	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c904	48		pha				pha
.c905	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.c907	48		pha				pha
.c908	20 5f c9	jsr $c95f			jsr 	IFSX1ShiftLeft 				; double
.c90b	20 5f c9	jsr $c95f			jsr 	IFSX1ShiftLeft 				; x 4
.c90e	18		clc				clc 								; add saved value x 5
.c90f	68		pla				pla
.c910	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.c912	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c914	68		pla				pla
.c915	75 81		adc $81,x			adc 	XS_Mantissa+1,x
.c917	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c919	68		pla				pla
.c91a	75 82		adc $82,x			adc 	XS_Mantissa+2,x
.c91c	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c91e	68		pla				pla
.c91f	75 83		adc $83,x			adc 	XS_Mantissa+3,x
.c921	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c923	20 5f c9	jsr $c95f			jsr 	IFSX1ShiftLeft 				; x 10
.c926	ee 9c 03	inc $039c			inc 	ExpTemp 					; bump count of digits processed.
.c929	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.c92b	29 0f		and #$0f			and 	#15
.c92d	c8		iny				iny
.c92e	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.c930	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c932	90 b8		bcc $c8ec			bcc 	_IFSLoop
.c934	f6 81		inc $81,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.c936	d0 b4		bne $c8ec			bne 	_IFSLoop
.c938	f6 82		inc $82,x			inc 	XS_Mantissa+2,x
.c93a	d0 b0		bne $c8ec			bne 	_IFSLoop
.c93c	f6 83		inc $83,x			inc 	XS_Mantissa+3,x
.c93e	80 ac		bra $c8ec			bra 	_IFSLoop
.c940					_IFSExit:
.c940	98		tya				tya 								; get offset
.c941					_IFSOkay:
.c941	38		sec				sec
.c942	ad 9c 03	lda $039c			lda 	ExpTemp
.c945	f0 01		beq $c948			beq 	_IFSSkipFail
.c947	18		clc				clc
.c948					_IFSSkipFail:
.c948	68		pla				pla 								; and exit.
.c949	60		rts				rts
.c94a					_IFSOverflow:
.c94a	20 9e ae	jsr $ae9e			jsr 	ERR_Handler
>c94d	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>c955	20 6f 76 65 72 66 6c 6f 77 00
.c95f					IFSX1ShiftLeft:
.c95f	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.c961	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.c963	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.c965	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.c967	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.c968					FPSubtract:
.c968	48		pha				pha
.c969	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.c96b	49 80		eor #$80			eor 	#$80
.c96d	95 8b		sta $8b,x			sta 	XS2_Type,x
.c96f	68		pla				pla 								; --- and fall through ---
.c970					FPAdd:
.c970	48		pha				pha
.c971	b5 85		lda $85,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.c973	d0 05		bne $c97a			bne 	_FPA_NegativeLHS
.c975	20 91 c9	jsr $c991			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.c978	68		pla				pla
.c979	60		rts				rts
.c97a					_FPA_NegativeLHS:
.c97a	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.c97c	49 80		eor #$80			eor 	#$80
.c97e	95 85		sta $85,x			sta 	XS_Type,x
.c980	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of B and add
.c982	49 80		eor #$80			eor 	#$80
.c984	95 8b		sta $8b,x			sta 	XS2_Type,x
.c986	20 91 c9	jsr $c991			jsr 	FPAdd_Worker 				; do the add calculation.
.c989	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 back
.c98b	49 80		eor #$80			eor 	#$80
.c98d	95 85		sta $85,x			sta 	XS_Type,x
.c98f	68		pla				pla
.c990	60		rts				rts
.c991					FPAdd_Worker:
.c991	34 8b		bit $8b,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.c993	70 07		bvs $c99c			bvs 	_FPAWExit 					; no change.
.c995	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.c997	50 07		bvc $c9a0			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.c999	20 0e cc	jsr $cc0e			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.c99c					_FPAWExit:
.c99c	20 7d cc	jsr $cc7d			jsr 	FPUNormalise 				; normalise the result.
.c99f	60		rts				rts
.c9a0					_FPAWMakeSame:
.c9a0	b5 84		lda $84,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.c9a2	38		sec				sec
.c9a3	f5 8a		sbc $8a,x			sbc	 	XS2_Exponent,x 				; using subtraction
.c9a5	f0 16		beq $c9bd			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.c9a7	da		phx				phx 								; save X
.c9a8	90 06		bcc $c9b0			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.c9aa	e8		inx				inx
.c9ab	e8		inx				inx
.c9ac	e8		inx				inx
.c9ad	e8		inx				inx
.c9ae	e8		inx				inx
.c9af	e8		inx				inx
.c9b0					_FPAWShiftA:
.c9b0	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.c9b2	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.c9b4	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.c9b6	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.c9b8	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.c9ba	fa		plx				plx 								; restore original X
.c9bb	80 e3		bra $c9a0			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.c9bd					_FPAW_DoArithmetic:
.c9bd	34 8b		bit $8b,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.c9bf	30 28		bmi $c9e9			bmi 	_FPAW_BNegative
.c9c1	18		clc				clc
.c9c2	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.c9c4	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.c9c6	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c9c8	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c9ca	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.c9cc	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c9ce	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c9d0	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.c9d2	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c9d4	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.c9d6	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.c9d8	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c9da	90 c0		bcc $c99c			bcc 	_FPAWExit 					; no carry.
.c9dc	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.c9de	38		sec				sec
.c9df	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.c9e1	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.c9e3	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.c9e5	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.c9e7	80 b3		bra $c99c			bra 	_FPAWExit
.c9e9					_FPAW_BNegative:
.c9e9	38		sec				sec
.c9ea	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.c9ec	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.c9ee	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c9f0	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c9f2	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.c9f4	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c9f6	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c9f8	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.c9fa	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c9fc	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.c9fe	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.ca00	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.ca02	b0 09		bcs $ca0d			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.ca04	20 34 cc	jsr $cc34			jsr 	FPUNegateInteger			; negate the mantissa
.ca07	b5 85		lda $85,x			lda 	XS_Type,x 					; flip result sign
.ca09	49 80		eor #$80			eor 	#$80
.ca0b	95 85		sta $85,x			sta 	XS_Type,x
.ca0d					_FPAWGoExit:
.ca0d	4c 9c c9	jmp $c99c			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.ca10					FPD_IsDivZero:
.ca10	20 9e ae	jsr $ae9e			jsr ERR_Handler
>ca13	44 69 76 69 73 69 6f 6e			.text "Division by zero",0
>ca1b	20 62 79 20 7a 65 72 6f 00
.ca24					FPDivide:
.ca24	48		pha				pha
.ca25	5a		phy				phy
.ca26	34 8b		bit $8b,x			bit 	XS2_Type,x 					; check if division by zero
.ca28	70 e6		bvs $ca10			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.ca2a	34 85		bit $85,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.ca2c	f0 03		beq $ca31			beq 	_FPDCalculateExp
.ca2e					_FPD_Exit:
.ca2e	7a		ply				ply
.ca2f	68		pla				pla
.ca30	60		rts				rts
.ca31					_FPDCalculateExp:
.ca31	b5 8a		lda $8a,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.ca33	49 ff		eor #$ff			eor 	#$FF
.ca35	1a		inc a				inc 	a
.ca36	95 8a		sta $8a,x			sta 	XS2_Exponent,x
.ca38	20 08 cb	jsr $cb08			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.ca3b	18		clc				clc 	 							; add 1 to the resulting exponent
.ca3c	69 01		adc #$01			adc 	#1
.ca3e	b0 54		bcs $ca94			bcs 	_FPD_Overflow 				; which can overflow.
.ca40	95 84		sta $84,x			sta 	XS_Exponent,x
.ca42	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.ca44	85 1a		sta $1a				sta 	zLTemp1+0
.ca46	85 1b		sta $1b				sta 	zLTemp1+1
.ca48	85 1c		sta $1c				sta 	zLTemp1+2
.ca4a	85 1d		sta $1d				sta 	zLTemp1+3
.ca4c	a0 20		ldy #$20			ldy 	#32 						; times round.
.ca4e					_FPD_Loop:
.ca4e	38		sec				sec 								; calculate X1-X2 stacking result because we might
.ca4f	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; not save it.
.ca51	f5 86		sbc $86,x			sbc 	XS2_Mantissa,x
.ca53	48		pha				pha
.ca54	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.ca56	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.ca58	48		pha				pha
.ca59	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.ca5b	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.ca5d	48		pha				pha
.ca5e	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.ca60	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.ca62	90 13		bcc $ca77			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.ca64	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; save results out to A
.ca66	68		pla				pla
.ca67	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.ca69	68		pla				pla
.ca6a	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.ca6c	68		pla				pla
.ca6d	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.ca6f	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.ca71	09 80		ora #$80			ora 	#$80
.ca73	85 1d		sta $1d				sta 	zLTemp1+3
.ca75	80 03		bra $ca7a			bra 	_FPD_Rotates
.ca77					_FPD_NoSubtract:
.ca77	68		pla				pla 								; throw away unwanted results
.ca78	68		pla				pla
.ca79	68		pla				pla
.ca7a					_FPD_Rotates:
.ca7a	56 89		lsr $89,x			lsr 	3+XS2_Mantissa,x
.ca7c	76 88		ror $88,x			ror 	2+XS2_Mantissa,x
.ca7e	76 87		ror $87,x			ror 	1+XS2_Mantissa,x
.ca80	76 86		ror $86,x			ror 	0+XS2_Mantissa,x
.ca82	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.ca84	26 1b		rol $1b				rol 	zLTemp1+1
.ca86	26 1c		rol $1c				rol 	zLTemp1+2
.ca88	26 1d		rol $1d				rol 	zLTemp1+3
.ca8a	90 02		bcc $ca8e			bcc 	_FPD_NoCarry
.ca8c	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.ca8e					_FPD_NoCarry:
.ca8e	88		dey				dey 								; do 32 times
.ca8f	d0 bd		bne $ca4e			bne 	_FPD_Loop
.ca91	4c ec ca	jmp $caec			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.ca94					_FPD_Overflow:
.ca94	4c da cc	jmp $ccda			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.ca97					FPMultiply:
.ca97	48		pha				pha
.ca98	5a		phy				phy
.ca99	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.ca9b	70 07		bvs $caa4			bvs 	_FPM_Exit
.ca9d	34 8b		bit $8b,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.ca9f	50 06		bvc $caa7			bvc 	_FPM_CalcExponent
.caa1	20 0e cc	jsr $cc0e			jsr 	FPUCopyX2ToX1
.caa4					_FPM_Exit:
.caa4	7a		ply				ply
.caa5	68		pla				pla
.caa6	60		rts				rts
.caa7					_FPM_CalcExponent:
.caa7	18		clc				clc
.caa8	20 08 cb	jsr $cb08			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.caab	95 84		sta $84,x			sta 	XS_Exponent,x 				; save the result.
.caad	a9 00		lda #$00			lda 	#0
.caaf	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.cab1	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.cab3	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.cab5	85 1d		sta $1d				sta 	zLTemp1+3
.cab7	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.cab9					_FPM_Loop:
.cab9	b5 80		lda $80,x			lda 	XS_Mantissa,x				; check LSB of long product
.cabb	29 01		and #$01			and 	#1
.cabd	18		clc				clc 								; clear carry for the long rotate.
.cabe	f0 19		beq $cad9			beq 	_FPM_NoAddition
.cac0	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.cac1	a5 1a		lda $1a				lda 	zLTemp1+0
.cac3	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.cac5	85 1a		sta $1a				sta 	zLTemp1+0
.cac7	a5 1b		lda $1b				lda 	zLTemp1+1
.cac9	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.cacb	85 1b		sta $1b				sta 	zLTemp1+1
.cacd	a5 1c		lda $1c				lda 	zLTemp1+2
.cacf	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.cad1	85 1c		sta $1c				sta 	zLTemp1+2
.cad3	a5 1d		lda $1d				lda 	zLTemp1+3
.cad5	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.cad7	85 1d		sta $1d				sta 	zLTemp1+3
.cad9					_FPM_NoAddition:
.cad9	66 1d		ror $1d				ror 	3+zLTemp1
.cadb	66 1c		ror $1c				ror 	2+zLTemp1
.cadd	66 1b		ror $1b				ror 	1+zLTemp1
.cadf	66 1a		ror $1a				ror 	0+zLTemp1
.cae1	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.cae3	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.cae5	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.cae7	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.cae9	88		dey				dey
.caea	d0 cd		bne $cab9			bne 	_FPM_Loop 					; do this 32 times.
.caec					FPM_CopySignNormalize:
.caec	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.caee	95 80		sta $80,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.caf0	a5 1b		lda $1b				lda 	zLTemp1+1
.caf2	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.caf4	a5 1c		lda $1c				lda 	zLTemp1+2
.caf6	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.caf8	a5 1d		lda $1d				lda 	zLTemp1+3
.cafa	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.cafc	b5 85		lda $85,x			lda 	XS_Type,x 					; sign is xor of signs
.cafe	55 8b		eor $8b,x			eor 	XS2_Type,x
.cb00	95 85		sta $85,x			sta 	XS_Type,x
.cb02	20 7d cc	jsr $cc7d			jsr 	FPUNormalise 				; normalise and exit.
.cb05	7a		ply				ply
.cb06	68		pla				pla
.cb07	60		rts				rts
.cb08					FPCalculateExponent:
.cb08	18		clc				clc
.cb09	b5 84		lda $84,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.cb0b	75 8a		adc $8a,x			adc 	XS2_Exponent,x
.cb0d	b0 08		bcs $cb17			bcs 	_FPCECarry 					; carry out ?
.cb0f	10 03		bpl $cb14			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.cb11	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.cb13	60		rts				rts
.cb14					_FPCEExpZero:
.cb14	a9 00		lda #$00			lda 	#0
.cb16	60		rts				rts
.cb17					_FPCECarry:
.cb17	30 03		bmi $cb1c			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.cb19	09 80		ora #$80			ora 	#$80 						; put in right range
.cb1b	60		rts				rts
.cb1c					_FPCEOverflow:
.cb1c	4c da cc	jmp $ccda			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.cb1f					FPFractionalPart:
.cb1f	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.cb21	38		sec				sec 								; this flag tells us to keep the fractional part
.cb22	30 0d		bmi $cb31			bmi 	FPGetPart
.cb24	60		rts				rts
.cb25					FPIntegerPart:
.cb25	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.cb27	18		clc				clc 								; this flag says keep the integer part.
.cb28	30 07		bmi $cb31			bmi 	FPGetPart 					; -ve exponents are 0..127
.cb2a	48		pha				pha
.cb2b	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.cb2d	95 85		sta $85,x			sta 	XS_Type,x
.cb2f	68		pla				pla
.cb30	60		rts				rts
.cb31					FPGetPart:
.cb31	48		pha				pha
.cb32	5a		phy				phy 								; save Y
.cb33	08		php				php 								; save action
.cb34	34 85		bit $85,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.cb36	70 59		bvs $cb91			bvs 	_FPGP_Exit 					; then do nothing.
.cb38	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.cb3a	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.cb3c	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.cb3e	85 1c		sta $1c				sta 	zLTemp1+2
.cb40	85 1d		sta $1d				sta 	zLTemp1+3
.cb42	b5 84		lda $84,x			lda 	XS_Exponent,x				; the number of shifts.
.cb44	38		sec				sec
.cb45	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.cb47	f0 12		beq $cb5b			beq 	_FPGP_NoShift 				; ... if any
.cb49	c9 20		cmp #$20			cmp 	#32
.cb4b	90 02		bcc $cb4f			bcc 	_FPGP_NotMax
.cb4d	a9 20		lda #$20			lda 	#32 						; max of 32.
.cb4f					_FPGP_NotMax:
.cb4f	a8		tay				tay 								; Y is the mask shift count.
.cb50					_FPGP_ShiftMask:
.cb50	46 1d		lsr $1d				lsr 	3+zLTemp1
.cb52	66 1c		ror $1c				ror 	2+zLTemp1
.cb54	66 1b		ror $1b				ror 	1+zLTemp1
.cb56	66 1a		ror $1a				ror 	0+zLTemp1
.cb58	88		dey				dey
.cb59	d0 f5		bne $cb50			bne 	_FPGP_ShiftMask
.cb5b					_FPGP_NoShift:
.cb5b	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.cb5d	8e 9c 03	stx $039c			stx 	ExpTemp						; save X
.cb60					_FPGP_MaskLoop:
.cb60	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.cb63	28		plp				plp 								; if CC we keep the top part, so we
.cb64	08		php				php		 							; flip the mask.
.cb65	b0 02		bcs $cb69			bcs		_FPGP_NoFlip
.cb67	49 ff		eor #$ff			eor 	#$FF
.cb69					_FPGP_NoFlip:
.cb69	35 80		and $80,x			and 	XS_Mantissa,x 				; and into the mantissa.
.cb6b	95 80		sta $80,x			sta 	XS_Mantissa,x
.cb6d	e8		inx				inx
.cb6e	c8		iny				iny
.cb6f	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.cb71	d0 ed		bne $cb60			bne 	_FPGP_MaskLoop
.cb73	ae 9c 03	ldx $039c			ldx 	ExpTemp						; restore X
.cb76	28		plp				plp
.cb77	08		php				php 								; get action flag on the stack
.cb78	90 04		bcc $cb7e			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.cb7a	a9 00		lda #$00			lda 	#0
.cb7c	95 85		sta $85,x			sta 	XS_Type,x
.cb7e					_FPGP_NotFractional:
.cb7e	b5 80		lda $80,x			lda 	XS_Mantissa,x 						; check if \1 zero
.cb80	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.cb82	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.cb84	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.cb86	f0 05		beq $cb8d			beq 	_FPGP_Zero 					; if zero, return zero
.cb88	20 7d cc	jsr $cc7d			jsr 	FPUNormalise
.cb8b	80 04		bra $cb91			bra 	_FPGP_Exit 					; and exit
.cb8d					_FPGP_Zero:
.cb8d	a9 40		lda #$40			lda 	#$40 						; set zero flag
.cb8f	95 85		sta $85,x			sta 	XS_Type,x
.cb91					_FPGP_Exit:
.cb91	68		pla				pla 								; throw saved action flag.
.cb92	7a		ply				ply
.cb93	68		pla				pla
.cb94	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.cb95					FPCompare:
.cb95	20 d6 cb	jsr $cbd6			jsr 	FPFastCompare 				; fast compare try first
.cb98	b0 3b		bcs $cbd5			bcs 	_FPCExit 					; that worked.
.cb9a	b5 84		lda $84,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.cb9c	48		pha				pha
.cb9d	b5 8a		lda $8a,x			lda 	XS2_Exponent,x
.cb9f	48		pha				pha
.cba0	20 68 c9	jsr $c968			jsr 	FPSubtract 					; calculate X1-X2
.cba3	34 85		bit $85,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.cba5	70 2a		bvs $cbd1			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.cba7	68		pla				pla
.cba8	8d 9c 03	sta $039c			sta 	ExpTemp						; save first exponent in temporary reg.
.cbab	68		pla				pla
.cbac	38		sec				sec
.cbad	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; calculate AX-BX
.cbb0	70 14		bvs $cbc6			bvs 	_FPCNotEqual				; overflow, can't be equal.
.cbb2	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.cbb3	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.cbb5	b0 0f		bcs $cbc6			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.cbb7	38		sec				sec
.cbb8	ad 9c 03	lda $039c			lda 	ExpTemp 					; get one of the exponents back.
.cbbb	e9 12		sbc #$12			sbc 	#18 						; allow for 2^18 error, relatively.
.cbbd	b0 02		bcs $cbc1			bcs 	_FPCNotRange 				; keep in range.
.cbbf	a9 01		lda #$01			lda 	#1
.cbc1					_FPCNotRange:
.cbc1	38		sec				sec
.cbc2	f5 84		sbc $84,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.cbc4	b0 0d		bcs $cbd3			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.cbc6					_FPCNotEqual:
.cbc6	b5 85		lda $85,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.cbc8	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.cbca	f0 02		beq $cbce			beq 	_FPCNE2
.cbcc	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.cbce	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.cbcf	80 04		bra $cbd5			bra 	_FPCExit
.cbd1					_FPCPullZero:
.cbd1	68		pla				pla 								; throw saved exponents
.cbd2	68		pla				pla
.cbd3					_FPCZero:
.cbd3	a9 00		lda #$00			lda 	#0 							; and return zero
.cbd5					_FPCExit:
.cbd5	60		rts				rts
.cbd6					FPFastCompare:
.cbd6	34 85		bit $85,x			bit 	XS_Type,x 					; n1 is zero.
.cbd8	70 23		bvs $cbfd			bvs 	_FPFLeftZero
.cbda	34 8b		bit $8b,x			bit 	XS2_Type,x 					; n2 is zero
.cbdc	b5 85		lda $85,x			lda 	XS_Type,x 					; if so, return sign bit of 1 (n-0)
.cbde	70 25		bvs $cc05			bvs 	_FPFSignBit
.cbe0	55 8b		eor $8b,x			eor 	XS2_Type,x 					; eor 2 type bits. now know both non-zero
.cbe2	0a		asl a				asl 	a 							; put in CS if different.
.cbe3	b5 85		lda $85,x			lda 	XS_Type,x 					; if signs different return sign of first
.cbe5	b0 1e		bcs $cc05			bcs 	_FPFSignBit
.cbe7	38		sec				sec 								; same sign and not-zero. compare exponents
.cbe8	b5 84		lda $84,x			lda 	XS_Exponent,x 				; compare exponents. if the same, then fail.
.cbea	f5 8a		sbc $8a,x			sbc 	XS2_Exponent,x 				; e.g. we have to do it via subtraction.
.cbec	f0 09		beq $cbf7			beq 	_FPNoFastCompare
.cbee	6a		ror a				ror 	a 							; put carry into bit 7.
.cbef	34 85		bit $85,x			bit 	XS_Type,X 					; if it is +x then flip it.
.cbf1	30 02		bmi $cbf5			bmi		_FPFCNotMinus
.cbf3	49 80		eor #$80			eor 	#$80
.cbf5					_FPFCNotMinus:
.cbf5	80 0e		bra $cc05			bra		_FPFSignBit
.cbf7					_FPNoFastCompare:
.cbf7	18		clc				clc
.cbf8	60		rts				rts
.cbf9					_FPFZero:
.cbf9	a9 00		lda #$00			lda 	#0
.cbfb					_FPFExitSet:
.cbfb	38		sec				sec
.cbfc	60		rts				rts
.cbfd					_FPFLeftZero:
.cbfd	34 8b		bit $8b,x			bit 	XS2_Type,x 					; if right is zero, return zero.
.cbff	70 f8		bvs $cbf9			bvs 	_FPFZero
.cc01	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip sign bit
.cc03	49 80		eor #$80			eor 	#$80						; return that as a sign.
.cc05					_FPFSignBit:
.cc05	0a		asl a				asl 	a
.cc06	a9 01		lda #$01			lda 	#1
.cc08	90 f1		bcc $cbfb			bcc		_FPFExitSet
.cc0a	a9 ff		lda #$ff			lda 	#$FF
.cc0c	38		sec				sec
.cc0d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.cc0e					FPUCopyX2ToX1:
.cc0e	48		pha				pha
.cc0f	da		phx				phx
.cc10	5a		phy				phy
.cc11	a0 08		ldy #$08			ldy 	#8
.cc13	b5 86		lda $86,x	_FPUC21:lda 	XS2_Mantissa,x
.cc15	95 80		sta $80,x			sta 	XS_Mantissa,x
.cc17	e8		inx				inx
.cc18	88		dey				dey
.cc19	10 f8		bpl $cc13			bpl 	_FPUC21
.cc1b	7a		ply				ply
.cc1c	fa		plx				plx
.cc1d	68		pla				pla
.cc1e	60		rts				rts
.cc1f					FPUSetInteger:
.cc1f	48		pha				pha
.cc20	95 80		sta $80,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.cc22	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.cc24	10 02		bpl $cc28			bpl 	_FPUSIExtend
.cc26	a9 ff		lda #$ff			lda 	#$FF
.cc28					_FPUSIExtend:
.cc28	95 81		sta $81,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.cc2a	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.cc2c	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.cc2e	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.cc30	95 85		sta $85,x			sta 	XS_Type,x
.cc32	68		pla				pla
.cc33	60		rts				rts
.cc34					FPUNegateInteger:
.cc34	48		pha				pha
.cc35	38		sec				sec
.cc36	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.cc38	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.cc3a	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.cc3c	a9 00		lda #$00			lda 	#0
.cc3e	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.cc40	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.cc42	a9 00		lda #$00			lda 	#0
.cc44	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.cc46	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.cc48	a9 00		lda #$00			lda 	#0
.cc4a	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.cc4c	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.cc4e	68		pla				pla
.cc4f	60		rts				rts
.cc50					FPUToFloat:
.cc50	48		pha				pha
.cc51	b5 85		lda $85,x			lda 	XS_Type,x					; exit if already float.
.cc53	29 0f		and #$0f			and 	#$0F
.cc55	f0 24		beq $cc7b			beq 	_FPUFExit
.cc57	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.cc59	95 85		sta $85,x			sta 	XS_Type,x
.cc5b	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.cc5d	95 84		sta $84,x			sta 	XS_Exponent,x 				; x mantissa.
.cc5f	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.cc61	10 07		bpl $cc6a			bpl		_FPUFPositive
.cc63	20 34 cc	jsr $cc34			jsr 	FPUNegateInteger 			; negate the mantissa
.cc66	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.cc68	95 85		sta $85,x			sta 	XS_Type,x
.cc6a					_FPUFPositive:
.cc6a	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.cc6c	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.cc6e	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.cc70	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.cc72	d0 04		bne $cc78			bne 	_FPUFNonZero
.cc74	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.cc76	95 85		sta $85,x			sta 	XS_Type,x
.cc78					_FPUFNonZero:
.cc78	20 7d cc	jsr $cc7d			jsr 	FPUNormalise 				; normalise the floating point.
.cc7b					_FPUFExit:
.cc7b	68		pla				pla
.cc7c	60		rts				rts
.cc7d					FPUNormalise:
.cc7d	48		pha				pha
.cc7e	34 85		bit $85,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.cc80	70 18		bvs $cc9a			bvs 	_FPUNExit
.cc82	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.cc84	f0 10		beq $cc96			beq 	_FPUNSetZero
.cc86					_FPUNLoop:
.cc86	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.cc88	30 10		bmi $cc9a			bmi 	_FPUNExit 					; if so, we are normalised.
.cc8a	16 80		asl $80,x			asl 	0+XS_Mantissa+0,x
.cc8c	36 81		rol $81,x			rol 	1+XS_Mantissa+0,x
.cc8e	36 82		rol $82,x			rol 	2+XS_Mantissa+0,x
.cc90	36 83		rol $83,x			rol 	3+XS_Mantissa+0,x
.cc92	d6 84		dec $84,x			dec 	XS_Exponent,x 				; decrement exponent
.cc94	d0 f0		bne $cc86			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.cc96					_FPUNSetZero:
.cc96	a9 40		lda #$40			lda 	#$40
.cc98	95 85		sta $85,x			sta 	XS_Type,x 					; the result is now zero.
.cc9a					_FPUNExit:
.cc9a	68		pla				pla
.cc9b	60		rts				rts
.cc9c					FPUToInteger:
.cc9c	48		pha				pha
.cc9d	b5 85		lda $85,x			lda 	XS_Type,x 					; if already integer, exit
.cc9f	29 01		and #$01			and 	#1
.cca1	d0 31		bne $ccd4			bne 	_FPUTOI_Exit
.cca3	34 85		bit $85,x			bit 	XS_Type,x					; if zero, return zero.
.cca5	70 23		bvs $ccca			bvs 	_FPUTOI_Zero
.cca7	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.cca9	10 1f		bpl $ccca			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.ccab	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.ccad	b0 2b		bcs $ccda			bcs 	FP_Overflow
.ccaf					_FPUToIToInteger:
.ccaf	b5 84		lda $84,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.ccb1	c9 a0		cmp #$a0			cmp 	#128+32
.ccb3	f0 0c		beq $ccc1			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.ccb5	f6 84		inc $84,x			inc 	XS_Exponent,X 				; increment Exponent
.ccb7	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.ccb9	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.ccbb	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.ccbd	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.ccbf	80 ee		bra $ccaf			bra 	_FPUToIToInteger 			; keep going.
.ccc1					_FPUToICheckSign:
.ccc1	b5 85		lda $85,x			lda 	XS_Type,x 					; check sign
.ccc3	10 0f		bpl $ccd4			bpl 	_FPUToI_Exit 				; exit if unsigned.
.ccc5	20 34 cc	jsr $cc34			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.ccc8	80 0a		bra $ccd4			bra 	_FPUTOI_Exit
.ccca					_FPUTOI_Zero:
.ccca	a9 00		lda #$00			lda 	#0 							; return zero integer.
.cccc	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.ccce	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.ccd0	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.ccd2	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.ccd4					_FPUToI_Exit:
.ccd4	a9 01		lda #$01			lda 	#1 							; set type to integer
.ccd6	95 85		sta $85,x			sta 	XS_Type,x
.ccd8	68		pla				pla
.ccd9	60		rts				rts
.ccda					FP_Overflow:
.ccda	20 9e ae	jsr $ae9e			jsr ERR_Handler
>ccdd	46 6c 6f 61 74 69 6e 67			.text "Floating Point overflow",0
>cce5	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.ccf5					FPUTimes10:
.ccf5	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.ccf7	85 1a		sta $1a				sta 	ZLTemp1+0
.ccf9	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.ccfb	85 1b		sta $1b				sta 	ZLTemp1+1
.ccfd	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.ccff	85 1c		sta $1c				sta 	ZLTemp1+2
.cd01	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.cd03	85 1d		sta $1d				sta 	ZLTemp1+3
.cd05	20 3a cd	jsr $cd3a			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.cd08	20 3a cd	jsr $cd3a			jsr 	_FPUT_LSR_ZLTemp1
.cd0b	18		clc				clc
.cd0c	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.cd0e	65 1a		adc $1a				adc 	ZLTemp1+0
.cd10	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.cd12	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.cd14	65 1b		adc $1b				adc 	ZLTemp1+1
.cd16	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.cd18	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.cd1a	65 1c		adc $1c				adc 	ZLTemp1+2
.cd1c	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.cd1e	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.cd20	65 1d		adc $1d				adc 	ZLTemp1+3
.cd22	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.cd24	90 0a		bcc $cd30			bcc 	_FPUTimes10
.cd26	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.cd28	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.cd2a	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.cd2c	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.cd2e	f6 84		inc $84,x			inc 	XS_Exponent,x				; fix exponent
.cd30					_FPUTimes10:
.cd30	b5 84		lda $84,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.cd32	18		clc				clc
.cd33	69 03		adc #$03			adc 	#3
.cd35	95 84		sta $84,x			sta 	XS_Exponent,x
.cd37	b0 a1		bcs $ccda			bcs 	FP_Overflow 				; error
.cd39	60		rts				rts
.cd3a					_FPUT_LSR_ZLTemp1:
.cd3a	46 1d		lsr $1d				lsr 	ZLTemp1+3
.cd3c	66 1c		ror $1c				ror 	ZLTemp1+2
.cd3e	66 1b		ror $1b				ror 	ZLTemp1+1
.cd40	66 1a		ror $1a				ror 	ZLTemp1+0
.cd42	60		rts				rts
.cd43					FPUScale10A:
.cd43	5a		phy				phy
.cd44	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.cd46	f0 37		beq $cd7f			beq 	_FPUScaleExit
.cd48	da		phx				phx 								; save X
.cd49	e8		inx				inx
.cd4a	e8		inx				inx
.cd4b	e8		inx				inx
.cd4c	e8		inx				inx
.cd4d	e8		inx				inx
.cd4e	e8		inx				inx
.cd4f	a8		tay				tay 								; save power scalar in Y.
.cd50	a9 00		lda #$00			lda 	#0
.cd52	95 80		sta $80,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.cd54	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.cd56	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.cd58	95 85		sta $85,x			sta 	XS_Type,x
.cd5a	a9 80		lda #$80			lda 	#$80
.cd5c	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.cd5e	a9 81		lda #$81			lda 	#$81
.cd60	95 84		sta $84,x			sta 	XS_Exponent,x
.cd62	5a		phy				phy 								; save 10^n on stack.
.cd63	c0 00		cpy #$00			cpy 	#0
.cd65	10 05		bpl $cd6c			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.cd67	98		tya				tya
.cd68	49 ff		eor #$ff			eor 	#$FF
.cd6a	1a		inc a				inc 	a
.cd6b	a8		tay				tay
.cd6c					_FPUSAbs:
.cd6c	20 f5 cc	jsr $ccf5			jsr 	FPUTimes10
.cd6f	88		dey				dey
.cd70	d0 fa		bne $cd6c			bne 	_FPUSAbs 					; tos is now 10^|AC|
.cd72	68		pla				pla 								; restore count in A
.cd73	fa		plx				plx 								; restore X pointing to number to scale.
.cd74	0a		asl a				asl 	a
.cd75	b0 05		bcs $cd7c			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.cd77	20 97 ca	jsr $ca97			jsr 	FPMultiply 					; if clear multiply.
.cd7a	80 03		bra $cd7f			bra		_FPUScaleExit
.cd7c					_FPUSDivide:
.cd7c	20 24 ca	jsr $ca24			jsr 	FPDivide
.cd7f					_FPUScaleExit:
.cd7f	7a		ply				ply
.cd80	60		rts				rts
.cd81					FPUCopyToNext:
.cd81	a0 06		ldy #$06			ldy 		#6
.cd83	da		phx				phx
.cd84					_FPUCopy1:
.cd84	b5 80		lda $80,x			lda 	XS_Mantissa,x
.cd86	95 86		sta $86,x			sta 	XS2_Mantissa,x
.cd88	e8		inx				inx
.cd89	88		dey				dey
.cd8a	d0 f8		bne $cd84			bne 	_FPUCopy1
.cd8c	fa		plx				plx
.cd8d	60		rts				rts
.cd8e					FPUCopyFromNext:
.cd8e	a0 06		ldy #$06			ldy 		#6
.cd90	da		phx				phx
.cd91					_FPUCopy1:
.cd91	b5 86		lda $86,x			lda 	XS2_Mantissa,x
.cd93	95 80		sta $80,x			sta 	XS_Mantissa,x
.cd95	e8		inx				inx
.cd96	88		dey				dey
.cd97	d0 f8		bne $cd91			bne 	_FPUCopy1
.cd99	fa		plx				plx
.cd9a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.cd9b					FPToString:
.cd9b	48		pha				pha
.cd9c	5a		phy				phy
.cd9d	34 85		bit $85,x			bit 		XS_Type,x 				; check zero flag
.cd9f	50 0a		bvc $cdab			bvc 		_FPTSIsFloat 			; if zero,
.cda1					_FPTSZero:
.cda1	a9 30		lda #$30			lda 		#"0"
.cda3	20 c5 c8	jsr $c8c5			jsr 		ITSOutputCharacter
.cda6					_FPTSExit:
.cda6	7a		ply				ply
.cda7	68		pla				pla
.cda8	60		rts				rts
.cda9	80 fb		bra $cda6			bra 		_FPTSExit
.cdab					_FPTSIsFloat:
.cdab	b5 85		lda $85,x			lda 		XS_Type,x 				; is it signed ?
.cdad	10 09		bpl $cdb8			bpl 		_FPTSNotSigned
.cdaf	a9 00		lda #$00			lda 		#0 						; clear sign flag
.cdb1	95 85		sta $85,x			sta 		XS_Type,x
.cdb3	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.cdb5	20 c5 c8	jsr $c8c5			jsr 		ITSOutputCharacter
.cdb8					_FPTSNotSigned:
.cdb8	b5 84		lda $84,x			lda 		XS_Exponent,x
.cdba	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.cdbc	b0 09		bcs $cdc7			bcs 		_FPTSExponent
.cdbe	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.cdc0	90 05		bcc $cdc7			bcc 		_FPTSExponent 			;
.cdc2					_FPTSStandard:
.cdc2	20 06 ce	jsr $ce06			jsr 		FPTOutputBody 			; output the body.
.cdc5	80 df		bra $cda6			bra 		_FPTSExit
.cdc7					_FPTSExponent:
.cdc7	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.cdc9	8d 9d 03	sta $039d			sta 		ExpCount
.cdcc					_FPTSExponentLoop:
.cdcc	b5 84		lda $84,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.cdce	10 0e		bpl $cdde			bpl 		_FPTSTimes
.cdd0	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.cdd2	90 14		bcc $cde8			bcc 		_FPTSScaledToExp
.cdd4	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.cdd6	20 43 cd	jsr $cd43			jsr 		FPUScale10A
.cdd9	ee 9d 03	inc $039d			inc 		ExpCount
.cddc	80 ee		bra $cdcc			bra 		_FPTSExponentLoop
.cdde					_FPTSTimes:
.cdde	a9 01		lda #$01			lda 		#1
.cde0	20 43 cd	jsr $cd43			jsr 		FPUScale10A
.cde3	ce 9d 03	dec $039d			dec 		ExpCount
.cde6	80 e4		bra $cdcc			bra 		_FPTSExponentLoop
.cde8					_FPTSScaledToExp:
.cde8	20 06 ce	jsr $ce06			jsr 		FPTOutputBody 			; output the body.
.cdeb	a9 65		lda #$65			lda 		#"e"					; output E
.cded	20 c5 c8	jsr $c8c5			jsr 		ITSOutputCharacter
.cdf0	ad 9d 03	lda $039d			lda 		ExpCount 				; get the exponent
.cdf3	95 80		sta $80,x			sta 		XS_Mantissa,x
.cdf5	29 80		and #$80			and 		#$80 					; sign extend it
.cdf7	f0 02		beq $cdfb			beq 		_FPTSSExt
.cdf9	a9 ff		lda #$ff			lda 		#$FF
.cdfb					_FPTSSExt:
.cdfb	95 81		sta $81,x			sta 		XS_Mantissa+1,x
.cdfd	95 82		sta $82,x			sta 		XS_Mantissa+2,x
.cdff	95 83		sta $83,x			sta 		XS_Mantissa+3,x
.ce01	20 27 c8	jsr $c827			jsr 		INTToString 			; output the exponent.
.ce04	80 a0		bra $cda6			bra			_FPTSExit 				; and exit.
.ce06					FPTOutputBody:
.ce06	20 81 cd	jsr $cd81			jsr 		FPUCopyToNext 			; copy to next slot.
.ce09	20 9c cc	jsr $cc9c			jsr 		FPUToInteger 			; convert to an integer
.ce0c	20 27 c8	jsr $c827			jsr 		INTToString 			; output the main integer part.
.ce0f	20 8e cd	jsr $cd8e			jsr 		FPUCopyFromNext 		; get the fractional part back.
.ce12	20 1f cb	jsr $cb1f			jsr 		FPFractionalPart 		; get the decimal part.
.ce15	34 85		bit $85,x			bit 		XS_Type,x 				; any fractional part.
.ce17	70 3c		bvs $ce55			bvs 		_FPTOExit 				; if not, exit now.
.ce19	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.ce1b	20 c5 c8	jsr $c8c5			jsr 		ITSOutputCharacter
.ce1e					_FPOutLoop:
.ce1e	34 85		bit $85,x			bit 		XS_Type,x 				; finally reached zero.
.ce20	70 1d		bvs $ce3f			bvs 		_FPStripZeros 			; strip trailing zeros
.ce22	20 f5 cc	jsr $ccf5			jsr 		FPUTimes10 				; multiply by 10
.ce25	20 81 cd	jsr $cd81			jsr 		FPUCopyToNext			; copy to next slot.
.ce28	20 9c cc	jsr $cc9c			jsr 		FPUToInteger 			; convert to integer
.ce2b	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; print digit.
.ce2d	09 30		ora #$30			ora 		#"0"
.ce2f	20 c5 c8	jsr $c8c5			jsr 		ITSOutputCharacter
.ce32	20 8e cd	jsr $cd8e			jsr 		FPUCopyFromNext 		; get it back
.ce35	20 1f cb	jsr $cb1f			jsr 		FPFractionalPart 		; get fractional part
.ce38	ad 14 03	lda $0314			lda 		NumBufX 				; done 11 characters yet ?
.ce3b	c9 0b		cmp #$0b			cmp 	 	#11
.ce3d	90 df		bcc $ce1e			bcc 		_FPOutLoop 				; if so, keep going till zero.
.ce3f					_FPStripZeros:
.ce3f	ac 14 03	ldy $0314			ldy 		NumBufX 				; strip trailing zeros.
.ce42					_FPStripLoop:
.ce42	88		dey				dey 								; back one, if at start then no strip
.ce43	f0 10		beq $ce55			beq 		_FPToExit
.ce45	b9 15 03	lda $0315,y			lda 		Num_Buffer,y 			; keep going if "0"
.ce48	c9 30		cmp #$30			cmp 		#"0"
.ce4a	f0 f6		beq $ce42			beq 		_FPStripLoop
.ce4c	c8		iny				iny
.ce4d	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.ce4f	99 15 03	sta $0315,y			sta 		Num_Buffer,y
.ce52	8c 14 03	sty $0314			sty 		NumBufX 				; update position.
.ce55					_FPTOExit:
.ce55	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.ce56					FPFromString:
.ce56	48		pha				pha 								; push A
.ce57	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.ce59	c9 2e		cmp #$2e			cmp 	#"."
.ce5b	f0 03		beq $ce60			beq	 	_FPFIsDecimal
.ce5d	4c bc ce	jmp $cebc			jmp 	_FPFNotDecimal
.ce60					_FPFIsDecimal:
.ce60	c8		iny				iny 								; consume the decimal.
.ce61	20 50 cc	jsr $cc50			jsr 	FPUToFloat 					; convert the integer to float.
.ce64	da		phx				phx 								; save X.
.ce65	5a		phy				phy 								; save decimal start position
.ce66	e8		inx				inx
.ce67	e8		inx				inx
.ce68	e8		inx				inx
.ce69	e8		inx				inx
.ce6a	e8		inx				inx
.ce6b	e8		inx				inx
.ce6c	20 dd c8	jsr $c8dd			jsr 	INTFromStringY 				; get the part after the DP.
.ce6f	20 50 cc	jsr $cc50			jsr 	FPUToFloat 					; convert that to a float.
.ce72	68		pla				pla 								; calculate - chars consumed.
.ce73	8c 9c 03	sty $039c			sty 	ExpTemp
.ce76	38		sec				sec
.ce77	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; this is the shift amount
.ce7a	20 43 cd	jsr $cd43			jsr 	FPUScale10A 				; scale it by 10^AC
.ce7d	fa		plx				plx 								; restore original X
.ce7e	20 70 c9	jsr $c970			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.ce81	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.ce83	c9 45		cmp #$45			cmp 	#"E"
.ce85	f0 04		beq $ce8b			beq 	_FPFExponent
.ce87	c9 65		cmp #$65			cmp 	#"e"
.ce89	d0 31		bne $cebc			bne 	_FPFNotDecimal 				; no, then exit normally.
.ce8b					_FPFExponent:
.ce8b	c8		iny				iny 								; skip over E symbol.
.ce8c	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.ce8e	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.ce90	d0 01		bne $ce93			bne 	_FPFGotSign
.ce92	c8		iny				iny 								; if it was - skip over it.
.ce93					_FPFGotSign:
.ce93	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.ce94	da		phx				phx
.ce95	e8		inx				inx
.ce96	e8		inx				inx
.ce97	e8		inx				inx
.ce98	e8		inx				inx
.ce99	e8		inx				inx
.ce9a	e8		inx				inx
.ce9b	20 dd c8	jsr $c8dd			jsr 	INTFromStringY 				; get the exponent
.ce9e	fa		plx				plx 								; restore X.
.ce9f	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.cea1	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.cea3	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.cea5	d0 17		bne $cebe			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.cea7	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.cea9	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.ceab	b0 11		bcs $cebe			bcs 	_FPFXOverflow
.cead	68		pla				pla 								; get direction
.ceae	d0 07		bne $ceb7			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.ceb0	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.ceb2	49 ff		eor #$ff			eor 	#$FF
.ceb4	1a		inc a				inc 	a
.ceb5	95 86		sta $86,x			sta 	XS2_Mantissa+0,x
.ceb7					_FPFXScale:
.ceb7	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.ceb9	20 43 cd	jsr $cd43			jsr 	FPUScale10A 				; scale by the exponent.
.cebc					_FPFNotDecimal:
.cebc	68		pla				pla
.cebd	60		rts				rts
.cebe					_FPFXOverflow:
.cebe	20 9e ae	jsr $ae9e			jsr 	ERR_Handler
>cec1	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>cec9	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.ced0					Unary_Rnd:
.ced0	20 2a bc	jsr $bc2a			jsr 	EvaluateNumberX 			; get value
.ced3	20 90 c2	jsr $c290			jsr 	CheckNextRParen 			; check right bracket.
.ced6	20 aa be	jsr $beaa			jsr 	GetSignCurrent 				; get sign -1,0,1.
.ced9	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.cedb	30 10		bmi $ceed			bmi 	_URSetSeed
.cedd	f0 28		beq $cf07			beq 	_URMakeRandom 				; if zero return same number, don't advance sequence
.cedf	da		phx				phx
.cee0	a2 00		ldx #$00			ldx 	#0 							; run 16 bit RNG procession on upper/lower
.cee2	20 3e cf	jsr $cf3e			jsr 	Random16
.cee5	a2 02		ldx #$02			ldx 	#2
.cee7	20 3e cf	jsr $cf3e			jsr 	Random16
.ceea	fa		plx				plx
.ceeb	80 1a		bra $cf07			bra 	_URMakeRandom
.ceed					_URSetSeed:
.ceed	20 50 cc	jsr $cc50			jsr 	FPUToFloat 					; make it a float to twiddle it.
.cef0	b5 80		lda $80,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.cef2	8d a3 03	sta $03a3			sta 	RandomSeed+0
.cef5	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.cef7	8d a4 03	sta $03a4			sta 	RandomSeed+1
.cefa	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.cefc	8d a5 03	sta $03a5			sta 	RandomSeed+2
.ceff	b5 83		lda $83,x			lda		XS_Mantissa+3,x 			; this is to make the seed bear not much
.cf01	0a		asl a				asl 	a 							; resemblance to the seed value.
.cf02	49 db		eor #$db			eor 	#$DB
.cf04	8d a6 03	sta $03a6			sta 	RandomSeed+3
.cf07					_URMakeRandom:
.cf07	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; check if seed is zero.
.cf0a	0d a4 03	ora $03a4			ora 	RandomSeed+1
.cf0d	0d a5 03	ora $03a5			ora 	RandomSeed+2
.cf10	0d a6 03	ora $03a6			ora 	RandomSeed+3
.cf13	d0 0a		bne $cf1f			bne 	_URNotZero
.cf15	a9 47		lda #$47			lda 	#$47						; if it is, make it non zero.
.cf17	8d a4 03	sta $03a4			sta 	RandomSeed+1				; in both parts.
.cf1a	a9 3d		lda #$3d			lda 	#$3D
.cf1c	8d a6 03	sta $03a6			sta 	RandomSeed+3
.cf1f					_URNotZero:
.cf1f	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; copy seed into mantissa.
.cf22	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.cf24	ad a4 03	lda $03a4			lda 	RandomSeed+1
.cf27	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.cf29	ad a5 03	lda $03a5			lda 	RandomSeed+2
.cf2c	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.cf2e	ad a6 03	lda $03a6			lda 	RandomSeed+3
.cf31	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.cf33	a9 00		lda #$00			lda 	#$00 						; set type to float.
.cf35	95 85		sta $85,x			sta 	XS_Type,x
.cf37	a9 80		lda #$80			lda 	#$80
.cf39	95 84		sta $84,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.cf3b	4c 7d cc	jmp $cc7d			jmp 	FPUNormalise 				; and normalise.
.cf3e					Random16:
.cf3e	5e a4 03	lsr $03a4,x			lsr 	RandomSeed+1,x				; shift seed right
.cf41	7e a3 03	ror $03a3,x			ror 	RandomSeed,x
.cf44	90 08		bcc $cf4e			bcc 	_R16_NoXor
.cf46	bd a4 03	lda $03a4,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.cf49	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.cf4b	9d a4 03	sta $03a4,x			sta 	RandomSeed+1,x
.cf4e					_R16_NoXor:
.cf4e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.cf4f					Unary_Int:
.cf4f	20 2a bc	jsr $bc2a			jsr 	EvaluateNumberX 			; get value
.cf52	20 90 c2	jsr $c290			jsr 	CheckNextRParen 			; check right bracket.
.cf55	4c 9c cc	jmp $cc9c			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Return to file: basic.asm

.cf58	80 fe		bra $cf58	_halt:	bra 		_halt
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 a0						.word 	StartROM
>fffe	88 ac					.word TIM_BreakVector

;******  End of listing
