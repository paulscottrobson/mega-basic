
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Sun Sep  1 10:30:43 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="65816"				cpu = "65816"
="em65816"				hardware = "em65816"
=1					exitonend = 1
=0					autorun = 0
=1					loadtest = 1
=1					hasfloat = 1
=1					hasinteger = 1
=253					maxstring = 253

;******  Processing file: modules/basic/pointer/em65816/src_em65816.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stackmarkers.inc

=5					SourcePosSize   =   5 							; Source position stack space needed.
=1					SMark_Gosub 	= 	1 							; 0 is GOSUB/RETURN.
=2					SMark_Repeat 	= 	2 							; 1 is REPEAT/UNTIL.
=3					SMark_While 	= 	3 							; 2 is WHILE/WEND.
=4					SMark_If 		= 	4 							; 3 is IF/ENDIF
=5					SMark_For 		= 	5 							; 4 is FOR/NEXT

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/hardware/common/macros32.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0020					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0022					zVarDataPtr: .word ? 						; position of variable data.
>0024					zVarType: 	.byte ? 						; type of data (token)
>0025					zNullString:.byte ? 						; represents a NULL string.
>0026					zBasicSP:	.word ? 						; stack pointer
>0080					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>0084					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>0085					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=134					XS2_Mantissa = XS_Mantissa+XS_Size
=138					XS2_Exponent = XS_Exponent+XS_Size
=139					XS2_Type = XS_Type+XS_Size
=140					XS3_Mantissa = XS_Mantissa+XS_Size*2
=144					XS3_Exponent = XS_Exponent+XS_Size*2
=145					XS3_Type = XS_Type+XS_Size*2
>0300					StringPtr:	.word ? 						; Top of free memory (for string allocation)
>0302					VarMemPtr: 	.word ?							; Bottom of free memory (for variables)
>0304					endOfProgram: .dword ? 						; End of Program Memory (long)
>0308					vecPrintCharacter .word ?
>030a					vecInputCharacter .word ?
>030c					UserVector .fill 4 							; USR(x) calls this.
>0310					LocalVector .fill 4 						; Indirect calls call this.
>0314					NumBufX 	.byte 	?						; buffer index position
>0315					Num_Buffer	.fill 	32 						; buffer for numeric conversions
=6					HashTableCount = 6 							; there are 6 hash tables, in token order.
=8					HashTableSize = 8 							; each hash table as 8 links.
.0335					HashTableBase:
>0335								.fill	HashTableCount * HashTableSize * 2
.0395					HashTableEnd:
=$315					Var_Buffer 	= Num_Buffer 					; buffer for variable name (same space)
>0395					Var_Type    .byte ? 						; type of variable (as a type token)
>0396					Var_Hash 	.byte ? 						; hash of identifier name.
>0397					Var_Length 	.byte ? 						; length of variable name
>0398					Var_HashAddress .byte ?						; low byte of hash table entry.
>0399					Var_DataSize .byte ?						; size of one element.
>039a					NumSuppress	.byte 	?						; leading zero suppression flag
>039b					NumConvCount .byte 	? 						; count for conversions.
>039c					ExpTemp:	.byte ?							; Working temp for exponents.
>039d					ExpCount:	.byte ? 						; Count of decimal exponents.
>039e					SignCount:	.byte ?							; Integer Divide Sign Counts.
>039f					TempStringWriteIndex: .byte ? 				; Write offset.
>03a0					ValSign: 	.byte ? 						; sign flag for val()
>03a1					SliceStart:	.byte ? 						; string slice parts
>03a2					SliceCount:	.byte ?
>03a3					RandomSeed:	.dword ? 						; Random seed.
>03a7					SignNext:	.byte ? 						; Used for keeping sign of STEP in FOR/NEXT
>03a8					BreakCount:	.byte ? 						; Counter, avoid checking break every command.
=3					ArrayMaxDim = 3 							; number of dimensions.
>03a9					ArrayDef:	.fill (ArrayMaxDim+1)*2 		; dimensions for auto-creation
>03b1					UsrArrayDef:.fill (ArrayMaxDim+1)*2 		; dimensions created in DIM
>03b9					UsrArrayIdx:.byte ? 						; index into UsrArrayDef
>03ba					LastPrinted:.byte ? 						; last printed char ?
>03bb					ListIndent: .byte ? 						; list indent level
>03bc					LastListIndent:.byte ? 						; previous one.
>03bd					DataLPtr: 	.dword ?						; the data long ptr (swapped with zCodePtr)
>03c1					DataIndex:	.byte ?							; index position.
>03c2					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>03c4					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>03c6					Tim_SR:		.byte ? 						; Processor Status
>03c7					Tim_A:		.byte ? 						; Processor Registers
>03c8					Tim_X:		.byte ?
>03c9					Tim_Y:		.byte ?
>03ca					Tim_Z:		.byte ?
>03cb					Tim_SP:		.word ?							; Stack Pointer (just in cases)
>0400					BasicStack:	.fill 	256 					; and occupy whole pages.
.0500					EndBasicStack:
>0500					IFT_XCursor:.byte ?							; current logical position on screen
>0501					IFT_YCursor:.byte ?
>0502					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0566					IFT_LineBuffer: .fill 100 					; line input buffer.

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/em65816.asm

=$7f00					HighMemory = $7F00
=$3000					VariableMemory = $3000
.1000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testcode.src

>1000	0b 0a 00 c6 01 bf 02 bb			.byte	$0b,$0a,$00,$c6,$01,$bf,$02,$bb
>1008	bf 03 00 21 14 00 c5 58			.byte	$bf,$03,$00,$21,$14,$00,$c5,$58
>1010	bf 71 bf 41 7c fd 03 37			.byte	$bf,$71,$bf,$41,$7c,$fd,$03,$37
>1018	bf fe 07 48 65 6c 6c 6f			.byte	$bf,$fe,$07,$48,$65,$6c,$6c,$6f
>1020	c0 d6 fe 09 52 65 61 64			.byte	$c0,$d6,$fe,$09,$52,$65,$61,$64
>1028	2e 2e 2e 00 0b 1e 00 d6			.byte	$2e,$2e,$2e,$00,$0b,$1e,$00,$d6
>1030	01 bf 02 bb bf 03 00 05			.byte	$01,$bf,$02,$bb,$bf,$03,$00,$05
>1038	28 00 c4 00 00				.byte	$28,$00,$c4,$00,$00

;******  Return to file: modules/hardware/em65816.asm

.c000					StartROM:
.c000	18		clc				clc
.c001	fb		xce				xce
.c002	c2 30		rep #$30			rep 	#$30
.c004	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.c007	1b		tcs				tcs
.c008	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.c00b	e2 30		sep #$30			sep 	#$30
.c00d	c2 30		rep #$30			rep 	#$30						; clear AXY in 16 bit.
.c00f	a9 00		lda #$00			lda 	#$0000
.c011	aa		tax				tax
.c012	a8		tay				tay
.c013	e2 30		sep #$30			sep 	#$30
.c015	5c f6 87 01	jmp $0187f6		jmp BASIC_Start
.c019					TIM_BreakHandler:
.c019	5c 69 83 01	jmp $018369			jmp 	TIM_BreakVector

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.018000					IFT_ClearScreen:
.018000	48		pha				pha
.018001	da		phx				phx
.018002	5a		phy				phy
.018003	20 9c 81	jsr $01819c			jsr 	IF_Home 					; home cursor
.018006	a2 20		ldx #$20			ldx 	#IF_Height 					; this many lines.
.018008					_IFT_CS0:
.018008	a0 40		ldy #$40			ldy 	#IF_Width 					; this many chars/line
.01800a					_IFT_CS1:
.01800a	a9 20		lda #$20			lda 	#' '						; clear line.
.01800c	20 c8 81	jsr $0181c8			jsr 	IF_Write
.01800f	88		dey				dey
.018010	d0 f8		bne $01800a			bne 	_IFT_CS1
.018012	20 af 81	jsr $0181af			jsr 	IF_NewLine 					; next line down
.018015	ca		dex				dex
.018016	d0 f0		bne $018008			bne 	_IFT_CS0
.018018	7a		ply				ply
.018019	fa		plx				plx
.01801a	68		pla				pla
.01801b					IFT_HomeCursor:
.01801b	48		pha				pha
.01801c	20 9c 81	jsr $01819c			jsr 	IF_Home
.01801f	a9 00		lda #$00			lda 	#0
.018021	8d 00 05	sta $0500			sta 	IFT_XCursor
.018024	8d 01 05	sta $0501			sta 	IFT_YCursor
.018027	68		pla				pla
.018028	60		rts				rts
.018029					IFT_UpLine:
.018029	48		pha				pha
.01802a	ad 01 05	lda $0501			lda  	IFT_YCursor 				; get Y
.01802d	3a		dec a				dec 	a 							; line above
.01802e	30 03		bmi $018033			bmi 	_IFTULExit 					; too far, abort
.018030	20 be 80	jsr $0180be			jsr 	IFT_SetYPos					; set to that line.
.018033					_IFTULExit:
.018033	68		pla				pla
.018034	60		rts				rts
.018035					IFT_PrintCharacter:
.018035	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.018037	f0 16		beq $01804f			beq 	IFT_NewLine
.018039	48		pha				pha
.01803a	20 67 80	jsr $018067			jsr 	IFT_UpperCase 				; make upper case
.01803d	20 c8 81	jsr $0181c8			jsr 	IF_Write 					; write out.
.018040	ee 00 05	inc $0500			inc 	IFT_XCursor 				; bump x cursor
.018043	ad 00 05	lda $0500			lda 	IFT_XCursor 				; reached RHS ?
.018046	c9 40		cmp #$40			cmp 	#IF_Width
.018048	d0 03		bne $01804d			bne 	_IFT_PCNotEOL
.01804a	20 4f 80	jsr $01804f			jsr 	IFT_NewLine 				; if so do new line.
.01804d					_IFT_PCNotEOL:
.01804d	68		pla				pla
.01804e	60		rts				rts
.01804f					IFT_NewLine:
.01804f	48		pha				pha
.018050	20 af 81	jsr $0181af			jsr 	IF_NewLine 					; new line on actual screen.
.018053	a9 00		lda #$00			lda 	#0 							; reset x position
.018055	8d 00 05	sta $0500			sta 	IFT_XCursor
.018058	ee 01 05	inc $0501			inc 	IFT_YCursor 				; move down.
.01805b	ad 01 05	lda $0501			lda 	IFT_YCursor
.01805e	c9 20		cmp #$20			cmp 	#IF_Height 					; reached bottom.
.018060	d0 03		bne $018065			bne 	_IFT_NL_NotEOS
.018062	20 72 80	jsr $018072			jsr 	IFT_Scroll 					; scroll screen up.
.018065					_IFT_NL_NotEOS:
.018065	68		pla				pla
.018066	60		rts				rts
.018067					IFT_UpperCase:
.018067	c9 61		cmp #$61			cmp 	#"a"
.018069	90 06		bcc $018071			bcc 	_IFT_UCExit
.01806b	c9 7b		cmp #$7b			cmp 	#"z"+1
.01806d	b0 02		bcs $018071			bcs 	_IFT_UCExit
.01806f	49 20		eor #$20			eor 	#$20
.018071					_IFT_UCExit:
.018071	60		rts				rts
.018072					IFT_Scroll:
.018072	48		pha				pha 								; save AXY
.018073	da		phx				phx
.018074	5a		phy				phy
.018075	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.018077					_IFT_SLoop:
.018077	20 97 80	jsr $018097			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.01807a	e8		inx				inx
.01807b	e0 1f		cpx #$1f			cpx 	#IF_Height-1				; do whole screen
.01807d	d0 f8		bne $018077			bne 	_IFT_SLoop
.01807f	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.018081	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.018084	a2 40		ldx #$40			ldx 	#IF_Width 					; blank line
.018086					_IFT_SBlank:
.018086	a9 20		lda #$20			lda 	#32
.018088	20 c8 81	jsr $0181c8			jsr 	IF_Write
.01808b	ca		dex				dex
.01808c	d0 f8		bne $018086			bne 	_IFT_SBlank
.01808e	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.018090	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.018093	7a		ply				ply
.018094	fa		plx				plx
.018095	68		pla				pla
.018096	60		rts				rts
.018097					_IFT_ScrollLine:
.018097	da		phx				phx
.018098	da		phx				phx
.018099	8a		txa				txa 								; copy line into buffer.
.01809a	1a		inc a				inc 	a 							; next line down.
.01809b	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.01809e	a2 00		ldx #$00			ldx 	#0
.0180a0					_IFTScrollCopy1:
.0180a0	20 bf 81	jsr $0181bf			jsr 	IF_Read
.0180a3	9d 02 05	sta $0502,x			sta 	IFT_Buffer,x
.0180a6	e8		inx				inx
.0180a7	e0 40		cpx #$40			cpx 	#IF_Width
.0180a9	d0 f5		bne $0180a0			bne 	_IFTScrollCopy1
.0180ab	68		pla				pla
.0180ac	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.0180af	a2 00		ldx #$00			ldx 	#0
.0180b1					_IFTScrollCopy2:
.0180b1	bd 02 05	lda $0502,x			lda 	IFT_Buffer,x
.0180b4	20 c8 81	jsr $0181c8			jsr 	IF_Write
.0180b7	e8		inx				inx
.0180b8	e0 40		cpx #$40			cpx 	#IF_Width
.0180ba	d0 f5		bne $0180b1			bne 	_IFTScrollCopy2
.0180bc	fa		plx				plx
.0180bd	60		rts				rts
.0180be					IFT_SetYPos:
.0180be	48		pha				pha
.0180bf	da		phx				phx
.0180c0	aa		tax				tax
.0180c1	20 1b 80	jsr $01801b			jsr 	IFT_HomeCursor
.0180c4	e0 00		cpx #$00			cpx 	#0
.0180c6	f0 09		beq $0180d1			beq 	_IFT_MOAExit
.0180c8					_IFT_MOALoop:
.0180c8	20 af 81	jsr $0181af			jsr 	IF_NewLine
.0180cb	ee 01 05	inc $0501			inc 	IFT_YCursor
.0180ce	ca		dex				dex
.0180cf	d0 f7		bne $0180c8			bne		_IFT_MOALoop
.0180d1					_IFT_MOAExit:
.0180d1	fa		plx				plx
.0180d2	68		pla				pla
.0180d3	60		rts				rts
.0180d4					IFT_GetKeyCursor:
.0180d4	20 dc 80	jsr $0180dc			jsr 	_IFT_FlipCursor 			; reverse current
.0180d7					_IFT_GKCWait:
.0180d7	20 d9 81	jsr $0181d9			jsr 	IF_GetKey 					; get key
.0180da	f0 fb		beq $0180d7			beq 	_IFT_GKCWait
.0180dc					_IFT_FlipCursor:
.0180dc	48		pha				pha 								; save
.0180dd	20 bf 81	jsr $0181bf			jsr 	IF_Read 					; read
.0180e0	20 d1 81	jsr $0181d1			jsr 	IF_LeftOne
.0180e3	49 80		eor #$80			eor 	#$80 						; reverse
.0180e5	20 c8 81	jsr $0181c8			jsr 	IF_Write 					; write
.0180e8	20 d1 81	jsr $0181d1			jsr 	IF_LeftOne
.0180eb	68		pla				pla
.0180ec	60		rts				rts
.0180ed					IFT_ReadLine:
.0180ed	48		pha				pha
.0180ee					_IFT_RLLoop:
.0180ee	20 d4 80	jsr $0180d4			jsr 	IFT_GetKeyCursor 			; get keystroke
.0180f1	c9 0d		cmp #$0d			cmp 	#13							; return
.0180f3	f0 7d		beq $018172			beq 	_IFT_RLExit
.0180f5	c9 20		cmp #$20			cmp 	#32 						; control character
.0180f7	90 05		bcc $0180fe			bcc 	_IFT_Control
.0180f9	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0180fc	80 f0		bra $0180ee			bra 	_IFT_RLLoop
.0180fe					_IFT_Control:
.0180fe	c9 01		cmp #$01			cmp 	#"A"-64
.018100	f0 26		beq $018128			beq 	_IFT_Left
.018102	c9 04		cmp #$04			cmp 	#"D"-64
.018104	f0 2e		beq $018134			beq 	_IFT_Right
.018106	c9 17		cmp #$17			cmp 	#"W"-64
.018108	f0 36		beq $018140			beq 	_IFT_Up
.01810a	c9 13		cmp #$13			cmp 	#"S"-64
.01810c	f0 3e		beq $01814c			beq 	_IFT_Down
.01810e	c9 08		cmp #$08			cmp 	#"H"-64
.018110	f0 09		beq $01811b			beq 	_IFT_Backspace
.018112	c9 1a		cmp #$1a			cmp 	#"Z"-64
.018114	d0 d8		bne $0180ee			bne 	_IFT_RLLoop
.018116	20 00 80	jsr $018000			jsr 	IFT_ClearScreen				; clear CTL-Z
.018119	80 d3		bra $0180ee			bra 	_IFT_RLLoop
.01811b					_IFT_Backspace:
.01811b	ad 00 05	lda $0500			lda 	IFT_XCursor 				; check not start of line.
.01811e	f0 ce		beq $0180ee			beq 	_IFT_RLLoop
.018120	20 d1 81	jsr $0181d1			jsr 	IF_LeftOne
.018123	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.018125	20 c8 81	jsr $0181c8			jsr 	IF_Write
.018128					_IFT_Left:
.018128	ce 00 05	dec $0500			dec 	IFT_XCursor 				; left CTL-W
.01812b	10 29		bpl $018156			bpl 	_IFT_Reposition
.01812d	a9 3f		lda #$3f			lda 	#IF_Width-1
.01812f					_IFT_SetX:
.01812f	8d 00 05	sta $0500			sta 	IFT_XCursor
.018132	80 22		bra $018156			bra 	_IFT_Reposition
.018134					_IFT_Right:
.018134	ee 00 05	inc $0500			inc 	IFT_XCursor
.018137	ad 00 05	lda $0500			lda 	IFT_XCursor
.01813a	49 40		eor #$40			eor 	#IF_Width
.01813c	f0 f1		beq $01812f			beq 	_IFT_SetX
.01813e	80 16		bra $018156			bra 	_IFT_Reposition
.018140					_IFT_Up:
.018140	ce 01 05	dec $0501			dec 	IFT_YCursor
.018143	10 11		bpl $018156			bpl 	_IFT_Reposition
.018145	a9 1f		lda #$1f			lda 	#IF_Height-1
.018147					_IFT_SetY:
.018147	8d 01 05	sta $0501			sta 	IFT_YCursor
.01814a	80 0a		bra $018156			bra 	_IFT_Reposition
.01814c					_IFT_Down:
.01814c	ee 01 05	inc $0501			inc 	IFT_YCursor
.01814f	ad 01 05	lda $0501			lda 	IFT_YCursor
.018152	49 20		eor #$20			eor 	#IF_Height
.018154	f0 f1		beq $018147			beq 	_IFT_SetY
.018156					_IFT_Reposition:
.018156	ad 00 05	lda $0500			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.018159	48		pha				pha
.01815a	ad 01 05	lda $0501			lda 	IFT_YCursor
.01815d	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.018160	68		pla				pla
.018161	aa		tax				tax
.018162	e0 00		cpx #$00			cpx 	#0
.018164	f0 88		beq $0180ee			beq 	_IFT_RLLoop
.018166					_IFT_MoveRight:
.018166	20 bf 81	jsr $0181bf			jsr 	IF_Read
.018169	ee 00 05	inc $0500			inc 	IFT_XCursor
.01816c	ca		dex				dex
.01816d	d0 f7		bne $018166			bne 	_IFT_MoveRight
.01816f	4c ee 80	jmp $0180ee			jmp 	_IFT_RLLoop
.018172					_IFT_RLExit:
.018172	ad 01 05	lda $0501			lda 	IFT_YCursor 				; go to start of line.
.018175	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.018178	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.01817a					_IFT_RLRead:
.01817a	20 bf 81	jsr $0181bf			jsr 	IF_Read
.01817d	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.018180	e8		inx				inx
.018181	e0 40		cpx #$40			cpx 	#IF_Width
.018183	d0 f5		bne $01817a			bne 	_IFT_RLRead
.018185					_IFT_RL_Trim:
.018185	ca		dex				dex 	 							; previous char
.018186	30 07		bmi $01818f			bmi 	_IFT_Found 					; gone too far
.018188	bd 66 05	lda $0566,x			lda 	IFT_LineBuffer,x			; go back if space
.01818b	c9 20		cmp #$20			cmp 	#" "
.01818d	f0 f6		beq $018185			beq 	_IFT_RL_Trim
.01818f					_IFT_Found:
.01818f	e8		inx				inx 								; forward to non-space
.018190	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.018192	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.018195	68		pla				pla
.018196	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.018198	a0 05		ldy #$05			ldy 	#IFT_LineBuffer >> 8
.01819a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_em65816.asm

=64					IF_Width 	= 64 							; characters across
=32					IF_Height 	= 32 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line.
=8					IF_XPos 	= 8 							; current position, horizontal.
=$f0000					IF_Screen = $F0000							; 2k screen RAM here
=$f8010					IF_PKeyboard = $F8010						; Keyboard port.
=$f8000					IF_PBreak = $F8000 							; Break key.
.01819b					IF_Reset:
.01819b	60		rts				rts
.01819c					IF_Home:
.01819c	48		pha				pha
.01819d	64 08		stz $08				stz 	IF_XPos 					; zero X position
.01819f	a9 00		lda #$00			lda 	#IF_Screen & $FF 			; set r/w pos.
.0181a1	85 04		sta $04				sta 	IF_Pos
.0181a3	a9 00		lda #$00			lda 	#(IF_Screen >> 8) & $FF
.0181a5	85 05		sta $05				sta 	IF_Pos+1
.0181a7	a9 0f		lda #$0f			lda 	#IF_Screen >> 16
.0181a9	85 06		sta $06				sta 	IF_Pos+2
.0181ab	64 07		stz $07				stz 	IF_Pos+3
.0181ad	68		pla				pla
.0181ae	60		rts				rts
.0181af					IF_NewLine:
.0181af	48		pha				pha
.0181b0	64 08		stz $08				stz 	IF_XPos						; back to start of line
.0181b2	18		clc				clc 								; down one line
.0181b3	a5 04		lda $04				lda 	IF_Pos
.0181b5	69 40		adc #$40			adc 	#64
.0181b7	85 04		sta $04				sta 	IF_Pos
.0181b9	90 02		bcc $0181bd			bcc 	_IF_NoCarry 				; carry through.
.0181bb	e6 05		inc $05				inc 	IF_Pos+1
.0181bd					_IF_NoCarry:
.0181bd	68		pla				pla
.0181be	60		rts				rts
.0181bf					IF_Read:
.0181bf	5a		phy				phy 								; save current Y
.0181c0	a4 08		ldy $08				ldy 	IF_XPos 					; read character at current position
.0181c2	b7 04		lda [$04],y			lda 	[IF_Pos],y
.0181c4	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181c6	7a		ply				ply									; restore Y
.0181c7	60		rts				rts
.0181c8					IF_Write:
.0181c8	5a		phy				phy 								; save current Y
.0181c9	a4 08		ldy $08				ldy 	IF_XPos 					; write character at current position
.0181cb	97 04		sta [$04],y			sta 	[IF_Pos],y
.0181cd	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181cf	7a		ply				ply									; restore Y
.0181d0	60		rts				rts
.0181d1					IF_LeftOne:
.0181d1	c6 08		dec $08				dec 	IF_XPos
.0181d3	60		rts				rts
.0181d4					IF_CheckBreak:
.0181d4	af 00 80 0f	lda $0f8000			lda 	IF_PBreak					; non-zero if Ctrl+C pressed.
.0181d8	60		rts				rts
.0181d9					IF_GetKey:
.0181d9	af 10 80 0f	lda $0f8010			lda 	IF_PKeyboard				; read keyboard
.0181dd	f0 08		beq $0181e7			beq		_IFGK_NoKey 				; skip if zero,no key pressed
.0181df	48		pha				pha 								; key pressed, clear queue.
.0181e0	a9 00		lda #$00			lda 	#0
.0181e2	8f 10 80 0f	sta $0f8010			sta 	IF_PKeyboard
.0181e6	68		pla				pla
.0181e7					_IFGK_NoKey:
.0181e7	09 00		ora #$00			ora 	#0							; set Z flag appropriately.
.0181e9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.0181ea					TIM_Error:
.0181ea	20 29 80	jsr $018029			jsr 	IFT_UpLine 					; go up one line.
.0181ed	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.0181ef	80 02		bra $0181f3			bra 	TIM_ShowPrompt
.0181f1					TIM_NewCommand:
.0181f1	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.0181f3					TIM_ShowPrompt:
.0181f3	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.0181f6	20 ed 80	jsr $0180ed			jsr 	IFT_ReadLine	 			; get character, go to next line
.0181f9	20 4f 80	jsr $01804f			jsr 	IFT_NewLine					; go to next line.
.0181fc	86 10		stx $10				stx 	zTemp1 						; save line read address
.0181fe	84 11		sty $11				sty 	zTemp1+1
.018200	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.018202	b1 10		lda ($10),y			lda 	(zTemp1),y
.018204	c9 3f		cmp #$3f			cmp 	#"?"
.018206	f0 04		beq $01820c			beq 	TIM_SkipFirst
.018208	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.01820a	d0 01		bne $01820d			bne 	TIM_NotDot
.01820c					TIM_SkipFirst:
.01820c	c8		iny				iny
.01820d					TIM_NotDot:
.01820d	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.01820f	c9 52		cmp #$52			cmp 	#"R"						; show registers
.018211	f0 6b		beq $01827e			beq 	TIM_ShowRegisters
.018213	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.018215	f0 12		beq $018229			beq 	TIM_ShowMemory
.018217	c9 47		cmp #$47			cmp 	#"G"						; execute
.018219	f0 49		beq $018264			beq 	TIM_Execute
.01821b	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.01821d	f0 07		beq $018226			beq 	TIM_GoLoadMemory
.01821f	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.018221	d0 c7		bne $0181ea			bne 	TIM_Error
.018223	4c a2 83	jmp $0183a2			jmp 	TIM_UpdateRegisters
.018226					TIM_GoLoadMemory:
.018226	4c d2 83	jmp $0183d2			jmp 	TIM_LoadMemory
.018229					TIM_ShowMemory:
.018229	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.01822c	b0 bc		bcs $0181ea			bcs 	TIM_Error
.01822e	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.018230	85 12		sta $12				sta 	zTemp2
.018232	a5 15		lda $15				lda 	zTemp3+1
.018234	85 13		sta $13				sta 	zTemp2+1
.018236	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.018239	90 08		bcc $018243			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.01823b	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.01823d	85 14		sta $14				sta 	zTemp3
.01823f	a5 13		lda $13				lda 	zTemp2+1
.018241	85 15		sta $15				sta 	zTemp3+1
.018243					_TIMSM_Start:
.018243	20 f6 82	jsr $0182f6			jsr 	TIM_WriteLine 				; write one line of hex out
.018246	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.018248	18		clc				clc
.018249	69 10		adc #$10			adc 	#16
.01824b	85 12		sta $12				sta 	zTemp2
.01824d	90 02		bcc $018251			bcc 	_TIMSM_NoCarry
.01824f	e6 13		inc $13				inc 	zTemp2+1
.018251					_TIMSM_NoCarry:
.018251	20 d4 81	jsr $0181d4			jsr 	IF_CheckBreak 				; check CTL+C
.018254	d0 0b		bne $018261			bne 	_TIMSM_Ends 				; if pressed break out.
.018256	38		sec				sec 								; check past the end address in zTemp3
.018257	a5 14		lda $14				lda 	zTemp3
.018259	e5 12		sbc $12				sbc 	zTemp2
.01825b	a5 15		lda $15				lda 	zTemp3+1
.01825d	e5 13		sbc $13				sbc 	zTemp2+1
.01825f	10 e2		bpl $018243			bpl 	_TIMSM_Start
.018261					_TIMSM_Ends:
.018261	4c f1 81	jmp $0181f1			jmp 	TIM_NewCommand
.018264					TIM_Execute:
.018264	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; get the execute address
.018267	b0 81		bcs $0181ea			bcs 	TIM_Error 					; not legitimate
.018269	ae cb 03	ldx $03cb			ldx 	TIM_SP 						; set up SP
.01826c	9a		txs				txs
.01826d	ad c6 03	lda $03c6			lda 	TIM_SR 						; Status for PLP
.018270	48		pha				pha
.018271	ad c7 03	lda $03c7			lda 	TIM_A 						; restore AXYZ
.018274	ae c8 03	ldx $03c8			ldx 	TIM_X
.018277	ac c9 03	ldy $03c9			ldy 	TIM_Y
.01827a	28		plp				plp 								; and PS Byte.
.01827b	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.01827e					TIM_Start:
.01827e					TIM_ShowRegisters:
.01827e	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.018281	8d c5 03	sta $03c5			sta 	TIM_IRQ+1
.018284	ad ff ff	lda $ffff			lda 	$FFFF
.018287	8d c4 03	sta $03c4			sta 	TIM_IRQ
.01828a	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.01828c					_TIMSR_Text:
.01828c	bf bd 82 01	lda $0182bd,x			lda 	_TIMSR_Label,x
.018290	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018293	e8		inx				inx
.018294	e0 20		cpx #$20			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.018296	d0 f4		bne $01828c			bne 	_TIMSR_Text
.018298	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.01829a					_TIMSR_Skip:
.01829a	e8		inx				inx
.01829b					_TIMSR_LoopSpace:
.01829b	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.01829d	b0 04		bcs $0182a3			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.01829f	8a		txa				txa
.0182a0	4a		lsr a				lsr 	a
.0182a1	b0 05		bcs $0182a8			bcs 	_TIMSR_NoSpace
.0182a3					_TIMSR_Space:
.0182a3	a9 20		lda #$20			lda 	#" "
.0182a5	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182a8					_TIMSR_NoSpace:
.0182a8	bd c2 03	lda $03c2,x			lda 	TIM_PC,x 					; output hex value.
.0182ab	20 dd 82	jsr $0182dd			jsr 	TIM_WriteHex
.0182ae	e8		inx				inx
.0182af	e0 08		cpx #$08			cpx 	#TIM_Z-TIM_PC
.0182b1	f0 e7		beq $01829a			beq 	_TIMSR_Skip
.0182b3	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.0182b5	d0 e4		bne $01829b			bne 	_TimSR_LoopSpace
.0182b7	20 4f 80	jsr $01804f			jsr 	IFT_NewLine 				; new line
.0182ba	4c f1 81	jmp $0181f1			jmp	 	TIM_NewCommand 				; new command.
.0182bd					_TIMSR_Label:
>0182bd	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>0182c5	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>0182d5	52
>0182d6	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.0182dd					_TIMSR_LabelEnd:
.0182dd					TIM_WriteHex:
.0182dd	48		pha				pha 								; save A
.0182de	4a		lsr a				lsr 	a 							; shift MSB->LSB
.0182df	4a		lsr a				lsr 	a
.0182e0	4a		lsr a				lsr 	a
.0182e1	4a		lsr a				lsr 	a
.0182e2	20 e6 82	jsr $0182e6			jsr 	_TIMWH_Nibble 				; print MSB
.0182e5	68		pla				pla 								; restore and print LSB
.0182e6					_TIMWH_Nibble:
.0182e6	48		pha				pha
.0182e7	29 0f		and #$0f			and 	#15 						; mask out
.0182e9	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.0182eb	90 02		bcc $0182ef			bcc 	_TIMWHNoLetter
.0182ed	69 06		adc #$06			adc 	#6
.0182ef					_TIMWHNoLetter:
.0182ef	69 30		adc #$30			adc 	#48
.0182f1	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter 			; print it out.
.0182f4	68		pla				pla
.0182f5	60		rts				rts
.0182f6					TIM_WriteLine:
.0182f6	a9 2e		lda #$2e			lda 	#"." 						; prompt
.0182f8	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182fb	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.0182fd	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018300	a5 13		lda $13				lda 	zTemp2+1 					; write address
.018302	20 dd 82	jsr $0182dd			jsr 	TIM_WriteHex
.018305	a5 12		lda $12				lda 	zTemp2
.018307	20 dd 82	jsr $0182dd			jsr 	TIM_WriteHex
.01830a	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.01830c					_TIMWL_Loop:
.01830c	a9 20		lda #$20			lda 	#" "
.01830e	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018311	b1 12		lda ($12),y			lda 	(zTemp2),y
.018313	20 dd 82	jsr $0182dd			jsr 	TIM_WriteHex
.018316	c8		iny				iny
.018317	c0 10		cpy #$10			cpy 	#16
.018319	d0 f1		bne $01830c			bne 	_TIMWL_Loop
.01831b	4c 4f 80	jmp $01804f			jmp 	IFT_NewLine 				; new line and exit
.01831e					TIM_GetHex:
.01831e	c8		iny				iny
.01831f	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.018321	c9 20		cmp #$20			cmp 	#32
.018323	f0 f9		beq $01831e			beq 	TIM_GetHex
.018325	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.018327	f0 f5		beq $01831e			beq 	TIM_GetHex
.018329	20 52 83	jsr $018352			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.01832c	b0 23		bcs $018351			bcs 	_TIMGH_Exit					; if first bad then exit now.
.01832e	a9 00		lda #$00			lda 	#0 							; zero result
.018330	85 14		sta $14				sta 	zTemp3
.018332	85 15		sta $15				sta 	zTemp3+1
.018334					_TIM_GHLoop:
.018334	20 52 83	jsr $018352			jsr 	TIM_GetHexCharacter 		; get next character
.018337	b0 17		bcs $018350			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.018339	c8		iny				iny 								; skip over it.
.01833a	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.01833c	26 15		rol $15				rol 	zTemp3+1
.01833e	06 14		asl $14				asl 	zTemp3 						; now x 2
.018340	26 15		rol $15				rol 	zTemp3+1
.018342	06 14		asl $14				asl 	zTemp3						; now x 4
.018344	26 15		rol $15				rol 	zTemp3+1
.018346	06 14		asl $14				asl 	zTemp3 						; now x 8
.018348	26 15		rol $15				rol 	zTemp3+1
.01834a	05 14		ora $14				ora 	zTemp3 						; OR result in
.01834c	85 14		sta $14				sta 	zTemp3
.01834e	80 e4		bra $018334			bra 	_TIM_GHLoop 				; loop round again.
.018350					_TIMGH_Okay:
.018350	18		clc				clc
.018351					_TIMGH_Exit:
.018351	60		rts				rts
.018352					TIM_GetHexCharacter:
.018352	b1 10		lda ($10),y			lda 	(zTemp1),y
.018354	38		sec				sec
.018355	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.018357	90 0e		bcc $018367			bcc 	_TIM_GHCFail
.018359	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.01835b	90 0b		bcc $018368			bcc 	_TIM_GHCExit
.01835d	c9 11		cmp #$11			cmp 	#65-48						; < A
.01835f	90 06		bcc $018367			bcc		_TIM_GHCFail
.018361	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.018363	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.018365	90 01		bcc $018368			bcc		_TIM_GHCExit
.018367					_TIM_GHCFail:
.018367	38		sec				sec
.018368					_TIM_GHCExit:
.018368	60		rts				rts
.018369					TIM_BreakVector:
.018369	da		phx				phx									; save X/A on stack
.01836a	48		pha				pha
.01836b	ba		tsx				tsx 								; X points to S
.01836c	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.01836f	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.018371	d0 03		bne $018376			bne 	_TIMBreak					; if set, it's BRK
.018373	68		pla				pla 								; abandon routine.
.018374	fa		plx				plx
.018375	40		rti				rti
.018376					_TIMBreak:
.018376	68		pla				pla 								; save A X Y and maybe Z
.018377	8d c7 03	sta $03c7			sta 	TIM_A
.01837a	fa		plx				plx
.01837b	8e c8 03	stx $03c8			stx 	TIM_X
.01837e	8c c9 03	sty $03c9			sty 	TIM_Y
.018381	68		pla				pla 								; get Status Register
.018382	8d c6 03	sta $03c6			sta 	TIM_SR
.018385	68		pla				pla
.018386	8d c3 03	sta $03c3			sta 	TIM_PC+1 					; save calling address
.018389	68		pla				pla
.01838a	8d c2 03	sta $03c2			sta 	TIM_PC 						; high byte
.01838d	ad c3 03	lda $03c3			lda 	TIM_PC+1 					; dec PC to point right.
.018390	d0 03		bne $018395			bne 	_TIMDecrement 				; brk bumps it.
.018392	ce c2 03	dec $03c2			dec 	TIM_PC
.018395					_TIMDecrement:
.018395	ce c3 03	dec $03c3			dec 	TIM_PC+1
.018398	ba		tsx				tsx 								; and copy SP
.018399	8e cb 03	stx $03cb			stx 	TIM_SP
.01839c	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.01839e	9a		txs				txs
.01839f	4c 7e 82	jmp $01827e			jmp 	TIM_Start 					; and start up TIM monitor.
.0183a2					TIM_UpdateRegisters:
.0183a2	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; PC
.0183a5	b0 28		bcs $0183cf			bcs 	_TIMURFail
.0183a7	a5 14		lda $14				lda 	zTemp3
.0183a9	8d c3 03	sta $03c3			sta 	Tim_PC+1
.0183ac	a5 15		lda $15				lda 	zTemp3+1
.0183ae	8d c2 03	sta $03c2			sta 	Tim_PC
.0183b1	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; ignore IRQ
.0183b4	b0 19		bcs $0183cf			bcs 	_TIMURFail
.0183b6	a2 00		ldx #$00			ldx 	#0
.0183b8					_TIM_URLoop:
.0183b8	e0 04		cpx #$04			cpx 	#Tim_Z-Tim_SR
.0183ba	d0 01		bne $0183bd			bne 	_TIM_1
.0183bc	e8		inx				inx
.0183bd					_TIM_1:
.0183bd	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; registers
.0183c0	b0 0d		bcs $0183cf			bcs 	_TIMURFail
.0183c2	a5 14		lda $14				lda 	zTemp3
.0183c4	9d c6 03	sta $03c6,x			sta 	Tim_SR,x
.0183c7	e8		inx				inx
.0183c8	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.0183ca	d0 ec		bne $0183b8			bne 	_TIM_URLoop
.0183cc	4c f1 81	jmp $0181f1			jmp 	TIM_NewCommand
.0183cf					_TIMURFail:
.0183cf	4c ea 81	jmp $0181ea			jmp 	TIM_Error
.0183d2					TIM_LoadMemory:
.0183d2	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; target address => zTemp2
.0183d5	a5 14		lda $14				lda 	zTemp3
.0183d7	85 12		sta $12				sta 	zTemp2
.0183d9	a5 15		lda $15				lda 	zTemp3+1
.0183db	85 13		sta $13				sta 	zTemp2+1
.0183dd					_TIM_LMLoop:
.0183dd	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; next byte ?
.0183e0	b0 0e		bcs $0183f0			bcs 	_TIMLMDone 					; no more
.0183e2	a2 00		ldx #$00			ldx 	#0							; write out.
.0183e4	a5 14		lda $14				lda 	zTemp3
.0183e6	81 12		sta ($12,x)			sta 	(zTemp2,x)
.0183e8	e6 12		inc $12				inc 	zTemp2 						; bump address
.0183ea	d0 f1		bne $0183dd			bne 	_TIM_LMLoop
.0183ec	e6 13		inc $13				inc 	zTemp2+1
.0183ee	80 ed		bra $0183dd			bra 	_TIM_LMLoop
.0183f0					_TIMLMDone:
.0183f0	4c f1 81	jmp $0181f1			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/skip.asm

.0183f3					StructureSearchSingle:
.0183f3	a2 00		ldx #$00			ldx 	#0
.0183f5					StructureSearchDouble:
.0183f5	85 10		sta $10				sta 	zTemp1 						; save the target on zTemp1,zTemp1+1
.0183f7	86 11		stx $11				stx 	zTemp1+1
.0183f9	a9 00		lda #$00			lda 	#0 							; set the structure depth to zero (zTemp2)
.0183fb	85 12		sta $12				sta 	zTemp2
.0183fd	80 18		bra $018417			bra 	_SSWLoop 					; jump in, start scanning from here.
.0183ff					_SSWNextLine:
.0183ff	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018401	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.018403	18		clc				clc
.018404	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018406	85 16		sta $16				sta 	zCodePtr
.018408	90 02		bcc $01840c			bcc 	_SNLNoCarry
.01840a	e6 17		inc $17				inc 	zCodePtr+1
.01840c					_SNLNoCarry:
.01840c	a0 00		ldy #$00			ldy 	#0
.01840e	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018410	c9 00		cmp #$00			cmp 	#0					 		; if zero, fail.
.018412	f0 54		beq $018468			beq 	_SSWFail
.018414	c8		iny				iny
.018415	c8		iny				iny
.018416					_SSWNextSimple:
.018416	c8		iny				iny
.018417					_SSWLoop:
.018417	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018419	c9 00		cmp #$00			cmp 	#0 							; end of line ?
.01841b	f0 e2		beq $0183ff			beq 	_SSWNextLine 				; if so, then next line
.01841d	10 f7		bpl $018416			bpl 	_SSWNextSimple 				; needs to be a token, just skip char/number.
.01841f	a6 12		ldx $12				ldx 	zTemp2 						; check structure count
.018421	d0 08		bne $01842b			bne 	_SSWCheckUpDown 			; if it's non zero, then a match doesn't work.
.018423	c5 10		cmp $10				cmp 	zTemp1 						; found the right keyword, either choice.
.018425	f0 2d		beq $018454			beq 	_SSWFound 					; so exit.
.018427	c5 11		cmp $11				cmp 	zTemp1+1
.018429	f0 29		beq $018454			beq 	_SSWFound
.01842b					_SSWCheckUpDown:
.01842b	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus 			; if < keyword +
.01842d	90 10		bcc $01843f			bcc 	_SSWNext
.01842f	c9 93		cmp #$93			cmp 	#firstKeywordMinus 			; if < keyword - then as keyword +
.018431	90 08		bcc $01843b			bcc 	_SSWPlus
.018433	c9 98		cmp #$98			cmp 	#firstUnaryFunction			; if < first unary down as keyword -
.018435	b0 08		bcs $01843f			bcs 	_SSWNext
.018437	c6 12		dec $12				dec 	zTemp2 						; reduce structure count.
.018439	c6 12		dec $12				dec 	zTemp2
.01843b					_SSWPlus:
.01843b	e6 12		inc $12				inc 	zTemp2
.01843d	30 16		bmi $018455			bmi 	_SSWUnder					; error if driven -ve
.01843f					_SSWNext:
.01843f	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018441	c8		iny				iny 								; skip
.018442	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018444	90 0c		bcc $018452			bcc 	_SEDone 					; so just skip over it.
.018446	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018448	90 07		bcc $018451			bcc 	_SEDouble
.01844a	98		tya				tya 								; this is Y + 1
.01844b	18		clc				clc
.01844c	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.01844e	a8		tay				tay 								; back in Y.
.01844f	88		dey				dey 								; fix up, one for the +1, one for the iny
.018450	88		dey				dey
.018451					_SEDouble:
.018451	c8		iny				iny
.018452					_SEDone:
.018452	80 c3		bra $018417			bra 	_SSWLoop
.018454					_SSWFound:
.018454	60		rts				rts
.018455					_SSWUnder:
.018455	20 6e 85	jsr $01856e			jsr ERR_Handler
>018458	53 74 72 75 63 74 75 72			.text "Structure order",0
>018460	65 20 6f 72 64 65 72 00
.018468					_SSWFail:
.018468	20 6e 85	jsr $01856e			jsr ERR_Handler
>01846b	43 61 6e 27 74 20 66 69			.text "Can't find structure",0
>018473	6e 64 20 73 74 72 75 63 74 75 72 65 00
.018480					SkipEndOfCommand:
.018480	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018482	c9 00		cmp #$00			cmp 	#0 							; if zero, end of line, so exit
.018484	f0 19		beq $01849f			beq 	_SOCExit
.018486	c9 c0		cmp #$c0			cmp 	#token_Colon 				; if colon, end of command
.018488	f0 15		beq $01849f			beq 	_SOCExit
.01848a	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.01848c	c8		iny				iny 								; skip
.01848d	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.01848f	90 0c		bcc $01849d			bcc 	_SEDone 					; so just skip over it.
.018491	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018493	90 07		bcc $01849c			bcc 	_SEDouble
.018495	98		tya				tya 								; this is Y + 1
.018496	18		clc				clc
.018497	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018499	a8		tay				tay 								; back in Y.
.01849a	88		dey				dey 								; fix up, one for the +1, one for the iny
.01849b	88		dey				dey
.01849c					_SEDouble:
.01849c	c8		iny				iny
.01849d					_SEDone:
.01849d	80 e1		bra $018480			bra 	SkipEndOfCommand
.01849f					_SOCExit:
.01849f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stack.asm

.0184a0					StackReset:
.0184a0	48		pha				pha
.0184a1	5a		phy				phy
.0184a2	a9 00		lda #$00			lda 	#(BasicStack & $FF) 		; reset pointer
.0184a4	85 26		sta $26				sta 	zBasicSP
.0184a6	a9 04		lda #$04			lda 	#(BasicStack >> 8)
.0184a8	85 27		sta $27				sta 	zBasicSP+1
.0184aa	a0 00		ldy #$00			ldy 	#0 							; reset stack top to $00 which cannot
.0184ac	98		tya				tya 								; be a legal token.
.0184ad	91 26		sta ($26),y			sta 	(zBasicSP),y
.0184af	7a		ply				ply
.0184b0	68		pla				pla
.0184b1	60		rts				rts
.0184b2					StackPushFrame:
.0184b2	48		pha				pha
.0184b3	5a		phy				phy
.0184b4	1a		inc a				inc 	a 							; one extra byte in frame, for the marker.
.0184b5	48		pha				pha 								; save it.
.0184b6	29 0f		and #$0f			and 	#$0F 						; lower 4 bits
.0184b8	18		clc				clc 								; add to Basic Stack
.0184b9	65 26		adc $26				adc 	zBasicSP
.0184bb	85 26		sta $26				sta 	zBasicSP
.0184bd	90 02		bcc $0184c1			bcc 	_SPFNoBump
.0184bf	e6 27		inc $27				inc 	zBasicSP+1
.0184c1					_SPFNoBump:
.0184c1	a0 00		ldy #$00			ldy 	#0
.0184c3	68		pla				pla
.0184c4	91 26		sta ($26),y			sta 	(zBasicSP),y
.0184c6	7a		ply				ply
.0184c7	68		pla				pla
.0184c8	60		rts				rts
.0184c9					StackPopFrame:
.0184c9	48		pha				pha
.0184ca	5a		phy				phy
.0184cb	a0 00		ldy #$00			ldy 	#0 							; compare with top of stack using EOR
.0184cd	51 26		eor ($26),y			eor 	(zBasicSP),y
.0184cf	29 f0		and #$f0			and 	#$F0 						; top 4 bits zero, match
.0184d1	d0 12		bne $0184e5			bne 	SPFError 					; mixed structures
.0184d3	b1 26		lda ($26),y			lda 	(zBasicSP),y 				; get size from byte
.0184d5	29 0f		and #$0f			and 	#$0F
.0184d7	49 ff		eor #$ff			eor 	#$FF						; 2's complement
.0184d9	38		sec				sec
.0184da	65 26		adc $26				adc 	zBasicSP
.0184dc	85 26		sta $26				sta 	zBasicSP
.0184de	b0 02		bcs $0184e2			bcs 	_SPFNoBump
.0184e0	c6 27		dec $27				dec 	zBasicSP+1
.0184e2					_SPFNoBump:
.0184e2	7a		ply				ply
.0184e3	68		pla				pla
.0184e4	60		rts				rts
.0184e5					SPFError:
.0184e5	20 6e 85	jsr $01856e			jsr ERR_Handler
>0184e8	4d 69 78 65 64 20 53 74			.text "Mixed Structures",0
>0184f0	72 75 63 74 75 72 65 73 00
.0184f9					StackSavePosition:
.0184f9	98		tya				tya
.0184fa	5a		phy				phy
.0184fb	a0 05		ldy #$05			ldy 	#5
.0184fd	91 26		sta ($26),y			sta 	(zBasicSP),y
.0184ff	a0 01		ldy #$01			ldy 	#1
.018501	a5 16		lda $16				lda 	zCodePtr+0 					; 4 bytes, could reduce this for 65816/6502
.018503	91 26		sta ($26),y			sta 	(zBasicSP),y
.018505	c8		iny				iny
.018506	a5 17		lda $17				lda 	zCodePtr+1
.018508	91 26		sta ($26),y			sta 	(zBasicSP),y
.01850a	c8		iny				iny
.01850b	a5 18		lda $18				lda 	zCodePtr+2
.01850d	91 26		sta ($26),y			sta 	(zBasicSP),y
.01850f	c8		iny				iny
.018510	a5 19		lda $19				lda 	zCodePtr+3
.018512	91 26		sta ($26),y			sta 	(zBasicSP),y
.018514	7a		ply				ply
.018515	60		rts				rts
.018516					StackRestorePosition:
.018516	5a		phy				phy
.018517	a0 01		ldy #$01			ldy 	#1 							; copy 4 bytes that are the pointer
.018519	b1 26		lda ($26),y			lda 	(zBasicSP),y
.01851b	85 16		sta $16				sta 	zCodePtr+0
.01851d	c8		iny				iny
.01851e	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018520	85 17		sta $17				sta 	zCodePtr+1
.018522	c8		iny				iny
.018523	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018525	85 18		sta $18				sta 	zCodePtr+2
.018527	c8		iny				iny
.018528	b1 26		lda ($26),y			lda 	(zBasicSP),y
.01852a	85 19		sta $19				sta 	zCodePtr+3
.01852c	c8		iny				iny
.01852d	b1 26		lda ($26),y			lda 	(zBasicSP),y 				; offset
.01852f	7a		ply				ply 								; restore Y
.018530	a8		tay				tay
.018531	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/vectors.asm

.018532					CharPrint:
.018532	4c 35 80	jmp $018035			jmp 	IFT_PrintCharacter
.018535					CharGet:
.018535	4c d9 81	jmp $0181d9			jmp 	IF_GetKey
.018538					CheckBreak:
.018538	4c d4 81	jmp $0181d4			jmp 	IF_CheckBreak
.01853b					CharGetPosition:
.01853b	ad 00 05	lda $0500			lda 	IFT_XCursor
.01853e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/errors.asm

.01853f					SyntaxError:
.01853f	20 6e 85	jsr $01856e			jsr 	ERR_Handler
>018542	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>01854a	72 72 6f 72 00
.01854f					TypeError:
.01854f	20 6e 85	jsr $01856e			jsr 	ERR_Handler
>018552	57 72 6f 6e 67 20 74 79				.text 	"Wrong type",0
>01855a	70 65 00
.01855d					BadParamError:
.01855d	20 6e 85	jsr $01856e			jsr 	ERR_Handler
>018560	42 61 64 20 50 61 72 61				.text 	"Bad Parameter",0
>018568	6d 65 74 65 72 00
.01856e					ERR_Handler:
.01856e	a0 00		ldy #$00			ldy 	#0
.018570	c8		iny				iny
.018571	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018573	85 80		sta $80				sta 	XS_Mantissa
.018575	c8		iny				iny
.018576	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018578	85 81		sta $81				sta 	XS_Mantissa+1
.01857a	fa		plx				plx 								; address in XY
.01857b	7a		ply				ply
.01857c	e8		inx				inx 								; bump, because of RTS/JSR address -1
.01857d	d0 01		bne $018580			bne 	_EHNoSkip
.01857f	c8		iny				iny
.018580					_EHNoSkip:
.018580	20 9f 85	jsr $01859f			jsr 	PrintROMMessage 			; print message from ROM.
.018583	a5 80		lda $80				lda 	XS_Mantissa					; line number = 0
.018585	05 81		ora $81				ora 	XS_Mantissa+1
.018587	f0 0c		beq $018595			beq 	_EHNoLine
.018589	a2 9a		ldx #$9a			ldx 	#_EHAt & $FF 				; print " at "
.01858b	a0 85		ldy #$85			ldy 	#(_EHAt >> 8) & $FF
.01858d	20 9f 85	jsr $01859f			jsr 	PrintROMMessage
.018590	a2 00		ldx #$00			ldx 	#0 							; Print line number
.018592	20 b4 85	jsr $0185b4			jsr 	Print16BitInteger
.018595					_EHNoLine:
.018595	80 fe		bra $018595			bra 	_EHNoLine
.018597	4c 27 88	jmp $018827			jmp 	WarmStart
>01859a	20 61 74 20 00			_EHAt:	.text 	" at ",0
.01859f					PrintROMMessage:
.01859f	86 1a		stx $1a				stx 	zLTemp1 					; save addres
.0185a1	84 1b		sty $1b				sty 	zLTemp1+1
.0185a3	4b		phk				phk
.0185a4	68		pla				pla
.0185a5	85 1c		sta $1c				sta 	ZLTemp1+2
.0185a7	a0 00		ldy #$00			ldy 	#0
.0185a9					_PRMLoop:
.0185a9	b7 1a		lda [$1a],y			lda 	[zLTemp1],y
.0185ab	f0 06		beq $0185b3			beq		_PRMExit
.0185ad	c8		iny				iny
.0185ae	20 32 85	jsr $018532			jsr 	CharPrint
.0185b1	80 f6		bra $0185a9			bra 	_PRMLoop
.0185b3					_PRMExit:
.0185b3	60		rts				rts
.0185b4					Print16BitInteger:
.0185b4	a9 00		lda #$00			lda 	#0 							; make 32 bit
.0185b6	85 82		sta $82				sta 	XS_Mantissa+2
.0185b8	85 83		sta $83				sta 	XS_Mantissa+3
.0185ba					Print32BitInteger:
.0185ba	a9 00		lda #$00			lda 	#0
.0185bc	8d 14 03	sta $0314			sta 	NumBufX 					; reset the conversion pointer
.0185bf	aa		tax				tax 								; convert bottom level.
.0185c0	20 59 9d	jsr $019d59			jsr 	INTToString 				; make string
.0185c3	a2 00		ldx #$00			ldx 	#0 							; print buffer
.0185c5	bd 15 03	lda $0315,x	_P1Loop:lda 	Num_Buffer,x
.0185c8	f0 06		beq $0185d0			beq 	_P1Exit
.0185ca	20 32 85	jsr $018532			jsr 	CharPrint
.0185cd	e8		inx				inx
.0185ce	80 f5		bra $0185c5			bra 	_P1Loop
.0185d0	8a		txa		_P1Exit:txa 								; return chars printed.
.0185d1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm


;******  Processing file: modules/basic/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b6					lastUnaryFunction = $b6
.0185d2					VectorTable:
>0185d2	b1 91					.word BinaryOp_And         & $FFFF ; $80 and
>0185d4	cd 91					.word BinaryOp_Or          & $FFFF ; $81 or
>0185d6	e9 91					.word BinaryOp_Xor         & $FFFF ; $82 xor
>0185d8	e9 91					.word BinaryOp_Eor         & $FFFF ; $83 eor
>0185da	20 92					.word Binary_Equal         & $FFFF ; $84 =
>0185dc	3a 92					.word Binary_NotEqual      & $FFFF ; $85 <>
>0185de	43 92					.word Binary_Less          & $FFFF ; $86 <
>0185e0	4c 92					.word Binary_LessEqual     & $FFFF ; $87 <=
>0185e2	5e 92					.word Binary_Greater       & $FFFF ; $88 >
>0185e4	55 92					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>0185e6	e3 92					.word BinaryOp_Add         & $FFFF ; $8a +
>0185e8	ff 92					.word BinaryOp_Subtract    & $FFFF ; $8b -
>0185ea	10 93					.word BinaryOp_Multiply    & $FFFF ; $8c *
>0185ec	21 93					.word BinaryOp_Divide      & $FFFF ; $8d /
>0185ee	90 86					.word NotImplemented       & $FFFF ; $8e ^
>0185f0	5b 8b					.word Command_IF           & $FFFF ; $8f if
>0185f2	ad 8f					.word Command_WHILE        & $FFFF ; $90 while
>0185f4	d5 8f					.word Command_REPEAT       & $FFFF ; $91 repeat
>0185f6	89 89					.word Command_FOR          & $FFFF ; $92 for
>0185f8	90 86					.word NotImplemented       & $FFFF ; $93 then
>0185fa	b8 8b					.word Command_ENDIF        & $FFFF ; $94 endif
>0185fc	ca 8f					.word Command_WEND         & $FFFF ; $95 wend
>0185fe	de 8f					.word Command_UNTIL        & $FFFF ; $96 until
>018600	06 8a					.word Command_NEXT         & $FFFF ; $97 next
>018602	90 86					.word NotImplemented       & $FFFF ; $98 not
>018604	90 86					.word NotImplemented       & $FFFF ; $99 fn(
>018606	26 94					.word Unary_Abs            & $FFFF ; $9a abs(
>018608	73 95					.word Unary_Asc            & $FFFF ; $9b asc(
>01860a	85 a4					.word Unary_Int            & $FFFF ; $9c int(
>01860c	40 94					.word Unary_Peek           & $FFFF ; $9d peek(
>01860e	06 a4					.word Unary_Rnd            & $FFFF ; $9e rnd(
>018610	b3 94					.word Unary_Usr            & $FFFF ; $9f usr(
>018612	b2 95					.word Unary_Left           & $FFFF ; $a0 left$(
>018614	c7 95					.word Unary_Right          & $FFFF ; $a1 right$(
>018616	99 95					.word Unary_Mid            & $FFFF ; $a2 mid$(
>018618	10 97					.word Unary_Spc            & $FFFF ; $a3 spc(
>01861a	41 95					.word Unary_Str            & $FFFF ; $a4 str$(
>01861c	d5 94					.word Unary_Val            & $FFFF ; $a5 val(
>01861e	8a 95					.word Unary_Len            & $FFFF ; $a6 len(
>018620	3f 96					.word Unary_Hex            & $FFFF ; $a7 hex$(
>018622	90 86					.word NotImplemented       & $FFFF ; $a8 sin(
>018624	90 86					.word NotImplemented       & $FFFF ; $a9 cos(
>018626	90 86					.word NotImplemented       & $FFFF ; $aa tan(
>018628	90 86					.word NotImplemented       & $FFFF ; $ab atn(
>01862a	90 86					.word NotImplemented       & $FFFF ; $ac exp(
>01862c	90 86					.word NotImplemented       & $FFFF ; $ad log(
>01862e	90 86					.word NotImplemented       & $FFFF ; $ae sqr(
>018630	95 96					.word Unary_Dec            & $FFFF ; $af dec(
>018632	44 94					.word Unary_Deek           & $FFFF ; $b0 deek(
>018634	48 94					.word Unary_Leek           & $FFFF ; $b1 leek(
>018636	80 94					.word Unary_Mod            & $FFFF ; $b2 mod(
>018638	e0 93					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>01863a	f2 96					.word Unary_Chr            & $FFFF ; $b4 chr$(
>01863c	74 94					.word Unary_Pos            & $FFFF ; $b5 pos(
>01863e	33 97					.word Unary_Tab            & $FFFF ; $b6 tab(
>018640	90 86					.word NotImplemented       & $FFFF ; $b7 $
>018642	90 86					.word NotImplemented       & $FFFF ; $b8 $(
>018644	90 86					.word NotImplemented       & $FFFF ; $b9 #
>018646	90 86					.word NotImplemented       & $FFFF ; $ba #(
>018648	90 86					.word NotImplemented       & $FFFF ; $bb %
>01864a	90 86					.word NotImplemented       & $FFFF ; $bc %(
>01864c	90 86					.word NotImplemented       & $FFFF ; $bd (
>01864e	90 86					.word NotImplemented       & $FFFF ; $be )
>018650	90 86					.word NotImplemented       & $FFFF ; $bf ,
>018652	88 89					.word Command_COLON        & $FFFF ; $c0 :
>018654	90 86					.word NotImplemented       & $FFFF ; $c1 ;
>018656	90 86					.word NotImplemented       & $FFFF ; $c2 def
>018658	8e 8f					.word Command_CLR          & $FFFF ; $c3 clr
>01865a	a5 8f					.word Command_STOP         & $FFFF ; $c4 stop
>01865c	df 8a					.word Command_DATA         & $FFFF ; $c5 data
>01865e	b9 8a					.word Command_READ         & $FFFF ; $c6 read
>018660	34 88					.word Command_DIM          & $FFFF ; $c7 dim
>018662	90 86					.word NotImplemented       & $FFFF ; $c8 to
>018664	90 86					.word NotImplemented       & $FFFF ; $c9 step
>018666	d4 8e					.word Command_GOSUB        & $FFFF ; $ca gosub
>018668	e4 8e					.word Command_RETURN       & $FFFF ; $cb return
>01866a	cc 8e					.word Command_GOTO         & $FFFF ; $cc goto
>01866c	57 8b					.word Command_END          & $FFFF ; $cd end
>01866e	90 86					.word NotImplemented       & $FFFF ; $ce input
>018670	1c 8b					.word Command_LET          & $FFFF ; $cf let
>018672	be 8b					.word Command_LIST         & $FFFF ; $d0 list
>018674	75 8e					.word Command_NEW          & $FFFF ; $d1 new
>018676	91 8e					.word Command_OLD          & $FFFF ; $d2 old
>018678	ed 8e					.word Command_ON           & $FFFF ; $d3 on
>01867a	e2 8a					.word Command_RESTORE      & $FFFF ; $d4 restore
>01867c	44 8e					.word Command_POKE         & $FFFF ; $d5 poke
>01867e	b2 8d					.word Command_PRINT        & $FFFF ; $d6 print
>018680	fa 88					.word Command_RUN          & $FFFF ; $d7 run
>018682	bc 88					.word Command_WAIT         & $FFFF ; $d8 wait
>018684	3d 8b					.word Command_SYS          & $FFFF ; $d9 sys
>018686	48 8e					.word Command_DOKE         & $FFFF ; $da doke
>018688	4c 8e					.word Command_LOKE         & $FFFF ; $db loke
>01868a	2c 8e					.word Command_ASSERT       & $FFFF ; $dc assert
>01868c	90 86					.word NotImplemented       & $FFFF ; $dd get
>01868e	b2 8b					.word Command_ELSE         & $FFFF ; $de else
.018690					NotImplemented:
.018690	20 6e 85	jsr $01856e			jsr ERR_Handler
>018693	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>01869b	65 6d 65 6e 74 65 64 00
.0186a3					BinaryPrecedence:
>0186a3	01					.byte 1    ; $80 and
>0186a4	01					.byte 1    ; $81 or
>0186a5	01					.byte 1    ; $82 xor
>0186a6	01					.byte 1    ; $83 eor
>0186a7	02					.byte 2    ; $84 =
>0186a8	02					.byte 2    ; $85 <>
>0186a9	02					.byte 2    ; $86 <
>0186aa	02					.byte 2    ; $87 <=
>0186ab	02					.byte 2    ; $88 >
>0186ac	02					.byte 2    ; $89 >=
>0186ad	03					.byte 3    ; $8a +
>0186ae	03					.byte 3    ; $8b -
>0186af	04					.byte 4    ; $8c *
>0186b0	04					.byte 4    ; $8d /
>0186b1	05					.byte 5    ; $8e ^
.0186b2					KeywordText:
>0186b2	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>0186b5	4f d2					.byte $4f,$d2                          ; $81 or
>0186b7	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>0186ba	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>0186bd	bd					.byte $bd                              ; $84 =
>0186be	3c be					.byte $3c,$be                          ; $85 <>
>0186c0	bc					.byte $bc                              ; $86 <
>0186c1	3c bd					.byte $3c,$bd                          ; $87 <=
>0186c3	be					.byte $be                              ; $88 >
>0186c4	3e bd					.byte $3e,$bd                          ; $89 >=
>0186c6	ab					.byte $ab                              ; $8a +
>0186c7	ad					.byte $ad                              ; $8b -
>0186c8	aa					.byte $aa                              ; $8c *
>0186c9	af					.byte $af                              ; $8d /
>0186ca	de					.byte $de                              ; $8e ^
>0186cb	49 c6					.byte $49,$c6                          ; $8f if
>0186cd	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>0186d2	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>0186d8	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>0186db	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>0186df	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>0186e4	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>0186e8	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>0186ed	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>0186f1	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>0186f4	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>0186f7	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>0186fb	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>0186ff	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>018703	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>018708	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>01870c	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>018710	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>018716	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>01871d	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>018722	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>018726	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>01872b	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>01872f	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>018733	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>018738	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>01873c	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>018740	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>018744	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>018748	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>01874c	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>018750	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>018754	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>018758	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>01875d	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>018762	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>018766	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>01876a	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>01876f	50 4f 53 a8				.byte $50,$4f,$53,$a8                  ; $b5 pos(
>018773	54 41 42 a8				.byte $54,$41,$42,$a8                  ; $b6 tab(
>018777	a4					.byte $a4                              ; $b7 $
>018778	24 a8					.byte $24,$a8                          ; $b8 $(
>01877a	a3					.byte $a3                              ; $b9 #
>01877b	23 a8					.byte $23,$a8                          ; $ba #(
>01877d	a5					.byte $a5                              ; $bb %
>01877e	25 a8					.byte $25,$a8                          ; $bc %(
>018780	a8					.byte $a8                              ; $bd (
>018781	a9					.byte $a9                              ; $be )
>018782	ac					.byte $ac                              ; $bf ,
>018783	ba					.byte $ba                              ; $c0 :
>018784	bb					.byte $bb                              ; $c1 ;
>018785	44 45 c6				.byte $44,$45,$c6                      ; $c2 def
>018788	43 4c d2				.byte $43,$4c,$d2                      ; $c3 clr
>01878b	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $c4 stop
>01878f	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c5 data
>018793	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c6 read
>018797	44 49 cd				.byte $44,$49,$cd                      ; $c7 dim
>01879a	54 cf					.byte $54,$cf                          ; $c8 to
>01879c	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c9 step
>0187a0	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $ca gosub
>0187a5	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $cb return
>0187ab	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $cc goto
>0187af	45 4e c4				.byte $45,$4e,$c4                      ; $cd end
>0187b2	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $ce input
>0187b7	4c 45 d4				.byte $4c,$45,$d4                      ; $cf let
>0187ba	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $d0 list
>0187be	4e 45 d7				.byte $4e,$45,$d7                      ; $d1 new
>0187c1	4f 4c c4				.byte $4f,$4c,$c4                      ; $d2 old
>0187c4	4f ce					.byte $4f,$ce                          ; $d3 on
>0187c6	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d4 restore
>0187cd	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d5 poke
>0187d1	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d6 print
>0187d6	52 55 ce				.byte $52,$55,$ce                      ; $d7 run
>0187d9	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d8 wait
>0187dd	53 59 d3				.byte $53,$59,$d3                      ; $d9 sys
>0187e0	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $da doke
>0187e4	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $db loke
>0187e8	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $dc assert
>0187ee	47 45 d4				.byte $47,$45,$d4                      ; $dd get
>0187f1	45 4c 53 c5				.byte $45,$4c,$53,$c5                  ; $de else
>0187f5	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_pos = $b5
=$b6					token_tab = $b6
=$b7					token_dollar = $b7
=$b8					token_dollarlparen = $b8
=$b9					token_hash = $b9
=$ba					token_hashlparen = $ba
=$bb					token_percent = $bb
=$bc					token_percentlparen = $bc
=$bd					token_lparen = $bd
=$be					token_rparen = $be
=$bf					token_comma = $bf
=$c0					token_colon = $c0
=$c1					token_semicolon = $c1
=$c2					token_def = $c2
=$c3					token_clr = $c3
=$c4					token_stop = $c4
=$c5					token_data = $c5
=$c6					token_read = $c6
=$c7					token_dim = $c7
=$c8					token_to = $c8
=$c9					token_step = $c9
=$ca					token_gosub = $ca
=$cb					token_return = $cb
=$cc					token_goto = $cc
=$cd					token_end = $cd
=$ce					token_input = $ce
=$cf					token_let = $cf
=$d0					token_list = $d0
=$d1					token_new = $d1
=$d2					token_old = $d2
=$d3					token_on = $d3
=$d4					token_restore = $d4
=$d5					token_poke = $d5
=$d6					token_print = $d6
=$d7					token_run = $d7
=$d8					token_wait = $d8
=$d9					token_sys = $d9
=$da					token_doke = $da
=$db					token_loke = $db
=$dc					token_assert = $dc
=$dd					token_get = $dd
=$de					token_else = $de

;******  Return to file: modules/basic/core.asm

.0187f6					BASIC_Start:
.0187f6	20 9b 81	jsr $01819b			jsr 	IF_Reset 					; set up and clear screen.
.0187f9	20 00 80	jsr $018000			jsr 	IFT_ClearScreen
.0187fc	a9 5c		lda #$5c			lda 	#$5C 						; JMP Long opcode
.0187fe	8d 10 03	sta $0310			sta 	LocalVector
.018801	8d 0c 03	sta $030c			sta 	UserVector
.018804	a9 c3		lda #$c3			lda 	#USRDefault & $FF 			; reset USR vector
.018806	8d 0d 03	sta $030d			sta 	UserVector+1
.018809	a9 94		lda #$94			lda 	#(USRDefault >> 8) & $FF
.01880b	8d 0e 03	sta $030e			sta 	UserVector+2
.01880e	a9 01		lda #$01			lda 	#(USRDefault >> 16) & $FF
.018810	8d 0f 03	sta $030f			sta 	UserVector+3
.018813	20 7a 97	jsr $01977a			jsr 	UpdateProgramEnd 			; update the program end.
.018816	20 8e 8f	jsr $018f8e			jsr 	ResetRunStatus 				; clear everything (CLR command)
.018819	c2 30		rep #$30			rep 	#$30
.01881b	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.01881e	1b		tcs				tcs
.01881f	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.018822	e2 30		sep #$30			sep 	#$30
.018824	4c fa 88	jmp $0188fa			jmp 	COMMAND_Run
.018827					WarmStart:
.018827	c2 30		rep #$30			rep 	#$30
.018829	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.01882c	1b		tcs				tcs
.01882d	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.018830	e2 30		sep #$30			sep 	#$30
.018832	80 f3		bra $018827			bra 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/dim.asm

.018834					Command_DIM:
.018834	98		tya				tya
.018835	48		pha				pha 								; push on stack.
.018836	20 e2 98	jsr $0198e2			jsr 	VariableExtract 			; get the identifier
.018839	ad 95 03	lda $0395			lda 	Var_Type 					; check it is an array
.01883c	29 01		and #$01			and 	#1
.01883e	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.018840	d0 6c		bne $0188ae			bne 	_CDIError
.018842	a9 00		lda #$00			lda 	#0 							; reset the DIM index. The dimensions are
.018844	8d b9 03	sta $03b9			sta 	UsrArrayIdx 				; built up here and copied in case we autodim
.018847					_CDIGetDimension:
.018847	ad b9 03	lda $03b9			lda 	UsrArrayIdx 				; done too many ?
.01884a	c9 06		cmp #$06			cmp 	#ArrayMaxDim*2
.01884c	f0 60		beq $0188ae			beq 	_CDIError
.01884e	20 92 91	jsr $019192			jsr 	EvaluateInteger 			; evaluate an index size
.018851	a5 81		lda $81				lda 	XS_Mantissa+1 				; check in range 0-7FFF
.018853	29 80		and #$80			and 	#$80
.018855	05 82		ora $82				ora 	XS_Mantissa+2
.018857	05 83		ora $83				ora 	XS_Mantissa+3
.018859	d0 53		bne $0188ae			bne 	_CDIError
.01885b	ae b9 03	ldx $03b9			ldx 	UsrArrayIdx 				; copy into the array table.
.01885e	18		clc				clc 								; add 1 - max index => size.
.01885f	a5 80		lda $80				lda 	XS_Mantissa+0
.018861	69 01		adc #$01			adc 	#1
.018863	9d b1 03	sta $03b1,x			sta 	UsrArrayDef+0,x
.018866	a5 81		lda $81				lda 	XS_Mantissa+1
.018868	69 00		adc #$00			adc 	#0
.01886a	9d b2 03	sta $03b2,x			sta 	UsrArrayDef+1,x
.01886d	30 3f		bmi $0188ae			bmi 	_CDIError 					; could be dim a(32767)
.01886f	e8		inx				inx 								; bump index.
.018870	e8		inx				inx
.018871	8e b9 03	stx $03b9			stx 	UsrArrayIdx
.018874	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018876	c8		iny				iny
.018877	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another dimension
.018879	f0 cc		beq $018847			beq 	_CDIGetDimension
.01887b	88		dey				dey
.01887c	20 d6 97	jsr $0197d6			jsr 	CheckNextRParen 			; closing ) present ?
.01887f	ae b9 03	ldx $03b9			ldx 	UsrArrayIdx 				; copy USR array to default
.018882	a9 ff		lda #$ff			lda 	#$FF 						; put end marker in ArrayDef
.018884	9d aa 03	sta $03aa,x			sta 	ArrayDef+1,x
.018887					_CDICopy:
.018887	bd b1 03	lda $03b1,x			lda 	UsrArrayDef,x
.01888a	9d a9 03	sta $03a9,x			sta 	ArrayDef,x
.01888d	ca		dex				dex
.01888e	10 f7		bpl $018887			bpl 	_CDICopy
.018890	68		pla				pla									; position of array identifier
.018891	85 10		sta $10				sta 	zTemp1
.018893	98		tya				tya
.018894	48		pha				pha
.018895	a5 10		lda $10				lda 	zTemp1 						; point to identifier
.018897	a8		tay				tay
.018898	20 e2 98	jsr $0198e2			jsr 	VariableExtract 			; get the identifier
.01889b	20 7b 9b	jsr $019b7b			jsr 	VariableLocate 				; check if it exists already.
.01889e	b0 0e		bcs $0188ae			bcs 	_CDIError
.0188a0	20 6e 99	jsr $01996e			jsr 	VariableCreate 				; create it using the current ArrayDef
.0188a3	68		pla				pla 								; restore code position
.0188a4	a8		tay				tay
.0188a5	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0188a7	c8		iny				iny
.0188a8	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another DIM
.0188aa	f0 88		beq $018834			beq 	Command_DIM
.0188ac	88		dey				dey
.0188ad	60		rts				rts
.0188ae					_CDIError:
.0188ae	20 6e 85	jsr $01856e			jsr ERR_Handler
>0188b1	42 61 64 20 44 49 4d 00			.text "Bad DIM",0
.0188b9					_CDISyntax:
.0188b9	4c 3f 85	jmp $01853f			jmp 	SyntaxError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/wait.asm

.0188bc					Command_WAIT:
.0188bc	20 92 91	jsr $019192			jsr		EvaluateInteger 			; address
.0188bf	a2 06		ldx #$06			ldx 	#XS_Size 					; and mask.
.0188c1	20 de 97	jsr $0197de			jsr 	CheckNextComma
.0188c4	20 94 91	jsr $019194			jsr 	EvaluateIntegerX
.0188c7	a9 00		lda #$00			lda 	#0							; set default xor.
.0188c9	85 8c		sta $8c				sta 	XS_Mantissa+XS_Size*2
.0188cb	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0188cd	c9 bf		cmp #$bf			cmp 	#token_Comma 				; no use the default
.0188cf	d0 06		bne $0188d7			bne 	_CWAXorDefault
.0188d1	c8		iny				iny
.0188d2	a2 0c		ldx #$0c			ldx 	#XS_Size*2
.0188d4	20 94 91	jsr $019194			jsr 	EvaluateIntegerX
.0188d7					_CWAXorDefault:
.0188d7	a5 80		lda $80				lda 	XS_Mantissa 				; copy 24 bits of mantissa to ZLTemp1
.0188d9	85 1a		sta $1a				sta 	zLTemp1
.0188db	a5 81		lda $81				lda 	XS_Mantissa+1
.0188dd	85 1b		sta $1b				sta 	zLTemp1+1
.0188df	a5 82		lda $82				lda 	XS_Mantissa+2
.0188e1	85 1c		sta $1c				sta 	zLTemp1+2
.0188e3					_CWAWaitLoop:
.0188e3	20 38 85	jsr $018538			jsr 	CheckBreak 					; exit on break.
.0188e6	c9 00		cmp #$00			cmp 	#0
.0188e8	d0 0f		bne $0188f9			bne 	_CWAWaitExit
.0188ea	a9 01		lda #$01			lda 	#1							; read 1 byte to mantissa/0
.0188ec	a2 00		ldx #$00			ldx 	#0
.0188ee	5a		phy				phy 								; this is the same routine as PEEK.
.0188ef	20 58 97	jsr $019758			jsr 	MemRead
.0188f2	7a		ply				ply
.0188f3	25 86		and $86				and 	XS_Mantissa+XS_Size 		; process it
.0188f5	45 8c		eor $8c				eor 	XS_Mantissa+XS_Size*2
.0188f7	f0 ea		beq $0188e3			beq 	_CWAWaitLoop
.0188f9					_CWAWaitExit:
.0188f9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/run.asm

.0188fa					Command_RUN:
.0188fa	20 8e 8f	jsr $018f8e			jsr 	ResetRunStatus 				; clear, reset stacks etc.
.0188fd	a9 00		lda #$00			lda 	#BasicProgram & $FF
.0188ff	85 16		sta $16				sta 	zCodePtr+0
.018901	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018903	85 17		sta $17				sta 	zCodePtr+1
.018905	a9 00		lda #$00			lda 	#0
.018907	85 18		sta $18				sta 	zCodePtr+2
.018909	85 19		sta $19				sta 	zCodePtr+3
.01890b	a0 03		ldy #$03			ldy 	#3
.01890d					RUN_NewLine:
.01890d	a0 00		ldy #$00			ldy 	#0
.01890f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018911	c8		iny				iny
.018912	c8		iny				iny
.018913	c8		iny				iny
.018914	c9 00		cmp #$00			cmp 	#0 							; if the offset is zero then END.
.018916	d0 16		bne $01892e			bne 	RUN_NextCommand
.018918	4c 57 8b	jmp $018b57			jmp 	Command_END 				; go do the command code.
.01891b					RUN_Skip:
.01891b	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.01891d	c8		iny				iny 								; skip
.01891e	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018920	90 0c		bcc $01892e			bcc 	_SEDone 					; so just skip over it.
.018922	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018924	90 07		bcc $01892d			bcc 	_SEDouble
.018926	98		tya				tya 								; this is Y + 1
.018927	18		clc				clc
.018928	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.01892a	a8		tay				tay 								; back in Y.
.01892b	88		dey				dey 								; fix up, one for the +1, one for the iny
.01892c	88		dey				dey
.01892d					_SEDouble:
.01892d	c8		iny				iny
.01892e					_SEDone:
.01892e					RUN_NextCommand:
.01892e	ad a8 03	lda $03a8			lda 	BreakCount 					; break counter
.018931	69 10		adc #$10			adc 	#16 						; one time in 16
.018933	8d a8 03	sta $03a8			sta 	BreakCount
.018936	90 0a		bcc $018942			bcc 	RUN_NoCheckBreak
.018938	20 38 85	jsr $018538			jsr 	CheckBreak 					; check for break
.01893b	c9 00		cmp #$00			cmp 	#0
.01893d	f0 03		beq $018942			beq 	RUN_NoCheckBreak
.01893f	4c a5 8f	jmp $018fa5			jmp 	Command_STOP 				; stop on BREAK.
.018942					RUN_NoCheckBreak:
.018942	a9 00		lda #$00			lda 	#0 							; this resets temporary string allocation.
.018944	85 21		sta $21				sta 	zTempStr+1 					; (initialised when first called)
.018946	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018948	c9 c0		cmp #$c0			cmp 	#token_Colon 				; skip over colons
.01894a	f0 cf		beq $01891b			beq 	RUN_Skip
.01894c	c9 00		cmp #$00			cmp 	#0 							; if non-zero execute whatever
.01894e	d0 0f		bne $01895f			bne 	RUN_Execute
.018950					RUN_NextLine:
.018950	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018952	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.018954	18		clc				clc
.018955	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018957	85 16		sta $16				sta 	zCodePtr
.018959	90 02		bcc $01895d			bcc 	_SNLNoCarry
.01895b	e6 17		inc $17				inc 	zCodePtr+1
.01895d					_SNLNoCarry:
.01895d	80 ae		bra $01890d			bra 	RUN_NewLine 				; go do the new line code
.01895f					RUN_Execute:
.01895f	c9 f8		cmp #$f8			cmp 	#$F8 						; handle shifts, REM etc.
.018961	b0 1e		bcs $018981			bcs 	RUN_Extension
.018963	c8		iny				iny
.018964	0a		asl a				asl 	a 							; double the character read.
.018965	90 14		bcc $01897b			bcc 	RUN_Default 				; if carry clear was $00-$7F, so try LET.
.018967	aa		tax				tax 								; ready to look up.
.018968	bf d2 85 01	lda $0185d2,x			lda 	VectorTable,x 				; copy address into LocalVector
.01896c	8d 11 03	sta $0311			sta 	LocalVector+1
.01896f	bf d3 85 01	lda $0185d3,x			lda 	VectorTable+1,x
.018973	8d 12 03	sta $0312			sta 	LocalVector+2
.018976	20 df 90	jsr $0190df			jsr 	EVCallLocalVector 			; execute the appropriate code.
.018979	80 b3		bra $01892e			bra 	RUN_NextCommand 			; do the next command.
.01897b					RUN_Default:
.01897b	88		dey				dey
.01897c	20 1c 8b	jsr $018b1c			jsr 	Command_LET 				; and try LET.
.01897f	80 ad		bra $01892e			bra 	RUN_NextCommand
.018981					RUN_Extension:
.018981	c9 ff		cmp #$ff			cmp 	#$FF 						; if $FF (REM)
.018983	f0 96		beq $01891b			beq 	RUN_Skip 					; skip over it.
.018985	4c 3f 85	jmp $01853f			jmp 	SyntaxError
.018988					Command_COLON:
.018988	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/for.asm

.018989					Command_FOR:
.018989	20 1c 8b	jsr $018b1c			jsr 	Command_LET 				; do the A = 99 bit
.01898c	a5 24		lda $24				lda 	zVarType 					; obviously has to be integer/real.
.01898e	c9 b7		cmp #$b7			cmp 	#token_Dollar
.018990	f0 71		beq $018a03			beq 	_CFOError
.018992	48		pha				pha 								; save the variable type.
.018993	5a		phy				phy 								; save type/variable address.
.018994	a0 01		ldy #$01			ldy 	#1							; type at + 1
.018996	91 26		sta ($26),y			sta 	(zBasicSP),y
.018998	c8		iny				iny
.018999	a5 22		lda $22				lda 	zVarDataPtr 				; data low at +2
.01899b	91 26		sta ($26),y			sta 	(zBasicSP),y
.01899d	c8		iny				iny
.01899e	a5 23		lda $23				lda 	zVarDataPtr+1 				; data high at +3
.0189a0	91 26		sta ($26),y			sta 	(zBasicSP),y
.0189a2	7a		ply				ply
.0189a3	a9 53		lda #$53			lda 	#(SMark_For << 4) + 3
.0189a5	20 b2 84	jsr $0184b2			jsr 	StackPushFrame 				; push on the stack with FOR marker.
.0189a8	a9 c8		lda #$c8			lda 	#token_TO
.0189aa	20 bf 97	jsr $0197bf			jsr 	CheckNextToken
.0189ad	a2 00		ldx #$00			ldx 	#0 							; put in Mantissa, bottom
.0189af	20 fc 8f	jsr $018ffc			jsr 	EvaluateExpression
.0189b2	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0189b4	a2 06		ldx #$06			ldx 	#XS_Size 					; X to second level
.0189b6	c9 c9		cmp #$c9			cmp 	#token_STEP
.0189b8	d0 06		bne $0189c0			bne 	_CFOStep1
.0189ba	c8		iny				iny
.0189bb	20 fe 8f	jsr $018ffe			jsr 	EvaluateExpressionX 		; get STEP value.
.0189be	80 0e		bra $0189ce			bra 	_CFOHaveStep
.0189c0					_CFOStep1:
.0189c0	a9 00		lda #$00			lda 	#0							; set step to integer 1.
.0189c2	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0189c4	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0189c6	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0189c8	a9 01		lda #$01			lda 	#1
.0189ca	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0189cc	95 85		sta $85,x			sta 	XS_Type,x
.0189ce					_CFOHaveStep:
.0189ce	68		pla				pla 								; restore variable type
.0189cf	a2 00		ldx #$00			ldx 	#0
.0189d1	c9 bb		cmp #$bb			cmp 	#token_Percent 				; do conversion to type
.0189d3	f0 0a		beq $0189df			beq 	_CFOInteger
.0189d5	20 86 a1	jsr $01a186			jsr 	FPUToFloat
.0189d8	a2 06		ldx #$06			ldx 	#6
.0189da	20 86 a1	jsr $01a186			jsr 	FPUToFloat
.0189dd	80 08		bra $0189e7			bra 	_CFOEndConv
.0189df					_CFOInteger:
.0189df	20 d2 a1	jsr $01a1d2			jsr 	FPUToInteger
.0189e2	a2 06		ldx #$06			ldx 	#6
.0189e4	20 d2 a1	jsr $01a1d2			jsr 	FPUToInteger
.0189e7					_CFOEndConv:
.0189e7	20 f9 84	jsr $0184f9			jsr 	StackSavePosition 			; save the loop position at 1-5
.0189ea	a9 55		lda #$55			lda 	#(SMark_For << 4)+SourcePosSize
.0189ec	20 b2 84	jsr $0184b2			jsr 	StackPushFrame 				; push the loop address frame.
.0189ef	5a		phy				phy
.0189f0	a0 00		ldy #$00			ldy 	#0
.0189f2					_CFOCopy:
.0189f2	b9 80 00	lda $0080,y			lda 	XS_Mantissa+0,y
.0189f5	c8		iny				iny
.0189f6	91 26		sta ($26),y			sta 	(zBasicSP),y
.0189f8	c0 0c		cpy #$0c			cpy 	#XS_Size*2
.0189fa	d0 f6		bne $0189f2			bne 	_CFOCopy
.0189fc	7a		ply				ply
.0189fd	a9 5c		lda #$5c			lda 	#(SMark_For << 4)+(XS_Size*2)
.0189ff	20 b2 84	jsr $0184b2			jsr 	StackPushFrame
.018a02	60		rts				rts
.018a03					_CFOError:
.018a03	4c 4f 85	jmp $01854f			jmp 	TypeError 					; wrong type.
.018a06					Command_NEXT:
.018a06	a9 00		lda #$00			lda 	#0 							; set variable data pointer+1 to zero
.018a08	85 23		sta $23				sta 	zVarDataPtr+1 				; this means we don't check
.018a0a	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018a0c	c9 00		cmp #$00			cmp 	#0 							; EOL
.018a0e	f0 07		beq $018a17			beq 	_CNextNoVariable
.018a10	c9 40		cmp #$40			cmp 	#$40
.018a12	b0 03		bcs $018a17			bcs 	_CNextNoVariable
.018a14	20 77 98	jsr $019877			jsr 	VariableFind
.018a17					_CNextNoVariable:
.018a17	a5 26		lda $26				lda 	zBasicSP 					; save on stack
.018a19	48		pha				pha
.018a1a	a5 27		lda $27				lda 	zBasicSP+1
.018a1c	48		pha				pha
.018a1d	a9 50		lda #$50			lda 	#(SMark_For << 4) 			; pop loop address frame
.018a1f	20 c9 84	jsr $0184c9			jsr 	StackPopFrame
.018a22	a9 50		lda #$50			lda 	#(SMark_For << 4) 			; pop STEP/TARGET frame.
.018a24	20 c9 84	jsr $0184c9			jsr 	StackPopFrame
.018a27	a9 50		lda #$50			lda 	#(Smark_For << 4) 			; pop variable address frame.
.018a29	20 c9 84	jsr $0184c9			jsr 	StackPopFrame
.018a2c	a5 23		lda $23				lda 	zVarDataPtr+1 				; if zero, then no variable provided
.018a2e	f0 11		beq $018a41			beq 	_CNextGetTarget 			; e.g. just NEXT not NEXT x
.018a30	5a		phy				phy 								; check addresses match.
.018a31	a0 02		ldy #$02			ldy 	#2
.018a33	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a35	c5 22		cmp $22				cmp 	zVarDataPtr
.018a37	d0 69		bne $018aa2			bne 	_CNextWrong
.018a39	c8		iny				iny
.018a3a	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a3c	c5 23		cmp $23				cmp 	zVarDataPtr+1
.018a3e	d0 62		bne $018aa2			bne 	_CNextWrong
.018a40	7a		ply				ply
.018a41					_CNextGetTarget:
.018a41	5a		phy				phy
.018a42	a0 01		ldy #$01			ldy 	#1 							; restore variable type and data.
.018a44	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a46	85 24		sta $24				sta 	zVarType
.018a48	c8		iny				iny
.018a49	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a4b	85 22		sta $22				sta 	zVarDataPtr
.018a4d	c8		iny				iny
.018a4e	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a50	85 23		sta $23				sta 	zVarDataPtr+1
.018a52	a2 0c		ldx #$0c			ldx 	#12
.018a54	20 bf 9b	jsr $019bbf			jsr 	VariableGet 				; get that variable value into expr[2]
.018a57	a2 00		ldx #$00			ldx 	#0 							; copy stacked Target/Step into expr[0] and [1]
.018a59	a0 0b		ldy #$0b			ldy 	#11
.018a5b					_CNXCopy:
.018a5b	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a5d	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018a5f	e8		inx				inx
.018a60	c8		iny				iny
.018a61	e0 0c		cpx #$0c			cpx 	#XS_Size*2
.018a63	d0 f6		bne $018a5b			bne 	_CNXCopy
.018a65	7a		ply				ply
.018a66	a2 06		ldx #$06			ldx 	#6 							; point at expr[1] s
.018a68	20 04 94	jsr $019404			jsr 	GetSignCurrent
.018a6b	8d a7 03	sta $03a7			sta 	SignNext 					; save in temporary.
.018a6e	a2 06		ldx #$06			ldx 	#6 							; add them, however
.018a70	20 e3 92	jsr $0192e3			jsr 	BinaryOp_Add
.018a73	20 10 9c	jsr $019c10			jsr 	VariableSet					; and write variable back.
.018a76	a2 00		ldx #$00			ldx 	#0
.018a78	20 67 92	jsr $019267			jsr 	CompareValues
.018a7b	09 00		ora #$00			ora 	#0
.018a7d	f0 05		beq $018a84			beq 	_CNXAgain 					; if true, then do it again.
.018a7f	cd a7 03	cmp $03a7			cmp 	SignNext 					; if sign different, then loop has finished.
.018a82	d0 0f		bne $018a93			bne 	_CNXLoopDone
.018a84					_CNXAgain:
.018a84	a9 53		lda #$53			lda 	#(SMark_For << 4) + 3		; re-stack variable address
.018a86	20 b2 84	jsr $0184b2			jsr 	StackPushFrame
.018a89	20 16 85	jsr $018516			jsr 	StackRestorePosition 		; get restore position back, e.g. loop round.
.018a8c	68		pla				pla
.018a8d	85 27		sta $27				sta 	zBasicSP+1
.018a8f	68		pla				pla
.018a90	85 26		sta $26				sta 	zBasicSP
.018a92					_CNXExit:
.018a92	60		rts				rts
.018a93					_CNXLoopDone:
.018a93	68		pla				pla
.018a94	68		pla				pla
.018a95	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018a97	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma ?
.018a99	d0 f7		bne $018a92			bne 	_CNXExit
.018a9b	c8		iny				iny
.018a9c	20 77 98	jsr $019877			jsr 	VariableFind 				; identify the variable
.018a9f	4c 17 8a	jmp $018a17			jmp 	_CNextNoVariable 			; go back with variable pre-found
.018aa2					_CNextWrong:
.018aa2	20 6e 85	jsr $01856e			jsr ERR_Handler
>018aa5	57 72 6f 6e 67 20 4e 65			.text "Wrong Next Variable",0
>018aad	78 74 20 56 61 72 69 61 62 6c 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/read.asm

.018ab9					Command_READ:
.018ab9	20 77 98	jsr $019877			jsr 	VariableFind 				; get variable/value into zVarDataPtr,zVarType
.018abc	a5 22		lda $22				lda 	zVarDataPtr 				; save variable info on stack
.018abe	48		pha				pha
.018abf	a5 23		lda $23				lda 	zVarDataPtr+1
.018ac1	48		pha				pha
.018ac2	a5 24		lda $24				lda 	zVarType
.018ac4	48		pha				pha
.018ac5	20 0b 8b	jsr $018b0b			jsr 	READGetDataItem 			; get the next data item
.018ac8	68		pla				pla 								; restore target variable information.
.018ac9	85 24		sta $24				sta 	zVarType
.018acb	68		pla				pla
.018acc	85 23		sta $23				sta 	zVarDataPtr+1
.018ace	68		pla				pla
.018acf	85 22		sta $22				sta 	zVarDataPtr
.018ad1	a2 00		ldx #$00			ldx 	#0
.018ad3	20 10 9c	jsr $019c10			jsr 	VariableSet 				; set the value out.
.018ad6	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018ad8	c8		iny				iny
.018ad9	c9 bf		cmp #$bf			cmp 	#token_Comma
.018adb	f0 dc		beq $018ab9			beq 	Command_READ 				; found, do another READ
.018add	88		dey				dey
.018ade	60		rts				rts
.018adf					Command_DATA:
.018adf	4c 80 84	jmp $018480			jmp 	SkipEndOfCommand
.018ae2					Command_RESTORE:
.018ae2	48		pha				pha
.018ae3	a9 00		lda #$00			lda 	#0 							; this being zero means 'initialise next read'
.018ae5	8d bd 03	sta $03bd			sta 	DataLPtr+0
.018ae8	8d be 03	sta $03be			sta 	DataLPtr+1
.018aeb	68		pla				pla
.018aec	60		rts				rts
.018aed					READSwapPointers:
.018aed	98		tya				tya
.018aee	48		pha				pha 								; save it
.018aef	ad c1 03	lda $03c1			lda 	DataIndex 					; get data offset, and copy to offset
.018af2	a8		tay				tay
.018af3	68		pla				pla 								; get code offset and save in DataIndex
.018af4	8d c1 03	sta $03c1			sta 	DataIndex
.018af7	da		phx				phx
.018af8	a2 03		ldx #$03			ldx 	#3 							; swap the Data Pointers (4 bytes) round.
.018afa					_RSWLoop:
.018afa	bd bd 03	lda $03bd,x			lda 	DataLPtr+0,x
.018afd	48		pha				pha
.018afe	b5 16		lda $16,x			lda 	zCodePtr+0,x
.018b00	9d bd 03	sta $03bd,x			sta 	DataLPtr+0,x
.018b03	68		pla				pla
.018b04	95 16		sta $16,x			sta 	zCodePtr+0,x
.018b06	ca		dex				dex
.018b07	10 f1		bpl $018afa			bpl 	_RSWLoop
.018b09	fa		plx				plx
.018b0a	60		rts				rts
.018b0b					READGetDataItem:
.018b0b	a9 0c		lda #$0c			lda 	#12
.018b0d	85 80		sta $80				sta 	XS_Mantissa+0
.018b0f	a9 00		lda #$00			lda 	#0
.018b11	85 81		sta $81				sta 	XS_Mantissa+1
.018b13	85 82		sta $82				sta 	XS_Mantissa+2
.018b15	85 83		sta $83				sta 	XS_Mantissa+3
.018b17	a9 01		lda #$01			lda 	#1
.018b19	85 85		sta $85				sta 	XS_Type
.018b1b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/let.asm

.018b1c					Command_LET:
.018b1c	20 77 98	jsr $019877			jsr 	VariableFind 				; get reference to one variable.
.018b1f	a9 84		lda #$84			lda 	#token_Equal  				; get equals
.018b21	20 bf 97	jsr $0197bf			jsr 	CheckNextToken
.018b24	a5 22		lda $22				lda 	zVarDataPtr 				; save variable info on stack
.018b26	48		pha				pha
.018b27	a5 23		lda $23				lda 	zVarDataPtr+1
.018b29	48		pha				pha
.018b2a	a5 24		lda $24				lda 	zVarType
.018b2c	48		pha				pha
.018b2d	20 fc 8f	jsr $018ffc			jsr 	EvaluateExpression 			; evaluate the RHS, set X to zero.
.018b30	68		pla				pla 								; restore target variable information.
.018b31	85 24		sta $24				sta 	zVarType
.018b33	68		pla				pla
.018b34	85 23		sta $23				sta 	zVarDataPtr+1
.018b36	68		pla				pla
.018b37	85 22		sta $22				sta 	zVarDataPtr
.018b39	20 10 9c	jsr $019c10			jsr 	VariableSet 				; set the value out.
.018b3c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/sys.asm

.018b3d					Command_SYS:
.018b3d	20 92 91	jsr $019192			jsr 	EvaluateInteger 			; address
.018b40	a5 80		lda $80				lda 	XS_Mantissa+0				; copy to localvector
.018b42	8d 10 03	sta $0310			sta 	LocalVector+0 				; only three, can only do 24 bit calls
.018b45	a5 81		lda $81				lda 	XS_Mantissa+1 				; and that only on 65816
.018b47	8d 11 03	sta $0311			sta 	LocalVector+1
.018b4a	a5 82		lda $82				lda 	XS_Mantissa+2
.018b4c	8d 12 03	sta $0312			sta 	LocalVector+2
.018b4f	22 54 8b 01	jsl $018b54			jsl 	_CSYLocalCall
.018b53	60		rts				rts
.018b54					_CSYLocalCall:
.018b54	dc 10 03	jmp [$0310]			jmp 	[LocalVector]

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/end.asm

.018b57					Command_END:
>018b57	02						.byte 	2
.018b58	4c 27 88	jmp $018827			jmp 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/if.asm

.018b5b					Command_IF:
.018b5b	20 92 91	jsr $019192			jsr 	EvaluateInteger 			; check success.
.018b5e	a5 80		lda $80				lda 	XS_Mantissa+0				; check the result if zero
.018b60	05 81		ora $81				ora 	XS_Mantissa+1
.018b62	05 82		ora $82				ora 	XS_Mantissa+2
.018b64	05 83		ora $83				ora 	XS_Mantissa+3
.018b66	aa		tax				tax 								; put into X.
.018b67	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018b69	c9 93		cmp #$93			cmp 	#token_Then 				; then found.
.018b6b	d0 2c		bne $018b99			bne 	_FIFExtended
.018b6d	c8		iny				iny
.018b6e	e0 00		cpx #$00			cpx 	#0 							; was it successful.
.018b70	f0 0b		beq $018b7d			beq 	_FIFEndOfLine 				; if not, go to the end of the line.
.018b72	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018b74	29 c0		and #$c0			and 	#$C0 						; is it a number
.018b76	c9 40		cmp #$40			cmp 	#$40
.018b78	d0 1e		bne $018b98			bne 	_FIFContinue 				; if not, do what ever follows.
.018b7a	4c cc 8e	jmp $018ecc			jmp		Command_GOTO 				; we have IF <expr> THEN <number> so we do GOTO code.
.018b7d					_FIFEndOfLine:
.018b7d	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018b7f	c9 00		cmp #$00			cmp 	#0 							; if zero, end of line, so exit
.018b81	f0 15		beq $018b98			beq 	_FIFContinue
.018b83	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018b85	c8		iny				iny 								; skip
.018b86	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018b88	90 0c		bcc $018b96			bcc 	_SEDone 					; so just skip over it.
.018b8a	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018b8c	90 07		bcc $018b95			bcc 	_SEDouble
.018b8e	98		tya				tya 								; this is Y + 1
.018b8f	18		clc				clc
.018b90	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018b92	a8		tay				tay 								; back in Y.
.018b93	88		dey				dey 								; fix up, one for the +1, one for the iny
.018b94	88		dey				dey
.018b95					_SEDouble:
.018b95	c8		iny				iny
.018b96					_SEDone:
.018b96	80 e5		bra $018b7d			bra 	_FIFEndOfLine
.018b98					_FIFContinue:
.018b98	60		rts				rts
.018b99					_FIFExtended:
.018b99	da		phx				phx 								; save result
.018b9a	a9 40		lda #$40			lda 	#(SMark_If << 4) 			; push marker on the stack, nothing else.
.018b9c	20 b2 84	jsr $0184b2			jsr 	StackPushFrame
.018b9f	68		pla				pla 								; restore result
.018ba0	f0 01		beq $018ba3			beq 	_FIXSkip 					; if zero then it has failed.
.018ba2	60		rts				rts 								; test passed, so continue executing
.018ba3					_FIXSkip:
.018ba3	a9 94		lda #$94			lda 	#token_endif 				; scan forward till found either ELSE or ENDIF
.018ba5	a2 de		ldx #$de			ldx 	#token_else 				; at the same level.
.018ba7	20 f5 83	jsr $0183f5			jsr 	StructureSearchDouble
.018baa	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018bac	c8		iny				iny
.018bad	c9 94		cmp #$94			cmp 	#token_endif 				; if endif, handle endif code.
.018baf	f0 07		beq $018bb8			beq 	Command_ENDIF
.018bb1	60		rts				rts
.018bb2					Command_ELSE:
.018bb2	a9 94		lda #$94			lda 	#token_endif 				; scan forward till found ENDIF
.018bb4	20 f3 83	jsr $0183f3			jsr 	StructureSearchSingle 		; then do the ENDIF pop.
.018bb7	c8		iny				iny
.018bb8					Command_ENDIF:
.018bb8	a9 40		lda #$40			lda 	#(SMark_If << 4)
.018bba	20 c9 84	jsr $0184c9			jsr 	StackPopFrame
.018bbd	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/list.asm

.018bbe					Command_LIST:
.018bbe	20 4b 8d	jsr $018d4b			jsr 	ListGetRange				; get any parameters
.018bc1	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018bc3	85 16		sta $16				sta 	zCodePtr+0
.018bc5	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018bc7	85 17		sta $17				sta 	zCodePtr+1
.018bc9	a9 00		lda #$00			lda 	#0
.018bcb	85 18		sta $18				sta 	zCodePtr+2
.018bcd	85 19		sta $19				sta 	zCodePtr+3
.018bcf	a0 03		ldy #$03			ldy 	#3
.018bd1	a9 00		lda #$00			lda 	#0 							; reset the indent & last indent
.018bd3	8d bc 03	sta $03bc			sta 	LastListIndent
.018bd6	8d bb 03	sta $03bb			sta 	ListIndent
.018bd9					_CILLoop:
.018bd9	a0 00		ldy #$00			ldy 	#0
.018bdb	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018bdd	c9 00		cmp #$00			cmp 	#0 							; if zero, end of program
.018bdf	f0 23		beq $018c04			beq 	_CILExit
.018be1	20 38 85	jsr $018538			jsr 	CheckBreak 					; check break
.018be4	c9 00		cmp #$00			cmp 	#0
.018be6	d0 1c		bne $018c04			bne 	_CILExit
.018be8	20 92 8d	jsr $018d92			jsr 	ListCheckRange 				; check current line in range.
.018beb	b0 08		bcs $018bf5			bcs		_CILNext
.018bed	a0 00		ldy #$00			ldy 	#0
.018bef	c8		iny				iny
.018bf0	c8		iny				iny
.018bf1	c8		iny				iny
.018bf2	20 07 8c	jsr $018c07			jsr 	ListLine 					; list one line.
.018bf5					_CILNext:
.018bf5	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018bf7	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.018bf9	18		clc				clc
.018bfa	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018bfc	85 16		sta $16				sta 	zCodePtr
.018bfe	90 02		bcc $018c02			bcc 	_SNLNoCarry
.018c00	e6 17		inc $17				inc 	zCodePtr+1
.018c02					_SNLNoCarry:
.018c02	80 d5		bra $018bd9			bra 	_CILLoop
.018c04					_CILExit:
.018c04	4c 27 88	jmp $018827			jmp 	WarmStart
.018c07					ListLine:
.018c07	ad bb 03	lda $03bb			lda 	ListIndent 					; copy current list indent -> last
.018c0a	8d bc 03	sta $03bc			sta 	LastListIndent
.018c0d					_LICountIndent:
.018c0d	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c0f	c9 00		cmp #$00			cmp 	#0
.018c11	f0 2f		beq $018c42			beq 	_LIDoneIndent
.018c13	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus
.018c15	90 16		bcc $018c2d			bcc 	_LICINext
.018c17	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.018c19	b0 12		bcs $018c2d			bcs 	_LICINext
.018c1b	ee bb 03	inc $03bb			inc 	ListIndent
.018c1e	c9 93		cmp #$93			cmp 	#firstKeywordMinus
.018c20	90 0b		bcc $018c2d			bcc 	_LICINext
.018c22	ce bb 03	dec $03bb			dec 	ListIndent
.018c25	ce bb 03	dec $03bb			dec 	ListIndent
.018c28	10 03		bpl $018c2d			bpl 	_LICINext
.018c2a	ee bb 03	inc $03bb			inc 	ListIndent
.018c2d					_LICINext:
.018c2d	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018c2f	c8		iny				iny 								; skip
.018c30	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018c32	90 0c		bcc $018c40			bcc 	_SEDone 					; so just skip over it.
.018c34	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018c36	90 07		bcc $018c3f			bcc 	_SEDouble
.018c38	98		tya				tya 								; this is Y + 1
.018c39	18		clc				clc
.018c3a	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018c3c	a8		tay				tay 								; back in Y.
.018c3d	88		dey				dey 								; fix up, one for the +1, one for the iny
.018c3e	88		dey				dey
.018c3f					_SEDouble:
.018c3f	c8		iny				iny
.018c40					_SEDone:
.018c40	80 cb		bra $018c0d			bra 	_LICountIndent
.018c42					_LIDoneIndent:
.018c42	a0 00		ldy #$00			ldy 	#0
.018c44	c8		iny				iny
.018c45	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c47	85 80		sta $80				sta 	XS_Mantissa
.018c49	c8		iny				iny
.018c4a	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c4c	85 81		sta $81				sta 	XS_Mantissa+1
.018c4e	20 b4 85	jsr $0185b4			jsr 	Print16BitInteger 			; print integer.
.018c51	85 10		sta $10				sta 	zTemp1 						; save spaces printed.
.018c53	ad bb 03	lda $03bb			lda 	ListIndent 					; smaller of current/prev indent
.018c56	cd bc 03	cmp $03bc			cmp 	LastListIndent
.018c59	90 03		bcc $018c5e			bcc 	_LISmaller
.018c5b	ad bc 03	lda $03bc			lda 	LastListIndent
.018c5e					_LISmaller:
.018c5e	0a		asl a				asl 	a 							; double indent
.018c5f	49 ff		eor #$ff			eor 	#$FF 						; 2's complement arithmetic
.018c61	38		sec				sec
.018c62	65 10		adc $10				adc 	zTemp1 						; "subtract" indent e.g. print more.
.018c64	aa		tax				tax 								; print spaces to column 6
.018c65					_LISpace:
.018c65	a9 20		lda #$20			lda 	#" "
.018c67	20 3b 8d	jsr $018d3b			jsr 	ListPrintLC
.018c6a	e8		inx				inx
.018c6b	e0 06		cpx #$06			cpx 	#6
.018c6d	d0 f6		bne $018c65			bne 	_LISpace
.018c6f					_LIDecode:
.018c6f	c8		iny				iny
.018c70	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c72	c9 00		cmp #$00			cmp 	#0 							; zero, exit.
.018c74	f0 0f		beq $018c85			beq 	_LIExit
.018c76	30 12		bmi $018c8a			bmi 	_LIToken
.018c78	c9 40		cmp #$40			cmp 	#$40 						; 01-$3F, character.
.018c7a	b0 50		bcs $018ccc			bcs 	_LIInteger
.018c7c	49 20		eor #$20			eor 	#$20 						; make 7 bit
.018c7e	69 20		adc #$20			adc 	#$20
.018c80	20 3b 8d	jsr $018d3b			jsr 	ListPrintLC 				; print in LC
.018c83	80 ea		bra $018c6f			bra 	_LIDecode
.018c85					_LIExit:
.018c85	a9 0d		lda #$0d			lda 	#13 						; print new line.
.018c87	4c 3b 8d	jmp $018d3b			jmp 	ListPrintLC
.018c8a					_LIToken:
.018c8a	c9 fc		cmp #$fc			cmp 	#$FC 						; $FC-$FF ?
.018c8c	90 49		bcc $018cd7			bcc		_LICommandToken
.018c8e	48		pha				pha 								; save in case end
.018c8f	a2 22		ldx #$22			ldx 	#'"'						; print if $FE quoted string
.018c91	c9 fe		cmp #$fe			cmp 	#$FE
.018c93	f0 17		beq $018cac			beq 	_LIPrint
.018c95	a2 2e		ldx #$2e			ldx 	#'.'						; print if $FD decimals
.018c97	c9 fd		cmp #$fd			cmp 	#$FD
.018c99	f0 11		beq $018cac			beq 	_LIPrint
.018c9b	a9 52		lda #$52			lda 	#'R'						; must be REM
.018c9d	20 3b 8d	jsr $018d3b			jsr 	ListPrintLC
.018ca0	a9 45		lda #$45			lda 	#'E'
.018ca2	20 3b 8d	jsr $018d3b			jsr 	ListPrintLC
.018ca5	a9 4d		lda #$4d			lda 	#'M'
.018ca7	20 3b 8d	jsr $018d3b			jsr 	ListPrintLC
.018caa	a2 20		ldx #$20			ldx 	#' '
.018cac					_LIPrint:
.018cac	8a		txa				txa
.018cad	20 3b 8d	jsr $018d3b			jsr 	ListPrintLC
.018cb0	c8		iny				iny
.018cb1	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018cb3	aa		tax				tax 								; put in X
.018cb4	ca		dex				dex
.018cb5					_LILoop:
.018cb5	ca		dex				dex 								; exit when count reached zero.
.018cb6	f0 08		beq $018cc0			beq 	_LIEnd
.018cb8	c8		iny				iny
.018cb9	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018cbb	20 3b 8d	jsr $018d3b			jsr 	ListPrintLC
.018cbe	80 f5		bra $018cb5			bra 	_LILoop
.018cc0	68		pla		_LIEnd:	pla 								; get A back
.018cc1	c9 fe		cmp #$fe			cmp 	#$FE 						; if '"' need closing quotes
.018cc3	d0 aa		bne $018c6f			bne 	_LIDecode
.018cc5	a9 22		lda #$22			lda 	#'"'
.018cc7	20 3b 8d	jsr $018d3b			jsr 	ListPrintLC
.018cca	80 a3		bra $018c6f			bra 	_LIDecode
.018ccc					_LIInteger:
.018ccc	a2 00		ldx #$00			ldx 	#0
.018cce	20 04 91	jsr $019104			jsr 	EvaluateGetInteger 			; get an atom
.018cd1	88		dey				dey
.018cd2	20 ba 85	jsr $0185ba			jsr 	Print32BitInteger 			; print integer.
.018cd5	80 98		bra $018c6f			bra 	_LIDecode
.018cd7					_LICommandToken:
.018cd7	5a		phy				phy 								; save Y
.018cd8	48		pha				pha 								; save token
.018cd9	a2 b2		ldx #$b2			ldx  	#KeywordText & $FF 			; address of keyword text table.
.018cdb	a9 86		lda #$86			lda 	(#KeywordText >> 8) & $FF
.018cdd	86 1a		stx $1a				stx 	zLTemp1
.018cdf	85 1b		sta $1b				sta 	zLTemp1+1
.018ce1	a9 01		lda #$01			lda 	(#KeywordText >> 16) & $FF 	; this is for 65816 (it's a table in code
.018ce3	85 1c		sta $1c				sta 	zLTemp1+2 					; space) and won't affect a 6502 at all.
.018ce5	68		pla				pla 								; get token
.018ce6	29 7f		and #$7f			and 	#127 						; chuck bit 7.
.018ce8	f0 16		beq $018d00			beq 	_LIFoundToken
.018cea	aa		tax				tax
.018ceb					_LITokenLoop:
.018ceb	a0 00		ldy #$00			ldy 	#0 							; last character not a token.
.018ced					_LIFindEnd:
.018ced	b7 1a		lda [$1a],y			lda 	[zLTemp1],y
.018cef	c8		iny				iny
.018cf0	0a		asl a				asl 	a
.018cf1	90 fa		bcc $018ced			bcc 	_LIFindEnd
.018cf3	98		tya				tya 								; that is step to the next
.018cf4	18		clc				clc 								; we don't bother bumping the 3rd byte
.018cf5	65 1a		adc $1a				adc 	zLTemp1 					; here.
.018cf7	85 1a		sta $1a				sta 	zLTemp1
.018cf9	90 02		bcc $018cfd			bcc 	_LINoBump
.018cfb	e6 1b		inc $1b				inc 	zLTemp1+1
.018cfd					_LINoBump:
.018cfd	ca		dex				dex 								; no go round again.
.018cfe	d0 eb		bne $018ceb			bne 	_LITokenLoop
.018d00					_LIFoundToken:
.018d00	a0 00		ldy #$00			ldy 	#0
.018d02					_LIPrintToken:
.018d02	b7 1a		lda [$1a],y			lda 	[zLTemp1],y
.018d04	c0 00		cpy #$00			cpy 	#0 							; see if needs prefix space
.018d06	d0 16		bne $018d1e			bne 	_LINoPrefixSpace
.018d08	c9 41		cmp #$41			cmp 	#"A" 						; e.g. alphabetic token.
.018d0a	90 12		bcc $018d1e			bcc 	_LINoPrefixSpace
.018d0c	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018d0e	b0 0e		bcs $018d1e			bcs 	_LINoPrefixSpace
.018d10	ae ba 03	ldx $03ba			ldx 	LastPrinted 				; if last was space not required
.018d13	e0 20		cpx #$20			cpx 	#" "
.018d15	f0 07		beq $018d1e			beq 	_LINoPrefixSpace
.018d17	48		pha				pha
.018d18	a9 20		lda #$20			lda 	#" "
.018d1a	20 3b 8d	jsr $018d3b			jsr 	ListPrintLC
.018d1d	68		pla				pla
.018d1e					_LINoPrefixSpace:
.018d1e	c8		iny				iny
.018d1f	48		pha				pha 								; save it
.018d20	29 7f		and #$7f			and 	#$7F
.018d22	20 3b 8d	jsr $018d3b			jsr 	ListPrintLC
.018d25	68		pla				pla
.018d26	10 da		bpl $018d02			bpl 	_LIPrintToken 				; go back if not end
.018d28	7a		ply				ply 								; restore Y
.018d29	29 7f		and #$7f			and 	#$7F 						; if last char is a letter
.018d2b	c9 41		cmp #$41			cmp 	#"A"
.018d2d	90 09		bcc $018d38			bcc 	_LINotLetter2
.018d2f	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018d31	b0 05		bcs $018d38			bcs 	_LINotLetter2
.018d33	a9 20		lda #$20			lda 	#" " 						; add spacing
.018d35	20 3b 8d	jsr $018d3b			jsr 	ListPrintLC
.018d38					_LINotLetter2:
.018d38	4c 6f 8c	jmp $018c6f			jmp 	_LIDecode
.018d3b					ListPrintLC:
.018d3b	8d ba 03	sta $03ba			sta 	LastPrinted
.018d3e	c9 41		cmp #$41			cmp 	#"A"
.018d40	90 06		bcc $018d48			bcc 	_LPLC0
.018d42	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018d44	b0 02		bcs $018d48			bcs 	_LPLC0
.018d46	69 20		adc #$20			adc 	#$20
.018d48	4c 32 85	jmp $018532	_LPLC0:	jmp 	CharPrint
.018d4b					ListGetRange:
.018d4b	a2 0b		ldx #$0b			ldx 	#XS_Size*2-1 				; clear first 2 slots back to defaults.
.018d4d					_LGRClear:
.018d4d	a9 00		lda #$00			lda 	#0
.018d4f	95 80		sta $80,x			sta 	XS_Mantissa,x
.018d51	ca		dex				dex
.018d52	10 f9		bpl $018d4d			bpl 	_LGRClear
.018d54	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018d56	c9 00		cmp #$00			cmp 	#0 							; nothing
.018d58	f0 21		beq $018d7b			beq 	_LGRBlank
.018d5a	c9 c0		cmp #$c0			cmp 	#token_Colon 				; or colon
.018d5c	f0 1d		beq $018d7b			beq 	_LGRBlank
.018d5e	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma
.018d60	f0 18		beq $018d7a			beq 	_LGREnd 					; then it's LIST ,x
.018d62	20 92 91	jsr $019192			jsr 	EvaluateInteger 			; get the first number into bottom
.018d65	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018d67	c9 bf		cmp #$bf			cmp 	#token_Comma
.018d69	f0 0f		beq $018d7a			beq 	_LGREnd 					; then it is LIST a,b
.018d6b	a5 80		lda $80				lda 	XS_Mantissa+0 				; copy first to second LIST n is n,n
.018d6d	85 86		sta $86				sta 	XS_Mantissa+XS_Size+0
.018d6f	a5 81		lda $81				lda 	XS_Mantissa+1
.018d71	85 87		sta $87				sta 	XS_Mantissa+XS_Size+1
.018d73					_LGRBumpExit:
.018d73	e6 86		inc $86				inc 	XS_Mantissa+XS_Size 		; bump it so we can use cc.
.018d75	d0 02		bne $018d79			bne 	_LGRBump2
.018d77	e6 87		inc $87				inc 	XS_Mantissa+XS_Size+1
.018d79					_LGRBump2:
.018d79	60		rts				rts
.018d7a					_LGREnd:
.018d7a	c8		iny				iny
.018d7b					_LGRBlank:
.018d7b	a9 ff		lda #$ff			lda 	#$FF 						; default to the end.
.018d7d	85 86		sta $86				sta 	XS_Mantissa+XS_Size
.018d7f	85 87		sta $87				sta 	XS_Mantissa+XS_Size+1
.018d81	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018d83	c9 00		cmp #$00			cmp 	#0
.018d85	f0 f2		beq $018d79			beq 	_LGRBump2
.018d87	0a		asl a				asl 	a 							; if not a number, then exit (to end)
.018d88	b0 ef		bcs $018d79			bcs 	_LGRBump2
.018d8a	a2 06		ldx #$06			ldx 	#XS_Size 					; get to range
.018d8c	20 94 91	jsr $019194			jsr 	EvaluateIntegerX
.018d8f	80 e2		bra $018d73			bra 	_LGRBumpExit
.018d91	60		rts				rts
.018d92					ListCheckRange:
.018d92	c8		iny				iny
.018d93	a2 00		ldx #$00			ldx 	#0 							; test low
.018d95	20 a2 8d	jsr $018da2			jsr 	_LCRCompare
.018d98	90 06		bcc $018da0			bcc 	_LCRFail
.018d9a	a2 06		ldx #$06			ldx 	#XS_Size 					; test high
.018d9c	20 a2 8d	jsr $018da2			jsr 	_LCRCompare
.018d9f	60		rts				rts
.018da0					_LCRFail:
.018da0	38		sec				sec
.018da1	60		rts				rts
.018da2					_LCRCompare:
.018da2	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018da4	38		sec				sec
.018da5	f5 80		sbc $80,x			sbc	 	XS_Mantissa+0,x
.018da7	08		php				php
.018da8	c8		iny				iny
.018da9	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018dab	28		plp				plp
.018dac	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.018dae	08		php				php
.018daf	88		dey				dey
.018db0	28		plp				plp
.018db1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/print.asm

.018db2					Command_PRINT:
.018db2	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018db4	c9 00		cmp #$00			cmp 	#0 							; end
.018db6	f0 70		beq $018e28			beq 	_CPR_NewLine
.018db8	c9 c0		cmp #$c0			cmp 	#token_Colon
.018dba	f0 6c		beq $018e28			beq 	_CPR_NewLine
.018dbc	c9 c1		cmp #$c1			cmp 	#token_SemiColon
.018dbe	f0 5b		beq $018e1b			beq 	_CPR_Skip
.018dc0	c9 bf		cmp #$bf			cmp 	#token_Comma
.018dc2	f0 49		beq $018e0d			beq 	_CPR_Tab
.018dc4	20 fc 8f	jsr $018ffc			jsr 	EvaluateExpression 			; get expression.
.018dc7	a5 85		lda $85				lda 	XS_Type 					; get type.
.018dc9	29 02		and #$02			and 	#2
.018dcb	d0 24		bne $018df1			bne 	_CPR_String 				; if type = 2 output as string.
.018dcd					_CPR_Number:
.018dcd	a9 00		lda #$00			lda 	#0 							; reset buffer index
.018dcf	8d 14 03	sta $0314			sta 	NumBufX
.018dd2	a5 85		lda $85				lda 	XS_Type 					; get type
.018dd4	4a		lsr a				lsr 	a
.018dd5	b0 05		bcs $018ddc			bcs 	_CPRInt 					; if msb set do as integer
.018dd7	20 d1 a2	jsr $01a2d1			jsr 	FPToString 					; call fp to str otherwise
.018dda	80 03		bra $018ddf			bra 	_CPRNPrint
.018ddc	20 59 9d	jsr $019d59	_CPRInt:jsr 	IntToString
.018ddf					_CPRNPrint:
.018ddf	ad 15 03	lda $0315			lda 	Num_Buffer 					; is first character -
.018de2	c9 2d		cmp #$2d			cmp 	#"-"
.018de4	f0 05		beq $018deb			beq 	_CPRNoSpace
.018de6	a9 20		lda #$20			lda 	#" "						; print the leading space
.018de8	20 32 85	jsr $018532			jsr 	CharPrint 					; so beloved of MS Basics.
.018deb					_CPRNoSpace:
.018deb	a2 14		ldx #$14			ldx 	#(Num_Buffer-1) & $FF
.018ded	a9 03		lda #$03			lda 	#(Num_Buffer-1) >> 8
.018def	80 04		bra $018df5			bra 	_CPRPrint
.018df1					_CPR_String:
.018df1	a6 80		ldx $80				ldx 	XS_Mantissa
.018df3	a5 81		lda $81				lda 	XS_Mantissa+1
.018df5					_CPRPrint:
.018df5	86 1e		stx $1e				stx 	zGenPtr
.018df7	85 1f		sta $1f				sta 	zGenPtr+1
.018df9	5a		phy				phy
.018dfa	a0 00		ldy #$00			ldy 	#0							; get length into X
.018dfc	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018dfe	aa		tax				tax
.018dff	f0 09		beq $018e0a			beq 	_CPREndPrint 				; nothing to print
.018e01					_CPRLoop:
.018e01	c8		iny				iny
.018e02	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018e04	20 32 85	jsr $018532			jsr 	CharPrint
.018e07	ca		dex				dex
.018e08	d0 f7		bne $018e01			bne 	_CPRLoop
.018e0a					_CPREndPrint:
.018e0a	7a		ply				ply
.018e0b	80 a5		bra $018db2			bra 	Command_Print
.018e0d					_CPR_Tab:
.018e0d	20 3b 85	jsr $01853b			jsr 	CharGetPosition 			; print until position % 8 = 0
.018e10	29 07		and #$07			and 	#7
.018e12	f0 07		beq $018e1b			beq 	_CPR_Skip
.018e14	a9 20		lda #$20			lda 	#" "
.018e16	20 32 85	jsr $018532			jsr 	CharPrint
.018e19	80 f2		bra $018e0d			bra 	_CPR_Tab
.018e1b					_CPR_Skip:
.018e1b	c8		iny				iny
.018e1c	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e1e	c9 c0		cmp #$c0			cmp 	#token_Colon 				; colon or $00, exit
.018e20	f0 09		beq $018e2b			beq 	_CPR_Exit
.018e22	c9 00		cmp #$00			cmp 	#0
.018e24	d0 8c		bne $018db2			bne 	Command_PRINT 				; if not go round again.
.018e26	80 03		bra $018e2b			bra 	_CPR_Exit
.018e28					_CPR_NewLine:
.018e28	20 4f 80	jsr $01804f			jsr 	IFT_NewLine
.018e2b					_CPR_Exit:
.018e2b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/assert.asm

.018e2c					Command_ASSERT:
.018e2c	20 92 91	jsr $019192			jsr 	EvaluateInteger 			; calculate thing being asserted
.018e2f	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; check if true (non-zero)
.018e31	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.018e33	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.018e35	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.018e37	f0 01		beq $018e3a			beq 	_ASFail
.018e39	60		rts				rts
.018e3a					_ASFail:
.018e3a	20 6e 85	jsr $01856e			jsr ERR_Handler
>018e3d	41 73 73 65 72 74 00			.text "Assert",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/poke.asm

.018e44					Command_POKE:
.018e44	a9 01		lda #$01			lda 	#1
.018e46	80 06		bra $018e4e			bra 	CmdPoke_Main
.018e48					Command_DOKE:
.018e48	a9 02		lda #$02			lda 	#2
.018e4a	80 02		bra $018e4e			bra 	CmdPoke_Main
.018e4c					Command_LOKE:
.018e4c	a9 04		lda #$04			lda 	#4
.018e4e					CmdPoke_Main:
.018e4e	48		pha				pha
.018e4f	20 92 91	jsr $019192			jsr 	EvaluateInteger 			; get two parameters.
.018e52	e8		inx				inx
.018e53	e8		inx				inx
.018e54	e8		inx				inx
.018e55	e8		inx				inx
.018e56	e8		inx				inx
.018e57	e8		inx				inx
.018e58	20 de 97	jsr $0197de			jsr 	CheckNextComma
.018e5b	20 94 91	jsr $019194			jsr 	EvaluateIntegerX
.018e5e	a5 80		lda $80				lda 	XS_Mantissa+0 			; copy the mantissa into ZLTemp1 (address)
.018e60	85 1a		sta $1a				sta 	zLTemp1
.018e62	a5 81		lda $81				lda 	XS_Mantissa+1
.018e64	85 1b		sta $1b				sta 	zLTemp1+1
.018e66	a5 82		lda $82				lda 	XS_Mantissa+2
.018e68	85 1c		sta $1c				sta 	zLTemp1+2
.018e6a	a5 83		lda $83				lda 	XS_Mantissa+3
.018e6c	85 1d		sta $1d				sta 	zLTemp1+3
.018e6e	68		pla				pla 								; get count
.018e6f	5a		phy				phy 								; save Y
.018e70	20 69 97	jsr $019769			jsr 	MemWrite 					; write it out
.018e73	7a		ply				ply 								; restore Y and done.
.018e74	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/newold.asm

.018e75					Command_NEW:
.018e75	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018e77	85 16		sta $16				sta 	zCodePtr+0
.018e79	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018e7b	85 17		sta $17				sta 	zCodePtr+1
.018e7d	a9 00		lda #$00			lda 	#0
.018e7f	85 18		sta $18				sta 	zCodePtr+2
.018e81	85 19		sta $19				sta 	zCodePtr+3
.018e83	a0 03		ldy #$03			ldy 	#3
.018e85	a0 00		ldy #$00			ldy 	#0
.018e87	a9 00		lda #$00			lda 	#0 							; write a 0 there.
.018e89	97 16		sta [$16],y			sta 	[zCodePtr],y
.018e8b	20 7a 97	jsr $01977a			jsr 	UpdateProgramEnd 			; update program end.
.018e8e	4c 27 88	jmp $018827			jmp 	WarmStart
.018e91					Command_OLD:
.018e91	ea		nop				nop
.018e92	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018e94	85 16		sta $16				sta 	zCodePtr+0
.018e96	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018e98	85 17		sta $17				sta 	zCodePtr+1
.018e9a	a9 00		lda #$00			lda 	#0
.018e9c	85 18		sta $18				sta 	zCodePtr+2
.018e9e	85 19		sta $19				sta 	zCodePtr+3
.018ea0	a0 03		ldy #$03			ldy 	#3
.018ea2					_COL_Find:
.018ea2	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018ea4	c8		iny				iny
.018ea5	c9 00		cmp #$00			cmp 	#0 							; if zero, then the position Y/Z is new offset
.018ea7	f0 18		beq $018ec1			beq 	_COL_Found
.018ea9	98		tya				tya
.018eaa	c9 00		cmp #$00			cmp 	#0
.018eac	d0 f4		bne $018ea2			bne 	_COL_Find 					; can't find old EOL, give up.
.018eae	20 6e 85	jsr $01856e			jsr ERR_Handler
>018eb1	50 72 6f 67 72 61 6d 20			.text "Program Corrupt",0
>018eb9	43 6f 72 72 75 70 74 00
.018ec1					_COL_Found:
.018ec1	98		tya				tya
.018ec2	48		pha				pha
.018ec3	a0 00		ldy #$00			ldy 	#0
.018ec5	68		pla				pla
.018ec6	97 16		sta [$16],y			sta 	[zCodePtr],y
.018ec8	20 7a 97	jsr $01977a			jsr 	UpdateProgramEnd 			; reset variable pointer
.018ecb	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/branch.asm

.018ecc					Command_GOTO:
.018ecc	20 21 8f	jsr $018f21			jsr 	GotoGetLineNumber
.018ecf					CmdGOTO:
.018ecf	a2 00		ldx #$00			ldx 	#0
.018ed1	4c 3e 8f	jmp $018f3e			jmp 	GotoChangeToLineNumberX
.018ed4					Command_GOSUB:
.018ed4	20 21 8f	jsr $018f21			jsr 	GotoGetLineNumber
.018ed7					CmdGOSUB:
.018ed7	20 f9 84	jsr $0184f9			jsr 	StackSavePosition
.018eda	a9 15		lda #$15			lda 	#(SMark_Gosub << 4)+SourcePosSize
.018edc	20 b2 84	jsr $0184b2			jsr 	StackPushFrame
.018edf	a2 00		ldx #$00			ldx		#0
.018ee1	4c 3e 8f	jmp $018f3e			jmp 	GotoChangeToLineNumberX
.018ee4					Command_RETURN:
.018ee4	a9 10		lda #$10			lda 	#(SMark_Gosub << 4)
.018ee6	20 c9 84	jsr $0184c9			jsr 	StackPopFrame
.018ee9	20 16 85	jsr $018516			jsr 	StackRestorePosition
.018eec	60		rts				rts
.018eed					Command_ON:
.018eed	a2 00		ldx #$00			ldx 	#0 							; get the ON.
.018eef	20 2e 96	jsr $01962e			jsr 	SLIByteParameter
.018ef2	a5 80		lda $80				lda 	XS_Mantissa+0 				; get the count
.018ef4	f0 28		beq $018f1e			beq 	_CONFail 					; can't be zero.
.018ef6	aa		tax				tax 								; save in X.
.018ef7	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018ef9	c8		iny				iny
.018efa	48		pha				pha
.018efb	c9 cc		cmp #$cc			cmp 	#token_GOTO 				; must be GOTO or GOSUB
.018efd	f0 07		beq $018f06			beq 	_CONOkayToken
.018eff	c9 ca		cmp #$ca			cmp 	#token_GOSUB
.018f01	f0 03		beq $018f06			beq 	_CONOkayToken
.018f03	4c 3f 85	jmp $01853f			jmp 	SyntaxError
.018f06					_CONOkayToken:
.018f06	da		phx				phx 								; count on top, GOTO/GOSUB token 2nd.
.018f07					_CONFindNumber:
.018f07	20 21 8f	jsr $018f21			jsr 	GotoGetLineNumber 			; get a line number.
.018f0a	fa		plx				plx 								; restore count
.018f0b	ca		dex				dex  								; decrement, exit if zero.
.018f0c	f0 06		beq $018f14			beq 	_CONFound
.018f0e	da		phx				phx 								; push back
.018f0f	20 de 97	jsr $0197de			jsr 	CheckNextComma				; check for comma
.018f12	80 f3		bra $018f07			bra 	_CONFindNumber
.018f14					_CONFound:
.018f14	68		pla				pla 								; get token
.018f15	c9 cc		cmp #$cc			cmp 	#token_GOTO 				; if GOTO
.018f17	f0 b6		beq $018ecf			beq		CmdGOTO 					; then just branch.
.018f19	20 80 84	jsr $018480			jsr 	SkipEndOfCommand 			; go to end of command
.018f1c	80 b9		bra $018ed7			bra 	CmdGOSUB 					; and do a GOSUB.
.018f1e					_CONFail:
.018f1e	4c 5d 85	jmp $01855d			jmp 	BadParamError
.018f21					GotoGetLineNumber:
.018f21	20 92 91	jsr $019192			jsr 	EvaluateInteger
.018f24	a5 82		lda $82				lda 	XS_Mantissa+2 				; check range
.018f26	05 83		ora $83				ora 	XS_Mantissa+3
.018f28	d0 01		bne $018f2b			bne 	_GLINError
.018f2a	60		rts				rts
.018f2b					_GLINError:
.018f2b	20 6e 85	jsr $01856e			jsr ERR_Handler
>018f2e	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>018f36	20 4e 75 6d 62 65 72 00
.018f3e					GotoChangeToLineNumberX:
.018f3e	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check line number not zero
.018f40	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.018f42	f0 37		beq $018f7b			beq 	_GCTLFail
.018f44	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018f46	85 16		sta $16				sta 	zCodePtr+0
.018f48	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018f4a	85 17		sta $17				sta 	zCodePtr+1
.018f4c	a9 00		lda #$00			lda 	#0
.018f4e	85 18		sta $18				sta 	zCodePtr+2
.018f50	85 19		sta $19				sta 	zCodePtr+3
.018f52	a0 03		ldy #$03			ldy 	#3
.018f54					_GCTLLoop:
.018f54	a0 00		ldy #$00			ldy 	#0
.018f56	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018f58	c9 00		cmp #$00			cmp 	#0
.018f5a	f0 1f		beq $018f7b			beq 	_GCTLFail
.018f5c	c8		iny				iny
.018f5d	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018f5f	d5 80		cmp $80,x			cmp 	XS_Mantissa+0,x
.018f61	d0 07		bne $018f6a			bne 	_GCTLNext
.018f63	c8		iny				iny
.018f64	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018f66	d5 81		cmp $81,x			cmp 	XS_Mantissa+1,x
.018f68	f0 0f		beq $018f79			beq 	_GCTLExit
.018f6a					_GCTLNext:
.018f6a	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018f6c	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.018f6e	18		clc				clc
.018f6f	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018f71	85 16		sta $16				sta 	zCodePtr
.018f73	90 02		bcc $018f77			bcc 	_SNLNoCarry
.018f75	e6 17		inc $17				inc 	zCodePtr+1
.018f77					_SNLNoCarry:
.018f77	80 db		bra $018f54			bra 	_GCTLLoop 					; try next line.
.018f79					_GCTLExit:
.018f79	c8		iny				iny
.018f7a	60		rts				rts
.018f7b					_GCTLFail:
.018f7b	20 6e 85	jsr $01856e			jsr ERR_Handler
>018f7e	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>018f86	20 4e 75 6d 62 65 72 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.018f8e					Command_CLR:
.018f8e					ResetRunStatus:
.018f8e	20 b3 98	jsr $0198b3			jsr 	VariableClear
.018f91	20 a0 84	jsr $0184a0			jsr 	StackReset
.018f94	a9 00		lda #$00			lda 	#HighMemory & $FF
.018f96	8d 00 03	sta $0300			sta 	StringPtr
.018f99	a9 7f		lda #$7f			lda 	#HighMemory >> 8
.018f9b	8d 01 03	sta $0301			sta 	StringPtr+1
.018f9e	20 7d 9a	jsr $019a7d			jsr 	ArrayResetDefault
.018fa1	20 e2 8a	jsr $018ae2			jsr 	Command_RESTORE
.018fa4	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/stop.asm

.018fa5					Command_STOP:
.018fa5	20 6e 85	jsr $01856e			jsr ERR_Handler
>018fa8	53 74 6f 70 00				.text "Stop",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/while.asm

.018fad					Command_WHILE:
.018fad	20 f9 84	jsr $0184f9			jsr 	StackSavePosition			; save position into stack, but don't yet push.
.018fb0	20 92 91	jsr $019192			jsr 	EvaluateInteger 			; calculate the while loop value.
.018fb3	a5 80		lda $80				lda 	XS_Mantissa+0				; check the result if zero
.018fb5	05 81		ora $81				ora 	XS_Mantissa+1
.018fb7	05 82		ora $82				ora 	XS_Mantissa+2
.018fb9	05 83		ora $83				ora 	XS_Mantissa+3
.018fbb	f0 06		beq $018fc3			beq 	_CWHSkip 					; if it is zero, then skip to WEND.
.018fbd	a9 35		lda #$35			lda 	#(SMark_While << 4)+SourcePosSize
.018fbf	20 b2 84	jsr $0184b2			jsr 	StackPushFrame 				; push on stack
.018fc2	60		rts				rts
.018fc3					_CWHSkip:
.018fc3	a9 95		lda #$95			lda 	#token_Wend 				; look for the WEND token.
.018fc5	20 f3 83	jsr $0183f3			jsr 	StructureSearchSingle
.018fc8	c8		iny				iny
.018fc9	60		rts				rts
.018fca					Command_WEND:
.018fca	a9 30		lda #$30			lda 	#(SMark_While << 4)			; remove the frame
.018fcc	20 c9 84	jsr $0184c9			jsr 	StackPopFrame
.018fcf	20 16 85	jsr $018516			jsr 	StackRestorePosition
.018fd2	80 d9		bra $018fad			bra 	Command_WHILE 				; and do the while again.
.018fd4	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/repeat.asm

.018fd5					Command_REPEAT:
.018fd5	20 f9 84	jsr $0184f9			jsr 	StackSavePosition			; save position into stack
.018fd8	a9 25		lda #$25			lda 	#(SMark_Repeat << 4)+SourcePosSize
.018fda	20 b2 84	jsr $0184b2			jsr 	StackPushFrame 				; push on stack
.018fdd	60		rts				rts
.018fde					Command_UNTIL:
.018fde	a9 20		lda #$20			lda 	#(SMark_Repeat << 4)		; remove the frame
.018fe0	20 c9 84	jsr $0184c9			jsr 	StackPopFrame
.018fe3	20 92 91	jsr $019192			jsr 	EvaluateInteger				; work out UNTIL
.018fe6	a5 80		lda $80				lda 	XS_Mantissa+0 				; check if zero.
.018fe8	05 81		ora $81				ora 	XS_Mantissa+1
.018fea	05 82		ora $82				ora 	XS_Mantissa+2
.018fec	05 83		ora $83				ora 	XS_Mantissa+3
.018fee	d0 08		bne $018ff8			bne 	_CUTExit 					; if not, just exit
.018ff0	20 16 85	jsr $018516			jsr 	StackRestorePosition 		; otherwise loop round again.
.018ff3	a9 25		lda #$25			lda 	#(SMark_Repeat << 4)+SourcePosSize
.018ff5	20 b2 84	jsr $0184b2			jsr 	StackPushFrame 				; fix the stack back.
.018ff8					_CUTExit:
.018ff8	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.018ff9					EVESyntax:
.018ff9	4c 3f 85	jmp $01853f			jmp 	SyntaxError
.018ffc					EvaluateExpression:
.018ffc	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.018ffe					EvaluateExpressionX:
.018ffe	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.019000					EvaluateExpressionXA:
.019000	48		pha				pha 								; save precedence on stack.
.019001	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019003	f0 f4		beq $018ff9			beq 	EVESyntax 					; end of line, syntax error.
.019005	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.019007	b0 03		bcs $01900c			bcs 	_EVNotVariable
.019009	4c d6 90	jmp $0190d6			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.01900c					_EVNotVariable:
.01900c	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.01900e	90 e9		bcc $018ff9			bcc 	EVESyntax
.019010	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.019012	b0 58		bcs $01906c			bcs 	_EVNotInteger
.019014	20 04 91	jsr $019104			jsr 	EvaluateGetInteger
.019017					_EVCheckDecimal:
.019017	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019019	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.01901b	d0 05		bne $019022			bne 	_EVGotAtom 					; no, get atom.
.01901d					_EVIsDecimal:
.01901d	20 2a 91	jsr $01912a			jsr 	EVGetDecimal 				; extend to the decimal part.
.019020	80 00		bra $019022			bra 	_EVGotAtom 					; and continue to got atom.
.019022					_EVGotAtom:
.019022	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019024	10 44		bpl $01906a			bpl 	_EVExitDrop 				; must be a token.
.019026	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.019028	b0 40		bcs $01906a			bcs 	_EVExitDrop
.01902a	68		pla				pla 								; get current precedence
.01902b	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.01902d	da		phx				phx 								; save X
.01902e	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019030	aa		tax				tax 								; put in X
.019031	bf 23 86 01	lda $018623,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.019035	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.019037	fa		plx				plx 								; restore X
.019038	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.01903a	90 2f		bcc $01906b			bcc 	_EVExit 					; exit if too low.
.01903c	f0 2d		beq $01906b			beq 	_EVExit 					; exit if equals
.01903e	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.019040	48		pha				pha
.019041	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019043	48		pha				pha
.019044	c8		iny				iny
.019045	da		phx				phx 								; save current position
.019046	e8		inx				inx
.019047	e8		inx				inx
.019048	e8		inx				inx
.019049	e8		inx				inx
.01904a	e8		inx				inx
.01904b	e8		inx				inx
.01904c	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.01904e	20 00 90	jsr $019000			jsr 	EvaluateExpressionXA 		; do the RHS.
.019051	fa		plx				plx 								; restore X
.019052	68		pla				pla 								; get the binary operator in A.
.019053					_EVCallA:
.019053	da		phx				phx 								; save X again
.019054	0a		asl a				asl 	a 							; double, lose the MSB.
.019055	aa		tax				tax									; put in X
.019056	bf d2 85 01	lda $0185d2,x			lda 	VectorTable,x 				; copy address into zGenPtr
.01905a	8d 11 03	sta $0311			sta 	LocalVector+1
.01905d	bf d3 85 01	lda $0185d3,x			lda 	VectorTable+1,x
.019061	8d 12 03	sta $0312			sta 	LocalVector+2
.019064	fa		plx				plx 								; restore X
.019065	20 df 90	jsr $0190df			jsr 	EVCallLocalVector
.019068	80 b8		bra $019022			bra 	_EVGotAtom 					; and loop back.
.01906a					_EVExitDrop:
.01906a	68		pla				pla
.01906b					_EVExit:
.01906b	60		rts				rts
.01906c					_EVNotInteger:
.01906c	c8		iny				iny
.01906d	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.01906f	d0 16		bne $019087			bne 	_EVNotMinus
.019071	20 73 91	jsr $019173			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.019074	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.019076	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.019078	f0 05		beq $01907f			beq 	_EVMinusFloat
.01907a	20 3c 9d	jsr $019d3c			jsr 	IntegerNegateAlways 		; negation
.01907d	80 a3		bra $019022			bra 	_EVGotAtom 					; and go back.
.01907f					_EVMinusFloat:
.01907f	b5 85		lda $85,x			lda 	XS_Type,x 					; invert the sign bit.
.019081	49 80		eor #$80			eor 	#$80
.019083	95 85		sta $85,x			sta 	XS_Type,x
.019085	80 9b		bra $019022			bra 	_EVGotAtom
.019087					_EVNotMinus:
.019087	c9 bd		cmp #$bd			cmp 	#token_lparen 				; is it left parenthesis
.019089	d0 17		bne $0190a2			bne 	_EVNotParenthesis
.01908b	20 fe 8f	jsr $018ffe			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.01908e	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019090	c8		iny				iny
.019091	c9 be		cmp #$be			cmp 	#token_rparen 				; okay if right bracket.
.019093	f0 8d		beq $019022			beq 	_EVGotAtom
.019095	20 6e 85	jsr $01856e			jsr ERR_Handler
>019098	4d 69 73 73 69 6e 67 20			.text "Missing )",0
>0190a0	29 00
.0190a2					_EVNotParenthesis:
.0190a2	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.0190a4	d0 0c		bne $0190b2			bne 	_EVNotNot
.0190a6	20 73 91	jsr $019173			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.0190a9	20 d2 a1	jsr $01a1d2			jsr 	FPUToInteger 				; make it an integer - if possible.
.0190ac	20 58 91	jsr $019158			jsr 	NotInteger 					; do the not calculation
.0190af	4c 22 90	jmp $019022			jmp 	_EVGotAtom
.0190b2					_EVNotNot:
.0190b2	c9 fe		cmp #$fe			cmp 	#$FE
.0190b4	d0 12		bne $0190c8			bne 	_EVNotString
.0190b6	20 51 98	jsr $019851			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.0190b9	a5 20		lda $20				lda 	zTempStr 					; copy address of string into mantissa
.0190bb	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0190bd	a5 21		lda $21				lda 	zTempStr+1
.0190bf	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0190c1	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.0190c3	95 85		sta $85,x			sta 	XS_Type,x
.0190c5	4c 22 90	jmp $019022			jmp 	_EVGotAtom
.0190c8					_EVNotString:
.0190c8	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.0190ca	90 04		bcc $0190d0			bcc 	_EVBadElement
.0190cc	c9 b7		cmp #$b7			cmp 	#lastUnaryFunction+1
.0190ce	90 03		bcc $0190d3			bcc 	_EVUnaryFunction
.0190d0					_EVBadElement:
.0190d0	4c 3f 85	jmp $01853f			jmp 	SyntaxError
.0190d3					_EVUnaryFunction:
.0190d3	4c 53 90	jmp $019053			jmp 	_EVCallA
.0190d6					_EVVariableHandler:
.0190d6	20 77 98	jsr $019877			jsr 	VariableFind 				; locate a variable
.0190d9	20 bf 9b	jsr $019bbf			jsr 	VariableGet 				; copy into memory.
.0190dc	4c 22 90	jmp $019022			jmp 	_EVGotAtom 					; and go round.
.0190df					EVCallLocalVector:
.0190df	6c 11 03	jmp ($0311)			jmp 	(LocalVector+1)
.0190e2					EVShiftMantissaLeft6:
.0190e2	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.0190e4	95 84		sta $84,x			sta 	XS_Exponent,x
.0190e6	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0190e8	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0190ea	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0190ec	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0190ee	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0190f0	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0190f2	a9 00		lda #$00			lda 	#0
.0190f4	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0190f6	20 f9 90	jsr $0190f9			jsr 	_EVSMLShift 					; call it here to do it twice
.0190f9					_EVSMLShift:
.0190f9	56 84		lsr $84,x			lsr 	XS_Exponent,x
.0190fb	76 83		ror $83,x			ror 	XS_Mantissa+3,x
.0190fd	76 82		ror $82,x			ror 	XS_Mantissa+2,x
.0190ff	76 81		ror $81,x			ror 	XS_Mantissa+1,x
.019101	76 80		ror $80,x			ror 	XS_Mantissa+0,x
.019103	60		rts				rts
.019104					EvaluateGetInteger:
.019104	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019106	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.019108	95 80		sta $80,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.01910a	a9 00		lda #$00			lda 	#0
.01910c	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01910e	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019110	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019112	1a		inc a				inc 	a 							; set to type 1 (integer)
.019113	95 85		sta $85,x			sta 	XS_Type,x
.019115					_EVCheckNextInteger:
.019115	c8		iny				iny
.019116	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019118	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.01911a	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.01911c	b0 0b		bcs $019129			bcs 	_EVEndInteger
.01911e	48		pha				pha 								; save it.
.01911f	20 e2 90	jsr $0190e2			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.019122	68		pla				pla
.019123	15 80		ora $80,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.019125	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019127	80 ec		bra $019115			bra 	_EVCheckNextInteger
.019129					_EVEndInteger:
.019129	60		rts				rts
.01912a					EVGetDecimal:
.01912a	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.01912c	8d 15 03	sta $0315			sta 	Num_Buffer
.01912f	da		phx				phx
.019130	c8		iny				iny
.019131	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019133	c8		iny				iny
.019134	3a		dec a				dec 	a								; convert to a string length.
.019135	3a		dec a				dec 	a
.019136	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.019138					_EVGDCopy:
.019138	48		pha				pha 									; save count
.019139	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01913b	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.01913e	e8		inx				inx 									; forward ....
.01913f	c8		iny				iny
.019140	68		pla				pla 									; get count
.019141	3a		dec a				dec 	a 								; until zero
.019142	d0 f4		bne $019138			bne 	_EVGDCopy
.019144	9d 15 03	sta $0315,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.019147	fa		plx				plx 									; restore X
.019148	a9 15		lda #$15			lda 	#Num_Buffer & $FF 				; set zGenPtr
.01914a	85 1e		sta $1e				sta 	zGenPtr
.01914c	a9 03		lda #$03			lda 	#Num_Buffer >> 8
.01914e	85 1f		sta $1f				sta 	zGenPtr+1
.019150	5a		phy				phy 									; save Y
.019151	a0 00		ldy #$00			ldy 	#0 								; start position
.019153	20 8c a3	jsr $01a38c			jsr 	FPFromString 					; convert current
.019156	7a		ply				ply 									; restore Y
.019157	60		rts				rts
.019158					NotInteger:
.019158	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01915a	49 ff		eor #$ff			eor 	#$FF
.01915c	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01915e	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019160	49 ff		eor #$ff			eor 	#$FF
.019162	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019164	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019166	49 ff		eor #$ff			eor 	#$FF
.019168	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01916a	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01916c	49 ff		eor #$ff			eor 	#$FF
.01916e	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019170	60		rts				rts
.019171					EvaluateGetAtom:
.019171	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.019173					EvaluateGetAtomX:
.019173	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.019175	20 00 90	jsr $019000			jsr 	EvaluateExpressionXA
.019178	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.01917a	29 0f		and #$0f			and 	#15
.01917c	c9 02		cmp #$02			cmp 	#2
.01917e	b0 01		bcs $019181			bcs 	EvaluateType
.019180	60		rts				rts
.019181					EvaluateType:
.019181	4c 4f 85	jmp $01854f			jmp 	TypeError
.019184					EvaluateNumber:
.019184	a2 00		ldx #$00			ldx 	#0
.019186					EvaluateNumberX:
.019186	20 fe 8f	jsr $018ffe			jsr 	EvaluateExpressionX
.019189	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0/1
.01918b	29 0f		and #$0f			and 	#15
.01918d	c9 02		cmp #$02			cmp 	#2
.01918f	b0 f0		bcs $019181			bcs 	EvaluateType
.019191	60		rts				rts
.019192					EvaluateInteger:
.019192	a2 00		ldx #$00			ldx 	#0
.019194					EvaluateIntegerX:
.019194	20 86 91	jsr $019186			jsr 	EvaluateNumberX
.019197	20 d2 a1	jsr $01a1d2			jsr 	FPUToInteger
.01919a	60		rts				rts
.01919b					EvaluateString:
.01919b	a2 00		ldx #$00			ldx 	#0
.01919d					EvaluateStringX:
.01919d	20 fe 8f	jsr $018ffe			jsr 	EvaluateExpressionX
.0191a0	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 2
.0191a2	29 0f		and #$0f			and 	#15
.0191a4	c9 02		cmp #$02			cmp 	#2
.0191a6	d0 d9		bne $019181			bne 	EvaluateType
.0191a8	b5 80		lda $80,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.0191aa	85 1e		sta $1e				sta 	zGenPtr
.0191ac	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0191ae	85 1f		sta $1f				sta 	zGenPtr+1
.0191b0	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.0191b1					BinaryOp_And:
.0191b1	20 05 92	jsr $019205			jsr 	BinaryMakeBothInteger
.0191b4	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.0191b6	35 86		and $86,x			and 	XS2_Mantissa+0,x
.0191b8	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0191ba	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.0191bc	35 87		and $87,x			and 	XS2_Mantissa+1,x
.0191be	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0191c0	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.0191c2	35 88		and $88,x			and 	XS2_Mantissa+2,x
.0191c4	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0191c6	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.0191c8	35 89		and $89,x			and 	XS2_Mantissa+3,x
.0191ca	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0191cc	60		rts				rts
.0191cd					BinaryOp_Or:
.0191cd	20 05 92	jsr $019205			jsr 	BinaryMakeBothInteger
.0191d0	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.0191d2	15 86		ora $86,x			ora 	XS2_Mantissa+0,x
.0191d4	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0191d6	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.0191d8	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.0191da	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0191dc	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.0191de	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.0191e0	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0191e2	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.0191e4	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.0191e6	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0191e8	60		rts				rts
.0191e9					BinaryOp_Eor:
.0191e9					BinaryOp_Xor:
.0191e9	20 05 92	jsr $019205			jsr 	BinaryMakeBothInteger
.0191ec	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.0191ee	55 86		eor $86,x			eor 	XS2_Mantissa+0,x
.0191f0	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0191f2	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.0191f4	55 87		eor $87,x			eor 	XS2_Mantissa+1,x
.0191f6	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0191f8	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.0191fa	55 88		eor $88,x			eor 	XS2_Mantissa+2,x
.0191fc	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0191fe	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.019200	55 89		eor $89,x			eor 	XS2_Mantissa+3,x
.019202	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019204	60		rts				rts
.019205					BinaryMakeBothInteger:
.019205	da		phx				phx 								; save X
.019206	e8		inx				inx
.019207	e8		inx				inx
.019208	e8		inx				inx
.019209	e8		inx				inx
.01920a	e8		inx				inx
.01920b	e8		inx				inx
.01920c	20 10 92	jsr $019210			jsr 	BinaryMakeInteger 			; convert to integer.
.01920f	fa		plx				plx 								; restore X and fall through.
.019210					BinaryMakeInteger:
.019210	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.019212	29 0f		and #$0f			and 	#15 						; check type zero
.019214	f0 04		beq $01921a			beq 	_BMIConvert 				; if float convert to integer.
.019216	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.019217	90 04		bcc $01921d			bcc 	_BMIError
.019219	60		rts				rts
.01921a					_BMIConvert:
.01921a	4c d2 a1	jmp $01a1d2			jmp 	FPUToInteger 				; convert to integer
.01921d					_BMIError:
.01921d	4c 4f 85	jmp $01854f			jmp 	TypeError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.019220					Binary_Equal:
.019220	20 67 92	jsr $019267			jsr 	CompareValues
.019223	09 00		ora #$00			ora 	#0
.019225	f0 04		beq $01922b			beq 	CCTrue
.019227	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.019229	80 02		bra $01922d			bra 	CCWrite
.01922b	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.01922d	95 80		sta $80,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.01922f	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019231	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019233	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019235	a9 01		lda #$01			lda 	#1
.019237	95 85		sta $85,x			sta 	XS_Type,x 					; set type to integer whatever.
.019239	60		rts				rts
.01923a					Binary_NotEqual:
.01923a	20 67 92	jsr $019267			jsr 	CompareValues
.01923d	09 00		ora #$00			ora 	#0
.01923f	f0 e6		beq $019227			beq 	CCFalse
.019241	80 e8		bra $01922b			bra 	CCTrue
.019243					Binary_Less:
.019243	20 67 92	jsr $019267			jsr 	CompareValues
.019246	09 00		ora #$00			ora 	#0
.019248	30 e1		bmi $01922b			bmi 	CCTrue
.01924a	80 db		bra $019227			bra 	CCFalse
.01924c					Binary_LessEqual:
.01924c	20 67 92	jsr $019267			jsr 	CompareValues
.01924f	c9 01		cmp #$01			cmp 	#1
.019251	d0 d8		bne $01922b			bne 	CCTrue
.019253	80 d2		bra $019227			bra 	CCFalse
.019255					Binary_GreaterEqual:
.019255	20 67 92	jsr $019267			jsr 	CompareValues
.019258	09 00		ora #$00			ora 	#0
.01925a	10 cf		bpl $01922b			bpl 	CCTrue
.01925c	80 c9		bra $019227			bra 	CCFalse
.01925e					Binary_Greater:
.01925e	20 67 92	jsr $019267			jsr 	CompareValues
.019261	c9 01		cmp #$01			cmp 	#1
.019263	f0 c6		beq $01922b			beq 	CCTrue
.019265	80 c0		bra $019227			bra 	CCFalse
.019267					CompareValues:
.019267	b5 85		lda $85,x			lda 	XS_Type,x 					; and the types together
.019269	35 8b		and $8b,x			and 	XS2_Type,x
.01926b	c9 02		cmp #$02			cmp 	#2
.01926d	f0 11		beq $019280			beq 	_CVString
.01926f	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.019271	35 8b		and $8b,x			and 	XS2_Type,x
.019273	4a		lsr a				lsr 	a 							; shift bit 0 into C
.019274	90 03		bcc $019279			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.019276	4c c2 92	jmp $0192c2			jmp 	CompareInteger32 							; so execute code at \1
.019279					_BCFloat:
.019279	20 66 93	jsr $019366			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.01927c	4c cb a0	jmp $01a0cb			jmp 	FPCompare 							; and execute code at \2
.01927f	60		rts				rts
.019280					_CVString:
.019280	da		phx				phx 								; save XY
.019281	5a		phy				phy
.019282	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.019284	85 1a		sta $1a				sta		zLTemp1+0
.019286	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019288	85 1b		sta $1b				sta 	zLTemp1+1
.01928a	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.01928c	85 1c		sta $1c				sta 	zLTemp1+2
.01928e	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.019290	85 1d		sta $1d				sta 	zLTemp1+3
.019292	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.019294	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.019296	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.019298	90 02		bcc $01929c			bcc 	_CVCommon
.01929a	b1 1c		lda ($1c),y			lda 	(zLTemp1+2),y
.01929c					_CVCommon:
.01929c	aa		tax				tax 								; put shorter string length in zero.
.01929d	f0 0c		beq $0192ab			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.01929f					_CVCompare:
.01929f	c8		iny				iny 								; next character
.0192a0	b1 1a		lda ($1a),y			lda 	(zLTemp1),y 				; compare characters
.0192a2	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.0192a4	90 13		bcc $0192b9			bcc 	_CVReturnLess 				; <
.0192a6	d0 15		bne $0192bd			bne 	_CVReturnGreater 			; >
.0192a8	ca		dex				dex 								; until common length matched.
.0192a9	d0 f4		bne $01929f			bne 	_CVCompare
.0192ab					_CVMatch:
.0192ab	a0 00		ldy #$00			ldy 	#0
.0192ad	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.0192af	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.0192b1	90 06		bcc $0192b9			bcc 	_CVReturnLess 				; <
.0192b3	d0 08		bne $0192bd			bne 	_CVReturnGreater 			; >
.0192b5	a9 00		lda #$00			lda 	#0
.0192b7	80 06		bra $0192bf			bra 	_CVExit 					; same common, same length, same string
.0192b9					_CVReturnLess:
.0192b9	a9 ff		lda #$ff			lda 	#$FF
.0192bb	80 02		bra $0192bf			bra 	_CVExit
.0192bd					_CVReturnGreater:
.0192bd	a9 01		lda #$01			lda 	#$01
.0192bf					_CVExit:
.0192bf	7a		ply				ply
.0192c0	fa		plx				plx
.0192c1	60		rts				rts
.0192c2					CompareInteger32:
.0192c2	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.0192c4	49 80		eor #$80			eor 	#$80
.0192c6	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0192c8	b5 89		lda $89,x			lda 	XS2_Mantissa+3,x
.0192ca	49 80		eor #$80			eor 	#$80
.0192cc	95 89		sta $89,x			sta 	XS2_Mantissa+3,x
.0192ce	20 4c 93	jsr $01934c			jsr 	SubInteger32 				; subtraction
.0192d1	90 0d		bcc $0192e0			bcc 	_CI32Less 					; cc return -1
.0192d3	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check if zero
.0192d5	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.0192d7	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.0192d9	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.0192db	f0 02		beq $0192df			beq 	_CI32Exit
.0192dd	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.0192df					_CI32Exit:
.0192df	60		rts				rts
.0192e0					_CI32Less:
.0192e0	a9 ff		lda #$ff			lda 	#$FF
.0192e2	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.0192e3					BinaryOp_Add:
.0192e3	b5 85		lda $85,x			lda 	XS_Type,x  					; and types together
.0192e5	35 8b		and $8b,x			and 	XS2_Type,x
.0192e7	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.0192e9	d0 11		bne $0192fc			bne 	_BOAString
.0192eb	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.0192ed	35 8b		and $8b,x			and 	XS2_Type,x
.0192ef	4a		lsr a				lsr 	a 							; shift bit 0 into C
.0192f0	90 03		bcc $0192f5			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.0192f2	4c 32 93	jmp $019332			jmp 	AddInteger32 							; so execute code at \1
.0192f5					_BCFloat:
.0192f5	20 66 93	jsr $019366			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.0192f8	4c a6 9e	jmp $019ea6			jmp 	FPAdd 							; and execute code at \2
.0192fb	60		rts				rts
.0192fc					_BOAString:
.0192fc	4c 80 93	jmp $019380			jmp 	ConcatenateString 			; concatenate two strings.
.0192ff					BinaryOp_Subtract:
.0192ff	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.019301	35 8b		and $8b,x			and 	XS2_Type,x
.019303	4a		lsr a				lsr 	a 							; shift bit 0 into C
.019304	90 03		bcc $019309			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.019306	4c 4c 93	jmp $01934c			jmp 	SubInteger32 							; so execute code at \1
.019309					_BCFloat:
.019309	20 66 93	jsr $019366			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.01930c	4c 9e 9e	jmp $019e9e			jmp 	FPSubtract 							; and execute code at \2
.01930f	60		rts				rts
.019310					BinaryOp_Multiply:
.019310	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.019312	35 8b		and $8b,x			and 	XS2_Type,x
.019314	4a		lsr a				lsr 	a 							; shift bit 0 into C
.019315	90 03		bcc $01931a			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.019317	4c 77 9c	jmp $019c77			jmp 	MulInteger32 							; so execute code at \1
.01931a					_BCFloat:
.01931a	20 66 93	jsr $019366			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.01931d	4c cd 9f	jmp $019fcd			jmp 	FPMultiply 							; and execute code at \2
.019320	60		rts				rts
.019321					BinaryOp_Divide:
.019321	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.019323	35 8b		and $8b,x			and 	XS2_Type,x
.019325	4a		lsr a				lsr 	a 							; shift bit 0 into C
.019326	90 03		bcc $01932b			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.019328	4c b5 9c	jmp $019cb5			jmp 	DivInteger32 							; so execute code at \1
.01932b					_BCFloat:
.01932b	20 66 93	jsr $019366			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.01932e	4c 5a 9f	jmp $019f5a			jmp 	FPDivide 							; and execute code at \2
.019331	60		rts				rts
.019332					AddInteger32:
.019332	18		clc				clc
.019333	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019335	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.019337	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019339	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01933b	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.01933d	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01933f	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019341	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.019343	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019345	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019347	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.019349	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01934b	60		rts				rts
.01934c					SubInteger32:
.01934c	38		sec				sec
.01934d	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01934f	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.019351	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019353	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019355	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.019357	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019359	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01935b	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.01935d	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01935f	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019361	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.019363	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019365	60		rts				rts
.019366					BinaryMakeBothFloat:
.019366	da		phx				phx 								; save X
.019367	e8		inx				inx
.019368	e8		inx				inx
.019369	e8		inx				inx
.01936a	e8		inx				inx
.01936b	e8		inx				inx
.01936c	e8		inx				inx
.01936d	20 71 93	jsr $019371			jsr 	BinaryMakeFloat 			; convert to float.
.019370	fa		plx				plx 								; restore X and fall through.
.019371					BinaryMakeFloat:
.019371	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.019373	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.019374	b0 04		bcs $01937a			bcs 	_BMFConvert
.019376	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.019377	b0 04		bcs $01937d			bcs 	_BMFError
.019379	60		rts				rts
.01937a					_BMFConvert:
.01937a	4c 86 a1	jmp $01a186			jmp 	FPUToFloat 					; convert to float
.01937d					_BMFError:
.01937d	4c 4f 85	jmp $01854f			jmp 	TypeError
.019380					ConcatenateString:
.019380	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.019382	85 1a		sta $1a				sta		zLTemp1+0
.019384	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019386	85 1b		sta $1b				sta 	zLTemp1+1
.019388	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.01938a	85 1c		sta $1c				sta 	zLTemp1+2
.01938c	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.01938e	85 1d		sta $1d				sta 	zLTemp1+3
.019390	5a		phy				phy
.019391	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.019393	b1 1a		lda ($1a),y			lda 	(zlTemp1),y
.019395	71 1c		adc ($1c),y			adc 	(zlTemp1+2),y
.019397	7a		ply				ply
.019398	b0 33		bcs $0193cd			bcs 	_CSError					; check in range.
.01939a	c9 fe		cmp #$fe			cmp 	#maxString+1
.01939c	b0 2f		bcs $0193cd			bcs 	_CSError
.01939e	20 16 98	jsr $019816			jsr 	AllocateTempString 			; store the result
.0193a1	20 b8 93	jsr $0193b8			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.0193a4	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.0193a6	85 1a		sta $1a				sta 	zLTemp1
.0193a8	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.0193aa	85 1b		sta $1b				sta 	zLTemp1+1
.0193ac	20 b8 93	jsr $0193b8			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.0193af	a5 20		lda $20				lda 	zTempStr 					; point current to new string
.0193b1	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0193b3	a5 21		lda $21				lda 	zTempStr+1
.0193b5	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0193b7	60		rts				rts
.0193b8					_CSCopyString:
.0193b8	da		phx				phx
.0193b9	5a		phy				phy
.0193ba	a0 00		ldy #$00			ldy 	#0 							; get length
.0193bc	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.0193be	f0 0a		beq $0193ca			beq 	_CSCSExit 					; if zero, exit
.0193c0	aa		tax				tax 								; put in X
.0193c1					_CSCSLoop:
.0193c1	c8		iny				iny 								; get next char
.0193c2	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.0193c4	20 41 98	jsr $019841			jsr		WriteTempString 			; copy out
.0193c7	ca		dex				dex 								; do whole string
.0193c8	d0 f7		bne $0193c1			bne 	_CSCSLoop
.0193ca					_CSCSExit:
.0193ca	7a		ply				ply
.0193cb	fa		plx				plx
.0193cc	60		rts				rts
.0193cd					_CSError:
.0193cd	20 6e 85	jsr $01856e			jsr ERR_Handler
>0193d0	53 74 72 69 6e 67 20 74			.text "String too long",0
>0193d8	6f 6f 20 6c 6f 6e 67 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.0193e0					Unary_Sgn:
.0193e0	20 86 91	jsr $019186			jsr 	EvaluateNumberX 			; get value
.0193e3	20 d6 97	jsr $0197d6			jsr 	CheckNextRParen 			; check right bracket.
.0193e6	20 04 94	jsr $019404			jsr 	GetSignCurrent 				; get sign.
.0193e9	09 00		ora #$00			ora 	#0
.0193eb	10 08		bpl $0193f5			bpl		UnarySetAInteger			; if 0,1 return that.
.0193ed	80 00		bra $0193ef			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.0193ef					UnarySetAMinus1:
.0193ef	a9 ff		lda #$ff			lda 	#$FF
.0193f1	95 80		sta $80,x			sta 	XS_Mantissa,x
.0193f3	80 04		bra $0193f9			bra 	UnarySetAFill
.0193f5					UnarySetAInteger:
.0193f5	95 80		sta $80,x			sta 	XS_Mantissa,x
.0193f7	a9 00		lda #$00			lda 	#0
.0193f9					UnarySetAFill:
.0193f9	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0193fb	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0193fd	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0193ff	a9 01		lda #$01			lda 	#1
.019401	95 85		sta $85,x			sta 	XS_Type,x
.019403	60		rts				rts
.019404					GetSignCurrent:
.019404	b5 85		lda $85,x			lda 	XS_Type,x 					; identify type.
.019406	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.019407	90 15		bcc $01941e			bcc 	_GSCFloat
.019409	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01940b	30 0e		bmi $01941b			bmi 	_GSCMinus1
.01940d	15 80		ora $80,x			ora 	XS_Mantissa+0,x
.01940f	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019411	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019413	d0 03		bne $019418			bne 	_GSCPlus1
.019415					_GSCZero:
.019415	a9 00		lda #$00			lda 	#0
.019417	60		rts				rts
.019418					_GSCPlus1:
.019418	a9 01		lda #$01			lda 	#$01
.01941a	60		rts				rts
.01941b					_GSCMinus1:
.01941b	a9 ff		lda #$ff			lda 	#$FF
.01941d	60		rts				rts
.01941e					_GSCFloat:
.01941e	34 85		bit $85,x			bit 	XS_Type,x
.019420	70 f3		bvs $019415			bvs 	_GSCZero
.019422	30 f7		bmi $01941b			bmi 	_GSCMinus1
.019424	80 f2		bra $019418			bra 	_GSCPlus1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.019426					Unary_Abs:
.019426	20 86 91	jsr $019186			jsr 	EvaluateNumberX 			; get value
.019429	20 d6 97	jsr $0197d6			jsr 	CheckNextRParen 			; check right bracket.
.01942c	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.01942e	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.019430	f0 07		beq $019439			beq 	_UAMinusFloat
.019432	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; check MSB
.019434	10 09		bpl $01943f			bpl 	_UAExit
.019436	4c 3c 9d	jmp $019d3c			jmp 	IntegerNegateAlways 		; negation
.019439					_UAMinusFloat:
.019439	b5 85		lda $85,x			lda 	XS_Type,x 					; clear the sign bit.
.01943b	29 7f		and #$7f			and		#$7F
.01943d	95 85		sta $85,x			sta 	XS_Type,x
.01943f					_UAExit:
.01943f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.019440					Unary_Peek:
.019440	a9 01		lda #$01			lda 	#1
.019442	80 06		bra $01944a			bra 	UPMain
.019444					Unary_Deek:
.019444	a9 02		lda #$02			lda 	#2
.019446	80 02		bra $01944a			bra 	UPMain
.019448					Unary_Leek:
.019448	a9 04		lda #$04			lda 	#4
.01944a					UPMain:
.01944a	48		pha				pha 								; set bytes to copy.
.01944b	20 94 91	jsr $019194			jsr 	EvaluateIntegerX 			; numeric parameter
.01944e	20 d6 97	jsr $0197d6			jsr 	CheckNextRParen 			; right bracket.
.019451	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.019453	85 1a		sta $1a				sta 	zLTemp1
.019455	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019457	85 1b		sta $1b				sta 	zLTemp1+1
.019459	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01945b	85 1c		sta $1c				sta 	zLTemp1+2
.01945d	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01945f	85 1d		sta $1d				sta 	zLTemp1+3
.019461	a9 00		lda #$00			lda 	#0 							; clear target area
.019463	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019465	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019467	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019469	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01946b	68		pla				pla 								; restore bytes to copy
.01946c	da		phx				phx 								; save XY
.01946d	5a		phy				phy
.01946e	20 58 97	jsr $019758			jsr 	MemRead 					; read the bytes in
.019471	7a		ply				ply 								; restore and exit
.019472	fa		plx				plx
.019473	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/pos.asm

.019474					Unary_Pos:
.019474	20 86 91	jsr $019186			jsr 	EvaluateNumberX 			; get value
.019477	20 d6 97	jsr $0197d6			jsr 	CheckNextRParen 			; check right bracket.
.01947a	20 3b 85	jsr $01853b			jsr 	CharGetPosition 			; get the position
.01947d	4c f5 93	jmp $0193f5			jmp		UnarySetAInteger			; if 0,1 return that.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.019480					Unary_Mod:
.019480	20 a8 94	jsr $0194a8			jsr 	_UMParameter 				; first parameter
.019483	20 de 97	jsr $0197de			jsr 	CheckNextComma
.019486	da		phx				phx 								; second parameter
.019487	e8		inx				inx
.019488	e8		inx				inx
.019489	e8		inx				inx
.01948a	e8		inx				inx
.01948b	e8		inx				inx
.01948c	e8		inx				inx
.01948d	20 a8 94	jsr $0194a8			jsr 	_UMParameter
.019490	fa		plx				plx
.019491	20 d6 97	jsr $0197d6			jsr 	CheckNextRParen
.019494	20 b5 9c	jsr $019cb5			jsr 	DivInteger32 				; divide
.019497	a5 1a		lda $1a				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.019499	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01949b	a5 1b		lda $1b				lda 	zLTemp1+1
.01949d	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01949f	a5 1c		lda $1c				lda 	zLTemp1+2
.0194a1	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0194a3	a5 1d		lda $1d				lda 	zLTemp1+3
.0194a5	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0194a7	60		rts				rts
.0194a8					_UMParameter:
.0194a8	20 94 91	jsr $019194			jsr 	EvaluateIntegerX 			; get value
.0194ab	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; absolute value
.0194ad	10 03		bpl $0194b2			bpl 	_UMNotSigned
.0194af	20 3c 9d	jsr $019d3c			jsr 	IntegerNegateAlways
.0194b2					_UMNotSigned:
.0194b2	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.0194b3					Unary_Usr:
.0194b3	20 86 91	jsr $019186			jsr 	EvaluateNumberX 			; numeric parameter
.0194b6	20 d6 97	jsr $0197d6			jsr 	CheckNextRParen 			; right bracket.
.0194b9	da		phx				phx 								; save XY
.0194ba	5a		phy				phy
.0194bb	ea		nop				nop
.0194bc	22 0c 03 00	jsl $00030c			jsl 	UserVector
.0194c0	7a		ply				ply 								; and exit
.0194c1	fa		plx				plx
.0194c2	60		rts				rts
.0194c3					USRDefault:
.0194c3	20 6e 85	jsr $01856e			jsr ERR_Handler
>0194c6	4e 6f 20 55 53 52 20 76			.text "No USR vector.",0
>0194ce	65 63 74 6f 72 2e 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.0194d5					Unary_Val:
.0194d5	20 9d 91	jsr $01919d			jsr 	EvaluateStringX 			; get string
.0194d8	20 d6 97	jsr $0197d6			jsr 	CheckNextRParen 			; check right bracket.
.0194db	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.0194dd	85 1e		sta $1e				sta 	zGenPtr
.0194df	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0194e1	85 1f		sta $1f				sta 	zGenPtr+1
.0194e3	5a		phy				phy
.0194e4	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.0194e6	b1 1e		lda ($1e),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.0194e8	f0 54		beq $01953e			beq 	_UVBadNumber
.0194ea	48		pha				pha 								; save length.
.0194eb	1a		inc a				inc 	a 							; one for the length, one for the terminator
.0194ec	1a		inc a				inc 	a
.0194ed	20 16 98	jsr $019816			jsr 	AllocateTempString
.0194f0	c8		iny				iny 								; move to the next.
.0194f1	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get character
.0194f3	49 2d		eor #$2d			eor 	#"-"						; zero if minus sign
.0194f5	8d a0 03	sta $03a0			sta 	ValSign
.0194f8	d0 04		bne $0194fe			bne 	_UVNotMinus
.0194fa	c8		iny				iny 								; skip over it.
.0194fb	68		pla				pla 								; decrement character count.
.0194fc	3a		dec a				dec 	a
.0194fd	48		pha				pha
.0194fe					_UVNotMinus:
.0194fe	68		pla				pla 								; this is the count.
.0194ff	48		pha		_UVCopy:pha									; copy into new temp string which is ASCIIZ
.019500	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.019502	c8		iny				iny
.019503	20 41 98	jsr $019841			jsr 	WriteTempString
.019506	68		pla				pla
.019507	3a		dec a				dec 	a
.019508	d0 f5		bne $0194ff			bne 	_UVCopy
.01950a	20 41 98	jsr $019841			jsr 	WriteTempString 			; make it ASCIIZ
.01950d	18		clc				clc
.01950e	a5 20		lda $20				lda 	zTempStr 					; tempstring +1 => genptr
.019510	69 01		adc #$01			adc 	#1
.019512	85 1e		sta $1e				sta 	zGenPtr
.019514	a5 21		lda $21				lda 	zTempStr+1
.019516	69 00		adc #$00			adc 	#0
.019518	85 1f		sta $1f				sta 	zGenPtr+1
.01951a	18		clc				clc
.01951b	20 0e 9e	jsr $019e0e			jsr 	IntFromString 				; first bit.
.01951e	b0 1e		bcs $01953e			bcs 	_UVBadNumber
.019520	20 8c a3	jsr $01a38c			jsr 	FPFromString				; try for a float part.
.019523	ad a0 03	lda $03a0			lda 	ValSign 					; was it negative
.019526	d0 10		bne $019538			bne 	_UVNotNegative
.019528	b5 85		lda $85,x			lda 	XS_Type,x 					; check if integer
.01952a	4a		lsr a				lsr 	a
.01952b	b0 08		bcs $019535			bcs 	_UVInteger
.01952d	b5 85		lda $85,x			lda 	XS_Type,x 					; set sign bit
.01952f	09 80		ora #$80			ora 	#$80
.019531	95 85		sta $85,x			sta 	XS_Type,x
.019533	80 03		bra $019538			bra 	_UVNotNegative
.019535					_UVInteger:
.019535	20 3c 9d	jsr $019d3c			jsr 	IntegerNegateAlways 		; sign it.
.019538					_UVNotNegative:
.019538	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; used everything
.01953a	d0 02		bne $01953e			bne 	_UVBadNumber
.01953c	7a		ply				ply
.01953d	60		rts				rts
.01953e					_UVBadNumber:
.01953e	4c 5d 85	jmp $01855d			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.019541					Unary_Str:
.019541	20 86 91	jsr $019186			jsr 	EvaluateNumberX 			; numeric parameter
.019544	20 d6 97	jsr $0197d6			jsr 	CheckNextRParen 			; right bracket.
.019547	a9 00		lda #$00			lda 	#0 							; reset buffer index
.019549	8d 14 03	sta $0314			sta 	NumBufX
.01954c	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.01954e	4a		lsr a				lsr 	a
.01954f	b0 05		bcs $019556			bcs 	_USInt 						; if msb set do as integer
.019551	20 d1 a2	jsr $01a2d1			jsr 	FPToString 					; call fp to str otherwise
.019554	80 03		bra $019559			bra 	_USDuplicate
.019556	20 59 9d	jsr $019d59	_USInt:	jsr 	IntToString
.019559					_USDuplicate:
.019559	ad 14 03	lda $0314			lda 	NumBufX 					; chars in buffer
.01955c	1a		inc a				inc 	a 							; one more for length
.01955d	20 16 98	jsr $019816			jsr 	AllocateTempString 			; allocate space for it.
.019560	5a		phy				phy 								; save Y
.019561	a0 00		ldy #$00			ldy 	#0 							; start copying
.019563	b9 15 03	lda $0315,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.019566	20 41 98	jsr $019841			jsr 	WriteTempString
.019569	c8		iny				iny
.01956a	cc 14 03	cpy $0314			cpy 	NumBufX 					; done the lot
.01956d	d0 f4		bne $019563			bne 	_USCopy
.01956f	7a		ply				ply 								; restore Y
.019570	4c 4b 97	jmp $01974b			jmp 	UnaryReturnTempStr 			; return new temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.019573					Unary_Asc:
.019573	20 9d 91	jsr $01919d			jsr 	EvaluateStringX 			; string parameter
.019576	20 d6 97	jsr $0197d6			jsr 	CheckNextRParen 			; right bracket.
.019579	5a		phy				phy 								; get the string length
.01957a	a0 00		ldy #$00			ldy 	#0
.01957c	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.01957e	f0 07		beq $019587			beq 	_UAIllegal 					; must be at least one character
.019580	c8		iny				iny
.019581	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; read it.
.019583	7a		ply				ply
.019584	4c f5 93	jmp $0193f5			jmp 	UnarySetAInteger
.019587					_UAIllegal:
.019587	4c 5d 85	jmp $01855d			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.01958a					Unary_Len:
.01958a	20 9d 91	jsr $01919d			jsr 	EvaluateStringX 			; string parameter
.01958d	20 d6 97	jsr $0197d6			jsr 	CheckNextRParen 			; right bracket.
.019590	5a		phy				phy 								; get the string length
.019591	a0 00		ldy #$00			ldy 	#0
.019593	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.019595	7a		ply				ply
.019596	4c f5 93	jmp $0193f5			jmp 	UnarySetAInteger

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.019599					Unary_Mid:
.019599	20 9d 91	jsr $01919d			jsr 	EvaluateStringX 				; get string.
.01959c	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.01959e	48		pha				pha
.01959f	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0195a1	48		pha				pha
.0195a2	20 de 97	jsr $0197de			jsr 	CheckNextComma 					; skip comma
.0195a5	20 2e 96	jsr $01962e			jsr 	SLIByteParameter 				; get a byte parameter (start)
.0195a8	48		pha				pha 									; and push it.
.0195a9	20 de 97	jsr $0197de			jsr 	CheckNextComma 					; skip comma
.0195ac	20 2e 96	jsr $01962e			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.0195af	48		pha				pha 									; and push it.
.0195b0	80 41		bra $0195f3			bra 	SLIProcess
.0195b2					Unary_Left:
.0195b2	20 9d 91	jsr $01919d			jsr 	EvaluateStringX 				; get string.
.0195b5	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.0195b7	48		pha				pha
.0195b8	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0195ba	48		pha				pha
.0195bb	a9 01		lda #$01			lda 	#1 								; push start position (1)
.0195bd	48		pha				pha
.0195be	20 de 97	jsr $0197de			jsr 	CheckNextComma 					; skip comma
.0195c1	20 2e 96	jsr $01962e			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.0195c4	48		pha				pha 									; and push it.
.0195c5	80 2c		bra $0195f3			bra 	SLIProcess
.0195c7					Unary_Right:
.0195c7	20 9d 91	jsr $01919d			jsr 	EvaluateStringX 				; get string.
.0195ca	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.0195cc	48		pha				pha
.0195cd	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0195cf	48		pha				pha
.0195d0	da		phx				phx 									; get the string length and push on stack.
.0195d1	a2 00		ldx #$00			ldx 	#0
.0195d3	a1 1e		lda ($1e,x)			lda		(zGenPtr,x)
.0195d5	fa		plx				plx
.0195d6	48		pha				pha
.0195d7	20 de 97	jsr $0197de			jsr 	CheckNextComma 					; skip comma
.0195da	20 2e 96	jsr $01962e			jsr 	SLIByteParameter 				; get a byte parameter.
.0195dd	8d 9e 03	sta $039e			sta 	SignCount 						; save in temporary.
.0195e0	68		pla				pla 									; restore string length.
.0195e1	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.0195e2	38		sec				sec
.0195e3	ed 9e 03	sbc $039e			sbc 	SignCount 						; subtract characters needed, gives start position.
.0195e6	f0 02		beq $0195ea			beq 	_URStart 						; if <= 0 start from 1.
.0195e8	10 02		bpl $0195ec			bpl 	_UROkay
.0195ea					_URStart:
.0195ea	a9 01		lda #$01			lda 	#1
.0195ec					_UROkay:
.0195ec	48		pha				pha 									; push start
.0195ed	ad 9e 03	lda $039e			lda 	SignCount 						; push count of characters
.0195f0	48		pha				pha
.0195f1	80 00		bra $0195f3			bra 	SLIProcess
.0195f3					SLIProcess:
.0195f3	20 d6 97	jsr $0197d6			jsr 	CheckNextRParen 				; closing right bracket.
.0195f6	68		pla				pla
.0195f7	8d a2 03	sta $03a2			sta 	SliceCount 						; count in signcount
.0195fa	1a		inc a				inc 	a 								; allocate +1 for it.
.0195fb	20 16 98	jsr $019816			jsr 	AllocateTempString
.0195fe	68		pla				pla 									; pop start number off stack.
.0195ff	f0 3b		beq $01963c			beq 	SLIError 						; exit if start = 0
.019601	8d a1 03	sta $03a1			sta 	SliceStart
.019604	68		pla				pla  									; pop string address.
.019605	85 1f		sta $1f				sta 	zGenPtr+1
.019607	68		pla				pla
.019608	85 1e		sta $1e				sta 	zGenPtr
.01960a	da		phx				phx
.01960b	5a		phy				phy
.01960c	a2 00		ldx #$00			ldx 	#0 								; point to string length.
.01960e	ac a1 03	ldy $03a1			ldy 	SliceStart 						; start of the string (+1 for count)
.019611					_SLICopy:
.019611	ad a2 03	lda $03a2			lda 	SliceCount 						; done count characters
.019614	f0 12		beq $019628			beq 	_SLIExit
.019616	ce a2 03	dec $03a2			dec 	SliceCount
.019619	98		tya				tya 									; index of character
.01961a	c1 1e		cmp ($1e,x)			cmp 	(zGenPtr,x)						; compare against length
.01961c	f0 02		beq $019620			beq 	_SLIOk 							; if equal, okay.
.01961e	b0 08		bcs $019628			bcs 	_SLIExit 						; if past end, then exit.
.019620	b1 1e		lda ($1e),y	_SLIOk:	lda 	(zGenPtr),y 					; copy one character
.019622	c8		iny				iny
.019623	20 41 98	jsr $019841			jsr 	WriteTempString
.019626	80 e9		bra $019611			bra 	_SLICopy 						; go round till copied characters
.019628					_SLIExit:
.019628	7a		ply				ply 									; restore YX
.019629	fa		plx				plx
.01962a	4c 4b 97	jmp $01974b			jmp 	UnaryReturnTempStr 				; return new temporary string.
.01962d	ea		nop				nop
.01962e					SLIByteParameter:
.01962e	20 94 91	jsr $019194			jsr 	EvaluateIntegerX 				; get integer
.019631	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.019633	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019635	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019637	d0 03		bne $01963c			bne 	SLIError
.019639	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01963b	60		rts				rts
.01963c					SLIError:
.01963c	4c 5d 85	jmp $01855d			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.01963f					Unary_Hex:
.01963f	20 94 91	jsr $019194			jsr 	EvaluateIntegerX 			; numeric parameter
.019642	20 d6 97	jsr $0197d6			jsr 	CheckNextRParen 			; right bracket.
.019645	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.019647	20 16 98	jsr $019816			jsr 	AllocateTempString			; allocate string space
.01964a	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.01964c	20 70 96	jsr $019670			jsr 	_UHConvert
.01964f	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019651	20 70 96	jsr $019670			jsr 	_UHConvert
.019654	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019656	20 70 96	jsr $019670			jsr 	_UHConvert
.019659	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01965b	20 70 96	jsr $019670			jsr 	_UHConvert
.01965e	5a		phy				phy 								; get length of new string
.01965f	a0 00		ldy #$00			ldy 	#0
.019661	b1 20		lda ($20),y			lda 	(zTempStr),y
.019663	7a		ply				ply
.019664	c9 00		cmp #$00			cmp 	#0
.019666	d0 05		bne $01966d			bne 	_UHExit 					; if it was non zero okay
.019668	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.01966a	20 41 98	jsr $019841			jsr 	WriteTempString
.01966d					_UHExit:
.01966d	4c 4b 97	jmp $01974b			jmp 	UnaryReturnTempStr 			; return new temporary string.
.019670					_UHConvert:
.019670	48		pha				pha
.019671	4a		lsr a				lsr 	a 							; do MSB
.019672	4a		lsr a				lsr 	a
.019673	4a		lsr a				lsr 	a
.019674	4a		lsr a				lsr 	a
.019675	20 79 96	jsr $019679			jsr 	_UHNibble
.019678	68		pla				pla 								; do LSB
.019679					_UHNibble:
.019679	29 0f		and #$0f			and 	#15 						; get nibble
.01967b	d0 0c		bne $019689			bne 	_UHNonZero
.01967d	5a		phy				phy									; get the length
.01967e	a0 00		ldy #$00			ldy 	#0
.019680	b1 20		lda ($20),y			lda 	(zTempStr),y
.019682	7a		ply				ply
.019683	c9 00		cmp #$00			cmp 	#0 							; suppress leading zeros.
.019685	f0 0d		beq $019694			beq 	_UHExit2
.019687	a9 00		lda #$00			lda 	#0
.019689					_UHNonZero:
.019689	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.01968b	90 02		bcc $01968f			bcc 	_UHDigit
.01968d	69 06		adc #$06			adc 	#7-1
.01968f					_UHDigit:
.01968f	69 30		adc #$30			adc 	#48
.019691	20 41 98	jsr $019841			jsr 	WriteTempString				; output.
.019694					_UHExit2:
.019694	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.019695					Unary_Dec:
.019695	20 9d 91	jsr $01919d			jsr 	EvaluateStringX 			; string parameter
.019698	20 d6 97	jsr $0197d6			jsr 	CheckNextRParen 			; right bracket.
.01969b	5a		phy				phy
.01969c	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.01969e	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.0196a0	f0 41		beq $0196e3			beq 	_UDFail 					; must fail if zero.
.0196a2	8d 9e 03	sta $039e			sta 	SignCount 					; use SignCount as a counter
.0196a5	a9 00		lda #$00			lda 	#0 							; set result to zero integer.
.0196a7	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0196a9	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0196ab	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0196ad	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0196af	a9 01		lda #$01			lda 	#1
.0196b1	95 85		sta $85,x			sta 	XS_Type,x
.0196b3					_UDConvertLoop:
.0196b3	5a		phy				phy 								; shift mantissa left 4
.0196b4	a0 04		ldy #$04			ldy 	#4
.0196b6					_UDShift:
.0196b6	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.0196b8	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.0196ba	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.0196bc	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.0196be	88		dey				dey
.0196bf	d0 f5		bne $0196b6			bne 	_UDShift
.0196c1	7a		ply				ply
.0196c2	c8		iny				iny 								; next character
.0196c3	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; fetch it.
.0196c5	20 e6 96	jsr $0196e6			jsr 	ConvertUpper 				; convert to U/C
.0196c8	c9 30		cmp #$30			cmp 	#"0"
.0196ca	90 17		bcc $0196e3			bcc 	_UDFail
.0196cc	c9 3a		cmp #$3a			cmp 	#"9"+1
.0196ce	90 06		bcc $0196d6			bcc 	_UDOkay
.0196d0	e9 37		sbc #$37			sbc 	#7+"0" 						; alpha fudge
.0196d2	c9 10		cmp #$10			cmp 	#16
.0196d4	b0 0d		bcs $0196e3			bcs 	_UDFail
.0196d6					_UDOkay:
.0196d6	29 0f		and #$0f			and 	#15 						; nibble only
.0196d8	15 80		ora $80,x			ora 	XS_Mantissa+0,x
.0196da	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0196dc	ce 9e 03	dec $039e			dec 	SignCount 					; do it for each character
.0196df	d0 d2		bne $0196b3			bne 	_UDConvertLoop
.0196e1	7a		ply				ply
.0196e2	60		rts				rts
.0196e3					_UDFail:
.0196e3	4c 5d 85	jmp $01855d			jmp 	BadParamError
.0196e6					ConvertUpper:
.0196e6	c9 61		cmp #$61			cmp 	#"a"
.0196e8	90 07		bcc $0196f1			bcc 	_CUExit
.0196ea	c9 7b		cmp #$7b			cmp 	#"z"+1
.0196ec	b0 03		bcs $0196f1			bcs 	_CUExit
.0196ee	38		sec				sec
.0196ef	e9 20		sbc #$20			sbc 	#32
.0196f1	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.0196f2					Unary_Chr:
.0196f2	20 94 91	jsr $019194			jsr 	EvaluateIntegerX			; numeric parameter
.0196f5	20 d6 97	jsr $0197d6			jsr 	CheckNextRParen 			; right bracket.
.0196f8	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.0196fa	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.0196fc	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.0196fe	d0 0d		bne $01970d			bne 	_UCChar
.019700	a9 01		lda #$01			lda 	#1 							; one character string
.019702	20 16 98	jsr $019816			jsr 	AllocateTempString
.019705	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.019707	20 41 98	jsr $019841			jsr 	WriteTempString
.01970a	4c 4b 97	jmp $01974b			jmp 	UnaryReturnTempStr
.01970d					_UCChar:
.01970d	4c 5d 85	jmp $01855d			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.019710					Unary_Spc:
.019710	20 2e 96	jsr $01962e			jsr 	SLIByteParameter 			; check space.
.019713	20 d6 97	jsr $0197d6			jsr 	CheckNextRParen
.019716	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019718					UnarySpcCreate:
.019718	c9 fe		cmp #$fe			cmp 	#maxString+1
.01971a	b0 14		bcs $019730			bcs 	_USSize
.01971c	48		pha				pha 								; save length
.01971d	1a		inc a				inc 	a 							; allocate one more.
.01971e	20 16 98	jsr $019816			jsr 	AllocateTempString
.019721	68		pla				pla 								; get length
.019722	f0 27		beq $01974b			beq 	UnaryReturnTempStr 			; return the current temp string
.019724					_USLoop:
.019724	48		pha				pha
.019725	a9 20		lda #$20			lda 	#" "
.019727	20 41 98	jsr $019841			jsr 	WriteTempString
.01972a	68		pla				pla
.01972b	3a		dec a				dec 	a
.01972c	d0 f6		bne $019724			bne 	_USLoop
.01972e	80 1b		bra $01974b			bra 	UnaryReturnTempStr
.019730					_USSize:
.019730	4c 5d 85	jmp $01855d			jmp 	BadParamError
.019733					Unary_Tab:
.019733	a2 00		ldx #$00			ldx 	#0 							; required TAB position.
.019735	20 2e 96	jsr $01962e			jsr 	SLIByteParameter
.019738	20 d6 97	jsr $0197d6			jsr 	CheckNextRParen
.01973b	20 3b 85	jsr $01853b			jsr 	CharGetPosition 			; were are we ?
.01973e	85 10		sta $10				sta 	zTemp1
.019740	38		sec				sec
.019741	a5 80		lda $80				lda 	XS_Mantissa+0 				; return chars required.
.019743	e5 10		sbc $10				sbc 	zTemp1
.019745	b0 d1		bcs $019718			bcs 	UnarySpcCreate
.019747	a9 00		lda #$00			lda 	#0
.019749	80 cd		bra $019718			bra 	UnarySpcCreate
.01974b					UnaryReturnTempStr:
.01974b	a5 20		lda $20				lda 	zTempStr 					; copy temp string addr -> mantissa
.01974d	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01974f	a5 21		lda $21				lda 	zTempStr+1
.019751	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019753	a9 02		lda #$02			lda 	#2 							; set type to string
.019755	95 85		sta $85,x			sta 	XS_Type,x
.019757	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/65816.asm

.019758					MemRead:
.019758	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.01975b	a0 00		ldy #$00			ldy 	#0 							; start from here
.01975d	b7 1a		lda [$1a],y	_MLoop1:lda 	[zlTemp1],y 				; read the long address
.01975f	95 80		sta $80,x			sta 	XS_Mantissa,x 				; copy into mantissa
.019761	c8		iny				iny 								; next to copy
.019762	e8		inx				inx
.019763	cc 9e 03	cpy $039e			cpy 	SignCount 					; do required # of bytes.
.019766	d0 f5		bne $01975d			bne 	_MLoop1
.019768	60		rts				rts
.019769					MemWrite:
.019769	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.01976c	a0 00		ldy #$00			ldy 	#0 							; start from here
.01976e	b5 80		lda $80,x	_MLoop1:lda 	XS_Mantissa,x 				; read mantisssa
.019770	97 1a		sta [$1a],y			sta 	[zlTemp1],y 				; write it out
.019772	c8		iny				iny 								; next to copy
.019773	e8		inx				inx
.019774	cc 9e 03	cpy $039e			cpy 	SignCount 					; do required # of bytes.
.019777	d0 f5		bne $01976e			bne 	_MLoop1
.019779	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/programend.asm

.01977a					UpdateProgramEnd:
.01977a	a9 00		lda #$00			lda 	#BasicProgram & $FF
.01977c	85 16		sta $16				sta 	zCodePtr+0
.01977e	a9 10		lda #$10			lda 	#BasicProgram >> 8
.019780	85 17		sta $17				sta 	zCodePtr+1
.019782	a9 00		lda #$00			lda 	#0
.019784	85 18		sta $18				sta 	zCodePtr+2
.019786	85 19		sta $19				sta 	zCodePtr+3
.019788	a0 03		ldy #$03			ldy 	#3
.01978a					_UPDLoop:
.01978a	a0 00		ldy #$00			ldy 	#0
.01978c	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01978e	c9 00		cmp #$00			cmp 	#0 							; end if offset is zero.
.019790	f0 0f		beq $0197a1			beq 	_UPDFoundEnd
.019792	a0 00		ldy #$00			ldy 	#0 							; point to offset
.019794	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.019796	18		clc				clc
.019797	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.019799	85 16		sta $16				sta 	zCodePtr
.01979b	90 02		bcc $01979f			bcc 	_SNLNoCarry
.01979d	e6 17		inc $17				inc 	zCodePtr+1
.01979f					_SNLNoCarry:
.01979f	80 e9		bra $01978a			bra 	_UPDLoop
.0197a1					_UPDFoundEnd:
.0197a1	18		clc				clc 								; end of program 2 on.
.0197a2	a5 16		lda $16				lda 	zCodePtr
.0197a4	69 02		adc #$02			adc 	#2
.0197a6	8d 04 03	sta $0304			sta 	endOfProgram
.0197a9	a5 17		lda $17				lda 	zCodePtr+1
.0197ab	69 00		adc #$00			adc 	#0
.0197ad	8d 05 03	sta $0305			sta 	endOfProgram+1
.0197b0	a5 18		lda $18				lda 	zCodePtr+2
.0197b2	69 00		adc #$00			adc		#0
.0197b4	8d 06 03	sta $0306			sta 	endOfProgram+2
.0197b7	a5 19		lda $19				lda 	zCodePtr+3
.0197b9	69 00		adc #$00			adc 	#0
.0197bb	8d 07 03	sta $0307			sta 	endOfProgram+3
.0197be	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.0197bf					CheckNextToken:
.0197bf	d7 16		cmp [$16],y			cmp 	[zCodePtr],y
.0197c1	d0 02		bne $0197c5			bne 	CTFail 						; no, then fail
.0197c3	c8		iny				iny
.0197c4	60		rts				rts
.0197c5					CTFail:
.0197c5	20 6e 85	jsr $01856e			jsr ERR_Handler
>0197c8	4d 69 73 73 69 6e 67 20			.text "Missing token",0
>0197d0	74 6f 6b 65 6e 00
.0197d6					CheckNextRParen:
.0197d6	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0197d8	c9 be		cmp #$be			cmp 	#token_rparen
.0197da	d0 e9		bne $0197c5			bne 	CTFail
.0197dc	c8		iny				iny
.0197dd	60		rts				rts
.0197de					CheckNextComma:
.0197de	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0197e0	c9 bf		cmp #$bf			cmp 	#token_comma
.0197e2	d0 e1		bne $0197c5			bne 	CTFail
.0197e4	c8		iny				iny
.0197e5	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/concrete.asm

.0197e6					StringConcrete:
.0197e6	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; save source to zTemp1
.0197e8	85 10		sta $10				sta 	zTemp1
.0197ea	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0197ec	85 11		sta $11				sta 	zTemp1+1
.0197ee	a0 00		ldy #$00			ldy 	#0 							; subtract the length+1 (clc) of the string.
.0197f0	18		clc				clc 								; from the string pointer
.0197f1	ad 00 03	lda $0300			lda 	StringPtr 					; and put in zTemp2 as well
.0197f4	f1 10		sbc ($10),y			sbc 	(zTemp1),y
.0197f6	8d 00 03	sta $0300			sta 	StringPtr
.0197f9	85 12		sta $12				sta 	zTemp2
.0197fb	ad 01 03	lda $0301			lda 	StringPtr+1
.0197fe	e9 00		sbc #$00			sbc 	#0
.019800	8d 01 03	sta $0301			sta 	StringPtr+1
.019803	85 13		sta $13				sta 	zTemp2+1
.019805	b1 10		lda ($10),y			lda 	(zTemp1),y 					; length add one for count
.019807	1a		inc a				inc 	a
.019808	aa		tax				tax
.019809	b1 10		lda ($10),y	_SCCopy:lda 	(zTemp1),y 					; copy whole thing including length
.01980b	91 12		sta ($12),y			sta 	(zTemp2),y
.01980d	c8		iny				iny
.01980e	ca		dex				dex
.01980f	d0 f8		bne $019809			bne 	_SCCopy
.019811	a5 13		lda $13				lda 	zTemp2+1 					; return concrete string in AX
.019813	a6 12		ldx $12				ldx 	zTemp2
.019815	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.019816					AllocateTempString:
.019816	48		pha				pha 								; save required count.
.019817	a5 21		lda $21				lda 	zTempStr+1 					; check if initialised yet ?
.019819	d0 0b		bne $019826			bne 	_ATSInitialised
.01981b	ad 00 03	lda $0300			lda 	StringPtr 					; set temporary string ptr 1 page below available
.01981e	85 20		sta $20				sta 	zTempStr					; space, this is for strings to be concreted.
.019820	ad 01 03	lda $0301			lda 	StringPtr+1
.019823	3a		dec a				dec 	a
.019824	85 21		sta $21				sta 	zTempStr+1
.019826					_ATSInitialised:
.019826	68		pla				pla 								; get required count back.
.019827	49 ff		eor #$ff			eor 	#$FF 						; negate 2's complement.
.019829	1a		inc a				inc 	a
.01982a	18		clc				clc
.01982b	65 20		adc $20				adc 	zTempStr 					; "add" to the temp string pointer
.01982d	85 20		sta $20				sta 	zTempStr
.01982f	a9 ff		lda #$ff			lda 	#$FF
.019831	65 21		adc $21				adc 	zTempStr+1
.019833	85 21		sta $21				sta 	zTempStr+1
.019835	a9 00		lda #$00			lda 	#0 							; clear temp string.
.019837	5a		phy				phy
.019838	a8		tay				tay
.019839	91 20		sta ($20),y			sta 	(zTempStr),y
.01983b	7a		ply				ply
.01983c	1a		inc a				inc 	a 							; reset the write index.
.01983d	8d 9f 03	sta $039f			sta 	TempStringWriteIndex
.019840	60		rts				rts
.019841					WriteTempString:
.019841	5a		phy				phy 								; save Y
.019842	ac 9f 03	ldy $039f			ldy 	TempStringWriteIndex	 	; write position.
.019845	91 20		sta ($20),y			sta 	(zTempStr),y 				; write character out.
.019847	ee 9f 03	inc $039f			inc 	TempStringWriteIndex 		; increment the write position.
.01984a	98		tya				tya 								; unchanged Y is now length
.01984b	a0 00		ldy #$00			ldy 	#0
.01984d	91 20		sta ($20),y			sta 	(zTempStr),y
.01984f	7a		ply				ply 								; restore Y and exit
.019850	60		rts				rts
.019851					CreateTempStringCopy:
.019851	da		phx				phx 								; save X
.019852	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019854	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.019855	20 16 98	jsr $019816			jsr 	AllocateTempString 			; allocate memory for temporary string.
.019858	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01985a	c8		iny				iny
.01985b	3a		dec a				dec 	a 							; make the actual length in charactes
.01985c	3a		dec a				dec 	a
.01985d	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.01985f	81 20		sta ($20,x)			sta 	(zTempStr,x)
.019861	85 1a		sta $1a				sta 	zLTemp1 					; that's used as a count.
.019863	09 00		ora #$00			ora 	#0 							; if zero already, exit
.019865	f0 0e		beq $019875			beq 	_CTSCExit
.019867					_CTSCLoop:
.019867	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019869	c8		iny				iny
.01986a	5a		phy				phy 								; save in Y
.01986b	e8		inx				inx 								; bump index
.01986c	da		phx				phx 								; index into Y
.01986d	7a		ply				ply
.01986e	91 20		sta ($20),y			sta 	(zTempStr),y 				; save at index
.019870	7a		ply				ply 								; restore Y
.019871	c6 1a		dec $1a				dec 	zLTemp1 					; do for each character
.019873	d0 f2		bne $019867			bne 	_CTSCLoop
.019875					_CTSCExit:
.019875	fa		plx				plx 								; restore X
.019876	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/variables.asm

.019877					VariableFind:
.019877	20 e2 98	jsr $0198e2			jsr 	VariableExtract 		; find out all about it ....
.01987a	20 7b 9b	jsr $019b7b			jsr 	VariableLocate 			; does it already exist ?
.01987d	b0 03		bcs $019882			bcs 	_VFExists 				; if so, use that.
.01987f	20 6e 99	jsr $01996e			jsr 	VariableCreate 			; otherwise create it.
.019882					_VFExists:
.019882	a5 24		lda $24				lda 	zVarType 				; is it still an array ?
.019884	29 01		and #$01			and 	#1
.019886	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.019888	d0 28		bne $0198b2			bne 	_VFSingleElement
.01988a					_VFNextIndex:
.01988a	a5 22		lda $22				lda 	zVarDataPtr 			; push the data ptr and type on the stack.
.01988c	48		pha				pha
.01988d	a5 23		lda $23				lda 	zVarDataPtr+1
.01988f	48		pha				pha
.019890	a5 24		lda $24				lda 	zVarType
.019892	48		pha				pha
.019893	20 94 91	jsr $019194			jsr 	EvaluateIntegerX 		; calculate the index.
.019896	68		pla				pla 							; restore and index.
.019897	85 24		sta $24				sta 	zVarType
.019899	68		pla				pla
.01989a	85 23		sta $23				sta 	zVarDataPtr+1
.01989c	68		pla				pla
.01989d	85 22		sta $22				sta 	zVarDataPtr
.01989f	20 f9 99	jsr $0199f9			jsr 	ArrayIndexFollow 		; do the index.
.0198a2	a5 24		lda $24				lda 	zVarType 				; is it still an array ??
.0198a4	29 01		and #$01			and 	#1
.0198a6	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.0198a8	d0 05		bne $0198af			bne 	_VFArrayDone 			; if so then exit.
.0198aa	20 de 97	jsr $0197de			jsr 	CheckNextComma 			; comma should follow
.0198ad	80 db		bra $01988a			bra 	_VFNextIndex
.0198af					_VFArrayDone:
.0198af	20 d6 97	jsr $0197d6			jsr 	CheckNextRParen 		; check closing right bracket.
.0198b2					_VFSingleElement:
.0198b2	60		rts				rts
.0198b3					VariableClear:
.0198b3	48		pha				pha 							; save registers
.0198b4	da		phx				phx
.0198b5	a2 00		ldx #$00			ldx 	#0 						; clear out the hash table.
.0198b7	8a		txa				txa
.0198b8	9d 35 03	sta $0335,x	_VCLoop:sta 	HashTableBase,x
.0198bb	e8		inx				inx
.0198bc	e0 60		cpx #$60			cpx 	#HashTableEnd-HashTableBase
.0198be	d0 f8		bne $0198b8			bne 	_VCLoop
.0198c0	a9 00		lda #$00			lda 	#VariableMemory & $FF
.0198c2	8d 02 03	sta $0302			sta 	VarMemPtr
.0198c5	a9 30		lda #$30			lda 	#VariableMemory >> 8
.0198c7	8d 03 03	sta $0303			sta 	VarMemPtr+1
.0198ca	fa		plx				plx 							; restore registers
.0198cb	68		pla				pla
.0198cc	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/extract.asm

.0198cd					VariableNameError:
.0198cd	20 6e 85	jsr $01856e			jsr ERR_Handler
>0198d0	42 61 64 20 56 61 72 69			.text "Bad Variable Name",0
>0198d8	61 62 6c 65 20 4e 61 6d 65 00
.0198e2					VariableExtract:
.0198e2	da		phx				phx 							; save X.
.0198e3	a9 ba		lda #$ba			lda 	#token_hashlParen  		; set the type to #( e.g. real array.
.0198e5	8d 95 03	sta $0395			sta 	Var_Type
.0198e8	8d 96 03	sta $0396			sta 	Var_Hash 				; we initialise the hash with this. It doesn't matter
.0198eb	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0198ed	c9 00		cmp #$00			cmp 	#0 						; first one must be A-Z
.0198ef	f0 dc		beq $0198cd			beq 	VariableNameError
.0198f1	c9 1b		cmp #$1b			cmp 	#26+1
.0198f3	b0 d8		bcs $0198cd			bcs 	VariableNameError
.0198f5	a2 ff		ldx #$ff			ldx 	#255 					; now copy it into the variable buffer.
.0198f7					_VECopyBuffer:
.0198f7	e8		inx				inx
.0198f8	e0 1f		cpx #$1f			cpx 	#31 					; too long
.0198fa	f0 d1		beq $0198cd			beq 	VariableNameError
.0198fc	9d 15 03	sta $0315,x			sta 	Var_Buffer,x 			; save character
.0198ff	18		clc				clc  							; update the hash value for it.
.019900	6d 96 03	adc $0396			adc 	Var_Hash
.019903	8d 96 03	sta $0396			sta 	Var_Hash
.019906	c8		iny				iny
.019907	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019909	c9 00		cmp #$00			cmp 	#0 						; zero or token, end of variable
.01990b	f0 0e		beq $01991b			beq 	_VECopyEnd
.01990d	30 0c		bmi $01991b			bmi 	_VECopyEnd
.01990f	c9 1b		cmp #$1b			cmp 	#26+1 					; A-Z continue copying
.019911	90 e4		bcc $0198f7			bcc 	_VECopyBuffer
.019913	c9 30		cmp #$30			cmp 	#"0" 					; 0-9 copy as well.
.019915	90 04		bcc $01991b			bcc 	_VECopyEnd
.019917	c9 3a		cmp #$3a			cmp 	#"9"+1
.019919	90 dc		bcc $0198f7			bcc 	_VECopyBuffer
.01991b					_VECopyEnd:
.01991b	c8		iny				iny
.01991c	c9 b7		cmp #$b7			cmp 	#token_Dollar 			; first type token.
.01991e	90 04		bcc $019924			bcc 	_VEDefaultRequired
.019920	c9 bd		cmp #$bd			cmp 	#token_PercentLParen+1	; last type token.
.019922	90 0b		bcc $01992f			bcc 	_VEHaveType
.019924					_VEDefaultRequired:
.019924	c9 bd		cmp #$bd			cmp 	#token_LParen 			; if it ends in ( then use the real array
.019926	f0 04		beq $01992c			beq 	_VESetType 				; default set above.
.019928	ce 95 03	dec $0395			dec 	Var_Type 				; this changes that default to the variable default
.01992b	88		dey				dey
.01992c					_VESetType:
.01992c	ad 95 03	lda $0395			lda 	Var_Type 				; get type ....
.01992f					_VEHaveType:
.01992f	8d 95 03	sta $0395			sta 	Var_Type 				; save as type.
.019932	bd 15 03	lda $0315,x			lda 	Var_Buffer,x 			; set bit 7 of name, marks the end.
.019935	09 80		ora #$80			ora 	#$80
.019937	9d 15 03	sta $0315,x			sta 	Var_Buffer,x
.01993a	e8		inx				inx 							; offset 3 => length 4.
.01993b	8e 97 03	stx $0397			stx 	Var_Length 				; save length of variable name.
.01993e	ad 95 03	lda $0395			lda 	Var_Type 				; get offset of var type from first type token
.019941	38		sec				sec
.019942	e9 b7		sbc #$b7			sbc 	#token_Dollar
.019944	0a		asl a				asl 	a 						; multiply by 16. This requires HashTableSize
.019945	0a		asl a				asl 	a 						; in data.asm to be 8 (8 sets of links,2 bytes each)
.019946	0a		asl a				asl 	a
.019947	0a		asl a				asl 	a
.019948	8d 98 03	sta $0398			sta 	Var_HashAddress
.01994b	ad 96 03	lda $0396			lda 	Var_Hash 				; get the hash
.01994e	29 07		and #$07			and 	#(HashTableSize-1) 		; force into range 0-tableSize-1
.019950	0a		asl a				asl 	a 						; double it (2 bytes per entry) & clears carry
.019951	6d 98 03	adc $0398			adc 	Var_HashAddress 		; add table offset.
.019954	69 35		adc #$35			adc 	#HashTableBase & $FF 	; now the low byte of the actual table address
.019956	8d 98 03	sta $0398			sta 	Var_HashAddress
.019959	a2 05		ldx #$05			ldx 	#5 						; hash is 5 bytes (real)
.01995b	ad 95 03	lda $0395			lda 	Var_Type
.01995e	c9 b9		cmp #$b9			cmp 	#token_Hash
.019960	f0 07		beq $019969			beq 	_VEHaveSize
.019962	ca		dex				dex
.019963	c9 bb		cmp #$bb			cmp 	#token_Percent 			; percent is 4 bytes (integer)
.019965	f0 02		beq $019969			beq 	_VEHaveSize
.019967	a2 02		ldx #$02			ldx 	#2 						; everything else is two.
.019969					_VEHaveSize:
.019969	8e 99 03	stx $0399			stx 	Var_DataSize
.01996c	fa		plx				plx
.01996d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varcreate.asm

.01996e					VariableCreate:
.01996e	da		phx				phx
.01996f	5a		phy				phy
.019970	ad 02 03	lda $0302			lda 	VarMemPtr 					; get address of next free into zTemp1
.019973	85 10		sta $10				sta 	zTemp1
.019975	ad 03 03	lda $0303			lda 	VarMemPtr+1
.019978	85 11		sta $11				sta 	zTemp1+1
.01997a	ad 99 03	lda $0399			lda 	Var_DataSize 				; bytes for the data bit
.01997d	18		clc				clc
.01997e	6d 97 03	adc $0397			adc 	Var_Length 					; add the length of the name
.019981	69 03		adc #$03			adc 	#3 							; 3 for the link and the hash.
.019983	6d 02 03	adc $0302			adc 	VarMemPtr 					; add to variable memory pointer
.019986	8d 02 03	sta $0302			sta 	VarMemPtr
.019989	90 03		bcc $01998e			bcc 	_VCNoCarry
.01998b	ee 03 03	inc $0303			inc 	VarMemPtr+1
.01998e					_VCNoCarry:
.01998e	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.019991	85 12		sta $12				sta 	zTemp2
.019993	a9 03		lda #$03			lda 	#HashTableBase >> 8
.019995	85 13		sta $13				sta 	zTemp2+1
.019997	a0 00		ldy #$00			ldy 	#0 							; put current hash link in position.
.019999	b1 12		lda ($12),y			lda 	(zTemp2),y
.01999b	91 10		sta ($10),y			sta 	(zTemp1),y
.01999d	c8		iny				iny
.01999e	b1 12		lda ($12),y			lda 	(zTemp2),y
.0199a0	91 10		sta ($10),y			sta 	(zTemp1),y
.0199a2	c8		iny				iny
.0199a3	ad 96 03	lda $0396			lda 	Var_Hash 					; write the hash out.
.0199a6	91 10		sta ($10),y			sta 	(zTemp1),y
.0199a8	c8		iny				iny
.0199a9	a2 00		ldx #$00			ldx 	#0 							; copy the name out.
.0199ab					_VCCopyName:
.0199ab	bd 15 03	lda $0315,x			lda 	Var_Buffer,x
.0199ae	91 10		sta ($10),y			sta 	(zTemp1),y
.0199b0	e8		inx				inx
.0199b1	c8		iny				iny
.0199b2	ec 97 03	cpx $0397			cpx 	Var_Length
.0199b5	d0 f4		bne $0199ab			bne 	_VCCopyName
.0199b7	5a		phy				phy 								; save the data offset.
.0199b8	ae 99 03	ldx $0399			ldx 	Var_DataSize 				; and write the data out.
.0199bb	a9 00		lda #$00			lda 	#0 							; which is all zeroes.
.0199bd					_VCClearData:
.0199bd	91 10		sta ($10),y			sta 	(zTemp1),y
.0199bf	c8		iny				iny
.0199c0	ca		dex				dex
.0199c1	d0 fa		bne $0199bd			bne 	_VCClearData
.0199c3	68		pla				pla 								; offset to the data
.0199c4	18		clc				clc
.0199c5	65 10		adc $10				adc 	zTemp1 						; add to start and save as data pointer.
.0199c7	85 22		sta $22				sta 	zVarDataPtr
.0199c9	a5 11		lda $11				lda 	zTemp1+1
.0199cb	69 00		adc #$00			adc 	#0
.0199cd	85 23		sta $23				sta 	zVarDataPtr+1
.0199cf	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.0199d2	85 24		sta $24				sta 	zVarType
.0199d4	a5 10		lda $10				lda 	zTemp1 						; fix hash link to point to new record
.0199d6	a0 00		ldy #$00			ldy 	#0
.0199d8	91 12		sta ($12),y			sta 	(zTemp2),y
.0199da	c8		iny				iny
.0199db	a5 11		lda $11				lda 	zTemp1+1
.0199dd	91 12		sta ($12),y			sta 	(zTemp2),y
.0199df	ad 95 03	lda $0395			lda 	Var_Type 					; array ? if so create the empty one.
.0199e2	29 01		and #$01			and 	#1
.0199e4	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.0199e6	d0 0e		bne $0199f6			bne 	_VCNotArray
.0199e8	a2 00		ldx #$00			ldx 	#0 							; call recursive array creator
.0199ea	20 90 9a	jsr $019a90			jsr 	ArrayCreate
.0199ed	5a		phy				phy 								; save YA at zVarDataPtr
.0199ee	a0 00		ldy #$00			ldy 	#0
.0199f0	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0199f2	c8		iny				iny
.0199f3	68		pla				pla
.0199f4	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0199f6					_VCNotArray:
.0199f6	7a		ply				ply
.0199f7	fa		plx				plx
.0199f8	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arrayidx.asm

.0199f9					ArrayIndexFollow:
.0199f9	5a		phy				phy
.0199fa	a0 00		ldy #$00			ldy 	#0 							; make zVarDataPtr point to the array.
.0199fc	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; e.g. it points to itself.
.0199fe	48		pha				pha
.0199ff	c8		iny				iny
.019a00	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019a02	85 23		sta $23				sta 	zVarDataPtr+1
.019a04	68		pla				pla
.019a05	85 22		sta $22				sta 	zVarDataPtr
.019a07	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; MSB of 16 bit integer and bytes 2&3
.019a09	29 80		and #$80			and 	#$80 						; must be zero.
.019a0b	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019a0d	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019a0f	d0 59		bne $019a6a			bne 	_AIFError
.019a11	a0 00		ldy #$00			ldy 	#0 							; calculate size - current - 1
.019a13	18		clc				clc
.019a14	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019a16	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.019a18	c8		iny				iny
.019a19	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019a1b	08		php				php 								; clear bit 7 retaining borrow.
.019a1c	29 7f		and #$7f			and 	#$7F
.019a1e	28		plp				plp
.019a1f	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.019a21	90 47		bcc $019a6a			bcc 	_AIFError 					; eror if size-current < 0
.019a23	b5 80		lda $80,x			lda  	XS_Mantissa+0,x 			; copy and double the index
.019a25	0a		asl a				asl 	a 							; (e.g. index * 2)
.019a26	85 10		sta $10				sta 	zTemp1
.019a28	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019a2a	2a		rol a				rol 	a
.019a2b	85 11		sta $11				sta 	zTemp1+1
.019a2d	a0 01		ldy #$01			ldy 	#1 							; is this a data entry.
.019a2f	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; if so, then type is unchanged, offset set
.019a31	30 1d		bmi $019a50			bmi 	_AIFCalculate
.019a33	c6 24		dec $24				dec 	zVarType 					; converts from an array to a type.
.019a35	a5 24		lda $24				lda 	zVarType 					; check that type
.019a37	c9 b7		cmp #$b7			cmp 	#token_Dollar 				; if string, use x 2
.019a39	f0 15		beq $019a50			beq 	_AIFCalculate
.019a3b	06 10		asl $10				asl 	zTemp1			 			; double the index
.019a3d	26 11		rol $11				rol 	zTemp1+1					; (e.g. index * 4)
.019a3f	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if integer, use x 4
.019a41	f0 0d		beq $019a50			beq 	_AIFCalculate
.019a43	18		clc				clc 								; add the original mantissa in again
.019a44	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; which makes it x5, for float.
.019a46	65 10		adc $10				adc 	zTemp1
.019a48	85 10		sta $10				sta 	zTemp1
.019a4a	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019a4c	65 11		adc $11				adc 	zTemp1+1
.019a4e	85 11		sta $11				sta 	zTemp1+1
.019a50					_AIFCalculate:
.019a50	18		clc				clc 								; add index x 2,4 or 5 to base
.019a51	a5 22		lda $22				lda 	zVarDataPtr
.019a53	65 10		adc $10				adc 	zTemp1
.019a55	85 22		sta $22				sta 	zVarDataPtr
.019a57	a5 23		lda $23				lda 	zVarDataPtr+1
.019a59	65 11		adc $11				adc 	zTemp1+1
.019a5b	85 23		sta $23				sta 	zVarDataPtr+1
.019a5d	18		clc				clc 								; add 2 more for the length prefix.
.019a5e	a5 22		lda $22				lda 	zVarDataPtr
.019a60	69 02		adc #$02			adc 	#2
.019a62	85 22		sta $22				sta 	zVarDataPtr
.019a64	90 02		bcc $019a68			bcc 	_AIFNoBump
.019a66	e6 23		inc $23				inc 	zVarDataPtr+1
.019a68					_AIFNoBump:
.019a68	7a		ply				ply
.019a69	60		rts				rts
.019a6a					_AIFError:
.019a6a	20 6e 85	jsr $01856e			jsr ERR_Handler
>019a6d	42 61 64 20 61 72 72 61			.text "Bad array index",0
>019a75	79 20 69 6e 64 65 78 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arraydef.asm

.019a7d					ArrayResetDefault:
.019a7d	a9 0b		lda #$0b			lda 	#11 						; 0..10 one array
.019a7f	8d a9 03	sta $03a9			sta 	ArrayDef+0
.019a82	a9 00		lda #$00			lda 	#0
.019a84	8d aa 03	sta $03aa			sta 	ArrayDef+1
.019a87	a9 ff		lda #$ff			lda 	#$FF
.019a89	8d ab 03	sta $03ab			sta 	ArrayDef+2 					; $FFFF implies no second element.
.019a8c	8d ac 03	sta $03ac			sta 	ArrayDef+3					; (test bit 7 of 2nd byte)
.019a8f	60		rts				rts
.019a90					ArrayCreate:
.019a90	bd a9 03	lda $03a9,x			lda 	ArrayDef+0,x 				; put size x 2 in zTemp1
.019a93	0a		asl a				asl 	a
.019a94	85 10		sta $10				sta 	zTemp1
.019a96	bd aa 03	lda $03aa,x			lda 	ArrayDef+1,x
.019a99	2a		rol a				rol 	a
.019a9a	85 11		sta $11				sta 	zTemp1+1
.019a9c	bd ac 03	lda $03ac,x			lda 	ArrayDef+3,x 				; if this is the last element it's array of ptrs.
.019a9f	10 22		bpl $019ac3			bpl 	_ACSized 					; if not multiply size x 2 (str) 4 (int) 5 (real)
.019aa1	ad 95 03	lda $0395			lda 	Var_Type 					; check the type
.019aa4	c9 b8		cmp #$b8			cmp 	#token_DollarLParen 		; also if it is an array of strings $(
.019aa6	f0 1b		beq $019ac3			beq 	_ACSized
.019aa8	06 10		asl $10				asl 	zTemp1 						; double again
.019aaa	26 11		rol $11				rol 	zTemp1+1
.019aac	b0 6f		bcs $019b1d			bcs 	ArrayIndexError 			; too large.
.019aae	c9 bc		cmp #$bc			cmp 	#token_PercentLParen 		; if %( four bytes/entry is enough.
.019ab0	f0 11		beq $019ac3			beq 	_ACSized
.019ab2	18		clc				clc 								; add original value x 5 for reals.
.019ab3	a5 10		lda $10				lda 	zTemp1
.019ab5	7d a9 03	adc $03a9,x			adc 	ArrayDef+0,x
.019ab8	85 10		sta $10				sta 	zTemp1
.019aba	a5 11		lda $11				lda 	zTemp1+1
.019abc	7d aa 03	adc $03aa,x			adc 	ArrayDef+1,x
.019abf	85 11		sta $11				sta 	zTemp1+1
.019ac1	b0 5a		bcs $019b1d			bcs 	ArrayIndexError
.019ac3					_ACSized:
.019ac3	18		clc				clc
.019ac4	a5 10		lda $10				lda 	zTemp1
.019ac6	69 02		adc #$02			adc 	#2
.019ac8	85 10		sta $10				sta 	zTemp1
.019aca	90 04		bcc $019ad0			bcc 	_ACNoBump
.019acc	e6 10		inc $10				inc 	zTemp1
.019ace	f0 4d		beq $019b1d			beq 	ArrayIndexError
.019ad0					_ACNoBump:
.019ad0	18		clc				clc
.019ad1	ad 02 03	lda $0302			lda 	VarMemPtr 					; add this allocated count to VarMemPtr
.019ad4	85 12		sta $12				sta 	zTemp2						; save start in zTemp2/zTemp3
.019ad6	85 14		sta $14				sta 	zTemp3
.019ad8	65 10		adc $10				adc 	zTemp1
.019ada	8d 02 03	sta $0302			sta 	VarMemPtr
.019add	ad 03 03	lda $0303			lda 	VarMemPtr+1
.019ae0	85 13		sta $13				sta 	zTemp2+1
.019ae2	85 15		sta $15				sta 	zTemp3+1
.019ae4	65 11		adc $11				adc 	zTemp1+1
.019ae6	8d 03 03	sta $0303			sta 	VarMemPtr+1
.019ae9	85 11		sta $11				sta 	zTemp1+1
.019aeb	b0 30		bcs $019b1d			bcs 	ArrayIndexError
.019aed	a0 00		ldy #$00			ldy 	#0							; write $00 out.
.019aef					_ACClear:
.019aef	98		tya				tya
.019af0	91 12		sta ($12),y			sta 	(zTemp2),y
.019af2	e6 12		inc $12				inc 	zTemp2
.019af4	d0 02		bne $019af8			bne 	_ACCBump
.019af6	e6 13		inc $13				inc 	zTemp2+1
.019af8					_ACCBump:
.019af8	a5 12		lda $12				lda 	zTemp2
.019afa	cd 02 03	cmp $0302			cmp 	VarMemPtr
.019afd	d0 f0		bne $019aef			bne 	_ACClear
.019aff	a5 13		lda $13				lda 	zTemp2+1
.019b01	cd 03 03	cmp $0303			cmp 	VarMemPtr+1
.019b04	d0 e9		bne $019aef			bne 	_ACClear
.019b06	a0 00		ldy #$00			ldy 	#0
.019b08	bd a9 03	lda $03a9,x			lda 	ArrayDef+0,x 				; copy the size into the start
.019b0b	91 14		sta ($14),y			sta 	(zTemp3),y
.019b0d	c8		iny				iny
.019b0e	bd aa 03	lda $03aa,x			lda 	ArrayDef+1,x
.019b11	91 14		sta ($14),y			sta 	(zTemp3),y
.019b13	bd ac 03	lda $03ac,x			lda 	ArrayDef+3,x 				; have we reached the end
.019b16	10 18		bpl $019b30			bpl 	ACCFillRecursive
.019b18	a4 15		ldy $15				ldy 	zTemp3+1 					; return address
.019b1a	a5 14		lda $14				lda 	zTemp3
.019b1c	60		rts				rts
.019b1d					ArrayIndexError:
.019b1d	20 6e 85	jsr $01856e			jsr ERR_Handler
>019b20	42 61 64 20 61 72 72 61			.text "Bad array index",0
>019b28	79 20 69 6e 64 65 78 00
.019b30					ACCFillRecursive:
.019b30	a9 ff		lda #$ff			lda 	#$FF 						; we mark the end, this is free space.
.019b32	a0 00		ldy #$00			ldy 	#0 							; this is overwritten by size of next allocated
.019b34	91 12		sta ($12),y			sta 	(zTemp2),y 					; array, but we might change that.
.019b36	c8		iny				iny
.019b37	b1 14		lda ($14),y			lda 	(zTemp3),y 					; set bit 15 of the max index indicating
.019b39	09 80		ora #$80			ora 	#$80 						; an array of pointers
.019b3b	91 14		sta ($14),y			sta 	(zTemp3),y
.019b3d	a5 14		lda $14				lda 	zTemp3 						; push the start on the stack
.019b3f	48		pha				pha
.019b40	a5 15		lda $15				lda 	zTemp3+1
.019b42	48		pha				pha
.019b43					_ACCFillLoop:
.019b43	18		clc				clc
.019b44	a5 14		lda $14				lda 	zTemp3 						; and work forwards.
.019b46	69 02		adc #$02			adc 	#2
.019b48	85 14		sta $14				sta 	zTemp3
.019b4a	90 02		bcc $019b4e			bcc 	_ACCSkip2
.019b4c	e6 15		inc $15				inc 	zTemp3+1
.019b4e					_ACCSkip2:
.019b4e	a0 00		ldy #$00			ldy 	#0 							; reached the end ?
.019b50	b1 14		lda ($14),y			lda 	(zTemp3),y					; (looking for FF marker, everything else 00)
.019b52	c8		iny				iny
.019b53	11 14		ora ($14),y			ora 	(zTemp3),y
.019b55	d0 21		bne $019b78			bne 	_ACCExit
.019b57	a5 14		lda $14				lda 	zTemp3 						; push zTemp3
.019b59	48		pha				pha
.019b5a	a5 15		lda $15				lda 	zTemp3+1
.019b5c	48		pha				pha
.019b5d	e8		inx				inx
.019b5e	e8		inx				inx
.019b5f	20 90 9a	jsr $019a90			jsr 	ArrayCreate 				; create array recursively.
.019b62	ca		dex				dex
.019b63	ca		dex				dex
.019b64	85 12		sta $12				sta 	zTemp2 						; save A
.019b66	68		pla				pla
.019b67	85 15		sta $15				sta 	zTemp3+1 					; restore zTemp3
.019b69	68		pla				pla
.019b6a	85 14		sta $14				sta 	zTemp3
.019b6c	98		tya				tya 								; write high bye from Y
.019b6d	a0 01		ldy #$01			ldy 	#1
.019b6f	91 14		sta ($14),y			sta 	(zTemp3),y
.019b71	88		dey				dey 								; write low byte out.
.019b72	a5 12		lda $12				lda 	zTemp2
.019b74	91 14		sta ($14),y			sta 	(zTemp3),y
.019b76	80 cb		bra $019b43			bra 	_ACCFillLoop 				; and try again.
.019b78					_ACCExit:
.019b78	7a		ply				ply 								; restore the original address
.019b79	68		pla				pla
.019b7a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varfind.asm

.019b7b					VariableLocate:
.019b7b	da		phx				phx
.019b7c	5a		phy				phy
.019b7d	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.019b80	85 12		sta $12				sta 	zTemp2 						; points to first address.
.019b82	a9 03		lda #$03			lda 	#HashTableBase >> 8
.019b84	85 13		sta $13				sta 	zTemp2+1
.019b86	a0 00		ldy #$00	_VLNext:ldy 	#0 							; get next link into AX
.019b88	b1 12		lda ($12),y			lda 	(zTemp2),y
.019b8a	aa		tax				tax
.019b8b	c8		iny				iny
.019b8c	b1 12		lda ($12),y			lda 	(zTemp2),y
.019b8e	85 13		sta $13				sta 	zTemp2+1 					; save in zTemp
.019b90	86 12		stx $12				stx 	zTemp2
.019b92	05 12		ora $12				ora 	zTemp2 						; got zero
.019b94	18		clc				clc
.019b95	f0 25		beq $019bbc			beq 	_VLExit 					; if so, then fail as end of chain.
.019b97	c8		iny				iny 								; point to hash (offset + 2)
.019b98	b1 12		lda ($12),y			lda 	(zTemp2),y
.019b9a	cd 96 03	cmp $0396			cmp 	Var_Hash
.019b9d	d0 e7		bne $019b86			bne 	_VLNext 					; try next if different.
.019b9f					_VLCompare:
.019b9f	c8		iny				iny 								; next character
.019ba0	b1 12		lda ($12),y			lda 	(zTemp2),y 					; compare variable field against buffer.
.019ba2	d9 12 03	cmp $0312,y			cmp 	Var_Buffer-3,y 				; the -3 is because name starts at 3.
.019ba5	d0 df		bne $019b86			bne 	_VLNext 					; fail if different, try next.
.019ba7	0a		asl a				asl 	a 							; until end character (bit 7 set) matched
.019ba8	90 f5		bcc $019b9f			bcc 	_VLCompare
.019baa	98		tya				tya
.019bab	38		sec				sec 								; add 1 as Y points to last character
.019bac	65 12		adc $12				adc 	zTemp2 						; add to the current address
.019bae	85 22		sta $22				sta 	zVarDataPtr
.019bb0	a5 13		lda $13				lda 	zTemp2+1
.019bb2	69 00		adc #$00			adc 	#0
.019bb4	85 23		sta $23				sta 	zVarDataPtr+1
.019bb6	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.019bb9	85 24		sta $24				sta 	zVarType
.019bbb	38		sec				sec 								; return CS
.019bbc	7a		ply		_VLExit:ply
.019bbd	fa		plx				plx
.019bbe	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/vargetset.asm

.019bbf					VariableGet:
.019bbf	5a		phy				phy
.019bc0	a0 00		ldy #$00			ldy 	#0 							; copy first two bytes
.019bc2	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019bc4	95 80		sta $80,x			sta 	XS_Mantissa,x
.019bc6	c8		iny				iny
.019bc7	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019bc9	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019bcb	c8		iny				iny
.019bcc	a5 24		lda $24				lda 	zVarType 					; if it is a string, set up for that.
.019bce	c9 b7		cmp #$b7			cmp 	#token_Dollar
.019bd0	f0 2c		beq $019bfe			beq 	_VGString
.019bd2	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; copy the next two bytes.
.019bd4	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019bd6	c8		iny				iny
.019bd7	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019bd9	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019bdb	c8		iny				iny
.019bdc	a9 01		lda #$01			lda 	#1 							; set type to 1.
.019bde	95 85		sta $85,x			sta 	XS_Type,x
.019be0	a5 24		lda $24				lda 	zVarType
.019be2	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if it is a %, then exit with default integer.
.019be4	f0 28		beq $019c0e			beq 	_VGExit
.019be6	a9 40		lda #$40			lda 	#$40 						; set type byte to zero
.019be8	95 85		sta $85,x			sta 	XS_Type,x 					; which is the code for zero/float.
.019bea	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; the last value to copy is the exponent.
.019bec	95 84		sta $84,x			sta 	XS_Exponent,x
.019bee	f0 1e		beq $019c0e			beq 	_VGExit 					; if exponent is zero ... it's zero.
.019bf0	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; the sign bit is the top mantissa bit.
.019bf2	48		pha				pha
.019bf3	29 80		and #$80			and 	#$80
.019bf5	95 85		sta $85,x			sta 	XS_Type,x 					; this is the type byte.
.019bf7	68		pla				pla
.019bf8	09 80		ora #$80			ora 	#$80 						; set the MSB as you would expect.
.019bfa	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; so it's a normalised float.
.019bfc	80 10		bra $019c0e			bra 	_VGExit
.019bfe					_VGString:
.019bfe	a9 02		lda #$02			lda 	#2 							; set type to 2, a string
.019c00	95 85		sta $85,x			sta 	XS_Type,x
.019c02	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; is the value there $0000
.019c04	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019c06	d0 06		bne $019c0e			bne 	_VGExit 					; if not, exit.
.019c08	85 25		sta $25				sta 	zNullString 				; make zNullString a 00 string.
.019c0a	a9 25		lda #$25			lda 	#zNullString
.019c0c	95 80		sta $80,x			sta 	XS_Mantissa,x 				; make it point to it.
.019c0e					_VGExit:
.019c0e	7a		ply				ply
.019c0f	60		rts				rts
.019c10					VariableSet:
.019c10	b5 85		lda $85,x			lda 	XS_Type,x 					; is the result a string
.019c12	29 02		and #$02			and 	#2 							; if so, it has to be
.019c14	d0 4b		bne $019c61			bne 	_VSString
.019c16	a5 24		lda $24				lda 	zVarType 					; if type is $ there's an error.
.019c18	c9 b7		cmp #$b7			cmp 	#token_Dollar
.019c1a	f0 42		beq $019c5e			beq 	_VSBadType
.019c1c	c9 bb		cmp #$bb			cmp 	#token_Percent 				; type convert to float/int
.019c1e	f0 05		beq $019c25			beq 	_VSMakeInt
.019c20	20 86 a1	jsr $01a186			jsr 	FPUToFloat
.019c23	80 03		bra $019c28			bra 	_VSCopy
.019c25					_VSMakeInt:
.019c25	20 d2 a1	jsr $01a1d2			jsr 	FPUToInteger
.019c28					_VSCopy:
.019c28	5a		phy				phy
.019c29	a0 00		ldy #$00			ldy 	#0 							; copy mantissa to target.
.019c2b	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019c2d	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019c2f	c8		iny				iny
.019c30	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019c32	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019c34	c8		iny				iny
.019c35	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019c37	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019c39	c8		iny				iny
.019c3a	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019c3c	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019c3e	a5 24		lda $24				lda 	zVarType 					; if target is integer, alrady done.
.019c40	c9 bb		cmp #$bb			cmp 	#token_Percent
.019c42	f0 18		beq $019c5c			beq 	_VSExit
.019c44	b5 85		lda $85,x			lda 	XS_Type,x 					; get the sign bit into carry flag.
.019c46	0a		asl a				asl 	a
.019c47	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; shift the sign into the mantissa high.
.019c49	08		php				php
.019c4a	0a		asl a				asl 	a
.019c4b	28		plp				plp
.019c4c	6a		ror a				ror 	a
.019c4d	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019c4f	c8		iny				iny
.019c50	b5 84		lda $84,x			lda 	XS_Exponent,x 				; copy the exponent in
.019c52	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019c54	34 85		bit $85,x			bit 	XS_Type,x 					; if the result is non zero
.019c56	50 04		bvc $019c5c			bvc 	_VSExit
.019c58	a9 00		lda #$00			lda 	#00 						; zero exponent indicating 0.
.019c5a	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019c5c					_VSExit:
.019c5c	7a		ply				ply
.019c5d	60		rts				rts
.019c5e					_VSBadType:
.019c5e	4c 4f 85	jmp $01854f			jmp 	TypeError
.019c61					_VSString:
.019c61	a5 24		lda $24				lda 	zVarType 					; type must be $
.019c63	c9 b7		cmp #$b7			cmp 	#token_Dollar
.019c65	d0 f7		bne $019c5e			bne 	_VSBadType
.019c67	da		phx				phx
.019c68	5a		phy				phy
.019c69	20 e6 97	jsr $0197e6			jsr 	StringConcrete 				; concrete the string in the mantissa -> AX
.019c6c	a0 01		ldy #$01			ldy 	#1 							; save high byte
.019c6e	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019c70	88		dey				dey 								; save low byte
.019c71	8a		txa				txa
.019c72	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019c74	7a		ply				ply 								; and exit.
.019c75	fa		plx				plx
.019c76	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.019c77					MulInteger32:
.019c77	b5 80		lda $80,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.019c79	95 8c		sta $8c,x			sta 	XS3_Mantissa,x
.019c7b	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019c7d	95 8d		sta $8d,x			sta 	XS3_Mantissa+1,x
.019c7f	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019c81	95 8e		sta $8e,x			sta 	XS3_Mantissa+2,x
.019c83	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019c85	95 8f		sta $8f,x			sta 	XS3_Mantissa+3,x
.019c87	a9 00		lda #$00			lda 	#0
.019c89	95 80		sta $80,x			sta 	XS_Mantissa+0,x 				; zero +0
.019c8b	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019c8d	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019c8f	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019c91					_BFMMultiply:
.019c91	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.019c93	29 01		and #$01			and 	#1
.019c95	f0 03		beq $019c9a			beq 	_BFMNoAdd
.019c97	20 32 93	jsr $019332			jsr 	AddInteger32
.019c9a					_BFMNoAdd:
.019c9a	16 86		asl $86,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.019c9c	36 87		rol $87,x			rol 	XS2_Mantissa+1,x
.019c9e	36 88		rol $88,x			rol 	XS2_Mantissa+2,x
.019ca0	36 89		rol $89,x			rol 	XS2_Mantissa+3,x
.019ca2	56 8f		lsr $8f,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.019ca4	76 8e		ror $8e,x			ror 	XS3_Mantissa+2,x
.019ca6	76 8d		ror $8d,x			ror 	XS3_Mantissa+1,x
.019ca8	76 8c		ror $8c,x			ror 	XS3_Mantissa,x
.019caa	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.019cac	15 8d		ora $8d,x			ora 	XS3_Mantissa+1,x
.019cae	15 8e		ora $8e,x			ora 	XS3_Mantissa+2,x
.019cb0	15 8f		ora $8f,x			ora 	XS3_Mantissa+3,x
.019cb2	d0 dd		bne $019c91			bne 	_BFMMultiply
.019cb4	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.019cb5					DivInteger32:
.019cb5	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; check for /0
.019cb7	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.019cb9	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.019cbb	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.019cbd	d0 14		bne $019cd3			bne 	_BFDOkay
.019cbf	20 6e 85	jsr $01856e			jsr ERR_Handler
>019cc2	44 69 76 69 73 69 6f 6e			.text "Division by Zero",0
>019cca	20 62 79 20 5a 65 72 6f 00
.019cd3					_BFDOkay:
.019cd3	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.019cd5	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.019cd7	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.019cd9	85 1c		sta $1c				sta 	zLTemp1+2
.019cdb	85 1d		sta $1d				sta 	zLTemp1+3
.019cdd	8d 9e 03	sta $039e			sta 	SignCount 					; Count of signs.
.019ce0	20 37 9d	jsr $019d37			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.019ce3	da		phx				phx
.019ce4	e8		inx				inx
.019ce5	e8		inx				inx
.019ce6	e8		inx				inx
.019ce7	e8		inx				inx
.019ce8	e8		inx				inx
.019ce9	e8		inx				inx
.019cea	20 37 9d	jsr $019d37			jsr 	CheckIntegerNegate
.019ced	fa		plx				plx
.019cee	5a		phy				phy 								; Y is the counter
.019cef	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.019cf1					_BFDLoop:
.019cf1	16 80		asl $80,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.019cf3	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.019cf5	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.019cf7	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.019cf9	26 1a		rol $1a				rol 	zLTemp1
.019cfb	26 1b		rol $1b				rol 	zLTemp1+1
.019cfd	26 1c		rol $1c				rol 	zLTemp1+2
.019cff	26 1d		rol $1d				rol 	zLTemp1+3
.019d01	38		sec				sec
.019d02	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.019d04	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.019d06	48		pha				pha
.019d07	a5 1b		lda $1b				lda 	zLTemp1+1
.019d09	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.019d0b	48		pha				pha
.019d0c	a5 1c		lda $1c				lda 	zLTemp1+2
.019d0e	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.019d10	48		pha				pha
.019d11	a5 1d		lda $1d				lda 	zLTemp1+3
.019d13	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.019d15	90 13		bcc $019d2a			bcc 	_BFDNoAdd
.019d17	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.019d19	68		pla				pla
.019d1a	85 1c		sta $1c				sta 	zLTemp1+2
.019d1c	68		pla				pla
.019d1d	85 1b		sta $1b				sta 	zLTemp1+1
.019d1f	68		pla				pla
.019d20	85 1a		sta $1a				sta 	zLTemp1+0
.019d22	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.019d24	09 01		ora #$01			ora 	#1
.019d26	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019d28	80 03		bra $019d2d			bra 	_BFDNext
.019d2a					_BFDNoAdd:
.019d2a	68		pla				pla 								; Throw away the intermediate calculations
.019d2b	68		pla				pla
.019d2c	68		pla				pla
.019d2d					_BFDNext:
.019d2d	88		dey				dey
.019d2e	d0 c1		bne $019cf1			bne 	_BFDLoop
.019d30	7a		ply				ply 								; restore Y and exit
.019d31	4e 9e 03	lsr $039e			lsr 	SignCount 					; if sign count odd,
.019d34	b0 06		bcs $019d3c			bcs		IntegerNegateAlways 			; negate the result
.019d36	60		rts				rts
.019d37					CheckIntegerNegate:
.019d37	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019d39	30 01		bmi $019d3c			bmi 	IntegerNegateAlways
.019d3b	60		rts				rts
.019d3c					IntegerNegateAlways:
.019d3c	ee 9e 03	inc $039e			inc 	SignCount
.019d3f	38		sec				sec
.019d40	a9 00		lda #$00			lda 	#0
.019d42	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.019d44	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019d46	a9 00		lda #$00			lda 	#0
.019d48	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.019d4a	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019d4c	a9 00		lda #$00			lda 	#0
.019d4e	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.019d50	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019d52	a9 00		lda #$00			lda 	#0
.019d54	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.019d56	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019d58	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.019d59					INTToString:
.019d59	48		pha				pha
.019d5a	5a		phy				phy
.019d5b	b5 83		lda $83,x			lda 		XS_Mantissa+3,x 		; check -ve
.019d5d	10 08		bpl $019d67			bpl 		_ITSNotMinus
.019d5f	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.019d61	20 fb 9d	jsr $019dfb			jsr 		ITSOutputCharacter
.019d64	20 3c 9d	jsr $019d3c			jsr 		IntegerNegateAlways 	; negate the number.
.019d67					_ITSNotMinus:
.019d67	a9 00		lda #$00			lda 		#0
.019d69	8d 9a 03	sta $039a			sta 		NumSuppress 			; clear the suppression flag.
.019d6c	8a		txa				txa 								; use Y for the mantissa index.
.019d6d	a8		tay				tay
.019d6e	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.019d70					_ITSNextSubtractor:
.019d70	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.019d72	8d 9b 03	sta $039b			sta 		NumConvCount
.019d75					_ITSSubtract:
.019d75	38		sec				sec
.019d76	b9 80 00	lda $0080,y			lda 		XS_Mantissa,y 			; subtract number and push on stack
.019d79	ff d7 9d 01	sbc $019dd7,x			sbc 		_ITSSubtractors+0,x
.019d7d	48		pha				pha
.019d7e	b9 81 00	lda $0081,y			lda 		XS_Mantissa+1,y
.019d81	ff d8 9d 01	sbc $019dd8,x			sbc 		_ITSSubtractors+1,x
.019d85	48		pha				pha
.019d86	b9 82 00	lda $0082,y			lda 		XS_Mantissa+2,y
.019d89	ff d9 9d 01	sbc $019dd9,x			sbc 		_ITSSubtractors+2,x
.019d8d	48		pha				pha
.019d8e	b9 83 00	lda $0083,y			lda 		XS_Mantissa+3,y
.019d91	ff da 9d 01	sbc $019dda,x			sbc 		_ITSSubtractors+3,x
.019d95	90 14		bcc $019dab			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.019d97	99 83 00	sta $0083,y			sta 		XS_Mantissa+3,y 		; save subtract off stack
.019d9a	68		pla				pla
.019d9b	99 82 00	sta $0082,y			sta 		XS_Mantissa+2,y
.019d9e	68		pla				pla
.019d9f	99 81 00	sta $0081,y			sta 		XS_Mantissa+1,y
.019da2	68		pla				pla
.019da3	99 80 00	sta $0080,y			sta 		XS_Mantissa+0,y
.019da6	ee 9b 03	inc $039b			inc 		NumConvCount 			; bump count.
.019da9	80 ca		bra $019d75			bra 		_ITSSubtract 			; go round again.
.019dab					_ITSCantSubtract:
.019dab	68		pla				pla 								; throw away interim answers
.019dac	68		pla				pla
.019dad	68		pla				pla
.019dae	ad 9b 03	lda $039b			lda 		NumConvCount 			; if not zero then no suppression check
.019db1	c9 30		cmp #$30			cmp 		#"0"
.019db3	d0 05		bne $019dba			bne 		_ITSOutputDigit
.019db5	ad 9a 03	lda $039a			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.019db8	10 09		bpl $019dc3			bpl	 		_ITSGoNextSubtractor
.019dba					_ITSOutputDigit:
.019dba	ce 9a 03	dec $039a			dec 		NumSuppress 			; suppression check will be non-zero.
.019dbd	ad 9b 03	lda $039b			lda 		NumConvCount 			; count of subtractions
.019dc0	20 fb 9d	jsr $019dfb			jsr 		ITSOutputCharacter 		; output it.
.019dc3					_ITSGoNextSubtractor:
.019dc3	e8		inx				inx 								; next dword
.019dc4	e8		inx				inx
.019dc5	e8		inx				inx
.019dc6	e8		inx				inx
.019dc7	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.019dc9	d0 a5		bne $019d70			bne 		_ITSNextSubtractor 		; do all the subtractors.
.019dcb	98		tya				tya 								; X is back as the mantissa index
.019dcc	aa		tax				tax
.019dcd	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.019dcf	09 30		ora #$30			ora 		#"0"
.019dd1	20 fb 9d	jsr $019dfb			jsr 		ITSOutputCharacter
.019dd4	7a		ply				ply 								; and exit
.019dd5	68		pla				pla
.019dd6	60		rts				rts
.019dd7					_ITSSubtractors:
>019dd7	00 ca 9a 3b					.dword 		1000000000
>019ddb	00 e1 f5 05					.dword 		100000000
>019ddf	80 96 98 00					.dword 		10000000
>019de3	40 42 0f 00					.dword 		1000000
>019de7	a0 86 01 00					.dword 		100000
>019deb	10 27 00 00					.dword 		10000
>019def	e8 03 00 00					.dword 		1000
>019df3	64 00 00 00					.dword 		100
>019df7	0a 00 00 00					.dword 		10
.019dfb					_ITSSubtractorsEnd:
.019dfb					ITSOutputCharacter:
.019dfb	48		pha				pha
.019dfc	da		phx				phx
.019dfd	ae 14 03	ldx $0314			ldx 	NumBufX 					; save digit
.019e00	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.019e03	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.019e05	9d 16 03	sta $0316,x			sta 	Num_Buffer+1,x
.019e08	ee 14 03	inc $0314			inc 	NumBufX						; bump pointer.
.019e0b	fa		plx				plx
.019e0c	68		pla				pla
.019e0d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.019e0e					IntFromString:
.019e0e	a0 00		ldy #$00			ldy 	#0
.019e10	8c 9c 03	sty $039c			sty 	ExpTemp 					; this is the converted digit count.
.019e13					IntFromStringY:
.019e13	48		pha				pha
.019e14	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.019e16	95 80		sta $80,x			sta 	XS_Mantissa,x
.019e18	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019e1a	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019e1c	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019e1e	a9 01		lda #$01			lda 	#1
.019e20	95 85		sta $85,x			sta 	XS_Type,x
.019e22					_IFSLoop:
.019e22	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.019e24	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.019e26	90 4e		bcc $019e76			bcc 	_IFSExit
.019e28	c9 3a		cmp #$3a			cmp 	#"9"+1
.019e2a	b0 4a		bcs $019e76			bcs 	_IFSExit
.019e2c	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.019e2e	c9 0c		cmp #$0c			cmp 	#12
.019e30	b0 4e		bcs $019e80			bcs 	_IFSOverflow
.019e32	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.019e34	48		pha				pha
.019e35	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019e37	48		pha				pha
.019e38	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019e3a	48		pha				pha
.019e3b	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019e3d	48		pha				pha
.019e3e	20 95 9e	jsr $019e95			jsr 	IFSX1ShiftLeft 				; double
.019e41	20 95 9e	jsr $019e95			jsr 	IFSX1ShiftLeft 				; x 4
.019e44	18		clc				clc 								; add saved value x 5
.019e45	68		pla				pla
.019e46	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.019e48	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019e4a	68		pla				pla
.019e4b	75 81		adc $81,x			adc 	XS_Mantissa+1,x
.019e4d	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019e4f	68		pla				pla
.019e50	75 82		adc $82,x			adc 	XS_Mantissa+2,x
.019e52	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019e54	68		pla				pla
.019e55	75 83		adc $83,x			adc 	XS_Mantissa+3,x
.019e57	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019e59	20 95 9e	jsr $019e95			jsr 	IFSX1ShiftLeft 				; x 10
.019e5c	ee 9c 03	inc $039c			inc 	ExpTemp 					; bump count of digits processed.
.019e5f	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.019e61	29 0f		and #$0f			and 	#15
.019e63	c8		iny				iny
.019e64	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.019e66	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019e68	90 b8		bcc $019e22			bcc 	_IFSLoop
.019e6a	f6 81		inc $81,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.019e6c	d0 b4		bne $019e22			bne 	_IFSLoop
.019e6e	f6 82		inc $82,x			inc 	XS_Mantissa+2,x
.019e70	d0 b0		bne $019e22			bne 	_IFSLoop
.019e72	f6 83		inc $83,x			inc 	XS_Mantissa+3,x
.019e74	80 ac		bra $019e22			bra 	_IFSLoop
.019e76					_IFSExit:
.019e76	98		tya				tya 								; get offset
.019e77					_IFSOkay:
.019e77	38		sec				sec
.019e78	ad 9c 03	lda $039c			lda 	ExpTemp
.019e7b	f0 01		beq $019e7e			beq 	_IFSSkipFail
.019e7d	18		clc				clc
.019e7e					_IFSSkipFail:
.019e7e	68		pla				pla 								; and exit.
.019e7f	60		rts				rts
.019e80					_IFSOverflow:
.019e80	20 6e 85	jsr $01856e			jsr 	ERR_Handler
>019e83	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>019e8b	20 6f 76 65 72 66 6c 6f 77 00
.019e95					IFSX1ShiftLeft:
.019e95	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.019e97	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.019e99	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.019e9b	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.019e9d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.019e9e					FPSubtract:
.019e9e	48		pha				pha
.019e9f	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.019ea1	49 80		eor #$80			eor 	#$80
.019ea3	95 8b		sta $8b,x			sta 	XS2_Type,x
.019ea5	68		pla				pla 								; --- and fall through ---
.019ea6					FPAdd:
.019ea6	48		pha				pha
.019ea7	b5 85		lda $85,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.019ea9	d0 05		bne $019eb0			bne 	_FPA_NegativeLHS
.019eab	20 c7 9e	jsr $019ec7			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.019eae	68		pla				pla
.019eaf	60		rts				rts
.019eb0					_FPA_NegativeLHS:
.019eb0	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.019eb2	49 80		eor #$80			eor 	#$80
.019eb4	95 85		sta $85,x			sta 	XS_Type,x
.019eb6	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of B and add
.019eb8	49 80		eor #$80			eor 	#$80
.019eba	95 8b		sta $8b,x			sta 	XS2_Type,x
.019ebc	20 c7 9e	jsr $019ec7			jsr 	FPAdd_Worker 				; do the add calculation.
.019ebf	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 back
.019ec1	49 80		eor #$80			eor 	#$80
.019ec3	95 85		sta $85,x			sta 	XS_Type,x
.019ec5	68		pla				pla
.019ec6	60		rts				rts
.019ec7					FPAdd_Worker:
.019ec7	34 8b		bit $8b,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.019ec9	70 07		bvs $019ed2			bvs 	_FPAWExit 					; no change.
.019ecb	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.019ecd	50 07		bvc $019ed6			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.019ecf	20 44 a1	jsr $01a144			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.019ed2					_FPAWExit:
.019ed2	20 b3 a1	jsr $01a1b3			jsr 	FPUNormalise 				; normalise the result.
.019ed5	60		rts				rts
.019ed6					_FPAWMakeSame:
.019ed6	b5 84		lda $84,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.019ed8	38		sec				sec
.019ed9	f5 8a		sbc $8a,x			sbc	 	XS2_Exponent,x 				; using subtraction
.019edb	f0 16		beq $019ef3			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.019edd	da		phx				phx 								; save X
.019ede	90 06		bcc $019ee6			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.019ee0	e8		inx				inx
.019ee1	e8		inx				inx
.019ee2	e8		inx				inx
.019ee3	e8		inx				inx
.019ee4	e8		inx				inx
.019ee5	e8		inx				inx
.019ee6					_FPAWShiftA:
.019ee6	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.019ee8	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.019eea	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.019eec	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.019eee	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.019ef0	fa		plx				plx 								; restore original X
.019ef1	80 e3		bra $019ed6			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.019ef3					_FPAW_DoArithmetic:
.019ef3	34 8b		bit $8b,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.019ef5	30 28		bmi $019f1f			bmi 	_FPAW_BNegative
.019ef7	18		clc				clc
.019ef8	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019efa	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.019efc	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019efe	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019f00	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.019f02	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019f04	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019f06	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.019f08	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019f0a	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019f0c	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.019f0e	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019f10	90 c0		bcc $019ed2			bcc 	_FPAWExit 					; no carry.
.019f12	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.019f14	38		sec				sec
.019f15	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.019f17	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.019f19	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.019f1b	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.019f1d	80 b3		bra $019ed2			bra 	_FPAWExit
.019f1f					_FPAW_BNegative:
.019f1f	38		sec				sec
.019f20	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019f22	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.019f24	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019f26	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019f28	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.019f2a	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019f2c	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019f2e	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.019f30	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019f32	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019f34	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.019f36	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019f38	b0 09		bcs $019f43			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.019f3a	20 6a a1	jsr $01a16a			jsr 	FPUNegateInteger			; negate the mantissa
.019f3d	b5 85		lda $85,x			lda 	XS_Type,x 					; flip result sign
.019f3f	49 80		eor #$80			eor 	#$80
.019f41	95 85		sta $85,x			sta 	XS_Type,x
.019f43					_FPAWGoExit:
.019f43	4c d2 9e	jmp $019ed2			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.019f46					FPD_IsDivZero:
.019f46	20 6e 85	jsr $01856e			jsr ERR_Handler
>019f49	44 69 76 69 73 69 6f 6e			.text "Division by zero",0
>019f51	20 62 79 20 7a 65 72 6f 00
.019f5a					FPDivide:
.019f5a	48		pha				pha
.019f5b	5a		phy				phy
.019f5c	34 8b		bit $8b,x			bit 	XS2_Type,x 					; check if division by zero
.019f5e	70 e6		bvs $019f46			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.019f60	34 85		bit $85,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.019f62	f0 03		beq $019f67			beq 	_FPDCalculateExp
.019f64					_FPD_Exit:
.019f64	7a		ply				ply
.019f65	68		pla				pla
.019f66	60		rts				rts
.019f67					_FPDCalculateExp:
.019f67	b5 8a		lda $8a,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.019f69	49 ff		eor #$ff			eor 	#$FF
.019f6b	1a		inc a				inc 	a
.019f6c	95 8a		sta $8a,x			sta 	XS2_Exponent,x
.019f6e	20 3e a0	jsr $01a03e			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.019f71	18		clc				clc 	 							; add 1 to the resulting exponent
.019f72	69 01		adc #$01			adc 	#1
.019f74	b0 54		bcs $019fca			bcs 	_FPD_Overflow 				; which can overflow.
.019f76	95 84		sta $84,x			sta 	XS_Exponent,x
.019f78	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.019f7a	85 1a		sta $1a				sta 	zLTemp1+0
.019f7c	85 1b		sta $1b				sta 	zLTemp1+1
.019f7e	85 1c		sta $1c				sta 	zLTemp1+2
.019f80	85 1d		sta $1d				sta 	zLTemp1+3
.019f82	a0 20		ldy #$20			ldy 	#32 						; times round.
.019f84					_FPD_Loop:
.019f84	38		sec				sec 								; calculate X1-X2 stacking result because we might
.019f85	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; not save it.
.019f87	f5 86		sbc $86,x			sbc 	XS2_Mantissa,x
.019f89	48		pha				pha
.019f8a	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019f8c	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.019f8e	48		pha				pha
.019f8f	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019f91	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.019f93	48		pha				pha
.019f94	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019f96	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.019f98	90 13		bcc $019fad			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.019f9a	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; save results out to A
.019f9c	68		pla				pla
.019f9d	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019f9f	68		pla				pla
.019fa0	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019fa2	68		pla				pla
.019fa3	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019fa5	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.019fa7	09 80		ora #$80			ora 	#$80
.019fa9	85 1d		sta $1d				sta 	zLTemp1+3
.019fab	80 03		bra $019fb0			bra 	_FPD_Rotates
.019fad					_FPD_NoSubtract:
.019fad	68		pla				pla 								; throw away unwanted results
.019fae	68		pla				pla
.019faf	68		pla				pla
.019fb0					_FPD_Rotates:
.019fb0	56 89		lsr $89,x			lsr 	3+XS2_Mantissa,x
.019fb2	76 88		ror $88,x			ror 	2+XS2_Mantissa,x
.019fb4	76 87		ror $87,x			ror 	1+XS2_Mantissa,x
.019fb6	76 86		ror $86,x			ror 	0+XS2_Mantissa,x
.019fb8	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.019fba	26 1b		rol $1b				rol 	zLTemp1+1
.019fbc	26 1c		rol $1c				rol 	zLTemp1+2
.019fbe	26 1d		rol $1d				rol 	zLTemp1+3
.019fc0	90 02		bcc $019fc4			bcc 	_FPD_NoCarry
.019fc2	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.019fc4					_FPD_NoCarry:
.019fc4	88		dey				dey 								; do 32 times
.019fc5	d0 bd		bne $019f84			bne 	_FPD_Loop
.019fc7	4c 22 a0	jmp $01a022			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.019fca					_FPD_Overflow:
.019fca	4c 10 a2	jmp $01a210			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.019fcd					FPMultiply:
.019fcd	48		pha				pha
.019fce	5a		phy				phy
.019fcf	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.019fd1	70 07		bvs $019fda			bvs 	_FPM_Exit
.019fd3	34 8b		bit $8b,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.019fd5	50 06		bvc $019fdd			bvc 	_FPM_CalcExponent
.019fd7	20 44 a1	jsr $01a144			jsr 	FPUCopyX2ToX1
.019fda					_FPM_Exit:
.019fda	7a		ply				ply
.019fdb	68		pla				pla
.019fdc	60		rts				rts
.019fdd					_FPM_CalcExponent:
.019fdd	18		clc				clc
.019fde	20 3e a0	jsr $01a03e			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.019fe1	95 84		sta $84,x			sta 	XS_Exponent,x 				; save the result.
.019fe3	a9 00		lda #$00			lda 	#0
.019fe5	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.019fe7	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.019fe9	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.019feb	85 1d		sta $1d				sta 	zLTemp1+3
.019fed	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.019fef					_FPM_Loop:
.019fef	b5 80		lda $80,x			lda 	XS_Mantissa,x				; check LSB of long product
.019ff1	29 01		and #$01			and 	#1
.019ff3	18		clc				clc 								; clear carry for the long rotate.
.019ff4	f0 19		beq $01a00f			beq 	_FPM_NoAddition
.019ff6	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.019ff7	a5 1a		lda $1a				lda 	zLTemp1+0
.019ff9	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.019ffb	85 1a		sta $1a				sta 	zLTemp1+0
.019ffd	a5 1b		lda $1b				lda 	zLTemp1+1
.019fff	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.01a001	85 1b		sta $1b				sta 	zLTemp1+1
.01a003	a5 1c		lda $1c				lda 	zLTemp1+2
.01a005	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.01a007	85 1c		sta $1c				sta 	zLTemp1+2
.01a009	a5 1d		lda $1d				lda 	zLTemp1+3
.01a00b	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.01a00d	85 1d		sta $1d				sta 	zLTemp1+3
.01a00f					_FPM_NoAddition:
.01a00f	66 1d		ror $1d				ror 	3+zLTemp1
.01a011	66 1c		ror $1c				ror 	2+zLTemp1
.01a013	66 1b		ror $1b				ror 	1+zLTemp1
.01a015	66 1a		ror $1a				ror 	0+zLTemp1
.01a017	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.01a019	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a01b	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a01d	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a01f	88		dey				dey
.01a020	d0 cd		bne $019fef			bne 	_FPM_Loop 					; do this 32 times.
.01a022					FPM_CopySignNormalize:
.01a022	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.01a024	95 80		sta $80,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.01a026	a5 1b		lda $1b				lda 	zLTemp1+1
.01a028	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a02a	a5 1c		lda $1c				lda 	zLTemp1+2
.01a02c	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a02e	a5 1d		lda $1d				lda 	zLTemp1+3
.01a030	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a032	b5 85		lda $85,x			lda 	XS_Type,x 					; sign is xor of signs
.01a034	55 8b		eor $8b,x			eor 	XS2_Type,x
.01a036	95 85		sta $85,x			sta 	XS_Type,x
.01a038	20 b3 a1	jsr $01a1b3			jsr 	FPUNormalise 				; normalise and exit.
.01a03b	7a		ply				ply
.01a03c	68		pla				pla
.01a03d	60		rts				rts
.01a03e					FPCalculateExponent:
.01a03e	18		clc				clc
.01a03f	b5 84		lda $84,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.01a041	75 8a		adc $8a,x			adc 	XS2_Exponent,x
.01a043	b0 08		bcs $01a04d			bcs 	_FPCECarry 					; carry out ?
.01a045	10 03		bpl $01a04a			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.01a047	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.01a049	60		rts				rts
.01a04a					_FPCEExpZero:
.01a04a	a9 00		lda #$00			lda 	#0
.01a04c	60		rts				rts
.01a04d					_FPCECarry:
.01a04d	30 03		bmi $01a052			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.01a04f	09 80		ora #$80			ora 	#$80 						; put in right range
.01a051	60		rts				rts
.01a052					_FPCEOverflow:
.01a052	4c 10 a2	jmp $01a210			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.01a055					FPFractionalPart:
.01a055	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.01a057	38		sec				sec 								; this flag tells us to keep the fractional part
.01a058	30 0d		bmi $01a067			bmi 	FPGetPart
.01a05a	60		rts				rts
.01a05b					FPIntegerPart:
.01a05b	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.01a05d	18		clc				clc 								; this flag says keep the integer part.
.01a05e	30 07		bmi $01a067			bmi 	FPGetPart 					; -ve exponents are 0..127
.01a060	48		pha				pha
.01a061	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.01a063	95 85		sta $85,x			sta 	XS_Type,x
.01a065	68		pla				pla
.01a066	60		rts				rts
.01a067					FPGetPart:
.01a067	48		pha				pha
.01a068	5a		phy				phy 								; save Y
.01a069	08		php				php 								; save action
.01a06a	34 85		bit $85,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.01a06c	70 59		bvs $01a0c7			bvs 	_FPGP_Exit 					; then do nothing.
.01a06e	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.01a070	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.01a072	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.01a074	85 1c		sta $1c				sta 	zLTemp1+2
.01a076	85 1d		sta $1d				sta 	zLTemp1+3
.01a078	b5 84		lda $84,x			lda 	XS_Exponent,x				; the number of shifts.
.01a07a	38		sec				sec
.01a07b	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.01a07d	f0 12		beq $01a091			beq 	_FPGP_NoShift 				; ... if any
.01a07f	c9 20		cmp #$20			cmp 	#32
.01a081	90 02		bcc $01a085			bcc 	_FPGP_NotMax
.01a083	a9 20		lda #$20			lda 	#32 						; max of 32.
.01a085					_FPGP_NotMax:
.01a085	a8		tay				tay 								; Y is the mask shift count.
.01a086					_FPGP_ShiftMask:
.01a086	46 1d		lsr $1d				lsr 	3+zLTemp1
.01a088	66 1c		ror $1c				ror 	2+zLTemp1
.01a08a	66 1b		ror $1b				ror 	1+zLTemp1
.01a08c	66 1a		ror $1a				ror 	0+zLTemp1
.01a08e	88		dey				dey
.01a08f	d0 f5		bne $01a086			bne 	_FPGP_ShiftMask
.01a091					_FPGP_NoShift:
.01a091	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.01a093	8e 9c 03	stx $039c			stx 	ExpTemp						; save X
.01a096					_FPGP_MaskLoop:
.01a096	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.01a099	28		plp				plp 								; if CC we keep the top part, so we
.01a09a	08		php				php		 							; flip the mask.
.01a09b	b0 02		bcs $01a09f			bcs		_FPGP_NoFlip
.01a09d	49 ff		eor #$ff			eor 	#$FF
.01a09f					_FPGP_NoFlip:
.01a09f	35 80		and $80,x			and 	XS_Mantissa,x 				; and into the mantissa.
.01a0a1	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a0a3	e8		inx				inx
.01a0a4	c8		iny				iny
.01a0a5	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.01a0a7	d0 ed		bne $01a096			bne 	_FPGP_MaskLoop
.01a0a9	ae 9c 03	ldx $039c			ldx 	ExpTemp						; restore X
.01a0ac	28		plp				plp
.01a0ad	08		php				php 								; get action flag on the stack
.01a0ae	90 04		bcc $01a0b4			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.01a0b0	a9 00		lda #$00			lda 	#0
.01a0b2	95 85		sta $85,x			sta 	XS_Type,x
.01a0b4					_FPGP_NotFractional:
.01a0b4	b5 80		lda $80,x			lda 	XS_Mantissa,x 						; check if \1 zero
.01a0b6	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.01a0b8	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01a0ba	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01a0bc	f0 05		beq $01a0c3			beq 	_FPGP_Zero 					; if zero, return zero
.01a0be	20 b3 a1	jsr $01a1b3			jsr 	FPUNormalise
.01a0c1	80 04		bra $01a0c7			bra 	_FPGP_Exit 					; and exit
.01a0c3					_FPGP_Zero:
.01a0c3	a9 40		lda #$40			lda 	#$40 						; set zero flag
.01a0c5	95 85		sta $85,x			sta 	XS_Type,x
.01a0c7					_FPGP_Exit:
.01a0c7	68		pla				pla 								; throw saved action flag.
.01a0c8	7a		ply				ply
.01a0c9	68		pla				pla
.01a0ca	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.01a0cb					FPCompare:
.01a0cb	20 0c a1	jsr $01a10c			jsr 	FPFastCompare 				; fast compare try first
.01a0ce	b0 3b		bcs $01a10b			bcs 	_FPCExit 					; that worked.
.01a0d0	b5 84		lda $84,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.01a0d2	48		pha				pha
.01a0d3	b5 8a		lda $8a,x			lda 	XS2_Exponent,x
.01a0d5	48		pha				pha
.01a0d6	20 9e 9e	jsr $019e9e			jsr 	FPSubtract 					; calculate X1-X2
.01a0d9	34 85		bit $85,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.01a0db	70 2a		bvs $01a107			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.01a0dd	68		pla				pla
.01a0de	8d 9c 03	sta $039c			sta 	ExpTemp						; save first exponent in temporary reg.
.01a0e1	68		pla				pla
.01a0e2	38		sec				sec
.01a0e3	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; calculate AX-BX
.01a0e6	70 14		bvs $01a0fc			bvs 	_FPCNotEqual				; overflow, can't be equal.
.01a0e8	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.01a0e9	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.01a0eb	b0 0f		bcs $01a0fc			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.01a0ed	38		sec				sec
.01a0ee	ad 9c 03	lda $039c			lda 	ExpTemp 					; get one of the exponents back.
.01a0f1	e9 12		sbc #$12			sbc 	#18 						; allow for 2^18 error, relatively.
.01a0f3	b0 02		bcs $01a0f7			bcs 	_FPCNotRange 				; keep in range.
.01a0f5	a9 01		lda #$01			lda 	#1
.01a0f7					_FPCNotRange:
.01a0f7	38		sec				sec
.01a0f8	f5 84		sbc $84,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.01a0fa	b0 0d		bcs $01a109			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.01a0fc					_FPCNotEqual:
.01a0fc	b5 85		lda $85,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.01a0fe	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.01a100	f0 02		beq $01a104			beq 	_FPCNE2
.01a102	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.01a104	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.01a105	80 04		bra $01a10b			bra 	_FPCExit
.01a107					_FPCPullZero:
.01a107	68		pla				pla 								; throw saved exponents
.01a108	68		pla				pla
.01a109					_FPCZero:
.01a109	a9 00		lda #$00			lda 	#0 							; and return zero
.01a10b					_FPCExit:
.01a10b	60		rts				rts
.01a10c					FPFastCompare:
.01a10c	34 85		bit $85,x			bit 	XS_Type,x 					; n1 is zero.
.01a10e	70 23		bvs $01a133			bvs 	_FPFLeftZero
.01a110	34 8b		bit $8b,x			bit 	XS2_Type,x 					; n2 is zero
.01a112	b5 85		lda $85,x			lda 	XS_Type,x 					; if so, return sign bit of 1 (n-0)
.01a114	70 25		bvs $01a13b			bvs 	_FPFSignBit
.01a116	55 8b		eor $8b,x			eor 	XS2_Type,x 					; eor 2 type bits. now know both non-zero
.01a118	0a		asl a				asl 	a 							; put in CS if different.
.01a119	b5 85		lda $85,x			lda 	XS_Type,x 					; if signs different return sign of first
.01a11b	b0 1e		bcs $01a13b			bcs 	_FPFSignBit
.01a11d	38		sec				sec 								; same sign and not-zero. compare exponents
.01a11e	b5 84		lda $84,x			lda 	XS_Exponent,x 				; compare exponents. if the same, then fail.
.01a120	f5 8a		sbc $8a,x			sbc 	XS2_Exponent,x 				; e.g. we have to do it via subtraction.
.01a122	f0 09		beq $01a12d			beq 	_FPNoFastCompare
.01a124	6a		ror a				ror 	a 							; put carry into bit 7.
.01a125	34 85		bit $85,x			bit 	XS_Type,X 					; if it is +x then flip it.
.01a127	30 02		bmi $01a12b			bmi		_FPFCNotMinus
.01a129	49 80		eor #$80			eor 	#$80
.01a12b					_FPFCNotMinus:
.01a12b	80 0e		bra $01a13b			bra		_FPFSignBit
.01a12d					_FPNoFastCompare:
.01a12d	18		clc				clc
.01a12e	60		rts				rts
.01a12f					_FPFZero:
.01a12f	a9 00		lda #$00			lda 	#0
.01a131					_FPFExitSet:
.01a131	38		sec				sec
.01a132	60		rts				rts
.01a133					_FPFLeftZero:
.01a133	34 8b		bit $8b,x			bit 	XS2_Type,x 					; if right is zero, return zero.
.01a135	70 f8		bvs $01a12f			bvs 	_FPFZero
.01a137	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip sign bit
.01a139	49 80		eor #$80			eor 	#$80						; return that as a sign.
.01a13b					_FPFSignBit:
.01a13b	0a		asl a				asl 	a
.01a13c	a9 01		lda #$01			lda 	#1
.01a13e	90 f1		bcc $01a131			bcc		_FPFExitSet
.01a140	a9 ff		lda #$ff			lda 	#$FF
.01a142	38		sec				sec
.01a143	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.01a144					FPUCopyX2ToX1:
.01a144	48		pha				pha
.01a145	da		phx				phx
.01a146	5a		phy				phy
.01a147	a0 08		ldy #$08			ldy 	#8
.01a149	b5 86		lda $86,x	_FPUC21:lda 	XS2_Mantissa,x
.01a14b	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a14d	e8		inx				inx
.01a14e	88		dey				dey
.01a14f	10 f8		bpl $01a149			bpl 	_FPUC21
.01a151	7a		ply				ply
.01a152	fa		plx				plx
.01a153	68		pla				pla
.01a154	60		rts				rts
.01a155					FPUSetInteger:
.01a155	48		pha				pha
.01a156	95 80		sta $80,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.01a158	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.01a15a	10 02		bpl $01a15e			bpl 	_FPUSIExtend
.01a15c	a9 ff		lda #$ff			lda 	#$FF
.01a15e					_FPUSIExtend:
.01a15e	95 81		sta $81,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.01a160	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a162	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a164	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.01a166	95 85		sta $85,x			sta 	XS_Type,x
.01a168	68		pla				pla
.01a169	60		rts				rts
.01a16a					FPUNegateInteger:
.01a16a	48		pha				pha
.01a16b	38		sec				sec
.01a16c	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.01a16e	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.01a170	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a172	a9 00		lda #$00			lda 	#0
.01a174	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.01a176	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a178	a9 00		lda #$00			lda 	#0
.01a17a	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.01a17c	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a17e	a9 00		lda #$00			lda 	#0
.01a180	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.01a182	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a184	68		pla				pla
.01a185	60		rts				rts
.01a186					FPUToFloat:
.01a186	48		pha				pha
.01a187	b5 85		lda $85,x			lda 	XS_Type,x					; exit if already float.
.01a189	29 0f		and #$0f			and 	#$0F
.01a18b	f0 24		beq $01a1b1			beq 	_FPUFExit
.01a18d	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.01a18f	95 85		sta $85,x			sta 	XS_Type,x
.01a191	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.01a193	95 84		sta $84,x			sta 	XS_Exponent,x 				; x mantissa.
.01a195	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.01a197	10 07		bpl $01a1a0			bpl		_FPUFPositive
.01a199	20 6a a1	jsr $01a16a			jsr 	FPUNegateInteger 			; negate the mantissa
.01a19c	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.01a19e	95 85		sta $85,x			sta 	XS_Type,x
.01a1a0					_FPUFPositive:
.01a1a0	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.01a1a2	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.01a1a4	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01a1a6	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01a1a8	d0 04		bne $01a1ae			bne 	_FPUFNonZero
.01a1aa	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.01a1ac	95 85		sta $85,x			sta 	XS_Type,x
.01a1ae					_FPUFNonZero:
.01a1ae	20 b3 a1	jsr $01a1b3			jsr 	FPUNormalise 				; normalise the floating point.
.01a1b1					_FPUFExit:
.01a1b1	68		pla				pla
.01a1b2	60		rts				rts
.01a1b3					FPUNormalise:
.01a1b3	48		pha				pha
.01a1b4	34 85		bit $85,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.01a1b6	70 18		bvs $01a1d0			bvs 	_FPUNExit
.01a1b8	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.01a1ba	f0 10		beq $01a1cc			beq 	_FPUNSetZero
.01a1bc					_FPUNLoop:
.01a1bc	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.01a1be	30 10		bmi $01a1d0			bmi 	_FPUNExit 					; if so, we are normalised.
.01a1c0	16 80		asl $80,x			asl 	0+XS_Mantissa+0,x
.01a1c2	36 81		rol $81,x			rol 	1+XS_Mantissa+0,x
.01a1c4	36 82		rol $82,x			rol 	2+XS_Mantissa+0,x
.01a1c6	36 83		rol $83,x			rol 	3+XS_Mantissa+0,x
.01a1c8	d6 84		dec $84,x			dec 	XS_Exponent,x 				; decrement exponent
.01a1ca	d0 f0		bne $01a1bc			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.01a1cc					_FPUNSetZero:
.01a1cc	a9 40		lda #$40			lda 	#$40
.01a1ce	95 85		sta $85,x			sta 	XS_Type,x 					; the result is now zero.
.01a1d0					_FPUNExit:
.01a1d0	68		pla				pla
.01a1d1	60		rts				rts
.01a1d2					FPUToInteger:
.01a1d2	48		pha				pha
.01a1d3	b5 85		lda $85,x			lda 	XS_Type,x 					; if already integer, exit
.01a1d5	29 01		and #$01			and 	#1
.01a1d7	d0 31		bne $01a20a			bne 	_FPUTOI_Exit
.01a1d9	34 85		bit $85,x			bit 	XS_Type,x					; if zero, return zero.
.01a1db	70 23		bvs $01a200			bvs 	_FPUTOI_Zero
.01a1dd	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.01a1df	10 1f		bpl $01a200			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.01a1e1	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.01a1e3	b0 2b		bcs $01a210			bcs 	FP_Overflow
.01a1e5					_FPUToIToInteger:
.01a1e5	b5 84		lda $84,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.01a1e7	c9 a0		cmp #$a0			cmp 	#128+32
.01a1e9	f0 0c		beq $01a1f7			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.01a1eb	f6 84		inc $84,x			inc 	XS_Exponent,X 				; increment Exponent
.01a1ed	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.01a1ef	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a1f1	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a1f3	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a1f5	80 ee		bra $01a1e5			bra 	_FPUToIToInteger 			; keep going.
.01a1f7					_FPUToICheckSign:
.01a1f7	b5 85		lda $85,x			lda 	XS_Type,x 					; check sign
.01a1f9	10 0f		bpl $01a20a			bpl 	_FPUToI_Exit 				; exit if unsigned.
.01a1fb	20 6a a1	jsr $01a16a			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.01a1fe	80 0a		bra $01a20a			bra 	_FPUTOI_Exit
.01a200					_FPUTOI_Zero:
.01a200	a9 00		lda #$00			lda 	#0 							; return zero integer.
.01a202	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a204	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a206	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a208	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a20a					_FPUToI_Exit:
.01a20a	a9 01		lda #$01			lda 	#1 							; set type to integer
.01a20c	95 85		sta $85,x			sta 	XS_Type,x
.01a20e	68		pla				pla
.01a20f	60		rts				rts
.01a210					FP_Overflow:
.01a210	20 6e 85	jsr $01856e			jsr ERR_Handler
>01a213	46 6c 6f 61 74 69 6e 67			.text "Floating Point overflow",0
>01a21b	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.01a22b					FPUTimes10:
.01a22b	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.01a22d	85 1a		sta $1a				sta 	ZLTemp1+0
.01a22f	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a231	85 1b		sta $1b				sta 	ZLTemp1+1
.01a233	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a235	85 1c		sta $1c				sta 	ZLTemp1+2
.01a237	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a239	85 1d		sta $1d				sta 	ZLTemp1+3
.01a23b	20 70 a2	jsr $01a270			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.01a23e	20 70 a2	jsr $01a270			jsr 	_FPUT_LSR_ZLTemp1
.01a241	18		clc				clc
.01a242	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.01a244	65 1a		adc $1a				adc 	ZLTemp1+0
.01a246	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a248	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a24a	65 1b		adc $1b				adc 	ZLTemp1+1
.01a24c	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a24e	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a250	65 1c		adc $1c				adc 	ZLTemp1+2
.01a252	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a254	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a256	65 1d		adc $1d				adc 	ZLTemp1+3
.01a258	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a25a	90 0a		bcc $01a266			bcc 	_FPUTimes10
.01a25c	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.01a25e	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a260	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a262	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a264	f6 84		inc $84,x			inc 	XS_Exponent,x				; fix exponent
.01a266					_FPUTimes10:
.01a266	b5 84		lda $84,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.01a268	18		clc				clc
.01a269	69 03		adc #$03			adc 	#3
.01a26b	95 84		sta $84,x			sta 	XS_Exponent,x
.01a26d	b0 a1		bcs $01a210			bcs 	FP_Overflow 				; error
.01a26f	60		rts				rts
.01a270					_FPUT_LSR_ZLTemp1:
.01a270	46 1d		lsr $1d				lsr 	ZLTemp1+3
.01a272	66 1c		ror $1c				ror 	ZLTemp1+2
.01a274	66 1b		ror $1b				ror 	ZLTemp1+1
.01a276	66 1a		ror $1a				ror 	ZLTemp1+0
.01a278	60		rts				rts
.01a279					FPUScale10A:
.01a279	5a		phy				phy
.01a27a	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.01a27c	f0 37		beq $01a2b5			beq 	_FPUScaleExit
.01a27e	da		phx				phx 								; save X
.01a27f	e8		inx				inx
.01a280	e8		inx				inx
.01a281	e8		inx				inx
.01a282	e8		inx				inx
.01a283	e8		inx				inx
.01a284	e8		inx				inx
.01a285	a8		tay				tay 								; save power scalar in Y.
.01a286	a9 00		lda #$00			lda 	#0
.01a288	95 80		sta $80,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.01a28a	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a28c	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a28e	95 85		sta $85,x			sta 	XS_Type,x
.01a290	a9 80		lda #$80			lda 	#$80
.01a292	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a294	a9 81		lda #$81			lda 	#$81
.01a296	95 84		sta $84,x			sta 	XS_Exponent,x
.01a298	5a		phy				phy 								; save 10^n on stack.
.01a299	c0 00		cpy #$00			cpy 	#0
.01a29b	10 05		bpl $01a2a2			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.01a29d	98		tya				tya
.01a29e	49 ff		eor #$ff			eor 	#$FF
.01a2a0	1a		inc a				inc 	a
.01a2a1	a8		tay				tay
.01a2a2					_FPUSAbs:
.01a2a2	20 2b a2	jsr $01a22b			jsr 	FPUTimes10
.01a2a5	88		dey				dey
.01a2a6	d0 fa		bne $01a2a2			bne 	_FPUSAbs 					; tos is now 10^|AC|
.01a2a8	68		pla				pla 								; restore count in A
.01a2a9	fa		plx				plx 								; restore X pointing to number to scale.
.01a2aa	0a		asl a				asl 	a
.01a2ab	b0 05		bcs $01a2b2			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.01a2ad	20 cd 9f	jsr $019fcd			jsr 	FPMultiply 					; if clear multiply.
.01a2b0	80 03		bra $01a2b5			bra		_FPUScaleExit
.01a2b2					_FPUSDivide:
.01a2b2	20 5a 9f	jsr $019f5a			jsr 	FPDivide
.01a2b5					_FPUScaleExit:
.01a2b5	7a		ply				ply
.01a2b6	60		rts				rts
.01a2b7					FPUCopyToNext:
.01a2b7	a0 06		ldy #$06			ldy 		#6
.01a2b9	da		phx				phx
.01a2ba					_FPUCopy1:
.01a2ba	b5 80		lda $80,x			lda 	XS_Mantissa,x
.01a2bc	95 86		sta $86,x			sta 	XS2_Mantissa,x
.01a2be	e8		inx				inx
.01a2bf	88		dey				dey
.01a2c0	d0 f8		bne $01a2ba			bne 	_FPUCopy1
.01a2c2	fa		plx				plx
.01a2c3	60		rts				rts
.01a2c4					FPUCopyFromNext:
.01a2c4	a0 06		ldy #$06			ldy 		#6
.01a2c6	da		phx				phx
.01a2c7					_FPUCopy1:
.01a2c7	b5 86		lda $86,x			lda 	XS2_Mantissa,x
.01a2c9	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a2cb	e8		inx				inx
.01a2cc	88		dey				dey
.01a2cd	d0 f8		bne $01a2c7			bne 	_FPUCopy1
.01a2cf	fa		plx				plx
.01a2d0	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.01a2d1					FPToString:
.01a2d1	48		pha				pha
.01a2d2	5a		phy				phy
.01a2d3	34 85		bit $85,x			bit 		XS_Type,x 				; check zero flag
.01a2d5	50 0a		bvc $01a2e1			bvc 		_FPTSIsFloat 			; if zero,
.01a2d7					_FPTSZero:
.01a2d7	a9 30		lda #$30			lda 		#"0"
.01a2d9	20 fb 9d	jsr $019dfb			jsr 		ITSOutputCharacter
.01a2dc					_FPTSExit:
.01a2dc	7a		ply				ply
.01a2dd	68		pla				pla
.01a2de	60		rts				rts
.01a2df	80 fb		bra $01a2dc			bra 		_FPTSExit
.01a2e1					_FPTSIsFloat:
.01a2e1	b5 85		lda $85,x			lda 		XS_Type,x 				; is it signed ?
.01a2e3	10 09		bpl $01a2ee			bpl 		_FPTSNotSigned
.01a2e5	a9 00		lda #$00			lda 		#0 						; clear sign flag
.01a2e7	95 85		sta $85,x			sta 		XS_Type,x
.01a2e9	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.01a2eb	20 fb 9d	jsr $019dfb			jsr 		ITSOutputCharacter
.01a2ee					_FPTSNotSigned:
.01a2ee	b5 84		lda $84,x			lda 		XS_Exponent,x
.01a2f0	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.01a2f2	b0 09		bcs $01a2fd			bcs 		_FPTSExponent
.01a2f4	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.01a2f6	90 05		bcc $01a2fd			bcc 		_FPTSExponent 			;
.01a2f8					_FPTSStandard:
.01a2f8	20 3c a3	jsr $01a33c			jsr 		FPTOutputBody 			; output the body.
.01a2fb	80 df		bra $01a2dc			bra 		_FPTSExit
.01a2fd					_FPTSExponent:
.01a2fd	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.01a2ff	8d 9d 03	sta $039d			sta 		ExpCount
.01a302					_FPTSExponentLoop:
.01a302	b5 84		lda $84,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.01a304	10 0e		bpl $01a314			bpl 		_FPTSTimes
.01a306	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.01a308	90 14		bcc $01a31e			bcc 		_FPTSScaledToExp
.01a30a	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.01a30c	20 79 a2	jsr $01a279			jsr 		FPUScale10A
.01a30f	ee 9d 03	inc $039d			inc 		ExpCount
.01a312	80 ee		bra $01a302			bra 		_FPTSExponentLoop
.01a314					_FPTSTimes:
.01a314	a9 01		lda #$01			lda 		#1
.01a316	20 79 a2	jsr $01a279			jsr 		FPUScale10A
.01a319	ce 9d 03	dec $039d			dec 		ExpCount
.01a31c	80 e4		bra $01a302			bra 		_FPTSExponentLoop
.01a31e					_FPTSScaledToExp:
.01a31e	20 3c a3	jsr $01a33c			jsr 		FPTOutputBody 			; output the body.
.01a321	a9 65		lda #$65			lda 		#"e"					; output E
.01a323	20 fb 9d	jsr $019dfb			jsr 		ITSOutputCharacter
.01a326	ad 9d 03	lda $039d			lda 		ExpCount 				; get the exponent
.01a329	95 80		sta $80,x			sta 		XS_Mantissa,x
.01a32b	29 80		and #$80			and 		#$80 					; sign extend it
.01a32d	f0 02		beq $01a331			beq 		_FPTSSExt
.01a32f	a9 ff		lda #$ff			lda 		#$FF
.01a331					_FPTSSExt:
.01a331	95 81		sta $81,x			sta 		XS_Mantissa+1,x
.01a333	95 82		sta $82,x			sta 		XS_Mantissa+2,x
.01a335	95 83		sta $83,x			sta 		XS_Mantissa+3,x
.01a337	20 59 9d	jsr $019d59			jsr 		INTToString 			; output the exponent.
.01a33a	80 a0		bra $01a2dc			bra			_FPTSExit 				; and exit.
.01a33c					FPTOutputBody:
.01a33c	20 b7 a2	jsr $01a2b7			jsr 		FPUCopyToNext 			; copy to next slot.
.01a33f	20 d2 a1	jsr $01a1d2			jsr 		FPUToInteger 			; convert to an integer
.01a342	20 59 9d	jsr $019d59			jsr 		INTToString 			; output the main integer part.
.01a345	20 c4 a2	jsr $01a2c4			jsr 		FPUCopyFromNext 		; get the fractional part back.
.01a348	20 55 a0	jsr $01a055			jsr 		FPFractionalPart 		; get the decimal part.
.01a34b	34 85		bit $85,x			bit 		XS_Type,x 				; any fractional part.
.01a34d	70 3c		bvs $01a38b			bvs 		_FPTOExit 				; if not, exit now.
.01a34f	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.01a351	20 fb 9d	jsr $019dfb			jsr 		ITSOutputCharacter
.01a354					_FPOutLoop:
.01a354	34 85		bit $85,x			bit 		XS_Type,x 				; finally reached zero.
.01a356	70 1d		bvs $01a375			bvs 		_FPStripZeros 			; strip trailing zeros
.01a358	20 2b a2	jsr $01a22b			jsr 		FPUTimes10 				; multiply by 10
.01a35b	20 b7 a2	jsr $01a2b7			jsr 		FPUCopyToNext			; copy to next slot.
.01a35e	20 d2 a1	jsr $01a1d2			jsr 		FPUToInteger 			; convert to integer
.01a361	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; print digit.
.01a363	09 30		ora #$30			ora 		#"0"
.01a365	20 fb 9d	jsr $019dfb			jsr 		ITSOutputCharacter
.01a368	20 c4 a2	jsr $01a2c4			jsr 		FPUCopyFromNext 		; get it back
.01a36b	20 55 a0	jsr $01a055			jsr 		FPFractionalPart 		; get fractional part
.01a36e	ad 14 03	lda $0314			lda 		NumBufX 				; done 11 characters yet ?
.01a371	c9 0b		cmp #$0b			cmp 	 	#11
.01a373	90 df		bcc $01a354			bcc 		_FPOutLoop 				; if so, keep going till zero.
.01a375					_FPStripZeros:
.01a375	ac 14 03	ldy $0314			ldy 		NumBufX 				; strip trailing zeros.
.01a378					_FPStripLoop:
.01a378	88		dey				dey 								; back one, if at start then no strip
.01a379	f0 10		beq $01a38b			beq 		_FPToExit
.01a37b	b9 15 03	lda $0315,y			lda 		Num_Buffer,y 			; keep going if "0"
.01a37e	c9 30		cmp #$30			cmp 		#"0"
.01a380	f0 f6		beq $01a378			beq 		_FPStripLoop
.01a382	c8		iny				iny
.01a383	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.01a385	99 15 03	sta $0315,y			sta 		Num_Buffer,y
.01a388	8c 14 03	sty $0314			sty 		NumBufX 				; update position.
.01a38b					_FPTOExit:
.01a38b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.01a38c					FPFromString:
.01a38c	48		pha				pha 								; push A
.01a38d	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.01a38f	c9 2e		cmp #$2e			cmp 	#"."
.01a391	f0 03		beq $01a396			beq	 	_FPFIsDecimal
.01a393	4c f2 a3	jmp $01a3f2			jmp 	_FPFNotDecimal
.01a396					_FPFIsDecimal:
.01a396	c8		iny				iny 								; consume the decimal.
.01a397	20 86 a1	jsr $01a186			jsr 	FPUToFloat 					; convert the integer to float.
.01a39a	da		phx				phx 								; save X.
.01a39b	5a		phy				phy 								; save decimal start position
.01a39c	e8		inx				inx
.01a39d	e8		inx				inx
.01a39e	e8		inx				inx
.01a39f	e8		inx				inx
.01a3a0	e8		inx				inx
.01a3a1	e8		inx				inx
.01a3a2	20 13 9e	jsr $019e13			jsr 	INTFromStringY 				; get the part after the DP.
.01a3a5	20 86 a1	jsr $01a186			jsr 	FPUToFloat 					; convert that to a float.
.01a3a8	68		pla				pla 								; calculate - chars consumed.
.01a3a9	8c 9c 03	sty $039c			sty 	ExpTemp
.01a3ac	38		sec				sec
.01a3ad	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; this is the shift amount
.01a3b0	20 79 a2	jsr $01a279			jsr 	FPUScale10A 				; scale it by 10^AC
.01a3b3	fa		plx				plx 								; restore original X
.01a3b4	20 a6 9e	jsr $019ea6			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.01a3b7	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.01a3b9	c9 45		cmp #$45			cmp 	#"E"
.01a3bb	f0 04		beq $01a3c1			beq 	_FPFExponent
.01a3bd	c9 65		cmp #$65			cmp 	#"e"
.01a3bf	d0 31		bne $01a3f2			bne 	_FPFNotDecimal 				; no, then exit normally.
.01a3c1					_FPFExponent:
.01a3c1	c8		iny				iny 								; skip over E symbol.
.01a3c2	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.01a3c4	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.01a3c6	d0 01		bne $01a3c9			bne 	_FPFGotSign
.01a3c8	c8		iny				iny 								; if it was - skip over it.
.01a3c9					_FPFGotSign:
.01a3c9	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.01a3ca	da		phx				phx
.01a3cb	e8		inx				inx
.01a3cc	e8		inx				inx
.01a3cd	e8		inx				inx
.01a3ce	e8		inx				inx
.01a3cf	e8		inx				inx
.01a3d0	e8		inx				inx
.01a3d1	20 13 9e	jsr $019e13			jsr 	INTFromStringY 				; get the exponent
.01a3d4	fa		plx				plx 								; restore X.
.01a3d5	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.01a3d7	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.01a3d9	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.01a3db	d0 17		bne $01a3f4			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.01a3dd	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.01a3df	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.01a3e1	b0 11		bcs $01a3f4			bcs 	_FPFXOverflow
.01a3e3	68		pla				pla 								; get direction
.01a3e4	d0 07		bne $01a3ed			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.01a3e6	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.01a3e8	49 ff		eor #$ff			eor 	#$FF
.01a3ea	1a		inc a				inc 	a
.01a3eb	95 86		sta $86,x			sta 	XS2_Mantissa+0,x
.01a3ed					_FPFXScale:
.01a3ed	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.01a3ef	20 79 a2	jsr $01a279			jsr 	FPUScale10A 				; scale by the exponent.
.01a3f2					_FPFNotDecimal:
.01a3f2	68		pla				pla
.01a3f3	60		rts				rts
.01a3f4					_FPFXOverflow:
.01a3f4	20 6e 85	jsr $01856e			jsr 	ERR_Handler
>01a3f7	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>01a3ff	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.01a406					Unary_Rnd:
.01a406	20 86 91	jsr $019186			jsr 	EvaluateNumberX 			; get value
.01a409	20 d6 97	jsr $0197d6			jsr 	CheckNextRParen 			; check right bracket.
.01a40c	20 04 94	jsr $019404			jsr 	GetSignCurrent 				; get sign -1,0,1.
.01a40f	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.01a411	30 10		bmi $01a423			bmi 	_URSetSeed
.01a413	f0 28		beq $01a43d			beq 	_URMakeRandom 				; if zero return same number.
.01a415	da		phx				phx
.01a416	a2 00		ldx #$00			ldx 	#0
.01a418	20 74 a4	jsr $01a474			jsr 	Random16
.01a41b	a2 02		ldx #$02			ldx 	#2
.01a41d	20 74 a4	jsr $01a474			jsr 	Random16
.01a420	fa		plx				plx
.01a421	80 1a		bra $01a43d			bra 	_URMakeRandom
.01a423					_URSetSeed:
.01a423	20 86 a1	jsr $01a186			jsr 	FPUToFloat 					; make it a float to twiddle it.
.01a426	b5 80		lda $80,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.01a428	8d a3 03	sta $03a3			sta 	RandomSeed+0
.01a42b	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.01a42d	8d a4 03	sta $03a4			sta 	RandomSeed+1
.01a430	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.01a432	8d a5 03	sta $03a5			sta 	RandomSeed+2
.01a435	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.01a437	0a		asl a				asl 	a
.01a438	49 db		eor #$db			eor 	#$DB
.01a43a	8d a6 03	sta $03a6			sta 	RandomSeed+3
.01a43d					_URMakeRandom:
.01a43d	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; check if seed is zero.
.01a440	0d a4 03	ora $03a4			ora 	RandomSeed+1
.01a443	0d a5 03	ora $03a5			ora 	RandomSeed+2
.01a446	0d a6 03	ora $03a6			ora 	RandomSeed+3
.01a449	d0 0a		bne $01a455			bne 	_URNotZero
.01a44b	a9 47		lda #$47			lda 	#$47
.01a44d	8d a4 03	sta $03a4			sta 	RandomSeed+1				; if it is, make it non zero.
.01a450	a9 3d		lda #$3d			lda 	#$3D
.01a452	8d a6 03	sta $03a6			sta 	RandomSeed+3
.01a455					_URNotZero:
.01a455	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; copy seed into mantissa.
.01a458	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a45a	ad a4 03	lda $03a4			lda 	RandomSeed+1
.01a45d	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a45f	ad a5 03	lda $03a5			lda 	RandomSeed+2
.01a462	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a464	ad a6 03	lda $03a6			lda 	RandomSeed+3
.01a467	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a469	a9 00		lda #$00			lda 	#$00 						; set type to float.
.01a46b	95 85		sta $85,x			sta 	XS_Type,x
.01a46d	a9 80		lda #$80			lda 	#$80
.01a46f	95 84		sta $84,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.01a471	4c b3 a1	jmp $01a1b3			jmp 	FPUNormalise
.01a474					Random16:
.01a474	5e a4 03	lsr $03a4,x			lsr 	RandomSeed+1,x				; shift seed right
.01a477	7e a3 03	ror $03a3,x			ror 	RandomSeed,x
.01a47a	90 08		bcc $01a484			bcc 	_R16_NoXor
.01a47c	bd a4 03	lda $03a4,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.01a47f	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.01a481	9d a4 03	sta $03a4,x			sta 	RandomSeed+1,x
.01a484					_R16_NoXor:
.01a484	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.01a485					Unary_Int:
.01a485	20 86 91	jsr $019186			jsr 	EvaluateNumberX 			; get value
.01a488	20 d6 97	jsr $0197d6			jsr 	CheckNextRParen 			; check right bracket.
.01a48b	4c d2 a1	jmp $01a1d2			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Return to file: basic.asm

>01a48e	02						.byte 	2
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 c0						.word 	StartROM
>fffe	19 c0					.word TIM_BreakHandler

;******  End of listing
