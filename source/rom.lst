
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Sun Sep  1 15:57:13 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="65816"				cpu = "65816"
="em65816"				hardware = "em65816"
=1					exitonend = 1
=1					autorun = 1
=2					loadtest = 2
=1					hasfloat = 1
=1					hasinteger = 1
=253					maxstring = 253

;******  Processing file: modules/basic/pointer/em65816/src_em65816.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stackmarkers.inc

=5					SourcePosSize   =   5 							; Source position stack space needed.
=1					SMark_Gosub 	= 	1 							; 0 is GOSUB/RETURN.
=2					SMark_Repeat 	= 	2 							; 1 is REPEAT/UNTIL.
=3					SMark_While 	= 	3 							; 2 is WHILE/WEND.
=4					SMark_If 		= 	4 							; 3 is IF/ENDIF
=5					SMark_For 		= 	5 							; 4 is FOR/NEXT

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/hardware/common/macros32.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0020					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0022					zVarDataPtr: .word ? 						; position of variable data.
>0024					zVarType: 	.byte ? 						; type of data (token)
>0025					zNullString:.byte ? 						; represents a NULL string.
>0026					zBasicSP:	.word ? 						; stack pointer
>0080					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>0084					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>0085					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=134					XS2_Mantissa = XS_Mantissa+XS_Size
=138					XS2_Exponent = XS_Exponent+XS_Size
=139					XS2_Type = XS_Type+XS_Size
=140					XS3_Mantissa = XS_Mantissa+XS_Size*2
=144					XS3_Exponent = XS_Exponent+XS_Size*2
=145					XS3_Type = XS_Type+XS_Size*2
>0300					StringPtr:	.word ? 						; Top of free memory (for string allocation)
>0302					VarMemPtr: 	.word ?							; Bottom of free memory (for variables)
>0304					endOfProgram: .dword ? 						; End of Program Memory (long)
>0308					vecPrintCharacter .word ?
>030a					vecInputCharacter .word ?
>030c					UserVector .fill 4 							; USR(x) calls this.
>0310					LocalVector .fill 4 						; Indirect calls call this.
>0314					NumBufX 	.byte 	?						; buffer index position
>0315					Num_Buffer	.fill 	32 						; buffer for numeric conversions
=6					HashTableCount = 6 							; there are 6 hash tables, in token order.
=8					HashTableSize = 8 							; each hash table as 8 links.
.0335					HashTableBase:
>0335								.fill	HashTableCount * HashTableSize * 2
.0395					HashTableEnd:
=$315					Var_Buffer 	= Num_Buffer 					; buffer for variable name (same space)
>0395					Var_Type    .byte ? 						; type of variable (as a type token)
>0396					Var_Hash 	.byte ? 						; hash of identifier name.
>0397					Var_Length 	.byte ? 						; length of variable name
>0398					Var_HashAddress .byte ?						; low byte of hash table entry.
>0399					Var_DataSize .byte ?						; size of one element.
>039a					NumSuppress	.byte 	?						; leading zero suppression flag
>039b					NumConvCount .byte 	? 						; count for conversions.
>039c					ExpTemp:	.byte ?							; Working temp for exponents.
>039d					ExpCount:	.byte ? 						; Count of decimal exponents.
>039e					SignCount:	.byte ?							; Integer Divide Sign Counts.
>039f					TempStringWriteIndex: .byte ? 				; Write offset.
>03a0					ValSign: 	.byte ? 						; sign flag for val()
>03a1					SliceStart:	.byte ? 						; string slice parts
>03a2					SliceCount:	.byte ?
>03a3					RandomSeed:	.dword ? 						; Random seed.
>03a7					SignNext:	.byte ? 						; Used for keeping sign of STEP in FOR/NEXT
>03a8					BreakCount:	.byte ? 						; Counter, avoid checking break every command.
=3					ArrayMaxDim = 3 							; number of dimensions.
>03a9					ArrayDef:	.fill (ArrayMaxDim+1)*2 		; dimensions for auto-creation
>03b1					UsrArrayDef:.fill (ArrayMaxDim+1)*2 		; dimensions created in DIM
>03b9					UsrArrayIdx:.byte ? 						; index into UsrArrayDef
>03ba					LastPrinted:.byte ? 						; last printed char ?
>03bb					ListIndent: .byte ? 						; list indent level
>03bc					LastListIndent:.byte ? 						; previous one.
>03bd					DataLPtr: 	.dword ?						; the data long ptr (swapped with zCodePtr)
>03c1					DataIndex:	.byte ?							; index position.
>03c2					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>03c4					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>03c6					Tim_SR:		.byte ? 						; Processor Status
>03c7					Tim_A:		.byte ? 						; Processor Registers
>03c8					Tim_X:		.byte ?
>03c9					Tim_Y:		.byte ?
>03ca					Tim_Z:		.byte ?
>03cb					Tim_SP:		.word ?							; Stack Pointer (just in cases)
>0400					BasicStack:	.fill 	256 					; and occupy whole pages.
.0500					EndBasicStack:
>0500					IFT_XCursor:.byte ?							; current logical position on screen
>0501					IFT_YCursor:.byte ?
>0502					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0566					IFT_LineBuffer: .fill 100 					; line input buffer.

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/em65816.asm

=$7f00					HighMemory = $7F00
=$3000					VariableMemory = $3000
.1000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testing.src

>1000	1f 0a 00 dc bd 40 fd 03			.byte	$1f,$0a,$00,$dc,$bd,$40,$fd,$03
>1008	30 8a 8b 43 66 74 fd 05			.byte	$30,$8a,$8b,$43,$66,$74,$fd,$05
>1010	38 34 39 be 84 8b 43 66			.byte	$38,$34,$39,$be,$84,$8b,$43,$66
>1018	74 fd 05 38 34 39 00 13			.byte	$74,$fd,$05,$38,$34,$39,$00,$13
>1020	14 00 dc bd 8b 48 5a 50			.byte	$14,$00,$dc,$bd,$8b,$48,$5a,$50
>1028	84 8b 41 4e 5d 65 be 84			.byte	$84,$8b,$41,$4e,$5d,$65,$be,$84
>1030	40 00 14 1e 00 dc bd 4b			.byte	$40,$00,$14,$1e,$00,$dc,$bd,$4b
>1038	73 7a 82 43 73 72 6a be			.byte	$73,$7a,$82,$43,$73,$72,$6a,$be
>1040	84 43 78 41 50 00 11 28			.byte	$84,$43,$78,$41,$50,$00,$11,$28
>1048	00 dc 9a 8b 42 51 68 7c			.byte	$00,$dc,$9a,$8b,$42,$51,$68,$7c
>1050	be 84 42 51 68 7c 00 14			.byte	$be,$84,$42,$51,$68,$7c,$00,$14
>1058	32 00 dc a0 fe 05 6b 64			.byte	$32,$00,$dc,$a0,$fe,$05,$6b,$64
>1060	6f bf 46 be 84 fe 05 6b			.byte	$6f,$bf,$46,$be,$84,$fe,$05,$6b
>1068	64 6f 00 28 3c 00 dc bd			.byte	$64,$6f,$00,$28,$3c,$00,$dc,$bd
>1070	7e 5e 6c fd 04 33 36 8c			.byte	$7e,$5e,$6c,$fd,$04,$33,$36,$8c
>1078	8b 42 46 67 7c fd 04 33			.byte	$8b,$42,$46,$67,$7c,$fd,$04,$33
>1080	34 be 84 8b 41 fd 0d 34			.byte	$34,$be,$84,$8b,$41,$fd,$0d,$34
>1088	31 31 31 37 34 38 34 65			.byte	$31,$31,$31,$37,$34,$38,$34,$65
>1090	31 31 00 13 46 00 dc bd			.byte	$31,$31,$00,$13,$46,$00,$dc,$bd
>1098	43 70 48 5e 88 41 7e 5d			.byte	$43,$70,$48,$5e,$88,$41,$7e,$5d
>10a0	45 be 84 8b 41 00 17 50			.byte	$45,$be,$84,$8b,$41,$00,$17,$50
>10a8	00 dc bd 8b 41 7a 56 52			.byte	$00,$dc,$bd,$8b,$41,$7a,$56,$52
>10b0	81 8b 42 4d 4b 59 be 84			.byte	$81,$8b,$42,$4d,$4b,$59,$be,$84
>10b8	8b 48 42 51 00 0d 5a 00			.byte	$8b,$48,$42,$51,$00,$0d,$5a,$00
>10c0	dc b3 43 6c 4b 5d be 84			.byte	$dc,$b3,$43,$6c,$4b,$5d,$be,$84
>10c8	41 00 16 64 00 dc a1 fe			.byte	$41,$00,$16,$64,$00,$dc,$a1,$fe
>10d0	07 76 65 62 70 6b bf 43			.byte	$07,$76,$65,$62,$70,$6b,$bf,$43
>10d8	be 84 fe 05 62 70 6b 00			.byte	$be,$84,$fe,$05,$62,$70,$6b,$00
>10e0	18 6e 00 dc bd 40 fd 03			.byte	$18,$6e,$00,$dc,$bd,$40,$fd,$03
>10e8	30 88 8b 51 70 52 fd 05			.byte	$30,$88,$8b,$51,$70,$52,$fd,$05
>10f0	31 32 33 be 84 8b 41 00			.byte	$31,$32,$33,$be,$84,$8b,$41,$00
>10f8	13 78 00 dc bd 8b 5c 45			.byte	$13,$78,$00,$dc,$bd,$8b,$5c,$45
>1100	56 86 8b 47 42 58 be 84			.byte	$56,$86,$8b,$47,$42,$58,$be,$84
>1108	8b 41 00 12 82 00 dc bd			.byte	$8b,$41,$00,$12,$82,$00,$dc,$bd
>1110	41 7e 76 6b 81 40 be 84			.byte	$41,$7e,$76,$6b,$81,$40,$be,$84
>1118	41 7e 76 6b 00 15 8c 00			.byte	$41,$7e,$76,$6b,$00,$15,$8c,$00
>1120	dc b2 41 5f 50 59 bf 43			.byte	$dc,$b2,$41,$5f,$50,$59,$bf,$43
>1128	6c 6e 50 be 84 41 5f 50			.byte	$6c,$6e,$50,$be,$84,$41,$5f,$50
>1130	59 00 13 96 00 dc a2 fe			.byte	$59,$00,$13,$96,$00,$dc,$a2,$fe
>1138	04 62 66 bf 42 bf 45 be			.byte	$04,$62,$66,$bf,$42,$bf,$45,$be
>1140	84 fe 03 66 00 1c a0 00			.byte	$84,$fe,$03,$66,$00,$1c,$a0,$00
>1148	dc bd 8b 41 63 62 61 fd			.byte	$dc,$bd,$8b,$41,$63,$62,$61,$fd
>1150	04 38 31 87 41 45 7e 4c			.byte	$04,$38,$31,$87,$41,$45,$7e,$4c
>1158	fd 04 35 33 be 84 8b 41			.byte	$fd,$04,$35,$33,$be,$84,$8b,$41
>1160	00 12 aa 00 dc bd 41 59			.byte	$00,$12,$aa,$00,$dc,$bd,$41,$59
>1168	46 7e 89 61 63 44 be 84			.byte	$46,$7e,$89,$61,$63,$44,$be,$84
>1170	8b 41 00 14 b4 00 dc bd			.byte	$8b,$41,$00,$14,$b4,$00,$dc,$bd
>1178	8b 5d 62 4b 82 7e 5b 43			.byte	$8b,$5d,$62,$4b,$82,$7e,$5b,$43
>1180	be 84 8b 63 79 4a 00 0e			.byte	$be,$84,$8b,$63,$79,$4a,$00,$0e
>1188	be 00 dc 98 8b 56 56 7f			.byte	$be,$00,$dc,$98,$8b,$56,$56,$7f
>1190	84 56 56 7e 00 12 c8 00			.byte	$84,$56,$56,$7e,$00,$12,$c8,$00
>1198	dc a6 fe 09 62 74 7a 71			.byte	$dc,$a6,$fe,$09,$62,$74,$7a,$71
>11a0	65 65 7a be 84 47 00 1c			.byte	$65,$65,$7a,$be,$84,$47,$00,$1c
>11a8	d2 00 dc bd 8b 42 6d 71			.byte	$d2,$00,$dc,$bd,$8b,$42,$6d,$71
>11b0	5a fd 04 33 35 89 8b 42			.byte	$5a,$fd,$04,$33,$35,$89,$8b,$42
>11b8	64 79 55 fd 04 36 37 be			.byte	$64,$79,$55,$fd,$04,$36,$37,$be
>11c0	84 40 00 13 dc 00 dc bd			.byte	$84,$40,$00,$13,$dc,$00,$dc,$bd
>11c8	41 49 70 67 85 8b 7f 42			.byte	$41,$49,$70,$67,$85,$8b,$7f,$42
>11d0	78 be 84 8b 41 00 15 e6			.byte	$78,$be,$84,$8b,$41,$00,$15,$e6
>11d8	00 dc bd 42 70 74 5d 81			.byte	$00,$dc,$bd,$42,$70,$74,$5d,$81
>11e0	42 55 7e 5d be 84 42 75			.byte	$42,$55,$7e,$5d,$be,$84,$42,$75
>11e8	7e 5d 00 10 f0 00 dc a5			.byte	$7e,$5d,$00,$10,$f0,$00,$dc,$a5
>11f0	a4 49 4d 70 be be 84 49			.byte	$a4,$49,$4d,$70,$be,$be,$84,$49
>11f8	4d 70 00 13 fa 00 dc 9b			.byte	$4d,$70,$00,$13,$fa,$00,$dc,$9b
>1200	fe 09 70 65 70 68 73 6e			.byte	$fe,$09,$70,$65,$70,$68,$73,$6e
>1208	72 be 84 41 70 00 17 04			.byte	$72,$be,$84,$41,$70,$00,$17,$04
>1210	01 dc bd 8b 43 5d 5a 7e			.byte	$01,$dc,$bd,$8b,$43,$5d,$5a,$7e
>1218	fd 04 37 32 88 40 fd 03			.byte	$fd,$04,$37,$32,$88,$40,$fd,$03
>1220	30 be 84 40 00 12 0e 01			.byte	$30,$be,$84,$40,$00,$12,$0e,$01
>1228	dc bd 46 45 61 87 8b 43			.byte	$dc,$bd,$46,$45,$61,$87,$8b,$43
>1230	4c 77 7b be 84 40 00 15			.byte	$4c,$77,$7b,$be,$84,$40,$00,$15
>1238	18 01 dc bd 41 4b 74 45			.byte	$18,$01,$dc,$bd,$41,$4b,$74,$45
>1240	82 42 7d 51 6f be 84 43			.byte	$82,$42,$7d,$51,$6f,$be,$84,$43
>1248	76 65 6a 00 11 22 01 dc			.byte	$76,$65,$6a,$00,$11,$22,$01,$dc
>1250	9a 8b 42 53 47 6a be 84			.byte	$9a,$8b,$42,$53,$47,$6a,$be,$84
>1258	42 53 47 6a 00 0c 2c 01			.byte	$42,$53,$47,$6a,$00,$0c,$2c,$01
>1260	dc b4 7d be 84 fe 03 3d			.byte	$dc,$b4,$7d,$be,$84,$fe,$03,$3d
>1268	00 17 36 01 dc bd 40 fd			.byte	$00,$17,$36,$01,$dc,$bd,$40,$fd
>1270	03 30 87 41 4b 5a 50 fd			.byte	$03,$30,$87,$41,$4b,$5a,$50,$fd
>1278	04 30 38 be 84 8b 41 00			.byte	$04,$30,$38,$be,$84,$8b,$41,$00
>1280	15 40 01 dc bd 8b 43 71			.byte	$15,$40,$01,$dc,$bd,$8b,$43,$71
>1288	76 66 85 8b 42 4c 56 55			.byte	$76,$66,$85,$8b,$42,$4c,$56,$55
>1290	be 84 8b 41 00 12 4a 01			.byte	$be,$84,$8b,$41,$00,$12,$4a,$01
>1298	dc bd 43 4e 53 5d 81 40			.byte	$dc,$bd,$43,$4e,$53,$5d,$81,$40
>12a0	be 84 43 4e 53 5d 00 0f			.byte	$be,$84,$43,$4e,$53,$5d,$00,$0f
>12a8	54 01 dc b3 8b 42 6e 6c			.byte	$54,$01,$dc,$b3,$8b,$42,$6e,$6c
>12b0	4e be 84 8b 41 00 13 5e			.byte	$4e,$be,$84,$8b,$41,$00,$13,$5e
>12b8	01 dc a3 48 be 84 fe 0a			.byte	$01,$dc,$a3,$48,$be,$84,$fe,$0a
>12c0	20 20 20 20 20 20 20 20			.byte	$20,$20,$20,$20,$20,$20,$20,$20
>12c8	00 1b 68 01 dc bd 8b 41			.byte	$00,$1b,$68,$01,$dc,$bd,$8b,$41
>12d0	51 5d 53 fd 04 35 31 88			.byte	$51,$5d,$53,$fd,$04,$35,$31,$88
>12d8	43 53 65 7c fd 04 32 33			.byte	$43,$53,$65,$7c,$fd,$04,$32,$33
>12e0	be 84 40 00 11 72 01 dc			.byte	$be,$84,$40,$00,$11,$72,$01,$dc
>12e8	bd 8b 41 67 7e 73 86 40			.byte	$bd,$8b,$41,$67,$7e,$73,$86,$40
>12f0	be 84 8b 41 00 14 7c 01			.byte	$be,$84,$8b,$41,$00,$14,$7c,$01
>12f8	dc bd 40 81 8b 41 4e 53			.byte	$dc,$bd,$40,$81,$8b,$41,$4e,$53
>1300	64 be 84 8b 41 4e 53 64			.byte	$64,$be,$84,$8b,$41,$4e,$53,$64
>1308	00 15 86 01 dc b2 8b 77			.byte	$00,$15,$86,$01,$dc,$b2,$8b,$77
>1310	57 42 bf 8b 41 7a 7b 7d			.byte	$57,$42,$bf,$8b,$41,$7a,$7b,$7d
>1318	be 84 77 57 42 00 13 90			.byte	$be,$84,$77,$57,$42,$00,$13,$90
>1320	01 dc a7 41 5d 57 4e be			.byte	$01,$dc,$a7,$41,$5d,$57,$4e,$be
>1328	84 fe 07 35 44 35 43 45			.byte	$84,$fe,$07,$35,$44,$35,$43,$45
>1330	00 22 9a 01 dc bd 42 4e			.byte	$00,$22,$9a,$01,$dc,$bd,$42,$4e
>1338	59 66 fd 04 35 35 8b 43			.byte	$59,$66,$fd,$04,$35,$35,$8b,$43
>1340	54 5b 45 fd 04 35 39 be			.byte	$54,$5b,$45,$fd,$04,$35,$39,$be
>1348	84 8b 41 46 41 5f fd 04			.byte	$84,$8b,$41,$46,$41,$5f,$fd,$04
>1350	30 34 00 10 a4 01 dc bd			.byte	$30,$34,$00,$10,$a4,$01,$dc,$bd
>1358	40 85 8b 69 68 56 be 84			.byte	$40,$85,$8b,$69,$68,$56,$be,$84
>1360	8b 41 00 10 ae 01 dc bd			.byte	$8b,$41,$00,$10,$ae,$01,$dc,$bd
>1368	8b 42 4e 76 48 80 40 be			.byte	$8b,$42,$4e,$76,$48,$80,$40,$be
>1370	84 40 00 10 b8 01 dc 98			.byte	$84,$40,$00,$10,$b8,$01,$dc,$98
>1378	8b 42 5f 5d 55 84 42 5f			.byte	$8b,$42,$5f,$5d,$55,$84,$42,$5f
>1380	5d 54 00 13 c2 01 dc af			.byte	$5d,$54,$00,$13,$c2,$01,$dc,$af
>1388	fe 07 44 41 44 33 33 be			.byte	$fe,$07,$44,$41,$44,$33,$33,$be
>1390	84 43 5a 74 73 00 1a cc			.byte	$84,$43,$5a,$74,$73,$00,$1a,$cc
>1398	01 dc bd 41 78 49 53 fd			.byte	$01,$dc,$bd,$41,$78,$49,$53,$fd
>13a0	04 30 32 86 8b 66 5b 5e			.byte	$04,$30,$32,$86,$8b,$66,$5b,$5e
>13a8	fd 04 39 32 be 84 40 00			.byte	$fd,$04,$39,$32,$be,$84,$40,$00
>13b0	12 d6 01 dc bd 43 63 46			.byte	$12,$d6,$01,$dc,$bd,$43,$63,$46
>13b8	7d 87 43 57 64 76 be 84			.byte	$7d,$87,$43,$57,$64,$76,$be,$84
>13c0	40 00 16 e0 01 dc bd 8b			.byte	$40,$00,$16,$e0,$01,$dc,$bd,$8b
>13c8	42 7f 54 76 81 8b 60 5c			.byte	$42,$7f,$54,$76,$81,$8b,$60,$5c
>13d0	42 be 84 8b 60 54 42 00			.byte	$42,$be,$84,$8b,$60,$54,$42,$00
>13d8	12 ea 01 dc a5 a4 40 fd			.byte	$12,$ea,$01,$dc,$a5,$a4,$40,$fd
>13e0	03 30 be be 84 40 fd 03			.byte	$03,$30,$be,$be,$84,$40,$fd,$03
>13e8	30 00 15 f4 01 dc a0 fe			.byte	$30,$00,$15,$f4,$01,$dc,$a0,$fe
>13f0	07 76 72 78 67 77 bf 42			.byte	$07,$76,$72,$78,$67,$77,$bf,$42
>13f8	be 84 fe 04 76 72 00 27			.byte	$be,$84,$fe,$04,$76,$72,$00,$27
>1400	fe 01 dc bd 41 50 55 57			.byte	$fe,$01,$dc,$bd,$41,$50,$55,$57
>1408	fd 04 32 37 8c 41 50 55			.byte	$fd,$04,$32,$37,$8c,$41,$50,$55
>1410	57 fd 04 32 37 be 84 41			.byte	$57,$fd,$04,$32,$37,$be,$84,$41
>1418	fd 0d 30 38 32 37 32 31			.byte	$fd,$0d,$30,$38,$32,$37,$32,$31
>1420	30 38 65 31 31 00 14 08			.byte	$30,$38,$65,$31,$31,$00,$14,$08
>1428	02 dc bd 8b 41 6d 58 4e			.byte	$02,$dc,$bd,$8b,$41,$6d,$58,$4e
>1430	87 42 4a 76 60 be 84 8b			.byte	$87,$42,$4a,$76,$60,$be,$84,$8b
>1438	41 00 14 12 02 dc bd 42			.byte	$41,$00,$14,$12,$02,$dc,$bd,$42
>1440	76 67 56 82 42 6d 5d 53			.byte	$76,$67,$56,$82,$42,$6d,$5d,$53
>1448	be 84 5b 7a 45 00 0e 1c			.byte	$be,$84,$5b,$7a,$45,$00,$0e,$1c
>1450	02 dc 9a 48 42 43 be 84			.byte	$02,$dc,$9a,$48,$42,$43,$be,$84
>1458	48 42 43 00 12 26 02 dc			.byte	$48,$42,$43,$00,$12,$26,$02,$dc
>1460	a1 fe 04 78 68 bf 44 be			.byte	$a1,$fe,$04,$78,$68,$bf,$44,$be
>1468	84 fe 04 78 68 00 20 30			.byte	$84,$fe,$04,$78,$68,$00,$20,$30
>1470	02 dc bd 48 49 61 fd 05			.byte	$02,$dc,$bd,$48,$49,$61,$fd,$05
>1478	38 30 38 8a 57 54 7b fd			.byte	$38,$30,$38,$8a,$57,$54,$7b,$fd
>1480	05 31 36 37 be 84 5f 5e			.byte	$05,$31,$36,$37,$be,$84,$5f,$5e
>1488	5c fd 04 39 38 00 13 3a			.byte	$5c,$fd,$04,$39,$38,$00,$13,$3a
>1490	02 dc bd 42 55 7a 8b 8b			.byte	$02,$dc,$bd,$42,$55,$7a,$8b,$8b
>1498	49 63 57 be 84 4b 79 51			.byte	$49,$63,$57,$be,$84,$4b,$79,$51
>14a0	00 16 44 02 dc bd 8b 42			.byte	$00,$16,$44,$02,$dc,$bd,$8b,$42
>14a8	78 76 41 80 43 44 78 6a			.byte	$78,$76,$41,$80,$43,$44,$78,$6a
>14b0	be 84 41 44 48 6a 00 0d			.byte	$be,$84,$41,$44,$48,$6a,$00,$0d
>14b8	4e 02 dc b3 42 7c 53 49			.byte	$4e,$02,$dc,$b3,$42,$7c,$53,$49
>14c0	be 84 41 00 12 58 02 dc			.byte	$be,$84,$41,$00,$12,$58,$02,$dc
>14c8	a2 fe 04 73 61 bf 48 bf			.byte	$a2,$fe,$04,$73,$61,$bf,$48,$bf
>14d0	4a be 84 fe 02 00 18 62			.byte	$4a,$be,$84,$fe,$02,$00,$18,$62
>14d8	02 dc bd 5f 58 7c fd 04			.byte	$02,$dc,$bd,$5f,$58,$7c,$fd,$04
>14e0	32 36 89 42 59 4a 79 fd			.byte	$32,$36,$89,$42,$59,$4a,$79,$fd
>14e8	03 39 be 84 40 00 14 6c			.byte	$03,$39,$be,$84,$40,$00,$14,$6c
>14f0	02 dc bd 41 61 43 78 88			.byte	$02,$dc,$bd,$41,$61,$43,$78,$88
>14f8	8b 41 7e 59 42 be 84 8b			.byte	$8b,$41,$7e,$59,$42,$be,$84,$8b
>1500	41 00 18 76 02 dc bd 8b			.byte	$41,$00,$18,$76,$02,$dc,$bd,$8b
>1508	41 6f 61 5d 80 8b 42 67			.byte	$41,$6f,$61,$5d,$80,$8b,$42,$67
>1510	61 6b be 84 8b 43 6f 61			.byte	$61,$6b,$be,$84,$8b,$43,$6f,$61
>1518	7f 00 14 80 02 dc b2 8b			.byte	$7f,$00,$14,$80,$02,$dc,$b2,$8b
>1520	67 4a 41 bf 8b 59 76 6c			.byte	$67,$4a,$41,$bf,$8b,$59,$76,$6c
>1528	be 84 4d 53 55 00 15 8a			.byte	$be,$84,$4d,$53,$55,$00,$15,$8a
>1530	02 dc a6 fe 0c 74 75 68			.byte	$02,$dc,$a6,$fe,$0c,$74,$75,$68
>1538	6b 77 72 75 76 72 6b be			.byte	$6b,$77,$72,$75,$76,$72,$6b,$be
>1540	84 4a 00 1a 94 02 dc bd			.byte	$84,$4a,$00,$1a,$94,$02,$dc,$bd
>1548	41 5f 7f 58 fd 04 30 35			.byte	$41,$5f,$7f,$58,$fd,$04,$30,$35
>1550	88 42 51 69 6b fd 04 32			.byte	$88,$42,$51,$69,$6b,$fd,$04,$32
>1558	31 be 84 40 00 14 9e 02			.byte	$31,$be,$84,$40,$00,$14,$9e,$02
>1560	dc bd 42 48 73 6e 85 8b			.byte	$dc,$bd,$42,$48,$73,$6e,$85,$8b
>1568	42 68 45 6e be 84 8b 41			.byte	$42,$68,$45,$6e,$be,$84,$8b,$41
>1570	00 12 a8 02 dc bd 42 73			.byte	$00,$12,$a8,$02,$dc,$bd,$42,$73
>1578	48 6f 81 40 be 84 42 73			.byte	$48,$6f,$81,$40,$be,$84,$42,$73
>1580	48 6f 00 0e b2 02 dc 98			.byte	$48,$6f,$00,$0e,$b2,$02,$dc,$98
>1588	8b 55 69 52 84 55 69 51			.byte	$8b,$55,$69,$52,$84,$55,$69,$51
>1590	00 16 bc 02 dc 9b fe 0c			.byte	$00,$16,$bc,$02,$dc,$9b,$fe,$0c
>1598	67 74 71 6d 64 65 79 6f			.byte	$67,$74,$71,$6d,$64,$65,$79,$6f
>15a0	71 77 be 84 41 67 00 13			.byte	$71,$77,$be,$84,$41,$67,$00,$13
>15a8	c6 02 dc bd 40 fd 03 30			.byte	$c6,$02,$dc,$bd,$40,$fd,$03,$30
>15b0	84 40 fd 03 30 be 84 8b			.byte	$84,$40,$fd,$03,$30,$be,$84,$8b
>15b8	41 00 0f d0 02 dc bd 40			.byte	$41,$00,$0f,$d0,$02,$dc,$bd,$40
>15c0	84 8b 79 5b 4d be 84 40			.byte	$84,$8b,$79,$5b,$4d,$be,$84,$40
>15c8	00 16 da 02 dc bd 77 70			.byte	$00,$16,$da,$02,$dc,$bd,$77,$70
>15d0	40 81 8b 43 6f 5d 7b be			.byte	$40,$81,$8b,$43,$6f,$5d,$7b,$be
>15d8	84 8b 43 48 4d 7b 00 1a			.byte	$84,$8b,$43,$48,$4d,$7b,$00,$1a
>15e0	e4 02 dc a5 a4 42 6b 67			.byte	$e4,$02,$dc,$a5,$a4,$42,$6b,$67
>15e8	76 fd 04 39 35 be be 84			.byte	$76,$fd,$04,$39,$35,$be,$be,$84
>15f0	42 6b 67 76 fd 04 39 35			.byte	$42,$6b,$67,$76,$fd,$04,$39,$35
>15f8	00 0d ee 02 dc b4 41 7c			.byte	$00,$0d,$ee,$02,$dc,$b4,$41,$7c
>1600	be 84 fe 03 7c 00 15 f8			.byte	$be,$84,$fe,$03,$7c,$00,$15,$f8
>1608	02 dc bd 5d 4a 70 fd 04			.byte	$02,$dc,$bd,$5d,$4a,$70,$fd,$04
>1610	34 31 84 40 fd 03 30 be			.byte	$34,$31,$84,$40,$fd,$03,$30,$be
>1618	84 40 00 14 02 03 dc bd			.byte	$84,$40,$00,$14,$02,$03,$dc,$bd
>1620	40 8a 8b 42 77 6c 4f be			.byte	$40,$8a,$8b,$42,$77,$6c,$4f,$be
>1628	84 8b 42 77 6c 4f 00 14			.byte	$84,$8b,$42,$77,$6c,$4f,$00,$14
>1630	0c 03 dc bd 8b 53 57 51			.byte	$0c,$03,$dc,$bd,$8b,$53,$57,$51
>1638	81 7c 43 7c be 84 8b 43			.byte	$81,$7c,$43,$7c,$be,$84,$8b,$43
>1640	54 41 00 0f 16 03 dc 9a			.byte	$54,$41,$00,$0f,$16,$03,$dc,$9a
>1648	8b 49 4c 6a be 84 49 4c			.byte	$8b,$49,$4c,$6a,$be,$84,$49,$4c
>1650	6a 00 16 20 03 dc a3 4b			.byte	$6a,$00,$16,$20,$03,$dc,$a3,$4b
>1658	be 84 fe 0d 20 20 20 20			.byte	$be,$84,$fe,$0d,$20,$20,$20,$20
>1660	20 20 20 20 20 20 20 00			.byte	$20,$20,$20,$20,$20,$20,$20,$00
>1668	13 2a 03 dc bd 40 fd 03			.byte	$13,$2a,$03,$dc,$bd,$40,$fd,$03
>1670	30 84 40 fd 03 30 be 84			.byte	$30,$84,$40,$fd,$03,$30,$be,$84
>1678	8b 41 00 16 34 03 dc bd			.byte	$8b,$41,$00,$16,$34,$03,$dc,$bd
>1680	42 40 46 54 8b 8b 43 6b			.byte	$42,$40,$46,$54,$8b,$8b,$43,$6b
>1688	5f 75 be 84 45 6b 66 49			.byte	$5f,$75,$be,$84,$45,$6b,$66,$49
>1690	00 14 3e 03 dc bd 8b 43			.byte	$00,$14,$3e,$03,$dc,$bd,$8b,$43
>1698	57 6a 76 80 48 60 4f be			.byte	$57,$6a,$76,$80,$48,$60,$4f,$be
>16a0	84 48 40 4a 00 0e 48 03			.byte	$84,$48,$40,$4a,$00,$0e,$48,$03
>16a8	dc b3 8b 64 6a 53 be 84			.byte	$dc,$b3,$8b,$64,$6a,$53,$be,$84
>16b0	8b 41 00 13 52 03 dc a7			.byte	$8b,$41,$00,$13,$52,$03,$dc,$a7
>16b8	41 63 6c 42 be 84 fe 07			.byte	$41,$63,$6c,$42,$be,$84,$fe,$07
>16c0	36 33 42 30 32 00 1a 5c			.byte	$36,$33,$42,$30,$32,$00,$1a,$5c
>16c8	03 dc bd 8b 42 5b 5d 51			.byte	$03,$dc,$bd,$8b,$42,$5b,$5d,$51
>16d0	fd 03 31 85 8b 42 5b 5d			.byte	$fd,$03,$31,$85,$8b,$42,$5b,$5d
>16d8	51 fd 03 31 be 84 40 00			.byte	$51,$fd,$03,$31,$be,$84,$40,$00
>16e0	14 66 03 dc bd 8b 41 65			.byte	$14,$66,$03,$dc,$bd,$8b,$41,$65
>16e8	63 48 8d 8b 43 4b 4b 7a			.byte	$63,$48,$8d,$8b,$43,$4b,$4b,$7a
>16f0	be 84 40 00 14 70 03 dc			.byte	$be,$84,$40,$00,$14,$70,$03,$dc
>16f8	bd 74 7b 53 82 42 61 64			.byte	$bd,$74,$7b,$53,$82,$42,$61,$64
>1700	65 be 84 42 55 5f 76 00			.byte	$65,$be,$84,$42,$55,$5f,$76,$00
>1708	15 7a 03 dc b2 42 76 4e			.byte	$15,$7a,$03,$dc,$b2,$42,$76,$4e
>1710	5d bf 8b 41 4e 70 78 be			.byte	$5d,$bf,$8b,$41,$4e,$70,$78,$be
>1718	84 58 6c 6d 00 11 84 03			.byte	$84,$58,$6c,$6d,$00,$11,$84,$03
>1720	dc af fe 06 35 45 37 35			.byte	$dc,$af,$fe,$06,$35,$45,$37,$35
>1728	be 84 45 79 75 00 1b 8e			.byte	$be,$84,$45,$79,$75,$00,$1b,$8e
>1730	03 dc bd 8b 4b 4b 4a fd			.byte	$03,$dc,$bd,$8b,$4b,$4b,$4a,$fd
>1738	05 30 31 33 89 43 56 6a			.byte	$05,$30,$31,$33,$89,$43,$56,$6a
>1740	65 fd 04 35 36 be 84 40			.byte	$65,$fd,$04,$35,$36,$be,$84,$40
>1748	00 14 98 03 dc bd 8b 55			.byte	$00,$14,$98,$03,$dc,$bd,$8b,$55
>1750	5d 50 85 8b 41 6a 42 5c			.byte	$5d,$50,$85,$8b,$41,$6a,$42,$5c
>1758	be 84 8b 41 00 14 a2 03			.byte	$be,$84,$8b,$41,$00,$14,$a2,$03
>1760	dc bd 62 7e 5f 80 8b 43			.byte	$dc,$bd,$62,$7e,$5f,$80,$8b,$43
>1768	56 48 6a be 84 60 76 56			.byte	$56,$48,$6a,$be,$84,$60,$76,$56
>1770	00 0a ac 03 dc 98 40 84			.byte	$00,$0a,$ac,$03,$dc,$98,$40,$84
>1778	8b 41 00 19 b6 03 dc a0			.byte	$8b,$41,$00,$19,$b6,$03,$dc,$a0
>1780	fe 0b 61 63 6c 71 63 78			.byte	$fe,$0b,$61,$63,$6c,$71,$63,$78
>1788	77 6b 65 bf 42 be 84 fe			.byte	$77,$6b,$65,$bf,$42,$be,$84,$fe
>1790	04 61 63 00 16 c0 03 dc			.byte	$04,$61,$63,$00,$16,$c0,$03,$dc
>1798	bd 40 fd 03 30 85 5f 6d			.byte	$bd,$40,$fd,$03,$30,$85,$5f,$6d
>17a0	7b fd 04 38 35 be 84 8b			.byte	$7b,$fd,$04,$38,$35,$be,$84,$8b
>17a8	41 00 16 ca 03 dc bd 8b			.byte	$41,$00,$16,$ca,$03,$dc,$bd,$8b
>17b0	43 54 44 62 8b 8b 43 58			.byte	$43,$54,$44,$62,$8b,$8b,$43,$58
>17b8	62 57 be 84 44 5d 75 00			.byte	$62,$57,$be,$84,$44,$5d,$75,$00
>17c0	12 d4 03 dc bd 43 67 79			.byte	$12,$d4,$03,$dc,$bd,$43,$67,$79
>17c8	76 81 40 be 84 43 67 79			.byte	$76,$81,$40,$be,$84,$43,$67,$79
>17d0	76 00 1c de 03 dc a5 a4			.byte	$76,$00,$1c,$de,$03,$dc,$a5,$a4
>17d8	8b 41 5a 6a 76 fd 04 36			.byte	$8b,$41,$5a,$6a,$76,$fd,$04,$36
>17e0	34 be be 84 8b 41 5a 6a			.byte	$34,$be,$be,$84,$8b,$41,$5a,$6a
>17e8	76 fd 04 36 34 00 13 e8			.byte	$76,$fd,$04,$36,$34,$00,$13,$e8
>17f0	03 dc a1 fe 05 66 71 68			.byte	$03,$dc,$a1,$fe,$05,$66,$71,$68
>17f8	bf 42 be 84 fe 04 71 68			.byte	$bf,$42,$be,$84,$fe,$04,$71,$68
>1800	00 15 f2 03 dc bd 40 fd			.byte	$00,$15,$f2,$03,$dc,$bd,$40,$fd
>1808	03 30 8b 40 fd 03 30 be			.byte	$03,$30,$8b,$40,$fd,$03,$30,$be
>1810	84 40 fd 03 30 00 14 fc			.byte	$84,$40,$fd,$03,$30,$00,$14,$fc
>1818	03 dc bd 8b 43 4b 5f 78			.byte	$03,$dc,$bd,$8b,$43,$4b,$5f,$78
>1820	88 8b 41 59 57 68 be 84			.byte	$88,$8b,$41,$59,$57,$68,$be,$84
>1828	40 00 14 06 04 dc bd 8b			.byte	$40,$00,$14,$06,$04,$dc,$bd,$8b
>1830	68 5d 7a 81 60 72 65 be			.byte	$68,$5d,$7a,$81,$60,$72,$65,$be
>1838	84 8b 48 4d 59 00 11 10			.byte	$84,$8b,$48,$4d,$59,$00,$11,$10
>1840	04 dc 9a 8b 42 4b 79 41			.byte	$04,$dc,$9a,$8b,$42,$4b,$79,$41
>1848	be 84 42 4b 79 41 00 14			.byte	$be,$84,$42,$4b,$79,$41,$00,$14
>1850	1a 04 dc a2 fe 06 67 75			.byte	$1a,$04,$dc,$a2,$fe,$06,$67,$75
>1858	70 62 bf 4a bf 46 be 84			.byte	$70,$62,$bf,$4a,$bf,$46,$be,$84
>1860	fe 02 00 26 24 04 dc bd			.byte	$fe,$02,$00,$26,$24,$04,$dc,$bd
>1868	42 47 6e 59 fd 03 33 8c			.byte	$42,$47,$6e,$59,$fd,$03,$33,$8c
>1870	44 7d 75 fd 05 30 31 39			.byte	$44,$7d,$75,$fd,$05,$30,$31,$39
>1878	be 84 41 fd 0d 31 33 30			.byte	$be,$84,$41,$fd,$0d,$31,$33,$30
>1880	38 31 36 38 34 65 31 30			.byte	$38,$31,$36,$38,$34,$65,$31,$30
>1888	00 14 2e 04 dc bd 8b 41			.byte	$00,$14,$2e,$04,$dc,$bd,$8b,$41
>1890	44 49 7b 86 41 50 7d 5f			.byte	$44,$49,$7b,$86,$41,$50,$7d,$5f
>1898	be 84 8b 41 00 0c 38 04			.byte	$be,$84,$8b,$41,$00,$0c,$38,$04
>18a0	dc bd 40 80 40 be 84 40			.byte	$dc,$bd,$40,$80,$40,$be,$84,$40
>18a8	00 0c 42 04 dc b3 64 56			.byte	$00,$0c,$42,$04,$dc,$b3,$64,$56
>18b0	57 be 84 41 00 11 4c 04			.byte	$57,$be,$84,$41,$00,$11,$4c,$04
>18b8	dc a6 fe 08 72 73 6e 6b			.byte	$dc,$a6,$fe,$08,$72,$73,$6e,$6b
>18c0	71 76 be 84 46 00 18 56			.byte	$71,$76,$be,$84,$46,$00,$18,$56
>18c8	04 dc bd 42 63 73 59 fd			.byte	$04,$dc,$bd,$42,$63,$73,$59,$fd
>18d0	04 36 39 87 5c 5b 4e fd			.byte	$04,$36,$39,$87,$5c,$5b,$4e,$fd
>18d8	03 38 be 84 40 00 13 60			.byte	$03,$38,$be,$84,$40,$00,$13,$60
>18e0	04 dc bd 8b 41 62 65 77			.byte	$04,$dc,$bd,$8b,$41,$62,$65,$77
>18e8	89 41 71 5b 52 be 84 40			.byte	$89,$41,$71,$5b,$52,$be,$84,$40
>18f0	00 15 6a 04 dc bd 8b 43			.byte	$00,$15,$6a,$04,$dc,$bd,$8b,$43
>18f8	5a 6e 51 80 43 62 74 5a			.byte	$5a,$6e,$51,$80,$43,$62,$74,$5a
>1900	be 84 60 50 4a 00 0f 74			.byte	$be,$84,$60,$50,$4a,$00,$0f,$74
>1908	04 dc b2 40 bf 41 5a 47			.byte	$04,$dc,$b2,$40,$bf,$41,$5a,$47
>1910	6a be 84 40 00 15 7e 04			.byte	$6a,$be,$84,$40,$00,$15,$7e,$04
>1918	dc 9b fe 0b 6e 72 69 6b			.byte	$dc,$9b,$fe,$0b,$6e,$72,$69,$6b
>1920	62 79 6e 71 6b be 84 41			.byte	$62,$79,$6e,$71,$6b,$be,$84,$41
>1928	6e 00 1d 88 04 dc bd 8b			.byte	$6e,$00,$1d,$88,$04,$dc,$bd,$8b
>1930	43 47 74 54 fd 04 36 36			.byte	$43,$47,$74,$54,$fd,$04,$36,$36
>1938	87 8b 42 75 48 65 fd 04			.byte	$87,$8b,$42,$75,$48,$65,$fd,$04
>1940	37 32 be 84 8b 41 00 12			.byte	$37,$32,$be,$84,$8b,$41,$00,$12
>1948	92 04 dc bd 56 46 6a 87			.byte	$92,$04,$dc,$bd,$56,$46,$6a,$87
>1950	8b 41 56 54 40 be 84 40			.byte	$8b,$41,$56,$54,$40,$be,$84,$40
>1958	00 17 9c 04 dc bd 8b 43			.byte	$00,$17,$9c,$04,$dc,$bd,$8b,$43
>1960	4f 77 4d 81 41 5a 6c 63			.byte	$4f,$77,$4d,$81,$41,$5a,$6c,$63
>1968	be 84 8b 42 45 53 4d 00			.byte	$be,$84,$8b,$42,$45,$53,$4d,$00
>1970	10 a6 04 dc 98 41 76 6e			.byte	$10,$a6,$04,$dc,$98,$41,$76,$6e
>1978	4f 84 8b 41 76 6e 50 00			.byte	$4f,$84,$8b,$41,$76,$6e,$50,$00
>1980	0d b0 04 dc b4 41 72 be			.byte	$0d,$b0,$04,$dc,$b4,$41,$72,$be
>1988	84 fe 03 72 00 1b ba 04			.byte	$84,$fe,$03,$72,$00,$1b,$ba,$04
>1990	dc bd 42 76 56 47 fd 04			.byte	$dc,$bd,$42,$76,$56,$47,$fd,$04
>1998	34 36 84 8b 43 47 43 53			.byte	$34,$36,$84,$8b,$43,$47,$43,$53
>19a0	fd 04 35 37 be 84 40 00			.byte	$fd,$04,$35,$37,$be,$84,$40,$00
>19a8	14 c4 04 dc bd 8b 43 51			.byte	$14,$c4,$04,$dc,$bd,$8b,$43,$51
>19b0	45 6b 85 43 70 6b 79 be			.byte	$45,$6b,$85,$43,$70,$6b,$79,$be
>19b8	84 8b 41 00 18 ce 04 dc			.byte	$84,$8b,$41,$00,$18,$ce,$04,$dc
>19c0	bd 8b 43 53 6d 7f 80 8b			.byte	$bd,$8b,$43,$53,$6d,$7f,$80,$8b
>19c8	41 74 55 7a be 84 8b 43			.byte	$41,$74,$55,$7a,$be,$84,$8b,$43
>19d0	77 7e 40 00 1a d8 04 dc			.byte	$77,$7e,$40,$00,$1a,$d8,$04,$dc
>19d8	a5 a4 4d 7b 5b fd 05 30			.byte	$a5,$a4,$4d,$7b,$5b,$fd,$05,$30
>19e0	36 38 be be 84 4d 7b 5b			.byte	$36,$38,$be,$be,$84,$4d,$7b,$5b
>19e8	fd 05 30 36 38 00 1a e2			.byte	$fd,$05,$30,$36,$38,$00,$1a,$e2
>19f0	04 dc a3 4f be 84 fe 11			.byte	$04,$dc,$a3,$4f,$be,$84,$fe,$11
>19f8	20 20 20 20 20 20 20 20			.byte	$20,$20,$20,$20,$20,$20,$20,$20
>1a00	20 20 20 20 20 20 20 00			.byte	$20,$20,$20,$20,$20,$20,$20,$00
>1a08	1a ec 04 dc bd 41 60 6b			.byte	$1a,$ec,$04,$dc,$bd,$41,$60,$6b
>1a10	55 fd 04 39 33 86 8b 70			.byte	$55,$fd,$04,$39,$33,$86,$8b,$70
>1a18	52 70 fd 04 39 34 be 84			.byte	$52,$70,$fd,$04,$39,$34,$be,$84
>1a20	40 00 14 f6 04 dc bd 8b			.byte	$40,$00,$14,$f6,$04,$dc,$bd,$8b
>1a28	4f 4d 5f 88 8b 43 43 62			.byte	$4f,$4d,$5f,$88,$8b,$43,$43,$62
>1a30	58 be 84 8b 41 00 16 00			.byte	$58,$be,$84,$8b,$41,$00,$16,$00
>1a38	05 dc bd 43 68 44 5a 80			.byte	$05,$dc,$bd,$43,$68,$44,$5a,$80
>1a40	8b 42 7a 46 64 be 84 41			.byte	$8b,$42,$7a,$46,$64,$be,$84,$41
>1a48	40 40 58 00 11 0a 05 dc			.byte	$40,$40,$58,$00,$11,$0a,$05,$dc
>1a50	9a 8b 41 47 79 4b be 84			.byte	$9a,$8b,$41,$47,$79,$4b,$be,$84
>1a58	41 47 79 4b 00 12 14 05			.byte	$41,$47,$79,$4b,$00,$12,$14,$05
>1a60	dc a7 74 5b 57 be 84 fe			.byte	$dc,$a7,$74,$5b,$57,$be,$84,$fe
>1a68	07 33 34 36 44 37 00 27			.byte	$07,$33,$34,$36,$44,$37,$00,$27
>1a70	1e 05 dc bd 43 6e 5a 5e			.byte	$1e,$05,$dc,$bd,$43,$6e,$5a,$5e
>1a78	fd 04 38 39 8c 43 48 63			.byte	$fd,$04,$38,$39,$8c,$43,$48,$63
>1a80	41 fd 04 39 31 be 84 48			.byte	$41,$fd,$04,$39,$31,$be,$84,$48
>1a88	fd 0d 30 32 31 37 33 32			.byte	$fd,$0d,$30,$32,$31,$37,$33,$32
>1a90	35 37 65 31 31 00 11 28			.byte	$35,$37,$65,$31,$31,$00,$11,$28
>1a98	05 dc bd 8b 43 4b 41 58			.byte	$05,$dc,$bd,$8b,$43,$4b,$41,$58
>1aa0	87 40 be 84 8b 41 00 17			.byte	$87,$40,$be,$84,$8b,$41,$00,$17
>1aa8	32 05 dc bd 8b 75 62 55			.byte	$32,$05,$dc,$bd,$8b,$75,$62,$55
>1ab0	80 8b 43 52 62 6a be 84			.byte	$80,$8b,$43,$52,$62,$6a,$be,$84
>1ab8	8b 43 77 62 7e 00 0d 3c			.byte	$8b,$43,$77,$62,$7e,$00,$0d,$3c
>1ac0	05 dc b3 41 50 63 55 be			.byte	$05,$dc,$b3,$41,$50,$63,$55,$be
>1ac8	84 41 00 11 46 05 dc af			.byte	$84,$41,$00,$11,$46,$05,$dc,$af
>1ad0	fe 06 42 46 35 37 be 84			.byte	$fe,$06,$42,$46,$35,$37,$be,$84
>1ad8	4b 7d 57 00 1e 50 05 dc			.byte	$4b,$7d,$57,$00,$1e,$50,$05,$dc
>1ae0	bd 40 fd 03 30 8b 8b 43			.byte	$bd,$40,$fd,$03,$30,$8b,$8b,$43
>1ae8	6e 61 54 fd 04 30 37 be			.byte	$6e,$61,$54,$fd,$04,$30,$37,$be
>1af0	84 43 6e 61 54 fd 04 30			.byte	$84,$43,$6e,$61,$54,$fd,$04,$30
>1af8	37 00 11 5a 05 dc bd 8b			.byte	$37,$00,$11,$5a,$05,$dc,$bd,$8b
>1b00	6f 64 59 88 59 4e 6d be			.byte	$6f,$64,$59,$88,$59,$4e,$6d,$be
>1b08	84 40 00 17 64 05 dc bd			.byte	$84,$40,$00,$17,$64,$05,$dc,$bd
>1b10	41 64 79 7b 82 8b 42 72			.byte	$41,$64,$79,$7b,$82,$8b,$42,$72
>1b18	67 49 be 84 8b 43 56 5e			.byte	$67,$49,$be,$84,$8b,$43,$56,$5e
>1b20	74 00 0f 6e 05 dc b2 40			.byte	$74,$00,$0f,$6e,$05,$dc,$b2,$40
>1b28	bf 43 45 50 64 be 84 40			.byte	$bf,$43,$45,$50,$64,$be,$84,$40
>1b30	00 13 78 05 dc a0 fe 06			.byte	$00,$13,$78,$05,$dc,$a0,$fe,$06
>1b38	6e 65 78 69 bf 41 be 84			.byte	$6e,$65,$78,$69,$bf,$41,$be,$84
>1b40	fe 03 6e 00 16 82 05 dc			.byte	$fe,$03,$6e,$00,$16,$82,$05,$dc
>1b48	bd 42 64 47 5c fd 04 35			.byte	$bd,$42,$64,$47,$5c,$fd,$04,$35
>1b50	36 86 40 fd 03 30 be 84			.byte	$36,$86,$40,$fd,$03,$30,$be,$84
>1b58	40 00 16 8c 05 dc bd 4e			.byte	$40,$00,$16,$8c,$05,$dc,$bd,$4e
>1b60	58 77 8a 8b 41 73 4d 42			.byte	$58,$77,$8a,$8b,$41,$73,$4d,$42
>1b68	be 84 8b 41 64 74 4b 00			.byte	$be,$84,$8b,$41,$64,$74,$4b,$00
>1b70	17 96 05 dc bd 8b 42 5c			.byte	$17,$96,$05,$dc,$bd,$8b,$42,$5c
>1b78	6a 45 81 41 61 62 49 be			.byte	$6a,$45,$81,$41,$61,$62,$49,$be
>1b80	84 8b 42 5c 48 45 00 0e			.byte	$84,$8b,$42,$5c,$48,$45,$00,$0e
>1b88	a0 05 dc 98 8b 58 78 5c			.byte	$a0,$05,$dc,$98,$8b,$58,$78,$5c
>1b90	84 58 78 5b 00 0e aa 05			.byte	$84,$58,$78,$5b,$00,$0e,$aa,$05
>1b98	dc a1 fe 02 bf 44 be 84			.byte	$dc,$a1,$fe,$02,$bf,$44,$be,$84
>1ba0	fe 02 00 1c b4 05 dc bd			.byte	$fe,$02,$00,$1c,$b4,$05,$dc,$bd
>1ba8	8b 41 7c 7d 7e fd 04 35			.byte	$8b,$41,$7c,$7d,$7e,$fd,$04,$35
>1bb0	38 89 8b 41 5b 52 4f fd			.byte	$38,$89,$8b,$41,$5b,$52,$4f,$fd
>1bb8	04 39 32 be 84 40 00 16			.byte	$04,$39,$32,$be,$84,$40,$00,$16
>1bc0	be 05 dc bd 43 6f 77 4d			.byte	$be,$05,$dc,$bd,$43,$6f,$77,$4d
>1bc8	8a 8b 41 74 66 48 be 84			.byte	$8a,$8b,$41,$74,$66,$48,$be,$84
>1bd0	41 7b 51 45 00 14 c8 05			.byte	$41,$7b,$51,$45,$00,$14,$c8,$05
>1bd8	dc bd 8b 41 7a 53 44 82			.byte	$dc,$bd,$8b,$41,$7a,$53,$44,$82
>1be0	40 be 84 8b 41 7a 53 44			.byte	$40,$be,$84,$8b,$41,$7a,$53,$44
>1be8	00 1a d2 05 dc a5 a4 41			.byte	$00,$1a,$d2,$05,$dc,$a5,$a4,$41
>1bf0	55 7f 4d fd 04 33 31 be			.byte	$55,$7f,$4d,$fd,$04,$33,$31,$be
>1bf8	be 84 41 55 7f 4d fd 04			.byte	$be,$84,$41,$55,$7f,$4d,$fd,$04
>1c00	33 31 00 19 dc 05 dc a2			.byte	$33,$31,$00,$19,$dc,$05,$dc,$a2
>1c08	fe 09 6f 77 71 64 7a 78			.byte	$fe,$09,$6f,$77,$71,$64,$7a,$78
>1c10	74 bf 45 bf 42 be 84 fe			.byte	$74,$bf,$45,$bf,$42,$be,$84,$fe
>1c18	04 7a 78 00 1b e6 05 dc			.byte	$04,$7a,$78,$00,$1b,$e6,$05,$dc
>1c20	bd 8b 6d 55 41 fd 04 31			.byte	$bd,$8b,$6d,$55,$41,$fd,$04,$31
>1c28	35 84 8b 41 51 44 6e fd			.byte	$35,$84,$8b,$41,$51,$44,$6e,$fd
>1c30	04 38 34 be 84 40 00 0f			.byte	$04,$38,$34,$be,$84,$40,$00,$0f
>1c38	f0 05 dc bd 5a 46 43 85			.byte	$f0,$05,$dc,$bd,$5a,$46,$43,$85
>1c40	40 be 84 8b 41 00 15 fa			.byte	$40,$be,$84,$8b,$41,$00,$15,$fa
>1c48	05 dc bd 43 65 74 7a 81			.byte	$05,$dc,$bd,$43,$65,$74,$7a,$81
>1c50	8b 41 64 42 6f be 84 8b			.byte	$8b,$41,$64,$42,$6f,$be,$84,$8b
>1c58	42 45 00 0f 04 06 dc 9a			.byte	$42,$45,$00,$0f,$04,$06,$dc,$9a
>1c60	8b 69 41 44 be 84 69 41			.byte	$8b,$69,$41,$44,$be,$84,$69,$41
>1c68	44 00 14 0e 06 dc a6 fe			.byte	$44,$00,$14,$0e,$06,$dc,$a6,$fe
>1c70	0b 7a 62 62 6a 76 72 6d			.byte	$0b,$7a,$62,$62,$6a,$76,$72,$6d
>1c78	66 70 be 84 49 00 28 18			.byte	$66,$70,$be,$84,$49,$00,$28,$18
>1c80	06 dc bd 42 40 5a 7c fd			.byte	$06,$dc,$bd,$42,$40,$5a,$7c,$fd
>1c88	04 39 34 8c 8b 68 6a 42			.byte	$04,$39,$34,$8c,$8b,$68,$6a,$42
>1c90	fd 04 37 34 be 84 8b 48			.byte	$fd,$04,$37,$34,$be,$84,$8b,$48
>1c98	fd 0d 37 35 39 37 33 32			.byte	$fd,$0d,$37,$35,$39,$37,$33,$32
>1ca0	36 31 65 31 30 00 16 22			.byte	$36,$31,$65,$31,$30,$00,$16,$22
>1ca8	06 dc bd 8b 41 77 6e 62			.byte	$06,$dc,$bd,$8b,$41,$77,$6e,$62
>1cb0	8b 8b 42 47 70 4f be 84			.byte	$8b,$8b,$42,$47,$70,$4f,$be,$84
>1cb8	50 41 6d 00 0f 2c 06 dc			.byte	$50,$41,$6d,$00,$0f,$2c,$06,$dc
>1cc0	bd 40 80 41 51 69 68 be			.byte	$bd,$40,$80,$41,$51,$69,$68,$be
>1cc8	84 40 00 0d 36 06 dc b3			.byte	$84,$40,$00,$0d,$36,$06,$dc,$b3
>1cd0	43 73 67 6b be 84 41 00			.byte	$43,$73,$67,$6b,$be,$84,$41,$00
>1cd8	10 40 06 dc 9b fe 06 79			.byte	$10,$40,$06,$dc,$9b,$fe,$06,$79
>1ce0	73 74 67 be 84 41 79 00			.byte	$73,$74,$67,$be,$84,$41,$79,$00
>1ce8	1c 4a 06 dc bd 43 4c 52			.byte	$1c,$4a,$06,$dc,$bd,$43,$4c,$52
>1cf0	4f fd 04 30 35 89 8b 42			.byte	$4f,$fd,$04,$30,$35,$89,$8b,$42
>1cf8	65 7d 4b fd 04 39 37 be			.byte	$65,$7d,$4b,$fd,$04,$39,$37,$be
>1d00	84 8b 41 00 14 54 06 dc			.byte	$84,$8b,$41,$00,$14,$54,$06,$dc
>1d08	bd 43 57 53 45 85 8b 42			.byte	$bd,$43,$57,$53,$45,$85,$8b,$42
>1d10	5f 73 6e be 84 8b 41 00			.byte	$5f,$73,$6e,$be,$84,$8b,$41,$00
>1d18	13 5e 06 dc bd 8b 70 51			.byte	$13,$5e,$06,$dc,$bd,$8b,$70,$51
>1d20	5c 80 6b 5a 6a be 84 4b			.byte	$5c,$80,$6b,$5a,$6a,$be,$84,$4b
>1d28	4a 60 00 17 68 06 dc b2			.byte	$4a,$60,$00,$17,$68,$06,$dc,$b2
>1d30	8b 43 4d 4d 44 bf 8b 41			.byte	$8b,$43,$4d,$4d,$44,$bf,$8b,$41
>1d38	74 68 6e be 84 41 58 64			.byte	$74,$68,$6e,$be,$84,$41,$58,$64
>1d40	56 00 0d 72 06 dc b4 41			.byte	$56,$00,$0d,$72,$06,$dc,$b4,$41
>1d48	67 be 84 fe 03 67 00 22			.byte	$67,$be,$84,$fe,$03,$67,$00,$22
>1d50	7c 06 dc bd 57 4f 5f fd			.byte	$7c,$06,$dc,$bd,$57,$4f,$5f,$fd
>1d58	05 39 39 35 8a 8b 41 48			.byte	$05,$39,$39,$35,$8a,$8b,$41,$48
>1d60	44 5e fd 04 30 36 be 84			.byte	$44,$5e,$fd,$04,$30,$36,$be,$84
>1d68	8b 70 74 7e fd 04 30 36			.byte	$8b,$70,$74,$7e,$fd,$04,$30,$36
>1d70	00 14 86 06 dc bd 8b 43			.byte	$00,$14,$86,$06,$dc,$bd,$8b,$43
>1d78	60 6a 63 8b 40 be 84 8b			.byte	$60,$6a,$63,$8b,$40,$be,$84,$8b
>1d80	43 60 6a 63 00 16 90 06			.byte	$43,$60,$6a,$63,$00,$16,$90,$06
>1d88	dc bd 8b 41 6d 57 64 80			.byte	$dc,$bd,$8b,$41,$6d,$57,$64,$80
>1d90	42 5c 40 47 be 84 42 50			.byte	$42,$5c,$40,$47,$be,$84,$42,$50
>1d98	40 44 00 10 9a 06 dc 98			.byte	$40,$44,$00,$10,$9a,$06,$dc,$98
>1da0	42 57 60 57 84 8b 42 57			.byte	$42,$57,$60,$57,$84,$8b,$42,$57
>1da8	60 58 00 13 a4 06 dc a3			.byte	$60,$58,$00,$13,$a4,$06,$dc,$a3
>1db0	48 be 84 fe 0a 20 20 20			.byte	$48,$be,$84,$fe,$0a,$20,$20,$20
>1db8	20 20 20 20 20 00 17 ae			.byte	$20,$20,$20,$20,$20,$00,$17,$ae
>1dc0	06 dc bd 8b 41 5b 5c 66			.byte	$06,$dc,$bd,$8b,$41,$5b,$5c,$66
>1dc8	fd 04 35 38 89 40 fd 03			.byte	$fd,$04,$35,$38,$89,$40,$fd,$03
>1dd0	30 be 84 40 00 16 b8 06			.byte	$30,$be,$84,$40,$00,$16,$b8,$06
>1dd8	dc bd 8b 6e 6f 47 8b 43			.byte	$dc,$bd,$8b,$6e,$6f,$47,$8b,$43
>1de0	5a 51 5e be 84 8b 44 49			.byte	$5a,$51,$5e,$be,$84,$8b,$44,$49
>1de8	40 65 00 16 c2 06 dc bd			.byte	$40,$65,$00,$16,$c2,$06,$dc,$bd
>1df0	8b 41 41 43 4b 82 70 4f			.byte	$8b,$41,$41,$43,$4b,$82,$70,$4f
>1df8	5d be 84 8b 41 71 4c 58			.byte	$5d,$be,$84,$8b,$41,$71,$4c,$58
>1e00	00 12 cc 06 dc a5 a4 8b			.byte	$00,$12,$cc,$06,$dc,$a5,$a4,$8b
>1e08	6f 49 5d be be 84 8b 6f			.byte	$6f,$49,$5d,$be,$be,$84,$8b,$6f
>1e10	49 5d 00 13 d6 06 dc a7			.byte	$49,$5d,$00,$13,$d6,$06,$dc,$a7
>1e18	41 6d 76 5c be 84 fe 07			.byte	$41,$6d,$76,$5c,$be,$84,$fe,$07
>1e20	36 44 44 39 43 00 1b e0			.byte	$36,$44,$44,$39,$43,$00,$1b,$e0
>1e28	06 dc bd 8b 43 6b 7c 44			.byte	$06,$dc,$bd,$8b,$43,$6b,$7c,$44
>1e30	fd 04 33 39 89 43 42 4b			.byte	$fd,$04,$33,$39,$89,$43,$42,$4b
>1e38	58 fd 04 33 32 be 84 40			.byte	$58,$fd,$04,$33,$32,$be,$84,$40
>1e40	00 0f ea 06 dc bd 40 88			.byte	$00,$0f,$ea,$06,$dc,$bd,$40,$88
>1e48	43 5a 66 7d be 84 40 00			.byte	$43,$5a,$66,$7d,$be,$84,$40,$00
>1e50	15 f4 06 dc bd 8b 4d 77			.byte	$15,$f4,$06,$dc,$bd,$8b,$4d,$77
>1e58	7c 81 8b 5e 7b 78 be 84			.byte	$7c,$81,$8b,$5e,$7b,$78,$be,$84
>1e60	8b 4c 73 74 00 0e fe 06			.byte	$8b,$4c,$73,$74,$00,$0e,$fe,$06
>1e68	dc 9a 78 7c 6f be 84 78			.byte	$dc,$9a,$78,$7c,$6f,$be,$84,$78
>1e70	7c 6f 00 13 08 07 dc af			.byte	$7c,$6f,$00,$13,$08,$07,$dc,$af
>1e78	fe 07 34 42 30 31 34 be			.byte	$fe,$07,$34,$42,$30,$31,$34,$be
>1e80	84 41 4b 40 54 00 15 12			.byte	$84,$41,$4b,$40,$54,$00,$15,$12
>1e88	07 dc bd 40 fd 03 30 89			.byte	$07,$dc,$bd,$40,$fd,$03,$30,$89
>1e90	7f 7d 43 fd 04 34 31 be			.byte	$7f,$7d,$43,$fd,$04,$34,$31,$be
>1e98	84 40 00 11 1c 07 dc bd			.byte	$84,$40,$00,$11,$1c,$07,$dc,$bd
>1ea0	40 88 8b 43 50 54 44 be			.byte	$40,$88,$8b,$43,$50,$54,$44,$be
>1ea8	84 8b 41 00 15 26 07 dc			.byte	$84,$8b,$41,$00,$15,$26,$07,$dc
>1eb0	bd 43 72 76 46 80 41 68			.byte	$bd,$43,$72,$76,$46,$80,$41,$68
>1eb8	6e 74 be 84 41 60 66 44			.byte	$6e,$74,$be,$84,$41,$60,$66,$44
>1ec0	00 0c 30 07 dc b3 7f 67			.byte	$00,$0c,$30,$07,$dc,$b3,$7f,$67
>1ec8	4c be 84 41 00 1e 3a 07			.byte	$4c,$be,$84,$41,$00,$1e,$3a,$07
>1ed0	dc a0 fe 0a 76 6a 71 68			.byte	$dc,$a0,$fe,$0a,$76,$6a,$71,$68
>1ed8	73 69 63 74 bf 4a be 84			.byte	$73,$69,$63,$74,$bf,$4a,$be,$84
>1ee0	fe 0a 76 6a 71 68 73 69			.byte	$fe,$0a,$76,$6a,$71,$68,$73,$69
>1ee8	63 74 00 23 44 07 dc bd			.byte	$63,$74,$00,$23,$44,$07,$dc,$bd
>1ef0	8b 78 5c 4c fd 04 36 34			.byte	$8b,$78,$5c,$4c,$fd,$04,$36,$34
>1ef8	8d 8b 64 7c 75 fd 04 30			.byte	$8d,$8b,$64,$7c,$75,$fd,$04,$30
>1f00	35 be 84 41 fd 09 35 32			.byte	$35,$be,$84,$41,$fd,$09,$35,$32
>1f08	37 34 36 36 37 00 0c 4e			.byte	$37,$34,$36,$36,$37,$00,$0c,$4e
>1f10	07 dc bd 40 85 40 be 84			.byte	$07,$dc,$bd,$40,$85,$40,$be,$84
>1f18	40 00 16 58 07 dc bd 8b			.byte	$40,$00,$16,$58,$07,$dc,$bd,$8b
>1f20	42 4e 64 4b 81 58 60 52			.byte	$42,$4e,$64,$4b,$81,$58,$60,$52
>1f28	be 84 8b 42 46 44 49 00			.byte	$be,$84,$8b,$42,$46,$44,$49,$00
>1f30	0e 62 07 dc b2 40 bf 41			.byte	$0e,$62,$07,$dc,$b2,$40,$bf,$41
>1f38	68 7b be 84 40 00 12 6c			.byte	$68,$7b,$be,$84,$40,$00,$12,$6c
>1f40	07 dc a1 fe 04 78 64 bf			.byte	$07,$dc,$a1,$fe,$04,$78,$64,$bf
>1f48	44 be 84 fe 04 78 64 00			.byte	$44,$be,$84,$fe,$04,$78,$64,$00
>1f50	1c 76 07 dc bd 41 5b 71			.byte	$1c,$76,$07,$dc,$bd,$41,$5b,$71
>1f58	51 fd 04 38 33 85 8b 42			.byte	$51,$fd,$04,$38,$33,$85,$8b,$42
>1f60	4c 63 4b fd 04 32 37 be			.byte	$4c,$63,$4b,$fd,$04,$32,$37,$be
>1f68	84 8b 41 00 15 80 07 dc			.byte	$84,$8b,$41,$00,$15,$80,$07,$dc
>1f70	bd 8b 43 4f 62 77 87 8b			.byte	$bd,$8b,$43,$4f,$62,$77,$87,$8b
>1f78	42 49 76 7e be 84 8b 41			.byte	$42,$49,$76,$7e,$be,$84,$8b,$41
>1f80	00 16 8a 07 dc bd 8b 43			.byte	$00,$16,$8a,$07,$dc,$bd,$8b,$43
>1f88	57 50 4e 82 8b 56 5e 58			.byte	$57,$50,$4e,$82,$8b,$56,$5e,$58
>1f90	be 84 43 41 4e 5a 00 0e			.byte	$be,$84,$43,$41,$4e,$5a,$00,$0e
>1f98	94 07 dc 98 57 69 6c 84			.byte	$94,$07,$dc,$98,$57,$69,$6c,$84
>1fa0	8b 57 69 6d 00 12 9e 07			.byte	$8b,$57,$69,$6d,$00,$12,$9e,$07
>1fa8	dc a2 fe 04 63 7a bf 46			.byte	$dc,$a2,$fe,$04,$63,$7a,$bf,$46
>1fb0	bf 43 be 84 fe 02 00 17			.byte	$bf,$43,$be,$84,$fe,$02,$00,$17
>1fb8	a8 07 dc bd 41 68 7a 76			.byte	$a8,$07,$dc,$bd,$41,$68,$7a,$76
>1fc0	fd 04 37 37 85 40 fd 03			.byte	$fd,$04,$37,$37,$85,$40,$fd,$03
>1fc8	30 be 84 8b 41 00 13 b2			.byte	$30,$be,$84,$8b,$41,$00,$13,$b2
>1fd0	07 dc bd 8b 6d 6f 60 86			.byte	$07,$dc,$bd,$8b,$6d,$6f,$60,$86
>1fd8	8b 61 56 44 be 84 8b 41			.byte	$8b,$61,$56,$44,$be,$84,$8b,$41
>1fe0	00 17 bc 07 dc bd 8b 42			.byte	$00,$17,$bc,$07,$dc,$bd,$8b,$42
>1fe8	68 63 76 81 41 67 78 73			.byte	$68,$63,$76,$81,$41,$67,$78,$73
>1ff0	be 84 8b 42 48 43 45 00			.byte	$be,$84,$8b,$42,$48,$43,$45,$00
>1ff8	1a c6 07 dc a5 a4 43 66			.byte	$1a,$c6,$07,$dc,$a5,$a4,$43,$66
>2000	65 4e fd 04 31 38 be be			.byte	$65,$4e,$fd,$04,$31,$38,$be,$be
>2008	84 43 66 65 4e fd 04 31			.byte	$84,$43,$66,$65,$4e,$fd,$04,$31
>2010	38 00 0f d0 07 dc a6 fe			.byte	$38,$00,$0f,$d0,$07,$dc,$a6,$fe
>2018	06 71 73 65 76 be 84 44			.byte	$06,$71,$73,$65,$76,$be,$84,$44
>2020	00 1e da 07 dc bd 40 fd			.byte	$00,$1e,$da,$07,$dc,$bd,$40,$fd
>2028	03 30 8b 8b 41 57 52 67			.byte	$03,$30,$8b,$8b,$41,$57,$52,$67
>2030	fd 04 32 31 be 84 41 57			.byte	$fd,$04,$32,$31,$be,$84,$41,$57
>2038	52 67 fd 04 32 31 00 0f			.byte	$52,$67,$fd,$04,$32,$31,$00,$0f
>2040	e4 07 dc bd 41 57 7e 5b			.byte	$e4,$07,$dc,$bd,$41,$57,$7e,$5b
>2048	87 40 be 84 40 00 14 ee			.byte	$87,$40,$be,$84,$40,$00,$14,$ee
>2050	07 dc bd 8b 48 73 56 81			.byte	$07,$dc,$bd,$8b,$48,$73,$56,$81
>2058	8b 75 42 68 be 84 8b 42			.byte	$8b,$75,$42,$68,$be,$84,$8b,$42
>2060	46 00 10 f8 07 dc 9a 41			.byte	$46,$00,$10,$f8,$07,$dc,$9a,$41
>2068	52 6a 43 be 84 41 52 6a			.byte	$52,$6a,$43,$be,$84,$41,$52,$6a
>2070	43 00 16 02 08 dc 9b fe			.byte	$43,$00,$16,$02,$08,$dc,$9b,$fe
>2078	0c 73 6e 63 77 63 73 75			.byte	$0c,$73,$6e,$63,$77,$63,$73,$75
>2080	65 71 79 be 84 41 73 00			.byte	$65,$71,$79,$be,$84,$41,$73,$00
>2088	1d 0c 08 dc bd 8b 41 7a			.byte	$1d,$0c,$08,$dc,$bd,$8b,$41,$7a
>2090	74 5c fd 04 32 35 89 8b			.byte	$74,$5c,$fd,$04,$32,$35,$89,$8b
>2098	42 63 70 73 fd 04 31 38			.byte	$42,$63,$70,$73,$fd,$04,$31,$38
>20a0	be 84 8b 41 00 15 16 08			.byte	$be,$84,$8b,$41,$00,$15,$16,$08
>20a8	dc bd 4f 44 64 8b 42 45			.byte	$dc,$bd,$4f,$44,$64,$8b,$42,$45
>20b0	4c 64 be 84 8b 41 76 48			.byte	$4c,$64,$be,$84,$8b,$41,$76,$48
>20b8	40 00 14 20 08 dc bd 41			.byte	$40,$00,$14,$20,$08,$dc,$bd,$41
>20c0	69 48 75 82 6e 42 7b be			.byte	$69,$48,$75,$82,$6e,$42,$7b,$be
>20c8	84 41 47 4a 4e 00 0f 2a			.byte	$84,$41,$47,$4a,$4e,$00,$0f,$2a
>20d0	08 dc b3 8b 41 47 52 62			.byte	$08,$dc,$b3,$8b,$41,$47,$52,$62
>20d8	be 84 8b 41 00 0c 34 08			.byte	$be,$84,$8b,$41,$00,$0c,$34,$08
>20e0	dc b4 7e be 84 fe 03 3e			.byte	$dc,$b4,$7e,$be,$84,$fe,$03,$3e
>20e8	00 1b 3e 08 dc bd 8b 6f			.byte	$00,$1b,$3e,$08,$dc,$bd,$8b,$6f
>20f0	57 6a fd 04 30 32 85 42			.byte	$57,$6a,$fd,$04,$30,$32,$85,$42
>20f8	7a 56 62 fd 04 33 37 be			.byte	$7a,$56,$62,$fd,$04,$33,$37,$be
>2100	84 8b 41 00 13 48 08 dc			.byte	$84,$8b,$41,$00,$13,$48,$08,$dc
>2108	bd 5b 74 65 88 8b 42 63			.byte	$bd,$5b,$74,$65,$88,$8b,$42,$63
>2110	77 7d be 84 8b 41 00 17			.byte	$77,$7d,$be,$84,$8b,$41,$00,$17
>2118	52 08 dc bd 8b 43 4a 5b			.byte	$52,$08,$dc,$bd,$8b,$43,$4a,$5b
>2120	5a 82 8b 42 5a 49 7d be			.byte	$5a,$82,$8b,$42,$5a,$49,$7d,$be
>2128	84 41 50 52 65 00 12 5c			.byte	$84,$41,$50,$52,$65,$00,$12,$5c
>2130	08 dc b2 56 61 4f bf 6e			.byte	$08,$dc,$b2,$56,$61,$4f,$bf,$6e
>2138	61 65 be 84 56 61 4f 00			.byte	$61,$65,$be,$84,$56,$61,$4f,$00
>2140	15 66 08 dc a3 4a be 84			.byte	$15,$66,$08,$dc,$a3,$4a,$be,$84
>2148	fe 0c 20 20 20 20 20 20			.byte	$fe,$0c,$20,$20,$20,$20,$20,$20
>2150	20 20 20 20 00 1b 70 08			.byte	$20,$20,$20,$20,$00,$1b,$70,$08
>2158	dc bd 48 4a 4e fd 05 31			.byte	$dc,$bd,$48,$4a,$4e,$fd,$05,$31
>2160	39 38 86 8b 42 71 57 68			.byte	$39,$38,$86,$8b,$42,$71,$57,$68
>2168	fd 04 35 38 be 84 40 00			.byte	$fd,$04,$35,$38,$be,$84,$40,$00
>2170	12 7a 08 dc bd 41 55 45			.byte	$12,$7a,$08,$dc,$bd,$41,$55,$45
>2178	4f 8b 40 be 84 41 55 45			.byte	$4f,$8b,$40,$be,$84,$41,$55,$45
>2180	4f 00 16 84 08 dc bd 43			.byte	$4f,$00,$16,$84,$08,$dc,$bd,$43
>2188	66 4a 62 80 8b 41 67 64			.byte	$66,$4a,$62,$80,$8b,$41,$67,$64
>2190	78 be 84 42 40 4a 40 00			.byte	$78,$be,$84,$42,$40,$4a,$40,$00
>2198	10 8e 08 dc 98 8b 42 45			.byte	$10,$8e,$08,$dc,$98,$8b,$42,$45
>21a0	5a 4d 84 42 45 5a 4c 00			.byte	$5a,$4d,$84,$42,$45,$5a,$4c,$00
>21a8	13 98 08 dc a7 42 69 76			.byte	$13,$98,$08,$dc,$a7,$42,$69,$76
>21b0	46 be 84 fe 07 41 39 44			.byte	$46,$be,$84,$fe,$07,$41,$39,$44
>21b8	38 36 00 17 a2 08 dc bd			.byte	$38,$36,$00,$17,$a2,$08,$dc,$bd
>21c0	40 fd 03 30 88 8b 60 68			.byte	$40,$fd,$03,$30,$88,$8b,$60,$68
>21c8	65 fd 04 30 38 be 84 8b			.byte	$65,$fd,$04,$30,$38,$be,$84,$8b
>21d0	41 00 11 ac 08 dc bd 42			.byte	$41,$00,$11,$ac,$08,$dc,$bd,$42
>21d8	62 6b 77 86 7e 7f 6e be			.byte	$62,$6b,$77,$86,$7e,$7f,$6e,$be
>21e0	84 40 00 16 b6 08 dc bd			.byte	$84,$40,$00,$16,$b6,$08,$dc,$bd
>21e8	42 67 62 53 80 8b 41 6f			.byte	$42,$67,$62,$53,$80,$8b,$41,$6f
>21f0	51 43 be 84 42 40 62 51			.byte	$51,$43,$be,$84,$42,$40,$62,$51
>21f8	00 12 c0 08 dc a5 a4 40			.byte	$00,$12,$c0,$08,$dc,$a5,$a4,$40
>2200	fd 03 30 be be 84 40 fd			.byte	$fd,$03,$30,$be,$be,$84,$40,$fd
>2208	03 30 00 13 ca 08 dc af			.byte	$03,$30,$00,$13,$ca,$08,$dc,$af
>2210	fe 07 42 46 33 37 32 be			.byte	$fe,$07,$42,$46,$33,$37,$32,$be
>2218	84 42 7f 4d 72 00 23 d4			.byte	$84,$42,$7f,$4d,$72,$00,$23,$d4
>2220	08 dc bd 41 61 53 5f fd			.byte	$08,$dc,$bd,$41,$61,$53,$5f,$fd
>2228	04 39 35 8d 41 4c 57 52			.byte	$04,$39,$35,$8d,$41,$4c,$57,$52
>2230	fd 04 37 31 be 84 41 fd			.byte	$fd,$04,$37,$31,$be,$84,$41,$fd
>2238	09 32 37 34 32 32 32 38			.byte	$09,$32,$37,$34,$32,$32,$32,$38
>2240	00 11 de 08 dc bd 69 57			.byte	$00,$11,$de,$08,$dc,$bd,$69,$57
>2248	4f 8d 41 52 7d 56 be 84			.byte	$4f,$8d,$41,$52,$7d,$56,$be,$84
>2250	40 00 12 e8 08 dc bd 8b			.byte	$40,$00,$12,$e8,$08,$dc,$bd,$8b
>2258	74 64 47 81 40 be 84 8b			.byte	$74,$64,$47,$81,$40,$be,$84,$8b
>2260	74 64 47 00 11 f2 08 dc			.byte	$74,$64,$47,$00,$11,$f2,$08,$dc
>2268	9a 8b 43 4c 74 7b be 84			.byte	$9a,$8b,$43,$4c,$74,$7b,$be,$84
>2270	43 4c 74 7b 00 14 fc 08			.byte	$43,$4c,$74,$7b,$00,$14,$fc,$08
>2278	dc a0 fe 07 73 68 6a 68			.byte	$dc,$a0,$fe,$07,$73,$68,$6a,$68
>2280	63 bf 41 be 84 fe 03 73			.byte	$63,$bf,$41,$be,$84,$fe,$03,$73
>2288	00 1d 06 09 dc bd 8b 41			.byte	$00,$1d,$06,$09,$dc,$bd,$8b,$41
>2290	62 65 62 fd 04 37 36 85			.byte	$62,$65,$62,$fd,$04,$37,$36,$85
>2298	8b 41 5a 62 5f fd 04 34			.byte	$8b,$41,$5a,$62,$5f,$fd,$04,$34
>22a0	34 be 84 8b 41 00 13 10			.byte	$34,$be,$84,$8b,$41,$00,$13,$10
>22a8	09 dc bd 8b 43 5c 6a 41			.byte	$09,$dc,$bd,$8b,$43,$5c,$6a,$41
>22b0	8d 71 46 74 be 84 8b 44			.byte	$8d,$71,$46,$74,$be,$84,$8b,$44
>22b8	00 16 1a 09 dc bd 8b 43			.byte	$00,$16,$1a,$09,$dc,$bd,$8b,$43
>22c0	46 65 4c 81 8b 4a 7d 59			.byte	$46,$65,$4c,$81,$8b,$4a,$7d,$59
>22c8	be 84 8b 42 65 49 00 0e			.byte	$be,$84,$8b,$42,$65,$49,$00,$0e
>22d0	24 09 dc b3 8b 60 5e 50			.byte	$24,$09,$dc,$b3,$8b,$60,$5e,$50
>22d8	be 84 8b 41 00 16 2e 09			.byte	$be,$84,$8b,$41,$00,$16,$2e,$09
>22e0	dc a1 fe 06 7a 6a 6b 6a			.byte	$dc,$a1,$fe,$06,$7a,$6a,$6b,$6a
>22e8	bf 49 be 84 fe 06 7a 6a			.byte	$bf,$49,$be,$84,$fe,$06,$7a,$6a
>22f0	6b 6a 00 1a 38 09 dc bd			.byte	$6b,$6a,$00,$1a,$38,$09,$dc,$bd
>22f8	41 6b 49 78 fd 04 36 39			.byte	$41,$6b,$49,$78,$fd,$04,$36,$39
>2300	88 43 50 7c 4e fd 04 35			.byte	$88,$43,$50,$7c,$4e,$fd,$04,$35
>2308	38 be 84 40 00 11 42 09			.byte	$38,$be,$84,$40,$00,$11,$42,$09
>2310	dc bd 8b 51 4c 46 89 54			.byte	$dc,$bd,$8b,$51,$4c,$46,$89,$54
>2318	48 4b be 84 40 00 14 4c			.byte	$48,$4b,$be,$84,$40,$00,$14,$4c
>2320	09 dc bd 42 40 4f 62 82			.byte	$09,$dc,$bd,$42,$40,$4f,$62,$82
>2328	66 6b 41 be 84 42 66 64			.byte	$66,$6b,$41,$be,$84,$42,$66,$64
>2330	63 00 15 56 09 dc b2 8b			.byte	$63,$00,$15,$56,$09,$dc,$b2,$8b
>2338	41 4d 43 61 bf 8b 56 41			.byte	$41,$4d,$43,$61,$bf,$8b,$56,$41
>2340	5a be 84 4a 7f 53 00 12			.byte	$5a,$be,$84,$4a,$7f,$53,$00,$12
>2348	60 09 dc a2 fe 04 61 6f			.byte	$60,$09,$dc,$a2,$fe,$04,$61,$6f
>2350	bf 46 bf 46 be 84 fe 02			.byte	$bf,$46,$bf,$46,$be,$84,$fe,$02
>2358	00 1b 6a 09 dc bd 43 6d			.byte	$00,$1b,$6a,$09,$dc,$bd,$43,$6d
>2360	6b 42 fd 04 38 38 86 8b			.byte	$6b,$42,$fd,$04,$38,$38,$86,$8b
>2368	41 7c 5b 65 fd 04 34 31			.byte	$41,$7c,$5b,$65,$fd,$04,$34,$31
>2370	be 84 40 00 14 74 09 dc			.byte	$be,$84,$40,$00,$14,$74,$09,$dc
>2378	bd 8b 43 69 47 6b 86 41			.byte	$bd,$8b,$43,$69,$47,$6b,$86,$41
>2380	77 6a 42 be 84 8b 41 00			.byte	$77,$6a,$42,$be,$84,$8b,$41,$00
>2388	14 7e 09 dc bd 4e 45 59			.byte	$14,$7e,$09,$dc,$bd,$4e,$45,$59
>2390	82 8b 6a 42 6c be 84 8b			.byte	$82,$8b,$6a,$42,$6c,$be,$84,$8b
>2398	64 47 73 00 10 88 09 dc			.byte	$64,$47,$73,$00,$10,$88,$09,$dc
>23a0	98 41 4b 4b 41 84 8b 41			.byte	$98,$41,$4b,$4b,$41,$84,$8b,$41
>23a8	4b 4b 42 00 0d 92 09 dc			.byte	$4b,$4b,$42,$00,$0d,$92,$09,$dc
>23b0	a6 fe 04 69 74 be 84 42			.byte	$a6,$fe,$04,$69,$74,$be,$84,$42
>23b8	00 1c 9c 09 dc bd 8b 43			.byte	$00,$1c,$9c,$09,$dc,$bd,$8b,$43
>23c0	51 7a fd 05 30 36 37 86			.byte	$51,$7a,$fd,$05,$30,$36,$37,$86
>23c8	43 44 55 74 fd 04 38 39			.byte	$43,$44,$55,$74,$fd,$04,$38,$39
>23d0	be 84 8b 41 00 11 a6 09			.byte	$be,$84,$8b,$41,$00,$11,$a6,$09
>23d8	dc bd 40 88 8b 42 75 5d			.byte	$dc,$bd,$40,$88,$8b,$42,$75,$5d
>23e0	72 be 84 8b 41 00 15 b0			.byte	$72,$be,$84,$8b,$41,$00,$15,$b0
>23e8	09 dc bd 41 79 7e 5b 80			.byte	$09,$dc,$bd,$41,$79,$7e,$5b,$80
>23f0	41 7c 58 5f be 84 41 78			.byte	$41,$7c,$58,$5f,$be,$84,$41,$78
>23f8	58 5b 00 12 ba 09 dc a5			.byte	$58,$5b,$00,$12,$ba,$09,$dc,$a5
>2400	a4 40 fd 03 30 be be 84			.byte	$a4,$40,$fd,$03,$30,$be,$be,$84
>2408	40 fd 03 30 00 16 c4 09			.byte	$40,$fd,$03,$30,$00,$16,$c4,$09
>2410	dc 9b fe 0c 62 75 73 77			.byte	$dc,$9b,$fe,$0c,$62,$75,$73,$77
>2418	66 71 6f 65 6f 70 be 84			.byte	$66,$71,$6f,$65,$6f,$70,$be,$84
>2420	41 62 00 1b ce 09 dc bd			.byte	$41,$62,$00,$1b,$ce,$09,$dc,$bd
>2428	42 57 5d 5e fd 04 32 34			.byte	$42,$57,$5d,$5e,$fd,$04,$32,$34
>2430	87 8b 43 72 4a 66 fd 04			.byte	$87,$8b,$43,$72,$4a,$66,$fd,$04
>2438	37 35 be 84 40 00 12 d8			.byte	$37,$35,$be,$84,$40,$00,$12,$d8
>2440	09 dc bd 41 44 7e 5c 88			.byte	$09,$dc,$bd,$41,$44,$7e,$5c,$88
>2448	55 4f 6e be 84 8b 41 00			.byte	$55,$4f,$6e,$be,$84,$8b,$41,$00
>2450	16 e2 09 dc bd 42 55 66			.byte	$16,$e2,$09,$dc,$bd,$42,$55,$66
>2458	75 82 8b 42 6c 5d 7a be			.byte	$75,$82,$8b,$42,$6c,$5d,$7a,$be
>2460	84 8b 79 7b 4d 00 11 ec			.byte	$84,$8b,$79,$7b,$4d,$00,$11,$ec
>2468	09 dc 9a 8b 43 49 40 7b			.byte	$09,$dc,$9a,$8b,$43,$49,$40,$7b
>2470	be 84 43 49 40 7b 00 0c			.byte	$be,$84,$43,$49,$40,$7b,$00,$0c
>2478	f6 09 dc b4 65 be 84 fe			.byte	$f6,$09,$dc,$b4,$65,$be,$84,$fe
>2480	03 25 00 1a 00 0a dc bd			.byte	$03,$25,$00,$1a,$00,$0a,$dc,$bd
>2488	42 4b 40 43 fd 04 37 32			.byte	$42,$4b,$40,$43,$fd,$04,$37,$32
>2490	88 42 53 6c 7c fd 04 38			.byte	$88,$42,$53,$6c,$7c,$fd,$04,$38
>2498	33 be 84 40 00 14 0a 0a			.byte	$33,$be,$84,$40,$00,$14,$0a,$0a
>24a0	dc bd 8b 41 7d 55 62 85			.byte	$dc,$bd,$8b,$41,$7d,$55,$62,$85
>24a8	41 53 44 49 be 84 8b 41			.byte	$41,$53,$44,$49,$be,$84,$8b,$41
>24b0	00 16 14 0a dc bd 8b 41			.byte	$00,$16,$14,$0a,$dc,$bd,$8b,$41
>24b8	62 68 47 82 41 43 52 74			.byte	$62,$68,$47,$82,$41,$43,$52,$74
>24c0	be 84 8b 61 7a 73 00 0e			.byte	$be,$84,$8b,$61,$7a,$73,$00,$0e
>24c8	1e 0a dc b3 8b 77 40 65			.byte	$1e,$0a,$dc,$b3,$8b,$77,$40,$65
>24d0	be 84 8b 41 00 1e 28 0a			.byte	$be,$84,$8b,$41,$00,$1e,$28,$0a
>24d8	dc a3 53 be 84 fe 15 20			.byte	$dc,$a3,$53,$be,$84,$fe,$15,$20
>24e0	20 20 20 20 20 20 20 20			.byte	$20,$20,$20,$20,$20,$20,$20,$20
>24e8	20 20 20 20 20 20 20 20			.byte	$20,$20,$20,$20,$20,$20,$20,$20
>24f0	20 20 00 27 32 0a dc bd			.byte	$20,$20,$00,$27,$32,$0a,$dc,$bd
>24f8	61 6b 7a fd 04 34 31 8c			.byte	$61,$6b,$7a,$fd,$04,$34,$31,$8c
>2500	8b 42 41 5c 45 fd 03 30			.byte	$8b,$42,$41,$5c,$45,$fd,$03,$30
>2508	be 84 8b 47 fd 0d 33 31			.byte	$be,$84,$8b,$47,$fd,$0d,$33,$31
>2510	35 33 35 33 33 34 65 31			.byte	$35,$33,$35,$33,$33,$34,$65,$31
>2518	30 00 14 3c 0a dc bd 8b			.byte	$30,$00,$14,$3c,$0a,$dc,$bd,$8b
>2520	43 5c 55 7f 8b 40 be 84			.byte	$43,$5c,$55,$7f,$8b,$40,$be,$84
>2528	8b 43 5c 55 7f 00 16 46			.byte	$8b,$43,$5c,$55,$7f,$00,$16,$46
>2530	0a dc bd 8b 41 7e 6f 47			.byte	$0a,$dc,$bd,$8b,$41,$7e,$6f,$47
>2538	82 8b 41 5c 59 74 be 84			.byte	$82,$8b,$41,$5c,$59,$74,$be,$84
>2540	62 76 75 00 14 50 0a dc			.byte	$62,$76,$75,$00,$14,$50,$0a,$dc
>2548	b2 42 70 7a 55 bf 42 46			.byte	$b2,$42,$70,$7a,$55,$bf,$42,$46
>2550	59 7e be 84 6a 60 57 00			.byte	$59,$7e,$be,$84,$6a,$60,$57,$00
>2558	12 5a 0a dc a7 67 7a 7b			.byte	$12,$5a,$0a,$dc,$a7,$67,$7a,$7b
>2560	be 84 fe 07 32 37 45 42			.byte	$be,$84,$fe,$07,$32,$37,$45,$42
>2568	42 00 29 64 0a dc bd 8b			.byte	$42,$00,$29,$64,$0a,$dc,$bd,$8b
>2570	41 43 5c 79 fd 04 39 34			.byte	$41,$43,$5c,$79,$fd,$04,$39,$34
>2578	8c 43 43 7b 58 fd 04 32			.byte	$8c,$43,$43,$7b,$58,$fd,$04,$32
>2580	34 be 84 8b 42 fd 0d 32			.byte	$34,$be,$84,$8b,$42,$fd,$0d,$32
>2588	31 37 32 31 38 35 31 65			.byte	$31,$37,$32,$31,$38,$35,$31,$65
>2590	31 31 00 12 6e 0a dc bd			.byte	$31,$31,$00,$12,$6e,$0a,$dc,$bd
>2598	8b 4d 51 78 84 8b 65 47			.byte	$8b,$4d,$51,$78,$84,$8b,$65,$47
>25a0	51 be 84 40 00 17 78 0a			.byte	$51,$be,$84,$40,$00,$17,$78,$0a
>25a8	dc bd 8b 43 43 42 57 81			.byte	$dc,$bd,$8b,$43,$43,$42,$57,$81
>25b0	41 79 5f 69 be 84 8b 42			.byte	$41,$79,$5f,$69,$be,$84,$8b,$42
>25b8	42 40 57 00 10 82 0a dc			.byte	$42,$40,$57,$00,$10,$82,$0a,$dc
>25c0	98 8b 42 66 5f 40 84 42			.byte	$98,$8b,$42,$66,$5f,$40,$84,$42
>25c8	66 5e 7f 00 11 8c 0a dc			.byte	$66,$5e,$7f,$00,$11,$8c,$0a,$dc
>25d0	af fe 06 41 46 41 45 be			.byte	$af,$fe,$06,$41,$46,$41,$45,$be
>25d8	84 4a 7e 6e 00 1c 96 0a			.byte	$84,$4a,$7e,$6e,$00,$1c,$96,$0a
>25e0	dc bd 8b 41 6f 64 7b fd			.byte	$dc,$bd,$8b,$41,$6f,$64,$7b,$fd
>25e8	04 39 34 88 8b 55 51 6f			.byte	$04,$39,$34,$88,$8b,$55,$51,$6f
>25f0	fd 05 31 34 35 be 84 40			.byte	$fd,$05,$31,$34,$35,$be,$84,$40
>25f8	00 14 a0 0a dc bd 8b 41			.byte	$00,$14,$a0,$0a,$dc,$bd,$8b,$41
>2600	4f 52 60 85 8b 75 52 43			.byte	$4f,$52,$60,$85,$8b,$75,$52,$43
>2608	be 84 8b 41 00 17 aa 0a			.byte	$be,$84,$8b,$41,$00,$17,$aa,$0a
>2610	dc bd 8b 42 65 60 7c 80			.byte	$dc,$bd,$8b,$42,$65,$60,$7c,$80
>2618	8b 4c 58 72 be 84 8b 42			.byte	$8b,$4c,$58,$72,$be,$84,$8b,$42
>2620	6d 78 7c 00 10 b4 0a dc			.byte	$6d,$78,$7c,$00,$10,$b4,$0a,$dc
>2628	a5 a4 71 60 55 be be 84			.byte	$a5,$a4,$71,$60,$55,$be,$be,$84
>2630	71 60 55 00 19 be 0a dc			.byte	$71,$60,$55,$00,$19,$be,$0a,$dc
>2638	a0 fe 08 62 79 7a 62 79			.byte	$a0,$fe,$08,$62,$79,$7a,$62,$79
>2640	69 bf 45 be 84 fe 07 62			.byte	$69,$bf,$45,$be,$84,$fe,$07,$62
>2648	79 7a 62 79 00 1d c8 0a			.byte	$79,$7a,$62,$79,$00,$1d,$c8,$0a
>2650	dc bd 44 58 61 fd 05 32			.byte	$dc,$bd,$44,$58,$61,$fd,$05,$32
>2658	35 39 8a 40 fd 03 30 be			.byte	$35,$39,$8a,$40,$fd,$03,$30,$be
>2660	84 44 58 61 fd 05 32 35			.byte	$84,$44,$58,$61,$fd,$05,$32,$35
>2668	39 00 0f d2 0a dc bd 8b			.byte	$39,$00,$0f,$d2,$0a,$dc,$bd,$8b
>2670	43 6a 46 88 40 be 84 40			.byte	$43,$6a,$46,$88,$40,$be,$84,$40
>2678	00 16 dc 0a dc bd 42 59			.byte	$00,$16,$dc,$0a,$dc,$bd,$42,$59
>2680	66 5d 82 8b 74 5c 5c be			.byte	$66,$5d,$82,$8b,$74,$5c,$5c,$be
>2688	84 8b 42 6d 7a 47 00 10			.byte	$84,$8b,$42,$6d,$7a,$47,$00,$10
>2690	e6 0a dc 9a 43 6b 6b 63			.byte	$e6,$0a,$dc,$9a,$43,$6b,$6b,$63
>2698	be 84 43 6b 6b 63 00 12			.byte	$be,$84,$43,$6b,$6b,$63,$00,$12
>26a0	f0 0a dc a1 fe 04 67 6a			.byte	$f0,$0a,$dc,$a1,$fe,$04,$67,$6a
>26a8	bf 46 be 84 fe 04 67 6a			.byte	$bf,$46,$be,$84,$fe,$04,$67,$6a
>26b0	00 16 fa 0a dc bd 40 fd			.byte	$00,$16,$fa,$0a,$dc,$bd,$40,$fd
>26b8	03 30 86 8b 72 43 66 fd			.byte	$03,$30,$86,$8b,$72,$43,$66,$fd
>26c0	04 31 34 be 84 40 00 0f			.byte	$04,$31,$34,$be,$84,$40,$00,$0f
>26c8	04 0b dc bd 40 86 4e 4d			.byte	$04,$0b,$dc,$bd,$40,$86,$4e,$4d
>26d0	68 be 84 8b 41 00 10 0e			.byte	$68,$be,$84,$8b,$41,$00,$10,$0e
>26d8	0b dc bd 8b 41 42 6d 53			.byte	$0b,$dc,$bd,$8b,$41,$42,$6d,$53
>26e0	80 40 be 84 40 00 0d 18			.byte	$80,$40,$be,$84,$40,$00,$0d,$18
>26e8	0b dc b3 42 79 51 44 be			.byte	$0b,$dc,$b3,$42,$79,$51,$44,$be
>26f0	84 41 00 17 22 0b dc a2			.byte	$84,$41,$00,$17,$22,$0b,$dc,$a2
>26f8	fe 07 79 64 6b 62 72 bf			.byte	$fe,$07,$79,$64,$6b,$62,$72,$bf
>2700	44 bf 46 be 84 fe 04 62			.byte	$44,$bf,$46,$be,$84,$fe,$04,$62
>2708	72 00 19 2c 0b dc bd 5a			.byte	$72,$00,$19,$2c,$0b,$dc,$bd,$5a
>2710	42 6b fd 04 30 31 88 41			.byte	$42,$6b,$fd,$04,$30,$31,$88,$41
>2718	53 70 63 fd 04 36 39 be			.byte	$53,$70,$63,$fd,$04,$36,$39,$be
>2720	84 40 00 14 36 0b dc bd			.byte	$84,$40,$00,$14,$36,$0b,$dc,$bd
>2728	43 66 6c 5f 85 8b 42 72			.byte	$43,$66,$6c,$5f,$85,$8b,$42,$72
>2730	6c 72 be 84 8b 41 00 10			.byte	$6c,$72,$be,$84,$8b,$41,$00,$10
>2738	40 0b dc bd 40 80 8b 41			.byte	$40,$0b,$dc,$bd,$40,$80,$8b,$41
>2740	7d 64 40 be 84 40 00 14			.byte	$7d,$64,$40,$be,$84,$40,$00,$14
>2748	4a 0b dc b2 8b 43 6a 70			.byte	$4a,$0b,$dc,$b2,$8b,$43,$6a,$70
>2750	46 bf 52 7c 4d be 84 47			.byte	$46,$bf,$52,$7c,$4d,$be,$84,$47
>2758	5d 6a 00 10 54 0b dc a6			.byte	$5d,$6a,$00,$10,$54,$0b,$dc,$a6
>2760	fe 07 79 70 61 6f 76 be			.byte	$fe,$07,$79,$70,$61,$6f,$76,$be
>2768	84 45 00 1b 5e 0b dc bd			.byte	$84,$45,$00,$1b,$5e,$0b,$dc,$bd
>2770	43 70 4a 48 fd 03 38 88			.byte	$43,$70,$4a,$48,$fd,$03,$38,$88
>2778	8b 43 70 43 7e fd 04 36			.byte	$8b,$43,$70,$43,$7e,$fd,$04,$36
>2780	33 be 84 8b 41 00 15 68			.byte	$33,$be,$84,$8b,$41,$00,$15,$68
>2788	0b dc bd 8b 43 64 4b 4d			.byte	$0b,$dc,$bd,$8b,$43,$64,$4b,$4d
>2790	87 8b 43 64 4b 4d be 84			.byte	$87,$8b,$43,$64,$4b,$4d,$be,$84
>2798	8b 41 00 16 72 0b dc bd			.byte	$8b,$41,$00,$16,$72,$0b,$dc,$bd
>27a0	8b 63 7c 65 82 8b 42 74			.byte	$8b,$63,$7c,$65,$82,$8b,$42,$74
>27a8	56 78 be 84 42 57 6a 53			.byte	$56,$78,$be,$84,$42,$57,$6a,$53
>27b0	00 0a 7c 0b dc 98 40 84			.byte	$00,$0a,$7c,$0b,$dc,$98,$40,$84
>27b8	8b 41 00 1d 86 0b dc bd			.byte	$8b,$41,$00,$1d,$86,$0b,$dc,$bd
>27c0	40 fd 03 30 8a 41 55 49			.byte	$40,$fd,$03,$30,$8a,$41,$55,$49
>27c8	5e fd 04 34 32 be 84 41			.byte	$5e,$fd,$04,$34,$32,$be,$84,$41
>27d0	55 49 5e fd 04 34 32 00			.byte	$55,$49,$5e,$fd,$04,$34,$32,$00
>27d8	14 90 0b dc bd 42 51 69			.byte	$14,$90,$0b,$dc,$bd,$42,$51,$69
>27e0	62 8a 71 7e 65 be 84 43			.byte	$62,$8a,$71,$7e,$65,$be,$84,$43
>27e8	43 68 47 00 17 9a 0b dc			.byte	$43,$68,$47,$00,$17,$9a,$0b,$dc
>27f0	bd 8b 42 7c 69 63 80 8b			.byte	$bd,$8b,$42,$7c,$69,$63,$80,$8b
>27f8	53 60 57 be 84 8b 42 7f			.byte	$53,$60,$57,$be,$84,$8b,$42,$7f
>2800	69 77 00 12 a4 0b dc a5			.byte	$69,$77,$00,$12,$a4,$0b,$dc,$a5
>2808	a4 42 4c 62 77 be be 84			.byte	$a4,$42,$4c,$62,$77,$be,$be,$84
>2810	42 4c 62 77 00 0d ae 0b			.byte	$42,$4c,$62,$77,$00,$0d,$ae,$0b
>2818	dc b4 41 66 be 84 fe 03			.byte	$dc,$b4,$41,$66,$be,$84,$fe,$03
>2820	66 00 1b b8 0b dc bd 8b			.byte	$66,$00,$1b,$b8,$0b,$dc,$bd,$8b
>2828	43 57 55 61 fd 04 38 32			.byte	$43,$57,$55,$61,$fd,$04,$38,$32
>2830	89 8b 6e 59 64 fd 04 33			.byte	$89,$8b,$6e,$59,$64,$fd,$04,$33
>2838	38 be 84 40 00 15 c2 0b			.byte	$38,$be,$84,$40,$00,$15,$c2,$0b
>2840	dc bd 8b 42 46 4f 74 89			.byte	$dc,$bd,$8b,$42,$46,$4f,$74,$89
>2848	8b 43 6c 57 42 be 84 8b			.byte	$8b,$43,$6c,$57,$42,$be,$84,$8b
>2850	41 00 14 cc 0b dc bd 43			.byte	$41,$00,$14,$cc,$0b,$dc,$bd,$43
>2858	5a 70 7a 82 43 4a 5a 44			.byte	$5a,$70,$7a,$82,$43,$4a,$5a,$44
>2860	be 84 50 6a 7e 00 10 d6			.byte	$be,$84,$50,$6a,$7e,$00,$10,$d6
>2868	0b dc 9a 43 40 46 58 be			.byte	$0b,$dc,$9a,$43,$40,$46,$58,$be
>2870	84 43 40 46 58 00 18 e0			.byte	$84,$43,$40,$46,$58,$00,$18,$e0
>2878	0b dc a3 4d be 84 fe 0f			.byte	$0b,$dc,$a3,$4d,$be,$84,$fe,$0f
>2880	20 20 20 20 20 20 20 20			.byte	$20,$20,$20,$20,$20,$20,$20,$20
>2888	20 20 20 20 20 00 1b ea			.byte	$20,$20,$20,$20,$20,$00,$1b,$ea
>2890	0b dc bd 72 55 6d fd 04			.byte	$0b,$dc,$bd,$72,$55,$6d,$fd,$04
>2898	34 36 85 8b 41 47 5f 4a			.byte	$34,$36,$85,$8b,$41,$47,$5f,$4a
>28a0	fd 04 38 34 be 84 8b 41			.byte	$fd,$04,$38,$34,$be,$84,$8b,$41
>28a8	00 10 f4 0b dc bd 40 84			.byte	$00,$10,$f4,$0b,$dc,$bd,$40,$84
>28b0	8b 42 5f 67 71 be 84 40			.byte	$8b,$42,$5f,$67,$71,$be,$84,$40
>28b8	00 17 fe 0b dc bd 8b 42			.byte	$00,$17,$fe,$0b,$dc,$bd,$8b,$42
>28c0	75 41 42 81 41 57 5b 7e			.byte	$75,$41,$42,$81,$41,$57,$5b,$7e
>28c8	be 84 8b 42 60 40 42 00			.byte	$be,$84,$8b,$42,$60,$40,$42,$00
>28d0	0d 08 0c dc b3 41 42 64			.byte	$0d,$08,$0c,$dc,$b3,$41,$42,$64
>28d8	73 be 84 41 00 13 12 0c			.byte	$73,$be,$84,$41,$00,$13,$12,$0c
>28e0	dc a7 42 41 55 4e be 84			.byte	$dc,$a7,$42,$41,$55,$4e,$be,$84
>28e8	fe 07 38 31 35 34 45 00			.byte	$fe,$07,$38,$31,$35,$34,$45,$00
>28f0	1f 1c 0c dc bd 8b 43 53			.byte	$1f,$1c,$0c,$dc,$bd,$8b,$43,$53
>28f8	6c 6c fd 04 31 32 8b 40			.byte	$6c,$6c,$fd,$04,$31,$32,$8b,$40
>2900	fd 03 30 be 84 8b 43 53			.byte	$fd,$03,$30,$be,$84,$8b,$43,$53
>2908	6c 6c fd 04 31 32 00 14			.byte	$6c,$6c,$fd,$04,$31,$32,$00,$14
>2910	26 0c dc bd 42 46 6e 5b			.byte	$26,$0c,$dc,$bd,$42,$46,$6e,$5b
>2918	8d 8b 41 69 5c 7c be 84			.byte	$8d,$8b,$41,$69,$5c,$7c,$be,$84
>2920	8b 41 00 16 30 0c dc bd			.byte	$8b,$41,$00,$16,$30,$0c,$dc,$bd
>2928	8b 42 59 7c 7d 81 43 4b			.byte	$8b,$42,$59,$7c,$7d,$81,$43,$4b
>2930	5e 6f be 84 8b 50 60 51			.byte	$5e,$6f,$be,$84,$8b,$50,$60,$51
>2938	00 17 3a 0c dc b2 8b 41			.byte	$00,$17,$3a,$0c,$dc,$b2,$8b,$41
>2940	4a 7a 46 bf 8b 42 6c 5c			.byte	$4a,$7a,$46,$bf,$8b,$42,$6c,$5c
>2948	74 be 84 41 4a 7a 46 00			.byte	$74,$be,$84,$41,$4a,$7a,$46,$00
>2950	13 44 0c dc af fe 07 42			.byte	$13,$44,$0c,$dc,$af,$fe,$07,$42
>2958	38 36 33 33 be 84 42 78			.byte	$38,$36,$33,$33,$be,$84,$42,$78
>2960	58 73 00 27 4e 0c dc bd			.byte	$58,$73,$00,$27,$4e,$0c,$dc,$bd
>2968	41 54 62 5f fd 04 39 35			.byte	$41,$54,$62,$5f,$fd,$04,$39,$35
>2970	8c 43 49 56 58 fd 04 34			.byte	$8c,$43,$49,$56,$58,$fd,$04,$34
>2978	32 be 84 42 fd 0d 38 35			.byte	$32,$be,$84,$42,$fd,$0d,$38,$35
>2980	35 38 30 33 31 38 65 31			.byte	$35,$38,$30,$33,$31,$38,$65,$31
>2988	31 00 15 58 0c dc bd 42			.byte	$31,$00,$15,$58,$0c,$dc,$bd,$42
>2990	6e 44 5f 8b 41 66 57 5e			.byte	$6e,$44,$5f,$8b,$41,$66,$57,$5e
>2998	be 84 41 47 6d 41 00 18			.byte	$be,$84,$41,$47,$6d,$41,$00,$18
>29a0	62 0c dc bd 8b 42 77 53			.byte	$62,$0c,$dc,$bd,$8b,$42,$77,$53
>29a8	79 80 8b 42 7b 6d 75 be			.byte	$79,$80,$8b,$42,$7b,$6d,$75,$be
>29b0	84 8b 42 7f 7f 7d 00 0a			.byte	$84,$8b,$42,$7f,$7f,$7d,$00,$0a
>29b8	6c 0c dc 98 40 84 8b 41			.byte	$6c,$0c,$dc,$98,$40,$84,$8b,$41
>29c0	00 12 76 0c dc a0 fe 05			.byte	$00,$12,$76,$0c,$dc,$a0,$fe,$05
>29c8	65 75 77 bf 41 be 84 fe			.byte	$65,$75,$77,$bf,$41,$be,$84,$fe
>29d0	03 65 00 16 80 0c dc bd			.byte	$03,$65,$00,$16,$80,$0c,$dc,$bd
>29d8	40 fd 03 30 84 42 57 4b			.byte	$40,$fd,$03,$30,$84,$42,$57,$4b
>29e0	4a fd 04 36 38 be 84 40			.byte	$4a,$fd,$04,$36,$38,$be,$84,$40
>29e8	00 11 8a 0c dc bd 43 69			.byte	$00,$11,$8a,$0c,$dc,$bd,$43,$69
>29f0	68 4a 86 76 52 55 be 84			.byte	$68,$4a,$86,$76,$52,$55,$be,$84
>29f8	40 00 12 94 0c dc bd 40			.byte	$40,$00,$12,$94,$0c,$dc,$bd,$40
>2a00	82 8b 49 40 78 be 84 8b			.byte	$82,$8b,$49,$40,$78,$be,$84,$8b
>2a08	49 40 78 00 1a 9e 0c dc			.byte	$49,$40,$78,$00,$1a,$9e,$0c,$dc
>2a10	a5 a4 8b 6a 54 5c fd 04			.byte	$a5,$a4,$8b,$6a,$54,$5c,$fd,$04
>2a18	38 33 be be 84 8b 6a 54			.byte	$38,$33,$be,$be,$84,$8b,$6a,$54
>2a20	5c fd 04 38 33 00 1e a8			.byte	$5c,$fd,$04,$38,$33,$00,$1e,$a8
>2a28	0c dc a1 fe 0a 76 77 75			.byte	$0c,$dc,$a1,$fe,$0a,$76,$77,$75
>2a30	62 69 65 6d 6b bf 4a be			.byte	$62,$69,$65,$6d,$6b,$bf,$4a,$be
>2a38	84 fe 0a 76 77 75 62 69			.byte	$84,$fe,$0a,$76,$77,$75,$62,$69
>2a40	65 6d 6b 00 15 b2 0c dc			.byte	$65,$6d,$6b,$00,$15,$b2,$0c,$dc
>2a48	bd 40 fd 03 30 88 71 48			.byte	$bd,$40,$fd,$03,$30,$88,$71,$48
>2a50	46 fd 04 35 31 be 84 40			.byte	$46,$fd,$04,$35,$31,$be,$84,$40
>2a58	00 0f bc 0c dc bd 40 89			.byte	$00,$0f,$bc,$0c,$dc,$bd,$40,$89
>2a60	41 7f 45 50 be 84 40 00			.byte	$41,$7f,$45,$50,$be,$84,$40,$00
>2a68	14 c6 0c dc bd 4c 59 7b			.byte	$14,$c6,$0c,$dc,$bd,$4c,$59,$7b
>2a70	80 8b 41 57 41 5f be 84			.byte	$80,$8b,$41,$57,$41,$5f,$be,$84
>2a78	48 58 61 00 0a d0 0c dc			.byte	$48,$58,$61,$00,$0a,$d0,$0c,$dc
>2a80	9a 40 be 84 40 00 14 da			.byte	$9a,$40,$be,$84,$40,$00,$14,$da
>2a88	0c dc a2 fe 06 78 69 78			.byte	$0c,$dc,$a2,$fe,$06,$78,$69,$78
>2a90	6c bf 4a bf 41 be 84 fe			.byte	$6c,$bf,$4a,$bf,$41,$be,$84,$fe
>2a98	02 00 1c e4 0c dc bd 8b			.byte	$02,$00,$1c,$e4,$0c,$dc,$bd,$8b
>2aa0	42 52 7f 51 fd 04 35 35			.byte	$42,$52,$7f,$51,$fd,$04,$35,$35
>2aa8	86 42 54 40 72 fd 04 34			.byte	$86,$42,$54,$40,$72,$fd,$04,$34
>2ab0	31 be 84 8b 41 00 12 ee			.byte	$31,$be,$84,$8b,$41,$00,$12,$ee
>2ab8	0c dc bd 43 58 59 43 84			.byte	$0c,$dc,$bd,$43,$58,$59,$43,$84
>2ac0	41 54 5b 61 be 84 40 00			.byte	$41,$54,$5b,$61,$be,$84,$40,$00
>2ac8	0f f8 0c dc bd 40 80 41			.byte	$0f,$f8,$0c,$dc,$bd,$40,$80,$41
>2ad0	7c 49 60 be 84 40 00 0f			.byte	$7c,$49,$60,$be,$84,$40,$00,$0f
>2ad8	02 0d dc b3 8b 42 5b 63			.byte	$02,$0d,$dc,$b3,$8b,$42,$5b,$63
>2ae0	5c be 84 8b 41 00 0c 0c			.byte	$5c,$be,$84,$8b,$41,$00,$0c,$0c
>2ae8	0d dc a6 fe 03 75 be 84			.byte	$0d,$dc,$a6,$fe,$03,$75,$be,$84
>2af0	41 00 1a 16 0d dc bd 69			.byte	$41,$00,$1a,$16,$0d,$dc,$bd,$69
>2af8	44 7e fd 04 30 31 85 42			.byte	$44,$7e,$fd,$04,$30,$31,$85,$42
>2b00	4d 60 55 fd 04 30 34 be			.byte	$4d,$60,$55,$fd,$04,$30,$34,$be
>2b08	84 8b 41 00 11 20 0d dc			.byte	$84,$8b,$41,$00,$11,$20,$0d,$dc
>2b10	bd 57 67 44 8d 41 73 68			.byte	$bd,$57,$67,$44,$8d,$41,$73,$68
>2b18	67 be 84 40 00 15 2a 0d			.byte	$67,$be,$84,$40,$00,$15,$2a,$0d
>2b20	dc bd 41 7e 5b 72 81 41			.byte	$dc,$bd,$41,$7e,$5b,$72,$81,$41
>2b28	7d 46 75 be 84 41 7f 5f			.byte	$7d,$46,$75,$be,$84,$41,$7f,$5f
>2b30	77 00 17 34 0d dc b2 8b			.byte	$77,$00,$17,$34,$0d,$dc,$b2,$8b
>2b38	42 6e 43 76 bf 8b 41 5b			.byte	$42,$6e,$43,$76,$bf,$8b,$41,$5b
>2b40	46 62 be 84 41 52 7d 54			.byte	$46,$62,$be,$84,$41,$52,$7d,$54
>2b48	00 10 3e 0d dc 9b fe 06			.byte	$00,$10,$3e,$0d,$dc,$9b,$fe,$06
>2b50	6c 74 78 68 be 84 41 6c			.byte	$6c,$74,$78,$68,$be,$84,$41,$6c
>2b58	00 23 48 0d dc bd 8b 43			.byte	$00,$23,$48,$0d,$dc,$bd,$8b,$43
>2b60	51 58 40 fd 04 37 37 8a			.byte	$51,$58,$40,$fd,$04,$37,$37,$8a
>2b68	41 68 69 7b fd 04 31 38			.byte	$41,$68,$69,$7b,$fd,$04,$31,$38
>2b70	be 84 8b 41 68 6e 45 fd			.byte	$be,$84,$8b,$41,$68,$6e,$45,$fd
>2b78	04 35 39 00 13 52 0d dc			.byte	$04,$35,$39,$00,$13,$52,$0d,$dc
>2b80	bd 8b 42 67 75 57 84 8b			.byte	$bd,$8b,$42,$67,$75,$57,$84,$8b
>2b88	6b 5e 67 be 84 40 00 12			.byte	$6b,$5e,$67,$be,$84,$40,$00,$12
>2b90	5c 0d dc bd 4c 4e 6e 81			.byte	$5c,$0d,$dc,$bd,$4c,$4e,$6e,$81
>2b98	4f 4f 52 be 84 4f 4f 7e			.byte	$4f,$4f,$52,$be,$84,$4f,$4f,$7e
>2ba0	00 10 66 0d dc 98 8b 41			.byte	$00,$10,$66,$0d,$dc,$98,$8b,$41
>2ba8	4a 42 6d 84 41 4a 42 6c			.byte	$4a,$42,$6d,$84,$41,$4a,$42,$6c
>2bb0	00 0d 70 0d dc b4 41 42			.byte	$00,$0d,$70,$0d,$dc,$b4,$41,$42
>2bb8	be 84 fe 03 42 00 1a 7a			.byte	$be,$84,$fe,$03,$42,$00,$1a,$7a
>2bc0	0d dc bd 44 70 77 fd 05			.byte	$0d,$dc,$bd,$44,$70,$77,$fd,$05
>2bc8	38 34 35 88 44 70 77 fd			.byte	$38,$34,$35,$88,$44,$70,$77,$fd
>2bd0	05 38 34 35 be 84 40 00			.byte	$05,$38,$34,$35,$be,$84,$40,$00
>2bd8	18 84 0d dc bd 8b 42 5b			.byte	$18,$84,$0d,$dc,$bd,$8b,$42,$5b
>2be0	4d 59 8a 8b 42 4e 5b 42			.byte	$4d,$59,$8a,$8b,$42,$4e,$5b,$42
>2be8	be 84 8b 44 69 68 5b 00			.byte	$be,$84,$8b,$44,$69,$68,$5b,$00
>2bf0	12 8e 0d dc bd 43 4f 65			.byte	$12,$8e,$0d,$dc,$bd,$43,$4f,$65
>2bf8	59 82 40 be 84 43 4f 65			.byte	$59,$82,$40,$be,$84,$43,$4f,$65
>2c00	59 00 1c 98 0d dc a5 a4			.byte	$59,$00,$1c,$98,$0d,$dc,$a5,$a4
>2c08	8b 41 5b 7e 76 fd 04 39			.byte	$8b,$41,$5b,$7e,$76,$fd,$04,$39
>2c10	35 be be 84 8b 41 5b 7e			.byte	$35,$be,$be,$84,$8b,$41,$5b,$7e
>2c18	76 fd 04 39 35 00 1b a2			.byte	$76,$fd,$04,$39,$35,$00,$1b,$a2
>2c20	0d dc a3 50 be 84 fe 12			.byte	$0d,$dc,$a3,$50,$be,$84,$fe,$12
>2c28	20 20 20 20 20 20 20 20			.byte	$20,$20,$20,$20,$20,$20,$20,$20
>2c30	20 20 20 20 20 20 20 20			.byte	$20,$20,$20,$20,$20,$20,$20,$20
>2c38	00 29 ac 0d d6 fe 22 50			.byte	$00,$29,$ac,$0d,$d6,$fe,$22,$50
>2c40	61 73 73 65 64 20 41 72			.byte	$61,$73,$73,$65,$64,$20,$41,$72
>2c48	69 74 68 6d 65 74 69 63			.byte	$69,$74,$68,$6d,$65,$74,$69,$63
>2c50	2c 4c 6f 67 69 63 61 6c			.byte	$2c,$4c,$6f,$67,$69,$63,$61,$6c
>2c58	2c 55 6e 61 72 79 2e c0			.byte	$2c,$55,$6e,$61,$72,$79,$2e,$c0
>2c60	c4 00 00				.byte	$c4,$00,$00

;******  Return to file: modules/hardware/em65816.asm

.c000					StartROM:
.c000	18		clc				clc
.c001	fb		xce				xce
.c002	c2 30		rep #$30			rep 	#$30
.c004	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.c007	1b		tcs				tcs
.c008	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.c00b	e2 30		sep #$30			sep 	#$30
.c00d	c2 30		rep #$30			rep 	#$30						; clear AXY in 16 bit.
.c00f	a9 00		lda #$00			lda 	#$0000
.c011	aa		tax				tax
.c012	a8		tay				tay
.c013	e2 30		sep #$30			sep 	#$30
.c015	5c 01 88 01	jmp $018801		jmp BASIC_Start
.c019					TIM_BreakHandler:
.c019	5c 69 83 01	jmp $018369			jmp 	TIM_BreakVector

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.018000					IFT_ClearScreen:
.018000	48		pha				pha
.018001	da		phx				phx
.018002	5a		phy				phy
.018003	20 9c 81	jsr $01819c			jsr 	IF_Home 					; home cursor
.018006	a2 20		ldx #$20			ldx 	#IF_Height 					; this many lines.
.018008					_IFT_CS0:
.018008	a0 40		ldy #$40			ldy 	#IF_Width 					; this many chars/line
.01800a					_IFT_CS1:
.01800a	a9 20		lda #$20			lda 	#' '						; clear line.
.01800c	20 c8 81	jsr $0181c8			jsr 	IF_Write
.01800f	88		dey				dey
.018010	d0 f8		bne $01800a			bne 	_IFT_CS1
.018012	20 af 81	jsr $0181af			jsr 	IF_NewLine 					; next line down
.018015	ca		dex				dex
.018016	d0 f0		bne $018008			bne 	_IFT_CS0
.018018	7a		ply				ply
.018019	fa		plx				plx
.01801a	68		pla				pla
.01801b					IFT_HomeCursor:
.01801b	48		pha				pha
.01801c	20 9c 81	jsr $01819c			jsr 	IF_Home
.01801f	a9 00		lda #$00			lda 	#0
.018021	8d 00 05	sta $0500			sta 	IFT_XCursor
.018024	8d 01 05	sta $0501			sta 	IFT_YCursor
.018027	68		pla				pla
.018028	60		rts				rts
.018029					IFT_UpLine:
.018029	48		pha				pha
.01802a	ad 01 05	lda $0501			lda  	IFT_YCursor 				; get Y
.01802d	3a		dec a				dec 	a 							; line above
.01802e	30 03		bmi $018033			bmi 	_IFTULExit 					; too far, abort
.018030	20 be 80	jsr $0180be			jsr 	IFT_SetYPos					; set to that line.
.018033					_IFTULExit:
.018033	68		pla				pla
.018034	60		rts				rts
.018035					IFT_PrintCharacter:
.018035	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.018037	f0 16		beq $01804f			beq 	IFT_NewLine
.018039	48		pha				pha
.01803a	20 67 80	jsr $018067			jsr 	IFT_UpperCase 				; make upper case
.01803d	20 c8 81	jsr $0181c8			jsr 	IF_Write 					; write out.
.018040	ee 00 05	inc $0500			inc 	IFT_XCursor 				; bump x cursor
.018043	ad 00 05	lda $0500			lda 	IFT_XCursor 				; reached RHS ?
.018046	c9 40		cmp #$40			cmp 	#IF_Width
.018048	d0 03		bne $01804d			bne 	_IFT_PCNotEOL
.01804a	20 4f 80	jsr $01804f			jsr 	IFT_NewLine 				; if so do new line.
.01804d					_IFT_PCNotEOL:
.01804d	68		pla				pla
.01804e	60		rts				rts
.01804f					IFT_NewLine:
.01804f	48		pha				pha
.018050	20 af 81	jsr $0181af			jsr 	IF_NewLine 					; new line on actual screen.
.018053	a9 00		lda #$00			lda 	#0 							; reset x position
.018055	8d 00 05	sta $0500			sta 	IFT_XCursor
.018058	ee 01 05	inc $0501			inc 	IFT_YCursor 				; move down.
.01805b	ad 01 05	lda $0501			lda 	IFT_YCursor
.01805e	c9 20		cmp #$20			cmp 	#IF_Height 					; reached bottom.
.018060	d0 03		bne $018065			bne 	_IFT_NL_NotEOS
.018062	20 72 80	jsr $018072			jsr 	IFT_Scroll 					; scroll screen up.
.018065					_IFT_NL_NotEOS:
.018065	68		pla				pla
.018066	60		rts				rts
.018067					IFT_UpperCase:
.018067	c9 61		cmp #$61			cmp 	#"a"
.018069	90 06		bcc $018071			bcc 	_IFT_UCExit
.01806b	c9 7b		cmp #$7b			cmp 	#"z"+1
.01806d	b0 02		bcs $018071			bcs 	_IFT_UCExit
.01806f	49 20		eor #$20			eor 	#$20
.018071					_IFT_UCExit:
.018071	60		rts				rts
.018072					IFT_Scroll:
.018072	48		pha				pha 								; save AXY
.018073	da		phx				phx
.018074	5a		phy				phy
.018075	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.018077					_IFT_SLoop:
.018077	20 97 80	jsr $018097			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.01807a	e8		inx				inx
.01807b	e0 1f		cpx #$1f			cpx 	#IF_Height-1				; do whole screen
.01807d	d0 f8		bne $018077			bne 	_IFT_SLoop
.01807f	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.018081	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.018084	a2 40		ldx #$40			ldx 	#IF_Width 					; blank line
.018086					_IFT_SBlank:
.018086	a9 20		lda #$20			lda 	#32
.018088	20 c8 81	jsr $0181c8			jsr 	IF_Write
.01808b	ca		dex				dex
.01808c	d0 f8		bne $018086			bne 	_IFT_SBlank
.01808e	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.018090	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.018093	7a		ply				ply
.018094	fa		plx				plx
.018095	68		pla				pla
.018096	60		rts				rts
.018097					_IFT_ScrollLine:
.018097	da		phx				phx
.018098	da		phx				phx
.018099	8a		txa				txa 								; copy line into buffer.
.01809a	1a		inc a				inc 	a 							; next line down.
.01809b	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.01809e	a2 00		ldx #$00			ldx 	#0
.0180a0					_IFTScrollCopy1:
.0180a0	20 bf 81	jsr $0181bf			jsr 	IF_Read
.0180a3	9d 02 05	sta $0502,x			sta 	IFT_Buffer,x
.0180a6	e8		inx				inx
.0180a7	e0 40		cpx #$40			cpx 	#IF_Width
.0180a9	d0 f5		bne $0180a0			bne 	_IFTScrollCopy1
.0180ab	68		pla				pla
.0180ac	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.0180af	a2 00		ldx #$00			ldx 	#0
.0180b1					_IFTScrollCopy2:
.0180b1	bd 02 05	lda $0502,x			lda 	IFT_Buffer,x
.0180b4	20 c8 81	jsr $0181c8			jsr 	IF_Write
.0180b7	e8		inx				inx
.0180b8	e0 40		cpx #$40			cpx 	#IF_Width
.0180ba	d0 f5		bne $0180b1			bne 	_IFTScrollCopy2
.0180bc	fa		plx				plx
.0180bd	60		rts				rts
.0180be					IFT_SetYPos:
.0180be	48		pha				pha
.0180bf	da		phx				phx
.0180c0	aa		tax				tax
.0180c1	20 1b 80	jsr $01801b			jsr 	IFT_HomeCursor
.0180c4	e0 00		cpx #$00			cpx 	#0
.0180c6	f0 09		beq $0180d1			beq 	_IFT_MOAExit
.0180c8					_IFT_MOALoop:
.0180c8	20 af 81	jsr $0181af			jsr 	IF_NewLine
.0180cb	ee 01 05	inc $0501			inc 	IFT_YCursor
.0180ce	ca		dex				dex
.0180cf	d0 f7		bne $0180c8			bne		_IFT_MOALoop
.0180d1					_IFT_MOAExit:
.0180d1	fa		plx				plx
.0180d2	68		pla				pla
.0180d3	60		rts				rts
.0180d4					IFT_GetKeyCursor:
.0180d4	20 dc 80	jsr $0180dc			jsr 	_IFT_FlipCursor 			; reverse current
.0180d7					_IFT_GKCWait:
.0180d7	20 d9 81	jsr $0181d9			jsr 	IF_GetKey 					; get key
.0180da	f0 fb		beq $0180d7			beq 	_IFT_GKCWait
.0180dc					_IFT_FlipCursor:
.0180dc	48		pha				pha 								; save
.0180dd	20 bf 81	jsr $0181bf			jsr 	IF_Read 					; read
.0180e0	20 d1 81	jsr $0181d1			jsr 	IF_LeftOne
.0180e3	49 80		eor #$80			eor 	#$80 						; reverse
.0180e5	20 c8 81	jsr $0181c8			jsr 	IF_Write 					; write
.0180e8	20 d1 81	jsr $0181d1			jsr 	IF_LeftOne
.0180eb	68		pla				pla
.0180ec	60		rts				rts
.0180ed					IFT_ReadLine:
.0180ed	48		pha				pha
.0180ee					_IFT_RLLoop:
.0180ee	20 d4 80	jsr $0180d4			jsr 	IFT_GetKeyCursor 			; get keystroke
.0180f1	c9 0d		cmp #$0d			cmp 	#13							; return
.0180f3	f0 7d		beq $018172			beq 	_IFT_RLExit
.0180f5	c9 20		cmp #$20			cmp 	#32 						; control character
.0180f7	90 05		bcc $0180fe			bcc 	_IFT_Control
.0180f9	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0180fc	80 f0		bra $0180ee			bra 	_IFT_RLLoop
.0180fe					_IFT_Control:
.0180fe	c9 01		cmp #$01			cmp 	#"A"-64
.018100	f0 26		beq $018128			beq 	_IFT_Left
.018102	c9 04		cmp #$04			cmp 	#"D"-64
.018104	f0 2e		beq $018134			beq 	_IFT_Right
.018106	c9 17		cmp #$17			cmp 	#"W"-64
.018108	f0 36		beq $018140			beq 	_IFT_Up
.01810a	c9 13		cmp #$13			cmp 	#"S"-64
.01810c	f0 3e		beq $01814c			beq 	_IFT_Down
.01810e	c9 08		cmp #$08			cmp 	#"H"-64
.018110	f0 09		beq $01811b			beq 	_IFT_Backspace
.018112	c9 1a		cmp #$1a			cmp 	#"Z"-64
.018114	d0 d8		bne $0180ee			bne 	_IFT_RLLoop
.018116	20 00 80	jsr $018000			jsr 	IFT_ClearScreen				; clear CTL-Z
.018119	80 d3		bra $0180ee			bra 	_IFT_RLLoop
.01811b					_IFT_Backspace:
.01811b	ad 00 05	lda $0500			lda 	IFT_XCursor 				; check not start of line.
.01811e	f0 ce		beq $0180ee			beq 	_IFT_RLLoop
.018120	20 d1 81	jsr $0181d1			jsr 	IF_LeftOne
.018123	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.018125	20 c8 81	jsr $0181c8			jsr 	IF_Write
.018128					_IFT_Left:
.018128	ce 00 05	dec $0500			dec 	IFT_XCursor 				; left CTL-W
.01812b	10 29		bpl $018156			bpl 	_IFT_Reposition
.01812d	a9 3f		lda #$3f			lda 	#IF_Width-1
.01812f					_IFT_SetX:
.01812f	8d 00 05	sta $0500			sta 	IFT_XCursor
.018132	80 22		bra $018156			bra 	_IFT_Reposition
.018134					_IFT_Right:
.018134	ee 00 05	inc $0500			inc 	IFT_XCursor
.018137	ad 00 05	lda $0500			lda 	IFT_XCursor
.01813a	49 40		eor #$40			eor 	#IF_Width
.01813c	f0 f1		beq $01812f			beq 	_IFT_SetX
.01813e	80 16		bra $018156			bra 	_IFT_Reposition
.018140					_IFT_Up:
.018140	ce 01 05	dec $0501			dec 	IFT_YCursor
.018143	10 11		bpl $018156			bpl 	_IFT_Reposition
.018145	a9 1f		lda #$1f			lda 	#IF_Height-1
.018147					_IFT_SetY:
.018147	8d 01 05	sta $0501			sta 	IFT_YCursor
.01814a	80 0a		bra $018156			bra 	_IFT_Reposition
.01814c					_IFT_Down:
.01814c	ee 01 05	inc $0501			inc 	IFT_YCursor
.01814f	ad 01 05	lda $0501			lda 	IFT_YCursor
.018152	49 20		eor #$20			eor 	#IF_Height
.018154	f0 f1		beq $018147			beq 	_IFT_SetY
.018156					_IFT_Reposition:
.018156	ad 00 05	lda $0500			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.018159	48		pha				pha
.01815a	ad 01 05	lda $0501			lda 	IFT_YCursor
.01815d	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.018160	68		pla				pla
.018161	aa		tax				tax
.018162	e0 00		cpx #$00			cpx 	#0
.018164	f0 88		beq $0180ee			beq 	_IFT_RLLoop
.018166					_IFT_MoveRight:
.018166	20 bf 81	jsr $0181bf			jsr 	IF_Read
.018169	ee 00 05	inc $0500			inc 	IFT_XCursor
.01816c	ca		dex				dex
.01816d	d0 f7		bne $018166			bne 	_IFT_MoveRight
.01816f	4c ee 80	jmp $0180ee			jmp 	_IFT_RLLoop
.018172					_IFT_RLExit:
.018172	ad 01 05	lda $0501			lda 	IFT_YCursor 				; go to start of line.
.018175	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.018178	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.01817a					_IFT_RLRead:
.01817a	20 bf 81	jsr $0181bf			jsr 	IF_Read
.01817d	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.018180	e8		inx				inx
.018181	e0 40		cpx #$40			cpx 	#IF_Width
.018183	d0 f5		bne $01817a			bne 	_IFT_RLRead
.018185					_IFT_RL_Trim:
.018185	ca		dex				dex 	 							; previous char
.018186	30 07		bmi $01818f			bmi 	_IFT_Found 					; gone too far
.018188	bd 66 05	lda $0566,x			lda 	IFT_LineBuffer,x			; go back if space
.01818b	c9 20		cmp #$20			cmp 	#" "
.01818d	f0 f6		beq $018185			beq 	_IFT_RL_Trim
.01818f					_IFT_Found:
.01818f	e8		inx				inx 								; forward to non-space
.018190	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.018192	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.018195	68		pla				pla
.018196	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.018198	a0 05		ldy #$05			ldy 	#IFT_LineBuffer >> 8
.01819a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_em65816.asm

=64					IF_Width 	= 64 							; characters across
=32					IF_Height 	= 32 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line.
=8					IF_XPos 	= 8 							; current position, horizontal.
=$f0000					IF_Screen = $F0000							; 2k screen RAM here
=$f8010					IF_PKeyboard = $F8010						; Keyboard port.
=$f8000					IF_PBreak = $F8000 							; Break key.
.01819b					IF_Reset:
.01819b	60		rts				rts
.01819c					IF_Home:
.01819c	48		pha				pha
.01819d	64 08		stz $08				stz 	IF_XPos 					; zero X position
.01819f	a9 00		lda #$00			lda 	#IF_Screen & $FF 			; set r/w pos.
.0181a1	85 04		sta $04				sta 	IF_Pos
.0181a3	a9 00		lda #$00			lda 	#(IF_Screen >> 8) & $FF
.0181a5	85 05		sta $05				sta 	IF_Pos+1
.0181a7	a9 0f		lda #$0f			lda 	#IF_Screen >> 16
.0181a9	85 06		sta $06				sta 	IF_Pos+2
.0181ab	64 07		stz $07				stz 	IF_Pos+3
.0181ad	68		pla				pla
.0181ae	60		rts				rts
.0181af					IF_NewLine:
.0181af	48		pha				pha
.0181b0	64 08		stz $08				stz 	IF_XPos						; back to start of line
.0181b2	18		clc				clc 								; down one line
.0181b3	a5 04		lda $04				lda 	IF_Pos
.0181b5	69 40		adc #$40			adc 	#64
.0181b7	85 04		sta $04				sta 	IF_Pos
.0181b9	90 02		bcc $0181bd			bcc 	_IF_NoCarry 				; carry through.
.0181bb	e6 05		inc $05				inc 	IF_Pos+1
.0181bd					_IF_NoCarry:
.0181bd	68		pla				pla
.0181be	60		rts				rts
.0181bf					IF_Read:
.0181bf	5a		phy				phy 								; save current Y
.0181c0	a4 08		ldy $08				ldy 	IF_XPos 					; read character at current position
.0181c2	b7 04		lda [$04],y			lda 	[IF_Pos],y
.0181c4	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181c6	7a		ply				ply									; restore Y
.0181c7	60		rts				rts
.0181c8					IF_Write:
.0181c8	5a		phy				phy 								; save current Y
.0181c9	a4 08		ldy $08				ldy 	IF_XPos 					; write character at current position
.0181cb	97 04		sta [$04],y			sta 	[IF_Pos],y
.0181cd	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181cf	7a		ply				ply									; restore Y
.0181d0	60		rts				rts
.0181d1					IF_LeftOne:
.0181d1	c6 08		dec $08				dec 	IF_XPos
.0181d3	60		rts				rts
.0181d4					IF_CheckBreak:
.0181d4	af 00 80 0f	lda $0f8000			lda 	IF_PBreak					; non-zero if Ctrl+C pressed.
.0181d8	60		rts				rts
.0181d9					IF_GetKey:
.0181d9	af 10 80 0f	lda $0f8010			lda 	IF_PKeyboard				; read keyboard
.0181dd	f0 08		beq $0181e7			beq		_IFGK_NoKey 				; skip if zero,no key pressed
.0181df	48		pha				pha 								; key pressed, clear queue.
.0181e0	a9 00		lda #$00			lda 	#0
.0181e2	8f 10 80 0f	sta $0f8010			sta 	IF_PKeyboard
.0181e6	68		pla				pla
.0181e7					_IFGK_NoKey:
.0181e7	09 00		ora #$00			ora 	#0							; set Z flag appropriately.
.0181e9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.0181ea					TIM_Error:
.0181ea	20 29 80	jsr $018029			jsr 	IFT_UpLine 					; go up one line.
.0181ed	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.0181ef	80 02		bra $0181f3			bra 	TIM_ShowPrompt
.0181f1					TIM_NewCommand:
.0181f1	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.0181f3					TIM_ShowPrompt:
.0181f3	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.0181f6	20 ed 80	jsr $0180ed			jsr 	IFT_ReadLine	 			; get character, go to next line
.0181f9	20 4f 80	jsr $01804f			jsr 	IFT_NewLine					; go to next line.
.0181fc	86 10		stx $10				stx 	zTemp1 						; save line read address
.0181fe	84 11		sty $11				sty 	zTemp1+1
.018200	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.018202	b1 10		lda ($10),y			lda 	(zTemp1),y
.018204	c9 3f		cmp #$3f			cmp 	#"?"
.018206	f0 04		beq $01820c			beq 	TIM_SkipFirst
.018208	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.01820a	d0 01		bne $01820d			bne 	TIM_NotDot
.01820c					TIM_SkipFirst:
.01820c	c8		iny				iny
.01820d					TIM_NotDot:
.01820d	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.01820f	c9 52		cmp #$52			cmp 	#"R"						; show registers
.018211	f0 6b		beq $01827e			beq 	TIM_ShowRegisters
.018213	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.018215	f0 12		beq $018229			beq 	TIM_ShowMemory
.018217	c9 47		cmp #$47			cmp 	#"G"						; execute
.018219	f0 49		beq $018264			beq 	TIM_Execute
.01821b	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.01821d	f0 07		beq $018226			beq 	TIM_GoLoadMemory
.01821f	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.018221	d0 c7		bne $0181ea			bne 	TIM_Error
.018223	4c a2 83	jmp $0183a2			jmp 	TIM_UpdateRegisters
.018226					TIM_GoLoadMemory:
.018226	4c d2 83	jmp $0183d2			jmp 	TIM_LoadMemory
.018229					TIM_ShowMemory:
.018229	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.01822c	b0 bc		bcs $0181ea			bcs 	TIM_Error
.01822e	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.018230	85 12		sta $12				sta 	zTemp2
.018232	a5 15		lda $15				lda 	zTemp3+1
.018234	85 13		sta $13				sta 	zTemp2+1
.018236	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.018239	90 08		bcc $018243			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.01823b	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.01823d	85 14		sta $14				sta 	zTemp3
.01823f	a5 13		lda $13				lda 	zTemp2+1
.018241	85 15		sta $15				sta 	zTemp3+1
.018243					_TIMSM_Start:
.018243	20 f6 82	jsr $0182f6			jsr 	TIM_WriteLine 				; write one line of hex out
.018246	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.018248	18		clc				clc
.018249	69 10		adc #$10			adc 	#16
.01824b	85 12		sta $12				sta 	zTemp2
.01824d	90 02		bcc $018251			bcc 	_TIMSM_NoCarry
.01824f	e6 13		inc $13				inc 	zTemp2+1
.018251					_TIMSM_NoCarry:
.018251	20 d4 81	jsr $0181d4			jsr 	IF_CheckBreak 				; check CTL+C
.018254	d0 0b		bne $018261			bne 	_TIMSM_Ends 				; if pressed break out.
.018256	38		sec				sec 								; check past the end address in zTemp3
.018257	a5 14		lda $14				lda 	zTemp3
.018259	e5 12		sbc $12				sbc 	zTemp2
.01825b	a5 15		lda $15				lda 	zTemp3+1
.01825d	e5 13		sbc $13				sbc 	zTemp2+1
.01825f	10 e2		bpl $018243			bpl 	_TIMSM_Start
.018261					_TIMSM_Ends:
.018261	4c f1 81	jmp $0181f1			jmp 	TIM_NewCommand
.018264					TIM_Execute:
.018264	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; get the execute address
.018267	b0 81		bcs $0181ea			bcs 	TIM_Error 					; not legitimate
.018269	ae cb 03	ldx $03cb			ldx 	TIM_SP 						; set up SP
.01826c	9a		txs				txs
.01826d	ad c6 03	lda $03c6			lda 	TIM_SR 						; Status for PLP
.018270	48		pha				pha
.018271	ad c7 03	lda $03c7			lda 	TIM_A 						; restore AXYZ
.018274	ae c8 03	ldx $03c8			ldx 	TIM_X
.018277	ac c9 03	ldy $03c9			ldy 	TIM_Y
.01827a	28		plp				plp 								; and PS Byte.
.01827b	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.01827e					TIM_Start:
.01827e					TIM_ShowRegisters:
.01827e	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.018281	8d c5 03	sta $03c5			sta 	TIM_IRQ+1
.018284	ad ff ff	lda $ffff			lda 	$FFFF
.018287	8d c4 03	sta $03c4			sta 	TIM_IRQ
.01828a	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.01828c					_TIMSR_Text:
.01828c	bf bd 82 01	lda $0182bd,x			lda 	_TIMSR_Label,x
.018290	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018293	e8		inx				inx
.018294	e0 20		cpx #$20			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.018296	d0 f4		bne $01828c			bne 	_TIMSR_Text
.018298	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.01829a					_TIMSR_Skip:
.01829a	e8		inx				inx
.01829b					_TIMSR_LoopSpace:
.01829b	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.01829d	b0 04		bcs $0182a3			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.01829f	8a		txa				txa
.0182a0	4a		lsr a				lsr 	a
.0182a1	b0 05		bcs $0182a8			bcs 	_TIMSR_NoSpace
.0182a3					_TIMSR_Space:
.0182a3	a9 20		lda #$20			lda 	#" "
.0182a5	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182a8					_TIMSR_NoSpace:
.0182a8	bd c2 03	lda $03c2,x			lda 	TIM_PC,x 					; output hex value.
.0182ab	20 dd 82	jsr $0182dd			jsr 	TIM_WriteHex
.0182ae	e8		inx				inx
.0182af	e0 08		cpx #$08			cpx 	#TIM_Z-TIM_PC
.0182b1	f0 e7		beq $01829a			beq 	_TIMSR_Skip
.0182b3	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.0182b5	d0 e4		bne $01829b			bne 	_TimSR_LoopSpace
.0182b7	20 4f 80	jsr $01804f			jsr 	IFT_NewLine 				; new line
.0182ba	4c f1 81	jmp $0181f1			jmp	 	TIM_NewCommand 				; new command.
.0182bd					_TIMSR_Label:
>0182bd	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>0182c5	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>0182d5	52
>0182d6	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.0182dd					_TIMSR_LabelEnd:
.0182dd					TIM_WriteHex:
.0182dd	48		pha				pha 								; save A
.0182de	4a		lsr a				lsr 	a 							; shift MSB->LSB
.0182df	4a		lsr a				lsr 	a
.0182e0	4a		lsr a				lsr 	a
.0182e1	4a		lsr a				lsr 	a
.0182e2	20 e6 82	jsr $0182e6			jsr 	_TIMWH_Nibble 				; print MSB
.0182e5	68		pla				pla 								; restore and print LSB
.0182e6					_TIMWH_Nibble:
.0182e6	48		pha				pha
.0182e7	29 0f		and #$0f			and 	#15 						; mask out
.0182e9	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.0182eb	90 02		bcc $0182ef			bcc 	_TIMWHNoLetter
.0182ed	69 06		adc #$06			adc 	#6
.0182ef					_TIMWHNoLetter:
.0182ef	69 30		adc #$30			adc 	#48
.0182f1	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter 			; print it out.
.0182f4	68		pla				pla
.0182f5	60		rts				rts
.0182f6					TIM_WriteLine:
.0182f6	a9 2e		lda #$2e			lda 	#"." 						; prompt
.0182f8	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182fb	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.0182fd	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018300	a5 13		lda $13				lda 	zTemp2+1 					; write address
.018302	20 dd 82	jsr $0182dd			jsr 	TIM_WriteHex
.018305	a5 12		lda $12				lda 	zTemp2
.018307	20 dd 82	jsr $0182dd			jsr 	TIM_WriteHex
.01830a	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.01830c					_TIMWL_Loop:
.01830c	a9 20		lda #$20			lda 	#" "
.01830e	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018311	b1 12		lda ($12),y			lda 	(zTemp2),y
.018313	20 dd 82	jsr $0182dd			jsr 	TIM_WriteHex
.018316	c8		iny				iny
.018317	c0 10		cpy #$10			cpy 	#16
.018319	d0 f1		bne $01830c			bne 	_TIMWL_Loop
.01831b	4c 4f 80	jmp $01804f			jmp 	IFT_NewLine 				; new line and exit
.01831e					TIM_GetHex:
.01831e	c8		iny				iny
.01831f	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.018321	c9 20		cmp #$20			cmp 	#32
.018323	f0 f9		beq $01831e			beq 	TIM_GetHex
.018325	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.018327	f0 f5		beq $01831e			beq 	TIM_GetHex
.018329	20 52 83	jsr $018352			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.01832c	b0 23		bcs $018351			bcs 	_TIMGH_Exit					; if first bad then exit now.
.01832e	a9 00		lda #$00			lda 	#0 							; zero result
.018330	85 14		sta $14				sta 	zTemp3
.018332	85 15		sta $15				sta 	zTemp3+1
.018334					_TIM_GHLoop:
.018334	20 52 83	jsr $018352			jsr 	TIM_GetHexCharacter 		; get next character
.018337	b0 17		bcs $018350			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.018339	c8		iny				iny 								; skip over it.
.01833a	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.01833c	26 15		rol $15				rol 	zTemp3+1
.01833e	06 14		asl $14				asl 	zTemp3 						; now x 2
.018340	26 15		rol $15				rol 	zTemp3+1
.018342	06 14		asl $14				asl 	zTemp3						; now x 4
.018344	26 15		rol $15				rol 	zTemp3+1
.018346	06 14		asl $14				asl 	zTemp3 						; now x 8
.018348	26 15		rol $15				rol 	zTemp3+1
.01834a	05 14		ora $14				ora 	zTemp3 						; OR result in
.01834c	85 14		sta $14				sta 	zTemp3
.01834e	80 e4		bra $018334			bra 	_TIM_GHLoop 				; loop round again.
.018350					_TIMGH_Okay:
.018350	18		clc				clc
.018351					_TIMGH_Exit:
.018351	60		rts				rts
.018352					TIM_GetHexCharacter:
.018352	b1 10		lda ($10),y			lda 	(zTemp1),y
.018354	38		sec				sec
.018355	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.018357	90 0e		bcc $018367			bcc 	_TIM_GHCFail
.018359	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.01835b	90 0b		bcc $018368			bcc 	_TIM_GHCExit
.01835d	c9 11		cmp #$11			cmp 	#65-48						; < A
.01835f	90 06		bcc $018367			bcc		_TIM_GHCFail
.018361	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.018363	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.018365	90 01		bcc $018368			bcc		_TIM_GHCExit
.018367					_TIM_GHCFail:
.018367	38		sec				sec
.018368					_TIM_GHCExit:
.018368	60		rts				rts
.018369					TIM_BreakVector:
.018369	da		phx				phx									; save X/A on stack
.01836a	48		pha				pha
.01836b	ba		tsx				tsx 								; X points to S
.01836c	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.01836f	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.018371	d0 03		bne $018376			bne 	_TIMBreak					; if set, it's BRK
.018373	68		pla				pla 								; abandon routine.
.018374	fa		plx				plx
.018375	40		rti				rti
.018376					_TIMBreak:
.018376	68		pla				pla 								; save A X Y and maybe Z
.018377	8d c7 03	sta $03c7			sta 	TIM_A
.01837a	fa		plx				plx
.01837b	8e c8 03	stx $03c8			stx 	TIM_X
.01837e	8c c9 03	sty $03c9			sty 	TIM_Y
.018381	68		pla				pla 								; get Status Register
.018382	8d c6 03	sta $03c6			sta 	TIM_SR
.018385	68		pla				pla
.018386	8d c3 03	sta $03c3			sta 	TIM_PC+1 					; save calling address
.018389	68		pla				pla
.01838a	8d c2 03	sta $03c2			sta 	TIM_PC 						; high byte
.01838d	ad c3 03	lda $03c3			lda 	TIM_PC+1 					; dec PC to point right.
.018390	d0 03		bne $018395			bne 	_TIMDecrement 				; brk bumps it.
.018392	ce c2 03	dec $03c2			dec 	TIM_PC
.018395					_TIMDecrement:
.018395	ce c3 03	dec $03c3			dec 	TIM_PC+1
.018398	ba		tsx				tsx 								; and copy SP
.018399	8e cb 03	stx $03cb			stx 	TIM_SP
.01839c	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.01839e	9a		txs				txs
.01839f	4c 7e 82	jmp $01827e			jmp 	TIM_Start 					; and start up TIM monitor.
.0183a2					TIM_UpdateRegisters:
.0183a2	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; PC
.0183a5	b0 28		bcs $0183cf			bcs 	_TIMURFail
.0183a7	a5 14		lda $14				lda 	zTemp3
.0183a9	8d c3 03	sta $03c3			sta 	Tim_PC+1
.0183ac	a5 15		lda $15				lda 	zTemp3+1
.0183ae	8d c2 03	sta $03c2			sta 	Tim_PC
.0183b1	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; ignore IRQ
.0183b4	b0 19		bcs $0183cf			bcs 	_TIMURFail
.0183b6	a2 00		ldx #$00			ldx 	#0
.0183b8					_TIM_URLoop:
.0183b8	e0 04		cpx #$04			cpx 	#Tim_Z-Tim_SR
.0183ba	d0 01		bne $0183bd			bne 	_TIM_1
.0183bc	e8		inx				inx
.0183bd					_TIM_1:
.0183bd	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; registers
.0183c0	b0 0d		bcs $0183cf			bcs 	_TIMURFail
.0183c2	a5 14		lda $14				lda 	zTemp3
.0183c4	9d c6 03	sta $03c6,x			sta 	Tim_SR,x
.0183c7	e8		inx				inx
.0183c8	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.0183ca	d0 ec		bne $0183b8			bne 	_TIM_URLoop
.0183cc	4c f1 81	jmp $0181f1			jmp 	TIM_NewCommand
.0183cf					_TIMURFail:
.0183cf	4c ea 81	jmp $0181ea			jmp 	TIM_Error
.0183d2					TIM_LoadMemory:
.0183d2	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; target address => zTemp2
.0183d5	a5 14		lda $14				lda 	zTemp3
.0183d7	85 12		sta $12				sta 	zTemp2
.0183d9	a5 15		lda $15				lda 	zTemp3+1
.0183db	85 13		sta $13				sta 	zTemp2+1
.0183dd					_TIM_LMLoop:
.0183dd	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; next byte ?
.0183e0	b0 0e		bcs $0183f0			bcs 	_TIMLMDone 					; no more
.0183e2	a2 00		ldx #$00			ldx 	#0							; write out.
.0183e4	a5 14		lda $14				lda 	zTemp3
.0183e6	81 12		sta ($12,x)			sta 	(zTemp2,x)
.0183e8	e6 12		inc $12				inc 	zTemp2 						; bump address
.0183ea	d0 f1		bne $0183dd			bne 	_TIM_LMLoop
.0183ec	e6 13		inc $13				inc 	zTemp2+1
.0183ee	80 ed		bra $0183dd			bra 	_TIM_LMLoop
.0183f0					_TIMLMDone:
.0183f0	4c f1 81	jmp $0181f1			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/skip.asm

.0183f3					StructureSearchSingle:
.0183f3	a2 00		ldx #$00			ldx 	#0
.0183f5					StructureSearchDouble:
.0183f5	85 10		sta $10				sta 	zTemp1 						; save the target on zTemp1,zTemp1+1
.0183f7	86 11		stx $11				stx 	zTemp1+1
.0183f9	a9 00		lda #$00			lda 	#0 							; set the structure depth to zero (zTemp2)
.0183fb	85 12		sta $12				sta 	zTemp2
.0183fd	80 18		bra $018417			bra 	_SSWLoop 					; jump in, start scanning from here.
.0183ff					_SSWNextLine:
.0183ff	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018401	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.018403	18		clc				clc
.018404	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018406	85 16		sta $16				sta 	zCodePtr
.018408	90 02		bcc $01840c			bcc 	_SNLNoCarry
.01840a	e6 17		inc $17				inc 	zCodePtr+1
.01840c					_SNLNoCarry:
.01840c	a0 00		ldy #$00			ldy 	#0
.01840e	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018410	c9 00		cmp #$00			cmp 	#0					 		; if zero, fail.
.018412	f0 54		beq $018468			beq 	_SSWFail
.018414	c8		iny				iny
.018415	c8		iny				iny
.018416					_SSWNextSimple:
.018416	c8		iny				iny
.018417					_SSWLoop:
.018417	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018419	c9 00		cmp #$00			cmp 	#0 							; end of line ?
.01841b	f0 e2		beq $0183ff			beq 	_SSWNextLine 				; if so, then next line
.01841d	10 f7		bpl $018416			bpl 	_SSWNextSimple 				; needs to be a token, just skip char/number.
.01841f	a6 12		ldx $12				ldx 	zTemp2 						; check structure count
.018421	d0 08		bne $01842b			bne 	_SSWCheckUpDown 			; if it's non zero, then a match doesn't work.
.018423	c5 10		cmp $10				cmp 	zTemp1 						; found the right keyword, either choice.
.018425	f0 2d		beq $018454			beq 	_SSWFound 					; so exit.
.018427	c5 11		cmp $11				cmp 	zTemp1+1
.018429	f0 29		beq $018454			beq 	_SSWFound
.01842b					_SSWCheckUpDown:
.01842b	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus 			; if < keyword +
.01842d	90 10		bcc $01843f			bcc 	_SSWNext
.01842f	c9 93		cmp #$93			cmp 	#firstKeywordMinus 			; if < keyword - then as keyword +
.018431	90 08		bcc $01843b			bcc 	_SSWPlus
.018433	c9 98		cmp #$98			cmp 	#firstUnaryFunction			; if < first unary down as keyword -
.018435	b0 08		bcs $01843f			bcs 	_SSWNext
.018437	c6 12		dec $12				dec 	zTemp2 						; reduce structure count.
.018439	c6 12		dec $12				dec 	zTemp2
.01843b					_SSWPlus:
.01843b	e6 12		inc $12				inc 	zTemp2
.01843d	30 16		bmi $018455			bmi 	_SSWUnder					; error if driven -ve
.01843f					_SSWNext:
.01843f	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018441	c8		iny				iny 								; skip
.018442	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018444	90 0c		bcc $018452			bcc 	_SEDone 					; so just skip over it.
.018446	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018448	90 07		bcc $018451			bcc 	_SEDouble
.01844a	98		tya				tya 								; this is Y + 1
.01844b	18		clc				clc
.01844c	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.01844e	a8		tay				tay 								; back in Y.
.01844f	88		dey				dey 								; fix up, one for the +1, one for the iny
.018450	88		dey				dey
.018451					_SEDouble:
.018451	c8		iny				iny
.018452					_SEDone:
.018452	80 c3		bra $018417			bra 	_SSWLoop
.018454					_SSWFound:
.018454	60		rts				rts
.018455					_SSWUnder:
.018455	20 79 85	jsr $018579			jsr ERR_Handler
>018458	53 74 72 75 63 74 75 72			.text "Structure order",0
>018460	65 20 6f 72 64 65 72 00
.018468					_SSWFail:
.018468	20 79 85	jsr $018579			jsr ERR_Handler
>01846b	43 61 6e 27 74 20 66 69			.text "Can't find structure",0
>018473	6e 64 20 73 74 72 75 63 74 75 72 65 00
.018480					SkipEndOfCommand:
.018480	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018482	c9 00		cmp #$00			cmp 	#0 							; if zero, end of line, so exit
.018484	f0 19		beq $01849f			beq 	_SOCExit
.018486	c9 c0		cmp #$c0			cmp 	#token_Colon 				; if colon, end of command
.018488	f0 15		beq $01849f			beq 	_SOCExit
.01848a	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.01848c	c8		iny				iny 								; skip
.01848d	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.01848f	90 0c		bcc $01849d			bcc 	_SEDone 					; so just skip over it.
.018491	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018493	90 07		bcc $01849c			bcc 	_SEDouble
.018495	98		tya				tya 								; this is Y + 1
.018496	18		clc				clc
.018497	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018499	a8		tay				tay 								; back in Y.
.01849a	88		dey				dey 								; fix up, one for the +1, one for the iny
.01849b	88		dey				dey
.01849c					_SEDouble:
.01849c	c8		iny				iny
.01849d					_SEDone:
.01849d	80 e1		bra $018480			bra 	SkipEndOfCommand
.01849f					_SOCExit:
.01849f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stack.asm

.0184a0					StackReset:
.0184a0	48		pha				pha
.0184a1	5a		phy				phy
.0184a2	a9 00		lda #$00			lda 	#(BasicStack & $FF) 		; reset pointer
.0184a4	85 26		sta $26				sta 	zBasicSP
.0184a6	a9 04		lda #$04			lda 	#(BasicStack >> 8)
.0184a8	85 27		sta $27				sta 	zBasicSP+1
.0184aa	a0 00		ldy #$00			ldy 	#0 							; reset stack top to $00 which cannot
.0184ac	98		tya				tya 								; be a legal token.
.0184ad	91 26		sta ($26),y			sta 	(zBasicSP),y
.0184af	7a		ply				ply
.0184b0	68		pla				pla
.0184b1	60		rts				rts
.0184b2					StackPushFrame:
.0184b2	48		pha				pha
.0184b3	5a		phy				phy
.0184b4	1a		inc a				inc 	a 							; one extra byte in frame, for the marker.
.0184b5	48		pha				pha 								; save it.
.0184b6	29 0f		and #$0f			and 	#$0F 						; lower 4 bits
.0184b8	18		clc				clc 								; add to Basic Stack
.0184b9	65 26		adc $26				adc 	zBasicSP
.0184bb	85 26		sta $26				sta 	zBasicSP
.0184bd	90 02		bcc $0184c1			bcc 	_SPFNoBump
.0184bf	e6 27		inc $27				inc 	zBasicSP+1
.0184c1					_SPFNoBump:
.0184c1	a0 00		ldy #$00			ldy 	#0
.0184c3	68		pla				pla
.0184c4	91 26		sta ($26),y			sta 	(zBasicSP),y
.0184c6	7a		ply				ply
.0184c7	68		pla				pla
.0184c8	60		rts				rts
.0184c9					StackPopFrame:
.0184c9	48		pha				pha
.0184ca	5a		phy				phy
.0184cb	a0 00		ldy #$00			ldy 	#0 							; compare with top of stack using EOR
.0184cd	51 26		eor ($26),y			eor 	(zBasicSP),y
.0184cf	29 f0		and #$f0			and 	#$F0 						; top 4 bits zero, match
.0184d1	d0 12		bne $0184e5			bne 	SPFError 					; mixed structures
.0184d3	b1 26		lda ($26),y			lda 	(zBasicSP),y 				; get size from byte
.0184d5	29 0f		and #$0f			and 	#$0F
.0184d7	49 ff		eor #$ff			eor 	#$FF						; 2's complement
.0184d9	38		sec				sec
.0184da	65 26		adc $26				adc 	zBasicSP
.0184dc	85 26		sta $26				sta 	zBasicSP
.0184de	b0 02		bcs $0184e2			bcs 	_SPFNoBump
.0184e0	c6 27		dec $27				dec 	zBasicSP+1
.0184e2					_SPFNoBump:
.0184e2	7a		ply				ply
.0184e3	68		pla				pla
.0184e4	60		rts				rts
.0184e5					SPFError:
.0184e5	20 79 85	jsr $018579			jsr ERR_Handler
>0184e8	4d 69 78 65 64 20 53 74			.text "Mixed Structures",0
>0184f0	72 75 63 74 75 72 65 73 00
.0184f9					StackSavePosition:
.0184f9	98		tya				tya
.0184fa	5a		phy				phy
.0184fb	a0 05		ldy #$05			ldy 	#5
.0184fd	91 26		sta ($26),y			sta 	(zBasicSP),y
.0184ff	a0 01		ldy #$01			ldy 	#1
.018501	a5 16		lda $16				lda 	zCodePtr+0 					; 4 bytes, could reduce this for 65816/6502
.018503	91 26		sta ($26),y			sta 	(zBasicSP),y
.018505	c8		iny				iny
.018506	a5 17		lda $17				lda 	zCodePtr+1
.018508	91 26		sta ($26),y			sta 	(zBasicSP),y
.01850a	c8		iny				iny
.01850b	a5 18		lda $18				lda 	zCodePtr+2
.01850d	91 26		sta ($26),y			sta 	(zBasicSP),y
.01850f	c8		iny				iny
.018510	a5 19		lda $19				lda 	zCodePtr+3
.018512	91 26		sta ($26),y			sta 	(zBasicSP),y
.018514	7a		ply				ply
.018515	60		rts				rts
.018516					StackRestorePosition:
.018516	5a		phy				phy
.018517	a0 01		ldy #$01			ldy 	#1 							; copy 4 bytes that are the pointer
.018519	b1 26		lda ($26),y			lda 	(zBasicSP),y
.01851b	85 16		sta $16				sta 	zCodePtr+0
.01851d	c8		iny				iny
.01851e	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018520	85 17		sta $17				sta 	zCodePtr+1
.018522	c8		iny				iny
.018523	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018525	85 18		sta $18				sta 	zCodePtr+2
.018527	c8		iny				iny
.018528	b1 26		lda ($26),y			lda 	(zBasicSP),y
.01852a	85 19		sta $19				sta 	zCodePtr+3
.01852c	c8		iny				iny
.01852d	b1 26		lda ($26),y			lda 	(zBasicSP),y 				; offset
.01852f	7a		ply				ply 								; restore Y
.018530	a8		tay				tay
.018531	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/vectors.asm

.018532					VIOCharPrint:
.018532	4c 35 80	jmp $018035			jmp 	IFT_PrintCharacter
.018535					VIOCharGet:
.018535	20 d9 81	jsr $0181d9			jsr 	IF_GetKey
.018538	c9 00		cmp #$00			cmp 	#0
.01853a	f0 02		beq $01853e			beq 	_VCG0
.01853c	38		sec				sec
.01853d	60		rts				rts
.01853e	18		clc		_VCG0:	clc
.01853f	60		rts				rts
.018540					VIOCheckBreak:
.018540	4c d4 81	jmp $0181d4			jmp 	IF_CheckBreak
.018543					VIOCharGetPosition:
.018543	ad 00 05	lda $0500			lda 	IFT_XCursor
.018546	60		rts				rts
.018547					VIOReadLine:
.018547	4c ed 80	jmp $0180ed			jmp 	IFT_ReadLine

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/errors.asm

.01854a					SyntaxError:
.01854a	20 79 85	jsr $018579			jsr 	ERR_Handler
>01854d	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>018555	72 72 6f 72 00
.01855a					TypeError:
.01855a	20 79 85	jsr $018579			jsr 	ERR_Handler
>01855d	57 72 6f 6e 67 20 74 79				.text 	"Wrong type",0
>018565	70 65 00
.018568					BadParamError:
.018568	20 79 85	jsr $018579			jsr 	ERR_Handler
>01856b	42 61 64 20 50 61 72 61				.text 	"Bad Parameter",0
>018573	6d 65 74 65 72 00
.018579					ERR_Handler:
.018579	a0 00		ldy #$00			ldy 	#0
.01857b	c8		iny				iny
.01857c	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01857e	85 80		sta $80				sta 	XS_Mantissa
.018580	c8		iny				iny
.018581	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018583	85 81		sta $81				sta 	XS_Mantissa+1
.018585	fa		plx				plx 								; address in XY
.018586	7a		ply				ply
.018587	e8		inx				inx 								; bump, because of RTS/JSR address -1
.018588	d0 01		bne $01858b			bne 	_EHNoSkip
.01858a	c8		iny				iny
.01858b					_EHNoSkip:
.01858b	20 aa 85	jsr $0185aa			jsr 	PrintROMMessage 			; print message from ROM.
.01858e	a5 80		lda $80				lda 	XS_Mantissa					; line number = 0
.018590	05 81		ora $81				ora 	XS_Mantissa+1
.018592	f0 0c		beq $0185a0			beq 	_EHNoLine
.018594	a2 a5		ldx #$a5			ldx 	#_EHAt & $FF 				; print " at "
.018596	a0 85		ldy #$85			ldy 	#(_EHAt >> 8) & $FF
.018598	20 aa 85	jsr $0185aa			jsr 	PrintROMMessage
.01859b	a2 00		ldx #$00			ldx 	#0 							; Print line number
.01859d	20 bf 85	jsr $0185bf			jsr 	Print16BitInteger
.0185a0					_EHNoLine:
.0185a0	80 fe		bra $0185a0			bra 	_EHNoLine
.0185a2	4c 32 88	jmp $018832			jmp 	WarmStart 					; normally warm start.
>0185a5	20 61 74 20 00			_EHAt:	.text 	" at ",0
.0185aa					PrintROMMessage:
.0185aa	86 1a		stx $1a				stx 	zLTemp1 					; save addres
.0185ac	84 1b		sty $1b				sty 	zLTemp1+1
.0185ae	4b		phk				phk 								; get current code page
.0185af	68		pla				pla
.0185b0	85 1c		sta $1c				sta 	ZLTemp1+2 					; put into the 3rd byte so we can use
.0185b2	a0 00		ldy #$00			ldy 	#0
.0185b4					_PRMLoop:
.0185b4	b7 1a		lda [$1a],y			lda 	[zLTemp1],y 				; 65816
.0185b6	f0 06		beq $0185be			beq		_PRMExit 					; character $00 => exit
.0185b8	c8		iny				iny  								; bump Y and print it.
.0185b9	20 32 85	jsr $018532			jsr 	VIOCharPrint
.0185bc	80 f6		bra $0185b4			bra 	_PRMLoop
.0185be					_PRMExit:
.0185be	60		rts				rts
.0185bf					Print16BitInteger:
.0185bf	a9 00		lda #$00			lda 	#0 							; make 32 bit
.0185c1	85 82		sta $82				sta 	XS_Mantissa+2
.0185c3	85 83		sta $83				sta 	XS_Mantissa+3
.0185c5					Print32BitInteger:
.0185c5	a9 00		lda #$00			lda 	#0
.0185c7	8d 14 03	sta $0314			sta 	NumBufX 					; reset the conversion pointer
.0185ca	aa		tax				tax 								; convert bottom level.
.0185cb	20 3a 9e	jsr $019e3a			jsr 	INTToString 				; make string from integer in Num_Buffer
.0185ce	a2 00		ldx #$00			ldx 	#0 							; print buffer contents
.0185d0	bd 15 03	lda $0315,x	_P1Loop:lda 	Num_Buffer,x
.0185d3	f0 06		beq $0185db			beq 	_P1Exit
.0185d5	20 32 85	jsr $018532			jsr 	VIOCharPrint
.0185d8	e8		inx				inx
.0185d9	80 f5		bra $0185d0			bra 	_P1Loop
.0185db	8a		txa		_P1Exit:txa 								; return chars printed.
.0185dc	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm


;******  Processing file: modules/basic/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b6					lastUnaryFunction = $b6
.0185dd					VectorTable:
>0185dd	83 92					.word BinaryOp_And         & $FFFF ; $80 and
>0185df	9f 92					.word BinaryOp_Or          & $FFFF ; $81 or
>0185e1	bb 92					.word BinaryOp_Xor         & $FFFF ; $82 xor
>0185e3	bb 92					.word BinaryOp_Eor         & $FFFF ; $83 eor
>0185e5	f2 92					.word Binary_Equal         & $FFFF ; $84 =
>0185e7	0c 93					.word Binary_NotEqual      & $FFFF ; $85 <>
>0185e9	15 93					.word Binary_Less          & $FFFF ; $86 <
>0185eb	1e 93					.word Binary_LessEqual     & $FFFF ; $87 <=
>0185ed	30 93					.word Binary_Greater       & $FFFF ; $88 >
>0185ef	27 93					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>0185f1	b5 93					.word BinaryOp_Add         & $FFFF ; $8a +
>0185f3	d1 93					.word BinaryOp_Subtract    & $FFFF ; $8b -
>0185f5	e2 93					.word BinaryOp_Multiply    & $FFFF ; $8c *
>0185f7	f3 93					.word BinaryOp_Divide      & $FFFF ; $8d /
>0185f9	9b 86					.word NotImplemented       & $FFFF ; $8e ^
>0185fb	11 8c					.word Command_IF           & $FFFF ; $8f if
>0185fd	7f 90					.word Command_WHILE        & $FFFF ; $90 while
>0185ff	a7 90					.word Command_REPEAT       & $FFFF ; $91 repeat
>018601	94 89					.word Command_FOR          & $FFFF ; $92 for
>018603	9b 86					.word NotImplemented       & $FFFF ; $93 then
>018605	6e 8c					.word Command_ENDIF        & $FFFF ; $94 endif
>018607	9c 90					.word Command_WEND         & $FFFF ; $95 wend
>018609	b0 90					.word Command_UNTIL        & $FFFF ; $96 until
>01860b	11 8a					.word Command_NEXT         & $FFFF ; $97 next
>01860d	9b 86					.word NotImplemented       & $FFFF ; $98 not
>01860f	9b 86					.word NotImplemented       & $FFFF ; $99 fn(
>018611	f8 94					.word Unary_Abs            & $FFFF ; $9a abs(
>018613	45 96					.word Unary_Asc            & $FFFF ; $9b asc(
>018615	66 a5					.word Unary_Int            & $FFFF ; $9c int(
>018617	12 95					.word Unary_Peek           & $FFFF ; $9d peek(
>018619	e7 a4					.word Unary_Rnd            & $FFFF ; $9e rnd(
>01861b	85 95					.word Unary_Usr            & $FFFF ; $9f usr(
>01861d	84 96					.word Unary_Left           & $FFFF ; $a0 left$(
>01861f	99 96					.word Unary_Right          & $FFFF ; $a1 right$(
>018621	6b 96					.word Unary_Mid            & $FFFF ; $a2 mid$(
>018623	e4 97					.word Unary_Spc            & $FFFF ; $a3 spc(
>018625	13 96					.word Unary_Str            & $FFFF ; $a4 str$(
>018627	a7 95					.word Unary_Val            & $FFFF ; $a5 val(
>018629	5c 96					.word Unary_Len            & $FFFF ; $a6 len(
>01862b	11 97					.word Unary_Hex            & $FFFF ; $a7 hex$(
>01862d	9b 86					.word NotImplemented       & $FFFF ; $a8 sin(
>01862f	9b 86					.word NotImplemented       & $FFFF ; $a9 cos(
>018631	9b 86					.word NotImplemented       & $FFFF ; $aa tan(
>018633	9b 86					.word NotImplemented       & $FFFF ; $ab atn(
>018635	9b 86					.word NotImplemented       & $FFFF ; $ac exp(
>018637	9b 86					.word NotImplemented       & $FFFF ; $ad log(
>018639	9b 86					.word NotImplemented       & $FFFF ; $ae sqr(
>01863b	67 97					.word Unary_Dec            & $FFFF ; $af dec(
>01863d	16 95					.word Unary_Deek           & $FFFF ; $b0 deek(
>01863f	1a 95					.word Unary_Leek           & $FFFF ; $b1 leek(
>018641	52 95					.word Unary_Mod            & $FFFF ; $b2 mod(
>018643	b2 94					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>018645	c6 97					.word Unary_Chr            & $FFFF ; $b4 chr$(
>018647	46 95					.word Unary_Pos            & $FFFF ; $b5 pos(
>018649	07 98					.word Unary_Tab            & $FFFF ; $b6 tab(
>01864b	9b 86					.word NotImplemented       & $FFFF ; $b7 $
>01864d	9b 86					.word NotImplemented       & $FFFF ; $b8 $(
>01864f	9b 86					.word NotImplemented       & $FFFF ; $b9 #
>018651	9b 86					.word NotImplemented       & $FFFF ; $ba #(
>018653	9b 86					.word NotImplemented       & $FFFF ; $bb %
>018655	9b 86					.word NotImplemented       & $FFFF ; $bc %(
>018657	9b 86					.word NotImplemented       & $FFFF ; $bd (
>018659	9b 86					.word NotImplemented       & $FFFF ; $be )
>01865b	9b 86					.word NotImplemented       & $FFFF ; $bf ,
>01865d	93 89					.word Command_COLON        & $FFFF ; $c0 :
>01865f	9b 86					.word NotImplemented       & $FFFF ; $c1 ;
>018661	9b 86					.word NotImplemented       & $FFFF ; $c2 def
>018663	60 90					.word Command_CLR          & $FFFF ; $c3 clr
>018665	77 90					.word Command_STOP         & $FFFF ; $c4 stop
>018667	ea 8a					.word Command_DATA         & $FFFF ; $c5 data
>018669	c4 8a					.word Command_READ         & $FFFF ; $c6 read
>01866b	3f 88					.word Command_DIM          & $FFFF ; $c7 dim
>01866d	9b 86					.word NotImplemented       & $FFFF ; $c8 to
>01866f	9b 86					.word NotImplemented       & $FFFF ; $c9 step
>018671	a6 8f					.word Command_GOSUB        & $FFFF ; $ca gosub
>018673	b6 8f					.word Command_RETURN       & $FFFF ; $cb return
>018675	9e 8f					.word Command_GOTO         & $FFFF ; $cc goto
>018677	0d 8c					.word Command_END          & $FFFF ; $cd end
>018679	9b 86					.word NotImplemented       & $FFFF ; $ce input
>01867b	88 8b					.word Command_LET          & $FFFF ; $cf let
>01867d	74 8c					.word Command_LIST         & $FFFF ; $d0 list
>01867f	47 8f					.word Command_NEW          & $FFFF ; $d1 new
>018681	63 8f					.word Command_OLD          & $FFFF ; $d2 old
>018683	bf 8f					.word Command_ON           & $FFFF ; $d3 on
>018685	ed 8a					.word Command_RESTORE      & $FFFF ; $d4 restore
>018687	16 8f					.word Command_POKE         & $FFFF ; $d5 poke
>018689	68 8e					.word Command_PRINT        & $FFFF ; $d6 print
>01868b	05 89					.word Command_RUN          & $FFFF ; $d7 run
>01868d	c7 88					.word Command_WAIT         & $FFFF ; $d8 wait
>01868f	f3 8b					.word Command_SYS          & $FFFF ; $d9 sys
>018691	1a 8f					.word Command_DOKE         & $FFFF ; $da doke
>018693	1e 8f					.word Command_LOKE         & $FFFF ; $db loke
>018695	fe 8e					.word Command_ASSERT       & $FFFF ; $dc assert
>018697	a9 8b					.word Command_GET          & $FFFF ; $dd get
>018699	68 8c					.word Command_ELSE         & $FFFF ; $de else
.01869b					NotImplemented:
.01869b	20 79 85	jsr $018579			jsr ERR_Handler
>01869e	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>0186a6	65 6d 65 6e 74 65 64 00
.0186ae					BinaryPrecedence:
>0186ae	01					.byte 1    ; $80 and
>0186af	01					.byte 1    ; $81 or
>0186b0	01					.byte 1    ; $82 xor
>0186b1	01					.byte 1    ; $83 eor
>0186b2	02					.byte 2    ; $84 =
>0186b3	02					.byte 2    ; $85 <>
>0186b4	02					.byte 2    ; $86 <
>0186b5	02					.byte 2    ; $87 <=
>0186b6	02					.byte 2    ; $88 >
>0186b7	02					.byte 2    ; $89 >=
>0186b8	03					.byte 3    ; $8a +
>0186b9	03					.byte 3    ; $8b -
>0186ba	04					.byte 4    ; $8c *
>0186bb	04					.byte 4    ; $8d /
>0186bc	05					.byte 5    ; $8e ^
.0186bd					KeywordText:
>0186bd	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>0186c0	4f d2					.byte $4f,$d2                          ; $81 or
>0186c2	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>0186c5	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>0186c8	bd					.byte $bd                              ; $84 =
>0186c9	3c be					.byte $3c,$be                          ; $85 <>
>0186cb	bc					.byte $bc                              ; $86 <
>0186cc	3c bd					.byte $3c,$bd                          ; $87 <=
>0186ce	be					.byte $be                              ; $88 >
>0186cf	3e bd					.byte $3e,$bd                          ; $89 >=
>0186d1	ab					.byte $ab                              ; $8a +
>0186d2	ad					.byte $ad                              ; $8b -
>0186d3	aa					.byte $aa                              ; $8c *
>0186d4	af					.byte $af                              ; $8d /
>0186d5	de					.byte $de                              ; $8e ^
>0186d6	49 c6					.byte $49,$c6                          ; $8f if
>0186d8	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>0186dd	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>0186e3	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>0186e6	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>0186ea	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>0186ef	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>0186f3	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>0186f8	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>0186fc	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>0186ff	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>018702	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>018706	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>01870a	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>01870e	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>018713	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>018717	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>01871b	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>018721	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>018728	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>01872d	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>018731	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>018736	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>01873a	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>01873e	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>018743	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>018747	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>01874b	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>01874f	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>018753	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>018757	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>01875b	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>01875f	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>018763	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>018768	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>01876d	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>018771	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>018775	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>01877a	50 4f 53 a8				.byte $50,$4f,$53,$a8                  ; $b5 pos(
>01877e	54 41 42 a8				.byte $54,$41,$42,$a8                  ; $b6 tab(
>018782	a4					.byte $a4                              ; $b7 $
>018783	24 a8					.byte $24,$a8                          ; $b8 $(
>018785	a3					.byte $a3                              ; $b9 #
>018786	23 a8					.byte $23,$a8                          ; $ba #(
>018788	a5					.byte $a5                              ; $bb %
>018789	25 a8					.byte $25,$a8                          ; $bc %(
>01878b	a8					.byte $a8                              ; $bd (
>01878c	a9					.byte $a9                              ; $be )
>01878d	ac					.byte $ac                              ; $bf ,
>01878e	ba					.byte $ba                              ; $c0 :
>01878f	bb					.byte $bb                              ; $c1 ;
>018790	44 45 c6				.byte $44,$45,$c6                      ; $c2 def
>018793	43 4c d2				.byte $43,$4c,$d2                      ; $c3 clr
>018796	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $c4 stop
>01879a	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c5 data
>01879e	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c6 read
>0187a2	44 49 cd				.byte $44,$49,$cd                      ; $c7 dim
>0187a5	54 cf					.byte $54,$cf                          ; $c8 to
>0187a7	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c9 step
>0187ab	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $ca gosub
>0187b0	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $cb return
>0187b6	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $cc goto
>0187ba	45 4e c4				.byte $45,$4e,$c4                      ; $cd end
>0187bd	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $ce input
>0187c2	4c 45 d4				.byte $4c,$45,$d4                      ; $cf let
>0187c5	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $d0 list
>0187c9	4e 45 d7				.byte $4e,$45,$d7                      ; $d1 new
>0187cc	4f 4c c4				.byte $4f,$4c,$c4                      ; $d2 old
>0187cf	4f ce					.byte $4f,$ce                          ; $d3 on
>0187d1	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d4 restore
>0187d8	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d5 poke
>0187dc	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d6 print
>0187e1	52 55 ce				.byte $52,$55,$ce                      ; $d7 run
>0187e4	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d8 wait
>0187e8	53 59 d3				.byte $53,$59,$d3                      ; $d9 sys
>0187eb	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $da doke
>0187ef	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $db loke
>0187f3	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $dc assert
>0187f9	47 45 d4				.byte $47,$45,$d4                      ; $dd get
>0187fc	45 4c 53 c5				.byte $45,$4c,$53,$c5                  ; $de else
>018800	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_pos = $b5
=$b6					token_tab = $b6
=$b7					token_dollar = $b7
=$b8					token_dollarlparen = $b8
=$b9					token_hash = $b9
=$ba					token_hashlparen = $ba
=$bb					token_percent = $bb
=$bc					token_percentlparen = $bc
=$bd					token_lparen = $bd
=$be					token_rparen = $be
=$bf					token_comma = $bf
=$c0					token_colon = $c0
=$c1					token_semicolon = $c1
=$c2					token_def = $c2
=$c3					token_clr = $c3
=$c4					token_stop = $c4
=$c5					token_data = $c5
=$c6					token_read = $c6
=$c7					token_dim = $c7
=$c8					token_to = $c8
=$c9					token_step = $c9
=$ca					token_gosub = $ca
=$cb					token_return = $cb
=$cc					token_goto = $cc
=$cd					token_end = $cd
=$ce					token_input = $ce
=$cf					token_let = $cf
=$d0					token_list = $d0
=$d1					token_new = $d1
=$d2					token_old = $d2
=$d3					token_on = $d3
=$d4					token_restore = $d4
=$d5					token_poke = $d5
=$d6					token_print = $d6
=$d7					token_run = $d7
=$d8					token_wait = $d8
=$d9					token_sys = $d9
=$da					token_doke = $da
=$db					token_loke = $db
=$dc					token_assert = $dc
=$dd					token_get = $dd
=$de					token_else = $de

;******  Return to file: modules/basic/core.asm

.018801					BASIC_Start:
.018801	20 9b 81	jsr $01819b			jsr 	IF_Reset 					; set up and clear screen.
.018804	20 00 80	jsr $018000			jsr 	IFT_ClearScreen
.018807	a9 5c		lda #$5c			lda 	#$5C 						; JMP Long opcode
.018809	8d 10 03	sta $0310			sta 	LocalVector
.01880c	8d 0c 03	sta $030c			sta 	UserVector
.01880f	a9 95		lda #$95			lda 	#USRDefault & $FF 			; reset USR vector
.018811	8d 0d 03	sta $030d			sta 	UserVector+1
.018814	a9 95		lda #$95			lda 	#(USRDefault >> 8) & $FF
.018816	8d 0e 03	sta $030e			sta 	UserVector+2
.018819	a9 01		lda #$01			lda 	#(USRDefault >> 16) & $FF
.01881b	8d 0f 03	sta $030f			sta 	UserVector+3
.01881e	20 4e 98	jsr $01984e			jsr 	UpdateProgramEnd 			; update the program end.
.018821	20 60 90	jsr $019060			jsr 	ResetRunStatus 				; clear everything (CLR command)
.018824	c2 30		rep #$30			rep 	#$30
.018826	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.018829	1b		tcs				tcs
.01882a	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.01882d	e2 30		sep #$30			sep 	#$30
.01882f	4c 05 89	jmp $018905			jmp 	COMMAND_Run
.018832					WarmStart:
.018832	c2 30		rep #$30			rep 	#$30
.018834	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.018837	1b		tcs				tcs
.018838	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.01883b	e2 30		sep #$30			sep 	#$30
.01883d	80 f3		bra $018832			bra 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/dim.asm

.01883f					Command_DIM:
.01883f	98		tya				tya
.018840	48		pha				pha 								; push on stack.
.018841	20 c3 99	jsr $0199c3			jsr 	VariableExtract 			; get the identifier
.018844	ad 95 03	lda $0395			lda 	Var_Type 					; check it is an array
.018847	29 01		and #$01			and 	#1
.018849	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.01884b	d0 6c		bne $0188b9			bne 	_CDIError
.01884d	a9 00		lda #$00			lda 	#0 							; reset the DIM index. The dimensions are
.01884f	8d b9 03	sta $03b9			sta 	UsrArrayIdx 				; built up here and copied in case we autodim
.018852					_CDIGetDimension:
.018852	ad b9 03	lda $03b9			lda 	UsrArrayIdx 				; done too many ?
.018855	c9 06		cmp #$06			cmp 	#ArrayMaxDim*2
.018857	f0 60		beq $0188b9			beq 	_CDIError
.018859	20 64 92	jsr $019264			jsr 	EvaluateInteger 			; evaluate an index size
.01885c	a5 81		lda $81				lda 	XS_Mantissa+1 				; check in range 0-7FFF
.01885e	29 80		and #$80			and 	#$80
.018860	05 82		ora $82				ora 	XS_Mantissa+2
.018862	05 83		ora $83				ora 	XS_Mantissa+3
.018864	d0 53		bne $0188b9			bne 	_CDIError
.018866	ae b9 03	ldx $03b9			ldx 	UsrArrayIdx 				; copy into the array table.
.018869	18		clc				clc 								; add 1 - max index => size.
.01886a	a5 80		lda $80				lda 	XS_Mantissa+0
.01886c	69 01		adc #$01			adc 	#1
.01886e	9d b1 03	sta $03b1,x			sta 	UsrArrayDef+0,x
.018871	a5 81		lda $81				lda 	XS_Mantissa+1
.018873	69 00		adc #$00			adc 	#0
.018875	9d b2 03	sta $03b2,x			sta 	UsrArrayDef+1,x
.018878	30 3f		bmi $0188b9			bmi 	_CDIError 					; could be dim a(32767)
.01887a	e8		inx				inx 								; bump index.
.01887b	e8		inx				inx
.01887c	8e b9 03	stx $03b9			stx 	UsrArrayIdx
.01887f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018881	c8		iny				iny
.018882	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another dimension
.018884	f0 cc		beq $018852			beq 	_CDIGetDimension
.018886	88		dey				dey
.018887	20 aa 98	jsr $0198aa			jsr 	CheckNextRParen 			; closing ) present ?
.01888a	ae b9 03	ldx $03b9			ldx 	UsrArrayIdx 				; copy USR array to default
.01888d	a9 ff		lda #$ff			lda 	#$FF 						; put end marker in ArrayDef
.01888f	9d aa 03	sta $03aa,x			sta 	ArrayDef+1,x
.018892					_CDICopy:
.018892	bd b1 03	lda $03b1,x			lda 	UsrArrayDef,x
.018895	9d a9 03	sta $03a9,x			sta 	ArrayDef,x
.018898	ca		dex				dex
.018899	10 f7		bpl $018892			bpl 	_CDICopy
.01889b	68		pla				pla									; position of array identifier
.01889c	85 10		sta $10				sta 	zTemp1
.01889e	98		tya				tya
.01889f	48		pha				pha
.0188a0	a5 10		lda $10				lda 	zTemp1 						; point to identifier
.0188a2	a8		tay				tay
.0188a3	20 c3 99	jsr $0199c3			jsr 	VariableExtract 			; get the identifier
.0188a6	20 5c 9c	jsr $019c5c			jsr 	VariableLocate 				; check if it exists already.
.0188a9	b0 0e		bcs $0188b9			bcs 	_CDIError
.0188ab	20 4f 9a	jsr $019a4f			jsr 	VariableCreate 				; create it using the current ArrayDef
.0188ae	68		pla				pla 								; restore code position
.0188af	a8		tay				tay
.0188b0	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0188b2	c8		iny				iny
.0188b3	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another DIM
.0188b5	f0 88		beq $01883f			beq 	Command_DIM
.0188b7	88		dey				dey
.0188b8	60		rts				rts
.0188b9					_CDIError:
.0188b9	20 79 85	jsr $018579			jsr ERR_Handler
>0188bc	42 61 64 20 44 49 4d 00			.text "Bad DIM",0
.0188c4					_CDISyntax:
.0188c4	4c 4a 85	jmp $01854a			jmp 	SyntaxError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/wait.asm

.0188c7					Command_WAIT:
.0188c7	20 64 92	jsr $019264			jsr		EvaluateInteger 			; address
.0188ca	a2 06		ldx #$06			ldx 	#XS_Size 					; and mask.
.0188cc	20 b2 98	jsr $0198b2			jsr 	CheckNextComma
.0188cf	20 66 92	jsr $019266			jsr 	EvaluateIntegerX
.0188d2	a9 00		lda #$00			lda 	#0							; set default xor.
.0188d4	85 8c		sta $8c				sta 	XS_Mantissa+XS_Size*2
.0188d6	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0188d8	c9 bf		cmp #$bf			cmp 	#token_Comma 				; no use the default
.0188da	d0 06		bne $0188e2			bne 	_CWAXorDefault
.0188dc	c8		iny				iny
.0188dd	a2 0c		ldx #$0c			ldx 	#XS_Size*2
.0188df	20 66 92	jsr $019266			jsr 	EvaluateIntegerX
.0188e2					_CWAXorDefault:
.0188e2	a5 80		lda $80				lda 	XS_Mantissa 				; copy 24 bits of mantissa to ZLTemp1
.0188e4	85 1a		sta $1a				sta 	zLTemp1
.0188e6	a5 81		lda $81				lda 	XS_Mantissa+1
.0188e8	85 1b		sta $1b				sta 	zLTemp1+1
.0188ea	a5 82		lda $82				lda 	XS_Mantissa+2
.0188ec	85 1c		sta $1c				sta 	zLTemp1+2
.0188ee					_CWAWaitLoop:
.0188ee	20 40 85	jsr $018540			jsr 	VIOCheckBreak 				; exit on break.
.0188f1	c9 00		cmp #$00			cmp 	#0
.0188f3	d0 0f		bne $018904			bne 	_CWAWaitExit
.0188f5	a9 01		lda #$01			lda 	#1							; read 1 byte to mantissa/0
.0188f7	a2 00		ldx #$00			ldx 	#0
.0188f9	5a		phy				phy 								; this is the same routine as PEEK.
.0188fa	20 2c 98	jsr $01982c			jsr 	MemRead
.0188fd	7a		ply				ply
.0188fe	25 86		and $86				and 	XS_Mantissa+XS_Size 		; process it
.018900	45 8c		eor $8c				eor 	XS_Mantissa+XS_Size*2
.018902	f0 ea		beq $0188ee			beq 	_CWAWaitLoop
.018904					_CWAWaitExit:
.018904	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/run.asm

.018905					Command_RUN:
.018905	20 60 90	jsr $019060			jsr 	ResetRunStatus 				; clear, reset stacks etc.
.018908	a9 00		lda #$00			lda 	#BasicProgram & $FF
.01890a	85 16		sta $16				sta 	zCodePtr+0
.01890c	a9 10		lda #$10			lda 	#BasicProgram >> 8
.01890e	85 17		sta $17				sta 	zCodePtr+1
.018910	a9 00		lda #$00			lda 	#0
.018912	85 18		sta $18				sta 	zCodePtr+2
.018914	85 19		sta $19				sta 	zCodePtr+3
.018916	a0 03		ldy #$03			ldy 	#3
.018918					RUN_NewLine:
.018918	a0 00		ldy #$00			ldy 	#0
.01891a	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01891c	c8		iny				iny
.01891d	c8		iny				iny
.01891e	c8		iny				iny
.01891f	c9 00		cmp #$00			cmp 	#0 							; if the offset is zero then END.
.018921	d0 16		bne $018939			bne 	RUN_NextCommand
.018923	4c 0d 8c	jmp $018c0d			jmp 	Command_END 				; go do the command code.
.018926					RUN_Skip:
.018926	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018928	c8		iny				iny 								; skip
.018929	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.01892b	90 0c		bcc $018939			bcc 	_SEDone 					; so just skip over it.
.01892d	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.01892f	90 07		bcc $018938			bcc 	_SEDouble
.018931	98		tya				tya 								; this is Y + 1
.018932	18		clc				clc
.018933	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018935	a8		tay				tay 								; back in Y.
.018936	88		dey				dey 								; fix up, one for the +1, one for the iny
.018937	88		dey				dey
.018938					_SEDouble:
.018938	c8		iny				iny
.018939					_SEDone:
.018939					RUN_NextCommand:
.018939	ad a8 03	lda $03a8			lda 	BreakCount 					; break counter
.01893c	69 10		adc #$10			adc 	#16 						; one time in 16
.01893e	8d a8 03	sta $03a8			sta 	BreakCount
.018941	90 0a		bcc $01894d			bcc 	RUN_NoCheckBreak
.018943	20 40 85	jsr $018540			jsr 	VIOCheckBreak 				; check for break
.018946	c9 00		cmp #$00			cmp 	#0
.018948	f0 03		beq $01894d			beq 	RUN_NoCheckBreak
.01894a	4c 77 90	jmp $019077			jmp 	Command_STOP 				; stop on BREAK.
.01894d					RUN_NoCheckBreak:
.01894d	a9 00		lda #$00			lda 	#0 							; this resets temporary string allocation.
.01894f	85 21		sta $21				sta 	zTempStr+1 					; (initialised when first called)
.018951	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018953	c9 c0		cmp #$c0			cmp 	#token_Colon 				; skip over colons
.018955	f0 cf		beq $018926			beq 	RUN_Skip
.018957	c9 00		cmp #$00			cmp 	#0 							; if non-zero execute whatever
.018959	d0 0f		bne $01896a			bne 	RUN_Execute
.01895b					RUN_NextLine:
.01895b	a0 00		ldy #$00			ldy 	#0 							; point to offset
.01895d	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.01895f	18		clc				clc
.018960	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018962	85 16		sta $16				sta 	zCodePtr
.018964	90 02		bcc $018968			bcc 	_SNLNoCarry
.018966	e6 17		inc $17				inc 	zCodePtr+1
.018968					_SNLNoCarry:
.018968	80 ae		bra $018918			bra 	RUN_NewLine 				; go do the new line code
.01896a					RUN_Execute:
.01896a	c9 f8		cmp #$f8			cmp 	#$F8 						; handle shifts, REM etc.
.01896c	b0 1e		bcs $01898c			bcs 	RUN_Extension
.01896e	c8		iny				iny
.01896f	0a		asl a				asl 	a 							; double the character read.
.018970	90 14		bcc $018986			bcc 	RUN_Default 				; if carry clear was $00-$7F, so try LET.
.018972	aa		tax				tax 								; ready to look up.
.018973	bf dd 85 01	lda $0185dd,x			lda 	VectorTable,x 				; copy address into LocalVector
.018977	8d 11 03	sta $0311			sta 	LocalVector+1
.01897a	bf de 85 01	lda $0185de,x			lda 	VectorTable+1,x
.01897e	8d 12 03	sta $0312			sta 	LocalVector+2
.018981	20 b1 91	jsr $0191b1			jsr 	EVCallLocalVector 			; execute the appropriate code.
.018984	80 b3		bra $018939			bra 	RUN_NextCommand 			; do the next command.
.018986					RUN_Default:
.018986	88		dey				dey
.018987	20 88 8b	jsr $018b88			jsr 	Command_LET 				; and try LET.
.01898a	80 ad		bra $018939			bra 	RUN_NextCommand
.01898c					RUN_Extension:
.01898c	c9 ff		cmp #$ff			cmp 	#$FF 						; if $FF (REM)
.01898e	f0 96		beq $018926			beq 	RUN_Skip 					; skip over it.
.018990	4c 4a 85	jmp $01854a			jmp 	SyntaxError
.018993					Command_COLON:
.018993	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/for.asm

.018994					Command_FOR:
.018994	20 88 8b	jsr $018b88			jsr 	Command_LET 				; do the A = 99 bit
.018997	a5 24		lda $24				lda 	zVarType 					; obviously has to be integer/real.
.018999	c9 b7		cmp #$b7			cmp 	#token_Dollar
.01899b	f0 71		beq $018a0e			beq 	_CFOError
.01899d	48		pha				pha 								; save the variable type.
.01899e	5a		phy				phy 								; save type/variable address.
.01899f	a0 01		ldy #$01			ldy 	#1							; type at + 1
.0189a1	91 26		sta ($26),y			sta 	(zBasicSP),y
.0189a3	c8		iny				iny
.0189a4	a5 22		lda $22				lda 	zVarDataPtr 				; data low at +2
.0189a6	91 26		sta ($26),y			sta 	(zBasicSP),y
.0189a8	c8		iny				iny
.0189a9	a5 23		lda $23				lda 	zVarDataPtr+1 				; data high at +3
.0189ab	91 26		sta ($26),y			sta 	(zBasicSP),y
.0189ad	7a		ply				ply
.0189ae	a9 53		lda #$53			lda 	#(SMark_For << 4) + 3
.0189b0	20 b2 84	jsr $0184b2			jsr 	StackPushFrame 				; push on the stack with FOR marker.
.0189b3	a9 c8		lda #$c8			lda 	#token_TO
.0189b5	20 93 98	jsr $019893			jsr 	CheckNextToken
.0189b8	a2 00		ldx #$00			ldx 	#0 							; put in Mantissa, bottom
.0189ba	20 ce 90	jsr $0190ce			jsr 	EvaluateExpression
.0189bd	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0189bf	a2 06		ldx #$06			ldx 	#XS_Size 					; X to second level
.0189c1	c9 c9		cmp #$c9			cmp 	#token_STEP
.0189c3	d0 06		bne $0189cb			bne 	_CFOStep1
.0189c5	c8		iny				iny
.0189c6	20 d0 90	jsr $0190d0			jsr 	EvaluateExpressionX 		; get STEP value.
.0189c9	80 0e		bra $0189d9			bra 	_CFOHaveStep
.0189cb					_CFOStep1:
.0189cb	a9 00		lda #$00			lda 	#0							; set step to integer 1.
.0189cd	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0189cf	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0189d1	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0189d3	a9 01		lda #$01			lda 	#1
.0189d5	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0189d7	95 85		sta $85,x			sta 	XS_Type,x
.0189d9					_CFOHaveStep:
.0189d9	68		pla				pla 								; restore variable type
.0189da	a2 00		ldx #$00			ldx 	#0
.0189dc	c9 bb		cmp #$bb			cmp 	#token_Percent 				; do conversion to type
.0189de	f0 0a		beq $0189ea			beq 	_CFOInteger
.0189e0	20 67 a2	jsr $01a267			jsr 	FPUToFloat
.0189e3	a2 06		ldx #$06			ldx 	#6
.0189e5	20 67 a2	jsr $01a267			jsr 	FPUToFloat
.0189e8	80 08		bra $0189f2			bra 	_CFOEndConv
.0189ea					_CFOInteger:
.0189ea	20 b3 a2	jsr $01a2b3			jsr 	FPUToInteger
.0189ed	a2 06		ldx #$06			ldx 	#6
.0189ef	20 b3 a2	jsr $01a2b3			jsr 	FPUToInteger
.0189f2					_CFOEndConv:
.0189f2	20 f9 84	jsr $0184f9			jsr 	StackSavePosition 			; save the loop position at 1-5
.0189f5	a9 55		lda #$55			lda 	#(SMark_For << 4)+SourcePosSize
.0189f7	20 b2 84	jsr $0184b2			jsr 	StackPushFrame 				; push the loop address frame.
.0189fa	5a		phy				phy
.0189fb	a0 00		ldy #$00			ldy 	#0
.0189fd					_CFOCopy:
.0189fd	b9 80 00	lda $0080,y			lda 	XS_Mantissa+0,y
.018a00	c8		iny				iny
.018a01	91 26		sta ($26),y			sta 	(zBasicSP),y
.018a03	c0 0c		cpy #$0c			cpy 	#XS_Size*2
.018a05	d0 f6		bne $0189fd			bne 	_CFOCopy
.018a07	7a		ply				ply
.018a08	a9 5c		lda #$5c			lda 	#(SMark_For << 4)+(XS_Size*2)
.018a0a	20 b2 84	jsr $0184b2			jsr 	StackPushFrame
.018a0d	60		rts				rts
.018a0e					_CFOError:
.018a0e	4c 5a 85	jmp $01855a			jmp 	TypeError 					; wrong type.
.018a11					Command_NEXT:
.018a11	a9 00		lda #$00			lda 	#0 							; set variable data pointer+1 to zero
.018a13	85 23		sta $23				sta 	zVarDataPtr+1 				; this means we don't check
.018a15	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018a17	c9 00		cmp #$00			cmp 	#0 							; EOL
.018a19	f0 07		beq $018a22			beq 	_CNextNoVariable
.018a1b	c9 40		cmp #$40			cmp 	#$40
.018a1d	b0 03		bcs $018a22			bcs 	_CNextNoVariable
.018a1f	20 58 99	jsr $019958			jsr 	VariableFind
.018a22					_CNextNoVariable:
.018a22	a5 26		lda $26				lda 	zBasicSP 					; save on stack
.018a24	48		pha				pha
.018a25	a5 27		lda $27				lda 	zBasicSP+1
.018a27	48		pha				pha
.018a28	a9 50		lda #$50			lda 	#(SMark_For << 4) 			; pop loop address frame
.018a2a	20 c9 84	jsr $0184c9			jsr 	StackPopFrame
.018a2d	a9 50		lda #$50			lda 	#(SMark_For << 4) 			; pop STEP/TARGET frame.
.018a2f	20 c9 84	jsr $0184c9			jsr 	StackPopFrame
.018a32	a9 50		lda #$50			lda 	#(Smark_For << 4) 			; pop variable address frame.
.018a34	20 c9 84	jsr $0184c9			jsr 	StackPopFrame
.018a37	a5 23		lda $23				lda 	zVarDataPtr+1 				; if zero, then no variable provided
.018a39	f0 11		beq $018a4c			beq 	_CNextGetTarget 			; e.g. just NEXT not NEXT x
.018a3b	5a		phy				phy 								; check addresses match.
.018a3c	a0 02		ldy #$02			ldy 	#2
.018a3e	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a40	c5 22		cmp $22				cmp 	zVarDataPtr
.018a42	d0 69		bne $018aad			bne 	_CNextWrong
.018a44	c8		iny				iny
.018a45	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a47	c5 23		cmp $23				cmp 	zVarDataPtr+1
.018a49	d0 62		bne $018aad			bne 	_CNextWrong
.018a4b	7a		ply				ply
.018a4c					_CNextGetTarget:
.018a4c	5a		phy				phy
.018a4d	a0 01		ldy #$01			ldy 	#1 							; restore variable type and data.
.018a4f	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a51	85 24		sta $24				sta 	zVarType
.018a53	c8		iny				iny
.018a54	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a56	85 22		sta $22				sta 	zVarDataPtr
.018a58	c8		iny				iny
.018a59	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a5b	85 23		sta $23				sta 	zVarDataPtr+1
.018a5d	a2 0c		ldx #$0c			ldx 	#12
.018a5f	20 a0 9c	jsr $019ca0			jsr 	VariableGet 				; get that variable value into expr[2]
.018a62	a2 00		ldx #$00			ldx 	#0 							; copy stacked Target/Step into expr[0] and [1]
.018a64	a0 0b		ldy #$0b			ldy 	#11
.018a66					_CNXCopy:
.018a66	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a68	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018a6a	e8		inx				inx
.018a6b	c8		iny				iny
.018a6c	e0 0c		cpx #$0c			cpx 	#XS_Size*2
.018a6e	d0 f6		bne $018a66			bne 	_CNXCopy
.018a70	7a		ply				ply
.018a71	a2 06		ldx #$06			ldx 	#6 							; point at expr[1] s
.018a73	20 d6 94	jsr $0194d6			jsr 	GetSignCurrent
.018a76	8d a7 03	sta $03a7			sta 	SignNext 					; save in temporary.
.018a79	a2 06		ldx #$06			ldx 	#6 							; add them, however
.018a7b	20 b5 93	jsr $0193b5			jsr 	BinaryOp_Add
.018a7e	20 f1 9c	jsr $019cf1			jsr 	VariableSet					; and write variable back.
.018a81	a2 00		ldx #$00			ldx 	#0
.018a83	20 39 93	jsr $019339			jsr 	CompareValues
.018a86	09 00		ora #$00			ora 	#0
.018a88	f0 05		beq $018a8f			beq 	_CNXAgain 					; if true, then do it again.
.018a8a	cd a7 03	cmp $03a7			cmp 	SignNext 					; if sign different, then loop has finished.
.018a8d	d0 0f		bne $018a9e			bne 	_CNXLoopDone
.018a8f					_CNXAgain:
.018a8f	a9 53		lda #$53			lda 	#(SMark_For << 4) + 3		; re-stack variable address
.018a91	20 b2 84	jsr $0184b2			jsr 	StackPushFrame
.018a94	20 16 85	jsr $018516			jsr 	StackRestorePosition 		; get restore position back, e.g. loop round.
.018a97	68		pla				pla
.018a98	85 27		sta $27				sta 	zBasicSP+1
.018a9a	68		pla				pla
.018a9b	85 26		sta $26				sta 	zBasicSP
.018a9d					_CNXExit:
.018a9d	60		rts				rts
.018a9e					_CNXLoopDone:
.018a9e	68		pla				pla
.018a9f	68		pla				pla
.018aa0	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018aa2	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma ?
.018aa4	d0 f7		bne $018a9d			bne 	_CNXExit
.018aa6	c8		iny				iny
.018aa7	20 58 99	jsr $019958			jsr 	VariableFind 				; identify the variable
.018aaa	4c 22 8a	jmp $018a22			jmp 	_CNextNoVariable 			; go back with variable pre-found
.018aad					_CNextWrong:
.018aad	20 79 85	jsr $018579			jsr ERR_Handler
>018ab0	57 72 6f 6e 67 20 4e 65			.text "Wrong Next Variable",0
>018ab8	78 74 20 56 61 72 69 61 62 6c 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/read.asm

.018ac4					Command_READ:
.018ac4	20 58 99	jsr $019958			jsr 	VariableFind 				; get variable/value into zVarDataPtr,zVarType
.018ac7	a5 22		lda $22				lda 	zVarDataPtr 				; save variable info on stack
.018ac9	48		pha				pha
.018aca	a5 23		lda $23				lda 	zVarDataPtr+1
.018acc	48		pha				pha
.018acd	a5 24		lda $24				lda 	zVarType
.018acf	48		pha				pha
.018ad0	20 16 8b	jsr $018b16			jsr 	READGetDataItem 			; get the next data item
.018ad3	68		pla				pla 								; restore target variable information.
.018ad4	85 24		sta $24				sta 	zVarType
.018ad6	68		pla				pla
.018ad7	85 23		sta $23				sta 	zVarDataPtr+1
.018ad9	68		pla				pla
.018ada	85 22		sta $22				sta 	zVarDataPtr
.018adc	a2 00		ldx #$00			ldx 	#0
.018ade	20 f1 9c	jsr $019cf1			jsr 	VariableSet 				; set the value out.
.018ae1	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018ae3	c8		iny				iny
.018ae4	c9 bf		cmp #$bf			cmp 	#token_Comma
.018ae6	f0 dc		beq $018ac4			beq 	Command_READ 				; found, do another READ
.018ae8	88		dey				dey
.018ae9	60		rts				rts
.018aea					Command_DATA:
.018aea	4c 80 84	jmp $018480			jmp 	SkipEndOfCommand
.018aed					Command_RESTORE:
.018aed	48		pha				pha
.018aee	a9 00		lda #$00			lda 	#0 							; this being zero means 'initialise next read'
.018af0	8d bd 03	sta $03bd			sta 	DataLPtr+0
.018af3	8d be 03	sta $03be			sta 	DataLPtr+1
.018af6	68		pla				pla
.018af7	60		rts				rts
.018af8					READSwapPointers:
.018af8	98		tya				tya
.018af9	48		pha				pha 								; save it
.018afa	ad c1 03	lda $03c1			lda 	DataIndex 					; get data offset, and copy to offset
.018afd	a8		tay				tay
.018afe	68		pla				pla 								; get code offset and save in DataIndex
.018aff	8d c1 03	sta $03c1			sta 	DataIndex
.018b02	da		phx				phx
.018b03	a2 03		ldx #$03			ldx 	#3 							; swap the Data Pointers (4 bytes) round.
.018b05					_RSWLoop:
.018b05	bd bd 03	lda $03bd,x			lda 	DataLPtr+0,x
.018b08	48		pha				pha
.018b09	b5 16		lda $16,x			lda 	zCodePtr+0,x
.018b0b	9d bd 03	sta $03bd,x			sta 	DataLPtr+0,x
.018b0e	68		pla				pla
.018b0f	95 16		sta $16,x			sta 	zCodePtr+0,x
.018b11	ca		dex				dex
.018b12	10 f1		bpl $018b05			bpl 	_RSWLoop
.018b14	fa		plx				plx
.018b15	60		rts				rts
.018b16					READGetDataItem:
.018b16	20 f8 8a	jsr $018af8			jsr 	ReadSwapPointers 			; swap code and data pointer.
.018b19	a5 16		lda $16				lda		zCodePtr+0 					; initialise ?
.018b1b	05 17		ora $17				ora 	zCodePtr+1
.018b1d	d0 12		bne $018b31			bne 	_RGDIIsInitialised
.018b1f	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018b21	85 16		sta $16				sta 	zCodePtr+0
.018b23	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018b25	85 17		sta $17				sta 	zCodePtr+1
.018b27	a9 00		lda #$00			lda 	#0
.018b29	85 18		sta $18				sta 	zCodePtr+2
.018b2b	85 19		sta $19				sta 	zCodePtr+3
.018b2d	a0 03		ldy #$03			ldy 	#3
.018b2f	80 06		bra $018b37			bra 	_RGDIFindData 				; locate next data from start and read that.
.018b31					_RGDIIsInitialised:
.018b31	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018b33	c9 bf		cmp #$bf			cmp 	#token_Comma
.018b35	f0 49		beq $018b80			beq 	_RGDISkipEvaluateExit
.018b37					_RGDIFindData:
.018b37	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018b39	c9 00		cmp #$00			cmp 	#0 							; end of line
.018b3b	f0 19		beq $018b56			beq 	_RGDIFindNextLine
.018b3d	c9 c5		cmp #$c5			cmp 	#token_DATA 				; found data token
.018b3f	f0 3f		beq $018b80			beq 	_RGDISkipEvaluateExit 		; then skip it and evaluate
.018b41	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018b43	c8		iny				iny 								; skip
.018b44	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018b46	90 0c		bcc $018b54			bcc 	_SEDone 					; so just skip over it.
.018b48	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018b4a	90 07		bcc $018b53			bcc 	_SEDouble
.018b4c	98		tya				tya 								; this is Y + 1
.018b4d	18		clc				clc
.018b4e	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018b50	a8		tay				tay 								; back in Y.
.018b51	88		dey				dey 								; fix up, one for the +1, one for the iny
.018b52	88		dey				dey
.018b53					_SEDouble:
.018b53	c8		iny				iny
.018b54					_SEDone:
.018b54	80 e1		bra $018b37			bra 	_RGDIFindData
.018b56					_RGDIFindNextLine:
.018b56	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018b58	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.018b5a	18		clc				clc
.018b5b	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018b5d	85 16		sta $16				sta 	zCodePtr
.018b5f	90 02		bcc $018b63			bcc 	_SNLNoCarry
.018b61	e6 17		inc $17				inc 	zCodePtr+1
.018b63					_SNLNoCarry:
.018b63	a0 00		ldy #$00			ldy 	#0
.018b65	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018b67	48		pha				pha
.018b68	c8		iny				iny
.018b69	c8		iny				iny
.018b6a	c8		iny				iny
.018b6b	68		pla				pla
.018b6c	d0 c9		bne $018b37			bne 	_RGDIFindData 				; back to scanning.
.018b6e	20 f8 8a	jsr $018af8			jsr 	ReadSwapPointers 			; so we get error in line number of READ
.018b71	20 79 85	jsr $018579			jsr ERR_Handler
>018b74	4f 75 74 20 6f 66 20 44			.text "Out of Data",0
>018b7c	61 74 61 00
.018b80					_RGDISkipEvaluateExit:
.018b80	c8		iny				iny
.018b81	20 ce 90	jsr $0190ce			jsr 	EvaluateExpression 			; evaluate the expression
.018b84	20 f8 8a	jsr $018af8			jsr 	ReadSwapPointers 			; swap the pointers around.
.018b87	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/let.asm

.018b88					Command_LET:
.018b88	20 58 99	jsr $019958			jsr 	VariableFind 				; get reference to one variable.
.018b8b	a9 84		lda #$84			lda 	#token_Equal  				; get equals
.018b8d	20 93 98	jsr $019893			jsr 	CheckNextToken
.018b90	a5 22		lda $22				lda 	zVarDataPtr 				; save variable info on stack
.018b92	48		pha				pha
.018b93	a5 23		lda $23				lda 	zVarDataPtr+1
.018b95	48		pha				pha
.018b96	a5 24		lda $24				lda 	zVarType
.018b98	48		pha				pha
.018b99	20 ce 90	jsr $0190ce			jsr 	EvaluateExpression 			; evaluate the RHS, set X to zero.
.018b9c	68		pla				pla 								; restore target variable information.
.018b9d	85 24		sta $24				sta 	zVarType
.018b9f	68		pla				pla
.018ba0	85 23		sta $23				sta 	zVarDataPtr+1
.018ba2	68		pla				pla
.018ba3	85 22		sta $22				sta 	zVarDataPtr
.018ba5	20 f1 9c	jsr $019cf1			jsr 	VariableSet 				; set the value out.
.018ba8	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/get.asm

.018ba9					Command_GET:
.018ba9					_CGLoop:
.018ba9	20 58 99	jsr $019958			jsr 	VariableFind 				; get a variable.
.018bac	20 35 85	jsr $018535			jsr 	VIOCharGet 					; get character
.018baf	b0 02		bcs $018bb3			bcs 	_CGNoKey
.018bb1	a9 00		lda #$00			lda 	#0 							; if no character return zero
.018bb3					_CGNoKey:
.018bb3	48		pha				pha
.018bb4	a5 24		lda $24				lda 	zVarType 					; look at the data type.
.018bb6	c9 b7		cmp #$b7			cmp 	#token_Dollar
.018bb8	f0 1e		beq $018bd8			beq 	_CGString
.018bba	68		pla				pla 								; put character in slot.
.018bbb	85 80		sta $80				sta 	XS_Mantissa
.018bbd	a9 00		lda #$00			lda 	#0
.018bbf	85 81		sta $81				sta 	XS_Mantissa+1
.018bc1	85 82		sta $82				sta 	XS_Mantissa+2
.018bc3	85 83		sta $83				sta 	XS_Mantissa+3
.018bc5	a9 01		lda #$01			lda 	#1 							; type integer
.018bc7	85 85		sta $85				sta 	XS_Type
.018bc9					_CGWriteSetNext:
.018bc9	a2 00		ldx #$00			ldx 	#0 							; write number/WriteTempString out
.018bcb	20 f1 9c	jsr $019cf1			jsr 	VariableSet
.018bce	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018bd0	c9 bf		cmp #$bf			cmp 	#token_Comma 				; if not comma exit
.018bd2	d0 03		bne $018bd7			bne 	_CGExit
.018bd4	c8		iny				iny
.018bd5	80 d2		bra $018ba9			bra 	_CGLoop 					; and get another.
.018bd7					_CGExit:
.018bd7	60		rts				rts
.018bd8					_CGString:
.018bd8	a9 02		lda #$02			lda 	#2 							; allocate temp string, space for 2.
.018bda	20 f7 98	jsr $0198f7			jsr 	AllocateTempString 			; initially empty.
.018bdd	a5 20		lda $20				lda 	zTempStr 					; set up to be returned.
.018bdf	85 80		sta $80				sta 	XS_Mantissa
.018be1	a5 21		lda $21				lda 	zTempStr+1
.018be3	85 81		sta $81				sta 	XS_Mantissa+1
.018be5	a9 02		lda #$02			lda 	#2
.018be7	85 85		sta $85				sta 	XS_Type
.018be9	68		pla				pla 								; get A
.018bea	c9 00		cmp #$00			cmp 	#0
.018bec	f0 db		beq $018bc9			beq 	_CGWriteSetNext
.018bee	20 22 99	jsr $019922			jsr 	WriteTempString 			; write it into string
.018bf1	80 d6		bra $018bc9			bra 	_CGWriteSetNext

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/sys.asm

.018bf3					Command_SYS:
.018bf3	20 64 92	jsr $019264			jsr 	EvaluateInteger 			; address to call.
.018bf6	a5 80		lda $80				lda 	XS_Mantissa+0				; copy to localvector
.018bf8	8d 10 03	sta $0310			sta 	LocalVector+0 				; only three, can only do 24 bit calls
.018bfb	a5 81		lda $81				lda 	XS_Mantissa+1 				; and that only on 65816
.018bfd	8d 11 03	sta $0311			sta 	LocalVector+1
.018c00	a5 82		lda $82				lda 	XS_Mantissa+2
.018c02	8d 12 03	sta $0312			sta 	LocalVector+2
.018c05	22 0a 8c 01	jsl $018c0a			jsl 	_CSYLocalCall 				; jump depending on 24/16 bit code address
.018c09	60		rts				rts
.018c0a					_CSYLocalCall:
.018c0a	dc 10 03	jmp [$0310]			jmp 	[LocalVector]		 		; address

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/input.asm


;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/end.asm

.018c0d					Command_END:
>018c0d	02						.byte 	2
.018c0e	4c 32 88	jmp $018832			jmp 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/if.asm

.018c11					Command_IF:
.018c11	20 64 92	jsr $019264			jsr 	EvaluateInteger 			; check success.
.018c14	a5 80		lda $80				lda 	XS_Mantissa+0				; check the result if zero
.018c16	05 81		ora $81				ora 	XS_Mantissa+1
.018c18	05 82		ora $82				ora 	XS_Mantissa+2
.018c1a	05 83		ora $83				ora 	XS_Mantissa+3
.018c1c	aa		tax				tax 								; put into X.
.018c1d	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c1f	c9 93		cmp #$93			cmp 	#token_Then 				; then found.
.018c21	d0 2c		bne $018c4f			bne 	_FIFExtended
.018c23	c8		iny				iny
.018c24	e0 00		cpx #$00			cpx 	#0 							; was it successful.
.018c26	f0 0b		beq $018c33			beq 	_FIFEndOfLine 				; if not, go to the end of the line.
.018c28	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c2a	29 c0		and #$c0			and 	#$C0 						; is it a number
.018c2c	c9 40		cmp #$40			cmp 	#$40
.018c2e	d0 1e		bne $018c4e			bne 	_FIFContinue 				; if not, do what ever follows.
.018c30	4c 9e 8f	jmp $018f9e			jmp		Command_GOTO 				; we have IF <expr> THEN <number> so we do GOTO code.
.018c33					_FIFEndOfLine:
.018c33	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c35	c9 00		cmp #$00			cmp 	#0 							; if zero, end of line, so exit
.018c37	f0 15		beq $018c4e			beq 	_FIFContinue
.018c39	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018c3b	c8		iny				iny 								; skip
.018c3c	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018c3e	90 0c		bcc $018c4c			bcc 	_SEDone 					; so just skip over it.
.018c40	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018c42	90 07		bcc $018c4b			bcc 	_SEDouble
.018c44	98		tya				tya 								; this is Y + 1
.018c45	18		clc				clc
.018c46	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018c48	a8		tay				tay 								; back in Y.
.018c49	88		dey				dey 								; fix up, one for the +1, one for the iny
.018c4a	88		dey				dey
.018c4b					_SEDouble:
.018c4b	c8		iny				iny
.018c4c					_SEDone:
.018c4c	80 e5		bra $018c33			bra 	_FIFEndOfLine
.018c4e					_FIFContinue:
.018c4e	60		rts				rts
.018c4f					_FIFExtended:
.018c4f	da		phx				phx 								; save result
.018c50	a9 40		lda #$40			lda 	#(SMark_If << 4) 			; push marker on the stack, nothing else.
.018c52	20 b2 84	jsr $0184b2			jsr 	StackPushFrame
.018c55	68		pla				pla 								; restore result
.018c56	f0 01		beq $018c59			beq 	_FIXSkip 					; if zero then it has failed.
.018c58	60		rts				rts 								; test passed, so continue executing
.018c59					_FIXSkip:
.018c59	a9 94		lda #$94			lda 	#token_endif 				; scan forward till found either ELSE or ENDIF
.018c5b	a2 de		ldx #$de			ldx 	#token_else 				; at the same level.
.018c5d	20 f5 83	jsr $0183f5			jsr 	StructureSearchDouble
.018c60	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c62	c8		iny				iny
.018c63	c9 94		cmp #$94			cmp 	#token_endif 				; if endif, handle endif code.
.018c65	f0 07		beq $018c6e			beq 	Command_ENDIF
.018c67	60		rts				rts
.018c68					Command_ELSE:
.018c68	a9 94		lda #$94			lda 	#token_endif 				; scan forward till found ENDIF
.018c6a	20 f3 83	jsr $0183f3			jsr 	StructureSearchSingle 		; then do the ENDIF pop.
.018c6d	c8		iny				iny
.018c6e					Command_ENDIF:
.018c6e	a9 40		lda #$40			lda 	#(SMark_If << 4)
.018c70	20 c9 84	jsr $0184c9			jsr 	StackPopFrame
.018c73	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/list.asm

.018c74					Command_LIST:
.018c74	20 01 8e	jsr $018e01			jsr 	ListGetRange				; get any parameters
.018c77	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018c79	85 16		sta $16				sta 	zCodePtr+0
.018c7b	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018c7d	85 17		sta $17				sta 	zCodePtr+1
.018c7f	a9 00		lda #$00			lda 	#0
.018c81	85 18		sta $18				sta 	zCodePtr+2
.018c83	85 19		sta $19				sta 	zCodePtr+3
.018c85	a0 03		ldy #$03			ldy 	#3
.018c87	a9 00		lda #$00			lda 	#0 							; reset the indent & last indent
.018c89	8d bc 03	sta $03bc			sta 	LastListIndent
.018c8c	8d bb 03	sta $03bb			sta 	ListIndent
.018c8f					_CILLoop:
.018c8f	a0 00		ldy #$00			ldy 	#0
.018c91	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c93	c9 00		cmp #$00			cmp 	#0 							; if zero, end of program
.018c95	f0 23		beq $018cba			beq 	_CILExit
.018c97	20 40 85	jsr $018540			jsr 	VIOCheckBreak 				; check break
.018c9a	c9 00		cmp #$00			cmp 	#0
.018c9c	d0 1c		bne $018cba			bne 	_CILExit
.018c9e	20 48 8e	jsr $018e48			jsr 	ListCheckRange 				; check current line in range.
.018ca1	b0 08		bcs $018cab			bcs		_CILNext
.018ca3	a0 00		ldy #$00			ldy 	#0
.018ca5	c8		iny				iny
.018ca6	c8		iny				iny
.018ca7	c8		iny				iny
.018ca8	20 bd 8c	jsr $018cbd			jsr 	ListLine 					; list one line.
.018cab					_CILNext:
.018cab	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018cad	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.018caf	18		clc				clc
.018cb0	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018cb2	85 16		sta $16				sta 	zCodePtr
.018cb4	90 02		bcc $018cb8			bcc 	_SNLNoCarry
.018cb6	e6 17		inc $17				inc 	zCodePtr+1
.018cb8					_SNLNoCarry:
.018cb8	80 d5		bra $018c8f			bra 	_CILLoop
.018cba					_CILExit:
.018cba	4c 32 88	jmp $018832			jmp 	WarmStart
.018cbd					ListLine:
.018cbd	ad bb 03	lda $03bb			lda 	ListIndent 					; copy current list indent -> last
.018cc0	8d bc 03	sta $03bc			sta 	LastListIndent
.018cc3					_LICountIndent:
.018cc3	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018cc5	c9 00		cmp #$00			cmp 	#0
.018cc7	f0 2f		beq $018cf8			beq 	_LIDoneIndent
.018cc9	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus
.018ccb	90 16		bcc $018ce3			bcc 	_LICINext
.018ccd	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.018ccf	b0 12		bcs $018ce3			bcs 	_LICINext
.018cd1	ee bb 03	inc $03bb			inc 	ListIndent
.018cd4	c9 93		cmp #$93			cmp 	#firstKeywordMinus
.018cd6	90 0b		bcc $018ce3			bcc 	_LICINext
.018cd8	ce bb 03	dec $03bb			dec 	ListIndent
.018cdb	ce bb 03	dec $03bb			dec 	ListIndent
.018cde	10 03		bpl $018ce3			bpl 	_LICINext
.018ce0	ee bb 03	inc $03bb			inc 	ListIndent
.018ce3					_LICINext:
.018ce3	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018ce5	c8		iny				iny 								; skip
.018ce6	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018ce8	90 0c		bcc $018cf6			bcc 	_SEDone 					; so just skip over it.
.018cea	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018cec	90 07		bcc $018cf5			bcc 	_SEDouble
.018cee	98		tya				tya 								; this is Y + 1
.018cef	18		clc				clc
.018cf0	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018cf2	a8		tay				tay 								; back in Y.
.018cf3	88		dey				dey 								; fix up, one for the +1, one for the iny
.018cf4	88		dey				dey
.018cf5					_SEDouble:
.018cf5	c8		iny				iny
.018cf6					_SEDone:
.018cf6	80 cb		bra $018cc3			bra 	_LICountIndent
.018cf8					_LIDoneIndent:
.018cf8	a0 00		ldy #$00			ldy 	#0
.018cfa	c8		iny				iny
.018cfb	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018cfd	85 80		sta $80				sta 	XS_Mantissa
.018cff	c8		iny				iny
.018d00	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018d02	85 81		sta $81				sta 	XS_Mantissa+1
.018d04	20 bf 85	jsr $0185bf			jsr 	Print16BitInteger 			; print integer.
.018d07	85 10		sta $10				sta 	zTemp1 						; save spaces printed.
.018d09	ad bb 03	lda $03bb			lda 	ListIndent 					; smaller of current/prev indent
.018d0c	cd bc 03	cmp $03bc			cmp 	LastListIndent
.018d0f	90 03		bcc $018d14			bcc 	_LISmaller
.018d11	ad bc 03	lda $03bc			lda 	LastListIndent
.018d14					_LISmaller:
.018d14	0a		asl a				asl 	a 							; double indent
.018d15	49 ff		eor #$ff			eor 	#$FF 						; 2's complement arithmetic
.018d17	38		sec				sec
.018d18	65 10		adc $10				adc 	zTemp1 						; "subtract" indent e.g. print more.
.018d1a	aa		tax				tax 								; print spaces to column 6
.018d1b					_LISpace:
.018d1b	a9 20		lda #$20			lda 	#" "
.018d1d	20 f1 8d	jsr $018df1			jsr 	ListPrintLC
.018d20	e8		inx				inx
.018d21	e0 06		cpx #$06			cpx 	#6
.018d23	d0 f6		bne $018d1b			bne 	_LISpace
.018d25					_LIDecode:
.018d25	c8		iny				iny
.018d26	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018d28	c9 00		cmp #$00			cmp 	#0 							; zero, exit.
.018d2a	f0 0f		beq $018d3b			beq 	_LIExit
.018d2c	30 12		bmi $018d40			bmi 	_LIToken
.018d2e	c9 40		cmp #$40			cmp 	#$40 						; 01-$3F, character.
.018d30	b0 50		bcs $018d82			bcs 	_LIInteger
.018d32	49 20		eor #$20			eor 	#$20 						; make 7 bit
.018d34	69 20		adc #$20			adc 	#$20
.018d36	20 f1 8d	jsr $018df1			jsr 	ListPrintLC 				; print in LC
.018d39	80 ea		bra $018d25			bra 	_LIDecode
.018d3b					_LIExit:
.018d3b	a9 0d		lda #$0d			lda 	#13 						; print new line.
.018d3d	4c f1 8d	jmp $018df1			jmp 	ListPrintLC
.018d40					_LIToken:
.018d40	c9 fc		cmp #$fc			cmp 	#$FC 						; $FC-$FF ?
.018d42	90 49		bcc $018d8d			bcc		_LICommandToken
.018d44	48		pha				pha 								; save in case end
.018d45	a2 22		ldx #$22			ldx 	#'"'						; print if $FE quoted string
.018d47	c9 fe		cmp #$fe			cmp 	#$FE
.018d49	f0 17		beq $018d62			beq 	_LIPrint
.018d4b	a2 2e		ldx #$2e			ldx 	#'.'						; print if $FD decimals
.018d4d	c9 fd		cmp #$fd			cmp 	#$FD
.018d4f	f0 11		beq $018d62			beq 	_LIPrint
.018d51	a9 52		lda #$52			lda 	#'R'						; must be REM
.018d53	20 f1 8d	jsr $018df1			jsr 	ListPrintLC
.018d56	a9 45		lda #$45			lda 	#'E'
.018d58	20 f1 8d	jsr $018df1			jsr 	ListPrintLC
.018d5b	a9 4d		lda #$4d			lda 	#'M'
.018d5d	20 f1 8d	jsr $018df1			jsr 	ListPrintLC
.018d60	a2 20		ldx #$20			ldx 	#' '
.018d62					_LIPrint:
.018d62	8a		txa				txa
.018d63	20 f1 8d	jsr $018df1			jsr 	ListPrintLC
.018d66	c8		iny				iny
.018d67	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018d69	aa		tax				tax 								; put in X
.018d6a	ca		dex				dex
.018d6b					_LILoop:
.018d6b	ca		dex				dex 								; exit when count reached zero.
.018d6c	f0 08		beq $018d76			beq 	_LIEnd
.018d6e	c8		iny				iny
.018d6f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018d71	20 f1 8d	jsr $018df1			jsr 	ListPrintLC
.018d74	80 f5		bra $018d6b			bra 	_LILoop
.018d76	68		pla		_LIEnd:	pla 								; get A back
.018d77	c9 fe		cmp #$fe			cmp 	#$FE 						; if '"' need closing quotes
.018d79	d0 aa		bne $018d25			bne 	_LIDecode
.018d7b	a9 22		lda #$22			lda 	#'"'
.018d7d	20 f1 8d	jsr $018df1			jsr 	ListPrintLC
.018d80	80 a3		bra $018d25			bra 	_LIDecode
.018d82					_LIInteger:
.018d82	a2 00		ldx #$00			ldx 	#0
.018d84	20 d6 91	jsr $0191d6			jsr 	EvaluateGetInteger 			; get an atom
.018d87	88		dey				dey
.018d88	20 c5 85	jsr $0185c5			jsr 	Print32BitInteger 			; print integer.
.018d8b	80 98		bra $018d25			bra 	_LIDecode
.018d8d					_LICommandToken:
.018d8d	5a		phy				phy 								; save Y
.018d8e	48		pha				pha 								; save token
.018d8f	a2 bd		ldx #$bd			ldx  	#KeywordText & $FF 			; address of keyword text table.
.018d91	a9 86		lda #$86			lda 	(#KeywordText >> 8) & $FF
.018d93	86 1a		stx $1a				stx 	zLTemp1
.018d95	85 1b		sta $1b				sta 	zLTemp1+1
.018d97	a9 01		lda #$01			lda 	(#KeywordText >> 16) & $FF 	; this is for 65816 (it's a table in code
.018d99	85 1c		sta $1c				sta 	zLTemp1+2 					; space) and won't affect a 6502 at all.
.018d9b	68		pla				pla 								; get token
.018d9c	29 7f		and #$7f			and 	#127 						; chuck bit 7.
.018d9e	f0 16		beq $018db6			beq 	_LIFoundToken
.018da0	aa		tax				tax
.018da1					_LITokenLoop:
.018da1	a0 00		ldy #$00			ldy 	#0 							; last character not a token.
.018da3					_LIFindEnd:
.018da3	b7 1a		lda [$1a],y			lda 	[zLTemp1],y
.018da5	c8		iny				iny
.018da6	0a		asl a				asl 	a
.018da7	90 fa		bcc $018da3			bcc 	_LIFindEnd
.018da9	98		tya				tya 								; that is step to the next
.018daa	18		clc				clc 								; we don't bother bumping the 3rd byte
.018dab	65 1a		adc $1a				adc 	zLTemp1 					; here.
.018dad	85 1a		sta $1a				sta 	zLTemp1
.018daf	90 02		bcc $018db3			bcc 	_LINoBump
.018db1	e6 1b		inc $1b				inc 	zLTemp1+1
.018db3					_LINoBump:
.018db3	ca		dex				dex 								; no go round again.
.018db4	d0 eb		bne $018da1			bne 	_LITokenLoop
.018db6					_LIFoundToken:
.018db6	a0 00		ldy #$00			ldy 	#0
.018db8					_LIPrintToken:
.018db8	b7 1a		lda [$1a],y			lda 	[zLTemp1],y
.018dba	c0 00		cpy #$00			cpy 	#0 							; see if needs prefix space
.018dbc	d0 16		bne $018dd4			bne 	_LINoPrefixSpace
.018dbe	c9 41		cmp #$41			cmp 	#"A" 						; e.g. alphabetic token.
.018dc0	90 12		bcc $018dd4			bcc 	_LINoPrefixSpace
.018dc2	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018dc4	b0 0e		bcs $018dd4			bcs 	_LINoPrefixSpace
.018dc6	ae ba 03	ldx $03ba			ldx 	LastPrinted 				; if last was space not required
.018dc9	e0 20		cpx #$20			cpx 	#" "
.018dcb	f0 07		beq $018dd4			beq 	_LINoPrefixSpace
.018dcd	48		pha				pha
.018dce	a9 20		lda #$20			lda 	#" "
.018dd0	20 f1 8d	jsr $018df1			jsr 	ListPrintLC
.018dd3	68		pla				pla
.018dd4					_LINoPrefixSpace:
.018dd4	c8		iny				iny
.018dd5	48		pha				pha 								; save it
.018dd6	29 7f		and #$7f			and 	#$7F
.018dd8	20 f1 8d	jsr $018df1			jsr 	ListPrintLC
.018ddb	68		pla				pla
.018ddc	10 da		bpl $018db8			bpl 	_LIPrintToken 				; go back if not end
.018dde	7a		ply				ply 								; restore Y
.018ddf	29 7f		and #$7f			and 	#$7F 						; if last char is a letter
.018de1	c9 41		cmp #$41			cmp 	#"A"
.018de3	90 09		bcc $018dee			bcc 	_LINotLetter2
.018de5	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018de7	b0 05		bcs $018dee			bcs 	_LINotLetter2
.018de9	a9 20		lda #$20			lda 	#" " 						; add spacing
.018deb	20 f1 8d	jsr $018df1			jsr 	ListPrintLC
.018dee					_LINotLetter2:
.018dee	4c 25 8d	jmp $018d25			jmp 	_LIDecode
.018df1					ListPrintLC:
.018df1	8d ba 03	sta $03ba			sta 	LastPrinted
.018df4	c9 41		cmp #$41			cmp 	#"A"
.018df6	90 06		bcc $018dfe			bcc 	_LPLC0
.018df8	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018dfa	b0 02		bcs $018dfe			bcs 	_LPLC0
.018dfc	69 20		adc #$20			adc 	#$20
.018dfe	4c 32 85	jmp $018532	_LPLC0:	jmp 	VIOCharPrint
.018e01					ListGetRange:
.018e01	a2 0b		ldx #$0b			ldx 	#XS_Size*2-1 				; clear first 2 slots back to defaults.
.018e03					_LGRClear:
.018e03	a9 00		lda #$00			lda 	#0
.018e05	95 80		sta $80,x			sta 	XS_Mantissa,x
.018e07	ca		dex				dex
.018e08	10 f9		bpl $018e03			bpl 	_LGRClear
.018e0a	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e0c	c9 00		cmp #$00			cmp 	#0 							; nothing
.018e0e	f0 21		beq $018e31			beq 	_LGRBlank
.018e10	c9 c0		cmp #$c0			cmp 	#token_Colon 				; or colon
.018e12	f0 1d		beq $018e31			beq 	_LGRBlank
.018e14	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma
.018e16	f0 18		beq $018e30			beq 	_LGREnd 					; then it's LIST ,x
.018e18	20 64 92	jsr $019264			jsr 	EvaluateInteger 			; get the first number into bottom
.018e1b	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e1d	c9 bf		cmp #$bf			cmp 	#token_Comma
.018e1f	f0 0f		beq $018e30			beq 	_LGREnd 					; then it is LIST a,b
.018e21	a5 80		lda $80				lda 	XS_Mantissa+0 				; copy first to second LIST n is n,n
.018e23	85 86		sta $86				sta 	XS_Mantissa+XS_Size+0
.018e25	a5 81		lda $81				lda 	XS_Mantissa+1
.018e27	85 87		sta $87				sta 	XS_Mantissa+XS_Size+1
.018e29					_LGRBumpExit:
.018e29	e6 86		inc $86				inc 	XS_Mantissa+XS_Size 		; bump it so we can use cc.
.018e2b	d0 02		bne $018e2f			bne 	_LGRBump2
.018e2d	e6 87		inc $87				inc 	XS_Mantissa+XS_Size+1
.018e2f					_LGRBump2:
.018e2f	60		rts				rts
.018e30					_LGREnd:
.018e30	c8		iny				iny
.018e31					_LGRBlank:
.018e31	a9 ff		lda #$ff			lda 	#$FF 						; default to the end.
.018e33	85 86		sta $86				sta 	XS_Mantissa+XS_Size
.018e35	85 87		sta $87				sta 	XS_Mantissa+XS_Size+1
.018e37	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e39	c9 00		cmp #$00			cmp 	#0
.018e3b	f0 f2		beq $018e2f			beq 	_LGRBump2
.018e3d	0a		asl a				asl 	a 							; if not a number, then exit (to end)
.018e3e	b0 ef		bcs $018e2f			bcs 	_LGRBump2
.018e40	a2 06		ldx #$06			ldx 	#XS_Size 					; get to range
.018e42	20 66 92	jsr $019266			jsr 	EvaluateIntegerX
.018e45	80 e2		bra $018e29			bra 	_LGRBumpExit
.018e47	60		rts				rts
.018e48					ListCheckRange:
.018e48	c8		iny				iny
.018e49	a2 00		ldx #$00			ldx 	#0 							; test low
.018e4b	20 58 8e	jsr $018e58			jsr 	_LCRCompare
.018e4e	90 06		bcc $018e56			bcc 	_LCRFail
.018e50	a2 06		ldx #$06			ldx 	#XS_Size 					; test high
.018e52	20 58 8e	jsr $018e58			jsr 	_LCRCompare
.018e55	60		rts				rts
.018e56					_LCRFail:
.018e56	38		sec				sec
.018e57	60		rts				rts
.018e58					_LCRCompare:
.018e58	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e5a	38		sec				sec
.018e5b	f5 80		sbc $80,x			sbc	 	XS_Mantissa+0,x
.018e5d	08		php				php
.018e5e	c8		iny				iny
.018e5f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e61	28		plp				plp
.018e62	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.018e64	08		php				php
.018e65	88		dey				dey
.018e66	28		plp				plp
.018e67	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/print.asm

.018e68					Command_PRINT:
.018e68					_CPR_Loop:
.018e68	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e6a	c9 00		cmp #$00			cmp 	#0 							; end
.018e6c	f0 24		beq $018e92			beq 	_CPR_GoNewLine
.018e6e	c9 c0		cmp #$c0			cmp 	#token_Colon
.018e70	f0 20		beq $018e92			beq 	_CPR_GoNewLine
.018e72	c9 c1		cmp #$c1			cmp 	#token_SemiColon
.018e74	f0 74		beq $018eea			beq 	_CPR_Skip
.018e76	c9 bf		cmp #$bf			cmp 	#token_Comma
.018e78	f0 57		beq $018ed1			beq 	_CPR_Tab
.018e7a	20 ce 90	jsr $0190ce			jsr 	EvaluateExpression 			; get expression.
.018e7d	a5 85		lda $85				lda 	XS_Type 					; get type.
.018e7f	29 02		and #$02			and 	#2
.018e81	d0 27		bne $018eaa			bne 	_CPR_String 				; if type = 2 output as string.
.018e83					_CPR_Number:
.018e83	a9 00		lda #$00			lda 	#0 							; reset buffer index
.018e85	8d 14 03	sta $0314			sta 	NumBufX
.018e88	a5 85		lda $85				lda 	XS_Type 					; get type
.018e8a	4a		lsr a				lsr 	a
.018e8b	b0 08		bcs $018e95			bcs 	_CPRInt 					; if msb set do as integer
.018e8d	20 b2 a3	jsr $01a3b2			jsr 	FPToString 					; call fp to str otherwise
.018e90	80 06		bra $018e98			bra 	_CPRNPrint
.018e92					_CPR_GoNewLine:
.018e92	4c f8 8e	jmp $018ef8			jmp 	_CPR_NewLine
.018e95	20 3a 9e	jsr $019e3a	_CPRInt:jsr 	IntToString
.018e98					_CPRNPrint:
.018e98	ad 15 03	lda $0315			lda 	Num_Buffer 					; is first character -
.018e9b	c9 2d		cmp #$2d			cmp 	#"-"
.018e9d	f0 05		beq $018ea4			beq 	_CPRNoSpace
.018e9f	a9 20		lda #$20			lda 	#" "						; print the leading space
.018ea1	20 32 85	jsr $018532			jsr 	VIOCharPrint 				; so beloved of MS Basics.
.018ea4					_CPRNoSpace:
.018ea4	a2 14		ldx #$14			ldx 	#(Num_Buffer-1) & $FF
.018ea6	a9 03		lda #$03			lda 	#(Num_Buffer-1) >> 8
.018ea8	80 04		bra $018eae			bra 	_CPRPrint
.018eaa					_CPR_String:
.018eaa	a6 80		ldx $80				ldx 	XS_Mantissa
.018eac	a5 81		lda $81				lda 	XS_Mantissa+1
.018eae					_CPRPrint:
.018eae	86 1e		stx $1e				stx 	zGenPtr
.018eb0	85 1f		sta $1f				sta 	zGenPtr+1
.018eb2	5a		phy				phy
.018eb3	a0 00		ldy #$00			ldy 	#0							; get length into X
.018eb5	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018eb7	aa		tax				tax
.018eb8	f0 09		beq $018ec3			beq 	_CPREndPrint 				; nothing to print
.018eba					_CPRLoop:
.018eba	c8		iny				iny
.018ebb	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018ebd	20 32 85	jsr $018532			jsr 	VIOCharPrint
.018ec0	ca		dex				dex
.018ec1	d0 f7		bne $018eba			bne 	_CPRLoop
.018ec3					_CPREndPrint:
.018ec3	a5 85		lda $85				lda 	XS_Type 					; if numeric add trailing space
.018ec5	29 02		and #$02			and 	#2
.018ec7	d0 05		bne $018ece			bne 	_CPRNoTrail
.018ec9	a9 20		lda #$20			lda 	#" "
.018ecb	20 32 85	jsr $018532			jsr 	VIOCharPrint
.018ece					_CPRNoTrail:
.018ece	7a		ply				ply
.018ecf	80 97		bra $018e68			bra 	_CPR_Loop
.018ed1					_CPR_Tab:
.018ed1	20 43 85	jsr $018543			jsr 	VIOCharGetPosition 			; print until position % 8 = 0
.018ed4					_CPR_CalcSpaces:
.018ed4	38		sec				sec 								; calculate position mod 10.
.018ed5	e9 0a		sbc #$0a			sbc 	#10
.018ed7	b0 fb		bcs $018ed4			bcs 	_CPR_CalcSpaces
.018ed9	69 0a		adc #$0a			adc 	#10
.018edb	f0 0d		beq $018eea			beq 	_CPR_Skip 					; nothing to print
.018edd	aa		tax				tax 								; print out spaces to mod 10
.018ede					_CPRTabSpaces:
.018ede	a9 20		lda #$20			lda 	#" "
.018ee0	20 32 85	jsr $018532			jsr 	VIOCharPrint
.018ee3	e8		inx				inx
.018ee4	e0 0a		cpx #$0a			cpx 	#10
.018ee6	d0 f6		bne $018ede			bne 	_CPRTabSpaces
.018ee8	80 e7		bra $018ed1			bra 	_CPR_Tab
.018eea					_CPR_Skip:
.018eea	c8		iny				iny
.018eeb	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018eed	c9 c0		cmp #$c0			cmp 	#token_Colon 				; colon or $00, exit
.018eef	f0 0c		beq $018efd			beq 	_CPR_Exit
.018ef1	c9 00		cmp #$00			cmp 	#0
.018ef3	f0 08		beq $018efd			beq 	_CPR_Exit 					; if not go round again.
.018ef5	4c 68 8e	jmp $018e68			jmp 	_CPR_Loop
.018ef8					_CPR_NewLine:
.018ef8	a9 0d		lda #$0d			lda 	#13
.018efa	20 32 85	jsr $018532			jsr 	VIOCharPrint
.018efd					_CPR_Exit:
.018efd	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/assert.asm

.018efe					Command_ASSERT:
.018efe	20 64 92	jsr $019264			jsr 	EvaluateInteger 			; calculate thing being asserted, 0=>X
.018f01	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; check if true (non-zero)
.018f03	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.018f05	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.018f07	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.018f09	f0 01		beq $018f0c			beq 	_ASFail
.018f0b	60		rts				rts
.018f0c					_ASFail:
.018f0c	20 79 85	jsr $018579			jsr ERR_Handler
>018f0f	41 73 73 65 72 74 00			.text "Assert",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/poke.asm

.018f16					Command_POKE:
.018f16	a9 01		lda #$01			lda 	#1
.018f18	80 06		bra $018f20			bra 	CmdPoke_Main
.018f1a					Command_DOKE:
.018f1a	a9 02		lda #$02			lda 	#2
.018f1c	80 02		bra $018f20			bra 	CmdPoke_Main
.018f1e					Command_LOKE:
.018f1e	a9 04		lda #$04			lda 	#4
.018f20					CmdPoke_Main:
.018f20	48		pha				pha
.018f21	20 64 92	jsr $019264			jsr 	EvaluateInteger 			; get two parameters.
.018f24	e8		inx				inx
.018f25	e8		inx				inx
.018f26	e8		inx				inx
.018f27	e8		inx				inx
.018f28	e8		inx				inx
.018f29	e8		inx				inx
.018f2a	20 b2 98	jsr $0198b2			jsr 	CheckNextComma
.018f2d	20 66 92	jsr $019266			jsr 	EvaluateIntegerX
.018f30	a5 80		lda $80				lda 	XS_Mantissa+0 			; copy the mantissa into ZLTemp1 (address)
.018f32	85 1a		sta $1a				sta 	zLTemp1
.018f34	a5 81		lda $81				lda 	XS_Mantissa+1
.018f36	85 1b		sta $1b				sta 	zLTemp1+1
.018f38	a5 82		lda $82				lda 	XS_Mantissa+2
.018f3a	85 1c		sta $1c				sta 	zLTemp1+2
.018f3c	a5 83		lda $83				lda 	XS_Mantissa+3
.018f3e	85 1d		sta $1d				sta 	zLTemp1+3
.018f40	68		pla				pla 								; get count
.018f41	5a		phy				phy 								; save Y
.018f42	20 3d 98	jsr $01983d			jsr 	MemWrite 					; write it out
.018f45	7a		ply				ply 								; restore Y and done.
.018f46	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/newold.asm

.018f47					Command_NEW:
.018f47	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018f49	85 16		sta $16				sta 	zCodePtr+0
.018f4b	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018f4d	85 17		sta $17				sta 	zCodePtr+1
.018f4f	a9 00		lda #$00			lda 	#0
.018f51	85 18		sta $18				sta 	zCodePtr+2
.018f53	85 19		sta $19				sta 	zCodePtr+3
.018f55	a0 03		ldy #$03			ldy 	#3
.018f57	a0 00		ldy #$00			ldy 	#0
.018f59	a9 00		lda #$00			lda 	#0 							; write a 0 there.
.018f5b	97 16		sta [$16],y			sta 	[zCodePtr],y
.018f5d	20 4e 98	jsr $01984e			jsr 	UpdateProgramEnd 			; update program end.
.018f60	4c 32 88	jmp $018832			jmp 	WarmStart
.018f63					Command_OLD:
.018f63	ea		nop				nop
.018f64	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018f66	85 16		sta $16				sta 	zCodePtr+0
.018f68	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018f6a	85 17		sta $17				sta 	zCodePtr+1
.018f6c	a9 00		lda #$00			lda 	#0
.018f6e	85 18		sta $18				sta 	zCodePtr+2
.018f70	85 19		sta $19				sta 	zCodePtr+3
.018f72	a0 03		ldy #$03			ldy 	#3
.018f74					_COL_Find:
.018f74	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018f76	c8		iny				iny
.018f77	c9 00		cmp #$00			cmp 	#0 							; if zero, then the position Y/Z is new offset
.018f79	f0 18		beq $018f93			beq 	_COL_Found
.018f7b	98		tya				tya
.018f7c	c9 00		cmp #$00			cmp 	#0
.018f7e	d0 f4		bne $018f74			bne 	_COL_Find 					; can't find old EOL, give up.
.018f80	20 79 85	jsr $018579			jsr ERR_Handler
>018f83	50 72 6f 67 72 61 6d 20			.text "Program Corrupt",0
>018f8b	43 6f 72 72 75 70 74 00
.018f93					_COL_Found:
.018f93	98		tya				tya
.018f94	48		pha				pha
.018f95	a0 00		ldy #$00			ldy 	#0
.018f97	68		pla				pla
.018f98	97 16		sta [$16],y			sta 	[zCodePtr],y
.018f9a	20 4e 98	jsr $01984e			jsr 	UpdateProgramEnd 			; reset variable pointer
.018f9d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/branch.asm

.018f9e					Command_GOTO:
.018f9e	20 f3 8f	jsr $018ff3			jsr 	GotoGetLineNumber
.018fa1					CmdGOTO:
.018fa1	a2 00		ldx #$00			ldx 	#0
.018fa3	4c 10 90	jmp $019010			jmp 	GotoChangeToLineNumberX
.018fa6					Command_GOSUB:
.018fa6	20 f3 8f	jsr $018ff3			jsr 	GotoGetLineNumber
.018fa9					CmdGOSUB:
.018fa9	20 f9 84	jsr $0184f9			jsr 	StackSavePosition
.018fac	a9 15		lda #$15			lda 	#(SMark_Gosub << 4)+SourcePosSize
.018fae	20 b2 84	jsr $0184b2			jsr 	StackPushFrame
.018fb1	a2 00		ldx #$00			ldx		#0
.018fb3	4c 10 90	jmp $019010			jmp 	GotoChangeToLineNumberX
.018fb6					Command_RETURN:
.018fb6	a9 10		lda #$10			lda 	#(SMark_Gosub << 4)
.018fb8	20 c9 84	jsr $0184c9			jsr 	StackPopFrame
.018fbb	20 16 85	jsr $018516			jsr 	StackRestorePosition
.018fbe	60		rts				rts
.018fbf					Command_ON:
.018fbf	a2 00		ldx #$00			ldx 	#0 							; get the ON.
.018fc1	20 00 97	jsr $019700			jsr 	SLIByteParameter
.018fc4	a5 80		lda $80				lda 	XS_Mantissa+0 				; get the count
.018fc6	f0 28		beq $018ff0			beq 	_CONFail 					; can't be zero.
.018fc8	aa		tax				tax 								; save in X.
.018fc9	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018fcb	c8		iny				iny
.018fcc	48		pha				pha
.018fcd	c9 cc		cmp #$cc			cmp 	#token_GOTO 				; must be GOTO or GOSUB
.018fcf	f0 07		beq $018fd8			beq 	_CONOkayToken
.018fd1	c9 ca		cmp #$ca			cmp 	#token_GOSUB
.018fd3	f0 03		beq $018fd8			beq 	_CONOkayToken
.018fd5	4c 4a 85	jmp $01854a			jmp 	SyntaxError
.018fd8					_CONOkayToken:
.018fd8	da		phx				phx 								; count on top, GOTO/GOSUB token 2nd.
.018fd9					_CONFindNumber:
.018fd9	20 f3 8f	jsr $018ff3			jsr 	GotoGetLineNumber 			; get a line number.
.018fdc	fa		plx				plx 								; restore count
.018fdd	ca		dex				dex  								; decrement, exit if zero.
.018fde	f0 06		beq $018fe6			beq 	_CONFound
.018fe0	da		phx				phx 								; push back
.018fe1	20 b2 98	jsr $0198b2			jsr 	CheckNextComma				; check for comma
.018fe4	80 f3		bra $018fd9			bra 	_CONFindNumber
.018fe6					_CONFound:
.018fe6	68		pla				pla 								; get token
.018fe7	c9 cc		cmp #$cc			cmp 	#token_GOTO 				; if GOTO
.018fe9	f0 b6		beq $018fa1			beq		CmdGOTO 					; then just branch.
.018feb	20 80 84	jsr $018480			jsr 	SkipEndOfCommand 			; go to end of command
.018fee	80 b9		bra $018fa9			bra 	CmdGOSUB 					; and do a GOSUB.
.018ff0					_CONFail:
.018ff0	4c 68 85	jmp $018568			jmp 	BadParamError
.018ff3					GotoGetLineNumber:
.018ff3	20 64 92	jsr $019264			jsr 	EvaluateInteger
.018ff6	a5 82		lda $82				lda 	XS_Mantissa+2 				; check range
.018ff8	05 83		ora $83				ora 	XS_Mantissa+3
.018ffa	d0 01		bne $018ffd			bne 	_GLINError
.018ffc	60		rts				rts
.018ffd					_GLINError:
.018ffd	20 79 85	jsr $018579			jsr ERR_Handler
>019000	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>019008	20 4e 75 6d 62 65 72 00
.019010					GotoChangeToLineNumberX:
.019010	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check line number not zero
.019012	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019014	f0 37		beq $01904d			beq 	_GCTLFail
.019016	a9 00		lda #$00			lda 	#BasicProgram & $FF
.019018	85 16		sta $16				sta 	zCodePtr+0
.01901a	a9 10		lda #$10			lda 	#BasicProgram >> 8
.01901c	85 17		sta $17				sta 	zCodePtr+1
.01901e	a9 00		lda #$00			lda 	#0
.019020	85 18		sta $18				sta 	zCodePtr+2
.019022	85 19		sta $19				sta 	zCodePtr+3
.019024	a0 03		ldy #$03			ldy 	#3
.019026					_GCTLLoop:
.019026	a0 00		ldy #$00			ldy 	#0
.019028	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01902a	c9 00		cmp #$00			cmp 	#0
.01902c	f0 1f		beq $01904d			beq 	_GCTLFail
.01902e	c8		iny				iny
.01902f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019031	d5 80		cmp $80,x			cmp 	XS_Mantissa+0,x
.019033	d0 07		bne $01903c			bne 	_GCTLNext
.019035	c8		iny				iny
.019036	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019038	d5 81		cmp $81,x			cmp 	XS_Mantissa+1,x
.01903a	f0 0f		beq $01904b			beq 	_GCTLExit
.01903c					_GCTLNext:
.01903c	a0 00		ldy #$00			ldy 	#0 							; point to offset
.01903e	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.019040	18		clc				clc
.019041	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.019043	85 16		sta $16				sta 	zCodePtr
.019045	90 02		bcc $019049			bcc 	_SNLNoCarry
.019047	e6 17		inc $17				inc 	zCodePtr+1
.019049					_SNLNoCarry:
.019049	80 db		bra $019026			bra 	_GCTLLoop 					; try next line.
.01904b					_GCTLExit:
.01904b	c8		iny				iny
.01904c	60		rts				rts
.01904d					_GCTLFail:
.01904d	20 79 85	jsr $018579			jsr ERR_Handler
>019050	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>019058	20 4e 75 6d 62 65 72 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.019060					Command_CLR:
.019060					ResetRunStatus:
.019060	20 94 99	jsr $019994			jsr 	VariableClear
.019063	20 a0 84	jsr $0184a0			jsr 	StackReset
.019066	a9 00		lda #$00			lda 	#HighMemory & $FF
.019068	8d 00 03	sta $0300			sta 	StringPtr
.01906b	a9 7f		lda #$7f			lda 	#HighMemory >> 8
.01906d	8d 01 03	sta $0301			sta 	StringPtr+1
.019070	20 5e 9b	jsr $019b5e			jsr 	ArrayResetDefault
.019073	20 ed 8a	jsr $018aed			jsr 	Command_RESTORE
.019076	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/stop.asm

.019077					Command_STOP:
.019077	20 79 85	jsr $018579			jsr ERR_Handler
>01907a	53 74 6f 70 00				.text "Stop",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/while.asm

.01907f					Command_WHILE:
.01907f	20 f9 84	jsr $0184f9			jsr 	StackSavePosition			; save position into stack, but don't yet push.
.019082	20 64 92	jsr $019264			jsr 	EvaluateInteger 			; calculate the while loop value.
.019085	a5 80		lda $80				lda 	XS_Mantissa+0				; check the result if zero
.019087	05 81		ora $81				ora 	XS_Mantissa+1
.019089	05 82		ora $82				ora 	XS_Mantissa+2
.01908b	05 83		ora $83				ora 	XS_Mantissa+3
.01908d	f0 06		beq $019095			beq 	_CWHSkip 					; if it is zero, then skip to WEND.
.01908f	a9 35		lda #$35			lda 	#(SMark_While << 4)+SourcePosSize
.019091	20 b2 84	jsr $0184b2			jsr 	StackPushFrame 				; push on stack
.019094	60		rts				rts
.019095					_CWHSkip:
.019095	a9 95		lda #$95			lda 	#token_Wend 				; look for the WEND token.
.019097	20 f3 83	jsr $0183f3			jsr 	StructureSearchSingle
.01909a	c8		iny				iny
.01909b	60		rts				rts
.01909c					Command_WEND:
.01909c	a9 30		lda #$30			lda 	#(SMark_While << 4)			; remove the frame
.01909e	20 c9 84	jsr $0184c9			jsr 	StackPopFrame
.0190a1	20 16 85	jsr $018516			jsr 	StackRestorePosition
.0190a4	80 d9		bra $01907f			bra 	Command_WHILE 				; and do the while again.
.0190a6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/repeat.asm

.0190a7					Command_REPEAT:
.0190a7	20 f9 84	jsr $0184f9			jsr 	StackSavePosition			; save position into stack
.0190aa	a9 25		lda #$25			lda 	#(SMark_Repeat << 4)+SourcePosSize
.0190ac	20 b2 84	jsr $0184b2			jsr 	StackPushFrame 				; push on stack
.0190af	60		rts				rts
.0190b0					Command_UNTIL:
.0190b0	a9 20		lda #$20			lda 	#(SMark_Repeat << 4)		; remove the frame
.0190b2	20 c9 84	jsr $0184c9			jsr 	StackPopFrame
.0190b5	20 64 92	jsr $019264			jsr 	EvaluateInteger				; work out UNTIL
.0190b8	a5 80		lda $80				lda 	XS_Mantissa+0 				; check if zero.
.0190ba	05 81		ora $81				ora 	XS_Mantissa+1
.0190bc	05 82		ora $82				ora 	XS_Mantissa+2
.0190be	05 83		ora $83				ora 	XS_Mantissa+3
.0190c0	d0 08		bne $0190ca			bne 	_CUTExit 					; if not, just exit
.0190c2	20 16 85	jsr $018516			jsr 	StackRestorePosition 		; otherwise loop round again.
.0190c5	a9 25		lda #$25			lda 	#(SMark_Repeat << 4)+SourcePosSize
.0190c7	20 b2 84	jsr $0184b2			jsr 	StackPushFrame 				; fix the stack back.
.0190ca					_CUTExit:
.0190ca	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.0190cb					EVESyntax:
.0190cb	4c 4a 85	jmp $01854a			jmp 	SyntaxError
.0190ce					EvaluateExpression:
.0190ce	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.0190d0					EvaluateExpressionX:
.0190d0	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.0190d2					EvaluateExpressionXA:
.0190d2	48		pha				pha 								; save precedence on stack.
.0190d3	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0190d5	f0 f4		beq $0190cb			beq 	EVESyntax 					; end of line, syntax error.
.0190d7	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.0190d9	b0 03		bcs $0190de			bcs 	_EVNotVariable
.0190db	4c a8 91	jmp $0191a8			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.0190de					_EVNotVariable:
.0190de	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.0190e0	90 e9		bcc $0190cb			bcc 	EVESyntax
.0190e2	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.0190e4	b0 58		bcs $01913e			bcs 	_EVNotInteger
.0190e6	20 d6 91	jsr $0191d6			jsr 	EvaluateGetInteger
.0190e9					_EVCheckDecimal:
.0190e9	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0190eb	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.0190ed	d0 05		bne $0190f4			bne 	_EVGotAtom 					; no, get atom.
.0190ef					_EVIsDecimal:
.0190ef	20 fc 91	jsr $0191fc			jsr 	EVGetDecimal 				; extend to the decimal part.
.0190f2	80 00		bra $0190f4			bra 	_EVGotAtom 					; and continue to got atom.
.0190f4					_EVGotAtom:
.0190f4	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0190f6	10 44		bpl $01913c			bpl 	_EVExitDrop 				; must be a token.
.0190f8	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.0190fa	b0 40		bcs $01913c			bcs 	_EVExitDrop
.0190fc	68		pla				pla 								; get current precedence
.0190fd	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.0190ff	da		phx				phx 								; save X
.019100	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019102	aa		tax				tax 								; put in X
.019103	bf 2e 86 01	lda $01862e,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.019107	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.019109	fa		plx				plx 								; restore X
.01910a	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.01910c	90 2f		bcc $01913d			bcc 	_EVExit 					; exit if too low.
.01910e	f0 2d		beq $01913d			beq 	_EVExit 					; exit if equals
.019110	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.019112	48		pha				pha
.019113	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019115	48		pha				pha
.019116	c8		iny				iny
.019117	da		phx				phx 								; save current position
.019118	e8		inx				inx
.019119	e8		inx				inx
.01911a	e8		inx				inx
.01911b	e8		inx				inx
.01911c	e8		inx				inx
.01911d	e8		inx				inx
.01911e	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.019120	20 d2 90	jsr $0190d2			jsr 	EvaluateExpressionXA 		; do the RHS.
.019123	fa		plx				plx 								; restore X
.019124	68		pla				pla 								; get the binary operator in A.
.019125					_EVCallA:
.019125	da		phx				phx 								; save X again
.019126	0a		asl a				asl 	a 							; double, lose the MSB.
.019127	aa		tax				tax									; put in X
.019128	bf dd 85 01	lda $0185dd,x			lda 	VectorTable,x 				; copy address into zGenPtr
.01912c	8d 11 03	sta $0311			sta 	LocalVector+1
.01912f	bf de 85 01	lda $0185de,x			lda 	VectorTable+1,x
.019133	8d 12 03	sta $0312			sta 	LocalVector+2
.019136	fa		plx				plx 								; restore X
.019137	20 b1 91	jsr $0191b1			jsr 	EVCallLocalVector
.01913a	80 b8		bra $0190f4			bra 	_EVGotAtom 					; and loop back.
.01913c					_EVExitDrop:
.01913c	68		pla				pla
.01913d					_EVExit:
.01913d	60		rts				rts
.01913e					_EVNotInteger:
.01913e	c8		iny				iny
.01913f	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.019141	d0 16		bne $019159			bne 	_EVNotMinus
.019143	20 45 92	jsr $019245			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.019146	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.019148	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.01914a	f0 05		beq $019151			beq 	_EVMinusFloat
.01914c	20 1d 9e	jsr $019e1d			jsr 	IntegerNegateAlways 		; negation
.01914f	80 a3		bra $0190f4			bra 	_EVGotAtom 					; and go back.
.019151					_EVMinusFloat:
.019151	b5 85		lda $85,x			lda 	XS_Type,x 					; invert the sign bit.
.019153	49 80		eor #$80			eor 	#$80
.019155	95 85		sta $85,x			sta 	XS_Type,x
.019157	80 9b		bra $0190f4			bra 	_EVGotAtom
.019159					_EVNotMinus:
.019159	c9 bd		cmp #$bd			cmp 	#token_lparen 				; is it left parenthesis
.01915b	d0 17		bne $019174			bne 	_EVNotParenthesis
.01915d	20 d0 90	jsr $0190d0			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.019160	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019162	c8		iny				iny
.019163	c9 be		cmp #$be			cmp 	#token_rparen 				; okay if right bracket.
.019165	f0 8d		beq $0190f4			beq 	_EVGotAtom
.019167	20 79 85	jsr $018579			jsr ERR_Handler
>01916a	4d 69 73 73 69 6e 67 20			.text "Missing )",0
>019172	29 00
.019174					_EVNotParenthesis:
.019174	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.019176	d0 0c		bne $019184			bne 	_EVNotNot
.019178	20 45 92	jsr $019245			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.01917b	20 b3 a2	jsr $01a2b3			jsr 	FPUToInteger 				; make it an integer - if possible.
.01917e	20 2a 92	jsr $01922a			jsr 	NotInteger 					; do the not calculation
.019181	4c f4 90	jmp $0190f4			jmp 	_EVGotAtom
.019184					_EVNotNot:
.019184	c9 fe		cmp #$fe			cmp 	#$FE
.019186	d0 12		bne $01919a			bne 	_EVNotString
.019188	20 32 99	jsr $019932			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.01918b	a5 20		lda $20				lda 	zTempStr 					; copy address of string into mantissa
.01918d	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01918f	a5 21		lda $21				lda 	zTempStr+1
.019191	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019193	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.019195	95 85		sta $85,x			sta 	XS_Type,x
.019197	4c f4 90	jmp $0190f4			jmp 	_EVGotAtom
.01919a					_EVNotString:
.01919a	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.01919c	90 04		bcc $0191a2			bcc 	_EVBadElement
.01919e	c9 b7		cmp #$b7			cmp 	#lastUnaryFunction+1
.0191a0	90 03		bcc $0191a5			bcc 	_EVUnaryFunction
.0191a2					_EVBadElement:
.0191a2	4c 4a 85	jmp $01854a			jmp 	SyntaxError
.0191a5					_EVUnaryFunction:
.0191a5	4c 25 91	jmp $019125			jmp 	_EVCallA
.0191a8					_EVVariableHandler:
.0191a8	20 58 99	jsr $019958			jsr 	VariableFind 				; locate a variable
.0191ab	20 a0 9c	jsr $019ca0			jsr 	VariableGet 				; copy into memory.
.0191ae	4c f4 90	jmp $0190f4			jmp 	_EVGotAtom 					; and go round.
.0191b1					EVCallLocalVector:
.0191b1	6c 11 03	jmp ($0311)			jmp 	(LocalVector+1)
.0191b4					EVShiftMantissaLeft6:
.0191b4	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.0191b6	95 84		sta $84,x			sta 	XS_Exponent,x
.0191b8	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0191ba	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0191bc	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0191be	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0191c0	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0191c2	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0191c4	a9 00		lda #$00			lda 	#0
.0191c6	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0191c8	20 cb 91	jsr $0191cb			jsr 	_EVSMLShift 					; call it here to do it twice
.0191cb					_EVSMLShift:
.0191cb	56 84		lsr $84,x			lsr 	XS_Exponent,x
.0191cd	76 83		ror $83,x			ror 	XS_Mantissa+3,x
.0191cf	76 82		ror $82,x			ror 	XS_Mantissa+2,x
.0191d1	76 81		ror $81,x			ror 	XS_Mantissa+1,x
.0191d3	76 80		ror $80,x			ror 	XS_Mantissa+0,x
.0191d5	60		rts				rts
.0191d6					EvaluateGetInteger:
.0191d6	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0191d8	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.0191da	95 80		sta $80,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.0191dc	a9 00		lda #$00			lda 	#0
.0191de	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0191e0	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0191e2	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0191e4	1a		inc a				inc 	a 							; set to type 1 (integer)
.0191e5	95 85		sta $85,x			sta 	XS_Type,x
.0191e7					_EVCheckNextInteger:
.0191e7	c8		iny				iny
.0191e8	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0191ea	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.0191ec	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.0191ee	b0 0b		bcs $0191fb			bcs 	_EVEndInteger
.0191f0	48		pha				pha 								; save it.
.0191f1	20 b4 91	jsr $0191b4			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.0191f4	68		pla				pla
.0191f5	15 80		ora $80,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.0191f7	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0191f9	80 ec		bra $0191e7			bra 	_EVCheckNextInteger
.0191fb					_EVEndInteger:
.0191fb	60		rts				rts
.0191fc					EVGetDecimal:
.0191fc	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.0191fe	8d 15 03	sta $0315			sta 	Num_Buffer
.019201	da		phx				phx
.019202	c8		iny				iny
.019203	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019205	c8		iny				iny
.019206	3a		dec a				dec 	a								; convert to a string length.
.019207	3a		dec a				dec 	a
.019208	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.01920a					_EVGDCopy:
.01920a	48		pha				pha 									; save count
.01920b	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01920d	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.019210	e8		inx				inx 									; forward ....
.019211	c8		iny				iny
.019212	68		pla				pla 									; get count
.019213	3a		dec a				dec 	a 								; until zero
.019214	d0 f4		bne $01920a			bne 	_EVGDCopy
.019216	9d 15 03	sta $0315,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.019219	fa		plx				plx 									; restore X
.01921a	a9 15		lda #$15			lda 	#Num_Buffer & $FF 				; set zGenPtr
.01921c	85 1e		sta $1e				sta 	zGenPtr
.01921e	a9 03		lda #$03			lda 	#Num_Buffer >> 8
.019220	85 1f		sta $1f				sta 	zGenPtr+1
.019222	5a		phy				phy 									; save Y
.019223	a0 00		ldy #$00			ldy 	#0 								; start position
.019225	20 6d a4	jsr $01a46d			jsr 	FPFromString 					; convert current
.019228	7a		ply				ply 									; restore Y
.019229	60		rts				rts
.01922a					NotInteger:
.01922a	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01922c	49 ff		eor #$ff			eor 	#$FF
.01922e	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019230	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019232	49 ff		eor #$ff			eor 	#$FF
.019234	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019236	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019238	49 ff		eor #$ff			eor 	#$FF
.01923a	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01923c	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01923e	49 ff		eor #$ff			eor 	#$FF
.019240	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019242	60		rts				rts
.019243					EvaluateGetAtom:
.019243	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.019245					EvaluateGetAtomX:
.019245	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.019247	20 d2 90	jsr $0190d2			jsr 	EvaluateExpressionXA
.01924a	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.01924c	29 0f		and #$0f			and 	#15
.01924e	c9 02		cmp #$02			cmp 	#2
.019250	b0 01		bcs $019253			bcs 	EvaluateType
.019252	60		rts				rts
.019253					EvaluateType:
.019253	4c 5a 85	jmp $01855a			jmp 	TypeError
.019256					EvaluateNumber:
.019256	a2 00		ldx #$00			ldx 	#0
.019258					EvaluateNumberX:
.019258	20 d0 90	jsr $0190d0			jsr 	EvaluateExpressionX
.01925b	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0/1
.01925d	29 0f		and #$0f			and 	#15
.01925f	c9 02		cmp #$02			cmp 	#2
.019261	b0 f0		bcs $019253			bcs 	EvaluateType
.019263	60		rts				rts
.019264					EvaluateInteger:
.019264	a2 00		ldx #$00			ldx 	#0
.019266					EvaluateIntegerX:
.019266	20 58 92	jsr $019258			jsr 	EvaluateNumberX
.019269	20 b3 a2	jsr $01a2b3			jsr 	FPUToInteger
.01926c	60		rts				rts
.01926d					EvaluateString:
.01926d	a2 00		ldx #$00			ldx 	#0
.01926f					EvaluateStringX:
.01926f	20 d0 90	jsr $0190d0			jsr 	EvaluateExpressionX
.019272	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 2
.019274	29 0f		and #$0f			and 	#15
.019276	c9 02		cmp #$02			cmp 	#2
.019278	d0 d9		bne $019253			bne 	EvaluateType
.01927a	b5 80		lda $80,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.01927c	85 1e		sta $1e				sta 	zGenPtr
.01927e	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019280	85 1f		sta $1f				sta 	zGenPtr+1
.019282	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.019283					BinaryOp_And:
.019283	20 d7 92	jsr $0192d7			jsr 	BinaryMakeBothInteger
.019286	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.019288	35 86		and $86,x			and 	XS2_Mantissa+0,x
.01928a	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01928c	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.01928e	35 87		and $87,x			and 	XS2_Mantissa+1,x
.019290	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019292	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.019294	35 88		and $88,x			and 	XS2_Mantissa+2,x
.019296	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019298	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.01929a	35 89		and $89,x			and 	XS2_Mantissa+3,x
.01929c	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01929e	60		rts				rts
.01929f					BinaryOp_Or:
.01929f	20 d7 92	jsr $0192d7			jsr 	BinaryMakeBothInteger
.0192a2	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.0192a4	15 86		ora $86,x			ora 	XS2_Mantissa+0,x
.0192a6	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0192a8	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.0192aa	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.0192ac	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0192ae	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.0192b0	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.0192b2	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0192b4	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.0192b6	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.0192b8	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0192ba	60		rts				rts
.0192bb					BinaryOp_Eor:
.0192bb					BinaryOp_Xor:
.0192bb	20 d7 92	jsr $0192d7			jsr 	BinaryMakeBothInteger
.0192be	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.0192c0	55 86		eor $86,x			eor 	XS2_Mantissa+0,x
.0192c2	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0192c4	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.0192c6	55 87		eor $87,x			eor 	XS2_Mantissa+1,x
.0192c8	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0192ca	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.0192cc	55 88		eor $88,x			eor 	XS2_Mantissa+2,x
.0192ce	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0192d0	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.0192d2	55 89		eor $89,x			eor 	XS2_Mantissa+3,x
.0192d4	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0192d6	60		rts				rts
.0192d7					BinaryMakeBothInteger:
.0192d7	da		phx				phx 								; save X
.0192d8	e8		inx				inx
.0192d9	e8		inx				inx
.0192da	e8		inx				inx
.0192db	e8		inx				inx
.0192dc	e8		inx				inx
.0192dd	e8		inx				inx
.0192de	20 e2 92	jsr $0192e2			jsr 	BinaryMakeInteger 			; convert to integer.
.0192e1	fa		plx				plx 								; restore X and fall through.
.0192e2					BinaryMakeInteger:
.0192e2	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.0192e4	29 0f		and #$0f			and 	#15 						; check type zero
.0192e6	f0 04		beq $0192ec			beq 	_BMIConvert 				; if float convert to integer.
.0192e8	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.0192e9	90 04		bcc $0192ef			bcc 	_BMIError
.0192eb	60		rts				rts
.0192ec					_BMIConvert:
.0192ec	4c b3 a2	jmp $01a2b3			jmp 	FPUToInteger 				; convert to integer
.0192ef					_BMIError:
.0192ef	4c 5a 85	jmp $01855a			jmp 	TypeError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.0192f2					Binary_Equal:
.0192f2	20 39 93	jsr $019339			jsr 	CompareValues
.0192f5	09 00		ora #$00			ora 	#0
.0192f7	f0 04		beq $0192fd			beq 	CCTrue
.0192f9	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.0192fb	80 02		bra $0192ff			bra 	CCWrite
.0192fd	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.0192ff	95 80		sta $80,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.019301	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019303	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019305	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019307	a9 01		lda #$01			lda 	#1
.019309	95 85		sta $85,x			sta 	XS_Type,x 					; set type to integer whatever.
.01930b	60		rts				rts
.01930c					Binary_NotEqual:
.01930c	20 39 93	jsr $019339			jsr 	CompareValues
.01930f	09 00		ora #$00			ora 	#0
.019311	f0 e6		beq $0192f9			beq 	CCFalse
.019313	80 e8		bra $0192fd			bra 	CCTrue
.019315					Binary_Less:
.019315	20 39 93	jsr $019339			jsr 	CompareValues
.019318	09 00		ora #$00			ora 	#0
.01931a	30 e1		bmi $0192fd			bmi 	CCTrue
.01931c	80 db		bra $0192f9			bra 	CCFalse
.01931e					Binary_LessEqual:
.01931e	20 39 93	jsr $019339			jsr 	CompareValues
.019321	c9 01		cmp #$01			cmp 	#1
.019323	d0 d8		bne $0192fd			bne 	CCTrue
.019325	80 d2		bra $0192f9			bra 	CCFalse
.019327					Binary_GreaterEqual:
.019327	20 39 93	jsr $019339			jsr 	CompareValues
.01932a	09 00		ora #$00			ora 	#0
.01932c	10 cf		bpl $0192fd			bpl 	CCTrue
.01932e	80 c9		bra $0192f9			bra 	CCFalse
.019330					Binary_Greater:
.019330	20 39 93	jsr $019339			jsr 	CompareValues
.019333	c9 01		cmp #$01			cmp 	#1
.019335	f0 c6		beq $0192fd			beq 	CCTrue
.019337	80 c0		bra $0192f9			bra 	CCFalse
.019339					CompareValues:
.019339	b5 85		lda $85,x			lda 	XS_Type,x 					; and the types together
.01933b	35 8b		and $8b,x			and 	XS2_Type,x
.01933d	c9 02		cmp #$02			cmp 	#2
.01933f	f0 11		beq $019352			beq 	_CVString
.019341	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.019343	35 8b		and $8b,x			and 	XS2_Type,x
.019345	4a		lsr a				lsr 	a 							; shift bit 0 into C
.019346	90 03		bcc $01934b			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.019348	4c 94 93	jmp $019394			jmp 	CompareInteger32 							; so execute code at \1
.01934b					_BCFloat:
.01934b	20 38 94	jsr $019438			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.01934e	4c ac a1	jmp $01a1ac			jmp 	FPCompare 							; and execute code at \2
.019351	60		rts				rts
.019352					_CVString:
.019352	da		phx				phx 								; save XY
.019353	5a		phy				phy
.019354	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.019356	85 1a		sta $1a				sta		zLTemp1+0
.019358	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01935a	85 1b		sta $1b				sta 	zLTemp1+1
.01935c	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.01935e	85 1c		sta $1c				sta 	zLTemp1+2
.019360	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.019362	85 1d		sta $1d				sta 	zLTemp1+3
.019364	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.019366	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.019368	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.01936a	90 02		bcc $01936e			bcc 	_CVCommon
.01936c	b1 1c		lda ($1c),y			lda 	(zLTemp1+2),y
.01936e					_CVCommon:
.01936e	aa		tax				tax 								; put shorter string length in zero.
.01936f	f0 0c		beq $01937d			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.019371					_CVCompare:
.019371	c8		iny				iny 								; next character
.019372	b1 1a		lda ($1a),y			lda 	(zLTemp1),y 				; compare characters
.019374	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.019376	90 13		bcc $01938b			bcc 	_CVReturnLess 				; <
.019378	d0 15		bne $01938f			bne 	_CVReturnGreater 			; >
.01937a	ca		dex				dex 								; until common length matched.
.01937b	d0 f4		bne $019371			bne 	_CVCompare
.01937d					_CVMatch:
.01937d	a0 00		ldy #$00			ldy 	#0
.01937f	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.019381	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.019383	90 06		bcc $01938b			bcc 	_CVReturnLess 				; <
.019385	d0 08		bne $01938f			bne 	_CVReturnGreater 			; >
.019387	a9 00		lda #$00			lda 	#0
.019389	80 06		bra $019391			bra 	_CVExit 					; same common, same length, same string
.01938b					_CVReturnLess:
.01938b	a9 ff		lda #$ff			lda 	#$FF
.01938d	80 02		bra $019391			bra 	_CVExit
.01938f					_CVReturnGreater:
.01938f	a9 01		lda #$01			lda 	#$01
.019391					_CVExit:
.019391	7a		ply				ply
.019392	fa		plx				plx
.019393	60		rts				rts
.019394					CompareInteger32:
.019394	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.019396	49 80		eor #$80			eor 	#$80
.019398	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01939a	b5 89		lda $89,x			lda 	XS2_Mantissa+3,x
.01939c	49 80		eor #$80			eor 	#$80
.01939e	95 89		sta $89,x			sta 	XS2_Mantissa+3,x
.0193a0	20 1e 94	jsr $01941e			jsr 	SubInteger32 				; subtraction
.0193a3	90 0d		bcc $0193b2			bcc 	_CI32Less 					; cc return -1
.0193a5	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check if zero
.0193a7	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.0193a9	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.0193ab	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.0193ad	f0 02		beq $0193b1			beq 	_CI32Exit
.0193af	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.0193b1					_CI32Exit:
.0193b1	60		rts				rts
.0193b2					_CI32Less:
.0193b2	a9 ff		lda #$ff			lda 	#$FF
.0193b4	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.0193b5					BinaryOp_Add:
.0193b5	b5 85		lda $85,x			lda 	XS_Type,x  					; and types together
.0193b7	35 8b		and $8b,x			and 	XS2_Type,x
.0193b9	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.0193bb	d0 11		bne $0193ce			bne 	_BOAString
.0193bd	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.0193bf	35 8b		and $8b,x			and 	XS2_Type,x
.0193c1	4a		lsr a				lsr 	a 							; shift bit 0 into C
.0193c2	90 03		bcc $0193c7			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.0193c4	4c 04 94	jmp $019404			jmp 	AddInteger32 							; so execute code at \1
.0193c7					_BCFloat:
.0193c7	20 38 94	jsr $019438			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.0193ca	4c 87 9f	jmp $019f87			jmp 	FPAdd 							; and execute code at \2
.0193cd	60		rts				rts
.0193ce					_BOAString:
.0193ce	4c 52 94	jmp $019452			jmp 	ConcatenateString 			; concatenate two strings.
.0193d1					BinaryOp_Subtract:
.0193d1	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.0193d3	35 8b		and $8b,x			and 	XS2_Type,x
.0193d5	4a		lsr a				lsr 	a 							; shift bit 0 into C
.0193d6	90 03		bcc $0193db			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.0193d8	4c 1e 94	jmp $01941e			jmp 	SubInteger32 							; so execute code at \1
.0193db					_BCFloat:
.0193db	20 38 94	jsr $019438			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.0193de	4c 7f 9f	jmp $019f7f			jmp 	FPSubtract 							; and execute code at \2
.0193e1	60		rts				rts
.0193e2					BinaryOp_Multiply:
.0193e2	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.0193e4	35 8b		and $8b,x			and 	XS2_Type,x
.0193e6	4a		lsr a				lsr 	a 							; shift bit 0 into C
.0193e7	90 03		bcc $0193ec			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.0193e9	4c 58 9d	jmp $019d58			jmp 	MulInteger32 							; so execute code at \1
.0193ec					_BCFloat:
.0193ec	20 38 94	jsr $019438			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.0193ef	4c ae a0	jmp $01a0ae			jmp 	FPMultiply 							; and execute code at \2
.0193f2	60		rts				rts
.0193f3					BinaryOp_Divide:
.0193f3	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.0193f5	35 8b		and $8b,x			and 	XS2_Type,x
.0193f7	4a		lsr a				lsr 	a 							; shift bit 0 into C
.0193f8	90 03		bcc $0193fd			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.0193fa	4c 96 9d	jmp $019d96			jmp 	DivInteger32 							; so execute code at \1
.0193fd					_BCFloat:
.0193fd	20 38 94	jsr $019438			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.019400	4c 3b a0	jmp $01a03b			jmp 	FPDivide 							; and execute code at \2
.019403	60		rts				rts
.019404					AddInteger32:
.019404	18		clc				clc
.019405	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019407	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.019409	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01940b	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01940d	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.01940f	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019411	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019413	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.019415	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019417	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019419	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.01941b	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01941d	60		rts				rts
.01941e					SubInteger32:
.01941e	38		sec				sec
.01941f	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019421	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.019423	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019425	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019427	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.019429	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01942b	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01942d	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.01942f	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019431	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019433	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.019435	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019437	60		rts				rts
.019438					BinaryMakeBothFloat:
.019438	da		phx				phx 								; save X
.019439	e8		inx				inx
.01943a	e8		inx				inx
.01943b	e8		inx				inx
.01943c	e8		inx				inx
.01943d	e8		inx				inx
.01943e	e8		inx				inx
.01943f	20 43 94	jsr $019443			jsr 	BinaryMakeFloat 			; convert to float.
.019442	fa		plx				plx 								; restore X and fall through.
.019443					BinaryMakeFloat:
.019443	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.019445	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.019446	b0 04		bcs $01944c			bcs 	_BMFConvert
.019448	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.019449	b0 04		bcs $01944f			bcs 	_BMFError
.01944b	60		rts				rts
.01944c					_BMFConvert:
.01944c	4c 67 a2	jmp $01a267			jmp 	FPUToFloat 					; convert to float
.01944f					_BMFError:
.01944f	4c 5a 85	jmp $01855a			jmp 	TypeError
.019452					ConcatenateString:
.019452	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.019454	85 1a		sta $1a				sta		zLTemp1+0
.019456	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019458	85 1b		sta $1b				sta 	zLTemp1+1
.01945a	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.01945c	85 1c		sta $1c				sta 	zLTemp1+2
.01945e	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.019460	85 1d		sta $1d				sta 	zLTemp1+3
.019462	5a		phy				phy
.019463	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.019465	b1 1a		lda ($1a),y			lda 	(zlTemp1),y
.019467	71 1c		adc ($1c),y			adc 	(zlTemp1+2),y
.019469	7a		ply				ply
.01946a	b0 33		bcs $01949f			bcs 	_CSError					; check in range.
.01946c	c9 fe		cmp #$fe			cmp 	#maxString+1
.01946e	b0 2f		bcs $01949f			bcs 	_CSError
.019470	20 f7 98	jsr $0198f7			jsr 	AllocateTempString 			; store the result
.019473	20 8a 94	jsr $01948a			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.019476	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.019478	85 1a		sta $1a				sta 	zLTemp1
.01947a	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.01947c	85 1b		sta $1b				sta 	zLTemp1+1
.01947e	20 8a 94	jsr $01948a			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.019481	a5 20		lda $20				lda 	zTempStr 					; point current to new string
.019483	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019485	a5 21		lda $21				lda 	zTempStr+1
.019487	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019489	60		rts				rts
.01948a					_CSCopyString:
.01948a	da		phx				phx
.01948b	5a		phy				phy
.01948c	a0 00		ldy #$00			ldy 	#0 							; get length
.01948e	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.019490	f0 0a		beq $01949c			beq 	_CSCSExit 					; if zero, exit
.019492	aa		tax				tax 								; put in X
.019493					_CSCSLoop:
.019493	c8		iny				iny 								; get next char
.019494	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.019496	20 22 99	jsr $019922			jsr		WriteTempString 			; copy out
.019499	ca		dex				dex 								; do whole string
.01949a	d0 f7		bne $019493			bne 	_CSCSLoop
.01949c					_CSCSExit:
.01949c	7a		ply				ply
.01949d	fa		plx				plx
.01949e	60		rts				rts
.01949f					_CSError:
.01949f	20 79 85	jsr $018579			jsr ERR_Handler
>0194a2	53 74 72 69 6e 67 20 74			.text "String too long",0
>0194aa	6f 6f 20 6c 6f 6e 67 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.0194b2					Unary_Sgn:
.0194b2	20 58 92	jsr $019258			jsr 	EvaluateNumberX 			; get value
.0194b5	20 aa 98	jsr $0198aa			jsr 	CheckNextRParen 			; check right bracket.
.0194b8	20 d6 94	jsr $0194d6			jsr 	GetSignCurrent 				; get sign.
.0194bb	09 00		ora #$00			ora 	#0
.0194bd	10 08		bpl $0194c7			bpl		UnarySetAInteger			; if 0,1 return that.
.0194bf	80 00		bra $0194c1			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.0194c1					UnarySetAMinus1:
.0194c1	a9 ff		lda #$ff			lda 	#$FF 						; put -1 in all four slots.
.0194c3	95 80		sta $80,x			sta 	XS_Mantissa,x
.0194c5	80 04		bra $0194cb			bra 	UnarySetAFill
.0194c7					UnarySetAInteger:
.0194c7	95 80		sta $80,x			sta 	XS_Mantissa,x
.0194c9	a9 00		lda #$00			lda 	#0
.0194cb					UnarySetAFill:
.0194cb	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0194cd	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0194cf	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0194d1	a9 01		lda #$01			lda 	#1 							; set type to integer.
.0194d3	95 85		sta $85,x			sta 	XS_Type,x
.0194d5	60		rts				rts
.0194d6					GetSignCurrent:
.0194d6	b5 85		lda $85,x			lda 	XS_Type,x 					; identify type.
.0194d8	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.0194d9	90 15		bcc $0194f0			bcc 	_GSCFloat 					; if clear do the float code.
.0194db	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; if msb of integer set, it's negative
.0194dd	30 0e		bmi $0194ed			bmi 	_GSCMinus1
.0194df	15 80		ora $80,x			ora 	XS_Mantissa+0,x
.0194e1	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.0194e3	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.0194e5	d0 03		bne $0194ea			bne 	_GSCPlus1 					; check if zero by oring all together.
.0194e7					_GSCZero:
.0194e7	a9 00		lda #$00			lda 	#0
.0194e9	60		rts				rts
.0194ea					_GSCPlus1:
.0194ea	a9 01		lda #$01			lda 	#$01
.0194ec	60		rts				rts
.0194ed					_GSCMinus1:
.0194ed	a9 ff		lda #$ff			lda 	#$FF
.0194ef	60		rts				rts
.0194f0					_GSCFloat:
.0194f0	34 85		bit $85,x			bit 	XS_Type,x 					; check bits
.0194f2	70 f3		bvs $0194e7			bvs 	_GSCZero 					; if zero flag set return zero
.0194f4	30 f7		bmi $0194ed			bmi 	_GSCMinus1 					; if sign set return -1
.0194f6	80 f2		bra $0194ea			bra 	_GSCPlus1		 			; else return +1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.0194f8					Unary_Abs:
.0194f8	20 58 92	jsr $019258			jsr 	EvaluateNumberX 			; get value
.0194fb	20 aa 98	jsr $0198aa			jsr 	CheckNextRParen 			; check right bracket.
.0194fe	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.019500	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.019502	f0 07		beq $01950b			beq 	_UAMinusFloat
.019504	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; check MSB of upper byte to see if negative
.019506	10 09		bpl $019511			bpl 	_UAExit
.019508	4c 1d 9e	jmp $019e1d			jmp 	IntegerNegateAlways 		; if so negate it.
.01950b					_UAMinusFloat:
.01950b	b5 85		lda $85,x			lda 	XS_Type,x 					; clear the sign bit.
.01950d	29 7f		and #$7f			and		#$7F
.01950f	95 85		sta $85,x			sta 	XS_Type,x
.019511					_UAExit:
.019511	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.019512					Unary_Peek:
.019512	a9 01		lda #$01			lda 	#1
.019514	80 06		bra $01951c			bra 	UPMain
.019516					Unary_Deek:
.019516	a9 02		lda #$02			lda 	#2
.019518	80 02		bra $01951c			bra 	UPMain
.01951a					Unary_Leek:
.01951a	a9 04		lda #$04			lda 	#4
.01951c					UPMain:
.01951c	48		pha				pha 								; set bytes to copy.
.01951d	20 66 92	jsr $019266			jsr 	EvaluateIntegerX 			; numeric parameter
.019520	20 aa 98	jsr $0198aa			jsr 	CheckNextRParen 			; right bracket.
.019523	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.019525	85 1a		sta $1a				sta 	zLTemp1
.019527	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019529	85 1b		sta $1b				sta 	zLTemp1+1
.01952b	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01952d	85 1c		sta $1c				sta 	zLTemp1+2
.01952f	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019531	85 1d		sta $1d				sta 	zLTemp1+3
.019533	a9 00		lda #$00			lda 	#0 							; clear target area
.019535	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019537	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019539	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01953b	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01953d	68		pla				pla 								; restore bytes to copy
.01953e	da		phx				phx 								; save XY
.01953f	5a		phy				phy
.019540	20 2c 98	jsr $01982c			jsr 	MemRead 					; read the bytes in
.019543	7a		ply				ply 								; restore and exit
.019544	fa		plx				plx
.019545	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/pos.asm

.019546					Unary_Pos:
.019546	20 58 92	jsr $019258			jsr 	EvaluateNumberX 			; get value
.019549	20 aa 98	jsr $0198aa			jsr 	CheckNextRParen 			; check right bracket.
.01954c	20 43 85	jsr $018543			jsr 	VIOCharGetPosition 			; get the position
.01954f	4c c7 94	jmp $0194c7			jmp		UnarySetAInteger			; if 0,1 return that.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.019552					Unary_Mod:
.019552	20 7a 95	jsr $01957a			jsr 	_UMParameter 				; first parameter
.019555	20 b2 98	jsr $0198b2			jsr 	CheckNextComma
.019558	da		phx				phx 								; second parameter
.019559	e8		inx				inx
.01955a	e8		inx				inx
.01955b	e8		inx				inx
.01955c	e8		inx				inx
.01955d	e8		inx				inx
.01955e	e8		inx				inx
.01955f	20 7a 95	jsr $01957a			jsr 	_UMParameter
.019562	fa		plx				plx
.019563	20 aa 98	jsr $0198aa			jsr 	CheckNextRParen
.019566	20 96 9d	jsr $019d96			jsr 	DivInteger32 				; divide
.019569	a5 1a		lda $1a				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.01956b	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01956d	a5 1b		lda $1b				lda 	zLTemp1+1
.01956f	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019571	a5 1c		lda $1c				lda 	zLTemp1+2
.019573	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019575	a5 1d		lda $1d				lda 	zLTemp1+3
.019577	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019579	60		rts				rts
.01957a					_UMParameter:
.01957a	20 66 92	jsr $019266			jsr 	EvaluateIntegerX 			; get value
.01957d	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; absolute value
.01957f	10 03		bpl $019584			bpl 	_UMNotSigned
.019581	20 1d 9e	jsr $019e1d			jsr 	IntegerNegateAlways
.019584					_UMNotSigned:
.019584	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.019585					Unary_Usr:
.019585	20 58 92	jsr $019258			jsr 	EvaluateNumberX 			; numeric parameter
.019588	20 aa 98	jsr $0198aa			jsr 	CheckNextRParen 			; right bracket.
.01958b	da		phx				phx 								; save XY
.01958c	5a		phy				phy
.01958d	ea		nop				nop
.01958e	22 0c 03 00	jsl $00030c			jsl 	UserVector
.019592	7a		ply				ply 								; and exit
.019593	fa		plx				plx
.019594	60		rts				rts
.019595					USRDefault:
.019595	20 79 85	jsr $018579			jsr ERR_Handler
>019598	4e 6f 20 55 53 52 20 76			.text "No USR vector.",0
>0195a0	65 63 74 6f 72 2e 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.0195a7					Unary_Val:
.0195a7	20 6f 92	jsr $01926f			jsr 	EvaluateStringX 			; get string
.0195aa	20 aa 98	jsr $0198aa			jsr 	CheckNextRParen 			; check right bracket.
.0195ad	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.0195af	85 1e		sta $1e				sta 	zGenPtr
.0195b1	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0195b3	85 1f		sta $1f				sta 	zGenPtr+1
.0195b5	5a		phy				phy
.0195b6	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.0195b8	b1 1e		lda ($1e),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.0195ba	f0 54		beq $019610			beq 	_UVBadNumber
.0195bc	48		pha				pha 								; save length.
.0195bd	1a		inc a				inc 	a 							; one for the length, one for the terminator
.0195be	1a		inc a				inc 	a
.0195bf	20 f7 98	jsr $0198f7			jsr 	AllocateTempString
.0195c2	c8		iny				iny 								; move to the next.
.0195c3	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get character
.0195c5	49 2d		eor #$2d			eor 	#"-"						; zero if minus sign
.0195c7	8d a0 03	sta $03a0			sta 	ValSign
.0195ca	d0 04		bne $0195d0			bne 	_UVNotMinus
.0195cc	c8		iny				iny 								; skip over it.
.0195cd	68		pla				pla 								; decrement character count.
.0195ce	3a		dec a				dec 	a
.0195cf	48		pha				pha
.0195d0					_UVNotMinus:
.0195d0	68		pla				pla 								; this is the count.
.0195d1	48		pha		_UVCopy:pha									; copy into new temp string which is ASCIIZ
.0195d2	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.0195d4	c8		iny				iny
.0195d5	20 22 99	jsr $019922			jsr 	WriteTempString
.0195d8	68		pla				pla
.0195d9	3a		dec a				dec 	a
.0195da	d0 f5		bne $0195d1			bne 	_UVCopy
.0195dc	20 22 99	jsr $019922			jsr 	WriteTempString 			; make it ASCIIZ
.0195df	18		clc				clc
.0195e0	a5 20		lda $20				lda 	zTempStr 					; tempstring +1 => genptr
.0195e2	69 01		adc #$01			adc 	#1
.0195e4	85 1e		sta $1e				sta 	zGenPtr
.0195e6	a5 21		lda $21				lda 	zTempStr+1
.0195e8	69 00		adc #$00			adc 	#0
.0195ea	85 1f		sta $1f				sta 	zGenPtr+1
.0195ec	18		clc				clc
.0195ed	20 ef 9e	jsr $019eef			jsr 	IntFromString 				; first bit.
.0195f0	b0 1e		bcs $019610			bcs 	_UVBadNumber
.0195f2	20 6d a4	jsr $01a46d			jsr 	FPFromString				; try for a float part.
.0195f5	ad a0 03	lda $03a0			lda 	ValSign 					; was it negative
.0195f8	d0 10		bne $01960a			bne 	_UVNotNegative
.0195fa	b5 85		lda $85,x			lda 	XS_Type,x 					; check if integer
.0195fc	4a		lsr a				lsr 	a
.0195fd	b0 08		bcs $019607			bcs 	_UVInteger
.0195ff	b5 85		lda $85,x			lda 	XS_Type,x 					; set sign bit
.019601	09 80		ora #$80			ora 	#$80
.019603	95 85		sta $85,x			sta 	XS_Type,x
.019605	80 03		bra $01960a			bra 	_UVNotNegative
.019607					_UVInteger:
.019607	20 1d 9e	jsr $019e1d			jsr 	IntegerNegateAlways 		; sign it.
.01960a					_UVNotNegative:
.01960a	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; used everything
.01960c	d0 02		bne $019610			bne 	_UVBadNumber
.01960e	7a		ply				ply
.01960f	60		rts				rts
.019610					_UVBadNumber:
.019610	4c 68 85	jmp $018568			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.019613					Unary_Str:
.019613	20 58 92	jsr $019258			jsr 	EvaluateNumberX 			; numeric parameter
.019616	20 aa 98	jsr $0198aa			jsr 	CheckNextRParen 			; right bracket.
.019619	a9 00		lda #$00			lda 	#0 							; reset buffer index
.01961b	8d 14 03	sta $0314			sta 	NumBufX
.01961e	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.019620	4a		lsr a				lsr 	a
.019621	b0 05		bcs $019628			bcs 	_USInt 						; if msb set do as integer
.019623	20 b2 a3	jsr $01a3b2			jsr 	FPToString 					; call fp to str otherwise
.019626	80 03		bra $01962b			bra 	_USDuplicate
.019628	20 3a 9e	jsr $019e3a	_USInt:	jsr 	IntToString
.01962b					_USDuplicate:
.01962b	ad 14 03	lda $0314			lda 	NumBufX 					; chars in buffer
.01962e	1a		inc a				inc 	a 							; one more for length
.01962f	20 f7 98	jsr $0198f7			jsr 	AllocateTempString 			; allocate space for it.
.019632	5a		phy				phy 								; save Y
.019633	a0 00		ldy #$00			ldy 	#0 							; start copying
.019635	b9 15 03	lda $0315,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.019638	20 22 99	jsr $019922			jsr 	WriteTempString
.01963b	c8		iny				iny
.01963c	cc 14 03	cpy $0314			cpy 	NumBufX 					; done the lot
.01963f	d0 f4		bne $019635			bne 	_USCopy
.019641	7a		ply				ply 								; restore Y
.019642	4c 1f 98	jmp $01981f			jmp 	UnaryReturnTempStr 			; return new temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.019645					Unary_Asc:
.019645	20 6f 92	jsr $01926f			jsr 	EvaluateStringX 			; string parameter
.019648	20 aa 98	jsr $0198aa			jsr 	CheckNextRParen 			; right bracket.
.01964b	5a		phy				phy 								; get the string length
.01964c	a0 00		ldy #$00			ldy 	#0
.01964e	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.019650	f0 07		beq $019659			beq 	_UAIllegal 					; must be at least one character, 0 => error
.019652	c8		iny				iny
.019653	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; read the first character
.019655	7a		ply				ply
.019656	4c c7 94	jmp $0194c7			jmp 	UnarySetAInteger 			; return that as an integer 0-255.
.019659					_UAIllegal:
.019659	4c 68 85	jmp $018568			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.01965c					Unary_Len:
.01965c	20 6f 92	jsr $01926f			jsr 	EvaluateStringX 			; string parameter
.01965f	20 aa 98	jsr $0198aa			jsr 	CheckNextRParen 			; right bracket.
.019662	5a		phy				phy 								; get the string length
.019663	a0 00		ldy #$00			ldy 	#0
.019665	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.019667	7a		ply				ply
.019668	4c c7 94	jmp $0194c7			jmp 	UnarySetAInteger 			; return as an integer.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.01966b					Unary_Mid:
.01966b	20 6f 92	jsr $01926f			jsr 	EvaluateStringX 				; get string.
.01966e	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.019670	48		pha				pha
.019671	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019673	48		pha				pha
.019674	20 b2 98	jsr $0198b2			jsr 	CheckNextComma 					; skip comma
.019677	20 00 97	jsr $019700			jsr 	SLIByteParameter 				; get a byte parameter (start)
.01967a	48		pha				pha 									; and push it.
.01967b	20 b2 98	jsr $0198b2			jsr 	CheckNextComma 					; skip comma
.01967e	20 00 97	jsr $019700			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.019681	48		pha				pha 									; and push it.
.019682	80 41		bra $0196c5			bra 	SLIProcess
.019684					Unary_Left:
.019684	20 6f 92	jsr $01926f			jsr 	EvaluateStringX 				; get string.
.019687	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.019689	48		pha				pha
.01968a	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01968c	48		pha				pha
.01968d	a9 01		lda #$01			lda 	#1 								; push start position (1)
.01968f	48		pha				pha
.019690	20 b2 98	jsr $0198b2			jsr 	CheckNextComma 					; skip comma
.019693	20 00 97	jsr $019700			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.019696	48		pha				pha 									; and push it.
.019697	80 2c		bra $0196c5			bra 	SLIProcess
.019699					Unary_Right:
.019699	20 6f 92	jsr $01926f			jsr 	EvaluateStringX 				; get string.
.01969c	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.01969e	48		pha				pha
.01969f	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0196a1	48		pha				pha
.0196a2	da		phx				phx 									; get the string length and push on stack.
.0196a3	a2 00		ldx #$00			ldx 	#0
.0196a5	a1 1e		lda ($1e,x)			lda		(zGenPtr,x)
.0196a7	fa		plx				plx
.0196a8	48		pha				pha
.0196a9	20 b2 98	jsr $0198b2			jsr 	CheckNextComma 					; skip comma
.0196ac	20 00 97	jsr $019700			jsr 	SLIByteParameter 				; get a byte parameter.
.0196af	8d 9e 03	sta $039e			sta 	SignCount 						; save in temporary.
.0196b2	68		pla				pla 									; restore string length.
.0196b3	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.0196b4	38		sec				sec
.0196b5	ed 9e 03	sbc $039e			sbc 	SignCount 						; subtract characters needed, gives start position.
.0196b8	f0 02		beq $0196bc			beq 	_URStart 						; if <= 0 start from 1.
.0196ba	10 02		bpl $0196be			bpl 	_UROkay
.0196bc					_URStart:
.0196bc	a9 01		lda #$01			lda 	#1
.0196be					_UROkay:
.0196be	48		pha				pha 									; push start
.0196bf	ad 9e 03	lda $039e			lda 	SignCount 						; push count of characters
.0196c2	48		pha				pha
.0196c3	80 00		bra $0196c5			bra 	SLIProcess
.0196c5					SLIProcess:
.0196c5	20 aa 98	jsr $0198aa			jsr 	CheckNextRParen 				; closing right bracket.
.0196c8	68		pla				pla
.0196c9	8d a2 03	sta $03a2			sta 	SliceCount 						; count in signcount
.0196cc	1a		inc a				inc 	a 								; allocate +1 for it.
.0196cd	20 f7 98	jsr $0198f7			jsr 	AllocateTempString
.0196d0	68		pla				pla 									; pop start number off stack.
.0196d1	f0 3b		beq $01970e			beq 	SLIError 						; exit if start = 0
.0196d3	8d a1 03	sta $03a1			sta 	SliceStart
.0196d6	68		pla				pla  									; pop string address.
.0196d7	85 1f		sta $1f				sta 	zGenPtr+1
.0196d9	68		pla				pla
.0196da	85 1e		sta $1e				sta 	zGenPtr
.0196dc	da		phx				phx
.0196dd	5a		phy				phy
.0196de	a2 00		ldx #$00			ldx 	#0 								; point to string length.
.0196e0	ac a1 03	ldy $03a1			ldy 	SliceStart 						; start of the string (+1 for count)
.0196e3					_SLICopy:
.0196e3	ad a2 03	lda $03a2			lda 	SliceCount 						; done count characters
.0196e6	f0 12		beq $0196fa			beq 	_SLIExit
.0196e8	ce a2 03	dec $03a2			dec 	SliceCount
.0196eb	98		tya				tya 									; index of character
.0196ec	c1 1e		cmp ($1e,x)			cmp 	(zGenPtr,x)						; compare against length
.0196ee	f0 02		beq $0196f2			beq 	_SLIOk 							; if equal, okay.
.0196f0	b0 08		bcs $0196fa			bcs 	_SLIExit 						; if past end, then exit.
.0196f2	b1 1e		lda ($1e),y	_SLIOk:	lda 	(zGenPtr),y 					; copy one character
.0196f4	c8		iny				iny
.0196f5	20 22 99	jsr $019922			jsr 	WriteTempString
.0196f8	80 e9		bra $0196e3			bra 	_SLICopy 						; go round till copied characters
.0196fa					_SLIExit:
.0196fa	7a		ply				ply 									; restore YX
.0196fb	fa		plx				plx
.0196fc	4c 1f 98	jmp $01981f			jmp 	UnaryReturnTempStr 				; return new temporary string.
.0196ff	ea		nop				nop
.019700					SLIByteParameter:
.019700	20 66 92	jsr $019266			jsr 	EvaluateIntegerX 				; get integer
.019703	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.019705	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019707	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019709	d0 03		bne $01970e			bne 	SLIError
.01970b	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01970d	60		rts				rts
.01970e					SLIError:
.01970e	4c 68 85	jmp $018568			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.019711					Unary_Hex:
.019711	20 66 92	jsr $019266			jsr 	EvaluateIntegerX 			; numeric parameter
.019714	20 aa 98	jsr $0198aa			jsr 	CheckNextRParen 			; right bracket.
.019717	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.019719	20 f7 98	jsr $0198f7			jsr 	AllocateTempString			; allocate string space
.01971c	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.01971e	20 42 97	jsr $019742			jsr 	_UHConvert
.019721	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019723	20 42 97	jsr $019742			jsr 	_UHConvert
.019726	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019728	20 42 97	jsr $019742			jsr 	_UHConvert
.01972b	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01972d	20 42 97	jsr $019742			jsr 	_UHConvert
.019730	5a		phy				phy 								; get length of new string
.019731	a0 00		ldy #$00			ldy 	#0
.019733	b1 20		lda ($20),y			lda 	(zTempStr),y
.019735	7a		ply				ply
.019736	c9 00		cmp #$00			cmp 	#0 							; if it was non zero okay
.019738	d0 05		bne $01973f			bne 	_UHExit 					; otherwise suppressed all leading zeros !
.01973a	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.01973c	20 22 99	jsr $019922			jsr 	WriteTempString
.01973f					_UHExit:
.01973f	4c 1f 98	jmp $01981f			jmp 	UnaryReturnTempStr 			; return new temporary string.
.019742					_UHConvert:
.019742	48		pha				pha
.019743	4a		lsr a				lsr 	a 							; do MSB
.019744	4a		lsr a				lsr 	a
.019745	4a		lsr a				lsr 	a
.019746	4a		lsr a				lsr 	a
.019747	20 4b 97	jsr $01974b			jsr 	_UHNibble
.01974a	68		pla				pla 								; do LSB
.01974b					_UHNibble:
.01974b	29 0f		and #$0f			and 	#15 						; get nibble
.01974d	d0 0c		bne $01975b			bne 	_UHNonZero 					; if not zero, write it out anyway.
.01974f	5a		phy				phy									; get the length
.019750	a0 00		ldy #$00			ldy 	#0
.019752	b1 20		lda ($20),y			lda 	(zTempStr),y
.019754	7a		ply				ply
.019755	c9 00		cmp #$00			cmp 	#0 							; length = 0 => suppress leading zeros.
.019757	f0 0d		beq $019766			beq 	_UHExit2
.019759	a9 00		lda #$00			lda 	#0 							; length > 0, so can't suppress any more.
.01975b					_UHNonZero:
.01975b	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.01975d	90 02		bcc $019761			bcc 	_UHDigit
.01975f	69 06		adc #$06			adc 	#7-1
.019761					_UHDigit:
.019761	69 30		adc #$30			adc 	#48
.019763	20 22 99	jsr $019922			jsr 	WriteTempString				; output to temp string.
.019766					_UHExit2:
.019766	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.019767					Unary_Dec:
.019767	20 6f 92	jsr $01926f			jsr 	EvaluateStringX 			; string parameter
.01976a	20 aa 98	jsr $0198aa			jsr 	CheckNextRParen 			; right bracket.
.01976d	5a		phy				phy
.01976e	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.019770	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.019772	f0 43		beq $0197b7			beq 	_UDFail 					; must fail if zero.
.019774	8d 9e 03	sta $039e			sta 	SignCount 					; use SignCount as a counter of chars to process.
.019777	a9 00		lda #$00			lda 	#0 							; set result to zero
.019779	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01977b	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01977d	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01977f	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019781	a9 01		lda #$01			lda 	#1 							; set type to integer.
.019783	95 85		sta $85,x			sta 	XS_Type,x
.019785					_UDConvertLoop:
.019785	5a		phy				phy 								; shift mantissa left 4
.019786	a0 04		ldy #$04			ldy 	#4
.019788					_UDShift:
.019788	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.01978a	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.01978c	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.01978e	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.019790	88		dey				dey
.019791	d0 f5		bne $019788			bne 	_UDShift
.019793	7a		ply				ply
.019794	c8		iny				iny 								; next character
.019795	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; fetch it.
.019797	20 ba 97	jsr $0197ba			jsr 	ConvertUpper 				; convert to U/C
.01979a	c9 30		cmp #$30			cmp 	#"0" 						; range 0-9
.01979c	90 19		bcc $0197b7			bcc 	_UDFail
.01979e	c9 3a		cmp #$3a			cmp 	#"9"+1
.0197a0	90 08		bcc $0197aa			bcc 	_UDOkay
.0197a2	e9 37		sbc #$37			sbc 	#7+"0" 						; A-F fudge
.0197a4	90 11		bcc $0197b7			bcc 	_UDFail 					; fails if between 9 and @
.0197a6	c9 10		cmp #$10			cmp 	#16 						; must be < 16 as hexadecimal.
.0197a8	b0 0d		bcs $0197b7			bcs 	_UDFail
.0197aa					_UDOkay:
.0197aa	29 0f		and #$0f			and 	#15 						; nibble only
.0197ac	15 80		ora $80,x			ora 	XS_Mantissa+0,x 			; OR into the bottom byte.
.0197ae	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0197b0	ce 9e 03	dec $039e			dec 	SignCount 					; do it for each character in the string.
.0197b3	d0 d0		bne $019785			bne 	_UDConvertLoop
.0197b5	7a		ply				ply
.0197b6	60		rts				rts
.0197b7					_UDFail:
.0197b7	4c 68 85	jmp $018568			jmp 	BadParamError
.0197ba					ConvertUpper:
.0197ba	c9 61		cmp #$61			cmp 	#"a"
.0197bc	90 07		bcc $0197c5			bcc 	_CUExit
.0197be	c9 7b		cmp #$7b			cmp 	#"z"+1
.0197c0	b0 03		bcs $0197c5			bcs 	_CUExit
.0197c2	38		sec				sec
.0197c3	e9 20		sbc #$20			sbc 	#32
.0197c5	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.0197c6					Unary_Chr:
.0197c6	20 66 92	jsr $019266			jsr 	EvaluateIntegerX			; numeric parameter which is the character we want
.0197c9	20 aa 98	jsr $0198aa			jsr 	CheckNextRParen 			; right bracket.
.0197cc	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.0197ce	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.0197d0	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.0197d2	d0 0d		bne $0197e1			bne 	_UCChar
.0197d4	a9 02		lda #$02			lda 	#1+1 						; one character string. 2 bytes - size+char
.0197d6	20 f7 98	jsr $0198f7			jsr 	AllocateTempString			; allocate it.
.0197d9	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.0197db	20 22 99	jsr $019922			jsr 	WriteTempString
.0197de	4c 1f 98	jmp $01981f			jmp 	UnaryReturnTempStr 			; and return that string.
.0197e1					_UCChar:
.0197e1	4c 68 85	jmp $018568			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.0197e4					Unary_Spc:
.0197e4	20 00 97	jsr $019700			jsr 	SLIByteParameter 			; check space.
.0197e7	20 aa 98	jsr $0198aa			jsr 	CheckNextRParen
.0197ea	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0197ec					UnarySpcCreate:
.0197ec	c9 fe		cmp #$fe			cmp 	#maxString+1
.0197ee	b0 14		bcs $019804			bcs 	_USSize
.0197f0	48		pha				pha 								; save length
.0197f1	1a		inc a				inc 	a 							; allocate one more.
.0197f2	20 f7 98	jsr $0198f7			jsr 	AllocateTempString
.0197f5	68		pla				pla 								; get length
.0197f6	f0 27		beq $01981f			beq 	UnaryReturnTempStr 			; return the current temp string
.0197f8					_USLoop:
.0197f8	48		pha				pha
.0197f9	a9 20		lda #$20			lda 	#" "
.0197fb	20 22 99	jsr $019922			jsr 	WriteTempString
.0197fe	68		pla				pla
.0197ff	3a		dec a				dec 	a
.019800	d0 f6		bne $0197f8			bne 	_USLoop
.019802	80 1b		bra $01981f			bra 	UnaryReturnTempStr
.019804					_USSize:
.019804	4c 68 85	jmp $018568			jmp 	BadParamError
.019807					Unary_Tab:
.019807	a2 00		ldx #$00			ldx 	#0 							; required TAB position.
.019809	20 00 97	jsr $019700			jsr 	SLIByteParameter
.01980c	20 aa 98	jsr $0198aa			jsr 	CheckNextRParen
.01980f	20 43 85	jsr $018543			jsr 	VIOCharGetPosition 			; were are we ?
.019812	85 10		sta $10				sta 	zTemp1
.019814	38		sec				sec
.019815	a5 80		lda $80				lda 	XS_Mantissa+0 				; return chars required.
.019817	e5 10		sbc $10				sbc 	zTemp1
.019819	b0 d1		bcs $0197ec			bcs 	UnarySpcCreate
.01981b	a9 00		lda #$00			lda 	#0
.01981d	80 cd		bra $0197ec			bra 	UnarySpcCreate
.01981f					UnaryReturnTempStr:
.01981f	a5 20		lda $20				lda 	zTempStr 					; copy temp string addr -> mantissa
.019821	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019823	a5 21		lda $21				lda 	zTempStr+1
.019825	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019827	a9 02		lda #$02			lda 	#2 							; set type to string
.019829	95 85		sta $85,x			sta 	XS_Type,x
.01982b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/65816.asm

.01982c					MemRead:
.01982c	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.01982f	a0 00		ldy #$00			ldy 	#0 							; start from here
.019831	b7 1a		lda [$1a],y	_MLoop1:lda 	[zlTemp1],y 				; read the long address
.019833	95 80		sta $80,x			sta 	XS_Mantissa,x 				; copy into mantissa
.019835	c8		iny				iny 								; next to copy
.019836	e8		inx				inx
.019837	cc 9e 03	cpy $039e			cpy 	SignCount 					; do required # of bytes.
.01983a	d0 f5		bne $019831			bne 	_MLoop1
.01983c	60		rts				rts
.01983d					MemWrite:
.01983d	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.019840	a0 00		ldy #$00			ldy 	#0 							; start from here
.019842	b5 80		lda $80,x	_MLoop1:lda 	XS_Mantissa,x 				; read mantisssa
.019844	97 1a		sta [$1a],y			sta 	[zlTemp1],y 				; write it out
.019846	c8		iny				iny 								; next to copy
.019847	e8		inx				inx
.019848	cc 9e 03	cpy $039e			cpy 	SignCount 					; do required # of bytes.
.01984b	d0 f5		bne $019842			bne 	_MLoop1
.01984d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/programend.asm

.01984e					UpdateProgramEnd:
.01984e	a9 00		lda #$00			lda 	#BasicProgram & $FF
.019850	85 16		sta $16				sta 	zCodePtr+0
.019852	a9 10		lda #$10			lda 	#BasicProgram >> 8
.019854	85 17		sta $17				sta 	zCodePtr+1
.019856	a9 00		lda #$00			lda 	#0
.019858	85 18		sta $18				sta 	zCodePtr+2
.01985a	85 19		sta $19				sta 	zCodePtr+3
.01985c	a0 03		ldy #$03			ldy 	#3
.01985e					_UPDLoop:
.01985e	a0 00		ldy #$00			ldy 	#0
.019860	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019862	c9 00		cmp #$00			cmp 	#0 							; end if offset is zero.
.019864	f0 0f		beq $019875			beq 	_UPDFoundEnd
.019866	a0 00		ldy #$00			ldy 	#0 							; point to offset
.019868	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.01986a	18		clc				clc
.01986b	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.01986d	85 16		sta $16				sta 	zCodePtr
.01986f	90 02		bcc $019873			bcc 	_SNLNoCarry
.019871	e6 17		inc $17				inc 	zCodePtr+1
.019873					_SNLNoCarry:
.019873	80 e9		bra $01985e			bra 	_UPDLoop
.019875					_UPDFoundEnd:
.019875	18		clc				clc 								; end of program 2 on.
.019876	a5 16		lda $16				lda 	zCodePtr
.019878	69 02		adc #$02			adc 	#2
.01987a	8d 04 03	sta $0304			sta 	endOfProgram
.01987d	a5 17		lda $17				lda 	zCodePtr+1
.01987f	69 00		adc #$00			adc 	#0
.019881	8d 05 03	sta $0305			sta 	endOfProgram+1
.019884	a5 18		lda $18				lda 	zCodePtr+2
.019886	69 00		adc #$00			adc		#0
.019888	8d 06 03	sta $0306			sta 	endOfProgram+2
.01988b	a5 19		lda $19				lda 	zCodePtr+3
.01988d	69 00		adc #$00			adc 	#0
.01988f	8d 07 03	sta $0307			sta 	endOfProgram+3
.019892	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.019893					CheckNextToken:
.019893	d7 16		cmp [$16],y			cmp 	[zCodePtr],y
.019895	d0 02		bne $019899			bne 	CTFail 						; no, then fail
.019897	c8		iny				iny
.019898	60		rts				rts
.019899					CTFail:
.019899	20 79 85	jsr $018579			jsr ERR_Handler
>01989c	4d 69 73 73 69 6e 67 20			.text "Missing token",0
>0198a4	74 6f 6b 65 6e 00
.0198aa					CheckNextRParen:
.0198aa	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0198ac	c9 be		cmp #$be			cmp 	#token_rparen
.0198ae	d0 e9		bne $019899			bne 	CTFail
.0198b0	c8		iny				iny
.0198b1	60		rts				rts
.0198b2					CheckNextComma:
.0198b2	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0198b4	c9 bf		cmp #$bf			cmp 	#token_comma
.0198b6	d0 e1		bne $019899			bne 	CTFail
.0198b8	c8		iny				iny
.0198b9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/concrete.asm

.0198ba					StringConcrete:
.0198ba	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; save source to zTemp1
.0198bc	85 10		sta $10				sta 	zTemp1
.0198be	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0198c0	85 11		sta $11				sta 	zTemp1+1
.0198c2	a0 00		ldy #$00			ldy 	#0 							; empty string, return default empty
.0198c4	b1 10		lda ($10),y			lda 	(zTemp1),y
.0198c6	f0 26		beq $0198ee			beq		_SCEmpty
.0198c8	18		clc				clc 								; from the string pointer
.0198c9	ad 00 03	lda $0300			lda 	StringPtr 					; and put in zTemp2 as well
.0198cc	f1 10		sbc ($10),y			sbc 	(zTemp1),y
.0198ce	8d 00 03	sta $0300			sta 	StringPtr
.0198d1	85 12		sta $12				sta 	zTemp2
.0198d3	ad 01 03	lda $0301			lda 	StringPtr+1
.0198d6	e9 00		sbc #$00			sbc 	#0
.0198d8	8d 01 03	sta $0301			sta 	StringPtr+1
.0198db	85 13		sta $13				sta 	zTemp2+1
.0198dd	b1 10		lda ($10),y			lda 	(zTemp1),y 					; length add one for count
.0198df	1a		inc a				inc 	a
.0198e0	aa		tax				tax
.0198e1	b1 10		lda ($10),y	_SCCopy:lda 	(zTemp1),y 					; copy whole thing including length
.0198e3	91 12		sta ($12),y			sta 	(zTemp2),y
.0198e5	c8		iny				iny
.0198e6	ca		dex				dex
.0198e7	d0 f8		bne $0198e1			bne 	_SCCopy
.0198e9	a5 13		lda $13				lda 	zTemp2+1 					; return concrete string in AX
.0198eb	a6 12		ldx $12				ldx 	zTemp2
.0198ed	60		rts				rts
.0198ee					_SCEmpty:
.0198ee	a9 00		lda #$00			lda 	#0
.0198f0	85 25		sta $25				sta 	zNullString
.0198f2	a9 00		lda #$00			lda 	#zNullString >> 8
.0198f4	a2 25		ldx #$25			ldx 	#zNulLString & $FF
.0198f6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.0198f7					AllocateTempString:
.0198f7	48		pha				pha 								; save required count.
.0198f8	a5 21		lda $21				lda 	zTempStr+1 					; check if initialised yet ?
.0198fa	d0 0b		bne $019907			bne 	_ATSInitialised
.0198fc	ad 00 03	lda $0300			lda 	StringPtr 					; set temporary string ptr 1 page below available
.0198ff	85 20		sta $20				sta 	zTempStr					; space, this is for strings to be concreted.
.019901	ad 01 03	lda $0301			lda 	StringPtr+1
.019904	3a		dec a				dec 	a
.019905	85 21		sta $21				sta 	zTempStr+1
.019907					_ATSInitialised:
.019907	68		pla				pla 								; get required count back.
.019908	49 ff		eor #$ff			eor 	#$FF 						; negate 2's complement.
.01990a	1a		inc a				inc 	a
.01990b	18		clc				clc
.01990c	65 20		adc $20				adc 	zTempStr 					; "add" to the temp string pointer
.01990e	85 20		sta $20				sta 	zTempStr
.019910	a9 ff		lda #$ff			lda 	#$FF
.019912	65 21		adc $21				adc 	zTempStr+1
.019914	85 21		sta $21				sta 	zTempStr+1
.019916	a9 00		lda #$00			lda 	#0 							; clear temp string.
.019918	5a		phy				phy
.019919	a8		tay				tay
.01991a	91 20		sta ($20),y			sta 	(zTempStr),y
.01991c	7a		ply				ply
.01991d	1a		inc a				inc 	a 							; reset the write index.
.01991e	8d 9f 03	sta $039f			sta 	TempStringWriteIndex
.019921	60		rts				rts
.019922					WriteTempString:
.019922	5a		phy				phy 								; save Y
.019923	ac 9f 03	ldy $039f			ldy 	TempStringWriteIndex	 	; write position.
.019926	91 20		sta ($20),y			sta 	(zTempStr),y 				; write character out.
.019928	ee 9f 03	inc $039f			inc 	TempStringWriteIndex 		; increment the write position.
.01992b	98		tya				tya 								; unchanged Y is now length
.01992c	a0 00		ldy #$00			ldy 	#0
.01992e	91 20		sta ($20),y			sta 	(zTempStr),y
.019930	7a		ply				ply 								; restore Y and exit
.019931	60		rts				rts
.019932					CreateTempStringCopy:
.019932	da		phx				phx 								; save X
.019933	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019935	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.019936	20 f7 98	jsr $0198f7			jsr 	AllocateTempString 			; allocate memory for temporary string.
.019939	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01993b	c8		iny				iny
.01993c	3a		dec a				dec 	a 							; make the actual length in charactes
.01993d	3a		dec a				dec 	a
.01993e	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.019940	81 20		sta ($20,x)			sta 	(zTempStr,x)
.019942	85 1a		sta $1a				sta 	zLTemp1 					; that's used as a count.
.019944	09 00		ora #$00			ora 	#0 							; if zero already, exit
.019946	f0 0e		beq $019956			beq 	_CTSCExit
.019948					_CTSCLoop:
.019948	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01994a	c8		iny				iny
.01994b	5a		phy				phy 								; save in Y
.01994c	e8		inx				inx 								; bump index
.01994d	da		phx				phx 								; index into Y
.01994e	7a		ply				ply
.01994f	91 20		sta ($20),y			sta 	(zTempStr),y 				; save at index
.019951	7a		ply				ply 								; restore Y
.019952	c6 1a		dec $1a				dec 	zLTemp1 					; do for each character
.019954	d0 f2		bne $019948			bne 	_CTSCLoop
.019956					_CTSCExit:
.019956	fa		plx				plx 								; restore X
.019957	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/variables.asm

.019958					VariableFind:
.019958	20 c3 99	jsr $0199c3			jsr 	VariableExtract 		; find out all about it ....
.01995b	20 5c 9c	jsr $019c5c			jsr 	VariableLocate 			; does it already exist ?
.01995e	b0 03		bcs $019963			bcs 	_VFExists 				; if so, use that.
.019960	20 4f 9a	jsr $019a4f			jsr 	VariableCreate 			; otherwise create it.
.019963					_VFExists:
.019963	a5 24		lda $24				lda 	zVarType 				; is it still an array ?
.019965	29 01		and #$01			and 	#1
.019967	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.019969	d0 28		bne $019993			bne 	_VFSingleElement
.01996b					_VFNextIndex:
.01996b	a5 22		lda $22				lda 	zVarDataPtr 			; push the data ptr and type on the stack.
.01996d	48		pha				pha
.01996e	a5 23		lda $23				lda 	zVarDataPtr+1
.019970	48		pha				pha
.019971	a5 24		lda $24				lda 	zVarType
.019973	48		pha				pha
.019974	20 66 92	jsr $019266			jsr 	EvaluateIntegerX 		; calculate the index.
.019977	68		pla				pla 							; restore and index.
.019978	85 24		sta $24				sta 	zVarType
.01997a	68		pla				pla
.01997b	85 23		sta $23				sta 	zVarDataPtr+1
.01997d	68		pla				pla
.01997e	85 22		sta $22				sta 	zVarDataPtr
.019980	20 da 9a	jsr $019ada			jsr 	ArrayIndexFollow 		; do the index.
.019983	a5 24		lda $24				lda 	zVarType 				; is it still an array ??
.019985	29 01		and #$01			and 	#1
.019987	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.019989	d0 05		bne $019990			bne 	_VFArrayDone 			; if so then exit.
.01998b	20 b2 98	jsr $0198b2			jsr 	CheckNextComma 			; comma should follow
.01998e	80 db		bra $01996b			bra 	_VFNextIndex
.019990					_VFArrayDone:
.019990	20 aa 98	jsr $0198aa			jsr 	CheckNextRParen 		; check closing right bracket.
.019993					_VFSingleElement:
.019993	60		rts				rts
.019994					VariableClear:
.019994	48		pha				pha 							; save registers
.019995	da		phx				phx
.019996	a2 00		ldx #$00			ldx 	#0 						; clear out the hash table.
.019998	8a		txa				txa
.019999	9d 35 03	sta $0335,x	_VCLoop:sta 	HashTableBase,x
.01999c	e8		inx				inx
.01999d	e0 60		cpx #$60			cpx 	#HashTableEnd-HashTableBase
.01999f	d0 f8		bne $019999			bne 	_VCLoop
.0199a1	a9 00		lda #$00			lda 	#VariableMemory & $FF
.0199a3	8d 02 03	sta $0302			sta 	VarMemPtr
.0199a6	a9 30		lda #$30			lda 	#VariableMemory >> 8
.0199a8	8d 03 03	sta $0303			sta 	VarMemPtr+1
.0199ab	fa		plx				plx 							; restore registers
.0199ac	68		pla				pla
.0199ad	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/extract.asm

.0199ae					VariableNameError:
.0199ae	20 79 85	jsr $018579			jsr ERR_Handler
>0199b1	42 61 64 20 56 61 72 69			.text "Bad Variable Name",0
>0199b9	61 62 6c 65 20 4e 61 6d 65 00
.0199c3					VariableExtract:
.0199c3	da		phx				phx 							; save X.
.0199c4	a9 ba		lda #$ba			lda 	#token_hashlParen  		; set the type to #( e.g. real array.
.0199c6	8d 95 03	sta $0395			sta 	Var_Type
.0199c9	8d 96 03	sta $0396			sta 	Var_Hash 				; we initialise the hash with this. It doesn't matter
.0199cc	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0199ce	c9 00		cmp #$00			cmp 	#0 						; first one must be A-Z
.0199d0	f0 dc		beq $0199ae			beq 	VariableNameError
.0199d2	c9 1b		cmp #$1b			cmp 	#26+1
.0199d4	b0 d8		bcs $0199ae			bcs 	VariableNameError
.0199d6	a2 ff		ldx #$ff			ldx 	#255 					; now copy it into the variable buffer.
.0199d8					_VECopyBuffer:
.0199d8	e8		inx				inx
.0199d9	e0 1f		cpx #$1f			cpx 	#31 					; too long
.0199db	f0 d1		beq $0199ae			beq 	VariableNameError
.0199dd	9d 15 03	sta $0315,x			sta 	Var_Buffer,x 			; save character
.0199e0	18		clc				clc  							; update the hash value for it.
.0199e1	6d 96 03	adc $0396			adc 	Var_Hash
.0199e4	8d 96 03	sta $0396			sta 	Var_Hash
.0199e7	c8		iny				iny
.0199e8	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0199ea	c9 00		cmp #$00			cmp 	#0 						; zero or token, end of variable
.0199ec	f0 0e		beq $0199fc			beq 	_VECopyEnd
.0199ee	30 0c		bmi $0199fc			bmi 	_VECopyEnd
.0199f0	c9 1b		cmp #$1b			cmp 	#26+1 					; A-Z continue copying
.0199f2	90 e4		bcc $0199d8			bcc 	_VECopyBuffer
.0199f4	c9 30		cmp #$30			cmp 	#"0" 					; 0-9 copy as well.
.0199f6	90 04		bcc $0199fc			bcc 	_VECopyEnd
.0199f8	c9 3a		cmp #$3a			cmp 	#"9"+1
.0199fa	90 dc		bcc $0199d8			bcc 	_VECopyBuffer
.0199fc					_VECopyEnd:
.0199fc	c8		iny				iny
.0199fd	c9 b7		cmp #$b7			cmp 	#token_Dollar 			; first type token.
.0199ff	90 04		bcc $019a05			bcc 	_VEDefaultRequired
.019a01	c9 bd		cmp #$bd			cmp 	#token_PercentLParen+1	; last type token.
.019a03	90 0b		bcc $019a10			bcc 	_VEHaveType
.019a05					_VEDefaultRequired:
.019a05	c9 bd		cmp #$bd			cmp 	#token_LParen 			; if it ends in ( then use the real array
.019a07	f0 04		beq $019a0d			beq 	_VESetType 				; default set above.
.019a09	ce 95 03	dec $0395			dec 	Var_Type 				; this changes that default to the variable default
.019a0c	88		dey				dey
.019a0d					_VESetType:
.019a0d	ad 95 03	lda $0395			lda 	Var_Type 				; get type ....
.019a10					_VEHaveType:
.019a10	8d 95 03	sta $0395			sta 	Var_Type 				; save as type.
.019a13	bd 15 03	lda $0315,x			lda 	Var_Buffer,x 			; set bit 7 of name, marks the end.
.019a16	09 80		ora #$80			ora 	#$80
.019a18	9d 15 03	sta $0315,x			sta 	Var_Buffer,x
.019a1b	e8		inx				inx 							; offset 3 => length 4.
.019a1c	8e 97 03	stx $0397			stx 	Var_Length 				; save length of variable name.
.019a1f	ad 95 03	lda $0395			lda 	Var_Type 				; get offset of var type from first type token
.019a22	38		sec				sec
.019a23	e9 b7		sbc #$b7			sbc 	#token_Dollar
.019a25	0a		asl a				asl 	a 						; multiply by 16. This requires HashTableSize
.019a26	0a		asl a				asl 	a 						; in data.asm to be 8 (8 sets of links,2 bytes each)
.019a27	0a		asl a				asl 	a
.019a28	0a		asl a				asl 	a
.019a29	8d 98 03	sta $0398			sta 	Var_HashAddress
.019a2c	ad 96 03	lda $0396			lda 	Var_Hash 				; get the hash
.019a2f	29 07		and #$07			and 	#(HashTableSize-1) 		; force into range 0-tableSize-1
.019a31	0a		asl a				asl 	a 						; double it (2 bytes per entry) & clears carry
.019a32	6d 98 03	adc $0398			adc 	Var_HashAddress 		; add table offset.
.019a35	69 35		adc #$35			adc 	#HashTableBase & $FF 	; now the low byte of the actual table address
.019a37	8d 98 03	sta $0398			sta 	Var_HashAddress
.019a3a	a2 05		ldx #$05			ldx 	#5 						; hash is 5 bytes (real)
.019a3c	ad 95 03	lda $0395			lda 	Var_Type
.019a3f	c9 b9		cmp #$b9			cmp 	#token_Hash
.019a41	f0 07		beq $019a4a			beq 	_VEHaveSize
.019a43	ca		dex				dex
.019a44	c9 bb		cmp #$bb			cmp 	#token_Percent 			; percent is 4 bytes (integer)
.019a46	f0 02		beq $019a4a			beq 	_VEHaveSize
.019a48	a2 02		ldx #$02			ldx 	#2 						; everything else is two.
.019a4a					_VEHaveSize:
.019a4a	8e 99 03	stx $0399			stx 	Var_DataSize
.019a4d	fa		plx				plx
.019a4e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varcreate.asm

.019a4f					VariableCreate:
.019a4f	da		phx				phx
.019a50	5a		phy				phy
.019a51	ad 02 03	lda $0302			lda 	VarMemPtr 					; get address of next free into zTemp1
.019a54	85 10		sta $10				sta 	zTemp1
.019a56	ad 03 03	lda $0303			lda 	VarMemPtr+1
.019a59	85 11		sta $11				sta 	zTemp1+1
.019a5b	ad 99 03	lda $0399			lda 	Var_DataSize 				; bytes for the data bit
.019a5e	18		clc				clc
.019a5f	6d 97 03	adc $0397			adc 	Var_Length 					; add the length of the name
.019a62	69 03		adc #$03			adc 	#3 							; 3 for the link and the hash.
.019a64	6d 02 03	adc $0302			adc 	VarMemPtr 					; add to variable memory pointer
.019a67	8d 02 03	sta $0302			sta 	VarMemPtr
.019a6a	90 03		bcc $019a6f			bcc 	_VCNoCarry
.019a6c	ee 03 03	inc $0303			inc 	VarMemPtr+1
.019a6f					_VCNoCarry:
.019a6f	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.019a72	85 12		sta $12				sta 	zTemp2
.019a74	a9 03		lda #$03			lda 	#HashTableBase >> 8
.019a76	85 13		sta $13				sta 	zTemp2+1
.019a78	a0 00		ldy #$00			ldy 	#0 							; put current hash link in position.
.019a7a	b1 12		lda ($12),y			lda 	(zTemp2),y
.019a7c	91 10		sta ($10),y			sta 	(zTemp1),y
.019a7e	c8		iny				iny
.019a7f	b1 12		lda ($12),y			lda 	(zTemp2),y
.019a81	91 10		sta ($10),y			sta 	(zTemp1),y
.019a83	c8		iny				iny
.019a84	ad 96 03	lda $0396			lda 	Var_Hash 					; write the hash out.
.019a87	91 10		sta ($10),y			sta 	(zTemp1),y
.019a89	c8		iny				iny
.019a8a	a2 00		ldx #$00			ldx 	#0 							; copy the name out.
.019a8c					_VCCopyName:
.019a8c	bd 15 03	lda $0315,x			lda 	Var_Buffer,x
.019a8f	91 10		sta ($10),y			sta 	(zTemp1),y
.019a91	e8		inx				inx
.019a92	c8		iny				iny
.019a93	ec 97 03	cpx $0397			cpx 	Var_Length
.019a96	d0 f4		bne $019a8c			bne 	_VCCopyName
.019a98	5a		phy				phy 								; save the data offset.
.019a99	ae 99 03	ldx $0399			ldx 	Var_DataSize 				; and write the data out.
.019a9c	a9 00		lda #$00			lda 	#0 							; which is all zeroes.
.019a9e					_VCClearData:
.019a9e	91 10		sta ($10),y			sta 	(zTemp1),y
.019aa0	c8		iny				iny
.019aa1	ca		dex				dex
.019aa2	d0 fa		bne $019a9e			bne 	_VCClearData
.019aa4	68		pla				pla 								; offset to the data
.019aa5	18		clc				clc
.019aa6	65 10		adc $10				adc 	zTemp1 						; add to start and save as data pointer.
.019aa8	85 22		sta $22				sta 	zVarDataPtr
.019aaa	a5 11		lda $11				lda 	zTemp1+1
.019aac	69 00		adc #$00			adc 	#0
.019aae	85 23		sta $23				sta 	zVarDataPtr+1
.019ab0	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.019ab3	85 24		sta $24				sta 	zVarType
.019ab5	a5 10		lda $10				lda 	zTemp1 						; fix hash link to point to new record
.019ab7	a0 00		ldy #$00			ldy 	#0
.019ab9	91 12		sta ($12),y			sta 	(zTemp2),y
.019abb	c8		iny				iny
.019abc	a5 11		lda $11				lda 	zTemp1+1
.019abe	91 12		sta ($12),y			sta 	(zTemp2),y
.019ac0	ad 95 03	lda $0395			lda 	Var_Type 					; array ? if so create the empty one.
.019ac3	29 01		and #$01			and 	#1
.019ac5	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.019ac7	d0 0e		bne $019ad7			bne 	_VCNotArray
.019ac9	a2 00		ldx #$00			ldx 	#0 							; call recursive array creator
.019acb	20 71 9b	jsr $019b71			jsr 	ArrayCreate
.019ace	5a		phy				phy 								; save YA at zVarDataPtr
.019acf	a0 00		ldy #$00			ldy 	#0
.019ad1	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019ad3	c8		iny				iny
.019ad4	68		pla				pla
.019ad5	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019ad7					_VCNotArray:
.019ad7	7a		ply				ply
.019ad8	fa		plx				plx
.019ad9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arrayidx.asm

.019ada					ArrayIndexFollow:
.019ada	5a		phy				phy
.019adb	a0 00		ldy #$00			ldy 	#0 							; make zVarDataPtr point to the array.
.019add	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; e.g. it points to itself.
.019adf	48		pha				pha
.019ae0	c8		iny				iny
.019ae1	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019ae3	85 23		sta $23				sta 	zVarDataPtr+1
.019ae5	68		pla				pla
.019ae6	85 22		sta $22				sta 	zVarDataPtr
.019ae8	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; MSB of 16 bit integer and bytes 2&3
.019aea	29 80		and #$80			and 	#$80 						; must be zero.
.019aec	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019aee	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019af0	d0 59		bne $019b4b			bne 	_AIFError
.019af2	a0 00		ldy #$00			ldy 	#0 							; calculate size - current - 1
.019af4	18		clc				clc
.019af5	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019af7	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.019af9	c8		iny				iny
.019afa	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019afc	08		php				php 								; clear bit 7 retaining borrow.
.019afd	29 7f		and #$7f			and 	#$7F
.019aff	28		plp				plp
.019b00	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.019b02	90 47		bcc $019b4b			bcc 	_AIFError 					; eror if size-current < 0
.019b04	b5 80		lda $80,x			lda  	XS_Mantissa+0,x 			; copy and double the index
.019b06	0a		asl a				asl 	a 							; (e.g. index * 2)
.019b07	85 10		sta $10				sta 	zTemp1
.019b09	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019b0b	2a		rol a				rol 	a
.019b0c	85 11		sta $11				sta 	zTemp1+1
.019b0e	a0 01		ldy #$01			ldy 	#1 							; is this a data entry.
.019b10	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; if so, then type is unchanged, offset set
.019b12	30 1d		bmi $019b31			bmi 	_AIFCalculate
.019b14	c6 24		dec $24				dec 	zVarType 					; converts from an array to a type.
.019b16	a5 24		lda $24				lda 	zVarType 					; check that type
.019b18	c9 b7		cmp #$b7			cmp 	#token_Dollar 				; if string, use x 2
.019b1a	f0 15		beq $019b31			beq 	_AIFCalculate
.019b1c	06 10		asl $10				asl 	zTemp1			 			; double the index
.019b1e	26 11		rol $11				rol 	zTemp1+1					; (e.g. index * 4)
.019b20	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if integer, use x 4
.019b22	f0 0d		beq $019b31			beq 	_AIFCalculate
.019b24	18		clc				clc 								; add the original mantissa in again
.019b25	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; which makes it x5, for float.
.019b27	65 10		adc $10				adc 	zTemp1
.019b29	85 10		sta $10				sta 	zTemp1
.019b2b	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019b2d	65 11		adc $11				adc 	zTemp1+1
.019b2f	85 11		sta $11				sta 	zTemp1+1
.019b31					_AIFCalculate:
.019b31	18		clc				clc 								; add index x 2,4 or 5 to base
.019b32	a5 22		lda $22				lda 	zVarDataPtr
.019b34	65 10		adc $10				adc 	zTemp1
.019b36	85 22		sta $22				sta 	zVarDataPtr
.019b38	a5 23		lda $23				lda 	zVarDataPtr+1
.019b3a	65 11		adc $11				adc 	zTemp1+1
.019b3c	85 23		sta $23				sta 	zVarDataPtr+1
.019b3e	18		clc				clc 								; add 2 more for the length prefix.
.019b3f	a5 22		lda $22				lda 	zVarDataPtr
.019b41	69 02		adc #$02			adc 	#2
.019b43	85 22		sta $22				sta 	zVarDataPtr
.019b45	90 02		bcc $019b49			bcc 	_AIFNoBump
.019b47	e6 23		inc $23				inc 	zVarDataPtr+1
.019b49					_AIFNoBump:
.019b49	7a		ply				ply
.019b4a	60		rts				rts
.019b4b					_AIFError:
.019b4b	20 79 85	jsr $018579			jsr ERR_Handler
>019b4e	42 61 64 20 61 72 72 61			.text "Bad array index",0
>019b56	79 20 69 6e 64 65 78 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arraydef.asm

.019b5e					ArrayResetDefault:
.019b5e	a9 0b		lda #$0b			lda 	#11 						; 0..10 one array
.019b60	8d a9 03	sta $03a9			sta 	ArrayDef+0
.019b63	a9 00		lda #$00			lda 	#0
.019b65	8d aa 03	sta $03aa			sta 	ArrayDef+1
.019b68	a9 ff		lda #$ff			lda 	#$FF
.019b6a	8d ab 03	sta $03ab			sta 	ArrayDef+2 					; $FFFF implies no second element.
.019b6d	8d ac 03	sta $03ac			sta 	ArrayDef+3					; (test bit 7 of 2nd byte)
.019b70	60		rts				rts
.019b71					ArrayCreate:
.019b71	bd a9 03	lda $03a9,x			lda 	ArrayDef+0,x 				; put size x 2 in zTemp1
.019b74	0a		asl a				asl 	a
.019b75	85 10		sta $10				sta 	zTemp1
.019b77	bd aa 03	lda $03aa,x			lda 	ArrayDef+1,x
.019b7a	2a		rol a				rol 	a
.019b7b	85 11		sta $11				sta 	zTemp1+1
.019b7d	bd ac 03	lda $03ac,x			lda 	ArrayDef+3,x 				; if this is the last element it's array of ptrs.
.019b80	10 22		bpl $019ba4			bpl 	_ACSized 					; if not multiply size x 2 (str) 4 (int) 5 (real)
.019b82	ad 95 03	lda $0395			lda 	Var_Type 					; check the type
.019b85	c9 b8		cmp #$b8			cmp 	#token_DollarLParen 		; also if it is an array of strings $(
.019b87	f0 1b		beq $019ba4			beq 	_ACSized
.019b89	06 10		asl $10				asl 	zTemp1 						; double again
.019b8b	26 11		rol $11				rol 	zTemp1+1
.019b8d	b0 6f		bcs $019bfe			bcs 	ArrayIndexError 			; too large.
.019b8f	c9 bc		cmp #$bc			cmp 	#token_PercentLParen 		; if %( four bytes/entry is enough.
.019b91	f0 11		beq $019ba4			beq 	_ACSized
.019b93	18		clc				clc 								; add original value x 5 for reals.
.019b94	a5 10		lda $10				lda 	zTemp1
.019b96	7d a9 03	adc $03a9,x			adc 	ArrayDef+0,x
.019b99	85 10		sta $10				sta 	zTemp1
.019b9b	a5 11		lda $11				lda 	zTemp1+1
.019b9d	7d aa 03	adc $03aa,x			adc 	ArrayDef+1,x
.019ba0	85 11		sta $11				sta 	zTemp1+1
.019ba2	b0 5a		bcs $019bfe			bcs 	ArrayIndexError
.019ba4					_ACSized:
.019ba4	18		clc				clc
.019ba5	a5 10		lda $10				lda 	zTemp1
.019ba7	69 02		adc #$02			adc 	#2
.019ba9	85 10		sta $10				sta 	zTemp1
.019bab	90 04		bcc $019bb1			bcc 	_ACNoBump
.019bad	e6 10		inc $10				inc 	zTemp1
.019baf	f0 4d		beq $019bfe			beq 	ArrayIndexError
.019bb1					_ACNoBump:
.019bb1	18		clc				clc
.019bb2	ad 02 03	lda $0302			lda 	VarMemPtr 					; add this allocated count to VarMemPtr
.019bb5	85 12		sta $12				sta 	zTemp2						; save start in zTemp2/zTemp3
.019bb7	85 14		sta $14				sta 	zTemp3
.019bb9	65 10		adc $10				adc 	zTemp1
.019bbb	8d 02 03	sta $0302			sta 	VarMemPtr
.019bbe	ad 03 03	lda $0303			lda 	VarMemPtr+1
.019bc1	85 13		sta $13				sta 	zTemp2+1
.019bc3	85 15		sta $15				sta 	zTemp3+1
.019bc5	65 11		adc $11				adc 	zTemp1+1
.019bc7	8d 03 03	sta $0303			sta 	VarMemPtr+1
.019bca	85 11		sta $11				sta 	zTemp1+1
.019bcc	b0 30		bcs $019bfe			bcs 	ArrayIndexError
.019bce	a0 00		ldy #$00			ldy 	#0							; write $00 out.
.019bd0					_ACClear:
.019bd0	98		tya				tya
.019bd1	91 12		sta ($12),y			sta 	(zTemp2),y
.019bd3	e6 12		inc $12				inc 	zTemp2
.019bd5	d0 02		bne $019bd9			bne 	_ACCBump
.019bd7	e6 13		inc $13				inc 	zTemp2+1
.019bd9					_ACCBump:
.019bd9	a5 12		lda $12				lda 	zTemp2
.019bdb	cd 02 03	cmp $0302			cmp 	VarMemPtr
.019bde	d0 f0		bne $019bd0			bne 	_ACClear
.019be0	a5 13		lda $13				lda 	zTemp2+1
.019be2	cd 03 03	cmp $0303			cmp 	VarMemPtr+1
.019be5	d0 e9		bne $019bd0			bne 	_ACClear
.019be7	a0 00		ldy #$00			ldy 	#0
.019be9	bd a9 03	lda $03a9,x			lda 	ArrayDef+0,x 				; copy the size into the start
.019bec	91 14		sta ($14),y			sta 	(zTemp3),y
.019bee	c8		iny				iny
.019bef	bd aa 03	lda $03aa,x			lda 	ArrayDef+1,x
.019bf2	91 14		sta ($14),y			sta 	(zTemp3),y
.019bf4	bd ac 03	lda $03ac,x			lda 	ArrayDef+3,x 				; have we reached the end
.019bf7	10 18		bpl $019c11			bpl 	ACCFillRecursive
.019bf9	a4 15		ldy $15				ldy 	zTemp3+1 					; return address
.019bfb	a5 14		lda $14				lda 	zTemp3
.019bfd	60		rts				rts
.019bfe					ArrayIndexError:
.019bfe	20 79 85	jsr $018579			jsr ERR_Handler
>019c01	42 61 64 20 61 72 72 61			.text "Bad array index",0
>019c09	79 20 69 6e 64 65 78 00
.019c11					ACCFillRecursive:
.019c11	a9 ff		lda #$ff			lda 	#$FF 						; we mark the end, this is free space.
.019c13	a0 00		ldy #$00			ldy 	#0 							; this is overwritten by size of next allocated
.019c15	91 12		sta ($12),y			sta 	(zTemp2),y 					; array, but we might change that.
.019c17	c8		iny				iny
.019c18	b1 14		lda ($14),y			lda 	(zTemp3),y 					; set bit 15 of the max index indicating
.019c1a	09 80		ora #$80			ora 	#$80 						; an array of pointers
.019c1c	91 14		sta ($14),y			sta 	(zTemp3),y
.019c1e	a5 14		lda $14				lda 	zTemp3 						; push the start on the stack
.019c20	48		pha				pha
.019c21	a5 15		lda $15				lda 	zTemp3+1
.019c23	48		pha				pha
.019c24					_ACCFillLoop:
.019c24	18		clc				clc
.019c25	a5 14		lda $14				lda 	zTemp3 						; and work forwards.
.019c27	69 02		adc #$02			adc 	#2
.019c29	85 14		sta $14				sta 	zTemp3
.019c2b	90 02		bcc $019c2f			bcc 	_ACCSkip2
.019c2d	e6 15		inc $15				inc 	zTemp3+1
.019c2f					_ACCSkip2:
.019c2f	a0 00		ldy #$00			ldy 	#0 							; reached the end ?
.019c31	b1 14		lda ($14),y			lda 	(zTemp3),y					; (looking for FF marker, everything else 00)
.019c33	c8		iny				iny
.019c34	11 14		ora ($14),y			ora 	(zTemp3),y
.019c36	d0 21		bne $019c59			bne 	_ACCExit
.019c38	a5 14		lda $14				lda 	zTemp3 						; push zTemp3
.019c3a	48		pha				pha
.019c3b	a5 15		lda $15				lda 	zTemp3+1
.019c3d	48		pha				pha
.019c3e	e8		inx				inx
.019c3f	e8		inx				inx
.019c40	20 71 9b	jsr $019b71			jsr 	ArrayCreate 				; create array recursively.
.019c43	ca		dex				dex
.019c44	ca		dex				dex
.019c45	85 12		sta $12				sta 	zTemp2 						; save A
.019c47	68		pla				pla
.019c48	85 15		sta $15				sta 	zTemp3+1 					; restore zTemp3
.019c4a	68		pla				pla
.019c4b	85 14		sta $14				sta 	zTemp3
.019c4d	98		tya				tya 								; write high bye from Y
.019c4e	a0 01		ldy #$01			ldy 	#1
.019c50	91 14		sta ($14),y			sta 	(zTemp3),y
.019c52	88		dey				dey 								; write low byte out.
.019c53	a5 12		lda $12				lda 	zTemp2
.019c55	91 14		sta ($14),y			sta 	(zTemp3),y
.019c57	80 cb		bra $019c24			bra 	_ACCFillLoop 				; and try again.
.019c59					_ACCExit:
.019c59	7a		ply				ply 								; restore the original address
.019c5a	68		pla				pla
.019c5b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varfind.asm

.019c5c					VariableLocate:
.019c5c	da		phx				phx
.019c5d	5a		phy				phy
.019c5e	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.019c61	85 12		sta $12				sta 	zTemp2 						; points to first address.
.019c63	a9 03		lda #$03			lda 	#HashTableBase >> 8
.019c65	85 13		sta $13				sta 	zTemp2+1
.019c67	a0 00		ldy #$00	_VLNext:ldy 	#0 							; get next link into AX
.019c69	b1 12		lda ($12),y			lda 	(zTemp2),y
.019c6b	aa		tax				tax
.019c6c	c8		iny				iny
.019c6d	b1 12		lda ($12),y			lda 	(zTemp2),y
.019c6f	85 13		sta $13				sta 	zTemp2+1 					; save in zTemp
.019c71	86 12		stx $12				stx 	zTemp2
.019c73	05 12		ora $12				ora 	zTemp2 						; got zero
.019c75	18		clc				clc
.019c76	f0 25		beq $019c9d			beq 	_VLExit 					; if so, then fail as end of chain.
.019c78	c8		iny				iny 								; point to hash (offset + 2)
.019c79	b1 12		lda ($12),y			lda 	(zTemp2),y
.019c7b	cd 96 03	cmp $0396			cmp 	Var_Hash
.019c7e	d0 e7		bne $019c67			bne 	_VLNext 					; try next if different.
.019c80					_VLCompare:
.019c80	c8		iny				iny 								; next character
.019c81	b1 12		lda ($12),y			lda 	(zTemp2),y 					; compare variable field against buffer.
.019c83	d9 12 03	cmp $0312,y			cmp 	Var_Buffer-3,y 				; the -3 is because name starts at 3.
.019c86	d0 df		bne $019c67			bne 	_VLNext 					; fail if different, try next.
.019c88	0a		asl a				asl 	a 							; until end character (bit 7 set) matched
.019c89	90 f5		bcc $019c80			bcc 	_VLCompare
.019c8b	98		tya				tya
.019c8c	38		sec				sec 								; add 1 as Y points to last character
.019c8d	65 12		adc $12				adc 	zTemp2 						; add to the current address
.019c8f	85 22		sta $22				sta 	zVarDataPtr
.019c91	a5 13		lda $13				lda 	zTemp2+1
.019c93	69 00		adc #$00			adc 	#0
.019c95	85 23		sta $23				sta 	zVarDataPtr+1
.019c97	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.019c9a	85 24		sta $24				sta 	zVarType
.019c9c	38		sec				sec 								; return CS
.019c9d	7a		ply		_VLExit:ply
.019c9e	fa		plx				plx
.019c9f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/vargetset.asm

.019ca0					VariableGet:
.019ca0	5a		phy				phy
.019ca1	a0 00		ldy #$00			ldy 	#0 							; copy first two bytes
.019ca3	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019ca5	95 80		sta $80,x			sta 	XS_Mantissa,x
.019ca7	c8		iny				iny
.019ca8	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019caa	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019cac	c8		iny				iny
.019cad	a5 24		lda $24				lda 	zVarType 					; if it is a string, set up for that.
.019caf	c9 b7		cmp #$b7			cmp 	#token_Dollar
.019cb1	f0 2c		beq $019cdf			beq 	_VGString
.019cb3	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; copy the next two bytes.
.019cb5	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019cb7	c8		iny				iny
.019cb8	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019cba	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019cbc	c8		iny				iny
.019cbd	a9 01		lda #$01			lda 	#1 							; set type to 1.
.019cbf	95 85		sta $85,x			sta 	XS_Type,x
.019cc1	a5 24		lda $24				lda 	zVarType
.019cc3	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if it is a %, then exit with default integer.
.019cc5	f0 28		beq $019cef			beq 	_VGExit
.019cc7	a9 40		lda #$40			lda 	#$40 						; set type byte to zero
.019cc9	95 85		sta $85,x			sta 	XS_Type,x 					; which is the code for zero/float.
.019ccb	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; the last value to copy is the exponent.
.019ccd	95 84		sta $84,x			sta 	XS_Exponent,x
.019ccf	f0 1e		beq $019cef			beq 	_VGExit 					; if exponent is zero ... it's zero.
.019cd1	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; the sign bit is the top mantissa bit.
.019cd3	48		pha				pha
.019cd4	29 80		and #$80			and 	#$80
.019cd6	95 85		sta $85,x			sta 	XS_Type,x 					; this is the type byte.
.019cd8	68		pla				pla
.019cd9	09 80		ora #$80			ora 	#$80 						; set the MSB as you would expect.
.019cdb	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; so it's a normalised float.
.019cdd	80 10		bra $019cef			bra 	_VGExit
.019cdf					_VGString:
.019cdf	a9 02		lda #$02			lda 	#2 							; set type to 2, a string
.019ce1	95 85		sta $85,x			sta 	XS_Type,x
.019ce3	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; is the value there $0000
.019ce5	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019ce7	d0 06		bne $019cef			bne 	_VGExit 					; if not, exit.
.019ce9	85 25		sta $25				sta 	zNullString 				; make zNullString a 00 string.
.019ceb	a9 25		lda #$25			lda 	#zNullString
.019ced	95 80		sta $80,x			sta 	XS_Mantissa,x 				; make it point to it.
.019cef					_VGExit:
.019cef	7a		ply				ply
.019cf0	60		rts				rts
.019cf1					VariableSet:
.019cf1	b5 85		lda $85,x			lda 	XS_Type,x 					; is the result a string
.019cf3	29 02		and #$02			and 	#2 							; if so, it has to be
.019cf5	d0 4b		bne $019d42			bne 	_VSString
.019cf7	a5 24		lda $24				lda 	zVarType 					; if type is $ there's an error.
.019cf9	c9 b7		cmp #$b7			cmp 	#token_Dollar
.019cfb	f0 42		beq $019d3f			beq 	_VSBadType
.019cfd	c9 bb		cmp #$bb			cmp 	#token_Percent 				; type convert to float/int
.019cff	f0 05		beq $019d06			beq 	_VSMakeInt
.019d01	20 67 a2	jsr $01a267			jsr 	FPUToFloat
.019d04	80 03		bra $019d09			bra 	_VSCopy
.019d06					_VSMakeInt:
.019d06	20 b3 a2	jsr $01a2b3			jsr 	FPUToInteger
.019d09					_VSCopy:
.019d09	5a		phy				phy
.019d0a	a0 00		ldy #$00			ldy 	#0 							; copy mantissa to target.
.019d0c	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019d0e	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019d10	c8		iny				iny
.019d11	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019d13	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019d15	c8		iny				iny
.019d16	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019d18	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019d1a	c8		iny				iny
.019d1b	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019d1d	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019d1f	a5 24		lda $24				lda 	zVarType 					; if target is integer, alrady done.
.019d21	c9 bb		cmp #$bb			cmp 	#token_Percent
.019d23	f0 18		beq $019d3d			beq 	_VSExit
.019d25	b5 85		lda $85,x			lda 	XS_Type,x 					; get the sign bit into carry flag.
.019d27	0a		asl a				asl 	a
.019d28	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; shift the sign into the mantissa high.
.019d2a	08		php				php
.019d2b	0a		asl a				asl 	a
.019d2c	28		plp				plp
.019d2d	6a		ror a				ror 	a
.019d2e	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019d30	c8		iny				iny
.019d31	b5 84		lda $84,x			lda 	XS_Exponent,x 				; copy the exponent in
.019d33	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019d35	34 85		bit $85,x			bit 	XS_Type,x 					; if the result is non zero
.019d37	50 04		bvc $019d3d			bvc 	_VSExit
.019d39	a9 00		lda #$00			lda 	#00 						; zero exponent indicating 0.
.019d3b	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019d3d					_VSExit:
.019d3d	7a		ply				ply
.019d3e	60		rts				rts
.019d3f					_VSBadType:
.019d3f	4c 5a 85	jmp $01855a			jmp 	TypeError
.019d42					_VSString:
.019d42	a5 24		lda $24				lda 	zVarType 					; type must be $
.019d44	c9 b7		cmp #$b7			cmp 	#token_Dollar
.019d46	d0 f7		bne $019d3f			bne 	_VSBadType
.019d48	da		phx				phx
.019d49	5a		phy				phy
.019d4a	20 ba 98	jsr $0198ba			jsr 	StringConcrete 				; concrete the string in the mantissa -> AX
.019d4d	a0 01		ldy #$01			ldy 	#1 							; save high byte
.019d4f	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019d51	88		dey				dey 								; save low byte
.019d52	8a		txa				txa
.019d53	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019d55	7a		ply				ply 								; and exit.
.019d56	fa		plx				plx
.019d57	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.019d58					MulInteger32:
.019d58	b5 80		lda $80,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.019d5a	95 8c		sta $8c,x			sta 	XS3_Mantissa,x
.019d5c	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019d5e	95 8d		sta $8d,x			sta 	XS3_Mantissa+1,x
.019d60	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019d62	95 8e		sta $8e,x			sta 	XS3_Mantissa+2,x
.019d64	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019d66	95 8f		sta $8f,x			sta 	XS3_Mantissa+3,x
.019d68	a9 00		lda #$00			lda 	#0
.019d6a	95 80		sta $80,x			sta 	XS_Mantissa+0,x 				; zero +0
.019d6c	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019d6e	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019d70	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019d72					_BFMMultiply:
.019d72	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.019d74	29 01		and #$01			and 	#1
.019d76	f0 03		beq $019d7b			beq 	_BFMNoAdd
.019d78	20 04 94	jsr $019404			jsr 	AddInteger32
.019d7b					_BFMNoAdd:
.019d7b	16 86		asl $86,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.019d7d	36 87		rol $87,x			rol 	XS2_Mantissa+1,x
.019d7f	36 88		rol $88,x			rol 	XS2_Mantissa+2,x
.019d81	36 89		rol $89,x			rol 	XS2_Mantissa+3,x
.019d83	56 8f		lsr $8f,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.019d85	76 8e		ror $8e,x			ror 	XS3_Mantissa+2,x
.019d87	76 8d		ror $8d,x			ror 	XS3_Mantissa+1,x
.019d89	76 8c		ror $8c,x			ror 	XS3_Mantissa,x
.019d8b	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.019d8d	15 8d		ora $8d,x			ora 	XS3_Mantissa+1,x
.019d8f	15 8e		ora $8e,x			ora 	XS3_Mantissa+2,x
.019d91	15 8f		ora $8f,x			ora 	XS3_Mantissa+3,x
.019d93	d0 dd		bne $019d72			bne 	_BFMMultiply
.019d95	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.019d96					DivInteger32:
.019d96	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; check for /0
.019d98	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.019d9a	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.019d9c	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.019d9e	d0 14		bne $019db4			bne 	_BFDOkay
.019da0	20 79 85	jsr $018579			jsr ERR_Handler
>019da3	44 69 76 69 73 69 6f 6e			.text "Division by Zero",0
>019dab	20 62 79 20 5a 65 72 6f 00
.019db4					_BFDOkay:
.019db4	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.019db6	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.019db8	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.019dba	85 1c		sta $1c				sta 	zLTemp1+2
.019dbc	85 1d		sta $1d				sta 	zLTemp1+3
.019dbe	8d 9e 03	sta $039e			sta 	SignCount 					; Count of signs.
.019dc1	20 18 9e	jsr $019e18			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.019dc4	da		phx				phx
.019dc5	e8		inx				inx
.019dc6	e8		inx				inx
.019dc7	e8		inx				inx
.019dc8	e8		inx				inx
.019dc9	e8		inx				inx
.019dca	e8		inx				inx
.019dcb	20 18 9e	jsr $019e18			jsr 	CheckIntegerNegate
.019dce	fa		plx				plx
.019dcf	5a		phy				phy 								; Y is the counter
.019dd0	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.019dd2					_BFDLoop:
.019dd2	16 80		asl $80,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.019dd4	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.019dd6	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.019dd8	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.019dda	26 1a		rol $1a				rol 	zLTemp1
.019ddc	26 1b		rol $1b				rol 	zLTemp1+1
.019dde	26 1c		rol $1c				rol 	zLTemp1+2
.019de0	26 1d		rol $1d				rol 	zLTemp1+3
.019de2	38		sec				sec
.019de3	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.019de5	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.019de7	48		pha				pha
.019de8	a5 1b		lda $1b				lda 	zLTemp1+1
.019dea	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.019dec	48		pha				pha
.019ded	a5 1c		lda $1c				lda 	zLTemp1+2
.019def	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.019df1	48		pha				pha
.019df2	a5 1d		lda $1d				lda 	zLTemp1+3
.019df4	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.019df6	90 13		bcc $019e0b			bcc 	_BFDNoAdd
.019df8	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.019dfa	68		pla				pla
.019dfb	85 1c		sta $1c				sta 	zLTemp1+2
.019dfd	68		pla				pla
.019dfe	85 1b		sta $1b				sta 	zLTemp1+1
.019e00	68		pla				pla
.019e01	85 1a		sta $1a				sta 	zLTemp1+0
.019e03	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.019e05	09 01		ora #$01			ora 	#1
.019e07	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019e09	80 03		bra $019e0e			bra 	_BFDNext
.019e0b					_BFDNoAdd:
.019e0b	68		pla				pla 								; Throw away the intermediate calculations
.019e0c	68		pla				pla
.019e0d	68		pla				pla
.019e0e					_BFDNext:
.019e0e	88		dey				dey
.019e0f	d0 c1		bne $019dd2			bne 	_BFDLoop
.019e11	7a		ply				ply 								; restore Y and exit
.019e12	4e 9e 03	lsr $039e			lsr 	SignCount 					; if sign count odd,
.019e15	b0 06		bcs $019e1d			bcs		IntegerNegateAlways 			; negate the result
.019e17	60		rts				rts
.019e18					CheckIntegerNegate:
.019e18	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019e1a	30 01		bmi $019e1d			bmi 	IntegerNegateAlways
.019e1c	60		rts				rts
.019e1d					IntegerNegateAlways:
.019e1d	ee 9e 03	inc $039e			inc 	SignCount
.019e20	38		sec				sec
.019e21	a9 00		lda #$00			lda 	#0
.019e23	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.019e25	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019e27	a9 00		lda #$00			lda 	#0
.019e29	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.019e2b	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019e2d	a9 00		lda #$00			lda 	#0
.019e2f	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.019e31	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019e33	a9 00		lda #$00			lda 	#0
.019e35	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.019e37	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019e39	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.019e3a					INTToString:
.019e3a	48		pha				pha
.019e3b	5a		phy				phy
.019e3c	b5 83		lda $83,x			lda 		XS_Mantissa+3,x 		; check -ve
.019e3e	10 08		bpl $019e48			bpl 		_ITSNotMinus
.019e40	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.019e42	20 dc 9e	jsr $019edc			jsr 		ITSOutputCharacter
.019e45	20 1d 9e	jsr $019e1d			jsr 		IntegerNegateAlways 	; negate the number.
.019e48					_ITSNotMinus:
.019e48	a9 00		lda #$00			lda 		#0
.019e4a	8d 9a 03	sta $039a			sta 		NumSuppress 			; clear the suppression flag.
.019e4d	8a		txa				txa 								; use Y for the mantissa index.
.019e4e	a8		tay				tay
.019e4f	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.019e51					_ITSNextSubtractor:
.019e51	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.019e53	8d 9b 03	sta $039b			sta 		NumConvCount
.019e56					_ITSSubtract:
.019e56	38		sec				sec
.019e57	b9 80 00	lda $0080,y			lda 		XS_Mantissa,y 			; subtract number and push on stack
.019e5a	ff b8 9e 01	sbc $019eb8,x			sbc 		_ITSSubtractors+0,x
.019e5e	48		pha				pha
.019e5f	b9 81 00	lda $0081,y			lda 		XS_Mantissa+1,y
.019e62	ff b9 9e 01	sbc $019eb9,x			sbc 		_ITSSubtractors+1,x
.019e66	48		pha				pha
.019e67	b9 82 00	lda $0082,y			lda 		XS_Mantissa+2,y
.019e6a	ff ba 9e 01	sbc $019eba,x			sbc 		_ITSSubtractors+2,x
.019e6e	48		pha				pha
.019e6f	b9 83 00	lda $0083,y			lda 		XS_Mantissa+3,y
.019e72	ff bb 9e 01	sbc $019ebb,x			sbc 		_ITSSubtractors+3,x
.019e76	90 14		bcc $019e8c			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.019e78	99 83 00	sta $0083,y			sta 		XS_Mantissa+3,y 		; save subtract off stack
.019e7b	68		pla				pla
.019e7c	99 82 00	sta $0082,y			sta 		XS_Mantissa+2,y
.019e7f	68		pla				pla
.019e80	99 81 00	sta $0081,y			sta 		XS_Mantissa+1,y
.019e83	68		pla				pla
.019e84	99 80 00	sta $0080,y			sta 		XS_Mantissa+0,y
.019e87	ee 9b 03	inc $039b			inc 		NumConvCount 			; bump count.
.019e8a	80 ca		bra $019e56			bra 		_ITSSubtract 			; go round again.
.019e8c					_ITSCantSubtract:
.019e8c	68		pla				pla 								; throw away interim answers
.019e8d	68		pla				pla
.019e8e	68		pla				pla
.019e8f	ad 9b 03	lda $039b			lda 		NumConvCount 			; if not zero then no suppression check
.019e92	c9 30		cmp #$30			cmp 		#"0"
.019e94	d0 05		bne $019e9b			bne 		_ITSOutputDigit
.019e96	ad 9a 03	lda $039a			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.019e99	10 09		bpl $019ea4			bpl	 		_ITSGoNextSubtractor
.019e9b					_ITSOutputDigit:
.019e9b	ce 9a 03	dec $039a			dec 		NumSuppress 			; suppression check will be non-zero.
.019e9e	ad 9b 03	lda $039b			lda 		NumConvCount 			; count of subtractions
.019ea1	20 dc 9e	jsr $019edc			jsr 		ITSOutputCharacter 		; output it.
.019ea4					_ITSGoNextSubtractor:
.019ea4	e8		inx				inx 								; next dword
.019ea5	e8		inx				inx
.019ea6	e8		inx				inx
.019ea7	e8		inx				inx
.019ea8	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.019eaa	d0 a5		bne $019e51			bne 		_ITSNextSubtractor 		; do all the subtractors.
.019eac	98		tya				tya 								; X is back as the mantissa index
.019ead	aa		tax				tax
.019eae	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.019eb0	09 30		ora #$30			ora 		#"0"
.019eb2	20 dc 9e	jsr $019edc			jsr 		ITSOutputCharacter
.019eb5	7a		ply				ply 								; and exit
.019eb6	68		pla				pla
.019eb7	60		rts				rts
.019eb8					_ITSSubtractors:
>019eb8	00 ca 9a 3b					.dword 		1000000000
>019ebc	00 e1 f5 05					.dword 		100000000
>019ec0	80 96 98 00					.dword 		10000000
>019ec4	40 42 0f 00					.dword 		1000000
>019ec8	a0 86 01 00					.dword 		100000
>019ecc	10 27 00 00					.dword 		10000
>019ed0	e8 03 00 00					.dword 		1000
>019ed4	64 00 00 00					.dword 		100
>019ed8	0a 00 00 00					.dword 		10
.019edc					_ITSSubtractorsEnd:
.019edc					ITSOutputCharacter:
.019edc	48		pha				pha
.019edd	da		phx				phx
.019ede	ae 14 03	ldx $0314			ldx 	NumBufX 					; save digit
.019ee1	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.019ee4	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.019ee6	9d 16 03	sta $0316,x			sta 	Num_Buffer+1,x
.019ee9	ee 14 03	inc $0314			inc 	NumBufX						; bump pointer.
.019eec	fa		plx				plx
.019eed	68		pla				pla
.019eee	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.019eef					IntFromString:
.019eef	a0 00		ldy #$00			ldy 	#0
.019ef1	8c 9c 03	sty $039c			sty 	ExpTemp 					; this is the converted digit count.
.019ef4					IntFromStringY:
.019ef4	48		pha				pha
.019ef5	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.019ef7	95 80		sta $80,x			sta 	XS_Mantissa,x
.019ef9	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019efb	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019efd	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019eff	a9 01		lda #$01			lda 	#1
.019f01	95 85		sta $85,x			sta 	XS_Type,x
.019f03					_IFSLoop:
.019f03	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.019f05	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.019f07	90 4e		bcc $019f57			bcc 	_IFSExit
.019f09	c9 3a		cmp #$3a			cmp 	#"9"+1
.019f0b	b0 4a		bcs $019f57			bcs 	_IFSExit
.019f0d	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.019f0f	c9 0c		cmp #$0c			cmp 	#12
.019f11	b0 4e		bcs $019f61			bcs 	_IFSOverflow
.019f13	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.019f15	48		pha				pha
.019f16	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019f18	48		pha				pha
.019f19	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019f1b	48		pha				pha
.019f1c	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019f1e	48		pha				pha
.019f1f	20 76 9f	jsr $019f76			jsr 	IFSX1ShiftLeft 				; double
.019f22	20 76 9f	jsr $019f76			jsr 	IFSX1ShiftLeft 				; x 4
.019f25	18		clc				clc 								; add saved value x 5
.019f26	68		pla				pla
.019f27	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.019f29	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019f2b	68		pla				pla
.019f2c	75 81		adc $81,x			adc 	XS_Mantissa+1,x
.019f2e	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019f30	68		pla				pla
.019f31	75 82		adc $82,x			adc 	XS_Mantissa+2,x
.019f33	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019f35	68		pla				pla
.019f36	75 83		adc $83,x			adc 	XS_Mantissa+3,x
.019f38	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019f3a	20 76 9f	jsr $019f76			jsr 	IFSX1ShiftLeft 				; x 10
.019f3d	ee 9c 03	inc $039c			inc 	ExpTemp 					; bump count of digits processed.
.019f40	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.019f42	29 0f		and #$0f			and 	#15
.019f44	c8		iny				iny
.019f45	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.019f47	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019f49	90 b8		bcc $019f03			bcc 	_IFSLoop
.019f4b	f6 81		inc $81,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.019f4d	d0 b4		bne $019f03			bne 	_IFSLoop
.019f4f	f6 82		inc $82,x			inc 	XS_Mantissa+2,x
.019f51	d0 b0		bne $019f03			bne 	_IFSLoop
.019f53	f6 83		inc $83,x			inc 	XS_Mantissa+3,x
.019f55	80 ac		bra $019f03			bra 	_IFSLoop
.019f57					_IFSExit:
.019f57	98		tya				tya 								; get offset
.019f58					_IFSOkay:
.019f58	38		sec				sec
.019f59	ad 9c 03	lda $039c			lda 	ExpTemp
.019f5c	f0 01		beq $019f5f			beq 	_IFSSkipFail
.019f5e	18		clc				clc
.019f5f					_IFSSkipFail:
.019f5f	68		pla				pla 								; and exit.
.019f60	60		rts				rts
.019f61					_IFSOverflow:
.019f61	20 79 85	jsr $018579			jsr 	ERR_Handler
>019f64	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>019f6c	20 6f 76 65 72 66 6c 6f 77 00
.019f76					IFSX1ShiftLeft:
.019f76	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.019f78	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.019f7a	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.019f7c	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.019f7e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.019f7f					FPSubtract:
.019f7f	48		pha				pha
.019f80	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.019f82	49 80		eor #$80			eor 	#$80
.019f84	95 8b		sta $8b,x			sta 	XS2_Type,x
.019f86	68		pla				pla 								; --- and fall through ---
.019f87					FPAdd:
.019f87	48		pha				pha
.019f88	b5 85		lda $85,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.019f8a	d0 05		bne $019f91			bne 	_FPA_NegativeLHS
.019f8c	20 a8 9f	jsr $019fa8			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.019f8f	68		pla				pla
.019f90	60		rts				rts
.019f91					_FPA_NegativeLHS:
.019f91	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.019f93	49 80		eor #$80			eor 	#$80
.019f95	95 85		sta $85,x			sta 	XS_Type,x
.019f97	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of B and add
.019f99	49 80		eor #$80			eor 	#$80
.019f9b	95 8b		sta $8b,x			sta 	XS2_Type,x
.019f9d	20 a8 9f	jsr $019fa8			jsr 	FPAdd_Worker 				; do the add calculation.
.019fa0	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 back
.019fa2	49 80		eor #$80			eor 	#$80
.019fa4	95 85		sta $85,x			sta 	XS_Type,x
.019fa6	68		pla				pla
.019fa7	60		rts				rts
.019fa8					FPAdd_Worker:
.019fa8	34 8b		bit $8b,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.019faa	70 07		bvs $019fb3			bvs 	_FPAWExit 					; no change.
.019fac	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.019fae	50 07		bvc $019fb7			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.019fb0	20 25 a2	jsr $01a225			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.019fb3					_FPAWExit:
.019fb3	20 94 a2	jsr $01a294			jsr 	FPUNormalise 				; normalise the result.
.019fb6	60		rts				rts
.019fb7					_FPAWMakeSame:
.019fb7	b5 84		lda $84,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.019fb9	38		sec				sec
.019fba	f5 8a		sbc $8a,x			sbc	 	XS2_Exponent,x 				; using subtraction
.019fbc	f0 16		beq $019fd4			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.019fbe	da		phx				phx 								; save X
.019fbf	90 06		bcc $019fc7			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.019fc1	e8		inx				inx
.019fc2	e8		inx				inx
.019fc3	e8		inx				inx
.019fc4	e8		inx				inx
.019fc5	e8		inx				inx
.019fc6	e8		inx				inx
.019fc7					_FPAWShiftA:
.019fc7	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.019fc9	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.019fcb	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.019fcd	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.019fcf	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.019fd1	fa		plx				plx 								; restore original X
.019fd2	80 e3		bra $019fb7			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.019fd4					_FPAW_DoArithmetic:
.019fd4	34 8b		bit $8b,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.019fd6	30 28		bmi $01a000			bmi 	_FPAW_BNegative
.019fd8	18		clc				clc
.019fd9	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019fdb	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.019fdd	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019fdf	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019fe1	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.019fe3	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019fe5	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019fe7	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.019fe9	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019feb	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019fed	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.019fef	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019ff1	90 c0		bcc $019fb3			bcc 	_FPAWExit 					; no carry.
.019ff3	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.019ff5	38		sec				sec
.019ff6	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.019ff8	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.019ffa	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.019ffc	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.019ffe	80 b3		bra $019fb3			bra 	_FPAWExit
.01a000					_FPAW_BNegative:
.01a000	38		sec				sec
.01a001	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01a003	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.01a005	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a007	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a009	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.01a00b	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a00d	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a00f	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.01a011	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a013	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a015	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.01a017	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a019	b0 09		bcs $01a024			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.01a01b	20 4b a2	jsr $01a24b			jsr 	FPUNegateInteger			; negate the mantissa
.01a01e	b5 85		lda $85,x			lda 	XS_Type,x 					; flip result sign
.01a020	49 80		eor #$80			eor 	#$80
.01a022	95 85		sta $85,x			sta 	XS_Type,x
.01a024					_FPAWGoExit:
.01a024	4c b3 9f	jmp $019fb3			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.01a027					FPD_IsDivZero:
.01a027	20 79 85	jsr $018579			jsr ERR_Handler
>01a02a	44 69 76 69 73 69 6f 6e			.text "Division by zero",0
>01a032	20 62 79 20 7a 65 72 6f 00
.01a03b					FPDivide:
.01a03b	48		pha				pha
.01a03c	5a		phy				phy
.01a03d	34 8b		bit $8b,x			bit 	XS2_Type,x 					; check if division by zero
.01a03f	70 e6		bvs $01a027			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.01a041	34 85		bit $85,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.01a043	f0 03		beq $01a048			beq 	_FPDCalculateExp
.01a045					_FPD_Exit:
.01a045	7a		ply				ply
.01a046	68		pla				pla
.01a047	60		rts				rts
.01a048					_FPDCalculateExp:
.01a048	b5 8a		lda $8a,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.01a04a	49 ff		eor #$ff			eor 	#$FF
.01a04c	1a		inc a				inc 	a
.01a04d	95 8a		sta $8a,x			sta 	XS2_Exponent,x
.01a04f	20 1f a1	jsr $01a11f			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.01a052	18		clc				clc 	 							; add 1 to the resulting exponent
.01a053	69 01		adc #$01			adc 	#1
.01a055	b0 54		bcs $01a0ab			bcs 	_FPD_Overflow 				; which can overflow.
.01a057	95 84		sta $84,x			sta 	XS_Exponent,x
.01a059	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.01a05b	85 1a		sta $1a				sta 	zLTemp1+0
.01a05d	85 1b		sta $1b				sta 	zLTemp1+1
.01a05f	85 1c		sta $1c				sta 	zLTemp1+2
.01a061	85 1d		sta $1d				sta 	zLTemp1+3
.01a063	a0 20		ldy #$20			ldy 	#32 						; times round.
.01a065					_FPD_Loop:
.01a065	38		sec				sec 								; calculate X1-X2 stacking result because we might
.01a066	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; not save it.
.01a068	f5 86		sbc $86,x			sbc 	XS2_Mantissa,x
.01a06a	48		pha				pha
.01a06b	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a06d	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.01a06f	48		pha				pha
.01a070	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a072	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.01a074	48		pha				pha
.01a075	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a077	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.01a079	90 13		bcc $01a08e			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.01a07b	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; save results out to A
.01a07d	68		pla				pla
.01a07e	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a080	68		pla				pla
.01a081	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a083	68		pla				pla
.01a084	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a086	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.01a088	09 80		ora #$80			ora 	#$80
.01a08a	85 1d		sta $1d				sta 	zLTemp1+3
.01a08c	80 03		bra $01a091			bra 	_FPD_Rotates
.01a08e					_FPD_NoSubtract:
.01a08e	68		pla				pla 								; throw away unwanted results
.01a08f	68		pla				pla
.01a090	68		pla				pla
.01a091					_FPD_Rotates:
.01a091	56 89		lsr $89,x			lsr 	3+XS2_Mantissa,x
.01a093	76 88		ror $88,x			ror 	2+XS2_Mantissa,x
.01a095	76 87		ror $87,x			ror 	1+XS2_Mantissa,x
.01a097	76 86		ror $86,x			ror 	0+XS2_Mantissa,x
.01a099	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.01a09b	26 1b		rol $1b				rol 	zLTemp1+1
.01a09d	26 1c		rol $1c				rol 	zLTemp1+2
.01a09f	26 1d		rol $1d				rol 	zLTemp1+3
.01a0a1	90 02		bcc $01a0a5			bcc 	_FPD_NoCarry
.01a0a3	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.01a0a5					_FPD_NoCarry:
.01a0a5	88		dey				dey 								; do 32 times
.01a0a6	d0 bd		bne $01a065			bne 	_FPD_Loop
.01a0a8	4c 03 a1	jmp $01a103			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.01a0ab					_FPD_Overflow:
.01a0ab	4c f1 a2	jmp $01a2f1			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.01a0ae					FPMultiply:
.01a0ae	48		pha				pha
.01a0af	5a		phy				phy
.01a0b0	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.01a0b2	70 07		bvs $01a0bb			bvs 	_FPM_Exit
.01a0b4	34 8b		bit $8b,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.01a0b6	50 06		bvc $01a0be			bvc 	_FPM_CalcExponent
.01a0b8	20 25 a2	jsr $01a225			jsr 	FPUCopyX2ToX1
.01a0bb					_FPM_Exit:
.01a0bb	7a		ply				ply
.01a0bc	68		pla				pla
.01a0bd	60		rts				rts
.01a0be					_FPM_CalcExponent:
.01a0be	18		clc				clc
.01a0bf	20 1f a1	jsr $01a11f			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.01a0c2	95 84		sta $84,x			sta 	XS_Exponent,x 				; save the result.
.01a0c4	a9 00		lda #$00			lda 	#0
.01a0c6	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.01a0c8	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.01a0ca	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.01a0cc	85 1d		sta $1d				sta 	zLTemp1+3
.01a0ce	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.01a0d0					_FPM_Loop:
.01a0d0	b5 80		lda $80,x			lda 	XS_Mantissa,x				; check LSB of long product
.01a0d2	29 01		and #$01			and 	#1
.01a0d4	18		clc				clc 								; clear carry for the long rotate.
.01a0d5	f0 19		beq $01a0f0			beq 	_FPM_NoAddition
.01a0d7	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.01a0d8	a5 1a		lda $1a				lda 	zLTemp1+0
.01a0da	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.01a0dc	85 1a		sta $1a				sta 	zLTemp1+0
.01a0de	a5 1b		lda $1b				lda 	zLTemp1+1
.01a0e0	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.01a0e2	85 1b		sta $1b				sta 	zLTemp1+1
.01a0e4	a5 1c		lda $1c				lda 	zLTemp1+2
.01a0e6	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.01a0e8	85 1c		sta $1c				sta 	zLTemp1+2
.01a0ea	a5 1d		lda $1d				lda 	zLTemp1+3
.01a0ec	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.01a0ee	85 1d		sta $1d				sta 	zLTemp1+3
.01a0f0					_FPM_NoAddition:
.01a0f0	66 1d		ror $1d				ror 	3+zLTemp1
.01a0f2	66 1c		ror $1c				ror 	2+zLTemp1
.01a0f4	66 1b		ror $1b				ror 	1+zLTemp1
.01a0f6	66 1a		ror $1a				ror 	0+zLTemp1
.01a0f8	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.01a0fa	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a0fc	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a0fe	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a100	88		dey				dey
.01a101	d0 cd		bne $01a0d0			bne 	_FPM_Loop 					; do this 32 times.
.01a103					FPM_CopySignNormalize:
.01a103	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.01a105	95 80		sta $80,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.01a107	a5 1b		lda $1b				lda 	zLTemp1+1
.01a109	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a10b	a5 1c		lda $1c				lda 	zLTemp1+2
.01a10d	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a10f	a5 1d		lda $1d				lda 	zLTemp1+3
.01a111	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a113	b5 85		lda $85,x			lda 	XS_Type,x 					; sign is xor of signs
.01a115	55 8b		eor $8b,x			eor 	XS2_Type,x
.01a117	95 85		sta $85,x			sta 	XS_Type,x
.01a119	20 94 a2	jsr $01a294			jsr 	FPUNormalise 				; normalise and exit.
.01a11c	7a		ply				ply
.01a11d	68		pla				pla
.01a11e	60		rts				rts
.01a11f					FPCalculateExponent:
.01a11f	18		clc				clc
.01a120	b5 84		lda $84,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.01a122	75 8a		adc $8a,x			adc 	XS2_Exponent,x
.01a124	b0 08		bcs $01a12e			bcs 	_FPCECarry 					; carry out ?
.01a126	10 03		bpl $01a12b			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.01a128	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.01a12a	60		rts				rts
.01a12b					_FPCEExpZero:
.01a12b	a9 00		lda #$00			lda 	#0
.01a12d	60		rts				rts
.01a12e					_FPCECarry:
.01a12e	30 03		bmi $01a133			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.01a130	09 80		ora #$80			ora 	#$80 						; put in right range
.01a132	60		rts				rts
.01a133					_FPCEOverflow:
.01a133	4c f1 a2	jmp $01a2f1			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.01a136					FPFractionalPart:
.01a136	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.01a138	38		sec				sec 								; this flag tells us to keep the fractional part
.01a139	30 0d		bmi $01a148			bmi 	FPGetPart
.01a13b	60		rts				rts
.01a13c					FPIntegerPart:
.01a13c	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.01a13e	18		clc				clc 								; this flag says keep the integer part.
.01a13f	30 07		bmi $01a148			bmi 	FPGetPart 					; -ve exponents are 0..127
.01a141	48		pha				pha
.01a142	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.01a144	95 85		sta $85,x			sta 	XS_Type,x
.01a146	68		pla				pla
.01a147	60		rts				rts
.01a148					FPGetPart:
.01a148	48		pha				pha
.01a149	5a		phy				phy 								; save Y
.01a14a	08		php				php 								; save action
.01a14b	34 85		bit $85,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.01a14d	70 59		bvs $01a1a8			bvs 	_FPGP_Exit 					; then do nothing.
.01a14f	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.01a151	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.01a153	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.01a155	85 1c		sta $1c				sta 	zLTemp1+2
.01a157	85 1d		sta $1d				sta 	zLTemp1+3
.01a159	b5 84		lda $84,x			lda 	XS_Exponent,x				; the number of shifts.
.01a15b	38		sec				sec
.01a15c	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.01a15e	f0 12		beq $01a172			beq 	_FPGP_NoShift 				; ... if any
.01a160	c9 20		cmp #$20			cmp 	#32
.01a162	90 02		bcc $01a166			bcc 	_FPGP_NotMax
.01a164	a9 20		lda #$20			lda 	#32 						; max of 32.
.01a166					_FPGP_NotMax:
.01a166	a8		tay				tay 								; Y is the mask shift count.
.01a167					_FPGP_ShiftMask:
.01a167	46 1d		lsr $1d				lsr 	3+zLTemp1
.01a169	66 1c		ror $1c				ror 	2+zLTemp1
.01a16b	66 1b		ror $1b				ror 	1+zLTemp1
.01a16d	66 1a		ror $1a				ror 	0+zLTemp1
.01a16f	88		dey				dey
.01a170	d0 f5		bne $01a167			bne 	_FPGP_ShiftMask
.01a172					_FPGP_NoShift:
.01a172	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.01a174	8e 9c 03	stx $039c			stx 	ExpTemp						; save X
.01a177					_FPGP_MaskLoop:
.01a177	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.01a17a	28		plp				plp 								; if CC we keep the top part, so we
.01a17b	08		php				php		 							; flip the mask.
.01a17c	b0 02		bcs $01a180			bcs		_FPGP_NoFlip
.01a17e	49 ff		eor #$ff			eor 	#$FF
.01a180					_FPGP_NoFlip:
.01a180	35 80		and $80,x			and 	XS_Mantissa,x 				; and into the mantissa.
.01a182	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a184	e8		inx				inx
.01a185	c8		iny				iny
.01a186	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.01a188	d0 ed		bne $01a177			bne 	_FPGP_MaskLoop
.01a18a	ae 9c 03	ldx $039c			ldx 	ExpTemp						; restore X
.01a18d	28		plp				plp
.01a18e	08		php				php 								; get action flag on the stack
.01a18f	90 04		bcc $01a195			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.01a191	a9 00		lda #$00			lda 	#0
.01a193	95 85		sta $85,x			sta 	XS_Type,x
.01a195					_FPGP_NotFractional:
.01a195	b5 80		lda $80,x			lda 	XS_Mantissa,x 						; check if \1 zero
.01a197	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.01a199	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01a19b	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01a19d	f0 05		beq $01a1a4			beq 	_FPGP_Zero 					; if zero, return zero
.01a19f	20 94 a2	jsr $01a294			jsr 	FPUNormalise
.01a1a2	80 04		bra $01a1a8			bra 	_FPGP_Exit 					; and exit
.01a1a4					_FPGP_Zero:
.01a1a4	a9 40		lda #$40			lda 	#$40 						; set zero flag
.01a1a6	95 85		sta $85,x			sta 	XS_Type,x
.01a1a8					_FPGP_Exit:
.01a1a8	68		pla				pla 								; throw saved action flag.
.01a1a9	7a		ply				ply
.01a1aa	68		pla				pla
.01a1ab	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.01a1ac					FPCompare:
.01a1ac	20 ed a1	jsr $01a1ed			jsr 	FPFastCompare 				; fast compare try first
.01a1af	b0 3b		bcs $01a1ec			bcs 	_FPCExit 					; that worked.
.01a1b1	b5 84		lda $84,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.01a1b3	48		pha				pha
.01a1b4	b5 8a		lda $8a,x			lda 	XS2_Exponent,x
.01a1b6	48		pha				pha
.01a1b7	20 7f 9f	jsr $019f7f			jsr 	FPSubtract 					; calculate X1-X2
.01a1ba	34 85		bit $85,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.01a1bc	70 2a		bvs $01a1e8			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.01a1be	68		pla				pla
.01a1bf	8d 9c 03	sta $039c			sta 	ExpTemp						; save first exponent in temporary reg.
.01a1c2	68		pla				pla
.01a1c3	38		sec				sec
.01a1c4	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; calculate AX-BX
.01a1c7	70 14		bvs $01a1dd			bvs 	_FPCNotEqual				; overflow, can't be equal.
.01a1c9	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.01a1ca	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.01a1cc	b0 0f		bcs $01a1dd			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.01a1ce	38		sec				sec
.01a1cf	ad 9c 03	lda $039c			lda 	ExpTemp 					; get one of the exponents back.
.01a1d2	e9 12		sbc #$12			sbc 	#18 						; allow for 2^18 error, relatively.
.01a1d4	b0 02		bcs $01a1d8			bcs 	_FPCNotRange 				; keep in range.
.01a1d6	a9 01		lda #$01			lda 	#1
.01a1d8					_FPCNotRange:
.01a1d8	38		sec				sec
.01a1d9	f5 84		sbc $84,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.01a1db	b0 0d		bcs $01a1ea			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.01a1dd					_FPCNotEqual:
.01a1dd	b5 85		lda $85,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.01a1df	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.01a1e1	f0 02		beq $01a1e5			beq 	_FPCNE2
.01a1e3	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.01a1e5	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.01a1e6	80 04		bra $01a1ec			bra 	_FPCExit
.01a1e8					_FPCPullZero:
.01a1e8	68		pla				pla 								; throw saved exponents
.01a1e9	68		pla				pla
.01a1ea					_FPCZero:
.01a1ea	a9 00		lda #$00			lda 	#0 							; and return zero
.01a1ec					_FPCExit:
.01a1ec	60		rts				rts
.01a1ed					FPFastCompare:
.01a1ed	34 85		bit $85,x			bit 	XS_Type,x 					; n1 is zero.
.01a1ef	70 23		bvs $01a214			bvs 	_FPFLeftZero
.01a1f1	34 8b		bit $8b,x			bit 	XS2_Type,x 					; n2 is zero
.01a1f3	b5 85		lda $85,x			lda 	XS_Type,x 					; if so, return sign bit of 1 (n-0)
.01a1f5	70 25		bvs $01a21c			bvs 	_FPFSignBit
.01a1f7	55 8b		eor $8b,x			eor 	XS2_Type,x 					; eor 2 type bits. now know both non-zero
.01a1f9	0a		asl a				asl 	a 							; put in CS if different.
.01a1fa	b5 85		lda $85,x			lda 	XS_Type,x 					; if signs different return sign of first
.01a1fc	b0 1e		bcs $01a21c			bcs 	_FPFSignBit
.01a1fe	38		sec				sec 								; same sign and not-zero. compare exponents
.01a1ff	b5 84		lda $84,x			lda 	XS_Exponent,x 				; compare exponents. if the same, then fail.
.01a201	f5 8a		sbc $8a,x			sbc 	XS2_Exponent,x 				; e.g. we have to do it via subtraction.
.01a203	f0 09		beq $01a20e			beq 	_FPNoFastCompare
.01a205	6a		ror a				ror 	a 							; put carry into bit 7.
.01a206	34 85		bit $85,x			bit 	XS_Type,X 					; if it is +x then flip it.
.01a208	30 02		bmi $01a20c			bmi		_FPFCNotMinus
.01a20a	49 80		eor #$80			eor 	#$80
.01a20c					_FPFCNotMinus:
.01a20c	80 0e		bra $01a21c			bra		_FPFSignBit
.01a20e					_FPNoFastCompare:
.01a20e	18		clc				clc
.01a20f	60		rts				rts
.01a210					_FPFZero:
.01a210	a9 00		lda #$00			lda 	#0
.01a212					_FPFExitSet:
.01a212	38		sec				sec
.01a213	60		rts				rts
.01a214					_FPFLeftZero:
.01a214	34 8b		bit $8b,x			bit 	XS2_Type,x 					; if right is zero, return zero.
.01a216	70 f8		bvs $01a210			bvs 	_FPFZero
.01a218	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip sign bit
.01a21a	49 80		eor #$80			eor 	#$80						; return that as a sign.
.01a21c					_FPFSignBit:
.01a21c	0a		asl a				asl 	a
.01a21d	a9 01		lda #$01			lda 	#1
.01a21f	90 f1		bcc $01a212			bcc		_FPFExitSet
.01a221	a9 ff		lda #$ff			lda 	#$FF
.01a223	38		sec				sec
.01a224	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.01a225					FPUCopyX2ToX1:
.01a225	48		pha				pha
.01a226	da		phx				phx
.01a227	5a		phy				phy
.01a228	a0 08		ldy #$08			ldy 	#8
.01a22a	b5 86		lda $86,x	_FPUC21:lda 	XS2_Mantissa,x
.01a22c	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a22e	e8		inx				inx
.01a22f	88		dey				dey
.01a230	10 f8		bpl $01a22a			bpl 	_FPUC21
.01a232	7a		ply				ply
.01a233	fa		plx				plx
.01a234	68		pla				pla
.01a235	60		rts				rts
.01a236					FPUSetInteger:
.01a236	48		pha				pha
.01a237	95 80		sta $80,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.01a239	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.01a23b	10 02		bpl $01a23f			bpl 	_FPUSIExtend
.01a23d	a9 ff		lda #$ff			lda 	#$FF
.01a23f					_FPUSIExtend:
.01a23f	95 81		sta $81,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.01a241	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a243	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a245	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.01a247	95 85		sta $85,x			sta 	XS_Type,x
.01a249	68		pla				pla
.01a24a	60		rts				rts
.01a24b					FPUNegateInteger:
.01a24b	48		pha				pha
.01a24c	38		sec				sec
.01a24d	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.01a24f	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.01a251	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a253	a9 00		lda #$00			lda 	#0
.01a255	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.01a257	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a259	a9 00		lda #$00			lda 	#0
.01a25b	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.01a25d	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a25f	a9 00		lda #$00			lda 	#0
.01a261	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.01a263	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a265	68		pla				pla
.01a266	60		rts				rts
.01a267					FPUToFloat:
.01a267	48		pha				pha
.01a268	b5 85		lda $85,x			lda 	XS_Type,x					; exit if already float.
.01a26a	29 0f		and #$0f			and 	#$0F
.01a26c	f0 24		beq $01a292			beq 	_FPUFExit
.01a26e	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.01a270	95 85		sta $85,x			sta 	XS_Type,x
.01a272	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.01a274	95 84		sta $84,x			sta 	XS_Exponent,x 				; x mantissa.
.01a276	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.01a278	10 07		bpl $01a281			bpl		_FPUFPositive
.01a27a	20 4b a2	jsr $01a24b			jsr 	FPUNegateInteger 			; negate the mantissa
.01a27d	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.01a27f	95 85		sta $85,x			sta 	XS_Type,x
.01a281					_FPUFPositive:
.01a281	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.01a283	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.01a285	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01a287	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01a289	d0 04		bne $01a28f			bne 	_FPUFNonZero
.01a28b	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.01a28d	95 85		sta $85,x			sta 	XS_Type,x
.01a28f					_FPUFNonZero:
.01a28f	20 94 a2	jsr $01a294			jsr 	FPUNormalise 				; normalise the floating point.
.01a292					_FPUFExit:
.01a292	68		pla				pla
.01a293	60		rts				rts
.01a294					FPUNormalise:
.01a294	48		pha				pha
.01a295	34 85		bit $85,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.01a297	70 18		bvs $01a2b1			bvs 	_FPUNExit
.01a299	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.01a29b	f0 10		beq $01a2ad			beq 	_FPUNSetZero
.01a29d					_FPUNLoop:
.01a29d	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.01a29f	30 10		bmi $01a2b1			bmi 	_FPUNExit 					; if so, we are normalised.
.01a2a1	16 80		asl $80,x			asl 	0+XS_Mantissa+0,x
.01a2a3	36 81		rol $81,x			rol 	1+XS_Mantissa+0,x
.01a2a5	36 82		rol $82,x			rol 	2+XS_Mantissa+0,x
.01a2a7	36 83		rol $83,x			rol 	3+XS_Mantissa+0,x
.01a2a9	d6 84		dec $84,x			dec 	XS_Exponent,x 				; decrement exponent
.01a2ab	d0 f0		bne $01a29d			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.01a2ad					_FPUNSetZero:
.01a2ad	a9 40		lda #$40			lda 	#$40
.01a2af	95 85		sta $85,x			sta 	XS_Type,x 					; the result is now zero.
.01a2b1					_FPUNExit:
.01a2b1	68		pla				pla
.01a2b2	60		rts				rts
.01a2b3					FPUToInteger:
.01a2b3	48		pha				pha
.01a2b4	b5 85		lda $85,x			lda 	XS_Type,x 					; if already integer, exit
.01a2b6	29 01		and #$01			and 	#1
.01a2b8	d0 31		bne $01a2eb			bne 	_FPUTOI_Exit
.01a2ba	34 85		bit $85,x			bit 	XS_Type,x					; if zero, return zero.
.01a2bc	70 23		bvs $01a2e1			bvs 	_FPUTOI_Zero
.01a2be	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.01a2c0	10 1f		bpl $01a2e1			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.01a2c2	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.01a2c4	b0 2b		bcs $01a2f1			bcs 	FP_Overflow
.01a2c6					_FPUToIToInteger:
.01a2c6	b5 84		lda $84,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.01a2c8	c9 a0		cmp #$a0			cmp 	#128+32
.01a2ca	f0 0c		beq $01a2d8			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.01a2cc	f6 84		inc $84,x			inc 	XS_Exponent,X 				; increment Exponent
.01a2ce	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.01a2d0	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a2d2	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a2d4	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a2d6	80 ee		bra $01a2c6			bra 	_FPUToIToInteger 			; keep going.
.01a2d8					_FPUToICheckSign:
.01a2d8	b5 85		lda $85,x			lda 	XS_Type,x 					; check sign
.01a2da	10 0f		bpl $01a2eb			bpl 	_FPUToI_Exit 				; exit if unsigned.
.01a2dc	20 4b a2	jsr $01a24b			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.01a2df	80 0a		bra $01a2eb			bra 	_FPUTOI_Exit
.01a2e1					_FPUTOI_Zero:
.01a2e1	a9 00		lda #$00			lda 	#0 							; return zero integer.
.01a2e3	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a2e5	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a2e7	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a2e9	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a2eb					_FPUToI_Exit:
.01a2eb	a9 01		lda #$01			lda 	#1 							; set type to integer
.01a2ed	95 85		sta $85,x			sta 	XS_Type,x
.01a2ef	68		pla				pla
.01a2f0	60		rts				rts
.01a2f1					FP_Overflow:
.01a2f1	20 79 85	jsr $018579			jsr ERR_Handler
>01a2f4	46 6c 6f 61 74 69 6e 67			.text "Floating Point overflow",0
>01a2fc	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.01a30c					FPUTimes10:
.01a30c	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.01a30e	85 1a		sta $1a				sta 	ZLTemp1+0
.01a310	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a312	85 1b		sta $1b				sta 	ZLTemp1+1
.01a314	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a316	85 1c		sta $1c				sta 	ZLTemp1+2
.01a318	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a31a	85 1d		sta $1d				sta 	ZLTemp1+3
.01a31c	20 51 a3	jsr $01a351			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.01a31f	20 51 a3	jsr $01a351			jsr 	_FPUT_LSR_ZLTemp1
.01a322	18		clc				clc
.01a323	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.01a325	65 1a		adc $1a				adc 	ZLTemp1+0
.01a327	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a329	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a32b	65 1b		adc $1b				adc 	ZLTemp1+1
.01a32d	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a32f	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a331	65 1c		adc $1c				adc 	ZLTemp1+2
.01a333	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a335	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a337	65 1d		adc $1d				adc 	ZLTemp1+3
.01a339	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a33b	90 0a		bcc $01a347			bcc 	_FPUTimes10
.01a33d	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.01a33f	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a341	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a343	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a345	f6 84		inc $84,x			inc 	XS_Exponent,x				; fix exponent
.01a347					_FPUTimes10:
.01a347	b5 84		lda $84,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.01a349	18		clc				clc
.01a34a	69 03		adc #$03			adc 	#3
.01a34c	95 84		sta $84,x			sta 	XS_Exponent,x
.01a34e	b0 a1		bcs $01a2f1			bcs 	FP_Overflow 				; error
.01a350	60		rts				rts
.01a351					_FPUT_LSR_ZLTemp1:
.01a351	46 1d		lsr $1d				lsr 	ZLTemp1+3
.01a353	66 1c		ror $1c				ror 	ZLTemp1+2
.01a355	66 1b		ror $1b				ror 	ZLTemp1+1
.01a357	66 1a		ror $1a				ror 	ZLTemp1+0
.01a359	60		rts				rts
.01a35a					FPUScale10A:
.01a35a	5a		phy				phy
.01a35b	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.01a35d	f0 37		beq $01a396			beq 	_FPUScaleExit
.01a35f	da		phx				phx 								; save X
.01a360	e8		inx				inx
.01a361	e8		inx				inx
.01a362	e8		inx				inx
.01a363	e8		inx				inx
.01a364	e8		inx				inx
.01a365	e8		inx				inx
.01a366	a8		tay				tay 								; save power scalar in Y.
.01a367	a9 00		lda #$00			lda 	#0
.01a369	95 80		sta $80,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.01a36b	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a36d	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a36f	95 85		sta $85,x			sta 	XS_Type,x
.01a371	a9 80		lda #$80			lda 	#$80
.01a373	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a375	a9 81		lda #$81			lda 	#$81
.01a377	95 84		sta $84,x			sta 	XS_Exponent,x
.01a379	5a		phy				phy 								; save 10^n on stack.
.01a37a	c0 00		cpy #$00			cpy 	#0
.01a37c	10 05		bpl $01a383			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.01a37e	98		tya				tya
.01a37f	49 ff		eor #$ff			eor 	#$FF
.01a381	1a		inc a				inc 	a
.01a382	a8		tay				tay
.01a383					_FPUSAbs:
.01a383	20 0c a3	jsr $01a30c			jsr 	FPUTimes10
.01a386	88		dey				dey
.01a387	d0 fa		bne $01a383			bne 	_FPUSAbs 					; tos is now 10^|AC|
.01a389	68		pla				pla 								; restore count in A
.01a38a	fa		plx				plx 								; restore X pointing to number to scale.
.01a38b	0a		asl a				asl 	a
.01a38c	b0 05		bcs $01a393			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.01a38e	20 ae a0	jsr $01a0ae			jsr 	FPMultiply 					; if clear multiply.
.01a391	80 03		bra $01a396			bra		_FPUScaleExit
.01a393					_FPUSDivide:
.01a393	20 3b a0	jsr $01a03b			jsr 	FPDivide
.01a396					_FPUScaleExit:
.01a396	7a		ply				ply
.01a397	60		rts				rts
.01a398					FPUCopyToNext:
.01a398	a0 06		ldy #$06			ldy 		#6
.01a39a	da		phx				phx
.01a39b					_FPUCopy1:
.01a39b	b5 80		lda $80,x			lda 	XS_Mantissa,x
.01a39d	95 86		sta $86,x			sta 	XS2_Mantissa,x
.01a39f	e8		inx				inx
.01a3a0	88		dey				dey
.01a3a1	d0 f8		bne $01a39b			bne 	_FPUCopy1
.01a3a3	fa		plx				plx
.01a3a4	60		rts				rts
.01a3a5					FPUCopyFromNext:
.01a3a5	a0 06		ldy #$06			ldy 		#6
.01a3a7	da		phx				phx
.01a3a8					_FPUCopy1:
.01a3a8	b5 86		lda $86,x			lda 	XS2_Mantissa,x
.01a3aa	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a3ac	e8		inx				inx
.01a3ad	88		dey				dey
.01a3ae	d0 f8		bne $01a3a8			bne 	_FPUCopy1
.01a3b0	fa		plx				plx
.01a3b1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.01a3b2					FPToString:
.01a3b2	48		pha				pha
.01a3b3	5a		phy				phy
.01a3b4	34 85		bit $85,x			bit 		XS_Type,x 				; check zero flag
.01a3b6	50 0a		bvc $01a3c2			bvc 		_FPTSIsFloat 			; if zero,
.01a3b8					_FPTSZero:
.01a3b8	a9 30		lda #$30			lda 		#"0"
.01a3ba	20 dc 9e	jsr $019edc			jsr 		ITSOutputCharacter
.01a3bd					_FPTSExit:
.01a3bd	7a		ply				ply
.01a3be	68		pla				pla
.01a3bf	60		rts				rts
.01a3c0	80 fb		bra $01a3bd			bra 		_FPTSExit
.01a3c2					_FPTSIsFloat:
.01a3c2	b5 85		lda $85,x			lda 		XS_Type,x 				; is it signed ?
.01a3c4	10 09		bpl $01a3cf			bpl 		_FPTSNotSigned
.01a3c6	a9 00		lda #$00			lda 		#0 						; clear sign flag
.01a3c8	95 85		sta $85,x			sta 		XS_Type,x
.01a3ca	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.01a3cc	20 dc 9e	jsr $019edc			jsr 		ITSOutputCharacter
.01a3cf					_FPTSNotSigned:
.01a3cf	b5 84		lda $84,x			lda 		XS_Exponent,x
.01a3d1	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.01a3d3	b0 09		bcs $01a3de			bcs 		_FPTSExponent
.01a3d5	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.01a3d7	90 05		bcc $01a3de			bcc 		_FPTSExponent 			;
.01a3d9					_FPTSStandard:
.01a3d9	20 1d a4	jsr $01a41d			jsr 		FPTOutputBody 			; output the body.
.01a3dc	80 df		bra $01a3bd			bra 		_FPTSExit
.01a3de					_FPTSExponent:
.01a3de	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.01a3e0	8d 9d 03	sta $039d			sta 		ExpCount
.01a3e3					_FPTSExponentLoop:
.01a3e3	b5 84		lda $84,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.01a3e5	10 0e		bpl $01a3f5			bpl 		_FPTSTimes
.01a3e7	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.01a3e9	90 14		bcc $01a3ff			bcc 		_FPTSScaledToExp
.01a3eb	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.01a3ed	20 5a a3	jsr $01a35a			jsr 		FPUScale10A
.01a3f0	ee 9d 03	inc $039d			inc 		ExpCount
.01a3f3	80 ee		bra $01a3e3			bra 		_FPTSExponentLoop
.01a3f5					_FPTSTimes:
.01a3f5	a9 01		lda #$01			lda 		#1
.01a3f7	20 5a a3	jsr $01a35a			jsr 		FPUScale10A
.01a3fa	ce 9d 03	dec $039d			dec 		ExpCount
.01a3fd	80 e4		bra $01a3e3			bra 		_FPTSExponentLoop
.01a3ff					_FPTSScaledToExp:
.01a3ff	20 1d a4	jsr $01a41d			jsr 		FPTOutputBody 			; output the body.
.01a402	a9 65		lda #$65			lda 		#"e"					; output E
.01a404	20 dc 9e	jsr $019edc			jsr 		ITSOutputCharacter
.01a407	ad 9d 03	lda $039d			lda 		ExpCount 				; get the exponent
.01a40a	95 80		sta $80,x			sta 		XS_Mantissa,x
.01a40c	29 80		and #$80			and 		#$80 					; sign extend it
.01a40e	f0 02		beq $01a412			beq 		_FPTSSExt
.01a410	a9 ff		lda #$ff			lda 		#$FF
.01a412					_FPTSSExt:
.01a412	95 81		sta $81,x			sta 		XS_Mantissa+1,x
.01a414	95 82		sta $82,x			sta 		XS_Mantissa+2,x
.01a416	95 83		sta $83,x			sta 		XS_Mantissa+3,x
.01a418	20 3a 9e	jsr $019e3a			jsr 		INTToString 			; output the exponent.
.01a41b	80 a0		bra $01a3bd			bra			_FPTSExit 				; and exit.
.01a41d					FPTOutputBody:
.01a41d	20 98 a3	jsr $01a398			jsr 		FPUCopyToNext 			; copy to next slot.
.01a420	20 b3 a2	jsr $01a2b3			jsr 		FPUToInteger 			; convert to an integer
.01a423	20 3a 9e	jsr $019e3a			jsr 		INTToString 			; output the main integer part.
.01a426	20 a5 a3	jsr $01a3a5			jsr 		FPUCopyFromNext 		; get the fractional part back.
.01a429	20 36 a1	jsr $01a136			jsr 		FPFractionalPart 		; get the decimal part.
.01a42c	34 85		bit $85,x			bit 		XS_Type,x 				; any fractional part.
.01a42e	70 3c		bvs $01a46c			bvs 		_FPTOExit 				; if not, exit now.
.01a430	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.01a432	20 dc 9e	jsr $019edc			jsr 		ITSOutputCharacter
.01a435					_FPOutLoop:
.01a435	34 85		bit $85,x			bit 		XS_Type,x 				; finally reached zero.
.01a437	70 1d		bvs $01a456			bvs 		_FPStripZeros 			; strip trailing zeros
.01a439	20 0c a3	jsr $01a30c			jsr 		FPUTimes10 				; multiply by 10
.01a43c	20 98 a3	jsr $01a398			jsr 		FPUCopyToNext			; copy to next slot.
.01a43f	20 b3 a2	jsr $01a2b3			jsr 		FPUToInteger 			; convert to integer
.01a442	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; print digit.
.01a444	09 30		ora #$30			ora 		#"0"
.01a446	20 dc 9e	jsr $019edc			jsr 		ITSOutputCharacter
.01a449	20 a5 a3	jsr $01a3a5			jsr 		FPUCopyFromNext 		; get it back
.01a44c	20 36 a1	jsr $01a136			jsr 		FPFractionalPart 		; get fractional part
.01a44f	ad 14 03	lda $0314			lda 		NumBufX 				; done 11 characters yet ?
.01a452	c9 0b		cmp #$0b			cmp 	 	#11
.01a454	90 df		bcc $01a435			bcc 		_FPOutLoop 				; if so, keep going till zero.
.01a456					_FPStripZeros:
.01a456	ac 14 03	ldy $0314			ldy 		NumBufX 				; strip trailing zeros.
.01a459					_FPStripLoop:
.01a459	88		dey				dey 								; back one, if at start then no strip
.01a45a	f0 10		beq $01a46c			beq 		_FPToExit
.01a45c	b9 15 03	lda $0315,y			lda 		Num_Buffer,y 			; keep going if "0"
.01a45f	c9 30		cmp #$30			cmp 		#"0"
.01a461	f0 f6		beq $01a459			beq 		_FPStripLoop
.01a463	c8		iny				iny
.01a464	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.01a466	99 15 03	sta $0315,y			sta 		Num_Buffer,y
.01a469	8c 14 03	sty $0314			sty 		NumBufX 				; update position.
.01a46c					_FPTOExit:
.01a46c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.01a46d					FPFromString:
.01a46d	48		pha				pha 								; push A
.01a46e	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.01a470	c9 2e		cmp #$2e			cmp 	#"."
.01a472	f0 03		beq $01a477			beq	 	_FPFIsDecimal
.01a474	4c d3 a4	jmp $01a4d3			jmp 	_FPFNotDecimal
.01a477					_FPFIsDecimal:
.01a477	c8		iny				iny 								; consume the decimal.
.01a478	20 67 a2	jsr $01a267			jsr 	FPUToFloat 					; convert the integer to float.
.01a47b	da		phx				phx 								; save X.
.01a47c	5a		phy				phy 								; save decimal start position
.01a47d	e8		inx				inx
.01a47e	e8		inx				inx
.01a47f	e8		inx				inx
.01a480	e8		inx				inx
.01a481	e8		inx				inx
.01a482	e8		inx				inx
.01a483	20 f4 9e	jsr $019ef4			jsr 	INTFromStringY 				; get the part after the DP.
.01a486	20 67 a2	jsr $01a267			jsr 	FPUToFloat 					; convert that to a float.
.01a489	68		pla				pla 								; calculate - chars consumed.
.01a48a	8c 9c 03	sty $039c			sty 	ExpTemp
.01a48d	38		sec				sec
.01a48e	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; this is the shift amount
.01a491	20 5a a3	jsr $01a35a			jsr 	FPUScale10A 				; scale it by 10^AC
.01a494	fa		plx				plx 								; restore original X
.01a495	20 87 9f	jsr $019f87			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.01a498	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.01a49a	c9 45		cmp #$45			cmp 	#"E"
.01a49c	f0 04		beq $01a4a2			beq 	_FPFExponent
.01a49e	c9 65		cmp #$65			cmp 	#"e"
.01a4a0	d0 31		bne $01a4d3			bne 	_FPFNotDecimal 				; no, then exit normally.
.01a4a2					_FPFExponent:
.01a4a2	c8		iny				iny 								; skip over E symbol.
.01a4a3	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.01a4a5	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.01a4a7	d0 01		bne $01a4aa			bne 	_FPFGotSign
.01a4a9	c8		iny				iny 								; if it was - skip over it.
.01a4aa					_FPFGotSign:
.01a4aa	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.01a4ab	da		phx				phx
.01a4ac	e8		inx				inx
.01a4ad	e8		inx				inx
.01a4ae	e8		inx				inx
.01a4af	e8		inx				inx
.01a4b0	e8		inx				inx
.01a4b1	e8		inx				inx
.01a4b2	20 f4 9e	jsr $019ef4			jsr 	INTFromStringY 				; get the exponent
.01a4b5	fa		plx				plx 								; restore X.
.01a4b6	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.01a4b8	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.01a4ba	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.01a4bc	d0 17		bne $01a4d5			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.01a4be	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.01a4c0	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.01a4c2	b0 11		bcs $01a4d5			bcs 	_FPFXOverflow
.01a4c4	68		pla				pla 								; get direction
.01a4c5	d0 07		bne $01a4ce			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.01a4c7	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.01a4c9	49 ff		eor #$ff			eor 	#$FF
.01a4cb	1a		inc a				inc 	a
.01a4cc	95 86		sta $86,x			sta 	XS2_Mantissa+0,x
.01a4ce					_FPFXScale:
.01a4ce	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.01a4d0	20 5a a3	jsr $01a35a			jsr 	FPUScale10A 				; scale by the exponent.
.01a4d3					_FPFNotDecimal:
.01a4d3	68		pla				pla
.01a4d4	60		rts				rts
.01a4d5					_FPFXOverflow:
.01a4d5	20 79 85	jsr $018579			jsr 	ERR_Handler
>01a4d8	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>01a4e0	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.01a4e7					Unary_Rnd:
.01a4e7	20 58 92	jsr $019258			jsr 	EvaluateNumberX 			; get value
.01a4ea	20 aa 98	jsr $0198aa			jsr 	CheckNextRParen 			; check right bracket.
.01a4ed	20 d6 94	jsr $0194d6			jsr 	GetSignCurrent 				; get sign -1,0,1.
.01a4f0	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.01a4f2	30 10		bmi $01a504			bmi 	_URSetSeed
.01a4f4	f0 28		beq $01a51e			beq 	_URMakeRandom 				; if zero return same number, don't advance sequence
.01a4f6	da		phx				phx
.01a4f7	a2 00		ldx #$00			ldx 	#0 							; run 16 bit RNG procession on upper/lower
.01a4f9	20 55 a5	jsr $01a555			jsr 	Random16
.01a4fc	a2 02		ldx #$02			ldx 	#2
.01a4fe	20 55 a5	jsr $01a555			jsr 	Random16
.01a501	fa		plx				plx
.01a502	80 1a		bra $01a51e			bra 	_URMakeRandom
.01a504					_URSetSeed:
.01a504	20 67 a2	jsr $01a267			jsr 	FPUToFloat 					; make it a float to twiddle it.
.01a507	b5 80		lda $80,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.01a509	8d a3 03	sta $03a3			sta 	RandomSeed+0
.01a50c	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.01a50e	8d a4 03	sta $03a4			sta 	RandomSeed+1
.01a511	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.01a513	8d a5 03	sta $03a5			sta 	RandomSeed+2
.01a516	b5 83		lda $83,x			lda		XS_Mantissa+3,x 			; this is to make the seed bear not much
.01a518	0a		asl a				asl 	a 							; resemblance to the seed value.
.01a519	49 db		eor #$db			eor 	#$DB
.01a51b	8d a6 03	sta $03a6			sta 	RandomSeed+3
.01a51e					_URMakeRandom:
.01a51e	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; check if seed is zero.
.01a521	0d a4 03	ora $03a4			ora 	RandomSeed+1
.01a524	0d a5 03	ora $03a5			ora 	RandomSeed+2
.01a527	0d a6 03	ora $03a6			ora 	RandomSeed+3
.01a52a	d0 0a		bne $01a536			bne 	_URNotZero
.01a52c	a9 47		lda #$47			lda 	#$47						; if it is, make it non zero.
.01a52e	8d a4 03	sta $03a4			sta 	RandomSeed+1				; in both parts.
.01a531	a9 3d		lda #$3d			lda 	#$3D
.01a533	8d a6 03	sta $03a6			sta 	RandomSeed+3
.01a536					_URNotZero:
.01a536	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; copy seed into mantissa.
.01a539	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a53b	ad a4 03	lda $03a4			lda 	RandomSeed+1
.01a53e	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a540	ad a5 03	lda $03a5			lda 	RandomSeed+2
.01a543	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a545	ad a6 03	lda $03a6			lda 	RandomSeed+3
.01a548	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a54a	a9 00		lda #$00			lda 	#$00 						; set type to float.
.01a54c	95 85		sta $85,x			sta 	XS_Type,x
.01a54e	a9 80		lda #$80			lda 	#$80
.01a550	95 84		sta $84,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.01a552	4c 94 a2	jmp $01a294			jmp 	FPUNormalise 				; and normalise.
.01a555					Random16:
.01a555	5e a4 03	lsr $03a4,x			lsr 	RandomSeed+1,x				; shift seed right
.01a558	7e a3 03	ror $03a3,x			ror 	RandomSeed,x
.01a55b	90 08		bcc $01a565			bcc 	_R16_NoXor
.01a55d	bd a4 03	lda $03a4,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.01a560	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.01a562	9d a4 03	sta $03a4,x			sta 	RandomSeed+1,x
.01a565					_R16_NoXor:
.01a565	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.01a566					Unary_Int:
.01a566	20 58 92	jsr $019258			jsr 	EvaluateNumberX 			; get value
.01a569	20 aa 98	jsr $0198aa			jsr 	CheckNextRParen 			; check right bracket.
.01a56c	4c b3 a2	jmp $01a2b3			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Return to file: basic.asm

>01a56f	02						.byte 	2
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 c0						.word 	StartROM
>fffe	19 c0					.word TIM_BreakHandler

;******  End of listing
