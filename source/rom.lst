
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Sun Aug 25 09:32:42 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="65816"				cpu = "65816"
="em65816"				hardware = "em65816"
=1					exitonend = 1
=0					autorun = 0
=0					loadtest = 0
=1					hasfloat = 1
=1					hasinteger = 1
=253					maxstring = 253

;******  Processing file: modules/float/fpmacros.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/em65816/src_em65816.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0020					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0200					IFT_XCursor:.byte ?							; current logical position on screen
>0201					IFT_YCursor:.byte ?
>0202					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0266					IFT_LineBuffer: .fill 100 					; line input buffer.
>0300					UserVector .fill 4 							; USR(x) calls this.
>0304					LocalVector .fill 4 						; Indirect calls call this.
>0308					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>030c					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>030d					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=782					XS2_Mantissa = XS_Mantissa+XS_Size
=786					XS2_Exponent = XS_Exponent+XS_Size
=787					XS2_Type = XS_Type+XS_Size
=788					XS3_Mantissa = XS_Mantissa+XS_Size*2
=792					XS3_Exponent = XS_Exponent+XS_Size*2
=793					XS3_Type = XS_Type+XS_Size*2
>0400					NumBufX 	.byte 	?						; buffer index position
>0401					Num_Buffer	.fill 	32 						; buffer for numeric conversions
=$401					Var_Buffer 	= Num_Buffer 					; buffer for variable name (same space)
>0421					Var_Type    .byte ? 						; type of variable (as a type token)
>0422					Var_Hash 	.byte ? 						; hash of identifier name.
>0423					Var_Length 	.byte ? 						; length of variable name
>0424					NumSuppress	.byte 	?						; leading zero suppression flag
>0425					NumConvCount .byte 	? 						; count for conversions.
>0426					ExpTemp:	.byte ?							; Working temp for exponents.
>0427					ExpCount:	.byte ? 						; Count of decimal exponents.
>0428					SignCount:	.byte ?							; Integer Divide Sign Counts.
>0429					StringPtr:	.word ? 						; Top of free memory (for string allocation)
>042b					TempStringWriteIndex: .byte ? 				; Write offset.
>042c					ValSign: 	.byte ? 						; sign flag for val()
>042d					SliceStart:	.byte ? 						; string slice parts
>042e					SliceCount:	.byte ?
>042f					RandomSeed:	.dword ? 						; Random seed.
>0433					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>0435					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>0437					Tim_SR:		.byte ? 						; Processor Status
>0438					Tim_A:		.byte ? 						; Processor Registers
>0439					Tim_X:		.byte ?
>043a					Tim_Y:		.byte ?
>043b					Tim_Z:		.byte ?
>043c					Tim_SP:		.word ?							; Stack Pointer (just in cases)
=6					HashTableCount = 6 							; there are 6 hash tables, in token order.
=8					HashTableSize = 8 							; each hash table as 8 links.
.043e					HashTableBase:
>043e								.fill	HashTableCount * HashTableSize * 2
.049e					HashTableEnd:

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/em65816.asm

=$8000					HighMemory = $8000
.1000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testcode.src

>1000	10 02 00 d4 14 05 13 14			.byte	$10,$02,$00,$d4,$14,$05,$13,$14
>1008	bd 56 8d 47 fd 03 30 00			.byte	$bd,$56,$8d,$47,$fd,$03,$30,$00
>1010	05 03 00 c2 00 00			.byte	$05,$03,$00,$c2,$00,$00

;******  Return to file: modules/hardware/em65816.asm

.c000					StartROM:
.c000	18		clc				clc
.c001	fb		xce				xce
.c002	c2 30		rep #$30			rep 	#$30
.c004	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.c007	1b		tcs				tcs
.c008	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.c00b	e2 30		sep #$30			sep 	#$30
.c00d	c2 30		rep #$30			rep 	#$30						; clear AXY in 16 bit.
.c00f	a9 00		lda #$00			lda 	#$0000
.c011	aa		tax				tax
.c012	a8		tay				tay
.c013	e2 30		sep #$30			sep 	#$30
.c015	5c 95 84 01	jmp $018495		jmp BASIC_Start
.c019					TIM_BreakHandler:
.c019	5c 93 99 01	jmp $019993			jmp 	TIM_BreakVector

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.018000					IFT_ClearScreen:
.018000	48		pha				pha
.018001	da		phx				phx
.018002	5a		phy				phy
.018003	20 a9 81	jsr $0181a9			jsr 	IF_Home 					; home cursor
.018006	a2 20		ldx #$20			ldx 	#IF_Height 					; this many lines.
.018008					_IFT_CS0:
.018008	a0 40		ldy #$40			ldy 	#IF_Width 					; this many chars/line
.01800a					_IFT_CS1:
.01800a	a9 20		lda #$20			lda 	#' '						; clear line.
.01800c	20 d5 81	jsr $0181d5			jsr 	IF_Write
.01800f	88		dey				dey
.018010	d0 f8		bne $01800a			bne 	_IFT_CS1
.018012	20 bc 81	jsr $0181bc			jsr 	IF_NewLine 					; next line down
.018015	ca		dex				dex
.018016	d0 f0		bne $018008			bne 	_IFT_CS0
.018018	7a		ply				ply
.018019	fa		plx				plx
.01801a	68		pla				pla
.01801b					IFT_HomeCursor:
.01801b	48		pha				pha
.01801c	20 a9 81	jsr $0181a9			jsr 	IF_Home
.01801f	a9 00		lda #$00			lda 	#0
.018021	8d 00 02	sta $0200			sta 	IFT_XCursor
.018024	8d 01 02	sta $0201			sta 	IFT_YCursor
.018027	68		pla				pla
.018028	60		rts				rts
.018029					IFT_UpLine:
.018029	48		pha				pha
.01802a	ad 01 02	lda $0201			lda  	IFT_YCursor 				; get Y
.01802d	3a		dec a				dec 	a 							; line above
.01802e	30 03		bmi $018033			bmi 	_IFTULExit 					; too far, abort
.018030	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos					; set to that line.
.018033					_IFTULExit:
.018033	68		pla				pla
.018034	60		rts				rts
.018035					IFT_PrintCharacter:
.018035	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.018037	f0 23		beq $01805c			beq 	IFT_NewLine
.018039	48		pha				pha
.01803a	20 74 80	jsr $018074			jsr 	IFT_UpperCase 				; make upper case
.01803d	20 d5 81	jsr $0181d5			jsr 	IF_Write 					; write out.
.018040	ee 00 02	inc $0200			inc 	IFT_XCursor 				; bump x cursor
.018043	ad 00 02	lda $0200			lda 	IFT_XCursor 				; reached RHS ?
.018046	c9 40		cmp #$40			cmp 	#IF_Width
.018048	d0 03		bne $01804d			bne 	_IFT_PCNotEOL
.01804a	20 5c 80	jsr $01805c			jsr 	IFT_NewLine 				; if so do new line.
.01804d					_IFT_PCNotEOL:
.01804d	68		pla				pla
.01804e	60		rts				rts
.01804f					IFT_Tab:
.01804f	a9 20		lda #$20			lda 	#" " 						; space
.018051	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018054	ad 00 02	lda $0200			lda 	IFT_XCursor 				; until x % 8 == 0
.018057	29 07		and #$07			and 	#7
.018059	d0 f4		bne $01804f			bne 	IFT_Tab
.01805b	60		rts				rts
.01805c					IFT_NewLine:
.01805c	48		pha				pha
.01805d	20 bc 81	jsr $0181bc			jsr 	IF_NewLine 					; new line on actual screen.
.018060	a9 00		lda #$00			lda 	#0 							; reset x position
.018062	8d 00 02	sta $0200			sta 	IFT_XCursor
.018065	ee 01 02	inc $0201			inc 	IFT_YCursor 				; move down.
.018068	ad 01 02	lda $0201			lda 	IFT_YCursor
.01806b	c9 20		cmp #$20			cmp 	#IF_Height 					; reached bottom.
.01806d	d0 03		bne $018072			bne 	_IFT_NL_NotEOS
.01806f	20 7f 80	jsr $01807f			jsr 	IFT_Scroll 					; scroll screen up.
.018072					_IFT_NL_NotEOS:
.018072	68		pla				pla
.018073	60		rts				rts
.018074					IFT_UpperCase:
.018074	c9 61		cmp #$61			cmp 	#"a"
.018076	90 06		bcc $01807e			bcc 	_IFT_UCExit
.018078	c9 7b		cmp #$7b			cmp 	#"z"+1
.01807a	b0 02		bcs $01807e			bcs 	_IFT_UCExit
.01807c	49 20		eor #$20			eor 	#$20
.01807e					_IFT_UCExit:
.01807e	60		rts				rts
.01807f					IFT_Scroll:
.01807f	48		pha				pha 								; save AXY
.018080	da		phx				phx
.018081	5a		phy				phy
.018082	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.018084					_IFT_SLoop:
.018084	20 a4 80	jsr $0180a4			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.018087	e8		inx				inx
.018088	e0 1f		cpx #$1f			cpx 	#IF_Height-1				; do whole screen
.01808a	d0 f8		bne $018084			bne 	_IFT_SLoop
.01808c	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.01808e	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.018091	a2 40		ldx #$40			ldx 	#IF_Width 					; blank line
.018093					_IFT_SBlank:
.018093	a9 20		lda #$20			lda 	#32
.018095	20 d5 81	jsr $0181d5			jsr 	IF_Write
.018098	ca		dex				dex
.018099	d0 f8		bne $018093			bne 	_IFT_SBlank
.01809b	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.01809d	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.0180a0	7a		ply				ply
.0180a1	fa		plx				plx
.0180a2	68		pla				pla
.0180a3	60		rts				rts
.0180a4					_IFT_ScrollLine:
.0180a4	da		phx				phx
.0180a5	da		phx				phx
.0180a6	8a		txa				txa 								; copy line into buffer.
.0180a7	1a		inc a				inc 	a 							; next line down.
.0180a8	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.0180ab	a2 00		ldx #$00			ldx 	#0
.0180ad					_IFTScrollCopy1:
.0180ad	20 cc 81	jsr $0181cc			jsr 	IF_Read
.0180b0	9d 02 02	sta $0202,x			sta 	IFT_Buffer,x
.0180b3	e8		inx				inx
.0180b4	e0 40		cpx #$40			cpx 	#IF_Width
.0180b6	d0 f5		bne $0180ad			bne 	_IFTScrollCopy1
.0180b8	68		pla				pla
.0180b9	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.0180bc	a2 00		ldx #$00			ldx 	#0
.0180be					_IFTScrollCopy2:
.0180be	bd 02 02	lda $0202,x			lda 	IFT_Buffer,x
.0180c1	20 d5 81	jsr $0181d5			jsr 	IF_Write
.0180c4	e8		inx				inx
.0180c5	e0 40		cpx #$40			cpx 	#IF_Width
.0180c7	d0 f5		bne $0180be			bne 	_IFTScrollCopy2
.0180c9	fa		plx				plx
.0180ca	60		rts				rts
.0180cb					IFT_SetYPos:
.0180cb	48		pha				pha
.0180cc	da		phx				phx
.0180cd	aa		tax				tax
.0180ce	20 1b 80	jsr $01801b			jsr 	IFT_HomeCursor
.0180d1	e0 00		cpx #$00			cpx 	#0
.0180d3	f0 09		beq $0180de			beq 	_IFT_MOAExit
.0180d5					_IFT_MOALoop:
.0180d5	20 bc 81	jsr $0181bc			jsr 	IF_NewLine
.0180d8	ee 01 02	inc $0201			inc 	IFT_YCursor
.0180db	ca		dex				dex
.0180dc	d0 f7		bne $0180d5			bne		_IFT_MOALoop
.0180de					_IFT_MOAExit:
.0180de	fa		plx				plx
.0180df	68		pla				pla
.0180e0	60		rts				rts
.0180e1					IFT_GetKeyCursor:
.0180e1	20 e9 80	jsr $0180e9			jsr 	_IFT_FlipCursor 			; reverse current
.0180e4					_IFT_GKCWait:
.0180e4	20 e6 81	jsr $0181e6			jsr 	IF_GetKey 					; get key
.0180e7	f0 fb		beq $0180e4			beq 	_IFT_GKCWait
.0180e9					_IFT_FlipCursor:
.0180e9	48		pha				pha 								; save
.0180ea	20 cc 81	jsr $0181cc			jsr 	IF_Read 					; read
.0180ed	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.0180f0	49 80		eor #$80			eor 	#$80 						; reverse
.0180f2	20 d5 81	jsr $0181d5			jsr 	IF_Write 					; write
.0180f5	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.0180f8	68		pla				pla
.0180f9	60		rts				rts
.0180fa					IFT_ReadLine:
.0180fa	48		pha				pha
.0180fb					_IFT_RLLoop:
.0180fb	20 e1 80	jsr $0180e1			jsr 	IFT_GetKeyCursor 			; get keystroke
.0180fe	c9 0d		cmp #$0d			cmp 	#13							; return
.018100	f0 7d		beq $01817f			beq 	_IFT_RLExit
.018102	c9 20		cmp #$20			cmp 	#32 						; control character
.018104	90 05		bcc $01810b			bcc 	_IFT_Control
.018106	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018109	80 f0		bra $0180fb			bra 	_IFT_RLLoop
.01810b					_IFT_Control:
.01810b	c9 01		cmp #$01			cmp 	#"A"-64
.01810d	f0 26		beq $018135			beq 	_IFT_Left
.01810f	c9 04		cmp #$04			cmp 	#"D"-64
.018111	f0 2e		beq $018141			beq 	_IFT_Right
.018113	c9 17		cmp #$17			cmp 	#"W"-64
.018115	f0 36		beq $01814d			beq 	_IFT_Up
.018117	c9 13		cmp #$13			cmp 	#"S"-64
.018119	f0 3e		beq $018159			beq 	_IFT_Down
.01811b	c9 08		cmp #$08			cmp 	#"H"-64
.01811d	f0 09		beq $018128			beq 	_IFT_Backspace
.01811f	c9 1a		cmp #$1a			cmp 	#"Z"-64
.018121	d0 d8		bne $0180fb			bne 	_IFT_RLLoop
.018123	20 00 80	jsr $018000			jsr 	IFT_ClearScreen				; clear CTL-Z
.018126	80 d3		bra $0180fb			bra 	_IFT_RLLoop
.018128					_IFT_Backspace:
.018128	ad 00 02	lda $0200			lda 	IFT_XCursor 				; check not start of line.
.01812b	f0 ce		beq $0180fb			beq 	_IFT_RLLoop
.01812d	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.018130	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.018132	20 d5 81	jsr $0181d5			jsr 	IF_Write
.018135					_IFT_Left:
.018135	ce 00 02	dec $0200			dec 	IFT_XCursor 				; left CTL-W
.018138	10 29		bpl $018163			bpl 	_IFT_Reposition
.01813a	a9 3f		lda #$3f			lda 	#IF_Width-1
.01813c					_IFT_SetX:
.01813c	8d 00 02	sta $0200			sta 	IFT_XCursor
.01813f	80 22		bra $018163			bra 	_IFT_Reposition
.018141					_IFT_Right:
.018141	ee 00 02	inc $0200			inc 	IFT_XCursor
.018144	ad 00 02	lda $0200			lda 	IFT_XCursor
.018147	49 40		eor #$40			eor 	#IF_Width
.018149	f0 f1		beq $01813c			beq 	_IFT_SetX
.01814b	80 16		bra $018163			bra 	_IFT_Reposition
.01814d					_IFT_Up:
.01814d	ce 01 02	dec $0201			dec 	IFT_YCursor
.018150	10 11		bpl $018163			bpl 	_IFT_Reposition
.018152	a9 1f		lda #$1f			lda 	#IF_Height-1
.018154					_IFT_SetY:
.018154	8d 01 02	sta $0201			sta 	IFT_YCursor
.018157	80 0a		bra $018163			bra 	_IFT_Reposition
.018159					_IFT_Down:
.018159	ee 01 02	inc $0201			inc 	IFT_YCursor
.01815c	ad 01 02	lda $0201			lda 	IFT_YCursor
.01815f	49 20		eor #$20			eor 	#IF_Height
.018161	f0 f1		beq $018154			beq 	_IFT_SetY
.018163					_IFT_Reposition:
.018163	ad 00 02	lda $0200			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.018166	48		pha				pha
.018167	ad 01 02	lda $0201			lda 	IFT_YCursor
.01816a	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.01816d	68		pla				pla
.01816e	aa		tax				tax
.01816f	e0 00		cpx #$00			cpx 	#0
.018171	f0 88		beq $0180fb			beq 	_IFT_RLLoop
.018173					_IFT_MoveRight:
.018173	20 cc 81	jsr $0181cc			jsr 	IF_Read
.018176	ee 00 02	inc $0200			inc 	IFT_XCursor
.018179	ca		dex				dex
.01817a	d0 f7		bne $018173			bne 	_IFT_MoveRight
.01817c	4c fb 80	jmp $0180fb			jmp 	_IFT_RLLoop
.01817f					_IFT_RLExit:
.01817f	ad 01 02	lda $0201			lda 	IFT_YCursor 				; go to start of line.
.018182	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.018185	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.018187					_IFT_RLRead:
.018187	20 cc 81	jsr $0181cc			jsr 	IF_Read
.01818a	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.01818d	e8		inx				inx
.01818e	e0 40		cpx #$40			cpx 	#IF_Width
.018190	d0 f5		bne $018187			bne 	_IFT_RLRead
.018192					_IFT_RL_Trim:
.018192	ca		dex				dex 	 							; previous char
.018193	30 07		bmi $01819c			bmi 	_IFT_Found 					; gone too far
.018195	bd 66 02	lda $0266,x			lda 	IFT_LineBuffer,x			; go back if space
.018198	c9 20		cmp #$20			cmp 	#" "
.01819a	f0 f6		beq $018192			beq 	_IFT_RL_Trim
.01819c					_IFT_Found:
.01819c	e8		inx				inx 								; forward to non-space
.01819d	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.01819f	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.0181a2	68		pla				pla
.0181a3	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.0181a5	a0 02		ldy #$02			ldy 	#IFT_LineBuffer >> 8
.0181a7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_em65816.asm

=64					IF_Width 	= 64 							; characters across
=32					IF_Height 	= 32 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line.
=8					IF_XPos 	= 8 							; current position, horizontal.
=$f0000					IF_Screen = $F0000							; 2k screen RAM here
=$f8010					IF_PKeyboard = $F8010						; Keyboard port.
=$f8000					IF_PBreak = $F8000 							; Break key.
.0181a8					IF_Reset:
.0181a8	60		rts				rts
.0181a9					IF_Home:
.0181a9	48		pha				pha
.0181aa	64 08		stz $08				stz 	IF_XPos 					; zero X position
.0181ac	a9 00		lda #$00			lda 	#IF_Screen & $FF 			; set r/w pos.
.0181ae	85 04		sta $04				sta 	IF_Pos
.0181b0	a9 00		lda #$00			lda 	#(IF_Screen >> 8) & $FF
.0181b2	85 05		sta $05				sta 	IF_Pos+1
.0181b4	a9 0f		lda #$0f			lda 	#IF_Screen >> 16
.0181b6	85 06		sta $06				sta 	IF_Pos+2
.0181b8	64 07		stz $07				stz 	IF_Pos+3
.0181ba	68		pla				pla
.0181bb	60		rts				rts
.0181bc					IF_NewLine:
.0181bc	48		pha				pha
.0181bd	64 08		stz $08				stz 	IF_XPos						; back to start of line
.0181bf	18		clc				clc 								; down one line
.0181c0	a5 04		lda $04				lda 	IF_Pos
.0181c2	69 40		adc #$40			adc 	#64
.0181c4	85 04		sta $04				sta 	IF_Pos
.0181c6	90 02		bcc $0181ca			bcc 	_IF_NoCarry 				; carry through.
.0181c8	e6 05		inc $05				inc 	IF_Pos+1
.0181ca					_IF_NoCarry:
.0181ca	68		pla				pla
.0181cb	60		rts				rts
.0181cc					IF_Read:
.0181cc	5a		phy				phy 								; save current Y
.0181cd	a4 08		ldy $08				ldy 	IF_XPos 					; read character at current position
.0181cf	b7 04		lda [$04],y			lda 	[IF_Pos],y
.0181d1	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181d3	7a		ply				ply									; restore Y
.0181d4	60		rts				rts
.0181d5					IF_Write:
.0181d5	5a		phy				phy 								; save current Y
.0181d6	a4 08		ldy $08				ldy 	IF_XPos 					; write character at current position
.0181d8	97 04		sta [$04],y			sta 	[IF_Pos],y
.0181da	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181dc	7a		ply				ply									; restore Y
.0181dd	60		rts				rts
.0181de					IF_LeftOne:
.0181de	c6 08		dec $08				dec 	IF_XPos
.0181e0	60		rts				rts
.0181e1					IF_CheckBreak:
.0181e1	af 00 80 0f	lda $0f8000			lda 	IF_PBreak					; non-zero if Ctrl+C pressed.
.0181e5	60		rts				rts
.0181e6					IF_GetKey:
.0181e6	af 10 80 0f	lda $0f8010			lda 	IF_PKeyboard				; read keyboard
.0181ea	f0 08		beq $0181f4			beq		_IFGK_NoKey 				; skip if zero,no key pressed
.0181ec	48		pha				pha 								; key pressed, clear queue.
.0181ed	a9 00		lda #$00			lda 	#0
.0181ef	8f 10 80 0f	sta $0f8010			sta 	IF_PKeyboard
.0181f3	68		pla				pla
.0181f4					_IFGK_NoKey:
.0181f4	09 00		ora #$00			ora 	#0							; set Z flag appropriately.
.0181f6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/errors.asm

.0181f7					SyntaxError:
.0181f7	20 26 82	jsr $018226			jsr 	ERR_Handler
>0181fa	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>018202	72 72 6f 72 00
.018207					TypeError:
.018207	20 26 82	jsr $018226			jsr 	ERR_Handler
>01820a	57 72 6f 6e 67 20 74 79				.text 	"Wrong type",0
>018212	70 65 00
.018215					BadParamError:
.018215	20 26 82	jsr $018226			jsr 	ERR_Handler
>018218	42 61 64 20 50 61 72 61				.text 	"Bad Parameter",0
>018220	6d 65 74 65 72 00
.018226					ERR_Handler:
.018226	a0 00		ldy #$00			ldy 	#0
.018228	c8		iny				iny
.018229	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01822b	8d 08 03	sta $0308			sta 	XS_Mantissa
.01822e	c8		iny				iny
.01822f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018231	8d 09 03	sta $0309			sta 	XS_Mantissa+1
.018234	fa		plx				plx 								; address in XY
.018235	7a		ply				ply
.018236	e8		inx				inx 								; bump, because of RTS/JSR address -1
.018237	d0 01		bne $01823a			bne 	_EHNoSkip
.018239	c8		iny				iny
.01823a					_EHNoSkip:
.01823a	20 5b 82	jsr $01825b			jsr 	PrintROMMessage 			; print message from ROM.
.01823d	ad 08 03	lda $0308			lda 	XS_Mantissa					; line number = 0
.018240	0d 09 03	ora $0309			ora 	XS_Mantissa+1
.018243	f0 0c		beq $018251			beq 	_EHNoLine
.018245	a2 56		ldx #$56			ldx 	#_EHAt & $FF 				; print " at "
.018247	a0 82		ldy #$82			ldy 	#(_EHAt >> 8) & $FF
.018249	20 5b 82	jsr $01825b			jsr 	PrintROMMessage
.01824c	a2 00		ldx #$00			ldx 	#0 							; Print line number
.01824e	20 70 82	jsr $018270			jsr 	Print16BitInteger
.018251					_EHNoLine:
.018251	80 fe		bra $018251			bra 	_EHNoLine
.018253	4c b5 84	jmp $0184b5			jmp 	WarmStart
>018256	20 61 74 20 00			_EHAt:	.text 	" at ",0
.01825b					PrintROMMessage:
.01825b	86 1a		stx $1a				stx 	zLTemp1 					; save addres
.01825d	84 1b		sty $1b				sty 	zLTemp1+1
.01825f	4b		phk				phk
.018260	68		pla				pla
.018261	85 1c		sta $1c				sta 	ZLTemp1+2
.018263	a0 00		ldy #$00			ldy 	#0
.018265					_PRMLoop:
.018265	b7 1a		lda [$1a],y			lda 	[zLTemp1],y
.018267	f0 06		beq $01826f			beq		_PRMExit
.018269	c8		iny				iny
.01826a	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01826d	80 f6		bra $018265			bra 	_PRMLoop
.01826f					_PRMExit:
.01826f	60		rts				rts
.018270					Print16BitInteger:
.018270	a9 00		lda #$00			lda 	#0 							; make 32 bit
.018272	8d 0a 03	sta $030a			sta 	XS_Mantissa+2
.018275	8d 0b 03	sta $030b			sta 	XS_Mantissa+3
.018278	8d 00 04	sta $0400			sta 	NumBufX 					; reset the conversion pointer
.01827b	aa		tax				tax 								; convert bottom level.
.01827c	20 26 90	jsr $019026			jsr 	INTToString 				; make string
.01827f	a2 00		ldx #$00			ldx 	#0 							; print buffer
.018281	bd 01 04	lda $0401,x	_P1Loop:lda 	Num_Buffer,x
.018284	f0 06		beq $01828c			beq 	_P1Exit
.018286	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018289	e8		inx				inx
.01828a	80 f5		bra $018281			bra 	_P1Loop
.01828c	60		rts		_P1Exit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm


;******  Processing file: modules/basic/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b4					lastUnaryFunction = $b4
.01828d					VectorTable:
>01828d	bd 87					.word BinaryOp_And         & $FFFF ; $80 and
>01828f	e5 87					.word BinaryOp_Or          & $FFFF ; $81 or
>018291	0d 88					.word BinaryOp_Xor         & $FFFF ; $82 xor
>018293	0d 88					.word BinaryOp_Eor         & $FFFF ; $83 eor
>018295	51 88					.word Binary_Equal         & $FFFF ; $84 =
>018297	70 88					.word Binary_NotEqual      & $FFFF ; $85 <>
>018299	79 88					.word Binary_Less          & $FFFF ; $86 <
>01829b	82 88					.word Binary_LessEqual     & $FFFF ; $87 <=
>01829d	94 88					.word Binary_Greater       & $FFFF ; $88 >
>01829f	8b 88					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>0182a1	29 89					.word BinaryOp_Add         & $FFFF ; $8a +
>0182a3	49 89					.word BinaryOp_Subtract    & $FFFF ; $8b -
>0182a5	5c 89					.word BinaryOp_Multiply    & $FFFF ; $8c *
>0182a7	6f 89					.word BinaryOp_Divide      & $FFFF ; $8d /
>0182a9	41 83					.word NotImplemented       & $FFFF ; $8e ^
>0182ab	41 83					.word NotImplemented       & $FFFF ; $8f if
>0182ad	41 83					.word NotImplemented       & $FFFF ; $90 while
>0182af	41 83					.word NotImplemented       & $FFFF ; $91 repeat
>0182b1	41 83					.word NotImplemented       & $FFFF ; $92 for
>0182b3	41 83					.word NotImplemented       & $FFFF ; $93 then
>0182b5	41 83					.word NotImplemented       & $FFFF ; $94 endif
>0182b7	41 83					.word NotImplemented       & $FFFF ; $95 wend
>0182b9	41 83					.word NotImplemented       & $FFFF ; $96 until
>0182bb	41 83					.word NotImplemented       & $FFFF ; $97 next
>0182bd	41 83					.word NotImplemented       & $FFFF ; $98 not
>0182bf	41 83					.word NotImplemented       & $FFFF ; $99 fn(
>0182c1	a3 8a					.word Unary_Abs            & $FFFF ; $9a abs(
>0182c3	fb 8b					.word Unary_Asc            & $FFFF ; $9b asc(
>0182c5	0b 98					.word Unary_Int            & $FFFF ; $9c int(
>0182c7	c1 8a					.word Unary_Peek           & $FFFF ; $9d peek(
>0182c9	82 97					.word Unary_Rnd            & $FFFF ; $9e rnd(
>0182cb	35 8b					.word Unary_Usr            & $FFFF ; $9f usr(
>0182cd	3c 8c					.word Unary_Left           & $FFFF ; $a0 left$(
>0182cf	53 8c					.word Unary_Right          & $FFFF ; $a1 right$(
>0182d1	21 8c					.word Unary_Mid            & $FFFF ; $a2 mid$(
>0182d3	b5 8d					.word Unary_Spc            & $FFFF ; $a3 spc(
>0182d5	c8 8b					.word Unary_Str            & $FFFF ; $a4 str$(
>0182d7	57 8b					.word Unary_Val            & $FFFF ; $a5 val(
>0182d9	12 8c					.word Unary_Len            & $FFFF ; $a6 len(
>0182db	d1 8c					.word Unary_Hex            & $FFFF ; $a7 hex$(
>0182dd	41 83					.word NotImplemented       & $FFFF ; $a8 sin(
>0182df	41 83					.word NotImplemented       & $FFFF ; $a9 cos(
>0182e1	41 83					.word NotImplemented       & $FFFF ; $aa tan(
>0182e3	41 83					.word NotImplemented       & $FFFF ; $ab atn(
>0182e5	41 83					.word NotImplemented       & $FFFF ; $ac exp(
>0182e7	41 83					.word NotImplemented       & $FFFF ; $ad log(
>0182e9	41 83					.word NotImplemented       & $FFFF ; $ae sqr(
>0182eb	2b 8d					.word Unary_Dec            & $FFFF ; $af dec(
>0182ed	c5 8a					.word Unary_Deek           & $FFFF ; $b0 deek(
>0182ef	c9 8a					.word Unary_Leek           & $FFFF ; $b1 leek(
>0182f1	fd 8a					.word Unary_Mod            & $FFFF ; $b2 mod(
>0182f3	51 8a					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>0182f5	93 8d					.word Unary_Chr            & $FFFF ; $b4 chr$(
>0182f7	41 83					.word NotImplemented       & $FFFF ; $b5 $
>0182f9	41 83					.word NotImplemented       & $FFFF ; $b6 $(
>0182fb	41 83					.word NotImplemented       & $FFFF ; $b7 #
>0182fd	41 83					.word NotImplemented       & $FFFF ; $b8 #(
>0182ff	41 83					.word NotImplemented       & $FFFF ; $b9 %
>018301	41 83					.word NotImplemented       & $FFFF ; $ba %(
>018303	41 83					.word NotImplemented       & $FFFF ; $bb (
>018305	41 83					.word NotImplemented       & $FFFF ; $bc )
>018307	41 83					.word NotImplemented       & $FFFF ; $bd ,
>018309	39 85					.word Command_COLON        & $FFFF ; $be :
>01830b	41 83					.word NotImplemented       & $FFFF ; $bf ;
>01830d	41 83					.word NotImplemented       & $FFFF ; $c0 def
>01830f	cd 85					.word Command_CLR          & $FFFF ; $c1 clr
>018311	db 85					.word Command_STOP         & $FFFF ; $c2 stop
>018313	41 83					.word NotImplemented       & $FFFF ; $c3 data
>018315	41 83					.word NotImplemented       & $FFFF ; $c4 read
>018317	41 83					.word NotImplemented       & $FFFF ; $c5 dim
>018319	41 83					.word NotImplemented       & $FFFF ; $c6 to
>01831b	41 83					.word NotImplemented       & $FFFF ; $c7 step
>01831d	41 83					.word NotImplemented       & $FFFF ; $c8 gosub
>01831f	41 83					.word NotImplemented       & $FFFF ; $c9 return
>018321	41 83					.word NotImplemented       & $FFFF ; $ca goto
>018323	3a 85					.word Command_END          & $FFFF ; $cb end
>018325	41 83					.word NotImplemented       & $FFFF ; $cc input
>018327	41 83					.word NotImplemented       & $FFFF ; $cd let
>018329	41 83					.word NotImplemented       & $FFFF ; $ce list
>01832b	41 83					.word NotImplemented       & $FFFF ; $cf new
>01832d	41 83					.word NotImplemented       & $FFFF ; $d0 old
>01832f	41 83					.word NotImplemented       & $FFFF ; $d1 on
>018331	41 83					.word NotImplemented       & $FFFF ; $d2 restore
>018333	41 83					.word NotImplemented       & $FFFF ; $d3 poke
>018335	3e 85					.word Command_PRINT        & $FFFF ; $d4 print
>018337	c3 84					.word Command_RUN          & $FFFF ; $d5 run
>018339	41 83					.word NotImplemented       & $FFFF ; $d6 wait
>01833b	41 83					.word NotImplemented       & $FFFF ; $d7 doke
>01833d	41 83					.word NotImplemented       & $FFFF ; $d8 loke
>01833f	b1 85					.word Command_ASSERT       & $FFFF ; $d9 assert
.018341					NotImplemented:
.018341	20 26 82	jsr $018226			jsr ERR_Handler
>018344	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>01834c	65 6d 65 6e 74 65 64 00
.018354					BinaryPrecedence:
>018354	01					.byte 1    ; $80 and
>018355	01					.byte 1    ; $81 or
>018356	01					.byte 1    ; $82 xor
>018357	01					.byte 1    ; $83 eor
>018358	02					.byte 2    ; $84 =
>018359	02					.byte 2    ; $85 <>
>01835a	02					.byte 2    ; $86 <
>01835b	02					.byte 2    ; $87 <=
>01835c	02					.byte 2    ; $88 >
>01835d	02					.byte 2    ; $89 >=
>01835e	03					.byte 3    ; $8a +
>01835f	03					.byte 3    ; $8b -
>018360	04					.byte 4    ; $8c *
>018361	04					.byte 4    ; $8d /
>018362	05					.byte 5    ; $8e ^
.018363					KeywordText:
>018363	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>018366	4f d2					.byte $4f,$d2                          ; $81 or
>018368	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>01836b	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>01836e	bd					.byte $bd                              ; $84 =
>01836f	3c be					.byte $3c,$be                          ; $85 <>
>018371	bc					.byte $bc                              ; $86 <
>018372	3c bd					.byte $3c,$bd                          ; $87 <=
>018374	be					.byte $be                              ; $88 >
>018375	3e bd					.byte $3e,$bd                          ; $89 >=
>018377	ab					.byte $ab                              ; $8a +
>018378	ad					.byte $ad                              ; $8b -
>018379	aa					.byte $aa                              ; $8c *
>01837a	af					.byte $af                              ; $8d /
>01837b	de					.byte $de                              ; $8e ^
>01837c	49 c6					.byte $49,$c6                          ; $8f if
>01837e	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>018383	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>018389	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>01838c	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>018390	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>018395	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>018399	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>01839e	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>0183a2	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>0183a5	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>0183a8	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>0183ac	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>0183b0	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>0183b4	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>0183b9	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>0183bd	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>0183c1	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>0183c7	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>0183ce	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>0183d3	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>0183d7	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>0183dc	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>0183e0	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>0183e4	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>0183e9	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>0183ed	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>0183f1	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>0183f5	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>0183f9	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>0183fd	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>018401	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>018405	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>018409	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>01840e	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>018413	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>018417	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>01841b	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>018420	a4					.byte $a4                              ; $b5 $
>018421	24 a8					.byte $24,$a8                          ; $b6 $(
>018423	a3					.byte $a3                              ; $b7 #
>018424	23 a8					.byte $23,$a8                          ; $b8 #(
>018426	a5					.byte $a5                              ; $b9 %
>018427	25 a8					.byte $25,$a8                          ; $ba %(
>018429	a8					.byte $a8                              ; $bb (
>01842a	a9					.byte $a9                              ; $bc )
>01842b	ac					.byte $ac                              ; $bd ,
>01842c	ba					.byte $ba                              ; $be :
>01842d	bb					.byte $bb                              ; $bf ;
>01842e	44 45 c6				.byte $44,$45,$c6                      ; $c0 def
>018431	43 4c d2				.byte $43,$4c,$d2                      ; $c1 clr
>018434	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $c2 stop
>018438	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c3 data
>01843c	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c4 read
>018440	44 49 cd				.byte $44,$49,$cd                      ; $c5 dim
>018443	54 cf					.byte $54,$cf                          ; $c6 to
>018445	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c7 step
>018449	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $c8 gosub
>01844e	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $c9 return
>018454	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $ca goto
>018458	45 4e c4				.byte $45,$4e,$c4                      ; $cb end
>01845b	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $cc input
>018460	4c 45 d4				.byte $4c,$45,$d4                      ; $cd let
>018463	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $ce list
>018467	4e 45 d7				.byte $4e,$45,$d7                      ; $cf new
>01846a	4f 4c c4				.byte $4f,$4c,$c4                      ; $d0 old
>01846d	4f ce					.byte $4f,$ce                          ; $d1 on
>01846f	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d2 restore
>018476	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d3 poke
>01847a	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d4 print
>01847f	52 55 ce				.byte $52,$55,$ce                      ; $d5 run
>018482	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d6 wait
>018486	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $d7 doke
>01848a	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $d8 loke
>01848e	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $d9 assert
>018494	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_dollar = $b5
=$b6					token_dollarlparen = $b6
=$b7					token_hash = $b7
=$b8					token_hashlparen = $b8
=$b9					token_percent = $b9
=$ba					token_percentlparen = $ba
=$bb					token_lparen = $bb
=$bc					token_rparen = $bc
=$bd					token_comma = $bd
=$be					token_colon = $be
=$bf					token_semicolon = $bf
=$c0					token_def = $c0
=$c1					token_clr = $c1
=$c2					token_stop = $c2
=$c3					token_data = $c3
=$c4					token_read = $c4
=$c5					token_dim = $c5
=$c6					token_to = $c6
=$c7					token_step = $c7
=$c8					token_gosub = $c8
=$c9					token_return = $c9
=$ca					token_goto = $ca
=$cb					token_end = $cb
=$cc					token_input = $cc
=$cd					token_let = $cd
=$ce					token_list = $ce
=$cf					token_new = $cf
=$d0					token_old = $d0
=$d1					token_on = $d1
=$d2					token_restore = $d2
=$d3					token_poke = $d3
=$d4					token_print = $d4
=$d5					token_run = $d5
=$d6					token_wait = $d6
=$d7					token_doke = $d7
=$d8					token_loke = $d8
=$d9					token_assert = $d9

;******  Return to file: modules/basic/core.asm

.018495					BASIC_Start:
.018495	20 a8 81	jsr $0181a8			jsr 	IF_Reset 					; set up and clear screen.
.018498	20 00 80	jsr $018000			jsr 	IFT_ClearScreen
.01849b	a9 5c		lda #$5c			lda 	#$5C 						; JMP Long opcode
.01849d	8d 04 03	sta $0304			sta 	LocalVector
.0184a0	8d 00 03	sta $0300			sta 	UserVector
.0184a3	a9 45		lda #$45			lda 	#USRDefault & $FF 			; reset USR vector
.0184a5	8d 01 03	sta $0301			sta 	UserVector+1
.0184a8	a9 8b		lda #$8b			lda 	#(USRDefault >> 8) & $FF
.0184aa	8d 02 03	sta $0302			sta 	UserVector+2
.0184ad	a9 01		lda #$01			lda 	#(USRDefault >> 16) & $FF
.0184af	8d 03 03	sta $0303			sta 	UserVector+3
.0184b2	20 cd 85	jsr $0185cd			jsr 	ResetRunStatus 				; clear everything (CLR command)
.0184b5					WarmStart:
.0184b5	c2 30		rep #$30			rep 	#$30
.0184b7	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.0184ba	1b		tcs				tcs
.0184bb	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.0184be	e2 30		sep #$30			sep 	#$30
.0184c0	4c c3 84	jmp $0184c3			jmp 	COMMAND_Run

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/run.asm

.0184c3					Command_RUN:
.0184c3	20 cd 85	jsr $0185cd			jsr 	ResetRunStatus 				; clear, reset stacks etc.
.0184c6	a9 00		lda #$00			lda 	#BasicProgram & $FF
.0184c8	85 16		sta $16				sta 	zCodePtr+0
.0184ca	a9 10		lda #$10			lda 	#BasicProgram >> 8
.0184cc	85 17		sta $17				sta 	zCodePtr+1
.0184ce	a9 00		lda #$00			lda 	#0
.0184d0	85 18		sta $18				sta 	zCodePtr+2
.0184d2	85 19		sta $19				sta 	zCodePtr+3
.0184d4	a0 03		ldy #$03			ldy 	#3
.0184d6					RUN_NewLine:
.0184d6	a0 00		ldy #$00			ldy 	#0
.0184d8	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0184da	c8		iny				iny
.0184db	c8		iny				iny
.0184dc	c8		iny				iny
.0184dd	c9 00		cmp #$00			cmp 	#0 							; if the offset is zero then END.
.0184df	d0 16		bne $0184f7			bne 	RUN_NextCommand
.0184e1	4c db 85	jmp $0185db			jmp 	Command_STOP 				; go do the command code.
.0184e4					RUN_Skip:
.0184e4	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.0184e6	c8		iny				iny 								; skip
.0184e7	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.0184e9	90 0c		bcc $0184f7			bcc 	_SEDone 					; so just skip over it.
.0184eb	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.0184ed	90 07		bcc $0184f6			bcc 	_SEDouble
.0184ef	98		tya				tya 								; this is Y + 1
.0184f0	18		clc				clc
.0184f1	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.0184f3	a8		tay				tay 								; back in Y.
.0184f4	88		dey				dey 								; fix up, one for the +1, one for the iny
.0184f5	88		dey				dey
.0184f6					_SEDouble:
.0184f6	c8		iny				iny
.0184f7					_SEDone:
.0184f7					RUN_NextCommand:
.0184f7	a9 00		lda #$00			lda 	#0 							; this resets temporary string allocation.
.0184f9	85 21		sta $21				sta 	zTempStr+1 					; (initialised when first called)
.0184fb	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0184fd	c9 be		cmp #$be			cmp 	#token_Colon 				; skip over colons
.0184ff	f0 e3		beq $0184e4			beq 	RUN_Skip
.018501	c9 00		cmp #$00			cmp 	#0 							; if non-zero execute whatever
.018503	d0 0f		bne $018514			bne 	RUN_Execute
.018505					RUN_NextLine:
.018505	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018507	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.018509	18		clc				clc
.01850a	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.01850c	85 16		sta $16				sta 	zCodePtr
.01850e	90 02		bcc $018512			bcc 	_SNLNoCarry
.018510	e6 17		inc $17				inc 	zCodePtr+1
.018512					_SNLNoCarry:
.018512	80 c2		bra $0184d6			bra 	RUN_NewLine 				; go do the new line code
.018514					RUN_Execute:
.018514	c9 f8		cmp #$f8			cmp 	#$F8 						; handle shifts, REM etc.
.018516	b0 1a		bcs $018532			bcs 	RUN_Extension
.018518	c8		iny				iny
.018519	0a		asl a				asl 	a 							; double the character read.
.01851a	90 14		bcc $018530			bcc 	RUN_Default 				; if carry clear was $00-$7F, so try LET.
.01851c	aa		tax				tax 								; ready to look up.
.01851d	bf 8d 82 01	lda $01828d,x			lda 	VectorTable,x 				; copy address into LocalVector
.018521	8d 05 03	sta $0305			sta 	LocalVector+1
.018524	bf 8e 82 01	lda $01828e,x			lda 	VectorTable+1,x
.018528	8d 06 03	sta $0306			sta 	LocalVector+2
.01852b	20 f6 86	jsr $0186f6			jsr 	EVCallLocalVector 			; execute the appropriate code.
.01852e	80 c7		bra $0184f7			bra 	RUN_NextCommand 			; do the next command.
.018530					RUN_Default:
.018530	80 fe		bra $018530			bra 	RUN_Default
.018532					RUN_Extension:
.018532	c9 ff		cmp #$ff			cmp 	#$FF 						; if $FF (REM)
.018534	f0 ae		beq $0184e4			beq 	RUN_Skip 					; skip over it.
.018536	4c f7 81	jmp $0181f7			jmp 	SyntaxError
.018539					Command_COLON:
.018539	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/end.asm

.01853a					Command_END:
>01853a	02						.byte 	2
.01853b	4c b5 84	jmp $0184b5			jmp 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/print.asm

.01853e					Command_PRINT:
.01853e	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018540	c9 00		cmp #$00			cmp 	#0 							; end
.018542	f0 69		beq $0185ad			beq 	_CPR_NewLine
.018544	c9 be		cmp #$be			cmp 	#token_Colon
.018546	f0 65		beq $0185ad			beq 	_CPR_NewLine
.018548	c9 bf		cmp #$bf			cmp 	#token_SemiColon
.01854a	f0 54		beq $0185a0			beq 	_CPR_Skip
.01854c	c9 bd		cmp #$bd			cmp 	#token_Comma
.01854e	f0 4d		beq $01859d			beq 	_CPR_Tab
.018550	20 e6 85	jsr $0185e6			jsr 	EvaluateExpression 			; get expression.
.018553	ad 0d 03	lda $030d			lda 	XS_Type 					; get type.
.018556	29 02		and #$02			and 	#2
.018558	d0 25		bne $01857f			bne 	_CPR_String 				; if type = 2 output as string.
.01855a					_CPR_Number:
.01855a	a9 00		lda #$00			lda 	#0 							; reset buffer index
.01855c	8d 00 04	sta $0400			sta 	NumBufX
.01855f	ad 0d 03	lda $030d			lda 	XS_Type 					; get type
.018562	4a		lsr a				lsr 	a
.018563	b0 05		bcs $01856a			bcs 	_CPRInt 					; if msb set do as integer
.018565	20 3a 96	jsr $01963a			jsr 	FPToString 					; call fp to str otherwise
.018568	80 03		bra $01856d			bra 	_CPRNPrint
.01856a	20 26 90	jsr $019026	_CPRInt:jsr 	IntToString
.01856d					_CPRNPrint:
.01856d	ad 01 04	lda $0401			lda 	Num_Buffer 					; is first character -
.018570	c9 2d		cmp #$2d			cmp 	#"-"
.018572	f0 05		beq $018579			beq 	_CPRNoSpace
.018574	a9 20		lda #$20			lda 	#" "						; print the leading space
.018576	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter 			; so beloved of MS Basics.
.018579					_CPRNoSpace:
.018579	a2 00		ldx #$00			ldx 	#(Num_Buffer-1) & $FF
.01857b	a9 04		lda #$04			lda 	#(Num_Buffer-1) >> 8
.01857d	80 06		bra $018585			bra 	_CPRPrint
.01857f					_CPR_String:
.01857f	ae 08 03	ldx $0308			ldx 	XS_Mantissa
.018582	ad 09 03	lda $0309			lda 	XS_Mantissa+1
.018585					_CPRPrint:
.018585	86 1e		stx $1e				stx 	zGenPtr
.018587	85 1f		sta $1f				sta 	zGenPtr+1
.018589	5a		phy				phy
.01858a	a0 00		ldy #$00			ldy 	#0							; get length into X
.01858c	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.01858e	aa		tax				tax
.01858f	f0 09		beq $01859a			beq 	_CPREndPrint 				; nothing to print
.018591					_CPRLoop:
.018591	c8		iny				iny
.018592	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018594	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018597	ca		dex				dex
.018598	d0 f7		bne $018591			bne 	_CPRLoop
.01859a					_CPREndPrint:
.01859a	7a		ply				ply
.01859b	80 a1		bra $01853e			bra 	Command_Print
.01859d					_CPR_Tab:
.01859d	20 4f 80	jsr $01804f			jsr 	IFT_Tab
.0185a0					_CPR_Skip:
.0185a0	c8		iny				iny
.0185a1	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0185a3	c9 be		cmp #$be			cmp 	#token_Colon 				; colon or $00, exit
.0185a5	f0 09		beq $0185b0			beq 	_CPR_Exit
.0185a7	c9 00		cmp #$00			cmp 	#0
.0185a9	d0 93		bne $01853e			bne 	Command_PRINT 				; if not go round again.
.0185ab	80 03		bra $0185b0			bra 	_CPR_Exit
.0185ad					_CPR_NewLine:
.0185ad	20 5c 80	jsr $01805c			jsr 	IFT_NewLine
.0185b0					_CPR_Exit:
.0185b0	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/assert.asm

.0185b1					Command_ASSERT:
.0185b1	20 8c 87	jsr $01878c			jsr 	EvaluateNumber 				; calculate thing being asserted
.0185b4	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; check if true (non-zero)
.0185b7	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.0185ba	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.0185bd	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.0185c0	f0 01		beq $0185c3			beq 	_ASFail
.0185c2	60		rts				rts
.0185c3					_ASFail:
.0185c3	20 26 82	jsr $018226			jsr ERR_Handler
>0185c6	41 73 73 65 72 74 00			.text "Assert",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.0185cd					Command_CLR:
.0185cd					ResetRunStatus:
.0185cd	20 01 8f	jsr $018f01			jsr 	VariableClear
.0185d0	a9 00		lda #$00			lda 	#HighMemory & $FF
.0185d2	8d 29 04	sta $0429			sta 	StringPtr
.0185d5	a9 80		lda #$80			lda 	#HighMemory >> 8
.0185d7	8d 2a 04	sta $042a			sta 	StringPtr+1
.0185da	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/stop.asm

.0185db					Command_STOP:
.0185db	20 26 82	jsr $018226			jsr ERR_Handler
>0185de	53 74 6f 70 00				.text "Stop",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.0185e3					EVESyntax:
.0185e3	4c f7 81	jmp $0181f7			jmp 	SyntaxError
.0185e6					EvaluateExpression:
.0185e6	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.0185e8					EvaluateExpressionX:
.0185e8	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.0185ea					EvaluateExpressionXA:
.0185ea	48		pha				pha 								; save precedence on stack.
.0185eb	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0185ed	f0 f4		beq $0185e3			beq 	EVESyntax 					; end of line, syntax error.
.0185ef	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.0185f1	b0 03		bcs $0185f6			bcs 	_EVNotVariable
.0185f3	4c ed 86	jmp $0186ed			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.0185f6					_EVNotVariable:
.0185f6	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.0185f8	90 e9		bcc $0185e3			bcc 	EVESyntax
.0185fa	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.0185fc	b0 7f		bcs $01867d			bcs 	_EVNotInteger
.0185fe	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.018600	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.018603	a9 00		lda #$00			lda 	#0
.018605	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018608	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01860b	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.01860e	1a		inc a				inc 	a 							; set to type 1 (integer)
.01860f	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018612					_EVCheckNextInteger:
.018612	c8		iny				iny
.018613	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018615	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.018617	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.018619	b0 0d		bcs $018628			bcs 	_EVCheckDecimal
.01861b	48		pha				pha 								; save it.
.01861c	20 f9 86	jsr $0186f9			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.01861f	68		pla				pla
.018620	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.018623	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018626	80 ea		bra $018612			bra 	_EVCheckNextInteger
.018628					_EVCheckDecimal:
.018628	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01862a	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.01862c	d0 05		bne $018633			bne 	_EVGotAtom 					; no, get atom.
.01862e					_EVIsDecimal:
.01862e	20 29 87	jsr $018729			jsr 	EVGetDecimal 				; extend to the decimal part.
.018631	80 00		bra $018633			bra 	_EVGotAtom 					; and continue to got atom.
.018633					_EVGotAtom:
.018633	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018635	10 44		bpl $01867b			bpl 	_EVExitDrop 				; must be a token.
.018637	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.018639	b0 40		bcs $01867b			bcs 	_EVExitDrop
.01863b	68		pla				pla 								; get current precedence
.01863c	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.01863e	da		phx				phx 								; save X
.01863f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018641	aa		tax				tax 								; put in X
.018642	bf d4 82 01	lda $0182d4,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.018646	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.018648	fa		plx				plx 								; restore X
.018649	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.01864b	90 2f		bcc $01867c			bcc 	_EVExit 					; exit if too low.
.01864d	f0 2d		beq $01867c			beq 	_EVExit 					; exit if equals
.01864f	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.018651	48		pha				pha
.018652	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018654	48		pha				pha
.018655	c8		iny				iny
.018656	da		phx				phx 								; save current position
.018657	e8		inx				inx
.018658	e8		inx				inx
.018659	e8		inx				inx
.01865a	e8		inx				inx
.01865b	e8		inx				inx
.01865c	e8		inx				inx
.01865d	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.01865f	20 ea 85	jsr $0185ea			jsr 	EvaluateExpressionXA 		; do the RHS.
.018662	fa		plx				plx 								; restore X
.018663	68		pla				pla 								; get the binary operator in A.
.018664					_EVCallA:
.018664	da		phx				phx 								; save X again
.018665	0a		asl a				asl 	a 							; double, lose the MSB.
.018666	aa		tax				tax									; put in X
.018667	bf 8d 82 01	lda $01828d,x			lda 	VectorTable,x 				; copy address into zGenPtr
.01866b	8d 05 03	sta $0305			sta 	LocalVector+1
.01866e	bf 8e 82 01	lda $01828e,x			lda 	VectorTable+1,x
.018672	8d 06 03	sta $0306			sta 	LocalVector+2
.018675	fa		plx				plx 								; restore X
.018676	20 f6 86	jsr $0186f6			jsr 	EVCallLocalVector
.018679	80 b8		bra $018633			bra 	_EVGotAtom 					; and loop back.
.01867b					_EVExitDrop:
.01867b	68		pla				pla
.01867c					_EVExit:
.01867c	60		rts				rts
.01867d					_EVNotInteger:
.01867d	c8		iny				iny
.01867e	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.018680	d0 19		bne $01869b			bne 	_EVNotMinus
.018682	20 7a 87	jsr $01877a			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.018685	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.018688	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.01868a	f0 05		beq $018691			beq 	_EVMinusFloat
.01868c	20 01 90	jsr $019001			jsr 	IntegerNegateAlways 		; negation
.01868f	80 a2		bra $018633			bra 	_EVGotAtom 					; and go back.
.018691					_EVMinusFloat:
.018691	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; invert the sign bit.
.018694	49 80		eor #$80			eor 	#$80
.018696	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018699	80 98		bra $018633			bra 	_EVGotAtom
.01869b					_EVNotMinus:
.01869b	c9 bb		cmp #$bb			cmp 	#token_lparen 				; is it left parenthesis
.01869d	d0 17		bne $0186b6			bne 	_EVNotParenthesis
.01869f	20 e8 85	jsr $0185e8			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.0186a2	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0186a4	c8		iny				iny
.0186a5	c9 bc		cmp #$bc			cmp 	#token_rparen 				; okay if right bracket.
.0186a7	f0 8a		beq $018633			beq 	_EVGotAtom
.0186a9	20 26 82	jsr $018226			jsr ERR_Handler
>0186ac	4d 69 73 73 69 6e 67 20			.text "Missing )",0
>0186b4	29 00
.0186b6					_EVNotParenthesis:
.0186b6	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.0186b8	d0 0c		bne $0186c6			bne 	_EVNotNot
.0186ba	20 7a 87	jsr $01877a			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.0186bd	20 0f 95	jsr $01950f			jsr 	FPUToInteger 				; make it an integer - if possible.
.0186c0	20 57 87	jsr $018757			jsr 	NotInteger 					; do the not calculation
.0186c3	4c 33 86	jmp $018633			jmp 	_EVGotAtom
.0186c6					_EVNotNot:
.0186c6	c9 fe		cmp #$fe			cmp 	#$FE
.0186c8	d0 15		bne $0186df			bne 	_EVNotString
.0186ca	20 68 8e	jsr $018e68			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.0186cd	a5 20		lda $20				lda 	zTempStr 					; copy address of string into mantissa
.0186cf	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0186d2	a5 21		lda $21				lda 	zTempStr+1
.0186d4	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0186d7	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.0186d9	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0186dc	4c 33 86	jmp $018633			jmp 	_EVGotAtom
.0186df					_EVNotString:
.0186df	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.0186e1	90 04		bcc $0186e7			bcc 	_EVBadElement
.0186e3	c9 b5		cmp #$b5			cmp 	#lastUnaryFunction+1
.0186e5	90 03		bcc $0186ea			bcc 	_EVUnaryFunction
.0186e7					_EVBadElement:
.0186e7	4c f7 81	jmp $0181f7			jmp 	SyntaxError
.0186ea					_EVUnaryFunction:
.0186ea	4c 64 86	jmp $018664			jmp 	_EVCallA
.0186ed					_EVVariableHandler:
.0186ed	20 a3 8e	jsr $018ea3			jsr 	VariableFind 				; locate a variable
.0186f0	20 13 8f	jsr $018f13			jsr 	VariableGet 				; copy into memory.
.0186f3	4c 33 86	jmp $018633			jmp 	_EVGotAtom 					; and go round.
.0186f6					EVCallLocalVector:
.0186f6	6c 05 03	jmp ($0305)			jmp 	(LocalVector+1)
.0186f9					EVShiftMantissaLeft6:
.0186f9	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.0186fc	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.0186ff	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018702	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018705	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018708	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01870b	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.01870e	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018711	a9 00		lda #$00			lda 	#0
.018713	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018716	20 19 87	jsr $018719			jsr 	_EVSMLShift 					; call it here to do it twice
.018719					_EVSMLShift:
.018719	5e 0c 03	lsr $030c,x			lsr 	XS_Exponent,x
.01871c	7e 0b 03	ror $030b,x			ror 	XS_Mantissa+3,x
.01871f	7e 0a 03	ror $030a,x			ror 	XS_Mantissa+2,x
.018722	7e 09 03	ror $0309,x			ror 	XS_Mantissa+1,x
.018725	7e 08 03	ror $0308,x			ror 	XS_Mantissa+0,x
.018728	60		rts				rts
.018729					EVGetDecimal:
.018729	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.01872b	8d 01 04	sta $0401			sta 	Num_Buffer
.01872e	da		phx				phx
.01872f	c8		iny				iny
.018730	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018732	c8		iny				iny
.018733	3a		dec a				dec 	a								; convert to a string length.
.018734	3a		dec a				dec 	a
.018735	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.018737					_EVGDCopy:
.018737	48		pha				pha 									; save count
.018738	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01873a	9d 01 04	sta $0401,x			sta 	Num_Buffer,x
.01873d	e8		inx				inx 									; forward ....
.01873e	c8		iny				iny
.01873f	68		pla				pla 									; get count
.018740	3a		dec a				dec 	a 								; until zero
.018741	d0 f4		bne $018737			bne 	_EVGDCopy
.018743	9d 01 04	sta $0401,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.018746	fa		plx				plx 									; restore X
.018747	a9 01		lda #$01			lda 	#Num_Buffer & $FF 				; set zGenPtr
.018749	85 1e		sta $1e				sta 	zGenPtr
.01874b	a9 04		lda #$04			lda 	#Num_Buffer >> 8
.01874d	85 1f		sta $1f				sta 	zGenPtr+1
.01874f	5a		phy				phy 									; save Y
.018750	a0 00		ldy #$00			ldy 	#0 								; start position
.018752	20 01 97	jsr $019701			jsr 	FPFromString 					; convert current
.018755	7a		ply				ply 									; restore Y
.018756	60		rts				rts
.018757					NotInteger:
.018757	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.01875a	49 ff		eor #$ff			eor 	#$FF
.01875c	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.01875f	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018762	49 ff		eor #$ff			eor 	#$FF
.018764	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018767	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.01876a	49 ff		eor #$ff			eor 	#$FF
.01876c	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01876f	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.018772	49 ff		eor #$ff			eor 	#$FF
.018774	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018777	60		rts				rts
.018778					EvaluateGetAtom:
.018778	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.01877a					EvaluateGetAtomX:
.01877a	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.01877c	20 ea 85	jsr $0185ea			jsr 	EvaluateExpressionXA
.01877f	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.018782	29 0f		and #$0f			and 	#15
.018784	c9 02		cmp #$02			cmp 	#2
.018786	b0 01		bcs $018789			bcs 	EvaluateType
.018788	60		rts				rts
.018789					EvaluateType:
.018789	4c 07 82	jmp $018207			jmp 	TypeError
.01878c					EvaluateNumber:
.01878c	a2 00		ldx #$00			ldx 	#0
.01878e					EvaluateNumberX:
.01878e	20 e8 85	jsr $0185e8			jsr 	EvaluateExpressionX
.018791	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 0/1
.018794	29 0f		and #$0f			and 	#15
.018796	c9 02		cmp #$02			cmp 	#2
.018798	b0 ef		bcs $018789			bcs 	EvaluateType
.01879a	60		rts				rts
.01879b					EvaluateInteger:
.01879b	a2 00		ldx #$00			ldx 	#0
.01879d					EvaluateIntegerX:
.01879d	20 8e 87	jsr $01878e			jsr 	EvaluateNumberX
.0187a0	20 0f 95	jsr $01950f			jsr 	FPUToInteger
.0187a3	60		rts				rts
.0187a4					EvaluateString:
.0187a4	a2 00		ldx #$00			ldx 	#0
.0187a6					EvaluateStringX:
.0187a6	20 e8 85	jsr $0185e8			jsr 	EvaluateExpressionX
.0187a9	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 2
.0187ac	29 0f		and #$0f			and 	#15
.0187ae	c9 02		cmp #$02			cmp 	#2
.0187b0	d0 d7		bne $018789			bne 	EvaluateType
.0187b2	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.0187b5	85 1e		sta $1e				sta 	zGenPtr
.0187b7	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0187ba	85 1f		sta $1f				sta 	zGenPtr+1
.0187bc	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.0187bd					BinaryOp_And:
.0187bd	20 35 88	jsr $018835			jsr 	BinaryMakeBothInteger
.0187c0	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.0187c3	3d 0e 03	and $030e,x			and 	XS2_Mantissa+0,x
.0187c6	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0187c9	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.0187cc	3d 0f 03	and $030f,x			and 	XS2_Mantissa+1,x
.0187cf	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0187d2	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.0187d5	3d 10 03	and $0310,x			and 	XS2_Mantissa+2,x
.0187d8	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0187db	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.0187de	3d 11 03	and $0311,x			and 	XS2_Mantissa+3,x
.0187e1	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0187e4	60		rts				rts
.0187e5					BinaryOp_Or:
.0187e5	20 35 88	jsr $018835			jsr 	BinaryMakeBothInteger
.0187e8	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.0187eb	1d 0e 03	ora $030e,x			ora 	XS2_Mantissa+0,x
.0187ee	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0187f1	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.0187f4	1d 0f 03	ora $030f,x			ora 	XS2_Mantissa+1,x
.0187f7	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0187fa	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.0187fd	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.018800	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018803	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.018806	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.018809	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.01880c	60		rts				rts
.01880d					BinaryOp_Eor:
.01880d					BinaryOp_Xor:
.01880d	20 35 88	jsr $018835			jsr 	BinaryMakeBothInteger
.018810	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.018813	5d 0e 03	eor $030e,x			eor 	XS2_Mantissa+0,x
.018816	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018819	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.01881c	5d 0f 03	eor $030f,x			eor 	XS2_Mantissa+1,x
.01881f	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018822	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.018825	5d 10 03	eor $0310,x			eor 	XS2_Mantissa+2,x
.018828	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01882b	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.01882e	5d 11 03	eor $0311,x			eor 	XS2_Mantissa+3,x
.018831	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018834	60		rts				rts
.018835					BinaryMakeBothInteger:
.018835	da		phx				phx 								; save X
.018836	e8		inx				inx
.018837	e8		inx				inx
.018838	e8		inx				inx
.018839	e8		inx				inx
.01883a	e8		inx				inx
.01883b	e8		inx				inx
.01883c	20 40 88	jsr $018840			jsr 	BinaryMakeInteger 			; convert to integer.
.01883f	fa		plx				plx 								; restore X and fall through.
.018840					BinaryMakeInteger:
.018840	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type byte.
.018843	29 0f		and #$0f			and 	#15 						; check type zero
.018845	f0 04		beq $01884b			beq 	_BMIConvert 				; if float convert to integer.
.018847	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.018848	90 04		bcc $01884e			bcc 	_BMIError
.01884a	60		rts				rts
.01884b					_BMIConvert:
.01884b	4c 0f 95	jmp $01950f			jmp 	FPUToInteger 				; convert to integer
.01884e					_BMIError:
.01884e	4c 07 82	jmp $018207			jmp 	TypeError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.018851					Binary_Equal:
.018851	20 9d 88	jsr $01889d			jsr 	CompareValues
.018854	09 00		ora #$00			ora 	#0
.018856	f0 04		beq $01885c			beq 	CCTrue
.018858	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.01885a	80 02		bra $01885e			bra 	CCWrite
.01885c	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.01885e	9d 08 03	sta $0308,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.018861	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018864	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018867	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.01886a	a9 01		lda #$01			lda 	#1
.01886c	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; set type to integer whatever.
.01886f	60		rts				rts
.018870					Binary_NotEqual:
.018870	20 9d 88	jsr $01889d			jsr 	CompareValues
.018873	09 00		ora #$00			ora 	#0
.018875	f0 e1		beq $018858			beq 	CCFalse
.018877	80 e3		bra $01885c			bra 	CCTrue
.018879					Binary_Less:
.018879	20 9d 88	jsr $01889d			jsr 	CompareValues
.01887c	09 00		ora #$00			ora 	#0
.01887e	30 dc		bmi $01885c			bmi 	CCTrue
.018880	80 d6		bra $018858			bra 	CCFalse
.018882					Binary_LessEqual:
.018882	20 9d 88	jsr $01889d			jsr 	CompareValues
.018885	c9 01		cmp #$01			cmp 	#1
.018887	d0 d3		bne $01885c			bne 	CCTrue
.018889	80 cd		bra $018858			bra 	CCFalse
.01888b					Binary_GreaterEqual:
.01888b	20 9d 88	jsr $01889d			jsr 	CompareValues
.01888e	09 00		ora #$00			ora 	#0
.018890	10 ca		bpl $01885c			bpl 	CCTrue
.018892	80 c4		bra $018858			bra 	CCFalse
.018894					Binary_Greater:
.018894	20 9d 88	jsr $01889d			jsr 	CompareValues
.018897	c9 01		cmp #$01			cmp 	#1
.018899	f0 c1		beq $01885c			beq 	CCTrue
.01889b	80 bb		bra $018858			bra 	CCFalse
.01889d					CompareValues:
.01889d	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and the types together
.0188a0	3d 13 03	and $0313,x			and 	XS2_Type,x
.0188a3	c9 02		cmp #$02			cmp 	#2
.0188a5	f0 13		beq $0188ba			beq 	_CVString
.0188a7	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.0188aa	3d 13 03	and $0313,x			and 	XS2_Type,x
.0188ad	4a		lsr a				lsr 	a 							; shift bit 0 into C
.0188ae	90 03		bcc $0188b3			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.0188b0	4c 00 89	jmp $018900			jmp 	CompareInteger32 							; so execute code at \1
.0188b3					_BCFloat:
.0188b3	20 ce 89	jsr $0189ce			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.0188b6	4c 1e 94	jmp $01941e			jmp 	FPCompare 							; and execute code at \2
.0188b9	60		rts				rts
.0188ba					_CVString:
.0188ba	da		phx				phx 								; save XY
.0188bb	5a		phy				phy
.0188bc	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.0188bf	85 1a		sta $1a				sta		zLTemp1+0
.0188c1	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0188c4	85 1b		sta $1b				sta 	zLTemp1+1
.0188c6	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x
.0188c9	85 1c		sta $1c				sta 	zLTemp1+2
.0188cb	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.0188ce	85 1d		sta $1d				sta 	zLTemp1+3
.0188d0	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.0188d2	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.0188d4	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.0188d6	90 02		bcc $0188da			bcc 	_CVCommon
.0188d8	b1 1c		lda ($1c),y			lda 	(zLTemp1+2),y
.0188da					_CVCommon:
.0188da	aa		tax				tax 								; put shorter string length in zero.
.0188db	f0 0c		beq $0188e9			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.0188dd					_CVCompare:
.0188dd	c8		iny				iny 								; next character
.0188de	b1 1a		lda ($1a),y			lda 	(zLTemp1),y 				; compare characters
.0188e0	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.0188e2	90 13		bcc $0188f7			bcc 	_CVReturnLess 				; <
.0188e4	d0 15		bne $0188fb			bne 	_CVReturnGreater 			; >
.0188e6	ca		dex				dex 								; until common length matched.
.0188e7	d0 f4		bne $0188dd			bne 	_CVCompare
.0188e9					_CVMatch:
.0188e9	a0 00		ldy #$00			ldy 	#0
.0188eb	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.0188ed	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.0188ef	90 06		bcc $0188f7			bcc 	_CVReturnLess 				; <
.0188f1	d0 08		bne $0188fb			bne 	_CVReturnGreater 			; >
.0188f3	a9 00		lda #$00			lda 	#0
.0188f5	80 06		bra $0188fd			bra 	_CVExit 					; same common, same length, same string
.0188f7					_CVReturnLess:
.0188f7	a9 ff		lda #$ff			lda 	#$FF
.0188f9	80 02		bra $0188fd			bra 	_CVExit
.0188fb					_CVReturnGreater:
.0188fb	a9 01		lda #$01			lda 	#$01
.0188fd					_CVExit:
.0188fd	7a		ply				ply
.0188fe	fa		plx				plx
.0188ff	60		rts				rts
.018900					CompareInteger32:
.018900	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.018903	49 80		eor #$80			eor 	#$80
.018905	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018908	bd 11 03	lda $0311,x			lda 	XS2_Mantissa+3,x
.01890b	49 80		eor #$80			eor 	#$80
.01890d	9d 11 03	sta $0311,x			sta 	XS2_Mantissa+3,x
.018910	20 a8 89	jsr $0189a8			jsr 	SubInteger32 				; subtraction
.018913	90 11		bcc $018926			bcc 	_CI32Less 					; cc return -1
.018915	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; check if zero
.018918	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.01891b	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.01891e	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.018921	f0 02		beq $018925			beq 	_CI32Exit
.018923	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.018925					_CI32Exit:
.018925	60		rts				rts
.018926					_CI32Less:
.018926	a9 ff		lda #$ff			lda 	#$FF
.018928	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.018929					BinaryOp_Add:
.018929	bd 0d 03	lda $030d,x			lda 	XS_Type,x  					; and types together
.01892c	3d 13 03	and $0313,x			and 	XS2_Type,x
.01892f	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.018931	d0 13		bne $018946			bne 	_BOAString
.018933	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018936	3d 13 03	and $0313,x			and 	XS2_Type,x
.018939	4a		lsr a				lsr 	a 							; shift bit 0 into C
.01893a	90 03		bcc $01893f			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.01893c	4c 82 89	jmp $018982			jmp 	AddInteger32 							; so execute code at \1
.01893f					_BCFloat:
.01893f	20 ce 89	jsr $0189ce			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018942	4c 92 91	jmp $019192			jmp 	FPAdd 							; and execute code at \2
.018945	60		rts				rts
.018946					_BOAString:
.018946	4c e9 89	jmp $0189e9			jmp 	ConcatenateString 			; concatenate two strings.
.018949					BinaryOp_Subtract:
.018949	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.01894c	3d 13 03	and $0313,x			and 	XS2_Type,x
.01894f	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018950	90 03		bcc $018955			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018952	4c a8 89	jmp $0189a8			jmp 	SubInteger32 							; so execute code at \1
.018955					_BCFloat:
.018955	20 ce 89	jsr $0189ce			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018958	4c 88 91	jmp $019188			jmp 	FPSubtract 							; and execute code at \2
.01895b	60		rts				rts
.01895c					BinaryOp_Multiply:
.01895c	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.01895f	3d 13 03	and $0313,x			and 	XS2_Type,x
.018962	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018963	90 03		bcc $018968			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018965	4c 14 8f	jmp $018f14			jmp 	MulInteger32 							; so execute code at \1
.018968					_BCFloat:
.018968	20 ce 89	jsr $0189ce			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.01896b	4c fe 92	jmp $0192fe			jmp 	FPMultiply 							; and execute code at \2
.01896e	60		rts				rts
.01896f					BinaryOp_Divide:
.01896f	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018972	3d 13 03	and $0313,x			and 	XS2_Type,x
.018975	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018976	90 03		bcc $01897b			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018978	4c 6b 8f	jmp $018f6b			jmp 	DivInteger32 							; so execute code at \1
.01897b					_BCFloat:
.01897b	20 ce 89	jsr $0189ce			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.01897e	4c 76 92	jmp $019276			jmp 	FPDivide 							; and execute code at \2
.018981	60		rts				rts
.018982					AddInteger32:
.018982	18		clc				clc
.018983	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018986	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.018989	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.01898c	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.01898f	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.018992	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018995	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018998	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.01899b	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01899e	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.0189a1	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.0189a4	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0189a7	60		rts				rts
.0189a8					SubInteger32:
.0189a8	38		sec				sec
.0189a9	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.0189ac	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.0189af	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0189b2	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0189b5	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.0189b8	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0189bb	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.0189be	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.0189c1	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0189c4	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.0189c7	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.0189ca	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0189cd	60		rts				rts
.0189ce					BinaryMakeBothFloat:
.0189ce	da		phx				phx 								; save X
.0189cf	e8		inx				inx
.0189d0	e8		inx				inx
.0189d1	e8		inx				inx
.0189d2	e8		inx				inx
.0189d3	e8		inx				inx
.0189d4	e8		inx				inx
.0189d5	20 d9 89	jsr $0189d9			jsr 	BinaryMakeFloat 			; convert to float.
.0189d8	fa		plx				plx 								; restore X and fall through.
.0189d9					BinaryMakeFloat:
.0189d9	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type byte.
.0189dc	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.0189dd	b0 04		bcs $0189e3			bcs 	_BMFConvert
.0189df	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.0189e0	b0 04		bcs $0189e6			bcs 	_BMFError
.0189e2	60		rts				rts
.0189e3					_BMFConvert:
.0189e3	4c b0 94	jmp $0194b0			jmp 	FPUToFloat 					; convert to float
.0189e6					_BMFError:
.0189e6	4c 07 82	jmp $018207			jmp 	TypeError
.0189e9					ConcatenateString:
.0189e9	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.0189ec	85 1a		sta $1a				sta		zLTemp1+0
.0189ee	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0189f1	85 1b		sta $1b				sta 	zLTemp1+1
.0189f3	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x
.0189f6	85 1c		sta $1c				sta 	zLTemp1+2
.0189f8	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.0189fb	85 1d		sta $1d				sta 	zLTemp1+3
.0189fd	5a		phy				phy
.0189fe	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.018a00	b1 1a		lda ($1a),y			lda 	(zlTemp1),y
.018a02	71 1c		adc ($1c),y			adc 	(zlTemp1+2),y
.018a04	7a		ply				ply
.018a05	b0 37		bcs $018a3e			bcs 	_CSError					; check in range.
.018a07	c9 fe		cmp #$fe			cmp 	#maxString+1
.018a09	b0 33		bcs $018a3e			bcs 	_CSError
.018a0b	20 2d 8e	jsr $018e2d			jsr 	AllocateTempString 			; store the result
.018a0e	20 29 8a	jsr $018a29			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.018a11	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.018a14	85 1a		sta $1a				sta 	zLTemp1
.018a16	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.018a19	85 1b		sta $1b				sta 	zLTemp1+1
.018a1b	20 29 8a	jsr $018a29			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.018a1e	a5 20		lda $20				lda 	zTempStr 					; point current to new string
.018a20	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018a23	a5 21		lda $21				lda 	zTempStr+1
.018a25	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018a28	60		rts				rts
.018a29					_CSCopyString:
.018a29	da		phx				phx
.018a2a	5a		phy				phy
.018a2b	a0 00		ldy #$00			ldy 	#0 							; get length
.018a2d	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.018a2f	f0 0a		beq $018a3b			beq 	_CSCSExit 					; if zero, exit
.018a31	aa		tax				tax 								; put in X
.018a32					_CSCSLoop:
.018a32	c8		iny				iny 								; get next char
.018a33	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.018a35	20 58 8e	jsr $018e58			jsr		WriteTempString 			; copy out
.018a38	ca		dex				dex 								; do whole string
.018a39	d0 f7		bne $018a32			bne 	_CSCSLoop
.018a3b					_CSCSExit:
.018a3b	7a		ply				ply
.018a3c	fa		plx				plx
.018a3d	60		rts				rts
.018a3e					_CSError:
.018a3e	20 26 82	jsr $018226			jsr ERR_Handler
>018a41	53 74 72 69 6e 67 20 74			.text "String too long",0
>018a49	6f 6f 20 6c 6f 6e 67 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.018a51					Unary_Sgn:
.018a51	20 8e 87	jsr $01878e			jsr 	EvaluateNumberX 			; get value
.018a54	20 1d 8e	jsr $018e1d			jsr 	CheckNextRParen 			; check right bracket.
.018a57	20 7b 8a	jsr $018a7b			jsr 	GetSignCurrent 				; get sign.
.018a5a	09 00		ora #$00			ora 	#0
.018a5c	10 09		bpl $018a67			bpl		UnarySetAInteger			; if 0,1 return that.
.018a5e	80 00		bra $018a60			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.018a60					UnarySetAMinus1:
.018a60	a9 ff		lda #$ff			lda 	#$FF
.018a62	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.018a65	80 05		bra $018a6c			bra 	UnarySetAFill
.018a67					UnarySetAInteger:
.018a67	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.018a6a	a9 00		lda #$00			lda 	#0
.018a6c					UnarySetAFill:
.018a6c	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018a6f	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018a72	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018a75	a9 01		lda #$01			lda 	#1
.018a77	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018a7a	60		rts				rts
.018a7b					GetSignCurrent:
.018a7b	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; identify type.
.018a7e	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.018a7f	90 19		bcc $018a9a			bcc 	_GSCFloat
.018a81	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.018a84	30 11		bmi $018a97			bmi 	_GSCMinus1
.018a86	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x
.018a89	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.018a8c	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.018a8f	d0 03		bne $018a94			bne 	_GSCPlus1
.018a91					_GSCZero:
.018a91	a9 00		lda #$00			lda 	#0
.018a93	60		rts				rts
.018a94					_GSCPlus1:
.018a94	a9 01		lda #$01			lda 	#$01
.018a96	60		rts				rts
.018a97					_GSCMinus1:
.018a97	a9 ff		lda #$ff			lda 	#$FF
.018a99	60		rts				rts
.018a9a					_GSCFloat:
.018a9a	3c 0d 03	bit $030d,x			bit 	XS_Type,x
.018a9d	70 f2		bvs $018a91			bvs 	_GSCZero
.018a9f	30 f6		bmi $018a97			bmi 	_GSCMinus1
.018aa1	80 f1		bra $018a94			bra 	_GSCPlus1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.018aa3					Unary_Abs:
.018aa3	20 8e 87	jsr $01878e			jsr 	EvaluateNumberX 			; get value
.018aa6	20 1d 8e	jsr $018e1d			jsr 	CheckNextRParen 			; check right bracket.
.018aa9	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.018aac	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.018aae	f0 08		beq $018ab8			beq 	_UAMinusFloat
.018ab0	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; check MSB
.018ab3	10 0b		bpl $018ac0			bpl 	_UAExit
.018ab5	4c 01 90	jmp $019001			jmp 	IntegerNegateAlways 		; negation
.018ab8					_UAMinusFloat:
.018ab8	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; clear the sign bit.
.018abb	29 7f		and #$7f			and		#$7F
.018abd	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018ac0					_UAExit:
.018ac0	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.018ac1					Unary_Peek:
.018ac1	a9 01		lda #$01			lda 	#1
.018ac3	80 06		bra $018acb			bra 	UPMain
.018ac5					Unary_Deek:
.018ac5	a9 02		lda #$02			lda 	#2
.018ac7	80 02		bra $018acb			bra 	UPMain
.018ac9					Unary_Leek:
.018ac9	a9 04		lda #$04			lda 	#4
.018acb					UPMain:
.018acb	48		pha				pha 								; set bytes to copy.
.018acc	20 9d 87	jsr $01879d			jsr 	EvaluateIntegerX 			; numeric parameter
.018acf	20 1d 8e	jsr $018e1d			jsr 	CheckNextRParen 			; right bracket.
.018ad2	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.018ad5	85 1a		sta $1a				sta 	zLTemp1
.018ad7	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018ada	85 1b		sta $1b				sta 	zLTemp1+1
.018adc	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018adf	85 1c		sta $1c				sta 	zLTemp1+2
.018ae1	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.018ae4	85 1d		sta $1d				sta 	zLTemp1+3
.018ae6	a9 00		lda #$00			lda 	#0 							; clear target area
.018ae8	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018aeb	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018aee	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018af1	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018af4	68		pla				pla 								; restore bytes to copy
.018af5	da		phx				phx 								; save XY
.018af6	5a		phy				phy
.018af7	20 f4 8d	jsr $018df4			jsr 	MemRead 					; read the bytes in
.018afa	7a		ply				ply 								; restore and exit
.018afb	fa		plx				plx
.018afc	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.018afd					Unary_Mod:
.018afd	20 29 8b	jsr $018b29			jsr 	_UMParameter 				; first parameter
.018b00	20 25 8e	jsr $018e25			jsr 	CheckNextComma
.018b03	da		phx				phx 								; second parameter
.018b04	e8		inx				inx
.018b05	e8		inx				inx
.018b06	e8		inx				inx
.018b07	e8		inx				inx
.018b08	e8		inx				inx
.018b09	e8		inx				inx
.018b0a	20 29 8b	jsr $018b29			jsr 	_UMParameter
.018b0d	fa		plx				plx
.018b0e	20 1d 8e	jsr $018e1d			jsr 	CheckNextRParen
.018b11	20 6b 8f	jsr $018f6b			jsr 	DivInteger32 				; divide
.018b14	a5 1a		lda $1a				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.018b16	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018b19	a5 1b		lda $1b				lda 	zLTemp1+1
.018b1b	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018b1e	a5 1c		lda $1c				lda 	zLTemp1+2
.018b20	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018b23	a5 1d		lda $1d				lda 	zLTemp1+3
.018b25	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018b28	60		rts				rts
.018b29					_UMParameter:
.018b29	20 9d 87	jsr $01879d			jsr 	EvaluateIntegerX 			; get value
.018b2c	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; absolute value
.018b2f	10 03		bpl $018b34			bpl 	_UMNotSigned
.018b31	20 01 90	jsr $019001			jsr 	IntegerNegateAlways
.018b34					_UMNotSigned:
.018b34	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.018b35					Unary_Usr:
.018b35	20 8e 87	jsr $01878e			jsr 	EvaluateNumberX 			; numeric parameter
.018b38	20 1d 8e	jsr $018e1d			jsr 	CheckNextRParen 			; right bracket.
.018b3b	da		phx				phx 								; save XY
.018b3c	5a		phy				phy
.018b3d	ea		nop				nop
.018b3e	22 00 03 00	jsl $000300			jsl 	UserVector
.018b42	7a		ply				ply 								; and exit
.018b43	fa		plx				plx
.018b44	60		rts				rts
.018b45					USRDefault:
.018b45	20 26 82	jsr $018226			jsr ERR_Handler
>018b48	4e 6f 20 55 53 52 20 76			.text "No USR vector.",0
>018b50	65 63 74 6f 72 2e 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.018b57					Unary_Val:
.018b57	20 a6 87	jsr $0187a6			jsr 	EvaluateStringX 			; get string
.018b5a	20 1d 8e	jsr $018e1d			jsr 	CheckNextRParen 			; check right bracket.
.018b5d	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.018b60	85 1e		sta $1e				sta 	zGenPtr
.018b62	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018b65	85 1f		sta $1f				sta 	zGenPtr+1
.018b67	5a		phy				phy
.018b68	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.018b6a	b1 1e		lda ($1e),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.018b6c	f0 57		beq $018bc5			beq 	_UVBadNumber
.018b6e	48		pha				pha 								; save length.
.018b6f	1a		inc a				inc 	a 							; one for the length, one for the terminator
.018b70	1a		inc a				inc 	a
.018b71	20 2d 8e	jsr $018e2d			jsr 	AllocateTempString
.018b74	c8		iny				iny 								; move to the next.
.018b75	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get character
.018b77	49 2d		eor #$2d			eor 	#"-"						; zero if minus sign
.018b79	8d 2c 04	sta $042c			sta 	ValSign
.018b7c	d0 04		bne $018b82			bne 	_UVNotMinus
.018b7e	c8		iny				iny 								; skip over it.
.018b7f	68		pla				pla 								; decrement character count.
.018b80	3a		dec a				dec 	a
.018b81	48		pha				pha
.018b82					_UVNotMinus:
.018b82	68		pla				pla 								; this is the count.
.018b83	48		pha		_UVCopy:pha									; copy into new temp string which is ASCIIZ
.018b84	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018b86	c8		iny				iny
.018b87	20 58 8e	jsr $018e58			jsr 	WriteTempString
.018b8a	68		pla				pla
.018b8b	3a		dec a				dec 	a
.018b8c	d0 f5		bne $018b83			bne 	_UVCopy
.018b8e	20 58 8e	jsr $018e58			jsr 	WriteTempString 			; make it ASCIIZ
.018b91	18		clc				clc
.018b92	a5 20		lda $20				lda 	zTempStr 					; tempstring +1 => genptr
.018b94	69 01		adc #$01			adc 	#1
.018b96	85 1e		sta $1e				sta 	zGenPtr
.018b98	a5 21		lda $21				lda 	zTempStr+1
.018b9a	69 00		adc #$00			adc 	#0
.018b9c	85 1f		sta $1f				sta 	zGenPtr+1
.018b9e	18		clc				clc
.018b9f	20 dd 90	jsr $0190dd			jsr 	IntFromString 				; first bit.
.018ba2	b0 21		bcs $018bc5			bcs 	_UVBadNumber
.018ba4	20 01 97	jsr $019701			jsr 	FPFromString				; try for a float part.
.018ba7	ad 2c 04	lda $042c			lda 	ValSign 					; was it negative
.018baa	d0 13		bne $018bbf			bne 	_UVNotNegative
.018bac	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; check if integer
.018baf	4a		lsr a				lsr 	a
.018bb0	b0 0a		bcs $018bbc			bcs 	_UVInteger
.018bb2	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; set sign bit
.018bb5	09 80		ora #$80			ora 	#$80
.018bb7	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018bba	80 03		bra $018bbf			bra 	_UVNotNegative
.018bbc					_UVInteger:
.018bbc	20 01 90	jsr $019001			jsr 	IntegerNegateAlways 		; sign it.
.018bbf					_UVNotNegative:
.018bbf	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; used everything
.018bc1	d0 02		bne $018bc5			bne 	_UVBadNumber
.018bc3	7a		ply				ply
.018bc4	60		rts				rts
.018bc5					_UVBadNumber:
.018bc5	4c 15 82	jmp $018215			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.018bc8					Unary_Str:
.018bc8	20 8e 87	jsr $01878e			jsr 	EvaluateNumberX 			; numeric parameter
.018bcb	20 1d 8e	jsr $018e1d			jsr 	CheckNextRParen 			; right bracket.
.018bce	a9 00		lda #$00			lda 	#0 							; reset buffer index
.018bd0	8d 00 04	sta $0400			sta 	NumBufX
.018bd3	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.018bd6	4a		lsr a				lsr 	a
.018bd7	b0 05		bcs $018bde			bcs 	_USInt 						; if msb set do as integer
.018bd9	20 3a 96	jsr $01963a			jsr 	FPToString 					; call fp to str otherwise
.018bdc	80 03		bra $018be1			bra 	_USDuplicate
.018bde	20 26 90	jsr $019026	_USInt:	jsr 	IntToString
.018be1					_USDuplicate:
.018be1	ad 00 04	lda $0400			lda 	NumBufX 					; chars in buffer
.018be4	1a		inc a				inc 	a 							; one more for length
.018be5	20 2d 8e	jsr $018e2d			jsr 	AllocateTempString 			; allocate space for it.
.018be8	5a		phy				phy 								; save Y
.018be9	a0 00		ldy #$00			ldy 	#0 							; start copying
.018beb	b9 01 04	lda $0401,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.018bee	20 58 8e	jsr $018e58			jsr 	WriteTempString
.018bf1	c8		iny				iny
.018bf2	cc 00 04	cpy $0400			cpy 	NumBufX 					; done the lot
.018bf5	d0 f4		bne $018beb			bne 	_USCopy
.018bf7	7a		ply				ply 								; restore Y
.018bf8	4c e4 8d	jmp $018de4			jmp 	UnaryReturnTempStr 			; return new temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.018bfb					Unary_Asc:
.018bfb	20 a6 87	jsr $0187a6			jsr 	EvaluateStringX 			; string parameter
.018bfe	20 1d 8e	jsr $018e1d			jsr 	CheckNextRParen 			; right bracket.
.018c01	5a		phy				phy 								; get the string length
.018c02	a0 00		ldy #$00			ldy 	#0
.018c04	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018c06	f0 07		beq $018c0f			beq 	_UAIllegal 					; must be at least one character
.018c08	c8		iny				iny
.018c09	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; read it.
.018c0b	7a		ply				ply
.018c0c	4c 67 8a	jmp $018a67			jmp 	UnarySetAInteger
.018c0f					_UAIllegal:
.018c0f	4c 15 82	jmp $018215			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.018c12					Unary_Len:
.018c12	20 a6 87	jsr $0187a6			jsr 	EvaluateStringX 			; string parameter
.018c15	20 1d 8e	jsr $018e1d			jsr 	CheckNextRParen 			; right bracket.
.018c18	5a		phy				phy 								; get the string length
.018c19	a0 00		ldy #$00			ldy 	#0
.018c1b	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018c1d	7a		ply				ply
.018c1e	4c 67 8a	jmp $018a67			jmp 	UnarySetAInteger

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.018c21					Unary_Mid:
.018c21	20 a6 87	jsr $0187a6			jsr 	EvaluateStringX 				; get string.
.018c24	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.018c27	48		pha				pha
.018c28	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018c2b	48		pha				pha
.018c2c	20 25 8e	jsr $018e25			jsr 	CheckNextComma 					; skip comma
.018c2f	20 bc 8c	jsr $018cbc			jsr 	SLIByteParameter 				; get a byte parameter (start)
.018c32	48		pha				pha 									; and push it.
.018c33	20 25 8e	jsr $018e25			jsr 	CheckNextComma 					; skip comma
.018c36	20 bc 8c	jsr $018cbc			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.018c39	48		pha				pha 									; and push it.
.018c3a	80 45		bra $018c81			bra 	SLIProcess
.018c3c					Unary_Left:
.018c3c	20 a6 87	jsr $0187a6			jsr 	EvaluateStringX 				; get string.
.018c3f	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.018c42	48		pha				pha
.018c43	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018c46	48		pha				pha
.018c47	a9 01		lda #$01			lda 	#1 								; push start position (1)
.018c49	48		pha				pha
.018c4a	20 25 8e	jsr $018e25			jsr 	CheckNextComma 					; skip comma
.018c4d	20 bc 8c	jsr $018cbc			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.018c50	48		pha				pha 									; and push it.
.018c51	80 2e		bra $018c81			bra 	SLIProcess
.018c53					Unary_Right:
.018c53	20 a6 87	jsr $0187a6			jsr 	EvaluateStringX 				; get string.
.018c56	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.018c59	48		pha				pha
.018c5a	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018c5d	48		pha				pha
.018c5e	da		phx				phx 									; get the string length and push on stack.
.018c5f	a2 00		ldx #$00			ldx 	#0
.018c61	a1 1e		lda ($1e,x)			lda		(zGenPtr,x)
.018c63	fa		plx				plx
.018c64	48		pha				pha
.018c65	20 25 8e	jsr $018e25			jsr 	CheckNextComma 					; skip comma
.018c68	20 bc 8c	jsr $018cbc			jsr 	SLIByteParameter 				; get a byte parameter.
.018c6b	8d 28 04	sta $0428			sta 	SignCount 						; save in temporary.
.018c6e	68		pla				pla 									; restore string length.
.018c6f	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.018c70	38		sec				sec
.018c71	ed 28 04	sbc $0428			sbc 	SignCount 						; subtract characters needed, gives start position.
.018c74	f0 02		beq $018c78			beq 	_URStart 						; if <= 0 start from 1.
.018c76	10 02		bpl $018c7a			bpl 	_UROkay
.018c78					_URStart:
.018c78	a9 01		lda #$01			lda 	#1
.018c7a					_UROkay:
.018c7a	48		pha				pha 									; push start
.018c7b	ad 28 04	lda $0428			lda 	SignCount 						; push count of characters
.018c7e	48		pha				pha
.018c7f	80 00		bra $018c81			bra 	SLIProcess
.018c81					SLIProcess:
.018c81	20 1d 8e	jsr $018e1d			jsr 	CheckNextRParen 				; closing right bracket.
.018c84	68		pla				pla
.018c85	8d 2e 04	sta $042e			sta 	SliceCount 						; count in signcount
.018c88	1a		inc a				inc 	a 								; allocate +1 for it.
.018c89	20 2d 8e	jsr $018e2d			jsr 	AllocateTempString
.018c8c	68		pla				pla 									; pop start number off stack.
.018c8d	f0 3f		beq $018cce			beq 	SLIError 						; exit if start = 0
.018c8f	8d 2d 04	sta $042d			sta 	SliceStart
.018c92	68		pla				pla  									; pop string address.
.018c93	85 1f		sta $1f				sta 	zGenPtr+1
.018c95	68		pla				pla
.018c96	85 1e		sta $1e				sta 	zGenPtr
.018c98	da		phx				phx
.018c99	5a		phy				phy
.018c9a	a2 00		ldx #$00			ldx 	#0 								; point to string length.
.018c9c	ac 2d 04	ldy $042d			ldy 	SliceStart 						; start of the string (+1 for count)
.018c9f					_SLICopy:
.018c9f	ad 2e 04	lda $042e			lda 	SliceCount 						; done count characters
.018ca2	f0 12		beq $018cb6			beq 	_SLIExit
.018ca4	ce 2e 04	dec $042e			dec 	SliceCount
.018ca7	98		tya				tya 									; index of character
.018ca8	c1 1e		cmp ($1e,x)			cmp 	(zGenPtr,x)						; compare against length
.018caa	f0 02		beq $018cae			beq 	_SLIOk 							; if equal, okay.
.018cac	b0 08		bcs $018cb6			bcs 	_SLIExit 						; if past end, then exit.
.018cae	b1 1e		lda ($1e),y	_SLIOk:	lda 	(zGenPtr),y 					; copy one character
.018cb0	c8		iny				iny
.018cb1	20 58 8e	jsr $018e58			jsr 	WriteTempString
.018cb4	80 e9		bra $018c9f			bra 	_SLICopy 						; go round till copied characters
.018cb6					_SLIExit:
.018cb6	7a		ply				ply 									; restore YX
.018cb7	fa		plx				plx
.018cb8	4c e4 8d	jmp $018de4			jmp 	UnaryReturnTempStr 				; return new temporary string.
.018cbb	ea		nop				nop
.018cbc					SLIByteParameter:
.018cbc	20 9d 87	jsr $01879d			jsr 	EvaluateIntegerX 				; get integer
.018cbf	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.018cc2	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.018cc5	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.018cc8	d0 04		bne $018cce			bne 	SLIError
.018cca	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018ccd	60		rts				rts
.018cce					SLIError:
.018cce	4c 15 82	jmp $018215			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.018cd1					Unary_Hex:
.018cd1	20 9d 87	jsr $01879d			jsr 	EvaluateIntegerX 			; numeric parameter
.018cd4	20 1d 8e	jsr $018e1d			jsr 	CheckNextRParen 			; right bracket.
.018cd7	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.018cd9	20 2d 8e	jsr $018e2d			jsr 	AllocateTempString			; allocate string space
.018cdc	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.018cdf	20 06 8d	jsr $018d06			jsr 	_UHConvert
.018ce2	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018ce5	20 06 8d	jsr $018d06			jsr 	_UHConvert
.018ce8	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018ceb	20 06 8d	jsr $018d06			jsr 	_UHConvert
.018cee	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018cf1	20 06 8d	jsr $018d06			jsr 	_UHConvert
.018cf4	5a		phy				phy 								; get length of new string
.018cf5	a0 00		ldy #$00			ldy 	#0
.018cf7	b1 20		lda ($20),y			lda 	(zTempStr),y
.018cf9	7a		ply				ply
.018cfa	c9 00		cmp #$00			cmp 	#0
.018cfc	d0 05		bne $018d03			bne 	_UHExit 					; if it was non zero okay
.018cfe	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.018d00	20 58 8e	jsr $018e58			jsr 	WriteTempString
.018d03					_UHExit:
.018d03	4c e4 8d	jmp $018de4			jmp 	UnaryReturnTempStr 			; return new temporary string.
.018d06					_UHConvert:
.018d06	48		pha				pha
.018d07	4a		lsr a				lsr 	a 							; do MSB
.018d08	4a		lsr a				lsr 	a
.018d09	4a		lsr a				lsr 	a
.018d0a	4a		lsr a				lsr 	a
.018d0b	20 0f 8d	jsr $018d0f			jsr 	_UHNibble
.018d0e	68		pla				pla 								; do LSB
.018d0f					_UHNibble:
.018d0f	29 0f		and #$0f			and 	#15 						; get nibble
.018d11	d0 0c		bne $018d1f			bne 	_UHNonZero
.018d13	5a		phy				phy									; get the length
.018d14	a0 00		ldy #$00			ldy 	#0
.018d16	b1 20		lda ($20),y			lda 	(zTempStr),y
.018d18	7a		ply				ply
.018d19	c9 00		cmp #$00			cmp 	#0 							; suppress leading zeros.
.018d1b	f0 0d		beq $018d2a			beq 	_UHExit2
.018d1d	a9 00		lda #$00			lda 	#0
.018d1f					_UHNonZero:
.018d1f	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.018d21	90 02		bcc $018d25			bcc 	_UHDigit
.018d23	69 06		adc #$06			adc 	#7-1
.018d25					_UHDigit:
.018d25	69 30		adc #$30			adc 	#48
.018d27	20 58 8e	jsr $018e58			jsr 	WriteTempString				; output.
.018d2a					_UHExit2:
.018d2a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.018d2b					Unary_Dec:
.018d2b	20 a6 87	jsr $0187a6			jsr 	EvaluateStringX 			; string parameter
.018d2e	20 1d 8e	jsr $018e1d			jsr 	CheckNextRParen 			; right bracket.
.018d31	5a		phy				phy
.018d32	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.018d34	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018d36	f0 4c		beq $018d84			beq 	_UDFail 					; must fail if zero.
.018d38	8d 28 04	sta $0428			sta 	SignCount 					; use SignCount as a counter
.018d3b	a9 00		lda #$00			lda 	#0 							; set result to zero integer.
.018d3d	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018d40	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018d43	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018d46	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018d49	a9 01		lda #$01			lda 	#1
.018d4b	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018d4e					_UDConvertLoop:
.018d4e	5a		phy				phy 								; shift mantissa left 4
.018d4f	a0 04		ldy #$04			ldy 	#4
.018d51					_UDShift:
.018d51	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x
.018d54	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.018d57	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.018d5a	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.018d5d	88		dey				dey
.018d5e	d0 f1		bne $018d51			bne 	_UDShift
.018d60	7a		ply				ply
.018d61	c8		iny				iny 								; next character
.018d62	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; fetch it.
.018d64	20 87 8d	jsr $018d87			jsr 	ConvertUpper 				; convert to U/C
.018d67	c9 30		cmp #$30			cmp 	#"0"
.018d69	90 19		bcc $018d84			bcc 	_UDFail
.018d6b	c9 3a		cmp #$3a			cmp 	#"9"+1
.018d6d	90 06		bcc $018d75			bcc 	_UDOkay
.018d6f	e9 37		sbc #$37			sbc 	#7+"0" 						; alpha fudge
.018d71	c9 10		cmp #$10			cmp 	#16
.018d73	b0 0f		bcs $018d84			bcs 	_UDFail
.018d75					_UDOkay:
.018d75	29 0f		and #$0f			and 	#15 						; nibble only
.018d77	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x
.018d7a	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018d7d	ce 28 04	dec $0428			dec 	SignCount 					; do it for each character
.018d80	d0 cc		bne $018d4e			bne 	_UDConvertLoop
.018d82	7a		ply				ply
.018d83	60		rts				rts
.018d84					_UDFail:
.018d84	4c 15 82	jmp $018215			jmp 	BadParamError
.018d87					ConvertUpper:
.018d87	c9 61		cmp #$61			cmp 	#"a"
.018d89	90 07		bcc $018d92			bcc 	_CUExit
.018d8b	c9 7b		cmp #$7b			cmp 	#"z"+1
.018d8d	b0 03		bcs $018d92			bcs 	_CUExit
.018d8f	38		sec				sec
.018d90	e9 20		sbc #$20			sbc 	#32
.018d92	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.018d93					Unary_Chr:
.018d93	20 9d 87	jsr $01879d			jsr 	EvaluateIntegerX			; numeric parameter
.018d96	20 1d 8e	jsr $018e1d			jsr 	CheckNextRParen 			; right bracket.
.018d99	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.018d9c	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.018d9f	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.018da2	d0 0e		bne $018db2			bne 	_UCChar
.018da4	a9 01		lda #$01			lda 	#1 							; one character string
.018da6	20 2d 8e	jsr $018e2d			jsr 	AllocateTempString
.018da9	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.018dac	20 58 8e	jsr $018e58			jsr 	WriteTempString
.018daf	4c e4 8d	jmp $018de4			jmp 	UnaryReturnTempStr
.018db2					_UCChar:
.018db2	4c 15 82	jmp $018215			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.018db5					Unary_Spc:
.018db5	20 9d 87	jsr $01879d			jsr 	EvaluateIntegerX 			; numeric parameter
.018db8	20 1d 8e	jsr $018e1d			jsr 	CheckNextRParen 			; right bracket.
.018dbb	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.018dbe	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.018dc1	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.018dc4	d0 1b		bne $018de1			bne 	_USSize
.018dc6	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018dc9	c9 fe		cmp #$fe			cmp 	#maxString+1
.018dcb	b0 14		bcs $018de1			bcs 	_USSize
.018dcd	48		pha				pha 								; save length
.018dce	1a		inc a				inc 	a 							; allocate one more.
.018dcf	20 2d 8e	jsr $018e2d			jsr 	AllocateTempString
.018dd2	68		pla				pla 								; get length
.018dd3	f0 0f		beq $018de4			beq 	UnaryReturnTempStr 			; return the current temp string
.018dd5					_USLoop:
.018dd5	48		pha				pha
.018dd6	a9 20		lda #$20			lda 	#" "
.018dd8	20 58 8e	jsr $018e58			jsr 	WriteTempString
.018ddb	68		pla				pla
.018ddc	3a		dec a				dec 	a
.018ddd	d0 f6		bne $018dd5			bne 	_USLoop
.018ddf	80 03		bra $018de4			bra 	UnaryReturnTempStr
.018de1					_USSize:
.018de1	4c 15 82	jmp $018215			jmp 	BadParamError
.018de4					UnaryReturnTempStr:
.018de4	a5 20		lda $20				lda 	zTempStr 					; copy temp string addr -> mantissa
.018de6	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018de9	a5 21		lda $21				lda 	zTempStr+1
.018deb	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018dee	a9 02		lda #$02			lda 	#2 							; set type to string
.018df0	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018df3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/65816.asm

.018df4					MemRead:
.018df4	8d 28 04	sta $0428			sta 	SignCount 					; save count
.018df7	a0 00		ldy #$00			ldy 	#0 							; start from here
.018df9	b7 1a		lda [$1a],y	_MLoop1:lda 	[zlTemp1],y 				; read the long address
.018dfb	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; copy into mantissa
.018dfe	c8		iny				iny 								; next to copy
.018dff	e8		inx				inx
.018e00	cc 28 04	cpy $0428			cpy 	SignCount 					; do required # of bytes.
.018e03	d0 f4		bne $018df9			bne 	_MLoop1
.018e05	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.018e06					CheckNextToken:
.018e06	d7 16		cmp [$16],y			cmp 	[zCodePtr],y
.018e08	d0 02		bne $018e0c			bne 	CTFail 						; no, then fail
.018e0a	c8		iny				iny
.018e0b	60		rts				rts
.018e0c					CTFail:
.018e0c	20 26 82	jsr $018226			jsr ERR_Handler
>018e0f	4d 69 73 73 69 6e 67 20			.text "Missing token",0
>018e17	74 6f 6b 65 6e 00
.018e1d					CheckNextRParen:
.018e1d	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e1f	c9 bc		cmp #$bc			cmp 	#token_rparen
.018e21	d0 e9		bne $018e0c			bne 	CTFail
.018e23	c8		iny				iny
.018e24	60		rts				rts
.018e25					CheckNextComma:
.018e25	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e27	c9 bd		cmp #$bd			cmp 	#token_comma
.018e29	d0 e1		bne $018e0c			bne 	CTFail
.018e2b	c8		iny				iny
.018e2c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.018e2d					AllocateTempString:
.018e2d	48		pha				pha 								; save required count.
.018e2e	a5 21		lda $21				lda 	zTempStr+1 					; check if initialised yet ?
.018e30	d0 0b		bne $018e3d			bne 	_ATSInitialised
.018e32	ad 29 04	lda $0429			lda 	StringPtr 					; set temporary string ptr 1 page below available
.018e35	85 20		sta $20				sta 	zTempStr					; space, this is for strings to be concreted.
.018e37	ad 2a 04	lda $042a			lda 	StringPtr+1
.018e3a	3a		dec a				dec 	a
.018e3b	85 21		sta $21				sta 	zTempStr+1
.018e3d					_ATSInitialised:
.018e3d	68		pla				pla 								; get required count back.
.018e3e	49 ff		eor #$ff			eor 	#$FF 						; negate 2's complement.
.018e40	1a		inc a				inc 	a
.018e41	18		clc				clc
.018e42	65 20		adc $20				adc 	zTempStr 					; "add" to the temp string pointer
.018e44	85 20		sta $20				sta 	zTempStr
.018e46	a9 ff		lda #$ff			lda 	#$FF
.018e48	65 21		adc $21				adc 	zTempStr+1
.018e4a	85 21		sta $21				sta 	zTempStr+1
.018e4c	a9 00		lda #$00			lda 	#0 							; clear temp string.
.018e4e	5a		phy				phy
.018e4f	a8		tay				tay
.018e50	91 20		sta ($20),y			sta 	(zTempStr),y
.018e52	7a		ply				ply
.018e53	1a		inc a				inc 	a 							; reset the write index.
.018e54	8d 2b 04	sta $042b			sta 	TempStringWriteIndex
.018e57	60		rts				rts
.018e58					WriteTempString:
.018e58	5a		phy				phy 								; save Y
.018e59	ac 2b 04	ldy $042b			ldy 	TempStringWriteIndex	 	; write position.
.018e5c	91 20		sta ($20),y			sta 	(zTempStr),y 				; write character out.
.018e5e	ee 2b 04	inc $042b			inc 	TempStringWriteIndex 		; increment the write position.
.018e61	98		tya				tya 								; unchanged Y is now length
.018e62	a0 00		ldy #$00			ldy 	#0
.018e64	91 20		sta ($20),y			sta 	(zTempStr),y
.018e66	7a		ply				ply 								; restore Y and exit
.018e67	60		rts				rts
.018e68					CreateTempStringCopy:
.018e68	da		phx				phx 								; save X
.018e69	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e6b	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.018e6c	20 2d 8e	jsr $018e2d			jsr 	AllocateTempString 			; allocate memory for temporary string.
.018e6f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e71	c8		iny				iny
.018e72	3a		dec a				dec 	a 							; make the actual length in charactes
.018e73	3a		dec a				dec 	a
.018e74	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.018e76	81 20		sta ($20,x)			sta 	(zTempStr,x)
.018e78	85 1a		sta $1a				sta 	zLTemp1 					; that's used as a count.
.018e7a	09 00		ora #$00			ora 	#0 							; if zero already, exit
.018e7c	f0 0e		beq $018e8c			beq 	_CTSCExit
.018e7e					_CTSCLoop:
.018e7e	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e80	c8		iny				iny
.018e81	5a		phy				phy 								; save in Y
.018e82	e8		inx				inx 								; bump index
.018e83	da		phx				phx 								; index into Y
.018e84	7a		ply				ply
.018e85	91 20		sta ($20),y			sta 	(zTempStr),y 				; save at index
.018e87	7a		ply				ply 								; restore Y
.018e88	c6 1a		dec $1a				dec 	zLTemp1 					; do for each character
.018e8a	d0 f2		bne $018e7e			bne 	_CTSCLoop
.018e8c					_CTSCExit:
.018e8c	fa		plx				plx 								; restore X
.018e8d	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/variables.asm

.018e8e					VariableNameError:
.018e8e	20 26 82	jsr $018226			jsr ERR_Handler
>018e91	42 61 64 20 56 61 72 69			.text "Bad Variable Name",0
>018e99	61 62 6c 65 20 4e 61 6d 65 00
.018ea3					VariableFind:
.018ea3	da		phx				phx 							; save X.
.018ea4	a9 b8		lda #$b8			lda 	#token_hashlParen  		; set the type to #( e.g. real array.
.018ea6	8d 21 04	sta $0421			sta 	Var_Type
.018ea9	8d 22 04	sta $0422			sta 	Var_Hash 				; we initialise the hash with this. It doesn't matter
.018eac	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018eae	c9 00		cmp #$00			cmp 	#0 						; first one must be A-Z
.018eb0	f0 dc		beq $018e8e			beq 	VariableNameError
.018eb2	c9 1b		cmp #$1b			cmp 	#26+1
.018eb4	b0 d8		bcs $018e8e			bcs 	VariableNameError
.018eb6	a2 ff		ldx #$ff			ldx 	#255 					; now copy it into the variable buffer.
.018eb8					_VFCopyBuffer:
.018eb8	e8		inx				inx
.018eb9	e0 1f		cpx #$1f			cpx 	#31 					; too long
.018ebb	f0 d1		beq $018e8e			beq 	VariableNameError
.018ebd	9d 01 04	sta $0401,x			sta 	Var_Buffer,x 			; save character
.018ec0	18		clc				clc  							; update the hash value for it.
.018ec1	6d 22 04	adc $0422			adc 	Var_Hash
.018ec4	8d 22 04	sta $0422			sta 	Var_Hash
.018ec7	c8		iny				iny
.018ec8	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018eca	c9 00		cmp #$00			cmp 	#0 						; zero or token, end of variable
.018ecc	f0 0e		beq $018edc			beq 	_VFCopyEnd
.018ece	30 0c		bmi $018edc			bmi 	_VFCopyEnd
.018ed0	c9 1b		cmp #$1b			cmp 	#26+1 					; A-Z continue copying
.018ed2	90 e4		bcc $018eb8			bcc 	_VFCopyBuffer
.018ed4	c9 30		cmp #$30			cmp 	#"0" 					; 0-9 copy as well.
.018ed6	90 04		bcc $018edc			bcc 	_VFCopyEnd
.018ed8	c9 3a		cmp #$3a			cmp 	#"9"+1
.018eda	b0 dc		bcs $018eb8			bcs 	_VFCopyBuffer
.018edc					_VFCopyEnd:
.018edc	c8		iny				iny
.018edd	c9 b5		cmp #$b5			cmp 	#token_Dollar 			; first type token.
.018edf	90 04		bcc $018ee5			bcc 	_VFDefaultRequired
.018ee1	c9 bb		cmp #$bb			cmp 	#token_PercentLParen+1	; last type token.
.018ee3	90 0b		bcc $018ef0			bcc 	_VFHaveType
.018ee5					_VFDefaultRequired:
.018ee5	c9 bb		cmp #$bb			cmp 	#token_LParen 			; if it ends in ( then use the real array
.018ee7	f0 04		beq $018eed			beq 	_VFSetType 				; default set above.
.018ee9	ce 21 04	dec $0421			dec 	Var_Type 				; this changes that default to the variable default
.018eec	88		dey				dey
.018eed					_VFSetType:
.018eed	ad 21 04	lda $0421			lda 	Var_Type 				; get type ....
.018ef0					_VFHaveType:
.018ef0	8d 21 04	sta $0421			sta 	Var_Type 				; save as type.
.018ef3	bd 01 04	lda $0401,x			lda 	Var_Buffer,x 			; set bit 7 of name, marks the end.
.018ef6	09 80		ora #$80			ora 	#$80
.018ef8	9d 01 04	sta $0401,x			sta 	Var_Buffer,x
.018efb	e8		inx				inx 							; offset 3 => length 4.
.018efc	8e 23 04	stx $0423			stx 	Var_Length 				; save length of variable name.
.018eff	5a		phy				phy 							; Y and X now both saved on the stack.
.018f00	ea		nop				nop
.018f01					VariableClear:
.018f01	48		pha				pha 							; save registers
.018f02	da		phx				phx
.018f03	a2 00		ldx #$00			ldx 	#0 						; clear out the hash table.
.018f05	8a		txa				txa
.018f06	a9 aa		lda #$aa			lda 	#$AA
.018f08	9d 3e 04	sta $043e,x	_VCLoop:sta 	HashTableBase,x
.018f0b	e8		inx				inx
.018f0c	e0 60		cpx #$60			cpx 	#HashTableEnd-HashTableBase
.018f0e	d0 f8		bne $018f08			bne 	_VCLoop
.018f10	fa		plx				plx 							; restore registers
.018f11	68		pla				pla
.018f12	60		rts				rts
.018f13					VariableGet:
.018f13	ea		nop				nop

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.018f14					MulInteger32:
.018f14	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.018f17	9d 14 03	sta $0314,x			sta 	XS3_Mantissa,x
.018f1a	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018f1d	9d 15 03	sta $0315,x			sta 	XS3_Mantissa+1,x
.018f20	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018f23	9d 16 03	sta $0316,x			sta 	XS3_Mantissa+2,x
.018f26	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.018f29	9d 17 03	sta $0317,x			sta 	XS3_Mantissa+3,x
.018f2c	a9 00		lda #$00			lda 	#0
.018f2e	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x 				; zero +0
.018f31	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018f34	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018f37	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018f3a					_BFMMultiply:
.018f3a	bd 14 03	lda $0314,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.018f3d	29 01		and #$01			and 	#1
.018f3f	f0 03		beq $018f44			beq 	_BFMNoAdd
.018f41	20 82 89	jsr $018982			jsr 	AddInteger32
.018f44					_BFMNoAdd:
.018f44	1e 0e 03	asl $030e,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.018f47	3e 0f 03	rol $030f,x			rol 	XS2_Mantissa+1,x
.018f4a	3e 10 03	rol $0310,x			rol 	XS2_Mantissa+2,x
.018f4d	3e 11 03	rol $0311,x			rol 	XS2_Mantissa+3,x
.018f50	5e 17 03	lsr $0317,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.018f53	7e 16 03	ror $0316,x			ror 	XS3_Mantissa+2,x
.018f56	7e 15 03	ror $0315,x			ror 	XS3_Mantissa+1,x
.018f59	7e 14 03	ror $0314,x			ror 	XS3_Mantissa,x
.018f5c	bd 14 03	lda $0314,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.018f5f	1d 15 03	ora $0315,x			ora 	XS3_Mantissa+1,x
.018f62	1d 16 03	ora $0316,x			ora 	XS3_Mantissa+2,x
.018f65	1d 17 03	ora $0317,x			ora 	XS3_Mantissa+3,x
.018f68	d0 d0		bne $018f3a			bne 	_BFMMultiply
.018f6a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.018f6b					DivInteger32:
.018f6b	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; check for /0
.018f6e	1d 0f 03	ora $030f,x			ora 	XS2_Mantissa+1,x
.018f71	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.018f74	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.018f77	d0 14		bne $018f8d			bne 	_BFDOkay
.018f79	20 26 82	jsr $018226			jsr ERR_Handler
>018f7c	44 69 76 69 73 69 6f 6e			.text "Division by Zero",0
>018f84	20 62 79 20 5a 65 72 6f 00
.018f8d					_BFDOkay:
.018f8d	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.018f8f	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.018f91	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.018f93	85 1c		sta $1c				sta 	zLTemp1+2
.018f95	85 1d		sta $1d				sta 	zLTemp1+3
.018f97	8d 28 04	sta $0428			sta 	SignCount 					; Count of signs.
.018f9a	20 fb 8f	jsr $018ffb			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.018f9d	da		phx				phx
.018f9e	e8		inx				inx
.018f9f	e8		inx				inx
.018fa0	e8		inx				inx
.018fa1	e8		inx				inx
.018fa2	e8		inx				inx
.018fa3	e8		inx				inx
.018fa4	20 fb 8f	jsr $018ffb			jsr 	CheckIntegerNegate
.018fa7	fa		plx				plx
.018fa8	5a		phy				phy 								; Y is the counter
.018fa9	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.018fab					_BFDLoop:
.018fab	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.018fae	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.018fb1	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.018fb4	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.018fb7	26 1a		rol $1a				rol 	zLTemp1
.018fb9	26 1b		rol $1b				rol 	zLTemp1+1
.018fbb	26 1c		rol $1c				rol 	zLTemp1+2
.018fbd	26 1d		rol $1d				rol 	zLTemp1+3
.018fbf	38		sec				sec
.018fc0	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.018fc2	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.018fc5	48		pha				pha
.018fc6	a5 1b		lda $1b				lda 	zLTemp1+1
.018fc8	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.018fcb	48		pha				pha
.018fcc	a5 1c		lda $1c				lda 	zLTemp1+2
.018fce	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.018fd1	48		pha				pha
.018fd2	a5 1d		lda $1d				lda 	zLTemp1+3
.018fd4	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.018fd7	90 15		bcc $018fee			bcc 	_BFDNoAdd
.018fd9	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.018fdb	68		pla				pla
.018fdc	85 1c		sta $1c				sta 	zLTemp1+2
.018fde	68		pla				pla
.018fdf	85 1b		sta $1b				sta 	zLTemp1+1
.018fe1	68		pla				pla
.018fe2	85 1a		sta $1a				sta 	zLTemp1+0
.018fe4	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.018fe7	09 01		ora #$01			ora 	#1
.018fe9	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018fec	80 03		bra $018ff1			bra 	_BFDNext
.018fee					_BFDNoAdd:
.018fee	68		pla				pla 								; Throw away the intermediate calculations
.018fef	68		pla				pla
.018ff0	68		pla				pla
.018ff1					_BFDNext:
.018ff1	88		dey				dey
.018ff2	d0 b7		bne $018fab			bne 	_BFDLoop
.018ff4	7a		ply				ply 								; restore Y and exit
.018ff5	4e 28 04	lsr $0428			lsr 	SignCount 					; if sign count odd,
.018ff8	b0 07		bcs $019001			bcs		IntegerNegateAlways 			; negate the result
.018ffa	60		rts				rts
.018ffb					CheckIntegerNegate:
.018ffb	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.018ffe	30 01		bmi $019001			bmi 	IntegerNegateAlways
.019000	60		rts				rts
.019001					IntegerNegateAlways:
.019001	ee 28 04	inc $0428			inc 	SignCount
.019004	38		sec				sec
.019005	a9 00		lda #$00			lda 	#0
.019007	fd 08 03	sbc $0308,x			sbc 	XS_Mantissa+0,x
.01900a	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.01900d	a9 00		lda #$00			lda 	#0
.01900f	fd 09 03	sbc $0309,x			sbc 	XS_Mantissa+1,x
.019012	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019015	a9 00		lda #$00			lda 	#0
.019017	fd 0a 03	sbc $030a,x			sbc 	XS_Mantissa+2,x
.01901a	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01901d	a9 00		lda #$00			lda 	#0
.01901f	fd 0b 03	sbc $030b,x			sbc 	XS_Mantissa+3,x
.019022	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019025	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.019026					INTToString:
.019026	48		pha				pha
.019027	5a		phy				phy
.019028	bd 0b 03	lda $030b,x			lda 		XS_Mantissa+3,x 		; check -ve
.01902b	10 08		bpl $019035			bpl 		_ITSNotMinus
.01902d	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.01902f	20 ca 90	jsr $0190ca			jsr 		ITSOutputCharacter
.019032	20 01 90	jsr $019001			jsr 		IntegerNegateAlways 	; negate the number.
.019035					_ITSNotMinus:
.019035	a9 00		lda #$00			lda 		#0
.019037	8d 24 04	sta $0424			sta 		NumSuppress 			; clear the suppression flag.
.01903a	8a		txa				txa 								; use Y for the mantissa index.
.01903b	a8		tay				tay
.01903c	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.01903e					_ITSNextSubtractor:
.01903e	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.019040	8d 25 04	sta $0425			sta 		NumConvCount
.019043					_ITSSubtract:
.019043	38		sec				sec
.019044	b9 08 03	lda $0308,y			lda 		XS_Mantissa,y 			; subtract number and push on stack
.019047	ff a6 90 01	sbc $0190a6,x			sbc 		_ITSSubtractors+0,x
.01904b	48		pha				pha
.01904c	b9 09 03	lda $0309,y			lda 		XS_Mantissa+1,y
.01904f	ff a7 90 01	sbc $0190a7,x			sbc 		_ITSSubtractors+1,x
.019053	48		pha				pha
.019054	b9 0a 03	lda $030a,y			lda 		XS_Mantissa+2,y
.019057	ff a8 90 01	sbc $0190a8,x			sbc 		_ITSSubtractors+2,x
.01905b	48		pha				pha
.01905c	b9 0b 03	lda $030b,y			lda 		XS_Mantissa+3,y
.01905f	ff a9 90 01	sbc $0190a9,x			sbc 		_ITSSubtractors+3,x
.019063	90 14		bcc $019079			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.019065	99 0b 03	sta $030b,y			sta 		XS_Mantissa+3,y 		; save subtract off stack
.019068	68		pla				pla
.019069	99 0a 03	sta $030a,y			sta 		XS_Mantissa+2,y
.01906c	68		pla				pla
.01906d	99 09 03	sta $0309,y			sta 		XS_Mantissa+1,y
.019070	68		pla				pla
.019071	99 08 03	sta $0308,y			sta 		XS_Mantissa+0,y
.019074	ee 25 04	inc $0425			inc 		NumConvCount 			; bump count.
.019077	80 ca		bra $019043			bra 		_ITSSubtract 			; go round again.
.019079					_ITSCantSubtract:
.019079	68		pla				pla 								; throw away interim answers
.01907a	68		pla				pla
.01907b	68		pla				pla
.01907c	ad 25 04	lda $0425			lda 		NumConvCount 			; if not zero then no suppression check
.01907f	c9 30		cmp #$30			cmp 		#"0"
.019081	d0 05		bne $019088			bne 		_ITSOutputDigit
.019083	ad 24 04	lda $0424			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.019086	10 09		bpl $019091			bpl	 		_ITSGoNextSubtractor
.019088					_ITSOutputDigit:
.019088	ce 24 04	dec $0424			dec 		NumSuppress 			; suppression check will be non-zero.
.01908b	ad 25 04	lda $0425			lda 		NumConvCount 			; count of subtractions
.01908e	20 ca 90	jsr $0190ca			jsr 		ITSOutputCharacter 		; output it.
.019091					_ITSGoNextSubtractor:
.019091	e8		inx				inx 								; next dword
.019092	e8		inx				inx
.019093	e8		inx				inx
.019094	e8		inx				inx
.019095	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.019097	d0 a5		bne $01903e			bne 		_ITSNextSubtractor 		; do all the subtractors.
.019099	98		tya				tya 								; X is back as the mantissa index
.01909a	aa		tax				tax
.01909b	bd 08 03	lda $0308,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.01909e	09 30		ora #$30			ora 		#"0"
.0190a0	20 ca 90	jsr $0190ca			jsr 		ITSOutputCharacter
.0190a3	7a		ply				ply 								; and exit
.0190a4	68		pla				pla
.0190a5	60		rts				rts
.0190a6					_ITSSubtractors:
>0190a6	00 ca 9a 3b					.dword 		1000000000
>0190aa	00 e1 f5 05					.dword 		100000000
>0190ae	80 96 98 00					.dword 		10000000
>0190b2	40 42 0f 00					.dword 		1000000
>0190b6	a0 86 01 00					.dword 		100000
>0190ba	10 27 00 00					.dword 		10000
>0190be	e8 03 00 00					.dword 		1000
>0190c2	64 00 00 00					.dword 		100
>0190c6	0a 00 00 00					.dword 		10
.0190ca					_ITSSubtractorsEnd:
.0190ca					ITSOutputCharacter:
.0190ca	48		pha				pha
.0190cb	da		phx				phx
.0190cc	ae 00 04	ldx $0400			ldx 	NumBufX 					; save digit
.0190cf	9d 01 04	sta $0401,x			sta 	Num_Buffer,x
.0190d2	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.0190d4	9d 02 04	sta $0402,x			sta 	Num_Buffer+1,x
.0190d7	ee 00 04	inc $0400			inc 	NumBufX						; bump pointer.
.0190da	fa		plx				plx
.0190db	68		pla				pla
.0190dc	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.0190dd					IntFromString:
.0190dd	a0 00		ldy #$00			ldy 	#0
.0190df	8c 26 04	sty $0426			sty 	ExpTemp 					; this is the converted digit count.
.0190e2					IntFromStringY:
.0190e2	48		pha				pha
.0190e3	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.0190e5	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.0190e8	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0190eb	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0190ee	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0190f1	a9 01		lda #$01			lda 	#1
.0190f3	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0190f6					_IFSLoop:
.0190f6	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.0190f8	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.0190fa	90 60		bcc $01915c			bcc 	_IFSExit
.0190fc	c9 3a		cmp #$3a			cmp 	#"9"+1
.0190fe	b0 5c		bcs $01915c			bcs 	_IFSExit
.019100	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.019103	c9 0c		cmp #$0c			cmp 	#12
.019105	b0 5f		bcs $019166			bcs 	_IFSOverflow
.019107	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.01910a	48		pha				pha
.01910b	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.01910e	48		pha				pha
.01910f	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.019112	48		pha				pha
.019113	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.019116	48		pha				pha
.019117	20 7b 91	jsr $01917b			jsr 	IFSX1ShiftLeft 				; double
.01911a	20 7b 91	jsr $01917b			jsr 	IFSX1ShiftLeft 				; x 4
.01911d	18		clc				clc 								; add saved value x 5
.01911e	68		pla				pla
.01911f	7d 08 03	adc $0308,x			adc 	XS_Mantissa+0,x
.019122	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019125	68		pla				pla
.019126	7d 09 03	adc $0309,x			adc 	XS_Mantissa+1,x
.019129	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.01912c	68		pla				pla
.01912d	7d 0a 03	adc $030a,x			adc 	XS_Mantissa+2,x
.019130	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019133	68		pla				pla
.019134	7d 0b 03	adc $030b,x			adc 	XS_Mantissa+3,x
.019137	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.01913a	20 7b 91	jsr $01917b			jsr 	IFSX1ShiftLeft 				; x 10
.01913d	ee 26 04	inc $0426			inc 	ExpTemp 					; bump count of digits processed.
.019140	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.019142	29 0f		and #$0f			and 	#15
.019144	c8		iny				iny
.019145	7d 08 03	adc $0308,x			adc 	XS_Mantissa+0,x
.019148	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.01914b	90 a9		bcc $0190f6			bcc 	_IFSLoop
.01914d	fe 09 03	inc $0309,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.019150	d0 a4		bne $0190f6			bne 	_IFSLoop
.019152	fe 0a 03	inc $030a,x			inc 	XS_Mantissa+2,x
.019155	d0 9f		bne $0190f6			bne 	_IFSLoop
.019157	fe 0b 03	inc $030b,x			inc 	XS_Mantissa+3,x
.01915a	80 9a		bra $0190f6			bra 	_IFSLoop
.01915c					_IFSExit:
.01915c	98		tya				tya 								; get offset
.01915d					_IFSOkay:
.01915d	38		sec				sec
.01915e	ad 26 04	lda $0426			lda 	ExpTemp
.019161	f0 01		beq $019164			beq 	_IFSSkipFail
.019163	18		clc				clc
.019164					_IFSSkipFail:
.019164	68		pla				pla 								; and exit.
.019165	60		rts				rts
.019166					_IFSOverflow:
.019166	20 26 82	jsr $018226			jsr 	ERR_Handler
>019169	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>019171	20 6f 76 65 72 66 6c 6f 77 00
.01917b					IFSX1ShiftLeft:
.01917b	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x
.01917e	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.019181	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.019184	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.019187	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.019188					FPSubtract:
.019188	48		pha				pha
.019189	bd 13 03	lda $0313,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.01918c	49 80		eor #$80			eor 	#$80
.01918e	9d 13 03	sta $0313,x			sta 	XS2_Type,x
.019191	68		pla				pla 								; --- and fall through ---
.019192					FPAdd:
.019192	48		pha				pha
.019193	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.019196	d0 05		bne $01919d			bne 	_FPA_NegativeLHS
.019198	20 ba 91	jsr $0191ba			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.01919b	68		pla				pla
.01919c	60		rts				rts
.01919d					_FPA_NegativeLHS:
.01919d	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.0191a0	49 80		eor #$80			eor 	#$80
.0191a2	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0191a5	bd 13 03	lda $0313,x			lda 	XS2_Type,x 					; flip the sign of B and add
.0191a8	49 80		eor #$80			eor 	#$80
.0191aa	9d 13 03	sta $0313,x			sta 	XS2_Type,x
.0191ad	20 ba 91	jsr $0191ba			jsr 	FPAdd_Worker 				; do the add calculation.
.0191b0	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip sign of X1 back
.0191b3	49 80		eor #$80			eor 	#$80
.0191b5	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0191b8	68		pla				pla
.0191b9	60		rts				rts
.0191ba					FPAdd_Worker:
.0191ba	3c 13 03	bit $0313,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.0191bd	70 08		bvs $0191c7			bvs 	_FPAWExit 					; no change.
.0191bf	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.0191c2	50 07		bvc $0191cb			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.0191c4	20 5f 94	jsr $01945f			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.0191c7					_FPAWExit:
.0191c7	20 e7 94	jsr $0194e7			jsr 	FPUNormalise 				; normalise the result.
.0191ca	60		rts				rts
.0191cb					_FPAWMakeSame:
.0191cb	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.0191ce	38		sec				sec
.0191cf	fd 12 03	sbc $0312,x			sbc	 	XS2_Exponent,x 				; using subtraction
.0191d2	f0 1b		beq $0191ef			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.0191d4	da		phx				phx 								; save X
.0191d5	90 06		bcc $0191dd			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.0191d7	e8		inx				inx
.0191d8	e8		inx				inx
.0191d9	e8		inx				inx
.0191da	e8		inx				inx
.0191db	e8		inx				inx
.0191dc	e8		inx				inx
.0191dd					_FPAWShiftA:
.0191dd	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x 				; so shift exponent up.
.0191e0	5e 0b 03	lsr $030b,x			lsr 	3+XS_Mantissa,x
.0191e3	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.0191e6	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.0191e9	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.0191ec	fa		plx				plx 								; restore original X
.0191ed	80 dc		bra $0191cb			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.0191ef					_FPAW_DoArithmetic:
.0191ef	3c 13 03	bit $0313,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.0191f2	30 39		bmi $01922d			bmi 	_FPAW_BNegative
.0191f4	18		clc				clc
.0191f5	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.0191f8	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.0191fb	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0191fe	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.019201	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.019204	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019207	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.01920a	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.01920d	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019210	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.019213	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.019216	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019219	90 ac		bcc $0191c7			bcc 	_FPAWExit 					; no carry.
.01921b	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x 				; so shift exponent up.
.01921e	38		sec				sec
.01921f	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.019222	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.019225	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.019228	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.01922b	80 9a		bra $0191c7			bra 	_FPAWExit
.01922d					_FPAW_BNegative:
.01922d	38		sec				sec
.01922e	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.019231	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.019234	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019237	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.01923a	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.01923d	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019240	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.019243	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.019246	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019249	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.01924c	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.01924f	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019252	b0 0b		bcs $01925f			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.019254	20 8c 94	jsr $01948c			jsr 	FPUNegateInteger			; negate the mantissa
.019257	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip result sign
.01925a	49 80		eor #$80			eor 	#$80
.01925c	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.01925f					_FPAWGoExit:
.01925f	4c c7 91	jmp $0191c7			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.019262					FPD_IsDivZero:
.019262	20 26 82	jsr $018226			jsr ERR_Handler
>019265	44 69 76 69 73 69 6f 6e			.text "Division by zero",0
>01926d	20 62 79 20 7a 65 72 6f 00
.019276					FPDivide:
.019276	48		pha				pha
.019277	5a		phy				phy
.019278	3c 13 03	bit $0313,x			bit 	XS2_Type,x 					; check if division by zero
.01927b	70 e5		bvs $019262			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.01927d	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.019280	f0 03		beq $019285			beq 	_FPDCalculateExp
.019282					_FPD_Exit:
.019282	7a		ply				ply
.019283	68		pla				pla
.019284	60		rts				rts
.019285					_FPDCalculateExp:
.019285	bd 12 03	lda $0312,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.019288	49 ff		eor #$ff			eor 	#$FF
.01928a	1a		inc a				inc 	a
.01928b	9d 12 03	sta $0312,x			sta 	XS2_Exponent,x
.01928e	20 82 93	jsr $019382			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.019291	18		clc				clc 	 							; add 1 to the resulting exponent
.019292	69 01		adc #$01			adc 	#1
.019294	b0 65		bcs $0192fb			bcs 	_FPD_Overflow 				; which can overflow.
.019296	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.019299	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.01929b	85 1a		sta $1a				sta 	zLTemp1+0
.01929d	85 1b		sta $1b				sta 	zLTemp1+1
.01929f	85 1c		sta $1c				sta 	zLTemp1+2
.0192a1	85 1d		sta $1d				sta 	zLTemp1+3
.0192a3	a0 20		ldy #$20			ldy 	#32 						; times round.
.0192a5					_FPD_Loop:
.0192a5	38		sec				sec 								; calculate X1-X2 stacking result because we might
.0192a6	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; not save it.
.0192a9	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa,x
.0192ac	48		pha				pha
.0192ad	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0192b0	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.0192b3	48		pha				pha
.0192b4	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.0192b7	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.0192ba	48		pha				pha
.0192bb	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.0192be	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.0192c1	90 17		bcc $0192da			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.0192c3	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x 			; save results out to A
.0192c6	68		pla				pla
.0192c7	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0192ca	68		pla				pla
.0192cb	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0192ce	68		pla				pla
.0192cf	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0192d2	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.0192d4	09 80		ora #$80			ora 	#$80
.0192d6	85 1d		sta $1d				sta 	zLTemp1+3
.0192d8	80 03		bra $0192dd			bra 	_FPD_Rotates
.0192da					_FPD_NoSubtract:
.0192da	68		pla				pla 								; throw away unwanted results
.0192db	68		pla				pla
.0192dc	68		pla				pla
.0192dd					_FPD_Rotates:
.0192dd	5e 11 03	lsr $0311,x			lsr 	3+XS2_Mantissa,x
.0192e0	7e 10 03	ror $0310,x			ror 	2+XS2_Mantissa,x
.0192e3	7e 0f 03	ror $030f,x			ror 	1+XS2_Mantissa,x
.0192e6	7e 0e 03	ror $030e,x			ror 	0+XS2_Mantissa,x
.0192e9	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.0192eb	26 1b		rol $1b				rol 	zLTemp1+1
.0192ed	26 1c		rol $1c				rol 	zLTemp1+2
.0192ef	26 1d		rol $1d				rol 	zLTemp1+3
.0192f1	90 02		bcc $0192f5			bcc 	_FPD_NoCarry
.0192f3	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.0192f5					_FPD_NoCarry:
.0192f5	88		dey				dey 								; do 32 times
.0192f6	d0 ad		bne $0192a5			bne 	_FPD_Loop
.0192f8	4c 5f 93	jmp $01935f			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.0192fb					_FPD_Overflow:
.0192fb	4c 5c 95	jmp $01955c			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.0192fe					FPMultiply:
.0192fe	48		pha				pha
.0192ff	5a		phy				phy
.019300	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.019303	70 08		bvs $01930d			bvs 	_FPM_Exit
.019305	3c 13 03	bit $0313,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.019308	50 06		bvc $019310			bvc 	_FPM_CalcExponent
.01930a	20 5f 94	jsr $01945f			jsr 	FPUCopyX2ToX1
.01930d					_FPM_Exit:
.01930d	7a		ply				ply
.01930e	68		pla				pla
.01930f	60		rts				rts
.019310					_FPM_CalcExponent:
.019310	18		clc				clc
.019311	20 82 93	jsr $019382			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.019314	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x 				; save the result.
.019317	a9 00		lda #$00			lda 	#0
.019319	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.01931b	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.01931d	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.01931f	85 1d		sta $1d				sta 	zLTemp1+3
.019321	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.019323					_FPM_Loop:
.019323	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x				; check LSB of long product
.019326	29 01		and #$01			and 	#1
.019328	18		clc				clc 								; clear carry for the long rotate.
.019329	f0 1d		beq $019348			beq 	_FPM_NoAddition
.01932b	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.01932c	a5 1a		lda $1a				lda 	zLTemp1+0
.01932e	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.019331	85 1a		sta $1a				sta 	zLTemp1+0
.019333	a5 1b		lda $1b				lda 	zLTemp1+1
.019335	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.019338	85 1b		sta $1b				sta 	zLTemp1+1
.01933a	a5 1c		lda $1c				lda 	zLTemp1+2
.01933c	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.01933f	85 1c		sta $1c				sta 	zLTemp1+2
.019341	a5 1d		lda $1d				lda 	zLTemp1+3
.019343	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.019346	85 1d		sta $1d				sta 	zLTemp1+3
.019348					_FPM_NoAddition:
.019348	66 1d		ror $1d				ror 	3+zLTemp1
.01934a	66 1c		ror $1c				ror 	2+zLTemp1
.01934c	66 1b		ror $1b				ror 	1+zLTemp1
.01934e	66 1a		ror $1a				ror 	0+zLTemp1
.019350	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.019353	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.019356	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.019359	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.01935c	88		dey				dey
.01935d	d0 c4		bne $019323			bne 	_FPM_Loop 					; do this 32 times.
.01935f					FPM_CopySignNormalize:
.01935f	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.019361	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.019364	a5 1b		lda $1b				lda 	zLTemp1+1
.019366	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019369	a5 1c		lda $1c				lda 	zLTemp1+2
.01936b	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01936e	a5 1d		lda $1d				lda 	zLTemp1+3
.019370	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019373	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; sign is xor of signs
.019376	5d 13 03	eor $0313,x			eor 	XS2_Type,x
.019379	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.01937c	20 e7 94	jsr $0194e7			jsr 	FPUNormalise 				; normalise and exit.
.01937f	7a		ply				ply
.019380	68		pla				pla
.019381	60		rts				rts
.019382					FPCalculateExponent:
.019382	18		clc				clc
.019383	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.019386	7d 12 03	adc $0312,x			adc 	XS2_Exponent,x
.019389	b0 08		bcs $019393			bcs 	_FPCECarry 					; carry out ?
.01938b	10 03		bpl $019390			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.01938d	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.01938f	60		rts				rts
.019390					_FPCEExpZero:
.019390	a9 00		lda #$00			lda 	#0
.019392	60		rts				rts
.019393					_FPCECarry:
.019393	30 03		bmi $019398			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.019395	09 80		ora #$80			ora 	#$80 						; put in right range
.019397	60		rts				rts
.019398					_FPCEOverflow:
.019398	4c 5c 95	jmp $01955c			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.01939b					FPFractionalPart:
.01939b	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.01939e	38		sec				sec 								; this flag tells us to keep the fractional part
.01939f	30 0f		bmi $0193b0			bmi 	FPGetPart
.0193a1	60		rts				rts
.0193a2					FPIntegerPart:
.0193a2	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.0193a5	18		clc				clc 								; this flag says keep the integer part.
.0193a6	30 08		bmi $0193b0			bmi 	FPGetPart 					; -ve exponents are 0..127
.0193a8	48		pha				pha
.0193a9	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.0193ab	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0193ae	68		pla				pla
.0193af	60		rts				rts
.0193b0					FPGetPart:
.0193b0	48		pha				pha
.0193b1	5a		phy				phy 								; save Y
.0193b2	08		php				php 								; save action
.0193b3	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.0193b6	70 62		bvs $01941a			bvs 	_FPGP_Exit 					; then do nothing.
.0193b8	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.0193ba	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.0193bc	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.0193be	85 1c		sta $1c				sta 	zLTemp1+2
.0193c0	85 1d		sta $1d				sta 	zLTemp1+3
.0193c2	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x				; the number of shifts.
.0193c5	38		sec				sec
.0193c6	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.0193c8	f0 12		beq $0193dc			beq 	_FPGP_NoShift 				; ... if any
.0193ca	c9 20		cmp #$20			cmp 	#32
.0193cc	90 02		bcc $0193d0			bcc 	_FPGP_NotMax
.0193ce	a9 20		lda #$20			lda 	#32 						; max of 32.
.0193d0					_FPGP_NotMax:
.0193d0	a8		tay				tay 								; Y is the mask shift count.
.0193d1					_FPGP_ShiftMask:
.0193d1	46 1d		lsr $1d				lsr 	3+zLTemp1
.0193d3	66 1c		ror $1c				ror 	2+zLTemp1
.0193d5	66 1b		ror $1b				ror 	1+zLTemp1
.0193d7	66 1a		ror $1a				ror 	0+zLTemp1
.0193d9	88		dey				dey
.0193da	d0 f5		bne $0193d1			bne 	_FPGP_ShiftMask
.0193dc					_FPGP_NoShift:
.0193dc	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.0193de	8e 26 04	stx $0426			stx 	ExpTemp						; save X
.0193e1					_FPGP_MaskLoop:
.0193e1	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.0193e4	28		plp				plp 								; if CC we keep the top part, so we
.0193e5	08		php				php		 							; flip the mask.
.0193e6	b0 02		bcs $0193ea			bcs		_FPGP_NoFlip
.0193e8	49 ff		eor #$ff			eor 	#$FF
.0193ea					_FPGP_NoFlip:
.0193ea	3d 08 03	and $0308,x			and 	XS_Mantissa,x 				; and into the mantissa.
.0193ed	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.0193f0	e8		inx				inx
.0193f1	c8		iny				iny
.0193f2	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.0193f4	d0 eb		bne $0193e1			bne 	_FPGP_MaskLoop
.0193f6	ae 26 04	ldx $0426			ldx 	ExpTemp						; restore X
.0193f9	28		plp				plp
.0193fa	08		php				php 								; get action flag on the stack
.0193fb	90 05		bcc $019402			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.0193fd	a9 00		lda #$00			lda 	#0
.0193ff	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019402					_FPGP_NotFractional:
.019402	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 						; check if \1 zero
.019405	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.019408	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.01940b	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.01940e	f0 05		beq $019415			beq 	_FPGP_Zero 					; if zero, return zero
.019410	20 e7 94	jsr $0194e7			jsr 	FPUNormalise
.019413	80 05		bra $01941a			bra 	_FPGP_Exit 					; and exit
.019415					_FPGP_Zero:
.019415	a9 40		lda #$40			lda 	#$40 						; set zero flag
.019417	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.01941a					_FPGP_Exit:
.01941a	68		pla				pla 								; throw saved action flag.
.01941b	7a		ply				ply
.01941c	68		pla				pla
.01941d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.01941e					FPCompare:
.01941e	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.019421	48		pha				pha
.019422	bd 12 03	lda $0312,x			lda 	XS2_Exponent,x
.019425	48		pha				pha
.019426	20 88 91	jsr $019188			jsr 	FPSubtract 					; calculate X1-X2
.019429	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.01942c	70 2c		bvs $01945a			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.01942e	68		pla				pla
.01942f	8d 26 04	sta $0426			sta 	ExpTemp						; save first exponent in temporary reg.
.019432	68		pla				pla
.019433	38		sec				sec
.019434	ed 26 04	sbc $0426			sbc 	ExpTemp 					; calculate AX-BX
.019437	70 15		bvs $01944e			bvs 	_FPCNotEqual				; overflow, can't be equal.
.019439	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.01943a	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.01943c	b0 10		bcs $01944e			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.01943e	38		sec				sec
.01943f	ad 26 04	lda $0426			lda 	ExpTemp 					; get one of the exponents back.
.019442	e9 12		sbc #$12			sbc 	#18 						; allow for 2^18 error, relatively.
.019444	b0 02		bcs $019448			bcs 	_FPCNotRange 				; keep in range.
.019446	a9 01		lda #$01			lda 	#1
.019448					_FPCNotRange:
.019448	38		sec				sec
.019449	fd 0c 03	sbc $030c,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.01944c	b0 0e		bcs $01945c			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.01944e					_FPCNotEqual:
.01944e	bd 0d 03	lda $030d,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.019451	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.019453	f0 02		beq $019457			beq 	_FPCNE2
.019455	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.019457	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.019458	80 04		bra $01945e			bra 	_FPCExit
.01945a					_FPCPullZero:
.01945a	68		pla				pla 								; throw saved exponents
.01945b	68		pla				pla
.01945c					_FPCZero:
.01945c	a9 00		lda #$00			lda 	#0 							; and return zero
.01945e					_FPCExit:
.01945e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.01945f					FPUCopyX2ToX1:
.01945f	48		pha				pha
.019460	da		phx				phx
.019461	5a		phy				phy
.019462	a0 08		ldy #$08			ldy 	#8
.019464	bd 0e 03	lda $030e,x	_FPUC21:lda 	XS2_Mantissa,x
.019467	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.01946a	e8		inx				inx
.01946b	88		dey				dey
.01946c	10 f6		bpl $019464			bpl 	_FPUC21
.01946e	7a		ply				ply
.01946f	fa		plx				plx
.019470	68		pla				pla
.019471	60		rts				rts
.019472					FPUSetInteger:
.019472	48		pha				pha
.019473	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.019476	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.019478	10 02		bpl $01947c			bpl 	_FPUSIExtend
.01947a	a9 ff		lda #$ff			lda 	#$FF
.01947c					_FPUSIExtend:
.01947c	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.01947f	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019482	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019485	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.019487	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.01948a	68		pla				pla
.01948b	60		rts				rts
.01948c					FPUNegateInteger:
.01948c	48		pha				pha
.01948d	38		sec				sec
.01948e	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.019490	fd 08 03	sbc $0308,x			sbc 	XS_Mantissa+0,x
.019493	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019496	a9 00		lda #$00			lda 	#0
.019498	fd 09 03	sbc $0309,x			sbc 	XS_Mantissa+1,x
.01949b	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.01949e	a9 00		lda #$00			lda 	#0
.0194a0	fd 0a 03	sbc $030a,x			sbc 	XS_Mantissa+2,x
.0194a3	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0194a6	a9 00		lda #$00			lda 	#0
.0194a8	fd 0b 03	sbc $030b,x			sbc 	XS_Mantissa+3,x
.0194ab	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0194ae	68		pla				pla
.0194af	60		rts				rts
.0194b0					FPUToFloat:
.0194b0	48		pha				pha
.0194b1	bd 0d 03	lda $030d,x			lda 	XS_Type,x					; exit if already float.
.0194b4	29 0f		and #$0f			and 	#$0F
.0194b6	f0 2d		beq $0194e5			beq 	_FPUFExit
.0194b8	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.0194ba	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0194bd	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.0194bf	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x 				; x mantissa.
.0194c2	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.0194c5	10 08		bpl $0194cf			bpl		_FPUFPositive
.0194c7	20 8c 94	jsr $01948c			jsr 	FPUNegateInteger 			; negate the mantissa
.0194ca	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.0194cc	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0194cf					_FPUFPositive:
.0194cf	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.0194d2	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.0194d5	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.0194d8	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.0194db	d0 05		bne $0194e2			bne 	_FPUFNonZero
.0194dd	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.0194df	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0194e2					_FPUFNonZero:
.0194e2	20 e7 94	jsr $0194e7			jsr 	FPUNormalise 				; normalise the floating point.
.0194e5					_FPUFExit:
.0194e5	68		pla				pla
.0194e6	60		rts				rts
.0194e7					FPUNormalise:
.0194e7	48		pha				pha
.0194e8	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.0194eb	70 20		bvs $01950d			bvs 	_FPUNExit
.0194ed	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.0194f0	f0 16		beq $019508			beq 	_FPUNSetZero
.0194f2					_FPUNLoop:
.0194f2	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.0194f5	30 16		bmi $01950d			bmi 	_FPUNExit 					; if so, we are normalised.
.0194f7	1e 08 03	asl $0308,x			asl 	0+XS_Mantissa+0,x
.0194fa	3e 09 03	rol $0309,x			rol 	1+XS_Mantissa+0,x
.0194fd	3e 0a 03	rol $030a,x			rol 	2+XS_Mantissa+0,x
.019500	3e 0b 03	rol $030b,x			rol 	3+XS_Mantissa+0,x
.019503	de 0c 03	dec $030c,x			dec 	XS_Exponent,x 				; decrement exponent
.019506	d0 ea		bne $0194f2			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.019508					_FPUNSetZero:
.019508	a9 40		lda #$40			lda 	#$40
.01950a	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; the result is now zero.
.01950d					_FPUNExit:
.01950d	68		pla				pla
.01950e	60		rts				rts
.01950f					FPUToInteger:
.01950f	48		pha				pha
.019510	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; if already integer, exit
.019513	29 01		and #$01			and 	#1
.019515	d0 3e		bne $019555			bne 	_FPUTOI_Exit
.019517	3c 0d 03	bit $030d,x			bit 	XS_Type,x					; if zero, return zero.
.01951a	70 2b		bvs $019547			bvs 	_FPUTOI_Zero
.01951c	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.01951f	10 26		bpl $019547			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.019521	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.019523	b0 37		bcs $01955c			bcs 	FP_Overflow
.019525					_FPUToIToInteger:
.019525	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.019528	c9 a0		cmp #$a0			cmp 	#128+32
.01952a	f0 11		beq $01953d			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.01952c	fe 0c 03	inc $030c,x			inc 	XS_Exponent,X 				; increment Exponent
.01952f	5e 0b 03	lsr $030b,x			lsr 	3+XS_Mantissa,x
.019532	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.019535	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.019538	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.01953b	80 e8		bra $019525			bra 	_FPUToIToInteger 			; keep going.
.01953d					_FPUToICheckSign:
.01953d	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; check sign
.019540	10 13		bpl $019555			bpl 	_FPUToI_Exit 				; exit if unsigned.
.019542	20 8c 94	jsr $01948c			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.019545	80 0e		bra $019555			bra 	_FPUTOI_Exit
.019547					_FPUTOI_Zero:
.019547	a9 00		lda #$00			lda 	#0 							; return zero integer.
.019549	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.01954c	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.01954f	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019552	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019555					_FPUToI_Exit:
.019555	a9 01		lda #$01			lda 	#1 							; set type to integer
.019557	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.01955a	68		pla				pla
.01955b	60		rts				rts
.01955c					FP_Overflow:
.01955c	20 26 82	jsr $018226			jsr ERR_Handler
>01955f	46 6c 6f 61 74 69 6e 67			.text "Floating Point overflow",0
>019567	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.019577					FPUTimes10:
.019577	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.01957a	85 1a		sta $1a				sta 	ZLTemp1+0
.01957c	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.01957f	85 1b		sta $1b				sta 	ZLTemp1+1
.019581	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.019584	85 1c		sta $1c				sta 	ZLTemp1+2
.019586	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.019589	85 1d		sta $1d				sta 	ZLTemp1+3
.01958b	20 cf 95	jsr $0195cf			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.01958e	20 cf 95	jsr $0195cf			jsr 	_FPUT_LSR_ZLTemp1
.019591	18		clc				clc
.019592	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.019595	65 1a		adc $1a				adc 	ZLTemp1+0
.019597	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.01959a	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.01959d	65 1b		adc $1b				adc 	ZLTemp1+1
.01959f	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0195a2	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.0195a5	65 1c		adc $1c				adc 	ZLTemp1+2
.0195a7	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0195aa	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.0195ad	65 1d		adc $1d				adc 	ZLTemp1+3
.0195af	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0195b2	90 0f		bcc $0195c3			bcc 	_FPUTimes10
.0195b4	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.0195b7	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.0195ba	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.0195bd	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.0195c0	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x				; fix exponent
.0195c3					_FPUTimes10:
.0195c3	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.0195c6	18		clc				clc
.0195c7	69 03		adc #$03			adc 	#3
.0195c9	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.0195cc	b0 8e		bcs $01955c			bcs 	FP_Overflow 				; error
.0195ce	60		rts				rts
.0195cf					_FPUT_LSR_ZLTemp1:
.0195cf	46 1d		lsr $1d				lsr 	ZLTemp1+3
.0195d1	66 1c		ror $1c				ror 	ZLTemp1+2
.0195d3	66 1b		ror $1b				ror 	ZLTemp1+1
.0195d5	66 1a		ror $1a				ror 	ZLTemp1+0
.0195d7	60		rts				rts
.0195d8					FPUScale10A:
.0195d8	5a		phy				phy
.0195d9	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.0195db	f0 3d		beq $01961a			beq 	_FPUScaleExit
.0195dd	da		phx				phx 								; save X
.0195de	e8		inx				inx
.0195df	e8		inx				inx
.0195e0	e8		inx				inx
.0195e1	e8		inx				inx
.0195e2	e8		inx				inx
.0195e3	e8		inx				inx
.0195e4	a8		tay				tay 								; save power scalar in Y.
.0195e5	a9 00		lda #$00			lda 	#0
.0195e7	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.0195ea	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0195ed	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0195f0	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0195f3	a9 80		lda #$80			lda 	#$80
.0195f5	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0195f8	a9 81		lda #$81			lda 	#$81
.0195fa	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.0195fd	5a		phy				phy 								; save 10^n on stack.
.0195fe	c0 00		cpy #$00			cpy 	#0
.019600	10 05		bpl $019607			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.019602	98		tya				tya
.019603	49 ff		eor #$ff			eor 	#$FF
.019605	1a		inc a				inc 	a
.019606	a8		tay				tay
.019607					_FPUSAbs:
.019607	20 77 95	jsr $019577			jsr 	FPUTimes10
.01960a	88		dey				dey
.01960b	d0 fa		bne $019607			bne 	_FPUSAbs 					; tos is now 10^|AC|
.01960d	68		pla				pla 								; restore count in A
.01960e	fa		plx				plx 								; restore X pointing to number to scale.
.01960f	0a		asl a				asl 	a
.019610	b0 05		bcs $019617			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.019612	20 fe 92	jsr $0192fe			jsr 	FPMultiply 					; if clear multiply.
.019615	80 03		bra $01961a			bra		_FPUScaleExit
.019617					_FPUSDivide:
.019617	20 76 92	jsr $019276			jsr 	FPDivide
.01961a					_FPUScaleExit:
.01961a	7a		ply				ply
.01961b	60		rts				rts
.01961c					FPUCopyToNext:
.01961c	a0 06		ldy #$06			ldy 		#6
.01961e	da		phx				phx
.01961f					_FPUCopy1:
.01961f	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x
.019622	9d 0e 03	sta $030e,x			sta 	XS2_Mantissa,x
.019625	e8		inx				inx
.019626	88		dey				dey
.019627	d0 f6		bne $01961f			bne 	_FPUCopy1
.019629	fa		plx				plx
.01962a	60		rts				rts
.01962b					FPUCopyFromNext:
.01962b	a0 06		ldy #$06			ldy 		#6
.01962d	da		phx				phx
.01962e					_FPUCopy1:
.01962e	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa,x
.019631	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.019634	e8		inx				inx
.019635	88		dey				dey
.019636	d0 f6		bne $01962e			bne 	_FPUCopy1
.019638	fa		plx				plx
.019639	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.01963a					FPToString:
.01963a	48		pha				pha
.01963b	5a		phy				phy
.01963c	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; check zero flag
.01963f	50 0a		bvc $01964b			bvc 		_FPTSIsFloat 			; if zero,
.019641					_FPTSZero:
.019641	a9 30		lda #$30			lda 		#"0"
.019643	20 ca 90	jsr $0190ca			jsr 		ITSOutputCharacter
.019646					_FPTSExit:
.019646	7a		ply				ply
.019647	68		pla				pla
.019648	60		rts				rts
.019649	80 fb		bra $019646			bra 		_FPTSExit
.01964b					_FPTSIsFloat:
.01964b	bd 0d 03	lda $030d,x			lda 		XS_Type,x 				; is it signed ?
.01964e	10 0a		bpl $01965a			bpl 		_FPTSNotSigned
.019650	a9 00		lda #$00			lda 		#0 						; clear sign flag
.019652	9d 0d 03	sta $030d,x			sta 		XS_Type,x
.019655	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.019657	20 ca 90	jsr $0190ca			jsr 		ITSOutputCharacter
.01965a					_FPTSNotSigned:
.01965a	bd 0c 03	lda $030c,x			lda 		XS_Exponent,x
.01965d	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.01965f	b0 09		bcs $01966a			bcs 		_FPTSExponent
.019661	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.019663	90 05		bcc $01966a			bcc 		_FPTSExponent 			;
.019665					_FPTSStandard:
.019665	20 ae 96	jsr $0196ae			jsr 		FPTOutputBody 			; output the body.
.019668	80 dc		bra $019646			bra 		_FPTSExit
.01966a					_FPTSExponent:
.01966a	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.01966c	8d 27 04	sta $0427			sta 		ExpCount
.01966f					_FPTSExponentLoop:
.01966f	bd 0c 03	lda $030c,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.019672	10 0e		bpl $019682			bpl 		_FPTSTimes
.019674	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.019676	90 14		bcc $01968c			bcc 		_FPTSScaledToExp
.019678	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.01967a	20 d8 95	jsr $0195d8			jsr 		FPUScale10A
.01967d	ee 27 04	inc $0427			inc 		ExpCount
.019680	80 ed		bra $01966f			bra 		_FPTSExponentLoop
.019682					_FPTSTimes:
.019682	a9 01		lda #$01			lda 		#1
.019684	20 d8 95	jsr $0195d8			jsr 		FPUScale10A
.019687	ce 27 04	dec $0427			dec 		ExpCount
.01968a	80 e3		bra $01966f			bra 		_FPTSExponentLoop
.01968c					_FPTSScaledToExp:
.01968c	20 ae 96	jsr $0196ae			jsr 		FPTOutputBody 			; output the body.
.01968f	a9 65		lda #$65			lda 		#"e"					; output E
.019691	20 ca 90	jsr $0190ca			jsr 		ITSOutputCharacter
.019694	ad 27 04	lda $0427			lda 		ExpCount 				; get the exponent
.019697	9d 08 03	sta $0308,x			sta 		XS_Mantissa,x
.01969a	29 80		and #$80			and 		#$80 					; sign extend it
.01969c	f0 02		beq $0196a0			beq 		_FPTSSExt
.01969e	a9 ff		lda #$ff			lda 		#$FF
.0196a0					_FPTSSExt:
.0196a0	9d 09 03	sta $0309,x			sta 		XS_Mantissa+1,x
.0196a3	9d 0a 03	sta $030a,x			sta 		XS_Mantissa+2,x
.0196a6	9d 0b 03	sta $030b,x			sta 		XS_Mantissa+3,x
.0196a9	20 26 90	jsr $019026			jsr 		INTToString 			; output the exponent.
.0196ac	80 98		bra $019646			bra			_FPTSExit 				; and exit.
.0196ae					FPTOutputBody:
.0196ae	20 1c 96	jsr $01961c			jsr 		FPUCopyToNext 			; copy to next slot.
.0196b1	20 0f 95	jsr $01950f			jsr 		FPUToInteger 			; convert to an integer
.0196b4	20 26 90	jsr $019026			jsr 		INTToString 			; output the main integer part.
.0196b7	20 2b 96	jsr $01962b			jsr 		FPUCopyFromNext 		; get the fractional part back.
.0196ba	20 9b 93	jsr $01939b			jsr 		FPFractionalPart 		; get the decimal part.
.0196bd	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; any fractional part.
.0196c0	70 3e		bvs $019700			bvs 		_FPTOExit 				; if not, exit now.
.0196c2	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.0196c4	20 ca 90	jsr $0190ca			jsr 		ITSOutputCharacter
.0196c7					_FPOutLoop:
.0196c7	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; finally reached zero.
.0196ca	70 1e		bvs $0196ea			bvs 		_FPStripZeros 			; strip trailing zeros
.0196cc	20 77 95	jsr $019577			jsr 		FPUTimes10 				; multiply by 10
.0196cf	20 1c 96	jsr $01961c			jsr 		FPUCopyToNext			; copy to next slot.
.0196d2	20 0f 95	jsr $01950f			jsr 		FPUToInteger 			; convert to integer
.0196d5	bd 08 03	lda $0308,x			lda 		XS_Mantissa+0,x 		; print digit.
.0196d8	09 30		ora #$30			ora 		#"0"
.0196da	20 ca 90	jsr $0190ca			jsr 		ITSOutputCharacter
.0196dd	20 2b 96	jsr $01962b			jsr 		FPUCopyFromNext 		; get it back
.0196e0	20 9b 93	jsr $01939b			jsr 		FPFractionalPart 		; get fractional part
.0196e3	ad 00 04	lda $0400			lda 		NumBufX 				; done 11 characters yet ?
.0196e6	c9 0b		cmp #$0b			cmp 	 	#11
.0196e8	90 dd		bcc $0196c7			bcc 		_FPOutLoop 				; if so, keep going till zero.
.0196ea					_FPStripZeros:
.0196ea	ac 00 04	ldy $0400			ldy 		NumBufX 				; strip trailing zeros.
.0196ed					_FPStripLoop:
.0196ed	88		dey				dey 								; back one, if at start then no strip
.0196ee	f0 10		beq $019700			beq 		_FPToExit
.0196f0	b9 01 04	lda $0401,y			lda 		Num_Buffer,y 			; keep going if "0"
.0196f3	c9 30		cmp #$30			cmp 		#"0"
.0196f5	f0 f6		beq $0196ed			beq 		_FPStripLoop
.0196f7	c8		iny				iny
.0196f8	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.0196fa	99 01 04	sta $0401,y			sta 		Num_Buffer,y
.0196fd	8c 00 04	sty $0400			sty 		NumBufX 				; update position.
.019700					_FPTOExit:
.019700	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.019701					FPFromString:
.019701	48		pha				pha 								; push A
.019702	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.019704	c9 2e		cmp #$2e			cmp 	#"."
.019706	f0 03		beq $01970b			beq	 	_FPFIsDecimal
.019708	4c 6e 97	jmp $01976e			jmp 	_FPFNotDecimal
.01970b					_FPFIsDecimal:
.01970b	c8		iny				iny 								; consume the decimal.
.01970c	20 b0 94	jsr $0194b0			jsr 	FPUToFloat 					; convert the integer to float.
.01970f	da		phx				phx 								; save X.
.019710	5a		phy				phy 								; save decimal start position
.019711	e8		inx				inx
.019712	e8		inx				inx
.019713	e8		inx				inx
.019714	e8		inx				inx
.019715	e8		inx				inx
.019716	e8		inx				inx
.019717	20 e2 90	jsr $0190e2			jsr 	INTFromStringY 				; get the part after the DP.
.01971a	20 b0 94	jsr $0194b0			jsr 	FPUToFloat 					; convert that to a float.
.01971d	68		pla				pla 								; calculate - chars consumed.
.01971e	8c 26 04	sty $0426			sty 	ExpTemp
.019721	38		sec				sec
.019722	ed 26 04	sbc $0426			sbc 	ExpTemp 					; this is the shift amount
.019725	20 d8 95	jsr $0195d8			jsr 	FPUScale10A 				; scale it by 10^AC
.019728	fa		plx				plx 								; restore original X
.019729	20 92 91	jsr $019192			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.01972c	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.01972e	c9 45		cmp #$45			cmp 	#"E"
.019730	f0 04		beq $019736			beq 	_FPFExponent
.019732	c9 65		cmp #$65			cmp 	#"e"
.019734	d0 38		bne $01976e			bne 	_FPFNotDecimal 				; no, then exit normally.
.019736					_FPFExponent:
.019736	c8		iny				iny 								; skip over E symbol.
.019737	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.019739	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.01973b	d0 01		bne $01973e			bne 	_FPFGotSign
.01973d	c8		iny				iny 								; if it was - skip over it.
.01973e					_FPFGotSign:
.01973e	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.01973f	da		phx				phx
.019740	e8		inx				inx
.019741	e8		inx				inx
.019742	e8		inx				inx
.019743	e8		inx				inx
.019744	e8		inx				inx
.019745	e8		inx				inx
.019746	20 e2 90	jsr $0190e2			jsr 	INTFromStringY 				; get the exponent
.019749	fa		plx				plx 								; restore X.
.01974a	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.01974d	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.019750	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.019753	d0 1b		bne $019770			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.019755	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.019758	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.01975a	b0 14		bcs $019770			bcs 	_FPFXOverflow
.01975c	68		pla				pla 								; get direction
.01975d	d0 09		bne $019768			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.01975f	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.019762	49 ff		eor #$ff			eor 	#$FF
.019764	1a		inc a				inc 	a
.019765	9d 0e 03	sta $030e,x			sta 	XS2_Mantissa+0,x
.019768					_FPFXScale:
.019768	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.01976b	20 d8 95	jsr $0195d8			jsr 	FPUScale10A 				; scale by the exponent.
.01976e					_FPFNotDecimal:
.01976e	68		pla				pla
.01976f	60		rts				rts
.019770					_FPFXOverflow:
.019770	20 26 82	jsr $018226			jsr 	ERR_Handler
>019773	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>01977b	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.019782					Unary_Rnd:
.019782	20 8e 87	jsr $01878e			jsr 	EvaluateNumberX 			; get value
.019785	20 1d 8e	jsr $018e1d			jsr 	CheckNextRParen 			; check right bracket.
.019788	20 7b 8a	jsr $018a7b			jsr 	GetSignCurrent 				; get sign -1,0,1.
.01978b	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.01978d	30 10		bmi $01979f			bmi 	_URSetSeed
.01978f	f0 2c		beq $0197bd			beq 	_URMakeRandom 				; if zero return same number.
.019791	da		phx				phx
.019792	a2 00		ldx #$00			ldx 	#0
.019794	20 fa 97	jsr $0197fa			jsr 	Random16
.019797	a2 02		ldx #$02			ldx 	#2
.019799	20 fa 97	jsr $0197fa			jsr 	Random16
.01979c	fa		plx				plx
.01979d	80 1e		bra $0197bd			bra 	_URMakeRandom
.01979f					_URSetSeed:
.01979f	20 b0 94	jsr $0194b0			jsr 	FPUToFloat 					; make it a float to twiddle it.
.0197a2	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.0197a5	8d 2f 04	sta $042f			sta 	RandomSeed+0
.0197a8	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.0197ab	8d 30 04	sta $0430			sta 	RandomSeed+1
.0197ae	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.0197b1	8d 31 04	sta $0431			sta 	RandomSeed+2
.0197b4	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.0197b7	0a		asl a				asl 	a
.0197b8	49 db		eor #$db			eor 	#$DB
.0197ba	8d 32 04	sta $0432			sta 	RandomSeed+3
.0197bd					_URMakeRandom:
.0197bd	ad 2f 04	lda $042f			lda 	RandomSeed+0 				; check if seed is zero.
.0197c0	0d 30 04	ora $0430			ora 	RandomSeed+1
.0197c3	0d 31 04	ora $0431			ora 	RandomSeed+2
.0197c6	0d 32 04	ora $0432			ora 	RandomSeed+3
.0197c9	d0 0a		bne $0197d5			bne 	_URNotZero
.0197cb	a9 47		lda #$47			lda 	#$47
.0197cd	8d 30 04	sta $0430			sta 	RandomSeed+1				; if it is, make it non zero.
.0197d0	a9 3d		lda #$3d			lda 	#$3D
.0197d2	8d 32 04	sta $0432			sta 	RandomSeed+3
.0197d5					_URNotZero:
.0197d5	ad 2f 04	lda $042f			lda 	RandomSeed+0 				; copy seed into mantissa.
.0197d8	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0197db	ad 30 04	lda $0430			lda 	RandomSeed+1
.0197de	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0197e1	ad 31 04	lda $0431			lda 	RandomSeed+2
.0197e4	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0197e7	ad 32 04	lda $0432			lda 	RandomSeed+3
.0197ea	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0197ed	a9 00		lda #$00			lda 	#$00 						; set type to float.
.0197ef	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0197f2	a9 80		lda #$80			lda 	#$80
.0197f4	9d 0c 03	sta $030c,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.0197f7	4c e7 94	jmp $0194e7			jmp 	FPUNormalise
.0197fa					Random16:
.0197fa	5e 30 04	lsr $0430,x			lsr 	RandomSeed+1,x				; shift seed right
.0197fd	7e 2f 04	ror $042f,x			ror 	RandomSeed,x
.019800	90 08		bcc $01980a			bcc 	_R16_NoXor
.019802	bd 30 04	lda $0430,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.019805	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.019807	9d 30 04	sta $0430,x			sta 	RandomSeed+1,x
.01980a					_R16_NoXor:
.01980a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.01980b					Unary_Int:
.01980b	20 8e 87	jsr $01878e			jsr 	EvaluateNumberX 			; get value
.01980e	20 1d 8e	jsr $018e1d			jsr 	CheckNextRParen 			; check right bracket.
.019811	4c 0f 95	jmp $01950f			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.019814					TIM_Error:
.019814	20 29 80	jsr $018029			jsr 	IFT_UpLine 					; go up one line.
.019817	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.019819	80 02		bra $01981d			bra 	TIM_ShowPrompt
.01981b					TIM_NewCommand:
.01981b	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.01981d					TIM_ShowPrompt:
.01981d	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.019820	20 fa 80	jsr $0180fa			jsr 	IFT_ReadLine	 			; get character, go to next line
.019823	20 5c 80	jsr $01805c			jsr 	IFT_NewLine					; go to next line.
.019826	86 10		stx $10				stx 	zTemp1 						; save line read address
.019828	84 11		sty $11				sty 	zTemp1+1
.01982a	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.01982c	b1 10		lda ($10),y			lda 	(zTemp1),y
.01982e	c9 3f		cmp #$3f			cmp 	#"?"
.019830	f0 04		beq $019836			beq 	TIM_SkipFirst
.019832	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.019834	d0 01		bne $019837			bne 	TIM_NotDot
.019836					TIM_SkipFirst:
.019836	c8		iny				iny
.019837					TIM_NotDot:
.019837	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.019839	c9 52		cmp #$52			cmp 	#"R"						; show registers
.01983b	f0 6b		beq $0198a8			beq 	TIM_ShowRegisters
.01983d	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.01983f	f0 12		beq $019853			beq 	TIM_ShowMemory
.019841	c9 47		cmp #$47			cmp 	#"G"						; execute
.019843	f0 49		beq $01988e			beq 	TIM_Execute
.019845	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.019847	f0 07		beq $019850			beq 	TIM_GoLoadMemory
.019849	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.01984b	d0 c7		bne $019814			bne 	TIM_Error
.01984d	4c cc 99	jmp $0199cc			jmp 	TIM_UpdateRegisters
.019850					TIM_GoLoadMemory:
.019850	4c fc 99	jmp $0199fc			jmp 	TIM_LoadMemory
.019853					TIM_ShowMemory:
.019853	20 48 99	jsr $019948			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.019856	b0 bc		bcs $019814			bcs 	TIM_Error
.019858	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.01985a	85 12		sta $12				sta 	zTemp2
.01985c	a5 15		lda $15				lda 	zTemp3+1
.01985e	85 13		sta $13				sta 	zTemp2+1
.019860	20 48 99	jsr $019948			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.019863	90 08		bcc $01986d			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.019865	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.019867	85 14		sta $14				sta 	zTemp3
.019869	a5 13		lda $13				lda 	zTemp2+1
.01986b	85 15		sta $15				sta 	zTemp3+1
.01986d					_TIMSM_Start:
.01986d	20 20 99	jsr $019920			jsr 	TIM_WriteLine 				; write one line of hex out
.019870	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.019872	18		clc				clc
.019873	69 10		adc #$10			adc 	#16
.019875	85 12		sta $12				sta 	zTemp2
.019877	90 02		bcc $01987b			bcc 	_TIMSM_NoCarry
.019879	e6 13		inc $13				inc 	zTemp2+1
.01987b					_TIMSM_NoCarry:
.01987b	20 e1 81	jsr $0181e1			jsr 	IF_CheckBreak 				; check CTL+C
.01987e	d0 0b		bne $01988b			bne 	_TIMSM_Ends 				; if pressed break out.
.019880	38		sec				sec 								; check past the end address in zTemp3
.019881	a5 14		lda $14				lda 	zTemp3
.019883	e5 12		sbc $12				sbc 	zTemp2
.019885	a5 15		lda $15				lda 	zTemp3+1
.019887	e5 13		sbc $13				sbc 	zTemp2+1
.019889	10 e2		bpl $01986d			bpl 	_TIMSM_Start
.01988b					_TIMSM_Ends:
.01988b	4c 1b 98	jmp $01981b			jmp 	TIM_NewCommand
.01988e					TIM_Execute:
.01988e	20 48 99	jsr $019948			jsr 	TIM_GetHex 					; get the execute address
.019891	b0 81		bcs $019814			bcs 	TIM_Error 					; not legitimate
.019893	ae 3c 04	ldx $043c			ldx 	TIM_SP 						; set up SP
.019896	9a		txs				txs
.019897	ad 37 04	lda $0437			lda 	TIM_SR 						; Status for PLP
.01989a	48		pha				pha
.01989b	ad 38 04	lda $0438			lda 	TIM_A 						; restore AXYZ
.01989e	ae 39 04	ldx $0439			ldx 	TIM_X
.0198a1	ac 3a 04	ldy $043a			ldy 	TIM_Y
.0198a4	28		plp				plp 								; and PS Byte.
.0198a5	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.0198a8					TIM_Start:
.0198a8					TIM_ShowRegisters:
.0198a8	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.0198ab	8d 36 04	sta $0436			sta 	TIM_IRQ+1
.0198ae	ad ff ff	lda $ffff			lda 	$FFFF
.0198b1	8d 35 04	sta $0435			sta 	TIM_IRQ
.0198b4	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.0198b6					_TIMSR_Text:
.0198b6	bf e7 98 01	lda $0198e7,x			lda 	_TIMSR_Label,x
.0198ba	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0198bd	e8		inx				inx
.0198be	e0 20		cpx #$20			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.0198c0	d0 f4		bne $0198b6			bne 	_TIMSR_Text
.0198c2	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.0198c4					_TIMSR_Skip:
.0198c4	e8		inx				inx
.0198c5					_TIMSR_LoopSpace:
.0198c5	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.0198c7	b0 04		bcs $0198cd			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.0198c9	8a		txa				txa
.0198ca	4a		lsr a				lsr 	a
.0198cb	b0 05		bcs $0198d2			bcs 	_TIMSR_NoSpace
.0198cd					_TIMSR_Space:
.0198cd	a9 20		lda #$20			lda 	#" "
.0198cf	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0198d2					_TIMSR_NoSpace:
.0198d2	bd 33 04	lda $0433,x			lda 	TIM_PC,x 					; output hex value.
.0198d5	20 07 99	jsr $019907			jsr 	TIM_WriteHex
.0198d8	e8		inx				inx
.0198d9	e0 08		cpx #$08			cpx 	#TIM_Z-TIM_PC
.0198db	f0 e7		beq $0198c4			beq 	_TIMSR_Skip
.0198dd	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.0198df	d0 e4		bne $0198c5			bne 	_TimSR_LoopSpace
.0198e1	20 5c 80	jsr $01805c			jsr 	IFT_NewLine 				; new line
.0198e4	4c 1b 98	jmp $01981b			jmp	 	TIM_NewCommand 				; new command.
.0198e7					_TIMSR_Label:
>0198e7	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>0198ef	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>0198ff	52
>019900	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.019907					_TIMSR_LabelEnd:
.019907					TIM_WriteHex:
.019907	48		pha				pha 								; save A
.019908	4a		lsr a				lsr 	a 							; shift MSB->LSB
.019909	4a		lsr a				lsr 	a
.01990a	4a		lsr a				lsr 	a
.01990b	4a		lsr a				lsr 	a
.01990c	20 10 99	jsr $019910			jsr 	_TIMWH_Nibble 				; print MSB
.01990f	68		pla				pla 								; restore and print LSB
.019910					_TIMWH_Nibble:
.019910	48		pha				pha
.019911	29 0f		and #$0f			and 	#15 						; mask out
.019913	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.019915	90 02		bcc $019919			bcc 	_TIMWHNoLetter
.019917	69 06		adc #$06			adc 	#6
.019919					_TIMWHNoLetter:
.019919	69 30		adc #$30			adc 	#48
.01991b	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter 			; print it out.
.01991e	68		pla				pla
.01991f	60		rts				rts
.019920					TIM_WriteLine:
.019920	a9 2e		lda #$2e			lda 	#"." 						; prompt
.019922	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.019925	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.019927	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01992a	a5 13		lda $13				lda 	zTemp2+1 					; write address
.01992c	20 07 99	jsr $019907			jsr 	TIM_WriteHex
.01992f	a5 12		lda $12				lda 	zTemp2
.019931	20 07 99	jsr $019907			jsr 	TIM_WriteHex
.019934	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.019936					_TIMWL_Loop:
.019936	a9 20		lda #$20			lda 	#" "
.019938	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01993b	b1 12		lda ($12),y			lda 	(zTemp2),y
.01993d	20 07 99	jsr $019907			jsr 	TIM_WriteHex
.019940	c8		iny				iny
.019941	c0 10		cpy #$10			cpy 	#16
.019943	d0 f1		bne $019936			bne 	_TIMWL_Loop
.019945	4c 5c 80	jmp $01805c			jmp 	IFT_NewLine 				; new line and exit
.019948					TIM_GetHex:
.019948	c8		iny				iny
.019949	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.01994b	c9 20		cmp #$20			cmp 	#32
.01994d	f0 f9		beq $019948			beq 	TIM_GetHex
.01994f	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.019951	f0 f5		beq $019948			beq 	TIM_GetHex
.019953	20 7c 99	jsr $01997c			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.019956	b0 23		bcs $01997b			bcs 	_TIMGH_Exit					; if first bad then exit now.
.019958	a9 00		lda #$00			lda 	#0 							; zero result
.01995a	85 14		sta $14				sta 	zTemp3
.01995c	85 15		sta $15				sta 	zTemp3+1
.01995e					_TIM_GHLoop:
.01995e	20 7c 99	jsr $01997c			jsr 	TIM_GetHexCharacter 		; get next character
.019961	b0 17		bcs $01997a			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.019963	c8		iny				iny 								; skip over it.
.019964	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.019966	26 15		rol $15				rol 	zTemp3+1
.019968	06 14		asl $14				asl 	zTemp3 						; now x 2
.01996a	26 15		rol $15				rol 	zTemp3+1
.01996c	06 14		asl $14				asl 	zTemp3						; now x 4
.01996e	26 15		rol $15				rol 	zTemp3+1
.019970	06 14		asl $14				asl 	zTemp3 						; now x 8
.019972	26 15		rol $15				rol 	zTemp3+1
.019974	05 14		ora $14				ora 	zTemp3 						; OR result in
.019976	85 14		sta $14				sta 	zTemp3
.019978	80 e4		bra $01995e			bra 	_TIM_GHLoop 				; loop round again.
.01997a					_TIMGH_Okay:
.01997a	18		clc				clc
.01997b					_TIMGH_Exit:
.01997b	60		rts				rts
.01997c					TIM_GetHexCharacter:
.01997c	b1 10		lda ($10),y			lda 	(zTemp1),y
.01997e	38		sec				sec
.01997f	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.019981	90 0e		bcc $019991			bcc 	_TIM_GHCFail
.019983	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.019985	90 0b		bcc $019992			bcc 	_TIM_GHCExit
.019987	c9 11		cmp #$11			cmp 	#65-48						; < A
.019989	90 06		bcc $019991			bcc		_TIM_GHCFail
.01998b	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.01998d	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.01998f	90 01		bcc $019992			bcc		_TIM_GHCExit
.019991					_TIM_GHCFail:
.019991	38		sec				sec
.019992					_TIM_GHCExit:
.019992	60		rts				rts
.019993					TIM_BreakVector:
.019993	da		phx				phx									; save X/A on stack
.019994	48		pha				pha
.019995	ba		tsx				tsx 								; X points to S
.019996	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.019999	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.01999b	d0 03		bne $0199a0			bne 	_TIMBreak					; if set, it's BRK
.01999d	68		pla				pla 								; abandon routine.
.01999e	fa		plx				plx
.01999f	40		rti				rti
.0199a0					_TIMBreak:
.0199a0	68		pla				pla 								; save A X Y and maybe Z
.0199a1	8d 38 04	sta $0438			sta 	TIM_A
.0199a4	fa		plx				plx
.0199a5	8e 39 04	stx $0439			stx 	TIM_X
.0199a8	8c 3a 04	sty $043a			sty 	TIM_Y
.0199ab	68		pla				pla 								; get Status Register
.0199ac	8d 37 04	sta $0437			sta 	TIM_SR
.0199af	68		pla				pla
.0199b0	8d 34 04	sta $0434			sta 	TIM_PC+1 					; save calling address
.0199b3	68		pla				pla
.0199b4	8d 33 04	sta $0433			sta 	TIM_PC 						; high byte
.0199b7	ad 34 04	lda $0434			lda 	TIM_PC+1 					; dec PC to point right.
.0199ba	d0 03		bne $0199bf			bne 	_TIMDecrement 				; brk bumps it.
.0199bc	ce 33 04	dec $0433			dec 	TIM_PC
.0199bf					_TIMDecrement:
.0199bf	ce 34 04	dec $0434			dec 	TIM_PC+1
.0199c2	ba		tsx				tsx 								; and copy SP
.0199c3	8e 3c 04	stx $043c			stx 	TIM_SP
.0199c6	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.0199c8	9a		txs				txs
.0199c9	4c a8 98	jmp $0198a8			jmp 	TIM_Start 					; and start up TIM monitor.
.0199cc					TIM_UpdateRegisters:
.0199cc	20 48 99	jsr $019948			jsr 	TIM_GetHex 					; PC
.0199cf	b0 28		bcs $0199f9			bcs 	_TIMURFail
.0199d1	a5 14		lda $14				lda 	zTemp3
.0199d3	8d 34 04	sta $0434			sta 	Tim_PC+1
.0199d6	a5 15		lda $15				lda 	zTemp3+1
.0199d8	8d 33 04	sta $0433			sta 	Tim_PC
.0199db	20 48 99	jsr $019948			jsr 	TIM_GetHex 					; ignore IRQ
.0199de	b0 19		bcs $0199f9			bcs 	_TIMURFail
.0199e0	a2 00		ldx #$00			ldx 	#0
.0199e2					_TIM_URLoop:
.0199e2	e0 04		cpx #$04			cpx 	#Tim_Z-Tim_SR
.0199e4	d0 01		bne $0199e7			bne 	_TIM_1
.0199e6	e8		inx				inx
.0199e7					_TIM_1:
.0199e7	20 48 99	jsr $019948			jsr 	TIM_GetHex 					; registers
.0199ea	b0 0d		bcs $0199f9			bcs 	_TIMURFail
.0199ec	a5 14		lda $14				lda 	zTemp3
.0199ee	9d 37 04	sta $0437,x			sta 	Tim_SR,x
.0199f1	e8		inx				inx
.0199f2	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.0199f4	d0 ec		bne $0199e2			bne 	_TIM_URLoop
.0199f6	4c 1b 98	jmp $01981b			jmp 	TIM_NewCommand
.0199f9					_TIMURFail:
.0199f9	4c 14 98	jmp $019814			jmp 	TIM_Error
.0199fc					TIM_LoadMemory:
.0199fc	20 48 99	jsr $019948			jsr 	TIM_GetHex 					; target address => zTemp2
.0199ff	a5 14		lda $14				lda 	zTemp3
.019a01	85 12		sta $12				sta 	zTemp2
.019a03	a5 15		lda $15				lda 	zTemp3+1
.019a05	85 13		sta $13				sta 	zTemp2+1
.019a07					_TIM_LMLoop:
.019a07	20 48 99	jsr $019948			jsr 	TIM_GetHex 					; next byte ?
.019a0a	b0 0e		bcs $019a1a			bcs 	_TIMLMDone 					; no more
.019a0c	a2 00		ldx #$00			ldx 	#0							; write out.
.019a0e	a5 14		lda $14				lda 	zTemp3
.019a10	81 12		sta ($12,x)			sta 	(zTemp2,x)
.019a12	e6 12		inc $12				inc 	zTemp2 						; bump address
.019a14	d0 f1		bne $019a07			bne 	_TIM_LMLoop
.019a16	e6 13		inc $13				inc 	zTemp2+1
.019a18	80 ed		bra $019a07			bra 	_TIM_LMLoop
.019a1a					_TIMLMDone:
.019a1a	4c 1b 98	jmp $01981b			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Return to file: basic.asm

>019a1d	02						.byte 	2
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 c0						.word 	StartROM
>fffe	19 c0					.word TIM_BreakHandler

;******  End of listing
