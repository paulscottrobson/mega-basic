
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Sun Sep  1 17:22:36 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="65816"				cpu = "65816"
="em65816"				hardware = "em65816"
=1					exitonend = 1
=0					autorun = 0
=1					loadtest = 1
=1					hasfloat = 1
=1					hasinteger = 1
=253					maxstring = 253

;******  Processing file: modules/basic/pointer/em65816/src_em65816.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stackmarkers.inc

=5					SourcePosSize   =   5 							; Source position stack space needed.
=1					SMark_Gosub 	= 	1 							; 0 is GOSUB/RETURN.
=2					SMark_Repeat 	= 	2 							; 1 is REPEAT/UNTIL.
=3					SMark_While 	= 	3 							; 2 is WHILE/WEND.
=4					SMark_If 		= 	4 							; 3 is IF/ENDIF
=5					SMark_For 		= 	5 							; 4 is FOR/NEXT

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/hardware/common/macros32.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0020					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0022					zVarDataPtr: .word ? 						; position of variable data.
>0024					zVarType: 	.byte ? 						; type of data (token)
>0025					zNullString:.byte ? 						; represents a NULL string.
>0026					zBasicSP:	.word ? 						; stack pointer
>0080					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>0084					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>0085					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=134					XS2_Mantissa = XS_Mantissa+XS_Size
=138					XS2_Exponent = XS_Exponent+XS_Size
=139					XS2_Type = XS_Type+XS_Size
=140					XS3_Mantissa = XS_Mantissa+XS_Size*2
=144					XS3_Exponent = XS_Exponent+XS_Size*2
=145					XS3_Type = XS_Type+XS_Size*2
>0300					StringPtr:	.word ? 						; Top of free memory (for string allocation)
>0302					VarMemPtr: 	.word ?							; Bottom of free memory (for variables)
>0304					endOfProgram: .dword ? 						; End of Program Memory (long)
>0308					vecPrintCharacter .word ?
>030a					vecInputCharacter .word ?
>030c					UserVector .fill 4 							; USR(x) calls this.
>0310					LocalVector .fill 4 						; Indirect calls call this.
>0314					NumBufX 	.byte 	?						; buffer index position
>0315					Num_Buffer	.fill 	32 						; buffer for numeric conversions
=6					HashTableCount = 6 							; there are 6 hash tables, in token order.
=8					HashTableSize = 8 							; each hash table as 8 links.
.0335					HashTableBase:
>0335								.fill	HashTableCount * HashTableSize * 2
.0395					HashTableEnd:
=$315					Var_Buffer 	= Num_Buffer 					; buffer for variable name (same space)
>0395					Var_Type    .byte ? 						; type of variable (as a type token)
>0396					Var_Hash 	.byte ? 						; hash of identifier name.
>0397					Var_Length 	.byte ? 						; length of variable name
>0398					Var_HashAddress .byte ?						; low byte of hash table entry.
>0399					Var_DataSize .byte ?						; size of one element.
>039a					NumSuppress	.byte 	?						; leading zero suppression flag
>039b					NumConvCount .byte 	? 						; count for conversions.
>039c					ExpTemp:	.byte ?							; Working temp for exponents.
>039d					ExpCount:	.byte ? 						; Count of decimal exponents.
>039e					SignCount:	.byte ?							; Integer Divide Sign Counts.
>039f					TempStringWriteIndex: .byte ? 				; Write offset.
>03a0					ValSign: 	.byte ? 						; sign flag for val()
>03a1					SliceStart:	.byte ? 						; string slice parts
>03a2					SliceCount:	.byte ?
>03a3					RandomSeed:	.dword ? 						; Random seed.
>03a7					SignNext:	.byte ? 						; Used for keeping sign of STEP in FOR/NEXT
>03a8					BreakCount:	.byte ? 						; Counter, avoid checking break every command.
=3					ArrayMaxDim = 3 							; number of dimensions.
>03a9					ArrayDef:	.fill (ArrayMaxDim+1)*2 		; dimensions for auto-creation
>03b1					UsrArrayDef:.fill (ArrayMaxDim+1)*2 		; dimensions created in DIM
>03b9					UsrArrayIdx:.byte ? 						; index into UsrArrayDef
>03ba					LastPrinted:.byte ? 						; last printed char ?
>03bb					ListIndent: .byte ? 						; list indent level
>03bc					LastListIndent:.byte ? 						; previous one.
>03bd					DataLPtr: 	.dword ?						; the data long ptr (swapped with zCodePtr)
>03c1					DataIndex:	.byte ?							; index position.
>03c2					InputAvailable: .byte ? 					; characters available in input buffer.
>03c3					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>03c5					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>03c7					Tim_SR:		.byte ? 						; Processor Status
>03c8					Tim_A:		.byte ? 						; Processor Registers
>03c9					Tim_X:		.byte ?
>03ca					Tim_Y:		.byte ?
>03cb					Tim_Z:		.byte ?
>03cc					Tim_SP:		.word ?							; Stack Pointer (just in cases)
>0400					BasicStack:	.fill 	256 					; and occupy whole pages.
.0500					EndBasicStack:
>0500					IFT_XCursor:.byte ?							; current logical position on screen
>0501					IFT_YCursor:.byte ?
>0502					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0566					IFT_LineBuffer: .fill 100 					; line input buffer.

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/em65816.asm

=$7f00					HighMemory = $7F00
=$3000					VariableMemory = $3000
.1000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testcode.src

>1000	19 0a 00 ce fe 07 68 65			.byte	$19,$0a,$00,$ce,$fe,$07,$68,$65
>1008	6c 6c 6f bf 08 05 0c 0c			.byte	$6c,$6c,$6f,$bf,$08,$05,$0c,$0c
>1010	0f bf 17 0f 12 0c 04 b7			.byte	$0f,$bf,$17,$0f,$12,$0c,$04,$b7
>1018	00 00					.byte	$00,$00

;******  Return to file: modules/hardware/em65816.asm

.c000					StartROM:
.c000	18		clc				clc
.c001	fb		xce				xce
.c002	c2 30		rep #$30			rep 	#$30
.c004	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.c007	1b		tcs				tcs
.c008	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.c00b	e2 30		sep #$30			sep 	#$30
.c00d	c2 30		rep #$30			rep 	#$30						; clear AXY in 16 bit.
.c00f	a9 00		lda #$00			lda 	#$0000
.c011	aa		tax				tax
.c012	a8		tay				tay
.c013	e2 30		sep #$30			sep 	#$30
.c015	5c 01 88 01	jmp $018801		jmp BASIC_Start
.c019					TIM_BreakHandler:
.c019	5c 69 83 01	jmp $018369			jmp 	TIM_BreakVector

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.018000					IFT_ClearScreen:
.018000	48		pha				pha
.018001	da		phx				phx
.018002	5a		phy				phy
.018003	20 9c 81	jsr $01819c			jsr 	IF_Home 					; home cursor
.018006	a2 20		ldx #$20			ldx 	#IF_Height 					; this many lines.
.018008					_IFT_CS0:
.018008	a0 40		ldy #$40			ldy 	#IF_Width 					; this many chars/line
.01800a					_IFT_CS1:
.01800a	a9 20		lda #$20			lda 	#' '						; clear line.
.01800c	20 c8 81	jsr $0181c8			jsr 	IF_Write
.01800f	88		dey				dey
.018010	d0 f8		bne $01800a			bne 	_IFT_CS1
.018012	20 af 81	jsr $0181af			jsr 	IF_NewLine 					; next line down
.018015	ca		dex				dex
.018016	d0 f0		bne $018008			bne 	_IFT_CS0
.018018	7a		ply				ply
.018019	fa		plx				plx
.01801a	68		pla				pla
.01801b					IFT_HomeCursor:
.01801b	48		pha				pha
.01801c	20 9c 81	jsr $01819c			jsr 	IF_Home
.01801f	a9 00		lda #$00			lda 	#0
.018021	8d 00 05	sta $0500			sta 	IFT_XCursor
.018024	8d 01 05	sta $0501			sta 	IFT_YCursor
.018027	68		pla				pla
.018028	60		rts				rts
.018029					IFT_UpLine:
.018029	48		pha				pha
.01802a	ad 01 05	lda $0501			lda  	IFT_YCursor 				; get Y
.01802d	3a		dec a				dec 	a 							; line above
.01802e	30 03		bmi $018033			bmi 	_IFTULExit 					; too far, abort
.018030	20 be 80	jsr $0180be			jsr 	IFT_SetYPos					; set to that line.
.018033					_IFTULExit:
.018033	68		pla				pla
.018034	60		rts				rts
.018035					IFT_PrintCharacter:
.018035	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.018037	f0 16		beq $01804f			beq 	IFT_NewLine
.018039	48		pha				pha
.01803a	20 67 80	jsr $018067			jsr 	IFT_UpperCase 				; make upper case
.01803d	20 c8 81	jsr $0181c8			jsr 	IF_Write 					; write out.
.018040	ee 00 05	inc $0500			inc 	IFT_XCursor 				; bump x cursor
.018043	ad 00 05	lda $0500			lda 	IFT_XCursor 				; reached RHS ?
.018046	c9 40		cmp #$40			cmp 	#IF_Width
.018048	d0 03		bne $01804d			bne 	_IFT_PCNotEOL
.01804a	20 4f 80	jsr $01804f			jsr 	IFT_NewLine 				; if so do new line.
.01804d					_IFT_PCNotEOL:
.01804d	68		pla				pla
.01804e	60		rts				rts
.01804f					IFT_NewLine:
.01804f	48		pha				pha
.018050	20 af 81	jsr $0181af			jsr 	IF_NewLine 					; new line on actual screen.
.018053	a9 00		lda #$00			lda 	#0 							; reset x position
.018055	8d 00 05	sta $0500			sta 	IFT_XCursor
.018058	ee 01 05	inc $0501			inc 	IFT_YCursor 				; move down.
.01805b	ad 01 05	lda $0501			lda 	IFT_YCursor
.01805e	c9 20		cmp #$20			cmp 	#IF_Height 					; reached bottom.
.018060	d0 03		bne $018065			bne 	_IFT_NL_NotEOS
.018062	20 72 80	jsr $018072			jsr 	IFT_Scroll 					; scroll screen up.
.018065					_IFT_NL_NotEOS:
.018065	68		pla				pla
.018066	60		rts				rts
.018067					IFT_UpperCase:
.018067	c9 61		cmp #$61			cmp 	#"a"
.018069	90 06		bcc $018071			bcc 	_IFT_UCExit
.01806b	c9 7b		cmp #$7b			cmp 	#"z"+1
.01806d	b0 02		bcs $018071			bcs 	_IFT_UCExit
.01806f	49 20		eor #$20			eor 	#$20
.018071					_IFT_UCExit:
.018071	60		rts				rts
.018072					IFT_Scroll:
.018072	48		pha				pha 								; save AXY
.018073	da		phx				phx
.018074	5a		phy				phy
.018075	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.018077					_IFT_SLoop:
.018077	20 97 80	jsr $018097			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.01807a	e8		inx				inx
.01807b	e0 1f		cpx #$1f			cpx 	#IF_Height-1				; do whole screen
.01807d	d0 f8		bne $018077			bne 	_IFT_SLoop
.01807f	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.018081	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.018084	a2 40		ldx #$40			ldx 	#IF_Width 					; blank line
.018086					_IFT_SBlank:
.018086	a9 20		lda #$20			lda 	#32
.018088	20 c8 81	jsr $0181c8			jsr 	IF_Write
.01808b	ca		dex				dex
.01808c	d0 f8		bne $018086			bne 	_IFT_SBlank
.01808e	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.018090	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.018093	7a		ply				ply
.018094	fa		plx				plx
.018095	68		pla				pla
.018096	60		rts				rts
.018097					_IFT_ScrollLine:
.018097	da		phx				phx
.018098	da		phx				phx
.018099	8a		txa				txa 								; copy line into buffer.
.01809a	1a		inc a				inc 	a 							; next line down.
.01809b	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.01809e	a2 00		ldx #$00			ldx 	#0
.0180a0					_IFTScrollCopy1:
.0180a0	20 bf 81	jsr $0181bf			jsr 	IF_Read
.0180a3	9d 02 05	sta $0502,x			sta 	IFT_Buffer,x
.0180a6	e8		inx				inx
.0180a7	e0 40		cpx #$40			cpx 	#IF_Width
.0180a9	d0 f5		bne $0180a0			bne 	_IFTScrollCopy1
.0180ab	68		pla				pla
.0180ac	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.0180af	a2 00		ldx #$00			ldx 	#0
.0180b1					_IFTScrollCopy2:
.0180b1	bd 02 05	lda $0502,x			lda 	IFT_Buffer,x
.0180b4	20 c8 81	jsr $0181c8			jsr 	IF_Write
.0180b7	e8		inx				inx
.0180b8	e0 40		cpx #$40			cpx 	#IF_Width
.0180ba	d0 f5		bne $0180b1			bne 	_IFTScrollCopy2
.0180bc	fa		plx				plx
.0180bd	60		rts				rts
.0180be					IFT_SetYPos:
.0180be	48		pha				pha
.0180bf	da		phx				phx
.0180c0	aa		tax				tax
.0180c1	20 1b 80	jsr $01801b			jsr 	IFT_HomeCursor
.0180c4	e0 00		cpx #$00			cpx 	#0
.0180c6	f0 09		beq $0180d1			beq 	_IFT_MOAExit
.0180c8					_IFT_MOALoop:
.0180c8	20 af 81	jsr $0181af			jsr 	IF_NewLine
.0180cb	ee 01 05	inc $0501			inc 	IFT_YCursor
.0180ce	ca		dex				dex
.0180cf	d0 f7		bne $0180c8			bne		_IFT_MOALoop
.0180d1					_IFT_MOAExit:
.0180d1	fa		plx				plx
.0180d2	68		pla				pla
.0180d3	60		rts				rts
.0180d4					IFT_GetKeyCursor:
.0180d4	20 dc 80	jsr $0180dc			jsr 	_IFT_FlipCursor 			; reverse current
.0180d7					_IFT_GKCWait:
.0180d7	20 d9 81	jsr $0181d9			jsr 	IF_GetKey 					; get key
.0180da	f0 fb		beq $0180d7			beq 	_IFT_GKCWait
.0180dc					_IFT_FlipCursor:
.0180dc	48		pha				pha 								; save
.0180dd	20 bf 81	jsr $0181bf			jsr 	IF_Read 					; read
.0180e0	20 d1 81	jsr $0181d1			jsr 	IF_LeftOne
.0180e3	49 80		eor #$80			eor 	#$80 						; reverse
.0180e5	20 c8 81	jsr $0181c8			jsr 	IF_Write 					; write
.0180e8	20 d1 81	jsr $0181d1			jsr 	IF_LeftOne
.0180eb	68		pla				pla
.0180ec	60		rts				rts
.0180ed					IFT_ReadLine:
.0180ed	48		pha				pha
.0180ee					_IFT_RLLoop:
.0180ee	20 d4 80	jsr $0180d4			jsr 	IFT_GetKeyCursor 			; get keystroke
.0180f1	c9 0d		cmp #$0d			cmp 	#13							; return
.0180f3	f0 7d		beq $018172			beq 	_IFT_RLExit
.0180f5	c9 20		cmp #$20			cmp 	#32 						; control character
.0180f7	90 05		bcc $0180fe			bcc 	_IFT_Control
.0180f9	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0180fc	80 f0		bra $0180ee			bra 	_IFT_RLLoop
.0180fe					_IFT_Control:
.0180fe	c9 01		cmp #$01			cmp 	#"A"-64
.018100	f0 26		beq $018128			beq 	_IFT_Left
.018102	c9 04		cmp #$04			cmp 	#"D"-64
.018104	f0 2e		beq $018134			beq 	_IFT_Right
.018106	c9 17		cmp #$17			cmp 	#"W"-64
.018108	f0 36		beq $018140			beq 	_IFT_Up
.01810a	c9 13		cmp #$13			cmp 	#"S"-64
.01810c	f0 3e		beq $01814c			beq 	_IFT_Down
.01810e	c9 08		cmp #$08			cmp 	#"H"-64
.018110	f0 09		beq $01811b			beq 	_IFT_Backspace
.018112	c9 1a		cmp #$1a			cmp 	#"Z"-64
.018114	d0 d8		bne $0180ee			bne 	_IFT_RLLoop
.018116	20 00 80	jsr $018000			jsr 	IFT_ClearScreen				; clear CTL-Z
.018119	80 d3		bra $0180ee			bra 	_IFT_RLLoop
.01811b					_IFT_Backspace:
.01811b	ad 00 05	lda $0500			lda 	IFT_XCursor 				; check not start of line.
.01811e	f0 ce		beq $0180ee			beq 	_IFT_RLLoop
.018120	20 d1 81	jsr $0181d1			jsr 	IF_LeftOne
.018123	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.018125	20 c8 81	jsr $0181c8			jsr 	IF_Write
.018128					_IFT_Left:
.018128	ce 00 05	dec $0500			dec 	IFT_XCursor 				; left CTL-W
.01812b	10 29		bpl $018156			bpl 	_IFT_Reposition
.01812d	a9 3f		lda #$3f			lda 	#IF_Width-1
.01812f					_IFT_SetX:
.01812f	8d 00 05	sta $0500			sta 	IFT_XCursor
.018132	80 22		bra $018156			bra 	_IFT_Reposition
.018134					_IFT_Right:
.018134	ee 00 05	inc $0500			inc 	IFT_XCursor
.018137	ad 00 05	lda $0500			lda 	IFT_XCursor
.01813a	49 40		eor #$40			eor 	#IF_Width
.01813c	f0 f1		beq $01812f			beq 	_IFT_SetX
.01813e	80 16		bra $018156			bra 	_IFT_Reposition
.018140					_IFT_Up:
.018140	ce 01 05	dec $0501			dec 	IFT_YCursor
.018143	10 11		bpl $018156			bpl 	_IFT_Reposition
.018145	a9 1f		lda #$1f			lda 	#IF_Height-1
.018147					_IFT_SetY:
.018147	8d 01 05	sta $0501			sta 	IFT_YCursor
.01814a	80 0a		bra $018156			bra 	_IFT_Reposition
.01814c					_IFT_Down:
.01814c	ee 01 05	inc $0501			inc 	IFT_YCursor
.01814f	ad 01 05	lda $0501			lda 	IFT_YCursor
.018152	49 20		eor #$20			eor 	#IF_Height
.018154	f0 f1		beq $018147			beq 	_IFT_SetY
.018156					_IFT_Reposition:
.018156	ad 00 05	lda $0500			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.018159	48		pha				pha
.01815a	ad 01 05	lda $0501			lda 	IFT_YCursor
.01815d	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.018160	68		pla				pla
.018161	aa		tax				tax
.018162	e0 00		cpx #$00			cpx 	#0
.018164	f0 88		beq $0180ee			beq 	_IFT_RLLoop
.018166					_IFT_MoveRight:
.018166	20 bf 81	jsr $0181bf			jsr 	IF_Read
.018169	ee 00 05	inc $0500			inc 	IFT_XCursor
.01816c	ca		dex				dex
.01816d	d0 f7		bne $018166			bne 	_IFT_MoveRight
.01816f	4c ee 80	jmp $0180ee			jmp 	_IFT_RLLoop
.018172					_IFT_RLExit:
.018172	ad 01 05	lda $0501			lda 	IFT_YCursor 				; go to start of line.
.018175	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.018178	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.01817a					_IFT_RLRead:
.01817a	20 bf 81	jsr $0181bf			jsr 	IF_Read
.01817d	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.018180	e8		inx				inx
.018181	e0 40		cpx #$40			cpx 	#IF_Width
.018183	d0 f5		bne $01817a			bne 	_IFT_RLRead
.018185					_IFT_RL_Trim:
.018185	ca		dex				dex 	 							; previous char
.018186	30 07		bmi $01818f			bmi 	_IFT_Found 					; gone too far
.018188	bd 66 05	lda $0566,x			lda 	IFT_LineBuffer,x			; go back if space
.01818b	c9 20		cmp #$20			cmp 	#" "
.01818d	f0 f6		beq $018185			beq 	_IFT_RL_Trim
.01818f					_IFT_Found:
.01818f	e8		inx				inx 								; forward to non-space
.018190	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.018192	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.018195	68		pla				pla
.018196	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.018198	a0 05		ldy #$05			ldy 	#IFT_LineBuffer >> 8
.01819a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_em65816.asm

=64					IF_Width 	= 64 							; characters across
=32					IF_Height 	= 32 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line.
=8					IF_XPos 	= 8 							; current position, horizontal.
=$f0000					IF_Screen = $F0000							; 2k screen RAM here
=$f8010					IF_PKeyboard = $F8010						; Keyboard port.
=$f8000					IF_PBreak = $F8000 							; Break key.
.01819b					IF_Reset:
.01819b	60		rts				rts
.01819c					IF_Home:
.01819c	48		pha				pha
.01819d	64 08		stz $08				stz 	IF_XPos 					; zero X position
.01819f	a9 00		lda #$00			lda 	#IF_Screen & $FF 			; set r/w pos.
.0181a1	85 04		sta $04				sta 	IF_Pos
.0181a3	a9 00		lda #$00			lda 	#(IF_Screen >> 8) & $FF
.0181a5	85 05		sta $05				sta 	IF_Pos+1
.0181a7	a9 0f		lda #$0f			lda 	#IF_Screen >> 16
.0181a9	85 06		sta $06				sta 	IF_Pos+2
.0181ab	64 07		stz $07				stz 	IF_Pos+3
.0181ad	68		pla				pla
.0181ae	60		rts				rts
.0181af					IF_NewLine:
.0181af	48		pha				pha
.0181b0	64 08		stz $08				stz 	IF_XPos						; back to start of line
.0181b2	18		clc				clc 								; down one line
.0181b3	a5 04		lda $04				lda 	IF_Pos
.0181b5	69 40		adc #$40			adc 	#64
.0181b7	85 04		sta $04				sta 	IF_Pos
.0181b9	90 02		bcc $0181bd			bcc 	_IF_NoCarry 				; carry through.
.0181bb	e6 05		inc $05				inc 	IF_Pos+1
.0181bd					_IF_NoCarry:
.0181bd	68		pla				pla
.0181be	60		rts				rts
.0181bf					IF_Read:
.0181bf	5a		phy				phy 								; save current Y
.0181c0	a4 08		ldy $08				ldy 	IF_XPos 					; read character at current position
.0181c2	b7 04		lda [$04],y			lda 	[IF_Pos],y
.0181c4	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181c6	7a		ply				ply									; restore Y
.0181c7	60		rts				rts
.0181c8					IF_Write:
.0181c8	5a		phy				phy 								; save current Y
.0181c9	a4 08		ldy $08				ldy 	IF_XPos 					; write character at current position
.0181cb	97 04		sta [$04],y			sta 	[IF_Pos],y
.0181cd	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181cf	7a		ply				ply									; restore Y
.0181d0	60		rts				rts
.0181d1					IF_LeftOne:
.0181d1	c6 08		dec $08				dec 	IF_XPos
.0181d3	60		rts				rts
.0181d4					IF_CheckBreak:
.0181d4	af 00 80 0f	lda $0f8000			lda 	IF_PBreak					; non-zero if Ctrl+C pressed.
.0181d8	60		rts				rts
.0181d9					IF_GetKey:
.0181d9	af 10 80 0f	lda $0f8010			lda 	IF_PKeyboard				; read keyboard
.0181dd	f0 08		beq $0181e7			beq		_IFGK_NoKey 				; skip if zero,no key pressed
.0181df	48		pha				pha 								; key pressed, clear queue.
.0181e0	a9 00		lda #$00			lda 	#0
.0181e2	8f 10 80 0f	sta $0f8010			sta 	IF_PKeyboard
.0181e6	68		pla				pla
.0181e7					_IFGK_NoKey:
.0181e7	09 00		ora #$00			ora 	#0							; set Z flag appropriately.
.0181e9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.0181ea					TIM_Error:
.0181ea	20 29 80	jsr $018029			jsr 	IFT_UpLine 					; go up one line.
.0181ed	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.0181ef	80 02		bra $0181f3			bra 	TIM_ShowPrompt
.0181f1					TIM_NewCommand:
.0181f1	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.0181f3					TIM_ShowPrompt:
.0181f3	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.0181f6	20 ed 80	jsr $0180ed			jsr 	IFT_ReadLine	 			; get character, go to next line
.0181f9	20 4f 80	jsr $01804f			jsr 	IFT_NewLine					; go to next line.
.0181fc	86 10		stx $10				stx 	zTemp1 						; save line read address
.0181fe	84 11		sty $11				sty 	zTemp1+1
.018200	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.018202	b1 10		lda ($10),y			lda 	(zTemp1),y
.018204	c9 3f		cmp #$3f			cmp 	#"?"
.018206	f0 04		beq $01820c			beq 	TIM_SkipFirst
.018208	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.01820a	d0 01		bne $01820d			bne 	TIM_NotDot
.01820c					TIM_SkipFirst:
.01820c	c8		iny				iny
.01820d					TIM_NotDot:
.01820d	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.01820f	c9 52		cmp #$52			cmp 	#"R"						; show registers
.018211	f0 6b		beq $01827e			beq 	TIM_ShowRegisters
.018213	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.018215	f0 12		beq $018229			beq 	TIM_ShowMemory
.018217	c9 47		cmp #$47			cmp 	#"G"						; execute
.018219	f0 49		beq $018264			beq 	TIM_Execute
.01821b	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.01821d	f0 07		beq $018226			beq 	TIM_GoLoadMemory
.01821f	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.018221	d0 c7		bne $0181ea			bne 	TIM_Error
.018223	4c a2 83	jmp $0183a2			jmp 	TIM_UpdateRegisters
.018226					TIM_GoLoadMemory:
.018226	4c d2 83	jmp $0183d2			jmp 	TIM_LoadMemory
.018229					TIM_ShowMemory:
.018229	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.01822c	b0 bc		bcs $0181ea			bcs 	TIM_Error
.01822e	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.018230	85 12		sta $12				sta 	zTemp2
.018232	a5 15		lda $15				lda 	zTemp3+1
.018234	85 13		sta $13				sta 	zTemp2+1
.018236	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.018239	90 08		bcc $018243			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.01823b	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.01823d	85 14		sta $14				sta 	zTemp3
.01823f	a5 13		lda $13				lda 	zTemp2+1
.018241	85 15		sta $15				sta 	zTemp3+1
.018243					_TIMSM_Start:
.018243	20 f6 82	jsr $0182f6			jsr 	TIM_WriteLine 				; write one line of hex out
.018246	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.018248	18		clc				clc
.018249	69 10		adc #$10			adc 	#16
.01824b	85 12		sta $12				sta 	zTemp2
.01824d	90 02		bcc $018251			bcc 	_TIMSM_NoCarry
.01824f	e6 13		inc $13				inc 	zTemp2+1
.018251					_TIMSM_NoCarry:
.018251	20 d4 81	jsr $0181d4			jsr 	IF_CheckBreak 				; check CTL+C
.018254	d0 0b		bne $018261			bne 	_TIMSM_Ends 				; if pressed break out.
.018256	38		sec				sec 								; check past the end address in zTemp3
.018257	a5 14		lda $14				lda 	zTemp3
.018259	e5 12		sbc $12				sbc 	zTemp2
.01825b	a5 15		lda $15				lda 	zTemp3+1
.01825d	e5 13		sbc $13				sbc 	zTemp2+1
.01825f	10 e2		bpl $018243			bpl 	_TIMSM_Start
.018261					_TIMSM_Ends:
.018261	4c f1 81	jmp $0181f1			jmp 	TIM_NewCommand
.018264					TIM_Execute:
.018264	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; get the execute address
.018267	b0 81		bcs $0181ea			bcs 	TIM_Error 					; not legitimate
.018269	ae cc 03	ldx $03cc			ldx 	TIM_SP 						; set up SP
.01826c	9a		txs				txs
.01826d	ad c7 03	lda $03c7			lda 	TIM_SR 						; Status for PLP
.018270	48		pha				pha
.018271	ad c8 03	lda $03c8			lda 	TIM_A 						; restore AXYZ
.018274	ae c9 03	ldx $03c9			ldx 	TIM_X
.018277	ac ca 03	ldy $03ca			ldy 	TIM_Y
.01827a	28		plp				plp 								; and PS Byte.
.01827b	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.01827e					TIM_Start:
.01827e					TIM_ShowRegisters:
.01827e	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.018281	8d c6 03	sta $03c6			sta 	TIM_IRQ+1
.018284	ad ff ff	lda $ffff			lda 	$FFFF
.018287	8d c5 03	sta $03c5			sta 	TIM_IRQ
.01828a	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.01828c					_TIMSR_Text:
.01828c	bf bd 82 01	lda $0182bd,x			lda 	_TIMSR_Label,x
.018290	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018293	e8		inx				inx
.018294	e0 20		cpx #$20			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.018296	d0 f4		bne $01828c			bne 	_TIMSR_Text
.018298	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.01829a					_TIMSR_Skip:
.01829a	e8		inx				inx
.01829b					_TIMSR_LoopSpace:
.01829b	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.01829d	b0 04		bcs $0182a3			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.01829f	8a		txa				txa
.0182a0	4a		lsr a				lsr 	a
.0182a1	b0 05		bcs $0182a8			bcs 	_TIMSR_NoSpace
.0182a3					_TIMSR_Space:
.0182a3	a9 20		lda #$20			lda 	#" "
.0182a5	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182a8					_TIMSR_NoSpace:
.0182a8	bd c3 03	lda $03c3,x			lda 	TIM_PC,x 					; output hex value.
.0182ab	20 dd 82	jsr $0182dd			jsr 	TIM_WriteHex
.0182ae	e8		inx				inx
.0182af	e0 08		cpx #$08			cpx 	#TIM_Z-TIM_PC
.0182b1	f0 e7		beq $01829a			beq 	_TIMSR_Skip
.0182b3	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.0182b5	d0 e4		bne $01829b			bne 	_TimSR_LoopSpace
.0182b7	20 4f 80	jsr $01804f			jsr 	IFT_NewLine 				; new line
.0182ba	4c f1 81	jmp $0181f1			jmp	 	TIM_NewCommand 				; new command.
.0182bd					_TIMSR_Label:
>0182bd	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>0182c5	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>0182d5	52
>0182d6	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.0182dd					_TIMSR_LabelEnd:
.0182dd					TIM_WriteHex:
.0182dd	48		pha				pha 								; save A
.0182de	4a		lsr a				lsr 	a 							; shift MSB->LSB
.0182df	4a		lsr a				lsr 	a
.0182e0	4a		lsr a				lsr 	a
.0182e1	4a		lsr a				lsr 	a
.0182e2	20 e6 82	jsr $0182e6			jsr 	_TIMWH_Nibble 				; print MSB
.0182e5	68		pla				pla 								; restore and print LSB
.0182e6					_TIMWH_Nibble:
.0182e6	48		pha				pha
.0182e7	29 0f		and #$0f			and 	#15 						; mask out
.0182e9	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.0182eb	90 02		bcc $0182ef			bcc 	_TIMWHNoLetter
.0182ed	69 06		adc #$06			adc 	#6
.0182ef					_TIMWHNoLetter:
.0182ef	69 30		adc #$30			adc 	#48
.0182f1	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter 			; print it out.
.0182f4	68		pla				pla
.0182f5	60		rts				rts
.0182f6					TIM_WriteLine:
.0182f6	a9 2e		lda #$2e			lda 	#"." 						; prompt
.0182f8	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182fb	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.0182fd	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018300	a5 13		lda $13				lda 	zTemp2+1 					; write address
.018302	20 dd 82	jsr $0182dd			jsr 	TIM_WriteHex
.018305	a5 12		lda $12				lda 	zTemp2
.018307	20 dd 82	jsr $0182dd			jsr 	TIM_WriteHex
.01830a	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.01830c					_TIMWL_Loop:
.01830c	a9 20		lda #$20			lda 	#" "
.01830e	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018311	b1 12		lda ($12),y			lda 	(zTemp2),y
.018313	20 dd 82	jsr $0182dd			jsr 	TIM_WriteHex
.018316	c8		iny				iny
.018317	c0 10		cpy #$10			cpy 	#16
.018319	d0 f1		bne $01830c			bne 	_TIMWL_Loop
.01831b	4c 4f 80	jmp $01804f			jmp 	IFT_NewLine 				; new line and exit
.01831e					TIM_GetHex:
.01831e	c8		iny				iny
.01831f	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.018321	c9 20		cmp #$20			cmp 	#32
.018323	f0 f9		beq $01831e			beq 	TIM_GetHex
.018325	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.018327	f0 f5		beq $01831e			beq 	TIM_GetHex
.018329	20 52 83	jsr $018352			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.01832c	b0 23		bcs $018351			bcs 	_TIMGH_Exit					; if first bad then exit now.
.01832e	a9 00		lda #$00			lda 	#0 							; zero result
.018330	85 14		sta $14				sta 	zTemp3
.018332	85 15		sta $15				sta 	zTemp3+1
.018334					_TIM_GHLoop:
.018334	20 52 83	jsr $018352			jsr 	TIM_GetHexCharacter 		; get next character
.018337	b0 17		bcs $018350			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.018339	c8		iny				iny 								; skip over it.
.01833a	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.01833c	26 15		rol $15				rol 	zTemp3+1
.01833e	06 14		asl $14				asl 	zTemp3 						; now x 2
.018340	26 15		rol $15				rol 	zTemp3+1
.018342	06 14		asl $14				asl 	zTemp3						; now x 4
.018344	26 15		rol $15				rol 	zTemp3+1
.018346	06 14		asl $14				asl 	zTemp3 						; now x 8
.018348	26 15		rol $15				rol 	zTemp3+1
.01834a	05 14		ora $14				ora 	zTemp3 						; OR result in
.01834c	85 14		sta $14				sta 	zTemp3
.01834e	80 e4		bra $018334			bra 	_TIM_GHLoop 				; loop round again.
.018350					_TIMGH_Okay:
.018350	18		clc				clc
.018351					_TIMGH_Exit:
.018351	60		rts				rts
.018352					TIM_GetHexCharacter:
.018352	b1 10		lda ($10),y			lda 	(zTemp1),y
.018354	38		sec				sec
.018355	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.018357	90 0e		bcc $018367			bcc 	_TIM_GHCFail
.018359	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.01835b	90 0b		bcc $018368			bcc 	_TIM_GHCExit
.01835d	c9 11		cmp #$11			cmp 	#65-48						; < A
.01835f	90 06		bcc $018367			bcc		_TIM_GHCFail
.018361	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.018363	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.018365	90 01		bcc $018368			bcc		_TIM_GHCExit
.018367					_TIM_GHCFail:
.018367	38		sec				sec
.018368					_TIM_GHCExit:
.018368	60		rts				rts
.018369					TIM_BreakVector:
.018369	da		phx				phx									; save X/A on stack
.01836a	48		pha				pha
.01836b	ba		tsx				tsx 								; X points to S
.01836c	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.01836f	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.018371	d0 03		bne $018376			bne 	_TIMBreak					; if set, it's BRK
.018373	68		pla				pla 								; abandon routine.
.018374	fa		plx				plx
.018375	40		rti				rti
.018376					_TIMBreak:
.018376	68		pla				pla 								; save A X Y and maybe Z
.018377	8d c8 03	sta $03c8			sta 	TIM_A
.01837a	fa		plx				plx
.01837b	8e c9 03	stx $03c9			stx 	TIM_X
.01837e	8c ca 03	sty $03ca			sty 	TIM_Y
.018381	68		pla				pla 								; get Status Register
.018382	8d c7 03	sta $03c7			sta 	TIM_SR
.018385	68		pla				pla
.018386	8d c4 03	sta $03c4			sta 	TIM_PC+1 					; save calling address
.018389	68		pla				pla
.01838a	8d c3 03	sta $03c3			sta 	TIM_PC 						; high byte
.01838d	ad c4 03	lda $03c4			lda 	TIM_PC+1 					; dec PC to point right.
.018390	d0 03		bne $018395			bne 	_TIMDecrement 				; brk bumps it.
.018392	ce c3 03	dec $03c3			dec 	TIM_PC
.018395					_TIMDecrement:
.018395	ce c4 03	dec $03c4			dec 	TIM_PC+1
.018398	ba		tsx				tsx 								; and copy SP
.018399	8e cc 03	stx $03cc			stx 	TIM_SP
.01839c	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.01839e	9a		txs				txs
.01839f	4c 7e 82	jmp $01827e			jmp 	TIM_Start 					; and start up TIM monitor.
.0183a2					TIM_UpdateRegisters:
.0183a2	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; PC
.0183a5	b0 28		bcs $0183cf			bcs 	_TIMURFail
.0183a7	a5 14		lda $14				lda 	zTemp3
.0183a9	8d c4 03	sta $03c4			sta 	Tim_PC+1
.0183ac	a5 15		lda $15				lda 	zTemp3+1
.0183ae	8d c3 03	sta $03c3			sta 	Tim_PC
.0183b1	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; ignore IRQ
.0183b4	b0 19		bcs $0183cf			bcs 	_TIMURFail
.0183b6	a2 00		ldx #$00			ldx 	#0
.0183b8					_TIM_URLoop:
.0183b8	e0 04		cpx #$04			cpx 	#Tim_Z-Tim_SR
.0183ba	d0 01		bne $0183bd			bne 	_TIM_1
.0183bc	e8		inx				inx
.0183bd					_TIM_1:
.0183bd	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; registers
.0183c0	b0 0d		bcs $0183cf			bcs 	_TIMURFail
.0183c2	a5 14		lda $14				lda 	zTemp3
.0183c4	9d c7 03	sta $03c7,x			sta 	Tim_SR,x
.0183c7	e8		inx				inx
.0183c8	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.0183ca	d0 ec		bne $0183b8			bne 	_TIM_URLoop
.0183cc	4c f1 81	jmp $0181f1			jmp 	TIM_NewCommand
.0183cf					_TIMURFail:
.0183cf	4c ea 81	jmp $0181ea			jmp 	TIM_Error
.0183d2					TIM_LoadMemory:
.0183d2	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; target address => zTemp2
.0183d5	a5 14		lda $14				lda 	zTemp3
.0183d7	85 12		sta $12				sta 	zTemp2
.0183d9	a5 15		lda $15				lda 	zTemp3+1
.0183db	85 13		sta $13				sta 	zTemp2+1
.0183dd					_TIM_LMLoop:
.0183dd	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; next byte ?
.0183e0	b0 0e		bcs $0183f0			bcs 	_TIMLMDone 					; no more
.0183e2	a2 00		ldx #$00			ldx 	#0							; write out.
.0183e4	a5 14		lda $14				lda 	zTemp3
.0183e6	81 12		sta ($12,x)			sta 	(zTemp2,x)
.0183e8	e6 12		inc $12				inc 	zTemp2 						; bump address
.0183ea	d0 f1		bne $0183dd			bne 	_TIM_LMLoop
.0183ec	e6 13		inc $13				inc 	zTemp2+1
.0183ee	80 ed		bra $0183dd			bra 	_TIM_LMLoop
.0183f0					_TIMLMDone:
.0183f0	4c f1 81	jmp $0181f1			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/skip.asm

.0183f3					StructureSearchSingle:
.0183f3	a2 00		ldx #$00			ldx 	#0
.0183f5					StructureSearchDouble:
.0183f5	85 10		sta $10				sta 	zTemp1 						; save the target on zTemp1,zTemp1+1
.0183f7	86 11		stx $11				stx 	zTemp1+1
.0183f9	a9 00		lda #$00			lda 	#0 							; set the structure depth to zero (zTemp2)
.0183fb	85 12		sta $12				sta 	zTemp2
.0183fd	80 18		bra $018417			bra 	_SSWLoop 					; jump in, start scanning from here.
.0183ff					_SSWNextLine:
.0183ff	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018401	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.018403	18		clc				clc
.018404	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018406	85 16		sta $16				sta 	zCodePtr
.018408	90 02		bcc $01840c			bcc 	_SNLNoCarry
.01840a	e6 17		inc $17				inc 	zCodePtr+1
.01840c					_SNLNoCarry:
.01840c	a0 00		ldy #$00			ldy 	#0
.01840e	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018410	c9 00		cmp #$00			cmp 	#0					 		; if zero, fail.
.018412	f0 54		beq $018468			beq 	_SSWFail
.018414	c8		iny				iny
.018415	c8		iny				iny
.018416					_SSWNextSimple:
.018416	c8		iny				iny
.018417					_SSWLoop:
.018417	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018419	c9 00		cmp #$00			cmp 	#0 							; end of line ?
.01841b	f0 e2		beq $0183ff			beq 	_SSWNextLine 				; if so, then next line
.01841d	10 f7		bpl $018416			bpl 	_SSWNextSimple 				; needs to be a token, just skip char/number.
.01841f	a6 12		ldx $12				ldx 	zTemp2 						; check structure count
.018421	d0 08		bne $01842b			bne 	_SSWCheckUpDown 			; if it's non zero, then a match doesn't work.
.018423	c5 10		cmp $10				cmp 	zTemp1 						; found the right keyword, either choice.
.018425	f0 2d		beq $018454			beq 	_SSWFound 					; so exit.
.018427	c5 11		cmp $11				cmp 	zTemp1+1
.018429	f0 29		beq $018454			beq 	_SSWFound
.01842b					_SSWCheckUpDown:
.01842b	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus 			; if < keyword +
.01842d	90 10		bcc $01843f			bcc 	_SSWNext
.01842f	c9 93		cmp #$93			cmp 	#firstKeywordMinus 			; if < keyword - then as keyword +
.018431	90 08		bcc $01843b			bcc 	_SSWPlus
.018433	c9 98		cmp #$98			cmp 	#firstUnaryFunction			; if < first unary down as keyword -
.018435	b0 08		bcs $01843f			bcs 	_SSWNext
.018437	c6 12		dec $12				dec 	zTemp2 						; reduce structure count.
.018439	c6 12		dec $12				dec 	zTemp2
.01843b					_SSWPlus:
.01843b	e6 12		inc $12				inc 	zTemp2
.01843d	30 16		bmi $018455			bmi 	_SSWUnder					; error if driven -ve
.01843f					_SSWNext:
.01843f	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018441	c8		iny				iny 								; skip
.018442	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018444	90 0c		bcc $018452			bcc 	_SEDone 					; so just skip over it.
.018446	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018448	90 07		bcc $018451			bcc 	_SEDouble
.01844a	98		tya				tya 								; this is Y + 1
.01844b	18		clc				clc
.01844c	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.01844e	a8		tay				tay 								; back in Y.
.01844f	88		dey				dey 								; fix up, one for the +1, one for the iny
.018450	88		dey				dey
.018451					_SEDouble:
.018451	c8		iny				iny
.018452					_SEDone:
.018452	80 c3		bra $018417			bra 	_SSWLoop
.018454					_SSWFound:
.018454	60		rts				rts
.018455					_SSWUnder:
.018455	20 79 85	jsr $018579			jsr ERR_Handler
>018458	53 74 72 75 63 74 75 72			.text "Structure order",0
>018460	65 20 6f 72 64 65 72 00
.018468					_SSWFail:
.018468	20 79 85	jsr $018579			jsr ERR_Handler
>01846b	43 61 6e 27 74 20 66 69			.text "Can't find structure",0
>018473	6e 64 20 73 74 72 75 63 74 75 72 65 00
.018480					SkipEndOfCommand:
.018480	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018482	c9 00		cmp #$00			cmp 	#0 							; if zero, end of line, so exit
.018484	f0 19		beq $01849f			beq 	_SOCExit
.018486	c9 c0		cmp #$c0			cmp 	#token_Colon 				; if colon, end of command
.018488	f0 15		beq $01849f			beq 	_SOCExit
.01848a	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.01848c	c8		iny				iny 								; skip
.01848d	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.01848f	90 0c		bcc $01849d			bcc 	_SEDone 					; so just skip over it.
.018491	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018493	90 07		bcc $01849c			bcc 	_SEDouble
.018495	98		tya				tya 								; this is Y + 1
.018496	18		clc				clc
.018497	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018499	a8		tay				tay 								; back in Y.
.01849a	88		dey				dey 								; fix up, one for the +1, one for the iny
.01849b	88		dey				dey
.01849c					_SEDouble:
.01849c	c8		iny				iny
.01849d					_SEDone:
.01849d	80 e1		bra $018480			bra 	SkipEndOfCommand
.01849f					_SOCExit:
.01849f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stack.asm

.0184a0					StackReset:
.0184a0	48		pha				pha
.0184a1	5a		phy				phy
.0184a2	a9 00		lda #$00			lda 	#(BasicStack & $FF) 		; reset pointer
.0184a4	85 26		sta $26				sta 	zBasicSP
.0184a6	a9 04		lda #$04			lda 	#(BasicStack >> 8)
.0184a8	85 27		sta $27				sta 	zBasicSP+1
.0184aa	a0 00		ldy #$00			ldy 	#0 							; reset stack top to $00 which cannot
.0184ac	98		tya				tya 								; be a legal token.
.0184ad	91 26		sta ($26),y			sta 	(zBasicSP),y
.0184af	7a		ply				ply
.0184b0	68		pla				pla
.0184b1	60		rts				rts
.0184b2					StackPushFrame:
.0184b2	48		pha				pha
.0184b3	5a		phy				phy
.0184b4	1a		inc a				inc 	a 							; one extra byte in frame, for the marker.
.0184b5	48		pha				pha 								; save it.
.0184b6	29 0f		and #$0f			and 	#$0F 						; lower 4 bits
.0184b8	18		clc				clc 								; add to Basic Stack
.0184b9	65 26		adc $26				adc 	zBasicSP
.0184bb	85 26		sta $26				sta 	zBasicSP
.0184bd	90 02		bcc $0184c1			bcc 	_SPFNoBump
.0184bf	e6 27		inc $27				inc 	zBasicSP+1
.0184c1					_SPFNoBump:
.0184c1	a0 00		ldy #$00			ldy 	#0
.0184c3	68		pla				pla
.0184c4	91 26		sta ($26),y			sta 	(zBasicSP),y
.0184c6	7a		ply				ply
.0184c7	68		pla				pla
.0184c8	60		rts				rts
.0184c9					StackPopFrame:
.0184c9	48		pha				pha
.0184ca	5a		phy				phy
.0184cb	a0 00		ldy #$00			ldy 	#0 							; compare with top of stack using EOR
.0184cd	51 26		eor ($26),y			eor 	(zBasicSP),y
.0184cf	29 f0		and #$f0			and 	#$F0 						; top 4 bits zero, match
.0184d1	d0 12		bne $0184e5			bne 	SPFError 					; mixed structures
.0184d3	b1 26		lda ($26),y			lda 	(zBasicSP),y 				; get size from byte
.0184d5	29 0f		and #$0f			and 	#$0F
.0184d7	49 ff		eor #$ff			eor 	#$FF						; 2's complement
.0184d9	38		sec				sec
.0184da	65 26		adc $26				adc 	zBasicSP
.0184dc	85 26		sta $26				sta 	zBasicSP
.0184de	b0 02		bcs $0184e2			bcs 	_SPFNoBump
.0184e0	c6 27		dec $27				dec 	zBasicSP+1
.0184e2					_SPFNoBump:
.0184e2	7a		ply				ply
.0184e3	68		pla				pla
.0184e4	60		rts				rts
.0184e5					SPFError:
.0184e5	20 79 85	jsr $018579			jsr ERR_Handler
>0184e8	4d 69 78 65 64 20 53 74			.text "Mixed Structures",0
>0184f0	72 75 63 74 75 72 65 73 00
.0184f9					StackSavePosition:
.0184f9	98		tya				tya
.0184fa	5a		phy				phy
.0184fb	a0 05		ldy #$05			ldy 	#5
.0184fd	91 26		sta ($26),y			sta 	(zBasicSP),y
.0184ff	a0 01		ldy #$01			ldy 	#1
.018501	a5 16		lda $16				lda 	zCodePtr+0 					; 4 bytes, could reduce this for 65816/6502
.018503	91 26		sta ($26),y			sta 	(zBasicSP),y
.018505	c8		iny				iny
.018506	a5 17		lda $17				lda 	zCodePtr+1
.018508	91 26		sta ($26),y			sta 	(zBasicSP),y
.01850a	c8		iny				iny
.01850b	a5 18		lda $18				lda 	zCodePtr+2
.01850d	91 26		sta ($26),y			sta 	(zBasicSP),y
.01850f	c8		iny				iny
.018510	a5 19		lda $19				lda 	zCodePtr+3
.018512	91 26		sta ($26),y			sta 	(zBasicSP),y
.018514	7a		ply				ply
.018515	60		rts				rts
.018516					StackRestorePosition:
.018516	5a		phy				phy
.018517	a0 01		ldy #$01			ldy 	#1 							; copy 4 bytes that are the pointer
.018519	b1 26		lda ($26),y			lda 	(zBasicSP),y
.01851b	85 16		sta $16				sta 	zCodePtr+0
.01851d	c8		iny				iny
.01851e	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018520	85 17		sta $17				sta 	zCodePtr+1
.018522	c8		iny				iny
.018523	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018525	85 18		sta $18				sta 	zCodePtr+2
.018527	c8		iny				iny
.018528	b1 26		lda ($26),y			lda 	(zBasicSP),y
.01852a	85 19		sta $19				sta 	zCodePtr+3
.01852c	c8		iny				iny
.01852d	b1 26		lda ($26),y			lda 	(zBasicSP),y 				; offset
.01852f	7a		ply				ply 								; restore Y
.018530	a8		tay				tay
.018531	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/vectors.asm

.018532					VIOCharPrint:
.018532	4c 35 80	jmp $018035			jmp 	IFT_PrintCharacter
.018535					VIOCharGet:
.018535	20 d9 81	jsr $0181d9			jsr 	IF_GetKey
.018538	c9 00		cmp #$00			cmp 	#0
.01853a	f0 02		beq $01853e			beq 	_VCG0
.01853c	38		sec				sec
.01853d	60		rts				rts
.01853e	18		clc		_VCG0:	clc
.01853f	60		rts				rts
.018540					VIOCheckBreak:
.018540	4c d4 81	jmp $0181d4			jmp 	IF_CheckBreak
.018543					VIOCharGetPosition:
.018543	ad 00 05	lda $0500			lda 	IFT_XCursor
.018546	60		rts				rts
.018547					VIOReadLine:
.018547	4c ed 80	jmp $0180ed			jmp 	IFT_ReadLine

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/errors.asm

.01854a					SyntaxError:
.01854a	20 79 85	jsr $018579			jsr 	ERR_Handler
>01854d	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>018555	72 72 6f 72 00
.01855a					TypeError:
.01855a	20 79 85	jsr $018579			jsr 	ERR_Handler
>01855d	57 72 6f 6e 67 20 74 79				.text 	"Wrong type",0
>018565	70 65 00
.018568					BadParamError:
.018568	20 79 85	jsr $018579			jsr 	ERR_Handler
>01856b	42 61 64 20 50 61 72 61				.text 	"Bad Parameter",0
>018573	6d 65 74 65 72 00
.018579					ERR_Handler:
.018579	a0 00		ldy #$00			ldy 	#0
.01857b	c8		iny				iny
.01857c	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01857e	85 80		sta $80				sta 	XS_Mantissa
.018580	c8		iny				iny
.018581	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018583	85 81		sta $81				sta 	XS_Mantissa+1
.018585	fa		plx				plx 								; address in XY
.018586	7a		ply				ply
.018587	e8		inx				inx 								; bump, because of RTS/JSR address -1
.018588	d0 01		bne $01858b			bne 	_EHNoSkip
.01858a	c8		iny				iny
.01858b					_EHNoSkip:
.01858b	20 aa 85	jsr $0185aa			jsr 	PrintROMMessage 			; print message from ROM.
.01858e	a5 80		lda $80				lda 	XS_Mantissa					; line number = 0
.018590	05 81		ora $81				ora 	XS_Mantissa+1
.018592	f0 0c		beq $0185a0			beq 	_EHNoLine
.018594	a2 a5		ldx #$a5			ldx 	#_EHAt & $FF 				; print " at "
.018596	a0 85		ldy #$85			ldy 	#(_EHAt >> 8) & $FF
.018598	20 aa 85	jsr $0185aa			jsr 	PrintROMMessage
.01859b	a2 00		ldx #$00			ldx 	#0 							; Print line number
.01859d	20 bf 85	jsr $0185bf			jsr 	Print16BitInteger
.0185a0					_EHNoLine:
.0185a0	80 fe		bra $0185a0			bra 	_EHNoLine
.0185a2	4c 32 88	jmp $018832			jmp 	WarmStart 					; normally warm start.
>0185a5	20 61 74 20 00			_EHAt:	.text 	" at ",0
.0185aa					PrintROMMessage:
.0185aa	86 1a		stx $1a				stx 	zLTemp1 					; save addres
.0185ac	84 1b		sty $1b				sty 	zLTemp1+1
.0185ae	4b		phk				phk 								; get current code page
.0185af	68		pla				pla
.0185b0	85 1c		sta $1c				sta 	ZLTemp1+2 					; put into the 3rd byte so we can use
.0185b2	a0 00		ldy #$00			ldy 	#0
.0185b4					_PRMLoop:
.0185b4	b7 1a		lda [$1a],y			lda 	[zLTemp1],y 				; 65816
.0185b6	f0 06		beq $0185be			beq		_PRMExit 					; character $00 => exit
.0185b8	c8		iny				iny  								; bump Y and print it.
.0185b9	20 32 85	jsr $018532			jsr 	VIOCharPrint
.0185bc	80 f6		bra $0185b4			bra 	_PRMLoop
.0185be					_PRMExit:
.0185be	60		rts				rts
.0185bf					Print16BitInteger:
.0185bf	a9 00		lda #$00			lda 	#0 							; make 32 bit
.0185c1	85 82		sta $82				sta 	XS_Mantissa+2
.0185c3	85 83		sta $83				sta 	XS_Mantissa+3
.0185c5					Print32BitInteger:
.0185c5	a9 00		lda #$00			lda 	#0
.0185c7	8d 14 03	sta $0314			sta 	NumBufX 					; reset the conversion pointer
.0185ca	aa		tax				tax 								; convert bottom level.
.0185cb	20 78 9e	jsr $019e78			jsr 	INTToString 				; make string from integer in Num_Buffer
.0185ce	a2 00		ldx #$00			ldx 	#0 							; print buffer contents
.0185d0	bd 15 03	lda $0315,x	_P1Loop:lda 	Num_Buffer,x
.0185d3	f0 06		beq $0185db			beq 	_P1Exit
.0185d5	20 32 85	jsr $018532			jsr 	VIOCharPrint
.0185d8	e8		inx				inx
.0185d9	80 f5		bra $0185d0			bra 	_P1Loop
.0185db	8a		txa		_P1Exit:txa 								; return chars printed.
.0185dc	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm


;******  Processing file: modules/basic/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b6					lastUnaryFunction = $b6
.0185dd					VectorTable:
>0185dd	be 92					.word BinaryOp_And         & $FFFF ; $80 and
>0185df	da 92					.word BinaryOp_Or          & $FFFF ; $81 or
>0185e1	f6 92					.word BinaryOp_Xor         & $FFFF ; $82 xor
>0185e3	f6 92					.word BinaryOp_Eor         & $FFFF ; $83 eor
>0185e5	2d 93					.word Binary_Equal         & $FFFF ; $84 =
>0185e7	36 93					.word Binary_NotEqual      & $FFFF ; $85 <>
>0185e9	3f 93					.word Binary_Less          & $FFFF ; $86 <
>0185eb	48 93					.word Binary_LessEqual     & $FFFF ; $87 <=
>0185ed	5a 93					.word Binary_Greater       & $FFFF ; $88 >
>0185ef	51 93					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>0185f1	f2 93					.word BinaryOp_Add         & $FFFF ; $8a +
>0185f3	0e 94					.word BinaryOp_Subtract    & $FFFF ; $8b -
>0185f5	1f 94					.word BinaryOp_Multiply    & $FFFF ; $8c *
>0185f7	30 94					.word BinaryOp_Divide      & $FFFF ; $8d /
>0185f9	9b 86					.word NotImplemented       & $FFFF ; $8e ^
>0185fb	4c 8c					.word Command_IF           & $FFFF ; $8f if
>0185fd	ba 90					.word Command_WHILE        & $FFFF ; $90 while
>0185ff	e2 90					.word Command_REPEAT       & $FFFF ; $91 repeat
>018601	94 89					.word Command_FOR          & $FFFF ; $92 for
>018603	9b 86					.word NotImplemented       & $FFFF ; $93 then
>018605	a9 8c					.word Command_ENDIF        & $FFFF ; $94 endif
>018607	d7 90					.word Command_WEND         & $FFFF ; $95 wend
>018609	eb 90					.word Command_UNTIL        & $FFFF ; $96 until
>01860b	11 8a					.word Command_NEXT         & $FFFF ; $97 next
>01860d	9b 86					.word NotImplemented       & $FFFF ; $98 not
>01860f	9b 86					.word NotImplemented       & $FFFF ; $99 fn(
>018611	35 95					.word Unary_Abs            & $FFFF ; $9a abs(
>018613	83 96					.word Unary_Asc            & $FFFF ; $9b asc(
>018615	a4 a5					.word Unary_Int            & $FFFF ; $9c int(
>018617	4f 95					.word Unary_Peek           & $FFFF ; $9d peek(
>018619	25 a5					.word Unary_Rnd            & $FFFF ; $9e rnd(
>01861b	c2 95					.word Unary_Usr            & $FFFF ; $9f usr(
>01861d	c2 96					.word Unary_Left           & $FFFF ; $a0 left$(
>01861f	d7 96					.word Unary_Right          & $FFFF ; $a1 right$(
>018621	a9 96					.word Unary_Mid            & $FFFF ; $a2 mid$(
>018623	22 98					.word Unary_Spc            & $FFFF ; $a3 spc(
>018625	51 96					.word Unary_Str            & $FFFF ; $a4 str$(
>018627	e3 95					.word Unary_Val            & $FFFF ; $a5 val(
>018629	9a 96					.word Unary_Len            & $FFFF ; $a6 len(
>01862b	4f 97					.word Unary_Hex            & $FFFF ; $a7 hex$(
>01862d	9b 86					.word NotImplemented       & $FFFF ; $a8 sin(
>01862f	9b 86					.word NotImplemented       & $FFFF ; $a9 cos(
>018631	9b 86					.word NotImplemented       & $FFFF ; $aa tan(
>018633	9b 86					.word NotImplemented       & $FFFF ; $ab atn(
>018635	9b 86					.word NotImplemented       & $FFFF ; $ac exp(
>018637	9b 86					.word NotImplemented       & $FFFF ; $ad log(
>018639	9b 86					.word NotImplemented       & $FFFF ; $ae sqr(
>01863b	a5 97					.word Unary_Dec            & $FFFF ; $af dec(
>01863d	53 95					.word Unary_Deek           & $FFFF ; $b0 deek(
>01863f	57 95					.word Unary_Leek           & $FFFF ; $b1 leek(
>018641	8f 95					.word Unary_Mod            & $FFFF ; $b2 mod(
>018643	ef 94					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>018645	04 98					.word Unary_Chr            & $FFFF ; $b4 chr$(
>018647	83 95					.word Unary_Pos            & $FFFF ; $b5 pos(
>018649	45 98					.word Unary_Tab            & $FFFF ; $b6 tab(
>01864b	9b 86					.word NotImplemented       & $FFFF ; $b7 $
>01864d	9b 86					.word NotImplemented       & $FFFF ; $b8 $(
>01864f	9b 86					.word NotImplemented       & $FFFF ; $b9 #
>018651	9b 86					.word NotImplemented       & $FFFF ; $ba #(
>018653	9b 86					.word NotImplemented       & $FFFF ; $bb %
>018655	9b 86					.word NotImplemented       & $FFFF ; $bc %(
>018657	9b 86					.word NotImplemented       & $FFFF ; $bd (
>018659	9b 86					.word NotImplemented       & $FFFF ; $be )
>01865b	9b 86					.word NotImplemented       & $FFFF ; $bf ,
>01865d	93 89					.word Command_COLON        & $FFFF ; $c0 :
>01865f	9b 86					.word NotImplemented       & $FFFF ; $c1 ;
>018661	9b 86					.word NotImplemented       & $FFFF ; $c2 def
>018663	9b 90					.word Command_CLR          & $FFFF ; $c3 clr
>018665	b2 90					.word Command_STOP         & $FFFF ; $c4 stop
>018667	ea 8a					.word Command_DATA         & $FFFF ; $c5 data
>018669	c4 8a					.word Command_READ         & $FFFF ; $c6 read
>01866b	3f 88					.word Command_DIM          & $FFFF ; $c7 dim
>01866d	9b 86					.word NotImplemented       & $FFFF ; $c8 to
>01866f	9b 86					.word NotImplemented       & $FFFF ; $c9 step
>018671	e1 8f					.word Command_GOSUB        & $FFFF ; $ca gosub
>018673	f1 8f					.word Command_RETURN       & $FFFF ; $cb return
>018675	d9 8f					.word Command_GOTO         & $FFFF ; $cc goto
>018677	48 8c					.word Command_END          & $FFFF ; $cd end
>018679	0d 8c					.word Command_INPUT        & $FFFF ; $ce input
>01867b	88 8b					.word Command_LET          & $FFFF ; $cf let
>01867d	af 8c					.word Command_LIST         & $FFFF ; $d0 list
>01867f	82 8f					.word Command_NEW          & $FFFF ; $d1 new
>018681	9e 8f					.word Command_OLD          & $FFFF ; $d2 old
>018683	fa 8f					.word Command_ON           & $FFFF ; $d3 on
>018685	ed 8a					.word Command_RESTORE      & $FFFF ; $d4 restore
>018687	51 8f					.word Command_POKE         & $FFFF ; $d5 poke
>018689	a3 8e					.word Command_PRINT        & $FFFF ; $d6 print
>01868b	05 89					.word Command_RUN          & $FFFF ; $d7 run
>01868d	c7 88					.word Command_WAIT         & $FFFF ; $d8 wait
>01868f	f3 8b					.word Command_SYS          & $FFFF ; $d9 sys
>018691	55 8f					.word Command_DOKE         & $FFFF ; $da doke
>018693	59 8f					.word Command_LOKE         & $FFFF ; $db loke
>018695	39 8f					.word Command_ASSERT       & $FFFF ; $dc assert
>018697	a9 8b					.word Command_GET          & $FFFF ; $dd get
>018699	a3 8c					.word Command_ELSE         & $FFFF ; $de else
.01869b					NotImplemented:
.01869b	20 79 85	jsr $018579			jsr ERR_Handler
>01869e	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>0186a6	65 6d 65 6e 74 65 64 00
.0186ae					BinaryPrecedence:
>0186ae	01					.byte 1    ; $80 and
>0186af	01					.byte 1    ; $81 or
>0186b0	01					.byte 1    ; $82 xor
>0186b1	01					.byte 1    ; $83 eor
>0186b2	02					.byte 2    ; $84 =
>0186b3	02					.byte 2    ; $85 <>
>0186b4	02					.byte 2    ; $86 <
>0186b5	02					.byte 2    ; $87 <=
>0186b6	02					.byte 2    ; $88 >
>0186b7	02					.byte 2    ; $89 >=
>0186b8	03					.byte 3    ; $8a +
>0186b9	03					.byte 3    ; $8b -
>0186ba	04					.byte 4    ; $8c *
>0186bb	04					.byte 4    ; $8d /
>0186bc	05					.byte 5    ; $8e ^
.0186bd					KeywordText:
>0186bd	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>0186c0	4f d2					.byte $4f,$d2                          ; $81 or
>0186c2	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>0186c5	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>0186c8	bd					.byte $bd                              ; $84 =
>0186c9	3c be					.byte $3c,$be                          ; $85 <>
>0186cb	bc					.byte $bc                              ; $86 <
>0186cc	3c bd					.byte $3c,$bd                          ; $87 <=
>0186ce	be					.byte $be                              ; $88 >
>0186cf	3e bd					.byte $3e,$bd                          ; $89 >=
>0186d1	ab					.byte $ab                              ; $8a +
>0186d2	ad					.byte $ad                              ; $8b -
>0186d3	aa					.byte $aa                              ; $8c *
>0186d4	af					.byte $af                              ; $8d /
>0186d5	de					.byte $de                              ; $8e ^
>0186d6	49 c6					.byte $49,$c6                          ; $8f if
>0186d8	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>0186dd	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>0186e3	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>0186e6	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>0186ea	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>0186ef	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>0186f3	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>0186f8	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>0186fc	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>0186ff	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>018702	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>018706	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>01870a	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>01870e	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>018713	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>018717	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>01871b	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>018721	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>018728	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>01872d	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>018731	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>018736	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>01873a	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>01873e	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>018743	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>018747	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>01874b	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>01874f	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>018753	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>018757	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>01875b	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>01875f	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>018763	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>018768	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>01876d	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>018771	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>018775	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>01877a	50 4f 53 a8				.byte $50,$4f,$53,$a8                  ; $b5 pos(
>01877e	54 41 42 a8				.byte $54,$41,$42,$a8                  ; $b6 tab(
>018782	a4					.byte $a4                              ; $b7 $
>018783	24 a8					.byte $24,$a8                          ; $b8 $(
>018785	a3					.byte $a3                              ; $b9 #
>018786	23 a8					.byte $23,$a8                          ; $ba #(
>018788	a5					.byte $a5                              ; $bb %
>018789	25 a8					.byte $25,$a8                          ; $bc %(
>01878b	a8					.byte $a8                              ; $bd (
>01878c	a9					.byte $a9                              ; $be )
>01878d	ac					.byte $ac                              ; $bf ,
>01878e	ba					.byte $ba                              ; $c0 :
>01878f	bb					.byte $bb                              ; $c1 ;
>018790	44 45 c6				.byte $44,$45,$c6                      ; $c2 def
>018793	43 4c d2				.byte $43,$4c,$d2                      ; $c3 clr
>018796	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $c4 stop
>01879a	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c5 data
>01879e	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c6 read
>0187a2	44 49 cd				.byte $44,$49,$cd                      ; $c7 dim
>0187a5	54 cf					.byte $54,$cf                          ; $c8 to
>0187a7	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c9 step
>0187ab	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $ca gosub
>0187b0	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $cb return
>0187b6	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $cc goto
>0187ba	45 4e c4				.byte $45,$4e,$c4                      ; $cd end
>0187bd	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $ce input
>0187c2	4c 45 d4				.byte $4c,$45,$d4                      ; $cf let
>0187c5	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $d0 list
>0187c9	4e 45 d7				.byte $4e,$45,$d7                      ; $d1 new
>0187cc	4f 4c c4				.byte $4f,$4c,$c4                      ; $d2 old
>0187cf	4f ce					.byte $4f,$ce                          ; $d3 on
>0187d1	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d4 restore
>0187d8	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d5 poke
>0187dc	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d6 print
>0187e1	52 55 ce				.byte $52,$55,$ce                      ; $d7 run
>0187e4	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d8 wait
>0187e8	53 59 d3				.byte $53,$59,$d3                      ; $d9 sys
>0187eb	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $da doke
>0187ef	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $db loke
>0187f3	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $dc assert
>0187f9	47 45 d4				.byte $47,$45,$d4                      ; $dd get
>0187fc	45 4c 53 c5				.byte $45,$4c,$53,$c5                  ; $de else
>018800	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_pos = $b5
=$b6					token_tab = $b6
=$b7					token_dollar = $b7
=$b8					token_dollarlparen = $b8
=$b9					token_hash = $b9
=$ba					token_hashlparen = $ba
=$bb					token_percent = $bb
=$bc					token_percentlparen = $bc
=$bd					token_lparen = $bd
=$be					token_rparen = $be
=$bf					token_comma = $bf
=$c0					token_colon = $c0
=$c1					token_semicolon = $c1
=$c2					token_def = $c2
=$c3					token_clr = $c3
=$c4					token_stop = $c4
=$c5					token_data = $c5
=$c6					token_read = $c6
=$c7					token_dim = $c7
=$c8					token_to = $c8
=$c9					token_step = $c9
=$ca					token_gosub = $ca
=$cb					token_return = $cb
=$cc					token_goto = $cc
=$cd					token_end = $cd
=$ce					token_input = $ce
=$cf					token_let = $cf
=$d0					token_list = $d0
=$d1					token_new = $d1
=$d2					token_old = $d2
=$d3					token_on = $d3
=$d4					token_restore = $d4
=$d5					token_poke = $d5
=$d6					token_print = $d6
=$d7					token_run = $d7
=$d8					token_wait = $d8
=$d9					token_sys = $d9
=$da					token_doke = $da
=$db					token_loke = $db
=$dc					token_assert = $dc
=$dd					token_get = $dd
=$de					token_else = $de

;******  Return to file: modules/basic/core.asm

.018801					BASIC_Start:
.018801	20 9b 81	jsr $01819b			jsr 	IF_Reset 					; set up and clear screen.
.018804	20 00 80	jsr $018000			jsr 	IFT_ClearScreen
.018807	a9 5c		lda #$5c			lda 	#$5C 						; JMP Long opcode
.018809	8d 10 03	sta $0310			sta 	LocalVector
.01880c	8d 0c 03	sta $030c			sta 	UserVector
.01880f	a9 d1		lda #$d1			lda 	#USRDefault & $FF 			; reset USR vector
.018811	8d 0d 03	sta $030d			sta 	UserVector+1
.018814	a9 95		lda #$95			lda 	#(USRDefault >> 8) & $FF
.018816	8d 0e 03	sta $030e			sta 	UserVector+2
.018819	a9 01		lda #$01			lda 	#(USRDefault >> 16) & $FF
.01881b	8d 0f 03	sta $030f			sta 	UserVector+3
.01881e	20 8c 98	jsr $01988c			jsr 	UpdateProgramEnd 			; update the program end.
.018821	20 9b 90	jsr $01909b			jsr 	ResetRunStatus 				; clear everything (CLR command)
.018824	c2 30		rep #$30			rep 	#$30
.018826	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.018829	1b		tcs				tcs
.01882a	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.01882d	e2 30		sep #$30			sep 	#$30
.01882f	4c 05 89	jmp $018905			jmp 	COMMAND_Run
.018832					WarmStart:
.018832	c2 30		rep #$30			rep 	#$30
.018834	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.018837	1b		tcs				tcs
.018838	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.01883b	e2 30		sep #$30			sep 	#$30
.01883d	80 f3		bra $018832			bra 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/dim.asm

.01883f					Command_DIM:
.01883f	98		tya				tya
.018840	48		pha				pha 								; push on stack.
.018841	20 01 9a	jsr $019a01			jsr 	VariableExtract 			; get the identifier
.018844	ad 95 03	lda $0395			lda 	Var_Type 					; check it is an array
.018847	29 01		and #$01			and 	#1
.018849	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.01884b	d0 6c		bne $0188b9			bne 	_CDIError
.01884d	a9 00		lda #$00			lda 	#0 							; reset the DIM index. The dimensions are
.01884f	8d b9 03	sta $03b9			sta 	UsrArrayIdx 				; built up here and copied in case we autodim
.018852					_CDIGetDimension:
.018852	ad b9 03	lda $03b9			lda 	UsrArrayIdx 				; done too many ?
.018855	c9 06		cmp #$06			cmp 	#ArrayMaxDim*2
.018857	f0 60		beq $0188b9			beq 	_CDIError
.018859	20 9f 92	jsr $01929f			jsr 	EvaluateInteger 			; evaluate an index size
.01885c	a5 81		lda $81				lda 	XS_Mantissa+1 				; check in range 0-7FFF
.01885e	29 80		and #$80			and 	#$80
.018860	05 82		ora $82				ora 	XS_Mantissa+2
.018862	05 83		ora $83				ora 	XS_Mantissa+3
.018864	d0 53		bne $0188b9			bne 	_CDIError
.018866	ae b9 03	ldx $03b9			ldx 	UsrArrayIdx 				; copy into the array table.
.018869	18		clc				clc 								; add 1 - max index => size.
.01886a	a5 80		lda $80				lda 	XS_Mantissa+0
.01886c	69 01		adc #$01			adc 	#1
.01886e	9d b1 03	sta $03b1,x			sta 	UsrArrayDef+0,x
.018871	a5 81		lda $81				lda 	XS_Mantissa+1
.018873	69 00		adc #$00			adc 	#0
.018875	9d b2 03	sta $03b2,x			sta 	UsrArrayDef+1,x
.018878	30 3f		bmi $0188b9			bmi 	_CDIError 					; could be dim a(32767)
.01887a	e8		inx				inx 								; bump index.
.01887b	e8		inx				inx
.01887c	8e b9 03	stx $03b9			stx 	UsrArrayIdx
.01887f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018881	c8		iny				iny
.018882	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another dimension
.018884	f0 cc		beq $018852			beq 	_CDIGetDimension
.018886	88		dey				dey
.018887	20 e8 98	jsr $0198e8			jsr 	CheckNextRParen 			; closing ) present ?
.01888a	ae b9 03	ldx $03b9			ldx 	UsrArrayIdx 				; copy USR array to default
.01888d	a9 ff		lda #$ff			lda 	#$FF 						; put end marker in ArrayDef
.01888f	9d aa 03	sta $03aa,x			sta 	ArrayDef+1,x
.018892					_CDICopy:
.018892	bd b1 03	lda $03b1,x			lda 	UsrArrayDef,x
.018895	9d a9 03	sta $03a9,x			sta 	ArrayDef,x
.018898	ca		dex				dex
.018899	10 f7		bpl $018892			bpl 	_CDICopy
.01889b	68		pla				pla									; position of array identifier
.01889c	85 10		sta $10				sta 	zTemp1
.01889e	98		tya				tya
.01889f	48		pha				pha
.0188a0	a5 10		lda $10				lda 	zTemp1 						; point to identifier
.0188a2	a8		tay				tay
.0188a3	20 01 9a	jsr $019a01			jsr 	VariableExtract 			; get the identifier
.0188a6	20 9a 9c	jsr $019c9a			jsr 	VariableLocate 				; check if it exists already.
.0188a9	b0 0e		bcs $0188b9			bcs 	_CDIError
.0188ab	20 8d 9a	jsr $019a8d			jsr 	VariableCreate 				; create it using the current ArrayDef
.0188ae	68		pla				pla 								; restore code position
.0188af	a8		tay				tay
.0188b0	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0188b2	c8		iny				iny
.0188b3	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another DIM
.0188b5	f0 88		beq $01883f			beq 	Command_DIM
.0188b7	88		dey				dey
.0188b8	60		rts				rts
.0188b9					_CDIError:
.0188b9	20 79 85	jsr $018579			jsr ERR_Handler
>0188bc	42 61 64 20 44 49 4d 00			.text "Bad DIM",0
.0188c4					_CDISyntax:
.0188c4	4c 4a 85	jmp $01854a			jmp 	SyntaxError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/wait.asm

.0188c7					Command_WAIT:
.0188c7	20 9f 92	jsr $01929f			jsr		EvaluateInteger 			; address
.0188ca	a2 06		ldx #$06			ldx 	#XS_Size 					; and mask.
.0188cc	20 f0 98	jsr $0198f0			jsr 	CheckNextComma
.0188cf	20 a1 92	jsr $0192a1			jsr 	EvaluateIntegerX
.0188d2	a9 00		lda #$00			lda 	#0							; set default xor.
.0188d4	85 8c		sta $8c				sta 	XS_Mantissa+XS_Size*2
.0188d6	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0188d8	c9 bf		cmp #$bf			cmp 	#token_Comma 				; no use the default
.0188da	d0 06		bne $0188e2			bne 	_CWAXorDefault
.0188dc	c8		iny				iny
.0188dd	a2 0c		ldx #$0c			ldx 	#XS_Size*2
.0188df	20 a1 92	jsr $0192a1			jsr 	EvaluateIntegerX
.0188e2					_CWAXorDefault:
.0188e2	a5 80		lda $80				lda 	XS_Mantissa 				; copy 24 bits of mantissa to ZLTemp1
.0188e4	85 1a		sta $1a				sta 	zLTemp1
.0188e6	a5 81		lda $81				lda 	XS_Mantissa+1
.0188e8	85 1b		sta $1b				sta 	zLTemp1+1
.0188ea	a5 82		lda $82				lda 	XS_Mantissa+2
.0188ec	85 1c		sta $1c				sta 	zLTemp1+2
.0188ee					_CWAWaitLoop:
.0188ee	20 40 85	jsr $018540			jsr 	VIOCheckBreak 				; exit on break.
.0188f1	c9 00		cmp #$00			cmp 	#0
.0188f3	d0 0f		bne $018904			bne 	_CWAWaitExit
.0188f5	a9 01		lda #$01			lda 	#1							; read 1 byte to mantissa/0
.0188f7	a2 00		ldx #$00			ldx 	#0
.0188f9	5a		phy				phy 								; this is the same routine as PEEK.
.0188fa	20 6a 98	jsr $01986a			jsr 	MemRead
.0188fd	7a		ply				ply
.0188fe	25 86		and $86				and 	XS_Mantissa+XS_Size 		; process it
.018900	45 8c		eor $8c				eor 	XS_Mantissa+XS_Size*2
.018902	f0 ea		beq $0188ee			beq 	_CWAWaitLoop
.018904					_CWAWaitExit:
.018904	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/run.asm

.018905					Command_RUN:
.018905	20 9b 90	jsr $01909b			jsr 	ResetRunStatus 				; clear, reset stacks etc.
.018908	a9 00		lda #$00			lda 	#BasicProgram & $FF
.01890a	85 16		sta $16				sta 	zCodePtr+0
.01890c	a9 10		lda #$10			lda 	#BasicProgram >> 8
.01890e	85 17		sta $17				sta 	zCodePtr+1
.018910	a9 00		lda #$00			lda 	#0
.018912	85 18		sta $18				sta 	zCodePtr+2
.018914	85 19		sta $19				sta 	zCodePtr+3
.018916	a0 03		ldy #$03			ldy 	#3
.018918					RUN_NewLine:
.018918	a0 00		ldy #$00			ldy 	#0
.01891a	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01891c	c8		iny				iny
.01891d	c8		iny				iny
.01891e	c8		iny				iny
.01891f	c9 00		cmp #$00			cmp 	#0 							; if the offset is zero then END.
.018921	d0 16		bne $018939			bne 	RUN_NextCommand
.018923	4c 48 8c	jmp $018c48			jmp 	Command_END 				; go do the command code.
.018926					RUN_Skip:
.018926	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018928	c8		iny				iny 								; skip
.018929	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.01892b	90 0c		bcc $018939			bcc 	_SEDone 					; so just skip over it.
.01892d	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.01892f	90 07		bcc $018938			bcc 	_SEDouble
.018931	98		tya				tya 								; this is Y + 1
.018932	18		clc				clc
.018933	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018935	a8		tay				tay 								; back in Y.
.018936	88		dey				dey 								; fix up, one for the +1, one for the iny
.018937	88		dey				dey
.018938					_SEDouble:
.018938	c8		iny				iny
.018939					_SEDone:
.018939					RUN_NextCommand:
.018939	ad a8 03	lda $03a8			lda 	BreakCount 					; break counter
.01893c	69 10		adc #$10			adc 	#16 						; one time in 16
.01893e	8d a8 03	sta $03a8			sta 	BreakCount
.018941	90 0a		bcc $01894d			bcc 	RUN_NoCheckBreak
.018943	20 40 85	jsr $018540			jsr 	VIOCheckBreak 				; check for break
.018946	c9 00		cmp #$00			cmp 	#0
.018948	f0 03		beq $01894d			beq 	RUN_NoCheckBreak
.01894a	4c b2 90	jmp $0190b2			jmp 	Command_STOP 				; stop on BREAK.
.01894d					RUN_NoCheckBreak:
.01894d	a9 00		lda #$00			lda 	#0 							; this resets temporary string allocation.
.01894f	85 21		sta $21				sta 	zTempStr+1 					; (initialised when first called)
.018951	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018953	c9 c0		cmp #$c0			cmp 	#token_Colon 				; skip over colons
.018955	f0 cf		beq $018926			beq 	RUN_Skip
.018957	c9 00		cmp #$00			cmp 	#0 							; if non-zero execute whatever
.018959	d0 0f		bne $01896a			bne 	RUN_Execute
.01895b					RUN_NextLine:
.01895b	a0 00		ldy #$00			ldy 	#0 							; point to offset
.01895d	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.01895f	18		clc				clc
.018960	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018962	85 16		sta $16				sta 	zCodePtr
.018964	90 02		bcc $018968			bcc 	_SNLNoCarry
.018966	e6 17		inc $17				inc 	zCodePtr+1
.018968					_SNLNoCarry:
.018968	80 ae		bra $018918			bra 	RUN_NewLine 				; go do the new line code
.01896a					RUN_Execute:
.01896a	c9 f8		cmp #$f8			cmp 	#$F8 						; handle shifts, REM etc.
.01896c	b0 1e		bcs $01898c			bcs 	RUN_Extension
.01896e	c8		iny				iny
.01896f	0a		asl a				asl 	a 							; double the character read.
.018970	90 14		bcc $018986			bcc 	RUN_Default 				; if carry clear was $00-$7F, so try LET.
.018972	aa		tax				tax 								; ready to look up.
.018973	bf dd 85 01	lda $0185dd,x			lda 	VectorTable,x 				; copy address into LocalVector
.018977	8d 11 03	sta $0311			sta 	LocalVector+1
.01897a	bf de 85 01	lda $0185de,x			lda 	VectorTable+1,x
.01897e	8d 12 03	sta $0312			sta 	LocalVector+2
.018981	20 ec 91	jsr $0191ec			jsr 	EVCallLocalVector 			; execute the appropriate code.
.018984	80 b3		bra $018939			bra 	RUN_NextCommand 			; do the next command.
.018986					RUN_Default:
.018986	88		dey				dey
.018987	20 88 8b	jsr $018b88			jsr 	Command_LET 				; and try LET.
.01898a	80 ad		bra $018939			bra 	RUN_NextCommand
.01898c					RUN_Extension:
.01898c	c9 ff		cmp #$ff			cmp 	#$FF 						; if $FF (REM)
.01898e	f0 96		beq $018926			beq 	RUN_Skip 					; skip over it.
.018990	4c 4a 85	jmp $01854a			jmp 	SyntaxError
.018993					Command_COLON:
.018993	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/for.asm

.018994					Command_FOR:
.018994	20 88 8b	jsr $018b88			jsr 	Command_LET 				; do the A = 99 bit
.018997	a5 24		lda $24				lda 	zVarType 					; obviously has to be integer/real.
.018999	c9 b7		cmp #$b7			cmp 	#token_Dollar
.01899b	f0 71		beq $018a0e			beq 	_CFOError
.01899d	48		pha				pha 								; save the variable type.
.01899e	5a		phy				phy 								; save type/variable address.
.01899f	a0 01		ldy #$01			ldy 	#1							; type at + 1
.0189a1	91 26		sta ($26),y			sta 	(zBasicSP),y
.0189a3	c8		iny				iny
.0189a4	a5 22		lda $22				lda 	zVarDataPtr 				; data low at +2
.0189a6	91 26		sta ($26),y			sta 	(zBasicSP),y
.0189a8	c8		iny				iny
.0189a9	a5 23		lda $23				lda 	zVarDataPtr+1 				; data high at +3
.0189ab	91 26		sta ($26),y			sta 	(zBasicSP),y
.0189ad	7a		ply				ply
.0189ae	a9 53		lda #$53			lda 	#(SMark_For << 4) + 3
.0189b0	20 b2 84	jsr $0184b2			jsr 	StackPushFrame 				; push on the stack with FOR marker.
.0189b3	a9 c8		lda #$c8			lda 	#token_TO
.0189b5	20 d1 98	jsr $0198d1			jsr 	CheckNextToken
.0189b8	a2 00		ldx #$00			ldx 	#0 							; put in Mantissa, bottom
.0189ba	20 09 91	jsr $019109			jsr 	EvaluateExpression
.0189bd	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0189bf	a2 06		ldx #$06			ldx 	#XS_Size 					; X to second level
.0189c1	c9 c9		cmp #$c9			cmp 	#token_STEP
.0189c3	d0 06		bne $0189cb			bne 	_CFOStep1
.0189c5	c8		iny				iny
.0189c6	20 0b 91	jsr $01910b			jsr 	EvaluateExpressionX 		; get STEP value.
.0189c9	80 0e		bra $0189d9			bra 	_CFOHaveStep
.0189cb					_CFOStep1:
.0189cb	a9 00		lda #$00			lda 	#0							; set step to integer 1.
.0189cd	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0189cf	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0189d1	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0189d3	a9 01		lda #$01			lda 	#1
.0189d5	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0189d7	95 85		sta $85,x			sta 	XS_Type,x
.0189d9					_CFOHaveStep:
.0189d9	68		pla				pla 								; restore variable type
.0189da	a2 00		ldx #$00			ldx 	#0
.0189dc	c9 bb		cmp #$bb			cmp 	#token_Percent 				; do conversion to type
.0189de	f0 0a		beq $0189ea			beq 	_CFOInteger
.0189e0	20 a5 a2	jsr $01a2a5			jsr 	FPUToFloat
.0189e3	a2 06		ldx #$06			ldx 	#6
.0189e5	20 a5 a2	jsr $01a2a5			jsr 	FPUToFloat
.0189e8	80 08		bra $0189f2			bra 	_CFOEndConv
.0189ea					_CFOInteger:
.0189ea	20 f1 a2	jsr $01a2f1			jsr 	FPUToInteger
.0189ed	a2 06		ldx #$06			ldx 	#6
.0189ef	20 f1 a2	jsr $01a2f1			jsr 	FPUToInteger
.0189f2					_CFOEndConv:
.0189f2	20 f9 84	jsr $0184f9			jsr 	StackSavePosition 			; save the loop position at 1-5
.0189f5	a9 55		lda #$55			lda 	#(SMark_For << 4)+SourcePosSize
.0189f7	20 b2 84	jsr $0184b2			jsr 	StackPushFrame 				; push the loop address frame.
.0189fa	5a		phy				phy
.0189fb	a0 00		ldy #$00			ldy 	#0
.0189fd					_CFOCopy:
.0189fd	b9 80 00	lda $0080,y			lda 	XS_Mantissa+0,y
.018a00	c8		iny				iny
.018a01	91 26		sta ($26),y			sta 	(zBasicSP),y
.018a03	c0 0c		cpy #$0c			cpy 	#XS_Size*2
.018a05	d0 f6		bne $0189fd			bne 	_CFOCopy
.018a07	7a		ply				ply
.018a08	a9 5c		lda #$5c			lda 	#(SMark_For << 4)+(XS_Size*2)
.018a0a	20 b2 84	jsr $0184b2			jsr 	StackPushFrame
.018a0d	60		rts				rts
.018a0e					_CFOError:
.018a0e	4c 5a 85	jmp $01855a			jmp 	TypeError 					; wrong type.
.018a11					Command_NEXT:
.018a11	a9 00		lda #$00			lda 	#0 							; set variable data pointer+1 to zero
.018a13	85 23		sta $23				sta 	zVarDataPtr+1 				; this means we don't check
.018a15	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018a17	c9 00		cmp #$00			cmp 	#0 							; EOL
.018a19	f0 07		beq $018a22			beq 	_CNextNoVariable
.018a1b	c9 40		cmp #$40			cmp 	#$40
.018a1d	b0 03		bcs $018a22			bcs 	_CNextNoVariable
.018a1f	20 96 99	jsr $019996			jsr 	VariableFind
.018a22					_CNextNoVariable:
.018a22	a5 26		lda $26				lda 	zBasicSP 					; save on stack
.018a24	48		pha				pha
.018a25	a5 27		lda $27				lda 	zBasicSP+1
.018a27	48		pha				pha
.018a28	a9 50		lda #$50			lda 	#(SMark_For << 4) 			; pop loop address frame
.018a2a	20 c9 84	jsr $0184c9			jsr 	StackPopFrame
.018a2d	a9 50		lda #$50			lda 	#(SMark_For << 4) 			; pop STEP/TARGET frame.
.018a2f	20 c9 84	jsr $0184c9			jsr 	StackPopFrame
.018a32	a9 50		lda #$50			lda 	#(Smark_For << 4) 			; pop variable address frame.
.018a34	20 c9 84	jsr $0184c9			jsr 	StackPopFrame
.018a37	a5 23		lda $23				lda 	zVarDataPtr+1 				; if zero, then no variable provided
.018a39	f0 11		beq $018a4c			beq 	_CNextGetTarget 			; e.g. just NEXT not NEXT x
.018a3b	5a		phy				phy 								; check addresses match.
.018a3c	a0 02		ldy #$02			ldy 	#2
.018a3e	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a40	c5 22		cmp $22				cmp 	zVarDataPtr
.018a42	d0 69		bne $018aad			bne 	_CNextWrong
.018a44	c8		iny				iny
.018a45	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a47	c5 23		cmp $23				cmp 	zVarDataPtr+1
.018a49	d0 62		bne $018aad			bne 	_CNextWrong
.018a4b	7a		ply				ply
.018a4c					_CNextGetTarget:
.018a4c	5a		phy				phy
.018a4d	a0 01		ldy #$01			ldy 	#1 							; restore variable type and data.
.018a4f	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a51	85 24		sta $24				sta 	zVarType
.018a53	c8		iny				iny
.018a54	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a56	85 22		sta $22				sta 	zVarDataPtr
.018a58	c8		iny				iny
.018a59	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a5b	85 23		sta $23				sta 	zVarDataPtr+1
.018a5d	a2 0c		ldx #$0c			ldx 	#12
.018a5f	20 de 9c	jsr $019cde			jsr 	VariableGet 				; get that variable value into expr[2]
.018a62	a2 00		ldx #$00			ldx 	#0 							; copy stacked Target/Step into expr[0] and [1]
.018a64	a0 0b		ldy #$0b			ldy 	#11
.018a66					_CNXCopy:
.018a66	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a68	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018a6a	e8		inx				inx
.018a6b	c8		iny				iny
.018a6c	e0 0c		cpx #$0c			cpx 	#XS_Size*2
.018a6e	d0 f6		bne $018a66			bne 	_CNXCopy
.018a70	7a		ply				ply
.018a71	a2 06		ldx #$06			ldx 	#6 							; point at expr[1] s
.018a73	20 13 95	jsr $019513			jsr 	GetSignCurrent
.018a76	8d a7 03	sta $03a7			sta 	SignNext 					; save in temporary.
.018a79	a2 06		ldx #$06			ldx 	#6 							; add them, however
.018a7b	20 f2 93	jsr $0193f2			jsr 	BinaryOp_Add
.018a7e	20 2f 9d	jsr $019d2f			jsr 	VariableSet					; and write variable back.
.018a81	a2 00		ldx #$00			ldx 	#0
.018a83	20 76 93	jsr $019376			jsr 	CompareValues
.018a86	09 00		ora #$00			ora 	#0
.018a88	f0 05		beq $018a8f			beq 	_CNXAgain 					; if true, then do it again.
.018a8a	cd a7 03	cmp $03a7			cmp 	SignNext 					; if sign different, then loop has finished.
.018a8d	d0 0f		bne $018a9e			bne 	_CNXLoopDone
.018a8f					_CNXAgain:
.018a8f	a9 53		lda #$53			lda 	#(SMark_For << 4) + 3		; re-stack variable address
.018a91	20 b2 84	jsr $0184b2			jsr 	StackPushFrame
.018a94	20 16 85	jsr $018516			jsr 	StackRestorePosition 		; get restore position back, e.g. loop round.
.018a97	68		pla				pla
.018a98	85 27		sta $27				sta 	zBasicSP+1
.018a9a	68		pla				pla
.018a9b	85 26		sta $26				sta 	zBasicSP
.018a9d					_CNXExit:
.018a9d	60		rts				rts
.018a9e					_CNXLoopDone:
.018a9e	68		pla				pla
.018a9f	68		pla				pla
.018aa0	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018aa2	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma ?
.018aa4	d0 f7		bne $018a9d			bne 	_CNXExit
.018aa6	c8		iny				iny
.018aa7	20 96 99	jsr $019996			jsr 	VariableFind 				; identify the variable
.018aaa	4c 22 8a	jmp $018a22			jmp 	_CNextNoVariable 			; go back with variable pre-found
.018aad					_CNextWrong:
.018aad	20 79 85	jsr $018579			jsr ERR_Handler
>018ab0	57 72 6f 6e 67 20 4e 65			.text "Wrong Next Variable",0
>018ab8	78 74 20 56 61 72 69 61 62 6c 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/read.asm

.018ac4					Command_READ:
.018ac4	20 96 99	jsr $019996			jsr 	VariableFind 				; get variable/value into zVarDataPtr,zVarType
.018ac7	a5 22		lda $22				lda 	zVarDataPtr 				; save variable info on stack
.018ac9	48		pha				pha
.018aca	a5 23		lda $23				lda 	zVarDataPtr+1
.018acc	48		pha				pha
.018acd	a5 24		lda $24				lda 	zVarType
.018acf	48		pha				pha
.018ad0	20 16 8b	jsr $018b16			jsr 	READGetDataItem 			; get the next data item
.018ad3	68		pla				pla 								; restore target variable information.
.018ad4	85 24		sta $24				sta 	zVarType
.018ad6	68		pla				pla
.018ad7	85 23		sta $23				sta 	zVarDataPtr+1
.018ad9	68		pla				pla
.018ada	85 22		sta $22				sta 	zVarDataPtr
.018adc	a2 00		ldx #$00			ldx 	#0
.018ade	20 2f 9d	jsr $019d2f			jsr 	VariableSet 				; set the value out.
.018ae1	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018ae3	c8		iny				iny
.018ae4	c9 bf		cmp #$bf			cmp 	#token_Comma
.018ae6	f0 dc		beq $018ac4			beq 	Command_READ 				; found, do another READ
.018ae8	88		dey				dey
.018ae9	60		rts				rts
.018aea					Command_DATA:
.018aea	4c 80 84	jmp $018480			jmp 	SkipEndOfCommand
.018aed					Command_RESTORE:
.018aed	48		pha				pha
.018aee	a9 00		lda #$00			lda 	#0 							; this being zero means 'initialise next read'
.018af0	8d bd 03	sta $03bd			sta 	DataLPtr+0
.018af3	8d be 03	sta $03be			sta 	DataLPtr+1
.018af6	68		pla				pla
.018af7	60		rts				rts
.018af8					READSwapPointers:
.018af8	98		tya				tya
.018af9	48		pha				pha 								; save it
.018afa	ad c1 03	lda $03c1			lda 	DataIndex 					; get data offset, and copy to offset
.018afd	a8		tay				tay
.018afe	68		pla				pla 								; get code offset and save in DataIndex
.018aff	8d c1 03	sta $03c1			sta 	DataIndex
.018b02	da		phx				phx
.018b03	a2 03		ldx #$03			ldx 	#3 							; swap the Data Pointers (4 bytes) round.
.018b05					_RSWLoop:
.018b05	bd bd 03	lda $03bd,x			lda 	DataLPtr+0,x
.018b08	48		pha				pha
.018b09	b5 16		lda $16,x			lda 	zCodePtr+0,x
.018b0b	9d bd 03	sta $03bd,x			sta 	DataLPtr+0,x
.018b0e	68		pla				pla
.018b0f	95 16		sta $16,x			sta 	zCodePtr+0,x
.018b11	ca		dex				dex
.018b12	10 f1		bpl $018b05			bpl 	_RSWLoop
.018b14	fa		plx				plx
.018b15	60		rts				rts
.018b16					READGetDataItem:
.018b16	20 f8 8a	jsr $018af8			jsr 	ReadSwapPointers 			; swap code and data pointer.
.018b19	a5 16		lda $16				lda		zCodePtr+0 					; initialise ?
.018b1b	05 17		ora $17				ora 	zCodePtr+1
.018b1d	d0 12		bne $018b31			bne 	_RGDIIsInitialised
.018b1f	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018b21	85 16		sta $16				sta 	zCodePtr+0
.018b23	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018b25	85 17		sta $17				sta 	zCodePtr+1
.018b27	a9 00		lda #$00			lda 	#0
.018b29	85 18		sta $18				sta 	zCodePtr+2
.018b2b	85 19		sta $19				sta 	zCodePtr+3
.018b2d	a0 03		ldy #$03			ldy 	#3
.018b2f	80 06		bra $018b37			bra 	_RGDIFindData 				; locate next data from start and read that.
.018b31					_RGDIIsInitialised:
.018b31	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018b33	c9 bf		cmp #$bf			cmp 	#token_Comma
.018b35	f0 49		beq $018b80			beq 	_RGDISkipEvaluateExit
.018b37					_RGDIFindData:
.018b37	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018b39	c9 00		cmp #$00			cmp 	#0 							; end of line
.018b3b	f0 19		beq $018b56			beq 	_RGDIFindNextLine
.018b3d	c9 c5		cmp #$c5			cmp 	#token_DATA 				; found data token
.018b3f	f0 3f		beq $018b80			beq 	_RGDISkipEvaluateExit 		; then skip it and evaluate
.018b41	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018b43	c8		iny				iny 								; skip
.018b44	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018b46	90 0c		bcc $018b54			bcc 	_SEDone 					; so just skip over it.
.018b48	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018b4a	90 07		bcc $018b53			bcc 	_SEDouble
.018b4c	98		tya				tya 								; this is Y + 1
.018b4d	18		clc				clc
.018b4e	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018b50	a8		tay				tay 								; back in Y.
.018b51	88		dey				dey 								; fix up, one for the +1, one for the iny
.018b52	88		dey				dey
.018b53					_SEDouble:
.018b53	c8		iny				iny
.018b54					_SEDone:
.018b54	80 e1		bra $018b37			bra 	_RGDIFindData
.018b56					_RGDIFindNextLine:
.018b56	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018b58	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.018b5a	18		clc				clc
.018b5b	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018b5d	85 16		sta $16				sta 	zCodePtr
.018b5f	90 02		bcc $018b63			bcc 	_SNLNoCarry
.018b61	e6 17		inc $17				inc 	zCodePtr+1
.018b63					_SNLNoCarry:
.018b63	a0 00		ldy #$00			ldy 	#0
.018b65	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018b67	48		pha				pha
.018b68	c8		iny				iny
.018b69	c8		iny				iny
.018b6a	c8		iny				iny
.018b6b	68		pla				pla
.018b6c	d0 c9		bne $018b37			bne 	_RGDIFindData 				; back to scanning.
.018b6e	20 f8 8a	jsr $018af8			jsr 	ReadSwapPointers 			; so we get error in line number of READ
.018b71	20 79 85	jsr $018579			jsr ERR_Handler
>018b74	4f 75 74 20 6f 66 20 44			.text "Out of Data",0
>018b7c	61 74 61 00
.018b80					_RGDISkipEvaluateExit:
.018b80	c8		iny				iny
.018b81	20 09 91	jsr $019109			jsr 	EvaluateExpression 			; evaluate the expression
.018b84	20 f8 8a	jsr $018af8			jsr 	ReadSwapPointers 			; swap the pointers around.
.018b87	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/let.asm

.018b88					Command_LET:
.018b88	20 96 99	jsr $019996			jsr 	VariableFind 				; get reference to one variable.
.018b8b	a9 84		lda #$84			lda 	#token_Equal  				; get equals
.018b8d	20 d1 98	jsr $0198d1			jsr 	CheckNextToken
.018b90	a5 22		lda $22				lda 	zVarDataPtr 				; save variable info on stack
.018b92	48		pha				pha
.018b93	a5 23		lda $23				lda 	zVarDataPtr+1
.018b95	48		pha				pha
.018b96	a5 24		lda $24				lda 	zVarType
.018b98	48		pha				pha
.018b99	20 09 91	jsr $019109			jsr 	EvaluateExpression 			; evaluate the RHS, set X to zero.
.018b9c	68		pla				pla 								; restore target variable information.
.018b9d	85 24		sta $24				sta 	zVarType
.018b9f	68		pla				pla
.018ba0	85 23		sta $23				sta 	zVarDataPtr+1
.018ba2	68		pla				pla
.018ba3	85 22		sta $22				sta 	zVarDataPtr
.018ba5	20 2f 9d	jsr $019d2f			jsr 	VariableSet 				; set the value out.
.018ba8	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/get.asm

.018ba9					Command_GET:
.018ba9					_CGLoop:
.018ba9	20 96 99	jsr $019996			jsr 	VariableFind 				; get a variable.
.018bac	20 35 85	jsr $018535			jsr 	VIOCharGet 					; get character
.018baf	b0 02		bcs $018bb3			bcs 	_CGNoKey
.018bb1	a9 00		lda #$00			lda 	#0 							; if no character return zero
.018bb3					_CGNoKey:
.018bb3	48		pha				pha
.018bb4	a5 24		lda $24				lda 	zVarType 					; look at the data type.
.018bb6	c9 b7		cmp #$b7			cmp 	#token_Dollar
.018bb8	f0 1e		beq $018bd8			beq 	_CGString
.018bba	68		pla				pla 								; put character in slot.
.018bbb	85 80		sta $80				sta 	XS_Mantissa
.018bbd	a9 00		lda #$00			lda 	#0
.018bbf	85 81		sta $81				sta 	XS_Mantissa+1
.018bc1	85 82		sta $82				sta 	XS_Mantissa+2
.018bc3	85 83		sta $83				sta 	XS_Mantissa+3
.018bc5	a9 01		lda #$01			lda 	#1 							; type integer
.018bc7	85 85		sta $85				sta 	XS_Type
.018bc9					_CGWriteSetNext:
.018bc9	a2 00		ldx #$00			ldx 	#0 							; write number/WriteTempString out
.018bcb	20 2f 9d	jsr $019d2f			jsr 	VariableSet
.018bce	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018bd0	c9 bf		cmp #$bf			cmp 	#token_Comma 				; if not comma exit
.018bd2	d0 03		bne $018bd7			bne 	_CGExit
.018bd4	c8		iny				iny
.018bd5	80 d2		bra $018ba9			bra 	_CGLoop 					; and get another.
.018bd7					_CGExit:
.018bd7	60		rts				rts
.018bd8					_CGString:
.018bd8	a9 02		lda #$02			lda 	#2 							; allocate temp string, space for 2.
.018bda	20 35 99	jsr $019935			jsr 	AllocateTempString 			; initially empty.
.018bdd	a5 20		lda $20				lda 	zTempStr 					; set up to be returned.
.018bdf	85 80		sta $80				sta 	XS_Mantissa
.018be1	a5 21		lda $21				lda 	zTempStr+1
.018be3	85 81		sta $81				sta 	XS_Mantissa+1
.018be5	a9 02		lda #$02			lda 	#2
.018be7	85 85		sta $85				sta 	XS_Type
.018be9	68		pla				pla 								; get A
.018bea	c9 00		cmp #$00			cmp 	#0
.018bec	f0 db		beq $018bc9			beq 	_CGWriteSetNext
.018bee	20 60 99	jsr $019960			jsr 	WriteTempString 			; write it into string
.018bf1	80 d6		bra $018bc9			bra 	_CGWriteSetNext

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/sys.asm

.018bf3					Command_SYS:
.018bf3	20 9f 92	jsr $01929f			jsr 	EvaluateInteger 			; address to call.
.018bf6	a5 80		lda $80				lda 	XS_Mantissa+0				; copy to localvector
.018bf8	8d 10 03	sta $0310			sta 	LocalVector+0 				; only three, can only do 24 bit calls
.018bfb	a5 81		lda $81				lda 	XS_Mantissa+1 				; and that only on 65816
.018bfd	8d 11 03	sta $0311			sta 	LocalVector+1
.018c00	a5 82		lda $82				lda 	XS_Mantissa+2
.018c02	8d 12 03	sta $0312			sta 	LocalVector+2
.018c05	22 0a 8c 01	jsl $018c0a			jsl 	_CSYLocalCall 				; jump depending on 24/16 bit code address
.018c09	60		rts				rts
.018c0a					_CSYLocalCall:
.018c0a	dc 10 03	jmp [$0310]			jmp 	[LocalVector]		 		; address

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/input.asm

.018c0d					Command_INPUT:
.018c0d	a9 00		lda #$00		lda 	#0 								; clear number of characters required.
.018c0f	8d c2 03	sta $03c2		sta 	InputAvailable 					; save character count
.018c12					_CILoop:
.018c12	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c14	c9 fe		cmp #$fe		cmp 	#$FE 							; is it a prompt string
.018c16	d0 15		bne $018c2d		bne 	_CINoPrompt
.018c18	c8		iny				iny
.018c19	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c1b	aa		tax			tax 									; into X
.018c1c	c8		iny				iny
.018c1d	ca		dex			dex 									; deduct marker/prompt length
.018c1e	ca		dex			dex
.018c1f	f0 f1		beq $018c12		beq 	_CILoop 						; nothing.
.018c21					_CIShowPrompt:
.018c21	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c23	20 32 85	jsr $018532		jsr 	VIOCharPrint
.018c26	c8		iny				iny
.018c27	ca		dex			dex
.018c28	d0 f7		bne $018c21		bne 	_CIShowPrompt
.018c2a	80 e6		bra $018c12		bra 	_CILoop
.018c2c					_CIAdvance:
.018c2c	c8		iny				iny
.018c2d					_CINoPrompt:
.018c2d	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c2f	c9 bf		cmp #$bf		cmp 	#token_Comma 					; skip , and ;
.018c31	f0 f9		beq $018c2c		beq 	_CIAdvance
.018c33	c9 c1		cmp #$c1		cmp 	#token_SemiColon
.018c35	f0 f5		beq $018c2c		beq 	_CIAdvance
.018c37	c9 00		cmp #$00		cmp 	#0 								; exit if 0 or :
.018c39	f0 04		beq $018c3f		beq 	_CIExit
.018c3b	c9 c0		cmp #$c0		cmp 	#token_Colon
.018c3d	d0 01		bne $018c40		bne 	_CIIsVariable  					; if not then there#s a variable or should be !
.018c3f					_CIExit:
.018c3f	60		rts			rts
.018c40					_CIIsVariable:
.018c40	ea		nop			nop
.018c41	20 96 99	jsr $019996		jsr 	VariableFind 					; set zVarType and zVarDataPtr accordingly.
.018c44	a5 24		lda $24			lda 	zVarType
.018c46	c9 b7		cmp #$b7		cmp 	#token_Dollar 					; if it's a dollar, then it's a string

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/end.asm

.018c48					Command_END:
>018c48	02						.byte 	2
.018c49	4c 32 88	jmp $018832			jmp 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/if.asm

.018c4c					Command_IF:
.018c4c	20 9f 92	jsr $01929f			jsr 	EvaluateInteger 			; check success.
.018c4f	a5 80		lda $80				lda 	XS_Mantissa+0				; check the result if zero
.018c51	05 81		ora $81				ora 	XS_Mantissa+1
.018c53	05 82		ora $82				ora 	XS_Mantissa+2
.018c55	05 83		ora $83				ora 	XS_Mantissa+3
.018c57	aa		tax				tax 								; put into X.
.018c58	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c5a	c9 93		cmp #$93			cmp 	#token_Then 				; then found.
.018c5c	d0 2c		bne $018c8a			bne 	_FIFExtended
.018c5e	c8		iny				iny
.018c5f	e0 00		cpx #$00			cpx 	#0 							; was it successful.
.018c61	f0 0b		beq $018c6e			beq 	_FIFEndOfLine 				; if not, go to the end of the line.
.018c63	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c65	29 c0		and #$c0			and 	#$C0 						; is it a number
.018c67	c9 40		cmp #$40			cmp 	#$40
.018c69	d0 1e		bne $018c89			bne 	_FIFContinue 				; if not, do what ever follows.
.018c6b	4c d9 8f	jmp $018fd9			jmp		Command_GOTO 				; we have IF <expr> THEN <number> so we do GOTO code.
.018c6e					_FIFEndOfLine:
.018c6e	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c70	c9 00		cmp #$00			cmp 	#0 							; if zero, end of line, so exit
.018c72	f0 15		beq $018c89			beq 	_FIFContinue
.018c74	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018c76	c8		iny				iny 								; skip
.018c77	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018c79	90 0c		bcc $018c87			bcc 	_SEDone 					; so just skip over it.
.018c7b	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018c7d	90 07		bcc $018c86			bcc 	_SEDouble
.018c7f	98		tya				tya 								; this is Y + 1
.018c80	18		clc				clc
.018c81	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018c83	a8		tay				tay 								; back in Y.
.018c84	88		dey				dey 								; fix up, one for the +1, one for the iny
.018c85	88		dey				dey
.018c86					_SEDouble:
.018c86	c8		iny				iny
.018c87					_SEDone:
.018c87	80 e5		bra $018c6e			bra 	_FIFEndOfLine
.018c89					_FIFContinue:
.018c89	60		rts				rts
.018c8a					_FIFExtended:
.018c8a	da		phx				phx 								; save result
.018c8b	a9 40		lda #$40			lda 	#(SMark_If << 4) 			; push marker on the stack, nothing else.
.018c8d	20 b2 84	jsr $0184b2			jsr 	StackPushFrame
.018c90	68		pla				pla 								; restore result
.018c91	f0 01		beq $018c94			beq 	_FIXSkip 					; if zero then it has failed.
.018c93	60		rts				rts 								; test passed, so continue executing
.018c94					_FIXSkip:
.018c94	a9 94		lda #$94			lda 	#token_endif 				; scan forward till found either ELSE or ENDIF
.018c96	a2 de		ldx #$de			ldx 	#token_else 				; at the same level.
.018c98	20 f5 83	jsr $0183f5			jsr 	StructureSearchDouble
.018c9b	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c9d	c8		iny				iny
.018c9e	c9 94		cmp #$94			cmp 	#token_endif 				; if endif, handle endif code.
.018ca0	f0 07		beq $018ca9			beq 	Command_ENDIF
.018ca2	60		rts				rts
.018ca3					Command_ELSE:
.018ca3	a9 94		lda #$94			lda 	#token_endif 				; scan forward till found ENDIF
.018ca5	20 f3 83	jsr $0183f3			jsr 	StructureSearchSingle 		; then do the ENDIF pop.
.018ca8	c8		iny				iny
.018ca9					Command_ENDIF:
.018ca9	a9 40		lda #$40			lda 	#(SMark_If << 4)
.018cab	20 c9 84	jsr $0184c9			jsr 	StackPopFrame
.018cae	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/list.asm

.018caf					Command_LIST:
.018caf	20 3c 8e	jsr $018e3c			jsr 	ListGetRange				; get any parameters
.018cb2	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018cb4	85 16		sta $16				sta 	zCodePtr+0
.018cb6	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018cb8	85 17		sta $17				sta 	zCodePtr+1
.018cba	a9 00		lda #$00			lda 	#0
.018cbc	85 18		sta $18				sta 	zCodePtr+2
.018cbe	85 19		sta $19				sta 	zCodePtr+3
.018cc0	a0 03		ldy #$03			ldy 	#3
.018cc2	a9 00		lda #$00			lda 	#0 							; reset the indent & last indent
.018cc4	8d bc 03	sta $03bc			sta 	LastListIndent
.018cc7	8d bb 03	sta $03bb			sta 	ListIndent
.018cca					_CILLoop:
.018cca	a0 00		ldy #$00			ldy 	#0
.018ccc	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018cce	c9 00		cmp #$00			cmp 	#0 							; if zero, end of program
.018cd0	f0 23		beq $018cf5			beq 	_CILExit
.018cd2	20 40 85	jsr $018540			jsr 	VIOCheckBreak 				; check break
.018cd5	c9 00		cmp #$00			cmp 	#0
.018cd7	d0 1c		bne $018cf5			bne 	_CILExit
.018cd9	20 83 8e	jsr $018e83			jsr 	ListCheckRange 				; check current line in range.
.018cdc	b0 08		bcs $018ce6			bcs		_CILNext
.018cde	a0 00		ldy #$00			ldy 	#0
.018ce0	c8		iny				iny
.018ce1	c8		iny				iny
.018ce2	c8		iny				iny
.018ce3	20 f8 8c	jsr $018cf8			jsr 	ListLine 					; list one line.
.018ce6					_CILNext:
.018ce6	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018ce8	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.018cea	18		clc				clc
.018ceb	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018ced	85 16		sta $16				sta 	zCodePtr
.018cef	90 02		bcc $018cf3			bcc 	_SNLNoCarry
.018cf1	e6 17		inc $17				inc 	zCodePtr+1
.018cf3					_SNLNoCarry:
.018cf3	80 d5		bra $018cca			bra 	_CILLoop
.018cf5					_CILExit:
.018cf5	4c 32 88	jmp $018832			jmp 	WarmStart
.018cf8					ListLine:
.018cf8	ad bb 03	lda $03bb			lda 	ListIndent 					; copy current list indent -> last
.018cfb	8d bc 03	sta $03bc			sta 	LastListIndent
.018cfe					_LICountIndent:
.018cfe	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018d00	c9 00		cmp #$00			cmp 	#0
.018d02	f0 2f		beq $018d33			beq 	_LIDoneIndent
.018d04	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus
.018d06	90 16		bcc $018d1e			bcc 	_LICINext
.018d08	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.018d0a	b0 12		bcs $018d1e			bcs 	_LICINext
.018d0c	ee bb 03	inc $03bb			inc 	ListIndent
.018d0f	c9 93		cmp #$93			cmp 	#firstKeywordMinus
.018d11	90 0b		bcc $018d1e			bcc 	_LICINext
.018d13	ce bb 03	dec $03bb			dec 	ListIndent
.018d16	ce bb 03	dec $03bb			dec 	ListIndent
.018d19	10 03		bpl $018d1e			bpl 	_LICINext
.018d1b	ee bb 03	inc $03bb			inc 	ListIndent
.018d1e					_LICINext:
.018d1e	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018d20	c8		iny				iny 								; skip
.018d21	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018d23	90 0c		bcc $018d31			bcc 	_SEDone 					; so just skip over it.
.018d25	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018d27	90 07		bcc $018d30			bcc 	_SEDouble
.018d29	98		tya				tya 								; this is Y + 1
.018d2a	18		clc				clc
.018d2b	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018d2d	a8		tay				tay 								; back in Y.
.018d2e	88		dey				dey 								; fix up, one for the +1, one for the iny
.018d2f	88		dey				dey
.018d30					_SEDouble:
.018d30	c8		iny				iny
.018d31					_SEDone:
.018d31	80 cb		bra $018cfe			bra 	_LICountIndent
.018d33					_LIDoneIndent:
.018d33	a0 00		ldy #$00			ldy 	#0
.018d35	c8		iny				iny
.018d36	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018d38	85 80		sta $80				sta 	XS_Mantissa
.018d3a	c8		iny				iny
.018d3b	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018d3d	85 81		sta $81				sta 	XS_Mantissa+1
.018d3f	20 bf 85	jsr $0185bf			jsr 	Print16BitInteger 			; print integer.
.018d42	85 10		sta $10				sta 	zTemp1 						; save spaces printed.
.018d44	ad bb 03	lda $03bb			lda 	ListIndent 					; smaller of current/prev indent
.018d47	cd bc 03	cmp $03bc			cmp 	LastListIndent
.018d4a	90 03		bcc $018d4f			bcc 	_LISmaller
.018d4c	ad bc 03	lda $03bc			lda 	LastListIndent
.018d4f					_LISmaller:
.018d4f	0a		asl a				asl 	a 							; double indent
.018d50	49 ff		eor #$ff			eor 	#$FF 						; 2's complement arithmetic
.018d52	38		sec				sec
.018d53	65 10		adc $10				adc 	zTemp1 						; "subtract" indent e.g. print more.
.018d55	aa		tax				tax 								; print spaces to column 6
.018d56					_LISpace:
.018d56	a9 20		lda #$20			lda 	#" "
.018d58	20 2c 8e	jsr $018e2c			jsr 	ListPrintLC
.018d5b	e8		inx				inx
.018d5c	e0 06		cpx #$06			cpx 	#6
.018d5e	d0 f6		bne $018d56			bne 	_LISpace
.018d60					_LIDecode:
.018d60	c8		iny				iny
.018d61	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018d63	c9 00		cmp #$00			cmp 	#0 							; zero, exit.
.018d65	f0 0f		beq $018d76			beq 	_LIExit
.018d67	30 12		bmi $018d7b			bmi 	_LIToken
.018d69	c9 40		cmp #$40			cmp 	#$40 						; 01-$3F, character.
.018d6b	b0 50		bcs $018dbd			bcs 	_LIInteger
.018d6d	49 20		eor #$20			eor 	#$20 						; make 7 bit
.018d6f	69 20		adc #$20			adc 	#$20
.018d71	20 2c 8e	jsr $018e2c			jsr 	ListPrintLC 				; print in LC
.018d74	80 ea		bra $018d60			bra 	_LIDecode
.018d76					_LIExit:
.018d76	a9 0d		lda #$0d			lda 	#13 						; print new line.
.018d78	4c 2c 8e	jmp $018e2c			jmp 	ListPrintLC
.018d7b					_LIToken:
.018d7b	c9 fc		cmp #$fc			cmp 	#$FC 						; $FC-$FF ?
.018d7d	90 49		bcc $018dc8			bcc		_LICommandToken
.018d7f	48		pha				pha 								; save in case end
.018d80	a2 22		ldx #$22			ldx 	#'"'						; print if $FE quoted string
.018d82	c9 fe		cmp #$fe			cmp 	#$FE
.018d84	f0 17		beq $018d9d			beq 	_LIPrint
.018d86	a2 2e		ldx #$2e			ldx 	#'.'						; print if $FD decimals
.018d88	c9 fd		cmp #$fd			cmp 	#$FD
.018d8a	f0 11		beq $018d9d			beq 	_LIPrint
.018d8c	a9 52		lda #$52			lda 	#'R'						; must be REM
.018d8e	20 2c 8e	jsr $018e2c			jsr 	ListPrintLC
.018d91	a9 45		lda #$45			lda 	#'E'
.018d93	20 2c 8e	jsr $018e2c			jsr 	ListPrintLC
.018d96	a9 4d		lda #$4d			lda 	#'M'
.018d98	20 2c 8e	jsr $018e2c			jsr 	ListPrintLC
.018d9b	a2 20		ldx #$20			ldx 	#' '
.018d9d					_LIPrint:
.018d9d	8a		txa				txa
.018d9e	20 2c 8e	jsr $018e2c			jsr 	ListPrintLC
.018da1	c8		iny				iny
.018da2	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018da4	aa		tax				tax 								; put in X
.018da5	ca		dex				dex
.018da6					_LILoop:
.018da6	ca		dex				dex 								; exit when count reached zero.
.018da7	f0 08		beq $018db1			beq 	_LIEnd
.018da9	c8		iny				iny
.018daa	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018dac	20 2c 8e	jsr $018e2c			jsr 	ListPrintLC
.018daf	80 f5		bra $018da6			bra 	_LILoop
.018db1	68		pla		_LIEnd:	pla 								; get A back
.018db2	c9 fe		cmp #$fe			cmp 	#$FE 						; if '"' need closing quotes
.018db4	d0 aa		bne $018d60			bne 	_LIDecode
.018db6	a9 22		lda #$22			lda 	#'"'
.018db8	20 2c 8e	jsr $018e2c			jsr 	ListPrintLC
.018dbb	80 a3		bra $018d60			bra 	_LIDecode
.018dbd					_LIInteger:
.018dbd	a2 00		ldx #$00			ldx 	#0
.018dbf	20 11 92	jsr $019211			jsr 	EvaluateGetInteger 			; get an atom
.018dc2	88		dey				dey
.018dc3	20 c5 85	jsr $0185c5			jsr 	Print32BitInteger 			; print integer.
.018dc6	80 98		bra $018d60			bra 	_LIDecode
.018dc8					_LICommandToken:
.018dc8	5a		phy				phy 								; save Y
.018dc9	48		pha				pha 								; save token
.018dca	a2 bd		ldx #$bd			ldx  	#KeywordText & $FF 			; address of keyword text table.
.018dcc	a9 86		lda #$86			lda 	(#KeywordText >> 8) & $FF
.018dce	86 1a		stx $1a				stx 	zLTemp1
.018dd0	85 1b		sta $1b				sta 	zLTemp1+1
.018dd2	a9 01		lda #$01			lda 	(#KeywordText >> 16) & $FF 	; this is for 65816 (it's a table in code
.018dd4	85 1c		sta $1c				sta 	zLTemp1+2 					; space) and won't affect a 6502 at all.
.018dd6	68		pla				pla 								; get token
.018dd7	29 7f		and #$7f			and 	#127 						; chuck bit 7.
.018dd9	f0 16		beq $018df1			beq 	_LIFoundToken
.018ddb	aa		tax				tax
.018ddc					_LITokenLoop:
.018ddc	a0 00		ldy #$00			ldy 	#0 							; last character not a token.
.018dde					_LIFindEnd:
.018dde	b7 1a		lda [$1a],y			lda 	[zLTemp1],y
.018de0	c8		iny				iny
.018de1	0a		asl a				asl 	a
.018de2	90 fa		bcc $018dde			bcc 	_LIFindEnd
.018de4	98		tya				tya 								; that is step to the next
.018de5	18		clc				clc 								; we don't bother bumping the 3rd byte
.018de6	65 1a		adc $1a				adc 	zLTemp1 					; here.
.018de8	85 1a		sta $1a				sta 	zLTemp1
.018dea	90 02		bcc $018dee			bcc 	_LINoBump
.018dec	e6 1b		inc $1b				inc 	zLTemp1+1
.018dee					_LINoBump:
.018dee	ca		dex				dex 								; no go round again.
.018def	d0 eb		bne $018ddc			bne 	_LITokenLoop
.018df1					_LIFoundToken:
.018df1	a0 00		ldy #$00			ldy 	#0
.018df3					_LIPrintToken:
.018df3	b7 1a		lda [$1a],y			lda 	[zLTemp1],y
.018df5	c0 00		cpy #$00			cpy 	#0 							; see if needs prefix space
.018df7	d0 16		bne $018e0f			bne 	_LINoPrefixSpace
.018df9	c9 41		cmp #$41			cmp 	#"A" 						; e.g. alphabetic token.
.018dfb	90 12		bcc $018e0f			bcc 	_LINoPrefixSpace
.018dfd	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018dff	b0 0e		bcs $018e0f			bcs 	_LINoPrefixSpace
.018e01	ae ba 03	ldx $03ba			ldx 	LastPrinted 				; if last was space not required
.018e04	e0 20		cpx #$20			cpx 	#" "
.018e06	f0 07		beq $018e0f			beq 	_LINoPrefixSpace
.018e08	48		pha				pha
.018e09	a9 20		lda #$20			lda 	#" "
.018e0b	20 2c 8e	jsr $018e2c			jsr 	ListPrintLC
.018e0e	68		pla				pla
.018e0f					_LINoPrefixSpace:
.018e0f	c8		iny				iny
.018e10	48		pha				pha 								; save it
.018e11	29 7f		and #$7f			and 	#$7F
.018e13	20 2c 8e	jsr $018e2c			jsr 	ListPrintLC
.018e16	68		pla				pla
.018e17	10 da		bpl $018df3			bpl 	_LIPrintToken 				; go back if not end
.018e19	7a		ply				ply 								; restore Y
.018e1a	29 7f		and #$7f			and 	#$7F 						; if last char is a letter
.018e1c	c9 41		cmp #$41			cmp 	#"A"
.018e1e	90 09		bcc $018e29			bcc 	_LINotLetter2
.018e20	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018e22	b0 05		bcs $018e29			bcs 	_LINotLetter2
.018e24	a9 20		lda #$20			lda 	#" " 						; add spacing
.018e26	20 2c 8e	jsr $018e2c			jsr 	ListPrintLC
.018e29					_LINotLetter2:
.018e29	4c 60 8d	jmp $018d60			jmp 	_LIDecode
.018e2c					ListPrintLC:
.018e2c	8d ba 03	sta $03ba			sta 	LastPrinted
.018e2f	c9 41		cmp #$41			cmp 	#"A"
.018e31	90 06		bcc $018e39			bcc 	_LPLC0
.018e33	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018e35	b0 02		bcs $018e39			bcs 	_LPLC0
.018e37	69 20		adc #$20			adc 	#$20
.018e39	4c 32 85	jmp $018532	_LPLC0:	jmp 	VIOCharPrint
.018e3c					ListGetRange:
.018e3c	a2 0b		ldx #$0b			ldx 	#XS_Size*2-1 				; clear first 2 slots back to defaults.
.018e3e					_LGRClear:
.018e3e	a9 00		lda #$00			lda 	#0
.018e40	95 80		sta $80,x			sta 	XS_Mantissa,x
.018e42	ca		dex				dex
.018e43	10 f9		bpl $018e3e			bpl 	_LGRClear
.018e45	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e47	c9 00		cmp #$00			cmp 	#0 							; nothing
.018e49	f0 21		beq $018e6c			beq 	_LGRBlank
.018e4b	c9 c0		cmp #$c0			cmp 	#token_Colon 				; or colon
.018e4d	f0 1d		beq $018e6c			beq 	_LGRBlank
.018e4f	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma
.018e51	f0 18		beq $018e6b			beq 	_LGREnd 					; then it's LIST ,x
.018e53	20 9f 92	jsr $01929f			jsr 	EvaluateInteger 			; get the first number into bottom
.018e56	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e58	c9 bf		cmp #$bf			cmp 	#token_Comma
.018e5a	f0 0f		beq $018e6b			beq 	_LGREnd 					; then it is LIST a,b
.018e5c	a5 80		lda $80				lda 	XS_Mantissa+0 				; copy first to second LIST n is n,n
.018e5e	85 86		sta $86				sta 	XS_Mantissa+XS_Size+0
.018e60	a5 81		lda $81				lda 	XS_Mantissa+1
.018e62	85 87		sta $87				sta 	XS_Mantissa+XS_Size+1
.018e64					_LGRBumpExit:
.018e64	e6 86		inc $86				inc 	XS_Mantissa+XS_Size 		; bump it so we can use cc.
.018e66	d0 02		bne $018e6a			bne 	_LGRBump2
.018e68	e6 87		inc $87				inc 	XS_Mantissa+XS_Size+1
.018e6a					_LGRBump2:
.018e6a	60		rts				rts
.018e6b					_LGREnd:
.018e6b	c8		iny				iny
.018e6c					_LGRBlank:
.018e6c	a9 ff		lda #$ff			lda 	#$FF 						; default to the end.
.018e6e	85 86		sta $86				sta 	XS_Mantissa+XS_Size
.018e70	85 87		sta $87				sta 	XS_Mantissa+XS_Size+1
.018e72	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e74	c9 00		cmp #$00			cmp 	#0
.018e76	f0 f2		beq $018e6a			beq 	_LGRBump2
.018e78	0a		asl a				asl 	a 							; if not a number, then exit (to end)
.018e79	b0 ef		bcs $018e6a			bcs 	_LGRBump2
.018e7b	a2 06		ldx #$06			ldx 	#XS_Size 					; get to range
.018e7d	20 a1 92	jsr $0192a1			jsr 	EvaluateIntegerX
.018e80	80 e2		bra $018e64			bra 	_LGRBumpExit
.018e82	60		rts				rts
.018e83					ListCheckRange:
.018e83	c8		iny				iny
.018e84	a2 00		ldx #$00			ldx 	#0 							; test low
.018e86	20 93 8e	jsr $018e93			jsr 	_LCRCompare
.018e89	90 06		bcc $018e91			bcc 	_LCRFail
.018e8b	a2 06		ldx #$06			ldx 	#XS_Size 					; test high
.018e8d	20 93 8e	jsr $018e93			jsr 	_LCRCompare
.018e90	60		rts				rts
.018e91					_LCRFail:
.018e91	38		sec				sec
.018e92	60		rts				rts
.018e93					_LCRCompare:
.018e93	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e95	38		sec				sec
.018e96	f5 80		sbc $80,x			sbc	 	XS_Mantissa+0,x
.018e98	08		php				php
.018e99	c8		iny				iny
.018e9a	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e9c	28		plp				plp
.018e9d	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.018e9f	08		php				php
.018ea0	88		dey				dey
.018ea1	28		plp				plp
.018ea2	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/print.asm

.018ea3					Command_PRINT:
.018ea3					_CPR_Loop:
.018ea3	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018ea5	c9 00		cmp #$00			cmp 	#0 							; end
.018ea7	f0 24		beq $018ecd			beq 	_CPR_GoNewLine
.018ea9	c9 c0		cmp #$c0			cmp 	#token_Colon
.018eab	f0 20		beq $018ecd			beq 	_CPR_GoNewLine
.018ead	c9 c1		cmp #$c1			cmp 	#token_SemiColon
.018eaf	f0 74		beq $018f25			beq 	_CPR_Skip
.018eb1	c9 bf		cmp #$bf			cmp 	#token_Comma
.018eb3	f0 57		beq $018f0c			beq 	_CPR_Tab
.018eb5	20 09 91	jsr $019109			jsr 	EvaluateExpression 			; get expression.
.018eb8	a5 85		lda $85				lda 	XS_Type 					; get type.
.018eba	29 02		and #$02			and 	#2
.018ebc	d0 27		bne $018ee5			bne 	_CPR_String 				; if type = 2 output as string.
.018ebe					_CPR_Number:
.018ebe	a9 00		lda #$00			lda 	#0 							; reset buffer index
.018ec0	8d 14 03	sta $0314			sta 	NumBufX
.018ec3	a5 85		lda $85				lda 	XS_Type 					; get type
.018ec5	4a		lsr a				lsr 	a
.018ec6	b0 08		bcs $018ed0			bcs 	_CPRInt 					; if msb set do as integer
.018ec8	20 f0 a3	jsr $01a3f0			jsr 	FPToString 					; call fp to str otherwise
.018ecb	80 06		bra $018ed3			bra 	_CPRNPrint
.018ecd					_CPR_GoNewLine:
.018ecd	4c 33 8f	jmp $018f33			jmp 	_CPR_NewLine
.018ed0	20 78 9e	jsr $019e78	_CPRInt:jsr 	IntToString
.018ed3					_CPRNPrint:
.018ed3	ad 15 03	lda $0315			lda 	Num_Buffer 					; is first character -
.018ed6	c9 2d		cmp #$2d			cmp 	#"-"
.018ed8	f0 05		beq $018edf			beq 	_CPRNoSpace
.018eda	a9 20		lda #$20			lda 	#" "						; print the leading space
.018edc	20 32 85	jsr $018532			jsr 	VIOCharPrint 				; so beloved of MS Basics.
.018edf					_CPRNoSpace:
.018edf	a2 14		ldx #$14			ldx 	#(Num_Buffer-1) & $FF
.018ee1	a9 03		lda #$03			lda 	#(Num_Buffer-1) >> 8
.018ee3	80 04		bra $018ee9			bra 	_CPRPrint
.018ee5					_CPR_String:
.018ee5	a6 80		ldx $80				ldx 	XS_Mantissa
.018ee7	a5 81		lda $81				lda 	XS_Mantissa+1
.018ee9					_CPRPrint:
.018ee9	86 1e		stx $1e				stx 	zGenPtr
.018eeb	85 1f		sta $1f				sta 	zGenPtr+1
.018eed	5a		phy				phy
.018eee	a0 00		ldy #$00			ldy 	#0							; get length into X
.018ef0	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018ef2	aa		tax				tax
.018ef3	f0 09		beq $018efe			beq 	_CPREndPrint 				; nothing to print
.018ef5					_CPRLoop:
.018ef5	c8		iny				iny
.018ef6	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018ef8	20 32 85	jsr $018532			jsr 	VIOCharPrint
.018efb	ca		dex				dex
.018efc	d0 f7		bne $018ef5			bne 	_CPRLoop
.018efe					_CPREndPrint:
.018efe	a5 85		lda $85				lda 	XS_Type 					; if numeric add trailing space
.018f00	29 02		and #$02			and 	#2
.018f02	d0 05		bne $018f09			bne 	_CPRNoTrail
.018f04	a9 20		lda #$20			lda 	#" "
.018f06	20 32 85	jsr $018532			jsr 	VIOCharPrint
.018f09					_CPRNoTrail:
.018f09	7a		ply				ply
.018f0a	80 97		bra $018ea3			bra 	_CPR_Loop
.018f0c					_CPR_Tab:
.018f0c	20 43 85	jsr $018543			jsr 	VIOCharGetPosition 			; print until position % 8 = 0
.018f0f					_CPR_CalcSpaces:
.018f0f	38		sec				sec 								; calculate position mod 10.
.018f10	e9 0a		sbc #$0a			sbc 	#10
.018f12	b0 fb		bcs $018f0f			bcs 	_CPR_CalcSpaces
.018f14	69 0a		adc #$0a			adc 	#10
.018f16	f0 0d		beq $018f25			beq 	_CPR_Skip 					; nothing to print
.018f18	aa		tax				tax 								; print out spaces to mod 10
.018f19					_CPRTabSpaces:
.018f19	a9 20		lda #$20			lda 	#" "
.018f1b	20 32 85	jsr $018532			jsr 	VIOCharPrint
.018f1e	e8		inx				inx
.018f1f	e0 0a		cpx #$0a			cpx 	#10
.018f21	d0 f6		bne $018f19			bne 	_CPRTabSpaces
.018f23	80 e7		bra $018f0c			bra 	_CPR_Tab
.018f25					_CPR_Skip:
.018f25	c8		iny				iny
.018f26	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018f28	c9 c0		cmp #$c0			cmp 	#token_Colon 				; colon or $00, exit
.018f2a	f0 0c		beq $018f38			beq 	_CPR_Exit
.018f2c	c9 00		cmp #$00			cmp 	#0
.018f2e	f0 08		beq $018f38			beq 	_CPR_Exit 					; if not go round again.
.018f30	4c a3 8e	jmp $018ea3			jmp 	_CPR_Loop
.018f33					_CPR_NewLine:
.018f33	a9 0d		lda #$0d			lda 	#13
.018f35	20 32 85	jsr $018532			jsr 	VIOCharPrint
.018f38					_CPR_Exit:
.018f38	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/assert.asm

.018f39					Command_ASSERT:
.018f39	20 9f 92	jsr $01929f			jsr 	EvaluateInteger 			; calculate thing being asserted, 0=>X
.018f3c	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; check if true (non-zero)
.018f3e	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.018f40	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.018f42	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.018f44	f0 01		beq $018f47			beq 	_ASFail
.018f46	60		rts				rts
.018f47					_ASFail:
.018f47	20 79 85	jsr $018579			jsr ERR_Handler
>018f4a	41 73 73 65 72 74 00			.text "Assert",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/poke.asm

.018f51					Command_POKE:
.018f51	a9 01		lda #$01			lda 	#1 							; 1 byte
.018f53	80 06		bra $018f5b			bra 	CmdPoke_Main
.018f55					Command_DOKE:
.018f55	a9 02		lda #$02			lda 	#2 							; 2 bytes
.018f57	80 02		bra $018f5b			bra 	CmdPoke_Main
.018f59					Command_LOKE:
.018f59	a9 04		lda #$04			lda 	#4							; 4 bytes
.018f5b					CmdPoke_Main:
.018f5b	48		pha				pha
.018f5c	20 9f 92	jsr $01929f			jsr 	EvaluateInteger 			; get two parameters. First is address
.018f5f	e8		inx				inx
.018f60	e8		inx				inx
.018f61	e8		inx				inx
.018f62	e8		inx				inx
.018f63	e8		inx				inx
.018f64	e8		inx				inx
.018f65	20 f0 98	jsr $0198f0			jsr 	CheckNextComma
.018f68	20 a1 92	jsr $0192a1			jsr 	EvaluateIntegerX 			; second is the data.
.018f6b	a5 80		lda $80				lda 	XS_Mantissa+0 				; copy the mantissa into ZLTemp1 (address)
.018f6d	85 1a		sta $1a				sta 	zLTemp1
.018f6f	a5 81		lda $81				lda 	XS_Mantissa+1
.018f71	85 1b		sta $1b				sta 	zLTemp1+1
.018f73	a5 82		lda $82				lda 	XS_Mantissa+2
.018f75	85 1c		sta $1c				sta 	zLTemp1+2
.018f77	a5 83		lda $83				lda 	XS_Mantissa+3
.018f79	85 1d		sta $1d				sta 	zLTemp1+3
.018f7b	68		pla				pla 								; get count
.018f7c	5a		phy				phy 								; save Y
.018f7d	20 7b 98	jsr $01987b			jsr 	MemWrite 					; write it out
.018f80	7a		ply				ply 								; restore Y and done.
.018f81	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/newold.asm

.018f82					Command_NEW:
.018f82	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018f84	85 16		sta $16				sta 	zCodePtr+0
.018f86	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018f88	85 17		sta $17				sta 	zCodePtr+1
.018f8a	a9 00		lda #$00			lda 	#0
.018f8c	85 18		sta $18				sta 	zCodePtr+2
.018f8e	85 19		sta $19				sta 	zCodePtr+3
.018f90	a0 03		ldy #$03			ldy 	#3
.018f92	a0 00		ldy #$00			ldy 	#0
.018f94	a9 00		lda #$00			lda 	#0 							; write a 0 there.
.018f96	97 16		sta [$16],y			sta 	[zCodePtr],y
.018f98	20 8c 98	jsr $01988c			jsr 	UpdateProgramEnd 			; update program end.
.018f9b	4c 32 88	jmp $018832			jmp 	WarmStart
.018f9e					Command_OLD:
.018f9e	ea		nop				nop
.018f9f	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018fa1	85 16		sta $16				sta 	zCodePtr+0
.018fa3	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018fa5	85 17		sta $17				sta 	zCodePtr+1
.018fa7	a9 00		lda #$00			lda 	#0
.018fa9	85 18		sta $18				sta 	zCodePtr+2
.018fab	85 19		sta $19				sta 	zCodePtr+3
.018fad	a0 03		ldy #$03			ldy 	#3
.018faf					_COL_Find:
.018faf	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018fb1	c8		iny				iny
.018fb2	c9 00		cmp #$00			cmp 	#0 							; if zero, then the position Y/Z is new offset
.018fb4	f0 18		beq $018fce			beq 	_COL_Found
.018fb6	98		tya				tya
.018fb7	c9 00		cmp #$00			cmp 	#0
.018fb9	d0 f4		bne $018faf			bne 	_COL_Find 					; can't find old EOL, give up.
.018fbb	20 79 85	jsr $018579			jsr ERR_Handler
>018fbe	50 72 6f 67 72 61 6d 20			.text "Program Corrupt",0
>018fc6	43 6f 72 72 75 70 74 00
.018fce					_COL_Found:
.018fce	98		tya				tya
.018fcf	48		pha				pha
.018fd0	a0 00		ldy #$00			ldy 	#0
.018fd2	68		pla				pla
.018fd3	97 16		sta [$16],y			sta 	[zCodePtr],y
.018fd5	20 8c 98	jsr $01988c			jsr 	UpdateProgramEnd 			; reset variable pointer
.018fd8	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/branch.asm

.018fd9					Command_GOTO:
.018fd9	20 2e 90	jsr $01902e			jsr 	GotoGetLineNumber
.018fdc					CmdGOTO:
.018fdc	a2 00		ldx #$00			ldx 	#0
.018fde	4c 4b 90	jmp $01904b			jmp 	GotoChangeToLineNumberX
.018fe1					Command_GOSUB:
.018fe1	20 2e 90	jsr $01902e			jsr 	GotoGetLineNumber
.018fe4					CmdGOSUB:
.018fe4	20 f9 84	jsr $0184f9			jsr 	StackSavePosition
.018fe7	a9 15		lda #$15			lda 	#(SMark_Gosub << 4)+SourcePosSize
.018fe9	20 b2 84	jsr $0184b2			jsr 	StackPushFrame
.018fec	a2 00		ldx #$00			ldx		#0
.018fee	4c 4b 90	jmp $01904b			jmp 	GotoChangeToLineNumberX
.018ff1					Command_RETURN:
.018ff1	a9 10		lda #$10			lda 	#(SMark_Gosub << 4)
.018ff3	20 c9 84	jsr $0184c9			jsr 	StackPopFrame
.018ff6	20 16 85	jsr $018516			jsr 	StackRestorePosition
.018ff9	60		rts				rts
.018ffa					Command_ON:
.018ffa	a2 00		ldx #$00			ldx 	#0 							; get the ON.
.018ffc	20 3e 97	jsr $01973e			jsr 	SLIByteParameter
.018fff	a5 80		lda $80				lda 	XS_Mantissa+0 				; get the count
.019001	f0 28		beq $01902b			beq 	_CONFail 					; can't be zero.
.019003	aa		tax				tax 								; save in X.
.019004	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019006	c8		iny				iny
.019007	48		pha				pha
.019008	c9 cc		cmp #$cc			cmp 	#token_GOTO 				; must be GOTO or GOSUB
.01900a	f0 07		beq $019013			beq 	_CONOkayToken
.01900c	c9 ca		cmp #$ca			cmp 	#token_GOSUB
.01900e	f0 03		beq $019013			beq 	_CONOkayToken
.019010	4c 4a 85	jmp $01854a			jmp 	SyntaxError
.019013					_CONOkayToken:
.019013	da		phx				phx 								; count on top, GOTO/GOSUB token 2nd.
.019014					_CONFindNumber:
.019014	20 2e 90	jsr $01902e			jsr 	GotoGetLineNumber 			; get a line number.
.019017	fa		plx				plx 								; restore count
.019018	ca		dex				dex  								; decrement, exit if zero.
.019019	f0 06		beq $019021			beq 	_CONFound
.01901b	da		phx				phx 								; push back
.01901c	20 f0 98	jsr $0198f0			jsr 	CheckNextComma				; check for comma
.01901f	80 f3		bra $019014			bra 	_CONFindNumber
.019021					_CONFound:
.019021	68		pla				pla 								; get token
.019022	c9 cc		cmp #$cc			cmp 	#token_GOTO 				; if GOTO
.019024	f0 b6		beq $018fdc			beq		CmdGOTO 					; then just branch.
.019026	20 80 84	jsr $018480			jsr 	SkipEndOfCommand 			; go to end of command
.019029	80 b9		bra $018fe4			bra 	CmdGOSUB 					; and do a GOSUB.
.01902b					_CONFail:
.01902b	4c 68 85	jmp $018568			jmp 	BadParamError
.01902e					GotoGetLineNumber:
.01902e	20 9f 92	jsr $01929f			jsr 	EvaluateInteger
.019031	a5 82		lda $82				lda 	XS_Mantissa+2 				; check range
.019033	05 83		ora $83				ora 	XS_Mantissa+3
.019035	d0 01		bne $019038			bne 	_GLINError
.019037	60		rts				rts
.019038					_GLINError:
.019038	20 79 85	jsr $018579			jsr ERR_Handler
>01903b	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>019043	20 4e 75 6d 62 65 72 00
.01904b					GotoChangeToLineNumberX:
.01904b	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check line number not zero
.01904d	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.01904f	f0 37		beq $019088			beq 	_GCTLFail
.019051	a9 00		lda #$00			lda 	#BasicProgram & $FF
.019053	85 16		sta $16				sta 	zCodePtr+0
.019055	a9 10		lda #$10			lda 	#BasicProgram >> 8
.019057	85 17		sta $17				sta 	zCodePtr+1
.019059	a9 00		lda #$00			lda 	#0
.01905b	85 18		sta $18				sta 	zCodePtr+2
.01905d	85 19		sta $19				sta 	zCodePtr+3
.01905f	a0 03		ldy #$03			ldy 	#3
.019061					_GCTLLoop:
.019061	a0 00		ldy #$00			ldy 	#0
.019063	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019065	c9 00		cmp #$00			cmp 	#0
.019067	f0 1f		beq $019088			beq 	_GCTLFail
.019069	c8		iny				iny
.01906a	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01906c	d5 80		cmp $80,x			cmp 	XS_Mantissa+0,x
.01906e	d0 07		bne $019077			bne 	_GCTLNext
.019070	c8		iny				iny
.019071	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019073	d5 81		cmp $81,x			cmp 	XS_Mantissa+1,x
.019075	f0 0f		beq $019086			beq 	_GCTLExit
.019077					_GCTLNext:
.019077	a0 00		ldy #$00			ldy 	#0 							; point to offset
.019079	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.01907b	18		clc				clc
.01907c	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.01907e	85 16		sta $16				sta 	zCodePtr
.019080	90 02		bcc $019084			bcc 	_SNLNoCarry
.019082	e6 17		inc $17				inc 	zCodePtr+1
.019084					_SNLNoCarry:
.019084	80 db		bra $019061			bra 	_GCTLLoop 					; try next line.
.019086					_GCTLExit:
.019086	c8		iny				iny
.019087	60		rts				rts
.019088					_GCTLFail:
.019088	20 79 85	jsr $018579			jsr ERR_Handler
>01908b	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>019093	20 4e 75 6d 62 65 72 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.01909b					Command_CLR:
.01909b					ResetRunStatus:
.01909b	20 d2 99	jsr $0199d2			jsr 	VariableClear
.01909e	20 a0 84	jsr $0184a0			jsr 	StackReset
.0190a1	a9 00		lda #$00			lda 	#HighMemory & $FF
.0190a3	8d 00 03	sta $0300			sta 	StringPtr
.0190a6	a9 7f		lda #$7f			lda 	#HighMemory >> 8
.0190a8	8d 01 03	sta $0301			sta 	StringPtr+1
.0190ab	20 9c 9b	jsr $019b9c			jsr 	ArrayResetDefault
.0190ae	20 ed 8a	jsr $018aed			jsr 	Command_RESTORE
.0190b1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/stop.asm

.0190b2					Command_STOP:
.0190b2	20 79 85	jsr $018579			jsr ERR_Handler
>0190b5	53 74 6f 70 00				.text "Stop",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/while.asm

.0190ba					Command_WHILE:
.0190ba	20 f9 84	jsr $0184f9			jsr 	StackSavePosition			; save position into stack, but don't yet push.
.0190bd	20 9f 92	jsr $01929f			jsr 	EvaluateInteger 			; calculate the while loop value.
.0190c0	a5 80		lda $80				lda 	XS_Mantissa+0				; check the result if zero
.0190c2	05 81		ora $81				ora 	XS_Mantissa+1
.0190c4	05 82		ora $82				ora 	XS_Mantissa+2
.0190c6	05 83		ora $83				ora 	XS_Mantissa+3
.0190c8	f0 06		beq $0190d0			beq 	_CWHSkip 					; if it is zero, then skip to WEND.
.0190ca	a9 35		lda #$35			lda 	#(SMark_While << 4)+SourcePosSize
.0190cc	20 b2 84	jsr $0184b2			jsr 	StackPushFrame 				; push on stack
.0190cf	60		rts				rts
.0190d0					_CWHSkip:
.0190d0	a9 95		lda #$95			lda 	#token_Wend 				; look for the WEND token.
.0190d2	20 f3 83	jsr $0183f3			jsr 	StructureSearchSingle
.0190d5	c8		iny				iny
.0190d6	60		rts				rts
.0190d7					Command_WEND:
.0190d7	a9 30		lda #$30			lda 	#(SMark_While << 4)			; remove the frame
.0190d9	20 c9 84	jsr $0184c9			jsr 	StackPopFrame
.0190dc	20 16 85	jsr $018516			jsr 	StackRestorePosition
.0190df	80 d9		bra $0190ba			bra 	Command_WHILE 				; and do the while again.
.0190e1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/repeat.asm

.0190e2					Command_REPEAT:
.0190e2	20 f9 84	jsr $0184f9			jsr 	StackSavePosition			; save position into stack
.0190e5	a9 25		lda #$25			lda 	#(SMark_Repeat << 4)+SourcePosSize
.0190e7	20 b2 84	jsr $0184b2			jsr 	StackPushFrame 				; push on stack
.0190ea	60		rts				rts
.0190eb					Command_UNTIL:
.0190eb	a9 20		lda #$20			lda 	#(SMark_Repeat << 4)		; remove the frame
.0190ed	20 c9 84	jsr $0184c9			jsr 	StackPopFrame
.0190f0	20 9f 92	jsr $01929f			jsr 	EvaluateInteger				; work out UNTIL
.0190f3	a5 80		lda $80				lda 	XS_Mantissa+0 				; check if zero.
.0190f5	05 81		ora $81				ora 	XS_Mantissa+1
.0190f7	05 82		ora $82				ora 	XS_Mantissa+2
.0190f9	05 83		ora $83				ora 	XS_Mantissa+3
.0190fb	d0 08		bne $019105			bne 	_CUTExit 					; if not, just exit
.0190fd	20 16 85	jsr $018516			jsr 	StackRestorePosition 		; otherwise loop round again.
.019100	a9 25		lda #$25			lda 	#(SMark_Repeat << 4)+SourcePosSize
.019102	20 b2 84	jsr $0184b2			jsr 	StackPushFrame 				; fix the stack back.
.019105					_CUTExit:
.019105	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.019106					EVESyntax:
.019106	4c 4a 85	jmp $01854a			jmp 	SyntaxError
.019109					EvaluateExpression:
.019109	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.01910b					EvaluateExpressionX:
.01910b	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.01910d					EvaluateExpressionXA:
.01910d	48		pha				pha 								; save precedence on stack.
.01910e	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019110	f0 f4		beq $019106			beq 	EVESyntax 					; end of line, syntax error.
.019112	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.019114	b0 03		bcs $019119			bcs 	_EVNotVariable
.019116	4c e3 91	jmp $0191e3			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.019119					_EVNotVariable:
.019119	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.01911b	90 e9		bcc $019106			bcc 	EVESyntax
.01911d	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.01911f	b0 58		bcs $019179			bcs 	_EVNotInteger
.019121	20 11 92	jsr $019211			jsr 	EvaluateGetInteger
.019124					_EVCheckDecimal:
.019124	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019126	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.019128	d0 05		bne $01912f			bne 	_EVGotAtom 					; no, get atom.
.01912a					_EVIsDecimal:
.01912a	20 37 92	jsr $019237			jsr 	EVGetDecimal 				; extend to the decimal part.
.01912d	80 00		bra $01912f			bra 	_EVGotAtom 					; and continue to got atom.
.01912f					_EVGotAtom:
.01912f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019131	10 44		bpl $019177			bpl 	_EVExitDrop 				; must be a token.
.019133	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.019135	b0 40		bcs $019177			bcs 	_EVExitDrop
.019137	68		pla				pla 								; get current precedence
.019138	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.01913a	da		phx				phx 								; save X
.01913b	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01913d	aa		tax				tax 								; put in X
.01913e	bf 2e 86 01	lda $01862e,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.019142	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.019144	fa		plx				plx 								; restore X
.019145	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.019147	90 2f		bcc $019178			bcc 	_EVExit 					; exit if too low.
.019149	f0 2d		beq $019178			beq 	_EVExit 					; exit if equals
.01914b	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.01914d	48		pha				pha
.01914e	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019150	48		pha				pha
.019151	c8		iny				iny
.019152	da		phx				phx 								; save current position
.019153	e8		inx				inx
.019154	e8		inx				inx
.019155	e8		inx				inx
.019156	e8		inx				inx
.019157	e8		inx				inx
.019158	e8		inx				inx
.019159	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.01915b	20 0d 91	jsr $01910d			jsr 	EvaluateExpressionXA 		; do the RHS.
.01915e	fa		plx				plx 								; restore X
.01915f	68		pla				pla 								; get the binary operator in A.
.019160					_EVCallA:
.019160	da		phx				phx 								; save X again
.019161	0a		asl a				asl 	a 							; double, lose the MSB.
.019162	aa		tax				tax									; put in X
.019163	bf dd 85 01	lda $0185dd,x			lda 	VectorTable,x 				; copy address into zGenPtr
.019167	8d 11 03	sta $0311			sta 	LocalVector+1
.01916a	bf de 85 01	lda $0185de,x			lda 	VectorTable+1,x
.01916e	8d 12 03	sta $0312			sta 	LocalVector+2
.019171	fa		plx				plx 								; restore X
.019172	20 ec 91	jsr $0191ec			jsr 	EVCallLocalVector
.019175	80 b8		bra $01912f			bra 	_EVGotAtom 					; and loop back.
.019177					_EVExitDrop:
.019177	68		pla				pla
.019178					_EVExit:
.019178	60		rts				rts
.019179					_EVNotInteger:
.019179	c8		iny				iny
.01917a	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.01917c	d0 16		bne $019194			bne 	_EVNotMinus
.01917e	20 80 92	jsr $019280			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.019181	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.019183	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.019185	f0 05		beq $01918c			beq 	_EVMinusFloat
.019187	20 5b 9e	jsr $019e5b			jsr 	IntegerNegateAlways 		; negation
.01918a	80 a3		bra $01912f			bra 	_EVGotAtom 					; and go back.
.01918c					_EVMinusFloat:
.01918c	b5 85		lda $85,x			lda 	XS_Type,x 					; invert the sign bit.
.01918e	49 80		eor #$80			eor 	#$80
.019190	95 85		sta $85,x			sta 	XS_Type,x
.019192	80 9b		bra $01912f			bra 	_EVGotAtom
.019194					_EVNotMinus:
.019194	c9 bd		cmp #$bd			cmp 	#token_lparen 				; is it left parenthesis
.019196	d0 17		bne $0191af			bne 	_EVNotParenthesis
.019198	20 0b 91	jsr $01910b			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.01919b	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01919d	c8		iny				iny
.01919e	c9 be		cmp #$be			cmp 	#token_rparen 				; okay if right bracket.
.0191a0	f0 8d		beq $01912f			beq 	_EVGotAtom
.0191a2	20 79 85	jsr $018579			jsr ERR_Handler
>0191a5	4d 69 73 73 69 6e 67 20			.text "Missing )",0
>0191ad	29 00
.0191af					_EVNotParenthesis:
.0191af	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.0191b1	d0 0c		bne $0191bf			bne 	_EVNotNot
.0191b3	20 80 92	jsr $019280			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.0191b6	20 f1 a2	jsr $01a2f1			jsr 	FPUToInteger 				; make it an integer - if possible.
.0191b9	20 65 92	jsr $019265			jsr 	NotInteger 					; do the not calculation
.0191bc	4c 2f 91	jmp $01912f			jmp 	_EVGotAtom
.0191bf					_EVNotNot:
.0191bf	c9 fe		cmp #$fe			cmp 	#$FE
.0191c1	d0 12		bne $0191d5			bne 	_EVNotString
.0191c3	20 70 99	jsr $019970			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.0191c6	a5 20		lda $20				lda 	zTempStr 					; copy address of string into mantissa
.0191c8	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0191ca	a5 21		lda $21				lda 	zTempStr+1
.0191cc	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0191ce	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.0191d0	95 85		sta $85,x			sta 	XS_Type,x
.0191d2	4c 2f 91	jmp $01912f			jmp 	_EVGotAtom
.0191d5					_EVNotString:
.0191d5	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.0191d7	90 04		bcc $0191dd			bcc 	_EVBadElement
.0191d9	c9 b7		cmp #$b7			cmp 	#lastUnaryFunction+1
.0191db	90 03		bcc $0191e0			bcc 	_EVUnaryFunction
.0191dd					_EVBadElement:
.0191dd	4c 4a 85	jmp $01854a			jmp 	SyntaxError
.0191e0					_EVUnaryFunction:
.0191e0	4c 60 91	jmp $019160			jmp 	_EVCallA
.0191e3					_EVVariableHandler:
.0191e3	20 96 99	jsr $019996			jsr 	VariableFind 				; locate a variable
.0191e6	20 de 9c	jsr $019cde			jsr 	VariableGet 				; copy into memory.
.0191e9	4c 2f 91	jmp $01912f			jmp 	_EVGotAtom 					; and go round.
.0191ec					EVCallLocalVector:
.0191ec	6c 11 03	jmp ($0311)			jmp 	(LocalVector+1)
.0191ef					EVShiftMantissaLeft6:
.0191ef	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.0191f1	95 84		sta $84,x			sta 	XS_Exponent,x
.0191f3	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0191f5	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0191f7	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0191f9	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0191fb	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0191fd	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0191ff	a9 00		lda #$00			lda 	#0
.019201	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019203	20 06 92	jsr $019206			jsr 	_EVSMLShift 					; call it here to do it twice
.019206					_EVSMLShift:
.019206	56 84		lsr $84,x			lsr 	XS_Exponent,x
.019208	76 83		ror $83,x			ror 	XS_Mantissa+3,x
.01920a	76 82		ror $82,x			ror 	XS_Mantissa+2,x
.01920c	76 81		ror $81,x			ror 	XS_Mantissa+1,x
.01920e	76 80		ror $80,x			ror 	XS_Mantissa+0,x
.019210	60		rts				rts
.019211					EvaluateGetInteger:
.019211	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019213	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.019215	95 80		sta $80,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.019217	a9 00		lda #$00			lda 	#0
.019219	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01921b	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01921d	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01921f	1a		inc a				inc 	a 							; set to type 1 (integer)
.019220	95 85		sta $85,x			sta 	XS_Type,x
.019222					_EVCheckNextInteger:
.019222	c8		iny				iny
.019223	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019225	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.019227	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.019229	b0 0b		bcs $019236			bcs 	_EVEndInteger
.01922b	48		pha				pha 								; save it.
.01922c	20 ef 91	jsr $0191ef			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.01922f	68		pla				pla
.019230	15 80		ora $80,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.019232	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019234	80 ec		bra $019222			bra 	_EVCheckNextInteger
.019236					_EVEndInteger:
.019236	60		rts				rts
.019237					EVGetDecimal:
.019237	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.019239	8d 15 03	sta $0315			sta 	Num_Buffer
.01923c	da		phx				phx
.01923d	c8		iny				iny
.01923e	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019240	c8		iny				iny
.019241	3a		dec a				dec 	a								; convert to a string length.
.019242	3a		dec a				dec 	a
.019243	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.019245					_EVGDCopy:
.019245	48		pha				pha 									; save count
.019246	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019248	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.01924b	e8		inx				inx 									; forward ....
.01924c	c8		iny				iny
.01924d	68		pla				pla 									; get count
.01924e	3a		dec a				dec 	a 								; until zero
.01924f	d0 f4		bne $019245			bne 	_EVGDCopy
.019251	9d 15 03	sta $0315,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.019254	fa		plx				plx 									; restore X
.019255	a9 15		lda #$15			lda 	#Num_Buffer & $FF 				; set zGenPtr
.019257	85 1e		sta $1e				sta 	zGenPtr
.019259	a9 03		lda #$03			lda 	#Num_Buffer >> 8
.01925b	85 1f		sta $1f				sta 	zGenPtr+1
.01925d	5a		phy				phy 									; save Y
.01925e	a0 00		ldy #$00			ldy 	#0 								; start position
.019260	20 ab a4	jsr $01a4ab			jsr 	FPFromString 					; convert current
.019263	7a		ply				ply 									; restore Y
.019264	60		rts				rts
.019265					NotInteger:
.019265	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019267	49 ff		eor #$ff			eor 	#$FF
.019269	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01926b	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01926d	49 ff		eor #$ff			eor 	#$FF
.01926f	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019271	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019273	49 ff		eor #$ff			eor 	#$FF
.019275	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019277	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019279	49 ff		eor #$ff			eor 	#$FF
.01927b	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01927d	60		rts				rts
.01927e					EvaluateGetAtom:
.01927e	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.019280					EvaluateGetAtomX:
.019280	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.019282	20 0d 91	jsr $01910d			jsr 	EvaluateExpressionXA
.019285	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.019287	29 0f		and #$0f			and 	#15
.019289	c9 02		cmp #$02			cmp 	#2
.01928b	b0 01		bcs $01928e			bcs 	EvaluateType
.01928d	60		rts				rts
.01928e					EvaluateType:
.01928e	4c 5a 85	jmp $01855a			jmp 	TypeError
.019291					EvaluateNumber:
.019291	a2 00		ldx #$00			ldx 	#0
.019293					EvaluateNumberX:
.019293	20 0b 91	jsr $01910b			jsr 	EvaluateExpressionX
.019296	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0/1
.019298	29 0f		and #$0f			and 	#15
.01929a	c9 02		cmp #$02			cmp 	#2
.01929c	b0 f0		bcs $01928e			bcs 	EvaluateType
.01929e	60		rts				rts
.01929f					EvaluateInteger:
.01929f	a2 00		ldx #$00			ldx 	#0
.0192a1					EvaluateIntegerX:
.0192a1	20 93 92	jsr $019293			jsr 	EvaluateNumberX
.0192a4	20 f1 a2	jsr $01a2f1			jsr 	FPUToInteger
.0192a7	60		rts				rts
.0192a8					EvaluateString:
.0192a8	a2 00		ldx #$00			ldx 	#0
.0192aa					EvaluateStringX:
.0192aa	20 0b 91	jsr $01910b			jsr 	EvaluateExpressionX
.0192ad	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 2
.0192af	29 0f		and #$0f			and 	#15
.0192b1	c9 02		cmp #$02			cmp 	#2
.0192b3	d0 d9		bne $01928e			bne 	EvaluateType
.0192b5	b5 80		lda $80,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.0192b7	85 1e		sta $1e				sta 	zGenPtr
.0192b9	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0192bb	85 1f		sta $1f				sta 	zGenPtr+1
.0192bd	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.0192be					BinaryOp_And:
.0192be	20 12 93	jsr $019312			jsr 	BinaryMakeBothInteger
.0192c1	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.0192c3	35 86		and $86,x			and 	XS2_Mantissa+0,x
.0192c5	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0192c7	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.0192c9	35 87		and $87,x			and 	XS2_Mantissa+1,x
.0192cb	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0192cd	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.0192cf	35 88		and $88,x			and 	XS2_Mantissa+2,x
.0192d1	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0192d3	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.0192d5	35 89		and $89,x			and 	XS2_Mantissa+3,x
.0192d7	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0192d9	60		rts				rts
.0192da					BinaryOp_Or:
.0192da	20 12 93	jsr $019312			jsr 	BinaryMakeBothInteger
.0192dd	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.0192df	15 86		ora $86,x			ora 	XS2_Mantissa+0,x
.0192e1	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0192e3	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.0192e5	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.0192e7	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0192e9	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.0192eb	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.0192ed	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0192ef	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.0192f1	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.0192f3	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0192f5	60		rts				rts
.0192f6					BinaryOp_Eor:
.0192f6					BinaryOp_Xor:
.0192f6	20 12 93	jsr $019312			jsr 	BinaryMakeBothInteger
.0192f9	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.0192fb	55 86		eor $86,x			eor 	XS2_Mantissa+0,x
.0192fd	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0192ff	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.019301	55 87		eor $87,x			eor 	XS2_Mantissa+1,x
.019303	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019305	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.019307	55 88		eor $88,x			eor 	XS2_Mantissa+2,x
.019309	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01930b	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.01930d	55 89		eor $89,x			eor 	XS2_Mantissa+3,x
.01930f	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019311	60		rts				rts
.019312					BinaryMakeBothInteger:
.019312	da		phx				phx 								; save X
.019313	e8		inx				inx
.019314	e8		inx				inx
.019315	e8		inx				inx
.019316	e8		inx				inx
.019317	e8		inx				inx
.019318	e8		inx				inx
.019319	20 1d 93	jsr $01931d			jsr 	BinaryMakeInteger 			; convert to integer.
.01931c	fa		plx				plx 								; restore X and fall through.
.01931d					BinaryMakeInteger:
.01931d	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.01931f	29 0f		and #$0f			and 	#15 						; check type zero
.019321	f0 04		beq $019327			beq 	_BMIConvert 				; if float convert to integer.
.019323	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.019324	90 04		bcc $01932a			bcc 	_BMIError
.019326	60		rts				rts
.019327					_BMIConvert:
.019327	4c f1 a2	jmp $01a2f1			jmp 	FPUToInteger 				; convert to integer
.01932a					_BMIError:
.01932a	4c 5a 85	jmp $01855a			jmp 	TypeError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.01932d					Binary_Equal:
.01932d	20 76 93	jsr $019376			jsr 	CompareValues 				; compare the values
.019330	09 00		ora #$00			ora 	#0 							; true if 0
.019332	f0 33		beq $019367			beq 	CCTrue
.019334	80 2d		bra $019363			bra 	CCFalse
.019336					Binary_NotEqual:
.019336	20 76 93	jsr $019376			jsr 	CompareValues
.019339	09 00		ora #$00			ora 	#0 							; true if -1 or 1
.01933b	f0 26		beq $019363			beq 	CCFalse
.01933d	80 28		bra $019367			bra 	CCTrue
.01933f					Binary_Less:
.01933f	20 76 93	jsr $019376			jsr 	CompareValues
.019342	09 00		ora #$00			ora 	#0 							; true if -1
.019344	30 21		bmi $019367			bmi 	CCTrue
.019346	80 1b		bra $019363			bra 	CCFalse
.019348					Binary_LessEqual:
.019348	20 76 93	jsr $019376			jsr 	CompareValues
.01934b	c9 01		cmp #$01			cmp 	#1 							; true if 0 or -1
.01934d	d0 18		bne $019367			bne 	CCTrue
.01934f	80 12		bra $019363			bra 	CCFalse
.019351					Binary_GreaterEqual:
.019351	20 76 93	jsr $019376			jsr 	CompareValues
.019354	09 00		ora #$00			ora 	#0 							; true if 0 or 1
.019356	10 0f		bpl $019367			bpl 	CCTrue
.019358	80 09		bra $019363			bra 	CCFalse
.01935a					Binary_Greater:
.01935a	20 76 93	jsr $019376			jsr 	CompareValues 				; true if 1
.01935d	c9 01		cmp #$01			cmp 	#1
.01935f	f0 06		beq $019367			beq 	CCTrue
.019361	80 00		bra $019363			bra 	CCFalse
.019363	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.019365	80 02		bra $019369			bra 	CCWrite
.019367	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.019369	95 80		sta $80,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.01936b	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01936d	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01936f	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019371	a9 01		lda #$01			lda 	#1
.019373	95 85		sta $85,x			sta 	XS_Type,x 					; set type to integer whatever.
.019375	60		rts				rts
.019376					CompareValues:
.019376	b5 85		lda $85,x			lda 	XS_Type,x 					; and the types together
.019378	35 8b		and $8b,x			and 	XS2_Type,x
.01937a	c9 02		cmp #$02			cmp 	#2 							; is it a string, then do the string
.01937c	f0 11		beq $01938f			beq 	_CVString					; comparison routine.
.01937e	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.019380	35 8b		and $8b,x			and 	XS2_Type,x
.019382	4a		lsr a				lsr 	a 							; shift bit 0 into C
.019383	90 03		bcc $019388			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.019385	4c d1 93	jmp $0193d1			jmp 	CompareInteger32 							; so execute code at \1
.019388					_BCFloat:
.019388	20 75 94	jsr $019475			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.01938b	4c ea a1	jmp $01a1ea			jmp 	FPCompare 							; and execute code at \2
.01938e	60		rts				rts
.01938f					_CVString:
.01938f	da		phx				phx 								; save XY
.019390	5a		phy				phy
.019391	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.019393	85 1a		sta $1a				sta		zLTemp1+0
.019395	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019397	85 1b		sta $1b				sta 	zLTemp1+1
.019399	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.01939b	85 1c		sta $1c				sta 	zLTemp1+2
.01939d	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.01939f	85 1d		sta $1d				sta 	zLTemp1+3
.0193a1	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.0193a3	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.0193a5	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.0193a7	90 02		bcc $0193ab			bcc 	_CVCommon
.0193a9	b1 1c		lda ($1c),y			lda 	(zLTemp1+2),y
.0193ab					_CVCommon:
.0193ab	aa		tax				tax 								; put shorter string length in zero.
.0193ac	f0 0c		beq $0193ba			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.0193ae					_CVCompare:
.0193ae	c8		iny				iny 								; next character
.0193af	b1 1a		lda ($1a),y			lda 	(zLTemp1),y 				; compare characters
.0193b1	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y 				; handle different values, < or >
.0193b3	90 13		bcc $0193c8			bcc 	_CVReturnLess 				; <
.0193b5	d0 15		bne $0193cc			bne 	_CVReturnGreater 			; >
.0193b7	ca		dex				dex 								; until common length matched.
.0193b8	d0 f4		bne $0193ae			bne 	_CVCompare
.0193ba					_CVMatch:
.0193ba	a0 00		ldy #$00			ldy 	#0
.0193bc	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.0193be	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.0193c0	90 06		bcc $0193c8			bcc 	_CVReturnLess 				; <
.0193c2	d0 08		bne $0193cc			bne 	_CVReturnGreater 			; >
.0193c4	a9 00		lda #$00			lda 	#0
.0193c6	80 06		bra $0193ce			bra 	_CVExit
.0193c8					_CVReturnLess:
.0193c8	a9 ff		lda #$ff			lda 	#$FF
.0193ca	80 02		bra $0193ce			bra 	_CVExit
.0193cc					_CVReturnGreater:
.0193cc	a9 01		lda #$01			lda 	#$01
.0193ce					_CVExit:
.0193ce	7a		ply				ply
.0193cf	fa		plx				plx
.0193d0	60		rts				rts
.0193d1					CompareInteger32:
.0193d1	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.0193d3	49 80		eor #$80			eor 	#$80
.0193d5	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0193d7	b5 89		lda $89,x			lda 	XS2_Mantissa+3,x
.0193d9	49 80		eor #$80			eor 	#$80
.0193db	95 89		sta $89,x			sta 	XS2_Mantissa+3,x
.0193dd	20 5b 94	jsr $01945b			jsr 	SubInteger32 				; subtraction
.0193e0	90 0d		bcc $0193ef			bcc 	_CI32Less 					; cc return -1
.0193e2	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check if zero
.0193e4	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.0193e6	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.0193e8	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.0193ea	f0 02		beq $0193ee			beq 	_CI32Exit
.0193ec	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.0193ee					_CI32Exit:
.0193ee	60		rts				rts
.0193ef					_CI32Less:
.0193ef	a9 ff		lda #$ff			lda 	#$FF
.0193f1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.0193f2					BinaryOp_Add:
.0193f2	b5 85		lda $85,x			lda 	XS_Type,x  					; and types together
.0193f4	35 8b		and $8b,x			and 	XS2_Type,x
.0193f6	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.0193f8	d0 11		bne $01940b			bne 	_BOAString 					; so go do the string code.
.0193fa	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.0193fc	35 8b		and $8b,x			and 	XS2_Type,x
.0193fe	4a		lsr a				lsr 	a 							; shift bit 0 into C
.0193ff	90 03		bcc $019404			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.019401	4c 41 94	jmp $019441			jmp 	AddInteger32 							; so execute code at \1
.019404					_BCFloat:
.019404	20 75 94	jsr $019475			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.019407	4c c5 9f	jmp $019fc5			jmp 	FPAdd 							; and execute code at \2
.01940a	60		rts				rts
.01940b					_BOAString:
.01940b	4c 8f 94	jmp $01948f			jmp 	ConcatenateString 			; concatenate two strings.
.01940e					BinaryOp_Subtract:
.01940e	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.019410	35 8b		and $8b,x			and 	XS2_Type,x
.019412	4a		lsr a				lsr 	a 							; shift bit 0 into C
.019413	90 03		bcc $019418			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.019415	4c 5b 94	jmp $01945b			jmp 	SubInteger32 							; so execute code at \1
.019418					_BCFloat:
.019418	20 75 94	jsr $019475			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.01941b	4c bd 9f	jmp $019fbd			jmp 	FPSubtract 							; and execute code at \2
.01941e	60		rts				rts
.01941f					BinaryOp_Multiply:
.01941f	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.019421	35 8b		and $8b,x			and 	XS2_Type,x
.019423	4a		lsr a				lsr 	a 							; shift bit 0 into C
.019424	90 03		bcc $019429			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.019426	4c 96 9d	jmp $019d96			jmp 	MulInteger32 							; so execute code at \1
.019429					_BCFloat:
.019429	20 75 94	jsr $019475			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.01942c	4c ec a0	jmp $01a0ec			jmp 	FPMultiply 							; and execute code at \2
.01942f	60		rts				rts
.019430					BinaryOp_Divide:
.019430	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.019432	35 8b		and $8b,x			and 	XS2_Type,x
.019434	4a		lsr a				lsr 	a 							; shift bit 0 into C
.019435	90 03		bcc $01943a			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.019437	4c d4 9d	jmp $019dd4			jmp 	DivInteger32 							; so execute code at \1
.01943a					_BCFloat:
.01943a	20 75 94	jsr $019475			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.01943d	4c 79 a0	jmp $01a079			jmp 	FPDivide 							; and execute code at \2
.019440	60		rts				rts
.019441					AddInteger32:
.019441	18		clc				clc
.019442	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019444	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.019446	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019448	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01944a	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.01944c	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01944e	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019450	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.019452	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019454	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019456	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.019458	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01945a	60		rts				rts
.01945b					SubInteger32:
.01945b	38		sec				sec
.01945c	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01945e	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.019460	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019462	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019464	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.019466	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019468	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01946a	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.01946c	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01946e	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019470	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.019472	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019474	60		rts				rts
.019475					BinaryMakeBothFloat:
.019475	da		phx				phx 								; save X
.019476	e8		inx				inx
.019477	e8		inx				inx
.019478	e8		inx				inx
.019479	e8		inx				inx
.01947a	e8		inx				inx
.01947b	e8		inx				inx
.01947c	20 80 94	jsr $019480			jsr 	BinaryMakeFloat 			; convert to float.
.01947f	fa		plx				plx 								; restore X and fall through.
.019480					BinaryMakeFloat:
.019480	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.019482	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.019483	b0 04		bcs $019489			bcs 	_BMFConvert
.019485	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.019486	b0 04		bcs $01948c			bcs 	_BMFError
.019488	60		rts				rts
.019489					_BMFConvert:
.019489	4c a5 a2	jmp $01a2a5			jmp 	FPUToFloat 					; convert to float, only float builds of course
.01948c					_BMFError:
.01948c	4c 5a 85	jmp $01855a			jmp 	TypeError
.01948f					ConcatenateString:
.01948f	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.019491	85 1a		sta $1a				sta		zLTemp1+0
.019493	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019495	85 1b		sta $1b				sta 	zLTemp1+1
.019497	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.019499	85 1c		sta $1c				sta 	zLTemp1+2
.01949b	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.01949d	85 1d		sta $1d				sta 	zLTemp1+3
.01949f	5a		phy				phy
.0194a0	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.0194a2	b1 1a		lda ($1a),y			lda 	(zlTemp1),y
.0194a4	71 1c		adc ($1c),y			adc 	(zlTemp1+2),y
.0194a6	7a		ply				ply
.0194a7	b0 33		bcs $0194dc			bcs 	_CSError					; check in range.
.0194a9	c9 fe		cmp #$fe			cmp 	#maxString+1
.0194ab	b0 2f		bcs $0194dc			bcs 	_CSError
.0194ad	20 35 99	jsr $019935			jsr 	AllocateTempString 			; store the result
.0194b0	20 c7 94	jsr $0194c7			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.0194b3	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.0194b5	85 1a		sta $1a				sta 	zLTemp1
.0194b7	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.0194b9	85 1b		sta $1b				sta 	zLTemp1+1
.0194bb	20 c7 94	jsr $0194c7			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.0194be	a5 20		lda $20				lda 	zTempStr 					; point current to new string
.0194c0	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0194c2	a5 21		lda $21				lda 	zTempStr+1
.0194c4	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0194c6	60		rts				rts
.0194c7					_CSCopyString:
.0194c7	da		phx				phx
.0194c8	5a		phy				phy
.0194c9	a0 00		ldy #$00			ldy 	#0 							; get length
.0194cb	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.0194cd	f0 0a		beq $0194d9			beq 	_CSCSExit 					; if zero, exit immediately
.0194cf	aa		tax				tax 								; put in X which is the counter.
.0194d0					_CSCSLoop:
.0194d0	c8		iny				iny 								; get next char
.0194d1	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.0194d3	20 60 99	jsr $019960			jsr		WriteTempString 			; copy out to new string
.0194d6	ca		dex				dex 								; do whole string
.0194d7	d0 f7		bne $0194d0			bne 	_CSCSLoop
.0194d9					_CSCSExit:
.0194d9	7a		ply				ply
.0194da	fa		plx				plx
.0194db	60		rts				rts
.0194dc					_CSError:
.0194dc	20 79 85	jsr $018579			jsr ERR_Handler
>0194df	53 74 72 69 6e 67 20 74			.text "String too long",0
>0194e7	6f 6f 20 6c 6f 6e 67 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.0194ef					Unary_Sgn:
.0194ef	20 93 92	jsr $019293			jsr 	EvaluateNumberX 			; get value
.0194f2	20 e8 98	jsr $0198e8			jsr 	CheckNextRParen 			; check right bracket.
.0194f5	20 13 95	jsr $019513			jsr 	GetSignCurrent 				; get sign.
.0194f8	09 00		ora #$00			ora 	#0
.0194fa	10 08		bpl $019504			bpl		UnarySetAInteger			; if 0,1 return that.
.0194fc	80 00		bra $0194fe			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.0194fe					UnarySetAMinus1:
.0194fe	a9 ff		lda #$ff			lda 	#$FF 						; put -1 in all four slots.
.019500	95 80		sta $80,x			sta 	XS_Mantissa,x
.019502	80 04		bra $019508			bra 	UnarySetAFill
.019504					UnarySetAInteger:
.019504	95 80		sta $80,x			sta 	XS_Mantissa,x
.019506	a9 00		lda #$00			lda 	#0
.019508					UnarySetAFill:
.019508	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01950a	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01950c	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01950e	a9 01		lda #$01			lda 	#1 							; set type to integer.
.019510	95 85		sta $85,x			sta 	XS_Type,x
.019512	60		rts				rts
.019513					GetSignCurrent:
.019513	b5 85		lda $85,x			lda 	XS_Type,x 					; identify type.
.019515	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.019516	90 15		bcc $01952d			bcc 	_GSCFloat 					; if clear do the float code.
.019518	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; if msb of integer set, it's negative
.01951a	30 0e		bmi $01952a			bmi 	_GSCMinus1
.01951c	15 80		ora $80,x			ora 	XS_Mantissa+0,x
.01951e	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019520	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019522	d0 03		bne $019527			bne 	_GSCPlus1 					; check if zero by oring all together.
.019524					_GSCZero:
.019524	a9 00		lda #$00			lda 	#0
.019526	60		rts				rts
.019527					_GSCPlus1:
.019527	a9 01		lda #$01			lda 	#$01
.019529	60		rts				rts
.01952a					_GSCMinus1:
.01952a	a9 ff		lda #$ff			lda 	#$FF
.01952c	60		rts				rts
.01952d					_GSCFloat:
.01952d	34 85		bit $85,x			bit 	XS_Type,x 					; check bits
.01952f	70 f3		bvs $019524			bvs 	_GSCZero 					; if zero flag set return zero
.019531	30 f7		bmi $01952a			bmi 	_GSCMinus1 					; if sign set return -1
.019533	80 f2		bra $019527			bra 	_GSCPlus1		 			; else return +1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.019535					Unary_Abs:
.019535	20 93 92	jsr $019293			jsr 	EvaluateNumberX 			; get value
.019538	20 e8 98	jsr $0198e8			jsr 	CheckNextRParen 			; check right bracket.
.01953b	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.01953d	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.01953f	f0 07		beq $019548			beq 	_UAMinusFloat
.019541	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; check MSB of upper byte to see if negative
.019543	10 09		bpl $01954e			bpl 	_UAExit
.019545	4c 5b 9e	jmp $019e5b			jmp 	IntegerNegateAlways 		; if so negate it.
.019548					_UAMinusFloat:
.019548	b5 85		lda $85,x			lda 	XS_Type,x 					; clear the sign bit.
.01954a	29 7f		and #$7f			and		#$7F
.01954c	95 85		sta $85,x			sta 	XS_Type,x
.01954e					_UAExit:
.01954e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.01954f					Unary_Peek:
.01954f	a9 01		lda #$01			lda 	#1 							; 1 byte
.019551	80 06		bra $019559			bra 	UPMain
.019553					Unary_Deek:
.019553	a9 02		lda #$02			lda 	#2 							; 2 bytes
.019555	80 02		bra $019559			bra 	UPMain
.019557					Unary_Leek:
.019557	a9 04		lda #$04			lda 	#4 							; 4 bytes
.019559					UPMain:
.019559	48		pha				pha 								; save bytes to copy.
.01955a	20 a1 92	jsr $0192a1			jsr 	EvaluateIntegerX 			; numeric parameter, the address to xEEK
.01955d	20 e8 98	jsr $0198e8			jsr 	CheckNextRParen 			; right bracket.
.019560	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.019562	85 1a		sta $1a				sta 	zLTemp1
.019564	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019566	85 1b		sta $1b				sta 	zLTemp1+1
.019568	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01956a	85 1c		sta $1c				sta 	zLTemp1+2
.01956c	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01956e	85 1d		sta $1d				sta 	zLTemp1+3
.019570	a9 00		lda #$00			lda 	#0 							; clear target area, which might get
.019572	95 80		sta $80,x			sta 	XS_Mantissa+0,x 			; 1,2 or 4 bytes.
.019574	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019576	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019578	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01957a	68		pla				pla 								; restore bytes to copy
.01957b	da		phx				phx 								; save XY
.01957c	5a		phy				phy
.01957d	20 6a 98	jsr $01986a			jsr 	MemRead 					; read the bytes in, processor dependent routine.
.019580	7a		ply				ply 								; restore and exit
.019581	fa		plx				plx
.019582	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/pos.asm

.019583					Unary_Pos:
.019583	20 93 92	jsr $019293			jsr 	EvaluateNumberX 			; get value, which is a dummy.
.019586	20 e8 98	jsr $0198e8			jsr 	CheckNextRParen 			; check right bracket.
.019589	20 43 85	jsr $018543			jsr 	VIOCharGetPosition 			; get the position
.01958c	4c 04 95	jmp $019504			jmp		UnarySetAInteger			; and return that.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.01958f					Unary_Mod:
.01958f	20 b7 95	jsr $0195b7			jsr 	_UMParameter 				; first parameter, get |param|
.019592	20 f0 98	jsr $0198f0			jsr 	CheckNextComma
.019595	da		phx				phx 								; second parameter, get |param|
.019596	e8		inx				inx
.019597	e8		inx				inx
.019598	e8		inx				inx
.019599	e8		inx				inx
.01959a	e8		inx				inx
.01959b	e8		inx				inx
.01959c	20 b7 95	jsr $0195b7			jsr 	_UMParameter
.01959f	fa		plx				plx
.0195a0	20 e8 98	jsr $0198e8			jsr 	CheckNextRParen
.0195a3	20 d4 9d	jsr $019dd4			jsr 	DivInteger32 				; divide, which handily leaves ....
.0195a6	a5 1a		lda $1a				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.0195a8	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0195aa	a5 1b		lda $1b				lda 	zLTemp1+1
.0195ac	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0195ae	a5 1c		lda $1c				lda 	zLTemp1+2
.0195b0	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0195b2	a5 1d		lda $1d				lda 	zLTemp1+3
.0195b4	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0195b6	60		rts				rts
.0195b7					_UMParameter:
.0195b7	20 a1 92	jsr $0192a1			jsr 	EvaluateIntegerX 			; get value
.0195ba	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; absolute value
.0195bc	10 03		bpl $0195c1			bpl 	_UMNotSigned
.0195be	20 5b 9e	jsr $019e5b			jsr 	IntegerNegateAlways
.0195c1					_UMNotSigned:
.0195c1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.0195c2					Unary_Usr:
.0195c2	20 93 92	jsr $019293			jsr 	EvaluateNumberX 			; numeric parameter
.0195c5	20 e8 98	jsr $0198e8			jsr 	CheckNextRParen 			; right bracket.
.0195c8	da		phx				phx 								; save XY
.0195c9	5a		phy				phy
.0195ca	22 0c 03 00	jsl $00030c			jsl 	UserVector 					; with the parameter in the base mantissa
.0195ce	7a		ply				ply 								; restore YX and exit with whatever the
.0195cf	fa		plx				plx 								; routine called has chosen to do with it.
.0195d0	60		rts				rts
.0195d1					USRDefault:
.0195d1	20 79 85	jsr $018579			jsr ERR_Handler
>0195d4	4e 6f 20 55 53 52 20 76			.text "No USR vector.",0
>0195dc	65 63 74 6f 72 2e 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.0195e3					Unary_Val:
.0195e3	20 aa 92	jsr $0192aa			jsr 	EvaluateStringX 			; get string
.0195e6	20 e8 98	jsr $0198e8			jsr 	CheckNextRParen 			; check right bracket.
.0195e9	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.0195eb	85 1e		sta $1e				sta 	zGenPtr
.0195ed	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0195ef	85 1f		sta $1f				sta 	zGenPtr+1
.0195f1	5a		phy				phy
.0195f2	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.0195f4	b1 1e		lda ($1e),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.0195f6	f0 56		beq $01964e			beq 	_UVBadNumber
.0195f8	48		pha				pha 								; save length.
.0195f9	1a		inc a				inc 	a 							; one for the length, one for the terminator
.0195fa	1a		inc a				inc 	a 							; null
.0195fb	20 35 99	jsr $019935			jsr 	AllocateTempString
.0195fe	c8		iny				iny 								; move to the next.
.0195ff	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get character
.019601	49 2d		eor #$2d			eor 	#"-"						; zero if minus sign
.019603	8d a0 03	sta $03a0			sta 	ValSign 					; store this in the val temp.
.019606	d0 06		bne $01960e			bne 	_UVNotMinus
.019608	c8		iny				iny 								; skip over it.
.019609	68		pla				pla 								; decrement character count.
.01960a	3a		dec a				dec 	a
.01960b	f0 41		beq $01964e			beq 	_UVBadNumber 				; if there was only a '-' that's an error.
.01960d	48		pha				pha
.01960e					_UVNotMinus:
.01960e	68		pla				pla 								; this is the count.
.01960f	48		pha		_UVCopy:pha									; copy into new temp string which is ASCIIZ
.019610	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.019612	c8		iny				iny
.019613	20 60 99	jsr $019960			jsr 	WriteTempString
.019616	68		pla				pla
.019617	3a		dec a				dec 	a
.019618	d0 f5		bne $01960f			bne 	_UVCopy 					; when finished copying A = 0 so
.01961a	20 60 99	jsr $019960			jsr 	WriteTempString 			; make it ASCIIZ
.01961d	18		clc				clc
.01961e	a5 20		lda $20				lda 	zTempStr 					; tempstring +1 => genptr
.019620	69 01		adc #$01			adc 	#1
.019622	85 1e		sta $1e				sta 	zGenPtr
.019624	a5 21		lda $21				lda 	zTempStr+1
.019626	69 00		adc #$00			adc 	#0
.019628	85 1f		sta $1f				sta 	zGenPtr+1
.01962a	18		clc				clc
.01962b	20 2d 9f	jsr $019f2d			jsr 	IntFromString 				; first bit.
.01962e	b0 1e		bcs $01964e			bcs 	_UVBadNumber
.019630	20 ab a4	jsr $01a4ab			jsr 	FPFromString				; try for a float part - if float basic.
.019633	ad a0 03	lda $03a0			lda 	ValSign 					; was it negative
.019636	d0 10		bne $019648			bne 	_UVNotNegative
.019638	b5 85		lda $85,x			lda 	XS_Type,x 					; check if integer
.01963a	4a		lsr a				lsr 	a
.01963b	b0 08		bcs $019645			bcs 	_UVInteger
.01963d	b5 85		lda $85,x			lda 	XS_Type,x 					; set sign bit
.01963f	09 80		ora #$80			ora 	#$80
.019641	95 85		sta $85,x			sta 	XS_Type,x
.019643	80 03		bra $019648			bra 	_UVNotNegative
.019645					_UVInteger:
.019645	20 5b 9e	jsr $019e5b			jsr 	IntegerNegateAlways 		; sign it.
.019648					_UVNotNegative:
.019648	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; used everything up ?
.01964a	d0 02		bne $01964e			bne 	_UVBadNumber
.01964c	7a		ply				ply
.01964d	60		rts				rts
.01964e					_UVBadNumber:
.01964e	4c 68 85	jmp $018568			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.019651					Unary_Str:
.019651	20 93 92	jsr $019293			jsr 	EvaluateNumberX 			; numeric parameter
.019654	20 e8 98	jsr $0198e8			jsr 	CheckNextRParen 			; right bracket.
.019657	a9 00		lda #$00			lda 	#0 							; reset buffer index
.019659	8d 14 03	sta $0314			sta 	NumBufX
.01965c	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.01965e	4a		lsr a				lsr 	a 							; bit 0 identifies an integer.
.01965f	b0 05		bcs $019666			bcs 	_USInt 						; if msb set do as integer
.019661	20 f0 a3	jsr $01a3f0			jsr 	FPToString 					; call fp to str otherwise
.019664	80 03		bra $019669			bra 	_USDuplicate
.019666	20 78 9e	jsr $019e78	_USInt:	jsr 	IntToString					; call int to str.
.019669					_USDuplicate:
.019669	ad 14 03	lda $0314			lda 	NumBufX 					; chars in buffer
.01966c	1a		inc a				inc 	a 							; one more for length
.01966d	20 35 99	jsr $019935			jsr 	AllocateTempString 			; allocate space for it.
.019670	5a		phy				phy 								; save Y
.019671	a0 00		ldy #$00			ldy 	#0 							; start copying
.019673	b9 15 03	lda $0315,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.019676	20 60 99	jsr $019960			jsr 	WriteTempString
.019679	c8		iny				iny
.01967a	cc 14 03	cpy $0314			cpy 	NumBufX 					; done the lot
.01967d	d0 f4		bne $019673			bne 	_USCopy
.01967f	7a		ply				ply 								; restore Y
.019680	4c 5d 98	jmp $01985d			jmp 	UnaryReturnTempStr 			; return newly created temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.019683					Unary_Asc:
.019683	20 aa 92	jsr $0192aa			jsr 	EvaluateStringX 			; string parameter
.019686	20 e8 98	jsr $0198e8			jsr 	CheckNextRParen 			; right bracket.
.019689	5a		phy				phy 								; get the string length
.01968a	a0 00		ldy #$00			ldy 	#0
.01968c	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.01968e	f0 07		beq $019697			beq 	_UAIllegal 					; must be at least one character, 0 => error
.019690	c8		iny				iny
.019691	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; read the first character
.019693	7a		ply				ply
.019694	4c 04 95	jmp $019504			jmp 	UnarySetAInteger 			; return that as an integer 0-255.
.019697					_UAIllegal:
.019697	4c 68 85	jmp $018568			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.01969a					Unary_Len:
.01969a	20 aa 92	jsr $0192aa			jsr 	EvaluateStringX 			; string parameter
.01969d	20 e8 98	jsr $0198e8			jsr 	CheckNextRParen 			; right bracket.
.0196a0	5a		phy				phy 								; get the string length
.0196a1	a0 00		ldy #$00			ldy 	#0
.0196a3	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.0196a5	7a		ply				ply
.0196a6	4c 04 95	jmp $019504			jmp 	UnarySetAInteger 			; return as an integer.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.0196a9					Unary_Mid:
.0196a9	20 aa 92	jsr $0192aa			jsr 	EvaluateStringX 				; get string.
.0196ac	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.0196ae	48		pha				pha
.0196af	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0196b1	48		pha				pha
.0196b2	20 f0 98	jsr $0198f0			jsr 	CheckNextComma 					; skip comma
.0196b5	20 3e 97	jsr $01973e			jsr 	SLIByteParameter 				; get a byte parameter (start)
.0196b8	48		pha				pha 									; and push it.
.0196b9	20 f0 98	jsr $0198f0			jsr 	CheckNextComma 					; skip comma
.0196bc	20 3e 97	jsr $01973e			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.0196bf	48		pha				pha 									; and push it.
.0196c0	80 41		bra $019703			bra 	SLIProcess
.0196c2					Unary_Left:
.0196c2	20 aa 92	jsr $0192aa			jsr 	EvaluateStringX 				; get string.
.0196c5	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.0196c7	48		pha				pha
.0196c8	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0196ca	48		pha				pha
.0196cb	a9 01		lda #$01			lda 	#1 								; push start position (1)
.0196cd	48		pha				pha
.0196ce	20 f0 98	jsr $0198f0			jsr 	CheckNextComma 					; skip comma
.0196d1	20 3e 97	jsr $01973e			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.0196d4	48		pha				pha 									; and push it.
.0196d5	80 2c		bra $019703			bra 	SLIProcess
.0196d7					Unary_Right:
.0196d7	20 aa 92	jsr $0192aa			jsr 	EvaluateStringX 				; get string.
.0196da	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.0196dc	48		pha				pha
.0196dd	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0196df	48		pha				pha
.0196e0	da		phx				phx 									; get the string length and push on stack.
.0196e1	a2 00		ldx #$00			ldx 	#0
.0196e3	a1 1e		lda ($1e,x)			lda		(zGenPtr,x)
.0196e5	fa		plx				plx
.0196e6	48		pha				pha
.0196e7	20 f0 98	jsr $0198f0			jsr 	CheckNextComma 					; skip comma
.0196ea	20 3e 97	jsr $01973e			jsr 	SLIByteParameter 				; get a byte parameter.
.0196ed	8d 9e 03	sta $039e			sta 	SignCount 						; save in temporary.
.0196f0	68		pla				pla 									; restore string length.
.0196f1	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.0196f2	38		sec				sec
.0196f3	ed 9e 03	sbc $039e			sbc 	SignCount 						; subtract characters needed, gives start position.
.0196f6	f0 02		beq $0196fa			beq 	_URStart 						; if <= 0 start from 1.
.0196f8	10 02		bpl $0196fc			bpl 	_UROkay
.0196fa					_URStart:
.0196fa	a9 01		lda #$01			lda 	#1
.0196fc					_UROkay:
.0196fc	48		pha				pha 									; push start
.0196fd	ad 9e 03	lda $039e			lda 	SignCount 						; push count of characters
.019700	48		pha				pha
.019701	80 00		bra $019703			bra 	SLIProcess
.019703					SLIProcess:
.019703	20 e8 98	jsr $0198e8			jsr 	CheckNextRParen 				; closing right bracket.
.019706	68		pla				pla
.019707	8d a2 03	sta $03a2			sta 	SliceCount 						; count in signcount
.01970a	1a		inc a				inc 	a 								; allocate +1 for it.
.01970b	20 35 99	jsr $019935			jsr 	AllocateTempString
.01970e	68		pla				pla 									; pop start number off stack.
.01970f	f0 3b		beq $01974c			beq 	SLIError 						; exit if start = 0
.019711	8d a1 03	sta $03a1			sta 	SliceStart
.019714	68		pla				pla  									; pop string address.
.019715	85 1f		sta $1f				sta 	zGenPtr+1
.019717	68		pla				pla
.019718	85 1e		sta $1e				sta 	zGenPtr
.01971a	da		phx				phx
.01971b	5a		phy				phy
.01971c	a2 00		ldx #$00			ldx 	#0 								; point to string length.
.01971e	ac a1 03	ldy $03a1			ldy 	SliceStart 						; start of the string (+1 for count)
.019721					_SLICopy:
.019721	ad a2 03	lda $03a2			lda 	SliceCount 						; done count characters
.019724	f0 12		beq $019738			beq 	_SLIExit
.019726	ce a2 03	dec $03a2			dec 	SliceCount
.019729	98		tya				tya 									; index of character
.01972a	c1 1e		cmp ($1e,x)			cmp 	(zGenPtr,x)						; compare against length
.01972c	f0 02		beq $019730			beq 	_SLIOk 							; if equal, okay.
.01972e	b0 08		bcs $019738			bcs 	_SLIExit 						; if past end, then exit.
.019730	b1 1e		lda ($1e),y	_SLIOk:	lda 	(zGenPtr),y 					; copy one character
.019732	c8		iny				iny
.019733	20 60 99	jsr $019960			jsr 	WriteTempString
.019736	80 e9		bra $019721			bra 	_SLICopy 						; go round till copied characters
.019738					_SLIExit:
.019738	7a		ply				ply 									; restore YX
.019739	fa		plx				plx
.01973a	4c 5d 98	jmp $01985d			jmp 	UnaryReturnTempStr 				; return new temporary string.
.01973d	ea		nop				nop
.01973e					SLIByteParameter:
.01973e	20 a1 92	jsr $0192a1			jsr 	EvaluateIntegerX 				; get integer
.019741	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.019743	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019745	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019747	d0 03		bne $01974c			bne 	SLIError
.019749	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01974b	60		rts				rts
.01974c					SLIError:
.01974c	4c 68 85	jmp $018568			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.01974f					Unary_Hex:
.01974f	20 a1 92	jsr $0192a1			jsr 	EvaluateIntegerX 			; numeric parameter
.019752	20 e8 98	jsr $0198e8			jsr 	CheckNextRParen 			; right bracket.
.019755	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.019757	20 35 99	jsr $019935			jsr 	AllocateTempString			; allocate string space
.01975a	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.01975c	20 80 97	jsr $019780			jsr 	_UHConvert
.01975f	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019761	20 80 97	jsr $019780			jsr 	_UHConvert
.019764	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019766	20 80 97	jsr $019780			jsr 	_UHConvert
.019769	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01976b	20 80 97	jsr $019780			jsr 	_UHConvert
.01976e	5a		phy				phy 								; get length of new string
.01976f	a0 00		ldy #$00			ldy 	#0
.019771	b1 20		lda ($20),y			lda 	(zTempStr),y
.019773	7a		ply				ply
.019774	c9 00		cmp #$00			cmp 	#0 							; if it was non zero okay
.019776	d0 05		bne $01977d			bne 	_UHExit 					; otherwise suppressed all leading zeros !
.019778	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.01977a	20 60 99	jsr $019960			jsr 	WriteTempString
.01977d					_UHExit:
.01977d	4c 5d 98	jmp $01985d			jmp 	UnaryReturnTempStr 			; return new temporary string.
.019780					_UHConvert:
.019780	48		pha				pha
.019781	4a		lsr a				lsr 	a 							; do MSB
.019782	4a		lsr a				lsr 	a
.019783	4a		lsr a				lsr 	a
.019784	4a		lsr a				lsr 	a
.019785	20 89 97	jsr $019789			jsr 	_UHNibble
.019788	68		pla				pla 								; do LSB
.019789					_UHNibble:
.019789	29 0f		and #$0f			and 	#15 						; get nibble
.01978b	d0 0c		bne $019799			bne 	_UHNonZero 					; if not zero, write it out anyway.
.01978d	5a		phy				phy									; get the length
.01978e	a0 00		ldy #$00			ldy 	#0
.019790	b1 20		lda ($20),y			lda 	(zTempStr),y
.019792	7a		ply				ply
.019793	c9 00		cmp #$00			cmp 	#0 							; length = 0 => suppress leading zeros.
.019795	f0 0d		beq $0197a4			beq 	_UHExit2
.019797	a9 00		lda #$00			lda 	#0 							; length > 0, so can't suppress any more.
.019799					_UHNonZero:
.019799	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.01979b	90 02		bcc $01979f			bcc 	_UHDigit
.01979d	69 06		adc #$06			adc 	#7-1
.01979f					_UHDigit:
.01979f	69 30		adc #$30			adc 	#48
.0197a1	20 60 99	jsr $019960			jsr 	WriteTempString				; output to temp string.
.0197a4					_UHExit2:
.0197a4	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.0197a5					Unary_Dec:
.0197a5	20 aa 92	jsr $0192aa			jsr 	EvaluateStringX 			; string parameter
.0197a8	20 e8 98	jsr $0198e8			jsr 	CheckNextRParen 			; right bracket.
.0197ab	5a		phy				phy
.0197ac	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.0197ae	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.0197b0	f0 43		beq $0197f5			beq 	_UDFail 					; must fail if zero.
.0197b2	8d 9e 03	sta $039e			sta 	SignCount 					; use SignCount as a counter of chars to process.
.0197b5	a9 00		lda #$00			lda 	#0 							; set result to zero
.0197b7	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0197b9	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0197bb	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0197bd	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0197bf	a9 01		lda #$01			lda 	#1 							; set type to integer.
.0197c1	95 85		sta $85,x			sta 	XS_Type,x
.0197c3					_UDConvertLoop:
.0197c3	5a		phy				phy 								; shift mantissa left 4
.0197c4	a0 04		ldy #$04			ldy 	#4
.0197c6					_UDShift:
.0197c6	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.0197c8	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.0197ca	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.0197cc	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.0197ce	88		dey				dey
.0197cf	d0 f5		bne $0197c6			bne 	_UDShift
.0197d1	7a		ply				ply
.0197d2	c8		iny				iny 								; next character
.0197d3	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; fetch it.
.0197d5	20 f8 97	jsr $0197f8			jsr 	ConvertUpper 				; convert to U/C
.0197d8	c9 30		cmp #$30			cmp 	#"0" 						; range 0-9
.0197da	90 19		bcc $0197f5			bcc 	_UDFail
.0197dc	c9 3a		cmp #$3a			cmp 	#"9"+1
.0197de	90 08		bcc $0197e8			bcc 	_UDOkay
.0197e0	e9 37		sbc #$37			sbc 	#7+"0" 						; A-F fudge
.0197e2	90 11		bcc $0197f5			bcc 	_UDFail 					; fails if between 9 and @
.0197e4	c9 10		cmp #$10			cmp 	#16 						; must be < 16 as hexadecimal.
.0197e6	b0 0d		bcs $0197f5			bcs 	_UDFail
.0197e8					_UDOkay:
.0197e8	29 0f		and #$0f			and 	#15 						; nibble only
.0197ea	15 80		ora $80,x			ora 	XS_Mantissa+0,x 			; OR into the bottom byte.
.0197ec	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0197ee	ce 9e 03	dec $039e			dec 	SignCount 					; do it for each character in the string.
.0197f1	d0 d0		bne $0197c3			bne 	_UDConvertLoop
.0197f3	7a		ply				ply
.0197f4	60		rts				rts
.0197f5					_UDFail:
.0197f5	4c 68 85	jmp $018568			jmp 	BadParamError
.0197f8					ConvertUpper:
.0197f8	c9 61		cmp #$61			cmp 	#"a"
.0197fa	90 07		bcc $019803			bcc 	_CUExit
.0197fc	c9 7b		cmp #$7b			cmp 	#"z"+1
.0197fe	b0 03		bcs $019803			bcs 	_CUExit
.019800	38		sec				sec
.019801	e9 20		sbc #$20			sbc 	#32
.019803	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.019804					Unary_Chr:
.019804	20 a1 92	jsr $0192a1			jsr 	EvaluateIntegerX			; numeric parameter which is the character we want
.019807	20 e8 98	jsr $0198e8			jsr 	CheckNextRParen 			; right bracket.
.01980a	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.01980c	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01980e	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019810	d0 0d		bne $01981f			bne 	_UCChar
.019812	a9 02		lda #$02			lda 	#1+1 						; one character string. 2 bytes - size+char
.019814	20 35 99	jsr $019935			jsr 	AllocateTempString			; allocate it.
.019817	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.019819	20 60 99	jsr $019960			jsr 	WriteTempString
.01981c	4c 5d 98	jmp $01985d			jmp 	UnaryReturnTempStr 			; and return that string.
.01981f					_UCChar:
.01981f	4c 68 85	jmp $018568			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.019822					Unary_Spc:
.019822	20 3e 97	jsr $01973e			jsr 	SLIByteParameter 			; check space.
.019825	20 e8 98	jsr $0198e8			jsr 	CheckNextRParen
.019828	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01982a					UnarySpcCreate:
.01982a	c9 fe		cmp #$fe			cmp 	#maxString+1
.01982c	b0 14		bcs $019842			bcs 	_USSize
.01982e	48		pha				pha 								; save length
.01982f	1a		inc a				inc 	a 							; allocate one more.
.019830	20 35 99	jsr $019935			jsr 	AllocateTempString
.019833	68		pla				pla 								; get length
.019834	f0 27		beq $01985d			beq 	UnaryReturnTempStr 			; return the current temp string
.019836					_USLoop:
.019836	48		pha				pha
.019837	a9 20		lda #$20			lda 	#" "
.019839	20 60 99	jsr $019960			jsr 	WriteTempString
.01983c	68		pla				pla
.01983d	3a		dec a				dec 	a
.01983e	d0 f6		bne $019836			bne 	_USLoop
.019840	80 1b		bra $01985d			bra 	UnaryReturnTempStr
.019842					_USSize:
.019842	4c 68 85	jmp $018568			jmp 	BadParamError
.019845					Unary_Tab:
.019845	a2 00		ldx #$00			ldx 	#0 							; required TAB position.
.019847	20 3e 97	jsr $01973e			jsr 	SLIByteParameter
.01984a	20 e8 98	jsr $0198e8			jsr 	CheckNextRParen
.01984d	20 43 85	jsr $018543			jsr 	VIOCharGetPosition 			; were are we ?
.019850	85 10		sta $10				sta 	zTemp1
.019852	38		sec				sec
.019853	a5 80		lda $80				lda 	XS_Mantissa+0 				; return chars required.
.019855	e5 10		sbc $10				sbc 	zTemp1
.019857	b0 d1		bcs $01982a			bcs 	UnarySpcCreate
.019859	a9 00		lda #$00			lda 	#0
.01985b	80 cd		bra $01982a			bra 	UnarySpcCreate
.01985d					UnaryReturnTempStr:
.01985d	a5 20		lda $20				lda 	zTempStr 					; copy temp string addr -> mantissa
.01985f	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019861	a5 21		lda $21				lda 	zTempStr+1
.019863	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019865	a9 02		lda #$02			lda 	#2 							; set type to string
.019867	95 85		sta $85,x			sta 	XS_Type,x
.019869	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/65816.asm

.01986a					MemRead:
.01986a	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.01986d	a0 00		ldy #$00			ldy 	#0 							; start from here
.01986f	b7 1a		lda [$1a],y	_MLoop1:lda 	[zlTemp1],y 				; read the long address
.019871	95 80		sta $80,x			sta 	XS_Mantissa,x 				; copy into mantissa
.019873	c8		iny				iny 								; next to copy
.019874	e8		inx				inx
.019875	cc 9e 03	cpy $039e			cpy 	SignCount 					; do required # of bytes.
.019878	d0 f5		bne $01986f			bne 	_MLoop1
.01987a	60		rts				rts
.01987b					MemWrite:
.01987b	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.01987e	a0 00		ldy #$00			ldy 	#0 							; start from here
.019880	b5 80		lda $80,x	_MLoop1:lda 	XS_Mantissa,x 				; read mantisssa
.019882	97 1a		sta [$1a],y			sta 	[zlTemp1],y 				; write it out
.019884	c8		iny				iny 								; next to copy
.019885	e8		inx				inx
.019886	cc 9e 03	cpy $039e			cpy 	SignCount 					; do required # of bytes.
.019889	d0 f5		bne $019880			bne 	_MLoop1
.01988b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/programend.asm

.01988c					UpdateProgramEnd:
.01988c	a9 00		lda #$00			lda 	#BasicProgram & $FF
.01988e	85 16		sta $16				sta 	zCodePtr+0
.019890	a9 10		lda #$10			lda 	#BasicProgram >> 8
.019892	85 17		sta $17				sta 	zCodePtr+1
.019894	a9 00		lda #$00			lda 	#0
.019896	85 18		sta $18				sta 	zCodePtr+2
.019898	85 19		sta $19				sta 	zCodePtr+3
.01989a	a0 03		ldy #$03			ldy 	#3
.01989c					_UPDLoop:
.01989c	a0 00		ldy #$00			ldy 	#0
.01989e	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0198a0	c9 00		cmp #$00			cmp 	#0 							; end if offset is zero.
.0198a2	f0 0f		beq $0198b3			beq 	_UPDFoundEnd
.0198a4	a0 00		ldy #$00			ldy 	#0 							; point to offset
.0198a6	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.0198a8	18		clc				clc
.0198a9	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.0198ab	85 16		sta $16				sta 	zCodePtr
.0198ad	90 02		bcc $0198b1			bcc 	_SNLNoCarry
.0198af	e6 17		inc $17				inc 	zCodePtr+1
.0198b1					_SNLNoCarry:
.0198b1	80 e9		bra $01989c			bra 	_UPDLoop
.0198b3					_UPDFoundEnd:
.0198b3	18		clc				clc 								; end of program 2 on.
.0198b4	a5 16		lda $16				lda 	zCodePtr
.0198b6	69 02		adc #$02			adc 	#2
.0198b8	8d 04 03	sta $0304			sta 	endOfProgram
.0198bb	a5 17		lda $17				lda 	zCodePtr+1
.0198bd	69 00		adc #$00			adc 	#0
.0198bf	8d 05 03	sta $0305			sta 	endOfProgram+1
.0198c2	a5 18		lda $18				lda 	zCodePtr+2
.0198c4	69 00		adc #$00			adc		#0
.0198c6	8d 06 03	sta $0306			sta 	endOfProgram+2
.0198c9	a5 19		lda $19				lda 	zCodePtr+3
.0198cb	69 00		adc #$00			adc 	#0
.0198cd	8d 07 03	sta $0307			sta 	endOfProgram+3
.0198d0	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.0198d1					CheckNextToken:
.0198d1	d7 16		cmp [$16],y			cmp 	[zCodePtr],y
.0198d3	d0 02		bne $0198d7			bne 	CTFail 						; no, then fail
.0198d5	c8		iny				iny
.0198d6	60		rts				rts
.0198d7					CTFail:
.0198d7	20 79 85	jsr $018579			jsr ERR_Handler
>0198da	4d 69 73 73 69 6e 67 20			.text "Missing token",0
>0198e2	74 6f 6b 65 6e 00
.0198e8					CheckNextRParen:
.0198e8	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0198ea	c9 be		cmp #$be			cmp 	#token_rparen
.0198ec	d0 e9		bne $0198d7			bne 	CTFail
.0198ee	c8		iny				iny
.0198ef	60		rts				rts
.0198f0					CheckNextComma:
.0198f0	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0198f2	c9 bf		cmp #$bf			cmp 	#token_comma
.0198f4	d0 e1		bne $0198d7			bne 	CTFail
.0198f6	c8		iny				iny
.0198f7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/concrete.asm

.0198f8					StringConcrete:
.0198f8	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; save source to zTemp1
.0198fa	85 10		sta $10				sta 	zTemp1
.0198fc	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0198fe	85 11		sta $11				sta 	zTemp1+1
.019900	a0 00		ldy #$00			ldy 	#0 							; empty string, return default empty
.019902	b1 10		lda ($10),y			lda 	(zTemp1),y
.019904	f0 26		beq $01992c			beq		_SCEmpty
.019906	18		clc				clc 								; from the string pointer
.019907	ad 00 03	lda $0300			lda 	StringPtr 					; and put in zTemp2 as well
.01990a	f1 10		sbc ($10),y			sbc 	(zTemp1),y
.01990c	8d 00 03	sta $0300			sta 	StringPtr
.01990f	85 12		sta $12				sta 	zTemp2
.019911	ad 01 03	lda $0301			lda 	StringPtr+1
.019914	e9 00		sbc #$00			sbc 	#0
.019916	8d 01 03	sta $0301			sta 	StringPtr+1
.019919	85 13		sta $13				sta 	zTemp2+1
.01991b	b1 10		lda ($10),y			lda 	(zTemp1),y 					; length add one for count
.01991d	1a		inc a				inc 	a
.01991e	aa		tax				tax
.01991f	b1 10		lda ($10),y	_SCCopy:lda 	(zTemp1),y 					; copy whole thing including length
.019921	91 12		sta ($12),y			sta 	(zTemp2),y
.019923	c8		iny				iny
.019924	ca		dex				dex
.019925	d0 f8		bne $01991f			bne 	_SCCopy
.019927	a5 13		lda $13				lda 	zTemp2+1 					; return concrete string in AX
.019929	a6 12		ldx $12				ldx 	zTemp2
.01992b	60		rts				rts
.01992c					_SCEmpty:
.01992c	a9 00		lda #$00			lda 	#0
.01992e	85 25		sta $25				sta 	zNullString
.019930	a9 00		lda #$00			lda 	#zNullString >> 8
.019932	a2 25		ldx #$25			ldx 	#zNulLString & $FF
.019934	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.019935					AllocateTempString:
.019935	48		pha				pha 								; save required count.
.019936	a5 21		lda $21				lda 	zTempStr+1 					; check if initialised yet ?
.019938	d0 0b		bne $019945			bne 	_ATSInitialised
.01993a	ad 00 03	lda $0300			lda 	StringPtr 					; set temporary string ptr 1 page below available
.01993d	85 20		sta $20				sta 	zTempStr					; space, this is for strings to be concreted.
.01993f	ad 01 03	lda $0301			lda 	StringPtr+1
.019942	3a		dec a				dec 	a
.019943	85 21		sta $21				sta 	zTempStr+1
.019945					_ATSInitialised:
.019945	68		pla				pla 								; get required count back.
.019946	49 ff		eor #$ff			eor 	#$FF 						; negate 2's complement.
.019948	1a		inc a				inc 	a
.019949	18		clc				clc
.01994a	65 20		adc $20				adc 	zTempStr 					; "add" to the temp string pointer
.01994c	85 20		sta $20				sta 	zTempStr
.01994e	a9 ff		lda #$ff			lda 	#$FF
.019950	65 21		adc $21				adc 	zTempStr+1
.019952	85 21		sta $21				sta 	zTempStr+1
.019954	a9 00		lda #$00			lda 	#0 							; clear temp string.
.019956	5a		phy				phy
.019957	a8		tay				tay
.019958	91 20		sta ($20),y			sta 	(zTempStr),y
.01995a	7a		ply				ply
.01995b	1a		inc a				inc 	a 							; reset the write index.
.01995c	8d 9f 03	sta $039f			sta 	TempStringWriteIndex
.01995f	60		rts				rts
.019960					WriteTempString:
.019960	5a		phy				phy 								; save Y
.019961	ac 9f 03	ldy $039f			ldy 	TempStringWriteIndex	 	; write position.
.019964	91 20		sta ($20),y			sta 	(zTempStr),y 				; write character out.
.019966	ee 9f 03	inc $039f			inc 	TempStringWriteIndex 		; increment the write position.
.019969	98		tya				tya 								; unchanged Y is now length
.01996a	a0 00		ldy #$00			ldy 	#0
.01996c	91 20		sta ($20),y			sta 	(zTempStr),y
.01996e	7a		ply				ply 								; restore Y and exit
.01996f	60		rts				rts
.019970					CreateTempStringCopy:
.019970	da		phx				phx 								; save X
.019971	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019973	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.019974	20 35 99	jsr $019935			jsr 	AllocateTempString 			; allocate memory for temporary string.
.019977	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019979	c8		iny				iny
.01997a	3a		dec a				dec 	a 							; make the actual length in charactes
.01997b	3a		dec a				dec 	a
.01997c	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.01997e	81 20		sta ($20,x)			sta 	(zTempStr,x)
.019980	85 1a		sta $1a				sta 	zLTemp1 					; that's used as a count.
.019982	09 00		ora #$00			ora 	#0 							; if zero already, exit
.019984	f0 0e		beq $019994			beq 	_CTSCExit
.019986					_CTSCLoop:
.019986	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019988	c8		iny				iny
.019989	5a		phy				phy 								; save in Y
.01998a	e8		inx				inx 								; bump index
.01998b	da		phx				phx 								; index into Y
.01998c	7a		ply				ply
.01998d	91 20		sta ($20),y			sta 	(zTempStr),y 				; save at index
.01998f	7a		ply				ply 								; restore Y
.019990	c6 1a		dec $1a				dec 	zLTemp1 					; do for each character
.019992	d0 f2		bne $019986			bne 	_CTSCLoop
.019994					_CTSCExit:
.019994	fa		plx				plx 								; restore X
.019995	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/variables.asm

.019996					VariableFind:
.019996	20 01 9a	jsr $019a01			jsr 	VariableExtract 		; find out all about it ....
.019999	20 9a 9c	jsr $019c9a			jsr 	VariableLocate 			; does it already exist ?
.01999c	b0 03		bcs $0199a1			bcs 	_VFExists 				; if so, use that.
.01999e	20 8d 9a	jsr $019a8d			jsr 	VariableCreate 			; otherwise create it.
.0199a1					_VFExists:
.0199a1	a5 24		lda $24				lda 	zVarType 				; is it still an array ?
.0199a3	29 01		and #$01			and 	#1
.0199a5	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.0199a7	d0 28		bne $0199d1			bne 	_VFSingleElement
.0199a9					_VFNextIndex:
.0199a9	a5 22		lda $22				lda 	zVarDataPtr 			; push the data ptr and type on the stack.
.0199ab	48		pha				pha
.0199ac	a5 23		lda $23				lda 	zVarDataPtr+1
.0199ae	48		pha				pha
.0199af	a5 24		lda $24				lda 	zVarType
.0199b1	48		pha				pha
.0199b2	20 a1 92	jsr $0192a1			jsr 	EvaluateIntegerX 		; calculate the index.
.0199b5	68		pla				pla 							; restore and index.
.0199b6	85 24		sta $24				sta 	zVarType
.0199b8	68		pla				pla
.0199b9	85 23		sta $23				sta 	zVarDataPtr+1
.0199bb	68		pla				pla
.0199bc	85 22		sta $22				sta 	zVarDataPtr
.0199be	20 18 9b	jsr $019b18			jsr 	ArrayIndexFollow 		; do the index.
.0199c1	a5 24		lda $24				lda 	zVarType 				; is it still an array ??
.0199c3	29 01		and #$01			and 	#1
.0199c5	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.0199c7	d0 05		bne $0199ce			bne 	_VFArrayDone 			; if so then exit.
.0199c9	20 f0 98	jsr $0198f0			jsr 	CheckNextComma 			; comma should follow
.0199cc	80 db		bra $0199a9			bra 	_VFNextIndex
.0199ce					_VFArrayDone:
.0199ce	20 e8 98	jsr $0198e8			jsr 	CheckNextRParen 		; check closing right bracket.
.0199d1					_VFSingleElement:
.0199d1	60		rts				rts
.0199d2					VariableClear:
.0199d2	48		pha				pha 							; save registers
.0199d3	da		phx				phx
.0199d4	a2 00		ldx #$00			ldx 	#0 						; clear out the hash table.
.0199d6	8a		txa				txa
.0199d7	9d 35 03	sta $0335,x	_VCLoop:sta 	HashTableBase,x
.0199da	e8		inx				inx
.0199db	e0 60		cpx #$60			cpx 	#HashTableEnd-HashTableBase
.0199dd	d0 f8		bne $0199d7			bne 	_VCLoop
.0199df	a9 00		lda #$00			lda 	#VariableMemory & $FF
.0199e1	8d 02 03	sta $0302			sta 	VarMemPtr
.0199e4	a9 30		lda #$30			lda 	#VariableMemory >> 8
.0199e6	8d 03 03	sta $0303			sta 	VarMemPtr+1
.0199e9	fa		plx				plx 							; restore registers
.0199ea	68		pla				pla
.0199eb	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/extract.asm

.0199ec					VariableNameError:
.0199ec	20 79 85	jsr $018579			jsr ERR_Handler
>0199ef	42 61 64 20 56 61 72 69			.text "Bad Variable Name",0
>0199f7	61 62 6c 65 20 4e 61 6d 65 00
.019a01					VariableExtract:
.019a01	da		phx				phx 							; save X.
.019a02	a9 ba		lda #$ba			lda 	#token_hashlParen  		; set the type to #( e.g. real array.
.019a04	8d 95 03	sta $0395			sta 	Var_Type
.019a07	8d 96 03	sta $0396			sta 	Var_Hash 				; we initialise the hash with this. It doesn't matter
.019a0a	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019a0c	c9 00		cmp #$00			cmp 	#0 						; first one must be A-Z
.019a0e	f0 dc		beq $0199ec			beq 	VariableNameError
.019a10	c9 1b		cmp #$1b			cmp 	#26+1
.019a12	b0 d8		bcs $0199ec			bcs 	VariableNameError
.019a14	a2 ff		ldx #$ff			ldx 	#255 					; now copy it into the variable buffer.
.019a16					_VECopyBuffer:
.019a16	e8		inx				inx
.019a17	e0 1f		cpx #$1f			cpx 	#31 					; too long
.019a19	f0 d1		beq $0199ec			beq 	VariableNameError
.019a1b	9d 15 03	sta $0315,x			sta 	Var_Buffer,x 			; save character
.019a1e	18		clc				clc  							; update the hash value for it.
.019a1f	6d 96 03	adc $0396			adc 	Var_Hash
.019a22	8d 96 03	sta $0396			sta 	Var_Hash
.019a25	c8		iny				iny
.019a26	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019a28	c9 00		cmp #$00			cmp 	#0 						; zero or token, end of variable
.019a2a	f0 0e		beq $019a3a			beq 	_VECopyEnd
.019a2c	30 0c		bmi $019a3a			bmi 	_VECopyEnd
.019a2e	c9 1b		cmp #$1b			cmp 	#26+1 					; A-Z continue copying
.019a30	90 e4		bcc $019a16			bcc 	_VECopyBuffer
.019a32	c9 30		cmp #$30			cmp 	#"0" 					; 0-9 copy as well.
.019a34	90 04		bcc $019a3a			bcc 	_VECopyEnd
.019a36	c9 3a		cmp #$3a			cmp 	#"9"+1
.019a38	90 dc		bcc $019a16			bcc 	_VECopyBuffer
.019a3a					_VECopyEnd:
.019a3a	c8		iny				iny
.019a3b	c9 b7		cmp #$b7			cmp 	#token_Dollar 			; first type token.
.019a3d	90 04		bcc $019a43			bcc 	_VEDefaultRequired
.019a3f	c9 bd		cmp #$bd			cmp 	#token_PercentLParen+1	; last type token.
.019a41	90 0b		bcc $019a4e			bcc 	_VEHaveType
.019a43					_VEDefaultRequired:
.019a43	c9 bd		cmp #$bd			cmp 	#token_LParen 			; if it ends in ( then use the real array
.019a45	f0 04		beq $019a4b			beq 	_VESetType 				; default set above.
.019a47	ce 95 03	dec $0395			dec 	Var_Type 				; this changes that default to the variable default
.019a4a	88		dey				dey
.019a4b					_VESetType:
.019a4b	ad 95 03	lda $0395			lda 	Var_Type 				; get type ....
.019a4e					_VEHaveType:
.019a4e	8d 95 03	sta $0395			sta 	Var_Type 				; save as type.
.019a51	bd 15 03	lda $0315,x			lda 	Var_Buffer,x 			; set bit 7 of name, marks the end.
.019a54	09 80		ora #$80			ora 	#$80
.019a56	9d 15 03	sta $0315,x			sta 	Var_Buffer,x
.019a59	e8		inx				inx 							; offset 3 => length 4.
.019a5a	8e 97 03	stx $0397			stx 	Var_Length 				; save length of variable name.
.019a5d	ad 95 03	lda $0395			lda 	Var_Type 				; get offset of var type from first type token
.019a60	38		sec				sec
.019a61	e9 b7		sbc #$b7			sbc 	#token_Dollar
.019a63	0a		asl a				asl 	a 						; multiply by 16. This requires HashTableSize
.019a64	0a		asl a				asl 	a 						; in data.asm to be 8 (8 sets of links,2 bytes each)
.019a65	0a		asl a				asl 	a
.019a66	0a		asl a				asl 	a
.019a67	8d 98 03	sta $0398			sta 	Var_HashAddress
.019a6a	ad 96 03	lda $0396			lda 	Var_Hash 				; get the hash
.019a6d	29 07		and #$07			and 	#(HashTableSize-1) 		; force into range 0-tableSize-1
.019a6f	0a		asl a				asl 	a 						; double it (2 bytes per entry) & clears carry
.019a70	6d 98 03	adc $0398			adc 	Var_HashAddress 		; add table offset.
.019a73	69 35		adc #$35			adc 	#HashTableBase & $FF 	; now the low byte of the actual table address
.019a75	8d 98 03	sta $0398			sta 	Var_HashAddress
.019a78	a2 05		ldx #$05			ldx 	#5 						; hash is 5 bytes (real)
.019a7a	ad 95 03	lda $0395			lda 	Var_Type
.019a7d	c9 b9		cmp #$b9			cmp 	#token_Hash
.019a7f	f0 07		beq $019a88			beq 	_VEHaveSize
.019a81	ca		dex				dex
.019a82	c9 bb		cmp #$bb			cmp 	#token_Percent 			; percent is 4 bytes (integer)
.019a84	f0 02		beq $019a88			beq 	_VEHaveSize
.019a86	a2 02		ldx #$02			ldx 	#2 						; everything else is two.
.019a88					_VEHaveSize:
.019a88	8e 99 03	stx $0399			stx 	Var_DataSize
.019a8b	fa		plx				plx
.019a8c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varcreate.asm

.019a8d					VariableCreate:
.019a8d	da		phx				phx
.019a8e	5a		phy				phy
.019a8f	ad 02 03	lda $0302			lda 	VarMemPtr 					; get address of next free into zTemp1
.019a92	85 10		sta $10				sta 	zTemp1
.019a94	ad 03 03	lda $0303			lda 	VarMemPtr+1
.019a97	85 11		sta $11				sta 	zTemp1+1
.019a99	ad 99 03	lda $0399			lda 	Var_DataSize 				; bytes for the data bit
.019a9c	18		clc				clc
.019a9d	6d 97 03	adc $0397			adc 	Var_Length 					; add the length of the name
.019aa0	69 03		adc #$03			adc 	#3 							; 3 for the link and the hash.
.019aa2	6d 02 03	adc $0302			adc 	VarMemPtr 					; add to variable memory pointer
.019aa5	8d 02 03	sta $0302			sta 	VarMemPtr
.019aa8	90 03		bcc $019aad			bcc 	_VCNoCarry
.019aaa	ee 03 03	inc $0303			inc 	VarMemPtr+1
.019aad					_VCNoCarry:
.019aad	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.019ab0	85 12		sta $12				sta 	zTemp2
.019ab2	a9 03		lda #$03			lda 	#HashTableBase >> 8
.019ab4	85 13		sta $13				sta 	zTemp2+1
.019ab6	a0 00		ldy #$00			ldy 	#0 							; put current hash link in position.
.019ab8	b1 12		lda ($12),y			lda 	(zTemp2),y
.019aba	91 10		sta ($10),y			sta 	(zTemp1),y
.019abc	c8		iny				iny
.019abd	b1 12		lda ($12),y			lda 	(zTemp2),y
.019abf	91 10		sta ($10),y			sta 	(zTemp1),y
.019ac1	c8		iny				iny
.019ac2	ad 96 03	lda $0396			lda 	Var_Hash 					; write the hash out.
.019ac5	91 10		sta ($10),y			sta 	(zTemp1),y
.019ac7	c8		iny				iny
.019ac8	a2 00		ldx #$00			ldx 	#0 							; copy the name out.
.019aca					_VCCopyName:
.019aca	bd 15 03	lda $0315,x			lda 	Var_Buffer,x
.019acd	91 10		sta ($10),y			sta 	(zTemp1),y
.019acf	e8		inx				inx
.019ad0	c8		iny				iny
.019ad1	ec 97 03	cpx $0397			cpx 	Var_Length
.019ad4	d0 f4		bne $019aca			bne 	_VCCopyName
.019ad6	5a		phy				phy 								; save the data offset.
.019ad7	ae 99 03	ldx $0399			ldx 	Var_DataSize 				; and write the data out.
.019ada	a9 00		lda #$00			lda 	#0 							; which is all zeroes.
.019adc					_VCClearData:
.019adc	91 10		sta ($10),y			sta 	(zTemp1),y
.019ade	c8		iny				iny
.019adf	ca		dex				dex
.019ae0	d0 fa		bne $019adc			bne 	_VCClearData
.019ae2	68		pla				pla 								; offset to the data
.019ae3	18		clc				clc
.019ae4	65 10		adc $10				adc 	zTemp1 						; add to start and save as data pointer.
.019ae6	85 22		sta $22				sta 	zVarDataPtr
.019ae8	a5 11		lda $11				lda 	zTemp1+1
.019aea	69 00		adc #$00			adc 	#0
.019aec	85 23		sta $23				sta 	zVarDataPtr+1
.019aee	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.019af1	85 24		sta $24				sta 	zVarType
.019af3	a5 10		lda $10				lda 	zTemp1 						; fix hash link to point to new record
.019af5	a0 00		ldy #$00			ldy 	#0
.019af7	91 12		sta ($12),y			sta 	(zTemp2),y
.019af9	c8		iny				iny
.019afa	a5 11		lda $11				lda 	zTemp1+1
.019afc	91 12		sta ($12),y			sta 	(zTemp2),y
.019afe	ad 95 03	lda $0395			lda 	Var_Type 					; array ? if so create the empty one.
.019b01	29 01		and #$01			and 	#1
.019b03	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.019b05	d0 0e		bne $019b15			bne 	_VCNotArray
.019b07	a2 00		ldx #$00			ldx 	#0 							; call recursive array creator
.019b09	20 af 9b	jsr $019baf			jsr 	ArrayCreate
.019b0c	5a		phy				phy 								; save YA at zVarDataPtr
.019b0d	a0 00		ldy #$00			ldy 	#0
.019b0f	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019b11	c8		iny				iny
.019b12	68		pla				pla
.019b13	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019b15					_VCNotArray:
.019b15	7a		ply				ply
.019b16	fa		plx				plx
.019b17	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arrayidx.asm

.019b18					ArrayIndexFollow:
.019b18	5a		phy				phy
.019b19	a0 00		ldy #$00			ldy 	#0 							; make zVarDataPtr point to the array.
.019b1b	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; e.g. it points to itself.
.019b1d	48		pha				pha
.019b1e	c8		iny				iny
.019b1f	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019b21	85 23		sta $23				sta 	zVarDataPtr+1
.019b23	68		pla				pla
.019b24	85 22		sta $22				sta 	zVarDataPtr
.019b26	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; MSB of 16 bit integer and bytes 2&3
.019b28	29 80		and #$80			and 	#$80 						; must be zero.
.019b2a	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019b2c	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019b2e	d0 59		bne $019b89			bne 	_AIFError
.019b30	a0 00		ldy #$00			ldy 	#0 							; calculate size - current - 1
.019b32	18		clc				clc
.019b33	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019b35	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.019b37	c8		iny				iny
.019b38	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019b3a	08		php				php 								; clear bit 7 retaining borrow.
.019b3b	29 7f		and #$7f			and 	#$7F
.019b3d	28		plp				plp
.019b3e	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.019b40	90 47		bcc $019b89			bcc 	_AIFError 					; eror if size-current < 0
.019b42	b5 80		lda $80,x			lda  	XS_Mantissa+0,x 			; copy and double the index
.019b44	0a		asl a				asl 	a 							; (e.g. index * 2)
.019b45	85 10		sta $10				sta 	zTemp1
.019b47	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019b49	2a		rol a				rol 	a
.019b4a	85 11		sta $11				sta 	zTemp1+1
.019b4c	a0 01		ldy #$01			ldy 	#1 							; is this a data entry.
.019b4e	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; if so, then type is unchanged, offset set
.019b50	30 1d		bmi $019b6f			bmi 	_AIFCalculate
.019b52	c6 24		dec $24				dec 	zVarType 					; converts from an array to a type.
.019b54	a5 24		lda $24				lda 	zVarType 					; check that type
.019b56	c9 b7		cmp #$b7			cmp 	#token_Dollar 				; if string, use x 2
.019b58	f0 15		beq $019b6f			beq 	_AIFCalculate
.019b5a	06 10		asl $10				asl 	zTemp1			 			; double the index
.019b5c	26 11		rol $11				rol 	zTemp1+1					; (e.g. index * 4)
.019b5e	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if integer, use x 4
.019b60	f0 0d		beq $019b6f			beq 	_AIFCalculate
.019b62	18		clc				clc 								; add the original mantissa in again
.019b63	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; which makes it x5, for float.
.019b65	65 10		adc $10				adc 	zTemp1
.019b67	85 10		sta $10				sta 	zTemp1
.019b69	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019b6b	65 11		adc $11				adc 	zTemp1+1
.019b6d	85 11		sta $11				sta 	zTemp1+1
.019b6f					_AIFCalculate:
.019b6f	18		clc				clc 								; add index x 2,4 or 5 to base
.019b70	a5 22		lda $22				lda 	zVarDataPtr
.019b72	65 10		adc $10				adc 	zTemp1
.019b74	85 22		sta $22				sta 	zVarDataPtr
.019b76	a5 23		lda $23				lda 	zVarDataPtr+1
.019b78	65 11		adc $11				adc 	zTemp1+1
.019b7a	85 23		sta $23				sta 	zVarDataPtr+1
.019b7c	18		clc				clc 								; add 2 more for the length prefix.
.019b7d	a5 22		lda $22				lda 	zVarDataPtr
.019b7f	69 02		adc #$02			adc 	#2
.019b81	85 22		sta $22				sta 	zVarDataPtr
.019b83	90 02		bcc $019b87			bcc 	_AIFNoBump
.019b85	e6 23		inc $23				inc 	zVarDataPtr+1
.019b87					_AIFNoBump:
.019b87	7a		ply				ply
.019b88	60		rts				rts
.019b89					_AIFError:
.019b89	20 79 85	jsr $018579			jsr ERR_Handler
>019b8c	42 61 64 20 61 72 72 61			.text "Bad array index",0
>019b94	79 20 69 6e 64 65 78 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arraydef.asm

.019b9c					ArrayResetDefault:
.019b9c	a9 0b		lda #$0b			lda 	#11 						; 0..10 one array
.019b9e	8d a9 03	sta $03a9			sta 	ArrayDef+0
.019ba1	a9 00		lda #$00			lda 	#0
.019ba3	8d aa 03	sta $03aa			sta 	ArrayDef+1
.019ba6	a9 ff		lda #$ff			lda 	#$FF
.019ba8	8d ab 03	sta $03ab			sta 	ArrayDef+2 					; $FFFF implies no second element.
.019bab	8d ac 03	sta $03ac			sta 	ArrayDef+3					; (test bit 7 of 2nd byte)
.019bae	60		rts				rts
.019baf					ArrayCreate:
.019baf	bd a9 03	lda $03a9,x			lda 	ArrayDef+0,x 				; put size x 2 in zTemp1
.019bb2	0a		asl a				asl 	a
.019bb3	85 10		sta $10				sta 	zTemp1
.019bb5	bd aa 03	lda $03aa,x			lda 	ArrayDef+1,x
.019bb8	2a		rol a				rol 	a
.019bb9	85 11		sta $11				sta 	zTemp1+1
.019bbb	bd ac 03	lda $03ac,x			lda 	ArrayDef+3,x 				; if this is the last element it's array of ptrs.
.019bbe	10 22		bpl $019be2			bpl 	_ACSized 					; if not multiply size x 2 (str) 4 (int) 5 (real)
.019bc0	ad 95 03	lda $0395			lda 	Var_Type 					; check the type
.019bc3	c9 b8		cmp #$b8			cmp 	#token_DollarLParen 		; also if it is an array of strings $(
.019bc5	f0 1b		beq $019be2			beq 	_ACSized
.019bc7	06 10		asl $10				asl 	zTemp1 						; double again
.019bc9	26 11		rol $11				rol 	zTemp1+1
.019bcb	b0 6f		bcs $019c3c			bcs 	ArrayIndexError 			; too large.
.019bcd	c9 bc		cmp #$bc			cmp 	#token_PercentLParen 		; if %( four bytes/entry is enough.
.019bcf	f0 11		beq $019be2			beq 	_ACSized
.019bd1	18		clc				clc 								; add original value x 5 for reals.
.019bd2	a5 10		lda $10				lda 	zTemp1
.019bd4	7d a9 03	adc $03a9,x			adc 	ArrayDef+0,x
.019bd7	85 10		sta $10				sta 	zTemp1
.019bd9	a5 11		lda $11				lda 	zTemp1+1
.019bdb	7d aa 03	adc $03aa,x			adc 	ArrayDef+1,x
.019bde	85 11		sta $11				sta 	zTemp1+1
.019be0	b0 5a		bcs $019c3c			bcs 	ArrayIndexError
.019be2					_ACSized:
.019be2	18		clc				clc
.019be3	a5 10		lda $10				lda 	zTemp1
.019be5	69 02		adc #$02			adc 	#2
.019be7	85 10		sta $10				sta 	zTemp1
.019be9	90 04		bcc $019bef			bcc 	_ACNoBump
.019beb	e6 10		inc $10				inc 	zTemp1
.019bed	f0 4d		beq $019c3c			beq 	ArrayIndexError
.019bef					_ACNoBump:
.019bef	18		clc				clc
.019bf0	ad 02 03	lda $0302			lda 	VarMemPtr 					; add this allocated count to VarMemPtr
.019bf3	85 12		sta $12				sta 	zTemp2						; save start in zTemp2/zTemp3
.019bf5	85 14		sta $14				sta 	zTemp3
.019bf7	65 10		adc $10				adc 	zTemp1
.019bf9	8d 02 03	sta $0302			sta 	VarMemPtr
.019bfc	ad 03 03	lda $0303			lda 	VarMemPtr+1
.019bff	85 13		sta $13				sta 	zTemp2+1
.019c01	85 15		sta $15				sta 	zTemp3+1
.019c03	65 11		adc $11				adc 	zTemp1+1
.019c05	8d 03 03	sta $0303			sta 	VarMemPtr+1
.019c08	85 11		sta $11				sta 	zTemp1+1
.019c0a	b0 30		bcs $019c3c			bcs 	ArrayIndexError
.019c0c	a0 00		ldy #$00			ldy 	#0							; write $00 out.
.019c0e					_ACClear:
.019c0e	98		tya				tya
.019c0f	91 12		sta ($12),y			sta 	(zTemp2),y
.019c11	e6 12		inc $12				inc 	zTemp2
.019c13	d0 02		bne $019c17			bne 	_ACCBump
.019c15	e6 13		inc $13				inc 	zTemp2+1
.019c17					_ACCBump:
.019c17	a5 12		lda $12				lda 	zTemp2
.019c19	cd 02 03	cmp $0302			cmp 	VarMemPtr
.019c1c	d0 f0		bne $019c0e			bne 	_ACClear
.019c1e	a5 13		lda $13				lda 	zTemp2+1
.019c20	cd 03 03	cmp $0303			cmp 	VarMemPtr+1
.019c23	d0 e9		bne $019c0e			bne 	_ACClear
.019c25	a0 00		ldy #$00			ldy 	#0
.019c27	bd a9 03	lda $03a9,x			lda 	ArrayDef+0,x 				; copy the size into the start
.019c2a	91 14		sta ($14),y			sta 	(zTemp3),y
.019c2c	c8		iny				iny
.019c2d	bd aa 03	lda $03aa,x			lda 	ArrayDef+1,x
.019c30	91 14		sta ($14),y			sta 	(zTemp3),y
.019c32	bd ac 03	lda $03ac,x			lda 	ArrayDef+3,x 				; have we reached the end
.019c35	10 18		bpl $019c4f			bpl 	ACCFillRecursive
.019c37	a4 15		ldy $15				ldy 	zTemp3+1 					; return address
.019c39	a5 14		lda $14				lda 	zTemp3
.019c3b	60		rts				rts
.019c3c					ArrayIndexError:
.019c3c	20 79 85	jsr $018579			jsr ERR_Handler
>019c3f	42 61 64 20 61 72 72 61			.text "Bad array index",0
>019c47	79 20 69 6e 64 65 78 00
.019c4f					ACCFillRecursive:
.019c4f	a9 ff		lda #$ff			lda 	#$FF 						; we mark the end, this is free space.
.019c51	a0 00		ldy #$00			ldy 	#0 							; this is overwritten by size of next allocated
.019c53	91 12		sta ($12),y			sta 	(zTemp2),y 					; array, but we might change that.
.019c55	c8		iny				iny
.019c56	b1 14		lda ($14),y			lda 	(zTemp3),y 					; set bit 15 of the max index indicating
.019c58	09 80		ora #$80			ora 	#$80 						; an array of pointers
.019c5a	91 14		sta ($14),y			sta 	(zTemp3),y
.019c5c	a5 14		lda $14				lda 	zTemp3 						; push the start on the stack
.019c5e	48		pha				pha
.019c5f	a5 15		lda $15				lda 	zTemp3+1
.019c61	48		pha				pha
.019c62					_ACCFillLoop:
.019c62	18		clc				clc
.019c63	a5 14		lda $14				lda 	zTemp3 						; and work forwards.
.019c65	69 02		adc #$02			adc 	#2
.019c67	85 14		sta $14				sta 	zTemp3
.019c69	90 02		bcc $019c6d			bcc 	_ACCSkip2
.019c6b	e6 15		inc $15				inc 	zTemp3+1
.019c6d					_ACCSkip2:
.019c6d	a0 00		ldy #$00			ldy 	#0 							; reached the end ?
.019c6f	b1 14		lda ($14),y			lda 	(zTemp3),y					; (looking for FF marker, everything else 00)
.019c71	c8		iny				iny
.019c72	11 14		ora ($14),y			ora 	(zTemp3),y
.019c74	d0 21		bne $019c97			bne 	_ACCExit
.019c76	a5 14		lda $14				lda 	zTemp3 						; push zTemp3
.019c78	48		pha				pha
.019c79	a5 15		lda $15				lda 	zTemp3+1
.019c7b	48		pha				pha
.019c7c	e8		inx				inx
.019c7d	e8		inx				inx
.019c7e	20 af 9b	jsr $019baf			jsr 	ArrayCreate 				; create array recursively.
.019c81	ca		dex				dex
.019c82	ca		dex				dex
.019c83	85 12		sta $12				sta 	zTemp2 						; save A
.019c85	68		pla				pla
.019c86	85 15		sta $15				sta 	zTemp3+1 					; restore zTemp3
.019c88	68		pla				pla
.019c89	85 14		sta $14				sta 	zTemp3
.019c8b	98		tya				tya 								; write high bye from Y
.019c8c	a0 01		ldy #$01			ldy 	#1
.019c8e	91 14		sta ($14),y			sta 	(zTemp3),y
.019c90	88		dey				dey 								; write low byte out.
.019c91	a5 12		lda $12				lda 	zTemp2
.019c93	91 14		sta ($14),y			sta 	(zTemp3),y
.019c95	80 cb		bra $019c62			bra 	_ACCFillLoop 				; and try again.
.019c97					_ACCExit:
.019c97	7a		ply				ply 								; restore the original address
.019c98	68		pla				pla
.019c99	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varfind.asm

.019c9a					VariableLocate:
.019c9a	da		phx				phx
.019c9b	5a		phy				phy
.019c9c	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.019c9f	85 12		sta $12				sta 	zTemp2 						; points to first address.
.019ca1	a9 03		lda #$03			lda 	#HashTableBase >> 8
.019ca3	85 13		sta $13				sta 	zTemp2+1
.019ca5	a0 00		ldy #$00	_VLNext:ldy 	#0 							; get next link into AX
.019ca7	b1 12		lda ($12),y			lda 	(zTemp2),y
.019ca9	aa		tax				tax
.019caa	c8		iny				iny
.019cab	b1 12		lda ($12),y			lda 	(zTemp2),y
.019cad	85 13		sta $13				sta 	zTemp2+1 					; save in zTemp
.019caf	86 12		stx $12				stx 	zTemp2
.019cb1	05 12		ora $12				ora 	zTemp2 						; got zero
.019cb3	18		clc				clc
.019cb4	f0 25		beq $019cdb			beq 	_VLExit 					; if so, then fail as end of chain.
.019cb6	c8		iny				iny 								; point to hash (offset + 2)
.019cb7	b1 12		lda ($12),y			lda 	(zTemp2),y
.019cb9	cd 96 03	cmp $0396			cmp 	Var_Hash
.019cbc	d0 e7		bne $019ca5			bne 	_VLNext 					; try next if different.
.019cbe					_VLCompare:
.019cbe	c8		iny				iny 								; next character
.019cbf	b1 12		lda ($12),y			lda 	(zTemp2),y 					; compare variable field against buffer.
.019cc1	d9 12 03	cmp $0312,y			cmp 	Var_Buffer-3,y 				; the -3 is because name starts at 3.
.019cc4	d0 df		bne $019ca5			bne 	_VLNext 					; fail if different, try next.
.019cc6	0a		asl a				asl 	a 							; until end character (bit 7 set) matched
.019cc7	90 f5		bcc $019cbe			bcc 	_VLCompare
.019cc9	98		tya				tya
.019cca	38		sec				sec 								; add 1 as Y points to last character
.019ccb	65 12		adc $12				adc 	zTemp2 						; add to the current address
.019ccd	85 22		sta $22				sta 	zVarDataPtr
.019ccf	a5 13		lda $13				lda 	zTemp2+1
.019cd1	69 00		adc #$00			adc 	#0
.019cd3	85 23		sta $23				sta 	zVarDataPtr+1
.019cd5	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.019cd8	85 24		sta $24				sta 	zVarType
.019cda	38		sec				sec 								; return CS
.019cdb	7a		ply		_VLExit:ply
.019cdc	fa		plx				plx
.019cdd	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/vargetset.asm

.019cde					VariableGet:
.019cde	5a		phy				phy
.019cdf	a0 00		ldy #$00			ldy 	#0 							; copy first two bytes
.019ce1	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019ce3	95 80		sta $80,x			sta 	XS_Mantissa,x
.019ce5	c8		iny				iny
.019ce6	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019ce8	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019cea	c8		iny				iny
.019ceb	a5 24		lda $24				lda 	zVarType 					; if it is a string, set up for that.
.019ced	c9 b7		cmp #$b7			cmp 	#token_Dollar
.019cef	f0 2c		beq $019d1d			beq 	_VGString
.019cf1	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; copy the next two bytes.
.019cf3	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019cf5	c8		iny				iny
.019cf6	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019cf8	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019cfa	c8		iny				iny
.019cfb	a9 01		lda #$01			lda 	#1 							; set type to 1.
.019cfd	95 85		sta $85,x			sta 	XS_Type,x
.019cff	a5 24		lda $24				lda 	zVarType
.019d01	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if it is a %, then exit with default integer.
.019d03	f0 28		beq $019d2d			beq 	_VGExit
.019d05	a9 40		lda #$40			lda 	#$40 						; set type byte to zero
.019d07	95 85		sta $85,x			sta 	XS_Type,x 					; which is the code for zero/float.
.019d09	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; the last value to copy is the exponent.
.019d0b	95 84		sta $84,x			sta 	XS_Exponent,x
.019d0d	f0 1e		beq $019d2d			beq 	_VGExit 					; if exponent is zero ... it's zero.
.019d0f	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; the sign bit is the top mantissa bit.
.019d11	48		pha				pha
.019d12	29 80		and #$80			and 	#$80
.019d14	95 85		sta $85,x			sta 	XS_Type,x 					; this is the type byte.
.019d16	68		pla				pla
.019d17	09 80		ora #$80			ora 	#$80 						; set the MSB as you would expect.
.019d19	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; so it's a normalised float.
.019d1b	80 10		bra $019d2d			bra 	_VGExit
.019d1d					_VGString:
.019d1d	a9 02		lda #$02			lda 	#2 							; set type to 2, a string
.019d1f	95 85		sta $85,x			sta 	XS_Type,x
.019d21	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; is the value there $0000
.019d23	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019d25	d0 06		bne $019d2d			bne 	_VGExit 					; if not, exit.
.019d27	85 25		sta $25				sta 	zNullString 				; make zNullString a 00 string.
.019d29	a9 25		lda #$25			lda 	#zNullString
.019d2b	95 80		sta $80,x			sta 	XS_Mantissa,x 				; make it point to it.
.019d2d					_VGExit:
.019d2d	7a		ply				ply
.019d2e	60		rts				rts
.019d2f					VariableSet:
.019d2f	b5 85		lda $85,x			lda 	XS_Type,x 					; is the result a string
.019d31	29 02		and #$02			and 	#2 							; if so, it has to be
.019d33	d0 4b		bne $019d80			bne 	_VSString
.019d35	a5 24		lda $24				lda 	zVarType 					; if type is $ there's an error.
.019d37	c9 b7		cmp #$b7			cmp 	#token_Dollar
.019d39	f0 42		beq $019d7d			beq 	_VSBadType
.019d3b	c9 bb		cmp #$bb			cmp 	#token_Percent 				; type convert to float/int
.019d3d	f0 05		beq $019d44			beq 	_VSMakeInt
.019d3f	20 a5 a2	jsr $01a2a5			jsr 	FPUToFloat
.019d42	80 03		bra $019d47			bra 	_VSCopy
.019d44					_VSMakeInt:
.019d44	20 f1 a2	jsr $01a2f1			jsr 	FPUToInteger
.019d47					_VSCopy:
.019d47	5a		phy				phy
.019d48	a0 00		ldy #$00			ldy 	#0 							; copy mantissa to target.
.019d4a	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019d4c	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019d4e	c8		iny				iny
.019d4f	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019d51	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019d53	c8		iny				iny
.019d54	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019d56	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019d58	c8		iny				iny
.019d59	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019d5b	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019d5d	a5 24		lda $24				lda 	zVarType 					; if target is integer, alrady done.
.019d5f	c9 bb		cmp #$bb			cmp 	#token_Percent
.019d61	f0 18		beq $019d7b			beq 	_VSExit
.019d63	b5 85		lda $85,x			lda 	XS_Type,x 					; get the sign bit into carry flag.
.019d65	0a		asl a				asl 	a
.019d66	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; shift the sign into the mantissa high.
.019d68	08		php				php
.019d69	0a		asl a				asl 	a
.019d6a	28		plp				plp
.019d6b	6a		ror a				ror 	a
.019d6c	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019d6e	c8		iny				iny
.019d6f	b5 84		lda $84,x			lda 	XS_Exponent,x 				; copy the exponent in
.019d71	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019d73	34 85		bit $85,x			bit 	XS_Type,x 					; if the result is non zero
.019d75	50 04		bvc $019d7b			bvc 	_VSExit
.019d77	a9 00		lda #$00			lda 	#00 						; zero exponent indicating 0.
.019d79	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019d7b					_VSExit:
.019d7b	7a		ply				ply
.019d7c	60		rts				rts
.019d7d					_VSBadType:
.019d7d	4c 5a 85	jmp $01855a			jmp 	TypeError
.019d80					_VSString:
.019d80	a5 24		lda $24				lda 	zVarType 					; type must be $
.019d82	c9 b7		cmp #$b7			cmp 	#token_Dollar
.019d84	d0 f7		bne $019d7d			bne 	_VSBadType
.019d86	da		phx				phx
.019d87	5a		phy				phy
.019d88	20 f8 98	jsr $0198f8			jsr 	StringConcrete 				; concrete the string in the mantissa -> AX
.019d8b	a0 01		ldy #$01			ldy 	#1 							; save high byte
.019d8d	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019d8f	88		dey				dey 								; save low byte
.019d90	8a		txa				txa
.019d91	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019d93	7a		ply				ply 								; and exit.
.019d94	fa		plx				plx
.019d95	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.019d96					MulInteger32:
.019d96	b5 80		lda $80,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.019d98	95 8c		sta $8c,x			sta 	XS3_Mantissa,x
.019d9a	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019d9c	95 8d		sta $8d,x			sta 	XS3_Mantissa+1,x
.019d9e	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019da0	95 8e		sta $8e,x			sta 	XS3_Mantissa+2,x
.019da2	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019da4	95 8f		sta $8f,x			sta 	XS3_Mantissa+3,x
.019da6	a9 00		lda #$00			lda 	#0
.019da8	95 80		sta $80,x			sta 	XS_Mantissa+0,x 				; zero +0, where the result goes.
.019daa	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019dac	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019dae	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019db0					_BFMMultiply:
.019db0	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.019db2	29 01		and #$01			and 	#1
.019db4	f0 03		beq $019db9			beq 	_BFMNoAdd
.019db6	20 41 94	jsr $019441			jsr 	AddInteger32 					; co-opt this code
.019db9					_BFMNoAdd:
.019db9	16 86		asl $86,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.019dbb	36 87		rol $87,x			rol 	XS2_Mantissa+1,x
.019dbd	36 88		rol $88,x			rol 	XS2_Mantissa+2,x
.019dbf	36 89		rol $89,x			rol 	XS2_Mantissa+3,x
.019dc1	56 8f		lsr $8f,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.019dc3	76 8e		ror $8e,x			ror 	XS3_Mantissa+2,x
.019dc5	76 8d		ror $8d,x			ror 	XS3_Mantissa+1,x
.019dc7	76 8c		ror $8c,x			ror 	XS3_Mantissa,x
.019dc9	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.019dcb	15 8d		ora $8d,x			ora 	XS3_Mantissa+1,x
.019dcd	15 8e		ora $8e,x			ora 	XS3_Mantissa+2,x
.019dcf	15 8f		ora $8f,x			ora 	XS3_Mantissa+3,x
.019dd1	d0 dd		bne $019db0			bne 	_BFMMultiply
.019dd3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.019dd4					DivInteger32:
.019dd4	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; check for division by zero.
.019dd6	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.019dd8	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.019dda	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.019ddc	d0 14		bne $019df2			bne 	_BFDOkay
.019dde	20 79 85	jsr $018579			jsr ERR_Handler
>019de1	44 69 76 69 73 69 6f 6e			.text "Division by Zero",0
>019de9	20 62 79 20 5a 65 72 6f 00
.019df2					_BFDOkay:
.019df2	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.019df4	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.019df6	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.019df8	85 1c		sta $1c				sta 	zLTemp1+2
.019dfa	85 1d		sta $1d				sta 	zLTemp1+3
.019dfc	8d 9e 03	sta $039e			sta 	SignCount 					; Count of signs.
.019dff	20 56 9e	jsr $019e56			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.019e02	da		phx				phx
.019e03	e8		inx				inx
.019e04	e8		inx				inx
.019e05	e8		inx				inx
.019e06	e8		inx				inx
.019e07	e8		inx				inx
.019e08	e8		inx				inx
.019e09	20 56 9e	jsr $019e56			jsr 	CheckIntegerNegate
.019e0c	fa		plx				plx
.019e0d	5a		phy				phy 								; Y is the counter
.019e0e	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.019e10					_BFDLoop:
.019e10	16 80		asl $80,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.019e12	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.019e14	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.019e16	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.019e18	26 1a		rol $1a				rol 	zLTemp1
.019e1a	26 1b		rol $1b				rol 	zLTemp1+1
.019e1c	26 1c		rol $1c				rol 	zLTemp1+2
.019e1e	26 1d		rol $1d				rol 	zLTemp1+3
.019e20	38		sec				sec
.019e21	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.019e23	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.019e25	48		pha				pha
.019e26	a5 1b		lda $1b				lda 	zLTemp1+1
.019e28	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.019e2a	48		pha				pha
.019e2b	a5 1c		lda $1c				lda 	zLTemp1+2
.019e2d	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.019e2f	48		pha				pha
.019e30	a5 1d		lda $1d				lda 	zLTemp1+3
.019e32	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.019e34	90 13		bcc $019e49			bcc 	_BFDNoAdd
.019e36	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.019e38	68		pla				pla
.019e39	85 1c		sta $1c				sta 	zLTemp1+2
.019e3b	68		pla				pla
.019e3c	85 1b		sta $1b				sta 	zLTemp1+1
.019e3e	68		pla				pla
.019e3f	85 1a		sta $1a				sta 	zLTemp1+0
.019e41	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.019e43	09 01		ora #$01			ora 	#1
.019e45	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019e47	80 03		bra $019e4c			bra 	_BFDNext
.019e49					_BFDNoAdd:
.019e49	68		pla				pla 								; Throw away the intermediate calculations
.019e4a	68		pla				pla
.019e4b	68		pla				pla
.019e4c					_BFDNext:
.019e4c	88		dey				dey
.019e4d	d0 c1		bne $019e10			bne 	_BFDLoop
.019e4f	7a		ply				ply 								; restore Y
.019e50	4e 9e 03	lsr $039e			lsr 	SignCount 					; if sign count odd,
.019e53	b0 06		bcs $019e5b			bcs		IntegerNegateAlways 		; negate the result
.019e55	60		rts				rts
.019e56					CheckIntegerNegate:
.019e56	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; is it -ve = MSB set ?
.019e58	30 01		bmi $019e5b			bmi 	IntegerNegateAlways 		; if so negate it
.019e5a	60		rts				rts
.019e5b					IntegerNegateAlways:
.019e5b	ee 9e 03	inc $039e			inc 	SignCount 					; bump the count of signs
.019e5e	38		sec				sec 								; 0-mantissa,x -> mantissa,x
.019e5f	a9 00		lda #$00			lda 	#0
.019e61	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.019e63	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019e65	a9 00		lda #$00			lda 	#0
.019e67	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.019e69	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019e6b	a9 00		lda #$00			lda 	#0
.019e6d	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.019e6f	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019e71	a9 00		lda #$00			lda 	#0
.019e73	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.019e75	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019e77	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.019e78					INTToString:
.019e78	48		pha				pha
.019e79	5a		phy				phy
.019e7a	b5 83		lda $83,x			lda 		XS_Mantissa+3,x 		; check -ve
.019e7c	10 08		bpl $019e86			bpl 		_ITSNotMinus
.019e7e	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.019e80	20 1a 9f	jsr $019f1a			jsr 		ITSOutputCharacter
.019e83	20 5b 9e	jsr $019e5b			jsr 		IntegerNegateAlways 	; negate the number.
.019e86					_ITSNotMinus:
.019e86	a9 00		lda #$00			lda 		#0
.019e88	8d 9a 03	sta $039a			sta 		NumSuppress 			; clear the suppression flag.
.019e8b	8a		txa				txa 								; use Y for the mantissa index.
.019e8c	a8		tay				tay
.019e8d	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.019e8f					_ITSNextSubtractor:
.019e8f	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.019e91	8d 9b 03	sta $039b			sta 		NumConvCount
.019e94					_ITSSubtract:
.019e94	38		sec				sec
.019e95	b9 80 00	lda $0080,y			lda 		XS_Mantissa,y 			; subtract number and push on stack
.019e98	ff f6 9e 01	sbc $019ef6,x			sbc 		_ITSSubtractors+0,x
.019e9c	48		pha				pha
.019e9d	b9 81 00	lda $0081,y			lda 		XS_Mantissa+1,y
.019ea0	ff f7 9e 01	sbc $019ef7,x			sbc 		_ITSSubtractors+1,x
.019ea4	48		pha				pha
.019ea5	b9 82 00	lda $0082,y			lda 		XS_Mantissa+2,y
.019ea8	ff f8 9e 01	sbc $019ef8,x			sbc 		_ITSSubtractors+2,x
.019eac	48		pha				pha
.019ead	b9 83 00	lda $0083,y			lda 		XS_Mantissa+3,y
.019eb0	ff f9 9e 01	sbc $019ef9,x			sbc 		_ITSSubtractors+3,x
.019eb4	90 14		bcc $019eca			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.019eb6	99 83 00	sta $0083,y			sta 		XS_Mantissa+3,y 		; save subtract off stack
.019eb9	68		pla				pla
.019eba	99 82 00	sta $0082,y			sta 		XS_Mantissa+2,y
.019ebd	68		pla				pla
.019ebe	99 81 00	sta $0081,y			sta 		XS_Mantissa+1,y
.019ec1	68		pla				pla
.019ec2	99 80 00	sta $0080,y			sta 		XS_Mantissa+0,y
.019ec5	ee 9b 03	inc $039b			inc 		NumConvCount 			; bump count.
.019ec8	80 ca		bra $019e94			bra 		_ITSSubtract 			; go round again.
.019eca					_ITSCantSubtract:
.019eca	68		pla				pla 								; throw away interim answers
.019ecb	68		pla				pla
.019ecc	68		pla				pla
.019ecd	ad 9b 03	lda $039b			lda 		NumConvCount 			; if not zero then no suppression check
.019ed0	c9 30		cmp #$30			cmp 		#"0"
.019ed2	d0 05		bne $019ed9			bne 		_ITSOutputDigit
.019ed4	ad 9a 03	lda $039a			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.019ed7	10 09		bpl $019ee2			bpl	 		_ITSGoNextSubtractor
.019ed9					_ITSOutputDigit:
.019ed9	ce 9a 03	dec $039a			dec 		NumSuppress 			; suppression check will be non-zero.
.019edc	ad 9b 03	lda $039b			lda 		NumConvCount 			; count of subtractions
.019edf	20 1a 9f	jsr $019f1a			jsr 		ITSOutputCharacter 		; output it.
.019ee2					_ITSGoNextSubtractor:
.019ee2	e8		inx				inx 								; next dword
.019ee3	e8		inx				inx
.019ee4	e8		inx				inx
.019ee5	e8		inx				inx
.019ee6	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.019ee8	d0 a5		bne $019e8f			bne 		_ITSNextSubtractor 		; do all the subtractors.
.019eea	98		tya				tya 								; X is back as the mantissa index
.019eeb	aa		tax				tax
.019eec	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.019eee	09 30		ora #$30			ora 		#"0"
.019ef0	20 1a 9f	jsr $019f1a			jsr 		ITSOutputCharacter
.019ef3	7a		ply				ply 								; and exit
.019ef4	68		pla				pla
.019ef5	60		rts				rts
.019ef6					_ITSSubtractors:
>019ef6	00 ca 9a 3b					.dword 		1000000000
>019efa	00 e1 f5 05					.dword 		100000000
>019efe	80 96 98 00					.dword 		10000000
>019f02	40 42 0f 00					.dword 		1000000
>019f06	a0 86 01 00					.dword 		100000
>019f0a	10 27 00 00					.dword 		10000
>019f0e	e8 03 00 00					.dword 		1000
>019f12	64 00 00 00					.dword 		100
>019f16	0a 00 00 00					.dword 		10
.019f1a					_ITSSubtractorsEnd:
.019f1a					ITSOutputCharacter:
.019f1a	48		pha				pha
.019f1b	da		phx				phx
.019f1c	ae 14 03	ldx $0314			ldx 	NumBufX 					; save digit
.019f1f	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.019f22	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.019f24	9d 16 03	sta $0316,x			sta 	Num_Buffer+1,x
.019f27	ee 14 03	inc $0314			inc 	NumBufX						; bump pointer.
.019f2a	fa		plx				plx
.019f2b	68		pla				pla
.019f2c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.019f2d					IntFromString:
.019f2d	a0 00		ldy #$00			ldy 	#0
.019f2f	8c 9c 03	sty $039c			sty 	ExpTemp 					; this is the converted digit count.
.019f32					IntFromStringY:
.019f32	48		pha				pha
.019f33	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.019f35	95 80		sta $80,x			sta 	XS_Mantissa,x
.019f37	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019f39	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019f3b	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019f3d	a9 01		lda #$01			lda 	#1
.019f3f	95 85		sta $85,x			sta 	XS_Type,x
.019f41					_IFSLoop:
.019f41	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.019f43	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.019f45	90 4e		bcc $019f95			bcc 	_IFSExit
.019f47	c9 3a		cmp #$3a			cmp 	#"9"+1
.019f49	b0 4a		bcs $019f95			bcs 	_IFSExit
.019f4b	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.019f4d	c9 0c		cmp #$0c			cmp 	#12
.019f4f	b0 4e		bcs $019f9f			bcs 	_IFSOverflow
.019f51	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.019f53	48		pha				pha
.019f54	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019f56	48		pha				pha
.019f57	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019f59	48		pha				pha
.019f5a	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019f5c	48		pha				pha
.019f5d	20 b4 9f	jsr $019fb4			jsr 	IFSX1ShiftLeft 				; double
.019f60	20 b4 9f	jsr $019fb4			jsr 	IFSX1ShiftLeft 				; x 4
.019f63	18		clc				clc 								; add saved value x 5
.019f64	68		pla				pla
.019f65	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.019f67	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019f69	68		pla				pla
.019f6a	75 81		adc $81,x			adc 	XS_Mantissa+1,x
.019f6c	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019f6e	68		pla				pla
.019f6f	75 82		adc $82,x			adc 	XS_Mantissa+2,x
.019f71	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019f73	68		pla				pla
.019f74	75 83		adc $83,x			adc 	XS_Mantissa+3,x
.019f76	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019f78	20 b4 9f	jsr $019fb4			jsr 	IFSX1ShiftLeft 				; x 10
.019f7b	ee 9c 03	inc $039c			inc 	ExpTemp 					; bump count of digits processed.
.019f7e	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.019f80	29 0f		and #$0f			and 	#15
.019f82	c8		iny				iny
.019f83	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.019f85	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019f87	90 b8		bcc $019f41			bcc 	_IFSLoop
.019f89	f6 81		inc $81,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.019f8b	d0 b4		bne $019f41			bne 	_IFSLoop
.019f8d	f6 82		inc $82,x			inc 	XS_Mantissa+2,x
.019f8f	d0 b0		bne $019f41			bne 	_IFSLoop
.019f91	f6 83		inc $83,x			inc 	XS_Mantissa+3,x
.019f93	80 ac		bra $019f41			bra 	_IFSLoop
.019f95					_IFSExit:
.019f95	98		tya				tya 								; get offset
.019f96					_IFSOkay:
.019f96	38		sec				sec
.019f97	ad 9c 03	lda $039c			lda 	ExpTemp
.019f9a	f0 01		beq $019f9d			beq 	_IFSSkipFail
.019f9c	18		clc				clc
.019f9d					_IFSSkipFail:
.019f9d	68		pla				pla 								; and exit.
.019f9e	60		rts				rts
.019f9f					_IFSOverflow:
.019f9f	20 79 85	jsr $018579			jsr 	ERR_Handler
>019fa2	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>019faa	20 6f 76 65 72 66 6c 6f 77 00
.019fb4					IFSX1ShiftLeft:
.019fb4	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.019fb6	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.019fb8	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.019fba	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.019fbc	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.019fbd					FPSubtract:
.019fbd	48		pha				pha
.019fbe	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.019fc0	49 80		eor #$80			eor 	#$80
.019fc2	95 8b		sta $8b,x			sta 	XS2_Type,x
.019fc4	68		pla				pla 								; --- and fall through ---
.019fc5					FPAdd:
.019fc5	48		pha				pha
.019fc6	b5 85		lda $85,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.019fc8	d0 05		bne $019fcf			bne 	_FPA_NegativeLHS
.019fca	20 e6 9f	jsr $019fe6			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.019fcd	68		pla				pla
.019fce	60		rts				rts
.019fcf					_FPA_NegativeLHS:
.019fcf	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.019fd1	49 80		eor #$80			eor 	#$80
.019fd3	95 85		sta $85,x			sta 	XS_Type,x
.019fd5	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of B and add
.019fd7	49 80		eor #$80			eor 	#$80
.019fd9	95 8b		sta $8b,x			sta 	XS2_Type,x
.019fdb	20 e6 9f	jsr $019fe6			jsr 	FPAdd_Worker 				; do the add calculation.
.019fde	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 back
.019fe0	49 80		eor #$80			eor 	#$80
.019fe2	95 85		sta $85,x			sta 	XS_Type,x
.019fe4	68		pla				pla
.019fe5	60		rts				rts
.019fe6					FPAdd_Worker:
.019fe6	34 8b		bit $8b,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.019fe8	70 07		bvs $019ff1			bvs 	_FPAWExit 					; no change.
.019fea	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.019fec	50 07		bvc $019ff5			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.019fee	20 63 a2	jsr $01a263			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.019ff1					_FPAWExit:
.019ff1	20 d2 a2	jsr $01a2d2			jsr 	FPUNormalise 				; normalise the result.
.019ff4	60		rts				rts
.019ff5					_FPAWMakeSame:
.019ff5	b5 84		lda $84,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.019ff7	38		sec				sec
.019ff8	f5 8a		sbc $8a,x			sbc	 	XS2_Exponent,x 				; using subtraction
.019ffa	f0 16		beq $01a012			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.019ffc	da		phx				phx 								; save X
.019ffd	90 06		bcc $01a005			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.019fff	e8		inx				inx
.01a000	e8		inx				inx
.01a001	e8		inx				inx
.01a002	e8		inx				inx
.01a003	e8		inx				inx
.01a004	e8		inx				inx
.01a005					_FPAWShiftA:
.01a005	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.01a007	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.01a009	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a00b	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a00d	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a00f	fa		plx				plx 								; restore original X
.01a010	80 e3		bra $019ff5			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.01a012					_FPAW_DoArithmetic:
.01a012	34 8b		bit $8b,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.01a014	30 28		bmi $01a03e			bmi 	_FPAW_BNegative
.01a016	18		clc				clc
.01a017	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01a019	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.01a01b	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a01d	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a01f	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.01a021	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a023	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a025	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.01a027	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a029	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a02b	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.01a02d	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a02f	90 c0		bcc $019ff1			bcc 	_FPAWExit 					; no carry.
.01a031	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.01a033	38		sec				sec
.01a034	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.01a036	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a038	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a03a	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a03c	80 b3		bra $019ff1			bra 	_FPAWExit
.01a03e					_FPAW_BNegative:
.01a03e	38		sec				sec
.01a03f	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01a041	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.01a043	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a045	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a047	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.01a049	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a04b	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a04d	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.01a04f	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a051	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a053	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.01a055	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a057	b0 09		bcs $01a062			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.01a059	20 89 a2	jsr $01a289			jsr 	FPUNegateInteger			; negate the mantissa
.01a05c	b5 85		lda $85,x			lda 	XS_Type,x 					; flip result sign
.01a05e	49 80		eor #$80			eor 	#$80
.01a060	95 85		sta $85,x			sta 	XS_Type,x
.01a062					_FPAWGoExit:
.01a062	4c f1 9f	jmp $019ff1			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.01a065					FPD_IsDivZero:
.01a065	20 79 85	jsr $018579			jsr ERR_Handler
>01a068	44 69 76 69 73 69 6f 6e			.text "Division by zero",0
>01a070	20 62 79 20 7a 65 72 6f 00
.01a079					FPDivide:
.01a079	48		pha				pha
.01a07a	5a		phy				phy
.01a07b	34 8b		bit $8b,x			bit 	XS2_Type,x 					; check if division by zero
.01a07d	70 e6		bvs $01a065			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.01a07f	34 85		bit $85,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.01a081	f0 03		beq $01a086			beq 	_FPDCalculateExp
.01a083					_FPD_Exit:
.01a083	7a		ply				ply
.01a084	68		pla				pla
.01a085	60		rts				rts
.01a086					_FPDCalculateExp:
.01a086	b5 8a		lda $8a,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.01a088	49 ff		eor #$ff			eor 	#$FF
.01a08a	1a		inc a				inc 	a
.01a08b	95 8a		sta $8a,x			sta 	XS2_Exponent,x
.01a08d	20 5d a1	jsr $01a15d			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.01a090	18		clc				clc 	 							; add 1 to the resulting exponent
.01a091	69 01		adc #$01			adc 	#1
.01a093	b0 54		bcs $01a0e9			bcs 	_FPD_Overflow 				; which can overflow.
.01a095	95 84		sta $84,x			sta 	XS_Exponent,x
.01a097	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.01a099	85 1a		sta $1a				sta 	zLTemp1+0
.01a09b	85 1b		sta $1b				sta 	zLTemp1+1
.01a09d	85 1c		sta $1c				sta 	zLTemp1+2
.01a09f	85 1d		sta $1d				sta 	zLTemp1+3
.01a0a1	a0 20		ldy #$20			ldy 	#32 						; times round.
.01a0a3					_FPD_Loop:
.01a0a3	38		sec				sec 								; calculate X1-X2 stacking result because we might
.01a0a4	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; not save it.
.01a0a6	f5 86		sbc $86,x			sbc 	XS2_Mantissa,x
.01a0a8	48		pha				pha
.01a0a9	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a0ab	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.01a0ad	48		pha				pha
.01a0ae	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a0b0	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.01a0b2	48		pha				pha
.01a0b3	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a0b5	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.01a0b7	90 13		bcc $01a0cc			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.01a0b9	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; save results out to A
.01a0bb	68		pla				pla
.01a0bc	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a0be	68		pla				pla
.01a0bf	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a0c1	68		pla				pla
.01a0c2	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a0c4	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.01a0c6	09 80		ora #$80			ora 	#$80
.01a0c8	85 1d		sta $1d				sta 	zLTemp1+3
.01a0ca	80 03		bra $01a0cf			bra 	_FPD_Rotates
.01a0cc					_FPD_NoSubtract:
.01a0cc	68		pla				pla 								; throw away unwanted results
.01a0cd	68		pla				pla
.01a0ce	68		pla				pla
.01a0cf					_FPD_Rotates:
.01a0cf	56 89		lsr $89,x			lsr 	3+XS2_Mantissa,x
.01a0d1	76 88		ror $88,x			ror 	2+XS2_Mantissa,x
.01a0d3	76 87		ror $87,x			ror 	1+XS2_Mantissa,x
.01a0d5	76 86		ror $86,x			ror 	0+XS2_Mantissa,x
.01a0d7	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.01a0d9	26 1b		rol $1b				rol 	zLTemp1+1
.01a0db	26 1c		rol $1c				rol 	zLTemp1+2
.01a0dd	26 1d		rol $1d				rol 	zLTemp1+3
.01a0df	90 02		bcc $01a0e3			bcc 	_FPD_NoCarry
.01a0e1	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.01a0e3					_FPD_NoCarry:
.01a0e3	88		dey				dey 								; do 32 times
.01a0e4	d0 bd		bne $01a0a3			bne 	_FPD_Loop
.01a0e6	4c 41 a1	jmp $01a141			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.01a0e9					_FPD_Overflow:
.01a0e9	4c 2f a3	jmp $01a32f			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.01a0ec					FPMultiply:
.01a0ec	48		pha				pha
.01a0ed	5a		phy				phy
.01a0ee	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.01a0f0	70 07		bvs $01a0f9			bvs 	_FPM_Exit
.01a0f2	34 8b		bit $8b,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.01a0f4	50 06		bvc $01a0fc			bvc 	_FPM_CalcExponent
.01a0f6	20 63 a2	jsr $01a263			jsr 	FPUCopyX2ToX1
.01a0f9					_FPM_Exit:
.01a0f9	7a		ply				ply
.01a0fa	68		pla				pla
.01a0fb	60		rts				rts
.01a0fc					_FPM_CalcExponent:
.01a0fc	18		clc				clc
.01a0fd	20 5d a1	jsr $01a15d			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.01a100	95 84		sta $84,x			sta 	XS_Exponent,x 				; save the result.
.01a102	a9 00		lda #$00			lda 	#0
.01a104	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.01a106	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.01a108	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.01a10a	85 1d		sta $1d				sta 	zLTemp1+3
.01a10c	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.01a10e					_FPM_Loop:
.01a10e	b5 80		lda $80,x			lda 	XS_Mantissa,x				; check LSB of long product
.01a110	29 01		and #$01			and 	#1
.01a112	18		clc				clc 								; clear carry for the long rotate.
.01a113	f0 19		beq $01a12e			beq 	_FPM_NoAddition
.01a115	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.01a116	a5 1a		lda $1a				lda 	zLTemp1+0
.01a118	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.01a11a	85 1a		sta $1a				sta 	zLTemp1+0
.01a11c	a5 1b		lda $1b				lda 	zLTemp1+1
.01a11e	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.01a120	85 1b		sta $1b				sta 	zLTemp1+1
.01a122	a5 1c		lda $1c				lda 	zLTemp1+2
.01a124	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.01a126	85 1c		sta $1c				sta 	zLTemp1+2
.01a128	a5 1d		lda $1d				lda 	zLTemp1+3
.01a12a	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.01a12c	85 1d		sta $1d				sta 	zLTemp1+3
.01a12e					_FPM_NoAddition:
.01a12e	66 1d		ror $1d				ror 	3+zLTemp1
.01a130	66 1c		ror $1c				ror 	2+zLTemp1
.01a132	66 1b		ror $1b				ror 	1+zLTemp1
.01a134	66 1a		ror $1a				ror 	0+zLTemp1
.01a136	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.01a138	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a13a	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a13c	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a13e	88		dey				dey
.01a13f	d0 cd		bne $01a10e			bne 	_FPM_Loop 					; do this 32 times.
.01a141					FPM_CopySignNormalize:
.01a141	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.01a143	95 80		sta $80,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.01a145	a5 1b		lda $1b				lda 	zLTemp1+1
.01a147	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a149	a5 1c		lda $1c				lda 	zLTemp1+2
.01a14b	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a14d	a5 1d		lda $1d				lda 	zLTemp1+3
.01a14f	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a151	b5 85		lda $85,x			lda 	XS_Type,x 					; sign is xor of signs
.01a153	55 8b		eor $8b,x			eor 	XS2_Type,x
.01a155	95 85		sta $85,x			sta 	XS_Type,x
.01a157	20 d2 a2	jsr $01a2d2			jsr 	FPUNormalise 				; normalise and exit.
.01a15a	7a		ply				ply
.01a15b	68		pla				pla
.01a15c	60		rts				rts
.01a15d					FPCalculateExponent:
.01a15d	18		clc				clc
.01a15e	b5 84		lda $84,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.01a160	75 8a		adc $8a,x			adc 	XS2_Exponent,x
.01a162	b0 08		bcs $01a16c			bcs 	_FPCECarry 					; carry out ?
.01a164	10 03		bpl $01a169			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.01a166	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.01a168	60		rts				rts
.01a169					_FPCEExpZero:
.01a169	a9 00		lda #$00			lda 	#0
.01a16b	60		rts				rts
.01a16c					_FPCECarry:
.01a16c	30 03		bmi $01a171			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.01a16e	09 80		ora #$80			ora 	#$80 						; put in right range
.01a170	60		rts				rts
.01a171					_FPCEOverflow:
.01a171	4c 2f a3	jmp $01a32f			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.01a174					FPFractionalPart:
.01a174	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.01a176	38		sec				sec 								; this flag tells us to keep the fractional part
.01a177	30 0d		bmi $01a186			bmi 	FPGetPart
.01a179	60		rts				rts
.01a17a					FPIntegerPart:
.01a17a	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.01a17c	18		clc				clc 								; this flag says keep the integer part.
.01a17d	30 07		bmi $01a186			bmi 	FPGetPart 					; -ve exponents are 0..127
.01a17f	48		pha				pha
.01a180	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.01a182	95 85		sta $85,x			sta 	XS_Type,x
.01a184	68		pla				pla
.01a185	60		rts				rts
.01a186					FPGetPart:
.01a186	48		pha				pha
.01a187	5a		phy				phy 								; save Y
.01a188	08		php				php 								; save action
.01a189	34 85		bit $85,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.01a18b	70 59		bvs $01a1e6			bvs 	_FPGP_Exit 					; then do nothing.
.01a18d	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.01a18f	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.01a191	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.01a193	85 1c		sta $1c				sta 	zLTemp1+2
.01a195	85 1d		sta $1d				sta 	zLTemp1+3
.01a197	b5 84		lda $84,x			lda 	XS_Exponent,x				; the number of shifts.
.01a199	38		sec				sec
.01a19a	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.01a19c	f0 12		beq $01a1b0			beq 	_FPGP_NoShift 				; ... if any
.01a19e	c9 20		cmp #$20			cmp 	#32
.01a1a0	90 02		bcc $01a1a4			bcc 	_FPGP_NotMax
.01a1a2	a9 20		lda #$20			lda 	#32 						; max of 32.
.01a1a4					_FPGP_NotMax:
.01a1a4	a8		tay				tay 								; Y is the mask shift count.
.01a1a5					_FPGP_ShiftMask:
.01a1a5	46 1d		lsr $1d				lsr 	3+zLTemp1
.01a1a7	66 1c		ror $1c				ror 	2+zLTemp1
.01a1a9	66 1b		ror $1b				ror 	1+zLTemp1
.01a1ab	66 1a		ror $1a				ror 	0+zLTemp1
.01a1ad	88		dey				dey
.01a1ae	d0 f5		bne $01a1a5			bne 	_FPGP_ShiftMask
.01a1b0					_FPGP_NoShift:
.01a1b0	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.01a1b2	8e 9c 03	stx $039c			stx 	ExpTemp						; save X
.01a1b5					_FPGP_MaskLoop:
.01a1b5	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.01a1b8	28		plp				plp 								; if CC we keep the top part, so we
.01a1b9	08		php				php		 							; flip the mask.
.01a1ba	b0 02		bcs $01a1be			bcs		_FPGP_NoFlip
.01a1bc	49 ff		eor #$ff			eor 	#$FF
.01a1be					_FPGP_NoFlip:
.01a1be	35 80		and $80,x			and 	XS_Mantissa,x 				; and into the mantissa.
.01a1c0	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a1c2	e8		inx				inx
.01a1c3	c8		iny				iny
.01a1c4	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.01a1c6	d0 ed		bne $01a1b5			bne 	_FPGP_MaskLoop
.01a1c8	ae 9c 03	ldx $039c			ldx 	ExpTemp						; restore X
.01a1cb	28		plp				plp
.01a1cc	08		php				php 								; get action flag on the stack
.01a1cd	90 04		bcc $01a1d3			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.01a1cf	a9 00		lda #$00			lda 	#0
.01a1d1	95 85		sta $85,x			sta 	XS_Type,x
.01a1d3					_FPGP_NotFractional:
.01a1d3	b5 80		lda $80,x			lda 	XS_Mantissa,x 						; check if \1 zero
.01a1d5	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.01a1d7	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01a1d9	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01a1db	f0 05		beq $01a1e2			beq 	_FPGP_Zero 					; if zero, return zero
.01a1dd	20 d2 a2	jsr $01a2d2			jsr 	FPUNormalise
.01a1e0	80 04		bra $01a1e6			bra 	_FPGP_Exit 					; and exit
.01a1e2					_FPGP_Zero:
.01a1e2	a9 40		lda #$40			lda 	#$40 						; set zero flag
.01a1e4	95 85		sta $85,x			sta 	XS_Type,x
.01a1e6					_FPGP_Exit:
.01a1e6	68		pla				pla 								; throw saved action flag.
.01a1e7	7a		ply				ply
.01a1e8	68		pla				pla
.01a1e9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.01a1ea					FPCompare:
.01a1ea	20 2b a2	jsr $01a22b			jsr 	FPFastCompare 				; fast compare try first
.01a1ed	b0 3b		bcs $01a22a			bcs 	_FPCExit 					; that worked.
.01a1ef	b5 84		lda $84,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.01a1f1	48		pha				pha
.01a1f2	b5 8a		lda $8a,x			lda 	XS2_Exponent,x
.01a1f4	48		pha				pha
.01a1f5	20 bd 9f	jsr $019fbd			jsr 	FPSubtract 					; calculate X1-X2
.01a1f8	34 85		bit $85,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.01a1fa	70 2a		bvs $01a226			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.01a1fc	68		pla				pla
.01a1fd	8d 9c 03	sta $039c			sta 	ExpTemp						; save first exponent in temporary reg.
.01a200	68		pla				pla
.01a201	38		sec				sec
.01a202	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; calculate AX-BX
.01a205	70 14		bvs $01a21b			bvs 	_FPCNotEqual				; overflow, can't be equal.
.01a207	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.01a208	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.01a20a	b0 0f		bcs $01a21b			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.01a20c	38		sec				sec
.01a20d	ad 9c 03	lda $039c			lda 	ExpTemp 					; get one of the exponents back.
.01a210	e9 12		sbc #$12			sbc 	#18 						; allow for 2^18 error, relatively.
.01a212	b0 02		bcs $01a216			bcs 	_FPCNotRange 				; keep in range.
.01a214	a9 01		lda #$01			lda 	#1
.01a216					_FPCNotRange:
.01a216	38		sec				sec
.01a217	f5 84		sbc $84,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.01a219	b0 0d		bcs $01a228			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.01a21b					_FPCNotEqual:
.01a21b	b5 85		lda $85,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.01a21d	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.01a21f	f0 02		beq $01a223			beq 	_FPCNE2
.01a221	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.01a223	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.01a224	80 04		bra $01a22a			bra 	_FPCExit
.01a226					_FPCPullZero:
.01a226	68		pla				pla 								; throw saved exponents
.01a227	68		pla				pla
.01a228					_FPCZero:
.01a228	a9 00		lda #$00			lda 	#0 							; and return zero
.01a22a					_FPCExit:
.01a22a	60		rts				rts
.01a22b					FPFastCompare:
.01a22b	34 85		bit $85,x			bit 	XS_Type,x 					; n1 is zero.
.01a22d	70 23		bvs $01a252			bvs 	_FPFLeftZero
.01a22f	34 8b		bit $8b,x			bit 	XS2_Type,x 					; n2 is zero
.01a231	b5 85		lda $85,x			lda 	XS_Type,x 					; if so, return sign bit of 1 (n-0)
.01a233	70 25		bvs $01a25a			bvs 	_FPFSignBit
.01a235	55 8b		eor $8b,x			eor 	XS2_Type,x 					; eor 2 type bits. now know both non-zero
.01a237	0a		asl a				asl 	a 							; put in CS if different.
.01a238	b5 85		lda $85,x			lda 	XS_Type,x 					; if signs different return sign of first
.01a23a	b0 1e		bcs $01a25a			bcs 	_FPFSignBit
.01a23c	38		sec				sec 								; same sign and not-zero. compare exponents
.01a23d	b5 84		lda $84,x			lda 	XS_Exponent,x 				; compare exponents. if the same, then fail.
.01a23f	f5 8a		sbc $8a,x			sbc 	XS2_Exponent,x 				; e.g. we have to do it via subtraction.
.01a241	f0 09		beq $01a24c			beq 	_FPNoFastCompare
.01a243	6a		ror a				ror 	a 							; put carry into bit 7.
.01a244	34 85		bit $85,x			bit 	XS_Type,X 					; if it is +x then flip it.
.01a246	30 02		bmi $01a24a			bmi		_FPFCNotMinus
.01a248	49 80		eor #$80			eor 	#$80
.01a24a					_FPFCNotMinus:
.01a24a	80 0e		bra $01a25a			bra		_FPFSignBit
.01a24c					_FPNoFastCompare:
.01a24c	18		clc				clc
.01a24d	60		rts				rts
.01a24e					_FPFZero:
.01a24e	a9 00		lda #$00			lda 	#0
.01a250					_FPFExitSet:
.01a250	38		sec				sec
.01a251	60		rts				rts
.01a252					_FPFLeftZero:
.01a252	34 8b		bit $8b,x			bit 	XS2_Type,x 					; if right is zero, return zero.
.01a254	70 f8		bvs $01a24e			bvs 	_FPFZero
.01a256	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip sign bit
.01a258	49 80		eor #$80			eor 	#$80						; return that as a sign.
.01a25a					_FPFSignBit:
.01a25a	0a		asl a				asl 	a
.01a25b	a9 01		lda #$01			lda 	#1
.01a25d	90 f1		bcc $01a250			bcc		_FPFExitSet
.01a25f	a9 ff		lda #$ff			lda 	#$FF
.01a261	38		sec				sec
.01a262	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.01a263					FPUCopyX2ToX1:
.01a263	48		pha				pha
.01a264	da		phx				phx
.01a265	5a		phy				phy
.01a266	a0 08		ldy #$08			ldy 	#8
.01a268	b5 86		lda $86,x	_FPUC21:lda 	XS2_Mantissa,x
.01a26a	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a26c	e8		inx				inx
.01a26d	88		dey				dey
.01a26e	10 f8		bpl $01a268			bpl 	_FPUC21
.01a270	7a		ply				ply
.01a271	fa		plx				plx
.01a272	68		pla				pla
.01a273	60		rts				rts
.01a274					FPUSetInteger:
.01a274	48		pha				pha
.01a275	95 80		sta $80,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.01a277	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.01a279	10 02		bpl $01a27d			bpl 	_FPUSIExtend
.01a27b	a9 ff		lda #$ff			lda 	#$FF
.01a27d					_FPUSIExtend:
.01a27d	95 81		sta $81,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.01a27f	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a281	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a283	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.01a285	95 85		sta $85,x			sta 	XS_Type,x
.01a287	68		pla				pla
.01a288	60		rts				rts
.01a289					FPUNegateInteger:
.01a289	48		pha				pha
.01a28a	38		sec				sec
.01a28b	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.01a28d	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.01a28f	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a291	a9 00		lda #$00			lda 	#0
.01a293	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.01a295	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a297	a9 00		lda #$00			lda 	#0
.01a299	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.01a29b	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a29d	a9 00		lda #$00			lda 	#0
.01a29f	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.01a2a1	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a2a3	68		pla				pla
.01a2a4	60		rts				rts
.01a2a5					FPUToFloat:
.01a2a5	48		pha				pha
.01a2a6	b5 85		lda $85,x			lda 	XS_Type,x					; exit if already float.
.01a2a8	29 0f		and #$0f			and 	#$0F
.01a2aa	f0 24		beq $01a2d0			beq 	_FPUFExit
.01a2ac	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.01a2ae	95 85		sta $85,x			sta 	XS_Type,x
.01a2b0	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.01a2b2	95 84		sta $84,x			sta 	XS_Exponent,x 				; x mantissa.
.01a2b4	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.01a2b6	10 07		bpl $01a2bf			bpl		_FPUFPositive
.01a2b8	20 89 a2	jsr $01a289			jsr 	FPUNegateInteger 			; negate the mantissa
.01a2bb	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.01a2bd	95 85		sta $85,x			sta 	XS_Type,x
.01a2bf					_FPUFPositive:
.01a2bf	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.01a2c1	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.01a2c3	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01a2c5	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01a2c7	d0 04		bne $01a2cd			bne 	_FPUFNonZero
.01a2c9	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.01a2cb	95 85		sta $85,x			sta 	XS_Type,x
.01a2cd					_FPUFNonZero:
.01a2cd	20 d2 a2	jsr $01a2d2			jsr 	FPUNormalise 				; normalise the floating point.
.01a2d0					_FPUFExit:
.01a2d0	68		pla				pla
.01a2d1	60		rts				rts
.01a2d2					FPUNormalise:
.01a2d2	48		pha				pha
.01a2d3	34 85		bit $85,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.01a2d5	70 18		bvs $01a2ef			bvs 	_FPUNExit
.01a2d7	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.01a2d9	f0 10		beq $01a2eb			beq 	_FPUNSetZero
.01a2db					_FPUNLoop:
.01a2db	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.01a2dd	30 10		bmi $01a2ef			bmi 	_FPUNExit 					; if so, we are normalised.
.01a2df	16 80		asl $80,x			asl 	0+XS_Mantissa+0,x
.01a2e1	36 81		rol $81,x			rol 	1+XS_Mantissa+0,x
.01a2e3	36 82		rol $82,x			rol 	2+XS_Mantissa+0,x
.01a2e5	36 83		rol $83,x			rol 	3+XS_Mantissa+0,x
.01a2e7	d6 84		dec $84,x			dec 	XS_Exponent,x 				; decrement exponent
.01a2e9	d0 f0		bne $01a2db			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.01a2eb					_FPUNSetZero:
.01a2eb	a9 40		lda #$40			lda 	#$40
.01a2ed	95 85		sta $85,x			sta 	XS_Type,x 					; the result is now zero.
.01a2ef					_FPUNExit:
.01a2ef	68		pla				pla
.01a2f0	60		rts				rts
.01a2f1					FPUToInteger:
.01a2f1	48		pha				pha
.01a2f2	b5 85		lda $85,x			lda 	XS_Type,x 					; if already integer, exit
.01a2f4	29 01		and #$01			and 	#1
.01a2f6	d0 31		bne $01a329			bne 	_FPUTOI_Exit
.01a2f8	34 85		bit $85,x			bit 	XS_Type,x					; if zero, return zero.
.01a2fa	70 23		bvs $01a31f			bvs 	_FPUTOI_Zero
.01a2fc	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.01a2fe	10 1f		bpl $01a31f			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.01a300	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.01a302	b0 2b		bcs $01a32f			bcs 	FP_Overflow
.01a304					_FPUToIToInteger:
.01a304	b5 84		lda $84,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.01a306	c9 a0		cmp #$a0			cmp 	#128+32
.01a308	f0 0c		beq $01a316			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.01a30a	f6 84		inc $84,x			inc 	XS_Exponent,X 				; increment Exponent
.01a30c	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.01a30e	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a310	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a312	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a314	80 ee		bra $01a304			bra 	_FPUToIToInteger 			; keep going.
.01a316					_FPUToICheckSign:
.01a316	b5 85		lda $85,x			lda 	XS_Type,x 					; check sign
.01a318	10 0f		bpl $01a329			bpl 	_FPUToI_Exit 				; exit if unsigned.
.01a31a	20 89 a2	jsr $01a289			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.01a31d	80 0a		bra $01a329			bra 	_FPUTOI_Exit
.01a31f					_FPUTOI_Zero:
.01a31f	a9 00		lda #$00			lda 	#0 							; return zero integer.
.01a321	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a323	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a325	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a327	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a329					_FPUToI_Exit:
.01a329	a9 01		lda #$01			lda 	#1 							; set type to integer
.01a32b	95 85		sta $85,x			sta 	XS_Type,x
.01a32d	68		pla				pla
.01a32e	60		rts				rts
.01a32f					FP_Overflow:
.01a32f	20 79 85	jsr $018579			jsr ERR_Handler
>01a332	46 6c 6f 61 74 69 6e 67			.text "Floating Point overflow",0
>01a33a	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.01a34a					FPUTimes10:
.01a34a	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.01a34c	85 1a		sta $1a				sta 	ZLTemp1+0
.01a34e	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a350	85 1b		sta $1b				sta 	ZLTemp1+1
.01a352	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a354	85 1c		sta $1c				sta 	ZLTemp1+2
.01a356	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a358	85 1d		sta $1d				sta 	ZLTemp1+3
.01a35a	20 8f a3	jsr $01a38f			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.01a35d	20 8f a3	jsr $01a38f			jsr 	_FPUT_LSR_ZLTemp1
.01a360	18		clc				clc
.01a361	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.01a363	65 1a		adc $1a				adc 	ZLTemp1+0
.01a365	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a367	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a369	65 1b		adc $1b				adc 	ZLTemp1+1
.01a36b	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a36d	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a36f	65 1c		adc $1c				adc 	ZLTemp1+2
.01a371	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a373	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a375	65 1d		adc $1d				adc 	ZLTemp1+3
.01a377	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a379	90 0a		bcc $01a385			bcc 	_FPUTimes10
.01a37b	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.01a37d	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a37f	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a381	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a383	f6 84		inc $84,x			inc 	XS_Exponent,x				; fix exponent
.01a385					_FPUTimes10:
.01a385	b5 84		lda $84,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.01a387	18		clc				clc
.01a388	69 03		adc #$03			adc 	#3
.01a38a	95 84		sta $84,x			sta 	XS_Exponent,x
.01a38c	b0 a1		bcs $01a32f			bcs 	FP_Overflow 				; error
.01a38e	60		rts				rts
.01a38f					_FPUT_LSR_ZLTemp1:
.01a38f	46 1d		lsr $1d				lsr 	ZLTemp1+3
.01a391	66 1c		ror $1c				ror 	ZLTemp1+2
.01a393	66 1b		ror $1b				ror 	ZLTemp1+1
.01a395	66 1a		ror $1a				ror 	ZLTemp1+0
.01a397	60		rts				rts
.01a398					FPUScale10A:
.01a398	5a		phy				phy
.01a399	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.01a39b	f0 37		beq $01a3d4			beq 	_FPUScaleExit
.01a39d	da		phx				phx 								; save X
.01a39e	e8		inx				inx
.01a39f	e8		inx				inx
.01a3a0	e8		inx				inx
.01a3a1	e8		inx				inx
.01a3a2	e8		inx				inx
.01a3a3	e8		inx				inx
.01a3a4	a8		tay				tay 								; save power scalar in Y.
.01a3a5	a9 00		lda #$00			lda 	#0
.01a3a7	95 80		sta $80,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.01a3a9	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a3ab	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a3ad	95 85		sta $85,x			sta 	XS_Type,x
.01a3af	a9 80		lda #$80			lda 	#$80
.01a3b1	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a3b3	a9 81		lda #$81			lda 	#$81
.01a3b5	95 84		sta $84,x			sta 	XS_Exponent,x
.01a3b7	5a		phy				phy 								; save 10^n on stack.
.01a3b8	c0 00		cpy #$00			cpy 	#0
.01a3ba	10 05		bpl $01a3c1			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.01a3bc	98		tya				tya
.01a3bd	49 ff		eor #$ff			eor 	#$FF
.01a3bf	1a		inc a				inc 	a
.01a3c0	a8		tay				tay
.01a3c1					_FPUSAbs:
.01a3c1	20 4a a3	jsr $01a34a			jsr 	FPUTimes10
.01a3c4	88		dey				dey
.01a3c5	d0 fa		bne $01a3c1			bne 	_FPUSAbs 					; tos is now 10^|AC|
.01a3c7	68		pla				pla 								; restore count in A
.01a3c8	fa		plx				plx 								; restore X pointing to number to scale.
.01a3c9	0a		asl a				asl 	a
.01a3ca	b0 05		bcs $01a3d1			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.01a3cc	20 ec a0	jsr $01a0ec			jsr 	FPMultiply 					; if clear multiply.
.01a3cf	80 03		bra $01a3d4			bra		_FPUScaleExit
.01a3d1					_FPUSDivide:
.01a3d1	20 79 a0	jsr $01a079			jsr 	FPDivide
.01a3d4					_FPUScaleExit:
.01a3d4	7a		ply				ply
.01a3d5	60		rts				rts
.01a3d6					FPUCopyToNext:
.01a3d6	a0 06		ldy #$06			ldy 		#6
.01a3d8	da		phx				phx
.01a3d9					_FPUCopy1:
.01a3d9	b5 80		lda $80,x			lda 	XS_Mantissa,x
.01a3db	95 86		sta $86,x			sta 	XS2_Mantissa,x
.01a3dd	e8		inx				inx
.01a3de	88		dey				dey
.01a3df	d0 f8		bne $01a3d9			bne 	_FPUCopy1
.01a3e1	fa		plx				plx
.01a3e2	60		rts				rts
.01a3e3					FPUCopyFromNext:
.01a3e3	a0 06		ldy #$06			ldy 		#6
.01a3e5	da		phx				phx
.01a3e6					_FPUCopy1:
.01a3e6	b5 86		lda $86,x			lda 	XS2_Mantissa,x
.01a3e8	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a3ea	e8		inx				inx
.01a3eb	88		dey				dey
.01a3ec	d0 f8		bne $01a3e6			bne 	_FPUCopy1
.01a3ee	fa		plx				plx
.01a3ef	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.01a3f0					FPToString:
.01a3f0	48		pha				pha
.01a3f1	5a		phy				phy
.01a3f2	34 85		bit $85,x			bit 		XS_Type,x 				; check zero flag
.01a3f4	50 0a		bvc $01a400			bvc 		_FPTSIsFloat 			; if zero,
.01a3f6					_FPTSZero:
.01a3f6	a9 30		lda #$30			lda 		#"0"
.01a3f8	20 1a 9f	jsr $019f1a			jsr 		ITSOutputCharacter
.01a3fb					_FPTSExit:
.01a3fb	7a		ply				ply
.01a3fc	68		pla				pla
.01a3fd	60		rts				rts
.01a3fe	80 fb		bra $01a3fb			bra 		_FPTSExit
.01a400					_FPTSIsFloat:
.01a400	b5 85		lda $85,x			lda 		XS_Type,x 				; is it signed ?
.01a402	10 09		bpl $01a40d			bpl 		_FPTSNotSigned
.01a404	a9 00		lda #$00			lda 		#0 						; clear sign flag
.01a406	95 85		sta $85,x			sta 		XS_Type,x
.01a408	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.01a40a	20 1a 9f	jsr $019f1a			jsr 		ITSOutputCharacter
.01a40d					_FPTSNotSigned:
.01a40d	b5 84		lda $84,x			lda 		XS_Exponent,x
.01a40f	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.01a411	b0 09		bcs $01a41c			bcs 		_FPTSExponent
.01a413	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.01a415	90 05		bcc $01a41c			bcc 		_FPTSExponent 			;
.01a417					_FPTSStandard:
.01a417	20 5b a4	jsr $01a45b			jsr 		FPTOutputBody 			; output the body.
.01a41a	80 df		bra $01a3fb			bra 		_FPTSExit
.01a41c					_FPTSExponent:
.01a41c	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.01a41e	8d 9d 03	sta $039d			sta 		ExpCount
.01a421					_FPTSExponentLoop:
.01a421	b5 84		lda $84,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.01a423	10 0e		bpl $01a433			bpl 		_FPTSTimes
.01a425	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.01a427	90 14		bcc $01a43d			bcc 		_FPTSScaledToExp
.01a429	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.01a42b	20 98 a3	jsr $01a398			jsr 		FPUScale10A
.01a42e	ee 9d 03	inc $039d			inc 		ExpCount
.01a431	80 ee		bra $01a421			bra 		_FPTSExponentLoop
.01a433					_FPTSTimes:
.01a433	a9 01		lda #$01			lda 		#1
.01a435	20 98 a3	jsr $01a398			jsr 		FPUScale10A
.01a438	ce 9d 03	dec $039d			dec 		ExpCount
.01a43b	80 e4		bra $01a421			bra 		_FPTSExponentLoop
.01a43d					_FPTSScaledToExp:
.01a43d	20 5b a4	jsr $01a45b			jsr 		FPTOutputBody 			; output the body.
.01a440	a9 65		lda #$65			lda 		#"e"					; output E
.01a442	20 1a 9f	jsr $019f1a			jsr 		ITSOutputCharacter
.01a445	ad 9d 03	lda $039d			lda 		ExpCount 				; get the exponent
.01a448	95 80		sta $80,x			sta 		XS_Mantissa,x
.01a44a	29 80		and #$80			and 		#$80 					; sign extend it
.01a44c	f0 02		beq $01a450			beq 		_FPTSSExt
.01a44e	a9 ff		lda #$ff			lda 		#$FF
.01a450					_FPTSSExt:
.01a450	95 81		sta $81,x			sta 		XS_Mantissa+1,x
.01a452	95 82		sta $82,x			sta 		XS_Mantissa+2,x
.01a454	95 83		sta $83,x			sta 		XS_Mantissa+3,x
.01a456	20 78 9e	jsr $019e78			jsr 		INTToString 			; output the exponent.
.01a459	80 a0		bra $01a3fb			bra			_FPTSExit 				; and exit.
.01a45b					FPTOutputBody:
.01a45b	20 d6 a3	jsr $01a3d6			jsr 		FPUCopyToNext 			; copy to next slot.
.01a45e	20 f1 a2	jsr $01a2f1			jsr 		FPUToInteger 			; convert to an integer
.01a461	20 78 9e	jsr $019e78			jsr 		INTToString 			; output the main integer part.
.01a464	20 e3 a3	jsr $01a3e3			jsr 		FPUCopyFromNext 		; get the fractional part back.
.01a467	20 74 a1	jsr $01a174			jsr 		FPFractionalPart 		; get the decimal part.
.01a46a	34 85		bit $85,x			bit 		XS_Type,x 				; any fractional part.
.01a46c	70 3c		bvs $01a4aa			bvs 		_FPTOExit 				; if not, exit now.
.01a46e	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.01a470	20 1a 9f	jsr $019f1a			jsr 		ITSOutputCharacter
.01a473					_FPOutLoop:
.01a473	34 85		bit $85,x			bit 		XS_Type,x 				; finally reached zero.
.01a475	70 1d		bvs $01a494			bvs 		_FPStripZeros 			; strip trailing zeros
.01a477	20 4a a3	jsr $01a34a			jsr 		FPUTimes10 				; multiply by 10
.01a47a	20 d6 a3	jsr $01a3d6			jsr 		FPUCopyToNext			; copy to next slot.
.01a47d	20 f1 a2	jsr $01a2f1			jsr 		FPUToInteger 			; convert to integer
.01a480	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; print digit.
.01a482	09 30		ora #$30			ora 		#"0"
.01a484	20 1a 9f	jsr $019f1a			jsr 		ITSOutputCharacter
.01a487	20 e3 a3	jsr $01a3e3			jsr 		FPUCopyFromNext 		; get it back
.01a48a	20 74 a1	jsr $01a174			jsr 		FPFractionalPart 		; get fractional part
.01a48d	ad 14 03	lda $0314			lda 		NumBufX 				; done 11 characters yet ?
.01a490	c9 0b		cmp #$0b			cmp 	 	#11
.01a492	90 df		bcc $01a473			bcc 		_FPOutLoop 				; if so, keep going till zero.
.01a494					_FPStripZeros:
.01a494	ac 14 03	ldy $0314			ldy 		NumBufX 				; strip trailing zeros.
.01a497					_FPStripLoop:
.01a497	88		dey				dey 								; back one, if at start then no strip
.01a498	f0 10		beq $01a4aa			beq 		_FPToExit
.01a49a	b9 15 03	lda $0315,y			lda 		Num_Buffer,y 			; keep going if "0"
.01a49d	c9 30		cmp #$30			cmp 		#"0"
.01a49f	f0 f6		beq $01a497			beq 		_FPStripLoop
.01a4a1	c8		iny				iny
.01a4a2	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.01a4a4	99 15 03	sta $0315,y			sta 		Num_Buffer,y
.01a4a7	8c 14 03	sty $0314			sty 		NumBufX 				; update position.
.01a4aa					_FPTOExit:
.01a4aa	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.01a4ab					FPFromString:
.01a4ab	48		pha				pha 								; push A
.01a4ac	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.01a4ae	c9 2e		cmp #$2e			cmp 	#"."
.01a4b0	f0 03		beq $01a4b5			beq	 	_FPFIsDecimal
.01a4b2	4c 11 a5	jmp $01a511			jmp 	_FPFNotDecimal
.01a4b5					_FPFIsDecimal:
.01a4b5	c8		iny				iny 								; consume the decimal.
.01a4b6	20 a5 a2	jsr $01a2a5			jsr 	FPUToFloat 					; convert the integer to float.
.01a4b9	da		phx				phx 								; save X.
.01a4ba	5a		phy				phy 								; save decimal start position
.01a4bb	e8		inx				inx
.01a4bc	e8		inx				inx
.01a4bd	e8		inx				inx
.01a4be	e8		inx				inx
.01a4bf	e8		inx				inx
.01a4c0	e8		inx				inx
.01a4c1	20 32 9f	jsr $019f32			jsr 	INTFromStringY 				; get the part after the DP.
.01a4c4	20 a5 a2	jsr $01a2a5			jsr 	FPUToFloat 					; convert that to a float.
.01a4c7	68		pla				pla 								; calculate - chars consumed.
.01a4c8	8c 9c 03	sty $039c			sty 	ExpTemp
.01a4cb	38		sec				sec
.01a4cc	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; this is the shift amount
.01a4cf	20 98 a3	jsr $01a398			jsr 	FPUScale10A 				; scale it by 10^AC
.01a4d2	fa		plx				plx 								; restore original X
.01a4d3	20 c5 9f	jsr $019fc5			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.01a4d6	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.01a4d8	c9 45		cmp #$45			cmp 	#"E"
.01a4da	f0 04		beq $01a4e0			beq 	_FPFExponent
.01a4dc	c9 65		cmp #$65			cmp 	#"e"
.01a4de	d0 31		bne $01a511			bne 	_FPFNotDecimal 				; no, then exit normally.
.01a4e0					_FPFExponent:
.01a4e0	c8		iny				iny 								; skip over E symbol.
.01a4e1	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.01a4e3	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.01a4e5	d0 01		bne $01a4e8			bne 	_FPFGotSign
.01a4e7	c8		iny				iny 								; if it was - skip over it.
.01a4e8					_FPFGotSign:
.01a4e8	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.01a4e9	da		phx				phx
.01a4ea	e8		inx				inx
.01a4eb	e8		inx				inx
.01a4ec	e8		inx				inx
.01a4ed	e8		inx				inx
.01a4ee	e8		inx				inx
.01a4ef	e8		inx				inx
.01a4f0	20 32 9f	jsr $019f32			jsr 	INTFromStringY 				; get the exponent
.01a4f3	fa		plx				plx 								; restore X.
.01a4f4	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.01a4f6	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.01a4f8	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.01a4fa	d0 17		bne $01a513			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.01a4fc	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.01a4fe	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.01a500	b0 11		bcs $01a513			bcs 	_FPFXOverflow
.01a502	68		pla				pla 								; get direction
.01a503	d0 07		bne $01a50c			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.01a505	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.01a507	49 ff		eor #$ff			eor 	#$FF
.01a509	1a		inc a				inc 	a
.01a50a	95 86		sta $86,x			sta 	XS2_Mantissa+0,x
.01a50c					_FPFXScale:
.01a50c	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.01a50e	20 98 a3	jsr $01a398			jsr 	FPUScale10A 				; scale by the exponent.
.01a511					_FPFNotDecimal:
.01a511	68		pla				pla
.01a512	60		rts				rts
.01a513					_FPFXOverflow:
.01a513	20 79 85	jsr $018579			jsr 	ERR_Handler
>01a516	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>01a51e	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.01a525					Unary_Rnd:
.01a525	20 93 92	jsr $019293			jsr 	EvaluateNumberX 			; get value
.01a528	20 e8 98	jsr $0198e8			jsr 	CheckNextRParen 			; check right bracket.
.01a52b	20 13 95	jsr $019513			jsr 	GetSignCurrent 				; get sign -1,0,1.
.01a52e	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.01a530	30 10		bmi $01a542			bmi 	_URSetSeed
.01a532	f0 28		beq $01a55c			beq 	_URMakeRandom 				; if zero return same number, don't advance sequence
.01a534	da		phx				phx
.01a535	a2 00		ldx #$00			ldx 	#0 							; run 16 bit RNG procession on upper/lower
.01a537	20 93 a5	jsr $01a593			jsr 	Random16
.01a53a	a2 02		ldx #$02			ldx 	#2
.01a53c	20 93 a5	jsr $01a593			jsr 	Random16
.01a53f	fa		plx				plx
.01a540	80 1a		bra $01a55c			bra 	_URMakeRandom
.01a542					_URSetSeed:
.01a542	20 a5 a2	jsr $01a2a5			jsr 	FPUToFloat 					; make it a float to twiddle it.
.01a545	b5 80		lda $80,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.01a547	8d a3 03	sta $03a3			sta 	RandomSeed+0
.01a54a	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.01a54c	8d a4 03	sta $03a4			sta 	RandomSeed+1
.01a54f	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.01a551	8d a5 03	sta $03a5			sta 	RandomSeed+2
.01a554	b5 83		lda $83,x			lda		XS_Mantissa+3,x 			; this is to make the seed bear not much
.01a556	0a		asl a				asl 	a 							; resemblance to the seed value.
.01a557	49 db		eor #$db			eor 	#$DB
.01a559	8d a6 03	sta $03a6			sta 	RandomSeed+3
.01a55c					_URMakeRandom:
.01a55c	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; check if seed is zero.
.01a55f	0d a4 03	ora $03a4			ora 	RandomSeed+1
.01a562	0d a5 03	ora $03a5			ora 	RandomSeed+2
.01a565	0d a6 03	ora $03a6			ora 	RandomSeed+3
.01a568	d0 0a		bne $01a574			bne 	_URNotZero
.01a56a	a9 47		lda #$47			lda 	#$47						; if it is, make it non zero.
.01a56c	8d a4 03	sta $03a4			sta 	RandomSeed+1				; in both parts.
.01a56f	a9 3d		lda #$3d			lda 	#$3D
.01a571	8d a6 03	sta $03a6			sta 	RandomSeed+3
.01a574					_URNotZero:
.01a574	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; copy seed into mantissa.
.01a577	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a579	ad a4 03	lda $03a4			lda 	RandomSeed+1
.01a57c	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a57e	ad a5 03	lda $03a5			lda 	RandomSeed+2
.01a581	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a583	ad a6 03	lda $03a6			lda 	RandomSeed+3
.01a586	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a588	a9 00		lda #$00			lda 	#$00 						; set type to float.
.01a58a	95 85		sta $85,x			sta 	XS_Type,x
.01a58c	a9 80		lda #$80			lda 	#$80
.01a58e	95 84		sta $84,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.01a590	4c d2 a2	jmp $01a2d2			jmp 	FPUNormalise 				; and normalise.
.01a593					Random16:
.01a593	5e a4 03	lsr $03a4,x			lsr 	RandomSeed+1,x				; shift seed right
.01a596	7e a3 03	ror $03a3,x			ror 	RandomSeed,x
.01a599	90 08		bcc $01a5a3			bcc 	_R16_NoXor
.01a59b	bd a4 03	lda $03a4,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.01a59e	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.01a5a0	9d a4 03	sta $03a4,x			sta 	RandomSeed+1,x
.01a5a3					_R16_NoXor:
.01a5a3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.01a5a4					Unary_Int:
.01a5a4	20 93 92	jsr $019293			jsr 	EvaluateNumberX 			; get value
.01a5a7	20 e8 98	jsr $0198e8			jsr 	CheckNextRParen 			; check right bracket.
.01a5aa	4c f1 a2	jmp $01a2f1			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Return to file: basic.asm

>01a5ad	02						.byte 	2
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 c0						.word 	StartROM
>fffe	19 c0					.word TIM_BreakHandler

;******  End of listing
