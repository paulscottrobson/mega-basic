
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Thu Aug 29 10:26:47 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="4510"					cpu = "4510"
="mega65"				hardware = "mega65"
=1					exitonend = 1
=0					autorun = 0
=1					loadtest = 1
=1					hasfloat = 1
=1					hasinteger = 1
=253					maxstring = 253

;******  Processing file: modules/float/fpmacros.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/mega65/src_mega65.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stackmarkers.inc

=5					SourcePosSize   =   5 							; Source position stack space needed.
=0					SMark_Gosub 	= 	0 							; 0 is GOSUB/RETURN
=1					SMark_Repeat 	= 	1 							; 1 is REPEAT/UNTIL.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0020					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0022					zVarDataPtr: .word ? 						; position of variable data.
>0024					zVarType: 	.byte ? 						; type of data (token)
>0025					zNullString:.byte ? 						; represents a NULL string.
>0026					zBasicSP:	.word ? 						; stack pointer
>0080					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>0084					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>0085					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=134					XS2_Mantissa = XS_Mantissa+XS_Size
=138					XS2_Exponent = XS_Exponent+XS_Size
=139					XS2_Type = XS_Type+XS_Size
=140					XS3_Mantissa = XS_Mantissa+XS_Size*2
=144					XS3_Exponent = XS_Exponent+XS_Size*2
=145					XS3_Type = XS_Type+XS_Size*2
>0300					StringPtr:	.word ? 						; Top of free memory (for string allocation)
>0302					VarMemPtr: 	.word ?							; Bottom of free memory (for variables)
>0304					endOfProgram: .dword ? 						; End of Program Memory (long)
>0308					vecPrintCharacter .word ?
>030a					vecInputCharacter .word ?
>030c					UserVector .fill 4 							; USR(x) calls this.
>0310					LocalVector .fill 4 						; Indirect calls call this.
>0314					NumBufX 	.byte 	?						; buffer index position
>0315					Num_Buffer	.fill 	32 						; buffer for numeric conversions
=6					HashTableCount = 6 							; there are 6 hash tables, in token order.
=8					HashTableSize = 8 							; each hash table as 8 links.
.0335					HashTableBase:
>0335								.fill	HashTableCount * HashTableSize * 2
.0395					HashTableEnd:
=$315					Var_Buffer 	= Num_Buffer 					; buffer for variable name (same space)
>0395					Var_Type    .byte ? 						; type of variable (as a type token)
>0396					Var_Hash 	.byte ? 						; hash of identifier name.
>0397					Var_Length 	.byte ? 						; length of variable name
>0398					Var_HashAddress .byte ?						; low byte of hash table entry.
>0399					Var_DataSize .byte ?						; size of one element.
>039a					NumSuppress	.byte 	?						; leading zero suppression flag
>039b					NumConvCount .byte 	? 						; count for conversions.
>039c					ExpTemp:	.byte ?							; Working temp for exponents.
>039d					ExpCount:	.byte ? 						; Count of decimal exponents.
>039e					SignCount:	.byte ?							; Integer Divide Sign Counts.
>039f					TempStringWriteIndex: .byte ? 				; Write offset.
>03a0					ValSign: 	.byte ? 						; sign flag for val()
>03a1					SliceStart:	.byte ? 						; string slice parts
>03a2					SliceCount:	.byte ?
>03a3					RandomSeed:	.dword ? 						; Random seed.
=3					ArrayMaxDim = 3 							; number of dimensions.
>03a7					ArrayDef:	.fill (ArrayMaxDim+1)*2 		; dimensions for auto-creation
>03af					UsrArrayDef:.fill (ArrayMaxDim+1)*2 		; dimensions created in DIM
>03b7					UsrArrayIdx:.byte ? 						; index into UsrArrayDef
>03b8					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>03ba					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>03bc					Tim_SR:		.byte ? 						; Processor Status
>03bd					Tim_A:		.byte ? 						; Processor Registers
>03be					Tim_X:		.byte ?
>03bf					Tim_Y:		.byte ?
>03c0					Tim_Z:		.byte ?
>03c1					Tim_SP:		.word ?							; Stack Pointer (just in cases)
>0400					BasicStack:	.fill 	256 					; and occupy whole pages.
.0500					EndBasicStack:
>0500					IFT_XCursor:.byte ?							; current logical position on screen
>0501					IFT_YCursor:.byte ?
>0502					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0566					IFT_LineBuffer: .fill 100 					; line input buffer.

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/mega65.asm

=$7f00					HighMemory = $7F00
=$2000					VariableMemory = $2000
.8000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testcode.src

>8000	09 0a 00 d6 40 fd 03 31			.byte	$09,$0a,$00,$d6,$40,$fd,$03,$31
>8008	00 0d 14 00 ff 09 48 65			.byte	$00,$0d,$14,$00,$ff,$09,$48,$65
>8010	6c 6c 6f 20 21 00 07 1e			.byte	$6c,$6c,$6f,$20,$21,$00,$07,$1e
>8018	00 d0 c0 c4 00 18 28 00			.byte	$00,$d0,$c0,$c4,$00,$18,$28,$00
>8020	18 bb 84 40 c0 d6 fe 08			.byte	$18,$bb,$84,$40,$c0,$d6,$fe,$08
>8028	53 74 61 72 74 2e c1 40			.byte	$53,$74,$61,$72,$74,$2e,$c1,$40
>8030	fd 04 32 33 00 0a 32 00			.byte	$fd,$04,$32,$33,$00,$0a,$32,$00
>8038	91 c0 19 bb 84 40 00 21			.byte	$91,$c0,$19,$bb,$84,$40,$00,$21
>8040	3c 00 91 c0 19 bb 84 19			.byte	$3c,$00,$91,$c0,$19,$bb,$84,$19
>8048	bb 8a 41 c0 d6 18 bb c1			.byte	$bb,$8a,$41,$c0,$d6,$18,$bb,$c1
>8050	19 bb 8a 40 fd 04 30 35			.byte	$19,$bb,$8a,$40,$fd,$04,$30,$35
>8058	c1 c0 96 19 bb 84 43 00			.byte	$c1,$c0,$96,$19,$bb,$84,$43,$00
>8060	14 46 00 d6 c0 18 bb 84			.byte	$14,$46,$00,$d6,$c0,$18,$bb,$84
>8068	18 bb 8a 41 c0 96 18 bb			.byte	$18,$bb,$8a,$41,$c0,$96,$18,$bb
>8070	84 4f 68 00 0b 50 00 d6			.byte	$84,$4f,$68,$00,$0b,$50,$00,$d6
>8078	fe 06 45 6e 64 2e 00 05			.byte	$fe,$06,$45,$6e,$64,$2e,$00,$05
>8080	5a 00 c4 00 00				.byte	$5a,$00,$c4,$00,$00

;******  Return to file: modules/hardware/mega65.asm

.a000					StartROM:
.a000	a2 ff		ldx #$ff			ldx 		#$FF 					; empty stack
.a002	9a		txs				txs
.a003	20 4d a2	jsr $a24d			jsr 	IF_Reset 					; reset external interface
.a006	20 0c a0	jsr $a00c			jsr 	IFT_ClearScreen
.a009	4c 64 b0	jmp $b064		jmp BASIC_Start

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.a00c					IFT_ClearScreen:
.a00c	48		pha				pha
.a00d	da		phx				phx
.a00e	5a		phy				phy
.a00f	20 b4 a1	jsr $a1b4			jsr 	IF_Home 					; home cursor
.a012	a2 19		ldx #$19			ldx 	#IF_Height 					; this many lines.
.a014					_IFT_CS0:
.a014	a0 50		ldy #$50			ldy 	#IF_Width 					; this many chars/line
.a016					_IFT_CS1:
.a016	a9 20		lda #$20			lda 	#' '						; clear line.
.a018	20 e3 a1	jsr $a1e3			jsr 	IF_Write
.a01b	88		dey				dey
.a01c	d0 f8		bne $a016			bne 	_IFT_CS1
.a01e	20 c3 a1	jsr $a1c3			jsr 	IF_NewLine 					; next line down
.a021	ca		dex				dex
.a022	d0 f0		bne $a014			bne 	_IFT_CS0
.a024	7a		ply				ply
.a025	fa		plx				plx
.a026	68		pla				pla
.a027					IFT_HomeCursor:
.a027	48		pha				pha
.a028	20 b4 a1	jsr $a1b4			jsr 	IF_Home
.a02b	a9 00		lda #$00			lda 	#0
.a02d	8d 00 05	sta $0500			sta 	IFT_XCursor
.a030	8d 01 05	sta $0501			sta 	IFT_YCursor
.a033	68		pla				pla
.a034	60		rts				rts
.a035					IFT_UpLine:
.a035	48		pha				pha
.a036	ad 01 05	lda $0501			lda  	IFT_YCursor 				; get Y
.a039	3a		dec a				dec 	a 							; line above
.a03a	30 03		bmi $a03f			bmi 	_IFTULExit 					; too far, abort
.a03c	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos					; set to that line.
.a03f					_IFTULExit:
.a03f	68		pla				pla
.a040	60		rts				rts
.a041					IFT_PrintCharacter:
.a041	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.a043	f0 23		beq $a068			beq 	IFT_NewLine
.a045	48		pha				pha
.a046	20 80 a0	jsr $a080			jsr 	IFT_UpperCase 				; make upper case
.a049	20 e3 a1	jsr $a1e3			jsr 	IF_Write 					; write out.
.a04c	ee 00 05	inc $0500			inc 	IFT_XCursor 				; bump x cursor
.a04f	ad 00 05	lda $0500			lda 	IFT_XCursor 				; reached RHS ?
.a052	c9 50		cmp #$50			cmp 	#IF_Width
.a054	d0 03		bne $a059			bne 	_IFT_PCNotEOL
.a056	20 68 a0	jsr $a068			jsr 	IFT_NewLine 				; if so do new line.
.a059					_IFT_PCNotEOL:
.a059	68		pla				pla
.a05a	60		rts				rts
.a05b					IFT_Tab:
.a05b	a9 20		lda #$20			lda 	#" " 						; space
.a05d	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.a060	ad 00 05	lda $0500			lda 	IFT_XCursor 				; until x % 8 == 0
.a063	29 07		and #$07			and 	#7
.a065	d0 f4		bne $a05b			bne 	IFT_Tab
.a067	60		rts				rts
.a068					IFT_NewLine:
.a068	48		pha				pha
.a069	20 c3 a1	jsr $a1c3			jsr 	IF_NewLine 					; new line on actual screen.
.a06c	a9 00		lda #$00			lda 	#0 							; reset x position
.a06e	8d 00 05	sta $0500			sta 	IFT_XCursor
.a071	ee 01 05	inc $0501			inc 	IFT_YCursor 				; move down.
.a074	ad 01 05	lda $0501			lda 	IFT_YCursor
.a077	c9 19		cmp #$19			cmp 	#IF_Height 					; reached bottom.
.a079	d0 03		bne $a07e			bne 	_IFT_NL_NotEOS
.a07b	20 8b a0	jsr $a08b			jsr 	IFT_Scroll 					; scroll screen up.
.a07e					_IFT_NL_NotEOS:
.a07e	68		pla				pla
.a07f	60		rts				rts
.a080					IFT_UpperCase:
.a080	c9 61		cmp #$61			cmp 	#"a"
.a082	90 06		bcc $a08a			bcc 	_IFT_UCExit
.a084	c9 7b		cmp #$7b			cmp 	#"z"+1
.a086	b0 02		bcs $a08a			bcs 	_IFT_UCExit
.a088	49 20		eor #$20			eor 	#$20
.a08a					_IFT_UCExit:
.a08a	60		rts				rts
.a08b					IFT_Scroll:
.a08b	48		pha				pha 								; save AXY
.a08c	da		phx				phx
.a08d	5a		phy				phy
.a08e	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.a090					_IFT_SLoop:
.a090	20 b0 a0	jsr $a0b0			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.a093	e8		inx				inx
.a094	e0 18		cpx #$18			cpx 	#IF_Height-1				; do whole screen
.a096	d0 f8		bne $a090			bne 	_IFT_SLoop
.a098	a9 18		lda #$18			lda 	#IF_Height-1 				; move to X = 0,Y = A
.a09a	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a09d	a2 50		ldx #$50			ldx 	#IF_Width 					; blank line
.a09f					_IFT_SBlank:
.a09f	a9 20		lda #$20			lda 	#32
.a0a1	20 e3 a1	jsr $a1e3			jsr 	IF_Write
.a0a4	ca		dex				dex
.a0a5	d0 f8		bne $a09f			bne 	_IFT_SBlank
.a0a7	a9 18		lda #$18			lda 	#IF_Height-1 				; move to X = 0,Y = A
.a0a9	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a0ac	7a		ply				ply
.a0ad	fa		plx				plx
.a0ae	68		pla				pla
.a0af	60		rts				rts
.a0b0					_IFT_ScrollLine:
.a0b0	da		phx				phx
.a0b1	da		phx				phx
.a0b2	8a		txa				txa 								; copy line into buffer.
.a0b3	1a		inc a				inc 	a 							; next line down.
.a0b4	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a0b7	a2 00		ldx #$00			ldx 	#0
.a0b9					_IFTScrollCopy1:
.a0b9	20 d5 a1	jsr $a1d5			jsr 	IF_Read
.a0bc	9d 02 05	sta $0502,x			sta 	IFT_Buffer,x
.a0bf	e8		inx				inx
.a0c0	e0 50		cpx #$50			cpx 	#IF_Width
.a0c2	d0 f5		bne $a0b9			bne 	_IFTScrollCopy1
.a0c4	68		pla				pla
.a0c5	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a0c8	a2 00		ldx #$00			ldx 	#0
.a0ca					_IFTScrollCopy2:
.a0ca	bd 02 05	lda $0502,x			lda 	IFT_Buffer,x
.a0cd	20 e3 a1	jsr $a1e3			jsr 	IF_Write
.a0d0	e8		inx				inx
.a0d1	e0 50		cpx #$50			cpx 	#IF_Width
.a0d3	d0 f5		bne $a0ca			bne 	_IFTScrollCopy2
.a0d5	fa		plx				plx
.a0d6	60		rts				rts
.a0d7					IFT_SetYPos:
.a0d7	48		pha				pha
.a0d8	da		phx				phx
.a0d9	aa		tax				tax
.a0da	20 27 a0	jsr $a027			jsr 	IFT_HomeCursor
.a0dd	e0 00		cpx #$00			cpx 	#0
.a0df	f0 09		beq $a0ea			beq 	_IFT_MOAExit
.a0e1					_IFT_MOALoop:
.a0e1	20 c3 a1	jsr $a1c3			jsr 	IF_NewLine
.a0e4	ee 01 05	inc $0501			inc 	IFT_YCursor
.a0e7	ca		dex				dex
.a0e8	d0 f7		bne $a0e1			bne		_IFT_MOALoop
.a0ea					_IFT_MOAExit:
.a0ea	fa		plx				plx
.a0eb	68		pla				pla
.a0ec	60		rts				rts
.a0ed					IFT_GetKeyCursor:
.a0ed	20 f5 a0	jsr $a0f5			jsr 	_IFT_FlipCursor 			; reverse current
.a0f0					_IFT_GKCWait:
.a0f0	20 06 a2	jsr $a206			jsr 	IF_GetKey 					; get key
.a0f3	f0 fb		beq $a0f0			beq 	_IFT_GKCWait
.a0f5					_IFT_FlipCursor:
.a0f5	48		pha				pha 								; save
.a0f6	20 d5 a1	jsr $a1d5			jsr 	IF_Read 					; read
.a0f9	20 ee a1	jsr $a1ee			jsr 	IF_LeftOne
.a0fc	49 80		eor #$80			eor 	#$80 						; reverse
.a0fe	20 e3 a1	jsr $a1e3			jsr 	IF_Write 					; write
.a101	20 ee a1	jsr $a1ee			jsr 	IF_LeftOne
.a104	68		pla				pla
.a105	60		rts				rts
.a106					IFT_ReadLine:
.a106	48		pha				pha
.a107					_IFT_RLLoop:
.a107	20 ed a0	jsr $a0ed			jsr 	IFT_GetKeyCursor 			; get keystroke
.a10a	c9 0d		cmp #$0d			cmp 	#13							; return
.a10c	f0 7d		beq $a18b			beq 	_IFT_RLExit
.a10e	c9 20		cmp #$20			cmp 	#32 						; control character
.a110	90 05		bcc $a117			bcc 	_IFT_Control
.a112	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.a115	80 f0		bra $a107			bra 	_IFT_RLLoop
.a117					_IFT_Control:
.a117	c9 01		cmp #$01			cmp 	#"A"-64
.a119	f0 26		beq $a141			beq 	_IFT_Left
.a11b	c9 04		cmp #$04			cmp 	#"D"-64
.a11d	f0 2e		beq $a14d			beq 	_IFT_Right
.a11f	c9 17		cmp #$17			cmp 	#"W"-64
.a121	f0 36		beq $a159			beq 	_IFT_Up
.a123	c9 13		cmp #$13			cmp 	#"S"-64
.a125	f0 3e		beq $a165			beq 	_IFT_Down
.a127	c9 08		cmp #$08			cmp 	#"H"-64
.a129	f0 09		beq $a134			beq 	_IFT_Backspace
.a12b	c9 1a		cmp #$1a			cmp 	#"Z"-64
.a12d	d0 d8		bne $a107			bne 	_IFT_RLLoop
.a12f	20 0c a0	jsr $a00c			jsr 	IFT_ClearScreen				; clear CTL-Z
.a132	80 d3		bra $a107			bra 	_IFT_RLLoop
.a134					_IFT_Backspace:
.a134	ad 00 05	lda $0500			lda 	IFT_XCursor 				; check not start of line.
.a137	f0 ce		beq $a107			beq 	_IFT_RLLoop
.a139	20 ee a1	jsr $a1ee			jsr 	IF_LeftOne
.a13c	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.a13e	20 e3 a1	jsr $a1e3			jsr 	IF_Write
.a141					_IFT_Left:
.a141	ce 00 05	dec $0500			dec 	IFT_XCursor 				; left CTL-W
.a144	10 29		bpl $a16f			bpl 	_IFT_Reposition
.a146	a9 4f		lda #$4f			lda 	#IF_Width-1
.a148					_IFT_SetX:
.a148	8d 00 05	sta $0500			sta 	IFT_XCursor
.a14b	80 22		bra $a16f			bra 	_IFT_Reposition
.a14d					_IFT_Right:
.a14d	ee 00 05	inc $0500			inc 	IFT_XCursor
.a150	ad 00 05	lda $0500			lda 	IFT_XCursor
.a153	49 50		eor #$50			eor 	#IF_Width
.a155	f0 f1		beq $a148			beq 	_IFT_SetX
.a157	80 16		bra $a16f			bra 	_IFT_Reposition
.a159					_IFT_Up:
.a159	ce 01 05	dec $0501			dec 	IFT_YCursor
.a15c	10 11		bpl $a16f			bpl 	_IFT_Reposition
.a15e	a9 18		lda #$18			lda 	#IF_Height-1
.a160					_IFT_SetY:
.a160	8d 01 05	sta $0501			sta 	IFT_YCursor
.a163	80 0a		bra $a16f			bra 	_IFT_Reposition
.a165					_IFT_Down:
.a165	ee 01 05	inc $0501			inc 	IFT_YCursor
.a168	ad 01 05	lda $0501			lda 	IFT_YCursor
.a16b	49 19		eor #$19			eor 	#IF_Height
.a16d	f0 f1		beq $a160			beq 	_IFT_SetY
.a16f					_IFT_Reposition:
.a16f	ad 00 05	lda $0500			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.a172	48		pha				pha
.a173	ad 01 05	lda $0501			lda 	IFT_YCursor
.a176	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a179	68		pla				pla
.a17a	aa		tax				tax
.a17b	e0 00		cpx #$00			cpx 	#0
.a17d	f0 88		beq $a107			beq 	_IFT_RLLoop
.a17f					_IFT_MoveRight:
.a17f	20 d5 a1	jsr $a1d5			jsr 	IF_Read
.a182	ee 00 05	inc $0500			inc 	IFT_XCursor
.a185	ca		dex				dex
.a186	d0 f7		bne $a17f			bne 	_IFT_MoveRight
.a188	4c 07 a1	jmp $a107			jmp 	_IFT_RLLoop
.a18b					_IFT_RLExit:
.a18b	ad 01 05	lda $0501			lda 	IFT_YCursor 				; go to start of line.
.a18e	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a191	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.a193					_IFT_RLRead:
.a193	20 d5 a1	jsr $a1d5			jsr 	IF_Read
.a196	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.a199	e8		inx				inx
.a19a	e0 50		cpx #$50			cpx 	#IF_Width
.a19c	d0 f5		bne $a193			bne 	_IFT_RLRead
.a19e					_IFT_RL_Trim:
.a19e	ca		dex				dex 	 							; previous char
.a19f	30 07		bmi $a1a8			bmi 	_IFT_Found 					; gone too far
.a1a1	bd 66 05	lda $0566,x			lda 	IFT_LineBuffer,x			; go back if space
.a1a4	c9 20		cmp #$20			cmp 	#" "
.a1a6	f0 f6		beq $a19e			beq 	_IFT_RL_Trim
.a1a8					_IFT_Found:
.a1a8	e8		inx				inx 								; forward to non-space
.a1a9	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.a1ab	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.a1ae	68		pla				pla
.a1af	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.a1b1	a0 05		ldy #$05			ldy 	#IFT_LineBuffer >> 8
.a1b3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_mega65.asm

=80					IF_Width 	= 80 							; characters across
=25					IF_Height 	= 25 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line
=6					IF_XPos 	= 6 							; current position, horizontal.
=8					IF_FarPtr 	= 8 							; far pointer (4 bytes)
=$1000					IF_Screen = $1000							; 2k screen RAM here
=$800					IF_CharSet = $800							; 2k character set (0-7F) here
.a1b4					IF_Home:
.a1b4	48		pha				pha 								; reset cursor position
.a1b5	a9 00		lda #$00			lda 	#IF_Screen & $FF
.a1b7	85 04		sta $04				sta 	IF_Pos
.a1b9	a9 10		lda #$10			lda 	#IF_Screen >> 8
.a1bb	85 05		sta $05				sta 	IF_Pos+1
.a1bd	a9 00		lda #$00			lda 	#0
.a1bf	85 06		sta $06				sta 	IF_XPos
.a1c1	68		pla				pla
.a1c2	60		rts				rts
.a1c3					IF_NewLine:
.a1c3	48		pha				pha
.a1c4	a9 00		lda #$00			lda 	#0 							; back to start of line
.a1c6	85 06		sta $06				sta 	IF_XPos
.a1c8	18		clc				clc 								; down one line
.a1c9	a5 04		lda $04				lda 	IF_Pos
.a1cb	69 50		adc #$50			adc 	#80
.a1cd	85 04		sta $04				sta 	IF_Pos
.a1cf	90 02		bcc $a1d3			bcc 	_IF_NoCarry 				; carry through.
.a1d1	e6 05		inc $05				inc 	IF_Pos+1
.a1d3					_IF_NoCarry:
.a1d3	68		pla				pla
.a1d4	60		rts				rts
.a1d5					IF_Read:
.a1d5	5a		phy				phy 								; save current Y
.a1d6	a4 06		ldy $06				ldy 	IF_XPos 					; read character at current position
.a1d8	b1 04		lda ($04),y			lda 	(IF_Pos),y
.a1da	49 20		eor #$20			eor 	#$20
.a1dc	18		clc				clc
.a1dd	69 20		adc #$20			adc 	#$20
.a1df	e6 06		inc $06				inc 	IF_XPos 					; step right.
.a1e1	7a		ply				ply									; restore Y
.a1e2	60		rts				rts
.a1e3					IF_Write:
.a1e3	5a		phy				phy 								; save current Y
.a1e4	a4 06		ldy $06				ldy 	IF_XPos 					; write character at current position
.a1e6	29 bf		and #$bf			and 	#63+128 					; PETSCII
.a1e8	91 04		sta ($04),y			sta 	(IF_Pos),y
.a1ea	e6 06		inc $06				inc 	IF_XPos 					; step right.
.a1ec	7a		ply				ply									; restore Y
.a1ed	60		rts				rts
.a1ee					IF_LeftOne:
.a1ee	c6 06		dec $06				dec 	IF_XPos
.a1f0	60		rts				rts
.a1f1					IF_CheckBreak:
.a1f1	db		phz				phz
.a1f2	20 3a a2	jsr $a23a			jsr 	IF_SetupKeyAddress 			; point to keyboard
.a1f5	e6 08		inc $08				inc 	IF_FarPtr 					; point to modifiers.
.a1f7	ea		nop				nop 								; read modifiers.
.a1f8	b2 08		lda ($08),z			lda 	(IF_FarPtr),z
.a1fa	fb		plz				plz 								; restore Z
.a1fb	29 05		and #$05			and 	#5							; break is LeftShift+Ctrl
.a1fd	c9 05		cmp #$05			cmp 	#5
.a1ff	f0 02		beq $a203			beq 	_IF_CBExit
.a201	a9 00		lda #$00			lda 	#0
.a203					_IF_CBExit:
.a203	c9 00		cmp #$00			cmp 	#0
.a205	60		rts				rts
.a206					IF_GetKey:
.a206	db		phz				phz
.a207	20 3a a2	jsr $a23a			jsr 	IF_SetupKeyAddress
.a20a	ea		nop				nop 								; read keyboard
.a20b	b2 08		lda ($08),z			lda 	(IF_FarPtr),z
.a20d	c9 14		cmp #$14			cmp 	#20
.a20f	d0 02		bne $a213			bne 	_KMNo
.a211	a9 08		lda #$08			lda 	#"H"-64
.a213					_KMNo:
.a213	c9 91		cmp #$91			cmp 	#145
.a215	d0 02		bne $a219			bne 	_KMNo
.a217	a9 17		lda #$17			lda 	#"W"-64
.a219					_KMNo:
.a219	c9 11		cmp #$11			cmp 	#17
.a21b	d0 02		bne $a21f			bne 	_KMNo
.a21d	a9 13		lda #$13			lda 	#"S"-64
.a21f					_KMNo:
.a21f	c9 9d		cmp #$9d			cmp 	#157
.a221	d0 02		bne $a225			bne 	_KMNo
.a223	a9 01		lda #$01			lda 	#"A"-64
.a225					_KMNo:
.a225	c9 1d		cmp #$1d			cmp 	#29
.a227	d0 02		bne $a22b			bne 	_KMNo
.a229	a9 04		lda #$04			lda 	#"D"-64
.a22b					_KMNo:
.a22b	c9 00		cmp #$00			cmp 	#0
.a22d	f0 07		beq $a236			beq 	_IFGKEmpty
.a22f	48		pha				pha
.a230	a9 00		lda #$00			lda 	#0
.a232	ea		nop				nop
.a233	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a235	68		pla				pla
.a236					_IFGKEmpty:
.a236	fb		plz				plz
.a237	c9 00		cmp #$00			cmp 	#0 							; set Z
.a239	60		rts				rts
.a23a					IF_SetupKeyAddress:
.a23a	a9 0f		lda #$0f			lda 	#$0F 						; set up to write to read keyboard.
.a23c	85 0b		sta $0b				sta 	IF_FarPtr+3
.a23e	a9 fd		lda #$fd			lda 	#$FD
.a240	85 0a		sta $0a				sta 	IF_FarPtr+2
.a242	a9 36		lda #$36			lda 	#$36
.a244	85 09		sta $09				sta 	IF_FarPtr+1
.a246	a9 10		lda #$10			lda 	#$10
.a248	85 08		sta $08				sta 	IF_FarPtr+0
.a24a	a3 00		ldz #$00			ldz 	#0
.a24c	60		rts				rts
.a24d					IF_Reset:
.a24d	48		pha				pha 								; save registers
.a24e	da		phx				phx
.a24f	5a		phy				phy
.a250	a9 0f		lda #$0f			lda 	#$0F 						; set up to write to video system.
.a252	85 0b		sta $0b				sta 	IF_FarPtr+3
.a254	a9 fd		lda #$fd			lda 	#$FD
.a256	85 0a		sta $0a				sta 	IF_FarPtr+2
.a258	a9 30		lda #$30			lda 	#$30
.a25a	85 09		sta $09				sta 	IF_FarPtr+1
.a25c	a9 00		lda #$00			lda 	#$00
.a25e	85 08		sta $08				sta 	IF_FarPtr+0
.a260	a3 2f		ldz #$2f			ldz 	#$2F 						; address already set up
.a262	a9 47		lda #$47			lda 	#$47
.a264	ea		nop				nop
.a265	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a267	a3 2f		ldz #$2f			ldz 	#$2F 						; address already set up
.a269	a9 53		lda #$53			lda 	#$53
.a26b	ea		nop				nop
.a26c	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a26e	a3 30		ldz #$30			ldz 	#$30 						; address already set up
.a270	a9 40		lda #$40			lda 	#$40
.a272	ea		nop				nop
.a273	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a275	a3 31		ldz #$31			ldz 	#$31 						; address already set up
.a277	a9 c0		lda #$c0			lda 	#$80+$40
.a279	ea		nop				nop
.a27a	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a27c	a3 20		ldz #$20			ldz 	#$20 						; address already set up
.a27e	a9 00		lda #$00			lda 	#0
.a280	ea		nop				nop
.a281	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a283	a3 21		ldz #$21			ldz 	#$21 						; address already set up
.a285	a9 00		lda #$00			lda 	#0
.a287	ea		nop				nop
.a288	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a28a	a3 54		ldz #$54			ldz 	#$54 						; address already set up
.a28c	a9 40		lda #$40			lda 	#$40
.a28e	ea		nop				nop
.a28f	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a291	a3 01		ldz #$01			ldz 	#$01 						; address already set up
.a293	a9 ff		lda #$ff			lda 	#$FF
.a295	ea		nop				nop
.a296	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a298	a3 00		ldz #$00			ldz 	#$00 						; address already set up
.a29a	a9 ff		lda #$ff			lda 	#$FF
.a29c	ea		nop				nop
.a29d	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a29f	a3 16		ldz #$16			ldz 	#$16 						; address already set up
.a2a1	a9 cc		lda #$cc			lda 	#$CC
.a2a3	ea		nop				nop
.a2a4	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2a6	a3 18		ldz #$18			ldz 	#$18 						; address already set up
.a2a8	a9 42		lda #$42			lda 	#$42
.a2aa	ea		nop				nop
.a2ab	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2ad	a3 11		ldz #$11			ldz 	#$11 						; address already set up
.a2af	a9 1b		lda #$1b			lda 	#$1B
.a2b1	ea		nop				nop
.a2b2	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2b4	a9 00		lda #$00			lda 	#$00						; colour RAM at $1F800-1FFFF (2kb)
.a2b6	85 0b		sta $0b				sta 	IF_FarPtr+3
.a2b8	a9 01		lda #$01			lda 	#$01
.a2ba	85 0a		sta $0a				sta 	IF_FarPtr+2
.a2bc	a9 f8		lda #$f8			lda 	#$F8
.a2be	85 09		sta $09				sta 	IF_FarPtr+1
.a2c0	a9 00		lda #$00			lda 	#$00
.a2c2	85 08		sta $08				sta 	IF_FarPtr+0
.a2c4	a3 00		ldz #$00			ldz 	#0
.a2c6					_EXTClearColorRam:
.a2c6	a9 05		lda #$05			lda 	#5							; fill that with this colour.
.a2c8	ea		nop				nop
.a2c9	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2cb	3b		dez				dez
.a2cc	d0 f8		bne $a2c6			bne 	_EXTClearColorRam
.a2ce	e6 09		inc $09				inc 	IF_FarPtr+1
.a2d0	d0 f4		bne $a2c6			bne 	_EXTClearColorRam
.a2d2	a2 00		ldx #$00			ldx 	#0 							; copy PET Font into memory.
.a2d4					_EXTCopyCBMFont:
.a2d4	bd 15 a3	lda $a315,x			lda 	IF_CBMFont,x 				; +$800 uses the lower case c/set
.a2d7	9d 00 08	sta $0800,x			sta 	IF_CharSet,x
.a2da	49 ff		eor #$ff			eor 	#$FF
.a2dc	9d 00 0c	sta $0c00,x			sta 	IF_CharSet+$400,x
.a2df	bd 15 a4	lda $a415,x			lda 	IF_CBMFont+$100,x
.a2e2	9d 00 09	sta $0900,x			sta 	IF_CharSet+$100,x
.a2e5	49 ff		eor #$ff			eor 	#$FF
.a2e7	9d 00 0d	sta $0d00,x			sta 	IF_CharSet+$500,x
.a2ea	bd 15 a5	lda $a515,x			lda 	IF_CBMFont+$200,x
.a2ed	9d 00 0a	sta $0a00,x			sta 	IF_CharSet+$200,x
.a2f0	49 ff		eor #$ff			eor 	#$FF
.a2f2	9d 00 0e	sta $0e00,x			sta 	IF_CharSet+$600,x
.a2f5	bd 15 a6	lda $a615,x			lda 	IF_CBMFont+$300,x
.a2f8	9d 00 0b	sta $0b00,x			sta 	IF_CharSet+$300,x
.a2fb	49 ff		eor #$ff			eor 	#$FF
.a2fd	9d 00 0f	sta $0f00,x			sta 	IF_CharSet+$700,x
.a300	ca		dex				dex
.a301	d0 d1		bne $a2d4			bne 	_EXTCopyCBMFont
.a303	a9 3b		lda #$3b			lda 	#$3F-4  					; puts ROM back in the map (the -4)
.a305	85 01		sta $01				sta 	$01
.a307	a9 00		lda #$00			lda 	#$00						; do not map bytes 0000-7FFF
.a309	a2 00		ldx #$00			ldx 	#$00						; (so we use the RAM physically at $0000-$7FFF)
.a30b	a0 00		ldy #$00			ldy 	#$00 						; 8000-FFFF offset by $200. The lower 8 bits are $00
.a30d	a3 f2		ldz #$f2			ldz 	#$F2 						; so this is an actual offset of $20000. So the space at
.a30f	5c		map				map
.a310	ea		nop				eom
.a311	7a		ply				ply 								; restore and exit.
.a312	fa		plx				plx
.a313	68		pla				pla
.a314	60		rts				rts
.a315					IF_CBMFont:
>a315	1c 22 4a 56 4c 20 1e 00				.binary "pet-font.bin"
>a31d	18 24 42 7e 42 42 42 00 7c 22 22 3c 22 22 7c 00
>a32d	1c 22 40 40 40 22 1c 00 78 24 22 22 22 24 78 00
>a33d	7e 40 40 78 40 40 7e 00 7e 40 40 78 40 40 40 00
>a34d	1c 22 40 4e 42 22 1c 00 42 42 42 7e 42 42 42 00
>a35d	1c 08 08 08 08 08 1c 00 0e 04 04 04 04 44 38 00
>a36d	42 44 48 70 48 44 42 00 40 40 40 40 40 40 7e 00
>a37d	42 66 5a 5a 42 42 42 00 42 62 52 4a 46 42 42 00
>a38d	18 24 42 42 42 24 18 00 7c 42 42 7c 40 40 40 00
>a39d	18 24 42 42 4a 24 1a 00 7c 42 42 7c 48 44 42 00
>a3ad	3c 42 40 3c 02 42 3c 00 3e 08 08 08 08 08 08 00
>a3bd	42 42 42 42 42 42 3c 00 42 42 42 24 24 18 18 00
>a3cd	42 42 42 5a 5a 66 42 00 42 42 24 18 24 42 42 00
>a3dd	22 22 22 1c 08 08 08 00 7e 02 04 18 20 40 7e 00
>a3ed	3c 20 20 20 20 20 3c 00 00 40 20 10 08 04 02 00
>a3fd	3c 04 04 04 04 04 3c 00 00 08 1c 2a 08 08 08 08
>a40d	00 00 10 20 7f 20 10 00 00 00 00 00 00 00 00 00
>a41d	08 08 08 08 00 00 08 00 24 24 24 00 00 00 00 00
>a42d	24 24 7e 24 7e 24 24 00 08 1e 28 1c 0a 3c 08 00
>a43d	00 62 64 08 10 26 46 00 30 48 48 30 4a 44 3a 00
>a44d	04 08 10 00 00 00 00 00 04 08 10 10 10 08 04 00
>a45d	20 10 08 08 08 10 20 00 08 2a 1c 3e 1c 2a 08 00
>a46d	00 08 08 3e 08 08 00 00 00 00 00 00 00 08 08 10
>a47d	00 00 00 7e 00 00 00 00 00 00 00 00 00 18 18 00
>a48d	00 02 04 08 10 20 40 00 3c 42 46 5a 62 42 3c 00
>a49d	08 18 28 08 08 08 3e 00 3c 42 02 0c 30 40 7e 00
>a4ad	3c 42 02 1c 02 42 3c 00 04 0c 14 24 7e 04 04 00
>a4bd	7e 40 78 04 02 44 38 00 1c 20 40 7c 42 42 3c 00
>a4cd	7e 42 04 08 10 10 10 00 3c 42 42 3c 42 42 3c 00
>a4dd	3c 42 42 3e 02 04 38 00 00 00 08 00 00 08 00 00
>a4ed	00 00 08 00 00 08 08 10 0e 18 30 60 30 18 0e 00
>a4fd	00 00 7e 00 7e 00 00 00 70 18 0c 06 0c 18 70 00
>a50d	3c 42 02 0c 10 00 10 00 00 00 00 00 ff 00 00 00
>a51d	08 1c 3e 7f 7f 1c 3e 00 10 10 10 10 10 10 10 10
>a52d	00 00 00 ff 00 00 00 00 00 00 ff 00 00 00 00 00
>a53d	00 ff 00 00 00 00 00 00 00 00 00 00 00 ff 00 00
>a54d	20 20 20 20 20 20 20 20 04 04 04 04 04 04 04 04
>a55d	00 00 00 00 e0 10 08 08 08 08 08 04 03 00 00 00
>a56d	08 08 08 10 e0 00 00 00 80 80 80 80 80 80 80 ff
>a57d	80 40 20 10 08 04 02 01 01 02 04 08 10 20 40 80
>a58d	ff 80 80 80 80 80 80 80 ff 01 01 01 01 01 01 01
>a59d	00 3c 7e 7e 7e 7e 3c 00 00 00 00 00 00 00 ff 00
>a5ad	36 7f 7f 7f 3e 1c 08 00 40 40 40 40 40 40 40 40
>a5bd	00 00 00 00 03 04 08 08 81 42 24 18 18 24 42 81
>a5cd	00 3c 42 42 42 42 3c 00 08 1c 2a 77 2a 08 08 00
>a5dd	02 02 02 02 02 02 02 02 08 1c 3e 7f 3e 1c 08 00
>a5ed	08 08 08 08 ff 08 08 08 a0 50 a0 50 a0 50 a0 50
>a5fd	08 08 08 08 08 08 08 08 00 00 01 3e 54 14 14 00
>a60d	ff 7f 3f 1f 0f 07 03 01 00 00 00 00 00 00 00 00
>a61d	f0 f0 f0 f0 f0 f0 f0 f0 00 00 00 00 ff ff ff ff
>a62d	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff
>a63d	80 80 80 80 80 80 80 80 aa 55 aa 55 aa 55 aa 55
>a64d	01 01 01 01 01 01 01 01 00 00 00 00 aa 55 aa 55
>a65d	ff fe fc f8 f0 e0 c0 80 03 03 03 03 03 03 03 03
>a66d	08 08 08 08 0f 08 08 08 00 00 00 00 0f 0f 0f 0f
>a67d	08 08 08 08 0f 00 00 00 00 00 00 00 f8 08 08 08
>a68d	00 00 00 00 00 00 ff ff 00 00 00 00 0f 08 08 08
>a69d	08 08 08 08 ff 00 00 00 00 00 00 00 ff 08 08 08
>a6ad	08 08 08 08 f8 08 08 08 c0 c0 c0 c0 c0 c0 c0 c0
>a6bd	e0 e0 e0 e0 e0 e0 e0 e0 07 07 07 07 07 07 07 07
>a6cd	ff ff 00 00 00 00 00 00 ff ff ff 00 00 00 00 00
>a6dd	00 00 00 00 00 ff ff ff 01 01 01 01 01 01 01 ff
>a6ed	00 00 00 00 f0 f0 f0 f0 0f 0f 0f 0f 00 00 00 00
>a6fd	08 08 08 08 f8 00 00 00 f0 f0 f0 f0 00 00 00 00
>a70d	f0 f0 f0 f0 0f 0f 0f 0f 1c 22 4a 56 4c 20 1e 00
>a71d	18 24 42 7e 42 42 42 00 7c 22 22 3c 22 22 7c 00
>a72d	1c 22 40 40 40 22 1c 00 78 24 22 22 22 24 78 00
>a73d	7e 40 40 78 40 40 7e 00 7e 40 40 78 40 40 40 00
>a74d	1c 22 40 4e 42 22 1c 00 42 42 42 7e 42 42 42 00
>a75d	1c 08 08 08 08 08 1c 00 0e 04 04 04 04 44 38 00
>a76d	42 44 48 70 48 44 42 00 40 40 40 40 40 40 7e 00
>a77d	42 66 5a 5a 42 42 42 00 42 62 52 4a 46 42 42 00
>a78d	18 24 42 42 42 24 18 00 7c 42 42 7c 40 40 40 00
>a79d	18 24 42 42 4a 24 1a 00 7c 42 42 7c 48 44 42 00
>a7ad	3c 42 40 3c 02 42 3c 00 3e 08 08 08 08 08 08 00
>a7bd	42 42 42 42 42 42 3c 00 42 42 42 24 24 18 18 00
>a7cd	42 42 42 5a 5a 66 42 00 42 42 24 18 24 42 42 00
>a7dd	22 22 22 1c 08 08 08 00 7e 02 04 18 20 40 7e 00
>a7ed	3c 20 20 20 20 20 3c 00 00 40 20 10 08 04 02 00
>a7fd	3c 04 04 04 04 04 3c 00 00 08 1c 2a 08 08 08 08
>a80d	00 00 10 20 7f 20 10 00 00 00 00 00 00 00 00 00
>a81d	08 08 08 08 00 00 08 00 24 24 24 00 00 00 00 00
>a82d	24 24 7e 24 7e 24 24 00 08 1e 28 1c 0a 3c 08 00
>a83d	00 62 64 08 10 26 46 00 30 48 48 30 4a 44 3a 00
>a84d	04 08 10 00 00 00 00 00 04 08 10 10 10 08 04 00
>a85d	20 10 08 08 08 10 20 00 08 2a 1c 3e 1c 2a 08 00
>a86d	00 08 08 3e 08 08 00 00 00 00 00 00 00 08 08 10
>a87d	00 00 00 7e 00 00 00 00 00 00 00 00 00 18 18 00
>a88d	00 02 04 08 10 20 40 00 3c 42 46 5a 62 42 3c 00
>a89d	08 18 28 08 08 08 3e 00 3c 42 02 0c 30 40 7e 00
>a8ad	3c 42 02 1c 02 42 3c 00 04 0c 14 24 7e 04 04 00
>a8bd	7e 40 78 04 02 44 38 00 1c 20 40 7c 42 42 3c 00
>a8cd	7e 42 04 08 10 10 10 00 3c 42 42 3c 42 42 3c 00
>a8dd	3c 42 42 3e 02 04 38 00 00 00 08 00 00 08 00 00
>a8ed	00 00 08 00 00 08 08 10 0e 18 30 60 30 18 0e 00
>a8fd	00 00 7e 00 7e 00 00 00 70 18 0c 06 0c 18 70 00
>a90d	3c 42 02 0c 10 00 10 00 00 00 00 00 ff 00 00 00
>a91d	00 00 38 04 3c 44 3a 00 40 40 5c 62 42 62 5c 00
>a92d	00 00 3c 42 40 42 3c 00 02 02 3a 46 42 46 3a 00
>a93d	00 00 3c 42 7e 40 3c 00 0c 12 10 7c 10 10 10 00
>a94d	00 00 3a 46 46 3a 02 3c 40 40 5c 62 42 42 42 00
>a95d	08 00 18 08 08 08 1c 00 04 00 0c 04 04 04 44 38
>a96d	40 40 44 48 50 68 44 00 18 08 08 08 08 08 1c 00
>a97d	00 00 76 49 49 49 49 00 00 00 5c 62 42 42 42 00
>a98d	00 00 3c 42 42 42 3c 00 00 00 5c 62 62 5c 40 40
>a99d	00 00 3a 46 46 3a 02 02 00 00 5c 62 40 40 40 00
>a9ad	00 00 3e 40 3c 02 7c 00 10 10 7c 10 10 12 0c 00
>a9bd	00 00 42 42 42 46 3a 00 00 00 42 42 42 24 18 00
>a9cd	00 00 41 49 49 49 36 00 00 00 42 24 18 24 42 00
>a9dd	00 00 42 42 46 3a 02 3c 00 00 7e 04 18 20 7e 00
>a9ed	08 08 08 08 ff 08 08 08 a0 50 a0 50 a0 50 a0 50
>a9fd	08 08 08 08 08 08 08 08 cc cc 33 33 cc cc 33 33
>aa0d	cc 66 33 99 cc 66 33 99 00 00 00 00 00 00 00 00
>aa1d	f0 f0 f0 f0 f0 f0 f0 f0 00 00 00 00 ff ff ff ff
>aa2d	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff
>aa3d	80 80 80 80 80 80 80 80 aa 55 aa 55 aa 55 aa 55
>aa4d	01 01 01 01 01 01 01 01 00 00 00 00 aa 55 aa 55
>aa5d	99 33 66 cc 99 33 66 cc 03 03 03 03 03 03 03 03
>aa6d	08 08 08 08 0f 08 08 08 00 00 00 00 0f 0f 0f 0f
>aa7d	08 08 08 08 0f 00 00 00 00 00 00 00 f8 08 08 08
>aa8d	00 00 00 00 00 00 ff ff 00 00 00 00 0f 08 08 08
>aa9d	08 08 08 08 ff 00 00 00 00 00 00 00 ff 08 08 08
>aaad	08 08 08 08 f8 08 08 08 c0 c0 c0 c0 c0 c0 c0 c0
>aabd	e0 e0 e0 e0 e0 e0 e0 e0 07 07 07 07 07 07 07 07
>aacd	ff ff 00 00 00 00 00 00 ff ff ff 00 00 00 00 00
>aadd	00 00 00 00 00 ff ff ff 01 02 44 48 50 60 40 00
>aaed	00 00 00 00 f0 f0 f0 f0 0f 0f 0f 0f 00 00 00 00
>aafd	08 08 08 08 f8 00 00 00 f0 f0 f0 f0 00 00 00 00
>ab0d	f0 f0 f0 f0 0f 0f 0f 0f

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.ab15					TIM_Error:
.ab15	20 35 a0	jsr $a035			jsr 	IFT_UpLine 					; go up one line.
.ab18	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.ab1a	80 02		bra $ab1e			bra 	TIM_ShowPrompt
.ab1c					TIM_NewCommand:
.ab1c	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.ab1e					TIM_ShowPrompt:
.ab1e	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.ab21	20 06 a1	jsr $a106			jsr 	IFT_ReadLine	 			; get character, go to next line
.ab24	20 68 a0	jsr $a068			jsr 	IFT_NewLine					; go to next line.
.ab27	86 10		stx $10				stx 	zTemp1 						; save line read address
.ab29	84 11		sty $11				sty 	zTemp1+1
.ab2b	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.ab2d	b1 10		lda ($10),y			lda 	(zTemp1),y
.ab2f	c9 3f		cmp #$3f			cmp 	#"?"
.ab31	f0 04		beq $ab37			beq 	TIM_SkipFirst
.ab33	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.ab35	d0 01		bne $ab38			bne 	TIM_NotDot
.ab37					TIM_SkipFirst:
.ab37	c8		iny				iny
.ab38					TIM_NotDot:
.ab38	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.ab3a	c9 52		cmp #$52			cmp 	#"R"						; show registers
.ab3c	f0 6e		beq $abac			beq 	TIM_ShowRegisters
.ab3e	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.ab40	f0 12		beq $ab54			beq 	TIM_ShowMemory
.ab42	c9 47		cmp #$47			cmp 	#"G"						; execute
.ab44	f0 49		beq $ab8f			beq 	TIM_Execute
.ab46	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.ab48	f0 07		beq $ab51			beq 	TIM_GoLoadMemory
.ab4a	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.ab4c	d0 c7		bne $ab15			bne 	TIM_Error
.ab4e	4c d1 ac	jmp $acd1			jmp 	TIM_UpdateRegisters
.ab51					TIM_GoLoadMemory:
.ab51	4c fc ac	jmp $acfc			jmp 	TIM_LoadMemory
.ab54					TIM_ShowMemory:
.ab54	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.ab57	b0 bc		bcs $ab15			bcs 	TIM_Error
.ab59	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.ab5b	85 12		sta $12				sta 	zTemp2
.ab5d	a5 15		lda $15				lda 	zTemp3+1
.ab5f	85 13		sta $13				sta 	zTemp2+1
.ab61	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.ab64	90 08		bcc $ab6e			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.ab66	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.ab68	85 14		sta $14				sta 	zTemp3
.ab6a	a5 13		lda $13				lda 	zTemp2+1
.ab6c	85 15		sta $15				sta 	zTemp3+1
.ab6e					_TIMSM_Start:
.ab6e	20 22 ac	jsr $ac22			jsr 	TIM_WriteLine 				; write one line of hex out
.ab71	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.ab73	18		clc				clc
.ab74	69 10		adc #$10			adc 	#16
.ab76	85 12		sta $12				sta 	zTemp2
.ab78	90 02		bcc $ab7c			bcc 	_TIMSM_NoCarry
.ab7a	e6 13		inc $13				inc 	zTemp2+1
.ab7c					_TIMSM_NoCarry:
.ab7c	20 f1 a1	jsr $a1f1			jsr 	IF_CheckBreak 				; check CTL+C
.ab7f	d0 0b		bne $ab8c			bne 	_TIMSM_Ends 				; if pressed break out.
.ab81	38		sec				sec 								; check past the end address in zTemp3
.ab82	a5 14		lda $14				lda 	zTemp3
.ab84	e5 12		sbc $12				sbc 	zTemp2
.ab86	a5 15		lda $15				lda 	zTemp3+1
.ab88	e5 13		sbc $13				sbc 	zTemp2+1
.ab8a	10 e2		bpl $ab6e			bpl 	_TIMSM_Start
.ab8c					_TIMSM_Ends:
.ab8c	4c 1c ab	jmp $ab1c			jmp 	TIM_NewCommand
.ab8f					TIM_Execute:
.ab8f	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; get the execute address
.ab92	b0 81		bcs $ab15			bcs 	TIM_Error 					; not legitimate
.ab94	ae c1 03	ldx $03c1			ldx 	TIM_SP 						; set up SP
.ab97	9a		txs				txs
.ab98	ad bc 03	lda $03bc			lda 	TIM_SR 						; Status for PLP
.ab9b	48		pha				pha
.ab9c	ad bd 03	lda $03bd			lda 	TIM_A 						; restore AXYZ
.ab9f	ae be 03	ldx $03be			ldx 	TIM_X
.aba2	ac bf 03	ldy $03bf			ldy 	TIM_Y
.aba5	ab c0 03	ldz $03c0			ldz 	TIM_Z
.aba8	28		plp				plp 								; and PS Byte.
.aba9	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.abac					TIM_Start:
.abac					TIM_ShowRegisters:
.abac	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.abaf	8d bb 03	sta $03bb			sta 	TIM_IRQ+1
.abb2	ad ff ff	lda $ffff			lda 	$FFFF
.abb5	8d ba 03	sta $03ba			sta 	TIM_IRQ
.abb8	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.abba					_TIMSR_Text:
.abba	bd e6 ab	lda $abe6,x			lda 	_TIMSR_Label,x
.abbd	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.abc0	e8		inx				inx
.abc1	e0 23		cpx #$23			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.abc3	d0 f5		bne $abba			bne 	_TIMSR_Text
.abc5	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.abc7					_TIMSR_Skip:
.abc7	e8		inx				inx
.abc8					_TIMSR_LoopSpace:
.abc8	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.abca	b0 04		bcs $abd0			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.abcc	8a		txa				txa
.abcd	4a		lsr a				lsr 	a
.abce	b0 05		bcs $abd5			bcs 	_TIMSR_NoSpace
.abd0					_TIMSR_Space:
.abd0	a9 20		lda #$20			lda 	#" "
.abd2	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.abd5					_TIMSR_NoSpace:
.abd5	bd b8 03	lda $03b8,x			lda 	TIM_PC,x 					; output hex value.
.abd8	20 09 ac	jsr $ac09			jsr 	TIM_WriteHex
.abdb	e8		inx				inx
.abdc	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.abde	d0 e8		bne $abc8			bne 	_TimSR_LoopSpace
.abe0	20 68 a0	jsr $a068			jsr 	IFT_NewLine 				; new line
.abe3	4c 1c ab	jmp $ab1c			jmp	 	TIM_NewCommand 				; new command.
.abe6					_TIMSR_Label:
>abe6	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>abee	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>abfe	52
>abff	20 5a 52					.text 	" ZR"
>ac02	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.ac09					_TIMSR_LabelEnd:
.ac09					TIM_WriteHex:
.ac09	48		pha				pha 								; save A
.ac0a	4a		lsr a				lsr 	a 							; shift MSB->LSB
.ac0b	4a		lsr a				lsr 	a
.ac0c	4a		lsr a				lsr 	a
.ac0d	4a		lsr a				lsr 	a
.ac0e	20 12 ac	jsr $ac12			jsr 	_TIMWH_Nibble 				; print MSB
.ac11	68		pla				pla 								; restore and print LSB
.ac12					_TIMWH_Nibble:
.ac12	48		pha				pha
.ac13	29 0f		and #$0f			and 	#15 						; mask out
.ac15	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.ac17	90 02		bcc $ac1b			bcc 	_TIMWHNoLetter
.ac19	69 06		adc #$06			adc 	#6
.ac1b					_TIMWHNoLetter:
.ac1b	69 30		adc #$30			adc 	#48
.ac1d	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter 			; print it out.
.ac20	68		pla				pla
.ac21	60		rts				rts
.ac22					TIM_WriteLine:
.ac22	a9 2e		lda #$2e			lda 	#"." 						; prompt
.ac24	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.ac27	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.ac29	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.ac2c	a5 13		lda $13				lda 	zTemp2+1 					; write address
.ac2e	20 09 ac	jsr $ac09			jsr 	TIM_WriteHex
.ac31	a5 12		lda $12				lda 	zTemp2
.ac33	20 09 ac	jsr $ac09			jsr 	TIM_WriteHex
.ac36	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.ac38					_TIMWL_Loop:
.ac38	a9 20		lda #$20			lda 	#" "
.ac3a	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.ac3d	b1 12		lda ($12),y			lda 	(zTemp2),y
.ac3f	20 09 ac	jsr $ac09			jsr 	TIM_WriteHex
.ac42	c8		iny				iny
.ac43	c0 10		cpy #$10			cpy 	#16
.ac45	d0 f1		bne $ac38			bne 	_TIMWL_Loop
.ac47	4c 68 a0	jmp $a068			jmp 	IFT_NewLine 				; new line and exit
.ac4a					TIM_GetHex:
.ac4a	c8		iny				iny
.ac4b	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.ac4d	c9 20		cmp #$20			cmp 	#32
.ac4f	f0 f9		beq $ac4a			beq 	TIM_GetHex
.ac51	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.ac53	f0 f5		beq $ac4a			beq 	TIM_GetHex
.ac55	20 7e ac	jsr $ac7e			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.ac58	b0 23		bcs $ac7d			bcs 	_TIMGH_Exit					; if first bad then exit now.
.ac5a	a9 00		lda #$00			lda 	#0 							; zero result
.ac5c	85 14		sta $14				sta 	zTemp3
.ac5e	85 15		sta $15				sta 	zTemp3+1
.ac60					_TIM_GHLoop:
.ac60	20 7e ac	jsr $ac7e			jsr 	TIM_GetHexCharacter 		; get next character
.ac63	b0 17		bcs $ac7c			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.ac65	c8		iny				iny 								; skip over it.
.ac66	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.ac68	26 15		rol $15				rol 	zTemp3+1
.ac6a	06 14		asl $14				asl 	zTemp3 						; now x 2
.ac6c	26 15		rol $15				rol 	zTemp3+1
.ac6e	06 14		asl $14				asl 	zTemp3						; now x 4
.ac70	26 15		rol $15				rol 	zTemp3+1
.ac72	06 14		asl $14				asl 	zTemp3 						; now x 8
.ac74	26 15		rol $15				rol 	zTemp3+1
.ac76	05 14		ora $14				ora 	zTemp3 						; OR result in
.ac78	85 14		sta $14				sta 	zTemp3
.ac7a	80 e4		bra $ac60			bra 	_TIM_GHLoop 				; loop round again.
.ac7c					_TIMGH_Okay:
.ac7c	18		clc				clc
.ac7d					_TIMGH_Exit:
.ac7d	60		rts				rts
.ac7e					TIM_GetHexCharacter:
.ac7e	b1 10		lda ($10),y			lda 	(zTemp1),y
.ac80	38		sec				sec
.ac81	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.ac83	90 0e		bcc $ac93			bcc 	_TIM_GHCFail
.ac85	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.ac87	90 0b		bcc $ac94			bcc 	_TIM_GHCExit
.ac89	c9 11		cmp #$11			cmp 	#65-48						; < A
.ac8b	90 06		bcc $ac93			bcc		_TIM_GHCFail
.ac8d	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.ac8f	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.ac91	90 01		bcc $ac94			bcc		_TIM_GHCExit
.ac93					_TIM_GHCFail:
.ac93	38		sec				sec
.ac94					_TIM_GHCExit:
.ac94	60		rts				rts
.ac95					TIM_BreakVector:
.ac95	da		phx				phx									; save X/A on stack
.ac96	48		pha				pha
.ac97	ba		tsx				tsx 								; X points to S
.ac98	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.ac9b	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.ac9d	d0 03		bne $aca2			bne 	_TIMBreak					; if set, it's BRK
.ac9f	68		pla				pla 								; abandon routine.
.aca0	fa		plx				plx
.aca1	40		rti				rti
.aca2					_TIMBreak:
.aca2	68		pla				pla 								; save A X Y and maybe Z
.aca3	8d bd 03	sta $03bd			sta 	TIM_A
.aca6	fa		plx				plx
.aca7	8e be 03	stx $03be			stx 	TIM_X
.acaa	8c bf 03	sty $03bf			sty 	TIM_Y
.acad	9c c0 03	stz $03c0			stz 	TIM_Z
.acb0	68		pla				pla 								; get Status Register
.acb1	8d bc 03	sta $03bc			sta 	TIM_SR
.acb4	68		pla				pla
.acb5	8d b9 03	sta $03b9			sta 	TIM_PC+1 					; save calling address
.acb8	68		pla				pla
.acb9	8d b8 03	sta $03b8			sta 	TIM_PC 						; high byte
.acbc	ad b9 03	lda $03b9			lda 	TIM_PC+1 					; dec PC to point right.
.acbf	d0 03		bne $acc4			bne 	_TIMDecrement 				; brk bumps it.
.acc1	ce b8 03	dec $03b8			dec 	TIM_PC
.acc4					_TIMDecrement:
.acc4	ce b9 03	dec $03b9			dec 	TIM_PC+1
.acc7	ba		tsx				tsx 								; and copy SP
.acc8	8e c1 03	stx $03c1			stx 	TIM_SP
.accb	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.accd	9a		txs				txs
.acce	4c ac ab	jmp $abac			jmp 	TIM_Start 					; and start up TIM monitor.
.acd1					TIM_UpdateRegisters:
.acd1	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; PC
.acd4	b0 23		bcs $acf9			bcs 	_TIMURFail
.acd6	a5 14		lda $14				lda 	zTemp3
.acd8	8d b9 03	sta $03b9			sta 	Tim_PC+1
.acdb	a5 15		lda $15				lda 	zTemp3+1
.acdd	8d b8 03	sta $03b8			sta 	Tim_PC
.ace0	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; ignore IRQ
.ace3	b0 14		bcs $acf9			bcs 	_TIMURFail
.ace5	a2 00		ldx #$00			ldx 	#0
.ace7					_TIM_URLoop:
.ace7	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; registers
.acea	b0 0d		bcs $acf9			bcs 	_TIMURFail
.acec	a5 14		lda $14				lda 	zTemp3
.acee	9d bc 03	sta $03bc,x			sta 	Tim_SR,x
.acf1	e8		inx				inx
.acf2	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.acf4	d0 f1		bne $ace7			bne 	_TIM_URLoop
.acf6	4c 1c ab	jmp $ab1c			jmp 	TIM_NewCommand
.acf9					_TIMURFail:
.acf9	4c 15 ab	jmp $ab15			jmp 	TIM_Error
.acfc					TIM_LoadMemory:
.acfc	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; target address => zTemp2
.acff	a5 14		lda $14				lda 	zTemp3
.ad01	85 12		sta $12				sta 	zTemp2
.ad03	a5 15		lda $15				lda 	zTemp3+1
.ad05	85 13		sta $13				sta 	zTemp2+1
.ad07					_TIM_LMLoop:
.ad07	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; next byte ?
.ad0a	b0 0e		bcs $ad1a			bcs 	_TIMLMDone 					; no more
.ad0c	a2 00		ldx #$00			ldx 	#0							; write out.
.ad0e	a5 14		lda $14				lda 	zTemp3
.ad10	81 12		sta ($12,x)			sta 	(zTemp2,x)
.ad12	e6 12		inc $12				inc 	zTemp2 						; bump address
.ad14	d0 f1		bne $ad07			bne 	_TIM_LMLoop
.ad16	e6 13		inc $13				inc 	zTemp2+1
.ad18	80 ed		bra $ad07			bra 	_TIM_LMLoop
.ad1a					_TIMLMDone:
.ad1a	4c 1c ab	jmp $ab1c			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stack.asm

.ad1d					StackReset:
.ad1d	48		pha				pha
.ad1e	5a		phy				phy
.ad1f	a9 00		lda #$00			lda 	#(BasicStack & $FF) 		; reset pointer
.ad21	85 26		sta $26				sta 	zBasicSP
.ad23	a9 04		lda #$04			lda 	#(BasicStack >> 8)
.ad25	85 27		sta $27				sta 	zBasicSP+1
.ad27	a0 00		ldy #$00			ldy 	#0 							; reset stack top to $00 which cannot
.ad29	98		tya				tya 								; be a legal token.
.ad2a	91 26		sta ($26),y			sta 	(zBasicSP),y
.ad2c	7a		ply				ply
.ad2d	68		pla				pla
.ad2e	60		rts				rts
.ad2f					StackPushFrame:
.ad2f	48		pha				pha
.ad30	5a		phy				phy
.ad31	1a		inc a				inc 	a 							; one extra byte in frame, for the marker.
.ad32	48		pha				pha 								; save it.
.ad33	29 0f		and #$0f			and 	#$0F 						; lower 4 bits
.ad35	18		clc				clc 								; add to Basic Stack
.ad36	65 26		adc $26				adc 	zBasicSP
.ad38	85 26		sta $26				sta 	zBasicSP
.ad3a	90 02		bcc $ad3e			bcc 	_SPFNoBump
.ad3c	e6 27		inc $27				inc 	zBasicSP+1
.ad3e					_SPFNoBump:
.ad3e	a0 00		ldy #$00			ldy 	#0
.ad40	68		pla				pla
.ad41	91 26		sta ($26),y			sta 	(zBasicSP),y
.ad43	7a		ply				ply
.ad44	68		pla				pla
.ad45	60		rts				rts
.ad46					StackPopFrame:
.ad46	48		pha				pha
.ad47	5a		phy				phy
.ad48	a0 00		ldy #$00			ldy 	#0 							; compare with top of stack using EOR
.ad4a	51 26		eor ($26),y			eor 	(zBasicSP),y
.ad4c	29 f0		and #$f0			and 	#$F0 						; top 4 bits zero, match
.ad4e	d0 12		bne $ad62			bne 	_SPFError 					; mixed structures
.ad50	b1 26		lda ($26),y			lda 	(zBasicSP),y 				; get size from byte
.ad52	29 0f		and #$0f			and 	#$0F
.ad54	49 ff		eor #$ff			eor 	#$FF						; 2's complement
.ad56	38		sec				sec
.ad57	65 26		adc $26				adc 	zBasicSP
.ad59	85 26		sta $26				sta 	zBasicSP
.ad5b	b0 02		bcs $ad5f			bcs 	_SPFNoBump
.ad5d	c6 27		dec $27				dec 	zBasicSP+1
.ad5f					_SPFNoBump:
.ad5f	7a		ply				ply
.ad60	68		pla				pla
.ad61	60		rts				rts
.ad62					_SPFError:
.ad62	20 e4 ad	jsr $ade4			jsr ERR_Handler
>ad65	4d 69 78 65 64 20 53 74			.text "Mixed Structures",0
>ad6d	72 75 63 74 75 72 65 73 00
.ad76					StackSavePosition:
.ad76	6b		tza				tza
.ad77	5a		phy				phy
.ad78	a0 05		ldy #$05			ldy 	#5
.ad7a	91 26		sta ($26),y			sta 	(zBasicSP),y
.ad7c	a0 01		ldy #$01			ldy 	#1
.ad7e	a5 16		lda $16				lda 	zCodePtr+0 					; 4 bytes, could reduce this for 65816/6502
.ad80	91 26		sta ($26),y			sta 	(zBasicSP),y
.ad82	c8		iny				iny
.ad83	a5 17		lda $17				lda 	zCodePtr+1
.ad85	91 26		sta ($26),y			sta 	(zBasicSP),y
.ad87	c8		iny				iny
.ad88	a5 18		lda $18				lda 	zCodePtr+2
.ad8a	91 26		sta ($26),y			sta 	(zBasicSP),y
.ad8c	c8		iny				iny
.ad8d	a5 19		lda $19				lda 	zCodePtr+3
.ad8f	91 26		sta ($26),y			sta 	(zBasicSP),y
.ad91	7a		ply				ply
.ad92	60		rts				rts
.ad93					StackRestorePosition:
.ad93	5a		phy				phy
.ad94	a0 01		ldy #$01			ldy 	#1 							; copy 4 bytes that are the pointer
.ad96	b1 26		lda ($26),y			lda 	(zBasicSP),y
.ad98	85 16		sta $16				sta 	zCodePtr+0
.ad9a	c8		iny				iny
.ad9b	b1 26		lda ($26),y			lda 	(zBasicSP),y
.ad9d	85 17		sta $17				sta 	zCodePtr+1
.ad9f	c8		iny				iny
.ada0	b1 26		lda ($26),y			lda 	(zBasicSP),y
.ada2	85 18		sta $18				sta 	zCodePtr+2
.ada4	c8		iny				iny
.ada5	b1 26		lda ($26),y			lda 	(zBasicSP),y
.ada7	85 19		sta $19				sta 	zCodePtr+3
.ada9	c8		iny				iny
.adaa	b1 26		lda ($26),y			lda 	(zBasicSP),y 				; offset
.adac	7a		ply				ply 								; restore Y
.adad	4b		taz				taz
.adae	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/vectors.asm

.adaf					CharPrint:
.adaf	4c 41 a0	jmp $a041			jmp 	IFT_PrintCharacter
.adb2					CharGet:
.adb2	4c 06 a2	jmp $a206			jmp 	IF_GetKey

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/errors.asm

.adb5					SyntaxError:
.adb5	20 e4 ad	jsr $ade4			jsr 	ERR_Handler
>adb8	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>adc0	72 72 6f 72 00
.adc5					TypeError:
.adc5	20 e4 ad	jsr $ade4			jsr 	ERR_Handler
>adc8	57 72 6f 6e 67 20 74 79				.text 	"Wrong type",0
>add0	70 65 00
.add3					BadParamError:
.add3	20 e4 ad	jsr $ade4			jsr 	ERR_Handler
>add6	42 61 64 20 50 61 72 61				.text 	"Bad Parameter",0
>adde	6d 65 74 65 72 00
.ade4					ERR_Handler:
.ade4	a3 00		ldz #$00			ldz 	#0
.ade6	1b		inz				inz
.ade7	ea		nop				nop
.ade8	b2 16		lda ($16),z			lda 	(zCodePtr),z
.adea	85 80		sta $80				sta 	XS_Mantissa
.adec	1b		inz				inz
.aded	ea		nop				nop
.adee	b2 16		lda ($16),z			lda 	(zCodePtr),z
.adf0	85 81		sta $81				sta 	XS_Mantissa+1
.adf2	fa		plx				plx 								; address in XY
.adf3	7a		ply				ply
.adf4	e8		inx				inx 								; bump, because of RTS/JSR address -1
.adf5	d0 01		bne $adf8			bne 	_EHNoSkip
.adf7	c8		iny				iny
.adf8					_EHNoSkip:
.adf8	20 17 ae	jsr $ae17			jsr 	PrintROMMessage 			; print message from ROM.
.adfb	a5 80		lda $80				lda 	XS_Mantissa					; line number = 0
.adfd	05 81		ora $81				ora 	XS_Mantissa+1
.adff	f0 0c		beq $ae0d			beq 	_EHNoLine
.ae01	a2 12		ldx #$12			ldx 	#_EHAt & $FF 				; print " at "
.ae03	a0 ae		ldy #$ae			ldy 	#(_EHAt >> 8) & $FF
.ae05	20 17 ae	jsr $ae17			jsr 	PrintROMMessage
.ae08	a2 00		ldx #$00			ldx 	#0 							; Print line number
.ae0a	20 28 ae	jsr $ae28			jsr 	Print16BitInteger
.ae0d					_EHNoLine:
.ae0d	80 fe		bra $ae0d			bra 	_EHNoLine
.ae0f	4c 87 b0	jmp $b087			jmp 	WarmStart
>ae12	20 61 74 20 00			_EHAt:	.text 	" at ",0
.ae17					PrintROMMessage:
.ae17	86 1a		stx $1a				stx 	zLTemp1 					; save addres
.ae19	84 1b		sty $1b				sty 	zLTemp1+1
.ae1b	a0 00		ldy #$00			ldy 	#0
.ae1d					_PRMLoop:
.ae1d	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.ae1f	f0 06		beq $ae27			beq		_PRMExit
.ae21	c8		iny				iny
.ae22	20 af ad	jsr $adaf			jsr 	CharPrint
.ae25	80 f6		bra $ae1d			bra 	_PRMLoop
.ae27					_PRMExit:
.ae27	60		rts				rts
.ae28					Print16BitInteger:
.ae28	a9 00		lda #$00			lda 	#0 							; make 32 bit
.ae2a	85 82		sta $82				sta 	XS_Mantissa+2
.ae2c	85 83		sta $83				sta 	XS_Mantissa+3
.ae2e					Print32BitInteger:
.ae2e	a9 00		lda #$00			lda 	#0
.ae30	8d 14 03	sta $0314			sta 	NumBufX 					; reset the conversion pointer
.ae33	aa		tax				tax 								; convert bottom level.
.ae34	20 cd c1	jsr $c1cd			jsr 	INTToString 				; make string
.ae37	a2 00		ldx #$00			ldx 	#0 							; print buffer
.ae39	bd 15 03	lda $0315,x	_P1Loop:lda 	Num_Buffer,x
.ae3c	f0 06		beq $ae44			beq 	_P1Exit
.ae3e	20 af ad	jsr $adaf			jsr 	CharPrint
.ae41	e8		inx				inx
.ae42	80 f5		bra $ae39			bra 	_P1Loop
.ae44	8a		txa		_P1Exit:txa 								; return chars printed.
.ae45	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm


;******  Processing file: modules/basic/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b6					lastUnaryFunction = $b6
.ae46					VectorTable:
>ae46	44 b6					.word BinaryOp_And         & $FFFF ; $80 and
>ae48	60 b6					.word BinaryOp_Or          & $FFFF ; $81 or
>ae4a	7c b6					.word BinaryOp_Xor         & $FFFF ; $82 xor
>ae4c	7c b6					.word BinaryOp_Eor         & $FFFF ; $83 eor
>ae4e	b3 b6					.word Binary_Equal         & $FFFF ; $84 =
>ae50	cd b6					.word Binary_NotEqual      & $FFFF ; $85 <>
>ae52	d6 b6					.word Binary_Less          & $FFFF ; $86 <
>ae54	df b6					.word Binary_LessEqual     & $FFFF ; $87 <=
>ae56	f1 b6					.word Binary_Greater       & $FFFF ; $88 >
>ae58	e8 b6					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>ae5a	76 b7					.word BinaryOp_Add         & $FFFF ; $8a +
>ae5c	92 b7					.word BinaryOp_Subtract    & $FFFF ; $8b -
>ae5e	a3 b7					.word BinaryOp_Multiply    & $FFFF ; $8c *
>ae60	b4 b7					.word BinaryOp_Divide      & $FFFF ; $8d /
>ae62	02 af					.word NotImplemented       & $FFFF ; $8e ^
>ae64	02 af					.word NotImplemented       & $FFFF ; $8f if
>ae66	02 af					.word NotImplemented       & $FFFF ; $90 while
>ae68	61 b4					.word Command_REPEAT       & $FFFF ; $91 repeat
>ae6a	02 af					.word NotImplemented       & $FFFF ; $92 for
>ae6c	02 af					.word NotImplemented       & $FFFF ; $93 then
>ae6e	02 af					.word NotImplemented       & $FFFF ; $94 endif
>ae70	02 af					.word NotImplemented       & $FFFF ; $95 wend
>ae72	6a b4					.word Command_UNTIL        & $FFFF ; $96 until
>ae74	02 af					.word NotImplemented       & $FFFF ; $97 next
>ae76	02 af					.word NotImplemented       & $FFFF ; $98 not
>ae78	02 af					.word NotImplemented       & $FFFF ; $99 fn(
>ae7a	b9 b8					.word Unary_Abs            & $FFFF ; $9a abs(
>ae7c	f9 b9					.word Unary_Asc            & $FFFF ; $9b asc(
>ae7e	b8 c8					.word Unary_Int            & $FFFF ; $9c int(
>ae80	d3 b8					.word Unary_Peek           & $FFFF ; $9d peek(
>ae82	39 c8					.word Unary_Rnd            & $FFFF ; $9e rnd(
>ae84	3a b9					.word Unary_Usr            & $FFFF ; $9f usr(
>ae86	38 ba					.word Unary_Left           & $FFFF ; $a0 left$(
>ae88	4d ba					.word Unary_Right          & $FFFF ; $a1 right$(
>ae8a	1f ba					.word Unary_Mid            & $FFFF ; $a2 mid$(
>ae8c	96 bb					.word Unary_Spc            & $FFFF ; $a3 spc(
>ae8e	c7 b9					.word Unary_Str            & $FFFF ; $a4 str$(
>ae90	5b b9					.word Unary_Val            & $FFFF ; $a5 val(
>ae92	10 ba					.word Unary_Len            & $FFFF ; $a6 len(
>ae94	c5 ba					.word Unary_Hex            & $FFFF ; $a7 hex$(
>ae96	02 af					.word NotImplemented       & $FFFF ; $a8 sin(
>ae98	02 af					.word NotImplemented       & $FFFF ; $a9 cos(
>ae9a	02 af					.word NotImplemented       & $FFFF ; $aa tan(
>ae9c	02 af					.word NotImplemented       & $FFFF ; $ab atn(
>ae9e	02 af					.word NotImplemented       & $FFFF ; $ac exp(
>aea0	02 af					.word NotImplemented       & $FFFF ; $ad log(
>aea2	02 af					.word NotImplemented       & $FFFF ; $ae sqr(
>aea4	1b bb					.word Unary_Dec            & $FFFF ; $af dec(
>aea6	d7 b8					.word Unary_Deek           & $FFFF ; $b0 deek(
>aea8	db b8					.word Unary_Leek           & $FFFF ; $b1 leek(
>aeaa	07 b9					.word Unary_Mod            & $FFFF ; $b2 mod(
>aeac	73 b8					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>aeae	78 bb					.word Unary_Chr            & $FFFF ; $b4 chr$(
>aeb0	02 af					.word NotImplemented       & $FFFF ; $b5 pos(
>aeb2	02 af					.word NotImplemented       & $FFFF ; $b6 tab(
>aeb4	02 af					.word NotImplemented       & $FFFF ; $b7 $
>aeb6	02 af					.word NotImplemented       & $FFFF ; $b8 $(
>aeb8	02 af					.word NotImplemented       & $FFFF ; $b9 #
>aeba	02 af					.word NotImplemented       & $FFFF ; $ba #(
>aebc	02 af					.word NotImplemented       & $FFFF ; $bb %
>aebe	02 af					.word NotImplemented       & $FFFF ; $bc %(
>aec0	02 af					.word NotImplemented       & $FFFF ; $bd (
>aec2	02 af					.word NotImplemented       & $FFFF ; $be )
>aec4	02 af					.word NotImplemented       & $FFFF ; $bf ,
>aec6	96 b1					.word Command_COLON        & $FFFF ; $c0 :
>aec8	02 af					.word NotImplemented       & $FFFF ; $c1 ;
>aeca	02 af					.word NotImplemented       & $FFFF ; $c2 def
>aecc	45 b4					.word Command_CLR          & $FFFF ; $c3 clr
>aece	59 b4					.word Command_STOP         & $FFFF ; $c4 stop
>aed0	02 af					.word NotImplemented       & $FFFF ; $c5 data
>aed2	02 af					.word NotImplemented       & $FFFF ; $c6 read
>aed4	8d b0					.word Command_DIM          & $FFFF ; $c7 dim
>aed6	02 af					.word NotImplemented       & $FFFF ; $c8 to
>aed8	02 af					.word NotImplemented       & $FFFF ; $c9 step
>aeda	bb b3					.word Command_GOSUB        & $FFFF ; $ca gosub
>aedc	c9 b3					.word Command_RETURN       & $FFFF ; $cb return
>aede	b5 b3					.word Command_GOTO         & $FFFF ; $cc goto
>aee0	b8 b1					.word Command_END          & $FFFF ; $cd end
>aee2	02 af					.word NotImplemented       & $FFFF ; $ce input
>aee4	97 b1					.word Command_LET          & $FFFF ; $cf let
>aee6	bd b1					.word Command_LIST         & $FFFF ; $d0 list
>aee8	57 b3					.word Command_NEW          & $FFFF ; $d1 new
>aeea	76 b3					.word Command_OLD          & $FFFF ; $d2 old
>aeec	02 af					.word NotImplemented       & $FFFF ; $d3 on
>aeee	02 af					.word NotImplemented       & $FFFF ; $d4 restore
>aef0	02 af					.word NotImplemented       & $FFFF ; $d5 poke
>aef2	ce b2					.word Command_PRINT        & $FFFF ; $d6 print
>aef4	17 b1					.word Command_RUN          & $FFFF ; $d7 run
>aef6	02 af					.word NotImplemented       & $FFFF ; $d8 wait
>aef8	02 af					.word NotImplemented       & $FFFF ; $d9 sys
>aefa	02 af					.word NotImplemented       & $FFFF ; $da doke
>aefc	02 af					.word NotImplemented       & $FFFF ; $db loke
>aefe	3f b3					.word Command_ASSERT       & $FFFF ; $dc assert
>af00	02 af					.word NotImplemented       & $FFFF ; $dd get
.af02					NotImplemented:
.af02	20 e4 ad	jsr $ade4			jsr ERR_Handler
>af05	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>af0d	65 6d 65 6e 74 65 64 00
.af15					BinaryPrecedence:
>af15	01					.byte 1    ; $80 and
>af16	01					.byte 1    ; $81 or
>af17	01					.byte 1    ; $82 xor
>af18	01					.byte 1    ; $83 eor
>af19	02					.byte 2    ; $84 =
>af1a	02					.byte 2    ; $85 <>
>af1b	02					.byte 2    ; $86 <
>af1c	02					.byte 2    ; $87 <=
>af1d	02					.byte 2    ; $88 >
>af1e	02					.byte 2    ; $89 >=
>af1f	03					.byte 3    ; $8a +
>af20	03					.byte 3    ; $8b -
>af21	04					.byte 4    ; $8c *
>af22	04					.byte 4    ; $8d /
>af23	05					.byte 5    ; $8e ^
.af24					KeywordText:
>af24	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>af27	4f d2					.byte $4f,$d2                          ; $81 or
>af29	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>af2c	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>af2f	bd					.byte $bd                              ; $84 =
>af30	3c be					.byte $3c,$be                          ; $85 <>
>af32	bc					.byte $bc                              ; $86 <
>af33	3c bd					.byte $3c,$bd                          ; $87 <=
>af35	be					.byte $be                              ; $88 >
>af36	3e bd					.byte $3e,$bd                          ; $89 >=
>af38	ab					.byte $ab                              ; $8a +
>af39	ad					.byte $ad                              ; $8b -
>af3a	aa					.byte $aa                              ; $8c *
>af3b	af					.byte $af                              ; $8d /
>af3c	de					.byte $de                              ; $8e ^
>af3d	49 c6					.byte $49,$c6                          ; $8f if
>af3f	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>af44	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>af4a	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>af4d	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>af51	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>af56	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>af5a	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>af5f	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>af63	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>af66	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>af69	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>af6d	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>af71	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>af75	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>af7a	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>af7e	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>af82	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>af88	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>af8f	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>af94	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>af98	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>af9d	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>afa1	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>afa5	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>afaa	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>afae	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>afb2	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>afb6	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>afba	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>afbe	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>afc2	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>afc6	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>afca	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>afcf	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>afd4	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>afd8	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>afdc	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>afe1	50 4f 53 a8				.byte $50,$4f,$53,$a8                  ; $b5 pos(
>afe5	54 41 42 a8				.byte $54,$41,$42,$a8                  ; $b6 tab(
>afe9	a4					.byte $a4                              ; $b7 $
>afea	24 a8					.byte $24,$a8                          ; $b8 $(
>afec	a3					.byte $a3                              ; $b9 #
>afed	23 a8					.byte $23,$a8                          ; $ba #(
>afef	a5					.byte $a5                              ; $bb %
>aff0	25 a8					.byte $25,$a8                          ; $bc %(
>aff2	a8					.byte $a8                              ; $bd (
>aff3	a9					.byte $a9                              ; $be )
>aff4	ac					.byte $ac                              ; $bf ,
>aff5	ba					.byte $ba                              ; $c0 :
>aff6	bb					.byte $bb                              ; $c1 ;
>aff7	44 45 c6				.byte $44,$45,$c6                      ; $c2 def
>affa	43 4c d2				.byte $43,$4c,$d2                      ; $c3 clr
>affd	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $c4 stop
>b001	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c5 data
>b005	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c6 read
>b009	44 49 cd				.byte $44,$49,$cd                      ; $c7 dim
>b00c	54 cf					.byte $54,$cf                          ; $c8 to
>b00e	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c9 step
>b012	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $ca gosub
>b017	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $cb return
>b01d	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $cc goto
>b021	45 4e c4				.byte $45,$4e,$c4                      ; $cd end
>b024	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $ce input
>b029	4c 45 d4				.byte $4c,$45,$d4                      ; $cf let
>b02c	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $d0 list
>b030	4e 45 d7				.byte $4e,$45,$d7                      ; $d1 new
>b033	4f 4c c4				.byte $4f,$4c,$c4                      ; $d2 old
>b036	4f ce					.byte $4f,$ce                          ; $d3 on
>b038	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d4 restore
>b03f	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d5 poke
>b043	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d6 print
>b048	52 55 ce				.byte $52,$55,$ce                      ; $d7 run
>b04b	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d8 wait
>b04f	53 59 d3				.byte $53,$59,$d3                      ; $d9 sys
>b052	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $da doke
>b056	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $db loke
>b05a	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $dc assert
>b060	47 45 d4				.byte $47,$45,$d4                      ; $dd get
>b063	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_pos = $b5
=$b6					token_tab = $b6
=$b7					token_dollar = $b7
=$b8					token_dollarlparen = $b8
=$b9					token_hash = $b9
=$ba					token_hashlparen = $ba
=$bb					token_percent = $bb
=$bc					token_percentlparen = $bc
=$bd					token_lparen = $bd
=$be					token_rparen = $be
=$bf					token_comma = $bf
=$c0					token_colon = $c0
=$c1					token_semicolon = $c1
=$c2					token_def = $c2
=$c3					token_clr = $c3
=$c4					token_stop = $c4
=$c5					token_data = $c5
=$c6					token_read = $c6
=$c7					token_dim = $c7
=$c8					token_to = $c8
=$c9					token_step = $c9
=$ca					token_gosub = $ca
=$cb					token_return = $cb
=$cc					token_goto = $cc
=$cd					token_end = $cd
=$ce					token_input = $ce
=$cf					token_let = $cf
=$d0					token_list = $d0
=$d1					token_new = $d1
=$d2					token_old = $d2
=$d3					token_on = $d3
=$d4					token_restore = $d4
=$d5					token_poke = $d5
=$d6					token_print = $d6
=$d7					token_run = $d7
=$d8					token_wait = $d8
=$d9					token_sys = $d9
=$da					token_doke = $da
=$db					token_loke = $db
=$dc					token_assert = $dc
=$dd					token_get = $dd

;******  Return to file: modules/basic/core.asm

.b064					BASIC_Start:
.b064	20 4d a2	jsr $a24d			jsr 	IF_Reset 					; set up and clear screen.
.b067	20 0c a0	jsr $a00c			jsr 	IFT_ClearScreen
.b06a	a9 4c		lda #$4c			lda 	#$4C 						; JMP opcode
.b06c	8d 10 03	sta $0310			sta 	LocalVector
.b06f	8d 0c 03	sta $030c			sta 	UserVector
.b072	a9 49		lda #$49			lda 	#USRDefault & $FF 			; reset USR vector
.b074	8d 0d 03	sta $030d			sta 	UserVector+1
.b077	a9 b9		lda #$b9			lda 	#(USRDefault >> 8) & $FF
.b079	8d 0e 03	sta $030e			sta 	UserVector+2
.b07c	a9 00		lda #$00			lda 	#(USRDefault >> 16) & $FF
.b07e	8d 0f 03	sta $030f			sta 	UserVector+3
.b081	20 e2 bb	jsr $bbe2			jsr 	UpdateProgramEnd 			; update the program end.
.b084	20 45 b4	jsr $b445			jsr 	ResetRunStatus 				; clear everything (CLR command)
.b087					WarmStart:
.b087	a2 ff		ldx #$ff			ldx 		#$FF 					; empty stack
.b089	9a		txs				txs
.b08a	4c 17 b1	jmp $b117			jmp 	COMMAND_Run

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/dim.asm

.b08d					Command_DIM:
.b08d	6b		tza				tza
.b08e	48		pha				pha 								; push on stack.
.b08f	20 54 bd	jsr $bd54			jsr 	VariableExtract 			; get the identifier
.b092	ad 95 03	lda $0395			lda 	Var_Type 					; check it is an array
.b095	29 01		and #$01			and 	#1
.b097	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.b099	d0 6e		bne $b109			bne 	_CDIError
.b09b	a9 00		lda #$00			lda 	#0 							; reset the DIM index. The dimensions are
.b09d	8d b7 03	sta $03b7			sta 	UsrArrayIdx 				; built up here and copied in case we autodim
.b0a0					_CDIGetDimension:
.b0a0	ad b7 03	lda $03b7			lda 	UsrArrayIdx 				; done too many ?
.b0a3	c9 06		cmp #$06			cmp 	#ArrayMaxDim*2
.b0a5	f0 62		beq $b109			beq 	_CDIError
.b0a7	20 25 b6	jsr $b625			jsr 	EvaluateInteger 			; evaluate an index size
.b0aa	a5 81		lda $81				lda 	XS_Mantissa+1 				; check in range 0-7FFF
.b0ac	29 80		and #$80			and 	#$80
.b0ae	05 82		ora $82				ora 	XS_Mantissa+2
.b0b0	05 83		ora $83				ora 	XS_Mantissa+3
.b0b2	d0 55		bne $b109			bne 	_CDIError
.b0b4	ae b7 03	ldx $03b7			ldx 	UsrArrayIdx 				; copy into the array table.
.b0b7	18		clc				clc 								; add 1 - max index => size.
.b0b8	a5 80		lda $80				lda 	XS_Mantissa+0
.b0ba	69 01		adc #$01			adc 	#1
.b0bc	9d af 03	sta $03af,x			sta 	UsrArrayDef+0,x
.b0bf	a5 81		lda $81				lda 	XS_Mantissa+1
.b0c1	69 00		adc #$00			adc 	#0
.b0c3	9d b0 03	sta $03b0,x			sta 	UsrArrayDef+1,x
.b0c6	30 41		bmi $b109			bmi 	_CDIError 					; could be dim a(32767)
.b0c8	e8		inx				inx 								; bump index.
.b0c9	e8		inx				inx
.b0ca	8e b7 03	stx $03b7			stx 	UsrArrayIdx
.b0cd	ea		nop				nop
.b0ce	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b0d0	1b		inz				inz
.b0d1	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another dimension
.b0d3	f0 cb		beq $b0a0			beq 	_CDIGetDimension
.b0d5	3b		dez				dez
.b0d6	20 43 bc	jsr $bc43			jsr 	CheckNextRParen 			; closing ) present ?
.b0d9	ae b7 03	ldx $03b7			ldx 	UsrArrayIdx 				; copy USR array to default
.b0dc	a9 ff		lda #$ff			lda 	#$FF 						; put end marker in ArrayDef
.b0de	9d a8 03	sta $03a8,x			sta 	ArrayDef+1,x
.b0e1					_CDICopy:
.b0e1	bd af 03	lda $03af,x			lda 	UsrArrayDef,x
.b0e4	9d a7 03	sta $03a7,x			sta 	ArrayDef,x
.b0e7	ca		dex				dex
.b0e8	10 f7		bpl $b0e1			bpl 	_CDICopy
.b0ea	68		pla				pla									; position of array identifier
.b0eb	85 10		sta $10				sta 	zTemp1
.b0ed	6b		tza				tza
.b0ee	48		pha				pha
.b0ef	a5 10		lda $10				lda 	zTemp1 						; point to identifier
.b0f1	4b		taz				taz
.b0f2	20 54 bd	jsr $bd54			jsr 	VariableExtract 			; get the identifier
.b0f5	20 ef bf	jsr $bfef			jsr 	VariableLocate 				; check if it exists already.
.b0f8	b0 0f		bcs $b109			bcs 	_CDIError
.b0fa	20 e2 bd	jsr $bde2			jsr 	VariableCreate 				; create it using the current ArrayDef
.b0fd	68		pla				pla 								; restore code position
.b0fe	4b		taz				taz
.b0ff	ea		nop				nop
.b100	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b102	1b		inz				inz
.b103	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another DIM
.b105	f0 86		beq $b08d			beq 	Command_DIM
.b107	3b		dez				dez
.b108	60		rts				rts
.b109					_CDIError:
.b109	20 e4 ad	jsr $ade4			jsr ERR_Handler
>b10c	42 61 64 20 44 49 4d 00			.text "Bad DIM",0
.b114					_CDISyntax:
.b114	4c b5 ad	jmp $adb5			jmp 	SyntaxError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/run.asm

.b117					Command_RUN:
.b117	20 45 b4	jsr $b445			jsr 	ResetRunStatus 				; clear, reset stacks etc.
.b11a	a9 00		lda #$00			lda 	#BasicProgram & $FF
.b11c	85 16		sta $16				sta 	zCodePtr+0
.b11e	a9 80		lda #$80			lda 	#BasicProgram >> 8
.b120	85 17		sta $17				sta 	zCodePtr+1
.b122	a9 02		lda #$02			lda 	#2
.b124	85 18		sta $18				sta 	zCodePtr+2
.b126	a9 00		lda #$00			lda 	#0
.b128	85 19		sta $19				sta 	zCodePtr+3
.b12a	a3 03		ldz #$03			ldz 	#3
.b12c					RUN_NewLine:
.b12c	a3 00		ldz #$00			ldz 	#0
.b12e	ea		nop				nop
.b12f	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b131	1b		inz				inz
.b132	1b		inz				inz
.b133	1b		inz				inz
.b134	c9 00		cmp #$00			cmp 	#0 							; if the offset is zero then END.
.b136	d0 18		bne $b150			bne 	RUN_NextCommand
.b138	4c b8 b1	jmp $b1b8			jmp 	Command_END 				; go do the command code.
.b13b					RUN_Skip:
.b13b	ea		nop				nop
.b13c	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read element
.b13e	1b		inz				inz 								; skip
.b13f	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.b141	90 0d		bcc $b150			bcc 	_SEDone 					; so just skip over it.
.b143	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.b145	90 08		bcc $b14f			bcc 	_SEDouble
.b147	6b		tza				tza 								; this is Y + 1
.b148	18		clc				clc
.b149	ea		nop				nop
.b14a	72 16		adc ($16),z			adc 	(zCodePtr),z 				; add total length of element
.b14c	4b		taz				taz 								; back in Y.
.b14d	3b		dez				dez 								; fix up, one for the +1, one for the iny
.b14e	3b		dez				dez
.b14f					_SEDouble:
.b14f	1b		inz				inz
.b150					_SEDone:
.b150					RUN_NextCommand:
.b150	a9 00		lda #$00			lda 	#0 							; this resets temporary string allocation.
.b152	85 21		sta $21				sta 	zTempStr+1 					; (initialised when first called)
.b154	ea		nop				nop
.b155	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b157	c9 c0		cmp #$c0			cmp 	#token_Colon 				; skip over colons
.b159	f0 e0		beq $b13b			beq 	RUN_Skip
.b15b	c9 00		cmp #$00			cmp 	#0 							; if non-zero execute whatever
.b15d	d0 10		bne $b16f			bne 	RUN_Execute
.b15f					RUN_NextLine:
.b15f	a3 00		ldz #$00			ldz 	#0 							; point to offset
.b161	ea		nop				nop
.b162	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read it
.b164	18		clc				clc
.b165	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.b167	85 16		sta $16				sta 	zCodePtr
.b169	90 02		bcc $b16d			bcc 	_SNLNoCarry
.b16b	e6 17		inc $17				inc 	zCodePtr+1
.b16d					_SNLNoCarry:
.b16d	80 bd		bra $b12c			bra 	RUN_NewLine 				; go do the new line code
.b16f					RUN_Execute:
.b16f	c9 f8		cmp #$f8			cmp 	#$F8 						; handle shifts, REM etc.
.b171	b0 1c		bcs $b18f			bcs 	RUN_Extension
.b173	1b		inz				inz
.b174	0a		asl a				asl 	a 							; double the character read.
.b175	90 12		bcc $b189			bcc 	RUN_Default 				; if carry clear was $00-$7F, so try LET.
.b177	aa		tax				tax 								; ready to look up.
.b178	bd 46 ae	lda $ae46,x			lda 	VectorTable,x 				; copy address into LocalVector
.b17b	8d 11 03	sta $0311			sta 	LocalVector+1
.b17e	bd 47 ae	lda $ae47,x			lda 	VectorTable+1,x
.b181	8d 12 03	sta $0312			sta 	LocalVector+2
.b184	20 6e b5	jsr $b56e			jsr 	EVCallLocalVector 			; execute the appropriate code.
.b187	80 c7		bra $b150			bra 	RUN_NextCommand 			; do the next command.
.b189					RUN_Default:
.b189	3b		dez				dez
.b18a	20 97 b1	jsr $b197			jsr 	Command_LET 				; and try LET.
.b18d	80 c1		bra $b150			bra 	RUN_NextCommand
.b18f					RUN_Extension:
.b18f	c9 ff		cmp #$ff			cmp 	#$FF 						; if $FF (REM)
.b191	f0 a8		beq $b13b			beq 	RUN_Skip 					; skip over it.
.b193	4c b5 ad	jmp $adb5			jmp 	SyntaxError
.b196					Command_COLON:
.b196	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/let.asm

.b197					Command_LET:
.b197	20 e9 bc	jsr $bce9			jsr 	VariableFind 				; get reference to one variable.
.b19a	a9 84		lda #$84			lda 	#token_Equal  				; get equals
.b19c	20 2b bc	jsr $bc2b			jsr 	CheckNextToken
.b19f	a5 22		lda $22				lda 	zVarDataPtr 				; save variable info on stack
.b1a1	48		pha				pha
.b1a2	a5 23		lda $23				lda 	zVarDataPtr+1
.b1a4	48		pha				pha
.b1a5	a5 24		lda $24				lda 	zVarType
.b1a7	48		pha				pha
.b1a8	20 88 b4	jsr $b488			jsr 	EvaluateExpression 			; evaluate the RHS.
.b1ab	68		pla				pla 								; restore target variable information.
.b1ac	85 24		sta $24				sta 	zVarType
.b1ae	68		pla				pla
.b1af	85 23		sta $23				sta 	zVarDataPtr+1
.b1b1	68		pla				pla
.b1b2	85 22		sta $22				sta 	zVarDataPtr
.b1b4	20 84 c0	jsr $c084			jsr 	VariableSet 				; set the value out.
.b1b7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/end.asm

.b1b8					Command_END:
.b1b8	80 fe		bra $b1b8	_halt:	bra 		_halt
.b1ba	4c 87 b0	jmp $b087			jmp 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/list.asm

.b1bd					Command_LIST:
.b1bd	a9 00		lda #$00			lda 	#BasicProgram & $FF
.b1bf	85 16		sta $16				sta 	zCodePtr+0
.b1c1	a9 80		lda #$80			lda 	#BasicProgram >> 8
.b1c3	85 17		sta $17				sta 	zCodePtr+1
.b1c5	a9 02		lda #$02			lda 	#2
.b1c7	85 18		sta $18				sta 	zCodePtr+2
.b1c9	a9 00		lda #$00			lda 	#0
.b1cb	85 19		sta $19				sta 	zCodePtr+3
.b1cd	a3 03		ldz #$03			ldz 	#3
.b1cf					_CILLoop:
.b1cf	a3 00		ldz #$00			ldz 	#0
.b1d1	ea		nop				nop
.b1d2	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b1d4	c9 00		cmp #$00			cmp 	#0 							; if zero, end of program
.b1d6	f0 13		beq $b1eb			beq 	_CILExit
.b1d8	20 f0 b1	jsr $b1f0			jsr 	ListLine 					; list one line.
.b1db	a3 00		ldz #$00			ldz 	#0 							; point to offset
.b1dd	ea		nop				nop
.b1de	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read it
.b1e0	18		clc				clc
.b1e1	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.b1e3	85 16		sta $16				sta 	zCodePtr
.b1e5	90 02		bcc $b1e9			bcc 	_SNLNoCarry
.b1e7	e6 17		inc $17				inc 	zCodePtr+1
.b1e9					_SNLNoCarry:
.b1e9	80 e4		bra $b1cf			bra 	_CILLoop
.b1eb					_CILExit:
.b1eb	80 fe		bra $b1eb			bra 	_CILExit
.b1ed	4c 87 b0	jmp $b087			jmp 	WarmStart
.b1f0					ListLine:
.b1f0	a3 00		ldz #$00			ldz 	#0
.b1f2	1b		inz				inz
.b1f3	ea		nop				nop
.b1f4	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b1f6	85 80		sta $80				sta 	XS_Mantissa
.b1f8	1b		inz				inz
.b1f9	ea		nop				nop
.b1fa	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b1fc	85 81		sta $81				sta 	XS_Mantissa+1
.b1fe	20 28 ae	jsr $ae28			jsr 	Print16BitInteger 			; print integer.
.b201	aa		tax				tax 								; print spaces to column 6
.b202					_LISpace:
.b202	a9 20		lda #$20			lda 	#" "
.b204	20 af ad	jsr $adaf			jsr 	CharPrint
.b207	e8		inx				inx
.b208	e0 06		cpx #$06			cpx 	#6
.b20a	d0 f6		bne $b202			bne 	_LISpace
.b20c					_LIDecode:
.b20c	1b		inz				inz
.b20d	ea		nop				nop
.b20e	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b210	c9 00		cmp #$00			cmp 	#0 							; zero, exit.
.b212	f0 0f		beq $b223			beq 	_LIExit
.b214	30 12		bmi $b228			bmi 	_LIToken
.b216	c9 40		cmp #$40			cmp 	#$40 						; 01-$3F, character.
.b218	b0 52		bcs $b26c			bcs 	_LIInteger
.b21a	49 20		eor #$20			eor 	#$20 						; make 7 bit
.b21c	69 20		adc #$20			adc 	#$20
.b21e	20 c1 b2	jsr $b2c1			jsr 	ListPrintLC 				; print in LC
.b221	80 e9		bra $b20c			bra 	_LIDecode
.b223					_LIExit:
.b223	a9 0d		lda #$0d			lda 	#13 						; print new line.
.b225	4c af ad	jmp $adaf			jmp 	CharPrint
.b228					_LIToken:
.b228	c9 fc		cmp #$fc			cmp 	#$FC 						; $FC-$FF ?
.b22a	90 4b		bcc $b277			bcc		_LICommandToken
.b22c	48		pha				pha 								; save in case end
.b22d	a2 22		ldx #$22			ldx 	#'"'						; print if $FE quoted string
.b22f	c9 fe		cmp #$fe			cmp 	#$FE
.b231	f0 17		beq $b24a			beq 	_LIPrint
.b233	a2 2e		ldx #$2e			ldx 	#'.'						; print if $FD decimals
.b235	c9 fd		cmp #$fd			cmp 	#$FD
.b237	f0 11		beq $b24a			beq 	_LIPrint
.b239	a9 52		lda #$52			lda 	#'R'						; must be REM
.b23b	20 c1 b2	jsr $b2c1			jsr 	ListPrintLC
.b23e	a9 45		lda #$45			lda 	#'E'
.b240	20 c1 b2	jsr $b2c1			jsr 	ListPrintLC
.b243	a9 4d		lda #$4d			lda 	#'M'
.b245	20 c1 b2	jsr $b2c1			jsr 	ListPrintLC
.b248	a2 20		ldx #$20			ldx 	#' '
.b24a					_LIPrint:
.b24a	8a		txa				txa
.b24b	20 c1 b2	jsr $b2c1			jsr 	ListPrintLC
.b24e	1b		inz				inz
.b24f	ea		nop				nop
.b250	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b252	aa		tax				tax 								; put in X
.b253	ca		dex				dex
.b254					_LILoop:
.b254	ca		dex				dex 								; exit when count reached zero.
.b255	f0 09		beq $b260			beq 	_LIEnd
.b257	1b		inz				inz
.b258	ea		nop				nop
.b259	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b25b	20 c1 b2	jsr $b2c1			jsr 	ListPrintLC
.b25e	80 f4		bra $b254			bra 	_LILoop
.b260	68		pla		_LIEnd:	pla 								; get A back
.b261	c9 fe		cmp #$fe			cmp 	#$FE 						; if '"' need closing quotes
.b263	d0 a7		bne $b20c			bne 	_LIDecode
.b265	a9 22		lda #$22			lda 	#'"'
.b267	20 c1 b2	jsr $b2c1			jsr 	ListPrintLC
.b26a	80 a0		bra $b20c			bra 	_LIDecode
.b26c					_LIInteger:
.b26c	a2 00		ldx #$00			ldx 	#0
.b26e	20 93 b5	jsr $b593			jsr 	EvaluateGetInteger 			; get an atom
.b271	3b		dez				dez
.b272	20 2e ae	jsr $ae2e			jsr 	Print32BitInteger 			; print integer.
.b275	80 95		bra $b20c			bra 	_LIDecode
.b277					_LICommandToken:
.b277	5a		phy				phy 								; save Y
.b278	48		pha				pha 								; save token
.b279	a2 24		ldx #$24			ldx  	#KeywordText & $FF 			; address of keyword text table.
.b27b	a9 af		lda #$af			lda 	(#KeywordText >> 8) & $FF
.b27d	86 1a		stx $1a				stx 	zLTemp1
.b27f	85 1b		sta $1b				sta 	zLTemp1+1
.b281	a9 00		lda #$00			lda 	(#KeywordText >> 16) & $FF 	; this is for 65816 (it's a table in code
.b283	85 1c		sta $1c				sta 	zLTemp1+2 					; space) and won't affect a 6502 at all.
.b285	68		pla				pla 								; get token, chuck bit 7.
.b286	29 7f		and #$7f			and 	#127
.b288	f0 16		beq $b2a0			beq 	_LIFoundToken
.b28a	aa		tax				tax
.b28b					_LITokenLoop:
.b28b	a0 00		ldy #$00			ldy 	#0
.b28d					_LIFindEnd:
.b28d	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b28f	c8		iny				iny
.b290	0a		asl a				asl 	a
.b291	90 fa		bcc $b28d			bcc 	_LIFindEnd
.b293	98		tya				tya 								; that is step to the next
.b294	18		clc				clc 								; we don't bother bumping the 3rd byte
.b295	65 1a		adc $1a				adc 	zLTemp1 					; here.
.b297	85 1a		sta $1a				sta 	zLTemp1
.b299	90 02		bcc $b29d			bcc 	_LINoBump
.b29b	e6 1b		inc $1b				inc 	zLTemp1+1
.b29d					_LINoBump:
.b29d	ca		dex				dex 								; no go round again.
.b29e	d0 eb		bne $b28b			bne 	_LITokenLoop
.b2a0					_LIFoundToken:
.b2a0	a0 00		ldy #$00			ldy 	#0
.b2a2					_LIPrintToken:
.b2a2	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b2a4	c8		iny				iny
.b2a5	48		pha				pha 								; save it
.b2a6	29 7f		and #$7f			and 	#$7F
.b2a8	20 c1 b2	jsr $b2c1			jsr 	ListPrintLC
.b2ab	68		pla				pla
.b2ac	10 f4		bpl $b2a2			bpl 	_LIPrintToken 				; go back if not end
.b2ae	7a		ply				ply 								; restore Y
.b2af	29 7f		and #$7f			and 	#$7F 						; if last char is a letter
.b2b1	c9 41		cmp #$41			cmp 	#"A"
.b2b3	90 09		bcc $b2be			bcc 	_LINotLetter
.b2b5	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b2b7	b0 05		bcs $b2be			bcs 	_LINotLetter
.b2b9	a9 20		lda #$20			lda 	#" " 						; add spacing
.b2bb	20 c1 b2	jsr $b2c1			jsr 	ListPrintLC
.b2be					_LINotLetter:
.b2be	4c 0c b2	jmp $b20c			jmp 	_LIDecode
.b2c1					ListPrintLC:
.b2c1	c9 41		cmp #$41			cmp 	#"A"
.b2c3	90 06		bcc $b2cb			bcc 	_LPLC0
.b2c5	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b2c7	b0 02		bcs $b2cb			bcs 	_LPLC0
.b2c9	69 20		adc #$20			adc 	#$20
.b2cb	4c af ad	jmp $adaf	_LPLC0:	jmp 	CharPrint

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/print.asm

.b2ce					Command_PRINT:
.b2ce	ea		nop				nop
.b2cf	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b2d1	c9 00		cmp #$00			cmp 	#0 							; end
.b2d3	f0 66		beq $b33b			beq 	_CPR_NewLine
.b2d5	c9 c0		cmp #$c0			cmp 	#token_Colon
.b2d7	f0 62		beq $b33b			beq 	_CPR_NewLine
.b2d9	c9 c1		cmp #$c1			cmp 	#token_SemiColon
.b2db	f0 50		beq $b32d			beq 	_CPR_Skip
.b2dd	c9 bf		cmp #$bf			cmp 	#token_Comma
.b2df	f0 49		beq $b32a			beq 	_CPR_Tab
.b2e1	20 88 b4	jsr $b488			jsr 	EvaluateExpression 			; get expression.
.b2e4	a5 85		lda $85				lda 	XS_Type 					; get type.
.b2e6	29 02		and #$02			and 	#2
.b2e8	d0 24		bne $b30e			bne 	_CPR_String 				; if type = 2 output as string.
.b2ea					_CPR_Number:
.b2ea	a9 00		lda #$00			lda 	#0 							; reset buffer index
.b2ec	8d 14 03	sta $0314			sta 	NumBufX
.b2ef	a5 85		lda $85				lda 	XS_Type 					; get type
.b2f1	4a		lsr a				lsr 	a
.b2f2	b0 05		bcs $b2f9			bcs 	_CPRInt 					; if msb set do as integer
.b2f4	20 04 c7	jsr $c704			jsr 	FPToString 					; call fp to str otherwise
.b2f7	80 03		bra $b2fc			bra 	_CPRNPrint
.b2f9	20 cd c1	jsr $c1cd	_CPRInt:jsr 	IntToString
.b2fc					_CPRNPrint:
.b2fc	ad 15 03	lda $0315			lda 	Num_Buffer 					; is first character -
.b2ff	c9 2d		cmp #$2d			cmp 	#"-"
.b301	f0 05		beq $b308			beq 	_CPRNoSpace
.b303	a9 20		lda #$20			lda 	#" "						; print the leading space
.b305	20 af ad	jsr $adaf			jsr 	CharPrint 					; so beloved of MS Basics.
.b308					_CPRNoSpace:
.b308	a2 14		ldx #$14			ldx 	#(Num_Buffer-1) & $FF
.b30a	a9 03		lda #$03			lda 	#(Num_Buffer-1) >> 8
.b30c	80 04		bra $b312			bra 	_CPRPrint
.b30e					_CPR_String:
.b30e	a6 80		ldx $80				ldx 	XS_Mantissa
.b310	a5 81		lda $81				lda 	XS_Mantissa+1
.b312					_CPRPrint:
.b312	86 1e		stx $1e				stx 	zGenPtr
.b314	85 1f		sta $1f				sta 	zGenPtr+1
.b316	5a		phy				phy
.b317	a0 00		ldy #$00			ldy 	#0							; get length into X
.b319	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b31b	aa		tax				tax
.b31c	f0 09		beq $b327			beq 	_CPREndPrint 				; nothing to print
.b31e					_CPRLoop:
.b31e	c8		iny				iny
.b31f	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b321	20 af ad	jsr $adaf			jsr 	CharPrint
.b324	ca		dex				dex
.b325	d0 f7		bne $b31e			bne 	_CPRLoop
.b327					_CPREndPrint:
.b327	7a		ply				ply
.b328	80 a4		bra $b2ce			bra 	Command_Print
.b32a					_CPR_Tab:
.b32a	20 5b a0	jsr $a05b			jsr 	IFT_Tab
.b32d					_CPR_Skip:
.b32d	1b		inz				inz
.b32e	ea		nop				nop
.b32f	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b331	c9 c0		cmp #$c0			cmp 	#token_Colon 				; colon or $00, exit
.b333	f0 09		beq $b33e			beq 	_CPR_Exit
.b335	c9 00		cmp #$00			cmp 	#0
.b337	d0 95		bne $b2ce			bne 	Command_PRINT 				; if not go round again.
.b339	80 03		bra $b33e			bra 	_CPR_Exit
.b33b					_CPR_NewLine:
.b33b	20 68 a0	jsr $a068			jsr 	IFT_NewLine
.b33e					_CPR_Exit:
.b33e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/assert.asm

.b33f					Command_ASSERT:
.b33f	20 25 b6	jsr $b625			jsr 	EvaluateInteger 			; calculate thing being asserted
.b342	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; check if true (non-zero)
.b344	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.b346	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.b348	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.b34a	f0 01		beq $b34d			beq 	_ASFail
.b34c	60		rts				rts
.b34d					_ASFail:
.b34d	20 e4 ad	jsr $ade4			jsr ERR_Handler
>b350	41 73 73 65 72 74 00			.text "Assert",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/newold.asm

.b357					Command_NEW:
.b357	a9 00		lda #$00			lda 	#BasicProgram & $FF
.b359	85 16		sta $16				sta 	zCodePtr+0
.b35b	a9 80		lda #$80			lda 	#BasicProgram >> 8
.b35d	85 17		sta $17				sta 	zCodePtr+1
.b35f	a9 02		lda #$02			lda 	#2
.b361	85 18		sta $18				sta 	zCodePtr+2
.b363	a9 00		lda #$00			lda 	#0
.b365	85 19		sta $19				sta 	zCodePtr+3
.b367	a3 03		ldz #$03			ldz 	#3
.b369	a3 00		ldz #$00			ldz 	#0
.b36b	a9 00		lda #$00			lda 	#0 							; write a 0 there.
.b36d	ea		nop				nop
.b36e	92 16		sta ($16),z			sta 	(zCodePtr),z
.b370	20 e2 bb	jsr $bbe2			jsr 	UpdateProgramEnd 			; update program end.
.b373	4c 87 b0	jmp $b087			jmp 	WarmStart
.b376					Command_OLD:
.b376	ea		nop				nop
.b377	a9 00		lda #$00			lda 	#BasicProgram & $FF
.b379	85 16		sta $16				sta 	zCodePtr+0
.b37b	a9 80		lda #$80			lda 	#BasicProgram >> 8
.b37d	85 17		sta $17				sta 	zCodePtr+1
.b37f	a9 02		lda #$02			lda 	#2
.b381	85 18		sta $18				sta 	zCodePtr+2
.b383	a9 00		lda #$00			lda 	#0
.b385	85 19		sta $19				sta 	zCodePtr+3
.b387	a3 03		ldz #$03			ldz 	#3
.b389					_COL_Find:
.b389	ea		nop				nop
.b38a	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b38c	1b		inz				inz
.b38d	c9 00		cmp #$00			cmp 	#0 							; if zero, then the position Y/Z is new offset
.b38f	f0 18		beq $b3a9			beq 	_COL_Found
.b391	6b		tza				tza
.b392	c9 00		cmp #$00			cmp 	#0
.b394	d0 f3		bne $b389			bne 	_COL_Find 					; can't find old EOL, give up.
.b396	20 e4 ad	jsr $ade4			jsr ERR_Handler
>b399	50 72 6f 67 72 61 6d 20			.text "Program Corrupt",0
>b3a1	43 6f 72 72 75 70 74 00
.b3a9					_COL_Found:
.b3a9	6b		tza				tza
.b3aa	48		pha				pha
.b3ab	a3 00		ldz #$00			ldz 	#0
.b3ad	68		pla				pla
.b3ae	ea		nop				nop
.b3af	92 16		sta ($16),z			sta 	(zCodePtr),z
.b3b1	20 e2 bb	jsr $bbe2			jsr 	UpdateProgramEnd 			; reset variable pointer
.b3b4	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/branch.asm

.b3b5					Command_GOTO:
.b3b5	20 d2 b3	jsr $b3d2			jsr 	GotoGetLineNumber
.b3b8	4c ef b3	jmp $b3ef			jmp 	GotoChangeToLineNumber
.b3bb					Command_GOSUB:
.b3bb	20 d2 b3	jsr $b3d2			jsr 	GotoGetLineNumber
.b3be	20 76 ad	jsr $ad76			jsr 	StackSavePosition
.b3c1	a9 05		lda #$05			lda 	#(SMark_Gosub << 4)+SourcePosSize
.b3c3	20 2f ad	jsr $ad2f			jsr 	StackPushFrame
.b3c6	4c ef b3	jmp $b3ef			jmp 	GotoChangeToLineNumber
.b3c9					Command_RETURN:
.b3c9	a9 00		lda #$00			lda 	#(SMark_Gosub << 4)
.b3cb	20 46 ad	jsr $ad46			jsr 	StackPopFrame
.b3ce	20 93 ad	jsr $ad93			jsr 	StackRestorePosition
.b3d1	60		rts				rts
.b3d2					GotoGetLineNumber:
.b3d2	20 25 b6	jsr $b625			jsr 	EvaluateInteger
.b3d5	a5 82		lda $82				lda 	XS_Mantissa+2 				; check range
.b3d7	05 83		ora $83				ora 	XS_Mantissa+3
.b3d9	d0 01		bne $b3dc			bne 	_GLINError
.b3db	60		rts				rts
.b3dc					_GLINError:
.b3dc	20 e4 ad	jsr $ade4			jsr ERR_Handler
>b3df	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>b3e7	20 4e 75 6d 62 65 72 00
.b3ef					GotoChangeToLineNumber:
.b3ef	a5 80		lda $80				lda 	XS_Mantissa+0 				; check line number not zero
.b3f1	05 81		ora $81				ora 	XS_Mantissa+1
.b3f3	f0 3d		beq $b432			beq 	_GCTLFail
.b3f5	a9 00		lda #$00			lda 	#BasicProgram & $FF
.b3f7	85 16		sta $16				sta 	zCodePtr+0
.b3f9	a9 80		lda #$80			lda 	#BasicProgram >> 8
.b3fb	85 17		sta $17				sta 	zCodePtr+1
.b3fd	a9 02		lda #$02			lda 	#2
.b3ff	85 18		sta $18				sta 	zCodePtr+2
.b401	a9 00		lda #$00			lda 	#0
.b403	85 19		sta $19				sta 	zCodePtr+3
.b405	a3 03		ldz #$03			ldz 	#3
.b407					_GCTLLoop:
.b407	a3 00		ldz #$00			ldz 	#0
.b409	ea		nop				nop
.b40a	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b40c	c9 00		cmp #$00			cmp 	#0
.b40e	f0 22		beq $b432			beq 	_GCTLFail
.b410	1b		inz				inz
.b411	ea		nop				nop
.b412	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b414	c5 80		cmp $80				cmp 	XS_Mantissa+0
.b416	d0 08		bne $b420			bne 	_GCTLNext
.b418	1b		inz				inz
.b419	ea		nop				nop
.b41a	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b41c	c5 81		cmp $81				cmp 	XS_Mantissa+1
.b41e	f0 10		beq $b430			beq 	_GCTLExit
.b420					_GCTLNext:
.b420	a3 00		ldz #$00			ldz 	#0 							; point to offset
.b422	ea		nop				nop
.b423	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read it
.b425	18		clc				clc
.b426	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.b428	85 16		sta $16				sta 	zCodePtr
.b42a	90 02		bcc $b42e			bcc 	_SNLNoCarry
.b42c	e6 17		inc $17				inc 	zCodePtr+1
.b42e					_SNLNoCarry:
.b42e	80 d7		bra $b407			bra 	_GCTLLoop 					; try next line.
.b430					_GCTLExit:
.b430	1b		inz				inz
.b431	60		rts				rts
.b432					_GCTLFail:
.b432	20 e4 ad	jsr $ade4			jsr ERR_Handler
>b435	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>b43d	20 4e 75 6d 62 65 72 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.b445					Command_CLR:
.b445					ResetRunStatus:
.b445	20 25 bd	jsr $bd25			jsr 	VariableClear
.b448	20 1d ad	jsr $ad1d			jsr 	StackReset
.b44b	a9 00		lda #$00			lda 	#HighMemory & $FF
.b44d	8d 00 03	sta $0300			sta 	StringPtr
.b450	a9 7f		lda #$7f			lda 	#HighMemory >> 8
.b452	8d 01 03	sta $0301			sta 	StringPtr+1
.b455	20 f1 be	jsr $bef1			jsr 	ArrayResetDefault
.b458	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/stop.asm

.b459					Command_STOP:
.b459	20 e4 ad	jsr $ade4			jsr ERR_Handler
>b45c	53 74 6f 70 00				.text "Stop",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/repeat.asm

.b461					Command_REPEAT:
.b461	20 76 ad	jsr $ad76			jsr 	StackSavePosition			; save position into stack
.b464	a9 15		lda #$15			lda 	#(SMark_Repeat << 4)+SourcePosSize
.b466	20 2f ad	jsr $ad2f			jsr 	StackPushFrame 				; push on stack
.b469	60		rts				rts
.b46a					Command_UNTIL:
.b46a	a9 10		lda #$10			lda 	#(SMark_Repeat << 4)		; remove the frame
.b46c	20 46 ad	jsr $ad46			jsr 	StackPopFrame
.b46f	20 25 b6	jsr $b625			jsr 	EvaluateInteger				; work out UNTIL
.b472	a5 80		lda $80				lda 	XS_Mantissa+0 				; check if zero.
.b474	05 81		ora $81				ora 	XS_Mantissa+1
.b476	05 82		ora $82				ora 	XS_Mantissa+2
.b478	05 83		ora $83				ora 	XS_Mantissa+3
.b47a	d0 08		bne $b484			bne 	_CUTExit 					; if not, just exit
.b47c	20 93 ad	jsr $ad93			jsr 	StackRestorePosition 		; otherwise loop round again.
.b47f	a9 15		lda #$15			lda 	#(SMark_Repeat << 4)+SourcePosSize
.b481	20 2f ad	jsr $ad2f			jsr 	StackPushFrame 				; fix the stack back.
.b484					_CUTExit:
.b484	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.b485					EVESyntax:
.b485	4c b5 ad	jmp $adb5			jmp 	SyntaxError
.b488					EvaluateExpression:
.b488	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.b48a					EvaluateExpressionX:
.b48a	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.b48c					EvaluateExpressionXA:
.b48c	48		pha				pha 								; save precedence on stack.
.b48d	ea		nop				nop
.b48e	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b490	f0 f3		beq $b485			beq 	EVESyntax 					; end of line, syntax error.
.b492	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.b494	b0 03		bcs $b499			bcs 	_EVNotVariable
.b496	4c 65 b5	jmp $b565			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.b499					_EVNotVariable:
.b499	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.b49b	90 e8		bcc $b485			bcc 	EVESyntax
.b49d	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.b49f	b0 59		bcs $b4fa			bcs 	_EVNotInteger
.b4a1	20 93 b5	jsr $b593			jsr 	EvaluateGetInteger
.b4a4					_EVCheckDecimal:
.b4a4	ea		nop				nop
.b4a5	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b4a7	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.b4a9	d0 05		bne $b4b0			bne 	_EVGotAtom 					; no, get atom.
.b4ab					_EVIsDecimal:
.b4ab	20 bb b5	jsr $b5bb			jsr 	EVGetDecimal 				; extend to the decimal part.
.b4ae	80 00		bra $b4b0			bra 	_EVGotAtom 					; and continue to got atom.
.b4b0					_EVGotAtom:
.b4b0	ea		nop				nop
.b4b1	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b4b3	10 43		bpl $b4f8			bpl 	_EVExitDrop 				; must be a token.
.b4b5	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.b4b7	b0 3f		bcs $b4f8			bcs 	_EVExitDrop
.b4b9	68		pla				pla 								; get current precedence
.b4ba	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.b4bc	da		phx				phx 								; save X
.b4bd	ea		nop				nop
.b4be	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b4c0	aa		tax				tax 								; put in X
.b4c1	bd 95 ae	lda $ae95,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.b4c4	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.b4c6	fa		plx				plx 								; restore X
.b4c7	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.b4c9	90 2e		bcc $b4f9			bcc 	_EVExit 					; exit if too low.
.b4cb	f0 2c		beq $b4f9			beq 	_EVExit 					; exit if equals
.b4cd	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.b4cf	48		pha				pha
.b4d0	ea		nop				nop
.b4d1	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b4d3	48		pha				pha
.b4d4	1b		inz				inz
.b4d5	da		phx				phx 								; save current position
.b4d6	e8		inx				inx
.b4d7	e8		inx				inx
.b4d8	e8		inx				inx
.b4d9	e8		inx				inx
.b4da	e8		inx				inx
.b4db	e8		inx				inx
.b4dc	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.b4de	20 8c b4	jsr $b48c			jsr 	EvaluateExpressionXA 		; do the RHS.
.b4e1	fa		plx				plx 								; restore X
.b4e2	68		pla				pla 								; get the binary operator in A.
.b4e3					_EVCallA:
.b4e3	da		phx				phx 								; save X again
.b4e4	0a		asl a				asl 	a 							; double, lose the MSB.
.b4e5	aa		tax				tax									; put in X
.b4e6	bd 46 ae	lda $ae46,x			lda 	VectorTable,x 				; copy address into zGenPtr
.b4e9	8d 11 03	sta $0311			sta 	LocalVector+1
.b4ec	bd 47 ae	lda $ae47,x			lda 	VectorTable+1,x
.b4ef	8d 12 03	sta $0312			sta 	LocalVector+2
.b4f2	fa		plx				plx 								; restore X
.b4f3	20 6e b5	jsr $b56e			jsr 	EVCallLocalVector
.b4f6	80 b8		bra $b4b0			bra 	_EVGotAtom 					; and loop back.
.b4f8					_EVExitDrop:
.b4f8	68		pla				pla
.b4f9					_EVExit:
.b4f9	60		rts				rts
.b4fa					_EVNotInteger:
.b4fa	1b		inz				inz
.b4fb	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.b4fd	d0 16		bne $b515			bne 	_EVNotMinus
.b4ff	20 06 b6	jsr $b606			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.b502	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.b504	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.b506	f0 05		beq $b50d			beq 	_EVMinusFloat
.b508	20 b0 c1	jsr $c1b0			jsr 	IntegerNegateAlways 		; negation
.b50b	80 a3		bra $b4b0			bra 	_EVGotAtom 					; and go back.
.b50d					_EVMinusFloat:
.b50d	b5 85		lda $85,x			lda 	XS_Type,x 					; invert the sign bit.
.b50f	49 80		eor #$80			eor 	#$80
.b511	95 85		sta $85,x			sta 	XS_Type,x
.b513	80 9b		bra $b4b0			bra 	_EVGotAtom
.b515					_EVNotMinus:
.b515	c9 bd		cmp #$bd			cmp 	#token_lparen 				; is it left parenthesis
.b517	d0 18		bne $b531			bne 	_EVNotParenthesis
.b519	20 8a b4	jsr $b48a			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.b51c	ea		nop				nop
.b51d	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b51f	1b		inz				inz
.b520	c9 be		cmp #$be			cmp 	#token_rparen 				; okay if right bracket.
.b522	f0 8c		beq $b4b0			beq 	_EVGotAtom
.b524	20 e4 ad	jsr $ade4			jsr ERR_Handler
>b527	4d 69 73 73 69 6e 67 20			.text "Missing )",0
>b52f	29 00
.b531					_EVNotParenthesis:
.b531	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.b533	d0 0c		bne $b541			bne 	_EVNotNot
.b535	20 06 b6	jsr $b606			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.b538	20 05 c6	jsr $c605			jsr 	FPUToInteger 				; make it an integer - if possible.
.b53b	20 eb b5	jsr $b5eb			jsr 	NotInteger 					; do the not calculation
.b53e	4c b0 b4	jmp $b4b0			jmp 	_EVGotAtom
.b541					_EVNotNot:
.b541	c9 fe		cmp #$fe			cmp 	#$FE
.b543	d0 12		bne $b557			bne 	_EVNotString
.b545	20 c0 bc	jsr $bcc0			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.b548	a5 20		lda $20				lda 	zTempStr 					; copy address of string into mantissa
.b54a	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b54c	a5 21		lda $21				lda 	zTempStr+1
.b54e	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b550	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.b552	95 85		sta $85,x			sta 	XS_Type,x
.b554	4c b0 b4	jmp $b4b0			jmp 	_EVGotAtom
.b557					_EVNotString:
.b557	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.b559	90 04		bcc $b55f			bcc 	_EVBadElement
.b55b	c9 b7		cmp #$b7			cmp 	#lastUnaryFunction+1
.b55d	90 03		bcc $b562			bcc 	_EVUnaryFunction
.b55f					_EVBadElement:
.b55f	4c b5 ad	jmp $adb5			jmp 	SyntaxError
.b562					_EVUnaryFunction:
.b562	4c e3 b4	jmp $b4e3			jmp 	_EVCallA
.b565					_EVVariableHandler:
.b565	20 e9 bc	jsr $bce9			jsr 	VariableFind 				; locate a variable
.b568	20 33 c0	jsr $c033			jsr 	VariableGet 				; copy into memory.
.b56b	4c b0 b4	jmp $b4b0			jmp 	_EVGotAtom 					; and go round.
.b56e					EVCallLocalVector:
.b56e	6c 11 03	jmp ($0311)			jmp 	(LocalVector+1)
.b571					EVShiftMantissaLeft6:
.b571	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.b573	95 84		sta $84,x			sta 	XS_Exponent,x
.b575	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.b577	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b579	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b57b	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b57d	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.b57f	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b581	a9 00		lda #$00			lda 	#0
.b583	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b585	20 88 b5	jsr $b588			jsr 	_EVSMLShift 					; call it here to do it twice
.b588					_EVSMLShift:
.b588	56 84		lsr $84,x			lsr 	XS_Exponent,x
.b58a	76 83		ror $83,x			ror 	XS_Mantissa+3,x
.b58c	76 82		ror $82,x			ror 	XS_Mantissa+2,x
.b58e	76 81		ror $81,x			ror 	XS_Mantissa+1,x
.b590	76 80		ror $80,x			ror 	XS_Mantissa+0,x
.b592	60		rts				rts
.b593					EvaluateGetInteger:
.b593	ea		nop				nop
.b594	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b596	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.b598	95 80		sta $80,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.b59a	a9 00		lda #$00			lda 	#0
.b59c	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b59e	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b5a0	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b5a2	1a		inc a				inc 	a 							; set to type 1 (integer)
.b5a3	95 85		sta $85,x			sta 	XS_Type,x
.b5a5					_EVCheckNextInteger:
.b5a5	1b		inz				inz
.b5a6	ea		nop				nop
.b5a7	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b5a9	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.b5ab	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.b5ad	b0 0b		bcs $b5ba			bcs 	_EVEndInteger
.b5af	48		pha				pha 								; save it.
.b5b0	20 71 b5	jsr $b571			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.b5b3	68		pla				pla
.b5b4	15 80		ora $80,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.b5b6	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b5b8	80 eb		bra $b5a5			bra 	_EVCheckNextInteger
.b5ba					_EVEndInteger:
.b5ba	60		rts				rts
.b5bb					EVGetDecimal:
.b5bb	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.b5bd	8d 15 03	sta $0315			sta 	Num_Buffer
.b5c0	da		phx				phx
.b5c1	1b		inz				inz
.b5c2	ea		nop				nop
.b5c3	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b5c5	1b		inz				inz
.b5c6	3a		dec a				dec 	a								; convert to a string length.
.b5c7	3a		dec a				dec 	a
.b5c8	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.b5ca					_EVGDCopy:
.b5ca	48		pha				pha 									; save count
.b5cb	ea		nop				nop
.b5cc	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b5ce	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.b5d1	e8		inx				inx 									; forward ....
.b5d2	1b		inz				inz
.b5d3	68		pla				pla 									; get count
.b5d4	3a		dec a				dec 	a 								; until zero
.b5d5	d0 f3		bne $b5ca			bne 	_EVGDCopy
.b5d7	9d 15 03	sta $0315,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.b5da	fa		plx				plx 									; restore X
.b5db	a9 15		lda #$15			lda 	#Num_Buffer & $FF 				; set zGenPtr
.b5dd	85 1e		sta $1e				sta 	zGenPtr
.b5df	a9 03		lda #$03			lda 	#Num_Buffer >> 8
.b5e1	85 1f		sta $1f				sta 	zGenPtr+1
.b5e3	5a		phy				phy 									; save Y
.b5e4	a0 00		ldy #$00			ldy 	#0 								; start position
.b5e6	20 bf c7	jsr $c7bf			jsr 	FPFromString 					; convert current
.b5e9	7a		ply				ply 									; restore Y
.b5ea	60		rts				rts
.b5eb					NotInteger:
.b5eb	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.b5ed	49 ff		eor #$ff			eor 	#$FF
.b5ef	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b5f1	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b5f3	49 ff		eor #$ff			eor 	#$FF
.b5f5	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b5f7	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.b5f9	49 ff		eor #$ff			eor 	#$FF
.b5fb	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b5fd	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.b5ff	49 ff		eor #$ff			eor 	#$FF
.b601	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b603	60		rts				rts
.b604					EvaluateGetAtom:
.b604	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.b606					EvaluateGetAtomX:
.b606	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.b608	20 8c b4	jsr $b48c			jsr 	EvaluateExpressionXA
.b60b	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.b60d	29 0f		and #$0f			and 	#15
.b60f	c9 02		cmp #$02			cmp 	#2
.b611	b0 01		bcs $b614			bcs 	EvaluateType
.b613	60		rts				rts
.b614					EvaluateType:
.b614	4c c5 ad	jmp $adc5			jmp 	TypeError
.b617					EvaluateNumber:
.b617	a2 00		ldx #$00			ldx 	#0
.b619					EvaluateNumberX:
.b619	20 8a b4	jsr $b48a			jsr 	EvaluateExpressionX
.b61c	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0/1
.b61e	29 0f		and #$0f			and 	#15
.b620	c9 02		cmp #$02			cmp 	#2
.b622	b0 f0		bcs $b614			bcs 	EvaluateType
.b624	60		rts				rts
.b625					EvaluateInteger:
.b625	a2 00		ldx #$00			ldx 	#0
.b627					EvaluateIntegerX:
.b627	20 19 b6	jsr $b619			jsr 	EvaluateNumberX
.b62a	20 05 c6	jsr $c605			jsr 	FPUToInteger
.b62d	60		rts				rts
.b62e					EvaluateString:
.b62e	a2 00		ldx #$00			ldx 	#0
.b630					EvaluateStringX:
.b630	20 8a b4	jsr $b48a			jsr 	EvaluateExpressionX
.b633	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 2
.b635	29 0f		and #$0f			and 	#15
.b637	c9 02		cmp #$02			cmp 	#2
.b639	d0 d9		bne $b614			bne 	EvaluateType
.b63b	b5 80		lda $80,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.b63d	85 1e		sta $1e				sta 	zGenPtr
.b63f	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b641	85 1f		sta $1f				sta 	zGenPtr+1
.b643	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.b644					BinaryOp_And:
.b644	20 98 b6	jsr $b698			jsr 	BinaryMakeBothInteger
.b647	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.b649	35 86		and $86,x			and 	XS2_Mantissa+0,x
.b64b	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b64d	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.b64f	35 87		and $87,x			and 	XS2_Mantissa+1,x
.b651	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b653	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.b655	35 88		and $88,x			and 	XS2_Mantissa+2,x
.b657	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b659	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.b65b	35 89		and $89,x			and 	XS2_Mantissa+3,x
.b65d	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b65f	60		rts				rts
.b660					BinaryOp_Or:
.b660	20 98 b6	jsr $b698			jsr 	BinaryMakeBothInteger
.b663	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.b665	15 86		ora $86,x			ora 	XS2_Mantissa+0,x
.b667	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b669	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.b66b	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.b66d	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b66f	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.b671	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.b673	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b675	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.b677	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.b679	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b67b	60		rts				rts
.b67c					BinaryOp_Eor:
.b67c					BinaryOp_Xor:
.b67c	20 98 b6	jsr $b698			jsr 	BinaryMakeBothInteger
.b67f	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.b681	55 86		eor $86,x			eor 	XS2_Mantissa+0,x
.b683	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b685	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.b687	55 87		eor $87,x			eor 	XS2_Mantissa+1,x
.b689	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b68b	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.b68d	55 88		eor $88,x			eor 	XS2_Mantissa+2,x
.b68f	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b691	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.b693	55 89		eor $89,x			eor 	XS2_Mantissa+3,x
.b695	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b697	60		rts				rts
.b698					BinaryMakeBothInteger:
.b698	da		phx				phx 								; save X
.b699	e8		inx				inx
.b69a	e8		inx				inx
.b69b	e8		inx				inx
.b69c	e8		inx				inx
.b69d	e8		inx				inx
.b69e	e8		inx				inx
.b69f	20 a3 b6	jsr $b6a3			jsr 	BinaryMakeInteger 			; convert to integer.
.b6a2	fa		plx				plx 								; restore X and fall through.
.b6a3					BinaryMakeInteger:
.b6a3	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.b6a5	29 0f		and #$0f			and 	#15 						; check type zero
.b6a7	f0 04		beq $b6ad			beq 	_BMIConvert 				; if float convert to integer.
.b6a9	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.b6aa	90 04		bcc $b6b0			bcc 	_BMIError
.b6ac	60		rts				rts
.b6ad					_BMIConvert:
.b6ad	4c 05 c6	jmp $c605			jmp 	FPUToInteger 				; convert to integer
.b6b0					_BMIError:
.b6b0	4c c5 ad	jmp $adc5			jmp 	TypeError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.b6b3					Binary_Equal:
.b6b3	20 fa b6	jsr $b6fa			jsr 	CompareValues
.b6b6	09 00		ora #$00			ora 	#0
.b6b8	f0 04		beq $b6be			beq 	CCTrue
.b6ba	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.b6bc	80 02		bra $b6c0			bra 	CCWrite
.b6be	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.b6c0	95 80		sta $80,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.b6c2	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b6c4	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b6c6	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b6c8	a9 01		lda #$01			lda 	#1
.b6ca	95 85		sta $85,x			sta 	XS_Type,x 					; set type to integer whatever.
.b6cc	60		rts				rts
.b6cd					Binary_NotEqual:
.b6cd	20 fa b6	jsr $b6fa			jsr 	CompareValues
.b6d0	09 00		ora #$00			ora 	#0
.b6d2	f0 e6		beq $b6ba			beq 	CCFalse
.b6d4	80 e8		bra $b6be			bra 	CCTrue
.b6d6					Binary_Less:
.b6d6	20 fa b6	jsr $b6fa			jsr 	CompareValues
.b6d9	09 00		ora #$00			ora 	#0
.b6db	30 e1		bmi $b6be			bmi 	CCTrue
.b6dd	80 db		bra $b6ba			bra 	CCFalse
.b6df					Binary_LessEqual:
.b6df	20 fa b6	jsr $b6fa			jsr 	CompareValues
.b6e2	c9 01		cmp #$01			cmp 	#1
.b6e4	d0 d8		bne $b6be			bne 	CCTrue
.b6e6	80 d2		bra $b6ba			bra 	CCFalse
.b6e8					Binary_GreaterEqual:
.b6e8	20 fa b6	jsr $b6fa			jsr 	CompareValues
.b6eb	09 00		ora #$00			ora 	#0
.b6ed	10 cf		bpl $b6be			bpl 	CCTrue
.b6ef	80 c9		bra $b6ba			bra 	CCFalse
.b6f1					Binary_Greater:
.b6f1	20 fa b6	jsr $b6fa			jsr 	CompareValues
.b6f4	c9 01		cmp #$01			cmp 	#1
.b6f6	f0 c6		beq $b6be			beq 	CCTrue
.b6f8	80 c0		bra $b6ba			bra 	CCFalse
.b6fa					CompareValues:
.b6fa	b5 85		lda $85,x			lda 	XS_Type,x 					; and the types together
.b6fc	35 8b		and $8b,x			and 	XS2_Type,x
.b6fe	c9 02		cmp #$02			cmp 	#2
.b700	f0 11		beq $b713			beq 	_CVString
.b702	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b704	35 8b		and $8b,x			and 	XS2_Type,x
.b706	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b707	90 03		bcc $b70c			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b709	4c 55 b7	jmp $b755			jmp 	CompareInteger32 							; so execute code at \1
.b70c					_BCFloat:
.b70c	20 f9 b7	jsr $b7f9			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b70f	4c 3b c5	jmp $c53b			jmp 	FPCompare 							; and execute code at \2
.b712	60		rts				rts
.b713					_CVString:
.b713	da		phx				phx 								; save XY
.b714	5a		phy				phy
.b715	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.b717	85 1a		sta $1a				sta		zLTemp1+0
.b719	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b71b	85 1b		sta $1b				sta 	zLTemp1+1
.b71d	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.b71f	85 1c		sta $1c				sta 	zLTemp1+2
.b721	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.b723	85 1d		sta $1d				sta 	zLTemp1+3
.b725	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.b727	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b729	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.b72b	90 02		bcc $b72f			bcc 	_CVCommon
.b72d	b1 1c		lda ($1c),y			lda 	(zLTemp1+2),y
.b72f					_CVCommon:
.b72f	aa		tax				tax 								; put shorter string length in zero.
.b730	f0 0c		beq $b73e			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.b732					_CVCompare:
.b732	c8		iny				iny 								; next character
.b733	b1 1a		lda ($1a),y			lda 	(zLTemp1),y 				; compare characters
.b735	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.b737	90 13		bcc $b74c			bcc 	_CVReturnLess 				; <
.b739	d0 15		bne $b750			bne 	_CVReturnGreater 			; >
.b73b	ca		dex				dex 								; until common length matched.
.b73c	d0 f4		bne $b732			bne 	_CVCompare
.b73e					_CVMatch:
.b73e	a0 00		ldy #$00			ldy 	#0
.b740	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b742	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.b744	90 06		bcc $b74c			bcc 	_CVReturnLess 				; <
.b746	d0 08		bne $b750			bne 	_CVReturnGreater 			; >
.b748	a9 00		lda #$00			lda 	#0
.b74a	80 06		bra $b752			bra 	_CVExit 					; same common, same length, same string
.b74c					_CVReturnLess:
.b74c	a9 ff		lda #$ff			lda 	#$FF
.b74e	80 02		bra $b752			bra 	_CVExit
.b750					_CVReturnGreater:
.b750	a9 01		lda #$01			lda 	#$01
.b752					_CVExit:
.b752	7a		ply				ply
.b753	fa		plx				plx
.b754	60		rts				rts
.b755					CompareInteger32:
.b755	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.b757	49 80		eor #$80			eor 	#$80
.b759	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b75b	b5 89		lda $89,x			lda 	XS2_Mantissa+3,x
.b75d	49 80		eor #$80			eor 	#$80
.b75f	95 89		sta $89,x			sta 	XS2_Mantissa+3,x
.b761	20 df b7	jsr $b7df			jsr 	SubInteger32 				; subtraction
.b764	90 0d		bcc $b773			bcc 	_CI32Less 					; cc return -1
.b766	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check if zero
.b768	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.b76a	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.b76c	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.b76e	f0 02		beq $b772			beq 	_CI32Exit
.b770	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.b772					_CI32Exit:
.b772	60		rts				rts
.b773					_CI32Less:
.b773	a9 ff		lda #$ff			lda 	#$FF
.b775	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.b776					BinaryOp_Add:
.b776	b5 85		lda $85,x			lda 	XS_Type,x  					; and types together
.b778	35 8b		and $8b,x			and 	XS2_Type,x
.b77a	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.b77c	d0 11		bne $b78f			bne 	_BOAString
.b77e	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b780	35 8b		and $8b,x			and 	XS2_Type,x
.b782	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b783	90 03		bcc $b788			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b785	4c c5 b7	jmp $b7c5			jmp 	AddInteger32 							; so execute code at \1
.b788					_BCFloat:
.b788	20 f9 b7	jsr $b7f9			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b78b	4c 16 c3	jmp $c316			jmp 	FPAdd 							; and execute code at \2
.b78e	60		rts				rts
.b78f					_BOAString:
.b78f	4c 13 b8	jmp $b813			jmp 	ConcatenateString 			; concatenate two strings.
.b792					BinaryOp_Subtract:
.b792	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b794	35 8b		and $8b,x			and 	XS2_Type,x
.b796	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b797	90 03		bcc $b79c			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b799	4c df b7	jmp $b7df			jmp 	SubInteger32 							; so execute code at \1
.b79c					_BCFloat:
.b79c	20 f9 b7	jsr $b7f9			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b79f	4c 0e c3	jmp $c30e			jmp 	FPSubtract 							; and execute code at \2
.b7a2	60		rts				rts
.b7a3					BinaryOp_Multiply:
.b7a3	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b7a5	35 8b		and $8b,x			and 	XS2_Type,x
.b7a7	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b7a8	90 03		bcc $b7ad			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b7aa	4c eb c0	jmp $c0eb			jmp 	MulInteger32 							; so execute code at \1
.b7ad					_BCFloat:
.b7ad	20 f9 b7	jsr $b7f9			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b7b0	4c 3d c4	jmp $c43d			jmp 	FPMultiply 							; and execute code at \2
.b7b3	60		rts				rts
.b7b4					BinaryOp_Divide:
.b7b4	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b7b6	35 8b		and $8b,x			and 	XS2_Type,x
.b7b8	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b7b9	90 03		bcc $b7be			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b7bb	4c 29 c1	jmp $c129			jmp 	DivInteger32 							; so execute code at \1
.b7be					_BCFloat:
.b7be	20 f9 b7	jsr $b7f9			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b7c1	4c ca c3	jmp $c3ca			jmp 	FPDivide 							; and execute code at \2
.b7c4	60		rts				rts
.b7c5					AddInteger32:
.b7c5	18		clc				clc
.b7c6	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.b7c8	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.b7ca	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b7cc	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b7ce	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.b7d0	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b7d2	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.b7d4	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.b7d6	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b7d8	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.b7da	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.b7dc	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b7de	60		rts				rts
.b7df					SubInteger32:
.b7df	38		sec				sec
.b7e0	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.b7e2	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.b7e4	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b7e6	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b7e8	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.b7ea	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b7ec	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.b7ee	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.b7f0	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b7f2	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.b7f4	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.b7f6	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b7f8	60		rts				rts
.b7f9					BinaryMakeBothFloat:
.b7f9	da		phx				phx 								; save X
.b7fa	e8		inx				inx
.b7fb	e8		inx				inx
.b7fc	e8		inx				inx
.b7fd	e8		inx				inx
.b7fe	e8		inx				inx
.b7ff	e8		inx				inx
.b800	20 04 b8	jsr $b804			jsr 	BinaryMakeFloat 			; convert to float.
.b803	fa		plx				plx 								; restore X and fall through.
.b804					BinaryMakeFloat:
.b804	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.b806	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.b807	b0 04		bcs $b80d			bcs 	_BMFConvert
.b809	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.b80a	b0 04		bcs $b810			bcs 	_BMFError
.b80c	60		rts				rts
.b80d					_BMFConvert:
.b80d	4c b9 c5	jmp $c5b9			jmp 	FPUToFloat 					; convert to float
.b810					_BMFError:
.b810	4c c5 ad	jmp $adc5			jmp 	TypeError
.b813					ConcatenateString:
.b813	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.b815	85 1a		sta $1a				sta		zLTemp1+0
.b817	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b819	85 1b		sta $1b				sta 	zLTemp1+1
.b81b	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.b81d	85 1c		sta $1c				sta 	zLTemp1+2
.b81f	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.b821	85 1d		sta $1d				sta 	zLTemp1+3
.b823	5a		phy				phy
.b824	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.b826	b1 1a		lda ($1a),y			lda 	(zlTemp1),y
.b828	71 1c		adc ($1c),y			adc 	(zlTemp1+2),y
.b82a	7a		ply				ply
.b82b	b0 33		bcs $b860			bcs 	_CSError					; check in range.
.b82d	c9 fe		cmp #$fe			cmp 	#maxString+1
.b82f	b0 2f		bcs $b860			bcs 	_CSError
.b831	20 85 bc	jsr $bc85			jsr 	AllocateTempString 			; store the result
.b834	20 4b b8	jsr $b84b			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.b837	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.b839	85 1a		sta $1a				sta 	zLTemp1
.b83b	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.b83d	85 1b		sta $1b				sta 	zLTemp1+1
.b83f	20 4b b8	jsr $b84b			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.b842	a5 20		lda $20				lda 	zTempStr 					; point current to new string
.b844	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b846	a5 21		lda $21				lda 	zTempStr+1
.b848	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b84a	60		rts				rts
.b84b					_CSCopyString:
.b84b	da		phx				phx
.b84c	5a		phy				phy
.b84d	a0 00		ldy #$00			ldy 	#0 							; get length
.b84f	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b851	f0 0a		beq $b85d			beq 	_CSCSExit 					; if zero, exit
.b853	aa		tax				tax 								; put in X
.b854					_CSCSLoop:
.b854	c8		iny				iny 								; get next char
.b855	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b857	20 b0 bc	jsr $bcb0			jsr		WriteTempString 			; copy out
.b85a	ca		dex				dex 								; do whole string
.b85b	d0 f7		bne $b854			bne 	_CSCSLoop
.b85d					_CSCSExit:
.b85d	7a		ply				ply
.b85e	fa		plx				plx
.b85f	60		rts				rts
.b860					_CSError:
.b860	20 e4 ad	jsr $ade4			jsr ERR_Handler
>b863	53 74 72 69 6e 67 20 74			.text "String too long",0
>b86b	6f 6f 20 6c 6f 6e 67 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.b873					Unary_Sgn:
.b873	20 19 b6	jsr $b619			jsr 	EvaluateNumberX 			; get value
.b876	20 43 bc	jsr $bc43			jsr 	CheckNextRParen 			; check right bracket.
.b879	20 97 b8	jsr $b897			jsr 	GetSignCurrent 				; get sign.
.b87c	09 00		ora #$00			ora 	#0
.b87e	10 08		bpl $b888			bpl		UnarySetAInteger			; if 0,1 return that.
.b880	80 00		bra $b882			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.b882					UnarySetAMinus1:
.b882	a9 ff		lda #$ff			lda 	#$FF
.b884	95 80		sta $80,x			sta 	XS_Mantissa,x
.b886	80 04		bra $b88c			bra 	UnarySetAFill
.b888					UnarySetAInteger:
.b888	95 80		sta $80,x			sta 	XS_Mantissa,x
.b88a	a9 00		lda #$00			lda 	#0
.b88c					UnarySetAFill:
.b88c	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b88e	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b890	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b892	a9 01		lda #$01			lda 	#1
.b894	95 85		sta $85,x			sta 	XS_Type,x
.b896	60		rts				rts
.b897					GetSignCurrent:
.b897	b5 85		lda $85,x			lda 	XS_Type,x 					; identify type.
.b899	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.b89a	90 15		bcc $b8b1			bcc 	_GSCFloat
.b89c	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.b89e	30 0e		bmi $b8ae			bmi 	_GSCMinus1
.b8a0	15 80		ora $80,x			ora 	XS_Mantissa+0,x
.b8a2	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.b8a4	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.b8a6	d0 03		bne $b8ab			bne 	_GSCPlus1
.b8a8					_GSCZero:
.b8a8	a9 00		lda #$00			lda 	#0
.b8aa	60		rts				rts
.b8ab					_GSCPlus1:
.b8ab	a9 01		lda #$01			lda 	#$01
.b8ad	60		rts				rts
.b8ae					_GSCMinus1:
.b8ae	a9 ff		lda #$ff			lda 	#$FF
.b8b0	60		rts				rts
.b8b1					_GSCFloat:
.b8b1	34 85		bit $85,x			bit 	XS_Type,x
.b8b3	70 f3		bvs $b8a8			bvs 	_GSCZero
.b8b5	30 f7		bmi $b8ae			bmi 	_GSCMinus1
.b8b7	80 f2		bra $b8ab			bra 	_GSCPlus1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.b8b9					Unary_Abs:
.b8b9	20 19 b6	jsr $b619			jsr 	EvaluateNumberX 			; get value
.b8bc	20 43 bc	jsr $bc43			jsr 	CheckNextRParen 			; check right bracket.
.b8bf	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.b8c1	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.b8c3	f0 07		beq $b8cc			beq 	_UAMinusFloat
.b8c5	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; check MSB
.b8c7	10 09		bpl $b8d2			bpl 	_UAExit
.b8c9	4c b0 c1	jmp $c1b0			jmp 	IntegerNegateAlways 		; negation
.b8cc					_UAMinusFloat:
.b8cc	b5 85		lda $85,x			lda 	XS_Type,x 					; clear the sign bit.
.b8ce	29 7f		and #$7f			and		#$7F
.b8d0	95 85		sta $85,x			sta 	XS_Type,x
.b8d2					_UAExit:
.b8d2	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.b8d3					Unary_Peek:
.b8d3	a9 01		lda #$01			lda 	#1
.b8d5	80 06		bra $b8dd			bra 	UPMain
.b8d7					Unary_Deek:
.b8d7	a9 02		lda #$02			lda 	#2
.b8d9	80 02		bra $b8dd			bra 	UPMain
.b8db					Unary_Leek:
.b8db	a9 04		lda #$04			lda 	#4
.b8dd					UPMain:
.b8dd	48		pha				pha 								; set bytes to copy.
.b8de	20 27 b6	jsr $b627			jsr 	EvaluateIntegerX 			; numeric parameter
.b8e1	20 43 bc	jsr $bc43			jsr 	CheckNextRParen 			; right bracket.
.b8e4	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.b8e6	85 1a		sta $1a				sta 	zLTemp1
.b8e8	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b8ea	85 1b		sta $1b				sta 	zLTemp1+1
.b8ec	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.b8ee	85 1c		sta $1c				sta 	zLTemp1+2
.b8f0	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.b8f2	85 1d		sta $1d				sta 	zLTemp1+3
.b8f4	a9 00		lda #$00			lda 	#0 							; clear target area
.b8f6	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b8f8	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b8fa	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b8fc	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b8fe	68		pla				pla 								; restore bytes to copy
.b8ff	da		phx				phx 								; save XY
.b900	5a		phy				phy
.b901	20 ce bb	jsr $bbce			jsr 	MemRead 					; read the bytes in
.b904	7a		ply				ply 								; restore and exit
.b905	fa		plx				plx
.b906	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.b907					Unary_Mod:
.b907	20 2f b9	jsr $b92f			jsr 	_UMParameter 				; first parameter
.b90a	20 4c bc	jsr $bc4c			jsr 	CheckNextComma
.b90d	da		phx				phx 								; second parameter
.b90e	e8		inx				inx
.b90f	e8		inx				inx
.b910	e8		inx				inx
.b911	e8		inx				inx
.b912	e8		inx				inx
.b913	e8		inx				inx
.b914	20 2f b9	jsr $b92f			jsr 	_UMParameter
.b917	fa		plx				plx
.b918	20 43 bc	jsr $bc43			jsr 	CheckNextRParen
.b91b	20 29 c1	jsr $c129			jsr 	DivInteger32 				; divide
.b91e	a5 1a		lda $1a				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.b920	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b922	a5 1b		lda $1b				lda 	zLTemp1+1
.b924	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b926	a5 1c		lda $1c				lda 	zLTemp1+2
.b928	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b92a	a5 1d		lda $1d				lda 	zLTemp1+3
.b92c	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b92e	60		rts				rts
.b92f					_UMParameter:
.b92f	20 27 b6	jsr $b627			jsr 	EvaluateIntegerX 			; get value
.b932	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; absolute value
.b934	10 03		bpl $b939			bpl 	_UMNotSigned
.b936	20 b0 c1	jsr $c1b0			jsr 	IntegerNegateAlways
.b939					_UMNotSigned:
.b939	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.b93a					Unary_Usr:
.b93a	20 19 b6	jsr $b619			jsr 	EvaluateNumberX 			; numeric parameter
.b93d	20 43 bc	jsr $bc43			jsr 	CheckNextRParen 			; right bracket.
.b940	da		phx				phx 								; save XY
.b941	5a		phy				phy
.b942	ea		nop				nop
.b943	20 0c 03	jsr $030c			jsr 	UserVector 					; call the USR function.
.b946	7a		ply				ply 								; and exit
.b947	fa		plx				plx
.b948	60		rts				rts
.b949					USRDefault:
.b949	20 e4 ad	jsr $ade4			jsr ERR_Handler
>b94c	4e 6f 20 55 53 52 20 76			.text "No USR vector.",0
>b954	65 63 74 6f 72 2e 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.b95b					Unary_Val:
.b95b	20 30 b6	jsr $b630			jsr 	EvaluateStringX 			; get string
.b95e	20 43 bc	jsr $bc43			jsr 	CheckNextRParen 			; check right bracket.
.b961	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.b963	85 1e		sta $1e				sta 	zGenPtr
.b965	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b967	85 1f		sta $1f				sta 	zGenPtr+1
.b969	5a		phy				phy
.b96a	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.b96c	b1 1e		lda ($1e),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.b96e	f0 54		beq $b9c4			beq 	_UVBadNumber
.b970	48		pha				pha 								; save length.
.b971	1a		inc a				inc 	a 							; one for the length, one for the terminator
.b972	1a		inc a				inc 	a
.b973	20 85 bc	jsr $bc85			jsr 	AllocateTempString
.b976	c8		iny				iny 								; move to the next.
.b977	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get character
.b979	49 2d		eor #$2d			eor 	#"-"						; zero if minus sign
.b97b	8d a0 03	sta $03a0			sta 	ValSign
.b97e	d0 04		bne $b984			bne 	_UVNotMinus
.b980	c8		iny				iny 								; skip over it.
.b981	68		pla				pla 								; decrement character count.
.b982	3a		dec a				dec 	a
.b983	48		pha				pha
.b984					_UVNotMinus:
.b984	68		pla				pla 								; this is the count.
.b985	48		pha		_UVCopy:pha									; copy into new temp string which is ASCIIZ
.b986	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b988	c8		iny				iny
.b989	20 b0 bc	jsr $bcb0			jsr 	WriteTempString
.b98c	68		pla				pla
.b98d	3a		dec a				dec 	a
.b98e	d0 f5		bne $b985			bne 	_UVCopy
.b990	20 b0 bc	jsr $bcb0			jsr 	WriteTempString 			; make it ASCIIZ
.b993	18		clc				clc
.b994	a5 20		lda $20				lda 	zTempStr 					; tempstring +1 => genptr
.b996	69 01		adc #$01			adc 	#1
.b998	85 1e		sta $1e				sta 	zGenPtr
.b99a	a5 21		lda $21				lda 	zTempStr+1
.b99c	69 00		adc #$00			adc 	#0
.b99e	85 1f		sta $1f				sta 	zGenPtr+1
.b9a0	18		clc				clc
.b9a1	20 7e c2	jsr $c27e			jsr 	IntFromString 				; first bit.
.b9a4	b0 1e		bcs $b9c4			bcs 	_UVBadNumber
.b9a6	20 bf c7	jsr $c7bf			jsr 	FPFromString				; try for a float part.
.b9a9	ad a0 03	lda $03a0			lda 	ValSign 					; was it negative
.b9ac	d0 10		bne $b9be			bne 	_UVNotNegative
.b9ae	b5 85		lda $85,x			lda 	XS_Type,x 					; check if integer
.b9b0	4a		lsr a				lsr 	a
.b9b1	b0 08		bcs $b9bb			bcs 	_UVInteger
.b9b3	b5 85		lda $85,x			lda 	XS_Type,x 					; set sign bit
.b9b5	09 80		ora #$80			ora 	#$80
.b9b7	95 85		sta $85,x			sta 	XS_Type,x
.b9b9	80 03		bra $b9be			bra 	_UVNotNegative
.b9bb					_UVInteger:
.b9bb	20 b0 c1	jsr $c1b0			jsr 	IntegerNegateAlways 		; sign it.
.b9be					_UVNotNegative:
.b9be	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; used everything
.b9c0	d0 02		bne $b9c4			bne 	_UVBadNumber
.b9c2	7a		ply				ply
.b9c3	60		rts				rts
.b9c4					_UVBadNumber:
.b9c4	4c d3 ad	jmp $add3			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.b9c7					Unary_Str:
.b9c7	20 19 b6	jsr $b619			jsr 	EvaluateNumberX 			; numeric parameter
.b9ca	20 43 bc	jsr $bc43			jsr 	CheckNextRParen 			; right bracket.
.b9cd	a9 00		lda #$00			lda 	#0 							; reset buffer index
.b9cf	8d 14 03	sta $0314			sta 	NumBufX
.b9d2	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.b9d4	4a		lsr a				lsr 	a
.b9d5	b0 05		bcs $b9dc			bcs 	_USInt 						; if msb set do as integer
.b9d7	20 04 c7	jsr $c704			jsr 	FPToString 					; call fp to str otherwise
.b9da	80 03		bra $b9df			bra 	_USDuplicate
.b9dc	20 cd c1	jsr $c1cd	_USInt:	jsr 	IntToString
.b9df					_USDuplicate:
.b9df	ad 14 03	lda $0314			lda 	NumBufX 					; chars in buffer
.b9e2	1a		inc a				inc 	a 							; one more for length
.b9e3	20 85 bc	jsr $bc85			jsr 	AllocateTempString 			; allocate space for it.
.b9e6	5a		phy				phy 								; save Y
.b9e7	a0 00		ldy #$00			ldy 	#0 							; start copying
.b9e9	b9 15 03	lda $0315,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.b9ec	20 b0 bc	jsr $bcb0			jsr 	WriteTempString
.b9ef	c8		iny				iny
.b9f0	cc 14 03	cpy $0314			cpy 	NumBufX 					; done the lot
.b9f3	d0 f4		bne $b9e9			bne 	_USCopy
.b9f5	7a		ply				ply 								; restore Y
.b9f6	4c c1 bb	jmp $bbc1			jmp 	UnaryReturnTempStr 			; return new temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.b9f9					Unary_Asc:
.b9f9	20 30 b6	jsr $b630			jsr 	EvaluateStringX 			; string parameter
.b9fc	20 43 bc	jsr $bc43			jsr 	CheckNextRParen 			; right bracket.
.b9ff	5a		phy				phy 								; get the string length
.ba00	a0 00		ldy #$00			ldy 	#0
.ba02	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.ba04	f0 07		beq $ba0d			beq 	_UAIllegal 					; must be at least one character
.ba06	c8		iny				iny
.ba07	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; read it.
.ba09	7a		ply				ply
.ba0a	4c 88 b8	jmp $b888			jmp 	UnarySetAInteger
.ba0d					_UAIllegal:
.ba0d	4c d3 ad	jmp $add3			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.ba10					Unary_Len:
.ba10	20 30 b6	jsr $b630			jsr 	EvaluateStringX 			; string parameter
.ba13	20 43 bc	jsr $bc43			jsr 	CheckNextRParen 			; right bracket.
.ba16	5a		phy				phy 								; get the string length
.ba17	a0 00		ldy #$00			ldy 	#0
.ba19	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.ba1b	7a		ply				ply
.ba1c	4c 88 b8	jmp $b888			jmp 	UnarySetAInteger

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.ba1f					Unary_Mid:
.ba1f	20 30 b6	jsr $b630			jsr 	EvaluateStringX 				; get string.
.ba22	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.ba24	48		pha				pha
.ba25	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.ba27	48		pha				pha
.ba28	20 4c bc	jsr $bc4c			jsr 	CheckNextComma 					; skip comma
.ba2b	20 b4 ba	jsr $bab4			jsr 	SLIByteParameter 				; get a byte parameter (start)
.ba2e	48		pha				pha 									; and push it.
.ba2f	20 4c bc	jsr $bc4c			jsr 	CheckNextComma 					; skip comma
.ba32	20 b4 ba	jsr $bab4			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.ba35	48		pha				pha 									; and push it.
.ba36	80 41		bra $ba79			bra 	SLIProcess
.ba38					Unary_Left:
.ba38	20 30 b6	jsr $b630			jsr 	EvaluateStringX 				; get string.
.ba3b	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.ba3d	48		pha				pha
.ba3e	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.ba40	48		pha				pha
.ba41	a9 01		lda #$01			lda 	#1 								; push start position (1)
.ba43	48		pha				pha
.ba44	20 4c bc	jsr $bc4c			jsr 	CheckNextComma 					; skip comma
.ba47	20 b4 ba	jsr $bab4			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.ba4a	48		pha				pha 									; and push it.
.ba4b	80 2c		bra $ba79			bra 	SLIProcess
.ba4d					Unary_Right:
.ba4d	20 30 b6	jsr $b630			jsr 	EvaluateStringX 				; get string.
.ba50	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.ba52	48		pha				pha
.ba53	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.ba55	48		pha				pha
.ba56	da		phx				phx 									; get the string length and push on stack.
.ba57	a2 00		ldx #$00			ldx 	#0
.ba59	a1 1e		lda ($1e,x)			lda		(zGenPtr,x)
.ba5b	fa		plx				plx
.ba5c	48		pha				pha
.ba5d	20 4c bc	jsr $bc4c			jsr 	CheckNextComma 					; skip comma
.ba60	20 b4 ba	jsr $bab4			jsr 	SLIByteParameter 				; get a byte parameter.
.ba63	8d 9e 03	sta $039e			sta 	SignCount 						; save in temporary.
.ba66	68		pla				pla 									; restore string length.
.ba67	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.ba68	38		sec				sec
.ba69	ed 9e 03	sbc $039e			sbc 	SignCount 						; subtract characters needed, gives start position.
.ba6c	f0 02		beq $ba70			beq 	_URStart 						; if <= 0 start from 1.
.ba6e	10 02		bpl $ba72			bpl 	_UROkay
.ba70					_URStart:
.ba70	a9 01		lda #$01			lda 	#1
.ba72					_UROkay:
.ba72	48		pha				pha 									; push start
.ba73	ad 9e 03	lda $039e			lda 	SignCount 						; push count of characters
.ba76	48		pha				pha
.ba77	80 00		bra $ba79			bra 	SLIProcess
.ba79					SLIProcess:
.ba79	20 43 bc	jsr $bc43			jsr 	CheckNextRParen 				; closing right bracket.
.ba7c	68		pla				pla
.ba7d	8d a2 03	sta $03a2			sta 	SliceCount 						; count in signcount
.ba80	1a		inc a				inc 	a 								; allocate +1 for it.
.ba81	20 85 bc	jsr $bc85			jsr 	AllocateTempString
.ba84	68		pla				pla 									; pop start number off stack.
.ba85	f0 3b		beq $bac2			beq 	SLIError 						; exit if start = 0
.ba87	8d a1 03	sta $03a1			sta 	SliceStart
.ba8a	68		pla				pla  									; pop string address.
.ba8b	85 1f		sta $1f				sta 	zGenPtr+1
.ba8d	68		pla				pla
.ba8e	85 1e		sta $1e				sta 	zGenPtr
.ba90	da		phx				phx
.ba91	5a		phy				phy
.ba92	a2 00		ldx #$00			ldx 	#0 								; point to string length.
.ba94	ac a1 03	ldy $03a1			ldy 	SliceStart 						; start of the string (+1 for count)
.ba97					_SLICopy:
.ba97	ad a2 03	lda $03a2			lda 	SliceCount 						; done count characters
.ba9a	f0 12		beq $baae			beq 	_SLIExit
.ba9c	ce a2 03	dec $03a2			dec 	SliceCount
.ba9f	98		tya				tya 									; index of character
.baa0	c1 1e		cmp ($1e,x)			cmp 	(zGenPtr,x)						; compare against length
.baa2	f0 02		beq $baa6			beq 	_SLIOk 							; if equal, okay.
.baa4	b0 08		bcs $baae			bcs 	_SLIExit 						; if past end, then exit.
.baa6	b1 1e		lda ($1e),y	_SLIOk:	lda 	(zGenPtr),y 					; copy one character
.baa8	c8		iny				iny
.baa9	20 b0 bc	jsr $bcb0			jsr 	WriteTempString
.baac	80 e9		bra $ba97			bra 	_SLICopy 						; go round till copied characters
.baae					_SLIExit:
.baae	7a		ply				ply 									; restore YX
.baaf	fa		plx				plx
.bab0	4c c1 bb	jmp $bbc1			jmp 	UnaryReturnTempStr 				; return new temporary string.
.bab3	ea		nop				nop
.bab4					SLIByteParameter:
.bab4	20 27 b6	jsr $b627			jsr 	EvaluateIntegerX 				; get integer
.bab7	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.bab9	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.babb	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.babd	d0 03		bne $bac2			bne 	SLIError
.babf	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.bac1	60		rts				rts
.bac2					SLIError:
.bac2	4c d3 ad	jmp $add3			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.bac5					Unary_Hex:
.bac5	20 27 b6	jsr $b627			jsr 	EvaluateIntegerX 			; numeric parameter
.bac8	20 43 bc	jsr $bc43			jsr 	CheckNextRParen 			; right bracket.
.bacb	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.bacd	20 85 bc	jsr $bc85			jsr 	AllocateTempString			; allocate string space
.bad0	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.bad2	20 f6 ba	jsr $baf6			jsr 	_UHConvert
.bad5	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.bad7	20 f6 ba	jsr $baf6			jsr 	_UHConvert
.bada	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.badc	20 f6 ba	jsr $baf6			jsr 	_UHConvert
.badf	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.bae1	20 f6 ba	jsr $baf6			jsr 	_UHConvert
.bae4	5a		phy				phy 								; get length of new string
.bae5	a0 00		ldy #$00			ldy 	#0
.bae7	b1 20		lda ($20),y			lda 	(zTempStr),y
.bae9	7a		ply				ply
.baea	c9 00		cmp #$00			cmp 	#0
.baec	d0 05		bne $baf3			bne 	_UHExit 					; if it was non zero okay
.baee	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.baf0	20 b0 bc	jsr $bcb0			jsr 	WriteTempString
.baf3					_UHExit:
.baf3	4c c1 bb	jmp $bbc1			jmp 	UnaryReturnTempStr 			; return new temporary string.
.baf6					_UHConvert:
.baf6	48		pha				pha
.baf7	4a		lsr a				lsr 	a 							; do MSB
.baf8	4a		lsr a				lsr 	a
.baf9	4a		lsr a				lsr 	a
.bafa	4a		lsr a				lsr 	a
.bafb	20 ff ba	jsr $baff			jsr 	_UHNibble
.bafe	68		pla				pla 								; do LSB
.baff					_UHNibble:
.baff	29 0f		and #$0f			and 	#15 						; get nibble
.bb01	d0 0c		bne $bb0f			bne 	_UHNonZero
.bb03	5a		phy				phy									; get the length
.bb04	a0 00		ldy #$00			ldy 	#0
.bb06	b1 20		lda ($20),y			lda 	(zTempStr),y
.bb08	7a		ply				ply
.bb09	c9 00		cmp #$00			cmp 	#0 							; suppress leading zeros.
.bb0b	f0 0d		beq $bb1a			beq 	_UHExit2
.bb0d	a9 00		lda #$00			lda 	#0
.bb0f					_UHNonZero:
.bb0f	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.bb11	90 02		bcc $bb15			bcc 	_UHDigit
.bb13	69 06		adc #$06			adc 	#7-1
.bb15					_UHDigit:
.bb15	69 30		adc #$30			adc 	#48
.bb17	20 b0 bc	jsr $bcb0			jsr 	WriteTempString				; output.
.bb1a					_UHExit2:
.bb1a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.bb1b					Unary_Dec:
.bb1b	20 30 b6	jsr $b630			jsr 	EvaluateStringX 			; string parameter
.bb1e	20 43 bc	jsr $bc43			jsr 	CheckNextRParen 			; right bracket.
.bb21	5a		phy				phy
.bb22	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.bb24	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.bb26	f0 41		beq $bb69			beq 	_UDFail 					; must fail if zero.
.bb28	8d 9e 03	sta $039e			sta 	SignCount 					; use SignCount as a counter
.bb2b	a9 00		lda #$00			lda 	#0 							; set result to zero integer.
.bb2d	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.bb2f	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bb31	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.bb33	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.bb35	a9 01		lda #$01			lda 	#1
.bb37	95 85		sta $85,x			sta 	XS_Type,x
.bb39					_UDConvertLoop:
.bb39	5a		phy				phy 								; shift mantissa left 4
.bb3a	a0 04		ldy #$04			ldy 	#4
.bb3c					_UDShift:
.bb3c	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.bb3e	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.bb40	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.bb42	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.bb44	88		dey				dey
.bb45	d0 f5		bne $bb3c			bne 	_UDShift
.bb47	7a		ply				ply
.bb48	c8		iny				iny 								; next character
.bb49	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; fetch it.
.bb4b	20 6c bb	jsr $bb6c			jsr 	ConvertUpper 				; convert to U/C
.bb4e	c9 30		cmp #$30			cmp 	#"0"
.bb50	90 17		bcc $bb69			bcc 	_UDFail
.bb52	c9 3a		cmp #$3a			cmp 	#"9"+1
.bb54	90 06		bcc $bb5c			bcc 	_UDOkay
.bb56	e9 37		sbc #$37			sbc 	#7+"0" 						; alpha fudge
.bb58	c9 10		cmp #$10			cmp 	#16
.bb5a	b0 0d		bcs $bb69			bcs 	_UDFail
.bb5c					_UDOkay:
.bb5c	29 0f		and #$0f			and 	#15 						; nibble only
.bb5e	15 80		ora $80,x			ora 	XS_Mantissa+0,x
.bb60	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.bb62	ce 9e 03	dec $039e			dec 	SignCount 					; do it for each character
.bb65	d0 d2		bne $bb39			bne 	_UDConvertLoop
.bb67	7a		ply				ply
.bb68	60		rts				rts
.bb69					_UDFail:
.bb69	4c d3 ad	jmp $add3			jmp 	BadParamError
.bb6c					ConvertUpper:
.bb6c	c9 61		cmp #$61			cmp 	#"a"
.bb6e	90 07		bcc $bb77			bcc 	_CUExit
.bb70	c9 7b		cmp #$7b			cmp 	#"z"+1
.bb72	b0 03		bcs $bb77			bcs 	_CUExit
.bb74	38		sec				sec
.bb75	e9 20		sbc #$20			sbc 	#32
.bb77	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.bb78					Unary_Chr:
.bb78	20 27 b6	jsr $b627			jsr 	EvaluateIntegerX			; numeric parameter
.bb7b	20 43 bc	jsr $bc43			jsr 	CheckNextRParen 			; right bracket.
.bb7e	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.bb80	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.bb82	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.bb84	d0 0d		bne $bb93			bne 	_UCChar
.bb86	a9 01		lda #$01			lda 	#1 							; one character string
.bb88	20 85 bc	jsr $bc85			jsr 	AllocateTempString
.bb8b	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.bb8d	20 b0 bc	jsr $bcb0			jsr 	WriteTempString
.bb90	4c c1 bb	jmp $bbc1			jmp 	UnaryReturnTempStr
.bb93					_UCChar:
.bb93	4c d3 ad	jmp $add3			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.bb96					Unary_Spc:
.bb96	20 27 b6	jsr $b627			jsr 	EvaluateIntegerX 			; numeric parameter
.bb99	20 43 bc	jsr $bc43			jsr 	CheckNextRParen 			; right bracket.
.bb9c	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.bb9e	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.bba0	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.bba2	d0 1a		bne $bbbe			bne 	_USSize
.bba4	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.bba6	c9 fe		cmp #$fe			cmp 	#maxString+1
.bba8	b0 14		bcs $bbbe			bcs 	_USSize
.bbaa	48		pha				pha 								; save length
.bbab	1a		inc a				inc 	a 							; allocate one more.
.bbac	20 85 bc	jsr $bc85			jsr 	AllocateTempString
.bbaf	68		pla				pla 								; get length
.bbb0	f0 0f		beq $bbc1			beq 	UnaryReturnTempStr 			; return the current temp string
.bbb2					_USLoop:
.bbb2	48		pha				pha
.bbb3	a9 20		lda #$20			lda 	#" "
.bbb5	20 b0 bc	jsr $bcb0			jsr 	WriteTempString
.bbb8	68		pla				pla
.bbb9	3a		dec a				dec 	a
.bbba	d0 f6		bne $bbb2			bne 	_USLoop
.bbbc	80 03		bra $bbc1			bra 	UnaryReturnTempStr
.bbbe					_USSize:
.bbbe	4c d3 ad	jmp $add3			jmp 	BadParamError
.bbc1					UnaryReturnTempStr:
.bbc1	a5 20		lda $20				lda 	zTempStr 					; copy temp string addr -> mantissa
.bbc3	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.bbc5	a5 21		lda $21				lda 	zTempStr+1
.bbc7	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bbc9	a9 02		lda #$02			lda 	#2 							; set type to string
.bbcb	95 85		sta $85,x			sta 	XS_Type,x
.bbcd	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/4510.asm

.bbce	db		phz		MemRead:phz
.bbcf	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.bbd2	a3 00		ldz #$00			ldz 	#0 							; start from here
.bbd4	ea		nop		_MLoop1:nop
.bbd5	b2 1a		lda ($1a),z			lda 	(zlTemp1),z 				; read the long address
.bbd7	95 80		sta $80,x			sta 	XS_Mantissa,x 				; copy into mantissa
.bbd9	1b		inz				inz 								; next to copy
.bbda	e8		inx				inx
.bbdb	dc 9e 03	cpz $039e			cpz 	SignCount 					; do required # of bytes.
.bbde	d0 f4		bne $bbd4			bne 	_MLoop1
.bbe0	fb		plz				plz
.bbe1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/programend.asm

.bbe2					UpdateProgramEnd:
.bbe2	a9 00		lda #$00			lda 	#BasicProgram & $FF
.bbe4	85 16		sta $16				sta 	zCodePtr+0
.bbe6	a9 80		lda #$80			lda 	#BasicProgram >> 8
.bbe8	85 17		sta $17				sta 	zCodePtr+1
.bbea	a9 02		lda #$02			lda 	#2
.bbec	85 18		sta $18				sta 	zCodePtr+2
.bbee	a9 00		lda #$00			lda 	#0
.bbf0	85 19		sta $19				sta 	zCodePtr+3
.bbf2	a3 03		ldz #$03			ldz 	#3
.bbf4					_UPDLoop:
.bbf4	a3 00		ldz #$00			ldz 	#0
.bbf6	ea		nop				nop
.bbf7	b2 16		lda ($16),z			lda 	(zCodePtr),z
.bbf9	c9 00		cmp #$00			cmp 	#0 							; end if offset is zero.
.bbfb	f0 10		beq $bc0d			beq 	_UPDFoundEnd
.bbfd	a3 00		ldz #$00			ldz 	#0 							; point to offset
.bbff	ea		nop				nop
.bc00	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read it
.bc02	18		clc				clc
.bc03	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.bc05	85 16		sta $16				sta 	zCodePtr
.bc07	90 02		bcc $bc0b			bcc 	_SNLNoCarry
.bc09	e6 17		inc $17				inc 	zCodePtr+1
.bc0b					_SNLNoCarry:
.bc0b	80 e7		bra $bbf4			bra 	_UPDLoop
.bc0d					_UPDFoundEnd:
.bc0d	18		clc				clc 								; end of program 2 on.
.bc0e	a5 16		lda $16				lda 	zCodePtr
.bc10	69 02		adc #$02			adc 	#2
.bc12	8d 04 03	sta $0304			sta 	endOfProgram
.bc15	a5 17		lda $17				lda 	zCodePtr+1
.bc17	69 00		adc #$00			adc 	#0
.bc19	8d 05 03	sta $0305			sta 	endOfProgram+1
.bc1c	a5 18		lda $18				lda 	zCodePtr+2
.bc1e	69 00		adc #$00			adc		#0
.bc20	8d 06 03	sta $0306			sta 	endOfProgram+2
.bc23	a5 19		lda $19				lda 	zCodePtr+3
.bc25	69 00		adc #$00			adc 	#0
.bc27	8d 07 03	sta $0307			sta 	endOfProgram+3
.bc2a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.bc2b					CheckNextToken:
.bc2b	ea		nop				nop
.bc2c	d2 16		cmp ($16),z			cmp 	(zCodePtr),z
.bc2e	d0 02		bne $bc32			bne 	CTFail 						; no, then fail
.bc30	1b		inz				inz
.bc31	60		rts				rts
.bc32					CTFail:
.bc32	20 e4 ad	jsr $ade4			jsr ERR_Handler
>bc35	4d 69 73 73 69 6e 67 20			.text "Missing token",0
>bc3d	74 6f 6b 65 6e 00
.bc43					CheckNextRParen:
.bc43	ea		nop				nop
.bc44	b2 16		lda ($16),z			lda 	(zCodePtr),z
.bc46	c9 be		cmp #$be			cmp 	#token_rparen
.bc48	d0 e8		bne $bc32			bne 	CTFail
.bc4a	1b		inz				inz
.bc4b	60		rts				rts
.bc4c					CheckNextComma:
.bc4c	ea		nop				nop
.bc4d	b2 16		lda ($16),z			lda 	(zCodePtr),z
.bc4f	c9 bf		cmp #$bf			cmp 	#token_comma
.bc51	d0 df		bne $bc32			bne 	CTFail
.bc53	1b		inz				inz
.bc54	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/concrete.asm

.bc55					StringConcrete:
.bc55	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; save source to zTemp1
.bc57	85 10		sta $10				sta 	zTemp1
.bc59	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bc5b	85 11		sta $11				sta 	zTemp1+1
.bc5d	a0 00		ldy #$00			ldy 	#0 							; subtract the length+1 (clc) of the string.
.bc5f	18		clc				clc 								; from the string pointer
.bc60	ad 00 03	lda $0300			lda 	StringPtr 					; and put in zTemp2 as well
.bc63	f1 10		sbc ($10),y			sbc 	(zTemp1),y
.bc65	8d 00 03	sta $0300			sta 	StringPtr
.bc68	85 12		sta $12				sta 	zTemp2
.bc6a	ad 01 03	lda $0301			lda 	StringPtr+1
.bc6d	e9 00		sbc #$00			sbc 	#0
.bc6f	8d 01 03	sta $0301			sta 	StringPtr+1
.bc72	85 13		sta $13				sta 	zTemp2+1
.bc74	b1 10		lda ($10),y			lda 	(zTemp1),y 					; length add one for count
.bc76	1a		inc a				inc 	a
.bc77	aa		tax				tax
.bc78	b1 10		lda ($10),y	_SCCopy:lda 	(zTemp1),y 					; copy whole thing including length
.bc7a	91 12		sta ($12),y			sta 	(zTemp2),y
.bc7c	c8		iny				iny
.bc7d	ca		dex				dex
.bc7e	d0 f8		bne $bc78			bne 	_SCCopy
.bc80	a5 13		lda $13				lda 	zTemp2+1 					; return concrete string in AX
.bc82	a6 12		ldx $12				ldx 	zTemp2
.bc84	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.bc85					AllocateTempString:
.bc85	48		pha				pha 								; save required count.
.bc86	a5 21		lda $21				lda 	zTempStr+1 					; check if initialised yet ?
.bc88	d0 0b		bne $bc95			bne 	_ATSInitialised
.bc8a	ad 00 03	lda $0300			lda 	StringPtr 					; set temporary string ptr 1 page below available
.bc8d	85 20		sta $20				sta 	zTempStr					; space, this is for strings to be concreted.
.bc8f	ad 01 03	lda $0301			lda 	StringPtr+1
.bc92	3a		dec a				dec 	a
.bc93	85 21		sta $21				sta 	zTempStr+1
.bc95					_ATSInitialised:
.bc95	68		pla				pla 								; get required count back.
.bc96	49 ff		eor #$ff			eor 	#$FF 						; negate 2's complement.
.bc98	1a		inc a				inc 	a
.bc99	18		clc				clc
.bc9a	65 20		adc $20				adc 	zTempStr 					; "add" to the temp string pointer
.bc9c	85 20		sta $20				sta 	zTempStr
.bc9e	a9 ff		lda #$ff			lda 	#$FF
.bca0	65 21		adc $21				adc 	zTempStr+1
.bca2	85 21		sta $21				sta 	zTempStr+1
.bca4	a9 00		lda #$00			lda 	#0 							; clear temp string.
.bca6	5a		phy				phy
.bca7	a8		tay				tay
.bca8	91 20		sta ($20),y			sta 	(zTempStr),y
.bcaa	7a		ply				ply
.bcab	1a		inc a				inc 	a 							; reset the write index.
.bcac	8d 9f 03	sta $039f			sta 	TempStringWriteIndex
.bcaf	60		rts				rts
.bcb0					WriteTempString:
.bcb0	5a		phy				phy 								; save Y
.bcb1	ac 9f 03	ldy $039f			ldy 	TempStringWriteIndex	 	; write position.
.bcb4	91 20		sta ($20),y			sta 	(zTempStr),y 				; write character out.
.bcb6	ee 9f 03	inc $039f			inc 	TempStringWriteIndex 		; increment the write position.
.bcb9	98		tya				tya 								; unchanged Y is now length
.bcba	a0 00		ldy #$00			ldy 	#0
.bcbc	91 20		sta ($20),y			sta 	(zTempStr),y
.bcbe	7a		ply				ply 								; restore Y and exit
.bcbf	60		rts				rts
.bcc0					CreateTempStringCopy:
.bcc0	da		phx				phx 								; save X
.bcc1	ea		nop				nop
.bcc2	b2 16		lda ($16),z			lda 	(zCodePtr),z
.bcc4	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.bcc5	20 85 bc	jsr $bc85			jsr 	AllocateTempString 			; allocate memory for temporary string.
.bcc8	ea		nop				nop
.bcc9	b2 16		lda ($16),z			lda 	(zCodePtr),z
.bccb	1b		inz				inz
.bccc	3a		dec a				dec 	a 							; make the actual length in charactes
.bccd	3a		dec a				dec 	a
.bcce	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.bcd0	81 20		sta ($20,x)			sta 	(zTempStr,x)
.bcd2	85 1a		sta $1a				sta 	zLTemp1 					; that's used as a count.
.bcd4	09 00		ora #$00			ora 	#0 							; if zero already, exit
.bcd6	f0 0f		beq $bce7			beq 	_CTSCExit
.bcd8					_CTSCLoop:
.bcd8	ea		nop				nop
.bcd9	b2 16		lda ($16),z			lda 	(zCodePtr),z
.bcdb	1b		inz				inz
.bcdc	5a		phy				phy 								; save in Y
.bcdd	e8		inx				inx 								; bump index
.bcde	da		phx				phx 								; index into Y
.bcdf	7a		ply				ply
.bce0	91 20		sta ($20),y			sta 	(zTempStr),y 				; save at index
.bce2	7a		ply				ply 								; restore Y
.bce3	c6 1a		dec $1a				dec 	zLTemp1 					; do for each character
.bce5	d0 f1		bne $bcd8			bne 	_CTSCLoop
.bce7					_CTSCExit:
.bce7	fa		plx				plx 								; restore X
.bce8	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/variables.asm

.bce9					VariableFind:
.bce9	20 54 bd	jsr $bd54			jsr 	VariableExtract 		; find out all about it ....
.bcec	20 ef bf	jsr $bfef			jsr 	VariableLocate 			; does it already exist ?
.bcef	b0 03		bcs $bcf4			bcs 	_VFExists 				; if so, use that.
.bcf1	20 e2 bd	jsr $bde2			jsr 	VariableCreate 			; otherwise create it.
.bcf4					_VFExists:
.bcf4	a5 24		lda $24				lda 	zVarType 				; is it still an array ?
.bcf6	29 01		and #$01			and 	#1
.bcf8	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.bcfa	d0 28		bne $bd24			bne 	_VFSingleElement
.bcfc					_VFNextIndex:
.bcfc	a5 22		lda $22				lda 	zVarDataPtr 			; push the data ptr and type on the stack.
.bcfe	48		pha				pha
.bcff	a5 23		lda $23				lda 	zVarDataPtr+1
.bd01	48		pha				pha
.bd02	a5 24		lda $24				lda 	zVarType
.bd04	48		pha				pha
.bd05	20 27 b6	jsr $b627			jsr 	EvaluateIntegerX 		; calculate the index.
.bd08	68		pla				pla 							; restore and index.
.bd09	85 24		sta $24				sta 	zVarType
.bd0b	68		pla				pla
.bd0c	85 23		sta $23				sta 	zVarDataPtr+1
.bd0e	68		pla				pla
.bd0f	85 22		sta $22				sta 	zVarDataPtr
.bd11	20 6d be	jsr $be6d			jsr 	ArrayIndexFollow 		; do the index.
.bd14	a5 24		lda $24				lda 	zVarType 				; is it still an array ??
.bd16	29 01		and #$01			and 	#1
.bd18	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.bd1a	d0 05		bne $bd21			bne 	_VFArrayDone 			; if so then exit.
.bd1c	20 4c bc	jsr $bc4c			jsr 	CheckNextComma 			; comma should follow
.bd1f	80 db		bra $bcfc			bra 	_VFNextIndex
.bd21					_VFArrayDone:
.bd21	20 43 bc	jsr $bc43			jsr 	CheckNextRParen 		; check closing right bracket.
.bd24					_VFSingleElement:
.bd24	60		rts				rts
.bd25					VariableClear:
.bd25	48		pha				pha 							; save registers
.bd26	da		phx				phx
.bd27	a2 00		ldx #$00			ldx 	#0 						; clear out the hash table.
.bd29	8a		txa				txa
.bd2a	9d 35 03	sta $0335,x	_VCLoop:sta 	HashTableBase,x
.bd2d	e8		inx				inx
.bd2e	e0 60		cpx #$60			cpx 	#HashTableEnd-HashTableBase
.bd30	d0 f8		bne $bd2a			bne 	_VCLoop
.bd32	a9 00		lda #$00			lda 	#VariableMemory & $FF
.bd34	8d 02 03	sta $0302			sta 	VarMemPtr
.bd37	a9 20		lda #$20			lda 	#VariableMemory >> 8
.bd39	8d 03 03	sta $0303			sta 	VarMemPtr+1
.bd3c	fa		plx				plx 							; restore registers
.bd3d	68		pla				pla
.bd3e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/extract.asm

.bd3f					VariableNameError:
.bd3f	20 e4 ad	jsr $ade4			jsr ERR_Handler
>bd42	42 61 64 20 56 61 72 69			.text "Bad Variable Name",0
>bd4a	61 62 6c 65 20 4e 61 6d 65 00
.bd54					VariableExtract:
.bd54	da		phx				phx 							; save X.
.bd55	a9 ba		lda #$ba			lda 	#token_hashlParen  		; set the type to #( e.g. real array.
.bd57	8d 95 03	sta $0395			sta 	Var_Type
.bd5a	8d 96 03	sta $0396			sta 	Var_Hash 				; we initialise the hash with this. It doesn't matter
.bd5d	ea		nop				nop
.bd5e	b2 16		lda ($16),z			lda 	(zCodePtr),z
.bd60	c9 00		cmp #$00			cmp 	#0 						; first one must be A-Z
.bd62	f0 db		beq $bd3f			beq 	VariableNameError
.bd64	c9 1b		cmp #$1b			cmp 	#26+1
.bd66	b0 d7		bcs $bd3f			bcs 	VariableNameError
.bd68	a2 ff		ldx #$ff			ldx 	#255 					; now copy it into the variable buffer.
.bd6a					_VECopyBuffer:
.bd6a	e8		inx				inx
.bd6b	e0 1f		cpx #$1f			cpx 	#31 					; too long
.bd6d	f0 d0		beq $bd3f			beq 	VariableNameError
.bd6f	9d 15 03	sta $0315,x			sta 	Var_Buffer,x 			; save character
.bd72	18		clc				clc  							; update the hash value for it.
.bd73	6d 96 03	adc $0396			adc 	Var_Hash
.bd76	8d 96 03	sta $0396			sta 	Var_Hash
.bd79	1b		inz				inz
.bd7a	ea		nop				nop
.bd7b	b2 16		lda ($16),z			lda 	(zCodePtr),z
.bd7d	c9 00		cmp #$00			cmp 	#0 						; zero or token, end of variable
.bd7f	f0 0e		beq $bd8f			beq 	_VECopyEnd
.bd81	30 0c		bmi $bd8f			bmi 	_VECopyEnd
.bd83	c9 1b		cmp #$1b			cmp 	#26+1 					; A-Z continue copying
.bd85	90 e3		bcc $bd6a			bcc 	_VECopyBuffer
.bd87	c9 30		cmp #$30			cmp 	#"0" 					; 0-9 copy as well.
.bd89	90 04		bcc $bd8f			bcc 	_VECopyEnd
.bd8b	c9 3a		cmp #$3a			cmp 	#"9"+1
.bd8d	90 db		bcc $bd6a			bcc 	_VECopyBuffer
.bd8f					_VECopyEnd:
.bd8f	1b		inz				inz
.bd90	c9 b7		cmp #$b7			cmp 	#token_Dollar 			; first type token.
.bd92	90 04		bcc $bd98			bcc 	_VEDefaultRequired
.bd94	c9 bd		cmp #$bd			cmp 	#token_PercentLParen+1	; last type token.
.bd96	90 0b		bcc $bda3			bcc 	_VEHaveType
.bd98					_VEDefaultRequired:
.bd98	c9 bd		cmp #$bd			cmp 	#token_LParen 			; if it ends in ( then use the real array
.bd9a	f0 04		beq $bda0			beq 	_VESetType 				; default set above.
.bd9c	ce 95 03	dec $0395			dec 	Var_Type 				; this changes that default to the variable default
.bd9f	3b		dez				dez
.bda0					_VESetType:
.bda0	ad 95 03	lda $0395			lda 	Var_Type 				; get type ....
.bda3					_VEHaveType:
.bda3	8d 95 03	sta $0395			sta 	Var_Type 				; save as type.
.bda6	bd 15 03	lda $0315,x			lda 	Var_Buffer,x 			; set bit 7 of name, marks the end.
.bda9	09 80		ora #$80			ora 	#$80
.bdab	9d 15 03	sta $0315,x			sta 	Var_Buffer,x
.bdae	e8		inx				inx 							; offset 3 => length 4.
.bdaf	8e 97 03	stx $0397			stx 	Var_Length 				; save length of variable name.
.bdb2	ad 95 03	lda $0395			lda 	Var_Type 				; get offset of var type from first type token
.bdb5	38		sec				sec
.bdb6	e9 b7		sbc #$b7			sbc 	#token_Dollar
.bdb8	0a		asl a				asl 	a 						; multiply by 16. This requires HashTableSize
.bdb9	0a		asl a				asl 	a 						; in data.asm to be 8 (8 sets of links,2 bytes each)
.bdba	0a		asl a				asl 	a
.bdbb	0a		asl a				asl 	a
.bdbc	8d 98 03	sta $0398			sta 	Var_HashAddress
.bdbf	ad 96 03	lda $0396			lda 	Var_Hash 				; get the hash
.bdc2	29 07		and #$07			and 	#(HashTableSize-1) 		; force into range 0-tableSize-1
.bdc4	0a		asl a				asl 	a 						; double it (2 bytes per entry) & clears carry
.bdc5	6d 98 03	adc $0398			adc 	Var_HashAddress 		; add table offset.
.bdc8	69 35		adc #$35			adc 	#HashTableBase & $FF 	; now the low byte of the actual table address
.bdca	8d 98 03	sta $0398			sta 	Var_HashAddress
.bdcd	a2 05		ldx #$05			ldx 	#5 						; hash is 5 bytes (real)
.bdcf	ad 95 03	lda $0395			lda 	Var_Type
.bdd2	c9 b9		cmp #$b9			cmp 	#token_Hash
.bdd4	f0 07		beq $bddd			beq 	_VEHaveSize
.bdd6	ca		dex				dex
.bdd7	c9 bb		cmp #$bb			cmp 	#token_Percent 			; percent is 4 bytes (integer)
.bdd9	f0 02		beq $bddd			beq 	_VEHaveSize
.bddb	a2 02		ldx #$02			ldx 	#2 						; everything else is two.
.bddd					_VEHaveSize:
.bddd	8e 99 03	stx $0399			stx 	Var_DataSize
.bde0	fa		plx				plx
.bde1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varcreate.asm

.bde2					VariableCreate:
.bde2	da		phx				phx
.bde3	5a		phy				phy
.bde4	ad 02 03	lda $0302			lda 	VarMemPtr 					; get address of next free into zTemp1
.bde7	85 10		sta $10				sta 	zTemp1
.bde9	ad 03 03	lda $0303			lda 	VarMemPtr+1
.bdec	85 11		sta $11				sta 	zTemp1+1
.bdee	ad 99 03	lda $0399			lda 	Var_DataSize 				; bytes for the data bit
.bdf1	18		clc				clc
.bdf2	6d 97 03	adc $0397			adc 	Var_Length 					; add the length of the name
.bdf5	69 03		adc #$03			adc 	#3 							; 3 for the link and the hash.
.bdf7	6d 02 03	adc $0302			adc 	VarMemPtr 					; add to variable memory pointer
.bdfa	8d 02 03	sta $0302			sta 	VarMemPtr
.bdfd	90 03		bcc $be02			bcc 	_VCNoCarry
.bdff	ee 03 03	inc $0303			inc 	VarMemPtr+1
.be02					_VCNoCarry:
.be02	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.be05	85 12		sta $12				sta 	zTemp2
.be07	a9 03		lda #$03			lda 	#HashTableBase >> 8
.be09	85 13		sta $13				sta 	zTemp2+1
.be0b	a0 00		ldy #$00			ldy 	#0 							; put current hash link in position.
.be0d	b1 12		lda ($12),y			lda 	(zTemp2),y
.be0f	91 10		sta ($10),y			sta 	(zTemp1),y
.be11	c8		iny				iny
.be12	b1 12		lda ($12),y			lda 	(zTemp2),y
.be14	91 10		sta ($10),y			sta 	(zTemp1),y
.be16	c8		iny				iny
.be17	ad 96 03	lda $0396			lda 	Var_Hash 					; write the hash out.
.be1a	91 10		sta ($10),y			sta 	(zTemp1),y
.be1c	c8		iny				iny
.be1d	a2 00		ldx #$00			ldx 	#0 							; copy the name out.
.be1f					_VCCopyName:
.be1f	bd 15 03	lda $0315,x			lda 	Var_Buffer,x
.be22	91 10		sta ($10),y			sta 	(zTemp1),y
.be24	e8		inx				inx
.be25	c8		iny				iny
.be26	ec 97 03	cpx $0397			cpx 	Var_Length
.be29	d0 f4		bne $be1f			bne 	_VCCopyName
.be2b	5a		phy				phy 								; save the data offset.
.be2c	ae 99 03	ldx $0399			ldx 	Var_DataSize 				; and write the data out.
.be2f	a9 00		lda #$00			lda 	#0 							; which is all zeroes.
.be31					_VCClearData:
.be31	91 10		sta ($10),y			sta 	(zTemp1),y
.be33	c8		iny				iny
.be34	ca		dex				dex
.be35	d0 fa		bne $be31			bne 	_VCClearData
.be37	68		pla				pla 								; offset to the data
.be38	18		clc				clc
.be39	65 10		adc $10				adc 	zTemp1 						; add to start and save as data pointer.
.be3b	85 22		sta $22				sta 	zVarDataPtr
.be3d	a5 11		lda $11				lda 	zTemp1+1
.be3f	69 00		adc #$00			adc 	#0
.be41	85 23		sta $23				sta 	zVarDataPtr+1
.be43	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.be46	85 24		sta $24				sta 	zVarType
.be48	a5 10		lda $10				lda 	zTemp1 						; fix hash link to point to new record
.be4a	a0 00		ldy #$00			ldy 	#0
.be4c	91 12		sta ($12),y			sta 	(zTemp2),y
.be4e	c8		iny				iny
.be4f	a5 11		lda $11				lda 	zTemp1+1
.be51	91 12		sta ($12),y			sta 	(zTemp2),y
.be53	ad 95 03	lda $0395			lda 	Var_Type 					; array ? if so create the empty one.
.be56	29 01		and #$01			and 	#1
.be58	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.be5a	d0 0e		bne $be6a			bne 	_VCNotArray
.be5c	a2 00		ldx #$00			ldx 	#0 							; call recursive array creator
.be5e	20 04 bf	jsr $bf04			jsr 	ArrayCreate
.be61	5a		phy				phy 								; save YA at zVarDataPtr
.be62	a0 00		ldy #$00			ldy 	#0
.be64	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.be66	c8		iny				iny
.be67	68		pla				pla
.be68	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.be6a					_VCNotArray:
.be6a	7a		ply				ply
.be6b	fa		plx				plx
.be6c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arrayidx.asm

.be6d					ArrayIndexFollow:
.be6d	5a		phy				phy
.be6e	a0 00		ldy #$00			ldy 	#0 							; make zVarDataPtr point to the array.
.be70	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; e.g. it points to itself.
.be72	48		pha				pha
.be73	c8		iny				iny
.be74	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.be76	85 23		sta $23				sta 	zVarDataPtr+1
.be78	68		pla				pla
.be79	85 22		sta $22				sta 	zVarDataPtr
.be7b	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; MSB of 16 bit integer and bytes 2&3
.be7d	29 80		and #$80			and 	#$80 						; must be zero.
.be7f	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.be81	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.be83	d0 59		bne $bede			bne 	_AIFError
.be85	a0 00		ldy #$00			ldy 	#0 							; calculate size - current - 1
.be87	18		clc				clc
.be88	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.be8a	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.be8c	c8		iny				iny
.be8d	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.be8f	08		php				php 								; clear bit 7 retaining borrow.
.be90	29 7f		and #$7f			and 	#$7F
.be92	28		plp				plp
.be93	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.be95	90 47		bcc $bede			bcc 	_AIFError 					; eror if size-current < 0
.be97	b5 80		lda $80,x			lda  	XS_Mantissa+0,x 			; copy and double the index
.be99	0a		asl a				asl 	a 							; (e.g. index * 2)
.be9a	85 10		sta $10				sta 	zTemp1
.be9c	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.be9e	2a		rol a				rol 	a
.be9f	85 11		sta $11				sta 	zTemp1+1
.bea1	a0 01		ldy #$01			ldy 	#1 							; is this a data entry.
.bea3	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; if so, then type is unchanged, offset set
.bea5	30 1d		bmi $bec4			bmi 	_AIFCalculate
.bea7	c6 24		dec $24				dec 	zVarType 					; converts from an array to a type.
.bea9	a5 24		lda $24				lda 	zVarType 					; check that type
.beab	c9 b7		cmp #$b7			cmp 	#token_Dollar 				; if string, use x 2
.bead	f0 15		beq $bec4			beq 	_AIFCalculate
.beaf	06 10		asl $10				asl 	zTemp1			 			; double the index
.beb1	26 11		rol $11				rol 	zTemp1+1					; (e.g. index * 4)
.beb3	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if integer, use x 4
.beb5	f0 0d		beq $bec4			beq 	_AIFCalculate
.beb7	18		clc				clc 								; add the original mantissa in again
.beb8	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; which makes it x5, for float.
.beba	65 10		adc $10				adc 	zTemp1
.bebc	85 10		sta $10				sta 	zTemp1
.bebe	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bec0	65 11		adc $11				adc 	zTemp1+1
.bec2	85 11		sta $11				sta 	zTemp1+1
.bec4					_AIFCalculate:
.bec4	18		clc				clc 								; add index x 2,4 or 5 to base
.bec5	a5 22		lda $22				lda 	zVarDataPtr
.bec7	65 10		adc $10				adc 	zTemp1
.bec9	85 22		sta $22				sta 	zVarDataPtr
.becb	a5 23		lda $23				lda 	zVarDataPtr+1
.becd	65 11		adc $11				adc 	zTemp1+1
.becf	85 23		sta $23				sta 	zVarDataPtr+1
.bed1	18		clc				clc 								; add 2 more for the length prefix.
.bed2	a5 22		lda $22				lda 	zVarDataPtr
.bed4	69 02		adc #$02			adc 	#2
.bed6	85 22		sta $22				sta 	zVarDataPtr
.bed8	90 02		bcc $bedc			bcc 	_AIFNoBump
.beda	e6 23		inc $23				inc 	zVarDataPtr+1
.bedc					_AIFNoBump:
.bedc	7a		ply				ply
.bedd	60		rts				rts
.bede					_AIFError:
.bede	20 e4 ad	jsr $ade4			jsr ERR_Handler
>bee1	42 61 64 20 61 72 72 61			.text "Bad array index",0
>bee9	79 20 69 6e 64 65 78 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arraydef.asm

.bef1					ArrayResetDefault:
.bef1	a9 0b		lda #$0b			lda 	#11 						; 0..10 one array
.bef3	8d a7 03	sta $03a7			sta 	ArrayDef+0
.bef6	a9 00		lda #$00			lda 	#0
.bef8	8d a8 03	sta $03a8			sta 	ArrayDef+1
.befb	a9 ff		lda #$ff			lda 	#$FF
.befd	8d a9 03	sta $03a9			sta 	ArrayDef+2 					; $FFFF implies no second element.
.bf00	8d aa 03	sta $03aa			sta 	ArrayDef+3					; (test bit 7 of 2nd byte)
.bf03	60		rts				rts
.bf04					ArrayCreate:
.bf04	bd a7 03	lda $03a7,x			lda 	ArrayDef+0,x 				; put size x 2 in zTemp1
.bf07	0a		asl a				asl 	a
.bf08	85 10		sta $10				sta 	zTemp1
.bf0a	bd a8 03	lda $03a8,x			lda 	ArrayDef+1,x
.bf0d	2a		rol a				rol 	a
.bf0e	85 11		sta $11				sta 	zTemp1+1
.bf10	bd aa 03	lda $03aa,x			lda 	ArrayDef+3,x 				; if this is the last element it's array of ptrs.
.bf13	10 22		bpl $bf37			bpl 	_ACSized 					; if not multiply size x 2 (str) 4 (int) 5 (real)
.bf15	ad 95 03	lda $0395			lda 	Var_Type 					; check the type
.bf18	c9 b8		cmp #$b8			cmp 	#token_DollarLParen 		; also if it is an array of strings $(
.bf1a	f0 1b		beq $bf37			beq 	_ACSized
.bf1c	06 10		asl $10				asl 	zTemp1 						; double again
.bf1e	26 11		rol $11				rol 	zTemp1+1
.bf20	b0 6f		bcs $bf91			bcs 	ArrayIndexError 			; too large.
.bf22	c9 bc		cmp #$bc			cmp 	#token_PercentLParen 		; if %( four bytes/entry is enough.
.bf24	f0 11		beq $bf37			beq 	_ACSized
.bf26	18		clc				clc 								; add original value x 5 for reals.
.bf27	a5 10		lda $10				lda 	zTemp1
.bf29	7d a7 03	adc $03a7,x			adc 	ArrayDef+0,x
.bf2c	85 10		sta $10				sta 	zTemp1
.bf2e	a5 11		lda $11				lda 	zTemp1+1
.bf30	7d a8 03	adc $03a8,x			adc 	ArrayDef+1,x
.bf33	85 11		sta $11				sta 	zTemp1+1
.bf35	b0 5a		bcs $bf91			bcs 	ArrayIndexError
.bf37					_ACSized:
.bf37	18		clc				clc
.bf38	a5 10		lda $10				lda 	zTemp1
.bf3a	69 02		adc #$02			adc 	#2
.bf3c	85 10		sta $10				sta 	zTemp1
.bf3e	90 04		bcc $bf44			bcc 	_ACNoBump
.bf40	e6 10		inc $10				inc 	zTemp1
.bf42	f0 4d		beq $bf91			beq 	ArrayIndexError
.bf44					_ACNoBump:
.bf44	18		clc				clc
.bf45	ad 02 03	lda $0302			lda 	VarMemPtr 					; add this allocated count to VarMemPtr
.bf48	85 12		sta $12				sta 	zTemp2						; save start in zTemp2/zTemp3
.bf4a	85 14		sta $14				sta 	zTemp3
.bf4c	65 10		adc $10				adc 	zTemp1
.bf4e	8d 02 03	sta $0302			sta 	VarMemPtr
.bf51	ad 03 03	lda $0303			lda 	VarMemPtr+1
.bf54	85 13		sta $13				sta 	zTemp2+1
.bf56	85 15		sta $15				sta 	zTemp3+1
.bf58	65 11		adc $11				adc 	zTemp1+1
.bf5a	8d 03 03	sta $0303			sta 	VarMemPtr+1
.bf5d	85 11		sta $11				sta 	zTemp1+1
.bf5f	b0 30		bcs $bf91			bcs 	ArrayIndexError
.bf61	a0 00		ldy #$00			ldy 	#0							; write $00 out.
.bf63					_ACClear:
.bf63	98		tya				tya
.bf64	91 12		sta ($12),y			sta 	(zTemp2),y
.bf66	e6 12		inc $12				inc 	zTemp2
.bf68	d0 02		bne $bf6c			bne 	_ACCBump
.bf6a	e6 13		inc $13				inc 	zTemp2+1
.bf6c					_ACCBump:
.bf6c	a5 12		lda $12				lda 	zTemp2
.bf6e	cd 02 03	cmp $0302			cmp 	VarMemPtr
.bf71	d0 f0		bne $bf63			bne 	_ACClear
.bf73	a5 13		lda $13				lda 	zTemp2+1
.bf75	cd 03 03	cmp $0303			cmp 	VarMemPtr+1
.bf78	d0 e9		bne $bf63			bne 	_ACClear
.bf7a	a0 00		ldy #$00			ldy 	#0
.bf7c	bd a7 03	lda $03a7,x			lda 	ArrayDef+0,x 				; copy the size into the start
.bf7f	91 14		sta ($14),y			sta 	(zTemp3),y
.bf81	c8		iny				iny
.bf82	bd a8 03	lda $03a8,x			lda 	ArrayDef+1,x
.bf85	91 14		sta ($14),y			sta 	(zTemp3),y
.bf87	bd aa 03	lda $03aa,x			lda 	ArrayDef+3,x 				; have we reached the end
.bf8a	10 18		bpl $bfa4			bpl 	ACCFillRecursive
.bf8c	a4 15		ldy $15				ldy 	zTemp3+1 					; return address
.bf8e	a5 14		lda $14				lda 	zTemp3
.bf90	60		rts				rts
.bf91					ArrayIndexError:
.bf91	20 e4 ad	jsr $ade4			jsr ERR_Handler
>bf94	42 61 64 20 61 72 72 61			.text "Bad array index",0
>bf9c	79 20 69 6e 64 65 78 00
.bfa4					ACCFillRecursive:
.bfa4	a9 ff		lda #$ff			lda 	#$FF 						; we mark the end, this is free space.
.bfa6	a0 00		ldy #$00			ldy 	#0 							; this is overwritten by size of next allocated
.bfa8	91 12		sta ($12),y			sta 	(zTemp2),y 					; array, but we might change that.
.bfaa	c8		iny				iny
.bfab	b1 14		lda ($14),y			lda 	(zTemp3),y 					; set bit 15 of the max index indicating
.bfad	09 80		ora #$80			ora 	#$80 						; an array of pointers
.bfaf	91 14		sta ($14),y			sta 	(zTemp3),y
.bfb1	a5 14		lda $14				lda 	zTemp3 						; push the start on the stack
.bfb3	48		pha				pha
.bfb4	a5 15		lda $15				lda 	zTemp3+1
.bfb6	48		pha				pha
.bfb7					_ACCFillLoop:
.bfb7	18		clc				clc
.bfb8	a5 14		lda $14				lda 	zTemp3 						; and work forwards.
.bfba	69 02		adc #$02			adc 	#2
.bfbc	85 14		sta $14				sta 	zTemp3
.bfbe	90 02		bcc $bfc2			bcc 	_ACCSkip2
.bfc0	e6 15		inc $15				inc 	zTemp3+1
.bfc2					_ACCSkip2:
.bfc2	a0 00		ldy #$00			ldy 	#0 							; reached the end ?
.bfc4	b1 14		lda ($14),y			lda 	(zTemp3),y					; (looking for FF marker, everything else 00)
.bfc6	c8		iny				iny
.bfc7	11 14		ora ($14),y			ora 	(zTemp3),y
.bfc9	d0 21		bne $bfec			bne 	_ACCExit
.bfcb	a5 14		lda $14				lda 	zTemp3 						; push zTemp3
.bfcd	48		pha				pha
.bfce	a5 15		lda $15				lda 	zTemp3+1
.bfd0	48		pha				pha
.bfd1	e8		inx				inx
.bfd2	e8		inx				inx
.bfd3	20 04 bf	jsr $bf04			jsr 	ArrayCreate 				; create array recursively.
.bfd6	ca		dex				dex
.bfd7	ca		dex				dex
.bfd8	85 12		sta $12				sta 	zTemp2 						; save A
.bfda	68		pla				pla
.bfdb	85 15		sta $15				sta 	zTemp3+1 					; restore zTemp3
.bfdd	68		pla				pla
.bfde	85 14		sta $14				sta 	zTemp3
.bfe0	98		tya				tya 								; write high bye from Y
.bfe1	a0 01		ldy #$01			ldy 	#1
.bfe3	91 14		sta ($14),y			sta 	(zTemp3),y
.bfe5	88		dey				dey 								; write low byte out.
.bfe6	a5 12		lda $12				lda 	zTemp2
.bfe8	91 14		sta ($14),y			sta 	(zTemp3),y
.bfea	80 cb		bra $bfb7			bra 	_ACCFillLoop 				; and try again.
.bfec					_ACCExit:
.bfec	7a		ply				ply 								; restore the original address
.bfed	68		pla				pla
.bfee	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varfind.asm

.bfef					VariableLocate:
.bfef	da		phx				phx
.bff0	5a		phy				phy
.bff1	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.bff4	85 12		sta $12				sta 	zTemp2 						; points to first address.
.bff6	a9 03		lda #$03			lda 	#HashTableBase >> 8
.bff8	85 13		sta $13				sta 	zTemp2+1
.bffa	a0 00		ldy #$00	_VLNext:ldy 	#0 							; get next link into AX
.bffc	b1 12		lda ($12),y			lda 	(zTemp2),y
.bffe	aa		tax				tax
.bfff	c8		iny				iny
.c000	b1 12		lda ($12),y			lda 	(zTemp2),y
.c002	85 13		sta $13				sta 	zTemp2+1 					; save in zTemp
.c004	86 12		stx $12				stx 	zTemp2
.c006	05 12		ora $12				ora 	zTemp2 						; got zero
.c008	18		clc				clc
.c009	f0 25		beq $c030			beq 	_VLExit 					; if so, then fail as end of chain.
.c00b	c8		iny				iny 								; point to hash (offset + 2)
.c00c	b1 12		lda ($12),y			lda 	(zTemp2),y
.c00e	cd 96 03	cmp $0396			cmp 	Var_Hash
.c011	d0 e7		bne $bffa			bne 	_VLNext 					; try next if different.
.c013					_VLCompare:
.c013	c8		iny				iny 								; next character
.c014	b1 12		lda ($12),y			lda 	(zTemp2),y 					; compare variable field against buffer.
.c016	d9 12 03	cmp $0312,y			cmp 	Var_Buffer-3,y 				; the -3 is because name starts at 3.
.c019	d0 df		bne $bffa			bne 	_VLNext 					; fail if different, try next.
.c01b	0a		asl a				asl 	a 							; until end character (bit 7 set) matched
.c01c	90 f5		bcc $c013			bcc 	_VLCompare
.c01e	98		tya				tya
.c01f	38		sec				sec 								; add 1 as Y points to last character
.c020	65 12		adc $12				adc 	zTemp2 						; add to the current address
.c022	85 22		sta $22				sta 	zVarDataPtr
.c024	a5 13		lda $13				lda 	zTemp2+1
.c026	69 00		adc #$00			adc 	#0
.c028	85 23		sta $23				sta 	zVarDataPtr+1
.c02a	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.c02d	85 24		sta $24				sta 	zVarType
.c02f	38		sec				sec 								; return CS
.c030	7a		ply		_VLExit:ply
.c031	fa		plx				plx
.c032	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/vargetset.asm

.c033					VariableGet:
.c033	5a		phy				phy
.c034	a0 00		ldy #$00			ldy 	#0 							; copy first two bytes
.c036	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.c038	95 80		sta $80,x			sta 	XS_Mantissa,x
.c03a	c8		iny				iny
.c03b	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.c03d	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c03f	c8		iny				iny
.c040	a5 24		lda $24				lda 	zVarType 					; if it is a string, set up for that.
.c042	c9 b7		cmp #$b7			cmp 	#token_Dollar
.c044	f0 2c		beq $c072			beq 	_VGString
.c046	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; copy the next two bytes.
.c048	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c04a	c8		iny				iny
.c04b	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.c04d	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c04f	c8		iny				iny
.c050	a9 01		lda #$01			lda 	#1 							; set type to 1.
.c052	95 85		sta $85,x			sta 	XS_Type,x
.c054	a5 24		lda $24				lda 	zVarType
.c056	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if it is a %, then exit with default integer.
.c058	f0 28		beq $c082			beq 	_VGExit
.c05a	a9 40		lda #$40			lda 	#$40 						; set type byte to zero
.c05c	95 85		sta $85,x			sta 	XS_Type,x 					; which is the code for zero/float.
.c05e	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; the last value to copy is the exponent.
.c060	95 84		sta $84,x			sta 	XS_Exponent,x
.c062	f0 1e		beq $c082			beq 	_VGExit 					; if exponent is zero ... it's zero.
.c064	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; the sign bit is the top mantissa bit.
.c066	48		pha				pha
.c067	29 80		and #$80			and 	#$80
.c069	95 85		sta $85,x			sta 	XS_Type,x 					; this is the type byte.
.c06b	68		pla				pla
.c06c	09 80		ora #$80			ora 	#$80 						; set the MSB as you would expect.
.c06e	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; so it's a normalised float.
.c070	80 10		bra $c082			bra 	_VGExit
.c072					_VGString:
.c072	a9 02		lda #$02			lda 	#2 							; set type to 2, a string
.c074	95 85		sta $85,x			sta 	XS_Type,x
.c076	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; is the value there $0000
.c078	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.c07a	d0 06		bne $c082			bne 	_VGExit 					; if not, exit.
.c07c	85 25		sta $25				sta 	zNullString 				; make zNullString a 00 string.
.c07e	a9 25		lda #$25			lda 	#zNullString
.c080	95 80		sta $80,x			sta 	XS_Mantissa,x 				; make it point to it.
.c082					_VGExit:
.c082	7a		ply				ply
.c083	60		rts				rts
.c084					VariableSet:
.c084	b5 85		lda $85,x			lda 	XS_Type,x 					; is the result a string
.c086	29 02		and #$02			and 	#2 							; if so, it has to be
.c088	d0 4b		bne $c0d5			bne 	_VSString
.c08a	a5 24		lda $24				lda 	zVarType 					; if type is $ there's an error.
.c08c	c9 b7		cmp #$b7			cmp 	#token_Dollar
.c08e	f0 42		beq $c0d2			beq 	_VSBadType
.c090	c9 bb		cmp #$bb			cmp 	#token_Percent 				; type convert to float/int
.c092	f0 05		beq $c099			beq 	_VSMakeInt
.c094	20 b9 c5	jsr $c5b9			jsr 	FPUToFloat
.c097	80 03		bra $c09c			bra 	_VSCopy
.c099					_VSMakeInt:
.c099	20 05 c6	jsr $c605			jsr 	FPUToInteger
.c09c					_VSCopy:
.c09c	5a		phy				phy
.c09d	a0 00		ldy #$00			ldy 	#0 							; copy mantissa to target.
.c09f	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.c0a1	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.c0a3	c8		iny				iny
.c0a4	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c0a6	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.c0a8	c8		iny				iny
.c0a9	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c0ab	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.c0ad	c8		iny				iny
.c0ae	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.c0b0	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.c0b2	a5 24		lda $24				lda 	zVarType 					; if target is integer, alrady done.
.c0b4	c9 bb		cmp #$bb			cmp 	#token_Percent
.c0b6	f0 18		beq $c0d0			beq 	_VSExit
.c0b8	b5 85		lda $85,x			lda 	XS_Type,x 					; get the sign bit into carry flag.
.c0ba	0a		asl a				asl 	a
.c0bb	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; shift the sign into the mantissa high.
.c0bd	08		php				php
.c0be	0a		asl a				asl 	a
.c0bf	28		plp				plp
.c0c0	6a		ror a				ror 	a
.c0c1	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.c0c3	c8		iny				iny
.c0c4	b5 84		lda $84,x			lda 	XS_Exponent,x 				; copy the exponent in
.c0c6	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.c0c8	34 85		bit $85,x			bit 	XS_Type,x 					; if the result is non zero
.c0ca	50 04		bvc $c0d0			bvc 	_VSExit
.c0cc	a9 00		lda #$00			lda 	#00 						; zero exponent indicating 0.
.c0ce	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.c0d0					_VSExit:
.c0d0	7a		ply				ply
.c0d1	60		rts				rts
.c0d2					_VSBadType:
.c0d2	4c c5 ad	jmp $adc5			jmp 	TypeError
.c0d5					_VSString:
.c0d5	a5 24		lda $24				lda 	zVarType 					; type must be $
.c0d7	c9 b7		cmp #$b7			cmp 	#token_Dollar
.c0d9	d0 f7		bne $c0d2			bne 	_VSBadType
.c0db	da		phx				phx
.c0dc	5a		phy				phy
.c0dd	20 55 bc	jsr $bc55			jsr 	StringConcrete 				; concrete the string in the mantissa -> AX
.c0e0	a0 01		ldy #$01			ldy 	#1 							; save high byte
.c0e2	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.c0e4	88		dey				dey 								; save low byte
.c0e5	8a		txa				txa
.c0e6	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.c0e8	7a		ply				ply 								; and exit.
.c0e9	fa		plx				plx
.c0ea	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.c0eb					MulInteger32:
.c0eb	b5 80		lda $80,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.c0ed	95 8c		sta $8c,x			sta 	XS3_Mantissa,x
.c0ef	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c0f1	95 8d		sta $8d,x			sta 	XS3_Mantissa+1,x
.c0f3	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c0f5	95 8e		sta $8e,x			sta 	XS3_Mantissa+2,x
.c0f7	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.c0f9	95 8f		sta $8f,x			sta 	XS3_Mantissa+3,x
.c0fb	a9 00		lda #$00			lda 	#0
.c0fd	95 80		sta $80,x			sta 	XS_Mantissa+0,x 				; zero +0
.c0ff	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c101	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c103	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c105					_BFMMultiply:
.c105	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.c107	29 01		and #$01			and 	#1
.c109	f0 03		beq $c10e			beq 	_BFMNoAdd
.c10b	20 c5 b7	jsr $b7c5			jsr 	AddInteger32
.c10e					_BFMNoAdd:
.c10e	16 86		asl $86,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.c110	36 87		rol $87,x			rol 	XS2_Mantissa+1,x
.c112	36 88		rol $88,x			rol 	XS2_Mantissa+2,x
.c114	36 89		rol $89,x			rol 	XS2_Mantissa+3,x
.c116	56 8f		lsr $8f,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.c118	76 8e		ror $8e,x			ror 	XS3_Mantissa+2,x
.c11a	76 8d		ror $8d,x			ror 	XS3_Mantissa+1,x
.c11c	76 8c		ror $8c,x			ror 	XS3_Mantissa,x
.c11e	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.c120	15 8d		ora $8d,x			ora 	XS3_Mantissa+1,x
.c122	15 8e		ora $8e,x			ora 	XS3_Mantissa+2,x
.c124	15 8f		ora $8f,x			ora 	XS3_Mantissa+3,x
.c126	d0 dd		bne $c105			bne 	_BFMMultiply
.c128	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.c129					DivInteger32:
.c129	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; check for /0
.c12b	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.c12d	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.c12f	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.c131	d0 14		bne $c147			bne 	_BFDOkay
.c133	20 e4 ad	jsr $ade4			jsr ERR_Handler
>c136	44 69 76 69 73 69 6f 6e			.text "Division by Zero",0
>c13e	20 62 79 20 5a 65 72 6f 00
.c147					_BFDOkay:
.c147	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.c149	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.c14b	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.c14d	85 1c		sta $1c				sta 	zLTemp1+2
.c14f	85 1d		sta $1d				sta 	zLTemp1+3
.c151	8d 9e 03	sta $039e			sta 	SignCount 					; Count of signs.
.c154	20 ab c1	jsr $c1ab			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.c157	da		phx				phx
.c158	e8		inx				inx
.c159	e8		inx				inx
.c15a	e8		inx				inx
.c15b	e8		inx				inx
.c15c	e8		inx				inx
.c15d	e8		inx				inx
.c15e	20 ab c1	jsr $c1ab			jsr 	CheckIntegerNegate
.c161	fa		plx				plx
.c162	5a		phy				phy 								; Y is the counter
.c163	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.c165					_BFDLoop:
.c165	16 80		asl $80,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.c167	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.c169	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.c16b	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.c16d	26 1a		rol $1a				rol 	zLTemp1
.c16f	26 1b		rol $1b				rol 	zLTemp1+1
.c171	26 1c		rol $1c				rol 	zLTemp1+2
.c173	26 1d		rol $1d				rol 	zLTemp1+3
.c175	38		sec				sec
.c176	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.c178	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.c17a	48		pha				pha
.c17b	a5 1b		lda $1b				lda 	zLTemp1+1
.c17d	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.c17f	48		pha				pha
.c180	a5 1c		lda $1c				lda 	zLTemp1+2
.c182	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.c184	48		pha				pha
.c185	a5 1d		lda $1d				lda 	zLTemp1+3
.c187	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.c189	90 13		bcc $c19e			bcc 	_BFDNoAdd
.c18b	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.c18d	68		pla				pla
.c18e	85 1c		sta $1c				sta 	zLTemp1+2
.c190	68		pla				pla
.c191	85 1b		sta $1b				sta 	zLTemp1+1
.c193	68		pla				pla
.c194	85 1a		sta $1a				sta 	zLTemp1+0
.c196	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.c198	09 01		ora #$01			ora 	#1
.c19a	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c19c	80 03		bra $c1a1			bra 	_BFDNext
.c19e					_BFDNoAdd:
.c19e	68		pla				pla 								; Throw away the intermediate calculations
.c19f	68		pla				pla
.c1a0	68		pla				pla
.c1a1					_BFDNext:
.c1a1	88		dey				dey
.c1a2	d0 c1		bne $c165			bne 	_BFDLoop
.c1a4	7a		ply				ply 								; restore Y and exit
.c1a5	4e 9e 03	lsr $039e			lsr 	SignCount 					; if sign count odd,
.c1a8	b0 06		bcs $c1b0			bcs		IntegerNegateAlways 			; negate the result
.c1aa	60		rts				rts
.c1ab					CheckIntegerNegate:
.c1ab	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.c1ad	30 01		bmi $c1b0			bmi 	IntegerNegateAlways
.c1af	60		rts				rts
.c1b0					IntegerNegateAlways:
.c1b0	ee 9e 03	inc $039e			inc 	SignCount
.c1b3	38		sec				sec
.c1b4	a9 00		lda #$00			lda 	#0
.c1b6	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.c1b8	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c1ba	a9 00		lda #$00			lda 	#0
.c1bc	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.c1be	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c1c0	a9 00		lda #$00			lda 	#0
.c1c2	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.c1c4	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c1c6	a9 00		lda #$00			lda 	#0
.c1c8	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.c1ca	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c1cc	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.c1cd					INTToString:
.c1cd	48		pha				pha
.c1ce	5a		phy				phy
.c1cf	b5 83		lda $83,x			lda 		XS_Mantissa+3,x 		; check -ve
.c1d1	10 08		bpl $c1db			bpl 		_ITSNotMinus
.c1d3	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.c1d5	20 6b c2	jsr $c26b			jsr 		ITSOutputCharacter
.c1d8	20 b0 c1	jsr $c1b0			jsr 		IntegerNegateAlways 	; negate the number.
.c1db					_ITSNotMinus:
.c1db	a9 00		lda #$00			lda 		#0
.c1dd	8d 9a 03	sta $039a			sta 		NumSuppress 			; clear the suppression flag.
.c1e0	8a		txa				txa 								; use Y for the mantissa index.
.c1e1	a8		tay				tay
.c1e2	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.c1e4					_ITSNextSubtractor:
.c1e4	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.c1e6	8d 9b 03	sta $039b			sta 		NumConvCount
.c1e9					_ITSSubtract:
.c1e9	38		sec				sec
.c1ea	b9 80 00	lda $0080,y			lda 		XS_Mantissa,y 			; subtract number and push on stack
.c1ed	fd 47 c2	sbc $c247,x			sbc 		_ITSSubtractors+0,x
.c1f0	48		pha				pha
.c1f1	b9 81 00	lda $0081,y			lda 		XS_Mantissa+1,y
.c1f4	fd 48 c2	sbc $c248,x			sbc 		_ITSSubtractors+1,x
.c1f7	48		pha				pha
.c1f8	b9 82 00	lda $0082,y			lda 		XS_Mantissa+2,y
.c1fb	fd 49 c2	sbc $c249,x			sbc 		_ITSSubtractors+2,x
.c1fe	48		pha				pha
.c1ff	b9 83 00	lda $0083,y			lda 		XS_Mantissa+3,y
.c202	fd 4a c2	sbc $c24a,x			sbc 		_ITSSubtractors+3,x
.c205	90 14		bcc $c21b			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.c207	99 83 00	sta $0083,y			sta 		XS_Mantissa+3,y 		; save subtract off stack
.c20a	68		pla				pla
.c20b	99 82 00	sta $0082,y			sta 		XS_Mantissa+2,y
.c20e	68		pla				pla
.c20f	99 81 00	sta $0081,y			sta 		XS_Mantissa+1,y
.c212	68		pla				pla
.c213	99 80 00	sta $0080,y			sta 		XS_Mantissa+0,y
.c216	ee 9b 03	inc $039b			inc 		NumConvCount 			; bump count.
.c219	80 ce		bra $c1e9			bra 		_ITSSubtract 			; go round again.
.c21b					_ITSCantSubtract:
.c21b	68		pla				pla 								; throw away interim answers
.c21c	68		pla				pla
.c21d	68		pla				pla
.c21e	ad 9b 03	lda $039b			lda 		NumConvCount 			; if not zero then no suppression check
.c221	c9 30		cmp #$30			cmp 		#"0"
.c223	d0 05		bne $c22a			bne 		_ITSOutputDigit
.c225	ad 9a 03	lda $039a			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.c228	10 09		bpl $c233			bpl	 		_ITSGoNextSubtractor
.c22a					_ITSOutputDigit:
.c22a	ce 9a 03	dec $039a			dec 		NumSuppress 			; suppression check will be non-zero.
.c22d	ad 9b 03	lda $039b			lda 		NumConvCount 			; count of subtractions
.c230	20 6b c2	jsr $c26b			jsr 		ITSOutputCharacter 		; output it.
.c233					_ITSGoNextSubtractor:
.c233	e8		inx				inx 								; next dword
.c234	e8		inx				inx
.c235	e8		inx				inx
.c236	e8		inx				inx
.c237	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.c239	d0 a9		bne $c1e4			bne 		_ITSNextSubtractor 		; do all the subtractors.
.c23b	98		tya				tya 								; X is back as the mantissa index
.c23c	aa		tax				tax
.c23d	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.c23f	09 30		ora #$30			ora 		#"0"
.c241	20 6b c2	jsr $c26b			jsr 		ITSOutputCharacter
.c244	7a		ply				ply 								; and exit
.c245	68		pla				pla
.c246	60		rts				rts
.c247					_ITSSubtractors:
>c247	00 ca 9a 3b					.dword 		1000000000
>c24b	00 e1 f5 05					.dword 		100000000
>c24f	80 96 98 00					.dword 		10000000
>c253	40 42 0f 00					.dword 		1000000
>c257	a0 86 01 00					.dword 		100000
>c25b	10 27 00 00					.dword 		10000
>c25f	e8 03 00 00					.dword 		1000
>c263	64 00 00 00					.dword 		100
>c267	0a 00 00 00					.dword 		10
.c26b					_ITSSubtractorsEnd:
.c26b					ITSOutputCharacter:
.c26b	48		pha				pha
.c26c	da		phx				phx
.c26d	ae 14 03	ldx $0314			ldx 	NumBufX 					; save digit
.c270	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.c273	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.c275	9d 16 03	sta $0316,x			sta 	Num_Buffer+1,x
.c278	ee 14 03	inc $0314			inc 	NumBufX						; bump pointer.
.c27b	fa		plx				plx
.c27c	68		pla				pla
.c27d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.c27e					IntFromString:
.c27e	a0 00		ldy #$00			ldy 	#0
.c280	8c 9c 03	sty $039c			sty 	ExpTemp 					; this is the converted digit count.
.c283					IntFromStringY:
.c283	48		pha				pha
.c284	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.c286	95 80		sta $80,x			sta 	XS_Mantissa,x
.c288	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c28a	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c28c	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c28e	a9 01		lda #$01			lda 	#1
.c290	95 85		sta $85,x			sta 	XS_Type,x
.c292					_IFSLoop:
.c292	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.c294	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.c296	90 4e		bcc $c2e6			bcc 	_IFSExit
.c298	c9 3a		cmp #$3a			cmp 	#"9"+1
.c29a	b0 4a		bcs $c2e6			bcs 	_IFSExit
.c29c	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.c29e	c9 0c		cmp #$0c			cmp 	#12
.c2a0	b0 4e		bcs $c2f0			bcs 	_IFSOverflow
.c2a2	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.c2a4	48		pha				pha
.c2a5	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c2a7	48		pha				pha
.c2a8	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c2aa	48		pha				pha
.c2ab	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.c2ad	48		pha				pha
.c2ae	20 05 c3	jsr $c305			jsr 	IFSX1ShiftLeft 				; double
.c2b1	20 05 c3	jsr $c305			jsr 	IFSX1ShiftLeft 				; x 4
.c2b4	18		clc				clc 								; add saved value x 5
.c2b5	68		pla				pla
.c2b6	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.c2b8	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c2ba	68		pla				pla
.c2bb	75 81		adc $81,x			adc 	XS_Mantissa+1,x
.c2bd	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c2bf	68		pla				pla
.c2c0	75 82		adc $82,x			adc 	XS_Mantissa+2,x
.c2c2	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c2c4	68		pla				pla
.c2c5	75 83		adc $83,x			adc 	XS_Mantissa+3,x
.c2c7	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c2c9	20 05 c3	jsr $c305			jsr 	IFSX1ShiftLeft 				; x 10
.c2cc	ee 9c 03	inc $039c			inc 	ExpTemp 					; bump count of digits processed.
.c2cf	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.c2d1	29 0f		and #$0f			and 	#15
.c2d3	c8		iny				iny
.c2d4	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.c2d6	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c2d8	90 b8		bcc $c292			bcc 	_IFSLoop
.c2da	f6 81		inc $81,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.c2dc	d0 b4		bne $c292			bne 	_IFSLoop
.c2de	f6 82		inc $82,x			inc 	XS_Mantissa+2,x
.c2e0	d0 b0		bne $c292			bne 	_IFSLoop
.c2e2	f6 83		inc $83,x			inc 	XS_Mantissa+3,x
.c2e4	80 ac		bra $c292			bra 	_IFSLoop
.c2e6					_IFSExit:
.c2e6	98		tya				tya 								; get offset
.c2e7					_IFSOkay:
.c2e7	38		sec				sec
.c2e8	ad 9c 03	lda $039c			lda 	ExpTemp
.c2eb	f0 01		beq $c2ee			beq 	_IFSSkipFail
.c2ed	18		clc				clc
.c2ee					_IFSSkipFail:
.c2ee	68		pla				pla 								; and exit.
.c2ef	60		rts				rts
.c2f0					_IFSOverflow:
.c2f0	20 e4 ad	jsr $ade4			jsr 	ERR_Handler
>c2f3	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>c2fb	20 6f 76 65 72 66 6c 6f 77 00
.c305					IFSX1ShiftLeft:
.c305	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.c307	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.c309	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.c30b	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.c30d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.c30e					FPSubtract:
.c30e	48		pha				pha
.c30f	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.c311	49 80		eor #$80			eor 	#$80
.c313	95 8b		sta $8b,x			sta 	XS2_Type,x
.c315	68		pla				pla 								; --- and fall through ---
.c316					FPAdd:
.c316	48		pha				pha
.c317	b5 85		lda $85,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.c319	d0 05		bne $c320			bne 	_FPA_NegativeLHS
.c31b	20 37 c3	jsr $c337			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.c31e	68		pla				pla
.c31f	60		rts				rts
.c320					_FPA_NegativeLHS:
.c320	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.c322	49 80		eor #$80			eor 	#$80
.c324	95 85		sta $85,x			sta 	XS_Type,x
.c326	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of B and add
.c328	49 80		eor #$80			eor 	#$80
.c32a	95 8b		sta $8b,x			sta 	XS2_Type,x
.c32c	20 37 c3	jsr $c337			jsr 	FPAdd_Worker 				; do the add calculation.
.c32f	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 back
.c331	49 80		eor #$80			eor 	#$80
.c333	95 85		sta $85,x			sta 	XS_Type,x
.c335	68		pla				pla
.c336	60		rts				rts
.c337					FPAdd_Worker:
.c337	34 8b		bit $8b,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.c339	70 07		bvs $c342			bvs 	_FPAWExit 					; no change.
.c33b	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.c33d	50 07		bvc $c346			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.c33f	20 77 c5	jsr $c577			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.c342					_FPAWExit:
.c342	20 e6 c5	jsr $c5e6			jsr 	FPUNormalise 				; normalise the result.
.c345	60		rts				rts
.c346					_FPAWMakeSame:
.c346	b5 84		lda $84,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.c348	38		sec				sec
.c349	f5 8a		sbc $8a,x			sbc	 	XS2_Exponent,x 				; using subtraction
.c34b	f0 16		beq $c363			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.c34d	da		phx				phx 								; save X
.c34e	90 06		bcc $c356			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.c350	e8		inx				inx
.c351	e8		inx				inx
.c352	e8		inx				inx
.c353	e8		inx				inx
.c354	e8		inx				inx
.c355	e8		inx				inx
.c356					_FPAWShiftA:
.c356	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.c358	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.c35a	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.c35c	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.c35e	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.c360	fa		plx				plx 								; restore original X
.c361	80 e3		bra $c346			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.c363					_FPAW_DoArithmetic:
.c363	34 8b		bit $8b,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.c365	30 28		bmi $c38f			bmi 	_FPAW_BNegative
.c367	18		clc				clc
.c368	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.c36a	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.c36c	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c36e	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c370	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.c372	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c374	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c376	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.c378	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c37a	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.c37c	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.c37e	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c380	90 c0		bcc $c342			bcc 	_FPAWExit 					; no carry.
.c382	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.c384	38		sec				sec
.c385	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.c387	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.c389	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.c38b	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.c38d	80 b3		bra $c342			bra 	_FPAWExit
.c38f					_FPAW_BNegative:
.c38f	38		sec				sec
.c390	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.c392	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.c394	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c396	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c398	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.c39a	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c39c	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c39e	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.c3a0	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c3a2	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.c3a4	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.c3a6	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c3a8	b0 09		bcs $c3b3			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.c3aa	20 9d c5	jsr $c59d			jsr 	FPUNegateInteger			; negate the mantissa
.c3ad	b5 85		lda $85,x			lda 	XS_Type,x 					; flip result sign
.c3af	49 80		eor #$80			eor 	#$80
.c3b1	95 85		sta $85,x			sta 	XS_Type,x
.c3b3					_FPAWGoExit:
.c3b3	4c 42 c3	jmp $c342			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.c3b6					FPD_IsDivZero:
.c3b6	20 e4 ad	jsr $ade4			jsr ERR_Handler
>c3b9	44 69 76 69 73 69 6f 6e			.text "Division by zero",0
>c3c1	20 62 79 20 7a 65 72 6f 00
.c3ca					FPDivide:
.c3ca	48		pha				pha
.c3cb	5a		phy				phy
.c3cc	34 8b		bit $8b,x			bit 	XS2_Type,x 					; check if division by zero
.c3ce	70 e6		bvs $c3b6			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.c3d0	34 85		bit $85,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.c3d2	f0 03		beq $c3d7			beq 	_FPDCalculateExp
.c3d4					_FPD_Exit:
.c3d4	7a		ply				ply
.c3d5	68		pla				pla
.c3d6	60		rts				rts
.c3d7					_FPDCalculateExp:
.c3d7	b5 8a		lda $8a,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.c3d9	49 ff		eor #$ff			eor 	#$FF
.c3db	1a		inc a				inc 	a
.c3dc	95 8a		sta $8a,x			sta 	XS2_Exponent,x
.c3de	20 ae c4	jsr $c4ae			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.c3e1	18		clc				clc 	 							; add 1 to the resulting exponent
.c3e2	69 01		adc #$01			adc 	#1
.c3e4	b0 54		bcs $c43a			bcs 	_FPD_Overflow 				; which can overflow.
.c3e6	95 84		sta $84,x			sta 	XS_Exponent,x
.c3e8	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.c3ea	85 1a		sta $1a				sta 	zLTemp1+0
.c3ec	85 1b		sta $1b				sta 	zLTemp1+1
.c3ee	85 1c		sta $1c				sta 	zLTemp1+2
.c3f0	85 1d		sta $1d				sta 	zLTemp1+3
.c3f2	a0 20		ldy #$20			ldy 	#32 						; times round.
.c3f4					_FPD_Loop:
.c3f4	38		sec				sec 								; calculate X1-X2 stacking result because we might
.c3f5	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; not save it.
.c3f7	f5 86		sbc $86,x			sbc 	XS2_Mantissa,x
.c3f9	48		pha				pha
.c3fa	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c3fc	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.c3fe	48		pha				pha
.c3ff	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c401	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.c403	48		pha				pha
.c404	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.c406	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.c408	90 13		bcc $c41d			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.c40a	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; save results out to A
.c40c	68		pla				pla
.c40d	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c40f	68		pla				pla
.c410	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c412	68		pla				pla
.c413	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c415	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.c417	09 80		ora #$80			ora 	#$80
.c419	85 1d		sta $1d				sta 	zLTemp1+3
.c41b	80 03		bra $c420			bra 	_FPD_Rotates
.c41d					_FPD_NoSubtract:
.c41d	68		pla				pla 								; throw away unwanted results
.c41e	68		pla				pla
.c41f	68		pla				pla
.c420					_FPD_Rotates:
.c420	56 89		lsr $89,x			lsr 	3+XS2_Mantissa,x
.c422	76 88		ror $88,x			ror 	2+XS2_Mantissa,x
.c424	76 87		ror $87,x			ror 	1+XS2_Mantissa,x
.c426	76 86		ror $86,x			ror 	0+XS2_Mantissa,x
.c428	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.c42a	26 1b		rol $1b				rol 	zLTemp1+1
.c42c	26 1c		rol $1c				rol 	zLTemp1+2
.c42e	26 1d		rol $1d				rol 	zLTemp1+3
.c430	90 02		bcc $c434			bcc 	_FPD_NoCarry
.c432	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.c434					_FPD_NoCarry:
.c434	88		dey				dey 								; do 32 times
.c435	d0 bd		bne $c3f4			bne 	_FPD_Loop
.c437	4c 92 c4	jmp $c492			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.c43a					_FPD_Overflow:
.c43a	4c 43 c6	jmp $c643			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.c43d					FPMultiply:
.c43d	48		pha				pha
.c43e	5a		phy				phy
.c43f	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.c441	70 07		bvs $c44a			bvs 	_FPM_Exit
.c443	34 8b		bit $8b,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.c445	50 06		bvc $c44d			bvc 	_FPM_CalcExponent
.c447	20 77 c5	jsr $c577			jsr 	FPUCopyX2ToX1
.c44a					_FPM_Exit:
.c44a	7a		ply				ply
.c44b	68		pla				pla
.c44c	60		rts				rts
.c44d					_FPM_CalcExponent:
.c44d	18		clc				clc
.c44e	20 ae c4	jsr $c4ae			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.c451	95 84		sta $84,x			sta 	XS_Exponent,x 				; save the result.
.c453	a9 00		lda #$00			lda 	#0
.c455	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.c457	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.c459	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.c45b	85 1d		sta $1d				sta 	zLTemp1+3
.c45d	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.c45f					_FPM_Loop:
.c45f	b5 80		lda $80,x			lda 	XS_Mantissa,x				; check LSB of long product
.c461	29 01		and #$01			and 	#1
.c463	18		clc				clc 								; clear carry for the long rotate.
.c464	f0 19		beq $c47f			beq 	_FPM_NoAddition
.c466	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.c467	a5 1a		lda $1a				lda 	zLTemp1+0
.c469	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.c46b	85 1a		sta $1a				sta 	zLTemp1+0
.c46d	a5 1b		lda $1b				lda 	zLTemp1+1
.c46f	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.c471	85 1b		sta $1b				sta 	zLTemp1+1
.c473	a5 1c		lda $1c				lda 	zLTemp1+2
.c475	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.c477	85 1c		sta $1c				sta 	zLTemp1+2
.c479	a5 1d		lda $1d				lda 	zLTemp1+3
.c47b	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.c47d	85 1d		sta $1d				sta 	zLTemp1+3
.c47f					_FPM_NoAddition:
.c47f	66 1d		ror $1d				ror 	3+zLTemp1
.c481	66 1c		ror $1c				ror 	2+zLTemp1
.c483	66 1b		ror $1b				ror 	1+zLTemp1
.c485	66 1a		ror $1a				ror 	0+zLTemp1
.c487	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.c489	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.c48b	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.c48d	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.c48f	88		dey				dey
.c490	d0 cd		bne $c45f			bne 	_FPM_Loop 					; do this 32 times.
.c492					FPM_CopySignNormalize:
.c492	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.c494	95 80		sta $80,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.c496	a5 1b		lda $1b				lda 	zLTemp1+1
.c498	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c49a	a5 1c		lda $1c				lda 	zLTemp1+2
.c49c	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c49e	a5 1d		lda $1d				lda 	zLTemp1+3
.c4a0	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c4a2	b5 85		lda $85,x			lda 	XS_Type,x 					; sign is xor of signs
.c4a4	55 8b		eor $8b,x			eor 	XS2_Type,x
.c4a6	95 85		sta $85,x			sta 	XS_Type,x
.c4a8	20 e6 c5	jsr $c5e6			jsr 	FPUNormalise 				; normalise and exit.
.c4ab	7a		ply				ply
.c4ac	68		pla				pla
.c4ad	60		rts				rts
.c4ae					FPCalculateExponent:
.c4ae	18		clc				clc
.c4af	b5 84		lda $84,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.c4b1	75 8a		adc $8a,x			adc 	XS2_Exponent,x
.c4b3	b0 08		bcs $c4bd			bcs 	_FPCECarry 					; carry out ?
.c4b5	10 03		bpl $c4ba			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.c4b7	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.c4b9	60		rts				rts
.c4ba					_FPCEExpZero:
.c4ba	a9 00		lda #$00			lda 	#0
.c4bc	60		rts				rts
.c4bd					_FPCECarry:
.c4bd	30 03		bmi $c4c2			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.c4bf	09 80		ora #$80			ora 	#$80 						; put in right range
.c4c1	60		rts				rts
.c4c2					_FPCEOverflow:
.c4c2	4c 43 c6	jmp $c643			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.c4c5					FPFractionalPart:
.c4c5	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.c4c7	38		sec				sec 								; this flag tells us to keep the fractional part
.c4c8	30 0d		bmi $c4d7			bmi 	FPGetPart
.c4ca	60		rts				rts
.c4cb					FPIntegerPart:
.c4cb	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.c4cd	18		clc				clc 								; this flag says keep the integer part.
.c4ce	30 07		bmi $c4d7			bmi 	FPGetPart 					; -ve exponents are 0..127
.c4d0	48		pha				pha
.c4d1	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.c4d3	95 85		sta $85,x			sta 	XS_Type,x
.c4d5	68		pla				pla
.c4d6	60		rts				rts
.c4d7					FPGetPart:
.c4d7	48		pha				pha
.c4d8	5a		phy				phy 								; save Y
.c4d9	08		php				php 								; save action
.c4da	34 85		bit $85,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.c4dc	70 59		bvs $c537			bvs 	_FPGP_Exit 					; then do nothing.
.c4de	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.c4e0	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.c4e2	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.c4e4	85 1c		sta $1c				sta 	zLTemp1+2
.c4e6	85 1d		sta $1d				sta 	zLTemp1+3
.c4e8	b5 84		lda $84,x			lda 	XS_Exponent,x				; the number of shifts.
.c4ea	38		sec				sec
.c4eb	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.c4ed	f0 12		beq $c501			beq 	_FPGP_NoShift 				; ... if any
.c4ef	c9 20		cmp #$20			cmp 	#32
.c4f1	90 02		bcc $c4f5			bcc 	_FPGP_NotMax
.c4f3	a9 20		lda #$20			lda 	#32 						; max of 32.
.c4f5					_FPGP_NotMax:
.c4f5	a8		tay				tay 								; Y is the mask shift count.
.c4f6					_FPGP_ShiftMask:
.c4f6	46 1d		lsr $1d				lsr 	3+zLTemp1
.c4f8	66 1c		ror $1c				ror 	2+zLTemp1
.c4fa	66 1b		ror $1b				ror 	1+zLTemp1
.c4fc	66 1a		ror $1a				ror 	0+zLTemp1
.c4fe	88		dey				dey
.c4ff	d0 f5		bne $c4f6			bne 	_FPGP_ShiftMask
.c501					_FPGP_NoShift:
.c501	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.c503	8e 9c 03	stx $039c			stx 	ExpTemp						; save X
.c506					_FPGP_MaskLoop:
.c506	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.c509	28		plp				plp 								; if CC we keep the top part, so we
.c50a	08		php				php		 							; flip the mask.
.c50b	b0 02		bcs $c50f			bcs		_FPGP_NoFlip
.c50d	49 ff		eor #$ff			eor 	#$FF
.c50f					_FPGP_NoFlip:
.c50f	35 80		and $80,x			and 	XS_Mantissa,x 				; and into the mantissa.
.c511	95 80		sta $80,x			sta 	XS_Mantissa,x
.c513	e8		inx				inx
.c514	c8		iny				iny
.c515	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.c517	d0 ed		bne $c506			bne 	_FPGP_MaskLoop
.c519	ae 9c 03	ldx $039c			ldx 	ExpTemp						; restore X
.c51c	28		plp				plp
.c51d	08		php				php 								; get action flag on the stack
.c51e	90 04		bcc $c524			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.c520	a9 00		lda #$00			lda 	#0
.c522	95 85		sta $85,x			sta 	XS_Type,x
.c524					_FPGP_NotFractional:
.c524	b5 80		lda $80,x			lda 	XS_Mantissa,x 						; check if \1 zero
.c526	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.c528	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.c52a	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.c52c	f0 05		beq $c533			beq 	_FPGP_Zero 					; if zero, return zero
.c52e	20 e6 c5	jsr $c5e6			jsr 	FPUNormalise
.c531	80 04		bra $c537			bra 	_FPGP_Exit 					; and exit
.c533					_FPGP_Zero:
.c533	a9 40		lda #$40			lda 	#$40 						; set zero flag
.c535	95 85		sta $85,x			sta 	XS_Type,x
.c537					_FPGP_Exit:
.c537	68		pla				pla 								; throw saved action flag.
.c538	7a		ply				ply
.c539	68		pla				pla
.c53a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.c53b					FPCompare:
.c53b	b5 84		lda $84,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.c53d	48		pha				pha
.c53e	b5 8a		lda $8a,x			lda 	XS2_Exponent,x
.c540	48		pha				pha
.c541	20 0e c3	jsr $c30e			jsr 	FPSubtract 					; calculate X1-X2
.c544	34 85		bit $85,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.c546	70 2a		bvs $c572			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.c548	68		pla				pla
.c549	8d 9c 03	sta $039c			sta 	ExpTemp						; save first exponent in temporary reg.
.c54c	68		pla				pla
.c54d	38		sec				sec
.c54e	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; calculate AX-BX
.c551	70 14		bvs $c567			bvs 	_FPCNotEqual				; overflow, can't be equal.
.c553	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.c554	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.c556	b0 0f		bcs $c567			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.c558	38		sec				sec
.c559	ad 9c 03	lda $039c			lda 	ExpTemp 					; get one of the exponents back.
.c55c	e9 12		sbc #$12			sbc 	#18 						; allow for 2^18 error, relatively.
.c55e	b0 02		bcs $c562			bcs 	_FPCNotRange 				; keep in range.
.c560	a9 01		lda #$01			lda 	#1
.c562					_FPCNotRange:
.c562	38		sec				sec
.c563	f5 84		sbc $84,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.c565	b0 0d		bcs $c574			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.c567					_FPCNotEqual:
.c567	b5 85		lda $85,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.c569	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.c56b	f0 02		beq $c56f			beq 	_FPCNE2
.c56d	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.c56f	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.c570	80 04		bra $c576			bra 	_FPCExit
.c572					_FPCPullZero:
.c572	68		pla				pla 								; throw saved exponents
.c573	68		pla				pla
.c574					_FPCZero:
.c574	a9 00		lda #$00			lda 	#0 							; and return zero
.c576					_FPCExit:
.c576	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.c577					FPUCopyX2ToX1:
.c577	48		pha				pha
.c578	da		phx				phx
.c579	5a		phy				phy
.c57a	a0 08		ldy #$08			ldy 	#8
.c57c	b5 86		lda $86,x	_FPUC21:lda 	XS2_Mantissa,x
.c57e	95 80		sta $80,x			sta 	XS_Mantissa,x
.c580	e8		inx				inx
.c581	88		dey				dey
.c582	10 f8		bpl $c57c			bpl 	_FPUC21
.c584	7a		ply				ply
.c585	fa		plx				plx
.c586	68		pla				pla
.c587	60		rts				rts
.c588					FPUSetInteger:
.c588	48		pha				pha
.c589	95 80		sta $80,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.c58b	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.c58d	10 02		bpl $c591			bpl 	_FPUSIExtend
.c58f	a9 ff		lda #$ff			lda 	#$FF
.c591					_FPUSIExtend:
.c591	95 81		sta $81,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.c593	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c595	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c597	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.c599	95 85		sta $85,x			sta 	XS_Type,x
.c59b	68		pla				pla
.c59c	60		rts				rts
.c59d					FPUNegateInteger:
.c59d	48		pha				pha
.c59e	38		sec				sec
.c59f	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.c5a1	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.c5a3	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c5a5	a9 00		lda #$00			lda 	#0
.c5a7	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.c5a9	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c5ab	a9 00		lda #$00			lda 	#0
.c5ad	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.c5af	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c5b1	a9 00		lda #$00			lda 	#0
.c5b3	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.c5b5	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c5b7	68		pla				pla
.c5b8	60		rts				rts
.c5b9					FPUToFloat:
.c5b9	48		pha				pha
.c5ba	b5 85		lda $85,x			lda 	XS_Type,x					; exit if already float.
.c5bc	29 0f		and #$0f			and 	#$0F
.c5be	f0 24		beq $c5e4			beq 	_FPUFExit
.c5c0	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.c5c2	95 85		sta $85,x			sta 	XS_Type,x
.c5c4	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.c5c6	95 84		sta $84,x			sta 	XS_Exponent,x 				; x mantissa.
.c5c8	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.c5ca	10 07		bpl $c5d3			bpl		_FPUFPositive
.c5cc	20 9d c5	jsr $c59d			jsr 	FPUNegateInteger 			; negate the mantissa
.c5cf	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.c5d1	95 85		sta $85,x			sta 	XS_Type,x
.c5d3					_FPUFPositive:
.c5d3	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.c5d5	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.c5d7	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.c5d9	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.c5db	d0 04		bne $c5e1			bne 	_FPUFNonZero
.c5dd	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.c5df	95 85		sta $85,x			sta 	XS_Type,x
.c5e1					_FPUFNonZero:
.c5e1	20 e6 c5	jsr $c5e6			jsr 	FPUNormalise 				; normalise the floating point.
.c5e4					_FPUFExit:
.c5e4	68		pla				pla
.c5e5	60		rts				rts
.c5e6					FPUNormalise:
.c5e6	48		pha				pha
.c5e7	34 85		bit $85,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.c5e9	70 18		bvs $c603			bvs 	_FPUNExit
.c5eb	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.c5ed	f0 10		beq $c5ff			beq 	_FPUNSetZero
.c5ef					_FPUNLoop:
.c5ef	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.c5f1	30 10		bmi $c603			bmi 	_FPUNExit 					; if so, we are normalised.
.c5f3	16 80		asl $80,x			asl 	0+XS_Mantissa+0,x
.c5f5	36 81		rol $81,x			rol 	1+XS_Mantissa+0,x
.c5f7	36 82		rol $82,x			rol 	2+XS_Mantissa+0,x
.c5f9	36 83		rol $83,x			rol 	3+XS_Mantissa+0,x
.c5fb	d6 84		dec $84,x			dec 	XS_Exponent,x 				; decrement exponent
.c5fd	d0 f0		bne $c5ef			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.c5ff					_FPUNSetZero:
.c5ff	a9 40		lda #$40			lda 	#$40
.c601	95 85		sta $85,x			sta 	XS_Type,x 					; the result is now zero.
.c603					_FPUNExit:
.c603	68		pla				pla
.c604	60		rts				rts
.c605					FPUToInteger:
.c605	48		pha				pha
.c606	b5 85		lda $85,x			lda 	XS_Type,x 					; if already integer, exit
.c608	29 01		and #$01			and 	#1
.c60a	d0 31		bne $c63d			bne 	_FPUTOI_Exit
.c60c	34 85		bit $85,x			bit 	XS_Type,x					; if zero, return zero.
.c60e	70 23		bvs $c633			bvs 	_FPUTOI_Zero
.c610	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.c612	10 1f		bpl $c633			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.c614	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.c616	b0 2b		bcs $c643			bcs 	FP_Overflow
.c618					_FPUToIToInteger:
.c618	b5 84		lda $84,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.c61a	c9 a0		cmp #$a0			cmp 	#128+32
.c61c	f0 0c		beq $c62a			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.c61e	f6 84		inc $84,x			inc 	XS_Exponent,X 				; increment Exponent
.c620	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.c622	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.c624	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.c626	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.c628	80 ee		bra $c618			bra 	_FPUToIToInteger 			; keep going.
.c62a					_FPUToICheckSign:
.c62a	b5 85		lda $85,x			lda 	XS_Type,x 					; check sign
.c62c	10 0f		bpl $c63d			bpl 	_FPUToI_Exit 				; exit if unsigned.
.c62e	20 9d c5	jsr $c59d			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.c631	80 0a		bra $c63d			bra 	_FPUTOI_Exit
.c633					_FPUTOI_Zero:
.c633	a9 00		lda #$00			lda 	#0 							; return zero integer.
.c635	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c637	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c639	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c63b	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c63d					_FPUToI_Exit:
.c63d	a9 01		lda #$01			lda 	#1 							; set type to integer
.c63f	95 85		sta $85,x			sta 	XS_Type,x
.c641	68		pla				pla
.c642	60		rts				rts
.c643					FP_Overflow:
.c643	20 e4 ad	jsr $ade4			jsr ERR_Handler
>c646	46 6c 6f 61 74 69 6e 67			.text "Floating Point overflow",0
>c64e	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.c65e					FPUTimes10:
.c65e	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.c660	85 1a		sta $1a				sta 	ZLTemp1+0
.c662	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c664	85 1b		sta $1b				sta 	ZLTemp1+1
.c666	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c668	85 1c		sta $1c				sta 	ZLTemp1+2
.c66a	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.c66c	85 1d		sta $1d				sta 	ZLTemp1+3
.c66e	20 a3 c6	jsr $c6a3			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.c671	20 a3 c6	jsr $c6a3			jsr 	_FPUT_LSR_ZLTemp1
.c674	18		clc				clc
.c675	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.c677	65 1a		adc $1a				adc 	ZLTemp1+0
.c679	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c67b	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c67d	65 1b		adc $1b				adc 	ZLTemp1+1
.c67f	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c681	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c683	65 1c		adc $1c				adc 	ZLTemp1+2
.c685	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c687	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.c689	65 1d		adc $1d				adc 	ZLTemp1+3
.c68b	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c68d	90 0a		bcc $c699			bcc 	_FPUTimes10
.c68f	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.c691	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.c693	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.c695	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.c697	f6 84		inc $84,x			inc 	XS_Exponent,x				; fix exponent
.c699					_FPUTimes10:
.c699	b5 84		lda $84,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.c69b	18		clc				clc
.c69c	69 03		adc #$03			adc 	#3
.c69e	95 84		sta $84,x			sta 	XS_Exponent,x
.c6a0	b0 a1		bcs $c643			bcs 	FP_Overflow 				; error
.c6a2	60		rts				rts
.c6a3					_FPUT_LSR_ZLTemp1:
.c6a3	46 1d		lsr $1d				lsr 	ZLTemp1+3
.c6a5	66 1c		ror $1c				ror 	ZLTemp1+2
.c6a7	66 1b		ror $1b				ror 	ZLTemp1+1
.c6a9	66 1a		ror $1a				ror 	ZLTemp1+0
.c6ab	60		rts				rts
.c6ac					FPUScale10A:
.c6ac	5a		phy				phy
.c6ad	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.c6af	f0 37		beq $c6e8			beq 	_FPUScaleExit
.c6b1	da		phx				phx 								; save X
.c6b2	e8		inx				inx
.c6b3	e8		inx				inx
.c6b4	e8		inx				inx
.c6b5	e8		inx				inx
.c6b6	e8		inx				inx
.c6b7	e8		inx				inx
.c6b8	a8		tay				tay 								; save power scalar in Y.
.c6b9	a9 00		lda #$00			lda 	#0
.c6bb	95 80		sta $80,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.c6bd	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c6bf	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c6c1	95 85		sta $85,x			sta 	XS_Type,x
.c6c3	a9 80		lda #$80			lda 	#$80
.c6c5	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c6c7	a9 81		lda #$81			lda 	#$81
.c6c9	95 84		sta $84,x			sta 	XS_Exponent,x
.c6cb	5a		phy				phy 								; save 10^n on stack.
.c6cc	c0 00		cpy #$00			cpy 	#0
.c6ce	10 05		bpl $c6d5			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.c6d0	98		tya				tya
.c6d1	49 ff		eor #$ff			eor 	#$FF
.c6d3	1a		inc a				inc 	a
.c6d4	a8		tay				tay
.c6d5					_FPUSAbs:
.c6d5	20 5e c6	jsr $c65e			jsr 	FPUTimes10
.c6d8	88		dey				dey
.c6d9	d0 fa		bne $c6d5			bne 	_FPUSAbs 					; tos is now 10^|AC|
.c6db	68		pla				pla 								; restore count in A
.c6dc	fa		plx				plx 								; restore X pointing to number to scale.
.c6dd	0a		asl a				asl 	a
.c6de	b0 05		bcs $c6e5			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.c6e0	20 3d c4	jsr $c43d			jsr 	FPMultiply 					; if clear multiply.
.c6e3	80 03		bra $c6e8			bra		_FPUScaleExit
.c6e5					_FPUSDivide:
.c6e5	20 ca c3	jsr $c3ca			jsr 	FPDivide
.c6e8					_FPUScaleExit:
.c6e8	7a		ply				ply
.c6e9	60		rts				rts
.c6ea					FPUCopyToNext:
.c6ea	a0 06		ldy #$06			ldy 		#6
.c6ec	da		phx				phx
.c6ed					_FPUCopy1:
.c6ed	b5 80		lda $80,x			lda 	XS_Mantissa,x
.c6ef	95 86		sta $86,x			sta 	XS2_Mantissa,x
.c6f1	e8		inx				inx
.c6f2	88		dey				dey
.c6f3	d0 f8		bne $c6ed			bne 	_FPUCopy1
.c6f5	fa		plx				plx
.c6f6	60		rts				rts
.c6f7					FPUCopyFromNext:
.c6f7	a0 06		ldy #$06			ldy 		#6
.c6f9	da		phx				phx
.c6fa					_FPUCopy1:
.c6fa	b5 86		lda $86,x			lda 	XS2_Mantissa,x
.c6fc	95 80		sta $80,x			sta 	XS_Mantissa,x
.c6fe	e8		inx				inx
.c6ff	88		dey				dey
.c700	d0 f8		bne $c6fa			bne 	_FPUCopy1
.c702	fa		plx				plx
.c703	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.c704					FPToString:
.c704	48		pha				pha
.c705	5a		phy				phy
.c706	34 85		bit $85,x			bit 		XS_Type,x 				; check zero flag
.c708	50 0a		bvc $c714			bvc 		_FPTSIsFloat 			; if zero,
.c70a					_FPTSZero:
.c70a	a9 30		lda #$30			lda 		#"0"
.c70c	20 6b c2	jsr $c26b			jsr 		ITSOutputCharacter
.c70f					_FPTSExit:
.c70f	7a		ply				ply
.c710	68		pla				pla
.c711	60		rts				rts
.c712	80 fb		bra $c70f			bra 		_FPTSExit
.c714					_FPTSIsFloat:
.c714	b5 85		lda $85,x			lda 		XS_Type,x 				; is it signed ?
.c716	10 09		bpl $c721			bpl 		_FPTSNotSigned
.c718	a9 00		lda #$00			lda 		#0 						; clear sign flag
.c71a	95 85		sta $85,x			sta 		XS_Type,x
.c71c	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.c71e	20 6b c2	jsr $c26b			jsr 		ITSOutputCharacter
.c721					_FPTSNotSigned:
.c721	b5 84		lda $84,x			lda 		XS_Exponent,x
.c723	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.c725	b0 09		bcs $c730			bcs 		_FPTSExponent
.c727	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.c729	90 05		bcc $c730			bcc 		_FPTSExponent 			;
.c72b					_FPTSStandard:
.c72b	20 6f c7	jsr $c76f			jsr 		FPTOutputBody 			; output the body.
.c72e	80 df		bra $c70f			bra 		_FPTSExit
.c730					_FPTSExponent:
.c730	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.c732	8d 9d 03	sta $039d			sta 		ExpCount
.c735					_FPTSExponentLoop:
.c735	b5 84		lda $84,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.c737	10 0e		bpl $c747			bpl 		_FPTSTimes
.c739	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.c73b	90 14		bcc $c751			bcc 		_FPTSScaledToExp
.c73d	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.c73f	20 ac c6	jsr $c6ac			jsr 		FPUScale10A
.c742	ee 9d 03	inc $039d			inc 		ExpCount
.c745	80 ee		bra $c735			bra 		_FPTSExponentLoop
.c747					_FPTSTimes:
.c747	a9 01		lda #$01			lda 		#1
.c749	20 ac c6	jsr $c6ac			jsr 		FPUScale10A
.c74c	ce 9d 03	dec $039d			dec 		ExpCount
.c74f	80 e4		bra $c735			bra 		_FPTSExponentLoop
.c751					_FPTSScaledToExp:
.c751	20 6f c7	jsr $c76f			jsr 		FPTOutputBody 			; output the body.
.c754	a9 65		lda #$65			lda 		#"e"					; output E
.c756	20 6b c2	jsr $c26b			jsr 		ITSOutputCharacter
.c759	ad 9d 03	lda $039d			lda 		ExpCount 				; get the exponent
.c75c	95 80		sta $80,x			sta 		XS_Mantissa,x
.c75e	29 80		and #$80			and 		#$80 					; sign extend it
.c760	f0 02		beq $c764			beq 		_FPTSSExt
.c762	a9 ff		lda #$ff			lda 		#$FF
.c764					_FPTSSExt:
.c764	95 81		sta $81,x			sta 		XS_Mantissa+1,x
.c766	95 82		sta $82,x			sta 		XS_Mantissa+2,x
.c768	95 83		sta $83,x			sta 		XS_Mantissa+3,x
.c76a	20 cd c1	jsr $c1cd			jsr 		INTToString 			; output the exponent.
.c76d	80 a0		bra $c70f			bra			_FPTSExit 				; and exit.
.c76f					FPTOutputBody:
.c76f	20 ea c6	jsr $c6ea			jsr 		FPUCopyToNext 			; copy to next slot.
.c772	20 05 c6	jsr $c605			jsr 		FPUToInteger 			; convert to an integer
.c775	20 cd c1	jsr $c1cd			jsr 		INTToString 			; output the main integer part.
.c778	20 f7 c6	jsr $c6f7			jsr 		FPUCopyFromNext 		; get the fractional part back.
.c77b	20 c5 c4	jsr $c4c5			jsr 		FPFractionalPart 		; get the decimal part.
.c77e	34 85		bit $85,x			bit 		XS_Type,x 				; any fractional part.
.c780	70 3c		bvs $c7be			bvs 		_FPTOExit 				; if not, exit now.
.c782	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.c784	20 6b c2	jsr $c26b			jsr 		ITSOutputCharacter
.c787					_FPOutLoop:
.c787	34 85		bit $85,x			bit 		XS_Type,x 				; finally reached zero.
.c789	70 1d		bvs $c7a8			bvs 		_FPStripZeros 			; strip trailing zeros
.c78b	20 5e c6	jsr $c65e			jsr 		FPUTimes10 				; multiply by 10
.c78e	20 ea c6	jsr $c6ea			jsr 		FPUCopyToNext			; copy to next slot.
.c791	20 05 c6	jsr $c605			jsr 		FPUToInteger 			; convert to integer
.c794	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; print digit.
.c796	09 30		ora #$30			ora 		#"0"
.c798	20 6b c2	jsr $c26b			jsr 		ITSOutputCharacter
.c79b	20 f7 c6	jsr $c6f7			jsr 		FPUCopyFromNext 		; get it back
.c79e	20 c5 c4	jsr $c4c5			jsr 		FPFractionalPart 		; get fractional part
.c7a1	ad 14 03	lda $0314			lda 		NumBufX 				; done 11 characters yet ?
.c7a4	c9 0b		cmp #$0b			cmp 	 	#11
.c7a6	90 df		bcc $c787			bcc 		_FPOutLoop 				; if so, keep going till zero.
.c7a8					_FPStripZeros:
.c7a8	ac 14 03	ldy $0314			ldy 		NumBufX 				; strip trailing zeros.
.c7ab					_FPStripLoop:
.c7ab	88		dey				dey 								; back one, if at start then no strip
.c7ac	f0 10		beq $c7be			beq 		_FPToExit
.c7ae	b9 15 03	lda $0315,y			lda 		Num_Buffer,y 			; keep going if "0"
.c7b1	c9 30		cmp #$30			cmp 		#"0"
.c7b3	f0 f6		beq $c7ab			beq 		_FPStripLoop
.c7b5	c8		iny				iny
.c7b6	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.c7b8	99 15 03	sta $0315,y			sta 		Num_Buffer,y
.c7bb	8c 14 03	sty $0314			sty 		NumBufX 				; update position.
.c7be					_FPTOExit:
.c7be	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.c7bf					FPFromString:
.c7bf	48		pha				pha 								; push A
.c7c0	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.c7c2	c9 2e		cmp #$2e			cmp 	#"."
.c7c4	f0 03		beq $c7c9			beq	 	_FPFIsDecimal
.c7c6	4c 25 c8	jmp $c825			jmp 	_FPFNotDecimal
.c7c9					_FPFIsDecimal:
.c7c9	c8		iny				iny 								; consume the decimal.
.c7ca	20 b9 c5	jsr $c5b9			jsr 	FPUToFloat 					; convert the integer to float.
.c7cd	da		phx				phx 								; save X.
.c7ce	5a		phy				phy 								; save decimal start position
.c7cf	e8		inx				inx
.c7d0	e8		inx				inx
.c7d1	e8		inx				inx
.c7d2	e8		inx				inx
.c7d3	e8		inx				inx
.c7d4	e8		inx				inx
.c7d5	20 83 c2	jsr $c283			jsr 	INTFromStringY 				; get the part after the DP.
.c7d8	20 b9 c5	jsr $c5b9			jsr 	FPUToFloat 					; convert that to a float.
.c7db	68		pla				pla 								; calculate - chars consumed.
.c7dc	8c 9c 03	sty $039c			sty 	ExpTemp
.c7df	38		sec				sec
.c7e0	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; this is the shift amount
.c7e3	20 ac c6	jsr $c6ac			jsr 	FPUScale10A 				; scale it by 10^AC
.c7e6	fa		plx				plx 								; restore original X
.c7e7	20 16 c3	jsr $c316			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.c7ea	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.c7ec	c9 45		cmp #$45			cmp 	#"E"
.c7ee	f0 04		beq $c7f4			beq 	_FPFExponent
.c7f0	c9 65		cmp #$65			cmp 	#"e"
.c7f2	d0 31		bne $c825			bne 	_FPFNotDecimal 				; no, then exit normally.
.c7f4					_FPFExponent:
.c7f4	c8		iny				iny 								; skip over E symbol.
.c7f5	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.c7f7	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.c7f9	d0 01		bne $c7fc			bne 	_FPFGotSign
.c7fb	c8		iny				iny 								; if it was - skip over it.
.c7fc					_FPFGotSign:
.c7fc	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.c7fd	da		phx				phx
.c7fe	e8		inx				inx
.c7ff	e8		inx				inx
.c800	e8		inx				inx
.c801	e8		inx				inx
.c802	e8		inx				inx
.c803	e8		inx				inx
.c804	20 83 c2	jsr $c283			jsr 	INTFromStringY 				; get the exponent
.c807	fa		plx				plx 								; restore X.
.c808	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.c80a	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.c80c	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.c80e	d0 17		bne $c827			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.c810	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.c812	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.c814	b0 11		bcs $c827			bcs 	_FPFXOverflow
.c816	68		pla				pla 								; get direction
.c817	d0 07		bne $c820			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.c819	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.c81b	49 ff		eor #$ff			eor 	#$FF
.c81d	1a		inc a				inc 	a
.c81e	95 86		sta $86,x			sta 	XS2_Mantissa+0,x
.c820					_FPFXScale:
.c820	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.c822	20 ac c6	jsr $c6ac			jsr 	FPUScale10A 				; scale by the exponent.
.c825					_FPFNotDecimal:
.c825	68		pla				pla
.c826	60		rts				rts
.c827					_FPFXOverflow:
.c827	20 e4 ad	jsr $ade4			jsr 	ERR_Handler
>c82a	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>c832	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.c839					Unary_Rnd:
.c839	20 19 b6	jsr $b619			jsr 	EvaluateNumberX 			; get value
.c83c	20 43 bc	jsr $bc43			jsr 	CheckNextRParen 			; check right bracket.
.c83f	20 97 b8	jsr $b897			jsr 	GetSignCurrent 				; get sign -1,0,1.
.c842	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.c844	30 10		bmi $c856			bmi 	_URSetSeed
.c846	f0 28		beq $c870			beq 	_URMakeRandom 				; if zero return same number.
.c848	da		phx				phx
.c849	a2 00		ldx #$00			ldx 	#0
.c84b	20 a7 c8	jsr $c8a7			jsr 	Random16
.c84e	a2 02		ldx #$02			ldx 	#2
.c850	20 a7 c8	jsr $c8a7			jsr 	Random16
.c853	fa		plx				plx
.c854	80 1a		bra $c870			bra 	_URMakeRandom
.c856					_URSetSeed:
.c856	20 b9 c5	jsr $c5b9			jsr 	FPUToFloat 					; make it a float to twiddle it.
.c859	b5 80		lda $80,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.c85b	8d a3 03	sta $03a3			sta 	RandomSeed+0
.c85e	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.c860	8d a4 03	sta $03a4			sta 	RandomSeed+1
.c863	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.c865	8d a5 03	sta $03a5			sta 	RandomSeed+2
.c868	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.c86a	0a		asl a				asl 	a
.c86b	49 db		eor #$db			eor 	#$DB
.c86d	8d a6 03	sta $03a6			sta 	RandomSeed+3
.c870					_URMakeRandom:
.c870	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; check if seed is zero.
.c873	0d a4 03	ora $03a4			ora 	RandomSeed+1
.c876	0d a5 03	ora $03a5			ora 	RandomSeed+2
.c879	0d a6 03	ora $03a6			ora 	RandomSeed+3
.c87c	d0 0a		bne $c888			bne 	_URNotZero
.c87e	a9 47		lda #$47			lda 	#$47
.c880	8d a4 03	sta $03a4			sta 	RandomSeed+1				; if it is, make it non zero.
.c883	a9 3d		lda #$3d			lda 	#$3D
.c885	8d a6 03	sta $03a6			sta 	RandomSeed+3
.c888					_URNotZero:
.c888	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; copy seed into mantissa.
.c88b	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c88d	ad a4 03	lda $03a4			lda 	RandomSeed+1
.c890	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c892	ad a5 03	lda $03a5			lda 	RandomSeed+2
.c895	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c897	ad a6 03	lda $03a6			lda 	RandomSeed+3
.c89a	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c89c	a9 00		lda #$00			lda 	#$00 						; set type to float.
.c89e	95 85		sta $85,x			sta 	XS_Type,x
.c8a0	a9 80		lda #$80			lda 	#$80
.c8a2	95 84		sta $84,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.c8a4	4c e6 c5	jmp $c5e6			jmp 	FPUNormalise
.c8a7					Random16:
.c8a7	5e a4 03	lsr $03a4,x			lsr 	RandomSeed+1,x				; shift seed right
.c8aa	7e a3 03	ror $03a3,x			ror 	RandomSeed,x
.c8ad	90 08		bcc $c8b7			bcc 	_R16_NoXor
.c8af	bd a4 03	lda $03a4,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.c8b2	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.c8b4	9d a4 03	sta $03a4,x			sta 	RandomSeed+1,x
.c8b7					_R16_NoXor:
.c8b7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.c8b8					Unary_Int:
.c8b8	20 19 b6	jsr $b619			jsr 	EvaluateNumberX 			; get value
.c8bb	20 43 bc	jsr $bc43			jsr 	CheckNextRParen 			; check right bracket.
.c8be	4c 05 c6	jmp $c605			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Return to file: basic.asm

.c8c1	80 fe		bra $c8c1	_halt:	bra 		_halt
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 a0						.word 	StartROM
>fffe	95 ac					.word TIM_BreakVector

;******  End of listing
