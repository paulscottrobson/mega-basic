
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Sun Sep  1 18:13:33 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="65816"				cpu = "65816"
="em65816"				hardware = "em65816"
=1					exitonend = 1
=1					autorun = 1
=2					loadtest = 2
=1					hasfloat = 1
=1					hasinteger = 1
=253					maxstring = 253

;******  Processing file: modules/basic/pointer/em65816/src_em65816.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stackmarkers.inc

=5					SourcePosSize   =   5 							; Source position stack space needed.
=1					SMark_Gosub 	= 	1 							; 0 is GOSUB/RETURN.
=2					SMark_Repeat 	= 	2 							; 1 is REPEAT/UNTIL.
=3					SMark_While 	= 	3 							; 2 is WHILE/WEND.
=4					SMark_If 		= 	4 							; 3 is IF/ENDIF
=5					SMark_For 		= 	5 							; 4 is FOR/NEXT

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/hardware/common/macros32.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0020					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0022					zVarDataPtr: .word ? 						; position of variable data.
>0024					zVarType: 	.byte ? 						; type of data (token)
>0025					zNullString:.byte ? 						; represents a NULL string.
>0026					zBasicSP:	.word ? 						; stack pointer
>0080					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>0084					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>0085					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=134					XS2_Mantissa = XS_Mantissa+XS_Size
=138					XS2_Exponent = XS_Exponent+XS_Size
=139					XS2_Type = XS_Type+XS_Size
=140					XS3_Mantissa = XS_Mantissa+XS_Size*2
=144					XS3_Exponent = XS_Exponent+XS_Size*2
=145					XS3_Type = XS_Type+XS_Size*2
>0300					StringPtr:	.word ? 						; Top of free memory (for string allocation)
>0302					VarMemPtr: 	.word ?							; Bottom of free memory (for variables)
>0304					endOfProgram: .dword ? 						; End of Program Memory (long)
>0308					vecPrintCharacter .word ?
>030a					vecInputCharacter .word ?
>030c					UserVector .fill 4 							; USR(x) calls this.
>0310					LocalVector .fill 4 						; Indirect calls call this.
>0314					NumBufX 	.byte 	?						; buffer index position
>0315					Num_Buffer	.fill 	32 						; buffer for numeric conversions
=6					HashTableCount = 6 							; there are 6 hash tables, in token order.
=8					HashTableSize = 8 							; each hash table as 8 links.
.0335					HashTableBase:
>0335								.fill	HashTableCount * HashTableSize * 2
.0395					HashTableEnd:
=$315					Var_Buffer 	= Num_Buffer 					; buffer for variable name (same space)
>0395					Var_Type    .byte ? 						; type of variable (as a type token)
>0396					Var_Hash 	.byte ? 						; hash of identifier name.
>0397					Var_Length 	.byte ? 						; length of variable name
>0398					Var_HashAddress .byte ?						; low byte of hash table entry.
>0399					Var_DataSize .byte ?						; size of one element.
>039a					NumSuppress	.byte 	?						; leading zero suppression flag
>039b					NumConvCount .byte 	? 						; count for conversions.
>039c					ExpTemp:	.byte ?							; Working temp for exponents.
>039d					ExpCount:	.byte ? 						; Count of decimal exponents.
>039e					SignCount:	.byte ?							; Integer Divide Sign Counts.
>039f					TempStringWriteIndex: .byte ? 				; Write offset.
>03a0					ValSign: 	.byte ? 						; sign flag for val()
>03a1					SliceStart:	.byte ? 						; string slice parts
>03a2					SliceCount:	.byte ?
>03a3					RandomSeed:	.dword ? 						; Random seed.
>03a7					SignNext:	.byte ? 						; Used for keeping sign of STEP in FOR/NEXT
>03a8					BreakCount:	.byte ? 						; Counter, avoid checking break every command.
=3					ArrayMaxDim = 3 							; number of dimensions.
>03a9					ArrayDef:	.fill (ArrayMaxDim+1)*2 		; dimensions for auto-creation
>03b1					UsrArrayDef:.fill (ArrayMaxDim+1)*2 		; dimensions created in DIM
>03b9					UsrArrayIdx:.byte ? 						; index into UsrArrayDef
>03ba					LastPrinted:.byte ? 						; last printed char ?
>03bb					ListIndent: .byte ? 						; list indent level
>03bc					LastListIndent:.byte ? 						; previous one.
>03bd					DataLPtr: 	.dword ?						; the data long ptr (swapped with zCodePtr)
>03c1					DataIndex:	.byte ?							; index position.
>03c2					InputAvailable: .byte ? 					; characters available in input buffer.
>03c3					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>03c5					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>03c7					Tim_SR:		.byte ? 						; Processor Status
>03c8					Tim_A:		.byte ? 						; Processor Registers
>03c9					Tim_X:		.byte ?
>03ca					Tim_Y:		.byte ?
>03cb					Tim_Z:		.byte ?
>03cc					Tim_SP:		.word ?							; Stack Pointer (just in cases)
>0400					BasicStack:	.fill 	256 					; and occupy whole pages.
.0500					EndBasicStack:
>0500					IFT_XCursor:.byte ?							; current logical position on screen
>0501					IFT_YCursor:.byte ?
>0502					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0566					IFT_LineBuffer: .fill 100 					; line input buffer.

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/em65816.asm

=$7f00					HighMemory = $7F00
=$3000					VariableMemory = $3000
.1000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testing.src

>1000	1d 0a 00 dc bd 41 7c 53			.byte	$1d,$0a,$00,$dc,$bd,$41,$7c,$53
>1008	42 fd 04 37 37 8a 40 fd			.byte	$42,$fd,$04,$37,$37,$8a,$40,$fd
>1010	03 30 be 84 41 7c 53 42			.byte	$03,$30,$be,$84,$41,$7c,$53,$42
>1018	fd 04 37 37 00 0f 14 00			.byte	$fd,$04,$37,$37,$00,$0f,$14,$00
>1020	dc bd 8b 7f 42 42 88 40			.byte	$dc,$bd,$8b,$7f,$42,$42,$88,$40
>1028	be 84 40 00 14 1e 00 dc			.byte	$be,$84,$40,$00,$14,$1e,$00,$dc
>1030	bd 41 6f 4f 7f 80 42 73			.byte	$bd,$41,$6f,$4f,$7f,$80,$42,$73
>1038	7f 47 be 84 63 4f 47 00			.byte	$7f,$47,$be,$84,$63,$4f,$47,$00
>1040	0e 28 00 dc 9a 65 55 5d			.byte	$0e,$28,$00,$dc,$9a,$65,$55,$5d
>1048	be 84 65 55 5d 00 16 32			.byte	$be,$84,$65,$55,$5d,$00,$16,$32
>1050	00 dc a0 fe 06 61 64 64			.byte	$00,$dc,$a0,$fe,$06,$61,$64,$64
>1058	6a bf 47 be 84 fe 06 61			.byte	$6a,$bf,$47,$be,$84,$fe,$06,$61
>1060	64 64 6a 00 1b 3c 00 dc			.byte	$64,$64,$6a,$00,$1b,$3c,$00,$dc
>1068	bd 43 53 6a 44 fd 04 39			.byte	$bd,$43,$53,$6a,$44,$fd,$04,$39
>1070	33 85 42 61 4d 77 fd 04			.byte	$33,$85,$42,$61,$4d,$77,$fd,$04
>1078	31 34 be 84 8b 41 00 13			.byte	$31,$34,$be,$84,$8b,$41,$00,$13
>1080	46 00 dc bd 41 73 57 77			.byte	$46,$00,$dc,$bd,$41,$73,$57,$77
>1088	89 8b 54 66 42 be 84 8b			.byte	$89,$8b,$54,$66,$42,$be,$84,$8b
>1090	41 00 15 50 00 dc bd 41			.byte	$41,$00,$15,$50,$00,$dc,$bd,$41
>1098	67 7f 7a 80 41 66 67 6c			.byte	$67,$7f,$7a,$80,$41,$66,$67,$6c
>10a0	be 84 41 66 67 68 00 0f			.byte	$be,$84,$41,$66,$67,$68,$00,$0f
>10a8	5a 00 dc b3 8b 42 69 55			.byte	$5a,$00,$dc,$b3,$8b,$42,$69,$55
>10b0	68 be 84 8b 41 00 16 64			.byte	$68,$be,$84,$8b,$41,$00,$16,$64
>10b8	00 dc a1 fe 06 73 76 61			.byte	$00,$dc,$a1,$fe,$06,$73,$76,$61
>10c0	71 bf 49 be 84 fe 06 73			.byte	$71,$bf,$49,$be,$84,$fe,$06,$73
>10c8	76 61 71 00 22 6e 00 dc			.byte	$76,$61,$71,$00,$22,$6e,$00,$dc
>10d0	bd 8b 41 40 54 76 fd 04			.byte	$bd,$8b,$41,$40,$54,$76,$fd,$04
>10d8	39 35 8b 74 72 64 fd 04			.byte	$39,$35,$8b,$74,$72,$64,$fd,$04
>10e0	36 39 be 84 8b 41 75 47			.byte	$36,$39,$be,$84,$8b,$41,$75,$47
>10e8	5b fd 04 36 34 00 11 78			.byte	$5b,$fd,$04,$36,$34,$00,$11,$78
>10f0	00 dc bd 43 5e 6d 49 84			.byte	$00,$dc,$bd,$43,$5e,$6d,$49,$84
>10f8	6c 44 60 be 84 40 00 15			.byte	$6c,$44,$60,$be,$84,$40,$00,$15
>1100	82 00 dc bd 8b 5b 6c 43			.byte	$82,$00,$dc,$bd,$8b,$5b,$6c,$43
>1108	80 43 55 4d 4e be 84 43			.byte	$80,$43,$55,$4d,$4e,$be,$84,$43
>1110	44 41 4c 00 18 8c 00 dc			.byte	$44,$41,$4c,$00,$18,$8c,$00,$dc
>1118	a2 fe 07 7a 68 77 75 77			.byte	$a2,$fe,$07,$7a,$68,$77,$75,$77
>1120	bf 43 bf 43 be 84 fe 05			.byte	$bf,$43,$bf,$43,$be,$84,$fe,$05
>1128	77 75 77 00 1b 96 00 dc			.byte	$77,$75,$77,$00,$1b,$96,$00,$dc
>1130	bd 41 45 4d 7a fd 04 30			.byte	$bd,$41,$45,$4d,$7a,$fd,$04,$30
>1138	37 87 43 6c 7f 7b fd 04			.byte	$37,$87,$43,$6c,$7f,$7b,$fd,$04
>1140	31 39 be 84 8b 41 00 11			.byte	$31,$39,$be,$84,$8b,$41,$00,$11
>1148	a0 00 dc bd 42 6d 64 4b			.byte	$a0,$00,$dc,$bd,$42,$6d,$64,$4b
>1150	87 7f 54 67 be 84 40 00			.byte	$87,$7f,$54,$67,$be,$84,$40,$00
>1158	15 aa 00 dc bd 41 58 72			.byte	$15,$aa,$00,$dc,$bd,$41,$58,$72
>1160	75 80 8b 61 6f 6a be 84			.byte	$75,$80,$8b,$61,$6f,$6a,$be,$84
>1168	41 58 50 54 00 0a b4 00			.byte	$41,$58,$50,$54,$00,$0a,$b4,$00
>1170	dc 98 40 84 8b 41 00 12			.byte	$dc,$98,$40,$84,$8b,$41,$00,$12
>1178	be 00 dc a6 fe 09 62 72			.byte	$be,$00,$dc,$a6,$fe,$09,$62,$72
>1180	6a 74 77 61 62 be 84 47			.byte	$6a,$74,$77,$61,$62,$be,$84,$47
>1188	00 18 c8 00 dc bd 40 fd			.byte	$00,$18,$c8,$00,$dc,$bd,$40,$fd
>1190	03 30 85 8b 42 6b 70 59			.byte	$03,$30,$85,$8b,$42,$6b,$70,$59
>1198	fd 04 38 32 be 84 8b 41			.byte	$fd,$04,$38,$32,$be,$84,$8b,$41
>11a0	00 15 d2 00 dc bd 8b 42			.byte	$00,$15,$d2,$00,$dc,$bd,$8b,$42
>11a8	6f 79 46 87 8b 42 6f 79			.byte	$6f,$79,$46,$87,$8b,$42,$6f,$79
>11b0	46 be 84 8b 41 00 17 dc			.byte	$46,$be,$84,$8b,$41,$00,$17,$dc
>11b8	00 dc bd 8b 41 62 42 67			.byte	$00,$dc,$bd,$8b,$41,$62,$42,$67
>11c0	82 42 43 74 78 be 84 8b			.byte	$82,$42,$43,$74,$78,$be,$84,$8b
>11c8	43 61 76 5f 00 12 e6 00			.byte	$43,$61,$76,$5f,$00,$12,$e6,$00
>11d0	dc a5 a4 40 fd 03 30 be			.byte	$dc,$a5,$a4,$40,$fd,$03,$30,$be
>11d8	be 84 40 fd 03 30 00 10			.byte	$be,$84,$40,$fd,$03,$30,$00,$10
>11e0	f0 00 dc 9b fe 06 77 67			.byte	$f0,$00,$dc,$9b,$fe,$06,$77,$67
>11e8	71 6b be 84 41 77 00 21			.byte	$71,$6b,$be,$84,$41,$77,$00,$21
>11f0	fa 00 dc bd 6e 66 62 fd			.byte	$fa,$00,$dc,$bd,$6e,$66,$62,$fd
>11f8	04 33 32 8b 43 61 4e 40			.byte	$04,$33,$32,$8b,$43,$61,$4e,$40
>1200	fd 04 33 33 be 84 8b 42			.byte	$fd,$04,$33,$33,$be,$84,$8b,$42
>1208	72 67 5e fd 04 30 32 00			.byte	$72,$67,$5e,$fd,$04,$30,$32,$00
>1210	16 04 01 dc bd 8b 42 74			.byte	$16,$04,$01,$dc,$bd,$8b,$42,$74
>1218	51 45 8b 56 5d 69 be 84			.byte	$51,$45,$8b,$56,$5d,$69,$be,$84
>1220	8b 43 4a 6e 6e 00 15 0e			.byte	$8b,$43,$4a,$6e,$6e,$00,$15,$0e
>1228	01 dc bd 8b 4f 71 56 81			.byte	$01,$dc,$bd,$8b,$4f,$71,$56,$81
>1230	42 43 6c 5e be 84 8b 4c			.byte	$42,$43,$6c,$5e,$be,$84,$8b,$4c
>1238	51 42 00 11 18 01 dc 9a			.byte	$51,$42,$00,$11,$18,$01,$dc,$9a
>1240	8b 42 5b 60 45 be 84 42			.byte	$8b,$42,$5b,$60,$45,$be,$84,$42
>1248	5b 60 45 00 0c 22 01 dc			.byte	$5b,$60,$45,$00,$0c,$22,$01,$dc
>1250	b4 64 be 84 fe 03 24 00			.byte	$b4,$64,$be,$84,$fe,$03,$24,$00
>1258	19 2c 01 dc bd 43 71 64			.byte	$19,$2c,$01,$dc,$bd,$43,$71,$64
>1260	4e fd 03 32 84 8b 62 5a			.byte	$4e,$fd,$03,$32,$84,$8b,$62,$5a
>1268	7e fd 04 33 32 be 84 40			.byte	$7e,$fd,$04,$33,$32,$be,$84,$40
>1270	00 14 36 01 dc bd 8b 42			.byte	$00,$14,$36,$01,$dc,$bd,$8b,$42
>1278	4d 59 40 8d 8b 42 7d 6d			.byte	$4d,$59,$40,$8d,$8b,$42,$7d,$6d
>1280	4d be 84 40 00 0f 40 01			.byte	$4d,$be,$84,$40,$00,$0f,$40,$01
>1288	dc bd 8b 6b 76 6b 80 40			.byte	$dc,$bd,$8b,$6b,$76,$6b,$80,$40
>1290	be 84 40 00 0a 4a 01 dc			.byte	$be,$84,$40,$00,$0a,$4a,$01,$dc
>1298	b3 40 be 84 40 00 1e 54			.byte	$b3,$40,$be,$84,$40,$00,$1e,$54
>12a0	01 dc a3 53 be 84 fe 15			.byte	$01,$dc,$a3,$53,$be,$84,$fe,$15
>12a8	20 20 20 20 20 20 20 20			.byte	$20,$20,$20,$20,$20,$20,$20,$20
>12b0	20 20 20 20 20 20 20 20			.byte	$20,$20,$20,$20,$20,$20,$20,$20
>12b8	20 20 20 00 1b 5e 01 dc			.byte	$20,$20,$20,$00,$1b,$5e,$01,$dc
>12c0	bd 8b 41 6e 5a 63 fd 04			.byte	$bd,$8b,$41,$6e,$5a,$63,$fd,$04
>12c8	32 32 86 61 6e 4d fd 04			.byte	$32,$32,$86,$61,$6e,$4d,$fd,$04
>12d0	37 32 be 84 8b 41 00 11			.byte	$37,$32,$be,$84,$8b,$41,$00,$11
>12d8	68 01 dc bd 40 85 8b 43			.byte	$68,$01,$dc,$bd,$40,$85,$8b,$43
>12e0	64 5b 70 be 84 8b 41 00			.byte	$64,$5b,$70,$be,$84,$8b,$41,$00
>12e8	14 72 01 dc bd 53 4c 41			.byte	$14,$72,$01,$dc,$bd,$53,$4c,$41
>12f0	82 8b 63 76 5c be 84 8b			.byte	$82,$8b,$63,$76,$5c,$be,$84,$8b
>12f8	70 7a 5b 00 14 7c 01 dc			.byte	$70,$7a,$5b,$00,$14,$7c,$01,$dc
>1300	b2 7a 6b 43 bf 8b 42 4c			.byte	$b2,$7a,$6b,$43,$bf,$8b,$42,$4c
>1308	49 69 be 84 7a 6b 43 00			.byte	$49,$69,$be,$84,$7a,$6b,$43,$00
>1310	12 86 01 dc a7 77 5c 43			.byte	$12,$86,$01,$dc,$a7,$77,$5c,$43
>1318	be 84 fe 07 33 37 37 30			.byte	$be,$84,$fe,$07,$33,$37,$37,$30
>1320	33 00 19 90 01 dc bd 40			.byte	$33,$00,$19,$90,$01,$dc,$bd,$40
>1328	fd 03 30 8d 41 46 7a 61			.byte	$fd,$03,$30,$8d,$41,$46,$7a,$61
>1330	fd 04 35 39 be 84 40 fd			.byte	$fd,$04,$35,$39,$be,$84,$40,$fd
>1338	03 30 00 13 9a 01 dc bd			.byte	$03,$30,$00,$13,$9a,$01,$dc,$bd
>1340	8b 63 7b 6d 85 42 71 5a			.byte	$8b,$63,$7b,$6d,$85,$42,$71,$5a
>1348	7f be 84 8b 41 00 10 a4			.byte	$7f,$be,$84,$8b,$41,$00,$10,$a4
>1350	01 dc bd 40 82 78 7e 66			.byte	$01,$dc,$bd,$40,$82,$78,$7e,$66
>1358	be 84 78 7e 66 00 10 ae			.byte	$be,$84,$78,$7e,$66,$00,$10,$ae
>1360	01 dc 98 43 66 69 44 84			.byte	$01,$dc,$98,$43,$66,$69,$44,$84
>1368	8b 43 66 69 45 00 11 b8			.byte	$8b,$43,$66,$69,$45,$00,$11,$b8
>1370	01 dc af fe 06 31 42 43			.byte	$01,$dc,$af,$fe,$06,$31,$42,$43
>1378	41 be 84 41 6f 4a 00 1b			.byte	$41,$be,$84,$41,$6f,$4a,$00,$1b
>1380	c2 01 dc bd 43 53 65 69			.byte	$c2,$01,$dc,$bd,$43,$53,$65,$69
>1388	fd 04 39 32 87 43 53 65			.byte	$fd,$04,$39,$32,$87,$43,$53,$65
>1390	69 fd 04 39 32 be 84 8b			.byte	$69,$fd,$04,$39,$32,$be,$84,$8b
>1398	41 00 11 cc 01 dc bd 8b			.byte	$41,$00,$11,$cc,$01,$dc,$bd,$8b
>13a0	42 7a 49 78 86 40 be 84			.byte	$42,$7a,$49,$78,$86,$40,$be,$84
>13a8	8b 41 00 14 d6 01 dc bd			.byte	$8b,$41,$00,$14,$d6,$01,$dc,$bd
>13b0	8b 55 5d 67 81 41 57 72			.byte	$8b,$55,$5d,$67,$81,$41,$57,$72
>13b8	6f be 84 8b 4d 41 00 1c			.byte	$6f,$be,$84,$8b,$4d,$41,$00,$1c
>13c0	e0 01 dc a5 a4 8b 41 7c			.byte	$e0,$01,$dc,$a5,$a4,$8b,$41,$7c
>13c8	68 58 fd 04 30 36 be be			.byte	$68,$58,$fd,$04,$30,$36,$be,$be
>13d0	84 8b 41 7c 68 58 fd 04			.byte	$84,$8b,$41,$7c,$68,$58,$fd,$04
>13d8	30 36 00 1e ea 01 dc a0			.byte	$30,$36,$00,$1e,$ea,$01,$dc,$a0
>13e0	fe 0b 6e 6d 71 64 65 6f			.byte	$fe,$0b,$6e,$6d,$71,$64,$65,$6f
>13e8	6f 65 6b bf 47 be 84 fe			.byte	$6f,$65,$6b,$bf,$47,$be,$84,$fe
>13f0	09 6e 6d 71 64 65 6f 6f			.byte	$09,$6e,$6d,$71,$64,$65,$6f,$6f
>13f8	00 1c f4 01 dc bd 8b 42			.byte	$00,$1c,$f4,$01,$dc,$bd,$8b,$42
>1400	51 51 50 fd 04 35 33 85			.byte	$51,$51,$50,$fd,$04,$35,$33,$85
>1408	41 79 45 40 fd 04 35 34			.byte	$41,$79,$45,$40,$fd,$04,$35,$34
>1410	be 84 8b 41 00 15 fe 01			.byte	$be,$84,$8b,$41,$00,$15,$fe,$01
>1418	dc bd 42 69 62 61 8a 42			.byte	$dc,$bd,$42,$69,$62,$61,$8a,$42
>1420	7d 48 74 be 84 45 66 6b			.byte	$7d,$48,$74,$be,$84,$45,$66,$6b
>1428	55 00 12 08 02 dc bd 8b			.byte	$55,$00,$12,$08,$02,$dc,$bd,$8b
>1430	63 68 7f 81 40 be 84 8b			.byte	$63,$68,$7f,$81,$40,$be,$84,$8b
>1438	63 68 7f 00 11 12 02 dc			.byte	$63,$68,$7f,$00,$11,$12,$02,$dc
>1440	9a 8b 43 44 7c 6b be 84			.byte	$9a,$8b,$43,$44,$7c,$6b,$be,$84
>1448	43 44 7c 6b 00 0e 1c 02			.byte	$43,$44,$7c,$6b,$00,$0e,$1c,$02
>1450	dc a1 fe 02 bf 40 be 84			.byte	$dc,$a1,$fe,$02,$bf,$40,$be,$84
>1458	fe 02 00 29 26 02 dc bd			.byte	$fe,$02,$00,$29,$26,$02,$dc,$bd
>1460	8b 43 6a 65 71 fd 04 32			.byte	$8b,$43,$6a,$65,$71,$fd,$04,$32
>1468	32 8c 42 71 73 45 fd 04			.byte	$32,$8c,$42,$71,$73,$45,$fd,$04
>1470	31 39 be 84 8b 46 fd 0d			.byte	$31,$39,$be,$84,$8b,$46,$fd,$0d
>1478	39 39 37 37 32 34 39 35			.byte	$39,$39,$37,$37,$32,$34,$39,$35
>1480	65 31 31 00 14 30 02 dc			.byte	$65,$31,$31,$00,$14,$30,$02,$dc
>1488	bd 8b 42 40 5c 7b 84 8b			.byte	$bd,$8b,$42,$40,$5c,$7b,$84,$8b
>1490	42 5a 6f 79 be 84 40 00			.byte	$42,$5a,$6f,$79,$be,$84,$40,$00
>1498	16 3a 02 dc bd 65 55 41			.byte	$16,$3a,$02,$dc,$bd,$65,$55,$41
>14a0	81 8b 43 49 5c 46 be 84			.byte	$81,$8b,$43,$49,$5c,$46,$be,$84
>14a8	8b 43 48 48 45 00 0e 44			.byte	$8b,$43,$48,$48,$45,$00,$0e,$44
>14b0	02 dc b3 8b 63 7e 65 be			.byte	$02,$dc,$b3,$8b,$63,$7e,$65,$be
>14b8	84 8b 41 00 1c 4e 02 dc			.byte	$84,$8b,$41,$00,$1c,$4e,$02,$dc
>14c0	a2 fe 09 6f 6e 61 70 79			.byte	$a2,$fe,$09,$6f,$6e,$61,$70,$79
>14c8	6a 72 bf 43 bf 45 be 84			.byte	$6a,$72,$bf,$43,$bf,$45,$be,$84
>14d0	fe 07 61 70 79 6a 72 00			.byte	$fe,$07,$61,$70,$79,$6a,$72,$00
>14d8	17 58 02 dc bd 40 fd 03			.byte	$17,$58,$02,$dc,$bd,$40,$fd,$03
>14e0	30 86 41 73 48 4a fd 04			.byte	$30,$86,$41,$73,$48,$4a,$fd,$04
>14e8	38 38 be 84 8b 41 00 15			.byte	$38,$38,$be,$84,$8b,$41,$00,$15
>14f0	62 02 dc bd 41 50 42 69			.byte	$62,$02,$dc,$bd,$41,$50,$42,$69
>14f8	8b 8b 65 65 7e be 84 41			.byte	$8b,$8b,$65,$65,$7e,$be,$84,$41
>1500	75 68 67 00 14 6c 02 dc			.byte	$75,$68,$67,$00,$14,$6c,$02,$dc
>1508	bd 42 77 4f 58 82 42 66			.byte	$bd,$42,$77,$4f,$58,$82,$42,$66
>1510	61 65 be 84 51 6e 7d 00			.byte	$61,$65,$be,$84,$51,$6e,$7d,$00
>1518	14 76 02 dc b2 8b 55 59			.byte	$14,$76,$02,$dc,$b2,$8b,$55,$59
>1520	4f bf 42 4b 7d 65 be 84			.byte	$4f,$bf,$42,$4b,$7d,$65,$be,$84
>1528	55 59 4f 00 0b 80 02 dc			.byte	$55,$59,$4f,$00,$0b,$80,$02,$dc
>1530	a6 fe 02 be 84 40 00 1b			.byte	$a6,$fe,$02,$be,$84,$40,$00,$1b
>1538	8a 02 dc bd 41 52 74 64			.byte	$8a,$02,$dc,$bd,$41,$52,$74,$64
>1540	fd 04 37 35 87 41 52 74			.byte	$fd,$04,$37,$35,$87,$41,$52,$74
>1548	64 fd 04 37 35 be 84 8b			.byte	$64,$fd,$04,$37,$35,$be,$84,$8b
>1550	41 00 10 94 02 dc bd 8b			.byte	$41,$00,$10,$94,$02,$dc,$bd,$8b
>1558	43 5f 69 7f 8c 40 be 84			.byte	$43,$5f,$69,$7f,$8c,$40,$be,$84
>1560	40 00 15 9e 02 dc bd 42			.byte	$40,$00,$15,$9e,$02,$dc,$bd,$42
>1568	63 47 6f 81 8b 7f 42 56			.byte	$63,$47,$6f,$81,$8b,$7f,$42,$56
>1570	be 84 8b 5c 40 51 00 10			.byte	$be,$84,$8b,$5c,$40,$51,$00,$10
>1578	a8 02 dc 98 8b 42 7a 78			.byte	$a8,$02,$dc,$98,$8b,$42,$7a,$78
>1580	57 84 42 7a 78 56 00 12			.byte	$57,$84,$42,$7a,$78,$56,$00,$12
>1588	b2 02 dc 9b fe 08 74 6c			.byte	$b2,$02,$dc,$9b,$fe,$08,$74,$6c
>1590	78 6c 6f 71 be 84 41 74			.byte	$78,$6c,$6f,$71,$be,$84,$41,$74
>1598	00 22 bc 02 dc bd 8b 41			.byte	$00,$22,$bc,$02,$dc,$bd,$8b,$41
>15a0	7d 77 76 fd 04 32 32 8a			.byte	$7d,$77,$76,$fd,$04,$32,$32,$8a
>15a8	41 5f 76 40 fd 04 34 34			.byte	$41,$5f,$76,$40,$fd,$04,$34,$34
>15b0	be 84 8b 5e 41 75 fd 04			.byte	$be,$84,$8b,$5e,$41,$75,$fd,$04
>15b8	37 38 00 14 c6 02 dc bd			.byte	$37,$38,$00,$14,$c6,$02,$dc,$bd
>15c0	8b 41 70 7a 40 84 8b 42			.byte	$8b,$41,$70,$7a,$40,$84,$8b,$42
>15c8	60 6b 7e be 84 40 00 17			.byte	$60,$6b,$7e,$be,$84,$40,$00,$17
>15d0	d0 02 dc bd 41 42 7f 5e			.byte	$d0,$02,$dc,$bd,$41,$42,$7f,$5e
>15d8	81 8b 42 43 4e 7f be 84			.byte	$81,$8b,$42,$43,$4e,$7f,$be,$84
>15e0	8b 42 41 40 61 00 1a da			.byte	$8b,$42,$41,$40,$61,$00,$1a,$da
>15e8	02 dc a5 a4 44 41 54 fd			.byte	$02,$dc,$a5,$a4,$44,$41,$54,$fd
>15f0	05 35 30 31 be be 84 44			.byte	$05,$35,$30,$31,$be,$be,$84,$44
>15f8	41 54 fd 05 35 30 31 00			.byte	$41,$54,$fd,$05,$35,$30,$31,$00
>1600	0d e4 02 dc b4 41 71 be			.byte	$0d,$e4,$02,$dc,$b4,$41,$71,$be
>1608	84 fe 03 71 00 17 ee 02			.byte	$84,$fe,$03,$71,$00,$17,$ee,$02
>1610	dc bd 8b 43 6f 5f 69 fd			.byte	$dc,$bd,$8b,$43,$6f,$5f,$69,$fd
>1618	04 30 35 89 40 fd 03 30			.byte	$04,$30,$35,$89,$40,$fd,$03,$30
>1620	be 84 40 00 13 f8 02 dc			.byte	$be,$84,$40,$00,$13,$f8,$02,$dc
>1628	bd 8b 41 72 60 6f 89 41			.byte	$bd,$8b,$41,$72,$60,$6f,$89,$41
>1630	6e 46 49 be 84 40 00 14			.byte	$6e,$46,$49,$be,$84,$40,$00,$14
>1638	02 03 dc bd 8b 43 53 56			.byte	$02,$03,$dc,$bd,$8b,$43,$53,$56
>1640	7f 80 7e 66 46 be 84 6c			.byte	$7f,$80,$7e,$66,$46,$be,$84,$6c
>1648	60 40 00 10 0c 03 dc 9a			.byte	$60,$40,$00,$10,$0c,$03,$dc,$9a
>1650	43 53 64 4d be 84 43 53			.byte	$43,$53,$64,$4d,$be,$84,$43,$53
>1658	64 4d 00 0f 16 03 dc a3			.byte	$64,$4d,$00,$0f,$16,$03,$dc,$a3
>1660	44 be 84 fe 06 20 20 20			.byte	$44,$be,$84,$fe,$06,$20,$20,$20
>1668	20 00 1d 20 03 dc bd 8b			.byte	$20,$00,$1d,$20,$03,$dc,$bd,$8b
>1670	41 63 7f 65 fd 04 33 38			.byte	$41,$63,$7f,$65,$fd,$04,$33,$38
>1678	87 8b 56 46 5e fd 05 34			.byte	$87,$8b,$56,$46,$5e,$fd,$05,$34
>1680	33 34 be 84 8b 41 00 10			.byte	$33,$34,$be,$84,$8b,$41,$00,$10
>1688	2a 03 dc bd 61 6a 48 8d			.byte	$2a,$03,$dc,$bd,$61,$6a,$48,$8d
>1690	61 6a 48 be 84 41 00 17			.byte	$61,$6a,$48,$be,$84,$41,$00,$17
>1698	34 03 dc bd 8b 41 51 68			.byte	$34,$03,$dc,$bd,$8b,$41,$51,$68
>16a0	54 81 42 59 57 75 be 84			.byte	$54,$81,$42,$59,$57,$75,$be,$84
>16a8	8b 41 40 68 43 00 0a 3e			.byte	$8b,$41,$40,$68,$43,$00,$0a,$3e
>16b0	03 dc b3 40 be 84 40 00			.byte	$03,$dc,$b3,$40,$be,$84,$40,$00
>16b8	0c 48 03 dc a7 40 be 84			.byte	$0c,$48,$03,$dc,$a7,$40,$be,$84
>16c0	fe 03 30 00 1a 52 03 dc			.byte	$fe,$03,$30,$00,$1a,$52,$03,$dc
>16c8	bd 42 63 7e 60 fd 04 38			.byte	$bd,$42,$63,$7e,$60,$fd,$04,$38
>16d0	35 87 47 75 5a fd 05 37			.byte	$35,$87,$47,$75,$5a,$fd,$05,$37
>16d8	30 34 be 84 40 00 17 5c			.byte	$30,$34,$be,$84,$40,$00,$17,$5c
>16e0	03 dc bd 8b 42 53 5a 60			.byte	$03,$dc,$bd,$8b,$42,$53,$5a,$60
>16e8	8b 8b 41 58 76 4b be 84			.byte	$8b,$8b,$41,$58,$76,$4b,$be,$84
>16f0	8b 7a 64 55 00 16 66 03			.byte	$8b,$7a,$64,$55,$00,$16,$66,$03
>16f8	dc bd 8b 6e 7d 73 81 8b			.byte	$dc,$bd,$8b,$6e,$7d,$73,$81,$8b
>1700	41 7d 75 7c be 84 8b 6c			.byte	$41,$7d,$75,$7c,$be,$84,$8b,$6c
>1708	75 73 00 16 70 03 dc b2			.byte	$75,$73,$00,$16,$70,$03,$dc,$b2
>1710	43 6a 52 4f bf 8b 42 68			.byte	$43,$6a,$52,$4f,$bf,$8b,$42,$68
>1718	78 6e be 84 41 41 59 61			.byte	$78,$6e,$be,$84,$41,$41,$59,$61
>1720	00 13 7a 03 dc af fe 07			.byte	$00,$13,$7a,$03,$dc,$af,$fe,$07
>1728	36 43 33 45 46 be 84 41			.byte	$36,$43,$33,$45,$46,$be,$84,$41
>1730	6c 4f 6f 00 19 84 03 dc			.byte	$6c,$4f,$6f,$00,$19,$84,$03,$dc
>1738	bd 42 5c 7f 6c fd 03 38			.byte	$bd,$42,$5c,$7f,$6c,$fd,$03,$38
>1740	89 43 42 73 5f fd 04 31			.byte	$89,$43,$42,$73,$5f,$fd,$04,$31
>1748	37 be 84 40 00 0f 8e 03			.byte	$37,$be,$84,$40,$00,$0f,$8e,$03
>1750	dc bd 40 84 41 55 69 69			.byte	$dc,$bd,$40,$84,$41,$55,$69,$69
>1758	be 84 40 00 13 98 03 dc			.byte	$be,$84,$40,$00,$13,$98,$03,$dc
>1760	bd 49 5a 48 80 8b 53 6e			.byte	$bd,$49,$5a,$48,$80,$8b,$53,$6e
>1768	62 be 84 48 50 48 00 0e			.byte	$62,$be,$84,$48,$50,$48,$00,$0e
>1770	a2 03 dc 98 44 7f 49 84			.byte	$a2,$03,$dc,$98,$44,$7f,$49,$84
>1778	8b 44 7f 4a 00 1b ac 03			.byte	$8b,$44,$7f,$4a,$00,$1b,$ac,$03
>1780	dc a0 fe 09 61 78 66 6d			.byte	$dc,$a0,$fe,$09,$61,$78,$66,$6d
>1788	79 6d 74 bf 46 be 84 fe			.byte	$79,$6d,$74,$bf,$46,$be,$84,$fe
>1790	08 61 78 66 6d 79 6d 00			.byte	$08,$61,$78,$66,$6d,$79,$6d,$00
>1798	19 b6 03 dc bd 42 63 46			.byte	$19,$b6,$03,$dc,$bd,$42,$63,$46
>17a0	6d fd 04 30 35 87 59 4f			.byte	$6d,$fd,$04,$30,$35,$87,$59,$4f
>17a8	59 fd 04 30 34 be 84 40			.byte	$59,$fd,$04,$30,$34,$be,$84,$40
>17b0	00 13 c0 03 dc bd 42 60			.byte	$00,$13,$c0,$03,$dc,$bd,$42,$60
>17b8	6e 7c 85 43 47 7c 76 be			.byte	$6e,$7c,$85,$43,$47,$7c,$76,$be
>17c0	84 8b 41 00 12 ca 03 dc			.byte	$84,$8b,$41,$00,$12,$ca,$03,$dc
>17c8	bd 59 6f 6e 80 6b 71 7c			.byte	$bd,$59,$6f,$6e,$80,$6b,$71,$7c
>17d0	be 84 49 61 6c 00 18 d4			.byte	$be,$84,$49,$61,$6c,$00,$18,$d4
>17d8	03 dc a5 a4 64 4e 5c fd			.byte	$03,$dc,$a5,$a4,$64,$4e,$5c,$fd
>17e0	04 39 35 be be 84 64 4e			.byte	$04,$39,$35,$be,$be,$84,$64,$4e
>17e8	5c fd 04 39 35 00 16 de			.byte	$5c,$fd,$04,$39,$35,$00,$16,$de
>17f0	03 dc a1 fe 06 61 6c 69			.byte	$03,$dc,$a1,$fe,$06,$61,$6c,$69
>17f8	63 bf 4a be 84 fe 06 61			.byte	$63,$bf,$4a,$be,$84,$fe,$06,$61
>1800	6c 69 63 00 1b e8 03 dc			.byte	$6c,$69,$63,$00,$1b,$e8,$03,$dc
>1808	bd 8b 42 44 66 fd 05 31			.byte	$bd,$8b,$42,$44,$66,$fd,$05,$31
>1810	30 36 87 7b 59 62 fd 04			.byte	$30,$36,$87,$7b,$59,$62,$fd,$04
>1818	38 32 be 84 8b 41 00 14			.byte	$38,$32,$be,$84,$8b,$41,$00,$14
>1820	f2 03 dc bd 8b 43 63 45			.byte	$f2,$03,$dc,$bd,$8b,$43,$63,$45
>1828	7b 8d 42 76 41 51 be 84			.byte	$7b,$8d,$42,$76,$41,$51,$be,$84
>1830	8b 41 00 15 fc 03 dc bd			.byte	$8b,$41,$00,$15,$fc,$03,$dc,$bd
>1838	43 64 71 6e 81 42 72 73			.byte	$43,$64,$71,$6e,$81,$42,$72,$73
>1840	67 be 84 43 76 73 6f 00			.byte	$67,$be,$84,$43,$76,$73,$6f,$00
>1848	10 06 04 dc 9a 41 72 50			.byte	$10,$06,$04,$dc,$9a,$41,$72,$50
>1850	60 be 84 41 72 50 60 00			.byte	$60,$be,$84,$41,$72,$50,$60,$00
>1858	17 10 04 dc a2 fe 06 73			.byte	$17,$10,$04,$dc,$a2,$fe,$06,$73
>1860	61 79 69 bf 41 bf 43 be			.byte	$61,$79,$69,$bf,$41,$bf,$43,$be
>1868	84 fe 05 73 61 79 00 22			.byte	$84,$fe,$05,$73,$61,$79,$00,$22
>1870	1a 04 dc bd 8b 42 59 5f			.byte	$1a,$04,$dc,$bd,$8b,$42,$59,$5f
>1878	46 fd 04 31 31 8b 42 71			.byte	$46,$fd,$04,$31,$31,$8b,$42,$71
>1880	64 51 fd 04 35 34 be 84			.byte	$64,$51,$fd,$04,$35,$34,$be,$84
>1888	8b 45 4b 43 57 fd 03 36			.byte	$8b,$45,$4b,$43,$57,$fd,$03,$36
>1890	00 15 24 04 dc bd 8b 5c			.byte	$00,$15,$24,$04,$dc,$bd,$8b,$5c
>1898	59 8b 41 5b 53 53 be 84			.byte	$59,$8b,$41,$5b,$53,$53,$be,$84
>18a0	8b 41 5b 6f 6c 00 14 2e			.byte	$8b,$41,$5b,$6f,$6c,$00,$14,$2e
>18a8	04 dc bd 8b 42 7b 5f 44			.byte	$04,$dc,$bd,$8b,$42,$7b,$5f,$44
>18b0	81 40 be 84 8b 42 7b 5f			.byte	$81,$40,$be,$84,$8b,$42,$7b,$5f
>18b8	44 00 0c 38 04 dc b3 43			.byte	$44,$00,$0c,$38,$04,$dc,$b3,$43
>18c0	76 56 be 84 41 00 0e 42			.byte	$76,$56,$be,$84,$41,$00,$0e,$42
>18c8	04 dc a6 fe 05 74 72 79			.byte	$04,$dc,$a6,$fe,$05,$74,$72,$79
>18d0	be 84 43 00 28 4c 04 dc			.byte	$be,$84,$43,$00,$28,$4c,$04,$dc
>18d8	bd 8b 41 5f 4e 69 fd 04			.byte	$bd,$8b,$41,$5f,$4e,$69,$fd,$04
>18e0	36 38 8c 79 40 48 fd 04			.byte	$36,$38,$8c,$79,$40,$48,$fd,$04
>18e8	35 31 be 84 8b 49 fd 0d			.byte	$35,$31,$be,$84,$8b,$49,$fd,$0d
>18f0	31 30 37 30 38 36 35 34			.byte	$31,$30,$37,$30,$38,$36,$35,$34
>18f8	65 31 30 00 16 56 04 dc			.byte	$65,$31,$30,$00,$16,$56,$04,$dc
>1900	bd 41 74 76 54 8b 43 72			.byte	$bd,$41,$74,$76,$54,$8b,$43,$72
>1908	57 59 be 84 8b 41 7d 61			.byte	$57,$59,$be,$84,$8b,$41,$7d,$61
>1910	45 00 16 60 04 dc bd 8b			.byte	$45,$00,$16,$60,$04,$dc,$bd,$8b
>1918	42 4c 53 67 82 6e 59 5f			.byte	$42,$4c,$53,$67,$82,$6e,$59,$5f
>1920	be 84 8b 42 62 4a 7a 00			.byte	$be,$84,$8b,$42,$62,$4a,$7a,$00
>1928	13 6a 04 dc b2 41 72 6a			.byte	$13,$6a,$04,$dc,$b2,$41,$72,$6a
>1930	bf 43 68 63 5b be 84 41			.byte	$bf,$43,$68,$63,$5b,$be,$84,$41
>1938	72 6a 00 0f 74 04 dc 9b			.byte	$72,$6a,$00,$0f,$74,$04,$dc,$9b
>1940	fe 05 78 73 73 be 84 41			.byte	$fe,$05,$78,$73,$73,$be,$84,$41
>1948	78 00 1e 7e 04 dc bd 40			.byte	$78,$00,$1e,$7e,$04,$dc,$bd,$40
>1950	fd 03 30 8b 53 7b 5e fd			.byte	$fd,$03,$30,$8b,$53,$7b,$5e,$fd
>1958	05 38 31 31 be 84 8b 53			.byte	$05,$38,$31,$31,$be,$84,$8b,$53
>1960	7b 5e fd 05 38 31 31 00			.byte	$7b,$5e,$fd,$05,$38,$31,$31,$00
>1968	12 88 04 dc bd 8b 42 65			.byte	$12,$88,$04,$dc,$bd,$8b,$42,$65
>1970	4c 69 89 46 7a 69 be 84			.byte	$4c,$69,$89,$46,$7a,$69,$be,$84
>1978	40 00 15 92 04 dc bd 8b			.byte	$40,$00,$15,$92,$04,$dc,$bd,$8b
>1980	54 73 7f 81 41 4e 57 7f			.byte	$54,$73,$7f,$81,$41,$4e,$57,$7f
>1988	be 84 8b 50 60 41 00 0e			.byte	$be,$84,$8b,$50,$60,$41,$00,$0e
>1990	9c 04 dc 98 67 7f 65 84			.byte	$9c,$04,$dc,$98,$67,$7f,$65,$84
>1998	8b 67 7f 66 00 0d a6 04			.byte	$8b,$67,$7f,$66,$00,$0d,$a6,$04
>19a0	dc b4 41 74 be 84 fe 03			.byte	$dc,$b4,$41,$74,$be,$84,$fe,$03
>19a8	74 00 17 b0 04 dc bd 8b			.byte	$74,$00,$17,$b0,$04,$dc,$bd,$8b
>19b0	41 43 54 53 fd 04 39 35			.byte	$41,$43,$54,$53,$fd,$04,$39,$35
>19b8	88 40 fd 03 30 be 84 40			.byte	$88,$40,$fd,$03,$30,$be,$84,$40
>19c0	00 13 ba 04 dc bd 8b 41			.byte	$00,$13,$ba,$04,$dc,$bd,$8b,$41
>19c8	59 47 7c 84 42 7b 4b 64			.byte	$59,$47,$7c,$84,$42,$7b,$4b,$64
>19d0	be 84 40 00 13 c4 04 dc			.byte	$be,$84,$40,$00,$13,$c4,$04,$dc
>19d8	bd 41 57 65 63 80 69 75			.byte	$bd,$41,$57,$65,$63,$80,$69,$75
>19e0	75 be 84 41 65 61 00 14			.byte	$75,$be,$84,$41,$65,$61,$00,$14
>19e8	ce 04 dc a5 a4 8b 41 42			.byte	$ce,$04,$dc,$a5,$a4,$8b,$41,$42
>19f0	6b 45 be be 84 8b 41 42			.byte	$6b,$45,$be,$be,$84,$8b,$41,$42
>19f8	6b 45 00 0b d8 04 dc a3			.byte	$6b,$45,$00,$0b,$d8,$04,$dc,$a3
>1a00	40 be 84 fe 02 00 24 e2			.byte	$40,$be,$84,$fe,$02,$00,$24,$e2
>1a08	04 dc bd 8b 43 72 6f 53			.byte	$04,$dc,$bd,$8b,$43,$72,$6f,$53
>1a10	fd 03 30 8d 43 43 53 61			.byte	$fd,$03,$30,$8d,$43,$43,$53,$61
>1a18	fd 04 35 31 be 84 8b 41			.byte	$fd,$04,$35,$31,$be,$84,$8b,$41
>1a20	fd 09 32 34 32 38 37 31			.byte	$fd,$09,$32,$34,$32,$38,$37,$31
>1a28	31 00 14 ec 04 dc bd 8b			.byte	$31,$00,$14,$ec,$04,$dc,$bd,$8b
>1a30	43 43 63 4b 86 8b 43 5a			.byte	$43,$43,$63,$4b,$86,$8b,$43,$5a
>1a38	61 79 be 84 40 00 14 f6			.byte	$61,$79,$be,$84,$40,$00,$14,$f6
>1a40	04 dc bd 41 75 4d 72 82			.byte	$04,$dc,$bd,$41,$75,$4d,$72,$82
>1a48	6d 5a 73 be 84 41 58 57			.byte	$6d,$5a,$73,$be,$84,$41,$58,$57
>1a50	41 00 11 00 05 dc 9a 8b			.byte	$41,$00,$11,$00,$05,$dc,$9a,$8b
>1a58	41 41 55 75 be 84 41 41			.byte	$41,$41,$55,$75,$be,$84,$41,$41
>1a60	55 75 00 13 0a 05 dc a7			.byte	$55,$75,$00,$13,$0a,$05,$dc,$a7
>1a68	42 66 71 43 be 84 fe 07			.byte	$42,$66,$71,$43,$be,$84,$fe,$07
>1a70	41 36 43 34 33 00 27 14			.byte	$41,$36,$43,$34,$33,$00,$27,$14
>1a78	05 dc bd 6e 7a 49 fd 04			.byte	$05,$dc,$bd,$6e,$7a,$49,$fd,$04
>1a80	31 37 8c 8b 58 6d 40 fd			.byte	$31,$37,$8c,$8b,$58,$6d,$40,$fd
>1a88	04 36 36 be 84 8b 41 fd			.byte	$04,$36,$36,$be,$84,$8b,$41,$fd
>1a90	0d 39 34 34 31 33 33 34			.byte	$0d,$39,$34,$34,$31,$33,$33,$34
>1a98	31 65 31 30 00 13 1e 05			.byte	$31,$65,$31,$30,$00,$13,$1e,$05
>1aa0	dc bd 43 6c 42 66 89 8b			.byte	$dc,$bd,$43,$6c,$42,$66,$89,$8b
>1aa8	5b 5d 5f be 84 8b 41 00			.byte	$5b,$5d,$5f,$be,$84,$8b,$41,$00
>1ab0	16 28 05 dc bd 8b 43 52			.byte	$16,$28,$05,$dc,$bd,$8b,$43,$52
>1ab8	4f 48 82 49 4f 43 be 84			.byte	$4f,$48,$82,$49,$4f,$43,$be,$84
>1ac0	8b 43 5b 40 45 00 0d 32			.byte	$8b,$43,$5b,$40,$45,$00,$0d,$32
>1ac8	05 dc b3 42 46 45 41 be			.byte	$05,$dc,$b3,$42,$46,$45,$41,$be
>1ad0	84 41 00 13 3c 05 dc af			.byte	$84,$41,$00,$13,$3c,$05,$dc,$af
>1ad8	fe 07 41 30 43 38 44 be			.byte	$fe,$07,$41,$30,$43,$38,$44,$be
>1ae0	84 42 60 72 4d 00 28 46			.byte	$84,$42,$60,$72,$4d,$00,$28,$46
>1ae8	05 dc bd 8b 41 78 5e 7e			.byte	$05,$dc,$bd,$8b,$41,$78,$5e,$7e
>1af0	fd 04 31 34 8c 43 42 69			.byte	$fd,$04,$31,$34,$8c,$43,$42,$69
>1af8	6a fd 03 31 be 84 8b 43			.byte	$6a,$fd,$03,$31,$be,$84,$8b,$43
>1b00	fd 0d 39 33 34 36 34 33			.byte	$fd,$0d,$39,$33,$34,$36,$34,$33
>1b08	37 34 65 31 31 00 15 50			.byte	$37,$34,$65,$31,$31,$00,$15,$50
>1b10	05 dc bd 8b 7f 65 51 8a			.byte	$05,$dc,$bd,$8b,$7f,$65,$51,$8a
>1b18	41 7f 7f 64 be 84 41 40			.byte	$41,$7f,$7f,$64,$be,$84,$41,$40
>1b20	5a 53 00 15 5a 05 dc bd			.byte	$5a,$53,$00,$15,$5a,$05,$dc,$bd
>1b28	8b 44 74 7d 80 41 72 4e			.byte	$8b,$44,$74,$7d,$80,$41,$72,$4e
>1b30	5b be 84 41 72 4a 43 00			.byte	$5b,$be,$84,$41,$72,$4a,$43,$00
>1b38	14 64 05 dc b2 43 44 43			.byte	$14,$64,$05,$dc,$b2,$43,$44,$43
>1b40	6e bf 8b 61 61 7d be 84			.byte	$6e,$bf,$8b,$61,$61,$7d,$be,$84
>1b48	5c 59 7d 00 16 6e 05 dc			.byte	$5c,$59,$7d,$00,$16,$6e,$05,$dc
>1b50	a0 fe 09 6d 67 76 72 69			.byte	$a0,$fe,$09,$6d,$67,$76,$72,$69
>1b58	65 67 bf 41 be 84 fe 03			.byte	$65,$67,$bf,$41,$be,$84,$fe,$03
>1b60	6d 00 19 78 05 dc bd 8b			.byte	$6d,$00,$19,$78,$05,$dc,$bd,$8b
>1b68	66 76 43 fd 04 36 31 87			.byte	$66,$76,$43,$fd,$04,$36,$31,$87
>1b70	5e 5d 4d fd 03 31 be 84			.byte	$5e,$5d,$4d,$fd,$03,$31,$be,$84
>1b78	8b 41 00 14 82 05 dc bd			.byte	$8b,$41,$00,$14,$82,$05,$dc,$bd
>1b80	8b 44 62 79 85 8b 42 42			.byte	$8b,$44,$62,$79,$85,$8b,$42,$42
>1b88	65 71 be 84 8b 41 00 0f			.byte	$65,$71,$be,$84,$8b,$41,$00,$0f
>1b90	8c 05 dc bd 40 80 43 4b			.byte	$8c,$05,$dc,$bd,$40,$80,$43,$4b
>1b98	55 79 be 84 40 00 10 96			.byte	$55,$79,$be,$84,$40,$00,$10,$96
>1ba0	05 dc 98 8b 41 4a 76 42			.byte	$05,$dc,$98,$8b,$41,$4a,$76,$42
>1ba8	84 41 4a 76 41 00 12 a0			.byte	$84,$41,$4a,$76,$41,$00,$12,$a0
>1bb0	05 dc a1 fe 04 79 6e bf			.byte	$05,$dc,$a1,$fe,$04,$79,$6e,$bf
>1bb8	45 be 84 fe 04 79 6e 00			.byte	$45,$be,$84,$fe,$04,$79,$6e,$00
>1bc0	28 aa 05 dc bd 8b 7c 4f			.byte	$28,$aa,$05,$dc,$bd,$8b,$7c,$4f
>1bc8	68 fd 04 39 38 8c 8b 43			.byte	$68,$fd,$04,$39,$38,$8c,$8b,$43
>1bd0	6b 5f 5f fd 04 37 39 be			.byte	$6b,$5f,$5f,$fd,$04,$37,$39,$be
>1bd8	84 42 fd 0d 33 38 30 31			.byte	$84,$42,$fd,$0d,$33,$38,$30,$31
>1be0	39 36 37 32 65 31 31 00			.byte	$39,$36,$37,$32,$65,$31,$31,$00
>1be8	13 b4 05 dc bd 43 41 6f			.byte	$13,$b4,$05,$dc,$bd,$43,$41,$6f
>1bf0	49 84 8b 41 60 60 54 be			.byte	$49,$84,$8b,$41,$60,$60,$54,$be
>1bf8	84 40 00 17 be 05 dc bd			.byte	$84,$40,$00,$17,$be,$05,$dc,$bd
>1c00	8b 43 59 44 5d 80 8b 72			.byte	$8b,$43,$59,$44,$5d,$80,$8b,$72
>1c08	6f 54 be 84 8b 43 7b 6f			.byte	$6f,$54,$be,$84,$8b,$43,$7b,$6f
>1c10	60 00 1c c8 05 dc a5 a4			.byte	$60,$00,$1c,$c8,$05,$dc,$a5,$a4
>1c18	8b 41 48 6e 79 fd 04 37			.byte	$8b,$41,$48,$6e,$79,$fd,$04,$37
>1c20	31 be be 84 8b 41 48 6e			.byte	$31,$be,$be,$84,$8b,$41,$48,$6e
>1c28	79 fd 04 37 31 00 17 d2			.byte	$79,$fd,$04,$37,$31,$00,$17,$d2
>1c30	05 dc a2 fe 09 6d 75 6f			.byte	$05,$dc,$a2,$fe,$09,$6d,$75,$6f
>1c38	65 6b 77 6e bf 49 bf 45			.byte	$65,$6b,$77,$6e,$bf,$49,$bf,$45
>1c40	be 84 fe 02 00 1f dc 05			.byte	$be,$84,$fe,$02,$00,$1f,$dc,$05
>1c48	dc bd 8b 43 6b 54 4c fd			.byte	$dc,$bd,$8b,$43,$6b,$54,$4c,$fd
>1c50	04 38 35 8b 40 fd 03 30			.byte	$04,$38,$35,$8b,$40,$fd,$03,$30
>1c58	be 84 8b 43 6b 54 4c fd			.byte	$be,$84,$8b,$43,$6b,$54,$4c,$fd
>1c60	04 38 35 00 13 e6 05 dc			.byte	$04,$38,$35,$00,$13,$e6,$05,$dc
>1c68	bd 43 6f 5a 6b 88 41 45			.byte	$bd,$43,$6f,$5a,$6b,$88,$41,$45
>1c70	7a 59 be 84 8b 41 00 16			.byte	$7a,$59,$be,$84,$8b,$41,$00,$16
>1c78	f0 05 dc bd 8b 43 5e 55			.byte	$f0,$05,$dc,$bd,$8b,$43,$5e,$55
>1c80	58 81 6c 64 6a be 84 8b			.byte	$58,$81,$6c,$64,$6a,$be,$84,$8b
>1c88	43 52 51 56 00 10 fa 05			.byte	$43,$52,$51,$56,$00,$10,$fa,$05
>1c90	dc 9a 42 74 5e 60 be 84			.byte	$dc,$9a,$42,$74,$5e,$60,$be,$84
>1c98	42 74 5e 60 00 0e 04 06			.byte	$42,$74,$5e,$60,$00,$0e,$04,$06
>1ca0	dc a6 fe 05 6e 66 78 be			.byte	$dc,$a6,$fe,$05,$6e,$66,$78,$be
>1ca8	84 43 00 1c 0e 06 dc bd			.byte	$84,$43,$00,$1c,$0e,$06,$dc,$bd
>1cb0	8b 47 5d 52 fd 05 37 38			.byte	$8b,$47,$5d,$52,$fd,$05,$37,$38
>1cb8	38 86 8b 4f 45 67 fd 05			.byte	$38,$86,$8b,$4f,$45,$67,$fd,$05
>1cc0	32 38 33 be 84 40 00 15			.byte	$32,$38,$33,$be,$84,$40,$00,$15
>1cc8	18 06 dc bd 8b 66 76 42			.byte	$18,$06,$dc,$bd,$8b,$66,$76,$42
>1cd0	8b 8b 60 7e 62 be 84 8b			.byte	$8b,$8b,$60,$7e,$62,$be,$84,$8b
>1cd8	45 77 60 00 17 22 06 dc			.byte	$45,$77,$60,$00,$17,$22,$06,$dc
>1ce0	bd 42 47 54 78 82 8b 43			.byte	$bd,$42,$47,$54,$78,$82,$8b,$43
>1ce8	70 40 4c be 84 8b 41 77			.byte	$70,$40,$4c,$be,$84,$8b,$41,$77
>1cf0	54 74 00 0d 2c 06 dc b3			.byte	$54,$74,$00,$0d,$2c,$06,$dc,$b3
>1cf8	41 61 52 48 be 84 41 00			.byte	$41,$61,$52,$48,$be,$84,$41,$00
>1d00	13 36 06 dc 9b fe 09 67			.byte	$13,$36,$06,$dc,$9b,$fe,$09,$67
>1d08	66 73 62 6c 65 71 be 84			.byte	$66,$73,$62,$6c,$65,$71,$be,$84
>1d10	41 67 00 16 40 06 dc bd			.byte	$41,$67,$00,$16,$40,$06,$dc,$bd
>1d18	42 74 75 60 fd 04 35 35			.byte	$42,$74,$75,$60,$fd,$04,$35,$35
>1d20	86 40 fd 03 30 be 84 40			.byte	$86,$40,$fd,$03,$30,$be,$84,$40
>1d28	00 13 4a 06 dc bd 8b 6d			.byte	$00,$13,$4a,$06,$dc,$bd,$8b,$6d
>1d30	42 5a 84 8b 42 53 43 4d			.byte	$42,$5a,$84,$8b,$42,$53,$43,$4d
>1d38	be 84 40 00 17 54 06 dc			.byte	$be,$84,$40,$00,$17,$54,$06,$dc
>1d40	bd 8b 41 7c 5e 53 82 43			.byte	$bd,$8b,$41,$7c,$5e,$53,$82,$43
>1d48	58 51 49 be 84 8b 42 64			.byte	$58,$51,$49,$be,$84,$8b,$42,$64
>1d50	4f 5c 00 14 5e 06 dc b2			.byte	$4f,$5c,$00,$14,$5e,$06,$dc,$b2
>1d58	8b 61 4f 7d bf 8b 73 7e			.byte	$8b,$61,$4f,$7d,$bf,$8b,$73,$7e
>1d60	4c be 84 61 4f 7d 00 0c			.byte	$4c,$be,$84,$61,$4f,$7d,$00,$0c
>1d68	68 06 dc b4 6d be 84 fe			.byte	$68,$06,$dc,$b4,$6d,$be,$84,$fe
>1d70	03 2d 00 1b 72 06 dc bd			.byte	$03,$2d,$00,$1b,$72,$06,$dc,$bd
>1d78	41 66 57 73 fd 04 36 34			.byte	$41,$66,$57,$73,$fd,$04,$36,$34
>1d80	86 42 43 49 7b fd 04 32			.byte	$86,$42,$43,$49,$7b,$fd,$04,$32
>1d88	33 be 84 8b 41 00 14 7c			.byte	$33,$be,$84,$8b,$41,$00,$14,$7c
>1d90	06 dc bd 8b 41 64 7b 6c			.byte	$06,$dc,$bd,$8b,$41,$64,$7b,$6c
>1d98	85 43 47 74 77 be 84 8b			.byte	$85,$43,$47,$74,$77,$be,$84,$8b
>1da0	41 00 17 86 06 dc bd 8b			.byte	$41,$00,$17,$86,$06,$dc,$bd,$8b
>1da8	43 69 7a 7b 82 42 6c 66			.byte	$43,$69,$7a,$7b,$82,$42,$6c,$66
>1db0	4e be 84 8b 41 45 5c 75			.byte	$4e,$be,$84,$8b,$41,$45,$5c,$75
>1db8	00 10 90 06 dc 98 8b 41			.byte	$00,$10,$90,$06,$dc,$98,$8b,$41
>1dc0	66 48 44 84 41 66 48 43			.byte	$66,$48,$44,$84,$41,$66,$48,$43
>1dc8	00 12 9a 06 dc a3 47 be			.byte	$00,$12,$9a,$06,$dc,$a3,$47,$be
>1dd0	84 fe 09 20 20 20 20 20			.byte	$84,$fe,$09,$20,$20,$20,$20,$20
>1dd8	20 20 00 1c a4 06 dc bd			.byte	$20,$20,$00,$1c,$a4,$06,$dc,$bd
>1de0	8b 5e 7d 79 fd 04 37 38			.byte	$8b,$5e,$7d,$79,$fd,$04,$37,$38
>1de8	88 8b 43 5c 53 79 fd 04			.byte	$88,$8b,$43,$5c,$53,$79,$fd,$04
>1df0	38 35 be 84 8b 41 00 14			.byte	$38,$35,$be,$84,$8b,$41,$00,$14
>1df8	ae 06 dc bd 8b 42 7d 4c			.byte	$ae,$06,$dc,$bd,$8b,$42,$7d,$4c
>1e00	4c 84 8b 41 6a 52 70 be			.byte	$4c,$84,$8b,$41,$6a,$52,$70,$be
>1e08	84 40 00 16 b8 06 dc bd			.byte	$84,$40,$00,$16,$b8,$06,$dc,$bd
>1e10	8b 41 65 6a 55 80 43 63			.byte	$8b,$41,$65,$6a,$55,$80,$43,$63
>1e18	5c 5e be 84 42 42 54 4a			.byte	$5c,$5e,$be,$84,$42,$42,$54,$4a
>1e20	00 1a c2 06 dc a5 a4 8b			.byte	$00,$1a,$c2,$06,$dc,$a5,$a4,$8b
>1e28	5d 66 56 fd 04 35 37 be			.byte	$5d,$66,$56,$fd,$04,$35,$37,$be
>1e30	be 84 8b 5d 66 56 fd 04			.byte	$be,$84,$8b,$5d,$66,$56,$fd,$04
>1e38	35 37 00 13 cc 06 dc a7			.byte	$35,$37,$00,$13,$cc,$06,$dc,$a7
>1e40	42 7c 4e 4c be 84 fe 07			.byte	$42,$7c,$4e,$4c,$be,$84,$fe,$07
>1e48	42 43 33 38 43 00 1c d6			.byte	$42,$43,$33,$38,$43,$00,$1c,$d6
>1e50	06 dc bd 8b 43 6f 4f 55			.byte	$06,$dc,$bd,$8b,$43,$6f,$4f,$55
>1e58	fd 04 37 31 84 8b 42 63			.byte	$fd,$04,$37,$31,$84,$8b,$42,$63
>1e60	65 50 fd 04 30 34 be 84			.byte	$65,$50,$fd,$04,$30,$34,$be,$84
>1e68	40 00 18 e0 06 dc bd 8b			.byte	$40,$00,$18,$e0,$06,$dc,$bd,$8b
>1e70	41 41 49 59 8a 8b 41 4b			.byte	$41,$41,$49,$59,$8a,$8b,$41,$4b
>1e78	50 41 be 84 8b 42 4c 59			.byte	$50,$41,$be,$84,$8b,$42,$4c,$59
>1e80	5a 00 17 ea 06 dc bd 8b			.byte	$5a,$00,$17,$ea,$06,$dc,$bd,$8b
>1e88	43 52 59 4e 82 41 55 75			.byte	$43,$52,$59,$4e,$82,$41,$55,$75
>1e90	4a be 84 8b 42 47 6c 48			.byte	$4a,$be,$84,$8b,$42,$47,$6c,$48
>1e98	00 0f f4 06 dc 9a 8b 46			.byte	$00,$0f,$f4,$06,$dc,$9a,$8b,$46
>1ea0	6d 6d be 84 46 6d 6d 00			.byte	$6d,$6d,$be,$84,$46,$6d,$6d,$00
>1ea8	13 fe 06 dc af fe 07 38			.byte	$13,$fe,$06,$dc,$af,$fe,$07,$38
>1eb0	36 42 34 36 be 84 42 46			.byte	$36,$42,$34,$36,$be,$84,$42,$46
>1eb8	6d 46 00 15 08 07 dc bd			.byte	$6d,$46,$00,$15,$08,$07,$dc,$bd
>1ec0	40 fd 03 30 8a 40 fd 03			.byte	$40,$fd,$03,$30,$8a,$40,$fd,$03
>1ec8	30 be 84 40 fd 03 30 00			.byte	$30,$be,$84,$40,$fd,$03,$30,$00
>1ed0	13 12 07 dc bd 43 57 54			.byte	$13,$12,$07,$dc,$bd,$43,$57,$54
>1ed8	4d 87 8b 42 57 57 70 be			.byte	$4d,$87,$8b,$42,$57,$57,$70,$be
>1ee0	84 40 00 15 1c 07 dc bd			.byte	$84,$40,$00,$15,$1c,$07,$dc,$bd
>1ee8	41 49 48 48 81 8b 6a 6e			.byte	$41,$49,$48,$48,$81,$8b,$6a,$6e
>1ef0	68 be 84 8b 62 66 68 00			.byte	$68,$be,$84,$8b,$62,$66,$68,$00
>1ef8	0c 26 07 dc b3 77 76 54			.byte	$0c,$26,$07,$dc,$b3,$77,$76,$54
>1f00	be 84 41 00 16 30 07 dc			.byte	$be,$84,$41,$00,$16,$30,$07,$dc
>1f08	a0 fe 06 6c 6c 65 67 bf			.byte	$a0,$fe,$06,$6c,$6c,$65,$67,$bf
>1f10	47 be 84 fe 06 6c 6c 65			.byte	$47,$be,$84,$fe,$06,$6c,$6c,$65
>1f18	67 00 1b 3a 07 dc bd 8b			.byte	$67,$00,$1b,$3a,$07,$dc,$bd,$8b
>1f20	43 69 7b 50 fd 04 36 32			.byte	$43,$69,$7b,$50,$fd,$04,$36,$32
>1f28	89 42 5c 57 71 fd 04 37			.byte	$89,$42,$5c,$57,$71,$fd,$04,$37
>1f30	34 be 84 40 00 13 44 07			.byte	$34,$be,$84,$40,$00,$13,$44,$07
>1f38	dc bd 8b 79 7e 49 87 8b			.byte	$dc,$bd,$8b,$79,$7e,$49,$87,$8b
>1f40	43 6a 54 64 be 84 40 00			.byte	$43,$6a,$54,$64,$be,$84,$40,$00
>1f48	16 4e 07 dc bd 8b 5b 74			.byte	$16,$4e,$07,$dc,$bd,$8b,$5b,$74
>1f50	73 81 8b 42 62 6f 60 be			.byte	$73,$81,$8b,$42,$62,$6f,$60,$be
>1f58	84 8b 42 64 53 00 10 58			.byte	$84,$8b,$42,$64,$53,$00,$10,$58
>1f60	07 dc b2 40 bf 8b 41 51			.byte	$07,$dc,$b2,$40,$bf,$8b,$41,$51
>1f68	53 6d be 84 40 00 1a 62			.byte	$53,$6d,$be,$84,$40,$00,$1a,$62
>1f70	07 dc a1 fe 0b 6b 6b 62			.byte	$07,$dc,$a1,$fe,$0b,$6b,$6b,$62
>1f78	77 6f 79 61 6f 6e bf 43			.byte	$77,$6f,$79,$61,$6f,$6e,$bf,$43
>1f80	be 84 fe 05 61 6f 6e 00			.byte	$be,$84,$fe,$05,$61,$6f,$6e,$00
>1f88	16 6c 07 dc bd 40 fd 03			.byte	$16,$6c,$07,$dc,$bd,$40,$fd,$03
>1f90	30 89 42 54 46 74 fd 04			.byte	$30,$89,$42,$54,$46,$74,$fd,$04
>1f98	33 34 be 84 40 00 13 76			.byte	$33,$34,$be,$84,$40,$00,$13,$76
>1fa0	07 dc bd 8b 41 4c 45 5e			.byte	$07,$dc,$bd,$8b,$41,$4c,$45,$5e
>1fa8	89 41 72 5d 58 be 84 40			.byte	$89,$41,$72,$5d,$58,$be,$84,$40
>1fb0	00 16 80 07 dc bd 8b 55			.byte	$00,$16,$80,$07,$dc,$bd,$8b,$55
>1fb8	78 6e 82 8b 42 59 74 44			.byte	$78,$6e,$82,$8b,$42,$59,$74,$44
>1fc0	be 84 42 4c 4c 6e 00 0e			.byte	$be,$84,$42,$4c,$4c,$6e,$00,$0e
>1fc8	8a 07 dc 98 6f 50 47 84			.byte	$8a,$07,$dc,$98,$6f,$50,$47,$84
>1fd0	8b 6f 50 48 00 16 94 07			.byte	$8b,$6f,$50,$48,$00,$16,$94,$07
>1fd8	dc a2 fe 08 6f 65 6f 65			.byte	$dc,$a2,$fe,$08,$6f,$65,$6f,$65
>1fe0	6b 73 bf 4a bf 48 be 84			.byte	$6b,$73,$bf,$4a,$bf,$48,$be,$84
>1fe8	fe 02 00 1c 9e 07 dc bd			.byte	$fe,$02,$00,$1c,$9e,$07,$dc,$bd
>1ff0	43 47 58 4f fd 04 34 38			.byte	$43,$47,$58,$4f,$fd,$04,$34,$38
>1ff8	89 8b 43 6b 6d 66 fd 04			.byte	$89,$8b,$43,$6b,$6d,$66,$fd,$04
>2000	39 32 be 84 8b 41 00 13			.byte	$39,$32,$be,$84,$8b,$41,$00,$13
>2008	a8 07 dc bd 62 43 49 88			.byte	$a8,$07,$dc,$bd,$62,$43,$49,$88
>2010	8b 42 64 65 56 be 84 8b			.byte	$8b,$42,$64,$65,$56,$be,$84,$8b
>2018	41 00 16 b2 07 dc bd 8b			.byte	$41,$00,$16,$b2,$07,$dc,$bd,$8b
>2020	42 70 57 5b 80 41 45 5f			.byte	$42,$70,$57,$5b,$80,$41,$45,$5f
>2028	7c be 84 41 45 48 64 00			.byte	$7c,$be,$84,$41,$45,$48,$64,$00
>2030	1a bc 07 dc a5 a4 42 71			.byte	$1a,$bc,$07,$dc,$a5,$a4,$42,$71
>2038	4c 4a fd 04 35 32 be be			.byte	$4c,$4a,$fd,$04,$35,$32,$be,$be
>2040	84 42 71 4c 4a fd 04 35			.byte	$84,$42,$71,$4c,$4a,$fd,$04,$35
>2048	32 00 0b c6 07 dc a6 fe			.byte	$32,$00,$0b,$c6,$07,$dc,$a6,$fe
>2050	02 be 84 40 00 1b d0 07			.byte	$02,$be,$84,$40,$00,$1b,$d0,$07
>2058	dc bd 40 fd 03 30 8d 8b			.byte	$dc,$bd,$40,$fd,$03,$30,$8d,$8b
>2060	41 57 6d 40 fd 04 30 39			.byte	$41,$57,$6d,$40,$fd,$04,$30,$39
>2068	be 84 8b 40 fd 03 30 00			.byte	$be,$84,$8b,$40,$fd,$03,$30,$00
>2070	13 da 07 dc bd 8b 42 6a			.byte	$13,$da,$07,$dc,$bd,$8b,$42,$6a
>2078	6f 6f 8d 43 63 57 62 be			.byte	$6f,$6f,$8d,$43,$63,$57,$62,$be
>2080	84 40 00 13 e4 07 dc bd			.byte	$84,$40,$00,$13,$e4,$07,$dc,$bd
>2088	6e 52 42 81 8b 42 5d 57			.byte	$6e,$52,$42,$81,$8b,$42,$5d,$57
>2090	be 84 8b 4d 55 00 11 ee			.byte	$be,$84,$8b,$4d,$55,$00,$11,$ee
>2098	07 dc 9a 8b 42 5a 62 7d			.byte	$07,$dc,$9a,$8b,$42,$5a,$62,$7d
>20a0	be 84 42 5a 62 7d 00 16			.byte	$be,$84,$42,$5a,$62,$7d,$00,$16
>20a8	f8 07 dc 9b fe 0c 6a 6f			.byte	$f8,$07,$dc,$9b,$fe,$0c,$6a,$6f
>20b0	73 76 68 61 6c 74 67 69			.byte	$73,$76,$68,$61,$6c,$74,$67,$69
>20b8	be 84 41 6a 00 17 02 08			.byte	$be,$84,$41,$6a,$00,$17,$02,$08
>20c0	dc bd 40 fd 03 30 89 8b			.byte	$dc,$bd,$40,$fd,$03,$30,$89,$8b
>20c8	71 56 6a fd 04 36 31 be			.byte	$71,$56,$6a,$fd,$04,$36,$31,$be
>20d0	84 8b 41 00 13 0c 08 dc			.byte	$84,$8b,$41,$00,$13,$0c,$08,$dc
>20d8	bd 43 4f 6c 6c 86 8b 43			.byte	$bd,$43,$4f,$6c,$6c,$86,$8b,$43
>20e0	66 4d 7b be 84 40 00 14			.byte	$66,$4d,$7b,$be,$84,$40,$00,$14
>20e8	16 08 dc bd 43 53 4f 6b			.byte	$16,$08,$dc,$bd,$43,$53,$4f,$6b
>20f0	82 43 6d 69 4b be 84 7e			.byte	$82,$43,$6d,$69,$4b,$be,$84,$7e
>20f8	66 60 00 0f 20 08 dc b3			.byte	$66,$60,$00,$0f,$20,$08,$dc,$b3
>2100	8b 43 42 66 49 be 84 8b			.byte	$8b,$43,$42,$66,$49,$be,$84,$8b
>2108	41 00 0c 2a 08 dc b4 6b			.byte	$41,$00,$0c,$2a,$08,$dc,$b4,$6b
>2110	be 84 fe 03 2b 00 1c 34			.byte	$be,$84,$fe,$03,$2b,$00,$1c,$34
>2118	08 dc bd 8b 43 5a 68 67			.byte	$08,$dc,$bd,$8b,$43,$5a,$68,$67
>2120	fd 04 32 38 87 42 63 77			.byte	$fd,$04,$32,$38,$87,$42,$63,$77
>2128	48 fd 04 34 39 be 84 8b			.byte	$48,$fd,$04,$34,$39,$be,$84,$8b
>2130	41 00 0f 3e 08 dc bd 41			.byte	$41,$00,$0f,$3e,$08,$dc,$bd,$41
>2138	6d 4d 52 87 40 be 84 40			.byte	$6d,$4d,$52,$87,$40,$be,$84,$40
>2140	00 14 48 08 dc bd 77 7d			.byte	$00,$14,$48,$08,$dc,$bd,$77,$7d
>2148	69 80 8b 41 7c 50 48 be			.byte	$69,$80,$8b,$41,$7c,$50,$48,$be
>2150	84 43 6d 68 00 16 52 08			.byte	$84,$43,$6d,$68,$00,$16,$52,$08
>2158	dc b2 41 5c 63 72 bf 8b			.byte	$dc,$b2,$41,$5c,$63,$72,$bf,$8b
>2160	41 74 57 5b be 84 41 5c			.byte	$41,$74,$57,$5b,$be,$84,$41,$5c
>2168	63 72 00 17 5c 08 dc a3			.byte	$63,$72,$00,$17,$5c,$08,$dc,$a3
>2170	4c be 84 fe 0e 20 20 20			.byte	$4c,$be,$84,$fe,$0e,$20,$20,$20
>2178	20 20 20 20 20 20 20 20			.byte	$20,$20,$20,$20,$20,$20,$20,$20
>2180	20 00 29 66 08 dc bd 4f			.byte	$20,$00,$29,$66,$08,$dc,$bd,$4f
>2188	50 51 fd 05 32 33 37 8c			.byte	$50,$51,$fd,$05,$32,$33,$37,$8c
>2190	8b 42 7e 61 74 fd 04 33			.byte	$8b,$42,$7e,$61,$74,$fd,$04,$33
>2198	31 be 84 8b 44 fd 0d 38			.byte	$31,$be,$84,$8b,$44,$fd,$0d,$38
>21a0	37 36 30 36 32 36 36 65			.byte	$37,$36,$30,$36,$32,$36,$36,$65
>21a8	31 30 00 11 70 08 dc bd			.byte	$31,$30,$00,$11,$70,$08,$dc,$bd
>21b0	43 5f 79 6b 87 55 76 55			.byte	$43,$5f,$79,$6b,$87,$55,$76,$55
>21b8	be 84 40 00 15 7a 08 dc			.byte	$be,$84,$40,$00,$15,$7a,$08,$dc
>21c0	bd 43 64 51 5b 80 8b 68			.byte	$bd,$43,$64,$51,$5b,$80,$8b,$68
>21c8	7c 66 be 84 43 44 41 5a			.byte	$7c,$66,$be,$84,$43,$44,$41,$5a
>21d0	00 0e 84 08 dc 98 7c 6b			.byte	$00,$0e,$84,$08,$dc,$98,$7c,$6b
>21d8	45 84 8b 7c 6b 46 00 13			.byte	$45,$84,$8b,$7c,$6b,$46,$00,$13
>21e0	8e 08 dc a7 42 63 6e 6e			.byte	$8e,$08,$dc,$a7,$42,$63,$6e,$6e
>21e8	be 84 fe 07 41 33 42 41			.byte	$be,$84,$fe,$07,$41,$33,$42,$41
>21f0	45 00 1c 98 08 dc bd 8b			.byte	$45,$00,$1c,$98,$08,$dc,$bd,$8b
>21f8	41 48 7f 74 fd 04 31 32			.byte	$41,$48,$7f,$74,$fd,$04,$31,$32
>2200	87 8b 42 4b 74 7a fd 04			.byte	$87,$8b,$42,$4b,$74,$7a,$fd,$04
>2208	39 32 be 84 40 00 14 a2			.byte	$39,$32,$be,$84,$40,$00,$14,$a2
>2210	08 dc bd 8b 41 76 7b 68			.byte	$08,$dc,$bd,$8b,$41,$76,$7b,$68
>2218	87 41 53 48 4d be 84 8b			.byte	$87,$41,$53,$48,$4d,$be,$84,$8b
>2220	41 00 14 ac 08 dc bd 8b			.byte	$41,$00,$14,$ac,$08,$dc,$bd,$8b
>2228	6f 52 5e 82 7c 6d 6c be			.byte	$6f,$52,$5e,$82,$7c,$6d,$6c,$be
>2230	84 8b 53 7f 72 00 14 b6			.byte	$84,$8b,$53,$7f,$72,$00,$14,$b6
>2238	08 dc a5 a4 8b 41 7b 60			.byte	$08,$dc,$a5,$a4,$8b,$41,$7b,$60
>2240	72 be be 84 8b 41 7b 60			.byte	$72,$be,$be,$84,$8b,$41,$7b,$60
>2248	72 00 12 c0 08 dc af fe			.byte	$72,$00,$12,$c0,$08,$dc,$af,$fe
>2250	07 31 31 37 31 33 be 84			.byte	$07,$31,$31,$37,$31,$33,$be,$84
>2258	51 5c 53 00 1c ca 08 dc			.byte	$51,$5c,$53,$00,$1c,$ca,$08,$dc
>2260	bd 53 68 67 fd 05 37 37			.byte	$bd,$53,$68,$67,$fd,$05,$37,$37
>2268	34 85 8b 4d 74 76 fd 05			.byte	$34,$85,$8b,$4d,$74,$76,$fd,$05
>2270	37 32 39 be 84 8b 41 00			.byte	$37,$32,$39,$be,$84,$8b,$41,$00
>2278	14 d4 08 dc bd 62 7f 65			.byte	$14,$d4,$08,$dc,$bd,$62,$7f,$65
>2280	8a 42 43 7e 74 be 84 42			.byte	$8a,$42,$43,$7e,$74,$be,$84,$42
>2288	66 7e 59 00 15 de 08 dc			.byte	$66,$7e,$59,$00,$15,$de,$08,$dc
>2290	bd 43 61 69 70 81 8b 53			.byte	$bd,$43,$61,$69,$70,$81,$8b,$53
>2298	49 40 be 84 8b 52 40 50			.byte	$49,$40,$be,$84,$8b,$52,$40,$50
>22a0	00 11 e8 08 dc 9a 8b 43			.byte	$00,$11,$e8,$08,$dc,$9a,$8b,$43
>22a8	50 79 74 be 84 43 50 79			.byte	$50,$79,$74,$be,$84,$43,$50,$79
>22b0	74 00 18 f2 08 dc a0 fe			.byte	$74,$00,$18,$f2,$08,$dc,$a0,$fe
>22b8	07 64 71 75 61 77 bf 49			.byte	$07,$64,$71,$75,$61,$77,$bf,$49
>22c0	be 84 fe 07 64 71 75 61			.byte	$be,$84,$fe,$07,$64,$71,$75,$61
>22c8	77 00 21 fc 08 dc bd 43			.byte	$77,$00,$21,$fc,$08,$dc,$bd,$43
>22d0	68 50 6d fd 04 35 39 8b			.byte	$68,$50,$6d,$fd,$04,$35,$39,$8b
>22d8	8b 47 64 72 fd 05 35 31			.byte	$8b,$47,$64,$72,$fd,$05,$35,$31
>22e0	32 be 84 43 6f 75 60 fd			.byte	$32,$be,$84,$43,$6f,$75,$60,$fd
>22e8	03 31 00 14 06 09 dc bd			.byte	$03,$31,$00,$14,$06,$09,$dc,$bd
>22f0	40 8a 8b 42 7f 66 61 be			.byte	$40,$8a,$8b,$42,$7f,$66,$61,$be
>22f8	84 8b 42 7f 66 61 00 15			.byte	$84,$8b,$42,$7f,$66,$61,$00,$15
>2300	10 09 dc bd 43 61 4b 45			.byte	$10,$09,$dc,$bd,$43,$61,$4b,$45
>2308	80 43 43 79 71 be 84 43			.byte	$80,$43,$43,$79,$71,$be,$84,$43
>2310	41 49 41 00 0f 1a 09 dc			.byte	$41,$49,$41,$00,$0f,$1a,$09,$dc
>2318	b3 8b 41 6a 7e 61 be 84			.byte	$b3,$8b,$41,$6a,$7e,$61,$be,$84
>2320	8b 41 00 12 24 09 dc a1			.byte	$8b,$41,$00,$12,$24,$09,$dc,$a1
>2328	fe 04 66 78 bf 48 be 84			.byte	$fe,$04,$66,$78,$bf,$48,$be,$84
>2330	fe 04 66 78 00 16 2e 09			.byte	$fe,$04,$66,$78,$00,$16,$2e,$09
>2338	dc bd 41 6f 7e fd 05 36			.byte	$dc,$bd,$41,$6f,$7e,$fd,$05,$36
>2340	31 37 84 40 fd 03 30 be			.byte	$31,$37,$84,$40,$fd,$03,$30,$be
>2348	84 40 00 13 38 09 dc bd			.byte	$84,$40,$00,$13,$38,$09,$dc,$bd
>2350	8b 43 47 40 55 85 4d 7e			.byte	$8b,$43,$47,$40,$55,$85,$4d,$7e
>2358	54 be 84 8b 41 00 17 42			.byte	$54,$be,$84,$8b,$41,$00,$17,$42
>2360	09 dc bd 42 71 61 6d 82			.byte	$09,$dc,$bd,$42,$71,$61,$6d,$82
>2368	8b 43 69 6f 6f be 84 8b			.byte	$8b,$43,$69,$6f,$6f,$be,$84,$8b
>2370	41 58 4e 44 00 16 4c 09			.byte	$41,$58,$4e,$44,$00,$16,$4c,$09
>2378	dc b2 8b 42 49 70 6e bf			.byte	$dc,$b2,$8b,$42,$49,$70,$6e,$bf
>2380	8b 42 44 5a 44 be 84 45			.byte	$8b,$42,$44,$5a,$44,$be,$84,$45
>2388	56 6a 00 13 56 09 dc a2			.byte	$56,$6a,$00,$13,$56,$09,$dc,$a2
>2390	fe 05 64 69 6c bf 45 bf			.byte	$fe,$05,$64,$69,$6c,$bf,$45,$bf
>2398	43 be 84 fe 02 00 1f 60			.byte	$43,$be,$84,$fe,$02,$00,$1f,$60
>23a0	09 dc bd 8b 41 4b 63 6d			.byte	$09,$dc,$bd,$8b,$41,$4b,$63,$6d
>23a8	fd 04 38 35 8b 8b 41 4b			.byte	$fd,$04,$38,$35,$8b,$8b,$41,$4b
>23b0	63 6d fd 04 38 35 be 84			.byte	$63,$6d,$fd,$04,$38,$35,$be,$84
>23b8	40 fd 03 30 00 18 6a 09			.byte	$40,$fd,$03,$30,$00,$18,$6a,$09
>23c0	dc bd 8b 43 5a 64 63 8a			.byte	$dc,$bd,$8b,$43,$5a,$64,$63,$8a
>23c8	8b 42 4e 53 66 be 84 8b			.byte	$8b,$42,$4e,$53,$66,$be,$84,$8b
>23d0	45 68 78 49 00 0f 74 09			.byte	$45,$68,$78,$49,$00,$0f,$74,$09
>23d8	dc bd 40 80 8b 69 43 44			.byte	$dc,$bd,$40,$80,$8b,$69,$43,$44
>23e0	be 84 40 00 10 7e 09 dc			.byte	$be,$84,$40,$00,$10,$7e,$09,$dc
>23e8	98 8b 43 47 46 47 84 43			.byte	$98,$8b,$43,$47,$46,$47,$84,$43
>23f0	47 46 46 00 0c 88 09 dc			.byte	$47,$46,$46,$00,$0c,$88,$09,$dc
>23f8	a6 fe 03 76 be 84 41 00			.byte	$a6,$fe,$03,$76,$be,$84,$41,$00
>2400	1a 92 09 dc bd 42 4d 78			.byte	$1a,$92,$09,$dc,$bd,$42,$4d,$78
>2408	61 fd 04 32 37 85 6c 6e			.byte	$61,$fd,$04,$32,$37,$85,$6c,$6e
>2410	45 fd 04 31 38 be 84 8b			.byte	$45,$fd,$04,$31,$38,$be,$84,$8b
>2418	41 00 10 9c 09 dc bd 42			.byte	$41,$00,$10,$9c,$09,$dc,$bd,$42
>2420	74 6a 4d 88 40 be 84 8b			.byte	$74,$6a,$4d,$88,$40,$be,$84,$8b
>2428	41 00 11 a6 09 dc bd 42			.byte	$41,$00,$11,$a6,$09,$dc,$bd,$42
>2430	70 55 67 80 42 4a 6a be			.byte	$70,$55,$67,$80,$42,$4a,$6a,$be
>2438	84 62 00 18 b0 09 dc a5			.byte	$84,$62,$00,$18,$b0,$09,$dc,$a5
>2440	a4 42 66 62 40 fd 03 32			.byte	$a4,$42,$66,$62,$40,$fd,$03,$32
>2448	be be 84 42 66 62 40 fd			.byte	$be,$be,$84,$42,$66,$62,$40,$fd
>2450	03 32 00 13 ba 09 dc 9b			.byte	$03,$32,$00,$13,$ba,$09,$dc,$9b
>2458	fe 09 6b 66 65 76 61 68			.byte	$fe,$09,$6b,$66,$65,$76,$61,$68
>2460	75 be 84 41 6b 00 17 c4			.byte	$75,$be,$84,$41,$6b,$00,$17,$c4
>2468	09 dc bd 40 fd 03 30 87			.byte	$09,$dc,$bd,$40,$fd,$03,$30,$87
>2470	41 50 4c 58 fd 04 37 38			.byte	$41,$50,$4c,$58,$fd,$04,$37,$38
>2478	be 84 8b 41 00 14 ce 09			.byte	$be,$84,$8b,$41,$00,$14,$ce,$09
>2480	dc bd 8b 42 77 45 5c 89			.byte	$dc,$bd,$8b,$42,$77,$45,$5c,$89
>2488	8b 42 53 50 45 be 84 40			.byte	$8b,$42,$53,$50,$45,$be,$84,$40
>2490	00 17 d8 09 dc bd 41 57			.byte	$00,$17,$d8,$09,$dc,$bd,$41,$57
>2498	7e 6f 82 8b 42 76 76 57			.byte	$7e,$6f,$82,$8b,$42,$76,$76,$57
>24a0	be 84 8b 43 61 48 7a 00			.byte	$be,$84,$8b,$43,$61,$48,$7a,$00
>24a8	10 e2 09 dc 9a 41 5c 6e			.byte	$10,$e2,$09,$dc,$9a,$41,$5c,$6e
>24b0	70 be 84 41 5c 6e 70 00			.byte	$70,$be,$84,$41,$5c,$6e,$70,$00
>24b8	0d ec 09 dc b4 41 5d be			.byte	$0d,$ec,$09,$dc,$b4,$41,$5d,$be
>24c0	84 fe 03 5d 00 16 f6 09			.byte	$84,$fe,$03,$5d,$00,$16,$f6,$09
>24c8	dc bd 40 fd 03 30 89 42			.byte	$dc,$bd,$40,$fd,$03,$30,$89,$42
>24d0	57 51 7e fd 04 32 37 be			.byte	$57,$51,$7e,$fd,$04,$32,$37,$be
>24d8	84 40 00 0f 00 0a dc bd			.byte	$84,$40,$00,$0f,$00,$0a,$dc,$bd
>24e0	40 87 8b 75 66 50 be 84			.byte	$40,$87,$8b,$75,$66,$50,$be,$84
>24e8	40 00 14 0a 0a dc bd 8b			.byte	$40,$00,$14,$0a,$0a,$dc,$bd,$8b
>24f0	41 40 4c 72 82 40 be 84			.byte	$41,$40,$4c,$72,$82,$40,$be,$84
>24f8	8b 41 40 4c 72 00 0e 14			.byte	$8b,$41,$40,$4c,$72,$00,$0e,$14
>2500	0a dc b3 8b 7f 68 5e be			.byte	$0a,$dc,$b3,$8b,$7f,$68,$5e,$be
>2508	84 8b 41 00 16 1e 0a dc			.byte	$84,$8b,$41,$00,$16,$1e,$0a,$dc
>2510	a3 4b be 84 fe 0d 20 20			.byte	$a3,$4b,$be,$84,$fe,$0d,$20,$20
>2518	20 20 20 20 20 20 20 20			.byte	$20,$20,$20,$20,$20,$20,$20,$20
>2520	20 00 1c 28 0a dc bd 8b			.byte	$20,$00,$1c,$28,$0a,$dc,$bd,$8b
>2528	43 45 79 60 fd 04 37 39			.byte	$43,$45,$79,$60,$fd,$04,$37,$39
>2530	85 43 64 68 64 fd 04 35			.byte	$85,$43,$64,$68,$64,$fd,$04,$35
>2538	32 be 84 8b 41 00 14 32			.byte	$32,$be,$84,$8b,$41,$00,$14,$32
>2540	0a dc bd 43 48 5b 59 85			.byte	$0a,$dc,$bd,$43,$48,$5b,$59,$85
>2548	8b 43 64 69 63 be 84 8b			.byte	$8b,$43,$64,$69,$63,$be,$84,$8b
>2550	41 00 10 3c 0a dc bd 40			.byte	$41,$00,$10,$3c,$0a,$dc,$bd,$40
>2558	80 8b 43 56 4c 56 be 84			.byte	$80,$8b,$43,$56,$4c,$56,$be,$84
>2560	40 00 17 46 0a dc b2 8b			.byte	$40,$00,$17,$46,$0a,$dc,$b2,$8b
>2568	42 61 61 62 bf 8b 43 6c			.byte	$42,$61,$61,$62,$bf,$8b,$43,$6c
>2570	59 4a be 84 42 61 61 62			.byte	$59,$4a,$be,$84,$42,$61,$61,$62
>2578	00 13 50 0a dc a7 41 6b			.byte	$00,$13,$50,$0a,$dc,$a7,$41,$6b
>2580	4f 7b be 84 fe 07 36 42			.byte	$4f,$7b,$be,$84,$fe,$07,$36,$42
>2588	33 46 42 00 19 5a 0a dc			.byte	$33,$46,$42,$00,$19,$5a,$0a,$dc
>2590	bd 43 54 5b 70 fd 03 34			.byte	$bd,$43,$54,$5b,$70,$fd,$03,$34
>2598	87 43 54 5b 70 fd 03 34			.byte	$87,$43,$54,$5b,$70,$fd,$03,$34
>25a0	be 84 8b 41 00 14 64 0a			.byte	$be,$84,$8b,$41,$00,$14,$64,$0a
>25a8	dc bd 8b 41 46 79 71 84			.byte	$dc,$bd,$8b,$41,$46,$79,$71,$84
>25b0	8b 42 72 56 77 be 84 40			.byte	$8b,$42,$72,$56,$77,$be,$84,$40
>25b8	00 16 6e 0a dc bd 8b 42			.byte	$00,$16,$6e,$0a,$dc,$bd,$8b,$42
>25c0	68 66 47 81 4e 48 63 be			.byte	$68,$66,$47,$81,$4e,$48,$63,$be
>25c8	84 8b 42 60 66 45 00 10			.byte	$84,$8b,$42,$60,$66,$45,$00,$10
>25d0	78 0a dc 98 43 68 66 49			.byte	$78,$0a,$dc,$98,$43,$68,$66,$49
>25d8	84 8b 43 68 66 4a 00 13			.byte	$84,$8b,$43,$68,$66,$4a,$00,$13
>25e0	82 0a dc af fe 07 36 41			.byte	$82,$0a,$dc,$af,$fe,$07,$36,$41
>25e8	31 45 33 be 84 41 6a 47			.byte	$31,$45,$33,$be,$84,$41,$6a,$47
>25f0	63 00 1a 8c 0a dc bd 41			.byte	$63,$00,$1a,$8c,$0a,$dc,$bd,$41
>25f8	6e 57 75 fd 04 36 36 84			.byte	$6e,$57,$75,$fd,$04,$36,$36,$84
>2600	42 4c 75 75 fd 04 35 33			.byte	$42,$4c,$75,$75,$fd,$04,$35,$33
>2608	be 84 40 00 15 96 0a dc			.byte	$be,$84,$40,$00,$15,$96,$0a,$dc
>2610	bd 8b 43 4c 75 7b 86 8b			.byte	$bd,$8b,$43,$4c,$75,$7b,$86,$8b
>2618	41 54 52 63 be 84 8b 41			.byte	$41,$54,$52,$63,$be,$84,$8b,$41
>2620	00 16 a0 0a dc bd 42 58			.byte	$00,$16,$a0,$0a,$dc,$bd,$42,$58
>2628	62 77 80 8b 41 54 68 48			.byte	$62,$77,$80,$8b,$41,$54,$68,$48
>2630	be 84 42 48 42 70 00 10			.byte	$be,$84,$42,$48,$42,$70,$00,$10
>2638	aa 0a dc a5 a4 7f 72 54			.byte	$aa,$0a,$dc,$a5,$a4,$7f,$72,$54
>2640	be be 84 7f 72 54 00 1a			.byte	$be,$be,$84,$7f,$72,$54,$00,$1a
>2648	b4 0a dc a0 fe 08 79 63			.byte	$b4,$0a,$dc,$a0,$fe,$08,$79,$63
>2650	62 66 62 6a bf 47 be 84			.byte	$62,$66,$62,$6a,$bf,$47,$be,$84
>2658	fe 08 79 63 62 66 62 6a			.byte	$fe,$08,$79,$63,$62,$66,$62,$6a
>2660	00 1c be 0a dc bd 8b 42			.byte	$00,$1c,$be,$0a,$dc,$bd,$8b,$42
>2668	72 7a 6f fd 04 32 37 85			.byte	$72,$7a,$6f,$fd,$04,$32,$37,$85
>2670	43 4b 61 4e fd 04 36 34			.byte	$43,$4b,$61,$4e,$fd,$04,$36,$34
>2678	be 84 8b 41 00 13 c8 0a			.byte	$be,$84,$8b,$41,$00,$13,$c8,$0a
>2680	dc bd 40 8b 41 60 79 78			.byte	$dc,$bd,$40,$8b,$41,$60,$79,$78
>2688	be 84 8b 41 60 79 78 00			.byte	$be,$84,$8b,$41,$60,$79,$78,$00
>2690	18 d2 0a dc bd 8b 41 4d			.byte	$18,$d2,$0a,$dc,$bd,$8b,$41,$4d
>2698	76 7b 80 8b 42 50 49 54			.byte	$76,$7b,$80,$8b,$42,$50,$49,$54
>26a0	be 84 8b 43 5d 7f 7c 00			.byte	$be,$84,$8b,$43,$5d,$7f,$7c,$00
>26a8	11 dc 0a dc 9a 8b 42 7c			.byte	$11,$dc,$0a,$dc,$9a,$8b,$42,$7c
>26b0	43 60 be 84 42 7c 43 60			.byte	$43,$60,$be,$84,$42,$7c,$43,$60
>26b8	00 18 e6 0a dc a1 fe 07			.byte	$00,$18,$e6,$0a,$dc,$a1,$fe,$07
>26c0	65 6a 68 6c 62 bf 48 be			.byte	$65,$6a,$68,$6c,$62,$bf,$48,$be
>26c8	84 fe 07 65 6a 68 6c 62			.byte	$84,$fe,$07,$65,$6a,$68,$6c,$62
>26d0	00 23 f0 0a dc bd 8b 42			.byte	$00,$23,$f0,$0a,$dc,$bd,$8b,$42
>26d8	5c 79 61 fd 04 35 32 8a			.byte	$5c,$79,$61,$fd,$04,$35,$32,$8a
>26e0	8b 43 59 59 7e fd 04 38			.byte	$8b,$43,$59,$59,$7e,$fd,$04,$38
>26e8	33 be 84 8b 45 76 53 60			.byte	$33,$be,$84,$8b,$45,$76,$53,$60
>26f0	fd 03 33 00 0f fa 0a dc			.byte	$fd,$03,$33,$00,$0f,$fa,$0a,$dc
>26f8	bd 8b 52 59 6e 8c 40 be			.byte	$bd,$8b,$52,$59,$6e,$8c,$40,$be
>2700	84 40 00 14 04 0b dc bd			.byte	$84,$40,$00,$14,$04,$0b,$dc,$bd
>2708	8b 5e 46 71 82 8b 65 56			.byte	$8b,$5e,$46,$71,$82,$8b,$65,$56
>2710	40 be 84 7b 53 4f 00 0c			.byte	$40,$be,$84,$7b,$53,$4f,$00,$0c
>2718	0e 0b dc b3 70 52 45 be			.byte	$0e,$0b,$dc,$b3,$70,$52,$45,$be
>2720	84 41 00 19 18 0b dc a2			.byte	$84,$41,$00,$19,$18,$0b,$dc,$a2
>2728	fe 09 65 6e 74 61 72 6d			.byte	$fe,$09,$65,$6e,$74,$61,$72,$6d
>2730	67 bf 46 bf 49 be 84 fe			.byte	$67,$bf,$46,$bf,$49,$be,$84,$fe
>2738	04 6d 67 00 21 22 0b dc			.byte	$04,$6d,$67,$00,$21,$22,$0b,$dc
>2740	bd 4c 41 66 fd 05 34 31			.byte	$bd,$4c,$41,$66,$fd,$05,$34,$31
>2748	39 8b 8b 42 7a 43 59 fd			.byte	$39,$8b,$8b,$42,$7a,$43,$59,$fd
>2750	03 38 be 84 43 46 45 40			.byte	$03,$38,$be,$84,$43,$46,$45,$40
>2758	fd 04 32 32 00 12 2c 0b			.byte	$fd,$04,$32,$32,$00,$12,$2c,$0b
>2760	dc bd 50 69 54 86 8b 43			.byte	$dc,$bd,$50,$69,$54,$86,$8b,$43
>2768	4d 55 51 be 84 40 00 18			.byte	$4d,$55,$51,$be,$84,$40,$00,$18
>2770	36 0b dc bd 8b 42 51 59			.byte	$36,$0b,$dc,$bd,$8b,$42,$51,$59
>2778	6e 80 8b 41 7a 43 5b be			.byte	$6e,$80,$8b,$41,$7a,$43,$5b,$be
>2780	84 8b 43 7b 5c 40 00 17			.byte	$84,$8b,$43,$7b,$5c,$40,$00,$17
>2788	40 0b dc b2 8b 43 55 54			.byte	$40,$0b,$dc,$b2,$8b,$43,$55,$54
>2790	68 bf 8b 42 4d 56 48 be			.byte	$68,$bf,$8b,$42,$4d,$56,$48,$be
>2798	84 41 47 7e 60 00 15 4a			.byte	$84,$41,$47,$7e,$60,$00,$15,$4a
>27a0	0b dc a6 fe 0c 63 61 79			.byte	$0b,$dc,$a6,$fe,$0c,$63,$61,$79
>27a8	62 77 66 76 69 79 7a be			.byte	$62,$77,$66,$76,$69,$79,$7a,$be
>27b0	84 4a 00 25 54 0b dc bd			.byte	$84,$4a,$00,$25,$54,$0b,$dc,$bd
>27b8	42 4f 41 5d fd 04 37 39			.byte	$42,$4f,$41,$5d,$fd,$04,$37,$39
>27c0	8d 8b 41 5c 41 6b fd 04			.byte	$8d,$8b,$41,$5c,$41,$6b,$fd,$04
>27c8	36 32 be 84 8b 41 fd 09			.byte	$36,$32,$be,$84,$8b,$41,$fd,$09
>27d0	35 35 34 31 35 32 39 00			.byte	$35,$35,$34,$31,$35,$32,$39,$00
>27d8	10 5e 0b dc bd 42 7d 4d			.byte	$10,$5e,$0b,$dc,$bd,$42,$7d,$4d
>27e0	68 89 40 be 84 8b 41 00			.byte	$68,$89,$40,$be,$84,$8b,$41,$00
>27e8	16 68 0b dc bd 42 63 66			.byte	$16,$68,$0b,$dc,$bd,$42,$63,$66
>27f0	48 81 8b 42 6a 6f 53 be			.byte	$48,$81,$8b,$42,$6a,$6f,$53,$be
>27f8	84 8b 48 49 53 00 10 72			.byte	$84,$8b,$48,$49,$53,$00,$10,$72
>2800	0b dc 98 8b 41 78 7e 42			.byte	$0b,$dc,$98,$8b,$41,$78,$7e,$42
>2808	84 41 78 7e 41 00 13 7c			.byte	$84,$41,$78,$7e,$41,$00,$13,$7c
>2810	0b dc 9b fe 09 6d 70 65			.byte	$0b,$dc,$9b,$fe,$09,$6d,$70,$65
>2818	6f 70 6e 66 be 84 41 6d			.byte	$6f,$70,$6e,$66,$be,$84,$41,$6d
>2820	00 25 86 0b dc bd 8b 43			.byte	$00,$25,$86,$0b,$dc,$bd,$8b,$43
>2828	55 61 46 fd 04 38 37 8d			.byte	$55,$61,$46,$fd,$04,$38,$37,$8d
>2830	42 5b 79 57 fd 04 35 34			.byte	$42,$5b,$79,$57,$fd,$04,$35,$34
>2838	be 84 8b 41 fd 09 33 36			.byte	$be,$84,$8b,$41,$fd,$09,$33,$36
>2840	39 36 31 30 35 00 12 90			.byte	$39,$36,$31,$30,$35,$00,$12,$90
>2848	0b dc bd 6f 40 77 84 8b			.byte	$0b,$dc,$bd,$6f,$40,$77,$84,$8b
>2850	41 5c 69 58 be 84 40 00			.byte	$41,$5c,$69,$58,$be,$84,$40,$00
>2858	16 9a 0b dc bd 43 45 62			.byte	$16,$9a,$0b,$dc,$bd,$43,$45,$62
>2860	47 81 8b 41 71 53 57 be			.byte	$47,$81,$8b,$41,$71,$53,$57,$be
>2868	84 8b 70 51 51 00 1c a4			.byte	$84,$8b,$70,$51,$51,$00,$1c,$a4
>2870	0b dc a5 a4 8b 43 6e 7f			.byte	$0b,$dc,$a5,$a4,$8b,$43,$6e,$7f
>2878	4b fd 04 39 33 be be 84			.byte	$4b,$fd,$04,$39,$33,$be,$be,$84
>2880	8b 43 6e 7f 4b fd 04 39			.byte	$8b,$43,$6e,$7f,$4b,$fd,$04,$39
>2888	33 00 0d ae 0b dc b4 41			.byte	$33,$00,$0d,$ae,$0b,$dc,$b4,$41
>2890	5d be 84 fe 03 5d 00 26			.byte	$5d,$be,$84,$fe,$03,$5d,$00,$26
>2898	b8 0b dc bd 8b 41 4d 6d			.byte	$b8,$0b,$dc,$bd,$8b,$41,$4d,$6d
>28a0	53 fd 04 33 38 8d 43 5c			.byte	$53,$fd,$04,$33,$38,$8d,$43,$5c
>28a8	5b 4d fd 04 32 32 be 84			.byte	$5b,$4d,$fd,$04,$32,$32,$be,$84
>28b0	8b 40 fd 0a 33 35 32 35			.byte	$8b,$40,$fd,$0a,$33,$35,$32,$35
>28b8	33 36 33 33 00 13 c2 0b			.byte	$33,$36,$33,$33,$00,$13,$c2,$0b
>28c0	dc bd 8b 41 50 44 58 89			.byte	$dc,$bd,$8b,$41,$50,$44,$58,$89
>28c8	42 51 5a 79 be 84 40 00			.byte	$42,$51,$5a,$79,$be,$84,$40,$00
>28d0	12 cc 0b dc bd 40 82 43			.byte	$12,$cc,$0b,$dc,$bd,$40,$82,$43
>28d8	59 73 44 be 84 43 59 73			.byte	$59,$73,$44,$be,$84,$43,$59,$73
>28e0	44 00 11 d6 0b dc 9a 8b			.byte	$44,$00,$11,$d6,$0b,$dc,$9a,$8b
>28e8	41 59 6d 6d be 84 41 59			.byte	$41,$59,$6d,$6d,$be,$84,$41,$59
>28f0	6d 6d 00 0b e0 0b dc a3			.byte	$6d,$6d,$00,$0b,$e0,$0b,$dc,$a3
>28f8	40 be 84 fe 02 00 22 ea			.byte	$40,$be,$84,$fe,$02,$00,$22,$ea
>2900	0b dc bd 41 68 42 51 fd			.byte	$0b,$dc,$bd,$41,$68,$42,$51,$fd
>2908	04 37 35 8b 8b 43 78 58			.byte	$04,$37,$35,$8b,$8b,$43,$78,$58
>2910	fd 05 35 33 32 be 84 41			.byte	$fd,$05,$35,$33,$32,$be,$84,$41
>2918	6b 7a 6a fd 04 32 38 00			.byte	$6b,$7a,$6a,$fd,$04,$32,$38,$00
>2920	16 f4 0b dc bd 41 7b 54			.byte	$16,$f4,$0b,$dc,$bd,$41,$7b,$54
>2928	5d 8b 8b 43 66 5e 56 be			.byte	$5d,$8b,$8b,$43,$66,$5e,$56,$be
>2930	84 45 61 72 73 00 14 fe			.byte	$84,$45,$61,$72,$73,$00,$14,$fe
>2938	0b dc bd 8b 43 50 4b 6c			.byte	$0b,$dc,$bd,$8b,$43,$50,$4b,$6c
>2940	80 79 4a 7d be 84 69 40			.byte	$80,$79,$4a,$7d,$be,$84,$69,$40
>2948	54 00 0f 08 0c dc b3 8b			.byte	$54,$00,$0f,$08,$0c,$dc,$b3,$8b
>2950	42 70 4f 4e be 84 8b 41			.byte	$42,$70,$4f,$4e,$be,$84,$8b,$41
>2958	00 0c 12 0c dc a7 40 be			.byte	$00,$0c,$12,$0c,$dc,$a7,$40,$be
>2960	84 fe 03 30 00 21 1c 0c			.byte	$84,$fe,$03,$30,$00,$21,$1c,$0c
>2968	dc bd 42 68 78 6c fd 04			.byte	$dc,$bd,$42,$68,$78,$6c,$fd,$04
>2970	34 32 8b 8b 41 50 56 67			.byte	$34,$32,$8b,$8b,$41,$50,$56,$67
>2978	fd 04 39 37 be 84 43 79			.byte	$fd,$04,$39,$37,$be,$84,$43,$79
>2980	4f 54 fd 03 34 00 10 26			.byte	$4f,$54,$fd,$03,$34,$00,$10,$26
>2988	0c dc bd 40 86 8b 43 4e			.byte	$0c,$dc,$bd,$40,$86,$8b,$43,$4e
>2990	74 5d be 84 40 00 18 30			.byte	$74,$5d,$be,$84,$40,$00,$18,$30
>2998	0c dc bd 8b 41 68 6a 41			.byte	$0c,$dc,$bd,$8b,$41,$68,$6a,$41
>29a0	81 8b 43 54 7b 55 be 84			.byte	$81,$8b,$43,$54,$7b,$55,$be,$84
>29a8	8b 41 40 6a 41 00 0f 3a			.byte	$8b,$41,$40,$6a,$41,$00,$0f,$3a
>29b0	0c dc b2 40 bf 8b 50 6d			.byte	$0c,$dc,$b2,$40,$bf,$8b,$50,$6d
>29b8	76 be 84 40 00 13 44 0c			.byte	$76,$be,$84,$40,$00,$13,$44,$0c
>29c0	dc af fe 07 35 41 36 35			.byte	$dc,$af,$fe,$07,$35,$41,$36,$35
>29c8	32 be 84 41 5a 59 52 00			.byte	$32,$be,$84,$41,$5a,$59,$52,$00
>29d0	22 4e 0c dc bd 8b 42 50			.byte	$22,$4e,$0c,$dc,$bd,$8b,$42,$50
>29d8	41 42 fd 04 39 34 8a 68			.byte	$41,$42,$fd,$04,$39,$34,$8a,$68
>29e0	6f 6d fd 04 30 31 be 84			.byte	$6f,$6d,$fd,$04,$30,$31,$be,$84
>29e8	8b 41 67 51 55 fd 04 39			.byte	$8b,$41,$67,$51,$55,$fd,$04,$39
>29f0	33 00 14 58 0c dc bd 40			.byte	$33,$00,$14,$58,$0c,$dc,$bd,$40
>29f8	8a 8b 42 73 75 72 be 84			.byte	$8a,$8b,$42,$73,$75,$72,$be,$84
>2a00	8b 42 73 75 72 00 15 62			.byte	$8b,$42,$73,$75,$72,$00,$15,$62
>2a08	0c dc bd 42 4e 56 6d 80			.byte	$0c,$dc,$bd,$42,$4e,$56,$6d,$80
>2a10	8b 43 5c 45 43 be 84 42			.byte	$8b,$43,$5c,$45,$43,$be,$84,$42
>2a18	52 6d 00 10 6c 0c dc 98			.byte	$52,$6d,$00,$10,$6c,$0c,$dc,$98
>2a20	42 47 6d 6e 84 8b 42 47			.byte	$42,$47,$6d,$6e,$84,$8b,$42,$47
>2a28	6d 6f 00 12 76 0c dc a0			.byte	$6d,$6f,$00,$12,$76,$0c,$dc,$a0
>2a30	fe 04 72 72 bf 47 be 84			.byte	$fe,$04,$72,$72,$bf,$47,$be,$84
>2a38	fe 04 72 72 00 25 80 0c			.byte	$fe,$04,$72,$72,$00,$25,$80,$0c
>2a40	dc bd 42 79 43 64 fd 04			.byte	$dc,$bd,$42,$79,$43,$64,$fd,$04
>2a48	33 36 8d 8b 42 40 68 5f			.byte	$33,$36,$8d,$8b,$42,$40,$68,$5f
>2a50	fd 04 36 35 be 84 8b 41			.byte	$fd,$04,$36,$35,$be,$84,$8b,$41
>2a58	fd 09 34 33 38 36 33 36			.byte	$fd,$09,$34,$33,$38,$36,$33,$36
>2a60	36 00 12 8a 0c dc bd 8b			.byte	$36,$00,$12,$8a,$0c,$dc,$bd,$8b
>2a68	6d 6f 58 85 56 4c 65 be			.byte	$6d,$6f,$58,$85,$56,$4c,$65,$be
>2a70	84 8b 41 00 17 94 0c dc			.byte	$84,$8b,$41,$00,$17,$94,$0c,$dc
>2a78	bd 8b 42 60 50 60 81 41			.byte	$bd,$8b,$42,$60,$50,$60,$81,$41
>2a80	70 47 6f be 84 8b 42 40			.byte	$70,$47,$6f,$be,$84,$8b,$42,$40
>2a88	50 51 00 1c 9e 0c dc a5			.byte	$50,$51,$00,$1c,$9e,$0c,$dc,$a5
>2a90	a4 8b 42 62 62 77 fd 04			.byte	$a4,$8b,$42,$62,$62,$77,$fd,$04
>2a98	30 39 be be 84 8b 42 62			.byte	$30,$39,$be,$be,$84,$8b,$42,$62
>2aa0	62 77 fd 04 30 39 00 16			.byte	$62,$77,$fd,$04,$30,$39,$00,$16
>2aa8	a8 0c dc a1 fe 09 69 68			.byte	$a8,$0c,$dc,$a1,$fe,$09,$69,$68
>2ab0	75 68 72 68 6d bf 41 be			.byte	$75,$68,$72,$68,$6d,$bf,$41,$be
>2ab8	84 fe 03 6d 00 1f b2 0c			.byte	$84,$fe,$03,$6d,$00,$1f,$b2,$0c
>2ac0	dc bd 8b 42 5b 67 53 fd			.byte	$dc,$bd,$8b,$42,$5b,$67,$53,$fd
>2ac8	04 31 34 8a 40 fd 03 30			.byte	$04,$31,$34,$8a,$40,$fd,$03,$30
>2ad0	be 84 8b 42 5b 67 53 fd			.byte	$be,$84,$8b,$42,$5b,$67,$53,$fd
>2ad8	04 31 34 00 17 bc 0c dc			.byte	$04,$31,$34,$00,$17,$bc,$0c,$dc
>2ae0	bd 8b 43 6f 6f 74 8a 41			.byte	$bd,$8b,$43,$6f,$6f,$74,$8a,$41
>2ae8	77 4a 49 be 84 8b 41 78			.byte	$77,$4a,$49,$be,$84,$8b,$41,$78
>2af0	65 6b 00 17 c6 0c dc bd			.byte	$65,$6b,$00,$17,$c6,$0c,$dc,$bd
>2af8	8b 42 7c 62 71 82 8b 41			.byte	$8b,$42,$7c,$62,$71,$82,$8b,$41
>2b00	60 5b 74 be 84 43 5c 79			.byte	$60,$5b,$74,$be,$84,$43,$5c,$79
>2b08	43 00 11 d0 0c dc 9a 8b			.byte	$43,$00,$11,$d0,$0c,$dc,$9a,$8b
>2b10	41 44 55 77 be 84 41 44			.byte	$41,$44,$55,$77,$be,$84,$41,$44
>2b18	55 77 00 1a da 0c dc a2			.byte	$55,$77,$00,$1a,$da,$0c,$dc,$a2
>2b20	fe 09 6a 6b 73 71 72 65			.byte	$fe,$09,$6a,$6b,$73,$71,$72,$65
>2b28	64 bf 45 bf 48 be 84 fe			.byte	$64,$bf,$45,$bf,$48,$be,$84,$fe
>2b30	05 72 65 64 00 23 e4 0c			.byte	$05,$72,$65,$64,$00,$23,$e4,$0c
>2b38	dc bd 42 64 63 7c fd 04			.byte	$dc,$bd,$42,$64,$63,$7c,$fd,$04
>2b40	34 37 8d 42 56 47 6e fd			.byte	$34,$37,$8d,$42,$56,$47,$6e,$fd
>2b48	04 37 37 be 84 41 fd 09			.byte	$04,$37,$37,$be,$84,$41,$fd,$09
>2b50	30 39 36 31 39 34 38 00			.byte	$30,$39,$36,$31,$39,$34,$38,$00
>2b58	14 ee 0c dc bd 8b 41 65			.byte	$14,$ee,$0c,$dc,$bd,$8b,$41,$65
>2b60	4c 75 85 8b 73 75 5d be			.byte	$4c,$75,$85,$8b,$73,$75,$5d,$be
>2b68	84 8b 41 00 15 f8 0c dc			.byte	$84,$8b,$41,$00,$15,$f8,$0c,$dc
>2b70	bd 43 4f 78 54 80 41 40			.byte	$bd,$43,$4f,$78,$54,$80,$41,$40
>2b78	5b 41 be 84 41 40 58 40			.byte	$5b,$41,$be,$84,$41,$40,$58,$40
>2b80	00 0f 02 0d dc b3 8b 42			.byte	$00,$0f,$02,$0d,$dc,$b3,$8b,$42
>2b88	74 7b 4e be 84 8b 41 00			.byte	$74,$7b,$4e,$be,$84,$8b,$41,$00
>2b90	0e 0c 0d dc a6 fe 05 73			.byte	$0e,$0c,$0d,$dc,$a6,$fe,$05,$73
>2b98	65 68 be 84 43 00 16 16			.byte	$65,$68,$be,$84,$43,$00,$16,$16
>2ba0	0d dc bd 40 fd 03 30 87			.byte	$0d,$dc,$bd,$40,$fd,$03,$30,$87
>2ba8	8b 6c 4a 57 fd 04 31 37			.byte	$8b,$6c,$4a,$57,$fd,$04,$31,$37
>2bb0	be 84 40 00 13 20 0d dc			.byte	$be,$84,$40,$00,$13,$20,$0d,$dc
>2bb8	bd 8b 79 68 43 86 42 7f			.byte	$bd,$8b,$79,$68,$43,$86,$42,$7f
>2bc0	62 7b be 84 8b 41 00 12			.byte	$62,$7b,$be,$84,$8b,$41,$00,$12
>2bc8	2a 0d dc bd 41 44 6c 6a			.byte	$2a,$0d,$dc,$bd,$41,$44,$6c,$6a
>2bd0	80 43 76 58 be 84 64 48			.byte	$80,$43,$76,$58,$be,$84,$64,$48
>2bd8	00 17 34 0d dc b2 8b 41			.byte	$00,$17,$34,$0d,$dc,$b2,$8b,$41
>2be0	4c 5d 56 bf 8b 42 43 50			.byte	$4c,$5d,$56,$bf,$8b,$42,$43,$50
>2be8	6f be 84 41 4c 5d 56 00			.byte	$6f,$be,$84,$41,$4c,$5d,$56,$00
>2bf0	16 3e 0d dc 9b fe 0c 6c			.byte	$16,$3e,$0d,$dc,$9b,$fe,$0c,$6c
>2bf8	66 65 6c 6e 65 78 65 7a			.byte	$66,$65,$6c,$6e,$65,$78,$65,$7a
>2c00	6f be 84 41 6c 00 1c 48			.byte	$6f,$be,$84,$41,$6c,$00,$1c,$48
>2c08	0d dc bd 8b 65 73 4d fd			.byte	$0d,$dc,$bd,$8b,$65,$73,$4d,$fd
>2c10	04 39 35 88 8b 42 7a 41			.byte	$04,$39,$35,$88,$8b,$42,$7a,$41
>2c18	47 fd 04 34 36 be 84 8b			.byte	$47,$fd,$04,$34,$36,$be,$84,$8b
>2c20	41 00 14 52 0d dc bd 8b			.byte	$41,$00,$14,$52,$0d,$dc,$bd,$8b
>2c28	42 7b 67 57 8d 41 40 54			.byte	$42,$7b,$67,$57,$8d,$41,$40,$54
>2c30	41 be 84 8b 42 00 18 5c			.byte	$41,$be,$84,$8b,$42,$00,$18,$5c
>2c38	0d dc bd 8b 43 4a 4b 7e			.byte	$0d,$dc,$bd,$8b,$43,$4a,$4b,$7e
>2c40	80 8b 41 7b 6e 62 be 84			.byte	$80,$8b,$41,$7b,$6e,$62,$be,$84
>2c48	8b 43 7b 6f 7e 00 0e 66			.byte	$8b,$43,$7b,$6f,$7e,$00,$0e,$66
>2c50	0d dc 98 73 7b 74 84 8b			.byte	$0d,$dc,$98,$73,$7b,$74,$84,$8b
>2c58	73 7b 75 00 0d 70 0d dc			.byte	$73,$7b,$75,$00,$0d,$70,$0d,$dc
>2c60	b4 41 50 be 84 fe 03 50			.byte	$b4,$41,$50,$be,$84,$fe,$03,$50
>2c68	00 1a 7a 0d dc bd 41 79			.byte	$00,$1a,$7a,$0d,$dc,$bd,$41,$79
>2c70	55 5d fd 04 33 37 84 42			.byte	$55,$5d,$fd,$04,$33,$37,$84,$42
>2c78	51 59 7b fd 04 34 37 be			.byte	$51,$59,$7b,$fd,$04,$34,$37,$be
>2c80	84 40 00 12 84 0d dc bd			.byte	$84,$40,$00,$12,$84,$0d,$dc,$bd
>2c88	41 53 4f 48 84 41 44 59			.byte	$41,$53,$4f,$48,$84,$41,$44,$59
>2c90	64 be 84 40 00 15 8e 0d			.byte	$64,$be,$84,$40,$00,$15,$8e,$0d
>2c98	dc bd 43 61 59 43 81 42			.byte	$dc,$bd,$43,$61,$59,$43,$81,$42
>2ca0	6d 59 55 be 84 43 6d 59			.byte	$6d,$59,$55,$be,$84,$43,$6d,$59
>2ca8	57 00 12 98 0d dc a5 a4			.byte	$57,$00,$12,$98,$0d,$dc,$a5,$a4
>2cb0	43 58 7f 69 be be 84 43			.byte	$43,$58,$7f,$69,$be,$be,$84,$43
>2cb8	58 7f 69 00 1d a2 0d dc			.byte	$58,$7f,$69,$00,$1d,$a2,$0d,$dc
>2cc0	a3 52 be 84 fe 14 20 20			.byte	$a3,$52,$be,$84,$fe,$14,$20,$20
>2cc8	20 20 20 20 20 20 20 20			.byte	$20,$20,$20,$20,$20,$20,$20,$20
>2cd0	20 20 20 20 20 20 20 20			.byte	$20,$20,$20,$20,$20,$20,$20,$20
>2cd8	00 29 ac 0d d6 fe 22 50			.byte	$00,$29,$ac,$0d,$d6,$fe,$22,$50
>2ce0	61 73 73 65 64 20 41 72			.byte	$61,$73,$73,$65,$64,$20,$41,$72
>2ce8	69 74 68 6d 65 74 69 63			.byte	$69,$74,$68,$6d,$65,$74,$69,$63
>2cf0	2c 4c 6f 67 69 63 61 6c			.byte	$2c,$4c,$6f,$67,$69,$63,$61,$6c
>2cf8	2c 55 6e 61 72 79 2e c0			.byte	$2c,$55,$6e,$61,$72,$79,$2e,$c0
>2d00	c4 00 00				.byte	$c4,$00,$00

;******  Return to file: modules/hardware/em65816.asm

.c000					StartROM:
.c000	18		clc				clc
.c001	fb		xce				xce
.c002	c2 30		rep #$30			rep 	#$30
.c004	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.c007	1b		tcs				tcs
.c008	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.c00b	e2 30		sep #$30			sep 	#$30
.c00d	c2 30		rep #$30			rep 	#$30						; clear AXY in 16 bit.
.c00f	a9 00		lda #$00			lda 	#$0000
.c011	aa		tax				tax
.c012	a8		tay				tay
.c013	e2 30		sep #$30			sep 	#$30
.c015	5c 01 88 01	jmp $018801		jmp BASIC_Start
.c019					TIM_BreakHandler:
.c019	5c 69 83 01	jmp $018369			jmp 	TIM_BreakVector

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.018000					IFT_ClearScreen:
.018000	48		pha				pha
.018001	da		phx				phx
.018002	5a		phy				phy
.018003	20 9c 81	jsr $01819c			jsr 	IF_Home 					; home cursor
.018006	a2 20		ldx #$20			ldx 	#IF_Height 					; this many lines.
.018008					_IFT_CS0:
.018008	a0 40		ldy #$40			ldy 	#IF_Width 					; this many chars/line
.01800a					_IFT_CS1:
.01800a	a9 20		lda #$20			lda 	#' '						; clear line.
.01800c	20 c8 81	jsr $0181c8			jsr 	IF_Write
.01800f	88		dey				dey
.018010	d0 f8		bne $01800a			bne 	_IFT_CS1
.018012	20 af 81	jsr $0181af			jsr 	IF_NewLine 					; next line down
.018015	ca		dex				dex
.018016	d0 f0		bne $018008			bne 	_IFT_CS0
.018018	7a		ply				ply
.018019	fa		plx				plx
.01801a	68		pla				pla
.01801b					IFT_HomeCursor:
.01801b	48		pha				pha
.01801c	20 9c 81	jsr $01819c			jsr 	IF_Home
.01801f	a9 00		lda #$00			lda 	#0
.018021	8d 00 05	sta $0500			sta 	IFT_XCursor
.018024	8d 01 05	sta $0501			sta 	IFT_YCursor
.018027	68		pla				pla
.018028	60		rts				rts
.018029					IFT_UpLine:
.018029	48		pha				pha
.01802a	ad 01 05	lda $0501			lda  	IFT_YCursor 				; get Y
.01802d	3a		dec a				dec 	a 							; line above
.01802e	30 03		bmi $018033			bmi 	_IFTULExit 					; too far, abort
.018030	20 be 80	jsr $0180be			jsr 	IFT_SetYPos					; set to that line.
.018033					_IFTULExit:
.018033	68		pla				pla
.018034	60		rts				rts
.018035					IFT_PrintCharacter:
.018035	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.018037	f0 16		beq $01804f			beq 	IFT_NewLine
.018039	48		pha				pha
.01803a	20 67 80	jsr $018067			jsr 	IFT_UpperCase 				; make upper case
.01803d	20 c8 81	jsr $0181c8			jsr 	IF_Write 					; write out.
.018040	ee 00 05	inc $0500			inc 	IFT_XCursor 				; bump x cursor
.018043	ad 00 05	lda $0500			lda 	IFT_XCursor 				; reached RHS ?
.018046	c9 40		cmp #$40			cmp 	#IF_Width
.018048	d0 03		bne $01804d			bne 	_IFT_PCNotEOL
.01804a	20 4f 80	jsr $01804f			jsr 	IFT_NewLine 				; if so do new line.
.01804d					_IFT_PCNotEOL:
.01804d	68		pla				pla
.01804e	60		rts				rts
.01804f					IFT_NewLine:
.01804f	48		pha				pha
.018050	20 af 81	jsr $0181af			jsr 	IF_NewLine 					; new line on actual screen.
.018053	a9 00		lda #$00			lda 	#0 							; reset x position
.018055	8d 00 05	sta $0500			sta 	IFT_XCursor
.018058	ee 01 05	inc $0501			inc 	IFT_YCursor 				; move down.
.01805b	ad 01 05	lda $0501			lda 	IFT_YCursor
.01805e	c9 20		cmp #$20			cmp 	#IF_Height 					; reached bottom.
.018060	d0 03		bne $018065			bne 	_IFT_NL_NotEOS
.018062	20 72 80	jsr $018072			jsr 	IFT_Scroll 					; scroll screen up.
.018065					_IFT_NL_NotEOS:
.018065	68		pla				pla
.018066	60		rts				rts
.018067					IFT_UpperCase:
.018067	c9 61		cmp #$61			cmp 	#"a"
.018069	90 06		bcc $018071			bcc 	_IFT_UCExit
.01806b	c9 7b		cmp #$7b			cmp 	#"z"+1
.01806d	b0 02		bcs $018071			bcs 	_IFT_UCExit
.01806f	49 20		eor #$20			eor 	#$20
.018071					_IFT_UCExit:
.018071	60		rts				rts
.018072					IFT_Scroll:
.018072	48		pha				pha 								; save AXY
.018073	da		phx				phx
.018074	5a		phy				phy
.018075	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.018077					_IFT_SLoop:
.018077	20 97 80	jsr $018097			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.01807a	e8		inx				inx
.01807b	e0 1f		cpx #$1f			cpx 	#IF_Height-1				; do whole screen
.01807d	d0 f8		bne $018077			bne 	_IFT_SLoop
.01807f	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.018081	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.018084	a2 40		ldx #$40			ldx 	#IF_Width 					; blank line
.018086					_IFT_SBlank:
.018086	a9 20		lda #$20			lda 	#32
.018088	20 c8 81	jsr $0181c8			jsr 	IF_Write
.01808b	ca		dex				dex
.01808c	d0 f8		bne $018086			bne 	_IFT_SBlank
.01808e	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.018090	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.018093	7a		ply				ply
.018094	fa		plx				plx
.018095	68		pla				pla
.018096	60		rts				rts
.018097					_IFT_ScrollLine:
.018097	da		phx				phx
.018098	da		phx				phx
.018099	8a		txa				txa 								; copy line into buffer.
.01809a	1a		inc a				inc 	a 							; next line down.
.01809b	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.01809e	a2 00		ldx #$00			ldx 	#0
.0180a0					_IFTScrollCopy1:
.0180a0	20 bf 81	jsr $0181bf			jsr 	IF_Read
.0180a3	9d 02 05	sta $0502,x			sta 	IFT_Buffer,x
.0180a6	e8		inx				inx
.0180a7	e0 40		cpx #$40			cpx 	#IF_Width
.0180a9	d0 f5		bne $0180a0			bne 	_IFTScrollCopy1
.0180ab	68		pla				pla
.0180ac	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.0180af	a2 00		ldx #$00			ldx 	#0
.0180b1					_IFTScrollCopy2:
.0180b1	bd 02 05	lda $0502,x			lda 	IFT_Buffer,x
.0180b4	20 c8 81	jsr $0181c8			jsr 	IF_Write
.0180b7	e8		inx				inx
.0180b8	e0 40		cpx #$40			cpx 	#IF_Width
.0180ba	d0 f5		bne $0180b1			bne 	_IFTScrollCopy2
.0180bc	fa		plx				plx
.0180bd	60		rts				rts
.0180be					IFT_SetYPos:
.0180be	48		pha				pha
.0180bf	da		phx				phx
.0180c0	aa		tax				tax
.0180c1	20 1b 80	jsr $01801b			jsr 	IFT_HomeCursor
.0180c4	e0 00		cpx #$00			cpx 	#0
.0180c6	f0 09		beq $0180d1			beq 	_IFT_MOAExit
.0180c8					_IFT_MOALoop:
.0180c8	20 af 81	jsr $0181af			jsr 	IF_NewLine
.0180cb	ee 01 05	inc $0501			inc 	IFT_YCursor
.0180ce	ca		dex				dex
.0180cf	d0 f7		bne $0180c8			bne		_IFT_MOALoop
.0180d1					_IFT_MOAExit:
.0180d1	fa		plx				plx
.0180d2	68		pla				pla
.0180d3	60		rts				rts
.0180d4					IFT_GetKeyCursor:
.0180d4	20 dc 80	jsr $0180dc			jsr 	_IFT_FlipCursor 			; reverse current
.0180d7					_IFT_GKCWait:
.0180d7	20 d9 81	jsr $0181d9			jsr 	IF_GetKey 					; get key
.0180da	f0 fb		beq $0180d7			beq 	_IFT_GKCWait
.0180dc					_IFT_FlipCursor:
.0180dc	48		pha				pha 								; save
.0180dd	20 bf 81	jsr $0181bf			jsr 	IF_Read 					; read
.0180e0	20 d1 81	jsr $0181d1			jsr 	IF_LeftOne
.0180e3	49 80		eor #$80			eor 	#$80 						; reverse
.0180e5	20 c8 81	jsr $0181c8			jsr 	IF_Write 					; write
.0180e8	20 d1 81	jsr $0181d1			jsr 	IF_LeftOne
.0180eb	68		pla				pla
.0180ec	60		rts				rts
.0180ed					IFT_ReadLine:
.0180ed	48		pha				pha
.0180ee					_IFT_RLLoop:
.0180ee	20 d4 80	jsr $0180d4			jsr 	IFT_GetKeyCursor 			; get keystroke
.0180f1	c9 0d		cmp #$0d			cmp 	#13							; return
.0180f3	f0 7d		beq $018172			beq 	_IFT_RLExit
.0180f5	c9 20		cmp #$20			cmp 	#32 						; control character
.0180f7	90 05		bcc $0180fe			bcc 	_IFT_Control
.0180f9	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0180fc	80 f0		bra $0180ee			bra 	_IFT_RLLoop
.0180fe					_IFT_Control:
.0180fe	c9 01		cmp #$01			cmp 	#"A"-64
.018100	f0 26		beq $018128			beq 	_IFT_Left
.018102	c9 04		cmp #$04			cmp 	#"D"-64
.018104	f0 2e		beq $018134			beq 	_IFT_Right
.018106	c9 17		cmp #$17			cmp 	#"W"-64
.018108	f0 36		beq $018140			beq 	_IFT_Up
.01810a	c9 13		cmp #$13			cmp 	#"S"-64
.01810c	f0 3e		beq $01814c			beq 	_IFT_Down
.01810e	c9 08		cmp #$08			cmp 	#"H"-64
.018110	f0 09		beq $01811b			beq 	_IFT_Backspace
.018112	c9 1a		cmp #$1a			cmp 	#"Z"-64
.018114	d0 d8		bne $0180ee			bne 	_IFT_RLLoop
.018116	20 00 80	jsr $018000			jsr 	IFT_ClearScreen				; clear CTL-Z
.018119	80 d3		bra $0180ee			bra 	_IFT_RLLoop
.01811b					_IFT_Backspace:
.01811b	ad 00 05	lda $0500			lda 	IFT_XCursor 				; check not start of line.
.01811e	f0 ce		beq $0180ee			beq 	_IFT_RLLoop
.018120	20 d1 81	jsr $0181d1			jsr 	IF_LeftOne
.018123	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.018125	20 c8 81	jsr $0181c8			jsr 	IF_Write
.018128					_IFT_Left:
.018128	ce 00 05	dec $0500			dec 	IFT_XCursor 				; left CTL-W
.01812b	10 29		bpl $018156			bpl 	_IFT_Reposition
.01812d	a9 3f		lda #$3f			lda 	#IF_Width-1
.01812f					_IFT_SetX:
.01812f	8d 00 05	sta $0500			sta 	IFT_XCursor
.018132	80 22		bra $018156			bra 	_IFT_Reposition
.018134					_IFT_Right:
.018134	ee 00 05	inc $0500			inc 	IFT_XCursor
.018137	ad 00 05	lda $0500			lda 	IFT_XCursor
.01813a	49 40		eor #$40			eor 	#IF_Width
.01813c	f0 f1		beq $01812f			beq 	_IFT_SetX
.01813e	80 16		bra $018156			bra 	_IFT_Reposition
.018140					_IFT_Up:
.018140	ce 01 05	dec $0501			dec 	IFT_YCursor
.018143	10 11		bpl $018156			bpl 	_IFT_Reposition
.018145	a9 1f		lda #$1f			lda 	#IF_Height-1
.018147					_IFT_SetY:
.018147	8d 01 05	sta $0501			sta 	IFT_YCursor
.01814a	80 0a		bra $018156			bra 	_IFT_Reposition
.01814c					_IFT_Down:
.01814c	ee 01 05	inc $0501			inc 	IFT_YCursor
.01814f	ad 01 05	lda $0501			lda 	IFT_YCursor
.018152	49 20		eor #$20			eor 	#IF_Height
.018154	f0 f1		beq $018147			beq 	_IFT_SetY
.018156					_IFT_Reposition:
.018156	ad 00 05	lda $0500			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.018159	48		pha				pha
.01815a	ad 01 05	lda $0501			lda 	IFT_YCursor
.01815d	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.018160	68		pla				pla
.018161	aa		tax				tax
.018162	e0 00		cpx #$00			cpx 	#0
.018164	f0 88		beq $0180ee			beq 	_IFT_RLLoop
.018166					_IFT_MoveRight:
.018166	20 bf 81	jsr $0181bf			jsr 	IF_Read
.018169	ee 00 05	inc $0500			inc 	IFT_XCursor
.01816c	ca		dex				dex
.01816d	d0 f7		bne $018166			bne 	_IFT_MoveRight
.01816f	4c ee 80	jmp $0180ee			jmp 	_IFT_RLLoop
.018172					_IFT_RLExit:
.018172	ad 01 05	lda $0501			lda 	IFT_YCursor 				; go to start of line.
.018175	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.018178	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.01817a					_IFT_RLRead:
.01817a	20 bf 81	jsr $0181bf			jsr 	IF_Read
.01817d	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.018180	e8		inx				inx
.018181	e0 40		cpx #$40			cpx 	#IF_Width
.018183	d0 f5		bne $01817a			bne 	_IFT_RLRead
.018185					_IFT_RL_Trim:
.018185	ca		dex				dex 	 							; previous char
.018186	30 07		bmi $01818f			bmi 	_IFT_Found 					; gone too far
.018188	bd 66 05	lda $0566,x			lda 	IFT_LineBuffer,x			; go back if space
.01818b	c9 20		cmp #$20			cmp 	#" "
.01818d	f0 f6		beq $018185			beq 	_IFT_RL_Trim
.01818f					_IFT_Found:
.01818f	e8		inx				inx 								; forward to non-space
.018190	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.018192	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.018195	68		pla				pla
.018196	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.018198	a0 05		ldy #$05			ldy 	#IFT_LineBuffer >> 8
.01819a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_em65816.asm

=64					IF_Width 	= 64 							; characters across
=32					IF_Height 	= 32 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line.
=8					IF_XPos 	= 8 							; current position, horizontal.
=$f0000					IF_Screen = $F0000							; 2k screen RAM here
=$f8010					IF_PKeyboard = $F8010						; Keyboard port.
=$f8000					IF_PBreak = $F8000 							; Break key.
.01819b					IF_Reset:
.01819b	60		rts				rts
.01819c					IF_Home:
.01819c	48		pha				pha
.01819d	64 08		stz $08				stz 	IF_XPos 					; zero X position
.01819f	a9 00		lda #$00			lda 	#IF_Screen & $FF 			; set r/w pos.
.0181a1	85 04		sta $04				sta 	IF_Pos
.0181a3	a9 00		lda #$00			lda 	#(IF_Screen >> 8) & $FF
.0181a5	85 05		sta $05				sta 	IF_Pos+1
.0181a7	a9 0f		lda #$0f			lda 	#IF_Screen >> 16
.0181a9	85 06		sta $06				sta 	IF_Pos+2
.0181ab	64 07		stz $07				stz 	IF_Pos+3
.0181ad	68		pla				pla
.0181ae	60		rts				rts
.0181af					IF_NewLine:
.0181af	48		pha				pha
.0181b0	64 08		stz $08				stz 	IF_XPos						; back to start of line
.0181b2	18		clc				clc 								; down one line
.0181b3	a5 04		lda $04				lda 	IF_Pos
.0181b5	69 40		adc #$40			adc 	#64
.0181b7	85 04		sta $04				sta 	IF_Pos
.0181b9	90 02		bcc $0181bd			bcc 	_IF_NoCarry 				; carry through.
.0181bb	e6 05		inc $05				inc 	IF_Pos+1
.0181bd					_IF_NoCarry:
.0181bd	68		pla				pla
.0181be	60		rts				rts
.0181bf					IF_Read:
.0181bf	5a		phy				phy 								; save current Y
.0181c0	a4 08		ldy $08				ldy 	IF_XPos 					; read character at current position
.0181c2	b7 04		lda [$04],y			lda 	[IF_Pos],y
.0181c4	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181c6	7a		ply				ply									; restore Y
.0181c7	60		rts				rts
.0181c8					IF_Write:
.0181c8	5a		phy				phy 								; save current Y
.0181c9	a4 08		ldy $08				ldy 	IF_XPos 					; write character at current position
.0181cb	97 04		sta [$04],y			sta 	[IF_Pos],y
.0181cd	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181cf	7a		ply				ply									; restore Y
.0181d0	60		rts				rts
.0181d1					IF_LeftOne:
.0181d1	c6 08		dec $08				dec 	IF_XPos
.0181d3	60		rts				rts
.0181d4					IF_CheckBreak:
.0181d4	af 00 80 0f	lda $0f8000			lda 	IF_PBreak					; non-zero if Ctrl+C pressed.
.0181d8	60		rts				rts
.0181d9					IF_GetKey:
.0181d9	af 10 80 0f	lda $0f8010			lda 	IF_PKeyboard				; read keyboard
.0181dd	f0 08		beq $0181e7			beq		_IFGK_NoKey 				; skip if zero,no key pressed
.0181df	48		pha				pha 								; key pressed, clear queue.
.0181e0	a9 00		lda #$00			lda 	#0
.0181e2	8f 10 80 0f	sta $0f8010			sta 	IF_PKeyboard
.0181e6	68		pla				pla
.0181e7					_IFGK_NoKey:
.0181e7	09 00		ora #$00			ora 	#0							; set Z flag appropriately.
.0181e9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.0181ea					TIM_Error:
.0181ea	20 29 80	jsr $018029			jsr 	IFT_UpLine 					; go up one line.
.0181ed	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.0181ef	80 02		bra $0181f3			bra 	TIM_ShowPrompt
.0181f1					TIM_NewCommand:
.0181f1	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.0181f3					TIM_ShowPrompt:
.0181f3	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.0181f6	20 ed 80	jsr $0180ed			jsr 	IFT_ReadLine	 			; get character, go to next line
.0181f9	20 4f 80	jsr $01804f			jsr 	IFT_NewLine					; go to next line.
.0181fc	86 10		stx $10				stx 	zTemp1 						; save line read address
.0181fe	84 11		sty $11				sty 	zTemp1+1
.018200	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.018202	b1 10		lda ($10),y			lda 	(zTemp1),y
.018204	c9 3f		cmp #$3f			cmp 	#"?"
.018206	f0 04		beq $01820c			beq 	TIM_SkipFirst
.018208	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.01820a	d0 01		bne $01820d			bne 	TIM_NotDot
.01820c					TIM_SkipFirst:
.01820c	c8		iny				iny
.01820d					TIM_NotDot:
.01820d	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.01820f	c9 52		cmp #$52			cmp 	#"R"						; show registers
.018211	f0 6b		beq $01827e			beq 	TIM_ShowRegisters
.018213	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.018215	f0 12		beq $018229			beq 	TIM_ShowMemory
.018217	c9 47		cmp #$47			cmp 	#"G"						; execute
.018219	f0 49		beq $018264			beq 	TIM_Execute
.01821b	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.01821d	f0 07		beq $018226			beq 	TIM_GoLoadMemory
.01821f	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.018221	d0 c7		bne $0181ea			bne 	TIM_Error
.018223	4c a2 83	jmp $0183a2			jmp 	TIM_UpdateRegisters
.018226					TIM_GoLoadMemory:
.018226	4c d2 83	jmp $0183d2			jmp 	TIM_LoadMemory
.018229					TIM_ShowMemory:
.018229	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.01822c	b0 bc		bcs $0181ea			bcs 	TIM_Error
.01822e	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.018230	85 12		sta $12				sta 	zTemp2
.018232	a5 15		lda $15				lda 	zTemp3+1
.018234	85 13		sta $13				sta 	zTemp2+1
.018236	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.018239	90 08		bcc $018243			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.01823b	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.01823d	85 14		sta $14				sta 	zTemp3
.01823f	a5 13		lda $13				lda 	zTemp2+1
.018241	85 15		sta $15				sta 	zTemp3+1
.018243					_TIMSM_Start:
.018243	20 f6 82	jsr $0182f6			jsr 	TIM_WriteLine 				; write one line of hex out
.018246	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.018248	18		clc				clc
.018249	69 10		adc #$10			adc 	#16
.01824b	85 12		sta $12				sta 	zTemp2
.01824d	90 02		bcc $018251			bcc 	_TIMSM_NoCarry
.01824f	e6 13		inc $13				inc 	zTemp2+1
.018251					_TIMSM_NoCarry:
.018251	20 d4 81	jsr $0181d4			jsr 	IF_CheckBreak 				; check CTL+C
.018254	d0 0b		bne $018261			bne 	_TIMSM_Ends 				; if pressed break out.
.018256	38		sec				sec 								; check past the end address in zTemp3
.018257	a5 14		lda $14				lda 	zTemp3
.018259	e5 12		sbc $12				sbc 	zTemp2
.01825b	a5 15		lda $15				lda 	zTemp3+1
.01825d	e5 13		sbc $13				sbc 	zTemp2+1
.01825f	10 e2		bpl $018243			bpl 	_TIMSM_Start
.018261					_TIMSM_Ends:
.018261	4c f1 81	jmp $0181f1			jmp 	TIM_NewCommand
.018264					TIM_Execute:
.018264	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; get the execute address
.018267	b0 81		bcs $0181ea			bcs 	TIM_Error 					; not legitimate
.018269	ae cc 03	ldx $03cc			ldx 	TIM_SP 						; set up SP
.01826c	9a		txs				txs
.01826d	ad c7 03	lda $03c7			lda 	TIM_SR 						; Status for PLP
.018270	48		pha				pha
.018271	ad c8 03	lda $03c8			lda 	TIM_A 						; restore AXYZ
.018274	ae c9 03	ldx $03c9			ldx 	TIM_X
.018277	ac ca 03	ldy $03ca			ldy 	TIM_Y
.01827a	28		plp				plp 								; and PS Byte.
.01827b	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.01827e					TIM_Start:
.01827e					TIM_ShowRegisters:
.01827e	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.018281	8d c6 03	sta $03c6			sta 	TIM_IRQ+1
.018284	ad ff ff	lda $ffff			lda 	$FFFF
.018287	8d c5 03	sta $03c5			sta 	TIM_IRQ
.01828a	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.01828c					_TIMSR_Text:
.01828c	bf bd 82 01	lda $0182bd,x			lda 	_TIMSR_Label,x
.018290	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018293	e8		inx				inx
.018294	e0 20		cpx #$20			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.018296	d0 f4		bne $01828c			bne 	_TIMSR_Text
.018298	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.01829a					_TIMSR_Skip:
.01829a	e8		inx				inx
.01829b					_TIMSR_LoopSpace:
.01829b	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.01829d	b0 04		bcs $0182a3			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.01829f	8a		txa				txa
.0182a0	4a		lsr a				lsr 	a
.0182a1	b0 05		bcs $0182a8			bcs 	_TIMSR_NoSpace
.0182a3					_TIMSR_Space:
.0182a3	a9 20		lda #$20			lda 	#" "
.0182a5	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182a8					_TIMSR_NoSpace:
.0182a8	bd c3 03	lda $03c3,x			lda 	TIM_PC,x 					; output hex value.
.0182ab	20 dd 82	jsr $0182dd			jsr 	TIM_WriteHex
.0182ae	e8		inx				inx
.0182af	e0 08		cpx #$08			cpx 	#TIM_Z-TIM_PC
.0182b1	f0 e7		beq $01829a			beq 	_TIMSR_Skip
.0182b3	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.0182b5	d0 e4		bne $01829b			bne 	_TimSR_LoopSpace
.0182b7	20 4f 80	jsr $01804f			jsr 	IFT_NewLine 				; new line
.0182ba	4c f1 81	jmp $0181f1			jmp	 	TIM_NewCommand 				; new command.
.0182bd					_TIMSR_Label:
>0182bd	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>0182c5	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>0182d5	52
>0182d6	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.0182dd					_TIMSR_LabelEnd:
.0182dd					TIM_WriteHex:
.0182dd	48		pha				pha 								; save A
.0182de	4a		lsr a				lsr 	a 							; shift MSB->LSB
.0182df	4a		lsr a				lsr 	a
.0182e0	4a		lsr a				lsr 	a
.0182e1	4a		lsr a				lsr 	a
.0182e2	20 e6 82	jsr $0182e6			jsr 	_TIMWH_Nibble 				; print MSB
.0182e5	68		pla				pla 								; restore and print LSB
.0182e6					_TIMWH_Nibble:
.0182e6	48		pha				pha
.0182e7	29 0f		and #$0f			and 	#15 						; mask out
.0182e9	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.0182eb	90 02		bcc $0182ef			bcc 	_TIMWHNoLetter
.0182ed	69 06		adc #$06			adc 	#6
.0182ef					_TIMWHNoLetter:
.0182ef	69 30		adc #$30			adc 	#48
.0182f1	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter 			; print it out.
.0182f4	68		pla				pla
.0182f5	60		rts				rts
.0182f6					TIM_WriteLine:
.0182f6	a9 2e		lda #$2e			lda 	#"." 						; prompt
.0182f8	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182fb	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.0182fd	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018300	a5 13		lda $13				lda 	zTemp2+1 					; write address
.018302	20 dd 82	jsr $0182dd			jsr 	TIM_WriteHex
.018305	a5 12		lda $12				lda 	zTemp2
.018307	20 dd 82	jsr $0182dd			jsr 	TIM_WriteHex
.01830a	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.01830c					_TIMWL_Loop:
.01830c	a9 20		lda #$20			lda 	#" "
.01830e	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018311	b1 12		lda ($12),y			lda 	(zTemp2),y
.018313	20 dd 82	jsr $0182dd			jsr 	TIM_WriteHex
.018316	c8		iny				iny
.018317	c0 10		cpy #$10			cpy 	#16
.018319	d0 f1		bne $01830c			bne 	_TIMWL_Loop
.01831b	4c 4f 80	jmp $01804f			jmp 	IFT_NewLine 				; new line and exit
.01831e					TIM_GetHex:
.01831e	c8		iny				iny
.01831f	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.018321	c9 20		cmp #$20			cmp 	#32
.018323	f0 f9		beq $01831e			beq 	TIM_GetHex
.018325	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.018327	f0 f5		beq $01831e			beq 	TIM_GetHex
.018329	20 52 83	jsr $018352			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.01832c	b0 23		bcs $018351			bcs 	_TIMGH_Exit					; if first bad then exit now.
.01832e	a9 00		lda #$00			lda 	#0 							; zero result
.018330	85 14		sta $14				sta 	zTemp3
.018332	85 15		sta $15				sta 	zTemp3+1
.018334					_TIM_GHLoop:
.018334	20 52 83	jsr $018352			jsr 	TIM_GetHexCharacter 		; get next character
.018337	b0 17		bcs $018350			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.018339	c8		iny				iny 								; skip over it.
.01833a	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.01833c	26 15		rol $15				rol 	zTemp3+1
.01833e	06 14		asl $14				asl 	zTemp3 						; now x 2
.018340	26 15		rol $15				rol 	zTemp3+1
.018342	06 14		asl $14				asl 	zTemp3						; now x 4
.018344	26 15		rol $15				rol 	zTemp3+1
.018346	06 14		asl $14				asl 	zTemp3 						; now x 8
.018348	26 15		rol $15				rol 	zTemp3+1
.01834a	05 14		ora $14				ora 	zTemp3 						; OR result in
.01834c	85 14		sta $14				sta 	zTemp3
.01834e	80 e4		bra $018334			bra 	_TIM_GHLoop 				; loop round again.
.018350					_TIMGH_Okay:
.018350	18		clc				clc
.018351					_TIMGH_Exit:
.018351	60		rts				rts
.018352					TIM_GetHexCharacter:
.018352	b1 10		lda ($10),y			lda 	(zTemp1),y
.018354	38		sec				sec
.018355	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.018357	90 0e		bcc $018367			bcc 	_TIM_GHCFail
.018359	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.01835b	90 0b		bcc $018368			bcc 	_TIM_GHCExit
.01835d	c9 11		cmp #$11			cmp 	#65-48						; < A
.01835f	90 06		bcc $018367			bcc		_TIM_GHCFail
.018361	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.018363	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.018365	90 01		bcc $018368			bcc		_TIM_GHCExit
.018367					_TIM_GHCFail:
.018367	38		sec				sec
.018368					_TIM_GHCExit:
.018368	60		rts				rts
.018369					TIM_BreakVector:
.018369	da		phx				phx									; save X/A on stack
.01836a	48		pha				pha
.01836b	ba		tsx				tsx 								; X points to S
.01836c	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.01836f	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.018371	d0 03		bne $018376			bne 	_TIMBreak					; if set, it's BRK
.018373	68		pla				pla 								; abandon routine.
.018374	fa		plx				plx
.018375	40		rti				rti
.018376					_TIMBreak:
.018376	68		pla				pla 								; save A X Y and maybe Z
.018377	8d c8 03	sta $03c8			sta 	TIM_A
.01837a	fa		plx				plx
.01837b	8e c9 03	stx $03c9			stx 	TIM_X
.01837e	8c ca 03	sty $03ca			sty 	TIM_Y
.018381	68		pla				pla 								; get Status Register
.018382	8d c7 03	sta $03c7			sta 	TIM_SR
.018385	68		pla				pla
.018386	8d c4 03	sta $03c4			sta 	TIM_PC+1 					; save calling address
.018389	68		pla				pla
.01838a	8d c3 03	sta $03c3			sta 	TIM_PC 						; high byte
.01838d	ad c4 03	lda $03c4			lda 	TIM_PC+1 					; dec PC to point right.
.018390	d0 03		bne $018395			bne 	_TIMDecrement 				; brk bumps it.
.018392	ce c3 03	dec $03c3			dec 	TIM_PC
.018395					_TIMDecrement:
.018395	ce c4 03	dec $03c4			dec 	TIM_PC+1
.018398	ba		tsx				tsx 								; and copy SP
.018399	8e cc 03	stx $03cc			stx 	TIM_SP
.01839c	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.01839e	9a		txs				txs
.01839f	4c 7e 82	jmp $01827e			jmp 	TIM_Start 					; and start up TIM monitor.
.0183a2					TIM_UpdateRegisters:
.0183a2	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; PC
.0183a5	b0 28		bcs $0183cf			bcs 	_TIMURFail
.0183a7	a5 14		lda $14				lda 	zTemp3
.0183a9	8d c4 03	sta $03c4			sta 	Tim_PC+1
.0183ac	a5 15		lda $15				lda 	zTemp3+1
.0183ae	8d c3 03	sta $03c3			sta 	Tim_PC
.0183b1	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; ignore IRQ
.0183b4	b0 19		bcs $0183cf			bcs 	_TIMURFail
.0183b6	a2 00		ldx #$00			ldx 	#0
.0183b8					_TIM_URLoop:
.0183b8	e0 04		cpx #$04			cpx 	#Tim_Z-Tim_SR
.0183ba	d0 01		bne $0183bd			bne 	_TIM_1
.0183bc	e8		inx				inx
.0183bd					_TIM_1:
.0183bd	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; registers
.0183c0	b0 0d		bcs $0183cf			bcs 	_TIMURFail
.0183c2	a5 14		lda $14				lda 	zTemp3
.0183c4	9d c7 03	sta $03c7,x			sta 	Tim_SR,x
.0183c7	e8		inx				inx
.0183c8	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.0183ca	d0 ec		bne $0183b8			bne 	_TIM_URLoop
.0183cc	4c f1 81	jmp $0181f1			jmp 	TIM_NewCommand
.0183cf					_TIMURFail:
.0183cf	4c ea 81	jmp $0181ea			jmp 	TIM_Error
.0183d2					TIM_LoadMemory:
.0183d2	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; target address => zTemp2
.0183d5	a5 14		lda $14				lda 	zTemp3
.0183d7	85 12		sta $12				sta 	zTemp2
.0183d9	a5 15		lda $15				lda 	zTemp3+1
.0183db	85 13		sta $13				sta 	zTemp2+1
.0183dd					_TIM_LMLoop:
.0183dd	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; next byte ?
.0183e0	b0 0e		bcs $0183f0			bcs 	_TIMLMDone 					; no more
.0183e2	a2 00		ldx #$00			ldx 	#0							; write out.
.0183e4	a5 14		lda $14				lda 	zTemp3
.0183e6	81 12		sta ($12,x)			sta 	(zTemp2,x)
.0183e8	e6 12		inc $12				inc 	zTemp2 						; bump address
.0183ea	d0 f1		bne $0183dd			bne 	_TIM_LMLoop
.0183ec	e6 13		inc $13				inc 	zTemp2+1
.0183ee	80 ed		bra $0183dd			bra 	_TIM_LMLoop
.0183f0					_TIMLMDone:
.0183f0	4c f1 81	jmp $0181f1			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/skip.asm

.0183f3					StructureSearchSingle:
.0183f3	a2 00		ldx #$00			ldx 	#0
.0183f5					StructureSearchDouble:
.0183f5	85 10		sta $10				sta 	zTemp1 						; save the target on zTemp1,zTemp1+1
.0183f7	86 11		stx $11				stx 	zTemp1+1
.0183f9	a9 00		lda #$00			lda 	#0 							; set the structure depth to zero (zTemp2)
.0183fb	85 12		sta $12				sta 	zTemp2
.0183fd	80 18		bra $018417			bra 	_SSWLoop 					; jump in, start scanning from here.
.0183ff					_SSWNextLine:
.0183ff	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018401	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.018403	18		clc				clc
.018404	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018406	85 16		sta $16				sta 	zCodePtr
.018408	90 02		bcc $01840c			bcc 	_SNLNoCarry
.01840a	e6 17		inc $17				inc 	zCodePtr+1
.01840c					_SNLNoCarry:
.01840c	a0 00		ldy #$00			ldy 	#0
.01840e	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018410	c9 00		cmp #$00			cmp 	#0					 		; if zero, fail.
.018412	f0 54		beq $018468			beq 	_SSWFail
.018414	c8		iny				iny
.018415	c8		iny				iny
.018416					_SSWNextSimple:
.018416	c8		iny				iny
.018417					_SSWLoop:
.018417	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018419	c9 00		cmp #$00			cmp 	#0 							; end of line ?
.01841b	f0 e2		beq $0183ff			beq 	_SSWNextLine 				; if so, then next line
.01841d	10 f7		bpl $018416			bpl 	_SSWNextSimple 				; needs to be a token, just skip char/number.
.01841f	a6 12		ldx $12				ldx 	zTemp2 						; check structure count
.018421	d0 08		bne $01842b			bne 	_SSWCheckUpDown 			; if it's non zero, then a match doesn't work.
.018423	c5 10		cmp $10				cmp 	zTemp1 						; found the right keyword, either choice.
.018425	f0 2d		beq $018454			beq 	_SSWFound 					; so exit.
.018427	c5 11		cmp $11				cmp 	zTemp1+1
.018429	f0 29		beq $018454			beq 	_SSWFound
.01842b					_SSWCheckUpDown:
.01842b	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus 			; if < keyword +
.01842d	90 10		bcc $01843f			bcc 	_SSWNext
.01842f	c9 93		cmp #$93			cmp 	#firstKeywordMinus 			; if < keyword - then as keyword +
.018431	90 08		bcc $01843b			bcc 	_SSWPlus
.018433	c9 98		cmp #$98			cmp 	#firstUnaryFunction			; if < first unary down as keyword -
.018435	b0 08		bcs $01843f			bcs 	_SSWNext
.018437	c6 12		dec $12				dec 	zTemp2 						; reduce structure count.
.018439	c6 12		dec $12				dec 	zTemp2
.01843b					_SSWPlus:
.01843b	e6 12		inc $12				inc 	zTemp2
.01843d	30 16		bmi $018455			bmi 	_SSWUnder					; error if driven -ve
.01843f					_SSWNext:
.01843f	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018441	c8		iny				iny 								; skip
.018442	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018444	90 0c		bcc $018452			bcc 	_SEDone 					; so just skip over it.
.018446	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018448	90 07		bcc $018451			bcc 	_SEDouble
.01844a	98		tya				tya 								; this is Y + 1
.01844b	18		clc				clc
.01844c	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.01844e	a8		tay				tay 								; back in Y.
.01844f	88		dey				dey 								; fix up, one for the +1, one for the iny
.018450	88		dey				dey
.018451					_SEDouble:
.018451	c8		iny				iny
.018452					_SEDone:
.018452	80 c3		bra $018417			bra 	_SSWLoop
.018454					_SSWFound:
.018454	60		rts				rts
.018455					_SSWUnder:
.018455	20 79 85	jsr $018579			jsr ERR_Handler
>018458	53 74 72 75 63 74 75 72			.text "Structure order",0
>018460	65 20 6f 72 64 65 72 00
.018468					_SSWFail:
.018468	20 79 85	jsr $018579			jsr ERR_Handler
>01846b	43 61 6e 27 74 20 66 69			.text "Can't find structure",0
>018473	6e 64 20 73 74 72 75 63 74 75 72 65 00
.018480					SkipEndOfCommand:
.018480	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018482	c9 00		cmp #$00			cmp 	#0 							; if zero, end of line, so exit
.018484	f0 19		beq $01849f			beq 	_SOCExit
.018486	c9 c0		cmp #$c0			cmp 	#token_Colon 				; if colon, end of command
.018488	f0 15		beq $01849f			beq 	_SOCExit
.01848a	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.01848c	c8		iny				iny 								; skip
.01848d	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.01848f	90 0c		bcc $01849d			bcc 	_SEDone 					; so just skip over it.
.018491	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018493	90 07		bcc $01849c			bcc 	_SEDouble
.018495	98		tya				tya 								; this is Y + 1
.018496	18		clc				clc
.018497	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018499	a8		tay				tay 								; back in Y.
.01849a	88		dey				dey 								; fix up, one for the +1, one for the iny
.01849b	88		dey				dey
.01849c					_SEDouble:
.01849c	c8		iny				iny
.01849d					_SEDone:
.01849d	80 e1		bra $018480			bra 	SkipEndOfCommand
.01849f					_SOCExit:
.01849f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stack.asm

.0184a0					StackReset:
.0184a0	48		pha				pha
.0184a1	5a		phy				phy
.0184a2	a9 00		lda #$00			lda 	#(BasicStack & $FF) 		; reset pointer
.0184a4	85 26		sta $26				sta 	zBasicSP
.0184a6	a9 04		lda #$04			lda 	#(BasicStack >> 8)
.0184a8	85 27		sta $27				sta 	zBasicSP+1
.0184aa	a0 00		ldy #$00			ldy 	#0 							; reset stack top to $00 which cannot
.0184ac	98		tya				tya 								; be a legal token.
.0184ad	91 26		sta ($26),y			sta 	(zBasicSP),y
.0184af	7a		ply				ply
.0184b0	68		pla				pla
.0184b1	60		rts				rts
.0184b2					StackPushFrame:
.0184b2	48		pha				pha
.0184b3	5a		phy				phy
.0184b4	1a		inc a				inc 	a 							; one extra byte in frame, for the marker.
.0184b5	48		pha				pha 								; save it.
.0184b6	29 0f		and #$0f			and 	#$0F 						; lower 4 bits
.0184b8	18		clc				clc 								; add to Basic Stack
.0184b9	65 26		adc $26				adc 	zBasicSP
.0184bb	85 26		sta $26				sta 	zBasicSP
.0184bd	90 02		bcc $0184c1			bcc 	_SPFNoBump
.0184bf	e6 27		inc $27				inc 	zBasicSP+1
.0184c1					_SPFNoBump:
.0184c1	a0 00		ldy #$00			ldy 	#0
.0184c3	68		pla				pla
.0184c4	91 26		sta ($26),y			sta 	(zBasicSP),y
.0184c6	7a		ply				ply
.0184c7	68		pla				pla
.0184c8	60		rts				rts
.0184c9					StackPopFrame:
.0184c9	48		pha				pha
.0184ca	5a		phy				phy
.0184cb	a0 00		ldy #$00			ldy 	#0 							; compare with top of stack using EOR
.0184cd	51 26		eor ($26),y			eor 	(zBasicSP),y
.0184cf	29 f0		and #$f0			and 	#$F0 						; top 4 bits zero, match
.0184d1	d0 12		bne $0184e5			bne 	SPFError 					; mixed structures
.0184d3	b1 26		lda ($26),y			lda 	(zBasicSP),y 				; get size from byte
.0184d5	29 0f		and #$0f			and 	#$0F
.0184d7	49 ff		eor #$ff			eor 	#$FF						; 2's complement
.0184d9	38		sec				sec
.0184da	65 26		adc $26				adc 	zBasicSP
.0184dc	85 26		sta $26				sta 	zBasicSP
.0184de	b0 02		bcs $0184e2			bcs 	_SPFNoBump
.0184e0	c6 27		dec $27				dec 	zBasicSP+1
.0184e2					_SPFNoBump:
.0184e2	7a		ply				ply
.0184e3	68		pla				pla
.0184e4	60		rts				rts
.0184e5					SPFError:
.0184e5	20 79 85	jsr $018579			jsr ERR_Handler
>0184e8	4d 69 78 65 64 20 53 74			.text "Mixed Structures",0
>0184f0	72 75 63 74 75 72 65 73 00
.0184f9					StackSavePosition:
.0184f9	98		tya				tya
.0184fa	5a		phy				phy
.0184fb	a0 05		ldy #$05			ldy 	#5
.0184fd	91 26		sta ($26),y			sta 	(zBasicSP),y
.0184ff	a0 01		ldy #$01			ldy 	#1
.018501	a5 16		lda $16				lda 	zCodePtr+0 					; 4 bytes, could reduce this for 65816/6502
.018503	91 26		sta ($26),y			sta 	(zBasicSP),y
.018505	c8		iny				iny
.018506	a5 17		lda $17				lda 	zCodePtr+1
.018508	91 26		sta ($26),y			sta 	(zBasicSP),y
.01850a	c8		iny				iny
.01850b	a5 18		lda $18				lda 	zCodePtr+2
.01850d	91 26		sta ($26),y			sta 	(zBasicSP),y
.01850f	c8		iny				iny
.018510	a5 19		lda $19				lda 	zCodePtr+3
.018512	91 26		sta ($26),y			sta 	(zBasicSP),y
.018514	7a		ply				ply
.018515	60		rts				rts
.018516					StackRestorePosition:
.018516	5a		phy				phy
.018517	a0 01		ldy #$01			ldy 	#1 							; copy 4 bytes that are the pointer
.018519	b1 26		lda ($26),y			lda 	(zBasicSP),y
.01851b	85 16		sta $16				sta 	zCodePtr+0
.01851d	c8		iny				iny
.01851e	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018520	85 17		sta $17				sta 	zCodePtr+1
.018522	c8		iny				iny
.018523	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018525	85 18		sta $18				sta 	zCodePtr+2
.018527	c8		iny				iny
.018528	b1 26		lda ($26),y			lda 	(zBasicSP),y
.01852a	85 19		sta $19				sta 	zCodePtr+3
.01852c	c8		iny				iny
.01852d	b1 26		lda ($26),y			lda 	(zBasicSP),y 				; offset
.01852f	7a		ply				ply 								; restore Y
.018530	a8		tay				tay
.018531	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/vectors.asm

.018532					VIOCharPrint:
.018532	4c 35 80	jmp $018035			jmp 	IFT_PrintCharacter
.018535					VIOCharGet:
.018535	20 d9 81	jsr $0181d9			jsr 	IF_GetKey
.018538	c9 00		cmp #$00			cmp 	#0
.01853a	f0 02		beq $01853e			beq 	_VCG0
.01853c	38		sec				sec
.01853d	60		rts				rts
.01853e	18		clc		_VCG0:	clc
.01853f	60		rts				rts
.018540					VIOCheckBreak:
.018540	4c d4 81	jmp $0181d4			jmp 	IF_CheckBreak
.018543					VIOCharGetPosition:
.018543	ad 00 05	lda $0500			lda 	IFT_XCursor
.018546	60		rts				rts
.018547					VIOReadLine:
.018547	4c ed 80	jmp $0180ed			jmp 	IFT_ReadLine

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/errors.asm

.01854a					SyntaxError:
.01854a	20 79 85	jsr $018579			jsr 	ERR_Handler
>01854d	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>018555	72 72 6f 72 00
.01855a					TypeError:
.01855a	20 79 85	jsr $018579			jsr 	ERR_Handler
>01855d	57 72 6f 6e 67 20 74 79				.text 	"Wrong type",0
>018565	70 65 00
.018568					BadParamError:
.018568	20 79 85	jsr $018579			jsr 	ERR_Handler
>01856b	42 61 64 20 50 61 72 61				.text 	"Bad Parameter",0
>018573	6d 65 74 65 72 00
.018579					ERR_Handler:
.018579	a0 00		ldy #$00			ldy 	#0
.01857b	c8		iny				iny
.01857c	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01857e	85 80		sta $80				sta 	XS_Mantissa
.018580	c8		iny				iny
.018581	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018583	85 81		sta $81				sta 	XS_Mantissa+1
.018585	fa		plx				plx 								; address in XY
.018586	7a		ply				ply
.018587	e8		inx				inx 								; bump, because of RTS/JSR address -1
.018588	d0 01		bne $01858b			bne 	_EHNoSkip
.01858a	c8		iny				iny
.01858b					_EHNoSkip:
.01858b	20 aa 85	jsr $0185aa			jsr 	PrintROMMessage 			; print message from ROM.
.01858e	a5 80		lda $80				lda 	XS_Mantissa					; line number = 0
.018590	05 81		ora $81				ora 	XS_Mantissa+1
.018592	f0 0c		beq $0185a0			beq 	_EHNoLine
.018594	a2 a5		ldx #$a5			ldx 	#_EHAt & $FF 				; print " at "
.018596	a0 85		ldy #$85			ldy 	#(_EHAt >> 8) & $FF
.018598	20 aa 85	jsr $0185aa			jsr 	PrintROMMessage
.01859b	a2 00		ldx #$00			ldx 	#0 							; Print line number
.01859d	20 bf 85	jsr $0185bf			jsr 	Print16BitInteger
.0185a0					_EHNoLine:
.0185a0	80 fe		bra $0185a0			bra 	_EHNoLine
.0185a2	4c 32 88	jmp $018832			jmp 	WarmStart 					; normally warm start.
>0185a5	20 61 74 20 00			_EHAt:	.text 	" at ",0
.0185aa					PrintROMMessage:
.0185aa	86 1a		stx $1a				stx 	zLTemp1 					; save addres
.0185ac	84 1b		sty $1b				sty 	zLTemp1+1
.0185ae	4b		phk				phk 								; get current code page
.0185af	68		pla				pla
.0185b0	85 1c		sta $1c				sta 	ZLTemp1+2 					; put into the 3rd byte so we can use
.0185b2	a0 00		ldy #$00			ldy 	#0
.0185b4					_PRMLoop:
.0185b4	b7 1a		lda [$1a],y			lda 	[zLTemp1],y 				; 65816
.0185b6	f0 06		beq $0185be			beq		_PRMExit 					; character $00 => exit
.0185b8	c8		iny				iny  								; bump Y and print it.
.0185b9	20 32 85	jsr $018532			jsr 	VIOCharPrint
.0185bc	80 f6		bra $0185b4			bra 	_PRMLoop
.0185be					_PRMExit:
.0185be	60		rts				rts
.0185bf					Print16BitInteger:
.0185bf	a9 00		lda #$00			lda 	#0 							; make 32 bit
.0185c1	85 82		sta $82				sta 	XS_Mantissa+2
.0185c3	85 83		sta $83				sta 	XS_Mantissa+3
.0185c5					Print32BitInteger:
.0185c5	a9 00		lda #$00			lda 	#0
.0185c7	8d 14 03	sta $0314			sta 	NumBufX 					; reset the conversion pointer
.0185ca	aa		tax				tax 								; convert bottom level.
.0185cb	20 bd 9e	jsr $019ebd			jsr 	INTToString 				; make string from integer in Num_Buffer
.0185ce	a2 00		ldx #$00			ldx 	#0 							; print buffer contents
.0185d0	bd 15 03	lda $0315,x	_P1Loop:lda 	Num_Buffer,x
.0185d3	f0 06		beq $0185db			beq 	_P1Exit
.0185d5	20 32 85	jsr $018532			jsr 	VIOCharPrint
.0185d8	e8		inx				inx
.0185d9	80 f5		bra $0185d0			bra 	_P1Loop
.0185db	8a		txa		_P1Exit:txa 								; return chars printed.
.0185dc	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm


;******  Processing file: modules/basic/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b6					lastUnaryFunction = $b6
.0185dd					VectorTable:
>0185dd	03 93					.word BinaryOp_And         & $FFFF ; $80 and
>0185df	1f 93					.word BinaryOp_Or          & $FFFF ; $81 or
>0185e1	3b 93					.word BinaryOp_Xor         & $FFFF ; $82 xor
>0185e3	3b 93					.word BinaryOp_Eor         & $FFFF ; $83 eor
>0185e5	72 93					.word Binary_Equal         & $FFFF ; $84 =
>0185e7	7b 93					.word Binary_NotEqual      & $FFFF ; $85 <>
>0185e9	84 93					.word Binary_Less          & $FFFF ; $86 <
>0185eb	8d 93					.word Binary_LessEqual     & $FFFF ; $87 <=
>0185ed	9f 93					.word Binary_Greater       & $FFFF ; $88 >
>0185ef	96 93					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>0185f1	37 94					.word BinaryOp_Add         & $FFFF ; $8a +
>0185f3	53 94					.word BinaryOp_Subtract    & $FFFF ; $8b -
>0185f5	64 94					.word BinaryOp_Multiply    & $FFFF ; $8c *
>0185f7	75 94					.word BinaryOp_Divide      & $FFFF ; $8d /
>0185f9	9b 86					.word NotImplemented       & $FFFF ; $8e ^
>0185fb	91 8c					.word Command_IF           & $FFFF ; $8f if
>0185fd	ff 90					.word Command_WHILE        & $FFFF ; $90 while
>0185ff	27 91					.word Command_REPEAT       & $FFFF ; $91 repeat
>018601	94 89					.word Command_FOR          & $FFFF ; $92 for
>018603	9b 86					.word NotImplemented       & $FFFF ; $93 then
>018605	ee 8c					.word Command_ENDIF        & $FFFF ; $94 endif
>018607	1c 91					.word Command_WEND         & $FFFF ; $95 wend
>018609	30 91					.word Command_UNTIL        & $FFFF ; $96 until
>01860b	11 8a					.word Command_NEXT         & $FFFF ; $97 next
>01860d	9b 86					.word NotImplemented       & $FFFF ; $98 not
>01860f	9b 86					.word NotImplemented       & $FFFF ; $99 fn(
>018611	7a 95					.word Unary_Abs            & $FFFF ; $9a abs(
>018613	c8 96					.word Unary_Asc            & $FFFF ; $9b asc(
>018615	e9 a5					.word Unary_Int            & $FFFF ; $9c int(
>018617	94 95					.word Unary_Peek           & $FFFF ; $9d peek(
>018619	6a a5					.word Unary_Rnd            & $FFFF ; $9e rnd(
>01861b	07 96					.word Unary_Usr            & $FFFF ; $9f usr(
>01861d	07 97					.word Unary_Left           & $FFFF ; $a0 left$(
>01861f	1c 97					.word Unary_Right          & $FFFF ; $a1 right$(
>018621	ee 96					.word Unary_Mid            & $FFFF ; $a2 mid$(
>018623	67 98					.word Unary_Spc            & $FFFF ; $a3 spc(
>018625	96 96					.word Unary_Str            & $FFFF ; $a4 str$(
>018627	28 96					.word Unary_Val            & $FFFF ; $a5 val(
>018629	df 96					.word Unary_Len            & $FFFF ; $a6 len(
>01862b	94 97					.word Unary_Hex            & $FFFF ; $a7 hex$(
>01862d	9b 86					.word NotImplemented       & $FFFF ; $a8 sin(
>01862f	9b 86					.word NotImplemented       & $FFFF ; $a9 cos(
>018631	9b 86					.word NotImplemented       & $FFFF ; $aa tan(
>018633	9b 86					.word NotImplemented       & $FFFF ; $ab atn(
>018635	9b 86					.word NotImplemented       & $FFFF ; $ac exp(
>018637	9b 86					.word NotImplemented       & $FFFF ; $ad log(
>018639	9b 86					.word NotImplemented       & $FFFF ; $ae sqr(
>01863b	ea 97					.word Unary_Dec            & $FFFF ; $af dec(
>01863d	98 95					.word Unary_Deek           & $FFFF ; $b0 deek(
>01863f	9c 95					.word Unary_Leek           & $FFFF ; $b1 leek(
>018641	d4 95					.word Unary_Mod            & $FFFF ; $b2 mod(
>018643	34 95					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>018645	49 98					.word Unary_Chr            & $FFFF ; $b4 chr$(
>018647	c8 95					.word Unary_Pos            & $FFFF ; $b5 pos(
>018649	8a 98					.word Unary_Tab            & $FFFF ; $b6 tab(
>01864b	9b 86					.word NotImplemented       & $FFFF ; $b7 $
>01864d	9b 86					.word NotImplemented       & $FFFF ; $b8 $(
>01864f	9b 86					.word NotImplemented       & $FFFF ; $b9 #
>018651	9b 86					.word NotImplemented       & $FFFF ; $ba #(
>018653	9b 86					.word NotImplemented       & $FFFF ; $bb %
>018655	9b 86					.word NotImplemented       & $FFFF ; $bc %(
>018657	9b 86					.word NotImplemented       & $FFFF ; $bd (
>018659	9b 86					.word NotImplemented       & $FFFF ; $be )
>01865b	9b 86					.word NotImplemented       & $FFFF ; $bf ,
>01865d	93 89					.word Command_COLON        & $FFFF ; $c0 :
>01865f	9b 86					.word NotImplemented       & $FFFF ; $c1 ;
>018661	9b 86					.word NotImplemented       & $FFFF ; $c2 def
>018663	e0 90					.word Command_CLR          & $FFFF ; $c3 clr
>018665	f7 90					.word Command_STOP         & $FFFF ; $c4 stop
>018667	ea 8a					.word Command_DATA         & $FFFF ; $c5 data
>018669	c4 8a					.word Command_READ         & $FFFF ; $c6 read
>01866b	3f 88					.word Command_DIM          & $FFFF ; $c7 dim
>01866d	9b 86					.word NotImplemented       & $FFFF ; $c8 to
>01866f	9b 86					.word NotImplemented       & $FFFF ; $c9 step
>018671	26 90					.word Command_GOSUB        & $FFFF ; $ca gosub
>018673	36 90					.word Command_RETURN       & $FFFF ; $cb return
>018675	1e 90					.word Command_GOTO         & $FFFF ; $cc goto
>018677	8d 8c					.word Command_END          & $FFFF ; $cd end
>018679	0d 8c					.word Command_INPUT        & $FFFF ; $ce input
>01867b	88 8b					.word Command_LET          & $FFFF ; $cf let
>01867d	f4 8c					.word Command_LIST         & $FFFF ; $d0 list
>01867f	c7 8f					.word Command_NEW          & $FFFF ; $d1 new
>018681	e3 8f					.word Command_OLD          & $FFFF ; $d2 old
>018683	3f 90					.word Command_ON           & $FFFF ; $d3 on
>018685	ed 8a					.word Command_RESTORE      & $FFFF ; $d4 restore
>018687	96 8f					.word Command_POKE         & $FFFF ; $d5 poke
>018689	e8 8e					.word Command_PRINT        & $FFFF ; $d6 print
>01868b	05 89					.word Command_RUN          & $FFFF ; $d7 run
>01868d	c7 88					.word Command_WAIT         & $FFFF ; $d8 wait
>01868f	f3 8b					.word Command_SYS          & $FFFF ; $d9 sys
>018691	9a 8f					.word Command_DOKE         & $FFFF ; $da doke
>018693	9e 8f					.word Command_LOKE         & $FFFF ; $db loke
>018695	7e 8f					.word Command_ASSERT       & $FFFF ; $dc assert
>018697	a9 8b					.word Command_GET          & $FFFF ; $dd get
>018699	e8 8c					.word Command_ELSE         & $FFFF ; $de else
.01869b					NotImplemented:
.01869b	20 79 85	jsr $018579			jsr ERR_Handler
>01869e	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>0186a6	65 6d 65 6e 74 65 64 00
.0186ae					BinaryPrecedence:
>0186ae	01					.byte 1    ; $80 and
>0186af	01					.byte 1    ; $81 or
>0186b0	01					.byte 1    ; $82 xor
>0186b1	01					.byte 1    ; $83 eor
>0186b2	02					.byte 2    ; $84 =
>0186b3	02					.byte 2    ; $85 <>
>0186b4	02					.byte 2    ; $86 <
>0186b5	02					.byte 2    ; $87 <=
>0186b6	02					.byte 2    ; $88 >
>0186b7	02					.byte 2    ; $89 >=
>0186b8	03					.byte 3    ; $8a +
>0186b9	03					.byte 3    ; $8b -
>0186ba	04					.byte 4    ; $8c *
>0186bb	04					.byte 4    ; $8d /
>0186bc	05					.byte 5    ; $8e ^
.0186bd					KeywordText:
>0186bd	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>0186c0	4f d2					.byte $4f,$d2                          ; $81 or
>0186c2	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>0186c5	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>0186c8	bd					.byte $bd                              ; $84 =
>0186c9	3c be					.byte $3c,$be                          ; $85 <>
>0186cb	bc					.byte $bc                              ; $86 <
>0186cc	3c bd					.byte $3c,$bd                          ; $87 <=
>0186ce	be					.byte $be                              ; $88 >
>0186cf	3e bd					.byte $3e,$bd                          ; $89 >=
>0186d1	ab					.byte $ab                              ; $8a +
>0186d2	ad					.byte $ad                              ; $8b -
>0186d3	aa					.byte $aa                              ; $8c *
>0186d4	af					.byte $af                              ; $8d /
>0186d5	de					.byte $de                              ; $8e ^
>0186d6	49 c6					.byte $49,$c6                          ; $8f if
>0186d8	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>0186dd	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>0186e3	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>0186e6	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>0186ea	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>0186ef	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>0186f3	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>0186f8	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>0186fc	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>0186ff	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>018702	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>018706	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>01870a	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>01870e	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>018713	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>018717	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>01871b	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>018721	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>018728	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>01872d	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>018731	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>018736	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>01873a	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>01873e	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>018743	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>018747	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>01874b	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>01874f	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>018753	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>018757	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>01875b	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>01875f	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>018763	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>018768	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>01876d	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>018771	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>018775	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>01877a	50 4f 53 a8				.byte $50,$4f,$53,$a8                  ; $b5 pos(
>01877e	54 41 42 a8				.byte $54,$41,$42,$a8                  ; $b6 tab(
>018782	a4					.byte $a4                              ; $b7 $
>018783	24 a8					.byte $24,$a8                          ; $b8 $(
>018785	a3					.byte $a3                              ; $b9 #
>018786	23 a8					.byte $23,$a8                          ; $ba #(
>018788	a5					.byte $a5                              ; $bb %
>018789	25 a8					.byte $25,$a8                          ; $bc %(
>01878b	a8					.byte $a8                              ; $bd (
>01878c	a9					.byte $a9                              ; $be )
>01878d	ac					.byte $ac                              ; $bf ,
>01878e	ba					.byte $ba                              ; $c0 :
>01878f	bb					.byte $bb                              ; $c1 ;
>018790	44 45 c6				.byte $44,$45,$c6                      ; $c2 def
>018793	43 4c d2				.byte $43,$4c,$d2                      ; $c3 clr
>018796	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $c4 stop
>01879a	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c5 data
>01879e	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c6 read
>0187a2	44 49 cd				.byte $44,$49,$cd                      ; $c7 dim
>0187a5	54 cf					.byte $54,$cf                          ; $c8 to
>0187a7	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c9 step
>0187ab	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $ca gosub
>0187b0	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $cb return
>0187b6	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $cc goto
>0187ba	45 4e c4				.byte $45,$4e,$c4                      ; $cd end
>0187bd	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $ce input
>0187c2	4c 45 d4				.byte $4c,$45,$d4                      ; $cf let
>0187c5	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $d0 list
>0187c9	4e 45 d7				.byte $4e,$45,$d7                      ; $d1 new
>0187cc	4f 4c c4				.byte $4f,$4c,$c4                      ; $d2 old
>0187cf	4f ce					.byte $4f,$ce                          ; $d3 on
>0187d1	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d4 restore
>0187d8	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d5 poke
>0187dc	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d6 print
>0187e1	52 55 ce				.byte $52,$55,$ce                      ; $d7 run
>0187e4	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d8 wait
>0187e8	53 59 d3				.byte $53,$59,$d3                      ; $d9 sys
>0187eb	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $da doke
>0187ef	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $db loke
>0187f3	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $dc assert
>0187f9	47 45 d4				.byte $47,$45,$d4                      ; $dd get
>0187fc	45 4c 53 c5				.byte $45,$4c,$53,$c5                  ; $de else
>018800	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_pos = $b5
=$b6					token_tab = $b6
=$b7					token_dollar = $b7
=$b8					token_dollarlparen = $b8
=$b9					token_hash = $b9
=$ba					token_hashlparen = $ba
=$bb					token_percent = $bb
=$bc					token_percentlparen = $bc
=$bd					token_lparen = $bd
=$be					token_rparen = $be
=$bf					token_comma = $bf
=$c0					token_colon = $c0
=$c1					token_semicolon = $c1
=$c2					token_def = $c2
=$c3					token_clr = $c3
=$c4					token_stop = $c4
=$c5					token_data = $c5
=$c6					token_read = $c6
=$c7					token_dim = $c7
=$c8					token_to = $c8
=$c9					token_step = $c9
=$ca					token_gosub = $ca
=$cb					token_return = $cb
=$cc					token_goto = $cc
=$cd					token_end = $cd
=$ce					token_input = $ce
=$cf					token_let = $cf
=$d0					token_list = $d0
=$d1					token_new = $d1
=$d2					token_old = $d2
=$d3					token_on = $d3
=$d4					token_restore = $d4
=$d5					token_poke = $d5
=$d6					token_print = $d6
=$d7					token_run = $d7
=$d8					token_wait = $d8
=$d9					token_sys = $d9
=$da					token_doke = $da
=$db					token_loke = $db
=$dc					token_assert = $dc
=$dd					token_get = $dd
=$de					token_else = $de

;******  Return to file: modules/basic/core.asm

.018801					BASIC_Start:
.018801	20 9b 81	jsr $01819b			jsr 	IF_Reset 					; set up and clear screen.
.018804	20 00 80	jsr $018000			jsr 	IFT_ClearScreen
.018807	a9 5c		lda #$5c			lda 	#$5C 						; JMP Long opcode
.018809	8d 10 03	sta $0310			sta 	LocalVector
.01880c	8d 0c 03	sta $030c			sta 	UserVector
.01880f	a9 16		lda #$16			lda 	#USRDefault & $FF 			; reset USR vector
.018811	8d 0d 03	sta $030d			sta 	UserVector+1
.018814	a9 96		lda #$96			lda 	#(USRDefault >> 8) & $FF
.018816	8d 0e 03	sta $030e			sta 	UserVector+2
.018819	a9 01		lda #$01			lda 	#(USRDefault >> 16) & $FF
.01881b	8d 0f 03	sta $030f			sta 	UserVector+3
.01881e	20 d1 98	jsr $0198d1			jsr 	UpdateProgramEnd 			; update the program end.
.018821	20 e0 90	jsr $0190e0			jsr 	ResetRunStatus 				; clear everything (CLR command)
.018824	c2 30		rep #$30			rep 	#$30
.018826	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.018829	1b		tcs				tcs
.01882a	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.01882d	e2 30		sep #$30			sep 	#$30
.01882f	4c 05 89	jmp $018905			jmp 	COMMAND_Run
.018832					WarmStart:
.018832	c2 30		rep #$30			rep 	#$30
.018834	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.018837	1b		tcs				tcs
.018838	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.01883b	e2 30		sep #$30			sep 	#$30
.01883d	80 f3		bra $018832			bra 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/dim.asm

.01883f					Command_DIM:
.01883f	98		tya				tya
.018840	48		pha				pha 								; push on stack.
.018841	20 46 9a	jsr $019a46			jsr 	VariableExtract 			; get the identifier
.018844	ad 95 03	lda $0395			lda 	Var_Type 					; check it is an array
.018847	29 01		and #$01			and 	#1
.018849	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.01884b	d0 6c		bne $0188b9			bne 	_CDIError
.01884d	a9 00		lda #$00			lda 	#0 							; reset the DIM index. The dimensions are
.01884f	8d b9 03	sta $03b9			sta 	UsrArrayIdx 				; built up here and copied in case we autodim
.018852					_CDIGetDimension:
.018852	ad b9 03	lda $03b9			lda 	UsrArrayIdx 				; done too many ?
.018855	c9 06		cmp #$06			cmp 	#ArrayMaxDim*2
.018857	f0 60		beq $0188b9			beq 	_CDIError
.018859	20 e4 92	jsr $0192e4			jsr 	EvaluateInteger 			; evaluate an index size
.01885c	a5 81		lda $81				lda 	XS_Mantissa+1 				; check in range 0-7FFF
.01885e	29 80		and #$80			and 	#$80
.018860	05 82		ora $82				ora 	XS_Mantissa+2
.018862	05 83		ora $83				ora 	XS_Mantissa+3
.018864	d0 53		bne $0188b9			bne 	_CDIError
.018866	ae b9 03	ldx $03b9			ldx 	UsrArrayIdx 				; copy into the array table.
.018869	18		clc				clc 								; add 1 - max index => size.
.01886a	a5 80		lda $80				lda 	XS_Mantissa+0
.01886c	69 01		adc #$01			adc 	#1
.01886e	9d b1 03	sta $03b1,x			sta 	UsrArrayDef+0,x
.018871	a5 81		lda $81				lda 	XS_Mantissa+1
.018873	69 00		adc #$00			adc 	#0
.018875	9d b2 03	sta $03b2,x			sta 	UsrArrayDef+1,x
.018878	30 3f		bmi $0188b9			bmi 	_CDIError 					; could be dim a(32767)
.01887a	e8		inx				inx 								; bump index.
.01887b	e8		inx				inx
.01887c	8e b9 03	stx $03b9			stx 	UsrArrayIdx
.01887f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018881	c8		iny				iny
.018882	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another dimension
.018884	f0 cc		beq $018852			beq 	_CDIGetDimension
.018886	88		dey				dey
.018887	20 2d 99	jsr $01992d			jsr 	CheckNextRParen 			; closing ) present ?
.01888a	ae b9 03	ldx $03b9			ldx 	UsrArrayIdx 				; copy USR array to default
.01888d	a9 ff		lda #$ff			lda 	#$FF 						; put end marker in ArrayDef
.01888f	9d aa 03	sta $03aa,x			sta 	ArrayDef+1,x
.018892					_CDICopy:
.018892	bd b1 03	lda $03b1,x			lda 	UsrArrayDef,x
.018895	9d a9 03	sta $03a9,x			sta 	ArrayDef,x
.018898	ca		dex				dex
.018899	10 f7		bpl $018892			bpl 	_CDICopy
.01889b	68		pla				pla									; position of array identifier
.01889c	85 10		sta $10				sta 	zTemp1
.01889e	98		tya				tya
.01889f	48		pha				pha
.0188a0	a5 10		lda $10				lda 	zTemp1 						; point to identifier
.0188a2	a8		tay				tay
.0188a3	20 46 9a	jsr $019a46			jsr 	VariableExtract 			; get the identifier
.0188a6	20 df 9c	jsr $019cdf			jsr 	VariableLocate 				; check if it exists already.
.0188a9	b0 0e		bcs $0188b9			bcs 	_CDIError
.0188ab	20 d2 9a	jsr $019ad2			jsr 	VariableCreate 				; create it using the current ArrayDef
.0188ae	68		pla				pla 								; restore code position
.0188af	a8		tay				tay
.0188b0	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0188b2	c8		iny				iny
.0188b3	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another DIM
.0188b5	f0 88		beq $01883f			beq 	Command_DIM
.0188b7	88		dey				dey
.0188b8	60		rts				rts
.0188b9					_CDIError:
.0188b9	20 79 85	jsr $018579			jsr ERR_Handler
>0188bc	42 61 64 20 44 49 4d 00			.text "Bad DIM",0
.0188c4					_CDISyntax:
.0188c4	4c 4a 85	jmp $01854a			jmp 	SyntaxError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/wait.asm

.0188c7					Command_WAIT:
.0188c7	20 e4 92	jsr $0192e4			jsr		EvaluateInteger 			; address
.0188ca	a2 06		ldx #$06			ldx 	#XS_Size 					; and mask.
.0188cc	20 35 99	jsr $019935			jsr 	CheckNextComma
.0188cf	20 e6 92	jsr $0192e6			jsr 	EvaluateIntegerX
.0188d2	a9 00		lda #$00			lda 	#0							; set default xor.
.0188d4	85 8c		sta $8c				sta 	XS_Mantissa+XS_Size*2
.0188d6	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0188d8	c9 bf		cmp #$bf			cmp 	#token_Comma 				; no use the default
.0188da	d0 06		bne $0188e2			bne 	_CWAXorDefault
.0188dc	c8		iny				iny
.0188dd	a2 0c		ldx #$0c			ldx 	#XS_Size*2
.0188df	20 e6 92	jsr $0192e6			jsr 	EvaluateIntegerX
.0188e2					_CWAXorDefault:
.0188e2	a5 80		lda $80				lda 	XS_Mantissa 				; copy 24 bits of mantissa to ZLTemp1
.0188e4	85 1a		sta $1a				sta 	zLTemp1
.0188e6	a5 81		lda $81				lda 	XS_Mantissa+1
.0188e8	85 1b		sta $1b				sta 	zLTemp1+1
.0188ea	a5 82		lda $82				lda 	XS_Mantissa+2
.0188ec	85 1c		sta $1c				sta 	zLTemp1+2
.0188ee					_CWAWaitLoop:
.0188ee	20 40 85	jsr $018540			jsr 	VIOCheckBreak 				; exit on break.
.0188f1	c9 00		cmp #$00			cmp 	#0
.0188f3	d0 0f		bne $018904			bne 	_CWAWaitExit
.0188f5	a9 01		lda #$01			lda 	#1							; read 1 byte to mantissa/0
.0188f7	a2 00		ldx #$00			ldx 	#0
.0188f9	5a		phy				phy 								; this is the same routine as PEEK.
.0188fa	20 af 98	jsr $0198af			jsr 	MemRead
.0188fd	7a		ply				ply
.0188fe	25 86		and $86				and 	XS_Mantissa+XS_Size 		; process it
.018900	45 8c		eor $8c				eor 	XS_Mantissa+XS_Size*2
.018902	f0 ea		beq $0188ee			beq 	_CWAWaitLoop
.018904					_CWAWaitExit:
.018904	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/run.asm

.018905					Command_RUN:
.018905	20 e0 90	jsr $0190e0			jsr 	ResetRunStatus 				; clear, reset stacks etc.
.018908	a9 00		lda #$00			lda 	#BasicProgram & $FF
.01890a	85 16		sta $16				sta 	zCodePtr+0
.01890c	a9 10		lda #$10			lda 	#BasicProgram >> 8
.01890e	85 17		sta $17				sta 	zCodePtr+1
.018910	a9 00		lda #$00			lda 	#0
.018912	85 18		sta $18				sta 	zCodePtr+2
.018914	85 19		sta $19				sta 	zCodePtr+3
.018916	a0 03		ldy #$03			ldy 	#3
.018918					RUN_NewLine:
.018918	a0 00		ldy #$00			ldy 	#0
.01891a	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01891c	c8		iny				iny
.01891d	c8		iny				iny
.01891e	c8		iny				iny
.01891f	c9 00		cmp #$00			cmp 	#0 							; if the offset is zero then END.
.018921	d0 16		bne $018939			bne 	RUN_NextCommand
.018923	4c 8d 8c	jmp $018c8d			jmp 	Command_END 				; go do the command code.
.018926					RUN_Skip:
.018926	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018928	c8		iny				iny 								; skip
.018929	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.01892b	90 0c		bcc $018939			bcc 	_SEDone 					; so just skip over it.
.01892d	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.01892f	90 07		bcc $018938			bcc 	_SEDouble
.018931	98		tya				tya 								; this is Y + 1
.018932	18		clc				clc
.018933	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018935	a8		tay				tay 								; back in Y.
.018936	88		dey				dey 								; fix up, one for the +1, one for the iny
.018937	88		dey				dey
.018938					_SEDouble:
.018938	c8		iny				iny
.018939					_SEDone:
.018939					RUN_NextCommand:
.018939	ad a8 03	lda $03a8			lda 	BreakCount 					; break counter
.01893c	69 10		adc #$10			adc 	#16 						; one time in 16
.01893e	8d a8 03	sta $03a8			sta 	BreakCount
.018941	90 0a		bcc $01894d			bcc 	RUN_NoCheckBreak
.018943	20 40 85	jsr $018540			jsr 	VIOCheckBreak 				; check for break
.018946	c9 00		cmp #$00			cmp 	#0
.018948	f0 03		beq $01894d			beq 	RUN_NoCheckBreak
.01894a	4c f7 90	jmp $0190f7			jmp 	Command_STOP 				; stop on BREAK.
.01894d					RUN_NoCheckBreak:
.01894d	a9 00		lda #$00			lda 	#0 							; this resets temporary string allocation.
.01894f	85 21		sta $21				sta 	zTempStr+1 					; (initialised when first called)
.018951	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018953	c9 c0		cmp #$c0			cmp 	#token_Colon 				; skip over colons
.018955	f0 cf		beq $018926			beq 	RUN_Skip
.018957	c9 00		cmp #$00			cmp 	#0 							; if non-zero execute whatever
.018959	d0 0f		bne $01896a			bne 	RUN_Execute
.01895b					RUN_NextLine:
.01895b	a0 00		ldy #$00			ldy 	#0 							; point to offset
.01895d	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.01895f	18		clc				clc
.018960	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018962	85 16		sta $16				sta 	zCodePtr
.018964	90 02		bcc $018968			bcc 	_SNLNoCarry
.018966	e6 17		inc $17				inc 	zCodePtr+1
.018968					_SNLNoCarry:
.018968	80 ae		bra $018918			bra 	RUN_NewLine 				; go do the new line code
.01896a					RUN_Execute:
.01896a	c9 f8		cmp #$f8			cmp 	#$F8 						; handle shifts, REM etc.
.01896c	b0 1e		bcs $01898c			bcs 	RUN_Extension
.01896e	c8		iny				iny
.01896f	0a		asl a				asl 	a 							; double the character read.
.018970	90 14		bcc $018986			bcc 	RUN_Default 				; if carry clear was $00-$7F, so try LET.
.018972	aa		tax				tax 								; ready to look up.
.018973	bf dd 85 01	lda $0185dd,x			lda 	VectorTable,x 				; copy address into LocalVector
.018977	8d 11 03	sta $0311			sta 	LocalVector+1
.01897a	bf de 85 01	lda $0185de,x			lda 	VectorTable+1,x
.01897e	8d 12 03	sta $0312			sta 	LocalVector+2
.018981	20 31 92	jsr $019231			jsr 	EVCallLocalVector 			; execute the appropriate code.
.018984	80 b3		bra $018939			bra 	RUN_NextCommand 			; do the next command.
.018986					RUN_Default:
.018986	88		dey				dey
.018987	20 88 8b	jsr $018b88			jsr 	Command_LET 				; and try LET.
.01898a	80 ad		bra $018939			bra 	RUN_NextCommand
.01898c					RUN_Extension:
.01898c	c9 ff		cmp #$ff			cmp 	#$FF 						; if $FF (REM)
.01898e	f0 96		beq $018926			beq 	RUN_Skip 					; skip over it.
.018990	4c 4a 85	jmp $01854a			jmp 	SyntaxError
.018993					Command_COLON:
.018993	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/for.asm

.018994					Command_FOR:
.018994	20 88 8b	jsr $018b88			jsr 	Command_LET 				; do the A = 99 bit
.018997	a5 24		lda $24				lda 	zVarType 					; obviously has to be integer/real.
.018999	c9 b7		cmp #$b7			cmp 	#token_Dollar
.01899b	f0 71		beq $018a0e			beq 	_CFOError
.01899d	48		pha				pha 								; save the variable type.
.01899e	5a		phy				phy 								; save type/variable address.
.01899f	a0 01		ldy #$01			ldy 	#1							; type at + 1
.0189a1	91 26		sta ($26),y			sta 	(zBasicSP),y
.0189a3	c8		iny				iny
.0189a4	a5 22		lda $22				lda 	zVarDataPtr 				; data low at +2
.0189a6	91 26		sta ($26),y			sta 	(zBasicSP),y
.0189a8	c8		iny				iny
.0189a9	a5 23		lda $23				lda 	zVarDataPtr+1 				; data high at +3
.0189ab	91 26		sta ($26),y			sta 	(zBasicSP),y
.0189ad	7a		ply				ply
.0189ae	a9 53		lda #$53			lda 	#(SMark_For << 4) + 3
.0189b0	20 b2 84	jsr $0184b2			jsr 	StackPushFrame 				; push on the stack with FOR marker.
.0189b3	a9 c8		lda #$c8			lda 	#token_TO
.0189b5	20 16 99	jsr $019916			jsr 	CheckNextToken
.0189b8	a2 00		ldx #$00			ldx 	#0 							; put in Mantissa, bottom
.0189ba	20 4e 91	jsr $01914e			jsr 	EvaluateExpression
.0189bd	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0189bf	a2 06		ldx #$06			ldx 	#XS_Size 					; X to second level
.0189c1	c9 c9		cmp #$c9			cmp 	#token_STEP
.0189c3	d0 06		bne $0189cb			bne 	_CFOStep1
.0189c5	c8		iny				iny
.0189c6	20 50 91	jsr $019150			jsr 	EvaluateExpressionX 		; get STEP value.
.0189c9	80 0e		bra $0189d9			bra 	_CFOHaveStep
.0189cb					_CFOStep1:
.0189cb	a9 00		lda #$00			lda 	#0							; set step to integer 1.
.0189cd	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0189cf	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0189d1	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0189d3	a9 01		lda #$01			lda 	#1
.0189d5	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0189d7	95 85		sta $85,x			sta 	XS_Type,x
.0189d9					_CFOHaveStep:
.0189d9	68		pla				pla 								; restore variable type
.0189da	a2 00		ldx #$00			ldx 	#0
.0189dc	c9 bb		cmp #$bb			cmp 	#token_Percent 				; do conversion to type
.0189de	f0 0a		beq $0189ea			beq 	_CFOInteger
.0189e0	20 ea a2	jsr $01a2ea			jsr 	FPUToFloat
.0189e3	a2 06		ldx #$06			ldx 	#6
.0189e5	20 ea a2	jsr $01a2ea			jsr 	FPUToFloat
.0189e8	80 08		bra $0189f2			bra 	_CFOEndConv
.0189ea					_CFOInteger:
.0189ea	20 36 a3	jsr $01a336			jsr 	FPUToInteger
.0189ed	a2 06		ldx #$06			ldx 	#6
.0189ef	20 36 a3	jsr $01a336			jsr 	FPUToInteger
.0189f2					_CFOEndConv:
.0189f2	20 f9 84	jsr $0184f9			jsr 	StackSavePosition 			; save the loop position at 1-5
.0189f5	a9 55		lda #$55			lda 	#(SMark_For << 4)+SourcePosSize
.0189f7	20 b2 84	jsr $0184b2			jsr 	StackPushFrame 				; push the loop address frame.
.0189fa	5a		phy				phy
.0189fb	a0 00		ldy #$00			ldy 	#0
.0189fd					_CFOCopy:
.0189fd	b9 80 00	lda $0080,y			lda 	XS_Mantissa+0,y
.018a00	c8		iny				iny
.018a01	91 26		sta ($26),y			sta 	(zBasicSP),y
.018a03	c0 0c		cpy #$0c			cpy 	#XS_Size*2
.018a05	d0 f6		bne $0189fd			bne 	_CFOCopy
.018a07	7a		ply				ply
.018a08	a9 5c		lda #$5c			lda 	#(SMark_For << 4)+(XS_Size*2)
.018a0a	20 b2 84	jsr $0184b2			jsr 	StackPushFrame
.018a0d	60		rts				rts
.018a0e					_CFOError:
.018a0e	4c 5a 85	jmp $01855a			jmp 	TypeError 					; wrong type.
.018a11					Command_NEXT:
.018a11	a9 00		lda #$00			lda 	#0 							; set variable data pointer+1 to zero
.018a13	85 23		sta $23				sta 	zVarDataPtr+1 				; this means we don't check
.018a15	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018a17	c9 00		cmp #$00			cmp 	#0 							; EOL
.018a19	f0 07		beq $018a22			beq 	_CNextNoVariable
.018a1b	c9 40		cmp #$40			cmp 	#$40
.018a1d	b0 03		bcs $018a22			bcs 	_CNextNoVariable
.018a1f	20 db 99	jsr $0199db			jsr 	VariableFind
.018a22					_CNextNoVariable:
.018a22	a5 26		lda $26				lda 	zBasicSP 					; save on stack
.018a24	48		pha				pha
.018a25	a5 27		lda $27				lda 	zBasicSP+1
.018a27	48		pha				pha
.018a28	a9 50		lda #$50			lda 	#(SMark_For << 4) 			; pop loop address frame
.018a2a	20 c9 84	jsr $0184c9			jsr 	StackPopFrame
.018a2d	a9 50		lda #$50			lda 	#(SMark_For << 4) 			; pop STEP/TARGET frame.
.018a2f	20 c9 84	jsr $0184c9			jsr 	StackPopFrame
.018a32	a9 50		lda #$50			lda 	#(Smark_For << 4) 			; pop variable address frame.
.018a34	20 c9 84	jsr $0184c9			jsr 	StackPopFrame
.018a37	a5 23		lda $23				lda 	zVarDataPtr+1 				; if zero, then no variable provided
.018a39	f0 11		beq $018a4c			beq 	_CNextGetTarget 			; e.g. just NEXT not NEXT x
.018a3b	5a		phy				phy 								; check addresses match.
.018a3c	a0 02		ldy #$02			ldy 	#2
.018a3e	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a40	c5 22		cmp $22				cmp 	zVarDataPtr
.018a42	d0 69		bne $018aad			bne 	_CNextWrong
.018a44	c8		iny				iny
.018a45	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a47	c5 23		cmp $23				cmp 	zVarDataPtr+1
.018a49	d0 62		bne $018aad			bne 	_CNextWrong
.018a4b	7a		ply				ply
.018a4c					_CNextGetTarget:
.018a4c	5a		phy				phy
.018a4d	a0 01		ldy #$01			ldy 	#1 							; restore variable type and data.
.018a4f	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a51	85 24		sta $24				sta 	zVarType
.018a53	c8		iny				iny
.018a54	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a56	85 22		sta $22				sta 	zVarDataPtr
.018a58	c8		iny				iny
.018a59	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a5b	85 23		sta $23				sta 	zVarDataPtr+1
.018a5d	a2 0c		ldx #$0c			ldx 	#12
.018a5f	20 23 9d	jsr $019d23			jsr 	VariableGet 				; get that variable value into expr[2]
.018a62	a2 00		ldx #$00			ldx 	#0 							; copy stacked Target/Step into expr[0] and [1]
.018a64	a0 0b		ldy #$0b			ldy 	#11
.018a66					_CNXCopy:
.018a66	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a68	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018a6a	e8		inx				inx
.018a6b	c8		iny				iny
.018a6c	e0 0c		cpx #$0c			cpx 	#XS_Size*2
.018a6e	d0 f6		bne $018a66			bne 	_CNXCopy
.018a70	7a		ply				ply
.018a71	a2 06		ldx #$06			ldx 	#6 							; point at expr[1] s
.018a73	20 58 95	jsr $019558			jsr 	GetSignCurrent
.018a76	8d a7 03	sta $03a7			sta 	SignNext 					; save in temporary.
.018a79	a2 06		ldx #$06			ldx 	#6 							; add them, however
.018a7b	20 37 94	jsr $019437			jsr 	BinaryOp_Add
.018a7e	20 74 9d	jsr $019d74			jsr 	VariableSet					; and write variable back.
.018a81	a2 00		ldx #$00			ldx 	#0
.018a83	20 bb 93	jsr $0193bb			jsr 	CompareValues
.018a86	09 00		ora #$00			ora 	#0
.018a88	f0 05		beq $018a8f			beq 	_CNXAgain 					; if true, then do it again.
.018a8a	cd a7 03	cmp $03a7			cmp 	SignNext 					; if sign different, then loop has finished.
.018a8d	d0 0f		bne $018a9e			bne 	_CNXLoopDone
.018a8f					_CNXAgain:
.018a8f	a9 53		lda #$53			lda 	#(SMark_For << 4) + 3		; re-stack variable address
.018a91	20 b2 84	jsr $0184b2			jsr 	StackPushFrame
.018a94	20 16 85	jsr $018516			jsr 	StackRestorePosition 		; get restore position back, e.g. loop round.
.018a97	68		pla				pla
.018a98	85 27		sta $27				sta 	zBasicSP+1
.018a9a	68		pla				pla
.018a9b	85 26		sta $26				sta 	zBasicSP
.018a9d					_CNXExit:
.018a9d	60		rts				rts
.018a9e					_CNXLoopDone:
.018a9e	68		pla				pla
.018a9f	68		pla				pla
.018aa0	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018aa2	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma ?
.018aa4	d0 f7		bne $018a9d			bne 	_CNXExit
.018aa6	c8		iny				iny
.018aa7	20 db 99	jsr $0199db			jsr 	VariableFind 				; identify the variable
.018aaa	4c 22 8a	jmp $018a22			jmp 	_CNextNoVariable 			; go back with variable pre-found
.018aad					_CNextWrong:
.018aad	20 79 85	jsr $018579			jsr ERR_Handler
>018ab0	57 72 6f 6e 67 20 4e 65			.text "Wrong Next Variable",0
>018ab8	78 74 20 56 61 72 69 61 62 6c 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/read.asm

.018ac4					Command_READ:
.018ac4	20 db 99	jsr $0199db			jsr 	VariableFind 				; get variable/value into zVarDataPtr,zVarType
.018ac7	a5 22		lda $22				lda 	zVarDataPtr 				; save variable info on stack
.018ac9	48		pha				pha
.018aca	a5 23		lda $23				lda 	zVarDataPtr+1
.018acc	48		pha				pha
.018acd	a5 24		lda $24				lda 	zVarType
.018acf	48		pha				pha
.018ad0	20 16 8b	jsr $018b16			jsr 	READGetDataItem 			; get the next data item
.018ad3	68		pla				pla 								; restore target variable information.
.018ad4	85 24		sta $24				sta 	zVarType
.018ad6	68		pla				pla
.018ad7	85 23		sta $23				sta 	zVarDataPtr+1
.018ad9	68		pla				pla
.018ada	85 22		sta $22				sta 	zVarDataPtr
.018adc	a2 00		ldx #$00			ldx 	#0
.018ade	20 74 9d	jsr $019d74			jsr 	VariableSet 				; set the value out.
.018ae1	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018ae3	c8		iny				iny
.018ae4	c9 bf		cmp #$bf			cmp 	#token_Comma
.018ae6	f0 dc		beq $018ac4			beq 	Command_READ 				; found, do another READ
.018ae8	88		dey				dey
.018ae9	60		rts				rts
.018aea					Command_DATA:
.018aea	4c 80 84	jmp $018480			jmp 	SkipEndOfCommand
.018aed					Command_RESTORE:
.018aed	48		pha				pha
.018aee	a9 00		lda #$00			lda 	#0 							; this being zero means 'initialise next read'
.018af0	8d bd 03	sta $03bd			sta 	DataLPtr+0
.018af3	8d be 03	sta $03be			sta 	DataLPtr+1
.018af6	68		pla				pla
.018af7	60		rts				rts
.018af8					READSwapPointers:
.018af8	98		tya				tya
.018af9	48		pha				pha 								; save it
.018afa	ad c1 03	lda $03c1			lda 	DataIndex 					; get data offset, and copy to offset
.018afd	a8		tay				tay
.018afe	68		pla				pla 								; get code offset and save in DataIndex
.018aff	8d c1 03	sta $03c1			sta 	DataIndex
.018b02	da		phx				phx
.018b03	a2 03		ldx #$03			ldx 	#3 							; swap the Data Pointers (4 bytes) round.
.018b05					_RSWLoop:
.018b05	bd bd 03	lda $03bd,x			lda 	DataLPtr+0,x
.018b08	48		pha				pha
.018b09	b5 16		lda $16,x			lda 	zCodePtr+0,x
.018b0b	9d bd 03	sta $03bd,x			sta 	DataLPtr+0,x
.018b0e	68		pla				pla
.018b0f	95 16		sta $16,x			sta 	zCodePtr+0,x
.018b11	ca		dex				dex
.018b12	10 f1		bpl $018b05			bpl 	_RSWLoop
.018b14	fa		plx				plx
.018b15	60		rts				rts
.018b16					READGetDataItem:
.018b16	20 f8 8a	jsr $018af8			jsr 	ReadSwapPointers 			; swap code and data pointer.
.018b19	a5 16		lda $16				lda		zCodePtr+0 					; initialise ?
.018b1b	05 17		ora $17				ora 	zCodePtr+1
.018b1d	d0 12		bne $018b31			bne 	_RGDIIsInitialised
.018b1f	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018b21	85 16		sta $16				sta 	zCodePtr+0
.018b23	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018b25	85 17		sta $17				sta 	zCodePtr+1
.018b27	a9 00		lda #$00			lda 	#0
.018b29	85 18		sta $18				sta 	zCodePtr+2
.018b2b	85 19		sta $19				sta 	zCodePtr+3
.018b2d	a0 03		ldy #$03			ldy 	#3
.018b2f	80 06		bra $018b37			bra 	_RGDIFindData 				; locate next data from start and read that.
.018b31					_RGDIIsInitialised:
.018b31	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018b33	c9 bf		cmp #$bf			cmp 	#token_Comma
.018b35	f0 49		beq $018b80			beq 	_RGDISkipEvaluateExit
.018b37					_RGDIFindData:
.018b37	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018b39	c9 00		cmp #$00			cmp 	#0 							; end of line
.018b3b	f0 19		beq $018b56			beq 	_RGDIFindNextLine
.018b3d	c9 c5		cmp #$c5			cmp 	#token_DATA 				; found data token
.018b3f	f0 3f		beq $018b80			beq 	_RGDISkipEvaluateExit 		; then skip it and evaluate
.018b41	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018b43	c8		iny				iny 								; skip
.018b44	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018b46	90 0c		bcc $018b54			bcc 	_SEDone 					; so just skip over it.
.018b48	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018b4a	90 07		bcc $018b53			bcc 	_SEDouble
.018b4c	98		tya				tya 								; this is Y + 1
.018b4d	18		clc				clc
.018b4e	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018b50	a8		tay				tay 								; back in Y.
.018b51	88		dey				dey 								; fix up, one for the +1, one for the iny
.018b52	88		dey				dey
.018b53					_SEDouble:
.018b53	c8		iny				iny
.018b54					_SEDone:
.018b54	80 e1		bra $018b37			bra 	_RGDIFindData
.018b56					_RGDIFindNextLine:
.018b56	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018b58	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.018b5a	18		clc				clc
.018b5b	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018b5d	85 16		sta $16				sta 	zCodePtr
.018b5f	90 02		bcc $018b63			bcc 	_SNLNoCarry
.018b61	e6 17		inc $17				inc 	zCodePtr+1
.018b63					_SNLNoCarry:
.018b63	a0 00		ldy #$00			ldy 	#0
.018b65	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018b67	48		pha				pha
.018b68	c8		iny				iny
.018b69	c8		iny				iny
.018b6a	c8		iny				iny
.018b6b	68		pla				pla
.018b6c	d0 c9		bne $018b37			bne 	_RGDIFindData 				; back to scanning.
.018b6e	20 f8 8a	jsr $018af8			jsr 	ReadSwapPointers 			; so we get error in line number of READ
.018b71	20 79 85	jsr $018579			jsr ERR_Handler
>018b74	4f 75 74 20 6f 66 20 44			.text "Out of Data",0
>018b7c	61 74 61 00
.018b80					_RGDISkipEvaluateExit:
.018b80	c8		iny				iny
.018b81	20 4e 91	jsr $01914e			jsr 	EvaluateExpression 			; evaluate the expression
.018b84	20 f8 8a	jsr $018af8			jsr 	ReadSwapPointers 			; swap the pointers around.
.018b87	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/let.asm

.018b88					Command_LET:
.018b88	20 db 99	jsr $0199db			jsr 	VariableFind 				; get reference to one variable.
.018b8b	a9 84		lda #$84			lda 	#token_Equal  				; get equals
.018b8d	20 16 99	jsr $019916			jsr 	CheckNextToken
.018b90	a5 22		lda $22				lda 	zVarDataPtr 				; save variable info on stack
.018b92	48		pha				pha
.018b93	a5 23		lda $23				lda 	zVarDataPtr+1
.018b95	48		pha				pha
.018b96	a5 24		lda $24				lda 	zVarType
.018b98	48		pha				pha
.018b99	20 4e 91	jsr $01914e			jsr 	EvaluateExpression 			; evaluate the RHS, set X to zero.
.018b9c	68		pla				pla 								; restore target variable information.
.018b9d	85 24		sta $24				sta 	zVarType
.018b9f	68		pla				pla
.018ba0	85 23		sta $23				sta 	zVarDataPtr+1
.018ba2	68		pla				pla
.018ba3	85 22		sta $22				sta 	zVarDataPtr
.018ba5	20 74 9d	jsr $019d74			jsr 	VariableSet 				; set the value out.
.018ba8	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/get.asm

.018ba9					Command_GET:
.018ba9					_CGLoop:
.018ba9	20 db 99	jsr $0199db			jsr 	VariableFind 				; get a variable.
.018bac	20 35 85	jsr $018535			jsr 	VIOCharGet 					; get character
.018baf	b0 02		bcs $018bb3			bcs 	_CGNoKey
.018bb1	a9 00		lda #$00			lda 	#0 							; if no character return zero
.018bb3					_CGNoKey:
.018bb3	48		pha				pha
.018bb4	a5 24		lda $24				lda 	zVarType 					; look at the data type.
.018bb6	c9 b7		cmp #$b7			cmp 	#token_Dollar
.018bb8	f0 1e		beq $018bd8			beq 	_CGString
.018bba	68		pla				pla 								; put character in slot.
.018bbb	85 80		sta $80				sta 	XS_Mantissa
.018bbd	a9 00		lda #$00			lda 	#0
.018bbf	85 81		sta $81				sta 	XS_Mantissa+1
.018bc1	85 82		sta $82				sta 	XS_Mantissa+2
.018bc3	85 83		sta $83				sta 	XS_Mantissa+3
.018bc5	a9 01		lda #$01			lda 	#1 							; type integer
.018bc7	85 85		sta $85				sta 	XS_Type
.018bc9					_CGWriteSetNext:
.018bc9	a2 00		ldx #$00			ldx 	#0 							; write number/WriteTempString out
.018bcb	20 74 9d	jsr $019d74			jsr 	VariableSet
.018bce	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018bd0	c9 bf		cmp #$bf			cmp 	#token_Comma 				; if not comma exit
.018bd2	d0 03		bne $018bd7			bne 	_CGExit
.018bd4	c8		iny				iny
.018bd5	80 d2		bra $018ba9			bra 	_CGLoop 					; and get another.
.018bd7					_CGExit:
.018bd7	60		rts				rts
.018bd8					_CGString:
.018bd8	a9 02		lda #$02			lda 	#2 							; allocate temp string, space for 2.
.018bda	20 7a 99	jsr $01997a			jsr 	AllocateTempString 			; initially empty.
.018bdd	a5 20		lda $20				lda 	zTempStr 					; set up to be returned.
.018bdf	85 80		sta $80				sta 	XS_Mantissa
.018be1	a5 21		lda $21				lda 	zTempStr+1
.018be3	85 81		sta $81				sta 	XS_Mantissa+1
.018be5	a9 02		lda #$02			lda 	#2
.018be7	85 85		sta $85				sta 	XS_Type
.018be9	68		pla				pla 								; get A
.018bea	c9 00		cmp #$00			cmp 	#0
.018bec	f0 db		beq $018bc9			beq 	_CGWriteSetNext
.018bee	20 a5 99	jsr $0199a5			jsr 	WriteTempString 			; write it into string
.018bf1	80 d6		bra $018bc9			bra 	_CGWriteSetNext

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/sys.asm

.018bf3					Command_SYS:
.018bf3	20 e4 92	jsr $0192e4			jsr 	EvaluateInteger 			; address to call.
.018bf6	a5 80		lda $80				lda 	XS_Mantissa+0				; copy to localvector
.018bf8	8d 10 03	sta $0310			sta 	LocalVector+0 				; only three, can only do 24 bit calls
.018bfb	a5 81		lda $81				lda 	XS_Mantissa+1 				; and that only on 65816
.018bfd	8d 11 03	sta $0311			sta 	LocalVector+1
.018c00	a5 82		lda $82				lda 	XS_Mantissa+2
.018c02	8d 12 03	sta $0312			sta 	LocalVector+2
.018c05	22 0a 8c 01	jsl $018c0a			jsl 	_CSYLocalCall 				; jump depending on 24/16 bit code address
.018c09	60		rts				rts
.018c0a					_CSYLocalCall:
.018c0a	dc 10 03	jmp [$0310]			jmp 	[LocalVector]		 		; address

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/input.asm

.018c0d					Command_INPUT:
.018c0d	a9 00		lda #$00		lda 	#0 								; clear number of characters required.
.018c0f	8d c2 03	sta $03c2		sta 	InputAvailable 					; save character count
.018c12					_CILoop:
.018c12	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c14	c9 fe		cmp #$fe		cmp 	#$FE 							; is it a prompt string
.018c16	d0 15		bne $018c2d		bne 	_CINoPrompt
.018c18	c8		iny				iny
.018c19	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c1b	aa		tax			tax 									; into X
.018c1c	c8		iny				iny
.018c1d	ca		dex			dex 									; deduct marker/prompt length
.018c1e	ca		dex			dex
.018c1f	f0 f1		beq $018c12		beq 	_CILoop 						; nothing.
.018c21					_CIShowPrompt:
.018c21	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c23	20 32 85	jsr $018532		jsr 	VIOCharPrint
.018c26	c8		iny				iny
.018c27	ca		dex			dex
.018c28	d0 f7		bne $018c21		bne 	_CIShowPrompt
.018c2a	80 e6		bra $018c12		bra 	_CILoop
.018c2c					_CIAdvance:
.018c2c	c8		iny				iny
.018c2d					_CINoPrompt:
.018c2d	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c2f	c9 bf		cmp #$bf		cmp 	#token_Comma 					; skip , and ;
.018c31	f0 f9		beq $018c2c		beq 	_CIAdvance
.018c33	c9 c1		cmp #$c1		cmp 	#token_SemiColon
.018c35	f0 f5		beq $018c2c		beq 	_CIAdvance
.018c37	c9 00		cmp #$00		cmp 	#0 								; exit if 0 or :
.018c39	f0 04		beq $018c3f		beq 	_CIExit
.018c3b	c9 c0		cmp #$c0		cmp 	#token_Colon
.018c3d	d0 01		bne $018c40		bne 	_CIIsVariable  					; if not then there#s a variable or should be !
.018c3f					_CIExit:
.018c3f	60		rts			rts
.018c40					_CIIsVariable:
.018c40	20 db 99	jsr $0199db		jsr 	VariableFind 					; set zVarType and zVarDataPtr accordingly.
.018c43	ea		nop			nop
.018c44	a5 24		lda $24			lda 	zVarType
.018c46	c9 b7		cmp #$b7		cmp 	#token_Dollar 					; is it a string ?
.018c48	f0 41		beq $018c8b		beq 	_CIIsString
.018c4a					_CINGetText:
.018c4a	a9 00		lda #$00		lda 	#0
.018c4c	8d 14 03	sta $0314		sta 	NumBufX
.018c4f					_CINSkip:
.018c4f	20 8c 8c	jsr $018c8c		jsr 	CIGetCharacter 					; get character skip spaces
.018c52	c9 20		cmp #$20		cmp 	#" "
.018c54	f0 f9		beq $018c4f		beq 	_CINSkip
.018c56					_CINLoop:
.018c56	ae 14 03	ldx $0314		ldx 	NumBufX 						; output character
.018c59	9d 15 03	sta $0315,x		sta 	Num_Buffer,x
.018c5c	a9 00		lda #$00		lda 	#0 								; add trailing NULL
.018c5e	9d 16 03	sta $0316,x		sta 	Num_Buffer+1,x
.018c61	ee 14 03	inc $0314		inc 	NumBufX 						; bump ptr
.018c64	20 8c 8c	jsr $018c8c		jsr 	CIGetCharacter 					; get next character
.018c67	c9 21		cmp #$21		cmp 	#" "+1
.018c69	b0 eb		bcs $018c56		bcs 	_CINLoop
.018c6b	a9 03		lda #$03		lda 	#Num_Buffer >> 8 				; get ready to convert.
.018c6d	85 1f		sta $1f			sta 	zGenPtr+1
.018c6f	a9 15		lda #$15		lda 	#Num_Buffer & $FF
.018c71	85 1e		sta $1e			sta 	zGenPtr
.018c73	a2 00		ldx #$00		ldx 	#0
.018c75	20 72 9f	jsr $019f72		jsr 	INTFromString 					; integer conversion.
.018c78	b0 0a		bcs $018c84		bcs 	_CINFailed
.018c7a	20 f0 a4	jsr $01a4f0		jsr 	FPFromString
.018c7d	a2 00		ldx #$00		ldx 	#0 								; write value into variable
.018c7f	20 74 9d	jsr $019d74		jsr 	VariableSet
.018c82	80 8e		bra $018c12		bra 	_CILoop 						; go round again.
.018c84					_CINFailed:
.018c84	a9 00		lda #$00		lda 	#0 								; set to request input next time.
.018c86	8d c2 03	sta $03c2		sta 	InputAvailable
.018c89	80 bf		bra $018c4a		bra 	_CINGetText 					; and try again
.018c8b					_CIIsString:
.018c8b	ea		nop			nop
.018c8c					CIGetCharacter:
.018c8c	ea		nop			nop

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/end.asm

.018c8d					Command_END:
>018c8d	02						.byte 	2
.018c8e	4c 32 88	jmp $018832			jmp 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/if.asm

.018c91					Command_IF:
.018c91	20 e4 92	jsr $0192e4			jsr 	EvaluateInteger 			; check success.
.018c94	a5 80		lda $80				lda 	XS_Mantissa+0				; check the result if zero
.018c96	05 81		ora $81				ora 	XS_Mantissa+1
.018c98	05 82		ora $82				ora 	XS_Mantissa+2
.018c9a	05 83		ora $83				ora 	XS_Mantissa+3
.018c9c	aa		tax				tax 								; put into X.
.018c9d	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c9f	c9 93		cmp #$93			cmp 	#token_Then 				; then found.
.018ca1	d0 2c		bne $018ccf			bne 	_FIFExtended
.018ca3	c8		iny				iny
.018ca4	e0 00		cpx #$00			cpx 	#0 							; was it successful.
.018ca6	f0 0b		beq $018cb3			beq 	_FIFEndOfLine 				; if not, go to the end of the line.
.018ca8	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018caa	29 c0		and #$c0			and 	#$C0 						; is it a number
.018cac	c9 40		cmp #$40			cmp 	#$40
.018cae	d0 1e		bne $018cce			bne 	_FIFContinue 				; if not, do what ever follows.
.018cb0	4c 1e 90	jmp $01901e			jmp		Command_GOTO 				; we have IF <expr> THEN <number> so we do GOTO code.
.018cb3					_FIFEndOfLine:
.018cb3	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018cb5	c9 00		cmp #$00			cmp 	#0 							; if zero, end of line, so exit
.018cb7	f0 15		beq $018cce			beq 	_FIFContinue
.018cb9	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018cbb	c8		iny				iny 								; skip
.018cbc	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018cbe	90 0c		bcc $018ccc			bcc 	_SEDone 					; so just skip over it.
.018cc0	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018cc2	90 07		bcc $018ccb			bcc 	_SEDouble
.018cc4	98		tya				tya 								; this is Y + 1
.018cc5	18		clc				clc
.018cc6	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018cc8	a8		tay				tay 								; back in Y.
.018cc9	88		dey				dey 								; fix up, one for the +1, one for the iny
.018cca	88		dey				dey
.018ccb					_SEDouble:
.018ccb	c8		iny				iny
.018ccc					_SEDone:
.018ccc	80 e5		bra $018cb3			bra 	_FIFEndOfLine
.018cce					_FIFContinue:
.018cce	60		rts				rts
.018ccf					_FIFExtended:
.018ccf	da		phx				phx 								; save result
.018cd0	a9 40		lda #$40			lda 	#(SMark_If << 4) 			; push marker on the stack, nothing else.
.018cd2	20 b2 84	jsr $0184b2			jsr 	StackPushFrame
.018cd5	68		pla				pla 								; restore result
.018cd6	f0 01		beq $018cd9			beq 	_FIXSkip 					; if zero then it has failed.
.018cd8	60		rts				rts 								; test passed, so continue executing
.018cd9					_FIXSkip:
.018cd9	a9 94		lda #$94			lda 	#token_endif 				; scan forward till found either ELSE or ENDIF
.018cdb	a2 de		ldx #$de			ldx 	#token_else 				; at the same level.
.018cdd	20 f5 83	jsr $0183f5			jsr 	StructureSearchDouble
.018ce0	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018ce2	c8		iny				iny
.018ce3	c9 94		cmp #$94			cmp 	#token_endif 				; if endif, handle endif code.
.018ce5	f0 07		beq $018cee			beq 	Command_ENDIF
.018ce7	60		rts				rts
.018ce8					Command_ELSE:
.018ce8	a9 94		lda #$94			lda 	#token_endif 				; scan forward till found ENDIF
.018cea	20 f3 83	jsr $0183f3			jsr 	StructureSearchSingle 		; then do the ENDIF pop.
.018ced	c8		iny				iny
.018cee					Command_ENDIF:
.018cee	a9 40		lda #$40			lda 	#(SMark_If << 4)
.018cf0	20 c9 84	jsr $0184c9			jsr 	StackPopFrame
.018cf3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/list.asm

.018cf4					Command_LIST:
.018cf4	20 81 8e	jsr $018e81			jsr 	ListGetRange				; get any parameters
.018cf7	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018cf9	85 16		sta $16				sta 	zCodePtr+0
.018cfb	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018cfd	85 17		sta $17				sta 	zCodePtr+1
.018cff	a9 00		lda #$00			lda 	#0
.018d01	85 18		sta $18				sta 	zCodePtr+2
.018d03	85 19		sta $19				sta 	zCodePtr+3
.018d05	a0 03		ldy #$03			ldy 	#3
.018d07	a9 00		lda #$00			lda 	#0 							; reset the indent & last indent
.018d09	8d bc 03	sta $03bc			sta 	LastListIndent
.018d0c	8d bb 03	sta $03bb			sta 	ListIndent
.018d0f					_CILLoop:
.018d0f	a0 00		ldy #$00			ldy 	#0
.018d11	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018d13	c9 00		cmp #$00			cmp 	#0 							; if zero, end of program
.018d15	f0 23		beq $018d3a			beq 	_CILExit
.018d17	20 40 85	jsr $018540			jsr 	VIOCheckBreak 				; check break
.018d1a	c9 00		cmp #$00			cmp 	#0
.018d1c	d0 1c		bne $018d3a			bne 	_CILExit
.018d1e	20 c8 8e	jsr $018ec8			jsr 	ListCheckRange 				; check current line in range.
.018d21	b0 08		bcs $018d2b			bcs		_CILNext
.018d23	a0 00		ldy #$00			ldy 	#0
.018d25	c8		iny				iny
.018d26	c8		iny				iny
.018d27	c8		iny				iny
.018d28	20 3d 8d	jsr $018d3d			jsr 	ListLine 					; list one line.
.018d2b					_CILNext:
.018d2b	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018d2d	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.018d2f	18		clc				clc
.018d30	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018d32	85 16		sta $16				sta 	zCodePtr
.018d34	90 02		bcc $018d38			bcc 	_SNLNoCarry
.018d36	e6 17		inc $17				inc 	zCodePtr+1
.018d38					_SNLNoCarry:
.018d38	80 d5		bra $018d0f			bra 	_CILLoop
.018d3a					_CILExit:
.018d3a	4c 32 88	jmp $018832			jmp 	WarmStart
.018d3d					ListLine:
.018d3d	ad bb 03	lda $03bb			lda 	ListIndent 					; copy current list indent -> last
.018d40	8d bc 03	sta $03bc			sta 	LastListIndent
.018d43					_LICountIndent:
.018d43	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018d45	c9 00		cmp #$00			cmp 	#0
.018d47	f0 2f		beq $018d78			beq 	_LIDoneIndent
.018d49	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus
.018d4b	90 16		bcc $018d63			bcc 	_LICINext
.018d4d	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.018d4f	b0 12		bcs $018d63			bcs 	_LICINext
.018d51	ee bb 03	inc $03bb			inc 	ListIndent
.018d54	c9 93		cmp #$93			cmp 	#firstKeywordMinus
.018d56	90 0b		bcc $018d63			bcc 	_LICINext
.018d58	ce bb 03	dec $03bb			dec 	ListIndent
.018d5b	ce bb 03	dec $03bb			dec 	ListIndent
.018d5e	10 03		bpl $018d63			bpl 	_LICINext
.018d60	ee bb 03	inc $03bb			inc 	ListIndent
.018d63					_LICINext:
.018d63	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018d65	c8		iny				iny 								; skip
.018d66	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018d68	90 0c		bcc $018d76			bcc 	_SEDone 					; so just skip over it.
.018d6a	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018d6c	90 07		bcc $018d75			bcc 	_SEDouble
.018d6e	98		tya				tya 								; this is Y + 1
.018d6f	18		clc				clc
.018d70	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018d72	a8		tay				tay 								; back in Y.
.018d73	88		dey				dey 								; fix up, one for the +1, one for the iny
.018d74	88		dey				dey
.018d75					_SEDouble:
.018d75	c8		iny				iny
.018d76					_SEDone:
.018d76	80 cb		bra $018d43			bra 	_LICountIndent
.018d78					_LIDoneIndent:
.018d78	a0 00		ldy #$00			ldy 	#0
.018d7a	c8		iny				iny
.018d7b	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018d7d	85 80		sta $80				sta 	XS_Mantissa
.018d7f	c8		iny				iny
.018d80	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018d82	85 81		sta $81				sta 	XS_Mantissa+1
.018d84	20 bf 85	jsr $0185bf			jsr 	Print16BitInteger 			; print integer.
.018d87	85 10		sta $10				sta 	zTemp1 						; save spaces printed.
.018d89	ad bb 03	lda $03bb			lda 	ListIndent 					; smaller of current/prev indent
.018d8c	cd bc 03	cmp $03bc			cmp 	LastListIndent
.018d8f	90 03		bcc $018d94			bcc 	_LISmaller
.018d91	ad bc 03	lda $03bc			lda 	LastListIndent
.018d94					_LISmaller:
.018d94	0a		asl a				asl 	a 							; double indent
.018d95	49 ff		eor #$ff			eor 	#$FF 						; 2's complement arithmetic
.018d97	38		sec				sec
.018d98	65 10		adc $10				adc 	zTemp1 						; "subtract" indent e.g. print more.
.018d9a	aa		tax				tax 								; print spaces to column 6
.018d9b					_LISpace:
.018d9b	a9 20		lda #$20			lda 	#" "
.018d9d	20 71 8e	jsr $018e71			jsr 	ListPrintLC
.018da0	e8		inx				inx
.018da1	e0 06		cpx #$06			cpx 	#6
.018da3	d0 f6		bne $018d9b			bne 	_LISpace
.018da5					_LIDecode:
.018da5	c8		iny				iny
.018da6	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018da8	c9 00		cmp #$00			cmp 	#0 							; zero, exit.
.018daa	f0 0f		beq $018dbb			beq 	_LIExit
.018dac	30 12		bmi $018dc0			bmi 	_LIToken
.018dae	c9 40		cmp #$40			cmp 	#$40 						; 01-$3F, character.
.018db0	b0 50		bcs $018e02			bcs 	_LIInteger
.018db2	49 20		eor #$20			eor 	#$20 						; make 7 bit
.018db4	69 20		adc #$20			adc 	#$20
.018db6	20 71 8e	jsr $018e71			jsr 	ListPrintLC 				; print in LC
.018db9	80 ea		bra $018da5			bra 	_LIDecode
.018dbb					_LIExit:
.018dbb	a9 0d		lda #$0d			lda 	#13 						; print new line.
.018dbd	4c 71 8e	jmp $018e71			jmp 	ListPrintLC
.018dc0					_LIToken:
.018dc0	c9 fc		cmp #$fc			cmp 	#$FC 						; $FC-$FF ?
.018dc2	90 49		bcc $018e0d			bcc		_LICommandToken
.018dc4	48		pha				pha 								; save in case end
.018dc5	a2 22		ldx #$22			ldx 	#'"'						; print if $FE quoted string
.018dc7	c9 fe		cmp #$fe			cmp 	#$FE
.018dc9	f0 17		beq $018de2			beq 	_LIPrint
.018dcb	a2 2e		ldx #$2e			ldx 	#'.'						; print if $FD decimals
.018dcd	c9 fd		cmp #$fd			cmp 	#$FD
.018dcf	f0 11		beq $018de2			beq 	_LIPrint
.018dd1	a9 52		lda #$52			lda 	#'R'						; must be REM
.018dd3	20 71 8e	jsr $018e71			jsr 	ListPrintLC
.018dd6	a9 45		lda #$45			lda 	#'E'
.018dd8	20 71 8e	jsr $018e71			jsr 	ListPrintLC
.018ddb	a9 4d		lda #$4d			lda 	#'M'
.018ddd	20 71 8e	jsr $018e71			jsr 	ListPrintLC
.018de0	a2 20		ldx #$20			ldx 	#' '
.018de2					_LIPrint:
.018de2	8a		txa				txa
.018de3	20 71 8e	jsr $018e71			jsr 	ListPrintLC
.018de6	c8		iny				iny
.018de7	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018de9	aa		tax				tax 								; put in X
.018dea	ca		dex				dex
.018deb					_LILoop:
.018deb	ca		dex				dex 								; exit when count reached zero.
.018dec	f0 08		beq $018df6			beq 	_LIEnd
.018dee	c8		iny				iny
.018def	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018df1	20 71 8e	jsr $018e71			jsr 	ListPrintLC
.018df4	80 f5		bra $018deb			bra 	_LILoop
.018df6	68		pla		_LIEnd:	pla 								; get A back
.018df7	c9 fe		cmp #$fe			cmp 	#$FE 						; if '"' need closing quotes
.018df9	d0 aa		bne $018da5			bne 	_LIDecode
.018dfb	a9 22		lda #$22			lda 	#'"'
.018dfd	20 71 8e	jsr $018e71			jsr 	ListPrintLC
.018e00	80 a3		bra $018da5			bra 	_LIDecode
.018e02					_LIInteger:
.018e02	a2 00		ldx #$00			ldx 	#0
.018e04	20 56 92	jsr $019256			jsr 	EvaluateGetInteger 			; get an atom
.018e07	88		dey				dey
.018e08	20 c5 85	jsr $0185c5			jsr 	Print32BitInteger 			; print integer.
.018e0b	80 98		bra $018da5			bra 	_LIDecode
.018e0d					_LICommandToken:
.018e0d	5a		phy				phy 								; save Y
.018e0e	48		pha				pha 								; save token
.018e0f	a2 bd		ldx #$bd			ldx  	#KeywordText & $FF 			; address of keyword text table.
.018e11	a9 86		lda #$86			lda 	(#KeywordText >> 8) & $FF
.018e13	86 1a		stx $1a				stx 	zLTemp1
.018e15	85 1b		sta $1b				sta 	zLTemp1+1
.018e17	a9 01		lda #$01			lda 	(#KeywordText >> 16) & $FF 	; this is for 65816 (it's a table in code
.018e19	85 1c		sta $1c				sta 	zLTemp1+2 					; space) and won't affect a 6502 at all.
.018e1b	68		pla				pla 								; get token
.018e1c	29 7f		and #$7f			and 	#127 						; chuck bit 7.
.018e1e	f0 16		beq $018e36			beq 	_LIFoundToken
.018e20	aa		tax				tax
.018e21					_LITokenLoop:
.018e21	a0 00		ldy #$00			ldy 	#0 							; last character not a token.
.018e23					_LIFindEnd:
.018e23	b7 1a		lda [$1a],y			lda 	[zLTemp1],y
.018e25	c8		iny				iny
.018e26	0a		asl a				asl 	a
.018e27	90 fa		bcc $018e23			bcc 	_LIFindEnd
.018e29	98		tya				tya 								; that is step to the next
.018e2a	18		clc				clc 								; we don't bother bumping the 3rd byte
.018e2b	65 1a		adc $1a				adc 	zLTemp1 					; here.
.018e2d	85 1a		sta $1a				sta 	zLTemp1
.018e2f	90 02		bcc $018e33			bcc 	_LINoBump
.018e31	e6 1b		inc $1b				inc 	zLTemp1+1
.018e33					_LINoBump:
.018e33	ca		dex				dex 								; no go round again.
.018e34	d0 eb		bne $018e21			bne 	_LITokenLoop
.018e36					_LIFoundToken:
.018e36	a0 00		ldy #$00			ldy 	#0
.018e38					_LIPrintToken:
.018e38	b7 1a		lda [$1a],y			lda 	[zLTemp1],y
.018e3a	c0 00		cpy #$00			cpy 	#0 							; see if needs prefix space
.018e3c	d0 16		bne $018e54			bne 	_LINoPrefixSpace
.018e3e	c9 41		cmp #$41			cmp 	#"A" 						; e.g. alphabetic token.
.018e40	90 12		bcc $018e54			bcc 	_LINoPrefixSpace
.018e42	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018e44	b0 0e		bcs $018e54			bcs 	_LINoPrefixSpace
.018e46	ae ba 03	ldx $03ba			ldx 	LastPrinted 				; if last was space not required
.018e49	e0 20		cpx #$20			cpx 	#" "
.018e4b	f0 07		beq $018e54			beq 	_LINoPrefixSpace
.018e4d	48		pha				pha
.018e4e	a9 20		lda #$20			lda 	#" "
.018e50	20 71 8e	jsr $018e71			jsr 	ListPrintLC
.018e53	68		pla				pla
.018e54					_LINoPrefixSpace:
.018e54	c8		iny				iny
.018e55	48		pha				pha 								; save it
.018e56	29 7f		and #$7f			and 	#$7F
.018e58	20 71 8e	jsr $018e71			jsr 	ListPrintLC
.018e5b	68		pla				pla
.018e5c	10 da		bpl $018e38			bpl 	_LIPrintToken 				; go back if not end
.018e5e	7a		ply				ply 								; restore Y
.018e5f	29 7f		and #$7f			and 	#$7F 						; if last char is a letter
.018e61	c9 41		cmp #$41			cmp 	#"A"
.018e63	90 09		bcc $018e6e			bcc 	_LINotLetter2
.018e65	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018e67	b0 05		bcs $018e6e			bcs 	_LINotLetter2
.018e69	a9 20		lda #$20			lda 	#" " 						; add spacing
.018e6b	20 71 8e	jsr $018e71			jsr 	ListPrintLC
.018e6e					_LINotLetter2:
.018e6e	4c a5 8d	jmp $018da5			jmp 	_LIDecode
.018e71					ListPrintLC:
.018e71	8d ba 03	sta $03ba			sta 	LastPrinted
.018e74	c9 41		cmp #$41			cmp 	#"A"
.018e76	90 06		bcc $018e7e			bcc 	_LPLC0
.018e78	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018e7a	b0 02		bcs $018e7e			bcs 	_LPLC0
.018e7c	69 20		adc #$20			adc 	#$20
.018e7e	4c 32 85	jmp $018532	_LPLC0:	jmp 	VIOCharPrint
.018e81					ListGetRange:
.018e81	a2 0b		ldx #$0b			ldx 	#XS_Size*2-1 				; clear first 2 slots back to defaults.
.018e83					_LGRClear:
.018e83	a9 00		lda #$00			lda 	#0
.018e85	95 80		sta $80,x			sta 	XS_Mantissa,x
.018e87	ca		dex				dex
.018e88	10 f9		bpl $018e83			bpl 	_LGRClear
.018e8a	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e8c	c9 00		cmp #$00			cmp 	#0 							; nothing
.018e8e	f0 21		beq $018eb1			beq 	_LGRBlank
.018e90	c9 c0		cmp #$c0			cmp 	#token_Colon 				; or colon
.018e92	f0 1d		beq $018eb1			beq 	_LGRBlank
.018e94	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma
.018e96	f0 18		beq $018eb0			beq 	_LGREnd 					; then it's LIST ,x
.018e98	20 e4 92	jsr $0192e4			jsr 	EvaluateInteger 			; get the first number into bottom
.018e9b	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e9d	c9 bf		cmp #$bf			cmp 	#token_Comma
.018e9f	f0 0f		beq $018eb0			beq 	_LGREnd 					; then it is LIST a,b
.018ea1	a5 80		lda $80				lda 	XS_Mantissa+0 				; copy first to second LIST n is n,n
.018ea3	85 86		sta $86				sta 	XS_Mantissa+XS_Size+0
.018ea5	a5 81		lda $81				lda 	XS_Mantissa+1
.018ea7	85 87		sta $87				sta 	XS_Mantissa+XS_Size+1
.018ea9					_LGRBumpExit:
.018ea9	e6 86		inc $86				inc 	XS_Mantissa+XS_Size 		; bump it so we can use cc.
.018eab	d0 02		bne $018eaf			bne 	_LGRBump2
.018ead	e6 87		inc $87				inc 	XS_Mantissa+XS_Size+1
.018eaf					_LGRBump2:
.018eaf	60		rts				rts
.018eb0					_LGREnd:
.018eb0	c8		iny				iny
.018eb1					_LGRBlank:
.018eb1	a9 ff		lda #$ff			lda 	#$FF 						; default to the end.
.018eb3	85 86		sta $86				sta 	XS_Mantissa+XS_Size
.018eb5	85 87		sta $87				sta 	XS_Mantissa+XS_Size+1
.018eb7	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018eb9	c9 00		cmp #$00			cmp 	#0
.018ebb	f0 f2		beq $018eaf			beq 	_LGRBump2
.018ebd	0a		asl a				asl 	a 							; if not a number, then exit (to end)
.018ebe	b0 ef		bcs $018eaf			bcs 	_LGRBump2
.018ec0	a2 06		ldx #$06			ldx 	#XS_Size 					; get to range
.018ec2	20 e6 92	jsr $0192e6			jsr 	EvaluateIntegerX
.018ec5	80 e2		bra $018ea9			bra 	_LGRBumpExit
.018ec7	60		rts				rts
.018ec8					ListCheckRange:
.018ec8	c8		iny				iny
.018ec9	a2 00		ldx #$00			ldx 	#0 							; test low
.018ecb	20 d8 8e	jsr $018ed8			jsr 	_LCRCompare
.018ece	90 06		bcc $018ed6			bcc 	_LCRFail
.018ed0	a2 06		ldx #$06			ldx 	#XS_Size 					; test high
.018ed2	20 d8 8e	jsr $018ed8			jsr 	_LCRCompare
.018ed5	60		rts				rts
.018ed6					_LCRFail:
.018ed6	38		sec				sec
.018ed7	60		rts				rts
.018ed8					_LCRCompare:
.018ed8	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018eda	38		sec				sec
.018edb	f5 80		sbc $80,x			sbc	 	XS_Mantissa+0,x
.018edd	08		php				php
.018ede	c8		iny				iny
.018edf	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018ee1	28		plp				plp
.018ee2	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.018ee4	08		php				php
.018ee5	88		dey				dey
.018ee6	28		plp				plp
.018ee7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/print.asm

.018ee8					Command_PRINT:
.018ee8					_CPR_Loop:
.018ee8	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018eea	c9 00		cmp #$00			cmp 	#0 							; end
.018eec	f0 24		beq $018f12			beq 	_CPR_GoNewLine
.018eee	c9 c0		cmp #$c0			cmp 	#token_Colon
.018ef0	f0 20		beq $018f12			beq 	_CPR_GoNewLine
.018ef2	c9 c1		cmp #$c1			cmp 	#token_SemiColon
.018ef4	f0 74		beq $018f6a			beq 	_CPR_Skip
.018ef6	c9 bf		cmp #$bf			cmp 	#token_Comma
.018ef8	f0 57		beq $018f51			beq 	_CPR_Tab
.018efa	20 4e 91	jsr $01914e			jsr 	EvaluateExpression 			; get expression.
.018efd	a5 85		lda $85				lda 	XS_Type 					; get type.
.018eff	29 02		and #$02			and 	#2
.018f01	d0 27		bne $018f2a			bne 	_CPR_String 				; if type = 2 output as string.
.018f03					_CPR_Number:
.018f03	a9 00		lda #$00			lda 	#0 							; reset buffer index
.018f05	8d 14 03	sta $0314			sta 	NumBufX
.018f08	a5 85		lda $85				lda 	XS_Type 					; get type
.018f0a	4a		lsr a				lsr 	a
.018f0b	b0 08		bcs $018f15			bcs 	_CPRInt 					; if msb set do as integer
.018f0d	20 35 a4	jsr $01a435			jsr 	FPToString 					; call fp to str otherwise
.018f10	80 06		bra $018f18			bra 	_CPRNPrint
.018f12					_CPR_GoNewLine:
.018f12	4c 78 8f	jmp $018f78			jmp 	_CPR_NewLine
.018f15	20 bd 9e	jsr $019ebd	_CPRInt:jsr 	IntToString
.018f18					_CPRNPrint:
.018f18	ad 15 03	lda $0315			lda 	Num_Buffer 					; is first character -
.018f1b	c9 2d		cmp #$2d			cmp 	#"-"
.018f1d	f0 05		beq $018f24			beq 	_CPRNoSpace
.018f1f	a9 20		lda #$20			lda 	#" "						; print the leading space
.018f21	20 32 85	jsr $018532			jsr 	VIOCharPrint 				; so beloved of MS Basics.
.018f24					_CPRNoSpace:
.018f24	a2 14		ldx #$14			ldx 	#(Num_Buffer-1) & $FF
.018f26	a9 03		lda #$03			lda 	#(Num_Buffer-1) >> 8
.018f28	80 04		bra $018f2e			bra 	_CPRPrint
.018f2a					_CPR_String:
.018f2a	a6 80		ldx $80				ldx 	XS_Mantissa
.018f2c	a5 81		lda $81				lda 	XS_Mantissa+1
.018f2e					_CPRPrint:
.018f2e	86 1e		stx $1e				stx 	zGenPtr
.018f30	85 1f		sta $1f				sta 	zGenPtr+1
.018f32	5a		phy				phy
.018f33	a0 00		ldy #$00			ldy 	#0							; get length into X
.018f35	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018f37	aa		tax				tax
.018f38	f0 09		beq $018f43			beq 	_CPREndPrint 				; nothing to print
.018f3a					_CPRLoop:
.018f3a	c8		iny				iny
.018f3b	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018f3d	20 32 85	jsr $018532			jsr 	VIOCharPrint
.018f40	ca		dex				dex
.018f41	d0 f7		bne $018f3a			bne 	_CPRLoop
.018f43					_CPREndPrint:
.018f43	a5 85		lda $85				lda 	XS_Type 					; if numeric add trailing space
.018f45	29 02		and #$02			and 	#2
.018f47	d0 05		bne $018f4e			bne 	_CPRNoTrail
.018f49	a9 20		lda #$20			lda 	#" "
.018f4b	20 32 85	jsr $018532			jsr 	VIOCharPrint
.018f4e					_CPRNoTrail:
.018f4e	7a		ply				ply
.018f4f	80 97		bra $018ee8			bra 	_CPR_Loop
.018f51					_CPR_Tab:
.018f51	20 43 85	jsr $018543			jsr 	VIOCharGetPosition 			; print until position % 8 = 0
.018f54					_CPR_CalcSpaces:
.018f54	38		sec				sec 								; calculate position mod 10.
.018f55	e9 0a		sbc #$0a			sbc 	#10
.018f57	b0 fb		bcs $018f54			bcs 	_CPR_CalcSpaces
.018f59	69 0a		adc #$0a			adc 	#10
.018f5b	f0 0d		beq $018f6a			beq 	_CPR_Skip 					; nothing to print
.018f5d	aa		tax				tax 								; print out spaces to mod 10
.018f5e					_CPRTabSpaces:
.018f5e	a9 20		lda #$20			lda 	#" "
.018f60	20 32 85	jsr $018532			jsr 	VIOCharPrint
.018f63	e8		inx				inx
.018f64	e0 0a		cpx #$0a			cpx 	#10
.018f66	d0 f6		bne $018f5e			bne 	_CPRTabSpaces
.018f68	80 e7		bra $018f51			bra 	_CPR_Tab
.018f6a					_CPR_Skip:
.018f6a	c8		iny				iny
.018f6b	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018f6d	c9 c0		cmp #$c0			cmp 	#token_Colon 				; colon or $00, exit
.018f6f	f0 0c		beq $018f7d			beq 	_CPR_Exit
.018f71	c9 00		cmp #$00			cmp 	#0
.018f73	f0 08		beq $018f7d			beq 	_CPR_Exit 					; if not go round again.
.018f75	4c e8 8e	jmp $018ee8			jmp 	_CPR_Loop
.018f78					_CPR_NewLine:
.018f78	a9 0d		lda #$0d			lda 	#13
.018f7a	20 32 85	jsr $018532			jsr 	VIOCharPrint
.018f7d					_CPR_Exit:
.018f7d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/assert.asm

.018f7e					Command_ASSERT:
.018f7e	20 e4 92	jsr $0192e4			jsr 	EvaluateInteger 			; calculate thing being asserted, 0=>X
.018f81	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; check if true (non-zero)
.018f83	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.018f85	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.018f87	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.018f89	f0 01		beq $018f8c			beq 	_ASFail
.018f8b	60		rts				rts
.018f8c					_ASFail:
.018f8c	20 79 85	jsr $018579			jsr ERR_Handler
>018f8f	41 73 73 65 72 74 00			.text "Assert",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/poke.asm

.018f96					Command_POKE:
.018f96	a9 01		lda #$01			lda 	#1 							; 1 byte
.018f98	80 06		bra $018fa0			bra 	CmdPoke_Main
.018f9a					Command_DOKE:
.018f9a	a9 02		lda #$02			lda 	#2 							; 2 bytes
.018f9c	80 02		bra $018fa0			bra 	CmdPoke_Main
.018f9e					Command_LOKE:
.018f9e	a9 04		lda #$04			lda 	#4							; 4 bytes
.018fa0					CmdPoke_Main:
.018fa0	48		pha				pha
.018fa1	20 e4 92	jsr $0192e4			jsr 	EvaluateInteger 			; get two parameters. First is address
.018fa4	e8		inx				inx
.018fa5	e8		inx				inx
.018fa6	e8		inx				inx
.018fa7	e8		inx				inx
.018fa8	e8		inx				inx
.018fa9	e8		inx				inx
.018faa	20 35 99	jsr $019935			jsr 	CheckNextComma
.018fad	20 e6 92	jsr $0192e6			jsr 	EvaluateIntegerX 			; second is the data.
.018fb0	a5 80		lda $80				lda 	XS_Mantissa+0 				; copy the mantissa into ZLTemp1 (address)
.018fb2	85 1a		sta $1a				sta 	zLTemp1
.018fb4	a5 81		lda $81				lda 	XS_Mantissa+1
.018fb6	85 1b		sta $1b				sta 	zLTemp1+1
.018fb8	a5 82		lda $82				lda 	XS_Mantissa+2
.018fba	85 1c		sta $1c				sta 	zLTemp1+2
.018fbc	a5 83		lda $83				lda 	XS_Mantissa+3
.018fbe	85 1d		sta $1d				sta 	zLTemp1+3
.018fc0	68		pla				pla 								; get count
.018fc1	5a		phy				phy 								; save Y
.018fc2	20 c0 98	jsr $0198c0			jsr 	MemWrite 					; write it out
.018fc5	7a		ply				ply 								; restore Y and done.
.018fc6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/newold.asm

.018fc7					Command_NEW:
.018fc7	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018fc9	85 16		sta $16				sta 	zCodePtr+0
.018fcb	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018fcd	85 17		sta $17				sta 	zCodePtr+1
.018fcf	a9 00		lda #$00			lda 	#0
.018fd1	85 18		sta $18				sta 	zCodePtr+2
.018fd3	85 19		sta $19				sta 	zCodePtr+3
.018fd5	a0 03		ldy #$03			ldy 	#3
.018fd7	a0 00		ldy #$00			ldy 	#0
.018fd9	a9 00		lda #$00			lda 	#0 							; write a 0 there.
.018fdb	97 16		sta [$16],y			sta 	[zCodePtr],y
.018fdd	20 d1 98	jsr $0198d1			jsr 	UpdateProgramEnd 			; update program end.
.018fe0	4c 32 88	jmp $018832			jmp 	WarmStart
.018fe3					Command_OLD:
.018fe3	ea		nop				nop
.018fe4	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018fe6	85 16		sta $16				sta 	zCodePtr+0
.018fe8	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018fea	85 17		sta $17				sta 	zCodePtr+1
.018fec	a9 00		lda #$00			lda 	#0
.018fee	85 18		sta $18				sta 	zCodePtr+2
.018ff0	85 19		sta $19				sta 	zCodePtr+3
.018ff2	a0 03		ldy #$03			ldy 	#3
.018ff4					_COL_Find:
.018ff4	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018ff6	c8		iny				iny
.018ff7	c9 00		cmp #$00			cmp 	#0 							; if zero, then the position Y/Z is new offset
.018ff9	f0 18		beq $019013			beq 	_COL_Found
.018ffb	98		tya				tya
.018ffc	c9 00		cmp #$00			cmp 	#0
.018ffe	d0 f4		bne $018ff4			bne 	_COL_Find 					; can't find old EOL, give up.
.019000	20 79 85	jsr $018579			jsr ERR_Handler
>019003	50 72 6f 67 72 61 6d 20			.text "Program Corrupt",0
>01900b	43 6f 72 72 75 70 74 00
.019013					_COL_Found:
.019013	98		tya				tya
.019014	48		pha				pha
.019015	a0 00		ldy #$00			ldy 	#0
.019017	68		pla				pla
.019018	97 16		sta [$16],y			sta 	[zCodePtr],y
.01901a	20 d1 98	jsr $0198d1			jsr 	UpdateProgramEnd 			; reset variable pointer
.01901d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/branch.asm

.01901e					Command_GOTO:
.01901e	20 73 90	jsr $019073			jsr 	GotoGetLineNumber
.019021					CmdGOTO:
.019021	a2 00		ldx #$00			ldx 	#0
.019023	4c 90 90	jmp $019090			jmp 	GotoChangeToLineNumberX
.019026					Command_GOSUB:
.019026	20 73 90	jsr $019073			jsr 	GotoGetLineNumber
.019029					CmdGOSUB:
.019029	20 f9 84	jsr $0184f9			jsr 	StackSavePosition
.01902c	a9 15		lda #$15			lda 	#(SMark_Gosub << 4)+SourcePosSize
.01902e	20 b2 84	jsr $0184b2			jsr 	StackPushFrame
.019031	a2 00		ldx #$00			ldx		#0
.019033	4c 90 90	jmp $019090			jmp 	GotoChangeToLineNumberX
.019036					Command_RETURN:
.019036	a9 10		lda #$10			lda 	#(SMark_Gosub << 4)
.019038	20 c9 84	jsr $0184c9			jsr 	StackPopFrame
.01903b	20 16 85	jsr $018516			jsr 	StackRestorePosition
.01903e	60		rts				rts
.01903f					Command_ON:
.01903f	a2 00		ldx #$00			ldx 	#0 							; get the ON.
.019041	20 83 97	jsr $019783			jsr 	SLIByteParameter
.019044	a5 80		lda $80				lda 	XS_Mantissa+0 				; get the count
.019046	f0 28		beq $019070			beq 	_CONFail 					; can't be zero.
.019048	aa		tax				tax 								; save in X.
.019049	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01904b	c8		iny				iny
.01904c	48		pha				pha
.01904d	c9 cc		cmp #$cc			cmp 	#token_GOTO 				; must be GOTO or GOSUB
.01904f	f0 07		beq $019058			beq 	_CONOkayToken
.019051	c9 ca		cmp #$ca			cmp 	#token_GOSUB
.019053	f0 03		beq $019058			beq 	_CONOkayToken
.019055	4c 4a 85	jmp $01854a			jmp 	SyntaxError
.019058					_CONOkayToken:
.019058	da		phx				phx 								; count on top, GOTO/GOSUB token 2nd.
.019059					_CONFindNumber:
.019059	20 73 90	jsr $019073			jsr 	GotoGetLineNumber 			; get a line number.
.01905c	fa		plx				plx 								; restore count
.01905d	ca		dex				dex  								; decrement, exit if zero.
.01905e	f0 06		beq $019066			beq 	_CONFound
.019060	da		phx				phx 								; push back
.019061	20 35 99	jsr $019935			jsr 	CheckNextComma				; check for comma
.019064	80 f3		bra $019059			bra 	_CONFindNumber
.019066					_CONFound:
.019066	68		pla				pla 								; get token
.019067	c9 cc		cmp #$cc			cmp 	#token_GOTO 				; if GOTO
.019069	f0 b6		beq $019021			beq		CmdGOTO 					; then just branch.
.01906b	20 80 84	jsr $018480			jsr 	SkipEndOfCommand 			; go to end of command
.01906e	80 b9		bra $019029			bra 	CmdGOSUB 					; and do a GOSUB.
.019070					_CONFail:
.019070	4c 68 85	jmp $018568			jmp 	BadParamError
.019073					GotoGetLineNumber:
.019073	20 e4 92	jsr $0192e4			jsr 	EvaluateInteger
.019076	a5 82		lda $82				lda 	XS_Mantissa+2 				; check range
.019078	05 83		ora $83				ora 	XS_Mantissa+3
.01907a	d0 01		bne $01907d			bne 	_GLINError
.01907c	60		rts				rts
.01907d					_GLINError:
.01907d	20 79 85	jsr $018579			jsr ERR_Handler
>019080	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>019088	20 4e 75 6d 62 65 72 00
.019090					GotoChangeToLineNumberX:
.019090	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check line number not zero
.019092	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019094	f0 37		beq $0190cd			beq 	_GCTLFail
.019096	a9 00		lda #$00			lda 	#BasicProgram & $FF
.019098	85 16		sta $16				sta 	zCodePtr+0
.01909a	a9 10		lda #$10			lda 	#BasicProgram >> 8
.01909c	85 17		sta $17				sta 	zCodePtr+1
.01909e	a9 00		lda #$00			lda 	#0
.0190a0	85 18		sta $18				sta 	zCodePtr+2
.0190a2	85 19		sta $19				sta 	zCodePtr+3
.0190a4	a0 03		ldy #$03			ldy 	#3
.0190a6					_GCTLLoop:
.0190a6	a0 00		ldy #$00			ldy 	#0
.0190a8	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0190aa	c9 00		cmp #$00			cmp 	#0
.0190ac	f0 1f		beq $0190cd			beq 	_GCTLFail
.0190ae	c8		iny				iny
.0190af	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0190b1	d5 80		cmp $80,x			cmp 	XS_Mantissa+0,x
.0190b3	d0 07		bne $0190bc			bne 	_GCTLNext
.0190b5	c8		iny				iny
.0190b6	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0190b8	d5 81		cmp $81,x			cmp 	XS_Mantissa+1,x
.0190ba	f0 0f		beq $0190cb			beq 	_GCTLExit
.0190bc					_GCTLNext:
.0190bc	a0 00		ldy #$00			ldy 	#0 							; point to offset
.0190be	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.0190c0	18		clc				clc
.0190c1	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.0190c3	85 16		sta $16				sta 	zCodePtr
.0190c5	90 02		bcc $0190c9			bcc 	_SNLNoCarry
.0190c7	e6 17		inc $17				inc 	zCodePtr+1
.0190c9					_SNLNoCarry:
.0190c9	80 db		bra $0190a6			bra 	_GCTLLoop 					; try next line.
.0190cb					_GCTLExit:
.0190cb	c8		iny				iny
.0190cc	60		rts				rts
.0190cd					_GCTLFail:
.0190cd	20 79 85	jsr $018579			jsr ERR_Handler
>0190d0	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>0190d8	20 4e 75 6d 62 65 72 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.0190e0					Command_CLR:
.0190e0					ResetRunStatus:
.0190e0	20 17 9a	jsr $019a17			jsr 	VariableClear
.0190e3	20 a0 84	jsr $0184a0			jsr 	StackReset
.0190e6	a9 00		lda #$00			lda 	#HighMemory & $FF
.0190e8	8d 00 03	sta $0300			sta 	StringPtr
.0190eb	a9 7f		lda #$7f			lda 	#HighMemory >> 8
.0190ed	8d 01 03	sta $0301			sta 	StringPtr+1
.0190f0	20 e1 9b	jsr $019be1			jsr 	ArrayResetDefault
.0190f3	20 ed 8a	jsr $018aed			jsr 	Command_RESTORE
.0190f6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/stop.asm

.0190f7					Command_STOP:
.0190f7	20 79 85	jsr $018579			jsr ERR_Handler
>0190fa	53 74 6f 70 00				.text "Stop",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/while.asm

.0190ff					Command_WHILE:
.0190ff	20 f9 84	jsr $0184f9			jsr 	StackSavePosition			; save position into stack, but don't yet push.
.019102	20 e4 92	jsr $0192e4			jsr 	EvaluateInteger 			; calculate the while loop value.
.019105	a5 80		lda $80				lda 	XS_Mantissa+0				; check the result if zero
.019107	05 81		ora $81				ora 	XS_Mantissa+1
.019109	05 82		ora $82				ora 	XS_Mantissa+2
.01910b	05 83		ora $83				ora 	XS_Mantissa+3
.01910d	f0 06		beq $019115			beq 	_CWHSkip 					; if it is zero, then skip to WEND.
.01910f	a9 35		lda #$35			lda 	#(SMark_While << 4)+SourcePosSize
.019111	20 b2 84	jsr $0184b2			jsr 	StackPushFrame 				; push on stack
.019114	60		rts				rts
.019115					_CWHSkip:
.019115	a9 95		lda #$95			lda 	#token_Wend 				; look for the WEND token.
.019117	20 f3 83	jsr $0183f3			jsr 	StructureSearchSingle
.01911a	c8		iny				iny
.01911b	60		rts				rts
.01911c					Command_WEND:
.01911c	a9 30		lda #$30			lda 	#(SMark_While << 4)			; remove the frame
.01911e	20 c9 84	jsr $0184c9			jsr 	StackPopFrame
.019121	20 16 85	jsr $018516			jsr 	StackRestorePosition
.019124	80 d9		bra $0190ff			bra 	Command_WHILE 				; and do the while again.
.019126	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/repeat.asm

.019127					Command_REPEAT:
.019127	20 f9 84	jsr $0184f9			jsr 	StackSavePosition			; save position into stack
.01912a	a9 25		lda #$25			lda 	#(SMark_Repeat << 4)+SourcePosSize
.01912c	20 b2 84	jsr $0184b2			jsr 	StackPushFrame 				; push on stack
.01912f	60		rts				rts
.019130					Command_UNTIL:
.019130	a9 20		lda #$20			lda 	#(SMark_Repeat << 4)		; remove the frame
.019132	20 c9 84	jsr $0184c9			jsr 	StackPopFrame
.019135	20 e4 92	jsr $0192e4			jsr 	EvaluateInteger				; work out UNTIL
.019138	a5 80		lda $80				lda 	XS_Mantissa+0 				; check if zero.
.01913a	05 81		ora $81				ora 	XS_Mantissa+1
.01913c	05 82		ora $82				ora 	XS_Mantissa+2
.01913e	05 83		ora $83				ora 	XS_Mantissa+3
.019140	d0 08		bne $01914a			bne 	_CUTExit 					; if not, just exit
.019142	20 16 85	jsr $018516			jsr 	StackRestorePosition 		; otherwise loop round again.
.019145	a9 25		lda #$25			lda 	#(SMark_Repeat << 4)+SourcePosSize
.019147	20 b2 84	jsr $0184b2			jsr 	StackPushFrame 				; fix the stack back.
.01914a					_CUTExit:
.01914a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.01914b					EVESyntax:
.01914b	4c 4a 85	jmp $01854a			jmp 	SyntaxError
.01914e					EvaluateExpression:
.01914e	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.019150					EvaluateExpressionX:
.019150	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.019152					EvaluateExpressionXA:
.019152	48		pha				pha 								; save precedence on stack.
.019153	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019155	f0 f4		beq $01914b			beq 	EVESyntax 					; end of line, syntax error.
.019157	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.019159	b0 03		bcs $01915e			bcs 	_EVNotVariable
.01915b	4c 28 92	jmp $019228			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.01915e					_EVNotVariable:
.01915e	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.019160	90 e9		bcc $01914b			bcc 	EVESyntax
.019162	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.019164	b0 58		bcs $0191be			bcs 	_EVNotInteger
.019166	20 56 92	jsr $019256			jsr 	EvaluateGetInteger
.019169					_EVCheckDecimal:
.019169	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01916b	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.01916d	d0 05		bne $019174			bne 	_EVGotAtom 					; no, get atom.
.01916f					_EVIsDecimal:
.01916f	20 7c 92	jsr $01927c			jsr 	EVGetDecimal 				; extend to the decimal part.
.019172	80 00		bra $019174			bra 	_EVGotAtom 					; and continue to got atom.
.019174					_EVGotAtom:
.019174	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019176	10 44		bpl $0191bc			bpl 	_EVExitDrop 				; must be a token.
.019178	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.01917a	b0 40		bcs $0191bc			bcs 	_EVExitDrop
.01917c	68		pla				pla 								; get current precedence
.01917d	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.01917f	da		phx				phx 								; save X
.019180	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019182	aa		tax				tax 								; put in X
.019183	bf 2e 86 01	lda $01862e,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.019187	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.019189	fa		plx				plx 								; restore X
.01918a	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.01918c	90 2f		bcc $0191bd			bcc 	_EVExit 					; exit if too low.
.01918e	f0 2d		beq $0191bd			beq 	_EVExit 					; exit if equals
.019190	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.019192	48		pha				pha
.019193	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019195	48		pha				pha
.019196	c8		iny				iny
.019197	da		phx				phx 								; save current position
.019198	e8		inx				inx
.019199	e8		inx				inx
.01919a	e8		inx				inx
.01919b	e8		inx				inx
.01919c	e8		inx				inx
.01919d	e8		inx				inx
.01919e	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.0191a0	20 52 91	jsr $019152			jsr 	EvaluateExpressionXA 		; do the RHS.
.0191a3	fa		plx				plx 								; restore X
.0191a4	68		pla				pla 								; get the binary operator in A.
.0191a5					_EVCallA:
.0191a5	da		phx				phx 								; save X again
.0191a6	0a		asl a				asl 	a 							; double, lose the MSB.
.0191a7	aa		tax				tax									; put in X
.0191a8	bf dd 85 01	lda $0185dd,x			lda 	VectorTable,x 				; copy address into zGenPtr
.0191ac	8d 11 03	sta $0311			sta 	LocalVector+1
.0191af	bf de 85 01	lda $0185de,x			lda 	VectorTable+1,x
.0191b3	8d 12 03	sta $0312			sta 	LocalVector+2
.0191b6	fa		plx				plx 								; restore X
.0191b7	20 31 92	jsr $019231			jsr 	EVCallLocalVector
.0191ba	80 b8		bra $019174			bra 	_EVGotAtom 					; and loop back.
.0191bc					_EVExitDrop:
.0191bc	68		pla				pla
.0191bd					_EVExit:
.0191bd	60		rts				rts
.0191be					_EVNotInteger:
.0191be	c8		iny				iny
.0191bf	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.0191c1	d0 16		bne $0191d9			bne 	_EVNotMinus
.0191c3	20 c5 92	jsr $0192c5			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.0191c6	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.0191c8	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.0191ca	f0 05		beq $0191d1			beq 	_EVMinusFloat
.0191cc	20 a0 9e	jsr $019ea0			jsr 	IntegerNegateAlways 		; negation
.0191cf	80 a3		bra $019174			bra 	_EVGotAtom 					; and go back.
.0191d1					_EVMinusFloat:
.0191d1	b5 85		lda $85,x			lda 	XS_Type,x 					; invert the sign bit.
.0191d3	49 80		eor #$80			eor 	#$80
.0191d5	95 85		sta $85,x			sta 	XS_Type,x
.0191d7	80 9b		bra $019174			bra 	_EVGotAtom
.0191d9					_EVNotMinus:
.0191d9	c9 bd		cmp #$bd			cmp 	#token_lparen 				; is it left parenthesis
.0191db	d0 17		bne $0191f4			bne 	_EVNotParenthesis
.0191dd	20 50 91	jsr $019150			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.0191e0	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0191e2	c8		iny				iny
.0191e3	c9 be		cmp #$be			cmp 	#token_rparen 				; okay if right bracket.
.0191e5	f0 8d		beq $019174			beq 	_EVGotAtom
.0191e7	20 79 85	jsr $018579			jsr ERR_Handler
>0191ea	4d 69 73 73 69 6e 67 20			.text "Missing )",0
>0191f2	29 00
.0191f4					_EVNotParenthesis:
.0191f4	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.0191f6	d0 0c		bne $019204			bne 	_EVNotNot
.0191f8	20 c5 92	jsr $0192c5			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.0191fb	20 36 a3	jsr $01a336			jsr 	FPUToInteger 				; make it an integer - if possible.
.0191fe	20 aa 92	jsr $0192aa			jsr 	NotInteger 					; do the not calculation
.019201	4c 74 91	jmp $019174			jmp 	_EVGotAtom
.019204					_EVNotNot:
.019204	c9 fe		cmp #$fe			cmp 	#$FE
.019206	d0 12		bne $01921a			bne 	_EVNotString
.019208	20 b5 99	jsr $0199b5			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.01920b	a5 20		lda $20				lda 	zTempStr 					; copy address of string into mantissa
.01920d	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01920f	a5 21		lda $21				lda 	zTempStr+1
.019211	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019213	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.019215	95 85		sta $85,x			sta 	XS_Type,x
.019217	4c 74 91	jmp $019174			jmp 	_EVGotAtom
.01921a					_EVNotString:
.01921a	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.01921c	90 04		bcc $019222			bcc 	_EVBadElement
.01921e	c9 b7		cmp #$b7			cmp 	#lastUnaryFunction+1
.019220	90 03		bcc $019225			bcc 	_EVUnaryFunction
.019222					_EVBadElement:
.019222	4c 4a 85	jmp $01854a			jmp 	SyntaxError
.019225					_EVUnaryFunction:
.019225	4c a5 91	jmp $0191a5			jmp 	_EVCallA
.019228					_EVVariableHandler:
.019228	20 db 99	jsr $0199db			jsr 	VariableFind 				; locate a variable
.01922b	20 23 9d	jsr $019d23			jsr 	VariableGet 				; copy into memory.
.01922e	4c 74 91	jmp $019174			jmp 	_EVGotAtom 					; and go round.
.019231					EVCallLocalVector:
.019231	6c 11 03	jmp ($0311)			jmp 	(LocalVector+1)
.019234					EVShiftMantissaLeft6:
.019234	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.019236	95 84		sta $84,x			sta 	XS_Exponent,x
.019238	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01923a	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01923c	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01923e	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019240	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019242	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019244	a9 00		lda #$00			lda 	#0
.019246	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019248	20 4b 92	jsr $01924b			jsr 	_EVSMLShift 					; call it here to do it twice
.01924b					_EVSMLShift:
.01924b	56 84		lsr $84,x			lsr 	XS_Exponent,x
.01924d	76 83		ror $83,x			ror 	XS_Mantissa+3,x
.01924f	76 82		ror $82,x			ror 	XS_Mantissa+2,x
.019251	76 81		ror $81,x			ror 	XS_Mantissa+1,x
.019253	76 80		ror $80,x			ror 	XS_Mantissa+0,x
.019255	60		rts				rts
.019256					EvaluateGetInteger:
.019256	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019258	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.01925a	95 80		sta $80,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.01925c	a9 00		lda #$00			lda 	#0
.01925e	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019260	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019262	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019264	1a		inc a				inc 	a 							; set to type 1 (integer)
.019265	95 85		sta $85,x			sta 	XS_Type,x
.019267					_EVCheckNextInteger:
.019267	c8		iny				iny
.019268	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01926a	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.01926c	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.01926e	b0 0b		bcs $01927b			bcs 	_EVEndInteger
.019270	48		pha				pha 								; save it.
.019271	20 34 92	jsr $019234			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.019274	68		pla				pla
.019275	15 80		ora $80,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.019277	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019279	80 ec		bra $019267			bra 	_EVCheckNextInteger
.01927b					_EVEndInteger:
.01927b	60		rts				rts
.01927c					EVGetDecimal:
.01927c	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.01927e	8d 15 03	sta $0315			sta 	Num_Buffer
.019281	da		phx				phx
.019282	c8		iny				iny
.019283	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019285	c8		iny				iny
.019286	3a		dec a				dec 	a								; convert to a string length.
.019287	3a		dec a				dec 	a
.019288	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.01928a					_EVGDCopy:
.01928a	48		pha				pha 									; save count
.01928b	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01928d	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.019290	e8		inx				inx 									; forward ....
.019291	c8		iny				iny
.019292	68		pla				pla 									; get count
.019293	3a		dec a				dec 	a 								; until zero
.019294	d0 f4		bne $01928a			bne 	_EVGDCopy
.019296	9d 15 03	sta $0315,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.019299	fa		plx				plx 									; restore X
.01929a	a9 15		lda #$15			lda 	#Num_Buffer & $FF 				; set zGenPtr
.01929c	85 1e		sta $1e				sta 	zGenPtr
.01929e	a9 03		lda #$03			lda 	#Num_Buffer >> 8
.0192a0	85 1f		sta $1f				sta 	zGenPtr+1
.0192a2	5a		phy				phy 									; save Y
.0192a3	a0 00		ldy #$00			ldy 	#0 								; start position
.0192a5	20 f0 a4	jsr $01a4f0			jsr 	FPFromString 					; convert current
.0192a8	7a		ply				ply 									; restore Y
.0192a9	60		rts				rts
.0192aa					NotInteger:
.0192aa	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0192ac	49 ff		eor #$ff			eor 	#$FF
.0192ae	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0192b0	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0192b2	49 ff		eor #$ff			eor 	#$FF
.0192b4	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0192b6	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0192b8	49 ff		eor #$ff			eor 	#$FF
.0192ba	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0192bc	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.0192be	49 ff		eor #$ff			eor 	#$FF
.0192c0	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0192c2	60		rts				rts
.0192c3					EvaluateGetAtom:
.0192c3	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.0192c5					EvaluateGetAtomX:
.0192c5	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.0192c7	20 52 91	jsr $019152			jsr 	EvaluateExpressionXA
.0192ca	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.0192cc	29 0f		and #$0f			and 	#15
.0192ce	c9 02		cmp #$02			cmp 	#2
.0192d0	b0 01		bcs $0192d3			bcs 	EvaluateType
.0192d2	60		rts				rts
.0192d3					EvaluateType:
.0192d3	4c 5a 85	jmp $01855a			jmp 	TypeError
.0192d6					EvaluateNumber:
.0192d6	a2 00		ldx #$00			ldx 	#0
.0192d8					EvaluateNumberX:
.0192d8	20 50 91	jsr $019150			jsr 	EvaluateExpressionX
.0192db	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0/1
.0192dd	29 0f		and #$0f			and 	#15
.0192df	c9 02		cmp #$02			cmp 	#2
.0192e1	b0 f0		bcs $0192d3			bcs 	EvaluateType
.0192e3	60		rts				rts
.0192e4					EvaluateInteger:
.0192e4	a2 00		ldx #$00			ldx 	#0
.0192e6					EvaluateIntegerX:
.0192e6	20 d8 92	jsr $0192d8			jsr 	EvaluateNumberX
.0192e9	20 36 a3	jsr $01a336			jsr 	FPUToInteger
.0192ec	60		rts				rts
.0192ed					EvaluateString:
.0192ed	a2 00		ldx #$00			ldx 	#0
.0192ef					EvaluateStringX:
.0192ef	20 50 91	jsr $019150			jsr 	EvaluateExpressionX
.0192f2	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 2
.0192f4	29 0f		and #$0f			and 	#15
.0192f6	c9 02		cmp #$02			cmp 	#2
.0192f8	d0 d9		bne $0192d3			bne 	EvaluateType
.0192fa	b5 80		lda $80,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.0192fc	85 1e		sta $1e				sta 	zGenPtr
.0192fe	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019300	85 1f		sta $1f				sta 	zGenPtr+1
.019302	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.019303					BinaryOp_And:
.019303	20 57 93	jsr $019357			jsr 	BinaryMakeBothInteger
.019306	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.019308	35 86		and $86,x			and 	XS2_Mantissa+0,x
.01930a	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01930c	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.01930e	35 87		and $87,x			and 	XS2_Mantissa+1,x
.019310	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019312	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.019314	35 88		and $88,x			and 	XS2_Mantissa+2,x
.019316	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019318	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.01931a	35 89		and $89,x			and 	XS2_Mantissa+3,x
.01931c	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01931e	60		rts				rts
.01931f					BinaryOp_Or:
.01931f	20 57 93	jsr $019357			jsr 	BinaryMakeBothInteger
.019322	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.019324	15 86		ora $86,x			ora 	XS2_Mantissa+0,x
.019326	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019328	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.01932a	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.01932c	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01932e	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.019330	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.019332	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019334	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.019336	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.019338	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01933a	60		rts				rts
.01933b					BinaryOp_Eor:
.01933b					BinaryOp_Xor:
.01933b	20 57 93	jsr $019357			jsr 	BinaryMakeBothInteger
.01933e	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.019340	55 86		eor $86,x			eor 	XS2_Mantissa+0,x
.019342	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019344	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.019346	55 87		eor $87,x			eor 	XS2_Mantissa+1,x
.019348	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01934a	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.01934c	55 88		eor $88,x			eor 	XS2_Mantissa+2,x
.01934e	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019350	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.019352	55 89		eor $89,x			eor 	XS2_Mantissa+3,x
.019354	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019356	60		rts				rts
.019357					BinaryMakeBothInteger:
.019357	da		phx				phx 								; save X
.019358	e8		inx				inx
.019359	e8		inx				inx
.01935a	e8		inx				inx
.01935b	e8		inx				inx
.01935c	e8		inx				inx
.01935d	e8		inx				inx
.01935e	20 62 93	jsr $019362			jsr 	BinaryMakeInteger 			; convert to integer.
.019361	fa		plx				plx 								; restore X and fall through.
.019362					BinaryMakeInteger:
.019362	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.019364	29 0f		and #$0f			and 	#15 						; check type zero
.019366	f0 04		beq $01936c			beq 	_BMIConvert 				; if float convert to integer.
.019368	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.019369	90 04		bcc $01936f			bcc 	_BMIError
.01936b	60		rts				rts
.01936c					_BMIConvert:
.01936c	4c 36 a3	jmp $01a336			jmp 	FPUToInteger 				; convert to integer
.01936f					_BMIError:
.01936f	4c 5a 85	jmp $01855a			jmp 	TypeError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.019372					Binary_Equal:
.019372	20 bb 93	jsr $0193bb			jsr 	CompareValues 				; compare the values
.019375	09 00		ora #$00			ora 	#0 							; true if 0
.019377	f0 33		beq $0193ac			beq 	CCTrue
.019379	80 2d		bra $0193a8			bra 	CCFalse
.01937b					Binary_NotEqual:
.01937b	20 bb 93	jsr $0193bb			jsr 	CompareValues
.01937e	09 00		ora #$00			ora 	#0 							; true if -1 or 1
.019380	f0 26		beq $0193a8			beq 	CCFalse
.019382	80 28		bra $0193ac			bra 	CCTrue
.019384					Binary_Less:
.019384	20 bb 93	jsr $0193bb			jsr 	CompareValues
.019387	09 00		ora #$00			ora 	#0 							; true if -1
.019389	30 21		bmi $0193ac			bmi 	CCTrue
.01938b	80 1b		bra $0193a8			bra 	CCFalse
.01938d					Binary_LessEqual:
.01938d	20 bb 93	jsr $0193bb			jsr 	CompareValues
.019390	c9 01		cmp #$01			cmp 	#1 							; true if 0 or -1
.019392	d0 18		bne $0193ac			bne 	CCTrue
.019394	80 12		bra $0193a8			bra 	CCFalse
.019396					Binary_GreaterEqual:
.019396	20 bb 93	jsr $0193bb			jsr 	CompareValues
.019399	09 00		ora #$00			ora 	#0 							; true if 0 or 1
.01939b	10 0f		bpl $0193ac			bpl 	CCTrue
.01939d	80 09		bra $0193a8			bra 	CCFalse
.01939f					Binary_Greater:
.01939f	20 bb 93	jsr $0193bb			jsr 	CompareValues 				; true if 1
.0193a2	c9 01		cmp #$01			cmp 	#1
.0193a4	f0 06		beq $0193ac			beq 	CCTrue
.0193a6	80 00		bra $0193a8			bra 	CCFalse
.0193a8	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.0193aa	80 02		bra $0193ae			bra 	CCWrite
.0193ac	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.0193ae	95 80		sta $80,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.0193b0	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0193b2	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0193b4	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0193b6	a9 01		lda #$01			lda 	#1
.0193b8	95 85		sta $85,x			sta 	XS_Type,x 					; set type to integer whatever.
.0193ba	60		rts				rts
.0193bb					CompareValues:
.0193bb	b5 85		lda $85,x			lda 	XS_Type,x 					; and the types together
.0193bd	35 8b		and $8b,x			and 	XS2_Type,x
.0193bf	c9 02		cmp #$02			cmp 	#2 							; is it a string, then do the string
.0193c1	f0 11		beq $0193d4			beq 	_CVString					; comparison routine.
.0193c3	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.0193c5	35 8b		and $8b,x			and 	XS2_Type,x
.0193c7	4a		lsr a				lsr 	a 							; shift bit 0 into C
.0193c8	90 03		bcc $0193cd			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.0193ca	4c 16 94	jmp $019416			jmp 	CompareInteger32 							; so execute code at \1
.0193cd					_BCFloat:
.0193cd	20 ba 94	jsr $0194ba			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.0193d0	4c 2f a2	jmp $01a22f			jmp 	FPCompare 							; and execute code at \2
.0193d3	60		rts				rts
.0193d4					_CVString:
.0193d4	da		phx				phx 								; save XY
.0193d5	5a		phy				phy
.0193d6	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.0193d8	85 1a		sta $1a				sta		zLTemp1+0
.0193da	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0193dc	85 1b		sta $1b				sta 	zLTemp1+1
.0193de	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.0193e0	85 1c		sta $1c				sta 	zLTemp1+2
.0193e2	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.0193e4	85 1d		sta $1d				sta 	zLTemp1+3
.0193e6	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.0193e8	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.0193ea	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.0193ec	90 02		bcc $0193f0			bcc 	_CVCommon
.0193ee	b1 1c		lda ($1c),y			lda 	(zLTemp1+2),y
.0193f0					_CVCommon:
.0193f0	aa		tax				tax 								; put shorter string length in zero.
.0193f1	f0 0c		beq $0193ff			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.0193f3					_CVCompare:
.0193f3	c8		iny				iny 								; next character
.0193f4	b1 1a		lda ($1a),y			lda 	(zLTemp1),y 				; compare characters
.0193f6	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y 				; handle different values, < or >
.0193f8	90 13		bcc $01940d			bcc 	_CVReturnLess 				; <
.0193fa	d0 15		bne $019411			bne 	_CVReturnGreater 			; >
.0193fc	ca		dex				dex 								; until common length matched.
.0193fd	d0 f4		bne $0193f3			bne 	_CVCompare
.0193ff					_CVMatch:
.0193ff	a0 00		ldy #$00			ldy 	#0
.019401	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.019403	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.019405	90 06		bcc $01940d			bcc 	_CVReturnLess 				; <
.019407	d0 08		bne $019411			bne 	_CVReturnGreater 			; >
.019409	a9 00		lda #$00			lda 	#0
.01940b	80 06		bra $019413			bra 	_CVExit
.01940d					_CVReturnLess:
.01940d	a9 ff		lda #$ff			lda 	#$FF
.01940f	80 02		bra $019413			bra 	_CVExit
.019411					_CVReturnGreater:
.019411	a9 01		lda #$01			lda 	#$01
.019413					_CVExit:
.019413	7a		ply				ply
.019414	fa		plx				plx
.019415	60		rts				rts
.019416					CompareInteger32:
.019416	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.019418	49 80		eor #$80			eor 	#$80
.01941a	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01941c	b5 89		lda $89,x			lda 	XS2_Mantissa+3,x
.01941e	49 80		eor #$80			eor 	#$80
.019420	95 89		sta $89,x			sta 	XS2_Mantissa+3,x
.019422	20 a0 94	jsr $0194a0			jsr 	SubInteger32 				; subtraction
.019425	90 0d		bcc $019434			bcc 	_CI32Less 					; cc return -1
.019427	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check if zero
.019429	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.01942b	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01942d	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01942f	f0 02		beq $019433			beq 	_CI32Exit
.019431	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.019433					_CI32Exit:
.019433	60		rts				rts
.019434					_CI32Less:
.019434	a9 ff		lda #$ff			lda 	#$FF
.019436	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.019437					BinaryOp_Add:
.019437	b5 85		lda $85,x			lda 	XS_Type,x  					; and types together
.019439	35 8b		and $8b,x			and 	XS2_Type,x
.01943b	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.01943d	d0 11		bne $019450			bne 	_BOAString 					; so go do the string code.
.01943f	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.019441	35 8b		and $8b,x			and 	XS2_Type,x
.019443	4a		lsr a				lsr 	a 							; shift bit 0 into C
.019444	90 03		bcc $019449			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.019446	4c 86 94	jmp $019486			jmp 	AddInteger32 							; so execute code at \1
.019449					_BCFloat:
.019449	20 ba 94	jsr $0194ba			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.01944c	4c 0a a0	jmp $01a00a			jmp 	FPAdd 							; and execute code at \2
.01944f	60		rts				rts
.019450					_BOAString:
.019450	4c d4 94	jmp $0194d4			jmp 	ConcatenateString 			; concatenate two strings.
.019453					BinaryOp_Subtract:
.019453	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.019455	35 8b		and $8b,x			and 	XS2_Type,x
.019457	4a		lsr a				lsr 	a 							; shift bit 0 into C
.019458	90 03		bcc $01945d			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.01945a	4c a0 94	jmp $0194a0			jmp 	SubInteger32 							; so execute code at \1
.01945d					_BCFloat:
.01945d	20 ba 94	jsr $0194ba			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.019460	4c 02 a0	jmp $01a002			jmp 	FPSubtract 							; and execute code at \2
.019463	60		rts				rts
.019464					BinaryOp_Multiply:
.019464	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.019466	35 8b		and $8b,x			and 	XS2_Type,x
.019468	4a		lsr a				lsr 	a 							; shift bit 0 into C
.019469	90 03		bcc $01946e			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.01946b	4c db 9d	jmp $019ddb			jmp 	MulInteger32 							; so execute code at \1
.01946e					_BCFloat:
.01946e	20 ba 94	jsr $0194ba			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.019471	4c 31 a1	jmp $01a131			jmp 	FPMultiply 							; and execute code at \2
.019474	60		rts				rts
.019475					BinaryOp_Divide:
.019475	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.019477	35 8b		and $8b,x			and 	XS2_Type,x
.019479	4a		lsr a				lsr 	a 							; shift bit 0 into C
.01947a	90 03		bcc $01947f			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.01947c	4c 19 9e	jmp $019e19			jmp 	DivInteger32 							; so execute code at \1
.01947f					_BCFloat:
.01947f	20 ba 94	jsr $0194ba			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.019482	4c be a0	jmp $01a0be			jmp 	FPDivide 							; and execute code at \2
.019485	60		rts				rts
.019486					AddInteger32:
.019486	18		clc				clc
.019487	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019489	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.01948b	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01948d	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01948f	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.019491	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019493	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019495	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.019497	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019499	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01949b	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.01949d	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01949f	60		rts				rts
.0194a0					SubInteger32:
.0194a0	38		sec				sec
.0194a1	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0194a3	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.0194a5	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0194a7	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0194a9	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.0194ab	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0194ad	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0194af	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.0194b1	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0194b3	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.0194b5	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.0194b7	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0194b9	60		rts				rts
.0194ba					BinaryMakeBothFloat:
.0194ba	da		phx				phx 								; save X
.0194bb	e8		inx				inx
.0194bc	e8		inx				inx
.0194bd	e8		inx				inx
.0194be	e8		inx				inx
.0194bf	e8		inx				inx
.0194c0	e8		inx				inx
.0194c1	20 c5 94	jsr $0194c5			jsr 	BinaryMakeFloat 			; convert to float.
.0194c4	fa		plx				plx 								; restore X and fall through.
.0194c5					BinaryMakeFloat:
.0194c5	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.0194c7	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.0194c8	b0 04		bcs $0194ce			bcs 	_BMFConvert
.0194ca	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.0194cb	b0 04		bcs $0194d1			bcs 	_BMFError
.0194cd	60		rts				rts
.0194ce					_BMFConvert:
.0194ce	4c ea a2	jmp $01a2ea			jmp 	FPUToFloat 					; convert to float, only float builds of course
.0194d1					_BMFError:
.0194d1	4c 5a 85	jmp $01855a			jmp 	TypeError
.0194d4					ConcatenateString:
.0194d4	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.0194d6	85 1a		sta $1a				sta		zLTemp1+0
.0194d8	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0194da	85 1b		sta $1b				sta 	zLTemp1+1
.0194dc	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.0194de	85 1c		sta $1c				sta 	zLTemp1+2
.0194e0	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.0194e2	85 1d		sta $1d				sta 	zLTemp1+3
.0194e4	5a		phy				phy
.0194e5	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.0194e7	b1 1a		lda ($1a),y			lda 	(zlTemp1),y
.0194e9	71 1c		adc ($1c),y			adc 	(zlTemp1+2),y
.0194eb	7a		ply				ply
.0194ec	b0 33		bcs $019521			bcs 	_CSError					; check in range.
.0194ee	c9 fe		cmp #$fe			cmp 	#maxString+1
.0194f0	b0 2f		bcs $019521			bcs 	_CSError
.0194f2	20 7a 99	jsr $01997a			jsr 	AllocateTempString 			; store the result
.0194f5	20 0c 95	jsr $01950c			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.0194f8	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.0194fa	85 1a		sta $1a				sta 	zLTemp1
.0194fc	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.0194fe	85 1b		sta $1b				sta 	zLTemp1+1
.019500	20 0c 95	jsr $01950c			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.019503	a5 20		lda $20				lda 	zTempStr 					; point current to new string
.019505	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019507	a5 21		lda $21				lda 	zTempStr+1
.019509	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01950b	60		rts				rts
.01950c					_CSCopyString:
.01950c	da		phx				phx
.01950d	5a		phy				phy
.01950e	a0 00		ldy #$00			ldy 	#0 							; get length
.019510	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.019512	f0 0a		beq $01951e			beq 	_CSCSExit 					; if zero, exit immediately
.019514	aa		tax				tax 								; put in X which is the counter.
.019515					_CSCSLoop:
.019515	c8		iny				iny 								; get next char
.019516	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.019518	20 a5 99	jsr $0199a5			jsr		WriteTempString 			; copy out to new string
.01951b	ca		dex				dex 								; do whole string
.01951c	d0 f7		bne $019515			bne 	_CSCSLoop
.01951e					_CSCSExit:
.01951e	7a		ply				ply
.01951f	fa		plx				plx
.019520	60		rts				rts
.019521					_CSError:
.019521	20 79 85	jsr $018579			jsr ERR_Handler
>019524	53 74 72 69 6e 67 20 74			.text "String too long",0
>01952c	6f 6f 20 6c 6f 6e 67 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.019534					Unary_Sgn:
.019534	20 d8 92	jsr $0192d8			jsr 	EvaluateNumberX 			; get value
.019537	20 2d 99	jsr $01992d			jsr 	CheckNextRParen 			; check right bracket.
.01953a	20 58 95	jsr $019558			jsr 	GetSignCurrent 				; get sign.
.01953d	09 00		ora #$00			ora 	#0
.01953f	10 08		bpl $019549			bpl		UnarySetAInteger			; if 0,1 return that.
.019541	80 00		bra $019543			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.019543					UnarySetAMinus1:
.019543	a9 ff		lda #$ff			lda 	#$FF 						; put -1 in all four slots.
.019545	95 80		sta $80,x			sta 	XS_Mantissa,x
.019547	80 04		bra $01954d			bra 	UnarySetAFill
.019549					UnarySetAInteger:
.019549	95 80		sta $80,x			sta 	XS_Mantissa,x
.01954b	a9 00		lda #$00			lda 	#0
.01954d					UnarySetAFill:
.01954d	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01954f	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019551	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019553	a9 01		lda #$01			lda 	#1 							; set type to integer.
.019555	95 85		sta $85,x			sta 	XS_Type,x
.019557	60		rts				rts
.019558					GetSignCurrent:
.019558	b5 85		lda $85,x			lda 	XS_Type,x 					; identify type.
.01955a	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.01955b	90 15		bcc $019572			bcc 	_GSCFloat 					; if clear do the float code.
.01955d	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; if msb of integer set, it's negative
.01955f	30 0e		bmi $01956f			bmi 	_GSCMinus1
.019561	15 80		ora $80,x			ora 	XS_Mantissa+0,x
.019563	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019565	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019567	d0 03		bne $01956c			bne 	_GSCPlus1 					; check if zero by oring all together.
.019569					_GSCZero:
.019569	a9 00		lda #$00			lda 	#0
.01956b	60		rts				rts
.01956c					_GSCPlus1:
.01956c	a9 01		lda #$01			lda 	#$01
.01956e	60		rts				rts
.01956f					_GSCMinus1:
.01956f	a9 ff		lda #$ff			lda 	#$FF
.019571	60		rts				rts
.019572					_GSCFloat:
.019572	34 85		bit $85,x			bit 	XS_Type,x 					; check bits
.019574	70 f3		bvs $019569			bvs 	_GSCZero 					; if zero flag set return zero
.019576	30 f7		bmi $01956f			bmi 	_GSCMinus1 					; if sign set return -1
.019578	80 f2		bra $01956c			bra 	_GSCPlus1		 			; else return +1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.01957a					Unary_Abs:
.01957a	20 d8 92	jsr $0192d8			jsr 	EvaluateNumberX 			; get value
.01957d	20 2d 99	jsr $01992d			jsr 	CheckNextRParen 			; check right bracket.
.019580	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.019582	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.019584	f0 07		beq $01958d			beq 	_UAMinusFloat
.019586	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; check MSB of upper byte to see if negative
.019588	10 09		bpl $019593			bpl 	_UAExit
.01958a	4c a0 9e	jmp $019ea0			jmp 	IntegerNegateAlways 		; if so negate it.
.01958d					_UAMinusFloat:
.01958d	b5 85		lda $85,x			lda 	XS_Type,x 					; clear the sign bit.
.01958f	29 7f		and #$7f			and		#$7F
.019591	95 85		sta $85,x			sta 	XS_Type,x
.019593					_UAExit:
.019593	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.019594					Unary_Peek:
.019594	a9 01		lda #$01			lda 	#1 							; 1 byte
.019596	80 06		bra $01959e			bra 	UPMain
.019598					Unary_Deek:
.019598	a9 02		lda #$02			lda 	#2 							; 2 bytes
.01959a	80 02		bra $01959e			bra 	UPMain
.01959c					Unary_Leek:
.01959c	a9 04		lda #$04			lda 	#4 							; 4 bytes
.01959e					UPMain:
.01959e	48		pha				pha 								; save bytes to copy.
.01959f	20 e6 92	jsr $0192e6			jsr 	EvaluateIntegerX 			; numeric parameter, the address to xEEK
.0195a2	20 2d 99	jsr $01992d			jsr 	CheckNextRParen 			; right bracket.
.0195a5	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.0195a7	85 1a		sta $1a				sta 	zLTemp1
.0195a9	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0195ab	85 1b		sta $1b				sta 	zLTemp1+1
.0195ad	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0195af	85 1c		sta $1c				sta 	zLTemp1+2
.0195b1	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.0195b3	85 1d		sta $1d				sta 	zLTemp1+3
.0195b5	a9 00		lda #$00			lda 	#0 							; clear target area, which might get
.0195b7	95 80		sta $80,x			sta 	XS_Mantissa+0,x 			; 1,2 or 4 bytes.
.0195b9	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0195bb	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0195bd	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0195bf	68		pla				pla 								; restore bytes to copy
.0195c0	da		phx				phx 								; save XY
.0195c1	5a		phy				phy
.0195c2	20 af 98	jsr $0198af			jsr 	MemRead 					; read the bytes in, processor dependent routine.
.0195c5	7a		ply				ply 								; restore and exit
.0195c6	fa		plx				plx
.0195c7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/pos.asm

.0195c8					Unary_Pos:
.0195c8	20 d8 92	jsr $0192d8			jsr 	EvaluateNumberX 			; get value, which is a dummy.
.0195cb	20 2d 99	jsr $01992d			jsr 	CheckNextRParen 			; check right bracket.
.0195ce	20 43 85	jsr $018543			jsr 	VIOCharGetPosition 			; get the position
.0195d1	4c 49 95	jmp $019549			jmp		UnarySetAInteger			; and return that.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.0195d4					Unary_Mod:
.0195d4	20 fc 95	jsr $0195fc			jsr 	_UMParameter 				; first parameter, get |param|
.0195d7	20 35 99	jsr $019935			jsr 	CheckNextComma
.0195da	da		phx				phx 								; second parameter, get |param|
.0195db	e8		inx				inx
.0195dc	e8		inx				inx
.0195dd	e8		inx				inx
.0195de	e8		inx				inx
.0195df	e8		inx				inx
.0195e0	e8		inx				inx
.0195e1	20 fc 95	jsr $0195fc			jsr 	_UMParameter
.0195e4	fa		plx				plx
.0195e5	20 2d 99	jsr $01992d			jsr 	CheckNextRParen
.0195e8	20 19 9e	jsr $019e19			jsr 	DivInteger32 				; divide, which handily leaves ....
.0195eb	a5 1a		lda $1a				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.0195ed	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0195ef	a5 1b		lda $1b				lda 	zLTemp1+1
.0195f1	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0195f3	a5 1c		lda $1c				lda 	zLTemp1+2
.0195f5	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0195f7	a5 1d		lda $1d				lda 	zLTemp1+3
.0195f9	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0195fb	60		rts				rts
.0195fc					_UMParameter:
.0195fc	20 e6 92	jsr $0192e6			jsr 	EvaluateIntegerX 			; get value
.0195ff	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; absolute value
.019601	10 03		bpl $019606			bpl 	_UMNotSigned
.019603	20 a0 9e	jsr $019ea0			jsr 	IntegerNegateAlways
.019606					_UMNotSigned:
.019606	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.019607					Unary_Usr:
.019607	20 d8 92	jsr $0192d8			jsr 	EvaluateNumberX 			; numeric parameter
.01960a	20 2d 99	jsr $01992d			jsr 	CheckNextRParen 			; right bracket.
.01960d	da		phx				phx 								; save XY
.01960e	5a		phy				phy
.01960f	22 0c 03 00	jsl $00030c			jsl 	UserVector 					; with the parameter in the base mantissa
.019613	7a		ply				ply 								; restore YX and exit with whatever the
.019614	fa		plx				plx 								; routine called has chosen to do with it.
.019615	60		rts				rts
.019616					USRDefault:
.019616	20 79 85	jsr $018579			jsr ERR_Handler
>019619	4e 6f 20 55 53 52 20 76			.text "No USR vector.",0
>019621	65 63 74 6f 72 2e 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.019628					Unary_Val:
.019628	20 ef 92	jsr $0192ef			jsr 	EvaluateStringX 			; get string
.01962b	20 2d 99	jsr $01992d			jsr 	CheckNextRParen 			; check right bracket.
.01962e	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.019630	85 1e		sta $1e				sta 	zGenPtr
.019632	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019634	85 1f		sta $1f				sta 	zGenPtr+1
.019636	5a		phy				phy
.019637	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.019639	b1 1e		lda ($1e),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.01963b	f0 56		beq $019693			beq 	_UVBadNumber
.01963d	48		pha				pha 								; save length.
.01963e	1a		inc a				inc 	a 							; one for the length, one for the terminator
.01963f	1a		inc a				inc 	a 							; null
.019640	20 7a 99	jsr $01997a			jsr 	AllocateTempString
.019643	c8		iny				iny 								; move to the next.
.019644	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get character
.019646	49 2d		eor #$2d			eor 	#"-"						; zero if minus sign
.019648	8d a0 03	sta $03a0			sta 	ValSign 					; store this in the val temp.
.01964b	d0 06		bne $019653			bne 	_UVNotMinus
.01964d	c8		iny				iny 								; skip over it.
.01964e	68		pla				pla 								; decrement character count.
.01964f	3a		dec a				dec 	a
.019650	f0 41		beq $019693			beq 	_UVBadNumber 				; if there was only a '-' that's an error.
.019652	48		pha				pha
.019653					_UVNotMinus:
.019653	68		pla				pla 								; this is the count.
.019654	48		pha		_UVCopy:pha									; copy into new temp string which is ASCIIZ
.019655	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.019657	c8		iny				iny
.019658	20 a5 99	jsr $0199a5			jsr 	WriteTempString
.01965b	68		pla				pla
.01965c	3a		dec a				dec 	a
.01965d	d0 f5		bne $019654			bne 	_UVCopy 					; when finished copying A = 0 so
.01965f	20 a5 99	jsr $0199a5			jsr 	WriteTempString 			; make it ASCIIZ
.019662	18		clc				clc
.019663	a5 20		lda $20				lda 	zTempStr 					; tempstring +1 => genptr
.019665	69 01		adc #$01			adc 	#1
.019667	85 1e		sta $1e				sta 	zGenPtr
.019669	a5 21		lda $21				lda 	zTempStr+1
.01966b	69 00		adc #$00			adc 	#0
.01966d	85 1f		sta $1f				sta 	zGenPtr+1
.01966f	18		clc				clc
.019670	20 72 9f	jsr $019f72			jsr 	IntFromString 				; first bit.
.019673	b0 1e		bcs $019693			bcs 	_UVBadNumber
.019675	20 f0 a4	jsr $01a4f0			jsr 	FPFromString				; try for a float part - if float basic.
.019678	ad a0 03	lda $03a0			lda 	ValSign 					; was it negative
.01967b	d0 10		bne $01968d			bne 	_UVNotNegative
.01967d	b5 85		lda $85,x			lda 	XS_Type,x 					; check if integer
.01967f	4a		lsr a				lsr 	a
.019680	b0 08		bcs $01968a			bcs 	_UVInteger
.019682	b5 85		lda $85,x			lda 	XS_Type,x 					; set sign bit
.019684	09 80		ora #$80			ora 	#$80
.019686	95 85		sta $85,x			sta 	XS_Type,x
.019688	80 03		bra $01968d			bra 	_UVNotNegative
.01968a					_UVInteger:
.01968a	20 a0 9e	jsr $019ea0			jsr 	IntegerNegateAlways 		; sign it.
.01968d					_UVNotNegative:
.01968d	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; used everything up ?
.01968f	d0 02		bne $019693			bne 	_UVBadNumber
.019691	7a		ply				ply
.019692	60		rts				rts
.019693					_UVBadNumber:
.019693	4c 68 85	jmp $018568			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.019696					Unary_Str:
.019696	20 d8 92	jsr $0192d8			jsr 	EvaluateNumberX 			; numeric parameter
.019699	20 2d 99	jsr $01992d			jsr 	CheckNextRParen 			; right bracket.
.01969c	a9 00		lda #$00			lda 	#0 							; reset buffer index
.01969e	8d 14 03	sta $0314			sta 	NumBufX
.0196a1	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.0196a3	4a		lsr a				lsr 	a 							; bit 0 identifies an integer.
.0196a4	b0 05		bcs $0196ab			bcs 	_USInt 						; if msb set do as integer
.0196a6	20 35 a4	jsr $01a435			jsr 	FPToString 					; call fp to str otherwise
.0196a9	80 03		bra $0196ae			bra 	_USDuplicate
.0196ab	20 bd 9e	jsr $019ebd	_USInt:	jsr 	IntToString					; call int to str.
.0196ae					_USDuplicate:
.0196ae	ad 14 03	lda $0314			lda 	NumBufX 					; chars in buffer
.0196b1	1a		inc a				inc 	a 							; one more for length
.0196b2	20 7a 99	jsr $01997a			jsr 	AllocateTempString 			; allocate space for it.
.0196b5	5a		phy				phy 								; save Y
.0196b6	a0 00		ldy #$00			ldy 	#0 							; start copying
.0196b8	b9 15 03	lda $0315,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.0196bb	20 a5 99	jsr $0199a5			jsr 	WriteTempString
.0196be	c8		iny				iny
.0196bf	cc 14 03	cpy $0314			cpy 	NumBufX 					; done the lot
.0196c2	d0 f4		bne $0196b8			bne 	_USCopy
.0196c4	7a		ply				ply 								; restore Y
.0196c5	4c a2 98	jmp $0198a2			jmp 	UnaryReturnTempStr 			; return newly created temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.0196c8					Unary_Asc:
.0196c8	20 ef 92	jsr $0192ef			jsr 	EvaluateStringX 			; string parameter
.0196cb	20 2d 99	jsr $01992d			jsr 	CheckNextRParen 			; right bracket.
.0196ce	5a		phy				phy 								; get the string length
.0196cf	a0 00		ldy #$00			ldy 	#0
.0196d1	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.0196d3	f0 07		beq $0196dc			beq 	_UAIllegal 					; must be at least one character, 0 => error
.0196d5	c8		iny				iny
.0196d6	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; read the first character
.0196d8	7a		ply				ply
.0196d9	4c 49 95	jmp $019549			jmp 	UnarySetAInteger 			; return that as an integer 0-255.
.0196dc					_UAIllegal:
.0196dc	4c 68 85	jmp $018568			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.0196df					Unary_Len:
.0196df	20 ef 92	jsr $0192ef			jsr 	EvaluateStringX 			; string parameter
.0196e2	20 2d 99	jsr $01992d			jsr 	CheckNextRParen 			; right bracket.
.0196e5	5a		phy				phy 								; get the string length
.0196e6	a0 00		ldy #$00			ldy 	#0
.0196e8	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.0196ea	7a		ply				ply
.0196eb	4c 49 95	jmp $019549			jmp 	UnarySetAInteger 			; return as an integer.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.0196ee					Unary_Mid:
.0196ee	20 ef 92	jsr $0192ef			jsr 	EvaluateStringX 				; get string.
.0196f1	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.0196f3	48		pha				pha
.0196f4	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0196f6	48		pha				pha
.0196f7	20 35 99	jsr $019935			jsr 	CheckNextComma 					; skip comma
.0196fa	20 83 97	jsr $019783			jsr 	SLIByteParameter 				; get a byte parameter (start)
.0196fd	48		pha				pha 									; and push it.
.0196fe	20 35 99	jsr $019935			jsr 	CheckNextComma 					; skip comma
.019701	20 83 97	jsr $019783			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.019704	48		pha				pha 									; and push it.
.019705	80 41		bra $019748			bra 	SLIProcess
.019707					Unary_Left:
.019707	20 ef 92	jsr $0192ef			jsr 	EvaluateStringX 				; get string.
.01970a	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.01970c	48		pha				pha
.01970d	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01970f	48		pha				pha
.019710	a9 01		lda #$01			lda 	#1 								; push start position (1)
.019712	48		pha				pha
.019713	20 35 99	jsr $019935			jsr 	CheckNextComma 					; skip comma
.019716	20 83 97	jsr $019783			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.019719	48		pha				pha 									; and push it.
.01971a	80 2c		bra $019748			bra 	SLIProcess
.01971c					Unary_Right:
.01971c	20 ef 92	jsr $0192ef			jsr 	EvaluateStringX 				; get string.
.01971f	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.019721	48		pha				pha
.019722	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019724	48		pha				pha
.019725	da		phx				phx 									; get the string length and push on stack.
.019726	a2 00		ldx #$00			ldx 	#0
.019728	a1 1e		lda ($1e,x)			lda		(zGenPtr,x)
.01972a	fa		plx				plx
.01972b	48		pha				pha
.01972c	20 35 99	jsr $019935			jsr 	CheckNextComma 					; skip comma
.01972f	20 83 97	jsr $019783			jsr 	SLIByteParameter 				; get a byte parameter.
.019732	8d 9e 03	sta $039e			sta 	SignCount 						; save in temporary.
.019735	68		pla				pla 									; restore string length.
.019736	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.019737	38		sec				sec
.019738	ed 9e 03	sbc $039e			sbc 	SignCount 						; subtract characters needed, gives start position.
.01973b	f0 02		beq $01973f			beq 	_URStart 						; if <= 0 start from 1.
.01973d	10 02		bpl $019741			bpl 	_UROkay
.01973f					_URStart:
.01973f	a9 01		lda #$01			lda 	#1
.019741					_UROkay:
.019741	48		pha				pha 									; push start
.019742	ad 9e 03	lda $039e			lda 	SignCount 						; push count of characters
.019745	48		pha				pha
.019746	80 00		bra $019748			bra 	SLIProcess
.019748					SLIProcess:
.019748	20 2d 99	jsr $01992d			jsr 	CheckNextRParen 				; closing right bracket.
.01974b	68		pla				pla
.01974c	8d a2 03	sta $03a2			sta 	SliceCount 						; count in signcount
.01974f	1a		inc a				inc 	a 								; allocate +1 for it.
.019750	20 7a 99	jsr $01997a			jsr 	AllocateTempString
.019753	68		pla				pla 									; pop start number off stack.
.019754	f0 3b		beq $019791			beq 	SLIError 						; exit if start = 0
.019756	8d a1 03	sta $03a1			sta 	SliceStart
.019759	68		pla				pla  									; pop string address.
.01975a	85 1f		sta $1f				sta 	zGenPtr+1
.01975c	68		pla				pla
.01975d	85 1e		sta $1e				sta 	zGenPtr
.01975f	da		phx				phx
.019760	5a		phy				phy
.019761	a2 00		ldx #$00			ldx 	#0 								; point to string length.
.019763	ac a1 03	ldy $03a1			ldy 	SliceStart 						; start of the string (+1 for count)
.019766					_SLICopy:
.019766	ad a2 03	lda $03a2			lda 	SliceCount 						; done count characters
.019769	f0 12		beq $01977d			beq 	_SLIExit
.01976b	ce a2 03	dec $03a2			dec 	SliceCount
.01976e	98		tya				tya 									; index of character
.01976f	c1 1e		cmp ($1e,x)			cmp 	(zGenPtr,x)						; compare against length
.019771	f0 02		beq $019775			beq 	_SLIOk 							; if equal, okay.
.019773	b0 08		bcs $01977d			bcs 	_SLIExit 						; if past end, then exit.
.019775	b1 1e		lda ($1e),y	_SLIOk:	lda 	(zGenPtr),y 					; copy one character
.019777	c8		iny				iny
.019778	20 a5 99	jsr $0199a5			jsr 	WriteTempString
.01977b	80 e9		bra $019766			bra 	_SLICopy 						; go round till copied characters
.01977d					_SLIExit:
.01977d	7a		ply				ply 									; restore YX
.01977e	fa		plx				plx
.01977f	4c a2 98	jmp $0198a2			jmp 	UnaryReturnTempStr 				; return new temporary string.
.019782	ea		nop				nop
.019783					SLIByteParameter:
.019783	20 e6 92	jsr $0192e6			jsr 	EvaluateIntegerX 				; get integer
.019786	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.019788	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01978a	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01978c	d0 03		bne $019791			bne 	SLIError
.01978e	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019790	60		rts				rts
.019791					SLIError:
.019791	4c 68 85	jmp $018568			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.019794					Unary_Hex:
.019794	20 e6 92	jsr $0192e6			jsr 	EvaluateIntegerX 			; numeric parameter
.019797	20 2d 99	jsr $01992d			jsr 	CheckNextRParen 			; right bracket.
.01979a	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.01979c	20 7a 99	jsr $01997a			jsr 	AllocateTempString			; allocate string space
.01979f	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.0197a1	20 c5 97	jsr $0197c5			jsr 	_UHConvert
.0197a4	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0197a6	20 c5 97	jsr $0197c5			jsr 	_UHConvert
.0197a9	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0197ab	20 c5 97	jsr $0197c5			jsr 	_UHConvert
.0197ae	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0197b0	20 c5 97	jsr $0197c5			jsr 	_UHConvert
.0197b3	5a		phy				phy 								; get length of new string
.0197b4	a0 00		ldy #$00			ldy 	#0
.0197b6	b1 20		lda ($20),y			lda 	(zTempStr),y
.0197b8	7a		ply				ply
.0197b9	c9 00		cmp #$00			cmp 	#0 							; if it was non zero okay
.0197bb	d0 05		bne $0197c2			bne 	_UHExit 					; otherwise suppressed all leading zeros !
.0197bd	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.0197bf	20 a5 99	jsr $0199a5			jsr 	WriteTempString
.0197c2					_UHExit:
.0197c2	4c a2 98	jmp $0198a2			jmp 	UnaryReturnTempStr 			; return new temporary string.
.0197c5					_UHConvert:
.0197c5	48		pha				pha
.0197c6	4a		lsr a				lsr 	a 							; do MSB
.0197c7	4a		lsr a				lsr 	a
.0197c8	4a		lsr a				lsr 	a
.0197c9	4a		lsr a				lsr 	a
.0197ca	20 ce 97	jsr $0197ce			jsr 	_UHNibble
.0197cd	68		pla				pla 								; do LSB
.0197ce					_UHNibble:
.0197ce	29 0f		and #$0f			and 	#15 						; get nibble
.0197d0	d0 0c		bne $0197de			bne 	_UHNonZero 					; if not zero, write it out anyway.
.0197d2	5a		phy				phy									; get the length
.0197d3	a0 00		ldy #$00			ldy 	#0
.0197d5	b1 20		lda ($20),y			lda 	(zTempStr),y
.0197d7	7a		ply				ply
.0197d8	c9 00		cmp #$00			cmp 	#0 							; length = 0 => suppress leading zeros.
.0197da	f0 0d		beq $0197e9			beq 	_UHExit2
.0197dc	a9 00		lda #$00			lda 	#0 							; length > 0, so can't suppress any more.
.0197de					_UHNonZero:
.0197de	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.0197e0	90 02		bcc $0197e4			bcc 	_UHDigit
.0197e2	69 06		adc #$06			adc 	#7-1
.0197e4					_UHDigit:
.0197e4	69 30		adc #$30			adc 	#48
.0197e6	20 a5 99	jsr $0199a5			jsr 	WriteTempString				; output to temp string.
.0197e9					_UHExit2:
.0197e9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.0197ea					Unary_Dec:
.0197ea	20 ef 92	jsr $0192ef			jsr 	EvaluateStringX 			; string parameter
.0197ed	20 2d 99	jsr $01992d			jsr 	CheckNextRParen 			; right bracket.
.0197f0	5a		phy				phy
.0197f1	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.0197f3	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.0197f5	f0 43		beq $01983a			beq 	_UDFail 					; must fail if zero.
.0197f7	8d 9e 03	sta $039e			sta 	SignCount 					; use SignCount as a counter of chars to process.
.0197fa	a9 00		lda #$00			lda 	#0 							; set result to zero
.0197fc	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0197fe	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019800	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019802	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019804	a9 01		lda #$01			lda 	#1 							; set type to integer.
.019806	95 85		sta $85,x			sta 	XS_Type,x
.019808					_UDConvertLoop:
.019808	5a		phy				phy 								; shift mantissa left 4
.019809	a0 04		ldy #$04			ldy 	#4
.01980b					_UDShift:
.01980b	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.01980d	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.01980f	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.019811	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.019813	88		dey				dey
.019814	d0 f5		bne $01980b			bne 	_UDShift
.019816	7a		ply				ply
.019817	c8		iny				iny 								; next character
.019818	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; fetch it.
.01981a	20 3d 98	jsr $01983d			jsr 	ConvertUpper 				; convert to U/C
.01981d	c9 30		cmp #$30			cmp 	#"0" 						; range 0-9
.01981f	90 19		bcc $01983a			bcc 	_UDFail
.019821	c9 3a		cmp #$3a			cmp 	#"9"+1
.019823	90 08		bcc $01982d			bcc 	_UDOkay
.019825	e9 37		sbc #$37			sbc 	#7+"0" 						; A-F fudge
.019827	90 11		bcc $01983a			bcc 	_UDFail 					; fails if between 9 and @
.019829	c9 10		cmp #$10			cmp 	#16 						; must be < 16 as hexadecimal.
.01982b	b0 0d		bcs $01983a			bcs 	_UDFail
.01982d					_UDOkay:
.01982d	29 0f		and #$0f			and 	#15 						; nibble only
.01982f	15 80		ora $80,x			ora 	XS_Mantissa+0,x 			; OR into the bottom byte.
.019831	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019833	ce 9e 03	dec $039e			dec 	SignCount 					; do it for each character in the string.
.019836	d0 d0		bne $019808			bne 	_UDConvertLoop
.019838	7a		ply				ply
.019839	60		rts				rts
.01983a					_UDFail:
.01983a	4c 68 85	jmp $018568			jmp 	BadParamError
.01983d					ConvertUpper:
.01983d	c9 61		cmp #$61			cmp 	#"a"
.01983f	90 07		bcc $019848			bcc 	_CUExit
.019841	c9 7b		cmp #$7b			cmp 	#"z"+1
.019843	b0 03		bcs $019848			bcs 	_CUExit
.019845	38		sec				sec
.019846	e9 20		sbc #$20			sbc 	#32
.019848	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.019849					Unary_Chr:
.019849	20 e6 92	jsr $0192e6			jsr 	EvaluateIntegerX			; numeric parameter which is the character we want
.01984c	20 2d 99	jsr $01992d			jsr 	CheckNextRParen 			; right bracket.
.01984f	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.019851	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019853	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019855	d0 0d		bne $019864			bne 	_UCChar
.019857	a9 02		lda #$02			lda 	#1+1 						; one character string. 2 bytes - size+char
.019859	20 7a 99	jsr $01997a			jsr 	AllocateTempString			; allocate it.
.01985c	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.01985e	20 a5 99	jsr $0199a5			jsr 	WriteTempString
.019861	4c a2 98	jmp $0198a2			jmp 	UnaryReturnTempStr 			; and return that string.
.019864					_UCChar:
.019864	4c 68 85	jmp $018568			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.019867					Unary_Spc:
.019867	20 83 97	jsr $019783			jsr 	SLIByteParameter 			; check space.
.01986a	20 2d 99	jsr $01992d			jsr 	CheckNextRParen
.01986d	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01986f					UnarySpcCreate:
.01986f	c9 fe		cmp #$fe			cmp 	#maxString+1
.019871	b0 14		bcs $019887			bcs 	_USSize
.019873	48		pha				pha 								; save length
.019874	1a		inc a				inc 	a 							; allocate one more.
.019875	20 7a 99	jsr $01997a			jsr 	AllocateTempString
.019878	68		pla				pla 								; get length
.019879	f0 27		beq $0198a2			beq 	UnaryReturnTempStr 			; return the current temp string
.01987b					_USLoop:
.01987b	48		pha				pha
.01987c	a9 20		lda #$20			lda 	#" "
.01987e	20 a5 99	jsr $0199a5			jsr 	WriteTempString
.019881	68		pla				pla
.019882	3a		dec a				dec 	a
.019883	d0 f6		bne $01987b			bne 	_USLoop
.019885	80 1b		bra $0198a2			bra 	UnaryReturnTempStr
.019887					_USSize:
.019887	4c 68 85	jmp $018568			jmp 	BadParamError
.01988a					Unary_Tab:
.01988a	a2 00		ldx #$00			ldx 	#0 							; required TAB position.
.01988c	20 83 97	jsr $019783			jsr 	SLIByteParameter
.01988f	20 2d 99	jsr $01992d			jsr 	CheckNextRParen
.019892	20 43 85	jsr $018543			jsr 	VIOCharGetPosition 			; were are we ?
.019895	85 10		sta $10				sta 	zTemp1
.019897	38		sec				sec
.019898	a5 80		lda $80				lda 	XS_Mantissa+0 				; return chars required.
.01989a	e5 10		sbc $10				sbc 	zTemp1
.01989c	b0 d1		bcs $01986f			bcs 	UnarySpcCreate
.01989e	a9 00		lda #$00			lda 	#0
.0198a0	80 cd		bra $01986f			bra 	UnarySpcCreate
.0198a2					UnaryReturnTempStr:
.0198a2	a5 20		lda $20				lda 	zTempStr 					; copy temp string addr -> mantissa
.0198a4	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0198a6	a5 21		lda $21				lda 	zTempStr+1
.0198a8	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0198aa	a9 02		lda #$02			lda 	#2 							; set type to string
.0198ac	95 85		sta $85,x			sta 	XS_Type,x
.0198ae	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/65816.asm

.0198af					MemRead:
.0198af	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.0198b2	a0 00		ldy #$00			ldy 	#0 							; start from here
.0198b4	b7 1a		lda [$1a],y	_MLoop1:lda 	[zlTemp1],y 				; read the long address
.0198b6	95 80		sta $80,x			sta 	XS_Mantissa,x 				; copy into mantissa
.0198b8	c8		iny				iny 								; next to copy
.0198b9	e8		inx				inx
.0198ba	cc 9e 03	cpy $039e			cpy 	SignCount 					; do required # of bytes.
.0198bd	d0 f5		bne $0198b4			bne 	_MLoop1
.0198bf	60		rts				rts
.0198c0					MemWrite:
.0198c0	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.0198c3	a0 00		ldy #$00			ldy 	#0 							; start from here
.0198c5	b5 80		lda $80,x	_MLoop1:lda 	XS_Mantissa,x 				; read mantisssa
.0198c7	97 1a		sta [$1a],y			sta 	[zlTemp1],y 				; write it out
.0198c9	c8		iny				iny 								; next to copy
.0198ca	e8		inx				inx
.0198cb	cc 9e 03	cpy $039e			cpy 	SignCount 					; do required # of bytes.
.0198ce	d0 f5		bne $0198c5			bne 	_MLoop1
.0198d0	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/programend.asm

.0198d1					UpdateProgramEnd:
.0198d1	a9 00		lda #$00			lda 	#BasicProgram & $FF
.0198d3	85 16		sta $16				sta 	zCodePtr+0
.0198d5	a9 10		lda #$10			lda 	#BasicProgram >> 8
.0198d7	85 17		sta $17				sta 	zCodePtr+1
.0198d9	a9 00		lda #$00			lda 	#0
.0198db	85 18		sta $18				sta 	zCodePtr+2
.0198dd	85 19		sta $19				sta 	zCodePtr+3
.0198df	a0 03		ldy #$03			ldy 	#3
.0198e1					_UPDLoop:
.0198e1	a0 00		ldy #$00			ldy 	#0
.0198e3	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0198e5	c9 00		cmp #$00			cmp 	#0 							; end if offset is zero.
.0198e7	f0 0f		beq $0198f8			beq 	_UPDFoundEnd
.0198e9	a0 00		ldy #$00			ldy 	#0 							; point to offset
.0198eb	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.0198ed	18		clc				clc
.0198ee	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.0198f0	85 16		sta $16				sta 	zCodePtr
.0198f2	90 02		bcc $0198f6			bcc 	_SNLNoCarry
.0198f4	e6 17		inc $17				inc 	zCodePtr+1
.0198f6					_SNLNoCarry:
.0198f6	80 e9		bra $0198e1			bra 	_UPDLoop
.0198f8					_UPDFoundEnd:
.0198f8	18		clc				clc 								; end of program 2 on.
.0198f9	a5 16		lda $16				lda 	zCodePtr
.0198fb	69 02		adc #$02			adc 	#2
.0198fd	8d 04 03	sta $0304			sta 	endOfProgram
.019900	a5 17		lda $17				lda 	zCodePtr+1
.019902	69 00		adc #$00			adc 	#0
.019904	8d 05 03	sta $0305			sta 	endOfProgram+1
.019907	a5 18		lda $18				lda 	zCodePtr+2
.019909	69 00		adc #$00			adc		#0
.01990b	8d 06 03	sta $0306			sta 	endOfProgram+2
.01990e	a5 19		lda $19				lda 	zCodePtr+3
.019910	69 00		adc #$00			adc 	#0
.019912	8d 07 03	sta $0307			sta 	endOfProgram+3
.019915	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.019916					CheckNextToken:
.019916	d7 16		cmp [$16],y			cmp 	[zCodePtr],y
.019918	d0 02		bne $01991c			bne 	CTFail 						; no, then fail
.01991a	c8		iny				iny
.01991b	60		rts				rts
.01991c					CTFail:
.01991c	20 79 85	jsr $018579			jsr ERR_Handler
>01991f	4d 69 73 73 69 6e 67 20			.text "Missing token",0
>019927	74 6f 6b 65 6e 00
.01992d					CheckNextRParen:
.01992d	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01992f	c9 be		cmp #$be			cmp 	#token_rparen
.019931	d0 e9		bne $01991c			bne 	CTFail
.019933	c8		iny				iny
.019934	60		rts				rts
.019935					CheckNextComma:
.019935	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019937	c9 bf		cmp #$bf			cmp 	#token_comma
.019939	d0 e1		bne $01991c			bne 	CTFail
.01993b	c8		iny				iny
.01993c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/concrete.asm

.01993d					StringConcrete:
.01993d	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; save source to zTemp1
.01993f	85 10		sta $10				sta 	zTemp1
.019941	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019943	85 11		sta $11				sta 	zTemp1+1
.019945	a0 00		ldy #$00			ldy 	#0 							; empty string, return default empty
.019947	b1 10		lda ($10),y			lda 	(zTemp1),y
.019949	f0 26		beq $019971			beq		_SCEmpty
.01994b	18		clc				clc 								; from the string pointer
.01994c	ad 00 03	lda $0300			lda 	StringPtr 					; and put in zTemp2 as well
.01994f	f1 10		sbc ($10),y			sbc 	(zTemp1),y
.019951	8d 00 03	sta $0300			sta 	StringPtr
.019954	85 12		sta $12				sta 	zTemp2
.019956	ad 01 03	lda $0301			lda 	StringPtr+1
.019959	e9 00		sbc #$00			sbc 	#0
.01995b	8d 01 03	sta $0301			sta 	StringPtr+1
.01995e	85 13		sta $13				sta 	zTemp2+1
.019960	b1 10		lda ($10),y			lda 	(zTemp1),y 					; length add one for count
.019962	1a		inc a				inc 	a
.019963	aa		tax				tax
.019964	b1 10		lda ($10),y	_SCCopy:lda 	(zTemp1),y 					; copy whole thing including length
.019966	91 12		sta ($12),y			sta 	(zTemp2),y
.019968	c8		iny				iny
.019969	ca		dex				dex
.01996a	d0 f8		bne $019964			bne 	_SCCopy
.01996c	a5 13		lda $13				lda 	zTemp2+1 					; return concrete string in AX
.01996e	a6 12		ldx $12				ldx 	zTemp2
.019970	60		rts				rts
.019971					_SCEmpty:
.019971	a9 00		lda #$00			lda 	#0
.019973	85 25		sta $25				sta 	zNullString
.019975	a9 00		lda #$00			lda 	#zNullString >> 8
.019977	a2 25		ldx #$25			ldx 	#zNulLString & $FF
.019979	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.01997a					AllocateTempString:
.01997a	48		pha				pha 								; save required count.
.01997b	a5 21		lda $21				lda 	zTempStr+1 					; check if initialised yet ?
.01997d	d0 0b		bne $01998a			bne 	_ATSInitialised
.01997f	ad 00 03	lda $0300			lda 	StringPtr 					; set temporary string ptr 1 page below available
.019982	85 20		sta $20				sta 	zTempStr					; space, this is for strings to be concreted.
.019984	ad 01 03	lda $0301			lda 	StringPtr+1
.019987	3a		dec a				dec 	a
.019988	85 21		sta $21				sta 	zTempStr+1
.01998a					_ATSInitialised:
.01998a	68		pla				pla 								; get required count back.
.01998b	49 ff		eor #$ff			eor 	#$FF 						; negate 2's complement.
.01998d	1a		inc a				inc 	a
.01998e	18		clc				clc
.01998f	65 20		adc $20				adc 	zTempStr 					; "add" to the temp string pointer
.019991	85 20		sta $20				sta 	zTempStr
.019993	a9 ff		lda #$ff			lda 	#$FF
.019995	65 21		adc $21				adc 	zTempStr+1
.019997	85 21		sta $21				sta 	zTempStr+1
.019999	a9 00		lda #$00			lda 	#0 							; clear temp string.
.01999b	5a		phy				phy
.01999c	a8		tay				tay
.01999d	91 20		sta ($20),y			sta 	(zTempStr),y
.01999f	7a		ply				ply
.0199a0	1a		inc a				inc 	a 							; reset the write index.
.0199a1	8d 9f 03	sta $039f			sta 	TempStringWriteIndex
.0199a4	60		rts				rts
.0199a5					WriteTempString:
.0199a5	5a		phy				phy 								; save Y
.0199a6	ac 9f 03	ldy $039f			ldy 	TempStringWriteIndex	 	; write position.
.0199a9	91 20		sta ($20),y			sta 	(zTempStr),y 				; write character out.
.0199ab	ee 9f 03	inc $039f			inc 	TempStringWriteIndex 		; increment the write position.
.0199ae	98		tya				tya 								; unchanged Y is now length
.0199af	a0 00		ldy #$00			ldy 	#0
.0199b1	91 20		sta ($20),y			sta 	(zTempStr),y
.0199b3	7a		ply				ply 								; restore Y and exit
.0199b4	60		rts				rts
.0199b5					CreateTempStringCopy:
.0199b5	da		phx				phx 								; save X
.0199b6	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0199b8	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.0199b9	20 7a 99	jsr $01997a			jsr 	AllocateTempString 			; allocate memory for temporary string.
.0199bc	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0199be	c8		iny				iny
.0199bf	3a		dec a				dec 	a 							; make the actual length in charactes
.0199c0	3a		dec a				dec 	a
.0199c1	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.0199c3	81 20		sta ($20,x)			sta 	(zTempStr,x)
.0199c5	85 1a		sta $1a				sta 	zLTemp1 					; that's used as a count.
.0199c7	09 00		ora #$00			ora 	#0 							; if zero already, exit
.0199c9	f0 0e		beq $0199d9			beq 	_CTSCExit
.0199cb					_CTSCLoop:
.0199cb	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0199cd	c8		iny				iny
.0199ce	5a		phy				phy 								; save in Y
.0199cf	e8		inx				inx 								; bump index
.0199d0	da		phx				phx 								; index into Y
.0199d1	7a		ply				ply
.0199d2	91 20		sta ($20),y			sta 	(zTempStr),y 				; save at index
.0199d4	7a		ply				ply 								; restore Y
.0199d5	c6 1a		dec $1a				dec 	zLTemp1 					; do for each character
.0199d7	d0 f2		bne $0199cb			bne 	_CTSCLoop
.0199d9					_CTSCExit:
.0199d9	fa		plx				plx 								; restore X
.0199da	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/variables.asm

.0199db					VariableFind:
.0199db	20 46 9a	jsr $019a46			jsr 	VariableExtract 		; find out all about it ....
.0199de	20 df 9c	jsr $019cdf			jsr 	VariableLocate 			; does it already exist ?
.0199e1	b0 03		bcs $0199e6			bcs 	_VFExists 				; if so, use that.
.0199e3	20 d2 9a	jsr $019ad2			jsr 	VariableCreate 			; otherwise create it.
.0199e6					_VFExists:
.0199e6	a5 24		lda $24				lda 	zVarType 				; is it still an array ?
.0199e8	29 01		and #$01			and 	#1
.0199ea	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.0199ec	d0 28		bne $019a16			bne 	_VFSingleElement
.0199ee					_VFNextIndex:
.0199ee	a5 22		lda $22				lda 	zVarDataPtr 			; push the data ptr and type on the stack.
.0199f0	48		pha				pha
.0199f1	a5 23		lda $23				lda 	zVarDataPtr+1
.0199f3	48		pha				pha
.0199f4	a5 24		lda $24				lda 	zVarType
.0199f6	48		pha				pha
.0199f7	20 e6 92	jsr $0192e6			jsr 	EvaluateIntegerX 		; calculate the index.
.0199fa	68		pla				pla 							; restore and index.
.0199fb	85 24		sta $24				sta 	zVarType
.0199fd	68		pla				pla
.0199fe	85 23		sta $23				sta 	zVarDataPtr+1
.019a00	68		pla				pla
.019a01	85 22		sta $22				sta 	zVarDataPtr
.019a03	20 5d 9b	jsr $019b5d			jsr 	ArrayIndexFollow 		; do the index.
.019a06	a5 24		lda $24				lda 	zVarType 				; is it still an array ??
.019a08	29 01		and #$01			and 	#1
.019a0a	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.019a0c	d0 05		bne $019a13			bne 	_VFArrayDone 			; if so then exit.
.019a0e	20 35 99	jsr $019935			jsr 	CheckNextComma 			; comma should follow
.019a11	80 db		bra $0199ee			bra 	_VFNextIndex
.019a13					_VFArrayDone:
.019a13	20 2d 99	jsr $01992d			jsr 	CheckNextRParen 		; check closing right bracket.
.019a16					_VFSingleElement:
.019a16	60		rts				rts
.019a17					VariableClear:
.019a17	48		pha				pha 							; save registers
.019a18	da		phx				phx
.019a19	a2 00		ldx #$00			ldx 	#0 						; clear out the hash table.
.019a1b	8a		txa				txa
.019a1c	9d 35 03	sta $0335,x	_VCLoop:sta 	HashTableBase,x
.019a1f	e8		inx				inx
.019a20	e0 60		cpx #$60			cpx 	#HashTableEnd-HashTableBase
.019a22	d0 f8		bne $019a1c			bne 	_VCLoop
.019a24	a9 00		lda #$00			lda 	#VariableMemory & $FF
.019a26	8d 02 03	sta $0302			sta 	VarMemPtr
.019a29	a9 30		lda #$30			lda 	#VariableMemory >> 8
.019a2b	8d 03 03	sta $0303			sta 	VarMemPtr+1
.019a2e	fa		plx				plx 							; restore registers
.019a2f	68		pla				pla
.019a30	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/extract.asm

.019a31					VariableNameError:
.019a31	20 79 85	jsr $018579			jsr ERR_Handler
>019a34	42 61 64 20 56 61 72 69			.text "Bad Variable Name",0
>019a3c	61 62 6c 65 20 4e 61 6d 65 00
.019a46					VariableExtract:
.019a46	da		phx				phx 							; save X.
.019a47	a9 ba		lda #$ba			lda 	#token_hashlParen  		; set the type to #( e.g. real array.
.019a49	8d 95 03	sta $0395			sta 	Var_Type
.019a4c	8d 96 03	sta $0396			sta 	Var_Hash 				; we initialise the hash with this. It doesn't matter
.019a4f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019a51	c9 00		cmp #$00			cmp 	#0 						; first one must be A-Z
.019a53	f0 dc		beq $019a31			beq 	VariableNameError
.019a55	c9 1b		cmp #$1b			cmp 	#26+1
.019a57	b0 d8		bcs $019a31			bcs 	VariableNameError
.019a59	a2 ff		ldx #$ff			ldx 	#255 					; now copy it into the variable buffer.
.019a5b					_VECopyBuffer:
.019a5b	e8		inx				inx
.019a5c	e0 1f		cpx #$1f			cpx 	#31 					; too long
.019a5e	f0 d1		beq $019a31			beq 	VariableNameError
.019a60	9d 15 03	sta $0315,x			sta 	Var_Buffer,x 			; save character
.019a63	18		clc				clc  							; update the hash value for it.
.019a64	6d 96 03	adc $0396			adc 	Var_Hash
.019a67	8d 96 03	sta $0396			sta 	Var_Hash
.019a6a	c8		iny				iny
.019a6b	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019a6d	c9 00		cmp #$00			cmp 	#0 						; zero or token, end of variable
.019a6f	f0 0e		beq $019a7f			beq 	_VECopyEnd
.019a71	30 0c		bmi $019a7f			bmi 	_VECopyEnd
.019a73	c9 1b		cmp #$1b			cmp 	#26+1 					; A-Z continue copying
.019a75	90 e4		bcc $019a5b			bcc 	_VECopyBuffer
.019a77	c9 30		cmp #$30			cmp 	#"0" 					; 0-9 copy as well.
.019a79	90 04		bcc $019a7f			bcc 	_VECopyEnd
.019a7b	c9 3a		cmp #$3a			cmp 	#"9"+1
.019a7d	90 dc		bcc $019a5b			bcc 	_VECopyBuffer
.019a7f					_VECopyEnd:
.019a7f	c8		iny				iny
.019a80	c9 b7		cmp #$b7			cmp 	#token_Dollar 			; first type token.
.019a82	90 04		bcc $019a88			bcc 	_VEDefaultRequired
.019a84	c9 bd		cmp #$bd			cmp 	#token_PercentLParen+1	; last type token.
.019a86	90 0b		bcc $019a93			bcc 	_VEHaveType
.019a88					_VEDefaultRequired:
.019a88	c9 bd		cmp #$bd			cmp 	#token_LParen 			; if it ends in ( then use the real array
.019a8a	f0 04		beq $019a90			beq 	_VESetType 				; default set above.
.019a8c	ce 95 03	dec $0395			dec 	Var_Type 				; this changes that default to the variable default
.019a8f	88		dey				dey
.019a90					_VESetType:
.019a90	ad 95 03	lda $0395			lda 	Var_Type 				; get type ....
.019a93					_VEHaveType:
.019a93	8d 95 03	sta $0395			sta 	Var_Type 				; save as type.
.019a96	bd 15 03	lda $0315,x			lda 	Var_Buffer,x 			; set bit 7 of name, marks the end.
.019a99	09 80		ora #$80			ora 	#$80
.019a9b	9d 15 03	sta $0315,x			sta 	Var_Buffer,x
.019a9e	e8		inx				inx 							; offset 3 => length 4.
.019a9f	8e 97 03	stx $0397			stx 	Var_Length 				; save length of variable name.
.019aa2	ad 95 03	lda $0395			lda 	Var_Type 				; get offset of var type from first type token
.019aa5	38		sec				sec
.019aa6	e9 b7		sbc #$b7			sbc 	#token_Dollar
.019aa8	0a		asl a				asl 	a 						; multiply by 16. This requires HashTableSize
.019aa9	0a		asl a				asl 	a 						; in data.asm to be 8 (8 sets of links,2 bytes each)
.019aaa	0a		asl a				asl 	a
.019aab	0a		asl a				asl 	a
.019aac	8d 98 03	sta $0398			sta 	Var_HashAddress
.019aaf	ad 96 03	lda $0396			lda 	Var_Hash 				; get the hash
.019ab2	29 07		and #$07			and 	#(HashTableSize-1) 		; force into range 0-tableSize-1
.019ab4	0a		asl a				asl 	a 						; double it (2 bytes per entry) & clears carry
.019ab5	6d 98 03	adc $0398			adc 	Var_HashAddress 		; add table offset.
.019ab8	69 35		adc #$35			adc 	#HashTableBase & $FF 	; now the low byte of the actual table address
.019aba	8d 98 03	sta $0398			sta 	Var_HashAddress
.019abd	a2 05		ldx #$05			ldx 	#5 						; hash is 5 bytes (real)
.019abf	ad 95 03	lda $0395			lda 	Var_Type
.019ac2	c9 b9		cmp #$b9			cmp 	#token_Hash
.019ac4	f0 07		beq $019acd			beq 	_VEHaveSize
.019ac6	ca		dex				dex
.019ac7	c9 bb		cmp #$bb			cmp 	#token_Percent 			; percent is 4 bytes (integer)
.019ac9	f0 02		beq $019acd			beq 	_VEHaveSize
.019acb	a2 02		ldx #$02			ldx 	#2 						; everything else is two.
.019acd					_VEHaveSize:
.019acd	8e 99 03	stx $0399			stx 	Var_DataSize
.019ad0	fa		plx				plx
.019ad1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varcreate.asm

.019ad2					VariableCreate:
.019ad2	da		phx				phx
.019ad3	5a		phy				phy
.019ad4	ad 02 03	lda $0302			lda 	VarMemPtr 					; get address of next free into zTemp1
.019ad7	85 10		sta $10				sta 	zTemp1
.019ad9	ad 03 03	lda $0303			lda 	VarMemPtr+1
.019adc	85 11		sta $11				sta 	zTemp1+1
.019ade	ad 99 03	lda $0399			lda 	Var_DataSize 				; bytes for the data bit
.019ae1	18		clc				clc
.019ae2	6d 97 03	adc $0397			adc 	Var_Length 					; add the length of the name
.019ae5	69 03		adc #$03			adc 	#3 							; 3 for the link and the hash.
.019ae7	6d 02 03	adc $0302			adc 	VarMemPtr 					; add to variable memory pointer
.019aea	8d 02 03	sta $0302			sta 	VarMemPtr
.019aed	90 03		bcc $019af2			bcc 	_VCNoCarry
.019aef	ee 03 03	inc $0303			inc 	VarMemPtr+1
.019af2					_VCNoCarry:
.019af2	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.019af5	85 12		sta $12				sta 	zTemp2
.019af7	a9 03		lda #$03			lda 	#HashTableBase >> 8
.019af9	85 13		sta $13				sta 	zTemp2+1
.019afb	a0 00		ldy #$00			ldy 	#0 							; put current hash link in position.
.019afd	b1 12		lda ($12),y			lda 	(zTemp2),y
.019aff	91 10		sta ($10),y			sta 	(zTemp1),y
.019b01	c8		iny				iny
.019b02	b1 12		lda ($12),y			lda 	(zTemp2),y
.019b04	91 10		sta ($10),y			sta 	(zTemp1),y
.019b06	c8		iny				iny
.019b07	ad 96 03	lda $0396			lda 	Var_Hash 					; write the hash out.
.019b0a	91 10		sta ($10),y			sta 	(zTemp1),y
.019b0c	c8		iny				iny
.019b0d	a2 00		ldx #$00			ldx 	#0 							; copy the name out.
.019b0f					_VCCopyName:
.019b0f	bd 15 03	lda $0315,x			lda 	Var_Buffer,x
.019b12	91 10		sta ($10),y			sta 	(zTemp1),y
.019b14	e8		inx				inx
.019b15	c8		iny				iny
.019b16	ec 97 03	cpx $0397			cpx 	Var_Length
.019b19	d0 f4		bne $019b0f			bne 	_VCCopyName
.019b1b	5a		phy				phy 								; save the data offset.
.019b1c	ae 99 03	ldx $0399			ldx 	Var_DataSize 				; and write the data out.
.019b1f	a9 00		lda #$00			lda 	#0 							; which is all zeroes.
.019b21					_VCClearData:
.019b21	91 10		sta ($10),y			sta 	(zTemp1),y
.019b23	c8		iny				iny
.019b24	ca		dex				dex
.019b25	d0 fa		bne $019b21			bne 	_VCClearData
.019b27	68		pla				pla 								; offset to the data
.019b28	18		clc				clc
.019b29	65 10		adc $10				adc 	zTemp1 						; add to start and save as data pointer.
.019b2b	85 22		sta $22				sta 	zVarDataPtr
.019b2d	a5 11		lda $11				lda 	zTemp1+1
.019b2f	69 00		adc #$00			adc 	#0
.019b31	85 23		sta $23				sta 	zVarDataPtr+1
.019b33	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.019b36	85 24		sta $24				sta 	zVarType
.019b38	a5 10		lda $10				lda 	zTemp1 						; fix hash link to point to new record
.019b3a	a0 00		ldy #$00			ldy 	#0
.019b3c	91 12		sta ($12),y			sta 	(zTemp2),y
.019b3e	c8		iny				iny
.019b3f	a5 11		lda $11				lda 	zTemp1+1
.019b41	91 12		sta ($12),y			sta 	(zTemp2),y
.019b43	ad 95 03	lda $0395			lda 	Var_Type 					; array ? if so create the empty one.
.019b46	29 01		and #$01			and 	#1
.019b48	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.019b4a	d0 0e		bne $019b5a			bne 	_VCNotArray
.019b4c	a2 00		ldx #$00			ldx 	#0 							; call recursive array creator
.019b4e	20 f4 9b	jsr $019bf4			jsr 	ArrayCreate
.019b51	5a		phy				phy 								; save YA at zVarDataPtr
.019b52	a0 00		ldy #$00			ldy 	#0
.019b54	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019b56	c8		iny				iny
.019b57	68		pla				pla
.019b58	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019b5a					_VCNotArray:
.019b5a	7a		ply				ply
.019b5b	fa		plx				plx
.019b5c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arrayidx.asm

.019b5d					ArrayIndexFollow:
.019b5d	5a		phy				phy
.019b5e	a0 00		ldy #$00			ldy 	#0 							; make zVarDataPtr point to the array.
.019b60	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; e.g. it points to itself.
.019b62	48		pha				pha
.019b63	c8		iny				iny
.019b64	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019b66	85 23		sta $23				sta 	zVarDataPtr+1
.019b68	68		pla				pla
.019b69	85 22		sta $22				sta 	zVarDataPtr
.019b6b	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; MSB of 16 bit integer and bytes 2&3
.019b6d	29 80		and #$80			and 	#$80 						; must be zero.
.019b6f	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019b71	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019b73	d0 59		bne $019bce			bne 	_AIFError
.019b75	a0 00		ldy #$00			ldy 	#0 							; calculate size - current - 1
.019b77	18		clc				clc
.019b78	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019b7a	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.019b7c	c8		iny				iny
.019b7d	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019b7f	08		php				php 								; clear bit 7 retaining borrow.
.019b80	29 7f		and #$7f			and 	#$7F
.019b82	28		plp				plp
.019b83	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.019b85	90 47		bcc $019bce			bcc 	_AIFError 					; eror if size-current < 0
.019b87	b5 80		lda $80,x			lda  	XS_Mantissa+0,x 			; copy and double the index
.019b89	0a		asl a				asl 	a 							; (e.g. index * 2)
.019b8a	85 10		sta $10				sta 	zTemp1
.019b8c	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019b8e	2a		rol a				rol 	a
.019b8f	85 11		sta $11				sta 	zTemp1+1
.019b91	a0 01		ldy #$01			ldy 	#1 							; is this a data entry.
.019b93	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; if so, then type is unchanged, offset set
.019b95	30 1d		bmi $019bb4			bmi 	_AIFCalculate
.019b97	c6 24		dec $24				dec 	zVarType 					; converts from an array to a type.
.019b99	a5 24		lda $24				lda 	zVarType 					; check that type
.019b9b	c9 b7		cmp #$b7			cmp 	#token_Dollar 				; if string, use x 2
.019b9d	f0 15		beq $019bb4			beq 	_AIFCalculate
.019b9f	06 10		asl $10				asl 	zTemp1			 			; double the index
.019ba1	26 11		rol $11				rol 	zTemp1+1					; (e.g. index * 4)
.019ba3	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if integer, use x 4
.019ba5	f0 0d		beq $019bb4			beq 	_AIFCalculate
.019ba7	18		clc				clc 								; add the original mantissa in again
.019ba8	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; which makes it x5, for float.
.019baa	65 10		adc $10				adc 	zTemp1
.019bac	85 10		sta $10				sta 	zTemp1
.019bae	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019bb0	65 11		adc $11				adc 	zTemp1+1
.019bb2	85 11		sta $11				sta 	zTemp1+1
.019bb4					_AIFCalculate:
.019bb4	18		clc				clc 								; add index x 2,4 or 5 to base
.019bb5	a5 22		lda $22				lda 	zVarDataPtr
.019bb7	65 10		adc $10				adc 	zTemp1
.019bb9	85 22		sta $22				sta 	zVarDataPtr
.019bbb	a5 23		lda $23				lda 	zVarDataPtr+1
.019bbd	65 11		adc $11				adc 	zTemp1+1
.019bbf	85 23		sta $23				sta 	zVarDataPtr+1
.019bc1	18		clc				clc 								; add 2 more for the length prefix.
.019bc2	a5 22		lda $22				lda 	zVarDataPtr
.019bc4	69 02		adc #$02			adc 	#2
.019bc6	85 22		sta $22				sta 	zVarDataPtr
.019bc8	90 02		bcc $019bcc			bcc 	_AIFNoBump
.019bca	e6 23		inc $23				inc 	zVarDataPtr+1
.019bcc					_AIFNoBump:
.019bcc	7a		ply				ply
.019bcd	60		rts				rts
.019bce					_AIFError:
.019bce	20 79 85	jsr $018579			jsr ERR_Handler
>019bd1	42 61 64 20 61 72 72 61			.text "Bad array index",0
>019bd9	79 20 69 6e 64 65 78 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arraydef.asm

.019be1					ArrayResetDefault:
.019be1	a9 0b		lda #$0b			lda 	#11 						; 0..10 one array
.019be3	8d a9 03	sta $03a9			sta 	ArrayDef+0
.019be6	a9 00		lda #$00			lda 	#0
.019be8	8d aa 03	sta $03aa			sta 	ArrayDef+1
.019beb	a9 ff		lda #$ff			lda 	#$FF
.019bed	8d ab 03	sta $03ab			sta 	ArrayDef+2 					; $FFFF implies no second element.
.019bf0	8d ac 03	sta $03ac			sta 	ArrayDef+3					; (test bit 7 of 2nd byte)
.019bf3	60		rts				rts
.019bf4					ArrayCreate:
.019bf4	bd a9 03	lda $03a9,x			lda 	ArrayDef+0,x 				; put size x 2 in zTemp1
.019bf7	0a		asl a				asl 	a
.019bf8	85 10		sta $10				sta 	zTemp1
.019bfa	bd aa 03	lda $03aa,x			lda 	ArrayDef+1,x
.019bfd	2a		rol a				rol 	a
.019bfe	85 11		sta $11				sta 	zTemp1+1
.019c00	bd ac 03	lda $03ac,x			lda 	ArrayDef+3,x 				; if this is the last element it's array of ptrs.
.019c03	10 22		bpl $019c27			bpl 	_ACSized 					; if not multiply size x 2 (str) 4 (int) 5 (real)
.019c05	ad 95 03	lda $0395			lda 	Var_Type 					; check the type
.019c08	c9 b8		cmp #$b8			cmp 	#token_DollarLParen 		; also if it is an array of strings $(
.019c0a	f0 1b		beq $019c27			beq 	_ACSized
.019c0c	06 10		asl $10				asl 	zTemp1 						; double again
.019c0e	26 11		rol $11				rol 	zTemp1+1
.019c10	b0 6f		bcs $019c81			bcs 	ArrayIndexError 			; too large.
.019c12	c9 bc		cmp #$bc			cmp 	#token_PercentLParen 		; if %( four bytes/entry is enough.
.019c14	f0 11		beq $019c27			beq 	_ACSized
.019c16	18		clc				clc 								; add original value x 5 for reals.
.019c17	a5 10		lda $10				lda 	zTemp1
.019c19	7d a9 03	adc $03a9,x			adc 	ArrayDef+0,x
.019c1c	85 10		sta $10				sta 	zTemp1
.019c1e	a5 11		lda $11				lda 	zTemp1+1
.019c20	7d aa 03	adc $03aa,x			adc 	ArrayDef+1,x
.019c23	85 11		sta $11				sta 	zTemp1+1
.019c25	b0 5a		bcs $019c81			bcs 	ArrayIndexError
.019c27					_ACSized:
.019c27	18		clc				clc
.019c28	a5 10		lda $10				lda 	zTemp1
.019c2a	69 02		adc #$02			adc 	#2
.019c2c	85 10		sta $10				sta 	zTemp1
.019c2e	90 04		bcc $019c34			bcc 	_ACNoBump
.019c30	e6 10		inc $10				inc 	zTemp1
.019c32	f0 4d		beq $019c81			beq 	ArrayIndexError
.019c34					_ACNoBump:
.019c34	18		clc				clc
.019c35	ad 02 03	lda $0302			lda 	VarMemPtr 					; add this allocated count to VarMemPtr
.019c38	85 12		sta $12				sta 	zTemp2						; save start in zTemp2/zTemp3
.019c3a	85 14		sta $14				sta 	zTemp3
.019c3c	65 10		adc $10				adc 	zTemp1
.019c3e	8d 02 03	sta $0302			sta 	VarMemPtr
.019c41	ad 03 03	lda $0303			lda 	VarMemPtr+1
.019c44	85 13		sta $13				sta 	zTemp2+1
.019c46	85 15		sta $15				sta 	zTemp3+1
.019c48	65 11		adc $11				adc 	zTemp1+1
.019c4a	8d 03 03	sta $0303			sta 	VarMemPtr+1
.019c4d	85 11		sta $11				sta 	zTemp1+1
.019c4f	b0 30		bcs $019c81			bcs 	ArrayIndexError
.019c51	a0 00		ldy #$00			ldy 	#0							; write $00 out.
.019c53					_ACClear:
.019c53	98		tya				tya
.019c54	91 12		sta ($12),y			sta 	(zTemp2),y
.019c56	e6 12		inc $12				inc 	zTemp2
.019c58	d0 02		bne $019c5c			bne 	_ACCBump
.019c5a	e6 13		inc $13				inc 	zTemp2+1
.019c5c					_ACCBump:
.019c5c	a5 12		lda $12				lda 	zTemp2
.019c5e	cd 02 03	cmp $0302			cmp 	VarMemPtr
.019c61	d0 f0		bne $019c53			bne 	_ACClear
.019c63	a5 13		lda $13				lda 	zTemp2+1
.019c65	cd 03 03	cmp $0303			cmp 	VarMemPtr+1
.019c68	d0 e9		bne $019c53			bne 	_ACClear
.019c6a	a0 00		ldy #$00			ldy 	#0
.019c6c	bd a9 03	lda $03a9,x			lda 	ArrayDef+0,x 				; copy the size into the start
.019c6f	91 14		sta ($14),y			sta 	(zTemp3),y
.019c71	c8		iny				iny
.019c72	bd aa 03	lda $03aa,x			lda 	ArrayDef+1,x
.019c75	91 14		sta ($14),y			sta 	(zTemp3),y
.019c77	bd ac 03	lda $03ac,x			lda 	ArrayDef+3,x 				; have we reached the end
.019c7a	10 18		bpl $019c94			bpl 	ACCFillRecursive
.019c7c	a4 15		ldy $15				ldy 	zTemp3+1 					; return address
.019c7e	a5 14		lda $14				lda 	zTemp3
.019c80	60		rts				rts
.019c81					ArrayIndexError:
.019c81	20 79 85	jsr $018579			jsr ERR_Handler
>019c84	42 61 64 20 61 72 72 61			.text "Bad array index",0
>019c8c	79 20 69 6e 64 65 78 00
.019c94					ACCFillRecursive:
.019c94	a9 ff		lda #$ff			lda 	#$FF 						; we mark the end, this is free space.
.019c96	a0 00		ldy #$00			ldy 	#0 							; this is overwritten by size of next allocated
.019c98	91 12		sta ($12),y			sta 	(zTemp2),y 					; array, but we might change that.
.019c9a	c8		iny				iny
.019c9b	b1 14		lda ($14),y			lda 	(zTemp3),y 					; set bit 15 of the max index indicating
.019c9d	09 80		ora #$80			ora 	#$80 						; an array of pointers
.019c9f	91 14		sta ($14),y			sta 	(zTemp3),y
.019ca1	a5 14		lda $14				lda 	zTemp3 						; push the start on the stack
.019ca3	48		pha				pha
.019ca4	a5 15		lda $15				lda 	zTemp3+1
.019ca6	48		pha				pha
.019ca7					_ACCFillLoop:
.019ca7	18		clc				clc
.019ca8	a5 14		lda $14				lda 	zTemp3 						; and work forwards.
.019caa	69 02		adc #$02			adc 	#2
.019cac	85 14		sta $14				sta 	zTemp3
.019cae	90 02		bcc $019cb2			bcc 	_ACCSkip2
.019cb0	e6 15		inc $15				inc 	zTemp3+1
.019cb2					_ACCSkip2:
.019cb2	a0 00		ldy #$00			ldy 	#0 							; reached the end ?
.019cb4	b1 14		lda ($14),y			lda 	(zTemp3),y					; (looking for FF marker, everything else 00)
.019cb6	c8		iny				iny
.019cb7	11 14		ora ($14),y			ora 	(zTemp3),y
.019cb9	d0 21		bne $019cdc			bne 	_ACCExit
.019cbb	a5 14		lda $14				lda 	zTemp3 						; push zTemp3
.019cbd	48		pha				pha
.019cbe	a5 15		lda $15				lda 	zTemp3+1
.019cc0	48		pha				pha
.019cc1	e8		inx				inx
.019cc2	e8		inx				inx
.019cc3	20 f4 9b	jsr $019bf4			jsr 	ArrayCreate 				; create array recursively.
.019cc6	ca		dex				dex
.019cc7	ca		dex				dex
.019cc8	85 12		sta $12				sta 	zTemp2 						; save A
.019cca	68		pla				pla
.019ccb	85 15		sta $15				sta 	zTemp3+1 					; restore zTemp3
.019ccd	68		pla				pla
.019cce	85 14		sta $14				sta 	zTemp3
.019cd0	98		tya				tya 								; write high bye from Y
.019cd1	a0 01		ldy #$01			ldy 	#1
.019cd3	91 14		sta ($14),y			sta 	(zTemp3),y
.019cd5	88		dey				dey 								; write low byte out.
.019cd6	a5 12		lda $12				lda 	zTemp2
.019cd8	91 14		sta ($14),y			sta 	(zTemp3),y
.019cda	80 cb		bra $019ca7			bra 	_ACCFillLoop 				; and try again.
.019cdc					_ACCExit:
.019cdc	7a		ply				ply 								; restore the original address
.019cdd	68		pla				pla
.019cde	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varfind.asm

.019cdf					VariableLocate:
.019cdf	da		phx				phx
.019ce0	5a		phy				phy
.019ce1	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.019ce4	85 12		sta $12				sta 	zTemp2 						; points to first address.
.019ce6	a9 03		lda #$03			lda 	#HashTableBase >> 8
.019ce8	85 13		sta $13				sta 	zTemp2+1
.019cea	a0 00		ldy #$00	_VLNext:ldy 	#0 							; get next link into AX
.019cec	b1 12		lda ($12),y			lda 	(zTemp2),y
.019cee	aa		tax				tax
.019cef	c8		iny				iny
.019cf0	b1 12		lda ($12),y			lda 	(zTemp2),y
.019cf2	85 13		sta $13				sta 	zTemp2+1 					; save in zTemp
.019cf4	86 12		stx $12				stx 	zTemp2
.019cf6	05 12		ora $12				ora 	zTemp2 						; got zero
.019cf8	18		clc				clc
.019cf9	f0 25		beq $019d20			beq 	_VLExit 					; if so, then fail as end of chain.
.019cfb	c8		iny				iny 								; point to hash (offset + 2)
.019cfc	b1 12		lda ($12),y			lda 	(zTemp2),y
.019cfe	cd 96 03	cmp $0396			cmp 	Var_Hash
.019d01	d0 e7		bne $019cea			bne 	_VLNext 					; try next if different.
.019d03					_VLCompare:
.019d03	c8		iny				iny 								; next character
.019d04	b1 12		lda ($12),y			lda 	(zTemp2),y 					; compare variable field against buffer.
.019d06	d9 12 03	cmp $0312,y			cmp 	Var_Buffer-3,y 				; the -3 is because name starts at 3.
.019d09	d0 df		bne $019cea			bne 	_VLNext 					; fail if different, try next.
.019d0b	0a		asl a				asl 	a 							; until end character (bit 7 set) matched
.019d0c	90 f5		bcc $019d03			bcc 	_VLCompare
.019d0e	98		tya				tya
.019d0f	38		sec				sec 								; add 1 as Y points to last character
.019d10	65 12		adc $12				adc 	zTemp2 						; add to the current address
.019d12	85 22		sta $22				sta 	zVarDataPtr
.019d14	a5 13		lda $13				lda 	zTemp2+1
.019d16	69 00		adc #$00			adc 	#0
.019d18	85 23		sta $23				sta 	zVarDataPtr+1
.019d1a	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.019d1d	85 24		sta $24				sta 	zVarType
.019d1f	38		sec				sec 								; return CS
.019d20	7a		ply		_VLExit:ply
.019d21	fa		plx				plx
.019d22	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/vargetset.asm

.019d23					VariableGet:
.019d23	5a		phy				phy
.019d24	a0 00		ldy #$00			ldy 	#0 							; copy first two bytes
.019d26	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019d28	95 80		sta $80,x			sta 	XS_Mantissa,x
.019d2a	c8		iny				iny
.019d2b	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019d2d	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019d2f	c8		iny				iny
.019d30	a5 24		lda $24				lda 	zVarType 					; if it is a string, set up for that.
.019d32	c9 b7		cmp #$b7			cmp 	#token_Dollar
.019d34	f0 2c		beq $019d62			beq 	_VGString
.019d36	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; copy the next two bytes.
.019d38	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019d3a	c8		iny				iny
.019d3b	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019d3d	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019d3f	c8		iny				iny
.019d40	a9 01		lda #$01			lda 	#1 							; set type to 1.
.019d42	95 85		sta $85,x			sta 	XS_Type,x
.019d44	a5 24		lda $24				lda 	zVarType
.019d46	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if it is a %, then exit with default integer.
.019d48	f0 28		beq $019d72			beq 	_VGExit
.019d4a	a9 40		lda #$40			lda 	#$40 						; set type byte to zero
.019d4c	95 85		sta $85,x			sta 	XS_Type,x 					; which is the code for zero/float.
.019d4e	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; the last value to copy is the exponent.
.019d50	95 84		sta $84,x			sta 	XS_Exponent,x
.019d52	f0 1e		beq $019d72			beq 	_VGExit 					; if exponent is zero ... it's zero.
.019d54	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; the sign bit is the top mantissa bit.
.019d56	48		pha				pha
.019d57	29 80		and #$80			and 	#$80
.019d59	95 85		sta $85,x			sta 	XS_Type,x 					; this is the type byte.
.019d5b	68		pla				pla
.019d5c	09 80		ora #$80			ora 	#$80 						; set the MSB as you would expect.
.019d5e	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; so it's a normalised float.
.019d60	80 10		bra $019d72			bra 	_VGExit
.019d62					_VGString:
.019d62	a9 02		lda #$02			lda 	#2 							; set type to 2, a string
.019d64	95 85		sta $85,x			sta 	XS_Type,x
.019d66	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; is the value there $0000
.019d68	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019d6a	d0 06		bne $019d72			bne 	_VGExit 					; if not, exit.
.019d6c	85 25		sta $25				sta 	zNullString 				; make zNullString a 00 string.
.019d6e	a9 25		lda #$25			lda 	#zNullString
.019d70	95 80		sta $80,x			sta 	XS_Mantissa,x 				; make it point to it.
.019d72					_VGExit:
.019d72	7a		ply				ply
.019d73	60		rts				rts
.019d74					VariableSet:
.019d74	b5 85		lda $85,x			lda 	XS_Type,x 					; is the result a string
.019d76	29 02		and #$02			and 	#2 							; if so, it has to be
.019d78	d0 4b		bne $019dc5			bne 	_VSString
.019d7a	a5 24		lda $24				lda 	zVarType 					; if type is $ there's an error.
.019d7c	c9 b7		cmp #$b7			cmp 	#token_Dollar
.019d7e	f0 42		beq $019dc2			beq 	_VSBadType
.019d80	c9 bb		cmp #$bb			cmp 	#token_Percent 				; type convert to float/int
.019d82	f0 05		beq $019d89			beq 	_VSMakeInt
.019d84	20 ea a2	jsr $01a2ea			jsr 	FPUToFloat
.019d87	80 03		bra $019d8c			bra 	_VSCopy
.019d89					_VSMakeInt:
.019d89	20 36 a3	jsr $01a336			jsr 	FPUToInteger
.019d8c					_VSCopy:
.019d8c	5a		phy				phy
.019d8d	a0 00		ldy #$00			ldy 	#0 							; copy mantissa to target.
.019d8f	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019d91	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019d93	c8		iny				iny
.019d94	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019d96	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019d98	c8		iny				iny
.019d99	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019d9b	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019d9d	c8		iny				iny
.019d9e	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019da0	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019da2	a5 24		lda $24				lda 	zVarType 					; if target is integer, alrady done.
.019da4	c9 bb		cmp #$bb			cmp 	#token_Percent
.019da6	f0 18		beq $019dc0			beq 	_VSExit
.019da8	b5 85		lda $85,x			lda 	XS_Type,x 					; get the sign bit into carry flag.
.019daa	0a		asl a				asl 	a
.019dab	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; shift the sign into the mantissa high.
.019dad	08		php				php
.019dae	0a		asl a				asl 	a
.019daf	28		plp				plp
.019db0	6a		ror a				ror 	a
.019db1	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019db3	c8		iny				iny
.019db4	b5 84		lda $84,x			lda 	XS_Exponent,x 				; copy the exponent in
.019db6	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019db8	34 85		bit $85,x			bit 	XS_Type,x 					; if the result is non zero
.019dba	50 04		bvc $019dc0			bvc 	_VSExit
.019dbc	a9 00		lda #$00			lda 	#00 						; zero exponent indicating 0.
.019dbe	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019dc0					_VSExit:
.019dc0	7a		ply				ply
.019dc1	60		rts				rts
.019dc2					_VSBadType:
.019dc2	4c 5a 85	jmp $01855a			jmp 	TypeError
.019dc5					_VSString:
.019dc5	a5 24		lda $24				lda 	zVarType 					; type must be $
.019dc7	c9 b7		cmp #$b7			cmp 	#token_Dollar
.019dc9	d0 f7		bne $019dc2			bne 	_VSBadType
.019dcb	da		phx				phx
.019dcc	5a		phy				phy
.019dcd	20 3d 99	jsr $01993d			jsr 	StringConcrete 				; concrete the string in the mantissa -> AX
.019dd0	a0 01		ldy #$01			ldy 	#1 							; save high byte
.019dd2	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019dd4	88		dey				dey 								; save low byte
.019dd5	8a		txa				txa
.019dd6	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019dd8	7a		ply				ply 								; and exit.
.019dd9	fa		plx				plx
.019dda	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.019ddb					MulInteger32:
.019ddb	b5 80		lda $80,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.019ddd	95 8c		sta $8c,x			sta 	XS3_Mantissa,x
.019ddf	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019de1	95 8d		sta $8d,x			sta 	XS3_Mantissa+1,x
.019de3	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019de5	95 8e		sta $8e,x			sta 	XS3_Mantissa+2,x
.019de7	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019de9	95 8f		sta $8f,x			sta 	XS3_Mantissa+3,x
.019deb	a9 00		lda #$00			lda 	#0
.019ded	95 80		sta $80,x			sta 	XS_Mantissa+0,x 				; zero +0, where the result goes.
.019def	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019df1	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019df3	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019df5					_BFMMultiply:
.019df5	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.019df7	29 01		and #$01			and 	#1
.019df9	f0 03		beq $019dfe			beq 	_BFMNoAdd
.019dfb	20 86 94	jsr $019486			jsr 	AddInteger32 					; co-opt this code
.019dfe					_BFMNoAdd:
.019dfe	16 86		asl $86,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.019e00	36 87		rol $87,x			rol 	XS2_Mantissa+1,x
.019e02	36 88		rol $88,x			rol 	XS2_Mantissa+2,x
.019e04	36 89		rol $89,x			rol 	XS2_Mantissa+3,x
.019e06	56 8f		lsr $8f,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.019e08	76 8e		ror $8e,x			ror 	XS3_Mantissa+2,x
.019e0a	76 8d		ror $8d,x			ror 	XS3_Mantissa+1,x
.019e0c	76 8c		ror $8c,x			ror 	XS3_Mantissa,x
.019e0e	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.019e10	15 8d		ora $8d,x			ora 	XS3_Mantissa+1,x
.019e12	15 8e		ora $8e,x			ora 	XS3_Mantissa+2,x
.019e14	15 8f		ora $8f,x			ora 	XS3_Mantissa+3,x
.019e16	d0 dd		bne $019df5			bne 	_BFMMultiply
.019e18	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.019e19					DivInteger32:
.019e19	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; check for division by zero.
.019e1b	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.019e1d	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.019e1f	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.019e21	d0 14		bne $019e37			bne 	_BFDOkay
.019e23	20 79 85	jsr $018579			jsr ERR_Handler
>019e26	44 69 76 69 73 69 6f 6e			.text "Division by Zero",0
>019e2e	20 62 79 20 5a 65 72 6f 00
.019e37					_BFDOkay:
.019e37	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.019e39	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.019e3b	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.019e3d	85 1c		sta $1c				sta 	zLTemp1+2
.019e3f	85 1d		sta $1d				sta 	zLTemp1+3
.019e41	8d 9e 03	sta $039e			sta 	SignCount 					; Count of signs.
.019e44	20 9b 9e	jsr $019e9b			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.019e47	da		phx				phx
.019e48	e8		inx				inx
.019e49	e8		inx				inx
.019e4a	e8		inx				inx
.019e4b	e8		inx				inx
.019e4c	e8		inx				inx
.019e4d	e8		inx				inx
.019e4e	20 9b 9e	jsr $019e9b			jsr 	CheckIntegerNegate
.019e51	fa		plx				plx
.019e52	5a		phy				phy 								; Y is the counter
.019e53	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.019e55					_BFDLoop:
.019e55	16 80		asl $80,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.019e57	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.019e59	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.019e5b	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.019e5d	26 1a		rol $1a				rol 	zLTemp1
.019e5f	26 1b		rol $1b				rol 	zLTemp1+1
.019e61	26 1c		rol $1c				rol 	zLTemp1+2
.019e63	26 1d		rol $1d				rol 	zLTemp1+3
.019e65	38		sec				sec
.019e66	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.019e68	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.019e6a	48		pha				pha
.019e6b	a5 1b		lda $1b				lda 	zLTemp1+1
.019e6d	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.019e6f	48		pha				pha
.019e70	a5 1c		lda $1c				lda 	zLTemp1+2
.019e72	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.019e74	48		pha				pha
.019e75	a5 1d		lda $1d				lda 	zLTemp1+3
.019e77	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.019e79	90 13		bcc $019e8e			bcc 	_BFDNoAdd
.019e7b	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.019e7d	68		pla				pla
.019e7e	85 1c		sta $1c				sta 	zLTemp1+2
.019e80	68		pla				pla
.019e81	85 1b		sta $1b				sta 	zLTemp1+1
.019e83	68		pla				pla
.019e84	85 1a		sta $1a				sta 	zLTemp1+0
.019e86	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.019e88	09 01		ora #$01			ora 	#1
.019e8a	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019e8c	80 03		bra $019e91			bra 	_BFDNext
.019e8e					_BFDNoAdd:
.019e8e	68		pla				pla 								; Throw away the intermediate calculations
.019e8f	68		pla				pla
.019e90	68		pla				pla
.019e91					_BFDNext:
.019e91	88		dey				dey
.019e92	d0 c1		bne $019e55			bne 	_BFDLoop
.019e94	7a		ply				ply 								; restore Y
.019e95	4e 9e 03	lsr $039e			lsr 	SignCount 					; if sign count odd,
.019e98	b0 06		bcs $019ea0			bcs		IntegerNegateAlways 		; negate the result
.019e9a	60		rts				rts
.019e9b					CheckIntegerNegate:
.019e9b	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; is it -ve = MSB set ?
.019e9d	30 01		bmi $019ea0			bmi 	IntegerNegateAlways 		; if so negate it
.019e9f	60		rts				rts
.019ea0					IntegerNegateAlways:
.019ea0	ee 9e 03	inc $039e			inc 	SignCount 					; bump the count of signs
.019ea3	38		sec				sec 								; 0-mantissa,x -> mantissa,x
.019ea4	a9 00		lda #$00			lda 	#0
.019ea6	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.019ea8	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019eaa	a9 00		lda #$00			lda 	#0
.019eac	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.019eae	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019eb0	a9 00		lda #$00			lda 	#0
.019eb2	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.019eb4	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019eb6	a9 00		lda #$00			lda 	#0
.019eb8	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.019eba	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019ebc	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.019ebd					INTToString:
.019ebd	48		pha				pha
.019ebe	5a		phy				phy
.019ebf	b5 83		lda $83,x			lda 		XS_Mantissa+3,x 		; check -ve
.019ec1	10 08		bpl $019ecb			bpl 		_ITSNotMinus
.019ec3	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.019ec5	20 5f 9f	jsr $019f5f			jsr 		ITSOutputCharacter
.019ec8	20 a0 9e	jsr $019ea0			jsr 		IntegerNegateAlways 	; negate the number.
.019ecb					_ITSNotMinus:
.019ecb	a9 00		lda #$00			lda 		#0
.019ecd	8d 9a 03	sta $039a			sta 		NumSuppress 			; clear the suppression flag.
.019ed0	8a		txa				txa 								; use Y for the mantissa index.
.019ed1	a8		tay				tay
.019ed2	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.019ed4					_ITSNextSubtractor:
.019ed4	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.019ed6	8d 9b 03	sta $039b			sta 		NumConvCount
.019ed9					_ITSSubtract:
.019ed9	38		sec				sec
.019eda	b9 80 00	lda $0080,y			lda 		XS_Mantissa,y 			; subtract number and push on stack
.019edd	ff 3b 9f 01	sbc $019f3b,x			sbc 		_ITSSubtractors+0,x
.019ee1	48		pha				pha
.019ee2	b9 81 00	lda $0081,y			lda 		XS_Mantissa+1,y
.019ee5	ff 3c 9f 01	sbc $019f3c,x			sbc 		_ITSSubtractors+1,x
.019ee9	48		pha				pha
.019eea	b9 82 00	lda $0082,y			lda 		XS_Mantissa+2,y
.019eed	ff 3d 9f 01	sbc $019f3d,x			sbc 		_ITSSubtractors+2,x
.019ef1	48		pha				pha
.019ef2	b9 83 00	lda $0083,y			lda 		XS_Mantissa+3,y
.019ef5	ff 3e 9f 01	sbc $019f3e,x			sbc 		_ITSSubtractors+3,x
.019ef9	90 14		bcc $019f0f			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.019efb	99 83 00	sta $0083,y			sta 		XS_Mantissa+3,y 		; save subtract off stack
.019efe	68		pla				pla
.019eff	99 82 00	sta $0082,y			sta 		XS_Mantissa+2,y
.019f02	68		pla				pla
.019f03	99 81 00	sta $0081,y			sta 		XS_Mantissa+1,y
.019f06	68		pla				pla
.019f07	99 80 00	sta $0080,y			sta 		XS_Mantissa+0,y
.019f0a	ee 9b 03	inc $039b			inc 		NumConvCount 			; bump count.
.019f0d	80 ca		bra $019ed9			bra 		_ITSSubtract 			; go round again.
.019f0f					_ITSCantSubtract:
.019f0f	68		pla				pla 								; throw away interim answers
.019f10	68		pla				pla
.019f11	68		pla				pla
.019f12	ad 9b 03	lda $039b			lda 		NumConvCount 			; if not zero then no suppression check
.019f15	c9 30		cmp #$30			cmp 		#"0"
.019f17	d0 05		bne $019f1e			bne 		_ITSOutputDigit
.019f19	ad 9a 03	lda $039a			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.019f1c	10 09		bpl $019f27			bpl	 		_ITSGoNextSubtractor
.019f1e					_ITSOutputDigit:
.019f1e	ce 9a 03	dec $039a			dec 		NumSuppress 			; suppression check will be non-zero.
.019f21	ad 9b 03	lda $039b			lda 		NumConvCount 			; count of subtractions
.019f24	20 5f 9f	jsr $019f5f			jsr 		ITSOutputCharacter 		; output it.
.019f27					_ITSGoNextSubtractor:
.019f27	e8		inx				inx 								; next dword
.019f28	e8		inx				inx
.019f29	e8		inx				inx
.019f2a	e8		inx				inx
.019f2b	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.019f2d	d0 a5		bne $019ed4			bne 		_ITSNextSubtractor 		; do all the subtractors.
.019f2f	98		tya				tya 								; X is back as the mantissa index
.019f30	aa		tax				tax
.019f31	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.019f33	09 30		ora #$30			ora 		#"0"
.019f35	20 5f 9f	jsr $019f5f			jsr 		ITSOutputCharacter
.019f38	7a		ply				ply 								; and exit
.019f39	68		pla				pla
.019f3a	60		rts				rts
.019f3b					_ITSSubtractors:
>019f3b	00 ca 9a 3b					.dword 		1000000000
>019f3f	00 e1 f5 05					.dword 		100000000
>019f43	80 96 98 00					.dword 		10000000
>019f47	40 42 0f 00					.dword 		1000000
>019f4b	a0 86 01 00					.dword 		100000
>019f4f	10 27 00 00					.dword 		10000
>019f53	e8 03 00 00					.dword 		1000
>019f57	64 00 00 00					.dword 		100
>019f5b	0a 00 00 00					.dword 		10
.019f5f					_ITSSubtractorsEnd:
.019f5f					ITSOutputCharacter:
.019f5f	48		pha				pha
.019f60	da		phx				phx
.019f61	ae 14 03	ldx $0314			ldx 	NumBufX 					; save digit
.019f64	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.019f67	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.019f69	9d 16 03	sta $0316,x			sta 	Num_Buffer+1,x
.019f6c	ee 14 03	inc $0314			inc 	NumBufX						; bump pointer.
.019f6f	fa		plx				plx
.019f70	68		pla				pla
.019f71	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.019f72					IntFromString:
.019f72	a0 00		ldy #$00			ldy 	#0
.019f74	8c 9c 03	sty $039c			sty 	ExpTemp 					; this is the converted digit count.
.019f77					IntFromStringY:
.019f77	48		pha				pha
.019f78	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.019f7a	95 80		sta $80,x			sta 	XS_Mantissa,x
.019f7c	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019f7e	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019f80	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019f82	a9 01		lda #$01			lda 	#1
.019f84	95 85		sta $85,x			sta 	XS_Type,x
.019f86					_IFSLoop:
.019f86	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.019f88	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.019f8a	90 4e		bcc $019fda			bcc 	_IFSExit
.019f8c	c9 3a		cmp #$3a			cmp 	#"9"+1
.019f8e	b0 4a		bcs $019fda			bcs 	_IFSExit
.019f90	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.019f92	c9 0c		cmp #$0c			cmp 	#12
.019f94	b0 4e		bcs $019fe4			bcs 	_IFSOverflow
.019f96	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.019f98	48		pha				pha
.019f99	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019f9b	48		pha				pha
.019f9c	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019f9e	48		pha				pha
.019f9f	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019fa1	48		pha				pha
.019fa2	20 f9 9f	jsr $019ff9			jsr 	IFSX1ShiftLeft 				; double
.019fa5	20 f9 9f	jsr $019ff9			jsr 	IFSX1ShiftLeft 				; x 4
.019fa8	18		clc				clc 								; add saved value x 5
.019fa9	68		pla				pla
.019faa	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.019fac	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019fae	68		pla				pla
.019faf	75 81		adc $81,x			adc 	XS_Mantissa+1,x
.019fb1	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019fb3	68		pla				pla
.019fb4	75 82		adc $82,x			adc 	XS_Mantissa+2,x
.019fb6	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019fb8	68		pla				pla
.019fb9	75 83		adc $83,x			adc 	XS_Mantissa+3,x
.019fbb	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019fbd	20 f9 9f	jsr $019ff9			jsr 	IFSX1ShiftLeft 				; x 10
.019fc0	ee 9c 03	inc $039c			inc 	ExpTemp 					; bump count of digits processed.
.019fc3	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.019fc5	29 0f		and #$0f			and 	#15
.019fc7	c8		iny				iny
.019fc8	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.019fca	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019fcc	90 b8		bcc $019f86			bcc 	_IFSLoop
.019fce	f6 81		inc $81,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.019fd0	d0 b4		bne $019f86			bne 	_IFSLoop
.019fd2	f6 82		inc $82,x			inc 	XS_Mantissa+2,x
.019fd4	d0 b0		bne $019f86			bne 	_IFSLoop
.019fd6	f6 83		inc $83,x			inc 	XS_Mantissa+3,x
.019fd8	80 ac		bra $019f86			bra 	_IFSLoop
.019fda					_IFSExit:
.019fda	98		tya				tya 								; get offset
.019fdb					_IFSOkay:
.019fdb	38		sec				sec
.019fdc	ad 9c 03	lda $039c			lda 	ExpTemp
.019fdf	f0 01		beq $019fe2			beq 	_IFSSkipFail
.019fe1	18		clc				clc
.019fe2					_IFSSkipFail:
.019fe2	68		pla				pla 								; and exit.
.019fe3	60		rts				rts
.019fe4					_IFSOverflow:
.019fe4	20 79 85	jsr $018579			jsr 	ERR_Handler
>019fe7	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>019fef	20 6f 76 65 72 66 6c 6f 77 00
.019ff9					IFSX1ShiftLeft:
.019ff9	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.019ffb	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.019ffd	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.019fff	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.01a001	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.01a002					FPSubtract:
.01a002	48		pha				pha
.01a003	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.01a005	49 80		eor #$80			eor 	#$80
.01a007	95 8b		sta $8b,x			sta 	XS2_Type,x
.01a009	68		pla				pla 								; --- and fall through ---
.01a00a					FPAdd:
.01a00a	48		pha				pha
.01a00b	b5 85		lda $85,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.01a00d	d0 05		bne $01a014			bne 	_FPA_NegativeLHS
.01a00f	20 2b a0	jsr $01a02b			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.01a012	68		pla				pla
.01a013	60		rts				rts
.01a014					_FPA_NegativeLHS:
.01a014	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.01a016	49 80		eor #$80			eor 	#$80
.01a018	95 85		sta $85,x			sta 	XS_Type,x
.01a01a	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of B and add
.01a01c	49 80		eor #$80			eor 	#$80
.01a01e	95 8b		sta $8b,x			sta 	XS2_Type,x
.01a020	20 2b a0	jsr $01a02b			jsr 	FPAdd_Worker 				; do the add calculation.
.01a023	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 back
.01a025	49 80		eor #$80			eor 	#$80
.01a027	95 85		sta $85,x			sta 	XS_Type,x
.01a029	68		pla				pla
.01a02a	60		rts				rts
.01a02b					FPAdd_Worker:
.01a02b	34 8b		bit $8b,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.01a02d	70 07		bvs $01a036			bvs 	_FPAWExit 					; no change.
.01a02f	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.01a031	50 07		bvc $01a03a			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.01a033	20 a8 a2	jsr $01a2a8			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.01a036					_FPAWExit:
.01a036	20 17 a3	jsr $01a317			jsr 	FPUNormalise 				; normalise the result.
.01a039	60		rts				rts
.01a03a					_FPAWMakeSame:
.01a03a	b5 84		lda $84,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.01a03c	38		sec				sec
.01a03d	f5 8a		sbc $8a,x			sbc	 	XS2_Exponent,x 				; using subtraction
.01a03f	f0 16		beq $01a057			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.01a041	da		phx				phx 								; save X
.01a042	90 06		bcc $01a04a			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.01a044	e8		inx				inx
.01a045	e8		inx				inx
.01a046	e8		inx				inx
.01a047	e8		inx				inx
.01a048	e8		inx				inx
.01a049	e8		inx				inx
.01a04a					_FPAWShiftA:
.01a04a	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.01a04c	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.01a04e	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a050	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a052	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a054	fa		plx				plx 								; restore original X
.01a055	80 e3		bra $01a03a			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.01a057					_FPAW_DoArithmetic:
.01a057	34 8b		bit $8b,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.01a059	30 28		bmi $01a083			bmi 	_FPAW_BNegative
.01a05b	18		clc				clc
.01a05c	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01a05e	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.01a060	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a062	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a064	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.01a066	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a068	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a06a	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.01a06c	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a06e	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a070	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.01a072	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a074	90 c0		bcc $01a036			bcc 	_FPAWExit 					; no carry.
.01a076	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.01a078	38		sec				sec
.01a079	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.01a07b	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a07d	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a07f	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a081	80 b3		bra $01a036			bra 	_FPAWExit
.01a083					_FPAW_BNegative:
.01a083	38		sec				sec
.01a084	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01a086	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.01a088	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a08a	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a08c	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.01a08e	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a090	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a092	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.01a094	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a096	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a098	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.01a09a	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a09c	b0 09		bcs $01a0a7			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.01a09e	20 ce a2	jsr $01a2ce			jsr 	FPUNegateInteger			; negate the mantissa
.01a0a1	b5 85		lda $85,x			lda 	XS_Type,x 					; flip result sign
.01a0a3	49 80		eor #$80			eor 	#$80
.01a0a5	95 85		sta $85,x			sta 	XS_Type,x
.01a0a7					_FPAWGoExit:
.01a0a7	4c 36 a0	jmp $01a036			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.01a0aa					FPD_IsDivZero:
.01a0aa	20 79 85	jsr $018579			jsr ERR_Handler
>01a0ad	44 69 76 69 73 69 6f 6e			.text "Division by zero",0
>01a0b5	20 62 79 20 7a 65 72 6f 00
.01a0be					FPDivide:
.01a0be	48		pha				pha
.01a0bf	5a		phy				phy
.01a0c0	34 8b		bit $8b,x			bit 	XS2_Type,x 					; check if division by zero
.01a0c2	70 e6		bvs $01a0aa			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.01a0c4	34 85		bit $85,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.01a0c6	f0 03		beq $01a0cb			beq 	_FPDCalculateExp
.01a0c8					_FPD_Exit:
.01a0c8	7a		ply				ply
.01a0c9	68		pla				pla
.01a0ca	60		rts				rts
.01a0cb					_FPDCalculateExp:
.01a0cb	b5 8a		lda $8a,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.01a0cd	49 ff		eor #$ff			eor 	#$FF
.01a0cf	1a		inc a				inc 	a
.01a0d0	95 8a		sta $8a,x			sta 	XS2_Exponent,x
.01a0d2	20 a2 a1	jsr $01a1a2			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.01a0d5	18		clc				clc 	 							; add 1 to the resulting exponent
.01a0d6	69 01		adc #$01			adc 	#1
.01a0d8	b0 54		bcs $01a12e			bcs 	_FPD_Overflow 				; which can overflow.
.01a0da	95 84		sta $84,x			sta 	XS_Exponent,x
.01a0dc	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.01a0de	85 1a		sta $1a				sta 	zLTemp1+0
.01a0e0	85 1b		sta $1b				sta 	zLTemp1+1
.01a0e2	85 1c		sta $1c				sta 	zLTemp1+2
.01a0e4	85 1d		sta $1d				sta 	zLTemp1+3
.01a0e6	a0 20		ldy #$20			ldy 	#32 						; times round.
.01a0e8					_FPD_Loop:
.01a0e8	38		sec				sec 								; calculate X1-X2 stacking result because we might
.01a0e9	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; not save it.
.01a0eb	f5 86		sbc $86,x			sbc 	XS2_Mantissa,x
.01a0ed	48		pha				pha
.01a0ee	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a0f0	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.01a0f2	48		pha				pha
.01a0f3	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a0f5	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.01a0f7	48		pha				pha
.01a0f8	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a0fa	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.01a0fc	90 13		bcc $01a111			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.01a0fe	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; save results out to A
.01a100	68		pla				pla
.01a101	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a103	68		pla				pla
.01a104	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a106	68		pla				pla
.01a107	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a109	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.01a10b	09 80		ora #$80			ora 	#$80
.01a10d	85 1d		sta $1d				sta 	zLTemp1+3
.01a10f	80 03		bra $01a114			bra 	_FPD_Rotates
.01a111					_FPD_NoSubtract:
.01a111	68		pla				pla 								; throw away unwanted results
.01a112	68		pla				pla
.01a113	68		pla				pla
.01a114					_FPD_Rotates:
.01a114	56 89		lsr $89,x			lsr 	3+XS2_Mantissa,x
.01a116	76 88		ror $88,x			ror 	2+XS2_Mantissa,x
.01a118	76 87		ror $87,x			ror 	1+XS2_Mantissa,x
.01a11a	76 86		ror $86,x			ror 	0+XS2_Mantissa,x
.01a11c	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.01a11e	26 1b		rol $1b				rol 	zLTemp1+1
.01a120	26 1c		rol $1c				rol 	zLTemp1+2
.01a122	26 1d		rol $1d				rol 	zLTemp1+3
.01a124	90 02		bcc $01a128			bcc 	_FPD_NoCarry
.01a126	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.01a128					_FPD_NoCarry:
.01a128	88		dey				dey 								; do 32 times
.01a129	d0 bd		bne $01a0e8			bne 	_FPD_Loop
.01a12b	4c 86 a1	jmp $01a186			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.01a12e					_FPD_Overflow:
.01a12e	4c 74 a3	jmp $01a374			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.01a131					FPMultiply:
.01a131	48		pha				pha
.01a132	5a		phy				phy
.01a133	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.01a135	70 07		bvs $01a13e			bvs 	_FPM_Exit
.01a137	34 8b		bit $8b,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.01a139	50 06		bvc $01a141			bvc 	_FPM_CalcExponent
.01a13b	20 a8 a2	jsr $01a2a8			jsr 	FPUCopyX2ToX1
.01a13e					_FPM_Exit:
.01a13e	7a		ply				ply
.01a13f	68		pla				pla
.01a140	60		rts				rts
.01a141					_FPM_CalcExponent:
.01a141	18		clc				clc
.01a142	20 a2 a1	jsr $01a1a2			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.01a145	95 84		sta $84,x			sta 	XS_Exponent,x 				; save the result.
.01a147	a9 00		lda #$00			lda 	#0
.01a149	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.01a14b	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.01a14d	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.01a14f	85 1d		sta $1d				sta 	zLTemp1+3
.01a151	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.01a153					_FPM_Loop:
.01a153	b5 80		lda $80,x			lda 	XS_Mantissa,x				; check LSB of long product
.01a155	29 01		and #$01			and 	#1
.01a157	18		clc				clc 								; clear carry for the long rotate.
.01a158	f0 19		beq $01a173			beq 	_FPM_NoAddition
.01a15a	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.01a15b	a5 1a		lda $1a				lda 	zLTemp1+0
.01a15d	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.01a15f	85 1a		sta $1a				sta 	zLTemp1+0
.01a161	a5 1b		lda $1b				lda 	zLTemp1+1
.01a163	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.01a165	85 1b		sta $1b				sta 	zLTemp1+1
.01a167	a5 1c		lda $1c				lda 	zLTemp1+2
.01a169	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.01a16b	85 1c		sta $1c				sta 	zLTemp1+2
.01a16d	a5 1d		lda $1d				lda 	zLTemp1+3
.01a16f	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.01a171	85 1d		sta $1d				sta 	zLTemp1+3
.01a173					_FPM_NoAddition:
.01a173	66 1d		ror $1d				ror 	3+zLTemp1
.01a175	66 1c		ror $1c				ror 	2+zLTemp1
.01a177	66 1b		ror $1b				ror 	1+zLTemp1
.01a179	66 1a		ror $1a				ror 	0+zLTemp1
.01a17b	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.01a17d	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a17f	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a181	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a183	88		dey				dey
.01a184	d0 cd		bne $01a153			bne 	_FPM_Loop 					; do this 32 times.
.01a186					FPM_CopySignNormalize:
.01a186	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.01a188	95 80		sta $80,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.01a18a	a5 1b		lda $1b				lda 	zLTemp1+1
.01a18c	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a18e	a5 1c		lda $1c				lda 	zLTemp1+2
.01a190	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a192	a5 1d		lda $1d				lda 	zLTemp1+3
.01a194	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a196	b5 85		lda $85,x			lda 	XS_Type,x 					; sign is xor of signs
.01a198	55 8b		eor $8b,x			eor 	XS2_Type,x
.01a19a	95 85		sta $85,x			sta 	XS_Type,x
.01a19c	20 17 a3	jsr $01a317			jsr 	FPUNormalise 				; normalise and exit.
.01a19f	7a		ply				ply
.01a1a0	68		pla				pla
.01a1a1	60		rts				rts
.01a1a2					FPCalculateExponent:
.01a1a2	18		clc				clc
.01a1a3	b5 84		lda $84,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.01a1a5	75 8a		adc $8a,x			adc 	XS2_Exponent,x
.01a1a7	b0 08		bcs $01a1b1			bcs 	_FPCECarry 					; carry out ?
.01a1a9	10 03		bpl $01a1ae			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.01a1ab	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.01a1ad	60		rts				rts
.01a1ae					_FPCEExpZero:
.01a1ae	a9 00		lda #$00			lda 	#0
.01a1b0	60		rts				rts
.01a1b1					_FPCECarry:
.01a1b1	30 03		bmi $01a1b6			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.01a1b3	09 80		ora #$80			ora 	#$80 						; put in right range
.01a1b5	60		rts				rts
.01a1b6					_FPCEOverflow:
.01a1b6	4c 74 a3	jmp $01a374			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.01a1b9					FPFractionalPart:
.01a1b9	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.01a1bb	38		sec				sec 								; this flag tells us to keep the fractional part
.01a1bc	30 0d		bmi $01a1cb			bmi 	FPGetPart
.01a1be	60		rts				rts
.01a1bf					FPIntegerPart:
.01a1bf	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.01a1c1	18		clc				clc 								; this flag says keep the integer part.
.01a1c2	30 07		bmi $01a1cb			bmi 	FPGetPart 					; -ve exponents are 0..127
.01a1c4	48		pha				pha
.01a1c5	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.01a1c7	95 85		sta $85,x			sta 	XS_Type,x
.01a1c9	68		pla				pla
.01a1ca	60		rts				rts
.01a1cb					FPGetPart:
.01a1cb	48		pha				pha
.01a1cc	5a		phy				phy 								; save Y
.01a1cd	08		php				php 								; save action
.01a1ce	34 85		bit $85,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.01a1d0	70 59		bvs $01a22b			bvs 	_FPGP_Exit 					; then do nothing.
.01a1d2	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.01a1d4	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.01a1d6	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.01a1d8	85 1c		sta $1c				sta 	zLTemp1+2
.01a1da	85 1d		sta $1d				sta 	zLTemp1+3
.01a1dc	b5 84		lda $84,x			lda 	XS_Exponent,x				; the number of shifts.
.01a1de	38		sec				sec
.01a1df	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.01a1e1	f0 12		beq $01a1f5			beq 	_FPGP_NoShift 				; ... if any
.01a1e3	c9 20		cmp #$20			cmp 	#32
.01a1e5	90 02		bcc $01a1e9			bcc 	_FPGP_NotMax
.01a1e7	a9 20		lda #$20			lda 	#32 						; max of 32.
.01a1e9					_FPGP_NotMax:
.01a1e9	a8		tay				tay 								; Y is the mask shift count.
.01a1ea					_FPGP_ShiftMask:
.01a1ea	46 1d		lsr $1d				lsr 	3+zLTemp1
.01a1ec	66 1c		ror $1c				ror 	2+zLTemp1
.01a1ee	66 1b		ror $1b				ror 	1+zLTemp1
.01a1f0	66 1a		ror $1a				ror 	0+zLTemp1
.01a1f2	88		dey				dey
.01a1f3	d0 f5		bne $01a1ea			bne 	_FPGP_ShiftMask
.01a1f5					_FPGP_NoShift:
.01a1f5	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.01a1f7	8e 9c 03	stx $039c			stx 	ExpTemp						; save X
.01a1fa					_FPGP_MaskLoop:
.01a1fa	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.01a1fd	28		plp				plp 								; if CC we keep the top part, so we
.01a1fe	08		php				php		 							; flip the mask.
.01a1ff	b0 02		bcs $01a203			bcs		_FPGP_NoFlip
.01a201	49 ff		eor #$ff			eor 	#$FF
.01a203					_FPGP_NoFlip:
.01a203	35 80		and $80,x			and 	XS_Mantissa,x 				; and into the mantissa.
.01a205	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a207	e8		inx				inx
.01a208	c8		iny				iny
.01a209	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.01a20b	d0 ed		bne $01a1fa			bne 	_FPGP_MaskLoop
.01a20d	ae 9c 03	ldx $039c			ldx 	ExpTemp						; restore X
.01a210	28		plp				plp
.01a211	08		php				php 								; get action flag on the stack
.01a212	90 04		bcc $01a218			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.01a214	a9 00		lda #$00			lda 	#0
.01a216	95 85		sta $85,x			sta 	XS_Type,x
.01a218					_FPGP_NotFractional:
.01a218	b5 80		lda $80,x			lda 	XS_Mantissa,x 						; check if \1 zero
.01a21a	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.01a21c	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01a21e	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01a220	f0 05		beq $01a227			beq 	_FPGP_Zero 					; if zero, return zero
.01a222	20 17 a3	jsr $01a317			jsr 	FPUNormalise
.01a225	80 04		bra $01a22b			bra 	_FPGP_Exit 					; and exit
.01a227					_FPGP_Zero:
.01a227	a9 40		lda #$40			lda 	#$40 						; set zero flag
.01a229	95 85		sta $85,x			sta 	XS_Type,x
.01a22b					_FPGP_Exit:
.01a22b	68		pla				pla 								; throw saved action flag.
.01a22c	7a		ply				ply
.01a22d	68		pla				pla
.01a22e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.01a22f					FPCompare:
.01a22f	20 70 a2	jsr $01a270			jsr 	FPFastCompare 				; fast compare try first
.01a232	b0 3b		bcs $01a26f			bcs 	_FPCExit 					; that worked.
.01a234	b5 84		lda $84,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.01a236	48		pha				pha
.01a237	b5 8a		lda $8a,x			lda 	XS2_Exponent,x
.01a239	48		pha				pha
.01a23a	20 02 a0	jsr $01a002			jsr 	FPSubtract 					; calculate X1-X2
.01a23d	34 85		bit $85,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.01a23f	70 2a		bvs $01a26b			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.01a241	68		pla				pla
.01a242	8d 9c 03	sta $039c			sta 	ExpTemp						; save first exponent in temporary reg.
.01a245	68		pla				pla
.01a246	38		sec				sec
.01a247	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; calculate AX-BX
.01a24a	70 14		bvs $01a260			bvs 	_FPCNotEqual				; overflow, can't be equal.
.01a24c	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.01a24d	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.01a24f	b0 0f		bcs $01a260			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.01a251	38		sec				sec
.01a252	ad 9c 03	lda $039c			lda 	ExpTemp 					; get one of the exponents back.
.01a255	e9 12		sbc #$12			sbc 	#18 						; allow for 2^18 error, relatively.
.01a257	b0 02		bcs $01a25b			bcs 	_FPCNotRange 				; keep in range.
.01a259	a9 01		lda #$01			lda 	#1
.01a25b					_FPCNotRange:
.01a25b	38		sec				sec
.01a25c	f5 84		sbc $84,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.01a25e	b0 0d		bcs $01a26d			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.01a260					_FPCNotEqual:
.01a260	b5 85		lda $85,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.01a262	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.01a264	f0 02		beq $01a268			beq 	_FPCNE2
.01a266	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.01a268	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.01a269	80 04		bra $01a26f			bra 	_FPCExit
.01a26b					_FPCPullZero:
.01a26b	68		pla				pla 								; throw saved exponents
.01a26c	68		pla				pla
.01a26d					_FPCZero:
.01a26d	a9 00		lda #$00			lda 	#0 							; and return zero
.01a26f					_FPCExit:
.01a26f	60		rts				rts
.01a270					FPFastCompare:
.01a270	34 85		bit $85,x			bit 	XS_Type,x 					; n1 is zero.
.01a272	70 23		bvs $01a297			bvs 	_FPFLeftZero
.01a274	34 8b		bit $8b,x			bit 	XS2_Type,x 					; n2 is zero
.01a276	b5 85		lda $85,x			lda 	XS_Type,x 					; if so, return sign bit of 1 (n-0)
.01a278	70 25		bvs $01a29f			bvs 	_FPFSignBit
.01a27a	55 8b		eor $8b,x			eor 	XS2_Type,x 					; eor 2 type bits. now know both non-zero
.01a27c	0a		asl a				asl 	a 							; put in CS if different.
.01a27d	b5 85		lda $85,x			lda 	XS_Type,x 					; if signs different return sign of first
.01a27f	b0 1e		bcs $01a29f			bcs 	_FPFSignBit
.01a281	38		sec				sec 								; same sign and not-zero. compare exponents
.01a282	b5 84		lda $84,x			lda 	XS_Exponent,x 				; compare exponents. if the same, then fail.
.01a284	f5 8a		sbc $8a,x			sbc 	XS2_Exponent,x 				; e.g. we have to do it via subtraction.
.01a286	f0 09		beq $01a291			beq 	_FPNoFastCompare
.01a288	6a		ror a				ror 	a 							; put carry into bit 7.
.01a289	34 85		bit $85,x			bit 	XS_Type,X 					; if it is +x then flip it.
.01a28b	30 02		bmi $01a28f			bmi		_FPFCNotMinus
.01a28d	49 80		eor #$80			eor 	#$80
.01a28f					_FPFCNotMinus:
.01a28f	80 0e		bra $01a29f			bra		_FPFSignBit
.01a291					_FPNoFastCompare:
.01a291	18		clc				clc
.01a292	60		rts				rts
.01a293					_FPFZero:
.01a293	a9 00		lda #$00			lda 	#0
.01a295					_FPFExitSet:
.01a295	38		sec				sec
.01a296	60		rts				rts
.01a297					_FPFLeftZero:
.01a297	34 8b		bit $8b,x			bit 	XS2_Type,x 					; if right is zero, return zero.
.01a299	70 f8		bvs $01a293			bvs 	_FPFZero
.01a29b	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip sign bit
.01a29d	49 80		eor #$80			eor 	#$80						; return that as a sign.
.01a29f					_FPFSignBit:
.01a29f	0a		asl a				asl 	a
.01a2a0	a9 01		lda #$01			lda 	#1
.01a2a2	90 f1		bcc $01a295			bcc		_FPFExitSet
.01a2a4	a9 ff		lda #$ff			lda 	#$FF
.01a2a6	38		sec				sec
.01a2a7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.01a2a8					FPUCopyX2ToX1:
.01a2a8	48		pha				pha
.01a2a9	da		phx				phx
.01a2aa	5a		phy				phy
.01a2ab	a0 08		ldy #$08			ldy 	#8
.01a2ad	b5 86		lda $86,x	_FPUC21:lda 	XS2_Mantissa,x
.01a2af	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a2b1	e8		inx				inx
.01a2b2	88		dey				dey
.01a2b3	10 f8		bpl $01a2ad			bpl 	_FPUC21
.01a2b5	7a		ply				ply
.01a2b6	fa		plx				plx
.01a2b7	68		pla				pla
.01a2b8	60		rts				rts
.01a2b9					FPUSetInteger:
.01a2b9	48		pha				pha
.01a2ba	95 80		sta $80,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.01a2bc	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.01a2be	10 02		bpl $01a2c2			bpl 	_FPUSIExtend
.01a2c0	a9 ff		lda #$ff			lda 	#$FF
.01a2c2					_FPUSIExtend:
.01a2c2	95 81		sta $81,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.01a2c4	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a2c6	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a2c8	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.01a2ca	95 85		sta $85,x			sta 	XS_Type,x
.01a2cc	68		pla				pla
.01a2cd	60		rts				rts
.01a2ce					FPUNegateInteger:
.01a2ce	48		pha				pha
.01a2cf	38		sec				sec
.01a2d0	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.01a2d2	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.01a2d4	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a2d6	a9 00		lda #$00			lda 	#0
.01a2d8	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.01a2da	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a2dc	a9 00		lda #$00			lda 	#0
.01a2de	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.01a2e0	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a2e2	a9 00		lda #$00			lda 	#0
.01a2e4	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.01a2e6	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a2e8	68		pla				pla
.01a2e9	60		rts				rts
.01a2ea					FPUToFloat:
.01a2ea	48		pha				pha
.01a2eb	b5 85		lda $85,x			lda 	XS_Type,x					; exit if already float.
.01a2ed	29 0f		and #$0f			and 	#$0F
.01a2ef	f0 24		beq $01a315			beq 	_FPUFExit
.01a2f1	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.01a2f3	95 85		sta $85,x			sta 	XS_Type,x
.01a2f5	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.01a2f7	95 84		sta $84,x			sta 	XS_Exponent,x 				; x mantissa.
.01a2f9	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.01a2fb	10 07		bpl $01a304			bpl		_FPUFPositive
.01a2fd	20 ce a2	jsr $01a2ce			jsr 	FPUNegateInteger 			; negate the mantissa
.01a300	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.01a302	95 85		sta $85,x			sta 	XS_Type,x
.01a304					_FPUFPositive:
.01a304	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.01a306	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.01a308	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01a30a	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01a30c	d0 04		bne $01a312			bne 	_FPUFNonZero
.01a30e	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.01a310	95 85		sta $85,x			sta 	XS_Type,x
.01a312					_FPUFNonZero:
.01a312	20 17 a3	jsr $01a317			jsr 	FPUNormalise 				; normalise the floating point.
.01a315					_FPUFExit:
.01a315	68		pla				pla
.01a316	60		rts				rts
.01a317					FPUNormalise:
.01a317	48		pha				pha
.01a318	34 85		bit $85,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.01a31a	70 18		bvs $01a334			bvs 	_FPUNExit
.01a31c	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.01a31e	f0 10		beq $01a330			beq 	_FPUNSetZero
.01a320					_FPUNLoop:
.01a320	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.01a322	30 10		bmi $01a334			bmi 	_FPUNExit 					; if so, we are normalised.
.01a324	16 80		asl $80,x			asl 	0+XS_Mantissa+0,x
.01a326	36 81		rol $81,x			rol 	1+XS_Mantissa+0,x
.01a328	36 82		rol $82,x			rol 	2+XS_Mantissa+0,x
.01a32a	36 83		rol $83,x			rol 	3+XS_Mantissa+0,x
.01a32c	d6 84		dec $84,x			dec 	XS_Exponent,x 				; decrement exponent
.01a32e	d0 f0		bne $01a320			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.01a330					_FPUNSetZero:
.01a330	a9 40		lda #$40			lda 	#$40
.01a332	95 85		sta $85,x			sta 	XS_Type,x 					; the result is now zero.
.01a334					_FPUNExit:
.01a334	68		pla				pla
.01a335	60		rts				rts
.01a336					FPUToInteger:
.01a336	48		pha				pha
.01a337	b5 85		lda $85,x			lda 	XS_Type,x 					; if already integer, exit
.01a339	29 01		and #$01			and 	#1
.01a33b	d0 31		bne $01a36e			bne 	_FPUTOI_Exit
.01a33d	34 85		bit $85,x			bit 	XS_Type,x					; if zero, return zero.
.01a33f	70 23		bvs $01a364			bvs 	_FPUTOI_Zero
.01a341	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.01a343	10 1f		bpl $01a364			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.01a345	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.01a347	b0 2b		bcs $01a374			bcs 	FP_Overflow
.01a349					_FPUToIToInteger:
.01a349	b5 84		lda $84,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.01a34b	c9 a0		cmp #$a0			cmp 	#128+32
.01a34d	f0 0c		beq $01a35b			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.01a34f	f6 84		inc $84,x			inc 	XS_Exponent,X 				; increment Exponent
.01a351	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.01a353	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a355	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a357	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a359	80 ee		bra $01a349			bra 	_FPUToIToInteger 			; keep going.
.01a35b					_FPUToICheckSign:
.01a35b	b5 85		lda $85,x			lda 	XS_Type,x 					; check sign
.01a35d	10 0f		bpl $01a36e			bpl 	_FPUToI_Exit 				; exit if unsigned.
.01a35f	20 ce a2	jsr $01a2ce			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.01a362	80 0a		bra $01a36e			bra 	_FPUTOI_Exit
.01a364					_FPUTOI_Zero:
.01a364	a9 00		lda #$00			lda 	#0 							; return zero integer.
.01a366	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a368	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a36a	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a36c	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a36e					_FPUToI_Exit:
.01a36e	a9 01		lda #$01			lda 	#1 							; set type to integer
.01a370	95 85		sta $85,x			sta 	XS_Type,x
.01a372	68		pla				pla
.01a373	60		rts				rts
.01a374					FP_Overflow:
.01a374	20 79 85	jsr $018579			jsr ERR_Handler
>01a377	46 6c 6f 61 74 69 6e 67			.text "Floating Point overflow",0
>01a37f	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.01a38f					FPUTimes10:
.01a38f	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.01a391	85 1a		sta $1a				sta 	ZLTemp1+0
.01a393	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a395	85 1b		sta $1b				sta 	ZLTemp1+1
.01a397	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a399	85 1c		sta $1c				sta 	ZLTemp1+2
.01a39b	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a39d	85 1d		sta $1d				sta 	ZLTemp1+3
.01a39f	20 d4 a3	jsr $01a3d4			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.01a3a2	20 d4 a3	jsr $01a3d4			jsr 	_FPUT_LSR_ZLTemp1
.01a3a5	18		clc				clc
.01a3a6	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.01a3a8	65 1a		adc $1a				adc 	ZLTemp1+0
.01a3aa	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a3ac	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a3ae	65 1b		adc $1b				adc 	ZLTemp1+1
.01a3b0	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a3b2	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a3b4	65 1c		adc $1c				adc 	ZLTemp1+2
.01a3b6	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a3b8	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a3ba	65 1d		adc $1d				adc 	ZLTemp1+3
.01a3bc	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a3be	90 0a		bcc $01a3ca			bcc 	_FPUTimes10
.01a3c0	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.01a3c2	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a3c4	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a3c6	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a3c8	f6 84		inc $84,x			inc 	XS_Exponent,x				; fix exponent
.01a3ca					_FPUTimes10:
.01a3ca	b5 84		lda $84,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.01a3cc	18		clc				clc
.01a3cd	69 03		adc #$03			adc 	#3
.01a3cf	95 84		sta $84,x			sta 	XS_Exponent,x
.01a3d1	b0 a1		bcs $01a374			bcs 	FP_Overflow 				; error
.01a3d3	60		rts				rts
.01a3d4					_FPUT_LSR_ZLTemp1:
.01a3d4	46 1d		lsr $1d				lsr 	ZLTemp1+3
.01a3d6	66 1c		ror $1c				ror 	ZLTemp1+2
.01a3d8	66 1b		ror $1b				ror 	ZLTemp1+1
.01a3da	66 1a		ror $1a				ror 	ZLTemp1+0
.01a3dc	60		rts				rts
.01a3dd					FPUScale10A:
.01a3dd	5a		phy				phy
.01a3de	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.01a3e0	f0 37		beq $01a419			beq 	_FPUScaleExit
.01a3e2	da		phx				phx 								; save X
.01a3e3	e8		inx				inx
.01a3e4	e8		inx				inx
.01a3e5	e8		inx				inx
.01a3e6	e8		inx				inx
.01a3e7	e8		inx				inx
.01a3e8	e8		inx				inx
.01a3e9	a8		tay				tay 								; save power scalar in Y.
.01a3ea	a9 00		lda #$00			lda 	#0
.01a3ec	95 80		sta $80,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.01a3ee	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a3f0	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a3f2	95 85		sta $85,x			sta 	XS_Type,x
.01a3f4	a9 80		lda #$80			lda 	#$80
.01a3f6	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a3f8	a9 81		lda #$81			lda 	#$81
.01a3fa	95 84		sta $84,x			sta 	XS_Exponent,x
.01a3fc	5a		phy				phy 								; save 10^n on stack.
.01a3fd	c0 00		cpy #$00			cpy 	#0
.01a3ff	10 05		bpl $01a406			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.01a401	98		tya				tya
.01a402	49 ff		eor #$ff			eor 	#$FF
.01a404	1a		inc a				inc 	a
.01a405	a8		tay				tay
.01a406					_FPUSAbs:
.01a406	20 8f a3	jsr $01a38f			jsr 	FPUTimes10
.01a409	88		dey				dey
.01a40a	d0 fa		bne $01a406			bne 	_FPUSAbs 					; tos is now 10^|AC|
.01a40c	68		pla				pla 								; restore count in A
.01a40d	fa		plx				plx 								; restore X pointing to number to scale.
.01a40e	0a		asl a				asl 	a
.01a40f	b0 05		bcs $01a416			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.01a411	20 31 a1	jsr $01a131			jsr 	FPMultiply 					; if clear multiply.
.01a414	80 03		bra $01a419			bra		_FPUScaleExit
.01a416					_FPUSDivide:
.01a416	20 be a0	jsr $01a0be			jsr 	FPDivide
.01a419					_FPUScaleExit:
.01a419	7a		ply				ply
.01a41a	60		rts				rts
.01a41b					FPUCopyToNext:
.01a41b	a0 06		ldy #$06			ldy 		#6
.01a41d	da		phx				phx
.01a41e					_FPUCopy1:
.01a41e	b5 80		lda $80,x			lda 	XS_Mantissa,x
.01a420	95 86		sta $86,x			sta 	XS2_Mantissa,x
.01a422	e8		inx				inx
.01a423	88		dey				dey
.01a424	d0 f8		bne $01a41e			bne 	_FPUCopy1
.01a426	fa		plx				plx
.01a427	60		rts				rts
.01a428					FPUCopyFromNext:
.01a428	a0 06		ldy #$06			ldy 		#6
.01a42a	da		phx				phx
.01a42b					_FPUCopy1:
.01a42b	b5 86		lda $86,x			lda 	XS2_Mantissa,x
.01a42d	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a42f	e8		inx				inx
.01a430	88		dey				dey
.01a431	d0 f8		bne $01a42b			bne 	_FPUCopy1
.01a433	fa		plx				plx
.01a434	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.01a435					FPToString:
.01a435	48		pha				pha
.01a436	5a		phy				phy
.01a437	34 85		bit $85,x			bit 		XS_Type,x 				; check zero flag
.01a439	50 0a		bvc $01a445			bvc 		_FPTSIsFloat 			; if zero,
.01a43b					_FPTSZero:
.01a43b	a9 30		lda #$30			lda 		#"0"
.01a43d	20 5f 9f	jsr $019f5f			jsr 		ITSOutputCharacter
.01a440					_FPTSExit:
.01a440	7a		ply				ply
.01a441	68		pla				pla
.01a442	60		rts				rts
.01a443	80 fb		bra $01a440			bra 		_FPTSExit
.01a445					_FPTSIsFloat:
.01a445	b5 85		lda $85,x			lda 		XS_Type,x 				; is it signed ?
.01a447	10 09		bpl $01a452			bpl 		_FPTSNotSigned
.01a449	a9 00		lda #$00			lda 		#0 						; clear sign flag
.01a44b	95 85		sta $85,x			sta 		XS_Type,x
.01a44d	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.01a44f	20 5f 9f	jsr $019f5f			jsr 		ITSOutputCharacter
.01a452					_FPTSNotSigned:
.01a452	b5 84		lda $84,x			lda 		XS_Exponent,x
.01a454	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.01a456	b0 09		bcs $01a461			bcs 		_FPTSExponent
.01a458	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.01a45a	90 05		bcc $01a461			bcc 		_FPTSExponent 			;
.01a45c					_FPTSStandard:
.01a45c	20 a0 a4	jsr $01a4a0			jsr 		FPTOutputBody 			; output the body.
.01a45f	80 df		bra $01a440			bra 		_FPTSExit
.01a461					_FPTSExponent:
.01a461	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.01a463	8d 9d 03	sta $039d			sta 		ExpCount
.01a466					_FPTSExponentLoop:
.01a466	b5 84		lda $84,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.01a468	10 0e		bpl $01a478			bpl 		_FPTSTimes
.01a46a	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.01a46c	90 14		bcc $01a482			bcc 		_FPTSScaledToExp
.01a46e	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.01a470	20 dd a3	jsr $01a3dd			jsr 		FPUScale10A
.01a473	ee 9d 03	inc $039d			inc 		ExpCount
.01a476	80 ee		bra $01a466			bra 		_FPTSExponentLoop
.01a478					_FPTSTimes:
.01a478	a9 01		lda #$01			lda 		#1
.01a47a	20 dd a3	jsr $01a3dd			jsr 		FPUScale10A
.01a47d	ce 9d 03	dec $039d			dec 		ExpCount
.01a480	80 e4		bra $01a466			bra 		_FPTSExponentLoop
.01a482					_FPTSScaledToExp:
.01a482	20 a0 a4	jsr $01a4a0			jsr 		FPTOutputBody 			; output the body.
.01a485	a9 65		lda #$65			lda 		#"e"					; output E
.01a487	20 5f 9f	jsr $019f5f			jsr 		ITSOutputCharacter
.01a48a	ad 9d 03	lda $039d			lda 		ExpCount 				; get the exponent
.01a48d	95 80		sta $80,x			sta 		XS_Mantissa,x
.01a48f	29 80		and #$80			and 		#$80 					; sign extend it
.01a491	f0 02		beq $01a495			beq 		_FPTSSExt
.01a493	a9 ff		lda #$ff			lda 		#$FF
.01a495					_FPTSSExt:
.01a495	95 81		sta $81,x			sta 		XS_Mantissa+1,x
.01a497	95 82		sta $82,x			sta 		XS_Mantissa+2,x
.01a499	95 83		sta $83,x			sta 		XS_Mantissa+3,x
.01a49b	20 bd 9e	jsr $019ebd			jsr 		INTToString 			; output the exponent.
.01a49e	80 a0		bra $01a440			bra			_FPTSExit 				; and exit.
.01a4a0					FPTOutputBody:
.01a4a0	20 1b a4	jsr $01a41b			jsr 		FPUCopyToNext 			; copy to next slot.
.01a4a3	20 36 a3	jsr $01a336			jsr 		FPUToInteger 			; convert to an integer
.01a4a6	20 bd 9e	jsr $019ebd			jsr 		INTToString 			; output the main integer part.
.01a4a9	20 28 a4	jsr $01a428			jsr 		FPUCopyFromNext 		; get the fractional part back.
.01a4ac	20 b9 a1	jsr $01a1b9			jsr 		FPFractionalPart 		; get the decimal part.
.01a4af	34 85		bit $85,x			bit 		XS_Type,x 				; any fractional part.
.01a4b1	70 3c		bvs $01a4ef			bvs 		_FPTOExit 				; if not, exit now.
.01a4b3	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.01a4b5	20 5f 9f	jsr $019f5f			jsr 		ITSOutputCharacter
.01a4b8					_FPOutLoop:
.01a4b8	34 85		bit $85,x			bit 		XS_Type,x 				; finally reached zero.
.01a4ba	70 1d		bvs $01a4d9			bvs 		_FPStripZeros 			; strip trailing zeros
.01a4bc	20 8f a3	jsr $01a38f			jsr 		FPUTimes10 				; multiply by 10
.01a4bf	20 1b a4	jsr $01a41b			jsr 		FPUCopyToNext			; copy to next slot.
.01a4c2	20 36 a3	jsr $01a336			jsr 		FPUToInteger 			; convert to integer
.01a4c5	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; print digit.
.01a4c7	09 30		ora #$30			ora 		#"0"
.01a4c9	20 5f 9f	jsr $019f5f			jsr 		ITSOutputCharacter
.01a4cc	20 28 a4	jsr $01a428			jsr 		FPUCopyFromNext 		; get it back
.01a4cf	20 b9 a1	jsr $01a1b9			jsr 		FPFractionalPart 		; get fractional part
.01a4d2	ad 14 03	lda $0314			lda 		NumBufX 				; done 11 characters yet ?
.01a4d5	c9 0b		cmp #$0b			cmp 	 	#11
.01a4d7	90 df		bcc $01a4b8			bcc 		_FPOutLoop 				; if so, keep going till zero.
.01a4d9					_FPStripZeros:
.01a4d9	ac 14 03	ldy $0314			ldy 		NumBufX 				; strip trailing zeros.
.01a4dc					_FPStripLoop:
.01a4dc	88		dey				dey 								; back one, if at start then no strip
.01a4dd	f0 10		beq $01a4ef			beq 		_FPToExit
.01a4df	b9 15 03	lda $0315,y			lda 		Num_Buffer,y 			; keep going if "0"
.01a4e2	c9 30		cmp #$30			cmp 		#"0"
.01a4e4	f0 f6		beq $01a4dc			beq 		_FPStripLoop
.01a4e6	c8		iny				iny
.01a4e7	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.01a4e9	99 15 03	sta $0315,y			sta 		Num_Buffer,y
.01a4ec	8c 14 03	sty $0314			sty 		NumBufX 				; update position.
.01a4ef					_FPTOExit:
.01a4ef	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.01a4f0					FPFromString:
.01a4f0	48		pha				pha 								; push A
.01a4f1	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.01a4f3	c9 2e		cmp #$2e			cmp 	#"."
.01a4f5	f0 03		beq $01a4fa			beq	 	_FPFIsDecimal
.01a4f7	4c 56 a5	jmp $01a556			jmp 	_FPFNotDecimal
.01a4fa					_FPFIsDecimal:
.01a4fa	c8		iny				iny 								; consume the decimal.
.01a4fb	20 ea a2	jsr $01a2ea			jsr 	FPUToFloat 					; convert the integer to float.
.01a4fe	da		phx				phx 								; save X.
.01a4ff	5a		phy				phy 								; save decimal start position
.01a500	e8		inx				inx
.01a501	e8		inx				inx
.01a502	e8		inx				inx
.01a503	e8		inx				inx
.01a504	e8		inx				inx
.01a505	e8		inx				inx
.01a506	20 77 9f	jsr $019f77			jsr 	INTFromStringY 				; get the part after the DP.
.01a509	20 ea a2	jsr $01a2ea			jsr 	FPUToFloat 					; convert that to a float.
.01a50c	68		pla				pla 								; calculate - chars consumed.
.01a50d	8c 9c 03	sty $039c			sty 	ExpTemp
.01a510	38		sec				sec
.01a511	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; this is the shift amount
.01a514	20 dd a3	jsr $01a3dd			jsr 	FPUScale10A 				; scale it by 10^AC
.01a517	fa		plx				plx 								; restore original X
.01a518	20 0a a0	jsr $01a00a			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.01a51b	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.01a51d	c9 45		cmp #$45			cmp 	#"E"
.01a51f	f0 04		beq $01a525			beq 	_FPFExponent
.01a521	c9 65		cmp #$65			cmp 	#"e"
.01a523	d0 31		bne $01a556			bne 	_FPFNotDecimal 				; no, then exit normally.
.01a525					_FPFExponent:
.01a525	c8		iny				iny 								; skip over E symbol.
.01a526	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.01a528	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.01a52a	d0 01		bne $01a52d			bne 	_FPFGotSign
.01a52c	c8		iny				iny 								; if it was - skip over it.
.01a52d					_FPFGotSign:
.01a52d	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.01a52e	da		phx				phx
.01a52f	e8		inx				inx
.01a530	e8		inx				inx
.01a531	e8		inx				inx
.01a532	e8		inx				inx
.01a533	e8		inx				inx
.01a534	e8		inx				inx
.01a535	20 77 9f	jsr $019f77			jsr 	INTFromStringY 				; get the exponent
.01a538	fa		plx				plx 								; restore X.
.01a539	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.01a53b	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.01a53d	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.01a53f	d0 17		bne $01a558			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.01a541	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.01a543	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.01a545	b0 11		bcs $01a558			bcs 	_FPFXOverflow
.01a547	68		pla				pla 								; get direction
.01a548	d0 07		bne $01a551			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.01a54a	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.01a54c	49 ff		eor #$ff			eor 	#$FF
.01a54e	1a		inc a				inc 	a
.01a54f	95 86		sta $86,x			sta 	XS2_Mantissa+0,x
.01a551					_FPFXScale:
.01a551	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.01a553	20 dd a3	jsr $01a3dd			jsr 	FPUScale10A 				; scale by the exponent.
.01a556					_FPFNotDecimal:
.01a556	68		pla				pla
.01a557	60		rts				rts
.01a558					_FPFXOverflow:
.01a558	20 79 85	jsr $018579			jsr 	ERR_Handler
>01a55b	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>01a563	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.01a56a					Unary_Rnd:
.01a56a	20 d8 92	jsr $0192d8			jsr 	EvaluateNumberX 			; get value
.01a56d	20 2d 99	jsr $01992d			jsr 	CheckNextRParen 			; check right bracket.
.01a570	20 58 95	jsr $019558			jsr 	GetSignCurrent 				; get sign -1,0,1.
.01a573	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.01a575	30 10		bmi $01a587			bmi 	_URSetSeed
.01a577	f0 28		beq $01a5a1			beq 	_URMakeRandom 				; if zero return same number, don't advance sequence
.01a579	da		phx				phx
.01a57a	a2 00		ldx #$00			ldx 	#0 							; run 16 bit RNG procession on upper/lower
.01a57c	20 d8 a5	jsr $01a5d8			jsr 	Random16
.01a57f	a2 02		ldx #$02			ldx 	#2
.01a581	20 d8 a5	jsr $01a5d8			jsr 	Random16
.01a584	fa		plx				plx
.01a585	80 1a		bra $01a5a1			bra 	_URMakeRandom
.01a587					_URSetSeed:
.01a587	20 ea a2	jsr $01a2ea			jsr 	FPUToFloat 					; make it a float to twiddle it.
.01a58a	b5 80		lda $80,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.01a58c	8d a3 03	sta $03a3			sta 	RandomSeed+0
.01a58f	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.01a591	8d a4 03	sta $03a4			sta 	RandomSeed+1
.01a594	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.01a596	8d a5 03	sta $03a5			sta 	RandomSeed+2
.01a599	b5 83		lda $83,x			lda		XS_Mantissa+3,x 			; this is to make the seed bear not much
.01a59b	0a		asl a				asl 	a 							; resemblance to the seed value.
.01a59c	49 db		eor #$db			eor 	#$DB
.01a59e	8d a6 03	sta $03a6			sta 	RandomSeed+3
.01a5a1					_URMakeRandom:
.01a5a1	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; check if seed is zero.
.01a5a4	0d a4 03	ora $03a4			ora 	RandomSeed+1
.01a5a7	0d a5 03	ora $03a5			ora 	RandomSeed+2
.01a5aa	0d a6 03	ora $03a6			ora 	RandomSeed+3
.01a5ad	d0 0a		bne $01a5b9			bne 	_URNotZero
.01a5af	a9 47		lda #$47			lda 	#$47						; if it is, make it non zero.
.01a5b1	8d a4 03	sta $03a4			sta 	RandomSeed+1				; in both parts.
.01a5b4	a9 3d		lda #$3d			lda 	#$3D
.01a5b6	8d a6 03	sta $03a6			sta 	RandomSeed+3
.01a5b9					_URNotZero:
.01a5b9	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; copy seed into mantissa.
.01a5bc	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a5be	ad a4 03	lda $03a4			lda 	RandomSeed+1
.01a5c1	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a5c3	ad a5 03	lda $03a5			lda 	RandomSeed+2
.01a5c6	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a5c8	ad a6 03	lda $03a6			lda 	RandomSeed+3
.01a5cb	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a5cd	a9 00		lda #$00			lda 	#$00 						; set type to float.
.01a5cf	95 85		sta $85,x			sta 	XS_Type,x
.01a5d1	a9 80		lda #$80			lda 	#$80
.01a5d3	95 84		sta $84,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.01a5d5	4c 17 a3	jmp $01a317			jmp 	FPUNormalise 				; and normalise.
.01a5d8					Random16:
.01a5d8	5e a4 03	lsr $03a4,x			lsr 	RandomSeed+1,x				; shift seed right
.01a5db	7e a3 03	ror $03a3,x			ror 	RandomSeed,x
.01a5de	90 08		bcc $01a5e8			bcc 	_R16_NoXor
.01a5e0	bd a4 03	lda $03a4,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.01a5e3	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.01a5e5	9d a4 03	sta $03a4,x			sta 	RandomSeed+1,x
.01a5e8					_R16_NoXor:
.01a5e8	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.01a5e9					Unary_Int:
.01a5e9	20 d8 92	jsr $0192d8			jsr 	EvaluateNumberX 			; get value
.01a5ec	20 2d 99	jsr $01992d			jsr 	CheckNextRParen 			; check right bracket.
.01a5ef	4c 36 a3	jmp $01a336			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Return to file: basic.asm

>01a5f2	02						.byte 	2
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 c0						.word 	StartROM
>fffe	19 c0					.word TIM_BreakHandler

;******  End of listing
