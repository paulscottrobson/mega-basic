
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Sat Aug 24 16:28:30 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="4510"					cpu = "4510"
="mega65"				hardware = "mega65"
=1					exitonend = 1
=0					autorun = 0
=0					loadtest = 0
=1					hasfloat = 1
=1					hasinteger = 1
=253					maxstring = 253

;******  Processing file: modules/float/fpmacros.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/mega65/src_mega65.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0020					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0200					IFT_XCursor:.byte ?							; current logical position on screen
>0201					IFT_YCursor:.byte ?
>0202					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0266					IFT_LineBuffer: .fill 100 					; line input buffer.
>0300					UserVector .fill 4 							; USR(x) calls this.
>0304					LocalVector .fill 4 						; Indirect calls call this.
>0308					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>030c					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>030d					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=782					XS2_Mantissa = XS_Mantissa+XS_Size
=786					XS2_Exponent = XS_Exponent+XS_Size
=787					XS2_Type = XS_Type+XS_Size
=788					XS3_Mantissa = XS_Mantissa+XS_Size*2
=792					XS3_Exponent = XS_Exponent+XS_Size*2
=793					XS3_Type = XS_Type+XS_Size*2
>0400					NumBufX 	.byte 	?						; buffer index position
>0401					Num_Buffer	.fill 	32 						; buffer for numeric conversions
>0421					NumSuppress	.byte 	?						; leading zero suppression flag
>0422					NumConvCount .byte 	? 						; count for conversions.
>0423					ExpTemp:	.byte ?							; Working temp for exponents.
>0424					ExpCount:	.byte ? 						; Count of decimal exponents.
>0425					SignCount:	.byte ?							; Integer Divide Sign Counts.
>0426					StringPtr:	.word ? 						; Top of free memory (for string allocation)
>0428					TempStringWriteIndex: .byte ? 				; Write offset.
>0429					ValSign: 	.byte ? 						; sign flag for val()
>042a					SliceStart:	.byte ? 						; string slice parts
>042b					SliceCount:	.byte ?
>042c					RandomSeed:	.dword ? 						; Random seed.
>0430					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>0432					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>0434					Tim_SR:		.byte ? 						; Processor Status
>0435					Tim_A:		.byte ? 						; Processor Registers
>0436					Tim_X:		.byte ?
>0437					Tim_Y:		.byte ?
>0438					Tim_Z:		.byte ?
>0439					Tim_SP:		.byte ?							; Stack Pointer

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/mega65.asm

=$7000					HighMemory = $7000
.8000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testcode.src

>8000	12 02 00 d4 a7 b1 48 40			.byte	$12,$02,$00,$d4,$a7,$b1,$48,$40
>8008	40 8a 50 40 40 8c 42 bc			.byte	$40,$8a,$50,$40,$40,$8c,$42,$bc
>8010	bc 00 05 03 00 c2 00 00			.byte	$bc,$00,$05,$03,$00,$c2,$00,$00

;******  Return to file: modules/hardware/mega65.asm

.a000					StartROM:
.a000	a2 ff		ldx #$ff			ldx 		#$FF 					; empty stack
.a002	9a		txs				txs
.a003	20 4d a2	jsr $a24d			jsr 	IF_Reset 					; reset external interface
.a006	20 0c a0	jsr $a00c			jsr 	IFT_ClearScreen
.a009	4c b1 ad	jmp $adb1		jmp BASIC_Start

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.a00c					IFT_ClearScreen:
.a00c	48		pha				pha
.a00d	da		phx				phx
.a00e	5a		phy				phy
.a00f	20 b4 a1	jsr $a1b4			jsr 	IF_Home 					; home cursor
.a012	a2 19		ldx #$19			ldx 	#IF_Height 					; this many lines.
.a014					_IFT_CS0:
.a014	a0 50		ldy #$50			ldy 	#IF_Width 					; this many chars/line
.a016					_IFT_CS1:
.a016	a9 20		lda #$20			lda 	#' '						; clear line.
.a018	20 e3 a1	jsr $a1e3			jsr 	IF_Write
.a01b	88		dey				dey
.a01c	d0 f8		bne $a016			bne 	_IFT_CS1
.a01e	20 c3 a1	jsr $a1c3			jsr 	IF_NewLine 					; next line down
.a021	ca		dex				dex
.a022	d0 f0		bne $a014			bne 	_IFT_CS0
.a024	7a		ply				ply
.a025	fa		plx				plx
.a026	68		pla				pla
.a027					IFT_HomeCursor:
.a027	48		pha				pha
.a028	20 b4 a1	jsr $a1b4			jsr 	IF_Home
.a02b	a9 00		lda #$00			lda 	#0
.a02d	8d 00 02	sta $0200			sta 	IFT_XCursor
.a030	8d 01 02	sta $0201			sta 	IFT_YCursor
.a033	68		pla				pla
.a034	60		rts				rts
.a035					IFT_UpLine:
.a035	48		pha				pha
.a036	ad 01 02	lda $0201			lda  	IFT_YCursor 				; get Y
.a039	3a		dec a				dec 	a 							; line above
.a03a	30 03		bmi $a03f			bmi 	_IFTULExit 					; too far, abort
.a03c	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos					; set to that line.
.a03f					_IFTULExit:
.a03f	68		pla				pla
.a040	60		rts				rts
.a041					IFT_PrintCharacter:
.a041	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.a043	f0 23		beq $a068			beq 	IFT_NewLine
.a045	48		pha				pha
.a046	20 80 a0	jsr $a080			jsr 	IFT_UpperCase 				; make upper case
.a049	20 e3 a1	jsr $a1e3			jsr 	IF_Write 					; write out.
.a04c	ee 00 02	inc $0200			inc 	IFT_XCursor 				; bump x cursor
.a04f	ad 00 02	lda $0200			lda 	IFT_XCursor 				; reached RHS ?
.a052	c9 50		cmp #$50			cmp 	#IF_Width
.a054	d0 03		bne $a059			bne 	_IFT_PCNotEOL
.a056	20 68 a0	jsr $a068			jsr 	IFT_NewLine 				; if so do new line.
.a059					_IFT_PCNotEOL:
.a059	68		pla				pla
.a05a	60		rts				rts
.a05b					IFT_Tab:
.a05b	a9 20		lda #$20			lda 	#" " 						; space
.a05d	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.a060	ad 00 02	lda $0200			lda 	IFT_XCursor 				; until x % 8 == 0
.a063	29 07		and #$07			and 	#7
.a065	d0 f4		bne $a05b			bne 	IFT_Tab
.a067	60		rts				rts
.a068					IFT_NewLine:
.a068	48		pha				pha
.a069	20 c3 a1	jsr $a1c3			jsr 	IF_NewLine 					; new line on actual screen.
.a06c	a9 00		lda #$00			lda 	#0 							; reset x position
.a06e	8d 00 02	sta $0200			sta 	IFT_XCursor
.a071	ee 01 02	inc $0201			inc 	IFT_YCursor 				; move down.
.a074	ad 01 02	lda $0201			lda 	IFT_YCursor
.a077	c9 19		cmp #$19			cmp 	#IF_Height 					; reached bottom.
.a079	d0 03		bne $a07e			bne 	_IFT_NL_NotEOS
.a07b	20 8b a0	jsr $a08b			jsr 	IFT_Scroll 					; scroll screen up.
.a07e					_IFT_NL_NotEOS:
.a07e	68		pla				pla
.a07f	60		rts				rts
.a080					IFT_UpperCase:
.a080	c9 61		cmp #$61			cmp 	#"a"
.a082	90 06		bcc $a08a			bcc 	_IFT_UCExit
.a084	c9 7b		cmp #$7b			cmp 	#"z"+1
.a086	b0 02		bcs $a08a			bcs 	_IFT_UCExit
.a088	49 20		eor #$20			eor 	#$20
.a08a					_IFT_UCExit:
.a08a	60		rts				rts
.a08b					IFT_Scroll:
.a08b	48		pha				pha 								; save AXY
.a08c	da		phx				phx
.a08d	5a		phy				phy
.a08e	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.a090					_IFT_SLoop:
.a090	20 b0 a0	jsr $a0b0			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.a093	e8		inx				inx
.a094	e0 18		cpx #$18			cpx 	#IF_Height-1				; do whole screen
.a096	d0 f8		bne $a090			bne 	_IFT_SLoop
.a098	a9 18		lda #$18			lda 	#IF_Height-1 				; move to X = 0,Y = A
.a09a	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a09d	a2 50		ldx #$50			ldx 	#IF_Width 					; blank line
.a09f					_IFT_SBlank:
.a09f	a9 20		lda #$20			lda 	#32
.a0a1	20 e3 a1	jsr $a1e3			jsr 	IF_Write
.a0a4	ca		dex				dex
.a0a5	d0 f8		bne $a09f			bne 	_IFT_SBlank
.a0a7	a9 18		lda #$18			lda 	#IF_Height-1 				; move to X = 0,Y = A
.a0a9	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a0ac	7a		ply				ply
.a0ad	fa		plx				plx
.a0ae	68		pla				pla
.a0af	60		rts				rts
.a0b0					_IFT_ScrollLine:
.a0b0	da		phx				phx
.a0b1	da		phx				phx
.a0b2	8a		txa				txa 								; copy line into buffer.
.a0b3	1a		inc a				inc 	a 							; next line down.
.a0b4	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a0b7	a2 00		ldx #$00			ldx 	#0
.a0b9					_IFTScrollCopy1:
.a0b9	20 d5 a1	jsr $a1d5			jsr 	IF_Read
.a0bc	9d 02 02	sta $0202,x			sta 	IFT_Buffer,x
.a0bf	e8		inx				inx
.a0c0	e0 50		cpx #$50			cpx 	#IF_Width
.a0c2	d0 f5		bne $a0b9			bne 	_IFTScrollCopy1
.a0c4	68		pla				pla
.a0c5	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a0c8	a2 00		ldx #$00			ldx 	#0
.a0ca					_IFTScrollCopy2:
.a0ca	bd 02 02	lda $0202,x			lda 	IFT_Buffer,x
.a0cd	20 e3 a1	jsr $a1e3			jsr 	IF_Write
.a0d0	e8		inx				inx
.a0d1	e0 50		cpx #$50			cpx 	#IF_Width
.a0d3	d0 f5		bne $a0ca			bne 	_IFTScrollCopy2
.a0d5	fa		plx				plx
.a0d6	60		rts				rts
.a0d7					IFT_SetYPos:
.a0d7	48		pha				pha
.a0d8	da		phx				phx
.a0d9	aa		tax				tax
.a0da	20 27 a0	jsr $a027			jsr 	IFT_HomeCursor
.a0dd	e0 00		cpx #$00			cpx 	#0
.a0df	f0 09		beq $a0ea			beq 	_IFT_MOAExit
.a0e1					_IFT_MOALoop:
.a0e1	20 c3 a1	jsr $a1c3			jsr 	IF_NewLine
.a0e4	ee 01 02	inc $0201			inc 	IFT_YCursor
.a0e7	ca		dex				dex
.a0e8	d0 f7		bne $a0e1			bne		_IFT_MOALoop
.a0ea					_IFT_MOAExit:
.a0ea	fa		plx				plx
.a0eb	68		pla				pla
.a0ec	60		rts				rts
.a0ed					IFT_GetKeyCursor:
.a0ed	20 f5 a0	jsr $a0f5			jsr 	_IFT_FlipCursor 			; reverse current
.a0f0					_IFT_GKCWait:
.a0f0	20 06 a2	jsr $a206			jsr 	IF_GetKey 					; get key
.a0f3	f0 fb		beq $a0f0			beq 	_IFT_GKCWait
.a0f5					_IFT_FlipCursor:
.a0f5	48		pha				pha 								; save
.a0f6	20 d5 a1	jsr $a1d5			jsr 	IF_Read 					; read
.a0f9	20 ee a1	jsr $a1ee			jsr 	IF_LeftOne
.a0fc	49 80		eor #$80			eor 	#$80 						; reverse
.a0fe	20 e3 a1	jsr $a1e3			jsr 	IF_Write 					; write
.a101	20 ee a1	jsr $a1ee			jsr 	IF_LeftOne
.a104	68		pla				pla
.a105	60		rts				rts
.a106					IFT_ReadLine:
.a106	48		pha				pha
.a107					_IFT_RLLoop:
.a107	20 ed a0	jsr $a0ed			jsr 	IFT_GetKeyCursor 			; get keystroke
.a10a	c9 0d		cmp #$0d			cmp 	#13							; return
.a10c	f0 7d		beq $a18b			beq 	_IFT_RLExit
.a10e	c9 20		cmp #$20			cmp 	#32 						; control character
.a110	90 05		bcc $a117			bcc 	_IFT_Control
.a112	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.a115	80 f0		bra $a107			bra 	_IFT_RLLoop
.a117					_IFT_Control:
.a117	c9 01		cmp #$01			cmp 	#"A"-64
.a119	f0 26		beq $a141			beq 	_IFT_Left
.a11b	c9 04		cmp #$04			cmp 	#"D"-64
.a11d	f0 2e		beq $a14d			beq 	_IFT_Right
.a11f	c9 17		cmp #$17			cmp 	#"W"-64
.a121	f0 36		beq $a159			beq 	_IFT_Up
.a123	c9 13		cmp #$13			cmp 	#"S"-64
.a125	f0 3e		beq $a165			beq 	_IFT_Down
.a127	c9 08		cmp #$08			cmp 	#"H"-64
.a129	f0 09		beq $a134			beq 	_IFT_Backspace
.a12b	c9 1a		cmp #$1a			cmp 	#"Z"-64
.a12d	d0 d8		bne $a107			bne 	_IFT_RLLoop
.a12f	20 0c a0	jsr $a00c			jsr 	IFT_ClearScreen				; clear CTL-Z
.a132	80 d3		bra $a107			bra 	_IFT_RLLoop
.a134					_IFT_Backspace:
.a134	ad 00 02	lda $0200			lda 	IFT_XCursor 				; check not start of line.
.a137	f0 ce		beq $a107			beq 	_IFT_RLLoop
.a139	20 ee a1	jsr $a1ee			jsr 	IF_LeftOne
.a13c	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.a13e	20 e3 a1	jsr $a1e3			jsr 	IF_Write
.a141					_IFT_Left:
.a141	ce 00 02	dec $0200			dec 	IFT_XCursor 				; left CTL-W
.a144	10 29		bpl $a16f			bpl 	_IFT_Reposition
.a146	a9 4f		lda #$4f			lda 	#IF_Width-1
.a148					_IFT_SetX:
.a148	8d 00 02	sta $0200			sta 	IFT_XCursor
.a14b	80 22		bra $a16f			bra 	_IFT_Reposition
.a14d					_IFT_Right:
.a14d	ee 00 02	inc $0200			inc 	IFT_XCursor
.a150	ad 00 02	lda $0200			lda 	IFT_XCursor
.a153	49 50		eor #$50			eor 	#IF_Width
.a155	f0 f1		beq $a148			beq 	_IFT_SetX
.a157	80 16		bra $a16f			bra 	_IFT_Reposition
.a159					_IFT_Up:
.a159	ce 01 02	dec $0201			dec 	IFT_YCursor
.a15c	10 11		bpl $a16f			bpl 	_IFT_Reposition
.a15e	a9 18		lda #$18			lda 	#IF_Height-1
.a160					_IFT_SetY:
.a160	8d 01 02	sta $0201			sta 	IFT_YCursor
.a163	80 0a		bra $a16f			bra 	_IFT_Reposition
.a165					_IFT_Down:
.a165	ee 01 02	inc $0201			inc 	IFT_YCursor
.a168	ad 01 02	lda $0201			lda 	IFT_YCursor
.a16b	49 19		eor #$19			eor 	#IF_Height
.a16d	f0 f1		beq $a160			beq 	_IFT_SetY
.a16f					_IFT_Reposition:
.a16f	ad 00 02	lda $0200			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.a172	48		pha				pha
.a173	ad 01 02	lda $0201			lda 	IFT_YCursor
.a176	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a179	68		pla				pla
.a17a	aa		tax				tax
.a17b	e0 00		cpx #$00			cpx 	#0
.a17d	f0 88		beq $a107			beq 	_IFT_RLLoop
.a17f					_IFT_MoveRight:
.a17f	20 d5 a1	jsr $a1d5			jsr 	IF_Read
.a182	ee 00 02	inc $0200			inc 	IFT_XCursor
.a185	ca		dex				dex
.a186	d0 f7		bne $a17f			bne 	_IFT_MoveRight
.a188	4c 07 a1	jmp $a107			jmp 	_IFT_RLLoop
.a18b					_IFT_RLExit:
.a18b	ad 01 02	lda $0201			lda 	IFT_YCursor 				; go to start of line.
.a18e	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a191	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.a193					_IFT_RLRead:
.a193	20 d5 a1	jsr $a1d5			jsr 	IF_Read
.a196	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.a199	e8		inx				inx
.a19a	e0 50		cpx #$50			cpx 	#IF_Width
.a19c	d0 f5		bne $a193			bne 	_IFT_RLRead
.a19e					_IFT_RL_Trim:
.a19e	ca		dex				dex 	 							; previous char
.a19f	30 07		bmi $a1a8			bmi 	_IFT_Found 					; gone too far
.a1a1	bd 66 02	lda $0266,x			lda 	IFT_LineBuffer,x			; go back if space
.a1a4	c9 20		cmp #$20			cmp 	#" "
.a1a6	f0 f6		beq $a19e			beq 	_IFT_RL_Trim
.a1a8					_IFT_Found:
.a1a8	e8		inx				inx 								; forward to non-space
.a1a9	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.a1ab	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.a1ae	68		pla				pla
.a1af	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.a1b1	a0 02		ldy #$02			ldy 	#IFT_LineBuffer >> 8
.a1b3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_mega65.asm

=80					IF_Width 	= 80 							; characters across
=25					IF_Height 	= 25 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line
=6					IF_XPos 	= 6 							; current position, horizontal.
=8					IF_FarPtr 	= 8 							; far pointer (4 bytes)
=$1000					IF_Screen = $1000							; 2k screen RAM here
=$800					IF_CharSet = $800							; 2k character set (0-7F) here
.a1b4					IF_Home:
.a1b4	48		pha				pha 								; reset cursor position
.a1b5	a9 00		lda #$00			lda 	#IF_Screen & $FF
.a1b7	85 04		sta $04				sta 	IF_Pos
.a1b9	a9 10		lda #$10			lda 	#IF_Screen >> 8
.a1bb	85 05		sta $05				sta 	IF_Pos+1
.a1bd	a9 00		lda #$00			lda 	#0
.a1bf	85 06		sta $06				sta 	IF_XPos
.a1c1	68		pla				pla
.a1c2	60		rts				rts
.a1c3					IF_NewLine:
.a1c3	48		pha				pha
.a1c4	a9 00		lda #$00			lda 	#0 							; back to start of line
.a1c6	85 06		sta $06				sta 	IF_XPos
.a1c8	18		clc				clc 								; down one line
.a1c9	a5 04		lda $04				lda 	IF_Pos
.a1cb	69 50		adc #$50			adc 	#80
.a1cd	85 04		sta $04				sta 	IF_Pos
.a1cf	90 02		bcc $a1d3			bcc 	_IF_NoCarry 				; carry through.
.a1d1	e6 05		inc $05				inc 	IF_Pos+1
.a1d3					_IF_NoCarry:
.a1d3	68		pla				pla
.a1d4	60		rts				rts
.a1d5					IF_Read:
.a1d5	5a		phy				phy 								; save current Y
.a1d6	a4 06		ldy $06				ldy 	IF_XPos 					; read character at current position
.a1d8	b1 04		lda ($04),y			lda 	(IF_Pos),y
.a1da	49 20		eor #$20			eor 	#$20
.a1dc	18		clc				clc
.a1dd	69 20		adc #$20			adc 	#$20
.a1df	e6 06		inc $06				inc 	IF_XPos 					; step right.
.a1e1	7a		ply				ply									; restore Y
.a1e2	60		rts				rts
.a1e3					IF_Write:
.a1e3	5a		phy				phy 								; save current Y
.a1e4	a4 06		ldy $06				ldy 	IF_XPos 					; write character at current position
.a1e6	29 bf		and #$bf			and 	#63+128 					; PETSCII
.a1e8	91 04		sta ($04),y			sta 	(IF_Pos),y
.a1ea	e6 06		inc $06				inc 	IF_XPos 					; step right.
.a1ec	7a		ply				ply									; restore Y
.a1ed	60		rts				rts
.a1ee					IF_LeftOne:
.a1ee	c6 06		dec $06				dec 	IF_XPos
.a1f0	60		rts				rts
.a1f1					IF_CheckBreak:
.a1f1	db		phz				phz
.a1f2	20 3a a2	jsr $a23a			jsr 	IF_SetupKeyAddress 			; point to keyboard
.a1f5	e6 08		inc $08				inc 	IF_FarPtr 					; point to modifiers.
.a1f7	ea		nop				nop 								; read modifiers.
.a1f8	b2 08		lda ($08),z			lda 	(IF_FarPtr),z
.a1fa	fb		plz				plz 								; restore Z
.a1fb	29 05		and #$05			and 	#5							; break is LeftShift+Ctrl
.a1fd	c9 05		cmp #$05			cmp 	#5
.a1ff	f0 02		beq $a203			beq 	_IF_CBExit
.a201	a9 00		lda #$00			lda 	#0
.a203					_IF_CBExit:
.a203	c9 00		cmp #$00			cmp 	#0
.a205	60		rts				rts
.a206					IF_GetKey:
.a206	db		phz				phz
.a207	20 3a a2	jsr $a23a			jsr 	IF_SetupKeyAddress
.a20a	ea		nop				nop 								; read keyboard
.a20b	b2 08		lda ($08),z			lda 	(IF_FarPtr),z
.a20d	c9 14		cmp #$14			cmp 	#20
.a20f	d0 02		bne $a213			bne 	_KMNo
.a211	a9 08		lda #$08			lda 	#"H"-64
.a213					_KMNo:
.a213	c9 91		cmp #$91			cmp 	#145
.a215	d0 02		bne $a219			bne 	_KMNo
.a217	a9 17		lda #$17			lda 	#"W"-64
.a219					_KMNo:
.a219	c9 11		cmp #$11			cmp 	#17
.a21b	d0 02		bne $a21f			bne 	_KMNo
.a21d	a9 13		lda #$13			lda 	#"S"-64
.a21f					_KMNo:
.a21f	c9 9d		cmp #$9d			cmp 	#157
.a221	d0 02		bne $a225			bne 	_KMNo
.a223	a9 01		lda #$01			lda 	#"A"-64
.a225					_KMNo:
.a225	c9 1d		cmp #$1d			cmp 	#29
.a227	d0 02		bne $a22b			bne 	_KMNo
.a229	a9 04		lda #$04			lda 	#"D"-64
.a22b					_KMNo:
.a22b	c9 00		cmp #$00			cmp 	#0
.a22d	f0 07		beq $a236			beq 	_IFGKEmpty
.a22f	48		pha				pha
.a230	a9 00		lda #$00			lda 	#0
.a232	ea		nop				nop
.a233	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a235	68		pla				pla
.a236					_IFGKEmpty:
.a236	fb		plz				plz
.a237	c9 00		cmp #$00			cmp 	#0 							; set Z
.a239	60		rts				rts
.a23a					IF_SetupKeyAddress:
.a23a	a9 0f		lda #$0f			lda 	#$0F 						; set up to write to read keyboard.
.a23c	85 0b		sta $0b				sta 	IF_FarPtr+3
.a23e	a9 fd		lda #$fd			lda 	#$FD
.a240	85 0a		sta $0a				sta 	IF_FarPtr+2
.a242	a9 36		lda #$36			lda 	#$36
.a244	85 09		sta $09				sta 	IF_FarPtr+1
.a246	a9 10		lda #$10			lda 	#$10
.a248	85 08		sta $08				sta 	IF_FarPtr+0
.a24a	a3 00		ldz #$00			ldz 	#0
.a24c	60		rts				rts
.a24d					IF_Reset:
.a24d	48		pha				pha 								; save registers
.a24e	da		phx				phx
.a24f	5a		phy				phy
.a250	a9 0f		lda #$0f			lda 	#$0F 						; set up to write to video system.
.a252	85 0b		sta $0b				sta 	IF_FarPtr+3
.a254	a9 fd		lda #$fd			lda 	#$FD
.a256	85 0a		sta $0a				sta 	IF_FarPtr+2
.a258	a9 30		lda #$30			lda 	#$30
.a25a	85 09		sta $09				sta 	IF_FarPtr+1
.a25c	a9 00		lda #$00			lda 	#$00
.a25e	85 08		sta $08				sta 	IF_FarPtr+0
.a260	a3 2f		ldz #$2f			ldz 	#$2F 						; address already set up
.a262	a9 47		lda #$47			lda 	#$47
.a264	ea		nop				nop
.a265	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a267	a3 2f		ldz #$2f			ldz 	#$2F 						; address already set up
.a269	a9 53		lda #$53			lda 	#$53
.a26b	ea		nop				nop
.a26c	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a26e	a3 30		ldz #$30			ldz 	#$30 						; address already set up
.a270	a9 40		lda #$40			lda 	#$40
.a272	ea		nop				nop
.a273	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a275	a3 31		ldz #$31			ldz 	#$31 						; address already set up
.a277	a9 c0		lda #$c0			lda 	#$80+$40
.a279	ea		nop				nop
.a27a	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a27c	a3 20		ldz #$20			ldz 	#$20 						; address already set up
.a27e	a9 00		lda #$00			lda 	#0
.a280	ea		nop				nop
.a281	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a283	a3 21		ldz #$21			ldz 	#$21 						; address already set up
.a285	a9 00		lda #$00			lda 	#0
.a287	ea		nop				nop
.a288	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a28a	a3 54		ldz #$54			ldz 	#$54 						; address already set up
.a28c	a9 40		lda #$40			lda 	#$40
.a28e	ea		nop				nop
.a28f	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a291	a3 01		ldz #$01			ldz 	#$01 						; address already set up
.a293	a9 ff		lda #$ff			lda 	#$FF
.a295	ea		nop				nop
.a296	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a298	a3 00		ldz #$00			ldz 	#$00 						; address already set up
.a29a	a9 ff		lda #$ff			lda 	#$FF
.a29c	ea		nop				nop
.a29d	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a29f	a3 16		ldz #$16			ldz 	#$16 						; address already set up
.a2a1	a9 cc		lda #$cc			lda 	#$CC
.a2a3	ea		nop				nop
.a2a4	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2a6	a3 18		ldz #$18			ldz 	#$18 						; address already set up
.a2a8	a9 42		lda #$42			lda 	#$42
.a2aa	ea		nop				nop
.a2ab	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2ad	a3 11		ldz #$11			ldz 	#$11 						; address already set up
.a2af	a9 1b		lda #$1b			lda 	#$1B
.a2b1	ea		nop				nop
.a2b2	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2b4	a9 00		lda #$00			lda 	#$00						; colour RAM at $1F800-1FFFF (2kb)
.a2b6	85 0b		sta $0b				sta 	IF_FarPtr+3
.a2b8	a9 01		lda #$01			lda 	#$01
.a2ba	85 0a		sta $0a				sta 	IF_FarPtr+2
.a2bc	a9 f8		lda #$f8			lda 	#$F8
.a2be	85 09		sta $09				sta 	IF_FarPtr+1
.a2c0	a9 00		lda #$00			lda 	#$00
.a2c2	85 08		sta $08				sta 	IF_FarPtr+0
.a2c4	a3 00		ldz #$00			ldz 	#0
.a2c6					_EXTClearColorRam:
.a2c6	a9 05		lda #$05			lda 	#5							; fill that with this colour.
.a2c8	ea		nop				nop
.a2c9	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2cb	3b		dez				dez
.a2cc	d0 f8		bne $a2c6			bne 	_EXTClearColorRam
.a2ce	e6 09		inc $09				inc 	IF_FarPtr+1
.a2d0	d0 f4		bne $a2c6			bne 	_EXTClearColorRam
.a2d2	a2 00		ldx #$00			ldx 	#0 							; copy PET Font into memory.
.a2d4					_EXTCopyCBMFont:
.a2d4	bd 15 a3	lda $a315,x			lda 	IF_CBMFont,x 				; +$800 uses the lower case c/set
.a2d7	9d 00 08	sta $0800,x			sta 	IF_CharSet,x
.a2da	49 ff		eor #$ff			eor 	#$FF
.a2dc	9d 00 0c	sta $0c00,x			sta 	IF_CharSet+$400,x
.a2df	bd 15 a4	lda $a415,x			lda 	IF_CBMFont+$100,x
.a2e2	9d 00 09	sta $0900,x			sta 	IF_CharSet+$100,x
.a2e5	49 ff		eor #$ff			eor 	#$FF
.a2e7	9d 00 0d	sta $0d00,x			sta 	IF_CharSet+$500,x
.a2ea	bd 15 a5	lda $a515,x			lda 	IF_CBMFont+$200,x
.a2ed	9d 00 0a	sta $0a00,x			sta 	IF_CharSet+$200,x
.a2f0	49 ff		eor #$ff			eor 	#$FF
.a2f2	9d 00 0e	sta $0e00,x			sta 	IF_CharSet+$600,x
.a2f5	bd 15 a6	lda $a615,x			lda 	IF_CBMFont+$300,x
.a2f8	9d 00 0b	sta $0b00,x			sta 	IF_CharSet+$300,x
.a2fb	49 ff		eor #$ff			eor 	#$FF
.a2fd	9d 00 0f	sta $0f00,x			sta 	IF_CharSet+$700,x
.a300	ca		dex				dex
.a301	d0 d1		bne $a2d4			bne 	_EXTCopyCBMFont
.a303	a9 3b		lda #$3b			lda 	#$3F-4  					; puts ROM back in the map (the -4)
.a305	85 01		sta $01				sta 	$01
.a307	a9 00		lda #$00			lda 	#$00						; do not map bytes 0000-7FFF
.a309	a2 00		ldx #$00			ldx 	#$00						; (so we use the RAM physically at $0000-$7FFF)
.a30b	a0 00		ldy #$00			ldy 	#$00 						; 8000-FFFF offset by $200. The lower 8 bits are $00
.a30d	a3 f2		ldz #$f2			ldz 	#$F2 						; so this is an actual offset of $20000. So the space at
.a30f	5c		map				map
.a310	ea		nop				eom
.a311	7a		ply				ply 								; restore and exit.
.a312	fa		plx				plx
.a313	68		pla				pla
.a314	60		rts				rts
.a315					IF_CBMFont:
>a315	1c 22 4a 56 4c 20 1e 00				.binary "pet-font.bin"
>a31d	18 24 42 7e 42 42 42 00 7c 22 22 3c 22 22 7c 00
>a32d	1c 22 40 40 40 22 1c 00 78 24 22 22 22 24 78 00
>a33d	7e 40 40 78 40 40 7e 00 7e 40 40 78 40 40 40 00
>a34d	1c 22 40 4e 42 22 1c 00 42 42 42 7e 42 42 42 00
>a35d	1c 08 08 08 08 08 1c 00 0e 04 04 04 04 44 38 00
>a36d	42 44 48 70 48 44 42 00 40 40 40 40 40 40 7e 00
>a37d	42 66 5a 5a 42 42 42 00 42 62 52 4a 46 42 42 00
>a38d	18 24 42 42 42 24 18 00 7c 42 42 7c 40 40 40 00
>a39d	18 24 42 42 4a 24 1a 00 7c 42 42 7c 48 44 42 00
>a3ad	3c 42 40 3c 02 42 3c 00 3e 08 08 08 08 08 08 00
>a3bd	42 42 42 42 42 42 3c 00 42 42 42 24 24 18 18 00
>a3cd	42 42 42 5a 5a 66 42 00 42 42 24 18 24 42 42 00
>a3dd	22 22 22 1c 08 08 08 00 7e 02 04 18 20 40 7e 00
>a3ed	3c 20 20 20 20 20 3c 00 00 40 20 10 08 04 02 00
>a3fd	3c 04 04 04 04 04 3c 00 00 08 1c 2a 08 08 08 08
>a40d	00 00 10 20 7f 20 10 00 00 00 00 00 00 00 00 00
>a41d	08 08 08 08 00 00 08 00 24 24 24 00 00 00 00 00
>a42d	24 24 7e 24 7e 24 24 00 08 1e 28 1c 0a 3c 08 00
>a43d	00 62 64 08 10 26 46 00 30 48 48 30 4a 44 3a 00
>a44d	04 08 10 00 00 00 00 00 04 08 10 10 10 08 04 00
>a45d	20 10 08 08 08 10 20 00 08 2a 1c 3e 1c 2a 08 00
>a46d	00 08 08 3e 08 08 00 00 00 00 00 00 00 08 08 10
>a47d	00 00 00 7e 00 00 00 00 00 00 00 00 00 18 18 00
>a48d	00 02 04 08 10 20 40 00 3c 42 46 5a 62 42 3c 00
>a49d	08 18 28 08 08 08 3e 00 3c 42 02 0c 30 40 7e 00
>a4ad	3c 42 02 1c 02 42 3c 00 04 0c 14 24 7e 04 04 00
>a4bd	7e 40 78 04 02 44 38 00 1c 20 40 7c 42 42 3c 00
>a4cd	7e 42 04 08 10 10 10 00 3c 42 42 3c 42 42 3c 00
>a4dd	3c 42 42 3e 02 04 38 00 00 00 08 00 00 08 00 00
>a4ed	00 00 08 00 00 08 08 10 0e 18 30 60 30 18 0e 00
>a4fd	00 00 7e 00 7e 00 00 00 70 18 0c 06 0c 18 70 00
>a50d	3c 42 02 0c 10 00 10 00 00 00 00 00 ff 00 00 00
>a51d	08 1c 3e 7f 7f 1c 3e 00 10 10 10 10 10 10 10 10
>a52d	00 00 00 ff 00 00 00 00 00 00 ff 00 00 00 00 00
>a53d	00 ff 00 00 00 00 00 00 00 00 00 00 00 ff 00 00
>a54d	20 20 20 20 20 20 20 20 04 04 04 04 04 04 04 04
>a55d	00 00 00 00 e0 10 08 08 08 08 08 04 03 00 00 00
>a56d	08 08 08 10 e0 00 00 00 80 80 80 80 80 80 80 ff
>a57d	80 40 20 10 08 04 02 01 01 02 04 08 10 20 40 80
>a58d	ff 80 80 80 80 80 80 80 ff 01 01 01 01 01 01 01
>a59d	00 3c 7e 7e 7e 7e 3c 00 00 00 00 00 00 00 ff 00
>a5ad	36 7f 7f 7f 3e 1c 08 00 40 40 40 40 40 40 40 40
>a5bd	00 00 00 00 03 04 08 08 81 42 24 18 18 24 42 81
>a5cd	00 3c 42 42 42 42 3c 00 08 1c 2a 77 2a 08 08 00
>a5dd	02 02 02 02 02 02 02 02 08 1c 3e 7f 3e 1c 08 00
>a5ed	08 08 08 08 ff 08 08 08 a0 50 a0 50 a0 50 a0 50
>a5fd	08 08 08 08 08 08 08 08 00 00 01 3e 54 14 14 00
>a60d	ff 7f 3f 1f 0f 07 03 01 00 00 00 00 00 00 00 00
>a61d	f0 f0 f0 f0 f0 f0 f0 f0 00 00 00 00 ff ff ff ff
>a62d	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff
>a63d	80 80 80 80 80 80 80 80 aa 55 aa 55 aa 55 aa 55
>a64d	01 01 01 01 01 01 01 01 00 00 00 00 aa 55 aa 55
>a65d	ff fe fc f8 f0 e0 c0 80 03 03 03 03 03 03 03 03
>a66d	08 08 08 08 0f 08 08 08 00 00 00 00 0f 0f 0f 0f
>a67d	08 08 08 08 0f 00 00 00 00 00 00 00 f8 08 08 08
>a68d	00 00 00 00 00 00 ff ff 00 00 00 00 0f 08 08 08
>a69d	08 08 08 08 ff 00 00 00 00 00 00 00 ff 08 08 08
>a6ad	08 08 08 08 f8 08 08 08 c0 c0 c0 c0 c0 c0 c0 c0
>a6bd	e0 e0 e0 e0 e0 e0 e0 e0 07 07 07 07 07 07 07 07
>a6cd	ff ff 00 00 00 00 00 00 ff ff ff 00 00 00 00 00
>a6dd	00 00 00 00 00 ff ff ff 01 01 01 01 01 01 01 ff
>a6ed	00 00 00 00 f0 f0 f0 f0 0f 0f 0f 0f 00 00 00 00
>a6fd	08 08 08 08 f8 00 00 00 f0 f0 f0 f0 00 00 00 00
>a70d	f0 f0 f0 f0 0f 0f 0f 0f 1c 22 4a 56 4c 20 1e 00
>a71d	18 24 42 7e 42 42 42 00 7c 22 22 3c 22 22 7c 00
>a72d	1c 22 40 40 40 22 1c 00 78 24 22 22 22 24 78 00
>a73d	7e 40 40 78 40 40 7e 00 7e 40 40 78 40 40 40 00
>a74d	1c 22 40 4e 42 22 1c 00 42 42 42 7e 42 42 42 00
>a75d	1c 08 08 08 08 08 1c 00 0e 04 04 04 04 44 38 00
>a76d	42 44 48 70 48 44 42 00 40 40 40 40 40 40 7e 00
>a77d	42 66 5a 5a 42 42 42 00 42 62 52 4a 46 42 42 00
>a78d	18 24 42 42 42 24 18 00 7c 42 42 7c 40 40 40 00
>a79d	18 24 42 42 4a 24 1a 00 7c 42 42 7c 48 44 42 00
>a7ad	3c 42 40 3c 02 42 3c 00 3e 08 08 08 08 08 08 00
>a7bd	42 42 42 42 42 42 3c 00 42 42 42 24 24 18 18 00
>a7cd	42 42 42 5a 5a 66 42 00 42 42 24 18 24 42 42 00
>a7dd	22 22 22 1c 08 08 08 00 7e 02 04 18 20 40 7e 00
>a7ed	3c 20 20 20 20 20 3c 00 00 40 20 10 08 04 02 00
>a7fd	3c 04 04 04 04 04 3c 00 00 08 1c 2a 08 08 08 08
>a80d	00 00 10 20 7f 20 10 00 00 00 00 00 00 00 00 00
>a81d	08 08 08 08 00 00 08 00 24 24 24 00 00 00 00 00
>a82d	24 24 7e 24 7e 24 24 00 08 1e 28 1c 0a 3c 08 00
>a83d	00 62 64 08 10 26 46 00 30 48 48 30 4a 44 3a 00
>a84d	04 08 10 00 00 00 00 00 04 08 10 10 10 08 04 00
>a85d	20 10 08 08 08 10 20 00 08 2a 1c 3e 1c 2a 08 00
>a86d	00 08 08 3e 08 08 00 00 00 00 00 00 00 08 08 10
>a87d	00 00 00 7e 00 00 00 00 00 00 00 00 00 18 18 00
>a88d	00 02 04 08 10 20 40 00 3c 42 46 5a 62 42 3c 00
>a89d	08 18 28 08 08 08 3e 00 3c 42 02 0c 30 40 7e 00
>a8ad	3c 42 02 1c 02 42 3c 00 04 0c 14 24 7e 04 04 00
>a8bd	7e 40 78 04 02 44 38 00 1c 20 40 7c 42 42 3c 00
>a8cd	7e 42 04 08 10 10 10 00 3c 42 42 3c 42 42 3c 00
>a8dd	3c 42 42 3e 02 04 38 00 00 00 08 00 00 08 00 00
>a8ed	00 00 08 00 00 08 08 10 0e 18 30 60 30 18 0e 00
>a8fd	00 00 7e 00 7e 00 00 00 70 18 0c 06 0c 18 70 00
>a90d	3c 42 02 0c 10 00 10 00 00 00 00 00 ff 00 00 00
>a91d	00 00 38 04 3c 44 3a 00 40 40 5c 62 42 62 5c 00
>a92d	00 00 3c 42 40 42 3c 00 02 02 3a 46 42 46 3a 00
>a93d	00 00 3c 42 7e 40 3c 00 0c 12 10 7c 10 10 10 00
>a94d	00 00 3a 46 46 3a 02 3c 40 40 5c 62 42 42 42 00
>a95d	08 00 18 08 08 08 1c 00 04 00 0c 04 04 04 44 38
>a96d	40 40 44 48 50 68 44 00 18 08 08 08 08 08 1c 00
>a97d	00 00 76 49 49 49 49 00 00 00 5c 62 42 42 42 00
>a98d	00 00 3c 42 42 42 3c 00 00 00 5c 62 62 5c 40 40
>a99d	00 00 3a 46 46 3a 02 02 00 00 5c 62 40 40 40 00
>a9ad	00 00 3e 40 3c 02 7c 00 10 10 7c 10 10 12 0c 00
>a9bd	00 00 42 42 42 46 3a 00 00 00 42 42 42 24 18 00
>a9cd	00 00 41 49 49 49 36 00 00 00 42 24 18 24 42 00
>a9dd	00 00 42 42 46 3a 02 3c 00 00 7e 04 18 20 7e 00
>a9ed	08 08 08 08 ff 08 08 08 a0 50 a0 50 a0 50 a0 50
>a9fd	08 08 08 08 08 08 08 08 cc cc 33 33 cc cc 33 33
>aa0d	cc 66 33 99 cc 66 33 99 00 00 00 00 00 00 00 00
>aa1d	f0 f0 f0 f0 f0 f0 f0 f0 00 00 00 00 ff ff ff ff
>aa2d	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff
>aa3d	80 80 80 80 80 80 80 80 aa 55 aa 55 aa 55 aa 55
>aa4d	01 01 01 01 01 01 01 01 00 00 00 00 aa 55 aa 55
>aa5d	99 33 66 cc 99 33 66 cc 03 03 03 03 03 03 03 03
>aa6d	08 08 08 08 0f 08 08 08 00 00 00 00 0f 0f 0f 0f
>aa7d	08 08 08 08 0f 00 00 00 00 00 00 00 f8 08 08 08
>aa8d	00 00 00 00 00 00 ff ff 00 00 00 00 0f 08 08 08
>aa9d	08 08 08 08 ff 00 00 00 00 00 00 00 ff 08 08 08
>aaad	08 08 08 08 f8 08 08 08 c0 c0 c0 c0 c0 c0 c0 c0
>aabd	e0 e0 e0 e0 e0 e0 e0 e0 07 07 07 07 07 07 07 07
>aacd	ff ff 00 00 00 00 00 00 ff ff ff 00 00 00 00 00
>aadd	00 00 00 00 00 ff ff ff 01 02 44 48 50 60 40 00
>aaed	00 00 00 00 f0 f0 f0 f0 0f 0f 0f 0f 00 00 00 00
>aafd	08 08 08 08 f8 00 00 00 f0 f0 f0 f0 00 00 00 00
>ab0d	f0 f0 f0 f0 0f 0f 0f 0f

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/errors.asm

.ab15					SyntaxError:
.ab15	20 44 ab	jsr $ab44			jsr 	ERR_Handler
>ab18	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>ab20	72 72 6f 72 00
.ab25					TypeError:
.ab25	20 44 ab	jsr $ab44			jsr 	ERR_Handler
>ab28	57 72 6f 6e 67 20 74 79				.text 	"Wrong type",0
>ab30	70 65 00
.ab33					BadParamError:
.ab33	20 44 ab	jsr $ab44			jsr 	ERR_Handler
>ab36	42 61 64 20 50 61 72 61				.text 	"Bad Parameter",0
>ab3e	6d 65 74 65 72 00
.ab44					ERR_Handler:
.ab44	a3 00		ldz #$00			ldz 	#0
.ab46	1b		inz				inz
.ab47	ea		nop				nop
.ab48	b2 16		lda ($16),z			lda 	(zCodePtr),z
.ab4a	8d 08 03	sta $0308			sta 	XS_Mantissa
.ab4d	1b		inz				inz
.ab4e	ea		nop				nop
.ab4f	b2 16		lda ($16),z			lda 	(zCodePtr),z
.ab51	8d 09 03	sta $0309			sta 	XS_Mantissa+1
.ab54	fa		plx				plx 								; address in XY
.ab55	7a		ply				ply
.ab56	e8		inx				inx 								; bump, because of RTS/JSR address -1
.ab57	d0 01		bne $ab5a			bne 	_EHNoSkip
.ab59	c8		iny				iny
.ab5a					_EHNoSkip:
.ab5a	20 7b ab	jsr $ab7b			jsr 	PrintROMMessage 			; print message from ROM.
.ab5d	ad 08 03	lda $0308			lda 	XS_Mantissa					; line number = 0
.ab60	0d 09 03	ora $0309			ora 	XS_Mantissa+1
.ab63	f0 0c		beq $ab71			beq 	_EHNoLine
.ab65	a2 76		ldx #$76			ldx 	#_EHAt & $FF 				; print " at "
.ab67	a0 ab		ldy #$ab			ldy 	#(_EHAt >> 8) & $FF
.ab69	20 7b ab	jsr $ab7b			jsr 	PrintROMMessage
.ab6c	a2 00		ldx #$00			ldx 	#0 							; Print line number
.ab6e	20 8c ab	jsr $ab8c			jsr 	Print16BitInteger
.ab71					_EHNoLine:
.ab71	80 fe		bra $ab71			bra 	_EHNoLine
.ab73	4c d1 ad	jmp $add1			jmp 	WarmStart
>ab76	20 61 74 20 00			_EHAt:	.text 	" at ",0
.ab7b					PrintROMMessage:
.ab7b	86 1a		stx $1a				stx 	zLTemp1 					; save addres
.ab7d	84 1b		sty $1b				sty 	zLTemp1+1
.ab7f	a0 00		ldy #$00			ldy 	#0
.ab81					_PRMLoop:
.ab81	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.ab83	f0 06		beq $ab8b			beq		_PRMExit
.ab85	c8		iny				iny
.ab86	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.ab89	80 f6		bra $ab81			bra 	_PRMLoop
.ab8b					_PRMExit:
.ab8b	60		rts				rts
.ab8c					Print16BitInteger:
.ab8c	a9 00		lda #$00			lda 	#0 							; make 32 bit
.ab8e	8d 0a 03	sta $030a			sta 	XS_Mantissa+2
.ab91	8d 0b 03	sta $030b			sta 	XS_Mantissa+3
.ab94	8d 00 04	sta $0400			sta 	NumBufX 					; reset the conversion pointer
.ab97	aa		tax				tax 								; convert bottom level.
.ab98	20 c0 b8	jsr $b8c0			jsr 	INTToString 				; make string
.ab9b	a2 00		ldx #$00			ldx 	#0 							; print buffer
.ab9d	bd 01 04	lda $0401,x	_P1Loop:lda 	Num_Buffer,x
.aba0	f0 06		beq $aba8			beq 	_P1Exit
.aba2	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.aba5	e8		inx				inx
.aba6	80 f5		bra $ab9d			bra 	_P1Loop
.aba8	60		rts		_P1Exit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm


;******  Processing file: modules/basic/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b4					lastUnaryFunction = $b4
.aba9					VectorTable:
>aba9	d5 b0					.word BinaryOp_And         & $FFFF ; $80 and
>abab	fd b0					.word BinaryOp_Or          & $FFFF ; $81 or
>abad	25 b1					.word BinaryOp_Xor         & $FFFF ; $82 xor
>abaf	25 b1					.word BinaryOp_Eor         & $FFFF ; $83 eor
>abb1	69 b1					.word Binary_Equal         & $FFFF ; $84 =
>abb3	88 b1					.word Binary_NotEqual      & $FFFF ; $85 <>
>abb5	91 b1					.word Binary_Less          & $FFFF ; $86 <
>abb7	9a b1					.word Binary_LessEqual     & $FFFF ; $87 <=
>abb9	ac b1					.word Binary_Greater       & $FFFF ; $88 >
>abbb	a3 b1					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>abbd	41 b2					.word BinaryOp_Add         & $FFFF ; $8a +
>abbf	61 b2					.word BinaryOp_Subtract    & $FFFF ; $8b -
>abc1	74 b2					.word BinaryOp_Multiply    & $FFFF ; $8c *
>abc3	87 b2					.word BinaryOp_Divide      & $FFFF ; $8d /
>abc5	5d ac					.word NotImplemented       & $FFFF ; $8e ^
>abc7	5d ac					.word NotImplemented       & $FFFF ; $8f if
>abc9	5d ac					.word NotImplemented       & $FFFF ; $90 while
>abcb	5d ac					.word NotImplemented       & $FFFF ; $91 repeat
>abcd	5d ac					.word NotImplemented       & $FFFF ; $92 for
>abcf	5d ac					.word NotImplemented       & $FFFF ; $93 then
>abd1	5d ac					.word NotImplemented       & $FFFF ; $94 endif
>abd3	5d ac					.word NotImplemented       & $FFFF ; $95 wend
>abd5	5d ac					.word NotImplemented       & $FFFF ; $96 until
>abd7	5d ac					.word NotImplemented       & $FFFF ; $97 next
>abd9	5d ac					.word NotImplemented       & $FFFF ; $98 not
>abdb	5d ac					.word NotImplemented       & $FFFF ; $99 fn(
>abdd	bb b3					.word Unary_Abs            & $FFFF ; $9a abs(
>abdf	12 b5					.word Unary_Asc            & $FFFF ; $9b asc(
>abe1	a1 c0					.word Unary_Int            & $FFFF ; $9c int(
>abe3	d9 b3					.word Unary_Peek           & $FFFF ; $9d peek(
>abe5	18 c0					.word Unary_Rnd            & $FFFF ; $9e rnd(
>abe7	4d b4					.word Unary_Usr            & $FFFF ; $9f usr(
>abe9	53 b5					.word Unary_Left           & $FFFF ; $a0 left$(
>abeb	6a b5					.word Unary_Right          & $FFFF ; $a1 right$(
>abed	38 b5					.word Unary_Mid            & $FFFF ; $a2 mid$(
>abef	cc b6					.word Unary_Spc            & $FFFF ; $a3 spc(
>abf1	df b4					.word Unary_Str            & $FFFF ; $a4 str$(
>abf3	6e b4					.word Unary_Val            & $FFFF ; $a5 val(
>abf5	29 b5					.word Unary_Len            & $FFFF ; $a6 len(
>abf7	e8 b5					.word Unary_Hex            & $FFFF ; $a7 hex$(
>abf9	5d ac					.word NotImplemented       & $FFFF ; $a8 sin(
>abfb	5d ac					.word NotImplemented       & $FFFF ; $a9 cos(
>abfd	5d ac					.word NotImplemented       & $FFFF ; $aa tan(
>abff	5d ac					.word NotImplemented       & $FFFF ; $ab atn(
>ac01	5d ac					.word NotImplemented       & $FFFF ; $ac exp(
>ac03	5d ac					.word NotImplemented       & $FFFF ; $ad log(
>ac05	5d ac					.word NotImplemented       & $FFFF ; $ae sqr(
>ac07	42 b6					.word Unary_Dec            & $FFFF ; $af dec(
>ac09	dd b3					.word Unary_Deek           & $FFFF ; $b0 deek(
>ac0b	e1 b3					.word Unary_Leek           & $FFFF ; $b1 leek(
>ac0d	15 b4					.word Unary_Mod            & $FFFF ; $b2 mod(
>ac0f	69 b3					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>ac11	aa b6					.word Unary_Chr            & $FFFF ; $b4 chr$(
>ac13	5d ac					.word NotImplemented       & $FFFF ; $b5 $(
>ac15	5d ac					.word NotImplemented       & $FFFF ; $b6 $
>ac17	5d ac					.word NotImplemented       & $FFFF ; $b7 #(
>ac19	5d ac					.word NotImplemented       & $FFFF ; $b8 #
>ac1b	5d ac					.word NotImplemented       & $FFFF ; $b9 %(
>ac1d	5d ac					.word NotImplemented       & $FFFF ; $ba %
>ac1f	5d ac					.word NotImplemented       & $FFFF ; $bb (
>ac21	5d ac					.word NotImplemented       & $FFFF ; $bc )
>ac23	5d ac					.word NotImplemented       & $FFFF ; $bd ,
>ac25	52 ae					.word Command_COLON        & $FFFF ; $be :
>ac27	5d ac					.word NotImplemented       & $FFFF ; $bf ;
>ac29	5d ac					.word NotImplemented       & $FFFF ; $c0 def
>ac2b	e9 ae					.word Command_CLR          & $FFFF ; $c1 clr
>ac2d	f4 ae					.word Command_STOP         & $FFFF ; $c2 stop
>ac2f	5d ac					.word NotImplemented       & $FFFF ; $c3 data
>ac31	5d ac					.word NotImplemented       & $FFFF ; $c4 read
>ac33	5d ac					.word NotImplemented       & $FFFF ; $c5 dim
>ac35	5d ac					.word NotImplemented       & $FFFF ; $c6 to
>ac37	5d ac					.word NotImplemented       & $FFFF ; $c7 step
>ac39	5d ac					.word NotImplemented       & $FFFF ; $c8 gosub
>ac3b	5d ac					.word NotImplemented       & $FFFF ; $c9 return
>ac3d	5d ac					.word NotImplemented       & $FFFF ; $ca goto
>ac3f	53 ae					.word Command_END          & $FFFF ; $cb end
>ac41	5d ac					.word NotImplemented       & $FFFF ; $cc input
>ac43	5d ac					.word NotImplemented       & $FFFF ; $cd let
>ac45	5d ac					.word NotImplemented       & $FFFF ; $ce list
>ac47	5d ac					.word NotImplemented       & $FFFF ; $cf new
>ac49	5d ac					.word NotImplemented       & $FFFF ; $d0 old
>ac4b	5d ac					.word NotImplemented       & $FFFF ; $d1 on
>ac4d	5d ac					.word NotImplemented       & $FFFF ; $d2 restore
>ac4f	5d ac					.word NotImplemented       & $FFFF ; $d3 poke
>ac51	58 ae					.word Command_PRINT        & $FFFF ; $d4 print
>ac53	d7 ad					.word Command_RUN          & $FFFF ; $d5 run
>ac55	5d ac					.word NotImplemented       & $FFFF ; $d6 wait
>ac57	5d ac					.word NotImplemented       & $FFFF ; $d7 doke
>ac59	5d ac					.word NotImplemented       & $FFFF ; $d8 loke
>ac5b	cd ae					.word Command_ASSERT       & $FFFF ; $d9 assert
.ac5d					NotImplemented:
.ac5d	20 44 ab	jsr $ab44			jsr ERR_Handler
>ac60	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>ac68	65 6d 65 6e 74 65 64 00
.ac70					BinaryPrecedence:
>ac70	01					.byte 1    ; $80 and
>ac71	01					.byte 1    ; $81 or
>ac72	01					.byte 1    ; $82 xor
>ac73	01					.byte 1    ; $83 eor
>ac74	02					.byte 2    ; $84 =
>ac75	02					.byte 2    ; $85 <>
>ac76	02					.byte 2    ; $86 <
>ac77	02					.byte 2    ; $87 <=
>ac78	02					.byte 2    ; $88 >
>ac79	02					.byte 2    ; $89 >=
>ac7a	03					.byte 3    ; $8a +
>ac7b	03					.byte 3    ; $8b -
>ac7c	04					.byte 4    ; $8c *
>ac7d	04					.byte 4    ; $8d /
>ac7e	05					.byte 5    ; $8e ^
.ac7f					KeywordText:
>ac7f	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>ac82	4f d2					.byte $4f,$d2                          ; $81 or
>ac84	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>ac87	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>ac8a	bd					.byte $bd                              ; $84 =
>ac8b	3c be					.byte $3c,$be                          ; $85 <>
>ac8d	bc					.byte $bc                              ; $86 <
>ac8e	3c bd					.byte $3c,$bd                          ; $87 <=
>ac90	be					.byte $be                              ; $88 >
>ac91	3e bd					.byte $3e,$bd                          ; $89 >=
>ac93	ab					.byte $ab                              ; $8a +
>ac94	ad					.byte $ad                              ; $8b -
>ac95	aa					.byte $aa                              ; $8c *
>ac96	af					.byte $af                              ; $8d /
>ac97	de					.byte $de                              ; $8e ^
>ac98	49 c6					.byte $49,$c6                          ; $8f if
>ac9a	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>ac9f	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>aca5	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>aca8	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>acac	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>acb1	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>acb5	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>acba	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>acbe	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>acc1	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>acc4	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>acc8	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>accc	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>acd0	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>acd5	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>acd9	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>acdd	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>ace3	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>acea	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>acef	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>acf3	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>acf8	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>acfc	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>ad00	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>ad05	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>ad09	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>ad0d	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>ad11	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>ad15	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>ad19	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>ad1d	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>ad21	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>ad25	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>ad2a	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>ad2f	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>ad33	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>ad37	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>ad3c	24 a8					.byte $24,$a8                          ; $b5 $(
>ad3e	a4					.byte $a4                              ; $b6 $
>ad3f	23 a8					.byte $23,$a8                          ; $b7 #(
>ad41	a3					.byte $a3                              ; $b8 #
>ad42	25 a8					.byte $25,$a8                          ; $b9 %(
>ad44	a5					.byte $a5                              ; $ba %
>ad45	a8					.byte $a8                              ; $bb (
>ad46	a9					.byte $a9                              ; $bc )
>ad47	ac					.byte $ac                              ; $bd ,
>ad48	ba					.byte $ba                              ; $be :
>ad49	bb					.byte $bb                              ; $bf ;
>ad4a	44 45 c6				.byte $44,$45,$c6                      ; $c0 def
>ad4d	43 4c d2				.byte $43,$4c,$d2                      ; $c1 clr
>ad50	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $c2 stop
>ad54	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c3 data
>ad58	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c4 read
>ad5c	44 49 cd				.byte $44,$49,$cd                      ; $c5 dim
>ad5f	54 cf					.byte $54,$cf                          ; $c6 to
>ad61	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c7 step
>ad65	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $c8 gosub
>ad6a	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $c9 return
>ad70	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $ca goto
>ad74	45 4e c4				.byte $45,$4e,$c4                      ; $cb end
>ad77	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $cc input
>ad7c	4c 45 d4				.byte $4c,$45,$d4                      ; $cd let
>ad7f	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $ce list
>ad83	4e 45 d7				.byte $4e,$45,$d7                      ; $cf new
>ad86	4f 4c c4				.byte $4f,$4c,$c4                      ; $d0 old
>ad89	4f ce					.byte $4f,$ce                          ; $d1 on
>ad8b	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d2 restore
>ad92	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d3 poke
>ad96	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d4 print
>ad9b	52 55 ce				.byte $52,$55,$ce                      ; $d5 run
>ad9e	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d6 wait
>ada2	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $d7 doke
>ada6	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $d8 loke
>adaa	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $d9 assert
>adb0	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_dollarlparen = $b5
=$b6					token_dollar = $b6
=$b7					token_hashlparen = $b7
=$b8					token_hash = $b8
=$b9					token_percentlparen = $b9
=$ba					token_percent = $ba
=$bb					token_lparen = $bb
=$bc					token_rparen = $bc
=$bd					token_comma = $bd
=$be					token_colon = $be
=$bf					token_semicolon = $bf
=$c0					token_def = $c0
=$c1					token_clr = $c1
=$c2					token_stop = $c2
=$c3					token_data = $c3
=$c4					token_read = $c4
=$c5					token_dim = $c5
=$c6					token_to = $c6
=$c7					token_step = $c7
=$c8					token_gosub = $c8
=$c9					token_return = $c9
=$ca					token_goto = $ca
=$cb					token_end = $cb
=$cc					token_input = $cc
=$cd					token_let = $cd
=$ce					token_list = $ce
=$cf					token_new = $cf
=$d0					token_old = $d0
=$d1					token_on = $d1
=$d2					token_restore = $d2
=$d3					token_poke = $d3
=$d4					token_print = $d4
=$d5					token_run = $d5
=$d6					token_wait = $d6
=$d7					token_doke = $d7
=$d8					token_loke = $d8
=$d9					token_assert = $d9

;******  Return to file: modules/basic/core.asm

.adb1					BASIC_Start:
.adb1	20 4d a2	jsr $a24d			jsr 	IF_Reset 					; set up and clear screen.
.adb4	20 0c a0	jsr $a00c			jsr 	IFT_ClearScreen
.adb7	a9 4c		lda #$4c			lda 	#$4C 						; JMP opcode
.adb9	8d 04 03	sta $0304			sta 	LocalVector
.adbc	8d 00 03	sta $0300			sta 	UserVector
.adbf	a9 5c		lda #$5c			lda 	#USRDefault & $FF 			; reset USR vector
.adc1	8d 01 03	sta $0301			sta 	UserVector+1
.adc4	a9 b4		lda #$b4			lda 	#(USRDefault >> 8) & $FF
.adc6	8d 02 03	sta $0302			sta 	UserVector+2
.adc9	a9 00		lda #$00			lda 	#(USRDefault >> 16) & $FF
.adcb	8d 03 03	sta $0303			sta 	UserVector+3
.adce	20 e9 ae	jsr $aee9			jsr 	ResetRunStatus 				; clear everything (CLR command)
.add1					WarmStart:
.add1	a2 ff		ldx #$ff			ldx 		#$FF 					; empty stack
.add3	9a		txs				txs
.add4	4c d7 ad	jmp $add7			jmp 	COMMAND_Run

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/run.asm

.add7					Command_RUN:
.add7	20 e9 ae	jsr $aee9			jsr 	ResetRunStatus 				; clear, reset stacks etc.
.adda	a9 00		lda #$00			lda 	#BasicProgram & $FF
.addc	85 16		sta $16				sta 	zCodePtr+0
.adde	a9 80		lda #$80			lda 	#BasicProgram >> 8
.ade0	85 17		sta $17				sta 	zCodePtr+1
.ade2	a9 02		lda #$02			lda 	#2
.ade4	85 18		sta $18				sta 	zCodePtr+2
.ade6	a9 00		lda #$00			lda 	#0
.ade8	85 19		sta $19				sta 	zCodePtr+3
.adea	a3 03		ldz #$03			ldz 	#3
.adec					RUN_NewLine:
.adec	a3 00		ldz #$00			ldz 	#0
.adee	ea		nop				nop
.adef	b2 16		lda ($16),z			lda 	(zCodePtr),z
.adf1	1b		inz				inz
.adf2	1b		inz				inz
.adf3	1b		inz				inz
.adf4	c9 00		cmp #$00			cmp 	#0 							; if the offset is zero then END.
.adf6	d0 18		bne $ae10			bne 	RUN_NextCommand
.adf8	4c f4 ae	jmp $aef4			jmp 	Command_STOP 				; go do the command code.
.adfb					RUN_Skip:
.adfb	ea		nop				nop
.adfc	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read element
.adfe	1b		inz				inz 								; skip
.adff	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.ae01	90 0d		bcc $ae10			bcc 	_SEDone 					; so just skip over it.
.ae03	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.ae05	90 08		bcc $ae0f			bcc 	_SEDouble
.ae07	6b		tza				tza 								; this is Y + 1
.ae08	18		clc				clc
.ae09	ea		nop				nop
.ae0a	72 16		adc ($16),z			adc 	(zCodePtr),z 				; add total length of element
.ae0c	4b		taz				taz 								; back in Y.
.ae0d	3b		dez				dez 								; fix up, one for the +1, one for the iny
.ae0e	3b		dez				dez
.ae0f					_SEDouble:
.ae0f	1b		inz				inz
.ae10					_SEDone:
.ae10					RUN_NextCommand:
.ae10	a9 00		lda #$00			lda 	#0 							; this resets temporary string allocation.
.ae12	85 21		sta $21				sta 	zTempStr+1 					; (initialised when first called)
.ae14	ea		nop				nop
.ae15	b2 16		lda ($16),z			lda 	(zCodePtr),z
.ae17	c9 be		cmp #$be			cmp 	#token_Colon 				; skip over colons
.ae19	f0 e0		beq $adfb			beq 	RUN_Skip
.ae1b	c9 00		cmp #$00			cmp 	#0 							; if non-zero execute whatever
.ae1d	d0 10		bne $ae2f			bne 	RUN_Execute
.ae1f					RUN_NextLine:
.ae1f	a3 00		ldz #$00			ldz 	#0 							; point to offset
.ae21	ea		nop				nop
.ae22	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read it
.ae24	18		clc				clc
.ae25	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.ae27	85 16		sta $16				sta 	zCodePtr
.ae29	90 02		bcc $ae2d			bcc 	_SNLNoCarry
.ae2b	e6 17		inc $17				inc 	zCodePtr+1
.ae2d					_SNLNoCarry:
.ae2d	80 bd		bra $adec			bra 	RUN_NewLine 				; go do the new line code
.ae2f					RUN_Execute:
.ae2f	c9 f8		cmp #$f8			cmp 	#$F8 						; handle shifts, REM etc.
.ae31	b0 18		bcs $ae4b			bcs 	RUN_Extension
.ae33	1b		inz				inz
.ae34	0a		asl a				asl 	a 							; double the character read.
.ae35	90 12		bcc $ae49			bcc 	RUN_Default 				; if carry clear was $00-$7F, so try LET.
.ae37	aa		tax				tax 								; ready to look up.
.ae38	bd a9 ab	lda $aba9,x			lda 	VectorTable,x 				; copy address into LocalVector
.ae3b	8d 05 03	sta $0305			sta 	LocalVector+1
.ae3e	bd aa ab	lda $abaa,x			lda 	VectorTable+1,x
.ae41	8d 06 03	sta $0306			sta 	LocalVector+2
.ae44	20 0c b0	jsr $b00c			jsr 	EVCallLocalVector 			; execute the appropriate code.
.ae47	80 c7		bra $ae10			bra 	RUN_NextCommand 			; do the next command.
.ae49					RUN_Default:
.ae49	80 fe		bra $ae49			bra 	RUN_Default
.ae4b					RUN_Extension:
.ae4b	c9 ff		cmp #$ff			cmp 	#$FF 						; if $FF (REM)
.ae4d	f0 ac		beq $adfb			beq 	RUN_Skip 					; skip over it.
.ae4f	4c 15 ab	jmp $ab15			jmp 	SyntaxError
.ae52					Command_COLON:
.ae52	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/end.asm

.ae53					Command_END:
.ae53	80 fe		bra $ae53	_halt:	bra 		_halt
.ae55	4c d1 ad	jmp $add1			jmp 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/print.asm

.ae58					Command_PRINT:
.ae58	ea		nop				nop
.ae59	b2 16		lda ($16),z			lda 	(zCodePtr),z
.ae5b	c9 00		cmp #$00			cmp 	#0 							; end
.ae5d	f0 6a		beq $aec9			beq 	_CPR_NewLine
.ae5f	c9 be		cmp #$be			cmp 	#token_Colon
.ae61	f0 66		beq $aec9			beq 	_CPR_NewLine
.ae63	c9 bf		cmp #$bf			cmp 	#token_SemiColon
.ae65	f0 54		beq $aebb			beq 	_CPR_Skip
.ae67	c9 bd		cmp #$bd			cmp 	#token_Comma
.ae69	f0 4d		beq $aeb8			beq 	_CPR_Tab
.ae6b	20 ff ae	jsr $aeff			jsr 	EvaluateExpression 			; get expression.
.ae6e	ad 0d 03	lda $030d			lda 	XS_Type 					; get type.
.ae71	29 02		and #$02			and 	#2
.ae73	d0 25		bne $ae9a			bne 	_CPR_String 				; if type = 2 output as string.
.ae75					_CPR_Number:
.ae75	a9 00		lda #$00			lda 	#0 							; reset buffer index
.ae77	8d 00 04	sta $0400			sta 	NumBufX
.ae7a	ad 0d 03	lda $030d			lda 	XS_Type 					; get type
.ae7d	4a		lsr a				lsr 	a
.ae7e	b0 05		bcs $ae85			bcs 	_CPRInt 					; if msb set do as integer
.ae80	20 d0 be	jsr $bed0			jsr 	FPToString 					; call fp to str otherwise
.ae83	80 03		bra $ae88			bra 	_CPRNPrint
.ae85	20 c0 b8	jsr $b8c0	_CPRInt:jsr 	IntToString
.ae88					_CPRNPrint:
.ae88	ad 01 04	lda $0401			lda 	Num_Buffer 					; is first character -
.ae8b	c9 2d		cmp #$2d			cmp 	#"-"
.ae8d	f0 05		beq $ae94			beq 	_CPRNoSpace
.ae8f	a9 20		lda #$20			lda 	#" "						; print the leading space
.ae91	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter 			; so beloved of MS Basics.
.ae94					_CPRNoSpace:
.ae94	a2 00		ldx #$00			ldx 	#(Num_Buffer-1) & $FF
.ae96	a9 04		lda #$04			lda 	#(Num_Buffer-1) >> 8
.ae98	80 06		bra $aea0			bra 	_CPRPrint
.ae9a					_CPR_String:
.ae9a	ae 08 03	ldx $0308			ldx 	XS_Mantissa
.ae9d	ad 09 03	lda $0309			lda 	XS_Mantissa+1
.aea0					_CPRPrint:
.aea0	86 1e		stx $1e				stx 	zGenPtr
.aea2	85 1f		sta $1f				sta 	zGenPtr+1
.aea4	5a		phy				phy
.aea5	a0 00		ldy #$00			ldy 	#0							; get length into X
.aea7	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.aea9	aa		tax				tax
.aeaa	f0 09		beq $aeb5			beq 	_CPREndPrint 				; nothing to print
.aeac					_CPRLoop:
.aeac	c8		iny				iny
.aead	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.aeaf	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.aeb2	ca		dex				dex
.aeb3	d0 f7		bne $aeac			bne 	_CPRLoop
.aeb5					_CPREndPrint:
.aeb5	7a		ply				ply
.aeb6	80 a0		bra $ae58			bra 	Command_Print
.aeb8					_CPR_Tab:
.aeb8	20 5b a0	jsr $a05b			jsr 	IFT_Tab
.aebb					_CPR_Skip:
.aebb	1b		inz				inz
.aebc	ea		nop				nop
.aebd	b2 16		lda ($16),z			lda 	(zCodePtr),z
.aebf	c9 be		cmp #$be			cmp 	#token_Colon 				; colon or $00, exit
.aec1	f0 09		beq $aecc			beq 	_CPR_Exit
.aec3	c9 00		cmp #$00			cmp 	#0
.aec5	d0 91		bne $ae58			bne 	Command_PRINT 				; if not go round again.
.aec7	80 03		bra $aecc			bra 	_CPR_Exit
.aec9					_CPR_NewLine:
.aec9	20 68 a0	jsr $a068			jsr 	IFT_NewLine
.aecc					_CPR_Exit:
.aecc	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/assert.asm

.aecd					Command_ASSERT:
.aecd	20 a4 b0	jsr $b0a4			jsr 	EvaluateNumber 				; calculate thing being asserted
.aed0	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; check if true (non-zero)
.aed3	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.aed6	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.aed9	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.aedc	f0 01		beq $aedf			beq 	_ASFail
.aede	60		rts				rts
.aedf					_ASFail:
.aedf	20 44 ab	jsr $ab44			jsr ERR_Handler
>aee2	41 73 73 65 72 74 00			.text "Assert",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.aee9					Command_CLR:
.aee9					ResetRunStatus:
.aee9	a9 00		lda #$00			lda 	#HighMemory & $FF
.aeeb	8d 26 04	sta $0426			sta 	StringPtr
.aeee	a9 70		lda #$70			lda 	#HighMemory >> 8
.aef0	8d 27 04	sta $0427			sta 	StringPtr+1
.aef3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/stop.asm

.aef4					Command_STOP:
.aef4	20 44 ab	jsr $ab44			jsr ERR_Handler
>aef7	53 74 6f 70 00				.text "Stop",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.aefc					EVESyntax:
.aefc	4c 15 ab	jmp $ab15			jmp 	SyntaxError
.aeff					EvaluateExpression:
.aeff	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.af01					EvaluateExpressionX:
.af01	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.af03					EvaluateExpressionXA:
.af03	48		pha				pha 								; save precedence on stack.
.af04	ea		nop				nop
.af05	b2 16		lda ($16),z			lda 	(zCodePtr),z
.af07	f0 f3		beq $aefc			beq 	EVESyntax 					; end of line, syntax error.
.af09	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.af0b	b0 03		bcs $af10			bcs 	_EVNotVariable
.af0d	4c 0b b0	jmp $b00b			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.af10					_EVNotVariable:
.af10	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.af12	90 e8		bcc $aefc			bcc 	EVESyntax
.af14	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.af16	b3 82 00	bcs $af9a			bcs 	_EVNotInteger
.af19	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.af1b	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.af1e	a9 00		lda #$00			lda 	#0
.af20	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.af23	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.af26	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.af29	1a		inc a				inc 	a 							; set to type 1 (integer)
.af2a	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.af2d					_EVCheckNextInteger:
.af2d	1b		inz				inz
.af2e	ea		nop				nop
.af2f	b2 16		lda ($16),z			lda 	(zCodePtr),z
.af31	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.af33	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.af35	b0 0d		bcs $af44			bcs 	_EVCheckDecimal
.af37	48		pha				pha 								; save it.
.af38	20 0f b0	jsr $b00f			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.af3b	68		pla				pla
.af3c	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.af3f	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.af42	80 e9		bra $af2d			bra 	_EVCheckNextInteger
.af44					_EVCheckDecimal:
.af44	ea		nop				nop
.af45	b2 16		lda ($16),z			lda 	(zCodePtr),z
.af47	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.af49	d0 05		bne $af50			bne 	_EVGotAtom 					; no, get atom.
.af4b					_EVIsDecimal:
.af4b	20 3f b0	jsr $b03f			jsr 	EVGetDecimal 				; extend to the decimal part.
.af4e	80 00		bra $af50			bra 	_EVGotAtom 					; and continue to got atom.
.af50					_EVGotAtom:
.af50	ea		nop				nop
.af51	b2 16		lda ($16),z			lda 	(zCodePtr),z
.af53	10 43		bpl $af98			bpl 	_EVExitDrop 				; must be a token.
.af55	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.af57	b0 3f		bcs $af98			bcs 	_EVExitDrop
.af59	68		pla				pla 								; get current precedence
.af5a	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.af5c	da		phx				phx 								; save X
.af5d	ea		nop				nop
.af5e	b2 16		lda ($16),z			lda 	(zCodePtr),z
.af60	aa		tax				tax 								; put in X
.af61	bd f0 ab	lda $abf0,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.af64	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.af66	fa		plx				plx 								; restore X
.af67	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.af69	90 2e		bcc $af99			bcc 	_EVExit 					; exit if too low.
.af6b	f0 2c		beq $af99			beq 	_EVExit 					; exit if equals
.af6d	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.af6f	48		pha				pha
.af70	ea		nop				nop
.af71	b2 16		lda ($16),z			lda 	(zCodePtr),z
.af73	48		pha				pha
.af74	1b		inz				inz
.af75	da		phx				phx 								; save current position
.af76	e8		inx				inx
.af77	e8		inx				inx
.af78	e8		inx				inx
.af79	e8		inx				inx
.af7a	e8		inx				inx
.af7b	e8		inx				inx
.af7c	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.af7e	20 03 af	jsr $af03			jsr 	EvaluateExpressionXA 		; do the RHS.
.af81	fa		plx				plx 								; restore X
.af82	68		pla				pla 								; get the binary operator in A.
.af83					_EVCallA:
.af83	da		phx				phx 								; save X again
.af84	0a		asl a				asl 	a 							; double, lose the MSB.
.af85	aa		tax				tax									; put in X
.af86	bd a9 ab	lda $aba9,x			lda 	VectorTable,x 				; copy address into zGenPtr
.af89	8d 05 03	sta $0305			sta 	LocalVector+1
.af8c	bd aa ab	lda $abaa,x			lda 	VectorTable+1,x
.af8f	8d 06 03	sta $0306			sta 	LocalVector+2
.af92	fa		plx				plx 								; restore X
.af93	20 0c b0	jsr $b00c			jsr 	EVCallLocalVector
.af96	80 b8		bra $af50			bra 	_EVGotAtom 					; and loop back.
.af98					_EVExitDrop:
.af98	68		pla				pla
.af99					_EVExit:
.af99	60		rts				rts
.af9a					_EVNotInteger:
.af9a	1b		inz				inz
.af9b	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.af9d	d0 19		bne $afb8			bne 	_EVNotMinus
.af9f	20 92 b0	jsr $b092			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.afa2	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.afa5	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.afa7	f0 05		beq $afae			beq 	_EVMinusFloat
.afa9	20 9b b8	jsr $b89b			jsr 	IntegerNegateAlways 		; negation
.afac	80 a2		bra $af50			bra 	_EVGotAtom 					; and go back.
.afae					_EVMinusFloat:
.afae	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; invert the sign bit.
.afb1	49 80		eor #$80			eor 	#$80
.afb3	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.afb6	80 98		bra $af50			bra 	_EVGotAtom
.afb8					_EVNotMinus:
.afb8	c9 bb		cmp #$bb			cmp 	#token_lparen 				; is it left parenthesis
.afba	d0 18		bne $afd4			bne 	_EVNotParenthesis
.afbc	20 01 af	jsr $af01			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.afbf	ea		nop				nop
.afc0	b2 16		lda ($16),z			lda 	(zCodePtr),z
.afc2	1b		inz				inz
.afc3	c9 bc		cmp #$bc			cmp 	#token_rparen 				; okay if right bracket.
.afc5	f0 89		beq $af50			beq 	_EVGotAtom
.afc7	20 44 ab	jsr $ab44			jsr ERR_Handler
>afca	4d 69 73 73 69 6e 67 20			.text "Missing )",0
>afd2	29 00
.afd4					_EVNotParenthesis:
.afd4	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.afd6	d0 0c		bne $afe4			bne 	_EVNotNot
.afd8	20 92 b0	jsr $b092			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.afdb	20 a5 bd	jsr $bda5			jsr 	FPUToInteger 				; make it an integer - if possible.
.afde	20 6f b0	jsr $b06f			jsr 	NotInteger 					; do the not calculation
.afe1	4c 50 af	jmp $af50			jmp 	_EVGotAtom
.afe4					_EVNotNot:
.afe4	c9 fe		cmp #$fe			cmp 	#$FE
.afe6	d0 15		bne $affd			bne 	_EVNotString
.afe8	20 85 b7	jsr $b785			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.afeb	a5 20		lda $20				lda 	zTempStr 					; copy address of string into mantissa
.afed	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.aff0	a5 21		lda $21				lda 	zTempStr+1
.aff2	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.aff5	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.aff7	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.affa	4c 50 af	jmp $af50			jmp 	_EVGotAtom
.affd					_EVNotString:
.affd	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.afff	90 04		bcc $b005			bcc 	_EVBadElement
.b001	c9 b5		cmp #$b5			cmp 	#lastUnaryFunction+1
.b003	90 03		bcc $b008			bcc 	_EVUnaryFunction
.b005					_EVBadElement:
.b005	4c 15 ab	jmp $ab15			jmp 	SyntaxError
.b008					_EVUnaryFunction:
.b008	4c 83 af	jmp $af83			jmp 	_EVCallA
.b00b					_EVVariableHandler:
.b00b	ea		nop				nop
.b00c					EVCallLocalVector:
.b00c	6c 05 03	jmp ($0305)			jmp 	(LocalVector+1)
.b00f					EVShiftMantissaLeft6:
.b00f	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.b012	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.b015	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.b018	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b01b	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b01e	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b021	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b024	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b027	a9 00		lda #$00			lda 	#0
.b029	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b02c	20 2f b0	jsr $b02f			jsr 	_EVSMLShift 					; call it here to do it twice
.b02f					_EVSMLShift:
.b02f	5e 0c 03	lsr $030c,x			lsr 	XS_Exponent,x
.b032	7e 0b 03	ror $030b,x			ror 	XS_Mantissa+3,x
.b035	7e 0a 03	ror $030a,x			ror 	XS_Mantissa+2,x
.b038	7e 09 03	ror $0309,x			ror 	XS_Mantissa+1,x
.b03b	7e 08 03	ror $0308,x			ror 	XS_Mantissa+0,x
.b03e	60		rts				rts
.b03f					EVGetDecimal:
.b03f	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.b041	8d 01 04	sta $0401			sta 	Num_Buffer
.b044	da		phx				phx
.b045	1b		inz				inz
.b046	ea		nop				nop
.b047	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b049	1b		inz				inz
.b04a	3a		dec a				dec 	a								; convert to a string length.
.b04b	3a		dec a				dec 	a
.b04c	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.b04e					_EVGDCopy:
.b04e	48		pha				pha 									; save count
.b04f	ea		nop				nop
.b050	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b052	9d 01 04	sta $0401,x			sta 	Num_Buffer,x
.b055	e8		inx				inx 									; forward ....
.b056	1b		inz				inz
.b057	68		pla				pla 									; get count
.b058	3a		dec a				dec 	a 								; until zero
.b059	d0 f3		bne $b04e			bne 	_EVGDCopy
.b05b	9d 01 04	sta $0401,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.b05e	fa		plx				plx 									; restore X
.b05f	a9 01		lda #$01			lda 	#Num_Buffer & $FF 				; set zGenPtr
.b061	85 1e		sta $1e				sta 	zGenPtr
.b063	a9 04		lda #$04			lda 	#Num_Buffer >> 8
.b065	85 1f		sta $1f				sta 	zGenPtr+1
.b067	5a		phy				phy 									; save Y
.b068	a0 00		ldy #$00			ldy 	#0 								; start position
.b06a	20 97 bf	jsr $bf97			jsr 	FPFromString 					; convert current
.b06d	7a		ply				ply 									; restore Y
.b06e	60		rts				rts
.b06f					NotInteger:
.b06f	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b072	49 ff		eor #$ff			eor 	#$FF
.b074	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b077	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b07a	49 ff		eor #$ff			eor 	#$FF
.b07c	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b07f	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.b082	49 ff		eor #$ff			eor 	#$FF
.b084	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b087	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.b08a	49 ff		eor #$ff			eor 	#$FF
.b08c	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b08f	60		rts				rts
.b090					EvaluateGetAtom:
.b090	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.b092					EvaluateGetAtomX:
.b092	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.b094	20 03 af	jsr $af03			jsr 	EvaluateExpressionXA
.b097	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.b09a	29 0f		and #$0f			and 	#15
.b09c	c9 02		cmp #$02			cmp 	#2
.b09e	b0 01		bcs $b0a1			bcs 	EvaluateType
.b0a0	60		rts				rts
.b0a1					EvaluateType:
.b0a1	4c 25 ab	jmp $ab25			jmp 	TypeError
.b0a4					EvaluateNumber:
.b0a4	a2 00		ldx #$00			ldx 	#0
.b0a6					EvaluateNumberX:
.b0a6	20 01 af	jsr $af01			jsr 	EvaluateExpressionX
.b0a9	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 0/1
.b0ac	29 0f		and #$0f			and 	#15
.b0ae	c9 02		cmp #$02			cmp 	#2
.b0b0	b0 ef		bcs $b0a1			bcs 	EvaluateType
.b0b2	60		rts				rts
.b0b3					EvaluateInteger:
.b0b3	a2 00		ldx #$00			ldx 	#0
.b0b5					EvaluateIntegerX:
.b0b5	20 a6 b0	jsr $b0a6			jsr 	EvaluateNumberX
.b0b8	20 a5 bd	jsr $bda5			jsr 	FPUToInteger
.b0bb	60		rts				rts
.b0bc					EvaluateString:
.b0bc	a2 00		ldx #$00			ldx 	#0
.b0be					EvaluateStringX:
.b0be	20 01 af	jsr $af01			jsr 	EvaluateExpressionX
.b0c1	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 2
.b0c4	29 0f		and #$0f			and 	#15
.b0c6	c9 02		cmp #$02			cmp 	#2
.b0c8	d0 d7		bne $b0a1			bne 	EvaluateType
.b0ca	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.b0cd	85 1e		sta $1e				sta 	zGenPtr
.b0cf	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b0d2	85 1f		sta $1f				sta 	zGenPtr+1
.b0d4	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.b0d5					BinaryOp_And:
.b0d5	20 4d b1	jsr $b14d			jsr 	BinaryMakeBothInteger
.b0d8	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.b0db	3d 0e 03	and $030e,x			and 	XS2_Mantissa+0,x
.b0de	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b0e1	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.b0e4	3d 0f 03	and $030f,x			and 	XS2_Mantissa+1,x
.b0e7	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b0ea	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.b0ed	3d 10 03	and $0310,x			and 	XS2_Mantissa+2,x
.b0f0	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b0f3	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.b0f6	3d 11 03	and $0311,x			and 	XS2_Mantissa+3,x
.b0f9	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b0fc	60		rts				rts
.b0fd					BinaryOp_Or:
.b0fd	20 4d b1	jsr $b14d			jsr 	BinaryMakeBothInteger
.b100	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.b103	1d 0e 03	ora $030e,x			ora 	XS2_Mantissa+0,x
.b106	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b109	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.b10c	1d 0f 03	ora $030f,x			ora 	XS2_Mantissa+1,x
.b10f	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b112	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.b115	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.b118	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b11b	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.b11e	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.b121	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b124	60		rts				rts
.b125					BinaryOp_Eor:
.b125					BinaryOp_Xor:
.b125	20 4d b1	jsr $b14d			jsr 	BinaryMakeBothInteger
.b128	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.b12b	5d 0e 03	eor $030e,x			eor 	XS2_Mantissa+0,x
.b12e	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b131	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.b134	5d 0f 03	eor $030f,x			eor 	XS2_Mantissa+1,x
.b137	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b13a	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.b13d	5d 10 03	eor $0310,x			eor 	XS2_Mantissa+2,x
.b140	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b143	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.b146	5d 11 03	eor $0311,x			eor 	XS2_Mantissa+3,x
.b149	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b14c	60		rts				rts
.b14d					BinaryMakeBothInteger:
.b14d	da		phx				phx 								; save X
.b14e	e8		inx				inx
.b14f	e8		inx				inx
.b150	e8		inx				inx
.b151	e8		inx				inx
.b152	e8		inx				inx
.b153	e8		inx				inx
.b154	20 58 b1	jsr $b158			jsr 	BinaryMakeInteger 			; convert to integer.
.b157	fa		plx				plx 								; restore X and fall through.
.b158					BinaryMakeInteger:
.b158	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type byte.
.b15b	29 0f		and #$0f			and 	#15 						; check type zero
.b15d	f0 04		beq $b163			beq 	_BMIConvert 				; if float convert to integer.
.b15f	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.b160	90 04		bcc $b166			bcc 	_BMIError
.b162	60		rts				rts
.b163					_BMIConvert:
.b163	4c a5 bd	jmp $bda5			jmp 	FPUToInteger 				; convert to integer
.b166					_BMIError:
.b166	4c 25 ab	jmp $ab25			jmp 	TypeError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.b169					Binary_Equal:
.b169	20 b5 b1	jsr $b1b5			jsr 	CompareValues
.b16c	09 00		ora #$00			ora 	#0
.b16e	f0 04		beq $b174			beq 	CCTrue
.b170	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.b172	80 02		bra $b176			bra 	CCWrite
.b174	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.b176	9d 08 03	sta $0308,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.b179	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b17c	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b17f	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b182	a9 01		lda #$01			lda 	#1
.b184	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; set type to integer whatever.
.b187	60		rts				rts
.b188					Binary_NotEqual:
.b188	20 b5 b1	jsr $b1b5			jsr 	CompareValues
.b18b	09 00		ora #$00			ora 	#0
.b18d	f0 e1		beq $b170			beq 	CCFalse
.b18f	80 e3		bra $b174			bra 	CCTrue
.b191					Binary_Less:
.b191	20 b5 b1	jsr $b1b5			jsr 	CompareValues
.b194	09 00		ora #$00			ora 	#0
.b196	30 dc		bmi $b174			bmi 	CCTrue
.b198	80 d6		bra $b170			bra 	CCFalse
.b19a					Binary_LessEqual:
.b19a	20 b5 b1	jsr $b1b5			jsr 	CompareValues
.b19d	c9 01		cmp #$01			cmp 	#1
.b19f	d0 d3		bne $b174			bne 	CCTrue
.b1a1	80 cd		bra $b170			bra 	CCFalse
.b1a3					Binary_GreaterEqual:
.b1a3	20 b5 b1	jsr $b1b5			jsr 	CompareValues
.b1a6	09 00		ora #$00			ora 	#0
.b1a8	10 ca		bpl $b174			bpl 	CCTrue
.b1aa	80 c4		bra $b170			bra 	CCFalse
.b1ac					Binary_Greater:
.b1ac	20 b5 b1	jsr $b1b5			jsr 	CompareValues
.b1af	c9 01		cmp #$01			cmp 	#1
.b1b1	f0 c1		beq $b174			beq 	CCTrue
.b1b3	80 bb		bra $b170			bra 	CCFalse
.b1b5					CompareValues:
.b1b5	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and the types together
.b1b8	3d 13 03	and $0313,x			and 	XS2_Type,x
.b1bb	c9 02		cmp #$02			cmp 	#2
.b1bd	f0 13		beq $b1d2			beq 	_CVString
.b1bf	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b1c2	3d 13 03	and $0313,x			and 	XS2_Type,x
.b1c5	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b1c6	90 03		bcc $b1cb			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b1c8	4c 18 b2	jmp $b218			jmp 	CompareInteger32 							; so execute code at \1
.b1cb					_BCFloat:
.b1cb	20 e6 b2	jsr $b2e6			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b1ce	4c b4 bc	jmp $bcb4			jmp 	FPCompare 							; and execute code at \2
.b1d1	60		rts				rts
.b1d2					_CVString:
.b1d2	da		phx				phx 								; save XY
.b1d3	5a		phy				phy
.b1d4	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.b1d7	85 1a		sta $1a				sta		zLTemp1+0
.b1d9	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b1dc	85 1b		sta $1b				sta 	zLTemp1+1
.b1de	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x
.b1e1	85 1c		sta $1c				sta 	zLTemp1+2
.b1e3	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.b1e6	85 1d		sta $1d				sta 	zLTemp1+3
.b1e8	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.b1ea	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b1ec	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.b1ee	90 02		bcc $b1f2			bcc 	_CVCommon
.b1f0	b1 1c		lda ($1c),y			lda 	(zLTemp1+2),y
.b1f2					_CVCommon:
.b1f2	aa		tax				tax 								; put shorter string length in zero.
.b1f3	f0 0c		beq $b201			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.b1f5					_CVCompare:
.b1f5	c8		iny				iny 								; next character
.b1f6	b1 1a		lda ($1a),y			lda 	(zLTemp1),y 				; compare characters
.b1f8	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.b1fa	90 13		bcc $b20f			bcc 	_CVReturnLess 				; <
.b1fc	d0 15		bne $b213			bne 	_CVReturnGreater 			; >
.b1fe	ca		dex				dex 								; until common length matched.
.b1ff	d0 f4		bne $b1f5			bne 	_CVCompare
.b201					_CVMatch:
.b201	a0 00		ldy #$00			ldy 	#0
.b203	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b205	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.b207	90 06		bcc $b20f			bcc 	_CVReturnLess 				; <
.b209	d0 08		bne $b213			bne 	_CVReturnGreater 			; >
.b20b	a9 00		lda #$00			lda 	#0
.b20d	80 06		bra $b215			bra 	_CVExit 					; same common, same length, same string
.b20f					_CVReturnLess:
.b20f	a9 ff		lda #$ff			lda 	#$FF
.b211	80 02		bra $b215			bra 	_CVExit
.b213					_CVReturnGreater:
.b213	a9 01		lda #$01			lda 	#$01
.b215					_CVExit:
.b215	7a		ply				ply
.b216	fa		plx				plx
.b217	60		rts				rts
.b218					CompareInteger32:
.b218	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.b21b	49 80		eor #$80			eor 	#$80
.b21d	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b220	bd 11 03	lda $0311,x			lda 	XS2_Mantissa+3,x
.b223	49 80		eor #$80			eor 	#$80
.b225	9d 11 03	sta $0311,x			sta 	XS2_Mantissa+3,x
.b228	20 c0 b2	jsr $b2c0			jsr 	SubInteger32 				; subtraction
.b22b	90 11		bcc $b23e			bcc 	_CI32Less 					; cc return -1
.b22d	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; check if zero
.b230	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.b233	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.b236	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.b239	f0 02		beq $b23d			beq 	_CI32Exit
.b23b	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.b23d					_CI32Exit:
.b23d	60		rts				rts
.b23e					_CI32Less:
.b23e	a9 ff		lda #$ff			lda 	#$FF
.b240	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.b241					BinaryOp_Add:
.b241	bd 0d 03	lda $030d,x			lda 	XS_Type,x  					; and types together
.b244	3d 13 03	and $0313,x			and 	XS2_Type,x
.b247	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.b249	d0 13		bne $b25e			bne 	_BOAString
.b24b	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b24e	3d 13 03	and $0313,x			and 	XS2_Type,x
.b251	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b252	90 03		bcc $b257			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b254	4c 9a b2	jmp $b29a			jmp 	AddInteger32 							; so execute code at \1
.b257					_BCFloat:
.b257	20 e6 b2	jsr $b2e6			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b25a	4c 28 ba	jmp $ba28			jmp 	FPAdd 							; and execute code at \2
.b25d	60		rts				rts
.b25e					_BOAString:
.b25e	4c 01 b3	jmp $b301			jmp 	ConcatenateString 			; concatenate two strings.
.b261					BinaryOp_Subtract:
.b261	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b264	3d 13 03	and $0313,x			and 	XS2_Type,x
.b267	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b268	90 03		bcc $b26d			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b26a	4c c0 b2	jmp $b2c0			jmp 	SubInteger32 							; so execute code at \1
.b26d					_BCFloat:
.b26d	20 e6 b2	jsr $b2e6			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b270	4c 1e ba	jmp $ba1e			jmp 	FPSubtract 							; and execute code at \2
.b273	60		rts				rts
.b274					BinaryOp_Multiply:
.b274	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b277	3d 13 03	and $0313,x			and 	XS2_Type,x
.b27a	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b27b	90 03		bcc $b280			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b27d	4c ae b7	jmp $b7ae			jmp 	MulInteger32 							; so execute code at \1
.b280					_BCFloat:
.b280	20 e6 b2	jsr $b2e6			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b283	4c 94 bb	jmp $bb94			jmp 	FPMultiply 							; and execute code at \2
.b286	60		rts				rts
.b287					BinaryOp_Divide:
.b287	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b28a	3d 13 03	and $0313,x			and 	XS2_Type,x
.b28d	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b28e	90 03		bcc $b293			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b290	4c 05 b8	jmp $b805			jmp 	DivInteger32 							; so execute code at \1
.b293					_BCFloat:
.b293	20 e6 b2	jsr $b2e6			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b296	4c 0c bb	jmp $bb0c			jmp 	FPDivide 							; and execute code at \2
.b299	60		rts				rts
.b29a					AddInteger32:
.b29a	18		clc				clc
.b29b	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b29e	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.b2a1	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b2a4	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b2a7	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.b2aa	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b2ad	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.b2b0	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.b2b3	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b2b6	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.b2b9	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.b2bc	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b2bf	60		rts				rts
.b2c0					SubInteger32:
.b2c0	38		sec				sec
.b2c1	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b2c4	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.b2c7	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b2ca	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b2cd	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.b2d0	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b2d3	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.b2d6	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.b2d9	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b2dc	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.b2df	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.b2e2	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b2e5	60		rts				rts
.b2e6					BinaryMakeBothFloat:
.b2e6	da		phx				phx 								; save X
.b2e7	e8		inx				inx
.b2e8	e8		inx				inx
.b2e9	e8		inx				inx
.b2ea	e8		inx				inx
.b2eb	e8		inx				inx
.b2ec	e8		inx				inx
.b2ed	20 f1 b2	jsr $b2f1			jsr 	BinaryMakeFloat 			; convert to float.
.b2f0	fa		plx				plx 								; restore X and fall through.
.b2f1					BinaryMakeFloat:
.b2f1	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type byte.
.b2f4	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.b2f5	b0 04		bcs $b2fb			bcs 	_BMFConvert
.b2f7	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.b2f8	b0 04		bcs $b2fe			bcs 	_BMFError
.b2fa	60		rts				rts
.b2fb					_BMFConvert:
.b2fb	4c 46 bd	jmp $bd46			jmp 	FPUToFloat 					; convert to float
.b2fe					_BMFError:
.b2fe	4c 25 ab	jmp $ab25			jmp 	TypeError
.b301					ConcatenateString:
.b301	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.b304	85 1a		sta $1a				sta		zLTemp1+0
.b306	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b309	85 1b		sta $1b				sta 	zLTemp1+1
.b30b	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x
.b30e	85 1c		sta $1c				sta 	zLTemp1+2
.b310	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.b313	85 1d		sta $1d				sta 	zLTemp1+3
.b315	5a		phy				phy
.b316	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.b318	b1 1a		lda ($1a),y			lda 	(zlTemp1),y
.b31a	71 1c		adc ($1c),y			adc 	(zlTemp1+2),y
.b31c	7a		ply				ply
.b31d	b0 37		bcs $b356			bcs 	_CSError					; check in range.
.b31f	c9 fe		cmp #$fe			cmp 	#maxString+1
.b321	b0 33		bcs $b356			bcs 	_CSError
.b323	20 4a b7	jsr $b74a			jsr 	AllocateTempString 			; store the result
.b326	20 41 b3	jsr $b341			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.b329	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.b32c	85 1a		sta $1a				sta 	zLTemp1
.b32e	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.b331	85 1b		sta $1b				sta 	zLTemp1+1
.b333	20 41 b3	jsr $b341			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.b336	a5 20		lda $20				lda 	zTempStr 					; point current to new string
.b338	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b33b	a5 21		lda $21				lda 	zTempStr+1
.b33d	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b340	60		rts				rts
.b341					_CSCopyString:
.b341	da		phx				phx
.b342	5a		phy				phy
.b343	a0 00		ldy #$00			ldy 	#0 							; get length
.b345	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b347	f0 0a		beq $b353			beq 	_CSCSExit 					; if zero, exit
.b349	aa		tax				tax 								; put in X
.b34a					_CSCSLoop:
.b34a	c8		iny				iny 								; get next char
.b34b	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b34d	20 75 b7	jsr $b775			jsr		WriteTempString 			; copy out
.b350	ca		dex				dex 								; do whole string
.b351	d0 f7		bne $b34a			bne 	_CSCSLoop
.b353					_CSCSExit:
.b353	7a		ply				ply
.b354	fa		plx				plx
.b355	60		rts				rts
.b356					_CSError:
.b356	20 44 ab	jsr $ab44			jsr ERR_Handler
>b359	53 74 72 69 6e 67 20 74			.text "String too long",0
>b361	6f 6f 20 6c 6f 6e 67 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.b369					Unary_Sgn:
.b369	20 a6 b0	jsr $b0a6			jsr 	EvaluateNumberX 			; get value
.b36c	20 38 b7	jsr $b738			jsr 	CheckNextRParen 			; check right bracket.
.b36f	20 93 b3	jsr $b393			jsr 	GetSignCurrent 				; get sign.
.b372	09 00		ora #$00			ora 	#0
.b374	10 09		bpl $b37f			bpl		UnarySetAInteger			; if 0,1 return that.
.b376	80 00		bra $b378			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.b378					UnarySetAMinus1:
.b378	a9 ff		lda #$ff			lda 	#$FF
.b37a	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.b37d	80 05		bra $b384			bra 	UnarySetAFill
.b37f					UnarySetAInteger:
.b37f	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.b382	a9 00		lda #$00			lda 	#0
.b384					UnarySetAFill:
.b384	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b387	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b38a	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b38d	a9 01		lda #$01			lda 	#1
.b38f	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.b392	60		rts				rts
.b393					GetSignCurrent:
.b393	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; identify type.
.b396	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.b397	90 19		bcc $b3b2			bcc 	_GSCFloat
.b399	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.b39c	30 11		bmi $b3af			bmi 	_GSCMinus1
.b39e	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x
.b3a1	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.b3a4	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.b3a7	d0 03		bne $b3ac			bne 	_GSCPlus1
.b3a9					_GSCZero:
.b3a9	a9 00		lda #$00			lda 	#0
.b3ab	60		rts				rts
.b3ac					_GSCPlus1:
.b3ac	a9 01		lda #$01			lda 	#$01
.b3ae	60		rts				rts
.b3af					_GSCMinus1:
.b3af	a9 ff		lda #$ff			lda 	#$FF
.b3b1	60		rts				rts
.b3b2					_GSCFloat:
.b3b2	3c 0d 03	bit $030d,x			bit 	XS_Type,x
.b3b5	70 f2		bvs $b3a9			bvs 	_GSCZero
.b3b7	30 f6		bmi $b3af			bmi 	_GSCMinus1
.b3b9	80 f1		bra $b3ac			bra 	_GSCPlus1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.b3bb					Unary_Abs:
.b3bb	20 a6 b0	jsr $b0a6			jsr 	EvaluateNumberX 			; get value
.b3be	20 38 b7	jsr $b738			jsr 	CheckNextRParen 			; check right bracket.
.b3c1	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.b3c4	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.b3c6	f0 08		beq $b3d0			beq 	_UAMinusFloat
.b3c8	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; check MSB
.b3cb	10 0b		bpl $b3d8			bpl 	_UAExit
.b3cd	4c 9b b8	jmp $b89b			jmp 	IntegerNegateAlways 		; negation
.b3d0					_UAMinusFloat:
.b3d0	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; clear the sign bit.
.b3d3	29 7f		and #$7f			and		#$7F
.b3d5	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.b3d8					_UAExit:
.b3d8	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.b3d9					Unary_Peek:
.b3d9	a9 01		lda #$01			lda 	#1
.b3db	80 06		bra $b3e3			bra 	UPMain
.b3dd					Unary_Deek:
.b3dd	a9 02		lda #$02			lda 	#2
.b3df	80 02		bra $b3e3			bra 	UPMain
.b3e1					Unary_Leek:
.b3e1	a9 04		lda #$04			lda 	#4
.b3e3					UPMain:
.b3e3	48		pha				pha 								; set bytes to copy.
.b3e4	20 b5 b0	jsr $b0b5			jsr 	EvaluateIntegerX 			; numeric parameter
.b3e7	20 38 b7	jsr $b738			jsr 	CheckNextRParen 			; right bracket.
.b3ea	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.b3ed	85 1a		sta $1a				sta 	zLTemp1
.b3ef	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b3f2	85 1b		sta $1b				sta 	zLTemp1+1
.b3f4	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.b3f7	85 1c		sta $1c				sta 	zLTemp1+2
.b3f9	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.b3fc	85 1d		sta $1d				sta 	zLTemp1+3
.b3fe	a9 00		lda #$00			lda 	#0 							; clear target area
.b400	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b403	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b406	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b409	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b40c	68		pla				pla 								; restore bytes to copy
.b40d	da		phx				phx 								; save XY
.b40e	5a		phy				phy
.b40f	20 0b b7	jsr $b70b			jsr 	MemRead 					; read the bytes in
.b412	7a		ply				ply 								; restore and exit
.b413	fa		plx				plx
.b414	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.b415					Unary_Mod:
.b415	20 41 b4	jsr $b441			jsr 	_UMParameter 				; first parameter
.b418	20 41 b7	jsr $b741			jsr 	CheckNextComma
.b41b	da		phx				phx 								; second parameter
.b41c	e8		inx				inx
.b41d	e8		inx				inx
.b41e	e8		inx				inx
.b41f	e8		inx				inx
.b420	e8		inx				inx
.b421	e8		inx				inx
.b422	20 41 b4	jsr $b441			jsr 	_UMParameter
.b425	fa		plx				plx
.b426	20 38 b7	jsr $b738			jsr 	CheckNextRParen
.b429	20 05 b8	jsr $b805			jsr 	DivInteger32 				; divide
.b42c	a5 1a		lda $1a				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.b42e	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b431	a5 1b		lda $1b				lda 	zLTemp1+1
.b433	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b436	a5 1c		lda $1c				lda 	zLTemp1+2
.b438	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b43b	a5 1d		lda $1d				lda 	zLTemp1+3
.b43d	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b440	60		rts				rts
.b441					_UMParameter:
.b441	20 b5 b0	jsr $b0b5			jsr 	EvaluateIntegerX 			; get value
.b444	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; absolute value
.b447	10 03		bpl $b44c			bpl 	_UMNotSigned
.b449	20 9b b8	jsr $b89b			jsr 	IntegerNegateAlways
.b44c					_UMNotSigned:
.b44c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.b44d					Unary_Usr:
.b44d	20 a6 b0	jsr $b0a6			jsr 	EvaluateNumberX 			; numeric parameter
.b450	20 38 b7	jsr $b738			jsr 	CheckNextRParen 			; right bracket.
.b453	da		phx				phx 								; save XY
.b454	5a		phy				phy
.b455	ea		nop				nop
.b456	20 00 03	jsr $0300			jsr 	UserVector 					; call the USR function.
.b459	7a		ply				ply 								; and exit
.b45a	fa		plx				plx
.b45b	60		rts				rts
.b45c					USRDefault:
.b45c	20 44 ab	jsr $ab44			jsr ERR_Handler
>b45f	4e 6f 20 55 53 52 20 76			.text "No USR vector.",0
>b467	65 63 74 6f 72 2e 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.b46e					Unary_Val:
.b46e	20 be b0	jsr $b0be			jsr 	EvaluateStringX 			; get string
.b471	20 38 b7	jsr $b738			jsr 	CheckNextRParen 			; check right bracket.
.b474	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.b477	85 1e		sta $1e				sta 	zGenPtr
.b479	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b47c	85 1f		sta $1f				sta 	zGenPtr+1
.b47e	5a		phy				phy
.b47f	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.b481	b1 1e		lda ($1e),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.b483	f0 57		beq $b4dc			beq 	_UVBadNumber
.b485	48		pha				pha 								; save length.
.b486	1a		inc a				inc 	a 							; one for the length, one for the terminator
.b487	1a		inc a				inc 	a
.b488	20 4a b7	jsr $b74a			jsr 	AllocateTempString
.b48b	c8		iny				iny 								; move to the next.
.b48c	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get character
.b48e	49 2d		eor #$2d			eor 	#"-"						; zero if minus sign
.b490	8d 29 04	sta $0429			sta 	ValSign
.b493	d0 04		bne $b499			bne 	_UVNotMinus
.b495	c8		iny				iny 								; skip over it.
.b496	68		pla				pla 								; decrement character count.
.b497	3a		dec a				dec 	a
.b498	48		pha				pha
.b499					_UVNotMinus:
.b499	68		pla				pla 								; this is the count.
.b49a	48		pha		_UVCopy:pha									; copy into new temp string which is ASCIIZ
.b49b	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b49d	c8		iny				iny
.b49e	20 75 b7	jsr $b775			jsr 	WriteTempString
.b4a1	68		pla				pla
.b4a2	3a		dec a				dec 	a
.b4a3	d0 f5		bne $b49a			bne 	_UVCopy
.b4a5	20 75 b7	jsr $b775			jsr 	WriteTempString 			; make it ASCIIZ
.b4a8	18		clc				clc
.b4a9	a5 20		lda $20				lda 	zTempStr 					; tempstring +1 => genptr
.b4ab	69 01		adc #$01			adc 	#1
.b4ad	85 1e		sta $1e				sta 	zGenPtr
.b4af	a5 21		lda $21				lda 	zTempStr+1
.b4b1	69 00		adc #$00			adc 	#0
.b4b3	85 1f		sta $1f				sta 	zGenPtr+1
.b4b5	18		clc				clc
.b4b6	20 73 b9	jsr $b973			jsr 	IntFromString 				; first bit.
.b4b9	b0 21		bcs $b4dc			bcs 	_UVBadNumber
.b4bb	20 97 bf	jsr $bf97			jsr 	FPFromString				; try for a float part.
.b4be	ad 29 04	lda $0429			lda 	ValSign 					; was it negative
.b4c1	d0 13		bne $b4d6			bne 	_UVNotNegative
.b4c3	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; check if integer
.b4c6	4a		lsr a				lsr 	a
.b4c7	b0 0a		bcs $b4d3			bcs 	_UVInteger
.b4c9	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; set sign bit
.b4cc	09 80		ora #$80			ora 	#$80
.b4ce	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.b4d1	80 03		bra $b4d6			bra 	_UVNotNegative
.b4d3					_UVInteger:
.b4d3	20 9b b8	jsr $b89b			jsr 	IntegerNegateAlways 		; sign it.
.b4d6					_UVNotNegative:
.b4d6	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; used everything
.b4d8	d0 02		bne $b4dc			bne 	_UVBadNumber
.b4da	7a		ply				ply
.b4db	60		rts				rts
.b4dc					_UVBadNumber:
.b4dc	4c 33 ab	jmp $ab33			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.b4df					Unary_Str:
.b4df	20 a6 b0	jsr $b0a6			jsr 	EvaluateNumberX 			; numeric parameter
.b4e2	20 38 b7	jsr $b738			jsr 	CheckNextRParen 			; right bracket.
.b4e5	a9 00		lda #$00			lda 	#0 							; reset buffer index
.b4e7	8d 00 04	sta $0400			sta 	NumBufX
.b4ea	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.b4ed	4a		lsr a				lsr 	a
.b4ee	b0 05		bcs $b4f5			bcs 	_USInt 						; if msb set do as integer
.b4f0	20 d0 be	jsr $bed0			jsr 	FPToString 					; call fp to str otherwise
.b4f3	80 03		bra $b4f8			bra 	_USDuplicate
.b4f5	20 c0 b8	jsr $b8c0	_USInt:	jsr 	IntToString
.b4f8					_USDuplicate:
.b4f8	ad 00 04	lda $0400			lda 	NumBufX 					; chars in buffer
.b4fb	1a		inc a				inc 	a 							; one more for length
.b4fc	20 4a b7	jsr $b74a			jsr 	AllocateTempString 			; allocate space for it.
.b4ff	5a		phy				phy 								; save Y
.b500	a0 00		ldy #$00			ldy 	#0 							; start copying
.b502	b9 01 04	lda $0401,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.b505	20 75 b7	jsr $b775			jsr 	WriteTempString
.b508	c8		iny				iny
.b509	cc 00 04	cpy $0400			cpy 	NumBufX 					; done the lot
.b50c	d0 f4		bne $b502			bne 	_USCopy
.b50e	7a		ply				ply 								; restore Y
.b50f	4c fb b6	jmp $b6fb			jmp 	UnaryReturnTempStr 			; return new temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.b512					Unary_Asc:
.b512	20 be b0	jsr $b0be			jsr 	EvaluateStringX 			; string parameter
.b515	20 38 b7	jsr $b738			jsr 	CheckNextRParen 			; right bracket.
.b518	5a		phy				phy 								; get the string length
.b519	a0 00		ldy #$00			ldy 	#0
.b51b	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b51d	f0 07		beq $b526			beq 	_UAIllegal 					; must be at least one character
.b51f	c8		iny				iny
.b520	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; read it.
.b522	7a		ply				ply
.b523	4c 7f b3	jmp $b37f			jmp 	UnarySetAInteger
.b526					_UAIllegal:
.b526	4c 33 ab	jmp $ab33			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.b529					Unary_Len:
.b529	20 be b0	jsr $b0be			jsr 	EvaluateStringX 			; string parameter
.b52c	20 38 b7	jsr $b738			jsr 	CheckNextRParen 			; right bracket.
.b52f	5a		phy				phy 								; get the string length
.b530	a0 00		ldy #$00			ldy 	#0
.b532	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b534	7a		ply				ply
.b535	4c 7f b3	jmp $b37f			jmp 	UnarySetAInteger

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.b538					Unary_Mid:
.b538	20 be b0	jsr $b0be			jsr 	EvaluateStringX 				; get string.
.b53b	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.b53e	48		pha				pha
.b53f	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b542	48		pha				pha
.b543	20 41 b7	jsr $b741			jsr 	CheckNextComma 					; skip comma
.b546	20 d3 b5	jsr $b5d3			jsr 	SLIByteParameter 				; get a byte parameter (start)
.b549	48		pha				pha 									; and push it.
.b54a	20 41 b7	jsr $b741			jsr 	CheckNextComma 					; skip comma
.b54d	20 d3 b5	jsr $b5d3			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.b550	48		pha				pha 									; and push it.
.b551	80 45		bra $b598			bra 	SLIProcess
.b553					Unary_Left:
.b553	20 be b0	jsr $b0be			jsr 	EvaluateStringX 				; get string.
.b556	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.b559	48		pha				pha
.b55a	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b55d	48		pha				pha
.b55e	a9 01		lda #$01			lda 	#1 								; push start position (1)
.b560	48		pha				pha
.b561	20 41 b7	jsr $b741			jsr 	CheckNextComma 					; skip comma
.b564	20 d3 b5	jsr $b5d3			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.b567	48		pha				pha 									; and push it.
.b568	80 2e		bra $b598			bra 	SLIProcess
.b56a					Unary_Right:
.b56a	20 be b0	jsr $b0be			jsr 	EvaluateStringX 				; get string.
.b56d	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.b570	48		pha				pha
.b571	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b574	48		pha				pha
.b575	da		phx				phx 									; get the string length and push on stack.
.b576	a2 00		ldx #$00			ldx 	#0
.b578	a1 1e		lda ($1e,x)			lda		(zGenPtr,x)
.b57a	fa		plx				plx
.b57b	48		pha				pha
.b57c	20 41 b7	jsr $b741			jsr 	CheckNextComma 					; skip comma
.b57f	20 d3 b5	jsr $b5d3			jsr 	SLIByteParameter 				; get a byte parameter.
.b582	8d 25 04	sta $0425			sta 	SignCount 						; save in temporary.
.b585	68		pla				pla 									; restore string length.
.b586	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.b587	38		sec				sec
.b588	ed 25 04	sbc $0425			sbc 	SignCount 						; subtract characters needed, gives start position.
.b58b	f0 02		beq $b58f			beq 	_URStart 						; if <= 0 start from 1.
.b58d	10 02		bpl $b591			bpl 	_UROkay
.b58f					_URStart:
.b58f	a9 01		lda #$01			lda 	#1
.b591					_UROkay:
.b591	48		pha				pha 									; push start
.b592	ad 25 04	lda $0425			lda 	SignCount 						; push count of characters
.b595	48		pha				pha
.b596	80 00		bra $b598			bra 	SLIProcess
.b598					SLIProcess:
.b598	20 38 b7	jsr $b738			jsr 	CheckNextRParen 				; closing right bracket.
.b59b	68		pla				pla
.b59c	8d 2b 04	sta $042b			sta 	SliceCount 						; count in signcount
.b59f	1a		inc a				inc 	a 								; allocate +1 for it.
.b5a0	20 4a b7	jsr $b74a			jsr 	AllocateTempString
.b5a3	68		pla				pla 									; pop start number off stack.
.b5a4	f0 3f		beq $b5e5			beq 	SLIError 						; exit if start = 0
.b5a6	8d 2a 04	sta $042a			sta 	SliceStart
.b5a9	68		pla				pla  									; pop string address.
.b5aa	85 1f		sta $1f				sta 	zGenPtr+1
.b5ac	68		pla				pla
.b5ad	85 1e		sta $1e				sta 	zGenPtr
.b5af	da		phx				phx
.b5b0	5a		phy				phy
.b5b1	a2 00		ldx #$00			ldx 	#0 								; point to string length.
.b5b3	ac 2a 04	ldy $042a			ldy 	SliceStart 						; start of the string (+1 for count)
.b5b6					_SLICopy:
.b5b6	ad 2b 04	lda $042b			lda 	SliceCount 						; done count characters
.b5b9	f0 12		beq $b5cd			beq 	_SLIExit
.b5bb	ce 2b 04	dec $042b			dec 	SliceCount
.b5be	98		tya				tya 									; index of character
.b5bf	c1 1e		cmp ($1e,x)			cmp 	(zGenPtr,x)						; compare against length
.b5c1	f0 02		beq $b5c5			beq 	_SLIOk 							; if equal, okay.
.b5c3	b0 08		bcs $b5cd			bcs 	_SLIExit 						; if past end, then exit.
.b5c5	b1 1e		lda ($1e),y	_SLIOk:	lda 	(zGenPtr),y 					; copy one character
.b5c7	c8		iny				iny
.b5c8	20 75 b7	jsr $b775			jsr 	WriteTempString
.b5cb	80 e9		bra $b5b6			bra 	_SLICopy 						; go round till copied characters
.b5cd					_SLIExit:
.b5cd	7a		ply				ply 									; restore YX
.b5ce	fa		plx				plx
.b5cf	4c fb b6	jmp $b6fb			jmp 	UnaryReturnTempStr 				; return new temporary string.
.b5d2	ea		nop				nop
.b5d3					SLIByteParameter:
.b5d3	20 b5 b0	jsr $b0b5			jsr 	EvaluateIntegerX 				; get integer
.b5d6	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.b5d9	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.b5dc	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.b5df	d0 04		bne $b5e5			bne 	SLIError
.b5e1	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b5e4	60		rts				rts
.b5e5					SLIError:
.b5e5	4c 33 ab	jmp $ab33			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.b5e8					Unary_Hex:
.b5e8	20 b5 b0	jsr $b0b5			jsr 	EvaluateIntegerX 			; numeric parameter
.b5eb	20 38 b7	jsr $b738			jsr 	CheckNextRParen 			; right bracket.
.b5ee	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.b5f0	20 4a b7	jsr $b74a			jsr 	AllocateTempString			; allocate string space
.b5f3	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.b5f6	20 1d b6	jsr $b61d			jsr 	_UHConvert
.b5f9	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.b5fc	20 1d b6	jsr $b61d			jsr 	_UHConvert
.b5ff	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b602	20 1d b6	jsr $b61d			jsr 	_UHConvert
.b605	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b608	20 1d b6	jsr $b61d			jsr 	_UHConvert
.b60b	5a		phy				phy 								; get length of new string
.b60c	a0 00		ldy #$00			ldy 	#0
.b60e	b1 20		lda ($20),y			lda 	(zTempStr),y
.b610	7a		ply				ply
.b611	c9 00		cmp #$00			cmp 	#0
.b613	d0 05		bne $b61a			bne 	_UHExit 					; if it was non zero okay
.b615	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.b617	20 75 b7	jsr $b775			jsr 	WriteTempString
.b61a					_UHExit:
.b61a	4c fb b6	jmp $b6fb			jmp 	UnaryReturnTempStr 			; return new temporary string.
.b61d					_UHConvert:
.b61d	48		pha				pha
.b61e	4a		lsr a				lsr 	a 							; do MSB
.b61f	4a		lsr a				lsr 	a
.b620	4a		lsr a				lsr 	a
.b621	4a		lsr a				lsr 	a
.b622	20 26 b6	jsr $b626			jsr 	_UHNibble
.b625	68		pla				pla 								; do LSB
.b626					_UHNibble:
.b626	29 0f		and #$0f			and 	#15 						; get nibble
.b628	d0 0c		bne $b636			bne 	_UHNonZero
.b62a	5a		phy				phy									; get the length
.b62b	a0 00		ldy #$00			ldy 	#0
.b62d	b1 20		lda ($20),y			lda 	(zTempStr),y
.b62f	7a		ply				ply
.b630	c9 00		cmp #$00			cmp 	#0 							; suppress leading zeros.
.b632	f0 0d		beq $b641			beq 	_UHExit2
.b634	a9 00		lda #$00			lda 	#0
.b636					_UHNonZero:
.b636	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.b638	90 02		bcc $b63c			bcc 	_UHDigit
.b63a	69 06		adc #$06			adc 	#7-1
.b63c					_UHDigit:
.b63c	69 30		adc #$30			adc 	#48
.b63e	20 75 b7	jsr $b775			jsr 	WriteTempString				; output.
.b641					_UHExit2:
.b641	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.b642					Unary_Dec:
.b642	20 be b0	jsr $b0be			jsr 	EvaluateStringX 			; string parameter
.b645	20 38 b7	jsr $b738			jsr 	CheckNextRParen 			; right bracket.
.b648	5a		phy				phy
.b649	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.b64b	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b64d	f0 4c		beq $b69b			beq 	_UDFail 					; must fail if zero.
.b64f	8d 25 04	sta $0425			sta 	SignCount 					; use SignCount as a counter
.b652	a9 00		lda #$00			lda 	#0 							; set result to zero integer.
.b654	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b657	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b65a	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b65d	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b660	a9 01		lda #$01			lda 	#1
.b662	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.b665					_UDConvertLoop:
.b665	5a		phy				phy 								; shift mantissa left 4
.b666	a0 04		ldy #$04			ldy 	#4
.b668					_UDShift:
.b668	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x
.b66b	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.b66e	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.b671	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.b674	88		dey				dey
.b675	d0 f1		bne $b668			bne 	_UDShift
.b677	7a		ply				ply
.b678	c8		iny				iny 								; next character
.b679	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; fetch it.
.b67b	20 9e b6	jsr $b69e			jsr 	ConvertUpper 				; convert to U/C
.b67e	c9 30		cmp #$30			cmp 	#"0"
.b680	90 19		bcc $b69b			bcc 	_UDFail
.b682	c9 3a		cmp #$3a			cmp 	#"9"+1
.b684	90 06		bcc $b68c			bcc 	_UDOkay
.b686	e9 37		sbc #$37			sbc 	#7+"0" 						; alpha fudge
.b688	c9 10		cmp #$10			cmp 	#16
.b68a	b0 0f		bcs $b69b			bcs 	_UDFail
.b68c					_UDOkay:
.b68c	29 0f		and #$0f			and 	#15 						; nibble only
.b68e	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x
.b691	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b694	ce 25 04	dec $0425			dec 	SignCount 					; do it for each character
.b697	d0 cc		bne $b665			bne 	_UDConvertLoop
.b699	7a		ply				ply
.b69a	60		rts				rts
.b69b					_UDFail:
.b69b	4c 33 ab	jmp $ab33			jmp 	BadParamError
.b69e					ConvertUpper:
.b69e	c9 61		cmp #$61			cmp 	#"a"
.b6a0	90 07		bcc $b6a9			bcc 	_CUExit
.b6a2	c9 7b		cmp #$7b			cmp 	#"z"+1
.b6a4	b0 03		bcs $b6a9			bcs 	_CUExit
.b6a6	38		sec				sec
.b6a7	e9 20		sbc #$20			sbc 	#32
.b6a9	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.b6aa					Unary_Chr:
.b6aa	20 b5 b0	jsr $b0b5			jsr 	EvaluateIntegerX			; numeric parameter
.b6ad	20 38 b7	jsr $b738			jsr 	CheckNextRParen 			; right bracket.
.b6b0	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.b6b3	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.b6b6	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.b6b9	d0 0e		bne $b6c9			bne 	_UCChar
.b6bb	a9 01		lda #$01			lda 	#1 							; one character string
.b6bd	20 4a b7	jsr $b74a			jsr 	AllocateTempString
.b6c0	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.b6c3	20 75 b7	jsr $b775			jsr 	WriteTempString
.b6c6	4c fb b6	jmp $b6fb			jmp 	UnaryReturnTempStr
.b6c9					_UCChar:
.b6c9	4c 33 ab	jmp $ab33			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.b6cc					Unary_Spc:
.b6cc	20 b5 b0	jsr $b0b5			jsr 	EvaluateIntegerX 			; numeric parameter
.b6cf	20 38 b7	jsr $b738			jsr 	CheckNextRParen 			; right bracket.
.b6d2	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.b6d5	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.b6d8	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.b6db	d0 1b		bne $b6f8			bne 	_USSize
.b6dd	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b6e0	c9 fe		cmp #$fe			cmp 	#maxString+1
.b6e2	b0 14		bcs $b6f8			bcs 	_USSize
.b6e4	48		pha				pha 								; save length
.b6e5	1a		inc a				inc 	a 							; allocate one more.
.b6e6	20 4a b7	jsr $b74a			jsr 	AllocateTempString
.b6e9	68		pla				pla 								; get length
.b6ea	f0 0f		beq $b6fb			beq 	UnaryReturnTempStr 			; return the current temp string
.b6ec					_USLoop:
.b6ec	48		pha				pha
.b6ed	a9 20		lda #$20			lda 	#" "
.b6ef	20 75 b7	jsr $b775			jsr 	WriteTempString
.b6f2	68		pla				pla
.b6f3	3a		dec a				dec 	a
.b6f4	d0 f6		bne $b6ec			bne 	_USLoop
.b6f6	80 03		bra $b6fb			bra 	UnaryReturnTempStr
.b6f8					_USSize:
.b6f8	4c 33 ab	jmp $ab33			jmp 	BadParamError
.b6fb					UnaryReturnTempStr:
.b6fb	a5 20		lda $20				lda 	zTempStr 					; copy temp string addr -> mantissa
.b6fd	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b700	a5 21		lda $21				lda 	zTempStr+1
.b702	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b705	a9 02		lda #$02			lda 	#2 							; set type to string
.b707	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.b70a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/4510.asm

.b70b	db		phz		MemRead:phz
.b70c	8d 25 04	sta $0425			sta 	SignCount 					; save count
.b70f	a3 00		ldz #$00			ldz 	#0 							; start from here
.b711	ea		nop		_MLoop1:nop
.b712	b2 1a		lda ($1a),z			lda 	(zlTemp1),z 				; read the long address
.b714	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; copy into mantissa
.b717	1b		inz				inz 								; next to copy
.b718	e8		inx				inx
.b719	dc 25 04	cpz $0425			cpz 	SignCount 					; do required # of bytes.
.b71c	d0 f3		bne $b711			bne 	_MLoop1
.b71e	fb		plz				plz
.b71f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.b720					CheckNextToken:
.b720	ea		nop				nop
.b721	d2 16		cmp ($16),z			cmp 	(zCodePtr),z
.b723	d0 02		bne $b727			bne 	CTFail 						; no, then fail
.b725	1b		inz				inz
.b726	60		rts				rts
.b727					CTFail:
.b727	20 44 ab	jsr $ab44			jsr ERR_Handler
>b72a	4d 69 73 73 69 6e 67 20			.text "Missing token",0
>b732	74 6f 6b 65 6e 00
.b738					CheckNextRParen:
.b738	ea		nop				nop
.b739	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b73b	c9 bc		cmp #$bc			cmp 	#token_rparen
.b73d	d0 e8		bne $b727			bne 	CTFail
.b73f	1b		inz				inz
.b740	60		rts				rts
.b741					CheckNextComma:
.b741	ea		nop				nop
.b742	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b744	c9 bd		cmp #$bd			cmp 	#token_comma
.b746	d0 df		bne $b727			bne 	CTFail
.b748	1b		inz				inz
.b749	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.b74a					AllocateTempString:
.b74a	48		pha				pha 								; save required count.
.b74b	a5 21		lda $21				lda 	zTempStr+1 					; check if initialised yet ?
.b74d	d0 0b		bne $b75a			bne 	_ATSInitialised
.b74f	ad 26 04	lda $0426			lda 	StringPtr 					; set temporary string ptr 1 page below available
.b752	85 20		sta $20				sta 	zTempStr					; space, this is for strings to be concreted.
.b754	ad 27 04	lda $0427			lda 	StringPtr+1
.b757	3a		dec a				dec 	a
.b758	85 21		sta $21				sta 	zTempStr+1
.b75a					_ATSInitialised:
.b75a	68		pla				pla 								; get required count back.
.b75b	49 ff		eor #$ff			eor 	#$FF 						; negate 2's complement.
.b75d	1a		inc a				inc 	a
.b75e	18		clc				clc
.b75f	65 20		adc $20				adc 	zTempStr 					; "add" to the temp string pointer
.b761	85 20		sta $20				sta 	zTempStr
.b763	a9 ff		lda #$ff			lda 	#$FF
.b765	65 21		adc $21				adc 	zTempStr+1
.b767	85 21		sta $21				sta 	zTempStr+1
.b769	a9 00		lda #$00			lda 	#0 							; clear temp string.
.b76b	5a		phy				phy
.b76c	a8		tay				tay
.b76d	91 20		sta ($20),y			sta 	(zTempStr),y
.b76f	7a		ply				ply
.b770	1a		inc a				inc 	a 							; reset the write index.
.b771	8d 28 04	sta $0428			sta 	TempStringWriteIndex
.b774	60		rts				rts
.b775					WriteTempString:
.b775	5a		phy				phy 								; save Y
.b776	ac 28 04	ldy $0428			ldy 	TempStringWriteIndex	 	; write position.
.b779	91 20		sta ($20),y			sta 	(zTempStr),y 				; write character out.
.b77b	ee 28 04	inc $0428			inc 	TempStringWriteIndex 		; increment the write position.
.b77e	98		tya				tya 								; unchanged Y is now length
.b77f	a0 00		ldy #$00			ldy 	#0
.b781	91 20		sta ($20),y			sta 	(zTempStr),y
.b783	7a		ply				ply 								; restore Y and exit
.b784	60		rts				rts
.b785					CreateTempStringCopy:
.b785	da		phx				phx 								; save X
.b786	ea		nop				nop
.b787	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b789	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.b78a	20 4a b7	jsr $b74a			jsr 	AllocateTempString 			; allocate memory for temporary string.
.b78d	ea		nop				nop
.b78e	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b790	1b		inz				inz
.b791	3a		dec a				dec 	a 							; make the actual length in charactes
.b792	3a		dec a				dec 	a
.b793	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.b795	81 20		sta ($20,x)			sta 	(zTempStr,x)
.b797	85 1a		sta $1a				sta 	zLTemp1 					; that's used as a count.
.b799	09 00		ora #$00			ora 	#0 							; if zero already, exit
.b79b	f0 0f		beq $b7ac			beq 	_CTSCExit
.b79d					_CTSCLoop:
.b79d	ea		nop				nop
.b79e	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b7a0	1b		inz				inz
.b7a1	5a		phy				phy 								; save in Y
.b7a2	e8		inx				inx 								; bump index
.b7a3	da		phx				phx 								; index into Y
.b7a4	7a		ply				ply
.b7a5	91 20		sta ($20),y			sta 	(zTempStr),y 				; save at index
.b7a7	7a		ply				ply 								; restore Y
.b7a8	c6 1a		dec $1a				dec 	zLTemp1 					; do for each character
.b7aa	d0 f1		bne $b79d			bne 	_CTSCLoop
.b7ac					_CTSCExit:
.b7ac	fa		plx				plx 								; restore X
.b7ad	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.b7ae					MulInteger32:
.b7ae	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.b7b1	9d 14 03	sta $0314,x			sta 	XS3_Mantissa,x
.b7b4	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b7b7	9d 15 03	sta $0315,x			sta 	XS3_Mantissa+1,x
.b7ba	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.b7bd	9d 16 03	sta $0316,x			sta 	XS3_Mantissa+2,x
.b7c0	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.b7c3	9d 17 03	sta $0317,x			sta 	XS3_Mantissa+3,x
.b7c6	a9 00		lda #$00			lda 	#0
.b7c8	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x 				; zero +0
.b7cb	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b7ce	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b7d1	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b7d4					_BFMMultiply:
.b7d4	bd 14 03	lda $0314,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.b7d7	29 01		and #$01			and 	#1
.b7d9	f0 03		beq $b7de			beq 	_BFMNoAdd
.b7db	20 9a b2	jsr $b29a			jsr 	AddInteger32
.b7de					_BFMNoAdd:
.b7de	1e 0e 03	asl $030e,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.b7e1	3e 0f 03	rol $030f,x			rol 	XS2_Mantissa+1,x
.b7e4	3e 10 03	rol $0310,x			rol 	XS2_Mantissa+2,x
.b7e7	3e 11 03	rol $0311,x			rol 	XS2_Mantissa+3,x
.b7ea	5e 17 03	lsr $0317,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.b7ed	7e 16 03	ror $0316,x			ror 	XS3_Mantissa+2,x
.b7f0	7e 15 03	ror $0315,x			ror 	XS3_Mantissa+1,x
.b7f3	7e 14 03	ror $0314,x			ror 	XS3_Mantissa,x
.b7f6	bd 14 03	lda $0314,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.b7f9	1d 15 03	ora $0315,x			ora 	XS3_Mantissa+1,x
.b7fc	1d 16 03	ora $0316,x			ora 	XS3_Mantissa+2,x
.b7ff	1d 17 03	ora $0317,x			ora 	XS3_Mantissa+3,x
.b802	d0 d0		bne $b7d4			bne 	_BFMMultiply
.b804	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.b805					DivInteger32:
.b805	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; check for /0
.b808	1d 0f 03	ora $030f,x			ora 	XS2_Mantissa+1,x
.b80b	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.b80e	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.b811	d0 14		bne $b827			bne 	_BFDOkay
.b813	20 44 ab	jsr $ab44			jsr ERR_Handler
>b816	44 69 76 69 73 69 6f 6e			.text "Division by Zero",0
>b81e	20 62 79 20 5a 65 72 6f 00
.b827					_BFDOkay:
.b827	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.b829	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.b82b	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.b82d	85 1c		sta $1c				sta 	zLTemp1+2
.b82f	85 1d		sta $1d				sta 	zLTemp1+3
.b831	8d 25 04	sta $0425			sta 	SignCount 					; Count of signs.
.b834	20 95 b8	jsr $b895			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.b837	da		phx				phx
.b838	e8		inx				inx
.b839	e8		inx				inx
.b83a	e8		inx				inx
.b83b	e8		inx				inx
.b83c	e8		inx				inx
.b83d	e8		inx				inx
.b83e	20 95 b8	jsr $b895			jsr 	CheckIntegerNegate
.b841	fa		plx				plx
.b842	5a		phy				phy 								; Y is the counter
.b843	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.b845					_BFDLoop:
.b845	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.b848	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.b84b	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.b84e	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.b851	26 1a		rol $1a				rol 	zLTemp1
.b853	26 1b		rol $1b				rol 	zLTemp1+1
.b855	26 1c		rol $1c				rol 	zLTemp1+2
.b857	26 1d		rol $1d				rol 	zLTemp1+3
.b859	38		sec				sec
.b85a	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.b85c	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.b85f	48		pha				pha
.b860	a5 1b		lda $1b				lda 	zLTemp1+1
.b862	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.b865	48		pha				pha
.b866	a5 1c		lda $1c				lda 	zLTemp1+2
.b868	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.b86b	48		pha				pha
.b86c	a5 1d		lda $1d				lda 	zLTemp1+3
.b86e	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.b871	90 15		bcc $b888			bcc 	_BFDNoAdd
.b873	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.b875	68		pla				pla
.b876	85 1c		sta $1c				sta 	zLTemp1+2
.b878	68		pla				pla
.b879	85 1b		sta $1b				sta 	zLTemp1+1
.b87b	68		pla				pla
.b87c	85 1a		sta $1a				sta 	zLTemp1+0
.b87e	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.b881	09 01		ora #$01			ora 	#1
.b883	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b886	80 03		bra $b88b			bra 	_BFDNext
.b888					_BFDNoAdd:
.b888	68		pla				pla 								; Throw away the intermediate calculations
.b889	68		pla				pla
.b88a	68		pla				pla
.b88b					_BFDNext:
.b88b	88		dey				dey
.b88c	d0 b7		bne $b845			bne 	_BFDLoop
.b88e	7a		ply				ply 								; restore Y and exit
.b88f	4e 25 04	lsr $0425			lsr 	SignCount 					; if sign count odd,
.b892	b0 07		bcs $b89b			bcs		IntegerNegateAlways 			; negate the result
.b894	60		rts				rts
.b895					CheckIntegerNegate:
.b895	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.b898	30 01		bmi $b89b			bmi 	IntegerNegateAlways
.b89a	60		rts				rts
.b89b					IntegerNegateAlways:
.b89b	ee 25 04	inc $0425			inc 	SignCount
.b89e	38		sec				sec
.b89f	a9 00		lda #$00			lda 	#0
.b8a1	fd 08 03	sbc $0308,x			sbc 	XS_Mantissa+0,x
.b8a4	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b8a7	a9 00		lda #$00			lda 	#0
.b8a9	fd 09 03	sbc $0309,x			sbc 	XS_Mantissa+1,x
.b8ac	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b8af	a9 00		lda #$00			lda 	#0
.b8b1	fd 0a 03	sbc $030a,x			sbc 	XS_Mantissa+2,x
.b8b4	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b8b7	a9 00		lda #$00			lda 	#0
.b8b9	fd 0b 03	sbc $030b,x			sbc 	XS_Mantissa+3,x
.b8bc	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b8bf	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.b8c0					INTToString:
.b8c0	48		pha				pha
.b8c1	5a		phy				phy
.b8c2	bd 0b 03	lda $030b,x			lda 		XS_Mantissa+3,x 		; check -ve
.b8c5	10 08		bpl $b8cf			bpl 		_ITSNotMinus
.b8c7	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.b8c9	20 60 b9	jsr $b960			jsr 		ITSOutputCharacter
.b8cc	20 9b b8	jsr $b89b			jsr 		IntegerNegateAlways 	; negate the number.
.b8cf					_ITSNotMinus:
.b8cf	a9 00		lda #$00			lda 		#0
.b8d1	8d 21 04	sta $0421			sta 		NumSuppress 			; clear the suppression flag.
.b8d4	8a		txa				txa 								; use Y for the mantissa index.
.b8d5	a8		tay				tay
.b8d6	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.b8d8					_ITSNextSubtractor:
.b8d8	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.b8da	8d 22 04	sta $0422			sta 		NumConvCount
.b8dd					_ITSSubtract:
.b8dd	38		sec				sec
.b8de	b9 08 03	lda $0308,y			lda 		XS_Mantissa,y 			; subtract number and push on stack
.b8e1	fd 3c b9	sbc $b93c,x			sbc 		_ITSSubtractors+0,x
.b8e4	48		pha				pha
.b8e5	b9 09 03	lda $0309,y			lda 		XS_Mantissa+1,y
.b8e8	fd 3d b9	sbc $b93d,x			sbc 		_ITSSubtractors+1,x
.b8eb	48		pha				pha
.b8ec	b9 0a 03	lda $030a,y			lda 		XS_Mantissa+2,y
.b8ef	fd 3e b9	sbc $b93e,x			sbc 		_ITSSubtractors+2,x
.b8f2	48		pha				pha
.b8f3	b9 0b 03	lda $030b,y			lda 		XS_Mantissa+3,y
.b8f6	fd 3f b9	sbc $b93f,x			sbc 		_ITSSubtractors+3,x
.b8f9	90 14		bcc $b90f			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.b8fb	99 0b 03	sta $030b,y			sta 		XS_Mantissa+3,y 		; save subtract off stack
.b8fe	68		pla				pla
.b8ff	99 0a 03	sta $030a,y			sta 		XS_Mantissa+2,y
.b902	68		pla				pla
.b903	99 09 03	sta $0309,y			sta 		XS_Mantissa+1,y
.b906	68		pla				pla
.b907	99 08 03	sta $0308,y			sta 		XS_Mantissa+0,y
.b90a	ee 22 04	inc $0422			inc 		NumConvCount 			; bump count.
.b90d	80 ce		bra $b8dd			bra 		_ITSSubtract 			; go round again.
.b90f					_ITSCantSubtract:
.b90f	68		pla				pla 								; throw away interim answers
.b910	68		pla				pla
.b911	68		pla				pla
.b912	ad 22 04	lda $0422			lda 		NumConvCount 			; if not zero then no suppression check
.b915	c9 30		cmp #$30			cmp 		#"0"
.b917	d0 05		bne $b91e			bne 		_ITSOutputDigit
.b919	ad 21 04	lda $0421			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.b91c	10 09		bpl $b927			bpl	 		_ITSGoNextSubtractor
.b91e					_ITSOutputDigit:
.b91e	ce 21 04	dec $0421			dec 		NumSuppress 			; suppression check will be non-zero.
.b921	ad 22 04	lda $0422			lda 		NumConvCount 			; count of subtractions
.b924	20 60 b9	jsr $b960			jsr 		ITSOutputCharacter 		; output it.
.b927					_ITSGoNextSubtractor:
.b927	e8		inx				inx 								; next dword
.b928	e8		inx				inx
.b929	e8		inx				inx
.b92a	e8		inx				inx
.b92b	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.b92d	d0 a9		bne $b8d8			bne 		_ITSNextSubtractor 		; do all the subtractors.
.b92f	98		tya				tya 								; X is back as the mantissa index
.b930	aa		tax				tax
.b931	bd 08 03	lda $0308,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.b934	09 30		ora #$30			ora 		#"0"
.b936	20 60 b9	jsr $b960			jsr 		ITSOutputCharacter
.b939	7a		ply				ply 								; and exit
.b93a	68		pla				pla
.b93b	60		rts				rts
.b93c					_ITSSubtractors:
>b93c	00 ca 9a 3b					.dword 		1000000000
>b940	00 e1 f5 05					.dword 		100000000
>b944	80 96 98 00					.dword 		10000000
>b948	40 42 0f 00					.dword 		1000000
>b94c	a0 86 01 00					.dword 		100000
>b950	10 27 00 00					.dword 		10000
>b954	e8 03 00 00					.dword 		1000
>b958	64 00 00 00					.dword 		100
>b95c	0a 00 00 00					.dword 		10
.b960					_ITSSubtractorsEnd:
.b960					ITSOutputCharacter:
.b960	48		pha				pha
.b961	da		phx				phx
.b962	ae 00 04	ldx $0400			ldx 	NumBufX 					; save digit
.b965	9d 01 04	sta $0401,x			sta 	Num_Buffer,x
.b968	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.b96a	9d 02 04	sta $0402,x			sta 	Num_Buffer+1,x
.b96d	ee 00 04	inc $0400			inc 	NumBufX						; bump pointer.
.b970	fa		plx				plx
.b971	68		pla				pla
.b972	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.b973					IntFromString:
.b973	a0 00		ldy #$00			ldy 	#0
.b975	8c 23 04	sty $0423			sty 	ExpTemp 					; this is the converted digit count.
.b978					IntFromStringY:
.b978	48		pha				pha
.b979	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.b97b	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.b97e	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b981	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b984	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b987	a9 01		lda #$01			lda 	#1
.b989	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.b98c					_IFSLoop:
.b98c	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.b98e	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.b990	90 60		bcc $b9f2			bcc 	_IFSExit
.b992	c9 3a		cmp #$3a			cmp 	#"9"+1
.b994	b0 5c		bcs $b9f2			bcs 	_IFSExit
.b996	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.b999	c9 0c		cmp #$0c			cmp 	#12
.b99b	b0 5f		bcs $b9fc			bcs 	_IFSOverflow
.b99d	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.b9a0	48		pha				pha
.b9a1	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.b9a4	48		pha				pha
.b9a5	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b9a8	48		pha				pha
.b9a9	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b9ac	48		pha				pha
.b9ad	20 11 ba	jsr $ba11			jsr 	IFSX1ShiftLeft 				; double
.b9b0	20 11 ba	jsr $ba11			jsr 	IFSX1ShiftLeft 				; x 4
.b9b3	18		clc				clc 								; add saved value x 5
.b9b4	68		pla				pla
.b9b5	7d 08 03	adc $0308,x			adc 	XS_Mantissa+0,x
.b9b8	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b9bb	68		pla				pla
.b9bc	7d 09 03	adc $0309,x			adc 	XS_Mantissa+1,x
.b9bf	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b9c2	68		pla				pla
.b9c3	7d 0a 03	adc $030a,x			adc 	XS_Mantissa+2,x
.b9c6	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b9c9	68		pla				pla
.b9ca	7d 0b 03	adc $030b,x			adc 	XS_Mantissa+3,x
.b9cd	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b9d0	20 11 ba	jsr $ba11			jsr 	IFSX1ShiftLeft 				; x 10
.b9d3	ee 23 04	inc $0423			inc 	ExpTemp 					; bump count of digits processed.
.b9d6	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.b9d8	29 0f		and #$0f			and 	#15
.b9da	c8		iny				iny
.b9db	7d 08 03	adc $0308,x			adc 	XS_Mantissa+0,x
.b9de	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b9e1	90 a9		bcc $b98c			bcc 	_IFSLoop
.b9e3	fe 09 03	inc $0309,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.b9e6	d0 a4		bne $b98c			bne 	_IFSLoop
.b9e8	fe 0a 03	inc $030a,x			inc 	XS_Mantissa+2,x
.b9eb	d0 9f		bne $b98c			bne 	_IFSLoop
.b9ed	fe 0b 03	inc $030b,x			inc 	XS_Mantissa+3,x
.b9f0	80 9a		bra $b98c			bra 	_IFSLoop
.b9f2					_IFSExit:
.b9f2	98		tya				tya 								; get offset
.b9f3					_IFSOkay:
.b9f3	38		sec				sec
.b9f4	ad 23 04	lda $0423			lda 	ExpTemp
.b9f7	f0 01		beq $b9fa			beq 	_IFSSkipFail
.b9f9	18		clc				clc
.b9fa					_IFSSkipFail:
.b9fa	68		pla				pla 								; and exit.
.b9fb	60		rts				rts
.b9fc					_IFSOverflow:
.b9fc	20 44 ab	jsr $ab44			jsr 	ERR_Handler
>b9ff	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>ba07	20 6f 76 65 72 66 6c 6f 77 00
.ba11					IFSX1ShiftLeft:
.ba11	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x
.ba14	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.ba17	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.ba1a	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.ba1d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.ba1e					FPSubtract:
.ba1e	48		pha				pha
.ba1f	bd 13 03	lda $0313,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.ba22	49 80		eor #$80			eor 	#$80
.ba24	9d 13 03	sta $0313,x			sta 	XS2_Type,x
.ba27	68		pla				pla 								; --- and fall through ---
.ba28					FPAdd:
.ba28	48		pha				pha
.ba29	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.ba2c	d0 05		bne $ba33			bne 	_FPA_NegativeLHS
.ba2e	20 50 ba	jsr $ba50			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.ba31	68		pla				pla
.ba32	60		rts				rts
.ba33					_FPA_NegativeLHS:
.ba33	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.ba36	49 80		eor #$80			eor 	#$80
.ba38	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.ba3b	bd 13 03	lda $0313,x			lda 	XS2_Type,x 					; flip the sign of B and add
.ba3e	49 80		eor #$80			eor 	#$80
.ba40	9d 13 03	sta $0313,x			sta 	XS2_Type,x
.ba43	20 50 ba	jsr $ba50			jsr 	FPAdd_Worker 				; do the add calculation.
.ba46	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip sign of X1 back
.ba49	49 80		eor #$80			eor 	#$80
.ba4b	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.ba4e	68		pla				pla
.ba4f	60		rts				rts
.ba50					FPAdd_Worker:
.ba50	3c 13 03	bit $0313,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.ba53	70 08		bvs $ba5d			bvs 	_FPAWExit 					; no change.
.ba55	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.ba58	50 07		bvc $ba61			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.ba5a	20 f5 bc	jsr $bcf5			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.ba5d					_FPAWExit:
.ba5d	20 7d bd	jsr $bd7d			jsr 	FPUNormalise 				; normalise the result.
.ba60	60		rts				rts
.ba61					_FPAWMakeSame:
.ba61	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.ba64	38		sec				sec
.ba65	fd 12 03	sbc $0312,x			sbc	 	XS2_Exponent,x 				; using subtraction
.ba68	f0 1b		beq $ba85			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.ba6a	da		phx				phx 								; save X
.ba6b	90 06		bcc $ba73			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.ba6d	e8		inx				inx
.ba6e	e8		inx				inx
.ba6f	e8		inx				inx
.ba70	e8		inx				inx
.ba71	e8		inx				inx
.ba72	e8		inx				inx
.ba73					_FPAWShiftA:
.ba73	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x 				; so shift exponent up.
.ba76	5e 0b 03	lsr $030b,x			lsr 	3+XS_Mantissa,x
.ba79	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.ba7c	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.ba7f	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.ba82	fa		plx				plx 								; restore original X
.ba83	80 dc		bra $ba61			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.ba85					_FPAW_DoArithmetic:
.ba85	3c 13 03	bit $0313,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.ba88	30 39		bmi $bac3			bmi 	_FPAW_BNegative
.ba8a	18		clc				clc
.ba8b	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.ba8e	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.ba91	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.ba94	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.ba97	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.ba9a	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.ba9d	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.baa0	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.baa3	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.baa6	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.baa9	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.baac	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.baaf	90 ac		bcc $ba5d			bcc 	_FPAWExit 					; no carry.
.bab1	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x 				; so shift exponent up.
.bab4	38		sec				sec
.bab5	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.bab8	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.babb	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.babe	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.bac1	80 9a		bra $ba5d			bra 	_FPAWExit
.bac3					_FPAW_BNegative:
.bac3	38		sec				sec
.bac4	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.bac7	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.baca	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.bacd	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.bad0	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.bad3	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.bad6	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.bad9	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.badc	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.badf	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.bae2	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.bae5	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.bae8	b0 0b		bcs $baf5			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.baea	20 22 bd	jsr $bd22			jsr 	FPUNegateInteger			; negate the mantissa
.baed	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip result sign
.baf0	49 80		eor #$80			eor 	#$80
.baf2	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.baf5					_FPAWGoExit:
.baf5	4c 5d ba	jmp $ba5d			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.baf8					FPD_IsDivZero:
.baf8	20 44 ab	jsr $ab44			jsr ERR_Handler
>bafb	44 69 76 69 73 69 6f 6e			.text "Division by zero",0
>bb03	20 62 79 20 7a 65 72 6f 00
.bb0c					FPDivide:
.bb0c	48		pha				pha
.bb0d	5a		phy				phy
.bb0e	3c 13 03	bit $0313,x			bit 	XS2_Type,x 					; check if division by zero
.bb11	70 e5		bvs $baf8			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.bb13	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.bb16	f0 03		beq $bb1b			beq 	_FPDCalculateExp
.bb18					_FPD_Exit:
.bb18	7a		ply				ply
.bb19	68		pla				pla
.bb1a	60		rts				rts
.bb1b					_FPDCalculateExp:
.bb1b	bd 12 03	lda $0312,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.bb1e	49 ff		eor #$ff			eor 	#$FF
.bb20	1a		inc a				inc 	a
.bb21	9d 12 03	sta $0312,x			sta 	XS2_Exponent,x
.bb24	20 18 bc	jsr $bc18			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.bb27	18		clc				clc 	 							; add 1 to the resulting exponent
.bb28	69 01		adc #$01			adc 	#1
.bb2a	b0 65		bcs $bb91			bcs 	_FPD_Overflow 				; which can overflow.
.bb2c	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.bb2f	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.bb31	85 1a		sta $1a				sta 	zLTemp1+0
.bb33	85 1b		sta $1b				sta 	zLTemp1+1
.bb35	85 1c		sta $1c				sta 	zLTemp1+2
.bb37	85 1d		sta $1d				sta 	zLTemp1+3
.bb39	a0 20		ldy #$20			ldy 	#32 						; times round.
.bb3b					_FPD_Loop:
.bb3b	38		sec				sec 								; calculate X1-X2 stacking result because we might
.bb3c	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; not save it.
.bb3f	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa,x
.bb42	48		pha				pha
.bb43	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.bb46	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.bb49	48		pha				pha
.bb4a	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.bb4d	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.bb50	48		pha				pha
.bb51	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.bb54	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.bb57	90 17		bcc $bb70			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.bb59	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x 			; save results out to A
.bb5c	68		pla				pla
.bb5d	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.bb60	68		pla				pla
.bb61	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.bb64	68		pla				pla
.bb65	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.bb68	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.bb6a	09 80		ora #$80			ora 	#$80
.bb6c	85 1d		sta $1d				sta 	zLTemp1+3
.bb6e	80 03		bra $bb73			bra 	_FPD_Rotates
.bb70					_FPD_NoSubtract:
.bb70	68		pla				pla 								; throw away unwanted results
.bb71	68		pla				pla
.bb72	68		pla				pla
.bb73					_FPD_Rotates:
.bb73	5e 11 03	lsr $0311,x			lsr 	3+XS2_Mantissa,x
.bb76	7e 10 03	ror $0310,x			ror 	2+XS2_Mantissa,x
.bb79	7e 0f 03	ror $030f,x			ror 	1+XS2_Mantissa,x
.bb7c	7e 0e 03	ror $030e,x			ror 	0+XS2_Mantissa,x
.bb7f	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.bb81	26 1b		rol $1b				rol 	zLTemp1+1
.bb83	26 1c		rol $1c				rol 	zLTemp1+2
.bb85	26 1d		rol $1d				rol 	zLTemp1+3
.bb87	90 02		bcc $bb8b			bcc 	_FPD_NoCarry
.bb89	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.bb8b					_FPD_NoCarry:
.bb8b	88		dey				dey 								; do 32 times
.bb8c	d0 ad		bne $bb3b			bne 	_FPD_Loop
.bb8e	4c f5 bb	jmp $bbf5			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.bb91					_FPD_Overflow:
.bb91	4c f2 bd	jmp $bdf2			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.bb94					FPMultiply:
.bb94	48		pha				pha
.bb95	5a		phy				phy
.bb96	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.bb99	70 08		bvs $bba3			bvs 	_FPM_Exit
.bb9b	3c 13 03	bit $0313,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.bb9e	50 06		bvc $bba6			bvc 	_FPM_CalcExponent
.bba0	20 f5 bc	jsr $bcf5			jsr 	FPUCopyX2ToX1
.bba3					_FPM_Exit:
.bba3	7a		ply				ply
.bba4	68		pla				pla
.bba5	60		rts				rts
.bba6					_FPM_CalcExponent:
.bba6	18		clc				clc
.bba7	20 18 bc	jsr $bc18			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.bbaa	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x 				; save the result.
.bbad	a9 00		lda #$00			lda 	#0
.bbaf	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.bbb1	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.bbb3	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.bbb5	85 1d		sta $1d				sta 	zLTemp1+3
.bbb7	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.bbb9					_FPM_Loop:
.bbb9	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x				; check LSB of long product
.bbbc	29 01		and #$01			and 	#1
.bbbe	18		clc				clc 								; clear carry for the long rotate.
.bbbf	f0 1d		beq $bbde			beq 	_FPM_NoAddition
.bbc1	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.bbc2	a5 1a		lda $1a				lda 	zLTemp1+0
.bbc4	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.bbc7	85 1a		sta $1a				sta 	zLTemp1+0
.bbc9	a5 1b		lda $1b				lda 	zLTemp1+1
.bbcb	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.bbce	85 1b		sta $1b				sta 	zLTemp1+1
.bbd0	a5 1c		lda $1c				lda 	zLTemp1+2
.bbd2	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.bbd5	85 1c		sta $1c				sta 	zLTemp1+2
.bbd7	a5 1d		lda $1d				lda 	zLTemp1+3
.bbd9	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.bbdc	85 1d		sta $1d				sta 	zLTemp1+3
.bbde					_FPM_NoAddition:
.bbde	66 1d		ror $1d				ror 	3+zLTemp1
.bbe0	66 1c		ror $1c				ror 	2+zLTemp1
.bbe2	66 1b		ror $1b				ror 	1+zLTemp1
.bbe4	66 1a		ror $1a				ror 	0+zLTemp1
.bbe6	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.bbe9	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.bbec	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.bbef	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.bbf2	88		dey				dey
.bbf3	d0 c4		bne $bbb9			bne 	_FPM_Loop 					; do this 32 times.
.bbf5					FPM_CopySignNormalize:
.bbf5	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.bbf7	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.bbfa	a5 1b		lda $1b				lda 	zLTemp1+1
.bbfc	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.bbff	a5 1c		lda $1c				lda 	zLTemp1+2
.bc01	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.bc04	a5 1d		lda $1d				lda 	zLTemp1+3
.bc06	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.bc09	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; sign is xor of signs
.bc0c	5d 13 03	eor $0313,x			eor 	XS2_Type,x
.bc0f	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bc12	20 7d bd	jsr $bd7d			jsr 	FPUNormalise 				; normalise and exit.
.bc15	7a		ply				ply
.bc16	68		pla				pla
.bc17	60		rts				rts
.bc18					FPCalculateExponent:
.bc18	18		clc				clc
.bc19	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.bc1c	7d 12 03	adc $0312,x			adc 	XS2_Exponent,x
.bc1f	b0 08		bcs $bc29			bcs 	_FPCECarry 					; carry out ?
.bc21	10 03		bpl $bc26			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.bc23	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.bc25	60		rts				rts
.bc26					_FPCEExpZero:
.bc26	a9 00		lda #$00			lda 	#0
.bc28	60		rts				rts
.bc29					_FPCECarry:
.bc29	30 03		bmi $bc2e			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.bc2b	09 80		ora #$80			ora 	#$80 						; put in right range
.bc2d	60		rts				rts
.bc2e					_FPCEOverflow:
.bc2e	4c f2 bd	jmp $bdf2			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.bc31					FPFractionalPart:
.bc31	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.bc34	38		sec				sec 								; this flag tells us to keep the fractional part
.bc35	30 0f		bmi $bc46			bmi 	FPGetPart
.bc37	60		rts				rts
.bc38					FPIntegerPart:
.bc38	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.bc3b	18		clc				clc 								; this flag says keep the integer part.
.bc3c	30 08		bmi $bc46			bmi 	FPGetPart 					; -ve exponents are 0..127
.bc3e	48		pha				pha
.bc3f	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.bc41	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bc44	68		pla				pla
.bc45	60		rts				rts
.bc46					FPGetPart:
.bc46	48		pha				pha
.bc47	5a		phy				phy 								; save Y
.bc48	08		php				php 								; save action
.bc49	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.bc4c	70 62		bvs $bcb0			bvs 	_FPGP_Exit 					; then do nothing.
.bc4e	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.bc50	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.bc52	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.bc54	85 1c		sta $1c				sta 	zLTemp1+2
.bc56	85 1d		sta $1d				sta 	zLTemp1+3
.bc58	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x				; the number of shifts.
.bc5b	38		sec				sec
.bc5c	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.bc5e	f0 12		beq $bc72			beq 	_FPGP_NoShift 				; ... if any
.bc60	c9 20		cmp #$20			cmp 	#32
.bc62	90 02		bcc $bc66			bcc 	_FPGP_NotMax
.bc64	a9 20		lda #$20			lda 	#32 						; max of 32.
.bc66					_FPGP_NotMax:
.bc66	a8		tay				tay 								; Y is the mask shift count.
.bc67					_FPGP_ShiftMask:
.bc67	46 1d		lsr $1d				lsr 	3+zLTemp1
.bc69	66 1c		ror $1c				ror 	2+zLTemp1
.bc6b	66 1b		ror $1b				ror 	1+zLTemp1
.bc6d	66 1a		ror $1a				ror 	0+zLTemp1
.bc6f	88		dey				dey
.bc70	d0 f5		bne $bc67			bne 	_FPGP_ShiftMask
.bc72					_FPGP_NoShift:
.bc72	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.bc74	8e 23 04	stx $0423			stx 	ExpTemp						; save X
.bc77					_FPGP_MaskLoop:
.bc77	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.bc7a	28		plp				plp 								; if CC we keep the top part, so we
.bc7b	08		php				php		 							; flip the mask.
.bc7c	b0 02		bcs $bc80			bcs		_FPGP_NoFlip
.bc7e	49 ff		eor #$ff			eor 	#$FF
.bc80					_FPGP_NoFlip:
.bc80	3d 08 03	and $0308,x			and 	XS_Mantissa,x 				; and into the mantissa.
.bc83	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.bc86	e8		inx				inx
.bc87	c8		iny				iny
.bc88	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.bc8a	d0 eb		bne $bc77			bne 	_FPGP_MaskLoop
.bc8c	ae 23 04	ldx $0423			ldx 	ExpTemp						; restore X
.bc8f	28		plp				plp
.bc90	08		php				php 								; get action flag on the stack
.bc91	90 05		bcc $bc98			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.bc93	a9 00		lda #$00			lda 	#0
.bc95	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bc98					_FPGP_NotFractional:
.bc98	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 						; check if \1 zero
.bc9b	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.bc9e	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.bca1	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.bca4	f0 05		beq $bcab			beq 	_FPGP_Zero 					; if zero, return zero
.bca6	20 7d bd	jsr $bd7d			jsr 	FPUNormalise
.bca9	80 05		bra $bcb0			bra 	_FPGP_Exit 					; and exit
.bcab					_FPGP_Zero:
.bcab	a9 40		lda #$40			lda 	#$40 						; set zero flag
.bcad	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bcb0					_FPGP_Exit:
.bcb0	68		pla				pla 								; throw saved action flag.
.bcb1	7a		ply				ply
.bcb2	68		pla				pla
.bcb3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.bcb4					FPCompare:
.bcb4	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.bcb7	48		pha				pha
.bcb8	bd 12 03	lda $0312,x			lda 	XS2_Exponent,x
.bcbb	48		pha				pha
.bcbc	20 1e ba	jsr $ba1e			jsr 	FPSubtract 					; calculate X1-X2
.bcbf	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.bcc2	70 2c		bvs $bcf0			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.bcc4	68		pla				pla
.bcc5	8d 23 04	sta $0423			sta 	ExpTemp						; save first exponent in temporary reg.
.bcc8	68		pla				pla
.bcc9	38		sec				sec
.bcca	ed 23 04	sbc $0423			sbc 	ExpTemp 					; calculate AX-BX
.bccd	70 15		bvs $bce4			bvs 	_FPCNotEqual				; overflow, can't be equal.
.bccf	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.bcd0	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.bcd2	b0 10		bcs $bce4			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.bcd4	38		sec				sec
.bcd5	ad 23 04	lda $0423			lda 	ExpTemp 					; get one of the exponents back.
.bcd8	e9 12		sbc #$12			sbc 	#18 						; allow for 2^18 error, relatively.
.bcda	b0 02		bcs $bcde			bcs 	_FPCNotRange 				; keep in range.
.bcdc	a9 01		lda #$01			lda 	#1
.bcde					_FPCNotRange:
.bcde	38		sec				sec
.bcdf	fd 0c 03	sbc $030c,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.bce2	b0 0e		bcs $bcf2			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.bce4					_FPCNotEqual:
.bce4	bd 0d 03	lda $030d,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.bce7	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.bce9	f0 02		beq $bced			beq 	_FPCNE2
.bceb	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.bced	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.bcee	80 04		bra $bcf4			bra 	_FPCExit
.bcf0					_FPCPullZero:
.bcf0	68		pla				pla 								; throw saved exponents
.bcf1	68		pla				pla
.bcf2					_FPCZero:
.bcf2	a9 00		lda #$00			lda 	#0 							; and return zero
.bcf4					_FPCExit:
.bcf4	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.bcf5					FPUCopyX2ToX1:
.bcf5	48		pha				pha
.bcf6	da		phx				phx
.bcf7	5a		phy				phy
.bcf8	a0 08		ldy #$08			ldy 	#8
.bcfa	bd 0e 03	lda $030e,x	_FPUC21:lda 	XS2_Mantissa,x
.bcfd	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.bd00	e8		inx				inx
.bd01	88		dey				dey
.bd02	10 f6		bpl $bcfa			bpl 	_FPUC21
.bd04	7a		ply				ply
.bd05	fa		plx				plx
.bd06	68		pla				pla
.bd07	60		rts				rts
.bd08					FPUSetInteger:
.bd08	48		pha				pha
.bd09	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.bd0c	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.bd0e	10 02		bpl $bd12			bpl 	_FPUSIExtend
.bd10	a9 ff		lda #$ff			lda 	#$FF
.bd12					_FPUSIExtend:
.bd12	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.bd15	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.bd18	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.bd1b	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.bd1d	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bd20	68		pla				pla
.bd21	60		rts				rts
.bd22					FPUNegateInteger:
.bd22	48		pha				pha
.bd23	38		sec				sec
.bd24	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.bd26	fd 08 03	sbc $0308,x			sbc 	XS_Mantissa+0,x
.bd29	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.bd2c	a9 00		lda #$00			lda 	#0
.bd2e	fd 09 03	sbc $0309,x			sbc 	XS_Mantissa+1,x
.bd31	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.bd34	a9 00		lda #$00			lda 	#0
.bd36	fd 0a 03	sbc $030a,x			sbc 	XS_Mantissa+2,x
.bd39	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.bd3c	a9 00		lda #$00			lda 	#0
.bd3e	fd 0b 03	sbc $030b,x			sbc 	XS_Mantissa+3,x
.bd41	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.bd44	68		pla				pla
.bd45	60		rts				rts
.bd46					FPUToFloat:
.bd46	48		pha				pha
.bd47	bd 0d 03	lda $030d,x			lda 	XS_Type,x					; exit if already float.
.bd4a	29 0f		and #$0f			and 	#$0F
.bd4c	f0 2d		beq $bd7b			beq 	_FPUFExit
.bd4e	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.bd50	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bd53	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.bd55	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x 				; x mantissa.
.bd58	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.bd5b	10 08		bpl $bd65			bpl		_FPUFPositive
.bd5d	20 22 bd	jsr $bd22			jsr 	FPUNegateInteger 			; negate the mantissa
.bd60	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.bd62	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bd65					_FPUFPositive:
.bd65	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.bd68	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.bd6b	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.bd6e	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.bd71	d0 05		bne $bd78			bne 	_FPUFNonZero
.bd73	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.bd75	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bd78					_FPUFNonZero:
.bd78	20 7d bd	jsr $bd7d			jsr 	FPUNormalise 				; normalise the floating point.
.bd7b					_FPUFExit:
.bd7b	68		pla				pla
.bd7c	60		rts				rts
.bd7d					FPUNormalise:
.bd7d	48		pha				pha
.bd7e	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.bd81	70 20		bvs $bda3			bvs 	_FPUNExit
.bd83	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.bd86	f0 16		beq $bd9e			beq 	_FPUNSetZero
.bd88					_FPUNLoop:
.bd88	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.bd8b	30 16		bmi $bda3			bmi 	_FPUNExit 					; if so, we are normalised.
.bd8d	1e 08 03	asl $0308,x			asl 	0+XS_Mantissa+0,x
.bd90	3e 09 03	rol $0309,x			rol 	1+XS_Mantissa+0,x
.bd93	3e 0a 03	rol $030a,x			rol 	2+XS_Mantissa+0,x
.bd96	3e 0b 03	rol $030b,x			rol 	3+XS_Mantissa+0,x
.bd99	de 0c 03	dec $030c,x			dec 	XS_Exponent,x 				; decrement exponent
.bd9c	d0 ea		bne $bd88			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.bd9e					_FPUNSetZero:
.bd9e	a9 40		lda #$40			lda 	#$40
.bda0	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; the result is now zero.
.bda3					_FPUNExit:
.bda3	68		pla				pla
.bda4	60		rts				rts
.bda5					FPUToInteger:
.bda5	48		pha				pha
.bda6	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; if already integer, exit
.bda9	29 01		and #$01			and 	#1
.bdab	d0 3e		bne $bdeb			bne 	_FPUTOI_Exit
.bdad	3c 0d 03	bit $030d,x			bit 	XS_Type,x					; if zero, return zero.
.bdb0	70 2b		bvs $bddd			bvs 	_FPUTOI_Zero
.bdb2	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.bdb5	10 26		bpl $bddd			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.bdb7	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.bdb9	b0 37		bcs $bdf2			bcs 	FP_Overflow
.bdbb					_FPUToIToInteger:
.bdbb	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.bdbe	c9 a0		cmp #$a0			cmp 	#128+32
.bdc0	f0 11		beq $bdd3			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.bdc2	fe 0c 03	inc $030c,x			inc 	XS_Exponent,X 				; increment Exponent
.bdc5	5e 0b 03	lsr $030b,x			lsr 	3+XS_Mantissa,x
.bdc8	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.bdcb	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.bdce	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.bdd1	80 e8		bra $bdbb			bra 	_FPUToIToInteger 			; keep going.
.bdd3					_FPUToICheckSign:
.bdd3	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; check sign
.bdd6	10 13		bpl $bdeb			bpl 	_FPUToI_Exit 				; exit if unsigned.
.bdd8	20 22 bd	jsr $bd22			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.bddb	80 0e		bra $bdeb			bra 	_FPUTOI_Exit
.bddd					_FPUTOI_Zero:
.bddd	a9 00		lda #$00			lda 	#0 							; return zero integer.
.bddf	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.bde2	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.bde5	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.bde8	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.bdeb					_FPUToI_Exit:
.bdeb	a9 01		lda #$01			lda 	#1 							; set type to integer
.bded	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bdf0	68		pla				pla
.bdf1	60		rts				rts
.bdf2					FP_Overflow:
.bdf2	20 44 ab	jsr $ab44			jsr ERR_Handler
>bdf5	46 6c 6f 61 74 69 6e 67			.text "Floating Point overflow",0
>bdfd	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.be0d					FPUTimes10:
.be0d	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.be10	85 1a		sta $1a				sta 	ZLTemp1+0
.be12	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.be15	85 1b		sta $1b				sta 	ZLTemp1+1
.be17	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.be1a	85 1c		sta $1c				sta 	ZLTemp1+2
.be1c	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.be1f	85 1d		sta $1d				sta 	ZLTemp1+3
.be21	20 65 be	jsr $be65			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.be24	20 65 be	jsr $be65			jsr 	_FPUT_LSR_ZLTemp1
.be27	18		clc				clc
.be28	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.be2b	65 1a		adc $1a				adc 	ZLTemp1+0
.be2d	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.be30	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.be33	65 1b		adc $1b				adc 	ZLTemp1+1
.be35	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.be38	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.be3b	65 1c		adc $1c				adc 	ZLTemp1+2
.be3d	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.be40	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.be43	65 1d		adc $1d				adc 	ZLTemp1+3
.be45	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.be48	90 0f		bcc $be59			bcc 	_FPUTimes10
.be4a	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.be4d	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.be50	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.be53	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.be56	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x				; fix exponent
.be59					_FPUTimes10:
.be59	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.be5c	18		clc				clc
.be5d	69 03		adc #$03			adc 	#3
.be5f	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.be62	b0 8e		bcs $bdf2			bcs 	FP_Overflow 				; error
.be64	60		rts				rts
.be65					_FPUT_LSR_ZLTemp1:
.be65	46 1d		lsr $1d				lsr 	ZLTemp1+3
.be67	66 1c		ror $1c				ror 	ZLTemp1+2
.be69	66 1b		ror $1b				ror 	ZLTemp1+1
.be6b	66 1a		ror $1a				ror 	ZLTemp1+0
.be6d	60		rts				rts
.be6e					FPUScale10A:
.be6e	5a		phy				phy
.be6f	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.be71	f0 3d		beq $beb0			beq 	_FPUScaleExit
.be73	da		phx				phx 								; save X
.be74	e8		inx				inx
.be75	e8		inx				inx
.be76	e8		inx				inx
.be77	e8		inx				inx
.be78	e8		inx				inx
.be79	e8		inx				inx
.be7a	a8		tay				tay 								; save power scalar in Y.
.be7b	a9 00		lda #$00			lda 	#0
.be7d	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.be80	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.be83	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.be86	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.be89	a9 80		lda #$80			lda 	#$80
.be8b	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.be8e	a9 81		lda #$81			lda 	#$81
.be90	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.be93	5a		phy				phy 								; save 10^n on stack.
.be94	c0 00		cpy #$00			cpy 	#0
.be96	10 05		bpl $be9d			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.be98	98		tya				tya
.be99	49 ff		eor #$ff			eor 	#$FF
.be9b	1a		inc a				inc 	a
.be9c	a8		tay				tay
.be9d					_FPUSAbs:
.be9d	20 0d be	jsr $be0d			jsr 	FPUTimes10
.bea0	88		dey				dey
.bea1	d0 fa		bne $be9d			bne 	_FPUSAbs 					; tos is now 10^|AC|
.bea3	68		pla				pla 								; restore count in A
.bea4	fa		plx				plx 								; restore X pointing to number to scale.
.bea5	0a		asl a				asl 	a
.bea6	b0 05		bcs $bead			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.bea8	20 94 bb	jsr $bb94			jsr 	FPMultiply 					; if clear multiply.
.beab	80 03		bra $beb0			bra		_FPUScaleExit
.bead					_FPUSDivide:
.bead	20 0c bb	jsr $bb0c			jsr 	FPDivide
.beb0					_FPUScaleExit:
.beb0	7a		ply				ply
.beb1	60		rts				rts
.beb2					FPUCopyToNext:
.beb2	a0 06		ldy #$06			ldy 		#6
.beb4	da		phx				phx
.beb5					_FPUCopy1:
.beb5	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x
.beb8	9d 0e 03	sta $030e,x			sta 	XS2_Mantissa,x
.bebb	e8		inx				inx
.bebc	88		dey				dey
.bebd	d0 f6		bne $beb5			bne 	_FPUCopy1
.bebf	fa		plx				plx
.bec0	60		rts				rts
.bec1					FPUCopyFromNext:
.bec1	a0 06		ldy #$06			ldy 		#6
.bec3	da		phx				phx
.bec4					_FPUCopy1:
.bec4	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa,x
.bec7	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.beca	e8		inx				inx
.becb	88		dey				dey
.becc	d0 f6		bne $bec4			bne 	_FPUCopy1
.bece	fa		plx				plx
.becf	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.bed0					FPToString:
.bed0	48		pha				pha
.bed1	5a		phy				phy
.bed2	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; check zero flag
.bed5	50 0a		bvc $bee1			bvc 		_FPTSIsFloat 			; if zero,
.bed7					_FPTSZero:
.bed7	a9 30		lda #$30			lda 		#"0"
.bed9	20 60 b9	jsr $b960			jsr 		ITSOutputCharacter
.bedc					_FPTSExit:
.bedc	7a		ply				ply
.bedd	68		pla				pla
.bede	60		rts				rts
.bedf	80 fb		bra $bedc			bra 		_FPTSExit
.bee1					_FPTSIsFloat:
.bee1	bd 0d 03	lda $030d,x			lda 		XS_Type,x 				; is it signed ?
.bee4	10 0a		bpl $bef0			bpl 		_FPTSNotSigned
.bee6	a9 00		lda #$00			lda 		#0 						; clear sign flag
.bee8	9d 0d 03	sta $030d,x			sta 		XS_Type,x
.beeb	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.beed	20 60 b9	jsr $b960			jsr 		ITSOutputCharacter
.bef0					_FPTSNotSigned:
.bef0	bd 0c 03	lda $030c,x			lda 		XS_Exponent,x
.bef3	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.bef5	b0 09		bcs $bf00			bcs 		_FPTSExponent
.bef7	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.bef9	90 05		bcc $bf00			bcc 		_FPTSExponent 			;
.befb					_FPTSStandard:
.befb	20 44 bf	jsr $bf44			jsr 		FPTOutputBody 			; output the body.
.befe	80 dc		bra $bedc			bra 		_FPTSExit
.bf00					_FPTSExponent:
.bf00	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.bf02	8d 24 04	sta $0424			sta 		ExpCount
.bf05					_FPTSExponentLoop:
.bf05	bd 0c 03	lda $030c,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.bf08	10 0e		bpl $bf18			bpl 		_FPTSTimes
.bf0a	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.bf0c	90 14		bcc $bf22			bcc 		_FPTSScaledToExp
.bf0e	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.bf10	20 6e be	jsr $be6e			jsr 		FPUScale10A
.bf13	ee 24 04	inc $0424			inc 		ExpCount
.bf16	80 ed		bra $bf05			bra 		_FPTSExponentLoop
.bf18					_FPTSTimes:
.bf18	a9 01		lda #$01			lda 		#1
.bf1a	20 6e be	jsr $be6e			jsr 		FPUScale10A
.bf1d	ce 24 04	dec $0424			dec 		ExpCount
.bf20	80 e3		bra $bf05			bra 		_FPTSExponentLoop
.bf22					_FPTSScaledToExp:
.bf22	20 44 bf	jsr $bf44			jsr 		FPTOutputBody 			; output the body.
.bf25	a9 65		lda #$65			lda 		#"e"					; output E
.bf27	20 60 b9	jsr $b960			jsr 		ITSOutputCharacter
.bf2a	ad 24 04	lda $0424			lda 		ExpCount 				; get the exponent
.bf2d	9d 08 03	sta $0308,x			sta 		XS_Mantissa,x
.bf30	29 80		and #$80			and 		#$80 					; sign extend it
.bf32	f0 02		beq $bf36			beq 		_FPTSSExt
.bf34	a9 ff		lda #$ff			lda 		#$FF
.bf36					_FPTSSExt:
.bf36	9d 09 03	sta $0309,x			sta 		XS_Mantissa+1,x
.bf39	9d 0a 03	sta $030a,x			sta 		XS_Mantissa+2,x
.bf3c	9d 0b 03	sta $030b,x			sta 		XS_Mantissa+3,x
.bf3f	20 c0 b8	jsr $b8c0			jsr 		INTToString 			; output the exponent.
.bf42	80 98		bra $bedc			bra			_FPTSExit 				; and exit.
.bf44					FPTOutputBody:
.bf44	20 b2 be	jsr $beb2			jsr 		FPUCopyToNext 			; copy to next slot.
.bf47	20 a5 bd	jsr $bda5			jsr 		FPUToInteger 			; convert to an integer
.bf4a	20 c0 b8	jsr $b8c0			jsr 		INTToString 			; output the main integer part.
.bf4d	20 c1 be	jsr $bec1			jsr 		FPUCopyFromNext 		; get the fractional part back.
.bf50	20 31 bc	jsr $bc31			jsr 		FPFractionalPart 		; get the decimal part.
.bf53	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; any fractional part.
.bf56	70 3e		bvs $bf96			bvs 		_FPTOExit 				; if not, exit now.
.bf58	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.bf5a	20 60 b9	jsr $b960			jsr 		ITSOutputCharacter
.bf5d					_FPOutLoop:
.bf5d	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; finally reached zero.
.bf60	70 1e		bvs $bf80			bvs 		_FPStripZeros 			; strip trailing zeros
.bf62	20 0d be	jsr $be0d			jsr 		FPUTimes10 				; multiply by 10
.bf65	20 b2 be	jsr $beb2			jsr 		FPUCopyToNext			; copy to next slot.
.bf68	20 a5 bd	jsr $bda5			jsr 		FPUToInteger 			; convert to integer
.bf6b	bd 08 03	lda $0308,x			lda 		XS_Mantissa+0,x 		; print digit.
.bf6e	09 30		ora #$30			ora 		#"0"
.bf70	20 60 b9	jsr $b960			jsr 		ITSOutputCharacter
.bf73	20 c1 be	jsr $bec1			jsr 		FPUCopyFromNext 		; get it back
.bf76	20 31 bc	jsr $bc31			jsr 		FPFractionalPart 		; get fractional part
.bf79	ad 00 04	lda $0400			lda 		NumBufX 				; done 11 characters yet ?
.bf7c	c9 0b		cmp #$0b			cmp 	 	#11
.bf7e	90 dd		bcc $bf5d			bcc 		_FPOutLoop 				; if so, keep going till zero.
.bf80					_FPStripZeros:
.bf80	ac 00 04	ldy $0400			ldy 		NumBufX 				; strip trailing zeros.
.bf83					_FPStripLoop:
.bf83	88		dey				dey 								; back one, if at start then no strip
.bf84	f0 10		beq $bf96			beq 		_FPToExit
.bf86	b9 01 04	lda $0401,y			lda 		Num_Buffer,y 			; keep going if "0"
.bf89	c9 30		cmp #$30			cmp 		#"0"
.bf8b	f0 f6		beq $bf83			beq 		_FPStripLoop
.bf8d	c8		iny				iny
.bf8e	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.bf90	99 01 04	sta $0401,y			sta 		Num_Buffer,y
.bf93	8c 00 04	sty $0400			sty 		NumBufX 				; update position.
.bf96					_FPTOExit:
.bf96	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.bf97					FPFromString:
.bf97	48		pha				pha 								; push A
.bf98	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.bf9a	c9 2e		cmp #$2e			cmp 	#"."
.bf9c	f0 03		beq $bfa1			beq	 	_FPFIsDecimal
.bf9e	4c 04 c0	jmp $c004			jmp 	_FPFNotDecimal
.bfa1					_FPFIsDecimal:
.bfa1	c8		iny				iny 								; consume the decimal.
.bfa2	20 46 bd	jsr $bd46			jsr 	FPUToFloat 					; convert the integer to float.
.bfa5	da		phx				phx 								; save X.
.bfa6	5a		phy				phy 								; save decimal start position
.bfa7	e8		inx				inx
.bfa8	e8		inx				inx
.bfa9	e8		inx				inx
.bfaa	e8		inx				inx
.bfab	e8		inx				inx
.bfac	e8		inx				inx
.bfad	20 78 b9	jsr $b978			jsr 	INTFromStringY 				; get the part after the DP.
.bfb0	20 46 bd	jsr $bd46			jsr 	FPUToFloat 					; convert that to a float.
.bfb3	68		pla				pla 								; calculate - chars consumed.
.bfb4	8c 23 04	sty $0423			sty 	ExpTemp
.bfb7	38		sec				sec
.bfb8	ed 23 04	sbc $0423			sbc 	ExpTemp 					; this is the shift amount
.bfbb	20 6e be	jsr $be6e			jsr 	FPUScale10A 				; scale it by 10^AC
.bfbe	fa		plx				plx 								; restore original X
.bfbf	20 28 ba	jsr $ba28			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.bfc2	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.bfc4	c9 45		cmp #$45			cmp 	#"E"
.bfc6	f0 04		beq $bfcc			beq 	_FPFExponent
.bfc8	c9 65		cmp #$65			cmp 	#"e"
.bfca	d0 38		bne $c004			bne 	_FPFNotDecimal 				; no, then exit normally.
.bfcc					_FPFExponent:
.bfcc	c8		iny				iny 								; skip over E symbol.
.bfcd	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.bfcf	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.bfd1	d0 01		bne $bfd4			bne 	_FPFGotSign
.bfd3	c8		iny				iny 								; if it was - skip over it.
.bfd4					_FPFGotSign:
.bfd4	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.bfd5	da		phx				phx
.bfd6	e8		inx				inx
.bfd7	e8		inx				inx
.bfd8	e8		inx				inx
.bfd9	e8		inx				inx
.bfda	e8		inx				inx
.bfdb	e8		inx				inx
.bfdc	20 78 b9	jsr $b978			jsr 	INTFromStringY 				; get the exponent
.bfdf	fa		plx				plx 								; restore X.
.bfe0	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.bfe3	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.bfe6	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.bfe9	d0 1b		bne $c006			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.bfeb	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.bfee	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.bff0	b0 14		bcs $c006			bcs 	_FPFXOverflow
.bff2	68		pla				pla 								; get direction
.bff3	d0 09		bne $bffe			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.bff5	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.bff8	49 ff		eor #$ff			eor 	#$FF
.bffa	1a		inc a				inc 	a
.bffb	9d 0e 03	sta $030e,x			sta 	XS2_Mantissa+0,x
.bffe					_FPFXScale:
.bffe	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.c001	20 6e be	jsr $be6e			jsr 	FPUScale10A 				; scale by the exponent.
.c004					_FPFNotDecimal:
.c004	68		pla				pla
.c005	60		rts				rts
.c006					_FPFXOverflow:
.c006	20 44 ab	jsr $ab44			jsr 	ERR_Handler
>c009	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>c011	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.c018					Unary_Rnd:
.c018	20 a6 b0	jsr $b0a6			jsr 	EvaluateNumberX 			; get value
.c01b	20 38 b7	jsr $b738			jsr 	CheckNextRParen 			; check right bracket.
.c01e	20 93 b3	jsr $b393			jsr 	GetSignCurrent 				; get sign -1,0,1.
.c021	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.c023	30 10		bmi $c035			bmi 	_URSetSeed
.c025	f0 2c		beq $c053			beq 	_URMakeRandom 				; if zero return same number.
.c027	da		phx				phx
.c028	a2 00		ldx #$00			ldx 	#0
.c02a	20 90 c0	jsr $c090			jsr 	Random16
.c02d	a2 02		ldx #$02			ldx 	#2
.c02f	20 90 c0	jsr $c090			jsr 	Random16
.c032	fa		plx				plx
.c033	80 1e		bra $c053			bra 	_URMakeRandom
.c035					_URSetSeed:
.c035	20 46 bd	jsr $bd46			jsr 	FPUToFloat 					; make it a float to twiddle it.
.c038	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.c03b	8d 2c 04	sta $042c			sta 	RandomSeed+0
.c03e	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.c041	8d 2d 04	sta $042d			sta 	RandomSeed+1
.c044	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.c047	8d 2e 04	sta $042e			sta 	RandomSeed+2
.c04a	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.c04d	0a		asl a				asl 	a
.c04e	49 db		eor #$db			eor 	#$DB
.c050	8d 2f 04	sta $042f			sta 	RandomSeed+3
.c053					_URMakeRandom:
.c053	ad 2c 04	lda $042c			lda 	RandomSeed+0 				; check if seed is zero.
.c056	0d 2d 04	ora $042d			ora 	RandomSeed+1
.c059	0d 2e 04	ora $042e			ora 	RandomSeed+2
.c05c	0d 2f 04	ora $042f			ora 	RandomSeed+3
.c05f	d0 0a		bne $c06b			bne 	_URNotZero
.c061	a9 47		lda #$47			lda 	#$47
.c063	8d 2d 04	sta $042d			sta 	RandomSeed+1				; if it is, make it non zero.
.c066	a9 3d		lda #$3d			lda 	#$3D
.c068	8d 2f 04	sta $042f			sta 	RandomSeed+3
.c06b					_URNotZero:
.c06b	ad 2c 04	lda $042c			lda 	RandomSeed+0 				; copy seed into mantissa.
.c06e	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.c071	ad 2d 04	lda $042d			lda 	RandomSeed+1
.c074	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.c077	ad 2e 04	lda $042e			lda 	RandomSeed+2
.c07a	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.c07d	ad 2f 04	lda $042f			lda 	RandomSeed+3
.c080	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.c083	a9 00		lda #$00			lda 	#$00 						; set type to float.
.c085	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.c088	a9 80		lda #$80			lda 	#$80
.c08a	9d 0c 03	sta $030c,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.c08d	4c 7d bd	jmp $bd7d			jmp 	FPUNormalise
.c090					Random16:
.c090	5e 2d 04	lsr $042d,x			lsr 	RandomSeed+1,x				; shift seed right
.c093	7e 2c 04	ror $042c,x			ror 	RandomSeed,x
.c096	90 08		bcc $c0a0			bcc 	_R16_NoXor
.c098	bd 2d 04	lda $042d,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.c09b	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.c09d	9d 2d 04	sta $042d,x			sta 	RandomSeed+1,x
.c0a0					_R16_NoXor:
.c0a0	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.c0a1					Unary_Int:
.c0a1	20 a6 b0	jsr $b0a6			jsr 	EvaluateNumberX 			; get value
.c0a4	20 38 b7	jsr $b738			jsr 	CheckNextRParen 			; check right bracket.
.c0a7	4c a5 bd	jmp $bda5			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.c0aa					TIM_Error:
.c0aa	20 35 a0	jsr $a035			jsr 	IFT_UpLine 					; go up one line.
.c0ad	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.c0af	80 02		bra $c0b3			bra 	TIM_ShowPrompt
.c0b1					TIM_NewCommand:
.c0b1	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.c0b3					TIM_ShowPrompt:
.c0b3	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.c0b6	20 06 a1	jsr $a106			jsr 	IFT_ReadLine	 			; get character, go to next line
.c0b9	20 68 a0	jsr $a068			jsr 	IFT_NewLine					; go to next line.
.c0bc	86 10		stx $10				stx 	zTemp1 						; save line read address
.c0be	84 11		sty $11				sty 	zTemp1+1
.c0c0	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.c0c2	b1 10		lda ($10),y			lda 	(zTemp1),y
.c0c4	c9 3f		cmp #$3f			cmp 	#"?"
.c0c6	f0 04		beq $c0cc			beq 	TIM_SkipFirst
.c0c8	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.c0ca	d0 01		bne $c0cd			bne 	TIM_NotDot
.c0cc					TIM_SkipFirst:
.c0cc	c8		iny				iny
.c0cd					TIM_NotDot:
.c0cd	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.c0cf	c9 52		cmp #$52			cmp 	#"R"						; show registers
.c0d1	f0 6e		beq $c141			beq 	TIM_ShowRegisters
.c0d3	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.c0d5	f0 12		beq $c0e9			beq 	TIM_ShowMemory
.c0d7	c9 47		cmp #$47			cmp 	#"G"						; execute
.c0d9	f0 49		beq $c124			beq 	TIM_Execute
.c0db	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.c0dd	f0 07		beq $c0e6			beq 	TIM_GoLoadMemory
.c0df	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.c0e1	d0 c7		bne $c0aa			bne 	TIM_Error
.c0e3	4c 66 c2	jmp $c266			jmp 	TIM_UpdateRegisters
.c0e6					TIM_GoLoadMemory:
.c0e6	4c 91 c2	jmp $c291			jmp 	TIM_LoadMemory
.c0e9					TIM_ShowMemory:
.c0e9	20 df c1	jsr $c1df			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.c0ec	b0 bc		bcs $c0aa			bcs 	TIM_Error
.c0ee	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.c0f0	85 12		sta $12				sta 	zTemp2
.c0f2	a5 15		lda $15				lda 	zTemp3+1
.c0f4	85 13		sta $13				sta 	zTemp2+1
.c0f6	20 df c1	jsr $c1df			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.c0f9	90 08		bcc $c103			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.c0fb	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.c0fd	85 14		sta $14				sta 	zTemp3
.c0ff	a5 13		lda $13				lda 	zTemp2+1
.c101	85 15		sta $15				sta 	zTemp3+1
.c103					_TIMSM_Start:
.c103	20 b7 c1	jsr $c1b7			jsr 	TIM_WriteLine 				; write one line of hex out
.c106	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.c108	18		clc				clc
.c109	69 10		adc #$10			adc 	#16
.c10b	85 12		sta $12				sta 	zTemp2
.c10d	90 02		bcc $c111			bcc 	_TIMSM_NoCarry
.c10f	e6 13		inc $13				inc 	zTemp2+1
.c111					_TIMSM_NoCarry:
.c111	20 f1 a1	jsr $a1f1			jsr 	IF_CheckBreak 				; check CTL+C
.c114	d0 0b		bne $c121			bne 	_TIMSM_Ends 				; if pressed break out.
.c116	38		sec				sec 								; check past the end address in zTemp3
.c117	a5 14		lda $14				lda 	zTemp3
.c119	e5 12		sbc $12				sbc 	zTemp2
.c11b	a5 15		lda $15				lda 	zTemp3+1
.c11d	e5 13		sbc $13				sbc 	zTemp2+1
.c11f	10 e2		bpl $c103			bpl 	_TIMSM_Start
.c121					_TIMSM_Ends:
.c121	4c b1 c0	jmp $c0b1			jmp 	TIM_NewCommand
.c124					TIM_Execute:
.c124	20 df c1	jsr $c1df			jsr 	TIM_GetHex 					; get the execute address
.c127	b0 81		bcs $c0aa			bcs 	TIM_Error 					; not legitimate
.c129	ae 39 04	ldx $0439			ldx 	TIM_SP 						; set up SP
.c12c	9a		txs				txs
.c12d	ad 34 04	lda $0434			lda 	TIM_SR 						; Status for PLP
.c130	48		pha				pha
.c131	ad 35 04	lda $0435			lda 	TIM_A 						; restore AXYZ
.c134	ae 36 04	ldx $0436			ldx 	TIM_X
.c137	ac 37 04	ldy $0437			ldy 	TIM_Y
.c13a	ab 38 04	ldz $0438			ldz 	TIM_Z
.c13d	28		plp				plp 								; and PS Byte.
.c13e	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.c141					TIM_Start:
.c141					TIM_ShowRegisters:
.c141	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.c144	8d 33 04	sta $0433			sta 	TIM_IRQ+1
.c147	ad ff ff	lda $ffff			lda 	$FFFF
.c14a	8d 32 04	sta $0432			sta 	TIM_IRQ
.c14d	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.c14f					_TIMSR_Text:
.c14f	bd 7b c1	lda $c17b,x			lda 	_TIMSR_Label,x
.c152	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.c155	e8		inx				inx
.c156	e0 23		cpx #$23			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.c158	d0 f5		bne $c14f			bne 	_TIMSR_Text
.c15a	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.c15c					_TIMSR_Skip:
.c15c	e8		inx				inx
.c15d					_TIMSR_LoopSpace:
.c15d	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.c15f	b0 04		bcs $c165			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.c161	8a		txa				txa
.c162	4a		lsr a				lsr 	a
.c163	b0 05		bcs $c16a			bcs 	_TIMSR_NoSpace
.c165					_TIMSR_Space:
.c165	a9 20		lda #$20			lda 	#" "
.c167	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.c16a					_TIMSR_NoSpace:
.c16a	bd 30 04	lda $0430,x			lda 	TIM_PC,x 					; output hex value.
.c16d	20 9e c1	jsr $c19e			jsr 	TIM_WriteHex
.c170	e8		inx				inx
.c171	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.c173	d0 e8		bne $c15d			bne 	_TimSR_LoopSpace
.c175	20 68 a0	jsr $a068			jsr 	IFT_NewLine 				; new line
.c178	4c b1 c0	jmp $c0b1			jmp	 	TIM_NewCommand 				; new command.
.c17b					_TIMSR_Label:
>c17b	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>c183	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>c193	52
>c194	20 5a 52					.text 	" ZR"
>c197	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.c19e					_TIMSR_LabelEnd:
.c19e					TIM_WriteHex:
.c19e	48		pha				pha 								; save A
.c19f	4a		lsr a				lsr 	a 							; shift MSB->LSB
.c1a0	4a		lsr a				lsr 	a
.c1a1	4a		lsr a				lsr 	a
.c1a2	4a		lsr a				lsr 	a
.c1a3	20 a7 c1	jsr $c1a7			jsr 	_TIMWH_Nibble 				; print MSB
.c1a6	68		pla				pla 								; restore and print LSB
.c1a7					_TIMWH_Nibble:
.c1a7	48		pha				pha
.c1a8	29 0f		and #$0f			and 	#15 						; mask out
.c1aa	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.c1ac	90 02		bcc $c1b0			bcc 	_TIMWHNoLetter
.c1ae	69 06		adc #$06			adc 	#6
.c1b0					_TIMWHNoLetter:
.c1b0	69 30		adc #$30			adc 	#48
.c1b2	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter 			; print it out.
.c1b5	68		pla				pla
.c1b6	60		rts				rts
.c1b7					TIM_WriteLine:
.c1b7	a9 2e		lda #$2e			lda 	#"." 						; prompt
.c1b9	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.c1bc	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.c1be	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.c1c1	a5 13		lda $13				lda 	zTemp2+1 					; write address
.c1c3	20 9e c1	jsr $c19e			jsr 	TIM_WriteHex
.c1c6	a5 12		lda $12				lda 	zTemp2
.c1c8	20 9e c1	jsr $c19e			jsr 	TIM_WriteHex
.c1cb	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.c1cd					_TIMWL_Loop:
.c1cd	a9 20		lda #$20			lda 	#" "
.c1cf	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.c1d2	b1 12		lda ($12),y			lda 	(zTemp2),y
.c1d4	20 9e c1	jsr $c19e			jsr 	TIM_WriteHex
.c1d7	c8		iny				iny
.c1d8	c0 10		cpy #$10			cpy 	#16
.c1da	d0 f1		bne $c1cd			bne 	_TIMWL_Loop
.c1dc	4c 68 a0	jmp $a068			jmp 	IFT_NewLine 				; new line and exit
.c1df					TIM_GetHex:
.c1df	c8		iny				iny
.c1e0	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.c1e2	c9 20		cmp #$20			cmp 	#32
.c1e4	f0 f9		beq $c1df			beq 	TIM_GetHex
.c1e6	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.c1e8	f0 f5		beq $c1df			beq 	TIM_GetHex
.c1ea	20 13 c2	jsr $c213			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.c1ed	b0 23		bcs $c212			bcs 	_TIMGH_Exit					; if first bad then exit now.
.c1ef	a9 00		lda #$00			lda 	#0 							; zero result
.c1f1	85 14		sta $14				sta 	zTemp3
.c1f3	85 15		sta $15				sta 	zTemp3+1
.c1f5					_TIM_GHLoop:
.c1f5	20 13 c2	jsr $c213			jsr 	TIM_GetHexCharacter 		; get next character
.c1f8	b0 17		bcs $c211			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.c1fa	c8		iny				iny 								; skip over it.
.c1fb	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.c1fd	26 15		rol $15				rol 	zTemp3+1
.c1ff	06 14		asl $14				asl 	zTemp3 						; now x 2
.c201	26 15		rol $15				rol 	zTemp3+1
.c203	06 14		asl $14				asl 	zTemp3						; now x 4
.c205	26 15		rol $15				rol 	zTemp3+1
.c207	06 14		asl $14				asl 	zTemp3 						; now x 8
.c209	26 15		rol $15				rol 	zTemp3+1
.c20b	05 14		ora $14				ora 	zTemp3 						; OR result in
.c20d	85 14		sta $14				sta 	zTemp3
.c20f	80 e4		bra $c1f5			bra 	_TIM_GHLoop 				; loop round again.
.c211					_TIMGH_Okay:
.c211	18		clc				clc
.c212					_TIMGH_Exit:
.c212	60		rts				rts
.c213					TIM_GetHexCharacter:
.c213	b1 10		lda ($10),y			lda 	(zTemp1),y
.c215	38		sec				sec
.c216	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.c218	90 0e		bcc $c228			bcc 	_TIM_GHCFail
.c21a	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.c21c	90 0b		bcc $c229			bcc 	_TIM_GHCExit
.c21e	c9 11		cmp #$11			cmp 	#65-48						; < A
.c220	90 06		bcc $c228			bcc		_TIM_GHCFail
.c222	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.c224	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.c226	90 01		bcc $c229			bcc		_TIM_GHCExit
.c228					_TIM_GHCFail:
.c228	38		sec				sec
.c229					_TIM_GHCExit:
.c229	60		rts				rts
.c22a					TIM_BreakVector:
.c22a	da		phx				phx									; save X/A on stack
.c22b	48		pha				pha
.c22c	ba		tsx				tsx 								; X points to S
.c22d	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.c230	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.c232	d0 03		bne $c237			bne 	_TIMBreak					; if set, it's BRK
.c234	68		pla				pla 								; abandon routine.
.c235	fa		plx				plx
.c236	40		rti				rti
.c237					_TIMBreak:
.c237	68		pla				pla 								; save A X Y and maybe Z
.c238	8d 35 04	sta $0435			sta 	TIM_A
.c23b	fa		plx				plx
.c23c	8e 36 04	stx $0436			stx 	TIM_X
.c23f	8c 37 04	sty $0437			sty 	TIM_Y
.c242	9c 38 04	stz $0438			stz 	TIM_Z
.c245	68		pla				pla 								; get Status Register
.c246	8d 34 04	sta $0434			sta 	TIM_SR
.c249	68		pla				pla
.c24a	8d 31 04	sta $0431			sta 	TIM_PC+1 					; save calling address
.c24d	68		pla				pla
.c24e	8d 30 04	sta $0430			sta 	TIM_PC 						; high byte
.c251	ad 31 04	lda $0431			lda 	TIM_PC+1 					; dec PC to point right.
.c254	d0 03		bne $c259			bne 	_TIMDecrement 				; brk bumps it.
.c256	ce 30 04	dec $0430			dec 	TIM_PC
.c259					_TIMDecrement:
.c259	ce 31 04	dec $0431			dec 	TIM_PC+1
.c25c	ba		tsx				tsx 								; and copy SP
.c25d	8e 39 04	stx $0439			stx 	TIM_SP
.c260	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.c262	9a		txs				txs
.c263	4c 41 c1	jmp $c141			jmp 	TIM_Start 					; and start up TIM monitor.
.c266					TIM_UpdateRegisters:
.c266	20 df c1	jsr $c1df			jsr 	TIM_GetHex 					; PC
.c269	b0 23		bcs $c28e			bcs 	_TIMURFail
.c26b	a5 14		lda $14				lda 	zTemp3
.c26d	8d 31 04	sta $0431			sta 	Tim_PC+1
.c270	a5 15		lda $15				lda 	zTemp3+1
.c272	8d 30 04	sta $0430			sta 	Tim_PC
.c275	20 df c1	jsr $c1df			jsr 	TIM_GetHex 					; ignore IRQ
.c278	b0 14		bcs $c28e			bcs 	_TIMURFail
.c27a	a2 00		ldx #$00			ldx 	#0
.c27c					_TIM_URLoop:
.c27c	20 df c1	jsr $c1df			jsr 	TIM_GetHex 					; registers
.c27f	b0 0d		bcs $c28e			bcs 	_TIMURFail
.c281	a5 14		lda $14				lda 	zTemp3
.c283	9d 34 04	sta $0434,x			sta 	Tim_SR,x
.c286	e8		inx				inx
.c287	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.c289	d0 f1		bne $c27c			bne 	_TIM_URLoop
.c28b	4c b1 c0	jmp $c0b1			jmp 	TIM_NewCommand
.c28e					_TIMURFail:
.c28e	4c aa c0	jmp $c0aa			jmp 	TIM_Error
.c291					TIM_LoadMemory:
.c291	20 df c1	jsr $c1df			jsr 	TIM_GetHex 					; target address => zTemp2
.c294	a5 14		lda $14				lda 	zTemp3
.c296	85 12		sta $12				sta 	zTemp2
.c298	a5 15		lda $15				lda 	zTemp3+1
.c29a	85 13		sta $13				sta 	zTemp2+1
.c29c					_TIM_LMLoop:
.c29c	20 df c1	jsr $c1df			jsr 	TIM_GetHex 					; next byte ?
.c29f	b0 0e		bcs $c2af			bcs 	_TIMLMDone 					; no more
.c2a1	a2 00		ldx #$00			ldx 	#0							; write out.
.c2a3	a5 14		lda $14				lda 	zTemp3
.c2a5	81 12		sta ($12,x)			sta 	(zTemp2,x)
.c2a7	e6 12		inc $12				inc 	zTemp2 						; bump address
.c2a9	d0 f1		bne $c29c			bne 	_TIM_LMLoop
.c2ab	e6 13		inc $13				inc 	zTemp2+1
.c2ad	80 ed		bra $c29c			bra 	_TIM_LMLoop
.c2af					_TIMLMDone:
.c2af	4c b1 c0	jmp $c0b1			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Return to file: basic.asm

.c2b2	80 fe		bra $c2b2	_halt:	bra 		_halt
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 a0						.word 	StartROM
>fffe	2a c2					.word TIM_BreakVector

;******  End of listing
